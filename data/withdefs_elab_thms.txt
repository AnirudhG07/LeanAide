{α : Type u_2} [add_zero_class α] : add_zero_class (set α)
{α : Type u} [pseudo_metric_space α] (x y z : α) : has_nndist.nndist x z ≤ has_nndist.nndist x y + has_nndist.nndist y z
{α : Type u} [pseudo_emetric_space α] (s t : set α) : ennreal
(G : Type u_1) [topological_space G] [group G] : Prop
(α : Type u) : Type u
(a : Sort u) (b : Sort v) : Sort (max 1 (imax u v))
{α : Type u_1} (ι : Type u_3) {m : measurable_space α} [preorder ι] (m' : measurable_space α) (hm' : m' ≤ m) : measure_theory.filtration ι m
{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a - b < 0 ↔ a < b
{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (a0 : 0 < a) : a * b ≤ 1
{S₁ : Type u_1} {S₂ : Type u_2} {S₃ : Type u_3} [shelf S₁] [shelf S₂] [shelf S₃] (g : shelf_hom S₂ S₃) (f : shelf_hom S₁ S₂) : shelf_hom S₁ S₃
{R : Type u_1} [add_monoid R] (a : add_units R) : is_add_regular ↑a
{R : Type u_1} {A : Type u_2} [has_zero R] : has_coe_t A (unitization R A)
(C : Type u) [category_theory.category C] : Prop
(α : Type u) [has_add α] : α → α → Prop
{R : Type u_2} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] : mul_action_with_zero R M
 : Type
(P : Type u_2) [preorder P] : Type u_2
{K : Type u} [hring : comm_ring K] : ratfunc K → ratfunc K → ratfunc K
{α : Type u} (g : set (set α)) : set α → Prop
(R : Type u_1) [comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] (n : ℕ) : multilinear_map R (λ (i : fin n), M) (tensor_algebra R M)
(arg_name : name) : name
(n : ℕ) : equiv.perm (fin n)
{G : Type u_1} [add_group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G) : ∃ (x : G), add_order_of x = p
{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (s : alist β) : option (β a) × alist β
 : setoid (Type u)
{M : Type u_1} [has_add M] (r : M → M → Prop) : add_con M
{α : Type} [random α] : io (stream α)
(V : Type u) [quiver V] (L : Sort u_2) : Sort (imax (u+1) (u+1) u_1 u_2)
{α : Type u_1} : ordnode α → α → ordnode α → α → ordnode α → ordnode α
(α : Type u) [t : topological_space α] : Prop
{α : Type u} [has_le α] [decidable_rel has_le.le] (l : list α) : ordnode α
(c : cardinal) : cardinal
{α : Sort u_1} [h : nonempty α] : inhabited α
(Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)] (r : ratfunc Fq) : with_zero (multiplicative ℤ)
{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a - c < b → a < b + c
{Fq : Type u_1} [field Fq] [fintype Fq] : absolute_value (polynomial Fq) ℤ
{R : Type u_1} {ι : Type u_4} [linear_ordered_field R] [fintype ι] {f : ι → R} (hf : f ∈ std_simplex R ι) (x : ι) : f x ∈ set.Icc 0 1
{R : Type u_1} [comm_ring R] (S : submonoid R) (P : Type u_2) [comm_ring P] [algebra R P] : Type u_2
(C : Type u) [category_theory.category C] : Prop
(α : Type u) [topological_space α] : Prop
{α : Type u_1} [add_monoid α] (s : multiset α) (comm : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → add_commute x y) : α
(E : Sort u_1) (α : out_param (Sort u_2)) (β : out_param (Sort u_3)) : Sort (max 1 (imax u_1 u_2 u_3) (imax u_1 u_3 u_2))
{α : Type u_1} {δ : α → Type u_2} [decidable_eq α] (s : finset α) (t : Π (a : α), finset (δ a)) : finset (Π (a : α), a ∈ s → δ a)
{α : Type u} (p : α → Prop) [decidable_pred p] : wseq α → wseq α
{α : Type u_1} [linear_order α] (pred : α → α) (hle_pred_iff : ∀ {a b : α}, a ≤ pred b ↔ a < b) : pred_order α
{α : Type u_1} (p : α → Prop) [decidable_pred p] (a : α) : option α
(R : Type u) (X : Type v) [comm_ring R] : free_non_unital_non_assoc_algebra R X → free_non_unital_non_assoc_algebra R X → Prop
{G : Type w} [topological_space G] [has_neg G] [has_continuous_neg G] {ι : Type u_1} : has_continuous_neg (ι → G)
{m n : ℕ} (f : fin2 m → fin2 n) (k : ℕ) : fin2 (m + k) → fin2 (n + k)
{α : Type u} {β : Type v} {γ : Type u_1} [topological_space α] [topological_space β] [topological_space γ] {f : α → γ} (hf : continuous f) : continuous (λ (x : α × β), f x.fst)
(Γ₀ : Type u_1) [linear_ordered_comm_group_with_zero Γ₀] : directed ge (λ (γ₀ : Γ₀ˣ), filter.principal {γ : Γ₀ | γ < ↑γ₀})
{R : Type u_1} [ring R] : R → power_series R → power_series R
{α : Type u} : computation α → α
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (X : C) : Type (max u v)
(n : ℕ) : surreal
{G : Type u_1} [has_mul G] : G → G → G
{n : ℕ} (x y : bitvec n) : bitvec n
{α : Type} {ds₁ ds₂ : list ℕ} [s : has_mul α] (x : holor α ds₁) (y : holor α ds₂) : holor α (ds₁ ++ ds₂)
{α : Type u} [monoid α] {r : α} (hr : invertible r) (s : α) (hs : s = r) : invertible s
(p : ℕ) [fact (nat.prime p)] (a : ℤ) : zmod.legendre_sym p a = 0 ↔ ↑a = 0
(α : Type u) [has_le α] : Type u
{α : Type u} : computation α → ℕ → option α
(α : Type u) : Type u
{α : Type u_3} {β : Type u_4} [has_inf α] [has_top α] [has_inf β] [has_top β] (f : inf_top_hom α β) : top_hom α β
(R : Type u_1) {α : Type u_2} (G : simple_graph α) [has_zero R] [has_one R] : matrix α (sym2 α) R
(Fq F : Type) [field Fq] [field F] [algebra (ratfunc Fq) F] : Prop
{α : Type u} [pseudo_metric_space α] {s t : set α} : 0 ≤ metric.Hausdorff_dist s t
{K : Type u} [field K] (s : subfield K) {l : list K} : (∀ (x : K), x ∈ l → x ∈ s) → l.sum ∈ s
(α : Type u) (r : α → α → Prop) : Prop
{R : Type u_1} {a : R} [cancel_monoid_with_zero R] [nontrivial R] : is_regular a ↔ a ≠ 0
{G : Type u_1} [add_group G] : has_bot (add_subgroup G)
{m : Type u_1 → Type u_2} [monad m] {α : Sort u_3} {β γ : Type u_1} (f : α → m β) (g : β → m γ) (x : α) : m γ
{α : Type u} (x : α) : free_comm_ring α
{a b : ℕ} (h : a = b) : bitvec a → bitvec b
(R : Type u_1) [ordered_comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] : Type u_2
{β : Type u} {α : Type v} [add_comm_monoid β] (s : finset α) (f : α → β) : β
(α : Type u_1) (ι : Type u_2) : Type (max u_1 u_2)
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (s : subsemigroup M) (t : subsemigroup N) : subsemigroup (M × N)
(t : Type u → Type u → Type u) : Type (u+1)
{α : Type u_1} {β : Type u_2} (t : α) (ts : list α) (r : list β) : list α → (list α → β) → list α × list β
(α : Type u_1) [partial_order α] : PartialOrder
{m : Type u_2} {n : Type u_3} {α : Type v} (M : matrix m n α) : matrix n m α
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [uniform_space α] [uniform_space β] [uniform_space γ] (f : α → β → γ) : Prop
{α : Type u_2} [add_zero_class α] : add_zero_class (filter α)
{Γ : Type u_1} {R : Type u_2} [partial_order Γ] [has_zero R] (a : Γ) : zero_hom R (hahn_series Γ R)
(𝕜 : Type u_1) (A : Type u_2) [comm_semiring 𝕜] [topological_space 𝕜] [has_continuous_add 𝕜] [has_continuous_const_smul 𝕜 𝕜] [non_unital_non_assoc_semiring A] [topological_space A] [module 𝕜 A] : set (weak_dual 𝕜 A)
{α : Type u_1} [has_mul α] [has_one α] : list α → α
 : Type
(C : Type u) [category_theory.category C] : Prop
{r p : nnreal} : ↑(r - p) = ↑r - ↑p
{G : Type u_1} [group G] (H : ℕ → subgroup G) (hH : is_descending_central_series H) (n : ℕ) : lower_central_series G n ≤ H n
{R : Type u} [comm_semiring R] {A : Type v} [comm_semiring A] [algebra R A] : comm_semiring (submodule R A)
{α : Type u_1} {β : Type u_2} [preorder β] (f : α → β) : preorder α
{α : Type u_1} {β : Type u_2} (f : α → β) : regular_expression α → regular_expression β
{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) (s : set α) : Prop
(M : Type u_1) [mul_one_class M] (c : con M) : submonoid (M × M)
(L : Type v) (M : Type w) [lie_ring L] [add_comm_group M] : Type (max v w)
(l : list ℕ) (n : ℕ) : finset ℕ
{α : Type u} [preorder α] {f : ℤ → α} (hf : antitone f) (n : ℤ) {x : α} (h1 : f (n + 1) < x) (h2 : x < f n) (a : ℤ) : f a ≠ x
{α : Type u_1} [β : semi_normed_ring α] : non_unital_semi_normed_ring α
{α : Type u_1} [measurable_space α] {f : ℕ → α → ennreal} {g : α → ennreal} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {F : J → C} (B : category_theory.limits.bicone F) : Type (max u v)
{α : Type u} (f : filter (filter α)) : filter α
(R : Type u_1) [comm_ring R] [local_ring R] (q : ℕ) [char_R_q : char_p R q] : q = 0 ∨ is_prime_pow q
{F : Type} [comm_semiring F] (q : ℕ) (f g : polynomial F) : Prop
 : Type (u+1)
{α : Type u} {β : Type v} (f : β → α ⊕ β) (b : β) : computation α
(α : Type u_1) : computation α
{A : Type u_2} [add_group A] (H : add_subgroup A) : Prop
(R : Type u_1) (M : Type u_2) [ordered_semiring R] [ordered_add_comm_monoid M] [smul_with_zero R M] : Prop
{α : Type u_1} [decidable_eq α] (l : list α) (x : α) (h : x ∈ l) : α
{G : Type u_1} [has_add G] : G → G → G
(n : ℕ) (t : Type u_1) : typevec n
{G : Type u_1} [group G] (H : subgroup G) {x : G} : x ∈ H → x⁻¹ ∈ H
(c : cardinal) : Prop
 : Type
(C : Type u) [category_theory.category C] [category_theory.limits.has_images C] : Prop
(α : Type u_1) [preorder α] (f : closure_operator α) : α → α
(M : Type u_1) [add_zero_class M] (c : add_con M) : add_submonoid (M × M)
(R : Type u_1) [comm_semiring R] (X : Type u_2) : Type (max u_1 u_2)
(M : Type u_1) [has_add M] : galois_insertion add_subsemigroup.closure coe
 : real.cos (real.pi / 6) ^ 2 = 3 / 4
{G : Type u_1} [group G] : has_bot (subgroup G)
{G : Type u_1} [add_group G] (k : set G) : add_subgroup G
(X : Top) : algebraic_geometry.SheafedSpace (category_theory.discrete punit)
{R : Type u_1} [comm_ring R] {A : Type u_2} [comm_ring A] [algebra R A] : has_bracket (derivation R A A) (derivation R A A)
{α : Type u_1} [preorder α] [decidable_rel has_lt.lt] (l : list α) : with_top α
(p : char → Prop) [decidable_pred p] : parser char
(X : Type u) [has_mul X] [has_zero X] [has_lt X] : Prop
{R : Type u₁} [semiring R] (r : R → R → Prop) : Type u₁
{α : Type u_1} [cancel_comm_monoid_with_zero α] [normalization_monoid α] : associates α → α
(M₀ : Type u_4) : Type u_4
{C : Type u₁} [category_theory.category C] : category_theory.faithful category_theory.yoneda
{F : Type} [comm_semiring F] {q : ℕ} {f : polynomial F} (hf : polynomial.has_separable_contraction q f) : ℕ
 : Type (u_1+1)
(α : Type u_1) [preorder α] : lower_adjoint id
 : Type (max (u+1) u (v+1))
{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) (b : β) : function.injective (λ (a : α), f a b)
{α : Type u_1} (f : α → α) (x : α) : function.is_periodic_pt f 0 x
{α : Type u} {β : α → Type v} [decidable_eq α] : list (sigma β) → list (sigma β) → list (sigma β)
{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (s : finmap β) : finmap β
{C : Type u} [category_theory.category C] (X : C) : Type (max u v)
{α : Type u} (t : ordnode α) : list α
 : parser unit
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) (s : set L) (hs : s = ↑S) : intermediate_field K L
{n : ℕ} (F : typevec (n + 1) → Type u_1) (α : Type u) (β : typevec n) : Type u_1
{R : Type u_1} [has_add R] (c : R) : Prop
(S₀ : Type u_4) : Type u_4
{F : Type u → Type u} [functor F] {α : Type u} (x : F α) : set α
{E : Type u_2} [non_unital_normed_ring E] [star_ring E] [cstar_ring E] : normed_star_group E
{α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {f : α → β} : isometry f ↔ ∀ (x y : α), has_dist.dist (f x) (f y) = has_dist.dist x y
{α : Type u_1} {β : Type u_2} [nontrivial α] {f : α → β} (hf : function.injective f) (y : β) : ∃ (x : α), f x ≠ y
 : unit
(R : Type u) (A : Type w) [comm_semiring R] [semiring A] [algebra R A] (n : ℕ) [inv : invertible ↑n] : invertible ↑n
(n : ℕ) : ℕ
{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) (x : X) (hsat : jordan_holder_lattice.is_maximal s.top x) : composition_series X
{α : Type u} : ordnode α → ℕ → ordnode α
{M : Type u_5} [nontrivial M] [hM : comm_monoid_with_zero M] (h : ∀ (a : M), is_unit a ∨ a = 0) : comm_group_with_zero M
{M : Type u_1} [add_monoid M] (x : M) : is_add_submonoid (multiples x)
(α : Type u_6) [topological_space α] [h : measurable_space α] : Prop
(X : algebraic_geometry.LocallyRingedSpace) : algebraic_geometry.RingedSpace
 : ℕ → option ℕ
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f) : quotient_map f
(R : Type u) (A : Type v) [comm_semiring R] [semiring A] [algebra R A] : Type v
(α : Type u) [group α] : category_theory.groupoid (category_theory.single_obj α)
{M : Type u_1} [has_mul M] (S : subsemigroup M) {x y : M} : x ∈ S → y ∈ S → x * y ∈ S
{α : Type u_1} [has_zero α] [has_one α] [has_add α] [has_neg α] : ℤ → α
{n : ℕ} (P : mvpfunctor n) (α : typevec n) : Type u
{α : Type u_1} (r : α → α → Prop) (a : α) : principal_seg (subrel r {b : α | r b a}) r
 : list bool → bool
 : ℕ → enat
 : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b ∧ ordinal.omega ≤ b}
{R : Type u_1} [comm_ring R] [topological_space R] {M : submonoid R} : ring_topology (localization M)
(M : Type u_9) (N : Type u_10) [has_one M] [has_one N] : Type (max u_10 u_9)
{p : ℕ} (hp : nat.prime p) {R : Type u_1} [comm_ring R] [is_domain R] {n : ℕ} (hn : n ≠ 0) (h : irreducible (polynomial.cyclotomic (p ^ n) R)) : irreducible (polynomial.cyclotomic p R)
(J : Type u₁) [category_theory.category J] : Prop
 : nat.arithmetic_function ℕ
{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) (s : finmap β) : finmap β
{n : ℕ} : fin2 n → fin2 n → fin2 n
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop
{b : ℕ} {l : list ℕ} (hl : ∀ (x : ℕ), x ∈ l → x < b + 2) : nat.of_digits (b + 2) l < (b + 2) ^ l.length
 : ℕ → ℤ
(C : Type u) [category_theory.category C] : category_theory.grothendieck_topology C
{α : Type u_1} {p : α → Prop} [encodable α] [decidable_pred p] (h : ∃ (x : α), p x) : {a // p a}
{K : Type u} [field K] (s : subfield K) {x : K} : x ∈ s → -x ∈ s
{α : Type u_1} [preorder α] [locally_finite_order α] (a b : α) : multiset α
(α : Type u_1) [uniform_space α] : has_coe_t α (uniform_space.completion α)
{α : Type u_1} {β : Type u_2} [encodable α] [inhabited α] {r : β → β → Prop} (f : α → β) (hf : directed r f) : ℕ → α
(S : Type u_4) (M : out_param (Type u_5)) [add_zero_class M] [set_like S M] : Type
(R : Type u_1) [ring R] : algebra_map ℤ R = int.cast_ring_hom R
 : Type
{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3
(𝕜 : Type u_1) (E : Type u_2) [is_R_or_C 𝕜] [inner_product_space 𝕜 E] : galois_connection submodule.orthogonal submodule.orthogonal
(L : first_order.language) {M : Type w} [L.Structure M] (A : set M) (α : Type u_1) : Type (max u_1 w)
(p : Set → Prop) (A : Class) : Prop
(Fq F : Type) [field Fq] [field F] [algebra (polynomial Fq) F] : subalgebra (polynomial Fq) F
(α : Type u_3) [has_inf α] : inf_hom α α
 : ennreal → nnreal
{C : Type u} [category_theory.category C] [category_theory.limits.has_limits C] : category_theory.limits.has_colimits (algebraic_geometry.PresheafedSpace C)
(C : Type u) : Type u
{C : Type u} [category_theory.category C] (J : C) : Prop
{X : Type u} [topological_space X] (x₀ x₁ : X) : setoid (path x₀ x₁)
{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] (y : R) [algebra R S] [is_localization.away y S] [H : ideal.is_jacobson R] : ideal.is_jacobson S
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (k : ℕ) : lie_ideal R L → lie_ideal R L
(C : Type u) : Type u
{α : Type u} {β : Type v} : α ⊕ β → option β
{α : Type u_1} {β : Type u_2} [mul_one_class α] [comm_group β] {f : α → β} (hf : is_monoid_hom f) : is_monoid_hom (λ (a : α), (f a)⁻¹)
{α : Type u_1} [primcodable α] (p : α → Prop) : Prop
{C : Sort u_1} : pempty → C
{α : Type u_1} {p : multiset α → Sort u_2} (s : multiset α) : (Π (s : multiset α), (Π (t : multiset α), t < s → p t) → p s) → p s
{α : Type u_1} : has_le (subtype setoid.is_partition)
(R : Type u) [semiring R] (q : ℕ) [hp : char_p R 0] [hq : exp_char R q] : q = 1
 : Type
{X : Type u_1} [topological_space X] (s : set X) : set X
{R : Type u} [semiring R] (p : polynomial R) : R
{R : Type u_1} [comm_ring R] (S : submonoid R) {P : Type u_2} [comm_ring P] [algebra R P] [loc : is_localization S P] (x : P) : fractional_ideal S P
{ι : Type u_1} (A : ι → Type u_2) [add_monoid ι] [graded_monoid.gmonoid A] : monoid (A 0)
{R : Type u} [comm_ring R] : has_quotient R (ideal R)
{α : Type u} {β : Type v} [add_group α] [add_group β] (f : α → β) : Prop
{α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : a / c ≤ b / d → (a * d - b * c) / (c * d) ≤ 0
{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] [fact (even (fintype.card n))] : has_neg (matrix.special_linear_group n R)
{R : Type u_2} {M : Type u_3} [semiring R] [add_comm_monoid M] [module R M] : canonically_ordered_add_monoid (submodule R M)
{α : Type u} {β : Type v} (l : lazy_list α) (f : α → β) : lazy_list β
(S : Type u_3) (G : Type u_4) [sub_neg_monoid G] [set_like S G] : Type
(L : first_order.language) (M : Type w) [L.Structure M] : Prop
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J → C) [category_theory.limits.has_product f] : category_theory.limits.has_biproduct f
(Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)] : Type
(M : Type u) [topological_space M] [has_mul M] : Prop
(α : Type u) [topological_space α] : Type u
{α : Type u_1} {β : α → Type u_2} (γ : Type u_3) (fγ : (Σ (a : α), β a → γ) → γ) : W_type β → γ
{A : Type v} [ring A] : lie_ring A
{α : Type u_1} {β : Type u_2} (f : part α) (g : α → part β) : part β
(T : Type u) [category_theory.category T] : Type (max u v)
(α : Type u_2) : Type u_2
{M : Type u_1} [has_mul M] (p : M) : Prop
(L : first_order.language) : Prop
{α : Type u} [group α] [has_lt α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a : α} : 1 < a⁻¹ ↔ a < 1
 : Type
(α : Type u) [add_group α] : Prop
{K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : generalized_continued_fraction.int_fract_pair K
{α : Type u} [ring α] {a b : α} : a ∣ a + b ↔ a ∣ b
{p : Prop} (a : erased p) : p
{R : Type u_1} [comm_monoid R] : star_semigroup R
{K : Type u_1} [division_ring K] (s : seq (generalized_continued_fraction.pair K)) (n : ℕ) : seq (generalized_continued_fraction.pair K)
{K : Type u} [field K] (S : subfield K) (s : set K) (hs : s = ↑S) : subfield K
 : Type
(α : Type u) : Type u
{G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * b⁻¹
{E : Type u_1} (c : E) : Type
{α : Type u_1} [partial_order α] : subsingleton (pred_order α)
{k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_ring k] [group G] [add_comm_group V] [module k V] (ρ : representation k G V) (g : G) : k
(x : ℤ) : ↑(x.nat_abs) ^ 2 = x ^ 2
{α : Type u_1} [decidable_eq α] (s : finset α) : finset (equiv.perm α)
(E : Type u_6) [add_comm_group E] [has_norm E] : Prop
 : Type
{α : Type u} {β : Type v} (m : α → β) (f : filter α) : filter β
{M : Type u_1} [add_zero_class M] (S : add_submonoid M) : set M
{L : first_order.language} (T : L.Theory) : Type (max u v (w+1))
(R : Type u_1) [comm_ring R] [is_domain R] [decidable_eq R] [fintype R] : field R
{J : Type u₁} [category_theory.category J] (j₁ j₂ : J) : Prop
 : cardinal → ordinal
 : real.sin (real.pi / 6) = 1 / 2
{M : Type u_4} [topological_space M] [monoid M] [has_continuous_mul M] (s : submonoid M) : submonoid M
{α : Type u_1} [topological_space α] (B : set (topological_space.opens α)) : Prop
{α : Type u} [topological_space α] (s : set α) : Prop
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (x y : M) : Prop
(α : Type u_3) [uniform_space α] [add_group α] : Prop
(M : Type u) [has_mul M] : Magma
{α : Type u_1} {γ : Type u_3} [topological_space α] [measurable_space α] [opens_measurable_space α] [topological_space γ] [measurable_space γ] [borel_space γ] {f : α → γ} (hf : continuous f) : measurable f
(α : Type u_2) [preorder α] : Type u_2
(N : Type u_2) [add_monoid N] : Prop
(C : Type u) : Type u
{α : Type u} {β : Type v} (f : α → β) (g : β → α) : set.maps_to f (function.fixed_points (g ∘ f)) (function.fixed_points (f ∘ g))
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C] : category_theory.limits.has_binary_biproducts C
{R : Type u} {Γ₀ : Type v} [ring R] [linear_ordered_comm_group_with_zero Γ₀] (v : valuation R Γ₀) : subring R
{α : Type u_6} : mul_action (function.End α) α
(n : ℕ) [has_zero (fin n)] : Type
{α : Type u_1} [add_semigroup α] [partial_order α] [contravariant_class α α (function.swap has_add.add) has_le.le] : add_right_cancel_semigroup α
{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : b < -a + c → a + b < c
 : num → num → num
{L : first_order.language} {M : Type w} [nonempty M] [L.Structure M] : L.skolem₁.Structure M
(G : Type u_1) [add_group G] : set G
{M : Type u_1} [add_monoid M] (S : add_submonoid M) : add_submonoid M
(F : Type u_1) [field F] (E : Type u_2) [field E] [algebra F E] : intermediate_field F E
 : two_pointing Prop
{α : Type u_1} {p : α → Prop} [encodable α] [decidable_pred p] (h : ∃ (x : α), p x) : α
{α : Type u_1} [normed_division_ring α] {a : α} (ha : a ≠ 0) : filter.tendsto (has_mul.mul a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)
{α : Type u_1} [has_mul α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {b c : α} (bc : b < c) (a : α) : a * b < a * c
(α : Sort u_1) [h : nonempty α] : α
(G : pgame) : Prop
{α : Type u} [uniform_space α] {f : filter α} (hf : cauchy f) {U : ℕ → set (α × α)} (U_mem : ∀ (n : ℕ), U n ∈ uniformity α) (n : ℕ) : set α
{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (s : finmap β) : option (β a) × finmap β
{α : Type u} [preorder α] (a : α) : a ≤ a
{G : Type u_1} [add_group G] (H : add_subgroup G) : add_subgroup G
{α : Type u} {β : Type v} (f : ultrafilter α) (m : α → ultrafilter β) : ultrafilter β
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1
{α : Type u_1} (l : ordnode α) (x : α) (r : ordnode α) : ordnode α
 : pos_num → pos_num
{α : Type u_1} {β : Type u_2} (f : α → β → β) (H : left_commutative f) (b : β) (s : multiset α) : β
{α : Type u} (p : α → Prop) [decidable_pred p] : ordnode α → ordnode α
{n : Type u_3} {α : Type v} [add_monoid α] [star_add_monoid α] : star_add_monoid (matrix n n α)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_colimit (category_theory.limits.pair X Y)] : category_theory.split_mono category_theory.limits.coprod.inl
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) : category_theory.simple X ↔ is_simple_order (category_theory.subobject X)
(β : Type w) (C : Type u) : Type (max w u)
(α : Type u_1) [partial_order α] : circular_partial_order α
(α : Type u) : Type u
{R : Type u} [non_assoc_semiring R] (S : subsemiring R) (s : set R) (hs : s = ↑S) : subsemiring R
(attr_name : name) : name
{α : Type u_1} {β : Type u_2} {f : α → β} : monotone (set.image f)
(V : Type u_1) [quiver V] : prefunctor V V
(L : first_order.language) : Type v
{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] (X : C) : Type (max u v)
{ι : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [has_one R] [has_zero ι] (A : ι → S) : Prop
{k : Type u_1} [ring k] {V : Type u_2} {P : Type u_3} [add_comm_group V] [module k V] [add_torsor V P] : add_action V (affine_subspace k P)
(R : Type u_1) [ring R] : algebra ℤ R
(α : Type u) : Type u
{α : Type u} (r : α → α → Prop) (s : set α) : Prop
{M₀ : Type u_1} [monoid_with_zero M₀] : M₀ → M₀
 : filter.tendsto (λ (x : ℝ), real.exp (-x)) filter.at_top (nhds 0)
(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom A B
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) : graded_algebra (clifford_algebra.even_odd Q)
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f g : add_hom M N) : add_subsemigroup M
{α : Type u_1} [decidable_eq α] (xs : list α) (x default : α) : α
(α : Type u) [pseudo_metric_space α] : Type u
{α : Type u} [preorder α] {x y : α} (h : x = y) : y ≤ x
{n : ℕ} {F : typevec n → Type v} [mvfunctor F] {α : typevec n} (x : F α) (i : fin2 n) : set (α i)
(G : Type u) [add_monoid G] : Prop
(α : Type u_1) {ι : Type u_2} (i : ι) : Type u_1
{𝕜 : Type u_1} {E : Type u_3} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] {A : set E} (hA : balanced 𝕜 A) : absorbs 𝕜 A A
{α : Sort u_1} {β : Sort u_2} {f : α → β} (hf : function.bijective f) (b : β) : ∃! (a : α), f a = b
(α : Type u) : Type u
{G : Type u_1} [group G] {s : set G} (h : is_subgroup s) : subgroup G
{α : Type u} [preorder α] {a b : α} : a = b → a ≤ b
 : Type v
{x y z : ℤ} (h : pythagorean_triple x y z) (k : ℤ) : pythagorean_triple (k * x) (k * y) (k * z)
{α : Type} (a : α) (v : ℕ → α) : ℕ → α
{α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {f : ι → α} (H : bdd_above (set.range f)) (c : ι) : f c ≤ supr f
{α : Type u_1} [has_one α] [has_add α] : pos_num → α
{α : Type u_1} {β : α → Type u_2} (f : (Π (a : α), part (β a)) → Π (a : α), part (β a)) : stream (Π (a : α), part (β a))
(R : Type u) [non_unital_semiring R] : Type u
{V : Type u} (G : simple_graph V) : Type u
{B : Type u} [quiver B] {a b : B} : quiver.path a b → category_theory.free_bicategory.hom a b
{α : Type u_1} [partial_order α] [succ_order α] {a : α} : is_max a → order.succ a = a
 : Type
 : Type
{α : Type u_1} [linear_ordered_field α] (f : cau_seq α has_abs.abs) : Prop
(H : Type u) [topological_space H] : Type u
{n : ℕ} {α : Type u_1} : vector α n → array n α
{α : Type u_1} [linear_ordered_ring α] [floor_ring α] (a : α) : α
 : category_theory.reflective CompHaus_to_Top
(n d : pos_num) : num
(G : Type u) [monoid G] : ℕ
{α : Type u_1} (p : α → Prop) [decidable_pred p] (s : finset α) : finset (subtype p)
 : Type
 : Type
(R : Type u_1) (η : Type u_2) [semiring R] [fintype η] : basis η R (η → R)
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (a : category_theory.over P) : ↑a = 0 ↔ a.hom = 0
{α : Type u} [pseudo_metric_space α] : has_nndist α
{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order α] [preorder β] [bounded_order β] (gi : galois_coinsertion l u) : bounded_order α
{α : Type u} : complete_lattice (topological_space α)
(G : Type u_1) [add_comm_group G] : add_subgroup G
{a b c : Prop} : a ∧ (b ∨ c) ↔ a ∧ b ∨ a ∧ c
{α : Type u_1} (s : cycle α) : Prop
{α : Type u_1} {P : α → Prop} : antitone (λ (s : set α), ∀ (x : α), x ∈ s → P x)
{α : Type u} [preorder α] {a b c : α} : b < c → a < b → a < c
{M : Type u_1} [monoid M] (a : M) : Prop
{n : ℕ} (i : fin (2 ^ n)) : bitvec n
{α : Type u} {β : α → Type v} [decidable_eq α] : list (sigma β) → list (sigma β)
{a b c : Prop} : (a ∨ b) ∧ c ↔ a ∧ c ∨ b ∧ c
{R : Type u_1} [has_mul R] (c : R) : Prop
{G : Type u_1} {s : set G} [group G] : is_normal_subgroup (group.normal_closure s)
{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a < b + c → a - c < b
(R : Type u_1) [comm_ring R] [is_domain R] : Prop
{α : Type u_1} [decidable_eq α] (s : multiset α) (H : ∀ (x : α), x ∈ s) : fintype α
{α : Type u} [preorder α] {a b c : α} : a ≤ b → b ≤ c → a ≤ c
{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) (n : ℕ) : K
{α : Type u_1} {β : Type u_2} (f : ℕ → α → β → β) : ℕ → β → list α → β
(n m : ℕ) : ℕ
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] [locally_compact_space (α × β)] : continuous continuous_map.curry
(α : Type u) : Type u
{α : Type u_2} {β : Type u_3} [decidable_eq β] [add_monoid α] [add_action α β] : add_action α (finset β)
{α : Type u_1} [fintype α] (p : α → Prop) [decidable_pred p] (hp : ∃! (a : α), p a) : α
{α : Type u_1} [decidable_eq α] (s : multiset α) : finset α
{M : Type u_1} [mul_one_class M] : has_top (submonoid M)
{V : Type u} (G : simple_graph V) (v : V) : set (sym2 V)
{M : Type u_1} [mul_one_class M] (s : set M) : submonoid M
(R : Type u) [comm_ring R] : Type u
{α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (b0 : 0 < b) : a * b ≤ 1
{α : Type u_1} {β : Type u_2} (f : α → option β) (s : multiset α) : multiset β
{α : Type u} (s : wseq α) (p : α → bool) : computation bool
{α : Type u} {β : Type v} (f : ℕ → α → β → β) (start : ℕ) (b : β) (as : list α) : β
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : has_zero (lie_subalgebra R L)
{α : Type u} [preorder α] {s t : set α} (h : bdd_above t) : bdd_above (s ∩ t)
{α : Type u_1} (r : α → α → Prop) [is_well_order α r] (a : α) : ordinal
{K : Type u} [hfield : field K] (x : ratfunc K) : polynomial K
 : pos_num → num
 : Type (u+1)
{α : Type u} [topological_space α] {s : set α} (H : is_preconnected s) : is_preconnected (closure s)
{α : Type u_1} (t : α) : list α → list (list α)
(n : ℕ) (a : zmod n) : zmod n → zmod n
(α : Type u) (r : α → α → Prop) [is_symm α r] : is_symm_op α Prop r
{α : Type u} [partial_order α] {a b : α} : a ≤ b → b ≤ a → a = b
(β : Type u_2) [pseudo_metric_space β] [add_monoid β] [has_lipschitz_add β] : nnreal
{R : Type u} [ring R] (s : set R) : set R
{R : Type u} {M : Type v} [semiring R] [add_comm_monoid M] [module R M] (self : submodule R M) : add_submonoid M
{m : Type u_2} {n : Type u_3} {α : Type v} [decidable_eq m] (M : matrix m n α) (i : m) (b : n → α) : matrix m n α
(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [fintype K] [finite_dimensional K V] : fintype V
{C : Type u} [category_theory.category C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y] : C
{α : Type u} : dense_embedding has_pure.pure
{K : Type u} [hfield : field K] (x : ratfunc K) : polynomial K
{k : Type u_1} [division_ring k] {ι : Type u_4} (s : finset ι) (h : ↑(s.card) ≠ 0) : s.sum (λ (i : ι), finset.centroid_weights k s i) = 1
(α : Type u_8) (β : Type u_9) [has_Sup α] [has_Sup β] : Type (max u_8 u_9)
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : complete_lattice (lie_subalgebra R L)
{α : Type u_1} [decidable_eq α] {δ : α → Type u_2} (m : multiset α) (t : Π (a : α), multiset (δ a)) : multiset (Π (a : α), a ∈ m → δ a)
{n : ℕ} (c : composition n) (j : fin n) : fin c.length
(x y : ereal) : ereal
 : bool → bool
(G : Type u_1) [add_group G] [topological_space G] : Type u_1
(α : Type u_1) : Type u_1
{α : Type u} [has_le α] [decidable_rel has_le.le] (f : α → α) (x : α) : ordnode α → ordnode α
(K : Type v) (L : Type w) [field K] [field L] [algebra K L] (f : polynomial K) : Prop
(n : ℕ) (s : set ℕ) : Prop
{α : Type u_1} {β : Type u_2} : option α → β → (α → β) → β
 : matrix (fin 2) (fin 2) ℤ
(α : Type u_4) : Type u_4
{G : Type u} [add_group G] (B : add_group_filter_basis G) : G → filter G
{α : Type u_1} [topological_space α] (s : topological_space.positive_compacts α) : topological_space.nonempty_compacts α
(α : Type u_3) [topological_space α] : Prop
(F : Type u_1) (K : Type u_2) [field F] [field K] [algebra F K] : Prop
{α : Type u} {β : Type v} [semigroup β] (f : α → β) : α → list α → β
{α : Type u_1} [encodable α] : list α → ℕ
{n : ℕ} {α : fin n → Type u} (a : d_array n α) (i : fin n) : α i
{α : Type u_1} : lists α → list (lists α)
(C : Type u) [category_theory.category C] : Prop
{α : Type u} {β : Type v} {p : α → Prop} (f : Π (a : α), p a → β) (l : list α) : (∀ (a : α), a ∈ l → p a) → list β
{α : Type u} [preorder α] {a b : α} (h : a < b) : ¬b ≤ a
{M : Type u_1} [add_monoid M] (u : add_units M) (a : M) : is_add_unit (↑u + a) ↔ is_add_unit a
{α : Sort u} (f : α → α) (h : function.involutive f) : equiv.perm α
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : a < 0) (hb : b ≤ 0) : a + b < 0
 : pgame → pgame
(a b : simplex_category) : Type
(X Y : Type u) : category_theory.limits.binary_fan X Y
{α : Type u_1} (l : filter α) (β : Type u_2) : setoid (α → β)
(R : Type u_1) [comm_ring R] [with_ideal R] (M : Type u_2) [add_comm_group M] [module R M] : topological_space M
{R : Type u_1} {a b : R} [comm_semigroup R] : is_regular (a * b) ↔ is_regular a ∧ is_regular b
{α : Type u_1} [has_sub α] [has_zero α] (a b : with_top α) : with_top α
{α : Type u} : lazy_list α → lazy_list α
(α : Type u) [uniform_space α] : Prop
{α : Type u_1} {p : Prop} {q : α → Prop} : p → ∀ (x : α), q x ↔ ∀ (x : α), p → q x
{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A B : matrix n n α) (h : B.mul A = 1) : invertible A.det
(α : Type u) [s : lattice α] [add_comm_group α] [covariant_class α α has_add.add has_le.le] : distrib_lattice α
(k : Type u₁) (G : Type u₂) [semiring k] : Type (max u₁ u₂)
(R : Type u) [ring R] : Prop
{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b) : closure (set.Ico a b) = set.Icc a b
(a b : num) : num
{α₁ : Type u_1} {β₁ : Type u_2} [decidable_eq α₁] (a : α₁) (e : equiv.perm β₁) : equiv.perm (α₁ × β₁)
{α : Type u_2} [add_monoid α] (s : set α) : Prop
{G : Type u_3} [add_group G] (P : add_subgroup G) : Prop
{α : Type u} [topological_space α] {s : set α} : is_closed (frontier s)
(G : pgame) : Prop
{m : Type u → Type u} [applicative m] {α β : Type u} (F : α → m β) (x : free_add_semigroup α) : m (free_add_semigroup β)
{R : Type u} {A : Type v} [comm_semiring R] [ring A] [algebra R A] (a : A) (r : R) : A
{α : Sort u_1} (P : Prop) [decidable P] (a b : α) : dite P (λ (h : P), a) (λ (h : ¬P), b) = ite P a b
{α : Type u_2} [decidable_eq α] [has_sub α] : has_sub (finset α)
{α : Type u} {line col : ℕ} (f : thunk α) : α
(α : Type u_5) (β : Type u_6) [non_unital_non_assoc_semiring α] [non_unital_non_assoc_semiring β] : Type (max u_5 u_6)
(α : Type u_1) : Type u_1
(C : Type u₁) [category_theory.category C] (D : Type u₁) [category_theory.category D] : category_theory.category (C ⊕ D)
{α : Type u} {f g : α → α} (h : function.commute f g) : set.bij_on f (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g))
{R : Type u} [semiring R] (p : polynomial R) : polynomial R
{α : Type u} (a : α) : seq α → seq α
 : Type (u+1)
{α : Type u} [uniform_space α] {f : filter α} (hf : cauchy f) {U : ℕ → set (α × α)} (U_mem : ∀ (n : ℕ), U n ∈ uniformity α) (n : ℕ) : α
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1
{α : Type u_1} {M : Type u_5} [has_zero M] {b : M} (h : b ≠ 0) : function.injective (λ (a : α), finsupp.single a b)
{α : Type u} (P : α → Prop) : ordnode α → Prop
{α : Type u_1} {β : Type u_2} [semilattice_sup α] [order_bot α] (s : finset β) (f : β → α) : α
{α : Type u_1} {β : Type u_2} [encodable α] (f : β → α) (finv : α → option β) (linv : ∀ (b : β), finv (f b) = option.some b) : encodable β
{α : Type u_1} {β : Type u_2} (r : α → β → Prop) (s : finset α) (b : β) [Π (a : α), decidable (r a b)] : finset α
{α : Type u_1} {𝒜 : finset (finset α)} {r : ℕ} : 𝒜.slice r ⊆ 𝒜
{α : Type u} [t : topological_space α] (s : set α) : Prop
{α : Type u_2} {β : Type u_3} {r : α → β → Prop} (c : concept α β r) : concept β α (function.swap r)
(α : Type u_1) : Type u_1
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0) : a + b ≤ 0
(E : Type u_6) : Type u_6
(R : Type u) [semiring R] : ℕ → Prop
{R : Type u} [ring R] (self : subring R) : add_subgroup R
(V : Type u) [quiver V] : Type u
{α : Type u_1} (l : ordnode α) (x : α) (m : ordnode α) (y : α) (r : ordnode α) : ordnode α
{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R (-x) (-y) → same_ray R x y
{α : Type u_1} (g : generalized_continued_fraction α) [has_one α] : Prop
{α : Type u_1} {β : Type u_2} [add_comm_group α] [uniform_space α] [complete_space α] {f : β → α} : summable f ↔ cauchy_seq (λ (s : finset β), s.sum (λ (b : β), f b))
(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] : Type v
 : Type
{α : Type u} [linear_order α] (x y : α) {P : Sort u_1} (h₁ : x < y → P) (h₂ : x = y → P) (h₃ : y < x → P) : P
{a b c : Prop} : a ∨ b ∧ c ↔ (a ∨ b) ∧ (a ∨ c)
(n : ℕ) : ℕ
{α : Type u} (r : α → α → Prop) [is_well_order α r] : linear_order α
{α : Type u_1} [preorder α] (s : ordset α) : ℕ
{α : Type u_1} : list (option α) → option (list α)
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1
{α : Type u_1} [add_group α] : has_quotient α (add_subgroup α)
{α : Type u_1} [topological_space α] (s : set α) : filter α
{C : Type u} [category_theory.category C] [category_theory.non_preadditive_abelian C] : category_theory.preadditive C
(α : Type u_4) : Type u_4
(α : Type u_1) [fin_enum α] : list α
{α : Type u} [preorder α] {a b : α} (h : a < b) : ¬b < a
{G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)
{R : Type u_2} {M : Type u_3} [semiring R] [add_comm_group M] [module R M] : has_involutive_neg (submodule R M)
{M : Type u_1} [has_add M] {S T : add_subsemigroup M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T) : S = T
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {c₁ c₂ : α × β} (p : path.homotopic.quotient c₁ c₂) : path.homotopic.quotient c₁.fst c₂.fst
{α : Type u} [pseudo_metric_space α] {s : set α} {x y : α} : metric.inf_dist x s ≤ metric.inf_dist y s + has_dist.dist x y
{R : Type u_1} {M : Type u_3} {a b : R} [monoid R] [mul_action R M] (h : a * b = 1) : is_smul_regular M b
(R : Type u_1) [semiring R] : Type u_1
{α : Type u_2} [topological_space α] {g : α → α} (h : continuous g) : flow ℕ α
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V ↔ module.finite K V
(C : Type u) [category_theory.category C] : Type (max u v)
{G₁ : Type u_2} {G₂ : Type u_3} [group G₁] [group G₂] [group.is_nilpotent G₁] [group.is_nilpotent G₂] : group.is_nilpotent (G₁ × G₂)
{α : Type u} [partial_order α] {a b : α} : a ≤ b → a ≠ b → a < b
{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b ≠ 0 ↔ b * a ≠ 0
{α : Type u_1} (p : α → Prop) [decidable_pred p] (s : multiset α) : ℕ
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.is_terminal 0
{α : Type u_2} {β : Type u_3} [decidable_eq β] [has_vadd α β] : has_vadd α (finset β)
 : nnreal
(α : Type u_1) (β : Type u_2) : Type u_1
{α : Type u_1} (n : ℕ) : list α → ℕ → list α × list (list α)
{M : Type u_1} [has_mul M] : complete_lattice (con M)
(α : Type u) : category_theory.single_obj α
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 < b) : 0 < a + b
{X : Type v} [topological_space X] [compact_space X] : paracompact_space X
{α : Type u} : list α → stream α → stream α
{A : Type u_2} [add_group A] (H : add_subgroup A) : Prop
{M : Type u_1} [mul_action ennreal M] : mul_action nnreal M
{H : Type u_5} [topological_space H] (M : Type u_6) [topological_space M] [charted_space H M] (G : structure_groupoid H) : Prop
(R : Type u_1) [semiring R] : Type u_1
{R : Type u_1} {A : Type u_2} (x : unitization R A) : R
(n : ℕ) : comm_ring (fin (n + 1))
{α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : a - b ≤ c → a ≤ b + c
{α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist s s = 0
{α : Type u_1} [monoid α] (x y : α) : Prop
(P : ℕ → Prop) [decidable_pred P] : ℕ → ℕ
(α : Type u_1) (β : Type u_2) [uniform_space β] : uniform_space (α → β)
{F : Type u → Type u} [functor F] {α : Type u} (p : α → Prop) (x : F α) : Prop
(X : Type u_1) [has_mul X] [has_zero X] [has_lt X] [has_le X] : Prop
(L : first_order.language) (α : Type w) : first_order.language
{α : Type u_1} [linear_order α] {s : set α} : ¬bdd_above s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), x < y
{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {A B : matrix n n α} (h : A.mul B = 1) : A⁻¹ = B
(α : Type u_3) [preorder α] [topological_space α] : Prop
{α : Type u} {β : Type v} (f' : β → α) (f : α → β) (s : set α) : Prop
(n : ℕ) : ℕ
 : category_theory.ess_surj Compactum_to_CompHaus
 : ℕ → ℕ → option ℕ
{ι : Type u_1} {R : Type u_2} {A : Type u_3} [decidable_eq ι] [add_monoid ι] [comm_semiring R] [semiring A] [algebra R A] (𝒜 : ι → submodule R A) : Type (max u_1 u_3)
{G : Type u_1} [add_group G] (H : add_subgroup G) {x y : G} : x ∈ H → y ∈ H → x + y ∈ H
{α : Type u_2} [subtraction_monoid α] : subtraction_monoid (set α)
(M : Type u) : Type u
{M : Type u_1} [mul_one_class M] {c : con M} : ↑1 = 1
{R : Type u_1} [mul_zero_class R] (h : is_regular 0) : subsingleton R
(α : Type u) [t : topological_space α] [topological_space.second_countable_topology α] : set (set α)
{F : Type u → Type u} [functor F] (q : qpf F) : Prop
{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a
(k n : ℕ) : finset (fin k → ℕ)
(M : Type u) [has_add M] : AddMagma
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b ≤ 1) : a * b < 1
 : num → num → num
 : multiset.nat.antidiagonal 0 = {(0, 0)}
 : Type
(X : Type u_1) [topological_space X] : Type u_1
(n : ℕ) : Type
(C : Type u) [category_theory.category C] : setoid C
 : Type (u+1)
{α : Type u} (t : ordnode α) : list α
(R : Type u) [comm_ring R] [local_ring R] : Type u
(n a b : ℕ) : Prop
{α : Type u_1} {β : Type u_2} (e : local_equiv α β) : local_equiv β α
{α : Type u_1} {r : α → α → Prop} (hr : well_founded r) : well_founded (relation.cut_expand r)
 : num → num → num
{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 1 → a = 1
{α : Type u} (p : α → Prop) [decidable_pred p] : ordnode α → ordnode α × ordnode α
{B : Type u} [quiver B] : B → B → Type (max u v)
 : pos_num → pos_num
 : pSet → pSet
(R : Type u) [comm_ring R] [is_domain R] : Prop
{α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist s ∅ = 0
(α : Type u_1) [decidable_eq α] [fintype α] : trunc (encodable α)
{M : Type u} [has_one M] [has_mul M] : ℕ → M → M
{X : Type u_1} [topological_space X] {x y z : X} (γ : path x y) (γ' : path y z) : path x z
{n : Type u_4} {α : Type u_5} [fintype n] [non_unital_semi_normed_ring α] : non_unital_semi_normed_ring (matrix n n α)
(X : Type u) [lattice X] [jordan_holder_lattice X] : Type u
(R : Type u) [comm_ring R] : Type u
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B F : bilin_form R M) (f : module.End R M) : Prop
{α : Type u_1} [U : uniform_space α] (m : pseudo_metric_space α) (H : uniformity α = uniformity α) : pseudo_metric_space α
{α : Type u} (s : set α) : Prop
{α : Type u_1} (a : lists α) : lists α → Prop
{α : Type u_1} {β : Type u_2} [has_coe α β] : has_coe (generalized_continued_fraction.pair α) (generalized_continued_fraction.pair β)
{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : 1 / a ≤ 1 / b ↔ b ≤ a
{α : Type u} (max : ℕ) (f : thunk α) : option α
(R : Type u_1) [ring R] [topological_space R] [t : nonarchimedean_ring R] : nonarchimedean_add_group R
{α : Type u} (s : set α) : is_closed {u : ultrafilter α | s ∈ u}
{ι : Type u_1} [encodable ι] {E : ι → Type u_2} [Π (i : ι), topological_space (E i)] [∀ (i : ι), polish_space (E i)] : polish_space (Π (i : ι), E i)
{n : ℕ} : bitvec n → bitvec n → bitvec n
{F : Type u_3} [field F] [fintype F] (hF : ring_char F = 2) (a : F) : is_square a
(α : Type u) [s : lattice α] [comm_group α] [covariant_class α α has_mul.mul has_le.le] : distrib_lattice α
{p : ℕ} [fact (nat.prime p)] (f : padic_seq p) : ℤ
{M : Type u_1} [monoid M] {s t : set M} (ht : is_submonoid t) (h : s ⊆ t) : monoid.closure s ⊆ t
{f : Type → Type v} [alternative f] (p : Prop) [decidable p] : f unit
(a : ℤ) : ↑(a.nat_abs) ≤ a ^ 2
{α : Type u_2} {β : Type u_3} [complete_lattice α] [complete_lattice β] (f : complete_lattice_hom α β) : Sup_hom α β
(R : Type u_1) [rack R] : Prop
{α : Type u_1} (l : list α) : list (multiset α)
 : onote → ordinal
{α : Type u} {β : Type v} [preorder α] [preorder β] (c₀ : omega_complete_partial_order.chain α) (c₁ : omega_complete_partial_order.chain β) : omega_complete_partial_order.chain (α × β)
 : Type
 : onote → ordinal → Prop
 : Type
{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] (h : bounded_continuous_function α β) : α → β
{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order α] [semilattice_sup β] (gi : galois_coinsertion l u) : semilattice_sup α
{α : Type u_1} (r : α → α → Prop) : Prop
{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : 1 < L.prod) : 0 < L.length
 : turing.to_partrec.code
{α : Type u_1} {β : Type u_2} {f : α → β} {mα : measurable_space α} [measurable_space β] [topological_space β] [topological_space.metrizable_space β] [borel_space β] [topological_space.second_countable_topology β] : measure_theory.strongly_measurable f ↔ measurable f
(α : Type u) : Type u
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1
{α : Type u_1} (r : α → α → Prop) (s : set α) : set α
{α : Type u_1} [linear_ordered_field α] {β : Type u_2} [ring β] {abv : β → α} (f : cau_seq β abv) : Prop
(G : Type u_1) [category_theory.groupoid G] : Type (max u_1 (v+1))
(R : Type u) : Type u
(α : Sort u) : Sort u
(α : Type u_5) : Type u_5
{α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ b) : a ∣ b + c ↔ a ∣ c
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (P : category_theory.idempotents.karoubi C) : category_theory.idempotents.karoubi C
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {f : J → C} {t : category_theory.limits.cone (category_theory.discrete.functor f)} (ht : category_theory.limits.is_limit t) : category_theory.limits.bicone f
(α : Type u_3) [preorder α] [topological_space α] : Prop
{α : Type u} (c : computation α) : α ⊕ computation α
{α : Type u} [topological_space α] (x : α) : stone_cech α
(t s : omega.nat.preterm) (k : ℕ) : omega.nat.preterm → omega.nat.preterm
(X : Twop) : Bipointed
{R : Type u_1} [ring R] (s : subring R) (m : multiset R) : (∀ (a : R), a ∈ m → a ∈ s) → m.sum ∈ s
(α : Type u) {β : Type v} [group α] [mul_action α β] (b : β) : subgroup α
(L : Type v) [has_bracket L L] [has_zero L] : Prop
{R : Type u_1} [comm_ring R] [is_domain R] [normalized_gcd_monoid R] (p : polynomial R) : polynomial R
 : has_pure ultrafilter
(R : Type u_1) (Rₘ : Type u_2) [comm_semiring R] [comm_semiring Rₘ] (M : submonoid R) [subsingleton R] [algebra R Rₘ] [is_localization M Rₘ] : unique Rₘ
(n d : pos_num) : num
{α : Type u} {β : Type v} [mul_one_class α] [group β] {f : α → β} (hf : is_mul_hom f) : is_monoid_hom f
(β : Type u_2) [pseudo_metric_space β] [monoid β] : Prop
{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a < b + c → -b + a < c
{X : Type u_1} [topological_space X] (F : set X) : Prop
{E : ℕ → Type u_1} : has_dist (Π (n : ℕ), E n)
(α : Type u) [t : topological_space α] [topological_space.separable_space α] [nonempty α] : dense_range (topological_space.dense_seq α)
{α : Type u} [pseudo_metric_space α] (s : set α) : lipschitz_with 1 (λ (x : α), metric.inf_nndist x s)
{t : Type u_1 → Type u_1 → Type u_1} {m : Type u_1 → Type u_1} [bitraversable t] [applicative m] {α β : Type u_1} : t (m α) (m β) → m (t α β)
{α : Type u_1} (a : α) (n : ℕ) : sym α n
{α : Type u_1} (s : multiset α) : Prop
{M₁ : Type u_1} {M₂ : Type u_2} [has_inv M₂] [has_involutive_inv M₁] (f : M₁ → M₂) (hf : function.surjective f) (inv : ∀ (x : M₁), f x⁻¹ = (f x)⁻¹) : has_involutive_inv M₂
{G : Type u_1} [group G] (S : set G) : subgroup G
{α : Sort u} (a : α) {β : Sort u} : β → Prop
(R : Type u) [semiring R] [nontrivial R] [hq : exp_char R 1] : char_zero R
{α : Type u_1} {β : Type u_2} [encodable α] [encodable β] (n : ℕ) : option (α ⊕ β)
 : Type
{α : Type u_1} [comm_semiring α] (a x : α) (n : ℕ) (b : α) : α
(α : Type u_1) [distrib_lattice α] [bounded_order α] : BoundedDistribLattice
(p : ℕ) (z : ℤ) : ℕ
{X : Type u_2} [emetric_space X] (s : set X) : ennreal
{α : Sort u} (a : α) : α
(α : Type u_1) [boolean_ring α] : BoolRing
{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (i j : ι) : local_homeomorph (B × F) (B × F)
{M : Type u_3} [monoid M] (L : list M) (h : L.prod ≠ 1) : 0 < L.length
{a : ℕ} (a1 : 1 < a) (n : ℕ) : ℕ
{α : Type u_1} {𝒜 : finset (finset α)} {A₁ A₂ : finset α} {r₁ r₂ : ℕ} (h₁ : A₁ ∈ 𝒜.slice r₁) (h₂ : A₂ ∈ 𝒜.slice r₂) : r₁ ≠ r₂ → A₁ ≠ A₂
{k : Type u_2} [field k] : power_series k → power_series k
{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] (S : intermediate_field F E) : Prop
{K : Type u_1} [division_ring K] (g : generalized_continued_fraction K) : ℕ → generalized_continued_fraction K
(p : ℕ) [hp : fact (nat.prime p)] (n : ℕ) : mv_polynomial ℕ ℤ
(M : Type u_1) {α : Type u_2} [add_monoid M] [add_action M α] (s : set α) : add_submonoid M
{R : Type u_1} [comm_semiring R] {M : submonoid R} (z w : localization M) : localization M
{α : Type u} [topological_space α] [t2_space α] [compact_space α] : totally_disconnected_space α ↔ totally_separated_space α
{α : Type u_1} {β : Type u_2} {f : α → β} [topological_space β] {m : measurable_space α} (hf : measure_theory.strongly_measurable f) : ℕ → measure_theory.simple_func α β
(R : Type u_1) [rack R] : Type u_1
(n : ℕ) (a : fin n) (b : ℕ) : Prop
{α : Type u_2} {β : Type u_3} [preorder α] [preorder β] [bounded_order α] [bounded_order β] (f : bounded_order_hom α β) : bot_hom α β
{β : Type u_2} {f g : β → nnreal} (hgf : ∀ (b : β), g b ≤ f b) : summable f → summable g
(F : Type u_7) (α : out_param (Type u_8)) (β : out_param (Type u_9)) [lattice α] [lattice β] [bounded_order α] [bounded_order β] : Type (max u_7 u_8 u_9)
{α : Type u_1} [lattice α] [order_bot α] {a : α} : has_le (finpartition a)
{α : Type u} {β : Type v} {f : α → β} (h : function.injective f) (s : set α) : set.inj_on f s
{α : Type u} [decidable_eq α] (a : α) : wseq α → computation ℕ
(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] : Type (max u (v+1))
{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : M.transpose.det = M.det
{p n : ℕ} {R : Type u_1} [comm_ring R] (x : truncated_witt_vector p n R) : witt_vector p R
(α : Type u) : Type u
{R : Type u_1} [monoid_with_zero R] (f : nat.arithmetic_function R) : Prop
(G : Type u_1) [monoid G] : Prop
{α : Type u_1} {β : Type u_2} [t : topological_space α] [add_group β] (f : α → β) : add_group_topology β
{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ < b⁻¹ ↔ b < a
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] : submodule R M
{α : Type u_1} {r s : α → α → Prop} (h : ∀ (x y : α), r x y → s x y) : eqv_gen.setoid r ≤ eqv_gen.setoid s
 : category_theory.limits.has_limits_of_size AddGroup
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : a < 1) (hb : b ≤ 1) : a * b < 1
(C : Type u) [category_theory.category C] : Prop
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (c : con M) (d : con N) : con (M × N)
 : Type
{α : Type u} (x : α) : free_semigroup α
(a b : ℕ) {c : ℕ} (hc : 0 < c) : c * a / (c * b) = a / b
{α : Type u_1} [preorder α] {β : Type u_2} [preorder β] (f : α → β) (f_strict_mono : strict_mono f) (s : ordset α) : ordset β
{α : Type u} : ordnode α → ℕ → option α
{α : Type u_1} [primcodable α] (p : α → Prop) : Prop
{α : Type u_1} {p : α → Prop} [emetric_space α] : emetric_space (subtype p)
 : pos_num → pos_num → num
{M : Type u_1} [has_add M] (S : add_subsemigroup M) : set M
{R : Type u_2} {Γ₀ : Type u_3} [linear_ordered_add_comm_monoid_with_top Γ₀] [ring R] (v : add_valuation R Γ₀) : preorder R
{α : Type u_1} {b : bool} : lists' α b → list (lists α)
 : pos_num → ℕ → bool
{a : ℕ} (a1 : 1 < a) (n : ℕ) : ℤ
 : ℤ → ℤ → ℤ
{α : Type u_1} [preorder α] [fintype α] : locally_finite_order α
{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.fst
{α : Type u} (s : set α) : Prop
{α : Type u} [has_le α] [decidable_rel has_le.le] : list α → ordnode α
{α : Type u_3} {β : Type u_4} [lattice α] [lattice β] [bounded_order α] [bounded_order β] (f : bounded_lattice_hom α β) : bounded_order_hom α β
{C : Type u} [category_theory.category C] : category_theory.grothendieck_topology C
{α : Type u} (s : stream α) : stream α
{α : Type u_1} {β : Type u_3} {γ : Type u_5} [decidable_eq γ] (f : α → β → γ) (s : finset α) (t : finset β) : finset γ
{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) : X
(α : Type u) (β : Type v) [topological_space α] [has_zero β] [topological_space β] : Type (max u v)
 : Type
(α : Type u_2) [topological_space α] : spectral_map α α
(ι : Type v) (β : ι → Type w) [Π (i : ι), add_comm_monoid (β i)] : Type (max v w)
(ρ : out_param (Type u)) (m : Type u → Type v) : Type v
(R : Type u) [semiring R] : Prop
{α : Type u_2} [has_mul α] (a : α) (s t : set α) : set α
(R : Type u_1) (M : Type u_2) [semiring R] [nontrivial M] [add_comm_monoid M] [module R M] : nontrivial R
(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [has_add M] [has_add N] : Type (max u_10 u_11 u_9)
{M : Type u} [monoid M] (F : Type v) [field F] [mul_semiring_action M F] (m : M) : subfield F
{α : Type u} {β : Type v} {f : α → β} {g : β → α} (hf : function.injective f) (hg : function.injective g) : ∃ (h : α → β), function.bijective h
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1
{G : Type u_1} [group G] (H : subgroup G) : Prop
{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] : galois_insertion (intermediate_field.adjoin F) coe
{α : Type v} {d u l r : ℕ} (A : matrix (fin (u + d)) (fin (l + r)) α) : matrix (fin u) (fin r) α
{α : Type u_1} (s : set α) : local_equiv α α
{A : Type u_2} [add_monoid A] (s : set A) : A → Prop
{α : Type u} {L₁ L₂ : list (α × bool)} : free_group.red.step L₁ L₂ → L₂.length + 2 = L₁.length
(α : Type u_1) [partial_order α] [order_top α] : Prop
{α : Type u_1} {ι : Type u_3} {m : measurable_space α} [preorder ι] {f : measure_theory.filtration ι m} {τ : α → ι} (hτ : measure_theory.is_stopping_time f τ) : measurable_space α
(C : Type u_1) [category_theory.category C] : Type
{n : ℕ} {α : fin n → Type u} [Π (i : fin n), decidable_eq (α i)] (a b : d_array n α) : bool
{α : Type u} : lazy_list α → list α
{α : Type u_1} [complete_lattice α] : Inf_hom α (lower_set α)
{R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_left_regular a) : is_left_regular (a * b) ↔ is_left_regular b
{E : ℕ → Type u_1} (x : Π (n : ℕ), E n) (n : ℕ) : set (Π (n : ℕ), E n)
{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α} : a * b ≤ c → b ≤ a⁻¹ * c
(x y : ℕ) : ↑(x.gcd y) = ↑x * x.gcd_a y + ↑y * x.gcd_b y
(n : ℕ) : bitvec n
{α : Type u} {β : Type v} (f : α → β) : free_add_magma α → free_add_magma β
(k : ℕ) : nat.arithmetic_function ℕ
(R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R] : add_valuation R enat
{α : Type u_1} {β : Type u_2} (s : finset α) (t : finset β) : finset (α ⊕ β)
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)
(α : Type u) : Type u
{a b : ereal} (h : -a ≤ b) : -b ≤ a
{X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s ↔ is_closed s
{R : Type u_1} [comm_ring R] {a b : R} : a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)
(n : ℕ) : composition n
{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 1 ≤ a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b
(M : Type u_1) (α : Type u_2) [has_vadd M α] [measurable_space M] [measurable_space α] : Prop
 : Type
{α : fin 0 → Type u_1} : d_array 0 α
{α : Type u} (P : α → Prop) [decidable_pred P] : list α → (list α → list α) → list (list α)
{α : Type u_1} [measurable_space α] {f : ℕ → α → nnreal} {g : α → nnreal} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g
(α : Type u_1) : Type u_1
{α : Type u} [ring α] [no_zero_divisors α] : cancel_monoid_with_zero α
{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : 1 < a) (hb : 1 ≤ b) (a0 : 0 < a) : 1 < a * b
{α : Type u} [primcodable α] [inhabited α] (p : set α) : set ℕ
{α : Type u_1} [fintype α] : finset α
{α : Type u} {β : Type u_1} [topological_space α] [topological_space β] [topological_space.second_countable_topology α] [topological_space.second_countable_topology β] : topological_space.second_countable_topology (α ⊕ β)
{α : Type u_1} [preorder α] [decidable_rel has_le.le] (x : α) (s : ordset α) : ordset α
(ρ ρ' : out_param (Type u)) (m m' : Type u → Type v) : Type (max (u+1) v)
 : Type
(α : Type u_4) : Type u_4
{H : Type u} [topological_space H] : closed_under_restriction (continuous_groupoid H)
(n : ℕ) : finset ℕ
{α : Type u_1} [preorder α] [is_total α has_le.le] [decidable_rel has_le.le] (x : α) (s : ordset α) : ordset α
(S : Type u_1) (R : out_param (Type u)) [ring R] [set_like S R] : Type
{α : Sort u} {β : Sort v} {γ : Sort w} {g : β → γ} (hg : function.surjective g) : function.surjective (function.comp g)
{α : Type u_1} [topological_space α] {R : Type u_2} [comm_semiring R] {A : Type u_3} [topological_space A] [semiring A] [algebra R A] [topological_semiring A] : subalgebra R (α → A)
(C : Type u) [category_theory.category C] : Prop
{G : Type u_1} [group G] (H : subgroup G) : subgroup G
(α : Type u_1) (n : ℕ) : Type u_1
{α : Type u} [group_with_zero α] (a b : α) [invertible a] [invertible b] : invertible (a / b)
{α : Type u} [semilattice_inf α] [order_bot α] (a b : α) : Prop
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape ι} [category_theory.limits.has_zero_object V] : homological_complex V c
{L : first_order.language} (κ : cardinal) (T : L.Theory) : Prop
(a b c : ℤ) : Prop
{α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop
{β : Type u_2} [topological_space β] {κ : Type u_5} (f : κ → β) : Prop
(M : Type u_1) [add_monoid M] : add_submonoid M
{α : Type u_1} [conditionally_complete_lattice α] : conditionally_complete_lattice (with_bot α)
{α : Type u} {β : Type v} : wseq α → wseq β → wseq (α × β)
{ι : Type u_1} (M : ι → Type u_2) [Π (i : ι), monoid (M i)] : ι → ι → Type (max u_1 u_2)
(R : Type u) [semiring R] {m : Type u_1} {n : Type u_2} [fintype m] [fintype n] : module.free R (matrix m n R)
(α : Type u) : Type u
{α : Type u} {β : Type v} (f : ulift (α → β)) (x : ulift α) : ulift β
(α : Type u_3) : Type u_3
(α : Type u) (lt : α → α → Prop) : Prop
{C : Type u_1} [category_theory.category C] (X : C) : Prop
(R : Type u_1) (M : Type u_3) [monoid_with_zero R] [has_zero M] : Type (max u_1 u_3)
 : Type (u_1+1)
{α : Type u} : rbnode α → tree α
(K : Type u_1) (V : Type u_2) [field K] [add_comm_group V] [module K V] : setoid {v // v ≠ 0}
{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (v : n → α) [invertible (matrix.diagonal v)] : invertible v
{α : Type u_1} {β : Type u_2} : list (option α) → list β → list (option β)
(R : Type u) [comm_semiring R] (A : Type v) [semiring A] [algebra R A] (n : Type w) (a : A) (m : matrix n n R) : matrix n n A
{G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (H : add_subgroup G) (K : add_subgroup N) : add_subgroup (G × N)
(M : Type u) [add_semigroup M] : AddSemigroup
{α : Type u} [preorder α] (s : set α) : α → Prop
 : sSet
{X : Type u_1} [topological_space X] (x y : X) : Type u_1
{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b ≠ 0 ↔ a ≠ 0 ∧ b ≠ 0
 : Type (u_1+1)
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1
{α : Type u_1} {ι : Type u_4} (l : filter α) (p : ι → Prop) (s : ι → set α) : Prop
{n : ℕ} (i : fin2 n) (k : ℕ) : fin2 (n + k)
{α : Type u_1} {n : ℕ} (v : vector3 α n.succ) : vector3 α n
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (X : category_theory.simplicial_object C) : chain_complex C ℕ
{R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] (S : subalgebra R A) : Prop
(r : ℕ) (b : bool) : ℕ
(G : Type u) : Type u
{α : Type u_1} (n : ℕ) (s : finset α) : finset (finset α)
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) : valuation R (with_zero (multiplicative ℤ))
{G : Type u_1} [group G] (g : G) : subgroup G
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] (f : measure_theory.simple_func α β) (g : measure_theory.simple_func α γ) : measure_theory.simple_func α (β × γ)
{β : Type w} {C : Type u} [category_theory.category C] (f : β → C) : Prop
{β : Type w} [add_comm_group β] (s : β) (C : Type u) : Type (max w u)
{R : Type u_1} {a b : R} [semigroup R] (ab : is_left_regular (a * b)) : is_left_regular b
 : category_theory.limits.has_limits_of_size Ring
{R : Type u_1} [semiring R] (N : ℕ) : polynomial R → polynomial R
{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : a < 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} (a : topological_fiber_prebundle F proj) : topological_space Z
(C : Type u_1) [category_theory.category C] [category_theory.is_idempotent_complete C] : category_theory.is_equivalence (category_theory.idempotents.to_karoubi C)
{R : Type u} [semiring R] (f : polynomial R) : polynomial R
{α : Type u_1} [measurable_space α] : measure_theory.measure α
{α : Type} (p : parser α) : Prop
{α : Type u} [pseudo_metric_space α] (s : set α) : lipschitz_with 1 (λ (x : α), metric.inf_dist x s)
{α : Type u} (a : α) (s : stream α) : stream α
 : Type (u+1)
{G : Type u_1} [group G] [fintype G] : monoid.is_torsion G
(C : Type u) [category_theory.category C] : Prop
 : Type
{α : Type u} [infinite α] : nonempty (field α)
{α : Type u_1} {β : Type u_2} [can_lift α β] : can_lift (multiset α) (multiset β)
(J : Type u₁) [category_theory.category J] : Prop
(k : Type u) [field k] : Prop
{n : Type u_4} {α : Type u_5} [fintype n] [non_unital_normed_ring α] : non_unital_normed_ring (matrix n n α)
(α : Type u_1) [partial_order α] [fintype α] : FinPartialOrder
{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a
(T : Type u) [topological_space T] : category_theory.pretopology.of_grothendieck (topological_space.opens T) (opens.grothendieck_topology T) = opens.pretopology T
{R : Type u_1} [nontrivial R] [hR : ring R] (h : ∀ (a : R), is_unit a ∨ a = 0) : division_ring R
(R : Type u) [semiring R] [strong_rank_condition R] : rank_condition R
{α β : Type u_1} {m : Type u_1 → Type u_2} [monad m] (y : m β) (z : α → m β) (x : m (option α)) : m β
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 ≤ b) : 0 < a + b
{C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_cokernels C] [category_theory.normal_epi_category C] : category_theory.limits.has_coequalizers C
(α : Type u) (ds : list ℕ) : Type u
{R : Type u_2} {M : Type u_3} [semiring R] [add_comm_group M] [module R M] : has_neg (submodule R M)
{α : Type u} : seq (seq1 α) → seq α
{α : Type u_2} [has_one α] [has_mul α] [has_inv α] : has_pow (filter α) ℤ
{α : Type u} [preorder α] {a b c : α} : b < c → a = b → a < c
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) (h : open_embedding f) [nonempty α] : local_homeomorph α β
{α : Type u} {f : α → α} {x : α} (hf : function.is_fixed_pt f x) : f x = x
{R : Type u_2} {Γ₀ : Type u_3} {Γ'₀ : Type u_4} [ring R] [linear_ordered_comm_monoid_with_zero Γ₀] [linear_ordered_comm_monoid_with_zero Γ'₀] (v₁ : valuation R Γ₀) (v₂ : valuation R Γ'₀) : Prop
(G : Type u_1) [topological_space G] [has_sub G] : Prop
 : Type
{α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) (x : α) : Prop
{α : Type u_2} {β : Type u_3} {γ : Type u_4} [preorder α] [preorder β] [preorder γ] (g : pseudo_epimorphism β γ) (f : pseudo_epimorphism α β) : pseudo_epimorphism α γ
(A B : CommRing) : category_theory.limits.binary_fan A B
 : golden_ratio⁻¹ = -golden_conj
{R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J J₃ A A' : matrix n n R₃) : Prop
{ι : Type u} (f : ι → ordinal) : ordinal
(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] [fintype l] : lie_subalgebra R (matrix (l ⊕ l) (l ⊕ l) R)
{M : Type u_1} [comm_monoid M] (S : submonoid M) : localization S
{n : ℕ} (c : composition n) (i : ℕ) : ℕ
{α : Type u} : ℕ → seq α → list α
{α : Type u_2} [has_neg α] : has_neg (set α)
{G₀ : Type u_2} [group_with_zero G₀] (a : G₀) : a * a / a = a
{n : ℕ} : (vector ℕ n → ℕ) → Prop
{α : Type u} (f : α → α) : α → lazy_list α
{α : Type u_2} [has_mul α] (a : α) : Prop
 : ℕ → ℤ → ℤ → ℕ → ℤ → ℤ → ℕ × ℤ × ℤ
{R : Type u} [semiring R] (p : polynomial R) : with_top ℕ
(R : Type u) [semiring R] : Type u
(M : Type u_1) [has_mul M] : galois_insertion con_gen coe_fn
{α : Type u} [pseudo_emetric_space α] : setoid α
(B : Type u) [category_theory.bicategory B] : Prop
{C : Type u₁} [category_theory.category C] [category_theory.well_powered C] [category_theory.limits.has_coproducts C] [category_theory.limits.has_images C] {A : C} (s : set (category_theory.subobject A)) : category_theory.subobject A
(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] : matrix (l ⊕ l) (l ⊕ l) R
{m : Type u → Type v} [monad m] {α : Type u} (p : α → m (ulift bool)) : list α → m (option α)
(n : ℕ) (α : Type u) : Type u
{α : Type u_2} {β : Type u_3} (r : α → β → Prop) (s : set α) : set β
{α : Type u_1} [monoid α] {p q : α} (hp : irreducible p) (hq : irreducible q) : p ∣ q → q ∣ p
{R : Type u} [ring R] (s : subring R) {x y : R} (hx : x ∈ s) (hy : y ∈ s) : x - y ∈ s
{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream (generalized_continued_fraction.pair K)
(a b : snum) : snum
(ι : Sort u_1) (α : ι → Sort u_2) (β : ι → Sort u_3) [Π (i : ι), can_lift (α i) (β i)] : can_lift (Π (i : ι), α i) (Π (i : ι), β i)
(R : Type u_1) [comm_ring R] {S : Type u_2} [comm_ring S] [algebra R S] (a : S) : Prop
{α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_cyclic α
{M : Type u_1} [add_zero_class M] {S T : add_submonoid M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T) : S = T
 : Type (u+1)
{M₀ : Type u_1} [cancel_monoid_with_zero M₀] {a b : M₀} (h₁ : b ≠ 1) (h₂ : a * b = a) : a = 0
(G : Type u) : Type u
(Γ : Type u_1) [inhabited Γ] : Type u_1
{k : Type u_1} {G : Type u_2} [comm_semiring k] [monoid G] : representation k G k
{𝕜 : Type u_1} {E : Type u_2} [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] (Q : affine_subspace 𝕜 E) : convex 𝕜 ↑Q
{a b c : ℕ} (h : a % c = b % c) : (a - b) % c = 0
(J : Type u₂) [category_theory.category J] : setoid J
{R : Type u} {M : Type v} [ring R] [add_comm_group M] [module R M] (S : submodule R M) : Prop
{α : Type u_1} {β : Type u_2} {γ : Sort u_3} (f : α → γ) (g : β → γ) : α ⊕ β → γ
{α : Type u_1} [encodable α] {n : ℕ} : encodable (array n α)
(A : Type u_1) (B : out_param (Type u_2)) : Type (max u_1 u_2)
(G : Type u_1) : Type u_1
{n : ℕ} {α : Type u_1} {v w : vector α n} (h : ∀ (m : fin n), v.nth m = w.nth m) : v = w
{α : Type u} : free_magma α → ℕ
{R : Type u} [field R] [star_ring R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y
(α : Type u) (r : α → α → Prop) : Prop
{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) : list (Σ (a : α), β a) → list (Σ (a : α), β a)
(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) : finset.centroid_weights_indicator k s = ↑s.indicator (finset.centroid_weights k s)
{α : Type u} {β : α → Type v} (l : list (sigma β)) : Prop
{V : Type u} (G : simple_graph V) (α : Type v) : Type (max u v)
{α : Type u} (s : wseq α) : Prop
(X : Type u_1) [topological_space X] [compact_space X] [t2_space X] [totally_disconnected_space X] : Profinite
{α : Type u} (f : α → α) (x : α) : Prop
{x y z : ℤ} (h : pythagorean_triple x y z) : Prop
(n : ℕ) : finset (ℕ × ℕ)
(R : Type u_1) [ordered_semiring R] [nontrivial R] : submonoid R
{α : Type u} {p : α → Prop} {a : α} (h : a ∈ {x : α | p x}) : p a
{n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (z : α 0) : fin.tail (function.update q 0 z) = fin.tail q
{α : Type u_1} [decidable_eq α] : monotone finset.shadow
(R : Type u_1) (A : Type u_2) [comm_semiring R] : pi.const_ring_hom A R = algebra_map R (A → R)
{M : Type u_1} (S : set M) [has_mul M] : set M
{m : Type → Type v} [monad m] {α : Type u} (p : α → m bool) (as : list α) : m bool
 : has_div ordinal
(H : Type u) [topological_space H] : structure_groupoid H
(α : Type u_2) : Type u_2
{R : Type u_1} {S : Type u_3} [comm_semiring R] [comm_semiring S] : comm_semiring (R × S)
 : Type
{R : Type u} [semiring R] (p : polynomial R) : ℕ
{α : Type u_1} (p : α → Prop) [decidable_pred p] (l : multiset α) (hp : ∃! (a : α), a ∈ l ∧ p a) : {a // a ∈ l ∧ p a}
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) : add_subsemigroup N
(A : out_param (Type u)) (B : Type v) : Type (max (u+1) (v+1))
(R : CommRing) : algebraic_geometry.LocallyRingedSpace
(α : Type u_1) [ht : topological_space α] [h : polish_space α] : upgraded_polish_space α
(k : Type u) [field k] : Type u
(n : ℕ) : ↑(n.totient) = ↑n * n.factors.to_finset.prod (λ (p : ℕ), 1 - (↑p)⁻¹)
(α : Type u) [cancel_comm_monoid_with_zero α] : Type u
(α : Type u_1) : Type u_1
{G : Type u_1} [group G] (H : ℕ → subgroup G) : Prop
(f : ordinal → ordinal) : ordinal → ordinal
{α : Type u} [preorder α] [no_max_order α] (a : α) : ∃ (f : ℕ → α), strict_mono f ∧ f 0 = a
{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) : Prop
{α : Type u_1} : sym α 0
(α : Type u_1) : Type u_1
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Type v
(α : Type u_1) {β : Type u_2} (q : two_pointing β) [nonempty α] : two_pointing (α → β)
(L : Type u_1) [topological_space L] [has_inf L] : Prop
{k : Type u₂} [ring k] : inhabited (affine_basis punit k punit)
{𝕜 : Type u_3} [field 𝕜] {r : ℕ} (M : matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜) : list (matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜)
{α : Type u_1} {M : Type u_4} [has_one M] (s : set α) (f : α → M) : α → M
(α : Type u_3) [has_le α] : Type u_3
{α : Type u} [partial_order α] {a b : α} (hab : a ≤ b) (hba : ¬a < b) : a = b
{α : Type u} {β : Type v} {s : set α} {f : α → β} : set.inj_on f s → function.injective (s.restrict f)
{A : Type u_1} {B : Type u_2} [i : set_like A B] {p q : A} (h : ∀ (x : B), x ∈ p ↔ x ∈ q) : p = q
(X Y : Pointed) : Type u
{α : Type u_1} [semilattice_inf α] : inf_hom α (lower_set α)
{X : Type u_1} (to_prod : X × X) : Bipointed
(R : Type u₁) (L : Type u₂) [comm_ring R] [lie_ring L] [lie_algebra R L] : Type (max u₁ u₂)
{α : Type u_1} [has_compl α] [has_sup α] (a b : α) : α
 : has_sub nonote
 : Type
(k : ℕ) (v : ℕ → ℤ) (as : list ℤ) : ℤ
 : list ℕ → ℕ → list ℕ
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) : affine.simplex k P 0
(p : ℕ) : Type
(A B : Class) : Prop
(R : Type u_1) [comm_semiring R] {X : Type u_2} : X → free_algebra R X
(α : Type u) : Type u
{α : Type u_1} {β : α → Type u_2} [Π (a : α), fintype (β a)] : W_type β → ℕ
{α : Type u_1} {β : Type u_3} {γ : Type u_5} (m : α → β → γ) (f : filter α) (g : filter β) : filter γ
{R : Type u_1} [nontrivial R] [hR : comm_ring R] (h : ∀ (a : R), is_unit a ∨ a = 0) : field R
(α : Sort u) : Sort (max 1 u)
(M : Type u_9) (N : Type u_10) [mul_one_class M] [mul_one_class N] : Type (max u_10 u_9)
{n : ℕ} (P : mvpfunctor (n + 1)) : mvpfunctor n
 : Type (u+1)
 : Type
{X : Type u_1} {Y : Type u_2} [topological_space X] (f : X → Y) : Prop
{α : Type u_2} [decidable_eq α] [add_zero_class α] : add_zero_class (finset α)
{m n : ℕ} : m ∣ m + n ↔ m ∣ n
{α : Type u_1} : list α → α → list α
 : Type (u+1)
{K : Type u_1} [field K] {Γ : Type u_2} [linear_ordered_comm_group_with_zero Γ] (v : valuation K Γ) : valuation_subring K
{α : Type u} : wseq α → computation (option (α × wseq α))
{α : Type u_1} [group α] (s : subgroup α) : setoid α
{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] : ratfunc K
{R : Type u_1} {a b : R} [monoid R] (h : b * a = 1) : is_left_regular a
 : Type
(α : Sort u_1) : Sort (max 1 (imax 1 u_1) u_1)
(R : Type u_1) [ordered_comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] (ι : Type u_4) [decidable_eq ι] : Type (max u_1 u_2 u_4)
(p : ℕ) [fact (nat.prime p)] : ↑((p - 1).factorial) = -1
(β : Type u_2) [pseudo_metric_space β] [add_monoid β] : Prop
(n : ℕ) : add_comm_group (fin (n + 1))
{α : Type u_1} [normed_division_ring α] {a : α} (ha : a ≠ 0) : filter.tendsto (λ (x : α), x * a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)
{R : Type u_1} {a : R} [monoid R] (ua : is_unit a) : is_regular a
(a : ℤ) : ℤ
(x y c : bool) : bool
{S : Type u_1} [ordered_semiring S] {R : Type u_2} [semiring R] (abv : R → S) [is_absolute_value abv] : absolute_value R S
{X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.pseudo_metrizable_space Y] {f : X → Y} (hf : inducing f) : topological_space.pseudo_metrizable_space X
(α : Type u_1) : Type u_1
 : category_theory.limits.limit_cone (category_theory.functor.empty (Type u))
{α : Type u} [pseudo_emetric_space α] (s : set α) : ennreal
(G : Type u_10) [has_involutive_neg G] : equiv.perm G
(R : Type u) [rack R] : rack.pre_envel_group R → rack.pre_envel_group R → Type u
(X : algebraic_geometry.LocallyRingedSpace) : Top
 : snum → snum
{α : Type u_1} {β : Type u_2} (f : α → β) [decidable_eq α] [fin_enum β] (h : function.injective f) : fin_enum α
 : Type (max (u+1) (v+1))
(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [has_mul α] [has_add α] [has_le α] [has_mul β] [has_add β] [has_le β] : Type (max u_6 u_7 u_8)
{G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G → ¬monoid.is_torsion_free G
(p : Type u_2) (q : Type u_3) (R : Type u₂) [decidable_eq p] [decidable_eq q] [comm_ring R] : matrix (p ⊕ q) (p ⊕ q) R
{α : Type u_1} : sym2.map (λ (x : α), x) = id
(V : Type u) [quiver V] : Type (max u v)
 : nat.partrec.code → ℕ
(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [has_top α] [has_top β] : Type (max u_6 u_7 u_8)
{a : Sort u} {b : Sort v} [has_coe_t a b] : has_lift_t a b
{α : Type u_1} [topological_space α] (s : set α) : Prop
{R : Type u_1} [mul_zero_class R] : is_left_regular 0 ↔ subsingleton R
{α : Type u_2} [decidable_eq α] [has_one α] [has_mul α] : has_pow (finset α) ℕ
{α : Type u_1} [linear_order α] {r s : α} : {r}.to_colex ≤ {s}.to_colex ↔ r ≤ s
(α : Type u_1) [topological_space α] [non_unital_non_assoc_ring α] : Prop
{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) (a : α) : f (-a) = -f a
{G : Type u_1} [group G] (H K : set G) : Type u_1
(α : Type u_5) : Type u_5
{α : Type u_1} (o : part α) : {dom := o.dom, get := λ (h : o.dom), o.get h} = o
(α : Type u_4) [has_le α] : Type u_4
{α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop
(R : Type u) (X : Type v) [comm_ring R] : Type (max u v)
(α : Type u_5) : Type u_5
 : Type
(R : Type u) [ring R] : Type u
{α : Type u_1} {β : Type u_2} [t : topological_space α] [ring β] (f : α → β) : ring_topology β
{A : Type u_2} [add_monoid A] (x : A) : add_submonoid A
{P : Type u_1} [preorder P] (F : order.pfilter P) : Prop
 : Type (u+1)
(G : Type u_1) [group G] [hG : group.is_nilpotent G] : ℕ
{α : Type u_1} [preorder α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] {a b : α} : a + b - a ≤ b
{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : 1 < a⁻¹ ↔ a < 1
{n : ℕ} : bitvec n → bitvec n → bitvec n
{α β : Type} (f : α → β → α) (a : α) (p : parser β) : parser α
{α : Type u_1} {β : Type u_2} (s : multiset α) (t : multiset β) : multiset (α ⊕ β)
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape ι} (C : homological_complex V c) [category_theory.limits.has_zero_object V] (i : ι) : V
 : ring_hom.localization_preserves ring_hom.finite
 : category_theory.concrete_category CpltSepUniformSpace
{P : Type u_1} [preorder P] (p : P) : order.ideal P
 : Type
{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red L₁ L₂) : free_group.red L₂ (free_group.reduce L₁)
{G : Type u_1} [add_group G] (s : set G) : set G
{α : Type u_3} {β : Type u_4} [lattice α] [lattice β] (f : lattice_hom α β) : inf_hom α β
(α : Type u_1) [ring α] : Type u_1
{α : Type u} {β : α → Type v} [decidable_eq α] (s s' : finmap β) : finmap β
{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order β] [semilattice_sup α] (gi : galois_insertion l u) : semilattice_sup β
(α : Type u_2) [fintype α] [nonempty α] [lattice α] : bounded_order α
{α : Type u_1} [has_add α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {b c : α} (bc : b < c) (a : α) : a + b < a + c
{α : Sort u_1} {β : Sort u_2} [nonempty α] (f : α → β) : β → α
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X → Y} (h : lipschitz_with K f) : dimH (set.range f) ≤ dimH set.univ
{α : Type u_1} (s : set (set α)) : set α → Prop
{X : Type u_1} [topological_space X] {x y : X} (h : joined x y) : path x y
{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] : has_dist (bounded_continuous_function α β)
{α : Type u_1} [add_semigroup α] (x y : α) : ((λ (_x : α), _x + x) ∘ λ (_x : α), _x + y) = λ (_x : α), _x + (y + x)
{α : Type u_1} [h : encodable α] : encodable (option α)
(R : Type u) [semiring R] (n : ℕ) : submodule R (polynomial R)
 : Type (u+1)
{α : Type u_1} {n : Type u_2} {m : Type u_3} [has_mul α] [add_comm_monoid α] (A : matrix m n α) [fintype m] : Prop
{α : Type u_1} [preorder α] [locally_finite_order α] (a b : α) : multiset α
{α : Type u_1} {β : Type u_2} [pseudo_emetric_space α] [pseudo_emetric_space β] {K : nnreal} {f : α → β} (hf : antilipschitz_with K f) : nnreal
{α : Type u_2} [division_comm_monoid α] : division_comm_monoid (filter α)
{α : Sort u_1} (a : α) : trunc α
{α : Type u_1} : list α → list (list α)
{K : Type u} [hring : comm_ring K] : ratfunc K → ratfunc K → ratfunc K
{G : Type u_1} [group G] [topological_space G] {H : Type u_2} [group H] [topological_space H] (U : open_subgroup G) (V : open_subgroup H) : open_subgroup (G × H)
(α : Type u) : Type u
{P : Type u_1} [preorder P] : partial_order (order.pfilter P)
(R : Type u_1) : Type u_1
(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] : Type v
(α : Type u_8) : Type u_8
{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.fst
{R : Type u} [non_assoc_semiring R] (s : set R) : subsemiring R
(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite_dimensional K L] : algebra.is_integral K L
 : Type
{α : Type u} (s1 s2 : wseq α) : wseq α
(p : ℕ) [hp : fact (nat.prime p)] : ℕ → mv_polynomial (fin 2 × ℕ) ℤ
(α : Sort u_1) : Sort (max 1 u_1)
(k n : ℕ) : multiset (fin k → ℕ)
{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) [nonempty α] : function.injective (λ (b : β) (a : α), f a b)
(α : Type) : Type
{α : Type uu} : list α → list α × list α
(ι : Type u_1) : complex_shape ι
(R : Type u) [ring R] : Prop
{α : Type u_1} {ι : Type u_2} (f : ι → measure_theory.outer_measure α) : measure_theory.outer_measure α
{α : Type u} (s : stream α) : α
{L : first_order.language} : setoid (category_theory.bundled L.Structure)
(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [mul_zero_one_class M] [mul_zero_one_class N] : Type (max u_10 u_11 u_9)
(α : Type u) [topological_space α] [sigma_compact_space α] : ℕ → set α
{α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {K : nnreal} (f : α → β) (hf : lipschitz_with K f) : locally_bounded_map α β
{α : Type u_1} {M : Type u_3} [monoid M] [monoid α] [mul_distrib_mul_action α M] : mul_action α (submonoid M)
 : Type
{α : Type u} (a : α) : computation α
{α : Type u_2} [decidable_eq α] [semigroup α] : semigroup (finset α)
(G : Type u) [topological_space G] [add_group G] : Prop
(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [add_zero_class M] [add_zero_class N] : Type (max u_10 u_11 u_9)
{α : Type u_1} [decidable_eq α] (s t : multiset α) : multiset α
{α : Type u} (r : α → α → Prop) [is_antisymm α r] {a b : α} : r a b → r b a → b = a
{α : Type uu} (r : α → α → Prop) [decidable_rel r] : list α → list α
 : Type
{f : ℕ → nnreal} {r : nnreal} : has_sum f r ↔ filter.tendsto (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), f i)) filter.at_top (nhds r)
(a : erased (Sort u)) : Sort u
{α : Type u_1} [encodable α] (a : ulower α) : α
{α : Type v} {d u l r : ℕ} (A : matrix (fin (u + d)) (fin (l + r)) α) : matrix (fin u) (fin l) α
{α : Type u} [comm_semiring α] {p p' : α} {ps ps' : ℕ} : p = p' → ps = ps' → p ^ ps = p' ^ ps'
(p : ℕ) [fact (nat.prime p)] (hp : p ≠ 2) (a : ℤ) : ↑({x : zmod p | x ^ 2 = ↑a}.to_finset.card) = zmod.legendre_sym p a + 1
{α : Type u_1} [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] [normalization_monoid α] [decidable_eq α] {a b : α} (ha : a ≠ 0) (hb : b ≠ 0) : factorization (a * b) = factorization a + factorization b
{α : Type u} [preorder α] {a : α} : a ≤ a
{α : Type u_1} [preorder α] [locally_finite_order α] (a b : α) : finset α
(C : Type u) [category_theory.category C] : Type (max u (v+1))
(L : Type u_1) [topological_space L] [has_sup L] : Prop
(J : Type u₁) [category_theory.category J] : Type u₁
{n : ℕ} (c : composition n) : ℕ
(C : Type u₁) : Type u₁
{ι : Type u_1} {Z : ι → Type u_2} [Π (i : ι), canonically_ordered_monoid (Z i)] : canonically_ordered_monoid (Π (i : ι), Z i)
(F : Type u → Type v) [applicative F] [is_lawful_applicative F] (G : Type u → Type w) [applicative G] [is_lawful_applicative G] : Type (max (u+1) v w)
{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) (s : alist β) : alist β
(α : Type u_1) (r : α → α → Prop) [is_preorder α r] : setoid α
 : io std_gen
{α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : a ≤ b + c → a - b ≤ c
(p : ℕ) [hp : fact (nat.prime p)] : is_domain (zmod p)
(α : Type u_1) [topological_space α] [t0_space α] : partial_order α
(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_products C] : Type (max u v)
{α : Type u} [pseudo_emetric_space α] {x : α} {s : set α} {r : ennreal} : emetric.inf_edist x s < r ↔ ∃ (y : α) (H : y ∈ s), has_edist.edist x y < r
{α : Type u_1} [generalized_boolean_algebra α] : non_unital_comm_ring α
{α : Type u_1} [monoid α] (s t : set α) (a : α) : set (α × α)
(A : Type u) [comm_ring A] [is_domain A] : Prop
{n : ℕ} {α : Type u_1} (a : α) (i : fin (n + 1)) (v : vector α n) : vector α (n + 1)
(α : Type u_1) [monoid_with_zero α] [decidable_eq α] [decidable_pred is_square] (a : α) : ℤ
{α : Type u_1} [decidable_eq α] [fintype α] (f : equiv.perm α) : finset (equiv.perm α)
{α : Type u_1} {β : Type u_2} {γ : Type u_3} (r : α → β → Prop) (p : β → γ → Prop) (a : α) (c : γ) : Prop
(α : Type u) [topological_space α] [t1_space α] : bornology α
{α : Type} (p : parser α) : parser unit
{α : Type u_2} [has_one α] : has_one (finset α)
{R : Type u_1} [ring R] (a b c : R) : R
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (self : subalgebra R A) : subsemiring A
{α : Type u_1} {P : α → Prop} (m : Π (s : α), P s → ennreal) (s : α) : ennreal
{C : Type u} [category_theory.category C] (P : C) (f g : category_theory.over P) : Prop
{R : Type u_1} [distrib R] (r : R) : add_hom R R
(α : Type u_1) [complete_lattice α] : complete_lattice.is_Sup_finite_compact α → well_founded gt
{R : Type u_1} [mul_zero_class R] [nR : nontrivial R] : ¬is_right_regular 0
{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) (a : α) : f a⁻¹ = (f a)⁻¹
(α : Type u_1) (β : Type u_2) [topological_space α] [topological_space β] [monoid β] [has_continuous_mul β] : submonoid (α → β)
{α : Type u_1} [B : bornology α] (m : pseudo_metric_space α) (H : ∀ (s : set α), bornology.is_bounded s ↔ bornology.is_bounded s) : pseudo_metric_space α
(X Y : Type u) : category_theory.limits.limit_cone (category_theory.limits.pair X Y)
(α : Type u) : Type u
(d : pos_num) : pos_num → num × num
(R : Type u) (A : Type v) [comm_ring R] [ring A] [algebra R A] : Prop
(α : Type u_6) (β : Type u_7) [preorder α] [preorder β] [mul_one_class α] [mul_one_class β] : Type (max u_6 u_7)
{α : Type u_1} (f : α → nnreal) (s : finset α) (h : s.sum (λ (a : α), f a) = 1) (h' : ∀ (a : α), a ∉ s → f a = 0) : pmf α
{α : Type u} (S : wseq (computation α)) : computation α
{K : Type u_2} [division_ring K] (a b ppredA predA : K) : K
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J → C) : Prop
(α : Type u) : Type u
{α : Type u} [non_unital_non_assoc_ring α] {a b c d e : α} : a * e + c = b * e + d ↔ (a - b) * e + c = d
 : Type
{α : Type u_1} {β : Type u_2} (r : setoid α) (f : α → β) (h : setoid.ker f ≤ r) (hf : function.surjective f) : setoid β
{f : ordinal → ordinal} (H : ordinal.is_normal f) : set.unbounded has_lt.lt (function.fixed_points f)
{ι : Type u_1} (V : Type u) [category_theory.category V] [category_theory.preadditive V] (c : complex_shape ι) : hom_rel (homological_complex V c)
{α : Type u} [t : topological_space α] (s : set (set α)) : Prop
{α : Type u_1} [monoid α] (a : α) : associates α
{α : Type u} [pseudo_emetric_space α] {x y : α} {s : set α} : emetric.inf_edist x s ≤ emetric.inf_edist y s + has_edist.edist x y
{α : Type u} [decidable_eq α] : list α → list α → bool
(M : Type u_9) (N : Type u_10) [has_zero M] [has_zero N] : Type (max u_10 u_9)
(i : ℕ) : lazy_list ℕ
{ι : Type u_1} {R : Type u_2} [comm_ring R] {M : Type u_4} [add_comm_group M] [module R M] (BR : ring_filter_basis R) (B : ι → submodule R M) : Prop
{β : Type v} [pseudo_emetric_space β] {α : Type u} [emetric_space α] {f : α → β} (h : isometry f) : function.injective f
{α : Type u_2} [has_inv α] : has_inv (filter α)
(n : ℕ) : fin (n + 1)
(R : Type u) [comm_ring R] [local_ring R] : prime_spectrum R
{α : Type u} (p : α → Prop) [decidable_pred p] : ordnode α → ordnode α × ordnode α
{α : Type u_1} [cancel_comm_monoid_with_zero α] [normalization_monoid α] [decidable_eq α] (h : ∀ (a b : α), ∃ (c : α), ∀ (d : α), a ∣ d ∧ b ∣ d ↔ c ∣ d) : normalized_gcd_monoid α
{α : Type u} [topological_space α] {s : set α} {x : α} : x ∈ closure s ↔ ∃ (u : ultrafilter α), s ∈ u ∧ ↑u ≤ nhds x
{α : Type u_1} [β : normed_ring α] : semi_normed_ring α
{R : Type u_1} {X : Type u_2} [comm_semiring R] (p : ℕ) [char_p R p] : char_p (free_algebra R X) p
{H : Type u_1} [topological_space H] {x : H} : charted_space.chart_at H x = local_homeomorph.refl H
{R : Type u_1} {a b : R} [add_monoid R] (h : b + a = 0) : is_add_left_regular a
{k : Type u₁} {G : Type u₂} [semiring k] [has_one G] : has_one (monoid_algebra k G)
{α : Type u} [preorder α] {s : set α} {a : α} (h : is_least s a) : bdd_below s
{M : Type u_1} [mul_one_class M] (S : submonoid M) : set M
(p : ℕ) [fact (nat.prime p)] (R : Type u₁) [comm_semiring R] [char_p R p] : perfection_map p (perfection.coeff R p 0)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (Y : category_theory.subobject X) : category_theory.simple ↑Y ↔ is_atom Y
{α : Type u} [preorder α] (s : set α) : set α
{α : Type u} [canonically_ordered_comm_semiring α] [nontrivial α] : 0 < 1
 : ℕ → nat.partrec.code
{G : Type u_2} [add_group G] {a b : {R : Type u_1} {R' : Type u_2} (M : Type u_3) [has_zero R] [has_zero M] [smul_with_zero R M] [has_zero R'] (f : zero_hom R' R) : smul_with_zero R' M
{α : Type u_1} {β : Type u_2} (r : rel α β) (s : set α) : set β
{p : ℕ} : padic_val_int p 1 = 0
{α : Type u_1} (r : α → α → Prop) : set α
{α : Type u} [topological_space α] : set α → set α → Prop
(K : Type u_1) [field K] (L : Type u_2) [field L] [algebra K L] : set (intermediate_field K L)
(C : Type u) [category_theory.category C] : Type (max u v)
(n : ℕ) : list (fin n)
(H : Type u_1) [topological_space H] : pregroupoid H
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b ≤ 1) : a * b < 1
 : list pgame → Type (u+1)
{α : Type u} (s : wseq α) (n : ℕ) : list α
{α : Type u_1} {β : Type u_2} (f : α → β) (ga : α → α) (gb : β → β) : Prop
{R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J : matrix n n R₃) [decidable_eq n] : submodule R₃ (matrix n n R₃)
{α : Type u} [preorder α] (s : set α) : Prop
(α : Type u_1) [topological_space α] : local_homeomorph α α
{α : Type u_1} [partial_order α] [pred_order α] {a : α} : is_min a → order.pred a = a
{R : Type u_1} {M : Type u_2} [comm_ring R] [topological_space R] [add_comm_group M] [module R M] [discrete_topology R] : inhabited (module_filter_basis R M)
{R : Type u_2} {Γ₀ : Type u_3} [comm_ring R] [linear_ordered_comm_monoid_with_zero Γ₀] (v : valuation R Γ₀) : ideal R
(a b : pos_num) : pos_num
{α : Type u_2} [division_monoid α] : division_monoid (filter α)
{α : Type u_1} (l₁ l₂ : list α) : Prop
{K : Type u} [hring : comm_ring K] : ratfunc K → ratfunc K
{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.mk L₁ = free_group.mk L₂) : free_group.reduce L₁ = free_group.reduce L₂
{α : Type u} [pseudo_emetric_space α] {p : α → Prop} (x y : subtype p) : has_edist.edist x y = has_edist.edist ↑x ↑y
{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b) : closure (set.Ioc a b) = set.Icc a b
{ι : Type u_1} [decidable_eq ι] (A : ι → Type u_2) [add_monoid ι] [Π (i : ι), add_comm_monoid (A i)] : Type (max u_1 u_2)
{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b
(C : Type v) (D : Type v') [category_theory.category C] [category_theory.concrete_category C] [category_theory.category D] [category_theory.concrete_category D] : Type (max u_1 u_2 v v')
 : Type
{R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] (Φ : submodule R (module.dual R M)) : submodule R M
{m : Type u_1 → Type u_2} [alternative m] {α : Type u_3} {β : Type u_1} (f : α → m β) : lazy_list α → m β
(α : Type u_1) [complete_lattice α] : Prop
 : Type (u_1+1)
(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [is_noetherian K V] : finset V
 : category_theory.category algebraic_geometry.Scheme
(α : Type u_2) [has_le α] : Prop
{α : Type u} {β : Type v} (f : α → β) : with_top α → with_top β
{α : Type u_1} [semigroup α] : has_dvd α
{α : Type u} [topological_space α] (s : set α) : Prop
{α : Type u} [pseudo_metric_space α] {s : set α} : 0 ≤ metric.diam s
{G : Type u_1} [add_group G] [topological_space G] [topological_add_group G] {H : add_subgroup G} (h_1_int : 0 ∈ interior ↑H) : is_open ↑H
(x y : Set) : Set
{α : Type u_1} [has_le α] [decidable_rel has_le.le] (x y : α) : ordering
{R : Type u} [comm_group R] [star_semigroup R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y
{M : Type u_1} [comm_monoid M] (S : submonoid M) : localization S → localization S → localization S
{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [sM : subsingleton M] : is_smul_regular M 0
{α : Type u_1} (G : simple_graph α) (n : ℕ) : Prop
{α : Type u_1} {β : Type u_2} [tα : topological_space α] [tβ : topological_space β] (f : α → β) : Prop
(M₀ : Type u_4) : Type u_4
{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.snd
{α : Type u_1} [has_one α] [has_add α] [z : has_zero α] : num → α
(F : Type u_1) [field F] (E : Type u_2) [field E] [algebra F E] : Prop
 : Type
(R : Type u) [semiring R] [nontrivial R] (p : ℕ) [hp : char_p R p] [hq : exp_char R 1] : p = 0
{M : Type u_1} [monoid M] {x : M} : 1 ∈ powers x
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) : Prop
(α : Type u_1) [t : topological_space α] : Prop
(α : Type u_2) : Type u_2
{α : Type u_2} [division_comm_monoid α] : division_comm_monoid (set α)
{X : Type u_1} [topological_space X] (S : discrete_quotient X) : setoid X
{k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_semiring k] [group G] [add_comm_monoid V] [module k V] (ρ : representation k G V) : submodule k V
{α : Type u_1} {ι : Type u_2} [semilattice_inf α] [order_bot α] (s : set ι) (f : ι → α) : Prop
{α : Type u_1} (a : α) : pmf α
{α : Type u} [preorder α] {a b c : α} : b ≤ c → a ≤ b → a ≤ c
{α : Type u_1} {β : Type u_2} [fintype (α ⊕ β)] : fintype α
(α : Type u) : Type u
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_initial C] : category_theory.limits.has_zero_object C
(m : Type → Type u) [monad m] : Type (max 1 u)
(R : Type u) (ι : Type u') [decidable_eq ι] [comm_semiring R] (A : Type u_1) [comm_semiring A] [algebra R A] [fintype ι] : multilinear_map R (λ (i : ι), A) A
{G : Type u_1} [add_group G] (H K : add_subgroup G) : Prop
(X : Type u_1) [topological_space X] [compact_space X] [t2_space X] : Compactum
{τ : Type u_1} {α : Type u_2} [canonically_ordered_add_monoid τ] {ϕ : τ → α → α} {s : set α} : is_fw_invariant ϕ s ↔ is_invariant ϕ s
{α : Type u} [pseudo_emetric_space α] {s : set α} : emetric.Hausdorff_edist s s = 0
{α : Type u_1} [denumerable α] : denumerable (finset α)
(α : Type u_1) : Type u_1
(R : Type u) [comm_ring R] : Type u
(α : Type u_1) (n : ℕ) : Type u_1
 : turing.to_partrec.code
{α : Type u} : seq α → ℕ → option α
{A : Type u_1} {B : Type u_2} [fintype B] [set_like A B] : fintype A
(c : Type u → Type v) : Type (max (u+1) v)
{Γ : Type u_1} [inhabited Γ] (f : Γ → Γ) : ℕ → turing.list_blank Γ → turing.list_blank Γ
(X : Top) : CompHaus
(n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) (s : set α) : local_homeomorph α β
{α : Type u} [mul_zero_class α] [has_distrib_neg α] : -0 = 0
(R : Type u) [comm_semiring R] (A : Type v) [comm_semiring A] [algebra R A] : module (set_semiring A) (submodule R A)
(n : ℕ) : ℕ
(α : Type u_1) [topological_space α] [quasi_sober α] [irreducible_space α] : α
{α : Type u_1} [ordered_semiring α] [floor_semiring α] : α → ℕ
{X : Type u_1} [topological_space X] [topological_space.first_countable_topology X] : sequential_space X
{F : Type} [comm_semiring F] (q : ℕ) (f : polynomial F) : Prop
(C : Type u) [category_theory.category C] : Prop
(α : Type u_8) : Type u_8
{ι : Type u_1} (V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (c : complex_shape ι) : Type (max u u_1 v)
{α : Type u} : lazy_list (lazy_list α) → lazy_list α
 : category_theory.limits.has_colimits_of_size (Type (max v u))
{S : Type u_1} [has_add S] (a : S) : add_commute a a
{α : Type u} {β : Type v} [preorder α] [preorder β] (l : α → β) (u : β → α) : Type (max u v)
{α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop
(n : ℕ) : Type
 : monad filter
{G : Type u_1} [add_group G] (S : set G) : add_subgroup G
{α : Type u} [has_neg α] (as : list α) : list α
{X : Type u_1} {Y : Type u_2} {Z : Type u_3} [topological_space X] (f : Y → Z) : locally_constant X Y → locally_constant X Z
(m n : ℕ) : Type
{M : Type u_1} [monoid M] {γ : Type u_2} [monoid γ] {f : M → γ} (hf : is_monoid_hom f) : is_submonoid (set.range f)
{α : Type u_1} (V : set (α × α)) : Prop
{α : Type u_1} (a : α) : generalized_continued_fraction α
{n : ℕ} (x y : bitvec n) : bool
{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : b ≤ -a + c → a + b ≤ c
{R : Type u} [non_assoc_semiring R] : has_inf (subsemiring R)
(α : Type u_1) [bornology α] : Born
{γ : Type u_1} {β : Type u_2} (f : γ → β) (hf : function.injective f) (m : metric_space β) : metric_space γ
(α : Type u) : Type u
{α : Type u_1} [decidable_eq α] {a : α} {z : sym2 α} (h : a ∈ z) : α
{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [nM : nontrivial M] : ¬is_smul_regular M 0
 : Type 1
{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] : pseudo_emetric_space (α × β)
 : nzsnum → snum
{J : Type u₁} [category_theory.category J] [nonempty J] (h : ∀ (j₁ j₂ : J), category_theory.zigzag j₁ j₂) : category_theory.is_connected J
(R : Type u) [non_assoc_ring R] (p : ℕ) [hc : char_p R p] [fintype R] : p ≠ 0
{M : Type u_1} [comm_monoid M] (S : submonoid M) : Type u_1
(R : Type u) [semiring R] : SemiRing
(R : Type u) {A : Type w} [comm_ring R] [semiring A] [algebra R A] : ring A
{P : ℤ → Prop} {m : ℤ} (h0 : P m) (h1 : ∀ (n : ℤ), n ≤ m → P n → P (n - 1)) (n : ℤ) : n ≤ m → P n
(B : Type u) : Type u
(M : Type u_1) [cancel_monoid_with_zero M] [decidable_eq M] [fintype M] [nontrivial M] : group_with_zero M
{M : Type u_3} {N : Type u_4} [has_one M] [has_one N] : has_one (one_hom M N)
{α : Type u} (a : α) : ordnode α
 : parser char
(Γ : Type u_1) (R : Type u_2) [linear_ordered_add_comm_group Γ] [ring R] [is_domain R] : add_valuation (hahn_series Γ R) (with_top Γ)
{ι : Type u_1} {Z : ι → Type u_2} [Π (i : ι), ordered_comm_monoid (Z i)] : ordered_comm_monoid (Π (i : ι), Z i)
{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : ∀ (x y : α), f (x + y) = f x + f y) : is_add_group_hom f
 : path {down := 0} {down := 1}
{σ₁ : Type u_1} {σ₂ : Type u_2} (f₂ : σ₂ → option σ₂) (tr : σ₁ → σ₂) (a₂ : σ₂) : option σ₁ → Prop
(P : Type u_2) [preorder P] : Type u_2
(α : Type u_2) : Type u_2
(R : Type u) : Type u
{α : Type u_1} [topological_space α] [polish_space α] [measurable_space α] [borel_space α] {s : set α} (hs : measurable_set s) : polish_space.is_clopenable s
{α : Type u} {β : Type v} : α ⊕ β → option α
{n m : ℕ} (i : fin m) (h : i.val < n) : fin n
{α : Type u_1} : ordnode α → α → ordnode α → ordnode α
(𝕜 : Type u_5) (𝕜' : Type u_6) [normed_field 𝕜] [semi_normed_ring 𝕜'] : Type (max u_5 u_6)
(α : Type u_1) : Type u_1
{α : Type u_1} [topological_space α] : inhabited (topological_space.compacts α)
{R : Type u_1} {L : Type u_2} [comm_ring R] [lie_ring L] [lie_algebra R L] (H : lie_subalgebra R L) : lie_subalgebra R L
{α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} [topological_space β] [preorder ι] [measurable_space ι] (f : measure_theory.filtration ι m) (u : ι → α → β) : Prop
{G : Type u_1} [hG : group G] [hf : fintype G] {p : ℕ} [hp : fact (nat.prime p)] (h : is_p_group p G) : group.is_nilpotent G
{α : Type u} {n m : ℕ} [has_repr α] : has_repr (matrix (fin m) (fin n) α)
{C : Type u₁} [category_theory.category C] {X : C} (S : category_theory.presieve X) : category_theory.limits.cocone S.diagram
{M : Type u_1} [add_monoid M] (s : set M) : set M
{R : Type u_1} (M : Type u_3) {a : R} [monoid R] [mul_action R M] (ua : is_unit a) : is_smul_regular M a
 : Type
 : set upper_half_plane
 : znum → znum
{α : Type u_1} (r : setoid α) : set (set α)
{α : Type u_1} [i₁ : linear_order α] [i₂ : order_bot α] (h : well_founded has_lt.lt) : conditionally_complete_linear_order_bot α
{α : Type u_1} {β : Type u_2} (f : α → β) : function.injective (quotient.lift f _)
{α : Type u_1} {E : Type u_2} [linear_order E] [has_zero E] [measurable_space α] [has_neg E] (f : measure_theory.simple_func α E) : measure_theory.simple_func α E
(α : Type u_1) (β : Type u_2) [has_le α] [has_le β] : Type (max u_1 u_2)
{R : Type u_1} [ring R] (p q : polynomial R) : polynomial R
{α : Type u_1} {β : Type u_2} [uniform_space α] (f : β → α) (l : filter β) : filter.tendsto (λ (x : β), (f x, f x)) l (uniformity α)
{α : Type u_1} : list (poly α) → poly α
{C : Type u} [category_theory.category C] {J₁ J₂ : category_theory.grothendieck_topology C} (h : category_theory.presieve.is_sheaf J₁ (category_theory.functor.closed_sieves J₂)) : J₁ ≤ J₂
(R : Type u_1) [comm_ring R] (K : Type u_5) [comm_ring K] [algebra R K] : Prop
{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream K
{P : ℤ → Prop} [decidable_pred P] (b : ℤ) (Hb : ∀ (z : ℤ), P z → b ≤ z) (Hinh : ∃ (z : ℤ), P z) : {lb // P lb ∧ ∀ (z : ℤ), P z → lb ≤ z}
{C : Type u_1} [category_theory.category C] [category_theory.abelian C] (X : category_theory.simplicial_object C) : chain_complex C ℕ
{α : Type u_1} {β : Type u_2} (f : α → β) (m : pseudo_metric_space β) : pseudo_metric_space α
{m : Type u → Type v} [monad m] {α : Type u} : option (m α) → m (option α)
(X : Type u_1) [topological_space X] [compact_space X] [t2_space X] : CompHaus
{M : Type u_2} [add_comm_monoid M] {G : Type u_5} [group G] [distrib_mul_action G M] {R : Type u_1} : mul_action G (ray_vector R M)
(k : Type u_1) (G : Type u_2) (V : Type u_3) [comm_semiring k] [monoid G] [add_comm_monoid V] [module k V] : Type (max u_3 u_2)
{M : Type u_1} [add_zero_class M] : has_inf (add_submonoid M)
{α : Type u_1} [has_one α] [has_zero α] [has_lt α] (s : simple_continued_fraction α) : Prop
{m : Type u → Type u} [applicative m] {α β : Type u} (f : α → m β) : lazy_list α → m (lazy_list β)
(n : ℕ) : finset ℕ
{M : Type u_1} [monoid M] (s : set M) : M → Prop
(n : ℕ) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 ≤ x) : 0 ≤ polynomial.eval x (polynomial.cyclotomic n R)
{M₂ : Type u_2} {M₁ : Type u_1} [has_inv M₁] [has_involutive_inv M₂] (f : M₁ → M₂) (hf : function.injective f) (inv : ∀ (x : M₁), f x⁻¹ = (f x)⁻¹) : has_involutive_inv M₁
(α : Type u) : set (set (ultrafilter α))
(α : Type u) (r : α → α → Prop) : Prop
{α : Type u_1} (s : cycle α) : ℕ
{M : Type u_1} [add_comm_monoid M] [module ennreal M] : module nnreal M
(L : first_order.language) : L.Theory
{α : Type u} {β : Type v} [preorder β] (f : α → β) (l : filter α) (a : α) : Prop
(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom (A × B) B
 : num → num → num
(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] : matrix (unit ⊕ l ⊕ l) (unit ⊕ l ⊕ l) R
{A : Type u_1} {ι : Type u_2} [ring A] (B : ι → add_subgroup A) : Prop
{α : Type u_1} {β : Type u_2} [non_unital_semi_normed_ring α] [non_unital_semi_normed_ring β] : non_unital_semi_normed_ring (α × β)
{α : Type u_1} [comm_semiring α] (E : linear_recurrence α) (init : fin E.order → α) : ℕ → α
{p : ℕ} {R : Type u_1} [comm_ring R] (n : ℕ) : witt_vector p R → witt_vector p R
{α : Type u_1} {β : Type u_2} (q : semiquot α) (f : α → semiquot β) : semiquot β
(p : Set → Prop) : Class
{α : Type u_1} (r : α → α → Prop) (s : set α) : Prop
(α : Type u_1) : Type u_1
(α : Type u_2) [has_lt α] : Prop
{α : Type u} [has_zero α] [has_sub α] : list α → list α → list α
(n : ℕ) : Prop
{α : Type u} (s₁ s₂ : stream α) : stream α
{α : Type u_1} (s : cycle α) : cycle α
{α : Type u_1} {n : ℕ} (f : fin n → α) : list α
{C : Type u₁} [category_theory.category C] [category_theory.well_powered C] [category_theory.limits.has_wide_pullbacks C] {A : C} (s : set (category_theory.subobject A)) : category_theory.subobject A
(α : Type u_2) [fintype α] [nonempty α] [semilattice_sup α] : order_top α
{X : Type u_1} [topological_space X] {x y : X} (γ : path x y) : path y x
{α : Type u} [emetric_space α] : continuous (λ (p : α × topological_space.closeds α), emetric.inf_edist p.fst ↑(p.snd))
 : Type
 : ℕ → ℕ → ℕ
{R : Type u} [ring R] (s : set R) (sm : submonoid R) (sa : add_subgroup R) (hm : ↑sm = s) (ha : ↑sa = s) : subring R
{α : Type u_1} [decidable_eq α] : ∅.shadow = ∅
{α : Type u} [preorder α] (s : set α) (a : α) : Prop
{α : Type u_1} {β : Type u_2} (f : α → β) (p : pmf α) : pmf β
(α : Type u) : Type u
 : Type
(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom (A × B) (B × A)
{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : L.prod < 1) : 0 < L.length
{α : Type u_1} [topological_space α] {s t : set α} (hs : is_Gδ s) (ht : is_Gδ t) : is_Gδ (s ∪ t)
(p : ℕ) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] (m : ℤ) : Type u_1
 : Type
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] [topological_space α] (F : ι → α → β) (f : α → β) (p : filter ι) : Prop
{α : Type u} [topological_space α] [nonempty α] (f : filter α) : α
(α : Type u_1) [lattice α] [bounded_order α] : BoundedLattice
{α : Type u} {β : Type v} [group α] [mul_action α β] (a : α) : equiv.perm β
{S : Type u_1} [has_add S] (a b : S) : Prop
{α : Sort u} {β : α → Sort v} [decidable_eq α] (f : Π (a : α), β a) (a' : α) (v : β a') (a : α) : β a
(J : Type v) [category_theory.small_category J] : Type v
 : pos_num → pos_num → num
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} (p : ι → P) : Prop
 : ¬summable (λ (n : ℕ), 1 / ↑n)
{α : Type u_1} [measurable_space α] (s : measure_theory.signed_measure α) : measure_theory.measure α
(o₁ o₂ : onote) : onote
(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] [module.free R M] : Type v
(α : Type u_7) (β : Type u_8) [has_sup α] [has_sup β] [has_bot α] [has_bot β] : Type (max u_7 u_8)
 : pSet → pSet
{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : a ≤ -b → b ≤ -a
{α : Type u} [partial_order α] {a b : α} (h : a ≤ b) : b = a ∨ a < b
{α : Type u_1} (x : α) : free_monoid α
{S : set ℕ} (hb : 0 ∈ S) (h_ind : ∀ (k : ℕ), k ∈ S → k + 1 ∈ S) (n : ℕ) : n ∈ S
{R : Type u} [comm_semiring R] (p : ℕ) (f : polynomial R) : polynomial R
(α : Type u) : Type u
(M : Type u_1) [sub_neg_monoid M] [measurable_space M] [has_measurable_add₂ M] [has_measurable_neg M] : has_measurable_smul₂ ℤ M
 : Type
{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : -a ≤ -b → b ≤ a
{F : Type u_1} (α : Type u_3) (β : Type u_4) [linear_order α] [lattice β] [order_hom_class F α β] (f : F) : lattice_hom α β
{α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : option α → β → γ) (as : list α) (bs : list β) : list γ × list α
(G : Type u_1) [group G] : ℕ → subgroup G
{α : Type u_1} {β : Type u_2} [denumerable α] [denumerable β] : denumerable (α × β)
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (𝒜 : ℕ → submodule R A) [graded_algebra 𝒜] : algebraic_geometry.LocallyRingedSpace
(V : Type u) [quiver V] [quiver.arborescence V] : V
{n : ℕ} {F : typevec n → Type u_1} [mvfunctor F] (q : mvqpf F) : Prop
{α : Type u} [topological_space α] : ultrafilter α → α
(α : Type u_1) : Type u_1
{G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] (K₀ : topological_space.positive_compacts G) : measure_theory.measure G
{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α} : a ≤ b * c → b⁻¹ * a ≤ c
(α : Type u_1) [measurable_space α] : Type u_1
(α : Type u) : Type u
{R : Type u_1} [non_assoc_ring R] [nontrivial R] [no_zero_divisors R] (hR : ring_char R ≠ 2) {a : R} : -a = a ↔ a = 0
 : Type
{V : Type u} (G : simple_graph V) (u v : V) : Prop
{K : Type u_1} [is_R_or_C K] : char_zero K
(G : Type u_2) [group G] (n : ℕ) : set (vector G n)
{M : Type u_3} {N : Type u_4} [has_add M] [add_comm_semigroup N] : has_add (add_hom M N)
{α : Type u} [pseudo_emetric_space α] {s : set α} : continuous (λ (x : α), emetric.inf_edist x s)
 : pgame → pgame → Prop
 : complex_shape ℕ
{α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : (a * d - b * c) / (c * d) ≤ 0 → a / c ≤ b / d
{α : Type u_1} [topological_space α] {U : set α} {hU : is_open U} : ↑⟨U, hU⟩ = U
{α : Type u_1} {β : Type u_2} [topological_space β] [measurable_space α] (f : α → β) : Prop
{R : Type u} {M : Type v} (x : triv_sq_zero_ext R M) : R
 : ℤ
{n : ℕ} (a : fin (n + 1)) : ↑(a.val) = a
{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : is_open_map Z.proj
{n : ℕ} {A : Type u} (F : A → typevec n → Type u) [Π (α : A), mvfunctor (F α)] [Π (α : A), mvqpf (F α)] : mvpfunctor n
{α : Type u_3} {β : Type u_4} [lattice α] [lattice β] [bounded_order α] [bounded_order β] (f : bounded_lattice_hom α β) : inf_top_hom α β
{R : Type u_2} {Γ₀ : Type u_3} {Γ'₀ : Type u_4} [linear_ordered_add_comm_monoid_with_top Γ₀] [linear_ordered_add_comm_monoid_with_top Γ'₀] [ring R] (v₁ : add_valuation R Γ₀) (v₂ : add_valuation R Γ'₀) : Prop
{X : Type u} [topological_space X] {x₀ x₁ : X} (p₀ p₁ : path x₀ x₁) : Type u
(α : Type u) [uniform_space α] : Type (u+1)
{C : Type u} [category_theory.category C] {X : C} (hX : category_theory.limits.is_zero X) : category_theory.limits.is_terminal X
(α : Type u_1) : set (equiv.perm α)
(α : Type u_2) [ordered_add_comm_monoid α] : Prop
(K : Type u_4) (V : Type u) [division_ring K] [add_comm_group V] [module K V] : set V
(α : Type u_1) : Type u_1
{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) : list (sigma β) → option (β a)
{α : Type u_1} {M : Type u_5} [has_one M] (f : α → M) : set α
(α : Type u_1) [topological_space α] : cocompact_map α α
{G : Type u} [group G] {x : G} (hx : is_of_fin_order x) : is_of_fin_order x⁻¹
{α : Type u} [linear_order α] {x y : α} : x < y ∨ y < x ↔ x ≠ y
(n : ℕ) : ∃ (a b c d : ℕ), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n
{V : Type u} (G : simple_graph V) : V → V → Type u
{α : Type u_1} {β : Type u_2} (s : multiset α) (t : multiset β) : multiset (α × β)
{R : Type u} : R → tropical R
{α : Type u} [topological_space α] (K : compact_exhaustion α) (x : α) : ℕ
{ι : Type u_1} {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] (f : ι → α) (g : ι → β) (s : set ι) : Prop
{C : Type u₁} (D : Type u₂) [category_theory.category D] (F : C → D) : Type u₁
{α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] [compact_space α] [separated_space α] {f : α → β} (h : continuous f) : uniform_continuous f
(α : Type u) [topological_space α] : Prop
{α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ c) : a ∣ b + c ↔ a ∣ b
{α : Type u} {β : Type v} (f : α → β) (s : set α) (t : set β) : Prop
{ι : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : ι → set X} {s : set X} (c : set (shrinking_lemma.partial_refinement u s)) : set ι
(α : Type u) [preorder α] : Type (max 1 u)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_colimit (category_theory.limits.pair X Y)] : category_theory.split_mono category_theory.limits.coprod.inr
 : list ℕ → ℕ → list ℕ
{α : Type u_1} [denumerable α] : denumerable (ulift α)
{α : Type u_1} : subsingleton (vector α 0)
{α : Type u_2} {β : Type u_3} {f : α → β} (hf : function.injective f) : filter.tendsto f filter.cofinite filter.cofinite
{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {x : α} : continuous (λ (f : bounded_continuous_function α β), ⇑f x)
{γ : Type w} [metric_space γ] {x y : γ} : has_nndist.nndist x y = 0 → x = y
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) : submodule 𝕜 E
{α : Type u_1} [add_comm_monoid α] [topological_space α] {β : Type u_2} (f : β → α) : α
 : ℕ
(C : Type u) [category_theory.category C] : Prop
{α : Type u} {f g : α → α} (h : function.commute f g) : set.inv_on f g (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g))
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} (C : homological_complex V c) : homotopy_equiv C C
(α : Type u) (β : Type v) [topological_space α] [pseudo_metric_space β] : Type (max u v)
{α : Type u} [uniform_space α] (f : filter α) : Prop
(α : Type u_1) [monoid α] : Type u_1
 : Type
{α : Type u_1} [preorder α] {a b : α} (h : a ≤ b) : set.Iio a ⊆ set.Iic b
(M : Type u) : Type u
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {n : ℕ} (hn : finite_dimensional.finrank K V = n.succ) : nontrivial V
{R : Type u} [semiring R] (p : polynomial R) (a : R) : Prop
{α : Type u_1} {β : Type u_2} (b : β) (f : α → β) : option α → β
{α : Type u} {β : Type v} [omega_complete_partial_order α] [omega_complete_partial_order β] (f : α → β) : Prop
(k : ℕ) {n : ℕ} : fin2 n → fin2 (k + n)
{α : Type u_1} (p : α → Prop) [decidable_pred p] (o : option α) : option α
{n : ℕ} (i : bitvec n) : fin (2 ^ n)
(n : ℕ) : filter.tendsto (λ (x : ℝ), x ^ n * real.exp (-x)) filter.at_top (nhds 0)
{α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] [nonempty α] {s : set α} (hs : is_compact s) : bdd_below s
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : continuous proj
{α : Type u_1} [topological_space α] [non_assoc_ring α] [has_continuous_mul α] : has_continuous_neg α
{α : Type u_4} {β : Type u_5} (r : α → α → Prop) (s : β → β → Prop) : Type (max u_4 u_5)
{α : Type u_1} : partial_order (part α)
(C : Type u) [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_pushouts C] : category_theory.limits.has_binary_coproducts C
{Γ : Type u_1} [inhabited Γ] : list Γ → turing.list_blank Γ → turing.list_blank Γ
{α : Type u_1} (s : seq α) : computation (list α)
{α : Type u_1} (c : set (set α)) : Prop
{C : Type u} [category_theory.category C] (𝒢 : set C) : Prop
{R : Type u} {M : Type v} [comm_ring R] [add_comm_group M] [module R M] (N P : submodule R M) : ideal R
{R : Type u_1} [comm_ring R] (g : matrix.special_linear_group (fin 2) R) : is_coprime (↑g 1 0) (↑g 1 1)
(α : Type u) [preorder α] [nonempty α] [no_min_order α] [no_max_order α] : ∃ (f : ℤ → α), strict_anti f
(G : Type u) [add_comm_group G] : AddCommGroup
(α : Type u) : Type u
{α : Type u} : ordnode α → option (α × ordnode α)
{C : Type u} [category_theory.category C] (X Y : C) : Prop
{α : Type u_1} (op : α → α → α) [hc : is_commutative α op] [ha : is_associative α op] : α → multiset α → α
{α : Sort u} : α → plift α
{C : Type u₁} [category_theory.category C] {A : Type u₂} [category_theory.category A] {J : category_theory.grothendieck_topology C} (ℱ : category_theory.Sheaf J A) (E : A) : category_theory.SheafOfTypes J
(M₀ : Type u_4) : Type u_4
{α : Type u_1} {β : Type u_2} (r : rel α β) : set β
(S : Type u) : Type u
 : turing.to_partrec.code
{R : Type u} [non_assoc_semiring R] (s : set R) : ↑(subsemiring.closure s) = ↑(add_submonoid.closure ↑(submonoid.closure s))
 : snum → snum
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] {i : α → β} [topological_space γ] (di : dense_inducing i) (f : α → γ) (b : β) : γ
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] [measurable_space β] (f : measure_theory.simple_func β γ) (g : α → β) (hgm : measurable g) : measure_theory.simple_func α γ
(R : Type u) [ring R] (E : Type v) [add_comm_group E] [module R E] (F : Type w) [add_comm_group F] [module R F] : Type (max v w)
{R : Type u_1} [comm_semiring R] {A : Type u} [topological_space A] [semiring A] [algebra R A] [topological_semiring A] (s : subalgebra R A) : subalgebra R A
 : onote → onote → onote
 : bounded_order Prop
{b m d : ℕ} (hb : 2 ≤ b) (hd : d ∈ b.digits m) : d < b
{G : Type u} [monoid G] (x : G) : ℕ
{ι : Type u_1} {α : Type u_2} [add_monoid ι] (l : list α) (fι : α → ι) : ι
{α : Sort u} [is_empty α] (β : α → Sort v) : unique (Π (a : α), β a)
(R : Type u₁) (L : Type u₂) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop
(R : Type u_2) [ring R] (Γ₀ : Type u_3) [linear_ordered_add_comm_monoid_with_top Γ₀] : Type (max u_2 u_3)
{α : Type u_1} [has_zero α] [has_one α] [has_add α] [has_neg α] : znum → α
{ι : Type u_1} (A : ι → Type u_2) [add_monoid ι] [graded_monoid.gmonoid A] {i : ι} : mul_action (A 0) (A i)
(C : Type u) [category_theory.category C] : Type (max v u)
{α : Type u_1} [ring α] : complete_semilattice_Inf (ring_topology α)
(V : Type u) : Type u
(p : ℕ) [hp : fact (nat.prime p)] : ℕ → mv_polynomial ℕ ℤ
{m : Type → Type u_1} [monad m] {α : Type u_2} (f : α → α → m unit) : list α → m unit
{α : Type u_1} {n : Type u_2} {m : Type u_3} [has_mul α] [add_comm_monoid α] (A : matrix m n α) [fintype n] : Prop
(V : Type u) : simple_graph V
{G : Type u_1} [group G] (K V : set G) : ℕ
(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [has_le α] [has_le β] [bounded_order α] [bounded_order β] : Type (max u_6 u_7 u_8)
{p : ℕ} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (x : witt_vector p R) : witt_vector p R
{ι : Type u_1} (A : ι → Type u_2) [has_add ι] : Type (max u_1 u_2)
{α : Type u} : lazy_list α → ℕ → option α
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_pullbacks C] : category_theory.limits.has_equalizers C
{α : Type u_1} [preorder α] [succ_order α] {a b : α} [no_max_order α] : a < b → order.succ a < order.succ b
{α : Type u_1} (r : α → α → Prop) [wo : is_well_order α r] : ordinal
{n : ℕ} (i : fin (n + 2)) : fin (n + 1)
(α : Type u) [has_mul α] [has_le α] : Prop
{α : Type u} {σ' : Type v} (M : DFA α σ') : NFA α σ'
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [non_unital_non_assoc_ring α] [non_unital_non_assoc_ring β] [topological_ring α] [topological_ring β] : topological_ring (α × β)
{α : Type u_2} {β : Type u_3} [decidable_eq α] [has_vsub α β] : has_vsub (finset α) (finset β)
(R : Type u_1) [ordered_comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] : setoid (ray_vector R M)
{α : Type u_1} [has_add α] [has_le α] (a : α) : Prop
(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [preorder α] [preorder β] : Type (max u_6 u_7 u_8)
{n : ℕ} (c : composition_as_set n) (i : fin c.length) : ℕ
{S : Type u} [has_mul S] {a x y : S} (h : semiconj_by a x y) : a * x = y * a
{α : Sort u_1} [is_empty α] {p : α → Sort u_2} (a : α) : p a
{n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) : fin.cons (q 0) (fin.tail q) = q
 : Type
(α : Type u) : Type u
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{R : Type u_1} [comm_semiring R] (s : subsemiring R) (m : multiset R) : (∀ (a : R), a ∈ m → a ∈ s) → m.prod ∈ s
(G₀ : Type u_4) [has_zero G₀] [has_inv G₀] [topological_space G₀] : Prop
{R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] : Prop
{α  : Type (u+1)
(A : Type u_2) [comm_ring A] [is_domain A] : Prop
{α : Type u_2} [division_monoid α] : division_monoid (set α)
{α : Type u_1} [add_semigroup α] (x y : α) : has_add.add x ∘ has_add.add y = has_add.add (x + y)
{b : ℕ} {S : set ℕ} (hb : b ∈ S) (h_ind : ∀ (k : ℕ), k ∈ S → k + 1 ∈ S) {n : ℕ} (hbn : b ≤ n) : n ∈ S
 : list name
{ι : Type u_1} [encodable ι] {E : ι → Type u_2} [Π (n : ι), topological_space (E n)] [∀ (n : ι), polish_space (E n)] : polish_space (Σ (n : ι), E n)
{n : ℕ} : 0 < n → 0 < szemeredi_regularity.step_bound n
{M : Type u_1} [add_monoid M] {x : M} : x ∈ multiples x
 : Type
{R : Type u} [non_assoc_semiring R] (self : subsemiring R) : add_submonoid R
 : filter.tendsto complex.exp (filter.comap complex.re filter.at_top) (filter.comap complex.abs filter.at_top)
{G : Type u_1} [has_mul G] : G → G → G
{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} : function.injective coe_fn
{m : Type u_1} {R : Type u_2} [fintype m] [comm_ring R] (M : matrix m m R) : Prop
{ι : Type u_1} {β : ι → Type u_2} [linear_order ι] [is_well_order ι has_lt.lt] [Π (a : ι), linear_order (β a)] : linear_order (lex (Π (i : ι), β i))
(f : ordinal → ordinal) : ordinal → ordinal
{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_finite_colimits C
{R : Type u} [semiring R] (p : polynomial R) : finset R
 : pnat.xgcd_type → pnat.xgcd_type
{G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ↔ is_of_fin_add_order x
{X : Type u_1} : alexandroff X
{X : Type u_1} [topological_space X] [preconnected_space X] [noncompact_space X] : connected_space (alexandroff X)
{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → option α
(T : Type u) [topological_space T] : category_theory.pretopology (topological_space.opens T)
 : parser ℕ
{n : Type u_3} {α : Type v} [fintype n] [semiring α] [star_ring α] : star_ring (matrix n n α)
(α : Type u_7) (β : Type u_8) [lattice α] [lattice β] : Type (max u_7 u_8)
(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom (A × B) A
{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] : continuous (λ (g : G × G), g.fst * g.snd * (g.fst)⁻¹)
 : lattice circle_deg1_lift
{G : Type u_1} [group G] : has_inf (subgroup G)
{α : Type u_1} {β : Type u_2} [add_comm_monoid α] [topological_space α] : has_sum (λ (b : β), 0) 0
 : Type
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [polish_space β] {f : α → β} (hf : closed_embedding f) : polish_space α
{Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ) : ∃ (a : Γ) (l' : turing.list_blank Γ), l = turing.list_blank.cons a l'
{α : Sort u_1} {p : α → Prop} (P : ∃ (a : α), p a) : p P.some
(X : Type u) [add_group X] : AddGroup
(n : ℕ) : ℕ
{α : Type u_1} (s₁ s₂ : multiset α) : multiset α
{R : Type u} [field R] (p q : polynomial R) : polynomial R
{α : Type u} (x : α) : dlist α → dlist α
(α : Type u_1) [has_one α] [has_zero α] [has_lt α] : Type u_1
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (N : submodule R M) : submodule R M
{α : Type u_2} [decidable_eq α] [monoid α] : monoid (finset α)
 : Type
{α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v a : α) : uv.compress u v (uv.compress u v a) = uv.compress u v a
{α : Type} (sep : parser unit) (p : parser α) : parser (list α)
{α : Type u_1} {r : α → α → Prop} (h : reflexive r) {x y : α} : x ≠ y → r x y ↔ r x y
{α : Type u_1} [topological_space α] [ring α] [topological_ring α] (S : subring α) : subring α
{R : Type u_1} {E : Type u_2} {ι : Type u_4} [linear_ordered_field R] [add_comm_group E] [module R E] (t : finset ι) (w : ι → R) (z : ι → E) : E
(n : ℕ) : ℕ → ℕ
(G : Type u_1) [group G] : is_ascending_central_series (upper_central_series G)
{α : Type u_1} {β : Type u_2} [encodable α] [encodable β] : encodable (α ⊕ β)
{p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2
(c d : ℕ) : ℤ → ℤ → Prop
{α : Type u} {β : Type v} {γ : Type w} (g : β → γ) (f : α → β) : list.map g ∘ list.map f = list.map (g ∘ f)
{X : Type u_1} {α : Type u_2} [has_zero α] [topological_space X] (f : X → α) : set X
{R : Type u_1} [mul_zero_class R] : ¬is_right_regular 0 ↔ nontrivial R
 : Type
(F : Type u_1) (K : Type u_2) [field F] [comm_ring K] [is_domain K] [algebra F K] [finite_dimensional F K] : field K
{G : Type w} [topological_space G] [group G] [topological_group G] (s : subgroup G) : subgroup G
{C : Type u} [category_theory.category C] {ι : Type u_1} (s : ι → C) : Prop
{α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop
{α : Type u} [pseudo_metric_space α] {s : set α} {x y : α} (h : y ∈ s) : metric.inf_dist x s ≤ has_dist.dist x y
(L : first_order.language) {M : Type u_3} (s : setoid M) : Type (max u_1 u_2 u_3)
{α : Type u} {β : α → Type v} [decidable_eq α] (s₁ s₂ : alist β) : alist β
{X : Type u_2} [emetric_space X] (m : ennreal → ennreal) : measure_theory.outer_measure X
{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] : has_coe (matrix.special_linear_group n ℤ) (matrix.special_linear_group n R)
{α : Type u_1} [is_empty α] (s : finset α) : s = ∅
 : list name
(α : Type u) : Type (max u (v+1))
(α : Type u_1) [preorder α] : Type u_1
{α : Type u_1} [topological_space α] [comm_ring α] [topological_ring α] (S : ideal α) : ideal α
(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] [module.free R M] : basis (module.free.choose_basis_index R M) R M
(C : Type u_1) [category_theory.category C] : Type
{α : Type u} (c : computation α) : option α
(R : Type u_1) [comm_ring R] : ring_invo R
{K : Type u_1} [linear_ordered_field K] (pconts conts : generalized_continued_fraction.pair K) (fr : K) : K
{α : Type u} (x : α) : ordnode α → Prop
{R : Type u_1} [ring R] [topological_space R] [nonarchimedean_ring R] (U : open_add_subgroup R) : ∃ (V : open_add_subgroup R), ↑V * ↑V ⊆ ↑U
 : ℕ → ℕ
(G : Type u_3) [group G] : Prop
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop
{α : Type u} {β : α → Type v} (s₁ s₂ : alist β) : Prop
(n : num) : num
(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom (A × B) B
{α : Type uu} (r : α → α → Prop) [decidable_rel r] (a : α) : list α → list α
{α : Type u_2} (A : set α) (β : Type u_7) [add_comm_monoid α] [add_comm_monoid β] (n : ℕ) : Type (max u_2 u_7)
{α : Type u} [preorder α] {s : set α} {a : α} (h : is_lub s a) : bdd_above s
{α : Type u} (s : seq α) : list α
{α : Sort u_1} {β : Sort u_2} (f : α → β) (c : ∀ (a b : α), f a = f b) : trunc α → β
{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) [nonempty β] : function.injective f
 : ℕ → ℕ → list ℕ
{α : Type u_1} [linear_order α] [topological_space α] [compact_Icc_space α] {a b : α} : is_compact (set.interval a b)
{α : Type u} [topological_space α] (x : α) : set α
{R₃ : Type u_7} {M₃ : Type u_8} [comm_ring R₃] [add_comm_group M₃] [module R₃ M₃] (B₃ : bilin_form R₃ M₃) : submodule R₃ (module.End R₃ M₃)
{α : Type u_1} [preorder α] [decidable_rel has_le.le] (x : α) (s : ordset α) : option α
(x : set Class) : Class
{V : Type u} (G : simple_graph V) : Type u
{α : Type u_1} {β : Type u_2} (f : α → β) (q : semiquot α) : semiquot β
(cs : list omega.clause) : Prop
(b : onote) : onote → Prop
{α : Type u} [ordered_add_comm_monoid α] : ordered_add_comm_group (add_units α)
(m n : ℕ) : option ℕ
(X : Top) (T : Type v) : Top.presheaf (Type v) X
(α : Type u_7) (β : Type u_8) [has_inf α] [has_inf β] : Type (max u_7 u_8)
(K : Type u_1) [field K] : Type u_1
{o : ordinal} : ordinal.principal has_add.add o ↔ o = 0 ∨ ∃ (a : ordinal), o = ordinal.omega ^ a
{M : Type u_1} [monoid M] : mul_distrib_mul_action (mul_aut M) M
(α : Type u_1) (β : Type u_2) [topological_space α] [topological_space β] [group β] [topological_group β] : subgroup (α → β)
{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} : a⁻¹ < b → b⁻¹ < a
{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : ifp_n.fr < 1
{L : first_order.language} (K : set (category_theory.bundled L.Structure)) : Prop
 : gcd_monoid ℕ
{M : Type u} [monoid M] (a : M) : a ^ 2 = a * a
 : pgame → Prop
 : name → name
 : Type
{α : Type u} [inhabited α] (a : α) : list α → ℕ → list α
{α : Type u_1} (s : set (set α)) : measurable_space α
 : nat.arithmetic_function ℕ
(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) [char_zero k] (h : s.card ≠ 0) : s.sum (λ (i : ι), finset.centroid_weights k s i) = 1
{α : Type u} {β : Type v} [add_group α] [add_action α β] (a : α) : equiv.perm β
{R : Type u_1} {S : Type u_2} [ring R] [topological_space R] [nonarchimedean_ring R] [ring S] [topological_space S] [nonarchimedean_ring S] : nonarchimedean_ring (R × S)
{R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p
{α : Type u} [topological_space α] (s : set α) : Prop
(a : pos_num) : pos_num
{α : Type u_1} {β : Type u_2} (f : α → β → β) (b : β) : list α → β × list β
{α : Type u_1} (r : α → α → Prop) (s : set α) : Prop
{n : ℕ} [fact (0 < n)] : fintype (quaternion_group n)
{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : -a ≤ 0 ↔ 0 ≤ a
(C : Type u) [category_theory.category C] : Prop
{n p k : ℕ} (hn : n ≠ 0) (h : n.factorization = finsupp.single p k) : n = p ^ k
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (c : add_con M) (f : M → N) : add_con N
(p n : ℕ) : mv_polynomial (fin 2 × ℕ) ℤ
{α : Type u} (s : wseq α) : wseq (list α)
{α : Type u} {β : Type v} [semiring α] [semiring β] {f : α → β} (hf : is_semiring_hom f) : is_add_monoid_hom f
{α : Type u_1} (p : α → Prop) [decidable_pred p] : list α → option α
{α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} (h : s ⊆ t) : emetric.inf_edist x t ≤ emetric.inf_edist x s
(α : Type u_5) (β : Type u_6) [non_assoc_semiring α] [non_assoc_semiring β] : Type (max u_5 u_6)
{R : Type u_1} [comm_ring R] (c₁ c₂ : R) : quadratic_form R (R × R)
(X : Type u) [topological_space X] : Top
{R : Type u_1} {S : Type u_3} [non_unital_comm_semiring R] [non_unital_comm_semiring S] : non_unital_comm_semiring (R × S)
(α : Type u) : Type u
{α : Type u_1} (R : α → α → Prop) : list α → Prop
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (H : lie_subalgebra R L) : Prop
{α : Type u} {β : Type v} (f : α → β) (l₁ : filter α) (l₂ : filter β) : Prop
{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a ≤ b → finset.Icc a b = ∅
 : well_founded nat.lt
{n : ℕ} (i : ℕ) (h : i < n) : fin n
 : Type
{α : Type u} : has_inf (filter α)
{M : Type u_3} [add_monoid M] (L : list M) (h : L.sum ≠ 0) : 0 < L.length
{α : Type u_1} (g : generalized_continued_fraction α) (n : ℕ) : Prop
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
 : Type (u_1+1)
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)
{α : Type u} [decidable_eq α] : list α → list (finset α)
(G : pgame) : ordinal
{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] : pseudo_metric_space (bounded_continuous_function α β)
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] : Type (max u v)
{M : Type u_1} [has_add M] : has_Inf (add_con M)
 : matrix.special_linear_group (fin 2) ℤ
 : name → ℕ → name
{k : Type u} [linear_ordered_field k] {a : k} (ha : 0 < a) : (set.Ioo 0 a)⁻¹ = set.Ioi a⁻¹
(A : Type u) [comm_ring A] (K : Type v) [field K] [algebra A K] : Type v
{R : Type u} [comm_ring R] (x y : R) (i : ℕ) : {z // x ^ i - y ^ i = z * (x - y)}
{α : Type u_1} {s t : set α} : s = t → s ⊆ t
{α : Type u_1} (q : semiquot α) : trunc α
{𝕜 : Type u_1} {E : Type u_2} [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] (K : geometry.simplicial_complex 𝕜 E) : set (finset E)
{α : Type u_1} : ℕ → list α → list α × list α
{γ : Type w} [emetric_space γ] {x y : γ} : has_edist.edist x y = 0 ↔ x = y
 : seq ℕ
{α : Type u_1} {β : α → Type u_2} : (Σ (a : α), β a → W_type β) → W_type β
{n : ℕ} (P : mvpfunctor (n + 1)) : P.last.M → fin2 n → Type u
{α : Type u_1} [decidable_eq α] (s : multiset α) : s - 0 = s
(R : Type u) [field R] : is_field R
(β : Type v) (C : Type u_1) [category_theory.category C] : Prop
(α : Type u_2) [fintype α] [nonempty α] [semilattice_inf α] : order_bot α
{α : Type u} {β : α → Type v} (s : multiset (sigma β)) : multiset α
{α : Type u_1} {β : Type u_2} (q : semiquot α) (f : α → β) (h : ∀ (a : α), a ∈ q → ∀ (b : α), b ∈ q → f a = f b) : β
(A : Type) [metric_space A] : Type 1
{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) : A⁻¹ = ring.inverse A
{α : Type u} [topological_space α] (a : α) (s : set α) : filter α
{α : Type u} [inhabited α] (as1 as2 : list α) : Prop
{α : Type u_1} {β : Type u_4} [preorder α] [preorder β] {l : α → β} {u : β → α} (gc : galois_connection l u) : lower_adjoint u
{α : Type u} (s : stream α) : stream (stream α)
{M₀ : Type u_1} [monoid_with_zero M₀] (x : M₀) (h : ¬is_unit x) : ring.inverse x = 0
{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] [subsingleton ι] (p : ι → E) : convex_independent 𝕜 p
{α : Type u} (s : seq α) : option α
(m M N : ℕ) : finset (Σ (n : ℕ), fin n → ℕ)
{α : Type u} {β : Type u_1} (t₁ : ordnode α) (t₂ : ordnode β) : ordnode (α × β)
(R : Type u_1) [comm_ring R] {A : Type u} [topological_space A] [ring A] [algebra R A] [topological_ring A] (x : A) : subalgebra R A
{α : Type u} (s : set α) : Prop
{α : Type u} {β : Type u_1} (t₁ : ordnode α) (t₂ : ordnode β) : ordnode (α ⊕ β)
(R : Type u_2) [comm_ring R] : Type u_2
{α : Type u} {β : α → Type v} : list (sigma β) → list α
{α : Type u_2} [monoid α] (m : α) : (∃ (c : α), m = c ^ 2) → is_square m
{α : Type u} [uniform_space α] (s : set α) : Prop
{α : Sort u_1} {r : α → α → Prop} (q : quot r) : α
(C : Type u) [category_theory.category C] : Prop
(α : Type u) (r : α → α → Prop) : Prop
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J → C) [category_theory.limits.has_coproduct f] : category_theory.limits.has_biproduct f
{α : Type u_1} {n : ℕ} (a : α) (v : vector3 α n) : vector3 α n.succ
 : golden_conj⁻¹ = -golden_ratio
 : Type
(F : Type u_8) (α : out_param (Type u_9)) (β : out_param (Type u_10)) [has_Sup α] [has_Sup β] : Type (max u_10 u_8 u_9)
(X Y : Top) : category_theory.limits.binary_fan X Y
{α : Type u} [topological_space α] (a : α) : filter α
(α : Type u) [has_one α] [has_mul α] : category_theory.category_struct (category_theory.single_obj α)
{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → ordnode α
 : num → znum
{α : Type u} [preorder α] [no_min_order α] (a : α) : ∃ (f : ℕ → α), strict_anti f ∧ f 0 = a
{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : 0 < -a ↔ a < 0
{α : Type u_1} (p : two_pointing α) : two_pointing α
{C : Type u₁} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) {T : C} (hT : category_theory.limits.is_terminal T) : category_theory.mono (hT.from A)
(α : Type u) {β : Type v} [monoid α] [mul_action α β] (b : β) : submonoid α
(α : Type u_3) [topological_space α] : Prop
{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream K
{α : Type u} [topological_space α] (s : set α) : set α
{M : Type u_1} [monoid M] (s : submonoid M) {l : list M} (hl : ∀ (x : M), x ∈ l → x ∈ s) : l.prod ∈ s
{ι : Type u_1} {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] (f : ι → α) (g : ι → β) : Prop
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) : Type (max u v)
{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_right_regular (b + a)) : is_add_right_regular b
(α : Type u_3) [measurable_space α] : Type u_3
{α β : ordinal} (h : α < β) : principal_seg has_lt.lt has_lt.lt
{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (b : B) : continuous (bundle.total_space_mk b)
(R : Type u_1) [comm_ring R] : Type u_1
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) : Prop
{G : Type u_1} {A : Type u_2} {B : Type u_3} [group G] [mul_action G A] : mul_action G (A → B)
(α : Type u) [preorder α] [nonempty α] [no_min_order α] [no_max_order α] : ∃ (f : ℤ → α), strict_mono f
{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) : list (Σ (a : α), β a) → option (β a)
{α : Type u} [has_le α] [decidable_rel has_le.le] : ordnode α → ordnode α → ordnode α
(C : Type u₁) [category_theory.category C] [category_theory.monoidal_category C] : Mon_ C
{α : Type u_1} {β : Type u_2} [tα : topological_space α] [tβ : topological_space β] (f : α → β) : Prop
{α : Sort u_1} {β : Sort u_2} (f : α → β) : nonempty α → nonempty β
(C : Type u) [category_theory.category C] : Prop
{H : Type u} [topological_space H] : closed_under_restriction id_restr_groupoid
{α : Type u} (i : ℕ) (t : ordnode α) : ordnode α × ordnode α
{α : Type u_1} [semigroup α] [partial_order α] [contravariant_class α α has_mul.mul has_le.le] : left_cancel_semigroup α
{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) : list (sigma β) → list (β a)
{α : Type u} {β : α → Type v} (s : multiset (sigma β)) : Prop
{α : Type u_1} [conditionally_complete_lattice α] (f : filter α) : α
{b : ℕ} {l : list ℕ} (hb : 2 ≤ b) (hl : ∀ (x : ℕ), x ∈ l → x < b) : nat.of_digits b l < b ^ l.length
 : Type (u_1+1)
{R : Type u} [ring R] : has_inf (subring R)
{α : Type u} {β : Type v} {γ : Type w} (f : β → γ) : option (α × β) → option (α × γ)
(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom A (A × B)
(α : Type u_1) [complete_lattice α] : Prop
{C : Type u} [category_theory.category C] (X : C) [category_theory.limits.has_binary_coproducts C] : category_theory.monad C
{α : Type u_1} [unique α] : encodable α
(R : Type u_1) [has_mul R] [has_add R] : group (ring_aut R)
 : ℕ
{α : Type u} (l : list α) : seq α
(α : Sort u) : Sort u
(α : Type u_2) [preorder α] [topological_space α] : Type
(ι : Type u_1) (𝕜 : Type u_3) [is_R_or_C 𝕜] (E : Type u_4) [inner_product_space 𝕜 E] [fintype ι] : Type (max u_1 u_3 u_4)
 : Type
{α : Type} (p : parser α) : parser (list α)
{G : Type u} [group G] (B : group_filter_basis G) : topological_space G
{G : Type u} [add_group G] (a x : G) : add_semiconj_by a x (a + x + -a)
{F : Type u_1} [field F] (S : set F) : Prop
(M : Type u_1) [measurable_space M] [has_inf M] : Prop
(k : ℕ) (R : Type u_1) [comm_ring R] [is_domain R] : finset R
{R : Type u_1} [rack R] {G : Type u_2} [group G] (f : shelf_hom R (quandle.conj G)) : rack.pre_envel_group R → G
{ι : Type u_1} {E : ι → Type : Type
{α : Type u_2} {β : Type u_3} [has_vadd α β] : has_vadd (set α) (set β)
 : turing.to_partrec.code
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [h : subsingleton V] : finite_dimensional.finrank K V = 0
{G : Type u_1} [group G] (S T : set G) : Prop
(a b : nonote) : ordering
(c : cardinal) : Prop
 : primrec (λ (a : (ℕ × nat.partrec.code) × ℕ), nat.partrec.code.evaln a.fst.fst a.fst.snd a.snd)
{α : Type u_1} {β : Type u_2} [preorder α] [order_bot α] [partial_order β] {l : α → β} {u : β → α} (gc : galois_connection l u) : order_bot β
 : ℕ
 : ordinal → pgame
{G : Type u_1} [comm_group G] : group.is_nilpotent G
{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [linear_ordered_comm_ring R] (g : matrix.special_linear_group n R) : ↑↑↑g = ↑g
(α : Type u_1) : Type u_1
(G : Type u_1) [group G] (n : ℕ) : subgroup G
{α : Type u} [monoid α] {a : α} (h : is_unit a) : invertible a
{α : Type u_1} [decidable_eq α] [fintype α] (f : equiv.perm α) : finset α
{α : Type u} {β : Type u_1} (f : α → β) : tree α → tree β
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
(α : Type u_5) (β : Type u_6) [topological_space α] [topological_space β] : Type (max u_5 u_6)
{K : Type u} [field K] (s : subfield K) : add_subgroup K
(R : Type u) [comm_ring R] : Type u
{M : Type w} (A : set M) (L : first_order.language) [L.Structure M] {α : Type u_1} (s : set (α → M)) : Prop
{α : Type u_1} {R : α → α → Prop} [decidable_rel R] {l : list α} : list.pairwise R l → list.pw_filter R l = l
{α : Type u} {β : Type v} {γ : Type w} (h : β → γ) (g : α → β) (l : list α) : list.map (h ∘ g) l = list.map h (list.map g l)
(R : Type u_1) [ordered_comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] (ι : Type u_4) [decidable_eq ι] : Type (max u_2 u_1 u_4)
(x y : {x // x.numeric}) : Prop
(J : Type u₁) [category_theory.category J] (C : Type u) [category_theory.category C] : Prop
(F : pfunctor) : Type u
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) (s : set α) : Prop
(R : Type u_1) [semiring R] : Type u_1
{R : Type u_1} [has_zero R] [has_one R] : dual_number R
(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [mul_one_class M] [mul_one_class N] : Type (max u_10 u_11 u_9)
{M : Type u_3} {N : Type u_4} {P : Type u_5} [has_zero M] [has_zero N] [has_zero P] (hnp : zero_hom N P) (hmn : zero_hom M N) : zero_hom M P
{α : Type u_1} (x : α) : lazy_list α → Prop
(M₀ : Type u_4) [has_mul M₀] [has_zero M₀] : Prop
(G : Type u) [add_monoid G] : ℕ
{α : Type u_1} (q : semiquot α) : Prop
{α : Type u} [monoid α] (a : α) : set α
(α : Type u) (β : Type v) [add_monoid α] [add_action α β] : set β
(α : Type u_2) [preorder α] : Type u_2
{α : Type u_1} [lattice α] [order_bot α] {a : α} (ha : is_atom a) : unique (finpartition a)
{α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] : opens_measurable_space α
(α : Type u_3) [topological_space α] : Type u_3
{α : Type u_2} [add_comm_monoid α] : multiset α → α
{α : Type u_1} [preorder α] (b : α) : set α
{𝒜 : Type u_1} [category_theory.category 𝒜] [category_theory.preadditive 𝒜] [category_theory.limits.has_kernels 𝒜] [category_theory.limits.has_images 𝒜] [category_theory.limits.has_binary_biproducts 𝒜] (A B : 𝒜) : category_theory.exact category_theory.limits.biprod.inl category_theory.limits.biprod.snd
(F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] : E → Prop
{α : Type u_1} [decidable_eq α] [fintype α] : monotone finset.up_shadow
{α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : (-1) * a = -a
{α : Type u} {β : Type w} : buffer α → (α → β) → buffer β
{X : Top} {C : Type u} [category_theory.category C] (F : Top.presheaf C X) : Prop
{α : Type u} [preorder α] (s : set α) : set α
{α : Type u_1} [semigroup_with_zero α] {a : α} : 0 ∣ a ↔ a = 0
 : Type (u+1)
{K : Type u} [hfield : field K] (x : ratfunc K) : polynomial K × polynomial K
(G : pgame) : Prop
 : Type
{α : Sort u} {β : Sort v} (a : α) : β
{α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] (hf : measure_theory.strongly_measurable f) : topological_space.is_separable (set.range f)
{α : Type u} [group_with_zero α] {a : α} [invertible a] : invertible a⁻¹
{S : Type u_1} [has_mul S] (a b : S) : Prop
{m : Type u_2} {α : Type v} [fintype m] [has_mul α] [add_comm_monoid α] (v w : m → α) : α
{α : Type u} (S : wseq (wseq α)) : wseq α
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : affine_subspace k P) : submodule k V
{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : -b + a < c → a < b + c
{α : Type u} {a b : α} [mul_zero_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a * b
{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : Type (max u_2 u_3)
{α : Type u_1} [comm_monoid_with_zero α] (p : α) : Prop
{α : Type u} {β : Type v} : α ⊕ β → β ⊕ α
(R : Type u_1) [monoid_with_zero R] : submonoid R
(α : Type u_3) [h : topological_space α] : Prop
{α : Type u} {β : Type v} [mul_one_class α] [mul_one_class β] (f : α → β) : Prop
(F : Type u_7) (α : out_param (Type u_8)) (β : out_param (Type u_9)) [has_sup α] [has_sup β] [has_bot α] [has_bot β] : Type (max u_7 u_8 u_9)
{α : Type u} (r : α → α → Prop) (s : set α) : Prop
{k : Type u₁} {G : Type u₂} {A : Type u_1} [comm_semiring k] [semiring A] [algebra k A] [monoid G] : algebra k (monoid_algebra A G)
{C : Type u_1} [category_theory.category C] [category_theory.abelian C] (X : category_theory.simplicial_object C) (n : ℕ) : category_theory.subobject (X.obj (opposite.op (simplex_category.mk n)))
{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : ¬has_btw.btw c b a
(R : Type u_1) (S : Type u_2) (M : Type u_3) [semiring S] [add_comm_monoid M] [comm_semiring R] [algebra R S] [module S M] : module R (restrict_scalars R S M)
 : znum → znum
{m : Type u_3} {α : Type u_5} [fintype m] [is_R_or_C α] [decidable_eq m] : normed_ring (matrix m m α)
{R : Type u_1} [ring R] {M : Type u_2} [add_comm_group M] [module R M] [decidable_eq (module.End R M)] [is_simple_module R M] : division_ring (module.End R M)
(F : Type u_7) (R : out_param (Type u_8)) (S : out_param (Type u_9)) [has_mul R] [has_add R] [has_mul S] [has_add S] : Type (max u_7 u_8 u_9)
{R : Type u} [comm_ring R] (a : R) (p : polynomial R) : ℕ
(α : Type u_5) [topological_space α] : Prop
 : ℕ → pgame
{G : Type u_1} [group G] (s : set G) : set G
 : Type
{α : Type u_1} [cancel_comm_monoid_with_zero α] [decidable_eq α] (h : ∀ (a b : α), ∃ (c : α), ∀ (d : α), a ∣ d ∧ b ∣ d ↔ c ∣ d) : gcd_monoid α
{A : Type u_2} [add_group A] (H : add_subgroup A) : Prop
(K : Type u_1) [field K] : subalgebra ℤ K
{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → ordnode α
{α : Type u} {β : α → Type v} [decidable_eq α] (s₁ s₂ : finmap β) : finmap β
 : bool → snum → snum
{R : Type u_1} [comm_ring R] {n : ℕ} (v : fin n → R) : matrix (fin n) (fin n) R
{R : Type u_1} {A : Type u_2} [has_zero A] (r : R) : unitization R A
{n : ℕ} (x y : bitvec n) : Prop
(G : Type u) [div_inv_monoid G] [measurable_space G] [has_measurable_mul₂ G] [has_measurable_inv G] : has_measurable_pow G ℤ
(X : Type u_5) [t : topological_space X] : Prop
{α : Type u_1} [has_add α] [has_le α] [contravariant_class α α has_add.add has_le.le] {a b c : α} (bc : a + b ≤ a + c) : b ≤ c
{α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.mk (free_group.reduce L) = free_group.mk L
{k : Type u₁} {G : Type u₂} [semiring k] [has_add G] : has_mul (add_monoid_algebra k G)
(L : first_order.language) (L' : first_order.language) : Type (max u u' v v')
(𝕜 : Type u_4) (E : Type u_5) [is_R_or_C 𝕜] : Type (max u_4 u_5)
{α β : Type} (f : α → β → β) (p : parser α) (b : β) : parser β
 : Type
 : Type
{X : Type u_1} [topological_space X] {s : set X} (hs : is_closed s) : is_seq_closed s
(A : Type u_4) [add_monoid A] [topological_space A] : continuous_add_monoid_hom A A
(x y : Set) : Set
(n : ℕ) : ℕ × ℕ
(R : Type u_1) [euclidean_domain R] : gcd_monoid R
{m : Type u → Type v} [applicative m] {α : Type u_1} {β : Type u} (f : ℕ → α → m β) (start : ℕ) (as : list α) : m (list β)
{α : Type u} {β : Type v} {γ : Type w} (f : α → β → γ) : seq α → seq β → seq γ
(M : Type u_10) (A : Type u_11) [monoid M] [add_monoid A] : Type (max u_10 u_11)
{Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ) : Γ
{R : Type u_1} [comm_monoid_with_zero R] (n : R) : Prop
{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] : has_involutive_neg (module.ray R M)
(x : Class) : set Class
(R : Type u) [ring R] : subring R
{p : ℕ} : padic_val_nat p 1 = 0
{α : Sort u_1} {p : α → Prop} (x : subtype p) : p ↑x
 : Type
{ι : Type u_1} {E : ι → Type u_2} [Π (i : ι), topological_space (E i)] [encodable ι] [∀ (i : ι), topological_space.second_countable_topology (E i)] : topological_space.second_countable_topology (Σ (i : ι), E i)
{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream (generalized_continued_fraction.pair K)
{G : Type u_1} [group G] : complete_lattice (subgroup G)
(C : Type u) [category_theory.category C] : Prop
(C : Type u) [category_theory.category C] : Type u
{M : Type u_1} [has_mul M] : has_le (con M)
{G : Type u_1} [group G] (H : subgroup G) : Prop
 : distrib_lattice Prop
(α : Type u) : Type u
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : add_submonoid A
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (s : set α) : continuous (λ (F : C(α, β)), continuous_map.restrict s F)
(C : Type u) : Type u
{C : Type u} [category_theory.category C] (X : C) : Type (max u v)
{α : Type u_1} {n : ℕ} (v : vector3 α n.succ) : α
{α : Type u} (s : computation α) (a : α) (n : ℕ) : Prop
{m : Type u_2} {n : Type u_3} {α : Type v} (M : matrix m n α) (i : m) (j : n) : M.transpose j i = M i j
(G₀ : Type u_4) : Type u_4
{α : Type u_1} (P : α → Prop) : Type u_1
{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] (g : G) : continuous (λ (h : G), g + h + -g)
(C : Type u) [category_theory.category C] : Prop
(α : Type u_1) [comm_semiring α] : Type u_1
(X : Type u_1) [fintype X] : Fintype
{α : Type u_1} {γ : α → Type u_3} [encodable α] [Π (a : α), encodable (γ a)] (n : ℕ) : option (sigma γ)
{α : Type u_1} {M : Type u_5} [comm_monoid M] (s : set α) : finprod (λ (i : α), finprod (λ (H : i ∈ s), 1)) = 1
{M : Type u_1} [add_monoid M] {x : M} : 0 ∈ multiples x
{α : Type u_1} [semigroup α] (x y : α) : has_mul.mul x ∘ has_mul.mul y = has_mul.mul (x * y)
{X : Type u_1} [topological_space X] : compact_space (alexandroff X)
{𝕜 : Type u_1} {F : Type u_3} [is_R_or_C 𝕜] [add_comm_group F] [module 𝕜 F] (c : inner_product_space.core 𝕜 F) : inner_product_space 𝕜 F
{G₀ : Type u_2} [group_with_zero G₀] (a : G₀) : a / (a / a) = a
{X : Type u_1} [topological_space X] {x y : X} {F : set X} (h : joined_in F x y) : path x y
 : Type (u+1)
{α : Type u} {β : α → Type v} (s₁ s₂ : finmap β) : Prop
(X : Type u_2) [topological_space X] : Type u_2
{G : Type u_1} [add_group G] (s : set G) : set G
{α : Type u} (t : ordnode α) : ordnode (ordnode α)
{α : Sort u_1} {β : Sort u_2} [nonempty β] (f : α → β) : β
(α : Type u_1) : Type u_1
{M : Type u_1} [add_monoid M] (P : add_submonoid M) : Prop
{α : Type u} {β : Type v} [topological_space α] [topological_space β] {f : α → β} (hf : closed_embedding f) : filter.tendsto f (filter.cocompact α) (filter.cocompact β)
{α : Type u_1} (G : simple_graph α) (n : ℕ) (s : finset α) : Prop
 : Type
{α : Type u} {β : α → Type v} [decidable_eq α] (m : hash_map α β) (a : α) : option (β a)
{α : Type u} [topological_space α] (s : set α) : Prop
 : category_theory.monad Meas
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (f : module.End R M) : Prop
{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → option α
{R : Type u} [semiring R] : R → polynomial R → R
{α : Type u} {β : Type w} {m : Type w → Type u_1} [monad m] (b : buffer α) (f : α → m β) : m (buffer β)
(α : Type u_1) (r : α → α → Prop) [is_preorder α r] : Type u_1
{A : Type u_3} [add_group A] (s : set A) : A → Prop
(α : Type u_3) [lattice α] : lattice_hom α α
{α : Type u_1} [linear_ordered_field α] {β : Type u_2} [ring β] (abv : β → α) (f : ℕ → β) : Prop
{F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) : ∃ (a : F), ¬is_square a
{α : Type u_1} {o p : part α} (H : ∀ (a : α), a ∈ o ↔ a ∈ p) : o = p
{m : Type v → Type w} [monad m] {α : Type u_1} {β : Type v} (f : ℕ → β → α → m β) (b : β) (as : list α) : m β
{G : Type u_1} [div_inv_monoid G] [measurable_space G] [has_measurable_mul G] (g : G) : measurable (λ (h : G), h / g)
{α : Type u_1} [linear_ordered_ring α] [floor_ring α] : α → ℤ
(R : Type u) (M : Type v) : Type (max u v)
{α : Type u_1} [boolean_ring α] : has_inf α
 : Type
(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] [fintype l] : lie_subalgebra R (matrix (l ⊕ l) (l ⊕ l) R)
(M : Type u_1) [has_add M] : galois_insertion add_con_gen coe_fn
{α : Type u} [pseudo_emetric_space α] : emetric.diam ∅ = 0
{α : Type u_1} [encodable α] : encodable (list α)
 : matrix.special_linear_group (fin 2) ℤ
{α : Type u_2} {β : Type u_3} {γ : Type u_4} [has_bot α] [has_bot β] [has_bot γ] (f : bot_hom β γ) (g : bot_hom α β) : bot_hom α γ
(R : Type u_1) [comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] : Type (max u_1 u_2)
{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} : function.injective coe_fn
(R : Type u) {A : Type v} [comm_semiring R] [ring A] [algebra R A] (a : A) : set R
{α : Type u} (a : α) (n : ℕ) : arity α n
{α : Type u} [has_add α] : is_add_hom id
(p : ℕ → Prop) [decidable_pred p] (n : ℕ) : fintype {i // i < n ∧ p i}
 : ℕ → pSet
 : Type
(p : ℕ) [hp : fact (nat.prime p)] {k : Type u_1} [comm_ring k] [char_p k p] (n : ℕ) (a₁ a₂ : witt_vector p k) (bs : fin (n + 1) → k) : polynomial k
(F : Type u_1) (K : Type u_2) [field F] [field K] [algebra F K] [finite_dimensional F K] [char_zero F] : is_separable F K
(F : pfunctor) : Type u
 : name → name
(K : Type u_1) (V : Type u_2) [field K] [add_comm_group V] [module K V] : Type u_2
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.sheaf C X) : category_theory.limits.is_terminal (F.val.obj (opposite.op ∅))
(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [topological_space α] [topological_space β] : Type (max u_6 u_7 u_8)
{α : Type u_1} {β : Type u_2} : list α → list β → list (option α × β)
(R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] {p : ℕ} [hp : char_p R p] (p_ne_zero : p ≠ 0) : nat.prime p
{α : Type u_1} (a : α) [decidable_pred (λ (_x : α), _x = a)] (h : fintype {b // b ≠ a}) : fintype α
(C : Type u) [category_theory.category C] : Prop
{G : Type u_1} [group G] (H : subgroup G) {x y : G} : x ∈ H → y ∈ H → x * y ∈ H
{α : Type u} (s : set α) : Prop
{α : Type u} (n : ℕ) (s : stream α) : stream α
(x : onote) : onote → onote
{α : Type u} {β : α → Type v} [decidable_eq α] (m : hash_map α β) (a : α) : hash_map α β
{α : Type u_1} (f : α → α) : ℕ → list α → list α
{α : Type u} [decidable_eq α] [mul_zero_one_class α] [nontrivial α] : mul_zero_one_class (with_top α)
{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] : semiring (submodule R A)
(𝕜 : Type u_1) (E : Type u_2) [ordered_semiring 𝕜] [ordered_add_comm_group E] [module 𝕜 E] [ordered_smul 𝕜 E] : convex_cone 𝕜 E
{α : Type u} {β : Type u_1} (f : α → β) : ordnode α → ordnode β
{ι : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [has_mul R] [has_add ι] (A : ι → S) : Prop
(α : Type u) [measurable_space α] : Meas
{α : Type u_1} [semigroup α] {a b c : α} : a ∣ b → b ∣ c → a ∣ c
 : subsingleton (fin 1)
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) (hf : continuous f) (K : topological_space.compacts α) : topological_space.compacts β
(X : CpltSepUniformSpace) : UniformSpace
{α : Type u} (s : seq α) : option (seq1 α)
{ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] {i j : ι} (w : free_product.neword M i j) : list (Σ (i : ι), M i)
(α : Type u_1) : Type u_1
{R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] (N : submodule R M) : ideal R
{R : Type u} [ring R] : ¬is_field (polynomial R)
{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] : has_one (submodule R A)
(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : Type (max u_4 u_5)
{α : Type u} [add_monoid α] (u : add_units α) : α
{α : Type uu} (r : α → α → Prop) [decidable_rel r] [is_total α r] [is_trans α r] (l : list α) : list.sorted r (list.insertion_sort r l)
{α : Type u_1} (p : α → Prop) [decidable_pred p] (l : list α) (hp : ∃ (a : α), a ∈ l ∧ p a) : {a // a ∈ l ∧ p a}
{β : ℕ → Type u_1} : inhabited (hash_map ℕ β)
(J : Type u₁) [category_theory.category J] {C : Type u₂} [category_theory.category C] [nonempty J] : category_theory.faithful (category_theory.functor.const J)
{G : Type u_1} [group G] (K : subgroup G) (s : set G) (hs : s = ↑K) : subgroup G
{α : Type u_1} [cancel_comm_monoid_with_zero α] [decidable_eq α] (h : ∀ (a b : α), ∃ (c : α), ∀ (d : α), d ∣ a ∧ d ∣ b ↔ d ∣ c) : gcd_monoid α
{α : Type u_1} [comm_semiring α] (E : linear_recurrence α) : submodule α (ℕ → α)
{M : Type w} (A : set M) (L : first_order.language) [L.Structure M] (s : set (M × M)) : Prop
(u : pnat.xgcd_type) : Prop
(α : Type u) [uniform_space α] : filter (α × α)
{α : Type u} {β : Type v} (f : α → β) (g : β → α) : set.inv_on f g (function.fixed_points (f ∘ g)) (function.fixed_points (g ∘ f))
{α : Type u_1} {β : Type u_2} [has_le β] [has_add β] [has_one β] (s : set α) (f : α → β) : Prop
{a b c : ℤ} (h : a % b = c) : b ∣ a - c
{R : Type u} [comm_ring R] (S : submonoid R) {L : Type u} [comm_ring L] [algebra R L] [is_localization S L] : cardinal.mk L ≤ cardinal.mk R
{α : Type u} {β : Type v} [add_zero_class α] [add_zero_class β] (f : α → β) : Prop
{c c' : Σ (n : ℕ), composition n} : c = c' ↔ c.snd.blocks = c'.snd.blocks
{α : Type u_1} {ι : Type u_3} {m : measurable_space α} [preorder ι] (f : measure_theory.filtration ι m) (τ : α → ι) : Prop
{α : Type u_1} [semiring α] {m n : ℕ} (h : m ∣ n) : ↑m ∣ ↑n
{α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u : α) (s : finset α) : uv.is_compressed u u s
{M : Type u_1} [add_zero_class M] (S : add_submonoid M) {x y : M} : x ∈ S → y ∈ S → x + y ∈ S
 : znum → znum → znum
{C : Type u} [category_theory.category C] (i p : category_theory.arrow C) : Prop
(V : Type u) [quiver V] (H : wide_subquiver V) : Type u
{α : Type u_1} {β : Type u_2} [add_comm_monoid α] [topological_space α] (f : β → α) (a : α) : Prop
{A : Type u_1} [add_monoid A] : distrib_mul_action (add_aut A) A
(K : Type u_1) (V : Type u_2) [division_ring K] [add_comm_group V] [module K V] : Prop
(α : Sort u_1) (β : Sort u_2) : Sort (max 1 (imax u_2 u_1) u_1)
{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : R
{α : Type u} [pseudo_metric_space α] {s t : set α} (incl : s ⊆ t) : metric.bounded t → metric.bounded s
{α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] (l : filter α) (f : α → E) (g : α → F) : Prop
{α : Type u'} {β : Type v'} {n : ℕ} (g : α → β ⊕ fin n) (k : ℕ) : α ⊕ fin k → β ⊕ fin (n + k)
{G : Type u} [add_group G] {x : G} (hx : is_of_fin_add_order x) : is_of_fin_add_order (-x)
(α : Type u) : Type u
{α : Type u_1} [metric_space α] {β : Type u} [nonempty β] (p : besicovitch.tau_package β α) : ordinal → ℕ
{α : Type u} (l : thunk (list α)) : dlist α
{M : Type u_1} [comm_monoid M] (S : submonoid M) (m : multiset M) (hm : ∀ (a : M), a ∈ m → a ∈ S) : m.prod ∈ S
 : Type
(J : Type v) : Type v
{R : Type u} [semiring R] (p : polynomial R) : Prop
{α : Type u} [canonically_ordered_add_monoid α] : canonically_ordered_add_monoid (with_zero α)
(b : bool) : ℕ
 : Type
(α : Type u_1) : basis α ℤ (free_abelian_group α)
{α : Type u} [group α] : group_with_zero (with_zero α)
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)
{α : Type u} {β : Type v} : α ⊕ β → bool
{α : Type u_1} [has_add α] (a : α) (s : set α) : set α
(p : ℕ) [hp : fact (nat.prime p)] : prime ↑p ↔ p % 4 = 3
{α : Type} (rels : set (free_group α)) : Type
(α : Type u) (r : α → α → Prop) : Prop
(C : Type u) [category_theory.category C] (n : ℕ) : Type (max v u)
 : Type (u_1+1)
(R : Type u_1) [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : is_unit ↑p ↔ ¬p ∣ ring_char R
{α : Type u} [topological_space α] {γ : Type u} [topological_space γ] [t2_space γ] [compact_space γ] {f : α → γ} (hf : continuous f) : stone_cech α → γ
{α : Type u} [topological_space α] {s : set α} : dense (closure s) → dense s
{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A B : matrix n n α) (h : A.mul B = 1) : invertible A
(G : Type u_1) (P : Type u_2) : Type (max u_1 u_2)
{α : Type u_1} : bool × α → option α
{C : Type u₁} [category_theory.category C] (Z : C → Prop) : category_theory.category {X // Z X}
{α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → option β → γ) : list α → list β → list γ
{R : Type u} [ring R] (s : subring R) : submonoid R
{α : Type u_1} {β : Type u_2} (x : option α) : (Π (a : α), a ∈ x → option β) → option β
{X : Type u_1} [topological_space X] {α : Type u_2} {β : Type u_3} (f : X → α) (g : α → β) (h : is_locally_constant (g ∘ f)) (inj : function.injective g) : is_locally_constant f
{α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), f x ≤ c) : supr f ≤ c
{α : Type u} (s : stream α) : seq α
{α : Type u_1} (k : ℕ) : (vector3 α k → Prop) → Prop
(w₁ w₂ p₁ p₂ : nnreal) : w₁ + w₂ = 1 → p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂
(p : nat.primes) : prime_multiset
{a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd b = 1) : a ∣ c
 : real.sin (real.pi / 3) ^ 2 = 3 / 4
{V : Type u} : has_sup (simple_graph V)
{R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R ≠ 2) : set.inj_on coe {0, 1, -1}
{α : Type u} {β : Type v} (f : α → β) (s : set β) : set α
{α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] : filter.tendsto (λ (r : α), r⁻¹) filter.at_top (nhds_within 0 (set.Ioi 0))
 : is_cyclic (quaternion_group 1)
{α : Type u_1} [preorder α] (a b : α) : set α
{C : Type u} [category_theory.category C] [category_theory.abelian C] : category_theory.non_preadditive_abelian C
{n m : ℕ} (F : typevec n → Type u_1) (G : fin2 n → typevec m → Type u) (v : typevec m) : Type u_1
{ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] {i j : ι} (w : free_product.neword M i j) : free_product.word M
{C : Type u} [category_theory.category C] (G : C) : Prop
(α : Type u) [measurable_space α] (β : Type v) : Type (max u v)
{R : Type u} [euclidean_domain R] [decidable_eq R] (x y : R) : R
 : Type (max (u+1) u (v+1))
{α : Type u} {β : α → Type v} (f : Π (x : α), β x → bool) (s : finmap β) : bool
(R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : ℕ) [hq : exp_char R q] : nat.prime q ∨ q = 1
{S : Type u_1} [semigroup S] {a b c : S} (hac : commute a c) (hbc : commute b c) : commute (a * b) c
{α : Type u_1} (l : list α) (n : ℕ) : list α
{α : Type u_1} {β : Type u_2} [measurable_space α] (f : measure_theory.simple_func α β) : finset β
(α : Type u) {g : Type} [random_gen g] [random α] : rand_g g α
{R : Type u_1} [semiring R] (f : polynomial R) : polynomial R
{M : Type u_1} [mul_one_class M] (S : submonoid M) (s : set M) (hs : s = ↑S) : submonoid M
{B : Type u_1} (E : B → Type u_2) : Type (max u_1 u_2)
{α : Type u} [preorder α] (c : omega_complete_partial_order.chain α) (x : α) : Prop
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} (f : γ → δ) (g : α → β → γ) (a : α) (b : β) : δ
{X : Type u_1} [topological_space X] (s : set X) : Prop
(p : ℕ) : ℕ → zmod (2 ^ p - 1)
{α : Type u_1} : has_one (language α)
{α : Type u} {β : Type v} [nonempty α] (f : α → β) (s : set α) (b : β) : α
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 ≤ b) : 0 < a + b
{α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} [contravariant_class α α has_add.add has_le.le] (h : a ≤ b) : b - (b - a) = a
{P : Type u_2} [metric_space P] {ps₁ ps₂ : set P} (hs : ps₁ ⊆ ps₂) (hc : euclidean_geometry.cospherical ps₂) : euclidean_geometry.cospherical ps₁
{α : Type u_1} {β : Type u_2} (f : α → β) (gp : generalized_continued_fraction.pair α) : generalized_continued_fraction.pair β
(α : Type u) (β : Type v) [topological_space α] [topological_space β] : Type (max u v)
{α : Type u} {β : Type v} (f : α → option β) : wseq α → wseq β
{α : Type u_1} [measurable_space α] (m : measure_theory.outer_measure α) : measure_theory.outer_measure α
{a b : ennreal} (h : a < b) : add_le_cancellable a
{α : Type u_1} [cancel_comm_monoid_with_zero α] [decidable_eq α] [unique_factorization_monoid α] (a : α) : multiset α
{α : Sort u_1} (r : α → α → Prop) : function.surjective (quot.mk r)
(α : Type u_1) [has_lt α] : has_sbtw α
(R : Type u_1) [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) : galois_coinsertion (λ (z : ℤ), ⟨↑b ^ z, _⟩) (λ (r : ↥(set.Ioi 0)), int.log b ↑r)
{α : Type u} [group α] (a : α) : invertible a
(X T : Top) : Top.presheaf (Type v) X
 : Type
{G : Type u_2} [add_group G] : has_neg (add_submonoid G)
(R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] : Type (max u_4 u_5)
(a₀ a₁ a₂ : Type u) : ℕ → Type u
{n : ℕ} : bitvec n → bitvec n → bitvec n
(R : Type u) [comm_ring R] : Top
{γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), x * y)
{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) [no_min_order α] : closure (set.Iio a) = set.Iic a
{V : Type u} (x y : simple_graph V) : Prop
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a ≤ 0) (hb : b < 0) : a + b < 0
{α : Type u} [topological_space α] {s : set α} : is_clopen s → frontier s = ∅
{n : ℕ} (α : typevec n) (β : Type u_1) : typevec (n + 1)
{α : Type u} (i : ℕ) (t : ordnode α) : ordnode α
{R : Type u_1} [comm_ring R] [is_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] : is_integrally_closed R ↔ is_integral_closure R R K
(C : Type u) [category_theory.category C] : Type (max u v)
{S : Type u_2} [comm_ring S] {A : Type u_4} [comm_ring A] [algebra A S] (pb : power_basis A S) : polynomial A
(C : Type u₁) [category_theory.category C] : hom_rel (category_theory.paths C)
{R : Type u₁} {L : Type u₂} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : lie_algebra.is_engelian R L
{R : Type v} [comm_ring R] (A : matrix (fin 1) (fin 1) R) : A.det = A 0 0
{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} (f : α → β → γ) : Prop
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] [is_noetherian_ring R] : algebra.finite_type R A ↔ algebra.finite_presentation R A
{α : Type u_1} [topological_space α] [polish_space α] {s : set α} (hs : is_closed s) : polish_space.is_clopenable s
{α : Type u_1} {β : Type u_2} (f : α → β) (s : set α) : set β
{R : Type u_1} [comm_ring R] (k : ℕ) (a : R) : ℕ → polynomial R
(β : Type u_1) (α : Type u_2) : Type (max u_1 u_2)
{G : Type u_1} [group G] (S : subgroup G) : set G
 : strict_mono real.sinh
{α : Type u} {β : Type u_1} (f : β → α) [decidable_eq α] [fin_enum β] (h : function.surjective f) : fin_enum α
{m : Type u_2} {n : Type u_3} {α : Type u_5} [decidable_eq m] [decidable_eq n] [semiring α] (i : m) (j : n) (a : α) : matrix m n α
{α : Type u_1} [preorder α] (s : ordset α) : Prop
{G : Type u_1} [add_group G] (S : add_subgroup G) : set G
(C : Type u) [category_theory.category C] : Type (max v u)
(α : Type u) : Type u
(G : Type u) [group G] : Type (u+1)
(R : Type u_1) (M : Type u_3) [has_zero R] [has_zero M] : Type (max u_1 u_3)
{α : Type u_1} {β : Type u_2} (f : α → list α → β) : list α → list β
(α : Type u_5) : Type u_5
(α : Type u_1) : Type u_1
{α : Type u_1} [circular_preorder α] (a b : α) : set α
{α : Sort u_1} : erased α → α
 : snum → snum
(a : pos_num) : pos_num → pos_num
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (λ (_x : G), _x +ᵥ p)
{α : Type u} [decidable_eq α] (i j : α) : function.involutive (has_mul.mul (equiv.swap i j))
{α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.red L (free_group.reduce L)
{α : Type u_2} {β : Type u_3} [preorder α] [preorder β] [bounded_order α] [bounded_order β] (f : bounded_order_hom α β) : top_hom α β
{n : Type u} [decidable_eq n] [fintype n] (β : Type v) [comm_ring β] : submonoid (matrix n n β)
{α : Type u_1} {m m' : metric_space α} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist) : m = m'
{α : Type u} (L : list (α × bool)) : free_group α
(C : Type u₁) [category_theory.category C] : Type u₁
(α : Type u_1) [topological_space α] [preorder α] : Prop
{n : ℕ} (a : fin (n + 1)) : ↑↑a = a
{α : Type u_1} {r : α → α → Prop} (h : reflexive r) {x y : α} (hr : x ≠ y → r x y) : r x y
{R : Type u} [ring R] (s : subring R) {x y : R} : x ∈ s → y ∈ s → x * y ∈ s
{α : Sort u_1} (p : α → α → Prop) : decidable_rel p
(p n : ℕ) (R : Type u_1) : Type u_1
(H : Type u_1) [topological_space H] : structure_groupoid H
{E : ℕ → Type u_1} (x y : Π (n : ℕ), E n) : ℕ
(X : Type u_3) [topological_space X] : Prop
(α : Type u_1) (β : Type u_2) [order.frame α] [order.frame β] : Type (max u_1 u_2)
(α : Type u) [has_lt α] : Prop
{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → ordnode α
(α : Type u_1) : Type u_1
{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order α] [semilattice_inf β] (gi : galois_coinsertion l u) : semilattice_inf α
(n : ℕ) : zmod n → zmod n
{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] (B : bilin_form R M) : quadratic_form R M
{α : Type u_1} {β : Type u_2} [decidable_eq β] (s : finset α) (t : α → finset β) : finset β
{α : Type u_2} [decidable_eq α] [has_div α] : has_div (finset α)
(n k : ℕ) : Prop
 : Type (u+1)
{G : Type u_1} [group G] (H : subgroup G) {x y : G} (hx : x ∈ H) (hy : y ∈ H) : x / y ∈ H
{M : Type u_1} [has_zero M] [has_add M] [has_neg M] : ℤ → M → M
 : irrational golden_ratio
{α : Type u_1} {β : Type u_2} [linear_order β] (f : α → β) (inj : function.injective f) : linear_order α
(R : Type u) : Type (u+1)
{M : Type u_1} [monoid M] {x y z : M} : y ∈ powers x → z ∈ powers x → y * z ∈ powers x
(n : ℕ) : arity Set n → Type (u+1)
{R : Type u} {A : Type v} [comm_semiring R] [ring A] [algebra R A] {r : R} {a : A} : r ∈ resolvent_set R a ↔ is_unit (resolvent a r)
{α : Type u} [preorder α] {a b c : α} (hab : a = b) (hbc : b < c) : a < c
(a b : nnreal) {p q : nnreal} (hp : 1 < p) (hpq : 1 / p + 1 / q = 1) : a * b ≤ a ^ ↑p / p + b ^ ↑q / q
(C : Type u) [category_theory.category C] : Type (max (max v u) u v)
 : pos_num → ℕ
(p : ℕ) [hp : fact (nat.prime p)] (n : ℕ) : ℕ → mv_polynomial (fin 1 × ℕ) ℤ
(α : Type u_1) : Type u_1
(L : list ℕ) (h : ∀ (i : ℕ), i ∈ L → 1 ≤ i) : L.length ≤ L.sum
{R : Type u} [ring R] (s : subring R) {l : list R} : (∀ (x : R), x ∈ l → x ∈ s) → l.sum ∈ s
(n : ℕ) : multiset ℕ
(α : Type u) : Type u
{V : Type u} (G : simple_graph V) : Type u
{α : Type u_1} [decidable_eq α] [partial_order α] [bounded_order α] [is_simple_order α] : lattice α
(X : Type u) [uniform_space X] [complete_space X] [separated_space X] : CpltSepUniformSpace
{α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) : Prop
(α : Type u_6) (β : Type u_7) [preorder α] [preorder β] [mul_zero_one_class α] [mul_zero_one_class β] : Type (max u_6 u_7)
{α : Type u_1} [preorder α] [locally_finite_order α] (a b : α) : multiset α
{α : Type u_1} (s : finset α) : Prop
(α : Type u_1) [encodable α] : decidable_eq α
{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} : a ≤ b⁻¹ → b ≤ a⁻¹
{α : Type u} (p : α → Prop) (s : stream α) : Prop
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (N : submodule R M) : Prop
(C : Type u₁) [category_theory.category C] : Type u₁
{R : Type u_1} {ι : Type u_2} {M : Type u_3} [ring R] [add_comm_group M] [module R M] [fintype ι] [is_noetherian R M] : is_noetherian R (ι → M)
{n : ℕ} (f : equiv.perm (fin n)) (a : Σ (a : fin n), fin n) : Σ (a : fin n), fin n
{α : Type u_2} [comm_monoid α] : comm_monoid (filter α)
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {n : ℕ} (f : α → β → γ) : vector α n → vector β n → vector γ n
 : Type (u_1+1)
{R : Type u} [non_assoc_semiring R] (s : subsemiring R) : 0 ∈ s
{m : Type → Type v} [monad m] {α : Type u_1} {β : Type} (f : α → m (option β)) : list α → m (list β)
{α : Type u} (s : stream (option α)) : Prop
(G₀ : Type u_1) [measurable_space G₀] [has_div G₀] : Prop
{α : Type u_1} (p : α → Prop) [decidable_pred p] : list α → option α × list α
{α : Type u_1} {β : Type u_2} [add_group α] [add_comm_group β] {f : α → β} (hf : is_add_group_hom f) : is_add_group_hom (λ (a : α), -f a)
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b
(α : Type u_2) [complete_lattice α] : Prop
(p : ℕ) [fact (nat.prime p)] {a : ℤ} : zmod.legendre_sym p a = -1 ↔ ¬is_square ↑a
{α : Type u_1} (m : set (measure_theory.outer_measure α)) (s : set α) : ennreal
{α : Type u_1} [encodable α] (a : α) : ulower α
{α : Type u_1} {β : Type u_2} (m₁ : measurable_space α) (m₂ : measurable_space β) : measurable_space (α × β)
(X : Type u_4) [topological_space X] : Prop
(α : Type u) : Type u
{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) [invertible A] : invertible A.det
{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_btw.btw a b c) : ¬has_sbtw.sbtw c b a
{α : Type u_1} [decidable_eq α] [fintype α] : fintype (equiv.perm α)
{α : Type u_1} {β : Type u_2} (f : α → β) (g : poly α) : poly β
{α : Type u_1} [topological_space α] (s : set α) (hs : is_open s) : local_homeomorph α α
{α : Type u_1} [emetric_space α] (K : nnreal) (f : α → α) : Prop
(p : ℕ) [hp : fact (nat.prime p)] : ℕ → ℕ → mv_polynomial ℕ ℤ
{F : Type u → Type u} [functor F] (q : qpf F) : Prop
{α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β] : continuous coe_fn
{a : Prop} (b : Prop) (h : a ↔ b) [D : decidable b] : decidable a
{R : Type u} [ring R] (h : is_field R) : field R
{α : Type u_1} [has_mul α] (s : set α) (a b : α) : Prop
 : Type
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_colimits C] : category_theory.limits.has_finite_wide_pushouts C
{n : ℕ} (p : fin n → Prop) [decidable_pred p] {i : fin n} (hi : i ∈ fin.find p) : p i
(x y : pgame) : Prop × Prop
(ι : Type u_1) {R : Type u_2} [add_monoid ι] [monoid R] : graded_monoid.gmonoid (λ (i : ι), R)
{n : ℕ} (P : mvpfunctor (n + 1)) : mvpfunctor n
 : pos_num → pos_num
{R : Type u_1} {S : Type u_3} [non_unital_non_assoc_semiring R] [non_unital_non_assoc_semiring S] : non_unital_non_assoc_semiring (R × S)
{α : Type u} [decidable_eq α] [mul_zero_one_class α] [nontrivial α] : mul_zero_one_class (with_bot α)
(F : Type u_7) (α : out_param (Type u_8)) (β : out_param (Type u_9)) [has_sup α] [has_sup β] : Type (max u_7 u_8 u_9)
{α : Type u_1} (R : α → α → Prop) : list α → Prop
{F : pfunctor} (R : F.M → F.M → Prop) : Prop
{α : Type u} [is_empty α] : unique (list α)
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (A : set X) (f : X → Y) : X → Y
{α : Type u} (f : thunk α) : α
{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order β] [complete_lattice α] (gi : galois_insertion l u) : complete_lattice β
{α : Type u} {β : Type v} (f : α → β) (s : set α) (t : set β) : Prop
{p : ℕ} {α : Type u_4} {β : Type u_5} (f : α → β) : witt_vector p α → witt_vector p β
{α : Type u} [ring α] : is_ring_hom id
(G : Type u_1) [topological_space G] [group G] [topological_group G] : subgroup G
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) : 1 ∈ S
{α : Type u_1} [add_monoid α] (s t : set α) (a : α) : set (α × α)
{R : Type u} [ring R] (p q : polynomial R) : polynomial R
{G : Type u_1} [group G] (H : ℕ → subgroup G) : Prop
{α : Type u_1} [decidable_eq α] (l : list α) (H : ∀ (x : α), x ∈ l) : encodable α
(R : Type u_1) [monoid R] [star_semigroup R] : submonoid R
{M : Type u_1} [has_add M] (S : add_subsemigroup M) {x y : M} : x ∈ S → y ∈ S → x + y ∈ S
{R : Type u} {n : Type w} [comm_ring R] [decidable_eq n] [fintype n] (J : matrix n n R) : lie_subalgebra R (matrix n n R)
(α : Type u_2) [preorder α] : pseudo_epimorphism α α
{α : Type u_1} (y : α) : fintype {x // x = y}
 : name → name
{α : Type u_1} : multiset α
(M : Type u_1) [has_mul M] : set M
{α : Sort u} {β : Sort v} {γ : Sort w} {g : β → γ} (hg : function.bijective g) : function.bijective (function.comp g)
{ι : Type u_1} (f : ι → cardinal) : cardinal
{α : Type u_2} [monoid α] : monoid (set α)
 : succ_order cardinal
 : Type (u_1+1)
{α : Type u_1} (r : α → α → Prop) (s : set α) : Prop
{ι : Type u_1} {M : Type u_4} [topological_space M] [has_mul M] [has_continuous_mul M] : has_continuous_mul (ι → M)
{α : Type u_1} {β : α → Type u_2} : W_type β → (Σ (a : α), β a → W_type β)
(α : Type u_1) [metric_space α] : Prop
{α : Type u_1} [preorder α] (a b : α) : set α
(b : ℤ) : b ≤ b ^ 2
{α : Type} (p : parser α) : Prop
{C : Type u} [category_theory.category C] [category_theory.limits.coproducts_disjoint C] : category_theory.limits.initial_mono_class C
{α : Type u} (x : α) : dlist α → dlist α
(n : ℕ) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 < x) : 0 < polynomial.eval x (polynomial.cyclotomic n R)
(C : Type u) [category_theory.category C] : category_theory.category (algebraic_geometry.PresheafedSpace C)
(α : Sort u) : Type
{α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b c : α} [contravariant_class α α has_add.add has_le.le] (h : a + c < b) : a < b - c
{α : Type u_1} {β : Type u_2} [primcodable α] [primcodable β] (f : α → β) : Prop
{ι : Type u_1} {f : ι → Type u_2} [Π (i : ι), has_mul (f i)] (C : Π (i : ι), con (f i)) : con (Π (i : ι), f i)
(α : Type u) : Type u
(K : Type u) : Type u
(M : Type u_1) [monoid M] : submonoid M
{R : Type u} [semiring R] (p : polynomial R) : R
{M : Type u_1} [monoid M] (s : set M) : Prop
{m : Type u → Type u_1} [monad m] {α β : Type u} (f : α → α → m β) : list α → m (list β)
{M : Type u_1} [monoid M] {s t : set M} (h : s ⊆ t) : monoid.closure s ⊆ monoid.closure t
(α : Type u₁) : category_theory.small_category (category_theory.discrete α)
(α : Type u_6) : Type u_6
{α : Type u_1} : list α → Prop
{X : Type u_1} [topological_space X] (x y : X) : Prop
(M : Type u_9) (N : Type u_10) [add_zero_class M] [add_zero_class N] : Type (max u_10 u_9)
(M : Type u_1) [has_add M] : set M
{α : Type u_1} {β : Type u_2} (f : α → β) (m : measurable_space β) : measurable_space α
{α : Type u_1} {ι : Sort u_4} (p : ι → Prop) (s : ι → set α) : Prop
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (X : C) : Type u
(α : Type) [has_zero α] [has_one α] [has_add α] [fintype α] : parser α
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_cokernels C] : category_theory.limits.has_coequalizers C
{α : Type u_1} : has_zero (language α)
{α : Type u} : seq α
(C : Type u) [category_theory.category C] : Type (max v u)
 : Type
{X : Type u} [topological_space X] {x₀ x₁ : X} (p₀ p₁ : path x₀ x₁) : Prop
(α : Type u_1) [omega_complete_partial_order α] : ωCPO
(k : ℕ) : ℕ → list (fin k → ℕ)
{α : Type u_2} [decidable_eq α] [has_inv α] : has_inv (finset α)
(b : bool) : num → num
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] : category_theory.monoidal_category (category_theory.skeleton C)
(R : Type u_1) [has_zero R] : Type u_1
{α : Type u_1} [decidable_eq α] (s : finset α) (F : finset (finset α)) : finpartition s
 : set surreal
{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A B : matrix n n α) (h : B.mul A = 1) : invertible A
(n : ℕ) : Type (u+1)
(G : Type u_2) : Type u_2
{α : Type u_1} [fintype α] : nonempty (field α) ↔ is_prime_pow (fintype.card α)
{n : ℕ} [fact (0 < n)] : fintype (dihedral_group n)
(m : Type u → Type v) : Type (u+1)
{γ : Type w} [preorder γ] [order_top γ] (s : set γ) : bdd_above s
{M : Type u_1} [mul_one_class M] : complete_lattice (submonoid M)
{ι : Type u_1} {α : Type u_2} (s : ι → set α) : Type (max u_1 u_2)
{α : Type u} [pseudo_emetric_space α] {s t : set α} : emetric.Hausdorff_edist s t = emetric.Hausdorff_edist t s
(o : ordinal) : cardinal
{α : Type u} {β : Type v} (r : rel α β) (f : filter β) : filter α
{R : Type u} [comm_ring R] (f : polynomial R) : adjoin_root f
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {F : J → C} (B : category_theory.limits.bicone F) : category_theory.limits.cocone (category_theory.discrete.functor F)
{R : Type u} [comm_semiring R] [star_ring R] : ring_aut R
{α : Type u_1} {β : Type u_2} (r : rel α β) (s : set β) : set α
 : Type (u_1+1)
(M : Type u_1) {α : Type u_2} [group M] [mul_action M α] (s : set α) : subgroup M
(a c b d : ℕ) : Prop
{α : Type u} {β : α → Type v} {δ : Type w} (f : δ → Π (a : α), β a → δ) (d : δ) (m : alist β) : δ
(α : Type u_1) : Type u_1
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b
(α : Type u_1) [subsingleton α] : fintype α
{n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (z : α (fin.last n)) : fin.init (function.update q (fin.last n) z) = fin.init q
{α : Type u} [decidable_eq α] (a : α) (as : list α) : list (list α)
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] (f : measure_theory.simple_func α (β → γ)) (g : measure_theory.simple_func α β) : measure_theory.simple_func α γ
{G : Type u_1} [group G] {H K : subgroup G} (h : ∀ (x : G), x ∈ H ↔ x ∈ K) : H = K
(G : out_param (Type u_1)) (P : Type u_2) [out_param (add_group G)] : Type (max u_1 u_2)
 : pgame
{α : Type u} [preorder α] {a b : α} (h : a < b) : a ≠ b
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1
{α : Type u_1} (r : α → α → Prop) (f : filter α) : Prop
{α : Type u} (l : ordnode α) : ordnode α → ordnode α
(M : Type u_9) (N : Type u_10) [has_add M] [has_add N] : Type (max u_10 u_9)
(C : Type u₁) [category_theory.category C] : Prop
(M : Type u_1) [has_add M] : Type u_1
 : Type (u+1)
 : Type (u_1+1)
(R : Type u) (X : Type v) [comm_ring R] : basis (free_monoid X) R (free_algebra R X)
(α : Type u) [topological_space α] : Prop
(α : Type u_1) (β : Type u_2) : Type (max u_1 u_2)
{α : Type u_1} [uniform_space α] {β : Type u_2} [uniform_space β] (f : α → β) : uniform_space.completion α → β
 : Type
 : Type
(d : ℤ) : Type
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E : intermediate_field K L) : E.map (alg_hom.id K L) = E
{ι : Type u} (f : ι → cardinal) : bdd_above (set.range f)
{α : Type u_1} {β : Type u_2} {ι : Type u_3} (u : ι → α → β) (τ : α → ι) : α → β
{α : Type u_1} {m : Type u_4} {n : Type u_5} [has_mul α] (A B : matrix m n α) : matrix m n α
{α : Type u_1} (f : α → α) : set α
{α : Type u} : ordnode α → option α
(R : Type u_1) [comm_ring R] : Type u_1
{α : Type u} {β : Sort u_1} (f : α → β → β) : ordnode α → β → β
{α : Type v} {d u n : ℕ} (A : matrix (fin (u + d)) (fin n) α) : matrix (fin d) (fin n) α
{S : Type u} [has_add S] {a x y : S} (h : add_semiconj_by a x y) : a + x = y + a
{R : Type u} {Γ₀ : Type v} [comm_ring R] [linear_ordered_comm_group_with_zero Γ₀] (v : valuation R Γ₀) (O : Type w) [comm_ring O] [algebra O R] : Prop
{L : first_order.language} (K : set (category_theory.bundled L.Structure)) : Prop
{α : Type u} {u : ultrafilter (ultrafilter α)} {x : ultrafilter α} : ↑u ≤ nhds x ↔ x = mjoin u
(c : nat.partrec.code) (n : ℕ) : nat.partrec.code
{Γ : Type u_4} [group Γ] {T : Type u_5} [topological_space T] [mul_action Γ T] [has_continuous_const_smul Γ T] : is_open_map quotient.mk
{R : Type u} [ring R] (B : ring_filter_basis R) : topological_space R
{α : Type u_1} [encodable α] {n : ℕ} : encodable (fin n → α)
(Γ₀ : Type u_1) [linear_ordered_comm_group_with_zero Γ₀] (x : Γ₀) : filter Γ₀
{x y z : ℤ} (k : ℤ) (hk : k ≠ 0) : pythagorean_triple (k * x) (k * y) (k * z) ↔ pythagorean_triple x y z
(R : Type u) [comm_ring R] : CommRing
(X : Type u_1) [topological_space X] : Type u_1
{ι : Type u_1} {M : Type u_4} [topological_space M] [has_add M] [has_continuous_add M] : has_continuous_add (ι → M)
{α : Type u_1} {β : Type u_2} (e : local_equiv α β) : β → α
{α : Type u_1} [has_le α] (a : α) : Prop
{n a : ℕ} (h : a < n + 1) : ↑a.val = a
(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [preorder α] [preorder β] [mul_one_class α] [mul_one_class β] : Type (max u_6 u_7 u_8)
(α : Type u) : Type (max 1 u)
{α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} (h : x ∈ s) : emetric.inf_edist x t ≤ emetric.Hausdorff_edist s t
{α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) (s : set α) (x : α) : Prop
{α : Type u_1} [metric_space α] {β : Type u} [nonempty β] (p : besicovitch.tau_package β α) : ordinal
{α : Type u_1} (k : ℕ) : (vector3 α k → Prop) → Prop
 : cardinal.ord ∘ cardinal.aleph = ordinal.enum_ord {b : ordinal | b.card.ord = b ∧ ordinal.omega ≤ b}
{α : Type u_1} [fintype (option α)] : fintype α
 : pos_num → pos_num → ordering
{α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] (l : filter α) (f : α → E) (g : α → F) : Prop
(α : Type u_1) (β : Type u_2) [topological_space α] [topological_space β] [add_monoid β] [has_continuous_add β] : add_submonoid (α → β)
{E : ℕ → Type u_1} [Π (n : ℕ), topological_space (E n)] [∀ (n : ℕ), discrete_topology (E n)] : metric_space (Π (n : ℕ), E n)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_coproducts C] : category_theory.limits.has_finite_biproducts C
{R : Type u} [semiring R] (p q : polynomial R) : polynomial R
 : sign_type → sign_type → sign_type
{α : Type u_1} (f : α → nnreal) : filter.tendsto (λ (s : finset α), ∑' (b : {x // x ∉ s}), f ↑b) filter.at_top (nhds 0)
(α : Type u) : Type u
(G : Type u_1) [measurable_space G] [has_sub G] : Prop
{α : Type u_1} {m : multiset α} {p : α → Prop} [decidable_pred p] : decidable (∃ (x : α) (H : x ∈ m), p x)
(p : nnreal) (h : p ≤ 1) : pmf bool
(R : Type u) (M : Type v) [ring R] [add_comm_group M] [module R M] : Type (max u v)
{α : Type u} [right_cancel_monoid α] : has_faithful_smul α α
{n : ℕ} (a : zmod n) : ↑↑a = a
{R : Type u} [non_assoc_semiring R] : has_top (subsemiring R)
{α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : a / c < b / d → (a * d - b * c) / (c * d) < 0
(G : Type u_3) [group G] [h : group.fg G] [decidable_pred (λ (n : ℕ), ∃ (S : finset G), S.card = n ∧ subgroup.closure ↑S = ⊤)] : ℕ
 : has_sub ordinal
(M : Type u_1) [monoid M] [measurable_space M] [has_measurable_mul₂ M] : has_measurable_pow M ℕ
(F : Type u_1) (α : out_param (Type u_2)) (β : out_param (Type u_3)) [has_le α] [has_le β] : Type (max u_1 u_2 u_3)
(K : Type u) (V : Type v) [semiring K] [add_comm_monoid V] [module K V] : cardinal
{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_regular a) : a ≠ 0
(B : Type u_1) (F : Type u_2) : B → Type u_2
{α : Type u_1} (r : α → α → Prop) : initial_seg r r
 : Type (u+1)
 : Type
(R : Type u) [ring R] (hf : is_field R) (x : R) : x ≠ 0 → (∃! (y : R), x * y = 1)
 : ℕ
{α : Type u_1} [encodable α] : encodable (plift α)
{α : Type} (p : parser α) : parser (list α)
{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] (h : G) : continuous (λ (g : G), g + h + -g)
{α : Type u_1} {β : Type u_2} [measurable_space α] [measurable_space β] {f : β → α} (hf : ∀ (x y : β), f x = f y) : measurable f
{α : Type u} (l : list α) : l ≠ list.nil → stream α
{β : Type u_2} (f : equiv.perm β) : Prop
{X : Type u} (m : X → X → X) (e : X) : Prop
(F : Sort u_1) (α : out_param (Sort u_2)) (β : out_param (Sort u_3)) : Sort (max 1 (imax u_1 u_2 u_3))
 : has_zero onote
{α : Type u} {β : Type v} [topological_space α] [topological_space β] : is_open_map prod.fst
(p : ℕ) (R : Type u_1) [comm_ring R] [invertible ↑p] : ℕ → mv_polynomial ℕ R
 : pSet → pSet
{X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s → is_closed s
(Γ : Type u_1) (R : Type u_2) [partial_order Γ] [add_comm_monoid R] (α : Type u_3) : Type (max u_1 u_2 u_3)
(G₀ : Type u_1) [measurable_space G₀] [has_div G₀] : Prop
{R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] (s : subsemiring R) (t : subsemiring S) : subsemiring (R × S)
(o : ordinal) : cardinal
(α : Type u) (β : Type v) : Type (max u v)
{C : Type u₁} [category_theory.category C] (A : C) : Prop
(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) [char_zero k] {n : ℕ} (h : s.card = n + 1) : s.sum (λ (i : ι), finset.centroid_weights k s i) = 1
{α : Type u_1} [decidable_eq α] (x y : α × α) : bool
{α : Type u_3} [linear_ordered_add_comm_group α] : filter.tendsto has_abs.abs filter.at_bot filter.at_top
(α : Type u) {β : Type v} [monoid α] [mul_action α β] (b : β) : set β
{α : Type u_1} (r : setoid α) : α → α → Prop
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] : category_theory.limits.has_equalizers C
(α : Type u_1) (β : Type u_2) [uniform_space β] : topological_space (α → β)
{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : Type u_1
(V : Type u) [quiver V] : Type (max u v)
{R : Type u_1} [cancel_monoid R] (g : R) : is_regular g
{α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] (f : α → β) : Prop
{α : Type u_1} {β : Type u_2} [add_zero_class α] [add_comm_group β] {f : α → β} (hf : is_add_monoid_hom f) : is_add_monoid_hom (λ (a : α), -f a)
 : Type
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {i : α → β} (di : dense_inducing i) [topological_space.separable_space α] : topological_space.separable_space β
(α : Type u_1) [ring α] : Type u_1
(o : nonote) : ordinal
(K : Type u_1) : Type u_1
(K : Type u_1) [division_ring K] [topological_space K] : Prop
{α : Type u_1} {β : Type u_2} (s : finset α) (t : finset β) : finset (α × β)
 : Type (max (u+1) u (v+1))
{H : Type u_1} [topological_space H] (G : structure_groupoid H) (f : H → H) (s : set H) (x : H) : Prop
(R : Type u_1) {V : Type u_2} {P : Type u_4} [ring R] [invertible 2] [add_comm_group V] [module R V] [add_torsor V P] (x y : P) : P
 : num → num → num
(α : Type u_3) : Type u_3
(G : Type u) : Type u
(α : Type u) : Type u
{α : Sort u} {β : α → Sort v} {f₁ f₂ : Π (x : α), β x} (h : ∀ (x : α), f₁ x = f₂ x) : f₁ = f₂
(v : list bool) : ℕ
{A : Type u_1} [semiring A] [algebra ennreal A] : algebra nnreal A
(α : Type u_3) [topological_space α] : Type u_3
(p : ℕ) (a : ℤ) [hp : fact (nat.prime p)] : ↑(zmod.legendre_sym p a) = ↑a ^ (p / 2)
(α : Type u) : ℕ → Type u
{M : Type u_1} [add_monoid M] (x : M) : set M
{α : Type u_1} (s t : multiset α) : Prop
{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_5} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] (p : seminorm_family 𝕜 E ι) : set (set E)
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 ≤ b) : 1 < a * b
{α : Type u} [add_group α] [preorder α] [covariant_class α α has_add.add has_le.le] {a : α} (h : 0 ≤ a) : -a ≤ a
{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.enough_injectives C] (Z : C) : cochain_complex C ℕ
{ι : Type u_1} {α : ι → Type u_3} [fintype ι] (m : Π (i : ι), measure_theory.outer_measure (α i)) (s : set (Π (i : ι), α i)) : ennreal
{p : ℕ} : padic_val_nat p 0 = 0
 : Type (u_1+1)
{𝒜 : Type u_1} [category_theory.category 𝒜] [category_theory.preadditive 𝒜] [category_theory.limits.has_kernels 𝒜] [category_theory.limits.has_images 𝒜] [category_theory.limits.has_binary_biproducts 𝒜] (A B : 𝒜) : category_theory.exact category_theory.limits.biprod.inr category_theory.limits.biprod.fst
{α : Type u} {β : α → Type v} (s : alist β) : list α
(X : Type u) [comm_ring X] [topological_space X] [topological_ring X] : TopCommRing
{α : Type u_1} {β : α → Type u_2} (F : Π (a : α), equiv.perm (β a)) : equiv.perm (Σ (a : α), β a)
(R : Type u_1) (M : Type u_2) [semiring R] [subsingleton R] [add_comm_monoid M] [module R M] : subsingleton M
{α : Type u_1} {β : Type u_2} [encodable α] [encodable β] : α ⊕ β → ℕ
{Γ₀ : Type u_1} [linear_ordered_comm_group_with_zero Γ₀] (γ : Γ₀) (h : γ ≠ 0) : {x : Γ₀ | x < γ} ∈ nhds 0
{α : Type u_1} [has_Inf α] {ι : Sort u_2} (s : ι → α) : α
 : num → num → num
(M : Type u_1) [monoid M] : mul_action M M
{α : Type u} (β : α → Type v) : Type (max u v)
{α : Type u} (s : computation α) : Prop
{R : Type u_1} {S : Type u_3} [semiring R] [semiring S] : semiring (R × S)
(c : omega.clause) : Prop
{m : Type u_2} {n : Type u_3} {α : Type v} [non_unital_non_assoc_semiring α] [fintype m] (v : m → α) (M : matrix m n α) : n → α
{G : Type w} [topological_space G] [group G] [topological_group G] [t2_space G] (K : topological_space.positive_compacts G) : locally_compact_space G
{M : Type u_1} [monoid M] (n : M) : submonoid M
(p : ℕ) (R : Type u_1) [comm_ring R] (n : ℕ) : mv_polynomial ℕ R
{α : Type u} [preorder α] {a b : α} (h : a < b) : ¬b < a
{R : Type u} {M : Type v} [semiring R] [add_comm_monoid M] [module R M] (self : submodule R M) : sub_mul_action R M
{α : Type u_1} : list α → ℕ → list α
{K : Type w} [field K] {f : polynomial K} (hf : f ≠ 0) : power_basis K (adjoin_root f)
(n : ℕ) : multiset (ℕ × ℕ)
{α : Type u} [topological_space α] (x : α) (F : filter α) : Prop
{n : Type u_3} {α : Type v} [has_star α] : has_star (matrix n n α)
{α : Type u_1} [preorder α] [order_bot α] [locally_finite_order α] (b : α) : finset α
(n : ℕ) (R : Type u_1) [ring R] [nontrivial R] : polynomial.cyclotomic n R ≠ 0
{α : Type u_1} (c : set (set α)) (H : ∀ (a : α), ∃! (b : set α) (H : b ∈ c), a ∈ b) : setoid α
{n : ℕ} {α : Type u_1} (v : vector α (n + 1)) : α
{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : -a < 0 ↔ 0 < a
{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_left_regular (a + b)) : is_add_left_regular b
 : category_theory.grothendieck_topology (Type u)
(n : ℕ) : option ℕ → Prop
(V : Type v) [category_theory.category V] [category_theory.monoidal_category V] (C : Type u₁) : Type (max u₁ v w)
{α : Type u_1} [cancel_comm_monoid_with_zero α] [normalization_monoid α] [decidable_eq α] (h : ∀ (a b : α), ∃ (c : α), ∀ (d : α), d ∣ a ∧ d ∣ b ↔ d ∣ c) : normalized_gcd_monoid α
{R : Type u} [ring R] (s : subring R) : 1 ∈ s
(R : Type u) [ring R] : Type u
{α : Type u} {β : Type v} (f : α → β) (a : ulift α) : ulift β
{ι : Type u} (f : ι → cardinal) : cardinal
{α : Type u_1} [has_mul α] (a : α) (s : set α) : set α
{n : Type u_3} {α : Type v} (A : matrix n n α) (i : n) : α
{α : Type u} (s₁ s₂ : seq α) : seq α
{α : Type u_1} (𝒜 : finset (finset α)) (r : ℕ) : finset (finset α)
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (P : C → Prop) : Type
(n : ℕ) : Type (u_1+1)
(K : Type u) [field K] (V : FinVect K) : FinVect K
{α : Type u_1} (l : list α) : list (list α)
(n m : ℕ) : list ℕ
{a : ℕ} : ℤ
(L : first_order.language) : Type (max u v)
(l : list ℕ) (h : ∀ (p : ℕ), p ∈ l → nat.prime p) : prime_multiset
{α : Type u} (f : filter α) : Prop
{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → option α
{α : Type u} : α × list α × α × list α → α
(α : Type u) [uniform_space α] : setoid α
(α : Type u) [preorder α] [nonempty α] [no_min_order α] : ∃ (f : ℕ → α), strict_anti f
(α : Type u_1) : Type u_1
{α : Type u} {γ : Type u_1} [topological_space γ] (f : α → γ) : ultrafilter α → γ
 : num → num → num
 : Type
{α : Type u_1} [comm_monoid α] [decidable_rel has_dvd.dvd] (a b : α) : enat
{α : Type u} {β : Type v} [ring α] [ring β] (f : α → β) : Prop
{α : Type u_1} [preorder α] [decidable_rel has_le.le] (x : α) (s : ordset α) : bool
(α : Sort u_1) : decidable_eq α
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C) : Type (max u v)
(K : Type u_1) [field K] [uniform_space K] : Prop
(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom (A × B) A
(V : Type u_1) [quiver V] : Type (max u_1 v)
{α : Type u} {β : α → Type v} (f : Π (x : α), β x → bool) (s : finmap β) : bool
{α : Type u_1} [linear_order α] : finset α → option α
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) : Prop
{α : Type u} {L₁ L₂ L₃ : list (α × bool)} : free_group.red L₁ L₂ → free_group.red L₁ L₃ → relation.join free_group.red L₂ L₃
{n : Type u'} [fintype n] [decidable_eq n] {α : Type u_1} [non_assoc_semiring α] (v : n → α) [invertible v] : invertible (matrix.diagonal v)
{R : Type u_1} {a b : R} [semigroup R] (lra : is_left_regular a) (lrb : is_left_regular b) : is_left_regular (a * b)
(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : ↑⊤ = set.univ
 : category_theory.limits.has_limits_of_size AddCommGroup
 : list ℕ → ℕ → list ℕ
{α : Type u_1} [monoid α] (p : α) : Prop
(C : Type u) [category_theory.category C] : category_theory.grothendieck_topology C
(X : Type u) : category_theory.projective X
(L : first_order.language) (L' : first_order.language) : first_order.language
{C : Type u} [category_theory.category C] (X : Top) (Z : C) : algebraic_geometry.PresheafedSpace C
{C : Type u} [category_theory.category C] (G : C) : Prop
(R : Type u_1) [add_comm_group R] [star_add_monoid R] : add_subgroup R
{α : Type u_1} {β : Type u_2} [has_add α] (f : α → β) (c : α) : Prop
{α : Type u_1} {β : Type u_2} (r : α → β → Prop) (t : finset β) (a : α) [decidable_pred (r a)] : finset β
{R : Type v} [comm_ring R] {o : Type u_1} (M : matrix o o R) (b : o → ℕ) : Prop
{R : Type u_1} [left_cancel_semigroup R] (g : R) : is_left_regular g
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : is_open_map proj
(k : ℕ) : nat.partrec.code → ℕ → option ℕ
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) : Prop
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_products C] : category_theory.limits.has_binary_biproducts C
{α : Type u_1} {m : Type u_1 → Type u_2} [monad m] (x : m (option α)) (y : m α) : m α
{α : Type u_1} : list α → list (list α)
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0
{α : Type u} {β : Type v} {γ : Type w} (f : α → β → γ) (s1 : wseq α) (s2 : wseq β) : wseq γ
{α : Type u} [pseudo_metric_space α] (x y : α) : has_edist.edist x y = ↑(has_nndist.nndist x y)
{α : Type u_1} [preorder α] [order_top α] [locally_finite_order α] (a : α) : multiset α
{α : Type u_1} (f : α → α → α) : option α → option α → option α
(p : ℕ) [hp : fact (nat.prime p)] : ℕ → mv_polynomial (fin 2 × ℕ) ℤ
{γ : Type u_1} [U : uniform_space γ] (m : metric_space γ) (H : uniformity γ = uniformity γ) : metric_space γ
{G : Type u} [group G] : inhabited (group_filter_basis G)
{C : Type u} [category_theory.category C] : partial_order (category_theory.grothendieck_topology C)
{α : Type u_1} : has_inf (setoid α)
(x y : Set) : Prop
{α : Type u_1} (l : list α) : list (list α)
{G : Type u_1} [group G] [is_free_group G] : is_free_group.generators G → G
{ι : Type u_1} (M : ι → Type u_2) [Π (i : ι), monoid (M i)] : free_monoid (Σ (i : ι), M i) → free_monoid (Σ (i : ι), M i) → Prop
{α : Type u_1} [dec : decidable_eq α] : regular_expression α → α → regular_expression α
{X : Type u_1} [topological_space X] (s : set X) (h₁ : is_closed s) (h₂ : is_compact s) : topological_space.opens (alexandroff X)
(k : Type u_1) (G : Type u_2) [comm_semiring k] [group G] [fintype G] [invertible ↑(fintype.card G)] : monoid_algebra k G
 : category_theory.limits.has_limits_of_size CommGroup
(L R : list pgame) : pgame
{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_finite_limits C
(n : ℕ) : simplex_category
{ι : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] (u : ι → set X) (s : set X) : Type (max u_1 u_2)
{α : Type u_1} [topological_space α] {s : set α} : measure_theory.analytic_set s ↔ ∃ (β : Type) (h : topological_space β) (h' : polish_space β) (f : β → α), continuous f ∧ set.range f = s
{α : Type u_1} (g : generalized_continued_fraction α) : seq α
{M : Type u_1} [monoid M] {s : set M} {a : M} (hs : is_submonoid s) (h : a ∈ s) : powers a ⊆ s
{ι : Type u_1} (α : ι → Type u_2) (l : list ι) : Type (max u_2 u_3)
{α : Type u} [preorder α] {a b c : α} : a < b → b < c → a < c
(α : Type u_1) [lattice α] [bounded_order α] : Prop
{α : Type u_1} [cancel_comm_monoid_with_zero α] [decidable_eq α] [normalization_monoid α] [unique_factorization_monoid α] (a : α) : multiset α
{α : Type u} {ι : Sort w} (r : α → α → Prop) (f : ι → α) : Prop
 : pgame → pgame → Type (u+1)
{n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (i : fin n) : α i.succ
{ι : Type u_1} (H : ι → Type u_2) : Type (max u_1 u_2)
 : ℕ → ℕ → ℕ → ℕ
(R : Type u_1) (M : Type u_2) [comm_ring R] [topological_space R] [add_comm_group M] [module R M] : Type u_2
{ι : Type u_1} (R : Type u_3) {A : Type u_5} [comm_ring R] [comm_ring A] [algebra R A] (x : ι → A) : Prop
 : Type
{α : Type u_2} [subtraction_monoid α] {a : α} : even a → even (-a)
 : Set → Set
{α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.reduce (free_group.reduce L) = free_group.reduce L
(X : Type u_3) [topological_space X] : Type u_3
(α : Type u) : Type u
 : Type
(H : Type u_5) [topological_space H] : Type u_5
{α : Type u} {β : Type v} (R : α → β → Prop) (s : wseq α) (t : wseq β) : Prop
{α : Type u_2} [comm_monoid α] : comm_monoid (set α)
{α : Type u_1} [decidable_eq α] [fintype α] (𝒜 : finset (finset α)) : finset (finset α)
{α : Type u} [has_le α] [decidable_rel has_le.le] (t₁ t₂ : ordnode α) : bool
{m : Type → Type v} [monad m] {α : Type} (p : α → m bool) (xs : list α) : m (option α)
{R : Type u_1} [comm_ring R] : lie_ring (fin 3 → R)
{α : Type u_1} {β : Type u_2} {ι : Type u_3} [metric_space β] [preorder ι] (f : ι → α → β) (g : α → β) (n : ℕ) (j : ι) : set α
 : num → ℕ
{R : Type u} [semiring R] (p : polynomial R) : R
{α : Sort u_1} {p : α → Prop} {C : Sort u} (H0 : C) (H : Π (a : α), p a → C) : C
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) (N : Type u_2) [add_comm_monoid N] : Type (max u_1 u_2)
(P : ℕ → Prop) (n : ℕ) : mv_polynomial ℕ ℤ
(α : Type u_1) [complete_semilattice_Inf α] : complete_lattice α
{α : Type u} (s : wseq α) : computation bool
 : Type (u_1+1)
{α : Type u} {β : Type v} [semiring α] [semiring β] (f : α → β) : Prop
(α : Type u) (β : Type v) [add_monoid α] [add_action α β] (g : α) : set β
{α : Type u} : nonempty (field α) ↔ is_prime_pow (cardinal.mk α)
{ι : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [add_monoid ι] [monoid R] (A : ι → S) [set_like.graded_monoid A] : submonoid R
 : Type (u_1+1)
(p : ℕ) [hp : fact (nat.prime p)] {k : Type u_1} [comm_ring k] [char_p k p] (n : ℕ) : (fin (n + 1) → k) → (fin (n + 1) → k) → k
{S : Type u_1} [add_semigroup S] {a b c : S} (hac : add_commute a c) (hbc : add_commute b c) : add_commute (a + b) c
 : Type (u+1)
{α : Type u_2} [has_add α] {a : α} : even a → (∃ (b : α), a = bit0 b)
{α : Type u_1} (p : α → Prop) [decidable_pred p] (s : multiset α) : multiset α
 : has_add surreal
{α : Type u} [pseudo_emetric_space α] {s t u : set α} : emetric.Hausdorff_edist s u ≤ emetric.Hausdorff_edist s t + emetric.Hausdorff_edist t u
{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : continuous Z.proj
{α : Type u_1} [preorder α] (a : α) : ordset α
{α : Type u_1} [encodable α] : encodable (multiset α)
{V : Type u} [quiver V] (r : V) : Prop
{α : Type u_1} : ordnode α → ℕ
{a : nnreal} : add_le_cancellable ↑a
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_algebra.is_semisimple R L] [h : is_lie_abelian L] : subsingleton L
{α : Type u_1} {β : Type u_2} (rα : α → α → Prop) (rβ : β → β → Prop) (f : α → β) : Prop
(α : Type u_1) : Type u_1
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type u_1} [is_noetherian K V] (b : basis ι K V) : fintype ι
{γ : Type w} [metric_space γ] : emetric_space γ
{R : Type u_1} [has_mul R] (c : R) : Prop
{α : Type u_1} {s : finset α} {β : α → Type u_2} [h : Π (a : α), decidable_eq (β a)] : decidable_eq (Π (a : α), a ∈ s → β a)
{p : ℕ} (hp : 1 < p) : padic_val_nat p p = 1
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] (j j' : C) : C
{R : Type u_1} [mul_zero_class R] (h : is_right_regular 0) : subsingleton R
{α : Type u} {β : Type v} [has_le β] (l : filter α) (f g : α → β) : Prop
{α : Type u_1} (n : ℕ) (l : list α) : list (multiset α)
(M : Type u) [add_monoid M] : AddMon
{α : Type u_1} {A : Type u_5} [add_monoid A] [monoid α] [distrib_mul_action α A] : mul_action α (add_submonoid A)
 : Type
{α : Type u} : list α → ordnode α → ℕ → ordnode α
(α : Type u_1) [preorder α] : Type u_1
{α : Type u} {β : Type v} [has_add β] (f : α → β) : free_add_magma α → β
(α : Type u_3) [uniform_space α] [group α] : Prop
{α : Type u_1} [has_mul α] (s : set α) (a : α) : set α
(M : Type u_1) [has_zero M] : zero_hom M M
(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] : Type u_2
{α : Type u} {β : Type v} (f : β → option (α × β)) (b : β) : seq α
{α : Type u_1} (G : simple_graph α) (s : set α) : Prop
{α : Type u} [topological_space α] (s : set α) : Prop
 : ℕ → Type
{k : Type u₁} {G : Type u₂} [semiring k] [has_zero G] : has_one (add_monoid_algebra k G)
(R : Type u) [non_assoc_semiring R] : galois_insertion subsemiring.closure coe
{H : Type u_1} [topological_space H] {e : local_homeomorph H H} : e ∈ charted_space.atlas H H ↔ e = local_homeomorph.refl H
{n : ℕ} (α : typevec (n + 1)) : Type u
(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_limits C] : category_theory.limits.has_finite_wide_pullbacks C
{α : Type u_1} {β : Type u_2} [encodable α] [fintype α] [encodable β] : encodable (α → β)
{n : ℕ} {x : ℕ × ℕ} : x ∈ finset.nat.antidiagonal n ↔ x.fst + x.snd = n
{α : Type u_1} [decidable_eq α] (a : α) : list α → list ℕ
{α : Type u_1} {β : Type u_2} (r : rel α β) : rel β α
{α : Type u_1} {β : Type u_2} [partial_order β] (f : α → β) (inj : function.injective f) : partial_order α
(o : ordinal) : ordinal
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] (F : ι → α → β) (f : α → β) (p : filter ι) : Prop
(α : Sort u_1) (β : Sort u_2) : Sort (max 1 (imax u_1 u_2))
{α : Type u_1} [conditionally_complete_lattice α] (a : α) : has_Inf.Inf {a} = a
{X : Top} {C : Type u} [category_theory.category C] (F : Top.presheaf C X) : Prop
(C : Type u) [category_theory.category C] [category_theory.non_preadditive_abelian C] : category_theory.abelian C
{α : Type u} [has_le α] [decidable_rel has_le.le] : ordnode α → ordnode α → ordnode α
{R : Type u} [semiring R] (p : polynomial R) (n : ℕ) (a : R) : polynomial R
{𝕜 : Type u} {A : Type v} [field 𝕜] [ring A] [algebra 𝕜 A] [nontrivial A] : spectrum 𝕜 0 = {0}
{R : Type u_1} [mul_zero_class R] : is_regular 0 ↔ subsingleton R
{α : Type u_1} (C : set (set α)) : Prop
(G : Type u_1) [measurable_space G] [has_sub G] : Prop
(p : ℕ) (R : Type u_1) [hp : fact (nat.prime p)] [comm_ring R] : comm_ring (witt_vector p R)
{ι : Type u_1} {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] (f : ι → α) (g : ι → β) (s : set ι) : Prop
{R : Type u_1} [comm_semiring R] {M : submonoid R} {S : Type u_2} [comm_semiring S] [algebra R S] [is_localization M S] (h : 0 ∈ M) : unique S
{α : Type u_1} {ι : Type u_2} {κ : Type u_3} (C : (ι → option α) → κ) : Type (max u_1 u_2 u_3)
{α : Type u_1} (l₁ l₂ : list α) : Prop
(R : Type u) [ring R] (Γ₀ : out_param (Type v)) [linear_ordered_comm_group_with_zero Γ₀] : Type (max u v)
{ι : Type u_1} (c : complex_shape ι) : complex_shape ι
{M : Type u_5} [add_comm_group M] : unique (module ℤ M)
(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] : category_theory.limits.has_finite_products C
{α : Type u_1} [measurable_space α] (s : set α) : measure_theory.measure α
{α : Type u_2} [has_sub α] : has_sub (filter α)
{α : Type u_1} [has_mul α] [has_le α] [contravariant_class α α has_mul.mul has_le.le] {a b c : α} (bc : a * b ≤ a * c) : b ≤ c
(a b c : ℤ) : Prop
 : Type
 : Type
{α : Type u} [pseudo_metric_space α] : metric.diam ∅ = 0
{R : Type u_1} [has_add R] (c : R) : Prop
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space.separable_space α] [topological_space β] {f : α → β} (h : dense_range f) (h' : continuous f) : topological_space.separable_space β
{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] : continuous (λ (g : G × G), g.fst + g.snd + -g.fst)
(M : Type u_1) [add_monoid M] [measurable_space M] [has_measurable_add₂ M] : has_measurable_smul₂ ℕ M
{α : Type u} (s : seq α) (n : ℕ) : Prop
(α : Type) [has_zero α] [has_one α] [has_add α] (fromc toc : char) : parser α
{K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x + y ∈ s
(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom B (A × B)
{n : ℕ} : zmod n → ℤ
(x : Class) : Class
{α : Type u_1} {A : Type u_3} [has_zero A] (f : α → A) : set α
(R : Type u) [semiring R] (P : Type (max u v)) [add_comm_monoid P] [module R P] : Prop
(α : Sort u) : Sort (max 1 u)
{α β : Type u} {F : Type u → Type u} [applicative F] [is_comm_applicative F] [decidable_eq β] (f : α → F β) (s : finset α) : F (finset β)
{α : Sort u_1} {β : Sort u_2} (f : α → β) (P : Prop) [decidable P] (a b : α) : f (ite P a b) = ite P (f a) (f b)
(C : Type u₁) [category_theory.category C] : Prop
(R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] : Prop
{α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v : α) (s : finset α) : Prop
 : onote → onote × ℕ
(S : Type u_4) (M : out_param (Type u_5)) [has_add M] [set_like S M] : Type
{α : Type u_1} [conditionally_complete_lattice α] : conditionally_complete_lattice (with_top α)
{α : Type u_1} : list α → Prop
(p : Set → Prop) : Class.iota p ∈ Class.univ
{p : ℕ} {R : Type u_1} (x : witt_vector p R) (n : ℕ) : witt_vector p R
(α : Type u_1) : Type u_1
{𝕜 : Type u_1} {E : Type u_2} [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] (K : geometry.simplicial_complex 𝕜 E) : set E
(α : Type u) : Type u
{S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : add_commute b a
{α : Type u} : dense_range has_pure.pure
{V : Type u} : has_inf (simple_graph V)
{n : Type u} [decidable_eq n] [fintype n] {α : Type v} [comm_ring α] (A : matrix n n α) : matrix n n α
{n : ℕ} {C : fin n.succ → Sort u_1} (H0 : C 0) (Hs : Π (i : fin n), C i.succ) (i : fin n.succ) : C i
{X : Type u_1} {α : Type u_2} {β : Type u_3} [fintype α] [topological_space X] (f : α → locally_constant X β) : locally_constant X (α → β)
{R : Type u₁} [non_unital_non_assoc_semiring R] : is_scalar_tower ℕ R R
{α : Type u_1} {β : Type u_2} [pseudo_emetric_space α] [pseudo_emetric_space β] (K : nnreal) (f : α → β) : Prop
(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_limits C] : category_theory.limits.has_finite_products C
{P : pfunctor} : P.W → P.A
 : has_pow ordinal ordinal
{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] (N : submonoid S) : submonoid R
{G : Type u_1} [group G] (H : subgroup G) : ℕ
 : Type
{α : Type u_1} {β : Type u_2} (ea : equiv.perm α) (eb : equiv.perm β) : equiv.perm (α ⊕ β)
(V : Type u) : simple_graph V
{α : Sort u_1} : trunc α → α
 : category_theory.is_equivalence Compactum_to_CompHaus
{M : Type u_1} [has_add M] : has_top (add_subsemigroup M)
{α : Sort u} [decidable_eq α] (a b r : α) : α
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : Prop
{R : Type u_1} {S : Type u_3} [ring R] [ring S] : ring (R × S)
{α : Type u_1} {β : Type u_2} : list α → list β → list (α × option β) × list β
{ι : Type u_1} {𝕜 : Type u_3} [is_R_or_C 𝕜] [fintype ι] [decidable_eq ι] (i : ι) (a : 𝕜) : euclidean_space 𝕜 ι
{α : Type u_1} (l : ordnode α) (x : α) (r : ordnode α) : ordnode α
{α : Type u_1} (p : α → Prop) [decidable_pred p] (l : list α) : list (ℕ × α)
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] (F : ι → α → β) (p : filter ι) (s : set α) : Prop
(p : Type u_2) (q : Type u_3) (R : Type u₂) [decidable_eq p] [decidable_eq q] [comm_ring R] [fintype p] [fintype q] : lie_subalgebra R (matrix (p ⊕ q) (p ⊕ q) R)
(X : Type u_1) [topological_space X] : Prop
{n : ℕ} (P : mvpfunctor (n + 1)) : pfunctor
{X : Top} (F : Top.presheaf (Type v) X) : Top.sheaf (Type v) X
{ι : Type u} {X : Type v} [topological_space X] {s : set X} (f : bump_covering ι X s) (U : ι → set X) : Prop
{α : Type u} [pseudo_metric_space α] (s : set α) : continuous (λ (x : α), metric.inf_nndist x s)
{α : Type u} {β : Type v} [uniform_space α] [semilattice_sup β] (u : β → α) : Prop
{α : Type u_1} (s : finset α) [decidable_eq α] : finset (α × α)
(α : Type u) (β : Type v) : Type (max u v)
{k : ℕ} {A : finset ℕ} (h₁ : ∀ {x : ℕ}, x ∈ A → x < k) : A.sum (has_pow.pow 2) < 2 ^ k
{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : ¬has_sbtw.sbtw c b a
 : omega.nat.preterm → option (omega.nat.preterm × omega.nat.preterm)
(n : ℕ) : filter.tendsto (λ (x : ℝ), polynomial.eval x (exp_neg_inv_glue.P_aux n) * real.exp (-x⁻¹) / x ^ (2 * n)) (nhds_within 0 (set.Ioi 0)) (nhds 0)
(α : Type u_1) [preorder α] : circular_preorder α
{H : Type u} {M : Type u_2} [topological_space H] [topological_space M] [charted_space H M] : has_groupoid M (continuous_groupoid H)
(n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1
{α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) (x : α) : Prop
{α : Type u_1} [partial_order α] [succ_order α] {a b : α} [no_max_order α] : a ≠ b → order.succ a ≠ order.succ b
{α : Type u_1} (o : option α) : finset α
{α : Type u_1} {β : Type u_2} [fintype α] [decidable_eq β] {f : α → β} (f_bij : function.bijective f) (b : β) : α
{α : Type u_1} {r : α → α → Prop} (sym : symmetric r) : set (sym2 α)
{α : Type u_1} [preorder α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] {a b : α} : b - (b - a) ≤ a
{M : Type u_1} [has_add M] (r : M → M → Prop) : M → M → Prop
(a b : nonote) : Prop
{P : Type u_1} [has_le P] : partial_order (order.ideal P)
{α : Type u_1} [has_lt α] : ordering → α → α → Prop
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} (r : α → β → Prop) (f : α → γ) (g : β → δ) : γ → δ → Prop
{α : Type u_1} {β : Type u_2} {p : α → β → Prop} {x₀ x₁ : Σ (a : α), subtype (p a)} : x₀.fst = x₁.fst → ↑(x₀.snd) = ↑(x₁.snd) → x₀ = x₁
(M : Type u_1) [add_zero_class M] : galois_insertion add_submonoid.closure coe
{α : Type u_1} {β : Type u_2} [measurable_space α] [semilattice_sup β] [order_bot β] [has_zero β] (i : ℕ → β) (f : α → β) (n : ℕ) : measure_theory.simple_func α β
 : list bool → ℕ
(x : ℕ) : Prop
{A : Type u_1} (K : Type u_2) [comm_ring A] (S : submonoid A) [comm_ring K] [algebra A K] [is_fraction_ring A K] (hS : S ≤ non_zero_divisors A) : subalgebra A K
{B : Type u_3} (E₁ : B → Type u_6) (E₂ : B → Type u_7) [topological_space (bundle.total_space E₁)] [topological_space (bundle.total_space E₂)] : topological_space (bundle.total_space (λ (x : B), E₁ x × E₂ x))
(ι : Type u_1) (R : Type u_3) (M : Type u_5) [semiring R] [add_comm_monoid M] [module R M] : Type (max u_1 u_3 u_5)
{α : Type u_1} [generalized_boolean_algebra α] (f : ℕ → α) : ℕ → α
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] : Prop
(α : Type u_1) (β : Type u_2) [uniform_space β] (𝔖 : set (set α)) : uniform_space (α → β)
(α : Type u_2) [preorder α] [bounded_order α] : bounded_order_hom α α
(M : Type u_1) [measurable_space M] [has_add M] : Prop
{α : Type u_1} [bornology α] {p : α → Prop} : bornology.is_bounded {x : α | p x} → bounded_space (subtype p)
{M₀ : Type u_1} [mul_zero_one_class M₀] : 0 ≠ 1 ∨ ∀ (a : M₀), a = 0
 : ℤ → option ℕ
{α : Type u_1} (g : generalized_continued_fraction α) : Prop
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {e : α → β} (de : dense_embedding e) [topological_space.separable_space α] : topological_space.separable_space β
{α : Type u} [topological_space α] [t2_space α] {s : set α} (hs : is_compact s) : is_closed s
(S : Type u_1) [ring S] (a : ℕ) : ↑(a.desc_factorial 2) = ↑a * (↑a - 1)
{α : Type u} {β : Type v} [topological_space α] [normed_lattice_add_comm_group β] : semilattice_inf (bounded_continuous_function α β)
{n : ℕ} : bitvec n → bitvec n
{C : Type u} [category_theory.category C] {X : C} : monoid (category_theory.End X)
 : Type
(α : Sort u_1) : Prop
{α : Type u_1} [circular_preorder α] {a b c d : α} (hbc : has_sbtw.sbtw a b c) (hcd : has_sbtw.sbtw a c d) : has_sbtw.sbtw a b d
{G : Type u_1} [add_group G] (K V : set G) : ℕ
{α : Type u_1} {β : Sort u_2} (f : α → β) (b : β) : option α
(a b : znum) : num
(p : Set → Set → Prop) (x y : Set) : Set
{α : Type u_1} [has_lt α] (s : set α) : Prop
{V : Type u} (G : simple_graph V) : set (sym2 V)
{α : Type u_1} (l : list α) : list (α × α)
(𝕜 : Type u_1) [is_R_or_C 𝕜] (n : Type u_2) [fintype n] : Type (max u_2 u_1)
{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) (s : alist β) : alist β
(G : Type u) [topological_space G] [has_neg G] : Prop
{α : Type u_1} {β : Type u_2} (f : filter α) (h : set α → set β) : filter β
 : Type (u_1+1)
(α : Type u_6) (β : Type u_7) [preorder α] [preorder β] [topological_space α] [topological_space β] : Type (max u_6 u_7)
{α : Type u} (r : α → α → Prop) [is_well_order α r] : principal_seg r has_lt.lt
{α : Type u} (s : wseq α) : Prop
 : nat.arithmetic_function ℤ
{R : Type u₁} [non_unital_non_assoc_ring R] : smul_comm_class ℤ R R
{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : a * b < c → b < a⁻¹ * c
 : Type (u+1)
{M : Type u_1} [has_add M] (c : add_con M) : Type u_1
{α : Type u_1} (n : ℕ) (x : α) : function.is_periodic_pt id n x
 : category_theory.limits.has_limits_of_size SemiRing
{α : Sort u_1} (p : α → Prop) : decidable_pred p
(p : ℕ) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] [is_domain k] [char_p k p] [perfect_ring k p] (m : ℤ) : witt_vector.isocrystal p k (witt_vector.standard_one_dim_isocrystal p k m)
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0
 : nzsnum → bool
{α : Type u_2} [has_one α] : has_one (set α)
{C : Type u_1} [category_theory.category C] : has_coe_t C (category_theory.idempotents.karoubi C)
{α : Type u_1} [preorder α] {a : α} : order_bot {x // a ≤ x}
{α : Type u} [topological_space α] (s : set α) : Prop
{L : first_order.language} (T : L.Theory) : Prop
{α : Type u} {m n : ℕ} (hm : m = n + n) (v : fin m → α) (k : fin n) : α
(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] (J : category_theory.grothendieck_topology C) : category_theory.pretopology C
{α : Type u} [pseudo_metric_space α] : uniform_continuous (λ (p : uniform_space.completion α × uniform_space.completion α), has_dist.dist p.fst p.snd)
 : list ℕ → ℕ → list ℕ
(n a b : ℕ) : Prop
(Γ : Type u_1) [inhabited Γ] : Type u_1
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) (m : multiset M) (hm : ∀ (a : M), a ∈ m → a ∈ S) : m.sum ∈ S
{α : Type u_1} {n : ℕ} (p : α → Prop) (v : vector3 α n) : Prop
{M : Type u_1} [has_mul M] : complete_lattice (subsemigroup M)
(α : Type u_1) (n : ℕ) : setoid (vector α n)
{α : Type u_1} (l : ordnode α) (x : α) (r : ordnode α) : ordnode α
(C : Type u) [category_theory.category C] : category_theory.bicategory (category_theory.locally_discrete C)
{α : Type u_1} [uniform_space α] (pkg : abstract_completion α) {β : Type u_2} [uniform_space β] (pkg' : abstract_completion β) : abstract_completion (α × β)
 : irrational golden_conj
 : category_theory.limits.has_limits_of_size CommRing
 : category_theory.limits.colimit_cocone (category_theory.functor.empty (Type u))
(α : Type u) : Type u
{a b : ℕ} (hab : a.coprime b) : a.factors.disjoint b.factors
{α : Type u_1} (a : α) : semiquot α
{α : Type u_1} {M : Type u_2} [has_zero M] (s : set α) (f : α → M) : α → M
(ι : Type u_3) : well_founded has_lt.lt
(A : Type u_1) [has_add A] : group (add_aut A)
{α : Type u} [monoid α] (a b : α) : Prop
(S : Type u_3) (G : Type u_4) [has_inv G] [set_like S G] : Type
{a b : ℤ} (ha : a ≠ 0) : is_least {n : ℕ | 0 < n ∧ ∃ (x y : ℤ), ↑n = a * x + b * y} (a.gcd b)
{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 1 < a) (hb : 1 ≤ b) (b0 : 0 < b) : 1 < a * b
{α : Type u_1} {r : α → α → Prop} [is_refl α r] [is_antisymm α r] {a b : α} : antisymm_rel r a b → a = b
{α : Type u_1} [add_group α] (s : add_subgroup α) : setoid α
{n : ℕ} {a b : fin n} : ↑a ≤ ↑b ↔ a ≤ b
{α : Type u_1} [measurable_space α] (p : pmf α) : measure_theory.measure α
{R : Type u} [comm_semiring R] (f : polynomial R) : Prop
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) : subfield L
{α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α] : a < b → order.pred a < order.pred b
{α : Type u_1} : list (option α) → list α → list α
{V : Type u} (G : simple_graph V) : Prop
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (h_int : algebra.is_integral K L) : is_totally_disconnected set.univ
{G : Type u} [add_monoid G] : is_of_fin_add_order 0
(X : Type u) [has_mul X] [has_zero X] [has_lt X] : Prop
{R : Type u_1} {a b : R} [add_semigroup R] (lra : is_add_left_regular a) (lrb : is_add_left_regular b) : is_add_left_regular (a + b)
{α : Type u_1} [denumerable α] {γ : α → Type u_3} [Π (a : α), denumerable (γ a)] : denumerable (sigma γ)
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] : has_zero C
 : Type
{α : Type u_1} {β : Type u_4} [preorder α] [preorder β] {u : β → α} (l : lower_adjoint u) : set α
(n : ℕ) (R : Type u_1) [comm_ring R] [is_domain R] : finset R
(ι : Type u) (β : ι → Type v) [Π (i : ι), has_zero (β i)] : Type (max u v)
(M : Type u_9) (N : Type u_10) [has_mul M] [has_mul N] : Type (max u_10 u_9)
{α : Type u_1} [has_mul α] [has_lt α] [contravariant_class α α has_mul.mul has_lt.lt] {a b c : α} (bc : a * b < a * c) : b < c
{Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ) : turing.list_blank Γ
 : matrix (fin 4) (fin 4) ℤ
(L : first_order.language) (M : Type w) [L.Structure M] : set (category_theory.bundled L.Structure)
{p : ordinal → Prop} (i : ordinal) (h : ∀ (j : ordinal), (∀ (k : ordinal), k < j → p k) → p j) : p i
 : function.injective real.sinh
(c : omega.clause) : Prop
{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a : α} : 0 < -a ↔ a < 0
{ι : Type u_1} (V : Type u) [category_theory.category V] [category_theory.preadditive V] (c : complex_shape ι) : Type (max u u_1 v)
 : name → ℕ
{α : Type u} [topological_space α] {s : set α} : is_preirreducible s ↔ ∀ (z₁ z₂ : set α), is_closed z₁ → is_closed z₂ → s ⊆ z₁ ∪ z₂ → s ⊆ z₁ ∨ s ⊆ z₂
(obj : Type u) : Type (max u (v+1))
(α : Sort u_1) [s : setoid α] : function.surjective quotient.mk
(M : Type u_4) [mul_one_class M] : Type u_4
{R : Type u} [comm_ring R] (t : set (prime_spectrum R)) : ideal R
(X : Profinite) : category_theory.limits.cone X.diagram
{M : Type u_1} {N : Type u_2} (α : Type u_6) [has_vadd M α] (g : N → M) : has_vadd N α
{R : Type u₁} [non_unital_non_assoc_ring R] : is_scalar_tower ℤ R R
{G : Type u} [add_group G] (B : add_group_filter_basis G) : topological_space G
{G : Type u_1} [group G] {s t : set G} (ht : is_normal_subgroup t) (h : s ⊆ t) : group.normal_closure s ⊆ t
{β : Type u_2} {ι : Sort u_4} (s : ι → set β) : set β
{α : Type u} [add_monoid α] (u : add_units α) : α
{α : Type u_1} {β : Type u_2} [nonempty α] (f : α → β) (s : set α) (hf : set.inj_on f s) : local_equiv α β
{α : Type u_1} [linear_ordered_semiring α] : subsingleton (floor_semiring α)
{X : Type u_1} {Y : Type u_2} {Z : Type u_3} [topological_space X] [topological_space Y] (f : X → Y) : locally_constant Y Z → locally_constant X Z
{r : nnreal} (hr : r < 1) : has_sum (λ (n : ℕ), r ^ n) (1 - r)⁻¹
(G : Type u_1) [add_group G] : galois_insertion add_subgroup.closure coe
{α : Type u_1} {β : Sort u_2} (f : α → β) (g : β → option α) : Prop
(R : Type u) [comm_ring R] : Top.presheaf CommRing (algebraic_geometry.prime_spectrum.Top R)
{α : Type u_2} [decidable_eq α] (k : ℕ) (𝒜 : finset (finset α)) : finset (finset α)
(J : Type u₁) [category_theory.category J] : Type u₁
{α : Type u_1} {β : Type u_2} [linear_order α] [linear_order β] : order.partial_iso α β → order.partial_iso β α
{α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] (f : α → β) : Prop
{α : Type u_1} [measurable_space α] : (α → ennreal) → ℕ → measure_theory.simple_func α ennreal
{α : Type u} [has_le α] [decidable_rel has_le.le] : ordnode α → ordnode α → bool
{M : Type u_1} [has_mul M] : has_Inf (con M)
{α : Type u} (s : wseq α) (n : ℕ) : wseq α
{R : Type u_1} [distrib R] (r : R) : add_hom R R
{α : Type u_1} {β : Type u_2} [conditionally_complete_lattice α] (f : filter β) (u : β → α) : α
{S : Type u_1} [has_mul S] (a : S) : commute a a
{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a : α} : -a < 0 ↔ 0 < a
{R : Type u_1} [semiring R] : power_series R
{α : Type u} {β : Type v} (f : ℕ → α → β) (as : list α) : list β
(G : Type u_3) [add_group G] : Type u_3
(R : Type u) {X : Type v} [semiring R] : X → free_non_unital_non_assoc_algebra R X
{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] [topological_space Z] (proj : Z → B) : Prop
{M : Type u_1} {N : Type u_2} [has_one M] [has_one N] (f : one_hom M N) : one_hom (with_top M) (with_top N)
{α : Type u} [semigroup α] [has_distrib_neg α] (a b : α) : a ∣ -b ↔ a ∣ b
{C : Type u} [category_theory.category C] (𝒢 : set C) : Prop
{α : Type u_6} : has_faithful_smul (function.End α) α
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b ≤ 0) : a + b < 0
{α : Type u_1} (ι : Type u_2) [preorder ι] (m : measurable_space α) : Type (max u_1 u_2)
{M : Type u_1} [add_comm_monoid M] (x : M) : Type u_1
{L : first_order.language} (T : L.Theory) : Prop
{C : Type u_1} [category_theory.bicategory C] (X : C) : Type u_3
{α : Type u_1} {β : Type u_2} {p : α → Prop} (f : Π (a : α), p a → β) (s : multiset α) : (∀ (a : α), a ∈ s → p a) → multiset β
{α : Type u_1} [decidable_eq α] (a : α) (s : multiset α) : multiset α
{α : Type u} {m n : ℕ} (hm : m = n + n) (v : fin m → α) (k : fin n) : α
(X : Type u_1) [topological_space X] : preorder X
(α : Type u_1) [fintype α] : trunc {f // function.bijective f}
{α : Type u_1} [topological_space α] [quasi_sober α] {S : set α} (hS : is_irreducible S) : α
{α : Type u} : ordnode α → α → ordnode α → ordnode α × α
{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] (h : G) : continuous (λ (g : G), g * h * g⁻¹)
{M : Type u_2} {α : Sort u_4} [comm_monoid M] (f : α → M) : M
{α : Type u_1} [decidable_eq α] [fintype α] (f : equiv.perm α) (x : α) : equiv.perm α
{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} : a⁻¹ < b⁻¹ → b < a
(M : Type u_1) [measurable_space M] [has_sup M] : Prop
{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {f g : bounded_continuous_function α β} [is_empty α] : has_dist.dist f g = 0
{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} {g : β → α} (h : isometry f) (hg : function.right_inverse g f) : isometry g
{R : Type u} [has_add R] : has_mul (tropical R)
{α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : b ≤ c - a → a + b ≤ c
{R : Type u} [non_assoc_semiring R] (M : submonoid R) : subsemiring R
{α : Type u} (s : set α) : filter α
{R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R M) ↔ monoid.fg M
(α : Type u) : Type u
{α : Type u} (s : seq α) : ℕ → seq α
{Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ) (n : ℕ) : Γ
(Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)] : valuation (ratfunc Fq) (with_zero (multiplicative ℤ))
{α : Type u_1} [decidable_eq α] {s : finset α} {a b : α} (hs : b ∈ s) (hsa : b ∉ s.erase a) : b = a
{α : Type u} (x : α) : free_group α
{α : Type u_1} {n : ℕ} (f : fin2 n → α) : vector3 α n
 : Type
(R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] [nontrivial R] {x : A} : is_integral R x → is_algebraic R x
{α : Type u_2} [decidable_eq α] [has_add α] : has_add (finset α)
{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] (K : nnreal) (f : α → β) : Prop
{M₂ : Type u_2} {M₁ : Type u_1} [has_neg M₁] [has_involutive_neg M₂] (f : M₁ → M₂) (hf : function.injective f) (inv : ∀ (x : M₁), f (-x) = -f x) : has_involutive_neg M₁
{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.enough_projectives C] (Z : C) : chain_complex C ℕ
{L : first_order.language} (K : set (category_theory.bundled L.Structure)) : Prop
(a b : Prop) : Prop
{B : Type u} [quiver B] {a b : B} : category_theory.free_bicategory.hom a b → category_theory.free_bicategory.hom a b → Type (max u v)
 : ennreal → ereal
{α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) : Prop
{α : Type u_1} (s : multiset α) : list α
{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b c : α} : a ≤ c - b → a + b ≤ c
 : bool → bool → snum → snum
{p : ℕ} (hp : 1 < p) : padic_val_int p ↑p = 1
{M : Type u_1} [comm_monoid M] (x : M) (N' : Type u_2) [comm_monoid N'] : Type (max u_1 u_2)
(α : Type u) [uniform_space α] : Prop
 : category_theory.category algebraic_geometry.LocallyRingedSpace
(G : Type u_1) [monoid G] : ¬monoid.is_torsion_free G ↔ ∃ (g : G), g ≠ 1 ∧ is_of_fin_order g
(α : Type u_1) [conditionally_complete_linear_order α] [topological_space α] [order_topology α] : compact_Icc_space α
 : has_add nonote
{M : Type u_1} [has_mul M] (r : M → M → Prop) : con M
(n : ℕ) (A : Type u_1) (v : typevec n) : Type u_1
{m : Type u_2} {n : Type u_3} {α : Type v} [non_unital_non_assoc_semiring α] [fintype n] (M : matrix m n α) (v : n → α) : m → α
{α : Type u} [ordered_add_comm_monoid α] (zero_le : ∀ (a : α), 0 ≤ a) : ordered_add_comm_monoid (with_zero α)
(α : Type u) : Type u
 : Type
 : Type (u+1)
 : cardinal
(F : Type u_8) (α : out_param (Type u_9)) (β : out_param (Type u_10)) [complete_lattice α] [complete_lattice β] : Type (max u_10 u_8 u_9)
(M : Type u) [add_comm_monoid M] : AddCommMon
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (s : submonoid M) (t : submonoid N) : submonoid (M × N)
{α : Type u_1} [preorder α] [nonempty α] [no_max_order α] : infinite α
 : list name
{α : Type u} [non_unital_non_assoc_ring α] (a b c : α) : a * (b - c) = a * b - a * c
{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → multiset.Ioc a b = 0
 : Type
(Γ : Type u) (Γ' : Type v) [inhabited Γ] [inhabited Γ'] : Type (max u v)
{α : Type u} (p : α → Prop) [decidable_pred p] (s : wseq α) : computation ℕ
{X : Type u_1} [topological_space X] [t1_space X] : t1_space (alexandroff X)
{α : Type u_2} [subtraction_comm_monoid α] : subtraction_comm_monoid (set α)
{M : Type u_1} [monoid M] : is_submonoid set.univ
 : Type (u+1)
{α : Type u_1} {β : Type u_2} [measurable_space α] (s : set α) (hs : measurable_set s) (f g : measure_theory.simple_func α β) : measure_theory.simple_func α β
{α : Type u_2} : bornology α
{ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] {i j : ι} (w : free_product.neword M i j) : M i
(v : ℕ → ℤ) (as : list ℤ) (l : ℕ) : ℕ → ℤ
(u : pnat.xgcd_type) : pnat.xgcd_type
{α : Type u} (β : Type v) [group α] [monoid β] [mul_action β α] (H : subgroup α) : Prop
{α : Type u_1} (x : α) : thunk α
{α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] : a < b - c ↔ c + a < b
{α : Type u} {β : Type v} {γ : Type u_1} (a : α) : α ⊕ β ⊕ γ
{α : Type u_1} : complete_lattice (setoid α)
(sub : name) : name → name
{L R : Type v} (fst snd : L → R) : Type v
{α : Type u_1} {β : Type u_2} [has_add α] [has_neg β] (f : α → β) (c : α) : Prop
(n : ℕ) : finset (Σ (a : fin n), fin n)
{α : Type u_1} : list (dlist α) → dlist α
 : Type
(R : Type u) [semiring R] : Prop
{α : Type u} [preorder α] {a b c : α} : a < b → b ≤ c → a < c
{α : Type u_1} {β : Type u_2} [encodable α] (f : β → α) (finv : α → β) (linv : ∀ (b : β), finv (f b) = b) : encodable β
(α : Type u_1) [lattice α] : Lattice
 : Type
{α : Type u_1} [semilattice_sup α] [order_bot α] (s : multiset α) : α
(C : Type u) [category_theory.category C] : Prop
{α : Type u} [preorder α] {s t : set α} (h : bdd_below s) : bdd_below (s ∩ t)
(p' : ℕ) : 2 < lucas_lehmer.q (p' + 2)
 : matrix (fin 8) (fin 8) ℤ
{n : Type u_4} {α : Type u_5} [fintype n] [semi_normed_ring α] [decidable_eq n] : semi_normed_ring (matrix n n α)
(L : first_order.language) (L' : first_order.language) : Type (max u_1 u_2 u_3 u_4)
{X : Type u_1} [topological_space X] [discrete_topology X] : order_bot (discrete_quotient X)
{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} [subsingleton α] : isometry f
{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) [no_max_order α] : closure (set.Ioi a) = set.Ici a
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] : Type (max u v)
 : omega.nat.preterm → Prop
{n : ℕ} (hpos : 0 < n) : irreducible (polynomial.cyclotomic n ℤ)
{α : Type u} [decidable_eq α] (L : list (α × bool)) : list (α × bool)
{M : Type u_1} [has_mul M] : has_mul (ultrafilter M)
(𝕜 : Type u_1) (V : Type u_2) [normed_field 𝕜] [add_comm_group V] [module 𝕜 V] : Type u_2
{α : Type u} : partial_order (topological_space α)
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] (e : local_homeomorph α β) (e' : local_homeomorph β γ) : local_homeomorph α γ
(G : Type u) : Type u
(R : Type u) [rack R] : rack.pre_envel_group R → rack.pre_envel_group R → Prop
{α : Type u_1} [measurable_space α] (a : α) : measure_theory.measure α
(R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] : Type
 : ℕ → pos_num
{α : Type u} {β : Type v} : seq α → seq β → seq (α × β)
{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] [no_zero_smul_divisors R M] (x : module.ray R M) : x ≠ -x
 : Type
(n : ℕ) : finset ℕ
 : first_order.language
{α : Type u_1} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} (m : α → β → γ → δ) (f : filter α) (g : filter β) (h : filter γ) : filter δ
 : Type v
(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) : ι → k
{α : Type u_1} [linear_order α] (a : α) : {a}.min' _ = a
(M₀ : Type u_4) : Type u_4
{α : Type u} [has_neg α] [has_sup α] : has_abs α
{α : Type u_1} [preorder α] [order_top α] (a : α) : Prop
(α : Type u_4) : Type u_4
{M : Type u_1} [mul_one_class M] {S T : submonoid M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T) : S = T
{α : Type u_1} (a : α) : lists α
{R : Type u} {M : Type v} [semiring R] [add_comm_monoid M] [module R M] (p : submodule R M) (s : set M) (hs : s = ↑p) : submodule R M
 : Type
{M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : L.sum < 0) : 0 < L.length
(α : Type u_3) [topological_space α] : Type u_3
{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order α] [lattice β] (gi : galois_coinsertion l u) : lattice α
{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] : has_mul (submodule R A)
(α : Type u_3) [has_le α] [has_add α] [has_sub α] : Type
{α : Type u} [preorder α] {s : set α} {a : α} (h : is_greatest s a) : bdd_above s
{G : Type u_1} [group G] (k : set G) : subgroup G
{p n : ℕ} {R : Type u_1} (i : fin n) (x : truncated_witt_vector p n R) : R
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{G : Type u_1} [has_zero G] [has_add G] [has_neg G] : list G → G
{α : Type u} {β : Type v} [preorder β] (f : α → β) (s : set α) (a : α) : Prop
{M : Type u_1} [add_monoid M] : is_add_submonoid set.univ
{α : Type u_1} {β : Type u_2} [fintype (α ⊕ β)] : fintype β
{α : Type u_1} {β : Type u_2} {f : α → β} (Hf : function.injective f) : function.injective (option.map f)
{α : Type u_2} {β : Type u_3} {γ : Type u_4} [complete_lattice α] [complete_lattice β] [complete_lattice γ] (f : frame_hom β γ) (g : frame_hom α β) : frame_hom α γ
(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [non_assoc_semiring α] [preorder α] [non_assoc_semiring β] [preorder β] : Type (max u_6 u_7 u_8)
{n : ℕ} (v : bitvec n) : ℕ
(ι : Type u_2) : Type u_2
 : snum → snum
{G : Type u_2} [group G] : mul_action.fixed_points (conj_act G) G = ↑(subgroup.center G)
{M : Type u_5} [nontrivial M] [hM : monoid_with_zero M] (h : ∀ (a : M), is_unit a ∨ a = 0) : group_with_zero M
{β : Type u} {α : Type v} [add_comm_monoid β] {s : finset α} (f : α → β) : mul_opposite.op (s.sum (λ (x : α), f x)) = s.sum (λ (x : α), mul_opposite.op (f x))
{n : ℕ} (k : ℕ) : option (fin2 n)
{α : Type u} [preorder α] {a b c : α} : b ≤ c → a = b → a ≤ c
{α : Type u_1} {β : Type u_2} [has_mul α] [has_mul β] (f : α → β) : Prop
{R : Type u} [ring R] (S : subring R) (s : set R) (hs : s = ↑S) : subring R
(R : Type u_1) (A : Type u_2) [comm_semiring R] [semiring A] [algebra R A] : Prop
{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) [invertible A.det] : invertible A
(α : Type u_2) [fintype α] [nonempty α] [linear_order α] : complete_linear_order α
(τ : Type u_1) [topological_space τ] [add_monoid τ] [has_continuous_add τ] (α : Type u_2) [topological_space α] : Type (max u_1 u_2)
{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : 1 ≤ a⁻¹ → a ≤ 1
(R : Type u_1) [semiring R] : Prop
(G : Type u) : Type u
{α : Type u_1} {M : Type u_4} [has_zero M] {s : set α} {f : α → M} {a : α} (h : s.indicator f a ≠ 0) : a ∈ s
{n : ℕ} {F : typevec n → Type u_1} [mvfunctor F] (q : mvqpf F) : Prop
{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → α → α
{K {C : Type u_1} [category_theory.category C] (X : C) : Prop
(α : Type u_6) (β : Type u_7) [has_bot α] [has_bot β] : Type (max u_6 u_7)
(R : Type u_1) (A : Type u_3) [comm_ring R] [ring A] [algebra R A] : Prop
{α : Type u_2} [has_add α] : has_add (filter α)
{α : Type u_1} (r : α → α → Prop) (s : set α) : set α
(α : Type u_1) : Type u_1
(p : Prop) : Type
{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → finset.Ioc a b = ∅
(obj : Type u) : Type (max u (v+1))
{α : Type u} {β : Type v} (l : filter α) (f g : α → β) : Prop
{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : b < a⁻¹ * c → a * b < c
{α : Type u_1} {s t : set α} : disjoint s t → disjoint (filter.principal s) (filter.principal t)
{α : Type u_1} [preorder α] [succ_order α] : α → α
{α : Type u} : lazy_list α → thunk (lazy_list α) → lazy_list α
{α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] (f : α → β) : Prop
(α : Type u) [topological_space α] : measurable_space α
{R : Type u_1} [mul_one_class R] : is_regular 1
{α : Type u_1} {n : Type u_3} (A : matrix n n α) : Prop
(α : Type u) : Type u
{M : Type u_1} [add_zero_class M] (s : set M) : add_submonoid M
{C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] (j j' : C) : C
{M : Type u_1} {P : Type u_3} [has_add M] [has_add P] (f : M → P) (h : ∀ (x y : M), f (x + y) = f x + f y) : add_con M
(n : name) : bool
{α : Type u_1} {a : α} {z : sym2 α} (h : a ∈ z) : α
{α : Type u} {β : Type v} (g : β → α) (f : α → β) (s : set α) (t : set β) : Prop
{M : Type u_3} {N : Type u_4} {P : Type u_5} [has_one M] [has_one N] [has_one P] (hnp : one_hom N P) (hmn : one_hom M N) : one_hom M P
{C : Type u} [category_theory.category C] (P Q : C) [category_theory.limits.has_binary_product P Q] : category_theory.limits.has_binary_product Q P
{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] [add_monoid β] [has_lipschitz_add β] : has_add (bounded_continuous_function α β)
 : Type (u+1)
{α : Type u} : fin 0 → α
{α : Type u_1} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} (g : α → β → γ → δ) (s : set α) (t : set β) (u : set γ) : set δ
{α : Type u_1} {m n : ℕ} (v : vector3 α m) (w : vector3 α n) : vector3 α (n + m)
 : Type
 : num → num
{X : Type u_1} [topological_space X] [compact_space X] {Y : Type u_2} [topological_space Y] : is_closed_map prod.snd
{α : Type u} {β : Type v} (f : ℕ → α → β → α) (start : ℕ) (a : α) (bs : list β) : α
{n : ℕ} : is_prime_pow n ↔ ∃! (p : ℕ), nat.prime p ∧ p ∣ n
{α : Type u} (x : α) : function.is_fixed_pt id x
{α : Type u_3} {β : Type u_4} [lattice α] [lattice β] [bounded_order α] [bounded_order β] (f : bounded_lattice_hom α β) : sup_bot_hom α β
 : ℕ → snum → bool
{α : Type u_1} (f : α → α) (n : ℕ) (x : α) : Prop
{γ : Type w} [metric_space γ] {x y : γ} : has_nndist.nndist x y = 0 ↔ x = y
{K : Type u} [field K] (s : subfield K) (m : multiset K) : (∀ (a : K), a ∈ m → a ∈ s) → m.prod ∈ s
{α : Type u_1} (m : α → α → α) : list α → list α → list α
{R : Type u_1} [semiring R] : algebra ℕ R
{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : 0 < a - b → b < a
(p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_sym p (a ^ 2) = 1
(α : Type u_2) [cancel_comm_monoid_with_zero α] : Prop
(o : ordinal) : Well_order
{α : Type u_1} (l : list α) : list (list α)
(G : Type u_1) [monoid G] (L : Type u_2) [comm_ring L] [no_zero_divisors L] : linear_independent L (λ (f : G →* L), ⇑f)
{α : Type u_1} [decidable_eq α] (s t : multiset α) : multiset α
(p : ℕ) {R : Type u_1} [comm_ring R] (r : R) : witt_vector p R
(C : Type u) [category_theory.category C] : Type (max u (v+1))
{R : Type u} [euclidean_domain R] [decidable_eq R] : R → R → R
(α : Type u_1) : local_equiv α α
{α : Type} (p : parser α) : Prop
{α : Type u_1} [nontrivial α] : nonempty α
(S : Type u_4) (M : out_param (Type u_5)) [has_zero M] [set_like S M] : Type
{n : ℕ} (x : bitvec n) (i : ℕ) (fill : bool) : bitvec n
{α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M} : finprod (λ (i : α), finprod (λ (H : i ∈ ∅), f i)) = 1
{ι : Type u_1} (G : ι → Type u_2) [Π (i : ι), group (G i)] [hG : Π (i : ι), is_free_group (G i)] : is_free_group (free_product G)
{M : Type u_1} [add_monoid M] {s : set M} (h : is_add_submonoid s) : add_submonoid M
{α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] : filter.tendsto (λ (x : α), x⁻¹) (nhds_within 0 (set.Ioi 0)) filter.at_top
(R : Type u) (n : ℕ) [comm_semiring R] (A : Type u_1) [semiring A] [algebra R A] : multilinear_map R (λ (i : fin n), A) A
(α : Type u) : Type u
{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {g : β → γ} (hg : function.injective g) : function.injective (function.comp g)
{α : Type u_1} [inhabited α] : option α → α
 : has_sizeof ℤ
{α : Sort u} {β : Sort v} {f : α → β} (hf : function.injective f) [subsingleton β] : subsingleton α
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (λ (_x : P), _x -ᵥ p)
{α : Type u} {β : Type v} (a : ulift α) (f : α → ulift β) : ulift β
{α : Type u_1} [preorder α] {a b : α} (h : a < b) : ¬is_max a
{α : Type u} : α → lazy_list α
(p : Prop) : Type
{α : Type u} (S : set (α → ℕ)) : Prop
{A : Type u_1} (K : Type u_2) [comm_ring A] (S : submonoid A) (hS : S ≤ non_zero_divisors A) [field K] [algebra A K] [is_fraction_ring A K] : subalgebra A K
{α : Type u} (s : stream α) : stream α
(α : Type u_1) [distrib_lattice α] : DistribLattice
(G : Type u) [topological_space G] [has_inv G] : Prop
(α : Type u_1) : Type u_1
{n : ℕ} : order_of (quaternion_group.a 1) = 2 * n
{α : Type u_1} [monoid α] (s : multiset α) (comm : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → commute x y) : α
(F : Type u_8) (α : out_param (Type u_9)) (β : out_param (Type u_10)) [complete_lattice α] [complete_lattice β] : Type (max u_10 u_8 u_9)
{α : Sort u_1} {a : α} : α
 : Type (u+1)
{α : Type u_1} {β : Type u_2} (f : α → β) (o : part α) : part β
{n : ℕ} (x y : bitvec n) : Prop
{C : Type u} [category_theory.category C] [category_theory.abelian C] : category_theory.limits.has_pushouts C
{n : Type u_3} {α : Type v} [decidable_eq n] [has_zero α] (d : n → α) : matrix n n α
{α : Type u_1} : set (α × α)
{α : Type u} : pos_num → tree α → option α
{α : Type u} [semilattice_sup α] [nonempty α] (s : finset α) : bdd_above ↑s
{X : Type u_1} (point : X) : Pointed
{α : Type u_1} : vector3 α 0
{α : Type u_1} : list α → list ℕ → list (list α) × list α
{G : Type u_1} [group G] (S : set G) : set (set G)
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J → C) : Type (max u v)
(F : Type u_7) (α : out_param (Type u_8)) (β : out_param (Type u_9)) [lattice α] [lattice β] : Type (max u_7 u_8 u_9)
 : Type
(R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] (x : A) : Prop
{R : Type u} [ring R] (S : set R) : Prop
 : path 0 1
{α : Sort u_1} (x : α) (h : ∀ (y : α), y = x) : subsingleton α
{G : Type u_1} [group G] (H K : subgroup G) : ℕ
{S : Type u_2} [linear_ordered_ring S] : absolute_value S S
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x : L} : x ∈ S → x⁻¹ ∈ S
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 ≤ b) : 1 < a * b
(R : Type u) [has_star R] : Prop
{K : Type v} [field K] (f : polynomial K) : polynomial (adjoin_root f.factor)
(A : Type u) : Type u
(α : Type u) : Type u
 : Type
{R : Type u} [comm_ring R] (x : prime_spectrum R) : ideal R
{α : Type u} {β : Type v} : α ⊕ β → bool
{M : Type u_1} [add_monoid M] {s₁ s₂ : set M} (is₁ : is_add_submonoid s₁) (is₂ : is_add_submon{α : Sort u_1} {s₁ : setoid α} (a : quotient s₁) : α
(f : ℕ → nnreal) : filter.tendsto (λ (i : ℕ), ∑' (k : ℕ), f (k + i)) filter.at_top (nhds 0)
(F : Type u → Type w) (G : Type v → Type u) (α : Type v) : Type w
(α : Type u) [ring α] : Type u
{α : Sort u} (r : α → α → Prop) : Prop
(α : Type u) [has_le α] : Type u
(g : Type) (α : Type u) : Type u
{R : Type u_1} [add_left_cancel_semigroup R] (g : R) : is_add_left_regular g
{M : Type u_1} [has_mul M] (s : set M) : subsemigroup M
{α : Type u_1} {β : Type u_2} (f : list α → α → list α → β) (l : list α) : list β
(u : Set) : set Set
{X : Top} (T : Top) : Top.sheaf (Type v) X
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)
 : znum → znum → ordering
{α : Type u} (a : α) : stream α
(Γ : Type u_1) [inhabited Γ] : setoid (list Γ)
(α : Type u_1) [nonempty α] [fintype α] : trunc α
{α : Type u_1} (p : α → Prop) [decidable_pred p] (l : list α) (hp : ∃ (a : α), a ∈ l ∧ p a) : α
{C : Type u} [category_theory.category C] [category_theory.abelian C] (P : C) : setoid (category_theory.over P)
 : Type → Type
{α : Type u} {β : α → Type v} [decidable_eq α] {δ : Type w} (m : hash_map α β) (d : δ) (f : δ → Π (a : α), β a → δ) : δ
{α : Type u} [linear_order α] {a b c : α} : set.interval a c ⊆ set.interval a b ∪ set.interval b c
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0
{α : Type u_1} [fintype α] [field α] : is_prime_pow (fintype.card α)
 : pSet
 : ℕ → list ℕ
{α : Type u_2} [subtraction_comm_monoid α] : subtraction_comm_monoid (filter α)
 : Type
{G : Type u_3} [group G] : group.fg G ↔ monoid.fg G
(R : Type u) (M : Type v) (M₂ : Type w) [semiring R] [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module R M₂] : submodule R (M × M₂)
 : Type
(R : Type u_8) (S : Type u_9) [comm_ring R] [ring S] [algebra R S] : Type (max u_8 u_9)
(R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] : free_add_monoid (M × N) → free_add_monoid (M × N) → Prop
{α : Type u_1} [preorder α] [order_bot α] (a : α) : Prop
 : Type
{α : Type u} : wseq α
(α : Type u_1) [has_one α] : Type u_1
(R : Type u) (K : Type v) [comm_ring R] [field K] [algebra R K] [no_zero_smul_divisors R K] : Prop
{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : 0 < -a → a < 0
{m : Type v → Type w} [applicative m] {α : Type u_1} {β : Type v} (f : ℕ → α → m β) (as : list α) : m (list β)
{n : ℕ} : bitvec n → ℤ
{α : Type} (m : ℕ) (a : α) (v : ℕ → α) : ℕ → α
{p : ℕ → Prop} [decidable_pred p] (H : ∃ (n : ℕ), p n) : ℕ
{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.snd
(𝕜 : Type u_1) (ι : Type u_5) [ordered_semiring 𝕜] [fintype ι] : set (ι → 𝕜)
{α : Type u_2} [has_zero α] : has_zero (set α)
 : filter.tendsto (λ (x : ℝ), x ^ (1 / x)) filter.at_top (nhds 1)
 : turing.to_partrec.cont → list (list ℕ)
(A : Type u) [add_group A] : Type u
{R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : polynomial R
(α : Type u) (r : α → α → Prop) : Prop
 : parser unit
{𝕜 : Type u_1} [linear_ordered_field 𝕜] [topological_space 𝕜] [order_topology 𝕜] {s : set 𝕜} : strict_convex 𝕜 s ↔ convex 𝕜 s
(α : Type u) : Type u
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_terminal C] : category_theory.limits.has_finite_products C
 : category_theory.limits.has_limits_of_size AddCommMon
{R : Type u_1} [comm_ring R] {M : submonoid R} (z : localization M) : localization M
{α : Type u_1} [semiring α] (b : α) : list ℕ → α
(G : Type u_1) [comm_monoid G] : submonoid G
 : Type
(op : ordinal → ordinal → ordinal) (o : ordinal) : Prop
{α : Type u} (s : wseq α) : wseq α
{α : Type u} [preorder α] {a b : α} : a ≤ b → ¬b ≤ a → a < b
{α : Type u_1} {E : Type u_2} [linear_order E] [has_zero E] [measurable_space α] (f : measure_theory.simple_func α E) : measure_theory.simple_func α E
{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A B : matrix n n α) (h : A.mul B = 1) : invertible A.det
(M : Type u_1) (α : Type u_2) [add_monoid M] [topological_space α] [add_action M α] : Prop
{α : Type u_1} (r : α → α → Prop) (c : cycle α) : Prop
(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom B (A × B)
{β : Type v} {γ : Type w} [emetric_space γ] [emetric_space β] : emetric_space (γ × β)
(X : Type u_1) [has_mul X] [has_zero X] [has_lt X] [has_le X] : Prop
{α : Type u} [decidable_eq α] (i j : α) : function.involutive (λ (_x : equiv.perm α), _x * equiv.swap i j)
 : Type
(α : Type u) [pseudo_metric_space α] : setoid α
 : Type
 : Type
{G : Type u_1} [has_one G] [has_mul G] [has_inv G] : list G → G
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) : Prop
(A : Type u_2) [add_group A] : Prop
 : has_le many_one_degree
{ι : Type u_1} {α : Type u_3} [preorder ι] [linear_order α] {u : ι → α} (h : monotone u) (H : ¬bdd_below (set.range u)) : filter.tendsto u filter.at_bot filter.at_bot
{α : Type u} (a : α) : stream α
{R : Type u} [comm_semiring R] (x y : R) : Prop
{α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v a : α) : α
{α : Type u} [non_unital_non_assoc_ring α] (k : α) (h : ∀ (x : α), x * k = 0 → x = 0) : is_right_regular k
{α : Type u_2} [has_zero α] : has_zero (filter α)
{α : Type u_1} [preorder α] [order_bot α] [locally_finite_order α] (b : α) : finset α
{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_btw.btw a b c) : has_btw.btw c a b
 : category_theory.limits.has_limits_of_size CommSemiRing
{α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] (h : a - c < b - c) : a < b
{n : ℕ} (i : fin n) : equiv.perm (fin n)
(F : pfunctor) : Type u
{V : Type u} (G : simple_graph V) : setoid V
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (X : algebraic_geometry.SheafedSpace C) : Top.sheaf C ↑X
{α : Type u} [topological_space α] [locally_compact_space α] [t2_space α] (x : α) : ∃ (U : set α), is_open U ∧ x ∈ U ∧ is_compact (closure U)
{n : ℕ} : arity pSet n → arity pSet n → Prop
{C : Type u} [category_theory.category C] (𝒢 : set C) : Prop
(α : Type u) [group α] : Type u
{L : first_order.language} (M : Type w) [L.Structure M] (T : L.Theory) : Prop
{α : Type u_1} [has_one α] : has_coe (simple_continued_fraction α) (generalized_continued_fraction α)
{K : Type u_2} [division_ring K] (aₙ bₙ ppredB predB : K) : K
{G : Type u_1} {P : Type u_2} [add_group G] [add_torsor G P] (x : P) : equiv.perm P
(C : Type u) [category_theory.category C] : Type (max u (v+1))
 : filter.tendsto real.log filter.at_top filter.at_top
(α : Sort u) : Type u
{α : Type u_1} [topological_space α] (x : α) (S : set α) : Prop
{R : Type u_1} [comm_ring R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) [is_domain R] : unique_factorization_monoid R
 : ereal → ereal
{α : Type u_1} {β : Type u_2} (s : multiset α) (f : α → multiset β) : multiset β
(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] : Type (max u v)
{m : Type u → Type u_1} [monad m] {α : Type u} {n : ℕ} : (fin n → m α) → m (vector α n)
(R : Type u_1) : Type u_1
(a b : snum) : snum
{M : Type u_3} {N : Type u_4} [has_add M] [add_zero_class N] : has_zero (add_hom M N)
{α : Type u_1} {p : α → Prop} (s : finset {x // p x}) {a : α} (h : ¬p a) : a ∉ finset.map (function.embedding.subtype (λ (x : α), p x)) s
{p : ℕ} [p_prime : fact (nat.prime p)] {b : ℕ} (dvd : p ∣ b) : padic_val_nat p (b / p) = padic_val_nat p b - 1
(a b : ℕ) : ℕ
{α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [semiring α] [add_group β] (h : function.antiperiodic f c) : function.periodic f (2 * c)
 : ℕ
(n : ℕ) : Type (u+1)
{G : Type u_1} [group G] (s : set G) : set G
{α : Type u_1} [β : normed_division_ring α] : normed_ring α
{n : ℕ} (x y : bitvec n) : Prop
(S : Type u_4) (M : out_param (Type u_5)) [has_one M] [set_like S M] : Type
{M : Type u_1} [monoid M] {ι : Sort u_2} {s : ι → set M} (h : ∀ (y : ι), is_submonoid (s y)) : is_submonoid (set.Inter s)
{α : Type u_1} {β : Type u_2} [cancel_comm_monoid_with_zero α] [normalized_gcd_monoid α] (s : finset β) (f : β → α) : α
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (s : add_subsemigroup M) (t : add_subsemigroup N) : add_subsemigroup (M × N)
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : M) : same_ray R x x
{α : Type u} : α × list α × α × list α → α × list α × α × list α
{α : Type u_1} : subsingleton (option α) ↔ is_empty α
{G : Type u_1} [add_group G] (T : set G) : set (set G)
{ι : Type u_1} (f g : ι → cardinal) (H : ∀ (i : ι), f i < g i) : cardinal.sum f < cardinal.prod g
(α : Type u_1) [encodable α] (n : ℕ) : option α
(R : Type u_1) (A : Type u_2) [semiring R] [star_semigroup R] [has_trivial_star R] [add_comm_group A] [module R A] [star_add_monoid A] [star_module R A] : submodule R A
{α : Type u_1} [topological_space α] [semiring α] [topological_semiring α] (s : subsemiring α) : subsemiring α
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
(α : Type u_6) : Type u_6
(M : Type u_1) [add_monoid M] : add_action M M
 : snum → Π (n : ℕ), vector bool n
{n : ℕ} (p : fin n → Prop) [decidable_pred p] : option (fin n)
{α : Type u} (i : ℕ) (t : ordnode α) : ordnode α
{R : Type u_1} [rack R] {x y z : R} : shelf.act x (shelf.act y z) = shelf.act (shelf.act x y) z ↔ shelf.act x z = z
{α : Sort u_1} {β : Sort u_2} (a : erased α) (f : α → erased β) : erased β
 : fact (1 ≤ 2)
(R : Type u) [comm_ring R] : Type u
{A : Type u_2} [add_monoid A] (s : set A) : Prop
{n : ℕ} (x y : bitvec n) : Prop
{R : Type u} [comm_semiring R] [star_ring R] : ring_hom_inv_pair (star_ring_end R) (star_ring_end R)
{a : Prop} : ¬¬a ↔ a
(α : Type u) : Type u
{α : Type u_1} [boolean_ring α] : has_sup α
(α : Type u) [t : topological_space α] [topological_space.separable_space α] [nonempty α] : ∃ (u : ℕ → α), dense_range u
(α : Type u_1) [topological_space α] : Type u_1
{α : Type u} [pseudo_metric_space α] : pseudo_emetric_space α
{α : Type u_1} {β : Type u_2} (f : α → β) : setoid α
{α : Type u_2} [decidable_eq α] [division_monoid α] : division_monoid (finset α)
{α : Type u} {β : Type v} [topological_space α] [preorder β] (f : α → β) (a : α) : Prop
{α : Type u_1} [measurable_space α] (f : α → ennreal) (n : ℕ) : measure_theory.simple_func α nnreal
{G : Type u} [group G] {x : G} : is_of_fin_order x⁻¹ ↔ is_of_fin_order x
(M : Type u_10) (α : Type u_11) [has_vadd M α] : Prop
(𝕆 : Type u_5) (α : Type u_6) [preorder 𝕆] [preorder α] : Type (max u_5 u_6)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.has_initial C
{α : Type u_1} {M : Type u_5} [has_zero M] (a : α) : function.injective (finsupp.single a)
{R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] : unique_factorization_monoid R
{α : Type u_1} [linear_ordered_field α] [floor_ring α] (x : α) : ℤ
{α : Type u_2} [decidable_eq α] [add_comm_semigroup α] : add_comm_semigroup (finset α)
(α : Type u_2) [has_bot α] : bot_hom α α
{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] : ratfunc K → ratfunc K
(R : Type u) [comm_ring R] : Type u
(R : Type u_1) {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (s : set M) : submodule R M
{n m : ℕ} (P : mvpfunctor n) (Q : fin2 n → mvpfunctor m) : mvpfunctor m
(𝕜 : Type u_1) {A : Type u_2} [normed_field 𝕜] [ring A] [algebra 𝕜 A] (a : A) : ennreal
{α : Type u} {β : α → Type v} [decidable_eq α] (m : hash_map α β) : list (Σ (a : α), β a)
{α : Type u_1} {β : Type u_2} (r : setoid α) (s : setoid β) : setoid (α × β)
(R : Type u_3) [comm_ring R] : Prop
(β : Type u_1) (γ : Type u_2) [measurable_space β] [measurable_space γ] [has_pow β γ] : Type
(f : turing.to_partrec.code) : turing.to_partrec.code
(n : ℕ) : ℕ
(M : Type u) : Type u
{n : ℕ} {α : fin n → Type u} (a : d_array n α) (i : fin n) (v : α i) : d_array n α
 : Type
{α : Type u} {β : Type v} [has_mul β] (f : α → β) : free_magma α → β
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) (x : α) : Prop
 : onote → onote × ℕ
{α : Type u_1} {β : Type u_2} [decidable_eq β] [fintype (α × β)] [nonempty α] : fintype β
{α : Type u} [preorder α] {s : set α} : ¬bdd_above s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), ¬y ≤ x
(J : Type u₁) [category_theory.category J] (C : Type u) [category_theory.category C] : Prop
(M : Type u_9) (N : Type u_10) [mul_zero_one_class M] [mul_zero_one_class N] : Type (max u_10 u_9)
{x y z : ℤ} : pythagorean_triple x y z ↔ pythagorean_triple y x z
{R : Type u} [semiring R] : polynomial R → finset ℕ
(α : Type u_6) : Type u_6
(α : Type u_6) [measurable_space α] : Type u_6
(C : Type u_1) [category_theory.category C] : Prop
{α : Type u} [topological_space α] [compact_space α] [discrete_topology α] : fintype α
 : comm_ring (clifford_algebra clifford_algebra_complex.Q)
{α : Type u_1} {β : Type u_2} (f : α → β) (m : pseudo_emetric_space β) : pseudo_emetric_space α
{α : Type u} (t s s' : set α) : set α
(n : ℕ) : list (ℕ × ℕ)
{α : Type u_1} (f : filter α) : Type (max u_1 (u_5+1))
{m : Type u_1} {n : Type u_2} {K : Type u_4} [fintype n] [decidable_eq n] [field K] (A : matrix m n K) : ℕ
 : Type
{P : ℕ → Prop} {m : ℕ} (h0 : P m) (h1 : ∀ (n : ℕ), m ≤ n → P n → P (n + 1)) (n : ℕ) : m ≤ n → P n
{α : Type u_1} [complete_lattice α] (s : set α) : Prop
(α : Type u_3) [topological_space α] : Prop
{M : Type u_1} {N : Type u_2} {α : Type u_6} [has_vadd M α] (g : N → M) (n : N) (a : α) : α
(C : Type u) [category_theory.category C] : Prop
{G : Type u} [add_group G] {x : G} : is_of_fin_add_order (-x) ↔ is_of_fin_add_order x
(R : Type u) (M : Type v) [ring R] [add_comm_group M] [module R M] [module.free R M] [nontrivial R] [module.finite R M] : fintype (module.free.choose_basis_index R M)
{α : Type u} [pseudo_metric_space α] (s : set α) : continuous (λ (x : α), metric.inf_dist x s)
{α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : measurable_space.comap f m₂ ≤ m₁ → measurable f
{α : Type u} {a b : α} [mul_zero_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a * b
{G : Type u_1} [add_group G] (S : set G) : set (set G)
 : Type (u_1+1)
{α : Type u} (s : wseq α) (p : α → bool) : computation bool
(α : Type u_1) [monoid α] : Type u_1
{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] : module (module.End R M) M
 : filter.tendsto (λ (N : ℕ), formal_multilinear_series.comp_partial_sum_target 0 N N) filter.at_top filter.at_top
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_presentation R A → algebra.finite_type R A
{α : Type u_1} {β : Type u_2} [semilattice_inf α] [order_top α] (s : finset β) (f : β → α) : α
{n : ℕ} {a b : fin n} : ↑a < ↑b ↔ a < b
(α : Type u_1) [fintype α] : encodable α
(M : Type u_1) {α : Type u_2} [add_group M] [add_action M α] (s : set α) : add_subgroup M
{γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), y * x)
 : pSet → pSet → pSet
{R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J J₃ : matrix n n R₃) [decidable_eq n] : submodule R₃ (matrix n n R₃)
{α : Type u_1} (r : α → α → Prop) (a : α) : α → Prop
{C : Type u₁} [category_theory.category C] {X : C} : complete_lattice (category_theory.sieve X)
{R : Type u} [ring R] (s : subring R) {x : R} : x ∈ s → -x ∈ s
(n : ℕ) : nonote
{α : Type u_1} {β : Type u_2} {n : ℕ} (f : α → β) (x : sym α n) : sym β n
 : Type
(α : Type u_1) [fintype α] [category_theory.small_category α] [category_theory.fin_category α] : Type
{F : pfunctor} (x : F.M) : F.A
{α : Type u} [partial_order α] {a b : α} : a ≤ b → a < b ∨ a = b
{H : Type u} [topological_space H] : order_bot (structure_groupoid H)
(α : Type u_1) : Type u_1
{X : Type u_1} [topological_space X] [normal_space X] (c : urysohns.CU X) : urysohns.CU X
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α] (a : α) : continuous (λ (f : C(α, β)), ⇑f a)
{n : ℕ} {A : Type u} (F : A → typevec n → Type u) (v : typevec n) : Type u
(K : Type u) [comm_ring K] (p : ℕ) [fact (nat.prime p)] [char_p K p] : ℕ × K → ℕ × K → Prop
{n : ℕ} (x y : bitvec n) : Prop
(X : algebraic_geometry.Scheme) : Prop
(R : Type u_1) [has_mul R] [has_add R] : Type
{R : Type u} [ring R] {Γ₀ : Type v} [linear_ordered_comm_group_with_zero Γ₀] (v : valuation R Γ₀) : valued R Γ₀
(G : Type u_1) [add_monoid G] : Prop
{α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α] : order.pred a < order.pred b → a < b
{α : Type u_1} [cancel_monoid_with_zero α] {a b c : α} (ha : a ≠ 0) : a * b ∣ a * c ↔ b ∣ c
(cs : list char) : parser char
{α : Type u_2} [semigroup α] : semigroup (filter α)
(M : Type u_1) (N : Type u_2) (α : Type u_3) [has_vadd M α] [has_vadd N α] [vadd_comm_class M N α] : vadd_comm_class N M α
{C : Type u} [category_theory.category C] [category_theory.enough_projectives C] (X : C) : C
{α : Type u} : ordnode α → ℕ
 : has_mul pgame
(α : Type u_2) (β : Type u_3) (r : α → β → Prop) : Type (max u_2 u_3)
{α : Type u} [cancel_monoid_with_zero α] [nontrivial α] : has_faithful_smul α α
{α : Type u} [has_le α] (x : α) : ordnode α → Prop
(obj : Type u) : Type (max u (v+1))
(α : Type u) : Type u
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) : add_hom (with_top M) (with_top N)
{α : Type u_1} {p : α → Prop} (s : finset {x // p x}) {a : α} (h : a ∈ finset.map (function.embedding.subtype (λ (x : α), p x)) s) : p a
{α : Type u_2} [decidable_eq α] [comm_semigroup α] : comm_semigroup (finset α)
(α : Type u_1) [complete_lattice α] : CompleteLattice
{α : Type u_1} {β : Type u_2} (f : ℕ → α → β → α) (a : α) (l : list β) : α
{M : Type u_1} {R : Type u_2} [monoid M] [ring R] [mul_semiring_action M R] : mul_action M (subring R)
{α : Type u} {β : Sort u_1} (z : β) (f : β → α → β → β) : ordnode α → β
(α : Type u_3) [has_inf α] [has_top α] : inf_top_hom α α
{R : Type u_1} (f : ℕ → R) : power_series R
{α : Type u} (a : α) : seq1 α
 : Type
{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → ordnode α × option α × ordnode α
{M : Type u_1} [has_mul M] {S T : subsemigroup M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T) : S = T
{α : Type u_1} {β : Type u_2} (rα : α → α → Prop) (rβ : β → β → Prop) : α × β → α × β → Prop
{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order β] [preorder α] [bounded_order α] (gi : galois_insertion l u) : bounded_order β
{Γ : Type u_1} [inhabited Γ] : list Γ → turing.list_blank Γ
(α : Type u_1) : Type u_1
{α : Type u_1} [comm_monoid α] (a b u : α) (hu : is_unit u) : a ∣ u * b ↔ a ∣ b
(x y : nonote) : nonote
{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (a0 : 0 < a) : 1 ≤ a * b
{α : Type u} {β : α → Type v} [decidable_eq α] (l : list (Σ (a : α), β a)) (m : hash_map α β) : hash_map α β
(n : ℕ) : pos_num
{R : Type v} [comm_ring R] {o : Type u_1} (M : matrix o o R) {n : ℕ} (b : o → fin n) : Prop
(α : Type u_1) (r s : α → α → Prop) : Type
{α : Type u} [topological_space α] {s t : set α} (hs : dense s) (ht : dense t) (hso : is_open s) : dense (s ∩ t)
(α : Type u_2) [fintype α] [linear_order α] [bounded_order α] : complete_linear_order α
{H : Type u} [topological_space H] {α : Type u_5} [topological_space α] [nonempty α] {f : α → H} (h : open_embedding f) : charted_space H α
(X : Type u) : Type u
{X : Type u_1} (to_two_pointing : two_pointing X) : Twop
 : has_one onote
{α : Type u_1} {n : ℕ} : has_lift (vector α n) (sym α n)
(V : Type u) [quiver V] : Sort (max (u+1) v)
{M : Type u} [has_add M] (a x y : M) : Prop
(α : Type u) : category_theory.sieve α
{n : ℕ} (c : composition n) : fin c.length → ℕ
{α : Type u_1} {β : Type u_2} [preorder β] [decidable_rel has_lt.lt] (f : α → β) (l : list α) : option α
{G : Type u_1} [group G] (H K : set G) : setoid G
(o : ordinal) : Prop
{M : Type u} [add_zero_class M] (a : M) : add_semiconj_by a 0 0
{α : Type u} (P : α → Prop) [decidable_pred P] : list α → list α → list (list α)
{α : Type u} (f : α → α) : set α
(α : Sort u) : Sort u
(R : Type u_1) : Type u_1
{b : Prop} (a : Prop) (h : a ↔ b) [D : decidable a] : decidable b
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (a : R) : submodule R M
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] (g : β → γ) (f : measure_theory.simple_func α β) : measure_theory.simple_func α γ
{α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (a0 : 0 ≤ a) : 1 ≤ a * b
{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) : Prop
{C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) (X : C) : closure_operator (category_theory.sieve X)
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a + b
(α : Type u) : Type u
{α : Type u} : list α → list (list α)
(M : Type u_10) (A : Type u_11) [monoid M] [monoid A] : Type (max u_10 u_11)
{X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] (C r : nnreal) (f : X → Y) : Prop
{M : Type u_1} [mul_one_class M] (S : submonoid M) : 1 ∈ S
{M : Type u_1} [add_zero_class M] (S : add_submonoid M) (s : set M) (hs : s = ↑S) : add_submonoid M
{α : Type u_1} [comm_semiring α] (t : tree α) (r₁ r₂ : tactic.ring2.csring_expr) (H : tactic.ring2.horner_expr.of_csexpr r₁ = tactic.ring2.horner_expr.of_csexpr r₂) : tactic.ring2.csring_expr.eval t r₁ = tactic.ring2.csring_expr.eval t r₂
{G : Type u_1} [group G] (H : subgroup G) : subgroup (conj_act G)
{α : Type u} {β : Type v} {γ : Type w} (f : α → β) : α ⊕ γ → β ⊕ γ
{η : Type u_2} [fintype η] {Gs : η → Type u_3} [Π (i : η), group (Gs i)] [∀ (i : η), group.is_nilpotent (Gs i)] : group.is_nilpotent (Π (i : η), Gs i)
(M : Type u) : Type u
{R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) : discrete_valuation_ring R
(G : Type u_1) [monoid G] : Prop
(α : Type u_1) [order.frame α] : Locale
{R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2) : 2 ≠ 0
(C : Type u) [category_theory.category C] : Prop
(α : Type u) : Type u
{R : Type u_1} [has_zero R] (n : R) : Prop
(α : Type u_2) : Type u_2
{n : ℕ} (x y : bitvec n) : Prop
{α : Type u_1} {n : ℕ} (f : fin n → α) (i : ℕ) : option α
(S : Type u) [semiring S] : ℕ → polynomial S
{n : ℕ} (x y : bitvec n) : bitvec n
{α : Type u_1} : α → list α → α
(A : Type u_2) : Type u_2
{α : Type u} (f : fin 0 → α) : list.of_fn f = list.nil
{M : Type w} (A : set M) (L : first_order.language) [L.Structure M] (s : set M) : Prop
(α : Type u_5) : Type u_5
{α : Type u_1} [comm_monoid α] (a b u : α) (hu : is_unit u) : u * a ∣ b ↔ a ∣ b
(α : Sort u) [has_variable_names α] {β : Sort v} : has_variable_names β
{α : Type} (seed : ℕ) (cmd : rand α) : io α
 : Type
 : bool → bool → bool
{G : Type u_1} [add_group G] {H K : add_subgroup G} (h : ∀ (x : G), x ∈ H ↔ x ∈ K) : H = K
 : ¬summable (λ (n : ℕ), (↑n)⁻¹)
{C : Type u₁} [category_theory.category C] {X : C} (t : category_theory.limits.is_initial X) : category_theory.limits.is_terminal (opposite.op X)
{F : pfunctor} : ℕ → F.M → F.M → Prop
(R : Type u) [semiring R] (p q : ℕ) [hp : char_p R p] [hq : exp_char R q] : p = q ↔ nat.prime p
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) [is_simple_order (category_theory.subobject X)] : category_theory.simple X
 : game → game → Prop
{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] : has_faithful_smul (module.End R M) M
{α : Type u_2} [add_monoid α] : add_monoid (set α)
(R : Type u_1) (K : Type u_2) [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] : Type u_2
{A : Type u_2} [add_group A] (a : A) : add_subgroup A
(A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] : field K
(p : ℕ) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] [is_domain k] [char_p k p] [perfect_ring k p] (V : Type u_2) [add_comm_group V] : Type (max u_1 u_2)
{α : Type u} (l : ordnode α) (x : α) (r : ordnode α) : ordnode α
(C : Type u) [𝒞 : category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_pushouts C
{α : Type u_1} {β : Type u_2} [group α] [comm_group β] {f : α → β} (hf : is_group_hom f) : is_group_hom (λ (a : α), (f a)⁻¹)
{R : Type u_1} [ring R] {M : Type u_2} [topological_space M] [add_comm_group M] [module R M] (p : submodule R M) : Prop
{α : Type u_1} (f : α → α) (x : α) : ℕ
(α : Type u) : Type u
{R : Type u_8} [ordered_semiring R] [nontrivial R] (l : list R) (h : ∀ (a : R), a ∈ l → 0 < a) : 0 < l.prod
{A : Type v} [ring A] {M : Type w} [add_comm_group M] [module A M] : lie_ring_module A M
{α : Type u_1} [ring α] : partial_order (ring_topology α)
{α : Type u} {β : Type v} [preorder β] (f : α → β) (s : set α) (a : α) : Prop
(F : Type u_8) (α : out_param (Type u_9)) (β : out_param (Type u_10)) [has_Inf α] [has_Inf β] : Type (max u_10 u_8 u_9)
{α : Type u} [primcodable α] [inhabited α] (p : α → Prop) : many_one_degree
{G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 ∈ interior ↑H) : is_open ↑H
(E : Type u_8) [comm_group E] [topological_space E] [topological_group E] : continuous_monoid_hom (E × E) E
(n : snum) : snum
(E : Type u_8) [add_comm_group E] [topological_space E] [topological_add_group E] : continuous_add_monoid_hom (E × E) E
{X : Type u_1} {α : Type u_2} [has_one α] [topological_space X] (f : X → α) : set X
{R : Type u} [linear_order R] : has_add (tropical R)
(x : Set) : Class
(C : Type u) [category_theory.category C] [category_theory.limits.has_limits C] : category_theory.limits.has_finite_limits C
{α : Type u} : ordnode α → ordnode α
{α : Type u} {β : Type v} {γ : Type w} [inhabited α] [inhabited β] (f : α → β → γ) : list α → list β → list γ
{α : Type u} [topological_space α] {s : set α} : is_compact s → ∀ (f : ultrafilter α), ↑f ≤ filter.principal s → (∃ (a : α) (H : a ∈ s), ↑f ≤ nhds a)
(n : ℕ) : Type
{α : Type u_1} [comm_semiring α] : linear_recurrence α
{α : Type u} (f : α → Type (max u v)) : ¬function.surjective f
{ι : Type u_1} {α : ι → Type u_3} [fintype ι] (m : Π (i : ι), measure_theory.outer_measure (α i)) : measure_theory.outer_measure (Π (i : ι), α i)
{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → option α
{R : Type u_1} {S : Type u_3} [comm_ring R] [comm_ring S] : comm_ring (R × S)
{α : Type u_1} {β : Type u_2} : lazy_list α → (α → lazy_list β) → lazy_list β
{α : Type u} {β : Type v} (f : α → β) (t : topological_space β) : topological_space α
{α : Type u} (c : computation α) : ℕ → computation α
{α : Type u_1} [linear_order α] (succ : α → α) (hsucc_le_iff : ∀ {a b : α}, succ a ≤ b ↔ a < b) : succ_order α
{R : Type u} [semiring R] {S : Type u_1} [add_comm_monoid S] (p : polynomial R) (f : ℕ → R → S) : S
 : stream ℕ
{α : Type u_1} {β : Type u_2} [has_mul α] [comm_group β] {f : α → β} (hf : is_mul_hom f) : is_mul_hom (λ (a : α), (f a)⁻¹)
(R : Type u_1) (A : Type u_2) [comm_semiring R] [semiring A] [algebra R A] : Prop
{M : Type u_1} [monoid M] (x : M) : is_submonoid (powers x)
{M : Type u} [add_zero_class M] (x : M) : add_semiconj_by 0 x x
{G : Type u_1} [add_group G] [topological_space G] [t2_space G] [topological_add_group G] [measurable_space G] [borel_space G] [locally_compact_space G] : measure_theory.measure G
{α : Type u_1} {β : Type u_2} [primcodable α] [primcodable β] (p : α → Prop) (q : β → Prop) : Prop
(α : Type u_6) (β : Type u_7) [non_assoc_semiring α] [preorder α] [non_assoc_semiring β] [preorder β] : Type (max u_6 u_7)
{R : Type u_1} [euclidean_domain R] (abv : absolute_value R ℤ) : Type
{α : Type u_1} (l : lazy_list α) : lazy_list {x // x ∈ l}
{α : Type u_2} {β : Type u_3} {γ : Type u_4} [has_Inf α] [has_Inf β] [has_Inf γ] (f : Inf_hom β γ) (g : Inf_hom α β) : Inf_hom α γ
{α : Type u_1} [β : normed_ring α] : non_unital_normed_ring α
 : pgame → Type (u+1)
{Γ : Type u_1} [inhabited Γ] (a : Γ) (l : turing.list_blank Γ) : turing.list_blank Γ
{α : Type u_1} (s t : finset α) (h : ∀ (a : α), a ∈ s → a ∉ t) : finset α
{α : Type u} [preorder α] {s t : set α} (h : bdd_below t) : bdd_below (s ∩ t)
 : Type
{C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] (hA : category_theory.is_subterminal A) : category_theory.mono (category_theory.limits.terminal.from A)
(X : Type u_1) [has_mul X] [has_zero X] [has_lt X] [has_le X] : Prop
(t : Type u → Type u → Type u) [bitraversable t] : Type
(m : Type u → Type u) (α : Type u) : Type u
(X : Type u_1) [topological_space X] [h : topological_space.metrizable_space X] : metric_space X
{T : Type w} [comm_ring T] (p : polynomial T) (S : Type u_1) [comm_ring S] [is_domain S] [algebra T S] : set S
{α : Type u_1} [denumerable α] : denumerable (list α)
{C : Type u} [category_theory.category C] (G : C) : Prop
(R : Type u_1) [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (v₁ v₂ : M) : Prop
{R₁ : Type u_4} [comm_ring R₁] : quadratic_form R₁ R₁
(G : Type u_1) [add_comm_monoid G] : add_submonoid G
{α : Type u_1} {β : Type u_2} (f : α → β) : rel α β
{α : Type u_2} [has_one α] [has_mul α] : has_pow (filter α) ℕ
{α : Type u_1} (r : α → α → Prop) (a : α) : α → Prop
{α : Type u} {β : Type v} [topological_space α] [topological_space β] (s : set α) (t : set β) : Prop
{α : Type u} {β : Type v} [topological_space α] [nonempty α] (f : filter β) (g : β → α) : α
{α : Type u_1} (p : α → Prop) [decidable_pred p] (l : list α) : list ℕ
{K : Type u_1} {β : Type u_2} [has_coe K β] : has_coe (generalized_continued_fraction.int_fract_pair K) (generalized_continued_fraction.int_fract_pair β)
{α : Type u_1} {ι : Type u_3} [lattice α] [order_bot α] (s : finset ι) (f : ι → α) : Prop
{K : Type u} [field K] : has_inf (subfield K)
{α : Type u} {β : Type v} (f : α → β) (t : topological_space α) : topological_space β
(u : pSet) : set pSet
{β : Type u_2} (x : β) (V : set (β × β)) : set β
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {f : J → C} {t : category_theory.limits.cocone (category_theory.discrete.functor f)} (ht : category_theory.limits.is_colimit t) : category_theory.limits.bicone f
{α : Type u} [has_lt α] [hwo : is_well_order α has_lt.lt] : has_well_founded α
(R : Type u) : Type u
{M : Type u_1} [add_monoid M] {γ : Type u_2} [add_monoid γ] {f : M → γ} (hf : is_add_monoid_hom f) : is_add_submonoid (set.range f)
(M : Type u_1) [has_mul M] : Type u_1
{α : Type u} [topological_space α] (s : set α) : Prop
{R : Type u_1} [semiring R] : has_mul (nat.arithmetic_function R)
{S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : a * b = b * a
{τ : Type u_1} {α : Type u_2} {β : Type u_3} [topological_space β] (f : filter τ) (ϕ : τ → α → β) (s : set α) : set β
(p : ℕ) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] : module (fraction_ring (witt_vector p k)) (fraction_ring (witt_vector p k))
(α : Type u) [has_le α] : Type u
{α : Type u_1} {β : Type u_2} [topological_space β] [comm_semiring β] (l : filter α) (k f : α → β) : Prop
{M : Type u_5} [add_comm_monoid M] : unique (module ℕ M)
(𝕆 : Type u_5) (α : Type u_6) [preorder 𝕆] [preorder α] : Type (max u_5 u_6)
{ι : Type u} (f : ι → ordinal → ordinal) (a : ordinal) : ordinal
(α : Type u_3) [has_sup α] : sup_hom α α
 : num → num → ordering
{α : Type u_4} {β : Type u_5} (r : α → α → Prop) (s : β → β → Prop) : Type (max u_4 u_5)
(G : Type u) : Type u
{n : ℕ} : group (dihedral_group n)
 : function.injective has_dvd.dvd
{α : Sort u} : α → Type
{α : Type u_1} (r : α → α → Prop) (a b : α) : Prop
{α : Type u} [decidable_eq α] {β : α → Type v} (l : list (sigma β)) : alist β
(m : Type u → Type u) [monad m] [is_lawful_monad m] : category_theory.monad (Type u)
{X : Type u_1} [topological_space X] (s : set X) : seq_closure s ⊆ closure s
{Γ : Type u_4} [group Γ] {T : Type u_5} [topological_space T] [mul_action Γ T] [fintype Γ] : properly_discontinuous_smul Γ T
{α : Type u_1} {β : Type u_2} (R : α → β → Prop) : list α → list β → Prop
(α : Type u) : Type u
{α : Type u} {β : Type v} [setoid α] [topological_space α] {f : β → α} (hf : dense_range f) : dense_range (quotient.mk ∘ f)
{α : Sort u_1} [subsingleton α] (a : α) : unique α
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 ≤ a) (hb : 0 < b) : 0 < a + b
{α : Type u_1} [decidable_eq α] (s : cycle α) : finset α
{α : Type u_1} (r : α → α → Prop) [decidable_rel r] (a : option α) (b : α) : option α
{M : Type u_1} [add_monoid M] {a : M} (h : is_add_unit a) : add_units M
{α : Type u_1} {r : α → α → Prop} : is_max_chain r (max_chain r)
{n : ℕ} (x : bitvec n) (i : ℕ) : bitvec n
{α : Type u_1} {β : Type u_2} [preorder α] [preorder β] (f : α → β) (g : β → α) : Prop
(α : Type u_2) [lattice α] : Prop
 : Type
{α : Type u} [pseudo_metric_space α] {s : set α} {x y : α} (h : metric.bounded s) (hx : x ∈ s) (hy : y ∈ s) : has_dist.dist x y ≤ metric.diam s
{V : Type u} [quiver V] {a b : V} : quiver.path a b → ℕ
(c : cardinal) : Prop
{C : Type u} [category_theory.category C] (𝒢 : set C) : Prop
(α : Type u) : Type u
(v : ℕ → ℤ) : omega.clause → Prop
(a b : num) : option num
{C : Type u₁} [category_theory.category C] [category_theory.well_powered C] [category_theory.limits.has_wide_pullbacks C] {A : C} (s : set (category_theory.subobject A)) : C
{α : Type u_2} {β : Type u_3} [has_vadd α β] : has_vadd α (set β)
{H : Type u} [topological_space H] {G : structure_groupoid H} (M : Type u_1) [topological_space M] [charted_space H M] [has_groupoid M G] : structomorph G M M
{α : Type u_1} (s : cycle α) : Prop
{α : Type u} : list α → lazy_list α
{n m : ℕ} (f : vector ℕ n → vector ℕ m) : Prop
{C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : category_theory.sieve X
{α : Type u_2} [has_mul α] : has_mul (filter α)
{α : Type u_2} [bornology α] (s : set α) : Prop
{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : a < 1) (hb : b ≤ 1) (a0 : 0 < a) : a * b < 1
{α : Type u_1} {β : Type u_2} [measurable_space α] [has_zero β] (f : measure_theory.simple_func α β) (s : set α) : measure_theory.simple_func α β
(R : Type u) {B : Type v} [comm_ring R] [decidable_eq B] [fintype B] (A : matrix B B ℤ) : Type (max u v)
 : Type
{α : Type u} (g : set (set α)) : topological_space α
{α : Type u_1} [topological_space α] (s : set α) : Prop
{ι : Type u_1} (R : Type u_3) {M : Type u_5} (v : ι → M) [semiring R] [add_comm_monoid M] [module R M] : Prop
(X : Top) (T : TopCommRing) : Top.presheaf CommRing X
{R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_ring A] [algebra R A] (𝒜 : ℕ → submodule R A) [graded_algebra 𝒜] : Type u_2
(C : Type u) [category_theory.category C] : Prop
(α : Type u_7) (β : Type u_8) [has_sup α] [has_sup β] : Type (max u_7 u_8)
{α : Type u_1} (m : set α → ennreal) (m_empty : m ∅ = 0) : measure_theory.outer_measure α
(α : Type u_1) (β : Type u_2) [topological_space α] [topological_space β] [add_group β] [topological_add_group β] : add_subgroup (α → β)
{α : Type u_1} {ι : Sort u_3} [conditionally_complete_linear_order α] {b : α} [nonempty ι] {f : ι → α} (h : b < supr f) : ∃ (i : ι), b < f i
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X Y : C) : category_theory.limits.mono_factorisation 0
(L : first_order.language) (M : Type w) [L.Structure M] : L.Theory
{α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {a b : α} : is_preconnected (set.Icc a b)
 : game → game → Prop
{α : Type u_1} (r s : α → α → Prop) (h : ∀ (x y : α), r x y → s x y) : quot r → quot s
(n : ℕ) (R : Type u_1) [ring R] : polynomial R
{α : Type u_1} (R : α → α → Prop) [decidable_rel R] : α → list α → list α
{P : Type u_1} [preorder P] (s t : order.pfilter P) (h : ↑s = ↑t) : s = t
{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ ≤ b ↔ b⁻¹ ≤ a
(α : Type u_1) : Type u_1
{X : Type u_1} [topological_space X] {R : Type u_5} [has_zero R] {U : set X} (f : locally_constant X R) (hU : is_clopen U) : locally_constant X R
(R : Type u_1) {A : Type u_3} [comm_ring R] [ring A] [algebra R A] (x : A) : Prop
(α : Type u_1) [partial_order α] [order_bot α] : Prop
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} (e : local_equiv α β) (e' : local_equiv γ δ) : local_equiv (α × γ) (β × δ)
{α : Type u_1} [has_mul α] (s : set α) (a b : α) : Prop
{M₀ : Type u_1} [mul_zero_one_class M₀] (h : 0 = 1) : unique M₀
{ι : Type u_1} {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] (f : ι → α) (g : ι → β) : Prop
(M : Type u) (R : Type v) [monoid M] [semiring R] : Type (max u v)
(α : Type u_2) [has_Sup α] : Sup_hom α α
(L : first_order.language) (M : Type u_3) (N : Type u_4) [L.Structure M] [L.Structure N] : Type (max u_3 u_4)
{α : Type u_1} [decidable_eq α] (s : multiset α) (a : α) : multiset α
{α : Type u_2} {β : Type u_4} [topological_space α] [has_zero β] (f : α → β) : Prop
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a + b
{α : Type u} (m : measure_theory.outer_measure α) : measurable_space α
{α : Type u} (l : stream α) : wseq α
{R : Type u} [ring R] (s : subsemiring R) (hneg : -1 ∈ s) : subring R
(α : Type u_1) [encodable α] : Type
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V ↔ nontrivial V
{R : Type u_1} [ring R] (S : subring R) : subalgebra ℤ R
{m : Type u_1 → Type u_2} {n : Type u_1 → Type u_3} [has_monad_lift_t m n] {α : Type u_1} : has_coe (m α) (n α)
{n : ℕ} {x : ℕ × ℕ} : x ∈ multiset.nat.antidiagonal n ↔ x.fst + x.snd = n
{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (l : list (Σ (a : α), β a)) : bool
(n : ℕ) : has_neg (fin n)
{α : Type u} [has_inv α] [has_sup α] : has_abs α
(X : algebraic_geometry.Scheme) : Prop
{ι : Type u} (f : ι → ordinal) : bdd_above (set.range f)
{α : Type u} {β : Type v} {δ : Type w} (f : α → β → δ) (s₁ : stream α) (s₂ : stream β) : stream δ
(C : Type u) [category_theory.category C] : Prop
{β : Type u_6} {γ : Type u_7} {m m0 : measurable_space β} (hm : m ≤ m0) (f : measure_theory.simple_func β γ) : measure_theory.simple_func β γ
{α : Type u_1} [cancel_comm_monoid_with_zero α] {a b c : α} (hc : c ≠ 0) : a * c ∣ b * c ↔ a ∣ b
{α : Type u} (r : α → α → Prop) [is_partial_order α r] : ∃ (s : α → α → Prop) (_x : is_linear_order α s), r ≤ s
{S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) : commute a (b * c)
{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → α → α
{α : Type u_1} (S : set (set α)) : set (set α)
(α : Type u) : Type u
{X : Type v} [topological_space X] [locally_compact_space X] [sigma_compact_space X] [t2_space X] : paracompact_space X
{α : Type u_1} [encodable α] : encodable (ulift α)
{α : Type u_1} (f : α → α) : list α → list α
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) : local_homeomorph β α
{α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} : finsum (λ (i : α), finsum (λ (H : i ∈ ∅), f i)) = 0
{α : Type u_2} [decidable_eq α] [subtraction_monoid α] : subtraction_monoid (finset α)
{m : ℕ} : bitvec m → ℕ → bitvec m
{α : Type u_1} {β : Type u_2} (e e' : local_equiv α β) : Prop
 : pythagorean_triple 0 0 0
{R : Type u} [semiring R] (p : polynomial R) : Prop
{α : Type u_1} [decidable_eq α] (𝒜 : finset (finset α)) : finset (finset α)
{ι : Type u_1} {A : ι → Type u_2} (i : ι) : A i → graded_monoid A
(n : ℕ) : Type (u+1)
{R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 → R} (h : is_coprime (p 0) (p 1)) : p ≠ 0
{α : Type u_1} : sym2 α → Prop
(X Y : algebraic_geometry.LocallyRingedSpace) : Type u_1
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) : α → β
(n : Type u) (R : Type v) [decidable_eq n] [fintype n] [comm_ring R] : Type (max u v)
(α : Type u_6) (β : Type u_7) [has_top α] [has_top β] : Type (max u_6 u_7)
(M : Type u_1) (X : Type u_2) [has_vadd M X] [topological_space M] [topological_space X] : Prop
{α : Type u_1} {β : Type u_2} : α × β → (Σ (_x : α), β)
{α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_simple_group α
{X : Type u_1} (a : free_abelian_group X) : finset X
{α : Type u_1} : ordnode α → Prop
(X : Type u) (Y : Type v) [topological_space X] [topological_space Y] : Type (max u v)
(f : bool → bool) (x : bool) : f (f (f x)) = f x
{α : Type u} [partial_order α] {a b : α} : a ≤ b → b ≤ a → b = a
{τ : Type u_1} {α : Type u_2} (ϕ : τ → α → α) (s : set α) : Prop
{α : Type u_1} {β : Type u_2} (p : pmf α) (f : α → pmf β) : pmf β
{n : ℕ} : zmod n → ℕ
{α : Type u_1} (p : pmf α) : set α
{α : Type u_2} [add_comm_monoid α] : add_comm_monoid (filter α)
(R : Type u) [ring R] : galois_insertion subring.closure coe
{n : Type u_3} {α : Type v} (v : n → α) : matrix unit n α
{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] [decidable_eq R] (s : finset S) : finset R
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop
(α : Type) [has_zero α] [has_one α] [has_add α] [fintype α] (fromc : char) : parser α
 : has_le cardinal
(k : Type u) [field k] (n : ℕ) : Type u
{R : Type u_2} [has_add R] (c : R) : Prop
{α : Type u_1} [has_one α] [has_zero α] [has_lt α] (a : α) : continued_fraction α
{V : Type u} (G : simple_graph V) (u v : V) : Type u
{V : Type u} (G : simple_graph V) (v w : V) : set V
{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] (h : is_smul_regular M 0) : subsingleton M
{α : Type u_1} : option (option α) → option α
{α : Type u_1} (x : α) : free_add_monoid α
{α : Type u} {β : Type v} (f : α → β) : free_semigroup α → free_semigroup β
{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : Type u_2
{R : Type u₁} [semiring R] (r : R → R → Prop) : R → R → Prop
(n : ℕ) : option ℕ
{α β : ordinal} (h : α ≤ β) : initial_seg has_lt.lt has_lt.lt
(n : ℕ) : Type
{α : Type u_1} (s : set α) (r : α → α → Prop) : Prop
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (ι : Type u_1) [unique ι] : finite_dimensional.finrank K V = 1 ↔ nonempty (basis ι K V)
(α : Type u_1) : Type u_1
(R : Type u_1) (A : Type u_2) [semiring R] [star_semigroup R] [has_trivial_star R] [add_comm_group A] [module R A] [star_add_monoid A] [star_module R A] : submodule R A
{R₁ : Type u_4} [comm_ring R₁] {n : Type w} [fintype n] [decidable_eq n] (M : matrix n n R₁) : quadratic_form R₁ (n → R₁)
{G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)
{K : Type u} [hring : comm_ring K] : ratfunc K
{α : Type u} [t : topological_space α] (s : set α) : Prop
{α : Type u_2} [decidable_eq α] [has_neg α] : has_neg (finset α)
(R : Type u_1) [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] : has_neg (module.ray R M)
{α : Type u_1} [decidable_eq α] {𝒜 : finset (finset α)} {s : finset α} (hs : s ∈ 𝒜.shadow) : ∃ (t : finset α) (H : t ∈ 𝒜), s ⊆ t
(α : Type u) (r : α → α → Prop) : Prop
{α : Type u_1} [lattice α] [bounded_order α] [is_simple_order α] : complete_boolean_algebra α
(𝕜 : Type u_1) (E : Type u_2) [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] : Type u_2
{A : Type u_6} [comm_ring A] [is_domain A] {M : submonoid A} (hM : M ≤ non_zero_divisors A) : is_domain (localization M)
{α : Type u} [non_unital_non_assoc_ring α] (a b c : α) : (a - b) * c = a * c - b * c
 : Type
{α : Type u} (r₁ r₂ : set (α × α)) : set (α × α)
{α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (H : is_semiring_hom f) : is_ring_hom f
{α : Type u_1} [preorder α] [add_comm_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} : a ≤ b → a - b ≤ 0
{C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_product X Y] : category_theory.limits.has_binary_biproduct X Y
(F : Type u_1) (α : out_param (Type u_2)) (β : out_param (Type u_3)) [topological_space α] [topological_space β] : Type (max u_1 u_2 u_3)
{J : Type u} (F : J → Type u) : category_theory.limits.colimit_cocone (category_theory.discrete.functor F)
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] [h : nontrivial V] : 0 < finite_dimensional.finrank K V
 : Type
 : Type
{α : Type u_1} [preorder α] [decidable_rel has_lt.lt] (l : list α) : with_bot α
{α : Type} {ds : list ℕ} [ring α] (x : holor α ds) : ℕ
 : Type
{α : Type u} {β : Type v} [topological_space α] [topological_space β] : is_open_map prod.snd
(a : ℤ) : ℤ
(n m : ℕ) : Prop
{ι : Type w} (A : Type u) {B : Type v} [comm_ring A] [comm_ring B] [algebra A B] [fintype ι] (b : ι → B) : A
{V : Type u} (G : simple_graph V) : set V
(𝕆 : Type u_5) (α : Type u_6) [preorder 𝕆] [preorder α] : Type (max u_5 u_6)
(α : Type u_2) [has_Inf α] : Inf_hom α α
{R : Type u_1} [semiring R] (p : polynomial R) : polynomial R
{α : Sort u_1} (f : α → α) : Prop
 : Type
{α : Type u} {β : Type v} (f : α → β) (s : stream α) : stream β
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] : monoid (category_theory.skeleton C)
{C : Type u₁} [category_theory.category C] [category_theory.monoidal_category C] : category_theory.reflects_isomorphisms (Mon_.forget C)
{α : Type u} {β : α → Type (max u v)} [decidable_eq α] (xs : list α) : (Π (a : α), list (β a)) → list (Π (a : α), a ∈ xs → β a)
(α : Type u_1) [topological_space α] : setoid α
{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i)
 : nzsnum → nzsnum
(p : Type u_2) (q : Type u_3) (R : Type u₂) [decidable_eq p] [decidable_eq q] [comm_ring R] (i : R) : matrix (p ⊕ q) (p ⊕ q) R
{K : Type u_1} [linear_ordered_field K] {c : continued_fraction K} : ↑c.convergents = ↑c.convergents'
{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a < 1 → 1 < a⁻¹
{α : Type u_1} {β : Type u_2} [fintype α] (f : α → β) (H : function.bijective f) : fintype β
(K : Type u_1) [field K] [number_field K] : ℕ
{α : Type u_1} [decidable_eq α] (a : α) : multiset α → ℕ
{x y z : ℤ} (h : pythagorean_triple x y z) : Prop
(α : Type u) [t : topological_space α] : Prop
{ι : Type u} {X : Type v} [topological_space X] {s : set X} (f : bump_covering ι X s) : partition_of_unity ι X s
{α : Type u_1} {β : Type u_2} (f : α → β → β) (b : β) (l : list α) : list β
 : nzsnum → bool
{J : Type v} [category_theory.small_category J] {C : Type u} [category_theory.category C] {B : C} [category_theory.is_connected J] [category_theory.limits.has_limits_of_shape J C] : category_theory.limits.has_limits_of_shape J (category_theory.over B)
(L : first_order.language) : Type u
{n : ℕ} {α : fin n → Type u} {β : Type w} (a : d_array n α) (b : β) (f : Π (i : fin n), α i → β → β) : β
{m : Type → Type v} [monad m] {α : Type u} (p : α → m bool) : list α → m bool
{α : Type u_2} [semiring α] (a : α) : Prop
{C : Type u} [category_theory.category_struct C] (X : C) : has_mul (category_theory.End X)
{R : Type u₁} [semiring R] [star_ring R] (r : R → R → Prop) (hr : ∀ (a b : R), r a b → r (has_star.star a) (has_star.star b)) : star_ring (ring_quot r)
(m M N : ℕ) : finset (Σ (n : ℕ), composition n)
{α : Type u} [pseudo_metric_space α] {s t : set α} (hs : metric.bounded s) (ht : metric.bounded t) : metric.bounded (s ∪ t)
{α : Type u_1} [preorder α] (a b : α) : set α
(M : Type u) : Type u
{n : ℕ} (x y : bitvec n) : bitvec n
{X : Type u_2} [emetric_space X] (m : set X → ennreal) : measure_theory.outer_measure X
 : ¬bdd_above {p : ℕ | nat.prime p}
{α : Type} (sep : parser unit) (p : parser α) : parser (list α)
{α : Type u_1} (n : ℤ) : poly α
 : Type
(p : pos) (n : ℕ) : pos
{α : Type u} {β : Type v} (f : filter α) (m : α → filter β) : filter β
{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 → 1 < a
{α : Type u} [has_inv α] : has_inv (with_zero α)
{n : ℕ} (x y : bitvec n) (c : bool) : bitvec (n + 1)
{p : ℕ} [fact (nat.prime p)] : padic_norm_e 1 = 1
(cs : list omega.clause) : Prop
{α : Type u_1} {n : ℕ} (f : fin n → α) (m : ℕ) : m ≤ n → list α → list α
(α : Type u_1) [ht : topological_space α] [h : polish_space α] : metric_space α
{Γ : Type u_1} {R : Type u_2} [partial_order Γ] [has_zero R] (x : hahn_series Γ R) : set Γ
 : Type → Type
{α : Type u} (r : α → α → Prop) [is_symm α r] {a b : α} : r a b ↔ r b a
{α : Type u} {β : Type v} (f : filter (α → β)) (g : filter α) : filter β
(m m' : Type u → Type v) (n n' : Type u → Type w) : Type (max (u+1) v w)
(K : Type u) [field K] : Type (u+1)
 : Type (u+1)
 : filter.cofinite = filter.at_top
(α : Type u_3) [topological_space α] : Type u_3
{α : Type u_1} {P : α → Prop} [encA : encodable α] [decP : decidable_pred P] : encodable {a // P a}
 : bool → list bool
(α : Type u_6) (β : Type u_7) [topological_space α] [topological_space β] : Type (max u_6 u_7)
(R : Type u) (A : Type v) [comm_semiring R] [star_ring R] [semiring A] [star_ring A] [algebra R A] [star_module R A] : Type v
{R : Type u_3} [comm_ring R] (p : polynomial R) (s : R) : polynomial R
{α : Type u_2} [monoid α] (m : α) : is_square m → (∃ (c : α), m = c ^ 2)
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 ≤ a) (hb : 1 < b) : 1 < a * b
{α : Type u_1} [boolean_algebra α] : boolean_ring α
{α : Type u_1} {β : Type u_2} (f : α → β) (u : uniform_space β) : uniform_space α
{α : Type u_1} [has_le α] (a : α) : Prop
(α : Type u_1) (β : Type u_2) [has_add α] [add_comm_semigroup β] : add_hom (add_hom α β) (α → β)
{R : Type u_1} {S : Type u_3} [non_unital_semiring R] [non_unital_semiring S] : non_unital_semiring (R × S)
{G : Type u_1} [add_group G] (H K : add_subgroup G) : ℕ
{R : Type u_1} (c₁ c₂ : R) : cardinal.mk (quaternion_algebra R c₁ c₂) = cardinal.mk R ^ 4
 : znum → znum
(n : Type u) [decidable_eq n] [fintype n] (α : Type v) [comm_ring α] [star_ring α] : submonoid (matrix n n α)
(α : Type u) [t : topological_space α] : Prop
{α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] [topological_space.pseudo_metrizable_space β] [measurable_space β] [borel_space β] (hf : measure_theory.strongly_measurable f) : measurable f
{α : Type u_1} {s : multiset α} {x : multiset α × multiset α} : x ∈ s.antidiagonal ↔ x.fst + x.snd = s
(α : Type u₁) : Type u₁
(𝕜 : Type u_1) {E : Type u_2} [ordered_semiring 𝕜] [add_comm_monoid E] [module 𝕜 E] : closure_operator (set E)
{R : Type u} [comm_semiring R] (S : Type u_1) [semiring S] [algebra R S] (M : submonoid R) : submonoid S
{P : Type u_1} [preorder P] [order_top P] : order_bot (order.pfilter P)
 : Type (u+1)
{f : ℕ → nnreal} (hf : ∀ ⦃m n : ℕ⦄, 0 < m → m ≤ n → f n ≤ f m) : summable (λ (k : ℕ), 2 ^ k * f (2 ^ k)) ↔ summable f
{α : Type u_1} [preorder α] {a b : α} (h : a ≤ b) : set.Iio a ⊆ set.Iio b
{α : Type u_3} {β : Type u_4} [has_sup α] [has_bot α] [has_sup β] [has_bot β] (f : sup_bot_hom α β) : bot_hom α β
{α : Type u} {n : ℕ} (v : fin n.succ → α) : α
(p : ℕ → Prop) : Type
(R : Type u_1) [rack R] : Prop
(α : Type u_1) : Type u_1
{X : Type u_1} [topological_space X] {R : Type u_5} [has_one R] {U : set X} (f : locally_constant X R) (hU : is_clopen U) : locally_constant X R
 : Type
{α : Type u} {β : Type v} (f : α → β) : seq α → seq β
(p : ℕ) (G : Type u_1) [group G] : Prop
{α : Type u} [add_group α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a : α} (h : 0 < a) : -a < a
{M : Type u_1} [mul_one_class M] (S : submonoid M) {x y : M} : x ∈ S → y ∈ S → x * y ∈ S
{R : Type u_1} [has_mul R] [has_star R] (x : R) : Prop
(x : pSet) (y : pSet) : Prop
{M : Type u_1} [mul_one_class M] : has_coe (con M) (submonoid (M × M))
{α : Type u_1} [preorder α] [order_top α] [locally_finite_order α] (a : α) : finset α
 : Type
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (has_vsub.vsub p)
(t : Type u → Type u) [traversable t] : Type (u+1)
(i j : ℤ) : ℕ
(α : Type u_2) [cancel_comm_monoid_with_zero α] : Type u_2
{n : ℕ} : nat.fib (n + 2) = nat.fib n + nat.fib (n + 1)
{α : Type u} {β : Type v} [semiring α] [semiring β] {f : α → β} (hf : is_semiring_hom f) : is_monoid_hom f
{M : Type u_1} [add_zero_class M] : complete_lattice (add_submonoid M)
{α : Type u_1} (l : filter α) : filter (set α)
{α : Type u} [pseudo_emetric_space α] (x : α) (s : set α) : ennreal
{α : Sort u_1} {p : α → Prop} (hp : ∀ (a : α), ¬p a) : is_empty (subtype p)
{m : Type v → Type w} [applicative m] {α : Type u_1} (f : ℕ → α → m punit) (as : list α) : m punit
{α : Type u_1} [decidable_eq α] (s : finset α) : finset (sym2 α)
{V : Type u} [quiver V] (H : wide_subquiver (quiver.symmetrify V)) : wide_subquiver V
{α : Type u} [semiring α] (s : set α) : ideal α
{n : ℕ} (c : composition n) : composition_as_set n
{R₂ : Type u_5} {M₂ : Type u_6} [comm_semiring R₂] [add_comm_monoid M₂] [module R₂ M₂] (B₂ : bilin_form R₂ M₂) : submodule R₂ (module.End R₂ M₂)
(a b : Prop) : Prop
{α : Type u_1} {β : Type u_4} [partial_order α] [preorder β] {u : β → α} (l : lower_adjoint u) : closure_operator α
(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) : ι → k
{G : Type u_1} [group G] (h : monoid.exponent_exists G) : monoid.is_torsion G
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C) : Type (max u v)
{M : Type u_1} [add_zero_class M] (S : add_submonoid M) : 0 ∈ S
{R : Type u} [semiring R] (x : laurent_series R) : power_series R
(C : Type u₁) [category_theory.category C] : category_theory.monad C
(α : Type) : Type
{α : Type u_1} {n : Type u_4} [has_sub n] (v : n → α) : matrix n n α
 : Type
(α : Type u_1) [measurable_space α] : Type u_1
(G : Type u_1) [category_theory.groupoid G] : Type u_1
(K : Type u_1) [field K] : Prop
(F : Type u_7) (α : out_param (Type u_8)) (β : out_param (Type u_9)) [has_inf α] [has_inf β] [has_top α] [has_top β] : Type (max u_7 u_8 u_9)
{α : Type u} [comm_semiring α] {p p' ps ps' : α} : p = p' → ps = ps' → p + ps = p' + ps'
{α : Sort u_1} {p : α → Prop} (P : ∃ (a : α), p a) : α
{a b k : ℕ} (h_ab_coprime : a.coprime b) (hka : k ∣ a) (hkb : k ∣ b) : k = 1
{ι : Type u_1} {α : Type u_2} [unique ι] [inhabited α] : inhabited (indexed_partition (λ (i : ι), set.univ))
{α : Type u_1} {𝒜 : finset (finset α)} {A : finset α} {r : ℕ} : A ∈ 𝒜.slice r ↔ A ∈ 𝒜 ∧ A.card = r
{R : Type u} [comm_semiring R] {A : Type v} [comm_semiring A] [algebra R A] : has_div (submodule R A)
{ι : Type u_1} {α : ι → Type u_2} [S : Π (i : ι), setoid (α i)] (f : Π (i : ι), quotient (S i)) : quotient pi_setoid
{R : Type u} {M : Type v} [has_zero R] (m : M) : triv_sq_zero_ext R M
(α : Type u) : Type u
{α : Type uu} (l₁ l₂ : list α) : Prop
(u : pnat.xgcd_type) : Prop
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} (f : α → β → γ → δ) : list α → list β → list γ → list δ
(α : Type u_1) : Type u_1
{R : Type u_1} {G : Type u_4} [group G] [mul_action G R] (g : G) : is_smul_regular R g
(α : Type u_2) [topological_space α] [preorder α] : esakia_hom α α
{X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C : nnreal} {f : X → Y} : lipschitz_with C f → holder_with C 1 f
{C : Type u} [category_theory.category C] (X Y : C) : Type v
(p : pos_num) : ℕ → pos_num
(m M N : ℕ) : set (Σ (n : ℕ), composition n)
{α : Type u_2} {β : Type u_3} {γ : Type u_4} [complete_lattice α] [complete_lattice β] [complete_lattice γ] (f : complete_lattice_hom β γ) (g : complete_lattice_hom α β) : complete_lattice_hom α γ
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1
(R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] (p : ℕ) [char_p R p] : char_p K p
{α : Type u_1} {β : Type u_2} (r : rel α β) (s : set β) : set α
{α : Type u_1} [h : normed_lattice_add_comm_group α] : ordered_add_comm_group α
{α : Type u} (p : α → Prop) (f : filter α) : Prop
{α : Type u} : ordnode α → option α
(α : Type u_6) (β : Type u_7) [preorder α] [preorder β] [bounded_order α] [bounded_order β] : Type (max u_6 u_7)
{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] : ratfunc K → ratfunc K → ratfunc K
{M : Type u_1} [has_add M] : has_add (ultrafilter M)
(L : first_order.language) : L.Structure unit
(C : Type u) [category_theory.category C] : Prop
{α : Type u} (lt : α → α → Prop) [decidable_rel lt] (x : α) : tree α → option pos_num
(p : ℕ) [hp : fact (nat.prime p)] {k : Type u_1} [field k] [char_p k p] [is_alg_closed k] {a₁ a₂ : witt_vector p k} (ha₁ : a₁.coeff 0 ≠ 0) (ha₂ : a₂.coeff 0 ≠ 0) : ℕ → k
{ι : Sort u_1} {α : Type u_2} [complete_lattice α] (t : ι → α) : Prop
{α : Type u_1} (p : Prop) (f : p → part α) : part α
{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) : Prop
(m : Type u) (n : Type u') (α : Type v) : Type (max u u' v)
{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a
(M : Type u_1) [measurable_space M] [has_add M] : Prop
{R : Type u_2} {Γ₀ : Type u_3} [ring R] [linear_ordered_comm_monoid_with_zero Γ₀] (v : valuation R Γ₀) : preorder R
(A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] : is_domain K
{α : Type u_1} [preorder α] [locally_finite_order α] (a b : α) : multiset α
{R : Type u_1} {M : Type u_2} {ι : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [fintype ι] (b : basis ι R M) : module.finite R M
(X : Type u_1) [topological_space X] [locally_compact_space X] [sigma_compact_space X] : compact_exhaustion X
{R : Type u_1} {a b : R} [semigroup R] (ab : is_right_regular (b * a)) : is_right_regular b
{b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : 0 < y) : b ^ x ≤ y ↔ x ≤ nat.log b y
(A : Type u_9) [add_zero_class A] : Type u_9
(α : Type) [has_zero α] [has_one α] [has_add α] [fintype α] : parser α
(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A) : category_theory.full (category_theory.shift_functor C i)
(α : Type u_10) (β : Type u_11) [monoid α] : Type (max u_10 u_11)
(G : Type u) : Type u
 : Type
{α : Type u_1} : list (list α) → list (list α)
(R : Type u_1) [has_zero R] [has_pow R ℕ] : Prop
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) : Prop
{α : Type u_1} (B : filter_basis α) : filter α
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) (S : add_subsemigroup M) : add_subsemigroup N
{n : ℕ} (P : mvpfunctor (n + 1)) {β : Type u} (g₀ : β → P.A) (g₂ : Π (b : β), P.last.B (g₀ b) → β) : β → P.last.M
(α : Type u_1) [topological_space α] : filter α
{α : Type u} {a b c d : α} [preorder α] (hca : c ≤ a) (hbd : b ≤ d) : a ≤ b → c ≤ d
(n : ℕ) (h : 0 < n) : composition n
(C : Type u) [category_theory.category C] : Type (max u v)
{α : Type u_1} [dec : decidable_eq α] : regular_expression α → list α → bool
 : Type
{ι : Type u_1} (c₁ c₂ : complex_shape ι) : complex_shape ι
{α : Type u} : dlist α
(α : Type u) (β : Type v) [partial_order α] [partial_order β] : partial_order (α × β)
{α : Type u} {β : Type v} [topological_space α] [topological_space β] {f : α → β} (hf : continuous f) : filter.comap f (filter.cocompact β) ≤ filter.cocompact α
{V : Type u_1} {α : Type u_2} [has_zero α] [has_one α] (A : matrix V V α) : Prop
{K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : generalized_continued_fraction K
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] (f : cocompact_map β γ) (g : cocompact_map α β) : cocompact_map α γ
(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [has_bot α] [has_bot β] : Type (max u_6 u_7 u_8)
{α : Type u} {β : Type v} (s : seq1 α) (f : α → seq1 β) : seq1 β
{P : Type u_1} [has_le P] [is_directed P has_le.le] [nonempty P] : order_top (order.ideal P)
{α : Type u} (s : wseq α) (n : ℕ) : computation (option α)
(α : Type u) : Type u
{R : Type u_1} [monoid R] [star_semigroup R] (A₀ A₁ B₀ B₁ : R) : Type
{α : Type u_1} [preorder α] (a : α) : upper_set α
{α : Type u_1} [circular_preorder α] {a b c : α} (habc : has_btw.btw a b c) (hcba : ¬has_btw.btw c b a) : has_sbtw.sbtw a b c
 : znum → znum → znum
{α : Type u_1} {β : Type u_2} {p : α → Prop} (f : Π (a : α), p a → β) (l : lazy_list α) : (∀ (a : α), a ∈ l → p a) → lazy_list β
{J : Type u} (F : J → Type u) : category_theory.limits.limit_cone (category_theory.discrete.functor F)
(C : Type u) (A : Type u_1) [category_theory.category C] [add_monoid A] : Type (max u u_1 v)
{P : Type u_1} [preorder P] (F : set P) : Prop
(X : Type u_1) {Y : Type u_2} [topological_space X] (y : Y) : locally_constant X Y
(R : Type u) (A : Type v) (B : Type w) [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B] : Type (max v w)
{α : Type u_2} [comm_semigroup α] : comm_semigroup (filter α)
{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (b0 : 0 < b) : 1 ≤ a * b
 : list ℤ → ℕ
{n : ℕ} (p : fin n) (i : fin (n + 1)) : fin n
{α : Type u} : free_add_magma α → ℕ
{α : Type u_1} {s : finset α} {p : α → Prop} [decidable_pred p] (h : ∀ (x : α), x ∈ s → p x) : finset.map (function.embedding.subtype p) (finset.subtype p s) = s
(x y : Set) : Set
{τ : Type u_1} {α : Type u_2} [preorder τ] [has_zero τ] (ϕ : τ → α → α) (s : set α) : Prop
(C : Type u) [category_theory.category C] : Prop
(α : Type u_1) [preorder α] : Type u_1
(α : Type u_1) (β : Type u_2) [uniform_space β] : filter_basis ((α → β) × (α → β))
{α : Type u_2} [add_semigroup α] : add_semigroup (filter α)
(p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_sym p a = 1 ∨ zmod.legendre_sym p a = -1
{X : Type u_1} [topological_space X] [locally_compact_space X] [t2_space X] : normal_space (alexandroff X)
(α : Type u_6) (β : Type u_7) [preorder α] [preorder β] : Type (max u_6 u_7)
{α : Type u_1} (r : α → α → Prop) : α → α → Prop
{X : Type u_1} [emetric_space X] (s t : set X) : Prop
{α : Type u} [semiring α] (r : α → α → Prop) : ideal α
(α : Type u_1) [topological_space α] [non_unital_non_assoc_semiring α] : Prop
{α : Type u_1} {β : α → Type u_2} [decidable_eq α] [fintype α] [Π (a : α), fintype (β a)] : fintype (Π (a : α), β a)
{α : Type u_1} {P : α → Prop} [encA : encodable α] : {a // P a} → ℕ
{K : Type u} [field K] (x : ratfunc K) : ℤ
{α : Type u_1} {β : Type u_2} (r : α → β → Prop) : list α → list β → Prop
 : Type
(V : Type u) : Type u
{P : Type u_1} [preorder P] (p : P) : order.pfilter P
 : Type
{X : Type u_1} [topological_space X] [path_connected_space X] (x y : X) : path x y
 : Type
{S : Type u_3} {R : Type u_4} [comm_semiring S] [semiring R] [algebra S R] (p : submodule S R) : set_like.graded_monoid (λ (i : ℕ), p ^ i)
(F : Type u_4) {α : out_param (Type u_5)} {β : out_param (Type u_6)} (r : out_param (α → α → Prop)) (s : out_param (β → β → Prop)) : Type (max u_4 u_5 u_6)
{α : Type u_2} [semiring α] {a : α} : odd a → (∃ (b : α), a = bit1 b)
(p : ℕ) [p_prime : fact (nat.prime p)] {q r : ℕ} (hq : q ≠ 0) (hr : r ≠ 0) : padic_val_nat p (q * r) = padic_val_nat p q + padic_val_nat p r
{C : Type u} [category_theory.category C] [category_theory.abelian C] : category_theory.limits.has_finite_biproducts C
{α : Type u_1} {β : Type u_2} [t : topological_space α] [group β] (f : α → β) : group_topology β
 : Type (u+1)
{G : Type u_1} [group G] (s : set G) : Prop
{p : ℕ → Sort u} (H : Π (n : ℕ), (Π (m : ℕ), m < n → p m) → p n) (n : ℕ) : p n
{α : Type u} (s : stream α) : stream α
{G : Type u_1} [add_group G] (H : add_subgroup G) {x : G} : x ∈ H → -x ∈ H
(α : Type u_5) : Type u_5
(X : Type u_1) [topological_space X] : setoid X
{C : Type u₁} [category_theory.category C] [category_theory.limits.has_initial C] (h : ∀ (X : C), category_theory.mono (category_theory.limits.initial.to X)) : category_theory.limits.initial_mono_class C
(l : list Prop) : Prop
(G : Type u_1) [group G] : Prop
{α : Type u_1} (s : finset α) : list α
{K : Type u_1} [field K] [is_alg_closed K] : infinite K
{H : Type u} [topological_space H] (G : structure_groupoid H) : local_homeomorph.refl H ∈ structure_groupoid.maximal_atlas H G
{α : Type u_1} (r : α → α → Prop) (s : set α) : set α
{α : Type u_1} [preorder α] [is_total α has_le.le] [decidable_rel has_le.le] (x : α) (s : ordset α) : ordset α
{R : Type u} [non_assoc_semiring R] (s : subsemiring R) {l : list R} : (∀ (x : R), x ∈ l → x ∈ s) → l.sum ∈ s
(P : name → bool) : name → bool
 : Class
{α : Type {G : Type u_1} [sub_neg_monoid G] [measurable_space G] [has_measurable_add G] (g : G) : measurable (λ (h : G), h - g)
 : Type
{α : Type u} {m : Type u → Type v} [monad m] [alternative m] (tac : α → m punit) : list α → m α
{α : Type u} [uniform_space α] (a : α) : Cauchy α
(G : Type u) : Type u
{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) (t : ordnode α) : option ℕ
(α : Type u_2) : Type u_2
(R : Type u) (M : Type v) (M₂ : Type w) [semiring R] [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module R M₂] : submodule R (M × M₂)
(α : Type u_1) : Type u_1
(α : Type u_1) [finite α] : fintype α
(α : Type u_1) [topological_space α] : filter α
(M : Type u_1) (N : Type u_2) [add_monoid M] [add_monoid N] : Type (max u_2 u_1)
{α : Type u_1} : list (option α) → list α
{X : Type u} [topological_space X] (x₀ x₁ : X) : Type u
{R : Type u_4} [linear_ordered_ring R] (a : R) : 0 ≤ a ^ 2
{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_succ_n : generalized_continued_fraction.int_fract_pair K} (succ_nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n) : 1 ≤ ifp_succ_n.b
{α : Type u} {β : Type v} (f : α → β) (s : set α) : Prop
{n : ℕ} (F : typevec n → Type u_2) [mvfunctor F] : Prop
{n : Type u_1} {R : Type u₂} [decidable_eq n] [comm_ring R] (t : matrix.transvection_struct n R) : matrix.transvection_struct n R
{α : Type u} {β : Type v} [h : can_lift α β] : can_lift (list α) (list β)
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) : Type v
{R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] [fintype R] : fintype S
(X : Type u_3) [topological_space X] : Prop
(C : Type u) [category_theory.category C] : Prop
(Γ₀ : Type u_1) [linear_ordered_comm_group_with_zero Γ₀] : topological_space Γ₀
{n : ℕ} (i j : Σ (a : composition n), composition a.length) : i = j ↔ i.fst.blocks = j.fst.blocks ∧ i.snd.blocks = j.snd.blocks
 : pgame → pgame → Prop
{R : Type u} [non_assoc_semiring R] (s : subsemiring R) {x y : R} : x ∈ s → y ∈ s → x + y ∈ s
{α : Type u_1} [topological_space α] [polish_space α] : polish_space (ℕ → α)
(α : Type v) [small α] : Type w
{α : Type v} {m l r : ℕ} (A : matrix (fin m) (fin (l + r)) α) : matrix (fin m) (fin r) α
 : pos_num → pos_num → pos_num
{α : Type u_1} (a : α) (n : ℕ) : multiset α
{C : Sort u_1} : empty → C
(α : Type u) : Type u
{γ : Type u_3} [topological_space γ] [compact_space γ] [t2_space γ] : uniform_space γ
{α : Type u_1} (β : α → Type u_2) (a : α) (h : a ∈ ∅) : β a
{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) (s : finmap β) : finmap β
{α : Type u} [linear_order α] (a b : α) : set α
{α : Type u_1} (S : set (set α)) : set α
(M : Type u_1) (N : Type u_2) [semiring M] [semiring N] : Type (max u_1 u_2)
{G : Type u_1} [group G] : is_descending_central_series (lower_central_series G)
(α : Type u_1) : Type u_1
(G : pgame) : Prop
{α : Type u_1} (p : pmf α) : measure_theory.outer_measure α
{X : Type u_1} [topological_space X] (x y : X) : Prop
(G : Type u) [add_group G] : add_monoid G
(F : Type u_9) (α : Type u_10) (β : Type u_11) [add_monoid α] [add_monoid β] [topological_space α] [topological_space β] : Type (max u_10 u_11 u_9)
{α : Type u_1} [has_compl α] [has_sup α] [has_inf α] (a b : α) : α
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) (S : add_subsemigroup N) : add_subsemigroup M
(G : Type u) [group G] : monoid G
(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A) : category_theory.ess_surj (category_theory.shift_functor C i)
{α : Type u_1} [circular_preorder α] {a b c : α} : has_sbtw.sbtw a b c ↔ has_sbtw.sbtw c a b
(p : ℕ) [fact (nat.prime p)] : field (zmod p)
{α : Type u} {β : Type v} [preorder β] (f : α → β) (l : filter α) (a : α) : Prop
(R : Type u) (n : ℕ) (A : Type u_1) [comm_semiring R] [semiring A] [algebra R A] [topological_space A] [has_continuous_mul A] : continuous_multilinear_map R (λ (i : fin n), A) A
{R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_principal_ideal_ring R] : fintype (class_group R K)
(α : Type u) [group α] : Prop
{ι : Type u} {X : Type v} [topological_space X] (i : ι) (s : set X) : bump_covering ι X s
{α : Type u_2} [decidable_eq α] [add_monoid α] : add_monoid (finset α)
{m : Type u_2} {n : Type u_3} {α : Type v} [decidable_eq n] (M : matrix m n α) (j : n) (b : m → α) : matrix m n α
{R : Type u_1} [comm_ring R] [char_zero R] : function.injective (λ (n : ℕ), polynomial.cyclotomic n R)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {t : category_theory.limits.cone (category_theory.limits.pair X Y)} (ht : category_theory.limits.is_limit t) : category_theory.limits.binary_bicone X Y
{α : Type u} {β : α → Type v} (a : α) (b : β a) : finmap β
 : sign_type → sign_type → Prop
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] {X : C} [category_theory.simple X] : division_ring (category_theory.End X)
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : canonically_ordered_add_monoid (lie_subalgebra R L)
{α : Type u} : complete_lattice (topological_space α)
 : subsingleton (fin 0)
(J : Type v) (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop
{G : Type u_1} [group G] (H : subgroup G) : subgroup G
(α : Type u) {β : Type v} [add_group α] [add_action α β] (b : β) : add_subgroup α
{α : Type u_1} [cancel_comm_monoid_with_zero α] [nontrivial α] [unique_factorization_monoid α] : normalization_monoid α
(β : Type u_2) [pseudo_metric_space β] [monoid β] [has_lipschitz_mul β] : nnreal
{α : Type u_1} [decidable_eq α] [fintype α] : ∅.up_shadow = ∅
{α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) : is_compact (s ∩ t)
(p : ℕ) : decidable (nat.prime p)
(α : Type u_7) (β : Type u_8) [lattice α] [lattice β] [bounded_order α] [bounded_order β] : Type (max u_7 u_8)
{p : ℕ} : padic_val_int p 0 = 0
(α : Sort u) [h₁ : inhabited α] [subsingleton α] : unique α
(α : Type u) : Type u
(p : ℕ) [hp : fact (nat.prime p)] (n : ℕ) : ℕ → mv_polynomial (fin 1 × ℕ) ℤ
{M : Type u_1} [add_zero_class M] {c : add_con M} : ↑0 = 0
(G : Type u) : Type u
(n : ℕ) : mv_polynomial ℕ ℤ
{F : Type u} [decidable_eq F] [field F] (s : finset F) (x : F) : polynomial F
{α : Type u_1} (r : ℕ) (A : set (finset α)) : Prop
{M : Type u_1} [add_comm_monoid M] (x : M) (N' : Type u_2) [add_comm_monoid N'] : Type (max u_1 u_2)
{a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd c = 1) : a ∣ b
{α : Type u} [pseudo_metric_space α] (a : α) : has_nndist.nndist a a = 0
 : Type
(α : Type u_1) [monoid α] : setoid α
 : nat.arithmetic_function ℕ
(G : Type u_1) [add_comm_group G] [topological_space G] [topological_add_group G] : uniform_space G
 : Type u
 : Type
{α : Type u_1} {β : Type u_2} (f : α → β) [has_lt β] (h : well_founded has_lt.lt) [nonempty α] : α
{α : Type u_1} [U : uniform_space α] (m : pseudo_emetric_space α) (H : uniformity α = uniformity α) : pseudo_emetric_space α
{M : Type u_1} [has_mul M] (r : M → M → Prop) : M → M → Prop
{F : pfunctor} [inhabited F.M] [decidable_eq F.A] (i : F.Idx) (x : F.M) : F.M
{M₀ : Type u_1} [mul_zero_one_class M₀] (h : 0 = 1) (a : M₀) : a = 0
 : Type
 : set algebraic_geometry.Scheme
{M : Type u_1} [semigroup M] : semigroup (ultrafilter M)
{M : Type u_1} [comm_monoid M] (x : M) : Type u_1
{ι : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [fintype ι] (b : basis ι R M) [fintype R] : fintype M
{α : Type u_1} [preorder α] [order_bot α] [locally_finite_order α] (b : α) : multiset α
(α : Type u_6) (β : Type u_7) [has_mul α] [has_add α] [has_le α] [has_mul β] [has_add β] [has_le β] : Type (max u_6 u_7)
(α : Type u) : Type u
{R : Type u} [ring R] (self : subring R) : subsemiring R
 : has_le pgame
{α : Type u} [topological_space α] (K : compact_exhaustion α) : compact_exhaustion α
(C : Type u) [category_theory.category C] (X : Top) : Type (max v u)
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (k : ℕ) : lie_ideal R L
{α : Type u} {β : Type v} {γ : Type u_1} [topological_space α] [topological_space β] [topological_space γ] {f : β → γ} (hf : continuous f) : continuous (λ (x : α × β), f x.snd)
{α : Type u} [decidable_eq α] [canonically_ordered_comm_semiring α] [nontrivial α] : comm_semiring (with_top α)
 : category_theory.faithful Compactum_to_CompHaus
{α : Type u} [group α] : complete_semilattice_Inf (group_topology α)
{α : Type u} {β : Type v} [topological_space α] [topological_space β] [totally_disconnected_space β] {f : α → β} (h : continuous f) : connected_components α → β
{a b c : Prop} : a ∧ b ∨ c ↔ (a ∨ c) ∧ (b ∨ c)
(A : Type u_4) [add_monoid A] [topological_space A] : continuous_add_monoid_hom A (A × A)
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (c : con M) (f : M → N) : con N
{R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J A : matrix n n R₃) : Prop
{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α} : b ≤ a⁻¹ * c → a * b ≤ c
{α : Type} (p : parser α) : Prop
{M : Type u_1} [monoid M] {x : M} : x ∈ powers x
 : Type (u+1)
{R : Type v} [comm_ring R] {A : matrix (fin 0) (fin 0) R} : A.det = 1
{α : Type u_1} {β : Type u_2} [denumerable α] [denumerable β] : denumerable (α ⊕ β)
{α : Sort u} (p : α → Prop) : Prop
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1
{α : Type u_1} (a : α) (s : finset α) (h : a ∉ s) : finset α
{a b : ereal} : -a ≤ b ↔ -b ≤ a
{α : Type u_2} [has_mul α] [fintype α] [decidable_eq α] : decidable_pred is_square
{K : Type u_2} [division_ring K] : seq (generalized_continued_fraction.pair K) → ℕ → K
(𝕜 : Type u_1) (E : Type u_2) [ordered_semiring 𝕜] [add_comm_monoid E] [module 𝕜 E] [topological_space E] : Prop
{M : Type u_1} [has_one M] [has_mul M] [has_inv M] : ℤ → M → M
{α : Type u_2} [topological_space α] [add_monoid α] [has_continuous_add α] : has_continuous_add (add_units α)
(A : Type u_9) (B : Type u_10) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : Type (max u_10 u_9)
{C : Type u} [category_theory.category C] (X Y : C) : Type (max u v)
{α : Type u} (x : α) : dlist α
{M : Type u_1} [add_monoid M] (a : M) (u : add_units M) : is_add_unit (a + ↑u) ↔ is_add_unit a
{α : Type u_1} [preorder α] (a : α) : upper_set α
{α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} [topological_space β] [preorder ι] (f : measure_theory.filtration ι m) (u : ι → α → β) : Prop
 : Type
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.has_zero_morphisms C
(C : Type u) [category_theory.category C] : Type (max u u_1)
 : ℕ → num
(R : Type u_1) [comm_ring R] : Prop
(G : Type u) : Type u
(a : cardinal) : a < 2 ^ a
{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_5} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] (p : seminorm_family 𝕜 E ι) [nonempty ι] : add_group_filter_basis E
{ι : Type u_1} {Z : ι → Type u_2} [Π (i : ι), ordered_add_comm_monoid (Z i)] : ordered_add_comm_monoid (Π (i : ι), Z i)
{α : Type u_1} (s t : multiset α) : Prop
{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_add_order x) (i : η) : is_of_fin_add_order (x i)
(G : Type w) [topological_space G] : Type w
(R : Type u) : Type u
(C : Type u) [category_theory.category C] : Prop
 : pos_num → pos_num → pos_num
{ι : Type u_1} {α : Type u_3} [preorder ι] [linear_order α] {u : ι → α} (h : monotone u) (H : ¬bdd_above (set.range u)) : filter.tendsto u filter.at_top filter.at_top
{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a < b + c → a - b < c
(R : Type u) : Type u
(X : Type u_1) [topological_space X] [h : topological_space.pseudo_metrizable_space X] : pseudo_metric_space X
{p n : ℕ} : padic_val_int p ↑n = padic_val_nat p n
(α : Type u_1) : Type u_1
{H : Type u_1} [topological_space H] {H' : Type u_3} [topological_space H'] (G : structure_groupoid H) (G' : structure_groupoid H') (P : (H → H') → set H → H → Prop) : Prop
(R : Type u) [semiring R] : Prop
{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ ≤ b⁻¹ ↔ b ≤ a
(C : Type (u+1)) : Type (u+1)
{G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] [locally_compact_space G] : measure_theory.measure G
(R : Type u) (L : Type v) (L' : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] : Type (max v w)
{α : Type u} [comm_group α] : is_group_hom has_inv.inv
 : num → num
{α : Type u} [uniform_space α] {s : set α} (h : totally_bounded s) : totally_bounded (closure s)
 : filter.tendsto (λ (x : ℝ), x ^ ((-1) / x)) filter.at_top (nhds 1)
{𝕜 : Type u_3} [field 𝕜] {r : ℕ} (M : matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜) : list (matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜)
{α : Type u} [topological_space α] {f : filter α} : is_closed {x : α | cluster_pt x f}
{α : Type u} [preorder α] {a b : α} (h : a ≤ b) : ¬b < a
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J → C) [category_theory.limits.has_biproduct F] : category_theory.limits.bicone F
(α : Type u) : Type u
{α : Type u_1} {β : Type u_2} [cancel_comm_monoid_with_zero α] [normalized_gcd_monoid α] (s : finset β) (f : β → α) : α
{α : Type u_1} [encodable α] : ℕ → option (list α)
{α : Type u_2} [add_comm_semigroup α] : add_comm_semigroup (set α)
{α : Type u_3} [preorder α] : filter α
{α : Type u} {f g : α → α} {x : α} (hf : function.is_fixed_pt f x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt (f ∘ g) x
(α : Type u) [add_monoid α] : Type u
(p : ℕ) [fact (nat.prime p)] (a : ℤ) : ℤ
 : ordinal
{V : Type u} (G : simple_graph V) (n : ℕ) : Prop
 : list bool → ℕ
 : nzsnum → nzsnum
(R : Type u_1) [comm_ring R] : ℕ → polynomial R
{ι : Type u_1} {R : Type u_2} {A : Type u_3} [comm_ring R] [comm_ring A] [algebra R A] (B : ι → submodule R A) : Prop
{M : Type u_1} [add_monoid M] {ι : Sort u_2} {s : ι → set M} (h : ∀ (y : ι), is_add_submonoid (s y)) : is_add_submonoid (set.Inter s)
{α : Type u} [decidable_eq α] (l₁ l₂ : list α) : bool
(α : Sort u) (β : Sort v) : Sort (max 1 u v)
(C : Type u) [category_theory.category C] : Prop
(Γ : Type u_1) (T : Type u_2) [topological_space T] [has_vadd Γ T] : Prop
(f : pSet → pSet) : pSet → pSet
{ι : Sort u_1} {ι' : Sort u_2} {α : Type u_3} [complete_lattice α] {s : ι → α} (hs : complete_lattice.independent s) (f : ι' → ι) (hf : function.injective f) : complete_lattice.independent (s ∘ f)
(α : Type u) [u : uniform_space α] : set (α × α)
(𝕂 : Type u_1) {𝔸 : Type u_2} [field 𝕂] [ring 𝔸] [algebra 𝕂 𝔸] [topological_space 𝔸] [topological_ring 𝔸] (x : 𝔸) : 𝔸
(C : Type u₁) : Type u₁
{P : ℤ → Prop} [decidable_pred P] (b : ℤ) (Hb : ∀ (z : ℤ), P z → z ≤ b) (Hinh : ∃ (z : ℤ), P z) : {ub // P ub ∧ ∀ (z : ℤ), P z → z ≤ ub}
(S : Type u_1) (R : out_param (Type u)) [non_assoc_semiring R] [set_like S R] : Type
 : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b}
{ι : Type u} (f : ι → ordinal → ordinal) (o : ordinal) : ordinal
 : pos_num → ℕ → num
(k : Type u₁) (G : Type u₂) [semiring k] : Type (max u₂ u₁)
{α : Type u_1} (q : trunc α) : semiquot α
 : znum → pos_num
{α : Sort u_1} (a : erased (erased α)) : erased α
{α : Type u} [group α] [has_lt α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a
{α : Sort u_1} [is_empty α] (p : α → Prop) : is_empty (subtype p)
{α : Type u} [topological_space α] {s : set α} : dense (closure s) ↔ dense s
(M₀ : Type u_4) : Type u_4
{α : Type u_1} (l : list (lists α)) : lists α
{𝕜 : Type u_1} {V : Type u_2} [normed_field 𝕜] [add_comm_group V] [module 𝕜 V] (e : enorm 𝕜 V) : emetric_space V
(α : Type u) (lt : α → α → Prop) : Prop
{α : Type} [random α] : io α
{α : Type u_1} [decidable_eq α] (a : α) : list α → ℕ
{K : Type u} [division_ring K] : group_with_zero K
{R : Type u_1} [has_mul R] (c : R) : Prop
{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : a < 0 → 0 < -a
{α : Sort u} : α → id α
(C : Type u) [category_theory.category C] : Prop
(p : ℕ) [fact (nat.prime p)] {a : ℤ} (ha0 : ↑a ≠ 0) : zmod.legendre_sym p a = 1 ↔ is_square ↑a
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X → Y} [sequential_space X] : continuous f ↔ seq_continuous f
{α : Type u} [preorder α] {a b c : α} (hab : a = b) (hbc : b ≤ c) : a ≤ c
(𝕜 : Type u_1) (E : Type u_2) [comm_semiring 𝕜] [topological_space 𝕜] [has_continuous_add 𝕜] [has_continuous_const_smul 𝕜 𝕜] [add_comm_monoid E] [module 𝕜 E] [topological_space E] : Type (max u_2 u_1)
{R : Type u_1} [comm_ring R] : comm_ring (clifford_algebra 0)
{α : Type u_1} [measurable_space α] (m : measure_theory.measure (measure_theory.measure α)) : measure_theory.measure α
{α : Type u} (s : wseq α) : computation (option α)
{α : Type u_1} {β : Type u_2} (s : set (α → β)) (t : set α) : set β
(F : Type u_2) (α : Type u_3) (β : Type u_4) [topological_space α] [pseudo_metric_space β] : Type (max u_2 u_3 u_4)
{α : Type u_1} : regular_expression α → language α
{R : Type u} [non_assoc_semiring R] : complete_lattice (subsemiring R)
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Type (max v u)
{α : Type u_1} [measurable_space α] (f : filter α) : Prop
{α : Type u_1} [conditionally_complete_linear_order α] {a : α} : conditionally_complete_linear_order {x // a ≤ x}
{X : Type u_1} (to_prod : X × X) : Bipointed
 : Type
{H : Type u} (M : Type u_2) [topological_space H] [topological_space M] [charted_space H M] (G : structure_groupoid H) : set (local_homeomorph M H)
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : module.ray R M) : M
{F : Type u_1} (α : Type u_3) (β : Type u_4) [linear_order α] [lattice β] [order_hom_class F α β] : lattice_hom_class F α β
(E : Type u_8) [add_comm_group E] [topological_space E] [topological_add_group E] : continuous_add_monoid_hom E E
{G : Type u_1} (P : Type u_2) [add_group G] [add_torsor G P] (v : G) : equiv.perm P
{P : ℤ → Prop} {m : ℤ} (h0 : P m) (h1 : ∀ (n : ℤ), m ≤ n → P n → P (n + 1)) (n : ℤ) : m ≤ n → P n
(M : Type u) : Type u
{α : Type u} {β : Type v} [group α] [group β] (f : α → β) : Prop
{X : Type u} [lattice X] [jordan_holder_lattice X] (s₁ s₂ : composition_series X) (h : s₁.top = s₂.bot) : composition_series X
 : Type
{M : Type u_4} [add_zero_class M] (self : add_submonoid M) : add_subsemigroup M
{X : Type u_1} (Y : Type u_2) [topological_space X] [mul_zero_one_class Y] {U : set X} (hU : is_clopen U) : locally_constant X Y
(G : pgame) : Prop
{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] : ¬is_smul_regular M 0 ↔ nontrivial M
{n : ℕ} (c : composition n) : finset (fin (n + 1))
(C : Type u₁) [category_theory.category C] (D : Type u₁) [category_theory.category D] : category_theory.category (C × D)
(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [topological_space α] [preorder α] [topological_space β] [preorder β] : Type (max u_6 u_7 u_8)
{α : Type u_1} (n : ℕ) (s : multiset α) : multiset (multiset α)
{α : Type u} [topological_space α] : totally_disconnected_space α ↔ ∀ (x : α), connected_component x = {x}
{α : Type u} : dlist α → list α
{α : Type u_1} : ordnode α → α → ordnode α → α → ordnode α → ordnode α
{H : Type u} [topological_space H] (PG : pregroupoid H) : structure_groupoid H
{X : Type u_1} [topological_space X] (s : set X) : Prop
 : Type
{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : f 0 = 0
{α : Type u} {β : Type v} (f : α → β) : seq1 α → seq1 β
(A : Type u_2) [comm_ring A] [is_domain A] : Prop
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (f : X → Y) : Prop
{α : Type u_1} [has_zero α] [linear_order α] (a : α) : {x // 0 ≤ x}
{α : Type u_1} (a : α) [subsingleton α] : fintype α
{α : Type u} [pseudo_emetric_space α] {s t : set α} (h : s ⊆ t) : emetric.diam s ≤ emetric.diam t
(α : Type u_2) [complete_lattice α] : frame_hom α α
(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite : finite_dimensional K L] : algebra.is_algebraic K L
{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.reduce L₁ = free_group.reduce L₂) : free_group.mk L₁ = free_group.mk L₂
{α : Type u} [preorder α] {f : ℕ → α} (hf : monotone f) (n : ℕ) {x : α} (h1 : f n < x) (h2 : x < f (n + 1)) (a : ℕ) : f a ≠ x
{α : Type u_1} [decidable_eq α] (l : list α) (H : ∀ (x : α), x ∈ l) : fintype α
{M : Type u_1} [add_semigroup M] : add_semigroup (ultrafilter M)
 : Type
{𝕂 : Type u_1} [is_R_or_C 𝕂] : has_strict_deriv_at (exp 𝕂) 1 0
{α : Type u_1} {β : Type u_2} [tα : topological_space α] [tβ : topological_space β] (f : α → β) : Prop
{V : Type u_1} (G : simple_graph V) (u v : V) : ℕ
(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : ↑(finite_dimensional.finrank K V) = module.rank K V
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{α : Type u_1} {β : Type u_2} {f : α → β} {r : setoid β} : setoid.comap f r = setoid.ker (quotient.mk ∘ f)
 : znum → znum → znum
(C : Type u) [category_theory.category C] [category_theory.essentially_small C] : Type w
(ds : list ℕ) : Type
{α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_nndist x s)
{α : Type u} (c : omega_complete_partial_order.chain (part α)) : part α
{G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)
{M : Type u} [has_zero M] [has_add M] : ℕ → M → M
(A : out_param (Type u)) {B : Type v} [has_quotient A B] (b : B) : Type (max u v)
{A : Type u_1} [add_monoid A] : has_faithful_smul (add_aut A) A
{m : Type u → Type u} [applicative m] {α β : Type u} (F : α → m β) : free_add_magma α → m (free_add_magma β)
(α : Type u) : Type u
{α : Type u_1} {β : Type u_2} (r : rel α β) : set α
{α : Sort u} {β : α → Sort v} (f₁ f₂ : Π (x : α), β x) : Prop
{α : Type u} (r : α → α → Prop) [is_antisymm α r] {a b : α} : r a b → r b a → a = b
{α : Type u_1} (s : multiset α) : multiset {x // x ∈ s}
 : ℕ
(a o : ordinal) (f : Π (b : ordinal), b < o → ordinal) : Prop
{α : Type u_1} [decidable_eq α] [lattice α] [bounded_order α] [is_simple_order α] : boolean_algebra α
(R : Type u) [comm_semiring R] [local_ring R] : ideal R
(m m' : Type u → Type v) (n n' : Type u → Type w) : Type (max (u+1) v w)
(p : ℕ) [fact (nat.prime p)] (a : ℤ) : zmod.legendre_sym p a = zmod.legendre_sym p (a % ↑p)
{α : Type u_1} : list (list α) → list (list α)
 : ℤ → ℤ → ℤ
{α : Type u} {β : α → Sort v} (s : set α) (f g : Π (i : α), β i) [Π (j : α), decidable (j ∈ s)] (i : α) : β i
(K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1
(α : Sort u) : Sort (max u 1)
{G :{G : Type u_1} [sub_neg_monoid G] [measurable_space G] [has_measurable_add G] (g : G) : measurable (λ (h : G), h - g)
 : Type
{α : Type u} {m : Type u → Type v} [monad m] [alternative m] (tac : α → m punit) : list α → m α
{α : Type u} [uniform_space α] (a : α) : Cauchy α
(G : Type u) : Type u
{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) (t : ordnode α) : option ℕ
(α : Type u_2) : Type u_2
(R : Type u) (M : Type v) (M₂ : Type w) [semiring R] [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module R M₂] : submodule R (M × M₂)
(α : Type u_1) : Type u_1
(α : Type u_1) [finite α] : fintype α
(α : Type u_1) [topological_space α] : filter α
(M : Type u_1) (N : Type u_2) [add_monoid M] [add_monoid N] : Type (max u_2 u_1)
{α : Type u_1} : list (option α) → list α
{X : Type u} [topological_space X] (x₀ x₁ : X) : Type u
{R : Type u_4} [linear_ordered_ring R] (a : R) : 0 ≤ a ^ 2
{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_succ_n : generalized_continued_fraction.int_fract_pair K} (succ_nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n) : 1 ≤ ifp_succ_n.b
{α : Type u} {β : Type v} (f : α → β) (s : set α) : Prop
{n : ℕ} (F : typevec n → Type u_2) [mvfunctor F] : Prop
{n : Type u_1} {R : Type u₂} [decidable_eq n] [comm_ring R] (t : matrix.transvection_struct n R) : matrix.transvection_struct n R
{α : Type u} {β : Type v} [h : can_lift α β] : can_lift (list α) (list β)
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) : Type v
{R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] [fintype R] : fintype S
(X : Type u_3) [topological_space X] : Prop
(C : Type u) [category_theory.category C] : Prop
(Γ₀ : Type u_1) [linear_ordered_comm_group_with_zero Γ₀] : topological_space Γ₀
{n : ℕ} (i j : Σ (a : composition n), composition a.length) : i = j ↔ i.fst.blocks = j.fst.blocks ∧ i.snd.blocks = j.snd.blocks
 : pgame → pgame → Prop
{R : Type u} [non_assoc_semiring R] (s : subsemiring R) {x y : R} : x ∈ s → y ∈ s → x + y ∈ s
{α : Type u_1} [topological_space α] [polish_space α] : polish_space (ℕ → α)
(α : Type v) [small α] : Type w
{α : Type v} {m l r : ℕ} (A : matrix (fin m) (fin (l + r)) α) : matrix (fin m) (fin r) α
 : pos_num → pos_num → pos_num
{α : Type u_1} (a : α) (n : ℕ) : multiset α
{C : Sort u_1} : empty → C
(α : Type u) : Type u
{γ : Type u_3} [topological_space γ] [compact_space γ] [t2_space γ] : uniform_space γ
{α : Type u_1} (β : α → Type u_2) (a : α) (h : a ∈ ∅) : β a
{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) (s : finmap β) : finmap β
{α : Type u} [linear_order α] (a b : α) : set α
{α : Type u_1} (S : set (set α)) : set α
(M : Type u_1) (N : Type u_2) [semiring M] [semiring N] : Type (max u_1 u_2)
{G : Type u_1} [group G] : is_descending_central_series (lower_central_series G)
(α : Type u_1) : Type u_1
(G : pgame) : Prop
{α : Type u_1} (p : pmf α) : measure_theory.outer_measure α
{X : Type u_1} [topological_space X] (x y : X) : Prop
(G : Type u) [add_group G] : add_monoid G
(F : Type u_9) (α : Type u_10) (β : Type u_11) [add_monoid α] [add_monoid β] [topological_space α] [topological_space β] : Type (max u_10 u_11 u_9)
{α : Type u_1} [has_compl α] [has_sup α] [has_inf α] (a b : α) : α
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) (S : add_subsemigroup N) : add_subsemigroup M
(G : Type u) [group G] : monoid G
(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A) : category_theory.ess_surj (category_theory.shift_functor C i)
{α : Type u_1} [circular_preorder α] {a b c : α} : has_sbtw.sbtw a b c ↔ has_sbtw.sbtw c a b
(p : ℕ) [fact (nat.prime p)] : field (zmod p)
{α : Type u} {β : Type v} [preorder β] (f : α → β) (l : filter α) (a : α) : Prop
(R : Type u) (n : ℕ) (A : Type u_1) [comm_semiring R] [semiring A] [algebra R A] [topological_space A] [has_continuous_mul A] : continuous_multilinear_map R (λ (i : fin n), A) A
{R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_principal_ideal_ring R] : fintype (class_group R K)
(α : Type u) [group α] : Prop
{ι : Type u} {X : Type v} [topological_space X] (i : ι) (s : set X) : bump_covering ι X s
{α : Type u_2} [decidable_eq α] [add_monoid α] : add_monoid (finset α)
{m : Type u_2} {n : Type u_3} {α : Type v} [decidable_eq n] (M : matrix m n α) (j : n) (b : m → α) : matrix m n α
{R : Type u_1} [comm_ring R] [char_zero R] : function.injective (λ (n : ℕ), polynomial.cyclotomic n R)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {t : category_theory.limits.cone (category_theory.limits.pair X Y)} (ht : category_theory.limits.is_limit t) : category_theory.limits.binary_bicone X Y
{α : Type u} {β : α → Type v} (a : α) (b : β a) : finmap β
 : sign_type → sign_type → Prop
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] {X : C} [category_theory.simple X] : division_ring (category_theory.End X)
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : canonically_ordered_add_monoid (lie_subalgebra R L)
{α : Type u} : complete_lattice (topological_space α)
 : subsingleton (fin 0)
(J : Type v) (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop
{G : Type u_1} [group G] (H : subgroup G) : subgroup G
(α : Type u) {β : Type v} [add_group α] [add_action α β] (b : β) : add_subgroup α
{α : Type u_1} [cancel_comm_monoid_with_zero α] [nontrivial α] [unique_factorization_monoid α] : normalization_monoid α
(β : Type u_2) [pseudo_metric_space β] [monoid β] [has_lipschitz_mul β] : nnreal
{α : Type u_1} [decidable_eq α] [fintype α] : ∅.up_shadow = ∅
{α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) : is_compact (s ∩ t)
(p : ℕ) : decidable (nat.prime p)
(α : Type u_7) (β : Type u_8) [lattice α] [lattice β] [bounded_order α] [bounded_order β] : Type (max u_7 u_8)
{p : ℕ} : padic_val_int p 0 = 0
(α : Sort u) [h₁ : inhabited α] [subsingleton α] : unique α
(α : Type u) : Type u
(p : ℕ) [hp : fact (nat.prime p)] (n : ℕ) : ℕ → mv_polynomial (fin 1 × ℕ) ℤ
{M : Type u_1} [add_zero_class M] {c : add_con M} : ↑0 = 0
(G : Type u) : Type u
(n : ℕ) : mv_polynomial ℕ ℤ
{F : Type u} [decidable_eq F] [field F] (s : finset F) (x : F) : polynomial F
{α : Type u_1} (r : ℕ) (A : set (finset α)) : Prop
{M : Type u_1} [add_comm_monoid M] (x : M) (N' : Type u_2) [add_comm_monoid N'] : Type (max u_1 u_2)
{a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd c = 1) : a ∣ b
{α : Type u} [pseudo_metric_space α] (a : α) : has_nndist.nndist a a = 0
 : Type
(α : Type u_1) [monoid α] : setoid α
 : nat.arithmetic_function ℕ
(G : Type u_1) [add_comm_group G] [topological_space G] [topological_add_group G] : uniform_space G
 : Type u
 : Type
{α : Type u_1} {β : Type u_2} (f : α → β) [has_lt β] (h : well_founded has_lt.lt) [nonempty α] : α
{α : Type u_1} [U : uniform_space α] (m : pseudo_emetric_space α) (H : uniformity α = uniformity α) : pseudo_emetric_space α
{M : Type u_1} [has_mul M] (r : M → M → Prop) : M → M → Prop
{F : pfunctor} [inhabited F.M] [decidable_eq F.A] (i : F.Idx) (x : F.M) : F.M
{M₀ : Type u_1} [mul_zero_one_class M₀] (h : 0 = 1) (a : M₀) : a = 0
 : Type
 : set algebraic_geometry.Scheme
{M : Type u_1} [semigroup M] : semigroup (ultrafilter M)
{M : Type u_1} [comm_monoid M] (x : M) : Type u_1
{ι : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [fintype ι] (b : basis ι R M) [fintype R] : fintype M
{α : Type u_1} [preorder α] [order_bot α] [locally_finite_order α] (b : α) : multiset α
(α : Type u_6) (β : Type u_7) [has_mul α] [has_add α] [has_le α] [has_mul β] [has_add β] [has_le β] : Type (max u_6 u_7)
(α : Type u) : Type u
{R : Type u} [ring R] (self : subring R) : subsemiring R
 : has_le pgame
{α : Type u} [topological_space α] (K : compact_exhaustion α) : compact_exhaustion α
(C : Type u) [category_theory.category C] (X : Top) : Type (max v u)
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (k : ℕ) : lie_ideal R L
{α : Type u} {β : Type v} {γ : Type u_1} [topological_space α] [topological_space β] [topological_space γ] {f : β → γ} (hf : continuous f) : continuous (λ (x : α × β), f x.snd)
{α : Type u} [decidable_eq α] [canonically_ordered_comm_semiring α] [nontrivial α] : comm_semiring (with_top α)
 : category_theory.faithful Compactum_to_CompHaus
{α : Type u} [group α] : complete_semilattice_Inf (group_topology α)
{α : Type u} {β : Type v} [topological_space α] [topological_space β] [totally_disconnected_space β] {f : α → β} (h : continuous f) : connected_components α → β
{a b c : Prop} : a ∧ b ∨ c ↔ (a ∨ c) ∧ (b ∨ c)
(A : Type u_4) [add_monoid A] [topological_space A] : continuous_add_monoid_hom A (A × A)
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (c : con M) (f : M → N) : con N
{R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J A : matrix n n R₃) : Prop
{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α} : b ≤ a⁻¹ * c → a * b ≤ c
{α : Type} (p : parser α) : Prop
{M : Type u_1} [monoid M] {x : M} : x ∈ powers x
 : Type (u+1)
{R : Type v} [comm_ring R] {A : matrix (fin 0) (fin 0) R} : A.det = 1
{α : Type u_1} {β : Type u_2} [denumerable α] [denumerable β] : denumerable (α ⊕ β)
{α : Sort u} (p : α → Prop) : Prop
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1
{α : Type u_1} (a : α) (s : finset α) (h : a ∉ s) : finset α
{a b : ereal} : -a ≤ b ↔ -b ≤ a
{α : Type u_2} [has_mul α] [fintype α] [decidable_eq α] : decidable_pred is_square
{K : Type u_2} [division_ring K] : seq (generalized_continued_fraction.pair K) → ℕ → K
(𝕜 : Type u_1) (E : Type u_2) [ordered_semiring 𝕜] [add_comm_monoid E] [module 𝕜 E] [topological_space E] : Prop
{M : Type u_1} [has_one M] [has_mul M] [has_inv M] : ℤ → M → M
{α : Type u_2} [topological_space α] [add_monoid α] [has_continuous_add α] : has_continuous_add (add_units α)
(A : Type u_9) (B : Type u_10) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : Type (max u_10 u_9)
{C : Type u} [category_theory.category C] (X Y : C) : Type (max u v)
{α : Type u} (x : α) : dlist α
{M : Type u_1} [add_monoid M] (a : M) (u : add_units M) : is_add_unit (a + ↑u) ↔ is_add_unit a
{α : Type u_1} [preorder α] (a : α) : upper_set α
{α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} [topological_space β] [preorder ι] (f : measure_theory.filtration ι m) (u : ι → α → β) : Prop
 : Type
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.has_zero_morphisms C
(C : Type u) [category_theory.category C] : Type (max u u_1)
 : ℕ → num
(R : Type u_1) [comm_ring R] : Prop
(G : Type u) : Type u
(a : cardinal) : a < 2 ^ a
{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_5} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] (p : seminorm_family 𝕜 E ι) [nonempty ι] : add_group_filter_basis E
{ι : Type u_1} {Z : ι → Type u_2} [Π (i : ι), ordered_add_comm_monoid (Z i)] : ordered_add_comm_monoid (Π (i : ι), Z i)
{α : Type u_1} (s t : multiset α) : Prop
{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_add_order x) (i : η) : is_of_fin_add_order (x i)
(G : Type w) [topological_space G] : Type w
(R : Type u) : Type u
(C : Type u) [category_theory.category C] : Prop
 : pos_num → pos_num → pos_num
{ι : Type u_1} {α : Type u_3} [preorder ι] [linear_order α] {u : ι → α} (h : monotone u) (H : ¬bdd_above (set.range u)) : filter.tendsto u filter.at_top filter.at_top
{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a < b + c → a - b < c
(R : Type u) : Type u
(X : Type u_1) [topological_space X] [h : topological_space.pseudo_metrizable_space X] : pseudo_metric_space X
{p n : ℕ} : padic_val_int p ↑n = padic_val_nat p n
(α : Type u_1) : Type u_1
{H : Type u_1} [topological_space H] {H' : Type u_3} [topological_space H'] (G : structure_groupoid H) (G' : structure_groupoid H') (P : (H → H') → set H → H → Prop) : Prop
(R : Type u) [semiring R] : Prop
{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ ≤ b⁻¹ ↔ b ≤ a
(C : Type (u+1)) : Type (u+1)
{G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] [locally_compact_space G] : measure_theory.measure G
(R : Type u) (L : Type v) (L' : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] : Type (max v w)
{α : Type u} [comm_group α] : is_group_hom has_inv.inv
 : num → num
{α : Type u} [uniform_space α] {s : set α} (h : totally_bounded s) : totally_bounded (closure s)
 : filter.tendsto (λ (x : ℝ), x ^ ((-1) / x)) filter.at_top (nhds 1)
{𝕜 : Type u_3} [field 𝕜] {r : ℕ} (M : matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜) : list (matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜)
{α : Type u} [topological_space α] {f : filter α} : is_closed {x : α | cluster_pt x f}
{α : Type u} [preorder α] {a b : α} (h : a ≤ b) : ¬b < a
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J → C) [category_theory.limits.has_biproduct F] : category_theory.limits.bicone F
(α : Type u) : Type u
{α : Type u_1} {β : Type u_2} [cancel_comm_monoid_with_zero α] [normalized_gcd_monoid α] (s : finset β) (f : β → α) : α
{α : Type u_1} [encodable α] : ℕ → option (list α)
{α : Type u_2} [add_comm_semigroup α] : add_comm_semigroup (set α)
{α : Type u_3} [preorder α] : filter α
{α : Type u} {f g : α → α} {x : α} (hf : function.is_fixed_pt f x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt (f ∘ g) x
(α : Type u) [add_monoid α] : Type u
(p : ℕ) [fact (nat.prime p)] (a : ℤ) : ℤ
 : ordinal
{V : Type u} (G : simple_graph V) (n : ℕ) : Prop
 : list bool → ℕ
 : nzsnum → nzsnum
(R : Type u_1) [comm_ring R] : ℕ → polynomial R
{ι : Type u_1} {R : Type u_2} {A : Type u_3} [comm_ring R] [comm_ring A] [algebra R A] (B : ι → submodule R A) : Prop
{M : Type u_1} [add_monoid M] {ι : Sort u_2} {s : ι → set M} (h : ∀ (y : ι), is_add_submonoid (s y)) : is_add_submonoid (set.Inter s)
{α : Type u} [decidable_eq α] (l₁ l₂ : list α) : bool
(α : Sort u) (β : Sort v) : Sort (max 1 u v)
(C : Type u) [category_theory.category C] : Prop
(Γ : Type u_1) (T : Type u_2) [topological_space T] [has_vadd Γ T] : Prop
(f : pSet → pSet) : pSet → pSet
{ι : Sort u_1} {ι' : Sort u_2} {α : Type u_3} [complete_lattice α] {s : ι → α} (hs : complete_lattice.independent s) (f : ι' → ι) (hf : function.injective f) : complete_lattice.independent (s ∘ f)
(α : Type u) [u : uniform_space α] : set (α × α)
(𝕂 : Type u_1) {𝔸 : Type u_2} [field 𝕂] [ring 𝔸] [algebra 𝕂 𝔸] [topological_space 𝔸] [topological_ring 𝔸] (x : 𝔸) : 𝔸
(C : Type u₁) : Type u₁
{P : ℤ → Prop} [decidable_pred P] (b : ℤ) (Hb : ∀ (z : ℤ), P z → z ≤ b) (Hinh : ∃ (z : ℤ), P z) : {ub // P ub ∧ ∀ (z : ℤ), P z → z ≤ ub}
(S : Type u_1) (R : out_param (Type u)) [non_assoc_semiring R] [set_like S R] : Type
 : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b}
{ι : Type u} (f : ι → ordinal → ordinal) (o : ordinal) : ordinal
 : pos_num → ℕ → num
(k : Type u₁) (G : Type u₂) [semiring k] : Type (max u₂ u₁)
{α : Type u_1} (q : trunc α) : semiquot α
 : znum → pos_num
{α : Sort u_1} (a : erased (erased α)) : erased α
{α : Type u} [group α] [has_lt α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a
{α : Sort u_1} [is_empty α] (p : α → Prop) : is_empty (subtype p)
{α : Type u} [topological_space α] {s : set α} : dense (closure s) ↔ dense s
(M₀ : Type u_4) : Type u_4
{α : Type u_1} (l : list (lists α)) : lists α
{𝕜 : Type u_1} {V : Type u_2} [normed_field 𝕜] [add_comm_group V] [module 𝕜 V] (e : enorm 𝕜 V) : emetric_space V
(α : Type u) (lt : α → α → Prop) : Prop
{α : Type} [random α] : io α
{α : Type u_1} [decidable_eq α] (a : α) : list α → ℕ
{K : Type u} [division_ring K] : group_with_zero K
{R : Type u_1} [has_mul R] (c : R) : Prop
{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : a < 0 → 0 < -a
{α : Sort u} : α → id α
(C : Type u) [category_theory.category C] : Prop
(p : ℕ) [fact (nat.prime p)] {a : ℤ} (ha0 : ↑a ≠ 0) : zmod.legendre_sym p a = 1 ↔ is_square ↑a
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X → Y} [sequential_space X] : continuous f ↔ seq_continuous f
{α : Type u} [preorder α] {a b c : α} (hab : a = b) (hbc : b ≤ c) : a ≤ c
(𝕜 : Type u_1) (E : Type u_2) [comm_semiring 𝕜] [topological_space 𝕜] [has_continuous_add 𝕜] [has_continuous_const_smul 𝕜 𝕜] [add_comm_monoid E] [module 𝕜 E] [topological_space E] : Type (max u_2 u_1)
{R : Type u_1} [comm_ring R] : comm_ring (clifford_algebra 0)
{α : Type u_1} [measurable_space α] (m : measure_theory.measure (measure_theory.measure α)) : measure_theory.measure α
{α : Type u} (s : wseq α) : computation (option α)
{α : Type u_1} {β : Type u_2} (s : set (α → β)) (t : set α) : set β
(F : Type u_2) (α : Type u_3) (β : Type u_4) [topological_space α] [pseudo_metric_space β] : Type (max u_2 u_3 u_4)
{α : Type u_1} : regular_expression α → language α
{R : Type u} [non_assoc_semiring R] : complete_lattice (subsemiring R)
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Type (max v u)
{α : Type u_1} [measurable_space α] (f : filter α) : Prop
{α : Type u_1} [conditionally_complete_linear_order α] {a : α} : conditionally_complete_linear_order {x // a ≤ x}
{X : Type u_1} (to_prod : X × X) : Bipointed
 : Type
{H : Type u} (M : Type u_2) [topological_space H] [topological_space M] [charted_space H M] (G : structure_groupoid H) : set (local_homeomorph M H)
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : module.ray R M) : M
{F : Type u_1} (α : Type u_3) (β : Type u_4) [linear_order α] [lattice β] [order_hom_class F α β] : lattice_hom_class F α β
(E : Type u_8) [add_comm_group E] [topological_space E] [topological_add_group E] : continuous_add_monoid_hom E E
{G : Type u_1} (P : Type u_2) [add_group G] [add_torsor G P] (v : G) : equiv.perm P
{P : ℤ → Prop} {m : ℤ} (h0 : P m) (h1 : ∀ (n : ℤ), m ≤ n → P n → P (n + 1)) (n : ℤ) : m ≤ n → P n
(M : Type u) : Type u
{α : Type u} {β : Type v} [group α] [group β] (f : α → β) : Prop
{X : Type u} [lattice X] [jordan_holder_lattice X] (s₁ s₂ : composition_series X) (h : s₁.top = s₂.bot) : composition_series X
 : Type
{M : Type u_4} [add_zero_class M] (self : add_submonoid M) : add_subsemigroup M
{X : Type u_1} (Y : Type u_2) [topological_space X] [mul_zero_one_class Y] {U : set X} (hU : is_clopen U) : locally_constant X Y
(G : pgame) : Prop
{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] : ¬is_smul_regular M 0 ↔ nontrivial M
{n : ℕ} (c : composition n) : finset (fin (n + 1))
(C : Type u₁) [category_theory.category C] (D : Type u₁) [category_theory.category D] : category_theory.category (C × D)
(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [topological_space α] [preorder α] [topological_space β] [preorder β] : Type (max u_6 u_7 u_8)
{α : Type u_1} (n : ℕ) (s : multiset α) : multiset (multiset α)
{α : Type u} [topological_space α] : totally_disconnected_space α ↔ ∀ (x : α), connected_component x = {x}
{α : Type u} : dlist α → list α
{α : Type u_1} : ordnode α → α → ordnode α → α → ordnode α → ordnode α
{H : Type u} [topological_space H] (PG : pregroupoid H) : structure_groupoid H
{X : Type u_1} [topological_space X] (s : set X) : Prop
 : Type
{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : f 0 = 0
{α : Type u} {β : Type v} (f : α → β) : seq1 α → seq1 β
(A : Type u_2) [comm_ring A] [is_domain A] : Prop
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (f : X → Y) : Prop
{α : Type u_1} [has_zero α] [linear_order α] (a : α) : {x // 0 ≤ x}
{α : Type u_1} (a : α) [subsingleton α] : fintype α
{α : Type u} [pseudo_emetric_space α] {s t : set α} (h : s ⊆ t) : emetric.diam s ≤ emetric.diam t
(α : Type u_2) [complete_lattice α] : frame_hom α α
(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite : finite_dimensional K L] : algebra.is_algebraic K L
{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.reduce L₁ = free_group.reduce L₂) : free_group.mk L₁ = free_group.mk L₂
{α : Type u} [preorder α] {f : ℕ → α} (hf : monotone f) (n : ℕ) {x : α} (h1 : f n < x) (h2 : x < f (n + 1)) (a : ℕ) : f a ≠ x
{α : Type u_1} [decidable_eq α] (l : list α) (H : ∀ (x : α), x ∈ l) : fintype α
{M : Type u_1} [add_semigroup M] : add_semigroup (ultrafilter M)
 : Type
{𝕂 : Type u_1} [is_R_or_C 𝕂] : has_strict_deriv_at (exp 𝕂) 1 0
{α : Type u_1} {β : Type u_2} [tα : topological_space α] [tβ : topological_space β] (f : α → β) : Prop
{V : Type u_1} (G : simple_graph V) (u v : V) : ℕ
(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : ↑(finite_dimensional.finrank K V) = module.rank K V
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{α : Type u_1} {β : Type u_2} {f : α → β} {r : setoid β} : setoid.comap f r = setoid.ker (quotient.mk ∘ f)
 : znum → znum → znum
(C : Type u) [category_theory.category C] [category_theory.essentially_small C] : Type w
(ds : list ℕ) : Type
{α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_nndist x s)
{α : Type u} (c : omega_complete_partial_order.chain (part α)) : part α
{G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)
{M : Type u} [has_zero M] [has_add M] : ℕ → M → M
(A : out_param (Type u)) {B : Type v} [has_quotient A B] (b : B) : Type (max u v)
{A : Type u_1} [add_monoid A] : has_faithful_smul (add_aut A) A
{m : Type u → Type u} [applicative m] {α β : Type u} (F : α → m β) : free_add_magma α → m (free_add_magma β)
(α : Type u) : Type u
{α : Type u_1} {β : Type u_2} (r : rel α β) : set α
{α : Sort u} {β : α → Sort v} (f₁ f₂ : Π (x : α), β x) : Prop
{α : Type u} (r : α → α → Prop) [is_antisymm α r] {a b : α} : r a b → r b a → a = b
{α : Type u_1} (s : multiset α) : multiset {x // x ∈ s}
 : ℕ
(a o : ordinal) (f : Π (b : ordinal), b < o → ordinal) : Prop
{α : Type u_1} [decidable_eq α] [lattice α] [bounded_order α] [is_simple_order α] : boolean_algebra α
(R : Type u) [comm_semiring R] [local_ring R] : ideal R
(m m' : Type u → Type v) (n n' : Type u → Type w) : Type (max (u+1) v w)
(p : ℕ) [fact (nat.prime p)] (a : ℤ) : zmod.legendre_sym p a = zmod.legendre_sym p (a % ↑p)
{α : Type u_1} : list (list α) → list (list α)
 : ℤ → ℤ → ℤ
{α : Type u} {β : α → Sort v} (s : set α) (f g : Π (i : α), β i) [Π (j : α), decidable (j ∈ s)] (i : α) : β i
(K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1
(α : Sort u) : Sort (max u 1)
{G :{α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), c ≤ f x) : c ≤ infi f
{M : Type u_1} [monoid M] (x : M) : set M
(α : Type u) [topological_space α] : Prop
{M : Type u_4} [topological_space M] [add_monoid M] [has_continuous_add M] (s : add_submonoid M) : add_submonoid M
(K : Type u) [hring : comm_ring K] : Type u
{K : Type u} [field K] (s : subfield K) : submonoid K
(k G : Type u) [ring k] [monoid G] : Type (u+1)
(v : multiset ℕ) (h : ∀ (p : ℕ), p ∈ v → nat.prime p) : prime_multiset
{α : Type u_1} : has_star.star 1 = 1
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (s : set R) : submodule R M
{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) (s : set α) : Prop
(α : Type u_2) [linear_ordered_ring α] : Type u_2
{M : Type u_1} [has_mul M] : has_top (subsemigroup M)
 : onote → ℕ → onote
 : Set → Set
(n p : ℕ) (l : list ℕ) : Prop
{n : ℕ} (P : mvpfunctor (n + 1)) (α : typevec n) : Type u
(α : Type u_1) [partial_order α] : closure_operator α
(α : Type u_1) [has_le α] : has_btw α
 : filter.tendsto real.exp filter.at_top filter.at_top
{α : Type u_1} (l : list α) : list (multiset α)
(F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] (S : set E) : intermediate_field F E
{α : Type u} [monoid α] (a b : α) [invertible a] [invertible b] : invertible (a * b)
{α : Sort u_1} {β : Sort u_2} (f : α → β) (s : β → β → Prop) (x y : α) : Prop
{α : Sort u_1} (x : fin 0) : α
(α : Type u_1) : Type u_1
(R : Type u) (S : Type v) [semiring R] [semiring S] (p : ℕ) [char_p R p] [char_p S p] : char_p (R × S) p
 : Type 1
{α : Type u_2} [add_semigroup α] : add_semigroup (set α)
{α : Type u_1} [topological_space α] [locally_compact_space α] [nonempty α] : nonempty (topological_space.positive_compacts α)
{M₀ : Type u_1} {M₀' : Type u_3} [mul_zero_one_class M₀] [nontrivial M₀] [has_zero M₀'] [has_one M₀'] (f : M₀' → M₀) (zero : f 0 = 0) (one : f 1 = 1) : nontrivial M₀'
{α : Type u_2} {G₀ : Type u_4} [topological_space α] [group_with_zero G₀] [mul_action G₀ α] [has_continuous_const_smul G₀ α] {c : G₀} (hc : c ≠ 0) : is_closed_map (λ (x : α), c • x)
 : Type
{C : Type u} [category_theory.category C] {X : C} (hX : category_theory.limits.is_zero X) : category_theory.limits.is_initial X
{α : Type u_2} [comm_monoid α] : multiset α → α
{α : Type u} {β : Type v} (xs : list (α × β)) : list (Σ (_x : α), β)
{R : Type u_1} [linear_ordered_field R] [floor_ring R] (b : ℕ) (r : R) : ℤ
{ι : Type u_1} {α : ι → Type u_2} [Π (i : ι), has_lt (α i)] (a b : Σ (i : ι), α i) : Prop
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] : Type (max u_2 u_1)
(α : Type u_1) (β : Type u_2) (V : set (β × β)) : set ((α → β) × (α → β))
{γ : Type u_1} {β : Type u_2} (f : γ → β) (hf : function.injective f) (m : emetric_space β) : emetric_space γ
{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : has_btw.btw a b c
{α : Type u_1} [preorder α] {a b : α} (h : a ≤ b) : set.Ioi b ⊆ set.Ici a
{α : Type u_1} {M : Type u_5} [add_comm_monoid M] (s : set α) : finsum (λ (i : α), finsum (λ (H : i ∈ s), 0)) = 0
(G : Type u) : Type u
{R : Type u} [euclidean_domain R] [decidable_eq R] : R → R → R → R → R → R → R × R × R
{α : Type u_1} {β : Type u_2} [has_add α] [has_add β] (f : α → β) : Prop
 : algebraic_geometry.Scheme
{α : Type u_1} [decidable_eq α] (s t : multiset α) : multiset α
{G : Type u} {x : G} [fintype G] [group G] [decidable_eq G] : finset.image (λ (i : ℕ), x ^ i) (finset.range (order_of x)) = ↑(subgroup.zpowers x).to_finset
{α : Type uu} : list α → list α → Prop
(α : Type u_1) [complete_lattice α] : complete_lattice.is_sup_closed_compact α → complete_lattice.is_Sup_finite_compact α
{α : Type u_1} (p : α → Prop) [decidable_pred p] : list α → ℕ
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : module.ray R M) : ray_vector R M
{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red (free_group.reduce L₁) L₂) : free_group.reduce L₁ = L₂
{α : Type u_1} [has_lt α] (a b : α) : Prop
{n : ℕ} {α : Type u} {β : Type v} {m : Type v → Type u_1} [monad m] (a : array n α) (f : α → m β) : m (array n β)
{G : Type u_10} [group G] (a : G) : equiv.perm G
{R : Type u} [comm_ring R] (r : R) : topological_space.opens (prime_spectrum R)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s ⊆ ↑(affine_span k s)
{α : Type u_1} {ι : Type u_5} {m0 : measurable_space α} (f : ι → measure_theory.measure α) : measure_theory.measure α
(Γ : Type u_4) (T : Type u_5) [topological_space T] [has_vadd Γ T] : Prop
{α : Type u_1} [semigroup α] [partial_order α] [contravariant_class α α (function.swap has_mul.mul) has_le.le] : right_cancel_semigroup α
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {P Q : C} (b : category_theory.limits.binary_bicone P Q) : Type (max u v)
{k : Type u₁} {G : Type u₂} {R : Type u_1} [comm_semiring R] [semiring k] [algebra R k] [add_monoid G] : algebra R (add_monoid_algebra k G)
{α : Type u} [pseudo_emetric_space α] {x y : α} {s : set α} (h : y ∈ s) : emetric.inf_edist x s ≤ has_edist.edist x y
(C : Type u₁) [category_theory.category C] [category_theory.limits.has_terminal C] : C
(R : Type u) (M : Type v) [comm_ring R] [add_comm_group M] [module R M] : Prop
(α : Type u_1) : besicovitch.ball_package α α
{C : Type u} [category_theory.category C] (B : C) : category_theory.limits.has_terminal (category_theory.over B)
{α : Type u_1} (f g : equiv.perm α) : Prop
(R : Type u_1) [ring R] [is_domain R] [decidable_eq R] [fintype R] : division_ring R
{α : Type u_1} (l : filter α) (β : Type u_2) : Type (max u_1 u_2)
{M : Type u_1} [comm_monoid_with_zero M] (S : submonoid M) (N : Type u_2) [comm_monoid_with_zero N] : Type (max u_1 u_2)
{α : Type u} : list (α × bool) → list (α × bool) → Prop
{C : Type u₁} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (h : ¬category_theory.limits.is_zero X) : nontrivial (category_theory.subobject X)
(M : Type u_4) [add_zero_class M] : Type u_4
{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (i : ι) : topological_fiber_bundle.trivialization F Z.proj
{α : Type u_1} {G : Type u_2} [group G] [monoid α] [mul_distrib_mul_action α G] : mul_action α (subgroup G)
{α : Type u_1} : ordnode α → Prop
(k : Type u_1) {V : Type u_2} (P : Type u_3) [ring k] [add_comm_group V] [module k V] [add_torsor V P] : Type u_3
{α : Type u_1} [linear_ordered_ring α] [floor_ring α] : α → ℤ
{α : Sort u_1} {β : α → Sort u_2} (x : α) (f : Π (x : α), β x) : β x
{α : Type u} (p : α → Prop) [decidable_pred p] (s : wseq α) : computation (option α)
{P : ℤ → Prop} (Hbdd : ∃ (b : ℤ), ∀ (z : ℤ), P z → z ≤ b) (Hinh : ∃ (z : ℤ), P z) : ∃ (ub : ℤ), P ub ∧ ∀ (z : ℤ), P z → z ≤ ub
(R : Type u_1) [ring R] : polynomial.cyclotomic 0 R = 1
{α : Type u} (l : list α) : list {x // x ∈ l}
{K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x / y ∈ s
 : Type
{α : Type u} [hg : add_group α] [is_add_cyclic α] : add_comm_group α
{G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * b⁻¹
{α : Type u_1} {s t : multiset α} : s ≤ t → s ⊆ t
 : num → pos_num
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (a : R) : Prop
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C] : category_theory.limits.has_zero_object C
{α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] {n : ℕ} (hn : 1 ≤ n) : filter.tendsto (λ (x : α), x ^ -↑n) filter.at_top (nhds 0)
(C : Type u₁) [category_theory.category C] : Prop
(C : Type u) [category_theory.category C] : Type (max u w v)
{R : Type u_1} [mul_zero_class R] [nR : nontrivial R] : ¬is_left_regular 0
{α : Type u_1} (n : ℕ) (l : list α) : list (list α)
{α : Type u} (t₁ t₂ : ordnode α) : Prop
{G : Type u_1} [group G] (H K : subgroup G) : Prop
{α : Type u} [has_le α] [decidable_rel has_le.le] (f : α → option α) (x : α) : ordnode α → ordnode α
{X : Type u_1} [topological_space X] [normal_space X] (c : urysohns.CU X) : urysohns.CU X
{C : Type u} [category_theory.category C] (X : C) : Type v
{C : Type u₁} [category_theory.category C] {X : C} (S R : category_theory.sieve X) : category_theory.sieve X
{α : Type u} : seq α → lazy_list α
(α : Type u_1) : Type u_1
{G : Type u_1} [comm_group G] (K : subgroup G) (g : multiset G) : (∀ (a : G), a ∈ g → a ∈ K) → g.prod ∈ K
(C : Type u) [category_theory.category C] : Type (max u v)
{α : Type u} (g : set (set α)) : filter α
(K : Type u) [field K] (V : Type u) [add_comm_group V] [module K V] [finite_dimensional K V] : FinVect K
{α : Type u} {β : Type v} [semigroup β] (f : α → β) (x : free_semigroup α) : β
(G : out_param (Type u_1)) (P : Type u_2) : Type (max u_1 u_2)
{α : Type u_1} {β : Type u_2} (e : local_equiv α β) (s : set α) (t : set β) : Prop
(p q n : ℕ) [fact (nat.prime p)] (hq : q ≠ 0) : padic_val_nat p (q ^ n) = n * padic_val_nat p q
{α : Type u_1} : partial_order (subtype setoid.is_partition)
{α : Type u} [add_comm_monoid α] (a b : α) (hab : a + b = 0) : add_units α
{α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) (s : set α) (x : α) : Prop
 : Type
 : Type
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] [topological_space α] (F : ι → α → β) (f : α → β) (p : filter ι) (s : set α) : Prop
{α : Type u_1} : list α → option α
(R : Type u) {A : Type v} [comm_semiring R] [ring A] [algebra R A] (a : A) : set R
(α : Type u_6) [topological_space α] [measurable_space α] : Prop
{α : Type u} {t : Type u → Type u} [traversable t] : t α → list α
(M : Type u) : Type u
{α : Type u} [pseudo_metric_space α] {s t : set α} : metric.Hausdorff_dist s t = metric.Hausdorff_dist t s
{R : Type u_1} [comm_ring R] {S : submonoid R} {P : Type u_2} [comm_ring P] [algebra R P] : has_coe (fractional_ideal S P) (submodule R P)
(X : algebraic_geometry.Scheme) : Prop
(α : Type u_1) (β : Type u_2) [has_add β] : add_hom β (α → β)
{α : Type u} [add_group α] : has_Inf (add_group_topology α)
{n : ℕ} (P : mvpfunctor (n + 1)) : mvpfunctor n
{α : Type u_1} [comm_semiring α] (E : linear_recurrence α) (u : ℕ → α) : Prop
(k G : Type u) [field k] [monoid G] : Type (u+1)
(α : Type u) {β : Type v} [add_monoid α] [add_action α β] (b : β) : set β
(n : ℕ) : ring_char (zmod n) = n
{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] (f : M → R) (x y : M) : R
(R : Type u_1) (M : Type u_2) [subsingleton R] [semiring R] [add_comm_monoid M] [module R M] : is_noetherian R M
{α : Type u_1} {β : Type u_2} (f : α → β) (m : measurable_space α) : measurable_space β
(R : Type u_1) [comm_ring R] (p : ℕ) [is_domain R] [char_p R p] : char_p (fraction_ring R) p
 : ℕ → ℕ × ℕ
{α : Type u_1} (r : α → α → Prop) (a : α) : α → Prop
{P : pfunctor} (x : P.W) : P.B x.head → P.W
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_limit (category_theory.limits.pair X Y)] : category_theory.split_epi category_theory.limits.prod.snd
{α : Type u_1} : ordnode α → α → ordnode α → ordnode α
(ι : Type u_1) : Type u_1
{M : Type u_1} [comm_monoid M] (S : submonoid M) : ℕ → localization S → localization S
{K : Type u} [field K] (self : subfield K) : subring K
(ι : Type u_1) (𝕜 : Type u_2) [is_R_or_C 𝕜] (E : Type u_3) [inner_product_space 𝕜 E] : Type (max u_1 u_2 u_3)
{α : Type u_1} [add_semigroup α] [partial_order α] [contravariant_class α α has_add.add has_le.le] : add_left_cancel_semigroup α
{α : Type u_1} [preorder α] (a : α) : lower_set α
(M : Type u_1) [measurable_space M] [has_sup M] : Prop
{α : Type u} [has_le α] [decidable_rel has_le.le] (f : option α → option α) (x : α) : ordnode α → ordnode α
{α : Sort u_1} {β : Sort u_2} (q : trunc α) (f : α → trunc β) : trunc β
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [finite_dimensional 𝕜 E] {n : ℕ} (hn : finite_dimensional.finrank 𝕜 E = n) : basis (fin n) 𝕜 E
{α : Type u} [uniform_space α] (s : set α) : Prop
(α : Type u) : Type u
(A : Type u_1) (R : Type u_2) (B : Type u_3) [comm_ring R] [comm_semiring A] [comm_ring B] [algebra R B] [algebra A B] : Prop
(n b : ℕ) : (n + 1) / (b + 2) < n + 1
{α : Type u} {n : ℕ} (h : α) (t : fin n → α) : fin n.succ → α
{P : Type u_1} [semilattice_sup P] [is_directed P ge] : has_inf (order.ideal P)
{α : Sort u_1} {C : trunc α → Sort u_3} [∀ (a : α), subsingleton (C (trunc.mk a))] (q : trunc α) (f : Π (a : α), C (trunc.mk a)) : C q
{α : Type u_1} {β : Type u_2} [emetric_space α] [pseudo_emetric_space β] {f : α → β} (h : antilipschitz_with 0 f) : subsingleton α
{R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_right_regular a) : is_right_regular (b * a) ↔ is_right_regular b
{α : Type u} [group α] : partial_order (group_topology α)
(C : Type u) [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_binary_coproducts C] : category_theory.monoidal_category C
{α : Type u_1} [decidable_eq α] : multiset α → finset (list α)
{M : Type u_1} [has_mul M] (S : subsemigroup M) (s : set M) (hs : s = ↑S) : subsemigroup M
(C : Type u) [category_theory.category C] : Prop
(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom A (A × B)
(α : Type u_1) [topological_space α] [preorder α] : Prop
{R : Type u} {M : Type v} [has_zero M] (r : R) : triv_sq_zero_ext R M
{R : Type u_1} [comm_ring R] [is_domain R] [normalized_gcd_monoid R] (p : polynomial R) : R
{α : Type u_1} [preorder α] [pred_order α] {a : α} : ¬is_min a → order.pred a < a
{R : Type u} [non_assoc_semiring R] (self : subsemiring R) : submonoid R
(L : first_order.language) : Prop
{α : Type u_2} {β : Type u_3} [decidable_eq β] [has_vadd α β] : has_vadd (finset α) (finset β)
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (s : set L) : lie_subalgebra R L
(X : Type u_1) [has_mul X] [has_zero X] [has_lt X] [has_le X] : Prop
{α : Type u} [pseudo_emetric_space α] {x : α} {s : set α} (h : x ∈ s) : emetric.inf_edist x s = 0
{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] : is_smul_regular M 0 ↔ subsingleton M
(x y : pgame) : Prop
{α : Type u_2} [decidable_eq α] [subtraction_comm_monoid α] : subtraction_comm_monoid (finset α)
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) : Prop
(C : Type u_1) [category_theory.category C] [category_theory.monoidal_category C] : Sort u_3
 : matrix (fin 7) (fin 7) ℤ
{G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x
(α : Type u_1) (β : Type u_2) [pseudo_emetric_space α] [pseudo_emetric_space β] : Type (max u_1 u_2)
(p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_sym p a ^ 2 = 1
(𝕜 : Type u_1) (E : Type u_2) (ι : Type u_5) [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] : Type (max u_5 u_2)
{C : Type u} [category_theory.category C] (X Y : algebraic_geometry.PresheafedSpace C) : Type v
(γ : Type) : Type
{R : Type u_1} [comm_ring R] [is_domain R] (P : cubic R) : multiset R
{α : Type u} [preorder α] {a b c : α} : b < c → a ≤ b → a < c
{R : Type u_1} [mul_zero_class R] (h : is_left_regular 0) : subsingleton R
{ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] (w : free_product.word M) : option ι
{R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) ↔ group.fg G
(α : Type u_2) [cancel_comm_monoid_with_zero α] : Type u_2
{n : ℕ} (α β : typevec n) : typevec n
{ι : Type u_1} {α : Type u_2} {s : ι → set α} (hs : indexed_partition s) : Type u_2
{α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} (h : a ≤ b) : a - b = 0
(G : Type u_1) [group G] : galois_insertion subgroup.closure coe
(α : Sort u_4) : Prop
{α : Type u} {β : Type v} [add_semigroup β] (f : α → β) (x : free_add_semigroup α) : β
(α : Type u_1) (β : Type u_2) : Type u_1
{H : Type u} [topological_space H] (G : structure_groupoid H) (M : Type u_5) (M' : Type u_6) [topological_space M] [topological_space M'] [charted_space H M] [charted_space H M'] : Type (max u_5 u_6)
 : Type v
(cache_ty : Type) : Type
(A : Type u_2) [comm_ring A] [is_domain A] : Prop
{α : Type u} : wseq α → wseq α → wseq α
(α : Type u_4) : Prop
{n : ℕ} {α : Type u_1} (v : vector α n) (i : fin n) (a : α) : vector α n
{a : ℕ} (a1 : 1 < a) (n : ℕ) : ℤ
(p : ℕ → Prop) : ℕ → ℕ
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) [category_theory.limits.has_binary_biproduct X Y] : C
(G : Type u_1) [monoid G] : ¬monoid.is_torsion G ↔ ∃ (g : G), ¬is_of_fin_order g
{α : Type u} {β : Type v} (f : α → β) : lazy_list α → lazy_list β
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_initial C] : category_theory.limits.has_finite_coproducts C
{α : Type u} [partial_order α] {a b : α} : a ≤ b → b ≠ a → a < b
(p : Prop) : Type
(α : Type u_2) [ordered_semiring α] : Type u_2
{n a : ℕ} (h : a < n + 1) : ↑↑a = a
{a b : ereal} (h : a ≤ -b) : b ≤ -a
{α : Type u} (s : wseq α) (n : ℕ) : computation (list α × wseq α)
{α : Type u_1} [decidable_eq α] (a : option α) : set (equiv.perm α)
{α : Type u} (p : α → Prop) [decidable_pred p] : list α → list α
(α : Type u_8) : Type u_8
(α : Type u_1) [preorder α] : Preorder
(R : Type u_1) (M : Type u_4) [semiring R] [add_comm_monoid M] [module R M] : galois_insertion (submodule.span R) coe
{ι : Type u_1} {𝕜 : Type u_3} [is_R_or_C 𝕜] {E : Type u_4} [inner_product_space 𝕜 E] [fintype ι] (b : orthonormal_basis ι 𝕜 E) : basis ι 𝕜 E
{α : Type u_1} (h : ¬infinite α) : fintype α
{α : Type u} : ordnode α → ℕ → ordnode α × ordnode α
{n : Type u_4} {α : Type u_5} [fintype n] [normed_ring α] [decidable_eq n] : normed_ring (matrix n n α)
 : Type
 : Type v
{α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α] : order.pred a ≤ order.pred b → a ≤ b
{α : Type} {rels : set (free_group α)} (x : α) : presented_group rels
{α : Type u_2} (l : filter α) : Prop
{α : Type u} [add_group α] (x : free_group α) : α
{α : Sort u_1} {ra ra' : α → α → Prop} (h : ∀ (a₁ a₂ : α), ra a₁ a₂ → ra' a₁ a₂) : quot ra → quot ra'
(H : Type u_1) [topological_space H] (G : structure_groupoid H) : has_groupoid H G
{n : ℕ} (x y : bitvec n) (b : bool) : bool × bitvec n
(α : Type u) [omega_complete_partial_order α] (s : set α) : Prop
{M : Type u_1} [add_semigroup M] : stream M → set M
{K : Type u} [field K] (s : set K) : subfield K
{α : Type u} [decidable_eq α] (L₁ : list (α × bool)) : list (list (α × bool))
(c : char) : parser unit
{C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : S ≤ J₁.close S
(x y : ℕ) : ℤ
{α : Sort u_1} (h : nonempty α) : α
(x y : ℕ) : ℤ
{R : Type u_1} {ι : Type u_2} {M : Type u_3} [ring R] [add_comm_group M] [module R M] [fintype ι] [is_artinian R M] : is_artinian R (ι → M)
{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a < -b → b < -a
(G : Type u_10) [has_involutive_inv G] : equiv.perm G
(n : Type u_1) (R : Type u₂) [decidable_eq n] [comm_ring R] [fintype n] : lie_subalgebra R (matrix n n R)
(C : Type u₁) [category_theory.category C] [category_theory.limits.has_initial C] : C
(R : Type u_1) [add_group R] [star_add_monoid R] : add_subgroup R
{ι : Type u_1} [decidable_eq ι] (A : ι → Type u_2) [add_comm_monoid ι] [Π (i : ι), add_comm_monoid (A i)] : Type (max u_1 u_2)
{α : Type u_1} [topological_space α] [non_assoc_ring α] (h : topological_semiring α) : topological_ring α
{α : Type u} [partial_order α] {a b : α} (h : a ≤ b) : a = b ∨ a < b
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape ι} (C : homological_complex V c) [category_theory.limits.has_zero_object V] (j : ι) : V
{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) (h : is_unit A.det) : invertible A
(F : Type u → Type u) [functor F] [q : qpf F] : Type u
{α : Type u_1} [measurable_space α] : function.injective measure_theory.jordan_decomposition.to_signed_measure
(N i : ℕ) : ℕ
{M : Type u_1} [add_monoid M] {s : set M} {a : M} (hs : is_add_submonoid s) (h : a ∈ s) : multiples a ⊆ s
{R : Type u} [comm_ring R] (s : set R) : set (prime_spectrum R)
(L : first_order.language) (α : Type u') : ℕ → Type (max u v u')
(p : ℕ) [hp : fact (nat.prime p)] : ℕ → mv_polynomial (fin 0 × ℕ) ℤ
{α : Type u} (β : α → Type v) : Type (max u v)
{M : Type u_1} [monoid M] {s : set M} {a : M} (h : a ∈ monoid.closure s) : ∃ (l : list M), (∀ (x : M), x ∈ l → x ∈ s) ∧ l.prod = a
{α : Type u} [preorder α] {a b c : α} (hab : a < b) (hbc : b = c) : a < c
(v : ℕ → ℕ) : omega.nat.preterm → ℕ
{α : Type u_1} {r : α → α → Prop} (wf : well_founded r) (x : α) : α
(n : ℕ) : list bool
(α : Type u_1) [boolean_algebra α] : BoolAlg
{α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {f : ι → α} (H : bdd_below (set.range f)) (c : ι) : infi f ≤ f c
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) : Type u_1
{α : Type u} (l : list α) (s : stream α) : stream (list α)
{A : Type u_3} [add_group A] (s : set A) : Prop
 : parser ℕ
{α : fin 0 → Sort u} (x : fin 0) : α x
(s : finset ℕ) {n : ℕ} (h : ∀ (m : ℕ), m ∈ s → m < n) : finset (fin n)
{n : ℕ} {p : fin n → Prop} [decidable_pred p] {i : fin n} (hi : i ∈ fin.find p) {j : fin n} (hj : j < i) : ¬p j
(R : Type u_1) [comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] : free_algebra R M → free_algebra R M → Prop
{α : Type u_1} {β : Type u_2} (A : set (α → β)) : Prop
 : has_add ordinal
(p : ℕ) [fact (nat.prime p)] : Type
{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b c : α} : a + b ≤ c → a ≤ c - b
 : Type
{ι : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] (A : ι → S) (a : R) : Prop
(a : Prop) : Prop
{R : Type u_1} [ring R] (P : cubic R) : R
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1
(n : ℕ) : Type
{α : Type u} : list (α × bool) → list (α × bool) → Prop
{gen : Type u} [random_gen gen] (g : gen) (lo hi : ℕ) : ℕ × gen
{R : Type u} [non_assoc_semiring R] (s : subsemiring R) : 1 ∈ s
{α : Type u} : ordnode α → option (ordnode α × α)
{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order β] [preorder α] [order_top α] (gi : galois_insertion l u) : order_top β
{α : Type u_2} [has_involutive_neg α] : has_involutive_neg (filter α)
{α : Sort u_1} (z : bool → α) (s : bool → snum → α → α) : snum → α
{α : Sort u_1} (h : is_empty α) {p : α → Sort u_2} (a : α) : p a
 : initial_seg has_lt.lt has_lt.lt
{R : Type u} [euclidean_domain R] [decidable_eq R] (a b : R) : euclidean_domain.gcd a b = a * euclidean_domain.gcd_a a b + b * euclidean_domain.gcd_b a b
{α : Type u} (max : ℕ) (f : thunk α) : option α
{α : Type u} [has_mul α] : is_mul_hom id
{α : Type u} {β : Type v} (f : filter α) (g : filter β) : filter (α × β)
{ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] (w : free_product.word M) : free_product M
{H : Type u} [topological_space H] (G : structure_groupoid H) : Prop
(α : Type u_3) {β : Type u_4} [has_inf α] [semilattice_inf β] (b : β) : inf_hom α β
{α : Type u_1} : list α → list ℕ → list (list α)
{α : Type u} [semiring α] : is_semiring_hom id
(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : basis (fin (finite_dimensional.finrank K V)) K V
(X : Type u_5) (Y : Type u_6) [topological_space X] : Type (max u_5 u_6)
{α : Type u_1} {β : Type u_2} [decidable_eq β] [fintype α] (f : α → β) (H : function.surjective f) : fintype β
(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : minpoly A x ≠ 1
{M : Type u_5} {N : Type u_6} {P : Type u_7} [has_add M] [has_add N] [has_add P] (f : add_hom M N) (g : add_hom M P) : add_hom M (N × P)
{β : Type u_2} [topological_space β] {κ : Type u_5} {f : κ → β} (hf : function.surjective f) : dense_range f
{R : Type u_1} [ring R] [strong_rank_condition R] (n : ℕ) {m : ℕ} (v : fin m → fin n → R) : linear_independent R v → m ≤ n
 : Type
{α : Type u_1} [add_comm_group α] [topological_space α] [topological_add_group α] [t2_space α] (f : ℕ → α) : filter.tendsto (λ (i : ℕ), ∑' (k : ℕ), f (k + i)) filter.at_top (nhds 0)
 : num → num
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a + b
 : list bool → num
{m : Type u_2} {n : Type u_3} {α : Type v} {β : Type w} (M : matrix m n α) (f : α → β) : matrix m n β
{α : Type u_1} {β : α → Type u_2} [Π (a : α), fintype (β a)] [Π (a : α), encodable (β a)] [encodable α] : encodable (W_type β)
 : set upper_half_plane
 : pgame → pgame
(α : Type u_1) [t : topological_space α] [preorder α] : Prop
{α : Type u_1} [linear_order α] {r s : α} : {r}.to_colex < {s}.to_colex ↔ r < s
(α : Type u_1) [has_mul α] : Type u_1
{α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s) : is_compact (s ∩ t)
{α : Type u} [topological_space α] [locally_compact_space α] {K : set α} (hK : is_compact K) : ∃ (K' : set α), is_compact K' ∧ K ⊆ interior K'
 : ℤ → znum
{C : Type u₁} [category_theory.category C] [category_theory.monoidal_category C] (A : Mon_ C) : Mod A
{α : Type u_1} (f : α → option α) : list α → list α
{α : Type u_1} [decidable_eq α] {s : finset α} (P : finpartition s) : Prop
{α : Type u} [linear_ordered_ring α] (a b c : α) : 0 ≤ a * b ∨ 0 ≤ b * c ∨ 0 ≤ c * a
{X : Type u_1} [topological_space X] (x : X) : path x x
{γ : Type w} [semilattice_sup γ] {s t : set γ} : bdd_above s → bdd_above t → bdd_above (s ∪ t)
{γ : Type w} [semilattice_inf γ] {s t : set γ} : bdd_below (s ∪ t) ↔ bdd_below s ∧ bdd_below t
{α : Type u_1} (l : language α) : language α
{R : Type u_1} [comm_ring R] (f : polynomial R) : set (prime_spectrum R)
{R : Type u_1} [monoid R] (r : R) : Prop
(R : Type u) [ring R] [strong_rank_condition R] {ι : Type v} [fintype ι] : finite_dimensional.finrank R (ι → R) = fintype.card ι
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_limits C
(C : Type u) [category_theory.category C] [∀ {X Y : C}, category_theory.limits.has_limit (category_theory.limits.pair X Y)] : category_theory.limits.has_binary_products C
{α : Type u_1} [has_mul α] [has_le α] (a : α) : Prop
{C : Type u₁} [category_theory.category C] {T : category_theory.monad C} : category_theory.creates_limits_of_size T.forget
(R : Type u) [ring R] : Ring
 : Type
{α : Type u_2} [decidable_eq α] [mul_one_class α] : mul_one_class (finset α)
{α : Type u_1} {p : α → Prop} [decidable_pred p] {s : finset α} (h : ∀ (x : α), x ∈ s → ¬p x) : finset.filter p s = ∅
(α : Type u_1) : Type u_1
{A : Type v} [add_monoid A] (a : A) : Prop
{a b : ℕ} (w : a ∣ b) (h : b < a) : b = 0
{S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : a + b = b + a
(α : Type u_6) (β : Type u_7) [preorder α] [preorder β] : Type (max u_6 u_7)
(M : Type u_4) [has_mul M] : Type u_4
{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) : Prop
(G : Type u_10) (P : Type u_11) [add_monoid G] : Type (max u_10 u_11)
{α : Type u_1} [h : inhabited α] (l : list α) (n : ℕ) : α
{α : Type u_1} : ℕ → list α → list (list α)
{α : Type u} [lattice α] [add_comm_group α] : has_neg_part α
(R : Type u) (M : Type v) [field R] [add_comm_group M] [module R M] : Type v
{α : Type u} (p : α → Prop) [decidable_pred p] : lazy_list α → lazy_list α
(R : Type u_1) (n : ℕ) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] : Type (max u_1 u_2)
{C : Type u₁} [category_theory.category C] {X : C} (𝒮 : set (category_theory.sieve X)) : category_theory.sieve X
(L : Type u_1) [topological_space L] [lattice L] : Type
{α : Type u_3} [preorder α] : filter α
(X : Type u) [group X] : Group
{α : Type u} : ordnode α → α → α
 : Type
(F : Type u_1) (E : Type u_2) [field F] [field E] [algebra F E] [finite_dimensional F E] [is_separable F E] : power_basis F E
{L : first_order.language} (T : L.Theory) : Prop
{α : Type u_1} [preorder α] {a b : α} (h : a ≤ b) : set.Ioi b ⊆ set.Ioi a
{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : has_sbtw.sbtw b c a
(o : ordinal) (f : Π (b : ordinal), b < o → ordinal → ordinal) : ordinal → ordinal
 : num → znum
 : num → list ℕ
 : Type (u_1+1)
(α : Type u_1) : Type u_1
{R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] (a : R) : multiset R
{A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] {x : B} [nontrivial A] (hx : is_integral A x) : minpoly A x ≠ 0
{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) : X
(M : Type u_1) [add_monoid M] : add_submonoid M
(α : Type u_3) [lattice α] [bounded_order α] : bounded_lattice_hom α α
{α : Type u_1} (δ : α → Type u_2) (a : α) (H : a ∈ 0) : δ a
(x : Class) : Class
(b : ℕ) : ℕ → ℕ
{α : Type u} {β : Type v} (r : rel α β) (l₁ : filter α) (l₂ : filter β) : Prop
(X : CompHaus) : Profinite
{G : Type u_1} [add_group G] : has_inf (add_subgroup G)
{G : Type u_1} [comm_group G] : group.nilpotency_class G ≤ 1
{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : -a < b → -b < a
{R : Type u} [euclidean_domain R] [decidable_eq R] (x y : R) : R
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : submonoid A
(X : BoundedDistribLattice) : BoundedLattice
(C : Type u) [category_theory.category C] : Prop
(α : Type u) (β : Type v) [monoid α] [mul_action α β] : set β
{α : Type u_1} [circular_preorder α] (a b : α) : set α
{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) : composition_series X
{n : ℕ} {α : fin (n + 1) → Type u} (x : α 0) (p : Π (i : fin n), α i.succ) (z : α 0) : function.update (fin.cons x p) 0 z = fin.cons z p
{M : Type u_1} [has_add M] (s : set M) : add_subsemigroup M
{α : Type u_1} {ι : Sort u_4} (l : filter α) (p : ι → Prop) (s : ι → set α) : Prop
(α : Type u) : Type u
(f : name → option name) : name → name
(α : Type u_2) [fintype α] [lattice α] [bounded_order α] : complete_lattice α
 : Type
{α : Type u_1} {β : Type u_2} [partial_order α] [preorder β] [order_top β] {l : α → β} {u : β → α} (gc : galois_connection l u) : order_top α
{α : Type u} {β : Type v} [topological_space α] [preorder β] (f : α → β) (s : set α) (a : α) : Prop
{M : Type u_1} [has_add M] : has_le (add_con M)
(R : Type u_1) (C : Type u) : Type u
{M₀ : Type u_1} [mul_zero_one_class M₀] : 0 = 1 ↔ subsingleton M₀
(α : Type u_5) [T : topological_space α] : Type (max u_5 (u_6+1))
{α : Type u} {β : Type v} (f : α → β) : computation α → computation β
(C : Type u) [category_theory.category C] : Prop
(K : Type u) {V : Type v} [division_ring K] [add_comm_group V] [module K V] (s : set V) : ℕ
{C : Type u} (X Y : C) : category_theory.limits.walking_pair → C
{α : Type u_1} {β : Type u_2} (f : α → β) : sym2 α → sym2 β
(R : Type u) (A : Type v) (B : Type w) [monoid R] [non_unital_non_assoc_semiring A] [distrib_mul_action R A] [non_unital_non_assoc_semiring B] [distrib_mul_action R B] : Type (max v w)
{α : Type u_1} {β : Type u_2} (f : α → β) (r : setoid β) : setoid α
(α : Sort u) (default : α) : Sort u
(n : ℕ) : ℤ → bitvec n.succ
(α : Type u_1) [complete_lattice α] : Prop
(p : ℕ) [hp : fact (nat.prime p)] : is_absolute_value (padic_norm p)
{α : Type u} {β : Type v} {γ : Type w} (f : β → γ) : α ⊕ β → α ⊕ γ
(R : Type u_1) [rack R] : shelf_hom R (quandle.conj (rack.envel_group R))
{ι : Type u_1} {α : ι → Type u_2} (r : ι → ι → Prop) (s : Π (i : ι), α i → α i → Prop) (a b : Σ (i : ι), α i) : Prop
{α : Type u_1} [has_le α] (a : α) : Prop
{α : Type u_1} [measurable_space α] : partial_order (measure_theory.measure α)
(R : Type u) (L : Type v) (L' : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] : Type (max v w)
{α : Type u_3} [linear_ordered_add_comm_group α] : filter.tendsto has_abs.abs filter.at_top filter.at_top
{n : ℕ} (F : typevec (n + 1) → Type u) [mvfunctor F] [q : mvqpf F] (α : typevec n) : Type u
(α : Type u_3) : Type u_3
(R : CommRing) : Top
 : Type
(R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R] : ∃ (ϖ : R), prime ϖ
{α : Type u} (a : α) (f : filter α) : topological_space α
(L : first_order.language) (M : Type u_3) [L.Structure M] : Prop
(F : Type u_1) (R : Type u_2) (Γ₀ : Type u_3) [linear_ordered_comm_monoid_with_zero Γ₀] [ring R] : Type (max u_1 u_2 u_3)
{α : Type u_1} [decidable_eq α] {𝒜 : finset (finset α)} {s : finset α} : s ∈ 𝒜.shadow ↔ ∃ (t : finset α) (H : t ∈ 𝒜), s ⊆ t ∧ t.card = s.card + 1
{n : ℕ} (i : fin2 n) : mvpfunctor n
{G : Type u_1} [group G] (H : subgroup G) : subgroup G
(α : Type u_2) [has_top α] : top_hom α α
{α : Type u_1} : regular_expression α → bool
{α : Type u_1} {β : Type u_2} [has_coe α β] : has_coe (generalized_continued_fraction α) (generalized_continued_fraction β)
{n : ℕ} (P : mvpfunctor (n + 1)) : P.last.W → fin2 n → Type u
 : Type
(R : Type u_1) [comm_ring R] [is_domain R] [char_zero R] : char_zero (fraction_ring R)
{R : Type u} [euclidean_domain R] [decidable_eq R] (x y : R) : R × R
{X : Type u_2} [emetric_space X] (s : finset X) : dimH ↑s = 0
(R : Type u_1) [has_one R] [has_neg R] : Type u_1
{α : Type u} {f g : α → α} {x : α} (hf : function.is_fixed_pt f x) (h : function.left_inverse g f) : function.is_fixed_pt g x
{R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] [gcd_monoid R] (a b : R) : ∃ (x y : R), gcd_monoid.gcd a b = a * x + b * y
{α : Type u_1} (a : α) : measure_theory.outer_measure α
 : bool → bool → bool
{R : Type u} [has_zero R] [has_pow R ℕ] (x : R) : Prop
{α : Type u_1} [encodable α] (n : ℕ) : option (multiset α)
{α : Type u} [topological_space α] [fintype α] : compact_space α
{G : Type u_1} [add_group G] (K : add_subgroup G) (s : set G) (hs : s = ↑K) : add_subgroup G
{α : Type u_1} [fintype α] (p : α → Prop) [decidable_pred p] (hp : ∃! (a : α), p a) : {a // p a}
{R : Type u_2} [comm_ring R] [is_domain R] {p : R} [decidable_rel has_dvd.dvd] (hp : prime p) : add_valuation R enat
{n : ℕ} : fin2 n → ℕ
(F : Type u_1) (K : Type u_2) [field F] [ring K] [is_domain K] [algebra F K] [finite_dimensional F K] : division_ring K
(α : Type u) [topological_space α] : Type u
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) (s : set A) (hs : s = ↑S) : subalgebra R A
{R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] (S : subalgebra R A) : subring A
{α : Type u_1} {β : Type u_2} [encodable α] [encodable β] : encodable (α × β)
{α : Sort u_1} {p : α → Prop} {q : Π (x : α), p x → Prop} : (∀ (x : α) (h : p x), q x h) ↔ ∀ (x : {a // p a}), q ↑x _
{G : Type u} [monoid G] : is_of_fin_order 1
{α : Type u_2} [subtraction_monoid α] : subtraction_monoid (filter α)
(α : Type u_3) [topological_space α] : Prop
(b : bool) : pos_num → pos_num
{R₁ : Type u_4} [comm_ring R₁] {n : Type w} [fintype n] [decidable_eq n] [invertible 2] (Q : quadratic_form R₁ (n → R₁)) : matrix n n R₁
{α : Type u_1} (i : α) : poly α
 : binder_info → ℕ
{F : Type u → Type u} [functor F] (q : qpf F) : Prop
(S : Type u_4) (M : out_param (Type u_5)) [mul_one_class M] [set_like S M] : Type
{α : Type u_1} {β : Type u_2} (r : α → β → Prop) : option α → option β → Prop
{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {A B : matrix n n α} (h : B.mul A = 1) : A⁻¹ = B
{M₀ : Type u_1} [mul_zero_class M₀] : has_mul.mul 0 = function.const M₀ 0
{α : Type u_1} [metric_space α] {β : Type u} [nonempty β] (p : besicovitch.tau_package β α) : ordinal → β
{α : Type u_1} {β : Type u_2} [fintype β] (f : α → β) (H : function.injective f) : fintype α
{α : Type u_1} (a : α) (o : part α) : Prop
{α : Type u_1} {β : Type u_2} [measurable_space α] [is_empty α] : measure_theory.simple_func α β
{α : Type u_1} {β : Type u_2} : setoid (local_equiv α β)
{α : Type u} (s : set α) : is_open {u : ultrafilter α | s ∈ u}
 : Type
{α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 1
 : ℕ → ℕ
(b : ℕ) (h : 2 ≤ b) : ℕ → list ℕ
{k : Type u₁} {G : Type u₂} [semiring k] [has_mul G] : has_mul (monoid_algebra k G)
(α : Type u_2) : Type u_2
{ι : Type u_1} (M : ι → Type u_2) [Π (i : ι), monoid (M i)] : Type (max u_1 u_2)
{n : ℕ} {α : Type u_1} {β : Type u_2} (f : β → α → β) (b : β) (v : vector α n) : vector β (n + 1)
(m : Type u) (n : Type u') [fintype m] [fintype n] (α : m → n → Type v) : Type (max u u' v)
(C : Type u) [𝒞 : category_theory.category C] : Type (max u v)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : affine_subspace k P
{α : Type u_1} [generalized_boolean_algebra α] {f d : ℕ → α} (hdisj : pairwise (disjoint on d)) (hsups : partial_sups d = partial_sups f) : d = disjointed f
(α : Type u_1) [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] [normalization_monoid α] [decidable_eq (associates α)] [decidable_eq α] : normalized_gcd_monoid α
{α : Type u_2} [decidable_eq α] [add_semigroup α] : add_semigroup (finset α)
 : finset.nat.antidiagonal 0 = {(0, 0)}
 : Type
{α : Type u} {β : Type v} (f' : β → α) (f : α → β) (t : set β) : Prop
 : Type (u+1)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X : C) : Prop
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) : 0 ∈ S
{α : Type u} [preorder α] (s : set α) : α → Prop
(R : Type u_1) [comm_ring R] (n ν : ℕ) : polynomial R
{α : Type u_1} : list α → list α → list (list α)
{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : 1 ≤ a⁻¹ ↔ a ≤ 1
 : Type
{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream K
{α : Type u_1} (l₁ l₂ : list α) : Prop
{G : Type u_3} [group G] (self : subgroup G) : submonoid G
{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : -a < 0 ↔ 0 < a
{α : Type u} [topological_space α] (s : set α) : Prop
{α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β] (x : α) : continuous (λ (f : C(α, β)), ⇑f x)
{α : Type u} [non_unital_non_assoc_ring α] (k : α) (h : ∀ (x : α), k * x = 0 → x = 0) : is_left_regular k
{p : bool → Prop} [Π (b : bool), decidable (p b)] : decidable (∀ (b : bool), p b)
{ι : Type u_1} {α : ι → Type u_2} (f : Π (i : ι), filter (α i)) : filter (Π (i : ι), α i)
{α : Type u} {β : Type v} [group α] [mul_action α β] [has_faithful_smul α β] : function.injective mul_action.to_perm
{α : Type u} {β : Type v} {f : α → β} {l₁ : filter α} {l₂ : filter β} : filter.tendsto f l₁ l₂ → l₁ ≤ filter.comap f l₂
(n : simplex_category) : ℕ
(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] : galois_insertion (category_theory.pretopology.to_grothendieck C) (category_theory.pretopology.of_grothendieck C)
{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : a < b * c → b⁻¹ * a < c
(K : Type u) [division_ring K] {ι : Type v} [fintype ι] : finite_dimensional.finrank K (ι → K) = fintype.card ι
 : Type
{α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} : emetric.inf_edist x t ≤ emetric.inf_edist x s + emetric.Hausdorff_edist s t
{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : 0 ≤ ifp_n.fr
{G : Type u_1} [group G] (K : subgroup G) {l : list G} : (∀ (x : G), x ∈ l → x ∈ K) → l.prod ∈ K
{G : Type u_1} {A : Type u_2} {B : Type u_3} [group G] [mul_action G A] [monoid B] : mul_distrib_mul_action G (A → B)
(α : Type u) : Type u
(L : Type u_1) (M : Type u_2) : Type (max u_1 u_2)
 : has_pure filter
 : name → name
{α : Type u_1} [uniform_space α] {β : Type u_2} [uniform_space β] (f : α → β) : uniform_space.completion α → uniform_space.completion β
(a : Sort u) (b : Sort v) : Sort (max 1 (imax u v))
{α : Type u_1} : option α → part α
(n a b : ℤ) : Prop
(n : ℕ) : ℕ → bitvec n
(R : Type u) (A : Type v) [comm_semiring R] [semiring A] : Type (max u v)
(X Y : Type u) : category_theory.limits.colimit_cocone (category_theory.limits.pair X Y)
(t : Type u → Type u) : Type (u+1)
(M : Type u) : Type u
 : Type
{R : Type u_1} {a : R} [cancel_monoid_with_zero R] (a0 : a ≠ 0) : is_regular a
{α : Type u_2} {β : Type u_3} [add_monoid α] [add_action α β] : add_action α (set β)
{m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n
{α : Type u_1} [decidable_eq α] (s : finset α) (n : ℕ) : finset (sym α n)
(α : Type u_1) (β : Type u_2) (γ : out_param (Type u_3)) : Type (max u_1 u_2 u_3)
(o : ordinal) (f : Π (a : ordinal), a < o → ordinal) : ordinal
(Γ : Type u_1) (R : Type u_2) [partial_order Γ] [has_zero R] : Type (max u_1 u_2)
(R : Type u) [semiring R] (n : with_bot ℕ) : submodule R (polynomial R)
 : has_neg surreal
(α : Type u_1) [add_comm_group α] : Type u_1
(G : Type u) : Type u
{G : Type u_1} [group G] [topological_space G] [nonarchimedean_group G] {K : Type u_3} [group K] [topological_space K] [nonarchimedean_group K] : nonarchimedean_group (G × K)
{α : Type u} [group α] : is_group_hom id
{α : Type u_1} : lazy_list α → lazy_list α
(X : algebraic_geometry.Scheme) : Type (max (u+1) (v+1))
{A : Type u_1} {ι : Type u_2} [ring A] [nonempty ι] {B : ι → add_subgroup A} (hB : ring_subgroups_basis B) : topological_space A
{X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] (C r : nnreal) (f : X → Y) (s : set X) : Prop
{α : Type u_1} {ι : Type u_2} {f : ι → α} : function.injective f → pairwise (ne on f)
(α : Type u_1) (enum : α → ℕ) (n : ℕ) : Type u_1
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_binary_biproducts C] : subsingleton (category_theory.preadditive C)
(p : ℕ) {idx : Type u_2} [hp : fact (nat.prime p)] (Φ : mv_polynomial idx ℤ) (n : ℕ) : mv_polynomial (idx × ℕ) ℤ
(R : Type u_1) [ring R] [topological_space R] : Prop
{α : Type u} [semigroup α] [has_distrib_neg α] (a b : α) : -a ∣ b ↔ a ∣ b
{𝕜 : Type u_1} {F : Type u_3} [is_R_or_C 𝕜] [add_comm_group F] [module 𝕜 F] [c : inner_product_space.core 𝕜 F] : has_inner 𝕜 F
{α : Type u_1} [preorder α] : ordset α
 : Type
{M : Type u_6} [add_monoid M] (u : add_units M) : equiv.perm M
(a b : num) : num
(p : ℕ) [hp : fact (nat.prime p)] (n : ℕ) : mv_polynomial (fin 2 × ℕ) ℤ
 : Type (u_1+1)
{α : Type u} {β : Type v} [topological_space α] [preorder β] (f : α → β) (s : set α) (a : α) : Prop
{α : Type u} : ordnode α → ordnode α
{α : Type u} [preorder α] {a b c : α} : b = c → a ≤ b → a ≤ c
{X : Type u_2} [emetric_space X] (m : set X → ennreal) (r : ennreal) : measure_theory.outer_measure X
(α : Type u_1) [fintype α] [category_theory.small_category α] [category_theory.fin_category α] : Type
(o : ordinal) : cardinal
(α : Type u_8) : Type u_8
{K : Type u} [field K] (s : subfield K) : 0 ∈ s
(α : Type) : Type
{α : Type u_1} [has_Sup α] {ι : Sort u_2} (s : ι → α) : α
(A : Type u_4) [monoid A] [topological_space A] : continuous_monoid_hom A (A × A)
{n : ℕ} {α : Type u} (a : array (n + 1) α) : array n α
{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] [inhabited β] : inhabited (bounded_continuous_function α β)
 : Type
{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {v : n → α} : is_unit (matrix.diagonal v) ↔ is_unit v
{α : Type u} : partial_order (topological_space α)
{α : Type u_1} [has_add α] [has_lt α] [contravariant_class α α has_add.add has_lt.lt] {a b c : α} (bc : a + b < a + c) : b < c
{α : Type u_1} {β : α → Type u_2} (f : (Π (a : α), part (β a)) → Π (a : α), part (β a)) (x : α) : part (β x)
{B : Type u} [quiver B] {a b c : B} : quiver.path a b → category_theory.free_bicategory.hom b c → quiver.path a c
{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} (f : α → β) (g : α → γ) (e' : β → γ) : β → γ
(F : Sort u_1) (α : out_param (Sort u_2)) (β : out_param (α → Sort u_3)) : Sort (max 1 (imax u_1 u_2 u_3))
(n : ℕ) (R : Type u_1) [comm_ring R] [is_domain R] : polynomial R
(R : Type u₁) [comm_ring R] (p : ℕ) [hp : fact (nat.prime p)] [char_p R p] : subring (ℕ → R)
{R : Type u} [has_involutive_star R] : equiv.perm R
{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] (proj : Z → B) : Type (max u_2 u_3 u_4)
{α : Type u_2} {β : Type u_3} [has_vadd α β] : has_vadd α (filter β)
{α : Type u} [topological_space α] (s : set α) : Prop
{α : Type u_1} {ι : Type u_3} [complete_lattice α] {t : ι → α} (ht : complete_lattice.independent t) : pairwise (disjoint on t)
{α : Type u} : ℕ → lazy_list α → list α
{α : Type u_1} [preorder α] (a : α) : set α
(R : Type u_1) (S : Type u_2) [semiring R] [ordered_semiring S] : Type (max u_1 u_2)
(α : Type u_2) [has_le α] : Prop
{R : Type u_1} [comm_semiring R] {M : Type u_2} {N : Type u_3} [add_comm_group M] [add_comm_group N] [module R M] [module R N] : tensor_product.compatible_smul R ℤ M N
(G : Type u_1) [monoid G] [topological_space G] : Type u_1
{α : Type u_1} (s : set (set α)) : filter_basis α
{C : Type u} [category_theory.category_struct C] (X : C) : Type v
{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] [topological_space Z] (proj : Z → B) : Type (max u_2 u_3 u_4)
(a : Sort u) (b : Sort v) : Sort (max 1 (imax u v))
 : znum → num
(α : Type u) : Type u
(n : ℕ) : Type
{α : Type u_1} {m : measurable_space α} (s : set α) : nonempty {t // s ⊆ t ∧ measurable_set t}
{α : Type u} [ring α] {a b : α} : a ∣ b + a ↔ a ∣ b
 : matrix (fin 6) (fin 6) ℤ
(α : Type u_2) : Type u_2
(n : ℕ) : is_well_order (fin n) has_lt.lt
{α : Type u} [topological_space α] {s t : set α} (hs : dense s) (ht : dense t) (hto : is_open t) : dense (s ∩ t)
(H : Type u_4) [add_group H] : Prop
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0) : a + b ≤ 0
{τ : Type u_1} {α : Type u_2} [canonically_ordered_add_monoid τ] {ϕ : τ → α → α} {s : set α} (h : is_fw_invariant ϕ s) : is_invariant ϕ s
(R : Type u) (X : Type v) [comm_ring R] : lie_ring (free_lie_algebra R X)
{α : Type u} {β : Type v} (f : α → β → α) (a : α) (s : wseq β) : wseq α
(α : Type u) : Type u
{ι : Type u_1} {α : ι → Type u_2} [Π (i : ι), has_le (α i)] (a b : Σ (i : ι), α i) : Prop
(x : Set) : Set
{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order α] [preorder β] [order_bot β] (gi : galois_coinsertion l u) : order_bot α
{α : Sort u} {β : Sort v} {f : α → β} (hf : function.surjective f) [unique α] : unique β
(R : Type u) [comm_ring R] : Top.sheaf CommRing (algebraic_geometry.prime_spectrum.Top R)
(Γ₀ Γ₁ : Type) : Type 1
{α : Type u_1} (f : α → set α) : ¬function.surjective f
{G : Type u_1} [group G] [h : group.is_nilpotent G] : is_solvable G
 : category_theory.full Compactum_to_CompHaus
(α : Type u) [lattice α] [decidable_eq α] [decidable_rel has_le.le] [decidable_rel has_lt.lt] [is_total α has_le.le] : linear_order α
{R : Type u} [ring R] (s : subring R) {l : list R} : (∀ (x : R), x ∈ l → x ∈ s) → l.prod ∈ s
{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] (p : polynomial S) : polynomial R
{α : Type u_1} {β : Type u_2} [add_comm_monoid α] [topological_space α] (f : β → α) : Prop
{α : Type u_7} {β : Type u_8} [measurable_space α] [measurable_space β] (f : α → β) : Prop
{G : Type u_3} [add_group G] (self : add_subgroup G) : add_submonoid G
{α : Type u_1} [topological_space α] {s : set α} (h : is_open s) : is_Gδ s
(M : Type u_1) [mul_one_class M] : galois_insertion submonoid.closure coe
{α : Type u_1} (s : set α) (r : α → α → Prop) : Prop
{G : Type u_1} [group G] {N : Type u_3} [group N] (H : subgroup G) (K : subgroup N) : subgroup (G × N)
(C : Type u₁) [category_theory.category C] : Prop
(R : Type u_1) [ring R] {n : ℕ} (m : ℕ) [char_p R m] (h : m ∣ n) : algebra (zmod n) R
{α : Type u} {β : Type v} {f : α → β} {b : β} {l : list α} : b ∈ list.map f l → (∃ (a : α), a ∈ l ∧ f a = b)
{M : Type u_1} [has_add M] : complete_lattice (add_subsemigroup M)
{R : Type u_1} {a b : R} [add_semigroup R] (rra : is_add_right_regular a) (rrb : is_add_right_regular b) : is_add_right_regular (a + b)
{k : Type u₁} {G : Type u₂} [group G] [semiring k] : distrib_mul_action G (monoid_algebra k G)
(D : Type u_1) [category_theory.category D] [category_theory.abelian D] : category_theory.is_idempotent_complete D
{α : Type u_1} (S : set (set α)) : set (set α)
{α : Type u_1} (R : α → α → Prop) [decidable_rel R] : list α → list α
(p : ℕ) [hp : fact (nat.prime p)] {k : Type u_1} [field k] [is_alg_closed k] (a₁ a₂ : witt_vector p k) : k
{ι : Type u_2} [encodable ι] {F : ι → Type u_3} [Π (i : ι), metric_space (F i)] : metric_space (Π (i : ι), F i)
 : Type (u+1)
{α : Type u_1} : has_mul (language α)
{R : Type u} [comm_ring R] [is_domain R] (p : polynomial R) : multiset R
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) : Prop
{α : Type u_1} {β : Type u_2} {l : filter α} {f : α → β} {lb : filter β} : filter.tendsto f l lb → ↑f.tendsto lb
(α : Type u_1) [order.frame α] : Frame
{α : Type u_1} [preorder α] [has_add α] [has_sub α] [has_ordered_sub α] {a b : α} : a + b - b ≤ a
{M : Type u_1} [comm_monoid_with_zero M] (S : submonoid M) : localization S
{α : Sort u} {f : α → α} (h : function.involutive f) (P : Prop) [decidable P] (x : α) : f (ite P x (f x)) = ite (¬P) x (f x)
{α : Type u_1} : list (lazy_list α) → lazy_list α
 : Set → Set → Prop
{R : Type u} [comm_semigroup R] [star_semigroup R] : mul_aut R
{α : Type u_1} [preorder α] [locally_finite_order α] (a b : α) : finset α
{n : ℕ} (α : typevec n) (β : typevec n) : Type (max u_1 u_2)
{V : Type u} (G : simple_graph V) (s : set (sym2 V)) : simple_graph V
{R : Type u_1} [comm_ring R] [is_domain R] : prime power_series.X
(α : Type u_1) [complete_semilattice_Sup α] : complete_lattice α
(M : Type u_1) [measurable_space M] [has_mul M] : Prop
(C : Type u) [category_theory.category C] : Prop
{G : Type u_1} [group G] : has_bracket (subgroup G) (subgroup G)
{G : Type u_1} [group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G) : ∃ (x : G), order_of x = p
(F : Type u_1) (α : out_param (Type u_2)) (β : out_param (Type u_3)) [topological_space α] [topological_space β] : Type (max u_1 u_2 u_3)
{α : Type u_2} [semigroup α] : semigroup (set α)
(α : Type u) (β : Type v) [group α] [mul_action α β] : setoid β
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (𝒜 : ℕ → submodule R A) [graded_algebra 𝒜] : algebraic_geometry.SheafedSpace CommRing
{α : Type u_1} {n : ℕ} (a : α) (v : vector3 α n) (i : fin2 n.succ) : vector3 α n.succ
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type u_1} [is_empty ι] (hV : module.rank K V = 0) : basis ι K V
{α : Type} (F : parser α → parser α) : parser α
{R : Type u} [comm_ring R] [is_domain R] (n : ℕ) (a : R) : multiset R
{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a + b < c → a < c - b
(n : ℕ) : ℕ
{α : Type u_2} [has_one α] : has_one (filter α)
{K : Type u_1} [field K] {t : ℕ} (not_dvd : ¬ring_char K ∣ t) : invertible ↑t
(p : Prop) : Type
{α : Type u_2} {β : Type u_3} [monoid α] [mul_action α β] : mul_action α (filter β)
(R : Type u) [add_monoid R] [has_one R] (p : ℕ) : Prop
{α : Sort u_1} {p : α → Prop} (h : ∃ (a : α), p a) {C : Sort u} (H : Π (a : α), p a → C) : C
 : bool → bool → bool
{C : Type u} [category_theory.category C] [category_theory.concrete_category C] {X : Top} (F : Top.presheaf C X) : Prop
{α : Type u} {n : ℕ} (v : fin n.succ → α) : fin n → α
{S : set ordinal} (f : ordinal → ordinal) (hS : set.unbounded has_lt.lt S) : strict_mono f ∧ set.range f = S ↔ f = ordinal.enum_ord S
{α : Type u} [monoid α] : conj_classes α → set α
(A : Type u_4) [comm_ring A] [is_domain A] [unique_factorization_monoid A] {K : Type u_5} [field K] [algebra A K] [is_fraction_ring A K] (x : K) : A
{α : Type u_2} {β : Type u_3} (f : α → β) : complete_lattice_hom (set β) (set α)
{R : Type u_1} {a b : R} [semigroup R] : is_regular (a * b) ∧ is_regular (b * a) ↔ is_regular a ∧ is_regular b
{α : Type u} [has_le α] [decidable_rel has_le.le] (a b : α) : α
{α : Type u_2} : filter α
{α : Type u} (l : list α) : ℕ → ordnode α × {l' // l'.length ≤ l.length}
{α : Type u_1} [has_one α] (a : α) : simple_continued_fraction α
{α : Type u_1} {β : Type u_2} {p : α → Prop} (f : Π (a : α), p a → β) (x : option α) : (∀ (a : α), a ∈ x → p a) → option β
 : first_order.language
(α : Type u_1) [boolean_algebra α] [fintype α] : FinBoolAlg
{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : b⁻¹ * a < c → a < b * c
 : Type u_1 → PartialFun
{α : Type u_1} [ms : measurable_space α] (m : measure_theory.outer_measure α) (h : ms ≤ m.caratheodory) : measure_theory.measure α
{α : Type u_1} (p : α → Prop) [decidable_pred p] (s : finset α) : finset α
(F : Type u_1) (K : Type u_2) [comm_ring F] [ring K] [algebra F K] : Prop
(α : Type) : Type
{α : Type u_1} [has_add α] (s : set α) (a b : α) : Prop
(C : Type u) [category_theory.category C] : Prop
(p : ℕ) [hp : fact (nat.prime p)] : ℕ → mv_polynomial (fin 2 × ℕ) ℤ
{α : Type u} : ordnode α → α → ordnode α
{α : Type u_1} (n : ℕ) (v : α) : array n α
(α : Type u_2) : Type u_2
(l r : ℕ) : Prop
{α : Type u} [add_right_cancel_monoid α] : has_faithful_vadd α α
{α : Type u_1} (s : finset α) : finset (finset α)
{α : Type u_1} (f : α → α) (n : ℕ) : set α
{α : Type u_1} [linear_order α] (s : finset α) (h₂ : 1 < s.card) : s.min' _ < s.max' _
{X : Type u_1} [topological_space X] (hX : ∀ {x y : X}, x ≠ y → (∃ (U : set X) (h_clopen : is_clopen U), x ∈ U ∧ y ∉ U)) : is_totally_disconnected set.univ
(α : Type u_4) : Type u_4
{R : Type u} [ring R] : has_top (subring R)
{M : Type u_1} [comm_monoid_with_zero M] {p : M} {L : list M} (pp : prime p) : p ∣ L.prod ↔ ∃ (a : M) (H : a ∈ L), p ∣ a
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 < b) : 1 < a * b
{R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J : matrix n n R₃) [decidable_eq n] : submodule R₃ (matrix n n R₃)
{α : Type u} {β : Type v} (f : α → β) : with_bot α → with_bot β
{α : Type u} [has_le α] [decidable_rel has_le.le] : ordnode α → ordnode α → bool
{α : Type u_1} (s : cycle α) : multiset α
{α : Type u} {β : Type v} (r : rel α β) (l : filter α) : filter β
{R : Type u_1} [comm_ring R] {c₁ c₂ : R} : has_mul (quaternion_algebra R c₁ c₂)
{K : Type u_1} [field K] (R : subring K) (hR : ∀ (x : K), x ∈ R ∨ x⁻¹ ∈ R) : valuation_subring K
(α : Type u_2) : Type u_2
{α : Type u_2} [subtraction_monoid α] {a : α} (h : is_add_unit a) : add_units α
{V : Type u} [quiver V] (r : V) [quiver.rooted_connected r] (b : V) : quiver.path r b
{α : Type u} [pseudo_metric_space α] (x : α) (s : set α) : nnreal
(P : Type u) : Type u
(𝕜 : Type u_1) {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} (v : ι → E) : Prop
{α : Type u_1} (β : α → Type u_2) : Type (max u_1 u_2)
{α : Type u} [lattice α] [comm_group α] : has_pos_part α
{α : Type u_1} {β : Type u_2} (f : β → α → β) (H : right_commutative f) (b : β) (s : multiset α) : β
{α : Type u} [decidable_eq α] (a : α) : wseq α → wseq ℕ
 : pgame → Type u
{α : Type u_2} [has_div α] : has_div (set α)
{α : Type u_2} {β : Type u_3} [add_monoid α] [add_action α β] : add_action α (filter β)
{C : Type u} [category_theory.category C] (P : C) : Prop
{F : Type u_3} [field F] [fintype F] : ring_char F = 2 ↔ fintype.card F % 2 = 0
(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_colimits C] : category_theory.limits.has_finite_coproducts C
(p : Prop) [decidable p] : p ∨ ¬p
{α : Type u} : can_lift (set α) (finset α)
{α : Sort u_1} {β : Sort u_2} {p : α → Prop} {q : β → Prop} (f : α → β) (h : ∀ (a : α), p a → q (f a)) : subtype p → subtype q
{M : Type u_1} [add_monoid M] (s : add_submonoid M) {l : list M} (hl : ∀ (x : M), x ∈ l → x ∈ s) : l.sum ∈ s
{G : Type u_1} [group G] (H : subgroup G) : 1 ∈ H
(α : Type u_1) : Type u_1
{α : Type u_1} [semilattice_sup α] : galois_insertion partial_sups coe_fn
{α : Type u_1} {ι : Sort u_3} [conditionally_complete_linear_order α] {a : α} [nonempty ι] {f : ι → α} (h : infi f < a) : ∃ (i : ι), f i < a
(C : Type u_1) [category_theory.category C] : Type (max u_1 u_2)
{α : Type u_1} (r : α → α → Prop) (s : set α) (f : ℕ → α) : Prop
{α : Type u} : lazy_list α → seq α
 : Type (u_1+1)
{α : Type u_1} {β : Type u_2} (e : local_equiv α β) (s : set α) : local_equiv α β
 : (ℕ → ℕ) → Prop
{α : Type u_1} : finset α
(K : Type u) : Type u
(β : Type v) (C : Type u_1) [category_theory.category C] : Prop
{p : ℕ} (n : ℕ) {R : Type u_1} (x : witt_vector p R) : truncated_witt_vector p n R
{α : Type u} (x : α) : free_abelian_group α
(R : Type u_1) [comm_ring R] : Prop
{α : Type u} [pseudo_emetric_space α] (x y z : α) : has_edist.edist x y ≤ has_edist.edist z x + has_edist.edist z y
(α : Type u_1) : Type u_1
(S : Type u_1) [shelf S] : shelf_hom S S
{n : Type u} [decidable_eq n] [fintype n] {α : Type v} [comm_ring α] (A : matrix n n α) (b : n → α) (i : n) : α
{α : Type u_1} : ℕ → ℕ → list α → list α
{p : ℕ} {R : Type u_1} [comm_ring R] (x : witt_vector p R) : witt_vector p R
(𝕜 : Type u_1) (E : Type u_2) [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [finite_dimensional 𝕜 E] : set E
(n : ℕ) : sSet
{α : Type u_1} [preorder α] (a b : α) : set α
(L : first_order.language) : Prop
{C : fin2 0 → Sort u} (i : fin2 0) : C i
{α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0
{α : Type u_1} (s : multiset α) : multiset (multiset α × multiset α)
{α : Type u_1} [subsingleton α] (s : finset α) : s.card ≤ 1
{α : Type u_1} {ι'' : Type u_6} [preorder ι''] (s'' : ι'' → set α) : Prop
 : num → option num
{α : Type u_1} [measurable_space α] : measurable_space (measure_theory.measure α)
{R : Type u_1} {a b : R} [add_monoid R] (h : a + b = 0) : is_add_right_regular a
{α : Type u} {β : Type v} [preorder α] [preorder β] (l : α → β) (u : β → α) : Prop
{G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G → ¬monoid.is_torsion G
(k : Type u) [field k] : Type u
{n : ℕ} {α : fin n → Type u} {α' : fin n → Type v} (a : d_array n α) (f : Π (i : fin n), α i → α' i) : d_array n α'
{α : Type u_1} {g g' : generalized_continued_fraction α} : g = g' ↔ g.h = g'.h ∧ g.s = g'.s
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] : Prop
{α : Type u_1} (r : α → α → Prop) [decidable_rel r] [is_trans α r] [is_antisymm α r] [is_total α r] (s : multiset α) : list α
{C : Type u₁} [category_theory.category C] {X : C} (𝒮 : set (category_theory.sieve X)) : category_theory.sieve X
{R : Type u} [comm_monoid R] [star_semigroup R] : star_module R R
 : simps_cfg
{n : ℕ} (x y : bitvec n) : Prop
(R : Type u_1) (A : Type u_2) [comm_semiring R] [comm_semiring A] [algebra R A] (M : Type u_3) [add_comm_monoid M] [module A M] [module R M] : Type (max u_2 u_3)
 : Type
{t : Type u → Type u} {α : Type u} {f : Type u → Type u} [applicative f] [traversable t] : t (f α) → f (t α)
{α : Type u_2} [add_comm_monoid α] : add_comm_monoid (set α)
(α : Type u_2) [complete_lattice α] : complete_lattice_hom α α
 : has_one pgame
{α : Type u} [pseudo_metric_space α] {s t : set α} (h : s ⊆ t) (ht : metric.bounded t) : metric.diam s ≤ metric.diam t
{α : Type u_1} (s : finset α) : finset {x // x ∈ s}
(C : Type u₁) [category_theory.category C] : category_theory.comonad C
{α : Type u_2} [add_comm_semigroup α] : add_comm_semigroup (filter α)
{α : Type u_1} {β : Type u_2} (f : ℕ → α → β → α) : ℕ → α → list β → α
(C : Type u) [category_theory.category C] (n : ℕ) : Type (max v u)
{n : ℕ} : group (quaternion_group n)
{R : Type u} [ring R] {S T : subring R} (h : ∀ (x : R), x ∈ S ↔ x ∈ T) : S = T
 : pgame → ordinal
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {c₁ c₂ : α × β} (p : path.homotopic.quotient c₁ c₂) : path.homotopic.quotient c₁.snd c₂.snd
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) (X : C) : Type (max u v)
{α : Sort u} : well_founded empty_relation
{n : ℕ} {F : Type u → Type u} [applicative F] {α β : Type u} (f : α → F β) : vector α n → F (vector β n)
{α : Type u_1} {n : ℕ} [decidable_eq α] (s : sym α (n + 1)) (a : α) (h : a ∈ s) : sym α n
(α : Type u_1) [group_with_zero α] : GroupWithZero
{α : Type u_2} {β : Type u_3} [complete_lattice α] [complete_lattice β] (f : complete_lattice_hom α β) : bounded_lattice_hom α β
(α : Type u) (r : α → α → Prop) : Prop
 : Type
{α : Type u_1} [topological_space α] : inhabited (topological_space.closeds α)
{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) (s : set α) : Prop
{α : Type u} (P : α → Prop) : ordnode α → Prop
{α : Type u_2} [decidable_eq α] [comm_monoid α] : comm_monoid (finset α)
{α : Type u_1} (s : cycle α) : Prop
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) : β → α
(u : pnat.xgcd_type) (hr : u.r ≠ 0) : u.step.v = u.v.swap
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s ⊆ span_points k s
{α : Type u_1} [preorder α] [succ_order α] {a b : α} [no_max_order α] : order.succ a < order.succ b → a < b
{α : Type u_1} [linear_ordered_field α] {a : α} (a2 : 2 ≤ a) : (1 - 1 / a)⁻¹ ≤ 2
(B : Type u) : Type (max u (v+1) (w+1))
{n : ℕ} (F : typevec (n + 1) → Type u_1) [mvfunctor F] [q : mvqpf F] (α : typevec n) : Type u_1
{α : Type u_1} (f : list α → list α) : ℕ → list α → list α
(M : Type u_2) [has_mul M] : group (mul_aut M)
(X : Type v) [topological_space X] : Prop
(α : Type u) [ring α] : Prop
{α : Type u_1} [β : normed_comm_ring α] : semi_normed_comm_ring α
 : Type (u_1+1)
{α : Type u_1} [preorder α] (a b : α) : Prop
{α : Sort u_1} {β : Sort u_2} (h : is_empty α) (a : α) : β
{α : Type u_1} [decidable_eq α] (l : list α) : finset α
{α : Type u_1} [lattice α] [order_bot α] {a b : α} (P : finpartition a) (h : a = b) : finpartition b
(α : Type u_1) : Type u_1
{α : Type u_3} [preorder α] (n : ℕ) [grade_min_order (fin n) α] : grade_min_order ℕ α
{α : Type u} (s : wseq α) (n : ℕ) : wseq α
{Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ) : turing.list_blank.cons l.head l.tail = l
(α : Type u_1) [uniform_space α] : Type u_1
(R : Type u) [non_assoc_semiring R] : Type u
{R : Type u} [semiring R] (n : ℕ) (a : R) : polynomial R
{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (b : B) : topological_fiber_bundle.trivialization F Z.proj
{α : Type uu} (r : α → α → Prop) [decidable_rel r] : list α → list α
 : list omega.ee → omega.clause → omega.clause
{α : Type u_1} {β : Type u_2} {γ : Type u_3} (r : rel α β) (s : rel β γ) : rel α γ
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop
(u v : binder_info) : bool
{M : Type u_1} [monoid M] {s : set M} (h : is_submonoid s) : submonoid M
(b x : ordinal) : ordinal
{α : Type u} [preorder α] (s : set α) : Prop
{E : ℕ → Type u_1} (x : Π (n : ℕ), E n) (s : set (Π (n : ℕ), E n)) : ℕ
(a b : Prop) : Prop
{b x c : ordinal} (b1 : 1 < b) (x0 : 0 < x) : b ^ c ≤ x ↔ c ≤ ordinal.log b x
{A : Type u_3} [add_group A] (s : set A) : Prop
 : function.injective fin
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (c : add_con M) (d : add_con N) : add_con (M × N)
{α : Type u_1} [inhabited α] (n : ℕ) : list α → list α
{M : Type u_1} [mul_one_class M] (c : con M) : con.ker c.mk' = c
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : submodule k V
(α : Type u) : Type u
{n : Type u_3} {R : Type u_6} [fintype n] [add_comm_monoid R] (A : matrix n n R) : R
{α : Type u} [topological_space α] {ι : Type u_1} (x : α) (F : filter ι) (u : ι → α) : Prop
(T : Type u) [topological_space T] : category_theory.grothendieck_topology (topological_space.opens T)
 : Type
{R : Type u} {M : Type v} [ring R] [add_comm_group M] {module_M : module R M} (p : submodule R M) : add_subgroup M
(α : Type u_1) [fintype α] [nonempty α] : pmf α
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (f : X → Y) : Prop
{α : Type u_1} {β : Type u_2} {ι : Type u_3} [linear_order ι] (u : ι → α → β) (τ : α → ι) : ι → α → β
(G : Type u_1) [group G] : subgroup G
{G : Type w} [topological_space G] [has_inv G] [has_continuous_inv G] {ι : Type u_1} : has_continuous_inv (ι → G)
 : parser ℕ
{n : ℕ} {x : ℕ × ℕ} : x ∈ list.nat.antidiagonal n ↔ x.fst + x.snd = n
{α : Type u_1} [complete_lattice α] (k : α) : Prop
(ι : Type v) : Type v
(α : Type u_1) [has_zero α] [has_one α] (n : ℕ) : matrix.circulant (λ (i : fin n), ite (↑i = 0) 1 0) = 1
 : Type
{M : Type u} [monoid M] (a : M) : a ^ 2 = a * a
(α : Type u) : Type u
{M : Type u_1} (S : set M) [semigroup M] : subsemigroup M
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (a : R) : Prop
{P : Type u_1} [preorder P] [order_bot P] : order_bot (order.ideal P)
{C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_kernels C] [category_theory.normal_mono_category C] : category_theory.limits.has_equalizers C
{α : Type u} {β : Sort u_1} (f : β → α → β) : β → ordnode α → β
{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) : Prop
{α : Sort u₁} {β : Sort u₂} (g : β → α) (f : α → β) : Prop
(C : Type u) [category_theory.category C] [category_theory.limits.has_colimits_of_size C] : category_theory.limits.has_colimits_of_size C
(α : Type u) [topological_space α] : Prop
{α : Type uu} (r : α → α → Prop) [decidable_rel r] : list α → list α → list α
{α : Type u_1} [denumerable α] : denumerable (plift α)
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop
(α : Type u_1) : enat
(𝕜 : Type u_5) [normed_field 𝕜] {E : Type u_1} {F : Type u_2} [semi_normed_ring E] [semi_normed_ring F] [normed_algebra 𝕜 E] [normed_algebra 𝕜 F] : normed_algebra 𝕜 (E × F)
(o : onote) : Prop
{α : Type u} : seq α → wseq α
{F : Type u_1} [field F] (S : set F) : set F
(R : Type u) : Type u
{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : 0 ≤ -a → a ≤ 0
{α : Type u_1} [t : topological_space α] (s : set α) : Prop
(α : Type u_7) (β : Type u_8) [has_inf α] [has_inf β] [has_top α] [has_top β] : Type (max u_7 u_8)
{R : Type u} [ring R] (s : subring R) : 0 ∈ s
{K : Type u} [hring : comm_ring K] : ratfunc K
(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : ↑⊥ = ∅
{α : Type u_1} [comm_semigroup α] {a b : α} (c : α) (h : c * a = b) : a ∣ b
{K : Type u_1} [decidable_eq K] {Γ : K → Type u_2} : Type (max u_1 u_2)
(α : Type u_5) (β : Type u_6) [topological_space α] [topological_space β] : Type (max u_5 u_6)
{α : Type u_1} (p : α → Prop) [decidable_pred p] : lazy_list α → option α
{M : Type u} [mul_one_class M] (x : M) : semiconj_by 1 x x
{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1
{α : Type u_2} {β : Type u_3} [topological_space α] [topological_space β] (f : α → β) : Prop
(α : Type u_1) (β : Type u_2) [has_le α] [has_le β] : Type (max u_1 u_2)
{R : Type u} [ring R] {Γ₀ : Type v} [linear_ordered_comm_group_with_zero Γ₀] (v : valuation R Γ₀) : ring_subgroups_basis (λ (γ : Γ₀ˣ), v.lt_add_subgroup γ)
{X : Type u_1} [topological_space X] {x y : X} : inseparable x y → nhds x = nhds y
(n : ℕ) (α : fin n → Type u) : Type u
(nm : name) (n : ℕ) : name
{n : ℕ} {α : Type u} {β : Type v} (a : array n α) (f : fin n → α → β) : array n β
{M : Type u_1} {α : Sort u_2} [add_comm_monoid M] (f : α → M) : M
{α : Type u} {β : Type v} (R : α → β → Prop) (ca : computation α) (cb : computation β) : Prop
(G : Type u_1) [group G] : ℕ → subgroup G
{α : Type u} [partial_order α] [decidable_rel has_le.le] {a b : α} (hab : a ≤ b) : a = b ∨ a < b
{α : Type u} {a b : α} [mul_zero_class α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 0 < a) (hb : 0 < b) : 0 < a * b
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : orthonormal 𝕜 v) : linear_independent 𝕜 v
(X : Type u) [has_mul X] [has_zero X] [has_lt X] : Prop
(α : Type u) : Type (max 1 u)
(R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] (x : A) : Prop
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.has_shift C ℤ] : Type (max u v)
{α : Type u_1} (o : part α) : α
(M : Type u_1) [add_semigroup M] : add_subsemigroup M
{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] : alternating_map R (n → R) R n
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) : Prop
{α : Type u_1} [decidable_eq α] (f : equiv.perm α) : Prop
 : Type
(α : Type u) : Type u
(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] [fintype l] : lie_subalgebra R (matrix (unit ⊕ l ⊕ l) (unit ⊕ l ⊕ l) R)
{α : Type u_1} : has_coe_t (finset α) (set α)
{α : Type u} [pseudo_metric_space α] (x y : α) : has_dist.dist x y = ↑(has_nndist.nndist x y)
(R : Type u_1) (A : Type u_2) [comm_ring R] [comm_ring A] [algebra R A] : subalgebra R A
{α : Type u_1} [preorder α] (s : set α) : Prop
{α : Type u_1} [partial_order α] : subsingleton (succ_order α)
(M : Type u_1) [has_mul M] : galois_insertion subsemigroup.closure coe
(α : Type u_1) (β : Type u_2) [decidable_eq α] [fintype α] [encodable β] : trunc (encodable (α → β))
{G : Type u_1} [group G] (T : set G) : set (set G)
{α : Sort u_1} {s₁ : setoid α} (a : α) : quotient s₁
{α : Type u} [topological_space α] (s : set α) : set α
(A : Type u) [comm_ring A] [is_domain A] [discrete_valuation_ring A] : valuation_ring A
 : setoid Well_order
 : Type
{α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 2
 : Type
{R : Type u_2} [comm_semiring R] : has_coe (polynomial R) (power_series R)
{M : Type u_1} [monoid M] {s₁ s₂ : set M} (is₁ : is_submonoid s₁) (is₂ : is_submonoid s₂) : is_submonoid (s₁ ∩ s₂)
{α : Type u} {β : Type v} (f : stream (α → β)) (s : stream α) : stream β
{α : Type u_1} (r : α → α → Prop) : set α → Prop
(α : Type) : Type
{M₀ : Type u_1} [cancel_monoid_with_zero M₀] {a b : M₀} (h₁ : b ≠ 1) (h₂ : b * a = a) : a = 0
{𝕜 : Type u_1} [is_R_or_C 𝕜] : inner_product_space 𝕜 𝕜
{α : Type u} [group α] [has_le α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : finite_dimensional.finrank K V = 0 ↔ subsingleton V
{α : Type u_1} (f g : α → α) : Prop
{R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R] [h : algebra.finite_type R (monoid_algebra R M)] : monoid.fg M
{α : Type u_1} [partial_order α] [bounded_order α] [is_simple_order α] [decidable_eq α] : linear_order α
{α : Type u_1} {β : Type u_2} (p : two_pointing α) (q : two_pointing β) : two_pointing (α ⊕ β)
{α : Type u} : α → ulift α
{α : Type u} (x : α) : ordnode α → ordnode α
{α : Type u_4} {β : Type u_5} (r : α → α → Prop) (s : β → β → Prop) : Type (max u_4 u_5)
(c : cardinal) : Prop
(M : Type u_1) (α : Type u_2) : Type (max u_1 u_2)
{α : Type u_1} {β : Type u_2} [primcodable α] [primcodable β] (p : α → Prop) (q : β → Prop) : Prop
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
(J : Type u₁) : Type u₁
{α : Type u} [pseudo_metric_space α] {s : set α} {x : α} (h : x ∈ s) : metric.inf_dist x s = 0
{κ : Type w} (A : Type u) {B : Type v} [comm_ring A] [comm_ring B] [algebra A B] (b : κ → B) : matrix κ κ A
 : Type (u_1+1)
 : Type (u_1+1)
{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_regular (a + b)) (ba : is_add_regular (b + a)) : is_add_regular a ∧ is_add_regular b
(α : Type u) [topological_space α] : Prop
{ι : Type u_1} {R : Type u_2} [comm_ring R] {M : Type u_4} [add_comm_group M] [module R M] [topological_space R] (B : ι → submodule R M) : Prop
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (f : J → C) [category_theory.limits.has_biproduct f] : C
{R : Type u} [semiring R] : polynomial R → ℕ → R
(d : pos_num) (q r : num) : num × num
{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : -a : Type
{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (s : finmap β) : option (β a)
{n m : ℕ} (i : fin (m * n)) : fin n
{𝕜 : Type u_1} {E : Type u_2} [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] (K : geometry.simplicial_complex 𝕜 E) : set E
{α : Type u_1} {β : Type u_2} (p : two_pointing α) (q : two_pointing β) : two_pointing (α × β)
{K : Type u_1} [field K] : ideal.is_jacobson K
{C : Type u₁} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)] : category_theory.is_subterminal A
{n : Type u_1} (p : Type u_2) {R : Type u₂} [decidable_eq n] [decidable_eq p] [comm_ring R] (t : matrix.transvection_struct n R) : matrix.transvection_struct (n ⊕ p) R
{m n : ℕ} {α : Type u_1} {o : ℕ} (ho : o = m + n) (u : fin m → α) (v : fin n → α) : fin o → α
 : fact (1 ≤ 1)
(C : Type u) [category_theory.category C] [category_theory.limits.has_colimits C] : category_theory.limits.has_finite_colimits C
{α : Type u_1} : multiset (multiset α) → multiset α
{α : Type u} [topological_space α] [locally_compact_space α] (x : α) : ∃ (K : set α), is_compact K ∧ K ∈ nhds x
 : Type u → cardinal
(l r : Type u) : bool → Type u
{α : Type u_2} {β : Type u_3} [decidable_eq β] [monoid α] [mul_action α β] : mul_action α (finset β)
{X : Type u} [lattice X] [jordan_holder_lattice X] {s₁ s₂ : composition_series X} (h : ∀ (x : X), x ∈ s₁ ↔ x ∈ s₂) : s₁ = s₂
{α : Type u_1} [decidable_eq α] (s : finset α) (a : α) : finset α
{p : bool → Prop} [Π (b : bool), decidable (p b)] : decidable (∃ (b : bool), p b)
{α : Type u_1} {δ : α → Sort u_2} (s : finset α) (f g : Π (i : α), δ i) [Π (j : α), decidable (j ∈ s)] (i : α) : δ i
{α : Sort u} [decidable_eq α] (a b : α) : equiv.perm α
{ι : Type u_1} (M : ι → Type u_2) [Π (i : ι), monoid (M i)] (i : ι) : Type (max u_1 u_2)
{α : Type u} (s : wseq α) (n : ℕ) (a : α) : wseq α
{n : ℕ} {F : typevec n → Type u_1} [mvfunctor F] (q : mvqpf F) : Prop
(R : Type u) (X : Type v) [semiring R] : Type (max u v)
(α : Type u) {g : Type} [random_gen g] [random α] : rand_g g (stream α)
{α : Type u_1} (R : α → α → Prop) [decidable_rel R] : list α → list α
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 ≤ b) : 1 < a * b
{Γ : Type u_1} [inhabited Γ] (l₁ l₂ : list Γ) : Prop
{G : Type u_3} [group G] (P : subgroup G) : Prop
{n : ℕ} {α : Type u_1} {v : vector α (n + 1)} : v.last = v.nth (fin.last n)
{X : Type u} [topological_space X] {x₀ x₁ x₂ : X} (P₀ : path.homotopic.quotient x₀ x₁) (P₁ : path.homotopic.quotient x₁ x₂) : path.homotopic.quotient x₀ x₂
(n a b : ℕ) : n < a ∨ b ≤ n ∨ n ∈ list.Ico a b
{α : Type u_1} {m m' : pseudo_metric_space α} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist) : m = m'
(α : Type u) [topological_space α] : Prop
{M : Type u_1} [add_monoid M] (a : M) : Prop
(α : Type u) {β : Type v} [topological_space α] [pseudo_metric_space β] (b : β) : bounded_continuous_function α β
{α : Type u_1} (s : set (set α)) : set α → Prop
{M : Type u_1} [hM : comm_monoid M] (h : ∀ (a : M), is_unit a) : comm_group M
{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_wide_pullbacks C] {B : C} : category_theory.limits.has_finite_products (category_theory.over B)
 : snum → bool
{X : Type u_1} {α : Type u_2} {β : Type u_3} [topological_space X] (f : locally_constant X (α → β)) (a : α) : locally_constant X β
{R : Type u} [ring R] : complete_lattice (subring R)
(n : ℕ) (a : fin n) (b : ℕ) : Prop
{X : Type u_1} [topological_space X] (x y : X) : Prop
(x y : pgame) : Prop
{α : Type u} [add_monoid α] : add_group (add_units α)
{M : Type u_1} (S : set M) [monoid M] : submonoid M
{M : Type u_1} [has_add M] (S : add_subsemigroup M) (s : set M) (hs : s = ↑S) : add_subsemigroup M
(α : Type u_2) [comm_monoid_with_zero α] : Prop
{α : Type u} [mul_one_class α] : is_monoid_hom id
 : Type (u_1+1)
{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → ℕ → option ℕ
{n : ℕ} (c : composition_as_set n) : list ℕ
{α : Type u_2} {β : Type u_3} [complete_lattice α] [complete_lattice β] (f : frame_hom α β) : lattice_hom α β
{n : ℕ} {F : typevec n → Type v} [mvfunctor F] {α : typevec n} (p : Π (i : fin2 n), α i → Prop) (x : F α) : Prop
{R : Type u_1} [linear_ordered_field R] [floor_ring R] (b : ℕ) (r : R) : ℤ
 : ℕ → Type
{α : Type u_1} (y : α) : fintype {x // y = x}
{α : Type u} [hg : group α] [is_cyclic α] : comm_group α
(α : Type u_1) : set (α × α)
{R : Type u} [semiring R] : polynomial R
(p : ℕ) (G : Type u_1) [group G] : Type u_1
(C : Type u) [category_theory.category C] : Prop
{R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : matrix n n (polynomial R)
{n : Type u_1} {R : Type u₂} [decidable_eq n] [comm_ring R] (t : matrix.transvection_struct n R) : matrix n n R
 : Set
(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A) : category_theory.is_equivalence (category_theory.shift_functor C i)
(u : pnat.xgcd_type) : ℕ × ℕ
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1
 : Type (u_1+1)
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : Prop
 : ordinal
{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) : list (sigma β) → list (sigma β)
{p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p
{G : Type u_1} [has_add G] : G → G → G
(α : Type u) : Type u
{R : Type u_1} {S : Type u_3} [distrib R] [distrib S] : distrib (R × S)
{F : Type u → Type u} [functor F] {α : Type u} (r : α → α → Prop) (x y : F α) : Prop
 : Type
(α : Type u_5) (β : Type u_6) [uniform_space α] [uniform_space β] : Type (max u_5 u_6)
{S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : commute b a
{α : Type u_1} [measurable_space α] : set α → Prop
{β : Type w} {C : Type u} [category_theory.category C] [unique β] (f : β → C) : category_theory.limits.colimit_cocone (category_theory.discrete.functor f)
{γ : Type u_3} [tγ : topological_space γ] [polish_space γ] [measurable_space γ] [borel_space γ] {s : set γ} : polish_space.is_clopenable s ↔ measurable_set s
(α : Type u) : Type u
{G : Type u_1} [add_group G] : has_top (add_subgroup G)
{α : Type u} [inhabited α] : ℕ → list α → α
{ι : Type u_1} {Z : ι → Type u_2} [Π (i : ι), canonically_ordered_add_monoid (Z i)] : canonically_ordered_add_monoid (Π (i : ι), Z i)
{α : Sort u₁} (β : Sort u₂) (a : α) : β → α
{G : Type u_1} [group G] (H : subgroup G) : Prop
{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : -a < 0 → 0 < a
{M : Type u_1} [monoid M] {s : set M} : s ⊆ monoid.closure s
{C : Type u} [category_theory.category C] [category_theory.limits.has_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_colimits C
(R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] : Prop
{R : Type u_1} {M : Type u_3} [semiring R] [add_comm_monoid M] [module R M] : has_top (submodule R M)
(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [topological_space α] [topological_space β] : Type (max u_6 u_7 u_8)
(M : Type u_1) {α : Type u_2} [monoid M] [mul_action M α] (s : set α) : submonoid M
{n : ℕ} (x : bitvec n) : bitvec n
{M : Type u_1} (S : set M) [has_add M] : set M
{α : Type u_1} : has_add (language α)
(X : Type u_4) [topological_space X] : Prop
{γ : Type w} [semilattice_sup γ] {s t : set γ} : bdd_above (s ∪ t) ↔ bdd_above s ∧ bdd_above t
(α : Type u) : Type u
{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : a⁻¹ ≤ 1 → 1 ≤ a
(p : ℕ) [hp : fact (nat.prime p)] : ℕ → mv_polynomial (fin 0 × ℕ) ℤ
{Γ : Type u_1} {R : Type u_2} [partial_order Γ] [has_zero R] [has_zero Γ] (x : hahn_series Γ R) : Γ
 : has_zero pgame
{α : Type u} : seq α → seq α
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)
 : Type
{α : Type u} [has_add α] : add_hom α (with_zero α)
{α : Type u_1} (L L' : list (list α)) : L = L' ↔ L.join = L'.join ∧ list.map list.length L = list.map list.length L'
{α : Type u_1} (p : α → Prop) [decidable_pred p] (l : finset α) (hp : ∃! (a : α), a ∈ l ∧ p a) : {a // a ∈ l ∧ p a}
(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [preorder α] [preorder β] [mul_zero_one_class α] [mul_zero_one_class β] : Type (max u_6 u_7 u_8)
(C : Type u) [category_theory.category C] : Prop
 : Type
 : Type
{𝕜 : Type u_1} {F : Type u_3} [is_R_or_C 𝕜] [add_comm_group F] [module 𝕜 F] [c : inner_product_space.core 𝕜 F] : has_norm F
 : Type (u+1)
{C : Type u} [category_theory.category C] [category_theory.abelian C] (P : C) : Type (max u v)
 : Type (u+1)
{M : Type u} [has_mul M] (a x y : M) : Prop
(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [has_one M] [has_one N] : Type (max u_10 u_11 u_9)
(F : pfunctor) : ℕ → Type u
{α : Type u_1} [comm_ring α] (E : linear_recurrence α) : polynomial α
{V : Type u} (G : simple_graph V) (n : ℕ) : Prop
(b o : ordinal) : list (ordinal × ordinal)
(α : Type u) [has_add α] : Type u
 : nzsnum → nzsnum
{R : Type u_1} [comm_ring R] [H : topological_space R] (J : ideal R) : Prop
{a : Type u} : bool → a → a → a
(n : ℕ) : ℕ
(L : first_order.language) (α : Type u') : Type (max u u')
(α : Type u_1) : Type u_1
{α : Type u} (x : free_comm_ring α) (s : set α) : Prop
(R : Type u) {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (s : set A) : subalgebra R A
{α : Type u_1} : part α
(X : Top) (T : Type u) : Top.sheaf (Type u) X
(R : Type u_1) [has_mul R] [has_add R] : Type u_1
(G H : AddCommGroup) : category_theory.limits.limit_cone (category_theory.limits.pair G H)
 : num → num
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (α : Type u_1) [add_right_cancel_semigroup α] [has_one α] : Type (max u u_1 v)
{α : Type u} [pseudo_metric_space α] (x y : α) : has_dist.dist ↑x ↑y = has_dist.dist x y
{α : Sort u} {β : Sort v} (a : plift α) (f : α → plift β) : plift β
{n : ℕ} {β : Type u_1} (q : fin (n + 2) → β) : fin.tail (fin.init q) = fin.init (fin.tail q)
(K : Type u) [field K] : galois_insertion subfield.closure coe
{𝕂 : Type u_1} [is_R_or_C 𝕂] : has_deriv_at (exp 𝕂) 1 0
{α : Type u} {β : Type v} [uniform_space α] [semilattice_sup β] [complete_space α] {u : β → α} (H : cauchy_seq u) : ∃ (x : α), filter.tendsto u filter.at_top (nhds x)
(α : Type u_3) [topological_space α] [has_le α] : Type u_3
{ι : Type u_1} {α : Type u_2} {s : ι → set α} (hs : indexed_partition s) : setoid α
{α : Sort u} {β : Sort v} (f : plift (α → β)) (x : plift α) : plift β
{S : Type u_1} [add_semigroup S] {a b c : S} (hab : add_commute a b) (hac : add_commute a c) : add_commute a (b + c)
(α : Type u_1) : Type u_1
 : Type
(Γ : Type u_1) [inhabited Γ] : Type u_1
 : function.surjective real.sinh
(α : Type u_4) [bornology α] : Prop
 : category_theory.limits.has_limits_of_size AddMon
{n : ℕ} {α : Type u} (a : array n α) (v : α) : array (n + 1) α
{α : Type u_1} [topological_space α] [baire_space α] {s : set α} : s ∈ residual α ↔ ∃ (t : set α) (H : t ⊆ s), is_Gδ t ∧ dense t
(C : Type (u+1)) : Type (u+1)
{α : Type u} [topological_space α] {f : filter α} {a : α} : f ≤ nhds a ↔ ∀ (s : set α), a ∈ s → is_open s → s ∈ f
(α : Type u_1) [measurable_space α] : Type u_1
{α : Type u} [comm_semiring α] {p p' ps ps' : α} : p = p' → ps = ps' → p * ps = p' * ps'
(α : Type u_8) (β : Type u_9) [complete_lattice α] [complete_lattice β] : Type (max u_8 u_9)
(α : Type u_3) [topological_space α] : Prop
{R : Type u} [comm_semiring R] {A : Type u_1} [ring A] [algebra R A] : has_distrib_neg (submodule R A)
(b : ℕ) : ℕ → ℕ
{m : Type u → Type u_1} [monad m] {α : Type u_2} {β : Type u} (f : α → m β) {n : ℕ} : vector α n → m (vector β n)
{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : a ≤ b → a - b ≤ 0
{C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : Prop
{α : Type u_4} {β : Type u_5} (r : α → α → Prop) (s : β → β → Prop) : Type (max u_4 u_5)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.is_initial 0
{α : Type u_1} {β : Type u_2} [has_le α] (s : α → set β) (x : α) : set β
{C : Type u₁} [category_theory.category C] : category_theory.full category_theory.yoneda
(α : Type u) (β : Type v) [monoid α] [mul_action α β] (g : α) : set β
{α : Type u} : α → ordnode α → α
(T : Type u_1) : Type u_1
(n k : ℕ) : Prop
(α : Type u) [preorder α] : Type u
{α : Type u_1} [is_empty α] : fintype.card α = 0
(α : Type u) : Type u
{n : ℕ} (i : fin2 n) (v : typevec n) : Type u
(G : Type u_1) [has_neg G] [measurable_space G] : Prop
(R : Type u_1) (S : Type u_2) (A : Type u_4) [semiring A] [comm_semiring S] [algebra S A] [comm_semiring R] [algebra R S] : algebra R (restrict_scalars R S A)
{α : Type u_1} (g : generalized_continued_fraction α) : seq α
{α : Type u_1} {m : multiset α} {p : α → Prop} [hp : Π (a : α), decidable (p a)] : decidable (∀ (a : α), a ∈ m → p a)
{R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_principal_ideal_ring R] : fintype.card (class_group R K) = 1
{α : Type u_1} {β : Type u_2} : ℕ → list α → (list α → β) → list β → list β
{ι : Type u_1} {α : ι → Type u_2} (s : finset ι) (t : Π (i : ι), finset (α i)) : finset (Σ (i : ι), α i)
 : Type
{K : Type u_1} (v : K) [linear_ordered_field K] [floor_ring K] : continued_fraction K
(z : ℤ) : ℤ
(R : Type u_1) [ring R] (M : Type u_2) [add_comm_group M] [module R M] : Prop
(n : ℕ) : bitvec n
(α β : cardinal) : cardinal
{α : Type u_1} {β : Type u_3} {γ : Type u_5} (f : α → β → γ) (s : set α) (t : set β) : set γ
{α : Type u} (a : α) : wseq α
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] {n : Type w} (B : bilin_form R M) (v : n → M) : Prop
{C : Type u₁} [category_theory.category C] (X : C) : category_theory.limits.cone (category_theory.functor.empty C)
(α : Type u_3) {β : Type u_4} [has_sup α] [semilattice_sup β] (b : β) : sup_hom α β
{R : Type u_1} [semiring R] (n : ℤ) : laurent_polynomial R
 : num → list bool
 : Type (u+1)
{α : Type u_3} (s : set α) : Type u_3
(R : Type u) [comm_ring R] : Type (max u (v+1))
(R : Type u_1) [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (v : M) (h : v ≠ 0) : -ray_of_ne_zero R v h = ray_of_ne_zero R (-v) _
{K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x - y ∈ s
{ι : Type u_1} {f : ι → Type u_2} [Π (i : ι), has_add (f i)] (C : Π (i : ι), add_con (f i)) : add_con (Π (i : ι), f i)
{R : Type u_1} {a : R} [add_monoid R] (ua : is_add_unit a) : is_add_regular a
{α : Type u_1} {β : Type u_2} (l₁ : list α) (l₂ : list β) : list (α × β)
{α : Type u} {β : Type v} (f : α → β) : wseq α → wseq β
(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [preorder α] [preorder β] [topological_space α] [topological_space β] : Type (max u_6 u_7 u_8)
 : ordinal → cardinal
{n m : ℕ} (i : fin (m * n)) : fin m
{R₁ : Type u_4} [comm_ring R₁] {n : Type u_5} (i j : n) : quadratic_form R₁ (n → R₁)
{α : Type u} : ordnode α → ℕ → ordnode α
{α : Type u_1} (s : multiset α) : multiset (multiset α)
{α : Type u} {β : Type v} {γ : Type u_1} {δ : Type u_2} (r : α → γ → Prop) (s : β → δ → Prop) : α ⊕ β → γ ⊕ δ → Prop
{α : Type u_1} [decidable_eq α] (s t : multiset α) : multiset α
{α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (hf : is_ring_hom f) : f 0 = 0
(R : Type u_1) (a b : R) : Type u_1
{α : Type u} {m : ℕ} (x : α) (u : fin m.succ → α) : matrix.vec_cons x u 1 = matrix.vec_head u
{α : Type u_1} {β : Type u_2} [nontrivial α] {f : α → β} (hf : function.injective f) : nontrivial β
(α : Type u_6) (β : Type u_7) [bornology α] [bornology β] : Type (max u_6 u_7)
(α : Sort u) : Sort (max (imax (v+1) u) (v+2))
(α : Type u_1) [preorder α] : simple_graph α
(r n : ℕ) : n.choose r ≤ n.choose (n / 2)
{R : Type u} [comm_semiring R] [nontrivial R] (h : ∀ (a b : R), a ∈ nonunits R → b ∈ nonunits R → a + b ∈ nonunits R) : local_ring R
{C : Type u_1} [category_theory.category C] : category_theory.category (category_theory.idempotents.karoubi C)
{α : Type u} [add_zero_class α] : is_add_monoid_hom id
(α : Sort u) (β : α → Sort v) : Sort (imax u v)
{α : Type u_1} (r : α → α → Prop) : cardinal
{f : ℕ → ℕ} (hf : function.injective f) : filter.tendsto f filter.at_top filter.at_top
{ι : Type u} {X : Type v} [topological_space X] {s : set X} (f : bump_covering ι X s) (x : X) (hx : x ∈ s) : ι
(R : Type u_1) : Type u_1
(R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] : module.rank R M = cardinal.mk (module.free.choose_basis_index R M)
{α : Type u_1} (sel : set α → option α) : set α → ℕ → option α
{α : Type u_1} (r : α → α → Prop) (s' s : multiset α) : Prop
{R : Type u_1} [comm_ring R] {ι : Type u_2} [fintype ι] [ideal.is_jacobson R] : ideal.is_jacobson (mv_polynomial ι R)
{α : Type u_1} {β : Type u_2} : α × β → β × α
(α : Type u) : Type u
{α : Type u} : ℕ → stream α → list α
 : pSet → pSet → Prop
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C] : category_theory.limits.has_zero_object C
(α : Type u_3) : Prop
(α : Type u_1) [fintype α] [encodable α] : list α
{α : Type u_1} {A B : finset α} (i : ℕ) (h₁ : i + B.card ≤ A.card) (h₂ : B ⊆ A) : ∃ (C : finset α), B ⊆ C ∧ C ⊆ A ∧ C.card = i + B.card
(P₂ P₁ : pfunctor) : pfunctor
(M : Type u_1) [monoid M] : submonoid M
{C : Type u} [category_theory.category C] : C → C → Prop
 : lattice ℕ
(M : Type u_4) [has_add M] : Type u_4
(α : Type u) [uniform_space α] : Type u
(α : Type u) (r : α → α → Prop) : Prop
{α : Type u} : ordnode α → ℕ → ordnode α
 : Type
{α : Type u} {β : α → Type v} [decidable_eq α] (m : hash_map α β) : list α
{α : Type u} [topological_space α] {β : Type u_1} [topological_space β] {f : α → β} (h : continuous f) : connected_components α → connected_components β
{α : Type u_1} {p : α → Prop} (s : finset α) (H : ∀ (x : α), x ∈ s ↔ p x) : fintype {x // p x}
{M : Type u_1} {ι : Type u_2} (R : Type u_3) [decidable_eq M] [comm_semiring R] (f : M → ι) (i : ι) : submodule R (add_monoid_algebra R M)
(α : Type u) (r : α → α → Prop) : Prop
{α : Type u_1} [decidable_eq α] [fintype α] {δ : α → Type u_4} (t : Π (a : α), finset (δ a)) : finset (Π (a : α), δ a)
(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [preorder α] [preorder β] [add_zero_class α] [add_zero_class β] : Type (max u_6 u_7 u_8)
(C : Type u) [category_theory.category C] : Prop
{R : Type u_1} [add_zero_class R] : is_add_regular 0
{α : Type u_1} (s : finset α) : ℕ
{X : Type u_1} [has_repr X] : has_repr (alexandroff X)
{α : Sort u} {β : Sort v} (f : α → β) (a : plift α) : plift β
{V : Type u} (G : simple_graph V) : Type u
{R : Type u_1} [mul_zero_class R] [nontrivial R] : ¬is_regular 0
{m : Type → Type v} [monad m] : list (m bool) → m bool
{G : Type u_1} [add_comm_group G] (B : add_group_filter_basis G) : uniform_space G
{α : Type u} [topological_space α] [locally_compact_space α] [t2_space α] {K : set α} (hK : is_compact K) : ∃ (V : set α), is_open V ∧ K ⊆ V ∧ is_compact (closure V)
 : pSet
{α : Type u_1} (s : finset α) [decidable_eq α] : finset (α × α)
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 ≤ a) (hb : 0 < b) : 0 < a + b
{p q r : Prop} (h₁ : implies p q) (h₂ : implies q r) : implies p r
{α : Type u_2} [has_involutive_inv α] : has_involutive_inv (filter α)
{α : Type u_1} [linear_ordered_field α] {β : Type u_2} [ring β] (abv : β → α) [is_absolute_value abv] (x : β) : cau_seq β abv
{α : Type u} [partial_order α] [decidable_rel has_le.le] {a b : α} (hab : a ≤ b) : a < b ∨ a = b
{α : Type u_1} (a : α) (s : multiset α) : Prop
{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a - b < 0 → a < b
(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) (i : ι) : finset.centroid_weights k s i = (↑(s.card))⁻¹
{α : Type u} [preorder α] {a b c : α} (hab : a ≤ b) (hbc : b = c) : a ≤ c
{B : Type u_1} {B' : Type u_3} (f : B' → B) (E : B → Type u_2) (x : B') : Type u_2
 : pSet → Type u
(m : ℤ) {n : ℤ} (hn : 0 < n) : (∃ (k : ℤ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m
 : has_pow cardinal cardinal
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : lie_module R L L
 : Type
(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] : matrix (l ⊕ l) (l ⊕ l) R
(o : ordinal) (f : Π (b : ordinal), b < o → ordinal → ordinal) : ordinal → ordinal
{C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y] : category_theory.limits.has_binary_biproduct X Y
(α : Type u_2) [preorder α] [pred_order α] : Prop
 : Type (u_1+1)
{m : Type u_2} {n : Type u_3} {α : Type v} [has_star α] (M : matrix m n α) : matrix n m α
(X Y : Bipointed) : Type u
(C : Type u) [category_theory.category C] [∀ {X Y : C}, category_theory.limits.has_colimit (category_theory.limits.pair X Y)] : category_theory.limits.has_binary_coproducts C
{n : ℕ} {p q : ℕ × ℕ} (hp : p ∈ finset.nat.antidiagonal n) (hq : q ∈ finset.nat.antidiagonal n) : p = q ↔ p.fst = q.fst
{n : ℕ} [hpos : fact (0 < n)] (i : zmod (2 * n)) : order_of (quaternion_group.xa i) = 4
(α : Type u) [pseudo_metric_space α] : Prop
(α : Type u) [has_mul α] : α → α → Prop
{R : Type u_1} {a b : R} [add_comm_semigroup R] : is_add_regular (a + b) ↔ is_add_regular a ∧ is_add_regular b
(G : Type u_10) (P : Type u_11) [has_vadd G P] : Prop
{α : Type u_2} [has_one α] [has_mul α] [has_inv α] : has_pow (set α) ℤ
{α : Type u_1} (p : α → Prop) [decidable_pred p] : list α → list α
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 ≤ a) (hb : 1 < b) : 1 < a * b
{α : Type u} {f g : α → α} {x : α} (hfg : function.is_fixed_pt (f ∘ g) x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt f x
(E : Type u_6) : Type u_6
(G : Type u) : Type u
 : has_mul nonote
(P : ℕ → Prop) [decidable_pred P] : enat
{α : Type u_1} [has_star α] : has_star (set α)
{ι : Type u_1} (A : ι → Type u_2) [has_zero ι] : Type u_2
(R : Type u_1) [has_mul R] [has_add R] : Type
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C) : Prop
{α : Type u} [is_empty α] : unique (set α)
(K : Type u) [comm_ring K] (p : ℕ) [fact (nat.prime p)] [char_p K p] : Type u
(α : Type u_5) [has_norm α] [has_one α] : Prop
{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) (s : set α) : Prop
{α : Type u_1} [has_zero α] [has_one α] [has_neg α] : sign_type → α
(s : char_buffer) : parser unit
{M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] : has_zero (zero_hom M N)
{C : Type u} [category_theory.category C] : complete_lattice (category_theory.grothendieck_topology C)
 : ℕ → num → num → num
{C : Type u_1} [category_theory.category C] (P Q : category_theory.idempotents.karoubi C) : Type u_2
(R : Type u) {X : Type v} [comm_ring R] : X → free_lie_algebra R X
 : pgame → pgame → Type (u+1)
{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red L₁ L₂) : free_group.reduce L₁ = free_group.reduce L₂
{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} : a < b⁻¹ → b < a⁻¹
(c1 c2 : omega.clause) : omega.clause
{m n : ℕ} : (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n
{α : Type u_1} (p : α → Prop) [decidable_pred p] (l : multiset α) (hp : ∃! (a : α), a ∈ l ∧ p a) : α
 : num → num
{α : Type u} : list α → ordnode α
{α : Type u_1} [decidable_eq α] (s t : multiset α) : multiset α
(C : Type u_1) [quiver C] : Sort (max (u_1+1) u_2 1)
{X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.metrizable_space Y] {f : X → Y} (hf : embedding f) : topological_space.metrizable_space X
{α : Type u_1} {β : Type u_2} [topological_space α] [metric_space β] : metric_space (bounded_continuous_function α β)
{α : Type u_1} : ((α → ℕ) → ℤ) → Prop
{α : Type u_1} [preorder α] (a : α) : set α
{n : ℕ} {α : Type u_1} {v : vector α (n + 1)} : v.reverse.head = v.last
{n : ℕ} {α : Type u_1} (v : vector α n) : vector α n
{H : Type u} [topological_space H] : order_top (structure_groupoid H)
{R : Type u_1} [semiring R] (f : polynomial R) : polynomial R
{α : Type u} [preorder α] {a b c : α} : a ≤ b → b ≤ c → a ≤ c
{α : Type u} [add_group α] : is_add_group_hom id
{M : Type u_1} [comm_monoid M] {s : set M} (hs : is_submonoid s) (m : multiset M) : (∀ (a : M), a ∈ m → a ∈ s) → m.prod ∈ s
{α : Type u_1} (s : set (sym2 α)) (x y : α) : Prop
{α : Type u_1} [preorder α] (a : α) : set α
(p : ℕ) : zmod (2 ^ p - 1)
(G : Type u_1) [group G] [topological_space G] : Type u_1
{F : Type u → Type v} [applicative F] [is_lawful_applicative F] : applicative_transformation F F
(C : Type u) (A : Type u_2) [category_theory.category C] [add_monoid A] : Type (max u u_2 v)
{R : Type u_1} [ordered_semiring R] [nontrivial R] : char_zero R
{C : Type u} [category_theory.category C] (X : C) [category_theory.limits.has_binary_products C] : category_theory.comonad C
{α : Type u_1} [add_group α] (s : add_subgroup α) : setoid α
{α : Type u} (r : α → α → Prop) (s : set α) : Prop
{α : Type u_1} [preorder α] [order_top α] [locally_finite_order α] (a : α) : finset α
 : two_pointing bool
{α : Type u} (p : α → Prop) [decidable_pred p] : ordnode α → ordnode α
(L : first_order.language) : cardinal
{G : Type u_1} [add_group G] (H : add_subgroup G) : add_subgroup G
(H : Type u_1) (H' : Type u_2) : Type (max u_1 u_2)
{β : Type u_2} {ι : Sort u_4} (s : ι → set β) : set β
{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : 0 = a * b ↔ a = 0 ∨ b = 0
(R : Type u) [semiring R] : Prop
{α : Type u} : dense_inducing has_pure.pure
 : exp_neg_inv_glue.f_aux 0 = exp_neg_inv_glue
(k : Type u_1) {V : Type u_2} (P : Type u_3) [ring k] [add_comm_group V] [module k V] [add_torsor V P] : Type u_3
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {P Q : C} (c : category_theory.limits.binary_bicone P Q) : category_theory.limits.cocone (category_theory.limits.pair P Q)
{G : Type u_1} [group G] : has_top (subgroup G)
{X : Type u_1} [topological_space X] {α : Type u_2} (f : locally_constant X α) : discrete_quotient X
{α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} {x : α} (hf : is_ring_hom f) : f (-x) = -f x
{α : Type u_1} {β : Type u_4} [partial_order α] [preorder β] {l : α → β} {u : β → α} (gc : galois_connection l u) : closure_operator α
{α : Type u_1} {A B : set (finset α)} {r : ℕ} : set.sized r A ∧ set.sized r B → set.sized r (A ∪ B)
 : num → ℕ → num
{G : Type u_10} [add_group G] (a : G) : equiv.perm G
{n : ℕ} (i : zmod n) : order_of (dihedral_group.sr i) = 2
(M : Type u) [topological_space M] [has_add M] : Prop
(α : Type u) : Type u
{ι : Type u_1} {α : ι → Type u_2} (s : set ι) (t : Π (i : ι), set (α i)) : set (Π (i : ι), α i)
 : Type (u_1+1)
{α : Type u_1} [primcodable α] (p : α → Prop) [decidable_pred p] : Prop
{α : Type u_1} [has_zero α] [has_one α] [has_add α] : ℕ → α
{α : Sort u} {β : Sort v} : function.injective coe_fn
{α : Type u_1} [preorder α] [succ_order α] {a b : α} [no_max_order α] : order.succ a ≤ order.succ b → a ≤ b
(x y : Set) : Set
{α : Type u} {n : ℕ} [has_repr α] : has_repr (fin n → α)
{α : Type u_1} {β : Type u_2} [encodable β] (f : α → β) (hf : function.injective f) : encodable α
{α : Type u_1} (r : α → α → Prop) [is_preorder α r] : α → antisymmetrization α r
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] : galois_insertion (algebra.adjoin R) coe
{m n : ℕ} : m ∣ n + m ↔ m ∣ n
(V : Type u) : Type (max u v)
{α : Type u_1} [comm_semiring α] (t : tree α) : tactic.ring2.csring_expr → α
{α : Type u} (f : α → α) (a : α) : stream α
(α : Type) : Type
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) (s : set α) (x : α) : Prop
{M : Type u_1} [add_zero_class M] : has_bot (add_submonoid M)
{A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) : prime (minpoly A x)
{G : Type u_2} [group G] : has_inv (submonoid G)
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) : ℕ → add_localization S → add_localization S
{α : Type u_2} [has_sub α] : has_sub (set α)
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {F : J → C} (B : category_theory.limits.bicone F) : category_theory.limits.cone (category_theory.discrete.functor F)
{V : Type u} [quiver V] (r : V) [quiver.rooted_connected r] : wide_subquiver V
{α : Type u_1} [conditionally_complete_lattice α] (f : filter α) : α
{H : Type u} [topological_space H] : partial_order (structure_groupoid H)
{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : 0 ≤ a - b → b ≤ a
{B : Type u_1} {E : B → Type u_2} (b : B) (a : E b) : bundle.total_space E
{p : ℕ → Prop} [decidable_pred p] {n : ℕ} : p n → nat.count p (n + 1) = nat.count p n + 1
 : Type
{n : ℕ} {α : Type u} {β : Type v} (a : array n α) (b : β) (f : fin n → α → β → β) : β
(a b : ℕ) : a - b.succ = a - b - 1
(P : Type u_2) [preorder P] : Type u_2
{α : Type u} (l : ordnode α) (x : α) : ordnode α → ordnode α
{M : Type u_1} [has_mul M] (c : con M) : Type u_1
{n : ℕ} [h : fact (0 < n)] (i : ℕ) : fin n
{α : Type u_1} [preorder α] (a : α) : lower_set α
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (hC : category_theory.skeletal C) : monoid C
 : Type (u+1)
{α : Type u_1} {β : Type u_2} [primcodable α] [primcodable β] (p : α → Prop) (q : β → Prop) : Prop
{β : Type u_2} (f : equiv.perm β) (x y : β) : Prop
{α : Type u_2} [decidable_eq α] [division_comm_monoid α] : division_comm_monoid (finset α)
{α : Type u_1} {β : Type u_4} [preorder α] [preorder β] {u : β → α} (l : lower_adjoint u) : α → β
(X Y : Type u) : category_theory.limits.cocone (category_theory.limits.pair X Y)
{α : Type u} (p : α → Prop) (f : filter α) : Prop
{α : Type u_1} {n : Type u_4} [non_unital_semiring α] [star_ring α] (A : matrix n n α) : Prop
(G : Type u) [comm_group G] : CommGroup
(C : Type u) [category_theory.category C] : Type (max u (v+1))
{α : Type u_1} [preorder α] (Ixx : α → α → set α) (l₁ : filter α) (l₂ : out_param (filter α)) : Prop
{α : Type} (p : parser α) : Prop
 : first_order.language
 : Type (u_1+1)
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop
{α : Sort u} {f : α → α} (h : function.involutive f) {x y : α} : f x = y ↔ x = f y
{n : ℕ} [fact (0 < n)] (a : zmod n) : ↑(a.val) = a
{M : Type u_1} [hM : monoid M] (h : ∀ (a : M), is_unit a) : group M
{α : Type u_1} [metric_space α] {β : Type u} [nonempty β] (p : besicovitch.tau_package β α) (i : ordinal) : set α
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : lie_ideal R L
 : principal_seg has_lt.lt has_lt.lt
{α : Type u} : ordnode α → ordnode α
 : nat.arithmetic_function ℕ
(p : ℕ) : Prop
{M₀ : Type u_6} [monoid_with_zero M₀] [nontrivial M₀] [no_zero_divisors M₀] {L : list M₀} : L.prod = 0 ↔ 0 ∈ L
{M : Type u_1} [add_monoid M] [distrib_mul_action ennreal M] : distrib_mul_action nnreal M
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
(M : Type u_1) [monoid M] : Prop
{α : Type u} [has_le α] [decidable_rel has_le.le] : ordnode α → ordnode α → ordnode α
{R : Type u_1} [right_cancel_semigroup R] (g : R) : is_right_regular g
{C : Type u₁} [category_theory.category C] {X : C} (t : category_theory.limits.is_terminal X) : category_theory.limits.is_initial (opposite.op X)
(a : Sort u) (b : Sort v) : Sort (max 1 (imax u v))
(R : Type u) [ring R] [nontrivial R] [is_noetherian_ring R] : strong_rank_condition R
{α : Type u_1} : complete_lattice (subtype setoid.is_partition)
{α : Type u_1} : lazy_list α → lazy_list α → lazy_list α
{α : Type u} [uniform_space α] {f : filter α} {x : α} (hf : cauchy f) (adhs : cluster_pt x f) : f ≤ nhds x
(F : Type u_5) (α : out_param (Type u_6)) (β : out_param (Type u_7)) [non_assoc_semiring α] [non_assoc_semiring β] : Type (max u_5 u_6 u_7)
{α : Type u} [decidable_eq α] (xs : list α) (h : ∀ (x : α), x ∈ xs) : fin_enum α
{α : Type u_1} [decidable_eq α] [fintype α] : function.injective equiv.perm.cycle_factors_finset
{p : ℕ} : summable (λ (n : ℕ), 1 / ↑n ^ p) ↔ 1 < p
 : Type
{R₁ : Type u_4} [comm_ring R₁] {n : Type w} [fintype n] [decidable_eq n] [invertible 2] (Q : quadratic_form R₁ (n → R₁)) : R₁
{α : Type u_1} [preorder α] [nonempty α] [no_min_order α] : infinite α
(α : Type u_1) (r : α → α → Prop) : Prop
(e a0 a : onote) : ℕ → ℕ → onote
{p : ℕ} {R : Type u_1} [comm_ring R] (P : ℕ → Prop) (x : witt_vector p R) : witt_vector p R
{α : Type u_2} {β : Type u_3} {γ : Type u_4} [bornology α] [bornology β] [bornology γ] (f : locally_bounded_map β γ) (g : locally_bounded_map α β) : locally_bounded_map α γ
{M : Type u_1} (S : set M) [add_monoid M] : add_submonoid M
(p : ℕ) : ℕ
{α : Type u_1} [preorder α] (lo : with_bot α) (t : ordnode α) (hi : with_top α) : Prop
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} (h : same_ray R x y) : same_ray R y x
(E : Type u_4) [non_unital_normed_ring E] [star_ring E] : Prop
(G : Type u_1) [add_group G] [topological_space G] : Prop
(α : Type u_2) [bornology α] : locally_bounded_map α α
(α : Type u_3) [measurable_space α] (M : Type u_4) [add_comm_monoid M] [topological_space M] : Type (max u_3 u_4)
{α : Type u} : ℕ → seq α → list α × seq α
{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : 1 / a < 1 / b ↔ b < a
{n : ℕ} (c : composition_as_set n) : ℕ
{α : Type u_1} (s : set α) (r : α → α → Prop) : Prop
 : onote
{α : Type u_2} [preorder α] [no_max_order α] : filter.at_top ≤ filter.cofinite
{α : Type u_1} [linear_ordered_field α] {β : Type u_2} [comm_ring β] {abv : β → α} [is_absolute_value abv] : Type u_2
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : lie_ideal R L
{α : Type u} [group_with_zero α] {a : α} (h : a ≠ 0) : invertible a
(G : Type u_1) [topological_space G] [has_div G] : Prop
{α : Type u} : ordnode α → bool
{α : Type u} [decidable_eq α] (xs : list (α × α)) (x : α) : α
{p : ℕ → Prop} : (∃ (x : ℕ), p x) → well_founded (nat.upto.gt p)
(R : Type u_1) [ring R] (M : Type u_2) [add_comm_group M] [module R M] : Prop
{α : Type u_1} : cycle α
{X : Type u_1} [topological_space X] (x : X) (F : set X) : set X
{α : Type u} (s : computation α) (a : α) : Prop
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type w} [fintype ι] (h : basis ι K V) : finite_dimensional K V
{α : Type u} [topological_space α] (s : set α) : set α
{G : Type u} [monoid G] (x : G) : Prop
{gen : Type u} [random_gen gen] (g : gen) : bool × gen
{α : Type u_1} {P : α → Prop} (h : ∃ (x : α), P x) : {x // P x}
(α : Type u_1) [add_right_cancel_semigroup α] [has_one α] : complex_shape α
{α : Type u} (s : seq α) : Prop
{ι : Type u_1} {α : ι → Type u_2} (f : Π (i : ι), filter (α i)) : filter (Π (i : ι), α i)
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) : Type u_2
{α : Sort u_1} (h : nonempty α) : erased α
{C : Type u} [category_theory.category C] {P Q : C} (t : category_theory.limits.binary_fan P Q) : category_theory.limits.binary_fan Q P
{α : Type u} (p : α → Prop) (s : stream α) : Prop
(R : Type u_2) (M : Type u_5) [semiring R] [add_comm_group M] : Type (max u_2 u_5)
{p : ℕ} {G : Type u_1} [group G] {α : Type u_2} [group α] [mul_distrib_mul_action α G] : mul_action α (sylow p G)
{α : Type u} (s : stream α) (n : ℕ) : α
{α : Type u} {β : Type v} [group β] (f : α → β) : list (α × bool) → β
{α : Type u_1} [β : non_unital_normed_ring α] : non_unital_semi_normed_ring α
{G : Type u_1} [add_group G] (H : add_subgroup G) : 0 ∈ H
{α : Type u_1} (A : finset α) (i : ℕ) (h₁ : i ≤ A.card) : ∃ (B : finset α), B ⊆ A ∧ B.card = i
(key data : Type) : Type
(α : Type u_8) (β : Type u_9) [has_Inf α] [has_Inf β] : Type (max u_8 u_9)
(c f₁ f₂ : Type u) (r₁ r₂ : Type v) : first_order.language
{α : Type u} [topological_space α] : dense_range stone_cech_unit
{α : Type} : parse_result α → ℕ
(n : Type u) [decidable_eq n] [fintype n] (R : Type v) [comm_ring R] : Type (max u v)
{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) (l : list (sigma β)) : list (sigma β)
 : bounded_random ℤ
(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] : matrix (l ⊕ l) (l ⊕ l) R
 : Type
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) : Prop
(R : Type u) [comm_ring R] [is_domain R] (n : ℕ) : is_domain (mv_polynomial (fin n) R)
{α : Type u} : ordnode α → ordnode α → ordnode α
{α : Type u_1} [decidable_eq α] (l : list α) (x : α) (h : x ∈ l) : α
(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [has_zero M] [has_zero N] : Type (max u_10 u_11 u_9)
{α : Type u_1} [add_right_cancel_semigroup α] (a : α) : complex_shape α
{J : Type u₁} [category_theory.category J] [category_theory.is_connected J] (j₁ j₂ : J) : category_theory.zigzag j₁ j₂
(α : Type u) {β : Type v} [add_monoid α] [add_action α β] (b : β) : add_submonoid α
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (ι : Type u_1) [unique ι] (h : finite_dimensional.finrank K V = 1) : basis ι K V
{α : Type u} [group α] [has_le α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a : α} : 1 ≤ a⁻¹ ↔ a ≤ 1
{α : Type u_1} [linear_ordered_ring α] : subsingleton (floor_ring α)
(M : Type u) : Type u
(R : Type u) [non_assoc_semiring R] : ℕ
{α : Type u_1} [boolean_ring α] : boolean_algebra α
{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) (h : is_unit A.det) : A.mul A⁻¹ = 1
{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → α → α
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_biproducts C] {J : Type v} [fintype J] (F : J → category_theory.idempotents.karoubi C) : category_theory.limits.bicone F
{α : Type u_2} {β : Type u_3} {γ : Type u_4} [has_top α] [has_top β] [has_top γ] (f : top_hom β γ) (g : top_hom α β) : top_hom α γ
(H : Type u_5) [topological_space H] (M : Type u_6) [topological_space M] : Type (max u_5 u_6)
{R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (S : finset M) : complete_lattice.is_compact_element (submodule.span R ↑S)
{α : Type u_1} {β : Type u_2} (f : α → β) : cycle α → cycle β
{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : a < 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1
{α : Type u} [preorder α] {s : set α} {a : α} (h : is_glb s a) : bdd_below s
 : Type
{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) : list (Σ (a : α), β a) → list (Σ (a : α), β a)
(p : ℕ) : padic_norm p 1 = 1
{G : Type u_1} [sub_neg_monoid G] (a b : G) : a - b = a + -b
(R : Type u) [comm_semiring R] (p : ℕ) [fact (nat.prime p)] [char_p R p] : Type u
{α : Type u_1} [preorder α] [pred_order α] : α → α
{K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : seq1 (generalized_continued_fraction.int_fract_pair K)
{α : Type u_1} {β : Type u_2} (r : rel α β) (s : set α) : rel {x // x ∈ s} β
{α : Sort u_1} {β : Sort u_2} {p : α → β → Prop} {x₀ x₁ : Σ' (a : α), subtype (p a)} : x₀.fst = x₁.fst → ↑(x₀.snd) = ↑(x₁.snd) → x₀ = x₁
{C : Type u} [category_theory.category C] [category_theory.limits.has_pullbacks C] {B : C} : category_theory.limits.has_binary_products (category_theory.over B)
{R : Type u} [non_assoc_semiring R] (s : set R) (sm : submonoid R) (hm : ↑sm = s) (sa : add_submonoid R) (ha : ↑sa = s) : subsemiring R
{M : Type u_1} [has_mul M] : has_bot (subsemigroup M)
{α : Type u_1} (p : α → bool) : list α → list α × option α × list α
(G : Type u) : Type u
{α : Type u} [group α] (g : group_topology α) : continuous has_inv.inv
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 ≤ b) : 0 < a + b
 : Type (u_1+1)
{α : Type u} (l : list α) : wseq α
(α : Type u_1) {β : Type u_2} [measurable_space α] (b : β) : measure_theory.simple_func α β
{β : Type w} {C : Type u} [category_theory.category C] (f : β → C) [category_theory.limits.has_product f] : C
{R : Type u_1} [comm_semiring R] (x : R) (S : Type u_2) [comm_semiring S] [algebra R S] : Prop
 : znum → znum
{a p k : ℕ} (pp : nat.prime p) (h₁ : ¬a ∣ p ^ k) (h₂ : a ∣ p ^ (k + 1)) : a = p ^ (k + 1)
{α : Type u_1} (r : α → α → Prop) (m : multiset α) : Prop
{p : Prop} (h : p) : unique p
(C : Type u) [category_theory.category C] : category_theory.grothendieck_topology C
(S : Type u_3) (G : Type u_4) [has_neg G] [set_like S G] : Type
{α : Sort u_1} {β : α → Type u_2} (p : α → Prop) (f : Π (x : α), β x) (x : subtype p) : β x.val
{β : Type w} {C : Type u} [category_theory.category C] (f : β → C) : Type (max w u v)
{α : Type u_1} [preorder α] : ordnode α → with_bot α → with_top α → Prop
{α : Type u_6} : add_action (additive (function.End α)) α
{M : Type u_1} {N : Type u_2} [has_zero M] [has_zero N] (f : zero_hom M N) : zero_hom (with_top M) (with_top N)
{α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → option β → γ) : list α → list β → list γ × list β
(R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] : Type (max u_1 u_2)
{α : Type u_1} (S : set (set α)) : Type
(L : Type v) (M : Type w) [has_bracket L M] [has_zero M] : Prop
(G : Type u_1) [group G] [topological_space G] : Prop
{M₀ : Type u_1} [mul_zero_one_class M₀] [nontrivial M₀] : 0 ≠ 1
{C : Type u} [category_theory.category C] (X Y : C) : Type (max u v)
(α : Type u) : Type u
{n : ℕ} (F : typevec n → Type u_1) [mvfunctor F] : Type (max (u+1) u_1)
 : Type (u_1+1)
{α : Type u_1} [has_le α] (a : α) : Prop
(o : ordinal) (f : Π (a : ordinal), a < o → ordinal) : ordinal
{R : Type u_1} (A : Type u_2) [comm_ring R] [ring A] [algebra R A] (c₁ c₂ : R) : Type u_2
{G : Type u_1} [add_group G] (H : add_subgroup G) : ℕ
{σ₁ : Type u_1} {σ₂ : Type u_2} (f₁ : σ₁ → option σ₁) (f₂ : σ₂ → option σ₂) (tr : σ₁ → σ₂ → Prop) : Prop
{α : Type u_1} [preorder α] (s : set α) : Prop
(data : Type) : Type
{R : Type u_1} [comm_ring R] (p : polynomial R) : polynomial R
{α : Type u_1} {s : finset α} (p : α → Prop) [decidable_pred p] : finset.map (function.embedding.subtype p) (finset.subtype p s) = finset.filter p s
{m : Type u → Type v} [monad m] {α : Type w} {β : Type u} (f : α → m β) (o : option α) : m (option β)
{R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [monoid.fg M] : algebra.finite_type R (monoid_algebra R M)
{m : Type u_2} {n : Type u_3} {α : Type v} [has_mul α] (w : m → α) (v : n → α) : matrix m n α
(o : ordinal) (f : Π (a : ordinal), a < o → ordinal) : ordinal
{α : Type u_1} [decidable_eq α] (s : multiset α) : multiset α
(C : Type u) [category_theory.category C] : Prop
{b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ nat.clog b x ≤ y
{K : Type u} [field K] (s : subring K) (hinv : ∀ (x : K), x ∈ s → x⁻¹ ∈ s) : subfield K
{X : Type u_1} [topological_space X] : discrete_topology X ↔ nhds = has_pure.pure
{α : Type u_1} [preorder α] [order_top α] [locally_finite_order α] (a : α) : multiset α
(n : ℕ) : list ℕ
(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [has_le α] [has_le β] : Type (max u_6 u_7 u_8)
(α : Type u_5) : Type u_5
(α : Type u) (β : Type v) [omega_complete_partial_order α] [omega_complete_partial_order β] : Type (max u v)
(G : Type u) [group G] : subgroup G
{α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] [separated_space α] {f : α → β} (hf : uniform_inducing f) : uniform_embedding f
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (p : submodule R M) : setoid M
{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] : has_inv (matrix n n α)
{α : Type u_1} (x : α) (z : sym2 α) : Prop
{G : Type w} [topological_space G] [group G] [topological_group G] [topological_space.separable_space G] [locally_compact_space G] : sigma_compact_space G
(x y : pgame) : Prop
{α : Type u_1} {β : Type u_2} (f : filter α) (g : set α → filter β) : filter β
{α : Type u_1} [has_add α] (s : set α) (a : α) : set α
(R : Type u_1) [comm_ring R] : algebra.finite_presentation R R
(α : Type u_5) (β : Type u_6) : Type (max u_5 u_6)
(α : Type u) [preorder α] [nonempty α] [no_max_order α] : ∃ (f : ℕ → α), strict_mono f
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] (j₁ j₂ j₃ : C) : C
{α : Type u_1} {p : α → Prop} [pseudo_emetric_space α] : pseudo_emetric_space (subtype p)
 : Type (u_1+1)
(R : Type u_1) [semiring R] (N : Type u_3) [add_comm_monoid N] [module R N] {ι : Type u_6} [decidable_eq ι] [subsingleton ι] (i : ι) : alternating_map R N N ι
 : pos_num → pos_num → znum
{R₁ : Type u_3} {M₁ : Type u_4} [ring R₁] [add_comm_group M₁] [module R₁ M₁] (B₁ : bilin_form R₁ M₁) (f : module.End R₁ M₁) : Prop
{α : Type u_2} [division_monoid α] {a : α} : is_square a → is_square a⁻¹
 : ℕ → ℕ → list ℕ
{α : Type u} {β : α → Type v} [decidable_eq α] (l : list (Σ (a : α), β a)) (hash_fn : α → ℕ) : hash_map α β
(R : Type u) [comm_ring R] (A : Type v) [ring A] [algebra R A] (A' : subalgebra R A) : lie_subalgebra R A
{α : Type u_1} : list α → option α
{α : Type u_1} [decidable_eq α] (l : list α) : equiv.perm α
{α : Type u_2} {β : Type u_4} [topological_space α] [has_one β] (f : α → β) : Prop
{α : Type u_1} : has_le (setoid α)
{G : Type u_1} {H : Type u_2} [add_group H] (f : G → H) : set G
{g : Type} [random_gen g] {n : ℕ} [fact (0 < n)] : rand_g g (fin n)
(p : ℕ) : padic_norm p 0 = 0
{α : Type u} (x : α) : free_add_semigroup α
{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} [is_trans β s] : has_coe (principal_seg r s) (initial_seg r s)
{n : ℕ} {A : Type u} (F : A → typevec n → Type u) (v : typevec n) : Type u
{α : Type u_1} (s : set α) (q : semiquot α) : semiquot α
 : unit
{R : Type u_1} [semiring R] (P : cubic R) : polynomial R
{α : Type u_1} (r : α → α → Prop) : cardinal
(P : pfunctor) : Type u_1
{α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β ⊕ γ) : list α → list β × list γ
{n : ℕ} : function.injective fin.succ_above
{α : Type u_2} [has_one α] [has_mul α] : has_pow (set α) ℕ
{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : has_sbtw.sbtw c a b
(α : Sort u) (tac_name : name) : Sort u
{β : Type w} {C : Type u} [category_theory.category C] [unique β] (f : β → C) : category_theory.limits.limit_cone (category_theory.discrete.functor f)
{α : Type u_1} {β : Type u_2} {m : measurable_space α} [topological_space β] {f : α → β} (hf : ∀ (x y : α), f x = f y) : measure_theory.strongly_measurable f
{α : Type u_1} : has_Inf (setoid α)
(C : Type u) [category_theory.category C] : Type u
{R : Type u_1} {S : Type u_3} [non_assoc_semiring R] [non_assoc_semiring S] : non_assoc_semiring (R × S)
{α : Type u} {β : Type v} (s : wseq α) (f : α → wseq β) : wseq β
 : Type
{α : Type u_1} {R : Type u_2} [comm_semiring R] (a b : R) (s : finset α) : s.powerset.sum (λ (t : finset α), a ^ t.card * b ^ (s.card - t.card)) = (a + b) ^ s.card
{K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x * y ∈ s
(M : Type u_1) (α : Type u_2) [has_vadd M α] [measurable_space M] [measurable_space α] : Prop
{R : Type u_1} {a b : R} [monoid R] (h : a * b = 1) : is_right_regular a
{G : Type u_10} [group_with_zero G] (a : G) (ha : a ≠ 0) : equiv.perm G
{α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : measurable f → m₂ ≤ measurable_space.map f m₁
{α : Type u_1} {β : Type u_2} [measurable_space α] [measurable_space β] (m : measure_theory.measure α) (f : α → measure_theory.measure β) : measure_theory.measure β
{α : Type u_1} {β : Type u_2} [decidable_eq α] [fintype (α × β)] [nonempty β] : fintype α
{V : Type u} (G : simple_graph V) : Prop
{R : Type u_1} [has_mul R] {a : R} : is_right_regular a ↔ is_smul_regular R (mul_opposite.op a)
{G : Type u_1} [add_group G] {s : set G} (h : is_add_subgroup s) : add_subgroup G
(p : ℕ) (R : Type u_1) : Type u_1
{α : Type u_1} (s t : multiset α) : Prop
{ι : Type u} (f : ι → ordinal) : ordinal
{G : Type u} [fintype G] [left_cancel_monoid G] (x : G) : 0 < order_of x
{P : ℤ → Prop} (Hbdd : ∃ (b : ℤ), ∀ (z : ℤ), P z → b ≤ z) (Hinh : ∃ (z : ℤ), P z) : ∃ (lb : ℤ), P lb ∧ ∀ (z : ℤ), P z → lb ≤ z
(α : Type u_1) (β : Type u_2) [uniform_space β] (𝔖 : set (set α)) : topological_space (α → β)
 : list bool → pos_num
{α : Type u} (c : computation α) : computation α
{α : Type u} {β : Type v} [topological_space α] [preorder β] (f : α → β) (a : α) : Prop
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (Q : quadratic_form R M) : tensor_algebra R M → tensor_algebra R M → Prop
(α : Type u_1) [complete_lattice α] : Prop
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : set P
(G : Type u_3) [group G] : Type u_3
{α : Type u} [semilattice_inf α] [nonempty α] (s : finset α) : bdd_below ↑s
{α : Sort u_1} {β : Sort u_2} (f : α → β) (a : erased α) : erased β
{α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} {x y : α} (hf : is_ring_hom f) : f (x - y) = f x - f y
(E : Type u_8) [comm_group E] [topological_space E] [topological_group E] : continuous_monoid_hom E E
{J : Type v} : category_theory.limits.wide_pullback_shape J → category_theory.limits.wide_pullback_shape J → Type v
(α : Type u) [t : topological_space α] [topological_space.separable_space α] [nonempty α] : ℕ → α
{α : Type u_1} : option α → list α
{α : Type u} {β : Type v} (s : seq (α × β)) : seq α × seq β
{α : Type u} [comm_ring α] [no_zero_divisors α] : cancel_comm_monoid_with_zero α
(M : Type u) [semigroup M] : Semigroup
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{α : Type u_1} {β : Type u_2} [infinite α] [fintype β] (f : α → β) : ∃ (x y : α), x ≠ y ∧ f x = f y
(α : Type v) : Prop
{R : Type u_1} [semiring R] (s : subsemiring R) {l : list R} : (∀ (x : R), x ∈ l → x ∈ s) → l.prod ∈ s
(p : ℕ) [hp : fact (nat.prime p)] (n : ℤ) : ℕ → mv_polynomial (fin 1 × ℕ) ℤ
(R : Type u) (A : Type v) (B : Type w) [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B] : Type (max v w)
{ι : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [monoid R] [add_monoid ι] (A : ι → S) : Prop
(𝕜 : Type u_4) (F : Type u_5) [is_R_or_C 𝕜] [add_comm_group F] [module 𝕜 F] : Type (max u_4 u_5)
{α : Type u_1} {M : Type u_5} [has_zero M] : function.injective coe_fn
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (α : Type u_1) [add_right_cancel_semigroup α] [has_one α] : Type (max u u_1 v)
 : zero_hom cardinal ℕ
 : turing.to_partrec.cont → turing.to_partrec.cont → turing.to_partrec.cont
{α : Type u_1} [lattice α] [order_bot α] (a : α) : Type u_1
{α : Type u} [monoid α] : invertible 1
{R : Type u_1} [comm_ring R] (a1 a2 a3 a4 a6 : R) : R
{n : ℕ} {α : Type u} {β : Type v} (a : array n α) (f : α → β) : array n β
{α : Type u} {β : Type v} {γ : Type u_1} (b : β) : α ⊕ β ⊕ γ
(G : Type u) : Type u
{R : Type u_1} [comm_ring R] {S : submonoid R} {P : Type u_2} [comm_ring P] [algebra R P] : has_coe_t (ideal R) (fractional_ideal S P)
 : Type
{n : ℕ} {α : Type u_1} [preorder α] {f g : fin n → α} (hf : strict_mono f) (hg : strict_mono g) (h : set.range f = set.range g) : f = g
{R : Type u_1} [fintype R] [comm_ring R] [is_reduced R] [char_p R 2] (a : R) : is_square a
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_limit (category_theory.limits.pair X Y)] : category_theory.split_epi category_theory.limits.prod.fst
(α : Type u) : Type u
{α : Type u} {β : α → Type v} (s : alist β) : finmap β
{V : Type u} [quiver V] (a : V) : V → Sort (max (u+1) v)
{α : Type u_1} [measurable_space α] : has_sub (measure_theory.measure α)
 : pSet
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {t : category_theory.limits.cocone (category_theory.limits.pair X Y)} (ht : category_theory.limits.is_colimit t) : category_theory.limits.binary_bicone X Y
{α : Type u_2} [mul_one_class α] : mul_one_class (filter α)
{R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J A : matrix n n R₃) : Prop
 : ordinal → ordinal → ordinal
{P : Type u_1} [preorder P] : has_coe (order.pfilter P) (set P)
{M : Type u_1} [has_add M] : complete_lattice (add_con M)
(L : first_order.language) (M : Type u_3) [L.Structure M] : Prop
{α : Type u_1} [topological_space α] [t2_space α] {f : α → α} (hf : continuous f) : is_closed (function.fixed_points f)
{α : Type u} (n : pos_num) (t : tree α) (v : α) : α
{M : Type u_1} [add_zero_class M] : has_top (add_submonoid M)
(n : ℕ) : bool
(α : Type u_1) [encodable α] [infinite α] : denumerable α
 : pgame → Prop
(M : Type u_5) [monoid M] (A : Type u_6) [add_monoid A] [distrib_mul_action M A] (B : Type u_8) [add_monoid B] [distrib_mul_action M B] : Type (max u_6 u_8)
(α : Type u_1) : Type u_1
 : initial_seg has_lt.lt has_lt.lt
 : znum → option pos_num
(n : ℕ) (i : fin (n + 1)) : sSet
 : filter.tendsto (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), 1 / (↑i + 1))) filter.at_top filter.at_top
(β : Type u_1) (α : Type u_2) : Type (max u_1 u_2)
{α : Type u_1} {n : Type u_4} [has_zero α] (A : matrix n n α) : Prop
{R : Type u} [semiring R] (p : polynomial R) : with_bot ℕ
{α : Type u} {β : Type v} : lazy_list α → lazy_list β → lazy_list (α × β)
{n : ℕ} (x : bitvec n) (i : ℕ) : bitvec n
(α : Type u_1) [f : denumerable α] (n : ℕ) : α
{R : Type u} [non_assoc_semiring R] {S T : subsemiring R} (h : ∀ (x : R), x ∈ S ↔ x ∈ T) : S = T
{α : Type u} {β : α → Type v} (s : finmap β) : finset α
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : submodule R A
{F : Type} [comm_semiring F] {q : ℕ} {f : polynomial F} (hf : polynomial.has_separable_contraction q f) : polynomial F
{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (s : alist β) : option (β a)
{α : Type u_1} (a : α) (s : cycle α) : Prop
(α : Type u) : Type u
{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_5} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] [nonempty ι] (p : seminorm_family 𝕜 E ι) [t : topological_space E] : Prop
{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : is_topological_fiber_bundle F Z.proj
(R : Type u_1) [comm_ring R] : ℕ → polynomial R
{α : Type u_1} [distrib_lattice α] [order_bot α] [decidable_eq α] {a : α} (P : finpartition a) (Q : Π (i : α), i ∈ P.parts → finpartition i) : finpartition a
{R : Type u_1} [semiring R] (f : nat.arithmetic_function R) (k : ℕ) : nat.arithmetic_function R
(C : Type u₁) [category_theory.category C] : Type u₁
(R : Type u_1) [semiring R] : subsemiring R
{X : Type u_1} [topological_space X] (S : discrete_quotient X) {Y : Type u_2} [topological_space Y] {f : Y → X} (cont : continuous f) : discrete_quotient Y
(H : Type u) (M : Type u_2) [topological_space H] [topological_space M] [charted_space H M] [locally_compact_space H] : locally_compact_space M
{α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) (s : set α) : Prop
{a b : Prop} : ¬(a ∨ b) ↔ ¬a ∧ ¬b
 : Type
{m : Type → Type v} [monad m] : list (m bool) → m bool
(R : Type u_1) [add_monoid R] [has_one R] : Prop
(n : ℕ) : ℕ → ℕ
{α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) (s : set α) : Prop
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] : Type (max u v)
(γ : Type u) : Type u
{α : Type u_1} {β : Type u_2} [measurable_space α] [measurable_space β] (f : α → β) : Prop
{M : Type u_1} [add_monoid M] {s : set M} (hs : is_add_submonoid s) {l : list M} : (∀ (x : M), x ∈ l → x ∈ s) → l.sum ∈ s
{H : Type u} [topological_space H] : structure_groupoid H
{R : Type u_1} {S : Type u_2} [euclidean_domain R] [ordered_semiring S] (abv : absolute_value R S) : Prop
{α : Type u_1} {β : Type u_2} [nonempty α] (f : α → β) (s : set α) (t : set β) (hf : set.bij_on f s t) : local_equiv α β
{α : Type u_1} [decidable_eq α] : list α → list α → option (list α)
(R : Type u_1) (A : Type u_2) : Type (max u_1 u_2)
(α : Type u_1) : Type u_1
{R₂ : Type u_5} {M₂ : Type u_6} [comm_semiring R₂] [add_comm_monoid M₂] [module R₂ M₂] (B₂ F₂ : bilin_form R₂ M₂) : submodule R₂ (module.End R₂ M₂)
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [non_unital_non_assoc_semiring α] [non_unital_non_assoc_semiring β] [topological_semiring α] [topological_semiring β] : topological_semiring (α × β)
(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] (X : Top) : Type (max u v)
(α : Type u_4) : Type u_4
 : Type
(m : Type u_1) (n : Type u_2) (R : Type u_3) [comm_semiring R] : matrix m n (mv_polynomial (m × n) R)
{α : Sort u_1} (a : α) : erased α
{C : Type u} [category_theory.category C] : has_Inf (category_theory.grothendieck_topology C)
(p : ℕ) [fact (nat.prime p)] : Type
(C : Type u) [category_theory.category C] : sSet
{α : Type u_1} [topological_space α] [inhabited α] : inhabited (topological_space.nonempty_compacts α)
 : Type
(H : Type u_1) [topological_space H] : charted_space H H
{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_left_regular a) : a ≠ 0
{C : Type u_1} [category_theory.category C] (r : hom_rel C) : Type u_1
(α : Type u_2) : Type u_2
(G : Type u_1) [comm_group G] : subgroup G
(α : Type u_1) : subsingleton α ∨ nontrivial α
(R : Type u) [comm_semiring R] : CommSemiRing
(V : Type u) : Type u
(K : Type u) [comm_ring K] (p : ℕ) [fact (nat.prime p)] [char_p K p] (x : ℕ × K) : perfect_closure K p
(𝕆 : Type u_1) {α : Type u_3} [preorder 𝕆] [preorder α] [grade_order 𝕆 α] : α → 𝕆
(R : Type u) [ring R] : Type (max u (v+1))
(R : Type u_2) {M : Type u_5} [ring R] [add_comm_monoid M] [module R M] : add_comm_group M
{R : Type u_1} [mul_zero_class R] (f g : nat.arithmetic_function R) : nat.arithmetic_function R
{α : Type u_1} {β : Type u_2} [primcodable α] [primcodable β] (p : α → Prop) (q : β → Prop) : Prop
{α : Type u} : seq1 (seq1 α) → seq1 α
(α : Type u_1) : option α
(α : Type u) : Type u
(p : Prop) : decidable p
(𝕜 : Type u_4) (E : Type u_5) : Type (max u_4 u_5)
{M : Type u_6} [add_monoid M] (u : add_units M) : equiv.perm M
(M : Type u) : Type u
(C : Type u) [category_theory.category C] : Prop
{ι : Type u_1} {G : ι → Type u_4} [Π (i : ι), group (G i)] {i j : ι} (w : free_product.neword G i j) : free_product.neword G j i
{α : Type u} [pseudo_metric_space α] {s : set α} (h : ¬metric.bounded s) : metric.diam s = 0
(M : Type u_1) [has_mul M] : Type u_1
{α : Type u_2} (A : set α) (β : Type u_7) [comm_monoid α] [comm_monoid β] (n : ℕ) : Type (max u_2 u_7)
{ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] {i j : ι} (w : free_product.neword M i j) : free_product M
(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom (A × B) (B × A)
{α : Type u_1} [measurable_space α] (s t : set α) : Prop
 : ℕ → ℕ
{α : Type u_1} {β : Type u_2} (r : setoid α) (f : α → β) : setoid β
(α : Type u_1) [uniform_space α] : Type u_1
(v : ℕ → ℤ) (as : list ℤ) : ℤ
(p : Prop) : Prop
{α : Type u_1} {n : ℕ} (a : α) (s : sym α n) : sym α n.succ
(G : Type u_2) [group G] : Prop
{α : Type u} {β : Type v} (f : α → β) : free_add_semigroup α → free_add_semigroup β
(V : Type u₁) : Type u₁
(R : Type u) [topological_space R] [has_star R] : Prop
{R : Type u_1} {M : Type u_2} [comm_ring R] [topological_space R] [add_comm_group M] [module R M] (B : module_filter_basis R M) : topological_space M
(α : Type u_2) [fintype α] [boolean_algebra α] : complete_boolean_algebra α
(α : Type u_2) [has_zero α] [has_one α] [has_le α] : Type
{K : Type v} [field K] (f : polynomial K) : Type v
{α : Type u} {β : Type v} {m : α → β} (u : ultrafilter β) (inj : function.injective m) (large : set.range m ∈ u) : ultrafilter α
{α : Type u} {β : Type v} {t : set β} {f : α → β} (h : ∀ (x : α), f x ∈ t) : function.injective f → function.injective (set.cod_restrict f t h)
(u : pnat.xgcd_type) : u.r + (u.bp + 1) * u.q = u.ap + 1
{α : Type u} (m : measure_theory.outer_measure α) (s : set α) : Prop
 : Type
(α : Type u_6) (β : Type u_7) [topological_space α] [topological_space β] : Type (max u_6 u_7)
{α : Type u_1} [fintype α] [decidable_eq α] (p : equiv.perm α) (x : α) : list α
(L : first_order.language) : L.Theory
(α : Type v) : Type u
{R : Type u_1} (M : Type u_3) [monoid R] [mul_action R M] : is_smul_regular M 1
{V : Type u₁} [quiver V] : prefunctor V (category_theory.paths V)
 : Type
 : pos_num → list bool
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {P Q : C} (c : category_theory.limits.binary_bicone P Q) : category_theory.limits.cone (category_theory.limits.pair P Q)
(R : Type u_1) (M : Type u_4) [semiring R] [add_comm_monoid M] [module R M] : Prop
(α : Type u_2) : Type u_2
{α : Type u_1} {r : α → α → Prop} [is_refl α r] {x y : α} : x ≠ y → r x y ↔ r x y
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] : has_quotient M (submodule R M)
{n : ℕ} {α : fin (n + 1) → Type u} : function.injective2 fin.cons
(F : Type u_2) (α : out_param (Type u_3)) (β : out_param (Type u_4)) [topological_space α] [has_zero β] [topological_space β] : Type (max u_2 u_3 u_4)
{G : Type u_2} [group G] {a b : G} : a = b → a / b = 1
{α : Type u} [preorder α] {a b c : α} : a ≤ b → b < c → a < c
 : stieltjes_function
{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a - b < c → a < b + c
(G₀ : Type u) : Type u
 : pgame
(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] : Type (max u v)
(ι : Type u_1) (R : Type u_2) [unique ι] [semiring R] : basis ι R R
{ι : Type u} {β : ι → Type v} [Π (i : ι), has_zero (β i)] : function.injective coe_fn
(C : Type u) : Type u
{M₀ : Type u_6} [monoid_with_zero M₀] {L : list M₀} (h : 0 ∈ L) : L.prod = 0
(α : Type u_1) : Type u_1
{α : Type u} {β : Type v} (f : α → β) (g : β → α) : set.bij_on g (function.fixed_points (f ∘ g)) (function.fixed_points (g ∘ f))
(α : Type u_8) : Type u_8
(α : Type u_1) : Type u_1
{α : Type u_1} [topological_space α] [has_le α] (s : clopen_upper_set α) : upper_set α
(C : Type u_1) (D : Type u_2) [category_theory.category C] [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] : Type (max u_3 u_4 u_1 u_2)
{α : Type u} {β : Type v} (f : α → β) : free_magma α → free_magma β
{G : Type u} [add_group G] : inhabited (add_group_filter_basis G)
{R : Type u_1} {M : Type u_3} [semiring R] [add_comm_monoid M] [module R M] : has_bot (submodule R M)
{α : Type u_1} [linear_order α] : finset α → option α
{K : Type u} [field K] (s : subfield K) {l : list K} : (∀ (x : K), x ∈ l → x ∈ s) → l.prod ∈ s
{R : Type u} [ring R] (p q : polynomial R) : polynomial R
 : Set → Set → Set
 : Set
{α : Type u} (s : stream α) : stream (list α)
{M : Type u_1} [monoid M] : has_faithful_smul (mul_aut M) M
{G : Type w} [topological_space G] [add_group G] [topological_add_group G] (s : add_subgroup G) : add_subgroup G
(B : Type v) [decidable_eq B] [fintype B] : Type v
{α : Type u} : function.injective free_group.of
{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b = 0 ↔ b * a = 0
{α : Type u_1} [monoid α] {a b u : α} (hu : is_unit u) : a * u ∣ b ↔ a ∣ b
 : Type
(α : Type u_1) : Type u_1
{α : Type u_2} [monoid α] : monoid (filter α)
{M : Type u_2} [add_comm_group M] {R : Type u_1} : has_involutive_neg (ray_vector R M)
(α : Type u) : Type
(Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)] : valued (ratfunc Fq) (with_zero (multiplicative ℤ))
(R : Type u) [semiring R] [nontrivial R] (p q : ℕ) [char_p R p] [exp_char R q] : q = 1 ↔ p = 0
(α : Type u) : Type u
{α : Type u_1} {r : α → α → Prop} {c : set α} (hc : is_chain r c) : ∃ (M : set α), is_max_chain r M ∧ c ⊆ M
(K : Type u_1) : Type u_1
{B : Type u_1} {E : B → Type u_2} : bundle.total_space E → B
{α : Type u} [topological_space α] {s : set α} (h : is_closed s) : interior (frontier s) = ∅
{R : Type u_1} [comm_ring R] (s : subring R) (m : multiset R) : (∀ (a : R), a ∈ m → a ∈ s) → m.prod ∈ s
{α : Type u} (s : wseq α) : computation (list α)
(α : Type u_8) : Type u_8
{ι : Type u_1} (R : Type u_3) {A : Type u_5} (x : ι → A) [comm_ring R] [comm_ring A] [algebra R A] : Prop
{α : Type u_2} [bornology α] (s : set α) : Prop
{G : Type u_1} [group G] : has_bracket G G
{ι : Type u_1} (A : ι → Type u_2) [add_monoid ι] : Type (max u_1 u_2)
{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order β] [lattice α] (gi : galois_insertion l u) : lattice β
{α : Type u} [has_zero α] [has_add α] : list α → list α → list α
{M : Type u_1} [monoid M] (P : submonoid M) : Prop
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_products C] : category_theory.limits.has_finite_biproducts C
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape ι} (A B : homological_complex V c) : Type (max u_1 v)
{n : Type u_1} {R : Type u₂} [decidable_eq n] [comm_ring R] (i j : n) (c : R) : matrix n n R
{α : Type u} {β : α → Type v} [decidable_eq α] (m : hash_map α β) (a : α) : bool
{α : Type u_1} (xs : lazy_list α) : lazy_list α
(C : Type u) [category_theory.category C] : Type (max u v)
{ι : Type u_1} (A : ι → Type u_2) [add_monoid ι] [graded_monoid.gmonoid A] : monoid (graded_monoid A)
(C : Type u) : Type (u+1)
{α : Type u_1} (m : set α → ennreal) : measure_theory.outer_measure α
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) (s : set α) (hs : is_open s) : local_homeomorph α β
{α : Type u_1} {β : Type u_2} [decidable_eq β] (f : α → β) (s : finset α) : finset β
{P : Type u_1} [preorder P] [order_bot P] : order_top (order.pfilter P)
(R : Type u₁) [comm_semiring R] (p : ℕ) : Type u₁
{α : Type u_1} [has_repr α] : has_repr (generalized_continued_fraction.pair α)
(M : Type u) [monoid M] {R : Type v} [ring R] [mul_semiring_action M R] (S : subring R) : Prop
{α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_dist x s)
{α : Type u} [inhabited α] : lazy_list α → α
{α : Type u_1} (r : α → α → Prop) [decidable_rel r] [is_trans α r] [is_antisymm α r] [is_total α r] (s : finset α) : list α
{o : ordinal} : ordinal.principal has_mul.mul o ↔ o ≤ 2 ∨ ∃ (a : ordinal), o = ordinal.omega ^ ordinal.omega ^ a
{K : Type u_1} [field K] [uniform_space K] : uniform_space.completion K → uniform_space.completion K
{R : Type u} [ring R] (s : set R) : subring R
(F : Type u_7) (α : out_param (Type u_8)) (β : out_param (Type u_9)) [has_inf α] [has_inf β] : Type (max u_7 u_8 u_9)
(R : Type u_1) [comm_semiring R] (X : Type u_2) : Type (max u_1 u_2)
{α : Type u} {β : Type v} {fa : α → α} {fb : β → β} {g : α → β} (h : function.semiconj g fa fb) : set.maps_to g (function.fixed_points fa) (function.fixed_points fb)
(R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R] : ∃ (ϖ : R), irreducible ϖ
(α : Type u_1) [add_right_cancel_semigroup α] [has_one α] : complex_shape α
(R : Type u) {M : Type v} {M₂ : Type w} [semiring R] [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module R M₂] (f : M → M₂) : Prop
(R : Type u_1) [comm_semiring R] : ideal R
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b
{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} : a⁻¹ ≤ b → b⁻¹ ≤ a
(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [bornology α] [bornology β] : Type (max u_6 u_7 u_8)
{M : Type u_2} [add_comm_group M] {R : Type u_1} : has_neg (ray_vector R M)
 : ℕ → list bool
{α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (a0 : 0 ≤ a) : a * b ≤ 1
(R : Type u_1) [comm_ring R] [is_domain R] [is_dedekind_domain R] : Type u_1
{ι : Type u_1} (A : ι → Type u_2) : Type (max u_1 u_2)
{α : Type u_1} {β : Type u_2} (f : list α → α → list α → β) : list α → list α → list β
(α : Type u_2) : Type u_2
{ι : Type u} (β : ι → Type v) [Π (i : ι), has_zero (β i)] : Type (max u v)
 : ℕ → name × ℕ
(C : Type u) [category_theory.category C] : Prop
{α : Type u} (l l' : list α) : Prop
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) (i : zmod 2) : submodule R (clifford_algebra Q)
{m : Type u → Type u} [applicative m] {α β : Type u} (F : α → m β) : free_magma α → m (free_magma β)
{α : Type u_1} {β : Type u_2} [preorder β] [decidable_rel has_lt.lt] (f : α → β) (l : list α) : option α
{α : Type u_3} {β : Type u_4} (r : α → β → Prop) [Π (a : α), decidable_pred (r a)] (s : finset α) (t : finset β) : finset (α × β)
{𝕜 : Type u_1} {V : Type u_2} [normed_field 𝕜] [add_comm_group V] [module 𝕜 V] (e : enorm 𝕜 V) : subspace 𝕜 V
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] : category_theory.preadditive (category_theory.idempotents.karoubi C)
{V : Type u} (G : simple_graph V) : Type u
{α : Type u_2} [monoid α] (s : set α) : Prop
(α : Type u) [uniform_space α] : UniformSpace
{α : Type u} : dlist α → dlist α → dlist α
(G : Type u_1) [add_group G] : add_torsor G G
{α : Type u_1} {n : ℕ} (v : vector α n) : vector.map id v = v
{m n k : ℕ} (H : k ∣ m * n) : {d // k = ↑(d.fst) * ↑(d.snd)}
[Π (P : Prop), decidable P] : functor finset
(M : Type u_3) [mul_one_class M] : Type u_3
(R : Type u_1) [comm_ring R] [nontrivial R] : strong_rank_condition R
{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] [topological_space Z] (proj : Z → B) : Prop
{a : Type u} : has_coe_t a (option a)
(α : Type u) [monoid α] : category_theory.category (category_theory.single_obj α)
(K : Type u) [field K] : Type u
{M : Type u_1} [monoid M] {s : set M} (hs : is_submonoid s) {l : list M} : (∀ (x : M), x ∈ l → x ∈ s) → l.prod ∈ s
{ι : Type u_1} (M : ι → Type u_2) [Π (i : ι), monoid (M i)] : Type (max u_1 u_2)
{α : Type u} {β : Type v} [preorder β] (f : α → β) (s : set α) (a : α) : Prop
{C : Type u} [category_theory.category C] (X Y : C) [category_theory.limits.has_binary_product X Y] : C
{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : f 1 = 1
(M : Type u_1) [has_one M] : one_hom M M
(ρ : Type u) (m : Type u → Type v) (α : Type u) : Type (max u v)
{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : -a ≤ 0 → 0 ≤ a
{G : Type u_1} [add_group G] (K : add_subgroup G) {l : list G} : (∀ (x : G), x ∈ l → x ∈ K) → l.sum ∈ K
(M₀ : Type u_4) : Type u_4
(α : Type u_1) [encodable α] : decidable_pred (λ (_x : ℕ), _x ∈ set.range encodable.encode)
{α : Type u_1} [cancel_comm_monoid_with_zero α] [wf_dvd_monoid α] [gcd_monoid α] : unique_factorization_monoid α
(C : Type u) [category_theory.category C] : category_theory.essentially_small C ↔ small (category_theory.skeleton C) ∧ category_theory.locally_small C
{α : Type u_3} {β : Type u_4} {γ : Type u_5} [lattice α] [lattice β] [lattice γ] (f : lattice_hom β γ) (g : lattice_hom α β) : lattice_hom α γ
{X : Type u_1} [topological_space X] (F : set X) (x y : X) : Prop
{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] (K : nnreal) (f : α → β) (s : set α) : Prop
(k : Type u_1) {V : Type u_2} (P : Type u_3) [ring k] [add_comm_group V] [module k V] [add_torsor V P] (n : ℕ) : Type u_3
{α : Type u_1} {β : Type u_2} : list α → list β → list (α × option β)
{C : Type u} [category_theory.category C] {O : C} (hO : category_theory.limits.is_zero O) : category_theory.limits.has_zero_morphisms C
(α : Type u) [decidable_eq α] (β : α → Type v) : Type (max u v)
{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a + b < c → b < -a + c
(R : Type u₁) [comm_semiring R] (p : ℕ) [hp : fact (nat.prime p)] [char_p R p] : subsemiring (ℕ → R)
{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → α → α
{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] (proj : Z → B) : Type (max u_2 u_3 u_4)
(α : Type u_1) (R : Type u_2) [topological_space α] [topological_space R] [semiring R] [topological_semiring R] : subsemiring (α → R)
{n : ℕ} {A : Type u} (F : A → typevec n → Type u) [Π (α : A), mvfunctor (F α)] [Π (α : A), mvqpf (F α)] : mvpfunctor n
{α : Type u_1} [circular_preorder α] {a b c : α} : has_btw.btw a b c ↔ has_btw.btw c a b
{n : ℕ} : order_of (dihedral_group.r 1) = n
{α : Type u_1} {β : Type u_2} [nontrivial β] {f : α → β} (hf : function.surjective f) : nontrivial α
{α : Type u} [topological_space α] {s : set α} : dense s → dense (closure s)
(C : Type u₁) [category_theory.category C] (D : Type u₂) [category_theory.category D] : category_theory.category (C × D)
{α : Type u_1} (s : finset α) : s.powerset.card = 2 ^ s.card
(x y c : bool) : bool
{α : Type u_1} [monoid α] {a u : α} (hu : is_unit u) : u ∣ a
{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x : M} [no_zero_smul_divisors R M] (h : same_ray R x (-x)) : x = 0
{α : Type u_1} {ι : Type u_4} (p : ι → Prop) (s : ι → set α) : Prop
{β : Type w} {C : Type u} [category_theory.category C] (f : β → C) : Prop
 : Type (u_1+1)
(M : Type u_1) [monoid_with_zero M] : is_square 0
(R : Type u₁) (L : Type u₂) [comm_ring R] [lie_ring L] [lie_algebra R L] : tensor_algebra R L → tensor_algebra R L → Prop
{C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] [category_theory.mono (category_theory.limits.terminal.from A)] : category_theory.is_subterminal A
 : Set → Set → Set
{G : Type u_1} [group G] (s : set G) : set G
(R : Type u_1) (V : Type u_2) [semiring R] [add_comm_group V] [module R V] : ℕ
{m : Type u → Type u} [applicative m] {α β : Type u} (F : α → m β) (x : free_semigroup α) : m (free_semigroup β)
{α : Type u_1} [B : bornology α] (m : metric_space α) (H : ∀ (s : set α), bornology.is_bounded s ↔ bornology.is_bounded s) : metric_space α
{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → ordnode α × ordnode α
{G : Type u_1} [group G] (s : set G) : is_subgroup (group.normal_closure s)
{K : Type u_1} [field K] (A : valuation_subring K) : Type u_1
(F : Type u → Type v) [functor F] : Type (max (u+1) v)
(C : Type u) [category_theory.category C] : Prop
{α : Type u_1} : list α → rbmap ℕ α has_lt.lt
(R : Type u_1) (M : Type u_9) [semiring R] [add_comm_monoid M] [module R M] : Type u_9
{β : Type w} {C : Type u} [category_theory.category C] (f : β → C) : Type (max w u v)
{α : Type u_1} (f : α → α) : list α → list α
{α : Type u} (p : α → Prop) [decidable_pred p] (s : wseq α) : wseq ℕ
(α : Type u_1) : ℕ
(α : Type u) [topological_space α] : Prop
 : real.cos (real.pi / 3) = 1 / 2
{α : Type u_1} (R : α → α → Prop) : list α → Prop
(a b : ℕ) : a ^ 2 - b ^ 2 = (a + b) * (a - b)
{a : Prop} {b : Sort v} (h₁ : a) (h₂ : ¬a) : b
{α : Type u_1} (C : set (set α)) : Prop
 : snum → snum
{α : Type u} {β : Type v} [topological_space α] [preorder β] (f : α → β) (s : set α) (a : α) : Prop
(X : Type u) [topological_space X] (x : X) : Type u
 : snum → bool
{α : Type u_1} [inhabited α] : semiquot α
{M₁ : Type u_1} {M₂ : Type u_2} [has_neg M₂] [has_involutive_neg M₁] (f : M₁ → M₂) (hf : function.surjective f) (inv : ∀ (x : M₁), f (-x) = -f x) : has_involutive_neg M₂
(C : Type u) [𝒞 : category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_pullbacks C
{H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] [totally_disconnected_space H] : topological_space.is_topological_basis {s : set H | is_clopen s}
{V : Type u} [quiver V] {a b c : V} : quiver.path a b → quiver.path b c → quiver.path a c
{α : Type u} {β : Type v} (f : filter α) (g : filter β) : filter (α × β)
(M : Type u_1) (N : Type u_2) [monoid M] [monoid N] : Type (max u_2 u_1)
(C : Type u) [category_theory.category C] [category_theory.limits.has_limits_of_size C] : category_theory.limits.has_limits_of_size C
{G : Type u} [group G] (B : group_filter_basis G) : G → filter G
(R : Type u_1) [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) : galois_insertion (λ (r : ↥(set.Ioi 0)), int.clog b ↑r) (λ (z : ℤ), ⟨↑b ^ z, _⟩)
(α : Type u) : category_theory.presieve α
{α : Type u_2} {β : Type u_3} {γ : Type u_4} [topological_space α] [topological_space β] [topological_space γ] (f : spectral_map β γ) (g : spectral_map α β) : spectral_map α γ
{α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] : a < b - c ↔ a + c < b
{α : Type u} (β : α → Type (max u v)) [fin_enum α] [Π (a : α), fin_enum (β a)] : list (Π (a : α), β a)
 : Type
(M : Type u) [monoid M] (F : Type v) [field F] [mul_semiring_action M F] : subfield F
(L : first_order.language) (M : Type w) [L.Structure M] : Type w
{R : Type u_2} {Γ₀ : Type u_3} [linear_ordered_add_comm_monoid_with_top Γ₀] [comm_ring R] (v : add_valuation R Γ₀) : ideal R
(α : Type u_2) : Type u_2
(m : Type u → Type v) (n : Type u → Type w) : Type (max (u+1) v w)
{R : Type u} [ring R] {S : set R} (hs : is_subring S) : subring R
{C : Type u} [category_theory.category C] (X : C) : Prop
{α : Type u_1} {β : Type u_2} {γ : Type u_3} (e : local_equiv α β) (e' : local_equiv β γ) : local_equiv α γ
(T : Type u) [topological_space T] : category_theory.pretopology.to_grothendieck (topological_space.opens T) (opens.pretopology T) = opens.grothendieck_topology T
(α : Sort u_1) (β : Sort u_2) : Sort (max 1 (imax u_1 u_2) (imax u_2 u_1))
{K : Type u_1} [has_repr K] : has_repr (generalized_continued_fraction.int_fract_pair K)
(n : Type u_1) (R : Type u₂) [decidable_eq n] [comm_ring R] [fintype n] : lie_subalgebra R (matrix n n R)
(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] : category_theory.pretopology C
(n : ℕ) : ennreal
(α : Type u_6) (β : Type u_7) [preorder α] [preorder β] [add_zero_class α] [add_zero_class β] : Type (max u_6 u_7)
 : num → ℕ → num
(α : Type u_1) {β : Type u_2} (b : β) (h : function.surjective (function.const α b)) : unique β
(P : pfunctor) (α : Type u_2) : Type (max u_1 u_2)
{K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] (n : ℕ) [fact (finite_dimensional.finrank K V = n + 1)] : finite_dimensional K V
{α : Type u} [preorder α] {a b : α} : a < b → a ≤ b
{α : Type u_2} [has_div α] : has_div (filter α)
(α : Type u) [complete_lattice α] : omega_complete_partial_order α
 : Type
(α : Type u) [topological_space α] : Prop
{α : Type u_1} (o : ordinal) (f : Π (a : ordinal), a < o → α) : set α
{α : Type u} (n : α → filter α) : topological_space α
{R : Type u_1} [add_cancel_monoid R] (g : R) : is_add_regular g
(n : pos_num) : Prop
{R : Type u} [non_assoc_semiring R] (s : subsemiring R) {x y : R} : x ∈ s → y ∈ s → x * y ∈ s
{α : Type u} {β : Type v} [topological_space α] [preorder β] (f : α → β) (a : α) : Prop
(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : galois_insertion (affine_span k) coe
{α : Type u_1} [linear_ordered_add_comm_group α] {n : ℤ} (hn : n ≠ 0) : function.injective (λ (_x : α), n • _x)
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a ≤ 0) (hb : b < 0) : a + b < 0
{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : 1 < a⁻¹ → a < 1
{α : Type u} {r : α → α → Prop} {s : set α} : directed_on r s → directed r coe
{X : Type u_1} [topological_space X] {x y : X} (γ : path x y) {x' y' : X} (hx : x' = x) (hy : y' = y) : path x' y'
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D : homological_complex V c} (f : homotopy_equiv C D) : homotopy_equiv D C
 : Type (u+1)
{R : Type u_1} [mul_zero_class R] : is_right_regular 0 ↔ subsingleton R
(M : Type u) : Type u
(E : Type u_6) [add_comm_group E] [has_norm E] : Prop
{α : Type u_1} (f : filter α) : Prop
{R : Type u} [non_assoc_semiring R] (s : subsemiring R) (m : multiset R) : (∀ (a : R), a ∈ m → a ∈ s) → m.sum ∈ s
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0
{α  : Type
{G : Type u_1} [monoid G] (tG : monoid.is_torsion G) : group G
(k : Type u_1) {V : Type u_2} (P : Type u_3) [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] : collinear k ∅
{n : ℕ} {α : fin (n + 1) → Type u} (x : α 0) (p : Π (i : fin n), α i.succ) (i : fin (n + 1)) : α i
 : has_inv pgame
{α : Type u_1} [cancel_comm_monoid_with_zero α] [normalized_gcd_monoid α] (s : multiset α) : α
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{α : Type u_1} [encodable α] {n : ℕ} : encodable (vector α n)
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b ≤ 0) : a + b < 0
(R : Type u) [non_unital_semiring R] [partial_order R] : Type u
{α : Type u} [is_empty α] : unique (filter α)
(C : Type u) [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_binary_products C] : category_theory.monoidal_category C
{α : Type u} [topological_space α] (x : α) : set α
{C : Type u} [category_theory.category C] (X Y : C) : Prop
{C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_binary_product A A] [category_theory.is_iso (category_theory.limits.diag A)] : category_theory.is_subterminal A
 : Type (u+1)
{C : Type u₁} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) [category_theory.limits.has_binary_product A A] : category_theory.is_iso (category_theory.limits.diag A)
(p : ℕ) [fact (nat.prime p)] (R : Type u₁) [comm_semiring R] [char_p R p] [perfect_ring R p] : perfection_map p (ring_hom.id R)
(R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [char_zero R] : char_zero K
{V : Type u} (G : simple_graph V) (v : V) : set V
{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : 1 < a⁻¹ ↔ a < 1
(α : Type u) [infinite α] : ultrafilter α
(n : ℕ) : finset (ℕ × ℕ)
{V : Type u_1} {α : Type u_2} [has_zero α] [has_one α] [decidable_eq α] [decidable_eq V] (A : matrix V V α) : matrix V V α
 : num → ℕ → bool
(c : cardinal) : ordinal
 : onote → onote → onote
{α : Type u} (p : α → Prop) [decidable_pred p] : ordnode α → ordnode α
{A : Type v} [ring A] : has_bracket A A
{α : Type u_1} {A : Type u_3} [add_group A] [monoid α] [distrib_mul_action α A] : mul_action α (add_subgroup A)
{α : Type u} [preorder α] {f : ℤ → α} (hf : monotone f) (n : ℤ) {x : α} (h1 : f n < x) (h2 : x < f (n + 1)) (a : ℤ) : f a ≠ x
{k : Type u_1} {E : Type u_2} {PE : Type u_3} [field k] [add_comm_group E] [module k E] [add_torsor E PE] (f : k → PE) (a b : k) : E
(R : Type u_1) [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (v : M) (h : v ≠ 0) : module.ray R M
 : turing.to_partrec.code
{α : Type u} (c : computation α) : computation α
{M : Type u_1} [has_mul M] (S : subsemigroup M) : set M
 : Type
 : Type (u+1)
{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : a < 0) (hb : b < 0) : 1 / a < 1 / b ↔ b < a
(G : Type u_1) [comm_group G] [topological_space G] [topological_group G] : uniform_space G
(G : Type u_1) [add_group G] : set G
(α : Type u) : Type u
{α : Type u} {β : Type v} [topological_space α] [topological_space β] [compact_space α] [compact_space β] : compact_space (α × β)
{K : Type u_1} [field K] {p : ℕ} [char_p K p] {t : ℕ} (not_dvd : ¬p ∣ t) : invertible ↑t
{n : ℕ} : bitvec n → bitvec n → bool
{R : Type u_1} {S : Type u_3} [non_unital_comm_ring R] [non_unital_comm_ring S] : non_unital_comm_ring (R × S)
(L : first_order.language) : Prop
(o : ordinal) : ordinal
{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] {p : ι → E} (hc : convex_independent 𝕜 p) : function.injective p
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) : Prop
{α : Type u_1} (x : α) : list α → Prop
{α : Type u} [lattice α] [bounded_order α] (x y : α) : Prop
{α : Type u_1} [ring α] (t : ring_topology α) : add_group_topology α
(α : Type u_1) [fintype α] : finite α
{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : a ≤ 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1
(M : Type u_1) [has_add M] : add_hom M M
{α : Type} (p : parser α) : Prop
{α : Type u_1} [has_le α] (s : set α) : Prop
 : nat.partrec.code
{ι : Type u_1} (A : ι → Type u_2) [add_comm_monoid ι] : Type (max u_1 u_2)
(R : Type u_1) (m : Type u_2) (n : Type u_3) [fintype m] [fintype n] [semiring R] : basis (m × n) R (matrix m n R)
{α : Type u_1} [monoid α] (a : α) : conj_classes α
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (r : R) : with_zero (multiplicative ℤ)
{α : Type u_1} {n : ℕ} (i : fin2 n) (v : vector3 α n) : α
(G : Type u) : Type u
{α : Type u_1} [fintype α] (h : 0 < fintype.card α) : trunc α
{α : Type u_1} (p : α → Prop) : list α → Prop
{α : Type u_1} [semilattice_inf α] [order_top α] (s : multiset α) : α
{α : Type u_1} {β : Type u_2} (r : α → β → Prop) : multiset α → multiset β → Prop
{G : Type u_1} [add_group G] [topological_space G] [t2_space G] [topological_add_group G] [measurable_space G] [borel_space G] (K₀ : topological_space.positive_compacts G) : measure_theory.measure G
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] (F : ι → α → β) (f : α → β) (p : filter ι) (s : set α) : Prop
{α : Type u} {f g : α → α} (h : function.commute f g) : set.bij_on g (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g))
(n : ℕ) : finset (fin n)
{α : Type u_2} [has_mul α] : has_mul (set α)
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) : add_localization S
(k : ℕ) : nat.arithmetic_function ℕ
{β : Type u} {α : Type v} [comm_monoid β] (s : finset α) (f : α → β) : β
{M : Type u_5} {N : Type u_6} {P : Type u_7} [has_add M] [has_add N] [add_comm_semigroup P] (f : add_hom M P) (g : add_hom N P) : add_hom (M × N) P
 : has_add pgame
(α : Type u_1) (β : Type u_2) : Type (max u_1 u_2)
{α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : a * -1 = -a
{R : Type u_1} [comm_semiring R] {S : Type u_2} [comm_semiring S] [algebra R S] (x : R) [is_localization.away x S] : S
{α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 3
{A : Type u_1} {ι : Type u_2} [ring A] [nonempty ι] {B : ι → add_subgroup A} (hB : ring_subgroups_basis B) : ring_filter_basis A
{α : Type u_1} [linear_order α] (a : α) : {a}.max' _ = a
{α : Type u} (a : α) : wseq α → wseq α
{R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_left_regular a) : is_add_left_regular (a + b) ↔ is_add_left_regular b
{n : ℕ} (P : mvpfunctor (n + 1)) (α : typevec n) : Type u
{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] [invertible 2] : can_lift (bilin_form R M) (quadratic_form R M)
{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] (g : G) : continuous (λ (h : G), g * h * g⁻¹)
(α : Type u_1) [measurable_space α] : Type u_1
 : num → num → znum
(α : Sort u) [has_variable_names α] {β : Sort v} : has_variable_names β
(C : Type u) [category_theory.category C] : Prop
(M : Type u_1) (α : Type u_2) [monoid M] [topological_space α] [mul_action M α] : Prop
{R : Type u₁} [monoid R] [has_distrib_neg R] (a : R) : (-a) ^ 2 = a ^ 2
(R : CommRing) : algebraic_geometry.Scheme
 : simps_cfg
(α : Type u) : Type u
(n : ℕ) : Type
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] [locally_compact_space α] [locally_compact_space β] : continuous continuous_map.uncurry
(R : Type u) {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (s : set A) : subalgebra R A
{V : Type u} (G : simple_graph V) : ℕ
(X : Type u) [lattice X] : Type u
{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order α] [complete_lattice β] (gi : galois_coinsertion l u) : complete_lattice α
(G : Type u_1) [topological_space G] [add_group G] [topological_add_group G] : add_subgroup G
{𝕜 : Type u_1} {E : Type u_2} [linear_ordered_field 𝕜] [ordered_add_comm_group E] [module 𝕜 E] (s : set E) (hs : convex 𝕜 s) : convex_cone 𝕜 E
{α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] (f : α → β) (s : set α) : Prop
(K : Type u) [division_ring K] {n : ℕ} : finite_dimensional.finrank K (fin n → K) = n
{R : Type u} [semiring R] (n : ℕ) : polynomial R → polynomial R
 : Type
{α : Type u} (g : set (set α)) : set α → Prop
{α : Type u} [preorder α] (s : set α) (a : α) : Prop
{α : Type u_1} {P : set α → Prop} (m : Π (s : set α), P s → ennreal) (P0 : P ∅) (m0 : m ∅ P0 = 0) : measure_theory.outer_measure α
{α : Type v} {m l r : ℕ} (A : matrix (fin m) (fin (l + r)) α) : matrix (fin m) (fin l) α
{α : Sort u_1} {β : Sort u_2} (q : trunc α) (f : α → β) (c : ∀ (a b : α), f a = f b) : β
(α : Type u) [monoid α] : Type u
 : snum → snum
{M : Type u_1} [add_monoid M] {x y z : M} : y ∈ multiples x → z ∈ multiples x → y + z ∈ multiples x
{C : Type u} [category_theory.category C] {X : Top} (F : Top.presheaf C X) : Prop
(T : Type u_1) : Type u_1
{α : Type u} (x : α) : free_ring α
{K : Type u} [field K] : has_top (subfield K)
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (s : set R) : Prop
{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : 1 ≤ a⁻¹ ↔ a ≤ 1
{α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist ∅ s = 0
{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] (f : module.End K V) : complete_lattice.independent f.eigenspace
{α : Type u} [topological_space α] [t2_space α] [compact_space α] : t2_space (connected_components α)
{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 1 < a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b
{ι : Type u_1} [decidable_eq ι] [fintype ι] {α : ι → Type u_2} [S : Π (i : ι), setoid (α i)] (f : Π (i : ι), quotient (S i)) : quotient pi_setoid
{R : Type u_1} [comm_ring R] (E : EllipticCurve R) : R
(G : Type u_1) [has_inv G] [measurable_space G] : Prop
(α : Type u_2) : Type u_2
 : omega.nat.preterm → ℕ
(α : Type u_4) [has_le α] : Type u_4
{α : Type u_1} (f : α → nnreal) (hf0 : tsum f ≠ 0) : pmf α
{ι : Type u_2} [encodable ι] {F : ι → Type u_3} [Π (i : ι), metric_space (F i)] : has_dist (Π (i : ι), F i)
(R : Type u) [semigroup R] : Type u
{C : Type u} [category_theory.category C] (T : category_theory.monad C) : Type u
{n : ℕ} {β : Type u_1} (a : β) (q : fin n → β) (b : β) : fin.cons a (fin.snoc q b) = fin.snoc (fin.cons a q) b
{R : Type u_1} [semiring R] (S : subsemiring R) : subalgebra ℕ R
 : category_theory.reflective Profinite_to_CompHaus
(J : Type v) : Type v
{m n : ℕ} (hmn : m.coprime n) : squarefree (m * n) ↔ squarefree m ∧ squarefree n
(α : Type u) [preorder α] : category_theory.small_category α
{α : Type u_1} [has_add α] (s : set α) (a b : α) : Prop
(C : Type u) [category_theory.category C] [category_theory.limits.has_coproducts C] : category_theory.limits.has_finite_coproducts C
{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) : Prop
{α : Type u} (s : seq α) {aₙ : α} {n m : ℕ} (m_le_n : m ≤ n) (s_nth_eq_some : s.nth n = option.some aₙ) : ∃ (aₘ : α), s.nth m = option.some aₘ
{n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬∃ (t : ℕ), t * t = n
{n : ℕ} {α : Type u_1} (l : list α) (c : composition n) : list (list α)
{α : Type u} [uniform_space α] (h : is_complete set.univ) : complete_space α
{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → multiset.Ico a b = 0
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V ↔ ∃ (x : V), x ≠ 0
{M : Type u_3} {N : Type u_4} {P : Type u_5} [has_add M] [has_add N] [has_add P] (hnp : add_hom N P) (hmn : add_hom M N) : add_hom M P
{m : Type u_2} {α : Type v} (w : m → α) : matrix m unit α
{α : Type u} {β : Type v} (c : computation α) (f : α → computation β) : computation β
(X : BoolAlg) : BoundedDistribLattice
{p : ℕ} [p_prime : fact (nat.prime p)] {a : ℤ} : multiplicity.finite ↑p a ↔ a ≠ 0
{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : 0 ≤ ifp_n.fr ∧ ifp_n.fr < 1
{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) : is_unit A ↔ is_unit A.det
{α : Type u_1} (f : set α → α) : ¬function.injective f
{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) : list (sigma β) → option (β a) × list (sigma β)
(C : Type u) [category_theory.category C] : Prop
(α : Type u_1) : Type u_1
{α : Type u_1} [preorder α] [succ_order α] {a : α} : ¬is_max a → a < order.succ a
(M : Type u_1) [has_add M] : Type u_1
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X → Y} [sequential_space X] : seq_continuous f → continuous f
{G : Type u} [fintype G] [add_left_cancel_monoid G] (x : G) : 0 < add_order_of x
{E : ℕ → Type u_1} (x : Π (n : ℕ), E n) (s : set (Π (n : ℕ), E n)) : ℕ
{M : Type u_1} [has_mul M] : has_inf (subsemigroup M)
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (s : add_submonoid M) (t : add_submonoid N) : add_submonoid (M × N)
{α : Type u} (r : α → α → Prop) : list α → list α → Prop
{α : Type u_2} [mul_one_class α] : mul_one_class (set α)
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0) : a + b ≤ 0
(m : ℕ) : padic_val_rat m 0 = 0
{M : Type u_1} [has_add M] {c : add_con M} (x y : M) : ↑(x + y) = ↑x + ↑y
{α : Type u_1} {β : Type u_2} (f : α → β) (ga : α → α → α) (gb : β → β → β) : Prop
(A : Type u_4) [monoid A] [topological_space A] : continuous_monoid_hom A A
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) [category_theory.limits.has_binary_biproduct P Q] : category_theory.limits.binary_bicone P Q
{R : Type u_1} [ring R] {M : Type u_2} [add_comm_group M] [module R M] (U : submodule R M) (x y : M) : Prop
{α : Type u_2} [has_add α] : has_add (set α)
(F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] (S T : set E) : ↑(intermediate_field.adjoin ↥(intermediate_field.adjoin F S) T) = intermediate_field.adjoin F (S ∪ T)
(k : Type u₁) (G : Type u₂) [semiring k] : G → add_monoid_algebra k G
(n : ℕ) : ℕ → ℕ
{R : Type u_1} [comm_ring R] (E : EllipticCurve R) : R
{α : Sort u_1} {p : α → Prop} {q : Π (x : α), p x → Prop} : (∃ (x : α) (h : p x), q x h) ↔ ∃ (x : {a // p a}), q ↑x _
(R : Type u_2) (Γ₀ : Type u_3) [linear_ordered_comm_monoid_with_zero Γ₀] [ring R] : Type (max u_2 u_3)
 : pgame
(α : Type u) : Type u
{α : Type u_1} (f : α → α) (x : α) : cycle α
{α : Type u_1} (a : α) : part α
{X : Type u} {Y : Type v} [metric_space X] [metric_space Y] : metric_space (X ⊕ Y)
{M : Type u_1} [comm_monoid M] (S : submonoid M) (N : Type u_2) [comm_monoid N] : Type (max u_1 u_2)
{α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b c : α} (h : c ≤ b) (h2 : a - c < b - c) : a < b
(p : Set → Prop) : Set → Set
{α : Type u} [topological_space α] {s t : set α} (H : is_preconnected s) (Kst : s ⊆ t) (Ktcs : t ⊆ closure s) : is_preconnected t
{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : is_add_monoid_hom f
{α : Type u_8} [add_comm_semigroup α] : add_hom (α × α) α
(H : Type u_5) [topological_space H] (M : Type u_6) : Type (max u_5 u_6)
(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom A B
{α : Type u} (s : wseq α) : computation ℕ
(α : Type u_5) : Type u_5
{α : Type u_1} {a : α} {s : set α} (h : a ∈ s) : semiquot α
 : Type
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_limits_of_shape (category_theory.limits.wide_pullback_shape J) C] {B : C} : category_theory.limits.has_limits_of_shape (category_theory.discrete J) (category_theory.over B)
{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) : list (sigma β) → list (sigma β)
{α : Type u_1} [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] [dec : decidable_eq α] (a : α) : multiset {a // irreducible a}
{R : Type u} : tropical R → R
{α : Type u_1} [complete_lattice α] : conditionally_complete_lattice α
{a : ℕ} (a1 : 1 < a) : ℕ → ℕ × ℕ
(g : Type) [random_gen g] : rand_g g g
(L : Type v) [lie_ring L] : non_unital_non_assoc_semiring L
{α : Type u_1} (n : ℕ) (a : α) : list α → list α
(α : Type u_7) (β : Type u_8) [measurable_space α] [measurable_space β] : Type (max u_7 u_8)
{K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : stream (option (generalized_continued_fraction.int_fract_pair K))
(F : Type u → Type v → Type w) [bifunctor F] : Type (max (u+1) (v+1) w)
{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → bool
{n : ℕ} (c : composition_as_set n) : composition n
{α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : m₂ ≤ measurable_space.map f m₁ → measurable f
 : category_theory.limits.has_limits_of_size (Type (max v u))
(α : Type u_2) : Type u_2
(tag : unit) {p : Prop} (h : p) : p
(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] (K : category_theory.pretopology C) : category_theory.grothendieck_topology C
{G : Type u} [add_monoid G] (x : G) : ℕ
{k : Type u_1} {V : Type u_2} [ring k] [add_comm_group V] [module k V] (p : submodule k V) : affine_subspace k V
(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] : matrix (l ⊕ l) (l ⊕ l) R
{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : a - b ≤ 0 → a ≤ b
 : Type
{α : Type u_1} {β : Type u_2} [topological_space α] [polish_space α] [topological_space β] [polish_space β] : polish_space (α ⊕ β)
(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] : matrix (unit ⊕ l ⊕ l) (unit ⊕ l ⊕ l) R
 : Type
(α : Type u_1) [linear_order α] : circular_order α
 : monoid ordinal
 : Type (u_1+1)
{X : Type u_1} [topological_space X] {U : set X} [Π (x : X), decidable (x ∈ U)] (hU : is_clopen U) : locally_constant X (fin 2)
{p : ℕ} : padic_val_rat p 1 = 0
(a : snum) : snum → snum
{α : Type u} : ordnode α → α → ordnode α → α × ordnode α
(p n : ℕ) : ℕ
{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) (a : α) : function.injective (f a)
{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : is_monoid_hom f
{ι : Type u_1} [decidable_eq ι] (A : ι → Type u_2) [has_add ι] [Π (i : ι), add_comm_monoid (A i)] : Type (max u_1 u_2)
{α : Type u_2} {β : Type u_3} (r : α → β → Prop) (t : set β) : set α
{R : Type u} [comm_ring R] [is_noetherian_ring R] : is_noetherian_ring (polynomial R)
(X : Profinite) : category_theory.limits.limit_cone X.diagram
(α : Type u_7) : Type u_7
{a : ℕ} (a1 : 1 < a) (n : ℕ) : ℕ
{α : Type u_2} [has_inv α] : has_inv (set α)
{α : Type u} {β : Type v} [topological_space α] (f : β → set α) : Prop
(R : Type u) (S : Type v) [semiring R] [semiring S] (p q : ℕ) [char_p R p] [char_p S q] : char_p (R × S) (p.lcm q)
{α : Type u} (c₁ c₂ : computation α) : computation α
{α : Type u_2} {β : Type u_3} [preorder α] [preorder β] (l : α → β) (u : β → α) : Type (max u_2 u_3)
{R : Type u} {M : Type v} (x : triv_sq_zero_ext R M) : M
{R : Type u_1} [has_mul R] {a : R} : is_left_regular a ↔ is_smul_regular R a
{A : Type u_2} [comm_ring A] [is_domain A] (h : is_dedekind_domain_inv A) : is_dedekind_domain A
{α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 4
(n : ℕ) : n.choose 2 = n * (n - 1) / 2
{α : Type u} [preorder α] {a b c : α} : b = c → a < b → a < c
(X : Type u_1) : Type u_1
(G : Type u_2) [group G] [fintype G] (R : Type u_3) [comm_ring R] [mul_semiring_action G R] (x : R) : polynomial R
(α : Type u_1) [add_comm_group α] : Type u_1
{n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) : fin.snoc (fin.init q) (q (fin.last n)) = q
 : ¬small ordinal
(R : Type u_1) (S : Type u_2) (M : Type u_3) : Type u_3
 : metric_space (ℕ → ℕ)
{α : Type u_1} {β : Type u_2} (q : pmf (α → β)) (p : pmf α) : pmf β
{α : Type u_2} {β : Type u_3} [monoid α] [mul_action α β] : mul_action α (set β)
{α : Type u_3} [preorder α] (n : ℕ) [grade_order (fin n) α] : grade_order ℕ α
{α : Type u_1} [decidable_eq α] : list α → list (equiv.perm α)
{R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_right_regular a) : is_add_right_regular (b + a) ↔ is_add_right_regular b
{α : Type u_1} {G : Type u_5} [topological_space G] [add_comm_group G] [topological_add_group G] {f : α → G} (hf : summable f) : filter.tendsto f filter.cofinite (nhds 0)
{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 0 → a = 0
{α : Type u_1} (r : α → α → Prop) (rk : α → ℕ) (s : set α) (n : ℕ) (f : ℕ → α) : Prop
(m : ℕ) {n : ℕ} (hn : 0 < n) : (∃ (k : ℕ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m
(x y : Set) : Set
 : Type (u+1)
(α : Type u_6) : Type u_6
{α : Type} (p : parser α) : Prop
(F : Type u → Type u) [functor F] [q : qpf F] : Type u
{α : Type u} [has_mul α] [has_one α] [has_distrib_neg α] (a : α) [invertible a] : invertible (-a)
{L : first_order.language} (K : set (category_theory.bundled L.Structure)) : Prop
{R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_ring A] [algebra R A] (𝒜 : ℕ → submodule R A) [graded_algebra 𝒜] : Top
(n : ℕ) (A : Type u) : mvpfunctor n
{M : Type u_1} [has_add M] : has_bot (add_subsemigroup M)
 : (λ (n : ℕ), ↑(nat.fib n)) = λ (n : ℕ), (golden_ratio ^ n - golden_conj ^ n) / real.sqrt 5
{G : Type u_1} [group G] [group.is_nilpotent G] (h : group.nilpotency_class G ≤ 1) : comm_group G
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (hi : inducing f) (ho : is_open (set.range f)) : is_open_map f
(n : ℕ) : comm_semigroup (fin (n + 1))
(n : ℕ) : Type
 : strict_mono (λ (n : ℕ), nat.fib (n + 2))
{α : Type u_1} {n : ℕ} {s t : finset α} : s ∈ finset.powerset_len n t ↔ s ⊆ t ∧ s.card = n
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) (s : set α) (t : set β) : Prop
{α : Type u_1} [comm_monoid_with_zero α] (a b : α) : Prop
 : ℕ → list ℕ
(F : Type u_9) (α : Type u_10) (β : Type u_11) [monoid α] [monoid β] [topological_space α] [topological_space β] : Type (max u_10 u_11 u_9)
 : Sort u
{α : Type u_1} (s : multiset α) (hs : s ≠ 0) : pmf α
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop
 : Type
{α : Type u} (s : set α) : Prop
{n : ℕ} (h : 0 < n) : random (fin n)
{α : Type} [has_mul α] {ds : list ℕ} : holor α ds → Prop
(p : ℕ → Prop) [decidable_pred p] (n : ℕ) : ℕ
{α : Type u} {β : Type v} (f : α → β) (s : set α) (t : set β) : Prop
{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} [has_coe α β] [has_coe_t β γ] (a : α) : ↑a = ↑↑a
{α : Type u} [pseudo_metric_space α] {x : α} : metric.inf_dist x ∅ = 0
{α : Type u_1} [linear_ordered_field α] (β : Type u_2) [ring β] (abv : β → α) [is_absolute_value abv] : Prop
(α : Type u) (β : Type v) [add_group α] [add_action α β] : setoid β
 : topological_space ennreal
(n : pos_num) : ℕ → pos_num → pos_num
(α : Type u_1) (β : Type u_2) [topological_space α] [topological_space β] : Type (max u_1 u_2)
(M : Type u_5) (N : Type u_6) [has_add M] [has_add N] : add_hom (M × N) M
{V : Type u} (r : V → V → Prop) : simple_graph V
(F : Type u_1) (E : Type u_2) (K : Type u_3) [field F] [field E] [field K] [algebra F E] [algebra F K] : Type (max u_2 u_3)
{G : Type u_1} [add_group G] (H : add_subgroup G) {x y : G} (hx : x ∈ H) (hy : y ∈ H) : x - y ∈ H
{R : Type u_1} [comm_semiring R] {X : Type u_2} : star_ring (free_algebra R X)
(R : Type u) [add_monoid R] : Type u
{γ : Type w} [preorder γ] [order_bot γ] (s : set γ) : bdd_below s
{α : Type u_1} (l : ordnode α) (x : α) (m : ordnode α) (y : α) (r : ordnode α) : ordnode α
(R : Type w) [semiring R] (C : Type u) [category_theory.category C] [category_theory.preadditive C] : Type (max u v w)
 : ℕ
(n : name) : bool
(R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] (x : M) : ideal R
{α β γ : Type} (l : list α) (p : α → β × γ) [decidable_eq β] : list (β × list γ)
(M : Type u) : Type u
{m : Type v → Type w} [applicative m] {α : Type u_1} {β : Type v} (f : ℕ → α → m β) : ℕ → list α → m (list β)
 : Type
(α : Type u_5) (β : out_param (Type u_6)) (γ : out_param (Type u_7)) : Type (max u_5 u_6 u_7)
(α : Type u_1) [topological_space α] : filter α
{M₀ : Type u_1} [mul_zero_one_class M₀] : 0 = 1 → subsingleton M₀
{α : Type u} : wseq α → wseq α → Prop
 : Type
(X : Type u) [has_mul X] [has_zero X] [has_lt X] : Prop
{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (x : B) : Type u_3
{α : Sort u₁} {β : Sort u₂} (g : β → α) (f : α → β) : Prop
{α : Type u_1} [has_le α] (s : set α) : Prop
{K : Type u_1} {β : Type u_2} (f : K → β) (gp : generalized_continued_fraction.int_fract_pair K) : generalized_continued_fraction.int_fract_pair β
{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0
{α : Type u_1} (s : multiset α) : (∃ (x : α), x ∈ s) → trunc α
{R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R ≠ 2) : -1 ≠ 1
{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a
{α : Type u_2} [has_add α] (a : α) : Prop
{α : Type u_1} [preorder α] (t : ordnode α) : Prop
(p : set pSet) : pSet → pSet
{C : Type u₁} [category_theory.category C] {X : C} (S R : category_theory.sieve X) : category_theory.sieve X
(R : Type u_1) (A : Type u_2) [comm_semiring R] [semiring A] [algebra R A] (p : polynomial A) : tensor_product R A (polynomial R)
(C : Type u) : Type (u+1)
{α : Type u_1} [has_le α] [bounded_order α] [is_simple_order α] : preorder α
{α : Type u} {a b : α} [mul_zero_class α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 0 < a) (hb : 0 < b) : 0 < a * b
{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a ≤ 0) (hb : b < 0) : a + b < 0
{α : Type u_1} [conditionally_complete_lattice α] (a : α) : has_Sup.Sup {a} = a
 : Type
(G : Type u) [group G] : Type u
{α : Type u_2} [has_neg α] : has_neg (filter α)
{R : Type v} [comm_ring R] {n : Type u_1} [unique n] [decidable_eq n] [fintype n] (A : matrix n n R) : A.det = A inhabited.default inhabited.default
{M : Type u_1} [mul_one_class M] : has_bot (submonoid M)
(X : Type u_5) [t : topological_space X] : Prop
(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] : Prop
{K : Type u} [hring : comm_ring K] : ratfunc K → ratfunc K → ratfunc K
(m M N : ℕ) (i : Σ (n : ℕ), fin n → ℕ) (hi : i ∈ formal_multilinear_series.comp_partial_sum_source m M N) : Σ (n : ℕ), composition n
{α : Type u} [has_mul α] [has_one α] (a : α) : Type u
{G : Type u_1} [group G] (H : ℕ → subgroup G) (hH : is_ascending_central_series H) (n : ℕ) : H n ≤ upper_central_series G n
{α : Type u_1} [preorder α] [order_bot α] [locally_finite_order α] (b : α) : multiset α
(α : Type u_1) : Type u_1
{α : Type u_1} {β : Type u_2} : list α → list β → list (option α × β) × list α
 : Type
{α : Type u} {β : Type v} (f₁ f₂ : α → β) (s : set α) : Prop
(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A) : category_theory.faithful (category_theory.shift_functor C i)
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} : transitive (category_theory.abelian.pseudo_equal P)
(α : Sort u) (β : α → Sort v) : setoid (Π (x : α), β x)
{C : Type u} [category_theory.category C] [category_theory.abelian C] : category_theory.limits.has_pullbacks C
(α : Type u_1) : Type u_1
(α : Type u) [add_group α] : Type u
(α : Type u_5) : Type u_5
{A : Type u_2} [comm_ring A] [is_domain A] : is_dedekind_domain A ↔ is_dedekind_domain_inv A
{M : Type u_1} [has_mul M] {r s : M → M → Prop} (h : ∀ (x y : M), r x y → s x y) : con_gen r ≤ con_gen s
{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order β] [semilattice_inf α] (gi : galois_insertion l u) : semilattice_inf β
{α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (b0 : 0 ≤ b) : 1 ≤ a * b
{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → option α
{α : Type u_1} [decidable_eq α] {s t u : multiset α} : s - t ≤ u ↔ s ≤ u + t
{α : Type u_1} (R : α → α → Prop) : α → list α → Prop
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α] : continuous coe_fn
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) : Prop
{α : Type u_1} [comm_semigroup α] {a b : α} (h : a ∣ b) (c : α) : a ∣ c * b
{p : ℕ → Prop} [decidable_pred p] {n : ℕ} : ¬p n → nat.count p (n + 1) = nat.count p n
(𝕜 : Type u_1) (E : Type u_2) [comm_semiring 𝕜] [topological_space 𝕜] [has_continuous_add 𝕜] [has_continuous_const_smul 𝕜 𝕜] [add_comm_monoid E] [module 𝕜 E] [topological_space E] : Type u_2
{α : Type u} [add_comm_group α] : is_add_group_hom has_neg.neg
{K : Type u_1} (v : K) [linear_ordered_field K] [floor_ring K] : simple_continued_fraction K
{α : Type u_2} {β : Type u_3} [topological_space α] [preorder α] [topological_space β] [preorder β] (f : esakia_hom α β) : pseudo_epimorphism α β
{K : Type u} {A : Type v} [field K] [ring A] [algebra K A] {x : A} : is_algebraic K x ↔ is_integral K x
 : onote → onote → ordering
{α : Type u_1} [semigroup α] {a b : α} (h : a ∣ b) (c : α) : a ∣ b * c
{α : Type u} [linear_order α] : α → α → set α
{ι : Type u_1} {E : ι → Type u_2} [Π (i : ι), metric_space (E i)] : has_dist (Σ (i : ι), E i)
{C : Type u_1} [category_theory.category C] (r : hom_rel C) : Prop
(n : ℕ) (R : Type u_1) [ring R] : polynomial.map (int.cast_ring_hom R) (polynomial.cyclotomic n ℤ) = polynomial.cyclotomic n R
(m n : ℤ) : list ℤ
 : Type u → Type u
 : category_theory.limits.has_limits_of_size Group
{M : Type u_3} [add_comm_group M] {R₂ : Type u} [ordered_ring R₂] [module R₂ M] (Q₂ : quadratic_form R₂ M) : Prop
(α : Type u_3) [has_sup α] [has_bot α] : sup_bot_hom α α
 : snum → ℤ
 : onote → onote → onote
{α : Type u_1} [group α] : has_quotient α (subgroup α)
 : Type (u_1+1)
(α : Type u) : Type u
{R : Type u} [semiring R] {a b : add_monoid_algebra R ℕ} : {to_finsupp := a} = {to_finsupp := b} ↔ a = b
 : ℕ → ℕ
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.has_terminal C
{α : Type v} {d u l r : ℕ} (A : matrix (fin (u + d)) (fin (l + r)) α) : matrix (fin d) (fin r) α
{M : Type u_1} [add_comm_monoid M] {s : set M} (hs : is_add_submonoid s) (m : multiset M) : (∀ (a : M), a ∈ m → a ∈ s) → m.sum ∈ s
(G : Type u_1) [group G] : set G
{G : Type u_10} [group_with_zero G] (a : G) (ha : a ≠ 0) : equiv.perm G
 : set.inj_on nat.factorization {x : ℕ | x ≠ 0}
{ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] : free_product.word M
{α : Type uu} {r : α → α → Prop} [decidable_rel r] {l : list α} (h : list.sorted r l) : list.insertion_sort r l = l
{x k l : ℕ} (w : 1 < x) : x ^ k ∣ x ^ l ↔ k ≤ l
{α : Type u_1} [is_empty α] : finset.univ = ∅
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : function.surjective proj
(J : Type v) : Type v
{α : Sort u_1} [s : setoid α] : quotient s → α
(L : first_order.language) (M : Type u_3) [L.Structure M] : Type u_3
{M : Type u_1} [monoid M] (S : submonoid M) : submonoid M
(R : Type u_1) (S : Type u_2) [comm_ring R] [comm_ring S] [algebra R S] : bilin_form R S
{K : Type u} [field K] {S T : subfield K} (h : ∀ (x : K), x ∈ S ↔ x ∈ T) : S = T
{α : Type u_1} (r : α → α → Prop) (s t : set α) : Prop
{α : Type u_2} [decidable_eq α] [has_one α] [has_mul α] [has_inv α] : has_pow (finset α) ℤ
{J : Type u₁} [category_theory.category J] : J → J → Prop
{M : Type u_1} [add_zero_class M] (c : add_con M) : add_con.ker c.mk' = c
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} (C D : homological_complex V c) : Type (max u_1 v)
{α : Type u_1} [group α] (s : subgroup α) : setoid α
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : quotient_map proj
 : ℕ → onote
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e e' : local_homeomorph α β) : Prop
{R : Type u} [comm_ring R] (f : polynomial R) (x y : R) : {z // polynomial.eval x f - polynomial.eval y f = z * (x - y)}
(α : Type u_2) [has_lt α] : Prop
(α : Type u_1) : Type u_1
{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b) : closure (set.Ioo a b) = set.Icc a b
(α : Type u) [topological_space α] : Prop
(α : Type u_1) : setoid (list α)
{α : Type u} [group α] (g : group_topology α) : continuous (λ (p : α × α), p.fst * p.snd)
{α : Type u} [pseudo_metric_space α] {s t : set α} : metric.bounded (s ∪ t) ↔ metric.bounded s ∧ metric.bounded t
{α : Sort u} {β : Sort v} {f : α → β} [inhabited α] [subsingleton β] (hf : function.injective f) : unique α
{R : Type u_1} {a b : R} [semigroup R] (ab : is_regular (a * b)) (ba : is_regular (b * a)) : is_regular a ∧ is_regular b
{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 1 < a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b
(L : Type v) : Type v
(L : first_order.language) : Type (max u v)
{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a < b → a - b < 0
(R : Type u_1) [has_one R] [has_neg R] : cardinal.mk (quaternion R) = cardinal.mk R ^ 4
 : Type
(α : Type u) : Type u
(α : Type u_1) (β : Type u_2) : Type (max u_1 u_2)
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x : L} : x ∈ S → -x ∈ S
{α : Type u_1} {β : Type u_2} [has_le β] [decidable_rel has_le.le] (f : α → β) (t : ordnode α) : ordnode β
{a b : Prop} (h₁ : a → b) (h₂ : ¬b) : ¬a
(α : Type u) [has_add α] [has_le α] : Prop
 : Type
 : category_theory.abelian AddCommGroup
{M : Type u} [mul_one_class M] (a : M) : semiconj_by a 1 1
{α : Type u} {β : Type v} {δ : Type w} (f : α → β → δ) : lazy_list α → lazy_list β → lazy_list δ
(α : Type) [has_zero α] [has_one α] [has_add α] : parser α
{K : Type u} [field K] (s : subfield K) : 1 ∈ s
{α : Type u_2} [decidable_eq α] [add_comm_monoid α] : add_comm_monoid (finset α)
{X : Type u_1} (to_two_(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : ℕ
(F : Type u → Type u) [applicative F] [is_lawful_applicative F] : applicative_transformation id F
{α : Type u} [decidable_eq α] (i j : α) : setoid (equiv.perm α)
 : Type
(α : Type u) : bool → Type u
{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b = 0 ↔ a = 0 ∨ b = 0
{G : Type u_1} [group G] (s : set G) : Prop
(n : ℕ) : Type
(p : ℕ) [hp : fact (nat.prime p)] (n : ℕ) : mv_polynomial (fin 2 × ℕ) ℤ
{M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : 0 < L.sum) : 0 < L.length
(p : ℕ) : ℕ → ℤ
(G : Type u_1) [group G] : Prop
{α : Type u_1} [add_right_cancel_semigroup α] (a : α) : complex_shape α
{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1
{X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C : nnreal} {f : X → Y} {s : set X} : lipschitz_on_with C f s → holder_on_with C 1 f s
{α : Type u_1} [decidable_eq α] : list α → list α
{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (b0 : 0 < b) : a * b ≤ 1
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] : setoid (local_homeomorph α β)
(f : ordinal → ordinal) : Prop
(α : Type u_1) (β : Type u_2) [linear_order α] [linear_order β] : Type (max u_1 u_2)
{α : Type u_1} [omega_complete_partial_order α] (y : Scott α) : set (Scott α)
(n : name) : name
{R : Type u₁} [non_unital_non_assoc_semiring R] : smul_comm_class ℕ R R
{α : Type u_1} [semigroup α] {a b : α} (c : α) (h : a * c = b) : a ∣ b
{α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) : is_compact t
{α : Type u} {β : α → Type v} (a : α) (b : β a) : alist β
{R : Type u_1} [semiring R] (s : set R) : subsemiring R
(x y f : Set) : Prop
 : Type (u+1)
 : Type (u_1+1)
{α : Type u_1} (a : α) (s : multiset α) : multiset α
(k : Type u) [field k] : Type u
 : Type
{n : ℕ} (a : composition n) (b : composition a.length) : composition n
{M : Type u_1} (S : set M) [add_semigroup M] : add_subsemigroup M
{R : Type u} [comm_ring R] [nontrivial R] : invariant_basis_number R
{C : Type u} [category_theory.category C] [category_theory.limits.has_wide_pullbacks C] {B : C} : category_theory.limits.has_products (category_theory.over B)
 : Type
{α : Type u} (l : list α) : dlist α
{R : Type u_1} [has_zero R] [has_one R] [has_add R] [has_neg R] {n : ℕ} : zmod n → R
{G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)
{R₂ : Type u_5} [comm_semiring R₂] {n : Type u_11} [fintype n] (M : matrix n n R₂) : bilin_form R₂ (n → R₂)
{α : Sort u_1} {p : α → Prop} (x : subtype p) : α
(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : ¬is_unit (minpoly A x)
{α : Type u_1} [preorder α] {a b : α} (h : b < a) : ¬is_min a
{α : Type u_1} [has_zero α] [has_one α] [has_add α] (n : ℕ) : α
{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : b ≤ a → 0 ≤ a - b
{α : Type u_2} [comm_semigroup α] : comm_semigroup (set α)
{γ : Type u_1} [U : uniform_space γ] (m : emetric_space γ) (H : uniformity γ = uniformity γ) : emetric_space γ
(α : Type u) : Type u
(out : out_param (Type u → Type v)) (m : Type u → Type v) : Type (max (u+1) v)
{C : Type u₁} [category_theory.category C] {J : category_theory.grothendieck_topology C} (X Y : category_theory.SheafOfTypes J) : Type (max u_1 u₁)
{α : Type u_1} {β : Type u_2} [omega_complete_partial_order α] [omega_complete_partial_order β] (c : omega_complete_partial_order.chain (α × β)) : α × β
{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a ≤ b → multiset.Icc a b = 0
{α : Type u_1} : list α → list (list α)
(o : ordinal) : pgame
(F A : Class) : Class
(α : Type u_7) [measurable_space α] : Prop
{M : Type u_1} (R : Type u_3) [decidable_eq M] [comm_semiring R] (m : M) : submodule R (add_monoid_algebra R M)
(p : nat.primes) : ↑p.factor_multiset = prime_multiset.of_prime p
{α : Type u} {β : Type v} {γ : Type u_1} (c : γ) : α ⊕ β ⊕ γ
 : Type
(γ : Type) : Type
{α : Type u} : wseq α → wseq α
{S : Type u_2} [comm_ring S] {K : Type u_6} [field K] [algebra K S] (pb : power_basis K S) : finite_dimensional K S
(op : ordinal → ordinal → ordinal) (o : ordinal) : ordinal
{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : b < c - a → a + b < c
{α : Type u} (r : α → α → Prop) [is_strict_order α r] : partial_order α
{α : Type u_1} [denumerable α] : denumerable (option α)
{n : ℕ} : has_well_founded (fin n)
 : Type (u+1)
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J → C) : Type (max u v)
{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ < b ↔ b⁻¹ < a
{M : Type u_1} [monoid M] (s : set M) : set M
{G : Type u_1} [group G] (s : set G) : subgroup G
{α : Type u} [decidable_eq α] : free_group α → list (α × bool)
{A : Type v} [ring A] {R : Type u} [comm_ring R] [algebra R A] : lie_algebra R A
(A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] (z : K) : K
(α : Type u_2) [has_le α] [bounded_order α] : Prop
{α : Type v} {d u n : ℕ} (A : matrix (fin (u + d)) (fin n) α) : matrix (fin u) (fin n) α
(α : Type u_2) : Type u_2
{R : Type u_1} [mul_zero_class R] : ¬is_left_regular 0 ↔ nontrivial R
 : Type
{F : Type u} [decidable_eq F] [field F] (s : finset F) (f : F → F) : polynomial F
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] (f : measure_theory.simple_func α β) (g : β → measure_theory.simple_func α γ) : measure_theory.simple_func α γ
(ι : Type u_4) (B : Type u_5) [topological_space B] (F : Type u_6) [topological_space F] : Type (max u_4 u_5 u_6)
{G : Type u_10} [group G] (a : G) : equiv.perm G
 : has_mod ordinal
{M : Type u_4} [mul_one_class M] (self : submonoid M) : subsemigroup M
{α : Sort u_1} (P : Prop) [decidable P] (x : ¬P → α) (y : ¬¬P → α) : dite (¬P) x y = dite P (λ (h : P), y _) x
{α : Type u_1} {β : Type u_2} [normed_ring α] [normed_ring β] : normed_ring (α × β)
{α : Type u} [lattice α] [comm_group α] : has_neg_part α
{X : Type u_1} [topological_space X] {Y : Type u_2} [topological_space Y] {f : Y → X} (cont : continuous f) (A : discrete_quotient Y) (B : discrete_quotient X) : Prop
(R' : Type u) (S' : Type v) (T' : Type w) [comm_semiring R'] [comm_semiring S'] [comm_semiring T'] [algebra R' S'] [algebra S' T'] : algebra (polynomial R') (S' → T')
{C : Type u} [category_theory.category C] : has_le (category_theory.grothendieck_topology C)
(C : Type u) [category_theory.category C] : Prop
 : Type
(α : Type u_4) : Type u_4
 : Type
(P : Type u_2) [has_le P] : Type u_2
(n : ℕ) : mv_polynomial ℕ ℤ
{α : Type u_1} (l : list α) : array l.length α
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Type v
{α : Type u_1} [decidable_eq α] [monoid α] {s : finset α} : decidable (mul_salem_spencer ↑s)
(S : Type u_4) (M : out_param (Type u_5)) [has_mul M] [set_like S M] : Type
(p : ℕ) [hp : fact (nat.prime p)] : ℕ → mv_polynomial (fin 1 × ℕ) ℤ
(α : Type u_1) [complete_lattice α] : well_founded gt → complete_lattice.is_sup_closed_compact α
{G : Type u_1} [group G] (H K : subgroup G) : Prop
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (h : 0 < finite_dimensional.finrank K V) : nontrivial V
(α : Type u_1) [nonempty_fin_lin_ord α] : NonemptyFinLinOrd
{R : Type u_1} [comm_ring R] (M : submonoid R) (S : Type u_2) [comm_ring S] [algebra R S] : submonoid S
{R : Type u} [semiring R] (p : polynomial R) : ℕ
(α : Type u) : Type u
{α : Sort u_1} (P : Prop) [decidable P] (a b : α) : ite (¬P) a b = ite P b a
{C : Type u₁} [category_theory.category C] {X : C} : inhabited (category_theory.sieve X)
{α : Type u_1} {r : α → α → Prop} {s : set α} (h : is_chain r s) : is_chain (flip r) s
(α : Type u_3) [omega_complete_partial_order α] : Type u_3
{X : Type u_1} [topological_space X] {A : set X} (h : is_clopen A) : discrete_quotient X
{ι : Type u_1} {R : Type u_3} (M : Type u_5) [semiring R] [add_comm_monoid M] [module R M] [subsingleton M] [is_empty ι] : basis ι R M
(α : Type u_1) [linear_ordered_ring α] [archimedean α] : floor_ring α
(S : Type u_3) (G : Type u_4) [div_inv_monoid G] [set_like S G] : Type
{α : Sort u_1} {β : Sort u_2} (f : α → β) {p : β → Prop} (h : ∀ (a : α), p (f a)) : α → subtype p
{𝕜 : Type u_5} [normed_field 𝕜] {𝕜' : Type u_1} [normed_ring 𝕜'] [normed_algebra 𝕜 𝕜'] : normed_space 𝕜 𝕜'
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] : function.injective coe
{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : b⁻¹ * a < c → a < b * c
(α : Type u) : Type u
(α : Type u_6) (β : Type u_7) [topological_space α] [preorder α] [topological_space β] [preorder β] : Type (max u_6 u_7)
{K : Type u} [field K] (s : subfield K) (m : multiset K) : (∀ (a : K), a ∈ m → a ∈ s) → m.sum ∈ s
{R : Type u} [comm_ring R] (f : polynomial R) : Type u
{α : Type u_1} (f : filter α) : filter_basis α
(α : Type u_1) [preorder α] : topological_space α
(n : num) : Prop
 : pSet → Set
(α : Type u) : Type u
{M : Type u_1} [add_zero_class M] : has_coe (add_con M) (add_submonoid (M × M))
{α : Type u_1} [preorder α] [locally_finite_order α] (a b : α) : finset α
 : num → pos_num
{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : a < 1) (hb : b ≤ 1) (b0 : 0 < b) : a * b < 1
{α : Type u_1} {P : α → Prop} [encA : encodable α] [decP : decidable_pred P] (v : ℕ) : option {a // P a}
{C : Type u} [category_theory.groupoid C] (X : C) : group (category_theory.End X)
{α : Type u_1} [has_one α] [has_zero α] [has_lt α] : has_coe (continued_fraction α) (simple_continued_fraction α)
{n : ℕ} [fact (0 < n)] (i : zmod n) : order_of (dihedral_group.r i) = n / n.gcd i.val
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) : Type (max u v)
{g : Type} [random_gen g] : rand_g g ℕ
{α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : (a * d - b * c) / (c * d) < 0 → a / c < b / d
(R : Type u_1) [has_zero R] : Type u_1
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_coproducts C] : category_theory.limits.has_binary_biproducts C
{P : ℕ → Sort u_1} (h : Π (n : ℕ), P (n + 1) → P n) {m n : ℕ} (mn : m ≤ n) (hP : P n) : P m
(R : Type u_1) [monoid_with_zero R] : mul_action_with_zero R R
(G : Type u_2) : Type u_2
(α : Type u) : Type u
{α : Type u_1} [has_le α] (s : lower_set α) : upper_set α
{R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : p ∣ ring_char R ↔ p ∣ fintype.card R
{𝕜 : Type u_1} [linear_ordered_field 𝕜] {R : Type u_2} [comm_ring R] (abv : R → 𝕜) [is_absolute_value abv] : uniform_space R
(α : Type u_1) (β : Type u_2) [topological_space α] [topological_space β] : Prop
(α : Type u_1) : Type u_1
(n : ℕ) : Type
(𝕜 : Type u_1) (E : Type u_2) [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] : has_inf (geometry.simplicial_complex 𝕜 E)
{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R x y → same_ray R (-x) (-y)
(M : Type u) [monoid M] {F : Type v} [field F] [mul_semiring_action M F] (S : subfield F) : Prop
{α : Type u_1} {γ : α → Type u_3} [encodable α] [Π (a : α), encodable (γ a)] : sigma γ → ℕ
{α : Type u_1} [decidable_eq α] (s : finset α) : has_bot (finpartition s)
{𝕜 : Type u_1} {V : Type u_2} [normed_field 𝕜] [add_comm_group V] [module 𝕜 V] : has_top (enorm 𝕜 V)
{α : Type u_1} (s : multiset (multiset α)) : multiset (multiset α)
{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : 0 ≤ -a ↔ a ≤ 0
{α : Type u} {β : Type v} (m : α → β) (f : filter β) : filter α
{α : Type u_1} {β : Type u_2} [has_add α] [add_comm_group β] {f : α → β} (hf : is_add_hom f) : is_add_hom (λ (a : α), -f a)
(G : Type u) [group G] : Type u
{α : Type u_1} [encodable α] (s : multiset α) : ℕ
{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] (p q : polynomial K) : ratfunc K
{α : Type u_1} [partial_order α] [pred_order α] {a b : α} [no_min_order α] : a ≠ b → order.pred a ≠ order.pred b
{X : Type u_1} [topological_space X] [t0_space X] : t0_space (alexandroff X)
{β : Type w} {C : Type u} [category_theory.category C] (f : β → C) [category_theory.limits.has_coproduct f] : C
{α : Type u} (r s : α → α → Prop) [is_nonstrict_strict_order α r s] {a b : α} : s a b ↔ r a b ∧ ¬r b a
 : Type
{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a + b < c → b < c - a
{R : Type u} [comm_ring R] : compact_space (prime_spectrum R)
{R : Type u} [ring R] (s : subring R) {x y : R} : x ∈ s → y ∈ s → x + y ∈ s
{L R : Type v} (fst snd : R → L) : Type v
(G : Type u) : Type u
{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : -a ≤ b → -b ≤ a
{α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v : α) (s : finset α) : finset α
(G : Type u_1) [add_monoid G] : Prop
(α : Type u_8) (β : Type u_9) [complete_lattice α] [complete_lattice β] : Type (max u_8 u_9)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] (X : C) [category_theory.simple X] : category_theory.indecomposable X
{α : Type} (cmd : rand α) : io α
{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) : list X
(x y z : ℤ) : Prop
{R : Type u_1} [add_right_cancel_semigroup R] (g : R) : is_add_right_regular g
{α : Type u} (c : computation (computation α)) : computation α
{α : Type u_1} {β : Type u_2} [bornology β] (f : α → β) : bornology α
{α : Type u} [lattice α] [add_comm_group α] : has_pos_part α
{β : Type u_2} [topological_space β] {κ : Type u_5} {f : κ → β} (hf : dense_range f) (b : β) : κ
{α : Type u_1} {m : multiset α} {β : α → Type u_2} [h : Π (a : α), decidable_eq (β a)] : decidable_eq (Π (a : α), a ∈ m → β a)
{α β γ : Type} (p : α → β × γ) [decidable_eq β] (b' : β) : list α → list γ × list α
{α : Type u_1} {β : Type u_2} (r : α → α → Prop) (f : filter β) (u : β → α) : Prop
{α : Type u_1} [linear_ordered_field α] {a b c : α} (hb : 0 ≤ b) (hc : 0 ≤ c) (h : a ≤ c * b) : a / b ≤ c
(α : Type u_2) [fintype α] [nonempty α] [lattice α] : complete_lattice α
{α : Type u_1} {ι : Type u_2} {κ : Type u_3} (C : (ι → option α) → κ) : Type (max u_1 u_2 u_3)
{n : ℕ} (m : ℕ) (i : fin (n + m)) (h : m ≤ ↑i) : fin n
(K : Type u) [field K] : valuation_ring K
(α : Type u_1) : Type u_1
{P : Type u_1} [semilattice_sup P] [is_directed P ge] : has_sup (order.ideal P)
{α : Type u_1} [linear_ordered_field α] {m n : ℕ} : ↑(m / n) ≤ ↑m / ↑n
{τ : Type u_1} [add_comm_group τ] [topological_space τ] [topological_add_group τ] {α : Type u_2} [topological_space α] (ϕ : flow τ α) : flow τ α
{α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop
{α : Type u_1} (p : α → Prop) [decidable_pred p] (l : finset α) (hp : ∃! (a : α), a ∈ l ∧ p a) : α
(R : Type u_1) [comm_ring R] : Prop
(P : pfunctor) : Type u_1
(R : Type u) (A : Type v) [comm_semiring R] [semiring A] [algebra R A] : subalgebra R A
(p : ℕ) : decidable (nat.prime p)
{R : Type u} [semiring R] (f : polynomial R) (n : ℕ) : polynomial R
{F : Type u_1} [field F] (p : polynomial F) : Type u_1
{G : Type u_1} [add_group G] : complete_lattice (add_subgroup G)
{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → finset.Ico a b = ∅
(S : Type u_1) (K : out_param (Type u_2)) [field K] [set_like S K] : Type
 : cardinal
