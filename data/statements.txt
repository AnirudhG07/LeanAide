theorem cont_mdiff_iff {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M → M'} {n : with_top ℕ} : cont_mdiff I I' n f ↔ continuous f ∧ ∀ (x : M) (y : M'), cont_diff_on 𝕜 n (⇑(ext_chart_at I' y) ∘ f ∘ ⇑((ext_chart_at I x).symm)) ((ext_chart_at I x).target ∩ ⇑((ext_chart_at I x).symm) ⁻¹' (f ⁻¹' (ext_chart_at I' y).source))
theorem nndist_triangle {α : Type u} [pseudo_metric_space α] (x y z : α) : has_nndist.nndist x z ≤ has_nndist.nndist x y + has_nndist.nndist y z
theorem is_noetherian.iff_dim_lt_aleph_0 {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V ↔ module.rank K V < cardinal.aleph_0
theorem finset.sum_card_inter_le {α : Type u_2} [decidable_eq α] {s : finset α} {B : finset (finset α)} {n : ℕ} (h : ∀ (a : α), a ∈ s → (finset.filter (has_mem.mem a) B).card ≤ n) : B.sum (λ (t : finset α), (s ∩ t).card) ≤ s.card * n
theorem basis.ext_multilinear_fin {R : Type u_1} {n : ℕ} {M : fin n → Type u_3} {M₂ : Type u_4} [comm_semiring R] [add_comm_monoid M₂] [Π (i : fin n), add_comm_monoid (M i)] [Π (i : fin n), module R (M i)] [module R M₂] {f g : multilinear_map R M M₂} {ι₁ : fin n → Type u_2} (e : Π (i : fin n), basis (ι₁ i) R (M i)) (h : ∀ (v : Π (i : fin n), ι₁ i), ⇑f (λ (i : fin n), ⇑(e i) (v i)) = ⇑g (λ (i : fin n), ⇑(e i) (v i))) : f = g
theorem tangent_bundle_proj_open {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) (M : Type u_4) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] : is_open_map (tangent_bundle.proj I M)
theorem Top.presheaf.section_ext {C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X : Top} [category_theory.concrete_category C] [category_theory.limits.preserves_filtered_colimits (category_theory.forget C)] [category_theory.limits.has_limits C] [category_theory.limits.preserves_limits (category_theory.forget C)] [category_theory.reflects_isomorphisms (category_theory.forget C)] (F : Top.sheaf C X) (U : topological_space.opens ↥X) (s t : ↥(F.val.obj (opposite.op U))) (h : ∀ (x : ↥U), ⇑(F.val.germ x) s = ⇑(F.val.germ x) t) : s = t
theorem list.sum_drop_succ {G : Type u_7} [add_group G] (L : list G) (i : ℕ) (p : i < L.length) : (list.drop (i + 1) L).sum = -L.nth_le i p + (list.drop i L).sum
theorem sub_lt_zero {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a - b < 0 ↔ a < b
theorem balanced.smul_mono {𝕜 : Type u_1} {𝕝 : Type u_2} {E : Type u_3} [normed_field 𝕜] [normed_ring 𝕝] [normed_space 𝕜 𝕝] [add_comm_group E] [module 𝕜 E] [smul_with_zero 𝕝 E] [is_scalar_tower 𝕜 𝕝 E] {s : set E} (hs : balanced 𝕝 s) {a : 𝕝} {b : 𝕜} (h : ∥a∥ ≤ ∥b∥) : a • s ⊆ b • s
theorem category_theory.right_lifting_property_initial_iff {C : Type u} [category_theory.category C] (i p : category_theory.arrow C) (h : category_theory.limits.is_initial i.left) : category_theory.has_lifting_property i p ↔ ∀ {e : i.right ⟶ p.right}, ∃ (l : i.right ⟶ p.left), l ≫ p.hom = e
theorem zero_lt.preorder.left.mul_le_one_of_le_of_le' {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (a0 : 0 < a) : a * b ≤ 1
theorem polynomial.X_pow_sub_one_dvd_prod_cyclotomic (R : Type u_1) [comm_ring R] {n m : ℕ} (hpos : 0 < n) (hm : m ∣ n) (hdiff : m ≠ n) : polynomial.X ^ m - 1 ∣ n.proper_divisors.prod (λ (i : ℕ), polynomial.cyclotomic i R)
theorem mul_equiv.apply_symm_apply {M : Type u_6} {N : Type u_7} [has_mul M] [has_mul N] (e : M ≃* N) (y : N) : ⇑e (⇑(e.symm) y) = y
theorem witt_vector.verschiebung_fun_is_poly (p : ℕ) : witt_vector.is_poly p (λ (R : Type u_1) (_Rcr : comm_ring R), witt_vector.verschiebung_fun)
theorem cont_diff.continuous_linear_map_comp {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {n : with_top ℕ} {f : E → F} (g : F →L[𝕜] G) (hf : cont_diff 𝕜 n f) : cont_diff 𝕜 n (λ (x : E), ⇑g (f x))
theorem add_units.is_add_regular {R : Type u_1} [add_monoid R] (a : add_units R) : is_add_regular ↑a
theorem quasi_sober_of_open_cover {α : Type u_1} [topological_space α] (S : set (set α)) (hS : ∀ (s : ↥S), is_open ↑s) [hS' : ∀ (s : ↥S), quasi_sober ↥s] (hS'' : ⋃₀S = ⊤) : quasi_sober α
theorem matrix.is_diag_of_subsingleton {α : Type u_1} {n : Type u_4} [has_zero α] [subsingleton n] (A : matrix n n α) : A.is_diag
theorem metric.tendsto_locally_uniformly_iff {α : Type u} {β : Type v} [pseudo_metric_space α] {ι : Type u_1} [topological_space β] {F : ι → β → α} {f : β → α} {p : filter ι} : tendsto_locally_uniformly F f p ↔ ∀ (ε : ℝ), ε > 0 → ∀ (x : β), ∃ (t : set β) (H : t ∈ nhds x), ∀ᶠ (n : ι) in p, ∀ (y : β), y ∈ t → has_dist.dist (f y) (F n y) < ε
theorem interval_integral.deriv_within_integral_of_tendsto_ae_right {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {c : E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set ℝ} [interval_integral.FTC_filter b (nhds_within b s) (nhds_within b t)] (hmeas : strongly_measurable_at_filter f (nhds_within b t) measure_theory.measure_space.volume) (hb : filter.tendsto f (nhds_within b t ⊓ measure_theory.measure_space.volume.ae) (nhds c)) (hs : unique_diff_within_at ℝ s b . "unique_diff_within_at_Ici_Iic_univ") : deriv_within (λ (u : ℝ), ∫ (x : ℝ) in a..u, f x) s b = c
theorem category_theory.sieve.id_mem_iff_eq_top {C : Type u₁} [category_theory.category C] {X : C} {S : category_theory.sieve X} : ⇑S (𝟙 X) ↔ S = ⊤
theorem euclidean_geometry.dist_sq_eq_dist_sq_add_dist_sq_iff_angle_eq_pi_div_two {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (p1 p2 p3 : P) : has_dist.dist p1 p3 * has_dist.dist p1 p3 = has_dist.dist p1 p2 * has_dist.dist p1 p2 + has_dist.dist p3 p2 * has_dist.dist p3 p2 ↔ euclidean_geometry.angle p1 p2 p3 = real.pi / 2
theorem linear_map.bot_lt_ker_of_det_eq_zero {M : Type u_2} [add_comm_group M] {𝕜 : Type u_1} [field 𝕜] [module 𝕜 M] {f : M →ₗ[𝕜] M} (hf : ⇑linear_map.det f = 0) : ⊥ < f.ker
theorem matrix.dot_product_mul_vec {m : Type u_2} {n : Type u_3} {R : Type u_7} [fintype n] [fintype m] [non_unital_semiring R] (v : m → R) (A : matrix m n R) (w : n → R) : matrix.dot_product v (A.mul_vec w) = matrix.dot_product (matrix.vec_mul v A) w
theorem category_theory.abelian_of_adjunction.has_kernels {C : Type u₁} [category_theory.category C] [category_theory.preadditive C] {D : Type u₂} [category_theory.category D] [category_theory.abelian D] (F : C ⥤ D) (G : D ⥤ C) [G.preserves_zero_morphisms] (i : F ⋙ G ≅ 𝟭 C) [category_theory.limits.preserves_finite_limits G] : category_theory.limits.has_kernels C
theorem measure_theory.Lp.ae_eq_of_forall_set_integral_eq' {α : Type u_1} {E' : Type u_5} {𝕜 : Type u_11} {p : ennreal} [is_R_or_C 𝕜] [inner_product_space 𝕜 E'] [complete_space E'] [normed_space ℝ E'] {m m0 : measurable_space α} {μ : measure_theory.measure α} (hm : m ≤ m0) (f g : ↥(measure_theory.Lp E' p μ)) (hp_ne_zero : p ≠ 0) (hp_ne_top : p ≠ ⊤) (hf_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑f s μ) (hg_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑g s μ) (hfg : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, ⇑f x ∂μ = ∫ (x : α) in s, ⇑g x ∂μ) (hf_meas : measure_theory.ae_strongly_measurable' m ⇑f μ) (hg_meas : measure_theory.ae_strongly_measurable' m ⇑g μ) : ⇑f =ᵐ[μ] ⇑g
theorem simple_graph.adj_iff_exists_edge {V : Type u} (G : simple_graph V) {v w : V} : G.adj v w ↔ v ≠ w ∧ ∃ (e : sym2 V) (H : e ∈ G.edge_set), v ∈ e ∧ w ∈ e
theorem set.nonempty.convex_hull {𝕜 : Type u_1} {E : Type u_2} [ordered_semiring 𝕜] [add_comm_monoid E] [module 𝕜 E] {s : set E} : s.nonempty → (⇑(convex_hull 𝕜) s).nonempty
theorem exists_prime_add_order_of_dvd_card {G : Type u_1} [add_group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G) : ∃ (x : G), add_order_of x = p
theorem has_ssubset.ssubset.trans_subset {α : Type u} [has_subset α] [has_ssubset α] [is_nonstrict_strict_order α has_subset.subset has_ssubset.ssubset] {a b c : α} [is_trans α has_subset.subset] (h₁ : a ⊂ b) (h₂ : b ⊆ c) : a ⊂ c
theorem interval_integral.continuous_of_dominated_interval {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {μ : measure_theory.measure ℝ} {X : Type u_5} [topological_space X] [topological_space.first_countable_topology X] {F : X → ℝ → E} {bound : ℝ → ℝ} {a b : ℝ} (hF_meas : ∀ (x : X), measure_theory.ae_strongly_measurable (F x) (μ.restrict (set.interval_oc a b))) (h_bound : ∀ (x : X), ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → ∥F x t∥ ≤ bound t) (bound_integrable : interval_integrable bound μ a b) (h_cont : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → continuous (λ (x : X), F x t)) : continuous (λ (x : X), ∫ (t : ℝ) in a..b, F x t ∂μ)
theorem ring_hom.ker_lift_injective {R : Type u} {S : Type v} [comm_ring R] [comm_ring S] (f : R →+* S) : function.injective ⇑(f.ker_lift)
theorem finset.sum_range_sub {G : Type u_1} [add_comm_group G] (f : ℕ → G) (n : ℕ) : (finset.range n).sum (λ (i : ℕ), f (i + 1) - f i) = f n - f 0
theorem submodule.span_algebra_map_image {R : Type u} {S : Type v} [comm_semiring R] [semiring S] [algebra R S] (a : set R) : submodule.span R (⇑(algebra_map R S) '' a) = submodule.map (algebra.linear_map R S) (submodule.span R a)
theorem linear_map.det_aux_def {M : Type u_2} [add_comm_group M] {ι : Type u_4} [decidable_eq ι] [fintype ι] {A : Type u_5} [comm_ring A] [module A M] (b : basis ι A M) (f : M →ₗ[A] M) : ⇑(linear_map.det_aux (trunc.mk b)) f = (⇑(linear_map.to_matrix b b) f).det
theorem list.sublist_iff_exists_order_embedding_nth_eq {α : Type u_1} {l l' : list α} : l <+ l' ↔ ∃ (f : ℕ ↪o ℕ), ∀ (ix : ℕ), l.nth ix = l'.nth (⇑f ix)
theorem measure_theory.add_haar_image_eq_zero_of_det_fderiv_within_eq_zero {E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {s : set E} {f : E → E} {f' : E → (E →L[ℝ] E)} [measurable_space E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (hf' : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (h'f' : ∀ (x : E), x ∈ s → (f' x).det = 0) : ⇑μ (f '' s) = 0
theorem category_theory.has_right_lifting_property_comp {C : Type u} [category_theory.category C] {X Y Z : C} {i : category_theory.arrow C} {f : X ⟶ Y} {g : Y ⟶ Z} (hf : category_theory.has_lifting_property i (category_theory.arrow.mk f)) (hg : category_theory.has_lifting_property i (category_theory.arrow.mk g)) : category_theory.has_lifting_property i (category_theory.arrow.mk (f ≫ g))
theorem has_lt.lt.of_dual {α : Type u_1} [has_lt α] {a b : αᵒᵈ} : b < a → ⇑order_dual.of_dual a < ⇑order_dual.of_dual b
theorem local_homeomorph.eq_on_source.target_eq {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {e e' : local_homeomorph α β} (h : e ≈ e') : e.to_local_equiv.target = e'.to_local_equiv.target
theorem inner_product_space.is_self_adjoint.conj_eigenvalue_eq_self {𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] {T : E →ₗ[𝕜] E} (hT : inner_product_space.is_self_adjoint T) {μ : 𝕜} (hμ : module.End.has_eigenvalue T μ) : ⇑(star_ring_end 𝕜) μ = μ
theorem countable_cover_nhds_within_of_sigma_compact {α : Type u} [topological_space α] [sigma_compact_space α] {f : α → set α} {s : set α} (hs : is_closed s) (hf : ∀ (x : α), x ∈ s → f x ∈ nhds_within x s) : ∃ (t : set α) (H : t ⊆ s), t.countable ∧ s ⊆ ⋃ (x : α) (H : x ∈ t), f x
theorem phragmen_lindelof.eq_on_horizontal_strip {E : Type u_1} [normed_group E] [normed_space ℂ E] {a b : ℝ} {f g : ℂ → E} (hdf : diff_cont_on_cl ℂ f (complex.im ⁻¹' set.Ioo a b)) (hBf : ∃ (c : ℝ) (H : c < real.pi / (b - a)) (B : ℝ), f =O[filter.comap (has_abs.abs ∘ complex.re) filter.at_top ⊓ filter.principal (complex.im ⁻¹' set.Ioo a b)] λ (z : ℂ), real.exp (B * real.exp (c * |z.re|))) (hdg : diff_cont_on_cl ℂ g (complex.im ⁻¹' set.Ioo a b)) (hBg : ∃ (c : ℝ) (H : c < real.pi / (b - a)) (B : ℝ), g =O[filter.comap (has_abs.abs ∘ complex.re) filter.at_top ⊓ filter.principal (complex.im ⁻¹' set.Ioo a b)] λ (z : ℂ), real.exp (B * real.exp (c * |z.re|))) (ha : ∀ (z : ℂ), z.im = a → f z = g z) (hb : ∀ (z : ℂ), z.im = b → f z = g z) : set.eq_on f g (complex.im ⁻¹' set.Icc a b)
theorem sum_hom_units {R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G →* R) [decidable (f = 1)] : finset.univ.sum (λ (g : G), ⇑f g) = ite (f = 1) ↑(fintype.card G) 0
theorem category_theory.limits.ι_colimit_limit_to_limit_colimit_π {J K : Type v} [category_theory.small_category J] [category_theory.small_category K] {C : Type u} [category_theory.category C] (F : J × K ⥤ C) [category_theory.limits.has_limits_of_shape J C] [category_theory.limits.has_colimits_of_shape K C] (j : J) (k : K) : category_theory.limits.colimit.ι (category_theory.curry.obj (category_theory.prod.swap K J ⋙ F) ⋙ category_theory.limits.lim) k ≫ category_theory.limits.colimit_limit_to_limit_colimit F ≫ category_theory.limits.limit.π (category_theory.curry.obj F ⋙ category_theory.limits.colim) j = category_theory.limits.limit.π ((category_theory.curry.obj (category_theory.prod.swap K J ⋙ F)).obj k) j ≫ category_theory.limits.colimit.ι ((category_theory.curry.obj F).obj j) k
theorem integral_exp_neg_le {b : ℝ} (a X : ℝ) (h2 : 0 < b) : ∫ (x : ℝ) in a..X, real.exp (-b * x) ≤ real.exp (-b * a) / b
theorem lift_of_splits {F : Type u_1} {K : Type u_2} {L : Type u_3} [field F] [field K] [field L] [algebra F K] [algebra F L] (s : finset K) : (∀ (x : K), x ∈ s → is_integral F x ∧ polynomial.splits (algebra_map F L) (minpoly F x)) → nonempty (↥(algebra.adjoin F ↑s) →ₐ[F] L)
theorem set.pairwise.subtype {α : Type u_1} (s : set α) (r : α → α → Prop) : s.pairwise r → pairwise (λ (x y : ↥s), r ↑x ↑y)
theorem lt_add_of_sub_right_lt {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a - c < b → a < b + c
theorem finprod_mem_mul_diff' {α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M} {s t : set α} (hst : s ⊆ t) (ht : (t ∩ function.mul_support f).finite) : finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ t  s), f i)) = finprod (λ (i : α), finprod (λ (H : i ∈ t), f i))
theorem dual_number.snd_mul {R : Type u_1} [semiring R] (x y : dual_number R) : (x * y).snd = triv_sq_zero_ext.fst x * triv_sq_zero_ext.snd y + triv_sq_zero_ext.fst y * triv_sq_zero_ext.snd x
theorem mem_nhds_within_Ioi_iff_exists_Ioo_subset' {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a u' : α} {s : set α} (hu' : a < u') : s ∈ nhds_within a (set.Ioi a) ↔ ∃ (u : α) (H : u ∈ set.Ioi a), set.Ioo a u ⊆ s
theorem filter.frequently_high_scores {β : Type u_4} [linear_order β] [no_max_order β] {u : ℕ → β} (hu : filter.tendsto u filter.at_top filter.at_top) : ∃ᶠ (n : ℕ) in filter.at_top, ∀ (k : ℕ), k < n → u k < u n
theorem linear_ordered_comm_group_with_zero.nhds_zero_of_units {Γ₀ : Type u_1} [linear_ordered_comm_group_with_zero Γ₀] (γ : Γ₀ˣ) : {x : Γ₀ | x < ↑γ} ∈ nhds 0
theorem nnreal.exists_le_has_sum_of_le {β : Type u_2} {f g : β → nnreal} {r : nnreal} (hgf : ∀ (b : β), g b ≤ f b) (hfr : has_sum f r) : ∃ (p : nnreal) (H : p ≤ r), has_sum g p
theorem turing.to_partrec.step_normal_then (c : turing.to_partrec.code) (k k' : turing.to_partrec.cont) (v : list ℕ) : turing.to_partrec.step_normal c (k.then k') v = (turing.to_partrec.step_normal c k v).then k'
theorem category_theory.monad.forget_creates_colimits_of_monad_preserves {C : Type u₁} [category_theory.category C] {T : category_theory.monad C} {J : Type u} [category_theory.category J] [category_theory.limits.preserves_colimits_of_shape J ↑T] (D : J ⥤ T.algebra) [category_theory.limits.has_colimit (D ⋙ T.forget)] : category_theory.limits.has_colimit D
theorem mem_Icc_of_mem_std_simplex {R : Type u_1} {ι : Type u_4} [linear_ordered_field R] [fintype ι] {f : ι → R} (hf : f ∈ std_simplex R ι) (x : ι) : f x ∈ set.Icc 0 1
theorem ring_hom_inv_pair.symm {R₁ : Type u_1} {R₂ : Type u_2} [semiring R₁] [semiring R₂] (σ₁₂ : R₁ →+* R₂) (σ₂₁ : R₂ →+* R₁) [ring_hom_inv_pair σ₁₂ σ₂₁] : ring_hom_inv_pair σ₂₁ σ₁₂
theorem category_theory.limits.eq_of_epi_equalizer {C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} [category_theory.limits.has_equalizer f g] [category_theory.epi (category_theory.limits.equalizer.ι f g)] : f = g
theorem metric.eball_top_eq_univ {α : Type u} [pseudo_metric_space α] (x : α) : emetric.ball x ⊤ = set.univ
theorem antivary.sum_smul_eq_sum_comp_perm_smul_iff {ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {σ : equiv.perm ι} {f : ι → α} {g : ι → β} [fintype ι] (hfg : antivary f g) : finset.univ.sum (λ (i : ι), f (⇑σ i) • g i) = finset.univ.sum (λ (i : ι), f i • g i) ↔ antivary (f ∘ ⇑σ) g
theorem pmf.to_outer_measure_mono {α : Type u_1} (p : pmf α) {s t : set α} (h : s ∩ p.support ⊆ t) : ⇑(p.to_outer_measure) s ≤ ⇑(p.to_outer_measure) t
theorem generalized_continued_fraction.zero_le_of_denom {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] : 0 ≤ (generalized_continued_fraction.of v).denominators n
theorem cont_diff.has_strict_deriv_at {n : with_top ℕ} {𝕂 : Type u_6} [is_R_or_C 𝕂] {F' : Type u_8} [normed_group F'] [normed_space 𝕂 F'] {f : 𝕂 → F'} {x : 𝕂} (hf : cont_diff 𝕂 n f) (hn : 1 ≤ n) : has_strict_deriv_at f (deriv f x) x
theorem liouville_with.mono {p q x : ℝ} (h : liouville_with p x) (hle : q ≤ p) : liouville_with q x
theorem mem_span_points (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) (s : set P) : p ∈ s → p ∈ span_points k s
theorem ring.direct_limit.of.zero_exact {ι : Type v} [preorder ι] {G : ι → Type w} [Π (i : ι), comm_ring (G i)] {f' : Π (i j : ι), i ≤ j → G i →+* G j} [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f' i j h))] [is_directed ι has_le.le] {i : ι} {x : G i} (hix : ⇑(ring.direct_limit.of G (λ (i j : ι) (h : i ≤ j), ⇑(f' i j h)) i) x = 0) : ∃ (j : ι) (hij : i ≤ j), ⇑(f' i j hij) x = 0
theorem nat.partrec.code.rec_computable {α : Type u_1} {σ : Type u_2} [primcodable α] [primcodable σ] {c : α → nat.partrec.code} (hc : computable c) {z : α → σ} (hz : computable z) {s : α → σ} (hs : computable s) {l : α → σ} (hl : computable l) {r : α → σ} (hr : computable r) {pr : α → nat.partrec.code × nat.partrec.code × σ × σ → σ} (hpr : computable₂ pr) {co : α → nat.partrec.code × nat.partrec.code × σ × σ → σ} (hco : computable₂ co) {pc : α → nat.partrec.code × nat.partrec.code × σ × σ → σ} (hpc : computable₂ pc) {rf : α → nat.partrec.code × σ → σ} (hrf : computable₂ rf) : let PR : α → nat.partrec.code → nat.partrec.code → σ → σ → σ := λ (a : α) (cf cg : nat.partrec.code) (hf hg : σ), pr a (cf, cg, hf, hg), CO : α → nat.partrec.code → nat.partrec.code → σ → σ → σ := λ (a : α) (cf cg : nat.partrec.code) (hf hg : σ), co a (cf, cg, hf, hg), PC : α → nat.partrec.code → nat.partrec.code → σ → σ → σ := λ (a : α) (cf cg : nat.partrec.code) (hf hg : σ), pc a (cf, cg, hf, hg), RF : α → nat.partrec.code → σ → σ := λ (a : α) (cf : nat.partrec.code) (hf : σ), rf a (cf, hf), F : α → nat.partrec.code → σ := λ (a : α) (c : nat.partrec.code), c.rec_on (z a) (s a) (l a) (r a) (PR a) (CO a) (PC a) (RF a) in computable (λ (a : α), F a (c a))
theorem inf_Sup_eq_supr_inf_sup_finset {α : Type u_1} [complete_lattice α] [is_compactly_generated α] {a : α} {s : set α} : a ⊓ has_Sup.Sup s = ⨆ (t : finset α) (H : ↑t ⊆ s), a ⊓ t.sup id
theorem category_theory.id_cover_lifting {C : Type u_1} [category_theory.category C] (J : category_theory.grothendieck_topology C) : category_theory.cover_lifting J J (𝟭 C)
theorem path.homotopic.proj_pi {ι : Type u_1} {X : ι → Type u_2} [Π (i : ι), topological_space (X i)] {as bs : Π (i : ι), X i} (i : ι) (paths : Π (i : ι), path.homotopic.quotient (as i) (bs i)) : path.homotopic.proj i (path.homotopic.pi paths) = paths i
theorem affine.triangle.orthocenter_eq_smul_vsub_vadd_circumcenter {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle ℝ P) : t.orthocenter = 3 • (finset.centroid ℝ finset.univ t.points -ᵥ affine.simplex.circumcenter t) +ᵥ affine.simplex.circumcenter t
theorem exists_lt_lt_of_not_covby {α : Type u_1} [has_lt α] {a b : α} (h : a < b) : ¬a ⋖ b → (∃ (c : α), a < c ∧ c < b)
theorem continuous.fst' {α : Type u} {β : Type v} {γ : Type u_1} [topological_space α] [topological_space β] [topological_space γ] {f : α → γ} (hf : continuous f) : continuous (λ (x : α × β), f x.fst)
theorem non_unital_ring_hom.comp_assoc {α : Type u_2} {β : Type u_3} {γ : Type u_4} [rα : non_unital_non_assoc_semiring α] [rβ : non_unital_non_assoc_semiring β] {rγ : non_unital_non_assoc_semiring γ} {δ : Type u_1} {rδ : non_unital_non_assoc_semiring δ} (f : α →ₙ+* β) (g : β →ₙ+* γ) (h : γ →ₙ+* δ) : (h.comp g).comp f = h.comp (g.comp f)
theorem linear_ordered_comm_group_with_zero.directed_lt (Γ₀ : Type u_1) [linear_ordered_comm_group_with_zero Γ₀] : directed ge (λ (γ₀ : Γ₀ˣ), filter.principal {γ : Γ₀ | γ < ↑γ₀})
theorem real.pi_lower_bound_start (n : ℕ) {a : ℝ} (h : real.sqrt_two_add_series (↑0 / ↑1) n ≤ 2 - (a / 2 ^ (n + 1)) ^ 2) : a < real.pi
theorem category_theory.idempotents.idem_of_id_sub_idem {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] {X : C} (p : X ⟶ X) (hp : p ≫ p = p) : (𝟙 X - p) ≫ (𝟙 X - p) = 𝟙 X - p
theorem finsum_mem_add_diff {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} {s t : set α} (hst : s ⊆ t) (ht : t.finite) : finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) + finsum (λ (i : α), finsum (λ (H : i ∈ t  s), f i)) = finsum (λ (i : α), finsum (λ (H : i ∈ t), f i))
theorem lower_adjoint.closed_eq_range_close {α : Type u_1} {β : Type u_4} [partial_order α] [partial_order β] {u : β → α} (l : lower_adjoint u) : l.closed = set.range (u ∘ ⇑l)
theorem measure_theory.finite_measure.tendsto_test_against_nn_of_le_const {α : Type u_1} [measurable_space α] [topological_space α] [opens_measurable_space α] {μ : measure_theory.finite_measure α} {fs : ℕ → bounded_continuous_function α nnreal} {c : nnreal} (fs_le_const : ∀ (n : ℕ) (a : α), ⇑(fs n) a ≤ c) {f : bounded_continuous_function α nnreal} (fs_lim : ∀ (a : α), filter.tendsto (λ (n : ℕ), ⇑(fs n) a) filter.at_top (nhds (⇑f a))) : filter.tendsto (λ (n : ℕ), μ.test_against_nn (fs n)) filter.at_top (nhds (μ.test_against_nn f))
theorem sylow.prime_pow_dvd_card_normalizer {G : Type u} [group G] [fintype G] {p n : ℕ} [hp : fact (nat.prime p)] (hdvd : p ^ (n + 1) ∣ fintype.card G) {H : subgroup G} (hH : fintype.card ↥H = p ^ n) : p ^ (n + 1) ∣ fintype.card ↥(H.normalizer)
theorem is_max_on.of_is_local_max_on_of_concave_on {E : Type u_1} {β : Type u_2} [add_comm_group E] [topological_space E] [module ℝ E] [topological_add_group E] [has_continuous_smul ℝ E] [ordered_add_comm_group β] [module ℝ β] [ordered_smul ℝ β] {s : set E} {f : E → β} {a : E} (a_in_s : a ∈ s) (h_localmax : is_local_max_on f s a) (h_conc : concave_on ℝ s f) : is_max_on f s a
theorem iterated_fderiv_succ_eq_comp_right {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {x : E} {n : ℕ} : iterated_fderiv 𝕜 (n + 1) f x = (⇑(continuous_multilinear_curry_right_equiv' 𝕜 n E F) ∘ iterated_fderiv 𝕜 n (λ (y : E), fderiv 𝕜 f y)) x
theorem finset.prod_sub_ordered {ι : Type u_1} {R : Type u_2} [comm_ring R] [linear_order ι] (s : finset ι) (f g : ι → R) : s.prod (λ (i : ι), f i - g i) = s.prod (λ (i : ι), f i) - s.sum (λ (i : ι), g i * (finset.filter (λ (_x : ι), _x < i) s).prod (λ (j : ι), f j - g j) * (finset.filter (λ (j : ι), i < j) s).prod (λ (j : ι), f j))
theorem interval_integral.measure_integral_sub_linear_is_o_of_tendsto_ae_of_le {ι : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a : ℝ} {c : E} {l l' : filter ℝ} {lt : filter ι} {μ : measure_theory.measure ℝ} {u v : ι → ℝ} [measure_theory.is_locally_finite_measure μ] [interval_integral.FTC_filter a l l'] (hfm : strongly_measurable_at_filter f l' μ) (hf : filter.tendsto f (l' ⊓ μ.ae) (nhds c)) (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) (huv : u ≤ᶠ[lt] v) : (λ (t : ι), ∫ (x : ℝ) in u t..v t, f x ∂μ - (⇑μ (set.Ioc (u t) (v t))).to_real • c) =o[lt] λ (t : ι), (⇑μ (set.Ioc (u t) (v t))).to_real
theorem zmod.legendre_sym_eq_zero_iff (p : ℕ) [fact (nat.prime p)] (a : ℤ) : zmod.legendre_sym p a = 0 ↔ ↑a = 0
theorem algebraic_topology.dold_kan.c_mk (i j : ℕ) (h : j + 1 = i) : algebraic_topology.dold_kan.c.rel i j
theorem pgame.zero_lf_le {x : pgame} : 0.lf x ↔ ∃ (i : x.left_moves), 0 ≤ x.move_left i
theorem contracting_with.fixed_point_is_fixed_pt {α : Type u_1} [metric_space α] {K : nnreal} {f : α → α} (hf : contracting_with K f) [nonempty α] [complete_space α] : function.is_fixed_pt f (contracting_with.fixed_point f hf)
theorem left.mul_lt_mul {α : Type u_1} [has_mul α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b c d : α} (h₁ : a < b) (h₂ : c < d) : a * c < b * d
theorem finprod_mul_distrib {α : Type u_1} {M : Type u_5} [comm_monoid M] {f g : α → M} (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) : finprod (λ (i : α), f i * g i) = finprod (λ (i : α), f i) * finprod (λ (i : α), g i)
theorem metric.Hausdorff_dist_nonneg {α : Type u} [pseudo_metric_space α] {s t : set α} : 0 ≤ metric.Hausdorff_dist s t
theorem subfield.list_sum_mem {K : Type u} [field K] (s : subfield K) {l : list K} : (∀ (x : K), x ∈ l → x ∈ s) → l.sum ∈ s
theorem inner_right_of_mem_orthogonal_singleton {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (u : E) {v : E} (hv : v ∈ (submodule.span 𝕜 {u})ᗮ) : has_inner.inner u v = 0
theorem is_regular_iff_ne_zero {R : Type u_1} {a : R} [cancel_monoid_with_zero R] [nontrivial R] : is_regular a ↔ a ≠ 0
theorem finsum_mem_insert' {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {a : α} {s : set α} (f : α → M) (h : a ∉ s) (hs : (s ∩ function.support f).finite) : finsum (λ (i : α), finsum (λ (H : i ∈ has_insert.insert a s), f i)) = f a + finsum (λ (i : α), finsum (λ (H : i ∈ s), f i))
theorem matrix.is_diag.diagonal_diag {α : Type u_1} {n : Type u_4} [has_zero α] [decidable_eq n] {A : matrix n n α} (h : A.is_diag) : matrix.diagonal A.diag = A
theorem is_nilpotent_of_product_of_sylow_group {G : Type u_1} [hG : group G] [hf : fintype G] (e : (Π (p : ↥((fintype.card G).factorization.support)) (P : sylow ↑p G), ↥↑P) ≃* G) : group.is_nilpotent G
theorem polynomial.irreducible_of_eisenstein_criterion {R : Type u_1} [comm_ring R] [is_domain R] {f : polynomial R} {P : ideal R} (hP : P.is_prime) (hfl : f.leading_coeff ∉ P) (hfP : ∀ (n : ℕ), ↑n < f.degree → f.coeff n ∈ P) (hfd0 : 0 < f.degree) (h0 : f.coeff 0 ∉ P ^ 2) (hu : f.is_primitive) : irreducible f
theorem witt_vector.iterate_verschiebung_mul_coeff {p : ℕ} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] [char_p R p] (x y : witt_vector p R) (i j : ℕ) : (⇑witt_vector.verschiebung^[i] x * ⇑witt_vector.verschiebung^[j] y).coeff (i + j) = x.coeff 0 ^ p ^ j * y.coeff 0 ^ p ^ i
theorem metric.inf_edist_ne_top {α : Type u} [pseudo_metric_space α] {s : set α} {x : α} (h : s.nonempty) : emetric.inf_edist x s ≠ ⊤
theorem orientation.two_zsmul_oangle_sub_eq_two_zsmul_oangle_sub_of_norm_eq {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x₁ x₂ y z : V} (hx₁yne : x₁ ≠ y) (hx₁zne : x₁ ≠ z) (hx₂yne : x₂ ≠ y) (hx₂zne : x₂ ≠ z) {r : ℝ} (hx₁ : ∥x₁∥ = r) (hx₂ : ∥x₂∥ = r) (hy : ∥y∥ = r) (hz : ∥z∥ = r) : 2 • o.oangle (y - x₁) (z - x₁) = 2 • o.oangle (y - x₂) (z - x₂)
theorem euclidean_geometry.right_dist_ne_zero_of_angle_eq_pi {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : euclidean_geometry.angle p1 p2 p3 = real.pi) : has_dist.dist p3 p2 ≠ 0
theorem linear_order.strict_concave_on_of_lt {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [ordered_add_comm_monoid β] [module 𝕜 E] [module 𝕜 β] [linear_order E] {s : set E} {f : E → β} (hs : convex 𝕜 s) (hf : ∀ ⦃x y : E⦄, x ∈ s → y ∈ s → x < y → ∀ ⦃a b : 𝕜⦄, 0 < a → 0 < b → a + b = 1 → a • f x + b • f y < f (a • x + b • y)) : strict_concave_on 𝕜 s f
theorem add_submonoid.dense_induction {M : Type u_1} [add_zero_class M] {p : M → Prop} (x : M) {s : set M} (hs : add_submonoid.closure s = ⊤) (Hs : ∀ (x : M), x ∈ s → p x) (H1 : p 0) (Hmul : ∀ (x y : M), p x → p y → p (x + y)) : p x
theorem inner_product_geometry.norm_add_eq_add_norm_iff_angle_eq_zero {V : Type u_1} [inner_product_space ℝ V] {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : ∥x + y∥ = ∥x∥ + ∥y∥ ↔ inner_product_geometry.angle x y = 0
theorem has_fderiv_at_integral_of_dominated_loc_of_lip' {α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {𝕜 : Type u_2} [is_R_or_C 𝕜] {E : Type u_3} [normed_group E] [normed_space ℝ E] [normed_space 𝕜 E] [complete_space E] {H : Type u_4} [normed_group H] [normed_space 𝕜 H] {F : H → α → E} {F' : α → (H →L[𝕜] E)} {x₀ : H} {bound : α → ℝ} {ε : ℝ} (ε_pos : 0 < ε) (hF_meas : ∀ (x : H), x ∈ metric.ball x₀ ε → measure_theory.ae_strongly_measurable (F x) μ) (hF_int : measure_theory.integrable (F x₀) μ) (hF'_meas : measure_theory.ae_strongly_measurable F' μ) (h_lipsch : ∀ᵐ (a : α) ∂μ, ∀ (x : H), x ∈ metric.ball x₀ ε → ∥F x a - F x₀ a∥ ≤ bound a * ∥x - x₀∥) (bound_integrable : measure_theory.integrable bound μ) (h_diff : ∀ᵐ (a : α) ∂μ, has_fderiv_at (λ (x : H), F x a) (F' a) x₀) : measure_theory.integrable F' μ ∧ has_fderiv_at (λ (x : H), ∫ (a : α), F x a ∂μ) (∫ (a : α), F' a ∂μ) x₀
theorem strict_convex_on_open_of_deriv2_pos {D : set ℝ} (hD : convex ℝ D) (hD₂ : is_open D) {f : ℝ → ℝ} (hf' : differentiable_on ℝ f D) (hf'' : ∀ (x : ℝ), x ∈ D → 0 < deriv^[2] f x) : strict_convex_on ℝ D f
theorem ennreal.coe_sub {r p : nnreal} : ↑(r - p) = ↑r - ↑p
theorem descending_central_series_ge_lower {G : Type u_1} [group G] (H : ℕ → subgroup G) (hH : is_descending_central_series H) (n : ℕ) : lower_central_series G n ≤ H n
theorem measure_theory.ae_eq_condexp_of_forall_set_integral_eq {α : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space ℝ F'] [complete_space F'] {m m0 : measurable_space α} {μ : measure_theory.measure α} (hm : m ≤ m0) [measure_theory.sigma_finite (μ.trim hm)] {f g : α → F'} (hf : measure_theory.integrable f μ) (hg_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on g s μ) (hg_eq : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, g x ∂μ = ∫ (x : α) in s, f x ∂μ) (hgm : measure_theory.ae_strongly_measurable' m g μ) : g =ᵐ[μ] measure_theory.condexp m μ f
theorem measure_theory.Lp.simple_func.induction {α : Type u_1} {E : Type u_4} [measurable_space α] [normed_group E] {p : ennreal} {μ : measure_theory.measure α} (hp_pos : p ≠ 0) (hp_ne_top : p ≠ ⊤) {P : ↥(measure_theory.Lp.simple_func E p μ) → Prop} (h_ind : ∀ (c : E) {s : set α} (hs : measurable_set s) (hμs : ⇑μ s < ⊤), P (measure_theory.Lp.simple_func.indicator_const p hs _ c)) (h_add : ∀ ⦃f g : measure_theory.simple_func α E⦄ (hf : measure_theory.mem_ℒp ⇑f p μ) (hg : measure_theory.mem_ℒp ⇑g p μ), disjoint (function.support ⇑f) (function.support ⇑g) → P (measure_theory.Lp.simple_func.to_Lp f hf) → P (measure_theory.Lp.simple_func.to_Lp g hg) → P (measure_theory.Lp.simple_func.to_Lp f hf + measure_theory.Lp.simple_func.to_Lp g hg)) (f : ↥(measure_theory.Lp.simple_func E p μ)) : P f
theorem padic_val_rat.inv (p : ℕ) [p_prime : fact (nat.prime p)] (q : ℚ) : padic_val_rat p q⁻¹ = -padic_val_rat p q
theorem finset.affine_combination_eq_linear_combination {k : Type u_1} {V : Type u_2} [ring k] [add_comm_group V] [module k V] {ι : Type u_4} (s : finset ι) (p : ι → V) (w : ι → k) (hw : s.sum (λ (i : ι), w i) = 1) : ⇑(s.affine_combination p) w = s.sum (λ (i : ι), w i • p i)
theorem bounded_continuous_function.Lp_norm_le {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} {p : ennreal} {μ : measure_theory.measure α} [normed_group E] [topological_space α] [borel_space α] [second_countable_topology_either α E] [measure_theory.is_finite_measure μ] (f : bounded_continuous_function α E) : ∥⟨continuous_map.to_ae_eq_fun μ f.to_continuous_map, _⟩∥ ≤ ↑(measure_theory.measure_univ_nnreal μ) ^ (p.to_real)⁻¹ * ∥f∥
theorem antitone.ne_of_lt_of_lt_int {α : Type u} [preorder α] {f : ℤ → α} (hf : antitone f) (n : ℤ) {x : α} (h1 : f (n + 1) < x) (h2 : x < f n) (a : ℤ) : f a ≠ x
theorem circle_integral.norm_integral_lt_of_norm_le_const_of_lt {E : Type u_1} [normed_group E] [normed_space ℂ E] [complete_space E] {f : ℂ → E} {c : ℂ} {R C : ℝ} (hR : 0 < R) (hc : continuous_on f (metric.sphere c R)) (hf : ∀ (z : ℂ), z ∈ metric.sphere c R → ∥f z∥ ≤ C) (hlt : ∃ (z : ℂ) (H : z ∈ metric.sphere c R), ∥f z∥ < C) : ∥∮ (z : ℂ) in C(c, R), f z∥ < 2 * real.pi * R * C
theorem measurable_of_tendsto_ennreal {α : Type u_1} [measurable_space α] {f : ℕ → α → ennreal} {g : α → ennreal} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g
theorem nnreal.inner_le_Lp_mul_Lq_has_sum {ι : Type u} {f g : ι → nnreal} {A B : nnreal} {p q : ℝ} (hpq : p.is_conjugate_exponent q) (hf : has_sum (λ (i : ι), f i ^ p) (A ^ p)) (hg : has_sum (λ (i : ι), g i ^ q) (B ^ q)) : ∃ (C : nnreal), C ≤ A * B ∧ has_sum (λ (i : ι), f i * g i) C
theorem filter.tendsto_small_sets_iff {α : Type u_1} {β : Type u_2} {la : filter α} {lb : filter β} {f : α → set β} : filter.tendsto f la lb.small_sets ↔ ∀ (t : set β), t ∈ lb → (∀ᶠ (x : α) in la, f x ⊆ t)
theorem char_p_zero_or_prime_power (R : Type u_1) [comm_ring R] [local_ring R] (q : ℕ) [char_R_q : char_p R q] : q = 0 ∨ is_prime_pow q
theorem pgame.lt_or_equiv_or_gt_or_fuzzy (x y : pgame) : x < y ∨ x.equiv y ∨ y < x ∨ x.fuzzy y
theorem submonoid.bot_or_nontrivial {M : Type u_1} [mul_one_class M] (S : submonoid M) : S = ⊥ ∨ nontrivial ↥S
theorem is_left_regular.pow {R : Type u_1} {a : R} [monoid R] (n : ℕ) (rla : is_left_regular a) : is_left_regular (a ^ n)
theorem cont_mdiff_on_iff {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M → M'} {s : set M} {n : with_top ℕ} : cont_mdiff_on I I' n f s ↔ continuous_on f s ∧ ∀ (x : M) (y : M'), cont_diff_on 𝕜 n (⇑(ext_chart_at I' y) ∘ f ∘ ⇑((ext_chart_at I x).symm)) ((ext_chart_at I x).target ∩ ⇑((ext_chart_at I x).symm) ⁻¹' (s ∩ f ⁻¹' (ext_chart_at I' y).source))
theorem subgroup.inv_mem {G : Type u_1} [group G] (H : subgroup G) {x : G} : x ∈ H → x⁻¹ ∈ H
theorem convex_cone.salient_positive_cone (𝕜 : Type u_1) (E : Type u_2) [ordered_semiring 𝕜] [ordered_add_comm_group E] [module 𝕜 E] [ordered_smul 𝕜 E] : (convex_cone.positive_cone 𝕜 E).salient
theorem iterated_fderiv_within_inter' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s u : set E} {f : E → F} {x : E} {n : ℕ} (hu : u ∈ nhds_within x s) (hs : unique_diff_on 𝕜 s) (xs : x ∈ s) : iterated_fderiv_within 𝕜 n f (s ∩ u) x = iterated_fderiv_within 𝕜 n f s x
theorem category_theory.equalizer.sieve.equalizer_sheaf_condition {C : Type u₁} [category_theory.category C] (P : Cᵒᵖ ⥤ Type (max v₁ u₁)) {X : C} (S : category_theory.sieve X) : category_theory.presieve.is_sheaf_for P ⇑S ↔ nonempty (category_theory.limits.is_limit (category_theory.limits.fork.of_ι (category_theory.equalizer.fork_map P ⇑S) _))
theorem category_theory.functor.monotone {X : Type u} {Y : Type v} [preorder X] [preorder Y] (f : X ⥤ Y) : monotone f.obj
theorem affine.simplex.vector_span_le_altitude_direction_orthogonal {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P (n + 1)) (i : fin (n + 2)) : vector_span ℝ (s.points '' ↑(finset.univ.erase i)) ≤ ((s.altitude i).direction)ᗮ
theorem dense_range.topological_closure_map_submodule {R₁ : Type u_1} {R₂ : Type u_2} [semiring R₁] [semiring R₂] {σ₁₂ : R₁ →+* R₂} {M₁ : Type u_4} [topological_space M₁] [add_comm_monoid M₁] {M₂ : Type u_6} [topological_space M₂] [add_comm_monoid M₂] [module R₁ M₁] [module R₂ M₂] [ring_hom_surjective σ₁₂] [topological_space R₁] [topological_space R₂] [has_continuous_smul R₁ M₁] [has_continuous_add M₁] [has_continuous_smul R₂ M₂] [has_continuous_add M₂] {f : M₁ →SL[σ₁₂] M₂} (hf' : dense_range ⇑f) {s : submodule R₁ M₁} (hs : s.topological_closure = ⊤) : (submodule.map ↑f s).topological_closure = ⊤
theorem set.Union_Inter_subset {α : Type u_1} {ι : Sort u_4} {ι' : Sort u_5} {s : ι → ι' → set α} : (⋃ (j : ι'), ⋂ (i : ι), s i j) ⊆ ⋂ (i : ι), ⋃ (j : ι'), s i j
theorem finprod_comp {α : Type u_1} {β : Type u_2} {M : Type u_5} [comm_monoid M] {g : β → M} (e : α → β) (he₀ : function.bijective e) : finprod (λ (i : α), g (e i)) = finprod (λ (j : β), g j)
theorem ideal.map_pi {R : Type u} [comm_ring R] (I : ideal R) {ι : Type u_1} [fintype ι] {ι' : Type w} (x : ι → R) (hi : ∀ (i : ι), x i ∈ I) (f : (ι → R) →ₗ[R] ι' → R) (i : ι') : ⇑f x i ∈ I
theorem real.sq_cos_pi_div_six  : real.cos (real.pi / 6) ^ 2 = 3 / 4
theorem continuous_at.snd'' {α : Type u} {β : Type v} {γ : Type u_1} [topological_space α] [topological_space β] [topological_space γ] {f : β → γ} {x : α × β} (hf : continuous_at f x.snd) : continuous_at (λ (x : α × β), f x.snd) x
theorem abs_cases {α : Type u} [linear_ordered_ring α] (a : α) : |a| = a ∧ 0 ≤ a ∨ |a| = -a ∧ a < 0
theorem power_basis.repr_gen_pow_is_integral {S : Type u_2} [comm_ring S] {R : Type u_3} [comm_ring R] [algebra R S] {A : Type u_4} [comm_ring A] [algebra R A] [algebra S A] [is_scalar_tower R S A] {B : power_basis S A} (hB : is_integral R B.gen) [is_domain S] (hmin : minpoly S B.gen = polynomial.map (algebra_map R S) (minpoly R B.gen)) (n : ℕ) (i : fin B.dim) : is_integral R (⇑(⇑(B.basis.repr) (B.gen ^ n)) i)
theorem continuous.exists_forall_ge_of_has_compact_mul_support {α : Type u_1} {β : Type u_2} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [topological_space β] [nonempty β] [has_one α] {f : β → α} (hf : continuous f) (h : has_compact_mul_support f) : ∃ (x : β), ∀ (y : β), f y ≤ f x
theorem combinatorics.exists_mono_homothetic_copy {M : Type u_1} {κ : Type u_2} [add_comm_monoid M] (S : finset M) [fintype κ] (C : M → κ) : ∃ (a : ℕ) (H : a > 0) (b : M) (c : κ), ∀ (s : M), s ∈ S → C (a • s + b) = c
theorem is_right_regular.pow_iff {R : Type u_1} {a : R} [monoid R] {n : ℕ} (n0 : 0 < n) : is_right_regular (a ^ n) ↔ is_right_regular a
theorem semiconj_by.reflexive {M : Type u} [mul_one_class M] : reflexive (λ (a b : M), ∃ (c : M), semiconj_by c a b)
theorem local_homeomorph.is_O_congr {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {E : Type u_3} [has_norm E] {F : Type u_4} [has_norm F] (e : local_homeomorph α β) {b : β} (hb : b ∈ e.to_local_equiv.target) {f : β → E} {g : β → F} : f =O[nhds b] g ↔ (f ∘ ⇑e) =O[nhds (⇑(e.symm) b)] (g ∘ ⇑e)
theorem finite_dimensional.exists_is_basis_integral (A : Type u_2) (K : Type u_3) [comm_ring A] [field K] [is_domain A] [algebra A K] [is_fraction_ring A K] (L : Type u_4) [field L] [algebra K L] [finite_dimensional K L] [algebra A L] [is_scalar_tower A K L] : ∃ (s : finset L) (b : basis ↥s K L), ∀ (x : ↥s), is_integral A (⇑b x)
theorem con.ker_lift_mk {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {f : M →* P} (x : M) : ⇑(con.ker_lift f) ↑x = ⇑f x
theorem measurable_space.dynkin_system.generate_from_eq {α : Type u_1} {s : set (set α)} (hs : is_pi_system s) : measurable_space.generate_from s = (measurable_space.dynkin_system.generate s).to_measurable_space _
theorem affine_equiv.affine_independent_iff {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} {V₂ : Type u_5} {P₂ : Type u_6} [add_comm_group V₂] [module k V₂] [add_torsor V₂ P₂] {p : ι → P} (e : P ≃ᵃ[k] P₂) : affine_independent k (⇑e ∘ p) ↔ affine_independent k p
theorem csupr_mem_Inter_Icc_of_antitone_Icc {α : Type u_1} {β : Type u_2} [conditionally_complete_lattice α] [semilattice_sup β] {f g : β → α} (h : antitone (λ (n : β), set.Icc (f n) (g n))) (h' : ∀ (n : β), f n ≤ g n) : (⨆ (n : β), f n) ∈ ⋂ (n : β), set.Icc (f n) (g n)
theorem normed_group_hom.is_quotient_quotient {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) : S.normed_mk.is_quotient
theorem category_theory.is_kernel_pair.is_reflexive_pair {C : Type u} [category_theory.category C] {A B R : C} {f g : R ⟶ A} {q : A ⟶ B} (h : category_theory.is_kernel_pair q f g) : category_theory.is_reflexive_pair f g
theorem self_adjoint.coe_re_map_spectrum {A : Type u_1} [normed_ring A] [normed_algebra ℂ A] [complete_space A] [star_ring A] [cstar_ring A] [star_module ℂ A] [nontrivial A] {a : A} (ha : a ∈ self_adjoint A) : spectrum ℂ a = coe ∘ complex.re '' spectrum ℂ a
theorem edist_le_Ico_sum_edist {α : Type u} [pseudo_emetric_space α] (f : ℕ → α) {m n : ℕ} (h : m ≤ n) : has_edist.edist (f m) (f n) ≤ (finset.Ico m n).sum (λ (i : ℕ), has_edist.edist (f i) (f (i + 1)))
theorem function.injective2.left {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) (b : β) : function.injective (λ (a : α), f a b)
theorem function.is_periodic_pt_zero {α : Type u_1} (f : α → α) (x : α) : function.is_periodic_pt f 0 x
theorem con.Sup_eq_con_gen {M : Type u_1} [has_mul M] (S : set (con M)) : has_Sup.Sup S = con_gen (λ (x y : M), ∃ (c : con M), c ∈ S ∧ ⇑c x y)
theorem filter.tendsto.at_top_div_const {α : Type u_3} {β : Type u_4} [linear_ordered_field α] {l : filter β} {f : β → α} {r : α} (hr : 0 < r) (hf : filter.tendsto f l filter.at_top) : filter.tendsto (λ (x : β), f x / r) l filter.at_top
theorem box_integral.integrable.sum_integral_congr {ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} [complete_space F] (h : box_integral.integrable I l f vol) {π₁ π₂ : box_integral.prepartition I} (hU : π₁.Union = π₂.Union) : π₁.boxes.sum (λ (J : box_integral.box ι), box_integral.integral J l f vol) = π₂.boxes.sum (λ (J : box_integral.box ι), box_integral.integral J l f vol)
theorem antivary_on.sum_mul_lt_sum_comp_perm_mul_iff {ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {s : finset ι} {σ : equiv.perm ι} {f g : ι → α} (hfg : antivary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i * g i) < s.sum (λ (i : ι), f (⇑σ i) * g i) ↔ ¬antivary_on (f ∘ ⇑σ) g ↑s
theorem add_valuation.is_equiv.comap {R : Type u_2} {Γ₀ : Type u_3} {Γ'₀ : Type u_4} [linear_ordered_add_comm_monoid_with_top Γ₀] [linear_ordered_add_comm_monoid_with_top Γ'₀] [ring R] {v₁ : add_valuation R Γ₀} {v₂ : add_valuation R Γ'₀} {S : Type u_1} [ring S] (f : S →+* R) (h : v₁.is_equiv v₂) : (add_valuation.comap f v₁).is_equiv (add_valuation.comap f v₂)
theorem unique_diff_on_convex {G : Type u_4} [normed_group G] [normed_space ℝ G] {s : set G} (conv : convex ℝ s) (hs : (interior s).nonempty) : unique_diff_on ℝ s
theorem category_theory.limits.biproduct.total {C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] {f : J → C} [category_theory.limits.has_biproduct f] : finset.univ.sum (λ (j : J), category_theory.limits.biproduct.π f j ≫ category_theory.limits.biproduct.ι f j) = 𝟙 (⨁ f)
theorem is_coatom.dual {α : Type u_1} [preorder α] [order_top α] {a : α} : is_coatom a → is_atom (⇑order_dual.to_dual a)
theorem isometry_emetric_iff_metric {α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {f : α → β} : isometry f ↔ ∀ (x y : α), has_dist.dist (f x) (f y) = has_dist.dist x y
theorem orthonormal.map_linear_isometry_equiv {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {E' : Type u_7} [inner_product_space 𝕜 E'] {v : basis ι 𝕜 E} (hv : orthonormal 𝕜 ⇑v) (f : E ≃ₗᵢ[𝕜] E') : orthonormal 𝕜 ⇑(v.map f.to_linear_equiv)
theorem submonoid.localization_map.eq_of_eq {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M →* P} (hg : ∀ (y : ↥S), is_unit (⇑g ↑y)) {x y : M} (h : ⇑(f.to_map) x = ⇑(f.to_map) y) : ⇑g x = ⇑g y
theorem function.injective.exists_ne {α : Type u_1} {β : Type u_2} [nontrivial α] {f : α → β} (hf : function.injective f) (y : β) : ∃ (x : α), f x ≠ y
theorem norm_pow_le {α : Type u_1} [semi_normed_ring α] [norm_one_class α] (a : α) (n : ℕ) : ∥a ^ n∥ ≤ ∥a∥ ^ n
theorem mem_nhds_within_Ici_iff_exists_Ico_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_max_order α] {a : α} {s : set α} : s ∈ nhds_within a (set.Ici a) ↔ ∃ (u : α) (H : u ∈ set.Ioi a), set.Ico a u ⊆ s
theorem domain_mvt {E : Type u_1} [normed_group E] [normed_space ℝ E] {f : E → ℝ} {s : set E} {x y : E} {f' : E → (E →L[ℝ] ℝ)} (hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (hs : convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)
theorem padic_norm.nonarchimedean (p : ℕ) [hp : fact (nat.prime p)] {q r : ℚ} : padic_norm p (q + r) ≤ linear_order.max (padic_norm p q) (padic_norm p r)
theorem category_theory.triangulated.pretriangulated.comp_dist_triangle_mor_zero₂₃ (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C ℤ] [category_theory.preadditive C] [∀ (n : ℤ), (category_theory.shift_functor C n).additive] [category_theory.triangulated.pretriangulated C] (T : category_theory.triangulated.triangle C) (H : T ∈ dist_triang C) : T.mor₂ ≫ T.mor₃ = 0
theorem algebraic_geometry.polynomial.is_open_map_comap_C {R : Type u_1} [comm_ring R] : is_open_map ⇑(prime_spectrum.comap polynomial.C)
theorem free_group.ext_hom {α : Type u} {G : Type u_1} [group G] (f g : free_group α →* G) (h : ∀ (a : α), ⇑f (free_group.of a) = ⇑g (free_group.of a)) : f = g
theorem le_nhds_of_Limsup_eq_Liminf {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {f : filter α} {a : α} (hl : filter.is_bounded has_le.le f) (hg : filter.is_bounded ge f) (hs : f.Limsup = a) (hi : f.Liminf = a) : f ≤ nhds a
theorem cont_diff_on.comp_continuous_linear_map {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {s : set E} {f : E → F} {n : with_top ℕ} (hf : cont_diff_on 𝕜 n f s) (g : G →L[𝕜] E) : cont_diff_on 𝕜 n (f ∘ ⇑g) (⇑g ⁻¹' s)
theorem multiples.is_add_submonoid {M : Type u_1} [add_monoid M] (x : M) : is_add_submonoid (multiples x)
theorem interval_integrable_sub_inv_iff {a b c : ℝ} : interval_integrable (λ (x : ℝ), (x - c)⁻¹) measure_theory.measure_space.volume a b ↔ a = b ∨ c ∉ set.interval a b
theorem measure_theory.outer_measure.bounded_by_union_of_top_of_nonempty_inter {α : Type u_1} {m : set α → ennreal} {s t : set α} (h : ∀ (u : set α), (s ∩ u).nonempty → (t ∩ u).nonempty → m u = ⊤) : ⇑(measure_theory.outer_measure.bounded_by m) (s ∪ t) = ⇑(measure_theory.outer_measure.bounded_by m) s + ⇑(measure_theory.outer_measure.bounded_by m) t
theorem convex.strict_anti_on_of_deriv_neg {D : set ℝ} (hD : convex ℝ D) {f : ℝ → ℝ} (hf : continuous_on f D) (hf' : ∀ (x : ℝ), x ∈ interior D → deriv f x < 0) : strict_anti_on f D
theorem tendsto_nhds_lim {α : Type u} {β : Type v} [topological_space α] {f : filter β} {g : β → α} (h : ∃ (a : α), filter.tendsto g f (nhds a)) : filter.tendsto g f (nhds (lim f g))
theorem complete_lattice.independent.linear_independent {ι : Type u_1} {R : Type u_2} {N : Type u_5} [ring R] [add_comm_group N] [module R N] [no_zero_smul_divisors R N] (p : ι → submodule R N) (hp : complete_lattice.independent p) {v : ι → N} (hv : ∀ (i : ι), v i ∈ p i) (hv' : ∀ (i : ι), v i ≠ 0) : linear_independent R v
theorem cont_diff_on.mul {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {n : with_top ℕ} {s : set E} {f g : E → 𝕜} (hf : cont_diff_on 𝕜 n f s) (hg : cont_diff_on 𝕜 n g s) : cont_diff_on 𝕜 n (λ (x : E), f x * g x) s
theorem is_open_map.to_quotient_map {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f) : quotient_map f
theorem subsemigroup.mul_mem {M : Type u_1} [has_mul M] (S : subsemigroup M) {x y : M} : x ∈ S → y ∈ S → x * y ∈ S
theorem ideal.exists_ideal_over_prime_of_is_integral' {R : Type u_1} [comm_ring R] {S : Type u_2} [comm_ring S] [algebra R S] [is_domain S] (H : algebra.is_integral R S) (P : ideal R) [P.is_prime] (hP : (algebra_map R S).ker ≤ P) : ∃ (Q : ideal S), Q.is_prime ∧ ideal.comap (algebra_map R S) Q = P
theorem algebraic_geometry.PresheafedSpace.glue_data.π_ι_inv_app_eq_id {C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) [category_theory.limits.has_limits C] (i : D.to_glue_data.J) (U : topological_space.opens ↥((D.to_glue_data.U i).carrier)) : D.diagram_over_open_π U i ≫ D.ι_inv_app_π_eq_map U ≫ D.ι_inv_app U = 𝟙 (category_theory.limits.limit (D.diagram_over_open U))
theorem normed_field.tendsto_zero_smul_of_tendsto_zero_of_bounded {ι : Type u_1} {𝕜 : Type u_2} {𝔸 : Type u_3} [normed_field 𝕜] [normed_group 𝔸] [normed_space 𝕜 𝔸] {l : filter ι} {ε : ι → 𝕜} {f : ι → 𝔸} (hε : filter.tendsto ε l (nhds 0)) (hf : filter.is_bounded_under has_le.le l (has_norm.norm ∘ f)) : filter.tendsto (ε • f) l (nhds 0)
theorem norm_bound {𝕜 : Type u_1} [is_R_or_C 𝕜] {F : Type u_2} [semi_normed_group F] [normed_space 𝕜 F] [normed_space ℝ F] [is_scalar_tower ℝ 𝕜 F] (fr : F →L[ℝ] ℝ) (x : F) : ∥⇑(fr.to_linear_map.extend_to_𝕜') x∥ ≤ ∥fr∥ * ∥x∥
theorem bump_covering.exists_is_subordinate_of_locally_finite {ι : Type u} {X : Type v} [topological_space X] {s : set X} [normal_space X] (hs : is_closed s) (U : ι → set X) (ho : ∀ (i : ι), is_open (U i)) (hf : locally_finite U) (hU : s ⊆ ⋃ (i : ι), U i) : ∃ (f : bump_covering ι X s), f.is_subordinate U
theorem matrix.is_diag_from_blocks_iff {α : Type u_1} {n : Type u_4} {m : Type u_5} [has_zero α] {A : matrix m m α} {B : matrix m n α} {C : matrix n m α} {D : matrix n n α} : (matrix.from_blocks A B C D).is_diag ↔ A.is_diag ∧ B = 0 ∧ C = 0 ∧ D.is_diag
theorem cardinal.ord_card_unbounded'  : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b ∧ ordinal.omega ≤ b}
theorem is_local_extr.fderiv_eq_zero {E : Type u} [normed_group E] [normed_space ℝ E] {f : E → ℝ} {a : E} (h : is_local_extr f a) : fderiv ℝ f a = 0
theorem exists_has_deriv_within_at_eq_of_lt_of_gt {a b : ℝ} {f f' : ℝ → ℝ} (hab : a ≤ b) (hf : ∀ (x : ℝ), x ∈ set.Icc a b → has_deriv_within_at f (f' x) (set.Icc a b) x) {m : ℝ} (hma : m < f' a) (hmb : f' b < m) : m ∈ f' '' set.Icc a b
theorem exists_nhds_square {α : Type u} [topological_space α] {s : set (α × α)} {x : α} (hx : s ∈ nhds (x, x)) : ∃ (U : set α), is_open U ∧ x ∈ U ∧ U ×ˢ U ⊆ s
theorem direct_sum.alg_hom_ext' {ι : Type uι} (R : Type uR) (A : ι → Type uA) {B : Type uB} [decidable_eq ι] [comm_semiring R] [Π (i : ι), add_comm_monoid (A i)] [Π (i : ι), module R (A i)] [add_monoid ι] [direct_sum.gsemiring A] [semiring B] [direct_sum.galgebra R A] [algebra R B] ⦃f g : direct_sum ι (λ (i : ι), A i) →ₐ[R] B⦄ (h : ∀ (i : ι), f.to_linear_map.comp (direct_sum.lof R ι A i) = g.to_linear_map.comp (direct_sum.lof R ι A i)) : f = g
theorem category_theory.nat_trans.right_derived_eq {C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] [category_theory.abelian C] [category_theory.has_injective_resolutions C] [category_theory.abelian D] {F G : C ⥤ D} [F.additive] [G.additive] (α : F ⟶ G) (n : ℕ) {X : C} (P : category_theory.InjectiveResolution X) : (category_theory.nat_trans.right_derived α n).app X = (F.right_derived_obj_iso n P).hom ≫ (homology_functor D (complex_shape.up ℕ) n).map ((category_theory.nat_trans.map_homological_complex α (complex_shape.up ℕ)).app P.cocomplex) ≫ (G.right_derived_obj_iso n P).inv
theorem algebraic_geometry.polynomial.comap_C_mem_image_of_Df {R : Type u_1} [comm_ring R] {f : polynomial R} {I : prime_spectrum (polynomial R)} (H : I ∈ (prime_spectrum.zero_locus {f})ᶜ) : ⇑(prime_spectrum.comap polynomial.C) I ∈ algebraic_geometry.polynomial.image_of_Df f
theorem structure_groupoid.local_invariant_prop.lift_prop_within_at_indep_chart_aux {H : Type u_1} {M : Type u_2} [topological_space H] [topological_space M] [charted_space H M] {H' : Type u_3} {M' : Type u_4} [topological_space H'] [topological_space M'] [charted_space H' M'] {G : structure_groupoid H} {G' : structure_groupoid H'} {e e' : local_homeomorph M H} {f f' : local_homeomorph M' H'} {P : (H → H') → set H → H → Prop} {g : M → M'} {s : set M} {x : M} (hG : G.local_invariant_prop G' P) (he : e ∈ structure_groupoid.maximal_atlas M G) (xe : x ∈ e.to_local_equiv.source) (he' : e' ∈ structure_groupoid.maximal_atlas M G) (xe' : x ∈ e'.to_local_equiv.source) (hf : f ∈ structure_groupoid.maximal_atlas M' G') (xf : g x ∈ f.to_local_equiv.source) (hf' : f' ∈ structure_groupoid.maximal_atlas M' G') (xf' : g x ∈ f'.to_local_equiv.source) (hgs : continuous_within_at g s x) (h : P (⇑f ∘ g ∘ ⇑(e.symm)) (e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' (s ∩ g ⁻¹' f.to_local_equiv.source)) (⇑e x)) : P (⇑f' ∘ g ∘ ⇑(e'.symm)) (e'.to_local_equiv.target ∩ ⇑(e'.symm) ⁻¹' (s ∩ g ⁻¹' f'.to_local_equiv.source)) (⇑e' x)
theorem polynomial.cyclotomic_irreducible_of_irreducible_pow {p : ℕ} (hp : nat.prime p) {R : Type u_1} [comm_ring R] [is_domain R] {n : ℕ} (hn : n ≠ 0) (h : irreducible (polynomial.cyclotomic (p ^ n) R)) : irreducible (polynomial.cyclotomic p R)
theorem finset.prod_subtype_of_mem {β : Type u} {α : Type v} {s : finset α} [comm_monoid β] (f : α → β) {p : α → Prop} [decidable_pred p] (h : ∀ (x : α), x ∈ s → p x) : (finset.subtype p s).prod (λ (x : subtype p), f ↑x) = s.prod (λ (x : α), f x)
theorem filter.tendsto.at_top_mul_neg_const {α : Type u_3} {β : Type u_4} [linear_ordered_field α] {l : filter β} {f : β → α} {r : α} (hr : r < 0) (hf : filter.tendsto f l filter.at_top) : filter.tendsto (λ (x : β), f x * r) l filter.at_bot
theorem zero_hom.congr_fun {M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] {f g : zero_hom M N} (h : f = g) (x : M) : ⇑f x = ⇑g x
theorem finset.prod_sigma {β : Type u} {α : Type v} [comm_monoid β] {σ : α → Type u_1} (s : finset α) (t : Π (a : α), finset (σ a)) (f : sigma σ → β) : (s.sigma t).prod (λ (x : Σ (i : α), σ i), f x) = s.prod (λ (a : α), (t a).prod (λ (s : σ a), f ⟨a, s⟩))
theorem reflection_involutive {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) [complete_space ↥K] : function.involutive ⇑(reflection K)
theorem is_localization.localization_localization_is_localization {R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] (N : submonoid S) (T : Type u_4) [comm_ring T] [algebra R T] [algebra S T] [is_scalar_tower R S T] [is_localization M S] [is_localization N T] : is_localization (is_localization.localization_localization_submodule M N) T
theorem basis.orientation_ne_iff_eq_neg {R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {ι : Type u_3} [decidable_eq ι] [fintype ι] (e : basis ι R M) (x : orientation R M ι) : x ≠ e.orientation ↔ x = -e.orientation
theorem measure_theory.null_of_locally_null {α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} [topological_space α] [topological_space.second_countable_topology α] (s : set α) (hs : ∀ (x : α), x ∈ s → (∃ (u : set α) (H : u ∈ nhds_within x s), ⇑μ u = 0)) : ⇑μ s = 0
theorem measure_theory.indicator_const_Lp_disjoint_union {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} {p : ennreal} {μ : measure_theory.measure α} [normed_group E] {s t : set α} (hs : measurable_set s) (ht : measurable_set t) (hμs : ⇑μ s ≠ ⊤) (hμt : ⇑μ t ≠ ⊤) (hst : s ∩ t = ∅) (c : E) : measure_theory.indicator_const_Lp p _ _ c = measure_theory.indicator_const_Lp p hs hμs c + measure_theory.indicator_const_Lp p ht hμt c
theorem nat.of_digits_lt_base_pow_length' {b : ℕ} {l : list ℕ} (hl : ∀ (x : ℕ), x ∈ l → x < b + 2) : nat.of_digits (b + 2) l < (b + 2) ^ l.length
theorem measure_theory.tendsto_measure_bInter_gt {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {ι : Type u_2} [linear_order ι] [topological_space ι] [order_topology ι] [densely_ordered ι] [topological_space.first_countable_topology ι] {s : ι → set α} {a : ι} (hs : ∀ (r : ι), r > a → measurable_set (s r)) (hm : ∀ (i j : ι), a < i → i ≤ j → s i ⊆ s j) (hf : ∃ (r : ι) (H : r > a), ⇑μ (s r) ≠ ⊤) : filter.tendsto (⇑μ ∘ s) (nhds_within a (set.Ioi a)) (nhds (⇑μ (⋂ (r : ι) (H : r > a), s r)))
theorem category_theory.limits.is_terminal.mono_from {C : Type u₁} [category_theory.category C] {X Y : C} (t : category_theory.limits.is_terminal X) (f : X ⟶ Y) : category_theory.mono f
theorem sylow.exists_subgroup_card_pow_prime {G : Type u} [group G] [fintype G] (p : ℕ) {n : ℕ} [fact (nat.prime p)] (hdvd : p ^ n ∣ fintype.card G) : ∃ (K : subgroup G), fintype.card ↥K = p ^ n
theorem submonoid.localization_map.map_mul_right {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M →* P} {T : submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ T) {Q : Type u_4} [comm_monoid Q] {k : T.localization_map Q} (z : N) : ⇑(f.map hy k) z * ⇑(k.to_map) (⇑g ↑((f.sec z).snd)) = ⇑(k.to_map) (⇑g (f.sec z).fst)
theorem associates.eq_pow_count_factors_of_dvd_pow {α : Type u_1} [cancel_comm_monoid_with_zero α] [dec_irr : Π (p : associates α), decidable (irreducible p)] [unique_factorization_monoid α] [dec : decidable_eq α] [dec' : decidable_eq (associates α)] {p a : associates α} (hp : irreducible p) {n : ℕ} (h : a ∣ p ^ n) : a = p ^ p.count a.factors
theorem fin.lt_succ_above_iff {n : ℕ} (p : fin (n + 1)) (i : fin n) : p < ⇑(p.succ_above) i ↔ p ≤ ⇑fin.cast_succ i
theorem formal_multilinear_series.comp_change_of_variables_sum {α : Type u_1} [add_comm_monoid α] (m M N : ℕ) (f : (Σ (n : ℕ), fin n → ℕ) → α) (g : (Σ (n : ℕ), composition n) → α) (h : ∀ (e : Σ (n : ℕ), fin n → ℕ) (he : e ∈ formal_multilinear_series.comp_partial_sum_source m M N), f e = g (formal_multilinear_series.comp_change_of_variables m M N e he)) : (formal_multilinear_series.comp_partial_sum_source m M N).sum (λ (e : Σ (n : ℕ), fin n → ℕ), f e) = (formal_multilinear_series.comp_partial_sum_target m M N).sum (λ (e : Σ (n : ℕ), composition n), g e)
theorem interval_integral.measure_integral_sub_linear_is_o_of_tendsto_ae {ι : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a : ℝ} {c : E} {l l' : filter ℝ} {lt : filter ι} {μ : measure_theory.measure ℝ} {u v : ι → ℝ} [measure_theory.is_locally_finite_measure μ] [interval_integral.FTC_filter a l l'] (hfm : strongly_measurable_at_filter f l' μ) (hf : filter.tendsto f (l' ⊓ μ.ae) (nhds c)) (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) : (λ (t : ι), ∫ (x : ℝ) in u t..v t, f x ∂μ - ∫ (x : ℝ) in u t..v t, c ∂μ) =o[lt] λ (t : ι), ∫ (x : ℝ) in u t..v t, 1 ∂μ
theorem emetric.tendsto_uniformly_iff {α : Type u} {β : Type v} [pseudo_emetric_space α] {ι : Type u_1} {F : ι → β → α} {f : β → α} {p : filter ι} : tendsto_uniformly F f p ↔ ∀ (ε : ennreal), ε > 0 → (∀ᶠ (n : ι) in p, ∀ (x : β), has_edist.edist (f x) (F n x) < ε)
theorem subfield.neg_mem {K : Type u} [field K] (s : subfield K) {x : K} : x ∈ s → -x ∈ s
theorem add_submonoid.localization_map.map_map {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M →+ P} {T : add_submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ T) {Q : Type u_4} [add_comm_monoid Q] {k : T.localization_map Q} {A : Type u_5} [add_comm_monoid A] {U : add_submonoid A} {R : Type u_6} [add_comm_monoid R] (j : U.localization_map R) {l : P →+ A} (hl : ∀ (w : ↥T), ⇑l ↑w ∈ U) (x : N) : ⇑(k.map hl j) (⇑(f.map hy k) x) = ⇑(f.map _ j) x
theorem measurable_liminf' {α : Type u_1} {δ : Type u_5} [topological_space α] [measurable_space α] [borel_space α] [measurable_space δ] [complete_linear_order α] [order_topology α] [topological_space.second_countable_topology α] {ι : Type u_2} {ι' : Type u_3} {f : ι → δ → α} {u : filter ι} (hf : ∀ (i : ι), measurable (f i)) {p : ι' → Prop} {s : ι' → set ι} (hu : u.has_countable_basis p s) (hs : ∀ (i : ι'), (s i).countable) : measurable (λ (x : δ), u.liminf (λ (i : ι), f i x))
theorem measure_theory.measure.finite_spanning_sets_in.outer_regular {α : Type u_1} [measurable_space α] [topological_space α] [opens_measurable_space α] {μ : measure_theory.measure α} (s : μ.finite_spanning_sets_in {U : set α | is_open U ∧ (μ.restrict U).outer_regular}) : μ.outer_regular
theorem orthonormal.oangle_add_oangle_rev_neg_left {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x y : V) : hb.oangle (-x) y + hb.oangle (-y) x = 0
theorem metric.closure_subset_cthickening {α : Type u} [pseudo_emetric_space α] (δ : ℝ) (E : set α) : closure E ⊆ metric.cthickening δ E
theorem algebra_map_int_eq (R : Type u_1) [ring R] : algebra_map ℤ R = int.cast_ring_hom R
theorem partition_of_unity.exists_is_subordinate_of_locally_finite {ι : Type u} {X : Type v} [topological_space X] {s : set X} [normal_space X] (hs : is_closed s) (U : ι → set X) (ho : ∀ (i : ι), is_open (U i)) (hf : locally_finite U) (hU : s ⊆ ⋃ (i : ι), U i) : ∃ (f : partition_of_unity ι X s), f.is_subordinate U
theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3
theorem mul_inv_mul_self {G₀ : Type u_2} [group_with_zero G₀] (a : G₀) : a * a⁻¹ * a = a
theorem submodule.orthogonal_gc (𝕜 : Type u_1) (E : Type u_2) [is_R_or_C 𝕜] [inner_product_space 𝕜 E] : galois_connection submodule.orthogonal submodule.orthogonal
theorem add_subsemigroup.subset_closure {M : Type u_1} [has_add M] {s : set M} : s ⊆ ↑(add_subsemigroup.closure s)
theorem dense_liouville  : dense {x : ℝ | liouville x}
theorem finset.exists_card_fiber_le_of_card_le_nsmul {α : Type u} {β : Type v} {M : Type w} [decidable_eq β] {s : finset α} {t : finset β} {f : α → β} {b : M} [linear_ordered_comm_ring M] (ht : t.nonempty) (hb : ↑(s.card) ≤ t.card • b) : ∃ (y : β) (H : y ∈ t), ↑((finset.filter (λ (x : α), f x = y) s).card) ≤ b
theorem intermediate_field.bot_eq_top_of_dim_adjoin_eq_one {F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] (h : ∀ (x : E), module.rank F ↥F⟮x⟯ = 1) : ⊥ = ⊤
theorem quotient.eq_rel {α : Type u_1} {r : setoid α} {x y : α} : quotient.mk' x = quotient.mk' y ↔ r.rel x y
theorem asymptotics.is_o.norm_right {α : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : α → E} {g' : α → F'} {l : filter α} : f =o[l] g' → (f =o[l] λ (x : α), ∥g' x∥)
theorem filter.tendsto.cesaro_smul {E : Type u_1} [normed_group E] [normed_space ℝ E] {u : ℕ → E} {l : E} (h : filter.tendsto u filter.at_top (nhds l)) : filter.tendsto (λ (n : ℕ), (↑n)⁻¹ • (finset.range n).sum (λ (i : ℕ), u i)) filter.at_top (nhds l)
theorem continuous.ae_measurable {α : Type u_1} {γ : Type u_3} [topological_space α] [measurable_space α] [opens_measurable_space α] [topological_space γ] [measurable_space γ] [borel_space γ] {f : α → γ} (h : continuous f) {μ : measure_theory.measure α} : ae_measurable f μ
theorem mem_nhds_within_Ici_iff_exists_Ico_subset' {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a u' : α} {s : set α} (hu' : a < u') : s ∈ nhds_within a (set.Ici a) ↔ ∃ (u : α) (H : u ∈ set.Ioi a), set.Ico a u ⊆ s
theorem orthonormal.oangle_add_cyc3 {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle x y + hb.oangle y z + hb.oangle z x = 0
theorem euclidean_geometry.angle_comm {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (p1 p2 p3 : P) : euclidean_geometry.angle p1 p2 p3 = euclidean_geometry.angle p3 p2 p1
theorem ideal.is_jacobson_localization {R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] (y : R) [algebra R S] [is_localization.away y S] [H : ideal.is_jacobson R] : ideal.is_jacobson S
theorem centroid_mem_affine_span_of_nonempty (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} [char_zero k] {s : finset ι} (p : ι → P) (h : s.nonempty) : finset.centroid k s p ∈ affine_span k (set.range p)
theorem measure_theory.lintegral_with_density_eq_lintegral_mul {α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) {f : α → ennreal} (h_mf : measurable f) {g : α → ennreal} : measurable g → ∫⁻ (a : α), g a ∂μ.with_density f = ∫⁻ (a : α), (f * g) a ∂μ
theorem finset.weighted_vsub_of_point_eq_of_sum_eq_zero {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (w : ι → k) (p : ι → P) (h : s.sum (λ (i : ι), w i) = 0) (b₁ b₂ : P) : ⇑(s.weighted_vsub_of_point p b₁) w = ⇑(s.weighted_vsub_of_point p b₂) w
theorem linear_map.trace_one (R : Type u_1) [comm_ring R] (M : Type u_2) [add_comm_group M] [module R M] [module.free R M] [module.finite R M] [nontrivial R] : ⇑(linear_map.trace R M) 1 = ↑(finite_dimensional.finrank R M)
theorem is_monoid_hom.inv {α : Type u_1} {β : Type u_2} [mul_one_class α] [comm_group β] {f : α → β} (hf : is_monoid_hom f) : is_monoid_hom (λ (a : α), (f a)⁻¹)
theorem formal_multilinear_series.change_origin_eval {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] [complete_space F] (p : formal_multilinear_series 𝕜 E F) {x y : E} (h : ↑∥x∥₊ + ↑∥y∥₊ < p.radius) : (p.change_origin x).sum y = p.sum (x + y)
theorem is_free_groupoid.path_nonempty_of_hom {G : Type u} [category_theory.groupoid G] [is_free_groupoid G] {a b : G} : nonempty (a ⟶ b) → nonempty (quiver.path (symgen a) (symgen b))
theorem linear_map.exists_extend {K : Type u_4} {V : Type u} {V' : Type u_8} [field K] [add_comm_group V] [add_comm_group V'] [module K V] [module K V'] {p : submodule K V} (f : ↥p →ₗ[K] V') : ∃ (g : V →ₗ[K] V'), g.comp p.subtype = f
theorem exp_char_one_of_char_zero (R : Type u) [semiring R] (q : ℕ) [hp : char_p R 0] [hq : exp_char R q] : q = 1
theorem measure_theory.L2.inner_indicator_const_Lp_one {α : Type u_1} {𝕜 : Type u_4} [is_R_or_C 𝕜] [measurable_space α] {μ : measure_theory.measure α} {s : set α} (hs : measurable_set s) (hμs : ⇑μ s ≠ ⊤) (f : ↥(measure_theory.Lp 𝕜 2 μ)) : has_inner.inner (measure_theory.indicator_const_Lp 2 hs hμs 1) f = ∫ (x : α) in s, ⇑f x ∂μ
theorem filter.tendsto.neg_const_mul_at_bot {α : Type u_3} {β : Type u_4} [linear_ordered_field α] {l : filter β} {f : β → α} {r : α} (hr : r < 0) (hf : filter.tendsto f l filter.at_bot) : filter.tendsto (λ (x : β), r * f x) l filter.at_top
theorem tendsto_uniformly_on.comp' {α : Type u_1} {β : Type u_2} {γ : Type u_3} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {s : set α} {p : filter ι} [uniform_space γ] {g : β → γ} (h : tendsto_uniformly_on F f p s) (hg : uniform_continuous g) : tendsto_uniformly_on (λ (i : ι), g ∘ F i) (g ∘ f) p s
theorem has_mfderiv_within_at.has_fderiv_within_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {f : E → E'} {s : set E} {x : E} {f' : tangent_space (model_with_corners_self 𝕜 E) x →L[𝕜] tangent_space (model_with_corners_self 𝕜 E') (f x)} : has_mfderiv_within_at (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f s x f' → has_fderiv_within_at f f' s x
theorem simplex_category.σ_comp_σ {n : ℕ} {i j : fin (n + 1)} (H : i ≤ j) : simplex_category.σ (⇑fin.cast_succ i) ≫ simplex_category.σ j = simplex_category.σ j.succ ≫ simplex_category.σ i
theorem ring_hom.is_integral_elem_leading_coeff_mul {R : Type u_1} {S : Type u_4} [comm_ring R] [comm_ring S] (f : R →+* S) (p : polynomial R) (x : S) (h : polynomial.eval₂ f x p = 0) : f.is_integral_elem (⇑f p.leading_coeff * x)
theorem has_continuous_add_of_smooth {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space 𝕜 E] (I : model_with_corners 𝕜 E H) {G : Type u_4} [has_add G] [topological_space G] [charted_space H G] [has_smooth_add I G] : has_continuous_add G
theorem has_fderiv_at.of_local_left_inverse {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {f' : E ≃L[𝕜] F} {g : F → E} {a : F} (hg : continuous_at g a) (hf : has_fderiv_at f ↑f' (g a)) (hfg : ∀ᶠ (y : F) in nhds a, f (g y) = y) : has_fderiv_at g ↑(f'.symm) a
theorem mul_sub_mul_div_mul_nonpos {α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : a / c ≤ b / d → (a * d - b * c) / (c * d) ≤ 0
theorem affine_subspace.not_le_iff_exists {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P) : ¬s1 ≤ s2 ↔ ∃ (p : P) (H : p ∈ s1), p ∉ s2
theorem is_dedekind_domain.height_one_spectrum.int_valuation.map_one' {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) : v.int_valuation_def 1 = 1
theorem measure_theory.integrable.tendsto_set_integral_nhds_zero {α : Type u_1} {E : Type u_2} [normed_group E] [normed_space ℝ E] [complete_space E] {m : measurable_space α} {μ : measure_theory.measure α} {ι : Type u_3} {f : α → E} (hf : measure_theory.integrable f μ) {l : filter ι} {s : ι → set α} (hs : filter.tendsto (⇑μ ∘ s) l (nhds 0)) : filter.tendsto (λ (i : ι), ∫ (x : α) in s i, f x ∂μ) l (nhds 0)
theorem units.mul_left_dvd {α : Type u_1} [comm_monoid α] {a b : α} {u : αˣ} : ↑u * a ∣ b ↔ a ∣ b
theorem mul_mem_class.mul_right_mem_add_closure {M : Type u_1} {R : Type u_4} [non_unital_non_assoc_semiring R] [set_like M R] [mul_mem_class M R] {S : M} {a b : R} (ha : a ∈ add_submonoid.closure ↑S) (hb : b ∈ S) : a * b ∈ add_submonoid.closure ↑S
theorem category_theory.limits.pushout_cocone.coequalizer_ext {C : Type u} [category_theory.category C] {X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z} (t : category_theory.limits.pushout_cocone f g) {W : C} {k l : t.X ⟶ W} (h₀ : t.inl ≫ k = t.inl ≫ l) (h₁ : t.inr ≫ k = t.inr ≫ l) (j : category_theory.limits.walking_span) : t.ι.app j ≫ k = t.ι.app j ≫ l
theorem complex.re_eq_add_conj (z : ℂ) : ↑(z.re) = (z + ⇑(star_ring_end ℂ) z) / 2
theorem matrix.conj_transpose_smul {m : Type u_2} {n : Type u_3} {R : Type u_7} {α : Type v} [has_star R] [has_star α] [has_scalar R α] [star_module R α] (c : R) (M : matrix m n α) : (c • M).conj_transpose = has_star.star c • M.conj_transpose
theorem simplex_category.δ_comp_σ_of_le {n : ℕ} {i : fin (n + 2)} {j : fin (n + 1)} (H : i ≤ ⇑fin.cast_succ j) : simplex_category.δ (⇑fin.cast_succ i) ≫ simplex_category.σ j.succ = simplex_category.σ j ≫ simplex_category.δ i
theorem category_theory.limits.has_biproduct.of_has_product {C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J → C) [category_theory.limits.has_product f] : category_theory.limits.has_biproduct f
theorem linear_map.continuous_of_is_closed_graph {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] [complete_space F] [complete_space E] (g : E →ₗ[𝕜] F) (hg : is_closed ↑(g.graph)) : continuous ⇑g
theorem bornology.is_vonN_bounded_covers {𝕜 : Type u_1} {E : Type u_2} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [has_continuous_smul 𝕜 E] : ⋃₀set_of (bornology.is_vonN_bounded 𝕜) = set.univ
theorem finprod_mem_singleton {α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M} {a : α} : finprod (λ (i : α), finprod (λ (H : i ∈ {a}), f i)) = f a
theorem units.is_open {R : Type u_1} [normed_ring R] [complete_space R] : is_open {x : R | is_unit x}
theorem monoid_hom.eq_on_mclosure {M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] {f g : M →* N} {s : set M} (h : set.eq_on ⇑f ⇑g s) : set.eq_on ⇑f ⇑g ↑(submonoid.closure s)
theorem exp_add_of_commute {𝕂 : Type u_1} {𝔸 : Type u_2} [is_R_or_C 𝕂] [normed_ring 𝔸] [normed_algebra 𝕂 𝔸] [complete_space 𝔸] {x y : 𝔸} (hxy : commute x y) : exp 𝕂 (x + y) = exp 𝕂 x * exp 𝕂 y
theorem monoid_with_zero_hom.congr_fun {M : Type u_3} {N : Type u_4} [mul_zero_one_class M] [mul_zero_one_class N] {f g : M →*₀ N} (h : f = g) (x : M) : ⇑f x = ⇑g x
theorem prime_spectrum.exists_prime_spectrum_prod_le_and_ne_bot_of_domain {A : Type u} [comm_ring A] [is_domain A] [is_noetherian_ring A] (h_fA : ¬is_field A) {I : ideal A} (h_nzI : I ≠ ⊥) : ∃ (Z : multiset (prime_spectrum A)), (multiset.map coe Z).prod ≤ I ∧ (multiset.map coe Z).prod ≠ ⊥
theorem card_class_group_eq_one_iff {R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_dedekind_domain R] [fintype (class_group R K)] : fintype.card (class_group R K) = 1 ↔ is_principal_ideal_ring R
theorem right.one_lt_inv_iff {α : Type u} [group α] [has_lt α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a : α} : 1 < a⁻¹ ↔ a < 1
theorem dvd_add_self_left {α : Type u} [ring α] {a b : α} : a ∣ a + b ↔ a ∣ b
theorem basis.le_span {ι : Type w} {R : Type u} [ring R] [rank_condition R] {M : Type v} [add_comm_group M] [module R M] {J : set M} (v : basis ι R M) (hJ : submodule.span R J = ⊤) : cardinal.mk ↥(set.range ⇑v) ≤ cardinal.mk ↥J
theorem subring.closure_induction {R : Type u} [ring R] {s : set R} {p : R → Prop} {x : R} (h : x ∈ subring.closure s) (Hs : ∀ (x : R), x ∈ s → p x) (H0 : p 0) (H1 : p 1) (Hadd : ∀ (x y : R), p x → p y → p (x + y)) (Hneg : ∀ (x : R), p x → p (-x)) (Hmul : ∀ (x y : R), p x → p y → p (x * y)) : p x
theorem erased.out_proof {p : Prop} (a : erased p) : p
theorem finset.induction_on_min_value {α : Type u_1} {ι : Type u_4} [linear_order α] [decidable_eq ι] (f : ι → α) {p : finset ι → Prop} (s : finset ι) (h0 : p ∅) (step : ∀ (a : ι) (s : finset ι), a ∉ s → (∀ (x : ι), x ∈ s → f a ≤ f x) → p s → p (has_insert.insert a s)) : p s
theorem is_add_submonoid_Union_of_directed {M : Type u_1} [add_monoid M] {ι : Type u_2} [hι : nonempty ι] {s : ι → set M} (hs : ∀ (i : ι), is_add_submonoid (s i)) (directed : ∀ (i j : ι), ∃ (k : ι), s i ⊆ s k ∧ s j ⊆ s k) : is_add_submonoid (⋃ (i : ι), s i)
theorem set.pairwise_disjoint.bUnion_finset {α : Type u_1} {ι : Type u_2} {ι' : Type u_3} [lattice α] [order_bot α] {s : set ι'} {g : ι' → finset ι} {f : ι → α} (hs : s.pairwise_disjoint (λ (i' : ι'), (g i').sup f)) (hg : ∀ (i : ι'), i ∈ s → ↑(g i).pairwise_disjoint f) : (⋃ (i : ι') (H : i ∈ s), ↑(g i)).pairwise_disjoint f
theorem division_def {G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * b⁻¹
theorem ball_pi {β : Type v} {π : β → Type u_1} [fintype β] [Π (b : β), pseudo_metric_space (π b)] (x : Π (b : β), π b) {r : ℝ} (hr : 0 < r) : metric.ball x r = set.univ.pi (λ (b : β), metric.ball (x b) r)
theorem int.nat_abs_pow_two (x : ℤ) : ↑(x.nat_abs) ^ 2 = x ^ 2
theorem module.free.rank_tensor_product' (R : Type u) (M : Type v) [comm_ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] (N : Type v) [add_comm_group N] [module R N] [module.free R N] : module.rank R (tensor_product R M N) = module.rank R M * module.rank R N
theorem norm_add_sq_eq_norm_sq_add_norm_sq_real {F : Type u_3} [inner_product_space ℝ F] {x y : F} (h : has_inner.inner x y = 0) : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥
theorem same_ray.pos_smul_left {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} {r : R} (h : same_ray R x y) (hr : 0 < r) : same_ray R (r • x) y
theorem category_theory.limits.coprod_comparison_inv_natural {C : Type u} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) {A A' B B' : C} [category_theory.limits.has_binary_coproduct A B] [category_theory.limits.has_binary_coproduct A' B'] [category_theory.limits.has_binary_coproduct (F.obj A) (F.obj B)] [category_theory.limits.has_binary_coproduct (F.obj A') (F.obj B')] (f : A ⟶ A') (g : B ⟶ B') [category_theory.is_iso (category_theory.limits.coprod_comparison F A B)] [category_theory.is_iso (category_theory.limits.coprod_comparison F A' B')] : category_theory.inv (category_theory.limits.coprod_comparison F A B) ≫ category_theory.limits.coprod.map (F.map f) (F.map g) = F.map (category_theory.limits.coprod.map f g) ≫ category_theory.inv (category_theory.limits.coprod_comparison F A' B')
theorem category_theory.normal_mono_category.pullback_of_mono {C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_kernels C] [category_theory.normal_mono_category C] {X Y Z : C} (a : X ⟶ Z) (b : Y ⟶ Z) [category_theory.mono a] [category_theory.mono b] : category_theory.limits.has_limit (category_theory.limits.cospan a b)
theorem tendsto_of_le_liminf_of_limsup_le {α : Type u} {β : Type v} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {f : filter β} {u : β → α} {a : α} (hinf : a ≤ f.liminf u) (hsup : f.limsup u ≤ a) (h : filter.is_bounded_under has_le.le f u . "is_bounded_default") (h' : filter.is_bounded_under ge f u . "is_bounded_default") : filter.tendsto u f (nhds a)
theorem category_theory.limits.is_initial.hom_ext {C : Type u₁} [category_theory.category C] {X Y : C} (t : category_theory.limits.is_initial X) (f g : X ⟶ Y) : f = g
theorem nat_smul_eq_nsmul {M : Type u_5} [add_comm_monoid M] (h : module ℕ M) (n : ℕ) (x : M) : n • x = n • x
theorem star_convex.ord_connected {𝕜 : Type u_1} [linear_ordered_field 𝕜] {x : 𝕜} {s : set 𝕜} (hx : x ∈ s) : star_convex 𝕜 x s → s.ord_connected
theorem bornology.is_vonN_bounded.of_topological_space_le {𝕜 : Type u_1} {E : Type u_2} [semi_normed_ring 𝕜] [add_comm_group E] [module 𝕜 E] {t t' : topological_space E} (h : t ≤ t') {s : set E} (hs : bornology.is_vonN_bounded 𝕜 s) : bornology.is_vonN_bounded 𝕜 s
theorem isometry.dist_eq {α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {f : α → β} (hf : isometry f) (x y : α) : has_dist.dist (f x) (f y) = has_dist.dist x y
theorem continuous_linear_map.is_open_map {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] (f : E →L[𝕜] F) [complete_space F] [complete_space E] (surj : function.surjective ⇑f) : is_open_map ⇑f
theorem add_monoid_algebra.support_gen_of_gen' {R : Type u_1} {M : Type u_2} [comm_semiring R] [add_monoid M] {S : set (add_monoid_algebra R M)} (hS : algebra.adjoin R S = ⊤) : algebra.adjoin R (add_monoid_algebra.of' R M '' ⋃ (f : add_monoid_algebra R M) (H : f ∈ S), ↑(f.support)) = ⊤
theorem real.sin_pi_div_six  : real.sin (real.pi / 6) = 1 / 2
theorem category_theory.presieve.is_sheaf_for.functor_inclusion_comp_extend {C : Type u₁} [category_theory.category C] {X : C} {S : category_theory.sieve X} {P : Cᵒᵖ ⥤ Type v₁} (h : category_theory.presieve.is_sheaf_for P ⇑S) (f : S.functor ⟶ P) : S.functor_inclusion ≫ h.extend f = f
theorem generalized_continued_fraction.terminates_of_rat (q : ℚ) : (generalized_continued_fraction.of q).terminates
theorem matrix.det_eq_of_forall_row_eq_smul_add_pred {R : Type v} [comm_ring R] {n : ℕ} {A B : matrix (fin (n + 1)) (fin (n + 1)) R} (c : fin n → R) (A_zero : ∀ (j : fin (n + 1)), A 0 j = B 0 j) (A_succ : ∀ (i : fin n) (j : fin (n + 1)), A i.succ j = B i.succ j + c i * A (⇑fin.cast_succ i) j) : A.det = B.det
theorem ideal.ideal_prod_prime {R : Type u} {S : Type v} [ring R] [ring S] (I : ideal (R × S)) : I.is_prime ↔ (∃ (p : ideal R), p.is_prime ∧ I = p.prod ⊤) ∨ ∃ (p : ideal S), p.is_prime ∧ I = ⊤.prod p
theorem measure_theory.signed_measure.subset_positive_null_set {α : Type u_1} [measurable_space α] {s : measure_theory.signed_measure α} {u v w : set α} (hu : measurable_set u) (hv : measurable_set v) (hw : measurable_set w) (hsu : 0.restrict u ≤ measure_theory.vector_measure.restrict s u) (hw₁ : ⇑s w = 0) (hw₂ : w ⊆ u) (hwt : v ⊆ w) : ⇑s v = 0
theorem measure_theory.integral_divergence_prod_Icc_of_has_fderiv_within_at_off_countable_of_le {E : Type u} [normed_group E] [normed_space ℝ E] [complete_space E] (f g : ℝ × ℝ → E) (f' g' : ℝ × ℝ → (ℝ × ℝ →L[ℝ] E)) (a b : ℝ × ℝ) (hle : a ≤ b) (s : set (ℝ × ℝ)) (hs : s.countable) (Hcf : continuous_on f (set.Icc a b)) (Hcg : continuous_on g (set.Icc a b)) (Hdf : ∀ (x : ℝ × ℝ), x ∈ set.Ioo a.fst b.fst ×ˢ set.Ioo a.snd b.snd  s → has_fderiv_at f (f' x) x) (Hdg : ∀ (x : ℝ × ℝ), x ∈ set.Ioo a.fst b.fst ×ˢ set.Ioo a.snd b.snd  s → has_fderiv_at g (g' x) x) (Hi : measure_theory.integrable_on (λ (x : ℝ × ℝ), ⇑(f' x) (1, 0) + ⇑(g' x) (0, 1)) (set.Icc a b) measure_theory.measure_space.volume) : ∫ (x : ℝ × ℝ) in set.Icc a b, ⇑(f' x) (1, 0) + ⇑(g' x) (0, 1) = (((∫ (x : ℝ) in a.fst..b.fst, g (x, b.snd)) - ∫ (x : ℝ) in a.fst..b.fst, g (x, a.snd)) + ∫ (y : ℝ) in a.snd..b.snd, f (b.fst, y)) - ∫ (y : ℝ) in a.snd..b.snd, f (a.fst, y)
theorem cont_diff_at.prod_map' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : with_top ℕ} {E' : Type u_6} [normed_group E'] [normed_space 𝕜 E'] {F' : Type u_7} [normed_group F'] [normed_space 𝕜 F'] {f : E → F} {g : E' → F'} {p : E × E'} (hf : cont_diff_at 𝕜 n f p.fst) (hg : cont_diff_at 𝕜 n g p.snd) : cont_diff_at 𝕜 n (prod.map f g) p
theorem emetric.controlled_of_uniform_embedding {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} : uniform_embedding f → ((∀ (ε : ennreal), ε > 0 → (∃ (δ : ennreal) (H : δ > 0), ∀ {a b : α}, has_edist.edist a b < δ → has_edist.edist (f a) (f b) < ε)) ∧ ∀ (δ : ennreal), δ > 0 → (∃ (ε : ennreal) (H : ε > 0), ∀ {a b : α}, has_edist.edist (f a) (f b) < ε → has_edist.edist a b < δ))
theorem convex.add_smul_mem_interior' {E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) {x y : E} (hx : x ∈ closure s) (hy : x + y ∈ interior s) {t : 𝕜} (ht : t ∈ set.Ioc 0 1) : x + t • y ∈ interior s
theorem set.countable_iff_exists_inj_on {α : Type u} {s : set α} : s.countable ↔ ∃ (f : α → ℕ), set.inj_on f s
theorem continuous.measurable {α : Type u_1} {γ : Type u_3} [topological_space α] [measurable_space α] [opens_measurable_space α] [topological_space γ] [measurable_space γ] [borel_space γ] {f : α → γ} (hf : continuous f) : measurable f
theorem is_primitive_root.pow {M : Type u_1} [comm_monoid M] {ζ : M} {n a b : ℕ} (hn : 0 < n) (h : is_primitive_root ζ n) (hprod : n = a * b) : is_primitive_root (ζ ^ a) b
theorem is_primitive_root.nth_roots_one_eq_bUnion_primitive_roots {R : Type u_5} [comm_ring R] [is_domain R] {ζ : R} {n : ℕ} (h : is_primitive_root ζ n) : polynomial.nth_roots_finset n R = n.divisors.bUnion (λ (i : ℕ), primitive_roots i R)
theorem algebraic_topology.dold_kan.hσ'_naturality {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (q n m : ℕ) (hnm : algebraic_topology.dold_kan.c.rel m n) {X Y : category_theory.simplicial_object C} (f : X ⟶ Y) : f.app (opposite.op (simplex_category.mk n)) ≫ algebraic_topology.dold_kan.hσ' q n m hnm = algebraic_topology.dold_kan.hσ' q n m hnm ≫ f.app (opposite.op (simplex_category.mk m))
theorem algebra.is_algebraic.cardinal_mk_le_max (R L : Type u) [comm_ring R] [comm_ring L] [is_domain L] [algebra R L] [no_zero_smul_divisors R L] (halg : algebra.is_algebraic R L) : cardinal.mk L ≤ linear_order.max (cardinal.mk R) cardinal.aleph_0
theorem function.maps_to_fixed_pts_comp {α : Type u} {β : Type v} (f : α → β) (g : β → α) : set.maps_to f (function.fixed_points (g ∘ f)) (function.fixed_points (f ∘ g))
theorem category_theory.limits.has_binary_biproducts_of_finite_biproducts (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C] : category_theory.limits.has_binary_biproducts C
theorem uniform_space.completion.uniformity_dist' {α : Type u} [pseudo_metric_space α] : uniformity (uniform_space.completion α) = ⨅ (ε : {ε // 0 < ε}), filter.principal {p : uniform_space.completion α × uniform_space.completion α | has_dist.dist p.fst p.snd < ε.val}
theorem strict_mono_on.continuous_at_of_image_mem_nhds {α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_on f s) (hs : s ∈ nhds a) (hfs : f '' s ∈ nhds (f a)) : continuous_at f a
theorem euclidean_geometry.reflection_mem_of_le_of_mem {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s₁ s₂ : affine_subspace ℝ P} [nonempty ↥s₁] [complete_space ↥(s₁.direction)] (hle : s₁ ≤ s₂) {p : P} (hp : p ∈ s₂) : ⇑(euclidean_geometry.reflection s₁) p ∈ s₂
theorem vitali_family.ae_tendsto_div {α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {ρ : measure_theory.measure α} [measure_theory.is_locally_finite_measure ρ] (hρ : ρ.absolutely_continuous μ) : ∀ᵐ (x : α) ∂μ, ∃ (c : ennreal), filter.tendsto (λ (a : set α), ⇑ρ a / ⇑μ a) (v.filter_at x) (nhds c)
theorem add_lt_of_lt_neg_add {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : b < -a + c → a + b < c
theorem cont_diff.continuous_fderiv_apply {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {n : with_top ℕ} (h : cont_diff 𝕜 n f) (hn : 1 ≤ n) : continuous (λ (p : E × E), ⇑(fderiv 𝕜 f p.fst) p.snd)
theorem continuous_uncurry_of_discrete_topology {α : Type u} {β : Type v} {γ : Type u_1} [topological_space α] [topological_space β] [topological_space γ] [discrete_topology α] {f : α → β → γ} (hf : ∀ (a : α), continuous (f a)) : continuous (function.uncurry f)
theorem fixed_points_submonoid_supr (M : Type u_1) (α : Type u_2) [monoid M] [mul_action M α] {ι : Sort u_3} {P : ι → submonoid M} : mul_action.fixed_points ↥(supr P) α = ⋂ (i : ι), mul_action.fixed_points ↥(P i) α
theorem generalized_continued_fraction.squash_seq_nth_of_lt {K : Type u_1} {n : ℕ} {s : seq (generalized_continued_fraction.pair K)} [division_ring K] {m : ℕ} (m_lt_n : m < n) : (generalized_continued_fraction.squash_seq s n).nth m = s.nth m
theorem continuous_at_right_of_monotone_on_of_image_mem_nhds_within {α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : monotone_on f s) (hs : s ∈ nhds_within a (set.Ici a)) (hfs : f '' s ∈ nhds_within (f a) (set.Ici (f a))) : continuous_within_at f (set.Ici a) a
theorem has_fpower_series_at.eq_formal_multilinear_series {𝕜 : Type u_1} {E : Type u_2} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] {p₁ p₂ : formal_multilinear_series 𝕜 𝕜 E} {f : 𝕜 → E} {x : 𝕜} (h₁ : has_fpower_series_at f p₁ x) (h₂ : has_fpower_series_at f p₂ x) : p₁ = p₂
theorem antivary.sum_smul_lt_sum_comp_perm_smul_iff {ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {σ : equiv.perm ι} {f : ι → α} {g : ι → β} [fintype ι] (hfg : antivary f g) : finset.univ.sum (λ (i : ι), f i • g i) < finset.univ.sum (λ (i : ι), f (⇑σ i) • g i) ↔ ¬antivary (f ∘ ⇑σ) g
theorem ADE_inequality.classification (p q r : ℕ+) : 1 < ADE_inequality.sum_inv {p, q, r} ↔ ADE_inequality.admissible {p, q, r}
theorem measure_theory.measure.prod_prod {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] (s : set α) (t : set β) : ⇑(μ.prod ν) (s ×ˢ t) = ⇑μ s * ⇑ν t
theorem monotone.tendsto_at_bot_at_bot {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] {f : α → β} (hf : monotone f) (h : ∀ (b : β), ∃ (a : α), f a ≤ b) : filter.tendsto f filter.at_bot filter.at_bot
theorem cont_diff_at.snd' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {n : with_top ℕ} {f : F → G} {x : E} {y : F} (hf : cont_diff_at 𝕜 n f y) : cont_diff_at 𝕜 n (λ (x : E × F), f x.snd) (x, y)
theorem orthonormal.oangle_rotation_right {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : real.angle) : hb.oangle x (⇑(hb.rotation θ) y) = hb.oangle x y + θ
theorem category_theory.limits.epi_of_is_colimit_parallel_family {J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J → (X ⟶ Y)} [nonempty J] {c : category_theory.limits.cocone (category_theory.limits.parallel_family f)} (i : category_theory.limits.is_colimit c) : category_theory.epi (c.ι.app category_theory.limits.walking_parallel_family.one)
theorem affine.simplex.finrank_direction_altitude {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P (n + 1)) (i : fin (n + 2)) : finite_dimensional.finrank ℝ ↥((s.altitude i).direction) = 1
theorem pgame.mul_comm_equiv (x y : pgame) : (x * y).equiv (y * x)
theorem continuous_on.surj_on_of_tendsto {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {δ : Type u_1} [linear_order δ] [topological_space δ] [order_closed_topology δ] {f : α → δ} {s : set α} [s.ord_connected] (hs : s.nonempty) (hf : continuous_on f s) (hbot : filter.tendsto (λ (x : ↥s), f ↑x) filter.at_bot filter.at_bot) (htop : filter.tendsto (λ (x : ↥s), f ↑x) filter.at_top filter.at_top) : set.surj_on f s set.univ
theorem cont_mdiff_coe_sphere {E : Type u_1} [inner_product_space ℝ E] {n : ℕ} [fact (finite_dimensional.finrank ℝ E = n + 1)] : cont_mdiff (model_with_corners_self ℝ (euclidean_space ℝ (fin n))) (model_with_corners_self ℝ E) ⊤ coe
theorem real.has_strict_fderiv_at_rpow_of_pos (p : ℝ × ℝ) (hp : 0 < p.fst) : has_strict_fderiv_at (λ (x : ℝ × ℝ), x.fst ^ x.snd) ((p.snd * p.fst ^ (p.snd - 1)) • continuous_linear_map.fst ℝ ℝ ℝ + (p.fst ^ p.snd * real.log p.fst) • continuous_linear_map.snd ℝ ℝ ℝ) p
theorem filter.tendsto_mul_left_cobounded {α : Type u_1} [normed_division_ring α] {a : α} (ha : a ≠ 0) : filter.tendsto (has_mul.mul a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)
theorem measure_theory.measure.pi_eq {ι : Type u_1} {α : ι → Type u_3} [fintype ι] [Π (i : ι), measurable_space (α i)] {μ : Π (i : ι), measure_theory.measure (α i)} [∀ (i : ι), measure_theory.sigma_finite (μ i)] {μ' : measure_theory.measure (Π (i : ι), α i)} (h : ∀ (s : Π (i : ι), set (α i)), (∀ (i : ι), measurable_set (s i)) → ⇑μ' (set.univ.pi s) = finset.univ.prod (λ (i : ι), ⇑(μ i) (s i))) : measure_theory.measure.pi μ = μ'
theorem mv_polynomial.exists_finset_rename₂ {σ : Type u_1} {R : Type u_4} [comm_semiring R] (p₁ p₂ : mv_polynomial σ R) : ∃ (s : finset σ) (q₁ q₂ : mv_polynomial ↥s R), p₁ = ⇑(mv_polynomial.rename coe) q₁ ∧ p₂ = ⇑(mv_polynomial.rename coe) q₂
theorem ordered_comm_group.mul_lt_mul_left' {α : Type u_1} [has_mul α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {b c : α} (bc : b < c) (a : α) : a * b < a * c
theorem orthonormal.oangle_sub_right {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle x z - hb.oangle y z = hb.oangle x y
theorem is_integral_closure.is_fraction_ring_of_algebraic (A : Type u_4) [comm_ring A] [is_domain A] {L : Type u_6} [field L] [algebra A L] (C : Type u_7) [comm_ring C] [is_domain C] [algebra C L] [is_integral_closure C A L] [algebra A C] [is_scalar_tower A C L] (alg : algebra.is_algebraic A L) (inj : ∀ (x : A), ⇑(algebra_map A L) x = 0 → x = 0) : is_fraction_ring C L
theorem le_refl {α : Type u} [preorder α] (a : α) : a ≤ a
theorem real_inner_le_norm {F : Type u_3} [inner_product_space ℝ F] (x y : F) : has_inner.inner x y ≤ ∥x∥ * ∥y∥
theorem isometric.map_midpoint {E : Type u_1} {PE : Type u_2} [normed_group E] [normed_space ℝ E] [metric_space PE] [normed_add_torsor E PE] {F : Type u_3} {PF : Type u_4} [normed_group F] [normed_space ℝ F] [metric_space PF] [normed_add_torsor F PF] (f : PE ≃ᵢ PF) (x y : PE) : ⇑f (midpoint ℝ x y) = midpoint ℝ (⇑f x) (⇑f y)
theorem measure_theory.smul_invariant_measure_tfae (G : Type u_1) {α : Type u_3} {m : measurable_space α} [group G] [mul_action G α] [measurable_space G] [has_measurable_smul G α] (μ : measure_theory.measure α) : [measure_theory.smul_invariant_measure G α μ, ∀ (c : G) (s : set α), measurable_set s → ⇑μ (has_scalar.smul c ⁻¹' s) = ⇑μ s, ∀ (c : G) (s : set α), measurable_set s → ⇑μ (c • s) = ⇑μ s, ∀ (c : G) (s : set α), ⇑μ (has_scalar.smul c ⁻¹' s) = ⇑μ s, ∀ (c : G) (s : set α), ⇑μ (c • s) = ⇑μ s, ∀ (c : G), measure_theory.measure.map (has_scalar.smul c) μ = μ, ∀ (c : G), measure_theory.measure_preserving (has_scalar.smul c) μ μ].tfae
theorem inv_nat_cast_smul_eq {E : Type u_1} (R : Type u_2) (S : Type u_3) [add_comm_group E] [division_ring R] [division_ring S] [module R E] [module S E] (n : ℕ) (x : E) : (↑n)⁻¹ • x = (↑n)⁻¹ • x
theorem mul_lt_one {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1
theorem measure_theory.measure.ext_of_Ioc_finite {α : Type u_1} [topological_space α] {m : measurable_space α} [topological_space.second_countable_topology α] [linear_order α] [order_topology α] [borel_space α] (μ ν : measure_theory.measure α) [measure_theory.is_finite_measure μ] (hμν : ⇑μ set.univ = ⇑ν set.univ) (h : ∀ ⦃a b : α⦄, a < b → ⇑μ (set.Ioc a b) = ⇑ν (set.Ioc a b)) : μ = ν
theorem group_algebra.mul_average_left (k : Type u_1) (G : Type u_2) [comm_semiring k] [group G] [fintype G] [invertible ↑(fintype.card G)] (g : G) : finsupp.single g 1 * group_algebra.average k G = group_algebra.average k G
theorem category_theory.simple_iff_subobject_is_simple_order {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) : category_theory.simple X ↔ is_simple_order (category_theory.subobject X)
theorem antivary.sum_smul_le_sum_smul_comp_perm {ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {σ : equiv.perm ι} {f : ι → α} {g : ι → β} [fintype ι] (hfg : antivary f g) : finset.univ.sum (λ (i : ι), f i • g i) ≤ finset.univ.sum (λ (i : ι), f i • g (⇑σ i))
theorem measure_theory.le_lintegral_add {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} (f g : α → ennreal) : ∫⁻ (a : α), f a ∂μ + ∫⁻ (a : α), g a ∂μ ≤ ∫⁻ (a : α), f a + g a ∂μ
theorem nnnorm_pow_le' {α : Type u_1} [semi_normed_ring α] (a : α) {n : ℕ} : 0 < n → ∥a ^ n∥₊ ≤ ∥a∥₊ ^ n
theorem category_theory.limits.biprod.add_eq_lift_id_desc {C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} (f g : X ⟶ Y) [category_theory.limits.has_binary_biproduct X X] : f + g = category_theory.limits.biprod.lift (𝟙 X) (𝟙 X) ≫ category_theory.limits.biprod.desc f g
theorem setoid.injective_iff_ker_bot {α : Type u_1} {β : Type u_2} (f : α → β) : function.injective f ↔ setoid.ker f = ⊥
theorem finprod_mem_div_distrib {α : Type u_1} {G : Type u_4} {s : set α} [division_comm_monoid G] (f g : α → G) (hs : s.finite) : finprod (λ (i : α), finprod (λ (H : i ∈ s), f i / g i)) = finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) / finprod (λ (i : α), finprod (λ (H : i ∈ s), g i))
theorem edist_lt_top {α : Type u_1} [pseudo_metric_space α] (x y : α) : has_edist.edist x y < ⊤
theorem polynomial.C_mem_lifts {R : Type u} [semiring R] {S : Type v} [semiring S] (f : R →+* S) (r : R) : ⇑polynomial.C (⇑f r) ∈ polynomial.lifts f
theorem set.monotone_image {α : Type u_1} {β : Type u_2} {f : α → β} : monotone (set.image f)
theorem is_alg_closed.splits_codomain {k : Type u_1} {K : Type u_2} [field k] [is_alg_closed k] [field K] {f : K →+* k} (p : polynomial K) : polynomial.splits f p
theorem finset.sup_indep.independent_of_univ {α : Type u_1} {ι : Type u_3} [complete_lattice α] [fintype ι] {f : ι → α} : finset.univ.sup_indep f → complete_lattice.independent f
theorem monovary_on.sum_smul_comp_perm_lt_sum_smul_iff {ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {s : finset ι} {σ : equiv.perm ι} {f : ι → α} {g : ι → β} (hfg : monovary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i • g (⇑σ i)) < s.sum (λ (i : ι), f i • g i) ↔ ¬monovary_on f (g ∘ ⇑σ) ↑s
theorem measure_theory.measure.div_mem_nhds_one_of_haar_pos {G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] (μ : measure_theory.measure G) [μ.is_haar_measure] [locally_compact_space G] (E : set G) (hE : measurable_set E) (hEpos : 0 < ⇑μ E) : E / E ∈ nhds 1
theorem list.is_prefix.reverse {α : Type u_1} {l₁ l₂ : list α} : l₁ <+: l₂ → l₁.reverse <:+ l₂.reverse
theorem real.tendsto_exp_neg_at_top_nhds_0  : filter.tendsto (λ (x : ℝ), real.exp (-x)) filter.at_top (nhds 0)
theorem orthonormal.inner_left_finsupp {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : orthonormal 𝕜 v) (l : ι →₀ 𝕜) (i : ι) : has_inner.inner (⇑(finsupp.total ι E 𝕜 v) l) (v i) = ⇑(star_ring_end 𝕜) (⇑l i)
theorem has_fpower_series_on_ball.uniform_geometric_approx' {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] {f : E → F} {p : formal_multilinear_series 𝕜 E F} {x : E} {r : ennreal} {r' : nnreal} (hf : has_fpower_series_on_ball f p x r) (h : ↑r' < r) : ∃ (a : ℝ) (H : a ∈ set.Ioo 0 1) (C : ℝ) (H : C > 0), ∀ (y : E), y ∈ metric.ball 0 ↑r' → ∀ (n : ℕ), ∥f (x + y) - p.partial_sum n y∥ ≤ C * (a * (∥y∥ / ↑r')) ^ n
theorem units.is_open_map_coe {R : Type u_1} [normed_ring R] [complete_space R] : is_open_map coe
theorem has_strict_deriv_at_exp {𝕂 : Type u_1} [is_R_or_C 𝕂] {x : 𝕂} : has_strict_deriv_at (exp 𝕂) (exp 𝕂 x) x
theorem nat.factors_unique {n : ℕ} {l : list ℕ} (h₁ : l.prod = n) (h₂ : ∀ (p : ℕ), p ∈ l → nat.prime p) : l ~ n.factors
theorem eq.ge {α : Type u} [preorder α] {x y : α} (h : x = y) : y ≤ x
theorem not_countable_complex  : ¬set.univ.countable
theorem cont_diff.differentiable {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {n : with_top ℕ} (h : cont_diff 𝕜 n f) (hn : 1 ≤ n) : differentiable 𝕜 f
theorem semiconj_by.mul_left {S : Type u} [semigroup S] {a b x y z : S} (ha : semiconj_by a y z) (hb : semiconj_by b x y) : semiconj_by (a * b) x z
theorem measure_theory.measure_set_of_frequently_eq_zero {α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {p : ℕ → α → Prop} (hp : ∑' (i : ℕ), ⇑μ {x : α | p i x} ≠ ⊤) : ⇑μ {x : α | ∃ᶠ (n : ℕ) in filter.at_top, p n x} = 0
theorem bornology.is_vonN_bounded.union {𝕜 : Type u_1} {E : Type u_2} [semi_normed_ring 𝕜] [has_scalar 𝕜 E] [has_zero E] [topological_space E] {s₁ s₂ : set E} (hs₁ : bornology.is_vonN_bounded 𝕜 s₁) (hs₂ : bornology.is_vonN_bounded 𝕜 s₂) : bornology.is_vonN_bounded 𝕜 (s₁ ∪ s₂)
theorem complex.eq_on_closure_of_eq_on_frontier {E : Type u} [normed_group E] [normed_space ℂ E] {F : Type v} [normed_group F] [normed_space ℂ F] [nontrivial E] {f g : E → F} {U : set E} (hU : metric.bounded U) (hf : diff_cont_on_cl ℂ f U) (hg : diff_cont_on_cl ℂ g U) (hfg : set.eq_on f g (frontier U)) : set.eq_on f g (closure U)
theorem polynomial.X_pow_mul_C {R : Type u} [semiring R] (r : R) (n : ℕ) : polynomial.X ^ n * ⇑polynomial.C r = ⇑polynomial.C r * polynomial.X ^ n
theorem balanced.absorbs_self {𝕜 : Type u_1} {E : Type u_3} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] {A : set E} (hA : balanced 𝕜 A) : absorbs 𝕜 A A
theorem bilin_form.restrict_orthogonal_span_singleton_nondegenerate {V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] (B : bilin_form K V) (b₁ : B.nondegenerate) (b₂ : B.is_refl) {x : V} (hx : ¬B.is_ortho x x) : (B.restrict (B.orthogonal (submodule.span K {x}))).nondegenerate
theorem function.bijective.exists_unique {α : Sort u_1} {β : Sort u_2} {f : α → β} (hf : function.bijective f) (b : β) : ∃! (a : α), f a = b
theorem eq.le {α : Type u} [preorder α] {a b : α} : a = b → a ≤ b
theorem euclidean_geometry.angle_eq_angle_of_dist_eq {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : has_dist.dist p1 p2 = has_dist.dist p1 p3) : euclidean_geometry.angle p1 p2 p3 = euclidean_geometry.angle p1 p3 p2
theorem pythagorean_triple.mul {x y z : ℤ} (h : pythagorean_triple x y z) (k : ℤ) : pythagorean_triple (k * x) (k * y) (k * z)
theorem le_csupr {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {f : ι → α} (H : bdd_above (set.range f)) (c : ι) : f c ≤ supr f
theorem category_theory.locally_discrete.eq_of_hom {C : Type u} [category_theory.category_struct C] {X Y : category_theory.locally_discrete C} {f g : X ⟶ Y} (η : f ⟶ g) : f = g
theorem has_fderiv_at_boundary_of_tendsto_fderiv {E : Type u_1} [normed_group E] [normed_space ℝ E] {F : Type u_2} [normed_group F] [normed_space ℝ F] {f : E → F} {s : set E} {x : E} {f' : E →L[ℝ] F} (f_diff : differentiable_on ℝ f s) (s_conv : convex ℝ s) (s_open : is_open s) (f_cont : ∀ (y : E), y ∈ closure s → continuous_within_at f s y) (h : filter.tendsto (λ (y : E), fderiv ℝ f y) (nhds_within x s) (nhds f')) : has_fderiv_within_at f f' (closure s) x
theorem affine_independent.exists_unique_dist_eq {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {ι : Type u_3} [hne : nonempty ι] [fintype ι] {p : ι → P} (ha : affine_independent ℝ p) : ∃! (cccr : P × ℝ), cccr.fst ∈ affine_span ℝ (set.range p) ∧ ∀ (i : ι), has_dist.dist (p i) cccr.fst = cccr.snd
theorem is_max.succ_eq {α : Type u_1} [partial_order α] [succ_order α] {a : α} : is_max a → order.succ a = a
theorem affine_independent_iff_linear_independent_vsub (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} (p : ι → P) (i1 : ι) : affine_independent k p ↔ linear_independent k (λ (i : {x // x ≠ i1}), p ↑i -ᵥ p i1)
theorem has_sum_of_subseq_of_summable {ι : Type u_1} {α : Type u_2} {E : Type u_3} [semi_normed_group E] {f : ι → E} (hf : summable (λ (a : ι), ∥f a∥)) {s : α → finset ι} {p : filter α} [p.ne_bot] (hs : filter.tendsto s p filter.at_top) {a : E} (ha : filter.tendsto (λ (b : α), (s b).sum (λ (i : ι), f i)) p (nhds a)) : has_sum f a
theorem finsupp.congr_fun {α : Type u_1} {M : Type u_5} [has_zero M] {f g : α →₀ M} (h : f = g) (a : α) : ⇑f a = ⇑g a
theorem tendsto_uniformly.tendsto_comp {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {x : α} {p : filter ι} {g : ι → α} [topological_space α] (h : tendsto_uniformly F f p) (hf : continuous_at f x) (hg : filter.tendsto g p (nhds x)) : filter.tendsto (λ (n : ι), F n (g n)) p (nhds (f x))
theorem category_theory.nat_trans_from_is_connected {J : Type u₁} [category_theory.category J] {C : Type u₂} [category_theory.category C] [category_theory.is_preconnected J] {X Y : C} (α : (category_theory.functor.const J).obj X ⟶ (category_theory.functor.const J).obj Y) (j j' : J) : α.app j = α.app j'
theorem ordinal.infinite_pigeonhole_card {β α : Type u} (f : β → α) (θ : cardinal) (hθ : θ ≤ cardinal.mk β) (h₁ : cardinal.aleph_0 ≤ θ) (h₂ : cardinal.mk α < θ.ord.cof) : ∃ (a : α), θ ≤ cardinal.mk ↥(f ⁻¹' {a})
theorem polynomial.gal.restrict_prod_injective {F : Type u_1} [field F] (p q : polynomial F) : function.injective ⇑(polynomial.gal.restrict_prod p q)
theorem orthogonal_family.is_internal_iff {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} [decidable_eq ι] [finite_dimensional 𝕜 E] {V : ι → submodule 𝕜 E} (hV : orthogonal_family 𝕜 (λ (i : ι), (V i).subtypeₗᵢ)) : direct_sum.is_internal V ↔ (supr V)ᗮ = ⊥
theorem basis.exists_op_nnnorm_le {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {E : Type v} [normed_group E] [normed_space 𝕜 E] {F : Type w} [normed_group F] [normed_space 𝕜 F] [complete_space 𝕜] {ι : Type u_1} [fintype ι] (v : basis ι 𝕜 E) : ∃ (C : nnreal) (H : C > 0), ∀ {u : E →L[𝕜] F} (M : nnreal), (∀ (i : ι), ∥⇑u (⇑v i)∥₊ ≤ M) → ∥u∥₊ ≤ C * M
theorem composition_series.exists_top_eq_snoc_equivalant {X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) (x : X) (hm : jordan_holder_lattice.is_maximal x s.top) (hb : s.bot ≤ x) : ∃ (t : composition_series X), t.bot = s.bot ∧ t.length + 1 = s.length ∧ ∃ (htx : t.top = x), s.equivalent (t.snoc s.top _)
theorem finite_dimensional.finrank_mul_finrank (F : Type u) (K : Type v) (A : Type w) [field F] [field K] [add_comm_group A] [algebra F K] [module K A] [module F A] [is_scalar_tower F K A] [finite_dimensional F K] : finite_dimensional.finrank F K * finite_dimensional.finrank K A = finite_dimensional.finrank F A
theorem has_fderiv_at_exp_zero_of_radius_pos {𝕂 : Type u_1} {𝔸 : Type u_2} [nondiscrete_normed_field 𝕂] [normed_ring 𝔸] [normed_algebra 𝕂 𝔸] [complete_space 𝔸] (h : 0 < (exp_series 𝕂 𝔸).radius) : has_fderiv_at (exp 𝕂) 1 0
theorem generalized_continued_fraction.le_of_succ_nth_denom {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {b : K} (nth_part_denom_eq : (generalized_continued_fraction.of v).partial_denominators.nth n = option.some b) : b * (generalized_continued_fraction.of v).denominators n ≤ (generalized_continued_fraction.of v).denominators (n + 1)
theorem sylow.prime_dvd_card_quotient_normalizer {G : Type u} [group G] [fintype G] {p n : ℕ} [hp : fact (nat.prime p)] (hdvd : p ^ (n + 1) ∣ fintype.card G) {H : subgroup G} (hH : fintype.card ↥H = p ^ n) : p ∣ fintype.card (↥(H.normalizer) ⧸ subgroup.comap H.normalizer.subtype H)
theorem projectivization.map_injective {K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] {L : Type u_3} {W : Type u_4} [field L] [add_comm_group W] [module L W] {σ : K →+* L} {τ : L →+* K} [ring_hom_inv_pair σ τ] (f : V →ₛₗ[σ] W) (hf : function.injective ⇑f) : function.injective (projectivization.map f hf)
theorem finite_field.is_square_iff {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) {a : F} (ha : a ≠ 0) : is_square a ↔ a ^ (fintype.card F / 2) = 1
theorem polynomial.exists_approx_polynomial {Fq : Type u_1} [fintype Fq] [field Fq] {b : polynomial Fq} (hb : b ≠ 0) {ε : ℝ} (hε : 0 < ε) (A : fin (fintype.card Fq ^ ⌈-real.log ε / real.log ↑(fintype.card Fq)⌉₊).succ → polynomial Fq) : ∃ (i₀ i₁ : fin (fintype.card Fq ^ ⌈-real.log ε / real.log ↑(fintype.card Fq)⌉₊).succ), i₀ ≠ i₁ ∧ ↑(⇑polynomial.card_pow_degree (A i₁ % b - A i₀ % b)) < ⇑polynomial.card_pow_degree b • ε
theorem measure_theory.measure.ext_of_generate_from_of_Union {α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} (C : set (set α)) (B : ℕ → set α) (hA : m0 = measurable_space.generate_from C) (hC : is_pi_system C) (h1B : (⋃ (i : ℕ), B i) = set.univ) (h2B : ∀ (i : ℕ), B i ∈ C) (hμB : ∀ (i : ℕ), ⇑μ (B i) ≠ ⊤) (h_eq : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s) : μ = ν
theorem finset.centroid_weights_eq_const (k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) : finset.centroid_weights k s = function.const ι (↑(s.card))⁻¹
theorem simplex_category.len_le_of_mono {x y : simplex_category} {f : x ⟶ y} : category_theory.mono f → x.len ≤ y.len
theorem ideal.comp_quotient_map_eq_of_comp_eq {R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] {R' : Type u_3} {S' : Type u_4} [comm_ring R'] [comm_ring S'] {f : R →+* S} {f' : R' →+* S'} {g : R →+* R'} {g' : S →+* S'} (hfg : f'.comp g = g'.comp f) (I : ideal S') : (I.quotient_map g' le_rfl).comp ((ideal.comap g' I).quotient_map f le_rfl) = (I.quotient_map f' le_rfl).comp ((ideal.comap f' I).quotient_map g _)
theorem nat.pred_one_add (n : ℕ) : (1 + n).pred = n
theorem pi.is_pwo {σ : Type u_1} {α : σ → Type u_2} [Π (s : σ), linear_order (α s)] [∀ (s : σ), is_well_order (α s) has_lt.lt] [fintype σ] (S : set (Π (s : σ), α s)) : S.is_pwo
theorem is_preconnected.Union_of_chain {α : Type u} {β : Type v} [topological_space α] [linear_order β] [succ_order β] [is_succ_archimedean β] {s : β → set α} (H : ∀ (n : β), is_preconnected (s n)) (K : ∀ (n : β), (s n ∩ s (order.succ n)).nonempty) : is_preconnected (⋃ (n : β), s n)
theorem witt_polynomial_zmod_self (p n : ℕ) : witt_polynomial p (zmod (p ^ (n + 1))) (n + 1) = ⇑(mv_polynomial.expand p) (witt_polynomial p (zmod (p ^ (n + 1))) n)
theorem cauchy_seq_iff_le_tendsto_0 {α : Type u} [pseudo_metric_space α] {s : ℕ → α} : cauchy_seq s ↔ ∃ (b : ℕ → ℝ), (∀ (n : ℕ), 0 ≤ b n) ∧ (∀ (n m N : ℕ), N ≤ n → N ≤ m → has_dist.dist (s n) (s m) ≤ b N) ∧ filter.tendsto b filter.at_top (nhds 0)
theorem Mon.filtered_colimits.colimit_mul_aux_eq_of_rel_right {J : Type v} [category_theory.small_category J] (F : J ⥤ Mon) [category_theory.is_filtered J] {x y y' : Σ (j : J), ↥(F.obj j)} (hyy' : category_theory.limits.types.filtered_colimit.rel (F ⋙ category_theory.forget Mon) y y') : Mon.filtered_colimits.colimit_mul_aux F x y = Mon.filtered_colimits.colimit_mul_aux F x y'
theorem metric.compact_iff_closed_bounded {α : Type u} [pseudo_metric_space α] {s : set α} [t2_space α] [proper_space α] : is_compact s ↔ is_closed s ∧ metric.bounded s
theorem complex.has_deriv_at_sin (x : ℂ) : has_deriv_at complex.sin (complex.cos x) x
theorem metric.exists_closed_ball_inter_eq_singleton_of_discrete {α : Type u} [pseudo_metric_space α] {s : set α} [discrete_topology ↥s] {x : α} (hx : x ∈ s) : ∃ (ε : ℝ) (H : ε > 0), metric.closed_ball x ε ∩ s = {x}
theorem complex.continuous_at_cpow_of_re_pos {p : ℂ × ℂ} (h₁ : 0 ≤ p.fst.re ∨ p.fst.im ≠ 0) (h₂ : 0 < p.snd.re) : continuous_at (λ (x : ℂ × ℂ), x.fst ^ x.snd) p
theorem char.quadratic_char_neg_one {F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F ≠ 2) : char.quadratic_char F (-1) = ⇑zmod.χ₄ ↑(fintype.card F)
theorem fin.cons_update {n : ℕ} {α : fin (n + 1) → Type u} (x : α 0) (p : Π (i : fin n), α i.succ) (i : fin n) (y : α i.succ) : fin.cons x (function.update p i y) = function.update (fin.cons x p) i.succ y
theorem setoid.Sup_def {α : Type u_1} {s : set (setoid α)} : has_Sup.Sup s = eqv_gen.setoid (has_Sup.Sup (setoid.rel '' s))
theorem category_theory.is_filtered.cocone_nonempty {C : Type u} [category_theory.category C] [category_theory.is_filtered C] {J : Type v} [category_theory.small_category J] [category_theory.fin_category J] (F : J ⥤ C) : nonempty (category_theory.limits.cocone F)
theorem category_theory.abelian.pseudoelement.pseudo_zero_iff {C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (a : category_theory.over P) : ↑a = 0 ↔ a.hom = 0
theorem ideal.is_prime_map_C_of_is_prime {R : Type u} [comm_ring R] {P : ideal R} (H : P.is_prime) : (ideal.map polynomial.C P).is_prime
theorem emetric.cauchy_iff {α : Type u} [pseudo_emetric_space α] {f : filter α} : cauchy f ↔ f ≠ ⊥ ∧ ∀ (ε : ennreal), ε > 0 → (∃ (t : set α) (H : t ∈ f), ∀ (x : α), x ∈ t → ∀ (y : α), y ∈ t → has_edist.edist x y < ε)
theorem measure_theory.measure_preimage_add {G : Type u_1} [measurable_space G] [add_group G] [has_measurable_add G] (μ : measure_theory.measure G) [μ.is_add_left_invariant] (g : G) (A : set G) : ⇑μ ((λ (h : G), g + h) ⁻¹' A) = ⇑μ A
theorem set.seq_of_forall_finite_exists {γ : Type u_1} {P : γ → set γ → Prop} (h : ∀ (t : set γ), t.finite → (∃ (c : γ), P c t)) : ∃ (u : ℕ → γ), ∀ (n : ℕ), P (u n) (u '' set.Iio n)
theorem is_add_group_hom.sub {α : Type u_1} {β : Type u_2} [add_group α] [add_comm_group β] {f g : α → β} (hf : is_add_group_hom f) (hg : is_add_group_hom g) : is_add_group_hom (λ (a : α), f a - g a)
theorem and_or_distrib_left {a b c : Prop} : a ∧ (b ∨ c) ↔ a ∧ b ∨ a ∧ c
theorem complex.circle_integral_div_sub_of_differentiable_on_off_countable {R : ℝ} {c w : ℂ} {s : set ℂ} (hs : s.countable) (hw : w ∈ metric.ball c R) {f : ℂ → ℂ} (hc : continuous_on f (metric.closed_ball c R)) (hd : ∀ (z : ℂ), z ∈ metric.ball c R  s → differentiable_at ℂ f z) : ∮ (z : ℂ) in C(c, R), f z / (z - w) = 2 * ↑real.pi * complex.I * f w
theorem set.antitone_bforall {α : Type u_1} {P : α → Prop} : antitone (λ (s : set α), ∀ (x : α), x ∈ s → P x)
theorem has_lt.lt.trans' {α : Type u} [preorder α] {a b c : α} : b < c → a < b → a < c
theorem is_preconnected_sUnion {α : Type u} [topological_space α] (x : α) (c : set (set α)) (H1 : ∀ (s : set α), s ∈ c → x ∈ s) (H2 : ∀ (s : set α), s ∈ c → is_preconnected s) : is_preconnected (⋃₀c)
theorem emetric.uniform_continuous_on_iff {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} {s : set α} : uniform_continuous_on f s ↔ ∀ (ε : ennreal), ε > 0 → (∃ (δ : ennreal) (H : δ > 0), ∀ {a : α} {H : a ∈ s} {b : α} {H : b ∈ s}, has_edist.edist a b < δ → has_edist.edist (f a) (f b) < ε)
theorem submonoid.closure_eq {M : Type u_1} [mul_one_class M] (S : submonoid M) : submonoid.closure ↑S = S
theorem strict_convex.ae_eq_const_or_average_mem_interior {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {f : α → E} [measure_theory.is_finite_measure μ] (hs : strict_convex ℝ s) (hsc : is_closed s) (hfs : ∀ᵐ (x : α) ∂μ, f x ∈ s) (hfi : measure_theory.integrable f μ) : f =ᵐ[μ] function.const α (⨍ (x : α), f x ∂μ) ∨ ⨍ (x : α), f x ∂μ ∈ interior s
theorem normed_space.norm_le_dual_bound (𝕜 : Type v) [is_R_or_C 𝕜] {E : Type u} [normed_group E] [normed_space 𝕜 E] (x : E) {M : ℝ} (hMp : 0 ≤ M) (hM : ∀ (f : normed_space.dual 𝕜 E), ∥⇑f x∥ ≤ M * ∥f∥) : ∥x∥ ≤ M
theorem or_and_distrib_right {a b c : Prop} : (a ∨ b) ∧ c ↔ a ∧ c ∨ b ∧ c
theorem filter.coprod_cocompact {α : Type u} {β : Type v} [topological_space α] [topological_space β] : (filter.cocompact α).coprod (filter.cocompact β) = filter.cocompact (α × β)
theorem group.normal_closure.is_normal {G : Type u_1} {s : set G} [group G] : is_normal_subgroup (group.normal_closure s)
theorem cont_diff_id {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {n : with_top ℕ} : cont_diff 𝕜 n id
theorem sub_right_lt_of_lt_add {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a < b + c → a - c < b
theorem dist_le_range_sum_dist {α : Type u} [pseudo_metric_space α] (f : ℕ → α) (n : ℕ) : has_dist.dist (f 0) (f n) ≤ (finset.range n).sum (λ (i : ℕ), has_dist.dist (f i) (f (i + 1)))
theorem box_integral.has_integral_iff {ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} {y : F} : box_integral.has_integral I l f vol y ↔ ∀ (ε : ℝ), ε > 0 → (∃ (r : nnreal → (ι → ℝ) → ↥(set.Ioi 0)), (∀ (c : nnreal), l.r_cond (r c)) ∧ ∀ (c : nnreal) (π : box_integral.tagged_prepartition I), l.mem_base_set I c (r c) π → π.is_partition → has_dist.dist (box_integral.integral_sum f vol π) y ≤ ε)
theorem le_trans {α : Type u} [preorder α] {a b c : α} : a ≤ b → b ≤ c → a ≤ c
theorem continuous_update {ι : Type u_5} {π : ι → Type u_6} [Π (i : ι), topological_space (π i)] [decidable_eq ι] (i : ι) : continuous (λ (f : (Π (j : ι), π j) × π i), function.update f.fst i f.snd)
theorem category_theory.is_iso_of_mono_of_split_epi {C : Type u₁} [category_theory.category C] {X Y : C} (f : X ⟶ Y) [category_theory.mono f] [category_theory.split_epi f] : category_theory.is_iso f
theorem continuous_map.continuous_curry {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] [locally_compact_space (α × β)] : continuous continuous_map.curry
theorem measure_theory.has_sum_integral_of_dominated_convergence {α : Type u_1} {E : Type u_2} [normed_group E] [normed_space ℝ E] [complete_space E] {m : measurable_space α} {μ : measure_theory.measure α} {ι : Type u_3} [encodable ι] {F : ι → α → E} {f : α → E} (bound : ι → α → ℝ) (hF_meas : ∀ (n : ι), measure_theory.ae_strongly_measurable (F n) μ) (h_bound : ∀ (n : ι), ∀ᵐ (a : α) ∂μ, ∥F n a∥ ≤ bound n a) (bound_summable : ∀ᵐ (a : α) ∂μ, summable (λ (n : ι), bound n a)) (bound_integrable : measure_theory.integrable (λ (a : α), ∑' (n : ι), bound n a) μ) (h_lim : ∀ᵐ (a : α) ∂μ, has_sum (λ (n : ι), F n a) (f a)) : has_sum (λ (n : ι), ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ)
theorem pythagorean_triple.coprime_classification' {x y z : ℤ} (h : pythagorean_triple x y z) (h_coprime : x.gcd y = 1) (h_parity : x % 2 = 1) (h_pos : 0 < z) : ∃ (m n : ℤ), x = m ^ 2 - n ^ 2 ∧ y = 2 * m * n ∧ z = m ^ 2 + n ^ 2 ∧ m.gcd n = 1 ∧ (m % 2 = 0 ∧ n % 2 = 1 ∨ m % 2 = 1 ∧ n % 2 = 0) ∧ 0 ≤ m
theorem submodule.sup_orthogonal_of_complete_space {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K : submodule 𝕜 E} [complete_space ↥K] : K ⊔ Kᗮ = ⊤
theorem is_localization.is_localization_of_is_exists_mul_mem {R : Type u_1} [comm_ring R] (S : Type u_2) [comm_ring S] [algebra R S] (M N : submonoid R) [is_localization M S] (h : M ≤ N) (h' : ∀ (x : ↥N), ∃ (m : R), m * ↑x ∈ M) : is_localization N S
theorem multilinear_map.snoc_add {R : Type u} {n : ℕ} {M : fin n.succ → Type v} {M₂ : Type v₂} [semiring R] [Π (i : fin n.succ), add_comm_monoid (M i)] [add_comm_monoid M₂] [Π (i : fin n.succ), module R (M i)] [module R M₂] (f : multilinear_map R M M₂) (m : Π (i : fin n), M (⇑fin.cast_succ i)) (x y : M (fin.last n)) : ⇑f (fin.snoc m (x + y)) = ⇑f (fin.snoc m x) + ⇑f (fin.snoc m y)
theorem zero_lt.right.mul_le_one_of_le_of_le {α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (b0 : 0 < b) : a * b ≤ 1
theorem minpoly.min (A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) {p : polynomial A} (pmonic : p.monic) (hp : ⇑(polynomial.aeval x) p = 0) : (minpoly A x).degree ≤ p.degree
theorem monovary_on.sum_smul_comp_perm_le_sum_smul {ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {s : finset ι} {σ : equiv.perm ι} {f : ι → α} {g : ι → β} (hfg : monovary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i • g (⇑σ i)) ≤ s.sum (λ (i : ι), f i • g i)
theorem padic_seq.lift_index_left_left {p : ℕ} [fact (nat.prime p)] {f : padic_seq p} (hf : ¬f ≈ 0) (v2 v3 : ℕ) : padic_norm p (⇑f (padic_seq.stationary_point hf)) = padic_norm p (⇑f (linear_order.max (padic_seq.stationary_point hf) (linear_order.max v2 v3)))
theorem monoid_with_zero_hom.congr_arg {M : Type u_3} {N : Type u_4} [mul_zero_one_class M] [mul_zero_one_class N] (f : M →*₀ N) {x y : M} (h : x = y) : ⇑f x = ⇑f y
theorem affine.simplex.centroid_eq_of_range_eq {k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : ℕ} {s₁ s₂ : affine.simplex k P n} (h : set.range s₁.points = set.range s₂.points) : finset.centroid k finset.univ s₁.points = finset.centroid k finset.univ s₂.points
theorem regular_expression.matches_map {α : Type u_1} {β : Type u_2} (f : α → β) (P : regular_expression α) : (regular_expression.map f P).matches = ⇑(language.map f) P.matches
theorem real.Inf_nonneg (S : set ℝ) (hS : ∀ (x : ℝ), x ∈ S → 0 ≤ x) : 0 ≤ has_Inf.Inf S
theorem Kuratowski_embedding.exists_isometric_embedding (α : Type u) [metric_space α] [topological_space.separable_space α] : ∃ (f : α → ↥(lp (λ (n : ℕ), ℝ) ⊤)), isometry f
theorem first_order.language.substructure.closure_induction' {L : first_order.language} {M : Type w} [L.Structure M] (s : set M) {p : Π (x : M), x ∈ ⇑(first_order.language.substructure.closure L) s → Prop} (Hs : ∀ (x : M) (h : x ∈ s), p x _) (Hfun : ∀ {n : ℕ} (f : L.functions n), first_order.language.closed_under f {x : M | ∃ (hx : x ∈ ⇑(first_order.language.substructure.closure L) s), p x hx}) {x : M} (hx : x ∈ ⇑(first_order.language.substructure.closure L) s) : p x hx
theorem filter.liminf_eq_supr_infi {α : Type u_1} {β : Type u_2} [complete_lattice α] {f : filter β} {u : β → α} : f.liminf u = ⨆ (s : set β) (H : s ∈ f), ⨅ (a : β) (H : a ∈ s), u a
theorem vitali_family.null_of_frequently_le_of_frequently_ge {α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {ρ : measure_theory.measure α} [measure_theory.is_locally_finite_measure ρ] (hρ : ρ.absolutely_continuous μ) {c d : nnreal} (hcd : c < d) (s : set α) (hc : ∀ (x : α), x ∈ s → (∃ᶠ (a : set α) in v.filter_at x, ⇑ρ a ≤ ↑c * ⇑μ a)) (hd : ∀ (x : α), x ∈ s → (∃ᶠ (a : set α) in v.filter_at x, ↑d * ⇑μ a ≤ ⇑ρ a)) : ⇑μ s = 0
theorem mul_equiv.map_finsupp_prod {α : Type u_1} {M : Type u_5} {N : Type u_7} {P : Type u_8} [has_zero M] [comm_monoid N] [comm_monoid P] (h : N ≃* P) (f : α →₀ M) (g : α → M → N) : ⇑h (f.prod g) = f.prod (λ (a : α) (b : M), ⇑h (g a b))
theorem bdd_above.inter_of_right {α : Type u} [preorder α] {s t : set α} (h : bdd_above t) : bdd_above (s ∩ t)
theorem subgroup.closure_induction'' {G : Type u_1} [group G] {k : set G} {p : G → Prop} {x : G} (h : x ∈ subgroup.closure k) (Hk : ∀ (x : G), x ∈ k → p x) (Hk_inv : ∀ (x : G), x ∈ k → p x⁻¹) (H1 : p 1) (Hmul : ∀ (x y : G), p x → p y → p (x * y)) : p x
theorem antivary.sum_smul_lt_sum_smul_comp_perm_iff {ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {σ : equiv.perm ι} {f : ι → α} {g : ι → β} [fintype ι] (hfg : antivary f g) : finset.univ.sum (λ (i : ι), f i • g i) < finset.univ.sum (λ (i : ι), f i • g (⇑σ i)) ↔ ¬antivary f (g ∘ ⇑σ)
theorem continuous_map.exists_mem_subalgebra_near_continuous_map_of_separates_points {X : Type u_1} [topological_space X] [compact_space X] (A : subalgebra ℝ C(X, ℝ)) (w : A.separates_points) (f : C(X, ℝ)) (ε : ℝ) (pos : 0 < ε) : ∃ (g : ↥A), ∥↑g - f∥ < ε
theorem bounded_continuous_function.exists_forall_mem_restrict_eq_of_closed {Y : Type u_2} [topological_space Y] [normal_space Y] {s : set Y} (f : bounded_continuous_function ↥s ℝ) (hs : is_closed s) {t : set ℝ} [t.ord_connected] (hf : ∀ (x : ↥s), ⇑f x ∈ t) (hne : t.nonempty) : ∃ (g : bounded_continuous_function Y ℝ), (∀ (y : Y), ⇑g y ∈ t) ∧ g.restrict s = f
theorem fin.order_embedding_eq {n : ℕ} {α : Type u_1} [preorder α] {f g : fin n ↪o α} (h : set.range ⇑f = set.range ⇑g) : f = g
theorem is_preconnected.closure {α : Type u} [topological_space α] {s : set α} (H : is_preconnected s) : is_preconnected (closure s)
theorem colex.sum_two_pow_lt_iff_lt (A B : finset ℕ) : A.sum (λ (i : ℕ), 2 ^ i) < B.sum (λ (i : ℕ), 2 ^ i) ↔ A.to_colex < B.to_colex
theorem is_artinian.induction {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [is_artinian R M] {P : submodule R M → Prop} (hgt : ∀ (I : submodule R M), (∀ (J : submodule R M), J < I → P J) → P I) (I : submodule R M) : P I
theorem linear_map.is_self_adjoint_adjoint_mul_self {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [finite_dimensional 𝕜 E] (T : E →ₗ[𝕜] E) : inner_product_space.is_self_adjoint (⇑linear_map.adjoint T * T)
theorem strict_concave_on.lt_on_open_segment' {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [linear_ordered_add_comm_monoid β] [has_scalar 𝕜 E] [module 𝕜 β] [ordered_smul 𝕜 β] {s : set E} {f : E → β} (hf : strict_concave_on 𝕜 s f) {x y : E} (hx : x ∈ s) (hy : y ∈ s) (hxy : x ≠ y) {a b : 𝕜} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) : linear_order.min (f x) (f y) < f (a • x + b • y)
theorem asymptotics.is_O_with.bound {α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {c : ℝ} {f : α → E} {g : α → F} {l : filter α} : asymptotics.is_O_with c l f g → (∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g x∥)
theorem finset.untrop_sum {R : Type u_1} {S : Type u_2} [conditionally_complete_linear_order R] (s : finset S) (f : S → tropical (with_top R)) : tropical.untrop (s.sum (λ (i : S), f i)) = ⨅ (i : ↥s), tropical.untrop (f ↑i)
theorem basis.map_isometry_euclidean_of_orthonormal {ι : Type u_1} {𝕜 : Type u_3} [is_R_or_C 𝕜] {E : Type u_4} [inner_product_space 𝕜 E] {E' : Type u_5} [inner_product_space 𝕜 E'] [fintype ι] (v : basis ι 𝕜 E) (hv : orthonormal 𝕜 ⇑v) (f : E ≃ₗᵢ[𝕜] E') : ((v.map f.to_linear_equiv).to_orthonormal_basis _).repr = f.symm.trans (v.to_orthonormal_basis hv).repr
theorem finsupp.sum_smul_index_add_monoid_hom {α : Type u_1} {M : Type u_5} {N : Type u_7} {R : Type u_11} [monoid R] [add_monoid M] [add_comm_monoid N] [distrib_mul_action R M] {g : α →₀ M} {b : R} {h : α → M →+ N} : (b • g).sum (λ (a : α), ⇑(h a)) = g.sum (λ (i : α) (c : M), ⇑(h i) (b • c))
theorem collinear_iff_of_mem (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p₀ : P} (h : p₀ ∈ s) : collinear k s ↔ ∃ (v : V), ∀ (p : P), p ∈ s → (∃ (r : k), p = r • v +ᵥ p₀)
theorem measure_theory.mem_ℒp.integral_indicator_norm_ge_nonneg_le_of_meas {α : Type u_1} {β : Type u_2} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {f : α → β} (hf : measure_theory.mem_ℒp f 1 μ) (hmeas : measure_theory.strongly_measurable f) {ε : ℝ} (hε : 0 < ε) : ∃ (M : ℝ), 0 ≤ M ∧ ∫⁻ (x : α), ↑∥{x : α | M ≤ ↑∥f x∥₊}.indicator f x∥₊ ∂μ ≤ ennreal.of_real ε
theorem polynomial.prod_multiset_X_sub_C_dvd {R : Type u} [field R] (p : polynomial R) : (multiset.map (λ (a : R), polynomial.X - ⇑polynomial.C a) p.roots).prod ∣ p
theorem is_closed.Icc_subset_of_forall_mem_nhds_within {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {a b : α} {s : set α} (hs : is_closed (s ∩ set.Icc a b)) (ha : a ∈ s) (hgt : ∀ (x : α), x ∈ s ∩ set.Ico a b → s ∈ nhds_within x (set.Ioi x)) : set.Icc a b ⊆ s
theorem spectrum.pow_norm_pow_one_div_tendsto_nhds_spectral_radius {A : Type u_2} [normed_ring A] [normed_algebra ℂ A] [complete_space A] [norm_one_class A] (a : A) : filter.tendsto (λ (n : ℕ), ennreal.of_real (∥a ^ n∥ ^ (1 / ↑n))) filter.at_top (nhds (spectral_radius ℂ a))
theorem is_cyclotomic_extension.prime_ne_two_pow_norm_zeta_sub_one {p : ℕ+} {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [ne_zero ↑↑p] {k : ℕ} [hpri : fact (nat.prime ↑p)] [is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic ↑(p ^ (k + 1)) K)) (h : p ≠ 2) : ⇑(algebra.norm K) (is_cyclotomic_extension.zeta (p ^ (k + 1)) K L - 1) = ↑p
theorem polynomial.X_pow_sub_one_separable_iff {F : Type u} [field F] {n : ℕ} : (polynomial.X ^ n - 1).separable ↔ ↑n ≠ 0
theorem pgame.lt_iff_forall_le {x y : pgame} (ox : x.numeric) (oy : y.numeric) : x < y ↔ (∃ (i : y.left_moves), x ≤ y.move_left i) ∨ ∃ (j : x.right_moves), x.move_right j ≤ y
theorem has_deriv_within_at.Ioo_of_Ioi {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {F : Type v} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {f' : F} [linear_order 𝕜] [order_closed_topology 𝕜] {x y : 𝕜} (h : x < y) : has_deriv_within_at f f' (set.Ioi x) x → has_deriv_within_at f f' (set.Ioo x y) x
theorem has_le.le.antisymm {α : Type u} [partial_order α] {a b : α} : a ≤ b → b ≤ a → a = b
theorem exists_ratio_has_deriv_at_eq_ratio_slope' (f f' : ℝ → ℝ) {a b : ℝ} (hab : a < b) (g g' : ℝ → ℝ) {lfa lga lfb lgb : ℝ} (hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x) (hgg' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x) (hfa : filter.tendsto f (nhds_within a (set.Ioi a)) (nhds lfa)) (hga : filter.tendsto g (nhds_within a (set.Ioi a)) (nhds lga)) (hfb : filter.tendsto f (nhds_within b (set.Iio b)) (nhds lfb)) (hgb : filter.tendsto g (nhds_within b (set.Iio b)) (nhds lgb)) : ∃ (c : ℝ) (H : c ∈ set.Ioo a b), (lgb - lga) * f' c = (lfb - lfa) * g' c
theorem measure_theory.simple_func.box_integral_eq_integral {ι : Type u} {E : Type v} [fintype ι] [normed_group E] [normed_space ℝ E] (f : measure_theory.simple_func (ι → ℝ) E) (μ : measure_theory.measure (ι → ℝ)) [measure_theory.is_locally_finite_measure μ] (I : box_integral.box ι) (l : box_integral.integration_params) (hl : l.bRiemann = bool.ff) : box_integral.integral I l ⇑f μ.to_box_additive.to_smul = measure_theory.simple_func.integral (μ.restrict ↑I) f
theorem dense.inter_open_nonempty {α : Type u} [topological_space α] {s : set α} : dense s → ∀ (U : set α), is_open U → U.nonempty → (U ∩ s).nonempty
theorem add_submonoid.localization_map.neg_unique {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {f : M →+ N} (h : ∀ (y : ↥S), is_add_unit (⇑f ↑y)) {y : ↥S} {z : N} (H : ⇑f ↑y + z = 0) : ↑-⇑(is_add_unit.lift_right (f.restrict S) h) y = z
theorem homology.comp_right_eq_comp_left {V : Type u_1} [category_theory.category V] {A₁ B₁ C₁ A₂ B₂ C₂ A₃ B₃ C₃ : V} {f₁ : A₁ ⟶ B₁} {g₁ : B₁ ⟶ C₁} {f₂ : A₂ ⟶ B₂} {g₂ : B₂ ⟶ C₂} {f₃ : A₃ ⟶ B₃} {g₃ : B₃ ⟶ C₃} {α₁ : category_theory.arrow.mk f₁ ⟶ category_theory.arrow.mk f₂} {β₁ : category_theory.arrow.mk g₁ ⟶ category_theory.arrow.mk g₂} {α₂ : category_theory.arrow.mk f₂ ⟶ category_theory.arrow.mk f₃} {β₂ : category_theory.arrow.mk g₂ ⟶ category_theory.arrow.mk g₃} (p₁ : α₁.right = β₁.left) (p₂ : α₂.right = β₂.left) : (α₁ ≫ α₂).right = (β₁ ≫ β₂).left
theorem pgame.zero_le {x : pgame} : 0 ≤ x ↔ ∀ (j : x.right_moves), ∃ (i : (x.move_right j).left_moves), 0 ≤ (x.move_right j).move_left i
theorem filter.map_at_top_finset_prod_le_of_prod_eq {α : Type u_3} {β : Type u_4} {γ : Type u_5} [comm_monoid α] {f : β → α} {g : γ → α} (h_eq : ∀ (u : finset γ), ∃ (v : finset β), ∀ (v' : finset β), v ⊆ v' → (∃ (u' : finset γ), u ⊆ u' ∧ u'.prod (λ (x : γ), g x) = v'.prod (λ (b : β), f b))) : filter.map (λ (s : finset β), s.prod (λ (b : β), f b)) filter.at_top ≤ filter.map (λ (s : finset γ), s.prod (λ (x : γ), g x)) filter.at_top
theorem smul_pos {R : Type u_1} {M : Type u_2} [ordered_semiring R] [ordered_add_comm_monoid M] [smul_with_zero R M] [ordered_smul R M] {a : M} {c : R} (hc : 0 < c) : 0 < a → 0 < c • a
theorem ordinal.enum_ord_def'_nonempty {S : set ordinal} (hS : set.unbounded has_lt.lt S) (a : ordinal) : (S ∩ set.Ici a).nonempty
theorem orientation.ne_iff_eq_neg {R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {ι : Type u_3} [decidable_eq ι] [fintype ι] [finite_dimensional R M] (x₁ x₂ : orientation R M ι) (h : fintype.card ι = finite_dimensional.finrank R M) : x₁ ≠ x₂ ↔ x₁ = -x₂
theorem add_semiconj_by.add_left {S : Type u} [add_semigroup S] {a b x y z : S} (ha : add_semiconj_by a y z) (hb : add_semiconj_by b x y) : add_semiconj_by (a + b) x z
theorem dense_embedding_pure {α : Type u} : dense_embedding has_pure.pure
theorem continuous_linear_map.is_bounded_linear_map {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] (f : E →L[𝕜] F) : is_bounded_linear_map 𝕜 ⇑f
theorem finset.sum_centroid_weights_eq_one_of_cast_card_ne_zero {k : Type u_1} [division_ring k] {ι : Type u_4} (s : finset ι) (h : ↑(s.card) ≠ 0) : s.sum (λ (i : ι), finset.centroid_weights k s i) = 1
theorem nat.prime.factorization {p : ℕ} (hp : nat.prime p) : p.factorization = finsupp.single p 1
theorem ideal.jacobson_eq_iff_jacobson_quotient_eq_bot {R : Type u} [comm_ring R] {I : ideal R} : I.jacobson = I ↔ ⊥.jacobson = ⊥
theorem affine_subspace.ext_of_direction_eq {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s1 s2 : affine_subspace k P} (hd : s1.direction = s2.direction) (hn : (↑s1 ∩ ↑s2).nonempty) : s1 = s2
theorem list.sum_neg {G : Type u_7} [add_comm_group G] (L : list G) : -L.sum = (list.map (λ (x : G), -x) L).sum
theorem orientation.oangle_neg_left_eq_neg_right {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x y : V) : o.oangle (-x) y = o.oangle x (-y)
theorem matrix.det_smul_inv_mul_vec_eq_cramer {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) (b : n → α) (h : is_unit A.det) : A.det • A⁻¹.mul_vec b = ⇑(A.cramer) b
theorem filter.eventually_eq.measure_eq {α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {s t : set α} (H : s =ᵐ[μ] t) : ⇑μ s = ⇑μ t
theorem interval_integral.integral_sub_linear_is_o_of_tendsto_ae {ι : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {c : E} {l l' : filter ℝ} {lt : filter ι} {a : ℝ} [interval_integral.FTC_filter a l l'] (hfm : strongly_measurable_at_filter f l' measure_theory.measure_space.volume) (hf : filter.tendsto f (l' ⊓ measure_theory.measure_space.volume.ae) (nhds c)) {u v : ι → ℝ} (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) : (λ (t : ι), (∫ (x : ℝ) in u t..v t, f x) - (v t - u t) • c) =o[lt] (v - u)
theorem set.finite.bdd_below_bUnion {α : Type u} {β : Type v} [semilattice_inf α] [nonempty α] {I : set β} {S : β → set α} (H : I.finite) : bdd_below (⋃ (i : β) (H : i ∈ I), S i) ↔ ∀ (i : β), i ∈ I → bdd_below (S i)
theorem pi_norm_le_iff {ι : Type u_2} {π : ι → Type u_1} [fintype ι] [Π (i : ι), semi_normed_group (π i)] {r : ℝ} (hr : 0 ≤ r) {x : Π (i : ι), π i} : ∥x∥ ≤ r ↔ ∀ (i : ι), ∥x i∥ ≤ r
theorem linear_map.mk_continuous_norm_le {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →ₛₗ[σ₁₂] F) {C : ℝ} (hC : 0 ≤ C) (h : ∀ (x : E), ∥⇑f x∥ ≤ C * ∥x∥) : ∥f.mk_continuous C h∥ ≤ C
theorem add_subsemigroup.closure_eq {M : Type u_1} [has_add M] (S : add_subsemigroup M) : add_subsemigroup.closure ↑S = S
theorem ideal.exists_ideal_over_prime_of_is_integral {R : Type u_1} [comm_ring R] {S : Type u_2} [comm_ring S] [algebra R S] (H : algebra.is_integral R S) (P : ideal R) [P.is_prime] (I : ideal S) [I.is_prime] (hIP : ideal.comap (algebra_map R S) I ≤ P) : ∃ (Q : ideal S) (H : Q ≥ I), Q.is_prime ∧ ideal.comap (algebra_map R S) Q = P
theorem function.injective.convex_independent_iff_set {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] {p : ι → E} (hi : function.injective p) : convex_independent 𝕜 (λ (x : ↥(set.range p)), ↑x) ↔ convex_independent 𝕜 p
theorem set.image_image2_antidistrib_left {α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {f : α → β → γ} {s : set α} {t : set β} {g : γ → δ} {f' : β' → α → δ} {g' : β → β'} (h_antidistrib : ∀ (a : α) (b : β), g (f a b) = f' (g' b) a) : g '' set.image2 f s t = set.image2 f' (g' '' t) s
theorem is_compact.has_extreme_point {E : Type u_1} [normed_group E] [normed_space ℝ E] {s : set E} (hscomp : is_compact s) (hsnemp : s.nonempty) : (set.extreme_points ℝ s).nonempty
theorem euclidean_geometry.dist_sq_add_dist_sq_eq_two_mul_dist_midpoint_sq_add_half_dist_sq {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (a b c : P) : has_dist.dist a b ^ 2 + has_dist.dist a c ^ 2 = 2 * (has_dist.dist a (midpoint ℝ b c) ^ 2 + (has_dist.dist b c / 2) ^ 2)
theorem con.comap_eq {M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] {c : con M} {f : N →* M} : con.comap ⇑f _ c = con.ker (c.mk'.comp f)
theorem is_artinian_of_tower (R : Type u_1) {S : Type u_2} {M : Type u_3} [comm_ring R] [ring S] [add_comm_group M] [algebra R S] [module S M] [module R M] [is_scalar_tower R S M] (h : is_artinian R M) : is_artinian S M
theorem cont_diff_prod_assoc_symm {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] : cont_diff 𝕜 ⊤ ⇑((equiv.prod_assoc E F G).symm)
theorem tensor_algebra.ι_range_disjoint_one {R : Type u_1} [comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] : disjoint (tensor_algebra.ι R).range 1
theorem real.cont_diff_at_rpow_of_ne (p : ℝ × ℝ) (hp : p.fst ≠ 0) {n : with_top ℕ} : cont_diff_at ℝ n (λ (p : ℝ × ℝ), p.fst ^ p.snd) p
theorem continuous_map.continuous {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : C(α, β)) : continuous ⇑f
theorem lipschitz_on_with.hausdorff_measure_image_le {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [measurable_space X] [borel_space X] [measurable_space Y] [borel_space Y] {K : nnreal} {f : X → Y} {s : set X} (h : lipschitz_on_with K f s) {d : ℝ} (hd : 0 ≤ d) : ⇑(measure_theory.measure.hausdorff_measure d) (f '' s) ≤ ↑K ^ d * ⇑(measure_theory.measure.hausdorff_measure d) s
theorem has_lt.lt.not_le {α : Type u} [preorder α] {a b : α} (h : a < b) : ¬b ≤ a
theorem add_units.is_add_unit_add_units_add {M : Type u_1} [add_monoid M] (u : add_units M) (a : M) : is_add_unit (↑u + a) ↔ is_add_unit a
theorem right.add_neg_of_neg_of_nonpos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : a < 0) (hb : b ≤ 0) : a + b < 0
theorem metric.thickening_empty {α : Type u} [pseudo_emetric_space α] (δ : ℝ) : metric.thickening δ ∅ = ∅
theorem nat.partrec.code.rec_prim {α : Type u_1} {σ : Type u_2} [primcodable α] [primcodable σ] {c : α → nat.partrec.code} (hc : primrec c) {z : α → σ} (hz : primrec z) {s : α → σ} (hs : primrec s) {l : α → σ} (hl : primrec l) {r : α → σ} (hr : primrec r) {pr : α → nat.partrec.code → nat.partrec.code → σ → σ → σ} (hpr : primrec (λ (a : α × nat.partrec.code × nat.partrec.code × σ × σ), pr a.fst a.snd.fst a.snd.snd.fst a.snd.snd.snd.fst a.snd.snd.snd.snd)) {co : α → nat.partrec.code → nat.partrec.code → σ → σ → σ} (hco : primrec (λ (a : α × nat.partrec.code × nat.partrec.code × σ × σ), co a.fst a.snd.fst a.snd.snd.fst a.snd.snd.snd.fst a.snd.snd.snd.snd)) {pc : α → nat.partrec.code → nat.partrec.code → σ → σ → σ} (hpc : primrec (λ (a : α × nat.partrec.code × nat.partrec.code × σ × σ), pc a.fst a.snd.fst a.snd.snd.fst a.snd.snd.snd.fst a.snd.snd.snd.snd)) {rf : α → nat.partrec.code → σ → σ} (hrf : primrec (λ (a : α × nat.partrec.code × σ), rf a.fst a.snd.fst a.snd.snd)) : let F : α → nat.partrec.code → σ := λ (a : α) (c : nat.partrec.code), c.rec_on (z a) (s a) (l a) (r a) (pr a) (co a) (pc a) (rf a) in primrec (λ (a : α), F a (c a))
theorem measure_theory.is_add_fundamental_domain.map_restrict_quotient {G : Type u_1} [add_group G] [measurable_space G] [topological_space G] [topological_add_group G] [borel_space G] {μ : measure_theory.measure G} {Γ : add_subgroup G} {𝓕 : set G} (h𝓕 : measure_theory.is_add_fundamental_domain ↥(Γ.opposite) 𝓕 μ) [encodable ↥Γ] [measurable_space (G ⧸ Γ)] [borel_space (G ⧸ Γ)] [t2_space (G ⧸ Γ)] [topological_space.second_countable_topology (G ⧸ Γ)] (K : topological_space.positive_compacts (G ⧸ Γ)) [Γ.normal] [μ.is_add_haar_measure] [μ.is_add_right_invariant] (h𝓕_finite : ⇑μ 𝓕 < ⊤) : measure_theory.measure.map ⇑(quotient_add_group.mk' Γ) (μ.restrict 𝓕) = ⇑μ (𝓕 ∩ ⇑(quotient_add_group.mk' Γ) ⁻¹' ↑K) • measure_theory.measure.add_haar_measure K
theorem finset.Inter_mem_sets {α : Type u} {f : filter α} {β : Type v} {s : β → set α} (is : finset β) : (⋂ (i : β) (H : i ∈ is), s i) ∈ f ↔ ∀ (i : β), i ∈ is → s i ∈ f
theorem category_theory.congr_arg_mpr_hom_right {C : Type u₁} [category_theory.category C] {X Y Z : C} (p : X ⟶ Y) (q : Z = Y) : _.mpr p = p ≫ category_theory.eq_to_hom _
theorem orthonormal.oangle_rotation_oangle_left {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x y : V) : hb.oangle (⇑(hb.rotation (hb.oangle x y)) x) y = 0
theorem add_monoid.subset_closure {M : Type u_1} [add_monoid M] {s : set M} : s ⊆ add_monoid.closure s
theorem monovary.sum_comp_perm_mul_lt_sum_mul_iff {ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {σ : equiv.perm ι} {f g : ι → α} [fintype ι] (hfg : monovary f g) : finset.univ.sum (λ (i : ι), f (⇑σ i) * g i) < finset.univ.sum (λ (i : ι), f i * g i) ↔ ¬monovary (f ∘ ⇑σ) g
theorem order_iso.to_galois_connection {α : Type u} {β : Type v} [preorder α] [preorder β] (oi : α ≃o β) : galois_connection ⇑oi ⇑(oi.symm)
theorem finset.mem_up_shadow_iff_exists_mem_card_add {α : Type u_1} [decidable_eq α] [fintype α] {𝒜 : finset (finset α)} {s : finset α} {k : ℕ} : s ∈ finset.up_shadow^[k] 𝒜 ↔ ∃ (t : finset α) (H : t ∈ 𝒜), t ⊆ s ∧ t.card + k = s.card
theorem integral_pow_abs_sub_interval_oc {a b : ℝ} (n : ℕ) : ∫ (x : ℝ) in set.interval_oc a b, |x - a| ^ n = |b - a| ^ (n + 1) / (↑n + 1)
theorem submodule.eq_top_of_nonempty_interior' {R : Type u_1} {M : Type u_2} [ring R] [topological_space R] [topological_space M] [add_comm_group M] [has_continuous_add M] [module R M] [has_continuous_smul R M] [(nhds_within 0 {x : R | is_unit x}).ne_bot] (s : submodule R M) (hs : (interior ↑s).nonempty) : s = ⊤
theorem function.periodic.tendsto_at_bot_interval_integral_of_pos' {T : ℝ} {g : ℝ → ℝ} (hg : function.periodic g T) (h_int : ∀ (t₁ t₂ : ℝ), interval_integrable g measure_theory.measure_space.volume t₁ t₂) (h₀ : ∀ (x : ℝ), 0 < g x) (hT : 0 < T) : filter.tendsto (λ (t : ℝ), ∫ (x : ℝ) in 0..t, g x) filter.at_bot filter.at_bot
theorem convex_on.neg {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [ordered_add_comm_group β] [has_scalar 𝕜 E] [module 𝕜 β] {s : set E} {f : E → β} : convex_on 𝕜 s f → concave_on 𝕜 s (-f)
theorem category_theory.triangulated.pretriangulated.comp_dist_triangle_mor_zero₃₁ (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C ℤ] [category_theory.preadditive C] [∀ (n : ℤ), (category_theory.shift_functor C n).additive] [category_theory.triangulated.pretriangulated C] (T : category_theory.triangulated.triangle C) (H : T ∈ dist_triang C) : T.mor₃ ≫ (category_theory.shift_equiv C 1).functor.map T.mor₁ = 0
theorem is_compact.nonempty_Inter_of_sequence_nonempty_compact_closed {α : Type u} [topological_space α] (Z : ℕ → set α) (hZd : ∀ (i : ℕ), Z (i + 1) ⊆ Z i) (hZn : ∀ (i : ℕ), (Z i).nonempty) (hZ0 : is_compact (Z 0)) (hZcl : ∀ (i : ℕ), is_closed (Z i)) : (⋂ (i : ℕ), Z i).nonempty
theorem is_localization.sec_spec' {R : Type u_1} [comm_semiring R] (M : submonoid R) {S : Type u_2} [comm_semiring S] [algebra R S] [is_localization M S] (z : S) : ⇑(algebra_map R S) (is_localization.sec M z).fst = ⇑(algebra_map R S) ↑((is_localization.sec M z).snd) * z
theorem is_regular_mul_iff {R : Type u_1} {a b : R} [comm_semigroup R] : is_regular (a * b) ↔ is_regular a ∧ is_regular b
theorem subgroup.pi_le_iff {η : Type u_5} {f : η → Type u_6} [Π (i : η), group (f i)] [decidable_eq η] [fintype η] {H : Π (i : η), subgroup (f i)} {J : subgroup (Π (i : η), f i)} : subgroup.pi set.univ H ≤ J ↔ ∀ (i : η), subgroup.map (monoid_hom.single f i) (H i) ≤ J
theorem finprod_mem_of_eq_on_one {α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M} {s : set α} (hf : set.eq_on f 1 s) : finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) = 1
theorem continuous_on.strongly_measurable_at_filter {α : Type u_1} {β : Type u_2} [measurable_space α] [topological_space α] [opens_measurable_space α] [topological_space β] [topological_space.pseudo_metrizable_space β] [second_countable_topology_either α β] {f : α → β} {s : set α} {μ : measure_theory.measure α} (hs : is_open s) (hf : continuous_on f s) (x : α) (H : x ∈ s) : strongly_measurable_at_filter f (nhds x) μ
theorem affine_subspace.mem_coe (k : Type u_1) {V : Type u_2} (P : Type u_3) [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) (s : affine_subspace k P) : p ∈ ↑s ↔ p ∈ s
theorem linear_ordered_comm_group_with_zero.singleton_nhds_of_units {Γ₀ : Type u_1} [linear_ordered_comm_group_with_zero Γ₀] (γ : Γ₀ˣ) : {↑γ} ∈ nhds ↑γ
theorem metric.Hausdorff_dist_le_of_inf_dist {α : Type u} [pseudo_metric_space α] {s t : set α} {r : ℝ} (hr : 0 ≤ r) (H1 : ∀ (x : α), x ∈ s → metric.inf_dist x t ≤ r) (H2 : ∀ (x : α), x ∈ t → metric.inf_dist x s ≤ r) : metric.Hausdorff_dist s t ≤ r
theorem first_order.language.substructure.is_elementary_of_exists {L : first_order.language} {M : Type u_3} [L.Structure M] (S : L.substructure M) (htv : ∀ (n : ℕ) (φ : L.bounded_formula empty (n + 1)) (x : fin n → ↥S) (a : M), φ.realize inhabited.default (fin.snoc (coe ∘ x) a) → (∃ (b : ↥S), φ.realize inhabited.default (fin.snoc (coe ∘ x) ↑b))) : S.is_elementary
theorem linear_map.separating_left_iff_ker_eq_bot {R : Type u_1} {R₁ : Type u_2} {R₂ : Type u_3} {M₁ : Type u_6} {M₂ : Type u_7} [comm_semiring R] [comm_semiring R₁] [add_comm_monoid M₁] [module R₁ M₁] [comm_semiring R₂] [add_comm_monoid M₂] [module R₂ M₂] {I₁ : R₁ →+* R} {I₂ : R₂ →+* R} {B : M₁ →ₛₗ[I₁] M₂ →ₛₗ[I₂] R} : B.separating_left ↔ B.ker = ⊥
theorem euclidean_geometry.circumcenter_eq_of_cospherical {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {ps : set P} {n : ℕ} [finite_dimensional ℝ V] (hd : finite_dimensional.finrank ℝ V = n) (hc : euclidean_geometry.cospherical ps) {sx₁ sx₂ : affine.simplex ℝ P n} (hsx₁ : set.range sx₁.points ⊆ ps) (hsx₂ : set.range sx₂.points ⊆ ps) : sx₁.circumcenter = sx₂.circumcenter
theorem is_open.measure_eq_supr_is_closed {α : Type u_1} [measurable_space α] [topological_space α] ⦃U : set α⦄ (hU : is_open U) (μ : measure_theory.measure α) [μ.weakly_regular] : ⇑μ U = ⨆ (F : set α) (H : F ⊆ U) (h : is_closed F), ⇑μ F
theorem imp_forall_iff {α : Type u_1} {p : Prop} {q : α → Prop} : p → ∀ (x : α), q x ↔ ∀ (x : α), p → q x
theorem measure_theory.tendsto_in_measure_of_tendsto_ae {α : Type u_1} {E : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [metric_space E] {f : ℕ → α → E} {g : α → E} [measure_theory.is_finite_measure μ] (hf : ∀ (n : ℕ), measure_theory.ae_strongly_measurable (f n) μ) (hfg : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (nhds (g x))) : measure_theory.tendsto_in_measure μ f filter.at_top g
theorem add_con.nsmul {M : Type u_1} [add_monoid M] (c : add_con M) (n : ℕ) {w x : M} : ⇑c w x → ⇑c (n • w) (n • x)
theorem module.free.of_equiv' {R : Type u} {N : Type z} [semiring R] [add_comm_monoid N] [module R N] {P : Type v} [add_comm_monoid P] [module R P] (h : module.free R P) (e : P ≃ₗ[R] N) : module.free R N
theorem closure_Ico {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b) : closure (set.Ico a b) = set.Icc a b
theorem category_theory.is_cofiltered.inf_to_commutes {C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] (O : finset C) (H : finset (Σ' (X Y : C) (mX : X ∈ O) (mY : Y ∈ O), X ⟶ Y)) {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f : X ⟶ Y} (mf : ⟨X, ⟨Y, ⟨mX, ⟨mY, f⟩⟩⟩⟩ ∈ H) : category_theory.is_cofiltered.inf_to O H mX ≫ f = category_theory.is_cofiltered.inf_to O H mY
theorem tendsto_tsum_compl_at_top_zero {α : Type u_1} {β : Type u_2} [add_comm_group α] [uniform_space α] [uniform_add_group α] [t1_space α] (f : β → α) : filter.tendsto (λ (s : finset β), ∑' (b : {x // x ∉ s}), f ↑b) filter.at_top (nhds 0)
theorem char_p_of_injective_algebra_map {R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] (h : function.injective ⇑(algebra_map R A)) (p : ℕ) [char_p R p] : char_p A p
theorem eq_of_vsub_eq_zero {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] {p1 p2 : P} (h : p1 -ᵥ p2 = 0) : p1 = p2
theorem add_monoid.is_torsion.not_torsion_free {G : Type u_1} [add_group G] [hN : nontrivial G] : add_monoid.is_torsion G → ¬add_monoid.is_torsion_free G
theorem bounded_continuous_function.uniform_continuous_comp {α : Type u} {β : Type v} {γ : Type w} [topological_space α] [pseudo_metric_space β] [pseudo_metric_space γ] {G : β → γ} {C : nnreal} (H : lipschitz_with C G) : uniform_continuous (bounded_continuous_function.comp G H)
theorem clifford_algebra.ι_mul_ι_add_swap {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Q : quadratic_form R M} (a b : M) : ⇑(clifford_algebra.ι Q) a * ⇑(clifford_algebra.ι Q) b + ⇑(clifford_algebra.ι Q) b * ⇑(clifford_algebra.ι Q) a = ⇑(algebra_map R (clifford_algebra Q)) (quadratic_form.polar ⇑Q a b)
theorem con.ker_lift_injective {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] (f : M →* P) : function.injective ⇑(con.ker_lift f)
theorem intermediate_field.ext {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] {S T : intermediate_field K L} (h : ∀ (x : L), x ∈ S ↔ x ∈ T) : S = T
theorem lie_ideal.map_bracket_le {R : Type u} {L : Type v} {L' : Type w₂} [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] (f : L →ₗ⁅R⁆ L') {I₁ I₂ : lie_ideal R L} : lie_ideal.map f ⁅I₁,I₂⁆ ≤ ⁅lie_ideal.map f I₁,lie_ideal.map f I₂⁆
theorem is_closed_frontier {α : Type u} [topological_space α] {s : set α} : is_closed (frontier s)
theorem subgroup.bot_or_exists_ne_one {G : Type u_1} [group G] (H : subgroup G) : H = ⊥ ∨ ∃ (x : G) (H : x ∈ H), x ≠ 1
theorem is_bounded_bilinear_map.continuous {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {f : E × F → G} (h : is_bounded_bilinear_map 𝕜 f) : continuous f
theorem dist_le_Ico_sum_of_dist_le {α : Type u} [pseudo_metric_space α] {f : ℕ → α} {m n : ℕ} (hmn : m ≤ n) {d : ℕ → ℝ} (hd : ∀ {k : ℕ}, m ≤ k → k < n → has_dist.dist (f k) (f (k + 1)) ≤ d k) : has_dist.dist (f m) (f n) ≤ (finset.Ico m n).sum (λ (i : ℕ), d i)
theorem integral_closure.is_fraction_ring_of_algebraic {A : Type u_4} [comm_ring A] [is_domain A] {L : Type u_6} [field L] [algebra A L] (alg : algebra.is_algebraic A L) (inj : ∀ (x : A), ⇑(algebra_map A L) x = 0 → x = 0) : is_fraction_ring ↥(integral_closure A L) L
theorem formal_multilinear_series.comp_partial_sum {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] [normed_group G] [normed_space 𝕜 G] (q : formal_multilinear_series 𝕜 F G) (p : formal_multilinear_series 𝕜 E F) (N : ℕ) (z : E) : q.partial_sum N ((finset.Ico 1 N).sum (λ (i : ℕ), ⇑(p i) (λ (j : fin i), z))) = (formal_multilinear_series.comp_partial_sum_target 0 N N).sum (λ (i : Σ (n : ℕ), composition n), ⇑(q.comp_along_composition p i.snd) (λ (j : fin i.fst), z))
theorem dite_eq_ite {α : Sort u_1} (P : Prop) [decidable P] (a b : α) : dite P (λ (h : P), a) (λ (h : ¬P), b) = ite P a b
theorem is_compact_pi_infinite {ι : Type u_1} {π : ι → Type u_2} [Π (i : ι), topological_space (π i)] {s : Π (i : ι), set (π i)} : (∀ (i : ι), is_compact (s i)) → is_compact {x : Π (i : ι), π i | ∀ (i : ι), x i ∈ s i}
theorem tendsto_uniformly.comp {α : Type u_1} {β : Type u_2} {γ : Type u_3} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {p : filter ι} (h : tendsto_uniformly F f p) (g : γ → α) : tendsto_uniformly (λ (n : ι), F n ∘ g) (f ∘ g) p
theorem category_theory.limits.mono_factorisation.ext {C : Type u} [category_theory.category C] {X Y : C} {f : X ⟶ Y} {F F' : category_theory.limits.mono_factorisation f} (hI : F.I = F'.I) (hm : F.m = category_theory.eq_to_hom hI ≫ F'.m) : F = F'
theorem measure_theory.uniform_integrable_of {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [normed_group β] {p : ennreal} {f : ι → α → β} [measure_theory.is_finite_measure μ] (hp : 1 ≤ p) (hp' : p ≠ ⊤) (hf : ∀ (i : ι), measure_theory.strongly_measurable (f i)) (h : ∀ (ε : ℝ), 0 < ε → (∃ (C : nnreal), ∀ (i : ι), measure_theory.snorm ({x : α | C ≤ ∥f i x∥₊}.indicator (f i)) p μ ≤ ennreal.of_real ε)) : measure_theory.uniform_integrable f p μ
theorem affine.simplex.circumcenter_eq_point {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (s : affine.simplex ℝ P 0) (i : fin 1) : s.circumcenter = s.points i
theorem exists_idempotent_of_compact_t2_of_continuous_mul_left {M : Type u_1} [nonempty M] [semigroup M] [topological_space M] [compact_space M] [t2_space M] (continuous_mul_left : ∀ (r : M), continuous (λ (_x : M), _x * r)) : ∃ (m : M), m * m = m
theorem units.is_smul_regular {R : Type u_1} (M : Type u_3) [monoid R] [mul_action R M] (a : Rˣ) : is_smul_regular M ↑a
theorem parser.nat_of_done_bounded {cb : char_buffer} {n n' val : ℕ} (h : parser.nat cb n = parse_result.done n' val) (hn : n' < buffer.size cb) : '0' ≤ buffer.read cb ⟨n', hn⟩ → '9' < buffer.read cb ⟨n', hn⟩
theorem function.commute.left_bij_on_fixed_pts_comp {α : Type u} {f g : α → α} (h : function.commute f g) : set.bij_on f (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g))
theorem norm_eq_infi_iff_real_inner_eq_zero {F : Type u_3} [inner_product_space ℝ F] (K : submodule ℝ F) {u v : F} (hv : v ∈ K) : (∥u - v∥ = ⨅ (w : ↥↑K), ∥u - ↑w∥) ↔ ∀ (w : F), w ∈ K → has_inner.inner (u - v) w = 0
theorem is_max_filter.undual {α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α} : is_max_filter (⇑order_dual.to_dual ∘ f) l a → is_min_filter f l a
theorem matrix.finrank_matrix {m : Type u_1} {n : Type u_2} [fintype m] [fintype n] {R : Type v} [field R] : finite_dimensional.finrank R (matrix m n R) = fintype.card m * fintype.card n
theorem probability_theory.indep_fun.variance_add {Ω : Type u_1} [measure_theory.measure_space Ω] [measure_theory.is_probability_measure measure_theory.measure_space.volume] {X Y : Ω → ℝ} (hX : measure_theory.mem_ℒp X 2 measure_theory.measure_space.volume) (hY : measure_theory.mem_ℒp Y 2 measure_theory.measure_space.volume) (h : probability_theory.indep_fun X Y measure_theory.measure_space.volume) : probability_theory.variance (X + Y) measure_theory.measure_space.volume = probability_theory.variance X measure_theory.measure_space.volume + probability_theory.variance Y measure_theory.measure_space.volume
theorem has_strict_fderiv_at.exists_lipschitz_on_with_of_nnnorm_lt {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {x : E} (hf : has_strict_fderiv_at f f' x) (K : nnreal) (hK : ∥f'∥₊ < K) : ∃ (s : set E) (H : s ∈ nhds x), lipschitz_on_with K f s
theorem pnat.prod_factor_multiset (n : ℕ+) : n.factor_multiset.prod = n
theorem left.mul_lt_one {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1
theorem category_theory.is_pullback.zero_top {C : Type u₁} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] (X : C) : category_theory.is_pullback 0 0 0 (𝟙 X)
theorem con.pow {M : Type u_1} [monoid M] (c : con M) (n : ℕ) {w x : M} : ⇑c w x → ⇑c (w ^ n) (x ^ n)
theorem finsupp.single_left_injective {α : Type u_1} {M : Type u_5} [has_zero M] {b : M} (h : b ≠ 0) : function.injective (λ (a : α), finsupp.single a b)
theorem category_theory.is_iso.of_mono_retraction {C : Type u₁} [category_theory.category C] {X Y : C} {f : X ⟶ Y} [category_theory.split_mono f] [category_theory.mono (category_theory.retraction f)] : category_theory.is_iso f
theorem power_series.order_eq_nat {R : Type u_1} [semiring R] {φ : power_series R} {n : ℕ} : φ.order = ↑n ↔ ⇑(power_series.coeff R n) φ ≠ 0 ∧ ∀ (i : ℕ), i < n → ⇑(power_series.coeff R i) φ = 0
theorem dfinsupp.single_eq_of_sigma_eq {ι : Type u} {β : ι → Type v} [dec : decidable_eq ι] [Π (i : ι), has_zero (β i)] {i j : ι} {xi : β i} {xj : β j} (h : ⟨i, xi⟩ = ⟨j, xj⟩) : dfinsupp.single i xi = dfinsupp.single j xj
theorem matrix.det_zero_of_row_eq {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] {M : matrix n n R} {i j : n} (i_ne_j : i ≠ j) (hij : M i = M j) : M.det = 0
theorem ennreal.tsum_geometric (r : ennreal) : ∑' (n : ℕ), r ^ n = (1 - r)⁻¹
theorem witt_vector.mul_is_poly₂ {p : ℕ} [fact (nat.prime p)] : witt_vector.is_poly₂ p (λ (_x : Type u_1) (_x_1 : comm_ring _x), has_mul.mul)
theorem valuation.ext_iff {R : Type u_2} {Γ₀ : Type u_3} [ring R] [linear_ordered_comm_monoid_with_zero Γ₀] {v₁ v₂ : valuation R Γ₀} : v₁ = v₂ ↔ ∀ (r : R), ⇑v₁ r = ⇑v₂ r
theorem lie_algebra.zero_root_subalgebra_is_cartan_of_eq (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (H : lie_subalgebra R L) [lie_algebra.is_nilpotent R ↥H] (h : lie_algebra.zero_root_subalgebra R L H = H) : H.is_cartan_subalgebra
theorem finset.slice_subset {α : Type u_1} {𝒜 : finset (finset α)} {r : ℕ} : 𝒜.slice r ⊆ 𝒜
theorem add_nonpos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0) : a + b ≤ 0
theorem orientation.oangle_rotation_self_left {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x : V} (hx : x ≠ 0) (θ : real.angle) : o.oangle (⇑(o.rotation θ) x) x = -θ
theorem concave_on.le_map_integral {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {f : α → E} {g : E → ℝ} [measure_theory.is_probability_measure μ] (hg : concave_on ℝ s g) (hgc : continuous_on g s) (hsc : is_closed s) (hfs : ∀ᵐ (x : α) ∂μ, f x ∈ s) (hfi : measure_theory.integrable f μ) (hgi : measure_theory.integrable (g ∘ f) μ) : ∫ (x : α), g (f x) ∂μ ≤ g (∫ (x : α), f x ∂μ)
theorem add_group.fg_iff {G : Type u_3} [add_group G] : add_group.fg G ↔ ∃ (S : set G), add_subgroup.closure S = ⊤ ∧ S.finite
theorem besicovitch.exists_closed_ball_covering_tsum_measure_le {α : Type u_1} [metric_space α] [topological_space.second_countable_topology α] [measurable_space α] [opens_measurable_space α] [has_besicovitch_covering α] (μ : measure_theory.measure α) [measure_theory.sigma_finite μ] [μ.outer_regular] {ε : ennreal} (hε : ε ≠ 0) (f : α → set ℝ) (s : set α) (hf : ∀ (x : α), x ∈ s → ∀ (δ : ℝ), δ > 0 → (f x ∩ set.Ioo 0 δ).nonempty) : ∃ (t : set α) (r : α → ℝ), t.countable ∧ t ⊆ s ∧ (∀ (x : α), x ∈ t → r x ∈ f x) ∧ (s ⊆ ⋃ (x : α) (H : x ∈ t), metric.closed_ball x (r x)) ∧ ∑' (x : ↥t), ⇑μ (metric.closed_ball ↑x (r ↑x)) ≤ ⇑μ s + ε
theorem tendsto_rpow_div_mul_add (a b c : ℝ) (hb : 0 ≠ b) : filter.tendsto (λ (x : ℝ), x ^ (a / (b * x + c))) filter.at_top (nhds 1)
theorem same_ray.of_neg {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R (-x) (-y) → same_ray R x y
theorem euclidean_geometry.inner_vsub_vsub_of_dist_eq_of_dist_eq {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {c₁ c₂ p₁ p₂ : P} (hc₁ : has_dist.dist p₁ c₁ = has_dist.dist p₂ c₁) (hc₂ : has_dist.dist p₁ c₂ = has_dist.dist p₂ c₂) : has_inner.inner (c₂ -ᵥ c₁) (p₂ -ᵥ p₁) = 0
theorem affine_independent.affine_span_image_finset_eq_of_le_of_card_eq_finrank_add_one {k : Type u_1} {V : Type u_2} {P : Type u_3} {ι : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {p : ι → P} (hi : affine_independent k p) {s : finset ι} {sp : affine_subspace k P} [finite_dimensional k ↥(sp.direction)] (hle : affine_span k ↑(finset.image p s) ≤ sp) (hc : s.card = finite_dimensional.finrank k ↥(sp.direction) + 1) : affine_span k ↑(finset.image p s) = sp
theorem summable_iff_cauchy_seq_finset {α : Type u_1} {β : Type u_2} [add_comm_group α] [uniform_space α] [complete_space α] {f : β → α} : summable f ↔ cauchy_seq (λ (s : finset β), s.sum (λ (b : β), f b))
theorem continuous_on.integral_sub_linear_is_o_ae {α : Type u_1} {E : Type u_3} [measurable_space α] {ι : Type u_5} [normed_group E] [topological_space α] [opens_measurable_space α] [normed_space ℝ E] [complete_space E] [second_countable_topology_either α E] {μ : measure_theory.measure α} [measure_theory.is_locally_finite_measure μ] {a : α} {t : set α} {f : α → E} (hft : continuous_on f t) (ha : a ∈ t) (ht : measurable_set t) {s : ι → set α} {li : filter ι} (hs : filter.tendsto s li (nhds_within a t).small_sets) (m : ι → ℝ := λ (i : ι), (⇑μ (s i)).to_real) (hsμ : (λ (i : ι), (⇑μ (s i)).to_real) =ᶠ[li] m . "refl") : (λ (i : ι), ∫ (x : α) in s i, f x ∂μ - m i • f a) =o[li] m
theorem finset.eq_weighted_vsub_subset_iff_eq_weighted_vsub_subtype (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} {v : V} {s : set ι} {p : ι → P} : (∃ (fs : finset ι) (hfs : ↑fs ⊆ s) (w : ι → k) (hw : fs.sum (λ (i : ι), w i) = 0), v = ⇑(fs.weighted_vsub p) w) ↔ ∃ (fs : finset ↥s) (w : ↥s → k) (hw : fs.sum (λ (i : ↥s), w i) = 0), v = ⇑(fs.weighted_vsub (λ (i : ↥s), p ↑i)) w
theorem set.subsingleton.preimage {α : Type u} {β : Type v} {s : set β} (hs : s.subsingleton) {f : α → β} (hf : function.injective f) : (f ⁻¹' s).subsingleton
theorem measure_theory.Lp.induction_strongly_measurable {α : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space α} {μ : measure_theory.measure α} [fact (1 ≤ p)] [normed_space ℝ F] (hm : m ≤ m0) (hp_ne_top : p ≠ ⊤) (P : ↥(measure_theory.Lp F p μ) → Prop) (h_ind : ∀ (c : F) {s : set α} (hs : measurable_set s) (hμs : ⇑μ s < ⊤), P ↑(measure_theory.Lp.simple_func.indicator_const p _ _ c)) (h_add : ∀ ⦃f g : α → F⦄ (hf : measure_theory.mem_ℒp f p μ) (hg : measure_theory.mem_ℒp g p μ), measure_theory.strongly_measurable f → measure_theory.strongly_measurable g → disjoint (function.support f) (function.support g) → P (measure_theory.mem_ℒp.to_Lp f hf) → P (measure_theory.mem_ℒp.to_Lp g hg) → P (measure_theory.mem_ℒp.to_Lp f hf + measure_theory.mem_ℒp.to_Lp g hg)) (h_closed : is_closed {f : ↥(measure_theory.Lp_meas F ℝ m p μ) | P ↑f}) (f : ↥(measure_theory.Lp F p μ)) : measure_theory.ae_strongly_measurable' m ⇑f μ → P f
theorem is_noetherian_def {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] : is_noetherian R M ↔ ∀ (s : submodule R M), s.fg
theorem is_connected.Ioo_cInf_cSup_subset {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {s : set α} (hs : is_connected s) (hb : bdd_below s) (ha : bdd_above s) : set.Ioo (has_Inf.Inf s) (has_Sup.Sup s) ⊆ s
theorem algebraic_independent.restrict_scalars {ι : Type u_1} {R : Type u_3} {A : Type u_5} {x : ι → A} [comm_ring R] [comm_ring A] [algebra R A] {K : Type u_2} [comm_ring K] [algebra R K] [algebra K A] [is_scalar_tower R K A] (hinj : function.injective ⇑(algebra_map R K)) (ai : algebraic_independent K x) : algebraic_independent R x
theorem cont_diff_at.has_strict_fderiv_at {n : with_top ℕ} {𝕂 : Type u_6} [is_R_or_C 𝕂] {E' : Type u_7} [normed_group E'] [normed_space 𝕂 E'] {F' : Type u_8} [normed_group F'] [normed_space 𝕂 F'] {f : E' → F'} {x : E'} (hf : cont_diff_at 𝕂 n f x) (hn : 1 ≤ n) : has_strict_fderiv_at f (fderiv 𝕂 f x) x
theorem or_and_distrib_left {a b c : Prop} : a ∨ b ∧ c ↔ (a ∨ b) ∧ (a ∨ c)
theorem cont_mdiff_on.cont_diff_on {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {n : with_top ℕ} {f : E → E'} {s : set E} : cont_mdiff_on (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n f s → cont_diff_on 𝕜 n f s
theorem multilinear_map.dom_dom_congr_eq_iff {R : Type u} {M₂ : Type v₂} {M₃ : Type v₃} [semiring R] [add_comm_monoid M₂] [add_comm_monoid M₃] [module R M₂] [module R M₃] {ι₁ : Type u_1} {ι₂ : Type u_2} [decidable_eq ι₁] [decidable_eq ι₂] (σ : ι₁ ≃ ι₂) (f g : multilinear_map R (λ (i : ι₁), M₂) M₃) : multilinear_map.dom_dom_congr σ f = multilinear_map.dom_dom_congr σ g ↔ f = g
theorem set.measure_eq_infi_is_open {α : Type u_1} [measurable_space α] [topological_space α] (A : set α) (μ : measure_theory.measure α) [μ.outer_regular] : ⇑μ A = ⨅ (U : set α) (h : A ⊆ U) (h2 : is_open U), ⇑μ U
theorem measure_theory.tendsto_integral_of_dominated_convergence {α : Type u_1} {E : Type u_2} [normed_group E] [normed_space ℝ E] [complete_space E] {m : measurable_space α} {μ : measure_theory.measure α} {F : ℕ → α → E} {f : α → E} (bound : α → ℝ) (F_measurable : ∀ (n : ℕ), measure_theory.ae_strongly_measurable (F n) μ) (bound_integrable : measure_theory.integrable bound μ) (h_bound : ∀ (n : ℕ), ∀ᵐ (a : α) ∂μ, ∥F n a∥ ≤ bound a) (h_lim : ∀ᵐ (a : α) ∂μ, filter.tendsto (λ (n : ℕ), F n a) filter.at_top (nhds (f a))) : filter.tendsto (λ (n : ℕ), ∫ (a : α), F n a ∂μ) filter.at_top (nhds (∫ (a : α), f a ∂μ))
theorem fintype.prod_equiv {α : Type u_1} {β : Type u_2} {M : Type u_3} [fintype α] [fintype β] [comm_monoid M] (e : α ≃ β) (f : α → M) (g : β → M) (h : ∀ (x : α), f x = g (⇑e x)) : finset.univ.prod (λ (x : α), f x) = finset.univ.prod (λ (x : β), g x)
theorem mul_lt_one' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1
theorem list.subperm_ext_iff {α : Type uu} [decidable_eq α] {l₁ l₂ : list α} : l₁ <+~ l₂ ↔ ∀ (x : α), x ∈ l₁ → list.count x l₁ ≤ list.count x l₂
theorem with_top.sum_lt_top_iff {ι : Type u_1} {M : Type u_4} [ordered_add_comm_monoid M] {s : finset ι} {f : ι → with_top M} : s.sum (λ (i : ι), f i) < ⊤ ↔ ∀ (i : ι), i ∈ s → f i < ⊤
theorem orthonormal.two_zsmul_oangle_sub_eq_two_zsmul_oangle_sub_of_norm_eq {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x₁ x₂ y z : V} (hx₁yne : x₁ ≠ y) (hx₁zne : x₁ ≠ z) (hx₂yne : x₂ ≠ y) (hx₂zne : x₂ ≠ z) {r : ℝ} (hx₁ : ∥x₁∥ = r) (hx₂ : ∥x₂∥ = r) (hy : ∥y∥ = r) (hz : ∥z∥ = r) : 2 • hb.oangle (y - x₁) (z - x₁) = 2 • hb.oangle (y - x₂) (z - x₂)
theorem filter.tendsto.integrable_at_filter_ae {α : Type u_1} {E : Type u_3} [measurable_space α] [normed_group E] {f : α → E} {μ : measure_theory.measure α} {l : filter α} [l.is_measurably_generated] (hfm : strongly_measurable_at_filter f l μ) (hμ : μ.finite_at_filter l) {b : E} (hf : filter.tendsto f (l ⊓ μ.ae) (nhds b)) : measure_theory.integrable_at_filter f l μ
theorem ring_equiv.is_domain {A : Type u_1} (B : Type u_2) [ring A] [ring B] [is_domain B] (e : A ≃+* B) : is_domain A
theorem cont_diff_on.smul {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : with_top ℕ} {s : set E} {f : E → 𝕜} {g : E → F} (hf : cont_diff_on 𝕜 n f s) (hg : cont_diff_on 𝕜 n g s) : cont_diff_on 𝕜 n (λ (x : E), f x • g x) s
theorem affine_subspace.direction_eq_vector_span {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : affine_subspace k P) : s.direction = vector_span k ↑s
theorem complex.integral_boundary_rect_of_continuous_on_of_has_fderiv_at_real {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] (f : ℂ → E) (f' : ℂ → (ℂ →L[ℝ] E)) (z w : ℂ) (Hc : continuous_on f (set.interval z.re w.re ×ℂ set.interval z.im w.im)) (Hd : ∀ (x : ℂ), x ∈ set.Ioo (linear_order.min z.re w.re) (linear_order.max z.re w.re) ×ℂ set.Ioo (linear_order.min z.im w.im) (linear_order.max z.im w.im) → has_fderiv_at f (f' x) x) (Hi : measure_theory.integrable_on (λ (z : ℂ), complex.I • ⇑(f' z) 1 - ⇑(f' z) complex.I) (set.interval z.re w.re ×ℂ set.interval z.im w.im) measure_theory.measure_space.volume) : (((∫ (x : ℝ) in z.re..w.re, f (↑x + ↑(z.im) * complex.I)) - ∫ (x : ℝ) in z.re..w.re, f (↑x + ↑(w.im) * complex.I)) + complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑(w.re) + ↑y * complex.I)) - complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑(z.re) + ↑y * complex.I) = ∫ (x : ℝ) in z.re..w.re, ∫ (y : ℝ) in z.im..w.im, complex.I • ⇑(f' (↑x + ↑y * complex.I)) 1 - ⇑(f' (↑x + ↑y * complex.I)) complex.I
theorem generalized_continued_fraction.of_part_num_eq_one {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {a : K} (nth_part_num_eq : (generalized_continued_fraction.of v).partial_numerators.nth n = option.some a) : a = 1
theorem fintype.exists_card_fiber_lt_of_card_lt_nsmul {α : Type u} {β : Type v} {M : Type w} [decidable_eq β] [fintype α] [fintype β] (f : α → β) {b : M} [linear_ordered_comm_ring M] (hb : ↑(fintype.card α) < fintype.card β • b) : ∃ (y : β), ↑((finset.filter (λ (x : α), f x = y) finset.univ).card) < b
theorem has_lt.lt.asymm {α : Type u} [preorder α] {a b : α} (h : a < b) : ¬b < a
theorem lp.has_sum_single {α : Type u_1} {E : α → Type u_2} {p : ennreal} [Π (i : α), normed_group (E i)] [decidable_eq α] [fact (1 ≤ p)] (hp : p ≠ ⊤) (f : ↥(lp E p)) : has_sum (λ (i : α), lp.single p i (⇑f i)) f
theorem add_commute.is_of_fin_order_add {G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)
theorem polynomial.chebyshev.T_complex_cos (θ : ℂ) (n : ℕ) : polynomial.eval (complex.cos θ) (polynomial.chebyshev.T ℂ n) = complex.cos (↑n * θ)
theorem basis.orientation_comp_linear_equiv_eq_iff_det_pos {R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {ι : Type u_3} [decidable_eq ι] [fintype ι] (e : basis ι R M) (f : M ≃ₗ[R] M) : (e.map f).orientation = e.orientation ↔ 0 < ⇑linear_map.det ↑f
theorem polynomial.bernoulli_generating_function {A : Type u_1} [comm_ring A] [algebra ℚ A] (t : A) : power_series.mk (λ (n : ℕ), ⇑(polynomial.aeval t) ((1 / ↑(n.factorial)) • polynomial.bernoulli n)) * (power_series.exp A - 1) = power_series.X * ⇑(power_series.rescale t) (power_series.exp A)
theorem is_cyclotomic_extension.rat.cyclotomic_ring_is_integral_closure_of_prime_pow {p : ℕ+} {k : ℕ} [hp : fact (nat.prime ↑p)] : is_integral_closure (cyclotomic_ring (p ^ k) ℤ ℚ) ℤ (cyclotomic_field (p ^ k) ℚ)
theorem derangements.equiv.remove_none.fiber_some {α : Type u_1} [decidable_eq α] (a : α) : derangements.equiv.remove_none.fiber (option.some a) = {f : equiv.perm α | function.fixed_points ⇑f ⊆ {a}}
theorem ring.direct_limit.exists_of {ι : Type v} [preorder ι] {G : ι → Type w} [Π (i : ι), comm_ring (G i)] {f : Π (i j : ι), i ≤ j → G i → G j} [nonempty ι] [is_directed ι has_le.le] (z : ring.direct_limit G f) : ∃ (i : ι) (x : G i), ⇑(ring.direct_limit.of G f i) x = z
theorem add_subsemigroup.ext {M : Type u_1} [has_add M] {S T : add_subsemigroup M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T) : S = T
theorem has_dvd.dvd.pow {M : Type u} [monoid M] {x y : M} (hxy : x ∣ y) {n : ℕ} (hn : n ≠ 0) : x ∣ y ^ n
theorem antilipschitz_with.le_mul_dist {α : Type u_1} {β : Type u_2} [pseudo_metric_space α] [pseudo_metric_space β] {K : nnreal} {f : α → β} : antilipschitz_with K f → ∀ (x y : α), has_dist.dist x y ≤ ↑K * has_dist.dist (f x) (f y)
theorem exists_Union_ball_eq_radius_pos_lt {α : Type u} {ι : Type v} [metric_space α] [proper_space α] {c : ι → α} {r : ι → ℝ} (hr : ∀ (i : ι), 0 < r i) (uf : ∀ (x : α), {i : ι | x ∈ metric.ball (c i) (r i)}.finite) (uU : (⋃ (i : ι), metric.ball (c i) (r i)) = set.univ) : ∃ (r' : ι → ℝ), (⋃ (i : ι), metric.ball (c i) (r' i)) = set.univ ∧ ∀ (i : ι), r' i ∈ set.Ioo 0 (r i)
theorem has_mfderiv_at.has_fderiv_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {f : E → E'} {x : E} {f' : tangent_space (model_with_corners_self 𝕜 E) x →L[𝕜] tangent_space (model_with_corners_self 𝕜 E') (f x)} : has_mfderiv_at (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f x f' → has_fderiv_at f f' x
theorem is_torsion_free.add_subgroup {G : Type u_1} [add_group G] (tG : add_monoid.is_torsion_free G) (H : add_subgroup G) : add_monoid.is_torsion_free ↥H
theorem metric.inf_dist_le_inf_dist_add_dist {α : Type u} [pseudo_metric_space α] {s : set α} {x y : α} : metric.inf_dist x s ≤ metric.inf_dist y s + has_dist.dist x y
theorem add_submonoid.localization_map.map_comp_map {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M →+ P} {T : add_submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ T) {Q : Type u_4} [add_comm_monoid Q] {k : T.localization_map Q} {A : Type u_5} [add_comm_monoid A] {U : add_submonoid A} {R : Type u_6} [add_comm_monoid R] (j : U.localization_map R) {l : P →+ A} (hl : ∀ (w : ↥T), ⇑l ↑w ∈ U) : (k.map hl j).comp (f.map hy k) = f.map _ j
theorem has_lt.lt.eq_top {α : Type u_1} [preorder α] [bounded_order α] [is_simple_order α] {a b : α} (h : a < b) : b = ⊤
theorem map_lt_line_map_iff_slope_lt_slope {k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k → E} {a b r : k} (hab : a < b) (h₀ : 0 < r) (h₁ : r < 1) : f (⇑(affine_map.line_map a b) r) < ⇑(affine_map.line_map (f a) (f b)) r ↔ slope f a (⇑(affine_map.line_map a b) r) < slope f (⇑(affine_map.line_map a b) r) b
theorem minpoly.gcd_domain_eq_field_fractions {A : Type u_1} {R : Type u_2} (K : Type u_3) [comm_ring A] [is_domain A] [normalized_gcd_monoid A] [field K] [comm_ring R] [is_domain R] [algebra A K] [is_fraction_ring A K] [algebra K R] [algebra A R] [is_scalar_tower A K R] {x : R} (hx : is_integral A x) : minpoly K x = polynomial.map (algebra_map A K) (minpoly A x)
theorem is_smul_regular.of_mul_eq_one {R : Type u_1} {M : Type u_3} {a b : R} [monoid R] [mul_action R M] (h : a * b = 1) : is_smul_regular M b
theorem cont_diff_at.fst' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {n : with_top ℕ} {f : E → G} {x : E} {y : F} (hf : cont_diff_at 𝕜 n f x) : cont_diff_at 𝕜 n (λ (x : E × F), f x.fst) (x, y)
theorem cont_diff.sub {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : with_top ℕ} {f g : E → F} (hf : cont_diff 𝕜 n f) (hg : cont_diff 𝕜 n g) : cont_diff 𝕜 n (λ (x : E), f x - g x)
theorem measure_theory.signed_measure.exists_compl_positive_negative {α : Type u_1} [measurable_space α] (s : measure_theory.signed_measure α) : ∃ (i : set α), measurable_set i ∧ 0.restrict i ≤ measure_theory.vector_measure.restrict s i ∧ measure_theory.vector_measure.restrict s iᶜ ≤ 0.restrict iᶜ
theorem metric.diam_le_of_forall_dist_le {α : Type u} [pseudo_metric_space α] {s : set α} {C : ℝ} (h₀ : 0 ≤ C) (h : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → has_dist.dist x y ≤ C) : metric.diam s ≤ C
theorem cont_diff_at.prod {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {x : E} {n : with_top ℕ} {f : E → F} {g : E → G} (hf : cont_diff_at 𝕜 n f x) (hg : cont_diff_at 𝕜 n g x) : cont_diff_at 𝕜 n (λ (x : E), (f x, g x)) x
theorem is_noetherian.iff_fg {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V ↔ module.finite K V
theorem module.free.rank_matrix'' (R : Type u) [ring R] [strong_rank_condition R] (m n : Type u) [fintype m] [fintype n] : module.rank R (matrix m n R) = cardinal.mk m * cardinal.mk n
theorem has_le.le.lt_of_ne {α : Type u} [partial_order α] {a b : α} : a ≤ b → a ≠ b → a < b
theorem mul_ne_zero_comm {M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b ≠ 0 ↔ b * a ≠ 0
theorem trans_gen_of_succ_of_lt {α : Type u_1} [partial_order α] [succ_order α] [is_succ_archimedean α] (r : α → α → Prop) {n m : α} (h : ∀ (i : α), i ∈ set.Ico n m → r i (order.succ i)) (hnm : n < m) : relation.trans_gen r n m
theorem is_noetherian_ring_iff_ideal_fg (R : Type u_1) [semiring R] : is_noetherian_ring R ↔ ∀ (I : ideal R), I.fg
theorem is_integer_of_is_root_of_monic {A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} (hp : p.monic) {r : K} (hr : ⇑(polynomial.aeval r) p = 0) : is_localization.is_integer A r
theorem orthogonal_projection_singleton (𝕜 : Type u_1) {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {v : E} (w : E) : ↑(⇑(orthogonal_projection (submodule.span 𝕜 {v})) w) = (has_inner.inner v w / ↑∥v∥ ^ 2) • v
theorem monotone.continuous_of_surjective {α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} (h_mono : monotone f) (h_surj : function.surjective f) : continuous f
theorem set.finite_or_infinite {α : Type u} {s : set α} : s.finite ∨ s.infinite
theorem submodule.complete_of_finite_dimensional {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {E : Type v} [normed_group E] [normed_space 𝕜 E] [complete_space 𝕜] (s : submodule 𝕜 E) [finite_dimensional 𝕜 ↥s] : is_complete ↑s
theorem right.add_pos_of_nonneg_of_pos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 < b) : 0 < a + b
theorem measure_theory.exists_nonempty_inter_of_measure_univ_lt_tsum_measure {α : Type u_1} {ι : Type u_5} {m : measurable_space α} (μ : measure_theory.measure α) {s : ι → set α} (hs : ∀ (i : ι), measurable_set (s i)) (H : ⇑μ set.univ < ∑' (i : ι), ⇑μ (s i)) : ∃ (i j : ι) (h : i ≠ j), (s i ∩ s j).nonempty
theorem normed_space.sphere_nonempty {E : Type u_2} [normed_group E] [normed_space ℝ E] [nontrivial E] {x : E} {r : ℝ} : (metric.sphere x r).nonempty ↔ 0 ≤ r
theorem finset.sum_le_sum {ι : Type u_1} {N : Type u_5} [ordered_add_comm_monoid N] {f g : ι → N} {s : finset ι} (h : ∀ (i : ι), i ∈ s → f i ≤ g i) : s.sum (λ (i : ι), f i) ≤ s.sum (λ (i : ι), g i)
theorem orthonormal.inner_sum {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : orthonormal 𝕜 v) (l₁ l₂ : ι → 𝕜) (s : finset ι) : has_inner.inner (s.sum (λ (i : ι), l₁ i • v i)) (s.sum (λ (i : ι), l₂ i • v i)) = s.sum (λ (i : ι), ⇑(star_ring_end 𝕜) (l₁ i) * l₂ i)
theorem vsub_eq_sub {G : Type u_1} [add_group G] (g1 g2 : G) : g1 -ᵥ g2 = g1 - g2
theorem euclidean_geometry.cospherical_def {P : Type u_2} [metric_space P] (ps : set P) : euclidean_geometry.cospherical ps ↔ ∃ (center : P) (radius : ℝ), ∀ (p : P), p ∈ ps → has_dist.dist p center = radius
theorem smooth_bump_function.nhds_within_range_basis {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {c : M} : (nhds_within (⇑(ext_chart_at I c) c) (set.range ⇑I)).has_basis (λ (f : smooth_bump_function I c), true) (λ (f : smooth_bump_function I c), euclidean.closed_ball (⇑(ext_chart_at I c) c) f.to_cont_diff_bump.to_cont_diff_bump_of_inner.R ∩ set.range ⇑I)
theorem lower_semicontinuous_on.add {α : Type u_1} [topological_space α] {s : set α} {γ : Type u_4} [linear_ordered_add_comm_monoid γ] [topological_space γ] [order_topology γ] [has_continuous_add γ] {f g : α → γ} (hf : lower_semicontinuous_on f s) (hg : lower_semicontinuous_on g s) : lower_semicontinuous_on (λ (z : α), f z + g z) s
theorem minpoly.degree_le_of_ne_zero (A : Type u_1) {B : Type u_2} [field A] [ring B] [algebra A B] (x : B) {p : polynomial A} (pnz : p ≠ 0) (hp : ⇑(polynomial.aeval x) p = 0) : (minpoly A x).degree ≤ p.degree
theorem isometry.continuous {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} (hf : isometry f) : continuous f
theorem linear_map.ext_ring {R : Type u_1} {S : Type u_6} {M₃ : Type u_12} [semiring R] [semiring S] [add_comm_monoid M₃] [module S M₃] {σ : R →+* S} {f g : R →ₛₗ[σ] M₃} (h : ⇑f 1 = ⇑g 1) : f = g
theorem finite_of_fin_dim_affine_independent (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [finite_dimensional k V] {s : set P} (hi : affine_independent k coe) : s.finite
theorem zero_hom.coe_inj {M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] ⦃f g : zero_hom M N⦄ (h : ⇑f = ⇑g) : f = g
theorem simple_graph.walk.edges_subset_edge_set {V : Type u} {G : simple_graph V} {u v : V} (p : G.walk u v) ⦃e : sym2 V⦄ (h : e ∈ p.edges) : e ∈ G.edge_set
theorem measure_theory.measure.ext_of_Ico' {α : Type u_1} [topological_space α] {m : measurable_space α} [topological_space.second_countable_topology α] [linear_order α] [order_topology α] [borel_space α] [no_max_order α] (μ ν : measure_theory.measure α) (hμ : ∀ ⦃a b : α⦄, a < b → ⇑μ (set.Ico a b) ≠ ⊤) (h : ∀ ⦃a b : α⦄, a < b → ⇑μ (set.Ico a b) = ⇑ν (set.Ico a b)) : μ = ν
theorem is_primitive_root.nth_roots_nodup {R : Type u_5} [comm_ring R] [is_domain R] {ζ : R} {n : ℕ} (h : is_primitive_root ζ n) : (polynomial.nth_roots n 1).nodup
theorem summable_of_norm_bounded_eventually {ι : Type u_1} {E : Type u_3} [semi_normed_group E] [complete_space E] {f : ι → E} (g : ι → ℝ) (hg : summable g) (h : ∀ᶠ (i : ι) in filter.cofinite, ∥f i∥ ≤ g i) : summable f
theorem le_add_of_sub_left_le {α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : a - b ≤ c → a ≤ b + c
theorem metric.Hausdorff_dist_self_zero {α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist s s = 0
theorem submodule.torsion_by_set_is_internal {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {ι : Type u_3} [decidable_eq ι] {S : finset ι} {p : ι → ideal R} (hp : ↑S.pairwise (λ (i j : ι), p i ⊔ p j = ⊤)) (hM : module.is_torsion_by_set R M (↑⨅ (i : ι) (H : i ∈ S), p i)) : direct_sum.is_internal (λ (i : ↥S), submodule.torsion_by_set R M ↑(p ↑i))
theorem subfield.subset_closure {K : Type u} [field K] {s : set K} : s ⊆ ↑(subfield.closure s)
theorem direct_sum.coe_ring_hom_of {ι : Type u_1} {R : Type u_4} [decidable_eq ι] [add_monoid ι] [semiring R] (A : ι → add_submonoid R) [set_like.graded_monoid A] (i : ι) (x : ↥(A i)) : ⇑(direct_sum.coe_ring_hom A) (⇑(direct_sum.of (λ (i : ι), ↥(A i)) i) x) = ↑x
theorem ordinal.unbounded_of_unbounded_Union {α β : Type u} (r : α → α → Prop) [wo : is_well_order α r] (s : β → set α) (h₁ : set.unbounded r (⋃ (x : β), s x)) (h₂ : cardinal.mk β < strict_order.cof r) : ∃ (x : β), set.unbounded r (s x)
theorem smooth_bump_function.nhds_basis_tsupport {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] (I : model_with_corners ℝ E H) {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] (c : M) [t2_space M] : (nhds c).has_basis (λ (f : smooth_bump_function I c), true) (λ (f : smooth_bump_function I c), tsupport ⇑f)
theorem category_theory.limits.has_limit_of_iso {J : Type u₁} [category_theory.category J] {C : Type u} [category_theory.category C] {F G : J ⥤ C} [category_theory.limits.has_limit F] (α : F ≅ G) : category_theory.limits.has_limit G
theorem euclidean_geometry.reflection_apply {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ℝ P) [nonempty ↥s] [complete_space ↥(s.direction)] (p : P) : ⇑(euclidean_geometry.reflection s) p = ↑(⇑(euclidean_geometry.orthogonal_projection s) p) -ᵥ p +ᵥ ↑(⇑(euclidean_geometry.orthogonal_projection s) p)
theorem fin.succ_above_below {n : ℕ} (p : fin (n + 1)) (i : fin n) (h : ⇑fin.cast_succ i < p) : ⇑(p.succ_above) i = ⇑fin.cast_succ i
theorem add_subgroup.add_normal {G : Type u_1} [add_group G] (H N : add_subgroup G) [N.normal] : ↑(H ⊔ N) = ↑H + ↑N
theorem finsum_mem_sUnion {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} {t : set (set α)} (h : t.pairwise_disjoint id) (ht₀ : t.finite) (ht₁ : ∀ (x : set α), x ∈ t → x.finite) : finsum (λ (a : α), finsum (λ (H : a ∈ ⋃₀t), f a)) = finsum (λ (s : set α), finsum (λ (H : s ∈ t), finsum (λ (a : α), finsum (λ (H : a ∈ s), f a))))
theorem summable.abs {α : Type u_1} {β : Type u_2} [linear_ordered_add_comm_group β] [uniform_space β] [uniform_add_group β] [complete_space β] {f : α → β} : summable f → summable (λ (x : α), |f x|)
theorem orientation.rotation_trans {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (θ₁ θ₂ : real.angle) : (o.rotation θ₁).trans (o.rotation θ₂) = o.rotation (θ₂ + θ₁)
theorem asymptotics.is_O_iff_eventually_is_O_with {α : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : α → E} {g' : α → F'} {l : filter α} : f =O[l] g' ↔ ∀ᶠ (c : ℝ) in filter.at_top, asymptotics.is_O_with c l f g'
theorem not_bdd_above_iff {α : Type u_1} [linear_order α] {s : set α} : ¬bdd_above s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), x < y
theorem matrix.inv_eq_right_inv {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {A B : matrix n n α} (h : A.mul B = 1) : A⁻¹ = B
theorem Top.sheaf.exists_unique_gluing' {C : Type u} [category_theory.category C] [category_theory.concrete_category C] [category_theory.limits.has_limits C] [category_theory.reflects_isomorphisms (category_theory.concrete_category.forget C)] [category_theory.limits.preserves_limits (category_theory.concrete_category.forget C)] {X : Top} (F : Top.sheaf C X) {ι : Type v} (U : ι → topological_space.opens ↥X) (V : topological_space.opens ↥X) (iUV : Π (i : ι), U i ⟶ V) (hcover : V ≤ supr U) (sf : Π (i : ι), ↥(F.val.obj (opposite.op (U i)))) (h : F.val.is_compatible U sf) : ∃! (s : ↥(F.val.obj (opposite.op V))), ∀ (i : ι), ⇑(F.val.map (iUV i).op) s = sf i
theorem nat.factorial_mul_asc_factorial (n k : ℕ) : n.factorial * n.asc_factorial k = (n + k).factorial
theorem measurable_equiv.measurable_embedding {α : Type u_1} {β : Type u_2} [measurable_space α] [measurable_space β] (e : α ≃ᵐ β) : measurable_embedding ⇑e
theorem real_inner_smul_self_right {F : Type u_3} [inner_product_space ℝ F] (x : F) (r : ℝ) : has_inner.inner x (r • x) = r * (∥x∥ * ∥x∥)
theorem orthonormal.oangle_rotation_left {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : real.angle) : hb.oangle (⇑(hb.rotation θ) x) y = hb.oangle x y - θ
theorem Compactum_to_CompHaus.ess_surj  : category_theory.ess_surj Compactum_to_CompHaus
theorem concave_on_open_of_deriv2_nonpos {D : set ℝ} (hD : convex ℝ D) (hD₂ : is_open D) {f : ℝ → ℝ} (hf' : differentiable_on ℝ f D) (hf'' : differentiable_on ℝ (deriv f) D) (hf''_nonpos : ∀ (x : ℝ), x ∈ D → deriv^[2] f x ≤ 0) : concave_on ℝ D f
theorem is_alg_closed.splits_domain {k : Type u_1} {K : Type u_2} [field k] [is_alg_closed k] [field K] {f : k →+* K} (p : polynomial k) : polynomial.splits f p
theorem affine_independent.vector_span_eq_top_of_card_eq_finrank_add_one {k : Type u_1} {V : Type u_2} {P : Type u_3} {ι : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [finite_dimensional k V] [fintype ι] {p : ι → P} (hi : affine_independent k p) (hc : fintype.card ι = finite_dimensional.finrank k V + 1) : vector_span k (set.range p) = ⊤
theorem category_theory.abelian.pseudoelement.zero_apply {C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (Q : C) (a : ↥P) : ⇑0 a = 0
theorem banach_steinhaus_supr_nnnorm {E : Type u_1} {F : Type u_2} {𝕜 : Type u_3} {𝕜₂ : Type u_4} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [ring_hom_isometric σ₁₂] {ι : Type u_5} [complete_space E] {g : ι → (E →SL[σ₁₂] F)} (h : ∀ (x : E), (⨆ (i : ι), ↑∥⇑(g i) x∥₊) < ⊤) : (⨆ (i : ι), ↑∥g i∥₊) < ⊤
theorem add_subgroup.mem_closure_singleton {G : Type u_1} [add_group G] {x y : G} : y ∈ add_subgroup.closure {x} ↔ ∃ (n : ℤ), n • x = y
theorem add_subgroup.add_mem {G : Type u_1} [add_group G] (H : add_subgroup G) {x y : G} : x ∈ H → y ∈ H → x + y ∈ H
theorem interval_integral.measure_integral_sub_integral_sub_linear_is_o_of_tendsto_ae_right {ι : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} {c : E} {lb lb' : filter ℝ} {lt : filter ι} {μ : measure_theory.measure ℝ} {u v : ι → ℝ} [interval_integral.FTC_filter b lb lb'] [measure_theory.is_locally_finite_measure μ] (hab : interval_integrable f μ a b) (hmeas : strongly_measurable_at_filter f lb' μ) (hf : filter.tendsto f (lb' ⊓ μ.ae) (nhds c)) (hu : filter.tendsto u lt lb) (hv : filter.tendsto v lt lb) : (λ (t : ι), ∫ (x : ℝ) in a..v t, f x ∂μ - ∫ (x : ℝ) in a..u t, f x ∂μ - ∫ (x : ℝ) in u t..v t, c ∂μ) =o[lt] λ (t : ι), ∫ (x : ℝ) in u t..v t, 1 ∂μ
theorem con.coe_one {M : Type u_1} [mul_one_class M] {c : con M} : ↑1 = 1
theorem is_regular.subsingleton {R : Type u_1} [mul_zero_class R] (h : is_regular 0) : subsingleton R
theorem category_theory.limits.has_limit_of_equalizer_and_product {C : Type u} [category_theory.category C] {J : Type v} [category_theory.small_category J] (F : J ⥤ C) [category_theory.limits.has_limit (category_theory.discrete.functor F.obj)] [category_theory.limits.has_limit (category_theory.discrete.functor (λ (f : Σ (p : J × J), p.fst ⟶ p.snd), F.obj f.fst.snd))] [category_theory.limits.has_equalizers C] : category_theory.limits.has_limit F
theorem nilpotency_class_pi {η : Type u_2} [fintype η] {Gs : η → Type u_3} [Π (i : η), group (Gs i)] [∀ (i : η), group.is_nilpotent (Gs i)] : group.nilpotency_class (Π (i : η), Gs i) = finset.univ.sup (λ (i : η), group.nilpotency_class (Gs i))
theorem inv_lt_one' {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a
theorem nat.totient_prime_pow_succ {p : ℕ} (hp : nat.prime p) (n : ℕ) : (p ^ (n + 1)).totient = p ^ n * (p - 1)
theorem edist_le_Ico_sum_of_edist_le {α : Type u} [pseudo_emetric_space α] {f : ℕ → α} {m n : ℕ} (hmn : m ≤ n) {d : ℕ → ennreal} (hd : ∀ {k : ℕ}, m ≤ k → k < n → has_edist.edist (f k) (f (k + 1)) ≤ d k) : has_edist.edist (f m) (f n) ≤ (finset.Ico m n).sum (λ (i : ℕ), d i)
theorem ring_equiv.map_one {R : Type u_4} {S : Type u_5} [non_assoc_semiring R] [non_assoc_semiring S] (f : R ≃+* S) : ⇑f 1 = 1
theorem euclidean_geometry.circumradius_eq_of_cospherical {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {ps : set P} {n : ℕ} [finite_dimensional ℝ V] (hd : finite_dimensional.finrank ℝ V = n) (hc : euclidean_geometry.cospherical ps) {sx₁ sx₂ : affine.simplex ℝ P n} (hsx₁ : set.range sx₁.points ⊆ ps) (hsx₂ : set.range sx₂.points ⊆ ps) : sx₁.circumradius = sx₂.circumradius
theorem list.nat.antidiagonal_zero  : list.nat.antidiagonal 0 = [(0, 0)]
theorem mul_lt_one_of_lt_of_le {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b ≤ 1) : a * b < 1
theorem ideal.map_comap_of_equiv {R : Type u} {S : Type v} [ring R] [ring S] (I : ideal R) (f : R ≃+* S) : ideal.map ↑f I = ideal.comap ↑(f.symm) I
theorem category_theory.unit_obj_eq_map_unit {C : Type u₁} {D : Type u₂} [category_theory.category C] [category_theory.category D] {i : D ⥤ C} [category_theory.reflective i] (X : C) : (category_theory.adjunction.of_right_adjoint i).unit.app (i.obj ((category_theory.left_adjoint i).obj X)) = i.map ((category_theory.left_adjoint i).map ((category_theory.adjunction.of_right_adjoint i).unit.app X))
theorem multiset.nat.antidiagonal_zero  : multiset.nat.antidiagonal 0 = {(0, 0)}
theorem is_compact.binary_compact_cover {α : Type u} [topological_space α] [t2_space α] {K U V : set α} (hK : is_compact K) (hU : is_open U) (hV : is_open V) (h2K : K ⊆ U ∪ V) : ∃ (K₁ K₂ : set α), is_compact K₁ ∧ is_compact K₂ ∧ K₁ ⊆ U ∧ K₂ ⊆ V ∧ K = K₁ ∪ K₂
theorem is_integral_trans {R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [comm_ring B] [algebra A B] [algebra R B] [algebra R A] [is_scalar_tower R A B] (A_int : algebra.is_integral R A) (x : B) (hx : is_integral A x) : is_integral R x
theorem pgame.lt_def {x y : pgame} (ox : x.numeric) (oy : y.numeric) : x < y ↔ (∃ (i : y.left_moves), (∀ (i' : x.left_moves), x.move_left i' < y.move_left i) ∧ ∀ (j : (y.move_left i).right_moves), x < (y.move_left i).move_right j) ∨ ∃ (j : x.right_moves), (∀ (i : (x.move_right j).left_moves), (x.move_right j).move_left i < y) ∧ ∀ (j' : y.right_moves), x.move_right j < y.move_right j'
theorem strict_concave_on.translate_right {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_cancel_comm_monoid E] [ordered_add_comm_monoid β] [module 𝕜 E] [has_scalar 𝕜 β] {s : set E} {f : E → β} (hf : strict_concave_on 𝕜 s f) (c : E) : strict_concave_on 𝕜 ((λ (z : E), c + z) ⁻¹' s) (f ∘ λ (z : E), c + z)
theorem uniform_group.uniform_continuous_iff_open_ker {α : Type u_1} {β : Type u_2} [uniform_space α] [group α] [uniform_group α] {hom : Type u_3} [uniform_space β] [discrete_topology β] [group β] [uniform_group β] [monoid_hom_class hom α β] {f : hom} : uniform_continuous ⇑f ↔ is_open ↑(↑f.ker)
theorem quotient.ind' {α : Sort u_1} {s₁ : setoid α} {p : quotient s₁ → Prop} (h : ∀ (a : α), p (quotient.mk' a)) (q : quotient s₁) : p q
theorem complex.norm_le_of_forall_mem_frontier_norm_le {E : Type u} [normed_group E] [normed_space ℂ E] {F : Type v} [normed_group F] [normed_space ℂ F] [nontrivial E] {f : E → F} {U : set E} (hU : metric.bounded U) (hd : diff_cont_on_cl ℂ f U) {C : ℝ} (hC : ∀ (z : E), z ∈ frontier U → ∥f z∥ ≤ C) {z : E} (hz : z ∈ closure U) : ∥f z∥ ≤ C
theorem category_theory.equivalence.ess_surj_of_equivalence {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) [category_theory.is_equivalence F] : category_theory.ess_surj F
theorem sub_orthogonal_projection_mem_orthogonal {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K : submodule 𝕜 E} [complete_space ↥K] (v : E) : v - ↑(⇑(orthogonal_projection K) v) ∈ Kᗮ
theorem filter.has_basis.exists_antitone_subbasis {α : Type u_1} {ι' : Sort u_5} {f : filter α} [h : f.is_countably_generated] {p : ι' → Prop} {s : ι' → set α} (hs : f.has_basis p s) : ∃ (x : ℕ → ι'), (∀ (i : ℕ), p (x i)) ∧ f.has_antitone_basis (λ (i : ℕ), s (x i))
theorem convex_on.translate_left {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [ordered_add_comm_monoid β] [module 𝕜 E] [has_scalar 𝕜 β] {s : set E} {f : E → β} (hf : convex_on 𝕜 s f) (c : E) : convex_on 𝕜 ((λ (z : E), c + z) ⁻¹' s) (f ∘ λ (z : E), z + c)
theorem unique_diff_within_at.unique_mdiff_within_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {s : set E} {x : E} : unique_diff_within_at 𝕜 s x → unique_mdiff_within_at (model_with_corners_self 𝕜 E) s x
theorem category_theory.grothendieck_topology.arrow_trans {C : Type u} [category_theory.category C] {X Y : C} (J : category_theory.grothendieck_topology C) (f : Y ⟶ X) (S R : category_theory.sieve X) (h : J.covers S f) : (∀ {Z : C} (g : Z ⟶ X), ⇑S g → J.covers R g) → J.covers R f
theorem continuous_on_clm_apply {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {E : Type v} [normed_group E] [normed_space 𝕜 E] {F : Type w} [normed_group F] [normed_space 𝕜 F] [complete_space 𝕜] {X : Type u_1} [topological_space X] [finite_dimensional 𝕜 E] {f : X → (E →L[𝕜] F)} {s : set X} : continuous_on f s ↔ ∀ (y : E), continuous_on (λ (x : X), ⇑(f x) y) s
theorem metric.bounded_closed_ball {α : Type u} [pseudo_metric_space α] {x : α} {r : ℝ} : metric.bounded (metric.closed_ball x r)
theorem pell.eq_pell {a : ℕ} (a1 : 1 < a) {x y : ℕ} (hp : x * x - d a1 * y * y = 1) : ∃ (n : ℕ), x = pell.xn a1 n ∧ y = pell.yn a1 n
theorem well_founded.cut_expand {α : Type u_1} {r : α → α → Prop} (hr : well_founded r) : well_founded (relation.cut_expand r)
theorem convex_image_has_deriv_at {f f' : ℝ → ℝ} {s : set ℝ} (hs : convex ℝ s) (hf : ∀ (x : ℝ), x ∈ s → has_deriv_at f (f' x) x) : convex ℝ (f' '' s)
theorem normed_group_hom.op_norm_zero {V₁ : Type u_2} {V₂ : Type u_3} [semi_normed_group V₁] [semi_normed_group V₂] : ∥0∥ = 0
theorem is_group_hom.injective_iff {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 1 → a = 1
theorem matrix.det_from_blocks_zero₂₁ {m : Type u_1} {n : Type u_2} [decidable_eq n] [fintype n] [decidable_eq m] [fintype m] {R : Type v} [comm_ring R] (A : matrix m m R) (B : matrix m n R) (D : matrix n n R) : (matrix.from_blocks A B 0 D).det = A.det * D.det
theorem subgroup.commutator_pi_pi_le {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (H K : Π (i : η), subgroup (Gs i)) : ⁅subgroup.pi set.univ H,subgroup.pi set.univ K⁆ ≤ subgroup.pi set.univ (λ (i : η), ⁅H i,K i⁆)
theorem setoid.classes_eqv_classes {α : Type u_1} {r : setoid α} (a : α) : ∃! (b : set α) (H : b ∈ r.classes), a ∈ b
theorem local_homeomorph.image_open_of_open' {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) {s : set α} (hs : is_open s) : is_open (⇑e '' (e.to_local_equiv.source ∩ s))
theorem strict_mono.strict_mono_iterate_of_lt_map {α : Type u_1} [preorder α] {f : α → α} {x : α} (hf : strict_mono f) (hx : x < f x) : strict_mono (λ (n : ℕ), f^[n] x)
theorem polynomial.root_multiplicity_X_sub_C_pow {R : Type u} [comm_ring R] [is_domain R] (a : R) (n : ℕ) : polynomial.root_multiplicity a ((polynomial.X - ⇑polynomial.C a) ^ n) = n
theorem is_const_of_deriv_eq_zero {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_group G] [normed_space 𝕜 G] {f : 𝕜 → G} (hf : differentiable 𝕜 f) (hf' : ∀ (x : 𝕜), deriv f x = 0) (x y : 𝕜) : f x = f y
theorem metric.Hausdorff_dist_empty {α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist s ∅ = 0
theorem filter.limsup_eq_infi_supr {α : Type u_1} {β : Type u_2} [complete_lattice α] {f : filter β} {u : β → α} : f.limsup u = ⨅ (s : set β) (H : s ∈ f), ⨆ (a : β) (H : a ∈ s), u a
theorem measure_theory.measure_preserving.exists_mem_image_mem_of_volume_lt_mul_volume {α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {f : α → α} {s : set α} (hf : measure_theory.measure_preserving f μ μ) (hs : measurable_set s) {n : ℕ} (hvol : ⇑μ set.univ < ↑n * ⇑μ s) : ∃ (x : α) (H : x ∈ s) (m : ℕ) (H : m ∈ set.Ioo 0 n), f^[m] x ∈ s
theorem parser.nat_of_done {cb : char_buffer} {n n' val : ℕ} (h : parser.nat cb n = parse_result.done n' val) : val = nat.of_digits 10 (list.map (λ (c : char), c.to_nat - '0'.to_nat) (list.take (n' - n) (list.drop n (buffer.to_list cb))).reverse)
theorem has_fderiv_within_at_iff_has_deriv_within_at {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {F : Type v} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {x : 𝕜} {s : set 𝕜} {f' : 𝕜 →L[𝕜] F} : has_fderiv_within_at f f' s x ↔ has_deriv_within_at f (⇑f' 1) s x
theorem is_compact.inter_Inter_nonempty {α : Type u} [topological_space α] {s : set α} {ι : Type v} (hs : is_compact s) (Z : ι → set α) (hZc : ∀ (i : ι), is_closed (Z i)) (hsZ : ∀ (t : finset ι), (s ∩ ⋂ (i : ι) (H : i ∈ t), Z i).nonempty) : (s ∩ ⋂ (i : ι), Z i).nonempty
theorem submodule.mem_orthogonal' {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) (v : E) : v ∈ Kᗮ ↔ ∀ (u : E), u ∈ K → has_inner.inner v u = 0
theorem ideal.polynomial.quotient_mk_comp_C_is_integral_of_jacobson {R : Type u_1} [comm_ring R] [ideal.is_jacobson R] (P : ideal (polynomial R)) [hP : P.is_maximal] : ((ideal.quotient.mk P).comp polynomial.C).is_integral
theorem interval_integral.integrable_on_deriv_right_of_nonneg {a b : ℝ} {g' g : ℝ → ℝ} (hab : a ≤ b) (hcont : continuous_on g (set.Icc a b)) (hderiv : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_within_at g (g' x) (set.Ioi x) x) (g'pos : ∀ (x : ℝ), x ∈ set.Ioo a b → 0 ≤ g' x) : measure_theory.integrable_on g' (set.Ioc a b) measure_theory.measure_space.volume
theorem affine_map.coe_comp {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} {V3 : Type u_6} {P3 : Type u_7} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] [add_comm_group V3] [module k V3] [add_torsor V3 P3] (f : P2 →ᵃ[k] P3) (g : P1 →ᵃ[k] P2) : ⇑(f.comp g) = ⇑f ∘ ⇑g
theorem measure_theory.signed_measure.of_diff_eq_zero_of_symm_diff_eq_zero_negative {α : Type u_1} [measurable_space α] {s : measure_theory.signed_measure α} {u v : set α} (hu : measurable_set u) (hv : measurable_set v) (hsu : measure_theory.vector_measure.restrict s u ≤ 0.restrict u) (hsv : measure_theory.vector_measure.restrict s v ≤ 0.restrict v) (hs : ⇑s (u ∆ v) = 0) : ⇑s (u  v) = 0 ∧ ⇑s (v  u) = 0
theorem geometric_hahn_banach_closed_compact {E : Type u_2} [normed_group E] [normed_space ℝ E] {s t : set E} (hs₁ : convex ℝ s) (hs₂ : is_closed s) (ht₁ : convex ℝ t) (ht₂ : is_compact t) (disj : disjoint s t) : ∃ (f : E →L[ℝ] ℝ) (u v : ℝ), (∀ (a : E), a ∈ s → ⇑f a < u) ∧ u < v ∧ ∀ (b : E), b ∈ t → v < ⇑f b
theorem monotone.tendsto_at_top_finset {α : Type u_3} {β : Type u_4} [preorder β] {f : β → finset α} (h : monotone f) (h' : ∀ (x : α), ∃ (n : β), x ∈ f n) : filter.tendsto f filter.at_top filter.at_top
theorem one_div_le_one_div {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : 1 / a ≤ 1 / b ↔ b ≤ a
theorem list.drop_sum_join {α : Type u_1} (L : list (list α)) (i : ℕ) : list.drop (list.take i (list.map list.length L)).sum L.join = (list.drop i L).join
theorem subsemiring.closure_induction₂ {R : Type u} [non_assoc_semiring R] {s : set R} {p : R → R → Prop} {x y : R} (hx : x ∈ subsemiring.closure s) (hy : y ∈ subsemiring.closure s) (Hs : ∀ (x : R), x ∈ s → ∀ (y : R), y ∈ s → p x y) (H0_left : ∀ (x : R), p 0 x) (H0_right : ∀ (x : R), p x 0) (H1_left : ∀ (x : R), p 1 x) (H1_right : ∀ (x : R), p x 1) (Hadd_left : ∀ (x₁ x₂ y : R), p x₁ y → p x₂ y → p (x₁ + x₂) y) (Hadd_right : ∀ (x y₁ y₂ : R), p x y₁ → p x y₂ → p x (y₁ + y₂)) (Hmul_left : ∀ (x₁ x₂ y : R), p x₁ y → p x₂ y → p (x₁ * x₂) y) (Hmul_right : ∀ (x y₁ y₂ : R), p x y₁ → p x y₂ → p x (y₁ * y₂)) : p x y
theorem ultrafilter_is_closed_basic {α : Type u} (s : set α) : is_closed {u : ultrafilter α | s ∈ u}
theorem locally_finite.countable_univ {α : Type u} [topological_space α] [sigma_compact_space α] {ι : Type u_1} {f : ι → set α} (hf : locally_finite f) (hne : ∀ (i : ι), (f i).nonempty) : set.univ.countable
theorem measure_theory.measure_lt_top_of_is_compact_of_is_mul_left_invariant' {G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {μ : measure_theory.measure G} [group G] [topological_group G] [μ.is_mul_left_invariant] {U : set G} (hU : (interior U).nonempty) (h : ⇑μ U ≠ ⊤) {K : set G} (hK : is_compact K) : ⇑μ K < ⊤
theorem finite_field.is_square_of_char_two {F : Type u_3} [field F] [fintype F] (hF : ring_char F = 2) (a : F) : is_square a
theorem eq_affine_combination_of_mem_affine_span {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} {p1 : P} {p : ι → P} (h : p1 ∈ affine_span k (set.range p)) : ∃ (s : finset ι) (w : ι → k) (hw : s.sum (λ (i : ι), w i) = 1), p1 = ⇑(s.affine_combination p) w
theorem matrix.nondegenerate.det_ne_zero {n : Type u_3} [fintype n] {A : Type u_1} [decidable_eq n] [comm_ring A] [is_domain A] {M : matrix n n A} : M.nondegenerate → M.det ≠ 0
theorem volume_set_of_liouville  : ⇑measure_theory.measure_space.volume {x : ℝ | liouville x} = 0
theorem monoid_algebra.non_unital_alg_hom_ext (k : Type u₁) {G : Type u₂} [semiring k] [has_mul G] {A : Type u₃} [non_unital_non_assoc_semiring A] [distrib_mul_action k A] {φ₁ φ₂ : monoid_algebra k G →ₙₐ[k] A} (h : ∀ (x : G), ⇑φ₁ (finsupp.single x 1) = ⇑φ₂ (finsupp.single x 1)) : φ₁ = φ₂
theorem submonoid.closure_induction {M : Type u_1} [mul_one_class M] {s : set M} {p : M → Prop} {x : M} (h : x ∈ submonoid.closure s) (Hs : ∀ (x : M), x ∈ s → p x) (H1 : p 1) (Hmul : ∀ (x y : M), p x → p y → p (x * y)) : p x
theorem matrix.pivot.exists_is_two_block_diagonal_of_ne_zero {𝕜 : Type u_3} [field 𝕜] {r : ℕ} (M : matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜) (hM : M (sum.inr ()) (sum.inr ()) ≠ 0) : ∃ (L L' : list (matrix.transvection_struct (fin r ⊕ unit) 𝕜)), (((list.map matrix.transvection_struct.to_matrix L).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L').prod).is_two_block_diagonal
theorem monoid.closure_subset {M : Type u_1} [monoid M] {s t : set M} (ht : is_submonoid t) (h : s ⊆ t) : monoid.closure s ⊆ t
theorem int.abs_le_self_pow_two (a : ℤ) : ↑(a.nat_abs) ≤ a ^ 2
theorem measure_theory.ae_eventually_not_mem {α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {s : ℕ → set α} (hs : ∑' (i : ℕ), ⇑μ (s i) ≠ ⊤) : ∀ᵐ (x : α) ∂μ, ∀ᶠ (n : ℕ) in filter.at_top, x ∉ s n
theorem cont_diff_on_fst {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : with_top ℕ} {s : set (E × F)} : cont_diff_on 𝕜 n prod.fst s
theorem refl_trans_gen_of_succ {α : Type u_1} [linear_order α] [succ_order α] [is_succ_archimedean α] (r : α → α → Prop) {n m : α} (h1 : ∀ (i : α), i ∈ set.Ico n m → r i (order.succ i)) (h2 : ∀ (i : α), i ∈ set.Ico m n → r (order.succ i) i) : relation.refl_trans_gen r n m
theorem linear_map.polar_gc {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [normed_comm_ring 𝕜] [add_comm_monoid E] [add_comm_monoid F] [module 𝕜 E] [module 𝕜 F] (B : E →ₗ[𝕜] F →ₗ[𝕜] 𝕜) : galois_connection (⇑order_dual.to_dual ∘ B.polar) (B.flip.polar ∘ ⇑order_dual.of_dual)
theorem bornology.is_bounded.of_compl {α : Type u_2} [bornology α] {s : set α} : bornology.is_bounded sᶜ → bornology.is_cobounded s
theorem matrix.star_mul {n : Type u_3} {α : Type v} [fintype n] [non_unital_semiring α] [star_ring α] (M N : matrix n n α) : has_star.star (M.mul N) = (has_star.star N).mul (has_star.star M)
theorem category_theory.limits.has_wide_equalizers_of_has_limit_parallel_family (C : Type u) [category_theory.category C] [∀ {J : Type v} {X Y : C} {f : J → (X ⟶ Y)}, category_theory.limits.has_limit (category_theory.limits.parallel_family f)] : category_theory.limits.has_wide_equalizers C
theorem equiv.is_domain {α : Type u} {β : Type v} [ring α] [ring β] [is_domain β] (e : α ≃+* β) : is_domain α
theorem strict_convex_on_zpow {m : ℤ} (hm₀ : m ≠ 0) (hm₁ : m ≠ 1) : strict_convex_on ℝ (set.Ioi 0) (λ (x : ℝ), x ^ m)
theorem deriv.lhopital_zero_at_top {l : filter ℝ} {f g : ℝ → ℝ} (hdf : ∀ᶠ (x : ℝ) in filter.at_top, differentiable_at ℝ f x) (hg' : ∀ᶠ (x : ℝ) in filter.at_top, deriv g x ≠ 0) (hftop : filter.tendsto f filter.at_top (nhds 0)) (hgtop : filter.tendsto g filter.at_top (nhds 0)) (hdiv : filter.tendsto (λ (x : ℝ), deriv f x / deriv g x) filter.at_top l) : filter.tendsto (λ (x : ℝ), f x / g x) filter.at_top l
theorem fixing_submonoid_union (M : Type u_1) (α : Type u_2) [monoid M] [mul_action M α] {s t : set α} : fixing_submonoid M (s ∪ t) = fixing_submonoid M s ⊓ fixing_submonoid M t
theorem ordered_smul.mk'' {R : Type u_1} {M : Type u_2} [linear_ordered_semiring R] [ordered_add_comm_monoid M] [mul_action_with_zero R M] (hR : ∀ {c : R}, c ≠ 0 → is_unit c) (hlt : ∀ ⦃a b : M⦄ ⦃c : R⦄, a < b → 0 < c → c • a ≤ c • b) : ordered_smul R M
theorem has_ssubset.ssubset.false {α : Type u} [has_ssubset α] [is_irrefl α has_ssubset.ssubset] {a : α} : ¬a ⊂ a
theorem Gromov_Hausdorff.GH_dist_le_Hausdorff_dist {X : Type u} [metric_space X] [compact_space X] [nonempty X] {Y : Type v} [metric_space Y] [compact_space Y] [nonempty Y] {γ : Type w} [metric_space γ] {Φ : X → γ} {Ψ : Y → γ} (ha : isometry Φ) (hb : isometry Ψ) : Gromov_Hausdorff.GH_dist X Y ≤ metric.Hausdorff_dist (set.range Φ) (set.range Ψ)
theorem witt_vector.is_poly₂.comp_left {p : ℕ} {g : Π ⦃R : Type u_1⦄ [_inst_3 : comm_ring R], witt_vector p R → witt_vector p R → witt_vector p R} {f : Π ⦃R : Type u_1⦄ [_inst_3 : comm_ring R], witt_vector p R → witt_vector p R} (hg : witt_vector.is_poly₂ p g) (hf : witt_vector.is_poly p f) : witt_vector.is_poly₂ p (λ (R : Type u_1) (_Rcr : comm_ring R) (x y : witt_vector p R), g (f x) y)
theorem eventually_closed_ball_subset {α : Type u} [pseudo_metric_space α] {x : α} {u : set α} (hu : u ∈ nhds x) : ∀ᶠ (r : ℝ) in nhds 0, metric.closed_ball x r ⊆ u
theorem list.length_pos_of_one_lt_prod {M : Type u_3} [monoid M] [preorder M] (L : list M) (h : 1 < L.prod) : 0 < L.length
theorem list.prod_drop_succ {G : Type u_7} [group G] (L : list G) (i : ℕ) (p : i < L.length) : (list.drop (i + 1) L).prod = (L.nth_le i p)⁻¹ * (list.drop i L).prod
theorem strongly_measurable_iff_measurable {α : Type u_1} {β : Type u_2} {f : α → β} {mα : measurable_space α} [measurable_space β] [topological_space β] [topological_space.metrizable_space β] [borel_space β] [topological_space.second_countable_topology β] : measure_theory.strongly_measurable f ↔ measurable f
theorem cont_mdiff_within_at_iff_target {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M → M'} {s : set M} {x : M} {n : with_top ℕ} : cont_mdiff_within_at I I' n f s x ↔ continuous_within_at f s x ∧ cont_mdiff_within_at I (model_with_corners_self 𝕜 E') n (⇑(ext_chart_at I' (f x)) ∘ f) (s ∩ f ⁻¹' (ext_chart_at I' (f x)).source) x
theorem line_map_le_map_iff_slope_le_slope_left {k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k → E} {a b r : k} (h : 0 < r * (b - a)) : ⇑(affine_map.line_map (f a) (f b)) r ≤ f (⇑(affine_map.line_map a b) r) ↔ slope f a b ≤ slope f a (⇑(affine_map.line_map a b) r)
theorem mul_lt_one_of_le_of_lt {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1
theorem differentiable_within_at.mdifferentiable_within_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {f : E → E'} {s : set E} {x : E} : differentiable_within_at 𝕜 f s x → mdifferentiable_within_at (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f s x
theorem orientation.oangle_eq_iff_eq_pos_smul_rotation_or_eq_zero {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y : V} (θ : real.angle) : o.oangle x y = θ ↔ (x ≠ 0 ∧ y ≠ 0 ∧ ∃ (r : ℝ), 0 < r ∧ y = r • ⇑(o.rotation θ) x) ∨ θ = 0 ∧ (x = 0 ∨ y = 0)
theorem continuous_linear_map.comp_has_fpower_series_on_ball {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] [normed_group G] [normed_space 𝕜 G] {f : E → F} {p : formal_multilinear_series 𝕜 E F} {x : E} {r : ennreal} (g : F →L[𝕜] G) (h : has_fpower_series_on_ball f p x r) : has_fpower_series_on_ball (⇑g ∘ f) (g.comp_formal_multilinear_series p) x r
theorem nhds_le_of_le {α : Type u} [topological_space α] {f : filter α} {a : α} {s : set α} (h : a ∈ s) (o : is_open s) (sf : filter.principal s ≤ f) : nhds a ≤ f
theorem has_strict_fderiv_at.eq_implicit_function_of_complemented {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] [complete_space F] {f : E → F} {f' : E →L[𝕜] F} {a : E} (hf : has_strict_fderiv_at f f' a) (hf' : f'.range = ⊤) (hker : f'.ker.closed_complemented) : ∀ᶠ (x : E) in nhds a, has_strict_fderiv_at.implicit_function_of_complemented f f' hf hf' hker (f x) (⇑(has_strict_fderiv_at.implicit_to_local_homeomorph_of_complemented f f' hf hf' hker) x).snd = x
theorem torus_integral_succ {n : ℕ} {E : Type u_1} [normed_group E] [normed_space ℂ E] [complete_space E] {f : (fin (n + 1) → ℂ) → E} {c : fin (n + 1) → ℂ} {R : fin (n + 1) → ℝ} (hf : torus_integrable f c R) : ∯ (x : fin (n + 1) → ℂ) in T(c, R), f x = ∮ (x : ℂ) in C(c 0, R 0), ∯ (y : fin n → ℂ) in T(c ∘ fin.succ, R ∘ fin.succ), f (fin.cons x y)
theorem interval_integral.sub_le_integral_of_has_deriv_right_of_le {a b : ℝ} {g' g φ : ℝ → ℝ} (hab : a ≤ b) (hcont : continuous_on g (set.Icc a b)) (hderiv : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_within_at g (g' x) (set.Ioi x) x) (φint : measure_theory.integrable_on φ (set.Icc a b) measure_theory.measure_space.volume) (hφg : ∀ (x : ℝ), x ∈ set.Ioo a b → g' x ≤ φ x) : g b - g a ≤ ∫ (y : ℝ) in a..b, φ y
theorem abelianization.hom_ext {G : Type u} [group G] {A : Type v} [monoid A] (φ ψ : abelianization G →* A) (h : φ.comp abelianization.of = ψ.comp abelianization.of) : φ = ψ
theorem phragmen_lindelof.quadrant_III {E : Type u_1} [normed_group E] [normed_space ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ} (hd : diff_cont_on_cl ℂ f (set.Iio 0 ×ℂ set.Iio 0)) (hB : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ filter.principal (set.Iio 0 ×ℂ set.Iio 0)] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hre : ∀ (x : ℝ), x ≤ 0 → ∥f ↑x∥ ≤ C) (him : ∀ (x : ℝ), x ≤ 0 → ∥f (↑x * complex.I)∥ ≤ C) (hz_re : z.re ≤ 0) (hz_im : z.im ≤ 0) : ∥f z∥ ≤ C
theorem list.is_infix.reverse {α : Type u_1} {l₁ l₂ : list α} : l₁ <:+: l₂ → l₁.reverse <:+: l₂.reverse
theorem dvd_add_right {α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ b) : a ∣ b + c ↔ a ∣ c
theorem exists_continuous_zero_one_of_closed {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : ∃ (f : C(X, ℝ)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1
theorem set.image_perm {α : Type u} {s : set α} {σ : equiv.perm α} (hs : {a : α | ⇑σ a ≠ a} ⊆ s) : ⇑σ '' s = s
theorem span_points_nonempty (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : (span_points k s).nonempty ↔ s.nonempty
theorem list.nodup.of_sublists' {α : Type u} {l : list α} : l.sublists'.nodup → l.nodup
theorem subring.multiset_sum_mem {R : Type u_1} [ring R] (s : subring R) (m : multiset R) : (∀ (a : R), a ∈ m → a ∈ s) → m.sum ∈ s
theorem category_theory.concrete_category.epi_of_surjective {C : Type v} [category_theory.category C] [category_theory.concrete_category C] {X Y : C} (f : X ⟶ Y) (s : function.surjective ⇑f) : category_theory.epi f
theorem balanced_zero_union_interior {𝕜 : Type u_1} {E : Type u_3} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] {A : set E} [topological_space E] [has_continuous_smul 𝕜 E] (hA : balanced 𝕜 A) : balanced 𝕜 (0 ∪ interior A)
theorem is_bounded_bilinear_map_inner {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [normed_space ℝ E] : is_bounded_bilinear_map ℝ (λ (p : E × E), has_inner.inner p.fst p.snd)
theorem lattice_ordered_comm_group.pos_of_nonneg {α : Type u} [lattice α] [add_comm_group α] (a : α) (h : 0 ≤ a) : a⁺ = a
theorem emetric.inf_edist_singleton {α : Type u} [pseudo_emetric_space α] {x y : α} : emetric.inf_edist x {y} = has_edist.edist x y
theorem polynomial.map_cyclotomic (n : ℕ) {R : Type u_1} {S : Type u_2} [ring R] [ring S] (f : R →+* S) : polynomial.map f (polynomial.cyclotomic n R) = polynomial.cyclotomic n S
theorem finset.prod_le_prod {ι : Type u_1} {R : Type u_8} [ordered_comm_semiring R] {f g : ι → R} {s : finset ι} (h0 : ∀ (i : ι), i ∈ s → 0 ≤ f i) (h1 : ∀ (i : ι), i ∈ s → f i ≤ g i) : s.prod (λ (i : ι), f i) ≤ s.prod (λ (i : ι), g i)
theorem category_theory.preadditive.has_coequalizer_of_has_cokernel {C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} (f g : X ⟶ Y) [category_theory.limits.has_cokernel (f - g)] : category_theory.limits.has_coequalizer f g
theorem norm_eq_infi_iff_inner_eq_zero {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) {u v : E} (hv : v ∈ K) : (∥u - v∥ = ⨅ (w : ↥↑K), ∥u - ↑w∥) ↔ ∀ (w : E), w ∈ K → has_inner.inner (u - v) w = 0
theorem measure_theory.ae_fin_strongly_measurable_iff_ae_measurable {α : Type u_1} {G : Type u_5} [normed_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] {f : α → G} {m0 : measurable_space α} (μ : measure_theory.measure α) [measure_theory.sigma_finite μ] : measure_theory.ae_fin_strongly_measurable f μ ↔ ae_measurable f μ
theorem is_mul_hom.to_is_monoid_hom {α : Type u} {β : Type v} [mul_one_class α] [group β] {f : α → β} (hf : is_mul_hom f) : is_monoid_hom f
theorem locally_finite.finite_nonempty_inter_compact {α : Type u} [topological_space α] {ι : Type u_1} {f : ι → set α} (hf : locally_finite f) {s : set α} (hs : is_compact s) : {i : ι | (f i ∩ s).nonempty}.finite
theorem real.ediam_eq {s : set ℝ} (h : metric.bounded s) : emetric.diam s = ennreal.of_real (has_Sup.Sup s - has_Inf.Inf s)
theorem neg_add_lt_of_lt_add {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a < b + c → -b + a < c
theorem topological_space.dense_range_dense_seq (α : Type u) [t : topological_space α] [topological_space.separable_space α] [nonempty α] : dense_range (topological_space.dense_seq α)
theorem metric.lipschitz_inf_nndist_pt {α : Type u} [pseudo_metric_space α] (s : set α) : lipschitz_with 1 (λ (x : α), metric.inf_nndist x s)
theorem category_theory.equalizer.presieve.compatible_iff {C : Type u₁} [category_theory.category C] (P : Cᵒᵖ ⥤ Type (max v₁ u₁)) {X : C} (R : category_theory.presieve X) [category_theory.limits.has_pullbacks C] (x : category_theory.equalizer.first_obj P R) : ((category_theory.equalizer.first_obj_eq_family P R).hom x).compatible ↔ category_theory.equalizer.presieve.first_map P R x = category_theory.equalizer.presieve.second_map P R x
theorem euclidean_geometry.vsub_orthogonal_projection_mem_direction {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} [nonempty ↥s] [complete_space ↥(s.direction)] {p1 : P} (p2 : P) (hp1 : p1 ∈ s) : ↑(⟨p1, hp1⟩ -ᵥ ⇑(euclidean_geometry.orthogonal_projection s) p2) ∈ s.direction
theorem nat.arithmetic_function.sum_eq_iff_sum_mul_moebius_eq {R : Type u_1} [ring R] {f g : ℕ → R} : (∀ (n : ℕ), 0 < n → n.divisors.sum (λ (i : ℕ), f i) = g n) ↔ ∀ (n : ℕ), 0 < n → n.divisors_antidiagonal.sum (λ (x : ℕ × ℕ), ↑(⇑nat.arithmetic_function.moebius x.fst) * g x.snd) = f n
theorem local_homeomorph.image_open_of_open {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) {s : set α} (hs : is_open s) (h : s ⊆ e.to_local_equiv.source) : is_open (⇑e '' s)
theorem topological_vector_bundle_core.is_open_map_proj {R : Type u_1} {B : Type u_3} {F : Type u_4} [nondiscrete_normed_field R] [normed_group F] [normed_space R F] [topological_space B] {ι : Type u_6} (Z : topological_vector_bundle_core R B F ι) : is_open_map Z.proj
theorem is_smul_regular.smul_iff {R : Type u_1} {S : Type u_2} {M : Type u_3} {a : R} [has_scalar R M] [has_scalar R S] [has_scalar S M] [is_scalar_tower R S M] (b : S) (ha : is_smul_regular M a) : is_smul_regular M (a • b) ↔ is_smul_regular M b
theorem fin.prod_univ_succ {β : Type u_2} [comm_monoid β] {n : ℕ} (f : fin (n + 1) → β) : finset.univ.prod (λ (i : fin (n + 1)), f i) = f 0 * finset.univ.prod (λ (i : fin n), f i.succ)
theorem add_comm_monoid.add_torsion.is_torsion {G : Type u_1} [add_comm_monoid G] : add_monoid.is_torsion ↥(add_comm_monoid.add_torsion G)
theorem measurable_set_of_differentiable_at (𝕜 : Type u_1) [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] (f : E → F) [measurable_space E] [opens_measurable_space E] [complete_space F] : measurable_set {x : E | differentiable_at 𝕜 f x}
theorem absorbent_ball {𝕜 : Type u_3} {E : Type u_4} [normed_field 𝕜] [semi_normed_group E] [normed_space 𝕜 E] {r : ℝ} {x : E} (hx : ∥x∥ < r) : absorbent 𝕜 (metric.ball x r)
theorem totally_disconnected_space_iff_connected_component_subsingleton {α : Type u} [topological_space α] : totally_disconnected_space α ↔ ∀ (x : α), (connected_component x).subsingleton
theorem measure_theory.absolutely_continuous_of_is_add_left_invariant {G : Type u_1} [measurable_space G] [add_group G] [has_measurable_add₂ G] (μ ν : measure_theory.measure G) [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] [has_measurable_neg G] [μ.is_add_left_invariant] [ν.is_add_left_invariant] (hν : ν ≠ 0) : μ.absolutely_continuous ν
theorem matrix.pivot.list_transvec_col_mul_last_row {𝕜 : Type u_3} [field 𝕜] {r : ℕ} (M : matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜) (i : fin r ⊕ unit) : (matrix.pivot.list_transvec_col M).prod.mul M (sum.inr ()) i = M (sum.inr ()) i
theorem nonempty_of_finprod_mem_ne_one {α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M} {s : set α} (h : finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) ≠ 1) : s.nonempty
theorem measure_theory.measure.add_haar_preimage_continuous_linear_equiv {E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (f : E ≃L[ℝ] E) (s : set E) : ⇑μ (⇑f ⁻¹' s) = ennreal.of_real |⇑linear_map.det ↑(f.symm)| * ⇑μ s
theorem nat.coprime_prod_left {ι : Type u_1} {x : ℕ} {s : ι → ℕ} {t : finset ι} : (∀ (i : ι), i ∈ t → (s i).coprime x) → (t.prod (λ (i : ι), s i)).coprime x
theorem cardinal.not_countable_real  : ¬set.univ.countable
theorem fintype.sum_equiv {α : Type u_1} {β : Type u_2} {M : Type u_3} [fintype α] [fintype β] [add_comm_monoid M] (e : α ≃ β) (f : α → M) (g : β → M) (h : ∀ (x : α), f x = g (⇑e x)) : finset.univ.sum (λ (x : α), f x) = finset.univ.sum (λ (x : β), g x)
theorem category_theory.is_iso_right_of_is_iso_biprod_map {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_binary_biproducts C] {W X Y Z : C} (f : W ⟶ Y) (g : X ⟶ Z) [category_theory.is_iso (category_theory.limits.biprod.map f g)] : category_theory.is_iso g
theorem monotone_on.map_is_greatest {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {t : set α} (Hf : monotone_on f t) {a : α} (Ha : is_greatest t a) : is_greatest (f '' t) (f a)
theorem list.length_pos_of_prod_ne_one {M : Type u_3} [monoid M] (L : list M) (h : L.prod ≠ 1) : 0 < L.length
theorem affine.simplex.altitude_def {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P (n + 1)) (i : fin (n + 2)) : s.altitude i = affine_subspace.mk' (s.points i) ((affine_span ℝ (s.points '' ↑(finset.univ.erase i))).direction)ᗮ ⊓ affine_span ℝ (set.range s.points)
theorem inner_product_geometry.angle_smul_right_of_pos {V : Type u_1} [inner_product_space ℝ V] (x y : V) {r : ℝ} (hr : 0 < r) : inner_product_geometry.angle x (r • y) = inner_product_geometry.angle x y
theorem finset.ne_of_mem_slice {α : Type u_1} {𝒜 : finset (finset α)} {A₁ A₂ : finset α} {r₁ r₂ : ℕ} (h₁ : A₁ ∈ 𝒜.slice r₁) (h₂ : A₂ ∈ 𝒜.slice r₂) : r₁ ≠ r₂ → A₁ ≠ A₂
theorem is_exposed.eq_inter_halfspace {𝕜 : Type u_1} {E : Type u_2} [normed_linear_ordered_field 𝕜] [normed_group E] [normed_space 𝕜 E] {A B : set E} (hAB : is_exposed 𝕜 A B) : ∃ (l : E →L[𝕜] 𝕜) (a : 𝕜), B = {x ∈ A | a ≤ ⇑l x}
theorem finite_field.sum_pow_units (K : Type u_1) [field K] [fintype K] [fintype Kˣ] (i : ℕ) : finset.univ.sum (λ (x : Kˣ), ↑x ^ i) = ite (fintype.card K - 1 ∣ i) (-1) 0
theorem finset.sum_subtype_map_embedding {β : Type u} {α : Type v} [add_comm_monoid β] {p : α → Prop} {s : finset {x // p x}} {f : {x // p x} → β} {g : α → β} (h : ∀ (x : {x // p x}), x ∈ s → g ↑x = f x) : (finset.map (function.embedding.subtype (λ (x : α), p x)) s).sum (λ (x : α), g x) = s.sum (λ (x : {x // p x}), f x)
theorem subgroup.closure_eq {G : Type u_1} [group G] (K : subgroup G) : subgroup.closure ↑K = K
theorem compact_t2_tot_disc_iff_tot_sep {α : Type u} [topological_space α] [t2_space α] [compact_space α] : totally_disconnected_space α ↔ totally_separated_space α
theorem is_local_max.has_deriv_at_eq_zero {f : ℝ → ℝ} {f' a : ℝ} (h : is_local_max f a) (hf : has_deriv_at f f' a) : f' = 0
theorem measurable_set_of_differentiable_within_at_Ioi {F : Type u_1} [normed_group F] [normed_space ℝ F] (f : ℝ → F) [complete_space F] : measurable_set {x : ℝ | differentiable_within_at ℝ f (set.Ioi x) x}
theorem nnreal.summable_of_le {β : Type u_2} {f g : β → nnreal} (hgf : ∀ (b : β), g b ≤ f b) : summable f → summable g
theorem convex.second_derivative_within_at_symmetric_of_mem_interior {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {s : set E} (s_conv : convex ℝ s) {f : E → F} {f' : E → (E →L[ℝ] F)} {f'' : E →L[ℝ] E →L[ℝ] F} (hf : ∀ (x : E), x ∈ interior s → has_fderiv_at f (f' x) x) {x : E} (xs : x ∈ s) (hx : has_fderiv_within_at f' f'' (interior s) x) {v w : E} (h4v : x + 4 • v ∈ interior s) (h4w : x + 4 • w ∈ interior s) : ⇑(⇑f'' w) v = ⇑(⇑f'' v) w
theorem polynomial.has_deriv_at {𝕜 : Type u} [nondiscrete_normed_field 𝕜] (p : polynomial 𝕜) (x : 𝕜) : has_deriv_at (λ (x : 𝕜), polynomial.eval x p) (polynomial.eval x (⇑polynomial.derivative p)) x
theorem closure_operator.le_closure {α : Type u_1} [partial_order α] (c : closure_operator α) (x : α) : x ≤ ⇑c x
theorem valuation.is_equiv.comap {R : Type u_2} {Γ₀ : Type u_3} {Γ'₀ : Type u_4} [ring R] [linear_ordered_comm_monoid_with_zero Γ₀] [linear_ordered_comm_monoid_with_zero Γ'₀] {v₁ : valuation R Γ₀} {v₂ : valuation R Γ'₀} {S : Type u_1} [ring S] (f : S →+* R) (h : v₁.is_equiv v₂) : (valuation.comap f v₁).is_equiv (valuation.comap f v₂)
theorem emetric.uniform_continuous_iff {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} : uniform_continuous f ↔ ∀ (ε : ennreal), ε > 0 → (∃ (δ : ennreal) (H : δ > 0), ∀ {a b : α}, has_edist.edist a b < δ → has_edist.edist (f a) (f b) < ε)
theorem is_cyclotomic_extension.splits_X_pow_sub_one (n : ℕ+) (S : set ℕ+) (K : Type w) (L : Type z) [field K] [field L] [algebra K L] [ne_zero ↑↑n] [H : is_cyclotomic_extension S K L] (hS : n ∈ S) : polynomial.splits (algebra_map K L) (polynomial.X ^ ↑n - 1)
theorem add_monoid_hom.functions_ext' {I : Type u_1} [decidable_eq I] {Z : I → Type u_2} [Π (i : I), add_comm_monoid (Z i)] [fintype I] (M : Type u_3) [add_comm_monoid M] (g h : (Π (i : I), Z i) →+ M) (H : ∀ (i : I), g.comp (add_monoid_hom.single Z i) = h.comp (add_monoid_hom.single Z i)) : g = h
theorem finset.weighted_vsub_apply_const {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (w : ι → k) (p : P) (h : s.sum (λ (i : ι), w i) = 0) : ⇑(s.weighted_vsub (λ (_x : ι), p)) w = 0
theorem is_primitive_root.is_integral {n : ℕ} {K : Type u_8} [comm_ring K] {μ : K} (h : is_primitive_root μ n) (hpos : 0 < n) : is_integral ℤ μ
theorem continuous.bdd_below_range_of_has_compact_mul_support {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_closed_topology α] [nonempty α] [topological_space β] [has_one α] {f : β → α} (hf : continuous f) (h : has_compact_mul_support f) : bdd_below (set.range f)
theorem function.injective.inj_on {α : Type u} {β : Type v} {f : α → β} (h : function.injective f) (s : set α) : set.inj_on f s
theorem matrix.det_transpose {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : M.transpose.det = M.det
theorem submonoid.localization_map.of_mul_equiv_of_dom_id {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] (f : S.localization_map N) : f.of_mul_equiv_of_dom _ = f
theorem monoid_algebra.ring_hom_ext' {k : Type u₁} {G : Type u₂} {R : Type u_1} [semiring k] [mul_one_class G] [semiring R] {f g : monoid_algebra k G →+* R} (h₁ : f.comp monoid_algebra.single_one_ring_hom = g.comp monoid_algebra.single_one_ring_hom) (h_of : ↑f.comp (monoid_algebra.of k G) = ↑g.comp (monoid_algebra.of k G)) : f = g
theorem uniform_space.second_countable_of_separable (α : Type u) [uniform_space α] [(uniformity α).is_countably_generated] [topological_space.separable_space α] : topological_space.second_countable_topology α
theorem linear_map.trace_id (R : Type u_1) [comm_ring R] (M : Type u_2) [add_comm_group M] [module R M] [module.free R M] [module.finite R M] [nontrivial R] : ⇑(linear_map.trace R M) linear_map.id = ↑(finite_dimensional.finrank R M)
theorem inv_lt_inv {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ < b⁻¹ ↔ b < a
theorem setoid.eqv_gen_mono {α : Type u_1} {r s : α → α → Prop} (h : ∀ (x y : α), r x y → s x y) : eqv_gen.setoid r ≤ eqv_gen.setoid s
theorem padic_seq.lift_index_right {p : ℕ} [fact (nat.prime p)] {f : padic_seq p} (hf : ¬f ≈ 0) (v1 v2 : ℕ) : padic_norm p (⇑f (padic_seq.stationary_point hf)) = padic_norm p (⇑f (linear_order.max v1 (linear_order.max v2 (padic_seq.stationary_point hf))))
theorem right.mul_lt_one_of_lt_of_le {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : a < 1) (hb : b ≤ 1) : a * b < 1
theorem is_upper_set.of_dual {α : Type u_1} [has_le α] {s : set α} : is_upper_set s → is_lower_set (⇑order_dual.of_dual ⁻¹' s)
theorem finset.add_sum_erase {β : Type u} {α : Type v} [add_comm_monoid β] [decidable_eq α] (s : finset α) (f : α → β) {a : α} (h : a ∈ s) : f a + (s.erase a).sum (λ (x : α), f x) = s.sum (λ (x : α), f x)
theorem category_theory.pullback_is_sheaf_of_cover_preserving {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {A : Type u₃} [category_theory.category A] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {G : C ⥤ D} (hG₁ : category_theory.compatible_preserving K G) (hG₂ : category_theory.cover_preserving J K G) (ℱ : category_theory.Sheaf K A) : category_theory.presheaf.is_sheaf J (G.op ⋙ ℱ.val)
theorem upper_semicontinuous.add' {α : Type u_1} [topological_space α] {γ : Type u_4} [linear_ordered_add_comm_monoid γ] [topological_space γ] [order_topology γ] {f g : α → γ} (hf : upper_semicontinuous f) (hg : upper_semicontinuous g) (hcont : ∀ (x : α), continuous_at (λ (p : γ × γ), p.fst + p.snd) (f x, g x)) : upper_semicontinuous (λ (z : α), f z + g z)
theorem matrix.transpose_has_orthogonal_rows_iff_has_orthogonal_cols {α : Type u_1} {n : Type u_2} {m : Type u_3} [has_mul α] [add_comm_monoid α] (A : matrix m n α) [fintype m] : A.transpose.has_orthogonal_rows ↔ A.has_orthogonal_cols
theorem category_theory.limits.eq_of_epi_fork_ι {C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} (t : category_theory.limits.fork f g) [category_theory.epi t.ι] : f = g
theorem has_ftaylor_series_up_to_on.exists_lipschitz_on_with_of_nnnorm_lt {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {f : E → F} {p : E → formal_multilinear_series ℝ E F} {s : set E} {x : E} (hf : has_ftaylor_series_up_to_on 1 f p (has_insert.insert x s)) (hs : convex ℝ s) (K : nnreal) (hK : ∥p x 1∥₊ < K) : ∃ (t : set E) (H : t ∈ nhds_within x s), lipschitz_on_with K f t
theorem nat.mul_div_mul_left (a b : ℕ) {c : ℕ} (hc : 0 < c) : c * a / (c * b) = a / b
theorem nat.exists_lt_modeq_of_infinite {s : set ℕ} (hs : s.infinite) {k : ℕ} (hk : 0 < k) : ∃ (m : ℕ) (H : m ∈ s) (n : ℕ) (H : n ∈ s), m < n ∧ m ≡ n [MOD k]
theorem category_theory.tensor_left_hom_equiv_tensor {C : Type u₁} [category_theory.category C] [category_theory.monoidal_category C] {X X' Y Y' Z Z' : C} [category_theory.exact_pairing Y Y'] (f : X ⟶ Y ⊗ Z) (g : X' ⟶ Z') : ⇑((category_theory.tensor_left_hom_equiv (X ⊗ X') Y Y' (Z ⊗ Z')).symm) ((f ⊗ g) ≫ (α_ Y Z Z').hom) = (α_ Y' X X').inv ≫ (⇑((category_theory.tensor_left_hom_equiv X Y Y' Z).symm) f ⊗ g)
theorem category_theory.presieve.is_sheaf_for_iff_yoneda_sheaf_condition {C : Type u₁} [category_theory.category C] {X : C} {S : category_theory.sieve X} {P : Cᵒᵖ ⥤ Type v₁} : category_theory.presieve.is_sheaf_for P ⇑S ↔ category_theory.presieve.yoneda_sheaf_condition P S
theorem padic_norm.sub (p : ℕ) [hp : fact (nat.prime p)] {q r : ℚ} : padic_norm p (q - r) ≤ linear_order.max (padic_norm p q) (padic_norm p r)
theorem add_action.sum_card_fixed_by_eq_card_orbits_add_card_add_group (α : Type u) (β : Type v) [add_group α] [add_action α β] [fintype α] [Π (a : α), fintype ↥(add_action.fixed_by α β a)] [fintype (quotient (add_action.orbit_rel α β))] : finset.univ.sum (λ (a : α), fintype.card ↥(add_action.fixed_by α β a)) = fintype.card (quotient (add_action.orbit_rel α β)) * fintype.card α
theorem finsupp.lhom_ext {α : Type u_1} {M : Type u_2} {N : Type u_3} {R : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [add_comm_monoid N] [module R N] ⦃φ ψ : (α →₀ M) →ₗ[R] N⦄ (h : ∀ (a : α) (b : M), ⇑φ (finsupp.single a b) = ⇑ψ (finsupp.single a b)) : φ = ψ
theorem affine_subspace.lt_def {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P) : s1 < s2 ↔ ↑s1 ⊂ ↑s2
theorem measure_theory.tendsto_in_measure_of_tendsto_snorm_top {α : Type u_1} {ι : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} {E : Type u_3} [normed_group E] {f : ι → α → E} {g : α → E} {l : filter ι} (hfg : filter.tendsto (λ (n : ι), measure_theory.snorm (f n - g) ⊤ μ) l (nhds 0)) : measure_theory.tendsto_in_measure μ f l g
theorem orthogonal_projection_norm_le {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) [complete_space ↥K] : ∥orthogonal_projection K∥ ≤ 1
theorem add_monoid_algebra.mem_adjoin_support {R : Type u_1} {M : Type u_2} [comm_semiring R] [add_monoid M] (f : add_monoid_algebra R M) : f ∈ algebra.adjoin R (add_monoid_algebra.of' R M '' ↑(f.support))
theorem finset.prod_add_prod_le {ι : Type u_1} {R : Type u_8} [ordered_comm_semiring R] {s : finset ι} {i : ι} {f g h : ι → R} (hi : i ∈ s) (h2i : g i + h i ≤ f i) (hgf : ∀ (j : ι), j ∈ s → j ≠ i → g j ≤ f j) (hhf : ∀ (j : ι), j ∈ s → j ≠ i → h j ≤ f j) (hg : ∀ (i : ι), i ∈ s → 0 ≤ g i) (hh : ∀ (i : ι), i ∈ s → 0 ≤ h i) : s.prod (λ (i : ι), g i) + s.prod (λ (i : ι), h i) ≤ s.prod (λ (i : ι), f i)
theorem euclidean_geometry.dist_smul_vadd_sq {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (r : ℝ) (v : V) (p₁ p₂ : P) : has_dist.dist (r • v +ᵥ p₁) p₂ * has_dist.dist (r • v +ᵥ p₁) p₂ = has_inner.inner v v * r * r + 2 * has_inner.inner v (p₁ -ᵥ p₂) * r + has_inner.inner (p₁ -ᵥ p₂) (p₁ -ᵥ p₂)
theorem measure_theory.conservative.frequently_measure_inter_ne_zero {α : Type u_2} [measurable_space α] {f : α → α} {s : set α} {μ : measure_theory.measure α} (hf : measure_theory.conservative f μ) (hs : measurable_set s) (h0 : ⇑μ s ≠ 0) : ∃ᶠ (m : ℕ) in filter.at_top, ⇑μ (s ∩ f^[m] ⁻¹' s) ≠ 0
theorem exists_idempotent_of_compact_t2_of_continuous_add_left {M : Type u_1} [nonempty M] [add_semigroup M] [topological_space M] [compact_space M] [t2_space M] (continuous_mul_left : ∀ (r : M), continuous (λ (_x : M), _x + r)) : ∃ (m : M), m + m = m
theorem complex.is_trivial_topological_fiber_bundle_re  : is_trivial_topological_fiber_bundle ℝ complex.re
theorem nat.exists_prime_ge_modeq_one {k : ℕ} (n : ℕ) (hpos : 0 < k) : ∃ (p : ℕ), nat.prime p ∧ n ≤ p ∧ p ≡ 1 [MOD k]
theorem affine.simplex.orthogonal_projection_vadd_smul_vsub_orthogonal_projection {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P n) {p1 : P} (p2 : P) (r : ℝ) (hp : p1 ∈ affine_span ℝ (set.range s.points)) : ⇑(s.orthogonal_projection_span) (r • (p2 -ᵥ ↑(⇑(s.orthogonal_projection_span) p2)) +ᵥ p1) = ⟨p1, hp⟩
theorem complex.is_trivial_topological_fiber_bundle_im  : is_trivial_topological_fiber_bundle ℝ complex.im
theorem monovary_on.sum_comp_perm_smul_lt_sum_smul_iff {ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {s : finset ι} {σ : equiv.perm ι} {f : ι → α} {g : ι → β} (hfg : monovary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f (⇑σ i) • g i) < s.sum (λ (i : ι), f i • g i) ↔ ¬monovary_on (f ∘ ⇑σ) g ↑s
theorem con.to_setoid_inj {M : Type u_1} [has_mul M] {c d : con M} (H : c.to_setoid = d.to_setoid) : c = d
theorem lie_module.is_weight_zero_of_nilpotent {R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (M : Type w) [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [nontrivial M] [lie_algebra.is_nilpotent R L] [lie_module.is_nilpotent R L M] : lie_module.is_weight ⊤ M 0
theorem is_topological_fiber_bundle_fst {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.fst
theorem map_Sup_of_continuous_at_of_monotone' {α : Type u} {β : Type v} [complete_linear_order α] [topological_space α] [order_topology α] [complete_linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} (Cf : continuous_at f (has_Sup.Sup s)) (Mf : monotone f) (hs : s.nonempty) : f (has_Sup.Sup s) = has_Sup.Sup (f '' s)
theorem category_theory.adjunction.gc {X : Type u} {Y : Type v} [preorder X] [preorder Y] {L : X ⥤ Y} {R : Y ⥤ X} (adj : L ⊣ R) : galois_connection L.obj R.obj
theorem power_series.eq_X_mul_shift_add_const {R : Type u_1} [semiring R] (φ : power_series R) : φ = power_series.X * power_series.mk (λ (p : ℕ), ⇑(power_series.coeff R (p + 1)) φ) + ⇑(power_series.C R) (⇑(power_series.constant_coeff R) φ)
theorem dense_sUnion_interior_of_closed {α : Type u_1} [topological_space α] [baire_space α] {S : set (set α)} (hc : ∀ (s : set α), s ∈ S → is_closed s) (hS : S.countable) (hU : ⋃₀S = set.univ) : dense (⋃ (s : set α) (H : s ∈ S), interior s)
theorem semiconj_by.mul_right {S : Type u} [semigroup S] {a x y x' y' : S} (h : semiconj_by a x y) (h' : semiconj_by a x' y') : semiconj_by a (x * x') (y * y')
theorem power_series.eq_shift_mul_X_add_const {R : Type u_1} [semiring R] (φ : power_series R) : φ = power_series.mk (λ (p : ℕ), ⇑(power_series.coeff R (p + 1)) φ) * power_series.X + ⇑(power_series.C R) (⇑(power_series.constant_coeff R) φ)
theorem real.Lp_add_le {ι : Type u} (s : finset ι) (f g : ι → ℝ) {p : ℝ} (hp : 1 ≤ p) : s.sum (λ (i : ι), |f i + g i| ^ p) ^ (1 / p) ≤ s.sum (λ (i : ι), |f i| ^ p) ^ (1 / p) + s.sum (λ (i : ι), |g i| ^ p) ^ (1 / p)
theorem orientation.two_zsmul_oangle_neg_right {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x y : V) : 2 • o.oangle x (-y) = 2 • o.oangle x y
theorem monovary_on.sum_mul_comp_perm_le_sum_mul {ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {s : finset ι} {σ : equiv.perm ι} {f g : ι → α} (hfg : monovary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i * g (⇑σ i)) ≤ s.sum (λ (i : ι), f i * g i)
theorem orthogonal_family.has_sum_linear_isometry_equiv_symm {ι : Type u_1} {𝕜 : Type u_2} [is_R_or_C 𝕜] {E : Type u_3} [inner_product_space 𝕜 E] [cplt : complete_space E] {G : ι → Type u_4} [Π (i : ι), inner_product_space 𝕜 (G i)] {V : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : orthogonal_family 𝕜 V) [∀ (i : ι), complete_space (G i)] (hV' : (⨆ (i : ι), (V i).to_linear_map.range).topological_closure = ⊤) (w : ↥(lp G 2)) : has_sum (λ (i : ι), ⇑(V i) (⇑w i)) (⇑((hV.linear_isometry_equiv hV').symm) w)
theorem antitone.covariant_of_const' {N : Type u_2} {α : Type u_3} [preorder α] [preorder N] {f : N → α} {μ : N → N → N} [covariant_class N N (function.swap μ) has_le.le] (hf : antitone f) (m : N) : antitone (λ (n : N), f (μ n m))
theorem laurent_polynomial.induction_on' {R : Type u_1} [semiring R] {M : laurent_polynomial R → Prop} (p : laurent_polynomial R) (h_add : ∀ (p q : laurent_polynomial R), M p → M q → M (p + q)) (h_C_mul_T : ∀ (n : ℤ) (a : R), M (⇑laurent_polynomial.C a * laurent_polynomial.T n)) : M p
theorem orthonormal.inner_left_sum {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : orthonormal 𝕜 v) (l : ι → 𝕜) {s : finset ι} {i : ι} (hi : i ∈ s) : has_inner.inner (s.sum (λ (i : ι), l i • v i)) (v i) = ⇑(star_ring_end 𝕜) (l i)
theorem subring.mem_supr_of_directed {R : Type u} [ring R] {ι : Sort u_1} [hι : nonempty ι] {S : ι → subring R} (hS : directed has_le.le S) {x : R} : (x ∈ ⨆ (i : ι), S i) ↔ ∃ (i : ι), x ∈ S i
theorem euclidean_geometry.dist_eq_add_dist_iff_angle_eq_pi {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (hp1p2 : p1 ≠ p2) (hp3p2 : p3 ≠ p2) : has_dist.dist p1 p3 = has_dist.dist p1 p2 + has_dist.dist p3 p2 ↔ euclidean_geometry.angle p1 p2 p3 = real.pi
theorem module.nontrivial (R : Type u_1) (M : Type u_2) [semiring R] [nontrivial M] [add_comm_monoid M] [module R M] : nontrivial R
theorem antitone.max {α : Type u} {β : Type v} [preorder α] [linear_order β] {f g : α → β} (hf : antitone f) (hg : antitone g) : antitone (λ (x : α), linear_order.max (f x) (g x))
theorem formal_multilinear_series.left_inv_eq_right_inv {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) (i : E ≃L[𝕜] F) (h : p 1 = ⇑((continuous_multilinear_curry_fin1 𝕜 E F).symm) ↑i) : p.left_inv i = p.right_inv i
theorem function.embedding.schroeder_bernstein {α : Type u} {β : Type v} {f : α → β} {g : β → α} (hf : function.injective f) (hg : function.injective g) : ∃ (h : α → β), function.bijective h
theorem right.mul_le_one {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1
theorem submodule.dim_sup_add_dim_inf_eq {K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] (s t : submodule K V) [finite_dimensional K ↥s] [finite_dimensional K ↥t] : finite_dimensional.finrank K ↥(s ⊔ t) + finite_dimensional.finrank K ↥(s ⊓ t) = finite_dimensional.finrank K ↥s + finite_dimensional.finrank K ↥t
theorem ideal.polynomial.jacobson_bot_of_integral_localization {S : Type u_2} [comm_ring S] [is_domain S] {R : Type u_1} [comm_ring R] [is_domain R] [ideal.is_jacobson R] (Rₘ : Type u_3) (Sₘ : Type u_4) [comm_ring Rₘ] [comm_ring Sₘ] (φ : R →+* S) (hφ : function.injective ⇑φ) (x : R) (hx : x ≠ 0) [algebra R Rₘ] [is_localization.away x Rₘ] [algebra S Sₘ] [is_localization (submonoid.map ↑φ (submonoid.powers x)) Sₘ] (hφ' : (is_localization.map Sₘ φ _).is_integral) : ⊥.jacobson = ⊥
theorem mul_eq_mul_prime_prod {R : Type u_1} [cancel_comm_monoid_with_zero R] {α : Type u_2} [decidable_eq α] {x y a : R} {s : finset α} {p : α → R} (hp : ∀ (i : α), i ∈ s → prime (p i)) (hx : x * y = a * s.prod (λ (i : α), p i)) : ∃ (t u : finset α) (b c : R), t ∪ u = s ∧ disjoint t u ∧ a = b * c ∧ x = b * t.prod (λ (i : α), p i) ∧ y = c * u.prod (λ (i : α), p i)
theorem compact_covered_by_add_left_translates {G : Type w} [topological_space G] [add_group G] [topological_add_group G] {K V : set G} (hK : is_compact K) (hV : (interior V).nonempty) : ∃ (t : finset G), K ⊆ ⋃ (g : G) (H : g ∈ t), (λ (h : G), g + h) ⁻¹' V
theorem nat.prime.multiplicity_choose {p n k b : ℕ} (hp : nat.prime p) (hkn : k ≤ n) (hnb : nat.log p n < b) : multiplicity p (n.choose k) = ↑((finset.filter (λ (i : ℕ), p ^ i ≤ k % p ^ i + (n - k) % p ^ i) (finset.Ico 1 b)).card)
theorem subsemigroup.closure_le {M : Type u_1} [has_mul M] {s : set M} {S : subsemigroup M} : subsemigroup.closure s ≤ S ↔ s ⊆ ↑S
theorem finset.prod_cancels_of_partition_cancels {β : Type u} {α : Type v} {s : finset α} {f : α → β} [comm_monoid β] (R : setoid α) [decidable_rel setoid.r] (h : ∀ (x : α), x ∈ s → (finset.filter (λ (y : α), y ≈ x) s).prod (λ (a : α), f a) = 1) : s.prod (λ (x : α), f x) = 1
theorem setoid.eq_of_mem_classes {α : Type u_1} {r : setoid α} {x : α} {b : set α} (hc : b ∈ r.classes) (hb : x ∈ b) {b' : set α} (hc' : b' ∈ r.classes) (hb' : x ∈ b') : b = b'
theorem eq_rec_constant {α : Sort u_1} {a a' : α} {β : Sort u_2} (y : β) (h : a = a') : eq.rec y h = y
theorem free_group.red.step.length {α : Type u} {L₁ L₂ : list (α × bool)} : free_group.red.step L₁ L₂ → L₂.length + 2 = L₁.length
theorem concave_on.translate_right {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [ordered_add_comm_monoid β] [module 𝕜 E] [has_scalar 𝕜 β] {s : set E} {f : E → β} (hf : concave_on 𝕜 s f) (c : E) : concave_on 𝕜 ((λ (z : E), c + z) ⁻¹' s) (f ∘ λ (z : E), c + z)
theorem strict_convex.affine_preimage {𝕜 : Type u_1} {E : Type u_3} {F : Type u_4} [ordered_ring 𝕜] [topological_space E] [topological_space F] [add_comm_group E] [add_comm_group F] [module 𝕜 E] [module 𝕜 F] {s : set F} (hs : strict_convex 𝕜 s) {f : E →ᵃ[𝕜] F} (hf : continuous ⇑f) (hfinj : function.injective ⇑f) : strict_convex 𝕜 (⇑f ⁻¹' s)
theorem submodule.is_internal_prime_power_torsion_of_pid {R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {M : Type v} [add_comm_group M] [module R M] [module.finite R M] (hM : module.is_torsion R M) : ∃ (ι : Type u) [_inst_9 : fintype ι] [_inst_10 : decidable_eq ι] (p : ι → R) [_inst_11 : ∀ (i : ι), irreducible (p i)] (e : ι → ℕ), direct_sum.is_internal (λ (i : ι), submodule.torsion_by R M (p i ^ e i))
theorem char.quadratic_char_dichotomy {F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0) : char.quadratic_char F a = 1 ∨ char.quadratic_char F a = -1
theorem orthogonal_projection_bot {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] : orthogonal_projection ⊥ = 0
theorem mul_is_left_regular_iff {R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_left_regular a) : is_left_regular (a * b) ↔ is_left_regular b
theorem le_inv_mul_of_mul_le {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α} : a * b ≤ c → b ≤ a⁻¹ * c
theorem nat.gcd_eq_gcd_ab (x y : ℕ) : ↑(x.gcd y) = ↑x * x.gcd_a y + ↑y * x.gcd_b y
theorem gram_schmidt_orthogonal (𝕜 : Type u_1) {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_3} [linear_order ι] [order_bot ι] [locally_finite_order ι] [is_well_order ι has_lt.lt] (f : ι → E) {a b : ι} (h₀ : a ≠ b) : has_inner.inner (gram_schmidt 𝕜 f a) (gram_schmidt 𝕜 f b) = 0
theorem measure_theory.lintegral_eq_zero_of_is_add_left_invariant {G : Type u_4} [measurable_space G] {μ : measure_theory.measure G} [topological_space G] [add_group G] [topological_add_group G] [borel_space G] [μ.is_add_left_invariant] [μ.regular] (hμ : μ ≠ 0) {f : G → ennreal} (hf : continuous f) : ∫⁻ (x : G), f x ∂μ = 0 ↔ f = 0
theorem vector_span_mono (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s₁ s₂ : set P} (h : s₁ ⊆ s₂) : vector_span k s₁ ≤ vector_span k s₂
theorem submonoid.localization_map.lift_mul_right {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M →* P} (hg : ∀ (y : ↥S), is_unit (⇑g ↑y)) (z : N) : ⇑(f.lift hg) z * ⇑g ↑((f.sec z).snd) = ⇑g (f.sec z).fst
theorem ereal.neg_le_of_neg_le {a b : ereal} (h : -a ≤ b) : -b ≤ a
theorem is_seq_closed_iff_is_closed {X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s ↔ is_closed s
theorem has_fderiv_at.le_of_lip {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {x₀ : E} (hf : has_fderiv_at f f' x₀) {s : set E} (hs : s ∈ nhds x₀) {C : nnreal} (hlip : lipschitz_on_with C f s) : ∥f'∥ ≤ ↑C
theorem pow_four_add_four_mul_pow_four {R : Type u_1} [comm_ring R] {a b : R} : a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)
theorem matrix.inv_of_mul_self {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) [invertible A] : (⅟ A).mul A = 1
theorem subfield.prod_mem {K : Type u} [field K] (s : subfield K) {ι : Type u_1} {t : finset ι} {f : ι → K} (h : ∀ (c : ι), c ∈ t → f c ∈ s) : t.prod (λ (i : ι), f i) ∈ s
theorem continuous_map.congr_arg {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : C(α, β)) {x y : α} (h : x = y) : ⇑f x = ⇑f y
theorem zero_lt.left.one_lt_mul_of_le_of_lt {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 1 ≤ a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b
theorem continuous_linear_map.adjoint_inner_left {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [inner_product_space 𝕜 F] [complete_space E] [complete_space F] (A : E →L[𝕜] F) (x : E) (y : F) : has_inner.inner (⇑(⇑continuous_linear_map.adjoint A) y) x = has_inner.inner y (⇑A x)
theorem lie_module.coe_lower_central_series_ideal_le {R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] {I : lie_ideal R L} (k : ℕ) : ↑(lie_module.lower_central_series R ↥I ↥I k) ≤ ↑(lie_module.lower_central_series R L ↥I k)
theorem finite_dimensional.finrank_eq_card_finset_basis {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type w} {b : finset ι} (h : basis ↥b K V) : finite_dimensional.finrank K V = b.card
theorem fin.nat_add_cast {n n' : ℕ} (m : ℕ) (i : fin n') (h : n' = n) : ⇑(fin.nat_add m) (⇑(fin.cast h) i) = ⇑(fin.cast _) (⇑(fin.nat_add m) i)
theorem monoid_hom.congr_arg {M : Type u_3} {N : Type u_4} [mul_one_class M] [mul_one_class N] (f : M →* N) {x y : M} (h : x = y) : ⇑f x = ⇑f y
theorem measurable_of_tendsto_nnreal {α : Type u_1} [measurable_space α] {f : ℕ → α → nnreal} {g : α → nnreal} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g
theorem pgame.lf_zero_le {x : pgame} : x.lf 0 ↔ ∃ (j : x.right_moves), x.move_right j ≤ 0
theorem asymptotics.is_O.neg_left {α : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : α → F} {f' : α → E'} {l : filter α} : f' =O[l] g → (λ (x : α), -f' x) =O[l] g
theorem category_theory.limits.pushout.hom_ext {C : Type u} [category_theory.category C] {X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z} [category_theory.limits.has_pushout f g] {W : C} {k l : category_theory.limits.pushout f g ⟶ W} (h₀ : category_theory.limits.pushout.inl ≫ k = category_theory.limits.pushout.inl ≫ l) (h₁ : category_theory.limits.pushout.inr ≫ k = category_theory.limits.pushout.inr ≫ l) : k = l
theorem monotone.dual_left {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} : monotone f → antitone (f ∘ ⇑order_dual.of_dual)
theorem interval_integral.integral_le_sub_of_has_deriv_right_of_le {a b : ℝ} {g' g φ : ℝ → ℝ} (hab : a ≤ b) (hcont : continuous_on g (set.Icc a b)) (hderiv : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_within_at g (g' x) (set.Ioi x) x) (φint : measure_theory.integrable_on φ (set.Icc a b) measure_theory.measure_space.volume) (hφg : ∀ (x : ℝ), x ∈ set.Ioo a b → φ x ≤ g' x) : ∫ (y : ℝ) in a..b, φ y ≤ g b - g a
theorem exp_series_radius_eq_top (𝕂 : Type u_1) (𝔸 : Type u_2) [is_R_or_C 𝕂] [normed_ring 𝔸] [normed_algebra 𝕂 𝔸] : (exp_series 𝕂 𝔸).radius = ⊤
theorem ring_hom.eq_on_field_closure {K : Type u} {L : Type v} [field K] [field L] {f g : K →+* L} {s : set K} (h : set.eq_on ⇑f ⇑g s) : set.eq_on ⇑f ⇑g ↑(subfield.closure s)
theorem affine_subspace.eq_iff_direction_eq_of_mem {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s₁ s₂ : affine_subspace k P} {p : P} (h₁ : p ∈ s₁) (h₂ : p ∈ s₂) : s₁ = s₂ ↔ s₁.direction = s₂.direction
theorem category_theory.limits.has_strict_terminal_objects_of_terminal_is_strict {C : Type u} [category_theory.category C] (I : C) (h : ∀ (A : C) (f : I ⟶ A), category_theory.is_iso f) : category_theory.limits.has_strict_terminal_objects C
theorem unique_factorization_monoid.dvd_of_dvd_mul_right_of_no_prime_factors {R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] {a b c : R} (ha : a ≠ 0) (no_factors : ∀ {d : R}, d ∣ a → d ∣ b → ¬prime d) : a ∣ b * c → a ∣ c
theorem affine_subspace.affine_span_eq_top_iff_vector_span_eq_top_of_nontrivial (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s : set P} [nontrivial P] : affine_span k s = ⊤ ↔ vector_span k s = ⊤
theorem category_theory.sheaf.subcanonical.is_sheaf_of_representable {C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} (hJ : category_theory.sheaf.subcanonical J) (P : Cᵒᵖ ⥤ Type v) [P.representable] : category_theory.presieve.is_sheaf J P
theorem dense_iff_inter_open {α : Type u} [topological_space α] {s : set α} : dense s ↔ ∀ (U : set α), is_open U → U.nonempty → (U ∩ s).nonempty
theorem finset.subset_vadd {α : Type u_2} {β : Type u_3} [decidable_eq β] [has_vadd α β] {u : finset β} {s : set α} {t : set β} : ↑u ⊆ s +ᵥ t → (∃ (s' : finset α) (t' : finset β), ↑s' ⊆ s ∧ ↑t' ⊆ t ∧ u ⊆ s' +ᵥ t')
theorem orthogonal_projection_unit_singleton (𝕜 : Type u_1) {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {v : E} (hv : ∥v∥ = 1) (w : E) : ↑(⇑(orthogonal_projection (submodule.span 𝕜 {v})) w) = has_inner.inner v w • v
theorem zero_lt.left.one_lt_mul_of_lt_of_le {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : 1 < a) (hb : 1 ≤ b) (a0 : 0 < a) : 1 < a * b
theorem finsum_mem_add_diff' {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} {s t : set α} (hst : s ⊆ t) (ht : (t ∩ function.support f).finite) : finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) + finsum (λ (i : α), finsum (λ (H : i ∈ t  s), f i)) = finsum (λ (i : α), finsum (λ (H : i ∈ t), f i))
theorem abs_real_inner_div_norm_mul_norm_eq_one_iff {F : Type u_3} [inner_product_space ℝ F] (x y : F) : |has_inner.inner x y / (∥x∥ * ∥y∥)| = 1 ↔ x ≠ 0 ∧ ∃ (r : ℝ), r ≠ 0 ∧ y = r • x
theorem exists_subset_is_orthonormal_basis {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {v : set E} [finite_dimensional 𝕜 E] (hv : orthonormal 𝕜 coe) : ∃ (u : set E) (H : u ⊇ v) (b : basis ↥u 𝕜 E), orthonormal 𝕜 ⇑b ∧ ⇑b = coe
theorem real.Inf_nonpos (S : set ℝ) (hS : ∀ (x : ℝ), x ∈ S → x ≤ 0) : has_Inf.Inf S ≤ 0
theorem measure_theory.mul_le_add_haar_image_of_lt_det {E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] [measurable_space E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (A : E →L[ℝ] E) {m : nnreal} (hm : ↑m < ennreal.of_real |A.det|) : ∀ᶠ (δ : nnreal) in nhds_within 0 (set.Ioi 0), ∀ (s : set E) (f : E → E), approximates_linear_on f A s δ → ↑m * ⇑μ s ≤ ⇑μ (f '' s)
theorem submodule.sup_orthogonal_inf_of_complete_space {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K₁ K₂ : submodule 𝕜 E} (h : K₁ ≤ K₂) [complete_space ↥K₁] : K₁ ⊔ K₁ᗮ ⊓ K₂ = K₂
theorem euclidean_geometry.circumradius_eq_of_cospherical_subset {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} {ps : set P} (h : ps ⊆ ↑s) [nonempty ↥s] {n : ℕ} [finite_dimensional ℝ ↥(s.direction)] (hd : finite_dimensional.finrank ℝ ↥(s.direction) = n) (hc : euclidean_geometry.cospherical ps) {sx₁ sx₂ : affine.simplex ℝ P n} (hsx₁ : set.range sx₁.points ⊆ ps) (hsx₂ : set.range sx₂.points ⊆ ps) : sx₁.circumradius = sx₂.circumradius
theorem function.surjective.comp_left {α : Sort u} {β : Sort v} {γ : Sort w} {g : β → γ} (hg : function.surjective g) : function.surjective (function.comp g)
theorem has_deriv_within_at.Ioi_of_Ici {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {F : Type v} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜} [partial_order 𝕜] : has_deriv_within_at f f' (set.Ici x) x → has_deriv_within_at f f' (set.Ioi x) x
theorem euclidean_geometry.cospherical_empty {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] : euclidean_geometry.cospherical ∅
theorem set.eq_of_Ico_disjoint {α : Type v} [linear_order α] {x₁ x₂ y₁ y₂ : α} (h : disjoint (set.Ico x₁ x₂) (set.Ico y₁ y₂)) (hx : x₁ < x₂) (h2 : x₂ ∈ set.Ico y₁ y₂) : y₁ = x₂
theorem power_series.span_X_is_prime {R : Type u_1} [comm_ring R] [is_domain R] : (ideal.span {power_series.X}).is_prime
theorem polynomial.gal.gal_action_hom_injective {F : Type u_1} [field F] (p : polynomial F) (E : Type u_2) [field E] [algebra F E] [fact (polynomial.splits (algebra_map F E) p)] : function.injective ⇑(polynomial.gal.gal_action_hom p E)
theorem measure_theory.signed_measure.to_signed_measure_to_jordan_decomposition {α : Type u_1} [measurable_space α] (s : measure_theory.signed_measure α) : s.to_jordan_decomposition.to_signed_measure = s
theorem category_theory.limits.has_coequalizers_of_has_colimit_parallel_pair (C : Type u) [category_theory.category C] [∀ {X Y : C} {f g : X ⟶ Y}, category_theory.limits.has_colimit (category_theory.limits.parallel_pair f g)] : category_theory.limits.has_coequalizers C
theorem affine_subspace.vsub_right_mem_direction_iff_mem {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p : P} (hp : p ∈ s) (p2 : P) : p2 -ᵥ p ∈ s.direction ↔ p2 ∈ s
theorem continuous_within_at.integral_sub_linear_is_o_ae {α : Type u_1} {E : Type u_3} [measurable_space α] {ι : Type u_5} [normed_group E] [topological_space α] [opens_measurable_space α] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} [measure_theory.is_locally_finite_measure μ] {a : α} {t : set α} {f : α → E} (ha : continuous_within_at f t a) (ht : measurable_set t) (hfm : strongly_measurable_at_filter f (nhds_within a t) μ) {s : ι → set α} {li : filter ι} (hs : filter.tendsto s li (nhds_within a t).small_sets) (m : ι → ℝ := λ (i : ι), (⇑μ (s i)).to_real) (hsμ : (λ (i : ι), (⇑μ (s i)).to_real) =ᶠ[li] m . "refl") : (λ (i : ι), ∫ (x : α) in s i, f x ∂μ - m i • f a) =o[li] m
theorem matrix.pivot.list_transvec_col_mul_last_col {𝕜 : Type u_3} [field 𝕜] {r : ℕ} (M : matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜) (hM : M (sum.inr ()) (sum.inr ()) ≠ 0) (i : fin r) : (matrix.pivot.list_transvec_col M).prod.mul M (sum.inl i) (sum.inr ()) = 0
theorem has_deriv_at.has_fderiv_at {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {F : Type v} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {x : 𝕜} {f' : F} : has_deriv_at f f' x → has_fderiv_at f (1.smul_right f') x
theorem nat.factorization_central_binom_eq_zero_of_two_mul_lt {p n : ℕ} (h : 2 * n < p) : ⇑(n.central_binom.factorization) p = 0
theorem semiconj_by.conj_mk {G : Type u} [group G] (a x : G) : semiconj_by a x (a * x * a⁻¹)
theorem has_deriv_at_interval_right_endpoint_of_tendsto_deriv {E : Type u_1} [normed_group E] [normed_space ℝ E] {s : set ℝ} {e : E} {a : ℝ} {f : ℝ → E} (f_diff : differentiable_on ℝ f s) (f_lim : continuous_within_at f s a) (hs : s ∈ nhds_within a (set.Iio a)) (f_lim' : filter.tendsto (λ (x : ℝ), deriv f x) (nhds_within a (set.Iio a)) (nhds e)) : has_deriv_within_at f e (set.Iic a) a
theorem laurent_polynomial.reduce_to_polynomial_of_mul_T {R : Type u_1} [semiring R] (f : laurent_polynomial R) {Q : laurent_polynomial R → Prop} (Qf : ∀ (f : polynomial R), Q (⇑polynomial.to_laurent f)) (QT : ∀ (f : laurent_polynomial R), Q (f * laurent_polynomial.T 1) → Q f) : Q f
theorem representation.average_map_id {k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_semiring k] [group G] [add_comm_monoid V] [module k V] (ρ : representation k G V) [fintype G] [invertible ↑(fintype.card G)] (v : V) (hv : v ∈ ρ.invariants) : ⇑(ρ.average_map) v = v
theorem subgroup.fg_iff_submonoid_fg {G : Type u_3} [group G] (P : subgroup G) : P.fg ↔ P.to_submonoid.fg
theorem has_compact_support.has_fderiv_at_convolution_right {𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G → E} {g : G → E'} [is_R_or_C 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space ℝ F] [normed_space 𝕜 F] [complete_space F] [measurable_space G] {μ : measure_theory.measure G} (L : E →L[𝕜] E' →L[𝕜] F) [normed_group G] [borel_space G] [topological_space.second_countable_topology G] [sigma_compact_space G] [measure_theory.sigma_finite μ] [μ.is_add_left_invariant] [normed_space 𝕜 G] [proper_space G] (hcg : has_compact_support g) (hf : measure_theory.locally_integrable f μ) (hg : cont_diff 𝕜 1 g) (x₀ : G) : has_fderiv_at (convolution f g L μ) (convolution f (fderiv 𝕜 g) (continuous_linear_map.precompR G L) μ x₀) x₀
theorem geometry.simplicial_complex.face_subset_face_iff {𝕜 : Type u_1} {E : Type u_2} [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] {K : geometry.simplicial_complex 𝕜 E} {s t : finset E} (hs : s ∈ K.faces) (ht : t ∈ K.faces) : ⇑(convex_hull 𝕜) ↑s ⊆ ⇑(convex_hull 𝕜) ↑t ↔ s ⊆ t
theorem category_theory.any_functor_const_on_obj {J : Type u₁} [category_theory.category J] [category_theory.is_preconnected J] {α : Type u₁} (F : J ⥤ category_theory.discrete α) (j j' : J) : F.obj j = F.obj j'
theorem box_integral.has_integral_zero_of_ae_eq_zero {ι : Type u} {E : Type v} [fintype ι] [normed_group E] [normed_space ℝ E] {l : box_integral.integration_params} {I : box_integral.box ι} {f : (ι → ℝ) → E} {μ : measure_theory.measure (ι → ℝ)} [measure_theory.is_locally_finite_measure μ] (hf : f =ᵐ[μ.restrict ↑I] 0) (hl : l.bRiemann = bool.ff) : box_integral.has_integral I l f μ.to_box_additive.to_smul 0
theorem measure_theory.tendsto_in_measure_of_tendsto_snorm_of_strongly_measurable {α : Type u_1} {ι : Type u_2} {E : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [normed_group E] {p : ennreal} {f : ι → α → E} {g : α → E} (hp_ne_zero : p ≠ 0) (hp_ne_top : p ≠ ⊤) (hf : ∀ (n : ι), measure_theory.strongly_measurable (f n)) (hg : measure_theory.strongly_measurable g) {l : filter ι} (hfg : filter.tendsto (λ (n : ι), measure_theory.snorm (f n - g) p μ) l (nhds 0)) : measure_theory.tendsto_in_measure μ f l g
theorem continuous_on.surj_on_Icc {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {δ : Type u_1} [linear_order δ] [topological_space δ] [order_closed_topology δ] {s : set α} [hs : s.ord_connected] {f : α → δ} (hf : continuous_on f s) {a b : α} (ha : a ∈ s) (hb : b ∈ s) : set.surj_on f s (set.Icc (f a) (f b))
theorem sequentially_complete.le_nhds_of_seq_tendsto_nhds {α : Type u} [uniform_space α] {f : filter α} (hf : cauchy f) {U : ℕ → set (α × α)} (U_mem : ∀ (n : ℕ), U n ∈ uniformity α) (U_le : ∀ (s : set (α × α)), s ∈ uniformity α → (∃ (n : ℕ), U n ⊆ s)) ⦃a : α⦄ (ha : filter.tendsto (sequentially_complete.seq hf U_mem) filter.at_top (nhds a)) : f ≤ nhds a
theorem category_theory.comp_left_adjoint_mate {C : Type u₁} [category_theory.category C] [category_theory.monoidal_category C] {X Y Z : C} [category_theory.has_left_dual X] [category_theory.has_left_dual Y] [category_theory.has_left_dual Z] {f : X ⟶ Y} {g : Y ⟶ Z} : ᘁ(f ≫ g) = ᘁg ≫ ᘁf
theorem is_lub.union {γ : Type w} [semilattice_sup γ] {a b : γ} {s t : set γ} (hs : is_lub s a) (ht : is_lub t b) : is_lub (s ∪ t) (a ⊔ b)
theorem continuous_linear_map.is_compact_image_coe_of_bounded_of_closed_image {𝕜 : Type u_1} {𝕜₂ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {E' : Type u_10} [semi_normed_group E'] [normed_space 𝕜 E'] [ring_hom_isometric σ₁₂] [proper_space F] {s : set (E' →SL[σ₁₂] F)} (hb : metric.bounded s) (hc : is_closed (coe_fn '' s)) : is_compact (coe_fn '' s)
theorem ratfunc.num_div_dvd' {K : Type u} [hfield : field K] (p : polynomial K) {q : polynomial K} (hq : q ≠ 0) : ⇑polynomial.C ((q / gcd_monoid.gcd p q).leading_coeff)⁻¹ * (p / gcd_monoid.gcd p q) ∣ p
theorem affine_independent_iff_indicator_eq_of_affine_combination_eq (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} (p : ι → P) : affine_independent k p ↔ ∀ (s1 s2 : finset ι) (w1 w2 : ι → k), s1.sum (λ (i : ι), w1 i) = 1 → s2.sum (λ (i : ι), w2 i) = 1 → ⇑(s1.affine_combination p) w1 = ⇑(s2.affine_combination p) w2 → ↑s1.indicator w1 = ↑s2.indicator w2
theorem submodule.fg_ker_comp {R : Type u_1} {M : Type u_2} {N : Type u_3} {P : Type u_4} [ring R] [add_comm_group M] [module R M] [add_comm_group N] [module R N] [add_comm_group P] [module R P] (f : M →ₗ[R] N) (g : N →ₗ[R] P) (hf1 : f.ker.fg) (hf2 : g.ker.fg) (hsur : function.surjective ⇑f) : (g.comp f).ker.fg
theorem orientation.oangle_rotation_left {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : real.angle) : o.oangle (⇑(o.rotation θ) x) y = o.oangle x y - θ
theorem cont_diff_const {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : with_top ℕ} {c : F} : cont_diff 𝕜 n (λ (x : E), c)
theorem dense.exists_countable_dense_subset_no_bot_top {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] [nontrivial α] {s : set α} [topological_space.separable_space ↥s] (hs : dense s) : ∃ (t : set α) (H : t ⊆ s), t.countable ∧ dense t ∧ (∀ (x : α), is_bot x → x ∉ t) ∧ ∀ (x : α), is_top x → x ∉ t
theorem formal_multilinear_series.comp_coeff_zero'' {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [comm_ring 𝕜] [add_comm_group E] [add_comm_group F] [module 𝕜 E] [module 𝕜 F] [topological_space E] [topological_space F] [topological_add_group E] [has_continuous_const_smul 𝕜 E] [topological_add_group F] [has_continuous_const_smul 𝕜 F] (q : formal_multilinear_series 𝕜 E F) (p : formal_multilinear_series 𝕜 E E) : q.comp p 0 = q 0
theorem mul_ne_zero_iff {M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b ≠ 0 ↔ a ≠ 0 ∧ b ≠ 0
theorem orthonormal_subtype_iff_ite {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [dec_E : decidable_eq E] {s : set E} : orthonormal 𝕜 coe ↔ ∀ (v : E), v ∈ s → ∀ (w : E), w ∈ s → has_inner.inner v w = ite (v = w) 1 0
theorem add_subsemigroup.closure_induction {M : Type u_1} [has_add M] {s : set M} {p : M → Prop} {x : M} (h : x ∈ add_subsemigroup.closure s) (Hs : ∀ (x : M), x ∈ s → p x) (Hmul : ∀ (x y : M), p x → p y → p (x + y)) : p x
theorem add_monoid_hom.map_zsmul {α : Type u_1} {β : Type u_2} [add_group α] [subtraction_monoid β] (f : α →+ β) (g : α) (n : ℤ) : ⇑f (n • g) = n • ⇑f g
theorem left.mul_lt_one' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1
theorem measure_theory.measure.finite_spanning_sets_in.sigma_finite {α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {C : set (set α)} (h : μ.finite_spanning_sets_in C) : measure_theory.sigma_finite μ
theorem measure_theory.tendsto_uniformly_on_of_ae_tendsto' {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} [metric_space β] {μ : measure_theory.measure α} [semilattice_sup ι] [nonempty ι] [encodable ι] {f : ι → α → β} {g : α → β} [measure_theory.is_finite_measure μ] (hf : ∀ (n : ι), measure_theory.strongly_measurable (f n)) (hg : measure_theory.strongly_measurable g) (hfg : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ι), f n x) filter.at_top (nhds (g x))) {ε : ℝ} (hε : 0 < ε) : ∃ (t : set α), measurable_set t ∧ ⇑μ t ≤ ennreal.of_real ε ∧ tendsto_uniformly_on f g filter.at_top tᶜ
theorem add_monoid_algebra.map_domain_mul {α : Type u_1} {β : Type u_2} {α₂ : Type u_3} [semiring β] [has_add α] [has_add α₂] {F : Type u_4} [add_hom_class F α α₂] (f : F) (x y : add_monoid_algebra β α) : finsupp.map_domain ⇑f (x * y) = finsupp.map_domain ⇑f x * finsupp.map_domain ⇑f y
theorem finset.subset_mul {α : Type u_2} [decidable_eq α] [has_mul α] {u : finset α} {s t : set α} : ↑u ⊆ s * t → (∃ (s' t' : finset α), ↑s' ⊆ s ∧ ↑t' ⊆ t ∧ u ⊆ s' * t')
theorem affine_independent_iff_eq_of_fintype_affine_combination_eq (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} [fintype ι] (p : ι → P) : affine_independent k p ↔ ∀ (w1 w2 : ι → k), finset.univ.sum (λ (i : ι), w1 i) = 1 → finset.univ.sum (λ (i : ι), w2 i) = 1 → ⇑(finset.univ.affine_combination p) w1 = ⇑(finset.univ.affine_combination p) w2 → w1 = w2
theorem dfinsupp.comp_lift_add_hom {ι : Type u} {γ : Type w} {β : ι → Type v} [dec : decidable_eq ι] {δ : Type u_1} [Π (i : ι), add_zero_class (β i)] [add_comm_monoid γ] [add_comm_monoid δ] (g : γ →+ δ) (f : Π (i : ι), β i →+ γ) : g.comp (⇑dfinsupp.lift_add_hom f) = ⇑dfinsupp.lift_add_hom (λ (a : ι), g.comp (f a))
theorem measure_theory.tendsto_in_measure.exists_seq_tendsto_ae {α : Type u_1} {E : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [metric_space E] {f : ℕ → α → E} {g : α → E} (hfg : measure_theory.tendsto_in_measure μ f filter.at_top g) : ∃ (ns : ℕ → ℕ), strict_mono ns ∧ ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (i : ℕ), f (ns i) x) filter.at_top (nhds (g x))
theorem has_fpower_series_on_ball.r_eq_top_of_exists {𝕜 : Type u_1} {E : Type u_2} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] {f : 𝕜 → E} {r : ennreal} {x : 𝕜} {p : formal_multilinear_series 𝕜 𝕜 E} (h : has_fpower_series_on_ball f p x r) (h' : ∀ (r' : nnreal), 0 < r' → (∃ (p' : formal_multilinear_series 𝕜 𝕜 E), has_fpower_series_on_ball f p' x ↑r')) : has_fpower_series_on_ball f p x ⊤
theorem free_algebra.induction (R : Type u_1) [comm_semiring R] (X : Type u_2) {C : free_algebra R X → Prop} (h_grade0 : ∀ (r : R), C (⇑(algebra_map R (free_algebra R X)) r)) (h_grade1 : ∀ (x : X), C (free_algebra.ι R x)) (h_mul : ∀ (a b : free_algebra R X), C a → C b → C (a * b)) (h_add : ∀ (a b : free_algebra R X), C a → C b → C (a + b)) (a : free_algebra R X) : C a
theorem asymptotics.is_O_with.of_norm_norm {α : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_normed_group E'] [semi_normed_group F'] {c : ℝ} {f' : α → E'} {g' : α → F'} {l : filter α} : asymptotics.is_O_with c l (λ (x : α), ∥f' x∥) (λ (x : α), ∥g' x∥) → asymptotics.is_O_with c l f' g'
theorem measure_theory.tendsto_set_to_fun_of_dominated_convergence {α : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {m : measurable_space α} {μ : measure_theory.measure α} [complete_space F] {T : set α → (E →L[ℝ] F)} {C : ℝ} (hT : measure_theory.dominated_fin_meas_additive μ T C) {fs : ℕ → α → E} {f : α → E} (bound : α → ℝ) (fs_measurable : ∀ (n : ℕ), measure_theory.ae_strongly_measurable (fs n) μ) (bound_integrable : measure_theory.integrable bound μ) (h_bound : ∀ (n : ℕ), ∀ᵐ (a : α) ∂μ, ∥fs n a∥ ≤ bound a) (h_lim : ∀ᵐ (a : α) ∂μ, filter.tendsto (λ (n : ℕ), fs n a) filter.at_top (nhds (f a))) : filter.tendsto (λ (n : ℕ), measure_theory.set_to_fun μ T hT (fs n)) filter.at_top (nhds (measure_theory.set_to_fun μ T hT f))
theorem is_topological_fiber_bundle.comap {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] {B' : Type u_5} [topological_space B'] (h : is_topological_fiber_bundle F proj) {f : B' → B} (hf : continuous f) : is_topological_fiber_bundle F (λ (x : ↥{p : B' × Z | f p.fst = proj p.snd}), ↑x.fst)
theorem dist_le_range_sum_of_dist_le {α : Type u} [pseudo_metric_space α] {f : ℕ → α} (n : ℕ) {d : ℕ → ℝ} (hd : ∀ {k : ℕ}, k < n → has_dist.dist (f k) (f (k + 1)) ≤ d k) : has_dist.dist (f 0) (f n) ≤ (finset.range n).sum (λ (i : ℕ), d i)
theorem cont_diff_at.mul {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {x : E} {n : with_top ℕ} {f g : E → 𝕜} (hf : cont_diff_at 𝕜 n f x) (hg : cont_diff_at 𝕜 n g x) : cont_diff_at 𝕜 n (λ (x : E), f x * g x) x
theorem order.exists_between_finsets {α : Type u_1} [linear_order α] [densely_ordered α] [no_min_order α] [no_max_order α] [nonem : nonempty α] (lo hi : finset α) (lo_lt_hi : ∀ (x : α), x ∈ lo → ∀ (y : α), y ∈ hi → x < y) : ∃ (m : α), (∀ (x : α), x ∈ lo → x < m) ∧ ∀ (y : α), y ∈ hi → m < y
theorem matrix.pivot.list_transvec_col_mul_mul_list_transvec_row_last_col {𝕜 : Type u_3} [field 𝕜] {r : ℕ} (M : matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜) (hM : M (sum.inr ()) (sum.inr ()) ≠ 0) (i : fin r) : ((matrix.pivot.list_transvec_col M).prod.mul M).mul (matrix.pivot.list_transvec_row M).prod (sum.inr ()) (sum.inl i) = 0
theorem exists_quadratic_eq_zero {K : Type u_1} [field K] [invertible 2] {a b c : K} (ha : a ≠ 0) (h : ∃ (s : K), discrim a b c = s * s) : ∃ (x : K), a * x * x + b * x + c = 0
theorem matrix.det_succ_column {R : Type v} [comm_ring R] {n : ℕ} (A : matrix (fin n.succ) (fin n.succ) R) (j : fin n.succ) : A.det = finset.univ.sum (λ (i : fin n.succ), (-1) ^ (↑i + ↑j) * A i j * (A.minor ⇑(i.succ_above) ⇑(j.succ_above)).det)
theorem finset.image₂_distrib_subset_left {α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ' : Type u_6} {δ : Type u_7} {ε : Type u_9} [decidable_eq β'] [decidable_eq γ'] [decidable_eq δ] [decidable_eq ε] {s : finset α} {t : finset β} {γ : Type u_2} {u : finset γ} {f : α → δ → ε} {g : β → γ → δ} {f₁ : α → β → β'} {f₂ : α → γ → γ'} {g' : β' → γ' → ε} (h_distrib : ∀ (a : α) (b : β) (c : γ), f a (g b c) = g' (f₁ a b) (f₂ a c)) : finset.image₂ f s (finset.image₂ g t u) ⊆ finset.image₂ g' (finset.image₂ f₁ s t) (finset.image₂ f₂ s u)
theorem finprod_mem_pair {α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M} {a b : α} (h : a ≠ b) : finprod (λ (i : α), finprod (λ (H : i ∈ {a, b}), f i)) = f a * f b
theorem basis.maximal {ι : Type u_1} {R : Type u_3} {M : Type u_5} [ring R] [add_comm_group M] [module R M] [nontrivial R] (b : basis ι R M) : _.maximal
theorem is_left_regular.of_mul {R : Type u_1} {a b : R} [semigroup R] (ab : is_left_regular (a * b)) : is_left_regular b
theorem absorbent.gauge_set_nonempty {E : Type u_1} [add_comm_group E] [module ℝ E] {s : set E} {x : E} (absorbs : absorbent ℝ s) : {r : ℝ | 0 < r ∧ x ∈ r • s}.nonempty
theorem zero_lt.right.mul_lt_one_of_lt_of_lt {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : a < 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1
theorem is_noetherian.bijective_of_surjective_endomorphism {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [is_noetherian R M] (f : M →ₗ[R] M) (s : function.surjective ⇑f) : function.bijective ⇑f
theorem fin.succ_above_right_inj {n : ℕ} {a b : fin n} {x : fin (n + 1)} : ⇑(x.succ_above) a = ⇑(x.succ_above) b ↔ a = b
theorem has_strict_fderiv_at.comp {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {f : E → F} {f' : E →L[𝕜] F} (x : E) {g : F → G} {g' : F →L[𝕜] G} (hg : has_strict_fderiv_at g g' (f x)) (hf : has_strict_fderiv_at f f' x) : has_strict_fderiv_at (λ (x : E), g (f x)) (g'.comp f') x
theorem complex.norm_eventually_eq_of_is_local_max {E : Type u} [normed_group E] [normed_space ℂ E] {F : Type v} [normed_group F] [normed_space ℂ F] {f : E → F} {c : E} (hd : ∀ᶠ (z : E) in nhds c, differentiable_at ℂ f z) (hc : is_local_max (has_norm.norm ∘ f) c) : ∀ᶠ (y : E) in nhds c, ∥f y∥ = ∥f c∥
theorem formal_multilinear_series.le_radius_of_is_O {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) {r : nnreal} (h : (λ (n : ℕ), ∥p n∥ * ↑r ^ n) =O[filter.at_top] λ (n : ℕ), 1) : ↑r ≤ p.radius
theorem subring.closure_induction₂ {R : Type u} [ring R] {s : set R} {p : R → R → Prop} {a b : R} (ha : a ∈ subring.closure s) (hb : b ∈ subring.closure s) (Hs : ∀ (x : R), x ∈ s → ∀ (y : R), y ∈ s → p x y) (H0_left : ∀ (x : R), p 0 x) (H0_right : ∀ (x : R), p x 0) (H1_left : ∀ (x : R), p 1 x) (H1_right : ∀ (x : R), p x 1) (Hneg_left : ∀ (x y : R), p x y → p (-x) y) (Hneg_right : ∀ (x y : R), p x y → p x (-y)) (Hadd_left : ∀ (x₁ x₂ y : R), p x₁ y → p x₂ y → p (x₁ + x₂) y) (Hadd_right : ∀ (x y₁ y₂ : R), p x y₁ → p x y₂ → p x (y₁ + y₂)) (Hmul_left : ∀ (x₁ x₂ y : R), p x₁ y → p x₂ y → p (x₁ * x₂) y) (Hmul_right : ∀ (x y₁ y₂ : R), p x y₁ → p x y₂ → p x (y₁ * y₂)) : p a b
theorem has_deriv_within_at.Iic_of_Iio {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {F : Type v} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜} [partial_order 𝕜] : has_deriv_within_at f f' (set.Iio x) x → has_deriv_within_at f f' (set.Iic x) x
theorem asymptotics.is_O_with.norm_right {α : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {c : ℝ} {f : α → E} {g' : α → F'} {l : filter α} : asymptotics.is_O_with c l f g' → asymptotics.is_O_with c l f (λ (x : α), ∥g' x∥)
theorem infinite_basis_le_maximal_linear_independent' {R : Type u} [ring R] {M : Type v} [add_comm_group M] [module R M] [nontrivial R] {ι : Type w} (b : basis ι R M) [infinite ι] {κ : Type w'} (v : κ → M) (i : linear_independent R v) (m : i.maximal) : (cardinal.mk ι).lift ≤ (cardinal.mk κ).lift
theorem exists_idempotent_in_compact_add_subsemigroup {M : Type u_1} [add_semigroup M] [topological_space M] [t2_space M] (continuous_mul_left : ∀ (r : M), continuous (λ (_x : M), _x + r)) (s : set M) (snemp : s.nonempty) (s_compact : is_compact s) (s_add : ∀ (x : M), x ∈ s → ∀ (y : M), y ∈ s → x + y ∈ s) : ∃ (m : M) (H : m ∈ s), m + m = m
theorem fractional_ideal.coe_one_eq_coe_submodule_top {R : Type u_1} [comm_ring R] {S : submonoid R} {P : Type u_2} [comm_ring P] [algebra R P] : ↑1 = is_localization.coe_submodule P ⊤
theorem is_preconnected.eq_univ_of_unbounded {α : Type v} [linear_order α] [topological_space α] [order_closed_topology α] {s : set α} (hs : is_preconnected s) (hb : ¬bdd_below s) (ha : ¬bdd_above s) : s = set.univ
theorem metric.lipschitz_inf_dist_pt {α : Type u} [pseudo_metric_space α] (s : set α) : lipschitz_with 1 (λ (x : α), metric.inf_dist x s)
theorem is_torsion_of_fintype {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G
theorem exists_maximal_orthonormal {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {s : set E} (hs : orthonormal 𝕜 coe) : ∃ (w : set E) (H : w ⊇ s), orthonormal 𝕜 coe ∧ ∀ (u : set E), u ⊇ w → orthonormal 𝕜 coe → u = w
theorem has_ftaylor_series_up_to_on.has_fderiv_within_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {x : E} {n : with_top ℕ} {p : E → formal_multilinear_series 𝕜 E F} (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 ≤ n) (hx : x ∈ s) : has_fderiv_within_at f (⇑(continuous_multilinear_curry_fin1 𝕜 E F) (p x 1)) s x
theorem set.mem_finset_sum {α : Type u_2} {ι : Type u_5} [add_comm_monoid α] (t : finset ι) (f : ι → set α) (a : α) : a ∈ t.sum (λ (i : ι), f i) ↔ ∃ (g : ι → α) (hg : ∀ {i : ι}, i ∈ t → g i ∈ f i), t.sum (λ (i : ι), g i) = a
theorem infinite.nonempty_field {α : Type u} [infinite α] : nonempty (field α)
theorem antivary_on.sum_mul_le_sum_mul_comp_perm {ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {s : finset ι} {σ : equiv.perm ι} {f g : ι → α} (hfg : antivary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i * g i) ≤ s.sum (λ (i : ι), f i * g (⇑σ i))
theorem cont_mdiff_on_iff_target {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M → M'} {s : set M} {n : with_top ℕ} : cont_mdiff_on I I' n f s ↔ continuous_on f s ∧ ∀ (y : M'), cont_mdiff_on I (model_with_corners_self 𝕜 E') n (⇑(ext_chart_at I' y) ∘ f) (s ∩ f ⁻¹' (ext_chart_at I' y).source)
theorem module.End.generalized_eigenspace_eq_generalized_eigenspace_finrank_of_le {K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (f : module.End K V) (μ : K) {k : ℕ} (hk : finite_dimensional.finrank K V ≤ k) : ⇑(f.generalized_eigenspace μ) k = ⇑(f.generalized_eigenspace μ) (finite_dimensional.finrank K V)
theorem nat.image_Ico_mod (n a : ℕ) : finset.image (λ (_x : ℕ), _x % a) (finset.Ico n (n + a)) = finset.range a
theorem covby.coe_fin {n : ℕ} {a b : fin n} : a ⋖ b → ↑a ⋖ ↑b
theorem eckmann_hilton.mul {X : Type u} {m₁ m₂ : X → X → X} {e₁ e₂ : X} (h₁ : eckmann_hilton.is_unital m₁ e₁) (h₂ : eckmann_hilton.is_unital m₂ e₂) (distrib : ∀ (a b c d : X), m₁ (m₂ a b) (m₂ c d) = m₂ (m₁ a c) (m₁ b d)) : m₁ = m₂
theorem nilpotent_iff_lower_central_series {G : Type u_1} [group G] : group.is_nilpotent G ↔ ∃ (n : ℕ), lower_central_series G n = ⊥
theorem inv_lt_one_iff_one_lt {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a
theorem opens.pretopology_of_grothendieck (T : Type u) [topological_space T] : category_theory.pretopology.of_grothendieck (topological_space.opens T) (opens.grothendieck_topology T) = opens.pretopology T
theorem trans_gen_of_succ_of_reflexive {α : Type u_1} [linear_order α] [succ_order α] [is_succ_archimedean α] (r : α → α → Prop) {n m : α} (hr : reflexive r) (h1 : ∀ (i : α), i ∈ set.Ico n m → r i (order.succ i)) (h2 : ∀ (i : α), i ∈ set.Ico m n → r (order.succ i) i) : relation.trans_gen r n m
theorem matrix.mul_vec_cramer {n : Type u} [decidable_eq n] [fintype n] {α : Type v} [comm_ring α] (A : matrix n n α) (b : n → α) : A.mul_vec (⇑(A.cramer) b) = A.det • b
theorem seminorm.balanced_ball_zero {𝕜 : Type u_3} {E : Type u_4} [semi_normed_ring 𝕜] [add_comm_group E] [module 𝕜 E] (p : seminorm 𝕜 E) (r : ℝ) : balanced 𝕜 (p.ball 0 r)
theorem metric.Hausdorff_dist_closure {α : Type u} [pseudo_metric_space α] {s t : set α} : metric.Hausdorff_dist (closure s) (closure t) = metric.Hausdorff_dist s t
theorem asymptotics.is_O_with.of_neg_left {α : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {c : ℝ} {g : α → F} {f' : α → E'} {l : filter α} : asymptotics.is_O_with c l (λ (x : α), -f' x) g → asymptotics.is_O_with c l f' g
theorem antivary_on.sum_smul_lt_sum_comp_perm_smul_iff {ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {s : finset ι} {σ : equiv.perm ι} {f : ι → α} {g : ι → β} (hfg : antivary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i • g i) < s.sum (λ (i : ι), f (⇑σ i) • g i) ↔ ¬antivary_on (f ∘ ⇑σ) g ↑s
theorem monotone_on.dual_left {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s : set α} : monotone_on f s → antitone_on (f ∘ ⇑order_dual.of_dual) s
theorem right.add_pos_of_pos_of_nonneg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 ≤ b) : 0 < a + b
theorem pi.has_faithful_smul_at {I : Type u} {f : I → Type v} {α : Type u_1} [Π (i : I), has_scalar α (f i)] [∀ (i : I), nonempty (f i)] (i : I) [has_faithful_smul α (f i)] : has_faithful_smul α (Π (i : I), f i)
theorem cont_diff_groupoid_zero_eq {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) : cont_diff_groupoid 0 I = continuous_groupoid H
theorem complex.im_eq_sub_conj (z : ℂ) : ↑(z.im) = (z - ⇑(star_ring_end ℂ) z) / (2 * complex.I)
theorem real.geom_mean_le_arith_mean_weighted {ι : Type u} (s : finset ι) (w z : ι → ℝ) (hw : ∀ (i : ι), i ∈ s → 0 ≤ w i) (hw' : s.sum (λ (i : ι), w i) = 1) (hz : ∀ (i : ι), i ∈ s → 0 ≤ z i) : s.prod (λ (i : ι), z i ^ w i) ≤ s.sum (λ (i : ι), w i * z i)
theorem antivary.sum_mul_eq_sum_comp_perm_mul_iff {ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {σ : equiv.perm ι} {f g : ι → α} [fintype ι] (hfg : antivary f g) : finset.univ.sum (λ (i : ι), f (⇑σ i) * g i) = finset.univ.sum (λ (i : ι), f i * g i) ↔ antivary (f ∘ ⇑σ) g
theorem finset.induction_on' {α : Type u_1} {p : finset α → Prop} [decidable_eq α] (S : finset α) (h₁ : p ∅) (h₂ : ∀ {a : α} {s : finset α}, a ∈ S → s ⊆ S → a ∉ s → p s → p (has_insert.insert a s)) : p S
theorem has_lt.lt.trans_eq' {α : Type u} [preorder α] {a b c : α} : b < c → a = b → a < c
theorem formal_multilinear_series.radius_right_inv_pos_of_radius_pos_aux1 (n : ℕ) (p : ℕ → ℝ) (hp : ∀ (k : ℕ), 0 ≤ p k) {r a : ℝ} (hr : 0 ≤ r) (ha : 0 ≤ a) : (finset.Ico 2 (n + 1)).sum (λ (k : ℕ), a ^ k * {c : composition k | 1 < c.length}.to_finset.sum (λ (c : composition k), r ^ c.length * finset.univ.prod (λ (j : fin c.length), p (c.blocks_fun j)))) ≤ (finset.Ico 2 (n + 1)).sum (λ (j : ℕ), r ^ j * (finset.Ico 1 n).sum (λ (k : ℕ), a ^ k * p k) ^ j)
theorem denumerable.raise'_sorted (l : list ℕ) (n : ℕ) : list.sorted has_lt.lt (denumerable.raise' l n)
theorem category_theory.limits.has_limit_of_equivalence_comp {J : Type u₁} [category_theory.category J] {K : Type u₂} [category_theory.category K] {C : Type u} [category_theory.category C] {F : J ⥤ C} (e : K ≌ J) [category_theory.limits.has_limit (e.functor ⋙ F)] : category_theory.limits.has_limit F
theorem fintype.all_card_le_filter_rel_iff_exists_injective {α : Type u} {β : Type v} [fintype β] (r : α → β → Prop) [Π (a : α), decidable_pred (r a)] : (∀ (A : finset α), A.card ≤ (finset.filter (λ (b : β), ∃ (a : α) (H : a ∈ A), r a b) finset.univ).card) ↔ ∃ (f : α → β), function.injective f ∧ ∀ (x : α), r x (f x)
theorem function.is_fixed_pt.eq {α : Type u} {f : α → α} {x : α} (hf : function.is_fixed_pt f x) : f x = x
theorem category_theory.abelian.pseudoelement.pseudo_pullback {C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.limits.has_pullbacks C] {P Q R : C} {f : P ⟶ R} {g : Q ⟶ R} {p : ↥P} {q : ↥Q} : ⇑f p = ⇑g q → (∃ (s : ↥(category_theory.limits.pullback f g)), ⇑category_theory.limits.pullback.fst s = p ∧ ⇑category_theory.limits.pullback.snd s = q)
theorem matrix.general_linear_group.ext {n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] ⦃A B : GL n R⦄ (h : ∀ (i j : n), ↑A i j = ↑B i j) : A = B
theorem list.nodup.of_sublists {α : Type u} {l : list α} : l.sublists.nodup → l.nodup
theorem same_ray_nonneg_smul_left {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (v : M) {r : R} (h : 0 ≤ r) : same_ray R (r • v) v
theorem finprod_eq_of_bijective {α : Type u_1} {β : Type u_2} {M : Type u_5} [comm_monoid M] {f : α → M} {g : β → M} (e : α → β) (he₀ : function.bijective e) (he₁ : ∀ (x : α), f x = g (e x)) : finprod (λ (i : α), f i) = finprod (λ (j : β), g j)
theorem nonempty_linear_equiv_of_dim_eq {K : Type u} {V V₁ : Type v} [division_ring K] [add_comm_group V] [module K V] [add_comm_group V₁] [module K V₁] (cond : module.rank K V = module.rank K V₁) : nonempty (V ≃ₗ[K] V₁)
theorem normed_ring.inverse_add {R : Type u_1} [normed_ring R] [complete_space R] (x : Rˣ) : ∀ᶠ (t : R) in nhds 0, ring.inverse (↑x + t) = ring.inverse (1 + ↑x⁻¹ * t) * ↑x⁻¹
theorem convex_on_univ_norm {E : Type u_2} [semi_normed_group E] [normed_space ℝ E] : convex_on ℝ set.univ has_norm.norm
theorem inv_gold  : golden_ratio⁻¹ = -golden_conj
theorem filter.tendsto_at_top_finset_of_monotone {α : Type u_3} {β : Type u_4} [preorder β] {f : β → finset α} (h : monotone f) (h' : ∀ (x : α), ∃ (n : β), x ∈ f n) : filter.tendsto f filter.at_top filter.at_top
theorem complex.integral_boundary_rect_eq_zero_of_continuous_on_of_differentiable_on {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] (f : ℂ → E) (z w : ℂ) (Hc : continuous_on f (set.interval z.re w.re ×ℂ set.interval z.im w.im)) (Hd : differentiable_on ℂ f (set.Ioo (linear_order.min z.re w.re) (linear_order.max z.re w.re) ×ℂ set.Ioo (linear_order.min z.im w.im) (linear_order.max z.im w.im))) : (((∫ (x : ℝ) in z.re..w.re, f (↑x + ↑(z.im) * complex.I)) - ∫ (x : ℝ) in z.re..w.re, f (↑x + ↑(w.im) * complex.I)) + complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑(w.re) + ↑y * complex.I)) - complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑(z.re) + ↑y * complex.I) = 0
theorem measure_theory.strongly_measurable.integral_prod_right {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {ν : measure_theory.measure β} [normed_group E] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite ν] ⦃f : α → β → E⦄ (hf : measure_theory.strongly_measurable (function.uncurry f)) : measure_theory.strongly_measurable (λ (x : α), ∫ (y : β), f x y ∂ν)
theorem continuous.Icc_extend' {α : Type u_1} {β : Type u_2} [linear_order α] {a b : α} {h : a ≤ b} [topological_space α] [order_topology α] [topological_space β] {f : ↥(set.Icc a b) → β} (hf : continuous f) : continuous (set.Icc_extend h f)
theorem projective_spectrum.gc_ideal {R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_ring A] [algebra R A] (𝒜 : ℕ → submodule R A) [graded_algebra 𝒜] : galois_connection (λ (I : ideal A), projective_spectrum.zero_locus 𝒜 ↑I) (λ (t : (set (projective_spectrum 𝒜))ᵒᵈ), (projective_spectrum.vanishing_ideal t).to_ideal)
theorem is_least.cInf_eq {α : Type u_1} [conditionally_complete_lattice α] {s : set α} {a : α} (H : is_least s a) : has_Inf.Inf s = a
theorem is_noetherian.injective_of_surjective_endomorphism {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [is_noetherian R M] (f : M →ₗ[R] M) (s : function.surjective ⇑f) : function.injective ⇑f
theorem linear_map.charpoly_to_matrix {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M →ₗ[R] M) {ι : Type w} [fintype ι] (b : basis ι R M) : (⇑(linear_map.to_matrix b b) f).charpoly = f.charpoly
theorem polynomial.monomial_mem_lifts {R : Type u} [semiring R] {S : Type v} [semiring S] {f : R →+* S} {s : S} (n : ℕ) (h : s ∈ set.range ⇑f) : ⇑(polynomial.monomial n) s ∈ polynomial.lifts f
theorem mul_self_div_self {G₀ : Type u_2} [group_with_zero G₀] (a : G₀) : a * a / a = a
theorem balanced.interior {𝕜 : Type u_1} {E : Type u_3} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] {A : set E} [topological_space E] [has_continuous_smul 𝕜 E] (hA : balanced 𝕜 A) (h : 0 ∈ interior A) : balanced 𝕜 (interior A)
theorem norm_sub_mul_self_real {F : Type u_3} [inner_product_space ℝ F] {x y : F} : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ - 2 * has_inner.inner x y + ∥y∥ * ∥y∥
theorem list.head_add_tail_sum_of_ne_nil {M : Type u_3} [add_monoid M] [inhabited M] (l : list M) (h : l ≠ list.nil) : l.head + l.tail.sum = l.sum
theorem nat.prime.factorization_pow {p k : ℕ} (hp : nat.prime p) : (p ^ k).factorization = finsupp.single p k
theorem affine.triangle.orthocenter_replace_orthocenter_eq_point {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {t₁ t₂ : affine.triangle ℝ P} {i₁ i₂ i₃ j₁ j₂ j₃ : fin 3} (hi₁₂ : i₁ ≠ i₂) (hi₁₃ : i₁ ≠ i₃) (hi₂₃ : i₂ ≠ i₃) (hj₁₂ : j₁ ≠ j₂) (hj₁₃ : j₁ ≠ j₃) (hj₂₃ : j₂ ≠ j₃) (h₁ : t₂.points j₁ = t₁.orthocenter) (h₂ : t₂.points j₂ = t₁.points i₂) (h₃ : t₂.points j₃ = t₁.points i₃) : t₂.orthocenter = t₁.points i₁
theorem nnreal.Lp_add_le_tsum {ι : Type u} {f g : ι → nnreal} {p : ℝ} (hp : 1 ≤ p) (hf : summable (λ (i : ι), f i ^ p)) (hg : summable (λ (i : ι), g i ^ p)) : summable (λ (i : ι), (f i + g i) ^ p) ∧ (∑' (i : ι), (f i + g i) ^ p) ^ (1 / p) ≤ (∑' (i : ι), f i ^ p) ^ (1 / p) + (∑' (i : ι), g i ^ p) ^ (1 / p)
theorem tendsto_comp_of_locally_uniform_limit {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {x : α} {p : filter ι} {g : ι → α} [topological_space α] (h : continuous_at f x) (hg : filter.tendsto g p (nhds x)) (hunif : ∀ (u : set (β × β)), u ∈ uniformity β → (∃ (t : set α) (H : t ∈ nhds x), ∀ᶠ (n : ι) in p, ∀ (y : α), y ∈ t → (f y, F n y) ∈ u)) : filter.tendsto (λ (n : ι), F n (g n)) p (nhds (f x))
theorem is_smul_regular.mul_iff {R : Type u_1} {M : Type u_3} {a b : R} [comm_semigroup R] [has_scalar R M] [is_scalar_tower R R M] : is_smul_regular M (a * b) ↔ is_smul_regular M a ∧ is_smul_regular M b
theorem measure_theory.has_finite_integral.tendsto_set_integral_nhds_zero {α : Type u_1} {E : Type u_2} [normed_group E] [normed_space ℝ E] [complete_space E] {m : measurable_space α} {μ : measure_theory.measure α} {ι : Type u_3} {f : α → E} (hf : measure_theory.has_finite_integral f μ) {l : filter ι} {s : ι → set α} (hs : filter.tendsto (⇑μ ∘ s) l (nhds 0)) : filter.tendsto (λ (i : ι), ∫ (x : α) in s i, f x ∂μ) l (nhds 0)
theorem irreducible.dvd_symm {α : Type u_1} [monoid α] {p q : α} (hp : irreducible p) (hq : irreducible q) : p ∣ q → q ∣ p
theorem is_field_of_is_integral_of_is_field {R : Type u_1} {S : Type u_2} [comm_ring R] [nontrivial R] [comm_ring S] [is_domain S] [algebra R S] (H : algebra.is_integral R S) (hRS : function.injective ⇑(algebra_map R S)) (hS : is_field S) : is_field R
theorem infi_eq_infi_finset {α : Type u_1} {ι : Type u_4} [complete_lattice α] (s : ι → α) : (⨅ (i : ι), s i) = ⨅ (t : finset ι) (i : ι) (H : i ∈ t), s i
theorem subring.sub_mem {R : Type u} [ring R] (s : subring R) {x y : R} (hx : x ∈ s) (hy : y ∈ s) : x - y ∈ s
theorem convex_cone.ext {𝕜 : Type u_1} {E : Type u_2} [ordered_semiring 𝕜] [add_comm_monoid E] [has_scalar 𝕜 E] {S T : convex_cone 𝕜 E} (h : ∀ (x : E), x ∈ S ↔ x ∈ T) : S = T
theorem nat.factorization_choose_le_one {p n k : ℕ} (p_large : n < p ^ 2) : ⇑((n.choose k).factorization) p ≤ 1
theorem Module.cokernel_π_image_subobject_ext {R : Type u} [ring R] {L M N : Module R} (f : L ⟶ M) [category_theory.limits.has_image f] (g : ↑(category_theory.limits.image_subobject f) ⟶ N) [category_theory.limits.has_cokernel g] {x y : ↥N} (l : ↥L) (w : x = y + ⇑g (⇑(category_theory.limits.factor_thru_image_subobject f) l)) : ⇑(category_theory.limits.cokernel.π g) x = ⇑(category_theory.limits.cokernel.π g) y
theorem edist_le_range_sum_edist {α : Type u} [pseudo_emetric_space α] (f : ℕ → α) (n : ℕ) : has_edist.edist (f 0) (f n) ≤ (finset.range n).sum (λ (i : ℕ), has_edist.edist (f i) (f (i + 1)))
theorem cont_diff_within_at.sub {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {x : E} {n : with_top ℕ} {s : set E} {f g : E → F} (hf : cont_diff_within_at 𝕜 n f s x) (hg : cont_diff_within_at 𝕜 n g s x) : cont_diff_within_at 𝕜 n (λ (x : E), f x - g x) s x
theorem krull_topology_t2 {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (h_int : algebra.is_integral K L) : t2_space (L ≃ₐ[K] L)
theorem linear_map.bound_of_continuous {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [ring_hom_isometric σ₁₂] (f : E →ₛₗ[σ₁₂] F) (hf : continuous ⇑f) : ∃ (C : ℝ), 0 < C ∧ ∀ (x : E), ∥⇑f x∥ ≤ C * ∥x∥
theorem local_homeomorph.to_open_embedding {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) (h : e.to_local_equiv.source = set.univ) : open_embedding ⇑e
theorem continuous.homeo_of_equiv_compact_to_t2.t1_counterexample  : ∃ (α β : Type) (Iα : topological_space α) (Iβ : topological_space β), compact_space α ∧ t1_space β ∧ ∃ (f : α ≃ β), continuous ⇑f ∧ ¬continuous ⇑(f.symm)
theorem is_torsion.of_surjective {G : Type u_1} {H : Type u_2} [group G] [group H] {f : G →* H} (hf : function.surjective ⇑f) (tG : monoid.is_torsion G) : monoid.is_torsion H
theorem add_is_torsion.of_surjective {G : Type u_1} {H : Type u_2} [add_group G] [add_group H] {f : G →+ H} (hf : function.surjective ⇑f) (tG : add_monoid.is_torsion G) : add_monoid.is_torsion H
theorem is_cyclic_of_prime_card {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_cyclic α
theorem add_submonoid.ext {M : Type u_1} [add_zero_class M] {S T : add_submonoid M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T) : S = T
theorem subset_closure_inter_of_is_preirreducible_of_is_open {α : Type u} [topological_space α] {S U : set α} (hS : is_preirreducible S) (hU : is_open U) (h : (S ∩ U).nonempty) : S ⊆ closure (S ∩ U)
theorem matrix.minor_diagonal {l : Type u_1} {m : Type u_2} {α : Type v} [has_zero α] [decidable_eq m] [decidable_eq l] (d : m → α) (e : l → m) (he : function.injective e) : (matrix.diagonal d).minor e e = matrix.diagonal (d ∘ e)
theorem eq_zero_of_mul_eq_self_right {M₀ : Type u_1} [cancel_monoid_with_zero M₀] {a b : M₀} (h₁ : b ≠ 1) (h₂ : a * b = a) : a = 0
theorem cardinal.mul_eq_max {a b : cardinal} (ha : cardinal.aleph_0 ≤ a) (hb : cardinal.aleph_0 ≤ b) : a * b = linear_order.max a b
theorem is_max_on.of_is_local_max_of_convex_univ {E : Type u_1} {β : Type u_2} [add_comm_group E] [topological_space E] [module ℝ E] [topological_add_group E] [has_continuous_smul ℝ E] [ordered_add_comm_group β] [module ℝ β] [ordered_smul ℝ β] {f : E → β} {a : E} (h_local_max : is_local_max f a) (h_conc : concave_on ℝ set.univ f) (x : E) : f x ≤ f a
theorem is_o_rpow_exp_pos_mul_at_top (s : ℝ) {b : ℝ} (hb : 0 < b) : (λ (x : ℝ), x ^ s) =o[filter.at_top] λ (x : ℝ), real.exp (b * x)
theorem category_theory.limits.as_factor_thru_image {C : Type u} [category_theory.category C] {X Y : C} (f : X ⟶ Y) [category_theory.limits.has_image f] : (category_theory.limits.image.mono_factorisation f).e = category_theory.limits.factor_thru_image f
theorem intermediate_field.fixing_subgroup.bot {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] : ⊥.fixing_subgroup = ⊤
theorem category_theory.functor.hext {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {F G : C ⥤ D} (h_obj : ∀ (X : C), F.obj X = G.obj X) (h_map : ∀ (X Y : C) (f : X ⟶ Y), F.map f == G.map f) : F = G
theorem bounded_continuous_function.exists_extension_forall_mem_of_closed_embedding {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] (f : bounded_continuous_function X ℝ) {t : set ℝ} {e : X → Y} [hs : t.ord_connected] (hf : ∀ (x : X), ⇑f x ∈ t) (hne : t.nonempty) (he : closed_embedding e) : ∃ (g : bounded_continuous_function Y ℝ), (∀ (y : Y), ⇑g y ∈ t) ∧ ⇑g ∘ e = ⇑f
theorem category_theory.abelian.pseudoelement.comp_comp {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q R : C} (f : P ⟶ Q) (g : Q ⟶ R) : ⇑g ∘ ⇑f = ⇑(f ≫ g)
theorem sub_pow_two {R : Type u₁} [comm_ring R] (a b : R) : (a - b) ^ 2 = a ^ 2 - 2 * a * b + b ^ 2
theorem path.homotopic.comp_pi_eq_pi_comp {ι : Type u_1} {X : ι → Type u_2} [Π (i : ι), topological_space (X i)] {as bs cs : Π (i : ι), X i} (γ₀ : Π (i : ι), path.homotopic.quotient (as i) (bs i)) (γ₁ : Π (i : ι), path.homotopic.quotient (bs i) (cs i)) : (path.homotopic.pi γ₀).comp (path.homotopic.pi γ₁) = path.homotopic.pi (λ (i : ι), (γ₀ i).comp (γ₁ i))
theorem is_p_group.nonempty_fixed_point_of_prime_not_dvd_card {p : ℕ} {G : Type u_1} [group G] (hG : is_p_group p G) [hp : fact (nat.prime p)] (α : Type u_2) [mul_action G α] [fintype α] [fintype ↥(mul_action.fixed_points G α)] (hpα : ¬p ∣ fintype.card α) : (mul_action.fixed_points G α).nonempty
theorem affine_subspace.convex {𝕜 : Type u_1} {E : Type u_2} [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] (Q : affine_subspace 𝕜 E) : convex 𝕜 ↑Q
theorem measure_theory.Lp.simple_func.mem_ℒp {α : Type u_1} {E : Type u_4} [measurable_space α] [normed_group E] {p : ennreal} {μ : measure_theory.measure α} (f : ↥(measure_theory.Lp.simple_func E p μ)) : measure_theory.mem_ℒp ⇑(measure_theory.Lp.simple_func.to_simple_func f) p μ
theorem is_localization.exists_integer_multiple {R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] (a : S) : ∃ (b : ↥M), is_localization.is_integer R (↑b • a)
theorem nat.sub_mod_eq_zero_of_mod_eq {a b c : ℕ} (h : a % c = b % c) : (a - b) % c = 0
theorem measure_theory.Lp_to_Lp_restrict_smul {α : Type u_1} {F : Type u_4} [measurable_space α] {𝕜 : Type u_5} [normed_field 𝕜] [normed_group F] [normed_space 𝕜 F] {p : ennreal} {μ : measure_theory.measure α} (c : 𝕜) (f : ↥(measure_theory.Lp F p μ)) (s : set α) : measure_theory.mem_ℒp.to_Lp ⇑(c • f) _ = c • measure_theory.mem_ℒp.to_Lp ⇑f _
theorem complex.finrank_real_complex_fact  : fact (finite_dimensional.finrank ℝ ℂ = 2)
theorem intermediate_field.fixing_subgroup_is_open {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E : intermediate_field K L) [finite_dimensional K ↥E] : is_open ↑(E.fixing_subgroup)
theorem finset.nat.sum_antidiagonal_eq_sum_range_succ {M : Type u_1} [add_comm_monoid M] (f : ℕ → ℕ → M) (n : ℕ) : (finset.nat.antidiagonal n).sum (λ (ij : ℕ × ℕ), f ij.fst ij.snd) = (finset.range n.succ).sum (λ (k : ℕ), f k (n - k))
theorem measure_theory.lintegral_infi {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : ℕ → α → ennreal} (h_meas : ∀ (n : ℕ), measurable (f n)) (h_anti : antitone f) (h_fin : ∫⁻ (a : α), f 0 a ∂μ ≠ ⊤) : ∫⁻ (a : α), (⨅ (n : ℕ), f n a) ∂μ = ⨅ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
theorem simple_graph.le_min_degree_of_forall_le_degree {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [nonempty V] (k : ℕ) (h : ∀ (v : V), k ≤ G.degree v) : k ≤ G.min_degree
theorem measure_theory.tendsto_lintegral_thickened_indicator_of_is_closed {α : Type u_1} [measurable_space α] [pseudo_emetric_space α] [opens_measurable_space α] (μ : measure_theory.finite_measure α) {F : set α} (F_closed : is_closed F) {δs : ℕ → ℝ} (δs_pos : ∀ (n : ℕ), 0 < δs n) (δs_lim : filter.tendsto δs filter.at_top (nhds 0)) : filter.tendsto (λ (n : ℕ), ∫⁻ (a : α), ↑(⇑(thickened_indicator _ F) a) ∂↑μ) filter.at_top (nhds (⇑↑μ F))
theorem AddMon.filtered_colimits.colimit_add_aux_eq_of_rel_right {J : Type v} [category_theory.small_category J] (F : J ⥤ AddMon) [category_theory.is_filtered J] {x y y' : Σ (j : J), ↥(F.obj j)} (hyy' : category_theory.limits.types.filtered_colimit.rel (F ⋙ category_theory.forget AddMon) y y') : AddMon.filtered_colimits.colimit_add_aux F x y = AddMon.filtered_colimits.colimit_add_aux F x y'
theorem encodable.axiom_of_choice {α : Type u_1} {β : α → Type u_2} {R : Π (x : α), β x → Prop} [Π (a : α), encodable (β a)] [Π (x : α) (y : β x), decidable (R x y)] (H : ∀ (x : α), ∃ (y : β x), R x y) : ∃ (f : Π (a : α), β a), ∀ (x : α), R x (f x)
theorem complex.integral_boundary_rect_eq_zero_of_differentiable_on {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] (f : ℂ → E) (z w : ℂ) (H : differentiable_on ℂ f (set.interval z.re w.re ×ℂ set.interval z.im w.im)) : (((∫ (x : ℝ) in z.re..w.re, f (↑x + ↑(z.im) * complex.I)) - ∫ (x : ℝ) in z.re..w.re, f (↑x + ↑(w.im) * complex.I)) + complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑(w.re) + ↑y * complex.I)) - complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑(z.re) + ↑y * complex.I) = 0
theorem category_theory.abelian.pseudoelement.comp_apply {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q R : C} (f : P ⟶ Q) (g : Q ⟶ R) (a : ↥P) : ⇑(f ≫ g) a = ⇑g (⇑f a)
theorem vector.ext {n : ℕ} {α : Type u_1} {v w : vector α n} (h : ∀ (m : fin n), v.nth m = w.nth m) : v = w
theorem star_div' {R : Type u} [field R] [star_ring R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y
theorem add_monoid_hom.is_of_fin_order {G : Type u} [add_monoid G] {H : Type v} [add_monoid H] (f : G →+ H) {x : G} (h : is_of_fin_add_order x) : is_of_fin_add_order (⇑f x)
theorem finset.centroid_weights_indicator_def (k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) : finset.centroid_weights_indicator k s = ↑s.indicator (finset.centroid_weights k s)
theorem sup_Inf_le_infi_sup {α : Type u_1} [complete_lattice α] {a : α} {s : set α} : a ⊔ has_Inf.Inf s ≤ ⨅ (b : α) (H : b ∈ s), a ⊔ b
theorem differentiable_on.circle_integral_sub_inv_smul {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] {R : ℝ} {c w : ℂ} {f : ℂ → E} (hd : differentiable_on ℂ f (metric.closed_ball c R)) (hw : w ∈ metric.ball c R) : ∮ (z : ℂ) in C(c, R), (z - w)⁻¹ • f z = (2 * ↑real.pi * complex.I) • f w
theorem Top.sheaf.exists_unique_gluing {C : Type u} [category_theory.category C] [category_theory.concrete_category C] [category_theory.limits.has_limits C] [category_theory.reflects_isomorphisms (category_theory.concrete_category.forget C)] [category_theory.limits.preserves_limits (category_theory.concrete_category.forget C)] {X : Top} (F : Top.sheaf C X) {ι : Type v} (U : ι → topological_space.opens ↥X) (sf : Π (i : ι), ↥(F.val.obj (opposite.op (U i)))) (h : F.val.is_compatible U sf) : ∃! (s : ↥(F.val.obj (opposite.op (supr U)))), F.val.is_gluing U sf s
theorem continuous_at.snd' {α : Type u} {β : Type v} {γ : Type u_1} [topological_space α] [topological_space β] [topological_space γ] {f : β → γ} {x : α} {y : β} (hf : continuous_at f y) : continuous_at (λ (x : α × β), f x.snd) (x, y)
theorem filter.eventually.of_small_sets {α : Type u_1} {l : filter α} {p : α → Prop} : (∀ᶠ (s : set α) in l.small_sets, ∀ (x : α), x ∈ s → p x) → (∀ᶠ (x : α) in l, p x)
theorem affine_independent.vector_span_image_finset_eq_of_le_of_card_eq_finrank_add_one {k : Type u_1} {V : Type u_2} {P : Type u_3} {ι : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {p : ι → P} (hi : affine_independent k p) {s : finset ι} {sm : submodule k V} [finite_dimensional k ↥sm] (hle : vector_span k ↑(finset.image p s) ≤ sm) (hc : s.card = finite_dimensional.finrank k ↥sm + 1) : vector_span k ↑(finset.image p s) = sm
theorem metric.bounded_iff_ediam_ne_top {α : Type u} [pseudo_metric_space α] {s : set α} : metric.bounded s ↔ emetric.diam s ≠ ⊤
theorem mdifferentiable_at_iff_differentiable_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {f : E → E'} {x : E} : mdifferentiable_at (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f x ↔ differentiable_at 𝕜 f x
theorem list.sublist_of_order_embedding_nth_eq {α : Type u_1} {l l' : list α} (f : ℕ ↪o ℕ) (hf : ∀ (ix : ℕ), l.nth ix = l'.nth (⇑f ix)) : l <+ l'
theorem continuous_map.subalgebra_topological_closure_eq_top_of_separates_points {X : Type u_1} [topological_space X] [compact_space X] (A : subalgebra ℝ C(X, ℝ)) (w : A.separates_points) : A.topological_closure = ⊤
theorem abs_real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul {F : Type u_3} [inner_product_space ℝ F] {x : F} {r : ℝ} (hx : x ≠ 0) (hr : r ≠ 0) : |has_inner.inner x (r • x)| / (∥x∥ * ∥r • x∥) = 1
theorem orientation.oangle_sub_left {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle x z - o.oangle x y = o.oangle y z
theorem measure_theory.measure.ext_of_Ioc' {α : Type u_1} [topological_space α] {m : measurable_space α} [topological_space.second_countable_topology α] [linear_order α] [order_topology α] [borel_space α] [no_min_order α] (μ ν : measure_theory.measure α) (hμ : ∀ ⦃a b : α⦄, a < b → ⇑μ (set.Ioc a b) ≠ ⊤) (h : ∀ ⦃a b : α⦄, a < b → ⇑μ (set.Ioc a b) = ⇑ν (set.Ioc a b)) : μ = ν
theorem affine_subspace.span_univ (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : affine_span k set.univ = ⊤
theorem convex_on.slope_mono_adjacent {𝕜 : Type u_1} [linear_ordered_field 𝕜] {s : set 𝕜} {f : 𝕜 → 𝕜} (hf : convex_on 𝕜 s f) {x y z : 𝕜} (hx : x ∈ s) (hz : z ∈ s) (hxy : x < y) (hyz : y < z) : (f y - f x) / (y - x) ≤ (f z - f y) / (z - y)
theorem polynomial_functions_closure_eq_top (a b : ℝ) : (polynomial_functions (set.Icc a b)).topological_closure = ⊤
theorem monotone.map_bdd_above {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} (Hf : monotone f) {s : set α} : bdd_above s → bdd_above (f '' s)
theorem continuous_map_mem_polynomial_functions_closure (a b : ℝ) (f : C(↥(set.Icc a b), ℝ)) : f ∈ (polynomial_functions (set.Icc a b)).topological_closure
theorem convex_hull_affine_basis_eq_nonneg_barycentric {R : Type u_1} {E : Type u_2} [linear_ordered_field R] [add_comm_group E] [module R E] {ι : Type u_3} (b : affine_basis ι R E) : ⇑(convex_hull R) (set.range b.points) = {x : E | ∀ (i : ι), 0 ≤ ⇑(b.coord i) x}
theorem has_mem.mem.out {α : Type u} {p : α → Prop} {a : α} (h : a ∈ {x : α | p x}) : p a
theorem fin.tail_update_zero {n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (z : α 0) : fin.tail (function.update q 0 z) = fin.tail q
theorem finset.shadow_monotone {α : Type u_1} [decidable_eq α] : monotone finset.shadow
theorem pi.const_ring_hom_eq_algebra_map (R : Type u_1) (A : Type u_2) [comm_semiring R] : pi.const_ring_hom A R = algebra_map R (A → R)
theorem category_theory.presieve.is_sheaf_for.is_separated_for {C : Type u₁} [category_theory.category C] {P : Cᵒᵖ ⥤ Type w} {X : C} {R : category_theory.presieve X} : category_theory.presieve.is_sheaf_for P R → category_theory.presieve.is_separated_for P R
theorem succ.rec {α : Type u_1} [preorder α] [succ_order α] [is_succ_archimedean α] {P : α → Prop} {m : α} (h0 : P m) (h1 : ∀ (n : α), m ≤ n → P n → P (order.succ n)) ⦃n : α⦄ (hmn : m ≤ n) : P n
theorem map_zsmul {G : Type u_6} {H : Type u_7} {F : Type u_8} [add_group G] [subtraction_monoid H] [add_monoid_hom_class F G H] (f : F) (n : ℤ) (g : G) : ⇑f (n • g) = n • ⇑f g
theorem nat.totient_eq_mul_prod_factors (n : ℕ) : ↑(n.totient) = ↑n * n.factors.to_finset.prod (λ (p : ℕ), 1 - (↑p)⁻¹)
theorem Hausdorffification.lift_eq {R : Type u_1} [comm_ring R] (I : ideal R) {M : Type u_2} [add_comm_group M] [module R M] {N : Type u_3} [add_comm_group N] [module R N] [h : is_Hausdorff I N] (f : M →ₗ[R] N) (g : Hausdorffification I M →ₗ[R] N) (hg : g.comp (Hausdorffification.of I M) = f) : g = Hausdorffification.lift I f
theorem seminorm.gauge_ball {E : Type u_1} [add_comm_group E] [module ℝ E] (p : seminorm ℝ E) : gauge (p.ball 0 1) = ⇑p
theorem real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul {F : Type u_3} [inner_product_space ℝ F] {x : F} {r : ℝ} (hx : x ≠ 0) (hr : r < 0) : has_inner.inner x (r • x) / (∥x∥ * ∥r • x∥) = -1
theorem simple_graph.inc_matrix_apply' {R : Type u_1} {α : Type u_2} (G : simple_graph α) [has_zero R] [has_one R] [decidable_eq α] [decidable_rel G.adj] {a : α} {e : sym2 α} : simple_graph.inc_matrix R G a e = ite (e ∈ G.incidence_set a) 1 0
theorem cont_mdiff_within_at.comp {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M → M'} {s : set M} {n : with_top ℕ} {E'' : Type u_14} [normed_group E''] [normed_space 𝕜 E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners 𝕜 E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {t : set M'} {g : M' → M''} (x : M) (hg : cont_mdiff_within_at I' I'' n g t (f x)) (hf : cont_mdiff_within_at I I' n f s x) (st : set.maps_to f s t) : cont_mdiff_within_at I I'' n (g ∘ f) s x
theorem matrix.inv_of_mul_self_assoc {m : Type u} {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) (B : matrix n m α) [invertible A] : (⅟ A).mul (A.mul B) = B
theorem metric.tendsto_at_top' {α : Type u} {β : Type v} [pseudo_metric_space α] [nonempty β] [semilattice_sup β] [no_max_order β] {u : β → α} {a : α} : filter.tendsto u filter.at_top (nhds a) ↔ ∀ (ε : ℝ), ε > 0 → (∃ (N : β), ∀ (n : β), n > N → has_dist.dist (u n) a < ε)
theorem padic_norm.zero_of_padic_norm_eq_zero (p : ℕ) [hp : fact (nat.prime p)] {q : ℚ} (h : padic_norm p q = 0) : q = 0
theorem is_cyclotomic_extension.rat.discr_prime_pow_ne_two' {p : ℕ+} {k : ℕ} {K : Type u} [field K] [char_zero K] {ζ : K} [hp : fact (nat.prime ↑p)] [is_cyclotomic_extension {p ^ (k + 1)} ℚ K] (hζ : is_primitive_root ζ ↑(p ^ (k + 1))) (hk : p ^ (k + 1) ≠ 2) : algebra.discr ℚ ⇑((is_primitive_root.sub_one_power_basis ℚ hζ).basis) = (-1) ^ ((↑p ^ (k + 1)).totient / 2) * ↑p ^ (↑p ^ k * ((↑p - 1) * (k + 1) - 1))
theorem orientation.oangle_neg_neg {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x y : V) : o.oangle (-x) (-y) = o.oangle x y
theorem nat.exists_strict_mono' {α : Type u} [preorder α] [no_max_order α] (a : α) : ∃ (f : ℕ → α), strict_mono f ∧ f 0 = a
theorem besicovitch.exist_finset_disjoint_balls_large_measure {α : Type u_1} [metric_space α] [topological_space.second_countable_topology α] [measurable_space α] [opens_measurable_space α] (μ : measure_theory.measure α) [measure_theory.is_finite_measure μ] {N : ℕ} {τ : ℝ} (hτ : 1 < τ) (hN : is_empty (besicovitch.satellite_config α N τ)) (s : set α) (r : α → ℝ) (rpos : ∀ (x : α), x ∈ s → 0 < r x) (rle : ∀ (x : α), x ∈ s → r x ≤ 1) : ∃ (t : finset α), ↑t ⊆ s ∧ ⇑μ (s  ⋃ (x : α) (H : x ∈ t), metric.closed_ball x (r x)) ≤ ↑N / (↑N + 1) * ⇑μ s ∧ ↑t.pairwise_disjoint (λ (x : α), metric.closed_ball x (r x))
theorem cSup_eq_of_forall_le_of_forall_lt_exists_gt {α : Type u_1} [conditionally_complete_lattice α] {s : set α} {b : α} (hs : s.nonempty) (H : ∀ (a : α), a ∈ s → a ≤ b) (H' : ∀ (w : α), w < b → (∃ (a : α) (H : a ∈ s), w < a)) : has_Sup.Sup s = b
theorem polynomial.gal.card_complex_roots_eq_card_real_add_card_not_gal_inv (p : polynomial ℚ) : (p.root_set ℂ).to_finset.card = (p.root_set ℝ).to_finset.card + (⇑(polynomial.gal.gal_action_hom p ℂ) (⇑(polynomial.gal.restrict p ℂ) (alg_equiv.restrict_scalars ℚ complex.conj_ae))).support.card
theorem modular_group.tendsto_norm_sq_coprime_pair (z : upper_half_plane) : filter.tendsto (λ (p : fin 2 → ℤ), ⇑complex.norm_sq (↑(p 0) * ↑z + ↑(p 1))) filter.cofinite filter.at_top
theorem measure_theory.measure_is_open_pos_of_vadd_invariant_of_compact_ne_zero (G : Type u_1) {α : Type u_3} {m : measurable_space α} [add_group G] [add_action G α] [measurable_space G] [has_measurable_vadd G α] {μ : measure_theory.measure α} [measure_theory.vadd_invariant_measure G α μ] [topological_space α] [has_continuous_const_vadd G α] [add_action.is_minimal G α] {K U : set α} (hK : is_compact K) (hμK : ⇑μ K ≠ 0) (hU : is_open U) (hne : U.nonempty) : 0 < ⇑μ U
theorem witt_vector.verschiebung_is_poly {p : ℕ} [hp : fact (nat.prime p)] : witt_vector.is_poly p (λ (R : Type u_1) (_Rcr : comm_ring R), ⇑witt_vector.verschiebung)
theorem bump_covering.exists_is_subordinate {ι : Type u} {X : Type v} [topological_space X] {s : set X} [normal_space X] [paracompact_space X] (hs : is_closed s) (U : ι → set X) (ho : ∀ (i : ι), is_open (U i)) (hU : s ⊆ ⋃ (i : ι), U i) : ∃ (f : bump_covering ι X s), f.is_subordinate U
theorem category_theory.subobject.inf_map {C : Type u₁} [category_theory.category C] [category_theory.limits.has_pullbacks C] {X Y : C} (g : Y ⟶ X) [category_theory.mono g] (f₁ f₂ : category_theory.subobject Y) : (category_theory.subobject.map g).obj (f₁ ⊓ f₂) = (category_theory.subobject.map g).obj f₁ ⊓ (category_theory.subobject.map g).obj f₂
theorem AddMon.filtered_colimits.colimit_zero_eq {J : Type v} [category_theory.small_category J] (F : J ⥤ AddMon) [category_theory.is_filtered J] (j : J) : 0 = AddMon.filtered_colimits.M.mk F ⟨j, 0⟩
theorem is_closed.mem_iff_inf_dist_zero {α : Type u} [pseudo_metric_space α] {s : set α} {x : α} (h : is_closed s) (hs : s.nonempty) : x ∈ s ↔ metric.inf_dist x s = 0
theorem subalgebra.separates_points.is_R_or_C_to_real {𝕜 : Type u_1} {X : Type u_2} [is_R_or_C 𝕜] [topological_space X] {A : subalgebra 𝕜 C(X, 𝕜)} (hA : A.separates_points) (hA' : continuous_map.conj_invariant_subalgebra (subalgebra.restrict_scalars ℝ A)) : ((subalgebra.restrict_scalars ℝ A).comap' (alg_hom.comp_left_continuous ℝ is_R_or_C.of_real_am is_R_or_C.continuous_of_real)).separates_points
theorem metric.isometry_inl {X : Type u} {Y : Type v} [metric_space X] [metric_space Y] : isometry sum.inl
theorem tendsto_rpow_mul_exp_neg_mul_at_top_nhds_0 (s b : ℝ) (hb : 0 < b) : filter.tendsto (λ (x : ℝ), x ^ s * real.exp (-b * x)) filter.at_top (nhds 0)
theorem metric.bounded.is_compact_closure {α : Type u} [pseudo_metric_space α] {s : set α} [proper_space α] (h : metric.bounded s) : is_compact (closure s)
theorem has_sum_coe_mul_geometric_of_norm_lt_1 {𝕜 : Type u_1} [normed_field 𝕜] [complete_space 𝕜] {r : 𝕜} (hr : ∥r∥ < 1) : has_sum (λ (n : ℕ), ↑n * r ^ n) (r / (1 - r) ^ 2)
theorem is_local_extr_on.exists_linear_map_of_has_strict_fderiv_at {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [complete_space E] [normed_group F] [normed_space ℝ F] [complete_space F] {f : E → F} {φ : E → ℝ} {x₀ : E} {f' : E →L[ℝ] F} {φ' : E →L[ℝ] ℝ} (hextr : is_local_extr_on φ {x : E | f x = f x₀} x₀) (hf' : has_strict_fderiv_at f f' x₀) (hφ' : has_strict_fderiv_at φ φ' x₀) : ∃ (Λ : module.dual ℝ F) (Λ₀ : ℝ), (Λ, Λ₀) ≠ 0 ∧ ∀ (x : E), ⇑Λ (⇑f' x) + Λ₀ • ⇑φ' x = 0
theorem re_inner_eq_norm_add_mul_self_sub_norm_sub_mul_self_div_four {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) : ⇑is_R_or_C.re (has_inner.inner x y) = (∥x + y∥ * ∥x + y∥ - ∥x - y∥ * ∥x - y∥) / 4
theorem has_le.le.eq_of_not_lt {α : Type u} [partial_order α] {a b : α} (hab : a ≤ b) (hba : ¬a < b) : a = b
theorem set.inj_on.injective {α : Type u} {β : Type v} {s : set α} {f : α → β} : set.inj_on f s → function.injective (s.restrict f)
theorem monotone.max {α : Type u} {β : Type v} [preorder α] [linear_order β] {f g : α → β} (hf : monotone f) (hg : monotone g) : monotone (λ (x : α), linear_order.max (f x) (g x))
theorem strict_concave_on_univ_of_deriv2_neg {f : ℝ → ℝ} (hf' : differentiable ℝ f) (hf'' : ∀ (x : ℝ), deriv^[2] f x < 0) : strict_concave_on ℝ set.univ f
theorem set_like.ext {A : Type u_1} {B : Type u_2} [i : set_like A B] {p q : A} (h : ∀ (x : B), x ∈ p ↔ x ∈ q) : p = q
theorem orientation.two_zsmul_oangle_neg_self_left {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x : V) : 2 • o.oangle (-x) x = 0
theorem filter.tendsto.eventually_interval_integrable_ae {ι : Type u_1} {E : Type u_3} [normed_group E] {f : ℝ → E} {μ : measure_theory.measure ℝ} {l l' : filter ℝ} (hfm : strongly_measurable_at_filter f l' μ) [filter.tendsto_Ixx_class set.Ioc l l'] [l'.is_measurably_generated] (hμ : μ.finite_at_filter l') {c : E} (hf : filter.tendsto f (l' ⊓ μ.ae) (nhds c)) {u v : ι → ℝ} {lt : filter ι} (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) : ∀ᶠ (t : ι) in lt, interval_integrable f μ (u t) (v t)
theorem has_le.le.absolutely_continuous_of_ae {α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} : μ.ae ≤ ν.ae → μ.absolutely_continuous ν
theorem emetric.tendsto_locally_uniformly_iff {α : Type u} {β : Type v} [pseudo_emetric_space α] {ι : Type u_1} [topological_space β] {F : ι → β → α} {f : β → α} {p : filter ι} : tendsto_locally_uniformly F f p ↔ ∀ (ε : ennreal), ε > 0 → ∀ (x : β), ∃ (t : set β) (H : t ∈ nhds x), ∀ᶠ (n : ι) in p, ∀ (y : β), y ∈ t → has_edist.edist (f y) (F n y) < ε
theorem polynomial.X_mem_lifts {R : Type u} [semiring R] {S : Type v} [semiring S] (f : R →+* S) : polynomial.X ∈ polynomial.lifts f
theorem convex_on.exists_ge_of_mem_convex_hull {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [linear_ordered_field 𝕜] [add_comm_group E] [linear_ordered_add_comm_group β] [module 𝕜 E] [module 𝕜 β] [ordered_smul 𝕜 β] {s : set E} {f : E → β} (hf : convex_on 𝕜 (⇑(convex_hull 𝕜) s) f) {x : E} (hx : x ∈ ⇑(convex_hull 𝕜) s) : ∃ (y : E) (H : y ∈ s), f x ≤ f y
theorem filter.tendsto.limsup_eq {α : Type u} {β : Type v} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {f : filter β} {u : β → α} {a : α} [f.ne_bot] (h : filter.tendsto u f (nhds a)) : f.limsup u = a
theorem laurent_polynomial.induction_on_mul_T {R : Type u_1} [semiring R] {Q : laurent_polynomial R → Prop} (f : laurent_polynomial R) (Qf : ∀ {f : polynomial R} {n : ℕ}, Q (⇑polynomial.to_laurent f * laurent_polynomial.T (-↑n))) : Q f
theorem metric.diam_closed_ball {α : Type u} [pseudo_metric_space α] {x : α} {r : ℝ} (h : 0 ≤ r) : metric.diam (metric.closed_ball x r) ≤ 2 * r
theorem ideal.quotient.quotient_ring_saturate {R : Type u} [comm_ring R] (I : ideal R) (s : set R) : ⇑(ideal.quotient.mk I) ⁻¹' (⇑(ideal.quotient.mk I) '' s) = ⋃ (x : ↥I), (λ (y : R), x.val + y) '' s
theorem order.iso_of_countable_dense (α : Type u_1) (β : Type u_2) [linear_order α] [linear_order β] [encodable α] [densely_ordered α] [no_min_order α] [no_max_order α] [nonempty α] [encodable β] [densely_ordered β] [no_min_order β] [no_max_order β] [nonempty β] : nonempty (α ≃o β)
theorem ring_hom.map_bit1 {α : Type u_2} {β : Type u_3} {rα : non_assoc_semiring α} {rβ : non_assoc_semiring β} (f : α →+* β) (a : α) : ⇑f (bit1 a) = bit1 (⇑f a)
theorem poly.ext {α : Type u_1} {f g : poly α} : (∀ (x : α → ℕ), ⇑f x = ⇑g x) → f = g
theorem ring_hom.map_sub {α : Type u_2} {β : Type u_3} [non_assoc_ring α] [non_assoc_ring β] (f : α →+* β) (x y : α) : ⇑f (x - y) = ⇑f x - ⇑f y
theorem continuous_multilinear_map.map_sum_finset {R : Type u} {ι : Type v} {M₁ : ι → Type w₁} {M₂ : Type w₂} [decidable_eq ι] [semiring R] [Π (i : ι), add_comm_monoid (M₁ i)] [add_comm_monoid M₂] [Π (i : ι), module R (M₁ i)] [module R M₂] [Π (i : ι), topological_space (M₁ i)] [topological_space M₂] (f : continuous_multilinear_map R M₁ M₂) {α : ι → Type u_1} [fintype ι] (g : Π (i : ι), α i → M₁ i) (A : Π (i : ι), finset (α i)) : ⇑f (λ (i : ι), (A i).sum (λ (j : α i), g i j)) = (fintype.pi_finset A).sum (λ (r : Π (a : ι), α a), ⇑f (λ (i : ι), g i (r i)))
theorem comp_assoc_right {α : Type u_1} (f : α → α → α) [is_associative α f] (x y : α) : ((λ (z : α), f z x) ∘ λ (z : α), f z y) = λ (z : α), f z (f y x)
theorem category_theory.preadditive.has_equalizer_of_has_kernel {C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} (f g : X ⟶ Y) [category_theory.limits.has_kernel (f - g)] : category_theory.limits.has_equalizer f g
theorem finsum_mem_image {α : Type u_1} {β : Type u_2} {M : Type u_5} [add_comm_monoid M] {f : α → M} {s : set β} {g : β → α} (hg : set.inj_on g s) : finsum (λ (i : α), finsum (λ (H : i ∈ g '' s), f i)) = finsum (λ (j : β), finsum (λ (H : j ∈ s), f (g j)))
theorem is_seq_closed_of_def {X : Type u_1} [topological_space X] {s : set X} (h : ∀ (x : ℕ → X) (a : X), (∀ (n : ℕ), x n ∈ s) → filter.tendsto x filter.at_top (nhds a) → a ∈ s) : is_seq_closed s
theorem nat.dvd_add_self_left {m n : ℕ} : m ∣ m + n ↔ m ∣ n
theorem convex_on.comp_affine_map {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {β : Type u_4} [linear_ordered_field 𝕜] [add_comm_group E] [add_comm_group F] [ordered_add_comm_monoid β] [module 𝕜 E] [module 𝕜 F] [has_scalar 𝕜 β] {f : F → β} (g : E →ᵃ[𝕜] F) {s : set F} (hf : convex_on 𝕜 s f) : convex_on 𝕜 (⇑g ⁻¹' s) (f ∘ ⇑g)
theorem add_monoid_algebra.map_domain_one {α : Type u_1} {β : Type u_2} {α₂ : Type u_3} [semiring β] [has_zero α] [has_zero α₂] {F : Type u_4} [zero_hom_class F α α₂] (f : F) : finsupp.map_domain ⇑f 1 = 1
theorem category_theory.nat_trans.left_derived_eq {C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] [category_theory.preadditive C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] [category_theory.has_projective_resolutions C] [category_theory.preadditive D] [category_theory.limits.has_zero_object D] [category_theory.limits.has_equalizers D] [category_theory.limits.has_cokernels D] [category_theory.limits.has_images D] [category_theory.limits.has_image_maps D] {F G : C ⥤ D} [F.additive] [G.additive] (α : F ⟶ G) (n : ℕ) {X : C} (P : category_theory.ProjectiveResolution X) : (category_theory.nat_trans.left_derived α n).app X = (F.left_derived_obj_iso n P).hom ≫ (homology_functor D (complex_shape.down ℕ) n).map ((category_theory.nat_trans.map_homological_complex α (complex_shape.down ℕ)).app P.complex) ≫ (G.left_derived_obj_iso n P).inv
theorem inner_product_geometry.angle_le_pi {V : Type u_1} [inner_product_space ℝ V] (x y : V) : inner_product_geometry.angle x y ≤ real.pi
theorem linear_map.nondegenerate_restrict_of_disjoint_orthogonal {R : Type u_1} {M : Type u_5} [comm_ring R] [add_comm_group M] [module R M] {B : M →ₗ[R] M →ₗ[R] R} (hB : B.is_refl) {W : submodule R M} (hW : disjoint W (W.orthogonal_bilin B)) : (B.dom_restrict₁₂ W W).nondegenerate
theorem set.sized.up_shadow {α : Type u_1} [decidable_eq α] [fintype α] {𝒜 : finset (finset α)} {r : ℕ} (h𝒜 : set.sized r ↑𝒜) : set.sized (r + 1) ↑(𝒜.up_shadow)
theorem structure_groupoid.mem_maximal_atlas_of_mem_atlas {H : Type u} {M : Type u_2} [topological_space H] [topological_space M] [charted_space H M] (G : structure_groupoid H) [has_groupoid M G] {e : local_homeomorph M H} (he : e ∈ charted_space.atlas H M) : e ∈ structure_groupoid.maximal_atlas M G
theorem is_left_regular_of_mul_eq_one {R : Type u_1} {a b : R} [monoid R] (h : b * a = 1) : is_left_regular a
theorem polynomial.prod_roots_eq_coeff_zero_of_monic_of_split {K : Type v} [field K] {P : polynomial K} (hmo : P.monic) (hP : polynomial.splits (ring_hom.id K) P) : P.coeff 0 = (-1) ^ P.nat_degree * P.roots.prod
theorem lie_module.weight_vector_multiplication {R : Type u} (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (M₁ : Type w₁) (M₂ : Type w₂) (M₃ : Type w₃) [add_comm_group M₁] [module R M₁] [lie_ring_module L M₁] [lie_module R L M₁] [add_comm_group M₂] [module R M₂] [lie_ring_module L M₂] [lie_module R L M₂] [add_comm_group M₃] [module R M₃] [lie_ring_module L M₃] [lie_module R L M₃] (g : tensor_product R M₁ M₂ →ₗ⁅R,L⁆ M₃) (χ₁ χ₂ : L → R) : (↑g.comp (tensor_product.map_incl (lie_module.pre_weight_space M₁ χ₁) (lie_module.pre_weight_space M₂ χ₂))).range ≤ lie_module.pre_weight_space M₃ (χ₁ + χ₂)
theorem zmod.wilsons_lemma (p : ℕ) [fact (nat.prime p)] : ↑((p - 1).factorial) = -1
theorem is_min_on.undual {α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α} : is_min_on (⇑order_dual.to_dual ∘ f) s a → is_max_on f s a
theorem filter.tendsto_mul_right_cobounded {α : Type u_1} [normed_division_ring α] {a : α} (ha : a ≠ 0) : filter.tendsto (λ (x : α), x * a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)
theorem is_unit.is_regular {R : Type u_1} {a : R} [monoid R] (ua : is_unit a) : is_regular a
theorem deriv.lhopital_zero_nhds' {a : ℝ} {l : filter ℝ} {f g : ℝ → ℝ} (hdf : ∀ᶠ (x : ℝ) in nhds_within a (set.univ  {a}), differentiable_at ℝ f x) (hg' : ∀ᶠ (x : ℝ) in nhds_within a (set.univ  {a}), deriv g x ≠ 0) (hfa : filter.tendsto f (nhds_within a (set.univ  {a})) (nhds 0)) (hga : filter.tendsto g (nhds_within a (set.univ  {a})) (nhds 0)) (hdiv : filter.tendsto (λ (x : ℝ), deriv f x / deriv g x) (nhds_within a (set.univ  {a})) l) : filter.tendsto (λ (x : ℝ), f x / g x) (nhds_within a (set.univ  {a})) l
theorem add_submonoid.localization_map.mk'_sec {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] (f : S.localization_map N) (z : N) : f.mk' (f.sec z).fst (f.sec z).snd = z
theorem antitone.pairwise_disjoint_on_Ioc_pred {α : Type u_1} {β : Type u_2} [linear_order α] [pred_order α] [preorder β] {f : α → β} (hf : antitone f) : pairwise (disjoint on λ (n : α), set.Ioc (f n) (f (order.pred n)))
theorem dfinsupp.single_eq_single_iff {ι : Type u} {β : ι → Type v} [dec : decidable_eq ι] [Π (i : ι), has_zero (β i)] (i j : ι) (xi : β i) (xj : β j) : dfinsupp.single i xi = dfinsupp.single j xj ↔ i = j ∧ xi == xj ∨ xi = 0 ∧ xj = 0
theorem is_mul_hom.mul {α : Type u_1} {β : Type u_2} [semigroup α] [comm_semigroup β] {f g : α → β} (hf : is_mul_hom f) (hg : is_mul_hom g) : is_mul_hom (λ (a : α), f a * g a)
theorem continuous_on_of_uniform_approx_of_continuous_on {α : Type u_1} {β : Type u_2} [uniform_space β] {f : α → β} {s : set α} [topological_space α] (L : ∀ (u : set (β × β)), u ∈ uniformity β → (∃ (F : α → β), continuous_on F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u)) : continuous_on f s
theorem inducing.pseudo_metrizable_space {X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.pseudo_metrizable_space Y] {f : X → Y} (hf : inducing f) : topological_space.pseudo_metrizable_space X
theorem cardinal.to_nat_right_inverse  : function.right_inverse coe ⇑cardinal.to_nat
theorem commute.quaternion_conj {R : Type u_1} [comm_ring R] {a b : quaternion R} (h : commute a b) : commute (⇑quaternion.conj a) (⇑quaternion.conj b)
theorem measure_theory.uniform_integrable_fintype {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [normed_group β] {p : ennreal} {f : ι → α → β} [fintype ι] (hp_one : 1 ≤ p) (hp_top : p ≠ ⊤) (hf : ∀ (i : ι), measure_theory.strongly_measurable (f i)) (hf' : ∀ (i : ι), measure_theory.mem_ℒp (f i) p μ) : measure_theory.uniform_integrable f p μ
theorem category_theory.limits.biprod.cone_point_unique_up_to_iso_hom {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) [category_theory.limits.has_binary_biproduct X Y] {b : category_theory.limits.binary_bicone X Y} (hb : b.is_bilimit) : (hb.is_limit.cone_point_unique_up_to_iso (category_theory.limits.binary_biproduct.is_limit X Y)).hom = category_theory.limits.biprod.lift b.fst b.snd
theorem box_integral.norm_integral_le_of_norm_le {ι : Type u} {E : Type v} [normed_group E] [normed_space ℝ E] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {g : (ι → ℝ) → ℝ} (hle : ∀ (x : ι → ℝ), x ∈ ⇑box_integral.box.Icc I → ∥f x∥ ≤ g x) (μ : measure_theory.measure (ι → ℝ)) [measure_theory.is_locally_finite_measure μ] (hg : box_integral.integrable I l g μ.to_box_additive.to_smul) : ∥box_integral.integral I l f μ.to_box_additive.to_smul∥ ≤ box_integral.integral I l g μ.to_box_additive.to_smul
theorem add_equiv.map_zero {M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (h : M ≃+ N) : ⇑h 0 = 0
theorem pi.mul_single_eq_of_ne' {I : Type u} {f : I → Type v₁} [decidable_eq I] [Π (i : I), has_one (f i)] {i i' : I} (h : i ≠ i') (x : f i) : pi.mul_single i x i' = 1
theorem linear_map.ext_on_range {R : Type u_1} {R₂ : Type u_2} {M : Type u_4} {M₂ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring R₂] [add_comm_monoid M₂] [module R₂ M₂] {σ₁₂ : R →+* R₂} {ι : Type u_3} {v : ι → M} {f g : M →ₛₗ[σ₁₂] M₂} (hv : submodule.span R (set.range v) = ⊤) (h : ∀ (i : ι), ⇑f (v i) = ⇑g (v i)) : f = g
theorem monotone.map_is_greatest {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} (Hf : monotone f) {a : α} {s : set α} (Ha : is_greatest s a) : is_greatest (f '' s) (f a)
theorem is_torsion.not_torsion_free {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G → ¬monoid.is_torsion_free G
theorem ordering.compares.of_swap {α : Type u_1} [has_lt α] {a b : α} {o : ordering} : o.swap.compares a b → o.compares b a
theorem sym2.map_id' {α : Type u_1} : sym2.map (λ (x : α), x) = id
theorem geometric_hahn_banach_point_point {E : Type u_2} [normed_group E] [normed_space ℝ E] {x y : E} (hxy : x ≠ y) : ∃ (f : E →L[ℝ] ℝ), ⇑f x < ⇑f y
theorem ennreal.cancel_of_lt {a : ennreal} (h : a < ⊤) : add_le_cancellable a
theorem simplex_category.len_le_of_epi {x y : simplex_category} {f : x ⟶ y} : category_theory.epi f → y.len ≤ x.len
theorem is_left_regular_zero_iff_subsingleton {R : Type u_1} [mul_zero_class R] : is_left_regular 0 ↔ subsingleton R
theorem colex.singleton_le_iff_le {α : Type u_1} [linear_order α] {r s : α} : {r}.to_colex ≤ {s}.to_colex ↔ r ≤ s
theorem is_add_group_hom.map_neg {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) (a : α) : f (-a) = -f a
theorem set.countable.exists_surjective {α : Type u} {s : set α} (hc : s.countable) (hs : s.nonempty) : ∃ (f : ℕ → α), s = set.range f
theorem part.eta {α : Type u_1} (o : part α) : {dom := o.dom, get := λ (h : o.dom), o.get h} = o
theorem unique_diff_within_at.eq {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {f' f₁' : E →L[𝕜] F} {x : E} {s : set E} (H : unique_diff_within_at 𝕜 s x) (hf : has_fderiv_within_at f f' s x) (hg : has_fderiv_within_at f f₁' s x) : f' = f₁'
theorem category_theory.cosimplicial_object.δ_comp_σ_of_gt {C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) {n : ℕ} {i : fin (n + 2)} {j : fin (n + 1)} (H : ⇑fin.cast_succ j < i) : X.δ i.succ ≫ X.σ (⇑fin.cast_succ j) = X.σ j ≫ X.δ i
theorem bilin_form.nondegenerate_restrict_of_disjoint_orthogonal {R₁ : Type u_3} {M₁ : Type u_4} [ring R₁] [add_comm_group M₁] [module R₁ M₁] (B : bilin_form R₁ M₁) (b : B.is_refl) {W : submodule R₁ M₁} (hW : disjoint W (B.orthogonal W)) : (B.restrict W).nondegenerate
theorem besicovitch.exists_disjoint_closed_ball_covering_ae {α : Type u_1} [metric_space α] [topological_space.second_countable_topology α] [measurable_space α] [opens_measurable_space α] [has_besicovitch_covering α] (μ : measure_theory.measure α) [measure_theory.sigma_finite μ] (f : α → set ℝ) (s : set α) (hf : ∀ (x : α), x ∈ s → ∀ (δ : ℝ), δ > 0 → (f x ∩ set.Ioo 0 δ).nonempty) (R : α → ℝ) (hR : ∀ (x : α), x ∈ s → 0 < R x) : ∃ (t : set α) (r : α → ℝ), t.countable ∧ t ⊆ s ∧ (∀ (x : α), x ∈ t → r x ∈ f x ∩ set.Ioo 0 (R x)) ∧ ⇑μ (s  ⋃ (x : α) (H : x ∈ t), metric.closed_ball x (r x)) = 0 ∧ t.pairwise_disjoint (λ (x : α), metric.closed_ball x (r x))
theorem real.abs_log_mul_self_lt (x : ℝ) (h1 : 0 < x) (h2 : x ≤ 1) : |real.log x * x| < 1
theorem measure_theory.content.inner_content_mono {G : Type w} [topological_space G] (μ : measure_theory.content G) ⦃U V : set G⦄ (hU : is_open U) (hV : is_open V) (h2 : U ⊆ V) : μ.inner_content ⟨U, hU⟩ ≤ μ.inner_content ⟨V, hV⟩
theorem eq_orthogonal_projection_fn_of_mem_of_inner_eq_zero {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K : submodule 𝕜 E} [complete_space ↥K] {u v : E} (hvm : v ∈ K) (hvo : ∀ (w : E), w ∈ K → has_inner.inner (u - v) w = 0) : orthogonal_projection_fn K u = v
theorem mul_action.quotient_preimage_image_eq_union_mul {α : Type u} {β : Type v} [group α] [mul_action α β] (U : set β) : quotient.mk ⁻¹' (quotient.mk '' U) = ⋃ (a : α), has_scalar.smul a '' U
theorem has_strict_fderiv_at.map_implicit_function_of_complemented_eq {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] [complete_space F] {f : E → F} {f' : E →L[𝕜] F} {a : E} (hf : has_strict_fderiv_at f f' a) (hf' : f'.range = ⊤) (hker : f'.ker.closed_complemented) : ∀ᶠ (p : F × ↥(f'.ker)) in nhds (f a, 0), f (has_strict_fderiv_at.implicit_function_of_complemented f f' hf hf' hker p.fst p.snd) = p.fst
theorem affine.simplex.face_centroid_eq_centroid {k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : ℕ} (s : affine.simplex k P n) {fs : finset (fin (n + 1))} {m : ℕ} (h : fs.card = m + 1) : finset.centroid k finset.univ (s.face h).points = finset.centroid k fs s.points
theorem finset.sup_indep_iff_disjoint_erase {α : Type u_1} {ι : Type u_3} [lattice α] [order_bot α] {s : finset ι} {f : ι → α} [decidable_eq ι] : s.sup_indep f ↔ ∀ (i : ι), i ∈ s → disjoint (f i) ((s.erase i).sup f)
theorem complex.has_deriv_at_cos (x : ℂ) : has_deriv_at complex.cos (-complex.sin x) x
theorem has_deriv_at_filter_iff_tendsto_slope {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {F : Type v} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜} {L : filter 𝕜} : has_deriv_at_filter f f' x L ↔ filter.tendsto (slope f x) (L ⊓ filter.principal {x}ᶜ) (nhds f')
theorem circle_integral.integral_eq_zero_of_has_deriv_within_at' {E : Type u_1} [normed_group E] [normed_space ℂ E] [complete_space E] {f f' : ℂ → E} {c : ℂ} {R : ℝ} (h : ∀ (z : ℂ), z ∈ metric.sphere c |R| → has_deriv_within_at f (f' z) (metric.sphere c |R|) z) : ∮ (z : ℂ) in C(c, R), f' z = 0
theorem first_order.language.hom.comp_assoc {L : first_order.language} {M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] {P : Type u_1} [L.Structure P] {Q : Type u_2} [L.Structure Q] (f : L.hom M N) (g : L.hom N P) (h : L.hom P Q) : (h.comp g).comp f = h.comp (g.comp f)
theorem measure_theory.lintegral_map_equiv {α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [measurable_space β] (f : β → ennreal) (g : α ≃ᵐ β) : ∫⁻ (a : β), f a ∂measure_theory.measure.map ⇑g μ = ∫⁻ (a : α), f (⇑g a) ∂μ
theorem bounded_convex_hull {E : Type u_2} [semi_normed_group E] [normed_space ℝ E] {s : set E} : metric.bounded (⇑(convex_hull ℝ) s) ↔ metric.bounded s
theorem add_tsub_le_left {α : Type u_1} [preorder α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] {a b : α} : a + b - a ≤ b
theorem left.one_lt_inv_iff {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : 1 < a⁻¹ ↔ a < 1
theorem absolute_value.abs_is_euclidean  : absolute_value.abs.is_euclidean
theorem image_sub_le_mul_sub_of_deriv_le {f : ℝ → ℝ} (hf : differentiable ℝ f) {C : ℝ} (le_hf' : ∀ (x : ℝ), deriv f x ≤ C) ⦃x y : ℝ⦄ (hxy : x ≤ y) : f y - f x ≤ C * (y - x)
theorem box_integral.has_integral_indicator_const {ι : Type u} {E : Type v} [fintype ι] [normed_group E] [normed_space ℝ E] (l : box_integral.integration_params) (hl : l.bRiemann = bool.ff) {s : set (ι → ℝ)} (hs : measurable_set s) (I : box_integral.box ι) (y : E) (μ : measure_theory.measure (ι → ℝ)) [measure_theory.is_locally_finite_measure μ] : box_integral.has_integral I l (s.indicator (λ (_x : ι → ℝ), y)) μ.to_box_additive.to_smul ((⇑μ (s ∩ ↑I)).to_real • y)
theorem multilinear_map.cons_add {R : Type u} {n : ℕ} {M : fin n.succ → Type v} {M₂ : Type v₂} [semiring R] [Π (i : fin n.succ), add_comm_monoid (M i)] [add_comm_monoid M₂] [Π (i : fin n.succ), module R (M i)] [module R M₂] (f : multilinear_map R M M₂) (m : Π (i : fin n), M i.succ) (x y : M 0) : ⇑f (fin.cons (x + y) m) = ⇑f (fin.cons x m) + ⇑f (fin.cons y m)
theorem simple_graph.clique_free.clique_finset {α : Type u_1} (G : simple_graph α) [fintype α] [decidable_eq α] [decidable_rel G.adj] {n : ℕ} : G.clique_free n → G.clique_finset n = ∅
theorem localization_finite  : ring_hom.localization_preserves ring_hom.finite
theorem free_group.reduce.rev {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red L₁ L₂) : free_group.red L₂ (free_group.reduce L₁)
theorem affine_subspace.mem_direction_iff_eq_vsub_left {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p : P} (hp : p ∈ s) (v : V) : v ∈ s.direction ↔ ∃ (p2 : P) (H : p2 ∈ s), v = p -ᵥ p2
theorem category_theory.grothendieck_topology.plus_map_to_plus {C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w} [category_theory.category D] [∀ (P : Cᵒᵖ ⥤ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] (P : Cᵒᵖ ⥤ D) [∀ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)ᵒᵖ D] : J.plus_map (J.to_plus P) = J.to_plus (J.plus_obj P)
theorem finset.exists_lt_sum_fiber_of_maps_to_of_nsmul_lt_sum {α : Type u} {β : Type v} {M : Type w} [decidable_eq β] {s : finset α} {t : finset β} {f : α → β} {w : α → M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (hf : ∀ (a : α), a ∈ s → f a ∈ t) (hb : t.card • b < s.sum (λ (x : α), w x)) : ∃ (y : β) (H : y ∈ t), b < (finset.filter (λ (x : α), f x = y) s).sum (λ (x : α), w x)
theorem filter.map_congr {α : Type u} {β : Type v} {m₁ m₂ : α → β} {f : filter α} (h : m₁ =ᶠ[f] m₂) : filter.map m₁ f = filter.map m₂ f
theorem iterated_fderiv_within_eq_equiv_comp {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {n : ℕ} {f : 𝕜 → F} {s : set 𝕜} : iterated_fderiv_within 𝕜 n f s = ⇑(continuous_multilinear_map.pi_field_equiv 𝕜 (fin n) F) ∘ iterated_deriv_within n f s
theorem is_free_groupoid.spanning_tree.tree_hom_eq {G : Type u} [category_theory.groupoid G] [is_free_groupoid G] (T : wide_subquiver (quiver.symmetrify (is_free_groupoid.generators G))) [quiver.arborescence ↥T] {a : G} (p : quiver.path (quiver.root ↥T) a) : is_free_groupoid.spanning_tree.tree_hom T a = is_free_groupoid.spanning_tree.hom_of_path T p
theorem colex.colex_lt_of_ssubset {α : Type u_1} [linear_order α] {A B : finset α} (h : A ⊂ B) : A.to_colex < B.to_colex
theorem ordered_add_comm_group.add_lt_add_left {α : Type u_1} [has_add α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {b c : α} (bc : b < c) (a : α) : a + b < a + c
theorem smooth_bump_covering.is_subordinate.to_bump_covering {ι : Type uι} {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} [t2_space M] {f : smooth_bump_covering ι I M s} {U : M → set M} : f.is_subordinate U → f.to_bump_covering.is_subordinate (λ (i : ι), U (f.c i))
theorem lipschitz_with.dimH_range_le {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X → Y} (h : lipschitz_with K f) : dimH (set.range f) ≤ dimH set.univ
theorem convex_on.map_integral_le {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {f : α → E} {g : E → ℝ} [measure_theory.is_probability_measure μ] (hg : convex_on ℝ s g) (hgc : continuous_on g s) (hsc : is_closed s) (hfs : ∀ᵐ (x : α) ∂μ, f x ∈ s) (hfi : measure_theory.integrable f μ) (hgi : measure_theory.integrable (g ∘ f) μ) : g (∫ (x : α), f x ∂μ) ≤ ∫ (x : α), g (f x) ∂μ
theorem measure_theory.integrable.interval_integrable {E : Type u_3} [normed_group E] {f : ℝ → E} {a b : ℝ} {μ : measure_theory.measure ℝ} (hf : measure_theory.integrable f μ) : interval_integrable f μ a b
theorem is_cyclotomic_extension.rat.is_integral_closure_adjoing_singleton_of_prime_pow {p : ℕ+} {k : ℕ} {K : Type u} [field K] [char_zero K] {ζ : K} [hp : fact (nat.prime ↑p)] [hcycl : is_cyclotomic_extension {p ^ k} ℚ K] (hζ : is_primitive_root ζ ↑(p ^ k)) : is_integral_closure ↥(algebra.adjoin ℤ {ζ}) ℤ K
theorem convex.mul_sub_lt_image_sub_of_lt_deriv {D : set ℝ} (hD : convex ℝ D) {f : ℝ → ℝ} (hf : continuous_on f D) (hf' : differentiable_on ℝ f (interior D)) {C : ℝ} (hf'_gt : ∀ (x : ℝ), x ∈ interior D → C < deriv f x) (x : ℝ) (H : x ∈ D) (y : ℝ) (H_1 : y ∈ D) : x < y → C * (y - x) < f y - f x
theorem comp_add_right {α : Type u_1} [add_semigroup α] (x y : α) : ((λ (_x : α), _x + x) ∘ λ (_x : α), _x + y) = λ (_x : α), _x + (y + x)
theorem set.abs_sub_le_of_subinterval {α : Type u} [linear_ordered_add_comm_group α] {a b x y : α} (h : set.interval x y ⊆ set.interval a b) : |y - x| ≤ |b - a|
theorem is_primitive_root.minpoly_eq_pow {n : ℕ} {K : Type u_8} [field K] {μ : K} (h : is_primitive_root μ n) [char_zero K] {p : ℕ} [hprime : fact (nat.prime p)] (hdiv : ¬p ∣ n) : minpoly ℤ μ = minpoly ℤ (μ ^ p)
theorem category_theory.limits.types.pi_lift_π_apply {β : Type u} (f : β → Type u) {P : Type u} (s : Π (b : β), P ⟶ f b) (b : β) (x : P) : category_theory.limits.pi.π f b (category_theory.limits.pi.lift s x) = s b x
theorem has_strict_fderiv_at.to_local_inverse {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] [cs : complete_space E] {f : E → F} {f' : E ≃L[𝕜] F} {a : E} (hf : has_strict_fderiv_at f ↑f' a) : has_strict_fderiv_at (has_strict_fderiv_at.local_inverse f f' a hf) ↑(f'.symm) (f a)
theorem t2_separation_finset {α : Type u} [topological_space α] [t2_space α] (s : finset α) : ∃ (f : α → set α), ↑s.pairwise_disjoint f ∧ ∀ (x : α), x ∈ s → x ∈ f x ∧ is_open (f x)
theorem fderiv_at.le_of_lip {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {x₀ : E} (hf : differentiable_at 𝕜 f x₀) {s : set E} (hs : s ∈ nhds x₀) {C : nnreal} (hlip : lipschitz_on_with C f s) : ∥fderiv 𝕜 f x₀∥ ≤ ↑C
theorem is_compact.eventually_forall_of_forall_eventually {α : Type u} {β : Type v} [topological_space α] [topological_space β] {x₀ : α} {K : set β} (hK : is_compact K) {P : α → β → Prop} (hP : ∀ (y : β), y ∈ K → (∀ᶠ (z : α × β) in nhds (x₀, y), P z.fst z.snd)) : ∀ᶠ (x : α) in nhds x₀, ∀ (y : β), y ∈ K → P x y
theorem measurable_space.cardinal_generate_measurable_le_continuum {α : Type u} {s : set (set α)} (hs : cardinal.mk ↥s ≤ cardinal.continuum) : cardinal.mk ↥{t : set α | measurable_space.generate_measurable s t} ≤ cardinal.continuum
theorem cont_diff_on.continuous_linear_map_comp {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {s : set E} {f : E → F} {n : with_top ℕ} (g : F →L[𝕜] G) (hf : cont_diff_on 𝕜 n f s) : cont_diff_on 𝕜 n (⇑g ∘ f) s
theorem add_subgroup.is_normal_topological_closure {G : Type u_1} [topological_space G] [add_group G] [topological_add_group G] (N : add_subgroup G) [N.normal] : N.topological_closure.normal
theorem measure_theory.measure.ext_iff_of_sUnion_eq_univ {α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} {S : set (set α)} (hc : S.countable) (hs : ⋃₀S = set.univ) : μ = ν ↔ ∀ (s : set α), s ∈ S → μ.restrict s = ν.restrict s
theorem finset.le_card_falling_div_choose {𝕜 : Type u_1} {α : Type u_2} [linear_ordered_field 𝕜] [decidable_eq α] {k : ℕ} {𝒜 : finset (finset α)} [fintype α] (hk : k ≤ fintype.card α) (h𝒜 : is_antichain has_subset.subset ↑𝒜) : (finset.range (k + 1)).sum (λ (r : ℕ), ↑((𝒜.slice (fintype.card α - r)).card) / ↑((fintype.card α).choose (fintype.card α - r))) ≤ ↑((finset.falling (fintype.card α - k) 𝒜).card) / ↑((fintype.card α).choose (fintype.card α - k))
theorem subgroup.commutator_pi_pi_of_fintype {η : Type u_1} [fintype η] {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (H K : Π (i : η), subgroup (Gs i)) : ⁅subgroup.pi set.univ H,subgroup.pi set.univ K⁆ = subgroup.pi set.univ (λ (i : η), ⁅H i,K i⁆)
theorem cont_diff_at_map_inverse {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : with_top ℕ} [complete_space E] (e : E ≃L[𝕜] F) : cont_diff_at 𝕜 n continuous_linear_map.inverse ↑e
theorem measure_theory.exists_null_pairwise_disjoint_diff {ι : Type u_1} {α : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [encodable ι] {s : ι → set α} (hd : pairwise (measure_theory.ae_disjoint μ on s)) : ∃ (t : ι → set α), (∀ (i : ι), measurable_set (t i)) ∧ (∀ (i : ι), ⇑μ (t i) = 0) ∧ pairwise (disjoint on λ (i : ι), s i  t i)
theorem card_multiples (n p : ℕ) : (finset.filter (λ (e : ℕ), p ∣ e + 1) (finset.range n)).card = n / p
theorem is_trivial_topological_fiber_bundle_fst {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.fst
theorem polynomial.sum_over_range {R : Type u} {S : Type v} [semiring R] [add_comm_monoid S] (p : polynomial R) {f : ℕ → R → S} (h : ∀ (n : ℕ), f n 0 = 0) : p.sum f = (finset.range (p.nat_degree + 1)).sum (λ (a : ℕ), f a (p.coeff a))
theorem category_theory.limits.colimit_limit_to_limit_colimit_surjective {J K : Type v} [category_theory.small_category J] [category_theory.small_category K] (F : J × K ⥤ Type v) [category_theory.is_filtered K] [category_theory.fin_category J] : function.surjective (category_theory.limits.colimit_limit_to_limit_colimit F)
theorem emetric.Hausdorff_edist_closure₁ {α : Type u} [pseudo_emetric_space α] {s t : set α} : emetric.Hausdorff_edist (closure s) t = emetric.Hausdorff_edist s t
theorem orientation.eq_iff_oangle_eq_zero_of_norm_eq {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y : V} (h : ∥x∥ = ∥y∥) : x = y ↔ o.oangle x y = 0
theorem upper_semicontinuous_at.add {α : Type u_1} [topological_space α] {x : α} {γ : Type u_4} [linear_ordered_add_comm_monoid γ] [topological_space γ] [order_topology γ] [has_continuous_add γ] {f g : α → γ} (hf : upper_semicontinuous_at f x) (hg : upper_semicontinuous_at g x) : upper_semicontinuous_at (λ (z : α), f z + g z) x
theorem algebra.is_integral_of_finite (K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite_dimensional K L] : algebra.is_integral K L
theorem finset.sum_partition {β : Type u} {α : Type v} {s : finset α} {f : α → β} [add_comm_monoid β] (R : setoid α) [decidable_rel setoid.r] : s.sum (λ (x : α), f x) = (finset.image quotient.mk s).sum (λ (xbar : quotient R), (finset.filter (λ (y : α), ⟦y⟧ = xbar) s).sum (λ (y : α), f y))
theorem category_theory.Groupoid.hom_to_functor {C D E : category_theory.Groupoid} (f : C ⟶ D) (g : D ⟶ E) : f ≫ g = f ⋙ g
theorem cont_diff_within_at.neg {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {x : E} {n : with_top ℕ} {s : set E} {f : E → F} (hf : cont_diff_within_at 𝕜 n f s x) : cont_diff_within_at 𝕜 n (λ (x : E), -f x) s x
theorem continuous_map.congr_fun {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f g : C(α, β)} (H : f = g) (x : α) : ⇑f x = ⇑g x
theorem compact_open_separated_add_left {G : Type w} [topological_space G] [add_group G] [topological_add_group G] {K U : set G} (hK : is_compact K) (hU : is_open U) (hKU : K ⊆ U) : ∃ (V : set G) (H : V ∈ nhds 0), V + K ⊆ U
theorem module.ray.some_vector_ne_zero {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : module.ray R M) : x.some_vector ≠ 0
theorem measure_theory.is_open_pos_measure_of_add_left_invariant_of_regular {G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {μ : measure_theory.measure G} [add_group G] [topological_add_group G] [μ.is_add_left_invariant] [μ.regular] (h₀ : μ ≠ 0) : μ.is_open_pos_measure
theorem affine_map.id_apply (k : Type u_1) {V1 : Type u_2} {P1 : Type u_3} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] (p : P1) : ⇑(affine_map.id k P1) p = p
theorem mvqpf.cofix.bisim {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} (r : mvqpf.cofix F α → mvqpf.cofix F α → Prop) (h : ∀ (x y : mvqpf.cofix F α), r x y → mvfunctor.liftr (α.rel_last r) x.dest y.dest) (x y : mvqpf.cofix F α) : r x y → x = y
theorem measure_theory.mem_ℒp.integral_indicator_norm_ge_le {α : Type u_1} {β : Type u_2} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {f : α → β} (hf : measure_theory.mem_ℒp f 1 μ) (hmeas : measure_theory.strongly_measurable f) {ε : ℝ} (hε : 0 < ε) : ∃ (M : ℝ), ∫⁻ (x : α), ↑∥{x : α | M ≤ ↑∥f x∥₊}.indicator f x∥₊ ∂μ ≤ ennreal.of_real ε
theorem affine.simplex.mem_altitude {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P (n + 1)) (i : fin (n + 2)) : s.points i ∈ s.altitude i
theorem set_of_is_preconnected_eq_of_ordered {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] : {s : set α | is_preconnected s} = set.range (function.uncurry set.Icc) ∪ set.range (function.uncurry set.Ico) ∪ set.range (function.uncurry set.Ioc) ∪ set.range (function.uncurry set.Ioo) ∪ (set.range set.Ici ∪ set.range set.Ioi ∪ set.range set.Iic ∪ set.range set.Iio ∪ {set.univ, ∅})
theorem proper_space_of_compact_closed_ball_of_le {α : Type u} [pseudo_metric_space α] (R : ℝ) (h : ∀ (x : α) (r : ℝ), R ≤ r → is_compact (metric.closed_ball x r)) : proper_space α
theorem nat.prod_factorization_eq_prod_factors {n : ℕ} {β : Type u_1} [comm_monoid β] (f : ℕ → β) : n.factorization.prod (λ (p k : ℕ), f p) = n.factors.to_finset.prod (λ (p : ℕ), f p)
theorem function.injective2.right' {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) [nonempty α] : function.injective (λ (b : β) (a : α), f a b)
theorem norm_add_lt_of_not_same_ray {E : Type u_2} [normed_group E] [normed_space ℝ E] [strict_convex_space ℝ E] {x y : E} (h : ¬same_ray ℝ x y) : ∥x + y∥ < ∥x∥ + ∥y∥
theorem add_comm_group.direct_limit.of.zero_exact {ι : Type v} [dec_ι : decidable_eq ι] [preorder ι] {G : ι → Type w} [Π (i : ι), add_comm_group (G i)] {f : Π (i j : ι), i ≤ j → G i →+ G j} [is_directed ι has_le.le] [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] (i : ι) (x : G i) (h : ⇑(add_comm_group.direct_limit.of G f i) x = 0) : ∃ (j : ι) (hij : i ≤ j), ⇑(f i j hij) x = 0
theorem interval_integral.has_deriv_at_integral_of_dominated_loc_of_lip {𝕜 : Type u_1} [is_R_or_C 𝕜] {μ : measure_theory.measure ℝ} {E : Type u_2} [normed_group E] [normed_space ℝ E] [normed_space 𝕜 E] [complete_space E] {a b ε : ℝ} {bound : ℝ → ℝ} {F : 𝕜 → ℝ → E} {F' : ℝ → E} {x₀ : 𝕜} (ε_pos : 0 < ε) (hF_meas : ∀ᶠ (x : 𝕜) in nhds x₀, measure_theory.ae_strongly_measurable (F x) (μ.restrict (set.interval_oc a b))) (hF_int : interval_integrable (F x₀) μ a b) (hF'_meas : measure_theory.ae_strongly_measurable F' (μ.restrict (set.interval_oc a b))) (h_lipsch : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → lipschitz_on_with (⇑real.nnabs (bound t)) (λ (x : 𝕜), F x t) (metric.ball x₀ ε)) (bound_integrable : interval_integrable bound μ a b) (h_diff : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → has_deriv_at (λ (x : 𝕜), F x t) (F' t) x₀) : interval_integrable F' μ a b ∧ has_deriv_at (λ (x : 𝕜), ∫ (t : ℝ) in a..b, F x t ∂μ) (∫ (t : ℝ) in a..b, F' t ∂μ) x₀
theorem is_p_group.coprime_card_of_ne {G : Type u_1} [group G] {G₂ : Type u_2} [group G₂] (p₁ p₂ : ℕ) [hp₁ : fact (nat.prime p₁)] [hp₂ : fact (nat.prime p₂)] (hne : p₁ ≠ p₂) (H₁ : subgroup G) (H₂ : subgroup G₂) [fintype ↥H₁] [fintype ↥H₂] (hH₁ : is_p_group p₁ ↥H₁) (hH₂ : is_p_group p₂ ↥H₂) : (fintype.card ↥H₁).coprime (fintype.card ↥H₂)
theorem measure_theory.Lp.induction_strongly_measurable_aux {α : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space α} {μ : measure_theory.measure α} [fact (1 ≤ p)] [normed_space ℝ F] (hm : m ≤ m0) (hp_ne_top : p ≠ ⊤) (P : ↥(measure_theory.Lp F p μ) → Prop) (h_ind : ∀ (c : F) {s : set α} (hs : measurable_set s) (hμs : ⇑μ s < ⊤), P ↑(measure_theory.Lp.simple_func.indicator_const p _ _ c)) (h_add : ∀ ⦃f g : α → F⦄ (hf : measure_theory.mem_ℒp f p μ) (hg : measure_theory.mem_ℒp g p μ), measure_theory.ae_strongly_measurable' m f μ → measure_theory.ae_strongly_measurable' m g μ → disjoint (function.support f) (function.support g) → P (measure_theory.mem_ℒp.to_Lp f hf) → P (measure_theory.mem_ℒp.to_Lp g hg) → P (measure_theory.mem_ℒp.to_Lp f hf + measure_theory.mem_ℒp.to_Lp g hg)) (h_closed : is_closed {f : ↥(measure_theory.Lp_meas F ℝ m p μ) | P ↑f}) (f : ↥(measure_theory.Lp F p μ)) : measure_theory.ae_strongly_measurable' m ⇑f μ → P f
theorem continuous_linear_map.is_weak_closed_closed_ball {𝕜 : Type u_1} {𝕜₂ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {E' : Type u_10} [semi_normed_group E'] [normed_space 𝕜 E'] [ring_hom_isometric σ₁₂] (f₀ : E' →SL[σ₁₂] F) (r : ℝ) ⦃f : E' →SL[σ₁₂] F⦄ (hf : ⇑f ∈ closure (coe_fn '' metric.closed_ball f₀ r)) : f ∈ metric.closed_ball f₀ r
theorem category_theory.limits.complete_lattice.coprod_eq_sup {α : Type u} [semilattice_sup α] [order_bot α] (x y : α) : (x ⨿ y) = x ⊔ y
theorem prime_spectrum.gc_set (R : Type u) [comm_ring R] : galois_connection (λ (s : set R), prime_spectrum.zero_locus s) (λ (t : (set (prime_spectrum R))ᵒᵈ), ↑(prime_spectrum.vanishing_ideal t))
theorem category_theory.is_pushout.paste_vert {C : Type u₁} [category_theory.category C] {X₁₁ X₁₂ X₂₁ X₂₂ X₃₁ X₃₂ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₂₁ : X₂₁ ⟶ X₂₂} {h₃₁ : X₃₁ ⟶ X₃₂} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₂₁ : X₂₁ ⟶ X₃₁} {v₂₂ : X₂₂ ⟶ X₃₂} (s : category_theory.is_pushout h₁₁ v₁₁ v₁₂ h₂₁) (t : category_theory.is_pushout h₂₁ v₂₁ v₂₂ h₃₁) : category_theory.is_pushout h₁₁ (v₁₁ ≫ v₂₁) (v₁₂ ≫ v₂₂) h₃₁
theorem subgroup.map_normalizer_eq_of_bijective {G : Type u_1} [group G] {N : Type u_3} [group N] (H : subgroup G) {f : G →* N} (hf : function.bijective ⇑f) : subgroup.map f H.normalizer = (subgroup.map f H).normalizer
theorem norm_image_sub_le_of_norm_deriv_le_segment {E : Type u_1} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {a b C : ℝ} (hf : differentiable_on ℝ f (set.Icc a b)) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → ∥deriv_within f (set.Icc a b) x∥ ≤ C) (x : ℝ) (H : x ∈ set.Icc a b) : ∥f x - f a∥ ≤ C * (x - a)
theorem category_theory.limits.has_limit.of_cones_iso {C : Type u} [category_theory.category C] {J K : Type u₁} [category_theory.category J] [category_theory.category K] (F : J ⥤ C) (G : K ⥤ C) (h : F.cones ≅ G.cones) [category_theory.limits.has_limit F] : category_theory.limits.has_limit G
theorem linear_dependent_comp_subtype {ι : Type u_1} {R : Type u_3} {M : Type u_5} {v : ι → M} [semiring R] [add_comm_monoid M] [module R M] {s : set ι} : ¬linear_independent R (v ∘ coe) ↔ ∃ (f : ι →₀ R), f ∈ finsupp.supported R R s ∧ f.support.sum (λ (i : ι), ⇑f i • v i) = 0 ∧ f ≠ 0
theorem category_theory.subobject.eq_of_comp_arrow_eq {C : Type u₁} [category_theory.category C] {X Y : C} {P : category_theory.subobject Y} {f g : X ⟶ ↑P} (h : f ≫ P.arrow = g ≫ P.arrow) : f = g
theorem pi_eq_sum_univ {ι : Type u_1} [fintype ι] [decidable_eq ι] {R : Type u_2} [semiring R] (x : ι → R) : x = finset.univ.sum (λ (i : ι), x i • λ (j : ι), ite (i = j) 1 0)
theorem simple_graph.bot_strongly_regular {V : Type u} [fintype V] [decidable_eq V] {ℓ : ℕ} : ⊥.is_SRG_with (fintype.card V) 0 ℓ 0
theorem continuous_map.tendsto_iff_tendsto_uniformly {α : Type u₁} {β : Type u₂} [topological_space α] [uniform_space β] {f : C(α, β)} {ι : Type u₃} {p : filter ι} {F : ι → C(α, β)} [compact_space α] : filter.tendsto F p (nhds f) ↔ tendsto_uniformly (λ (i : ι) (a : α), ⇑(F i) a) ⇑f p
theorem is_min_on.of_is_local_min_on_of_convex_on {E : Type u_1} {β : Type u_2} [add_comm_group E] [topological_space E] [module ℝ E] [topological_add_group E] [has_continuous_smul ℝ E] [ordered_add_comm_group β] [module ℝ β] [ordered_smul ℝ β] {s : set E} {f : E → β} {a : E} (a_in_s : a ∈ s) (h_localmin : is_local_min_on f s a) (h_conv : convex_on ℝ s f) : is_min_on f s a
theorem alternating_map.map_linear_dependent {ι : Type u_6} [decidable_eq ι] {K : Type u_1} [ring K] {M : Type u_2} [add_comm_group M] [module K M] {N : Type u_3} [add_comm_group N] [module K N] [no_zero_smul_divisors K N] (f : alternating_map K M N ι) (v : ι → M) (h : ¬linear_independent K v) : ⇑f v = 0
theorem is_countably_spanning.pi {ι : Type u_1} {α : ι → Type u_3} [fintype ι] {C : Π (i : ι), set (set (α i))} (hC : ∀ (i : ι), is_countably_spanning (C i)) : is_countably_spanning (set.univ.pi '' set.univ.pi C)
theorem continuous_linear_map.is_closed_image_coe_closed_ball {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [normed_group E] [normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [ring_hom_isometric σ₁₂] (f₀ : E →SL[σ₁₂] F) (r : ℝ) : is_closed (coe_fn '' metric.closed_ball f₀ r)
theorem multiset.nodup.of_powerset {α : Type u_1} {s : multiset α} : s.powerset.nodup → s.nodup
theorem linear_independent_unique {ι : Type u_1} {R : Type u_3} {M : Type u_5} [ring R] [nontrivial R] [add_comm_group M] [module R M] [no_zero_smul_divisors R M] (v : ι → M) [unique ι] : v inhabited.default ≠ 0 → linear_independent R v
theorem smooth_bump_function.smooth {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {c : M} (f : smooth_bump_function I c) [t2_space M] [smooth_manifold_with_corners I M] : smooth I (model_with_corners_self ℝ ℝ) ⇑f
theorem metric.uniformity_basis_dist_le {α : Type u} [pseudo_metric_space α] : (uniformity α).has_basis (λ (ε : ℝ), 0 < ε) (λ (ε : ℝ), {p : α × α | has_dist.dist p.fst p.snd ≤ ε})
theorem convex.lipschitz_on_with_of_nnnorm_deriv_within_le {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_group G] [normed_space 𝕜 G] {f : 𝕜 → G} {s : set 𝕜} {C : nnreal} (hs : convex ℝ s) (hf : differentiable_on 𝕜 f s) (bound : ∀ (x : 𝕜), x ∈ s → ∥deriv_within f s x∥₊ ≤ C) : lipschitz_on_with C f s
theorem algebraic_geometry.reduce_to_affine_global (P : Π (X : algebraic_geometry.Scheme), topological_space.opens ↥(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier) → Prop) (h₁ : ∀ (X : algebraic_geometry.Scheme) (U : topological_space.opens ↥(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)), (∀ (x : ↥U), ∃ {V : topological_space.opens ↥(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)} (h : x.val ∈ V) (i : V ⟶ U), P X V) → P X U) (h₂ : ∀ {X Y : algebraic_geometry.Scheme} (f : X ⟶ Y) [hf : algebraic_geometry.is_open_immersion f], ∃ {U : set ↥(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)} {V : set ↥(Y.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)} (hU : U = ⊤) (hV : V = set.range ⇑(f.val.base)), P X ⟨U, _⟩ → P Y ⟨V, _⟩) (h₃ : ∀ (R : CommRing), P (algebraic_geometry.Scheme.Spec.obj (opposite.op R)) ⊤) (X : algebraic_geometry.Scheme) (U : topological_space.opens ↥(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)) : P X U
theorem rack.to_envel_group.univ (R : Type u_1) [rack R] (G : Type u_2) [group G] (f : shelf_hom R (quandle.conj G)) : (quandle.conj.map (⇑rack.to_envel_group.map f)).comp (rack.to_envel_group R) = f
theorem polynomial.mono_map_nat_degree_eq {R : Type u_1} [semiring R] {S : Type u_2} {F : Type u_3} [semiring S] [add_monoid_hom_class F (polynomial R) (polynomial S)] {φ : F} {p : polynomial R} (k : ℕ) (fu : ℕ → ℕ) (fu0 : ∀ {n : ℕ}, n ≤ k → fu n = 0) (fc : ∀ {n m : ℕ}, k ≤ n → n < m → fu n < fu m) (φ_k : ∀ {f : polynomial R}, f.nat_degree < k → ⇑φ f = 0) (φ_mon_nat : ∀ (n : ℕ) (c : R), c ≠ 0 → (⇑φ (⇑(polynomial.monomial n) c)).nat_degree = fu n) : (⇑φ p).nat_degree = fu p.nat_degree
theorem list.drop_append {α : Type u} {l₁ l₂ : list α} (i : ℕ) : list.drop (l₁.length + i) (l₁ ++ l₂) = list.drop i l₂
theorem antisymm_of' {α : Type u} (r : α → α → Prop) [is_antisymm α r] {a b : α} : r a b → r b a → b = a
theorem pi.mul_single_apply_commute {I : Type u} {f : I → Type v} [decidable_eq I] [Π (i : I), mul_one_class (f i)] (x : Π (i : I), f i) (i j : I) : commute (pi.mul_single i (x i)) (pi.mul_single j (x j))
theorem nnreal.has_sum_iff_tendsto_nat {f : ℕ → nnreal} {r : nnreal} : has_sum f r ↔ filter.tendsto (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), f i)) filter.at_top (nhds r)
theorem holder_with.uniform_continuous {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C r : nnreal} {f : X → Y} (hf : holder_with C r f) (h0 : 0 < r) : uniform_continuous f
theorem cardinal.mk_Icc_real {a b : ℝ} (h : a < b) : cardinal.mk ↥(set.Icc a b) = cardinal.continuum
theorem linear_map.sum_repr_mul_repr_mul {ι₁ : Type u_1} {ι₂ : Type u_2} {R : Type u_3} {R₂ : Type u_4} {S : Type u_5} {S₂ : Type u_6} {M : Type u_7} {N : Type u_8} {P : Type u_9} [comm_ring R] [comm_ring S] [comm_ring R₂] [comm_ring S₂] [add_comm_group M] [add_comm_group N] [add_comm_group P] [module R M] [module S N] [module R₂ P] [module S₂ P] [smul_comm_class S₂ R₂ P] {ρ₁₂ : R →+* R₂} {σ₁₂ : S →+* S₂} (b₁ : basis ι₁ R M) (b₂ : basis ι₂ S N) {B : M →ₛₗ[ρ₁₂] N →ₛₗ[σ₁₂] P} (x : M) (y : N) : (⇑(b₁.repr) x).sum (λ (i : ι₁) (xi : R), (⇑(b₂.repr) y).sum (λ (j : ι₂) (yj : S), ⇑ρ₁₂ xi • ⇑σ₁₂ yj • ⇑(⇑B (⇑b₁ i)) (⇑b₂ j))) = ⇑(⇑B x) y
theorem besicovitch.ae_tendsto_measure_inter_div_of_measurable_set {β : Type u} [metric_space β] [measurable_space β] [borel_space β] [sigma_compact_space β] [has_besicovitch_covering β] (μ : measure_theory.measure β) [measure_theory.is_locally_finite_measure μ] {s : set β} (hs : measurable_set s) : ∀ᵐ (x : β) ∂μ, filter.tendsto (λ (r : ℝ), ⇑μ (s ∩ metric.closed_ball x r) / ⇑μ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds (s.indicator 1 x))
theorem antitone.map_is_least {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} (hf : antitone f) {a : α} {s : set α} : is_least s a → is_greatest (f '' s) (f a)
theorem tendsto_subseq_of_bounded {X : Type u_1} [pseudo_metric_space X] [proper_space X] {s : set X} (hs : metric.bounded s) {x : ℕ → X} (hx : ∀ (n : ℕ), x n ∈ s) : ∃ (a : X) (H : a ∈ closure s) (φ : ℕ → ℕ), strict_mono φ ∧ filter.tendsto (x ∘ φ) filter.at_top (nhds a)
theorem exists_irrational_btwn {x y : ℝ} (h : x < y) : ∃ (r : ℝ), irrational r ∧ x < r ∧ r < y
theorem tactic.ring_exp.exp_congr {α : Type u} [comm_semiring α] {p p' : α} {ps ps' : ℕ} : p = p' → ps = ps' → p ^ ps = p' ^ ps'
theorem direct_sum.ring_hom_ext' {ι : Type u_1} [decidable_eq ι] {A : ι → Type u_2} {R : Type u_3} [Π (i : ι), add_comm_monoid (A i)] [add_monoid ι] [direct_sum.gsemiring A] [semiring R] ⦃F G : direct_sum ι (λ (i : ι), A i) →+* R⦄ (h : ∀ (i : ι), ↑F.comp (direct_sum.of A i) = ↑G.comp (direct_sum.of A i)) : F = G
theorem is_galois.tfae {F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] [finite_dimensional F E] : [is_galois F E, intermediate_field.fixed_field ⊤ = ⊥, fintype.card (E ≃ₐ[F] E) = finite_dimensional.finrank F E, ∃ (p : polynomial F), p.separable ∧ polynomial.is_splitting_field F E p].tfae
theorem cont_diff_within_at.exists_lipschitz_on_with {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {f : E → F} {s : set E} {x : E} (hf : cont_diff_within_at ℝ 1 f s x) (hs : convex ℝ s) : ∃ (K : nnreal) (t : set E) (H : t ∈ nhds_within x s), lipschitz_on_with K f t
theorem dense_Inter_of_Gδ {α : Type u_1} {β : Type u_2} [topological_space α] [baire_space α] [encodable β] {f : β → set α} (ho : ∀ (s : β), is_Gδ (f s)) (hd : ∀ (s : β), dense (f s)) : dense (⋂ (s : β), f s)
theorem simple_graph.exists_maximal_degree_vertex {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [nonempty V] : ∃ (v : V), G.max_degree = G.degree v
theorem category_theory.limits.image.eq_fac {C : Type u} [category_theory.category C] {X Y : C} {f f' : X ⟶ Y} [category_theory.limits.has_image f] [category_theory.limits.has_image f'] [category_theory.limits.has_equalizers C] (h : f = f') : category_theory.limits.image.ι f = (category_theory.limits.image.eq_to_iso h).hom ≫ category_theory.limits.image.ι f'
theorem cont_diff_on.differentiable_on {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {n : with_top ℕ} (h : cont_diff_on 𝕜 n f s) (hn : 1 ≤ n) : differentiable_on 𝕜 f s
theorem zmod.legendre_sym_card_sqrts (p : ℕ) [fact (nat.prime p)] (hp : p ≠ 2) (a : ℤ) : ↑({x : zmod p | x ^ 2 = ↑a}.to_finset.card) = zmod.legendre_sym p a + 1
theorem category_theory.subobject.eq_of_comm {C : Type u₁} [category_theory.category C] {B : C} {X Y : category_theory.subobject B} (f : ↑X ≅ ↑Y) (w : f.hom ≫ Y.arrow = X.arrow) : X = Y
theorem factorization_mul {α : Type u_1} [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] [normalization_monoid α] [decidable_eq α] {a b : α} (ha : a ≠ 0) (hb : b ≠ 0) : factorization (a * b) = factorization a + factorization b
theorem le_rfl {α : Type u} [preorder α] {a : α} : a ≤ a
theorem dense_embedding.prod {α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} [topological_space α] [topological_space β] [topological_space γ] [topological_space δ] {e₁ : α → β} {e₂ : γ → δ} (de₁ : dense_embedding e₁) (de₂ : dense_embedding e₂) : dense_embedding (λ (p : α × γ), (e₁ p.fst, e₂ p.snd))
theorem tfae_mem_nhds_within_Iic {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a b : α} (h : a < b) (s : set α) : [s ∈ nhds_within b (set.Iic b), s ∈ nhds_within b (set.Icc a b), s ∈ nhds_within b (set.Ioc a b), ∃ (l : α) (H : l ∈ set.Ico a b), set.Ioc l b ⊆ s, ∃ (l : α) (H : l ∈ set.Iio b), set.Ioc l b ⊆ s].tfae
theorem approximates_linear_on.norm_fderiv_sub_le {E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {s : set E} {f : E → E} [measurable_space E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] {A : E →L[ℝ] E} {δ : nnreal} (hf : approximates_linear_on f A s δ) (hs : measurable_set s) (f' : E → (E →L[ℝ] E)) (hf' : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) : ∀ᵐ (x : E) ∂μ.restrict s, ∥f' x - A∥₊ ≤ δ
theorem star_convex.affine_image {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [ordered_ring 𝕜] [add_comm_group E] [add_comm_group F] [module 𝕜 E] [module 𝕜 F] {x : E} (f : E →ᵃ[𝕜] F) {s : set E} (hs : star_convex 𝕜 x s) : star_convex 𝕜 (⇑f x) (⇑f '' s)
theorem ennreal.to_real_sum {α : Type u_1} {s : finset α} {f : α → ennreal} (hf : ∀ (a : α), a ∈ s → f a ≠ ⊤) : (s.sum (λ (a : α), f a)).to_real = s.sum (λ (a : α), (f a).to_real)
theorem bounded_continuous_function.dist_le {α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {f g : bounded_continuous_function α β} {C : ℝ} (C0 : 0 ≤ C) : has_dist.dist f g ≤ C ↔ ∀ (x : α), has_dist.dist (⇑f x) (⇑g x) ≤ C
theorem affine_span_nonempty (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : ↑(affine_span k s).nonempty ↔ s.nonempty
theorem continuous_map.continuous_comp {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] (g : C(β, γ)) : continuous g.comp
theorem configuration.has_points.card_le (P L : Type u) [has_mem P L] [configuration.has_points P L] [fintype P] [fintype L] : fintype.card L ≤ fintype.card P
theorem phragmen_lindelof.eq_zero_on_horizontal_strip {E : Type u_1} [normed_group E] [normed_space ℂ E] {a b : ℝ} {f : ℂ → E} (hd : diff_cont_on_cl ℂ f (complex.im ⁻¹' set.Ioo a b)) (hB : ∃ (c : ℝ) (H : c < real.pi / (b - a)) (B : ℝ), f =O[filter.comap (has_abs.abs ∘ complex.re) filter.at_top ⊓ filter.principal (complex.im ⁻¹' set.Ioo a b)] λ (z : ℂ), real.exp (B * real.exp (c * |z.re|))) (ha : ∀ (z : ℂ), z.im = a → f z = 0) (hb : ∀ (z : ℂ), z.im = b → f z = 0) : set.eq_on f 0 (complex.im ⁻¹' set.Icc a b)
theorem is_left_regular.pow_iff {R : Type u_1} {a : R} [monoid R] {n : ℕ} (n0 : 0 < n) : is_left_regular (a ^ n) ↔ is_left_regular a
theorem generalized_continued_fraction.squash_seq_succ_n_tail_eq_squash_seq_tail_n {K : Type u_1} {n : ℕ} {s : seq (generalized_continued_fraction.pair K)} [division_ring K] : (generalized_continued_fraction.squash_seq s (n + 1)).tail = generalized_continued_fraction.squash_seq s.tail n
theorem category_theory.non_preadditive_abelian.σ_comp {C : Type u} [category_theory.category C] [category_theory.non_preadditive_abelian C] {X Y : C} (f : X ⟶ Y) : category_theory.non_preadditive_abelian.σ ≫ f = category_theory.limits.prod.map f f ≫ category_theory.non_preadditive_abelian.σ
theorem triv_sq_zero_ext.ind {R : Type u_1} {M : Type u_2} [add_zero_class R] [add_zero_class M] {P : triv_sq_zero_ext R M → Prop} (h : ∀ (r : R) (m : M), P (triv_sq_zero_ext.inl r + triv_sq_zero_ext.inr m)) (x : triv_sq_zero_ext R M) : P x
theorem submodule.basis_of_pid_aux {ι : Type u_1} {R : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] [fintype ι] {O : Type u_3} [add_comm_group O] [module R O] (M N : submodule R O) (b'M : basis ι R ↥M) (N_bot : N ≠ ⊥) (N_le_M : N ≤ M) : ∃ (y : O) (H : y ∈ M) (a : R) (hay : a • y ∈ N) (M' : submodule R O) (H : M' ≤ M) (N' : submodule R O) (H : N' ≤ N) (N'_le_M' : N' ≤ M') (y_ortho_M' : ∀ (c : R) (z : O), z ∈ M' → c • y + z = 0 → c = 0) (ay_ortho_N' : ∀ (c : R) (z : O), z ∈ N' → c • a • y + z = 0 → c = 0), ∀ (n' : ℕ) (bN' : basis (fin n') R ↥N'), ∃ (bN : basis (fin (n' + 1)) R ↥N), ∀ (m' : ℕ) (hn'm' : n' ≤ m') (bM' : basis (fin m') R ↥M'), ∃ (hnm : n' + 1 ≤ m' + 1) (bM : basis (fin (m' + 1)) R ↥M), ∀ (as : fin n' → R), (∀ (i : fin n'), ↑(⇑bN' i) = as i • ↑(⇑bM' (⇑(fin.cast_le hn'm') i))) → (∃ (as' : fin (n' + 1) → R), ∀ (i : fin (n' + 1)), ↑(⇑bN i) = as' i • ↑(⇑bM (⇑(fin.cast_le hnm) i)))
theorem add_subgroup.closure_eq {G : Type u_1} [add_group G] (K : add_subgroup G) : add_subgroup.closure ↑K = K
theorem pi_nat.exists_lipschitz_retraction_of_is_closed {E : ℕ → Type u_1} [Π (n : ℕ), topological_space (E n)] [∀ (n : ℕ), discrete_topology (E n)] {s : set (Π (n : ℕ), E n)} (hs : is_closed s) (hne : s.nonempty) : ∃ (f : (Π (n : ℕ), E n) → Π (n : ℕ), E n), (∀ (x : Π (n : ℕ), E n), x ∈ s → f x = x) ∧ set.range f = s ∧ lipschitz_with 1 f
theorem direct_sum.ring_hom_ext {ι : Type u_1} [decidable_eq ι] {A : ι → Type u_2} {R : Type u_3} [Π (i : ι), add_comm_monoid (A i)] [add_monoid ι] [direct_sum.gsemiring A] [semiring R] ⦃f g : direct_sum ι (λ (i : ι), A i) →+* R⦄ (h : ∀ (i : ι) (x : A i), ⇑f (⇑(direct_sum.of A i) x) = ⇑g (⇑(direct_sum.of A i) x)) : f = g
theorem equiv.nontrivial {α : Type u} {β : Type v} (e : α ≃ β) [nontrivial β] : nontrivial α
theorem measure_theory.outer_measure.trim_binop {α : Type u_1} [measurable_space α] {m₁ m₂ m₃ : measure_theory.outer_measure α} {op : ennreal → ennreal → ennreal} (h : ∀ (s : set α), ⇑m₁ s = op (⇑m₂ s) (⇑m₃ s)) (s : set α) : ⇑(m₁.trim) s = op (⇑(m₂.trim) s) (⇑(m₃.trim) s)
theorem sub_left_le_of_le_add {α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : a ≤ b + c → a - b ≤ c
theorem linear_map.eq_adjoint_iff_basis {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [inner_product_space 𝕜 F] [finite_dimensional 𝕜 E] [finite_dimensional 𝕜 F] {ι₁ : Type u_4} {ι₂ : Type u_5} (b₁ : basis ι₁ 𝕜 E) (b₂ : basis ι₂ 𝕜 F) (A : E →ₗ[𝕜] F) (B : F →ₗ[𝕜] E) : A = ⇑linear_map.adjoint B ↔ ∀ (i₁ : ι₁) (i₂ : ι₂), has_inner.inner (⇑A (⇑b₁ i₁)) (⇑b₂ i₂) = has_inner.inner (⇑b₁ i₁) (⇑B (⇑b₂ i₂))
theorem intermediate_field.prod_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {ι : Type u_3} {t : finset ι} {f : ι → L} (h : ∀ (c : ι), c ∈ t → f c ∈ S) : t.prod (λ (i : ι), f i) ∈ S
theorem complex.tendsto_lim_of_differentiable_on_punctured_nhds_of_bounded_under {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] {f : ℂ → E} {c : ℂ} (hd : ∀ᶠ (z : ℂ) in nhds_within c {c}ᶜ, differentiable_at ℂ f z) (hb : filter.is_bounded_under has_le.le (nhds_within c {c}ᶜ) (λ (z : ℂ), ∥f z - f c∥)) : filter.tendsto f (nhds_within c {c}ᶜ) (nhds (lim (nhds_within c {c}ᶜ) f))
theorem subalgebra.topological_closure_comap'_homeomorph {R : Type u_1} [comm_semiring R] {A : Type u} [topological_space A] [semiring A] [algebra R A] [topological_semiring A] (s : subalgebra R A) {B : Type u_2} [topological_space B] [ring B] [topological_ring B] [algebra R B] (f : B →ₐ[R] A) (f' : B ≃ₜ A) (w : ⇑f = ⇑f') : s.topological_closure.comap' f = (s.comap' f).topological_closure
theorem cycle.induction_on {α : Type u_1} {C : cycle α → Prop} (s : cycle α) (H0 : C cycle.nil) (HI : ∀ (a : α) (l : list α), C ↑l → C ↑(a :: l)) : C s
theorem orthonormal.rotation_eq_self_iff_angle_eq_zero {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x : V} (hx : x ≠ 0) (θ : real.angle) : ⇑(hb.rotation θ) x = x ↔ θ = 0
theorem irrational.add_cases {x y : ℝ} : irrational (x + y) → irrational x ∨ irrational y
theorem exists_mem_nhds_within_lt_dimH_of_lt_dimH {X : Type u_2} [emetric_space X] [topological_space.second_countable_topology X] {s : set X} {r : ennreal} (h : r < dimH s) : ∃ (x : X) (H : x ∈ s), ∀ (t : set X), t ∈ nhds_within x s → r < dimH t
theorem power_series.exp_pow_sum {A : Type u_1} [comm_ring A] [algebra ℚ A] (n : ℕ) : (finset.range n).sum (λ (k : ℕ), power_series.exp A ^ k) = power_series.mk (λ (p : ℕ), (finset.range n).sum (λ (k : ℕ), ↑k ^ p * ⇑(algebra_map ℚ A) (↑(p.factorial))⁻¹))
theorem comm_monoid.torsion.is_torsion {G : Type u_1} [comm_monoid G] : monoid.is_torsion ↥(comm_monoid.torsion G)
theorem emetric.inf_edist_lt_iff {α : Type u} [pseudo_emetric_space α] {x : α} {s : set α} {r : ennreal} : emetric.inf_edist x s < r ↔ ∃ (y : α) (H : y ∈ s), has_edist.edist x y < r
theorem continuous_multilinear_map.norm_image_sub_le {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : continuous_multilinear_map 𝕜 E G) (m₁ m₂ : Π (i : ι), E i) : ∥⇑f m₁ - ⇑f m₂∥ ≤ ∥f∥ * ↑(fintype.card ι) * linear_order.max ∥m₁∥ ∥m₂∥ ^ (fintype.card ι - 1) * ∥m₁ - m₂∥
theorem circle_deg1_lift.semiconj_of_bijective_of_translation_number_eq {f₁ f₂ : circle_deg1_lift} (h₁ : function.bijective ⇑f₁) (h₂ : function.bijective ⇑f₂) (h : f₁.translation_number = f₂.translation_number) : ∃ (F : circle_deg1_lift), function.semiconj ⇑F ⇑f₁ ⇑f₂
theorem composition_series.jordan_holder {X : Type u} [lattice X] [jordan_holder_lattice X] (s₁ s₂ : composition_series X) (hb : s₁.bot = s₂.bot) (ht : s₁.top = s₂.top) : s₁.equivalent s₂
theorem Sup_eq_of_forall_le_of_forall_lt_exists_gt {α : Type u_1} [complete_lattice α] {s : set α} {b : α} (_x : ∀ (a : α), a ∈ s → a ≤ b) (H : ∀ (w : α), w < b → (∃ (a : α) (H : a ∈ s), w < a)) : has_Sup.Sup s = b
theorem finite_field.sum_pow_lt_card_sub_one {K : Type u_1} [field K] [fintype K] (i : ℕ) (h : i < fintype.card K - 1) : finset.univ.sum (λ (x : K), x ^ i) = 0
theorem linear_equiv.finrank_eq {R : Type u_1} {M : Type u_2} {M₂ : Type u_3} [ring R] [add_comm_group M] [add_comm_group M₂] [module R M] [module R M₂] (f : M ≃ₗ[R] M₂) : finite_dimensional.finrank R M = finite_dimensional.finrank R M₂
theorem is_pi_system.pi {ι : Type u_1} {α : ι → Type u_3} {C : Π (i : ι), set (set (α i))} (hC : ∀ (i : ι), is_pi_system (C i)) : is_pi_system (set.univ.pi '' set.univ.pi C)
theorem measure_theory.tendsto_in_measure_of_tendsto_snorm {α : Type u_1} {ι : Type u_2} {E : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [normed_group E] {p : ennreal} {f : ι → α → E} {g : α → E} {l : filter ι} (hp_ne_zero : p ≠ 0) (hf : ∀ (n : ι), measure_theory.ae_strongly_measurable (f n) μ) (hg : measure_theory.ae_strongly_measurable g μ) (hfg : filter.tendsto (λ (n : ι), measure_theory.snorm (f n - g) p μ) l (nhds 0)) : measure_theory.tendsto_in_measure μ f l g
theorem polynomial.sum_over_range' {R : Type u} {S : Type v} [semiring R] [add_comm_monoid S] (p : polynomial R) {f : ℕ → R → S} (h : ∀ (n : ℕ), f n 0 = 0) (n : ℕ) (w : p.nat_degree < n) : p.sum f = (finset.range n).sum (λ (a : ℕ), f a (p.coeff a))
theorem is_dedekind_domain.height_one_spectrum.valuation_of_mk' {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] {K : Type u_2} [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) {r : R} {s : ↥(non_zero_divisors R)} : ⇑(v.valuation) (is_localization.mk' K r s) = ⇑(v.int_valuation) r / ⇑(v.int_valuation) ↑s
theorem formal_multilinear_series.le_radius_of_bound_nnreal {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) (C : nnreal) {r : nnreal} (h : ∀ (n : ℕ), ∥p n∥₊ * r ^ n ≤ C) : ↑r ≤ p.radius
theorem covariant.monotone_of_const {M : Type u_1} {N : Type u_2} {μ : M → N → N} [preorder N] [covariant_class M N μ has_le.le] (m : M) : monotone (μ m)
theorem exists_mem_Ioc_zpow {α : Type u_1} [linear_ordered_field α] [archimedean α] {x y : α} (hx : 0 < x) (hy : 1 < y) : ∃ (n : ℤ), x ∈ set.Ioc (y ^ n) (y ^ (n + 1))
theorem submonoid.localization_map.mul_inv_right {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {f : M →* N} (h : ∀ (y : ↥S), is_unit (⇑f ↑y)) (y : ↥S) (w z : N) : z = w * ↑(⇑(is_unit.lift_right (f.restrict S) h) y)⁻¹ ↔ z * ⇑f ↑y = w
theorem is_add_monoid_hom.comp {α : Type u} {β : Type v} [add_zero_class α] [add_zero_class β] {f : α → β} (hf : is_add_monoid_hom f) {γ : Type u_1} [add_zero_class γ] {g : β → γ} (hg : is_add_monoid_hom g) : is_add_monoid_hom (g ∘ f)
theorem is_Sup_finite_compact.well_founded (α : Type u_1) [complete_lattice α] : complete_lattice.is_Sup_finite_compact α → well_founded gt
theorem not_is_right_regular_zero {R : Type u_1} [mul_zero_class R] [nR : nontrivial R] : ¬is_right_regular 0
theorem is_compact.induction_on {α : Type u} [topological_space α] {s : set α} (hs : is_compact s) {p : set α → Prop} (he : p ∅) (hmono : ∀ ⦃s t : set α⦄, s ⊆ t → p t → p s) (hunion : ∀ ⦃s t : set α⦄, p s → p t → p (s ∪ t)) (hnhds : ∀ (x : α), x ∈ s → (∃ (t : set α) (H : t ∈ nhds_within x s), p t)) : p s
theorem is_group_hom.map_inv {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) (a : α) : f a⁻¹ = (f a)⁻¹
theorem category_theory.abelian.pseudoelement.pseudo_apply_aux {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P ⟶ Q) (a b : category_theory.over P) : a ≈ b → category_theory.abelian.app f a ≈ category_theory.abelian.app f b
theorem cont_mdiff_within_at_iff_cont_mdiff_on_nhds {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M → M'} {s : set M} {x : M} {n : ℕ} : cont_mdiff_within_at I I' ↑n f s x ↔ ∃ (u : set M) (H_1 : u ∈ nhds_within x (has_insert.insert x s)), cont_mdiff_on I I' ↑n f u
theorem generate_from_prod {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] : measurable_space.generate_from (set.image2 has_set_prod.prod {s : set α | measurable_set s} {t : set β | measurable_set t}) = prod.measurable_space
theorem has_fpower_series_on_ball.exchange_radius {𝕜 : Type u_1} {E : Type u_2} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] {p₁ p₂ : formal_multilinear_series 𝕜 𝕜 E} {f : 𝕜 → E} {r₁ r₂ : ennreal} {x : 𝕜} (h₁ : has_fpower_series_on_ball f p₁ x r₁) (h₂ : has_fpower_series_on_ball f p₂ x r₂) : has_fpower_series_on_ball f p₁ x r₂
theorem measure_theory.simple_func.exists_upper_semicontinuous_le_lintegral_le {α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] {μ : measure_theory.measure α} [μ.weakly_regular] (f : measure_theory.simple_func α nnreal) (int_f : ∫⁻ (x : α), ↑(⇑f x) ∂μ ≠ ⊤) {ε : ennreal} (ε0 : ε ≠ 0) : ∃ (g : α → nnreal), (∀ (x : α), g x ≤ ⇑f x) ∧ upper_semicontinuous g ∧ ∫⁻ (x : α), ↑(⇑f x) ∂μ ≤ ∫⁻ (x : α), ↑(g x) ∂μ + ε
theorem polynomial.degree_le_of_nat_degree_le {R : Type u} [semiring R] {p : polynomial R} {n : ℕ} : p.nat_degree ≤ n → p.degree ≤ ↑n
theorem fintype.exists_card_fiber_le_of_card_le_mul {α : Type u} {β : Type v} [decidable_eq β] [fintype α] [fintype β] (f : α → β) {n : ℕ} [nonempty β] (hn : fintype.card α ≤ fintype.card β * n) : ∃ (y : β), (finset.filter (λ (x : α), f x = y) finset.univ).card ≤ n
theorem Top.subpresheaf_to_Types.is_sheaf {X : Top} {T : ↥X → Type v} (P : Top.local_predicate T) : (Top.subpresheaf_to_Types P.to_prelocal_predicate).is_sheaf
theorem orthonormal.exists_hilbert_basis_extension {𝕜 : Type u_2} [is_R_or_C 𝕜] {E : Type u_3} [inner_product_space 𝕜 E] [cplt : complete_space E] {s : set E} (hs : orthonormal 𝕜 coe) : ∃ (w : set E) (b : hilbert_basis ↥w 𝕜 E), s ⊆ w ∧ ⇑b = coe
theorem exists_extension_norm_eq {𝕜 : Type u_1} [is_R_or_C 𝕜] {F : Type u_2} [semi_normed_group F] [normed_space 𝕜 F] (p : subspace 𝕜 F) (f : ↥p →L[𝕜] 𝕜) : ∃ (g : F →L[𝕜] 𝕜), (∀ (x : ↥p), ⇑g ↑x = ⇑f x) ∧ ∥g∥ = ∥f∥
theorem mv_polynomial.prod_X_add_C_eq_sum_esymm {R : Type u_1} [comm_semiring R] (σ : Type u_2) [fintype σ] : finset.univ.prod (λ (i : σ), ⇑polynomial.C (mv_polynomial.X i) + polynomial.X) = (finset.range (fintype.card σ + 1)).sum (λ (j : ℕ), ⇑polynomial.C (mv_polynomial.esymm σ R j) * polynomial.X ^ (fintype.card σ - j))
theorem category_theory.is_pushout.paste_horiz {C : Type u₁} [category_theory.category C] {X₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₁₂ : X₁₂ ⟶ X₁₃} {h₂₁ : X₂₁ ⟶ X₂₂} {h₂₂ : X₂₂ ⟶ X₂₃} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₁₃ : X₁₃ ⟶ X₂₃} (s : category_theory.is_pushout h₁₁ v₁₁ v₁₂ h₂₁) (t : category_theory.is_pushout h₁₂ v₁₂ v₁₃ h₂₂) : category_theory.is_pushout (h₁₁ ≫ h₁₂) v₁₁ v₁₃ (h₂₁ ≫ h₂₂)
theorem continuous_Inf_dom₂ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {f : α → β → γ} {tas : set (topological_space α)} {tbs : set (topological_space β)} {ta : topological_space α} {tb : topological_space β} {tc : topological_space γ} (ha : ta ∈ tas) (hb : tb ∈ tbs) (hf : continuous (λ (p : α × β), f p.fst p.snd)) : continuous (λ (p : α × β), f p.fst p.snd)
theorem submonoid.supr_induction {M : Type u_1} [mul_one_class M] {ι : Sort u_2} (S : ι → submonoid M) {C : M → Prop} {x : M} (hx : x ∈ ⨆ (i : ι), S i) (hp : ∀ (i : ι) (x : M), x ∈ S i → C x) (h1 : C 1) (hmul : ∀ (x y : M), C x → C y → C (x * y)) : C x
theorem sylow.card_eq_multiplicity {G : Type u} [group G] [fintype G] {p : ℕ} [hp : fact (nat.prime p)] (P : sylow p G) : fintype.card ↥P = p ^ ⇑((fintype.card G).factorization) p
theorem exp_neg_inv_glue.f_aux_deriv_zero (n : ℕ) : has_deriv_at (exp_neg_inv_glue.f_aux n) 0 0
theorem mul_add_eq_mul_add_iff_sub_mul_add_eq {α : Type u} [non_unital_non_assoc_ring α] {a b c d e : α} : a * e + c = b * e + d ↔ (a - b) * e + c = d
theorem witt_vector.is_poly₂.comp_right {p : ℕ} {g : Π ⦃R : Type u_1⦄ [_inst_3 : comm_ring R], witt_vector p R → witt_vector p R → witt_vector p R} {f : Π ⦃R : Type u_1⦄ [_inst_3 : comm_ring R], witt_vector p R → witt_vector p R} (hg : witt_vector.is_poly₂ p g) (hf : witt_vector.is_poly p f) : witt_vector.is_poly₂ p (λ (R : Type u_1) (_Rcr : comm_ring R) (x y : witt_vector p R), g x (f y))
theorem ordinal.fp_unbounded {f : ordinal → ordinal} (H : ordinal.is_normal f) : set.unbounded has_lt.lt (function.fixed_points f)
theorem measurable_of_tendsto_nnreal' {α : Type u_1} [measurable_space α] {ι : Type u_2} {f : ι → α → nnreal} {g : α → nnreal} (u : filter ι) [u.ne_bot] [u.is_countably_generated] (hf : ∀ (i : ι), measurable (f i)) (lim : filter.tendsto f u (nhds g)) : measurable g
theorem strict_mono_on.continuous_at_of_exists_between {α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_on f s) (hs : s ∈ nhds a) (hfs_l : ∀ (b : β), b < f a → (∃ (c : α) (H : c ∈ s), f c ∈ set.Ico b (f a))) (hfs_r : ∀ (b : β), b > f a → (∃ (c : α) (H : c ∈ s), f c ∈ set.Ioc (f a) b)) : continuous_at f a
theorem metric.bounded_bUnion {α : Type u} {β : Type v} [pseudo_metric_space α] {I : set β} {s : β → set α} (H : I.finite) : metric.bounded (⋃ (i : β) (H : i ∈ I), s i) ↔ ∀ (i : β), i ∈ I → metric.bounded (s i)
theorem metric.bounded.measure_lt_top {α : Type u_1} {m0 : measurable_space α} [pseudo_metric_space α] [proper_space α] {μ : measure_theory.measure α} [measure_theory.is_finite_measure_on_compacts μ] ⦃s : set α⦄ (hs : metric.bounded s) : ⇑μ s < ⊤
theorem has_lt.lt.lf {x y : pgame} (h : x < y) : x.lf y
theorem exists_maximal_of_chains_bounded {α : Type u_1} {r : α → α → Prop} (h : ∀ (c : set α), is_chain r c → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) (trans : ∀ {a b c : α}, r a b → r b c → r a c) : ∃ (m : α), ∀ (a : α), r m a → r a m
theorem set.eq_on.closure {α : Type u} {β : Type v} [topological_space α] [topological_space β] [t2_space α] {s : set β} {f g : β → α} (h : set.eq_on f g s) (hf : continuous f) (hg : continuous g) : set.eq_on f g (closure s)
theorem emetric.inf_edist_le_inf_edist_add_edist {α : Type u} [pseudo_emetric_space α] {x y : α} {s : set α} : emetric.inf_edist x s ≤ emetric.inf_edist y s + has_edist.edist x y
theorem add_con.neg {M : Type u_1} [add_group M] (c : add_con M) {w x : M} : ⇑c w x → ⇑c (-w) (-x)
theorem direct_sum.add_hom_ext' {ι : Type v} [dec_ι : decidable_eq ι] {β : ι → Type w} [Π (i : ι), add_comm_monoid (β i)] {γ : Type u_1} [add_monoid γ] ⦃f g : direct_sum ι (λ (i : ι), β i) →+ γ⦄ (H : ∀ (i : ι), f.comp (direct_sum.of (λ (i : ι), β i) i) = g.comp (direct_sum.of β i)) : f = g
theorem is_right_regular.pow {R : Type u_1} {a : R} [monoid R] (n : ℕ) (rra : is_right_regular a) : is_right_regular (a ^ n)
theorem convex.interior {E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) : convex 𝕜 (interior s)
theorem function.embedding.min_injective {ι : Type u} (β : ι → Type v) [I : nonempty ι] : ∃ (i : ι), nonempty (Π (j : ι), β i ↪ β j)
theorem isometry.injective {β : Type v} [pseudo_emetric_space β] {α : Type u} [emetric_space α] {f : α → β} (h : isometry f) : function.injective f
theorem is_local_extr_on.exists_multipliers_of_has_strict_fderiv_at {E : Type u_1} [normed_group E] [normed_space ℝ E] [complete_space E] {φ : E → ℝ} {x₀ : E} {φ' : E →L[ℝ] ℝ} {ι : Type u_2} [fintype ι] {f : ι → E → ℝ} {f' : ι → (E →L[ℝ] ℝ)} (hextr : is_local_extr_on φ {x : E | ∀ (i : ι), f i x = f i x₀} x₀) (hf' : ∀ (i : ι), has_strict_fderiv_at (f i) (f' i) x₀) (hφ' : has_strict_fderiv_at φ φ' x₀) : ∃ (Λ : ι → ℝ) (Λ₀ : ℝ), (Λ, Λ₀) ≠ 0 ∧ finset.univ.sum (λ (i : ι), Λ i • f' i) + Λ₀ • φ' = 0
theorem measure_theory.measure.eq_with_density_rn_deriv {α : Type u_1} {m : measurable_space α} {μ ν s : measure_theory.measure α} {f : α → ennreal} (hf : measurable f) (hs : s.mutually_singular ν) (hadd : μ = s + ν.with_density f) : ν.with_density f = ν.with_density (μ.rn_deriv ν)
theorem orthonormal.oangle_neg_left_eq_neg_right {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x y : V) : hb.oangle (-x) y = hb.oangle x (-y)
theorem cont_diff_on_snd {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : with_top ℕ} {s : set (E × F)} : cont_diff_on 𝕜 n prod.snd s
theorem mem_closure_iff_ultrafilter {α : Type u} [topological_space α] {s : set α} {x : α} : x ∈ closure s ↔ ∃ (u : ultrafilter α), s ∈ u ∧ ↑u ≤ nhds x
theorem real.tendsto_sum_pi_div_four  : filter.tendsto (λ (k : ℕ), (finset.range k).sum (λ (i : ℕ), (-1) ^ i / (2 * ↑i + 1))) filter.at_top (nhds (real.pi / 4))
theorem monovary.sum_comp_perm_smul_lt_sum_smul_iff {ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {σ : equiv.perm ι} {f : ι → α} {g : ι → β} [fintype ι] (hfg : monovary f g) : finset.univ.sum (λ (i : ι), f (⇑σ i) • g i) < finset.univ.sum (λ (i : ι), f i • g i) ↔ ¬monovary (f ∘ ⇑σ) g
theorem chart_at_self_eq {H : Type u_1} [topological_space H] {x : H} : charted_space.chart_at H x = local_homeomorph.refl H
theorem sum_four_sq_mul_sum_four_sq {R : Type u_1} [comm_ring R] {x₁ x₂ x₃ x₄ y₁ y₂ y₃ y₄ : R} : (x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2) * (y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2) = (x₁ * y₁ - x₂ * y₂ - x₃ * y₃ - x₄ * y₄) ^ 2 + (x₁ * y₂ + x₂ * y₁ + x₃ * y₄ - x₄ * y₃) ^ 2 + (x₁ * y₃ - x₂ * y₄ + x₃ * y₁ + x₄ * y₂) ^ 2 + (x₁ * y₄ + x₂ * y₃ - x₃ * y₂ + x₄ * y₁) ^ 2
theorem is_add_left_regular_of_add_eq_zero {R : Type u_1} {a b : R} [add_monoid R] (h : b + a = 0) : is_add_left_regular a
theorem is_add_torsion.exponent_exists {G : Type u_1} [add_group G] (tG : add_monoid.is_torsion G) (bounded : (set.range (λ (g : G), add_order_of g)).finite) : add_monoid.exponent_exists G
theorem is_least.bdd_below {α : Type u} [preorder α] {s : set α} {a : α} (h : is_least s a) : bdd_below s
theorem perfection_map.of (p : ℕ) [fact (nat.prime p)] (R : Type u₁) [comm_semiring R] [char_p R p] : perfection_map p (perfection.coeff R p 0)
theorem category_theory.subobject_simple_iff_is_atom {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (Y : category_theory.subobject X) : category_theory.simple ↑Y ↔ is_atom Y
theorem interval_integral.integral_sub_integral_sub_linear_is_o_of_tendsto_ae_right {ι : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {c : E} {lb lb' : filter ℝ} {lt : filter ι} {a b : ℝ} {u v : ι → ℝ} [interval_integral.FTC_filter b lb lb'] (hab : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f lb' measure_theory.measure_space.volume) (hf : filter.tendsto f (lb' ⊓ measure_theory.measure_space.volume.ae) (nhds c)) (hu : filter.tendsto u lt lb) (hv : filter.tendsto v lt lb) : (λ (t : ι), ((∫ (x : ℝ) in a..v t, f x) - ∫ (x : ℝ) in a..u t, f x) - (v t - u t) • c) =o[lt] (v - u)
theorem canonically_ordered_comm_semiring.zero_lt_one {α : Type u} [canonically_ordered_comm_semiring α] [nontrivial α] : 0 < 1
theorem submodule.closed_of_finite_dimensional {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {E : Type v} [normed_group E] [normed_space 𝕜 E] [complete_space 𝕜] (s : submodule 𝕜 E) [finite_dimensional 𝕜 ↥s] : is_closed ↑s
theorem orthonormal.rotation_symm {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (θ : real.angle) : (hb.rotation θ).symm = hb.rotation (-θ)
theorem euclidean_geometry.affine_span_of_orthocentric_system {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : set P} (ho : euclidean_geometry.orthocentric_system s) {p : fin 3 → P} (hps : set.range p ⊆ s) (hpi : function.injective p) : affine_span ℝ (set.range p) = affine_span ℝ s
theorem sub_eq_zero_of_eq {G : Type u_2} [add_group G] {a b : G} : a = b → a - b = 0
theorem orthonormal.orthonormal_of_forall_eq_or_eq_neg {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {v w : ι → E} (hv : orthonormal 𝕜 v) (hw : ∀ (i : ι), w i = v i ∨ w i = -v i) : orthonormal 𝕜 w
theorem real.sinh_bijective  : function.bijective real.sinh
theorem inner_product_space.is_self_adjoint.orthogonal_family_eigenspaces {𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] {T : E →ₗ[𝕜] E} (hT : inner_product_space.is_self_adjoint T) : orthogonal_family 𝕜 (λ (μ : 𝕜), (module.End.eigenspace T μ).subtypeₗᵢ)
theorem ne.ssubset_of_subset {α : Type u} [has_subset α] [has_ssubset α] [is_nonstrict_strict_order α has_subset.subset has_ssubset.ssubset] {a b : α} [is_antisymm α has_subset.subset] (h₁ : a ≠ b) (h₂ : a ⊆ b) : a ⊂ b
theorem zmod.euler_criterion (p : ℕ) [fact (nat.prime p)] {a : zmod p} (ha : a ≠ 0) : is_square a ↔ a ^ (p / 2) = 1
theorem is_pi_system_pi {ι : Type u_1} {α : ι → Type u_3} [Π (i : ι), measurable_space (α i)] : is_pi_system (set.univ.pi '' set.univ.pi (λ (i : ι), {s : set (α i) | measurable_set s}))
theorem bdd_above_insert {γ : Type w} [semilattice_sup γ] (a : γ) {s : set γ} : bdd_above (has_insert.insert a s) ↔ bdd_above s
theorem finset.le_sum_card_inter {α : Type u_2} [decidable_eq α] {s : finset α} {B : finset (finset α)} {n : ℕ} (h : ∀ (a : α), a ∈ s → n ≤ (finset.filter (has_mem.mem a) B).card) : s.card * n ≤ B.sum (λ (t : finset α), (s ∩ t).card)
theorem strict_mono_on.continuous_at_right_of_image_mem_nhds_within {α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_on f s) (hs : s ∈ nhds_within a (set.Ici a)) (hfs : f '' s ∈ nhds_within (f a) (set.Ici (f a))) : continuous_within_at f (set.Ici a) a
theorem euclidean_geometry.reflection_orthogonal_vadd {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} [nonempty ↥s] [complete_space ↥(s.direction)] {p : P} (hp : p ∈ s) {v : V} (hv : v ∈ (s.direction)ᗮ) : ⇑(euclidean_geometry.reflection s) (v +ᵥ p) = -v +ᵥ p
theorem ring_hom.ker_is_maximal_of_surjective {R : Type u_1} {K : Type u_2} [ring R] [field K] (f : R →+* K) (hf : function.surjective ⇑f) : f.ker.is_maximal
theorem linear_map.finite_dimensional_of_surjective {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {V₂ : Type v'} [add_comm_group V₂] [module K V₂] [h : finite_dimensional K V] (f : V →ₗ[K] V₂) (hf : f.range = ⊤) : finite_dimensional K V₂
theorem analytic_on.iterated_deriv {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {s : set 𝕜} [complete_space F] (h : analytic_on 𝕜 f s) (n : ℕ) : analytic_on 𝕜 (deriv^[n] f) s
theorem normed_group_hom.mk_normed_group_hom_norm_le {V₁ : Type u_2} {V₂ : Type u_3} [semi_normed_group V₁] [semi_normed_group V₂] (f : V₁ →+ V₂) {C : ℝ} (hC : 0 ≤ C) (h : ∀ (x : V₁), ∥⇑f x∥ ≤ C * ∥x∥) : ∥f.mk_normed_group_hom C h∥ ≤ C
theorem seminorm.absorbent_ball_zero {𝕜 : Type u_3} {E : Type u_4} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] (p : seminorm 𝕜 E) {r : ℝ} (hr : 0 < r) : absorbent 𝕜 (p.ball 0 r)
theorem neg_one_pow_two {R : Type u₁} [monoid R] [has_distrib_neg R] : (-1) ^ 2 = 1
theorem inner_eq_norm_mul_iff_of_norm_one {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x y : E} (hx : ∥x∥ = 1) (hy : ∥y∥ = 1) : has_inner.inner x y = 1 ↔ x = y
theorem edist_mem_uniformity {α : Type u} [pseudo_emetric_space α] {ε : ennreal} (ε0 : 0 < ε) : {p : α × α | has_edist.edist p.fst p.snd < ε} ∈ uniformity α
theorem has_le.le.trans_lt' {α : Type u} [preorder α] {a b c : α} : b ≤ c → a < b → a < c
theorem orthonormal.oangle_smul_right_of_pos {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x y : V) {r : ℝ} (hr : 0 < r) : hb.oangle x (r • y) = hb.oangle x y
theorem add_submonoid.localization_map.lift_left_inverse {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {k : S.localization_map P} (z : N) : ⇑(k.lift _) (⇑(f.lift _) z) = z
theorem probability_theory.strong_law_aux7 {Ω : Type u_1} [measure_theory.measure_space Ω] [measure_theory.is_probability_measure measure_theory.measure_space.volume] (X : ℕ → Ω → ℝ) (hint : measure_theory.integrable (X 0) measure_theory.measure_space.volume) (hindep : pairwise (λ (i j : ℕ), probability_theory.indep_fun (X i) (X j) measure_theory.measure_space.volume)) (hident : ∀ (i : ℕ), probability_theory.ident_distrib (X i) (X 0) measure_theory.measure_space.volume measure_theory.measure_space.volume) (hnonneg : ∀ (i : ℕ) (ω : Ω), 0 ≤ X i ω) : ∀ᵐ (ω : Ω), filter.tendsto (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), X i ω) / ↑n) filter.at_top (nhds (∫ (a : Ω), X 0 a))
theorem measure_theory.adapted.prog_measurable_of_continuous {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} [topological_space β] [preorder ι] {u : ι → α → β} {f : measure_theory.filtration ι m} [topological_space ι] [topological_space.metrizable_space ι] [measurable_space ι] [topological_space.second_countable_topology ι] [opens_measurable_space ι] [topological_space.metrizable_space β] (h : measure_theory.adapted f u) (hu_cont : ∀ (x : α), continuous (λ (i : ι), u i x)) : measure_theory.prog_measurable f u
theorem euclidean_geometry.orthogonal_projection_mem_orthogonal {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ℝ P) [nonempty ↥s] [complete_space ↥(s.direction)] (p : P) : ↑(⇑(euclidean_geometry.orthogonal_projection s) p) ∈ affine_subspace.mk' p (s.direction)ᗮ
theorem local_homeomorph.is_O_with_congr {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {E : Type u_3} [has_norm E] {F : Type u_4} [has_norm F] (e : local_homeomorph α β) {b : β} (hb : b ∈ e.to_local_equiv.target) {f : β → E} {g : β → F} {C : ℝ} : asymptotics.is_O_with C (nhds b) f g ↔ asymptotics.is_O_with C (nhds (⇑(e.symm) b)) (f ∘ ⇑e) (g ∘ ⇑e)
theorem measure_theory.simple_func.integral_eq_sum_of_subset {α : Type u_1} {F : Type u_3} [normed_group F] [normed_space ℝ F] {m : measurable_space α} {μ : measure_theory.measure α} [decidable_pred (λ (x : F), x ≠ 0)] {f : measure_theory.simple_func α F} {s : finset F} (hs : finset.filter (λ (x : F), x ≠ 0) f.range ⊆ s) : measure_theory.simple_func.integral μ f = s.sum (λ (x : F), (⇑μ (⇑f ⁻¹' {x})).to_real • x)
theorem same_ray.nonneg_smul_right {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} {r : R} (h : same_ray R x y) (hr : 0 ≤ r) : same_ray R x (r • y)
theorem add_subgroup.closure_induction'' {G : Type u_1} [add_group G] {k : set G} {p : G → Prop} {x : G} (h : x ∈ add_subgroup.closure k) (Hk : ∀ (x : G), x ∈ k → p x) (Hk_inv : ∀ (x : G), x ∈ k → p (-x)) (H1 : p 0) (Hmul : ∀ (x y : G), p x → p y → p (x + y)) : p x
theorem intermediate_field.multiset_sum_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) (m : multiset L) : (∀ (a : L), a ∈ m → a ∈ S) → m.sum ∈ S
theorem convex_on_iff_slope_mono_adjacent {𝕜 : Type u_1} [linear_ordered_field 𝕜] {s : set 𝕜} {f : 𝕜 → 𝕜} : convex_on 𝕜 s f ↔ convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f y - f x) / (y - x) ≤ (f z - f y) / (z - y)
theorem orthonormal.oangle_rotation_self_right {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x : V} (hx : x ≠ 0) (θ : real.angle) : hb.oangle x (⇑(hb.rotation θ) x) = θ
theorem disjoint_or_subset_of_clopen {α : Type u} [topological_space α] {s t : set α} (hs : is_preconnected s) (ht : is_clopen t) : disjoint s t ∨ s ⊆ t
theorem has_ftaylor_series_up_to_on.comp_continuous_linear_map {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {s : set E} {f : E → F} {n : with_top ℕ} {p : E → formal_multilinear_series 𝕜 E F} (hf : has_ftaylor_series_up_to_on n f p s) (g : G →L[𝕜] E) : has_ftaylor_series_up_to_on n (f ∘ ⇑g) (λ (x : G) (k : ℕ), (p (⇑g x) k).comp_continuous_linear_map (λ (_x : fin k), g)) (⇑g ⁻¹' s)
theorem localization_algebra_injective {R : Type u_1} [comm_ring R] {M : submonoid R} {S : Type u_2} [comm_ring S] [algebra R S] (Rₘ : Type u_4) (Sₘ : Type u_5) [comm_ring Rₘ] [comm_ring Sₘ] [algebra R Rₘ] [is_localization M Rₘ] [algebra S Sₘ] [is_localization (algebra.algebra_map_submonoid S M) Sₘ] (hRS : function.injective ⇑(algebra_map R S)) (hM : algebra.algebra_map_submonoid S M ≤ non_zero_divisors S) : function.injective ⇑(algebra_map Rₘ Sₘ)
theorem measure_theory.is_add_fundamental_domain.vadd_invariant_measure_map {G : Type u_1} [add_group G] [measurable_space G] [topological_space G] [topological_add_group G] [borel_space G] {μ : measure_theory.measure G} {Γ : add_subgroup G} {𝓕 : set G} (h𝓕 : measure_theory.is_add_fundamental_domain ↥(Γ.opposite) 𝓕 μ) [encodable ↥Γ] [measurable_space (G ⧸ Γ)] [borel_space (G ⧸ Γ)] [μ.is_add_left_invariant] [μ.is_add_right_invariant] : measure_theory.vadd_invariant_measure G (G ⧸ Γ) (measure_theory.measure.map quotient_add_group.mk (μ.restrict 𝓕))
theorem submodule.torsion'_is_torsion' {R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] (S : Type u_3) [comm_monoid S] [distrib_mul_action S M] [smul_comm_class S R M] : module.is_torsion' ↥(submodule.torsion' R M S) S
theorem is_local_max_on.has_fderiv_within_at_eq_zero {E : Type u} [normed_group E] [normed_space ℝ E] {f : E → ℝ} {a : E} {f' : E →L[ℝ] ℝ} {s : set E} (h : is_local_max_on f s a) (hf : has_fderiv_within_at f f' s a) {y : E} (hy : y ∈ pos_tangent_cone_at s a) (hy' : -y ∈ pos_tangent_cone_at s a) : ⇑f' y = 0
theorem finset.prod_partition {β : Type u} {α : Type v} {s : finset α} {f : α → β} [comm_monoid β] (R : setoid α) [decidable_rel setoid.r] : s.prod (λ (x : α), f x) = (finset.image quotient.mk s).prod (λ (xbar : quotient R), (finset.filter (λ (y : α), ⟦y⟧ = xbar) s).prod (λ (y : α), f y))
theorem mul_hom.srange_top_of_surjective {M : Type u_1} [has_mul M] {N : Type u_2} [has_mul N] (f : M →ₙ* N) (hf : function.surjective ⇑f) : f.srange = ⊤
theorem measure_theory.integral_image_eq_integral_abs_det_fderiv_smul {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] [normed_group F] [normed_space ℝ F] {s : set E} {f : E → E} {f' : E → (E →L[ℝ] E)} [measurable_space E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] [complete_space F] (hs : measurable_set s) (hf' : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) (g : E → F) : ∫ (x : E) in f '' s, g x ∂μ = ∫ (x : E) in s, |(f' x).det| • g (f x) ∂μ
theorem exists_deriv_eq_zero (f : ℝ → ℝ) {a b : ℝ} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hfI : f a = f b) : ∃ (c : ℝ) (H : c ∈ set.Ioo a b), deriv f c = 0
theorem has_binary_products_of_terminal_and_pullbacks (C : Type u) [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_pullbacks C] : category_theory.limits.has_binary_products C
theorem polynomial.cyclotomic'_ne_zero (n : ℕ) (R : Type u_1) [comm_ring R] [is_domain R] : polynomial.cyclotomic' n R ≠ 0
theorem bdd_above.inter_of_left {α : Type u} [preorder α] {s t : set α} (h : bdd_above s) : bdd_above (s ∩ t)
theorem nhds_le_uniformity {α : Type u_1} [uniform_space α] (x : α) : nhds (x, x) ≤ uniformity α
theorem is_localization.map_map {R : Type u_1} [comm_semiring R] {M : submonoid R} {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] {g : R →+* P} {T : submonoid P} {Q : Type u_4} [comm_semiring Q] (hy : M ≤ submonoid.comap ↑g T) [algebra P Q] [is_localization T Q] {A : Type u_5} [comm_semiring A] {U : submonoid A} {W : Type u_6} [comm_semiring W] [algebra A W] [is_localization U W] {l : P →+* A} (hl : T ≤ submonoid.comap ↑l U) (x : S) : ⇑(is_localization.map W l hl) (⇑(is_localization.map Q g hy) x) = ⇑(is_localization.map W (l.comp g) _) x
theorem vitali_family.measure_lim_ratio_meas_top {α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {ρ : measure_theory.measure α} [measure_theory.is_locally_finite_measure ρ] (hρ : ρ.absolutely_continuous μ) : ⇑μ {x : α | v.lim_ratio_meas hρ x = ⊤} = 0
theorem set.mem_finset_prod {α : Type u_2} {ι : Type u_5} [comm_monoid α] (t : finset ι) (f : ι → set α) (a : α) : a ∈ t.prod (λ (i : ι), f i) ↔ ∃ (g : ι → α) (hg : ∀ {i : ι}, i ∈ t → g i ∈ f i), t.prod (λ (i : ι), g i) = a
theorem spectrum.exp_mem_exp {𝕜 : Type u_1} {A : Type u_2} [is_R_or_C 𝕜] [normed_ring A] [normed_algebra 𝕜 A] [complete_space A] (a : A) {z : 𝕜} (hz : z ∈ spectrum 𝕜 a) : exp 𝕜 z ∈ spectrum 𝕜 (exp 𝕜 a)
theorem polynomial.is_eisenstein_at.irreducible {R : Type u} [comm_ring R] [is_domain R] {𝓟 : ideal R} {f : polynomial R} (hf : f.is_eisenstein_at 𝓟) (hprime : 𝓟.is_prime) (hu : f.is_primitive) (hfd0 : 0 < f.nat_degree) : irreducible f
theorem pgame.numeric_nat (n : ℕ) : ↑n.numeric
theorem add_submonoid.localization_map.add_neg {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {f : M →+ N} (h : ∀ (y : ↥S), is_add_unit (⇑f ↑y)) {x₁ x₂ : M} {y₁ y₂ : ↥S} : ⇑f x₁ + ↑-⇑(is_add_unit.lift_right (f.restrict S) h) y₁ = ⇑f x₂ + ↑-⇑(is_add_unit.lift_right (f.restrict S) h) y₂ ↔ ⇑f (x₁ + ↑y₂) = ⇑f (x₂ + ↑y₁)
theorem measure_theory.measure.add_haar_affine_subspace {E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (s : affine_subspace ℝ E) (hs : s ≠ ⊤) : ⇑μ ↑s = 0
theorem has_ftaylor_series_up_to_on_succ_iff_left {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {p : E → formal_multilinear_series 𝕜 E F} {n : ℕ} : has_ftaylor_series_up_to_on (↑n + 1) f p s ↔ has_ftaylor_series_up_to_on ↑n f p s ∧ (∀ (x : E), x ∈ s → has_fderiv_within_at (λ (y : E), p y n) (p x n.succ).curry_left s x) ∧ continuous_on (λ (x : E), p x (n + 1)) s
theorem exp_neg_inv_glue.cont_diff {n : with_top ℕ} : cont_diff ℝ n exp_neg_inv_glue
theorem ideal.eq_jacobson_iff_not_mem {R : Type u} [ring R] {I : ideal R} : I.jacobson = I ↔ ∀ (x : R), x ∉ I → (∃ (M : ideal R), (I ≤ M ∧ M.is_maximal) ∧ x ∉ M)
theorem orientation.oangle_eq_iff_eq_norm_div_norm_smul_rotation_of_ne_zero {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : real.angle) : o.oangle x y = θ ↔ y = (∥y∥ / ∥x∥) • ⇑(o.rotation θ) x
theorem setoid.ker_iff_mem_preimage {α : Type u_1} {β : Type u_2} {f : α → β} {x y : α} : (setoid.ker f).rel x y ↔ x ∈ f ⁻¹' {f y}
theorem padic_val_int.one {p : ℕ} : padic_val_int p 1 = 0
theorem algebra.power_basis.norm_gen_eq_prod_roots {S : Type u_2} [comm_ring S] {K : Type u_4} {F : Type u_6} [field K] [field F] [algebra K F] [algebra K S] (pb : power_basis K S) (hf : polynomial.splits (algebra_map K F) (minpoly K pb.gen)) : ⇑(algebra_map K F) (⇑(algebra.norm K) pb.gen) = (polynomial.map (algebra_map K F) (minpoly K pb.gen)).roots.prod
theorem ordinal.sub_nonempty {a b : ordinal} : {o : ordinal | a ≤ b + o}.nonempty
theorem smul_closed_unit_ball_of_nonneg {E : Type u_2} [normed_group E] [normed_space ℝ E] {r : ℝ} (hr : 0 ≤ r) : r • metric.closed_ball 0 1 = metric.closed_ball 0 r
theorem probability_theory.strong_law_ae {Ω : Type u_1} [measure_theory.measure_space Ω] [measure_theory.is_probability_measure measure_theory.measure_space.volume] (X : ℕ → Ω → ℝ) (hint : measure_theory.integrable (X 0) measure_theory.measure_space.volume) (hindep : pairwise (λ (i j : ℕ), probability_theory.indep_fun (X i) (X j) measure_theory.measure_space.volume)) (hident : ∀ (i : ℕ), probability_theory.ident_distrib (X i) (X 0) measure_theory.measure_space.volume measure_theory.measure_space.volume) : ∀ᵐ (ω : Ω), filter.tendsto (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), X i ω) / ↑n) filter.at_top (nhds (∫ (a : Ω), X 0 a))
theorem euclidean_geometry.orthogonal_projection_vadd_smul_vsub_orthogonal_projection {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} [nonempty ↥s] [complete_space ↥(s.direction)] {p1 : P} (p2 : P) (r : ℝ) (hp : p1 ∈ s) : ⇑(euclidean_geometry.orthogonal_projection s) (r • (p2 -ᵥ ↑(⇑(euclidean_geometry.orthogonal_projection s) p2)) +ᵥ p1) = ⟨p1, hp⟩
theorem measure_theory.measure.restrict_map {α : Type u_1} {β : Type u_2} {m0 : measurable_space α} [measurable_space β] {μ : measure_theory.measure α} {f : α → β} (hf : measurable f) {s : set β} (hs : measurable_set s) : (measure_theory.measure.map f μ).restrict s = measure_theory.measure.map f (μ.restrict (f ⁻¹' s))
theorem affine_map.coe_id (k : Type u_1) {V1 : Type u_2} (P1 : Type u_3) [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] : ⇑(affine_map.id k P1) = id
theorem simple_graph.max_degree_le_of_forall_degree_le {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (k : ℕ) (h : ∀ (v : V), G.degree v ≤ k) : G.max_degree ≤ k
theorem local_homeomorph.eq_on_source.symm' {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {e e' : local_homeomorph α β} (h : e ≈ e') : e.symm ≈ e'.symm
theorem finite_dimensional_sup {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E1 E2 : intermediate_field K L) (h1 : finite_dimensional K ↥E1) (h2 : finite_dimensional K ↥E2) : finite_dimensional K ↥(E1 ⊔ E2)
theorem inner_left_of_mem_orthogonal_singleton {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (u : E) {v : E} (hv : v ∈ (submodule.span 𝕜 {u})ᗮ) : has_inner.inner v u = 0
theorem polynomial.cyclotomic_two (R : Type u_1) [ring R] : polynomial.cyclotomic 2 R = polynomial.X + 1
theorem power_series.order_mul {R : Type u_1} [comm_ring R] [is_domain R] (φ ψ : power_series R) : (φ * ψ).order = φ.order + ψ.order
theorem left.mul_lt_one_of_lt_of_le {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b ≤ 1) : a * b < 1
theorem neg_concave_on_iff {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [ordered_add_comm_group β] [has_scalar 𝕜 E] [module 𝕜 β] {s : set E} {f : E → β} : concave_on 𝕜 s (-f) ↔ convex_on 𝕜 s f
theorem add_torsion_eq_add_torsion_submonoid (G : Type u_1) [add_comm_group G] : add_comm_monoid.add_torsion G = (add_torsion G).to_add_submonoid
theorem uniform_space.completion.coe_isometry {α : Type u} [pseudo_metric_space α] : isometry coe
theorem continuous.measurable_embedding {γ : Type u_3} [tγ : topological_space γ] [polish_space γ] [measurable_space γ] [borel_space γ] {β : Type u_4} [tβ : topological_space β] [t2_space β] [measurable_space β] [borel_space β] {f : γ → β} (f_cont : continuous f) (f_inj : function.injective f) : measurable_embedding f
theorem is_localization.ext {R : Type u_1} [comm_semiring R] (M : submonoid R) {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] (j k : S → P) (hj1 : j 1 = 1) (hk1 : k 1 = 1) (hjm : ∀ (a b : S), j (a * b) = j a * j b) (hkm : ∀ (a b : S), k (a * b) = k a * k b) (h : ∀ (a : R), j (⇑(algebra_map R S) a) = k (⇑(algebra_map R S) a)) : j = k
theorem is_preconnected.sUnion_directed {α : Type u} [topological_space α] {S : set (set α)} (K : directed_on has_subset.subset S) (H : ∀ (s : set α), s ∈ S → is_preconnected s) : is_preconnected (⋃₀S)
theorem well_founded_lt_exact_sequence {α : Type u_1} [lattice α] [is_modular_lattice α] {β : Type u_2} {γ : Type u_3} [partial_order β] [preorder γ] (h₁ : well_founded has_lt.lt) (h₂ : well_founded has_lt.lt) (K : α) (f₁ : β → α) (f₂ : α → β) (g₁ : γ → α) (g₂ : α → γ) (gci : galois_coinsertion f₁ f₂) (gi : galois_insertion g₂ g₁) (hf : ∀ (a : α), f₁ (f₂ a) = a ⊓ K) (hg : ∀ (a : α), g₁ (g₂ a) = a ⊔ K) : well_founded has_lt.lt
theorem is_min.pred_eq {α : Type u_1} [partial_order α] [pred_order α] {a : α} : is_min a → order.pred a = a
theorem polynomial.degree_multiset_prod_le {R : Type u} [comm_semiring R] (t : multiset (polynomial R)) : t.prod.degree ≤ (multiset.map polynomial.degree t).sum
theorem add_con.ext_iff {M : Type u_1} [has_add M] {c d : add_con M} : (∀ (x y : M), ⇑c x y ↔ ⇑d x y) ↔ c = d
theorem dim_mul_dim (F : Type u) (K A : Type v) [field F] [field K] [add_comm_group A] [algebra F K] [module K A] [module F A] [is_scalar_tower F K A] : module.rank F K * module.rank K A = module.rank F A
theorem finset.prod_range_induction {M : Type u_1} [comm_monoid M] (f s : ℕ → M) (h0 : s 0 = 1) (h : ∀ (n : ℕ), s (n + 1) = s n * f n) (n : ℕ) : (finset.range n).prod (λ (k : ℕ), f k) = s n
theorem ext_chart_preimage_mem_nhds_within {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] (x : M) {s t : set M} (ht : t ∈ nhds_within x s) : ⇑((ext_chart_at I x).symm) ⁻¹' t ∈ nhds_within (⇑(ext_chart_at I x) x) (⇑((ext_chart_at I x).symm) ⁻¹' s ∩ set.range ⇑I)
theorem free_group.reduce.sound {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.mk L₁ = free_group.mk L₂) : free_group.reduce L₁ = free_group.reduce L₂
theorem subtype.edist_eq {α : Type u} [pseudo_emetric_space α] {p : α → Prop} (x y : subtype p) : has_edist.edist x y = has_edist.edist ↑x ↑y
theorem closure_Ioc {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b) : closure (set.Ioc a b) = set.Icc a b
theorem fin.find_eq_none_iff {n : ℕ} {p : fin n → Prop} [decidable_pred p] : fin.find p = option.none ↔ ∀ (i : fin n), ¬p i
theorem ideal.exist_integer_multiples_not_mem {A : Type u_2} {K : Type u_3} [comm_ring A] [field K] [is_domain A] [is_dedekind_domain A] [algebra A K] [is_fraction_ring A K] {J : ideal A} (hJ : J ≠ ⊤) {ι : Type u_1} (s : finset ι) (f : ι → K) {j : ι} (hjs : j ∈ s) (hjf : f j ≠ 0) : ∃ (a : K), (∀ (i : ι), i ∈ s → is_localization.is_integer A (a * f i)) ∧ ∃ (i : ι) (H : i ∈ s), a * f i ∉ ↑J
theorem zero_lt.right.one_lt_mul_of_le_of_lt {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b
theorem orientation.oangle_neg_self_right {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x : V} (hx : x ≠ 0) : o.oangle x (-x) = ↑real.pi
theorem cont_diff_at.cont_mdiff_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {n : with_top ℕ} {f : E → E'} {x : E} : cont_diff_at 𝕜 n f x → cont_mdiff_at (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n f x
theorem generalized_continued_fraction.squash_gcf_eq_self_of_terminated {K : Type u_1} {n : ℕ} {g : generalized_continued_fraction K} [division_ring K] (terminated_at_n : g.terminated_at n) : g.squash_gcf n = g
theorem convolution_tendsto_right {G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G → E'} [measurable_space G] {μ : measure_theory.measure G} [semi_normed_group G] [borel_space G] [topological_space.second_countable_topology G] [μ.is_add_left_invariant] [measure_theory.sigma_finite μ] [normed_space ℝ E'] [complete_space E'] {ι : Type u_1} {l : filter ι} {φ : ι → G → ℝ} (hnφ : ∀ (i : ι) (x : G), 0 ≤ φ i x) (hiφ : ∀ (i : ι), ∫ (s : G), φ i s ∂μ = 1) (hφ : filter.tendsto (λ (n : ι), function.support (φ n)) l (nhds 0).small_sets) (hmg : measure_theory.ae_strongly_measurable g μ) {x₀ : G} (hcg : continuous_at g x₀) : filter.tendsto (λ (i : ι), convolution (φ i) g (continuous_linear_map.lsmul ℝ ℝ) μ x₀) l (nhds (g x₀))
theorem finset.centroid_singleton (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} (p : ι → P) (i : ι) : finset.centroid k {i} p = p i
theorem finset.le_prod_of_submultiplicative {ι : Type u_1} {M : Type u_4} {N : Type u_5} [comm_monoid M] [ordered_comm_monoid N] (f : M → N) (h_one : f 1 = 1) (h_mul : ∀ (x y : M), f (x * y) ≤ f x * f y) (s : finset ι) (g : ι → M) : f (s.prod (λ (i : ι), g i)) ≤ s.prod (λ (i : ι), f (g i))
theorem linear_equiv.closed_embedding_of_injective {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {E : Type v} [normed_group E] [normed_space 𝕜 E] {F : Type w} [normed_group F] [normed_space 𝕜 F] [complete_space 𝕜] {f : E →ₗ[𝕜] F} (hf : f.ker = ⊥) [finite_dimensional 𝕜 E] : closed_embedding ⇑f
theorem monotone.pairwise_disjoint_on_Ioc_succ {α : Type u_1} {β : Type u_2} [linear_order α] [succ_order α] [preorder β] {f : α → β} (hf : monotone f) : pairwise (disjoint on λ (n : α), set.Ioc (f n) (f (order.succ n)))
theorem fin.pred_above_succ_above {n : ℕ} (p i : fin n) : p.pred_above (⇑((⇑fin.cast_succ p).succ_above) i) = i
theorem injective_iff_map_eq_zero' {F : Type u_8} {G : Type u_1} {H : Type u_2} [add_group G] [add_zero_class H] [add_monoid_hom_class F G H] (f : F) : function.injective ⇑f ↔ ∀ (a : G), ⇑f a = 0 ↔ a = 0
theorem setoid.eqv_class_mem {α : Type u_1} {c : set (set α)} (H : ∀ (a : α), ∃! (b : set α) (H : b ∈ c), a ∈ b) {y : α} : {x : α | (setoid.mk_classes c H).rel x y} ∈ c
theorem topological_fiber_bundle_core.local_triv_as_local_equiv_trans {ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (i j : ι) : (Z.local_triv_as_local_equiv i).symm.trans (Z.local_triv_as_local_equiv j) ≈ (Z.triv_change i j).to_local_equiv
theorem phragmen_lindelof.right_half_plane_of_bounded_on_real {E : Type u_1} [normed_group E] [normed_space ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ} (hd : diff_cont_on_cl ℂ f {z : ℂ | 0 < z.re}) (hexp : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ filter.principal {z : ℂ | 0 < z.re}] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hre : filter.is_bounded_under has_le.le filter.at_top (λ (x : ℝ), ∥f ↑x∥)) (him : ∀ (x : ℝ), ∥f (↑x * complex.I)∥ ≤ C) (hz : 0 ≤ z.re) : ∥f z∥ ≤ C
theorem norm_combo_lt_of_ne {E : Type u_2} [normed_group E] [normed_space ℝ E] [strict_convex_space ℝ E] {x y : E} {a b r : ℝ} (hx : ∥x∥ ≤ r) (hy : ∥y∥ ≤ r) (hne : x ≠ y) (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) : ∥a • x + b • y∥ < r
theorem submonoid.mem_closure_singleton {M : Type u_1} [monoid M] {x y : M} : y ∈ submonoid.closure {x} ↔ ∃ (n : ℕ), x ^ n = y
theorem metric.diam_nonneg {α : Type u} [pseudo_metric_space α] {s : set α} : 0 ≤ metric.diam s
theorem matrix.det_permutation {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (σ : equiv.perm n) : (equiv.to_pequiv σ).to_matrix.det = ↑(⇑equiv.perm.sign σ)
theorem add_subgroup.is_open_of_zero_mem_interior {G : Type u_1} [add_group G] [topological_space G] [topological_add_group G] {H : add_subgroup G} (h_1_int : 0 ∈ interior ↑H) : is_open ↑H
theorem bornology.is_bounded.bounded_space_coe {α : Type u_1} [bornology α] {s : set α} : bornology.is_bounded s → bounded_space ↥s
theorem affine_span_insert_eq_affine_span (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {p : P} {ps : set P} (h : p ∈ affine_span k ps) : affine_span k (has_insert.insert p ps) = affine_span k ps
theorem star_div {R : Type u} [comm_group R] [star_semigroup R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y
theorem same_ray_smul_left_iff_of_ne {R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] [no_zero_smul_divisors R M] {v : M} (hv : v ≠ 0) {r : R} (hr : r ≠ 0) : same_ray R (r • v) v ↔ 0 < r
theorem is_smul_regular.zero {R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [sM : subsingleton M] : is_smul_regular M 0
theorem polynomial.is_separable_contraction.dvd_degree' {F : Type} [comm_semiring F] {q : ℕ} {f g : polynomial F} (hf : polynomial.is_separable_contraction q f g) : ∃ (m : ℕ), g.nat_degree * q ^ m = f.nat_degree
theorem category_theory.grothendieck_topology.is_closed_iff_close_eq_self {C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : J₁.is_closed S ↔ J₁.close S = S
theorem set.image_subset_iff {α : Type u} {β : Type v} {s : set α} {t : set β} {f : α → β} : f '' s ⊆ t ↔ s ⊆ f ⁻¹' t
theorem category_theory.abelian.exact_iff_image_eq_kernel {C : Type u₁} [category_theory.category C] [category_theory.abelian C] {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z) : category_theory.exact f g ↔ category_theory.limits.image_subobject f = category_theory.limits.kernel_subobject g
theorem add_monoid_algebra.grade.is_internal {ι : Type u_2} {R : Type u_3} [decidable_eq ι] [add_monoid ι] [comm_semiring R] : direct_sum.is_internal (add_monoid_algebra.grade R)
theorem add_subgroup.map_normalizer_eq_of_bijective {G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (H : add_subgroup G) {f : G →+ N} (hf : function.bijective ⇑f) : add_subgroup.map f H.normalizer = (add_subgroup.map f H).normalizer
theorem finset.subset_add {α : Type u_2} [decidable_eq α] [has_add α] {u : finset α} {s t : set α} : ↑u ⊆ s + t → (∃ (s' t' : finset α), ↑s' ⊆ s ∧ ↑t' ⊆ t ∧ u ⊆ s' + t')
theorem category_theory.normal_mono_category.epi_of_zero_cokernel {C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_kernels C] [category_theory.normal_mono_category C] {X Y : C} (f : X ⟶ Y) (Z : C) (l : category_theory.limits.is_colimit (category_theory.limits.cokernel_cofork.of_π 0 _)) : category_theory.epi f
theorem is_trivial_topological_fiber_bundle_snd {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.snd
theorem finsum_mem_insert {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {a : α} {s : set α} (f : α → M) (h : a ∉ s) (hs : s.finite) : finsum (λ (i : α), finsum (λ (H : i ∈ has_insert.insert a s), f i)) = f a + finsum (λ (i : α), finsum (λ (H : i ∈ s), f i))
theorem char_zero_of_exp_char_one (R : Type u) [semiring R] [nontrivial R] (p : ℕ) [hp : char_p R p] [hq : exp_char R 1] : p = 0
theorem normed_ring.inverse_add_norm_diff_first_order {R : Type u_1} [normed_ring R] [complete_space R] (x : Rˣ) : (λ (t : R), ring.inverse (↑x + t) - ↑x⁻¹) =O[nhds 0] λ (t : R), ∥t∥
theorem powers.one_mem {M : Type u_1} [monoid M] {x : M} : 1 ∈ powers x
theorem function.injective.map_at_top_finset_sum_eq {α : Type u_3} {β : Type u_4} {γ : Type u_5} [add_comm_monoid α] {g : γ → β} (hg : function.injective g) {f : β → α} (hf : ∀ (x : β), x ∉ set.range g → f x = 0) : filter.map (λ (s : finset γ), s.sum (λ (i : γ), f (g i))) filter.at_top = filter.map (λ (s : finset β), s.sum (λ (i : β), f i)) filter.at_top
theorem eventually_uniformity_iterate_comp_subset {α : Type u_1} [uniform_space α] {s : set (α × α)} (hs : s ∈ uniformity α) (n : ℕ) : ∀ᶠ (t : set (α × α)) in (uniformity α).small_sets, comp_rel t^[n] t ⊆ s
theorem euclidean_geometry.angle_left_midpoint_eq_pi_div_two_of_dist_eq {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : has_dist.dist p3 p1 = has_dist.dist p3 p2) : euclidean_geometry.angle p3 (midpoint ℝ p1 p2) p1 = real.pi / 2
theorem measure_theory.measure.add_haar_smul {E : Type u_1} [normed_group E] [measurable_space E] [normed_space ℝ E] [finite_dimensional ℝ E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (r : ℝ) (s : set E) : ⇑μ (r • s) = ennreal.of_real |r ^ finite_dimensional.finrank ℝ E| * ⇑μ s
theorem convex.center_mass_mem {R : Type u_1} {E : Type u_2} {ι : Type u_4} [linear_ordered_field R] [add_comm_group E] [module R E] {s : set E} {t : finset ι} {w : ι → R} {z : ι → E} (hs : convex R s) : (∀ (i : ι), i ∈ t → 0 ≤ w i) → 0 < t.sum (λ (i : ι), w i) → (∀ (i : ι), i ∈ t → z i ∈ s) → t.center_mass w z ∈ s
theorem multilinear_map.comp_linear_map_injective {R : Type u} {ι : Type u'} {M₁ : ι → Type v₁} {M₂ : Type v₂} [decidable_eq ι] [semiring R] [Π (i : ι), add_comm_monoid (M₁ i)] [add_comm_monoid M₂] [Π (i : ι), module R (M₁ i)] [module R M₂] {M₁' : ι → Type u_1} [Π (i : ι), add_comm_monoid (M₁' i)] [Π (i : ι), module R (M₁' i)] (f : Π (i : ι), M₁ i →ₗ[R] M₁' i) (hf : ∀ (i : ι), function.surjective ⇑(f i)) : function.injective (λ (g : multilinear_map R M₁' M₂), g.comp_linear_map f)
theorem affine_subspace.direction_bot (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : ⊥.direction = ⊥
theorem norm_add_sq {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x y : E} : ∥x + y∥ ^ 2 = ∥x∥ ^ 2 + 2 * ⇑is_R_or_C.re (has_inner.inner x y) + ∥y∥ ^ 2
theorem emetric.second_countable_of_sigma_compact (α : Type u) [pseudo_emetric_space α] [sigma_compact_space α] : topological_space.second_countable_topology α
theorem has_deriv_at_exp {𝕂 : Type u_1} [is_R_or_C 𝕂] {x : 𝕂} : has_deriv_at (exp 𝕂) (exp 𝕂 x) x
theorem interval_integral.integral_has_deriv_at_left {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (ha : continuous_at f a) : has_deriv_at (λ (u : ℝ), ∫ (x : ℝ) in u..b, f x) (-f a) a
theorem lie_module.nilpotent_of_nilpotent_quotient (R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] {N : lie_submodule R L M} (h₁ : N ≤ lie_module.max_triv_submodule R L M) (h₂ : lie_module.is_nilpotent R L (M ⧸ N)) : lie_module.is_nilpotent R L M
theorem orthonormal.eq_rotation_self_iff_angle_eq_zero {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x : V} (hx : x ≠ 0) (θ : real.angle) : x = ⇑(hb.rotation θ) x ↔ θ = 0
theorem antitone.covariant_of_const {M : Type u_1} {N : Type u_2} {μ : M → N → N} {α : Type u_3} [preorder α] [preorder N] {f : N → α} [covariant_class M N μ has_le.le] (hf : antitone f) (m : M) : antitone (λ (n : N), f (μ m n))
theorem has_sum.prod_fiberwise {α : Type u_1} {β : Type u_2} {γ : Type u_3} [add_comm_monoid α] [topological_space α] [has_continuous_add α] [regular_space α] {f : β × γ → α} {g : β → α} {a : α} (ha : has_sum f a) (hf : ∀ (b : β), has_sum (λ (c : γ), f (b, c)) (g b)) : has_sum g a
theorem image_norm_le_of_liminf_right_slope_norm_lt_deriv_boundary {a b : ℝ} {E : Type u_1} [normed_group E] {f : ℝ → E} {f' : ℝ → ℝ} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → ∀ (r : ℝ), f' x < r → (∃ᶠ (z : ℝ) in nhds_within x (set.Ioi x), slope (has_norm.norm ∘ f) x z < r)) {B B' : ℝ → ℝ} (ha : ∥f a∥ ≤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at B (B' x) (set.Ici x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → ∥f x∥ = B x → f' x < B' x) ⦃x : ℝ⦄ : x ∈ set.Icc a b → ∥f x∥ ≤ B x
theorem has_le.le.trans' {α : Type u} [preorder α] {a b c : α} : b ≤ c → a ≤ b → a ≤ c
theorem category_theory.whiskering_preadditive_coyoneda {C : Type u} [category_theory.category C] [category_theory.preadditive C] : category_theory.preadditive_coyoneda ⋙ (category_theory.whiskering_right C AddCommGroup (Type v)).obj (category_theory.forget AddCommGroup) = category_theory.coyoneda
theorem poly.is_poly {α : Type u_1} (f : poly α) : is_poly ⇑f
theorem W_type.cardinal_mk_le_of_le {α : Type u} {β : α → Type u} {κ : cardinal} (hκ : cardinal.sum (λ (a : α), κ ^ cardinal.mk (β a)) ≤ κ) : cardinal.mk (W_type β) ≤ κ
theorem category_theory.limits.has_zero_object_of_has_initial_object {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_initial C] : category_theory.limits.has_zero_object C
theorem cont_diff.add {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : with_top ℕ} {f g : E → F} (hf : cont_diff 𝕜 n f) (hg : cont_diff 𝕜 n g) : cont_diff 𝕜 n (λ (x : E), f x + g x)
theorem legendre_symbol.Ico_map_val_min_abs_nat_abs_eq_Ico_map_id (p : ℕ) [hp : fact (nat.prime p)] (a : zmod p) (hap : a ≠ 0) : multiset.map (λ (x : ℕ), (a * ↑x).val_min_abs.nat_abs) (finset.Ico 1 (p / 2).succ).val = multiset.map (λ (a : ℕ), a) (finset.Ico 1 (p / 2).succ).val
theorem dimH_image_le_of_locally_holder_on {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [topological_space.second_countable_topology X] {r : nnreal} {f : X → Y} (hr : 0 < r) {s : set X} (hf : ∀ (x : X), x ∈ s → (∃ (C : nnreal) (t : set X) (H : t ∈ nhds_within x s), holder_on_with C r f t)) : dimH (f '' s) ≤ dimH s / ↑r
theorem subalgebra.separates_points.strongly {α : Type u_1} [topological_space α] {𝕜 : Type u_5} [topological_space 𝕜] [field 𝕜] [topological_ring 𝕜] {s : subalgebra 𝕜 C(α, 𝕜)} (h : s.separates_points) : ↑s.separates_points_strongly
theorem mv_polynomial.induction_on'' {R : Type u} {σ : Type u_1} [comm_semiring R] {M : mv_polynomial σ R → Prop} (p : mv_polynomial σ R) (h_C : ∀ (a : R), M (⇑mv_polynomial.C a)) (h_add_weak : ∀ (a : σ →₀ ℕ) (b : R) (f : (σ →₀ ℕ) →₀ R), a ∉ f.support → b ≠ 0 → M f → M (⇑(mv_polynomial.monomial a) b) → M (⇑(mv_polynomial.monomial a) b + f)) (h_X : ∀ (p : mv_polynomial σ R) (n : σ), M p → M (p * mv_polynomial.X n)) : M p
theorem measure_theory.simple_func.lintegral_congr {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f g : measure_theory.simple_func α ennreal} (h : ⇑f =ᵐ[μ] ⇑g) : f.lintegral μ = g.lintegral μ
theorem is_localization.localization_localization_is_localization_of_has_all_units {R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] (N : submonoid S) (T : Type u_4) [comm_ring T] [algebra R T] [algebra S T] [is_scalar_tower R S T] [is_localization M S] [is_localization N T] (H : ∀ (x : S), is_unit x → x ∈ N) : is_localization (submonoid.comap (algebra_map R S).to_monoid_hom N) T
theorem is_fw_invariant_iff_is_invariant {τ : Type u_1} {α : Type u_2} [canonically_ordered_add_monoid τ] {ϕ : τ → α → α} {s : set α} : is_fw_invariant ϕ s ↔ is_invariant ϕ s
theorem emetric.Hausdorff_edist_self {α : Type u} [pseudo_emetric_space α] {s : set α} : emetric.Hausdorff_edist s s = 0
theorem continuous_linear_map.is_compact_image_coe_closed_ball {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [normed_group E] [normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [ring_hom_isometric σ₁₂] [proper_space F] (f₀ : E →SL[σ₁₂] F) (r : ℝ) : is_compact (coe_fn '' metric.closed_ball f₀ r)
theorem linear_map.eq_adjoint_iff {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [inner_product_space 𝕜 F] [finite_dimensional 𝕜 E] [finite_dimensional 𝕜 F] (A : E →ₗ[𝕜] F) (B : F →ₗ[𝕜] E) : A = ⇑linear_map.adjoint B ↔ ∀ (x : E) (y : F), has_inner.inner (⇑A x) y = has_inner.inner x (⇑B y)
theorem fintype.exists_sum_fiber_lt_of_sum_lt_nsmul {α : Type u} {β : Type v} {M : Type w} [decidable_eq β] [fintype α] [fintype β] (f : α → β) {w : α → M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (hb : finset.univ.sum (λ (x : α), w x) < fintype.card β • b) : ∃ (y : β), (finset.filter (λ (x : α), f x = y) finset.univ).sum (λ (x : α), w x) < b
theorem orientation.oangle_add_cyc3_neg_right {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle x (-y) + o.oangle y (-z) + o.oangle z (-x) = ↑real.pi
theorem is_open.measure_eq_supr_is_compact {α : Type u_1} [measurable_space α] [topological_space α] ⦃U : set α⦄ (hU : is_open U) (μ : measure_theory.measure α) [μ.regular] : ⇑μ U = ⨆ (K : set α) (h : K ⊆ U) (h2 : is_compact K), ⇑μ K
theorem ring_equiv.map_add {R : Type u_4} {S : Type u_5} [has_mul R] [has_add R] [has_mul S] [has_add S] (e : R ≃+* S) (x y : R) : ⇑e (x + y) = ⇑e x + ⇑e y
theorem direct_sum.to_module.unique (R : Type u) [semiring R] {ι : Type v} [dec_ι : decidable_eq ι] {M : ι → Type w} [Π (i : ι), add_comm_monoid (M i)] [Π (i : ι), module R (M i)] {N : Type u₁} [add_comm_monoid N] [module R N] (ψ : direct_sum ι (λ (i : ι), M i) →ₗ[R] N) (f : direct_sum ι (λ (i : ι), M i)) : ⇑ψ f = ⇑(direct_sum.to_module R ι N (λ (i : ι), ψ.comp (direct_sum.lof R ι M i))) f
theorem setoid.Inf_def {α : Type u_1} {s : set (setoid α)} : (has_Inf.Inf s).rel = has_Inf.Inf (setoid.rel '' s)
theorem image_le_of_liminf_slope_right_le_deriv_boundary {f : ℝ → ℝ} {a b : ℝ} (hf : continuous_on f (set.Icc a b)) {B B' : ℝ → ℝ} (ha : f a ≤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at B (B' x) (set.Ici x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → ∀ (r : ℝ), B' x < r → (∃ᶠ (z : ℝ) in nhds_within x (set.Ioi x), slope f x z < r)) ⦃x : ℝ⦄ : x ∈ set.Icc a b → f x ≤ B x
theorem add_monoid_hom.eq_on_neg {M : Type u_3} {F : Type u_8} {G : Type u_1} [add_group G] [add_monoid M] [add_monoid_hom_class F G M] {f g : F} {x : G} (h : ⇑f x = ⇑g x) : ⇑f (-x) = ⇑g (-x)
theorem filter.tendsto.uniformity_trans {α : Type u_1} {β : Type u_2} [uniform_space α] {l : filter β} {f₁ f₂ f₃ : β → α} (h₁₂ : filter.tendsto (λ (x : β), (f₁ x, f₂ x)) l (uniformity α)) (h₂₃ : filter.tendsto (λ (x : β), (f₂ x, f₃ x)) l (uniformity α)) : filter.tendsto (λ (x : β), (f₁ x, f₃ x)) l (uniformity α)
theorem category_theory.limits.biprod.total {C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} [category_theory.limits.has_binary_biproduct X Y] : category_theory.limits.biprod.fst ≫ category_theory.limits.biprod.inl + category_theory.limits.biprod.snd ≫ category_theory.limits.biprod.inr = 𝟙 (X ⊞ Y)
theorem intermediate_field.bot_eq_top_of_finrank_adjoin_le_one {F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] [finite_dimensional F E] (h : ∀ (x : E), finite_dimensional.finrank F ↥F⟮x⟯ ≤ 1) : ⊥ = ⊤
theorem nat.exists_infinite_primes (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p
theorem add_monoid_algebra.mem_span_support' {k : Type u₁} {G : Type u₂} [semiring k] (f : add_monoid_algebra k G) : f ∈ submodule.span k (add_monoid_algebra.of' k G '' ↑(f.support))
theorem neg_zero' {α : Type u} [mul_zero_class α] [has_distrib_neg α] : -0 = 0
theorem algebra.commutes {R : Type u} {A : Type w} [comm_semiring R] [semiring A] [algebra R A] (r : R) (x : A) : ⇑(algebra_map R A) r * x = x * ⇑(algebra_map R A) r
theorem setoid.nonempty_of_mem_partition {α : Type u_1} {c : set (set α)} (hc : setoid.is_partition c) {s : set α} (h : s ∈ c) : s.nonempty
theorem basis.exists_op_norm_le {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {E : Type v} [normed_group E] [normed_space 𝕜 E] {F : Type w} [normed_group F] [normed_space 𝕜 F] [complete_space 𝕜] {ι : Type u_1} [fintype ι] (v : basis ι 𝕜 E) : ∃ (C : ℝ) (H : C > 0), ∀ {u : E →L[𝕜] F} {M : ℝ}, 0 ≤ M → (∀ (i : ι), ∥⇑u (⇑v i)∥ ≤ M) → ∥u∥ ≤ C * M
theorem add_monoid_hom.coe_inj {M : Type u_3} {N : Type u_4} [add_zero_class M] [add_zero_class N] ⦃f g : M →+ N⦄ (h : ⇑f = ⇑g) : f = g
theorem simple_graph.max_degree_lt_card_verts {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [nonempty V] : G.max_degree < fintype.card V
theorem category_theory.limits.is_limit.of_nat_iso.cone_of_hom_fac {J : Type u₁} [category_theory.category J] {C : Type u₃} [category_theory.category C] {F : J ⥤ C} {X : C} (h : category_theory.yoneda.obj X ⋙ category_theory.ulift_functor ≅ F.cones) {Y : C} (f : Y ⟶ X) : category_theory.limits.is_limit.of_nat_iso.cone_of_hom h f = (category_theory.limits.is_limit.of_nat_iso.limit_cone h).extend f
theorem is_compact.uniform_continuous_on_of_continuous {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] [separated_space α] {s : set α} {f : α → β} (hs : is_compact s) (hf : continuous_on f s) : uniform_continuous_on f s
theorem fermat_42.exists_minimal {a b c : ℤ} (h : fermat_42 a b c) : ∃ (a0 b0 c0 : ℤ), fermat_42.minimal a0 b0 c0
theorem add_submonoid.localization_map.map_add_left {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M →+ P} {T : add_submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ T) {Q : Type u_4} [add_comm_monoid Q] {k : T.localization_map Q} (z : N) : ⇑(k.to_map) (⇑g ↑((f.sec z).snd)) + ⇑(f.map hy k) z = ⇑(k.to_map) (⇑g (f.sec z).fst)
theorem fin.prod_univ_succ_above {β : Type u_2} [comm_monoid β] {n : ℕ} (f : fin (n + 1) → β) (x : fin (n + 1)) : finset.univ.prod (λ (i : fin (n + 1)), f i) = f x * finset.univ.prod (λ (i : fin n), f (⇑(x.succ_above) i))
theorem cardinal.nsmul_lt_aleph_0_iff {n : ℕ} {a : cardinal} : n • a < cardinal.aleph_0 ↔ n = 0 ∨ a < cardinal.aleph_0
theorem filter.infi_ne_bot_of_directed {α : Type u} {ι : Sort x} {f : ι → filter α} [hn : nonempty α] (hd : directed ge f) (hb : ∀ (i : ι), (f i).ne_bot) : (infi f).ne_bot
theorem filter.tendsto.const_mul_at_bot {α : Type u_3} {β : Type u_4} [linear_ordered_field α] {l : filter β} {f : β → α} {r : α} (hr : 0 < r) (hf : filter.tendsto f l filter.at_bot) : filter.tendsto (λ (x : β), r * f x) l filter.at_bot
theorem ext_chart_preimage_inter_eq {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] (x : M) {s t : set M} : ⇑((ext_chart_at I x).symm) ⁻¹' (s ∩ t) ∩ set.range ⇑I = ⇑((ext_chart_at I x).symm) ⁻¹' s ∩ set.range ⇑I ∩ ⇑((ext_chart_at I x).symm) ⁻¹' t
theorem same_ray_pos_smul_right {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (v : M) {r : R} (h : 0 < r) : same_ray R v (r • v)
theorem is_primitive_root.card_primitive_roots {R : Type u_5} [comm_ring R] [is_domain R] {ζ : R} {k : ℕ} (h : is_primitive_root ζ k) : (primitive_roots k R).card = k.totient
theorem filter.tendsto.not_tendsto {α : Type u} {β : Type v} {f : α → β} {a : filter α} {b₁ b₂ : filter β} (hf : filter.tendsto f a b₁) [a.ne_bot] (hb : disjoint b₁ b₂) : ¬filter.tendsto f a b₂
theorem ring_hom.map_closure {R : Type u} {S : Type v} [ring R] [ring S] (f : R →+* S) (s : set R) : subring.map f (subring.closure s) = subring.closure (⇑f '' s)
theorem add_commute.refl {S : Type u_1} [has_add S] (a : S) : add_commute a a
theorem ideal.prime_iff_is_prime {A : Type u_2} [comm_ring A] [is_domain A] [is_dedekind_domain A] {P : ideal A} (hP : P ≠ ⊥) : prime P ↔ P.is_prime
theorem finset.exists_lt_card_fiber_of_nsmul_lt_card_of_maps_to {α : Type u} {β : Type v} {M : Type w} [decidable_eq β] {s : finset α} {t : finset β} {f : α → β} {b : M} [linear_ordered_comm_ring M] (hf : ∀ (a : α), a ∈ s → f a ∈ t) (ht : t.card • b < ↑(s.card)) : ∃ (y : β) (H : y ∈ t), b < ↑((finset.filter (λ (x : α), f x = y) s).card)
theorem orthonormal.det_rotation {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (θ : real.angle) : ⇑linear_map.det ↑((hb.rotation θ).to_linear_equiv) = 1
theorem zmod.units_pow_card_sub_one_eq_one (p : ℕ) [fact (nat.prime p)] (a : (zmod p)ˣ) : a ^ (p - 1) = 1
theorem list.nodup.sublists {α : Type u} {l : list α} : l.nodup → l.sublists.nodup
theorem algebraic_geometry.Spec_map_localization_is_iso (R : CommRing) (M : submonoid ↥R) (x : prime_spectrum (localization M)) : category_theory.is_iso (algebraic_geometry.PresheafedSpace.stalk_map (algebraic_geometry.Spec.to_PresheafedSpace.map (CommRing.of_hom (algebra_map ↥R (localization M))).op) x)
theorem real.tendsto_exp_nhds_0_nhds_1  : filter.tendsto real.exp (nhds 0) (nhds 1)
theorem measure_theory.measure_of_cont_bdd_of_tendsto_indicator {α : Type u_1} [measurable_space α] [topological_space α] [opens_measurable_space α] (μ : measure_theory.finite_measure α) {c : nnreal} {E : set α} (E_mble : measurable_set E) (fs : ℕ → bounded_continuous_function α nnreal) (fs_bdd : ∀ (n : ℕ) (a : α), ⇑(fs n) a ≤ c) (fs_lim : filter.tendsto (λ (n : ℕ), ⇑(fs n)) filter.at_top (nhds (E.indicator (λ (x : α), 1)))) : filter.tendsto (λ (n : ℕ), ∫⁻ (a : α), ↑(⇑(fs n) a) ∂↑μ) filter.at_top (nhds (⇑↑μ E))
theorem range.is_submonoid {M : Type u_1} [monoid M] {γ : Type u_2} [monoid γ] {f : M → γ} (hf : is_monoid_hom f) : is_submonoid (set.range f)
theorem continuous_map.Inter_compact_open_gen_subset_compact_conv_nhd {α : Type u₁} {β : Type u₂} [topological_space α] [uniform_space β] {K : set α} {V : set (β × β)} (f : C(α, β)) (hK : is_compact K) (hV : V ∈ uniformity β) : ∃ (ι : Type u₁) [_inst_3 : fintype ι] (C : ι → set α) (hC : ∀ (i : ι), is_compact (C i)) (U : ι → set β) (hU : ∀ (i : ι), is_open (U i)), (f ∈ ⋂ (i : ι), continuous_map.compact_open.gen (C i) (U i)) ∧ (⋂ (i : ι), continuous_map.compact_open.gen (C i) (U i)) ⊆ continuous_map.compact_conv_nhd K V f
theorem add_le_of_le_neg_add {α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : b ≤ -a + c → a + b ≤ c
theorem nat.partrec.code.fixed_point {f : nat.partrec.code → nat.partrec.code} (hf : computable f) : ∃ (c : nat.partrec.code), (f c).eval = c.eval
theorem cont_diff.smul {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : with_top ℕ} {f : E → 𝕜} {g : E → F} (hf : cont_diff 𝕜 n f) (hg : cont_diff 𝕜 n g) : cont_diff 𝕜 n (λ (x : E), f x • g x)
theorem smooth_bump_covering.exists_is_subordinate {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] (I : model_with_corners ℝ E H) {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} {U : M → set M} [t2_space M] [sigma_compact_space M] (hs : is_closed s) (hU : ∀ (x : M), x ∈ s → U x ∈ nhds x) : ∃ (ι : Type uM) (f : smooth_bump_covering ι I M s), f.is_subordinate U
theorem exists_between_of_forall_le {α : Type u_1} [conditionally_complete_lattice α] {s t : set α} (sne : s.nonempty) (tne : t.nonempty) (hst : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ t → x ≤ y) : (upper_bounds s ∩ lower_bounds t).nonempty
theorem ennreal.top_sub_coe {r : nnreal} : ⊤ - ↑r = ⊤
theorem is_smul_regular.not_zero {R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [nM : nontrivial M] : ¬is_smul_regular M 0
theorem uv.sup_sdiff_mem_of_mem_compression {α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] {s : finset α} {u v a : α} (ha : a ∈ uv.compression u v s) (hva : v ≤ a) (hua : disjoint u a) : (a ⊔ u)  v ∈ s
theorem monoid_algebra.alg_hom_ext' {k : Type u₁} {G : Type u₂} [comm_semiring k] [monoid G] {A : Type u₃} [semiring A] [algebra k A] ⦃φ₁ φ₂ : monoid_algebra k G →ₐ[k] A⦄ (h : ↑φ₁.comp (monoid_algebra.of k G) = ↑φ₂.comp (monoid_algebra.of k G)) : φ₁ = φ₂
theorem has_subset.subset.antisymm {α : Type u} [has_subset α] {a b : α} [is_antisymm α has_subset.subset] (h : a ⊆ b) (h' : b ⊆ a) : a = b
theorem affine_subspace.vsub_mem_direction {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p1 p2 : P} (hp1 : p1 ∈ s) (hp2 : p2 ∈ s) : p1 -ᵥ p2 ∈ s.direction
theorem orientation.oangle_rev {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x y : V) : o.oangle y x = -o.oangle x y
theorem char_dvd_card_solutions {K : Type u_1} {σ : Type u_2} [fintype K] [field K] [fintype σ] [decidable_eq K] [decidable_eq σ] (p : ℕ) [char_p K p] {f : mv_polynomial σ K} (h : f.total_degree < fintype.card σ) : p ∣ fintype.card {x // ⇑(mv_polynomial.eval x) f = 0}
theorem category_theory.zigzag_is_connected {J : Type u₁} [category_theory.category J] [nonempty J] (h : ∀ (j₁ j₂ : J), category_theory.zigzag j₁ j₂) : category_theory.is_connected J
theorem is_p_group.exists_fixed_point_of_prime_dvd_card_of_fixed_point {p : ℕ} {G : Type u_1} [group G] (hG : is_p_group p G) [hp : fact (nat.prime p)] (α : Type u_2) [mul_action G α] [fintype α] [fintype ↥(mul_action.fixed_points G α)] (hpα : p ∣ fintype.card α) {a : α} (ha : a ∈ mul_action.fixed_points G α) : ∃ (b : α), b ∈ mul_action.fixed_points G α ∧ a ≠ b
theorem orientation.oangle_neg_left {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : o.oangle (-x) y = o.oangle x y + ↑real.pi
theorem measure_theory.measure.finite_spanning_sets_in.ext {α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} {C : set (set α)} (hA : m0 = measurable_space.generate_from C) (hC : is_pi_system C) (h : μ.finite_spanning_sets_in C) (h_eq : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s) : μ = ν
theorem affine_independent.of_set_of_injective {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} {p : ι → P} (ha : affine_independent k (λ (x : ↥(set.range p)), ↑x)) (hi : function.injective p) : affine_independent k p
theorem category_theory.limits.cokernel.map_desc {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y Z X' Y' Z' : C} (f : X ⟶ Y) [category_theory.limits.has_cokernel f] (g : Y ⟶ Z) (w : f ≫ g = 0) (f' : X' ⟶ Y') [category_theory.limits.has_cokernel f'] (g' : Y' ⟶ Z') (w' : f' ≫ g' = 0) (p : X ⟶ X') (q : Y ⟶ Y') (r : Z ⟶ Z') (h₁ : f ≫ q = p ≫ f') (h₂ : g ≫ r = q ≫ g') : category_theory.limits.cokernel.map f f' p q h₁ ≫ category_theory.limits.cokernel.desc f' g' w' = category_theory.limits.cokernel.desc f g w ≫ r
theorem even.exists_two_nsmul {α : Type u_2} [add_monoid α] (m : α) : even m → (∃ (c : α), m = 2 • c)
theorem char_p.char_ne_zero_of_fintype (R : Type u) [non_assoc_ring R] (p : ℕ) [hc : char_p R p] [fintype R] : p ≠ 0
theorem measure_eq_measure_preimage_add_measure_tsum_Ico_zpow {α : Type u_1} [measurable_space α] (μ : measure_theory.measure α) {f : α → ennreal} (hf : measurable f) {s : set α} (hs : measurable_set s) {t : nnreal} (ht : 1 < t) : ⇑μ s = ⇑μ (s ∩ f ⁻¹' {0}) + ⇑μ (s ∩ f ⁻¹' {⊤}) + ∑' (n : ℤ), ⇑μ (s ∩ f ⁻¹' set.Ico (↑t ^ n) (↑t ^ (n + 1)))
theorem module.free.rank_direct_sum (R : Type u) [ring R] [strong_rank_condition R] {ι : Type v} (M : ι → Type w) [Π (i : ι), add_comm_group (M i)] [Π (i : ι), module R (M i)] [∀ (i : ι), module.free R (M i)] : module.rank R (direct_sum ι (λ (i : ι), M i)) = cardinal.sum (λ (i : ι), module.rank R (M i))
theorem vector_span_eq_span_vsub_finset_right_ne (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : finset P} {p : P} (hp : p ∈ s) : vector_span k ↑s = submodule.span k ↑(finset.image (λ (_x : P), _x -ᵥ p) (s.erase p))
theorem module.free.rank_prod' (R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] (N : Type v) [add_comm_group N] [module R N] [module.free R N] : module.rank R (M × N) = module.rank R M + module.rank R N
theorem nat.arithmetic_function.is_multiplicative.iff_ne_zero {R : Type u_1} [monoid_with_zero R] {f : nat.arithmetic_function R} : f.is_multiplicative ↔ ⇑f 1 = 1 ∧ ∀ {m n : ℕ}, m ≠ 0 → n ≠ 0 → m.coprime n → ⇑f (m * n) = ⇑f m * ⇑f n
theorem con.ker_eq_lift_of_injective {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] (c : con M) (f : M →* P) (H : c ≤ con.ker f) (h : function.injective ⇑(c.lift f H)) : con.ker f = c
theorem torus_integral_succ_above {n : ℕ} {E : Type u_1} [normed_group E] [normed_space ℂ E] [complete_space E] {f : (fin (n + 1) → ℂ) → E} {c : fin (n + 1) → ℂ} {R : fin (n + 1) → ℝ} (hf : torus_integrable f c R) (i : fin (n + 1)) : ∯ (x : fin (n + 1) → ℂ) in T(c, R), f x = ∮ (x : ℂ) in C(c i, R i), ∯ (y : fin n → ℂ) in T(c ∘ ⇑(i.succ_above), R ∘ ⇑(i.succ_above)), f (i.insert_nth x y)
theorem int.le_induction_down {P : ℤ → Prop} {m : ℤ} (h0 : P m) (h1 : ∀ (n : ℤ), n ≤ m → P n → P (n - 1)) (n : ℤ) : n ≤ m → P n
theorem has_ssubset.ssubset.not_subset {α : Type u} [has_subset α] [has_ssubset α] [is_nonstrict_strict_order α has_subset.subset has_ssubset.ssubset] {a b : α} (h : a ⊂ b) : ¬b ⊆ a
theorem is_o_rpow_exp_at_top (s : ℝ) : (λ (x : ℝ), x ^ s) =o[filter.at_top] real.exp
theorem tendsto_uniformly_on_iff_tendsto {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {p : filter ι} {s : set α} : tendsto_uniformly_on F f p s ↔ filter.tendsto (λ (q : ι × α), (f q.snd, F q.fst q.snd)) (p.prod (filter.principal s)) (uniformity β)
theorem is_localization.sec_spec {R : Type u_1} [comm_semiring R] (M : submonoid R) {S : Type u_2} [comm_semiring S] [algebra R S] [is_localization M S] (z : S) : z * ⇑(algebra_map R S) ↑((is_localization.sec M z).snd) = ⇑(algebra_map R S) (is_localization.sec M z).fst
theorem bsupr_limsup_dimH {X : Type u_2} [emetric_space X] [topological_space.second_countable_topology X] (s : set X) : (⨆ (x : X) (H : x ∈ s), (nhds_within x s).small_sets.limsup dimH) = dimH s
theorem polynomial.nat_degree_C_mul_eq_of_mul_ne_zero {R : Type u} {a : R} [semiring R] {p : polynomial R} (h : a * p.leading_coeff ≠ 0) : (⇑polynomial.C a * p).nat_degree = p.nat_degree
theorem equiv.perm.is_cycle_cycle_of_iff {α : Type u_1} [decidable_eq α] [fintype α] (f : equiv.perm α) {x : α} : (f.cycle_of x).is_cycle ↔ ⇑f x ≠ x
theorem filter.tendsto.at_bot_add {α : Type u} {β : Type v} [topological_space α] [linear_ordered_add_comm_group α] [order_topology α] {l : filter β} {f g : β → α} {C : α} (hf : filter.tendsto f l filter.at_bot) (hg : filter.tendsto g l (nhds C)) : filter.tendsto (λ (x : β), f x + g x) l filter.at_bot
theorem concave_on.ge_on_segment' {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [linear_ordered_add_comm_monoid β] [has_scalar 𝕜 E] [module 𝕜 β] [ordered_smul 𝕜 β] {s : set E} {f : E → β} (hf : concave_on 𝕜 s f) {x y : E} (hx : x ∈ s) (hy : y ∈ s) {a b : 𝕜} (ha : 0 ≤ a) (hb : 0 ≤ b) (hab : a + b = 1) : linear_order.min (f x) (f y) ≤ f (a • x + b • y)
theorem rack.to_envel_group.univ_uniq (R : Type u_1) [rack R] (G : Type u_2) [group G] (f : shelf_hom R (quandle.conj G)) (g : rack.envel_group R →* G) (h : f = (quandle.conj.map g).comp (rack.to_envel_group R)) : g = ⇑rack.to_envel_group.map f
theorem is_cyclotomic_extension.two_pow_norm_zeta_sub_one {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [ne_zero 2] {k : ℕ} (hk : 2 ≤ k) [is_cyclotomic_extension {2 ^ k} K L] (hirr : irreducible (polynomial.cyclotomic (2 ^ k) K)) : ⇑(algebra.norm K) (is_cyclotomic_extension.zeta (2 ^ k) K L - 1) = 2
theorem is_add_group_hom.mk' {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : ∀ (x y : α), f (x + y) = f x + f y) : is_add_group_hom f
theorem cont_diff.comp {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {n : with_top ℕ} {g : F → G} {f : E → F} (hg : cont_diff 𝕜 n g) (hf : cont_diff 𝕜 n f) : cont_diff 𝕜 n (g ∘ f)
theorem line_map_le_map_iff_slope_le_slope {k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k → E} {a b r : k} (hab : a < b) (h₀ : 0 < r) (h₁ : r < 1) : ⇑(affine_map.line_map (f a) (f b)) r ≤ f (⇑(affine_map.line_map a b) r) ↔ slope f (⇑(affine_map.line_map a b) r) b ≤ slope f a (⇑(affine_map.line_map a b) r)
theorem Top.presheaf.is_sheaf_of_is_sheaf_unique_gluing_types {X : Top} (F : Top.presheaf (Type v) X) (Fsh : F.is_sheaf_unique_gluing) : F.is_sheaf
theorem inner_matrix_row_row {𝕜 : Type u_3} [is_R_or_C 𝕜] {n m : ℕ} (A B : matrix (fin n) (fin m) 𝕜) (i j : fin n) : has_inner.inner (A i) (B j) = B.mul A.conj_transpose j i
theorem sub_mul_action.coe_image_orbit {R : Type u} {M : Type v} [monoid R] [mul_action R M] {p : sub_mul_action R M} (m : ↥p) : coe '' mul_action.orbit R m = mul_action.orbit R ↑m
theorem add_submonoid.closure_induction₂ {M : Type u_1} [add_zero_class M] {s : set M} {p : M → M → Prop} {x y : M} (hx : x ∈ add_submonoid.closure s) (hy : y ∈ add_submonoid.closure s) (Hs : ∀ (x : M), x ∈ s → ∀ (y : M), y ∈ s → p x y) (H1_left : ∀ (x : M), p 0 x) (H1_right : ∀ (x : M), p x 0) (Hmul_left : ∀ (x y z : M), p x z → p y z → p (x + y) z) (Hmul_right : ∀ (x y z : M), p z x → p z y → p z (x + y)) : p x y
theorem is_compact.elim_directed_cover {α : Type u} [topological_space α] {s : set α} {ι : Type v} [hι : nonempty ι] (hs : is_compact s) (U : ι → set α) (hUo : ∀ (i : ι), is_open (U i)) (hsU : s ⊆ ⋃ (i : ι), U i) (hdU : directed has_subset.subset U) : ∃ (i : ι), s ⊆ U i
theorem uniform_space.has_basis_symmetric {α : Type u_1} [uniform_space α] : (uniformity α).has_basis (λ (s : set (α × α)), s ∈ uniformity α ∧ symmetric_rel s) id
theorem monotone_on.map_is_least {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {t : set α} (Hf : monotone_on f t) {a : α} (Ha : is_least t a) : is_least (f '' t) (f a)
theorem strict_convex.vadd {𝕜 : Type u_1} {E : Type u_3} [ordered_semiring 𝕜] [topological_space E] [add_comm_group E] [module 𝕜 E] [has_continuous_add E] {s : set E} (hs : strict_convex 𝕜 s) (x : E) : strict_convex 𝕜 (x +ᵥ s)
theorem measure_theory.integrable.induction {α : Type u_1} {E : Type u_4} [measurable_space α] [normed_group E] {μ : measure_theory.measure α} (P : (α → E) → Prop) (h_ind : ∀ (c : E) ⦃s : set α⦄, measurable_set s → ⇑μ s < ⊤ → P (s.indicator (λ (_x : α), c))) (h_add : ∀ ⦃f g : α → E⦄, disjoint (function.support f) (function.support g) → measure_theory.integrable f μ → measure_theory.integrable g μ → P f → P g → P (f + g)) (h_closed : is_closed {f : ↥(measure_theory.Lp E 1 μ) | P ⇑f}) (h_ae : ∀ ⦃f g : α → E⦄, f =ᵐ[μ] g → measure_theory.integrable f μ → P f → P g) ⦃f : α → E⦄ (hf : measure_theory.integrable f μ) : P f
theorem euclidean_geometry.mul_dist_add_mul_dist_eq_mul_dist_of_cospherical {V : Type u_1} [inner_product_space ℝ V] {P : Type u_2} [metric_space P] [normed_add_torsor V P] {a b c d p : P} (h : euclidean_geometry.cospherical {a, b, c, d}) (hapc : euclidean_geometry.angle a p c = real.pi) (hbpd : euclidean_geometry.angle b p d = real.pi) : has_dist.dist a b * has_dist.dist c d + has_dist.dist b c * has_dist.dist d a = has_dist.dist a c * has_dist.dist b d
theorem int.lt_zpow_iff_log_lt {R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r) : r < ↑b ^ x ↔ int.log b r < x
theorem measurable_set.is_clopenable {α : Type u_1} [topological_space α] [polish_space α] [measurable_space α] [borel_space α] {s : set α} (hs : measurable_set s) : polish_space.is_clopenable s
theorem basis.mk_coord_apply {ι : Type u_1} {R : Type u_3} {M : Type u_5} {v : ι → M} [ring R] [add_comm_group M] [module R M] {hli : linear_independent R v} {hsp : submodule.span R (set.range v) = ⊤} {i j : ι} : ⇑((basis.mk hli hsp).coord i) (v j) = ite (j = i) 1 0
theorem nat.le_two_mul_of_factorization_central_binom_pos {p n : ℕ} (h_pos : 0 < ⇑(n.central_binom.factorization) p) : p ≤ 2 * n
theorem complex.two_pi_I_inv_smul_circle_integral_sub_inv_smul_of_differentiable_on_off_countable {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] {R : ℝ} {c w : ℂ} {f : ℂ → E} {s : set ℂ} (hs : s.countable) (hw : w ∈ metric.ball c R) (hc : continuous_on f (metric.closed_ball c R)) (hd : ∀ (x : ℂ), x ∈ metric.ball c R  s → differentiable_at ℂ f x) : (2 * ↑real.pi * complex.I)⁻¹ • ∮ (z : ℂ) in C(c, R), (z - w)⁻¹ • f z = f w
theorem measure_theory.ae_strongly_measurable'.ae_strongly_measurable'_of_measurable_space_le_on {α : Type u_1} {E : Type u_2} {m m₂ m0 : measurable_space α} {μ : measure_theory.measure α} [topological_space E] [has_zero E] (hm : m ≤ m0) {s : set α} {f : α → E} (hs_m : measurable_set s) (hs : ∀ (t : set α), measurable_set (s ∩ t) → measurable_set (s ∩ t)) (hf : measure_theory.ae_strongly_measurable' m f μ) (hf_zero : f =ᵐ[μ.restrict sᶜ] 0) : measure_theory.ae_strongly_measurable' m₂ f μ
theorem is_connected.bUnion_of_chain {α : Type u} {β : Type v} [topological_space α] [linear_order β] [succ_order β] [is_succ_archimedean β] {s : β → set α} {t : set β} (hnt : t.nonempty) (ht : t.ord_connected) (H : ∀ (n : β), n ∈ t → is_connected (s n)) (K : ∀ (n : β), n ∈ t → order.succ n ∈ t → (s n ∩ s (order.succ n)).nonempty) : is_connected (⋃ (n : β) (H : n ∈ t), s n)
theorem matrix.det_fin_two {R : Type v} [comm_ring R] (A : matrix (fin 2) (fin 2) R) : A.det = A 0 0 * A 1 1 - A 0 1 * A 1 0
theorem ennreal.ae_measurable_of_exist_almost_disjoint_supersets {α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) (f : α → ennreal) (h : ∀ (p q : nnreal), p < q → (∃ (u v : set α), measurable_set u ∧ measurable_set v ∧ {x : α | f x < ↑p} ⊆ u ∧ {x : α | ↑q < f x} ⊆ v ∧ ⇑μ (u ∩ v) = 0)) : ae_measurable f μ
theorem unique_mdiff_within_at.eq {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M → M'} {x : M} {s : set M} [Is : smooth_manifold_with_corners I M] [I's : smooth_manifold_with_corners I' M'] {f' f₁' : tangent_space I x →L[𝕜] tangent_space I' (f x)} (U : unique_mdiff_within_at I s x) (h : has_mfderiv_within_at I I' f s x f') (h₁ : has_mfderiv_within_at I I' f s x f₁') : f' = f₁'
theorem add_monoid.is_torsion.module_of_torsion (R : Type u_3) (M : Type u_4) [add_comm_monoid M] [semiring R] [module R M] (tR : add_monoid.is_torsion R) : add_monoid.is_torsion M
theorem filter.eventually.self_of_nhds {α : Type u} [topological_space α] {p : α → Prop} {a : α} (h : ∀ᶠ (y : α) in nhds a, p y) : p a
theorem of_quotient_center_nilpotent {G : Type u_1} [group G] (h : group.is_nilpotent (G ⧸ subgroup.center G)) : group.is_nilpotent G
theorem monovary.sum_comp_perm_mul_le_sum_mul {ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {σ : equiv.perm ι} {f g : ι → α} [fintype ι] (hfg : monovary f g) : finset.univ.sum (λ (i : ι), f (⇑σ i) * g i) ≤ finset.univ.sum (λ (i : ι), f i * g i)
theorem is_submonoid.image {M : Type u_1} [monoid M] {γ : Type u_2} [monoid γ] {f : M → γ} (hf : is_monoid_hom f) {s : set M} (hs : is_submonoid s) : is_submonoid (f '' s)
theorem linear_map.finrank_linear_map {K : Type u_1} [field K] {V : Type u_2} [add_comm_group V] [module K V] [finite_dimensional K V] {W : Type u_3} [add_comm_group W] [module K W] [finite_dimensional K W] : finite_dimensional.finrank K (V →ₗ[K] W) = finite_dimensional.finrank K V * finite_dimensional.finrank K W
theorem is_p_group.is_nilpotent {G : Type u_1} [hG : group G] [hf : fintype G] {p : ℕ} [hp : fact (nat.prime p)] (h : is_p_group p G) : group.is_nilpotent G
theorem euclidean_geometry.cospherical_singleton {P : Type u_2} [metric_space P] (p : P) : euclidean_geometry.cospherical {p}
theorem generalized_continued_fraction.terminates_iff_rat {K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : (generalized_continued_fraction.of v).terminates ↔ ∃ (q : ℚ), v = ↑q
theorem isometric.midpoint_fixed {E : Type u_1} {PE : Type u_2} [normed_group E] [normed_space ℝ E] [metric_space PE] [normed_add_torsor E PE] {x y : PE} (e : PE ≃ᵢ PE) : ⇑e x = x → ⇑e y = y → ⇑e (midpoint ℝ x y) = midpoint ℝ x y
theorem is_cyclotomic_extension.union_left (S T : set ℕ+) (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] [h : is_cyclotomic_extension T A B] (hS : S ⊆ T) : is_cyclotomic_extension S A ↥(algebra.adjoin A {b : B | ∃ (a : ℕ+), a ∈ S ∧ b ^ ↑a = 1})
theorem is_unit.is_smul_regular {R : Type u_1} (M : Type u_3) {a : R} [monoid R] [mul_action R M] (ua : is_unit a) : is_smul_regular M a
theorem euclidean_geometry.exists_of_range_subset_orthocentric_system {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {t : affine.triangle ℝ P} (ho : t.orthocenter ∉ set.range t.points) {p : fin 3 → P} (hps : set.range p ⊆ has_insert.insert t.orthocenter (set.range t.points)) (hpi : function.injective p) : (∃ (i₁ i₂ i₃ j₂ j₃ : fin 3), i₁ ≠ i₂ ∧ i₁ ≠ i₃ ∧ i₂ ≠ i₃ ∧ (∀ (i : fin 3), i = i₁ ∨ i = i₂ ∨ i = i₃) ∧ p i₁ = t.orthocenter ∧ j₂ ≠ j₃ ∧ t.points j₂ = p i₂ ∧ t.points j₃ = p i₃) ∨ set.range p = set.range t.points
theorem submodule.finite_span_is_compact_element {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (S : set M) (h : S.finite) : complete_lattice.is_compact_element (submodule.span R S)
theorem nat.arithmetic_function.is_multiplicative.multiplicative_factorization {R : Type u_1} [comm_monoid_with_zero R] (f : nat.arithmetic_function R) (hf : f.is_multiplicative) {n : ℕ} : n ≠ 0 → ⇑f n = n.factorization.prod (λ (p k : ℕ), ⇑f (p ^ k))
theorem metric.mk_uniformity_basis_le {α : Type u} [pseudo_metric_space α] {β : Type u_1} {p : β → Prop} {f : β → ℝ} (hf₀ : ∀ (x : β), p x → 0 < f x) (hf : ∀ (ε : ℝ), 0 < ε → (∃ (x : β) (hx : p x), f x ≤ ε)) : (uniformity α).has_basis p (λ (x : β), {p : α × α | has_dist.dist p.fst p.snd ≤ f x})
theorem well_founded.has_min {α : Type u_1} {r : α → α → Prop} (H : well_founded r) (s : set α) : s.nonempty → (∃ (a : α) (H : a ∈ s), ∀ (x : α), x ∈ s → ¬r x a)
theorem orthonormal.orthonormal_adjust_to_orientation {E : Type u_1} [inner_product_space ℝ E] {ι : Type u_2} [fintype ι] [decidable_eq ι] [nonempty ι] {e : basis ι ℝ E} (h : orthonormal ℝ ⇑e) (x : orientation ℝ E ι) : orthonormal ℝ ⇑(e.adjust_to_orientation x)
theorem asymptotics.is_O_const_left_iff_pos_le_norm {α : Type u_1} {E' : Type u_6} {E'' : Type u_9} [semi_normed_group E'] [normed_group E''] {f' : α → E'} {l : filter α} {c : E''} (hc : c ≠ 0) : (λ (x : α), c) =O[l] f' ↔ ∃ (b : ℝ), 0 < b ∧ ∀ᶠ (x : α) in l, b ≤ ∥f' x∥
theorem add_order_of_nsmul {G : Type u} {n : ℕ} [fintype G] [add_left_cancel_monoid G] (x : G) : add_order_of (n • x) = add_order_of x / (add_order_of x).gcd n
theorem measure_theory.measure.ext_of_Ico {α : Type u_1} [topological_space α] {m : measurable_space α} [topological_space.second_countable_topology α] [conditionally_complete_linear_order α] [order_topology α] [borel_space α] [no_max_order α] (μ ν : measure_theory.measure α) [measure_theory.is_locally_finite_measure μ] (h : ∀ ⦃a b : α⦄, a < b → ⇑μ (set.Ico a b) = ⇑ν (set.Ico a b)) : μ = ν
theorem open_map_of_strict_deriv {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] [complete_space 𝕜] {f f' : 𝕜 → 𝕜} (hf : ∀ (x : 𝕜), has_strict_deriv_at f (f' x) x) (h0 : ∀ (x : 𝕜), f' x ≠ 0) : is_open_map f
theorem ideal.comap_eq_of_scalar_tower_quotient {R : Type u_1} [comm_ring R] {S : Type u_2} [comm_ring S] {p : ideal R} {P : ideal S} [algebra R S] [algebra (R ⧸ p) (S ⧸ P)] [is_scalar_tower R (R ⧸ p) (S ⧸ P)] (h : function.injective ⇑(algebra_map (R ⧸ p) (S ⧸ P))) : ideal.comap (algebra_map R S) P = p
theorem submonoid.localization_map.lift_left_inverse {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {k : S.localization_map P} (z : N) : ⇑(k.lift _) (⇑(f.lift _) z) = z
theorem box_integral.prepartition.card_filter_mem_Icc_le {ι : Type u_1} {I : box_integral.box ι} (π : box_integral.prepartition I) [fintype ι] (x : ι → ℝ) : (finset.filter (λ (J : box_integral.box ι), x ∈ ⇑box_integral.box.Icc J) π.boxes).card ≤ 2 ^ fintype.card ι
theorem continuous_at_of_locally_lipschitz {α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {f : α → β} {x : α} {r : ℝ} (hr : 0 < r) (K : ℝ) (h : ∀ (y : α), has_dist.dist y x < r → has_dist.dist (f y) (f x) ≤ K * has_dist.dist y x) : continuous_at f x
theorem measure_theory.measure.eventually_nonempty_inter_smul_of_density_one {E : Type u_1} [normed_group E] [measurable_space E] [normed_space ℝ E] [finite_dimensional ℝ E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (s : set E) (x : E) (h : filter.tendsto (λ (r : ℝ), ⇑μ (s ∩ metric.closed_ball x r) / ⇑μ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds 1)) (t : set E) (ht : measurable_set t) (h't : ⇑μ t ≠ 0) : ∀ᶠ (r : ℝ) in nhds_within 0 (set.Ioi 0), (s ∩ ({x} + r • t)).nonempty
theorem setoid.ker_lift_injective {α : Type u_1} {β : Type u_2} (f : α → β) : function.injective (quotient.lift f _)
theorem convex.norm_image_sub_le_of_norm_deriv_le {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_group G] [normed_space 𝕜 G] {f : 𝕜 → G} {s : set 𝕜} {x y : 𝕜} {C : ℝ} (hf : ∀ (x : 𝕜), x ∈ s → differentiable_at 𝕜 f x) (bound : ∀ (x : 𝕜), x ∈ s → ∥deriv f x∥ ≤ C) (hs : convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∥f y - f x∥ ≤ C * ∥y - x∥
theorem linear_map.range_lt_top_of_det_eq_zero {M : Type u_2} [add_comm_group M] {𝕜 : Type u_1} [field 𝕜] [module 𝕜 M] {f : M →ₗ[𝕜] M} (hf : ⇑linear_map.det f = 0) : f.range < ⊤
theorem emetric.cauchy_seq_iff_le_tendsto_0 {α : Type u_1} {β : Type u_2} [pseudo_emetric_space α] [nonempty β] [semilattice_sup β] {s : β → α} : cauchy_seq s ↔ ∃ (b : β → ennreal), (∀ (n m N : β), N ≤ n → N ≤ m → has_edist.edist (s n) (s m) ≤ b N) ∧ filter.tendsto b filter.at_top (nhds 0)
theorem tendsto_diag_uniformity {α : Type u_1} {β : Type u_2} [uniform_space α] (f : β → α) (l : filter β) : filter.tendsto (λ (x : β), (f x, f x)) l (uniformity α)
theorem set.finite.pi {δ : Type u_1} [fintype δ] {κ : δ → Type u_2} {t : Π (d : δ), set (κ d)} (ht : ∀ (d : δ), (t d).finite) : (set.univ.pi t).finite
theorem con.ker_rel {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] (f : M →* P) {x y : M} : ⇑(con.ker f) x y ↔ ⇑f x = ⇑f y
theorem category_theory.le_topology_of_closed_sieves_is_sheaf {C : Type u} [category_theory.category C] {J₁ J₂ : category_theory.grothendieck_topology C} (h : category_theory.presieve.is_sheaf J₁ (category_theory.functor.closed_sieves J₂)) : J₁ ≤ J₂
theorem subsingleton_rat_module (E : Type u_1) [add_comm_group E] : subsingleton (module ℚ E)
theorem orthonormal.eq_rotation_self_iff {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x : V) (θ : real.angle) : x = ⇑(hb.rotation θ) x ↔ x = 0 ∨ θ = 0
theorem measure_theory.measure.inner_regular.is_compact_is_closed {X : Type u_1} [topological_space X] [sigma_compact_space X] [measurable_space X] (μ : measure_theory.measure X) : μ.inner_regular is_compact is_closed
theorem is_connected_iff_sUnion_disjoint_open {α : Type u} [topological_space α] {s : set α} : is_connected s ↔ ∀ (U : finset (set α)), (∀ (u v : set α), u ∈ U → v ∈ U → (s ∩ (u ∩ v)).nonempty → u = v) → (∀ (u : set α), u ∈ U → is_open u) → s ⊆ ⋃₀↑U → (∃ (u : set α) (H : u ∈ U), s ⊆ u)
theorem add_subgroup.sum_mem {G : Type u_1} [add_comm_group G] (K : add_subgroup G) {ι : Type u_2} {t : finset ι} {f : ι → G} (h : ∀ (c : ι), c ∈ t → f c ∈ K) : t.sum (λ (c : ι), f c) ∈ K
theorem gram_schmidt_def (𝕜 : Type u_1) {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_3} [linear_order ι] [order_bot ι] [locally_finite_order ι] [is_well_order ι has_lt.lt] (f : ι → E) (n : ι) : gram_schmidt 𝕜 f n = f n - (finset.Iio n).sum (λ (i : ι), ↑(⇑(orthogonal_projection (submodule.span 𝕜 {gram_schmidt 𝕜 f i})) (f n)))
theorem category_theory.limits.image.pre_comp_comp {C : Type u} [category_theory.category C] {X Y : C} (f : X ⟶ Y) {Z : C} (g : Y ⟶ Z) {W : C} (h : Z ⟶ W) [category_theory.limits.has_image (g ≫ h)] [category_theory.limits.has_image (f ≫ g ≫ h)] [category_theory.limits.has_image h] [category_theory.limits.has_image ((f ≫ g) ≫ h)] : category_theory.limits.image.pre_comp f (g ≫ h) ≫ category_theory.limits.image.pre_comp g h = category_theory.limits.image.eq_to_hom _ ≫ category_theory.limits.image.pre_comp (f ≫ g) h
theorem list.nat.nodup_antidiagonal (n : ℕ) : (list.nat.antidiagonal n).nodup
theorem formal_multilinear_series.continuous_on {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] {p : formal_multilinear_series 𝕜 E F} [complete_space F] : continuous_on p.sum (emetric.ball 0 p.radius)
theorem category_theory.limits.complete_lattice.finite_limit_eq_finset_univ_inf {α J : Type u} [category_theory.small_category J] [category_theory.fin_category J] [semilattice_inf α] [order_top α] (F : J ⥤ α) : category_theory.limits.limit F = finset.univ.inf F.obj
theorem measure_theory.L1.norm_sub_eq_lintegral {α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [normed_group β] (f g : ↥(measure_theory.Lp β 1 μ)) : ∥f - g∥ = (∫⁻ (x : α), ↑∥⇑f x - ⇑g x∥₊ ∂μ).to_real
theorem nnnorm_pow_le {α : Type u_1} [semi_normed_ring α] [norm_one_class α] (a : α) (n : ℕ) : ∥a ^ n∥₊ ≤ ∥a∥₊ ^ n
theorem is_free_groupoid.ext_functor {G : Type u_1} [category_theory.groupoid G] [is_free_groupoid G] {X : Type v} [group X] (f g : G ⥤ category_theory.single_obj X) (h : ∀ (a b : is_free_groupoid.generators G) (e : a ⟶ b), f.map (is_free_groupoid.of e) = g.map (is_free_groupoid.of e)) : f = g
theorem polynomial.cyclotomic_nonneg (n : ℕ) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 ≤ x) : 0 ≤ polynomial.eval x (polynomial.cyclotomic n R)
theorem matrix.list_prod_inv_reverse {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (l : list (matrix n n α)) : (l.prod)⁻¹ = (list.map has_inv.inv l.reverse).prod
theorem ideal.maximal_of_no_maximal {R : Type u} [semiring R] {P : ideal R} (hmax : ∀ (m : ideal R), P < m → ¬m.is_maximal) (J : ideal R) (hPJ : P < J) : J = ⊤
theorem category_theory.presheaf.is_sheaf_iff_is_limit_pretopology {C : Type u₁} [category_theory.category C] {A : Type u₂} [category_theory.category A] (P : Cᵒᵖ ⥤ A) [category_theory.limits.has_pullbacks C] (K : category_theory.pretopology C) : category_theory.presheaf.is_sheaf (category_theory.pretopology.to_grothendieck C K) P ↔ ∀ ⦃X : C⦄ (R : category_theory.presieve X), R ∈ ⇑K X → nonempty (category_theory.limits.is_limit (P.map_cone (category_theory.sieve.generate R).arrows.cocone.op))
theorem measure_theory.integral_divergence_of_has_fderiv_within_at_off_countable_aux₂ {E : Type u} [normed_group E] [normed_space ℝ E] [complete_space E] {n : ℕ} (I : box_integral.box (fin (n + 1))) (f : (fin (n + 1) → ℝ) → fin (n + 1) → E) (f' : (fin (n + 1) → ℝ) → ((fin (n + 1) → ℝ) →L[ℝ] fin (n + 1) → E)) (s : set (fin (n + 1) → ℝ)) (hs : s.countable) (Hc : continuous_on f (⇑box_integral.box.Icc I)) (Hd : ∀ (x : fin (n + 1) → ℝ), x ∈ ⇑box_integral.box.Ioo I  s → has_fderiv_at f (f' x) x) (Hi : measure_theory.integrable_on (λ (x : fin (n + 1) → ℝ), finset.univ.sum (λ (i : fin (n + 1)), ⇑(f' x) (pi.single i 1) i)) (⇑box_integral.box.Icc I) measure_theory.measure_space.volume) : ∫ (x : fin (n + 1) → ℝ) in ⇑box_integral.box.Icc I, finset.univ.sum (λ (i : fin (n + 1)), ⇑(f' x) (pi.single i 1) i) = finset.univ.sum (λ (i : fin (n + 1)), (∫ (x : fin n → ℝ) in ⇑box_integral.box.Icc (I.face i), f (i.insert_nth (I.upper i) x) i) - ∫ (x : fin n → ℝ) in ⇑box_integral.box.Icc (I.face i), f (i.insert_nth (I.lower i) x) i)
theorem modular_group.abs_c_le_one {g : matrix.special_linear_group (fin 2) ℤ} {z : upper_half_plane} (hz : z ∈ modular_group.fdo) (hg : g • z ∈ modular_group.fdo) : |↑g 1 0| ≤ 1
theorem direct_sum.to_module_lof (R : Type u) [semiring R] {ι : Type v} [dec_ι : decidable_eq ι] {M : ι → Type w} [Π (i : ι), add_comm_monoid (M i)] [Π (i : ι), module R (M i)] {N : Type u₁} [add_comm_monoid N] [module R N] {φ : Π (i : ι), M i →ₗ[R] N} (i : ι) (x : M i) : ⇑(direct_sum.to_module R ι N φ) (⇑(direct_sum.lof R ι M i) x) = ⇑(φ i) x
theorem submodule.smul_sup_le_of_le_smul_of_le_jacobson_bot {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {I : ideal R} {N N' : submodule R M} (hN' : N'.fg) (hIJ : I ≤ ⊥.jacobson) (hNN : N ⊔ N' ≤ N ⊔ I • N') : I • N' ≤ N
theorem finset.eq_zero_of_sum_eq_zero {β : Type u} {α : Type v} [add_comm_monoid β] {s : finset α} {f : α → β} {a : α} (hp : s.sum (λ (x : α), f x) = 0) (h1 : ∀ (x : α), x ∈ s → x ≠ a → f x = 0) (x : α) (H : x ∈ s) : f x = 0
theorem inv_int_cast_smul_eq {E : Type u_1} (R : Type u_2) (S : Type u_3) [add_comm_group E] [division_ring R] [division_ring S] [module R E] [module S E] (n : ℤ) (x : E) : (↑n)⁻¹ • x = (↑n)⁻¹ • x
theorem add_monoid_hom.continuous_of_bound {E : Type u_3} {F : Type u_4} [semi_normed_group E] [semi_normed_group F] (f : E →+ F) (C : ℝ) (h : ∀ (x : E), ∥⇑f x∥ ≤ C * ∥x∥) : continuous ⇑f
theorem is_metric_separated.finset_Union_right {X : Type u_1} [emetric_space X] {ι : Type u_2} {I : finset ι} {s : set X} {t : ι → set X} : (∀ (i : ι), i ∈ I → is_metric_separated s (t i)) → is_metric_separated s (⋃ (i : ι) (H : i ∈ I), t i)
theorem metric.cthickening_subset_thickening' {α : Type u} [pseudo_emetric_space α] {δ₁ δ₂ : ℝ} (δ₂_pos : 0 < δ₂) (hlt : δ₁ < δ₂) (E : set α) : metric.cthickening δ₁ E ⊆ metric.thickening δ₂ E
theorem continuous_map.continuous_of_continuous_uncurry {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] (f : α → C(β, γ)) (h : continuous (function.uncurry (λ (x : α) (y : β), ⇑(f x) y))) : continuous f
theorem exists_compact_between {α : Type u} [topological_space α] [locally_compact_space α] [regular_space α] {K U : set α} (hK : is_compact K) (hU : is_open U) (hKU : K ⊆ U) : ∃ (K' : set α), is_compact K' ∧ K ⊆ interior K' ∧ K' ⊆ U
theorem complex.mem_roots_of_unity (n : ℕ+) (x : ℂˣ) : x ∈ roots_of_unity n ℂ ↔ ∃ (i : ℕ) (H : i < ↑n), complex.exp (2 * ↑real.pi * complex.I * (↑i / ↑n)) = ↑x
theorem collinear_iff_not_affine_independent (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : fin 3 → P) : collinear k (set.range p) ↔ ¬affine_independent k p
theorem continuous_on.mono_dom {α : Type u_1} {β : Type u_2} {t₁ t₂ : topological_space α} {t₃ : topological_space β} (h₁ : t₂ ≤ t₁) {s : set α} {f : α → β} (h₂ : continuous_on f s) : continuous_on f s
theorem cont_mdiff_within_at.comp' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M → M'} {s : set M} {n : with_top ℕ} {E'' : Type u_14} [normed_group E''] [normed_space 𝕜 E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners 𝕜 E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {t : set M'} {g : M' → M''} (x : M) (hg : cont_mdiff_within_at I' I'' n g t (f x)) (hf : cont_mdiff_within_at I I' n f s x) : cont_mdiff_within_at I I'' n (g ∘ f) (s ∩ f ⁻¹' t) x
theorem strict_mono_on.continuous_at_right_of_exists_between {α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_on f s) (hs : s ∈ nhds_within a (set.Ici a)) (hfs : ∀ (b : β), b > f a → (∃ (c : α) (H : c ∈ s), f c ∈ set.Ioc (f a) b)) : continuous_within_at f (set.Ici a) a
theorem algebraic_geometry.PresheafedSpace.comp_c_app {C : Type u} [category_theory.category C] {X Y Z : algebraic_geometry.PresheafedSpace C} (α : X ⟶ Y) (β : Y ⟶ Z) (U : (topological_space.opens ↥(Z.carrier))ᵒᵖ) : (α ≫ β).c.app U = β.c.app U ≫ α.c.app (opposite.op ((topological_space.opens.map β.base).obj (opposite.unop U)))
theorem nat.factorial_mul_desc_factorial {n k : ℕ} : k ≤ n → (n - k).factorial * n.desc_factorial k = n.factorial
theorem cardinal.mk_Ioo_real {a b : ℝ} (h : a < b) : cardinal.mk ↥(set.Ioo a b) = cardinal.continuum
theorem continuous_at.fst' {α : Type u} {β : Type v} {γ : Type u_1} [topological_space α] [topological_space β] [topological_space γ] {f : α → γ} {x : α} {y : β} (hf : continuous_at f x) : continuous_at (λ (x : α × β), f x.fst) (x, y)
theorem measure_theory.measure.restrict_Inf_eq_Inf_restrict {α : Type u_1} {t : set α} {m0 : measurable_space α} {m : set (measure_theory.measure α)} (hm : m.nonempty) (ht : measurable_set t) : (has_Inf.Inf m).restrict t = has_Inf.Inf ((λ (μ : measure_theory.measure α), μ.restrict t) '' m)
theorem iterated_deriv_within_succ {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {n : ℕ} {f : 𝕜 → F} {s : set 𝕜} {x : 𝕜} (hxs : unique_diff_within_at 𝕜 s x) : iterated_deriv_within (n + 1) f s x = deriv_within (iterated_deriv_within n f s) s x
theorem direct_sum.is_internal.subordinate_orthonormal_basis_orthonormal {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [finite_dimensional 𝕜 E] {n : ℕ} (hn : finite_dimensional.finrank 𝕜 E = n) {ι : Type u_4} [fintype ι] [decidable_eq ι] {V : ι → submodule 𝕜 E} (hV : direct_sum.is_internal V) (hV' : orthogonal_family 𝕜 (λ (i : ι), (V i).subtypeₗᵢ)) : orthonormal 𝕜 ⇑(direct_sum.is_internal.subordinate_orthonormal_basis hn hV)
theorem has_fpower_series_on_ball.tendsto_locally_uniformly_on {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] {f : E → F} {p : formal_multilinear_series 𝕜 E F} {x : E} {r : ennreal} (hf : has_fpower_series_on_ball f p x r) : tendsto_locally_uniformly_on (λ (n : ℕ) (y : E), p.partial_sum n y) (λ (y : E), f (x + y)) filter.at_top (emetric.ball 0 r)
theorem emetric.continuous_inf_edist_Hausdorff_edist {α : Type u} [emetric_space α] : continuous (λ (p : α × topological_space.closeds α), emetric.inf_edist p.fst ↑(p.snd))
theorem direct_sum.mk_smul (R : Type u) [semiring R] {ι : Type v} [dec_ι : decidable_eq ι] {M : ι → Type w} [Π (i : ι), add_comm_monoid (M i)] [Π (i : ι), module R (M i)] (s : finset ι) (c : R) (x : Π (i : ↥↑s), M i.val) : ⇑(direct_sum.mk M s) (c • x) = c • ⇑(direct_sum.mk M s) x
theorem edist_le_of_edist_le_geometric_of_tendsto {α : Type u_1} [pseudo_emetric_space α] (r C : ennreal) {f : ℕ → α} (hu : ∀ (n : ℕ), has_edist.edist (f n) (f (n + 1)) ≤ C * r ^ n) {a : α} (ha : filter.tendsto f filter.at_top (nhds a)) (n : ℕ) : has_edist.edist (f n) a ≤ C * r ^ n / (1 - r)
theorem collinear_pair (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (p₁ p₂ : P) : collinear k {p₁, p₂}
theorem finset.shadow_empty {α : Type u_1} [decidable_eq α] : ∅.shadow = ∅
theorem lie_subalgebra.exists_nested_lie_ideal_of_le_normalizer {R : Type u_1} {L : Type u_2} [comm_ring R] [lie_ring L] [lie_algebra R L] {H K : lie_subalgebra R L} (h₁ : H ≤ K) (h₂ : K ≤ H.normalizer) : ∃ (I : lie_ideal R ↥K), ↑I = lie_subalgebra.of_le h₁
theorem is_smul_regular.of_smul {R : Type u_1} {S : Type u_2} {M : Type u_3} {s : S} [has_scalar R M] [has_scalar R S] [has_scalar S M] [is_scalar_tower R S M] (a : R) (ab : is_smul_regular M (a • s)) : is_smul_regular M s
theorem norm_sub_le_of_geometric_bound_of_has_sum {α : Type u_1} [semi_normed_group α] {r C : ℝ} {f : ℕ → α} (hr : r < 1) (hf : ∀ (n : ℕ), ∥f n∥ ≤ C * r ^ n) {a : α} (ha : has_sum f a) (n : ℕ) : ∥(finset.range n).sum (λ (x : ℕ), f x) - a∥ ≤ C * r ^ n / (1 - r)
theorem AddMon.filtered_colimits.colimit_add_aux_eq_of_rel_left {J : Type v} [category_theory.small_category J] (F : J ⥤ AddMon) [category_theory.is_filtered J] {x x' y : Σ (j : J), ↥(F.obj j)} (hxx' : category_theory.limits.types.filtered_colimit.rel (F ⋙ category_theory.forget AddMon) x x') : AddMon.filtered_colimits.colimit_add_aux F x y = AddMon.filtered_colimits.colimit_add_aux F x' y
theorem list.length_pos_of_prod_lt_one {M : Type u_3} [monoid M] [preorder M] (L : list M) (h : L.prod < 1) : 0 < L.length
theorem is_Gδ.union {α : Type u_1} [topological_space α] {s t : set α} (hs : is_Gδ s) (ht : is_Gδ t) : is_Gδ (s ∪ t)
theorem antivary_on.sum_mul_eq_sum_comp_perm_mul_iff {ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {s : finset ι} {σ : equiv.perm ι} {f g : ι → α} (hfg : antivary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f (⇑σ i) * g i) = s.sum (λ (i : ι), f i * g i) ↔ antivary_on (f ∘ ⇑σ) g ↑s
theorem first_order.language.direct_limit.cg {L : first_order.language} {ι : Type u_3} [encodable ι] [preorder ι] [is_directed ι has_le.le] [nonempty ι] {G : ι → Type w} [Π (i : ι), L.Structure (G i)] (f : Π (i j : ι), i ≤ j → L.embedding (G i) (G j)) (h : ∀ (i : ι), first_order.language.Structure.cg L (G i)) [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] : first_order.language.Structure.cg L (first_order.language.direct_limit G f)
theorem orientation.oangle_zero_left {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x : V) : o.oangle 0 x = 0
theorem nat.totient_eq_div_factors_mul (n : ℕ) : n.totient = n / n.factors.to_finset.prod (λ (p : ℕ), p) * n.factors.to_finset.prod (λ (p : ℕ), p - 1)
theorem orientation.oangle_smul_right_self_of_nonneg {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x : V) {r : ℝ} (hr : 0 ≤ r) : o.oangle x (r • x) = 0
theorem category_theory.is_coreflexive_pair.swap {C : Type u} [category_theory.category C] {A B : C} {f g : A ⟶ B} [category_theory.is_coreflexive_pair f g] : category_theory.is_coreflexive_pair g f
theorem is_integral_of_mem_closure' {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (G : set A) (hG : ∀ (x : A), x ∈ G → is_integral R x) (x : A) (H : x ∈ subring.closure G) : is_integral R x
theorem antivary.sum_mul_eq_sum_mul_comp_perm_iff {ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {σ : equiv.perm ι} {f g : ι → α} [fintype ι] (hfg : antivary f g) : finset.univ.sum (λ (i : ι), f i * g (⇑σ i)) = finset.univ.sum (λ (i : ι), f i * g i) ↔ antivary f (g ∘ ⇑σ)
theorem category_theory.has_limits_of_has_limits_creates_limits {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) [category_theory.limits.has_limits_of_size D] [category_theory.creates_limits_of_size F] : category_theory.limits.has_limits_of_size C
theorem real.not_summable_one_div_nat_cast  : ¬summable (λ (n : ℕ), 1 / ↑n)
theorem vitali_family.le_mul_with_density {α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {ρ : measure_theory.measure α} [measure_theory.is_locally_finite_measure ρ] (hρ : ρ.absolutely_continuous μ) {s : set α} (hs : measurable_set s) {t : nnreal} (ht : 1 < t) : ⇑ρ s ≤ ↑t * ⇑(μ.with_density (v.lim_ratio_meas hρ)) s
theorem category_theory.normal_mono_category.epi_of_zero_cancel {C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_kernels C] [category_theory.normal_mono_category C] [category_theory.limits.has_zero_object C] {X Y : C} (f : X ⟶ Y) (hf : ∀ (Z : C) (g : Y ⟶ Z), f ≫ g = 0 → g = 0) : category_theory.epi f
theorem power_series.ext {R : Type u_1} [semiring R] {φ ψ : power_series R} (h : ∀ (n : ℕ), ⇑(power_series.coeff R n) φ = ⇑(power_series.coeff R n) ψ) : φ = ψ
theorem submodule.topological_closure_map {R₁ : Type u_1} {R₂ : Type u_2} [semiring R₁] [semiring R₂] {σ₁₂ : R₁ →+* R₂} {M₁ : Type u_4} [topological_space M₁] [add_comm_monoid M₁] {M₂ : Type u_6} [topological_space M₂] [add_comm_monoid M₂] [module R₁ M₁] [module R₂ M₂] [ring_hom_surjective σ₁₂] [topological_space R₁] [topological_space R₂] [has_continuous_smul R₁ M₁] [has_continuous_add M₁] [has_continuous_smul R₂ M₂] [has_continuous_add M₂] (f : M₁ →SL[σ₁₂] M₂) (s : submodule R₁ M₁) : submodule.map ↑f s.topological_closure ≤ (submodule.map ↑f s).topological_closure
theorem convex_iff_pointwise_add_subset {𝕜 : Type u_1} {E : Type u_2} [ordered_semiring 𝕜] [add_comm_monoid E] [has_scalar 𝕜 E] {s : set E} : convex 𝕜 s ↔ ∀ ⦃a b : 𝕜⦄, 0 ≤ a → 0 ≤ b → a + b = 1 → a • s + b • s ⊆ s
theorem measure_theory.integral_eq_zero_of_add_left_eq_neg {G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure G} {f : G → E} {g : G} [add_group G] [has_measurable_add G] [μ.is_add_left_invariant] (hf' : ∀ (x : G), f (g + x) = -f x) : ∫ (x : G), f x ∂μ = 0
theorem add_hom.srange_top_of_surjective {M : Type u_1} [has_add M] {N : Type u_2} [has_add N] (f : add_hom M N) (hf : function.surjective ⇑f) : f.srange = ⊤
theorem metric.sigma.isometry_mk {ι : Type u_1} {E : ι → Type u_2} [Π (i : ι), metric_space (E i)] (i : ι) : isometry (sigma.mk i)
theorem real.cosh_eq (x : ℝ) : real.cosh x = (real.exp x + real.exp (-x)) / 2
theorem continuous_on.ae_strongly_measurable_of_is_separable {α : Type u_1} {β : Type u_2} [measurable_space α] [topological_space α] [topological_space.pseudo_metrizable_space α] [opens_measurable_space α] [topological_space β] [topological_space.pseudo_metrizable_space β] {f : α → β} {s : set α} {μ : measure_theory.measure α} (hf : continuous_on f s) (hs : measurable_set s) (h's : topological_space.is_separable s) : measure_theory.ae_strongly_measurable f (μ.restrict s)
theorem le_neg_of_le_neg {α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : a ≤ -b → b ≤ -a
theorem has_le.le.eq_or_gt {α : Type u} [partial_order α] {a b : α} (h : a ≤ b) : b = a ∨ a < b
theorem real.coe_fib_eq (n : ℕ) : ↑(nat.fib n) = (golden_ratio ^ n - golden_conj ^ n) / real.sqrt 5
theorem measure_theory.strongly_measurable.integral_prod_left {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} [normed_group E] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] ⦃f : α → β → E⦄ (hf : measure_theory.strongly_measurable (function.uncurry f)) : measure_theory.strongly_measurable (λ (y : β), ∫ (x : α), f x y ∂μ)
theorem nat.set_induction {S : set ℕ} (hb : 0 ∈ S) (h_ind : ∀ (k : ℕ), k ∈ S → k + 1 ∈ S) (n : ℕ) : n ∈ S
theorem cont_diff_bump_of_inner.nonneg' {E : Type u_1} [inner_product_space ℝ E] {c : E} (f : cont_diff_bump_of_inner c) (x : E) : 0 ≤ ⇑f x
theorem tendsto_extend_from {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {A : set X} {f : X → Y} {x : X} (h : ∃ (y : Y), filter.tendsto f (nhds_within x A) (nhds y)) : filter.tendsto f (nhds_within x A) (nhds (extend_from A f x))
theorem module.free.finrank_eq_card_choose_basis_index (R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] : finite_dimensional.finrank R M = fintype.card (module.free.choose_basis_index R M)
theorem first_order.language.substructure.closure_mono {L : first_order.language} {M : Type w} [L.Structure M] ⦃s t : set M⦄ (h : s ⊆ t) : ⇑(first_order.language.substructure.closure L) s ≤ ⇑(first_order.language.substructure.closure L) t
theorem le_of_neg_le_neg {α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : -a ≤ -b → b ≤ a
theorem minpoly.unique (A : Type u_1) {B : Type u_2} [field A] [ring B] [algebra A B] (x : B) {p : polynomial A} (pmonic : p.monic) (hp : ⇑(polynomial.aeval x) p = 0) (pmin : ∀ (q : polynomial A), q.monic → ⇑(polynomial.aeval x) q = 0 → p.degree ≤ q.degree) : p = minpoly A x
theorem matrix.pivot.list_transvec_col_mul_last_row_drop {𝕜 : Type u_3} [field 𝕜] {r : ℕ} (M : matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜) (i : fin r ⊕ unit) {k : ℕ} (hk : k ≤ r) : (list.drop k (matrix.pivot.list_transvec_col M)).prod.mul M (sum.inr ()) i = M (sum.inr ()) i
theorem measure_theory.is_add_fundamental_domain.is_add_left_invariant_map {G : Type u_1} [add_group G] [measurable_space G] [topological_space G] [topological_add_group G] [borel_space G] {μ : measure_theory.measure G} {Γ : add_subgroup G} {𝓕 : set G} (h𝓕 : measure_theory.is_add_fundamental_domain ↥(Γ.opposite) 𝓕 μ) [encodable ↥Γ] [measurable_space (G ⧸ Γ)] [borel_space (G ⧸ Γ)] [Γ.normal] [μ.is_add_left_invariant] [μ.is_add_right_invariant] : (measure_theory.measure.map ⇑(quotient_add_group.mk' Γ) (μ.restrict 𝓕)).is_add_left_invariant
theorem cont_diff_on_top_iff_deriv_of_open {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f₂ : 𝕜 → F} {s₂ : set 𝕜} (hs : is_open s₂) : cont_diff_on 𝕜 ⊤ f₂ s₂ ↔ differentiable_on 𝕜 f₂ s₂ ∧ cont_diff_on 𝕜 ⊤ (deriv f₂) s₂
theorem finset.prod_erase {β : Type u} {α : Type v} [comm_monoid β] [decidable_eq α] (s : finset α) {f : α → β} {a : α} (h : f a = 1) : (s.erase a).prod (λ (x : α), f x) = s.prod (λ (x : α), f x)
theorem group.conj_mem_conjugates_of_set {G : Type u_1} [group G] {s : set G} {x c : G} : x ∈ group.conjugates_of_set s → c * x * c⁻¹ ∈ group.conjugates_of_set s
theorem inv_mul_le_of_le_mul {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α} : a ≤ b * c → b⁻¹ * a ≤ c
theorem ring.eq_self_iff_eq_zero_of_char_ne_two {R : Type u_1} [non_assoc_ring R] [nontrivial R] [no_zero_divisors R] (hR : ring_char R ≠ 2) {a : R} : -a = a ↔ a = 0
theorem add_subgroup.supr_induction {G : Type u_1} [add_group G] {ι : Sort u_2} (S : ι → add_subgroup G) {C : G → Prop} {x : G} (hx : x ∈ ⨆ (i : ι), S i) (hp : ∀ (i : ι) (x : G), x ∈ S i → C x) (h1 : C 0) (hmul : ∀ (x y : G), C x → C y → C (x + y)) : C x
theorem matrix.diagonal_transvection_induction_of_det_ne_zero {n : Type u_1} {𝕜 : Type u_3} [field 𝕜] [decidable_eq n] [fintype n] (P : matrix n n 𝕜 → Prop) (M : matrix n n 𝕜) (hMdet : M.det ≠ 0) (hdiag : ∀ (D : n → 𝕜), (matrix.diagonal D).det ≠ 0 → P (matrix.diagonal D)) (htransvec : ∀ (t : matrix.transvection_struct n 𝕜), P t.to_matrix) (hmul : ∀ (A B : matrix n n 𝕜), A.det ≠ 0 → B.det ≠ 0 → P A → P B → P (A.mul B)) : P M
theorem ite_apply {α : Sort u_1} {σ : α → Sort u_4} (P : Prop) [decidable P] (f g : Π (a : α), σ a) (a : α) : ite P f g a = ite P (f a) (g a)
theorem power_basis.repr_pow_is_integral {S : Type u_2} [comm_ring S] {R : Type u_3} [comm_ring R] [algebra R S] {A : Type u_4} [comm_ring A] [algebra R A] [algebra S A] [is_scalar_tower R S A] {B : power_basis S A} (hB : is_integral R B.gen) [is_domain S] {x : A} (hx : ∀ (i : fin B.dim), is_integral R (⇑(⇑(B.basis.repr) x) i)) (hmin : minpoly S B.gen = polynomial.map (algebra_map R S) (minpoly R B.gen)) (n : ℕ) (i : fin B.dim) : is_integral R (⇑(⇑(B.basis.repr) (x ^ n)) i)
theorem continuous_multilinear_map.map_smul_univ {R : Type u} {ι : Type v} {M₁ : ι → Type w₁} {M₂ : Type w₂} [decidable_eq ι] [comm_semiring R] [Π (i : ι), add_comm_monoid (M₁ i)] [add_comm_monoid M₂] [Π (i : ι), module R (M₁ i)] [module R M₂] [Π (i : ι), topological_space (M₁ i)] [topological_space M₂] (f : continuous_multilinear_map R M₁ M₂) [fintype ι] (c : ι → R) (m : Π (i : ι), M₁ i) : ⇑f (λ (i : ι), c i • m i) = finset.univ.prod (λ (i : ι), c i) • ⇑f m
theorem box_integral.integrable.tendsto_integral_sum_to_filter_Union_single {ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I J : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} [complete_space F] (h : box_integral.integrable I l f vol) (hJ : J ≤ I) : filter.tendsto (box_integral.integral_sum f vol) (l.to_filter_Union I (box_integral.prepartition.single I J hJ)) (nhds (box_integral.integral J l f vol))
theorem char.quadratic_char_sq_one' {F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0) : char.quadratic_char F (a ^ 2) = 1
theorem nhds_within_of_mem_discrete {α : Type u} [topological_space α] {s : set α} [discrete_topology ↥s] {x : α} (hx : x ∈ s) : nhds_within x s = has_pure.pure x
theorem add_le_cancellable.tsub_lt_tsub_iff_left_of_le {α : Type u_1} [canonically_linear_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b c : α} (ha : add_le_cancellable a) (hb : add_le_cancellable b) (h : b ≤ a) : a - b < a - c ↔ c < b
theorem is_fraction_ring.lift_algebra_map {A : Type u_4} [comm_ring A] [is_domain A] {K : Type u_5} [field K] {L : Type u_7} [field L] [algebra A K] [is_fraction_ring A K] {g : A →+* L} (hg : function.injective ⇑g) (x : A) : ⇑(is_fraction_ring.lift hg) (⇑(algebra_map A K) x) = ⇑g x
theorem orientation.oangle_add_oangle_rev {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x y : V) : o.oangle x y + o.oangle y x = 0
theorem affine_subspace.eq_of_direction_eq_of_nonempty_of_le {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s₁ s₂ : affine_subspace k P} (hd : s₁.direction = s₂.direction) (hn : ↑s₁.nonempty) (hle : s₁ ≤ s₂) : s₁ = s₂
theorem Top.sheaf.eq_of_locally_eq' {C : Type u} [category_theory.category C] [category_theory.concrete_category C] [category_theory.limits.has_limits C] [category_theory.reflects_isomorphisms (category_theory.concrete_category.forget C)] [category_theory.limits.preserves_limits (category_theory.concrete_category.forget C)] {X : Top} (F : Top.sheaf C X) {ι : Type v} (U : ι → topological_space.opens ↥X) (V : topological_space.opens ↥X) (iUV : Π (i : ι), U i ⟶ V) (hcover : V ≤ supr U) (s t : ↥(F.val.obj (opposite.op V))) (h : ∀ (i : ι), ⇑(F.val.map (iUV i).op) s = ⇑(F.val.map (iUV i).op) t) : s = t
theorem part.ext' {α : Type u_1} {o p : part α} (H1 : o.dom ↔ p.dom) (H2 : ∀ (h₁ : o.dom) (h₂ : p.dom), o.get h₁ = p.get h₂) : o = p
theorem vector.scanl_nil {α : Type u_1} {β : Type u_2} (f : β → α → β) (b : β) : vector.scanl f b vector.nil = b::ᵥvector.nil
theorem colex.hom_le_iff {α : Type u_1} {β : Type u_2} [linear_order α] [linear_order β] {f : α → β} (h₁ : strict_mono f) (A B : finset α) : (finset.image f A).to_colex ≤ (finset.image f B).to_colex ↔ A.to_colex ≤ B.to_colex
theorem emetric.continuous_inf_edist {α : Type u} [pseudo_emetric_space α] {s : set α} : continuous (λ (x : α), emetric.inf_edist x s)
theorem div_le_div_of_mul_sub_mul_div_nonpos {α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : (a * d - b * c) / (c * d) ≤ 0 → a / c ≤ b / d
theorem topological_space.opens.coe_mk {α : Type u_1} [topological_space α] {U : set α} {hU : is_open U} : ↑⟨U, hU⟩ = U
theorem monovary.sum_mul_comp_perm_lt_sum_mul_iff {ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {σ : equiv.perm ι} {f g : ι → α} [fintype ι] (hfg : monovary f g) : finset.univ.sum (λ (i : ι), f i * g (⇑σ i)) < finset.univ.sum (λ (i : ι), f i * g i) ↔ ¬monovary f (g ∘ ⇑σ)
theorem continuous_at_of_locally_uniform_approx_of_continuous_at {α : Type u_1} {β : Type u_2} [uniform_space β] {f : α → β} {x : α} [topological_space α] (L : ∀ (u : set (β × β)), u ∈ uniformity β → (∃ (t : set α) (H : t ∈ nhds x) (F : α → β), continuous_at F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u)) : continuous_at f x
theorem alexandroff.not_continuous_cofinite_topology_of_symm {X : Type u_1} [topological_space X] [infinite X] [discrete_topology X] : ¬continuous ⇑(cofinite_topology.of.symm)
theorem has_strict_deriv_at_of_has_deriv_at_of_continuous_at {𝕜 : Type u_3} [is_R_or_C 𝕜] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {f f' : 𝕜 → G} {x : 𝕜} (hder : ∀ᶠ (y : 𝕜) in nhds x, has_deriv_at f (f' y) y) (hcont : continuous_at f' x) : has_strict_deriv_at f (f' x) x
theorem fin.coe_val_eq_self {n : ℕ} (a : fin (n + 1)) : ↑(a.val) = a
theorem alternating_group.is_conj_swap_mul_swap_of_cycle_type_two {g : equiv.perm (fin 5)} (ha : g ∈ alternating_group (fin 5)) (h1 : g ≠ 1) (h2 : ∀ (n : ℕ), n ∈ g.cycle_type → n = 2) : is_conj (equiv.swap 0 4 * equiv.swap 1 3) g
theorem topological_fiber_bundle_core.is_open_map_proj {ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : is_open_map Z.proj
theorem lipschitz_on_with.dist_le_mul {α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {K : nnreal} {s : set α} {f : α → β} : lipschitz_on_with K f s → ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → has_dist.dist (f x) (f y) ≤ ↑K * has_dist.dist x y
theorem con.lift_on_coe {M : Type u_1} [has_mul M] {β : Sort u_2} (c : con M) (f : M → β) (h : ∀ (a b : M), ⇑c a b → f a = f b) (x : M) : con.lift_on ↑x f h = f x
theorem probability_theory.strong_law_aux5 {Ω : Type u_1} [measure_theory.measure_space Ω] [measure_theory.is_probability_measure measure_theory.measure_space.volume] (X : ℕ → Ω → ℝ) (hint : measure_theory.integrable (X 0) measure_theory.measure_space.volume) (hident : ∀ (i : ℕ), probability_theory.ident_distrib (X i) (X 0) measure_theory.measure_space.volume measure_theory.measure_space.volume) (hnonneg : ∀ (i : ℕ) (ω : Ω), 0 ≤ X i ω) : ∀ᵐ (ω : Ω), (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), probability_theory.truncation (X i) ↑i ω) - (finset.range n).sum (λ (i : ℕ), X i ω)) =o[filter.at_top] λ (n : ℕ), ↑n
theorem clifford_algebra_quaternion.of_quaternion_conj {R : Type u_1} [comm_ring R] {c₁ c₂ : R} (q : quaternion_algebra R c₁ c₂) : ⇑clifford_algebra_quaternion.of_quaternion (⇑quaternion_algebra.conj q) = ⇑clifford_algebra.involute (⇑clifford_algebra.reverse (⇑clifford_algebra_quaternion.of_quaternion q))
theorem measurable_set.exists_lt_is_closed_of_ne_top {α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [μ.weakly_regular] ⦃A : set α⦄ (hA : measurable_set A) (h'A : ⇑μ A ≠ ⊤) {r : ennreal} (hr : r < ⇑μ A) : ∃ (K : set α) (H : K ⊆ A), is_closed K ∧ r < ⇑μ K
theorem strict_concave_on_of_slope_strict_anti_adjacent {𝕜 : Type u_1} [linear_ordered_field 𝕜] {s : set 𝕜} {f : 𝕜 → 𝕜} (hs : convex 𝕜 s) (hf : ∀ {x y z : 𝕜}, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) < (f y - f x) / (y - x)) : strict_concave_on 𝕜 s f
theorem filter.has_basis.mem_iff {α : Type u_1} {ι : Sort u_4} {l : filter α} {p : ι → Prop} {s : ι → set α} {t : set α} (hl : l.has_basis p s) : t ∈ l ↔ ∃ (i : ι) (hi : p i), s i ⊆ t
theorem finset.sum_fn {α : Type u_1} {β : α → Type u_2} {γ : Type u_3} [Π (a : α), add_comm_monoid (β a)] (s : finset γ) (g : γ → Π (a : α), β a) : s.sum (λ (c : γ), g c) = λ (a : α), s.sum (λ (c : γ), g c a)
theorem continuous_at.integral_sub_linear_is_o_ae {α : Type u_1} {E : Type u_3} [measurable_space α] {ι : Type u_5} [normed_group E] [topological_space α] [opens_measurable_space α] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} [measure_theory.is_locally_finite_measure μ] {a : α} {f : α → E} (ha : continuous_at f a) (hfm : strongly_measurable_at_filter f (nhds a) μ) {s : ι → set α} {li : filter ι} (hs : filter.tendsto s li (nhds a).small_sets) (m : ι → ℝ := λ (i : ι), (⇑μ (s i)).to_real) (hsμ : (λ (i : ι), (⇑μ (s i)).to_real) =ᶠ[li] m . "refl") : (λ (i : ι), ∫ (x : α) in s i, f x ∂μ - m i • f a) =o[li] m
theorem measure_theory.tendsto_in_measure_iff_tendsto_Lp {α : Type u_1} {β : Type u_2} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} {f : ℕ → α → β} {g : α → β} [measure_theory.is_finite_measure μ] (hp : 1 ≤ p) (hp' : p ≠ ⊤) (hf : ∀ (n : ℕ), measure_theory.mem_ℒp (f n) p μ) (hg : measure_theory.mem_ℒp g p μ) : measure_theory.tendsto_in_measure μ f filter.at_top g ∧ measure_theory.unif_integrable f p μ ↔ filter.tendsto (λ (n : ℕ), measure_theory.snorm (f n - g) p μ) filter.at_top (nhds 0)
theorem finset.image₂_distrib_subset_right {α : Type u_1} {α' : Type u_2} {β : Type u_3} {β' : Type u_4} {δ : Type u_7} {ε : Type u_9} [decidable_eq α'] [decidable_eq β'] [decidable_eq δ] [decidable_eq ε] {s : finset α} {t : finset β} {γ : Type u_5} {u : finset γ} {f : δ → γ → ε} {g : α → β → δ} {f₁ : α → γ → α'} {f₂ : β → γ → β'} {g' : α' → β' → ε} (h_distrib : ∀ (a : α) (b : β) (c : γ), f (g a b) c = g' (f₁ a c) (f₂ b c)) : finset.image₂ f (finset.image₂ g s t) u ⊆ finset.image₂ g' (finset.image₂ f₁ s u) (finset.image₂ f₂ t u)
theorem dual_pair.lc_coeffs {R : Type u_1} {M : Type u_2} {ι : Type u_3} [comm_ring R] [add_comm_group M] [module R M] {e : ι → M} {ε : ι → module.dual R M} [decidable_eq ι] (h : dual_pair e ε) (m : M) : dual_pair.lc e (h.coeffs m) = m
theorem fin.snoc_update {n : ℕ} {α : fin (n + 1) → Type u} (x : α (fin.last n)) (p : Π (i : fin n), α (⇑fin.cast_succ i)) (i : fin n) (y : α (⇑fin.cast_succ i)) : fin.snoc (function.update p i y) x = function.update (fin.snoc p x) (⇑fin.cast_succ i) y
theorem comm_sq.map {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) {W X Y Z : C} {f : W ⟶ X} {g : W ⟶ Y} {h : X ⟶ Z} {i : Y ⟶ Z} (s : category_theory.comm_sq f g h i) : category_theory.comm_sq (F.map f) (F.map g) (F.map h) (F.map i)
theorem Gromov_Hausdorff.Hausdorff_dist_optimal {X : Type u} [metric_space X] [compact_space X] [nonempty X] {Y : Type v} [metric_space Y] [compact_space Y] [nonempty Y] : metric.Hausdorff_dist (set.range (Gromov_Hausdorff.optimal_GH_injl X Y)) (set.range (Gromov_Hausdorff.optimal_GH_injr X Y)) = Gromov_Hausdorff.GH_dist X Y
theorem mul_add_mul_le_mul_add_mul' {α : Type u} [ordered_semiring α] {a b c d : α} [has_exists_add_of_le α] (hba : b ≤ a) (hdc : d ≤ c) : a • d + b • c ≤ a • c + b • d
theorem orientation.oangle_zero_right {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x : V) : o.oangle x 0 = 0
theorem metric.thickening_eq_preimage_inf_edist {α : Type u} [pseudo_emetric_space α] (δ : ℝ) (E : set α) : metric.thickening δ E = (λ (x : α), emetric.inf_edist x E) ⁻¹' set.Iio (ennreal.of_real δ)
theorem div_mem {M : Type u_3} {S : Type u_4} [div_inv_monoid M] [set_like S M] [hSM : subgroup_class S M] {H : S} {x y : M} (hx : x ∈ H) (hy : y ∈ H) : x / y ∈ H
theorem affine_independent.not_mem_affine_span_diff {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} [nontrivial k] {p : ι → P} (ha : affine_independent k p) (i : ι) (s : set ι) : p i ∉ affine_span k (p '' (s  {i}))
theorem strict_convex_on.slope_strict_mono_adjacent {𝕜 : Type u_1} [linear_ordered_field 𝕜] {s : set 𝕜} {f : 𝕜 → 𝕜} (hf : strict_convex_on 𝕜 s f) {x y z : 𝕜} (hx : x ∈ s) (hz : z ∈ s) (hxy : x < y) (hyz : y < z) : (f y - f x) / (y - x) < (f z - f y) / (z - y)
theorem measure_theory.lintegral_lintegral_symm {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] ⦃f : α → β → ennreal⦄ (hf : ae_measurable (function.uncurry f) (μ.prod ν)) : ∫⁻ (x : α), ∫⁻ (y : β), f x y ∂ν ∂μ = ∫⁻ (z : β × α), f z.snd z.fst ∂ν.prod μ
theorem affine_independent_set_iff_linear_independent_vsub (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p₁ : P} (hp₁ : p₁ ∈ s) : affine_independent k (λ (p : ↥s), ↑p) ↔ linear_independent k (λ (v : ↥((λ (p : P), p -ᵥ p₁) '' (s  {p₁}))), ↑v)
theorem is_algebraic_algebra_map {R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] [nontrivial R] (x : R) : is_algebraic R (⇑(algebra_map R A) x)
theorem is_of_fin_order.inv {G : Type u} [group G] {x : G} (hx : is_of_fin_order x) : is_of_fin_order x⁻¹
theorem lt_or_lt_iff_ne {α : Type u} [linear_order α] {x y : α} : x < y ∨ y < x ↔ x ≠ y
theorem nat.sum_four_squares (n : ℕ) : ∃ (a b c d : ℕ), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n
theorem reflection_mul_reflection {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) [complete_space ↥K] : reflection K * reflection K = 1
theorem algebra.discr_power_basis_eq_prod (K : Type u) {L : Type v} (E : Type z) [field K] [field L] [field E] [algebra K L] [algebra K E] [module.finite K L] [is_alg_closed E] (pb : power_basis K L) (e : fin pb.dim ≃ (L →ₐ[K] E)) [is_separable K L] : ⇑(algebra_map K E) (algebra.discr K ⇑(pb.basis)) = finset.univ.prod (λ (i : fin pb.dim), (finset.filter (λ (j : fin pb.dim), i < j) finset.univ).prod (λ (j : fin pb.dim), (⇑(⇑e j) pb.gen - ⇑(⇑e i) pb.gen) ^ 2))
theorem cardinal.add_eq_max {a b : cardinal} (ha : cardinal.aleph_0 ≤ a) : a + b = linear_order.max a b
theorem power_basis.repr_mul_is_integral {S : Type u_2} [comm_ring S] {R : Type u_3} [comm_ring R] [algebra R S] {A : Type u_4} [comm_ring A] [algebra R A] [algebra S A] [is_scalar_tower R S A] {B : power_basis S A} (hB : is_integral R B.gen) [is_domain S] {x y : A} (hx : ∀ (i : fin B.dim), is_integral R (⇑(⇑(B.basis.repr) x) i)) (hy : ∀ (i : fin B.dim), is_integral R (⇑(⇑(B.basis.repr) y) i)) (hmin : minpoly S B.gen = polynomial.map (algebra_map R S) (minpoly R B.gen)) (i : fin B.dim) : is_integral R (⇑(⇑(B.basis.repr) (x * y)) i)
theorem multilinear_map.comp_linear_map_id {R : Type u} {ι : Type u'} {M₂ : Type v₂} [decidable_eq ι] [semiring R] [add_comm_monoid M₂] [module R M₂] {M₁' : ι → Type u_1} [Π (i : ι), add_comm_monoid (M₁' i)] [Π (i : ι), module R (M₁' i)] (g : multilinear_map R M₁' M₂) : g.comp_linear_map (λ (i : ι), linear_map.id) = g
theorem ennreal.cancel_of_ne {a : ennreal} (h : a ≠ ⊤) : add_le_cancellable a
theorem continuous.comp_ae_strongly_measurable {α : Type u_1} {β : Type u_2} {γ : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [topological_space β] [topological_space γ] {g : β → γ} {f : α → β} (hg : continuous g) (hf : measure_theory.ae_strongly_measurable f μ) : measure_theory.ae_strongly_measurable (λ (x : α), g (f x)) μ
theorem compact_space.uniform_continuous_of_continuous {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] [compact_space α] [separated_space α] {f : α → β} (h : continuous f) : uniform_continuous f
theorem order.embedding_from_countable_to_dense (α : Type u_1) (β : Type u_2) [linear_order α] [linear_order β] [encodable α] [densely_ordered β] [nontrivial β] : nonempty (α ↪o β)
theorem box_integral.prepartition.not_disjoint_imp_le_of_subset_of_mem_split_many {ι : Type u_1} {I J Js : box_integral.box ι} {s : finset (ι × ℝ)} (H : ∀ (i : ι), {(i, J.lower i), (i, J.upper i)} ⊆ s) (HJs : Js ∈ box_integral.prepartition.split_many I s) (Hn : ¬disjoint ↑J ↑Js) : Js ≤ J
theorem dvd_add_left {α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ c) : a ∣ b + c ↔ a ∣ b
theorem category_theory.presieve.restrict_inj {C : Type u₁} [category_theory.category C] {P : Cᵒᵖ ⥤ Type w} {X : C} {R : category_theory.presieve X} {x₁ x₂ : category_theory.presieve.family_of_elements P ⇑(category_theory.sieve.generate R)} (t₁ : x₁.compatible) (t₂ : x₂.compatible) : category_theory.presieve.family_of_elements.restrict _ x₁ = category_theory.presieve.family_of_elements.restrict _ x₂ → x₁ = x₂
theorem cont_diff_on.neg {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : with_top ℕ} {s : set E} {f : E → F} (hf : cont_diff_on 𝕜 n f s) : cont_diff_on 𝕜 n (λ (x : E), -f x) s
theorem has_deriv_at_integral_of_dominated_loc_of_deriv_le {α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {𝕜 : Type u_2} [is_R_or_C 𝕜] {E : Type u_3} [normed_group E] [normed_space ℝ E] [normed_space 𝕜 E] [complete_space E] {F F' : 𝕜 → α → E} {x₀ : 𝕜} {ε : ℝ} (ε_pos : 0 < ε) (hF_meas : ∀ᶠ (x : 𝕜) in nhds x₀, measure_theory.ae_strongly_measurable (F x) μ) (hF_int : measure_theory.integrable (F x₀) μ) (hF'_meas : measure_theory.ae_strongly_measurable (F' x₀) μ) {bound : α → ℝ} (h_bound : ∀ᵐ (a : α) ∂μ, ∀ (x : 𝕜), x ∈ metric.ball x₀ ε → ∥F' x a∥ ≤ bound a) (bound_integrable : measure_theory.integrable bound μ) (h_diff : ∀ᵐ (a : α) ∂μ, ∀ (x : 𝕜), x ∈ metric.ball x₀ ε → has_deriv_at (λ (x : 𝕜), F x a) (F' x a) x) : measure_theory.integrable (F' x₀) μ ∧ has_deriv_at (λ (n : 𝕜), ∫ (a : α), F n a ∂μ) (∫ (a : α), F' x₀ a ∂μ) x₀
theorem tfae_mem_nhds_within_Iio {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a b : α} (h : a < b) (s : set α) : [s ∈ nhds_within b (set.Iio b), s ∈ nhds_within b (set.Ico a b), s ∈ nhds_within b (set.Ioo a b), ∃ (l : α) (H : l ∈ set.Ico a b), set.Ioo l b ⊆ s, ∃ (l : α) (H : l ∈ set.Iio b), set.Ioo l b ⊆ s].tfae
theorem function.injective.tendsto_cofinite {α : Type u_2} {β : Type u_3} {f : α → β} (hf : function.injective f) : filter.tendsto f filter.cofinite filter.cofinite
theorem bounded_continuous_function.continuous_eval_const {α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {x : α} : continuous (λ (f : bounded_continuous_function α β), ⇑f x)
theorem eq_of_nndist_eq_zero {γ : Type w} [metric_space γ] {x y : γ} : has_nndist.nndist x y = 0 → x = y
theorem add_monoid_algebra.fg_of_finite_type {R : Type u_1} {M : Type u_2} [add_comm_monoid M] [comm_ring R] [nontrivial R] [h : algebra.finite_type R (add_monoid_algebra R M)] : add_monoid.fg M
theorem interior_singleton {α : Type u} [topological_space α] (x : α) [(nhds_within x {x}ᶜ).ne_bot] : interior {x} = ∅
theorem matrix.mv_polynomial_X_map_eval₂ {m : Type u_1} {n : Type u_2} {R : Type u_3} {S : Type u_4} [comm_semiring R] [comm_semiring S] (f : R →+* S) (A : matrix m n S) : (matrix.mv_polynomial_X m n R).map (mv_polynomial.eval₂ f (λ (p : m × n), A p.fst p.snd)) = A
theorem submonoid.localization_map.lift_mk' {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M →* P} (hg : ∀ (y : ↥S), is_unit (⇑g ↑y)) (x : M) (y : ↥S) : ⇑(f.lift hg) (f.mk' x y) = ⇑g x * ↑(⇑(is_unit.lift_right (g.restrict S) hg) y)⁻¹
theorem add_submonoid.closure_mono {M : Type u_1} [add_zero_class M] ⦃s t : set M⦄ (h : s ⊆ t) : add_submonoid.closure s ≤ add_submonoid.closure t
theorem list.subperm_append_diff_self_of_count_le {α : Type uu} [decidable_eq α] {l₁ l₂ : list α} (h : ∀ (x : α), x ∈ l₁ → list.count x l₁ ≤ list.count x l₂) : l₁ ++ l₂.diff l₁ ~ l₂
theorem function.commute.inv_on_fixed_pts_comp {α : Type u} {f g : α → α} (h : function.commute f g) : set.inv_on f g (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g))
theorem euclidean_geometry.angle_eq_right {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (p1 p2 : P) : euclidean_geometry.angle p1 p2 p2 = real.pi / 2
theorem orthonormal.two_zsmul_oangle_neg_right {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x y : V) : 2 • hb.oangle x (-y) = 2 • hb.oangle x y
theorem eventually_ne_of_tendsto_norm_at_top {α : Type u_1} {E : Type u_3} [semi_normed_group E] {l : filter α} {f : α → E} (h : filter.tendsto (λ (y : α), ∥f y∥) l filter.at_top) (x : E) : ∀ᶠ (y : α) in l, f y ≠ x
theorem set.Iio_subset_Iic {α : Type u_1} [preorder α] {a b : α} (h : a ≤ b) : set.Iio a ⊆ set.Iic b
theorem is_regular.pow {R : Type u_1} {a : R} [monoid R] (n : ℕ) (ra : is_regular a) : is_regular (a ^ n)
theorem function.injective.is_domain {α : Type u_2} {β : Type u_3} [ring α] [is_domain α] [ring β] (f : β →+* α) (hf : function.injective ⇑f) : is_domain β
theorem map_cinfi_of_continuous_at_of_monotone {α : Type u} {β : Type v} {γ : Type w} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [conditionally_complete_linear_order β] [topological_space β] [order_topology β] [nonempty γ] {f : α → β} {g : γ → α} (Cf : continuous_at f (⨅ (i : γ), g i)) (Mf : monotone f) (H : bdd_below (set.range g)) : f (⨅ (i : γ), g i) = ⨅ (i : γ), f (g i)
theorem fintype.exists_ne_map_eq_of_card_lt {α : Type u_1} {β : Type u_2} [fintype α] [fintype β] (f : α → β) (h : fintype.card β < fintype.card α) : ∃ (x y : α), x ≠ y ∧ f x = f y
theorem finite_dimensional.nontrivial_of_finrank_eq_succ {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {n : ℕ} (hn : finite_dimensional.finrank K V = n.succ) : nontrivial V
theorem interval_integral.deriv_integral_right {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (hb : continuous_at f b) : deriv (λ (u : ℝ), ∫ (x : ℝ) in a..u, f x) b = f b
theorem polynomial.coeff_mul {R : Type u} [semiring R] (p q : polynomial R) (n : ℕ) : (p * q).coeff n = (finset.nat.antidiagonal n).sum (λ (x : ℕ × ℕ), p.coeff x.fst * q.coeff x.snd)
theorem bounded_continuous_function.arzela_ascoli₂ {α : Type u} {β : Type v} [topological_space α] [compact_space α] [pseudo_metric_space β] (s : set β) (hs : is_compact s) (A : set (bounded_continuous_function α β)) (closed : is_closed A) (in_s : ∀ (f : bounded_continuous_function α β) (x : α), f ∈ A → ⇑f x ∈ s) (H : ∀ (x : α) (ε : ℝ), ε > 0 → (∃ (U : set α) (H : U ∈ nhds x), ∀ (y : α), y ∈ U → ∀ (z : α), z ∈ U → ∀ (f : bounded_continuous_function α β), f ∈ A → has_dist.dist (⇑f y) (⇑f z) < ε)) : is_compact A
theorem is_localization.monoid_hom_ext {R : Type u_1} [comm_semiring R] (M : submonoid R) {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] ⦃j k : S →* P⦄ (h : j.comp ↑(algebra_map R S) = k.comp ↑(algebra_map R S)) : j = k
theorem Top.sheaf.pushforward_sheaf_of_sheaf {C : Type u₁} [category_theory.category C] {X Y : Top} (f : X ⟶ Y) [category_theory.limits.has_products C] {F : Top.presheaf C X} (h : F.is_sheaf) : (f _* F).is_sheaf
theorem real.tendsto_pow_mul_exp_neg_at_top_nhds_0 (n : ℕ) : filter.tendsto (λ (x : ℝ), x ^ n * real.exp (-x)) filter.at_top (nhds 0)
theorem finset.affine_combination_apply_const {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (w : ι → k) (p : P) (h : s.sum (λ (i : ι), w i) = 1) : ⇑(s.affine_combination (λ (_x : ι), p)) w = p
theorem is_compact.bdd_below {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] [nonempty α] {s : set α} (hs : is_compact s) : bdd_below s
theorem measure_theory.is_open_pos_measure_of_add_left_invariant_of_compact {G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {μ : measure_theory.measure G} [add_group G] [topological_add_group G] [μ.is_add_left_invariant] (K : set G) (hK : is_compact K) (h : ⇑μ K ≠ 0) : μ.is_open_pos_measure
theorem is_topological_fiber_bundle.continuous_proj {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : continuous proj
theorem topological_semiring.has_continuous_neg_of_mul {α : Type u_1} [topological_space α] [non_assoc_ring α] [has_continuous_mul α] : has_continuous_neg α
theorem metric.self_subset_cthickening {α : Type u} [pseudo_emetric_space α] {δ : ℝ} (E : set α) : E ⊆ metric.cthickening δ E
theorem mem_affine_span (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {p : P} {s : set P} (hp : p ∈ s) : p ∈ affine_span k s
theorem subalgebra.is_algebraic_iff {R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] (S : subalgebra R A) : S.is_algebraic ↔ algebra.is_algebraic R ↥S
theorem bdd_above.mono {α : Type u} [preorder α] ⦃s t : set α⦄ (h : s ⊆ t) : bdd_above t → bdd_above s
theorem has_binary_coproducts_of_initial_and_pushouts (C : Type u) [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_pushouts C] : category_theory.limits.has_binary_coproducts C
theorem convolution_lsmul {𝕜 : Type u_1} {G : Type u_2} {F : Type u_6} [normed_group F] {x : G} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 F] [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ F] [complete_space F] [has_sub G] {f : G → 𝕜} {g : G → F} : convolution f g (continuous_linear_map.lsmul 𝕜 𝕜) μ x = ∫ (t : G), f t • g (x - t) ∂μ
theorem tensor_algebra.induction {R : Type u_1} [comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {C : tensor_algebra R M → Prop} (h_grade0 : ∀ (r : R), C (⇑(algebra_map R (tensor_algebra R M)) r)) (h_grade1 : ∀ (x : M), C (⇑(tensor_algebra.ι R) x)) (h_mul : ∀ (a b : tensor_algebra R M), C a → C b → C (a * b)) (h_add : ∀ (a b : tensor_algebra R M), C a → C b → C (a + b)) (a : tensor_algebra R M) : C a
theorem tendsto_le_of_eventually_le {α : Type u} {β : Type v} [topological_space α] [preorder α] [t : order_closed_topology α] {f g : β → α} {b : filter β} {a₁ a₂ : α} [b.ne_bot] (hf : filter.tendsto f b (nhds a₁)) (hg : filter.tendsto g b (nhds a₂)) (h : f ≤ᶠ[b] g) : a₁ ≤ a₂
theorem finset.induction_on_max {α : Type u_1} [linear_order α] [decidable_eq α] {p : finset α → Prop} (s : finset α) (h0 : p ∅) (step : ∀ (a : α) (s : finset α), (∀ (x : α), x ∈ s → x < a) → p s → p (has_insert.insert a s)) : p s
theorem modular_group.bottom_row_coprime {R : Type u_1} [comm_ring R] (g : matrix.special_linear_group (fin 2) R) : is_coprime (↑g 1 0) (↑g 1 1)
theorem int.exists_strict_anti (α : Type u) [preorder α] [nonempty α] [no_min_order α] [no_max_order α] : ∃ (f : ℤ → α), strict_anti f
theorem continuous.tendsto_uniformly {α : Type u_1} {β : Type u_2} {γ : Type u_3} [uniform_space α] [uniform_space β] [separated_space α] [locally_compact_space α] [compact_space β] [separated_space β] [uniform_space γ] (f : α → β → γ) (h : continuous ↿f) (x : α) : tendsto_uniformly f (f x) (nhds x)
theorem union_mem_uniformity_sum {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] {a : set (α × α)} (ha : a ∈ uniformity α) {b : set (β × β)} (hb : b ∈ uniformity β) : (λ (p : α × α), (sum.inl p.fst, sum.inl p.snd)) '' a ∪ (λ (p : β × β), (sum.inr p.fst, sum.inr p.snd)) '' b ∈ uniform_space.core.sum.uniformity
theorem number_field.class_number_eq_one_iff {K : Type u_1} [field K] [number_field K] : number_field.class_number K = 1 ↔ is_principal_ideal_ring ↥(number_field.ring_of_integers K)
theorem inner_product_geometry.norm_sub_eq_add_norm_iff_angle_eq_pi {V : Type u_1} [inner_product_space ℝ V] {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : ∥x - y∥ = ∥x∥ + ∥y∥ ↔ inner_product_geometry.angle x y = real.pi
theorem continuous_equiv_fun_basis {𝕜 : Type u} [hnorm : nondiscrete_normed_field 𝕜] {E : Type v} [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_smul 𝕜 E] [complete_space 𝕜] [t2_space E] {ι : Type u_1} [fintype ι] (ξ : basis ι 𝕜 E) : continuous ⇑(ξ.equiv_fun)
theorem continuous_linear_map.tendsto_of_tendsto_pointwise_of_cauchy_seq {𝕜 : Type u_1} {𝕜₂ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {E' : Type u_10} [semi_normed_group E'] [normed_space 𝕜 E'] [ring_hom_isometric σ₁₂] {f : ℕ → (E' →SL[σ₁₂] F)} {g : E' →SL[σ₁₂] F} (hg : filter.tendsto (λ (n : ℕ) (x : E'), ⇑(f n) x) filter.at_top (nhds ⇑g)) (hf : cauchy_seq f) : filter.tendsto f filter.at_top (nhds g)
theorem interval_integral.integral_has_deriv_within_at_left {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set ℝ} [interval_integral.FTC_filter a (nhds_within a s) (nhds_within a t)] (hmeas : strongly_measurable_at_filter f (nhds_within a t) measure_theory.measure_space.volume) (ha : continuous_within_at f t a) : has_deriv_within_at (λ (u : ℝ), ∫ (x : ℝ) in u..b, f x) (-f a) s a
theorem orientation.rotation_eq_self_iff {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x : V) (θ : real.angle) : ⇑(o.rotation θ) x = x ↔ x = 0 ∨ θ = 0
theorem subsemiring.coe_closure_eq {R : Type u} [non_assoc_semiring R] (s : set R) : ↑(subsemiring.closure s) = ↑(add_submonoid.closure ↑(submonoid.closure s))
theorem orthonormal.inner_left_right_finset {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {s : finset ι} {v : ι → E} (hv : orthonormal 𝕜 v) {a : ι → ι → 𝕜} : s.sum (λ (i : ι), s.sum (λ (j : ι), a i j • has_inner.inner (v j) (v i))) = s.sum (λ (k : ι), a k k)
theorem monoid.image_closure {M : Type u_1} [monoid M] {A : Type u_2} [monoid A] {f : M → A} (hf : is_monoid_hom f) (s : set M) : f '' monoid.closure s = monoid.closure (f '' s)
theorem linear_equiv.nonempty_equiv_iff_dim_eq {K : Type u} {V V₁ : Type v} [division_ring K] [add_comm_group V] [module K V] [add_comm_group V₁] [module K V₁] : nonempty (V ≃ₗ[K] V₁) ↔ module.rank K V = module.rank K V₁
theorem weak_dual.is_closed_image_coe_of_bounded_of_closed {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [semi_normed_group E] [normed_space 𝕜 E] {s : set (weak_dual 𝕜 E)} (hb : metric.bounded (⇑normed_space.dual.to_weak_dual ⁻¹' s)) (hc : is_closed s) : is_closed (coe_fn '' s)
theorem local_homeomorph.eq_on_source.eq_on {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {e e' : local_homeomorph α β} (h : e ≈ e') : set.eq_on ⇑e ⇑e' e.to_local_equiv.source
theorem nat.floor_div_eq_div {α : Type u_1} [linear_ordered_field α] [floor_semiring α] (m n : ℕ) : ⌊↑m / ↑n⌋₊ = m / n
theorem is_alg_closed.ring_equiv_of_cardinal_eq_of_char_eq {K L : Type} [field K] [field L] [is_alg_closed K] [is_alg_closed L] (p : ℕ) [char_p K p] [char_p L p] (hK : cardinal.aleph_0 < cardinal.mk K) (hKL : cardinal.mk K = cardinal.mk L) : K ≃+* L
theorem discrete_topology_of_discrete_uniformity {α : Type u_1} [hα : uniform_space α] (h : uniformity α = filter.principal id_rel) : discrete_topology α
theorem nat.digits_lt_base {b m d : ℕ} (hb : 2 ≤ b) (hd : d ∈ b.digits m) : d < b
theorem exists_smooth_zero_one_of_closed {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] (I : model_with_corners ℝ E H) {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] [t2_space M] [sigma_compact_space M] {s t : set M} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : ∃ (f : cont_mdiff_map I (model_with_corners_self ℝ ℝ) M ℝ ⊤), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : M), ⇑f x ∈ set.Icc 0 1
theorem orientation.oangle_rotation_right {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : real.angle) : o.oangle x (⇑(o.rotation θ) y) = o.oangle x y + θ
theorem homeomorph.is_O_congr {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {E : Type u_3} [has_norm E] {F : Type u_4} [has_norm F] (e : α ≃ₜ β) {b : β} {f : β → E} {g : β → F} : f =O[nhds b] g ↔ (f ∘ ⇑e) =O[nhds (⇑(e.symm) b)] (g ∘ ⇑e)
theorem real.subgroup_dense_or_cyclic (G : add_subgroup ℝ) : dense ↑G ∨ ∃ (a : ℝ), G = add_subgroup.closure {a}
theorem fin.strict_mono_iff_lt_succ {n : ℕ} {α : Type u_1} [preorder α] {f : fin (n + 1) → α} : strict_mono f ↔ ∀ (i : fin n), f (⇑fin.cast_succ i) < f i.succ
theorem is_integral_localization {R : Type u_1} [comm_ring R] {M : submonoid R} {S : Type u_2} [comm_ring S] [algebra R S] {Rₘ : Type u_4} {Sₘ : Type u_5} [comm_ring Rₘ] [comm_ring Sₘ] [algebra R Rₘ] [is_localization M Rₘ] [algebra S Sₘ] [is_localization (algebra.algebra_map_submonoid S M) Sₘ] (H : algebra.is_integral R S) : (is_localization.map Sₘ (algebra_map R S) _).is_integral
theorem category_theory.has_initial_of_weakly_initial_and_has_wide_equalizers {C : Type u} [category_theory.category C] [category_theory.limits.has_wide_equalizers C] {T : C} (hT : ∀ (X : C), nonempty (T ⟶ X)) : category_theory.limits.has_initial C
theorem pgame.lf_iff_forall_le {x y : pgame} : x.lf y ↔ (∃ (i : y.left_moves), x ≤ y.move_left i) ∨ ∃ (j : x.right_moves), x.move_right j ≤ y
theorem orientation.oangle_rotation_self_right {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x : V} (hx : x ≠ 0) (θ : real.angle) : o.oangle x (⇑(o.rotation θ) x) = θ
theorem is_torsion.extension_closed {G : Type u_1} {H : Type u_2} [group G] {N : subgroup G} [group H] {f : G →* H} (hN : N = f.ker) (tH : monoid.is_torsion H) (tN : monoid.is_torsion ↥N) : monoid.is_torsion G
theorem local_equiv.trans_symm_self {α : Type u_1} {β : Type u_2} (e : local_equiv α β) : e.symm.trans e ≈ local_equiv.of_set e.target
theorem fintype.induction_empty_option' {P : Π (α : Type u) [_inst_1 : fintype α], Prop} (of_equiv : ∀ (α β : Type u) [_inst_2 : fintype β] (e : α ≃ β), P α → P β) (h_empty : P pempty) (h_option : ∀ (α : Type u) [_inst_3 : fintype α], P α → P (option α)) (α : Type u) [fintype α] : P α
theorem function.semiconj.symm_adjoint {α : Type u_1} {β : Type u_2} [partial_order α] [preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β} (h : function.semiconj g ⇑fa ⇑fb) {g' : β → α} (hg' : is_order_right_adjoint g g') : function.semiconj g' ⇑fb ⇑fa
theorem simple_graph.to_graph_adj_matrix_eq {V : Type u_1} (α : Type u_2) (G : simple_graph V) [decidable_rel G.adj] [mul_zero_one_class α] [nontrivial α] : _.to_graph = G
theorem local_equiv.eq_on_source.symm_eq_on {α : Type u_1} {β : Type u_2} {e e' : local_equiv α β} (h : e ≈ e') : set.eq_on ⇑(e.symm) ⇑(e'.symm) e.target
theorem measure_theory.mem_ℒp.induction {α : Type u_1} {E : Type u_4} [measurable_space α] [normed_group E] {p : ennreal} {μ : measure_theory.measure α} [fact (1 ≤ p)] (hp_ne_top : p ≠ ⊤) (P : (α → E) → Prop) (h_ind : ∀ (c : E) ⦃s : set α⦄, measurable_set s → ⇑μ s < ⊤ → P (s.indicator (λ (_x : α), c))) (h_add : ∀ ⦃f g : α → E⦄, disjoint (function.support f) (function.support g) → measure_theory.mem_ℒp f p μ → measure_theory.mem_ℒp g p μ → P f → P g → P (f + g)) (h_closed : is_closed {f : ↥(measure_theory.Lp E p μ) | P ⇑f}) (h_ae : ∀ ⦃f g : α → E⦄, f =ᵐ[μ] g → measure_theory.mem_ℒp f p μ → P f → P g) ⦃f : α → E⦄ (hf : measure_theory.mem_ℒp f p μ) : P f
theorem category_theory.limits.has_equalizers_of_pullbacks_and_binary_products {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_pullbacks C] : category_theory.limits.has_equalizers C
theorem submodule.is_torsion'_iff_torsion'_eq_top {R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] (S : Type u_3) [comm_monoid S] [distrib_mul_action S M] [smul_comm_class S R M] : module.is_torsion' M S ↔ submodule.torsion' R M S = ⊤
theorem double_quot.ker_quot_left_to_quot_sup {R : Type u} [comm_ring R] (I J : ideal R) : (double_quot.quot_left_to_quot_sup I J).ker = ideal.map (ideal.quotient.mk I) J
theorem is_closed_std_simplex (ι : Type u_1) [fintype ι] : is_closed (std_simplex ℝ ι)
theorem order.succ_lt_succ {α : Type u_1} [preorder α] [succ_order α] {a b : α} [no_max_order α] : a < b → order.succ a < order.succ b
theorem inner_product_geometry.angle_add_angle_eq_pi_of_angle_eq_pi {V : Type u_1} [inner_product_space ℝ V] {x y : V} (z : V) (h : inner_product_geometry.angle x y = real.pi) : inner_product_geometry.angle x z + inner_product_geometry.angle y z = real.pi
theorem cont_mdiff.continuous_tangent_map {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M → M'} {n : with_top ℕ} (hf : cont_mdiff I I' n f) (hmn : 1 ≤ n) : continuous (tangent_map I I' f)
theorem orientation.oangle_eq_iff_eq_norm_div_norm_smul_rotation_or_eq_zero {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y : V} (θ : real.angle) : o.oangle x y = θ ↔ x ≠ 0 ∧ y ≠ 0 ∧ y = (∥y∥ / ∥x∥) • ⇑(o.rotation θ) x ∨ θ = 0 ∧ (x = 0 ∨ y = 0)
theorem finset.sum_insert_of_eq_zero_if_not_mem {β : Type u} {α : Type v} {s : finset α} {a : α} {f : α → β} [add_comm_monoid β] [decidable_eq α] (h : a ∉ s → f a = 0) : (has_insert.insert a s).sum (λ (x : α), f x) = s.sum (λ (x : α), f x)
theorem infi_ne_top_subtype {α : Type u_1} {ι : Sort u_4} [complete_lattice α] (f : ι → α) : (⨅ (i : {i // f i ≠ ⊤}), f ↑i) = ⨅ (i : ι), f i
theorem measure_theory.lintegral_supr_ae {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : ℕ → α → ennreal} (hf : ∀ (n : ℕ), measurable (f n)) (h_mono : ∀ (n : ℕ), ∀ᵐ (a : α) ∂μ, f n a ≤ f n.succ a) : ∫⁻ (a : α), (⨆ (n : ℕ), f n a) ∂μ = ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
theorem finsum_mem_image' {α : Type u_1} {β : Type u_2} {M : Type u_5} [add_comm_monoid M] {f : α → M} {s : set β} {g : β → α} (hg : set.inj_on g (s ∩ function.support (f ∘ g))) : finsum (λ (i : α), finsum (λ (H : i ∈ g '' s), f i)) = finsum (λ (j : β), finsum (λ (H : j ∈ s), f (g j)))
theorem metric.Hausdorff_dist_self_closure {α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist s (closure s) = 0
theorem submodule.norm_coe {𝕜 : Type u_1} {_x : ring 𝕜} {E : Type u_2} [semi_normed_group E] {_x_1 : module 𝕜 E} {s : submodule 𝕜 E} (x : ↥s) : ∥↑x∥ = ∥x∥
theorem mvqpf.cofix.bisim₂ {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} (r : mvqpf.cofix F α → mvqpf.cofix F α → Prop) (h : ∀ (x y : mvqpf.cofix F α), r x y → mvfunctor.liftr' (α.rel_last' r) x.dest y.dest) (x y : mvqpf.cofix F α) : r x y → x = y
theorem category_theory.limits.biprod.braid_natural {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_binary_biproducts C] {W X Y Z : C} (f : X ⟶ Y) (g : Z ⟶ W) : category_theory.limits.biprod.map f g ≫ (category_theory.limits.biprod.braiding Y W).hom = (category_theory.limits.biprod.braiding X Z).hom ≫ category_theory.limits.biprod.map g f
theorem finset.exists_sum_fiber_lt_of_maps_to_of_sum_lt_nsmul {α : Type u} {β : Type v} {M : Type w} [decidable_eq β] {s : finset α} {t : finset β} {f : α → β} {w : α → M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (hf : ∀ (a : α), a ∈ s → f a ∈ t) (hb : s.sum (λ (x : α), w x) < t.card • b) : ∃ (y : β) (H : y ∈ t), (finset.filter (λ (x : α), f x = y) s).sum (λ (x : α), w x) < b
theorem Limsup_eq_of_le_nhds {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {f : filter α} {a : α} [f.ne_bot] : f ≤ nhds a → f.Limsup = a
theorem semiconj_by.eq {S : Type u} [has_mul S] {a x y : S} (h : semiconj_by a x y) : a * x = y * a
theorem continuous_map.compact_conv_nhd_subset_compact_open {α : Type u₁} {β : Type u₂} [topological_space α] [uniform_space β] {K : set α} (f : C(α, β)) (hK : is_compact K) {U : set β} (hU : is_open U) (hf : f ∈ continuous_map.compact_open.gen K U) : ∃ (V : set (β × β)) (H : V ∈ uniformity β), is_open V ∧ continuous_map.compact_conv_nhd K V f ⊆ continuous_map.compact_open.gen K U
theorem category_theory.simplicial_object.δ_comp_σ_self {C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) {n : ℕ} {i : fin (n + 1)} : X.σ i ≫ X.δ (⇑fin.cast_succ i) = 𝟙 (X.obj (opposite.op (simplex_category.mk n)))
theorem fin.cons_self_tail {n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) : fin.cons (q 0) (fin.tail q) = q
theorem dim_submodule_le_one_iff {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (s : submodule K V) : module.rank K ↥s ≤ 1 ↔ ∃ (v₀ : V) (H : v₀ ∈ s), s ≤ submodule.span K {v₀}
theorem orthogonal_projection_fn_inner_eq_zero {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K : submodule 𝕜 E} [complete_space ↥K] (v w : E) (H : w ∈ K) : has_inner.inner (v - orthogonal_projection_fn K v) w = 0
theorem tfae_mem_nhds_within_Ici {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a b : α} (hab : a < b) (s : set α) : [s ∈ nhds_within a (set.Ici a), s ∈ nhds_within a (set.Icc a b), s ∈ nhds_within a (set.Ico a b), ∃ (u : α) (H : u ∈ set.Ioc a b), set.Ico a u ⊆ s, ∃ (u : α) (H : u ∈ set.Ioi a), set.Ico a u ⊆ s].tfae
theorem category_theory.strong_epi_comp {C : Type u} [category_theory.category C] {P Q R : C} (f : P ⟶ Q) (g : Q ⟶ R) [category_theory.strong_epi f] [category_theory.strong_epi g] : category_theory.strong_epi (f ≫ g)
theorem alternating_map.comp_linear_map_assoc {R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] {ι : Type u_6} [decidable_eq ι] {M₂ : Type u_7} [add_comm_monoid M₂] [module R M₂] {M₃ : Type u_8} [add_comm_monoid M₃] [module R M₃] (f : alternating_map R M N ι) (g₁ : M₂ →ₗ[R] M) (g₂ : M₃ →ₗ[R] M₂) : (f.comp_linear_map g₁).comp_linear_map g₂ = f.comp_linear_map (g₁.comp g₂)
theorem left.one_lt_mul {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
theorem subsemiring.multiset_prod_mem {R : Type u_1} [comm_semiring R] (s : subsemiring R) (m : multiset R) : (∀ (a : R), a ∈ m → a ∈ s) → m.prod ∈ s
theorem first_order.language.directed_system.map_self {L : first_order.language} {ι : Type v} [preorder ι] {G : ι → Type w} [Π (i : ι), L.Structure (G i)] (f : Π (i j : ι), i ≤ j → L.embedding (G i) (G j)) [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] (i : ι) (x : G i) (h : i ≤ i) : ⇑(f i i h) x = x
theorem dist_convolution_le' {𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G → E} {g : G → E'} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 F] (L : E →L[𝕜] E' →L[𝕜] F) [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ F] [complete_space F] [semi_normed_group G] [borel_space G] [topological_space.second_countable_topology G] [μ.is_add_left_invariant] [measure_theory.sigma_finite μ] {x₀ : G} {R ε : ℝ} (hε : 0 ≤ ε) (hif : measure_theory.integrable f μ) (hf : function.support f ⊆ metric.ball 0 R) (hmg : measure_theory.ae_strongly_measurable g μ) (hg : ∀ (x : G), x ∈ metric.ball x₀ R → has_dist.dist (g x) (g x₀) ≤ ε) : has_dist.dist (convolution f g L μ x₀) (∫ (t : G), ⇑(⇑L (f t)) (g x₀) ∂μ) ≤ ∥L∥ * ∫ (x : G), ∥f x∥ ∂μ * ε
theorem fin.cast_add_cast {n n' : ℕ} (m : ℕ) (i : fin n') (h : n' = n) : ⇑(fin.cast_add m) (⇑(fin.cast h) i) = ⇑(fin.cast _) (⇑(fin.cast_add m) i)
theorem polynomial.contraction_degree_eq_aux {F : Type} [field F] (q : ℕ) [hq : fact (nat.prime q)] [hF : char_p F q] (g g' : polynomial F) (m m' : ℕ) (h_expand : ⇑(polynomial.expand F (q ^ m)) g = ⇑(polynomial.expand F (q ^ m')) g') (h : m < m') (hg : g.separable) : g.nat_degree = g'.nat_degree
theorem matrix.circulant_mul_comm {α : Type u_1} {n : Type u_4} [comm_semigroup α] [add_comm_monoid α] [fintype n] [add_comm_group n] (v w : n → α) : (matrix.circulant v).mul (matrix.circulant w) = (matrix.circulant w).mul (matrix.circulant v)
theorem measure_theory.lintegral_add_right {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} (f : α → ennreal) {g : α → ennreal} (hg : measurable g) : ∫⁻ (a : α), f a + g a ∂μ = ∫⁻ (a : α), f a ∂μ + ∫⁻ (a : α), g a ∂μ
theorem nndist_dist {α : Type u} [pseudo_metric_space α] (x y : α) : has_nndist.nndist x y = (has_dist.dist x y).to_nnreal
theorem well_founded.monotone_chain_condition (α : Type u_1) [partial_order α] : well_founded gt ↔ ∀ (a : ℕ →o α), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑a n = ⇑a m
theorem is_compact.exists_open_superset_measure_lt_top {α : Type u_1} [topological_space α] [measurable_space α] {s : set α} (h : is_compact s) (μ : measure_theory.measure α) [measure_theory.is_locally_finite_measure μ] : ∃ (U : set α) (H : U ⊇ s), is_open U ∧ ⇑μ U < ⊤
theorem real_inner_add_add_self {F : Type u_3} [inner_product_space ℝ F] {x y : F} : has_inner.inner (x + y) (x + y) = has_inner.inner x x + 2 * has_inner.inner x y + has_inner.inner y y
theorem finrank_orthogonal_span_singleton {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {n : ℕ} [fact (finite_dimensional.finrank 𝕜 E = n + 1)] {v : E} (hv : v ≠ 0) : finite_dimensional.finrank 𝕜 ↥(submodule.span 𝕜 {v})ᗮ = n
theorem inner_map_polarization {V : Type u_4} [inner_product_space ℂ V] (T : V →ₗ[ℂ] V) (x y : V) : has_inner.inner (⇑T y) x = (has_inner.inner (⇑T (x + y)) (x + y) - has_inner.inner (⇑T (x - y)) (x - y) + complex.I * has_inner.inner (⇑T (x + complex.I • y)) (x + complex.I • y) - complex.I * has_inner.inner (⇑T (x - complex.I • y)) (x - complex.I • y)) / 4
theorem linear_map.ext_basis {ι₁ : Type u_1} {ι₂ : Type u_2} {R : Type u_3} {R₂ : Type u_4} {S : Type u_5} {S₂ : Type u_6} {M : Type u_7} {N : Type u_8} {P : Type u_9} [comm_ring R] [comm_ring S] [comm_ring R₂] [comm_ring S₂] [add_comm_group M] [add_comm_group N] [add_comm_group P] [module R M] [module S N] [module R₂ P] [module S₂ P] [smul_comm_class S₂ R₂ P] {ρ₁₂ : R →+* R₂} {σ₁₂ : S →+* S₂} (b₁ : basis ι₁ R M) (b₂ : basis ι₂ S N) {B B' : M →ₛₗ[ρ₁₂] N →ₛₗ[σ₁₂] P} (h : ∀ (i : ι₁) (j : ι₂), ⇑(⇑B (⇑b₁ i)) (⇑b₂ j) = ⇑(⇑B' (⇑b₁ i)) (⇑b₂ j)) : B = B'
theorem real.summable_nat_pow_inv {p : ℕ} : summable (λ (n : ℕ), (↑n ^ p)⁻¹) ↔ 1 < p
theorem filter.liminf_const_top {α : Type u_1} {β : Type u_2} [complete_lattice α] {f : filter β} : f.liminf (λ (x : β), ⊤) = ⊤
theorem Kuratowski_embedding.embedding_of_subset_dist_le {α : Type u} [metric_space α] (x : ℕ → α) (a b : α) : has_dist.dist (Kuratowski_embedding.embedding_of_subset x a) (Kuratowski_embedding.embedding_of_subset x b) ≤ has_dist.dist a b
theorem finset.sup_univ_eq_supr {α : Type u_1} {β : Type u_2} [fintype α] [complete_lattice β] (f : α → β) : finset.univ.sup f = supr f
theorem uv.card_compression {α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v : α) (s : finset α) : (uv.compression u v s).card = s.card
theorem polynomial.degree_prod {R : Type u} {ι : Type w} (s : finset ι) [comm_semiring R] [no_zero_divisors R] (f : ι → polynomial R) [nontrivial R] : (s.prod (λ (i : ι), f i)).degree = s.sum (λ (i : ι), (f i).degree)
theorem box_integral.integrable.cauchy_map_integral_sum_to_filter_Union {ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} (h : box_integral.integrable I l f vol) (π₀ : box_integral.prepartition I) : cauchy (filter.map (box_integral.integral_sum f vol) (l.to_filter_Union I π₀))
theorem complex.det_conj_ae  : ⇑linear_map.det complex.conj_ae.to_linear_map = -1
theorem same_ray.exists_eq_smul_add {R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {v₁ v₂ : M} (h : same_ray R v₁ v₂) : ∃ (a b : R), 0 ≤ a ∧ 0 ≤ b ∧ a + b = 1 ∧ v₁ = a • (v₁ + v₂) ∧ v₂ = b • (v₁ + v₂)
theorem emetric.subset_countable_closure_of_compact {α : Type u} [pseudo_emetric_space α] {s : set α} (hs : is_compact s) : ∃ (t : set α) (H : t ⊆ s), t.countable ∧ s ⊆ closure t
theorem mv_polynomial.eval₂_hom_X {S : Type v} [comm_ring S] {R : Type u} (c : ℤ →+* S) (f : mv_polynomial R ℤ →+* S) (x : mv_polynomial R ℤ) : mv_polynomial.eval₂ c (⇑f ∘ mv_polynomial.X) x = ⇑f x
theorem probability_theory.ident_distrib.ae_strongly_measurable_snd {α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] [measurable_space β] [measurable_space γ] {μ : measure_theory.measure α} {ν : measure_theory.measure β} {f : α → γ} {g : β → γ} [topological_space γ] [topological_space.metrizable_space γ] [borel_space γ] (h : probability_theory.ident_distrib f g μ ν) (hf : measure_theory.ae_strongly_measurable f μ) : measure_theory.ae_strongly_measurable g ν
theorem comp_add_left {α : Type u_1} [add_semigroup α] (x y : α) : has_add.add x ∘ has_add.add y = has_add.add (x + y)
theorem algebra.discr_of_matrix_vec_mul {A : Type u} {B : Type v} {ι : Type w} [comm_ring A] [comm_ring B] [algebra A B] [fintype ι] [decidable_eq ι] (b : ι → B) (P : matrix ι ι A) : algebra.discr A (matrix.vec_mul b (P.map ⇑(algebra_map A B))) = P.det ^ 2 * algebra.discr A b
theorem nat.set_induction_bounded {b : ℕ} {S : set ℕ} (hb : b ∈ S) (h_ind : ∀ (k : ℕ), k ∈ S → k + 1 ∈ S) {n : ℕ} (hbn : b ≤ n) : n ∈ S
theorem quotient_add_group.add_subgroup_eq_top_of_subsingleton {G : Type u} [add_group G] (H : add_subgroup G) (h : subsingleton (G ⧸ H)) : H = ⊤
theorem finsupp.coe_fn_inj {α : Type u_1} {M : Type u_5} [has_zero M] {f g : α →₀ M} : ⇑f = ⇑g ↔ f = g
theorem measure_theory.submartingale_of_expected_stopped_value_mono {α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {𝒢 : measure_theory.filtration ℕ m0} [measure_theory.is_finite_measure μ] {f : ℕ → α → ℝ} (hadp : measure_theory.adapted 𝒢 f) (hint : ∀ (i : ℕ), measure_theory.integrable (f i) μ) (hf : ∀ (τ π : α → ℕ), measure_theory.is_stopping_time 𝒢 τ → measure_theory.is_stopping_time 𝒢 π → τ ≤ π → (∃ (N : ℕ), ∀ (x : α), π x ≤ N) → ∫ (x : α), measure_theory.stopped_value f τ x ∂μ ≤ ∫ (x : α), measure_theory.stopped_value f π x ∂μ) : measure_theory.submartingale f 𝒢 μ
theorem Module.has_cokernels_Module {R : Type u} [ring R] : category_theory.limits.has_cokernels (Module R)
theorem list.map_permutations_aux2 {α : Type u_1} {β : Type u_2} (t : α) (ts ys : list α) (f : list α → β) : list.map f (list.permutations_aux2 t ts list.nil ys id).snd = (list.permutations_aux2 t ts list.nil ys f).snd
theorem strict_anti.strict_concave_on_univ_of_deriv {f : ℝ → ℝ} (hf : differentiable ℝ f) (hf'_anti : strict_anti (deriv f)) : strict_concave_on ℝ set.univ f
theorem metric.diam_singleton {α : Type u} [pseudo_metric_space α] {x : α} : metric.diam {x} = 0
theorem szemeredi_regularity.step_bound_pos {n : ℕ} : 0 < n → 0 < szemeredi_regularity.step_bound n
theorem convex.translate_preimage_right {𝕜 : Type u_1} {E : Type u_2} [ordered_semiring 𝕜] [add_comm_monoid E] [module 𝕜 E] {s : set E} (hs : convex 𝕜 s) (z : E) : convex 𝕜 ((λ (x : E), z + x) ⁻¹' s)
theorem local_homeomorph.is_image.symm_preimage_eq {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {e : local_homeomorph α β} {s : set α} {t : set β} : e.is_image s t → e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' s = e.to_local_equiv.target ∩ t
theorem exists_increasing_or_nonincreasing_subseq {α : Type u_1} (r : α → α → Prop) [is_trans α r] (f : ℕ → α) : ∃ (g : ℕ ↪o ℕ), (∀ (m n : ℕ), m < n → r (f (⇑g m)) (f (⇑g n))) ∨ ∀ (m n : ℕ), m < n → ¬r (f (⇑g m)) (f (⇑g n))
theorem multiples.self_mem {M : Type u_1} [add_monoid M] {x : M} : x ∈ multiples x
theorem complex.tendsto_exp_comap_re_at_top  : filter.tendsto complex.exp (filter.comap complex.re filter.at_top) (filter.comap complex.abs filter.at_top)
theorem rel_embedding.coe_fn_injective {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} : function.injective coe_fn
theorem multiple_mem_adjoin_of_mem_localization_adjoin {R S : Type u} [comm_ring R] [comm_ring S] (M : submonoid R) (R' : Type u) [comm_ring R'] [algebra R R'] [algebra R' S] [algebra R S] [is_scalar_tower R R' S] [is_localization M R'] (s : set S) (x : S) (hx : x ∈ algebra.adjoin R' s) : ∃ (t : ↥M), t • x ∈ algebra.adjoin R s
theorem category_theory.limits.finite_colimits_from_coequalizers_and_finite_coproducts {C : Type u} [category_theory.category C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_finite_colimits C
theorem subgroup.closure_induction {G : Type u_1} [group G] {k : set G} {p : G → Prop} {x : G} (h : x ∈ subgroup.closure k) (Hk : ∀ (x : G), x ∈ k → p x) (H1 : p 1) (Hmul : ∀ (x y : G), p x → p y → p (x * y)) (Hinv : ∀ (x : G), p x → p x⁻¹) : p x
theorem antitone.pairwise_disjoint_on_Ioc_succ {α : Type u_1} {β : Type u_2} [linear_order α] [succ_order α] [preorder β] {f : α → β} (hf : antitone f) : pairwise (disjoint on λ (n : α), set.Ioc (f (order.succ n)) (f n))
theorem add_order_of_pos_iff {G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ↔ is_of_fin_add_order x
theorem bernstein_approximation.le_of_mem_S_compl {f : C(↥unit_interval, ℝ)} {ε : ℝ} {h : 0 < ε} {n : ℕ} {x : ↥unit_interval} {k : fin (n + 1)} (m : k ∈ (bernstein_approximation.S f ε h n x)ᶜ) : 1 ≤ bernstein_approximation.δ f ε h ^ -2 * (↑x - ↑(bernstein.z k)) ^ 2
theorem star_ring_end_apply {R : Type u} [comm_semiring R] [star_ring R] {x : R} : ⇑(star_ring_end R) x = has_star.star x
theorem finrank_eq_one_iff_of_nonzero' {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (v : V) (nz : v ≠ 0) : finite_dimensional.finrank K V = 1 ↔ ∀ (w : V), ∃ (c : K), c • v = w
theorem topological_group.continuous_conj_prod {G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] : continuous (λ (g : G × G), g.fst * g.snd * (g.fst)⁻¹)
theorem nnnorm_le_insert {E : Type u_3} [semi_normed_group E] (u v : E) : ∥v∥₊ ≤ ∥u∥₊ + ∥u - v∥₊
theorem has_sum_zero {α : Type u_1} {β : Type u_2} [add_comm_monoid α] [topological_space α] : has_sum (λ (b : β), 0) 0
theorem monoid_hom.map_finprod_mem' {α : Type u_1} {M : Type u_5} {N : Type u_6} [comm_monoid M] [comm_monoid N] {s : set α} {f : α → M} (g : M →* N) (h₀ : (s ∩ function.mul_support f).finite) : ⇑g (finprod (λ (j : α), finprod (λ (H : j ∈ s), f j))) = finprod (λ (i : α), finprod (λ (H : i ∈ s), ⇑g (f i)))
theorem is_integral_tower_top_of_is_integral {R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [comm_ring B] [algebra A B] [algebra R B] [algebra R A] [is_scalar_tower R A B] {x : B} (h : is_integral R x) : is_integral A x
theorem measure_theory.measurably_separable_range_of_disjoint {α : Type u_1} [topological_space α] [t2_space α] [measurable_space α] [borel_space α] {f g : (ℕ → ℕ) → α} (hf : continuous f) (hg : continuous g) (h : disjoint (set.range f) (set.range g)) : measure_theory.measurably_separable (set.range f) (set.range g)
theorem is_cyclotomic_extension.is_prime_pow_norm_zeta_sub_one {n : ℕ+} {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [ne_zero ↑↑n] (hn : is_prime_pow ↑n) [is_cyclotomic_extension {n} K L] (hirr : irreducible (polynomial.cyclotomic ↑n K)) (h : n ≠ 2) : ⇑(algebra.norm K) (is_cyclotomic_extension.zeta n K L - 1) = ↑(↑n.min_fac)
theorem is_group_hom.mul {α : Type u_1} {β : Type u_2} [group α] [comm_group β] {f g : α → β} (hf : is_group_hom f) (hg : is_group_hom g) : is_group_hom (λ (a : α), f a * g a)
theorem continuous_multilinear_map.cons_smul {R : Type u} {n : ℕ} {M : fin n.succ → Type w} {M₂ : Type w₂} [semiring R] [Π (i : fin n.succ), add_comm_monoid (M i)] [add_comm_monoid M₂] [Π (i : fin n.succ), module R (M i)] [module R M₂] [Π (i : fin n.succ), topological_space (M i)] [topological_space M₂] (f : continuous_multilinear_map R M M₂) (m : Π (i : fin n), M i.succ) (c : R) (x : M 0) : ⇑f (fin.cons (c • x) m) = c • ⇑f (fin.cons x m)
theorem order_of_pow {G : Type u} {n : ℕ} [fintype G] [left_cancel_monoid G] (x : G) : order_of (x ^ n) = order_of x / (order_of x).gcd n
theorem closed_embedding.polish_space {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [polish_space β] {f : α → β} (hf : closed_embedding f) : polish_space α
theorem turing.list_blank.exists_cons {Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ) : ∃ (a : Γ) (l' : turing.list_blank Γ), l = turing.list_blank.cons a l'
theorem separate_convex_open_set {E : Type u_2} [semi_normed_group E] [normed_space ℝ E] {s : set E} (hs₀ : 0 ∈ s) (hs₁ : convex ℝ s) (hs₂ : is_open s) {x₀ : E} (hx₀ : x₀ ∉ s) : ∃ (f : E →L[ℝ] ℝ), ⇑f x₀ = 1 ∧ ∀ (x : E), x ∈ s → ⇑f x < 1
theorem nat.digits_lt_base' {b m d : ℕ} : d ∈ (b + 2).digits m → d < b + 2
theorem Exists.some_spec {α : Sort u_1} {p : α → Prop} (P : ∃ (a : α), p a) : p P.some
theorem metric.inf_edist_le_inf_edist_cthickening_add {α : Type u} [pseudo_emetric_space α] {δ : ℝ} {s : set α} {x : α} : emetric.inf_edist x s ≤ emetric.inf_edist x (metric.cthickening δ s) + ennreal.of_real δ
theorem convolution_lsmul_swap {𝕜 : Type u_1} {G : Type u_2} {F : Type u_6} [normed_group F] {x : G} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 F] [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ F] [complete_space F] [add_comm_group G] [topological_space G] [topological_add_group G] [borel_space G] [μ.is_add_left_invariant] [μ.is_neg_invariant] {f : G → 𝕜} {g : G → F} : convolution f g (continuous_linear_map.lsmul 𝕜 𝕜) μ x = ∫ (t : G), f (x - t) • g t ∂μ
theorem antivary_on.sum_mul_lt_sum_mul_comp_perm_iff {ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {s : finset ι} {σ : equiv.perm ι} {f g : ι → α} (hfg : antivary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i * g i) < s.sum (λ (i : ι), f i * g (⇑σ i)) ↔ ¬antivary_on f (g ∘ ⇑σ) ↑s
theorem matrix.det_from_blocks_zero₁₂ {m : Type u_1} {n : Type u_2} [decidable_eq n] [fintype n] [decidable_eq m] [fintype m] {R : Type v} [comm_ring R] (A : matrix m m R) (C : matrix n m R) (D : matrix n n R) : (matrix.from_blocks A 0 C D).det = A.det * D.det
theorem lt_tsub_iff_right_of_le {α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b c : α} [contravariant_class α α has_add.add has_le.le] (h : c ≤ b) : a < b - c ↔ a + c < b
theorem two_mul_le_add_sq {R : Type u_4} [linear_ordered_comm_ring R] (a b : R) : 2 * a * b ≤ a ^ 2 + b ^ 2
theorem is_dedekind_domain_iff (A : Type u_2) [comm_ring A] [is_domain A] (K : Type u_1) [field K] [algebra A K] [is_fraction_ring A K] : is_dedekind_domain A ↔ is_noetherian_ring A ∧ ring.dimension_le_one A ∧ ∀ {x : K}, is_integral A x → (∃ (y : A), ⇑(algebra_map A K) y = x)
theorem nat.modeq.modeq_cancel_left_of_coprime {a b c m : ℕ} (hmc : m.gcd c = 1) (h : c * a ≡ c * b [MOD m]) : a ≡ b [MOD m]
theorem category_theory.limits.cofork.is_colimit.hom_iso_natural {C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} {t : category_theory.limits.cofork f g} {Z Z' : C} (q : Z ⟶ Z') (ht : category_theory.limits.is_colimit t) (k : t.X ⟶ Z) : ↑(⇑(category_theory.limits.cofork.is_colimit.hom_iso ht Z') (k ≫ q)) = ↑(⇑(category_theory.limits.cofork.is_colimit.hom_iso ht Z) k) ≫ q
theorem mem_nhds_within_Iio_iff_exists_Ico_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_min_order α] [densely_ordered α] {a : α} {s : set α} : s ∈ nhds_within a (set.Iio a) ↔ ∃ (l : α) (H : l ∈ set.Iio a), set.Ico l a ⊆ s
theorem inner_product_space.is_self_adjoint.orthogonal_supr_eigenspaces {𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] {T : E →ₗ[𝕜] E} (hT : inner_product_space.is_self_adjoint T) (μ : 𝕜) : module.End.eigenspace (T.restrict _) μ = ⊥
theorem nhds_basis_Ioo_pos_of_pos {α : Type u} [topological_space α] [linear_ordered_add_comm_group α] [order_topology α] [no_min_order α] [no_max_order α] {a : α} (ha : 0 < a) : (nhds a).has_basis (λ (ε : α), 0 < ε ∧ ε ≤ a) (λ (ε : α), set.Ioo (a - ε) (a + ε))
theorem convex.set_average_mem_closure {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {t : set α} {f : α → E} (hs : convex ℝ s) (h0 : ⇑μ t ≠ 0) (ht : ⇑μ t ≠ ⊤) (hfs : ∀ᵐ (x : α) ∂μ.restrict t, f x ∈ s) (hfi : measure_theory.integrable_on f t μ) : ⨍ (x : α) in t, f x ∂μ ∈ closure s
theorem metric.to_inductive_limit_isometry {X : ℕ → Type u} [Π (n : ℕ), metric_space (X n)] {f : Π (n : ℕ), X n → X (n + 1)} (I : ∀ (n : ℕ), isometry (f n)) (n : ℕ) : isometry (metric.to_inductive_limit I n)
theorem submodule.torsion_by_is_internal {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {ι : Type u_3} [decidable_eq ι] {S : finset ι} {q : ι → R} (hq : ↑S.pairwise (is_coprime on q)) (hM : module.is_torsion_by R M (S.prod (λ (i : ι), q i))) : direct_sum.is_internal (λ (i : ↥S), submodule.torsion_by R M (q ↑i))
theorem vector_span_def (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : vector_span k s = submodule.span k (s -ᵥ s)
theorem dim_mul_dim' (F : Type u) (K : Type v) (A : Type w) [field F] [field K] [add_comm_group A] [algebra F K] [module K A] [module F A] [is_scalar_tower F K A] : (module.rank F K).lift * (module.rank K A).lift = (module.rank F A).lift
theorem class_group.exists_min {R : Type u_1} {S : Type u_2} [euclidean_domain R] [comm_ring S] [is_domain S] [algebra R S] (abv : absolute_value R ℤ) (I : ↥(non_zero_divisors (ideal S))) : ∃ (b : S) (H : b ∈ ↑I), b ≠ 0 ∧ ∀ (c : S), c ∈ ↑I → ⇑abv (⇑(algebra.norm R) c) < ⇑abv (⇑(algebra.norm R) b) → c = 0
theorem uv.compress_idem {α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v a : α) : uv.compress u v (uv.compress u v a) = uv.compress u v a
theorem lattice_ordered_comm_group.mabs_mabs {α : Type u} [lattice α] [comm_group α] [covariant_class α α has_mul.mul has_le.le] (a : α) : ||a|| = |a|
theorem reflexive.ne_imp_iff {α : Type u_1} {r : α → α → Prop} (h : reflexive r) {x y : α} : x ≠ y → r x y ↔ r x y
theorem lipschitz_on_with.of_le_add_mul {α : Type u} [pseudo_metric_space α] {s : set α} {f : α → ℝ} (K : nnreal) (h : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → f x ≤ f y + ↑K * has_dist.dist x y) : lipschitz_on_with K f s
theorem orthogonal_projection_map_apply {𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} {E' : Type u_3} [inner_product_space 𝕜 E] [inner_product_space 𝕜 E'] (f : E ≃ₗᵢ[𝕜] E') (p : submodule 𝕜 E) [complete_space ↥p] (x : E') : ↑(⇑(orthogonal_projection (submodule.map ↑(f.to_linear_equiv) p)) x) = ⇑f ↑(⇑(orthogonal_projection p) (⇑(f.symm) x))
theorem filter.tendsto_iff_ultrafilter {α : Type u} {β : Type v} (f : α → β) (l₁ : filter α) (l₂ : filter β) : filter.tendsto f l₁ l₂ ↔ ∀ (g : ultrafilter α), ↑g ≤ l₁ → filter.tendsto f ↑g l₂
theorem complex.circle_integral_eq_of_differentiable_on_annulus_off_countable {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] {c : ℂ} {r R : ℝ} (h0 : 0 < r) (hle : r ≤ R) {f : ℂ → E} {s : set ℂ} (hs : s.countable) (hc : continuous_on f (metric.closed_ball c R  metric.ball c r)) (hd : ∀ (z : ℂ), z ∈ metric.ball c R  metric.closed_ball c r  s → differentiable_at ℂ f z) : ∮ (z : ℂ) in C(c, R), f z = ∮ (z : ℂ) in C(c, r), f z
theorem is_fraction_ring.lift_mk' {A : Type u_4} [comm_ring A] [is_domain A] {K : Type u_5} [field K] {L : Type u_7} [field L] [algebra A K] [is_fraction_ring A K] {g : A →+* L} (hg : function.injective ⇑g) (x : A) (y : ↥(non_zero_divisors A)) : ⇑(is_fraction_ring.lift hg) (is_localization.mk' K x y) = ⇑g x / ⇑g ↑y
theorem tendsto_at_top_of_geom_le {v : ℕ → ℝ} {c : ℝ} (h₀ : 0 < v 0) (hc : 1 < c) (hu : ∀ (n : ℕ), c * v n ≤ v (n + 1)) : filter.tendsto v filter.at_top filter.at_top
theorem is_primitive_root.pow_sub_one_norm_prime_pow_of_one_le {p : ℕ+} {K : Type u} {L : Type v} [field L] {ζ : L} [field K] [algebra K L] [hne : ne_zero ↑↑p] {k s : ℕ} (hζ : is_primitive_root ζ ↑(p ^ (k + 1))) [hpri : fact (nat.prime ↑p)] [hcycl : is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic ↑(p ^ (k + 1)) K)) (hs : s ≤ k) (hk : 1 ≤ k) : ⇑(algebra.norm K) (ζ ^ ↑p ^ s - 1) = ↑p ^ ↑p ^ s
theorem vsub_mem_vector_span_of_mem_span_points_of_mem_span_points (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p1 p2 : P} (hp1 : p1 ∈ span_points k s) (hp2 : p2 ∈ span_points k s) : p1 -ᵥ p2 ∈ vector_span k s
theorem upper_central_series_is_ascending_central_series (G : Type u_1) [group G] : is_ascending_central_series (upper_central_series G)
theorem nilpotency_class_eq_quotient_center_plus_one {G : Type u_1} [group G] [hH : group.is_nilpotent G] [nontrivial G] : group.nilpotency_class G = group.nilpotency_class (G ⧸ subgroup.center G) + 1
theorem nnreal.young_inequality_real (a b : nnreal) {p q : ℝ} (hpq : p.is_conjugate_exponent q) : a * b ≤ a ^ p / p.to_nnreal + b ^ q / q.to_nnreal
theorem measure_theory.signed_measure.of_diff_eq_zero_of_symm_diff_eq_zero_positive {α : Type u_1} [measurable_space α] {s : measure_theory.signed_measure α} {u v : set α} (hu : measurable_set u) (hv : measurable_set v) (hsu : 0.restrict u ≤ measure_theory.vector_measure.restrict s u) (hsv : 0.restrict v ≤ measure_theory.vector_measure.restrict s v) (hs : ⇑s (u ∆ v) = 0) : ⇑s (u  v) = 0 ∧ ⇑s (v  u) = 0
theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2
theorem absolute_value.is_admissible.exists_approx_aux {R : Type u_1} [euclidean_domain R] {abv : absolute_value R ℤ} (n : ℕ) (h : abv.is_admissible) {ε : ℝ} (hε : 0 < ε) {b : R} (hb : b ≠ 0) (A : fin (h.card ε ^ n).succ → fin n → R) : ∃ (i₀ i₁ : fin (h.card ε ^ n).succ), i₀ ≠ i₁ ∧ ∀ (k : fin n), ↑(⇑abv (A i₁ k % b - A i₀ k % b)) < ⇑abv b • ε
theorem coe_fourier_series  : ⇑fourier_series = fourier_Lp 2
theorem list.map_comp_map {α : Type u} {β : Type v} {γ : Type w} (g : β → γ) (f : α → β) : list.map g ∘ list.map f = list.map (g ∘ f)
theorem class_group.norm_le {R : Type u_1} {S : Type u_2} [euclidean_domain R] [comm_ring S] [is_domain S] [algebra R S] (abv : absolute_value R ℤ) {ι : Type u_5} [decidable_eq ι] [fintype ι] (bS : basis ι R S) (a : S) {y : ℤ} (hy : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y) : ⇑abv (⇑(algebra.norm R) a) ≤ class_group.norm_bound abv bS * y ^ fintype.card ι
theorem not_is_right_regular_zero_iff {R : Type u_1} [mul_zero_class R] : ¬is_right_regular 0 ↔ nontrivial R
theorem int.gcd_eq_gcd_ab (x y : ℤ) : ↑(x.gcd y) = x * x.gcd_a y + y * x.gcd_b y
theorem has_strict_fderiv_at_exp {𝕂 : Type u_1} {𝔸 : Type u_2} [is_R_or_C 𝕂] [normed_comm_ring 𝔸] [normed_algebra 𝕂 𝔸] [complete_space 𝔸] {x : 𝔸} : has_strict_fderiv_at (exp 𝕂) (exp 𝕂 x • 1) x
theorem affine_basis.to_matrix_vec_mul_coords {ι : Type u₁} {k : Type u₂} {V : Type u₃} {P : Type u₄} [add_comm_group V] [add_torsor V P] [ring k] [module k V] (b : affine_basis ι k P) [fintype ι] (b₂ : affine_basis ι k P) (x : P) : matrix.vec_mul (⇑(b₂.coords) x) (b.to_matrix b₂.points) = ⇑(b.coords) x
theorem is_R_or_C.I_re {K : Type u_1} [is_R_or_C K] : ⇑is_R_or_C.re is_R_or_C.I = 0
theorem affine.simplex.ext_iff {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : ℕ} (s1 s2 : affine.simplex k P n) : s1 = s2 ↔ ∀ (i : fin (n + 1)), s1.points i = s2.points i
theorem category_theory.limits.biprod.add_eq_lift_desc_id {C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} (f g : X ⟶ Y) [category_theory.limits.has_binary_biproduct Y Y] : f + g = category_theory.limits.biprod.lift f g ≫ category_theory.limits.biprod.desc (𝟙 Y) (𝟙 Y)
theorem monotone.tendsto_nhds_within_Ioi {β : Type v} [conditionally_complete_linear_order β] [topological_space β] [order_topology β] {α : Type u_1} [linear_order α] [topological_space α] [order_topology α] {f : α → β} (Mf : monotone f) (x : α) : filter.tendsto f (nhds_within x (set.Ioi x)) (nhds (has_Inf.Inf (f '' set.Ioi x)))
theorem complex.norm_deriv_le_div_of_maps_to_ball {E : Type u_1} [normed_group E] [normed_space ℂ E] {R₁ R₂ : ℝ} {f : ℂ → E} {c : ℂ} (hd : differentiable_on ℂ f (metric.ball c R₁)) (h_maps : set.maps_to f (metric.ball c R₁) (metric.ball (f c) R₂)) (h₀ : 0 < R₁) : ∥deriv f c∥ ≤ R₂ / R₁
theorem metric.inf_dist_le_dist_of_mem {α : Type u} [pseudo_metric_space α] {s : set α} {x y : α} (h : y ∈ s) : metric.inf_dist x s ≤ has_dist.dist x y
theorem measure_theory.analytic_set.image_of_continuous_on {α : Type u_1} [topological_space α] {β : Type u_2} [topological_space β] {s : set α} (hs : measure_theory.analytic_set s) {f : α → β} (hf : continuous_on f s) : measure_theory.analytic_set (f '' s)
theorem add_con.add_con_gen_of_add_con {M : Type u_1} [has_add M] (c : add_con M) : add_con_gen ⇑c = c
theorem star_convex.preimage_add_right {𝕜 : Type u_1} {E : Type u_2} [ordered_semiring 𝕜] [add_comm_monoid E] [module 𝕜 E] {x z : E} {s : set E} (hs : star_convex 𝕜 (z + x) s) : star_convex 𝕜 x ((λ (x : E), z + x) ⁻¹' s)
theorem finset.eq_empty_of_is_empty {α : Type u_1} [is_empty α] (s : finset α) : s = ∅
theorem measure_theory.probability_measure.tendsto_iff_forall_lintegral_tendsto {α : Type u_1} [measurable_space α] [topological_space α] [opens_measurable_space α] {γ : Type u_2} {F : filter γ} {μs : γ → measure_theory.probability_measure α} {μ : measure_theory.probability_measure α} : filter.tendsto μs F (nhds μ) ↔ ∀ (f : bounded_continuous_function α nnreal), filter.tendsto (λ (i : γ), ∫⁻ (x : α), ↑(⇑f x) ∂↑(μs i)) F (nhds (∫⁻ (x : α), ↑(⇑f x) ∂↑μ))
theorem reflection_orthogonal_complement_singleton_eq_neg {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [complete_space E] (v : E) : ⇑(reflection (submodule.span 𝕜 {v})ᗮ) v = -v
theorem measure_theory.L2.inner_indicator_const_Lp_eq_inner_set_integral {α : Type u_1} {E : Type u_2} (𝕜 : Type u_4) [is_R_or_C 𝕜] [measurable_space α] {μ : measure_theory.measure α} [inner_product_space 𝕜 E] {s : set α} [complete_space E] [normed_space ℝ E] (hs : measurable_set s) (hμs : ⇑μ s ≠ ⊤) (c : E) (f : ↥(measure_theory.Lp E 2 μ)) : has_inner.inner (measure_theory.indicator_const_Lp 2 hs hμs c) f = has_inner.inner c (∫ (x : α) in s, ⇑f x ∂μ)
theorem finset.image_image₂_right_anticomm {α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} [decidable_eq β'] [decidable_eq γ] [decidable_eq δ] {s : finset α} {t : finset β} {f : α → β' → γ} {g : β → β'} {f' : β → α → δ} {g' : δ → γ} (h_right_anticomm : ∀ (a : α) (b : β), f a (g b) = g' (f' b a)) : finset.image₂ f s (finset.image g t) = finset.image g' (finset.image₂ f' t s)
theorem finset.prod_le_prod'' {ι : Type u_1} {N : Type u_5} [ordered_comm_monoid N] {f g : ι → N} {s : finset ι} (h : ∀ (i : ι), i ∈ s → f i ≤ g i) : s.prod (λ (i : ι), f i) ≤ s.prod (λ (i : ι), g i)
theorem measure_theory.map_prod_sum_eq {G : Type u_1} [measurable_space G] [add_group G] [has_measurable_add₂ G] (μ ν : measure_theory.measure G) [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] [ν.is_add_left_invariant] : measure_theory.measure.map (λ (z : G × G), (z.fst, z.fst + z.snd)) (μ.prod ν) = μ.prod ν
theorem set.zero_smul_set {α : Type u_2} {β : Type u_3} [has_zero α] [has_zero β] [smul_with_zero α β] {s : set β} (h : s.nonempty) : 0 • s = 0
theorem measure_theory.conservative.ae_frequently_mem_of_mem_nhds {α : Type u_2} [measurable_space α] [topological_space α] [topological_space.second_countable_topology α] [opens_measurable_space α] {f : α → α} {μ : measure_theory.measure α} (h : measure_theory.conservative f μ) : ∀ᵐ (x : α) ∂μ, ∀ (s : set α), s ∈ nhds x → (∃ᶠ (n : ℕ) in filter.at_top, f^[n] x ∈ s)
theorem nonarchimedean_ring.mul_subset {R : Type u_1} [ring R] [topological_space R] [nonarchimedean_ring R] (U : open_add_subgroup R) : ∃ (V : open_add_subgroup R), ↑V * ↑V ⊆ ↑U
theorem filter.tendsto.at_top_mul_neg {α : Type u} {β : Type v} [linear_ordered_field α] [topological_space α] [order_topology α] {l : filter β} {f g : β → α} {C : α} (hC : C < 0) (hf : filter.tendsto f l filter.at_top) (hg : filter.tendsto g l (nhds C)) : filter.tendsto (λ (x : β), f x * g x) l filter.at_bot
theorem is_bot.to_dual {α : Type u_1} [has_le α] {a : α} : is_bot a → is_top (⇑order_dual.to_dual a)
theorem weak_bilin.embedding {𝕜 : Type u_2} {E : Type u_5} {F : Type u_6} [topological_space 𝕜] [comm_semiring 𝕜] [add_comm_monoid E] [module 𝕜 E] [add_comm_monoid F] [module 𝕜 F] {B : E →ₗ[𝕜] F →ₗ[𝕜] 𝕜} (hB : function.injective ⇑B) : embedding (λ (x : weak_bilin B) (y : F), ⇑(⇑B x) y)
theorem nat.infinite_set_of_prime  : {p : ℕ | nat.prime p}.infinite
theorem measure_theory.L1.simple_func.set_to_L1s_congr_measure {α : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {m : measurable_space α} {μ μ' : measure_theory.measure α} (T : set α → (E →L[ℝ] F)) (h_zero : ∀ (s : set α), measurable_set s → ⇑μ s = 0 → T s = 0) (h_add : measure_theory.fin_meas_additive μ T) (hμ : μ.absolutely_continuous μ') (f : ↥(measure_theory.Lp.simple_func E 1 μ)) (f' : ↥(measure_theory.Lp.simple_func E 1 μ')) (h : ⇑f =ᵐ[μ] ⇑f') : measure_theory.L1.simple_func.set_to_L1s T f = measure_theory.L1.simple_func.set_to_L1s T f'
theorem function.embedding.total (α : Type u) (β : Type v) : nonempty (α ↪ β) ∨ nonempty (β ↪ α)
theorem simplex_category.δ_comp_δ {n : ℕ} {i j : fin (n + 2)} (H : i ≤ j) : simplex_category.δ i ≫ simplex_category.δ j.succ = simplex_category.δ j ≫ simplex_category.δ (⇑fin.cast_succ i)
theorem witt_vector.frobenius_fun_is_poly (p : ℕ) [hp : fact (nat.prime p)] : witt_vector.is_poly p (λ (R : Type u_1) (_Rcr : comm_ring R), witt_vector.frobenius_fun)
theorem add_equiv.map_add {M : Type u_6} {N : Type u_7} [has_add M] [has_add N] (f : M ≃+ N) (x y : M) : ⇑f (x + y) = ⇑f x + ⇑f y
theorem precise_refinement_set {ι : Type u} {X : Type v} [topological_space X] [paracompact_space X] {s : set X} (hs : is_closed s) (u : ι → set X) (uo : ∀ (i : ι), is_open (u i)) (us : s ⊆ ⋃ (i : ι), u i) : ∃ (v : ι → set X), (∀ (i : ι), is_open (v i)) ∧ (s ⊆ ⋃ (i : ι), v i) ∧ locally_finite v ∧ ∀ (i : ι), v i ⊆ u i
theorem homological_complex.d_comp_eq_to_hom {ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape ι} (C : homological_complex V c) {i j j' : ι} (rij : c.rel i j) (rij' : c.rel i j') : C.d i j' ≫ category_theory.eq_to_hom _ = C.d i j
theorem measure_theory.meas_ge_le_lintegral_div {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : α → ennreal} (hf : ae_measurable f μ) {ε : ennreal} (hε : ε ≠ 0) (hε' : ε ≠ ⊤) : ⇑μ {x : α | ε ≤ f x} ≤ ∫⁻ (a : α), f a ∂μ / ε
theorem is_lub.bdd_above {α : Type u} [preorder α] {s : set α} {a : α} (h : is_lub s a) : bdd_above s
theorem function.injective2.left' {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) [nonempty β] : function.injective f
theorem module.torsion_by_prime_power_decomposition {R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {N : Type (max u v)} [add_comm_group N] [module R N] {p : R} (hp : irreducible p) (hN : module.is_torsion' N ↥(submonoid.powers p)) [h' : module.finite R N] : ∃ (d : ℕ) (k : fin d → ℕ), nonempty (N ≃ₗ[R] direct_sum (fin d) (λ (i : fin d), R ⧸ submodule.span R {p ^ k i}))
theorem box_integral.has_integral_bot_pderiv {E : Type u} [normed_group E] [normed_space ℝ E] {n : ℕ} [complete_space E] (I : box_integral.box (fin (n + 1))) (f : (fin (n + 1) → ℝ) → E) (f' : (fin (n + 1) → ℝ) → ((fin (n + 1) → ℝ) →L[ℝ] E)) (s : set (fin (n + 1) → ℝ)) (hs : s.countable) (Hs : ∀ (x : fin (n + 1) → ℝ), x ∈ s → continuous_within_at f (⇑box_integral.box.Icc I) x) (Hd : ∀ (x : fin (n + 1) → ℝ), x ∈ ⇑box_integral.box.Icc I  s → has_fderiv_within_at f (f' x) (⇑box_integral.box.Icc I) x) (i : fin (n + 1)) : box_integral.has_integral I ⊥ (λ (x : fin (n + 1) → ℝ), ⇑(f' x) (pi.single i 1)) box_integral.box_additive_map.volume (box_integral.integral (I.face i) ⊥ (λ (x : fin n → ℝ), f (i.insert_nth (I.upper i) x)) box_integral.box_additive_map.volume - box_integral.integral (I.face i) ⊥ (λ (x : fin n → ℝ), f (i.insert_nth (I.lower i) x)) box_integral.box_additive_map.volume)
theorem ennreal.lintegral_Lp_add_le {α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {p : ℝ} {f g : α → ennreal} (hf : ae_measurable f μ) (hg : ae_measurable g μ) (hp1 : 1 ≤ p) : (∫⁻ (a : α), (f + g) a ^ p ∂μ) ^ (1 / p) ≤ (∫⁻ (a : α), f a ^ p ∂μ) ^ (1 / p) + (∫⁻ (a : α), g a ^ p ∂μ) ^ (1 / p)
theorem is_cyclotomic_extension.integral (S : set ℕ+) (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] [is_domain B] [is_noetherian_ring A] [fintype ↥S] [is_cyclotomic_extension S A B] : algebra.is_integral A B
theorem solvable_by_rad.induction2 {F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] {α β γ : ↥(solvable_by_rad F E)} (hγ : γ ∈ F⟮α, β⟯) (hα : solvable_by_rad.P α) (hβ : solvable_by_rad.P β) : solvable_by_rad.P γ
theorem turing.to_partrec.step_ret_then {k k' : turing.to_partrec.cont} {v : list ℕ} : turing.to_partrec.step_ret (k.then k') v = (turing.to_partrec.step_ret k v).then k'
theorem is_compact_interval {α : Type u_1} [linear_order α] [topological_space α] [compact_Icc_space α] {a b : α} : is_compact (set.interval a b)
theorem finset.sum_centroid_weights_indicator (k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) [fintype ι] : finset.univ.sum (λ (i : ι), finset.centroid_weights_indicator k s i) = s.sum (λ (i : ι), finset.centroid_weights k s i)
theorem convolution_lmul {𝕜 : Type u_1} {G : Type u_2} {x : G} [nondiscrete_normed_field 𝕜] [measurable_space G] {μ : measure_theory.measure G} [has_sub G] [normed_space ℝ 𝕜] [complete_space 𝕜] {f g : G → 𝕜} : convolution f g (continuous_linear_map.lmul 𝕜 𝕜) μ x = ∫ (t : G), f t * g (x - t) ∂μ
theorem nat.perm_factors_mul_of_coprime {a b : ℕ} (hab : a.coprime b) : (a * b).factors ~ a.factors ++ b.factors
theorem con.le_def {M : Type u_1} [has_mul M] {c d : con M} : c ≤ d ↔ ∀ {x y : M}, ⇑c x y → ⇑d x y
theorem mem_nhds_within_Iio_iff_exists_Ioo_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_min_order α] {a : α} {s : set α} : s ∈ nhds_within a (set.Iio a) ↔ ∃ (l : α) (H : l ∈ set.Iio a), set.Ioo l a ⊆ s
theorem cont_diff_within_at.smul {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {x : E} {n : with_top ℕ} {s : set E} {f : E → 𝕜} {g : E → F} (hf : cont_diff_within_at 𝕜 n f s x) (hg : cont_diff_within_at 𝕜 n g s x) : cont_diff_within_at 𝕜 n (λ (x : E), f x • g x) s x
theorem tsirelson_inequality {R : Type u} [ordered_ring R] [star_ordered_ring R] [algebra ℝ R] [ordered_smul ℝ R] [star_module ℝ R] (A₀ A₁ B₀ B₁ : R) (T : is_CHSH_tuple A₀ A₁ B₀ B₁) : A₀ * B₀ + A₀ * B₁ + A₁ * B₀ - A₁ * B₁ ≤ real.sqrt 2 ^ 3 • 1
theorem apply_dite {α : Sort u_1} {β : Sort u_2} (f : α → β) (P : Prop) [decidable P] (x : P → α) (y : ¬P → α) : f (dite P x y) = dite P (λ (h : P), f (x h)) (λ (h : ¬P), f (y h))
theorem tendsto_locally_uniformly.tendsto_comp {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {x : α} {p : filter ι} {g : ι → α} [topological_space α] (h : tendsto_locally_uniformly F f p) (hf : continuous_at f x) (hg : filter.tendsto g p (nhds x)) : filter.tendsto (λ (n : ι), F n (g n)) p (nhds (f x))
theorem besicovitch.exist_disjoint_covering_families {α : Type u_1} [metric_space α] {β : Type u} {N : ℕ} {τ : ℝ} (hτ : 1 < τ) (hN : is_empty (besicovitch.satellite_config α N τ)) (q : besicovitch.ball_package β α) : ∃ (s : fin N → set β), (∀ (i : fin N), (s i).pairwise_disjoint (λ (j : β), metric.closed_ball (q.c j) (q.r j))) ∧ set.range q.c ⊆ ⋃ (i : fin N) (j : β) (H : j ∈ s i), metric.ball (q.c j) (q.r j)
theorem finsum_mem_singleton {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} {a : α} : finsum (λ (i : α), finsum (λ (H : i ∈ {a}), f i)) = f a
theorem set.prod_mul_indicator_subset_of_eq_one {α : Type u_1} {M : Type u_4} {N : Type u_5} [comm_monoid M] [has_one N] (f : α → N) (g : α → N → M) {s t : finset α} (h : s ⊆ t) (hg : ∀ (a : α), g a 1 = 1) : s.prod (λ (i : α), g i (f i)) = t.prod (λ (i : α), g i (↑s.mul_indicator f i))
theorem is_primitive_root.pow_is_root_minpoly {n : ℕ} {K : Type u_8} [field K] {μ : K} (h : is_primitive_root μ n) [char_zero K] {m : ℕ} (hcop : m.coprime n) : (polynomial.map (int.cast_ring_hom K) (minpoly ℤ μ)).is_root (μ ^ m)
theorem category_theory.limits.equalizer.hom_ext {C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} [category_theory.limits.has_equalizer f g] {W : C} {k l : W ⟶ category_theory.limits.equalizer f g} (h : k ≫ category_theory.limits.equalizer.ι f g = l ≫ category_theory.limits.equalizer.ι f g) : k = l
theorem add_subgroup.norm_coe {E : Type u_1} [semi_normed_group E] {s : add_subgroup E} (x : ↥s) : ∥↑x∥ = ∥x∥
theorem nnreal.rpow_arith_mean_le_arith_mean_rpow {ι : Type u} (s : finset ι) (w z : ι → nnreal) (hw' : s.sum (λ (i : ι), w i) = 1) {p : ℝ} (hp : 1 ≤ p) : s.sum (λ (i : ι), w i * z i) ^ p ≤ s.sum (λ (i : ι), w i * z i ^ p)
theorem tendsto_measure_cthickening_of_is_closed {α : Type u_1} [pseudo_metric_space α] [measurable_space α] [opens_measurable_space α] {μ : measure_theory.measure α} {s : set α} (hs : ∃ (R : ℝ) (H : R > 0), ⇑μ (metric.cthickening R s) ≠ ⊤) (h's : is_closed s) : filter.tendsto (λ (r : ℝ), ⇑μ (metric.cthickening r s)) (nhds 0) (nhds (⇑μ s))
theorem local_homeomorph.is_image.of_symm_preimage_eq' {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {e : local_homeomorph α β} {s : set α} {t : set β} : e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' (e.to_local_equiv.source ∩ s) = e.to_local_equiv.target ∩ t → e.is_image s t
theorem totally_bounded.image {α : Type u} {β : Type v} [uniform_space α] [uniform_space β] {f : α → β} {s : set α} (hs : totally_bounded s) (hf : uniform_continuous f) : totally_bounded (f '' s)
theorem ordinal.principal_add_iff_zero_or_omega_opow {o : ordinal} : ordinal.principal has_add.add o ↔ o = 0 ∨ ∃ (a : ordinal), o = ordinal.omega ^ a
theorem galois_connection.le_u_l_trans {α : Type u} {β : Type v} [preorder α] [preorder β] {l : α → β} {u : β → α} (gc : galois_connection l u) {x y z : α} (hxy : x ≤ u (l y)) (hyz : y ≤ u (l z)) : x ≤ u (l z)
theorem is_primitive_root.aut_to_pow_injective {n : ℕ+} (K : Type u_1) [field K] {L : Type u_2} [field L] {μ : L} (hμ : is_primitive_root μ ↑n) [algebra K L] [is_cyclotomic_extension {n} K L] : function.injective ⇑(is_primitive_root.aut_to_pow K hμ)
theorem subgroup.le_normalizer_map {G : Type u_1} [group G] {H : subgroup G} {N : Type u_3} [group N] (f : G →* N) : subgroup.map f H.normalizer ≤ (subgroup.map f H).normalizer
theorem inv_lt_of_inv_lt' {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} : a⁻¹ < b → b⁻¹ < a
theorem category_theory.limits.has_biproduct_of_total {C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] {f : J → C} (b : category_theory.limits.bicone f) (total : finset.univ.sum (λ (j : J), b.π j ≫ b.ι j) = 𝟙 b.X) : category_theory.limits.has_biproduct f
theorem topological_space.is_topological_basis_of_subbasis {α : Type u} [t : topological_space α] {s : set (set α)} (hs : t = topological_space.generate_from s) : topological_space.is_topological_basis ((λ (f : set (set α)), ⋂₀ f) '' {f : set (set α) | f.finite ∧ f ⊆ s ∧ (⋂₀ f).nonempty})
theorem cardinal.mk_univ_quaternion_algebra {R : Type u_1} (c₁ c₂ : R) : cardinal.mk ↥set.univ = cardinal.mk R ^ 4
theorem fin.succ_above_lt_gt {n : ℕ} (p : fin (n + 1)) (i : fin n) : ⇑fin.cast_succ i < p ∨ p < i.succ
theorem dist_le_of_approx_trajectories_ODE {E : Type u_1} [normed_group E] [normed_space ℝ E] {v : ℝ → E → E} {K : nnreal} (hv : ∀ (t : ℝ), lipschitz_with K (v t)) {f g f' g' : ℝ → E} {a b εf εg δ : ℝ} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (t : ℝ), t ∈ set.Ico a b → has_deriv_within_at f (f' t) (set.Ici t) t) (f_bound : ∀ (t : ℝ), t ∈ set.Ico a b → has_dist.dist (f' t) (v t (f t)) ≤ εf) (hg : continuous_on g (set.Icc a b)) (hg' : ∀ (t : ℝ), t ∈ set.Ico a b → has_deriv_within_at g (g' t) (set.Ici t) t) (g_bound : ∀ (t : ℝ), t ∈ set.Ico a b → has_dist.dist (g' t) (v t (g t)) ≤ εg) (ha : has_dist.dist (f a) (g a) ≤ δ) (t : ℝ) (H : t ∈ set.Icc a b) : has_dist.dist (f t) (g t) ≤ gronwall_bound δ ↑K (εf + εg) (t - a)
theorem has_strict_fderiv_at.exists_lipschitz_on_with {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {x : E} (hf : has_strict_fderiv_at f f' x) : ∃ (K : nnreal) (s : set E) (H : s ∈ nhds x), lipschitz_on_with K f s
theorem generate_from_prod_eq {α : Type u_1} {β : Type u_2} {C : set (set α)} {D : set (set β)} (hC : is_countably_spanning C) (hD : is_countably_spanning D) : prod.measurable_space = measurable_space.generate_from (set.image2 has_set_prod.prod C D)
theorem uv.compression_idem {α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v : α) (s : finset α) : uv.compression u v (uv.compression u v s) = uv.compression u v s
theorem local_homeomorph.is_image.of_symm_preimage_eq {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {e : local_homeomorph α β} {s : set α} {t : set β} : e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' s = e.to_local_equiv.target ∩ t → e.is_image s t
theorem nat.modeq_iff_dvd' {n a b : ℕ} (h : a ≤ b) : a ≡ b [MOD n] ↔ n ∣ b - a
theorem generalized_continued_fraction.int_fract_pair.nth_stream_fr_lt_one {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : ifp_n.fr < 1
theorem minpoly.aeval_of_is_scalar_tower (R : Type u_1) {K : Type u_2} {T : Type u_3} {U : Type u_4} [comm_ring R] [field K] [comm_ring T] [algebra R K] [algebra K T] [algebra R T] [is_scalar_tower R K T] [comm_semiring U] [algebra K U] [algebra R U] [is_scalar_tower R K U] (x : T) (y : U) (hy : ⇑(polynomial.aeval y) (minpoly K x) = 0) : ⇑(polynomial.aeval y) (minpoly R x) = 0
theorem mvpfunctor.W_ind {n : ℕ} (P : mvpfunctor (n + 1)) {α : typevec n} {C : P.W α → Prop} (ih : ∀ (a : P.A) (f' : (P.drop.B a).arrow α) (f : P.last.B a → P.W α), (∀ (i : P.last.B a), C (f i)) → C (P.W_mk a f' f)) (x : P.W α) : C x
theorem dfinsupp.lhom_ext {ι : Type u_1} {R : Type u_2} {M : ι → Type u_4} {N : Type u_5} [dec_ι : decidable_eq ι] [semiring R] [Π (i : ι), add_comm_monoid (M i)] [Π (i : ι), module R (M i)] [add_comm_monoid N] [module R N] ⦃φ ψ : (Π₀ (i : ι), M i) →ₗ[R] N⦄ (h : ∀ (i : ι) (x : M i), ⇑φ (dfinsupp.single i x) = ⇑ψ (dfinsupp.single i x)) : φ = ψ
theorem ideal.fg.map {R : Type u_1} {S : Type u_2} [semiring R] [semiring S] {I : ideal R} (h : I.fg) (f : R →+* S) : (ideal.map f I).fg
theorem finset.weighted_vsub_eq_weighted_vsub_of_point_of_sum_eq_zero {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (w : ι → k) (p : ι → P) (h : s.sum (λ (i : ι), w i) = 0) (b : P) : ⇑(s.weighted_vsub p) w = ⇑(s.weighted_vsub_of_point p b) w
theorem submodule.le_orthogonal_orthogonal {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) : K ≤ Kᗮᗮ
theorem mdifferentiable_at.differentiable_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {f : E → E'} {x : E} : mdifferentiable_at (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f x → differentiable_at 𝕜 f x
theorem add_subgroup.normal_add {G : Type u_1} [add_group G] (N H : add_subgroup G) [N.normal] : ↑(N ⊔ H) = ↑N + ↑H
theorem cont_diff_within_at.mul {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {x : E} {n : with_top ℕ} {s : set E} {f g : E → 𝕜} (hf : cont_diff_within_at 𝕜 n f s x) (hg : cont_diff_within_at 𝕜 n g s x) : cont_diff_within_at 𝕜 n (λ (x : E), f x * g x) s x
theorem list.nth_le_of_eq {α : Type u} {L L' : list α} (h : L = L') {i : ℕ} (hi : i < L.length) : L.nth_le i hi = L'.nth_le i _
theorem is_lower_set.of_dual {α : Type u_1} [has_le α] {s : set α} : is_lower_set s → is_upper_set (⇑order_dual.of_dual ⁻¹' s)
theorem pow_two {M : Type u} [monoid M] (a : M) : a ^ 2 = a * a
theorem orthonormal.oangle_neg_right {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : hb.oangle x (-y) = hb.oangle x y + ↑real.pi
theorem subsemigroup.closure_eq {M : Type u_1} [has_mul M] (S : subsemigroup M) : subsemigroup.closure ↑S = S
theorem monotone.le_iterate_of_le {α : Type u_1} [preorder α] {f g : α → α} (hg : monotone g) (h : f ≤ g) (n : ℕ) : f^[n] ≤ (g^[n])
theorem matrix.det_succ_row {R : Type v} [comm_ring R] {n : ℕ} (A : matrix (fin n.succ) (fin n.succ) R) (i : fin n.succ) : A.det = finset.univ.sum (λ (j : fin n.succ), (-1) ^ (↑i + ↑j) * A i j * (A.minor ⇑(i.succ_above) ⇑(j.succ_above)).det)
theorem submonoid.localization_map.comp_eq_of_eq {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M →* P} {T : submonoid P} {Q : Type u_4} [comm_monoid Q] (hg : ∀ (y : ↥S), ⇑g ↑y ∈ T) (k : T.localization_map Q) {x y : M} (h : ⇑(f.to_map) x = ⇑(f.to_map) y) : ⇑(k.to_map) (⇑g x) = ⇑(k.to_map) (⇑g y)
theorem filter.exists_antitone_basis {α : Type u_1} (f : filter α) [f.is_countably_generated] : ∃ (x : ℕ → set α), f.has_antitone_basis x
theorem algebra.discr_power_basis_eq_norm (K : Type u) {L : Type v} [field K] [field L] [algebra K L] [module.finite K L] (pb : power_basis K L) [is_separable K L] : algebra.discr K ⇑(pb.basis) = (-1) ^ (finite_dimensional.finrank K L * (finite_dimensional.finrank K L - 1) / 2) * ⇑(algebra.norm K) (⇑(polynomial.aeval pb.gen) (⇑polynomial.derivative (minpoly K pb.gen)))
theorem add_con.lift_funext {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} (f g : c.quotient →+ P) (h : ∀ (a : M), ⇑f ↑a = ⇑g ↑a) : f = g
theorem subsemiring.closure_mono {R : Type u} [non_assoc_semiring R] ⦃s t : set R⦄ (h : s ⊆ t) : subsemiring.closure s ≤ subsemiring.closure t
theorem finset.sum_centroid_weights_eq_one_of_card_ne_zero (k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) [char_zero k] (h : s.card ≠ 0) : s.sum (λ (i : ι), finset.centroid_weights k s i) = 1
theorem image_le_of_liminf_slope_right_lt_deriv_boundary {f f' : ℝ → ℝ} {a b : ℝ} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → ∀ (r : ℝ), f' x < r → (∃ᶠ (z : ℝ) in nhds_within x (set.Ioi x), slope f x z < r)) {B B' : ℝ → ℝ} (ha : f a ≤ B a) (hB : ∀ (x : ℝ), has_deriv_at B (B' x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → f x = B x → f' x < B' x) ⦃x : ℝ⦄ : x ∈ set.Icc a b → f x ≤ B x
theorem ennreal.sum_lt_top {α : Type u_1} {s : finset α} {f : α → ennreal} (h : ∀ (a : α), a ∈ s → f a ≠ ⊤) : s.sum (λ (a : α), f a) < ⊤
theorem inner_product_space.is_self_adjoint.diagonalization_apply_self_apply {𝕜 : Type u_1} [is_R_or_C 𝕜] [dec_𝕜 : decidable_eq 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] {T : E →ₗ[𝕜] E} (hT : inner_product_space.is_self_adjoint T) [finite_dimensional 𝕜 E] (v : E) (μ : module.End.eigenvalues T) : ⇑(hT.diagonalization) (⇑T v) μ = ↑μ • ⇑(hT.diagonalization) v μ
theorem set.image_congr' {α : Type u} {β : Type v} {f g : α → β} {s : set α} (h : ∀ (x : α), f x = g x) : f '' s = g '' s
theorem not_is_unit_prime_of_dvd_card {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p
theorem matrix.det_conj' {m : Type u} {α : Type v} [comm_ring α] [fintype m] [decidable_eq m] {M : matrix m m α} (h : is_unit M) (N : matrix m m α) : ((M⁻¹.mul N).mul M).det = N.det
theorem upper_semicontinuous_within_at.add {α : Type u_1} [topological_space α] {x : α} {s : set α} {γ : Type u_4} [linear_ordered_add_comm_monoid γ] [topological_space γ] [order_topology γ] [has_continuous_add γ] {f g : α → γ} (hf : upper_semicontinuous_within_at f s x) (hg : upper_semicontinuous_within_at g s x) : upper_semicontinuous_within_at (λ (z : α), f z + g z) s x
theorem filter.tendsto.cesaro {u : ℕ → ℝ} {l : ℝ} (h : filter.tendsto u filter.at_top (nhds l)) : filter.tendsto (λ (n : ℕ), (↑n)⁻¹ * (finset.range n).sum (λ (i : ℕ), u i)) filter.at_top (nhds l)
theorem affine_independent_iff {k : Type u_1} {V : Type u_2} [ring k] [add_comm_group V] [module k V] {ι : Type u_3} {p : ι → V} : affine_independent k p ↔ ∀ (s : finset ι) (w : ι → k), s.sum w = 0 → s.sum (λ (e : ι), w e • p e) = 0 → ∀ (e : ι), e ∈ s → w e = 0
theorem polynomial.gal.card_of_separable {F : Type u_1} [field F] {p : polynomial F} (hp : p.separable) : fintype.card p.gal = finite_dimensional.finrank F p.splitting_field
theorem is_cyclotomic_extension.union_right (S T : set ℕ+) (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] [h : is_cyclotomic_extension (S ∪ T) A B] : is_cyclotomic_extension T ↥(algebra.adjoin A {b : B | ∃ (a : ℕ+), a ∈ S ∧ b ^ ↑a = 1}) B
theorem neg_nonpos {α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : -a ≤ 0 ↔ 0 ≤ a
theorem ideal.injective_quotient_le_comap_map {R : Type u_1} [comm_ring R] (P : ideal (polynomial R)) : function.injective ⇑((ideal.map (polynomial.map_ring_hom (ideal.quotient.mk (ideal.comap polynomial.C P))) P).quotient_map (polynomial.map_ring_hom (ideal.quotient.mk (ideal.comap polynomial.C P))) ideal.le_comap_map)
theorem lipschitz_on_with.approximates_linear_on {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {s : set E} {c : nnreal} : lipschitz_on_with c (f - ⇑f') s → approximates_linear_on f f' s c
theorem nat.eq_pow_of_factorization_eq_single {n p k : ℕ} (hn : n ≠ 0) (h : n.factorization = finsupp.single p k) : n = p ^ k
theorem legendre_symbol.sum_mul_div_add_sum_mul_div_eq_mul (p q : ℕ) [hp : fact (nat.prime p)] (hq0 : ↑q ≠ 0) : (finset.Ico 1 (p / 2).succ).sum (λ (a : ℕ), a * q / p) + (finset.Ico 1 (q / 2).succ).sum (λ (a : ℕ), a * p / q) = p / 2 * (q / 2)
theorem is_semiring_hom.to_is_add_monoid_hom {α : Type u} {β : Type v} [semiring α] [semiring β] {f : α → β} (hf : is_semiring_hom f) : is_add_monoid_hom f
theorem circle_integral.integral_sub_inv_of_mem_ball {c w : ℂ} {R : ℝ} (hw : w ∈ metric.ball c R) : ∮ (z : ℂ) in C(c, R), (z - w)⁻¹ = 2 * ↑real.pi * complex.I
theorem supr_option_elim {α : Type u_1} {β : Type u_2} [complete_lattice α] (a : α) (f : β → α) : (⨆ (o : option β), option.elim a f o) = a ⊔ ⨆ (b : β), f b
theorem emetric.inf_edist_anti {α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} (h : s ⊆ t) : emetric.inf_edist x t ≤ emetric.inf_edist x s
theorem antilipschitz_with.of_le_mul_dist {α : Type u_1} {β : Type u_2} [pseudo_metric_space α] [pseudo_metric_space β] {K : nnreal} {f : α → β} : (∀ (x y : α), has_dist.dist x y ≤ ↑K * has_dist.dist (f x) (f y)) → antilipschitz_with K f
theorem module.projective_of_lifting_property' {R : Type u} [semiring R] {P : Type (max u v)} [add_comm_monoid P] [module R P] (huniv : ∀ {M : Type (max v u)} {N : Type (max u v)} [_inst_8 : add_comm_monoid M] [_inst_9 : add_comm_monoid N] [_inst_10 : module R M] [_inst_11 : module R N] (f : M →ₗ[R] N) (g : P →ₗ[R] N), function.surjective ⇑f → (∃ (h : P →ₗ[R] M), f.comp h = g)) : module.projective R P
theorem category_theory.well_powered_congr {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (e : C ≌ D) : category_theory.well_powered C ↔ category_theory.well_powered D
theorem linear_recurrence.geom_sol_iff_root_char_poly {α : Type u_1} [comm_ring α] (E : linear_recurrence α) (q : α) : E.is_solution (λ (n : ℕ), q ^ n) ↔ E.char_poly.is_root q
theorem complex.circle_integral_sub_center_inv_smul_of_differentiable_on_off_countable {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] {R : ℝ} (h0 : 0 < R) {f : ℂ → E} {c : ℂ} {s : set ℂ} (hs : s.countable) (hc : continuous_on f (metric.closed_ball c R)) (hd : ∀ (z : ℂ), z ∈ metric.ball c R  s → differentiable_at ℂ f z) : ∮ (z : ℂ) in C(c, R), (z - c)⁻¹ • f z = (2 * ↑real.pi * complex.I) • f c
theorem set.prod_mul_indicator_subset {α : Type u_1} {M : Type u_4} [comm_monoid M] (f : α → M) {s t : finset α} (h : s ⊆ t) : s.prod (λ (i : α), f i) = t.prod (λ (i : α), ↑s.mul_indicator f i)
theorem cardinal.mk_Ioc_real {a b : ℝ} (h : a < b) : cardinal.mk ↥(set.Ioc a b) = cardinal.continuum
theorem lucas_lehmer.X.X_card {q : ℕ+} : fintype.card (lucas_lehmer.X q) = ↑q ^ 2
theorem interval_integral.integral_has_strict_deriv_at_right {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (hb : continuous_at f b) : has_strict_deriv_at (λ (u : ℝ), ∫ (x : ℝ) in a..u, f x) (f b) b
theorem flow.omega_limit_image_eq {τ : Type u_1} [topological_space τ] [add_comm_group τ] [topological_add_group τ] {α : Type u_2} [topological_space α] (f : filter τ) (ϕ : flow τ α) (s : set α) (hf : ∀ (t : τ), filter.tendsto (λ (_x : τ), _x + t) f f) (t : τ) : omega_limit f ⇑ϕ (⇑ϕ t '' s) = omega_limit f ⇑ϕ s
theorem finset.Icc_eq_empty {α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a ≤ b → finset.Icc a b = ∅
theorem nat.lt_wf  : well_founded nat.lt
theorem lipschitz_with.of_dist_le_mul {α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {K : nnreal} {f : α → β} : (∀ (x y : α), has_dist.dist (f x) (f y) ≤ ↑K * has_dist.dist x y) → lipschitz_with K f
theorem minpoly.monic {A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] {x : B} (hx : is_integral A x) : (minpoly A x).monic
theorem monotone.csupr_mem_Inter_Icc_of_antitone {α : Type u_1} {β : Type u_2} [conditionally_complete_lattice α] [semilattice_sup β] {f g : β → α} (hf : monotone f) (hg : antitone g) (h : f ≤ g) : (⨆ (n : β), f n) ∈ ⋂ (n : β), set.Icc (f n) (g n)
theorem list.length_pos_of_sum_ne_zero {M : Type u_3} [add_monoid M] (L : list M) (h : L.sum ≠ 0) : 0 < L.length
theorem with_top.sum_eq_top_iff {ι : Type u_1} {M : Type u_4} [ordered_add_comm_monoid M] {s : finset ι} {f : ι → with_top M} : s.sum (λ (i : ι), f i) = ⊤ ↔ ∃ (i : ι) (H : i ∈ s), f i = ⊤
theorem one_lt_mul' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
theorem polynomial.cyclotomic_prime_pow_eq_geom_sum {R : Type u_1} [comm_ring R] {p n : ℕ} (hp : nat.prime p) : polynomial.cyclotomic (p ^ (n + 1)) R = (finset.range p).sum (λ (i : ℕ), (polynomial.X ^ p ^ n) ^ i)
theorem parser.nat_eq_done {cb : char_buffer} {n n' val : ℕ} : parser.nat cb n = parse_result.done n' val ↔ ∃ (hn : n < n'), val = nat.of_digits 10 (list.map (λ (c : char), c.to_nat - '0'.to_nat) (list.take (n' - n) (list.drop n (buffer.to_list cb))).reverse) ∧ (∀ (hn' : n' < buffer.size cb), '0' ≤ buffer.read cb ⟨n', hn'⟩ → '9' < buffer.read cb ⟨n', hn'⟩) ∧ ∃ (hn'' : n' ≤ buffer.size cb), ∀ (k : ℕ) (hk : k < n'), n ≤ k → '0' ≤ buffer.read cb ⟨k, _⟩ ∧ buffer.read cb ⟨k, _⟩ ≤ '9'
theorem simple_graph.min_degree_le_degree {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (v : V) : G.min_degree ≤ G.degree v
theorem norm_smul_inv_norm' {𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {r : ℝ} (r_nonneg : 0 ≤ r) {x : E} (hx : x ≠ 0) : ∥(↑r * (↑∥x∥)⁻¹) • x∥ = r
theorem continuous_at.div {α : Type u_1} {G₀ : Type u_3} [group_with_zero G₀] [topological_space G₀] [has_continuous_inv₀ G₀] [has_continuous_mul G₀] {f g : α → G₀} [topological_space α] {a : α} (hf : continuous_at f a) (hg : continuous_at g a) (h₀ : g a ≠ 0) : continuous_at (f / g) a
theorem add_valuation.supp_quot {R : Type u_2} {Γ₀ : Type u_3} [linear_ordered_add_comm_monoid_with_top Γ₀] [comm_ring R] (v : add_valuation R Γ₀) {J : ideal R} (hJ : J ≤ v.supp) : (v.on_quot hJ).supp = ideal.map (ideal.quotient.mk J) v.supp
theorem finite_dimensional.finrank_eq_card_basis {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type w} [fintype ι] (h : basis ι K V) : finite_dimensional.finrank K V = fintype.card ι
theorem euclidean_geometry.dist_sq_eq_dist_orthogonal_projection_sq_add_dist_orthogonal_projection_sq {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} [nonempty ↥s] [complete_space ↥(s.direction)] {p1 : P} (p2 : P) (hp1 : p1 ∈ s) : has_dist.dist p1 p2 * has_dist.dist p1 p2 = has_dist.dist p1 ↑(⇑(euclidean_geometry.orthogonal_projection s) p2) * has_dist.dist p1 ↑(⇑(euclidean_geometry.orthogonal_projection s) p2) + has_dist.dist p2 ↑(⇑(euclidean_geometry.orthogonal_projection s) p2) * has_dist.dist p2 ↑(⇑(euclidean_geometry.orthogonal_projection s) p2)
theorem emetric.Hausdorff_edist_self_closure {α : Type u} [pseudo_emetric_space α] {s : set α} : emetric.Hausdorff_edist s (closure s) = 0
theorem refl_trans_gen_of_succ_of_le {α : Type u_1} [partial_order α] [succ_order α] [is_succ_archimedean α] (r : α → α → Prop) {n m : α} (h : ∀ (i : α), i ∈ set.Ico n m → r i (order.succ i)) (hnm : n ≤ m) : relation.refl_trans_gen r n m
theorem is_local_max.deriv_eq_zero {f : ℝ → ℝ} {a : ℝ} (h : is_local_max f a) : deriv f a = 0
theorem polynomial.nat_degree_prod' {R : Type u} {ι : Type w} (s : finset ι) [comm_semiring R] (f : ι → polynomial R) (h : s.prod (λ (i : ι), (f i).leading_coeff) ≠ 0) : (s.prod (λ (i : ι), f i)).nat_degree = s.sum (λ (i : ι), (f i).nat_degree)
theorem affine.simplex.mk_of_point_points (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) (i : fin 1) : (affine.simplex.mk_of_point k p).points i = p
theorem set.inv_Ioo_0_left {k : Type u} [linear_ordered_field k] {a : k} (ha : 0 < a) : (set.Ioo 0 a)⁻¹ = set.Ioi a⁻¹
theorem local_equiv.eq_of_eq_on_source_univ {α : Type u_1} {β : Type u_2} (e e' : local_equiv α β) (h : e ≈ e') (s : e.source = set.univ) (t : e.target = set.univ) : e = e'
theorem lipschitz_with_of_nnnorm_deriv_le {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_group G] [normed_space 𝕜 G] {f : 𝕜 → G} {C : nnreal} (hf : differentiable 𝕜 f) (bound : ∀ (x : 𝕜), ∥deriv f x∥₊ ≤ C) : lipschitz_with C f
theorem strict_anti_on.Iic_union_Ici {α : Type u_1} {β : Type u_2} [linear_order α] [preorder β] {a : α} {f : α → β} (h₁ : strict_anti_on f (set.Iic a)) (h₂ : strict_anti_on f (set.Ici a)) : strict_anti f
theorem affine_map.line_map_continuous {R : Type u_1} {F : Type u_3} [add_comm_group F] [topological_space F] [topological_add_group F] [ring R] [module R F] [topological_space R] [has_continuous_smul R F] {p v : F} : continuous ⇑(affine_map.line_map p v)
theorem eq.subset {α : Type u_1} {s t : set α} : s = t → s ⊆ t
theorem mul_hom.congr_arg {M : Type u_3} {N : Type u_4} [has_mul M] [has_mul N] (f : M →ₙ* N) {x y : M} (h : x = y) : ⇑f x = ⇑f y
theorem is_frobenius_number_pair {m n : ℕ} (cop : m.coprime n) (hm : 1 < m) (hn : 1 < n) : is_frobenius_number (m * n - m - n) {m, n}
theorem edist_eq_zero {γ : Type w} [emetric_space γ] {x y : γ} : has_edist.edist x y = 0 ↔ x = y
theorem measure_theory.is_fundamental_domain.measure_eq {G : Type u_1} {α : Type u_2} [group G] [mul_action G α] [measurable_space α] {s t : set α} {μ : measure_theory.measure α} [measurable_space G] [has_measurable_smul G α] [measure_theory.smul_invariant_measure G α μ] [encodable G] (hs : measure_theory.is_fundamental_domain G s μ) (ht : measure_theory.is_fundamental_domain G t μ) : ⇑μ s = ⇑μ t
theorem padic_int.lift_unique {p : ℕ} [hp_prime : fact (nat.prime p)] {R : Type u_1} [non_assoc_semiring R] {f : Π (k : ℕ), R →+* zmod (p ^ k)} (f_compat : ∀ (k1 k2 : ℕ) (hk : k1 ≤ k2), (zmod.cast_hom _ (zmod (p ^ k1))).comp (f k2) = f k1) (g : R →+* ℤ_[p]) (hg : ∀ (n : ℕ), (padic_int.to_zmod_pow n).comp g = f n) : padic_int.lift f_compat = g
theorem multiset.sub_zero {α : Type u_1} [decidable_eq α] (s : multiset α) : s - 0 = s
theorem setoid.Sup_eq_eqv_gen {α : Type u_1} (S : set (setoid α)) : has_Sup.Sup S = eqv_gen.setoid (λ (x y : α), ∃ (r : setoid α), r ∈ S ∧ r.rel x y)
theorem polynomial.cyclotomic_expand_eq_cyclotomic_mul {p n : ℕ} (hp : nat.prime p) (hdiv : ¬p ∣ n) (R : Type u_1) [comm_ring R] : ⇑(polynomial.expand R p) (polynomial.cyclotomic n R) = polynomial.cyclotomic (n * p) R * polynomial.cyclotomic n R
theorem convex.set_combo_subset {𝕜 : Type u_1} {E : Type u_2} [ordered_semiring 𝕜] [add_comm_monoid E] [has_scalar 𝕜 E] {s : set E} : convex 𝕜 s → ∀ ⦃a b : 𝕜⦄, 0 ≤ a → 0 ≤ b → a + b = 1 → a • s + b • s ⊆ s
theorem field.to_is_field (R : Type u) [field R] : is_field R
theorem finset.nat.prod_antidiagonal_eq_prod_range_succ {M : Type u_1} [comm_monoid M] (f : ℕ → ℕ → M) (n : ℕ) : (finset.nat.antidiagonal n).prod (λ (ij : ℕ × ℕ), f ij.fst ij.snd) = (finset.range n.succ).prod (λ (k : ℕ), f k (n - k))
theorem add_con.symm {M : Type u_1} [has_add M] (c : add_con M) {x y : M} : ⇑c x y → ⇑c y x
theorem affine_basis.linear_combination_coord_eq_self {ι : Type u₁} {k : Type u₂} {V : Type u₃} [add_comm_group V] [ring k] [module k V] [fintype ι] (b : affine_basis ι k V) (v : V) : finset.univ.sum (λ (i : ι), ⇑(b.coord i) v • b.points i) = v
theorem homology_map_eq_of_homotopy {ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D : homological_complex V c} {f g : C ⟶ D} [category_theory.limits.has_equalizers V] [category_theory.limits.has_cokernels V] [category_theory.limits.has_images V] [category_theory.limits.has_image_maps V] [category_theory.limits.has_zero_object V] (h : homotopy f g) (i : ι) : (homology_functor V c i).map f = (homology_functor V c i).map g
theorem ae_strongly_measurable_of_tendsto_ae {α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [topological_space β] {ι : Type u_3} [topological_space.pseudo_metrizable_space β] (u : filter ι) [u.ne_bot] [u.is_countably_generated] {f : ι → α → β} {g : α → β} (hf : ∀ (i : ι), measure_theory.ae_strongly_measurable (f i) μ) (lim : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ι), f n x) u (nhds (g x))) : measure_theory.ae_strongly_measurable g μ
theorem measure_theory.pdf.to_quasi_measure_preserving {α : Type u_1} {E : Type u_2} [measurable_space E] {m : measurable_space α} {ℙ : measure_theory.measure α} {μ : measure_theory.measure E} {X : α → E} [measure_theory.has_pdf X «ℙ» μ] : measure_theory.measure.quasi_measure_preserving X «ℙ» μ
theorem finset.le_sum_of_subadditive {ι : Type u_1} {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [ordered_add_comm_monoid N] (f : M → N) (h_one : f 0 = 0) (h_mul : ∀ (x y : M), f (x + y) ≤ f x + f y) (s : finset ι) (g : ι → M) : f (s.sum (λ (i : ι), g i)) ≤ s.sum (λ (i : ι), f (g i))
theorem linear_isometry_equiv.inner_map_map {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {E' : Type u_7} [inner_product_space 𝕜 E'] (f : E ≃ₗᵢ[𝕜] E') (x y : E) : has_inner.inner (⇑f x) (⇑f y) = has_inner.inner x y
theorem finset.univ_filter_mem_range {α : Type u_1} {β : Type u_2} [fintype α] (f : α → β) [fintype β] [decidable_pred (λ (y : β), y ∈ set.range f)] [decidable_eq β] : finset.filter (λ (y : β), y ∈ set.range f) finset.univ = finset.image f finset.univ
theorem power_series.le_order {R : Type u_1} [semiring R] (φ : power_series R) (n : enat) (h : ∀ (i : ℕ), ↑i < n → ⇑(power_series.coeff R i) φ = 0) : n ≤ φ.order
theorem bilin_form.restrict_nondegenerate_of_is_compl_orthogonal {V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {B : bilin_form K V} {W : subspace K V} (b₁ : B.is_refl) (b₂ : (B.restrict W).nondegenerate) : is_compl W (B.orthogonal W)
theorem ordinal.fp_family_unbounded {ι : Type u} {f : ι → ordinal → ordinal} (H : ∀ (i : ι), ordinal.is_normal (f i)) : set.unbounded has_lt.lt (⋂ (i : ι), function.fixed_points (f i))
theorem matrix.nonsing_inv_eq_ring_inverse {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) : A⁻¹ = ring.inverse A
theorem dim_range_add_dim_ker {K : Type u} {V V₁ : Type v} [field K] [add_comm_group V] [module K V] [add_comm_group V₁] [module K V₁] (f : V →ₗ[K] V₁) : module.rank K ↥(f.range) + module.rank K ↥(f.ker) = module.rank K V
theorem set.countable.dimH_zero {X : Type u_2} [emetric_space X] {s : set X} (hs : s.countable) : dimH s = 0
theorem lower_adjoint.le_closure {α : Type u_1} {β : Type u_4} [preorder α] [preorder β] {u : β → α} (l : lower_adjoint u) (x : α) : x ≤ u (⇑l x)
theorem dite_apply {α : Sort u_1} {σ : α → Sort u_4} (P : Prop) [decidable P] (f : P → Π (a : α), σ a) (g : ¬P → Π (a : α), σ a) (a : α) : dite P f g a = dite P (λ (h : P), f h a) (λ (h : ¬P), g h a)
theorem contracting_with.exists_fixed_point' {α : Type u_1} [emetric_space α] {K : nnreal} {f : α → α} {s : set α} (hsc : is_complete s) (hsf : set.maps_to f s s) (hf : contracting_with K (set.maps_to.restrict f s s hsf)) {x : α} (hxs : x ∈ s) (hx : has_edist.edist x (f x) ≠ ⊤) : ∃ (y : α) (H : y ∈ s), function.is_fixed_pt f y ∧ filter.tendsto (λ (n : ℕ), f^[n] x) filter.at_top (nhds y) ∧ ∀ (n : ℕ), has_edist.edist (f^[n] x) y ≤ has_edist.edist x (f x) * ↑K ^ n / (1 - ↑K)
theorem ring.inverse_non_unit {M₀ : Type u_1} [monoid_with_zero M₀] (x : M₀) (h : ¬is_unit x) : ring.inverse x = 0
theorem finsupp.mul_prod_erase {α : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [comm_monoid N] (f : α →₀ M) (y : α) (g : α → M → N) (hyf : y ∈ f.support) : g y (⇑f y) * (finsupp.erase y f).prod g = f.prod g
theorem pgame.right_distrib_equiv (x y z : pgame) : ((x + y) * z).equiv (x * z + y * z)
theorem has_subset.subset.not_ssubset {α : Type u} [has_subset α] [has_ssubset α] [is_nonstrict_strict_order α has_subset.subset has_ssubset.ssubset] {a b : α} (h : a ⊆ b) : ¬b ⊂ a
theorem subsingleton.convex_independent {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] [subsingleton ι] (p : ι → E) : convex_independent 𝕜 p
theorem category_theory.reassoc_of {α : Sort u_1} (hh : α) {β : Prop} (x : tactic.calculated_Prop β hh . "derive_reassoc_proof") : β
theorem measurable_set_of_differentiable_within_at_Ici {F : Type u_1} [normed_group F] [normed_space ℝ F] (f : ℝ → F) [complete_space F] : measurable_set {x : ℝ | differentiable_within_at ℝ f (set.Ici x) x}
theorem fixed_points_subgroup_sup (M : Type u_1) (α : Type u_2) [group M] [mul_action M α] {P Q : subgroup M} : mul_action.fixed_points ↥(P ⊔ Q) α = mul_action.fixed_points ↥P α ∩ mul_action.fixed_points ↥Q α
theorem submonoid.dense_induction {M : Type u_1} [mul_one_class M] {p : M → Prop} (x : M) {s : set M} (hs : submonoid.closure s = ⊤) (Hs : ∀ (x : M), x ∈ s → p x) (H1 : p 1) (Hmul : ∀ (x y : M), p x → p y → p (x * y)) : p x
theorem contracting_with.aposteriori_dist_iterate_fixed_point_le {α : Type u_1} [metric_space α] {K : nnreal} {f : α → α} (hf : contracting_with K f) [nonempty α] [complete_space α] (x : α) (n : ℕ) : has_dist.dist (f^[n] x) (contracting_with.fixed_point f hf) ≤ has_dist.dist (f^[n] x) (f^[n + 1] x) / (1 - ↑K)
theorem is_square_of_exists_sq {α : Type u_2} [monoid α] (m : α) : (∃ (c : α), m = c ^ 2) → is_square m
theorem is_localization.map_injective_of_injective {R : Type u_1} [comm_ring R] (M : submonoid R) (S : Type u_2) [comm_ring S] [algebra R S] {P : Type u_3} [comm_ring P] [is_localization M S] (Q : Type u_5) [comm_ring Q] {g : R →+* P} [algebra P Q] (hg : function.injective ⇑g) [is_localization (submonoid.map ↑g M) Q] (hM : submonoid.map ↑g M ≤ non_zero_divisors P) : function.injective ⇑(is_localization.map Q g _)
theorem finsupp.map_domain_map_range {α : Type u_1} {β : Type u_2} {M : Type u_5} {N : Type u_7} [add_comm_monoid M] [add_comm_monoid N] (f : α → β) (v : α →₀ M) (g : M → N) (h0 : g 0 = 0) (hadd : ∀ (x y : M), g (x + y) = g x + g y) : finsupp.map_domain f (finsupp.map_range g h0 v) = finsupp.map_range g h0 (finsupp.map_domain f v)
theorem category_theory.limits.has_biproduct.of_has_coproduct {C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J → C) [category_theory.limits.has_coproduct f] : category_theory.limits.has_biproduct f
theorem fintype.exists_le_sum_fiber_of_nsmul_le_sum {α : Type u} {β : Type v} {M : Type w} [decidable_eq β] [fintype α] [fintype β] (f : α → β) {w : α → M} {b : M} [linear_ordered_cancel_add_comm_monoid M] [nonempty β] (hb : fintype.card β • b ≤ finset.univ.sum (λ (x : α), w x)) : ∃ (y : β), b ≤ (finset.filter (λ (x : α), f x = y) finset.univ).sum (λ (x : α), w x)
theorem euclidean_geometry.cospherical_pair {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (p₁ p₂ : P) : euclidean_geometry.cospherical {p₁, p₂}
theorem inv_gold_conj  : golden_conj⁻¹ = -golden_ratio
theorem nhds_basis_opens' {α : Type u} [topological_space α] (a : α) : (nhds a).has_basis (λ (s : set α), s ∈ nhds a ∧ is_open s) (λ (x : set α), x)
theorem dimH_def {X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] (s : set X) : dimH s = ⨆ (d : nnreal) (hd : ⇑(measure_theory.measure.hausdorff_measure ↑d) s = ⊤), ↑d
theorem add_monoid.closure_subset {M : Type u_1} [add_monoid M] {s t : set M} (ht : is_add_submonoid t) (h : s ⊆ t) : add_monoid.closure s ⊆ t
theorem category_theory.locally_cover_dense.induced_topology_cover_lifting {C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {G : C ⥤ D} {K : category_theory.grothendieck_topology D} [category_theory.full G] [category_theory.faithful G] (Hld : category_theory.locally_cover_dense K G) : category_theory.cover_lifting Hld.induced_topology K G
theorem orientation.eq_or_eq_neg {R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {ι : Type u_3} [decidable_eq ι] [fintype ι] [finite_dimensional R M] (x₁ x₂ : orientation R M ι) (h : fintype.card ι = finite_dimensional.finrank R M) : x₁ = x₂ ∨ x₁ = -x₂
theorem set.bInter_subset_of_mem {α : Type u_1} {β : Type u_2} {s : set α} {t : α → set β} {x : α} (xs : x ∈ s) : (⋂ (x : α) (H : x ∈ s), t x) ⊆ t x
theorem measure_theory.ae_eq_of_subset_of_measure_ge {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {s t : set α} (h₁ : s ⊆ t) (h₂ : ⇑μ t ≤ ⇑μ s) (hsm : measurable_set s) (ht : ⇑μ t ≠ ⊤) : s =ᵐ[μ] t
theorem set.nonempty.not_disjoint {α : Type u_1} {s t : set α} : (s ∩ t).nonempty → ¬disjoint s t
theorem principal_ideal_ring.ring_hom_mem_submonoid_of_factors_subset_of_units_subset {R : Type u_1} {S : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] [semiring S] (f : R →+* S) (s : submonoid S) (a : R) (ha : a ≠ 0) (h : ∀ (b : R), b ∈ principal_ideal_ring.factors a → ⇑f b ∈ s) (hf : ∀ (c : Rˣ), ⇑f ↑c ∈ s) : ⇑f a ∈ s
theorem convex.exists_nhds_within_lipschitz_on_with_of_has_fderiv_within_at_of_nnnorm_lt {E : Type u_1} [normed_group E] [normed_space ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_space 𝕜 E] [normed_group G] [normed_space 𝕜 G] {s : set E} {x : E} {f' : E → (E →L[𝕜] G)} (hs : convex ℝ s) {f : E → G} (hder : ∀ᶠ (y : E) in nhds_within x s, has_fderiv_within_at f (f' y) s y) (hcont : continuous_within_at f' s x) (K : nnreal) (hK : ∥f' x∥₊ < K) : ∃ (t : set E) (H : t ∈ nhds_within x s), lipschitz_on_with K f t
theorem function.periodic.interval_integral_add_zsmul_eq {E : Type u_1} [normed_group E] [normed_space ℝ E] [complete_space E] {f : ℝ → E} {T : ℝ} (hf : function.periodic f T) (n : ℤ) (t : ℝ) (h_int : ∀ (t₁ t₂ : ℝ), interval_integrable f measure_theory.measure_space.volume t₁ t₂) : ∫ (x : ℝ) in t..t + n • T, f x = n • ∫ (x : ℝ) in t..t + T, f x
theorem nat.exists_strict_anti' {α : Type u} [preorder α] [no_min_order α] (a : α) : ∃ (f : ℕ → α), strict_anti f ∧ f 0 = a
theorem neg_pos {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : 0 < -a ↔ a < 0
theorem orthonormal.exists_linear_isometry_equiv_eq_of_det_pos {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {f : V ≃ₗᵢ[ℝ] V} (hd : 0 < ⇑linear_map.det ↑(f.to_linear_equiv)) : ∃ (θ : real.angle), f = hb.rotation θ
theorem category_theory.is_subterminal.mono_is_terminal_from {C : Type u₁} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) {T : C} (hT : category_theory.limits.is_terminal T) : category_theory.mono (hT.from A)
theorem antivary_on.sum_mul_eq_sum_mul_comp_perm_iff {ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {s : finset ι} {σ : equiv.perm ι} {f g : ι → α} (hfg : antivary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i * g (⇑σ i)) = s.sum (λ (i : ι), f i * g i) ↔ antivary_on f (g ∘ ⇑σ) ↑s
theorem measure_theory.outer_measure.Union_of_tendsto_zero {α : Type u_1} {ι : Type u_2} (m : measure_theory.outer_measure α) {s : ι → set α} (l : filter ι) [l.ne_bot] (h0 : filter.tendsto (λ (k : ι), ⇑m ((⋃ (n : ι), s n)  s k)) l (nhds 0)) : ⇑m (⋃ (n : ι), s n) = ⨆ (n : ι), ⇑m (s n)
theorem ae_eq_const_or_norm_set_integral_lt_of_norm_le_const {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {t : set α} {f : α → E} {C : ℝ} [strict_convex_space ℝ E] (ht : ⇑μ t ≠ ⊤) (h_le : ∀ᵐ (x : α) ∂μ.restrict t, ∥f x∥ ≤ C) : f =ᵐ[μ.restrict t] function.const α (⨍ (x : α) in t, f x ∂μ) ∨ ∥∫ (x : α) in t, f x ∂μ∥ < (⇑μ t).to_real * C
theorem submonoid.supr_induction' {M : Type u_1} [mul_one_class M] {ι : Sort u_2} (S : ι → submonoid M) {C : Π (x : M), (x ∈ ⨆ (i : ι), S i) → Prop} (hp : ∀ (i : ι) (x : M) (H : x ∈ S i), C x _) (h1 : C 1 _) (hmul : ∀ (x y : M) (hx : x ∈ ⨆ (i : ι), S i) (hy : y ∈ ⨆ (i : ι), S i), C x hx → C y hy → C (x * y) _) {x : M} (hx : x ∈ ⨆ (i : ι), S i) : C x hx
theorem submonoid.list_prod_mem {M : Type u_1} [monoid M] (s : submonoid M) {l : list M} (hl : ∀ (x : M), x ∈ l → x ∈ s) : l.prod ∈ s
theorem real.inner_le_Lp_mul_Lq {ι : Type u} (s : finset ι) (f g : ι → ℝ) {p q : ℝ} (hpq : p.is_conjugate_exponent q) : s.sum (λ (i : ι), f i * g i) ≤ s.sum (λ (i : ι), |f i| ^ p) ^ (1 / p) * s.sum (λ (i : ι), |g i| ^ q) ^ (1 / q)
theorem finset.nonempty.to_set {α : Type u_1} {s : finset α} : s.nonempty → ↑s.nonempty
theorem pgame.mul_assoc_equiv (x y z : pgame) : (x * y * z).equiv (x * (y * z))
theorem emetric.cauchy_seq_iff {α : Type u} {β : Type v} [pseudo_emetric_space α] [nonempty β] [semilattice_sup β] {u : β → α} : cauchy_seq u ↔ ∀ (ε : ennreal), ε > 0 → (∃ (N : β), ∀ (m : β), m ≥ N → ∀ (n : β), n ≥ N → has_edist.edist (u m) (u n) < ε)
theorem coe_fn_coe_trans' {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {δ : out_param (Sort u_4)} [has_coe α β] [has_coe_t_aux β γ] [has_coe_to_fun γ (λ (_x : γ), δ)] (x : α) : ⇑x = ⇑↑x
theorem orthonormal.oangle_eq_pi_sub_two_zsmul_oangle_sub_of_norm_eq {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y : V} (hn : x ≠ y) (h : ∥x∥ = ∥y∥) : hb.oangle y x = ↑real.pi - 2 • hb.oangle (y - x) y
theorem module.free.finrank_linear_hom (R : Type u) (M : Type v) (N : Type w) [comm_ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] [add_comm_group N] [module R N] [module.free R N] [module.finite R N] : finite_dimensional.finrank R (M →ₗ[R] N) = finite_dimensional.finrank R M * finite_dimensional.finrank R N
theorem closed_under_restriction_iff_id_le {H : Type u} [topological_space H] (G : structure_groupoid H) : closed_under_restriction G ↔ id_restr_groupoid ≤ G
theorem linear_map.range_eq_top_of_cancel {R : Type u_1} {M : Type u_2} {R₂ : Type u_3} {M₂ : Type u_4} [ring R] [ring R₂] [add_comm_monoid M] [add_comm_group M₂] [module R M] [module R₂ M₂] {τ₁₂ : R →+* R₂} [ring_hom_surjective τ₁₂] {f : M →ₛₗ[τ₁₂] M₂} (h : ∀ (u v : M₂ →ₗ[R₂] M₂ ⧸ f.range), u.comp f = v.comp f → u = v) : f.range = ⊤
theorem quadratic_form.complex_equivalent {M : Type u_1} [add_comm_group M] [module ℂ M] [finite_dimensional ℂ M] (Q₁ Q₂ : quadratic_form ℂ M) (hQ₁ : (⇑quadratic_form.associated Q₁).nondegenerate) (hQ₂ : (⇑quadratic_form.associated Q₂).nondegenerate) : Q₁.equivalent Q₂
theorem Top.nonempty_limit_cone_of_compact_t2_cofiltered_system {J : Type u} [category_theory.small_category J] (F : J ⥤ Top) [category_theory.is_cofiltered J] [∀ (j : J), nonempty ↥(F.obj j)] [∀ (j : J), compact_space ↥(F.obj j)] [∀ (j : J), t2_space ↥(F.obj j)] : nonempty ↥((Top.limit_cone F).X)
theorem is_add_right_regular.of_add {R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_right_regular (b + a)) : is_add_right_regular b
theorem dense.prod {α : Type u} {β : Type v} [topological_space α] [topological_space β] {s : set α} {t : set β} (hs : dense s) (ht : dense t) : dense (s ×ˢ t)
theorem set_has_minimal_iff_artinian {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] : (∀ (a : set (submodule R M)), a.nonempty → (∃ (M' : submodule R M) (H : M' ∈ a), ∀ (I : submodule R M), I ∈ a → I ≤ M' → I = M')) ↔ is_artinian R M
theorem measure_theory.measure.is_haar_measure_map {G : Type u_1} [measurable_space G] [group G] [topological_space G] (μ : measure_theory.measure G) [μ.is_haar_measure] [borel_space G] [topological_group G] {H : Type u_2} [group H] [topological_space H] [measurable_space H] [borel_space H] [t2_space H] [topological_group H] (f : G ≃* H) (hf : continuous ⇑f) (hfsymm : continuous ⇑(f.symm)) : (measure_theory.measure.map ⇑f μ).is_haar_measure
theorem polynomial.is_primitive.irreducible_iff_irreducible_map_fraction_map {R : Type u_1} [comm_ring R] [is_domain R] [normalized_gcd_monoid R] {K : Type u_2} [field K] [algebra R K] [is_fraction_ring R K] {p : polynomial R} (hp : p.is_primitive) : irreducible p ↔ irreducible (polynomial.map (algebra_map R K) p)
theorem topological_fiber_bundle_core.continuous_total_space_mk {ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (b : B) : continuous (bundle.total_space_mk b)
theorem is_compact.finite_cover_balls {α : Type u} [pseudo_metric_space α] {s : set α} (hs : is_compact s) {e : ℝ} (he : 0 < e) : ∃ (t : set α) (H : t ⊆ s), t.finite ∧ s ⊆ ⋃ (x : α) (H : x ∈ t), metric.ball x e
theorem submodule.pow_induction_on_right {R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] (M : submodule R A) {C : A → Prop} (hr : ∀ (r : R), C (⇑(algebra_map R A) r)) (hadd : ∀ (x y : A), C x → C y → C (x + y)) (hmul : ∀ (x : A), C x → ∀ (m : A), m ∈ M → C (x * m)) {x : A} {n : ℕ} (hx : x ∈ M ^ n) : C x
theorem smooth_bump_function.smooth_smul {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {c : M} (f : smooth_bump_function I c) [t2_space M] [smooth_manifold_with_corners I M] {G : Type u_1} [normed_group G] [normed_space ℝ G] {g : M → G} (hg : smooth_on I (model_with_corners_self ℝ G) g (charted_space.chart_at H c).to_local_equiv.source) : smooth I (model_with_corners_self ℝ G) (λ (x : M), ⇑f x • g x)
theorem Top.presheaf.app_surjective_of_injective_of_locally_surjective {C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X : Top} [category_theory.concrete_category C] [category_theory.limits.preserves_filtered_colimits (category_theory.forget C)] [category_theory.limits.has_limits C] [category_theory.limits.preserves_limits (category_theory.forget C)] [category_theory.reflects_isomorphisms (category_theory.forget C)] {F G : Top.sheaf C X} (f : F ⟶ G) (U : topological_space.opens ↥X) (hinj : ∀ (x : ↥U), function.injective ⇑((Top.presheaf.stalk_functor C x.val).map f)) (hsurj : ∀ (t : ↥(G.val.obj (opposite.op U))) (x : ↥U), ∃ (V : topological_space.opens ↥X) (m : x.val ∈ V) (iVU : V ⟶ U) (s : ↥(F.val.obj (opposite.op V))), ⇑(f.app (opposite.op V)) s = ⇑(G.val.map iVU.op) t) : function.surjective ⇑(f.app (opposite.op U))
theorem free_algebra.hom_ext {R : Type u_1} [comm_semiring R] {X : Type u_2} {A : Type u_3} [semiring A] [algebra R A] {f g : free_algebra R X →ₐ[R] A} (w : ⇑f ∘ free_algebra.ι R = ⇑g ∘ free_algebra.ι R) : f = g
theorem int.exists_strict_mono (α : Type u) [preorder α] [nonempty α] [no_min_order α] [no_max_order α] : ∃ (f : ℤ → α), strict_mono f
theorem clifford_algebra.reverse_involute_commute {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Q : quadratic_form R M} : function.commute ⇑clifford_algebra.reverse ⇑clifford_algebra.involute
theorem emetric.Hausdorff_edist_image {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {s t : set α} {Φ : α → β} (h : isometry Φ) : emetric.Hausdorff_edist (Φ '' s) (Φ '' t) = emetric.Hausdorff_edist s t
theorem basis.det_is_unit_smul {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {ι : Type u_4} [decidable_eq ι] [fintype ι] (e : basis ι R M) {w : ι → R} (hw : ∀ (i : ι), is_unit (w i)) : ⇑(e.det) ⇑(e.is_unit_smul hw) = finset.univ.prod (λ (i : ι), w i)
theorem measure_theory.integral_add_left_eq_self {G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure G} [add_group G] [has_measurable_add G] [μ.is_add_left_invariant] (f : G → E) (g : G) : ∫ (x : G), f (g + x) ∂μ = ∫ (x : G), f x ∂μ
theorem formal_multilinear_series.norm_mul_pow_le_of_lt_radius {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) {r : nnreal} (h : ↑r < p.radius) : ∃ (C : ℝ) (H : C > 0), ∀ (n : ℕ), ∥p n∥ * ↑r ^ n ≤ C
theorem module.End.generalized_eigenspace_le_generalized_eigenspace_finrank {K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (f : module.End K V) (μ : K) (k : ℕ) : ⇑(f.generalized_eigenspace μ) k ≤ ⇑(f.generalized_eigenspace μ) (finite_dimensional.finrank K V)
theorem monoid_hom.map_div {α : Type u_1} {β : Type u_2} [group α] [division_monoid β] (f : α →* β) (g h : α) : ⇑f (g / h) = ⇑f g / ⇑f h
theorem monotone.map_is_least {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} (Hf : monotone f) {a : α} {s : set α} (Ha : is_least s a) : is_least (f '' s) (f a)
theorem nonempty.map {α : Sort u_1} {β : Sort u_2} (f : α → β) : nonempty α → nonempty β
theorem measure_theory.map_prod_inv_mul_eq_swap {G : Type u_1} [measurable_space G] [group G] [has_measurable_mul₂ G] (μ ν : measure_theory.measure G) [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] [has_measurable_inv G] [μ.is_mul_left_invariant] : measure_theory.measure.map (λ (z : G × G), (z.snd, (z.snd)⁻¹ * z.fst)) (μ.prod ν) = ν.prod μ
theorem category_theory.limits.has_colimits_of_shape_of_equivalence {J : Type u₁} [category_theory.category J] {C : Type u} [category_theory.category C] {J' : Type u₂} [category_theory.category J'] (e : J ≌ J') [category_theory.limits.has_colimits_of_shape J C] : category_theory.limits.has_colimits_of_shape J' C
theorem is_cyclotomic_extension.discr_prime_pow {p : ℕ+} {k : ℕ} {K : Type u} {L : Type v} {ζ : L} [field K] [field L] [algebra K L] [hcycl : is_cyclotomic_extension {p ^ k} K L] [hp : fact (nat.prime ↑p)] [ne_zero ↑↑p] (hζ : is_primitive_root ζ ↑(p ^ k)) (hirr : irreducible (polynomial.cyclotomic ↑(p ^ k) K)) : algebra.discr K ⇑((is_primitive_root.power_basis K hζ).basis) = (-1) ^ ((↑p ^ k).totient / 2) * ↑p ^ (↑p ^ (k - 1) * ((↑p - 1) * k - 1))
theorem cardinal.increasing_cantor_function {c : ℝ} (h1 : 0 < c) (h2 : c < 1 / 2) {n : ℕ} {f g : ℕ → bool} (hn : ∀ (k : ℕ), k < n → f k = g k) (fn : f n = bool.ff) (gn : g n = bool.tt) : cardinal.cantor_function c f < cardinal.cantor_function c g
theorem right_deriv_measurable_aux.D_subset_differentiable_set {F : Type u_1} [normed_group F] [normed_space ℝ F] {f : ℝ → F} {K : set F} (hK : is_complete K) : right_deriv_measurable_aux.D f K ⊆ {x : ℝ | differentiable_within_at ℝ f (set.Ici x) x ∧ deriv_within f (set.Ici x) x ∈ K}
theorem nat.of_digits_lt_base_pow_length {b : ℕ} {l : list ℕ} (hb : 2 ≤ b) (hl : ∀ (x : ℕ), x ∈ l → x < b) : nat.of_digits b l < b ^ l.length
theorem second_derivative_symmetric_of_eventually {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {x : E} {f : E → F} {f' : E → (E →L[ℝ] F)} {f'' : E →L[ℝ] E →L[ℝ] F} (hf : ∀ᶠ (y : E) in nhds x, has_fderiv_at f (f' y) y) (hx : has_fderiv_at f' f'' x) (v w : E) : ⇑(⇑f'' v) w = ⇑(⇑f'' w) v
theorem is_group_hom.mk' {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : ∀ (x y : α), f (x * y) = f x * f y) : is_group_hom f
theorem category_theory.cosimplicial_object.δ_comp_δ {C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) {n : ℕ} {i j : fin (n + 2)} (H : i ≤ j) : X.δ i ≫ X.δ j.succ = X.δ j ≫ X.δ (⇑fin.cast_succ i)
theorem map_le_line_map_iff_slope_le_slope_left {k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k → E} {a b r : k} (h : 0 < r * (b - a)) : f (⇑(affine_map.line_map a b) r) ≤ ⇑(affine_map.line_map (f a) (f b)) r ↔ slope f a (⇑(affine_map.line_map a b) r) ≤ slope f a b
theorem strict_anti_of_deriv_neg {f : ℝ → ℝ} (hf' : ∀ (x : ℝ), deriv f x < 0) : strict_anti f
theorem measure_theory.integral_prod {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] (f : α × β → E) (hf : measure_theory.integrable f (μ.prod ν)) : ∫ (z : α × β), f z ∂μ.prod ν = ∫ (x : α), ∫ (y : β), f (x, y) ∂ν ∂μ
theorem measure_theory.strongly_measurable.strongly_measurable_of_measurable_space_le_on {α : Type u_1} {E : Type u_2} {m m₂ : measurable_space α} [topological_space E] [has_zero E] {s : set α} {f : α → E} (hs_m : measurable_set s) (hs : ∀ (t : set α), measurable_set (s ∩ t) → measurable_set (s ∩ t)) (hf : measure_theory.strongly_measurable f) (hf_zero : ∀ (x : α), x ∉ s → f x = 0) : measure_theory.strongly_measurable f
theorem strict_mono_of_deriv_pos {f : ℝ → ℝ} (hf' : ∀ (x : ℝ), 0 < deriv f x) : strict_mono f
theorem submodule.pow_induction_on_left {R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] (M : submodule R A) {C : A → Prop} (hr : ∀ (r : R), C (⇑(algebra_map R A) r)) (hadd : ∀ (x y : A), C x → C y → C (x + y)) (hmul : ∀ (m : A), m ∈ M → ∀ (x : A), C x → C (m * x)) {x : A} {n : ℕ} (hx : x ∈ M ^ n) : C x
theorem finsum_mem_eq_of_bij_on {α : Type u_1} {β : Type u_2} {M : Type u_5} [add_comm_monoid M] {s : set α} {t : set β} {f : α → M} {g : β → M} (e : α → β) (he₀ : set.bij_on e s t) (he₁ : ∀ (x : α), x ∈ s → f x = g (e x)) : finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) = finsum (λ (j : β), finsum (λ (H : j ∈ t), g j))
theorem category_theory.functor.ess_image_eq_of_nat_iso {C : Type u₁} {D : Type u₂} [category_theory.category C] [category_theory.category D] {F F' : C ⥤ D} (h : F ≅ F') : F.ess_image = F'.ess_image
theorem cont_diff_within_at.comp' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {n : with_top ℕ} {s : set E} {t : set F} {g : F → G} {f : E → F} (x : E) (hg : cont_diff_within_at 𝕜 n g t (f x)) (hf : cont_diff_within_at 𝕜 n f s x) : cont_diff_within_at 𝕜 n (g ∘ f) (s ∩ f ⁻¹' t) x
theorem edist_le_of_edist_le_geometric_of_tendsto₀ {α : Type u_1} [pseudo_emetric_space α] (r C : ennreal) {f : ℕ → α} (hu : ∀ (n : ℕ), has_edist.edist (f n) (f (n + 1)) ≤ C * r ^ n) {a : α} (ha : filter.tendsto f filter.at_top (nhds a)) : has_edist.edist (f 0) a ≤ C / (1 - r)
theorem measure_theory.measure.ext_of_bUnion_eq_univ {α : Type u_1} {ι : Type u_5} {m0 : measurable_space α} {μ ν : measure_theory.measure α} {S : set ι} {s : ι → set α} (hc : S.countable) (hs : (⋃ (i : ι) (H : i ∈ S), s i) = set.univ) : (∀ (i : ι), i ∈ S → μ.restrict (s i) = ν.restrict (s i)) → μ = ν
theorem summable.map_iff_of_equiv {α : Type u_1} {β : Type u_2} {γ : Type u_3} [add_comm_monoid α] [topological_space α] {f : β → α} [add_comm_monoid γ] [topological_space γ] {G : Type u_4} [add_equiv_class G α γ] (g : G) (hg : continuous ⇑g) (hg' : continuous (add_equiv_class.inv g)) : summable (⇑g ∘ f) ↔ summable f
theorem add_semiconj_by.conj_mk {G : Type u} [add_group G] (a x : G) : add_semiconj_by a x (a + x + -a)
theorem fin.sum_univ_zero {β : Type u_2} [add_comm_monoid β] (f : fin 0 → β) : finset.univ.sum (λ (i : fin 0), f i) = 0
theorem vector_span_eq_span_vsub_set_left (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p : P} (hp : p ∈ s) : vector_span k s = submodule.span k (has_vsub.vsub p '' s)
theorem continuous_map.continuous_uncurry_of_continuous {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] [locally_compact_space β] (f : C(α, C(β, γ))) : continuous (function.uncurry (λ (x : α) (y : β), ⇑(⇑f x) y))
theorem interval_integral.measure_integral_sub_integral_sub_linear_is_o_of_tendsto_ae_left {ι : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} {c : E} {la la' : filter ℝ} {lt : filter ι} {μ : measure_theory.measure ℝ} {u v : ι → ℝ} [interval_integral.FTC_filter a la la'] [measure_theory.is_locally_finite_measure μ] (hab : interval_integrable f μ a b) (hmeas : strongly_measurable_at_filter f la' μ) (hf : filter.tendsto f (la' ⊓ μ.ae) (nhds c)) (hu : filter.tendsto u lt la) (hv : filter.tendsto v lt la) : (λ (t : ι), ∫ (x : ℝ) in v t..b, f x ∂μ - ∫ (x : ℝ) in u t..b, f x ∂μ + ∫ (x : ℝ) in u t..v t, c ∂μ) =o[lt] λ (t : ι), ∫ (x : ℝ) in u t..v t, 1 ∂μ
theorem turing.partrec_to_TM2.tr_supports (c : turing.to_partrec.code) (k : turing.partrec_to_TM2.cont') : turing.TM2.supports turing.partrec_to_TM2.tr (turing.partrec_to_TM2.code_supp c k)
theorem clifford_algebra.even_induction {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) {P : Π (x : clifford_algebra Q), x ∈ clifford_algebra.even_odd Q 0 → Prop} (hr : ∀ (r : R), P (⇑(algebra_map R (clifford_algebra Q)) r) _) (hadd : ∀ {x y : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 0} {hy : y ∈ clifford_algebra.even_odd Q 0}, P x hx → P y hy → P (x + y) _) (hιι_mul : ∀ (m₁ m₂ : M) {x : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 0}, P x hx → P (⇑(clifford_algebra.ι Q) m₁ * ⇑(clifford_algebra.ι Q) m₂ * x) _) (x : clifford_algebra Q) (hx : x ∈ clifford_algebra.even_odd Q 0) : P x hx
theorem apply_dite2 {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} (f : α → β → γ) (P : Prop) [decidable P] (a : P → α) (b : ¬P → α) (c : P → β) (d : ¬P → β) : f (dite P a b) (dite P c d) = dite P (λ (h : P), f (a h) (c h)) (λ (h : ¬P), f (b h) (d h))
theorem covby.of_dual {α : Type u_1} [has_lt α] {a b : αᵒᵈ} : b ⋖ a → ⇑order_dual.of_dual a ⋖ ⇑order_dual.of_dual b
theorem mem_nhds_iff_exists_Ioo_subset' {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {s : set α} (hl : ∃ (l : α), l < a) (hu : ∃ (u : α), a < u) : s ∈ nhds a ↔ ∃ (l u : α), a ∈ set.Ioo l u ∧ set.Ioo l u ⊆ s
theorem add_semiconj_by.add_right {S : Type u} [add_semigroup S] {a x y x' y' : S} (h : add_semiconj_by a x y) (h' : add_semiconj_by a x' y') : add_semiconj_by a (x + x') (y + y')
theorem isometry.comp {α : Type u} {β : Type v} {γ : Type w} [pseudo_emetric_space α] [pseudo_emetric_space β] [pseudo_emetric_space γ] {g : β → γ} {f : α → β} (hg : isometry g) (hf : isometry f) : isometry (g ∘ f)
theorem inf_Sup_eq_of_directed_on {α : Type u_1} [complete_lattice α] [is_compactly_generated α] {a : α} {s : set α} (h : directed_on has_le.le s) : a ⊓ has_Sup.Sup s = ⨆ (b : α) (H : b ∈ s), a ⊓ b
theorem interval_integral.continuous_on_primitive_interval' {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {a b₁ b₂ : ℝ} {μ : measure_theory.measure ℝ} {f : ℝ → E} [measure_theory.has_no_atoms μ] (h_int : interval_integrable f μ b₁ b₂) (ha : a ∈ set.interval b₁ b₂) : continuous_on (λ (b : ℝ), ∫ (x : ℝ) in a..b, f x ∂μ) (set.interval b₁ b₂)
theorem connected_component_subset_Inter_clopen {α : Type u} [topological_space α] {x : α} : connected_component x ⊆ ⋂ (Z : {Z // is_clopen Z ∧ x ∈ Z}), ↑Z
theorem rel_iso.coe_fn_injective {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} : function.injective coe_fn
theorem loc_compact_t2_tot_disc_iff_tot_sep {H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] : totally_disconnected_space H ↔ totally_separated_space H
theorem equiv.point_reflection_fixed_iff_of_injective_bit0 {G : Type u_1} {P : Type u_2} [add_group G] [add_torsor G P] {x y : P} (h : function.injective bit0) : ⇑(equiv.point_reflection x) y = y ↔ y = x
theorem orthonormal.comp_linear_isometry {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {E' : Type u_7} [inner_product_space 𝕜 E'] {v : ι → E} (hv : orthonormal 𝕜 v) (f : E →ₗᵢ[𝕜] E') : orthonormal 𝕜 (⇑f ∘ v)
theorem measure_theory.measure.restrict_apply {α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {s t : set α} (ht : measurable_set t) : ⇑(μ.restrict s) t = ⇑μ (t ∩ s)
theorem category_theory.grothendieck_topology.ext {C : Type u} [category_theory.category C] {J₁ J₂ : category_theory.grothendieck_topology C} (h : ⇑J₁ = ⇑J₂) : J₁ = J₂
theorem measure_theory.measure.ext_iff_of_Union_eq_univ {α : Type u_1} {ι : Type u_5} {m0 : measurable_space α} {μ ν : measure_theory.measure α} [encodable ι] {s : ι → set α} (hs : (⋃ (i : ι), s i) = set.univ) : μ = ν ↔ ∀ (i : ι), μ.restrict (s i) = ν.restrict (s i)
theorem is_ring_hom.to_is_semiring_hom {α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (hf : is_ring_hom f) : is_semiring_hom f
theorem has_le.le.of_dual {α : Type u_1} [has_le α] {a b : αᵒᵈ} : b ≤ a → ⇑order_dual.of_dual a ≤ ⇑order_dual.of_dual b
theorem orientation.exists_linear_isometry_equiv_eq_of_det_pos {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {f : V ≃ₗᵢ[ℝ] V} (hd : 0 < ⇑linear_map.det ↑(f.to_linear_equiv)) : ∃ (θ : real.angle), f = o.rotation θ
theorem pgame.zero_le_lf {x : pgame} : 0 ≤ x ↔ ∀ (j : x.right_moves), 0.lf (x.move_right j)
theorem inner_product_geometry.norm_sub_sq_eq_norm_sq_add_norm_sq' {V : Type u_1} [inner_product_space ℝ V] (x y : V) (h : inner_product_geometry.angle x y = real.pi / 2) : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥
theorem discrete_valuation_ring.iff_pid_with_one_nonzero_prime (R : Type u) [comm_ring R] [is_domain R] : discrete_valuation_ring R ↔ is_principal_ideal_ring R ∧ ∃! (P : ideal R), P ≠ ⊥ ∧ P.is_prime
theorem is_glb.union {γ : Type w} [semilattice_inf γ] {a₁ a₂ : γ} {s t : set γ} (hs : is_glb s a₁) (ht : is_glb t a₂) : is_glb (s ∪ t) (a₁ ⊓ a₂)
theorem has_fderiv_at.comp {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {f : E → F} {f' : E →L[𝕜] F} (x : E) {g : F → G} {g' : F →L[𝕜] G} (hg : has_fderiv_at g g' (f x)) (hf : has_fderiv_at f f' x) : has_fderiv_at (g ∘ f) (g'.comp f') x
theorem one_hom.comp_assoc {M : Type u_3} {N : Type u_4} {P : Type u_5} {Q : Type u_1} [has_one M] [has_one N] [has_one P] [has_one Q] (f : one_hom M N) (g : one_hom N P) (h : one_hom P Q) : (h.comp g).comp f = h.comp (g.comp f)
theorem category_theory.limits.is_terminal.hom_ext {C : Type u₁} [category_theory.category C] {X Y : C} (t : category_theory.limits.is_terminal X) (f g : Y ⟶ X) : f = g
theorem exists_subset_Union_closed_subset {ι : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : ι → set X} {s : set X} (hs : is_closed s) (uo : ∀ (i : ι), is_open (u i)) (uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite) (us : s ⊆ ⋃ (i : ι), u i) : ∃ (v : ι → set X), s ⊆ set.Union v ∧ (∀ (i : ι), is_closed (v i)) ∧ ∀ (i : ι), v i ⊆ u i
theorem measure_theory.measure.le_of_add_le_add_left {α : Type u_1} {m0 : measurable_space α} {μ ν₁ ν₂ : measure_theory.measure α} [measure_theory.is_finite_measure μ] (A2 : μ + ν₁ ≤ μ + ν₂) : ν₁ ≤ ν₂
theorem rat.uniform_space_eq  : is_absolute_value.uniform_space has_abs.abs = pseudo_metric_space.to_uniform_space
theorem dense.exists_countable_dense_subset_bot_top {α : Type u_1} [topological_space α] [partial_order α] {s : set α} [topological_space.separable_space ↥s] (hs : dense s) : ∃ (t : set α) (H : t ⊆ s), t.countable ∧ dense t ∧ (∀ (x : α), is_bot x → x ∈ s → x ∈ t) ∧ ∀ (x : α), is_top x → x ∈ s → x ∈ t
theorem measure_theory.simple_func.map_lintegral {α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} (g : β → ennreal) (f : measure_theory.simple_func α β) : (measure_theory.simple_func.map g f).lintegral μ = f.range.sum (λ (x : β), g x * ⇑μ (⇑f ⁻¹' {x}))
theorem has_ssubset.ssubset.subset {α : Type u} [has_subset α] [has_ssubset α] [is_nonstrict_strict_order α has_subset.subset has_ssubset.ssubset] {a b : α} (h : a ⊂ b) : a ⊆ b
theorem category_theory.limits.is_limit.hom_is_iso {J : Type u₁} [category_theory.category J] {C : Type u₃} [category_theory.category C] {F : J ⥤ C} {s t : category_theory.limits.cone F} (P : category_theory.limits.is_limit s) (Q : category_theory.limits.is_limit t) (f : s ⟶ t) : category_theory.is_iso f
theorem convex_on_pow (n : ℕ) : convex_on ℝ (set.Ici 0) (λ (x : ℝ), x ^ n)
theorem continuous_linear_map.unit_le_op_norm {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [ring_hom_isometric σ₁₂] (f : E →SL[σ₁₂] F) (x : E) : ∥x∥ ≤ 1 → ∥⇑f x∥ ≤ ∥f∥
theorem open_map_of_strict_fderiv_equiv {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] [complete_space E] {f : E → F} {f' : E → (E ≃L[𝕜] F)} (hf : ∀ (x : E), has_strict_fderiv_at f ↑(f' x) x) : is_open_map f
theorem category_theory.limits.pullback_cone.equalizer_ext {C : Type u} [category_theory.category C] {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} (t : category_theory.limits.pullback_cone f g) {W : C} {k l : W ⟶ t.X} (h₀ : k ≫ t.fst = l ≫ t.fst) (h₁ : k ≫ t.snd = l ≫ t.snd) (j : category_theory.limits.walking_cospan) : k ≫ t.π.app j = l ≫ t.π.app j
theorem category_theory.InjectiveResolution.desc_commutes {C : Type u} [category_theory.category C] [category_theory.abelian C] {Y Z : C} (f : Z ⟶ Y) (I : category_theory.InjectiveResolution Y) (J : category_theory.InjectiveResolution Z) : J.ι ≫ category_theory.InjectiveResolution.desc f I J = (cochain_complex.single₀ C).map f ≫ I.ι
theorem euclidean_geometry.exists_circumradius_eq_of_cospherical {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {ps : set P} {n : ℕ} [finite_dimensional ℝ V] (hd : finite_dimensional.finrank ℝ V = n) (hc : euclidean_geometry.cospherical ps) : ∃ (r : ℝ), ∀ (sx : affine.simplex ℝ P n), set.range sx.points ⊆ ps → sx.circumradius = r
theorem minpoly.aeval_ne_zero_of_dvd_not_unit_minpoly {A : Type u_1} {B : Type u_2} [comm_ring A] [is_domain A] [ring B] [algebra A B] {x : B} {a : polynomial A} (hx : is_integral A x) (hamonic : a.monic) (hdvd : dvd_not_unit a (minpoly A x)) : ⇑(polynomial.aeval x) a ≠ 0
theorem clifford_algebra.induction {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Q : quadratic_form R M} {C : clifford_algebra Q → Prop} (h_grade0 : ∀ (r : R), C (⇑(algebra_map R (clifford_algebra Q)) r)) (h_grade1 : ∀ (x : M), C (⇑(clifford_algebra.ι Q) x)) (h_mul : ∀ (a b : clifford_algebra Q), C a → C b → C (a * b)) (h_add : ∀ (a b : clifford_algebra Q), C a → C b → C (a + b)) (a : clifford_algebra Q) : C a
theorem nat_ordinal.induction {p : nat_ordinal → Prop} (i : nat_ordinal) (h : ∀ (j : nat_ordinal), (∀ (k : nat_ordinal), k < j → p k) → p j) : p i
theorem orientation.two_zsmul_oangle_smul_right_of_ne_zero {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x y : V) {r : ℝ} (hr : r ≠ 0) : 2 • o.oangle x (r • y) = 2 • o.oangle x y
theorem metric.bounded_singleton {α : Type u} [pseudo_metric_space α] {x : α} : metric.bounded {x}
theorem finprod_mem_union'' {α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M} {s t : set α} (hst : disjoint (s ∩ function.mul_support f) (t ∩ function.mul_support f)) (hs : (s ∩ function.mul_support f).finite) (ht : (t ∩ function.mul_support f).finite) : finprod (λ (i : α), finprod (λ (H : i ∈ s ∪ t), f i)) = finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ t), f i))
theorem sq_add_sq_mul_sq_add_sq {R : Type u_1} [comm_ring R] {x₁ x₂ y₁ y₂ : R} : (x₁ ^ 2 + x₂ ^ 2) * (y₁ ^ 2 + y₂ ^ 2) = (x₁ * y₁ - x₂ * y₂) ^ 2 + (x₁ * y₂ + x₂ * y₁) ^ 2
theorem lipschitz_with.of_le_add_mul' {α : Type u} [pseudo_metric_space α] {f : α → ℝ} (K : ℝ) (h : ∀ (x y : α), f x ≤ f y + K * has_dist.dist x y) : lipschitz_with K.to_nnreal f
theorem measure_theory.lintegral_infi_ae {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : ℕ → α → ennreal} (h_meas : ∀ (n : ℕ), measurable (f n)) (h_mono : ∀ (n : ℕ), f n.succ ≤ᵐ[μ] f n) (h_fin : ∫⁻ (a : α), f 0 a ∂μ ≠ ⊤) : ∫⁻ (a : α), (⨅ (n : ℕ), f n a) ∂μ = ⨅ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
theorem metric.tendsto_uniformly_on_iff {α : Type u} {β : Type v} [pseudo_metric_space α] {ι : Type u_1} {F : ι → β → α} {f : β → α} {p : filter ι} {s : set β} : tendsto_uniformly_on F f p s ↔ ∀ (ε : ℝ), ε > 0 → (∀ᶠ (n : ι) in p, ∀ (x : β), x ∈ s → has_dist.dist (f x) (F n x) < ε)
theorem lipschitz_with.hausdorff_measure_image_le {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [measurable_space X] [borel_space X] [measurable_space Y] [borel_space Y] {K : nnreal} {f : X → Y} (h : lipschitz_with K f) {d : ℝ} (hd : 0 ≤ d) (s : set X) : ⇑(measure_theory.measure.hausdorff_measure d) (f '' s) ≤ ↑K ^ d * ⇑(measure_theory.measure.hausdorff_measure d) s
theorem nat.filter_multiset_Ico_card_eq_of_periodic (n a : ℕ) (p : ℕ → Prop) [decidable_pred p] (pp : function.periodic p a) : ⇑multiset.card (multiset.filter p (multiset.Ico n (n + a))) = nat.count p a
theorem comp_mul_right {α : Type u_1} [semigroup α] (x y : α) : ((λ (_x : α), _x * x) ∘ λ (_x : α), _x * y) = λ (_x : α), _x * (y * x)
theorem category_theory.cover_dense.sheaf_hom_restrict_eq {C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {A : Type u_7} [category_theory.category A] {G : C ⥤ D} (H : category_theory.cover_dense K G) [category_theory.full G] {ℱ : Dᵒᵖ ⥤ A} {ℱ' : category_theory.Sheaf K A} (α : G.op ⋙ ℱ ⟶ G.op ⋙ ℱ'.val) : category_theory.whisker_left G.op (H.sheaf_hom α) = α
theorem nilpotent_of_surjective {G : Type u_1} [group G] {G' : Type u_2} [group G'] [h : group.is_nilpotent G] (f : G →* G') (hf : function.surjective ⇑f) : group.is_nilpotent G'
theorem affine_isometry_equiv.vadd_vsub {𝕜 : Type u_1} {V : Type u_2} {V₂ : Type u_4} {P : Type u_8} {P₂ : Type u_9} [normed_field 𝕜] [semi_normed_group V] [semi_normed_group V₂] [normed_space 𝕜 V] [normed_space 𝕜 V₂] [pseudo_metric_space P] [pseudo_metric_space P₂] [normed_add_torsor V P] [normed_add_torsor V₂ P₂] {f : P → P₂} (hf : isometry f) {p : P} {g : V → V₂} (hg : ∀ (v : V), g v = f (v +ᵥ p) -ᵥ f p) : isometry g
theorem finset.prod_le_one {ι : Type u_1} {R : Type u_8} [ordered_comm_semiring R] {f : ι → R} {s : finset ι} (h0 : ∀ (i : ι), i ∈ s → 0 ≤ f i) (h1 : ∀ (i : ι), i ∈ s → f i ≤ 1) : s.prod (λ (i : ι), f i) ≤ 1
theorem mem_extreme_points_iff_extreme_singleton {𝕜 : Type u_1} {E : Type u_2} [ordered_semiring 𝕜] [add_comm_monoid E] [has_scalar 𝕜 E] {A : set E} {x : E} : x ∈ set.extreme_points 𝕜 A ↔ is_extreme 𝕜 A {x}
theorem orthonormal.oangle_rotation_oangle_right {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x y : V) : hb.oangle y (⇑(hb.rotation (hb.oangle x y)) x) = 0
theorem measure_theory.mul_meas_ge_le_lintegral {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : α → ennreal} (hf : measurable f) (ε : ennreal) : ε * ⇑μ {x : α | ε ≤ f x} ≤ ∫⁻ (a : α), f a ∂μ
theorem bounded_continuous_function.exists_extension_forall_mem_Icc_of_closed_embedding {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] (f : bounded_continuous_function X ℝ) {a b : ℝ} {e : X → Y} (hf : ∀ (x : X), ⇑f x ∈ set.Icc a b) (hle : a ≤ b) (he : closed_embedding e) : ∃ (g : bounded_continuous_function Y ℝ), (∀ (y : Y), ⇑g y ∈ set.Icc a b) ∧ ⇑g ∘ e = ⇑f
theorem is_localization.smul_mem_finset_integer_multiple_span {R S : Type u} [comm_ring R] [comm_ring S] (M : submonoid R) (S' : Type u) [comm_ring S'] [algebra S S'] [algebra R S] [algebra R S'] [is_scalar_tower R S S'] [is_localization (submonoid.map ↑(algebra_map R S) M) S'] (x : S) (s : finset S') (hx : ⇑(algebra_map S S') x ∈ submodule.span R ↑s) : ∃ (m : ↥M), m • x ∈ submodule.span R ↑(is_localization.finset_integer_multiple (submonoid.map ↑(algebra_map R S) M) s)
theorem unique_diff_on.univ_pi {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] (ι : Type u_2) [fintype ι] (E : ι → Type u_3) [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] (s : Π (i : ι), set (E i)) (h : ∀ (i : ι), unique_diff_on 𝕜 (s i)) : unique_diff_on 𝕜 (set.univ.pi s)
theorem complex.has_deriv_at_exp (x : ℂ) : has_deriv_at complex.exp (complex.exp x) x
theorem category_theory.functor.obj_mem_ess_image {C : Type u₁} {D : Type u₂} [category_theory.category C] [category_theory.category D] (F : D ⥤ C) (Y : D) : F.obj Y ∈ F.ess_image
theorem orthonormal.oangle_zero_right {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x : V) : hb.oangle x 0 = 0
theorem sylow.card_coprime_index {G : Type u} [group G] [fintype G] {p : ℕ} [hp : fact (nat.prime p)] (P : sylow p G) : (fintype.card ↥P).coprime ↑P.index
theorem add_con.Sup_def {M : Type u_1} [has_add M] {S : set (add_con M)} : has_Sup.Sup S = add_con_gen (has_Sup.Sup (coe_fn '' S))
theorem finite_dimensional.finrank_zero_of_subsingleton {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [h : subsingleton V] : finite_dimensional.finrank K V = 0
theorem Top.presheaf.to_Types_is_sheaf (X : Top) (T : ↥X → Type u) : (X.presheaf_to_Types T).is_sheaf
theorem ring_hom.map_bit0 {α : Type u_2} {β : Type u_3} {rα : non_assoc_semiring α} {rβ : non_assoc_semiring β} (f : α →+* β) (a : α) : ⇑f (bit0 a) = bit0 (⇑f a)
theorem topological_space.second_countable_topology_of_countable_cover {α : Type u} [t : topological_space α] {ι : Type u_1} [encodable ι] {U : ι → set α} [∀ (i : ι), topological_space.second_countable_topology ↥(U i)] (Uo : ∀ (i : ι), is_open (U i)) (hc : (⋃ (i : ι), U i) = set.univ) : topological_space.second_countable_topology α
theorem is_cyclotomic_extension.finite (S : set ℕ+) (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] [is_domain B] [h₁ : fintype ↥S] [h₂ : is_cyclotomic_extension S A B] : module.finite A B
theorem nat.partrec.code.evaln_prim  : primrec (λ (a : (ℕ × nat.partrec.code) × ℕ), nat.partrec.code.evaln a.fst.fst a.fst.snd a.snd)
theorem measure_theory.conservative.ae_forall_image_mem_imp_frequently_image_mem {α : Type u_2} [measurable_space α] {f : α → α} {s : set α} {μ : measure_theory.measure α} (hf : measure_theory.conservative f μ) (hs : measurable_set s) : ∀ᵐ (x : α) ∂μ, ∀ (k : ℕ), f^[k] x ∈ s → (∃ᶠ (n : ℕ) in filter.at_top, f^[n] x ∈ s)
theorem emetric.complete_of_convergent_controlled_sequences {α : Type u} [pseudo_emetric_space α] (B : ℕ → ennreal) (hB : ∀ (n : ℕ), 0 < B n) (H : ∀ (u : ℕ → α), (∀ (N n m : ℕ), N ≤ n → N ≤ m → has_edist.edist (u n) (u m) < B N) → (∃ (x : α), filter.tendsto u filter.at_top (nhds x))) : complete_space α
theorem local_homeomorph.trans_self_symm {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) : e.trans e.symm ≈ local_homeomorph.of_set e.to_local_equiv.source _
theorem matrix.special_linear_group.coe_GL_pos_coe_GL_coe_matrix {n : Type u} [decidable_eq n] [fintype n] {R : Type v} [linear_ordered_comm_ring R] (g : matrix.special_linear_group n R) : ↑↑↑g = ↑g
theorem topological_vector_bundle.prod.inducing_diag {B : Type u_3} (E₁ : B → Type u_6) (E₂ : B → Type u_7) [topological_space (bundle.total_space E₁)] [topological_space (bundle.total_space E₂)] : inducing (λ (p : bundle.total_space (λ (x : B), E₁ x × E₂ x)), (⟨p.fst, p.snd.fst⟩, ⟨p.fst, p.snd.snd⟩))
theorem nat.totient_mul_prod_factors (n : ℕ) : n.totient * n.factors.to_finset.prod (λ (p : ℕ), p) = n * n.factors.to_finset.prod (λ (p : ℕ), p - 1)
theorem is_closed.is_glb_mem {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {s : set α} (ha : is_glb s a) (hs : s.nonempty) (sc : is_closed s) : a ∈ s
theorem algebraic_topology.dold_kan.map_hσ' {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] {D : Type u_3} [category_theory.category D] [category_theory.preadditive D] (G : C ⥤ D) [G.additive] (X : category_theory.simplicial_object C) (q n m : ℕ) (hnm : algebraic_topology.dold_kan.c.rel m n) : algebraic_topology.dold_kan.hσ' q n m hnm = G.map (algebraic_topology.dold_kan.hσ' q n m hnm)
theorem add_semiconj_by.reflexive {M : Type u} [add_zero_class M] : reflexive (λ (a b : M), ∃ (c : M), add_semiconj_by c a b)
theorem right.add_pos' {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
theorem category_theory.simplicial_object.σ_comp_σ {C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) {n : ℕ} {i j : fin (n + 1)} (H : i ≤ j) : X.σ j ≫ X.σ (⇑fin.cast_succ i) = X.σ i ≫ X.σ j.succ
theorem ordinal.exists_fundamental_sequence (a : ordinal) : ∃ (f : Π (b : ordinal), b < a.cof.ord → ordinal), a.is_fundamental_sequence a.cof.ord f
theorem tendsto_locally_uniformly_on.tendsto_comp {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {s : set α} {x : α} {p : filter ι} {g : ι → α} [topological_space α] (h : tendsto_locally_uniformly_on F f p s) (hf : continuous_within_at f s x) (hx : x ∈ s) (hg : filter.tendsto g p (nhds_within x s)) : filter.tendsto (λ (n : ι), F n (g n)) p (nhds (f x))
theorem finsum_add_distrib {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f g : α → M} (hf : (function.support f).finite) (hg : (function.support g).finite) : finsum (λ (i : α), f i + g i) = finsum (λ (i : α), f i) + finsum (λ (i : α), g i)
theorem is_o_zpow_exp_pos_mul_at_top (k : ℤ) {b : ℝ} (hb : 0 < b) : (λ (x : ℝ), x ^ k) =o[filter.at_top] λ (x : ℝ), real.exp (b * x)
theorem list.pairwise.pw_filter {α : Type u_1} {R : α → α → Prop} [decidable_rel R] {l : list α} : list.pairwise R l → list.pw_filter R l = l
theorem list.comp_map {α : Type u} {β : Type v} {γ : Type w} (h : β → γ) (g : α → β) (l : list α) : list.map (h ∘ g) l = list.map h (list.map g l)
theorem add_con.sup_eq_add_con_gen {M : Type u_1} [has_add M] (c d : add_con M) : c ⊔ d = add_con_gen (λ (x y : M), ⇑c x y ∨ ⇑d x y)
theorem category_theory.sheaf.sheaf_for_finest_topology {C : Type u} [category_theory.category C] {P : Cᵒᵖ ⥤ Type v} (Ps : set (Cᵒᵖ ⥤ Type v)) (h : P ∈ Ps) : category_theory.presieve.is_sheaf (category_theory.sheaf.finest_topology Ps) P
theorem exp_neg_inv_glue.zero_of_nonpos {x : ℝ} (hx : x ≤ 0) : exp_neg_inv_glue x = 0
theorem category_theory.limits.has_products_opposite {C : Type u₁} [category_theory.category C] (X : Type v₁) [category_theory.limits.has_coproducts_of_shape X C] : category_theory.limits.has_products_of_shape X Cᵒᵖ
theorem tsum_mul_tsum_eq_tsum_sum_range {α : Type u_1} {f g : ℕ → α} [topological_space α] [non_unital_non_assoc_semiring α] [regular_space α] [topological_semiring α] (hf : summable f) (hg : summable g) (hfg : summable (λ (x : ℕ × ℕ), f x.fst * g x.snd)) : (∑' (n : ℕ), f n) * ∑' (n : ℕ), g n = ∑' (n : ℕ), (finset.range (n + 1)).sum (λ (k : ℕ), f k * g (n - k))
theorem cont_diff_top_iff_deriv {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f₂ : 𝕜 → F} : cont_diff 𝕜 ⊤ f₂ ↔ differentiable 𝕜 f₂ ∧ cont_diff 𝕜 ⊤ (deriv f₂)
theorem subgroup.fg_of_index_ne_zero {G : Type u_1} [group G] {H : subgroup G} [hG : group.fg G] (hH : H.index ≠ 0) : group.fg ↥H
theorem closed_ball_pi {β : Type v} {π : β → Type u_1} [fintype β] [Π (b : β), pseudo_metric_space (π b)] (x : Π (b : β), π b) {r : ℝ} (hr : 0 ≤ r) : metric.closed_ball x r = set.univ.pi (λ (b : β), metric.closed_ball (x b) r)
theorem real.tendsto_prod_pi_div_two  : filter.tendsto (λ (k : ℕ), (finset.range k).prod (λ (i : ℕ), (2 * ↑i + 2) / (2 * ↑i + 1) * ((2 * ↑i + 2) / (2 * ↑i + 3)))) filter.at_top (nhds (real.pi / 2))
theorem cont_diff.comp_continuous_linear_map {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {n : with_top ℕ} {f : E → F} {g : G →L[𝕜] E} (hf : cont_diff 𝕜 n f) : cont_diff 𝕜 n (f ∘ ⇑g)
theorem metric.cthickening_zero {α : Type u} [pseudo_emetric_space α] (E : set α) : metric.cthickening 0 E = closure E
theorem ordinal.enum_ord_def' {S : set ordinal} (o : ordinal) : ordinal.enum_ord S o = has_Inf.Inf (S ∩ set.Ici (o.blsub (λ (a : ordinal) (_x : a < o), ordinal.enum_ord S a)))
theorem quadratic_form.equivalent_one_zero_neg_one_weighted_sum_squared {M : Type u_1} [add_comm_group M] [module ℝ M] [finite_dimensional ℝ M] (Q : quadratic_form ℝ M) : ∃ (w : fin (finite_dimensional.finrank ℝ M) → ℝ), (∀ (i : fin (finite_dimensional.finrank ℝ M)), w i = -1 ∨ w i = 0 ∨ w i = 1) ∧ Q.equivalent (quadratic_form.weighted_sum_squares ℝ w)
theorem measure_theory.outer_measure.Inf_apply' {α : Type u_1} {m : set (measure_theory.outer_measure α)} {s : set α} (h : s.nonempty) : ⇑(has_Inf.Inf m) s = ⨅ (t : ℕ → set α) (h2 : s ⊆ set.Union t), ∑' (n : ℕ), ⨅ (μ : measure_theory.outer_measure α) (h3 : μ ∈ m), ⇑μ (t n)
theorem real.subgroup_dense_of_no_min {G : add_subgroup ℝ} {g₀ : ℝ} (g₀_in : g₀ ∈ G) (g₀_ne : g₀ ≠ 0) (H' : ¬∃ (a : ℝ), is_least {g : ℝ | g ∈ G ∧ 0 < g} a) : dense ↑G
theorem ring.ne_bot_of_is_maximal_of_not_is_field {R : Type u_1} [comm_ring R] [nontrivial R] {M : ideal R} (max : M.is_maximal) (not_field : ¬is_field R) : M ≠ ⊥
theorem multilinear_map.dom_coprod_alternization_eq {ιa : Type u_7} {ιb : Type u_8} [decidable_eq ιa] [decidable_eq ιb] [fintype ιa] [fintype ιb] {R' : Type u_9} {Mᵢ : Type u_10} {N₁ : Type u_11} {N₂ : Type u_12} [comm_semiring R'] [add_comm_group N₁] [module R' N₁] [add_comm_group N₂] [module R' N₂] [add_comm_monoid Mᵢ] [module R' Mᵢ] (a : alternating_map R' Mᵢ N₁ ιa) (b : alternating_map R' Mᵢ N₂ ιb) : ⇑multilinear_map.alternatization (↑a.dom_coprod ↑b) = ((fintype.card ιa).factorial * (fintype.card ιb).factorial) • a.dom_coprod b
theorem category_theory.limits.biproduct.ι_π {J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [decidable_eq J] (f : J → C) [category_theory.limits.has_biproduct f] (j j' : J) : category_theory.limits.biproduct.ι f j ≫ category_theory.limits.biproduct.π f j' = dite (j = j') (λ (h : j = j'), category_theory.eq_to_hom _) (λ (h : ¬j = j'), 0)
theorem polynomial.chebyshev.cos_nat_mul (n : ℕ) (θ : ℂ) : complex.cos (↑n * θ) = polynomial.eval (complex.cos θ) (polynomial.chebyshev.T ℂ n)
theorem orientation.oangle_add_oangle_rev_neg_left {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x y : V) : o.oangle (-x) y + o.oangle (-y) x = 0
theorem complex.abs_le_abs_of_maps_to_ball_self {f : ℂ → ℂ} {z : ℂ} {R : ℝ} (hd : differentiable_on ℂ f (metric.ball 0 R)) (h_maps : set.maps_to f (metric.ball 0 R) (metric.ball 0 R)) (h₀ : f 0 = 0) (hz : complex.abs z < R) : complex.abs (f z) ≤ complex.abs z
theorem monoid_hom.ext_int {M : Type u_1} [monoid M] {f g : ℤ →* M} (h_neg_one : ⇑f (-1) = ⇑g (-1)) (h_nat : f.comp int.of_nat_hom.to_monoid_hom = g.comp int.of_nat_hom.to_monoid_hom) : f = g
theorem cardinal.lift_sup_le_lift_sup' {ι : Type v} {ι' : Type v'} (f : ι → cardinal) (f' : ι' → cardinal) (g : ι → ι') (h : ∀ (i : ι), (f i).lift ≤ (f' (g i)).lift) : (cardinal.sup f).lift ≤ (cardinal.sup f').lift
theorem units.mul_right_dvd {α : Type u_1} [monoid α] {a b : α} {u : αˣ} : a * ↑u ∣ b ↔ a ∣ b
theorem finprod_mem_comm {α : Type u_1} {β : Type u_2} {M : Type u_5} [comm_monoid M] {s : set α} {t : set β} (f : α → β → M) (hs : s.finite) (ht : t.finite) : finprod (λ (i : α), finprod (λ (H : i ∈ s), finprod (λ (j : β), finprod (λ (H : j ∈ t), f i j)))) = finprod (λ (j : β), finprod (λ (H : j ∈ t), finprod (λ (i : α), finprod (λ (H : i ∈ s), f i j))))
theorem pgame.lf.trans_le {x y z : pgame} (h₁ : x.lf y) (h₂ : y ≤ z) : x.lf z
theorem add_con.Inf_def {M : Type u_1} [has_add M] (S : set (add_con M)) : ⇑(has_Inf.Inf S) = has_Inf.Inf (coe_fn '' S)
theorem first_order.language.nonempty_of_nonempty_constants {L : first_order.language} {M : Type w} [L.Structure M] [h : nonempty L.constants] : nonempty M
theorem torus_integral_dim1 {E : Type u_1} [normed_group E] [normed_space ℂ E] [complete_space E] (f : (fin 1 → ℂ) → E) (c : fin 1 → ℂ) (R : fin 1 → ℝ) : ∯ (x : fin 1 → ℂ) in T(c, R), f x = ∮ (z : ℂ) in C(c 0, R 0), f (λ (_x : fin 1), z)
theorem measure_theory.outer_measure.trim_smul {α : Type u_1} [measurable_space α] {R : Type u_2} [has_scalar R ennreal] [is_scalar_tower R ennreal ennreal] (c : R) (m : measure_theory.outer_measure α) : (c • m).trim = c • m.trim
theorem polynomial.exists_eq_polynomial {Fq : Type u_1} [fintype Fq] [semiring Fq] {d m : ℕ} (hm : fintype.card Fq ^ d ≤ m) (b : polynomial Fq) (hb : b.nat_degree ≤ d) (A : fin m.succ → polynomial Fq) (hA : ∀ (i : fin m.succ), (A i).degree < b.degree) : ∃ (i₀ i₁ : fin m.succ), i₀ ≠ i₁ ∧ A i₁ = A i₀
theorem abs_real_inner_div_norm_mul_norm_le_one {F : Type u_3} [inner_product_space ℝ F] (x y : F) : |has_inner.inner x y / (∥x∥ * ∥y∥)| ≤ 1
theorem continuous.ext_on {α : Type u} {β : Type v} [topological_space α] [topological_space β] [t2_space α] {s : set β} (hs : dense s) {f g : β → α} (hf : continuous f) (hg : continuous g) (h : set.eq_on f g s) : f = g
theorem cardinal.add_eq_self {c : cardinal} (h : cardinal.aleph_0 ≤ c) : c + c = c
theorem category_theory.exact_inl_snd {𝒜 : Type u_1} [category_theory.category 𝒜] [category_theory.preadditive 𝒜] [category_theory.limits.has_kernels 𝒜] [category_theory.limits.has_images 𝒜] [category_theory.limits.has_binary_biproducts 𝒜] (A B : 𝒜) : category_theory.exact category_theory.limits.biprod.inl category_theory.limits.biprod.snd
theorem continuous.interval_integrable {E : Type u_3} [normed_group E] {μ : measure_theory.measure ℝ} [measure_theory.is_locally_finite_measure μ] {u : ℝ → E} (hu : continuous u) (a b : ℝ) : interval_integrable u μ a b
theorem finset.up_shadow_monotone {α : Type u_1} [decidable_eq α] [fintype α] : monotone finset.up_shadow
theorem neg_one_mul {α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : (-1) * a = -a
theorem finset.map_affine_combination {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) {V₂ : Type u_5} {P₂ : Type u_6} [add_comm_group V₂] [module k V₂] [add_torsor V₂ P₂] (p : ι → P) (w : ι → k) (hw : s.sum w = 1) (f : P →ᵃ[k] P₂) : ⇑f (⇑(s.affine_combination p) w) = ⇑(s.affine_combination (⇑f ∘ p)) w
theorem bdd_above.convolution_exists_at' {𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G → E} {g : G → E'} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 F] (L : E →L[𝕜] E' →L[𝕜] F) [measurable_space G] {μ : measure_theory.measure G} [add_group G] [has_measurable_add₂ G] [has_measurable_neg G] {x₀ : G} {s : set G} (hbg : bdd_above ((λ (i : G), ∥g i∥) '' ((λ (t : G), -t + x₀) ⁻¹' s))) (hs : measurable_set s) (h2s : function.support (λ (t : G), ⇑(⇑L (f t)) (g (x₀ - t))) ⊆ s) (hf : measure_theory.integrable_on f s μ) (hmf : measure_theory.ae_strongly_measurable f μ) (hmg : measure_theory.ae_strongly_measurable g (measure_theory.measure.map (λ (t : G), x₀ - t) μ)) : convolution_exists_at f g x₀ L μ
theorem module.free.finrank_prod (R : Type u) (M : Type v) (N : Type w) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] [add_comm_group N] [module R N] [module.free R N] [module.finite R N] : finite_dimensional.finrank R (M × N) = finite_dimensional.finrank R M + finite_dimensional.finrank R N
theorem is_fraction_ring.is_algebraic_iff' (R : Type u_1) [comm_ring R] (S : Type u_2) [comm_ring S] [algebra R S] (K : Type u_5) [field K] [is_domain R] [is_domain S] [algebra R K] [algebra S K] [no_zero_smul_divisors R K] [is_fraction_ring S K] [is_scalar_tower R S K] : algebra.is_algebraic R S ↔ algebra.is_algebraic R K
theorem measure_theory.restrict_map_with_density_abs_det_fderiv_eq_add_haar {E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {s : set E} {f : E → E} {f' : E → (E →L[ℝ] E)} [measurable_space E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (hs : measurable_set s) (hf' : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) : measure_theory.measure.map (s.restrict f) (⇑(measure_theory.measure.comap coe) (μ.with_density (λ (x : E), ennreal.of_real |(f' x).det|))) = μ.restrict (f '' s)
theorem zero_dvd_iff {α : Type u_1} [semigroup_with_zero α] {a : α} : 0 ∣ a ↔ a = 0
theorem finset.card_Icc_finset {α : Type u_1} [decidable_eq α] {s t : finset α} (h : s ⊆ t) : (finset.Icc s t).card = 2 ^ (t.card - s.card)
theorem measure_theory.strongly_measurable.is_separable_range {α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] (hf : measure_theory.strongly_measurable f) : topological_space.is_separable (set.range f)
theorem zmod.gauss_lemma (p : ℕ) [fact (nat.prime p)] {a : ℤ} (hp : p ≠ 2) (ha0 : ↑a ≠ 0) : zmod.legendre_sym p a = (-1) ^ (finset.filter (λ (x : ℕ), p / 2 < (↑a * ↑x).val) (finset.Ico 1 (p / 2).succ)).card
theorem nat.prime.multiplicity_factorial_mul {n p : ℕ} (hp : nat.prime p) : multiplicity p (p * n).factorial = multiplicity p n.factorial + ↑n
theorem linear_map.det_cases {M : Type u_2} [add_comm_group M] {A : Type u_5} [comm_ring A] [module A M] [decidable_eq M] {P : A → Prop} (f : M →ₗ[A] M) (hb : ∀ (s : finset M) (b : basis ↥s A M), P (⇑(linear_map.to_matrix b b) f).det) (h1 : P 1) : P (⇑linear_map.det f)
theorem measure_theory.mem_ℒp.snorm_indicator_le_of_meas {α : Type u_1} {β : Type u_2} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} {f : α → β} (hp_one : 1 ≤ p) (hp_top : p ≠ ⊤) (hf : measure_theory.mem_ℒp f p μ) (hmeas : measure_theory.strongly_measurable f) {ε : ℝ} (hε : 0 < ε) : ∃ (δ : ℝ) (hδ : 0 < δ), ∀ (s : set α), measurable_set s → ⇑μ s ≤ ennreal.of_real δ → measure_theory.snorm (s.indicator f) p μ ≤ ennreal.of_real ε
theorem equiv.perm.cycle_is_cycle_of {α : Type u_1} [decidable_eq α] [fintype α] {f c : equiv.perm α} {a : α} (ha : a ∈ c.support) (hc : c ∈ f.cycle_factors_finset) : c = f.cycle_of a
theorem measurable_set_of_mem_nhds_within_Ioi {α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] [linear_order α] [order_topology α] [topological_space.second_countable_topology α] {s : set α} (h : ∀ (x : α), x ∈ s → s ∈ nhds_within x (set.Ioi x)) : measurable_set s
theorem euclidean_geometry.mul_dist_eq_mul_dist_of_cospherical_of_angle_eq_pi {V : Type u_1} [inner_product_space ℝ V] {P : Type u_2} [metric_space P] [normed_add_torsor V P] {a b c d p : P} (h : euclidean_geometry.cospherical {a, b, c, d}) (hapb : euclidean_geometry.angle a p b = real.pi) (hcpd : euclidean_geometry.angle c p d = real.pi) : has_dist.dist a p * has_dist.dist b p = has_dist.dist c p * has_dist.dist d p
theorem witt_vector.is_poly₂.comp {p : ℕ} {h : Π ⦃R : Type u_1⦄ [_inst_3 : comm_ring R], witt_vector p R → witt_vector p R → witt_vector p R} {f g : Π ⦃R : Type u_1⦄ [_inst_3 : comm_ring R], witt_vector p R → witt_vector p R} (hh : witt_vector.is_poly₂ p h) (hf : witt_vector.is_poly p f) (hg : witt_vector.is_poly p g) : witt_vector.is_poly₂ p (λ (R : Type u_1) (_Rcr : comm_ring R) (x y : witt_vector p R), h (f x) (g y))
theorem strict_mono_on.dual_right {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s : set α} : strict_mono_on f s → strict_anti_on (⇑order_dual.to_dual ∘ f) s
theorem lt_add_of_neg_add_lt_left {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : -b + a < c → a < b + c
theorem not_interval_integrable_of_tendsto_norm_at_top_of_deriv_is_O_punctured {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [topological_space.second_countable_topology E] [complete_space E] [normed_group F] {f : ℝ → E} {g : ℝ → F} {a b c : ℝ} (h_deriv : ∀ᶠ (x : ℝ) in nhds_within c {c}ᶜ, differentiable_at ℝ f x) (h_infty : filter.tendsto (λ (x : ℝ), ∥f x∥) (nhds_within c {c}ᶜ) filter.at_top) (hg : deriv f =O[nhds_within c {c}ᶜ] g) (hne : a ≠ b) (hc : c ∈ set.interval a b) : ¬interval_integrable g measure_theory.measure_space.volume a b
theorem zero_lt.right.mul_nonneg {α : Type u} {a b : α} [mul_zero_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a * b
theorem finset.map_subtype_subset {α : Type u_1} {t : set α} (s : finset ↥t) : ↑(finset.map (function.embedding.subtype (λ (x : α), x ∈ t)) s) ⊆ t
theorem add_con.lift_apply_mk' {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} (f : c.quotient →+ P) : c.lift (f.comp c.mk') _ = f
theorem finset.exists_le_card_fiber_of_nsmul_le_card_of_maps_to {α : Type u} {β : Type v} {M : Type w} [decidable_eq β] {s : finset α} {t : finset β} {f : α → β} {b : M} [linear_ordered_comm_ring M] (hf : ∀ (a : α), a ∈ s → f a ∈ t) (ht : t.nonempty) (hb : t.card • b ≤ ↑(s.card)) : ∃ (y : β) (H : y ∈ t), b ≤ ↑((finset.filter (λ (x : α), f x = y) s).card)
theorem measure_theory.tendsto_in_measure_of_tendsto_snorm_of_ne_top {α : Type u_1} {ι : Type u_2} {E : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [normed_group E] {p : ennreal} {f : ι → α → E} {g : α → E} (hp_ne_zero : p ≠ 0) (hp_ne_top : p ≠ ⊤) (hf : ∀ (n : ι), measure_theory.ae_strongly_measurable (f n) μ) (hg : measure_theory.ae_strongly_measurable g μ) {l : filter ι} (hfg : filter.tendsto (λ (n : ι), measure_theory.snorm (f n - g) p μ) l (nhds 0)) : measure_theory.tendsto_in_measure μ f l g
theorem measure_theory.signed_measure.absolutely_continuous_iff_with_densityᵥ_rn_deriv_eq {α : Type u_1} {m : measurable_space α} (s : measure_theory.signed_measure α) (μ : measure_theory.measure α) [measure_theory.sigma_finite μ] : measure_theory.vector_measure.absolutely_continuous s μ.to_ennreal_vector_measure ↔ μ.with_densityᵥ (s.rn_deriv μ) = s
theorem orientation.fin_orthonormal_basis_orientation {E : Type u_1} [inner_product_space ℝ E] {n : ℕ} (hn : 0 < n) (h : finite_dimensional.finrank ℝ E = n) (x : orientation ℝ E (fin n)) : (orientation.fin_orthonormal_basis hn h x).orientation = x
theorem algebra.finite_presentation.trans {R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [algebra R A] [comm_ring B] [algebra R B] [algebra A B] [is_scalar_tower R A B] (hfpA : algebra.finite_presentation R A) (hfpB : algebra.finite_presentation A B) : algebra.finite_presentation R B
theorem has_scalar.comp.smul_comm_class {M : Type u_1} {N : Type u_2} {α : Type u_6} {β : Type u_7} [has_scalar M α] [has_scalar β α] [smul_comm_class M β α] (g : N → M) : smul_comm_class N β α
theorem interval_integral.integral_eq_sub_of_has_deriv_right {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} {f' : ℝ → E} (hcont : continuous_on f (set.interval a b)) (hderiv : ∀ (x : ℝ), x ∈ set.Ioo (linear_order.min a b) (linear_order.max a b) → has_deriv_within_at f (f' x) (set.Ioi x) x) (hint : interval_integrable f' measure_theory.measure_space.volume a b) : ∫ (y : ℝ) in a..b, f' y = f b - f a
theorem mvpfunctor.W_rec_eq {n : ℕ} (P : mvpfunctor (n + 1)) {α : typevec n} {C : Type u_1} (g : Π (a : P.A), (P.drop.B a).arrow α → (P.last.B a → P.W α) → (P.last.B a → C) → C) (a : P.A) (f' : (P.drop.B a).arrow α) (f : P.last.B a → P.W α) : P.W_rec g (P.W_mk a f' f) = g a f' f (λ (i : P.last.B a), P.W_rec g (f i))
theorem measure_theory.exists_measurable_superset {α : Type u_1} [measurable_space α] (μ : measure_theory.measure α) (s : set α) : ∃ (t : set α), s ⊆ t ∧ measurable_set t ∧ ⇑μ t = ⇑μ s
theorem tsub_lt_tsub_iff_right {α : Type u_1} [canonically_linear_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b c : α} [contravariant_class α α has_add.add has_le.le] (h : c ≤ a) : a - c < b - c ↔ a < b
theorem analytic_on.deriv {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {s : set 𝕜} [complete_space F] (h : analytic_on 𝕜 f s) : analytic_on 𝕜 (deriv f) s
theorem asymptotics.is_o.eventually_mul_div_cancel {α : Type u_1} {𝕜 : Type u_14} [normed_field 𝕜] {l : filter α} {u v : α → 𝕜} (h : u =o[l] v) : u / v * v =ᶠ[l] u
theorem has_sbtw.sbtw.not_btw {α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : ¬has_btw.btw c b a
theorem minpoly.nat_degree_pos {A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] [nontrivial B] {x : B} (hx : is_integral A x) : 0 < (minpoly A x).nat_degree
theorem measure_theory.measure.hausdorff_measure_le_liminf_sum {X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] {β : Type u_1} {ι : β → Type u_3} [hι : Π (n : β), fintype (ι n)] (d : ℝ) (s : set X) {l : filter β} (r : β → ennreal) (hr : filter.tendsto r l (nhds 0)) (t : Π (n : β), ι n → set X) (ht : ∀ᶠ (n : β) in l, ∀ (i : ι n), emetric.diam (t n i) ≤ r n) (hst : ∀ᶠ (n : β) in l, s ⊆ ⋃ (i : ι n), t n i) : ⇑(measure_theory.measure.hausdorff_measure d) s ≤ l.liminf (λ (n : β), finset.univ.sum (λ (i : ι n), emetric.diam (t n i) ^ d))
theorem real.abs_log_mul_self_rpow_lt (x t : ℝ) (h1 : 0 < x) (h2 : x ≤ 1) (ht : 0 < t) : |real.log x * x ^ t| < 1 / t
theorem unit_interval.le_one' {t : ↥unit_interval} : t ≤ 1
theorem finset.card_erase_eq_ite {α : Type u_1} {s : finset α} {a : α} [decidable_eq α] : (s.erase a).card = ite (a ∈ s) (s.card - 1) s.card
theorem polynomial.monic.irreducible_of_irreducible_map {R : Type u} {S : Type v} [comm_ring R] [is_domain R] [comm_ring S] [is_domain S] (φ : R →+* S) (f : polynomial R) (h_mon : f.monic) (h_irr : irreducible (polynomial.map φ f)) : irreducible f
theorem category_theory.comonad.coalgebra_iso_of_iso {C : Type u₁} [category_theory.category C] (G : category_theory.comonad C) {A B : G.coalgebra} (f : A ⟶ B) [category_theory.is_iso f.f] : category_theory.is_iso f
theorem deriv.lhopital_zero_at_bot {l : filter ℝ} {f g : ℝ → ℝ} (hdf : ∀ᶠ (x : ℝ) in filter.at_bot, differentiable_at ℝ f x) (hg' : ∀ᶠ (x : ℝ) in filter.at_bot, deriv g x ≠ 0) (hfbot : filter.tendsto f filter.at_bot (nhds 0)) (hgbot : filter.tendsto g filter.at_bot (nhds 0)) (hdiv : filter.tendsto (λ (x : ℝ), deriv f x / deriv g x) filter.at_bot l) : filter.tendsto (λ (x : ℝ), f x / g x) filter.at_bot l
theorem quaternion_algebra.basis.ext {R : Type u_1} {A : Type u_2} [comm_ring R] [ring A] [algebra R A] {c₁ c₂ : R} ⦃q₁ q₂ : quaternion_algebra.basis A c₁ c₂⦄ (hi : q₁.i = q₂.i) (hj : q₁.j = q₂.j) : q₁ = q₂
theorem euclidean_geometry.mul_dist_eq_mul_dist_of_cospherical {V : Type u_1} [inner_product_space ℝ V] {P : Type u_2} [metric_space P] [normed_add_torsor V P] {a b c d p : P} (h : euclidean_geometry.cospherical {a, b, c, d}) (hapb : ∃ (k₁ : ℝ), k₁ ≠ 1 ∧ b -ᵥ p = k₁ • (a -ᵥ p)) (hcpd : ∃ (k₂ : ℝ), k₂ ≠ 1 ∧ d -ᵥ p = k₂ • (c -ᵥ p)) : has_dist.dist a p * has_dist.dist b p = has_dist.dist c p * has_dist.dist d p
theorem is_local_extr.has_deriv_at_eq_zero {f : ℝ → ℝ} {f' a : ℝ} (h : is_local_extr f a) : has_deriv_at f f' a → f' = 0
theorem measure_theory.measure.tendsto_add_haar_inter_smul_one_of_density_one {E : Type u_1} [normed_group E] [measurable_space E] [normed_space ℝ E] [finite_dimensional ℝ E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (s : set E) (x : E) (h : filter.tendsto (λ (r : ℝ), ⇑μ (s ∩ metric.closed_ball x r) / ⇑μ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds 1)) (t : set E) (ht : measurable_set t) (h't : ⇑μ t ≠ 0) (h''t : ⇑μ t ≠ ⊤) : filter.tendsto (λ (r : ℝ), ⇑μ (s ∩ ({x} + r • t)) / ⇑μ ({x} + r • t)) (nhds_within 0 (set.Ioi 0)) (nhds 1)
theorem linear_map.linear_independent_iff {ι : Type u_1} {R : Type u_3} {M : Type u_5} {M' : Type u_6} {v : ι → M} [semiring R] [add_comm_monoid M] [add_comm_monoid M'] [module R M] [module R M'] (f : M →ₗ[R] M') (hf_inj : f.ker = ⊥) : linear_independent R (⇑f ∘ v) ↔ linear_independent R v
theorem has_strict_fderiv_at.eq_implicit_function {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] [complete_space 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] [finite_dimensional 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {a : E} (hf : has_strict_fderiv_at f f' a) (hf' : f'.range = ⊤) : ∀ᶠ (x : E) in nhds a, has_strict_fderiv_at.implicit_function f f' hf hf' (f x) (⇑(has_strict_fderiv_at.implicit_to_local_homeomorph f f' hf hf') x).snd = x
theorem inner_product_space.is_self_adjoint_iff_bilin_form {F : Type u_3} [inner_product_space ℝ F] (T : F →ₗ[ℝ] F) : inner_product_space.is_self_adjoint T ↔ bilin_form_of_real_inner.is_self_adjoint T
theorem add_con.lift_range {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} {f : M →+ P} (H : c ≤ add_con.ker f) : (c.lift f H).mrange = f.mrange
theorem submodule.orthogonal_orthogonal {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) [complete_space ↥K] : Kᗮᗮ = K
theorem nat.base_pow_length_digits_le' (b m : ℕ) (hm : m ≠ 0) : (b + 2) ^ ((b + 2).digits m).length ≤ (b + 2) * m
theorem orthonormal.oangle_eq_two_zsmul_oangle_sub_of_norm_eq {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y z : V} (hxyne : x ≠ y) (hxzne : x ≠ z) (hxy : ∥x∥ = ∥y∥) (hxz : ∥x∥ = ∥z∥) : hb.oangle y z = 2 • hb.oangle (y - x) (z - x)
theorem ordered_add_comm_group.le_of_add_le_add_left {α : Type u_1} [has_add α] [has_le α] [contravariant_class α α has_add.add has_le.le] {a b c : α} (bc : a + b ≤ a + c) : b ≤ c
theorem free_group.reduce.self {α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.mk (free_group.reduce L) = free_group.mk L
theorem nat.factorization_mul_apply_of_coprime {p a b : ℕ} (hab : a.coprime b) : ⇑((a * b).factorization) p = ⇑(a.factorization) p + ⇑(b.factorization) p
theorem complex.differentiable_on_update_lim_insert_of_is_o {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] {f : ℂ → E} {s : set ℂ} {c : ℂ} (hc : s ∈ nhds_within c {c}ᶜ) (hd : differentiable_on ℂ f s) (ho : (λ (z : ℂ), f z - f c) =o[nhds_within c {c}ᶜ] λ (z : ℂ), (z - c)⁻¹) : differentiable_on ℂ (function.update f c (lim (nhds_within c {c}ᶜ) f)) (has_insert.insert c s)
theorem category_theory.limits.has_terminal_of_unique {C : Type u₁} [category_theory.category C] (X : C) [h : Π (Y : C), unique (Y ⟶ X)] : category_theory.limits.has_terminal C
theorem complex.circle_integral_sub_inv_smul_of_differentiable_on_off_countable_aux {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] {R : ℝ} {c w : ℂ} {f : ℂ → E} {s : set ℂ} (hs : s.countable) (hw : w ∈ metric.ball c R  s) (hc : continuous_on f (metric.closed_ball c R)) (hd : ∀ (x : ℂ), x ∈ metric.ball c R  s → differentiable_at ℂ f x) : ∮ (z : ℂ) in C(c, R), (z - w)⁻¹ • f z = (2 * ↑real.pi * complex.I) • f w
theorem strict_mono.mul' {α : Type u_1} {β : Type u_2} [has_mul α] [preorder α] [preorder β] {f g : β → α} [covariant_class α α has_mul.mul has_lt.lt] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] (hf : strict_mono f) (hg : strict_mono g) : strict_mono (λ (x : β), f x * g x)
theorem map_lt_line_map_iff_slope_lt_slope_left {k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k → E} {a b r : k} (h : 0 < r * (b - a)) : f (⇑(affine_map.line_map a b) r) < ⇑(affine_map.line_map (f a) (f b)) r ↔ slope f a (⇑(affine_map.line_map a b) r) < slope f a b
theorem map_mul_inv {G : Type u_6} {H : Type u_7} {F : Type u_8} [group G] [division_monoid H] [monoid_hom_class F G H] (f : F) (a b : G) : ⇑f (a * b⁻¹) = ⇑f a * (⇑f b)⁻¹
theorem setoid.exists_of_mem_partition {α : Type u_1} {c : set (set α)} (hc : setoid.is_partition c) {s : set α} (hs : s ∈ c) : ∃ (y : α), s = {x : α | (setoid.mk_classes c _).rel x y}
theorem reflection_inv {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K : submodule 𝕜 E} [complete_space ↥K] : (reflection K)⁻¹ = reflection K
theorem clifford_algebra.hom_ext {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Q : quadratic_form R M} {A : Type u_3} [semiring A] [algebra R A] {f g : clifford_algebra Q →ₐ[R] A} : f.to_linear_map.comp (clifford_algebra.ι Q) = g.to_linear_map.comp (clifford_algebra.ι Q) → f = g
theorem absorbent_ball_zero {𝕜 : Type u_3} {E : Type u_4} [normed_field 𝕜] [semi_normed_group E] [normed_space 𝕜 E] {r : ℝ} (hr : 0 < r) : absorbent 𝕜 (metric.ball 0 r)
theorem measure_theory.outer_measure.binfi_apply {α : Type u_1} {ι : Type u_2} {I : set ι} (hI : I.nonempty) (m : ι → measure_theory.outer_measure α) (s : set α) : (⇑⨅ (i : ι) (H : i ∈ I), m i) s = ⨅ (t : ℕ → set α) (h2 : s ⊆ set.Union t), ∑' (n : ℕ), ⨅ (i : ι) (H : i ∈ I), ⇑(m i) (t n)
theorem polynomial.gal.splits_in_splitting_field_of_comp {F : Type u_1} [field F] (p q : polynomial F) (hq : q.nat_degree ≠ 0) : polynomial.splits (algebra_map F (p.comp q).splitting_field) p
theorem monoid_hom.ext_iff {M : Type u_3} {N : Type u_4} [mul_one_class M] [mul_one_class N] {f g : M →* N} : f = g ↔ ∀ (x : M), ⇑f x = ⇑g x
theorem mv_polynomial.induction_on' {R : Type u} {σ : Type u_1} [comm_semiring R] {P : mv_polynomial σ R → Prop} (p : mv_polynomial σ R) (h1 : ∀ (u : σ →₀ ℕ) (a : R), P (⇑(mv_polynomial.monomial u) a)) (h2 : ∀ (p q : mv_polynomial σ R), P p → P q → P (p + q)) : P p
theorem category_theory.grothendieck_topology.close_eq_top_iff_mem {C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : J₁.close S = ⊤ ↔ S ∈ ⇑J₁ X
theorem affine.triangle.altitude_eq_monge_plane {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle ℝ P) {i₁ i₂ i₃ : fin 3} (h₁₂ : i₁ ≠ i₂) (h₁₃ : i₁ ≠ i₃) (h₂₃ : i₂ ≠ i₃) : affine.simplex.altitude t i₁ = affine.simplex.monge_plane t i₂ i₃
theorem filter.tendsto.inv₀ {α : Type u_1} {G₀ : Type u_3} [has_zero G₀] [has_inv G₀] [topological_space G₀] [has_continuous_inv₀ G₀] {l : filter α} {f : α → G₀} {a : G₀} (hf : filter.tendsto f l (nhds a)) (ha : a ≠ 0) : filter.tendsto (λ (x : α), (f x)⁻¹) l (nhds a⁻¹)
theorem is_closed.is_seq_closed {X : Type u_1} [topological_space X] {s : set X} (hs : is_closed s) : is_seq_closed s
theorem finset.eventually_all {α : Type u} {ι : Type u_1} (I : finset ι) {l : filter α} {p : ι → α → Prop} : (∀ᶠ (x : α) in l, ∀ (i : ι), i ∈ I → p i x) ↔ ∀ (i : ι), i ∈ I → (∀ᶠ (x : α) in l, p i x)
theorem set.mem_fintype_prod {α : Type u_2} {ι : Type u_5} [comm_monoid α] [fintype ι] (f : ι → set α) (a : α) : a ∈ finset.univ.prod (λ (i : ι), f i) ↔ ∃ (g : ι → α) (hg : ∀ (i : ι), g i ∈ f i), finset.univ.prod (λ (i : ι), g i) = a
theorem unique_factorization_monoid.exists_reduced_factors {R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] (a : R) (H : a ≠ 0) (b : R) : ∃ (a' b' c' : R), (∀ {d : R}, d ∣ a' → d ∣ b' → is_unit d) ∧ c' * a' = a ∧ c' * b' = b
theorem solvable_by_rad.induction1 {F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] {α β : ↥(solvable_by_rad F E)} (hβ : β ∈ F⟮α⟯) (hα : solvable_by_rad.P α) : solvable_by_rad.P β
theorem composition.order_emb_of_fin_boundaries {n : ℕ} (c : composition n) : c.boundaries.order_emb_of_fin _ = c.boundary
theorem measure_theory.hausdorff_measure_pi_real {ι : Type u_1} [fintype ι] : measure_theory.measure.hausdorff_measure ↑(fintype.card ι) = measure_theory.measure_space.volume
theorem submodule.is_closed_orthogonal {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) : is_closed ↑Kᗮ
theorem continuous_multilinear_map.cons_add {R : Type u} {n : ℕ} {M : fin n.succ → Type w} {M₂ : Type w₂} [semiring R] [Π (i : fin n.succ), add_comm_monoid (M i)] [add_comm_monoid M₂] [Π (i : fin n.succ), module R (M i)] [module R M₂] [Π (i : fin n.succ), topological_space (M i)] [topological_space M₂] (f : continuous_multilinear_map R M M₂) (m : Π (i : fin n), M i.succ) (x y : M 0) : ⇑f (fin.cons (x + y) m) = ⇑f (fin.cons x m) + ⇑f (fin.cons y m)
theorem convex.set_average_mem {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {t : set α} {f : α → E} (hs : convex ℝ s) (hsc : is_closed s) (h0 : ⇑μ t ≠ 0) (ht : ⇑μ t ≠ ⊤) (hfs : ∀ᵐ (x : α) ∂μ.restrict t, f x ∈ s) (hfi : measure_theory.integrable_on f t μ) : ⨍ (x : α) in t, f x ∂μ ∈ s
theorem norm_image_sub_le_of_norm_deriv_le_segment_01 {E : Type u_1} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {C : ℝ} (hf : differentiable_on ℝ f (set.Icc 0 1)) (bound : ∀ (x : ℝ), x ∈ set.Ico 0 1 → ∥deriv_within f (set.Icc 0 1) x∥ ≤ C) : ∥f 1 - f 0∥ ≤ C
theorem affine.simplex.eq_monge_point_of_forall_mem_monge_plane {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} {s : affine.simplex ℝ P (n + 2)} {i₁ : fin (n + 3)} {p : P} (h : ∀ (i₂ : fin (n + 3)), i₁ ≠ i₂ → p ∈ s.monge_plane i₁ i₂) : p = s.monge_point
theorem lt_of_tsub_lt_tsub_left {α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] [covariant_class α α has_add.add has_le.le] (h : a - b < a - c) : c < b
theorem algebra.norm_eq_zero_iff' {K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] [finite_dimensional K L] {x : L} : ⇑linear_map.det (⇑(algebra.lmul K L) x) = 0 ↔ x = 0
theorem continuous_linear_map.is_compact_image_coe_of_bounded_of_weak_closed {𝕜 : Type u_1} {𝕜₂ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {E' : Type u_10} [semi_normed_group E'] [normed_space 𝕜 E'] [ring_hom_isometric σ₁₂] [proper_space F] {s : set (E' →SL[σ₁₂] F)} (hb : metric.bounded s) (hc : ∀ (f : E' →SL[σ₁₂] F), ⇑f ∈ closure (coe_fn '' s) → f ∈ s) : is_compact (coe_fn '' s)
theorem witt_vector.is_poly.comp {p : ℕ} {g f : Π ⦃R : Type u_1⦄ [_inst_3 : comm_ring R], witt_vector p R → witt_vector p R} (hg : witt_vector.is_poly p g) (hf : witt_vector.is_poly p f) : witt_vector.is_poly p (λ (R : Type u_1) (_Rcr : comm_ring R), g ∘ f)
theorem category_theory.topology_eq_iff_same_sheaves {C : Type u} [category_theory.category C] {J₁ J₂ : category_theory.grothendieck_topology C} : J₁ = J₂ ↔ ∀ (P : Cᵒᵖ ⥤ Type (max v u)), category_theory.presieve.is_sheaf J₁ P ↔ category_theory.presieve.is_sheaf J₂ P
theorem padic_val_nat.one {p : ℕ} : padic_val_nat p 1 = 0
theorem upper_semicontinuous_on.add' {α : Type u_1} [topological_space α] {s : set α} {γ : Type u_4} [linear_ordered_add_comm_monoid γ] [topological_space γ] [order_topology γ] {f g : α → γ} (hf : upper_semicontinuous_on f s) (hg : upper_semicontinuous_on g s) (hcont : ∀ (x : α), x ∈ s → continuous_at (λ (p : γ × γ), p.fst + p.snd) (f x, g x)) : upper_semicontinuous_on (λ (z : α), f z + g z) s
theorem inner_product_geometry.cos_angle_mul_norm_mul_norm {V : Type u_1} [inner_product_space ℝ V] (x y : V) : real.cos (inner_product_geometry.angle x y) * (∥x∥ * ∥y∥) = has_inner.inner x y
theorem subtype.prop {α : Sort u_1} {p : α → Prop} (x : subtype p) : p ↑x
theorem filter.tendsto.at_bot_mul_neg_const {α : Type u_3} {β : Type u_4} [linear_ordered_field α] {l : filter β} {f : β → α} {r : α} (hr : r < 0) (hf : filter.tendsto f l filter.at_bot) : filter.tendsto (λ (x : β), f x * r) l filter.at_top
theorem metric.bounded.exists_norm_le {E : Type u_1} [semi_normed_group E] {s : set E} : metric.bounded s → (∃ (R : ℝ), ∀ (x : E), x ∈ s → ∥x∥ ≤ R)
theorem exists_bounded_zero_one_of_closed {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : ∃ (f : bounded_continuous_function X ℝ), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1
theorem is_preconnected_of_forall {α : Type u} [topological_space α] {s : set α} (x : α) (H : ∀ (y : α), y ∈ s → (∃ (t : set α) (H : t ⊆ s), x ∈ t ∧ y ∈ t ∧ is_preconnected t)) : is_preconnected s
theorem pgame.le_zero {x : pgame} : x ≤ 0 ↔ ∀ (i : x.left_moves), ∃ (j : (x.move_left i).right_moves), (x.move_left i).move_right j ≤ 0
theorem orientation.oangle_smul_right_of_pos {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x y : V) {r : ℝ} (hr : 0 < r) : o.oangle x (r • y) = o.oangle x y
theorem lipschitz_with.of_le_add_mul {α : Type u} [pseudo_metric_space α] {f : α → ℝ} (K : nnreal) (h : ∀ (x y : α), f x ≤ f y + ↑K * has_dist.dist x y) : lipschitz_with K f
theorem affine.simplex.monge_point_mem_monge_plane {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P (n + 2)) {i₁ i₂ : fin (n + 3)} : s.monge_point ∈ s.monge_plane i₁ i₂
theorem metric.uniform_embedding_bot_of_pairwise_le_dist {α : Type u} [pseudo_metric_space α] {β : Type u_1} {ε : ℝ} (hε : 0 < ε) {f : β → α} (hf : pairwise (λ (x y : β), ε ≤ has_dist.dist (f x) (f y))) : uniform_embedding f
theorem module.ray.some_vector_ray {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : module.ray R M) : ray_of_ne_zero R x.some_vector _ = x
theorem topological_space.is_open_Union_countable {α : Type u} [t : topological_space α] [topological_space.second_countable_topology α] {ι : Type u_1} (s : ι → set α) (H : ∀ (i : ι), is_open (s i)) : ∃ (T : set ι), T.countable ∧ (⋃ (i : ι) (H : i ∈ T), s i) = ⋃ (i : ι), s i
theorem truncated_witt_vector.commutes (p : ℕ) [hp : fact (nat.prime p)] (n : ℕ) {m : ℕ} (hm : n ≤ m) : (truncated_witt_vector.truncate hm).comp (truncated_witt_vector.zmod_equiv_trunc p m).to_ring_hom = (truncated_witt_vector.zmod_equiv_trunc p n).to_ring_hom.comp (zmod.cast_hom _ (zmod (p ^ n)))
theorem continuous_map.continuous_restrict {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (s : set α) : continuous (λ (F : C(α, β)), continuous_map.restrict s F)
theorem multilinear_map.bound_of_shell {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : multilinear_map 𝕜 E G) {ε : ι → ℝ} {C : ℝ} (hε : ∀ (i : ι), 0 < ε i) {c : ι → 𝕜} (hc : ∀ (i : ι), 1 < ∥c i∥) (hf : ∀ (m : Π (i : ι), E i), (∀ (i : ι), ε i / ∥c i∥ ≤ ∥m i∥) → (∀ (i : ι), ∥m i∥ < ε i) → ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : ι), ∥m i∥)) (m : Π (i : ι), E i) : ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : ι), ∥m i∥)
theorem tangent_map_chart {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {p q : tangent_bundle I M} (h : q.fst ∈ (charted_space.chart_at H p.fst).to_local_equiv.source) : tangent_map I I ⇑(charted_space.chart_at H p.fst) q = ⇑((equiv.sigma_equiv_prod H E).symm) (⇑(charted_space.chart_at (model_prod H E) p) q)
theorem matrix.pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal {n : Type u_1} {𝕜 : Type u_3} [field 𝕜] [decidable_eq n] [fintype n] (M : matrix n n 𝕜) : ∃ (L L' : list (matrix.transvection_struct n 𝕜)) (D : n → 𝕜), ((list.map matrix.transvection_struct.to_matrix L).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L').prod = matrix.diagonal D
theorem matrix.transpose_apply {m : Type u_2} {n : Type u_3} {α : Type v} (M : matrix m n α) (i : m) (j : n) : M.transpose j i = M i j
theorem topological_add_group.continuous_conj {G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] (g : G) : continuous (λ (h : G), g + h + -g)
theorem bounded_continuous_function.norm_eq_of_nonempty {α : Type u} {β : Type v} [topological_space α] [semi_normed_group β] (f : bounded_continuous_function α β) [h : nonempty α] : ∥f∥ = has_Inf.Inf {C : ℝ | ∀ (x : α), ∥⇑f x∥ ≤ C}
theorem finset.sum_Ico_Ico_comm {M : Type u_1} [add_comm_monoid M] (a b : ℕ) (f : ℕ → ℕ → M) : (finset.Ico a b).sum (λ (i : ℕ), (finset.Ico i b).sum (λ (j : ℕ), f i j)) = (finset.Ico a b).sum (λ (j : ℕ), (finset.Ico a (j + 1)).sum (λ (i : ℕ), f i j))
theorem euclidean_geometry.orthogonal_projection_orthogonal_projection {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ℝ P) [nonempty ↥s] [complete_space ↥(s.direction)] (p : P) : ⇑(euclidean_geometry.orthogonal_projection s) ↑(⇑(euclidean_geometry.orthogonal_projection s) p) = ⇑(euclidean_geometry.orthogonal_projection s) p
theorem submodule.finrank_quotient_le {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] (s : submodule K V) : finite_dimensional.finrank K (V ⧸ s) ≤ finite_dimensional.finrank K V
theorem map_snd_nhds_within {α : Type u} {β : Type v} [topological_space α] [topological_space β] (x : α × β) : filter.map prod.snd (nhds_within x (prod.fst ⁻¹' {x.fst})) = nhds x.snd
theorem finsum_mem_union'' {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} {s t : set α} (hst : disjoint (s ∩ function.support f) (t ∩ function.support f)) (hs : (s ∩ function.support f).finite) (ht : (t ∩ function.support f).finite) : finsum (λ (i : α), finsum (λ (H : i ∈ s ∪ t), f i)) = finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) + finsum (λ (i : α), finsum (λ (H : i ∈ t), f i))
theorem generalized_continued_fraction.denominators_recurrence {K : Type u_1} {g : generalized_continued_fraction K} {n : ℕ} [division_ring K] {gp : generalized_continued_fraction.pair K} {ppredB predB : K} (succ_nth_s_eq : g.s.nth (n + 1) = option.some gp) (nth_denom_eq : g.denominators n = ppredB) (succ_nth_denom_eq : g.denominators (n + 1) = predB) : g.denominators (n + 2) = gp.b * predB + gp.a * ppredB
theorem finprod_mem_one {α : Type u_1} {M : Type u_5} [comm_monoid M] (s : set α) : finprod (λ (i : α), finprod (λ (H : i ∈ s), 1)) = 1
theorem multiples.zero_mem {M : Type u_1} [add_monoid M] {x : M} : 0 ∈ multiples x
theorem comp_mul_left {α : Type u_1} [semigroup α] (x y : α) : has_mul.mul x ∘ has_mul.mul y = has_mul.mul (x * y)
theorem vitali_family.ae_tendsto_rn_deriv {α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] (ρ : measure_theory.measure α) [measure_theory.is_locally_finite_measure ρ] : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (a : set α), ⇑ρ a / ⇑μ a) (v.filter_at x) (nhds (ρ.rn_deriv μ x))
theorem fin.range_succ_above {n : ℕ} (p : fin (n + 1)) : set.range ⇑(p.succ_above) = {p}ᶜ
theorem controlled_closure_range_of_complete {G : Type u_1} [normed_group G] [complete_space G] {H : Type u_2} [normed_group H] {f : normed_group_hom G H} {K : Type u_3} [semi_normed_group K] {j : normed_group_hom K H} (hj : ∀ (x : K), ∥⇑j x∥ = ∥x∥) {C ε : ℝ} (hC : 0 < C) (hε : 0 < ε) (hyp : ∀ (k : K), ∃ (g : G), ⇑f g = ⇑j k ∧ ∥g∥ ≤ C * ∥k∥) : f.surjective_on_with j.range.topological_closure (C + ε)
theorem div_div_self {G₀ : Type u_2} [group_with_zero G₀] (a : G₀) : a / (a / a) = a
theorem polynomial.cyclotomic'_eq_X_pow_sub_one_div {K : Type u_1} [comm_ring K] [is_domain K] {ζ : K} {n : ℕ} (hpos : 0 < n) (h : is_primitive_root ζ n) : polynomial.cyclotomic' n K = (polynomial.X ^ n - 1) /ₘ n.proper_divisors.prod (λ (i : ℕ), polynomial.cyclotomic' i K)
theorem measure_theory.integral_eq_lintegral_pos_part_sub_lintegral_neg_part {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : α → ℝ} (hf : measure_theory.integrable f μ) : ∫ (a : α), f a ∂μ = (∫⁻ (a : α), ennreal.of_real (f a) ∂μ).to_real - (∫⁻ (a : α), ennreal.of_real (-f a) ∂μ).to_real
theorem measure_theory.fin_strongly_measurable.measurable {α : Type u_1} {β : Type u_2} {m0 : measurable_space α} {μ : measure_theory.measure α} {f : α → β} [has_zero β] [topological_space β] [topological_space.pseudo_metrizable_space β] [measurable_space β] [borel_space β] (hf : measure_theory.fin_strongly_measurable f μ) : measurable f
theorem measure_theory.submartingale_iff_expected_stopped_value_mono {α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {𝒢 : measure_theory.filtration ℕ m0} [measure_theory.is_finite_measure μ] {f : ℕ → α → ℝ} (hadp : measure_theory.adapted 𝒢 f) (hint : ∀ (i : ℕ), measure_theory.integrable (f i) μ) : measure_theory.submartingale f 𝒢 μ ↔ ∀ (τ π : α → ℕ), measure_theory.is_stopping_time 𝒢 τ → measure_theory.is_stopping_time 𝒢 π → τ ≤ π → (∃ (N : ℕ), ∀ (x : α), π x ≤ N) → ∫ (x : α), measure_theory.stopped_value f τ x ∂μ ≤ ∫ (x : α), measure_theory.stopped_value f π x ∂μ
theorem closed_embedding.tendsto_cocompact {α : Type u} {β : Type v} [topological_space α] [topological_space β] {f : α → β} (hf : closed_embedding f) : filter.tendsto f (filter.cocompact α) (filter.cocompact β)
theorem diffeomorph.coe_fn_injective {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {H : Type u_5} [topological_space H] {H' : Type u_6} [topological_space H'] {I : model_with_corners 𝕜 E H} {I' : model_with_corners 𝕜 E' H'} {M : Type u_8} [topological_space M] [charted_space H M] {M' : Type u_9} [topological_space M'] [charted_space H' M'] {n : with_top ℕ} : function.injective (λ (h : diffeomorph I I' M M' n) (x : M), ⇑h x)
theorem finset.mem_shadow_iff_exists_mem_card_add {α : Type u_1} [decidable_eq α] {𝒜 : finset (finset α)} {s : finset α} {k : ℕ} : s ∈ finset.shadow^[k] 𝒜 ↔ ∃ (t : finset α) (H : t ∈ 𝒜), s ⊆ t ∧ t.card = s.card + k
theorem concave_on_iff_slope_anti_adjacent {𝕜 : Type u_1} [linear_ordered_field 𝕜] {s : set 𝕜} {f : 𝕜 → 𝕜} : concave_on 𝕜 s f ↔ convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) ≤ (f y - f x) / (y - x)
theorem real.summable_one_div_nat_rpow {p : ℝ} : summable (λ (n : ℕ), 1 / ↑n ^ p) ↔ 1 < p
theorem finsupp.sum_add_index' {α : Type u_1} {M : Type u_5} {N : Type u_7} [add_zero_class M] [add_comm_monoid N] {f g : α →₀ M} {h : α → M → N} (h_zero : ∀ (a : α), h a 0 = 0) (h_add : ∀ (a : α) (b₁ b₂ : M), h a (b₁ + b₂) = h a b₁ + h a b₂) : (f + g).sum h = f.sum h + g.sum h
theorem map_fst_nhds_within {α : Type u} {β : Type v} [topological_space α] [topological_space β] (x : α × β) : filter.map prod.fst (nhds_within x (prod.snd ⁻¹' {x.snd})) = nhds x.fst
theorem subgroup.le_normalizer_comap {G : Type u_1} [group G] {H : subgroup G} {N : Type u_3} [group N] (f : N →* G) : subgroup.comap f H.normalizer ≤ (subgroup.comap f H).normalizer
theorem composition.disjoint_range {n : ℕ} (c : composition n) {i₁ i₂ : fin c.length} (h : i₁ ≠ i₂) : disjoint (set.range ⇑(c.embedding i₁)) (set.range ⇑(c.embedding i₂))
theorem strict_convex_on.lt_on_open_segment {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [linear_ordered_add_comm_monoid β] [has_scalar 𝕜 E] [module 𝕜 β] [ordered_smul 𝕜 β] {s : set E} {f : E → β} (hf : strict_convex_on 𝕜 s f) {x y z : E} (hx : x ∈ s) (hy : y ∈ s) (hxy : x ≠ y) (hz : z ∈ open_segment 𝕜 x y) : f z < linear_order.max (f x) (f y)
theorem is_countably_spanning.prod {α : Type u_1} {β : Type u_3} {C : set (set α)} {D : set (set β)} (hC : is_countably_spanning C) (hD : is_countably_spanning D) : is_countably_spanning (set.image2 has_set_prod.prod C D)
theorem filter.coext {α : Type u} {f g : filter α} (h : ∀ (s : set α), sᶜ ∈ f ↔ sᶜ ∈ g) : f = g
theorem holder_with.dimH_image_le {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {C r : nnreal} {f : X → Y} (h : holder_with C r f) (hr : 0 < r) (s : set X) : dimH (f '' s) ≤ dimH s / ↑r
theorem add_submonoid.localization_map.neg_inj {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {f : M →+ N} (hf : ∀ (y : ↥S), is_add_unit (⇑f ↑y)) {y z : ↥S} (h : -⇑(is_add_unit.lift_right (f.restrict S) hf) y = -⇑(is_add_unit.lift_right (f.restrict S) hf) z) : ⇑f ↑y = ⇑f ↑z
theorem module.free.rank_pi_fintype (R : Type u) [ring R] [strong_rank_condition R] {ι : Type v} [fintype ι] {M : ι → Type w} [Π (i : ι), add_comm_group (M i)] [Π (i : ι), module R (M i)] [∀ (i : ι), module.free R (M i)] : module.rank R (Π (i : ι), M i) = cardinal.sum (λ (i : ι), module.rank R (M i))
theorem tsum_geometric_inv_two_ge (n : ℕ) : ∑' (i : ℕ), ite (n ≤ i) (2⁻¹ ^ i) 0 = 2 * 2⁻¹ ^ n
theorem probability_theory.cond_eq_inv_mul_cond_mul {α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) {s t : set α} [measure_theory.is_finite_measure μ] (hms : measurable_set s) (hmt : measurable_set t) : ⇑(probability_theory.cond μ s) t = (⇑μ s)⁻¹ * ⇑(probability_theory.cond μ t) s * ⇑μ t
theorem closure_operator.closed_eq_range_close {α : Type u_1} [partial_order α] (c : closure_operator α) : c.closed = set.range ⇑c
theorem intermediate_field.div_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} : x ∈ S → y ∈ S → x / y ∈ S
theorem nat.modeq.modeq_cancel_left_div_gcd {a b c m : ℕ} (hm : 0 < m) (h : c * a ≡ c * b [MOD m]) : a ≡ b [MOD m / m.gcd c]
theorem category_theory.is_pullback.of_bot {C : Type u₁} [category_theory.category C] {X₁₁ X₁₂ X₂₁ X₂₂ X₃₁ X₃₂ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₂₁ : X₂₁ ⟶ X₂₂} {h₃₁ : X₃₁ ⟶ X₃₂} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₂₁ : X₂₁ ⟶ X₃₁} {v₂₂ : X₂₂ ⟶ X₃₂} (s : category_theory.is_pullback h₁₁ (v₁₁ ≫ v₂₁) (v₁₂ ≫ v₂₂) h₃₁) (p : h₁₁ ≫ v₁₂ = v₁₁ ≫ h₂₁) (t : category_theory.is_pullback h₂₁ v₂₁ v₂₂ h₃₁) : category_theory.is_pullback h₁₁ v₁₁ v₁₂ h₂₁
theorem category_theory.limits.cotrident.is_colimit.hom_iso_natural {J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J → (X ⟶ Y)} [nonempty J] {t : category_theory.limits.cotrident f} {Z Z' : C} (q : Z ⟶ Z') (ht : category_theory.limits.is_colimit t) (k : t.X ⟶ Z) : ↑(⇑(category_theory.limits.cotrident.is_colimit.hom_iso ht Z') (k ≫ q)) = ↑(⇑(category_theory.limits.cotrident.is_colimit.hom_iso ht Z) k) ≫ q
theorem Compactum.continuous_of_hom {X Y : Compactum} (f : X ⟶ Y) : continuous ⇑f
theorem submodule.mul_induction_on' {R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] {M N : submodule R A} {C : Π (r : A), r ∈ M * N → Prop} (hm : ∀ (m : A) (H : m ∈ M) (n : A) (H_1 : n ∈ N), C (m * n) _) (ha : ∀ (x : A) (hx : x ∈ M * N) (y : A) (hy : y ∈ M * N), C x hx → C y hy → C (x + y) _) {r : A} (hr : r ∈ M * N) : C r hr
theorem continuous_linear_map.inverse_equiv {R : Type u_1} {M : Type u_2} {M₂ : Type u_3} [topological_space M] [topological_space M₂] [semiring R] [add_comm_monoid M₂] [module R M₂] [add_comm_monoid M] [module R M] (e : M ≃L[R] M₂) : ↑e.inverse = ↑(e.symm)
theorem formal_multilinear_series.le_mul_pow_of_radius_pos {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) (h : 0 < p.radius) : ∃ (C r : ℝ) (hC : 0 < C) (hr : 0 < r), ∀ (n : ℕ), ∥p n∥ ≤ C * r ^ n
theorem affine.simplex.sum_point_weights_with_circumcenter {n : ℕ} (i : fin (n + 1)) : finset.univ.sum (λ (j : affine.simplex.points_with_circumcenter_index n), affine.simplex.point_weights_with_circumcenter i j) = 1
theorem module.End.has_generalized_eigenvalue_of_has_eigenvalue {R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {μ : R} {k : ℕ} (hk : 0 < k) (hμ : f.has_eigenvalue μ) : f.has_generalized_eigenvalue μ k
theorem monoid_algebra.non_unital_alg_hom_ext' (k : Type u₁) {G : Type u₂} [semiring k] [has_mul G] {A : Type u₃} [non_unital_non_assoc_semiring A] [distrib_mul_action k A] {φ₁ φ₂ : monoid_algebra k G →ₙₐ[k] A} (h : φ₁.to_mul_hom.comp (monoid_algebra.of_magma k G) = φ₂.to_mul_hom.comp (monoid_algebra.of_magma k G)) : φ₁ = φ₂
theorem finite_field.exists_nonsquare {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) : ∃ (a : F), ¬is_square a
theorem part.ext {α : Type u_1} {o p : part α} (H : ∀ (a : α), a ∈ o ↔ a ∈ p) : o = p
theorem orthonormal.oangle_neg_self_right {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x : V} (hx : x ≠ 0) : hb.oangle x (-x) = ↑real.pi
theorem conformal_at_iff {E : Type u_1} {F : Type u_2} [inner_product_space ℝ E] [inner_product_space ℝ F] {f : E → F} {x : E} {f' : E →L[ℝ] F} (h : has_fderiv_at f f' x) : conformal_at f x ↔ ∃ (c : ℝ), 0 < c ∧ ∀ (u v : E), has_inner.inner (⇑f' u) (⇑f' v) = c * has_inner.inner u v
theorem normed_group_hom.op_norm_add_le {V₁ : Type u_2} {V₂ : Type u_3} [semi_normed_group V₁] [semi_normed_group V₂] (f g : normed_group_hom V₁ V₂) : ∥f + g∥ ≤ ∥f∥ + ∥g∥
theorem euclidean_geometry.orthogonal_projection_vsub_mem_direction_orthogonal {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ℝ P) [nonempty ↥s] [complete_space ↥(s.direction)] (p : P) : ↑(⇑(euclidean_geometry.orthogonal_projection s) p) -ᵥ p ∈ (s.direction)ᗮ
theorem is_extr_on.dual {α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α} : is_extr_on f s a → is_extr_on (⇑order_dual.to_dual ∘ f) s a
theorem hall_marriage_theorem.hall_hard_inductive {ι : Type u} {α : Type v} [fintype ι] {t : ι → finset α} [decidable_eq α] (ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card) : ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x
theorem cont_diff_at.prod_map {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : with_top ℕ} {E' : Type u_6} [normed_group E'] [normed_space 𝕜 E'] {F' : Type u_7} [normed_group F'] [normed_space 𝕜 F'] {f : E → F} {g : E' → F'} {x : E} {y : E'} (hf : cont_diff_at 𝕜 n f x) (hg : cont_diff_at 𝕜 n g y) : cont_diff_at 𝕜 n (prod.map f g) (x, y)
theorem measurable_div_const' {G : Type u_1} [div_inv_monoid G] [measurable_space G] [has_measurable_mul G] (g : G) : measurable (λ (h : G), h / g)
theorem fin.heq_fun_iff {α : Sort u_1} {k l : ℕ} (h : k = l) {f : fin k → α} {g : fin l → α} : f == g ↔ ∀ (i : fin k), f i = g ⟨↑i, _⟩
theorem linear_map.to_matrix_id {R : Type u_1} [comm_semiring R] {n : Type u_4} [fintype n] [decidable_eq n] {M₁ : Type u_5} [add_comm_monoid M₁] [module R M₁] (v₁ : basis n R M₁) : ⇑(linear_map.to_matrix v₁ v₁) linear_map.id = 1
theorem submodule.mem_of_span_eq_top_of_smul_pow_mem {R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] (M' : submodule R M) (s : set R) (hs : ideal.span s = ⊤) (x : M) (H : ∀ (r : ↥s), ∃ (n : ℕ), ↑r ^ n • x ∈ M') : x ∈ M'
theorem is_top.eq_top {α : Type u} [partial_order α] [order_top α] {a : α} : is_top a → a = ⊤
theorem direct_sum.is_internal_submodule_iff_independent_and_supr_eq_top {R : Type u} [ring R] {ι : Type v} [dec_ι : decidable_eq ι] {M : Type u_1} [add_comm_group M] [module R M] (A : ι → submodule R M) : direct_sum.is_internal A ↔ complete_lattice.independent A ∧ supr A = ⊤
theorem units.inv_eq_self_iff {R : Type x} [ring R] [no_zero_divisors R] (u : Rˣ) : u⁻¹ = u ↔ u = 1 ∨ u = -1
theorem algebraic_independent_finset_map_embedding_subtype {R : Type u_3} {A : Type u_5} [comm_ring R] [comm_ring A] [algebra R A] (s : set A) (li : algebraic_independent R coe) (t : finset ↥s) : algebraic_independent R coe
theorem category_theory.limits.is_iso_limit_cone_parallel_pair_of_self {C : Type u} [category_theory.category C] {X Y : C} {f : X ⟶ Y} {c : category_theory.limits.fork f f} (h : category_theory.limits.is_limit c) : category_theory.is_iso c.ι
theorem dist_convolution_le {G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G → E'} [measurable_space G] {μ : measure_theory.measure G} [semi_normed_group G] [borel_space G] [topological_space.second_countable_topology G] [μ.is_add_left_invariant] [measure_theory.sigma_finite μ] [normed_space ℝ E'] [complete_space E'] {f : G → ℝ} {x₀ : G} {R ε : ℝ} (hε : 0 ≤ ε) (hf : function.support f ⊆ metric.ball 0 R) (hnf : ∀ (x : G), 0 ≤ f x) (hintf : ∫ (x : G), f x ∂μ = 1) (hmg : measure_theory.ae_strongly_measurable g μ) (hg : ∀ (x : G), x ∈ metric.ball x₀ R → has_dist.dist (g x) (g x₀) ≤ ε) : has_dist.dist (convolution f g (continuous_linear_map.lsmul ℝ ℝ) μ x₀) (g x₀) ≤ ε
theorem finset.sum_bij {β : Type u} {α : Type v} {γ : Type w} [add_comm_monoid β] {s : finset α} {t : finset γ} {f : α → β} {g : γ → β} (i : Π (a : α), a ∈ s → γ) (hi : ∀ (a : α) (ha : a ∈ s), i a ha ∈ t) (h : ∀ (a : α) (ha : a ∈ s), f a = g (i a ha)) (i_inj : ∀ (a₁ a₂ : α) (ha₁ : a₁ ∈ s) (ha₂ : a₂ ∈ s), i a₁ ha₁ = i a₂ ha₂ → a₁ = a₂) (i_surj : ∀ (b : γ), b ∈ t → (∃ (a : α) (ha : a ∈ s), b = i a ha)) : s.sum (λ (x : α), f x) = t.sum (λ (x : γ), g x)
theorem emetric.diam_empty {α : Type u} [pseudo_emetric_space α] : emetric.diam ∅ = 0
theorem affine_subspace.inf_coe {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P) : ↑s1 ⊓ ↑s2 = ↑s1 ∩ ↑s2
theorem continuous_multilinear_map.le_op_norm {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : continuous_multilinear_map 𝕜 E G) (m : Π (i : ι), E i) : ∥⇑f m∥ ≤ ∥f∥ * finset.univ.prod (λ (i : ι), ∥m i∥)
theorem mk_univ_complex  : cardinal.mk ↥set.univ = cardinal.continuum
theorem exists_has_deriv_within_at_eq_of_gt_of_lt {a b : ℝ} {f f' : ℝ → ℝ} (hab : a ≤ b) (hf : ∀ (x : ℝ), x ∈ set.Icc a b → has_deriv_within_at f (f' x) (set.Icc a b) x) {m : ℝ} (hma : f' a < m) (hmb : m < f' b) : m ∈ f' '' set.Icc a b
theorem measure_theory.adapted.prog_measurable_of_nat {α : Type u_1} {β : Type u_2} {m : measurable_space α} {f : measure_theory.filtration ℕ m} {u : ℕ → α → β} [add_comm_monoid β] [topological_space β] [has_continuous_add β] (h : measure_theory.adapted f u) : measure_theory.prog_measurable f u
theorem has_deriv_at.lhopital_zero_nhds' {a : ℝ} {l : filter ℝ} {f f' g g' : ℝ → ℝ} (hff' : ∀ᶠ (x : ℝ) in nhds_within a (set.univ  {a}), has_deriv_at f (f' x) x) (hgg' : ∀ᶠ (x : ℝ) in nhds_within a (set.univ  {a}), has_deriv_at g (g' x) x) (hg' : ∀ᶠ (x : ℝ) in nhds_within a (set.univ  {a}), g' x ≠ 0) (hfa : filter.tendsto f (nhds_within a (set.univ  {a})) (nhds 0)) (hga : filter.tendsto g (nhds_within a (set.univ  {a})) (nhds 0)) (hdiv : filter.tendsto (λ (x : ℝ), f' x / g' x) (nhds_within a (set.univ  {a})) l) : filter.tendsto (λ (x : ℝ), f x / g x) (nhds_within a (set.univ  {a})) l
theorem dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at {R : Type u} {K : Type v} {L : Type z} {p : R} [comm_ring R] [field K] [field L] [algebra K L] [algebra R L] [algebra R K] [is_scalar_tower R K L] [is_separable K L] [is_domain R] [normalized_gcd_monoid R] [is_fraction_ring R K] [is_integrally_closed R] {B : power_basis K L} (hp : prime p) (hBint : is_integral R B.gen) {z : L} {Q : polynomial R} (hQ : ⇑(polynomial.aeval B.gen) Q = p • z) (hzint : is_integral R z) (hei : (minpoly R B.gen).is_eisenstein_at (submodule.span R {p})) : p ∣ Q.coeff 0
theorem filter.tendsto.neg_const_mul_at_top {α : Type u_3} {β : Type u_4} [linear_ordered_field α] {l : filter β} {f : β → α} {r : α} (hr : r < 0) (hf : filter.tendsto f l filter.at_top) : filter.tendsto (λ (x : β), r * f x) l filter.at_bot
theorem orthogonal_family.comp {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {G : ι → Type u_5} [Π (i : ι), inner_product_space 𝕜 (G i)] {V : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : orthogonal_family 𝕜 V) {γ : Type u_3} {f : γ → ι} (hf : function.injective f) : orthogonal_family 𝕜 (λ (g : γ), V (f g))
theorem monoid_algebra.map_domain_one {α : Type u_1} {β : Type u_2} {α₂ : Type u_3} [semiring β] [has_one α] [has_one α₂] {F : Type u_4} [one_hom_class F α α₂] (f : F) : finsupp.map_domain ⇑f 1 = 1
theorem category_theory.is_filtered.sup_objs_exists {C : Type u} [category_theory.category C] [category_theory.is_filtered C] (O : finset C) : ∃ (S : C), ∀ {X : C}, X ∈ O → nonempty (X ⟶ S)
theorem rel_hom.coe_fn_injective {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} : function.injective coe_fn
theorem padic_norm.eq_zpow_of_nonzero (p : ℕ) {q : ℚ} (hq : q ≠ 0) : padic_norm p q = ↑p ^ -padic_val_rat p q
theorem finset.nonempty.of_inv {α : Type u_2} [decidable_eq α] [has_inv α] {s : finset α} : s.nonempty → s⁻¹.nonempty
theorem direct_sum.add_hom_ext {ι : Type v} [dec_ι : decidable_eq ι] {β : ι → Type w} [Π (i : ι), add_comm_monoid (β i)] {γ : Type u_1} [add_monoid γ] ⦃f g : direct_sum ι (λ (i : ι), β i) →+ γ⦄ (H : ∀ (i : ι) (y : β i), ⇑f (⇑(direct_sum.of (λ (i : ι), β i) i) y) = ⇑g (⇑(direct_sum.of (λ (i : ι), β i) i) y)) : f = g
theorem is_add_hom.id {α : Type u} [has_add α] : is_add_hom id
theorem subalgebra.mul_self {R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : S.to_submodule * S.to_submodule = S.to_submodule
theorem generalized_continued_fraction.comp_exact_value_correctness_of_stream_eq_some_aux_comp {K : Type u_1} [linear_ordered_field K] [floor_ring K] {a : K} (b c : K) (fract_a_ne_zero : int.fract a ≠ 0) : (↑⌊a⌋ * b + c) / int.fract a + b = (b * a + c) / int.fract a
theorem convex.mul_sub_le_image_sub_of_le_deriv {D : set ℝ} (hD : convex ℝ D) {f : ℝ → ℝ} (hf : continuous_on f D) (hf' : differentiable_on ℝ f (interior D)) {C : ℝ} (hf'_ge : ∀ (x : ℝ), x ∈ interior D → C ≤ deriv f x) (x : ℝ) (H : x ∈ D) (y : ℝ) (H_1 : y ∈ D) : x ≤ y → C * (y - x) ≤ f y - f x
theorem lie_subalgebra.ideal_in_normalizer {R : Type u_1} {L : Type u_2} [comm_ring R] [lie_ring L] [lie_algebra R L] {H : lie_subalgebra R L} {x y : L} (hx : x ∈ H.normalizer) (hy : y ∈ H) : ⁅x,y⁆ ∈ H
theorem add_monoid_algebra.mv_polynomial_aeval_of_surjective_of_closure {R : Type u_1} {M : Type u_2} [add_comm_monoid M] [comm_semiring R] {S : set M} (hS : add_submonoid.closure S = ⊤) : function.surjective ⇑(mv_polynomial.aeval (λ (s : ↥S), add_monoid_algebra.of' R M ↑s))
theorem measure_theory.measure.exists_subset_measure_lt_top {α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {s : set α} [measure_theory.sigma_finite μ] {r : ennreal} (hs : measurable_set s) (h's : r < ⇑μ s) : ∃ (t : set α), measurable_set t ∧ t ⊆ s ∧ r < ⇑μ t ∧ ⇑μ t < ⊤
theorem nat.min_fac_sq_le_self {n : ℕ} (w : 0 < n) (h : ¬nat.prime n) : n.min_fac ^ 2 ≤ n
theorem squeeze_zero {α : Type u_1} {f g : α → ℝ} {t₀ : filter α} (hf : ∀ (t : α), 0 ≤ f t) (hft : ∀ (t : α), f t ≤ g t) (g0 : filter.tendsto g t₀ (nhds 0)) : filter.tendsto f t₀ (nhds 0)
theorem strict_concave_on.ae_eq_const_or_lt_map_average {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {f : α → E} {g : E → ℝ} [measure_theory.is_finite_measure μ] (hg : strict_concave_on ℝ s g) (hgc : continuous_on g s) (hsc : is_closed s) (hfs : ∀ᵐ (x : α) ∂μ, f x ∈ s) (hfi : measure_theory.integrable f μ) (hgi : measure_theory.integrable (g ∘ f) μ) : f =ᵐ[μ] function.const α (⨍ (x : α), f x ∂μ) ∨ ⨍ (x : α), g (f x) ∂μ < g (⨍ (x : α), f x ∂μ)
theorem measure_theory.simple_func.has_box_integral {ι : Type u} {E : Type v} [fintype ι] [normed_group E] [normed_space ℝ E] (f : measure_theory.simple_func (ι → ℝ) E) (μ : measure_theory.measure (ι → ℝ)) [measure_theory.is_locally_finite_measure μ] (I : box_integral.box ι) (l : box_integral.integration_params) (hl : l.bRiemann = bool.ff) : box_integral.has_integral I l ⇑f μ.to_box_additive.to_smul (measure_theory.simple_func.integral (μ.restrict ↑I) f)
theorem category_theory.grothendieck_topology.arrow_max {C : Type u} [category_theory.category C] {X Y : C} (J : category_theory.grothendieck_topology C) (f : Y ⟶ X) (S : category_theory.sieve X) (hf : ⇑S f) : J.covers S f
theorem strict_concave_on.slope_anti_adjacent {𝕜 : Type u_1} [linear_ordered_field 𝕜] {s : set 𝕜} {f : 𝕜 → 𝕜} (hf : strict_concave_on 𝕜 s f) {x y z : 𝕜} (hx : x ∈ s) (hz : z ∈ s) (hxy : x < y) (hyz : y < z) : (f z - f y) / (z - y) < (f y - f x) / (y - x)
theorem category_theory.has_colimits_of_reflective {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (R : D ⥤ C) [category_theory.reflective R] [category_theory.limits.has_colimits_of_size C] : category_theory.limits.has_colimits_of_size D
theorem measure_theory.map_prod_mul_eq {G : Type u_1} [measurable_space G] [group G] [has_measurable_mul₂ G] (μ ν : measure_theory.measure G) [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] [ν.is_mul_left_invariant] : measure_theory.measure.map (λ (z : G × G), (z.fst, z.fst * z.snd)) (μ.prod ν) = μ.prod ν
theorem add_is_torsion.extension_closed {G : Type u_1} {H : Type u_2} [add_group G] {N : add_subgroup G} [add_group H] {f : G →+ H} (hN : N = f.ker) (tH : add_monoid.is_torsion H) (tN : add_monoid.is_torsion ↥N) : add_monoid.is_torsion G
theorem finsum_mem_finset_product {α : Type u_1} {β : Type u_2} {M : Type u_5} [add_comm_monoid M] (s : finset (α × β)) (f : α × β → M) : finsum (λ (ab : α × β), finsum (λ (h : ab ∈ s), f ab)) = finsum (λ (a : α), finsum (λ (b : β), finsum (λ (h : (a, b) ∈ s), f (a, b))))
theorem matrix.is_diag_one {α : Type u_1} {n : Type u_4} [decidable_eq n] [has_zero α] [has_one α] : 1.is_diag
theorem char_prime_of_ne_zero (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] {p : ℕ} [hp : char_p R p] (p_ne_zero : p ≠ 0) : nat.prime p
theorem pgame.numeric_pow_half (n : ℕ) : (pgame.pow_half n).numeric
theorem euclidean_geometry.dist_sq_eq_dist_sq_add_dist_sq_sub_two_mul_dist_mul_dist_mul_cos_angle {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (p1 p2 p3 : P) : has_dist.dist p1 p3 * has_dist.dist p1 p3 = has_dist.dist p1 p2 * has_dist.dist p1 p2 + has_dist.dist p3 p2 * has_dist.dist p3 p2 - 2 * has_dist.dist p1 p2 * has_dist.dist p3 p2 * real.cos (euclidean_geometry.angle p1 p2 p3)
theorem multilinear_map.map_nonempty {R : Type u} {ι : Type u'} {M₁ : ι → Type v₁} {M₂ : Type v₂} [decidable_eq ι] [ring R] [Π (i : ι), add_comm_monoid (M₁ i)] [add_comm_monoid M₂] [Π (i : ι), module R (M₁ i)] [module R M₂] [nonempty ι] (f : multilinear_map R M₁ M₂) (p : Π (i : ι), submodule R (M₁ i)) : ↑(f.map p).nonempty
theorem subgroup.mul_mem {G : Type u_1} [group G] (H : subgroup G) {x y : G} : x ∈ H → y ∈ H → x * y ∈ H
theorem continuous_map.tendsto_iff_tendsto_locally_uniformly {α : Type u₁} {β : Type u₂} [topological_space α] [uniform_space β] {f : C(α, β)} {ι : Type u₃} {p : filter ι} {F : ι → C(α, β)} [locally_compact_space α] : filter.tendsto F p (nhds f) ↔ tendsto_locally_uniformly (λ (i : ι) (a : α), ⇑(F i) a) ⇑f p
theorem tsum_mul_tsum_of_summable_norm {α : Type u_1} {ι : Type u_4} {ι' : Type u_5} [normed_ring α] [complete_space α] {f : ι → α} {g : ι' → α} (hf : summable (λ (x : ι), ∥f x∥)) (hg : summable (λ (x : ι'), ∥g x∥)) : (∑' (x : ι), f x) * ∑' (y : ι'), g y = ∑' (z : ι × ι'), f z.fst * g z.snd
theorem projectivization.ind {K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] {P : ℙ K V → Prop} (h : ∀ (v : V) (h : v ≠ 0), P (projectivization.mk K v h)) (p : ℙ K V) : P p
theorem measure_theory.ext_on_measurable_space_of_generate_finite {α : Type u_1} (m₀ : measurable_space α) {μ ν : measure_theory.measure α} [measure_theory.is_finite_measure μ] (C : set (set α)) (hμν : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s) {m : measurable_space α} (h : m ≤ m₀) (hA : m = measurable_space.generate_from C) (hC : is_pi_system C) (h_univ : ⇑μ set.univ = ⇑ν set.univ) {s : set α} (hs : measurable_set s) : ⇑μ s = ⇑ν s
theorem witt_vector.mul_n_is_poly (p : ℕ) [hp : fact (nat.prime p)] (n : ℕ) : witt_vector.is_poly p (λ (R : Type u_1) (_Rcr : comm_ring R) (x : witt_vector p R), x * ↑n)
theorem real.inner_le_Lp_mul_Lq_tsum_of_nonneg {ι : Type u} {f g : ι → ℝ} {p q : ℝ} (hpq : p.is_conjugate_exponent q) (hf : ∀ (i : ι), 0 ≤ f i) (hg : ∀ (i : ι), 0 ≤ g i) (hf_sum : summable (λ (i : ι), f i ^ p)) (hg_sum : summable (λ (i : ι), g i ^ q)) : summable (λ (i : ι), f i * g i) ∧ ∑' (i : ι), f i * g i ≤ (∑' (i : ι), f i ^ p) ^ (1 / p) * (∑' (i : ι), g i ^ q) ^ (1 / q)
theorem category_theory.limits.has_limit_cospan_of_has_limit_pair_of_has_limit_parallel_pair {C : Type u} [𝒞 : category_theory.category C] {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) [category_theory.limits.has_limit (category_theory.limits.pair X Y)] [category_theory.limits.has_limit (category_theory.limits.parallel_pair (category_theory.limits.prod.fst ≫ f) (category_theory.limits.prod.snd ≫ g))] : category_theory.limits.has_limit (category_theory.limits.cospan f g)
theorem is_greatest.union {γ : Type w} [linear_order γ] {a b : γ} {s t : set γ} (ha : is_greatest s a) (hb : is_greatest t b) : is_greatest (s ∪ t) (linear_order.max a b)
theorem polynomial.chebyshev.U_complex_cos (θ : ℂ) (n : ℕ) : polynomial.eval (complex.cos θ) (polynomial.chebyshev.U ℂ n) * complex.sin θ = complex.sin ((↑n + 1) * θ)
theorem algebra.finite_presentation.of_surjective {R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [algebra R A] [comm_ring B] [algebra R B] {f : A →ₐ[R] B} (hf : function.surjective ⇑f) (hker : f.to_ring_hom.ker.fg) (hfp : algebra.finite_presentation R A) : algebra.finite_presentation R B
theorem strict_concave_on_iff_slope_strict_anti_adjacent {𝕜 : Type u_1} [linear_ordered_field 𝕜] {s : set 𝕜} {f : 𝕜 → 𝕜} : strict_concave_on 𝕜 s f ↔ convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) < (f y - f x) / (y - x)
theorem has_dvd.dvd.trans {α : Type u_1} [semigroup α] {a b c : α} : a ∣ b → b ∣ c → a ∣ c
theorem category_theory.limits.has_initial_of_unique {C : Type u₁} [category_theory.category C] (X : C) [h : Π (Y : C), unique (X ⟶ Y)] : category_theory.limits.has_initial C
theorem add_units.mk_semiconj_by {M : Type u} [add_monoid M] (u : add_units M) (x : M) : add_semiconj_by ↑u x (↑u + x + ↑-u)
theorem bounded_continuous_function.dist_le_two_norm {α : Type u} {β : Type v} [topological_space α] [semi_normed_group β] (f : bounded_continuous_function α β) (x y : α) : has_dist.dist (⇑f x) (⇑f y) ≤ 2 * ∥f∥
theorem orthonormal.eq_iff_norm_eq_and_oangle_eq_zero {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x y : V) : x = y ↔ ∥x∥ = ∥y∥ ∧ hb.oangle x y = 0
theorem measure_theory.lintegral_liminf_le' {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : ℕ → α → ennreal} (h_meas : ∀ (n : ℕ), ae_measurable (f n) μ) : ∫⁻ (a : α), filter.at_top.liminf (λ (n : ℕ), f n a) ∂μ ≤ filter.at_top.liminf (λ (n : ℕ), ∫⁻ (a : α), f n a ∂μ)
theorem euclidean_geometry.exists_unique_dist_eq_of_insert {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} [complete_space ↥(s.direction)] {ps : set P} (hnps : ps.nonempty) {p : P} (hps : ps ⊆ ↑s) (hp : p ∉ s) (hu : ∃! (cccr : P × ℝ), cccr.fst ∈ s ∧ ∀ (p1 : P), p1 ∈ ps → has_dist.dist p1 cccr.fst = cccr.snd) : ∃! (cccr₂ : P × ℝ), cccr₂.fst ∈ affine_span ℝ (has_insert.insert p ↑s) ∧ ∀ (p1 : P), p1 ∈ has_insert.insert p ps → has_dist.dist p1 cccr₂.fst = cccr₂.snd
theorem module.End.generalized_eigenspace_restrict {R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (p : submodule R M) (k : ℕ) (μ : R) (hfp : ∀ (x : M), x ∈ p → ⇑f x ∈ p) : ⇑(module.End.generalized_eigenspace (linear_map.restrict f hfp) μ) k = submodule.comap p.subtype (⇑(f.generalized_eigenspace μ) k)
theorem modular_group.exists_max_im (z : upper_half_plane) : ∃ (g : matrix.special_linear_group (fin 2) ℤ), ∀ (g' : matrix.special_linear_group (fin 2) ℤ), (g' • z).im ≤ (g • z).im
theorem formal_multilinear_series.comp_coeff_zero {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [comm_ring 𝕜] [add_comm_group E] [add_comm_group F] [add_comm_group G] [module 𝕜 E] [module 𝕜 F] [module 𝕜 G] [topological_space E] [topological_space F] [topological_space G] [topological_add_group E] [has_continuous_const_smul 𝕜 E] [topological_add_group F] [has_continuous_const_smul 𝕜 F] [topological_add_group G] [has_continuous_const_smul 𝕜 G] (q : formal_multilinear_series 𝕜 F G) (p : formal_multilinear_series 𝕜 E F) (v : fin 0 → E) (v' : fin 0 → F) : ⇑(q.comp p 0) v = ⇑(q 0) v'
theorem box_integral.integrable.dist_integral_sum_le_of_mem_base_set {ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} {c₁ c₂ : nnreal} {ε₁ ε₂ : ℝ} {π₁ π₂ : box_integral.tagged_prepartition I} (h : box_integral.integrable I l f vol) (hpos₁ : 0 < ε₁) (hpos₂ : 0 < ε₂) (h₁ : l.mem_base_set I c₁ (h.convergence_r ε₁ c₁) π₁) (h₂ : l.mem_base_set I c₂ (h.convergence_r ε₂ c₂) π₂) (HU : π₁.Union = π₂.Union) : has_dist.dist (box_integral.integral_sum f vol π₁) (box_integral.integral_sum f vol π₂) ≤ ε₁ + ε₂
theorem ideal.polynomial_not_is_field {R : Type u} [ring R] : ¬is_field (polynomial R)
theorem continuous.ae_strongly_measurable {α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [topological_space β] {f : α → β} [topological_space α] [opens_measurable_space α] [topological_space.pseudo_metrizable_space β] [second_countable_topology_either α β] (hf : continuous f) : measure_theory.ae_strongly_measurable f μ
theorem is_fraction_ring.ideal_span_singleton_map_subset (R : Type u_1) [comm_ring R] {S : Type u_2} [comm_ring S] [algebra R S] {K : Type u_5} {L : Type u_3} [is_domain R] [is_domain S] [field K] [field L] [algebra R K] [algebra R L] [algebra S L] [is_integral_closure S R L] [is_fraction_ring S L] [algebra K L] [is_scalar_tower R S L] [is_scalar_tower R K L] {a : S} {b : set S} (alg : algebra.is_algebraic R L) (inj : function.injective ⇑(algebra_map R L)) (h : ↑(ideal.span {a}) ⊆ ↑(submodule.span R b)) : ↑(ideal.span {⇑(algebra_map S L) a}) ⊆ ↑(submodule.span K (⇑(algebra_map S L) '' b))
theorem modular_group.tendsto_lc_row0 {cd : fin 2 → ℤ} (hcd : is_coprime (cd 0) (cd 1)) : filter.tendsto (λ (g : {g // ↑g 1 = cd}), ⇑(modular_group.lc_row0 cd) ↑↑g) filter.cofinite (filter.cocompact ℝ)
theorem measure_theory.analytic_set.Inter {α : Type u_1} [topological_space α] {ι : Type u_2} [hι : nonempty ι] [encodable ι] [t2_space α] {s : ι → set α} (hs : ∀ (n : ι), measure_theory.analytic_set (s n)) : measure_theory.analytic_set (⋂ (n : ι), s n)
theorem measurable.lintegral_prod_left' {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} [measure_theory.sigma_finite μ] {f : α × β → ennreal} (hf : measurable f) : measurable (λ (y : β), ∫⁻ (x : α), f (x, y) ∂μ)
theorem equiv.perm.perm_congr_eq_mul {α : Type u} (e p : equiv.perm α) : ⇑(equiv.perm_congr e) p = e * p * e⁻¹
theorem continuous_of_uniform_approx_of_continuous {α : Type u_1} {β : Type u_2} [uniform_space β] {f : α → β} [topological_space α] (L : ∀ (u : set (β × β)), u ∈ uniformity β → (∃ (F : α → β), continuous F ∧ ∀ (y : α), (f y, F y) ∈ u)) : continuous f
theorem list.sorted_insertion_sort {α : Type uu} (r : α → α → Prop) [decidable_rel r] [is_total α r] [is_trans α r] (l : list α) : list.sorted r (list.insertion_sort r l)
theorem affine_subspace.mem_top (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (p : P) : p ∈ ⊤
theorem midpoint_unique (R : Type u_1) {V : Type u_2} {P : Type u_4} [ring R] [invertible 2] [add_comm_group V] [module R V] [add_torsor V P] (R' : Type u_3) [ring R'] [invertible 2] [module R' V] (x y : P) : midpoint R x y = midpoint R' x y
theorem cont_diff_at.comp {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {f : E → F} {g : F → G} {n : with_top ℕ} (x : E) (hg : cont_diff_at 𝕜 n g (f x)) (hf : cont_diff_at 𝕜 n f x) : cont_diff_at 𝕜 n (g ∘ f) x
theorem has_deriv_at.real_of_complex {e : ℂ → ℂ} {e' : ℂ} {z : ℝ} (h : has_deriv_at e e' ↑z) : has_deriv_at (λ (x : ℝ), (e ↑x).re) e'.re z
theorem finprod_mem_union_inter' {α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M} {s t : set α} (hs : (s ∩ function.mul_support f).finite) (ht : (t ∩ function.mul_support f).finite) : finprod (λ (i : α), finprod (λ (H : i ∈ s ∪ t), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ s ∩ t), f i)) = finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ t), f i))
theorem ring_hom.codomain_trivial_iff_range_eq_singleton_zero {α : Type u_2} {β : Type u_3} {rα : non_assoc_semiring α} {rβ : non_assoc_semiring β} (f : α →+* β) : 0 = 1 ↔ set.range ⇑f = {0}
theorem affine_subspace.coe_direction_eq_vsub_set_right {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p : P} (hp : p ∈ s) : ↑(s.direction) = (λ (_x : P), _x -ᵥ p) '' ↑s
theorem not_same_ray_iff_norm_add_lt {E : Type u_2} [normed_group E] [normed_space ℝ E] [strict_convex_space ℝ E] {x y : E} : ¬same_ray ℝ x y ↔ ∥x + y∥ < ∥x∥ + ∥y∥
theorem orientation.oangle_smul_right_of_neg {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x y : V) {r : ℝ} (hr : r < 0) : o.oangle x (r • y) = o.oangle x (-y)
theorem norm_tsum_le_tsum_norm {ι : Type u_1} {E : Type u_3} [semi_normed_group E] {f : ι → E} (hf : summable (λ (i : ι), ∥f i∥)) : ∥∑' (i : ι), f i∥ ≤ ∑' (i : ι), ∥f i∥
theorem simplex_category.δ_comp_δ_self {n : ℕ} {i : fin (n + 2)} : simplex_category.δ i ≫ simplex_category.δ (⇑fin.cast_succ i) = simplex_category.δ i ≫ simplex_category.δ i.succ
theorem uniform_space.completion.continuous_dist {α : Type u} {β : Type v} [pseudo_metric_space α] [topological_space β] {f g : β → uniform_space.completion α} (hf : continuous f) (hg : continuous g) : continuous (λ (x : β), has_dist.dist (f x) (g x))
theorem add_submonoid.closure_induction' {M : Type u_1} [add_zero_class M] (s : set M) {p : Π (x : M), x ∈ add_submonoid.closure s → Prop} (Hs : ∀ (x : M) (h : x ∈ s), p x _) (H1 : p 0 _) (Hmul : ∀ (x : M) (hx : x ∈ add_submonoid.closure s) (y : M) (hy : y ∈ add_submonoid.closure s), p x hx → p y hy → p (x + y) _) {x : M} (hx : x ∈ add_submonoid.closure s) : p x hx
theorem function.inv_on_fixed_pts_comp {α : Type u} {β : Type v} (f : α → β) (g : β → α) : set.inv_on f g (function.fixed_points (f ∘ g)) (function.fixed_points (g ∘ f))
theorem measure_theory.measure_eq_sub_vadd {G : Type u_1} [measurable_space G] [add_group G] [has_measurable_add₂ G] (μ ν : measure_theory.measure G) [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] {E : set G} [has_measurable_neg G] [μ.is_add_left_invariant] [ν.is_add_left_invariant] (hE : measurable_set E) (h2E : ⇑ν E ≠ 0) (h3E : ⇑ν E ≠ ⊤) : μ = (⇑μ E / ⇑ν E) • ν
theorem polynomial.contraction_degree_eq_or_insep {F : Type} [field F] (q : ℕ) [hq : fact (nat.prime q)] [char_p F q] (g g' : polynomial F) (m m' : ℕ) (h_expand : ⇑(polynomial.expand F (q ^ m)) g = ⇑(polynomial.expand F (q ^ m')) g') (hg : g.separable) (hg' : g'.separable) : g.nat_degree = g'.nat_degree
theorem int.dvd_sub_of_mod_eq {a b c : ℤ} (h : a % b = c) : b ∣ a - c
theorem metric.inf_dist_le_Hausdorff_dist_of_mem {α : Type u} [pseudo_metric_space α] {s t : set α} {x : α} (hx : x ∈ s) (fin : emetric.Hausdorff_edist s t ≠ ⊤) : metric.inf_dist x t ≤ metric.Hausdorff_dist s t
theorem is_localization.card_le {R : Type u} [comm_ring R] (S : submonoid R) {L : Type u} [comm_ring L] [algebra R L] [is_localization S L] : cardinal.mk L ≤ cardinal.mk R
theorem tendsto_locally_uniformly_on_iff_tendsto_uniformly_on_of_compact {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {s : set α} {p : filter ι} [topological_space α] (hs : is_compact s) : tendsto_locally_uniformly_on F f p s ↔ tendsto_uniformly_on F f p s
theorem Top.presheaf.compatible_iff_left_res_eq_right_res {X : Top} (F : Top.presheaf (Type v) X) {ι : Type v} (U : ι → topological_space.opens ↥X) (sf : Top.presheaf.sheaf_condition_equalizer_products.pi_opens F U) : F.is_compatible U ((F.pi_opens_iso_sections_family U).hom sf) ↔ Top.presheaf.sheaf_condition_equalizer_products.left_res F U sf = Top.presheaf.sheaf_condition_equalizer_products.right_res F U sf
theorem fin.univ_cast_succ (n : ℕ) : finset.univ = finset.cons (fin.last n) (finset.map fin.cast_succ.to_embedding finset.univ) _
theorem sub_div_sub_smul_slope_add_sub_div_sub_smul_slope {k : Type u_1} {E : Type u_2} {PE : Type u_3} [field k] [add_comm_group E] [module k E] [add_torsor E PE] (f : k → PE) (a b c : k) : ((b - a) / (c - a)) • slope f a b + ((c - b) / (c - a)) • slope f b c = slope f a c
theorem vector_span_empty (k : Type u_1) {V : Type u_2} (P : Type u_3) [ring k] [add_comm_group V] [module k V] [add_torsor V P] : vector_span k ∅ = ⊥
theorem continuous_linear_map.is_closed_image_coe_of_bounded_of_weak_closed {𝕜 : Type u_1} {𝕜₂ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {E' : Type u_10} [semi_normed_group E'] [normed_space 𝕜 E'] [ring_hom_isometric σ₁₂] {s : set (E' →SL[σ₁₂] F)} (hb : metric.bounded s) (hc : ∀ (f : E' →SL[σ₁₂] F), ⇑f ∈ closure (coe_fn '' s) → f ∈ s) : is_closed (coe_fn '' s)
theorem composition.sigma_eq_iff_blocks_eq {c c' : Σ (n : ℕ), composition n} : c = c' ↔ c.snd.blocks = c'.snd.blocks
theorem has_dvd.dvd.nat_cast {α : Type u_1} [semiring α] {m n : ℕ} (h : m ∣ n) : ↑m ∣ ↑n
theorem matrix.adjugate_mul_distrib {n : Type u} [decidable_eq n] [fintype n] {α : Type v} [comm_ring α] (A B : matrix n n α) : (A.mul B).adjugate = B.adjugate.mul A.adjugate
theorem monoid_with_zero_hom.ext_rat {M : Type u_4} [group_with_zero M] {f g : ℚ →*₀ M} (same_on_int : f.comp (int.cast_ring_hom ℚ).to_monoid_with_zero_hom = g.comp (int.cast_ring_hom ℚ).to_monoid_with_zero_hom) : f = g
theorem fib_rec_char_poly_eq {β : Type u_1} [comm_ring β] : fib_rec.char_poly = polynomial.X ^ 2 - (polynomial.X + 1)
theorem category_theory.abelian.pseudoelement.pseudo_zero_aux {C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (Q : C) (f : category_theory.over P) : f ≈ ↑0 ↔ f.hom = 0
theorem pmf.bind_on_support_eq_bind {α : Type u_1} {β : Type u_2} (p : pmf α) (f : α → pmf β) : p.bind_on_support (λ (a : α) (_x : a ∈ p.support), f a) = p.bind f
theorem uv.is_compressed_self {α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u : α) (s : finset α) : uv.is_compressed u u s
theorem filter.tendsto.const_mul_at_top {α : Type u_3} {β : Type u_4} [linear_ordered_field α] {l : filter β} {f : β → α} {r : α} (hr : 0 < r) (hf : filter.tendsto f l filter.at_top) : filter.tendsto (λ (x : β), r * f x) l filter.at_top
theorem add_submonoid.add_mem {M : Type u_1} [add_zero_class M] (S : add_submonoid M) {x y : M} : x ∈ S → y ∈ S → x + y ∈ S
theorem minpoly.coeff_zero_ne_zero {A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) (h : x ≠ 0) : (minpoly A x).coeff 0 ≠ 0
theorem monotone.set_prod {α : Type u_1} {β : Type u_2} {γ : Type u_3} [preorder α] {f : α → set β} {g : α → set γ} (hf : monotone f) (hg : monotone g) : monotone (λ (x : α), f x ×ˢ g x)
theorem emetric.mem_iff_inf_edist_zero_of_closed {α : Type u} [pseudo_emetric_space α] {x : α} {s : set α} (h : is_closed s) : x ∈ s ↔ emetric.inf_edist x s = 0
theorem hall_matchings_on.nonempty {ι : Type u} {α : Type v} [decidable_eq α] (t : ι → finset α) (h : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card) (ι' : finset ι) : nonempty ↥(hall_matchings_on t ι')
theorem affine.triangle.eq_orthocenter_of_forall_mem_altitude {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {t : affine.triangle ℝ P} {i₁ i₂ : fin 3} {p : P} (h₁₂ : i₁ ≠ i₂) (h₁ : p ∈ affine.simplex.altitude t i₁) (h₂ : p ∈ affine.simplex.altitude t i₂) : p = t.orthocenter
theorem inner_eq_sum_norm_sq_div_four {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) : has_inner.inner x y = (↑∥x + y∥ ^ 2 - ↑∥x - y∥ ^ 2 + (↑∥x - is_R_or_C.I • y∥ ^ 2 - ↑∥x + is_R_or_C.I • y∥ ^ 2) * is_R_or_C.I) / 4
theorem padic_norm.values_discrete (p : ℕ) {q : ℚ} (hq : q ≠ 0) : ∃ (z : ℤ), padic_norm p q = ↑p ^ -z
theorem inner_product_geometry.inner_eq_zero_iff_angle_eq_pi_div_two {V : Type u_1} [inner_product_space ℝ V] (x y : V) : has_inner.inner x y = 0 ↔ inner_product_geometry.angle x y = real.pi / 2
theorem convex_on_of_slope_mono_adjacent {𝕜 : Type u_1} [linear_ordered_field 𝕜] {s : set 𝕜} {f : 𝕜 → 𝕜} (hs : convex 𝕜 s) (hf : ∀ {x y z : 𝕜}, x ∈ s → z ∈ s → x < y → y < z → (f y - f x) / (y - x) ≤ (f z - f y) / (z - y)) : convex_on 𝕜 s f
theorem affine_independent.affine_span_eq_of_le_of_card_eq_finrank_add_one {k : Type u_1} {V : Type u_2} {P : Type u_3} {ι : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype ι] {p : ι → P} (hi : affine_independent k p) {sp : affine_subspace k P} [finite_dimensional k ↥(sp.direction)] (hle : affine_span k (set.range p) ≤ sp) (hc : fintype.card ι = finite_dimensional.finrank k ↥(sp.direction) + 1) : affine_span k (set.range p) = sp
theorem exists_unique_zsmul_near_of_pos {α : Type u_1} [linear_ordered_add_comm_group α] [archimedean α] {a : α} (ha : 0 < a) (g : α) : ∃! (k : ℤ), k • a ≤ g ∧ g < (k + 1) • a
theorem local_ring.local_hom_tfae {R : Type u} {S : Type v} [comm_semiring R] [local_ring R] [comm_semiring S] [local_ring S] (f : R →+* S) : [is_local_ring_hom f, ⇑f '' (local_ring.maximal_ideal R).carrier ⊆ ↑(local_ring.maximal_ideal S), ideal.map f (local_ring.maximal_ideal R) ≤ local_ring.maximal_ideal S, local_ring.maximal_ideal R ≤ ideal.comap f (local_ring.maximal_ideal S), ideal.comap f (local_ring.maximal_ideal S) = local_ring.maximal_ideal R].tfae
theorem box_integral.prepartition.eventually_not_disjoint_imp_le_of_mem_split_many {ι : Type u_1} [fintype ι] (s : finset (box_integral.box ι)) : ∀ᶠ (t : finset (ι × ℝ)) in filter.at_top, ∀ (I J : box_integral.box ι), J ∈ s → ∀ (J' : box_integral.box ι), J' ∈ box_integral.prepartition.split_many I t → ¬disjoint ↑J ↑J' → J' ≤ J
theorem linear_map.injective_iff_surjective {K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {f : V →ₗ[K] V} : function.injective ⇑f ↔ function.surjective ⇑f
theorem category_theory.abelian.pseudoelement.pseudo_exact_of_exact {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q R : C} {f : P ⟶ Q} {g : Q ⟶ R} (h : category_theory.exact f g) : (∀ (a : ↥P), ⇑g (⇑f a) = 0) ∧ ∀ (b : ↥Q), ⇑g b = 0 → (∃ (a : ↥P), ⇑f a = b)
theorem metric.bounded.mono {α : Type u} [pseudo_metric_space α] {s t : set α} (incl : s ⊆ t) : metric.bounded t → metric.bounded s
theorem measurable_set.exists_lt_is_compact_of_ne_top {α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [μ.regular] ⦃A : set α⦄ (hA : measurable_set A) (h'A : ⇑μ A ≠ ⊤) {r : ennreal} (hr : r < ⇑μ A) : ∃ (K : set α) (H : K ⊆ A), is_compact K ∧ r < ⇑μ K
theorem finset.eq_of_card_le_one_of_sum_eq {β : Type u} {α : Type v} [add_comm_monoid β] {s : finset α} (hc : s.card ≤ 1) {f : α → β} {b : β} (h : s.sum (λ (x : α), f x) = b) (x : α) (H : x ∈ s) : f x = b
theorem fin.succ_above_ne {n : ℕ} (p : fin (n + 1)) (i : fin n) : ⇑(p.succ_above) i ≠ p
theorem exists_subset_Union_closure_subset {ι : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : ι → set X} {s : set X} (hs : is_closed s) (uo : ∀ (i : ι), is_open (u i)) (uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite) (us : s ⊆ ⋃ (i : ι), u i) : ∃ (v : ι → set X), s ⊆ set.Union v ∧ (∀ (i : ι), is_open (v i)) ∧ ∀ (i : ι), closure (v i) ⊆ u i
theorem is_of_fin_add_order.neg {G : Type u} [add_group G] {x : G} (hx : is_of_fin_add_order x) : is_of_fin_add_order (-x)
theorem category_theory.grothendieck_topology.close_is_closed {C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : J₁.is_closed (J₁.close S)
theorem linear_order.concave_on_of_lt {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [ordered_add_comm_monoid β] [module 𝕜 E] [module 𝕜 β] [linear_order E] {s : set E} {f : E → β} (hs : convex 𝕜 s) (hf : ∀ ⦃x y : E⦄, x ∈ s → y ∈ s → x < y → ∀ ⦃a b : 𝕜⦄, 0 < a → 0 < b → a + b = 1 → a • f x + b • f y ≤ f (a • x + b • y)) : concave_on 𝕜 s f
theorem measure_theory.induced_outer_measure_union_of_false_of_nonempty_inter {α : Type u_1} {P : set α → Prop} {m : Π (s : set α), P s → ennreal} {P0 : P ∅} {m0 : m ∅ P0 = 0} {s t : set α} (h : ∀ (u : set α), (s ∩ u).nonempty → (t ∩ u).nonempty → ¬P u) : ⇑(measure_theory.induced_outer_measure m P0 m0) (s ∪ t) = ⇑(measure_theory.induced_outer_measure m P0 m0) s + ⇑(measure_theory.induced_outer_measure m P0 m0) t
theorem colex.hom_fin_lt_iff {n : ℕ} (A B : finset (fin n)) : (finset.image (λ (i : fin n), ↑i) A).to_colex < (finset.image (λ (i : fin n), ↑i) B).to_colex ↔ A.to_colex < B.to_colex
theorem measure_theory.integral_integral_sub' {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] ⦃f g : α × β → E⦄ (hf : measure_theory.integrable f (μ.prod ν)) (hg : measure_theory.integrable g (μ.prod ν)) : ∫ (x : α), ∫ (y : β), (f - g) (x, y) ∂ν ∂μ = ∫ (x : α), ∫ (y : β), f (x, y) ∂ν ∂μ - ∫ (x : α), ∫ (y : β), g (x, y) ∂ν ∂μ
theorem measure_theory.measure_Union_eq_supr {α : Type u_1} {ι : Type u_5} {m : measurable_space α} {μ : measure_theory.measure α} [encodable ι] {s : ι → set α} (hd : directed has_subset.subset s) : ⇑μ (⋃ (i : ι), s i) = ⨆ (i : ι), ⇑μ (s i)
theorem matrix.det_from_blocks₁₁ {m : Type u} {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] [fintype m] [decidable_eq m] (A : matrix m m α) (B : matrix m n α) (C : matrix n m α) (D : matrix n n α) [invertible A] : (matrix.from_blocks A B C D).det = A.det * (D - (C.mul (⅟ A)).mul B).det
theorem measure_theory.submartingale.expected_stopped_value_mono {α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {𝒢 : measure_theory.filtration ℕ m0} [measure_theory.sigma_finite_filtration μ 𝒢] {f : ℕ → α → ℝ} (hf : measure_theory.submartingale f 𝒢 μ) {τ π : α → ℕ} (hτ : measure_theory.is_stopping_time 𝒢 τ) (hπ : measure_theory.is_stopping_time 𝒢 π) (hle : τ ≤ π) {N : ℕ} (hbdd : ∀ (x : α), π x ≤ N) : ∫ (x : α), measure_theory.stopped_value f τ x ∂μ ≤ ∫ (x : α), measure_theory.stopped_value f π x ∂μ
theorem submonoid.multiset_prod_mem {M : Type u_1} [comm_monoid M] (S : submonoid M) (m : multiset M) (hm : ∀ (a : M), a ∈ m → a ∈ S) : m.prod ∈ S
theorem vector_span_image_eq_span_vsub_set_right_ne (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} (p : ι → P) {s : set ι} {i : ι} (hi : i ∈ s) : vector_span k (p '' s) = submodule.span k ((λ (_x : P), _x -ᵥ p i) '' (p '' (s  {i})))
theorem category_theory.triangulated.pretriangulated.triangulated_functor.map_distinguished {C : Type u₁} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C ℤ] [category_theory.preadditive C] [∀ (n : ℤ), (category_theory.shift_functor C n).additive] {D : Type u₂} [category_theory.category D] [category_theory.limits.has_zero_object D] [category_theory.has_shift D ℤ] [category_theory.preadditive D] [∀ (n : ℤ), (category_theory.shift_functor D n).additive] [category_theory.triangulated.pretriangulated C] [category_theory.triangulated.pretriangulated D] (F : category_theory.triangulated.pretriangulated.triangulated_functor C D) (T : category_theory.triangulated.triangle C) (h : T ∈ dist_triang C) : F.map_triangle.obj T ∈ dist_triang D
theorem nat.factorization_mul_support_of_coprime {a b : ℕ} (hab : a.coprime b) : (a * b).factorization.support = a.factorization.support ∪ b.factorization.support
theorem module.End.has_generalized_eigenvalue_iff_has_eigenvalue {R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {μ : R} {k : ℕ} (hk : 0 < k) : f.has_generalized_eigenvalue μ k ↔ f.has_eigenvalue μ
theorem euclidean_geometry.angle_right_midpoint_eq_pi_div_two_of_dist_eq {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : has_dist.dist p3 p1 = has_dist.dist p3 p2) : euclidean_geometry.angle p3 (midpoint ℝ p1 p2) p2 = real.pi / 2
theorem affine_span_eq_affine_span_line_map_units {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] [nontrivial k] {s : set P} {p : P} (hp : p ∈ s) (w : ↥s → kˣ) : affine_span k (set.range (λ (q : ↥s), ⇑(affine_map.line_map p ↑q) ↑(w q))) = affine_span k s
theorem norm_sub_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero {F : Type u_3} [inner_product_space ℝ F] (x y : F) : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ ↔ has_inner.inner x y = 0
theorem antitone.pairwise_disjoint_on_Ico_pred {α : Type u_1} {β : Type u_2} [linear_order α] [pred_order α] [preorder β] {f : α → β} (hf : antitone f) : pairwise (disjoint on λ (n : α), set.Ico (f n) (f (order.pred n)))
theorem gaussian_int.prime_iff_mod_four_eq_three_of_nat_prime (p : ℕ) [hp : fact (nat.prime p)] : prime ↑p ↔ p % 4 = 3
theorem inner_product_geometry.angle_smul_right_of_neg {V : Type u_1} [inner_product_space ℝ V] (x y : V) {r : ℝ} (hr : r < 0) : inner_product_geometry.angle x (r • y) = inner_product_geometry.angle x (-y)
theorem eventually_nhds_iff {α : Type u} [topological_space α] {a : α} {p : α → Prop} : (∀ᶠ (x : α) in nhds a, p x) ↔ ∃ (t : set α), (∀ (x : α), x ∈ t → p x) ∧ is_open t ∧ a ∈ t
theorem subgroup.commutator_commutator_eq_bot_of_rotate {G : Type u_1} [group G] {H₁ H₂ H₃ : subgroup G} (h1 : ⁅⁅H₂,H₃⁆,H₁⁆ = ⊥) (h2 : ⁅⁅H₃,H₁⁆,H₂⁆ = ⊥) : ⁅⁅H₁,H₂⁆,H₃⁆ = ⊥
theorem filter.eventually.eventually_nhds {α : Type u} [topological_space α] {p : α → Prop} {a : α} (h : ∀ᶠ (y : α) in nhds a, p y) : ∀ᶠ (y : α) in nhds a, ∀ᶠ (x : α) in nhds y, p x
theorem edist_le_of_edist_le_geometric_two_of_tendsto {α : Type u_1} [pseudo_emetric_space α] (C : ennreal) {f : ℕ → α} (hu : ∀ (n : ℕ), has_edist.edist (f n) (f (n + 1)) ≤ C / 2 ^ n) {a : α} (ha : filter.tendsto f filter.at_top (nhds a)) (n : ℕ) : has_edist.edist (f n) a ≤ 2 * C / 2 ^ n
theorem minpoly.one (A : Type u_1) (B : Type u_2) [field A] [ring B] [algebra A B] [nontrivial B] : minpoly A 1 = polynomial.X - 1
theorem cont_diff.fst {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {n : with_top ℕ} {f : E → F × G} (hf : cont_diff 𝕜 n f) : cont_diff 𝕜 n (λ (x : E), (f x).fst)
theorem is_unit_iff_not_dvd_char (R : Type u_1) [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : is_unit ↑p ↔ ¬p ∣ ring_char R
theorem category_theory.idempotents.is_idempotent_complete_iff_idempotents_have_kernels (C : Type u_1) [category_theory.category C] [category_theory.preadditive C] : category_theory.is_idempotent_complete C ↔ ∀ (X : C) (p : X ⟶ X), p ≫ p = p → category_theory.limits.has_kernel p
theorem measure_theory.integral_eq_zero_of_add_right_eq_neg {G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure G} {f : G → E} {g : G} [add_group G] [has_measurable_add G] [μ.is_add_right_invariant] (hf' : ∀ (x : G), f (x + g) = -f x) : ∫ (x : G), f x ∂μ = 0
theorem filter.map_coe_Iic_at_bot {α : Type u_3} [semilattice_inf α] (a : α) : filter.map coe filter.at_bot = filter.at_bot
theorem eckmann_hilton.mul_assoc {X : Type u} {m₁ m₂ : X → X → X} {e₁ e₂ : X} (h₁ : eckmann_hilton.is_unital m₁ e₁) (h₂ : eckmann_hilton.is_unital m₂ e₂) (distrib : ∀ (a b c d : X), m₁ (m₂ a b) (m₂ c d) = m₂ (m₁ a c) (m₁ b d)) : is_associative X m₂
theorem dense.of_closure {α : Type u} [topological_space α] {s : set α} : dense (closure s) → dense s
theorem is_integrally_closed_iff {R : Type u_1} [comm_ring R] [is_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] : is_integrally_closed R ↔ ∀ {x : K}, is_integral R x → (∃ (y : R), ⇑(algebra_map R K) y = x)
theorem category_theory.is_pullback.paste_horiz {C : Type u₁} [category_theory.category C] {X₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₁₂ : X₁₂ ⟶ X₁₃} {h₂₁ : X₂₁ ⟶ X₂₂} {h₂₂ : X₂₂ ⟶ X₂₃} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₁₃ : X₁₃ ⟶ X₂₃} (s : category_theory.is_pullback h₁₁ v₁₁ v₁₂ h₂₁) (t : category_theory.is_pullback h₁₂ v₁₂ v₁₃ h₂₂) : category_theory.is_pullback (h₁₁ ≫ h₁₂) v₁₁ v₁₃ (h₂₁ ≫ h₂₂)
theorem continuous_multilinear_map.op_norm_zero_iff {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : continuous_multilinear_map 𝕜 E G) : ∥f∥ = 0 ↔ f = 0
theorem linear_independent.comp {ι : Type u_1} {ι' : Type u_2} {R : Type u_3} {M : Type u_5} {v : ι → M} [semiring R] [add_comm_monoid M] [module R M] (h : linear_independent R v) (f : ι' → ι) (hf : function.injective f) : linear_independent R (v ∘ f)
theorem is_locally_constant.desc {X : Type u_1} [topological_space X] {α : Type u_2} {β : Type u_3} (f : X → α) (g : α → β) (h : is_locally_constant (g ∘ f)) (inj : function.injective g) : is_locally_constant f
theorem submodule.span_smul_eq_of_is_unit {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (s : set M) (r : R) (hr : is_unit r) : submodule.span R (r • s) = submodule.span R s
theorem csupr_le {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), f x ≤ c) : supr f ≤ c
theorem is_preconnected_iff_subset_of_disjoint {α : Type u} [topological_space α] {s : set α} : is_preconnected s ↔ ∀ (u v : set α), is_open u → is_open v → s ⊆ u ∪ v → s ∩ (u ∩ v) = ∅ → s ⊆ u ∨ s ⊆ v
theorem continuous_map.to_Lp_norm_le {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} {p : ennreal} (μ : measure_theory.measure α) [normed_group E] [topological_space α] [borel_space α] [second_countable_topology_either α E] [compact_space α] [measure_theory.is_finite_measure μ] {𝕜 : Type u_5} [fact (1 ≤ p)] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] : ∥continuous_map.to_Lp p μ 𝕜∥ ≤ ↑(measure_theory.measure_univ_nnreal μ) ^ (p.to_real)⁻¹
theorem is_local_min.fderiv_eq_zero {E : Type u} [normed_group E] [normed_space ℝ E] {f : E → ℝ} {a : E} (h : is_local_min f a) : fderiv ℝ f a = 0
theorem norm_mk_zero {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) : ∥0∥ = 0
theorem seminorm.convex_on {𝕜 : Type u_3} {E : Type u_4} [normed_field 𝕜] [add_comm_group E] [normed_space ℝ 𝕜] [module 𝕜 E] [has_scalar ℝ E] [is_scalar_tower ℝ 𝕜 E] (p : seminorm 𝕜 E) : convex_on ℝ set.univ ⇑p
theorem nnreal.geom_mean_le_arith_mean2_weighted (w₁ w₂ p₁ p₂ : nnreal) : w₁ + w₂ = 1 → p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂
theorem topological_space.countable_cover_nhds {α : Type u} [t : topological_space α] [topological_space.second_countable_topology α] {f : α → set α} (hf : ∀ (x : α), f x ∈ nhds x) : ∃ (s : set α), s.countable ∧ (⋃ (x : α) (H : x ∈ s), f x) = set.univ
theorem int.dvd_of_dvd_mul_right_of_gcd_one {a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd b = 1) : a ∣ c
theorem real.sq_sin_pi_div_three  : real.sin (real.pi / 3) ^ 2 = 3 / 4
theorem setoid.classes_inj {α : Type u_1} {r₁ r₂ : setoid α} : r₁ = r₂ ↔ r₁.classes = r₂.classes
theorem alternating_group.normal_closure_fin_rotate_five  : subgroup.normal_closure {⟨fin_rotate 5, _⟩} = ⊤
theorem linear_map.aeval_self_charpoly {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M →ₗ[R] M) : ⇑(polynomial.aeval f) f.charpoly = 0
theorem linear_equiv.det_conj {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {M' : Type u_3} [add_comm_group M'] [module R M'] (f : M ≃ₗ[R] M) (e : M ≃ₗ[R] M') : ⇑linear_equiv.det ((e.symm.trans f).trans e) = ⇑linear_equiv.det f
theorem setoid.eq_of_mem_eqv_class {α : Type u_1} {c : set (set α)} (H : ∀ (a : α), ∃! (b : set α) (H : b ∈ c), a ∈ b) {x : α} {b b' : set α} (hc : b ∈ c) (hb : x ∈ b) (hc' : b' ∈ c) (hb' : x ∈ b') : b = b'
theorem pgame.lf.lt {x y : pgame} (h : x.lf y) (ox : x.numeric) (oy : y.numeric) : x < y
theorem int.cast_inj_on_of_ring_char_ne_two {R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R ≠ 2) : set.inj_on coe {0, 1, -1}
theorem complete_lattice.independent.dfinsupp_sum_add_hom_injective {ι : Type u_1} {N : Type u_5} [dec_ι : decidable_eq ι] [add_comm_group N] {p : ι → add_subgroup N} (h : complete_lattice.independent p) : function.injective ⇑(dfinsupp.sum_add_hom (λ (i : ι), (p i).subtype))
theorem tendsto_inv_at_top_zero' {α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] : filter.tendsto (λ (r : α), r⁻¹) filter.at_top (nhds_within 0 (set.Ioi 0))
theorem quaternion_group.quaternion_group_one_is_cyclic  : is_cyclic (quaternion_group 1)
theorem matrix.map_smul' {n : Type u_3} {α : Type v} {β : Type w} [has_mul α] [has_mul β] (f : α → β) (r : α) (A : matrix n n α) (hf : ∀ (a₁ a₂ : α), f (a₁ * a₂) = f a₁ * f a₂) : (r • A).map f = f r • A.map f
theorem is_nilpotent_pi_of_bounded_class {η : Type u_2} {Gs : η → Type u_3} [Π (i : η), group (Gs i)] [∀ (i : η), group.is_nilpotent (Gs i)] (n : ℕ) (h : ∀ (i : η), group.nilpotency_class (Gs i) ≤ n) : group.is_nilpotent (Π (i : η), Gs i)
theorem ring.inverse_unit {M₀ : Type u_1} [monoid_with_zero M₀] (u : M₀ˣ) : ring.inverse ↑u = ↑u⁻¹
theorem formal_multilinear_series.le_radius_of_bound {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) (C : ℝ) {r : nnreal} (h : ∀ (n : ℕ), ∥p n∥ * ↑r ^ n ≤ C) : ↑r ≤ p.radius
theorem tangent_cone_congr {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {x : E} {s t : set E} (h : nhds_within x s = nhds_within x t) : tangent_cone_at 𝕜 s x = tangent_cone_at 𝕜 t x
theorem concave_on.slope_anti_adjacent {𝕜 : Type u_1} [linear_ordered_field 𝕜] {s : set 𝕜} {f : 𝕜 → 𝕜} (hf : concave_on 𝕜 s f) {x y z : 𝕜} (hx : x ∈ s) (hz : z ∈ s) (hxy : x < y) (hyz : y < z) : (f z - f y) / (z - y) ≤ (f y - f x) / (y - x)
theorem measure_theory.integral_integral {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] {f : α → β → E} (hf : measure_theory.integrable (function.uncurry f) (μ.prod ν)) : ∫ (x : α), ∫ (y : β), f x y ∂ν ∂μ = ∫ (z : α × β), f z.fst z.snd ∂μ.prod ν
theorem metric.frontier_thickening_subset {α : Type u} [pseudo_emetric_space α] (E : set α) {δ : ℝ} (δ_pos : 0 < δ) : frontier (metric.thickening δ E) ⊆ {x : α | emetric.inf_edist x E = ennreal.of_real δ}
theorem unique_diff_on.prod {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {t : set F} (hs : unique_diff_on 𝕜 s) (ht : unique_diff_on 𝕜 t) : unique_diff_on 𝕜 (s ×ˢ t)
theorem monotone.mul_strict_mono' {α : Type u_1} {β : Type u_2} [has_mul α] [preorder α] [preorder β] [covariant_class α α has_mul.mul has_lt.lt] [covariant_class α α (function.swap has_mul.mul) has_le.le] {f g : β → α} (hf : monotone f) (hg : strict_mono g) : strict_mono (λ (x : β), f x * g x)
theorem filter.at_bot_Iio_eq {α : Type u_3} [semilattice_inf α] (a : α) : filter.at_bot = filter.comap coe filter.at_bot
theorem exp_char_is_prime_or_one (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : ℕ) [hq : exp_char R q] : nat.prime q ∨ q = 1
theorem commute.mul_left {S : Type u_1} [semigroup S] {a b c : S} (hac : commute a c) (hbc : commute b c) : commute (a * b) c
theorem emetric.Hausdorff_edist_closure₂ {α : Type u} [pseudo_emetric_space α] {s t : set α} : emetric.Hausdorff_edist s (closure t) = emetric.Hausdorff_edist s t
theorem add_semiconj_by.add_units_neg_right {M : Type u} [add_monoid M] {a : M} {x y : add_units M} (h : add_semiconj_by a ↑x ↑y) : add_semiconj_by a (↑-x) (↑-y)
theorem box_integral.prepartition.exists_tagged_le_is_Henstock_is_subordinate_Union_eq {ι : Type u_1} [fintype ι] {I : box_integral.box ι} (r : (ι → ℝ) → ↥(set.Ioi 0)) (π : box_integral.prepartition I) : ∃ (π' : box_integral.tagged_prepartition I), π'.to_prepartition ≤ π ∧ π'.is_Henstock ∧ π'.is_subordinate r ∧ π'.distortion = π.distortion ∧ π'.Union = π.Union
theorem liouville_with_one (x : ℝ) : liouville_with 1 x
theorem measure_theory.integral_norm_le_of_forall_fin_meas_integral_eq {α : Type u_1} {m m0 : measurable_space α} {μ : measure_theory.measure α} {s : set α} (hm : m ≤ m0) {f g : α → ℝ} (hf : measure_theory.strongly_measurable f) (hfi : measure_theory.integrable_on f s μ) (hg : measure_theory.strongly_measurable g) (hgi : measure_theory.integrable_on g s μ) (hgf : ∀ (t : set α), measurable_set t → ⇑μ t < ⊤ → ∫ (x : α) in t, g x ∂μ = ∫ (x : α) in t, f x ∂μ) (hs : measurable_set s) (hμs : ⇑μ s ≠ ⊤) : ∫ (x : α) in s, ∥g x∥ ∂μ ≤ ∫ (x : α) in s, ∥f x∥ ∂μ
theorem nilpotency_class_le_of_surjective {G : Type u_1} [group G] {G' : Type u_2} [group G'] (f : G →* G') (hf : function.surjective ⇑f) [h : group.is_nilpotent G] : group.nilpotency_class G' ≤ group.nilpotency_class G
theorem measurable_limsup {α : Type u_1} {δ : Type u_5} [topological_space α] [measurable_space α] [borel_space α] [measurable_space δ] [complete_linear_order α] [order_topology α] [topological_space.second_countable_topology α] {f : ℕ → δ → α} (hf : ∀ (i : ℕ), measurable (f i)) : measurable (λ (x : δ), filter.at_top.limsup (λ (i : ℕ), f i x))
theorem uniform_space.completion.mem_uniformity_dist {α : Type u} [pseudo_metric_space α] (s : set (uniform_space.completion α × uniform_space.completion α)) : s ∈ uniformity (uniform_space.completion α) ↔ ∃ (ε : ℝ) (H : ε > 0), ∀ {a b : uniform_space.completion α}, has_dist.dist a b < ε → (a, b) ∈ s
theorem orthonormal.two_zsmul_oangle_smul_right_self {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x : V) {r : ℝ} : 2 • hb.oangle x (r • x) = 0
theorem convex.exists_nhds_within_lipschitz_on_with_of_has_fderiv_within_at {E : Type u_1} [normed_group E] [normed_space ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_space 𝕜 E] [normed_group G] [normed_space 𝕜 G] {s : set E} {x : E} {f' : E → (E →L[𝕜] G)} (hs : convex ℝ s) {f : E → G} (hder : ∀ᶠ (y : E) in nhds_within x s, has_fderiv_within_at f (f' y) s y) (hcont : continuous_within_at f' s x) : ∃ (K : nnreal) (t : set E) (H : t ∈ nhds_within x s), lipschitz_on_with K f t
theorem mul_equiv.symm_apply_apply {M : Type u_6} {N : Type u_7} [has_mul M] [has_mul N] (e : M ≃* N) (x : M) : ⇑(e.symm) (⇑e x) = x
theorem normed_space.smul_mem_polar {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [semi_normed_group E] [normed_space 𝕜 E] {s : set E} {x' : normed_space.dual 𝕜 E} {c : 𝕜} (hc : ∀ (z : E), z ∈ s → ∥⇑x' z∥ ≤ ∥c∥) : c⁻¹ • x' ∈ normed_space.polar 𝕜 s
theorem left.add_pos_of_pos_of_nonneg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 ≤ b) : 0 < a + b
theorem tsub_tsub_cancel_of_le {α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} [contravariant_class α α has_add.add has_le.le] (h : a ≤ b) : b - (b - a) = a
theorem lie_algebra.is_nilpotent_range_ad_iff {R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : lie_algebra.is_nilpotent R ↥((lie_algebra.ad R L).range) ↔ lie_algebra.is_nilpotent R L
theorem euclidean_geometry.cospherical_subset {P : Type u_2} [metric_space P] {ps₁ ps₂ : set P} (hs : ps₁ ⊆ ps₂) (hc : euclidean_geometry.cospherical ps₂) : euclidean_geometry.cospherical ps₁
theorem real.cos_pi_div_six  : real.cos (real.pi / 6) = real.sqrt 3 / 2
theorem convex.lipschitz_on_with_of_nnnorm_has_fderiv_within_le {E : Type u_1} [normed_group E] [normed_space ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_space 𝕜 E] [normed_group G] [normed_space 𝕜 G] {f : E → G} {s : set E} {f' : E → (E →L[𝕜] G)} {C : nnreal} (hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (bound : ∀ (x : E), x ∈ s → ∥f' x∥₊ ≤ C) (hs : convex ℝ s) : lipschitz_on_with C f s
theorem pgame.le_zero_lf {x : pgame} : x ≤ 0 ↔ ∀ (i : x.left_moves), (x.move_left i).lf 0
theorem cont_diff_top_iff_fderiv {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} : cont_diff 𝕜 ⊤ f ↔ differentiable 𝕜 f ∧ cont_diff 𝕜 ⊤ (λ (y : E), fderiv 𝕜 f y)
theorem monoid_algebra.mem_closure_of_mem_span_closure {R : Type u_1} {M : Type u_2} [comm_ring R] [comm_monoid M] [nontrivial R] {m : M} {S : set M} (h : ⇑(monoid_algebra.of R M) m ∈ submodule.span R ↑(submonoid.closure (⇑(monoid_algebra.of R M) '' S))) : m ∈ submonoid.closure S
theorem category_theory.is_filtered.to_sup_commutes {C : Type u} [category_theory.category C] [category_theory.is_filtered C] (O : finset C) (H : finset (Σ' (X Y : C) (mX : X ∈ O) (mY : Y ∈ O), X ⟶ Y)) {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f : X ⟶ Y} (mf : ⟨X, ⟨Y, ⟨mX, ⟨mY, f⟩⟩⟩⟩ ∈ H) : f ≫ category_theory.is_filtered.to_sup O H mY = category_theory.is_filtered.to_sup O H mX
theorem torus_integrable.neg {n : ℕ} {E : Type u_1} [normed_group E] {f : (fin n → ℂ) → E} {c : fin n → ℂ} {R : fin n → ℝ} (hf : torus_integrable f c R) : torus_integrable (-f) c R
theorem is_cyclotomic_extension.norm_zeta_eq_one {n : ℕ+} {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [ne_zero ↑↑n] [is_cyclotomic_extension {n} K L] (hn : n ≠ 2) (hirr : irreducible (polynomial.cyclotomic ↑n K)) : ⇑(algebra.norm K) (is_cyclotomic_extension.zeta n K L) = 1
theorem polynomial.degree_cyclotomic' {R : Type u_1} [comm_ring R] [is_domain R] {ζ : R} {n : ℕ} (h : is_primitive_root ζ n) : (polynomial.cyclotomic' n R).degree = ↑(n.totient)
theorem con.mk'_surjective {M : Type u_1} [mul_one_class M] {c : con M} : function.surjective ⇑(c.mk')
theorem is_dedekind_domain.height_one_spectrum.int_valuation_ne_zero' {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x : ↥(non_zero_divisors R)) : v.int_valuation_def ↑x ≠ 0
theorem cont_diff_on.prod {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {n : with_top ℕ} {s : set E} {f : E → F} {g : E → G} (hf : cont_diff_on 𝕜 n f s) (hg : cont_diff_on 𝕜 n g s) : cont_diff_on 𝕜 n (λ (x : E), (f x, g x)) s
theorem maximal_linear_independent_eq_infinite_basis {R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {ι : Type u_1} (b : basis ι R M) [infinite ι] {κ : Type u_1} (v : κ → M) (i : linear_independent R v) (m : i.maximal) : cardinal.mk κ = cardinal.mk ι
theorem monotone.monotone_iterate_of_le_map {α : Type u_1} [preorder α] {f : α → α} {x : α} (hf : monotone f) (hx : x ≤ f x) : monotone (λ (n : ℕ), f^[n] x)
theorem ennreal.cancel_of_lt' {a b : ennreal} (h : a < b) : add_le_cancellable a
theorem probability_theory.lintegral_mul_indicator_eq_lintegral_mul_lintegral_indicator {α : Type u_1} {f : α → ennreal} {Mf mα : measurable_space α} {μ : measure_theory.measure α} (hMf : Mf ≤ mα) (c : ennreal) {T : set α} (h_meas_T : measurable_set T) (h_ind : probability_theory.indep_sets {s : set α | measurable_set s} {T} μ) (h_meas_f : measurable f) : ∫⁻ (a : α), f a * T.indicator (λ (_x : α), c) a ∂μ = ∫⁻ (a : α), f a ∂μ * ∫⁻ (a : α), T.indicator (λ (_x : α), c) a ∂μ
theorem surjective_quot_mk {α : Sort u_1} (r : α → α → Prop) : function.surjective (quot.mk r)
theorem finset.exists_card_fiber_lt_of_card_lt_nsmul {α : Type u} {β : Type v} {M : Type w} [decidable_eq β] {s : finset α} {t : finset β} {f : α → β} {b : M} [linear_ordered_comm_ring M] (ht : ↑(s.card) < t.card • b) : ∃ (y : β) (H : y ∈ t), ↑((finset.filter (λ (x : α), f x = y) s).card) < b
theorem continuous_map.polynomial_comp_attach_bound_mem {X : Type u_1} [topological_space X] [compact_space X] (A : subalgebra ℝ C(X, ℝ)) (f : ↥A) (g : polynomial ℝ) : (g.to_continuous_map_on (set.Icc (-∥f∥) ∥f∥)).comp ↑f.attach_bound ∈ A
theorem convex_hull_diam {E : Type u_2} [semi_normed_group E] [normed_space ℝ E] (s : set E) : metric.diam (⇑(convex_hull ℝ) s) = metric.diam s
theorem nilpotency_class_quotient_center {G : Type u_1} [group G] [hH : group.is_nilpotent G] : group.nilpotency_class (G ⧸ subgroup.center G) = group.nilpotency_class G - 1
theorem orientation.oangle_add_cyc3 {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle x y + o.oangle y z + o.oangle z x = 0
theorem orthonormal.rotation_oangle_eq_iff_norm_eq {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x y : V) : ⇑(hb.rotation (hb.oangle x y)) x = y ↔ ∥x∥ = ∥y∥
theorem zmod.χ₄_int_eq_if_mod_four (n : ℤ) : ⇑zmod.χ₄ ↑n = ite (n % 2 = 0) 0 (ite (n % 4 = 1) 1 (-1))
theorem has_mfderiv_at.comp {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {E'' : Type u_8} [normed_group E''] [normed_space 𝕜 E''] {H'' : Type u_9} [topological_space H''] {I'' : model_with_corners 𝕜 E'' H''} {M'' : Type u_10} [topological_space M''] [charted_space H'' M''] {f : M → M'} (x : M) {g : M' → M''} [Is : smooth_manifold_with_corners I M] [I's : smooth_manifold_with_corners I' M'] [I''s : smooth_manifold_with_corners I'' M''] {f' : tangent_space I x →L[𝕜] tangent_space I' (f x)} {g' : tangent_space I' (f x) →L[𝕜] tangent_space I'' (g (f x))} (hg : has_mfderiv_at I' I'' g (f x) g') (hf : has_mfderiv_at I I' f x f') : has_mfderiv_at I I'' (g ∘ f) x (g'.comp f')
theorem discrete_topology.of_subset {X : Type u_1} [topological_space X] {s t : set X} (ds : discrete_topology ↥s) (ts : t ⊆ s) : discrete_topology ↥t
theorem pow_eq_pow_mod {M : Type u_1} [monoid M] {x : M} (m : ℕ) {n : ℕ} (h : x ^ n = 1) : x ^ m = x ^ (m % n)
theorem partition_of_unity.exists_is_subordinate {ι : Type u} {X : Type v} [topological_space X] {s : set X} [normal_space X] [paracompact_space X] (hs : is_closed s) (U : ι → set X) (ho : ∀ (i : ι), is_open (U i)) (hU : s ⊆ ⋃ (i : ι), U i) : ∃ (f : partition_of_unity ι X s), f.is_subordinate U
theorem polynomial.card_pow_degree_anti_archimedean {Fq : Type u_1} [fintype Fq] [field Fq] {x y z : polynomial Fq} {a : ℤ} (hxy : ⇑polynomial.card_pow_degree (x - y) < a) (hyz : ⇑polynomial.card_pow_degree (y - z) < a) : ⇑polynomial.card_pow_degree (x - z) < a
theorem direct_sum.is_internal.submodule_independent {R : Type u} [semiring R] {ι : Type v} [dec_ι : decidable_eq ι] {M : Type u_1} [add_comm_monoid M] [module R M] {A : ι → submodule R M} (h : direct_sum.is_internal A) : complete_lattice.independent A
theorem pgame.relabelling.equiv {x y : pgame} (r : x.relabelling y) : x.equiv y
theorem linear_map.finrank_range_of_inj {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {V₂ : Type v'} [add_comm_group V₂] [module K V₂] {f : V →ₗ[K] V₂} (hf : function.injective ⇑f) : finite_dimensional.finrank K ↥(f.range) = finite_dimensional.finrank K V
theorem is_add_monoid_hom.is_add_monoid_hom_mul_left {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), x * y)
theorem affine_map.continuous_iff {R : Type u_1} {E : Type u_2} {F : Type u_3} [add_comm_group E] [topological_space E] [add_comm_group F] [topological_space F] [topological_add_group F] [ring R] [module R E] [module R F] {f : E →ᵃ[R] F} : continuous ⇑f ↔ continuous ⇑(f.linear)
theorem closure_Iio {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) [no_min_order α] : closure (set.Iio a) = set.Iic a
theorem formal_multilinear_series.nnnorm_mul_pow_le_of_lt_radius {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) {r : nnreal} (h : ↑r < p.radius) : ∃ (C : nnreal) (H : C > 0), ∀ (n : ℕ), ∥p n∥₊ * r ^ n ≤ C
theorem add_neg_of_nonpos_of_neg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a ≤ 0) (hb : b < 0) : a + b < 0
theorem topological_space.second_countable_topology_induced (α : Type u) (β : Type u_1) [t : topological_space β] [topological_space.second_countable_topology β] (f : α → β) : topological_space.second_countable_topology α
theorem image_norm_le_of_norm_deriv_right_le_deriv_boundary {E : Type u_1} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} {f' : ℝ → E} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : ℝ → ℝ} (ha : ∥f a∥ ≤ B a) (hB : ∀ (x : ℝ), has_deriv_at B (B' x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → ∥f' x∥ ≤ B' x) ⦃x : ℝ⦄ : x ∈ set.Icc a b → ∥f x∥ ≤ B x
theorem is_clopen.frontier_eq {α : Type u} [topological_space α] {s : set α} : is_clopen s → frontier s = ∅
theorem cSup_eq_of_is_forall_le_of_forall_le_imp_ge {α : Type u_1} [conditionally_complete_lattice α] {s : set α} {b : α} (hs : s.nonempty) (h_is_ub : ∀ (a : α), a ∈ s → a ≤ b) (h_b_le_ub : ∀ (ub : α), (∀ (a : α), a ∈ s → a ≤ ub) → b ≤ ub) : has_Sup.Sup s = b
theorem measurable_of_tendsto_metrizable {α : Type u_1} {β : Type u_2} [measurable_space α] [topological_space β] [topological_space.pseudo_metrizable_space β] [measurable_space β] [borel_space β] {f : ℕ → α → β} {g : α → β} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g
theorem locally_finite.finite_of_compact {α : Type u} [topological_space α] {ι : Type u_1} [compact_space α] {f : ι → set α} (hf : locally_finite f) (hne : ∀ (i : ι), (f i).nonempty) : set.univ.finite
theorem is_integrally_closed_iff_is_integral_closure {R : Type u_1} [comm_ring R] [is_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] : is_integrally_closed R ↔ is_integral_closure R R K
theorem fractional_ideal.exists_ne_zero_mem_is_integer {R : Type u_1} [comm_ring R] {K : Type u_3} [field K] [algebra R K] [is_fraction_ring R K] {I : fractional_ideal (non_zero_divisors R) K} [nontrivial R] (hI : I ≠ 0) : ∃ (x : R) (H : x ≠ 0), ⇑(algebra_map R K) x ∈ I
theorem simple_graph.is_SRG_with.card_neighbor_finset_union_of_not_adj {V : Type u} [fintype V] [decidable_eq V] {G : simple_graph V} [decidable_rel G.adj] {n k ℓ μ : ℕ} {v w : V} (h : G.is_SRG_with n k ℓ μ) (hne : v ≠ w) (ha : ¬G.adj v w) : (G.neighbor_finset v ∪ G.neighbor_finset w).card = 2 * k - μ
theorem has_compact_support.continuous_convolution_right {𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G → E} {g : G → E'} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 F] (L : E →L[𝕜] E' →L[𝕜] F) [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ F] [complete_space F] [add_group G] [topological_space G] [topological_add_group G] [borel_space G] [topological_space.second_countable_topology G] [locally_compact_space G] [t2_space G] (hcg : has_compact_support g) (hf : measure_theory.locally_integrable f μ) (hg : continuous g) : continuous (convolution f g L μ)
theorem cont_diff.snd {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {n : with_top ℕ} {f : E → F × G} (hf : cont_diff 𝕜 n f) : cont_diff 𝕜 n (λ (x : E), (f x).snd)
theorem lie_algebra.is_engelian_of_is_noetherian {R : Type u₁} {L : Type u₂} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : lie_algebra.is_engelian R L
theorem pi.single_apply {I : Type u} [decidable_eq I] {β : Type u_1} [has_zero β] (i : I) (x : β) (i' : I) : pi.single i x i' = ite (i' = i) x 0
theorem matrix.det_fin_one {R : Type v} [comm_ring R] (A : matrix (fin 1) (fin 1) R) : A.det = A 0 0
theorem list.drop_take_succ_join_eq_nth_le {α : Type u_1} (L : list (list α)) {i : ℕ} (hi : i < L.length) : list.drop (list.take i (list.map list.length L)).sum (list.take (list.take (i + 1) (list.map list.length L)).sum L.join) = L.nth_le i hi
theorem exists_open_nhds_zero_add_subset {M : Type u_4} [topological_space M] [add_monoid M] [has_continuous_add M] {U : set M} (hU : U ∈ nhds 0) : ∃ (V : set M), is_open V ∧ 0 ∈ V ∧ V + V ⊆ U
theorem sum_Ico_pow (n p : ℕ) : (finset.Ico 1 (n + 1)).sum (λ (k : ℕ), ↑k ^ p) = (finset.range (p + 1)).sum (λ (i : ℕ), bernoulli' i * ↑((p + 1).choose i) * ↑n ^ (p + 1 - i) / (↑p + 1))
theorem algebra.finite_presentation.of_finite_type {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] [is_noetherian_ring R] : algebra.finite_type R A ↔ algebra.finite_presentation R A
theorem is_closed.is_clopenable {α : Type u_1} [topological_space α] [polish_space α] {s : set α} (hs : is_closed s) : polish_space.is_clopenable s
theorem generalized_continued_fraction.abs_sub_convergents_le' {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {b : K} (nth_part_denom_eq : (generalized_continued_fraction.of v).partial_denominators.nth n = option.some b) : |v - (generalized_continued_fraction.of v).convergents n| ≤ 1 / (b * (generalized_continued_fraction.of v).denominators n * (generalized_continued_fraction.of v).denominators n)
theorem cont_mdiff_within_at.prod_map' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {F : Type u_8} [normed_group F] [normed_space 𝕜 F] {G : Type u_9} [topological_space G] {J : model_with_corners 𝕜 F G} {N : Type u_10} [topological_space N] [charted_space G N] {F' : Type u_11} [normed_group F'] [normed_space 𝕜 F'] {G' : Type u_12} [topological_space G'] {J' : model_with_corners 𝕜 F' G'} {N' : Type u_13} [topological_space N'] [charted_space G' N'] {f : M → M'} {s : set M} {n : with_top ℕ} {g : N → N'} {r : set N} {p : M × N} (hf : cont_mdiff_within_at I I' n f s p.fst) (hg : cont_mdiff_within_at J J' n g r p.snd) : cont_mdiff_within_at (I.prod J) (I'.prod J') n (prod.map f g) (s ×ˢ r) p
theorem category_theory.limits.complete_lattice.finite_product_eq_finset_inf {α : Type u} [semilattice_inf α] [order_top α] {ι : Type u} [fintype ι] (f : ι → α) : (∏ f) = (fintype.elems ι).inf f
theorem isometry.uniform_inducing {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} (hf : isometry f) : uniform_inducing f
theorem pnat.factor_multiset_one  : 1.factor_multiset = 0
theorem is_atom.dual {α : Type u_1} [preorder α] [order_bot α] {a : α} : is_atom a → is_coatom (⇑order_dual.to_dual a)
theorem has_ssubset.ssubset.asymm {α : Type u} [has_ssubset α] [is_asymm α has_ssubset.ssubset] {a b : α} (h : a ⊂ b) : ¬b ⊂ a
theorem is_p_group.exists_le_sylow {p : ℕ} {G : Type u_1} [group G] {P : subgroup G} (hP : is_p_group p ↥P) : ∃ (Q : sylow p G), P ≤ ↑Q
theorem monoid.fg_iff {M : Type u_1} [monoid M] : monoid.fg M ↔ ∃ (S : set M), submonoid.closure S = ⊤ ∧ S.finite
theorem interval_integral.integral_has_deriv_within_at_right {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set ℝ} [interval_integral.FTC_filter b (nhds_within b s) (nhds_within b t)] (hmeas : strongly_measurable_at_filter f (nhds_within b t) measure_theory.measure_space.volume) (hb : continuous_within_at f t b) : has_deriv_within_at (λ (u : ℝ), ∫ (x : ℝ) in a..u, f x) (f b) s b
theorem category_theory.iso_has_right_lifting_property {C : Type u} [category_theory.category C] {X Y : C} (i : category_theory.arrow C) (p : X ≅ Y) : category_theory.has_lifting_property i (category_theory.arrow.mk p.hom)
theorem nonempty_linear_equiv_of_lift_dim_eq {K : Type u} {V : Type v} {V' : Type v'} [division_ring K] [add_comm_group V] [module K V] [add_comm_group V'] [module K V'] (cond : (module.rank K V).lift = (module.rank K V').lift) : nonempty (V ≃ₗ[K] V')
theorem real.sinh_strict_mono  : strict_mono real.sinh
theorem tendsto_uniformly.comp' {α : Type u_1} {β : Type u_2} {γ : Type u_3} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {p : filter ι} [uniform_space γ] {g : β → γ} (h : tendsto_uniformly F f p) (hg : uniform_continuous g) : tendsto_uniformly (λ (i : ι), g ∘ F i) (g ∘ f) p
theorem integral_sin_mul_cos₁ {a b : ℝ} : ∫ (x : ℝ) in a..b, real.sin x * real.cos x = (real.sin b ^ 2 - real.sin a ^ 2) / 2
theorem shrinking_lemma.partial_refinement.exists_gt {ι : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : ι → set X} {s : set X} (v : shrinking_lemma.partial_refinement u s) (hs : is_closed s) (i : ι) (hi : i ∉ v.carrier) : ∃ (v' : shrinking_lemma.partial_refinement u s), v < v'
theorem linear_map.linear_independent_of_is_Ortho {K : Type u_8} {K₁ : Type u_9} {V₁ : Type u_12} {n : Type u_14} [field K] [field K₁] [add_comm_group V₁] [module K₁ V₁] {I₁ I₁' : K₁ →+* K} {B : V₁ →ₛₗ[I₁] V₁ →ₛₗ[I₁'] K} {v : n → V₁} (hv₁ : B.is_Ortho v) (hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i)) : linear_independent K₁ v
theorem injective_iff_map_eq_one' {F : Type u_8} {G : Type u_1} {H : Type u_2} [group G] [mul_one_class H] [monoid_hom_class F G H] (f : F) : function.injective ⇑f ↔ ∀ (a : G), ⇑f a = 1 ↔ a = 1
theorem composition.index_exists {n : ℕ} (c : composition n) {j : ℕ} (h : j < n) : ∃ (i : ℕ), j < c.size_up_to i.succ ∧ i < c.length
theorem mathlib_dir_locator  : true
theorem finite_dimensional.of_finset_basis {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type w} {s : finset ι} (h : basis ↥s K V) : finite_dimensional K V
theorem has_sum_two_pi_I_cauchy_power_series_integral {E : Type u_1} [normed_group E] [normed_space ℂ E] [complete_space E] {f : ℂ → E} {c : ℂ} {R : ℝ} {w : ℂ} (hf : circle_integrable f c R) (hw : complex.abs w < R) : has_sum (λ (n : ℕ), ∮ (z : ℂ) in C(c, R), (w / (z - c)) ^ n • (z - c)⁻¹ • f z) (∮ (z : ℂ) in C(c, R), (z - (c + w))⁻¹ • f z)
theorem measure_theory.integral_prod_symm {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] (f : α × β → E) (hf : measure_theory.integrable f (μ.prod ν)) : ∫ (z : α × β), f z ∂μ.prod ν = ∫ (y : β), ∫ (x : α), f (x, y) ∂μ ∂ν
theorem orthonormal.oangle_zero_left {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x : V) : hb.oangle 0 x = 0
theorem category_theory.locally_cover_dense.induced_topology_cover_preserving {C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {G : C ⥤ D} {K : category_theory.grothendieck_topology D} [category_theory.full G] [category_theory.faithful G] (Hld : category_theory.locally_cover_dense K G) : category_theory.cover_preserving Hld.induced_topology K G
theorem dfinsupp.ext_iff {ι : Type u} {β : ι → Type v} [Π (i : ι), has_zero (β i)] {f g : Π₀ (i : ι), β i} : f = g ↔ ∀ (i : ι), ⇑f i = ⇑g i
theorem complex.analytic_at_of_differentiable_on_punctured_nhds_of_continuous_at {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] {f : ℂ → E} {c : ℂ} (hd : ∀ᶠ (z : ℂ) in nhds_within c {c}ᶜ, differentiable_at ℂ f z) (hc : continuous_at f c) : analytic_at ℂ f c
theorem category_theory.simplicial_object.δ_comp_σ_succ {C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) {n : ℕ} {i : fin (n + 1)} : X.σ i ≫ X.δ i.succ = 𝟙 (X.obj (opposite.op (simplex_category.mk n)))
theorem vadd_right_injective {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (λ (_x : G), _x +ᵥ p)
theorem equiv.swap_mul_involutive {α : Type u} [decidable_eq α] (i j : α) : function.involutive (has_mul.mul (equiv.swap i j))
theorem tendsto_locally_uniformly_iff_tendsto_uniformly_of_compact_space {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {p : filter ι} [topological_space α] [compact_space α] : tendsto_locally_uniformly F f p ↔ tendsto_uniformly F f p
theorem asymptotics.is_o.norm_left {α : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : α → F} {f' : α → E'} {l : filter α} : f' =o[l] g → (λ (x : α), ∥f' x∥) =o[l] g
theorem affine_independent.exists_mem_inter_of_exists_mem_inter_affine_span {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} [nontrivial k] {p : ι → P} (ha : affine_independent k p) {s1 s2 : set ι} {p0 : P} (hp0s1 : p0 ∈ affine_span k (p '' s1)) (hp0s2 : p0 ∈ affine_span k (p '' s2)) : ∃ (i : ι), i ∈ s1 ∩ s2
theorem mul_add_mul_lt_mul_add_mul {α : Type u} [ordered_semiring α] {a b c d : α} [has_exists_add_of_le α] (hab : a < b) (hcd : c < d) : a * d + b * c < a * c + b * d
theorem free_group.reduce.red {α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.red L (free_group.reduce L)
theorem subring.closure_mono {R : Type u} [ring R] ⦃s t : set R⦄ (h : s ⊆ t) : subring.closure s ≤ subring.closure t
theorem add_monoid_hom.mk_normed_group_hom_norm_le' {V₁ : Type u_2} {V₂ : Type u_3} [semi_normed_group V₁] [semi_normed_group V₂] (f : V₁ →+ V₂) {C : ℝ} (h : ∀ (x : V₁), ∥⇑f x∥ ≤ C * ∥x∥) : ∥f.mk_normed_group_hom C h∥ ≤ linear_order.max C 0
theorem has_deriv_at.lhopital_zero_at_top {l : filter ℝ} {f f' g g' : ℝ → ℝ} (hff' : ∀ᶠ (x : ℝ) in filter.at_top, has_deriv_at f (f' x) x) (hgg' : ∀ᶠ (x : ℝ) in filter.at_top, has_deriv_at g (g' x) x) (hg' : ∀ᶠ (x : ℝ) in filter.at_top, g' x ≠ 0) (hftop : filter.tendsto f filter.at_top (nhds 0)) (hgtop : filter.tendsto g filter.at_top (nhds 0)) (hdiv : filter.tendsto (λ (x : ℝ), f' x / g' x) filter.at_top l) : filter.tendsto (λ (x : ℝ), f x / g x) filter.at_top l
theorem uniformity_edist {γ : Type w} [emetric_space γ] : uniformity γ = ⨅ (ε : ennreal) (H : ε > 0), filter.principal {p : γ × γ | has_edist.edist p.fst p.snd < ε}
theorem witt_vector.verschiebung_mul_frobenius {p : ℕ} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (x y : witt_vector p R) : ⇑witt_vector.verschiebung (x * ⇑witt_vector.frobenius y) = ⇑witt_vector.verschiebung x * y
theorem metric_space.ext {α : Type u_1} {m m' : metric_space α} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist) : m = m'
theorem cauchy_seq_of_le_tendsto_0' {α : Type u} {β : Type v} [pseudo_metric_space α] [nonempty β] [semilattice_sup β] {s : β → α} (b : β → ℝ) (h : ∀ (n m : β), n ≤ m → has_dist.dist (s n) (s m) ≤ b n) (h₀ : filter.tendsto b filter.at_top (nhds 0)) : cauchy_seq s
theorem padic_norm_e.add_eq_max_of_ne' {p : ℕ} [fact (nat.prime p)] {q r : ℚ_[p]} : padic_norm_e q ≠ padic_norm_e r → padic_norm_e (q + r) = linear_order.max (padic_norm_e q) (padic_norm_e r)
theorem denom_dvd_of_is_root {A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} {r : K} (hr : ⇑(polynomial.aeval r) p = 0) : ↑(is_fraction_ring.denom A r) ∣ p.leading_coeff
theorem monoid_hom.map_mul {M : Type u_3} {N : Type u_4} [mul_one_class M] [mul_one_class N] (f : M →* N) (a b : M) : ⇑f (a * b) = ⇑f a * ⇑f b
theorem is_preconnected_iff_subset_of_fully_disjoint_closed {α : Type u} [topological_space α] {s : set α} (hs : is_closed s) : is_preconnected s ↔ ∀ (u v : set α), is_closed u → is_closed v → s ⊆ u ∪ v → u ∩ v = ∅ → s ⊆ u ∨ s ⊆ v
theorem orthogonal_family.linear_isometry_equiv_apply_dfinsupp_sum_single {ι : Type u_1} {𝕜 : Type u_2} [is_R_or_C 𝕜] {E : Type u_3} [inner_product_space 𝕜 E] [cplt : complete_space E] {G : ι → Type u_4} [Π (i : ι), inner_product_space 𝕜 (G i)] {V : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : orthogonal_family 𝕜 V) [∀ (i : ι), complete_space (G i)] (hV' : (⨆ (i : ι), (V i).to_linear_map.range).topological_closure = ⊤) (W₀ : Π₀ (i : ι), G i) : ⇑(⇑(hV.linear_isometry_equiv hV') (W₀.sum (λ (i : ι), ⇑(V i)))) = ⇑W₀
theorem ennreal.young_inequality (a b : ennreal) {p q : ℝ} (hpq : p.is_conjugate_exponent q) : a * b ≤ a ^ p / ennreal.of_real p + b ^ q / ennreal.of_real q
theorem fin.coe_coe_eq_self {n : ℕ} (a : fin (n + 1)) : ↑↑a = a
theorem category_theory.limits.pushout_cocone.epi_of_is_colimit_mk_id_id {C : Type u} [category_theory.category C] {X Y : C} (f : X ⟶ Y) (t : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk (𝟙 Y) (𝟙 Y) rfl)) : category_theory.epi f
theorem reflexive.rel_of_ne_imp {α : Type u_1} {r : α → α → Prop} (h : reflexive r) {x y : α} (hr : x ≠ y → r x y) : r x y
theorem subring.mul_mem {R : Type u} [ring R] (s : subring R) {x y : R} : x ∈ s → y ∈ s → x * y ∈ s
theorem smul_zero' {R : Type u_1} (M : Type u_3) [has_zero R] [has_zero M] [smul_with_zero R M] (r : R) : r • 0 = 0
theorem tangent_bundle_proj_continuous {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) (M : Type u_4) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] : continuous (tangent_bundle.proj I M)
theorem disjoint.map_order_iso {α : Type u_2} {β : Type u_3} [semilattice_inf α] [order_bot α] [semilattice_inf β] [order_bot β] {a b : α} (f : α ≃o β) (ha : disjoint a b) : disjoint (⇑f a) (⇑f b)
theorem antitone.inf {α : Type u} {β : Type v} [preorder α] [semilattice_inf β] {f g : α → β} (hf : antitone f) (hg : antitone g) : antitone (f ⊓ g)
theorem is_localization.is_prime_of_is_prime_disjoint {R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] (I : ideal R) (hp : I.is_prime) (hd : disjoint ↑M ↑I) : (ideal.map (algebra_map R S) I).is_prime
theorem algebraic_geometry.LocallyRingedSpace.to_stalk_stalk_map_to_Γ_Spec (X : algebraic_geometry.LocallyRingedSpace) (x : ↥X) : algebraic_geometry.structure_sheaf.to_stalk ↥(opposite.unop (opposite.op (algebraic_geometry.LocallyRingedSpace.Γ.obj (opposite.op X)))) (⇑(X.to_Γ_Spec_SheafedSpace.base) x) ≫ algebraic_geometry.PresheafedSpace.stalk_map X.to_Γ_Spec_SheafedSpace x = X.Γ_to_stalk x
theorem complex.dist_le_div_mul_dist_of_maps_to_ball {E : Type u_1} [normed_group E] [normed_space ℂ E] {R₁ R₂ : ℝ} {f : ℂ → E} {c z : ℂ} (hd : differentiable_on ℂ f (metric.ball c R₁)) (h_maps : set.maps_to f (metric.ball c R₁) (metric.ball (f c) R₂)) (hz : z ∈ metric.ball c R₁) : has_dist.dist (f z) (f c) ≤ R₂ / R₁ * has_dist.dist z c
theorem category_theory.limits.is_colimit.of_nat_iso.cocone_fac {J : Type u₁} [category_theory.category J] {C : Type u₃} [category_theory.category C] {F : J ⥤ C} {X : C} (h : category_theory.coyoneda.obj (opposite.op X) ⋙ category_theory.ulift_functor ≅ F.cocones) (s : category_theory.limits.cocone F) : (category_theory.limits.is_colimit.of_nat_iso.colimit_cocone h).extend (category_theory.limits.is_colimit.of_nat_iso.hom_of_cocone h s) = s
theorem measure_theory.measure.tendsto_add_haar_inter_smul_zero_of_density_zero {E : Type u_1} [normed_group E] [measurable_space E] [normed_space ℝ E] [finite_dimensional ℝ E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (s : set E) (x : E) (h : filter.tendsto (λ (r : ℝ), ⇑μ (s ∩ metric.closed_ball x r) / ⇑μ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds 0)) (t : set E) (ht : measurable_set t) (h''t : ⇑μ t ≠ ⊤) : filter.tendsto (λ (r : ℝ), ⇑μ (s ∩ ({x} + r • t)) / ⇑μ ({x} + r • t)) (nhds_within 0 (set.Ioi 0)) (nhds 0)
theorem linear_map.trace_eq_contract_of_basis {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {ι : Type u_4} [fintype ι] (b : basis ι R M) : (linear_map.trace R M).comp (dual_tensor_hom R M M) = contract_left R M
theorem real_inner_add_sub_eq_zero_iff {F : Type u_3} [inner_product_space ℝ F] (x y : F) : has_inner.inner (x + y) (x - y) = 0 ↔ ∥x∥ = ∥y∥
theorem measure_theory.outer_measure.exists_mem_forall_mem_nhds_within_pos {α : Type u_1} [topological_space α] [topological_space.second_countable_topology α] (m : measure_theory.outer_measure α) {s : set α} (hs : ⇑m s ≠ 0) : ∃ (x : α) (H : x ∈ s), ∀ (t : set α), t ∈ nhds_within x s → 0 < ⇑m t
theorem subgroup.div_mem {G : Type u_1} [group G] (H : subgroup G) {x y : G} (hx : x ∈ H) (hy : y ∈ H) : x / y ∈ H
theorem finset.noncomm_sum_add_distrib {α : Type u_1} {β : Type u_2} [add_monoid β] {s : finset α} (f g : α → β) (comm_ff : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → add_commute (f x) (f y)) (comm_gg : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → add_commute (g x) (g y)) (comm_gf : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≠ y → add_commute (g x) (f y)) : s.noncomm_sum (f + g) _ = s.noncomm_sum f comm_ff + s.noncomm_sum g comm_gg
theorem group_algebra.mul_average_right (k : Type u_1) (G : Type u_2) [comm_semiring k] [group G] [fintype G] [invertible ↑(fintype.card G)] (g : G) : group_algebra.average k G * finsupp.single g 1 = group_algebra.average k G
theorem orthonormal.det_conj_lie {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) : ⇑linear_map.det ↑(hb.conj_lie.to_linear_equiv) = -1
theorem gold_irrational  : irrational golden_ratio
theorem even.nat_abs {n : ℤ} : even n → even n.nat_abs
theorem set.image_equiv_eq_preimage_symm {α : Type u_1} {β : Type u_2} (S : set α) (f : α ≃ β) : ⇑f '' S = ⇑(f.symm) ⁻¹' S
theorem powers.mul_mem {M : Type u_1} [monoid M] {x y z : M} : y ∈ powers x → z ∈ powers x → y * z ∈ powers x
theorem con.ext {M : Type u_1} [has_mul M] {c d : con M} (H : ∀ (x y : M), ⇑c x y ↔ ⇑d x y) : c = d
theorem cont_diff_at.has_strict_fderiv_at' {n : with_top ℕ} {𝕂 : Type u_6} [is_R_or_C 𝕂] {E' : Type u_7} [normed_group E'] [normed_space 𝕂 E'] {F' : Type u_8} [normed_group F'] [normed_space 𝕂 F'] {f : E' → F'} {f' : E' →L[𝕂] F'} {x : E'} (hf : cont_diff_at 𝕂 n f x) (hf' : has_fderiv_at f f' x) (hn : 1 ≤ n) : has_strict_fderiv_at f f' x
theorem intermediate_field.list_prod_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {l : list L} : (∀ (x : L), x ∈ l → x ∈ S) → l.prod ∈ S
theorem spectrum.is_unit_resolvent {R : Type u} {A : Type v} [comm_semiring R] [ring A] [algebra R A] {r : R} {a : A} : r ∈ resolvent_set R a ↔ is_unit (resolvent a r)
theorem not_covby_iff {α : Type u_1} [has_lt α] {a b : α} (h : a < b) : ¬a ⋖ b ↔ ∃ (c : α), a < c ∧ c < b
theorem measure_theory.integral_fn_integral_add {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] {E' : Type u_7} [normed_group E'] [complete_space E'] [normed_space ℝ E'] ⦃f g : α × β → E⦄ (F : E → E') (hf : measure_theory.integrable f (μ.prod ν)) (hg : measure_theory.integrable g (μ.prod ν)) : ∫ (x : α), F (∫ (y : β), f (x, y) + g (x, y) ∂ν) ∂μ = ∫ (x : α), F (∫ (y : β), f (x, y) ∂ν + ∫ (y : β), g (x, y) ∂ν) ∂μ
theorem monoid_hom.coe_inj {M : Type u_3} {N : Type u_4} [mul_one_class M] [mul_one_class N] ⦃f g : M →* N⦄ (h : ⇑f = ⇑g) : f = g
theorem eq.trans_lt {α : Type u} [preorder α] {a b c : α} (hab : a = b) (hbc : b < c) : a < c
theorem nnreal.young_inequality (a b : nnreal) {p q : nnreal} (hp : 1 < p) (hpq : 1 / p + 1 / q = 1) : a * b ≤ a ^ ↑p / p + b ^ ↑q / q
theorem cardinal.mk_real  : cardinal.mk ℝ = cardinal.continuum
theorem add_submonoid.localization_map.add_neg_left {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {f : M →+ N} (h : ∀ (y : ↥S), is_add_unit (⇑f ↑y)) (y : ↥S) (w z : N) : w + ↑-⇑(is_add_unit.lift_right (f.restrict S) h) y = z ↔ w = ⇑f ↑y + z
theorem box_integral.has_integral_of_mul {ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} {y : F} (a : ℝ) (h : ∀ (ε : ℝ), 0 < ε → (∃ (r : nnreal → (ι → ℝ) → ↥(set.Ioi 0)), (∀ (c : nnreal), l.r_cond (r c)) ∧ ∀ (c : nnreal) (π : box_integral.tagged_prepartition I), l.mem_base_set I c (r c) π → π.is_partition → has_dist.dist (box_integral.integral_sum f vol π) y ≤ a * ε)) : box_integral.has_integral I l f vol y
theorem finite_dimensional.span_of_finite (K : Type u) {V : Type v} [division_ring K] [add_comm_group V] [module K V] {A : set V} (hA : A.finite) : finite_dimensional K ↥(submodule.span K A)
theorem lipschitz_on_with.extend_finite_dimension {α : Type u_1} [pseudo_metric_space α] {E' : Type u_2} [normed_group E'] [normed_space ℝ E'] [finite_dimensional ℝ E'] {s : set α} {f : α → E'} {K : nnreal} (hf : lipschitz_on_with K f s) : ∃ (g : α → E'), lipschitz_with (lipschitz_extension_constant E' * K) g ∧ set.eq_on f g s
theorem local_homeomorph.eq_on_source.trans' {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] {e e' : local_homeomorph α β} {f f' : local_homeomorph β γ} (he : e ≈ e') (hf : f ≈ f') : e.trans f ≈ e'.trans f'
theorem supr_eq_of_forall_le_of_forall_lt_exists_gt {α : Type u_1} {ι : Sort u_4} [complete_lattice α] {b : α} {f : ι → α} (h₁ : ∀ (i : ι), f i ≤ b) (h₂ : ∀ (w : α), w < b → (∃ (i : ι), w < f i)) : (⨆ (i : ι), f i) = b
theorem euclidean_geometry.orthogonal_projection_vadd_eq_self {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} [nonempty ↥s] [complete_space ↥(s.direction)] {p : P} (hp : p ∈ s) {v : V} (hv : v ∈ (s.direction)ᗮ) : ⇑(euclidean_geometry.orthogonal_projection s) (v +ᵥ p) = ⟨p, hp⟩
theorem mv_polynomial.exists_fin_rename {σ : Type u_1} {R : Type u_4} [comm_semiring R] (p : mv_polynomial σ R) : ∃ (n : ℕ) (f : fin n → σ) (hf : function.injective f) (q : mv_polynomial (fin n) R), p = ⇑(mv_polynomial.rename f) q
theorem entrywise_sup_norm_bound_of_unitary {𝕜 : Type u_1} {n : Type u_3} [is_R_or_C 𝕜] [fintype n] [decidable_eq n] {U : matrix n n 𝕜} (hU : U ∈ matrix.unitary_group n 𝕜) : ∥U∥ ≤ 1
theorem category_theory.limits.eq_of_mono_cofork_π {C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} (t : category_theory.limits.cofork f g) [category_theory.mono t.π] : f = g
theorem measure_theory.measure.inner_regular.weakly_regular_of_finite {α : Type u_1} [measurable_space α] [topological_space α] [borel_space α] (μ : measure_theory.measure α) [measure_theory.is_finite_measure μ] (H : μ.inner_regular is_closed is_open) : μ.weakly_regular
theorem exp_eq_exp (𝕂 : Type u_1) (𝕂' : Type u_2) (𝔸 : Type u_3) [field 𝕂] [field 𝕂'] [ring 𝔸] [algebra 𝕂 𝔸] [algebra 𝕂' 𝔸] [topological_space 𝔸] [topological_ring 𝔸] : exp 𝕂 = exp 𝕂'
theorem has_deriv_within_at.Ioi_of_Ioo {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {F : Type v} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {f' : F} [linear_order 𝕜] [order_closed_topology 𝕜] {x y : 𝕜} (h : x < y) : has_deriv_within_at f f' (set.Ioo x y) x → has_deriv_within_at f f' (set.Ioi x) x
theorem is_compact.elim_finite_subcover_image {α : Type u} {ι : Type u_1} [topological_space α] {s : set α} {b : set ι} {c : ι → set α} (hs : is_compact s) (hc₁ : ∀ (i : ι), i ∈ b → is_open (c i)) (hc₂ : s ⊆ ⋃ (i : ι) (H : i ∈ b), c i) : ∃ (b' : set ι) (H : b' ⊆ b), b'.finite ∧ s ⊆ ⋃ (i : ι) (H : i ∈ b'), c i
theorem submonoid.localization_map.lift_spec_mul {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M →* P} (hg : ∀ (y : ↥S), is_unit (⇑g ↑y)) (z : N) (w v : P) : ⇑(f.lift hg) z * w = v ↔ ⇑g (f.sec z).fst * w = ⇑g ↑((f.sec z).snd) * v
theorem category_theory.presieve.extend_agrees {C : Type u₁} [category_theory.category C] {P : Cᵒᵖ ⥤ Type w} {X Y : C} {R : category_theory.presieve X} {x : category_theory.presieve.family_of_elements P R} (t : x.compatible) {f : Y ⟶ X} (hf : R f) : x.sieve_extend f _ = x f hf
theorem list.length_le_sum_of_one_le (L : list ℕ) (h : ∀ (i : ℕ), i ∈ L → 1 ≤ i) : L.length ≤ L.sum
theorem measure_theory.tendsto_lintegral_of_dominated_convergence {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {F : ℕ → α → ennreal} {f : α → ennreal} (bound : α → ennreal) (hF_meas : ∀ (n : ℕ), measurable (F n)) (h_bound : ∀ (n : ℕ), F n ≤ᵐ[μ] bound) (h_fin : ∫⁻ (a : α), bound a ∂μ ≠ ⊤) (h_lim : ∀ᵐ (a : α) ∂μ, filter.tendsto (λ (n : ℕ), F n a) filter.at_top (nhds (f a))) : filter.tendsto (λ (n : ℕ), ∫⁻ (a : α), F n a ∂μ) filter.at_top (nhds (∫⁻ (a : α), f a ∂μ))
theorem subring.list_sum_mem {R : Type u} [ring R] (s : subring R) {l : list R} : (∀ (x : R), x ∈ l → x ∈ s) → l.sum ∈ s
theorem same_ray.norm_add {E : Type u_1} [semi_normed_group E] [normed_space ℝ E] {x y : E} (h : same_ray ℝ x y) : ∥x + y∥ = ∥x∥ + ∥y∥
theorem linear_map.mul_eq_one_of_mul_eq_one {K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {f g : V →ₗ[K] V} (hfg : f * g = 1) : g * f = 1
theorem has_fpower_series_at.is_O_image_sub_norm_mul_norm_sub {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] {f : E → F} {p : formal_multilinear_series 𝕜 E F} {x : E} (hf : has_fpower_series_at f p x) : (λ (y : E × E), f y.fst - f y.snd - ⇑(p 1) (λ (_x : fin 1), y.fst - y.snd)) =O[nhds (x, x)] λ (y : E × E), ∥y - (x, x)∥ * ∥y.fst - y.snd∥
theorem linear_recurrence.eq_mk_of_is_sol_of_eq_init {α : Type u_1} [comm_semiring α] (E : linear_recurrence α) {u : ℕ → α} {init : fin E.order → α} (h : E.is_solution u) (heq : ∀ (n : fin E.order), u ↑n = init n) (n : ℕ) : u n = E.mk_sol init n
theorem measure_theory.integral_add_right_eq_self {G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure G} [add_group G] [has_measurable_add G] [μ.is_add_right_invariant] (f : G → E) (g : G) : ∫ (x : G), f (x + g) ∂μ = ∫ (x : G), f x ∂μ
theorem cont_diff_succ_iff_fderiv {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {n : ℕ} : cont_diff 𝕜 ↑(n + 1) f ↔ differentiable 𝕜 f ∧ cont_diff 𝕜 ↑n (λ (y : E), fderiv 𝕜 f y)
theorem measure_theory.exists_measurable_le_lintegral_eq {α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) (f : α → ennreal) : ∃ (g : α → ennreal), measurable g ∧ g ≤ f ∧ ∫⁻ (a : α), f a ∂μ = ∫⁻ (a : α), g a ∂μ
theorem submodule.nonempty_basis_of_pid {R : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {M : Type u_3} [add_comm_group M] [module R M] {ι : Type u_1} [fintype ι] (b : basis ι R M) (N : submodule R M) : ∃ (n : ℕ), nonempty (basis (fin n) R ↥N)
theorem finset.sum_cancels_of_partition_cancels {β : Type u} {α : Type v} {s : finset α} {f : α → β} [add_comm_monoid β] (R : setoid α) [decidable_rel setoid.r] (h : ∀ (x : α), x ∈ s → (finset.filter (λ (y : α), y ≈ x) s).sum (λ (a : α), f a) = 0) : s.sum (λ (x : α), f x) = 0
theorem clifford_algebra.odd_induction {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) {P : Π (x : clifford_algebra Q), x ∈ clifford_algebra.even_odd Q 1 → Prop} (hι : ∀ (v : M), P (⇑(clifford_algebra.ι Q) v) _) (hadd : ∀ {x y : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 1} {hy : y ∈ clifford_algebra.even_odd Q 1}, P x hx → P y hy → P (x + y) _) (hιι_mul : ∀ (m₁ m₂ : M) {x : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 1}, P x hx → P (⇑(clifford_algebra.ι Q) m₁ * ⇑(clifford_algebra.ι Q) m₂ * x) _) (x : clifford_algebra Q) (hx : x ∈ clifford_algebra.even_odd Q 1) : P x hx
theorem has_scalar.comp.smul_comm_class' {M : Type u_1} {N : Type u_2} {α : Type u_6} {β : Type u_7} [has_scalar M α] [has_scalar β α] [smul_comm_class β M α] (g : N → M) : smul_comm_class β N α
theorem matrix.nondegenerate_of_det_ne_zero {m : Type u_1} {A : Type u_3} [fintype m] [comm_ring A] [is_domain A] [decidable_eq m] {M : matrix m m A} (hM : M.det ≠ 0) : M.nondegenerate
theorem local_equiv.eq_on_source.symm' {α : Type u_1} {β : Type u_2} {e e' : local_equiv α β} (h : e ≈ e') : e.symm ≈ e'.symm
theorem emetric.Hausdorff_edist_closure {α : Type u} [pseudo_emetric_space α] {s t : set α} : emetric.Hausdorff_edist (closure s) (closure t) = emetric.Hausdorff_edist s t
theorem sub_mul_action.stabilizer_of_sub_mul.submonoid {R : Type u} {M : Type v} [monoid R] [mul_action R M] {p : sub_mul_action R M} (m : ↥p) : mul_action.stabilizer.submonoid R m = mul_action.stabilizer.submonoid R ↑m
theorem finset.sum_card_le {α : Type u_2} [decidable_eq α] {B : finset (finset α)} {n : ℕ} [fintype α] (h : ∀ (a : α), (finset.filter (has_mem.mem a) B).card ≤ n) : B.sum (λ (s : finset α), s.card) ≤ fintype.card α * n
theorem is_nilpotent_of_ker_le_center {G : Type u_1} [group G] {H : Type u_2} [group H] (f : G →* H) (hf1 : f.ker ≤ subgroup.center G) (hH : group.is_nilpotent H) : group.is_nilpotent G
theorem le_inv_of_le_inv {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} : a ≤ b⁻¹ → b ≤ a⁻¹
theorem antilipschitz_with.proper_space {β : Type u_2} [pseudo_metric_space β] {α : Type u_1} [metric_space α] {K : nnreal} {f : α → β} [proper_space α] (hK : antilipschitz_with K f) (f_cont : continuous f) (hf : function.surjective f) : proper_space β
theorem emetric.closeds.edist_eq {α : Type u} [emetric_space α] {s t : topological_space.closeds α} : has_edist.edist s t = emetric.Hausdorff_edist ↑s ↑t
theorem subsemiring.zero_mem {R : Type u} [non_assoc_semiring R] (s : subsemiring R) : 0 ∈ s
theorem measure_theory.outer_measure.mk_metric'.trim_pre {X : Type u_2} [emetric_space X] [measurable_space X] [opens_measurable_space X] (m : set X → ennreal) (hcl : ∀ (s : set X), m (closure s) = m s) (r : ennreal) : (measure_theory.outer_measure.mk_metric'.pre m r).trim = measure_theory.outer_measure.mk_metric'.pre m r
theorem submodule.exists_smith_normal_form_of_le {ι : Type u_1} {R : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {M : Type u_3} [add_comm_group M] [module R M] [fintype ι] (b : basis ι R M) (N O : submodule R M) (N_le_O : N ≤ O) : ∃ (n o : ℕ) (hno : n ≤ o) (bO : basis (fin o) R ↥O) (bN : basis (fin n) R ↥N) (a : fin n → R), ∀ (i : fin n), ↑(⇑bN i) = a i • ↑(⇑bO (⇑(fin.cast_le hno) i))
theorem compact_exists_clopen_in_open {α : Type u} [topological_space α] [t2_space α] [compact_space α] [totally_disconnected_space α] {x : α} {U : set α} (is_open : _root_.is_open U) (memU : x ∈ U) : ∃ (V : set α) (hV : is_clopen V), x ∈ V ∧ V ⊆ U
theorem matrix.transpose_has_orthogonal_cols_iff_has_orthogonal_rows {α : Type u_1} {n : Type u_2} {m : Type u_3} [has_mul α] [add_comm_monoid α] (A : matrix m n α) [fintype n] : A.transpose.has_orthogonal_cols ↔ A.has_orthogonal_rows
theorem cont_diff_within_at.prod_map' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : with_top ℕ} {E' : Type u_6} [normed_group E'] [normed_space 𝕜 E'] {F' : Type u_7} [normed_group F'] [normed_space 𝕜 F'] {s : set E} {t : set E'} {f : E → F} {g : E' → F'} {p : E × E'} (hf : cont_diff_within_at 𝕜 n f s p.fst) (hg : cont_diff_within_at 𝕜 n g t p.snd) : cont_diff_within_at 𝕜 n (prod.map f g) (s ×ˢ t) p
theorem reflection_map_apply {𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} {E' : Type u_3} [inner_product_space 𝕜 E] [inner_product_space 𝕜 E'] (f : E ≃ₗᵢ[𝕜] E') (K : submodule 𝕜 E) [complete_space ↥K] (x : E') : ⇑(reflection (submodule.map ↑(f.to_linear_equiv) K)) x = ⇑f (⇑(reflection K) (⇑(f.symm) x))
theorem inner_add_add_self {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x y : E} : has_inner.inner (x + y) (x + y) = has_inner.inner x x + has_inner.inner x y + has_inner.inner y x + has_inner.inner y y
theorem is_add_group_hom.neg {α : Type u_1} {β : Type u_2} [add_group α] [add_comm_group β] {f : α → β} (hf : is_add_group_hom f) : is_add_group_hom (λ (a : α), -f a)
theorem affine.triangle.altitude_replace_orthocenter_eq_affine_span {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {t₁ t₂ : affine.triangle ℝ P} {i₁ i₂ i₃ j₁ j₂ j₃ : fin 3} (hi₁₂ : i₁ ≠ i₂) (hi₁₃ : i₁ ≠ i₃) (hi₂₃ : i₂ ≠ i₃) (hj₁₂ : j₁ ≠ j₂) (hj₁₃ : j₁ ≠ j₃) (hj₂₃ : j₂ ≠ j₃) (h₁ : t₂.points j₁ = t₁.orthocenter) (h₂ : t₂.points j₂ = t₁.points i₂) (h₃ : t₂.points j₃ = t₁.points i₃) : affine.simplex.altitude t₂ j₂ = affine_span ℝ {t₁.points i₁, t₁.points i₂}
theorem function.Sup_div_semiconj {α : Type u_1} {G : Type u_4} [complete_lattice α] [group G] (f₁ f₂ : G →* α ≃o α) (g : G) : function.semiconj (λ (x : α), ⨆ (g' : G), ⇑(⇑f₁ g')⁻¹ (⇑(⇑f₂ g') x)) ⇑(⇑f₂ g) ⇑(⇑f₁ g)
theorem left.one_le_mul {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b
theorem has_fpower_series_on_ball.uniform_geometric_approx {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] {f : E → F} {p : formal_multilinear_series 𝕜 E F} {x : E} {r : ennreal} {r' : nnreal} (hf : has_fpower_series_on_ball f p x r) (h : ↑r' < r) : ∃ (a : ℝ) (H : a ∈ set.Ioo 0 1) (C : ℝ) (H : C > 0), ∀ (y : E), y ∈ metric.ball 0 ↑r' → ∀ (n : ℕ), ∥f (x + y) - p.partial_sum n y∥ ≤ C * a ^ n
theorem zmod.legendre_sym_eq_neg_one_iff (p : ℕ) [fact (nat.prime p)] {a : ℤ} : zmod.legendre_sym p a = -1 ↔ ¬is_square ↑a
theorem dense_inducing.extend_eq' {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] {i : α → β} [topological_space γ] [t2_space γ] {f : α → γ} (di : dense_inducing i) (hf : ∀ (b : β), ∃ (c : γ), filter.tendsto f (filter.comap i (nhds b)) (nhds c)) (a : α) : di.extend f (i a) = f a
theorem polynomial.eval_prod {R : Type u} [comm_semiring R] {ι : Type u_1} (s : finset ι) (p : ι → polynomial R) (x : R) : polynomial.eval x (s.prod (λ (j : ι), p j)) = s.prod (λ (j : ι), polynomial.eval x (p j))
theorem is_min.eq_bot {α : Type u} [partial_order α] [order_bot α] {a : α} : is_min a → a = ⊥
theorem Top.presheaf.is_iso_iff_stalk_functor_map_iso {C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X : Top} [category_theory.concrete_category C] [category_theory.limits.preserves_filtered_colimits (category_theory.forget C)] [category_theory.limits.has_limits C] [category_theory.limits.preserves_limits (category_theory.forget C)] [category_theory.reflects_isomorphisms (category_theory.forget C)] {F G : Top.sheaf C X} (f : F ⟶ G) : category_theory.is_iso f ↔ ∀ (x : ↥X), category_theory.is_iso ((Top.presheaf.stalk_functor C x).map f)
theorem metric.thickening_cthickening_subset {α : Type u} [pseudo_emetric_space α] {δ : ℝ} (ε : ℝ) (hδ : 0 ≤ δ) (s : set α) : metric.thickening ε (metric.cthickening δ s) ⊆ metric.thickening (ε + δ) s
theorem category_theory.is_pushout.of_bot {C : Type u₁} [category_theory.category C] {X₁₁ X₁₂ X₂₁ X₂₂ X₃₁ X₃₂ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₂₁ : X₂₁ ⟶ X₂₂} {h₃₁ : X₃₁ ⟶ X₃₂} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₂₁ : X₂₁ ⟶ X₃₁} {v₂₂ : X₂₂ ⟶ X₃₂} (s : category_theory.is_pushout h₁₁ (v₁₁ ≫ v₂₁) (v₁₂ ≫ v₂₂) h₃₁) (p : h₂₁ ≫ v₂₂ = v₂₁ ≫ h₃₁) (t : category_theory.is_pushout h₁₁ v₁₁ v₁₂ h₂₁) : category_theory.is_pushout h₂₁ v₂₁ v₂₂ h₃₁
theorem ring_hom.map_add {α : Type u_2} {β : Type u_3} {rα : non_assoc_semiring α} {rβ : non_assoc_semiring β} (f : α →+* β) (a b : α) : ⇑f (a + b) = ⇑f a + ⇑f b
theorem measure_theory.measure.ext_of_Ico_finite {α : Type u_1} [topological_space α] {m : measurable_space α} [topological_space.second_countable_topology α] [linear_order α] [order_topology α] [borel_space α] (μ ν : measure_theory.measure α) [measure_theory.is_finite_measure μ] (hμν : ⇑μ set.univ = ⇑ν set.univ) (h : ∀ ⦃a b : α⦄, a < b → ⇑μ (set.Ico a b) = ⇑ν (set.Ico a b)) : μ = ν
theorem matrix.sum_cramer_apply {n : Type u} [decidable_eq n] [fintype n] {α : Type v} [comm_ring α] (A : matrix n n α) {β : Type u_1} (s : finset β) (f : n → β → α) (i : n) : s.sum (λ (x : β), ⇑(A.cramer) (λ (j : n), f j x) i) = ⇑(A.cramer) (λ (j : n), s.sum (λ (x : β), f j x)) i
theorem list.nth_le_take' {α : Type u} (L : list α) {i j : ℕ} (hi : i < (list.take j L).length) : (list.take j L).nth_le i hi = L.nth_le i _
theorem has_btw.btw.not_sbtw {α : Type u_1} [circular_preorder α] {a b c : α} (h : has_btw.btw a b c) : ¬has_sbtw.sbtw c b a
theorem orientation.rotation_oangle_eq_iff_norm_eq {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x y : V) : ⇑(o.rotation (o.oangle x y)) x = y ↔ ∥x∥ = ∥y∥
theorem summable_norm_iff {α : Type u_1} {E : Type u_2} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {f : α → E} : summable (λ (x : α), ∥f x∥) ↔ summable f
theorem semiconj_by.units_inv_right {M : Type u} [monoid M] {a : M} {x y : Mˣ} (h : semiconj_by a ↑x ↑y) : semiconj_by a ↑x⁻¹ ↑y⁻¹
theorem linear_map.det_conj {M : Type u_2} [add_comm_group M] {A : Type u_5} [comm_ring A] [module A M] {N : Type u_1} [add_comm_group N] [module A N] (f : M →ₗ[A] M) (e : M ≃ₗ[A] N) : ⇑linear_map.det (↑e.comp (f.comp ↑(e.symm))) = ⇑linear_map.det f
theorem is_primitive_root.minpoly_dvd_cyclotomic {n : ℕ} {K : Type u_1} [field K] {μ : K} (h : is_primitive_root μ n) (hpos : 0 < n) [char_zero K] : minpoly ℤ μ ∣ polynomial.cyclotomic n ℤ
theorem star_isometry {E : Type u_2} [semi_normed_group E] [star_add_monoid E] [normed_star_group E] : isometry has_star.star
theorem real.volume_preserving_transvection_struct {ι : Type u_1} [fintype ι] [decidable_eq ι] (t : matrix.transvection_struct ι ℝ) : measure_theory.measure_preserving ⇑(⇑matrix.to_lin' t.to_matrix) measure_theory.measure_space.volume measure_theory.measure_space.volume
theorem continuous_map.continuous_coe {α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β] : continuous coe_fn
theorem category_theory.over.mono_of_mono_left {T : Type u₁} [category_theory.category T] {X : T} {f g : category_theory.over X} (k : f ⟶ g) [hk : category_theory.mono k.left] : category_theory.mono k
theorem pequiv.injective_of_forall_ne_is_some {α : Type u} {β : Type v} (f : α ≃. β) (a₂ : α) (h : ∀ (a₁ : α), a₁ ≠ a₂ → ↥((⇑f a₁).is_some)) : function.injective ⇑f
theorem has_fpower_series_on_ball.is_O_image_sub_image_sub_deriv_principal {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] {f : E → F} {p : formal_multilinear_series 𝕜 E F} {x : E} {r r' : ennreal} (hf : has_fpower_series_on_ball f p x r) (hr : r' < r) : (λ (y : E × E), f y.fst - f y.snd - ⇑(p 1) (λ (_x : fin 1), y.fst - y.snd)) =O[filter.principal (emetric.ball (x, x) r')] λ (y : E × E), ∥y - (x, x)∥ * ∥y.fst - y.snd∥
theorem left.add_pos' {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
theorem same_ray_of_mem_orbit {R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {v₁ v₂ : M} (h : v₁ ∈ mul_action.orbit ↥(units.pos_subgroup R) v₂) : same_ray R v₁ v₂
theorem category_theory.limits.has_finite_wide_pushouts_of_has_finite_limits (C : Type u) [category_theory.category C] [category_theory.limits.has_finite_colimits C] : category_theory.limits.has_finite_wide_pushouts C
theorem formal_multilinear_series.apply_composition_update {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [comm_ring 𝕜] [add_comm_group E] [add_comm_group F] [module 𝕜 E] [module 𝕜 F] [topological_space E] [topological_space F] [topological_add_group E] [has_continuous_const_smul 𝕜 E] [topological_add_group F] [has_continuous_const_smul 𝕜 F] (p : formal_multilinear_series 𝕜 E F) {n : ℕ} (c : composition n) (j : fin n) (v : fin n → E) (z : E) : p.apply_composition c (function.update v j z) = function.update (p.apply_composition c v) (c.index j) (⇑(p (c.blocks_fun (c.index j))) (function.update (v ∘ ⇑(c.embedding (c.index j))) (c.inv_embedding j) z))
theorem set.nonempty.of_closure {α : Type u} [topological_space α] {s : set α} : (closure s).nonempty → s.nonempty
theorem pgame.lf.le {x y : pgame} (h : x.lf y) (ox : x.numeric) (oy : y.numeric) : x ≤ y
theorem fin.find_spec {n : ℕ} (p : fin n → Prop) [decidable_pred p] {i : fin n} (hi : i ∈ fin.find p) : p i
theorem eq_of_tendsto_nhds {α : Type u} {β : Type v} [topological_space α] [topological_space β] [t1_space β] {f : α → β} {a : α} {b : β} (h : filter.tendsto f (nhds a) (nhds b)) : f a = b
theorem is_localization.exist_integer_multiples_of_fintype {R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] {ι : Type u_3} [fintype ι] (f : ι → S) : ∃ (b : ↥M), ∀ (i : ι), is_localization.is_integer R (↑b • f i)
theorem measure_theory.measure.measure_ae_null_of_prod_null {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] {s : set (α × β)} (h : ⇑(μ.prod ν) s = 0) : (λ (x : α), ⇑ν (prod.mk x ⁻¹' s)) =ᵐ[μ] 0
theorem list.nodup.sublists' {α : Type u} {l : list α} : l.nodup → l.sublists'.nodup
theorem measure_theory.measure.sub_mem_nhds_zero_of_add_haar_pos {G : Type u_1} [add_group G] [topological_space G] [t2_space G] [topological_add_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] (μ : measure_theory.measure G) [μ.is_add_haar_measure] [locally_compact_space G] (E : set G) (hE : measurable_set E) (hEpos : 0 < ⇑μ E) : E - E ∈ nhds 0
theorem lie_submodule.lie_ideal_oper_eq_tensor_map_range {R : Type u} [comm_ring R] {L : Type v} {M : Type w} [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (I : lie_ideal R L) (N : lie_submodule R L M) : ⁅I,N⁆ = ((lie_module.to_module_hom R L M).comp (tensor_product.lie_module.map_incl I N)).range
theorem power_basis.to_matrix_is_integral {K : Type u_1} {S : Type u_2} [field K] [comm_ring S] [algebra K S] {R : Type u_3} [comm_ring R] [algebra R S] [algebra R K] [is_scalar_tower R K S] {B B' : power_basis K S} {P : polynomial R} (h : ⇑(polynomial.aeval B.gen) P = B'.gen) (hB : is_integral R B.gen) (hmin : minpoly K B.gen = polynomial.map (algebra_map R K) (minpoly R B.gen)) (i : fin B.dim) (j : fin B'.dim) : is_integral R (B.basis.to_matrix ⇑(B'.basis) i j)
theorem measure_theory.unif_integrable_subsingleton {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} [subsingleton ι] (hp_one : 1 ≤ p) (hp_top : p ≠ ⊤) {f : ι → α → β} (hf : ∀ (i : ι), measure_theory.mem_ℒp (f i) p μ) : measure_theory.unif_integrable f p μ
theorem ring_hom.mem_ker {R : Type u} {S : Type v} [semiring R] [semiring S] (f : R →+* S) {r : R} : r ∈ f.ker ↔ ⇑f r = 0
theorem subfield.sum_mem {K : Type u} [field K] (s : subfield K) {ι : Type u_1} {t : finset ι} {f : ι → K} (h : ∀ (c : ι), c ∈ t → f c ∈ s) : t.sum (λ (i : ι), f i) ∈ s
theorem quiver.hom.le {X : Type u} [preorder X] {x y : X} (h : x ⟶ y) : x ≤ y
theorem mv_power_series.ext {σ : Type u_1} {R : Type u_2} [semiring R] {φ ψ : mv_power_series σ R} (h : ∀ (n : σ →₀ ℕ), ⇑(mv_power_series.coeff R n) φ = ⇑(mv_power_series.coeff R n) ψ) : φ = ψ
theorem cont_diff.has_strict_fderiv_at {n : with_top ℕ} {𝕂 : Type u_6} [is_R_or_C 𝕂] {E' : Type u_7} [normed_group E'] [normed_space 𝕂 E'] {F' : Type u_8} [normed_group F'] [normed_space 𝕂 F'] {f : E' → F'} {x : E'} (hf : cont_diff 𝕂 n f) (hn : 1 ≤ n) : has_strict_fderiv_at f (fderiv 𝕂 f x) x
theorem linear_map.span_preimage_le {R : Type u_1} {R₂ : Type u_2} {M : Type u_4} {M₂ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring R₂] {σ₁₂ : R →+* R₂} [add_comm_monoid M₂] [module R₂ M₂] (f : M →ₛₗ[σ₁₂] M₂) (s : set M₂) : submodule.span R (⇑f ⁻¹' s) ≤ submodule.comap f (submodule.span R₂ s)
theorem is_add_submonoid.image {M : Type u_1} [add_monoid M] {γ : Type u_2} [add_monoid γ] {f : M → γ} (hf : is_add_monoid_hom f) {s : set M} (hs : is_add_submonoid s) : is_add_submonoid (f '' s)
theorem convex_on_of_deriv2_nonneg {D : set ℝ} (hD : convex ℝ D) {f : ℝ → ℝ} (hf : continuous_on f D) (hf' : differentiable_on ℝ f (interior D)) (hf'' : differentiable_on ℝ (deriv f) (interior D)) (hf''_nonneg : ∀ (x : ℝ), x ∈ interior D → 0 ≤ deriv^[2] f x) : convex_on ℝ D f
theorem complex.circle_integral_eq_zero_of_differentiable_on_off_countable {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] {R : ℝ} (h0 : 0 ≤ R) {f : ℂ → E} {c : ℂ} {s : set ℂ} (hs : s.countable) (hc : continuous_on f (metric.closed_ball c R)) (hd : ∀ (z : ℂ), z ∈ metric.ball c R  s → differentiable_at ℂ f z) : ∮ (z : ℂ) in C(c, R), f z = 0
theorem antivary_on.sum_mul_le_sum_comp_perm_mul {ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {s : finset ι} {σ : equiv.perm ι} {f g : ι → α} (hfg : antivary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i * g i) ≤ s.sum (λ (i : ι), f (⇑σ i) * g i)
theorem is_ring_hom.id {α : Type u} [ring α] : is_ring_hom id
theorem strict_convex_on.sup {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [linear_ordered_add_comm_monoid β] [has_scalar 𝕜 E] [module 𝕜 β] [ordered_smul 𝕜 β] {s : set E} {f g : E → β} (hf : strict_convex_on 𝕜 s f) (hg : strict_convex_on 𝕜 s g) : strict_convex_on 𝕜 s (f ⊔ g)
theorem intermediate_field.one_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) : 1 ∈ S
theorem mul_self_mul_inv {G₀ : Type u_2} [group_with_zero G₀] (a : G₀) : a * a * a⁻¹ = a
theorem algebra.discr_eq_discr_of_to_matrix_coeff_is_integral {ι : Type w} {ι' : Type u_1} [fintype ι'] [fintype ι] (K : Type u) [field K] [number_field K] {b : basis ι ℚ K} {b' : basis ι' ℚ K} (h : ∀ (i : ι) (j : ι'), is_integral ℤ (b.to_matrix ⇑b' i j)) (h' : ∀ (i : ι') (j : ι), is_integral ℤ (b'.to_matrix ⇑b i j)) : algebra.discr ℚ ⇑b = algebra.discr ℚ ⇑b'
theorem formal_multilinear_series.min_radius_le_radius_add {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] (p q : formal_multilinear_series 𝕜 E F) : linear_order.min p.radius q.radius ≤ (p + q).radius
theorem setoid.ker_mk_eq {α : Type u_1} (r : setoid α) : setoid.ker quotient.mk = r
theorem measure_theory.measure.inner_regular.of_pseudo_emetric_space {X : Type u_1} [pseudo_emetric_space X] [measurable_space X] (μ : measure_theory.measure X) : μ.inner_regular is_closed is_open
theorem clifford_algebra_complex.to_complex_involute (c : clifford_algebra clifford_algebra_complex.Q) : ⇑clifford_algebra_complex.to_complex (⇑clifford_algebra.involute c) = ⇑(star_ring_end ℂ) (⇑clifford_algebra_complex.to_complex c)
theorem formal_multilinear_series.right_inv_remove_zero {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) (i : E ≃L[𝕜] F) : p.remove_zero.right_inv i = p.right_inv i
theorem measure_theory.ae_measurable_fderiv_within {E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {s : set E} {f : E → E} {f' : E → (E →L[ℝ] E)} [measurable_space E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (hs : measurable_set s) (hf' : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) : ae_measurable f' (μ.restrict s)
theorem nat.totient_eq_prod_factorization {n : ℕ} (hn : n ≠ 0) : n.totient = n.factorization.prod (λ (p k : ℕ), p ^ (k - 1) * (p - 1))
theorem category_theory.cosimplicial_object.σ_comp_σ {C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) {n : ℕ} {i j : fin (n + 1)} (H : i ≤ j) : X.σ (⇑fin.cast_succ i) ≫ X.σ j = X.σ j.succ ≫ X.σ i
theorem mul_add_mul_le_mul_add_mul {α : Type u} [ordered_semiring α] {a b c d : α} [has_exists_add_of_le α] (hab : a ≤ b) (hcd : c ≤ d) : a * d + b * c ≤ a * c + b * d
theorem strict_mono.strict_anti_iterate_of_map_lt {α : Type u_1} [preorder α] {f : α → α} {x : α} (hf : strict_mono f) (hx : f x < x) : strict_anti (λ (n : ℕ), f^[n] x)
theorem unique_mdiff_on.unique_mdiff_on_preimage {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {s : set M} [smooth_manifold_with_corners I' M'] (hs : unique_mdiff_on I s) {e : local_homeomorph M M'} (he : local_homeomorph.mdifferentiable I I' e) : unique_mdiff_on I' (e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' s)
theorem strict_anti_on.strict_concave_on_of_deriv {D : set ℝ} (hD : convex ℝ D) {f : ℝ → ℝ} (hf : continuous_on f D) (hf' : differentiable_on ℝ f (interior D)) (h_anti : strict_anti_on (deriv f) (interior D)) : strict_concave_on ℝ D f
theorem measure_theory.map_prod_mul_inv_eq {G : Type u_1} [measurable_space G] [group G] [has_measurable_mul₂ G] (μ ν : measure_theory.measure G) [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] [has_measurable_inv G] [μ.is_mul_left_invariant] [ν.is_mul_left_invariant] : measure_theory.measure.map (λ (z : G × G), (z.snd * z.fst, (z.fst)⁻¹)) (μ.prod ν) = μ.prod ν
theorem continuous_at_matrix_inv {n : Type u_5} {R : Type u_8} [topological_space R] [fintype n] [decidable_eq n] [comm_ring R] [topological_ring R] (A : matrix n n R) (h : continuous_at ring.inverse A.det) : continuous_at has_inv.inv A
theorem add_subsemigroup.add_mem {M : Type u_1} [has_add M] (S : add_subsemigroup M) {x y : M} : x ∈ S → y ∈ S → x + y ∈ S
theorem monotone.mul' {α : Type u_1} {β : Type u_2} [has_mul α] [preorder α] [preorder β] {f g : β → α} [covariant_class α α has_mul.mul has_le.le] [covariant_class α α (function.swap has_mul.mul) has_le.le] (hf : monotone f) (hg : monotone g) : monotone (λ (x : β), f x * g x)
theorem finset.sum_range_sub_of_monotone {α : Type v} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] [contravariant_class α α has_add.add has_le.le] {f : ℕ → α} (h : monotone f) (n : ℕ) : (finset.range n).sum (λ (i : ℕ), f (i + 1) - f i) = f n - f 0
theorem quadratic_ne_zero_of_discrim_ne_sq {R : Type u_1} [comm_ring R] [is_domain R] {a b c : R} (h2 : 2 ≠ 0) (ha : a ≠ 0) (h : ∀ (s : R), discrim a b c ≠ s * s) (x : R) : a * x * x + b * x + c ≠ 0
theorem euclidean_geometry.orthocentric_system.affine_independent {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : set P} (ho : euclidean_geometry.orthocentric_system s) {p : fin 3 → P} (hps : set.range p ⊆ s) (hpi : function.injective p) : affine_independent ℝ p
theorem vector.to_list_scanl {n : ℕ} {α : Type u_1} {β : Type u_2} (f : β → α → β) (b : β) (v : vector α n) : (vector.scanl f b v).to_list = list.scanl f b v.to_list
theorem exists_nat_nat_continuous_surjective_of_complete_space (α : Type u_1) [metric_space α] [complete_space α] [topological_space.second_countable_topology α] [nonempty α] : ∃ (f : (ℕ → ℕ) → α), continuous f ∧ function.surjective f
theorem units.exists0' {G₀ : Type u_2} [group_with_zero G₀] {p : Π (g : G₀), g ≠ 0 → Prop} : (∃ (g : G₀) (hg : g ≠ 0), p g hg) ↔ ∃ (g : G₀ˣ), p ↑g _
theorem orientation.eq_rotation_self_iff_angle_eq_zero {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x : V} (hx : x ≠ 0) (θ : real.angle) : x = ⇑(o.rotation θ) x ↔ θ = 0
theorem affine_equiv.point_reflection_fixed_iff_of_injective_bit0 (k : Type u_1) {P₁ : Type u_2} {V₁ : Type u_6} [ring k] [add_comm_group V₁] [module k V₁] [add_torsor V₁ P₁] {x y : P₁} (h : function.injective bit0) : ⇑(affine_equiv.point_reflection k x) y = y ↔ y = x
theorem local_homeomorph.eq_on_source.restr {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {e e' : local_homeomorph α β} (he : e ≈ e') (s : set α) : e.restr s ≈ e'.restr s
theorem function.bijective.comp_left {α : Sort u} {β : Sort v} {γ : Sort w} {g : β → γ} (hg : function.bijective g) : function.bijective (function.comp g)
theorem measurable.ennreal_tsum {α : Type u_1} [measurable_space α] {ι : Type u_2} [encodable ι] {f : ι → α → ennreal} (h : ∀ (i : ι), measurable (f i)) : measurable (λ (x : α), ∑' (i : ι), f i x)
theorem is_local_extr_on.linear_dependent_of_has_strict_fderiv_at {E : Type u_1} [normed_group E] [normed_space ℝ E] [complete_space E] {φ : E → ℝ} {x₀ : E} {φ' : E →L[ℝ] ℝ} {ι : Type u_2} [fintype ι] {f : ι → E → ℝ} {f' : ι → (E →L[ℝ] ℝ)} (hextr : is_local_extr_on φ {x : E | ∀ (i : ι), f i x = f i x₀} x₀) (hf' : ∀ (i : ι), has_strict_fderiv_at (f i) (f' i) x₀) (hφ' : has_strict_fderiv_at φ φ' x₀) : ¬linear_independent ℝ (option.elim φ' f')
theorem module.ray.units_smul_of_neg {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (u : Rˣ) (hu : ↑u < 0) (v : module.ray R M) : u • v = -v
theorem generalized_continued_fraction.coe_of_rat_eq {K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} {q : ℚ} (v_eq_q : v = ↑q) : {h := ↑((generalized_continued_fraction.of q).h), s := seq.map (generalized_continued_fraction.pair.map coe) (generalized_continued_fraction.of q).s} = generalized_continued_fraction.of v
theorem smul_mul_smul {M : Type u_1} {α : Type u_6} [monoid M] [mul_action M α] [has_mul α] (r s : M) (x y : α) [is_scalar_tower M α α] [smul_comm_class M α α] : r • x * s • y = (r * s) • (x * y)
theorem polynomial.add_submonoid_closure_set_of_eq_monomial {R : Type u} [semiring R] : add_submonoid.closure {p : polynomial R | ∃ (n : ℕ) (a : R), p = ⇑(polynomial.monomial n) a} = ⊤
theorem is_dedekind_domain.height_one_spectrum.int_valuation_le_pow_iff_dvd {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (r : R) (n : ℕ) : v.int_valuation_def r ≤ ↑(⇑multiplicative.of_add (-↑n)) ↔ v.as_ideal ^ n ∣ ideal.span {r}
theorem vector.scanl_val {n : ℕ} {α : Type u_1} {β : Type u_2} (f : β → α → β) (b : β) {v : vector α n} : (vector.scanl f b v).val = list.scanl f b v.val
theorem category_theory.limits.has_limits_of_shape_of_equivalence {J : Type u₁} [category_theory.category J] {C : Type u} [category_theory.category C] {J' : Type u₂} [category_theory.category J'] (e : J ≌ J') [category_theory.limits.has_limits_of_shape J C] : category_theory.limits.has_limits_of_shape J' C
theorem tactic.bicategory.coherence.assoc_lift_hom₂ {B : Type u} [category_theory.bicategory B] {a b : B} {f g h i : a ⟶ b} [category_theory.bicategory.lift_hom f] [category_theory.bicategory.lift_hom g] [category_theory.bicategory.lift_hom h] (η : f ⟶ g) (θ : g ⟶ h) (ι : h ⟶ i) [category_theory.bicategory.lift_hom₂ η] [category_theory.bicategory.lift_hom₂ θ] : η ≫ θ ≫ ι = (η ≫ θ) ≫ ι
theorem local_homeomorph.is_image.preimage_eq {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {e : local_homeomorph α β} {s : set α} {t : set β} : e.is_image s t → e.to_local_equiv.source ∩ ⇑e ⁻¹' t = e.to_local_equiv.source ∩ s
theorem box_integral.has_integral.tendsto {ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} {y : F} (h : box_integral.has_integral I l f vol y) : filter.tendsto (box_integral.integral_sum f vol) (l.to_filter_Union I ⊤) (nhds y)
theorem has_fderiv_within_at_of_not_mem_closure {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {x : E} {s : set E} (h : x ∉ closure s) : has_fderiv_within_at f f' s x
theorem con.con_gen_le {M : Type u_1} [has_mul M] {r : M → M → Prop} {c : con M} (h : ∀ (x y : M), r x y → setoid.r x y) : con_gen r ≤ c
theorem category_theory.Ran_is_sheaf_of_cover_lifting.glued_section_is_unique {C D : Type u} [category_theory.category C] [category_theory.category D] {A : Type w} [category_theory.category A] [category_theory.limits.has_limits A] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {G : C ⥤ D} (hu : category_theory.cover_lifting J K G) (ℱ : category_theory.Sheaf J A) {X : A} {U : D} {S : category_theory.sieve U} (hS : S ∈ ⇑K U) {x : category_theory.presieve.family_of_elements ((category_theory.Ran G.op).obj ℱ.val ⋙ category_theory.coyoneda.obj (opposite.op X)) S.arrows} (hx : x.compatible) (y : ((category_theory.Ran G.op).obj ℱ.val ⋙ category_theory.coyoneda.obj (opposite.op X)).obj (opposite.op U)) (hy : x.is_amalgamation y) : y = category_theory.Ran_is_sheaf_of_cover_lifting.glued_section hu ℱ hS hx
theorem int.le_self_pow_two (b : ℤ) : b ≤ b ^ 2
theorem is_closed.is_lub_mem {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {s : set α} (ha : is_lub s a) (hs : s.nonempty) (sc : is_closed s) : a ∈ s
theorem modular_group.one_lt_norm_sq_T_zpow_smul {z : upper_half_plane} (hz : z ∈ modular_group.fdo) (n : ℤ) : 1 < ⇑complex.norm_sq ↑(modular_group.T ^ n • z)
theorem tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm {α : Type u_1} [normed_ring α] [complete_space α] {f g : ℕ → α} (hf : summable (λ (x : ℕ), ∥f x∥)) (hg : summable (λ (x : ℕ), ∥g x∥)) : (∑' (n : ℕ), f n) * ∑' (n : ℕ), g n = ∑' (n : ℕ), (finset.nat.antidiagonal n).sum (λ (kl : ℕ × ℕ), f kl.fst * g kl.snd)
theorem smul_cancel_of_non_zero_divisor {M : Type u_1} {R : Type u_2} [monoid M] [non_unital_non_assoc_ring R] [distrib_mul_action M R] (k : M) (h : ∀ (x : R), k • x = 0 → x = 0) {a b : R} (h' : k • a = k • b) : a = b
theorem equiv.perm.is_three_cycle_sq_of_three_mem_cycle_type_five {g : equiv.perm (fin 5)} (h : 3 ∈ g.cycle_type) : (g * g).is_three_cycle
theorem category_theory.limits.initial_mono_class_of_disjoint_coproducts {C : Type u} [category_theory.category C] [category_theory.limits.coproducts_disjoint C] : category_theory.limits.initial_mono_class C
theorem is_localization.is_domain_of_le_non_zero_divisors {S : Type u_2} [comm_ring S] (A : Type u_6) [comm_ring A] [is_domain A] [algebra A S] {M : submonoid A} [is_localization M S] (hM : M ≤ non_zero_divisors A) : is_domain S
theorem orthonormal.exists_linear_isometry_equiv_map_eq_of_orientation_eq_neg {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {b₂ : basis (fin 2) ℝ V} (hb₂ : orthonormal ℝ ⇑b₂) (ho : b.orientation = -b₂.orientation) : ∃ (θ : real.angle), b₂ = b.map (hb.conj_lie.trans (hb.rotation θ)).to_linear_equiv
theorem measure_theory.L1.of_real_norm_sub_eq_lintegral {α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [normed_group β] (f g : ↥(measure_theory.Lp β 1 μ)) : ennreal.of_real ∥f - g∥ = ∫⁻ (x : α), ↑∥⇑f x - ⇑g x∥₊ ∂μ
theorem polynomial.cyclotomic_pos' (n : ℕ) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 < x) : 0 < polynomial.eval x (polynomial.cyclotomic n R)
theorem has_deriv_at_of_has_deriv_at_of_ne' {E : Type u_1} [normed_group E] [normed_space ℝ E] {f g : ℝ → E} {x : ℝ} (f_diff : ∀ (y : ℝ), y ≠ x → has_deriv_at f (g y) y) (hf : continuous_at f x) (hg : continuous_at g x) (y : ℝ) : has_deriv_at f (g y) y
theorem colex.forall_lt_of_colex_lt_of_forall_lt {α : Type u_1} [linear_order α] {A B : finset α} (t : α) (h₁ : A.to_colex < B.to_colex) (h₂ : ∀ (x : α), x ∈ B → x < t) (x : α) (H : x ∈ A) : x < t
theorem polynomial.lifts_iff_lifts_ring {R : Type u} [ring R] {S : Type v} [ring S] (f : R →+* S) (p : polynomial S) : p ∈ polynomial.lifts f ↔ p ∈ polynomial.lifts_ring f
theorem lt_tsub_of_add_lt_right {α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b c : α} [contravariant_class α α has_add.add has_le.le] (h : a + c < b) : a < b - c
theorem finset.prod_comp {β : Type u} {α : Type v} {γ : Type w} {s : finset α} [comm_monoid β] [decidable_eq γ] (f : γ → β) (g : α → γ) : s.prod (λ (a : α), f (g a)) = (finset.image g s).prod (λ (b : γ), f b ^ (finset.filter (λ (a : α), g a = b) s).card)
theorem subfield.closure_le {K : Type u} [field K] {s : set K} {t : subfield K} : subfield.closure s ≤ t ↔ s ⊆ ↑t
theorem filter.tendsto.at_bot_mul {α : Type u} {β : Type v} [linear_ordered_field α] [topological_space α] [order_topology α] {l : filter β} {f g : β → α} {C : α} (hC : 0 < C) (hf : filter.tendsto f l filter.at_bot) (hg : filter.tendsto g l (nhds C)) : filter.tendsto (λ (x : β), f x * g x) l filter.at_bot
theorem affine.simplex.circumcenter_eq_centroid {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (s : affine.simplex ℝ P 1) : s.circumcenter = finset.centroid ℝ finset.univ s.points
theorem measure_theory.exists_nonempty_inter_of_measure_univ_lt_sum_measure {α : Type u_1} {ι : Type u_5} {m : measurable_space α} (μ : measure_theory.measure α) {s : finset ι} {t : ι → set α} (h : ∀ (i : ι), i ∈ s → measurable_set (t i)) (H : ⇑μ set.univ < s.sum (λ (i : ι), ⇑μ (t i))) : ∃ (i : ι) (H : i ∈ s) (j : ι) (H : j ∈ s) (h : i ≠ j), (t i ∩ t j).nonempty
theorem summable_of_nonneg_of_le {β : Type u_2} {f g : β → ℝ} (hg : ∀ (b : β), 0 ≤ g b) (hgf : ∀ (b : β), g b ≤ f b) (hf : summable f) : summable g
theorem monovary.sum_smul_comp_perm_lt_sum_smul_iff {ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {σ : equiv.perm ι} {f : ι → α} {g : ι → β} [fintype ι] (hfg : monovary f g) : finset.univ.sum (λ (i : ι), f i • g (⇑σ i)) < finset.univ.sum (λ (i : ι), f i • g i) ↔ ¬monovary f (g ∘ ⇑σ)
theorem exists_locally_finite_subset_Union_ball_radius_lt {α : Type u} [metric_space α] [proper_space α] {s : set α} (hs : is_closed s) {R : α → ℝ} (hR : ∀ (x : α), x ∈ s → 0 < R x) : ∃ (ι : Type u) (c : ι → α) (r r' : ι → ℝ), (∀ (i : ι), c i ∈ s ∧ 0 < r i ∧ r i < r' i ∧ r' i < R (c i)) ∧ locally_finite (λ (i : ι), metric.ball (c i) (r' i)) ∧ s ⊆ ⋃ (i : ι), metric.ball (c i) (r i)
theorem monoid.closure_mono {M : Type u_1} [monoid M] {s t : set M} (h : s ⊆ t) : monoid.closure s ⊆ monoid.closure t
theorem line_map_lt_map_iff_slope_lt_slope {k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k → E} {a b r : k} (hab : a < b) (h₀ : 0 < r) (h₁ : r < 1) : ⇑(affine_map.line_map (f a) (f b)) r < f (⇑(affine_map.line_map a b) r) ↔ slope f (⇑(affine_map.line_map a b) r) b < slope f a (⇑(affine_map.line_map a b) r)
theorem filter.is_bounded_under.is_o_sub_self_inv {𝕜 : Type u_1} {E : Type u_2} [normed_field 𝕜] [has_norm E] {a : 𝕜} {f : 𝕜 → E} (h : filter.is_bounded_under has_le.le (nhds_within a {a}ᶜ) (has_norm.norm ∘ f)) : f =o[nhds_within a {a}ᶜ] λ (x : 𝕜), (x - a)⁻¹
theorem first_order.language.directed_system.map_map {L : first_order.language} {ι : Type v} [preorder ι] {G : ι → Type w} [Π (i : ι), L.Structure (G i)] (f : Π (i j : ι), i ≤ j → L.embedding (G i) (G j)) [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] {i j k : ι} (hij : i ≤ j) (hjk : j ≤ k) (x : G i) : ⇑(f j k hjk) (⇑(f i j hij) x) = ⇑(f i k _) x
theorem locally_finite.exists_finset_nhd_mul_support_subset {X : Type u_1} {R : Type u_9} {ι : Type u_10} {U : ι → set X} [topological_space X] [has_one R] {f : ι → X → R} (hlf : locally_finite (λ (i : ι), function.mul_support (f i))) (hso : ∀ (i : ι), mul_tsupport (f i) ⊆ U i) (ho : ∀ (i : ι), is_open (U i)) (x : X) : ∃ (is : finset ι) {n : set X} (hn₁ : n ∈ nhds x) (hn₂ : n ⊆ ⋂ (i : ι) (H : i ∈ is), U i), ∀ (z : X), z ∈ n → function.mul_support (λ (i : ι), f i z) ⊆ ↑is
theorem nilpotent_center_quotient_ind {P : Π (G : Type u_1) [_inst_3 : group G] [_inst_4 : group.is_nilpotent G], Prop} (G : Type u_1) [group G] [group.is_nilpotent G] (hbase : ∀ (G : Type u_1) [_inst_6 : group G] [_inst_7 : subsingleton G], P G) (hstep : ∀ (G : Type u_1) [_inst_8 : group G] [_inst_9 : group.is_nilpotent G], P (G ⧸ subgroup.center G) → P G) : P G
theorem category_theory.preadditive.has_coequalizers_of_has_cokernels {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_cokernels C] : category_theory.limits.has_coequalizers C
theorem add_monoid_hom.map_add {M : Type u_3} {N : Type u_4} [add_zero_class M] [add_zero_class N] (f : M →+ N) (a b : M) : ⇑f (a + b) = ⇑f a + ⇑f b
theorem probability_theory.cond_apply {α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) {s : set α} (hms : measurable_set s) (t : set α) : ⇑(probability_theory.cond μ s) t = (⇑μ s)⁻¹ * ⇑μ (s ∩ t)
theorem category_theory.limits.biproduct.cone_point_unique_up_to_iso_inv {J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (f : J → C) [category_theory.limits.has_biproduct f] {b : category_theory.limits.bicone f} (hb : b.is_bilimit) : (hb.is_limit.cone_point_unique_up_to_iso (category_theory.limits.biproduct.is_limit f)).inv = category_theory.limits.biproduct.desc b.ι
theorem finite_field.card_image_polynomial_eval {R : Type u_2} [comm_ring R] [is_domain R] [decidable_eq R] [fintype R] {p : polynomial R} (hp : 0 < p.degree) : fintype.card R ≤ p.nat_degree * (finset.image (λ (x : R), polynomial.eval x p) finset.univ).card
theorem discrim_lt_zero {K : Type u_1} [linear_ordered_field K] {a b c : K} (ha : a ≠ 0) (h : ∀ (x : K), 0 < a * x * x + b * x + c) : discrim a b c < 0
theorem set.finite.bUnion' {α : Type u} {ι : Type u_1} {s : set ι} (hs : s.finite) {t : Π (i : ι), i ∈ s → set α} (ht : ∀ (i : ι) (H : i ∈ s), (t i H).finite) : (⋃ (i : ι) (H : i ∈ s), t i H).finite
theorem finite_dimensional.nonempty_continuous_linear_equiv_of_finrank_eq {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {E : Type v} [normed_group E] [normed_space 𝕜 E] {F : Type w} [normed_group F] [normed_space 𝕜 F] [complete_space 𝕜] [finite_dimensional 𝕜 E] [finite_dimensional 𝕜 F] (cond : finite_dimensional.finrank 𝕜 E = finite_dimensional.finrank 𝕜 F) : nonempty (E ≃L[𝕜] F)
theorem is_monoid_hom.map_mul {α : Type u} {β : Type v} [mul_one_class α] [mul_one_class β] {f : α → β} (hf : is_monoid_hom f) (x y : α) : f (x * y) = f x * f y
theorem nat.mem_factors_mul_right {p a b : ℕ} (hpb : p ∈ b.factors) (ha : a ≠ 0) : p ∈ (a * b).factors
theorem is_max.of_dual {α : Type u_1} [has_le α] {a : αᵒᵈ} : is_max a → is_min (⇑order_dual.of_dual a)
theorem nonempty_sections_of_fintype_cofiltered_system {J : Type u} [category_theory.category J] [category_theory.is_cofiltered J] (F : J ⥤ Type v) [Π (j : J), fintype (F.obj j)] [∀ (j : J), nonempty (F.obj j)] : F.sections.nonempty
theorem finset.image_image₂_antidistrib_left {α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} [decidable_eq β'] [decidable_eq γ] [decidable_eq δ] {f : α → β → γ} {s : finset α} {t : finset β} {g : γ → δ} {f' : β' → α → δ} {g' : β → β'} (h_antidistrib : ∀ (a : α) (b : β), g (f a b) = f' (g' b) a) : finset.image g (finset.image₂ f s t) = finset.image₂ f' (finset.image g' t) s
theorem ring_hom.map_one_ne_zero {α : Type u_2} {β : Type u_3} {rα : non_assoc_semiring α} {rβ : non_assoc_semiring β} (f : α →+* β) [nontrivial β] : ⇑f 1 ≠ 0
theorem emetric.uniform_embedding_iff {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} : uniform_embedding f ↔ function.injective f ∧ uniform_continuous f ∧ ∀ (δ : ennreal), δ > 0 → (∃ (ε : ennreal) (H : ε > 0), ∀ {a b : α}, has_edist.edist (f a) (f b) < ε → has_edist.edist a b < δ)
theorem add_monoid_algebra.finite_type_iff_group_fg {R : Type u_1} {G : Type u_2} [add_comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (add_monoid_algebra R G) ↔ add_group.fg G
theorem convex.add_smul_mem_interior {E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) {x y : E} (hx : x ∈ s) (hy : x + y ∈ interior s) {t : 𝕜} (ht : t ∈ set.Ioc 0 1) : x + t • y ∈ interior s
theorem complex.has_deriv_at_sinh (x : ℂ) : has_deriv_at complex.sinh (complex.cosh x) x
theorem affine_subspace.direction_of_nonempty_eq_direction {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} (h : ↑s.nonempty) : affine_subspace.direction_of_nonempty h = s.direction
theorem finset.mem_dfinsupp_iff_of_support_subset {ι : Type u_1} {α : ι → Type u_2} [decidable_eq ι] [Π (i : ι), has_zero (α i)] {s : finset ι} {f : Π₀ (i : ι), α i} [Π (i : ι), decidable_eq (α i)] {t : Π₀ (i : ι), finset (α i)} (ht : t.support ⊆ s) : f ∈ s.dfinsupp ⇑t ↔ ∀ (i : ι), ⇑f i ∈ ⇑t i
theorem padic_norm.mul (p : ℕ) [hp : fact (nat.prime p)] (q r : ℚ) : padic_norm p (q * r) = padic_norm p q * padic_norm p r
theorem fintype.nonempty_field_iff {α : Type u_1} [fintype α] : nonempty (field α) ↔ is_prime_pow (fintype.card α)
theorem reflection_mem_subspace_orthogonal_precomplement_eq_neg {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K : submodule 𝕜 E} [complete_space E] {v : E} (hv : v ∈ K) : ⇑(reflection Kᗮ) v = -v
theorem order_top.bdd_above {γ : Type w} [preorder γ] [order_top γ] (s : set γ) : bdd_above s
theorem is_primitive_root.discr_zeta_eq_discr_zeta_sub_one {n : ℕ+} {K : Type u} [field K] [char_zero K] {ζ : K} [is_cyclotomic_extension {n} ℚ K] (hζ : is_primitive_root ζ ↑n) : algebra.discr ℚ ⇑((is_primitive_root.power_basis ℚ hζ).basis) = algebra.discr ℚ ⇑((is_primitive_root.sub_one_power_basis ℚ hζ).basis)
theorem emetric.Hausdorff_edist_comm {α : Type u} [pseudo_emetric_space α] {s t : set α} : emetric.Hausdorff_edist s t = emetric.Hausdorff_edist t s
theorem orthogonal_projection_inner_eq_zero {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K : submodule 𝕜 E} [complete_space ↥K] (v w : E) (H : w ∈ K) : has_inner.inner (v - ↑(⇑(orthogonal_projection K) v)) w = 0
theorem affine.triangle.dist_orthocenter_reflection_circumcenter {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle ℝ P) {i₁ i₂ : fin 3} (h : i₁ ≠ i₂) : has_dist.dist t.orthocenter (⇑(euclidean_geometry.reflection (affine_span ℝ (t.points '' {i₁, i₂}))) (affine.simplex.circumcenter t)) = affine.simplex.circumradius t
theorem vitali_family.ae_eventually_measure_pos {α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [topological_space.second_countable_topology α] : ∀ᵐ (x : α) ∂μ, ∀ᶠ (a : set α) in v.filter_at x, 0 < ⇑μ a
theorem dense_inducing.tendsto_comap_nhds_nhds {α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} [topological_space α] [topological_space β] {i : α → β} [topological_space δ] {f : γ → α} {g : γ → δ} {h : δ → β} {d : δ} {a : α} (di : dense_inducing i) (H : filter.tendsto h (nhds d) (nhds (i a))) (comm : h ∘ g = i ∘ f) : filter.tendsto f (filter.comap g (nhds d)) (nhds a)
theorem has_subset.subset.ssubset_of_ne {α : Type u} [has_subset α] [has_ssubset α] [is_nonstrict_strict_order α has_subset.subset has_ssubset.ssubset] {a b : α} [is_antisymm α has_subset.subset] (h₁ : a ⊆ b) (h₂ : a ≠ b) : a ⊂ b
theorem is_preconnected.Union_of_refl_trans_gen {α : Type u} [topological_space α] {ι : Type u_1} {s : ι → set α} (H : ∀ (i : ι), is_preconnected (s i)) (K : ∀ (i j : ι), relation.refl_trans_gen (λ (i j : ι), (s i ∩ s j).nonempty) i j) : is_preconnected (⋃ (n : ι), s n)
theorem monovary_on.sum_mul_comp_perm_eq_sum_mul_iff {ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {s : finset ι} {σ : equiv.perm ι} {f g : ι → α} (hfg : monovary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i * g (⇑σ i)) = s.sum (λ (i : ι), f i * g i) ↔ monovary_on f (g ∘ ⇑σ) ↑s
theorem shrinking_lemma.partial_refinement.le_chain_Sup {ι : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : ι → set X} {s : set X} {c : set (shrinking_lemma.partial_refinement u s)} (hc : is_chain has_le.le c) (ne : c.nonempty) (hfin : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite) (hU : s ⊆ ⋃ (i : ι), u i) {v : shrinking_lemma.partial_refinement u s} (hv : v ∈ c) : v ≤ shrinking_lemma.partial_refinement.chain_Sup c hc ne hfin hU
theorem matrix.nondegenerate.of_det_ne_zero {n : Type u_3} [fintype n] {A : Type u_1} [decidable_eq n] [comm_ring A] [is_domain A] {M : matrix n n A} : M.det ≠ 0 → M.nondegenerate
theorem deriv.lhopital_zero_nhds_left {a : ℝ} {l : filter ℝ} {f g : ℝ → ℝ} (hdf : ∀ᶠ (x : ℝ) in nhds_within a (set.Iio a), differentiable_at ℝ f x) (hg' : ∀ᶠ (x : ℝ) in nhds_within a (set.Iio a), deriv g x ≠ 0) (hfa : filter.tendsto f (nhds_within a (set.Iio a)) (nhds 0)) (hga : filter.tendsto g (nhds_within a (set.Iio a)) (nhds 0)) (hdiv : filter.tendsto (λ (x : ℝ), deriv f x / deriv g x) (nhds_within a (set.Iio a)) l) : filter.tendsto (λ (x : ℝ), f x / g x) (nhds_within a (set.Iio a)) l
theorem continuous.path_extend {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {x y : X} {γ : Y → path x y} {f : Y → ℝ} (hγ : continuous ↿γ) (hf : continuous f) : continuous (λ (t : Y), (γ t).extend (f t))
theorem one_le_mul {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b
theorem inner_product_space.is_self_adjoint.diagonalization_basis_apply_self_apply {𝕜 : Type u_1} [is_R_or_C 𝕜] [dec_𝕜 : decidable_eq 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] {T : E →ₗ[𝕜] E} (hT : inner_product_space.is_self_adjoint T) [finite_dimensional 𝕜 E] {n : ℕ} (hn : finite_dimensional.finrank 𝕜 E = n) (v : E) (i : fin n) : ⇑(hT.diagonalization_basis hn) (⇑T v) i = ↑(hT.eigenvalues hn i) * ⇑(hT.diagonalization_basis hn) v i
theorem is_antichain.max_maximals {α : Type u_1} {r : α → α → Prop} {s t : set α} (ht : is_antichain r t) (h : maximals r s ⊆ t) (hs : ∀ ⦃a : α⦄, a ∈ t → (∃ (b : α) (H : b ∈ maximals r s), r b a)) : maximals r s = t
theorem phragmen_lindelof.eq_on_vertical_strip {E : Type u_1} [normed_group E] [normed_space ℂ E] {a b : ℝ} {f g : ℂ → E} (hdf : diff_cont_on_cl ℂ f (complex.re ⁻¹' set.Ioo a b)) (hBf : ∃ (c : ℝ) (H : c < real.pi / (b - a)) (B : ℝ), f =O[filter.comap (has_abs.abs ∘ complex.im) filter.at_top ⊓ filter.principal (complex.re ⁻¹' set.Ioo a b)] λ (z : ℂ), real.exp (B * real.exp (c * |z.im|))) (hdg : diff_cont_on_cl ℂ g (complex.re ⁻¹' set.Ioo a b)) (hBg : ∃ (c : ℝ) (H : c < real.pi / (b - a)) (B : ℝ), g =O[filter.comap (has_abs.abs ∘ complex.im) filter.at_top ⊓ filter.principal (complex.re ⁻¹' set.Ioo a b)] λ (z : ℂ), real.exp (B * real.exp (c * |z.im|))) (ha : ∀ (z : ℂ), z.re = a → f z = g z) (hb : ∀ (z : ℂ), z.re = b → f z = g z) : set.eq_on f g (complex.re ⁻¹' set.Icc a b)
theorem is_closed.Hausdorff_dist_zero_iff_eq {α : Type u} [pseudo_metric_space α] {s t : set α} (hs : is_closed s) (ht : is_closed t) (fin : emetric.Hausdorff_edist s t ≠ ⊤) : metric.Hausdorff_dist s t = 0 ↔ s = t
theorem fin.init_update_last {n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (z : α (fin.last n)) : fin.init (function.update q (fin.last n) z) = fin.init q
theorem topological_space.is_topological_basis.dense_iff {α : Type u} [t : topological_space α] {b : set (set α)} (hb : topological_space.is_topological_basis b) {s : set α} : dense s ↔ ∀ (o : set α), o ∈ b → o.nonempty → (o ∩ s).nonempty
theorem subgroup.ext {G : Type u_1} [group G] {H K : subgroup G} (h : ∀ (x : G), x ∈ H ↔ x ∈ K) : H = K
theorem intermediate_field.fixing_subgroup.antimono {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] {E1 E2 : intermediate_field K L} (h12 : E1 ≤ E2) : E2.fixing_subgroup ≤ E1.fixing_subgroup
theorem has_lt.lt.ne {α : Type u} [preorder α] {a b : α} (h : a < b) : a ≠ b
theorem right.mul_lt_one_of_le_of_lt {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1
theorem euclidean_geometry.vsub_orthogonal_projection_mem_direction_orthogonal {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ℝ P) [nonempty ↥s] [complete_space ↥(s.direction)] (p : P) : p -ᵥ ↑(⇑(euclidean_geometry.orthogonal_projection s) p) ∈ (s.direction)ᗮ
theorem orthonormal.oangle_add_cyc3_neg_right {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle x (-y) + hb.oangle y (-z) + hb.oangle z (-x) = ↑real.pi
theorem false_of_nontrivial_of_product_domain (R : Type u_1) (S : Type u_2) [ring R] [ring S] [is_domain (R × S)] [nontrivial R] [nontrivial S] : false
theorem category_theory.limits.epi_of_is_colimit_cofork {C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} {c : category_theory.limits.cofork f g} (i : category_theory.limits.is_colimit c) : category_theory.epi c.π
theorem linear_map.to_matrix_id_eq_basis_to_matrix {ι : Type u_1} {ι' : Type u_2} {R : Type u_5} {M : Type u_6} [comm_semiring R] [add_comm_monoid M] [module R M] (b : basis ι R M) (b' : basis ι' R M) [fintype ι'] [fintype ι] [decidable_eq ι] : ⇑(linear_map.to_matrix b b') linear_map.id = b'.to_matrix ⇑b
theorem mem_nhds_within_Ici_iff_exists_Icc_subset' {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_max_order α] [densely_ordered α] {a : α} {s : set α} : s ∈ nhds_within a (set.Ici a) ↔ ∃ (u : α) (H : u ∈ set.Ioi a), set.Icc a u ⊆ s
theorem is_open.analytic_set_image {α : Type u_1} [topological_space α] {β : Type u_2} [topological_space β] [polish_space β] {s : set β} (hs : is_open s) {f : β → α} (f_cont : continuous f) : measure_theory.analytic_set (f '' s)
theorem units.smul_inv {G : Type u_1} {M : Type u_3} [group G] [monoid M] [mul_action G M] [smul_comm_class G M M] [is_scalar_tower G M M] (g : G) (m : Mˣ) : (g • m)⁻¹ = g⁻¹ • m⁻¹
theorem measure_theory.pdf.integral_fun_mul_eq_integral {α : Type u_1} {E : Type u_2} [measurable_space E] {m : measurable_space α} {ℙ : measure_theory.measure α} {μ : measure_theory.measure E} [measure_theory.is_finite_measure «ℙ»] {X : α → E} [measure_theory.has_pdf X «ℙ» μ] {f : E → ℝ} (hf : measurable f) : ∫ (x : E), f x * (measure_theory.pdf X «ℙ» μ x).to_real ∂μ = ∫ (x : α), f (X x) ∂«ℙ»
theorem has_deriv_at_integral_of_dominated_loc_of_lip {α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {𝕜 : Type u_2} [is_R_or_C 𝕜] {E : Type u_3} [normed_group E] [normed_space ℝ E] [normed_space 𝕜 E] [complete_space E] {F : 𝕜 → α → E} {F' : α → E} {x₀ : 𝕜} {ε : ℝ} (ε_pos : 0 < ε) (hF_meas : ∀ᶠ (x : 𝕜) in nhds x₀, measure_theory.ae_strongly_measurable (F x) μ) (hF_int : measure_theory.integrable (F x₀) μ) (hF'_meas : measure_theory.ae_strongly_measurable F' μ) {bound : α → ℝ} (h_lipsch : ∀ᵐ (a : α) ∂μ, lipschitz_on_with (⇑real.nnabs (bound a)) (λ (x : 𝕜), F x a) (metric.ball x₀ ε)) (bound_integrable : measure_theory.integrable bound μ) (h_diff : ∀ᵐ (a : α) ∂μ, has_deriv_at (λ (x : 𝕜), F x a) (F' a) x₀) : measure_theory.integrable F' μ ∧ has_deriv_at (λ (x : 𝕜), ∫ (a : α), F x a ∂μ) (∫ (a : α), F' a ∂μ) x₀
theorem intermediate_field.map_id {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E : intermediate_field K L) : E.map (alg_hom.id K L) = E
theorem add_con.ker_lift_range_eq {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {f : M →+ P} : (add_con.ker_lift f).mrange = f.mrange
theorem cardinal.bdd_above_range {ι : Type u} (f : ι → cardinal) : bdd_above (set.range f)
theorem orthonormal.oangle_eq_iff_eq_norm_div_norm_smul_rotation_of_ne_zero {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : real.angle) : hb.oangle x y = θ ↔ y = (∥y∥ / ∥x∥) • ⇑(hb.rotation θ) x
theorem orientation.oangle_self {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x : V) : o.oangle x x = 0
theorem linear_equiv.nonempty_equiv_iff_lift_dim_eq {K : Type u} {V : Type v} {V' : Type v'} [division_ring K] [add_comm_group V] [module K V] [add_comm_group V'] [module K V'] : nonempty (V ≃ₗ[K] V') ↔ (module.rank K V).lift = (module.rank K V').lift
theorem mem_nhds_iff_exists_Ioo_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_max_order α] [no_min_order α] {a : α} {s : set α} : s ∈ nhds a ↔ ∃ (l u : α), a ∈ set.Ioo l u ∧ set.Ioo l u ⊆ s
theorem quadratic_form.anisotropic_of_pi {ι : Type u_1} {Mᵢ : ι → Type u_7} [Π (i : ι), add_comm_group (Mᵢ i)] [fintype ι] {R : Type u_2} [ordered_ring R] [Π (i : ι), module R (Mᵢ i)] {Q : Π (i : ι), quadratic_form R (Mᵢ i)} (h : (quadratic_form.pi Q).anisotropic) (i : ι) : (Q i).anisotropic
theorem add_semiconj_by.eq {S : Type u} [has_add S] {a x y : S} (h : add_semiconj_by a x y) : a + x = y + a
theorem category_theory.limits.cokernel.π_of_epi {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ⟶ Y) [category_theory.limits.has_zero_object C] [category_theory.limits.has_cokernel f] [category_theory.epi f] : category_theory.limits.cokernel.π f = 0
theorem orthonormal.oangle_sub_left {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle x z - hb.oangle x y = hb.oangle y z
theorem orthogonal_family.summable_iff_norm_sq_summable {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {G : ι → Type u_5} [Π (i : ι), inner_product_space 𝕜 (G i)] {V : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : orthogonal_family 𝕜 V) [complete_space E] (f : Π (i : ι), G i) : summable (λ (i : ι), ⇑(V i) (f i)) ↔ summable (λ (i : ι), ∥f i∥ ^ 2)
theorem real.real_sqrt_le_nat_sqrt_succ {a : ℕ} : real.sqrt ↑a ≤ ↑(nat.sqrt a) + 1
theorem affine_subspace.direction_lt_of_nonempty {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s1 s2 : affine_subspace k P} (h : s1 < s2) (hn : ↑s1.nonempty) : s1.direction < s2.direction
theorem torus_integrable.function_integrable {n : ℕ} {E : Type u_1} [normed_group E] {f : (fin n → ℂ) → E} {c : fin n → ℂ} {R : fin n → ℝ} [normed_space ℂ E] (hf : torus_integrable f c R) : measure_theory.integrable_on (λ (θ : fin n → ℝ), finset.univ.prod (λ (i : fin n), ↑(R i) * complex.exp (↑(θ i) * complex.I) * complex.I) • f (torus_map c R θ)) (set.Icc 0 (λ (_x : fin n), 2 * real.pi)) measure_theory.measure_space.volume
theorem submodule.exists_le_ker_of_lt_top {K : Type u_4} {V : Type u} [field K] [add_comm_group V] [module K V] (p : submodule K V) (hp : p < ⊤) : ∃ (f : V →ₗ[K] K) (H : f ≠ 0), p ≤ f.ker
theorem cont_diff_within_at.comp_continuous_linear_map {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {s : set E} {f : E → F} {n : with_top ℕ} {x : G} (g : G →L[𝕜] E) (hf : cont_diff_within_at 𝕜 n f s (⇑g x)) : cont_diff_within_at 𝕜 n (f ∘ ⇑g) (⇑g ⁻¹' s) x
theorem polynomial.induction_with_nat_degree_le {R : Type u_1} [semiring R] (P : polynomial R → Prop) (N : ℕ) (P_0 : P 0) (P_C_mul_pow : ∀ (n : ℕ) (r : R), r ≠ 0 → n ≤ N → P (⇑polynomial.C r * polynomial.X ^ n)) (P_C_add : ∀ (f g : polynomial R), f.nat_degree < g.nat_degree → g.nat_degree ≤ N → P f → P g → P (f + g)) (f : polynomial R) : f.nat_degree ≤ N → P f
theorem setoid.inf_def {α : Type u_1} {r s : setoid α} : (r ⊓ s).rel = r.rel ⊓ s.rel
theorem is_connected.Union_of_chain {α : Type u} {β : Type v} [topological_space α] [linear_order β] [succ_order β] [is_succ_archimedean β] [nonempty β] {s : β → set α} (H : ∀ (n : β), is_connected (s n)) (K : ∀ (n : β), (s n ∩ s (order.succ n)).nonempty) : is_connected (⋃ (n : β), s n)
theorem has_fpower_series_on_ball.change_origin {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] [complete_space F] {f : E → F} {p : formal_multilinear_series 𝕜 E F} {x y : E} {r : ennreal} (hf : has_fpower_series_on_ball f p x r) (h : ↑∥y∥₊ < r) : has_fpower_series_on_ball f (p.change_origin y) (x + y) (r - ↑∥y∥₊)
theorem ultrafilter_converges_iff {α : Type u} {u : ultrafilter (ultrafilter α)} {x : ultrafilter α} : ↑u ≤ nhds x ↔ x = mjoin u
theorem is_open_map_quotient_mk_mul {Γ : Type u_4} [group Γ] {T : Type u_5} [topological_space T] [mul_action Γ T] [has_continuous_const_smul Γ T] : is_open_map quotient.mk
theorem fin.init_update_cast_succ {n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (i : fin n) (y : α (⇑fin.cast_succ i)) : fin.init (function.update q (⇑fin.cast_succ i) y) = function.update (fin.init q) i y
theorem same_ray.exists_pos {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} (h : same_ray R x y) (hx : x ≠ 0) (hy : y ≠ 0) : ∃ (r₁ r₂ : R), 0 < r₁ ∧ 0 < r₂ ∧ r₁ • x = r₂ • y
theorem measure_theory.analytic_set.measurably_separable {α : Type u_1} [topological_space α] [t2_space α] [measurable_space α] [borel_space α] {s t : set α} (hs : measure_theory.analytic_set s) (ht : measure_theory.analytic_set t) (h : disjoint s t) : measure_theory.measurably_separable s t
theorem witt_vector.map_verschiebung {p : ℕ} {R : Type u_1} {S : Type u_2} [hp : fact (nat.prime p)] [comm_ring R] [comm_ring S] (f : R →+* S) (x : witt_vector p R) : ⇑(witt_vector.map f) (⇑witt_vector.verschiebung x) = ⇑witt_vector.verschiebung (⇑(witt_vector.map f) x)
theorem pythagorean_triple.mul_iff {x y z : ℤ} (k : ℤ) (hk : k ≠ 0) : pythagorean_triple (k * x) (k * y) (k * z) ↔ pythagorean_triple x y z
theorem emetric.inf_edist_image {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {x : α} {t : set α} {Φ : α → β} (hΦ : isometry Φ) : emetric.inf_edist (Φ x) (Φ '' t) = emetric.inf_edist x t
theorem set.finset_prod_mem_finset_prod {α : Type u_2} {ι : Type u_5} [comm_monoid α] (t : finset ι) (f : ι → set α) (g : ι → α) (hg : ∀ (i : ι), i ∈ t → g i ∈ f i) : t.prod (λ (i : ι), g i) ∈ t.prod (λ (i : ι), f i)
theorem monotone.min {α : Type u} {β : Type v} [preorder α] [linear_order β] {f g : α → β} (hf : monotone f) (hg : monotone g) : monotone (λ (x : α), linear_order.min (f x) (g x))
theorem submodule.finrank_add_inf_finrank_orthogonal' {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K₁ K₂ : submodule 𝕜 E} [finite_dimensional 𝕜 ↥K₂] (h : K₁ ≤ K₂) {n : ℕ} (h_dim : finite_dimensional.finrank 𝕜 ↥K₁ + n = finite_dimensional.finrank 𝕜 ↥K₂) : finite_dimensional.finrank 𝕜 ↥(K₁ᗮ ⊓ K₂) = n
theorem module.projective_of_lifting_property {R : Type u} [ring R] {P : Type (max u v)} [add_comm_group P] [module R P] (huniv : ∀ {M : Type (max v u)} {N : Type (max u v)} [_inst_4 : add_comm_group M] [_inst_5 : add_comm_group N] [_inst_6 : module R M] [_inst_7 : module R N] (f : M →ₗ[R] N) (g : P →ₗ[R] N), function.surjective ⇑f → (∃ (h : P →ₗ[R] M), f.comp h = g)) : module.projective R P
theorem bounded_continuous_function.norm_const_le {α : Type u} {β : Type v} [topological_space α] [semi_normed_group β] (b : β) : ∥bounded_continuous_function.const α b∥ ≤ ∥b∥
theorem fin.coe_val_of_lt {n a : ℕ} (h : a < n + 1) : ↑a.val = a
theorem concave_on.le_map_sum {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} {ι : Type u_5} [linear_ordered_field 𝕜] [add_comm_group E] [ordered_add_comm_group β] [module 𝕜 E] [module 𝕜 β] [ordered_smul 𝕜 β] {s : set E} {f : E → β} {t : finset ι} {w : ι → 𝕜} {p : ι → E} (hf : concave_on 𝕜 s f) (h₀ : ∀ (i : ι), i ∈ t → 0 ≤ w i) (h₁ : t.sum (λ (i : ι), w i) = 1) (hmem : ∀ (i : ι), i ∈ t → p i ∈ s) : t.sum (λ (i : ι), w i • f (p i)) ≤ f (t.sum (λ (i : ι), w i • p i))
theorem emetric.Hausdorff_edist_le_ediam {α : Type u} [pseudo_emetric_space α] {s t : set α} (hs : s.nonempty) (ht : t.nonempty) : emetric.Hausdorff_edist s t ≤ emetric.diam (s ∪ t)
theorem normed_group_hom.norm_id_of_nontrivial_seminorm (V : Type u_1) [semi_normed_group V] (h : ∃ (x : V), ∥x∥ ≠ 0) : ∥normed_group_hom.id V∥ = 1
theorem emetric.inf_edist_le_Hausdorff_edist_of_mem {α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} (h : x ∈ s) : emetric.inf_edist x t ≤ emetric.Hausdorff_edist s t
theorem category_theory.limits.has_limit_of_has_colimit_left_op {C : Type u₁} [category_theory.category C] {J : Type u₂} [category_theory.category J] (F : J ⥤ Cᵒᵖ) [category_theory.limits.has_colimit F.left_op] : category_theory.limits.has_limit F
theorem nat.lt_base_pow_length_digits {b m : ℕ} (hb : 2 ≤ b) : m < b ^ (b.digits m).length
theorem cardinal.ord_aleph_eq_enum_card  : cardinal.ord ∘ cardinal.aleph = ordinal.enum_ord {b : ordinal | b.card.ord = b ∧ ordinal.omega ≤ b}
theorem polynomial.eval_mul_X_sub_C {R : Type u} [ring R] {p : polynomial R} (r : R) : polynomial.eval r (p * (polynomial.X - ⇑polynomial.C r)) = 0
theorem category_theory.limits.complete_lattice.finite_coproduct_eq_finset_sup {α : Type u} [semilattice_sup α] [order_bot α] {ι : Type u} [fintype ι] (f : ι → α) : (∐ f) = (fintype.elems ι).sup f
theorem add_subsemigroup.closure_induction' {M : Type u_1} [has_add M] (s : set M) {p : Π (x : M), x ∈ add_subsemigroup.closure s → Prop} (Hs : ∀ (x : M) (h : x ∈ s), p x _) (Hmul : ∀ (x : M) (hx : x ∈ add_subsemigroup.closure s) (y : M) (hy : y ∈ add_subsemigroup.closure s), p x hx → p y hy → p (x + y) _) {x : M} (hx : x ∈ add_subsemigroup.closure s) : p x hx
theorem orientation.some_basis_orientation {R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {ι : Type u_3} [decidable_eq ι] [fintype ι] [finite_dimensional R M] [nonempty ι] (x : orientation R M ι) (h : fintype.card ι = finite_dimensional.finrank R M) : (x.some_basis h).orientation = x
theorem cont_mdiff_within_at.cont_diff_within_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {n : with_top ℕ} {f : E → E'} {s : set E} {x : E} : cont_mdiff_within_at (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n f s x → cont_diff_within_at 𝕜 n f s x
theorem pequiv.injective_of_forall_is_some {α : Type u} {β : Type v} {f : α ≃. β} (h : ∀ (a : α), ↥((⇑f a).is_some)) : function.injective ⇑f
theorem real.sinh_eq (x : ℝ) : real.sinh x = (real.exp x - real.exp (-x)) / 2
theorem subsemiring.prod_mem {R : Type u_1} [comm_semiring R] (s : subsemiring R) {ι : Type u_2} {t : finset ι} {f : ι → R} (h : ∀ (c : ι), c ∈ t → f c ∈ s) : t.prod (λ (i : ι), f i) ∈ s
theorem convex.affine_preimage {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [ordered_ring 𝕜] [add_comm_group E] [add_comm_group F] [module 𝕜 E] [module 𝕜 F] (f : E →ᵃ[𝕜] F) {s : set F} (hs : convex 𝕜 s) : convex 𝕜 (⇑f ⁻¹' s)
theorem finsupp.on_finset_prod {α : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [comm_monoid N] {s : finset α} {f : α → M} {g : α → M → N} (hf : ∀ (a : α), f a ≠ 0 → a ∈ s) (hg : ∀ (a : α), g a 0 = 1) : (finsupp.on_finset s f hf).prod g = s.prod (λ (a : α), g a (f a))
theorem category_theory.limits.has_finite_biproducts.of_has_finite_coproducts {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_coproducts C] : category_theory.limits.has_finite_biproducts C
theorem function.update_comp_eq_of_forall_ne {α' : Sort w} [decidable_eq α'] {α : Sort u_1} {β : Sort u_2} (g : α' → β) {f : α → α'} {i : α'} (a : β) (h : ∀ (x : α), f x ≠ i) : function.update g i a ∘ f = g ∘ f
theorem cont_diff_at_fst {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : with_top ℕ} {p : E × F} : cont_diff_at 𝕜 n prod.fst p
theorem multilinear_map.map_sum {R : Type u} {ι : Type u'} {M₁ : ι → Type v₁} {M₂ : Type v₂} [decidable_eq ι] [semiring R] [Π (i : ι), add_comm_monoid (M₁ i)] [add_comm_monoid M₂] [Π (i : ι), module R (M₁ i)] [module R M₂] (f : multilinear_map R M₁ M₂) {α : ι → Type u_1} (g : Π (i : ι), α i → M₁ i) [fintype ι] [Π (i : ι), fintype (α i)] : ⇑f (λ (i : ι), finset.univ.sum (λ (j : α i), g i j)) = finset.univ.sum (λ (r : Π (i : ι), α i), ⇑f (λ (i : ι), g i (r i)))
theorem quotient.ind₂' {α : Sort u_1} {β : Sort u_2} {s₁ : setoid α} {s₂ : setoid β} {p : quotient s₁ → quotient s₂ → Prop} (h : ∀ (a₁ : α) (a₂ : β), p (quotient.mk' a₁) (quotient.mk' a₂)) (q₁ : quotient s₁) (q₂ : quotient s₂) : p q₁ q₂
theorem nnreal.tendsto_tsum_compl_at_top_zero {α : Type u_1} (f : α → nnreal) : filter.tendsto (λ (s : finset α), ∑' (b : {x // x ∉ s}), f ↑b) filter.at_top (nhds 0)
theorem continuous_within_at.insert_self {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} {x : α} {s : set α} : continuous_within_at f s x → continuous_within_at f (has_insert.insert x s) x
theorem linear_equiv_det_rotation (a : ↥circle) : ⇑linear_equiv.det (⇑rotation a).to_linear_equiv = 1
theorem convex_cone.flat.pointed {𝕜 : Type u_1} {E : Type u_2} [ordered_semiring 𝕜] [add_comm_group E] [has_scalar 𝕜 E] {S : convex_cone 𝕜 E} (hS : S.flat) : S.pointed
theorem continuous.locally_integrable {X : Type u_1} {E : Type u_3} [measurable_space X] [topological_space X] [normed_group E] {f : X → E} {μ : measure_theory.measure X} [opens_measurable_space X] [topological_space.metrizable_space X] [measure_theory.is_locally_finite_measure μ] (hf : continuous f) : measure_theory.locally_integrable f μ
theorem algebra.is_algebraic_of_larger_base (K : Type u_1) (L : Type u_2) {A : Type u_5} [field K] [field L] [comm_ring A] [algebra K L] [algebra L A] [algebra K A] [is_scalar_tower K L A] (A_alg : algebra.is_algebraic K A) : algebra.is_algebraic L A
theorem is_closed.polish_space {α : Type u_1} [topological_space α] [polish_space α] {s : set α} (hs : is_closed s) : polish_space ↥s
theorem category_theory.abelian.pseudoelement.epi_of_pseudo_surjective {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P ⟶ Q) : function.surjective ⇑f → category_theory.epi f
theorem zmod.int_cast_zmod_cast {n : ℕ} (a : zmod n) : ↑↑a = a
theorem pi_nat.lipschitz_with_one_iff_forall_dist_image_le_of_mem_cylinder {E : ℕ → Type u_1} {α : Type u_2} [pseudo_metric_space α] {f : (Π (n : ℕ), E n) → α} : (∀ (x y : Π (n : ℕ), E n), has_dist.dist (f x) (f y) ≤ has_dist.dist x y) ↔ ∀ (x y : Π (n : ℕ), E n) (n : ℕ), y ∈ pi_nat.cylinder x n → has_dist.dist (f x) (f y) ≤ (1 / 2) ^ n
theorem tsum_of_nnnorm_bounded {ι : Type u_1} {E : Type u_3} [semi_normed_group E] {f : ι → E} {g : ι → nnreal} {a : nnreal} (hg : has_sum g a) (h : ∀ (i : ι), ∥f i∥₊ ≤ g i) : ∥∑' (i : ι), f i∥₊ ≤ a
theorem norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) (h : has_inner.inner x y = 0) : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥
theorem measure_theory.lintegral_liminf_le {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : ℕ → α → ennreal} (h_meas : ∀ (n : ℕ), measurable (f n)) : ∫⁻ (a : α), filter.at_top.liminf (λ (n : ℕ), f n a) ∂μ ≤ filter.at_top.liminf (λ (n : ℕ), ∫⁻ (a : α), f n a ∂μ)
theorem mul_sub_mul_div_mul_neg {α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : a / c < b / d → (a * d - b * c) / (c * d) < 0
theorem exists_extension_of_le_sublinear {E : Type u_2} [add_comm_group E] [module ℝ E] (f : linear_pmap ℝ E ℝ) (N : E → ℝ) (N_hom : ∀ (c : ℝ), 0 < c → ∀ (x : E), N (c • x) = c * N x) (N_add : ∀ (x y : E), N (x + y) ≤ N x + N y) (hf : ∀ (x : ↥(f.domain)), ⇑f x ≤ N ↑x) : ∃ (g : E →ₗ[ℝ] ℝ), (∀ (x : ↥(f.domain)), ⇑g ↑x = ⇑f x) ∧ ∀ (x : E), ⇑g x ≤ N x
theorem has_fpower_series_on_ball.tendsto_locally_uniformly_on' {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] {f : E → F} {p : formal_multilinear_series 𝕜 E F} {x : E} {r : ennreal} (hf : has_fpower_series_on_ball f p x r) : tendsto_locally_uniformly_on (λ (n : ℕ) (y : E), p.partial_sum n (y - x)) f filter.at_top (emetric.ball x r)
theorem continuous_linear_map.op_norm_extend_le {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} {Fₗ : Type u_7} [normed_group E] [normed_group F] [normed_group Fₗ] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] [normed_space 𝕜 Fₗ] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →SL[σ₁₂] F) [complete_space F] (e : E →L[𝕜] Fₗ) (h_dense : dense_range ⇑e) {N : nnreal} (h_e : ∀ (x : E), ∥x∥ ≤ ↑N * ∥⇑e x∥) [ring_hom_isometric σ₁₂] : ∥f.extend e h_dense _∥ ≤ ↑N * ∥f∥
theorem interval_integral.differentiable_on_integral_of_continuous {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a : ℝ} {s : set ℝ} (hintg : ∀ (x : ℝ), x ∈ s → interval_integrable f measure_theory.measure_space.volume a x) (hcont : continuous f) : differentiable_on ℝ (λ (u : ℝ), ∫ (x : ℝ) in a..u, f x) s
theorem is_regular.ne_zero {R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_regular a) : a ≠ 0
theorem is_dedekind_domain.height_one_spectrum.valuation_of_algebra_map {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] {K : Type u_2} [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) (r : R) : ⇑(v.valuation) (⇑(algebra_map R K) r) = ⇑(v.int_valuation) r
theorem bounded_continuous_function.norm_le {α : Type u} {β : Type v} [topological_space α] [semi_normed_group β] {f : bounded_continuous_function α β} {C : ℝ} (C0 : 0 ≤ C) : ∥f∥ ≤ C ↔ ∀ (x : α), ∥⇑f x∥ ≤ C
theorem monoid.mem_closure_union_iff {M : Type u_1} [comm_monoid M] {s t : set M} {x : M} : x ∈ monoid.closure (s ∪ t) ↔ ∃ (y : M) (H : y ∈ monoid.closure s) (z : M) (H : z ∈ monoid.closure t), y * z = x
theorem cau_seq_iff_cauchy_seq {α : Type u} [normed_field α] {u : ℕ → α} : is_cau_seq has_norm.norm u ↔ cauchy_seq u
theorem category_theory.pi.has_colimit_of_has_colimit_comp_eval {I : Type v₁} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {J : Type v₁} [category_theory.small_category J] {F : J ⥤ Π (i : I), C i} [∀ (i : I), category_theory.limits.has_colimit (F ⋙ category_theory.pi.eval C i)] : category_theory.limits.has_colimit F
theorem matrix.mv_polynomial_X_map_matrix_eval {m : Type u_1} {R : Type u_3} [fintype m] [decidable_eq m] [comm_semiring R] (A : matrix m m R) : ⇑((mv_polynomial.eval (λ (p : m × m), A p.fst p.snd)).map_matrix) (matrix.mv_polynomial_X m m R) = A
theorem uniq_inv_of_is_field (R : Type u) [ring R] (hf : is_field R) (x : R) : x ≠ 0 → (∃! (y : R), x * y = 1)
theorem category_theory.limits.is_limit.exists_unique {J : Type u₁} [category_theory.category J] {C : Type u₃} [category_theory.category C] {F : J ⥤ C} {t : category_theory.limits.cone F} (h : category_theory.limits.is_limit t) (s : category_theory.limits.cone F) : ∃! (l : s.X ⟶ t.X), ∀ (j : J), l ≫ t.π.app j = s.π.app j
theorem submodule.Inf_orthogonal {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (s : set (submodule 𝕜 E)) : (⨅ (K : submodule 𝕜 E) (H : K ∈ s), Kᗮ) = (has_Sup.Sup s)ᗮ
theorem topological_add_group.continuous_conj' {G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] (h : G) : continuous (λ (g : G), g + h + -g)
theorem ring_hom_inv_pair.of_ring_equiv {R₁ : Type u_1} {R₂ : Type u_2} [semiring R₁] [semiring R₂] (e : R₁ ≃+* R₂) : ring_hom_inv_pair ↑e ↑(e.symm)
theorem measurable_const' {α : Type u_1} {β : Type u_2} [measurable_space α] [measurable_space β] {f : β → α} (hf : ∀ (x y : β), f x = f y) : measurable f
theorem orthonormal.exists_linear_isometry_equiv_map_eq_of_orientation_eq {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {b₂ : basis (fin 2) ℝ V} (hb₂ : orthonormal ℝ ⇑b₂) (ho : b.orientation = b₂.orientation) : ∃ (θ : real.angle), b₂ = b.map (hb.rotation θ).to_linear_equiv
theorem units.exists0 {G₀ : Type u_2} [group_with_zero G₀] {p : G₀ˣ → Prop} : (∃ (g : G₀ˣ), p g) ↔ ∃ (g : G₀) (hg : g ≠ 0), p (units.mk0 g hg)
theorem contracting_with.exists_fixed_point {α : Type u_1} [emetric_space α] [cs : complete_space α] {K : nnreal} {f : α → α} (hf : contracting_with K f) (x : α) (hx : has_edist.edist x (f x) ≠ ⊤) : ∃ (y : α), function.is_fixed_pt f y ∧ filter.tendsto (λ (n : ℕ), f^[n] x) filter.at_top (nhds y) ∧ ∀ (n : ℕ), has_edist.edist (f^[n] x) y ≤ has_edist.edist x (f x) * ↑K ^ n / (1 - ↑K)
theorem emetric.mk_uniformity_basis_le {α : Type u} [pseudo_emetric_space α] {β : Type u_1} {p : β → Prop} {f : β → ennreal} (hf₀ : ∀ (x : β), p x → 0 < f x) (hf : ∀ (ε : ennreal), 0 < ε → (∃ (x : β) (hx : p x), f x ≤ ε)) : (uniformity α).has_basis p (λ (x : β), {p : α × α | has_edist.edist p.fst p.snd ≤ f x})
theorem is_open_map_fst {α : Type u} {β : Type v} [topological_space α] [topological_space β] : is_open_map prod.fst
theorem finset.eq_weighted_vsub_of_point_subset_iff_eq_weighted_vsub_of_point_subtype {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} {v : V} {x : k} {s : set ι} {p : ι → P} {b : P} : (∃ (fs : finset ι) (hfs : ↑fs ⊆ s) (w : ι → k) (hw : fs.sum (λ (i : ι), w i) = x), v = ⇑(fs.weighted_vsub_of_point p b) w) ↔ ∃ (fs : finset ↥s) (w : ↥s → k) (hw : fs.sum (λ (i : ↥s), w i) = x), v = ⇑(fs.weighted_vsub_of_point (λ (i : ↥s), p ↑i) b) w
theorem is_seq_closed.is_closed {X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s → is_closed s
theorem is_path_connected.preimage_coe {X : Type u_1} [topological_space X] {U W : set X} (hW : is_path_connected W) (hWU : W ⊆ U) : is_path_connected (coe ⁻¹' W)
theorem is_algebraic_of_larger_base (K : Type u_1) (L : Type u_2) {A : Type u_5} [field K] [field L] [comm_ring A] [algebra K L] [algebra L A] [algebra K A] [is_scalar_tower K L A] {x : A} (A_alg : is_algebraic K x) : is_algebraic L x
theorem power_series.order_eq_top {R : Type u_1} [semiring R] {φ : power_series R} : φ.order = ⊤ ↔ φ = 0
theorem finset.sum_centroid_weights_eq_one_of_card_eq_add_one (k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) [char_zero k] {n : ℕ} (h : s.card = n + 1) : s.sum (λ (i : ι), finset.centroid_weights k s i) = 1
theorem set.sum_indicator_subset_of_eq_zero {α : Type u_1} {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [has_zero N] (f : α → N) (g : α → N → M) {s t : finset α} (h : s ⊆ t) (hg : ∀ (a : α), g a 0 = 0) : s.sum (λ (i : α), g i (f i)) = t.sum (λ (i : α), g i (↑s.indicator f i))
theorem filter.tendsto.integrable_at_filter {α : Type u_1} {E : Type u_3} [measurable_space α] [normed_group E] {f : α → E} {μ : measure_theory.measure α} {l : filter α} [l.is_measurably_generated] (hfm : strongly_measurable_at_filter f l μ) (hμ : μ.finite_at_filter l) {b : E} (hf : filter.tendsto f l (nhds b)) : measure_theory.integrable_at_filter f l μ
theorem filter.tendsto_abs_at_bot_at_top {α : Type u_3} [linear_ordered_add_comm_group α] : filter.tendsto has_abs.abs filter.at_bot filter.at_top
theorem filter.map₂_map_left_comm {α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {f : filter α} {g : filter β} {m : α' → β → γ} {n : α → α'} {m' : α → β → δ} {n' : δ → γ} (h_left_comm : ∀ (a : α) (b : β), m (n a) b = n' (m' a b)) : filter.map₂ m (filter.map n f) g = filter.map n' (filter.map₂ m' f g)
theorem measure_theory.measure.add_haar_submodule {E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (s : submodule ℝ E) (hs : s ≠ ⊤) : ⇑μ ↑s = 0
theorem matrix.to_lin'_mul_apply {R : Type u_1} [comm_semiring R] {l : Type u_2} {m : Type u_3} {n : Type u_4} [fintype n] [decidable_eq n] [fintype m] [decidable_eq m] (M : matrix l m R) (N : matrix m n R) (x : n → R) : ⇑(⇑matrix.to_lin' (M.mul N)) x = ⇑(⇑matrix.to_lin' M) (⇑(⇑matrix.to_lin' N) x)
theorem polynomial.cyclotomic_eq_X_pow_sub_one_div {R : Type u_1} [comm_ring R] {n : ℕ} (hpos : 0 < n) : polynomial.cyclotomic n R = (polynomial.X ^ n - 1) /ₘ n.proper_divisors.prod (λ (i : ℕ), polynomial.cyclotomic i R)
theorem dimH_range_le_of_locally_holder_on {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [topological_space.second_countable_topology X] {r : nnreal} {f : X → Y} (hr : 0 < r) (hf : ∀ (x : X), ∃ (C : nnreal) (s : set X) (H : s ∈ nhds x), holder_on_with C r f s) : dimH (set.range f) ≤ dimH set.univ / ↑r
theorem measure_theory.measure_mono_ae {α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {s t : set α} (H : s ≤ᵐ[μ] t) : ⇑μ s ≤ ⇑μ t
theorem finset.eq_one_of_prod_eq_one {β : Type u} {α : Type v} [comm_monoid β] {s : finset α} {f : α → β} {a : α} (hp : s.prod (λ (x : α), f x) = 1) (h1 : ∀ (x : α), x ∈ s → x ≠ a → f x = 1) (x : α) (H : x ∈ s) : f x = 1
theorem category_theory.preadditive.has_equalizers_of_has_kernels {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] : category_theory.limits.has_equalizers C
theorem antitone_on.dual_right {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s : set α} : antitone_on f s → monotone_on (⇑order_dual.to_dual ∘ f) s
theorem box_integral.norm_volume_sub_integral_face_upper_sub_lower_smul_le {E : Type u} [normed_group E] [normed_space ℝ E] {n : ℕ} [complete_space E] (I : box_integral.box (fin (n + 1))) {i : fin (n + 1)} {f : (fin (n + 1) → ℝ) → E} {f' : (fin (n + 1) → ℝ) →L[ℝ] E} (hfc : continuous_on f (⇑box_integral.box.Icc I)) {x : fin (n + 1) → ℝ} (hxI : x ∈ ⇑box_integral.box.Icc I) {a : E} {ε : ℝ} (h0 : 0 < ε) (hε : ∀ (y : fin (n + 1) → ℝ), y ∈ ⇑box_integral.box.Icc I → ∥f y - a - ⇑f' (y - x)∥ ≤ ε * ∥y - x∥) {c : nnreal} (hc : I.distortion ≤ c) : ∥finset.univ.prod (λ (j : fin (n + 1)), I.upper j - I.lower j) • ⇑f' (pi.single i 1) - (box_integral.integral (I.face i) ⊥ (f ∘ i.insert_nth (I.upper i)) box_integral.box_additive_map.volume - box_integral.integral (I.face i) ⊥ (f ∘ i.insert_nth (I.lower i)) box_integral.box_additive_map.volume)∥ ≤ 2 * ε * ↑c * finset.univ.prod (λ (j : fin (n + 1)), I.upper j - I.lower j)
theorem antivary.sum_mul_lt_sum_comp_perm_mul_iff {ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {σ : equiv.perm ι} {f g : ι → α} [fintype ι] (hfg : antivary f g) : finset.univ.sum (λ (i : ι), f i * g i) < finset.univ.sum (λ (i : ι), f (⇑σ i) * g i) ↔ ¬antivary (f ∘ ⇑σ) g
theorem finset.sum_subtype_of_mem {β : Type u} {α : Type v} {s : finset α} [add_comm_monoid β] (f : α → β) {p : α → Prop} [decidable_pred p] (h : ∀ (x : α), x ∈ s → p x) : (finset.subtype p s).sum (λ (x : subtype p), f ↑x) = s.sum (λ (x : α), f x)
theorem is_regular_of_cancel_monoid {R : Type u_1} [cancel_monoid R] (g : R) : is_regular g
theorem filter.tendsto_iff_seq_tendsto {α : Type u_3} {β : Type u_4} {f : α → β} {k : filter α} {l : filter β} [k.is_countably_generated] : filter.tendsto f k l ↔ ∀ (x : ℕ → α), filter.tendsto x filter.at_top k → filter.tendsto (f ∘ x) filter.at_top l
theorem polynomial.has_separable_contraction.eq_degree {F : Type} [comm_semiring F] {f : polynomial F} (hf : polynomial.has_separable_contraction 1 f) : hf.degree = f.nat_degree
theorem is_add_monoid_hom.neg {α : Type u_1} {β : Type u_2} [add_zero_class α] [add_comm_group β] {f : α → β} (hf : is_add_monoid_hom f) : is_add_monoid_hom (λ (a : α), -f a)
theorem dense_inducing.separable_space {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {i : α → β} (di : dense_inducing i) [topological_space.separable_space α] : topological_space.separable_space β
theorem list.drop_take_succ_eq_cons_nth_le {α : Type u_1} (L : list α) {i : ℕ} (hi : i < L.length) : list.drop i (list.take (i + 1) L) = [L.nth_le i hi]
theorem zero_hom.ext_iff {M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] {f g : zero_hom M N} : f = g ↔ ∀ (x : M), ⇑f x = ⇑g x
theorem orientation.oangle_rotation_oangle_right {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x y : V) : o.oangle y (⇑(o.rotation (o.oangle x y)) x) = 0
theorem box_integral.prepartition.restrict_boxes_of_le {ι : Type u_1} {I J : box_integral.box ι} (π : box_integral.prepartition I) (h : I ≤ J) : (π.restrict J).boxes = π.boxes
theorem monotone.pairwise_disjoint_on_Ioo_succ {α : Type u_1} {β : Type u_2} [linear_order α] [succ_order α] [preorder β] {f : α → β} (hf : monotone f) : pairwise (disjoint on λ (n : α), set.Ioo (f n) (f (order.succ n)))
theorem real.disjoint_residual_ae  : disjoint (residual ℝ) measure_theory.measure_space.volume.ae
theorem finset.sum_smul_vsub_const_eq_weighted_vsub {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (w : ι → k) (p₁ : ι → P) (p₂ : P) (h : s.sum (λ (i : ι), w i) = 0) : s.sum (λ (i : ι), w i • (p₁ i -ᵥ p₂)) = ⇑(s.weighted_vsub p₁) w
theorem nat.factorization_mul {a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0) : (a * b).factorization = a.factorization + b.factorization
theorem smooth_bump_function.nhds_basis_support {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] (I : model_with_corners ℝ E H) {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {c : M} [t2_space M] {s : set M} (hs : s ∈ nhds c) : (nhds c).has_basis (λ (f : smooth_bump_function I c), tsupport ⇑f ⊆ s) (λ (f : smooth_bump_function I c), function.support ⇑f)
theorem asymptotics.is_o.of_neg_right {α : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : α → E} {g' : α → F'} {l : filter α} : (f =o[l] λ (x : α), -g' x) → f =o[l] g'
theorem category_theory.is_iso_iff_nonzero {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] {X Y : C} [category_theory.simple X] [category_theory.simple Y] (f : X ⟶ Y) : category_theory.is_iso f ↔ f ≠ 0
theorem is_localization.exist_integer_multiples_of_finset {R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] (s : finset S) : ∃ (b : ↥M), ∀ (a : S), a ∈ s → is_localization.is_integer R (↑b • a)
theorem cont_diff_bump_of_inner.convolution_tendsto_right' {G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G → E'} [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ E'] [inner_product_space ℝ G] [complete_space E'] [borel_space G] [measure_theory.is_locally_finite_measure μ] [μ.is_open_pos_measure] [finite_dimensional ℝ G] [μ.is_add_left_invariant] {ι : Type u_1} {φ : ι → cont_diff_bump_of_inner 0} {l : filter ι} (hφ : filter.tendsto (λ (i : ι), (φ i).R) l (nhds 0)) (hmg : measure_theory.ae_strongly_measurable g μ) {x₀ : G} (hcg : continuous_at g x₀) : filter.tendsto (λ (i : ι), convolution (λ (x : G), (φ i).normed μ x) g (continuous_linear_map.lsmul ℝ ℝ) μ x₀) l (nhds (g x₀))
theorem has_fderiv_within_at.unique_diff_within_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {s : set E} {f' : E →L[𝕜] F} {x : E} (h : has_fderiv_within_at f f' s x) (hs : unique_diff_within_at 𝕜 s x) (h' : dense_range ⇑f') : unique_diff_within_at 𝕜 (f '' s) (f x)
theorem complete_lattice.independent.sup_indep {α : Type u_1} {ι : Type u_3} [complete_lattice α] {s : finset ι} {f : ι → α} : complete_lattice.independent (f ∘ coe) → s.sup_indep f
theorem complex.tendsto_norm_sq_cocompact_at_top  : filter.tendsto ⇑complex.norm_sq (filter.cocompact ℂ) filter.at_top
theorem filter.tendsto.liminf_eq {α : Type u} {β : Type v} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {f : filter β} {u : β → α} {a : α} [f.ne_bot] (h : filter.tendsto u f (nhds a)) : f.liminf u = a
theorem funext {α : Sort u} {β : α → Sort v} {f₁ f₂ : Π (x : α), β x} (h : ∀ (x : α), f₁ x = f₂ x) : f₁ = f₂
theorem generate_from_pi_eq {ι : Type u_1} {α : ι → Type u_3} [fintype ι] {C : Π (i : ι), set (set (α i))} (hC : ∀ (i : ι), is_countably_spanning (C i)) : measurable_space.pi = measurable_space.generate_from (set.univ.pi '' set.univ.pi C)
theorem has_fpower_series_at.is_O_sub_partial_sum_pow {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] {f : E → F} {p : formal_multilinear_series 𝕜 E F} {x : E} (hf : has_fpower_series_at f p x) (n : ℕ) : (λ (y : E), f (x + y) - p.partial_sum n y) =O[nhds 0] λ (y : E), ∥y∥ ^ n
theorem set.abs_sub_left_of_mem_interval {α : Type u} [linear_ordered_add_comm_group α] {a b x : α} (h : x ∈ set.interval a b) : |x - a| ≤ |b - a|
theorem basis.orientation_comp_linear_equiv_eq_neg_iff_det_neg {R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {ι : Type u_3} [decidable_eq ι] [fintype ι] (e : basis ι R M) (f : M ≃ₗ[R] M) : (e.map f).orientation = -e.orientation ↔ ⇑linear_map.det ↑f < 0
theorem t2_iff_nhds {α : Type u} [topological_space α] : t2_space α ↔ ∀ {x y : α}, (nhds x ⊓ nhds y).ne_bot → x = y
theorem submonoid.fg_iff {M : Type u_1} [monoid M] (P : submonoid M) : P.fg ↔ ∃ (S : set M), submonoid.closure S = P ∧ S.finite
theorem generalized_continued_fraction.of_correctness_of_terminated_at {K : Type u_1} [linear_ordered_field K] {v : K} {n : ℕ} [floor_ring K] (terminated_at_n : (generalized_continued_fraction.of v).terminated_at n) : v = (generalized_continued_fraction.of v).convergents n
theorem finsum_eq_of_bijective {α : Type u_1} {β : Type u_2} {M : Type u_5} [add_comm_monoid M] {f : α → M} {g : β → M} (e : α → β) (he₀ : function.bijective e) (he₁ : ∀ (x : α), f x = g (e x)) : finsum (λ (i : α), f i) = finsum (λ (j : β), g j)
theorem rack.pre_envel_group_rel'.rel {R : Type u} [rack R] {a b : rack.pre_envel_group R} : rack.pre_envel_group_rel' R a b → rack.pre_envel_group_rel R a b
theorem zmod.legendre_sym_eq_pow (p : ℕ) (a : ℤ) [hp : fact (nat.prime p)] : ↑(zmod.legendre_sym p a) = ↑a ^ (p / 2)
theorem matrix.aeval_eq_aeval_mod_charpoly {R : Type u} [comm_ring R] {n : Type v} [decidable_eq n] [fintype n] (M : matrix n n R) (p : polynomial R) : ⇑(polynomial.aeval M) p = ⇑(polynomial.aeval M) (p %ₘ M.charpoly)
theorem affine.simplex.sum_points_with_circumcenter {α : Type u_1} [add_comm_monoid α] {n : ℕ} (f : affine.simplex.points_with_circumcenter_index n → α) : finset.univ.sum (λ (i : affine.simplex.points_with_circumcenter_index n), f i) = finset.univ.sum (λ (i : fin (n + 1)), f (affine.simplex.points_with_circumcenter_index.point_index i)) + f affine.simplex.points_with_circumcenter_index.circumcenter_index
theorem uniform_continuous_of_continuous_at_one {α : Type u_1} {β : Type u_2} [uniform_space α] [group α] [uniform_group α] {hom : Type u_3} [uniform_space β] [group β] [uniform_group β] [monoid_hom_class hom α β] (f : hom) (hf : continuous_at ⇑f 1) : uniform_continuous ⇑f
theorem category_theory.essentially_small.mk' {C : Type u} [category_theory.category C] {S : Type w} [category_theory.small_category S] (e : C ≌ S) : category_theory.essentially_small C
theorem right.one_lt_mul_of_lt_of_le {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 ≤ b) : 1 < a * b
theorem neg_le_self {α : Type u} [add_group α] [preorder α] [covariant_class α α has_add.add has_le.le] {a : α} (h : 0 ≤ a) : -a ≤ a
theorem is_preconnected_of_forall_pair {α : Type u} [topological_space α] {s : set α} (H : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → (∃ (t : set α) (H : t ⊆ s), x ∈ t ∧ y ∈ t ∧ is_preconnected t)) : is_preconnected s
theorem conformal_at_iff_differentiable_at_or_differentiable_at_comp_conj {f : ℂ → ℂ} {z : ℂ} : conformal_at f z ↔ (differentiable_at ℂ f z ∨ differentiable_at ℂ (f ∘ ⇑(star_ring_end ℂ)) (⇑(star_ring_end ℂ) z)) ∧ fderiv ℝ f z ≠ 0
theorem is_noetherian.finite_basis_index {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type u_1} {s : set ι} [is_noetherian K V] (b : basis ↥s K V) : s.finite
theorem approximates_linear_on.surj_on_closed_ball_of_nonlinear_right_inverse {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] [cs : complete_space E] {f : E → F} {s : set E} {c : nnreal} {f' : E →L[𝕜] F} (hf : approximates_linear_on f f' s c) (f'symm : f'.nonlinear_right_inverse) {ε : ℝ} {b : E} (ε0 : 0 ≤ ε) (hε : metric.closed_ball b ε ⊆ s) : set.surj_on f (metric.closed_ball b ε) (metric.closed_ball (f b) (((↑(f'symm.nnnorm))⁻¹ - ↑c) * ε))
theorem covby.is_atom {α : Type u_1} [partial_order α] [order_bot α] {a : α} : ⊥ ⋖ a → is_atom a
theorem padic_val_nat.zero {p : ℕ} : padic_val_nat p 0 = 0
theorem power_series.order_X_pow {R : Type u_1} [semiring R] [nontrivial R] (n : ℕ) : (power_series.X ^ n).order = ↑n
theorem subgroup.subset_closure {G : Type u_1} [group G] {k : set G} : k ⊆ ↑(subgroup.closure k)
theorem field.exists_primitive_element_of_fintype_top (F : Type u_1) [field F] (E : Type u_2) [field E] [algebra F E] [fintype E] : ∃ (α : E), F⟮α⟯ = ⊤
theorem category_theory.exact_inr_fst {𝒜 : Type u_1} [category_theory.category 𝒜] [category_theory.preadditive 𝒜] [category_theory.limits.has_kernels 𝒜] [category_theory.limits.has_images 𝒜] [category_theory.limits.has_binary_biproducts 𝒜] (A B : 𝒜) : category_theory.exact category_theory.limits.biprod.inr category_theory.limits.biprod.fst
theorem finset.centroid_pair_fin (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [invertible 2] (p : fin 2 → P) : finset.centroid k finset.univ p = 2⁻¹ • (p 1 -ᵥ p 0) +ᵥ p 0
theorem eq.subset' {α : Type u} [has_subset α] {a b : α} [is_refl α has_subset.subset] : a = b → a ⊆ b
theorem interval_integral.measure_integral_sub_linear_is_o_of_tendsto_ae_of_ge {ι : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a : ℝ} {c : E} {l l' : filter ℝ} {lt : filter ι} {μ : measure_theory.measure ℝ} {u v : ι → ℝ} [measure_theory.is_locally_finite_measure μ] [interval_integral.FTC_filter a l l'] (hfm : strongly_measurable_at_filter f l' μ) (hf : filter.tendsto f (l' ⊓ μ.ae) (nhds c)) (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) (huv : v ≤ᶠ[lt] u) : (λ (t : ι), ∫ (x : ℝ) in u t..v t, f x ∂μ + (⇑μ (set.Ioc (v t) (u t))).to_real • c) =o[lt] λ (t : ι), (⇑μ (set.Ioc (v t) (u t))).to_real
theorem module.subsingleton (R : Type u_1) (M : Type u_2) [semiring R] [subsingleton R] [add_comm_monoid M] [module R M] : subsingleton M
theorem power_series.order_monomial_of_ne_zero {R : Type u_1} [semiring R] (n : ℕ) (a : R) (h : a ≠ 0) : (⇑(power_series.monomial R n) a).order = ↑n
theorem linear_equiv.det_mul_det_symm {M : Type u_2} [add_comm_group M] {A : Type u_1} [comm_ring A] [module A M] (f : M ≃ₗ[A] M) : ⇑linear_map.det ↑f * ⇑linear_map.det ↑(f.symm) = 1
theorem polynomial.sum_range_pow_eq_bernoulli_sub (n p : ℕ) : (↑p + 1) * (finset.range n).sum (λ (k : ℕ), ↑k ^ p) = polynomial.eval ↑n (polynomial.bernoulli p.succ) - bernoulli p.succ
theorem category_theory.abelian.pseudoelement.exact_of_pseudo_exact {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q R : C} (f : P ⟶ Q) (g : Q ⟶ R) : ((∀ (a : ↥P), ⇑g (⇑f a) = 0) ∧ ∀ (b : ↥Q), ⇑g b = 0 → (∃ (a : ↥P), ⇑f a = b)) → category_theory.exact f g
theorem linear_ordered_comm_group_with_zero.nhds_zero_of_ne_zero {Γ₀ : Type u_1} [linear_ordered_comm_group_with_zero Γ₀] (γ : Γ₀) (h : γ ≠ 0) : {x : Γ₀ | x < γ} ∈ nhds 0
theorem cont_diff_on_clm_apply {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] [complete_space 𝕜] {n : with_top ℕ} {f : E → (F →L[𝕜] G)} {s : set E} [finite_dimensional 𝕜 F] : cont_diff_on 𝕜 n f s ↔ ∀ (y : F), cont_diff_on 𝕜 n (λ (x : E), ⇑(f x) y) s
theorem cont_diff.prod {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {n : with_top ℕ} {f : E → F} {g : E → G} (hf : cont_diff 𝕜 n f) (hg : cont_diff 𝕜 n g) : cont_diff 𝕜 n (λ (x : E), (f x, g x))
theorem polynomial.leading_coeff_prod {R : Type u} {ι : Type w} (s : finset ι) [comm_semiring R] [no_zero_divisors R] (f : ι → polynomial R) : (s.prod (λ (i : ι), f i)).leading_coeff = s.prod (λ (i : ι), (f i).leading_coeff)
theorem local_equiv.eq_on_source.source_inter_preimage_eq {α : Type u_1} {β : Type u_2} {e e' : local_equiv α β} (he : e ≈ e') (s : set β) : e.source ∩ ⇑e ⁻¹' s = e'.source ∩ ⇑e' ⁻¹' s
theorem affine.simplex.monge_point_eq_affine_combination_of_points_with_circumcenter {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P (n + 2)) : s.monge_point = ⇑(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.monge_point_weights_with_circumcenter n)
theorem category_theory.has_weakly_initial_of_weakly_initial_set_and_has_products {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {ι : Type v} {B : ι → C} (hB : ∀ (A : C), ∃ (i : ι), nonempty (B i ⟶ A)) : ∃ (T : C), ∀ (X : C), nonempty (T ⟶ X)
theorem metric.emetric_ball {α : Type u} [pseudo_metric_space α] {x : α} {ε : ℝ} : emetric.ball x (ennreal.of_real ε) = metric.ball x ε
theorem vector.scanl_singleton {α : Type u_1} {β : Type u_2} (f : β → α → β) (b : β) (v : vector α 1) : vector.scanl f b v = b::ᵥf b v.head::ᵥvector.nil
theorem finsum_mem_insert_zero {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} {a : α} {s : set α} (h : f a = 0) : finsum (λ (i : α), finsum (λ (H : i ∈ has_insert.insert a s), f i)) = finsum (λ (i : α), finsum (λ (H : i ∈ s), f i))
theorem besicovitch.exists_disjoint_closed_ball_covering_ae_aux {α : Type u_1} [metric_space α] [topological_space.second_countable_topology α] [measurable_space α] [opens_measurable_space α] [has_besicovitch_covering α] (μ : measure_theory.measure α) [measure_theory.sigma_finite μ] (f : α → set ℝ) (s : set α) (hf : ∀ (x : α), x ∈ s → ∀ (δ : ℝ), δ > 0 → (f x ∩ set.Ioo 0 δ).nonempty) : ∃ (t : set (α × ℝ)), t.countable ∧ (∀ (p : α × ℝ), p ∈ t → p.fst ∈ s) ∧ (∀ (p : α × ℝ), p ∈ t → p.snd ∈ f p.fst) ∧ ⇑μ (s  ⋃ (p : α × ℝ) (hp : p ∈ t), metric.closed_ball p.fst p.snd) = 0 ∧ t.pairwise_disjoint (λ (p : α × ℝ), metric.closed_ball p.fst p.snd)
theorem finite_dimensional.exists_nontrivial_relation_of_dim_lt_card {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] {t : finset V} (h : finite_dimensional.finrank K V < t.card) : ∃ (f : V → K), t.sum (λ (e : V), f e • e) = 0 ∧ ∃ (x : V) (H : x ∈ t), f x ≠ 0
theorem matrix.nondegenerate.eq_zero_of_ortho {m : Type u_1} {R : Type u_2} [fintype m] [comm_ring R] {M : matrix m m R} (hM : M.nondegenerate) {v : m → R} (hv : ∀ (w : m → R), matrix.dot_product v (M.mul_vec w) = 0) : v = 0
theorem phragmen_lindelof.eq_on_right_half_plane_of_superexponential_decay {E : Type u_1} [normed_group E] [normed_space ℂ E] {f g : ℂ → E} (hfd : diff_cont_on_cl ℂ f {z : ℂ | 0 < z.re}) (hgd : diff_cont_on_cl ℂ g {z : ℂ | 0 < z.re}) (hfexp : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ filter.principal {z : ℂ | 0 < z.re}] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hgexp : ∃ (c : ℝ) (H : c < 2) (B : ℝ), g =O[filter.comap complex.abs filter.at_top ⊓ filter.principal {z : ℂ | 0 < z.re}] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hre : asymptotics.superpolynomial_decay filter.at_top real.exp (λ (x : ℝ), ∥f ↑x - g ↑x∥)) (hfim : ∃ (C : ℝ), ∀ (x : ℝ), ∥f (↑x * complex.I)∥ ≤ C) (hgim : ∃ (C : ℝ), ∀ (x : ℝ), ∥g (↑x * complex.I)∥ ≤ C) : set.eq_on f g {z : ℂ | 0 ≤ z.re}
theorem topological_space.positive_compacts.locally_compact_space_of_group {G : Type w} [topological_space G] [group G] [topological_group G] [t2_space G] (K : topological_space.positive_compacts G) : locally_compact_space G
theorem has_lt.lt.not_lt {α : Type u} [preorder α] {a b : α} (h : a < b) : ¬b < a
theorem list.permutations_aux2_snd_eq {α : Type u_1} {β : Type u_2} (t : α) (ts : list α) (r : list β) (ys : list α) (f : list α → β) : (list.permutations_aux2 t ts r ys f).snd = list.map (λ (x : list α), f (x ++ ts)) (list.permutations_aux2 t list.nil list.nil ys id).snd ++ r
theorem tendsto_uniformly_iff_tendsto {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {p : filter ι} : tendsto_uniformly F f p ↔ filter.tendsto (λ (q : ι × α), (f q.snd, F q.fst q.snd)) (p.prod ⊤) (uniformity β)
theorem has_scalar.comp.is_scalar_tower {M : Type u_1} {N : Type u_2} {α : Type u_6} {β : Type u_7} [has_scalar M α] [has_scalar M β] [has_scalar α β] [is_scalar_tower M α β] (g : N → M) : is_scalar_tower N α β
theorem add_subsemigroup.closure_mono {M : Type u_1} [has_add M] ⦃s t : set M⦄ (h : s ⊆ t) : add_subsemigroup.closure s ≤ add_subsemigroup.closure t
theorem measure_theory.unif_integrable_const {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} {g : α → β} (hp : 1 ≤ p) (hp_ne_top : p ≠ ⊤) (hg : measure_theory.mem_ℒp g p μ) : measure_theory.unif_integrable (λ (n : ι), g) p μ
theorem fourier_subalgebra_separates_points  : fourier_subalgebra.separates_points
theorem polynomial.cyclotomic_ne_zero (n : ℕ) (R : Type u_1) [ring R] [nontrivial R] : polynomial.cyclotomic n R ≠ 0
theorem neg_neg_iff_pos {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : -a < 0 ↔ 0 < a
theorem finset.sup_indep.independent {α : Type u_1} {ι : Type u_3} [complete_lattice α] {s : finset ι} {f : ι → α} : s.sup_indep f → complete_lattice.independent (f ∘ coe)
theorem iterated_deriv_within_succ' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {n : ℕ} {f : 𝕜 → F} {s : set 𝕜} {x : 𝕜} (hxs : unique_diff_on 𝕜 s) (hx : x ∈ s) : iterated_deriv_within (n + 1) f s x = iterated_deriv_within n (deriv_within f s) s x
theorem subsemiring.closure_induction {R : Type u} [non_assoc_semiring R] {s : set R} {p : R → Prop} {x : R} (h : x ∈ subsemiring.closure s) (Hs : ∀ (x : R), x ∈ s → p x) (H0 : p 0) (H1 : p 1) (Hadd : ∀ (x y : R), p x → p y → p (x + y)) (Hmul : ∀ (x y : R), p x → p y → p (x * y)) : p x
theorem emetric.cauchy_seq_iff' {α : Type u} {β : Type v} [pseudo_emetric_space α] [nonempty β] [semilattice_sup β] {u : β → α} : cauchy_seq u ↔ ∀ (ε : ennreal), ε > 0 → (∃ (N : β), ∀ (n : β), n ≥ N → has_edist.edist (u n) (u N) < ε)
theorem is_add_left_regular.of_add {R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_left_regular (a + b)) : is_add_left_regular b
theorem finset.filter_eq' {β : Type u_2} [decidable_eq β] (s : finset β) (b : β) : finset.filter (λ (a : β), a = b) s = ite (b ∈ s) {b} ∅
theorem smul_add_smul_le_smul_add_smul' {k : Type u_1} {M : Type u_2} [ordered_ring k] [ordered_add_comm_group M] [module k M] [ordered_smul k M] [contravariant_class M M has_add.add has_le.le] {a b : k} {c d : M} (hba : b ≤ a) (hdc : d ≤ c) : a • d + b • c ≤ a • c + b • d
theorem category_theory.exponential_ideal.mk_of_iso {C : Type u₁} {D : Type u₂} [category_theory.category C] [category_theory.category D] (i : D ⥤ C) [category_theory.limits.has_finite_products C] [category_theory.cartesian_closed C] [category_theory.reflective i] (h : Π (A : C), i ⋙ category_theory.exp A ⋙ category_theory.left_adjoint i ⋙ i ≅ i ⋙ category_theory.exp A) : category_theory.exponential_ideal i
theorem free_group.injective_lift_of_ping_pong {ι : Type u_1} [nontrivial ι] {G : Type u_1} [group G] (a : ι → G) {α : Type u_4} [mul_action G α] (X Y : ι → set α) (hXnonempty : ∀ (i : ι), (X i).nonempty) (hXdisj : pairwise (λ (i j : ι), disjoint (X i) (X j))) (hYdisj : pairwise (λ (i j : ι), disjoint (Y i) (Y j))) (hXYdisj : ∀ (i j : ι), disjoint (X i) (Y j)) (hX : ∀ (i : ι), a i • (Y i)ᶜ ⊆ X i) (hY : ∀ (i : ι), a⁻¹ i • (X i)ᶜ ⊆ Y i) : function.injective ⇑(⇑free_group.lift a)
theorem add_submonoid.localization_map.comp_eq_of_eq {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M →+ P} {T : add_submonoid P} {Q : Type u_4} [add_comm_monoid Q] (hg : ∀ (y : ↥S), ⇑g ↑y ∈ T) (k : T.localization_map Q) {x y : M} (h : ⇑(f.to_map) x = ⇑(f.to_map) y) : ⇑(k.to_map) (⇑g x) = ⇑(k.to_map) (⇑g y)
theorem subring.one_mem {R : Type u} [ring R] (s : subring R) : 1 ∈ s
theorem norm_pow_le' {α : Type u_1} [semi_normed_ring α] (a : α) {n : ℕ} (h : 0 < n) : ∥a ^ n∥ ≤ ∥a∥ ^ n
theorem witt_vector.ghost_component_teichmuller (p : ℕ) {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (r : R) (n : ℕ) : ⇑(witt_vector.ghost_component n) (⇑(witt_vector.teichmuller p) r) = r ^ p ^ n
theorem asymptotics.is_O_with.neg_right {α : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {c : ℝ} {f : α → E} {g' : α → F'} {l : filter α} : asymptotics.is_O_with c l f g' → asymptotics.is_O_with c l f (λ (x : α), -g' x)
theorem measure_theory.lintegral_fn_integral_sub {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] ⦃f g : α × β → E⦄ (F : E → ennreal) (hf : measure_theory.integrable f (μ.prod ν)) (hg : measure_theory.integrable g (μ.prod ν)) : ∫⁻ (x : α), F (∫ (y : β), f (x, y) - g (x, y) ∂ν) ∂μ = ∫⁻ (x : α), F (∫ (y : β), f (x, y) ∂ν - ∫ (y : β), g (x, y) ∂ν) ∂μ
theorem filter.tendsto.const_mul_at_top' {α : Type u_1} {R : Type u_2} {l : filter α} {f : α → R} {r : R} [linear_ordered_semiring R] [archimedean R] (hr : 0 < r) (hf : filter.tendsto f l filter.at_top) : filter.tendsto (λ (x : α), r * f x) l filter.at_top
theorem ring_equiv.ext {R : Type u_4} {S : Type u_5} [has_mul R] [has_add R] [has_mul S] [has_add S] {f g : R ≃+* S} (h : ∀ (x : R), ⇑f x = ⇑g x) : f = g
theorem norm_zero_eq_zero {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (hS : is_closed ↑S) (m : M) (h : ∥⇑(quotient_add_group.mk' S) m∥ = 0) : m ∈ S
theorem measure_theory.exists_upper_semicontinuous_le_integral_le {α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] {μ : measure_theory.measure α} [μ.weakly_regular] (f : α → nnreal) (fint : measure_theory.integrable (λ (x : α), ↑(f x)) μ) {ε : ℝ} (εpos : 0 < ε) : ∃ (g : α → nnreal), (∀ (x : α), g x ≤ f x) ∧ upper_semicontinuous g ∧ measure_theory.integrable (λ (x : α), ↑(g x)) μ ∧ ∫ (x : α), ↑(f x) ∂μ - ε ≤ ∫ (x : α), ↑(g x) ∂μ
theorem category_theory.is_connected.of_constant_of_preserves_morphisms {J : Type u₁} [category_theory.category J] [nonempty J] (h : ∀ {α : Type u₁} (F : J → α), (∀ {j₁ j₂ : J}, (j₁ ⟶ j₂) → F j₁ = F j₂) → ∀ (j j' : J), F j = F j') : category_theory.is_connected J
theorem cont_mdiff_iff_target {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M → M'} {n : with_top ℕ} : cont_mdiff I I' n f ↔ continuous f ∧ ∀ (y : M'), cont_mdiff_on I (model_with_corners_self 𝕜 E') n (⇑(ext_chart_at I' y) ∘ f) (f ⁻¹' (ext_chart_at I' y).source)
theorem euclidean_geometry.dist_set_eq_iff_dist_orthogonal_projection_eq {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} [nonempty ↥s] [complete_space ↥(s.direction)] {ps : set P} (hps : ps ⊆ ↑s) (p : P) : ps.pairwise (λ (p1 p2 : P), has_dist.dist p1 p = has_dist.dist p2 p) ↔ ps.pairwise (λ (p1 p2 : P), has_dist.dist p1 ↑(⇑(euclidean_geometry.orthogonal_projection s) p) = has_dist.dist p2 ↑(⇑(euclidean_geometry.orthogonal_projection s) p))
theorem affine_independent_of_subsingleton (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} [subsingleton ι] (p : ι → P) : affine_independent k p
theorem bilin_form.nondegenerate_iff_ker_eq_bot {R₂ : Type u_5} {M₂ : Type u_6} [comm_semiring R₂] [add_comm_monoid M₂] [module R₂ M₂] {B : bilin_form R₂ M₂} : B.nondegenerate ↔ (⇑bilin_form.to_lin B).ker = ⊥
theorem add_subgroup.closure_induction₂ {G : Type u_1} [add_group G] {k : set G} {p : G → G → Prop} {x y : G} (hx : x ∈ add_subgroup.closure k) (hy : y ∈ add_subgroup.closure k) (Hk : ∀ (x : G), x ∈ k → ∀ (y : G), y ∈ k → p x y) (H1_left : ∀ (x : G), p 0 x) (H1_right : ∀ (x : G), p x 0) (Hmul_left : ∀ (x₁ x₂ y : G), p x₁ y → p x₂ y → p (x₁ + x₂) y) (Hmul_right : ∀ (x y₁ y₂ : G), p x y₁ → p x y₂ → p x (y₁ + y₂)) (Hinv_left : ∀ (x y : G), p x y → p (-x) y) (Hinv_right : ∀ (x y : G), p x y → p x (-y)) : p x y
theorem add_monoid_hom.map_mul_iff {R : Type u_1} {S : Type u_2} [non_unital_non_assoc_semiring R] [non_unital_non_assoc_semiring S] (f : R →+ S) : (∀ (x y : R), ⇑f (x * y) = ⇑f x * ⇑f y) ↔ add_monoid_hom.mul.compr₂ f = (add_monoid_hom.mul.comp f).compl₂ f
theorem add_con.add_con_gen_eq {M : Type u_1} [has_add M] (r : M → M → Prop) : add_con_gen r = has_Inf.Inf {s : add_con M | ∀ (x y : M), r x y → ⇑s x y}
theorem is_add_hom.add {α : Type u_1} {β : Type u_2} [add_semigroup α] [add_comm_semigroup β] {f g : α → β} (hf : is_add_hom f) (hg : is_add_hom g) : is_add_hom (λ (a : α), f a + g a)
theorem polynomial.lifts_and_degree_eq_and_monic {R : Type u} [semiring R] {S : Type v} [semiring S] {f : R →+* S} [nontrivial S] {p : polynomial S} (hlifts : p ∈ polynomial.lifts f) (hp : p.monic) : ∃ (q : polynomial R), polynomial.map f q = p ∧ q.degree = p.degree ∧ q.monic
theorem intermediate_value_univ₂ {X : Type u} {α : Type v} [topological_space X] [linear_order α] [topological_space α] [order_closed_topology α] [preconnected_space X] {a b : X} {f g : X → α} (hf : continuous f) (hg : continuous g) (ha : f a ≤ g a) (hb : g b ≤ f b) : ∃ (x : X), f x = g x
theorem cont_diff_groupoid_le {m n : with_top ℕ} {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) (h : m ≤ n) : cont_diff_groupoid n I ≤ cont_diff_groupoid m I
theorem continuous_at_left_of_monotone_on_of_exists_between {α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} {a : α} (hf : monotone_on f s) (hs : s ∈ nhds_within a (set.Iic a)) (hfs : ∀ (b : β), b < f a → (∃ (c : α) (H : c ∈ s), f c ∈ set.Ioo b (f a))) : continuous_within_at f (set.Iic a) a
theorem formal_multilinear_series.congr {𝕜 : Type u_1} {E : Type u_3} {F : Type u_4} [comm_ring 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] [add_comm_group F] [module 𝕜 F] [topological_space F] [topological_add_group F] [has_continuous_const_smul 𝕜 F] (p : formal_multilinear_series 𝕜 E F) {m n : ℕ} {v : fin m → E} {w : fin n → E} (h1 : m = n) (h2 : ∀ (i : ℕ) (him : i < m) (hin : i < n), v ⟨i, him⟩ = w ⟨i, hin⟩) : ⇑(p m) v = ⇑(p n) w
theorem interval_integral.integral_has_deriv_at_right {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (hb : continuous_at f b) : has_deriv_at (λ (u : ℝ), ∫ (x : ℝ) in a..u, f x) (f b) b
theorem pnat.factor_multiset_gcd (m n : ℕ+) : (m.gcd n).factor_multiset = m.factor_multiset ⊓ n.factor_multiset
theorem formal_multilinear_series.partial_sum_continuous {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [ring 𝕜] [add_comm_group E] [add_comm_group F] [module 𝕜 E] [module 𝕜 F] [topological_space E] [topological_space F] [topological_add_group E] [topological_add_group F] [has_continuous_const_smul 𝕜 E] [has_continuous_const_smul 𝕜 F] (p : formal_multilinear_series 𝕜 E F) (n : ℕ) : continuous (p.partial_sum n)
theorem nat.exists_strict_anti (α : Type u) [preorder α] [nonempty α] [no_min_order α] : ∃ (f : ℕ → α), strict_anti f
theorem units.mk_semiconj_by {M : Type u} [monoid M] (u : Mˣ) (x : M) : semiconj_by ↑u x (↑u * x * ↑u⁻¹)
theorem nnreal.Lp_add_le_has_sum {ι : Type u} {f g : ι → nnreal} {A B : nnreal} {p : ℝ} (hp : 1 ≤ p) (hf : has_sum (λ (i : ι), f i ^ p) (A ^ p)) (hg : has_sum (λ (i : ι), g i ^ p) (B ^ p)) : ∃ (C : nnreal), C ≤ A + B ∧ has_sum (λ (i : ι), (f i + g i) ^ p) (C ^ p)
theorem probability_theory.cond_cond_eq_cond_inter {α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) {s t : set α} [measure_theory.is_finite_measure μ] (hms : measurable_set s) (hmt : measurable_set t) (hci : ⇑μ (s ∩ t) ≠ 0) : probability_theory.cond (probability_theory.cond μ s) t = probability_theory.cond μ (s ∩ t)
theorem nat.bitwise_comm {f : bool → bool → bool} (hf : ∀ (b b' : bool), f b b' = f b' b) (hf' : f bool.ff bool.ff = bool.ff) (n m : ℕ) : nat.bitwise f n m = nat.bitwise f m n
theorem polynomial.eval_monomial_one_add_sub {S : Type v} [comm_ring S] (d : ℕ) (y : S) : polynomial.eval (1 + y) (⇑(polynomial.monomial d) (↑d + 1)) - polynomial.eval y (⇑(polynomial.monomial d) (↑d + 1)) = (finset.range (d + 1)).sum (λ (x_1 : ℕ), ↑((d + 1).choose x_1) * (↑x_1 * y ^ (x_1 - 1)))
theorem mem_nhds_within_Iio_iff_exists_Ioo_subset' {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a l' : α} {s : set α} (hl' : l' < a) : s ∈ nhds_within a (set.Iio a) ↔ ∃ (l : α) (H : l ∈ set.Iio a), set.Ioo l a ⊆ s
theorem free_group.red.church_rosser {α : Type u} {L₁ L₂ L₃ : list (α × bool)} : free_group.red L₁ L₂ → free_group.red L₁ L₃ → relation.join free_group.red L₂ L₃
theorem measure_theory.add_haar_measure_eq_volume_pi (ι : Type u_1) [fintype ι] : measure_theory.measure.add_haar_measure (topological_space.positive_compacts.pi_Icc01 ι) = measure_theory.measure_space.volume
theorem is_left_regular.mul {R : Type u_1} {a b : R} [semigroup R] (lra : is_left_regular a) (lrb : is_left_regular b) : is_left_regular (a * b)
theorem affine_subspace.top_coe (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : ↑⊤ = set.univ
theorem category_theory.equiv_relation {J : Type u₁} [category_theory.category J] [category_theory.is_connected J] (r : J → J → Prop) (hr : equivalence r) (h : ∀ {j₁ j₂ : J}, (j₁ ⟶ j₂) → r j₁ j₂) (j₁ j₂ : J) : r j₁ j₂
theorem nat.desc_factorial_of_lt {n k : ℕ} : n < k → n.desc_factorial k = 0
theorem module.End.pos_finrank_generalized_eigenspace_of_has_eigenvalue {K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {f : module.End K V} {k : ℕ} {μ : K} (hx : f.has_eigenvalue μ) (hk : 0 < k) : 0 < finite_dimensional.finrank K ↥(⇑(f.generalized_eigenspace μ) k)
theorem monotone.pairwise_disjoint_on_Ioo_pred {α : Type u_1} {β : Type u_2} [linear_order α] [pred_order α] [preorder β] {f : α → β} (hf : monotone f) : pairwise (disjoint on λ (n : α), set.Ioo (f (order.pred n)) (f n))
theorem cont_diff_bump_of_inner.convolution_eq_right {G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G → E'} [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ E'] [inner_product_space ℝ G] [complete_space E'] {φ : cont_diff_bump_of_inner 0} {x₀ : G} (hg : ∀ (x : G), x ∈ metric.ball x₀ φ.R → g x = g x₀) : convolution ⇑φ g (continuous_linear_map.lsmul ℝ ℝ) μ x₀ = measure_theory.integral μ ⇑φ • g x₀
theorem measure_theory.measure.pi_eq_generate_from {ι : Type u_1} {α : ι → Type u_3} [fintype ι] [Π (i : ι), measurable_space (α i)] {μ : Π (i : ι), measure_theory.measure (α i)} {C : Π (i : ι), set (set (α i))} (hC : ∀ (i : ι), measurable_space.generate_from (C i) = _inst_3 i) (h2C : ∀ (i : ι), is_pi_system (C i)) (h3C : Π (i : ι), (μ i).finite_spanning_sets_in (C i)) {μν : measure_theory.measure (Π (i : ι), α i)} (h₁ : ∀ (s : Π (i : ι), set (α i)), (∀ (i : ι), s i ∈ C i) → ⇑μν (set.univ.pi s) = finset.univ.prod (λ (i : ι), ⇑(μ i) (s i))) : measure_theory.measure.pi μ = μν
theorem unique_diff_on.unique_mdiff_on {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {s : set E} : unique_diff_on 𝕜 s → unique_mdiff_on (model_with_corners_self 𝕜 E) s
theorem euclidean_geometry.inter_eq_singleton_orthogonal_projection_fn {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} [nonempty ↥s] [complete_space ↥(s.direction)] (p : P) : ↑s ∩ ↑(affine_subspace.mk' p (s.direction)ᗮ) = {euclidean_geometry.orthogonal_projection_fn s p}
theorem convex.monotone_on_of_deriv_nonneg {D : set ℝ} (hD : convex ℝ D) {f : ℝ → ℝ} (hf : continuous_on f D) (hf' : differentiable_on ℝ f (interior D)) (hf'_nonneg : ∀ (x : ℝ), x ∈ interior D → 0 ≤ deriv f x) : monotone_on f D
theorem lattice_ordered_comm_group.abs_abs {α : Type u} [lattice α] [add_comm_group α] [covariant_class α α has_add.add has_le.le] (a : α) : ||a|| = |a|
theorem nat.arithmetic_function.prod_eq_iff_prod_pow_moebius_eq_of_nonzero {R : Type u_1} [comm_group_with_zero R] {f g : ℕ → R} (hf : ∀ (n : ℕ), 0 < n → f n ≠ 0) (hg : ∀ (n : ℕ), 0 < n → g n ≠ 0) : (∀ (n : ℕ), 0 < n → n.divisors.prod (λ (i : ℕ), f i) = g n) ↔ ∀ (n : ℕ), 0 < n → n.divisors_antidiagonal.prod (λ (x : ℕ × ℕ), g x.snd ^ ⇑nat.arithmetic_function.moebius x.fst) = f n
theorem affine.simplex.sum_reflection_circumcenter_weights_with_circumcenter {n : ℕ} {i₁ i₂ : fin (n + 1)} (h : i₁ ≠ i₂) : finset.univ.sum (λ (i : affine.simplex.points_with_circumcenter_index n), affine.simplex.reflection_circumcenter_weights_with_circumcenter i₁ i₂ i) = 1
theorem metric.thickening_eq_bUnion_ball {X : Type u} [pseudo_metric_space X] {δ : ℝ} {E : set X} : metric.thickening δ E = ⋃ (x : X) (H : x ∈ E), metric.ball x δ
theorem add_monoid.is_torsion.module_of_fintype (R : Type u_3) (M : Type u_4) [add_comm_monoid M] [ring R] [fintype R] [module R M] : add_monoid.is_torsion M
theorem spectrum.has_fpower_series_on_ball_inverse_one_sub_smul (𝕜 : Type u_1) {A : Type u_2} [nondiscrete_normed_field 𝕜] [normed_ring A] [normed_algebra 𝕜 A] [complete_space A] (a : A) : has_fpower_series_on_ball (λ (z : 𝕜), ring.inverse (1 - z • a)) (λ (n : ℕ), continuous_multilinear_map.mk_pi_field 𝕜 (fin n) (a ^ n)) 0 (↑∥a∥₊)⁻¹
theorem continuous.exists_forall_ge {α : Type u_1} {β : Type u_2} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [topological_space β] [nonempty β] {f : β → α} (hf : continuous f) (hlim : filter.tendsto f (filter.cocompact β) filter.at_bot) : ∃ (x : β), ∀ (y : β), f y ≤ f x
theorem inner_product_geometry.angle_neg_right {V : Type u_1} [inner_product_space ℝ V] (x y : V) : inner_product_geometry.angle x (-y) = real.pi - inner_product_geometry.angle x y
theorem is_left_regular_of_left_cancel_semigroup {R : Type u_1} [left_cancel_semigroup R] (g : R) : is_left_regular g
theorem is_cyclotomic_extension.trans (S T : set ℕ+) (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] (C : Type w) [comm_ring C] [algebra A C] [algebra B C] [is_scalar_tower A B C] [hS : is_cyclotomic_extension S A B] [hT : is_cyclotomic_extension T B C] : is_cyclotomic_extension (S ∪ T) A C
theorem is_topological_fiber_bundle.is_open_map_proj {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : is_open_map proj
theorem pythagorean_triple.classification {x y z : ℤ} : pythagorean_triple x y z ↔ ∃ (k m n : ℤ), (x = k * (m ^ 2 - n ^ 2) ∧ y = k * (2 * m * n) ∨ x = k * (2 * m * n) ∧ y = k * (m ^ 2 - n ^ 2)) ∧ (z = k * (m ^ 2 + n ^ 2) ∨ z = -k * (m ^ 2 + n ^ 2))
theorem finset.prod_univ_pi {α : Type u_1} {β : Type u_2} [decidable_eq α] [fintype α] [comm_monoid β] {δ : α → Type u_3} {t : Π (a : α), finset (δ a)} (f : (Π (a : α), a ∈ finset.univ → δ a) → β) : (finset.univ.pi t).prod (λ (x : Π (a : α), a ∈ finset.univ → δ a), f x) = (fintype.pi_finset t).prod (λ (x : Π (a : α), δ a), f (λ (a : α) (_x : a ∈ finset.univ), x a))
theorem tendsto_of_tendsto_of_tendsto_of_le_of_le {α : Type u} {β : Type v} [topological_space α] [partial_order α] [t : order_topology α] {f g h : β → α} {b : filter β} {a : α} (hg : filter.tendsto g b (nhds a)) (hh : filter.tendsto h b (nhds a)) (hgf : g ≤ f) (hfh : f ≤ h) : filter.tendsto f b (nhds a)
theorem prime_spectrum.exists_prime_spectrum_prod_le (R : Type u) [comm_ring R] [is_noetherian_ring R] (I : ideal R) : ∃ (Z : multiset (prime_spectrum R)), (multiset.map coe Z).prod ≤ I
theorem category_theory.limits.has_binary_biproducts.of_has_binary_products {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_products C] : category_theory.limits.has_binary_biproducts C
theorem fin.prod_univ_zero {β : Type u_2} [comm_monoid β] (f : fin 0 → β) : finset.univ.prod (λ (i : fin 0), f i) = 1
theorem measure_theory.signed_measure.exists_subset_restrict_nonpos {α : Type u_1} [measurable_space α] {s : measure_theory.signed_measure α} {i : set α} (hi : ⇑s i < 0) : ∃ (j : set α), measurable_set j ∧ j ⊆ i ∧ measure_theory.vector_measure.restrict s j ≤ 0.restrict j ∧ ⇑s j < 0
theorem filter.tendsto.eventually_interval_integrable {ι : Type u_1} {E : Type u_3} [normed_group E] {f : ℝ → E} {μ : measure_theory.measure ℝ} {l l' : filter ℝ} (hfm : strongly_measurable_at_filter f l' μ) [filter.tendsto_Ixx_class set.Ioc l l'] [l'.is_measurably_generated] (hμ : μ.finite_at_filter l') {c : E} (hf : filter.tendsto f l' (nhds c)) {u v : ι → ℝ} {lt : filter ι} (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) : ∀ᶠ (t : ι) in lt, interval_integrable f μ (u t) (v t)
theorem is_compact.exists_mem_frontier_inf_dist_compl_eq_dist {E : Type u_1} [normed_group E] [normed_space ℝ E] [nontrivial E] {x : E} {K : set E} (hK : is_compact K) (hx : x ∈ K) : ∃ (y : E) (H : y ∈ frontier K), metric.inf_dist x Kᶜ = has_dist.dist x y
theorem category_theory.cocone_of_representable_ι_app {C : Type u₁} [category_theory.small_category C] (P : Cᵒᵖ ⥤ Type u₁) (j : (P.elements)ᵒᵖ) : (category_theory.cocone_of_representable P).ι.app j = (category_theory.yoneda_sections_small ((category_theory.category_of_elements.π P).left_op.obj j) (((category_theory.functor.const (P.elements)ᵒᵖ).obj (category_theory.cocone_of_representable P).X).obj j)).inv (opposite.unop j).snd
theorem normed_space.bounded_polar_of_mem_nhds_zero (𝕜 : Type u_1) [nondiscrete_normed_field 𝕜] {E : Type u_2} [semi_normed_group E] [normed_space 𝕜 E] {s : set E} (s_nhd : s ∈ nhds 0) : metric.bounded (normed_space.polar 𝕜 s)
theorem has_fderiv_at_filter_iff_has_deriv_at_filter {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {F : Type v} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {x : 𝕜} {L : filter 𝕜} {f' : 𝕜 →L[𝕜] F} : has_fderiv_at_filter f f' x L ↔ has_deriv_at_filter f (⇑f' 1) x L
theorem category_theory.limits.is_iso_colimit_cocone_parallel_pair_of_self {C : Type u} [category_theory.category C] {X Y : C} {f : X ⟶ Y} {c : category_theory.limits.cofork f f} (h : category_theory.limits.is_colimit c) : category_theory.is_iso c.π
theorem add_neg' {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0
theorem lower_semicontinuous_at.add {α : Type u_1} [topological_space α] {x : α} {γ : Type u_4} [linear_ordered_add_comm_monoid γ] [topological_space γ] [order_topology γ] [has_continuous_add γ] {f g : α → γ} (hf : lower_semicontinuous_at f x) (hg : lower_semicontinuous_at g x) : lower_semicontinuous_at (λ (z : α), f z + g z) x
theorem category_theory.exp_comparison_whisker_left {C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] [category_theory.limits.has_finite_products C] [category_theory.limits.has_finite_products D] (F : C ⥤ D) [category_theory.cartesian_closed C] [category_theory.cartesian_closed D] [category_theory.limits.preserves_limits_of_shape (category_theory.discrete category_theory.limits.walking_pair) F] {A A' : C} (f : A' ⟶ A) : category_theory.exp_comparison F A ≫ category_theory.whisker_left F (category_theory.pre (F.map f)) = category_theory.whisker_right (category_theory.pre f) F ≫ category_theory.exp_comparison F A'
theorem list.nth_le_take {α : Type u} (L : list α) {i j : ℕ} (hi : i < L.length) (hj : i < j) : L.nth_le i hi = (list.take j L).nth_le i _
theorem Top.presheaf.is_iso_of_stalk_functor_map_iso {C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X : Top} [category_theory.concrete_category C] [category_theory.limits.preserves_filtered_colimits (category_theory.forget C)] [category_theory.limits.has_limits C] [category_theory.limits.preserves_limits (category_theory.forget C)] [category_theory.reflects_isomorphisms (category_theory.forget C)] {F G : Top.sheaf C X} (f : F ⟶ G) [∀ (x : ↥X), category_theory.is_iso ((Top.presheaf.stalk_functor C x).map f)] : category_theory.is_iso f
theorem edist_nndist {α : Type u} [pseudo_metric_space α] (x y : α) : has_edist.edist x y = ↑(has_nndist.nndist x y)
theorem has_fderiv_at_ring_inverse {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {R : Type u_6} [normed_ring R] [normed_algebra 𝕜 R] [complete_space R] (x : Rˣ) : has_fderiv_at ring.inverse (-⇑(⇑(continuous_linear_map.lmul_left_right 𝕜 R) ↑x⁻¹) ↑x⁻¹) ↑x
theorem matrix.conj_transpose_apply {m : Type u_2} {n : Type u_3} {α : Type v} [has_star α] (M : matrix m n α) (i : m) (j : n) : M.conj_transpose j i = has_star.star (M i j)
theorem strict_convex_closed_ball (𝕜 : Type u_1) {E : Type u_2} [normed_linear_ordered_field 𝕜] [normed_group E] [normed_space 𝕜 E] [strict_convex_space 𝕜 E] (x : E) (r : ℝ) : strict_convex 𝕜 (metric.closed_ball x r)
theorem finset.weighted_vsub_of_point_vadd_eq_of_sum_eq_one {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (w : ι → k) (p : ι → P) (h : s.sum (λ (i : ι), w i) = 1) (b₁ b₂ : P) : ⇑(s.weighted_vsub_of_point p b₁) w +ᵥ b₁ = ⇑(s.weighted_vsub_of_point p b₂) w +ᵥ b₂
theorem complex.has_fpower_series_on_ball_of_differentiable_off_countable {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] {R : nnreal} {c : ℂ} {f : ℂ → E} {s : set ℂ} (hs : s.countable) (hc : continuous_on f (metric.closed_ball c ↑R)) (hd : ∀ (z : ℂ), z ∈ metric.ball c ↑R  s → differentiable_at ℂ f z) (hR : 0 < R) : has_fpower_series_on_ball f (cauchy_power_series f c ↑R) c ↑R
theorem lp.mem_ℓp_of_tendsto {α : Type u_1} {E : α → Type u_2} {p : ennreal} [Π (i : α), normed_group (E i)] {ι : Type u_3} {l : filter ι} [l.ne_bot] [fact (1 ≤ p)] {F : ι → ↥(lp E p)} (hF : metric.bounded (set.range F)) {f : Π (a : α), E a} (hf : filter.tendsto (id (λ (i : ι), ⇑(F i))) l (nhds f)) : mem_ℓp f p
theorem category_theory.limits.prod_comparison_natural {C : Type u} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) {A A' B B' : C} [category_theory.limits.has_binary_product A B] [category_theory.limits.has_binary_product A' B'] [category_theory.limits.has_binary_product (F.obj A) (F.obj B)] [category_theory.limits.has_binary_product (F.obj A') (F.obj B')] (f : A ⟶ A') (g : B ⟶ B') : F.map (category_theory.limits.prod.map f g) ≫ category_theory.limits.prod_comparison F A' B' = category_theory.limits.prod_comparison F A B ≫ category_theory.limits.prod.map (F.map f) (F.map g)
theorem convex_hull_eq_union {𝕜 : Type u_1} {E : Type u} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] {s : set E} : ⇑(convex_hull 𝕜) s = ⋃ (t : finset E) (hss : ↑t ⊆ s) (hai : affine_independent 𝕜 coe), ⇑(convex_hull 𝕜) ↑t
theorem set.finite.eventually_all {α : Type u} {ι : Type u_1} {I : set ι} (hI : I.finite) {l : filter α} {p : ι → α → Prop} : (∀ᶠ (x : α) in l, ∀ (i : ι), i ∈ I → p i x) ↔ ∀ (i : ι), i ∈ I → (∀ᶠ (x : α) in l, p i x)
theorem is_compact.exists_open_superset_measure_lt_top' {α : Type u_1} [topological_space α] [measurable_space α] {μ : measure_theory.measure α} {s : set α} (h : is_compact s) (hμ : ∀ (x : α), x ∈ s → μ.finite_at_filter (nhds x)) : ∃ (U : set α) (H : U ⊇ s), is_open U ∧ ⇑μ U < ⊤
theorem subgroup.closure_mul_image_eq_top' {G : Type u_1} [group G] {H : subgroup G} [decidable_eq G] {R S : finset G} (hR : ↑R ∈ subgroup.right_transversals ↑H) (hR1 : 1 ∈ R) (hS : subgroup.closure ↑S = ⊤) : subgroup.closure ↑(finset.image (λ (g : G), ⟨g * (↑(subgroup.mem_right_transversals.to_fun hR g))⁻¹, _⟩) (R * S)) = ⊤
theorem exp_add_of_mem_ball {𝕂 : Type u_1} {𝔸 : Type u_2} [nondiscrete_normed_field 𝕂] [normed_comm_ring 𝔸] [normed_algebra 𝕂 𝔸] [complete_space 𝔸] [char_zero 𝕂] {x y : 𝔸} (hx : x ∈ emetric.ball 0 (exp_series 𝕂 𝔸).radius) (hy : y ∈ emetric.ball 0 (exp_series 𝕂 𝔸).radius) : exp 𝕂 (x + y) = exp 𝕂 x * exp 𝕂 y
theorem add_submonoid.localization_map.lift_add_right {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M →+ P} (hg : ∀ (y : ↥S), is_add_unit (⇑g ↑y)) (z : N) : ⇑(f.lift hg) z + ⇑g ↑((f.sec z).snd) = ⇑g (f.sec z).fst
theorem inner_product_geometry.angle_self_neg_of_nonzero {V : Type u_1} [inner_product_space ℝ V] {x : V} (hx : x ≠ 0) : inner_product_geometry.angle x (-x) = real.pi
theorem finprod_mem_insert_one {α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M} {a : α} {s : set α} (h : f a = 1) : finprod (λ (i : α), finprod (λ (H : i ∈ has_insert.insert a s), f i)) = finprod (λ (i : α), finprod (λ (H : i ∈ s), f i))
theorem continuous_linear_map.is_open_map_of_ne_zero {R : Type u_1} {M : Type u_2} [topological_space R] [division_ring R] [has_continuous_sub R] [add_comm_group M] [topological_space M] [has_continuous_add M] [module R M] [has_continuous_smul R M] (f : M →L[R] R) (hf : f ≠ 0) : is_open_map ⇑f
theorem is_cyclotomic_extension.splitting_field_cyclotomic (n : ℕ+) (K : Type w) (L : Type z) [field K] [field L] [algebra K L] [ne_zero ↑↑n] [is_cyclotomic_extension {n} K L] : polynomial.is_splitting_field K L (polynomial.cyclotomic ↑n K)
theorem category_theory.inv_map_unit {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {L : C ⥤ D} {R : D ⥤ C} (h : L ⊣ R) {X : C} [category_theory.is_iso (h.unit.app X)] : category_theory.inv (L.map (h.unit.app X)) = h.counit.app (L.obj X)
theorem filter.map₂_distrib_le_left {α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {γ' : Type u_6} {δ : Type u_7} {ε : Type u_9} {f : filter α} {g : filter β} {h : filter γ} {m : α → δ → ε} {n : β → γ → δ} {m₁ : α → β → β'} {m₂ : α → γ → γ'} {n' : β' → γ' → ε} (h_distrib : ∀ (a : α) (b : β) (c : γ), m a (n b c) = n' (m₁ a b) (m₂ a c)) : filter.map₂ m f (filter.map₂ n g h) ≤ filter.map₂ n' (filter.map₂ m₁ f g) (filter.map₂ m₂ f h)
theorem matrix.det_mul_comm {m : Type u_1} [decidable_eq m] [fintype m] {R : Type v} [comm_ring R] (M N : matrix m m R) : (M.mul N).det = (N.mul M).det
theorem balanced.subset_core_of_subset {𝕜 : Type u_1} {E : Type u_2} [semi_normed_ring 𝕜] [has_scalar 𝕜 E] {s t : set E} (hs : balanced 𝕜 s) (h : s ⊆ t) : s ⊆ balanced_core 𝕜 t
theorem category_theory.limits.finite_limits_from_equalizers_and_finite_products {C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_finite_limits C
theorem measure_theory.analytic_set_iff_exists_polish_space_range {α : Type u_1} [topological_space α] {s : set α} : measure_theory.analytic_set s ↔ ∃ (β : Type) (h : topological_space β) (h' : polish_space β) (f : β → α), continuous f ∧ set.range f = s
theorem fractional_ideal.is_noetherian {R₁ : Type u_3} [comm_ring R₁] {K : Type u_4} [field K] [algebra R₁ K] [frac : is_fraction_ring R₁ K] [is_domain R₁] [is_noetherian_ring R₁] (I : fractional_ideal (non_zero_divisors R₁) K) : is_noetherian R₁ ↥I
theorem is_submonoid.power_subset {M : Type u_1} [monoid M] {s : set M} {a : M} (hs : is_submonoid s) (h : a ∈ s) : powers a ⊆ s
theorem category_theory.limits.image_subobject_iso_comp {C : Type u} [category_theory.category C] {X Y : C} [category_theory.limits.has_equalizers C] {X' : C} (h : X' ⟶ X) [category_theory.is_iso h] (f : X ⟶ Y) [category_theory.limits.has_image f] : category_theory.limits.image_subobject (h ≫ f) = category_theory.limits.image_subobject f
theorem has_lt.lt.trans {α : Type u} [preorder α] {a b c : α} : a < b → b < c → a < c
theorem real.rpow_sum_le_const_mul_sum_rpow {ι : Type u} (s : finset ι) (f : ι → ℝ) {p : ℝ} (hp : 1 ≤ p) : s.sum (λ (i : ι), |f i|) ^ p ≤ ↑(s.card) ^ (p - 1) * s.sum (λ (i : ι), |f i| ^ p)
theorem linear_map.continuous_of_finite_dimensional {𝕜 : Type u} [hnorm : nondiscrete_normed_field 𝕜] {E : Type v} [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_smul 𝕜 E] {F' : Type x} [add_comm_group F'] [module 𝕜 F'] [topological_space F'] [topological_add_group F'] [has_continuous_smul 𝕜 F'] [complete_space 𝕜] [t2_space E] [finite_dimensional 𝕜 E] (f : E →ₗ[𝕜] F') : continuous ⇑f
theorem continuous_linear_map.op_norm_lsmul_le {𝕜 : Type u_1} {E : Type u_4} [semi_normed_group E] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] {𝕜' : Type u_10} [normed_field 𝕜'] [normed_algebra 𝕜 𝕜'] [normed_space 𝕜' E] [is_scalar_tower 𝕜 𝕜' E] : ∥continuous_linear_map.lsmul 𝕜 𝕜'∥ ≤ 1
theorem category_theory.limits.coprod_comparison_natural {C : Type u} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) {A A' B B' : C} [category_theory.limits.has_binary_coproduct A B] [category_theory.limits.has_binary_coproduct A' B'] [category_theory.limits.has_binary_coproduct (F.obj A) (F.obj B)] [category_theory.limits.has_binary_coproduct (F.obj A') (F.obj B')] (f : A ⟶ A') (g : B ⟶ B') : category_theory.limits.coprod_comparison F A B ≫ F.map (category_theory.limits.coprod.map f g) = category_theory.limits.coprod.map (F.map f) (F.map g) ≫ category_theory.limits.coprod_comparison F A' B'
theorem cSup_insert {α : Type u_1} [conditionally_complete_lattice α] {s : set α} {a : α} (hs : bdd_above s) (sne : s.nonempty) : has_Sup.Sup (has_insert.insert a s) = a ⊔ has_Sup.Sup s
theorem abs_add {α : Type u} [linear_ordered_add_comm_group α] (a b : α) : |a + b| ≤ |a| + |b|
theorem generalized_continued_fraction.abs_sub_convergents_le {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] (not_terminated_at_n : ¬(generalized_continued_fraction.of v).terminated_at n) : |v - (generalized_continued_fraction.of v).convergents n| ≤ 1 / ((generalized_continued_fraction.of v).denominators n * (generalized_continued_fraction.of v).denominators (n + 1))
theorem list.is_suffix.reverse {α : Type u_1} {l₁ l₂ : list α} : l₁ <:+ l₂ → l₁.reverse <+: l₂.reverse
theorem is_primitive_root.norm_eq_neg_one_pow {K : Type u} {L : Type v} [field L] {ζ : L} [field K] [algebra K L] (hζ : is_primitive_root ζ 2) : ⇑(algebra.norm K) ζ = (-1) ^ finite_dimensional.finrank K L
theorem is_add_torsion_of_fintype {G : Type u_1} [add_group G] [fintype G] : add_monoid.is_torsion G
theorem metric.bounded.closure {α : Type u} [pseudo_metric_space α] {s : set α} (h : metric.bounded s) : metric.bounded (closure s)
theorem measure_theory.lintegral_prod_of_measurable {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] (f : α × β → ennreal) (hf : measurable f) : ∫⁻ (z : α × β), f z ∂μ.prod ν = ∫⁻ (x : α), ∫⁻ (y : β), f (x, y) ∂ν ∂μ
theorem complete_lattice.independent_iff_forall_dfinsupp {ι : Type u_1} {R : Type u_2} {N : Type u_5} [dec_ι : decidable_eq ι] [semiring R] [add_comm_monoid N] [module R N] (p : ι → submodule R N) : complete_lattice.independent p ↔ ∀ (i : ι) (x : ↥(p i)) (v : Π₀ (i : ι), ↥(p i)), ⇑(⇑(dfinsupp.lsum ℕ) (λ (i : ι), (p i).subtype)) (dfinsupp.erase i v) = ↑x → x = 0
theorem continuous_on.exists_forall_ge' {α : Type u_1} {β : Type u_2} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [topological_space β] {s : set β} {f : β → α} (hf : continuous_on f s) (hsc : is_closed s) {x₀ : β} (h₀ : x₀ ∈ s) (hc : ∀ᶠ (x : β) in filter.cocompact β ⊓ filter.principal s, f x ≤ f x₀) : ∃ (x : β) (H : x ∈ s), ∀ (y : β), y ∈ s → f y ≤ f x
theorem list.length_of_fn {α : Type u} {n : ℕ} (f : fin n → α) : (list.of_fn f).length = n
theorem measure_theory.integral2_divergence_prod_of_has_fderiv_within_at_off_countable {E : Type u} [normed_group E] [normed_space ℝ E] [complete_space E] (f g : ℝ × ℝ → E) (f' g' : ℝ × ℝ → (ℝ × ℝ →L[ℝ] E)) (a₁ a₂ b₁ b₂ : ℝ) (s : set (ℝ × ℝ)) (hs : s.countable) (Hcf : continuous_on f (set.interval a₁ b₁ ×ˢ set.interval a₂ b₂)) (Hcg : continuous_on g (set.interval a₁ b₁ ×ˢ set.interval a₂ b₂)) (Hdf : ∀ (x : ℝ × ℝ), x ∈ set.Ioo (linear_order.min a₁ b₁) (linear_order.max a₁ b₁) ×ˢ set.Ioo (linear_order.min a₂ b₂) (linear_order.max a₂ b₂)  s → has_fderiv_at f (f' x) x) (Hdg : ∀ (x : ℝ × ℝ), x ∈ set.Ioo (linear_order.min a₁ b₁) (linear_order.max a₁ b₁) ×ˢ set.Ioo (linear_order.min a₂ b₂) (linear_order.max a₂ b₂)  s → has_fderiv_at g (g' x) x) (Hi : measure_theory.integrable_on (λ (x : ℝ × ℝ), ⇑(f' x) (1, 0) + ⇑(g' x) (0, 1)) (set.interval a₁ b₁ ×ˢ set.interval a₂ b₂) measure_theory.measure_space.volume) : ∫ (x : ℝ) in a₁..b₁, ∫ (y : ℝ) in a₂..b₂, ⇑(f' (x, y)) (1, 0) + ⇑(g' (x, y)) (0, 1) = (((∫ (x : ℝ) in a₁..b₁, g (x, b₂)) - ∫ (x : ℝ) in a₁..b₁, g (x, a₂)) + ∫ (y : ℝ) in a₂..b₂, f (b₁, y)) - ∫ (y : ℝ) in a₂..b₂, f (a₁, y)
theorem closure_operator.mem_mk₃_closed {α : Type u_1} [partial_order α] {f : α → α} {p : α → Prop} {hf : ∀ (x : α), x ≤ f x} {hfp : ∀ (x : α), p (f x)} {hmin : ∀ ⦃x y : α⦄, x ≤ y → p y → f x ≤ y} {x : α} (hx : p x) : x ∈ (closure_operator.mk₃ f p hf hfp hmin).closed
theorem category_theory.is_pushout.of_right {C : Type u₁} [category_theory.category C] {X₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₁₂ : X₁₂ ⟶ X₁₃} {h₂₁ : X₂₁ ⟶ X₂₂} {h₂₂ : X₂₂ ⟶ X₂₃} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₁₃ : X₁₃ ⟶ X₂₃} (s : category_theory.is_pushout (h₁₁ ≫ h₁₂) v₁₁ v₁₃ (h₂₁ ≫ h₂₂)) (p : h₁₂ ≫ v₁₃ = v₁₂ ≫ h₂₂) (t : category_theory.is_pushout h₁₁ v₁₁ v₁₂ h₂₁) : category_theory.is_pushout h₁₂ v₁₂ v₁₃ h₂₂
theorem continuous_linear_map.adjoint_comp {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [inner_product_space 𝕜 F] [inner_product_space 𝕜 G] [complete_space E] [complete_space G] [complete_space F] (A : F →L[𝕜] G) (B : E →L[𝕜] F) : ⇑continuous_linear_map.adjoint (A.comp B) = (⇑continuous_linear_map.adjoint B).comp (⇑continuous_linear_map.adjoint A)
theorem category_theory.is_cofiltered.cone_nonempty {C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] {J : Type v} [category_theory.small_category J] [category_theory.fin_category J] (F : J ⥤ C) : nonempty (category_theory.limits.cone F)
theorem finset.induction_on {α : Type u_1} {p : finset α → Prop} [decidable_eq α] (s : finset α) (h₁ : p ∅) (h₂ : ∀ ⦃a : α⦄ {s : finset α}, a ∉ s → p s → p (has_insert.insert a s)) : p s
theorem real.Gamma_integral_convergent {s : ℝ} (h : 0 < s) : measure_theory.integrable_on (λ (x : ℝ), real.exp (-x) * x ^ (s - 1)) (set.Ioi 0) measure_theory.measure_space.volume
theorem convex.norm_image_sub_le_of_norm_fderiv_within_le {E : Type u_1} [normed_group E] [normed_space ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_space 𝕜 E] [normed_group G] [normed_space 𝕜 G] {f : E → G} {C : ℝ} {s : set E} {x y : E} (hf : differentiable_on 𝕜 f s) (bound : ∀ (x : E), x ∈ s → ∥fderiv_within 𝕜 f s x∥ ≤ C) (hs : convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∥f y - f x∥ ≤ C * ∥y - x∥
theorem even.neg {α : Type u_2} [subtraction_monoid α] {a : α} : even a → even (-a)
theorem algebra.mul_smul_comm {R : Type u} {A : Type w} [comm_semiring R] [semiring A] [algebra R A] (s : R) (x y : A) : x * s • y = s • (x * y)
theorem category_theory.category_of_elements.costructured_arrow_yoneda_equivalence_naturality {C : Type u} [category_theory.category C] {F₁ F₂ : Cᵒᵖ ⥤ Type v} (α : F₁ ⟶ F₂) : (category_theory.category_of_elements.map α).op ⋙ category_theory.category_of_elements.to_costructured_arrow F₂ = category_theory.category_of_elements.to_costructured_arrow F₁ ⋙ category_theory.costructured_arrow.map α
theorem free_group.reduce.idem {α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.reduce (free_group.reduce L) = free_group.reduce L
theorem polynomial.nat_degree_mul_C_eq_of_mul_ne_zero {R : Type u} {a : R} [semiring R] {p : polynomial R} (h : p.leading_coeff * a ≠ 0) : (p * ⇑polynomial.C a).nat_degree = p.nat_degree
theorem isometry.ediam_image {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} (hf : isometry f) (s : set α) : emetric.diam (f '' s) = emetric.diam s
theorem category_theory.has_limits_of_shape_of_reflective {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {J : Type u} [category_theory.category J] [category_theory.limits.has_limits_of_shape J C] (R : D ⥤ C) [category_theory.reflective R] : category_theory.limits.has_limits_of_shape J D
theorem ideal.quotient_mk_maps_eq {R : Type u_1} [comm_ring R] (P : ideal (polynomial R)) : ((ideal.quotient.mk (ideal.map (polynomial.map_ring_hom (ideal.quotient.mk (ideal.comap polynomial.C P))) P)).comp polynomial.C).comp (ideal.quotient.mk (ideal.comap polynomial.C P)) = ((ideal.map (polynomial.map_ring_hom (ideal.quotient.mk (ideal.comap polynomial.C P))) P).quotient_map (polynomial.map_ring_hom (ideal.quotient.mk (ideal.comap polynomial.C P))) ideal.le_comap_map).comp ((ideal.quotient.mk P).comp polynomial.C)
theorem asymptotics.is_O.norm_norm {α : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_normed_group E'] [semi_normed_group F'] {f' : α → E'} {g' : α → F'} {l : filter α} : f' =O[l] g' → ((λ (x : α), ∥f' x∥) =O[l] λ (x : α), ∥g' x∥)
theorem wcovby.to_dual {α : Type u_1} [preorder α] {a b : α} : a ⩿ b → ⇑order_dual.to_dual b ⩿ ⇑order_dual.to_dual a
theorem continuous_on.tendsto_uniformly {α : Type u_1} {β : Type u_2} {γ : Type u_3} [uniform_space α] [uniform_space β] [locally_compact_space α] [compact_space β] [separated_space β] [uniform_space γ] {f : α → β → γ} {x : α} {U : set α} (hxU : U ∈ nhds x) (hU : is_separated U) (h : continuous_on ↿f (U ×ˢ set.univ)) : tendsto_uniformly f (f x) (nhds x)
theorem has_deriv_at.lhopital_zero_nhds {a : ℝ} {l : filter ℝ} {f f' g g' : ℝ → ℝ} (hff' : ∀ᶠ (x : ℝ) in nhds a, has_deriv_at f (f' x) x) (hgg' : ∀ᶠ (x : ℝ) in nhds a, has_deriv_at g (g' x) x) (hg' : ∀ᶠ (x : ℝ) in nhds a, g' x ≠ 0) (hfa : filter.tendsto f (nhds a) (nhds 0)) (hga : filter.tendsto g (nhds a) (nhds 0)) (hdiv : filter.tendsto (λ (x : ℝ), f' x / g' x) (nhds a) l) : filter.tendsto (λ (x : ℝ), f x / g x) (nhds_within a (set.univ  {a})) l
theorem real.summable_nat_rpow_inv {p : ℝ} : summable (λ (n : ℕ), (↑n ^ p)⁻¹) ↔ 1 < p
theorem pgame.mul_one_equiv (x : pgame) : (x * 1).equiv x
theorem filter.map_map₂_right_comm {α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {f : filter α} {g : filter β} {m : α → β' → γ} {n : β → β'} {m' : α → β → δ} {n' : δ → γ} (h_right_comm : ∀ (a : α) (b : β), m a (n b) = n' (m' a b)) : filter.map₂ m f (filter.map n g) = filter.map n' (filter.map₂ m' f g)
theorem emetric.diam_singleton {α : Type u} [pseudo_emetric_space α] {x : α} : emetric.diam {x} = 0
theorem is_artinian_span_of_finite (R : Type u_1) {M : Type u_2} [ring R] [add_comm_group M] [module R M] [is_artinian_ring R] {A : set M} (hA : A.finite) : is_artinian R ↥(submodule.span R A)
theorem inner_product_geometry.angle_self {V : Type u_1} [inner_product_space ℝ V] {x : V} (hx : x ≠ 0) : inner_product_geometry.angle x x = 0
theorem witt_vector.init_is_poly (p n : ℕ) : witt_vector.is_poly p (λ (R : Type u_1) (_Rcr : comm_ring R), witt_vector.init n)
theorem lie_module.zero_weight_space_eq_top_of_nilpotent' {R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (M : Type w) [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [lie_algebra.is_nilpotent R L] [lie_module.is_nilpotent R L M] : lie_module.weight_space M 0 = ⊤
theorem bounded_continuous_function.tietze_extension_step {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] (f : bounded_continuous_function X ℝ) (e : C(X, Y)) (he : closed_embedding ⇑e) : ∃ (g : bounded_continuous_function Y ℝ), ∥g∥ ≤ ∥f∥ / 3 ∧ has_dist.dist (g.comp_continuous e) f ≤ 2 / 3 * ∥f∥
theorem category_theory.limits.prod.symmetry {C : Type u} [category_theory.category C] (P Q : C) [category_theory.limits.has_binary_product P Q] [category_theory.limits.has_binary_product Q P] : (category_theory.limits.prod.braiding P Q).hom ≫ (category_theory.limits.prod.braiding Q P).hom = 𝟙 (P ⨯ Q)
theorem relation.rprod_le_trans_gen_game_add {α : Type u_1} {β : Type u_2} (rα : α → α → Prop) (rβ : β → β → Prop) : prod.rprod rα rβ ≤ relation.trans_gen (relation.game_add rα rβ)
theorem filter.tendsto_neg_cobounded {E : Type u_3} [semi_normed_group E] : filter.tendsto has_neg.neg (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)
theorem field.nonempty_iff {α : Type u} : nonempty (field α) ↔ is_prime_pow (cardinal.mk α)
theorem pgame.mul_zero_equiv (x : pgame) : (x * 0).equiv 0
theorem finsupp.comap_smul_apply {α : Type u_1} {M : Type u_5} {G : Type u_9} [group G] [mul_action G α] [add_comm_monoid M] (g : G) (f : α →₀ M) (a : α) : ⇑(g • f) a = ⇑f (g⁻¹ • a)
theorem ae_strongly_measurable_iff_ae_measurable {α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [topological_space β] {f : α → β} [measurable_space β] [topological_space.pseudo_metrizable_space β] [borel_space β] [topological_space.second_countable_topology β] : measure_theory.ae_strongly_measurable f μ ↔ ae_measurable f μ
theorem eventually_residual_liouville  : ∀ᶠ (x : ℝ) in residual ℝ, liouville x
theorem add_commute.add_left {S : Type u_1} [add_semigroup S] {a b c : S} (hac : add_commute a c) (hbc : add_commute b c) : add_commute (a + b) c
theorem orthogonal_family.linear_isometry_equiv_symm_apply_dfinsupp_sum_single {ι : Type u_1} {𝕜 : Type u_2} [is_R_or_C 𝕜] {E : Type u_3} [inner_product_space 𝕜 E] [cplt : complete_space E] {G : ι → Type u_4} [Π (i : ι), inner_product_space 𝕜 (G i)] {V : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : orthogonal_family 𝕜 V) [∀ (i : ι), complete_space (G i)] (hV' : (⨆ (i : ι), (V i).to_linear_map.range).topological_closure = ⊤) (W₀ : Π₀ (i : ι), G i) : ⇑((hV.linear_isometry_equiv hV').symm) (W₀.sum (lp.single 2)) = W₀.sum (λ (i : ι), ⇑(V i))
theorem quotient.induction_on₂' {α : Sort u_1} {β : Sort u_2} {s₁ : setoid α} {s₂ : setoid β} {p : quotient s₁ → quotient s₂ → Prop} (q₁ : quotient s₁) (q₂ : quotient s₂) (h : ∀ (a₁ : α) (a₂ : β), p (quotient.mk' a₁) (quotient.mk' a₂)) : p q₁ q₂
theorem normed_space.eq_iff_forall_dual_eq (𝕜 : Type v) [is_R_or_C 𝕜] {E : Type u} [normed_group E] [normed_space 𝕜 E] {x y : E} : x = y ↔ ∀ (g : normed_space.dual 𝕜 E), ⇑g x = ⇑g y
theorem mem_orthogonal_singleton_of_inner_left {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (u : E) {v : E} (hv : has_inner.inner v u = 0) : v ∈ (submodule.span 𝕜 {u})ᗮ
theorem complex.has_strict_deriv_at_cos (x : ℂ) : has_strict_deriv_at complex.cos (-complex.sin x) x
theorem tendsto_div_of_monotone_of_tendsto_div_floor_pow (u : ℕ → ℝ) (l : ℝ) (hmono : monotone u) (c : ℕ → ℝ) (cone : ∀ (k : ℕ), 1 < c k) (clim : filter.tendsto c filter.at_top (nhds 1)) (hc : ∀ (k : ℕ), filter.tendsto (λ (n : ℕ), u ⌊c k ^ n⌋₊ / ↑⌊c k ^ n⌋₊) filter.at_top (nhds l)) : filter.tendsto (λ (n : ℕ), u n / ↑n) filter.at_top (nhds l)
theorem normed_group.core.to_semi_normed_group.core {E : Type u_1} [add_comm_group E] [has_norm E] (C : normed_group.core E) : semi_normed_group.core E
theorem real.young_inequality (a b : ℝ) {p q : ℝ} (hpq : p.is_conjugate_exponent q) : a * b ≤ |a| ^ p / p + |b| ^ q / q
theorem ball_pi' {β : Type v} {π : β → Type u_1} [fintype β] [Π (b : β), pseudo_metric_space (π b)] [nonempty β] (x : Π (b : β), π b) (r : ℝ) : metric.ball x r = set.univ.pi (λ (b : β), metric.ball (x b) r)
theorem measure_theory.jordan_decomposition.exists_compl_positive_negative {α : Type u_1} [measurable_space α] (j : measure_theory.jordan_decomposition α) : ∃ (S : set α), measurable_set S ∧ measure_theory.vector_measure.restrict j.to_signed_measure S ≤ 0.restrict S ∧ 0.restrict Sᶜ ≤ measure_theory.vector_measure.restrict j.to_signed_measure Sᶜ ∧ ⇑(j.pos_part) S = 0 ∧ ⇑(j.neg_part) Sᶜ = 0
theorem tendsto_uniformly_on.continuous_on {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {s : set α} {p : filter ι} [topological_space α] (h : tendsto_uniformly_on F f p s) (hc : ∀ᶠ (n : ι) in p, continuous_on (F n) s) [p.ne_bot] : continuous_on f s
theorem ring_equiv.to_non_unital_ring_hom_commutes {R : Type u_4} {S : Type u_5} [non_assoc_semiring R] [non_assoc_semiring S] (f : R ≃+* S) : ↑↑f = ↑f
theorem simplex_category.epi_iff_surjective {n m : simplex_category} {f : n ⟶ m} : category_theory.epi f ↔ function.surjective ⇑(simplex_category.hom.to_order_hom f)
theorem even.exists_bit0 {α : Type u_2} [has_add α] {a : α} : even a → (∃ (b : α), a = bit0 b)
theorem vsub_vadd_eq_vsub_sub {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p1 p2 : P) (g : G) : p1 -ᵥ (g +ᵥ p2) = p1 -ᵥ p2 - g
theorem emetric.Hausdorff_edist_triangle {α : Type u} [pseudo_emetric_space α] {s t u : set α} : emetric.Hausdorff_edist s u ≤ emetric.Hausdorff_edist s t + emetric.Hausdorff_edist t u
theorem cauchy_seq_of_le_geometric {α : Type u_1} [pseudo_metric_space α] (r C : ℝ) (hr : r < 1) {f : ℕ → α} (hu : ∀ (n : ℕ), has_dist.dist (f n) (f (n + 1)) ≤ C * r ^ n) : cauchy_seq f
theorem topological_fiber_bundle_core.continuous_proj {ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : continuous Z.proj
theorem convex.lipschitz_on_with_of_nnnorm_deriv_le {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_group G] [normed_space 𝕜 G] {f : 𝕜 → G} {s : set 𝕜} {C : nnreal} (hf : ∀ (x : 𝕜), x ∈ s → differentiable_at 𝕜 f x) (bound : ∀ (x : 𝕜), x ∈ s → ∥deriv f x∥₊ ≤ C) (hs : convex ℝ s) : lipschitz_on_with C f s
theorem is_torsion.subgroup {G : Type u_1} [group G] (tG : monoid.is_torsion G) (H : subgroup G) : monoid.is_torsion ↥H
theorem nat.pow_factorization_choose_le {p n k : ℕ} (hn : 0 < n) : p ^ ⇑((n.choose k).factorization) p ≤ n
theorem category_theory.ProjectiveResolution.lift_f_one_zero_comm {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] {Y Z : C} (f : Y ⟶ Z) (P : category_theory.ProjectiveResolution Y) (Q : category_theory.ProjectiveResolution Z) : category_theory.ProjectiveResolution.lift_f_one f P Q ≫ Q.complex.d 1 0 = P.complex.d 1 0 ≫ category_theory.ProjectiveResolution.lift_f_zero f P Q
theorem matrix.pivot.mul_list_transvec_row_last_col_take {𝕜 : Type u_3} [field 𝕜] {r : ℕ} (M : matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜) (i : fin r ⊕ unit) {k : ℕ} (hk : k ≤ r) : M.mul (list.take k (matrix.pivot.list_transvec_row M)).prod i (sum.inr ()) = M i (sum.inr ())
theorem monotone_on.map_bdd_above {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s t : set α} (Hf : monotone_on f t) (Hst : s ⊆ t) : (upper_bounds s ∩ t).nonempty → bdd_above (f '' s)
theorem submodule.linear_map_qext {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (p : submodule R M) {R₂ : Type u_3} {M₂ : Type u_4} [ring R₂] [add_comm_group M₂] [module R₂ M₂] {τ₁₂ : R →+* R₂} ⦃f g : M ⧸ p →ₛₗ[τ₁₂] M₂⦄ (h : f.comp p.mkq = g.comp p.mkq) : f = g
theorem measure_theory.measure.absolutely_continuous.ae_le {α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} : μ.absolutely_continuous ν → μ.ae ≤ ν.ae
theorem interval_integral.integral_sub_integral_sub_linear_is_o_of_tendsto_ae_left {ι : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {c : E} {la la' : filter ℝ} {lt : filter ι} {a b : ℝ} {u v : ι → ℝ} [interval_integral.FTC_filter a la la'] (hab : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f la' measure_theory.measure_space.volume) (hf : filter.tendsto f (la' ⊓ measure_theory.measure_space.volume.ae) (nhds c)) (hu : filter.tendsto u lt la) (hv : filter.tendsto v lt la) : (λ (t : ι), ((∫ (x : ℝ) in v t..b, f x) - ∫ (x : ℝ) in u t..b, f x) + (v t - u t) • c) =o[lt] (v - u)
theorem ennreal.cancel_coe {a : nnreal} : add_le_cancellable ↑a
theorem has_ssubset.ssubset.ne' {α : Type u} [has_ssubset α] [is_irrefl α has_ssubset.ssubset] {a b : α} : a ⊂ b → b ≠ a
theorem orthogonal_projection_orthogonal_complement_singleton_eq_zero {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [complete_space E] (v : E) : ⇑(orthogonal_projection (submodule.span 𝕜 {v})ᗮ) v = 0
theorem dioph.pow_dioph {α : Type} {f g : (α → ℕ) → ℕ} (df : dioph.dioph_fn f) (dg : dioph.dioph_fn g) : dioph.dioph_fn (λ (v : α → ℕ), f v ^ g v)
theorem lie_algebra.subsingleton_of_semisimple_lie_abelian (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_algebra.is_semisimple R L] [h : is_lie_abelian L] : subsingleton L
theorem add_subgroup.fg_iff_add_submonoid.fg {G : Type u_3} [add_group G] (P : add_subgroup G) : P.fg ↔ P.to_add_submonoid.fg
theorem triple_product_permutation {R : Type u_1} [comm_ring R] (u v w : fin 3 → R) : matrix.dot_product u (⇑(⇑cross_product v) w) = matrix.dot_product v (⇑(⇑cross_product w) u)
theorem category_theory.solution_set_condition_of_is_right_adjoint {C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (G : D ⥤ C) [category_theory.is_right_adjoint G] : category_theory.solution_set_condition G
theorem add_pow {R : Type u_1} [comm_semiring R] (x y : R) (n : ℕ) : (x + y) ^ n = (finset.range (n + 1)).sum (λ (m : ℕ), x ^ m * y ^ (n - m) * ↑(n.choose m))
theorem reflection_mem_subspace_orthogonal_complement_eq_neg {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K : submodule 𝕜 E} [complete_space ↥K] {v : E} (hv : v ∈ Kᗮ) : ⇑(reflection K) v = -v
theorem nat.lt_base_pow_length_digits' {b m : ℕ} : m < (b + 2) ^ ((b + 2).digits m).length
theorem convolution_lmul_swap {𝕜 : Type u_1} {G : Type u_2} {x : G} [nondiscrete_normed_field 𝕜] [measurable_space G] {μ : measure_theory.measure G} [add_comm_group G] [topological_space G] [topological_add_group G] [borel_space G] [μ.is_add_left_invariant] [μ.is_neg_invariant] [normed_space ℝ 𝕜] [complete_space 𝕜] {f g : G → 𝕜} : convolution f g (continuous_linear_map.lmul 𝕜 𝕜) μ x = ∫ (t : G), f (x - t) * g t ∂μ
theorem setoid.empty_not_mem_classes {α : Type u_1} {r : setoid α} : ∅ ∉ r.classes
theorem is_torsion.quotient_iff {G : Type u_1} {H : Type u_2} [group G] {N : subgroup G} [group H] {f : G →* H} (hf : function.surjective ⇑f) (hN : N = f.ker) (tN : monoid.is_torsion ↥N) : monoid.is_torsion H ↔ monoid.is_torsion G
theorem convex.norm_image_sub_le_of_norm_fderiv_within_le' {E : Type u_1} [normed_group E] [normed_space ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_space 𝕜 E] [normed_group G] [normed_space 𝕜 G] {f : E → G} {C : ℝ} {s : set E} {x y : E} {φ : E →L[𝕜] G} (hf : differentiable_on 𝕜 f s) (bound : ∀ (x : E), x ∈ s → ∥fderiv_within 𝕜 f s x - φ∥ ≤ C) (hs : convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∥f y - f x - ⇑φ (y - x)∥ ≤ C * ∥y - x∥
theorem padic_val_nat.self {p : ℕ} (hp : 1 < p) : padic_val_nat p p = 1
theorem asymptotics.is_O_iff {α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : α → E} {g : α → F} {l : filter α} : f =O[l] g ↔ ∃ (c : ℝ), ∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g x∥
theorem nat.factorization_choose_le_log {p n k : ℕ} : ⇑((n.choose k).factorization) p ≤ nat.log p n
theorem is_right_regular.subsingleton {R : Type u_1} [mul_zero_class R] (h : is_right_regular 0) : subsingleton R
theorem multiset.nodup.powerset {α : Type u_1} {s : multiset α} : s.nodup → s.powerset.nodup
theorem ring_hom.map_finsupp_prod {α : Type u_1} {M : Type u_5} {R : Type u_11} {S : Type u_12} [has_zero M] [comm_semiring R] [comm_semiring S] (h : R →+* S) (f : α →₀ M) (g : α → M → R) : ⇑h (f.prod g) = f.prod (λ (a : α) (b : M), ⇑h (g a b))
theorem map_inv {G : Type u_6} {H : Type u_7} {F : Type u_8} [group G] [division_monoid H] [monoid_hom_class F G H] (f : F) (a : G) : ⇑f a⁻¹ = (⇑f a)⁻¹
theorem finset.prod_sum {α : Type u} {β : Type v} [comm_semiring β] {δ : α → Type u_1} [decidable_eq α] [Π (a : α), decidable_eq (δ a)] {s : finset α} {t : Π (a : α), finset (δ a)} {f : Π (a : α), δ a → β} : s.prod (λ (a : α), (t a).sum (λ (b : δ a), f a b)) = (s.pi t).sum (λ (p : Π (a : α), a ∈ s → δ a), s.attach.prod (λ (x : {x // x ∈ s}), f x.val (p x.val _)))
theorem linear_map.trace_conj (R : Type u) [comm_semiring R] {M : Type v} [add_comm_monoid M] [module R M] (g : M →ₗ[R] M) (f : (M →ₗ[R] M)ˣ) : ⇑(linear_map.trace R M) (↑f * g * ↑f⁻¹) = ⇑(linear_map.trace R M) g
theorem category_theory.is_equivalence.of_iso_trans {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {F G H : C ⥤ D} (e : F ≅ G) (e' : G ≅ H) (hF : category_theory.is_equivalence F) : category_theory.is_equivalence.of_iso e' (category_theory.is_equivalence.of_iso e hF) = category_theory.is_equivalence.of_iso (e ≪≫ e') hF
theorem category_theory.limits.types.jointly_surjective' {J : Type v} [category_theory.small_category J] {F : J ⥤ Type (max v u)} (x : category_theory.limits.colimit F) : ∃ (j : J) (y : F.obj j), category_theory.limits.colimit.ι F j y = x
theorem Mon.filtered_colimits.colimit_mul_aux_eq_of_rel_left {J : Type v} [category_theory.small_category J] (F : J ⥤ Mon) [category_theory.is_filtered J] {x x' y : Σ (j : J), ↥(F.obj j)} (hxx' : category_theory.limits.types.filtered_colimit.rel (F ⋙ category_theory.forget Mon) x x') : Mon.filtered_colimits.colimit_mul_aux F x y = Mon.filtered_colimits.colimit_mul_aux F x' y
theorem max_zero_sub_eq_self {α : Type u} [add_group α] [linear_order α] [covariant_class α α has_add.add has_le.le] (a : α) : linear_order.max a 0 - linear_order.max (-a) 0 = a
theorem nat.factorization_mul_of_coprime {a b : ℕ} (hab : a.coprime b) : (a * b).factorization = a.factorization + b.factorization
theorem vitali_family.measure_lim_ratio_meas_zero {α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {ρ : measure_theory.measure α} [measure_theory.is_locally_finite_measure ρ] (hρ : ρ.absolutely_continuous μ) : ⇑ρ {x : α | v.lim_ratio_meas hρ x = 0} = 0
theorem finset.centroid_def (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} (s : finset ι) (p : ι → P) : finset.centroid k s p = ⇑(s.affine_combination p) (finset.centroid_weights k s)
theorem basis.orientation_units_smul {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {ι : Type u_4} [fintype ι] [decidable_eq ι] [nontrivial R] (e : basis ι R M) (w : ι → Rˣ) : (e.units_smul w).orientation = (finset.univ.prod (λ (i : ι), w i))⁻¹ • e.orientation
theorem polynomial.roots_of_cyclotomic (n : ℕ) (R : Type u_1) [comm_ring R] [is_domain R] : (polynomial.cyclotomic' n R).roots = (primitive_roots n R).val
theorem add_monoid_algebra.grade_by.is_internal {M : Type u_1} {ι : Type u_2} {R : Type u_3} [decidable_eq M] [add_monoid M] [decidable_eq ι] [add_monoid ι] [comm_semiring R] (f : M →+ ι) : direct_sum.is_internal (add_monoid_algebra.grade_by R ⇑f)
theorem Gromov_Hausdorff.GH_dist_le_of_approx_subsets {X : Type u} [metric_space X] [compact_space X] [nonempty X] {Y : Type v} [metric_space Y] [compact_space Y] [nonempty Y] {s : set X} (Φ : ↥s → Y) {ε₁ ε₂ ε₃ : ℝ} (hs : ∀ (x : X), ∃ (y : X) (H : y ∈ s), has_dist.dist x y ≤ ε₁) (hs' : ∀ (x : Y), ∃ (y : ↥s), has_dist.dist x (Φ y) ≤ ε₃) (H : ∀ (x y : ↥s), |has_dist.dist x y - has_dist.dist (Φ x) (Φ y)| ≤ ε₂) : Gromov_Hausdorff.GH_dist X Y ≤ ε₁ + ε₂ / 2 + ε₃
theorem antitone.dual_right {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} : antitone f → monotone (⇑order_dual.to_dual ∘ f)
theorem mul_right_continuous {α : Type u_1} [topological_space α] [non_unital_non_assoc_ring α] [topological_ring α] (x : α) : continuous ⇑(add_monoid_hom.mul_right x)
theorem set.finite.bdd_above_bUnion {α : Type u} {β : Type v} [semilattice_sup α] [nonempty α] {I : set β} {S : β → set α} (H : I.finite) : bdd_above (⋃ (i : β) (H : i ∈ I), S i) ↔ ∀ (i : β), i ∈ I → bdd_above (S i)
theorem approximates_linear_on.inverse_continuous_on {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {f' : E ≃L[𝕜] F} {s : set E} {c : nnreal} (hf : approximates_linear_on f ↑f' s c) (hc : subsingleton E ∨ c < ∥↑(f'.symm)∥₊⁻¹) : continuous_on ⇑((hf.to_local_equiv hc).symm) (f '' s)
theorem phragmen_lindelof.eq_zero_on_quadrant_I {E : Type u_1} [normed_group E] [normed_space ℂ E] {f : ℂ → E} (hd : diff_cont_on_cl ℂ f (set.Ioi 0 ×ℂ set.Ioi 0)) (hB : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ filter.principal (set.Ioi 0 ×ℂ set.Ioi 0)] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hre : ∀ (x : ℝ), 0 ≤ x → f ↑x = 0) (him : ∀ (x : ℝ), 0 ≤ x → f (↑x * complex.I) = 0) : set.eq_on f 0 {z : ℂ | 0 ≤ z.re ∧ 0 ≤ z.im}
theorem category_theory.is_pushout.zero_right {C : Type u₁} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] (X : C) : category_theory.is_pushout 0 (𝟙 X) 0 0
theorem convex.taylor_approx_two_segment {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {s : set E} (s_conv : convex ℝ s) {f : E → F} {f' : E → (E →L[ℝ] F)} {f'' : E →L[ℝ] E →L[ℝ] F} (hf : ∀ (x : E), x ∈ interior s → has_fderiv_at f (f' x) x) {x : E} (xs : x ∈ s) (hx : has_fderiv_within_at f' f'' (interior s) x) {v w : E} (hv : x + v ∈ interior s) (hw : x + v + w ∈ interior s) : (λ (h : ℝ), f (x + h • v + h • w) - f (x + h • v) - h • ⇑(f' x) w - h ^ 2 • ⇑(⇑f'' v) w - (h ^ 2 / 2) • ⇑(⇑f'' w) w) =o[nhds_within 0 (set.Ioi 0)] λ (h : ℝ), h ^ 2
theorem charted_space_self_atlas {H : Type u_1} [topological_space H] {e : local_homeomorph H H} : e ∈ charted_space.atlas H H ↔ e = local_homeomorph.refl H
theorem convex_hull_eq_union_convex_hull_finite_subsets {R : Type u_1} {E : Type u_2} [linear_ordered_field R] [add_comm_group E] [module R E] (s : set E) : ⇑(convex_hull R) s = ⋃ (t : finset E) (w : ↑t ⊆ s), ⇑(convex_hull R) ↑t
theorem category_theory.abelian.is_iso_of_is_iso_of_is_iso_of_is_iso_of_is_iso {V : Type u} [category_theory.category V] [category_theory.abelian V] {A B C D A' B' C' D' : V} {f : A ⟶ B} {g : B ⟶ C} {h : C ⟶ D} {f' : A' ⟶ B'} {g' : B' ⟶ C'} {h' : C' ⟶ D'} {α : A ⟶ A'} {β : B ⟶ B'} {γ : C ⟶ C'} {δ : D ⟶ D'} (comm₁ : α ≫ f' = f ≫ β) (comm₂ : β ≫ g' = g ≫ γ) (comm₃ : γ ≫ h' = h ≫ δ) {E E' : V} {i : D ⟶ E} {i' : D' ⟶ E'} {ε : E ⟶ E'} (comm₄ : δ ≫ i' = i ≫ ε) (hfg : category_theory.exact f g) (hgh : category_theory.exact g h) (hhi : category_theory.exact h i) (hf'g' : category_theory.exact f' g') (hg'h' : category_theory.exact g' h') (hh'i' : category_theory.exact h' i') [category_theory.is_iso α] [category_theory.is_iso β] [category_theory.is_iso δ] [category_theory.is_iso ε] : category_theory.is_iso γ
theorem category_theory.limits.has_finite_wide_pullbacks_of_has_finite_limits (C : Type u) [category_theory.category C] [category_theory.limits.has_finite_limits C] : category_theory.limits.has_finite_wide_pullbacks C
theorem measure_theory.tendsto_Lp_of_tendsto_ae {α : Type u_1} {β : Type u_2} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} [measure_theory.is_finite_measure μ] (hp : 1 ≤ p) (hp' : p ≠ ⊤) {f : ℕ → α → β} {g : α → β} (hf : ∀ (n : ℕ), measure_theory.ae_strongly_measurable (f n) μ) (hg : measure_theory.mem_ℒp g p μ) (hui : measure_theory.unif_integrable f p μ) (hfg : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (nhds (g x))) : filter.tendsto (λ (n : ℕ), measure_theory.snorm (f n - g) p μ) filter.at_top (nhds 0)
theorem finset.nat.mem_antidiagonal {n : ℕ} {x : ℕ × ℕ} : x ∈ finset.nat.antidiagonal n ↔ x.fst + x.snd = n
theorem witt_vector.lift_unique {p : ℕ} [hp : fact (nat.prime p)] {R : Type u_1} [comm_ring R] {S : Type u_2} [semiring S] {f : Π (k : ℕ), S →+* truncated_witt_vector p k R} (f_compat : ∀ (k₁ k₂ : ℕ) (hk : k₁ ≤ k₂), (truncated_witt_vector.truncate hk).comp (f k₂) = f k₁) (g : S →+* witt_vector p R) (g_compat : ∀ (k : ℕ), (witt_vector.truncate k).comp g = f k) : witt_vector.lift (λ (k₂ : ℕ), f k₂) f_compat = g
theorem interval_integral.integral_comp_smul_deriv {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {a b : ℝ} {f f' : ℝ → ℝ} {g : ℝ → E} (h : ∀ (x : ℝ), x ∈ set.interval a b → has_deriv_at f (f' x) x) (h' : continuous_on f' (set.interval a b)) (hg : continuous g) : ∫ (x : ℝ) in a..b, f' x • (g ∘ f) x = ∫ (x : ℝ) in f a..f b, g x
theorem ordered_smul.mk' {k : Type u_1} {M : Type u_2} [linear_ordered_field k] [ordered_add_comm_monoid M] [mul_action_with_zero k M] (hlt : ∀ ⦃a b : M⦄ ⦃c : k⦄, a < b → 0 < c → c • a ≤ c • b) : ordered_smul k M
theorem continuous_on.measurable_embedding {γ : Type u_3} [tγ : topological_space γ] [polish_space γ] [measurable_space γ] [borel_space γ] {β : Type u_4} [tβ : topological_space β] [t2_space β] [measurable_space β] [borel_space β] {s : set γ} {f : γ → β} (hs : measurable_set s) (f_cont : continuous_on f s) (f_inj : set.inj_on f s) : measurable_embedding (s.restrict f)
theorem liouville.exists_one_le_pow_mul_dist {Z : Type u_1} {N : Type u_2} {R : Type u_3} [pseudo_metric_space R] {d : N → ℝ} {j : Z → N → R} {f : R → R} {α : R} {ε M : ℝ} (d0 : ∀ (a : N), 1 ≤ d a) (e0 : 0 < ε) (B : ∀ ⦃y : R⦄, y ∈ metric.closed_ball α ε → has_dist.dist (f α) (f y) ≤ has_dist.dist α y * M) (L : ∀ ⦃z : Z⦄ ⦃a : N⦄, j z a ∈ metric.closed_ball α ε → 1 ≤ d a * has_dist.dist (f α) (f (j z a))) : ∃ (A : ℝ), 0 < A ∧ ∀ (z : Z) (a : N), 1 ≤ d a * (has_dist.dist α (j z a) * A)
theorem polynomial.nat_degree_multiset_prod' {R : Type u} [comm_semiring R] (t : multiset (polynomial R)) (h : (multiset.map (λ (f : polynomial R), f.leading_coeff) t).prod ≠ 0) : t.prod.nat_degree = (multiset.map (λ (f : polynomial R), f.nat_degree) t).sum
theorem set.exists_is_open_lt_of_lt {α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [μ.outer_regular] (A : set α) (r : ennreal) (hr : ⇑μ A < r) : ∃ (U : set α) (H : U ⊇ A), is_open U ∧ ⇑μ U < r
theorem lie_algebra.nilpotent_of_nilpotent_quotient {R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] {I : lie_ideal R L} (h₁ : I ≤ lie_algebra.center R L) (h₂ : lie_algebra.is_nilpotent R (L ⧸ I)) : lie_algebra.is_nilpotent R L
theorem affine_basis.affine_span_eq_top_of_to_matrix_left_inv {ι : Type u₁} {k : Type u₂} {V : Type u₃} {P : Type u₄} [add_comm_group V] [add_torsor V P] [ring k] [module k V] (b : affine_basis ι k P) {ι' : Type u_1} [fintype ι'] [fintype ι] [decidable_eq ι] [nontrivial k] (p : ι' → P) {A : matrix ι ι' k} (hA : A.mul (b.to_matrix p) = 1) : affine_span k (set.range p) = ⊤
theorem finite_dimensional.of_finite_basis {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type w} {s : set ι} (h : basis ↥s K V) (hs : s.finite) : finite_dimensional K V
theorem cInf_singleton {α : Type u_1} [conditionally_complete_lattice α] (a : α) : has_Inf.Inf {a} = a
theorem witt_vector.peval_poly_of_interest' (p : ℕ) [hp : fact (nat.prime p)] {k : Type u_1} [comm_ring k] [char_p k p] (n : ℕ) (x y : witt_vector p k) : witt_vector.peval (witt_vector.poly_of_interest p n) ![λ (i : ℕ), x.coeff i, λ (i : ℕ), y.coeff i] = (x * y).coeff (n + 1) - y.coeff (n + 1) * x.coeff 0 ^ p ^ (n + 1) - x.coeff (n + 1) * y.coeff 0 ^ p ^ (n + 1)
theorem differentiable_on.analytic_at {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] {s : set ℂ} {f : ℂ → E} {z : ℂ} (hd : differentiable_on ℂ f s) (hz : s ∈ nhds z) : analytic_at ℂ f z
theorem is_compact.finite_compact_cover {α : Type u} [topological_space α] [t2_space α] {s : set α} (hs : is_compact s) {ι : Type u_1} (t : finset ι) (U : ι → set α) (hU : ∀ (i : ι), i ∈ t → is_open (U i)) (hsC : s ⊆ ⋃ (i : ι) (H : i ∈ t), U i) : ∃ (K : ι → set α), (∀ (i : ι), is_compact (K i)) ∧ (∀ (i : ι), K i ⊆ U i) ∧ s = ⋃ (i : ι) (H : i ∈ t), K i
theorem convex_on.le_on_segment {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [linear_ordered_add_comm_monoid β] [has_scalar 𝕜 E] [module 𝕜 β] [ordered_smul 𝕜 β] {s : set E} {f : E → β} (hf : convex_on 𝕜 s f) {x y z : E} (hx : x ∈ s) (hy : y ∈ s) (hz : z ∈ segment 𝕜 x y) : f z ≤ linear_order.max (f x) (f y)
theorem diff_cont_on_cl.circle_integral_sub_inv_smul {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] {R : ℝ} {c w : ℂ} {f : ℂ → E} (h : diff_cont_on_cl ℂ f (metric.ball c R)) (hw : w ∈ metric.ball c R) : ∮ (z : ℂ) in C(c, R), (z - w)⁻¹ • f z = (2 * ↑real.pi * complex.I) • f w
theorem category_theory.abelian.pseudoelement.zero_of_map_zero {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P ⟶ Q) : function.injective ⇑f → ∀ (a : ↥P), ⇑f a = 0 → a = 0
theorem spectrum.zero_eq {𝕜 : Type u} {A : Type v} [field 𝕜] [ring A] [algebra 𝕜 A] [nontrivial A] : spectrum 𝕜 0 = {0}
theorem neg_strict_convex_on_iff {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [ordered_add_comm_group β] [has_scalar 𝕜 E] [module 𝕜 β] {s : set E} {f : E → β} : strict_convex_on 𝕜 s (-f) ↔ strict_concave_on 𝕜 s f
theorem category_theory.limits.cofork.coequalizer_ext {C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} (s : category_theory.limits.cofork f g) {W : C} {k l : s.X ⟶ W} (h : s.π ≫ k = s.π ≫ l) (j : category_theory.limits.walking_parallel_pair) : s.ι.app j ≫ k = s.ι.app j ≫ l
theorem convex.combo_closure_interior_subset_interior {E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) {a b : 𝕜} (ha : 0 ≤ a) (hb : 0 < b) (hab : a + b = 1) : a • closure s + b • interior s ⊆ interior s
theorem euclidean_geometry.reflection_symm {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ℝ P) [nonempty ↥s] [complete_space ↥(s.direction)] : (euclidean_geometry.reflection s).symm = euclidean_geometry.reflection s
theorem bornology.is_vonN_bounded.subset {𝕜 : Type u_1} {E : Type u_2} [semi_normed_ring 𝕜] [has_scalar 𝕜 E] [has_zero E] [topological_space E] {s₁ s₂ : set E} (h : s₁ ⊆ s₂) (hs₂ : bornology.is_vonN_bounded 𝕜 s₂) : bornology.is_vonN_bounded 𝕜 s₁
theorem is_regular_iff_subsingleton {R : Type u_1} [mul_zero_class R] : is_regular 0 ↔ subsingleton R
theorem asymptotics.is_o_iff_forall_is_O_with {α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : α → E} {g : α → F} {l : filter α} : f =o[l] g ↔ ∀ ⦃c : ℝ⦄, 0 < c → asymptotics.is_O_with c l f g
theorem strict_mono_on.continuous_at_left_of_surj_on {α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_on f s) (hs : s ∈ nhds_within a (set.Iic a)) (hfs : set.surj_on f s (set.Iio (f a))) : continuous_within_at f (set.Iic a) a
theorem continuous_map.homotopy.apply_one_path {X Y : Top} {f g : C(↥X, ↥Y)} (H : f.homotopy g) {x₀ x₁ : ↥X} (p : fundamental_groupoid.from_top x₀ ⟶ fundamental_groupoid.from_top x₁) : (fundamental_groupoid.fundamental_groupoid_functor.map g).map p = continuous_map.homotopy.hcast _ ≫ (fundamental_groupoid.fundamental_groupoid_functor.map H.ulift_map).map (continuous_map.homotopy.prod_to_prod_Top_I (𝟙 {down := 1}) p) ≫ continuous_map.homotopy.hcast _
theorem orthonormal.oangle_eq_iff_eq_norm_div_norm_smul_rotation_or_eq_zero {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y : V} (θ : real.angle) : hb.oangle x y = θ ↔ x ≠ 0 ∧ y ≠ 0 ∧ y = (∥y∥ / ∥x∥) • ⇑(hb.rotation θ) x ∨ θ = 0 ∧ (x = 0 ∨ y = 0)
theorem basis.ext_linear_isometry {R : Type u_1} {R₂ : Type u_2} {E : Type u_5} {E₂ : Type u_6} [semiring R] [semiring R₂] {σ₁₂ : R →+* R₂} [semi_normed_group E] [semi_normed_group E₂] [module R E] [module R₂ E₂] {ι : Type u_3} (b : basis ι R E) {f₁ f₂ : E →ₛₗᵢ[σ₁₂] E₂} (h : ∀ (i : ι), ⇑f₁ (⇑b i) = ⇑f₂ (⇑b i)) : f₁ = f₂
theorem mem_tangent_cone_of_open_segment_subset {G : Type u_4} [normed_group G] [normed_space ℝ G] {s : set G} {x y : G} (h : open_segment ℝ x y ⊆ s) : y - x ∈ tangent_cone_at ℝ s x
theorem convolution_assoc {𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {E'' : Type u_5} {F : Type u_6} {F' : Type u_7} {F'' : Type u_8} [normed_group E] [normed_group E'] [normed_group E''] [normed_group F] {f : G → E} {g : G → E'} [is_R_or_C 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 E''] [normed_space ℝ F] [normed_space 𝕜 F] [complete_space F] [measurable_space G] {μ : measure_theory.measure G} (L : E →L[𝕜] E' →L[𝕜] F) [normed_group F'] [normed_space ℝ F'] [normed_space 𝕜 F'] [complete_space F'] [normed_group F''] [normed_space ℝ F''] [normed_space 𝕜 F''] [complete_space F''] {k : G → E''} (L₂ : F →L[𝕜] E'' →L[𝕜] F') (L₃ : E →L[𝕜] F'' →L[𝕜] F') (L₄ : E' →L[𝕜] E'' →L[𝕜] F'') [add_group G] [has_measurable_add G] [measure_theory.sigma_finite μ] {ν : measure_theory.measure G} [measure_theory.sigma_finite ν] [ν.is_add_right_invariant] (hL : ∀ (x : E) (y : E') (z : E''), ⇑(⇑L₂ (⇑(⇑L x) y)) z = ⇑(⇑L₃ x) (⇑(⇑L₄ y) z)) {x₀ : G} (h₄ : convolution_exists g k L₄ ν) (h₁ : convolution_exists f g L μ) (hi : measure_theory.integrable (function.uncurry (λ (x y : G), ⇑(⇑L₃ (f y)) (⇑(⇑L₄ (g (x - y))) (k (x₀ - x))))) (ν.prod μ)) : convolution (convolution f g L μ) k L₂ ν x₀ = convolution f (convolution g k L₄ ν) L₃ μ x₀
theorem category_theory.limits.complete_lattice.pushout_eq_sup {α : Type u} [semilattice_sup α] [order_bot α] (x y z : α) (f : z ⟶ x) (g : z ⟶ y) : category_theory.limits.pushout f g = x ⊔ y
theorem con.con_gen_of_con {M : Type u_1} [has_mul M] (c : con M) : con_gen ⇑c = c
theorem linear_independent.fin_cons {K : Type u_4} {V : Type u} [division_ring K] [add_comm_group V] [module K V] {x : V} {n : ℕ} {v : fin n → V} (hv : linear_independent K v) (hx : x ∉ submodule.span K (set.range v)) : linear_independent K (fin.cons x v)
theorem orthonormal.inner_finsupp_eq_sum_left {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : orthonormal 𝕜 v) (l₁ l₂ : ι →₀ 𝕜) : has_inner.inner (⇑(finsupp.total ι E 𝕜 v) l₁) (⇑(finsupp.total ι E 𝕜 v) l₂) = l₁.sum (λ (i : ι) (y : 𝕜), ⇑(star_ring_end 𝕜) y * ⇑l₂ i)
theorem add_lt_add {α : Type u_1} [has_add α] [preorder α] [covariant_class α α has_add.add has_lt.lt] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c d : α} (h₁ : a < b) (h₂ : c < d) : a + c < b + d
theorem is_cyclotomic_extension.iff_singleton (n : ℕ+) (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] : is_cyclotomic_extension {n} A B ↔ (∃ (r : B), ⇑(polynomial.aeval r) (polynomial.cyclotomic ↑n A) = 0) ∧ ∀ (x : B), x ∈ algebra.adjoin A {b : B | b ^ ↑n = 1}
theorem metric.inf_dist_image {α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {t : set α} {x : α} {Φ : α → β} (hΦ : isometry Φ) : metric.inf_dist (Φ x) (Φ '' t) = metric.inf_dist x t
theorem filter.frequently.mem_closure {α : Type u} [topological_space α] {s : set α} {a : α} : (∃ᶠ (x : α) in nhds a, x ∈ s) → a ∈ closure s
theorem category_theory.limits.has_finite_products_of_has_products (C : Type u) [category_theory.category C] [category_theory.limits.has_products C] : category_theory.limits.has_finite_products C
theorem continuous.image_connected_component_eq_singleton {α : Type u} [topological_space α] {β : Type u_1} [topological_space β] [totally_disconnected_space β] {f : α → β} (h : continuous f) (a : α) : f '' connected_component a = {f a}
theorem holor.slice_eq {α : Type} {d : ℕ} {ds : list ℕ} (x y : holor α (d :: ds)) (h : x.slice = y.slice) : x = y
theorem euclidean_geometry.eq_of_dist_eq_of_dist_eq_of_finrank_eq_two {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] [finite_dimensional ℝ V] (hd : finite_dimensional.finrank ℝ V = 2) {c₁ c₂ p₁ p₂ p : P} {r₁ r₂ : ℝ} (hc : c₁ ≠ c₂) (hp : p₁ ≠ p₂) (hp₁c₁ : has_dist.dist p₁ c₁ = r₁) (hp₂c₁ : has_dist.dist p₂ c₁ = r₁) (hpc₁ : has_dist.dist p c₁ = r₁) (hp₁c₂ : has_dist.dist p₁ c₂ = r₂) (hp₂c₂ : has_dist.dist p₂ c₂ = r₂) (hpc₂ : has_dist.dist p c₂ = r₂) : p = p₁ ∨ p = p₂
theorem riesz_lemma {𝕜 : Type u_1} [normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : subspace 𝕜 E} (hFc : is_closed ↑F) (hF : ∃ (x : E), x ∉ F) {r : ℝ} (hr : r < 1) : ∃ (x₀ : E), x₀ ∉ F ∧ ∀ (y : E), y ∈ F → r * ∥x₀∥ ≤ ∥x₀ - y∥
theorem is_artinian.disjoint_partial_infs_eventually_top {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [I : is_artinian R M] (f : ℕ → submodule R M) (h : ∀ (n : ℕ), disjoint (⇑(partial_sups (⇑order_dual.to_dual ∘ f)) n) (⇑order_dual.to_dual (f (n + 1)))) : ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → f m = ⊤
theorem euclidean_geometry.exists_circumradius_eq_of_cospherical_subset {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} {ps : set P} (h : ps ⊆ ↑s) [nonempty ↥s] {n : ℕ} [finite_dimensional ℝ ↥(s.direction)] (hd : finite_dimensional.finrank ℝ ↥(s.direction) = n) (hc : euclidean_geometry.cospherical ps) : ∃ (r : ℝ), ∀ (sx : affine.simplex ℝ P n), set.range sx.points ⊆ ps → sx.circumradius = r
theorem ordered_comm_group.le_of_mul_le_mul_left {α : Type u_1} [has_mul α] [has_le α] [contravariant_class α α has_mul.mul has_le.le] {a b c : α} (bc : a * b ≤ a * c) : b ≤ c
theorem category_theory.grothendieck_topology.arrow_stable {C : Type u} [category_theory.category C] {X Y : C} (J : category_theory.grothendieck_topology C) (f : Y ⟶ X) (S : category_theory.sieve X) (h : J.covers S f) {Z : C} (g : Z ⟶ Y) : J.covers S (g ≫ f)
theorem finset.sum_congr_set {α : Type u_1} [add_comm_monoid α] {β : Type u_2} [fintype β] (s : set β) [decidable_pred (λ (_x : β), _x ∈ s)] (f : β → α) (g : ↥s → α) (w : ∀ (x : β) (h : x ∈ s), f x = g ⟨x, h⟩) (w' : ∀ (x : β), x ∉ s → f x = 0) : finset.univ.sum f = finset.univ.sum g
theorem charpoly_left_mul_matrix {K : Type u_1} {S : Type u_2} [field K] [comm_ring S] [algebra K S] (h : power_basis K S) : (⇑(algebra.left_mul_matrix h.basis) h.gen).charpoly = minpoly K h.gen
theorem nat.prime_divisors_eq_to_filter_divisors_prime (n : ℕ) : n.factors.to_finset = finset.filter nat.prime n.divisors
theorem tensor_product.span_tmul_eq_top (R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] : submodule.span R {t : tensor_product R M N | ∃ (m : M) (n : N), m ⊗ₜ[R] n = t} = ⊤
theorem metric.diam_empty {α : Type u} [pseudo_metric_space α] : metric.diam ∅ = 0
theorem ring_hom.eq_on_sclosure {R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] {f g : R →+* S} {s : set R} (h : set.eq_on ⇑f ⇑g s) : set.eq_on ⇑f ⇑g ↑(subsemiring.closure s)
theorem dense_range.separable_space {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space.separable_space α] [topological_space β] {f : α → β} (h : dense_range f) (h' : continuous f) : topological_space.separable_space β
theorem zmod.pow_card_sub_one_eq_one {p : ℕ} [fact (nat.prime p)] {a : zmod p} (ha : a ≠ 0) : a ^ (p - 1) = 1
theorem ideal.radical_eq_jacobson_iff_radical_quotient_eq_jacobson_bot {R : Type u} [comm_ring R] {I : ideal R} : I.radical = I.jacobson ↔ ⊥.radical = ⊥.jacobson
theorem category_theory.is_preconnected_of_equivalent {J : Type u₁} [category_theory.category J] {K : Type u₁} [category_theory.category K] [category_theory.is_preconnected J] (e : J ≌ K) : category_theory.is_preconnected K
theorem topological_add_group.continuous_conj_sum {G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] : continuous (λ (g : G × G), g.fst + g.snd + -g.fst)
theorem set.ord_connected_iff {α : Type u_1} [preorder α] {s : set α} : s.ord_connected ↔ ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≤ y → set.Icc x y ⊆ s
theorem subgroup.closure_induction' {G : Type u_1} [group G] {k : set G} {p : Π (x : G), x ∈ subgroup.closure k → Prop} (Hs : ∀ (x : G) (h : x ∈ k), p x _) (H1 : p 1 _) (Hmul : ∀ (x : G) (hx : x ∈ subgroup.closure k) (y : G) (hy : y ∈ subgroup.closure k), p x hx → p y hy → p (x * y) _) (Hinv : ∀ (x : G) (hx : x ∈ subgroup.closure k), p x hx → p x⁻¹ _) {x : G} (hx : x ∈ subgroup.closure k) : p x hx
theorem summable_geometric_iff_norm_lt_1 {K : Type u_4} [normed_field K] {ξ : K} : summable (λ (n : ℕ), ξ ^ n) ↔ ∥ξ∥ < 1
theorem submodule.quotient_torsion.torsion_eq_bot {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] : submodule.torsion R (M ⧸ submodule.torsion R M) = ⊥
theorem subfield.add_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x + y ∈ s
theorem module.projective_lifting_property {R : Type u} [semiring R] {P : Type (max u v)} [add_comm_monoid P] [module R P] {M : Type (max u v)} [add_comm_group M] [module R M] {N : Type u_1} [add_comm_group N] [module R N] [h : module.projective R P] (f : M →ₗ[R] N) (g : P →ₗ[R] N) (hf : function.surjective ⇑f) : ∃ (h : P →ₗ[R] M), f.comp h = g
theorem zpow_eq_zpow_iff' {α : Type u_1} [linear_ordered_comm_group α] {n : ℤ} {a b : α} (hn : n ≠ 0) : a ^ n = b ^ n ↔ a = b
theorem measure_theory.measure.sum_smul_dirac {α : Type u_1} {m0 : measurable_space α} [encodable α] [measurable_singleton_class α] (μ : measure_theory.measure α) : measure_theory.measure.sum (λ (a : α), ⇑μ {a} • measure_theory.measure.dirac a) = μ
theorem matrix.is_hermitian_from_blocks_iff {α : Type u_1} {m : Type u_3} {n : Type u_4} [non_unital_semiring α] [star_ring α] {A : matrix m m α} {B : matrix m n α} {C : matrix n m α} {D : matrix n n α} : (matrix.from_blocks A B C D).is_hermitian ↔ A.is_hermitian ∧ B.conj_transpose = C ∧ C.conj_transpose = B ∧ D.is_hermitian
theorem finsupp.comap_domain_add_of_injective {α : Type u_1} {β : Type u_2} {M : Type u_5} [add_zero_class M] {f : α → β} (hf : function.injective f) (v₁ v₂ : β →₀ M) : finsupp.comap_domain f (v₁ + v₂) _ = finsupp.comap_domain f v₁ _ + finsupp.comap_domain f v₂ _
theorem con.sup_def {M : Type u_1} [has_mul M] {c d : con M} : c ⊔ d = con_gen (setoid.r ⊔ setoid.r)
theorem has_deriv_within_at.Iio_of_Iic {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {F : Type v} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜} [partial_order 𝕜] : has_deriv_within_at f f' (set.Iic x) x → has_deriv_within_at f f' (set.Iio x) x
theorem multiset.nat.card_antidiagonal (n : ℕ) : ⇑multiset.card (multiset.nat.antidiagonal n) = n + 1
theorem exists_measurable_piecewise_nat {α : Type u_1} {β : Type u_2} {mβ : measurable_space β} {m : measurable_space α} (t : ℕ → set β) (t_meas : ∀ (n : ℕ), measurable_set (t n)) (t_disj : pairwise (disjoint on t)) (g : ℕ → β → α) (hg : ∀ (n : ℕ), measurable (g n)) : ∃ (f : β → α), measurable f ∧ ∀ (n : ℕ) (x : β), x ∈ t n → f x = g n x
theorem has_fpower_series_on_ball.tendsto_uniformly_on {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] {f : E → F} {p : formal_multilinear_series 𝕜 E F} {x : E} {r : ennreal} {r' : nnreal} (hf : has_fpower_series_on_ball f p x r) (h : ↑r' < r) : tendsto_uniformly_on (λ (n : ℕ) (y : E), p.partial_sum n y) (λ (y : E), f (x + y)) filter.at_top (metric.ball 0 ↑r')
theorem equiv.is_empty_congr {α : Sort u} {β : Sort v} (e : α ≃ β) : is_empty α ↔ is_empty β
theorem add_con.sup_def {M : Type u_1} [has_add M] {c d : add_con M} : c ⊔ d = add_con_gen (setoid.r ⊔ setoid.r)
theorem submonoid.subsemiring_closure_eq_closure {R : Type u} [non_assoc_semiring R] (M : submonoid R) : M.subsemiring_closure = subsemiring.closure ↑M
theorem measure_theory.ae_interval_oc_iff {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} [linear_order α] {a b : α} {P : α → Prop} : (∀ᵐ (x : α) ∂μ, x ∈ set.interval_oc a b → P x) ↔ (∀ᵐ (x : α) ∂μ, x ∈ set.Ioc a b → P x) ∧ ∀ᵐ (x : α) ∂μ, x ∈ set.Ioc b a → P x
theorem submodule.is_compl_orthogonal_of_complete_space {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K : submodule 𝕜 E} [complete_space ↥K] : is_compl K Kᗮ
theorem finsupp.add_hom_ext {α : Type u_1} {M : Type u_5} {N : Type u_7} [add_zero_class M] [add_zero_class N] ⦃f g : (α →₀ M) →+ N⦄ (H : ∀ (x : α) (y : M), ⇑f (finsupp.single x y) = ⇑g (finsupp.single x y)) : f = g
theorem apply_ite {α : Sort u_1} {β : Sort u_2} (f : α → β) (P : Prop) [decidable P] (a b : α) : f (ite P a b) = ite P (f a) (f b)
theorem interval_integral.integral_eq_sub_of_has_deriv_right_of_le_real {a b : ℝ} {g' g : ℝ → ℝ} (hab : a ≤ b) (hcont : continuous_on g (set.Icc a b)) (hderiv : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_within_at g (g' x) (set.Ioi x) x) (g'int : measure_theory.integrable_on g' (set.Icc a b) measure_theory.measure_space.volume) : ∫ (y : ℝ) in a..b, g' y = g b - g a
theorem padic_norm.padic_norm_p {p : ℕ} (hp : 1 < p) : padic_norm p ↑p = 1 / ↑p
theorem basis.ext_linear_isometry_equiv {R : Type u_1} {R₂ : Type u_2} {E : Type u_5} {E₂ : Type u_6} [semiring R] [semiring R₂] {σ₁₂ : R →+* R₂} {σ₂₁ : R₂ →+* R} [ring_hom_inv_pair σ₁₂ σ₂₁] [ring_hom_inv_pair σ₂₁ σ₁₂] [semi_normed_group E] [semi_normed_group E₂] [module R E] [module R₂ E₂] {ι : Type u_3} (b : basis ι R E) {f₁ f₂ : E ≃ₛₗᵢ[σ₁₂] E₂} (h : ∀ (i : ι), ⇑f₁ (⇑b i) = ⇑f₂ (⇑b i)) : f₁ = f₂
theorem linear_map.eq_on_span {R : Type u_1} {R₂ : Type u_2} {M : Type u_4} {M₂ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring R₂] [add_comm_monoid M₂] [module R₂ M₂] {σ₁₂ : R →+* R₂} {s : set M} {f g : M →ₛₗ[σ₁₂] M₂} (H : set.eq_on ⇑f ⇑g s) ⦃x : M⦄ (h : x ∈ submodule.span R s) : ⇑f x = ⇑g x
theorem zmod.nat_cast_comp_val {n : ℕ} (R : Type u_1) [ring R] [fact (0 < n)] : coe ∘ zmod.val = coe
theorem has_ftaylor_series_up_to_on.congr {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f f₁ : E → F} {n : with_top ℕ} {p : E → formal_multilinear_series 𝕜 E F} (h : has_ftaylor_series_up_to_on n f p s) (h₁ : ∀ (x : E), x ∈ s → f₁ x = f x) : has_ftaylor_series_up_to_on n f₁ p s
theorem add_monoid_hom.lipschitz_of_bound {E : Type u_3} {F : Type u_4} [semi_normed_group E] [semi_normed_group F] (f : E →+ F) (C : ℝ) (h : ∀ (x : E), ∥⇑f x∥ ≤ C * ∥x∥) : lipschitz_with C.to_nnreal ⇑f
theorem measure_theory.measure.rn_deriv_lt_top {α : Type u_1} {m : measurable_space α} (μ ν : measure_theory.measure α) [measure_theory.sigma_finite μ] : ∀ᵐ (x : α) ∂ν, μ.rn_deriv ν x < ⊤
theorem ideal.map_le_comap_of_inverse {R : Type u} {S : Type v} [semiring R] [semiring S] (f : R →+* S) (g : S →+* R) (I : ideal R) (h : function.left_inverse ⇑g ⇑f) : ideal.map f I ≤ ideal.comap g I
theorem category_theory.presieve.is_sheaf_for.unique_extend {C : Type u₁} [category_theory.category C] {X : C} {S : category_theory.sieve X} {P : Cᵒᵖ ⥤ Type v₁} (h : category_theory.presieve.is_sheaf_for P ⇑S) {f : S.functor ⟶ P} (t : category_theory.yoneda.obj X ⟶ P) (ht : S.functor_inclusion ≫ t = f) : t = h.extend f
theorem convex_hull_ediam {E : Type u_2} [semi_normed_group E] [normed_space ℝ E] (s : set E) : emetric.diam (⇑(convex_hull ℝ) s) = emetric.diam s
theorem Class.iota_ex (p : Set → Prop) : Class.iota p ∈ Class.univ
theorem quotient_norm_eq_zero_iff {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) : ∥⇑(quotient_add_group.mk' S) m∥ = 0 ↔ m ∈ closure ↑S
theorem category_theory.sheaf.is_sheaf_for_bind {C : Type u} [category_theory.category C] {X : C} (P : Cᵒᵖ ⥤ Type v) (U : category_theory.sieve X) (B : Π ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, ⇑U f → category_theory.sieve Y) (hU : category_theory.presieve.is_sheaf_for P ⇑U) (hB : ∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄ (hf : ⇑U f), category_theory.presieve.is_sheaf_for P ⇑(B hf)) (hB' : ∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄ (h : ⇑U f) ⦃Z : C⦄ (g : Z ⟶ Y), category_theory.presieve.is_separated_for P ⇑(category_theory.sieve.pullback g (B h))) : category_theory.presieve.is_sheaf_for P ⇑(category_theory.sieve.bind ⇑U B)
theorem concave_on.set_average_mem_hypograph {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {t : set α} {f : α → E} {g : E → ℝ} (hg : concave_on ℝ s g) (hgc : continuous_on g s) (hsc : is_closed s) (h0 : ⇑μ t ≠ 0) (ht : ⇑μ t ≠ ⊤) (hfs : ∀ᵐ (x : α) ∂μ.restrict t, f x ∈ s) (hfi : measure_theory.integrable_on f t μ) (hgi : measure_theory.integrable_on (g ∘ f) t μ) : (⨍ (x : α) in t, f x ∂μ, ⨍ (x : α) in t, g (f x) ∂μ) ∈ {p : E × ℝ | p.fst ∈ s ∧ p.snd ≤ g p.fst}
theorem category_theory.functor.ess_image.of_nat_iso {C : Type u₁} {D : Type u₂} [category_theory.category C] [category_theory.category D] {F F' : C ⥤ D} (h : F ≅ F') {Y : D} (hY : Y ∈ F.ess_image) : Y ∈ F'.ess_image
theorem intermediate_field.map_mono {K : Type u_1} {L : Type u_2} {M : Type u_3} [field K] [field L] [field M] [algebra K L] [algebra K M] {E1 E2 : intermediate_field K L} (e : L ≃ₐ[K] M) (h12 : E1 ≤ E2) : E1.map e.to_alg_hom ≤ E2.map e.to_alg_hom
theorem asymptotics.is_O.norm_right {α : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : α → E} {g' : α → F'} {l : filter α} : f =O[l] g' → (f =O[l] λ (x : α), ∥g' x∥)
theorem orthonormal.inner_left_fintype {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} [fintype ι] {v : ι → E} (hv : orthonormal 𝕜 v) (l : ι → 𝕜) (i : ι) : has_inner.inner (finset.univ.sum (λ (i : ι), l i • v i)) (v i) = ⇑(star_ring_end 𝕜) (l i)
theorem strict_convex_on_pow {n : ℕ} (hn : 2 ≤ n) : strict_convex_on ℝ (set.Ici 0) (λ (x : ℝ), x ^ n)
theorem submodule.fg_of_fg_map_of_fg_inf_ker {R : Type u_1} {M : Type u_2} {P : Type u_3} [ring R] [add_comm_group M] [module R M] [add_comm_group P] [module R P] (f : M →ₗ[R] P) {s : submodule R M} (hs1 : (submodule.map f s).fg) (hs2 : (s ⊓ f.ker).fg) : s.fg
theorem measure_theory.integral_mul_left_eq_self {G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure G} [group G] [has_measurable_mul G] [μ.is_mul_left_invariant] (f : G → E) (g : G) : ∫ (x : G), f (g * x) ∂μ = ∫ (x : G), f x ∂μ
theorem complete_lattice.independent.subtype_ne_bot_le_finrank {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] {ι : Type w} {p : ι → submodule K V} (hp : complete_lattice.independent p) [fintype {i // p i ≠ ⊥}] : fintype.card {i // p i ≠ ⊥} ≤ finite_dimensional.finrank K V
theorem has_mem.mem.ne_of_not_mem' {α : Type u_1} {β : Type u_2} [has_mem α β] {s t : β} {a : α} : a ∈ s → a ∉ t → s ≠ t
theorem add_commute.symm {S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : add_commute b a
theorem algebra.is_algebraic_trans {K : Type u_1} {L : Type u_2} {A : Type u_5} [field K] [field L] [comm_ring A] [algebra K L] [algebra L A] [algebra K A] [is_scalar_tower K L A] (L_alg : algebra.is_algebraic K L) (A_alg : algebra.is_algebraic L A) : algebra.is_algebraic K A
theorem dense_range_pure {α : Type u} : dense_range has_pure.pure
theorem commute.geom_sum₂_mul_add {α : Type u} [semiring α] {x y : α} (h : commute x y) (n : ℕ) : (finset.range n).sum (λ (i : ℕ), (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n
theorem linear_isometry.inner_map_map {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {E' : Type u_7} [inner_product_space 𝕜 E'] (f : E →ₗᵢ[𝕜] E') (x y : E) : has_inner.inner (⇑f x) (⇑f y) = has_inner.inner x y
theorem bounded_continuous_function.exists_norm_eq_restrict_eq_of_closed {Y : Type u_2} [topological_space Y] [normal_space Y] {s : set Y} (f : bounded_continuous_function ↥s ℝ) (hs : is_closed s) : ∃ (g : bounded_continuous_function Y ℝ), ∥g∥ = ∥f∥ ∧ g.restrict s = f
theorem category_theory.is_iso_of_epi_of_nonzero {C : Type u} [category_theory.category C] [category_theory.abelian C] {X Y : C} [category_theory.simple X] {f : X ⟶ Y} [category_theory.epi f] (w : f ≠ 0) : category_theory.is_iso f
theorem list.nth_zero_add_tail_sum {M : Type u_3} [add_monoid M] (l : list M) : (l.nth 0).get_or_else 0 + l.tail.sum = l.sum
theorem add_subgroup.vadd_invariant_measure {G : Type u_1} [add_group G] [measurable_space G] [topological_space G] [topological_add_group G] [borel_space G] {μ : measure_theory.measure G} {Γ : add_subgroup G} [μ.is_add_right_invariant] : measure_theory.vadd_invariant_measure ↥(Γ.opposite) G μ
theorem continuous_map.compact_open_eq_Inf_induced {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] : continuous_map.compact_open = ⨅ (s : set α) (hs : is_compact s), topological_space.induced (continuous_map.restrict s) continuous_map.compact_open
theorem self_adjoint.mem_spectrum_eq_re' {A : Type u_1} [normed_ring A] [normed_algebra ℂ A] [complete_space A] [star_ring A] [cstar_ring A] [star_module ℂ A] [nontrivial A] (a : ↥(self_adjoint A)) {z : ℂ} (hz : z ∈ spectrum ℂ ↑a) : z = ↑(z.re)
theorem basis_le_span' {R : Type u} [ring R] [rank_condition R] {M : Type v} [add_comm_group M] [module R M] {ι : Type u_1} (b : basis ι R M) {w : set M} [fintype ↥w] (s : submodule.span R w = ⊤) : cardinal.mk ι ≤ ↑(fintype.card ↥w)
theorem is_dedekind_domain.height_one_spectrum.valuation_lt_one_iff_dvd {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] {K : Type u_2} [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) (r : R) : ⇑(v.valuation) (⇑(algebra_map R K) r) < 1 ↔ v.as_ideal ∣ ideal.span {r}
theorem disjoint.eq_bot_of_self {α : Type u} [semilattice_inf α] [order_bot α] {a : α} : disjoint a a → a = ⊥
theorem sq_add_mul_sq_mul_sq_add_mul_sq {R : Type u_1} [comm_ring R] {x₁ x₂ y₁ y₂ n : R} : (x₁ ^ 2 + n * x₂ ^ 2) * (y₁ ^ 2 + n * y₂ ^ 2) = (x₁ * y₁ - n * x₂ * y₂) ^ 2 + n * (x₁ * y₂ + x₂ * y₁) ^ 2
theorem subalgebra.is_field_of_algebraic {K : Type u_3} {L : Type u_4} [field K] [field L] [algebra K L] (A : subalgebra K L) (hKL : algebra.is_algebraic K L) : is_field ↥A
theorem nnreal.Lp_add_le {ι : Type u} (s : finset ι) (f g : ι → nnreal) {p : ℝ} (hp : 1 ≤ p) : s.sum (λ (i : ι), (f i + g i) ^ p) ^ (1 / p) ≤ s.sum (λ (i : ι), f i ^ p) ^ (1 / p) + s.sum (λ (i : ι), g i ^ p) ^ (1 / p)
theorem is_add_submonoid.finset_sum_mem {M : Type u_1} {A : Type u_2} [add_comm_monoid M] {s : set M} (hs : is_add_submonoid s) (f : A → M) (t : finset A) : (∀ (b : A), b ∈ t → f b ∈ s) → t.sum (λ (b : A), f b) ∈ s
theorem measure_theory.signed_measure.subset_negative_null_set {α : Type u_1} [measurable_space α] {s : measure_theory.signed_measure α} {u v w : set α} (hu : measurable_set u) (hv : measurable_set v) (hw : measurable_set w) (hsu : measure_theory.vector_measure.restrict s u ≤ 0.restrict u) (hw₁ : ⇑s w = 0) (hw₂ : w ⊆ u) (hwt : v ⊆ w) : ⇑s v = 0
theorem measure_theory.measure_congr {α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {s t : set α} (H : s =ᵐ[μ] t) : ⇑μ s = ⇑μ t
theorem euclidean_geometry.orthogonal_projection_eq_self_iff {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} [nonempty ↥s] [complete_space ↥(s.direction)] {p : P} : ↑(⇑(euclidean_geometry.orthogonal_projection s) p) = p ↔ p ∈ s
theorem local_homeomorph.continuous_on_iff_continuous_on_comp_left {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] (e : local_homeomorph α β) {f : γ → α} {s : set γ} (h : s ⊆ f ⁻¹' e.to_local_equiv.source) : continuous_on f s ↔ continuous_on (⇑e ∘ f) s
theorem affine_subspace.inter_nonempty_of_nonempty_of_sup_direction_eq_top {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s1 s2 : affine_subspace k P} (h1 : ↑s1.nonempty) (h2 : ↑s2.nonempty) (hd : s1.direction ⊔ s2.direction = ⊤) : (↑s1 ∩ ↑s2).nonempty
theorem has_subset.subset.trans_ssubset {α : Type u} [has_subset α] [has_ssubset α] [is_nonstrict_strict_order α has_subset.subset has_ssubset.ssubset] {a b c : α} [is_trans α has_subset.subset] (h₁ : a ⊆ b) (h₂ : b ⊂ c) : a ⊂ c
theorem add_equiv.is_add_monoid_hom {M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (h : M ≃+ N) : is_add_monoid_hom ⇑h
theorem has_fderiv_at.comp_has_deriv_at {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {F : Type v} [normed_group F] [normed_space 𝕜 F] {E : Type w} [normed_group E] [normed_space 𝕜 E] {f : 𝕜 → F} {f' : F} (x : 𝕜) {l : F → E} {l' : F →L[𝕜] E} (hl : has_fderiv_at l l' (f x)) (hf : has_deriv_at f f' x) : has_deriv_at (l ∘ f) (⇑l' f') x
theorem probability_theory.lintegral_mul_eq_lintegral_mul_lintegral_of_independent_measurable_space {α : Type u_1} {f g : α → ennreal} {Mf Mg mα : measurable_space α} {μ : measure_theory.measure α} (hMf : Mf ≤ mα) (hMg : Mg ≤ mα) (h_ind : probability_theory.indep Mf Mg μ) (h_meas_f : measurable f) (h_meas_g : measurable g) : ∫⁻ (a : α), f a * g a ∂μ = ∫⁻ (a : α), f a ∂μ * ∫⁻ (a : α), g a ∂μ
theorem matrix.det_reindex_self {m : Type u_1} {n : Type u_2} [decidable_eq n] [fintype n] [decidable_eq m] [fintype m] {R : Type v} [comm_ring R] (e : m ≃ n) (A : matrix m m R) : (⇑(matrix.reindex e e) A).det = A.det
theorem continuous_linear_map.adjoint_adjoint {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [inner_product_space 𝕜 F] [complete_space E] [complete_space F] (A : E →L[𝕜] F) : ⇑continuous_linear_map.adjoint (⇑continuous_linear_map.adjoint A) = A
theorem unique_mdiff_within_at.unique_diff_within_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {s : set E} {x : E} : unique_mdiff_within_at (model_with_corners_self 𝕜 E) s x → unique_diff_within_at 𝕜 s x
theorem measure_theory.measure.pi_has_no_atoms {ι : Type u_1} {α : ι → Type u_3} [fintype ι] [Π (i : ι), measurable_space (α i)] {μ : Π (i : ι), measure_theory.measure (α i)} [∀ (i : ι), measure_theory.sigma_finite (μ i)] (i : ι) [measure_theory.has_no_atoms (μ i)] : measure_theory.has_no_atoms (measure_theory.measure.pi μ)
theorem filter.is_cobounded.mk {α : Type u_1} {r : α → α → Prop} {f : filter α} [is_trans α r] (a : α) (h : ∀ (s : set α), s ∈ f → (∃ (x : α) (H : x ∈ s), r a x)) : filter.is_cobounded r f
theorem inner_product_space.is_self_adjoint.has_eigenvector_of_is_min_on {𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] [complete_space E] {T : E →L[𝕜] E} (hT : inner_product_space.is_self_adjoint ↑T) {x₀ : E} (hx₀ : x₀ ≠ 0) (hextr : is_min_on T.re_apply_inner_self (metric.sphere 0 ∥x₀∥) x₀) : module.End.has_eigenvector ↑T (↑⨅ (x : {x // x ≠ 0}), (λ (x : E), T.re_apply_inner_self x / ∥x∥ ^ 2) ↑x) x₀
theorem measure_theory.finite_measure.tendsto_lintegral_nn_filter_of_le_const {α : Type u_1} [measurable_space α] [topological_space α] [opens_measurable_space α] {ι : Type u_2} {L : filter ι} [L.is_countably_generated] (μ : measure_theory.finite_measure α) {fs : ι → bounded_continuous_function α nnreal} {c : nnreal} (fs_le_const : ∀ᶠ (i : ι) in L, ∀ᵐ (a : α) ∂↑μ, ⇑(fs i) a ≤ c) {f : α → nnreal} (fs_lim : ∀ᵐ (a : α) ∂↑μ, filter.tendsto (λ (i : ι), ⇑(fs i) a) L (nhds (f a))) : filter.tendsto (λ (i : ι), ∫⁻ (a : α), ↑(⇑(fs i) a) ∂↑μ) L (nhds (∫⁻ (a : α), ↑(f a) ∂↑μ))
theorem cont_diff_at.fst'' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {n : with_top ℕ} {f : E → G} {x : E × F} (hf : cont_diff_at 𝕜 n f x.fst) : cont_diff_at 𝕜 n (λ (x : E × F), f x.fst) x
theorem polynomial.unique_int_coeff_of_cycl {K : Type u_1} [comm_ring K] [is_domain K] [char_zero K] {ζ : K} {n : ℕ+} (h : is_primitive_root ζ ↑n) : ∃! (P : polynomial ℤ), polynomial.map (int.cast_ring_hom K) P = polynomial.cyclotomic' ↑n K
theorem finset.sum_induction_nonempty {α : Type v} {s : finset α} {M : Type u_1} [add_comm_monoid M] (f : α → M) (p : M → Prop) (p_mul : ∀ (a b : M), p a → p b → p (a + b)) (hs_nonempty : s.nonempty) (p_s : ∀ (x : α), x ∈ s → p (f x)) : p (s.sum (λ (x : α), f x))
theorem covby.is_coatom {α : Type u_1} [partial_order α] [order_top α] {a : α} : a ⋖ ⊤ → is_coatom a
theorem model_with_corners_self_local_equiv (𝕜 : Type u_1) [nondiscrete_normed_field 𝕜] (E : Type u_2) [normed_group E] [normed_space 𝕜 E] : (model_with_corners_self 𝕜 E).to_local_equiv = local_equiv.refl E
theorem ideal.smul_eq_mul {R : Type u} [comm_semiring R] (I J : ideal R) : I • J = I * J
theorem finset.prod_induction_nonempty {α : Type v} {s : finset α} {M : Type u_1} [comm_monoid M] (f : α → M) (p : M → Prop) (p_mul : ∀ (a b : M), p a → p b → p (a * b)) (hs_nonempty : s.nonempty) (p_s : ∀ (x : α), x ∈ s → p (f x)) : p (s.prod (λ (x : α), f x))
theorem category_theory.is_pushout.zero_bot {C : Type u₁} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] (X : C) : category_theory.is_pushout (𝟙 X) 0 0 0
theorem direct_sum.mul_eq_sum_support_ghas_mul {ι : Type u_1} [decidable_eq ι] (A : ι → Type u_2) [Π (i : ι), add_comm_monoid (A i)] [add_monoid ι] [direct_sum.gsemiring A] [Π (i : ι) (x : A i), decidable (x ≠ 0)] (a a' : direct_sum ι (λ (i : ι), A i)) : a * a' = ((dfinsupp.support a).product (dfinsupp.support a')).sum (λ (ij : ι × ι), ⇑(direct_sum.of A (ij.fst + ij.snd)) (graded_monoid.ghas_mul.mul (⇑a ij.fst) (⇑a' ij.snd)))
theorem cardinal.mk_Ico_real {a b : ℝ} (h : a < b) : cardinal.mk ↥(set.Ico a b) = cardinal.continuum
theorem isometry.nndist_eq {α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {f : α → β} (hf : isometry f) (x y : α) : has_nndist.nndist (f x) (f y) = has_nndist.nndist x y
theorem continuous_map.dist_apply_le_dist {α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β] {f g : C(α, β)} (x : α) : has_dist.dist (⇑f x) (⇑g x) ≤ has_dist.dist f g
theorem finsupp.lhom_ext' {α : Type u_1} {M : Type u_2} {N : Type u_3} {R : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [add_comm_monoid N] [module R N] ⦃φ ψ : (α →₀ M) →ₗ[R] N⦄ (h : ∀ (a : α), φ.comp (finsupp.lsingle a) = ψ.comp (finsupp.lsingle a)) : φ = ψ
theorem analytic_at.comp {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] [normed_group G] [normed_space 𝕜 G] {g : F → G} {f : E → F} {x : E} (hg : analytic_at 𝕜 g (f x)) (hf : analytic_at 𝕜 f x) : analytic_at 𝕜 (g ∘ f) x
theorem add_hom.eq_on_mclosure {M : Type u_1} {N : Type u_2} [has_add M] [has_add N] {f g : add_hom M N} {s : set M} (h : set.eq_on ⇑f ⇑g s) : set.eq_on ⇑f ⇑g ↑(add_subsemigroup.closure s)
theorem inner_product_geometry.norm_sub_eq_abs_sub_norm_of_angle_eq_zero {V : Type u_1} [inner_product_space ℝ V] {x y : V} (h : inner_product_geometry.angle x y = 0) : ∥x - y∥ = |∥x∥ - ∥y∥|
theorem metric.continuous_inf_nndist_pt {α : Type u} [pseudo_metric_space α] (s : set α) : continuous (λ (x : α), metric.inf_nndist x s)
theorem is_integral_closure.is_fraction_ring_of_finite_extension (A : Type u_4) (K : Type u_5) [comm_ring A] [is_domain A] (L : Type u_6) [field K] [field L] [algebra A K] [algebra A L] [is_fraction_ring A K] (C : Type u_7) [comm_ring C] [is_domain C] [algebra C L] [is_integral_closure C A L] [algebra A C] [is_scalar_tower A C L] [algebra K L] [is_scalar_tower A K L] [finite_dimensional K L] : is_fraction_ring C L
theorem interval_integral.integral_has_strict_fderiv_at_of_tendsto_ae {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {ca cb : E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (ha : filter.tendsto f (nhds a ⊓ measure_theory.measure_space.volume.ae) (nhds ca)) (hb : filter.tendsto f (nhds b ⊓ measure_theory.measure_space.volume.ae) (nhds cb)) : has_strict_fderiv_at (λ (p : ℝ × ℝ), ∫ (x : ℝ) in p.fst..p.snd, f x) ((continuous_linear_map.snd ℝ ℝ ℝ).smul_right cb - (continuous_linear_map.fst ℝ ℝ ℝ).smul_right ca) (a, b)
theorem mem_extreme_points_iff_forall_segment {𝕜 : Type u_1} {E : Type u_2} [linear_ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] [densely_ordered 𝕜] [no_zero_smul_divisors 𝕜 E] {A : set E} {x : E} : x ∈ set.extreme_points 𝕜 A ↔ x ∈ A ∧ ∀ (x₁ : E), x₁ ∈ A → ∀ (x₂ : E), x₂ ∈ A → x ∈ segment 𝕜 x₁ x₂ → x₁ = x ∨ x₂ = x
theorem nat.sum_two_pow_lt {k : ℕ} {A : finset ℕ} (h₁ : ∀ {x : ℕ}, x ∈ A → x < k) : A.sum (has_pow.pow 2) < 2 ^ k
theorem has_sbtw.sbtw.not_sbtw {α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : ¬has_sbtw.sbtw c b a
theorem fintype.exists_le_card_fiber_of_nsmul_le_card {α : Type u} {β : Type v} {M : Type w} [decidable_eq β] [fintype α] [fintype β] (f : α → β) {b : M} [linear_ordered_comm_ring M] [nonempty β] (hb : fintype.card β • b ≤ ↑(fintype.card α)) : ∃ (y : β), b ≤ ↑((finset.filter (λ (x : α), f x = y) finset.univ).card)
theorem fin.succ_succ_above_one {n : ℕ} (i : fin (n + 2)) : ⇑(i.succ.succ_above) 1 = (⇑(i.succ_above) 0).succ
theorem measure_theory.measure_lt_top_of_is_compact_of_is_add_left_invariant' {G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {μ : measure_theory.measure G} [add_group G] [topological_add_group G] [μ.is_add_left_invariant] {U : set G} (hU : (interior U).nonempty) (h : ⇑μ U ≠ ⊤) {K : set G} (hK : is_compact K) : ⇑μ K < ⊤
theorem local_homeomorph.is_image.of_preimage_eq {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {e : local_homeomorph α β} {s : set α} {t : set β} : e.to_local_equiv.source ∩ ⇑e ⁻¹' t = e.to_local_equiv.source ∩ s → e.is_image s t
theorem dist_le_of_trajectories_ODE_of_mem_set {E : Type u_1} [normed_group E] [normed_space ℝ E] {v : ℝ → E → E} {s : ℝ → set E} {K : ℝ} (hv : ∀ (t : ℝ) (x : E), x ∈ s t → ∀ (y : E), y ∈ s t → has_dist.dist (v t x) (v t y) ≤ K * has_dist.dist x y) {f g : ℝ → E} {a b δ : ℝ} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (t : ℝ), t ∈ set.Ico a b → has_deriv_within_at f (v t (f t)) (set.Ici t) t) (hfs : ∀ (t : ℝ), t ∈ set.Ico a b → f t ∈ s t) (hg : continuous_on g (set.Icc a b)) (hg' : ∀ (t : ℝ), t ∈ set.Ico a b → has_deriv_within_at g (v t (g t)) (set.Ici t) t) (hgs : ∀ (t : ℝ), t ∈ set.Ico a b → g t ∈ s t) (ha : has_dist.dist (f a) (g a) ≤ δ) (t : ℝ) (H : t ∈ set.Icc a b) : has_dist.dist (f t) (g t) ≤ δ * real.exp (K * (t - a))
theorem exp_neg_inv_glue.f_aux_limit (n : ℕ) : filter.tendsto (λ (x : ℝ), polynomial.eval x (exp_neg_inv_glue.P_aux n) * real.exp (-x⁻¹) / x ^ (2 * n)) (nhds_within 0 (set.Ioi 0)) (nhds 0)
theorem polynomial.span_le_of_coeff_mem_C_inverse {R : Type u} [semiring R] {f : polynomial R} {I : submodule (polynomial R) (polynomial R)} (cf : ∀ (i : ℕ), f.coeff i ∈ ⇑polynomial.C ⁻¹' I.carrier) : submodule.span (polynomial R) {g : polynomial R | ∃ (i : ℕ), g = ⇑polynomial.C (f.coeff i)} ≤ I
theorem order.partial_iso.exists_across {α : Type u_1} {β : Type u_2} [linear_order α] [linear_order β] [densely_ordered β] [no_min_order β] [no_max_order β] [nonempty β] (f : order.partial_iso α β) (a : α) : ∃ (b : β), ∀ (p : α × β), p ∈ f.val → cmp p.fst a = cmp p.snd b
theorem padic_val_rat.sum_pos_of_pos (p : ℕ) [p_prime : fact (nat.prime p)] {n : ℕ} {F : ℕ → ℚ} (hF : ∀ (i : ℕ), i < n → 0 < padic_val_rat p (F i)) (hn0 : (finset.range n).sum (λ (i : ℕ), F i) ≠ 0) : 0 < padic_val_rat p ((finset.range n).sum (λ (i : ℕ), F i))
theorem monoid.closure_singleton {M : Type u_1} [monoid M] {x : M} : monoid.closure {x} = powers x
theorem bdd_above.image2 {α : Type u} {β : Type v} {γ : Type w} [preorder α] [preorder β] [preorder γ] {f : α → β → γ} {s : set α} {t : set β} (h₀ : ∀ (b : β), monotone (function.swap f b)) (h₁ : ∀ (a : α), monotone (f a)) : bdd_above s → bdd_above t → bdd_above (set.image2 f s t)
theorem sym2.card {α : Type u_1} [decidable_eq α] [fintype α] : fintype.card (sym2 α) = fintype.card α * (fintype.card α + 1) / 2
theorem convex.norm_image_sub_le_of_norm_has_fderiv_within_le {E : Type u_1} [normed_group E] [normed_space ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_space 𝕜 E] [normed_group G] [normed_space 𝕜 G] {f : E → G} {C : ℝ} {s : set E} {x y : E} {f' : E → (E →L[𝕜] G)} (hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (bound : ∀ (x : E), x ∈ s → ∥f' x∥ ≤ C) (hs : convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∥f y - f x∥ ≤ C * ∥y - x∥
theorem category_theory.eq_to_iso_map {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) {X Y : C} (p : X = Y) : F.map_iso (category_theory.eq_to_iso p) = category_theory.eq_to_iso _
theorem measure_theory.strongly_measurable.fin_strongly_measurable {α : Type u_1} {β : Type u_2} {f : α → β} [topological_space β] [has_zero β] {m0 : measurable_space α} (hf : measure_theory.strongly_measurable f) (μ : measure_theory.measure α) [measure_theory.sigma_finite μ] : measure_theory.fin_strongly_measurable f μ
theorem locally_finite.finite_nonempty_of_compact {α : Type u} [topological_space α] {ι : Type u_1} [compact_space α] {f : ι → set α} (hf : locally_finite f) : {i : ι | (f i).nonempty}.finite
theorem nat.factorization_eq_zero_iff (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1
theorem lucas_lehmer.order_ω (p' : ℕ) (h : lucas_lehmer.lucas_lehmer_residue (p' + 2) = 0) : order_of (lucas_lehmer.ω_unit (p' + 2)) = 2 ^ (p' + 2)
theorem linear_equiv.finrank_map_eq {R : Type u_1} {M : Type u_2} {M₂ : Type u_3} [ring R] [add_comm_group M] [add_comm_group M₂] [module R M] [module R M₂] (f : M ≃ₗ[R] M₂) (p : submodule R M) : finite_dimensional.finrank R ↥(submodule.map ↑f p) = finite_dimensional.finrank R ↥p
theorem algebraic_geometry.PresheafedSpace.glue_data.π_ι_inv_app_π {C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) [category_theory.limits.has_limits C] (i j : D.to_glue_data.J) (U : topological_space.opens ↥((D.to_glue_data.U i).carrier)) : D.diagram_over_open_π U i ≫ D.ι_inv_app_π_eq_map U ≫ D.ι_inv_app U ≫ D.diagram_over_open_π U j = D.diagram_over_open_π U j
theorem finset.mem_up_shadow_iff_exists_mem_card_add_one {α : Type u_1} [decidable_eq α] [fintype α] {𝒜 : finset (finset α)} {s : finset α} : s ∈ 𝒜.up_shadow ↔ ∃ (t : finset α) (H : t ∈ 𝒜), t ⊆ s ∧ t.card + 1 = s.card
theorem spectrum.pow_nnnorm_pow_one_div_tendsto_nhds_spectral_radius {A : Type u_2} [normed_ring A] [normed_algebra ℂ A] [complete_space A] [norm_one_class A] (a : A) : filter.tendsto (λ (n : ℕ), ↑∥a ^ n∥₊ ^ (1 / ↑n)) filter.at_top (nhds (spectral_radius ℂ a))
theorem order.succ_ne_succ {α : Type u_1} [partial_order α] [succ_order α] {a b : α} [no_max_order α] : a ≠ b → order.succ a ≠ order.succ b
theorem monotone.tendsto_nhds_within_Iio {β : Type v} [conditionally_complete_linear_order β] [topological_space β] [order_topology β] {α : Type u_1} [linear_order α] [topological_space α] [order_topology α] {f : α → β} (Mf : monotone f) (x : α) : filter.tendsto f (nhds_within x (set.Iio x)) (nhds (has_Sup.Sup (f '' set.Iio x)))
theorem generalized_continued_fraction.succ_succ_nth_convergent'_aux_eq_succ_nth_convergent'_aux_squash_seq {K : Type u_1} {n : ℕ} {s : seq (generalized_continued_fraction.pair K)} [division_ring K] : generalized_continued_fraction.convergents'_aux s (n + 2) = generalized_continued_fraction.convergents'_aux (generalized_continued_fraction.squash_seq s n) (n + 1)
theorem mul_hom.map_mclosure {M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (f : M →ₙ* N) (s : set M) : subsemigroup.map f (subsemigroup.closure s) = subsemigroup.closure (⇑f '' s)
theorem category_theory.limits.colimit_limit_to_limit_colimit_injective {J K : Type v} [category_theory.small_category J] [category_theory.small_category K] (F : J × K ⥤ Type v) [category_theory.is_filtered K] [fintype J] : function.injective (category_theory.limits.colimit_limit_to_limit_colimit F)
theorem matrix.det_succ_row_zero {R : Type v} [comm_ring R] {n : ℕ} (A : matrix (fin n.succ) (fin n.succ) R) : A.det = finset.univ.sum (λ (j : fin n.succ), (-1) ^ ↑j * A 0 j * (A.minor fin.succ ⇑(j.succ_above)).det)
theorem tsub_tsub_le {α : Type u_1} [preorder α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] {a b : α} : b - (b - a) ≤ a
theorem has_strict_fderiv_at.approximates_deriv_on_nhds {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {a : E} (hf : has_strict_fderiv_at f f' a) {c : nnreal} (hc : subsingleton E ∨ 0 < c) : ∃ (s : set E) (H : s ∈ nhds a), approximates_linear_on f f' s c
theorem linear_independent.map {ι : Type u_1} {R : Type u_3} {M : Type u_5} {M' : Type u_6} {v : ι → M} [semiring R] [add_comm_monoid M] [add_comm_monoid M'] [module R M] [module R M'] (hv : linear_independent R v) {f : M →ₗ[R] M'} (hf_inj : disjoint (submodule.span R (set.range v)) f.ker) : linear_independent R (⇑f ∘ v)
theorem measure_theory.mul_meas_ge_le_pow_snorm' {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} {p : ennreal} (μ : measure_theory.measure α) [normed_group E] {f : α → E} (hp_ne_zero : p ≠ 0) (hp_ne_top : p ≠ ⊤) (hf : measure_theory.ae_strongly_measurable f μ) (ε : ennreal) : ε ^ p.to_real * ⇑μ {x : α | ε ≤ ↑∥f x∥₊} ≤ measure_theory.snorm f p μ ^ p.to_real
theorem finset.prod_product_right' {β : Type u} {α : Type v} {γ : Type w} [comm_monoid β] {s : finset γ} {t : finset α} {f : γ → α → β} : (s.product t).prod (λ (x : γ × α), f x.fst x.snd) = t.prod (λ (y : α), s.prod (λ (x : γ), f x y))
theorem intermediate_value_univ {X : Type u} {α : Type v} [topological_space X] [linear_order α] [topological_space α] [order_closed_topology α] [preconnected_space X] (a b : X) {f : X → α} (hf : continuous f) : set.Icc (f a) (f b) ⊆ set.range f
theorem quadratic_eq_zero_iff {K : Type u_1} [field K] [invertible 2] {a b c : K} (ha : a ≠ 0) {s : K} (h : discrim a b c = s * s) (x : K) : a * x * x + b * x + c = 0 ↔ x = (-b + s) / (2 * a) ∨ x = (-b - s) / (2 * a)
theorem sigma.subtype_ext {α : Type u_1} {β : Type u_2} {p : α → β → Prop} {x₀ x₁ : Σ (a : α), subtype (p a)} : x₀.fst = x₁.fst → ↑(x₀.snd) = ↑(x₁.snd) → x₀ = x₁
theorem matrix.mul_inv_of_mul_self_cancel {m : Type u} {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix m n α) (B : matrix n n α) [invertible B] : (A.mul (⅟ B)).mul B = A
theorem is_bounded_linear_map_prod_multilinear {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {ι : Type u_5} [decidable_eq ι] [fintype ι] {E : ι → Type u_2} [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] : is_bounded_linear_map 𝕜 (λ (p : continuous_multilinear_map 𝕜 E F × continuous_multilinear_map 𝕜 E G), p.fst.prod p.snd)
theorem measure_theory.conservative.iterate {α : Type u_2} [measurable_space α] {f : α → α} {μ : measure_theory.measure α} (hf : measure_theory.conservative f μ) (n : ℕ) : measure_theory.conservative f^[n] μ
theorem category_theory.discrete.eq_of_hom {α : Type u₁} {X Y : category_theory.discrete α} (i : X ⟶ Y) : X.as = Y.as
theorem ring_hom.ker_is_prime {R : Type u} {S : Type v} [ring R] [ring S] [is_domain S] (f : R →+* S) : f.ker.is_prime
theorem category_theory.presieve.restrict_extend {C : Type u₁} [category_theory.category C] {P : Cᵒᵖ ⥤ Type w} {X : C} {R : category_theory.presieve X} {x : category_theory.presieve.family_of_elements P R} (t : x.compatible) : category_theory.presieve.family_of_elements.restrict _ x.sieve_extend = x
theorem inducing.is_separable_preimage {α : Type u} {β : Type v} [pseudo_metric_space α] {f : β → α} [topological_space β] (hf : inducing f) {s : set α} (hs : topological_space.is_separable s) : topological_space.is_separable (f ⁻¹' s)
theorem measurable.ennreal_induction {α : Type u_1} [measurable_space α] {P : (α → ennreal) → Prop} (h_ind : ∀ (c : ennreal) ⦃s : set α⦄, measurable_set s → P (s.indicator (λ (_x : α), c))) (h_add : ∀ ⦃f g : α → ennreal⦄, disjoint (function.support f) (function.support g) → measurable f → measurable g → P f → P g → P (f + g)) (h_supr : ∀ ⦃f : ℕ → α → ennreal⦄, (∀ (n : ℕ), measurable (f n)) → monotone f → (∀ (n : ℕ), P (f n)) → P (λ (x : α), ⨆ (n : ℕ), f n x)) ⦃f : α → ennreal⦄ (hf : measurable f) : P f
theorem linear_independent_set_iff_affine_independent_vadd_union_singleton (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set V} (hs : ∀ (v : V), v ∈ s → v ≠ 0) (p₁ : P) : linear_independent k (λ (v : ↥s), ↑v) ↔ affine_independent k (λ (p : ↥({p₁} ∪ (λ (v : V), v +ᵥ p₁) '' s)), ↑p)
theorem absolute_value.is_admissible.exists_approx {R : Type u_1} [euclidean_domain R] {abv : absolute_value R ℤ} {ι : Type u_2} [fintype ι] {ε : ℝ} (hε : 0 < ε) {b : R} (hb : b ≠ 0) (h : abv.is_admissible) (A : fin (h.card ε ^ fintype.card ι).succ → ι → R) : ∃ (i₀ i₁ : fin (h.card ε ^ fintype.card ι).succ), i₀ ≠ i₁ ∧ ∀ (k : ι), ↑(⇑abv (A i₁ k % b - A i₀ k % b)) < ⇑abv b • ε
theorem basis.to_matrix_mul_to_matrix_flip {ι : Type u_1} {ι' : Type u_2} {R : Type u_5} {M : Type u_6} [comm_semiring R] [add_comm_monoid M] [module R M] (b : basis ι R M) (b' : basis ι' R M) [decidable_eq ι] [fintype ι'] : (b.to_matrix ⇑b').mul (b'.to_matrix ⇑b) = 1
theorem monoid_hom.map_exists_right_inv {M : Type u_3} {N : Type u_4} {F : Type u_8} {mM : mul_one_class M} {mN : mul_one_class N} [monoid_hom_class F M N] (f : F) {x : M} (hx : ∃ (y : M), x * y = 1) : ∃ (y : N), ⇑f x * y = 1
theorem measure_theory.content.inner_content_Union_nat {G : Type w} [topological_space G] (μ : measure_theory.content G) [t2_space G] ⦃U : ℕ → set G⦄ (hU : ∀ (i : ℕ), is_open (U i)) : μ.inner_content ⟨⋃ (i : ℕ), U i, _⟩ ≤ ∑' (i : ℕ), μ.inner_content ⟨U i, _⟩
theorem measure_theory.unif_integrable_fin {α : Type u_1} {β : Type u_2} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} (hp_one : 1 ≤ p) (hp_top : p ≠ ⊤) {n : ℕ} {f : fin n → α → β} (hf : ∀ (i : fin n), measure_theory.mem_ℒp (f i) p μ) : measure_theory.unif_integrable f p μ
theorem filter.map_coe_Ici_at_top {α : Type u_3} [semilattice_sup α] (a : α) : filter.map coe filter.at_top = filter.at_top
theorem category_theory.grothendieck_topology.le_close_of_is_closed {C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) {X : C} {S T : category_theory.sieve X} (h : S ≤ T) (hT : J₁.is_closed T) : J₁.close S ≤ T
theorem set.pairwise_disjoint.bUnion {α : Type u_1} {ι : Type u_2} {ι' : Type u_3} [complete_lattice α] {s : set ι'} {g : ι' → set ι} {f : ι → α} (hs : s.pairwise_disjoint (λ (i' : ι'), ⨆ (i : ι) (H : i ∈ g i'), f i)) (hg : ∀ (i : ι'), i ∈ s → (g i).pairwise_disjoint f) : (⋃ (i : ι') (H : i ∈ s), g i).pairwise_disjoint f
theorem has_lt.lt.trans_lf {x y z : pgame} (h₁ : x < y) (h₂ : y.lf z) : x.lf z
theorem ideal.dvd_iff_le {A : Type u_2} [comm_ring A] [is_domain A] [is_dedekind_domain A] {I J : ideal A} : I ∣ J ↔ J ≤ I
theorem mem_adjoin_of_smul_prime_smul_of_minpoly_is_eiseinstein_at {R : Type u} {K : Type v} {L : Type z} {p : R} [comm_ring R] [field K] [field L] [algebra K L] [algebra R L] [algebra R K] [is_scalar_tower R K L] [is_separable K L] [is_domain R] [normalized_gcd_monoid R] [is_fraction_ring R K] [is_integrally_closed R] {B : power_basis K L} (hp : prime p) (hBint : is_integral R B.gen) {z : L} (hzint : is_integral R z) (hz : p • z ∈ algebra.adjoin R {B.gen}) (hei : (minpoly R B.gen).is_eisenstein_at (submodule.span R {p})) : z ∈ algebra.adjoin R {B.gen}
theorem measure_theory.measure_preserving.exists_mem_image_mem {α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {f : α → α} {s : set α} [measure_theory.is_finite_measure μ] (hf : measure_theory.measure_preserving f μ μ) (hs : measurable_set s) (hs' : ⇑μ s ≠ 0) : ∃ (x : α) (H : x ∈ s) (m : ℕ) (H : m ≠ 0), f^[m] x ∈ s
theorem bornology.is_bounded.bounded_space_subtype {α : Type u_1} [bornology α] {p : α → Prop} : bornology.is_bounded {x : α | p x} → bounded_space (subtype p)
theorem interval_integral.integral_const_of_cdf {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {a b : ℝ} {μ : measure_theory.measure ℝ} [measure_theory.is_finite_measure μ] (c : E) : ∫ (x : ℝ) in a..b, c ∂μ = ((⇑μ (set.Iic b)).to_real - (⇑μ (set.Iic a)).to_real) • c
theorem uniformity_pseudoedist {α : Type u} [pseudo_emetric_space α] : uniformity α = ⨅ (ε : ennreal) (H : ε > 0), filter.principal {p : α × α | has_edist.edist p.fst p.snd < ε}
theorem zero_ne_one_or_forall_eq_0 {M₀ : Type u_1} [mul_zero_one_class M₀] : 0 ≠ 1 ∨ ∀ (a : M₀), a = 0
theorem affine.simplex.monge_point_mem_affine_span {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P n) : s.monge_point ∈ affine_span ℝ (set.range s.points)
theorem dense_embedding.separable_space {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {e : α → β} (de : dense_embedding e) [topological_space.separable_space α] : topological_space.separable_space β
theorem finset.center_mass_id_mem_convex_hull {R : Type u_1} {E : Type u_2} [linear_ordered_field R] [add_comm_group E] [module R E] (t : finset E) {w : E → R} (hw₀ : ∀ (i : E), i ∈ t → 0 ≤ w i) (hws : 0 < t.sum (λ (i : E), w i)) : t.center_mass w id ∈ ⇑(convex_hull R) ↑t
theorem submodule.coe_inner {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (W : submodule 𝕜 E) (x y : ↥W) : has_inner.inner x y = has_inner.inner ↑x ↑y
theorem dense_bInter_of_open {α : Type u_1} {β : Type u_2} [topological_space α] [baire_space α] {S : set β} {f : β → set α} (ho : ∀ (s : β), s ∈ S → is_open (f s)) (hS : S.countable) (hd : ∀ (s : β), s ∈ S → dense (f s)) : dense (⋂ (s : β) (H : s ∈ S), f s)
theorem is_compact.is_closed {α : Type u} [topological_space α] [t2_space α] {s : set α} (hs : is_compact s) : is_closed s
theorem nat.cast_desc_factorial_two (S : Type u_1) [ring S] (a : ℕ) : ↑(a.desc_factorial 2) = ↑a * (↑a - 1)
theorem vitali_family.measure_le_mul_of_subset_lim_ratio_meas_lt {α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {ρ : measure_theory.measure α} [measure_theory.is_locally_finite_measure ρ] (hρ : ρ.absolutely_continuous μ) {p : nnreal} {s : set α} (h : s ⊆ {x : α | v.lim_ratio_meas hρ x < ↑p}) : ⇑ρ s ≤ ↑p * ⇑μ s
theorem ideal.is_jacobson_iff_prime_eq {R : Type u_1} [comm_ring R] : ideal.is_jacobson R ↔ ∀ (P : ideal R), P.is_prime → P.jacobson = P
theorem matrix.right_inv_eq_left_inv {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {A B C : matrix n n α} (h : A.mul B = 1) (g : C.mul A = 1) : B = C
theorem inner_eq_norm_mul_iff_real {F : Type u_3} [inner_product_space ℝ F] {x y : F} : has_inner.inner x y = ∥x∥ * ∥y∥ ↔ ∥y∥ • x = ∥x∥ • y
theorem linear_map.mk_continuous_norm_le' {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →ₛₗ[σ₁₂] F) {C : ℝ} (h : ∀ (x : E), ∥⇑f x∥ ≤ C * ∥x∥) : ∥f.mk_continuous C h∥ ≤ linear_order.max C 0
theorem polynomial_functions.comap'_comp_right_alg_hom_Icc_homeo_I (a b : ℝ) (h : a < b) : (polynomial_functions unit_interval).comap' (continuous_map.comp_right_alg_hom ℝ (Icc_homeo_I a b h).symm.to_continuous_map) = polynomial_functions (set.Icc a b)
theorem is_add_group_hom.comp {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) {γ : Type u_1} [add_group γ] {g : β → γ} (hg : is_add_group_hom g) : is_add_group_hom (g ∘ f)
theorem euclidean_geometry.orthogonal_projection_vsub_orthogonal_projection {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ℝ P) [nonempty ↥s] [complete_space ↥(s.direction)] (p : P) : ⇑(orthogonal_projection s.direction) (p -ᵥ ↑(⇑(euclidean_geometry.orthogonal_projection s) p)) = 0
theorem tendsto_uniformly_on.uniform_cauchy_seq_on {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {s : set α} {p : filter ι} (hF : tendsto_uniformly_on F f p s) : uniform_cauchy_seq_on F p s
theorem generalized_continued_fraction.continuants_recurrence {K : Type u_1} {g : generalized_continued_fraction K} {n : ℕ} [division_ring K] {gp ppred pred : generalized_continued_fraction.pair K} (succ_nth_s_eq : g.s.nth (n + 1) = option.some gp) (nth_conts_eq : g.continuants n = ppred) (succ_nth_conts_eq : g.continuants (n + 1) = pred) : g.continuants (n + 2) = {a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b}
theorem list.ordered_insert_eq_take_drop {α : Type uu} (r : α → α → Prop) [decidable_rel r] (a : α) (l : list α) : list.ordered_insert r a l = list.take_while (λ (b : α), ¬r a b) l ++ a :: list.drop_while (λ (b : α), ¬r a b) l
theorem has_sbtw.sbtw.trans_right {α : Type u_1} [circular_preorder α] {a b c d : α} (hbc : has_sbtw.sbtw a b c) (hcd : has_sbtw.sbtw a c d) : has_sbtw.sbtw a b d
theorem Top.presheaf.is_sheaf_sites_iff_is_sheaf_opens_le_cover {C : Type u} [category_theory.category C] {X : Top} (F : Top.presheaf C X) : category_theory.presheaf.is_sheaf (opens.grothendieck_topology ↥X) F ↔ F.is_sheaf_opens_le_cover
theorem asymptotics.is_O.neg_right {α : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : α → E} {g' : α → F'} {l : filter α} : f =O[l] g' → (f =O[l] λ (x : α), -g' x)
theorem one_hom.congr_arg {M : Type u_3} {N : Type u_4} [has_one M] [has_one N] (f : one_hom M N) {x y : M} (h : x = y) : ⇑f x = ⇑f y
theorem uniform_embedding_of_spaced_out {β : Type u_2} [uniform_space β] {α : Type u_1} {f : α → β} {s : set (β × β)} (hs : s ∈ uniformity β) (hf : pairwise (λ (x y : α), (f x, f y) ∉ s)) : uniform_embedding f
theorem char.quadratic_char_card_sqrts {F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F ≠ 2) (a : F) : ↑({x : F | x ^ 2 = a}.to_finset.card) = char.quadratic_char F a + 1
theorem has_fderiv_at_exp_zero {𝕂 : Type u_1} {𝔸 : Type u_2} [is_R_or_C 𝕂] [normed_ring 𝔸] [normed_algebra 𝕂 𝔸] [complete_space 𝔸] : has_fderiv_at (exp 𝕂) 1 0
theorem algebra.discr_zero_of_not_linear_independent (A : Type u) {B : Type v} {ι : Type w} [comm_ring A] [comm_ring B] [algebra A B] [fintype ι] [is_domain A] {b : ι → B} (hli : ¬linear_independent A b) : algebra.discr A b = 0
theorem measure_theory.integral_integral_sub {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] ⦃f g : α × β → E⦄ (hf : measure_theory.integrable f (μ.prod ν)) (hg : measure_theory.integrable g (μ.prod ν)) : ∫ (x : α), ∫ (y : β), f (x, y) - g (x, y) ∂ν ∂μ = ∫ (x : α), ∫ (y : β), f (x, y) ∂ν ∂μ - ∫ (x : α), ∫ (y : β), g (x, y) ∂ν ∂μ
theorem equiv.apply_swap_eq_self {α : Sort u} {β : Sort v} [decidable_eq α] {v : α → β} {i j : α} (hv : v i = v j) (k : α) : v (⇑(equiv.swap i j) k) = v k
theorem contracting_with.efixed_point_eq_of_edist_lt_top' {α : Type u_1} [emetric_space α] {K : nnreal} {f : α → α} (hf : contracting_with K f) {s : set α} (hsc : is_complete s) (hsf : set.maps_to f s s) (hfs : contracting_with K (set.maps_to.restrict f s s hsf)) {x : α} (hxs : x ∈ s) (hx : has_edist.edist x (f x) ≠ ⊤) {t : set α} (htc : is_complete t) (htf : set.maps_to f t t) (hft : contracting_with K (set.maps_to.restrict f t t htf)) {y : α} (hyt : y ∈ t) (hy : has_edist.edist y (f y) ≠ ⊤) (hxy : has_edist.edist x y ≠ ⊤) : contracting_with.efixed_point' f hsc hsf hfs x hxs hx = contracting_with.efixed_point' f htc htf hft y hyt hy
theorem rescale_to_shell_semi_normed {α : Type u_1} [normed_field α] {E : Type u_5} [semi_normed_group E] [normed_space α E] {c : α} (hc : 1 < ∥c∥) {ε : ℝ} (εpos : 0 < ε) {x : E} (hx : ∥x∥ ≠ 0) : ∃ (d : α), d ≠ 0 ∧ ∥d • x∥ < ε ∧ ε / ∥c∥ ≤ ∥d • x∥ ∧ ∥d∥⁻¹ ≤ ε⁻¹ * ∥c∥ * ∥x∥
theorem convex_cone.pointed_positive_cone (𝕜 : Type u_1) (E : Type u_2) [ordered_semiring 𝕜] [ordered_add_comm_group E] [module 𝕜 E] [ordered_smul 𝕜 E] : (convex_cone.positive_cone 𝕜 E).pointed
theorem polynomial.rev_at_fun_eq (N i : ℕ) : polynomial.rev_at_fun N i = ⇑(polynomial.rev_at N) i
theorem measure_theory.nonempty_inter_of_measure_lt_add {α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) {s t u : set α} (ht : measurable_set t) (h's : s ⊆ u) (h't : t ⊆ u) (h : ⇑μ u < ⇑μ s + ⇑μ t) : (s ∩ t).nonempty
theorem finset.pimage_eq_image_filter {α : Type u_1} {β : Type u_2} [decidable_eq β] {f : α →. β} [Π (x : α), decidable (f x).dom] {s : finset α} : finset.pimage f s = finset.image (λ (x : {x // x ∈ finset.filter (λ (x : α), (f x).dom) s}), (f ↑x).get _) (finset.filter (λ (x : α), (f x).dom) s).attach
theorem list.length_split_wrt_composition {n : ℕ} {α : Type u_1} (l : list α) (c : composition n) : (l.split_wrt_composition c).length = c.length
theorem measure_theory.measure.add_haar_image_continuous_linear_equiv {E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (f : E ≃L[ℝ] E) (s : set E) : ⇑μ (⇑f '' s) = ennreal.of_real |⇑linear_map.det ↑f| * ⇑μ s
theorem supr_eq_supr_finset {α : Type u_1} {ι : Type u_4} [complete_lattice α] (s : ι → α) : (⨆ (i : ι), s i) = ⨆ (t : finset ι) (i : ι) (H : i ∈ t), s i
theorem ring_hom.map_list_sum {β : Type u} {γ : Type w} [non_assoc_semiring β] [non_assoc_semiring γ] (f : β →+* γ) (l : list β) : ⇑f l.sum = (list.map ⇑f l).sum
theorem affine_independent_iff_of_fintype (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} [fintype ι] (p : ι → P) : affine_independent k p ↔ ∀ (w : ι → k), finset.univ.sum (λ (i : ι), w i) = 0 → ⇑(finset.univ.weighted_vsub p) w = 0 → ∀ (i : ι), w i = 0
theorem first_order.language.embedding.comp_assoc {L : first_order.language} {M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] {P : Type u_1} [L.Structure P] {Q : Type u_2} [L.Structure Q] (f : L.embedding M N) (g : L.embedding N P) (h : L.embedding P Q) : (h.comp g).comp f = h.comp (g.comp f)
theorem mv_polynomial.esymm_eq_sum_subtype (σ : Type u_1) (R : Type u_2) [comm_semiring R] [fintype σ] (n : ℕ) : mv_polynomial.esymm σ R n = finset.univ.sum (λ (t : {s // s.card = n}), ↑t.prod (λ (i : σ), mv_polynomial.X i))
theorem finsupp.comap_domain_smul_of_injective {α : Type u_1} {β : Type u_2} {M : Type u_5} {R : Type u_11} [add_monoid M] [monoid R] [distrib_mul_action R M] {f : α → β} (hf : function.injective f) (r : R) (v : β →₀ M) : finsupp.comap_domain f (r • v) _ = r • finsupp.comap_domain f v _
theorem phragmen_lindelof.vertical_strip {E : Type u_1} [normed_group E] [normed_space ℂ E] {a b C : ℝ} {f : ℂ → E} {z : ℂ} (hfd : diff_cont_on_cl ℂ f (complex.re ⁻¹' set.Ioo a b)) (hB : ∃ (c : ℝ) (H : c < real.pi / (b - a)) (B : ℝ), f =O[filter.comap (has_abs.abs ∘ complex.im) filter.at_top ⊓ filter.principal (complex.re ⁻¹' set.Ioo a b)] λ (z : ℂ), real.exp (B * real.exp (c * |z.im|))) (hle_a : ∀ (z : ℂ), z.re = a → ∥f z∥ ≤ C) (hle_b : ∀ (z : ℂ), z.re = b → ∥f z∥ ≤ C) (hza : a ≤ z.re) (hzb : z.re ≤ b) : ∥f z∥ ≤ C
theorem lt_inv_mul_of_mul_lt {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : a * b < c → b < a⁻¹ * c
theorem has_ftaylor_series_up_to_on.has_fderiv_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {x : E} {n : with_top ℕ} {p : E → formal_multilinear_series 𝕜 E F} (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 ≤ n) (hx : s ∈ nhds x) : has_fderiv_at f (⇑(continuous_multilinear_curry_fin1 𝕜 E F) (p x 1)) x
theorem category_theory.presieve.is_separated_for.is_sheaf_for {C : Type u₁} [category_theory.category C] {P : Cᵒᵖ ⥤ Type w} {X : C} {R : category_theory.presieve X} (t : category_theory.presieve.is_separated_for P R) : (∀ (x : category_theory.presieve.family_of_elements P R), x.compatible → (∃ (t : P.obj (opposite.op X)), x.is_amalgamation t)) → category_theory.presieve.is_sheaf_for P R
theorem first_order.language.is_fraisse_limit.is_fraisse {L : first_order.language} (K : set (category_theory.bundled L.Structure)) {M : Type w} [L.Structure M] [L.countable_functions] (h : first_order.language.is_fraisse_limit K M) : first_order.language.is_fraisse K
theorem image_le_of_liminf_slope_right_lt_deriv_boundary' {f f' : ℝ → ℝ} {a b : ℝ} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → ∀ (r : ℝ), f' x < r → (∃ᶠ (z : ℝ) in nhds_within x (set.Ioi x), slope f x z < r)) {B B' : ℝ → ℝ} (ha : f a ≤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at B (B' x) (set.Ici x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → f x = B x → f' x < B' x) ⦃x : ℝ⦄ : x ∈ set.Icc a b → f x ≤ B x
theorem set.image_image2_distrib_right {α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {f : α → β → γ} {s : set α} {t : set β} {g : γ → δ} {f' : α → β' → δ} {g' : β → β'} (h_distrib : ∀ (a : α) (b : β), g (f a b) = f' a (g' b)) : g '' set.image2 f s t = set.image2 f' s (g' '' t)
theorem function.is_periodic_id {α : Type u_1} (n : ℕ) (x : α) : function.is_periodic_pt id n x
theorem right.add_neg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0
theorem balanced.hull_subset_of_subset {𝕜 : Type u_1} {E : Type u_2} [semi_normed_ring 𝕜] [has_scalar 𝕜 E] {s t : set E} (ht : balanced 𝕜 t) (h : s ⊆ t) : balanced_hull 𝕜 s ⊆ t
theorem direct_sum.is_internal_submodule_of_independent_of_supr_eq_top {R : Type u} [ring R] {ι : Type v} [dec_ι : decidable_eq ι] {M : Type u_1} [add_comm_group M] [module R M] {A : ι → submodule R M} (hi : complete_lattice.independent A) (hs : supr A = ⊤) : direct_sum.is_internal A
theorem tendsto_locally_uniformly_on.continuous_on {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {s : set α} {p : filter ι} [topological_space α] (h : tendsto_locally_uniformly_on F f p s) (hc : ∀ᶠ (n : ι) in p, continuous_on (F n) s) [p.ne_bot] : continuous_on f s
theorem fourier_series_repr (f : ↥(measure_theory.Lp ℂ 2 haar_circle)) (i : ℤ) : ⇑(⇑(fourier_series.repr) f) i = ∫ (t : ↥circle), ↑t ^ -i * ⇑f t ∂haar_circle
theorem map_cInf_of_continuous_at_of_monotone {α : Type u} {β : Type v} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [conditionally_complete_linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} (Cf : continuous_at f (has_Inf.Inf s)) (Mf : monotone f) (ne : s.nonempty) (H : bdd_below s) : f (has_Inf.Inf s) = has_Inf.Inf (f '' s)
theorem basis.orientation_eq_or_eq_neg {R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {ι : Type u_3} [decidable_eq ι] [fintype ι] (e : basis ι R M) (x : orientation R M ι) : x = e.orientation ∨ x = -e.orientation
theorem uniform_space.completion.uniform_continuous_dist {α : Type u} [pseudo_metric_space α] : uniform_continuous (λ (p : uniform_space.completion α × uniform_space.completion α), has_dist.dist p.fst p.snd)
theorem continuous_map.homotopy.apply_zero_path {X Y : Top} {f g : C(↥X, ↥Y)} (H : f.homotopy g) {x₀ x₁ : ↥X} (p : fundamental_groupoid.from_top x₀ ⟶ fundamental_groupoid.from_top x₁) : (fundamental_groupoid.fundamental_groupoid_functor.map f).map p = continuous_map.homotopy.hcast _ ≫ (fundamental_groupoid.fundamental_groupoid_functor.map H.ulift_map).map (continuous_map.homotopy.prod_to_prod_Top_I (𝟙 {down := 0}) p) ≫ continuous_map.homotopy.hcast _
theorem convex_independent_iff_not_mem_convex_hull_diff {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] {p : ι → E} : convex_independent 𝕜 p ↔ ∀ (i : ι) (s : set ι), p i ∉ ⇑(convex_hull 𝕜) (p '' (s  {i}))
theorem matrix.det_mul_left_comm {m : Type u_1} [decidable_eq m] [fintype m] {R : Type v} [comm_ring R] (M N P : matrix m m R) : (M.mul (N.mul P)).det = (N.mul (M.mul P)).det
theorem add_submonoid.multiset_sum_mem {M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) (m : multiset M) (hm : ∀ (a : M), a ∈ m → a ∈ S) : m.sum ∈ S
theorem orthogonal_projection_fn_mem {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K : submodule 𝕜 E} [complete_space ↥K] (v : E) : orthogonal_projection_fn K v ∈ K
theorem gold_conj_irrational  : irrational golden_conj
theorem exterior_algebra.induction {R : Type u1} [comm_semiring R] {M : Type u2} [add_comm_monoid M] [module R M] {C : exterior_algebra R M → Prop} (h_grade0 : ∀ (r : R), C (⇑(algebra_map R (exterior_algebra R M)) r)) (h_grade1 : ∀ (x : M), C (⇑(exterior_algebra.ι R) x)) (h_mul : ∀ (a b : exterior_algebra R M), C a → C b → C (a * b)) (h_add : ∀ (a b : exterior_algebra R M), C a → C b → C (a + b)) (a : exterior_algebra R M) : C a
theorem finset.le_sum_nonempty_of_subadditive_on_pred {ι : Type u_1} {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [ordered_add_comm_monoid N] (f : M → N) (p : M → Prop) (h_mul : ∀ (x y : M), p x → p y → f (x + y) ≤ f x + f y) (hp_mul : ∀ (x y : M), p x → p y → p (x + y)) (g : ι → M) (s : finset ι) (hs_nonempty : s.nonempty) (hs : ∀ (i : ι), i ∈ s → p (g i)) : f (s.sum (λ (i : ι), g i)) ≤ s.sum (λ (i : ι), f (g i))
theorem category_theory.is_cofiltered.inf_exists {C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] (O : finset C) (H : finset (Σ' (X Y : C) (mX : X ∈ O) (mY : Y ∈ O), X ⟶ Y)) : ∃ (S : C) (T : Π {X : C}, X ∈ O → (S ⟶ X)), ∀ {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f : X ⟶ Y}, ⟨X, ⟨Y, ⟨mX, ⟨mY, f⟩⟩⟩⟩ ∈ H → T mX ≫ f = T mY
theorem submodule.is_internal_prime_power_torsion {R : Type u} [comm_ring R] [is_domain R] {M : Type v} [add_comm_group M] [module R M] [is_dedekind_domain R] [module.finite R M] (hM : module.is_torsion R M) : ∃ (P : finset (ideal R)) [_inst_7 : decidable_eq ↥P] [_inst_8 : ∀ (p : ideal R), p ∈ P → prime p] (e : ↥P → ℕ), direct_sum.is_internal (λ (p : ↥P), submodule.torsion_by_set R M ↑(↑p ^ e p))
theorem image_circle_map_Ioc (c : ℂ) (R : ℝ) : circle_map c R '' set.Ioc 0 (2 * real.pi) = metric.sphere c |R|
theorem real.has_sum_pow_div_log_of_abs_lt_1 {x : ℝ} (h : |x| < 1) : has_sum (λ (n : ℕ), x ^ (n + 1) / (↑n + 1)) (-real.log (1 - x))
theorem nat.coprime_factors_disjoint {a b : ℕ} (hab : a.coprime b) : a.factors.disjoint b.factors
theorem add_is_torsion_free.quotient_torsion (G : Type u_1) [add_comm_group G] : add_monoid.is_torsion_free (G ⧸ add_torsion G)
theorem finsupp.lt_wf (ι : Type u_3) : well_founded has_lt.lt
theorem dense_inducing.extend_Z_bilin {α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} {G : Type u_5} [topological_space α] [add_comm_group α] [topological_add_group α] [topological_space β] [add_comm_group β] [topological_add_group β] [topological_space γ] [add_comm_group γ] [topological_add_group γ] [topological_space δ] [add_comm_group δ] [topological_add_group δ] [uniform_space G] [add_comm_group G] [uniform_add_group G] [separated_space G] [complete_space G] {e : β →+ α} (de : dense_inducing ⇑e) {f : δ →+ γ} (df : dense_inducing ⇑f) {φ : β →+ δ →+ G} (hφ : continuous (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd)) : continuous (_.extend (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd))
theorem dim_add_dim_split {K : Type u} {V V₁ V₂ V₃ : Type v} [field K] [add_comm_group V] [module K V] [add_comm_group V₁] [module K V₁] [add_comm_group V₂] [module K V₂] [add_comm_group V₃] [module K V₃] (db : V₂ →ₗ[K] V) (eb : V₃ →ₗ[K] V) (cd : V₁ →ₗ[K] V₂) (ce : V₁ →ₗ[K] V₃) (hde : ⊤ ≤ db.range ⊔ eb.range) (hgd : cd.ker = ⊥) (eq : db.comp cd = eb.comp ce) (eq₂ : ∀ (d : V₂) (e : V₃), ⇑db d = ⇑eb e → (∃ (c : V₁), ⇑cd c = d ∧ ⇑ce c = e)) : module.rank K V + module.rank K V₁ = module.rank K V₂ + module.rank K V₃
theorem is_local_min_on.fderiv_within_nonneg {E : Type u} [normed_group E] [normed_space ℝ E] {f : E → ℝ} {a : E} {s : set E} (h : is_local_min_on f s a) {y : E} (hy : y ∈ pos_tangent_cone_at s a) : 0 ≤ ⇑(fderiv_within ℝ f s a) y
theorem category_theory.congr_hom {C : Type v} [category_theory.category C] [category_theory.concrete_category C] {X Y : C} {f g : X ⟶ Y} (h : f = g) (x : ↥X) : ⇑f x = ⇑g x
theorem ennreal.rpow_arith_mean_le_arith_mean_rpow {ι : Type u} (s : finset ι) (w z : ι → ennreal) (hw' : s.sum (λ (i : ι), w i) = 1) {p : ℝ} (hp : 1 ≤ p) : s.sum (λ (i : ι), w i * z i) ^ p ≤ s.sum (λ (i : ι), w i * z i ^ p)
theorem finite_dimensional.nonempty_linear_equiv_iff_finrank_eq {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {V₂ : Type v'} [add_comm_group V₂] [module K V₂] [finite_dimensional K V] [finite_dimensional K V₂] : nonempty (V ≃ₗ[K] V₂) ↔ finite_dimensional.finrank K V = finite_dimensional.finrank K V₂
theorem int.gcd_least_linear {a b : ℤ} (ha : a ≠ 0) : is_least {n : ℕ | 0 < n ∧ ∃ (x y : ℤ), ↑n = a * x + b * y} (a.gcd b)
theorem zero_lt.right.one_lt_mul_of_lt_of_le {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 1 < a) (hb : 1 ≤ b) (b0 : 0 < b) : 1 < a * b
theorem Gromov_Hausdorff.Hausdorff_dist_optimal_le_HD (X : Type u) (Y : Type v) [metric_space X] [compact_space X] [nonempty X] [metric_space Y] [compact_space Y] [nonempty Y] {f : Cb X Y} (h : f ∈ candidates_b X Y) : metric.Hausdorff_dist (set.range (Gromov_Hausdorff.optimal_GH_injl X Y)) (set.range (Gromov_Hausdorff.optimal_GH_injr X Y)) ≤ Gromov_Hausdorff.HD f
theorem antisymm_rel.eq {α : Type u_1} {r : α → α → Prop} [is_refl α r] [is_antisymm α r] {a b : α} : antisymm_rel r a b → a = b
theorem continuous_linear_map.eq_adjoint_iff {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [inner_product_space 𝕜 F] [complete_space E] [complete_space F] (A : E →L[𝕜] F) (B : F →L[𝕜] E) : A = ⇑continuous_linear_map.adjoint B ↔ ∀ (x : E) (y : F), has_inner.inner (⇑A x) y = has_inner.inner x (⇑B y)
theorem asymptotics.is_O_with.of_norm_right {α : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {c : ℝ} {f : α → E} {g' : α → F'} {l : filter α} : asymptotics.is_O_with c l f (λ (x : α), ∥g' x∥) → asymptotics.is_O_with c l f g'
theorem polynomial.exists_partition_polynomial {Fq : Type u_1} [fintype Fq] [field Fq] (n : ℕ) {ε : ℝ} (hε : 0 < ε) {b : polynomial Fq} (hb : b ≠ 0) (A : fin n → polynomial Fq) : ∃ (t : fin n → fin (fintype.card Fq ^ ⌈-real.log ε / real.log ↑(fintype.card Fq)⌉₊)), ∀ (i₀ i₁ : fin n), t i₀ = t i₁ → ↑(⇑polynomial.card_pow_degree (A i₁ % b - A i₀ % b)) < ⇑polynomial.card_pow_degree b • ε
theorem monoid_hom.map_list_prod {M : Type u_3} {N : Type u_4} [monoid M] [monoid N] (f : M →* N) (l : list M) : ⇑f l.prod = (list.map ⇑f l).prod
theorem fin.coe_fin_le {n : ℕ} {a b : fin n} : ↑a ≤ ↑b ↔ a ≤ b
theorem is_atom.bot_covby {α : Type u_1} [partial_order α] [order_bot α] {a : α} : is_atom a → ⊥ ⋖ a
theorem pred_lt_pred {α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α] : a < b → order.pred a < order.pred b
theorem generalized_continued_fraction.of_h_eq_floor {K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} : (generalized_continued_fraction.of v).h = ↑⌊v⌋
theorem category_theory.limits.has_zero_morphisms.ext {C : Type u} [category_theory.category C] (I J : category_theory.limits.has_zero_morphisms C) : I = J
theorem padic_seq.stationary {p : ℕ} [fact (nat.prime p)] {f : cau_seq ℚ (padic_norm p)} (hf : ¬f ≈ 0) : ∃ (N : ℕ), ∀ (m n : ℕ), N ≤ m → N ≤ n → padic_norm p (⇑f n) = padic_norm p (⇑f m)
theorem power_series.nat_le_order {R : Type u_1} [semiring R] (φ : power_series R) (n : ℕ) (h : ∀ (i : ℕ), i < n → ⇑(power_series.coeff R i) φ = 0) : ↑n ≤ φ.order
theorem measure_theory.measure_of_cont_bdd_of_tendsto_filter_indicator {α : Type u_1} [measurable_space α] {ι : Type u_2} {L : filter ι} [L.is_countably_generated] [topological_space α] [opens_measurable_space α] (μ : measure_theory.finite_measure α) {c : nnreal} {E : set α} (E_mble : measurable_set E) (fs : ι → bounded_continuous_function α nnreal) (fs_bdd : ∀ᶠ (i : ι) in L, ∀ᵐ (a : α) ∂↑μ, ⇑(fs i) a ≤ c) (fs_lim : ∀ᵐ (a : α) ∂↑μ, filter.tendsto (λ (i : ι), ⇑(fs i) a) L (nhds (E.indicator (λ (x : α), 1) a))) : filter.tendsto (λ (n : ι), ∫⁻ (a : α), ↑(⇑(fs n) a) ∂↑μ) L (nhds (⇑↑μ E))
theorem krull_topology_totally_disconnected {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (h_int : algebra.is_integral K L) : is_totally_disconnected set.univ
theorem category_theory.limits.cocones.cocone_iso_of_hom_iso {J : Type u₁} [category_theory.category J] {C : Type u₃} [category_theory.category C] {K : J ⥤ C} {c d : category_theory.limits.cocone K} (f : c ⟶ d) [i : category_theory.is_iso f.hom] : category_theory.is_iso f
theorem is_of_fin_order_zero {G : Type u} [add_monoid G] : is_of_fin_add_order 0
theorem set_has_maximal_iff_noetherian {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] : (∀ (a : set (submodule R M)), a.nonempty → (∃ (M' : submodule R M) (H : M' ∈ a), ∀ (I : submodule R M), I ∈ a → M' ≤ I → I = M')) ↔ is_noetherian R M
theorem is_add_left_regular.add {R : Type u_1} {a b : R} [add_semigroup R] (lra : is_add_left_regular a) (lrb : is_add_left_regular b) : is_add_left_regular (a + b)
theorem orthonormal.two_zsmul_oangle_smul_left_of_ne_zero {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x y : V) {r : ℝ} (hr : r ≠ 0) : 2 • hb.oangle (r • x) y = 2 • hb.oangle x y
theorem measure_theory.measure_eq_infi' {α : Type u_1} [measurable_space α] (μ : measure_theory.measure α) (s : set α) : ⇑μ s = ⨅ (t : {t // s ⊆ t ∧ measurable_set t}), ⇑μ ↑t
theorem euclidean_geometry.orthocentric_system.eq_insert_orthocenter {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : set P} (ho : euclidean_geometry.orthocentric_system s) {t : affine.triangle ℝ P} (ht : set.range t.points ⊆ s) : s = has_insert.insert t.orthocenter (set.range t.points)
theorem add_equiv.map_sub {G : Type u_10} {H : Type u_11} [add_group G] [subtraction_monoid H] (h : G ≃+ H) (x y : G) : ⇑h (x - y) = ⇑h x - ⇑h y
theorem matrix.adjugate_adjugate' {n : Type u} [decidable_eq n] [fintype n] {α : Type v} [comm_ring α] (A : matrix n n α) [nontrivial n] : A.adjugate.adjugate = A.det ^ (fintype.card n - 2) • A
theorem ordered_comm_group.lt_of_mul_lt_mul_left {α : Type u_1} [has_mul α] [has_lt α] [contravariant_class α α has_mul.mul has_lt.lt] {a b c : α} (bc : a * b < a * c) : b < c
theorem cont_diff_iff_iterated_deriv {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {n : with_top ℕ} : cont_diff 𝕜 n f ↔ (∀ (m : ℕ), ↑m ≤ n → continuous (iterated_deriv m f)) ∧ ∀ (m : ℕ), ↑m < n → differentiable 𝕜 (iterated_deriv m f)
theorem measure_theory.Lp.bounded_continuous_function_dense {α : Type u_1} [measurable_space α] [topological_space α] [normal_space α] [borel_space α] (E : Type u_2) [normed_group E] [second_countable_topology_either α E] {p : ennreal} [fact (1 ≤ p)] (hp : p ≠ ⊤) (μ : measure_theory.measure α) [normed_space ℝ E] [μ.weakly_regular] : (measure_theory.Lp.bounded_continuous_function E p μ).topological_closure = ⊤
theorem polynomial.X_mul_C {R : Type u} [semiring R] (r : R) : polynomial.X * ⇑polynomial.C r = ⇑polynomial.C r * polynomial.X
theorem category_theory.ProjectiveResolution.lift_commutes {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] {Y Z : C} (f : Y ⟶ Z) (P : category_theory.ProjectiveResolution Y) (Q : category_theory.ProjectiveResolution Z) : category_theory.ProjectiveResolution.lift f P Q ≫ Q.π = P.π ≫ (chain_complex.single₀ C).map f
theorem setoid.sup_def {α : Type u_1} {r s : setoid α} : r ⊔ s = eqv_gen.setoid (r.rel ⊔ s.rel)
theorem lipschitz_with.norm_sub_le {E : Type u_3} {F : Type u_4} [semi_normed_group E] [semi_normed_group F] {f : E → F} {C : nnreal} : lipschitz_with C f → ∀ (x y : E), ∥f x - f y∥ ≤ ↑C * ∥x - y∥
theorem smooth_smul {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {V : Type u_14} [normed_group V] [normed_space 𝕜 V] : smooth ((model_with_corners_self 𝕜 𝕜).prod (model_with_corners_self 𝕜 V)) (model_with_corners_self 𝕜 V) (λ (p : 𝕜 × V), p.fst • p.snd)
theorem ordinal.induction {p : ordinal → Prop} (i : ordinal) (h : ∀ (j : ordinal), (∀ (k : ordinal), k < j → p k) → p j) : p i
theorem norm_sub_sq_real {F : Type u_3} [inner_product_space ℝ F] {x y : F} : ∥x - y∥ ^ 2 = ∥x∥ ^ 2 - 2 * has_inner.inner x y + ∥y∥ ^ 2
theorem real.sinh_injective  : function.injective real.sinh
theorem category_theory.cover_preserving.comp {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {A : Type u₃} [category_theory.category A] (J : category_theory.grothendieck_topology C) (K : category_theory.grothendieck_topology D) {L : category_theory.grothendieck_topology A} {F : C ⥤ D} (hF : category_theory.cover_preserving J K F) {G : D ⥤ A} (hG : category_theory.cover_preserving K L G) : category_theory.cover_preserving J L (F ⋙ G)
theorem probability_theory.cond_add_cond_compl_eq {α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) {s t : set α} [measure_theory.is_finite_measure μ] (hms : measurable_set s) (hcs : ⇑μ s ≠ 0) (hcs' : ⇑μ sᶜ ≠ 0) : ⇑(probability_theory.cond μ s) t * ⇑μ s + ⇑(probability_theory.cond μ sᶜ) t * ⇑μ sᶜ = ⇑μ t
theorem strict_convex_on.translate_right {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_cancel_comm_monoid E] [ordered_add_comm_monoid β] [module 𝕜 E] [has_scalar 𝕜 β] {s : set E} {f : E → β} (hf : strict_convex_on 𝕜 s f) (c : E) : strict_convex_on 𝕜 ((λ (z : E), c + z) ⁻¹' s) (f ∘ λ (z : E), c + z)
theorem right.neg_pos_iff {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a : α} : 0 < -a ↔ a < 0
theorem mem_uniformity_edist {α : Type u} [pseudo_emetric_space α] {s : set (α × α)} : s ∈ uniformity α ↔ ∃ (ε : ennreal) (H : ε > 0), ∀ {a b : α}, has_edist.edist a b < ε → (a, b) ∈ s
theorem con.inv {M : Type u_1} [group M] (c : con M) {w x : M} : ⇑c w x → ⇑c w⁻¹ x⁻¹
theorem clifford_algebra.involute_prod_map_ι {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Q : quadratic_form R M} (l : list M) : ⇑clifford_algebra.involute (list.map ⇑(clifford_algebra.ι Q) l).prod = (-1) ^ l.length • (list.map ⇑(clifford_algebra.ι Q) l).prod
theorem is_preirreducible_iff_closed_union_closed {α : Type u} [topological_space α] {s : set α} : is_preirreducible s ↔ ∀ (z₁ z₂ : set α), is_closed z₁ → is_closed z₂ → s ⊆ z₁ ∪ z₂ → s ⊆ z₁ ∨ s ⊆ z₂
theorem submodule.map_subtype_top {R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] (p : submodule R M) : submodule.map p.subtype ⊤ = p
theorem surjective_quotient_mk (α : Sort u_1) [s : setoid α] : function.surjective quotient.mk
theorem add_monoid_hom.mrange_top_of_surjective {M : Type u_1} [add_zero_class M] {N : Type u_2} [add_zero_class N] (f : M →+ N) (hf : function.surjective ⇑f) : f.mrange = ⊤
theorem complex.differentiable_on_update_lim_of_is_o {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] {f : ℂ → E} {s : set ℂ} {c : ℂ} (hc : s ∈ nhds c) (hd : differentiable_on ℂ f (s  {c})) (ho : (λ (z : ℂ), f z - f c) =o[nhds_within c {c}ᶜ] λ (z : ℂ), (z - c)⁻¹) : differentiable_on ℂ (function.update f c (lim (nhds_within c {c}ᶜ) f)) s
theorem matrix.adjugate_adjugate {n : Type u} [decidable_eq n] [fintype n] {α : Type v} [comm_ring α] (A : matrix n n α) (h : fintype.card n ≠ 1) : A.adjugate.adjugate = A.det ^ (fintype.card n - 2) • A
theorem integral_sin_pow {a b : ℝ} (n : ℕ) : ∫ (x : ℝ) in a..b, real.sin x ^ (n + 2) = (real.sin a ^ (n + 1) * real.cos a - real.sin b ^ (n + 1) * real.cos b) / (↑n + 2) + (↑n + 1) / (↑n + 2) * ∫ (x : ℝ) in a..b, real.sin x ^ n
theorem affine.simplex.direction_altitude {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P (n + 1)) (i : fin (n + 2)) : (s.altitude i).direction = (vector_span ℝ (s.points '' ↑(finset.univ.erase i)))ᗮ ⊓ vector_span ℝ (set.range s.points)
theorem complete_lattice.independent_iff_dfinsupp_lsum_injective {ι : Type u_1} {R : Type u_2} {N : Type u_5} [dec_ι : decidable_eq ι] [ring R] [add_comm_group N] [module R N] (p : ι → submodule R N) : complete_lattice.independent p ↔ function.injective ⇑(⇑(dfinsupp.lsum ℕ) (λ (i : ι), (p i).subtype))
theorem nat.multiplicative_factorization {β : Type u_1} [comm_monoid β] (f : ℕ → β) (h_mult : ∀ (x y : ℕ), x.coprime y → f (x * y) = f x * f y) (hf : f 1 = 1) {n : ℕ} : n ≠ 0 → f n = n.factorization.prod (λ (p k : ℕ), f (p ^ k))
theorem order.pfilter.top_mem {P : Type u_1} [preorder P] [order_top P] {F : order.pfilter P} : ⊤ ∈ F
theorem group.normal_closure_subset {G : Type u_1} [group G] {s t : set G} (ht : is_normal_subgroup t) (h : s ⊆ t) : group.normal_closure s ⊆ t
theorem has_ftaylor_series_up_to_succ_iff_right {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {p : E → formal_multilinear_series 𝕜 E F} {n : ℕ} : has_ftaylor_series_up_to ↑(n + 1) f p ↔ (∀ (x : E), (p x 0).uncurry0 = f x) ∧ (∀ (x : E), has_fderiv_at (λ (y : E), p y 0) (p x 1).curry_left x) ∧ has_ftaylor_series_up_to ↑n (λ (x : E), ⇑(continuous_multilinear_curry_fin1 𝕜 E F) (p x 1)) (λ (x : E), (p x).shift)
theorem subsingleton_floor_semiring {α : Type u_1} [linear_ordered_semiring α] : subsingleton (floor_semiring α)
theorem add_con.lift_unique {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} {f : M →+ P} (H : c ≤ add_con.ker f) (g : c.quotient →+ P) (Hg : g.comp c.mk' = f) : g = c.lift f H
theorem nnreal.has_sum_geometric {r : nnreal} (hr : r < 1) : has_sum (λ (n : ℕ), r ^ n) (1 - r)⁻¹
theorem smooth_partition_of_unity.is_subordinate.to_partition_of_unity {ι : Type uι} {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} {f : smooth_partition_of_unity ι I M s} {U : ι → set M} : f.is_subordinate U → f.to_partition_of_unity.is_subordinate U
theorem finset.prod_add_ordered {ι : Type u_1} {R : Type u_2} [comm_semiring R] [linear_order ι] (s : finset ι) (f g : ι → R) : s.prod (λ (i : ι), f i + g i) = s.prod (λ (i : ι), f i) + s.sum (λ (i : ι), g i * (finset.filter (λ (_x : ι), _x < i) s).prod (λ (j : ι), f j + g j) * (finset.filter (λ (j : ι), i < j) s).prod (λ (j : ι), f j))
theorem emetric.complete_of_cauchy_seq_tendsto {α : Type u} [pseudo_emetric_space α] : (∀ (u : ℕ → α), cauchy_seq u → (∃ (a : α), filter.tendsto u filter.at_top (nhds a))) → complete_space α
theorem metric.thickening_mono {α : Type u} [pseudo_emetric_space α] {δ₁ δ₂ : ℝ} (hle : δ₁ ≤ δ₂) (E : set α) : metric.thickening δ₁ E ⊆ metric.thickening δ₂ E
theorem polynomial.coprime_of_root_cyclotomic {n : ℕ} (hpos : 0 < n) {p : ℕ} [hprime : fact (nat.prime p)] {a : ℕ} (hroot : (polynomial.cyclotomic n (zmod p)).is_root (⇑(nat.cast_ring_hom (zmod p)) a)) : a.coprime p
theorem matrix.is_symm.ext {α : Type u_1} {n : Type u_3} {A : matrix n n α} : (∀ (i j : n), A j i = A i j) → A.is_symm
theorem emetric.tendsto_uniformly_on_iff {α : Type u} {β : Type v} [pseudo_emetric_space α] {ι : Type u_1} {F : ι → β → α} {f : β → α} {p : filter ι} {s : set β} : tendsto_uniformly_on F f p s ↔ ∀ (ε : ennreal), ε > 0 → (∀ᶠ (n : ι) in p, ∀ (x : β), x ∈ s → has_edist.edist (f x) (F n x) < ε)
theorem ODE_solution_unique_of_mem_set {E : Type u_1} [normed_group E] [normed_space ℝ E] {v : ℝ → E → E} {s : ℝ → set E} {K : ℝ} (hv : ∀ (t : ℝ) (x : E), x ∈ s t → ∀ (y : E), y ∈ s t → has_dist.dist (v t x) (v t y) ≤ K * has_dist.dist x y) {f g : ℝ → E} {a b : ℝ} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (t : ℝ), t ∈ set.Ico a b → has_deriv_within_at f (v t (f t)) (set.Ici t) t) (hfs : ∀ (t : ℝ), t ∈ set.Ico a b → f t ∈ s t) (hg : continuous_on g (set.Icc a b)) (hg' : ∀ (t : ℝ), t ∈ set.Ico a b → has_deriv_within_at g (v t (g t)) (set.Ici t) t) (hgs : ∀ (t : ℝ), t ∈ set.Ico a b → g t ∈ s t) (ha : f a = g a) (t : ℝ) (H : t ∈ set.Icc a b) : f t = g t
theorem category_theory.hom_orthogonal.equiv_of_iso {C : Type u} [category_theory.category C] {ι : Type u_1} {s : ι → C} [category_theory.preadditive C] [category_theory.limits.has_finite_biproducts C] [∀ (i : ι), invariant_basis_number (category_theory.End (s i))] (o : category_theory.hom_orthogonal s) {α β : Type v} [fintype α] [fintype β] {f : α → ι} {g : β → ι} (i : (⨁ λ (a : α), s (f a)) ≅ ⨁ λ (b : β), s (g b)) : ∃ (e : α ≃ β), ∀ (a : α), g (⇑e a) = f a
theorem category_theory.presieve.family_of_elements.compatible.restrict {C : Type u₁} [category_theory.category C] {P : Cᵒᵖ ⥤ Type w} {X : C} {R₁ R₂ : category_theory.presieve X} (h : R₁ ≤ R₂) {x : category_theory.presieve.family_of_elements P R₂} : x.compatible → (category_theory.presieve.family_of_elements.restrict h x).compatible
theorem filter.map_map₂_distrib_left {α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {m : α → β → γ} {f : filter α} {g : filter β} {n : γ → δ} {m' : α' → β → δ} {n' : α → α'} (h_distrib : ∀ (a : α) (b : β), n (m a b) = m' (n' a) b) : filter.map n (filter.map₂ m f g) = filter.map₂ m' (filter.map n' f) g
theorem finset.sum_range_id_mul_two (n : ℕ) : (finset.range n).sum (λ (i : ℕ), i) * 2 = n * (n - 1)
theorem finset.le_prod_nonempty_of_submultiplicative {ι : Type u_1} {M : Type u_4} {N : Type u_5} [comm_monoid M] [ordered_comm_monoid N] (f : M → N) (h_mul : ∀ (x y : M), f (x * y) ≤ f x * f y) {s : finset ι} (hs : s.nonempty) (g : ι → M) : f (s.prod (λ (i : ι), g i)) ≤ s.prod (λ (i : ι), f (g i))
theorem has_ssubset.ssubset.trans {α : Type u} [has_ssubset α] [is_trans α has_ssubset.ssubset] {a b c : α} : a ⊂ b → b ⊂ c → a ⊂ c
theorem real.has_strict_fderiv_at_rpow_of_neg (p : ℝ × ℝ) (hp : p.fst < 0) : has_strict_fderiv_at (λ (x : ℝ × ℝ), x.fst ^ x.snd) ((p.snd * p.fst ^ (p.snd - 1)) • continuous_linear_map.fst ℝ ℝ ℝ + (p.fst ^ p.snd * real.log p.fst - real.exp (real.log p.fst * p.snd) * real.sin (p.snd * real.pi) * real.pi) • continuous_linear_map.snd ℝ ℝ ℝ) p
theorem monotone_stabilizes_iff_noetherian {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] : (∀ (f : ℕ →o submodule R M), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m) ↔ is_noetherian R M
theorem commute.refl {S : Type u_1} [has_mul S] (a : S) : commute a a
theorem category_theory.congr_arg_mpr_hom_left {C : Type u₁} [category_theory.category C] {X Y Z : C} (p : X = Y) (q : Y ⟶ Z) : _.mpr q = category_theory.eq_to_hom p ≫ q
theorem right.neg_neg_iff {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a : α} : -a < 0 ↔ 0 < a
theorem alexandroff.dense_range_coe {X : Type u_1} [topological_space X] [noncompact_space X] : dense_range coe
theorem convex_on.map_center_mass_le {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} {ι : Type u_5} [linear_ordered_field 𝕜] [add_comm_group E] [ordered_add_comm_group β] [module 𝕜 E] [module 𝕜 β] [ordered_smul 𝕜 β] {s : set E} {f : E → β} {t : finset ι} {w : ι → 𝕜} {p : ι → E} (hf : convex_on 𝕜 s f) (h₀ : ∀ (i : ι), i ∈ t → 0 ≤ w i) (h₁ : 0 < t.sum (λ (i : ι), w i)) (hmem : ∀ (i : ι), i ∈ t → p i ∈ s) : f (t.center_mass w p) ≤ t.center_mass w (f ∘ p)
theorem orthonormal.oangle_conj_lie {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x y : V) : hb.oangle (⇑(hb.conj_lie) x) (⇑(hb.conj_lie) y) = -hb.oangle x y
theorem generalized_continued_fraction.nth_of_eq_some_of_nth_int_fract_pair_stream_fr_ne_zero {K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} {n : ℕ} {ifp_n : generalized_continued_fraction.int_fract_pair K} (stream_nth_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) (nth_fr_ne_zero : ifp_n.fr ≠ 0) : (generalized_continued_fraction.of v).s.nth n = option.some {a := 1, b := ↑((generalized_continued_fraction.int_fract_pair.of (ifp_n.fr)⁻¹).b)}
theorem affine.triangle.orthocenter_mem_altitude {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle ℝ P) {i₁ : fin 3} : t.orthocenter ∈ affine.simplex.altitude t i₁
theorem dvd_neg {α : Type u} [semigroup α] [has_distrib_neg α] (a b : α) : a ∣ -b ↔ a ∣ b
theorem euclidean_geometry.angle_eq_zero_of_angle_eq_pi_left {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : euclidean_geometry.angle p1 p2 p3 = real.pi) : euclidean_geometry.angle p2 p1 p3 = 0
theorem topological_add_group.path_connected {E : Type u_2} [add_comm_group E] [module ℝ E] [topological_space E] [topological_add_group E] [has_continuous_smul ℝ E] : path_connected_space E
theorem add_neg_of_neg_of_nonpos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b ≤ 0) : a + b < 0
theorem same_ray_iff_inv_norm_smul_eq_of_ne {F : Type u_2} [normed_group F] [normed_space ℝ F] {x y : F} (hx : x ≠ 0) (hy : y ≠ 0) : same_ray ℝ x y ↔ ∥x∥⁻¹ • x = ∥y∥⁻¹ • y
theorem same_ray.trans {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y z : M} (hxy : same_ray R x y) (hyz : same_ray R y z) (hy : y = 0 → x = 0 ∨ z = 0) : same_ray R x z
theorem unique_topology_of_t2 {𝕜 : Type u} [hnorm : nondiscrete_normed_field 𝕜] {t : topological_space 𝕜} (h₁ : topological_add_group 𝕜) (h₂ : has_continuous_smul 𝕜 𝕜) (h₃ : t2_space 𝕜) : t = uniform_space.to_topological_space
theorem infi_and' {α : Type u_1} [complete_lattice α] {p q : Prop} {s : p → q → α} : (⨅ (h₁ : p) (h₂ : q), s h₁ h₂) = ⨅ (h : p ∧ q), s _ _
theorem ring_hom.map_list_prod {β : Type u} {γ : Type w} [semiring β] [semiring γ] (f : β →+* γ) (l : list β) : ⇑f l.prod = (list.map ⇑f l).prod
theorem add_con.sub {M : Type u_1} [add_group M] (c : add_con M) {w x y z : M} : ⇑c w x → ⇑c y z → ⇑c (w - y) (x - z)
theorem polynomial.degree_pos_induction_on {R : Type u} [semiring R] {P : polynomial R → Prop} (p : polynomial R) (h0 : 0 < p.degree) (hC : ∀ {a : R}, a ≠ 0 → P (⇑polynomial.C a * polynomial.X)) (hX : ∀ {p : polynomial R}, 0 < p.degree → P p → P (p * polynomial.X)) (hadd : ∀ {p : polynomial R} {a : R}, 0 < p.degree → P p → P (p + ⇑polynomial.C a)) : P p
theorem ae_eq_const_or_norm_integral_lt_of_norm_le_const {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {f : α → E} {C : ℝ} [strict_convex_space ℝ E] [measure_theory.is_finite_measure μ] (h_le : ∀ᵐ (x : α) ∂μ, ∥f x∥ ≤ C) : f =ᵐ[μ] function.const α (⨍ (x : α), f x ∂μ) ∨ ∥∫ (x : α), f x ∂μ∥ < (⇑μ set.univ).to_real * C
theorem seq.terminated_stable {α : Type u} (s : seq α) {m n : ℕ} (m_le_n : m ≤ n) (terminated_at_m : s.terminated_at m) : s.terminated_at n
theorem add_salem_spencer.le_roth_number_nat {k n : ℕ} (s : finset ℕ) (hs : add_salem_spencer ↑s) (hsn : ∀ (x : ℕ), x ∈ s → x < n) (hsk : s.card = k) : k ≤ ⇑roth_number_nat n
theorem strict_anti_on.dual_left {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s : set α} : strict_anti_on f s → strict_mono_on (f ∘ ⇑order_dual.of_dual) s
theorem fintype.exists_infinite_fiber {α : Type u_1} {β : Type u_2} [infinite α] [fintype β] (f : α → β) : ∃ (y : β), infinite ↥(f ⁻¹' {y})
theorem filter.exists_seq_tendsto {α : Type u_3} (f : filter α) [f.is_countably_generated] [f.ne_bot] : ∃ (x : ℕ → α), filter.tendsto x filter.at_top f
theorem set.eq_on.of_subset_closure {α : Type u} {β : Type v} [topological_space α] [topological_space β] [t2_space α] {s t : set β} {f g : β → α} (h : set.eq_on f g s) (hf : continuous_on f t) (hg : continuous_on g t) (hst : s ⊆ t) (hts : t ⊆ closure s) : set.eq_on f g t
theorem ideal.polynomial_mem_ideal_of_coeff_mem_ideal {R : Type u} [comm_semiring R] (I : ideal (polynomial R)) (p : polynomial R) (hp : ∀ (n : ℕ), p.coeff n ∈ ideal.comap polynomial.C I) : p ∈ I
theorem is_min.of_dual {α : Type u_1} [has_le α] {a : αᵒᵈ} : is_min a → is_max (⇑order_dual.of_dual a)
theorem local_homeomorph.is_o_congr {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {E : Type u_3} [has_norm E] {F : Type u_4} [has_norm F] (e : local_homeomorph α β) {b : β} (hb : b ∈ e.to_local_equiv.target) {f : β → E} {g : β → F} : f =o[nhds b] g ↔ (f ∘ ⇑e) =o[nhds (⇑(e.symm) b)] (g ∘ ⇑e)
theorem asymptotics.is_O_with.norm_norm {α : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_normed_group E'] [semi_normed_group F'] {c : ℝ} {f' : α → E'} {g' : α → F'} {l : filter α} : asymptotics.is_O_with c l f' g' → asymptotics.is_O_with c l (λ (x : α), ∥f' x∥) (λ (x : α), ∥g' x∥)
theorem small.mk' {α : Type v} {S : Type w} (e : α ≃ S) : small α
theorem topological_group.continuous_conj' {G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] (h : G) : continuous (λ (g : G), g * h * g⁻¹)
theorem lt_of_inv_lt_inv {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} : a⁻¹ < b⁻¹ → b < a
theorem finset.sum_product' {β : Type u} {α : Type v} {γ : Type w} [add_comm_monoid β] {s : finset γ} {t : finset α} {f : γ → α → β} : (s.product t).sum (λ (x : γ × α), f x.fst x.snd) = s.sum (λ (x : γ), t.sum (λ (y : α), f x y))
theorem torus_integrable.add {n : ℕ} {E : Type u_1} [normed_group E] {f g : (fin n → ℂ) → E} {c : fin n → ℂ} {R : fin n → ℝ} (hf : torus_integrable f c R) (hg : torus_integrable g c R) : torus_integrable (f + g) c R
theorem pseudo_metric.uniformity_basis_edist {α : Type u} [pseudo_metric_space α] : (uniformity α).has_basis (λ (ε : ennreal), 0 < ε) (λ (ε : ennreal), {p : α × α | has_edist.edist p.fst p.snd < ε})
theorem unique_mdiff_on.unique_diff_on_inter_preimage {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {s : set M} (hs : unique_mdiff_on I s) (x : M) (y : M') {f : M → M'} (hf : continuous_on f s) : unique_diff_on 𝕜 ((ext_chart_at I x).target ∩ ⇑((ext_chart_at I x).symm) ⁻¹' (s ∩ f ⁻¹' (ext_chart_at I' y).source))
theorem ideal.has_basis_nhds_zero_adic {R : Type u_1} [comm_ring R] (I : ideal R) : (nhds 0).has_basis (λ (n : ℕ), true) (λ (n : ℕ), ↑(I ^ n))
theorem measure_theory.ae_of_forall_measure_lt_top_ae_restrict {α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} [measure_theory.sigma_finite μ] (P : α → Prop) (h : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → (∀ᵐ (x : α) ∂μ.restrict s, P x)) : ∀ᵐ (x : α) ∂μ, P x
theorem differentiable.exists_eq_const_of_bounded {E : Type u} [normed_group E] [normed_space ℂ E] {F : Type v} [normed_group F] [normed_space ℂ F] {f : E → F} (hf : differentiable ℂ f) (hb : metric.bounded (set.range f)) : ∃ (c : F), f = function.const E c
theorem complex.abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le {a b : ℝ} (ha : a ≤ 0) {z : ℂ} (hz : |z.im| ≤ b) (hb : b ≤ real.pi / 2) : complex.abs (complex.exp (↑a * (complex.exp z + complex.exp (-z)))) ≤ real.exp (a * real.cos b * real.exp |z.re|)
theorem polynomial.has_separable_contraction.dvd_degree {F : Type} [comm_semiring F] {q : ℕ} {f : polynomial F} (hf : polynomial.has_separable_contraction q f) : hf.degree ∣ f.nat_degree
theorem measure_theory.mem_ℒp.mono {α : Type u_1} {E : Type u_2} {F : Type u_3} {m0 : measurable_space α} {p : ennreal} {μ : measure_theory.measure α} [normed_group E] [normed_group F] {f : α → E} {g : α → F} (hg : measure_theory.mem_ℒp g p μ) (hf : measure_theory.ae_strongly_measurable f μ) (hfg : ∀ᵐ (x : α) ∂μ, ∥f x∥ ≤ ∥g x∥) : measure_theory.mem_ℒp f p μ
theorem mul_action.sum_card_fixed_by_eq_card_orbits_mul_card_group (α : Type u) (β : Type v) [group α] [mul_action α β] [fintype α] [Π (a : α), fintype ↥(mul_action.fixed_by α β a)] [fintype (quotient (mul_action.orbit_rel α β))] : finset.univ.sum (λ (a : α), fintype.card ↥(mul_action.fixed_by α β a)) = fintype.card (quotient (mul_action.orbit_rel α β)) * fintype.card α
theorem matrix.det_one_add_mul_comm {m : Type u} {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] [fintype m] [decidable_eq m] (A : matrix m n α) (B : matrix n m α) : (1 + A.mul B).det = (1 + B.mul A).det
theorem category_theory.unit_comp_partial_bijective_aux_symm_apply {C : Type u₁} {D : Type u₂} [category_theory.category C] [category_theory.category D] {i : D ⥤ C} [category_theory.reflective i] {A : C} {B : D} (f : i.obj ((category_theory.left_adjoint i).obj A) ⟶ i.obj B) : ⇑((category_theory.unit_comp_partial_bijective_aux A B).symm) f = (category_theory.adjunction.of_right_adjoint i).unit.app A ≫ f
theorem bounded_continuous_function.dist_zero_of_empty {α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {f g : bounded_continuous_function α β} [is_empty α] : has_dist.dist f g = 0
theorem algebraic_geometry.LocallyRingedSpace.to_Γ_Spec_c_app_iff (X : algebraic_geometry.LocallyRingedSpace) (r : ↥(algebraic_geometry.LocallyRingedSpace.Γ.obj (opposite.op X))) (f : (algebraic_geometry.Spec.structure_sheaf ↥(algebraic_geometry.LocallyRingedSpace.Γ.obj (opposite.op X))).val.obj (opposite.op (prime_spectrum.basic_open r)) ⟶ X.to_SheafedSpace.to_PresheafedSpace.presheaf.obj (opposite.op (X.to_Γ_Spec_map_basic_open r))) : algebraic_geometry.structure_sheaf.to_open ↥(algebraic_geometry.LocallyRingedSpace.Γ.obj (opposite.op X)) (prime_spectrum.basic_open r) ≫ f = X.to_to_Γ_Spec_map_basic_open r ↔ f = X.to_Γ_Spec_c_app r
theorem le_nhds_of_cauchy_adhp_aux {α : Type u} [uniform_space α] {f : filter α} {x : α} (adhs : ∀ (s : set (α × α)), s ∈ uniformity α → (∃ (t : set α) (H : t ∈ f), t ×ˢ t ⊆ s ∧ ∃ (y : α), (x, y) ∈ s ∧ y ∈ t)) : f ≤ nhds x
theorem power_series.sub_const_eq_shift_mul_X {R : Type u_1} [ring R] (φ : power_series R) : φ - ⇑(power_series.C R) (⇑(power_series.constant_coeff R) φ) = power_series.mk (λ (p : ℕ), ⇑(power_series.coeff R (p + 1)) φ) * power_series.X
theorem isometry.right_inv {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} {g : β → α} (h : isometry f) (hg : function.right_inverse g f) : isometry g
theorem witt_vector.isocrystal_classification (p : ℕ) [fact (nat.prime p)] (k : Type u_1) [field k] [is_alg_closed k] [char_p k p] (V : Type u_2) [add_comm_group V] [witt_vector.isocrystal p k V] (h_dim : finite_dimensional.finrank (fraction_ring (witt_vector p k)) V = 1) : ∃ (m : ℤ), nonempty (witt_vector.isocrystal_equiv p k (witt_vector.standard_one_dim_isocrystal p k m) V)
theorem add_le_of_le_sub_left {α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : b ≤ c - a → a + b ≤ c
theorem affine.simplex.sum_monge_point_weights_with_circumcenter (n : ℕ) : finset.univ.sum (λ (i : affine.simplex.points_with_circumcenter_index (n + 2)), affine.simplex.monge_point_weights_with_circumcenter n i) = 1
theorem finset.noncomm_prod_mul_distrib {α : Type u_1} {β : Type u_2} [monoid β] {s : finset α} (f g : α → β) (comm_ff : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → commute (f x) (f y)) (comm_gg : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → commute (g x) (g y)) (comm_gf : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≠ y → commute (g x) (f y)) : s.noncomm_prod (f * g) _ = s.noncomm_prod f comm_ff * s.noncomm_prod g comm_gg
theorem monoid_algebra.finite_type_iff_fg {R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R M) ↔ monoid.fg M
theorem interval_integral.fderiv_within_integral_of_tendsto_ae {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {ca cb : E} {la lb : filter ℝ} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f la measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f lb measure_theory.measure_space.volume) {s t : set ℝ} [interval_integral.FTC_filter a (nhds_within a s) la] [interval_integral.FTC_filter b (nhds_within b t) lb] (ha : filter.tendsto f (la ⊓ measure_theory.measure_space.volume.ae) (nhds ca)) (hb : filter.tendsto f (lb ⊓ measure_theory.measure_space.volume.ae) (nhds cb)) (hs : unique_diff_within_at ℝ s a . "unique_diff_within_at_Ici_Iic_univ") (ht : unique_diff_within_at ℝ t b . "unique_diff_within_at_Ici_Iic_univ") : fderiv_within ℝ (λ (p : ℝ × ℝ), ∫ (x : ℝ) in p.fst..p.snd, f x) (s ×ˢ t) (a, b) = (continuous_linear_map.snd ℝ ℝ ℝ).smul_right cb - (continuous_linear_map.fst ℝ ℝ ℝ).smul_right ca
theorem line_map_lt_map_iff_slope_lt_slope_left {k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k → E} {a b r : k} (h : 0 < r * (b - a)) : ⇑(affine_map.line_map (f a) (f b)) r < f (⇑(affine_map.line_map a b) r) ↔ slope f a b < slope f a (⇑(affine_map.line_map a b) r)
theorem finset.eq_of_mem_of_not_mem_erase {α : Type u_1} [decidable_eq α] {s : finset α} {a b : α} (hs : b ∈ s) (hsa : b ∉ s.erase a) : b = a
theorem linear_map.trace_eq_contract_of_basis' {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {ι : Type u_4} [fintype ι] [decidable_eq ι] (b : basis ι R M) : linear_map.trace R M = (contract_left R M).comp (dual_tensor_hom_equiv_of_basis b).symm.to_linear_map
theorem mfderiv_within_eq_fderiv_within {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {f : E → E'} {s : set E} {x : E} : mfderiv_within (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f s x = fderiv_within 𝕜 f s x
theorem finset.nonempty.card_pos {α : Type u_1} {s : finset α} : s.nonempty → 0 < s.card
theorem filter.map_map₂_antidistrib_left {α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {m : α → β → γ} {f : filter α} {g : filter β} {n : γ → δ} {m' : β' → α → δ} {n' : β → β'} (h_antidistrib : ∀ (a : α) (b : β), n (m a b) = m' (n' b) a) : filter.map n (filter.map₂ m f g) = filter.map₂ m' (filter.map n' g) f
theorem has_deriv_within_at.liminf_right_norm_slope_le {E : Type u} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {f' : E} {x r : ℝ} (hf : has_deriv_within_at f f' (set.Ici x) x) (hr : ∥f'∥ < r) : ∃ᶠ (z : ℝ) in nhds_within x (set.Ioi x), ∥z - x∥⁻¹ * ∥f z - f x∥ < r
theorem is_integral.is_algebraic (R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] [nontrivial R] {x : A} : is_integral R x → is_algebraic R x
theorem Profinite.is_iso_of_bijective {X Y : Profinite} (f : X ⟶ Y) (bij : function.bijective ⇑f) : category_theory.is_iso f
theorem norm_sq_eq_add_norm_sq_projection {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x : E) (S : submodule 𝕜 E) [complete_space E] [complete_space ↥S] : ∥x∥ ^ 2 = ∥⇑(orthogonal_projection S) x∥ ^ 2 + ∥⇑(orthogonal_projection Sᗮ) x∥ ^ 2
theorem add_le_of_le_sub_right {α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b c : α} : a ≤ c - b → a + b ≤ c
theorem padic_val_int.self {p : ℕ} (hp : 1 < p) : padic_val_int p ↑p = 1
theorem zmod.χ₈'_int_eq_if_mod_eight (n : ℤ) : ⇑zmod.χ₈' ↑n = ite (n % 2 = 0) 0 (ite (n % 8 = 1 ∨ n % 8 = 3) 1 (-1))
theorem exists_bounded_mem_Icc_of_closed_of_le {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) {a b : ℝ} (hle : a ≤ b) : ∃ (f : bounded_continuous_function X ℝ), set.eq_on ⇑f (function.const X a) s ∧ set.eq_on ⇑f (function.const X b) t ∧ ∀ (x : X), ⇑f x ∈ set.Icc a b
theorem finsum_mem_pair {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} {a b : α} (h : a ≠ b) : finsum (λ (i : α), finsum (λ (H : i ∈ {a, b}), f i)) = f a + f b
theorem set.Union_lift_binary {α : Type u_1} {ι : Type u_2} {β : Type u_3} {S : ι → set α} {f : Π (i : ι), ↥(S i) → β} {hf : ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j), f i ⟨x, hxi⟩ = f j ⟨x, hxj⟩} {T : set α} (hT' : T = set.Union S) (dir : directed has_le.le S) (op : ↥T → ↥T → ↥T) (opi : Π (i : ι), ↥(S i) → ↥(S i) → ↥(S i)) (hopi : ∀ (i : ι) (x y : ↥(S i)), set.inclusion _ (opi i x y) = op (set.inclusion _ x) (set.inclusion _ y)) (opβ : β → β → β) (h : ∀ (i : ι) (x y : ↥(S i)), f i (opi i x y) = opβ (f i x) (f i y)) (x y : ↥T) : set.Union_lift S f hf T _ (op x y) = opβ (set.Union_lift S f hf T _ x) (set.Union_lift S f hf T _ y)
theorem monoid.not_is_torsion_free_iff (G : Type u_1) [monoid G] : ¬monoid.is_torsion_free G ↔ ∃ (g : G), g ≠ 1 ∧ is_of_fin_order g
theorem frontier_compl {α : Type u} [topological_space α] (s : set α) : frontier sᶜ = frontier s
theorem nat.four_pow_lt_mul_central_binom (n : ℕ) (n_big : 4 ≤ n) : 4 ^ n < n * n.central_binom
theorem pfun.ext' {α : Type u_1} {β : Type u_2} {f g : α →. β} (H1 : ∀ (a : α), a ∈ f.dom ↔ a ∈ g.dom) (H2 : ∀ (a : α) (p : f.dom a) (q : g.dom a), f.fn a p = g.fn a q) : f = g
theorem inner_sum {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_3} (s : finset ι) (f : ι → E) (x : E) : has_inner.inner x (s.sum (λ (i : ι), f i)) = s.sum (λ (i : ι), has_inner.inner x (f i))
theorem fintype.induction_empty_option {P : Type u → Prop} (of_equiv : ∀ {α β : Type u}, α ≃ β → P α → P β) (h_empty : P pempty) (h_option : ∀ {α : Type u} [_inst_1 : fintype α], P α → P (option α)) (α : Type u) [fintype α] : P α
theorem formal_multilinear_series.has_fpower_series_on_ball {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] [complete_space F] (p : formal_multilinear_series 𝕜 E F) (h : 0 < p.radius) : has_fpower_series_on_ball p.sum p 0 p.radius
theorem category_theory.normal_epi_category.mono_of_cancel_zero {C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_cokernels C] [category_theory.normal_epi_category C] [category_theory.limits.has_zero_object C] {X Y : C} (f : X ⟶ Y) (hf : ∀ (Z : C) (g : Z ⟶ X), g ≫ f = 0 → g = 0) : category_theory.mono f
theorem linear_recurrence.is_sol_mk_sol {α : Type u_1} [comm_semiring α] (E : linear_recurrence α) (init : fin E.order → α) : E.is_solution (E.mk_sol init)
theorem hall_marriage_theorem.hall_hard_inductive_step_A {ι : Type u} {α : Type v} [fintype ι] {t : ι → finset α} [decidable_eq α] {n : ℕ} (hn : fintype.card ι = n + 1) (ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card) (ih : ∀ {ι' : Type u} [_inst_3 : fintype ι'] (t' : ι' → finset α), fintype.card ι' ≤ n → (∀ (s' : finset ι'), s'.card ≤ (s'.bUnion t').card) → (∃ (f : ι' → α), function.injective f ∧ ∀ (x : ι'), f x ∈ t' x)) (ha : ∀ (s : finset ι), s.nonempty → s ≠ finset.univ → s.card < (s.bUnion t).card) : ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x
theorem measure_theory.exists_pos_set_lintegral_lt_of_measure_lt {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : α → ennreal} (h : ∫⁻ (x : α), f x ∂μ ≠ ⊤) {ε : ennreal} (hε : ε ≠ 0) : ∃ (δ : ennreal) (H : δ > 0), ∀ (s : set α), ⇑μ s < δ → ∫⁻ (x : α) in s, f x ∂μ < ε
theorem cont_diff_within_at_succ_iff_has_fderiv_within_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {x : E} {n : ℕ} : cont_diff_within_at 𝕜 ↑(n + 1) f s x ↔ ∃ (u : set E) (H : u ∈ nhds_within x (has_insert.insert x s)) (f' : E → (E →L[𝕜] F)), (∀ (x : E), x ∈ u → has_fderiv_within_at f (f' x) u x) ∧ cont_diff_within_at 𝕜 ↑n f' u x
theorem category_theory.limits.is_initial.epi_to {C : Type u₁} [category_theory.category C] {X Y : C} (t : category_theory.limits.is_initial X) (f : Y ⟶ X) : category_theory.epi f
theorem linear_independent.maximal_iff {ι : Type w} {R : Type u} [ring R] [nontrivial R] {M : Type v} [add_comm_group M] [module R M] {v : ι → M} (i : linear_independent R v) : i.maximal ↔ ∀ (κ : Type v) (w : κ → M), linear_independent R w → ∀ (j : ι → κ), w ∘ j = v → function.surjective j
theorem asymptotics.is_O.of_neg_right {α : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : α → E} {g' : α → F'} {l : filter α} : (f =O[l] λ (x : α), -g' x) → f =O[l] g'
theorem no_max_order.infinite {α : Type u_1} [preorder α] [nonempty α] [no_max_order α] : infinite α
theorem continuous_matrix {α : Type u_2} {m : Type u_4} {n : Type u_5} {R : Type u_8} [topological_space R] [topological_space α] {f : α → matrix m n R} (h : ∀ (i : m) (j : n), continuous (λ (a : α), f a i j)) : continuous f
theorem mul_sub {α : Type u} [non_unital_non_assoc_ring α] (a b c : α) : a * (b - c) = a * b - a * c
theorem multiset.Ioc_eq_zero {α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → multiset.Ioc a b = 0
theorem nnreal.rpow_sum_le_const_mul_sum_rpow {ι : Type u} (s : finset ι) (f : ι → nnreal) {p : ℝ} (hp : 1 ≤ p) : s.sum (λ (i : ι), f i) ^ p ≤ ↑(s.card) ^ (p - 1) * s.sum (λ (i : ι), f i ^ p)
theorem dist_le_of_le_geometric_two_of_tendsto {α : Type u_1} [pseudo_metric_space α] (C : ℝ) {f : ℕ → α} (hu₂ : ∀ (n : ℕ), has_dist.dist (f n) (f (n + 1)) ≤ C / 2 / 2 ^ n) {a : α} (ha : filter.tendsto f filter.at_top (nhds a)) (n : ℕ) : has_dist.dist (f n) a ≤ C / 2 ^ n
theorem with_top.is_lub_Sup' {β : Type u_1} [conditionally_complete_lattice β] {s : set (with_top β)} (hs : s.nonempty) : is_lub s (has_Sup.Sup s)
theorem measure_theory.continuous_L1_to_L1 {α : Type u_1} {G : Type u_5} [normed_group G] {m : measurable_space α} {μ μ' : measure_theory.measure α} (c' : ennreal) (hc' : c' ≠ ⊤) (hμ'_le : μ' ≤ c' • μ) : continuous (λ (f : ↥(measure_theory.Lp G 1 μ)), measure_theory.integrable.to_L1 ⇑f _)
theorem finsum_mem_range {α : Type u_1} {β : Type u_2} {M : Type u_5} [add_comm_monoid M] {f : α → M} {g : β → α} (hg : function.injective g) : finsum (λ (i : α), finsum (λ (H : i ∈ set.range g), f i)) = finsum (λ (j : β), f (g j))
theorem univ.is_submonoid {M : Type u_1} [monoid M] : is_submonoid set.univ
theorem has_fderiv_within_at.lim {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {x : E} {s : set E} (h : has_fderiv_within_at f f' s x) {α : Type u_4} (l : filter α) {c : α → 𝕜} {d : α → E} {v : E} (dtop : ∀ᶠ (n : α) in l, x + d n ∈ s) (clim : filter.tendsto (λ (n : α), ∥c n∥) l filter.at_top) (cdlim : filter.tendsto (λ (n : α), c n • d n) l (nhds v)) : filter.tendsto (λ (n : α), c n • (f (x + d n) - f x)) l (nhds (⇑f' v))
theorem is_cyclotomic_extension.prime_ne_two_pow_norm_zeta_pow_sub_one {p : ℕ+} {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [ne_zero ↑↑p] {k : ℕ} [hpri : fact (nat.prime ↑p)] [is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic ↑(p ^ (k + 1)) K)) {s : ℕ} (hs : s ≤ k) (htwo : p ^ (k - s + 1) ≠ 2) : ⇑(algebra.norm K) (is_cyclotomic_extension.zeta (p ^ (k + 1)) K L ^ ↑p ^ s - 1) = ↑p ^ ↑p ^ s
theorem generalized_continued_fraction.int_fract_pair.stream_succ_nth_fr_num_lt_nth_fr_num_rat {q : ℚ} {n : ℕ} {ifp_n ifp_succ_n : generalized_continued_fraction.int_fract_pair ℚ} (stream_nth_eq : generalized_continued_fraction.int_fract_pair.stream q n = option.some ifp_n) (stream_succ_nth_eq : generalized_continued_fraction.int_fract_pair.stream q (n + 1) = option.some ifp_succ_n) : ifp_succ_n.fr.num < ifp_n.fr.num
theorem add_subgroup.comap_normalizer_eq_of_surjective {G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (H : add_subgroup G) {f : N →+ G} (hf : function.surjective ⇑f) : add_subgroup.comap f H.normalizer = (add_subgroup.comap f H).normalizer
theorem lt_tsub_iff_left {α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] : a < b - c ↔ c + a < b
theorem is_local_max_on.fderiv_within_nonpos {E : Type u} [normed_group E] [normed_space ℝ E] {f : E → ℝ} {a : E} {s : set E} (h : is_local_max_on f s a) {y : E} (hy : y ∈ pos_tangent_cone_at s a) : ⇑(fderiv_within ℝ f s a) y ≤ 0
theorem intermediate_field.adjoin_adjoin_comm (F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] (S T : set E) : ↑(intermediate_field.adjoin ↥(intermediate_field.adjoin F S) T) = ↑(intermediate_field.adjoin ↥(intermediate_field.adjoin F T) S)
theorem supr_ne_bot_subtype {α : Type u_1} {ι : Sort u_4} [complete_lattice α] (f : ι → α) : (⨆ (i : {i // f i ≠ ⊥}), f ↑i) = ⨆ (i : ι), f i
theorem function.periodic.interval_integral_add_eq_add {E : Type u_1} [normed_group E] [normed_space ℝ E] [complete_space E] {f : ℝ → E} {T : ℝ} (hf : function.periodic f T) (t s : ℝ) (h_int : ∀ (t₁ t₂ : ℝ), interval_integrable f measure_theory.measure_space.volume t₁ t₂) : ∫ (x : ℝ) in t..s + T, f x = (∫ (x : ℝ) in t..s, f x) + ∫ (x : ℝ) in t..t + T, f x
theorem add_monoid_algebra.mem_closure_of_mem_span_closure {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_monoid M] [nontrivial R] {m : M} {S : set M} (h : add_monoid_algebra.of' R M m ∈ submodule.span R ↑(submonoid.closure (add_monoid_algebra.of' R M '' S))) : m ∈ add_submonoid.closure S
theorem polynomial.base_mul_mem_lifts {R : Type u} [semiring R] {S : Type v} [semiring S] {f : R →+* S} {p : polynomial S} (r : R) (hp : p ∈ polynomial.lifts f) : ⇑polynomial.C (⇑f r) * p ∈ polynomial.lifts f
theorem subtype.range_val {α : Type u_1} {s : set α} : set.range subtype.val = s
theorem spectrum.nonempty {A : Type u_1} [normed_ring A] [normed_algebra ℂ A] [complete_space A] [nontrivial A] (a : A) : (spectrum ℂ a).nonempty
theorem local_equiv.is_image.symm_preimage_eq {α : Type u_1} {β : Type u_2} {e : local_equiv α β} {s : set α} {t : set β} : e.is_image s t → e.target ∩ ⇑(e.symm) ⁻¹' s = e.target ∩ t
theorem power_series.order_monomial {R : Type u_1} [semiring R] (n : ℕ) (a : R) [decidable (a = 0)] : (⇑(power_series.monomial R n) a).order = ite (a = 0) ⊤ ↑n
theorem finset.exists_card_fiber_le_of_card_le_mul {α : Type u} {β : Type v} [decidable_eq β] {s : finset α} {t : finset β} {f : α → β} {n : ℕ} (ht : t.nonempty) (hn : s.card ≤ t.card * n) : ∃ (y : β) (H : y ∈ t), (finset.filter (λ (x : α), f x = y) s).card ≤ n
theorem has_lt.lt.trans_le {α : Type u} [preorder α] {a b c : α} : a < b → b ≤ c → a < c
theorem measure_theory.measure.haar.index_defined {G : Type u_1} [group G] [topological_space G] [topological_group G] {K V : set G} (hK : is_compact K) (hV : (interior V).nonempty) : ∃ (n : ℕ), n ∈ finset.card '' {t : finset G | K ⊆ ⋃ (g : G) (H : g ∈ t), (λ (h : G), g * h) ⁻¹' V}
theorem Gromov_Hausdorff.totally_bounded {t : set Gromov_Hausdorff.GH_space} {C : ℝ} {u : ℕ → ℝ} {K : ℕ → ℕ} (ulim : filter.tendsto u filter.at_top (nhds 0)) (hdiam : ∀ (p : Gromov_Hausdorff.GH_space), p ∈ t → metric.diam set.univ ≤ C) (hcov : ∀ (p : Gromov_Hausdorff.GH_space), p ∈ t → ∀ (n : ℕ), ∃ (s : set p.rep), cardinal.mk ↥s ≤ ↑(K n) ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s), metric.ball x (u n)) : totally_bounded t
theorem measure_theory.measure.rn_deriv_restrict {α : Type u_1} {m : measurable_space α} (ν : measure_theory.measure α) [measure_theory.sigma_finite ν] {s : set α} (hs : measurable_set s) : (ν.restrict s).rn_deriv ν =ᵐ[ν] s.indicator 1
theorem category_theory.has_colimits_of_has_colimits_creates_colimits {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) [category_theory.limits.has_colimits_of_size D] [category_theory.creates_colimits_of_size F] : category_theory.limits.has_colimits_of_size C
theorem convex_hull_exists_dist_ge2 {E : Type u_2} [semi_normed_group E] [normed_space ℝ E] {s t : set E} {x y : E} (hx : x ∈ ⇑(convex_hull ℝ) s) (hy : y ∈ ⇑(convex_hull ℝ) t) : ∃ (x' : E) (H : x' ∈ s) (y' : E) (H : y' ∈ t), has_dist.dist x y ≤ has_dist.dist x' y'
theorem exists_pow_lt_of_lt_one {α : Type u_1} [linear_ordered_field α] [archimedean α] {x y : α} (hx : 0 < x) (hy : y < 1) : ∃ (n : ℕ), y ^ n < x
theorem exists_polynomial_near_of_continuous_on (a b : ℝ) (f : ℝ → ℝ) (c : continuous_on f (set.Icc a b)) (ε : ℝ) (pos : 0 < ε) : ∃ (p : polynomial ℝ), ∀ (x : ℝ), x ∈ set.Icc a b → |polynomial.eval x p - f x| < ε
theorem bdd_below.inter_of_left {α : Type u} [preorder α] {s t : set α} (h : bdd_below s) : bdd_below (s ∩ t)
theorem submodule.inner_right_of_mem_orthogonal {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K : submodule 𝕜 E} {u v : E} (hu : u ∈ K) (hv : v ∈ Kᗮ) : has_inner.inner u v = 0
theorem orientation.two_zsmul_oangle_smul_right_self {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x : V) {r : ℝ} : 2 • o.oangle x (r • x) = 0
theorem lucas_lehmer.two_lt_q (p' : ℕ) : 2 < lucas_lehmer.q (p' + 2)
theorem continuous_linear_equiv.has_sum {ι : Type u_10} {R : Type u_11} {R₂ : Type u_12} {M : Type u_13} {M₂ : Type u_14} [semiring R] [semiring R₂] [add_comm_monoid M] [module R M] [add_comm_monoid M₂] [module R₂ M₂] [topological_space M] [topological_space M₂] {σ : R →+* R₂} {σ' : R₂ →+* R} [ring_hom_inv_pair σ σ'] [ring_hom_inv_pair σ' σ] {f : ι → M} (e : M ≃SL[σ] M₂) {y : M₂} : has_sum (λ (b : ι), ⇑e (f b)) y ↔ has_sum f (⇑(e.symm) y)
theorem category_theory.is_filtered.of_right_adjoint {C : Type u} [category_theory.category C] [category_theory.is_filtered C] {D : Type u₁} [category_theory.category D] {L : D ⥤ C} {R : C ⥤ D} (h : L ⊣ R) : category_theory.is_filtered D
theorem interval_integral.sub_le_integral_of_has_deriv_right_of_le_Ico {a b : ℝ} {g' g φ : ℝ → ℝ} (hab : a ≤ b) (hcont : continuous_on g (set.Icc a b)) (hderiv : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at g (g' x) (set.Ioi x) x) (φint : measure_theory.integrable_on φ (set.Icc a b) measure_theory.measure_space.volume) (hφg : ∀ (x : ℝ), x ∈ set.Ico a b → g' x ≤ φ x) : g b - g a ≤ ∫ (y : ℝ) in a..b, φ y
theorem isometry_subsingleton {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} [subsingleton α] : isometry f
theorem bilin_form.restrict_symm {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (b : B.is_symm) (W : submodule R M) : (B.restrict W).is_symm
theorem closure_Ioi {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) [no_max_order α] : closure (set.Ioi a) = set.Ici a
theorem category_theory.presheaf.is_limit_iff_is_sheaf_for_presieve {C : Type u₁} [category_theory.category C] {A : Type u₂} [category_theory.category A] (P : Cᵒᵖ ⥤ A) {X : C} (R : category_theory.presieve X) : nonempty (category_theory.limits.is_limit (P.map_cone (category_theory.sieve.generate R).arrows.cocone.op)) ↔ ∀ (E : Aᵒᵖ), category_theory.presieve.is_sheaf_for (P ⋙ category_theory.coyoneda.obj E) R
theorem inner_product_geometry.sin_angle_mul_norm_mul_norm {V : Type u_1} [inner_product_space ℝ V] (x y : V) : real.sin (inner_product_geometry.angle x y) * (∥x∥ * ∥y∥) = real.sqrt (has_inner.inner x x * has_inner.inner y y - has_inner.inner x y * has_inner.inner x y)
theorem polynomial.cyclotomic.irreducible {n : ℕ} (hpos : 0 < n) : irreducible (polynomial.cyclotomic n ℤ)
theorem continuous_linear_map.op_norm_zero_iff {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [normed_group E] [normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →SL[σ₁₂] F) [ring_hom_isometric σ₁₂] : ∥f∥ = 0 ↔ f = 0
theorem mdifferentiable_iff_differentiable {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {f : E → E'} : mdifferentiable (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f ↔ differentiable 𝕜 f
theorem power_series.ext_iff {R : Type u_1} [semiring R] {φ ψ : power_series R} : φ = ψ ↔ ∀ (n : ℕ), ⇑(power_series.coeff R n) φ = ⇑(power_series.coeff R n) ψ
theorem formal_multilinear_series.le_comp_radius_of_summable {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] [normed_group G] [normed_space 𝕜 G] (q : formal_multilinear_series 𝕜 F G) (p : formal_multilinear_series 𝕜 E F) (r : nnreal) (hr : summable (λ (i : Σ (n : ℕ), composition n), ∥q.comp_along_composition p i.snd∥₊ * r ^ i.fst)) : ↑r ≤ (q.comp p).radius
theorem witt_vector.is_poly₂.diag {p : ℕ} {f : Π ⦃R : Type u_1⦄ [_inst_3 : comm_ring R], witt_vector p R → witt_vector p R → witt_vector p R} (hf : witt_vector.is_poly₂ p f) : witt_vector.is_poly p (λ (R : Type u_1) (_Rcr : comm_ring R) (x : witt_vector p R), f x x)
theorem finset.induction_on_max_value {α : Type u_1} {ι : Type u_4} [linear_order α] [decidable_eq ι] (f : ι → α) {p : finset ι → Prop} (s : finset ι) (h0 : p ∅) (step : ∀ (a : ι) (s : finset ι), a ∉ s → (∀ (x : ι), x ∈ s → f x ≤ f a) → p s → p (has_insert.insert a s)) : p s
theorem finprod_mem_union' {α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M} {s t : set α} (hst : disjoint s t) (hs : (s ∩ function.mul_support f).finite) (ht : (t ∩ function.mul_support f).finite) : finprod (λ (i : α), finprod (λ (H : i ∈ s ∪ t), f i)) = finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ t), f i))
theorem function.periodic.exists_mem_Ico₀ {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x : α) : ∃ (y : α) (H : y ∈ set.Ico 0 c), f x = f y
theorem convex_independent.subtype {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] {p : ι → E} (hc : convex_independent 𝕜 p) (s : set ι) : convex_independent 𝕜 (λ (i : ↥s), p ↑i)
theorem inner_product_geometry.inner_eq_mul_norm_of_angle_eq_zero {V : Type u_1} [inner_product_space ℝ V] {x y : V} (h : inner_product_geometry.angle x y = 0) : has_inner.inner x y = ∥x∥ * ∥y∥
theorem left_invariant_derivation.left_invariant' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {G : Type u_4} [topological_space G] [charted_space H G] [monoid G] [has_smooth_mul I G] (g : G) (X : left_invariant_derivation I G) : ⇑(hfdifferential _) (⇑(derivation.eval_at 1) ↑X) = ⇑(derivation.eval_at g) ↑X
theorem rat.dense_range_cast {𝕜 : Type u_1} [linear_ordered_field 𝕜] [topological_space 𝕜] [order_topology 𝕜] [archimedean 𝕜] : dense_range coe
theorem same_ray.exists_nonneg_right {R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} (h : same_ray R x y) (hy : y ≠ 0) : ∃ (r : R), 0 ≤ r ∧ x = r • y
theorem metric.Hausdorff_dist_closure₁ {α : Type u} [pseudo_metric_space α] {s t : set α} : metric.Hausdorff_dist (closure s) t = metric.Hausdorff_dist s t
theorem euclidean_geometry.dist_left_midpoint_eq_dist_right_midpoint {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (p1 p2 : P) : has_dist.dist p1 (midpoint ℝ p1 p2) = has_dist.dist p2 (midpoint ℝ p1 p2)
theorem valuation.zero_iff {Γ₀ : Type u_3} [linear_ordered_comm_monoid_with_zero Γ₀] [nontrivial Γ₀] {K : Type u_1} [division_ring K] (v : valuation K Γ₀) {x : K} : ⇑v x = 0 ↔ x = 0
theorem module.ray.ne_neg_self {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] [no_zero_smul_divisors R M] (x : module.ray R M) : x ≠ -x
theorem measure_theory.outer_measure.restrict_Inf_eq_Inf_restrict {α : Type u_1} (m : set (measure_theory.outer_measure α)) {s : set α} (hm : m.nonempty) : ⇑(measure_theory.outer_measure.restrict s) (has_Inf.Inf m) = has_Inf.Inf (⇑(measure_theory.outer_measure.restrict s) '' m)
theorem zmod.χ₈'_trichotomy (a : zmod 8) : ⇑zmod.χ₈' a = 0 ∨ ⇑zmod.χ₈' a = 1 ∨ ⇑zmod.χ₈' a = -1
theorem order_ring_iso.subsingleton_right {α : Type u_2} {β : Type u_3} [linear_ordered_field α] [linear_ordered_field β] [archimedean β] : subsingleton (α ≃+*o β)
theorem list.nth_le_drop' {α : Type u} (L : list α) {i j : ℕ} (h : j < (list.drop i L).length) : (list.drop i L).nth_le j h = L.nth_le (i + j) _
theorem finset.min'_singleton {α : Type u_1} [linear_order α] (a : α) : {a}.min' _ = a
theorem irrational_nrt_of_notint_nrt {x : ℝ} (n : ℕ) (m : ℤ) (hxr : x ^ n = ↑m) (hv : ¬∃ (y : ℤ), x = ↑y) (hnpos : 0 < n) : irrational x
theorem vector_span_range_eq_span_range_vsub_left (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} (p : ι → P) (i0 : ι) : vector_span k (set.range p) = submodule.span k (set.range (λ (i : ι), p i0 -ᵥ p i))
theorem category_theory.is_iso_iff_bijective {X Y : Type u} (f : X ⟶ Y) : category_theory.is_iso f ↔ function.bijective f
theorem connected_components_preimage_image {α : Type u} [topological_space α] (U : set α) : coe ⁻¹' (coe '' U) = ⋃ (x : α) (H : x ∈ U), connected_component x
theorem conformal_at_iff_is_conformal_map_fderiv {X : Type u_1} {Y : Type u_2} [normed_group X] [normed_group Y] [normed_space ℝ X] [normed_space ℝ Y] {f : X → Y} {x : X} : conformal_at f x ↔ is_conformal_map (fderiv ℝ f x)
theorem exists_ratio_deriv_eq_ratio_slope' (f : ℝ → ℝ) {a b : ℝ} (hab : a < b) (g : ℝ → ℝ) {lfa lga lfb lgb : ℝ} (hdf : differentiable_on ℝ f (set.Ioo a b)) (hdg : differentiable_on ℝ g (set.Ioo a b)) (hfa : filter.tendsto f (nhds_within a (set.Ioi a)) (nhds lfa)) (hga : filter.tendsto g (nhds_within a (set.Ioi a)) (nhds lga)) (hfb : filter.tendsto f (nhds_within b (set.Iio b)) (nhds lfb)) (hgb : filter.tendsto g (nhds_within b (set.Iio b)) (nhds lgb)) : ∃ (c : ℝ) (H : c ∈ set.Ioo a b), (lgb - lga) * deriv f c = (lfb - lfa) * deriv g c
theorem convex_independent_iff_finset {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] {p : ι → E} : convex_independent 𝕜 p ↔ ∀ (s : finset ι) (x : ι), p x ∈ ⇑(convex_hull 𝕜) ↑(finset.image p s) → x ∈ s
theorem cont_mdiff_on.continuous_on_tangent_map_within {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M → M'} {s : set M} {n : with_top ℕ} (hf : cont_mdiff_on I I' n f s) (hmn : 1 ≤ n) (hs : unique_mdiff_on I s) : continuous_on (tangent_map_within I I' f s) (tangent_bundle.proj I M ⁻¹' s)
theorem int.tendsto_coe_cofinite  : filter.tendsto coe filter.cofinite (filter.cocompact ℝ)
theorem add_subgroup.pi_le_iff {η : Type u_5} {f : η → Type u_6} [Π (i : η), add_group (f i)] [decidable_eq η] [fintype η] {H : Π (i : η), add_subgroup (f i)} {J : add_subgroup (Π (i : η), f i)} : add_subgroup.pi set.univ H ≤ J ↔ ∀ (i : η), add_subgroup.map (add_monoid_hom.single f i) (H i) ≤ J
theorem cont_diff.cont_mdiff {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {n : with_top ℕ} {f : E → E'} : cont_diff 𝕜 n f → cont_mdiff (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n f
theorem cont_diff_on.continuous_on_iterated_deriv_within {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {s : set 𝕜} {n : with_top ℕ} {m : ℕ} (h : cont_diff_on 𝕜 n f s) (hmn : ↑m ≤ n) (hs : unique_diff_on 𝕜 s) : continuous_on (iterated_deriv_within m f s) s
theorem emetric.countable_closure_of_compact {γ : Type w} [emetric_space γ] {s : set γ} (hs : is_compact s) : ∃ (t : set γ) (H : t ⊆ s), t.countable ∧ s = closure t
theorem submonoid.ext {M : Type u_1} [mul_one_class M] {S T : submonoid M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T) : S = T
theorem category_theory.finrank_endomorphism_simple_eq_one {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (𝕜 : Type u_3) [field 𝕜] [is_alg_closed 𝕜] [category_theory.linear 𝕜 C] [category_theory.limits.has_kernels C] (X : C) [category_theory.simple X] [I : finite_dimensional 𝕜 (X ⟶ X)] : finite_dimensional.finrank 𝕜 (X ⟶ X) = 1
theorem basis.adjust_to_orientation_apply_eq_or_eq_neg {R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {ι : Type u_3} [decidable_eq ι] [fintype ι] [nontrivial R] [nonempty ι] (e : basis ι R M) (x : orientation R M ι) (i : ι) : ⇑(e.adjust_to_orientation x) i = ⇑e i ∨ ⇑(e.adjust_to_orientation x) i = -⇑e i
theorem list.length_pos_of_sum_neg {M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : L.sum < 0) : 0 < L.length
theorem add_subgroup.norm_trivial_quotient_mk {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (h : ↑(S.topological_closure) = set.univ) : ∥S.normed_mk∥ = 0
theorem map_Inf_of_continuous_at_of_monotone' {α : Type u} {β : Type v} [complete_linear_order α] [topological_space α] [order_topology α] [complete_linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} (Cf : continuous_at f (has_Inf.Inf s)) (Mf : monotone f) (hs : s.nonempty) : f (has_Inf.Inf s) = has_Inf.Inf (f '' s)
theorem category_theory.limits.pullback_cone.mono_of_is_limit_mk_id_id {C : Type u} [category_theory.category C] {X Y : C} (f : X ⟶ Y) (t : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk (𝟙 X) (𝟙 X) rfl)) : category_theory.mono f
theorem cauchy_seq_of_le_tendsto_0 {α : Type u} {β : Type v} [pseudo_metric_space α] [nonempty β] [semilattice_sup β] {s : β → α} (b : β → ℝ) (h : ∀ (n m N : β), N ≤ n → N ≤ m → has_dist.dist (s n) (s m) ≤ b N) (h₀ : filter.tendsto b filter.at_top (nhds 0)) : cauchy_seq s
theorem real.le_rpow_add {x : ℝ} (hx : 0 ≤ x) (y z : ℝ) : x ^ y * x ^ z ≤ x ^ (y + z)
theorem finset.le_sum_nonempty_of_subadditive {ι : Type u_1} {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [ordered_add_comm_monoid N] (f : M → N) (h_mul : ∀ (x y : M), f (x + y) ≤ f x + f y) {s : finset ι} (hs : s.nonempty) (g : ι → M) : f (s.sum (λ (i : ι), g i)) ≤ s.sum (λ (i : ι), f (g i))
theorem nat.factors_add_two (n : ℕ) : (n + 2).factors = (n + 2).min_fac :: ((n + 2) / (n + 2).min_fac).factors
theorem is_greatest.bdd_above {α : Type u} [preorder α] {s : set α} {a : α} (h : is_greatest s a) : bdd_above s
theorem semiconj_by.transitive {S : Type u} [semigroup S] : transitive (λ (a b : S), ∃ (c : S), semiconj_by c a b)
theorem fintype.exists_lt_card_fiber_of_mul_lt_card {α : Type u} {β : Type v} [decidable_eq β] [fintype α] [fintype β] (f : α → β) {n : ℕ} (hn : fintype.card β * n < fintype.card α) : ∃ (y : β), n < (finset.filter (λ (x : α), f x = y) finset.univ).card
theorem fin.coe_order_iso_apply {n m : ℕ} (e : fin n ≃o fin m) (i : fin n) : ↑(⇑e i) = ↑i
theorem left.add_pos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
theorem measure_theory.outer_measure.infi_apply' {α : Type u_1} {ι : Sort u_2} (m : ι → measure_theory.outer_measure α) {s : set α} (hs : s.nonempty) : (⇑⨅ (i : ι), m i) s = ⨅ (t : ℕ → set α) (h2 : s ⊆ set.Union t), ∑' (n : ℕ), ⨅ (i : ι), ⇑(m i) (t n)
theorem univ.is_add_submonoid {M : Type u_1} [add_monoid M] : is_add_submonoid set.univ
theorem is_compact.integrable_on_of_nhds_within {X : Type u_1} {E : Type u_3} [measurable_space X] [topological_space X] [normed_group E] {f : X → E} {μ : measure_theory.measure X} {K : set X} (hK : is_compact K) (hf : ∀ (x : X), x ∈ K → measure_theory.integrable_at_filter f (nhds_within x K) μ) : measure_theory.integrable_on f K μ
theorem finite_dimensional_direction_affine_span_of_finite (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} (h : s.finite) : finite_dimensional k ↥((affine_span k s).direction)
theorem option.map_injective {α : Type u_1} {β : Type u_2} {f : α → β} (Hf : function.injective f) : function.injective (option.map f)
theorem tendsto_exp_div_rpow_at_top (s : ℝ) : filter.tendsto (λ (x : ℝ), real.exp x / x ^ s) filter.at_top filter.at_top
theorem conj_act.fixed_points_eq_center {G : Type u_2} [group G] : mul_action.fixed_points (conj_act G) G = ↑(subgroup.center G)
theorem cSup_union {α : Type u_1} [conditionally_complete_lattice α] {s t : set α} (hs : bdd_above s) (sne : s.nonempty) (ht : bdd_above t) (tne : t.nonempty) : has_Sup.Sup (s ∪ t) = has_Sup.Sup s ⊔ has_Sup.Sup t
theorem euclidean_geometry.orthogonal_projection_fn_vsub_mem_direction_orthogonal {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} [nonempty ↥s] [complete_space ↥(s.direction)] (p : P) : euclidean_geometry.orthogonal_projection_fn s p -ᵥ p ∈ (s.direction)ᗮ
theorem finset.op_sum {β : Type u} {α : Type v} [add_comm_monoid β] {s : finset α} (f : α → β) : mul_opposite.op (s.sum (λ (x : α), f x)) = s.sum (λ (x : α), mul_opposite.op (f x))
theorem continuous_within_at.tendsto {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} {s : set α} {x : α} (h : continuous_within_at f s x) : filter.tendsto f (nhds_within x s) (nhds (f x))
theorem finset.product_bUnion {α : Type u_1} {β : Type u_2} {γ : Type u_3} [decidable_eq γ] (s : finset α) (t : finset β) (f : α × β → finset γ) : (s.product t).bUnion f = s.bUnion (λ (a : α), t.bUnion (λ (b : β), f (a, b)))
theorem topological_space.is_topological_basis.sigma {ι : Type u_1} {E : ι → Type u_2} [Π (i : ι), topological_space (E i)] {s : Π (i : ι), set (set (E i))} (hs : ∀ (i : ι), topological_space.is_topological_basis (s i)) : topological_space.is_topological_basis (⋃ (i : ι), (λ (u : set (E i)), sigma.mk i '' u) '' s i)
theorem strict_mono.dual_right {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} : strict_mono f → strict_anti (⇑order_dual.to_dual ∘ f)
theorem has_le.le.trans_eq' {α : Type u} [preorder α] {a b c : α} : b ≤ c → a = b → a ≤ c
theorem finset.sum_powerset {α : Type u} {β : Type v} [add_comm_monoid β] (s : finset α) (f : finset α → β) : s.powerset.sum (λ (t : finset α), f t) = (finset.range (s.card + 1)).sum (λ (j : ℕ), (finset.powerset_len j s).sum (λ (t : finset α), f t))
theorem filter.tendsto.implicit_function {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] [complete_space 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] [finite_dimensional 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {a : E} (hf : has_strict_fderiv_at f f' a) (hf' : f'.range = ⊤) {α : Type u_4} {l : filter α} {g₁ : α → F} {g₂ : α → ↥(f'.ker)} (h₁ : filter.tendsto g₁ l (nhds (f a))) (h₂ : filter.tendsto g₂ l (nhds 0)) : filter.tendsto (λ (t : α), has_strict_fderiv_at.implicit_function f f' hf hf' (g₁ t) (g₂ t)) l (nhds a)
theorem monotone.tendsto_at_top_at_top_iff {α : Type u_3} {β : Type u_4} [nonempty α] [semilattice_sup α] [preorder β] {f : α → β} (hf : monotone f) : filter.tendsto f filter.at_top filter.at_top ↔ ∀ (b : β), ∃ (a : α), b ≤ f a
theorem one_add_mul_le_pow {R : Type u₁} [linear_ordered_ring R] {a : R} (H : -2 ≤ a) (n : ℕ) : 1 + ↑n * a ≤ (1 + a) ^ n
theorem le_one_of_one_le_inv {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : 1 ≤ a⁻¹ → a ≤ 1
theorem set.mem_of_indicator_ne_zero {α : Type u_1} {M : Type u_4} [has_zero M] {s : set α} {f : α → M} {a : α} (h : s.indicator f a ≠ 0) : a ∈ s
theorem nat.arithmetic_function.is_multiplicative.eq_iff_eq_on_prime_powers {R : Type u_1} [comm_monoid_with_zero R] (f : nat.arithmetic_function R) (hf : f.is_multiplicative) (g : nat.arithmetic_function R) (hg : g.is_multiplicative) : f = g ↔ ∀ (p i : ℕ), nat.prime p → ⇑f (p ^ i) = ⇑g (p ^ i)
theorem dfinsupp.lift_add_hom_comp_single {ι : Type u} {γ : Type w} {β : ι → Type v} [dec : decidable_eq ι] [Π (i : ι), add_zero_class (β i)] [add_comm_monoid γ] (f : Π (i : ι), β i →+ γ) (i : ι) : (⇑dfinsupp.lift_add_hom f).comp (dfinsupp.single_add_hom β i) = f i
theorem filter.tendsto.at_bot_mul_neg_const' {α : Type u_1} {R : Type u_2} {l : filter α} {f : α → R} {r : R} [linear_ordered_ring R] [archimedean R] (hr : r < 0) (hf : filter.tendsto f l filter.at_bot) : filter.tendsto (λ (x : α), f x * r) l filter.at_top
theorem generalized_continued_fraction.succ_nth_convergent_eq_squash_gcf_nth_convergent {K : Type u_1} {n : ℕ} {g : generalized_continued_fraction K} [field K] (nth_part_denom_ne_zero : ∀ {b : K}, g.partial_denominators.nth n = option.some b → b ≠ 0) : g.convergents (n + 1) = (g.squash_gcf n).convergents n
theorem quadratic_eq_zero_iff_discrim_eq_sq {R : Type u_1} [comm_ring R] [is_domain R] {a b c : R} (h2 : 2 ≠ 0) (ha : a ≠ 0) (x : R) : a * x * x + b * x + c = 0 ↔ discrim a b c = (2 * a * x + b) ^ 2
theorem generalized_continued_fraction.int_fract_pair.succ_nth_stream_eq_none_iff {K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} {n : ℕ} : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.none ↔ generalized_continued_fraction.int_fract_pair.stream v n = option.none ∨ ∃ (ifp : generalized_continued_fraction.int_fract_pair K), generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp ∧ ifp.fr = 0
theorem comp_assoc_left {α : Type u_1} (f : α → α → α) [is_associative α f] (x y : α) : f x ∘ f y = f (f x y)
theorem mul_zero_eq_const {M₀ : Type u_1} [mul_zero_class M₀] : (λ (_x : M₀), _x * 0) = function.const M₀ 0
theorem phragmen_lindelof.eq_zero_on_right_half_plane_of_superexponential_decay {E : Type u_1} [normed_group E] [normed_space ℂ E] {f : ℂ → E} (hd : diff_cont_on_cl ℂ f {z : ℂ | 0 < z.re}) (hexp : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ filter.principal {z : ℂ | 0 < z.re}] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hre : asymptotics.superpolynomial_decay filter.at_top real.exp (λ (x : ℝ), ∥f ↑x∥)) (him : ∃ (C : ℝ), ∀ (x : ℝ), ∥f (↑x * complex.I)∥ ≤ C) : set.eq_on f 0 {z : ℂ | 0 ≤ z.re}
theorem add_monoid_hom.map_real_smul {E : Type u_1} [add_comm_group E] [module ℝ E] [topological_space E] [has_continuous_smul ℝ E] {F : Type u_2} [add_comm_group F] [module ℝ F] [topological_space F] [has_continuous_smul ℝ F] [t2_space F] (f : E →+ F) (hf : continuous ⇑f) (c : ℝ) (x : E) : ⇑f (c • x) = c • ⇑f x
theorem category_theory.has_limit_of_created {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ⥤ C) (F : C ⥤ D) [category_theory.limits.has_limit (K ⋙ F)] [category_theory.creates_limit K F] : category_theory.limits.has_limit K
theorem polynomial.cyclotomic.monic (n : ℕ) (R : Type u_1) [ring R] : (polynomial.cyclotomic n R).monic
theorem not_and_distrib {a b : Prop} : ¬(a ∧ b) ↔ ¬a ∨ ¬b
theorem finsum_mem_insert_of_eq_zero_if_not_mem {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} {a : α} {s : set α} (h : a ∉ s → f a = 0) : finsum (λ (i : α), finsum (λ (H : i ∈ has_insert.insert a s), f i)) = finsum (λ (i : α), finsum (λ (H : i ∈ s), f i))
theorem prime_spectrum.gc (R : Type u) [comm_ring R] : galois_connection (λ (I : ideal R), prime_spectrum.zero_locus ↑I) (λ (t : (set (prime_spectrum R))ᵒᵈ), prime_spectrum.vanishing_ideal t)
theorem antilipschitz_with.le_mul_nndist {α : Type u_1} {β : Type u_2} [pseudo_metric_space α] [pseudo_metric_space β] {K : nnreal} {f : α → β} : antilipschitz_with K f → ∀ (x y : α), has_nndist.nndist x y ≤ K * has_nndist.nndist (f x) (f y)
theorem complex.has_strict_deriv_at_cosh (x : ℂ) : has_strict_deriv_at complex.cosh (complex.sinh x) x
theorem units.is_unit_units_mul {M : Type u_1} [monoid M] (u : Mˣ) (a : M) : is_unit (↑u * a) ↔ is_unit a
theorem measure_theory.measure.restrict_mono {α : Type u_1} {m0 : measurable_space α} ⦃s s' : set α⦄ (hs : s ⊆ s') ⦃μ ν : measure_theory.measure α⦄ (hμν : μ ≤ ν) : μ.restrict s ≤ ν.restrict s'
theorem modular_group.bottom_row_surj {R : Type u_1} [comm_ring R] : set.surj_on (λ (g : matrix.special_linear_group (fin 2) R), ↑g 1) set.univ {cd : fin 2 → R | is_coprime (cd 0) (cd 1)}
theorem one_lt_mul'' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
theorem measure_theory.is_stopping_time.measurable_set_lt_of_is_lub {α : Type u_1} {ι : Type u_3} {m : measurable_space α} [linear_order ι] {f : measure_theory.filtration ι m} {τ : α → ι} [topological_space ι] [order_topology ι] [topological_space.first_countable_topology ι] (hτ : measure_theory.is_stopping_time f τ) (i : ι) (h_lub : is_lub (set.Iio i) i) : measurable_set {x : α | τ x < i}
theorem is_semiring_hom.comp {α : Type u} {β : Type v} [semiring α] [semiring β] {f : α → β} (hf : is_semiring_hom f) {γ : Type u_1} [semiring γ] {g : β → γ} (hg : is_semiring_hom g) : is_semiring_hom (g ∘ f)
theorem complete_lattice.independent.sup_indep_univ {α : Type u_1} {ι : Type u_3} [complete_lattice α] [fintype ι] {f : ι → α} : complete_lattice.independent f → finset.univ.sup_indep f
theorem interval_integral.integral_has_fderiv_at {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (ha : continuous_at f a) (hb : continuous_at f b) : has_fderiv_at (λ (p : ℝ × ℝ), ∫ (x : ℝ) in p.fst..p.snd, f x) ((continuous_linear_map.snd ℝ ℝ ℝ).smul_right (f b) - (continuous_linear_map.fst ℝ ℝ ℝ).smul_right (f a)) (a, b)
theorem category_theory.cosimplicial_object.δ_comp_δ_self {C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) {n : ℕ} {i : fin (n + 2)} : X.δ i ≫ X.δ (⇑fin.cast_succ i) = X.δ i ≫ X.δ i.succ
theorem add_con.add_con_gen_mono {M : Type u_1} [has_add M] {r s : M → M → Prop} (h : ∀ (x y : M), r x y → s x y) : add_con_gen r ≤ add_con_gen s
theorem category_theory.finrank_hom_simple_simple_eq_zero_of_not_iso {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (𝕜 : Type u_3) [division_ring 𝕜] [category_theory.limits.has_kernels C] [category_theory.linear 𝕜 C] {X Y : C} [category_theory.simple X] [category_theory.simple Y] (h : (X ≅ Y) → false) : finite_dimensional.finrank 𝕜 (X ⟶ Y) = 0
theorem matrix.det_smul_inv_vec_mul_eq_cramer_transpose {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) (b : n → α) (h : is_unit A.det) : A.det • matrix.vec_mul b A⁻¹ = ⇑(A.transpose.cramer) b
theorem not_bdd_below_iff {α : Type u_1} [linear_order α] {s : set α} : ¬bdd_below s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), y < x
theorem fintype.card_fin_even {k : ℕ} : fact (even (fintype.card (fin (bit0 k))))
theorem zmod.χ₄_eq_neg_one_pow {n : ℕ} (hn : n % 2 = 1) : ⇑zmod.χ₄ ↑n = (-1) ^ (n / 2)
theorem basis.to_matrix_units_smul {ι : Type u_1} {R₂ : Type u_7} {M₂ : Type u_8} [comm_ring R₂] [add_comm_group M₂] [module R₂ M₂] [decidable_eq ι] (e : basis ι R₂ M₂) (w : ι → R₂ˣ) : e.to_matrix ⇑(e.units_smul w) = matrix.diagonal (coe ∘ w)
theorem is_compact.elim_finite_subfamily_closed {α : Type u} [topological_space α] {s : set α} {ι : Type v} (hs : is_compact s) (Z : ι → set α) (hZc : ∀ (i : ι), is_closed (Z i)) (hsZ : (s ∩ ⋂ (i : ι), Z i) = ∅) : ∃ (t : finset ι), (s ∩ ⋂ (i : ι) (H : i ∈ t), Z i) = ∅
theorem denumerable.raise_sorted (l : list ℕ) (n : ℕ) : list.sorted has_le.le (denumerable.raise l n)
theorem Mon.filtered_colimits.colimit_one_eq {J : Type v} [category_theory.small_category J] (F : J ⥤ Mon) [category_theory.is_filtered J] (j : J) : 1 = Mon.filtered_colimits.M.mk F ⟨j, 1⟩
theorem generalized_continued_fraction.nth_of_eq_some_of_succ_nth_int_fract_pair_stream {K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} {n : ℕ} {ifp_succ_n : generalized_continued_fraction.int_fract_pair K} (stream_succ_nth_eq : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n) : (generalized_continued_fraction.of v).s.nth n = option.some {a := 1, b := ↑(ifp_succ_n.b)}
theorem gram_schmidt_orthonormal (𝕜 : Type u_1) {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_3} [linear_order ι] [order_bot ι] [locally_finite_order ι] [is_well_order ι has_lt.lt] [succ_order ι] [is_succ_archimedean ι] (f : ι → E) (h₀ : linear_independent 𝕜 f) : orthonormal 𝕜 (gram_schmidt_normed 𝕜 f)
theorem monoid_hom.range_top_of_surjective {G : Type u_1} [group G] {N : Type u_2} [group N] (f : G →* N) (hf : function.surjective ⇑f) : f.range = ⊤
theorem is_right_regular.ne_zero {R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (ra : is_right_regular a) : a ≠ 0
theorem cont_diff_at.neg {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {x : E} {n : with_top ℕ} {f : E → F} (hf : cont_diff_at 𝕜 n f x) : cont_diff_at 𝕜 n (λ (x : E), -f x) x
theorem measure_theory.uniform_integrable_const {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [normed_group β] {p : ennreal} {g : α → β} (hp : 1 ≤ p) (hp_ne_top : p ≠ ⊤) (hgm : measure_theory.strongly_measurable g) (hg : measure_theory.mem_ℒp g p μ) : measure_theory.uniform_integrable (λ (n : ι), g) p μ
theorem measure_theory.Lp_meas_subgroup_to_Lp_trim_norm_map {α : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space α} {μ : measure_theory.measure α} [hp : fact (1 ≤ p)] (hm : m ≤ m0) (f : ↥(measure_theory.Lp_meas_subgroup F m p μ)) : ∥measure_theory.Lp_meas_subgroup_to_Lp_trim F p μ hm f∥ = ∥f∥
theorem is_noetherian.exists_endomorphism_iterate_ker_inf_range_eq_bot {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [I : is_noetherian R M] (f : M →ₗ[R] M) : ∃ (n : ℕ), n ≠ 0 ∧ (f ^ n).ker ⊓ (f ^ n).range = ⊥
theorem dite_comp_equiv_update {α : Type u_1} {β : Sort u_2} {γ : Sort u_3} {s : set α} (e : β ≃ ↥s) (v : β → γ) (w : α → γ) (j : β) (x : γ) [decidable_eq β] [decidable_eq α] [Π (j : α), decidable (j ∈ s)] : (λ (i : α), dite (i ∈ s) (λ (h : i ∈ s), function.update v j x (⇑(e.symm) ⟨i, h⟩)) (λ (h : i ∉ s), w i)) = function.update (λ (i : α), dite (i ∈ s) (λ (h : i ∈ s), v (⇑(e.symm) ⟨i, h⟩)) (λ (h : i ∉ s), w i)) ↑(⇑e j) x
theorem vitali_family.eventually_measure_lt_top {α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [measure_theory.is_locally_finite_measure μ] (x : α) : ∀ᶠ (a : set α) in v.filter_at x, ⇑μ a < ⊤
theorem con.lift_coe {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} {f : M →* P} (H : c ≤ con.ker f) (x : M) : ⇑(c.lift f H) ↑x = ⇑f x
theorem encodable.skolem {α : Type u_1} {β : α → Type u_2} {P : Π (x : α), β x → Prop} [c : Π (a : α), encodable (β a)] [d : Π (x : α) (y : β x), decidable (P x y)] : (∀ (x : α), ∃ (y : β x), P x y) ↔ ∃ (f : Π (a : α), β a), ∀ (x : α), P x (f x)
theorem orientation.two_zsmul_oangle_smul_left_self {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x : V) {r : ℝ} : 2 • o.oangle (r • x) x = 0
theorem real.smul_map_diagonal_volume_pi {ι : Type u_1} [fintype ι] [decidable_eq ι] {D : ι → ℝ} (h : (matrix.diagonal D).det ≠ 0) : ennreal.of_real |(matrix.diagonal D).det| • measure_theory.measure.map ⇑(⇑matrix.to_lin' (matrix.diagonal D)) measure_theory.measure_space.volume = measure_theory.measure_space.volume
theorem map_add_neg {G : Type u_6} {H : Type u_7} {F : Type u_8} [add_group G] [subtraction_monoid H] [add_monoid_hom_class F G H] (f : F) (a b : G) : ⇑f (a + -b) = ⇑f a + -⇑f b
theorem tot_sep_of_zero_dim {α : Type u} [topological_space α] [t2_space α] (h : topological_space.is_topological_basis {s : set α | is_clopen s}) : totally_separated_space α
theorem list.subperm.of_cons {α : Type uu} (a : α) {l₁ l₂ : list α} : a :: l₁ <+~ a :: l₂ → l₁ <+~ l₂
theorem monoid_hom.eq_on_inv {M : Type u_3} {F : Type u_8} {G : Type u_1} [group G] [monoid M] [monoid_hom_class F G M] {f g : F} {x : G} (h : ⇑f x = ⇑g x) : ⇑f x⁻¹ = ⇑g x⁻¹
theorem ideal_eq_zero_of_localization {R : Type u} [comm_ring R] (I : ideal R) (h : ∀ (J : ideal R) (hJ : J.is_maximal), is_localization.coe_submodule (localization.at_prime J) I = 0) : I = 0
theorem metric.bounded_of_compact_space {α : Type u} [pseudo_metric_space α] {s : set α} [compact_space α] : metric.bounded s
theorem power_series.coeff_mul_of_lt_order {R : Type u_1} [semiring R] {φ ψ : power_series R} {n : ℕ} (h : ↑n < ψ.order) : ⇑(power_series.coeff R n) (φ * ψ) = 0
theorem measure_theory.outer_measure.mk_metric_mono {X : Type u_2} [emetric_space X] {m₁ m₂ : ennreal → ennreal} (hle : m₁ ≤ᶠ[nhds_within 0 (set.Ici 0)] m₂) : measure_theory.outer_measure.mk_metric m₁ ≤ measure_theory.outer_measure.mk_metric m₂
theorem measure_theory.measure.map_eq_sum {α : Type u_1} {β : Type u_2} {m0 : measurable_space α} [measurable_space β] [encodable β] [measurable_singleton_class β] (μ : measure_theory.measure α) (f : α → β) (hf : measurable f) : measure_theory.measure.map f μ = measure_theory.measure.sum (λ (b : β), ⇑μ (f ⁻¹' {b}) • measure_theory.measure.dirac b)
theorem image_subobject_map_comp_image_to_kernel {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {A B C : V} {f : A ⟶ B} [category_theory.limits.has_image f] {g : B ⟶ C} [category_theory.limits.has_kernel g] (w : f ≫ g = 0) {A' B' C' : V} {f' : A' ⟶ B'} [category_theory.limits.has_image f'] {g' : B' ⟶ C'} [category_theory.limits.has_kernel g'] (w' : f' ≫ g' = 0) (α : category_theory.arrow.mk f ⟶ category_theory.arrow.mk f') [category_theory.limits.has_image_map α] (β : category_theory.arrow.mk g ⟶ category_theory.arrow.mk g') (p : α.right = β.left) : image_to_kernel f g w ≫ category_theory.limits.kernel_subobject_map β = category_theory.limits.image_subobject_map α ≫ image_to_kernel f' g' w'
theorem affine_map.ext {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] {f g : P1 →ᵃ[k] P2} (h : ∀ (p : P1), ⇑f p = ⇑g p) : f = g
theorem tendsto_measure_cthickening {α : Type u_1} [pseudo_metric_space α] [measurable_space α] [opens_measurable_space α] {μ : measure_theory.measure α} {s : set α} (hs : ∃ (R : ℝ) (H : R > 0), ⇑μ (metric.cthickening R s) ≠ ⊤) : filter.tendsto (λ (r : ℝ), ⇑μ (metric.cthickening r s)) (nhds 0) (nhds (⇑μ (closure s)))
theorem finset.Ioc_eq_empty {α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → finset.Ioc a b = ∅
theorem circle_integrable.out {E : Type u_1} [normed_group E] {f : ℂ → E} {c : ℂ} {R : ℝ} [normed_space ℂ E] (hf : circle_integrable f c R) : interval_integrable (λ (θ : ℝ), deriv (circle_map c R) θ • f (circle_map c R θ)) measure_theory.measure_space.volume 0 (2 * real.pi)
theorem setoid.classes_mk_classes {α : Type u_1} (c : set (set α)) (hc : setoid.is_partition c) : (setoid.mk_classes c _).classes = c
theorem mul_lt_of_lt_inv_mul {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : b < a⁻¹ * c → a * b < c
theorem disjoint.filter_principal {α : Type u_1} {s t : set α} : disjoint s t → disjoint (filter.principal s) (filter.principal t)
theorem list.eq_nil_of_prefix_nil {α : Type u_1} {l : list α} : l <+: list.nil → l = list.nil
theorem finsupp.sum_add_index {α : Type u_1} {M : Type u_5} {N : Type u_7} [add_zero_class M] [add_comm_monoid N] {f g : α →₀ M} {h : α → M → N} (h_zero : ∀ (a : α), a ∈ f.support ∪ g.support → h a 0 = 0) (h_add : ∀ (a : α), a ∈ f.support ∪ g.support → ∀ (b₁ b₂ : M), h a (b₁ + b₂) = h a b₁ + h a b₂) : (f + g).sum h = f.sum h + g.sum h
theorem category_theory.pi.has_limit_of_has_limit_comp_eval {I : Type v₁} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {J : Type v₁} [category_theory.small_category J] {F : J ⥤ Π (i : I), C i} [∀ (i : I), category_theory.limits.has_limit (F ⋙ category_theory.pi.eval C i)] : category_theory.limits.has_limit F
theorem ideal.exists_maximal (α : Type u) [semiring α] [nontrivial α] : ∃ (M : ideal α), M.is_maximal
theorem infi_eq_of_forall_ge_of_forall_gt_exists_lt {α : Type u_1} {ι : Sort u_4} [complete_lattice α] {b : α} {f : ι → α} (h₁ : ∀ (i : ι), b ≤ f i) (h₂ : ∀ (w : α), b < w → (∃ (i : ι), f i < w)) : (⨅ (i : ι), f i) = b
theorem set.image_image2_right_anticomm {α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {s : set α} {t : set β} {f : α → β' → γ} {g : β → β'} {f' : β → α → δ} {g' : δ → γ} (h_right_anticomm : ∀ (a : α) (b : β), f a (g b) = g' (f' b a)) : set.image2 f s (g '' t) = g' '' set.image2 f' t s
theorem real.cosh_pos (x : ℝ) : 0 < real.cosh x
theorem nat.prime.multiplicity_factorial_mul_succ {n p : ℕ} (hp : nat.prime p) : multiplicity p (p * (n + 1)).factorial = multiplicity p (p * n).factorial + multiplicity p (n + 1) + 1
theorem alternating_map.dom_coprod.summand_add_swap_smul_eq_zero {ιa : Type u_7} {ιb : Type u_8} [decidable_eq ιa] [decidable_eq ιb] [fintype ιa] [fintype ιb] {R' : Type u_9} {Mᵢ : Type u_10} {N₁ : Type u_11} {N₂ : Type u_12} [comm_semiring R'] [add_comm_group N₁] [module R' N₁] [add_comm_group N₂] [module R' N₂] [add_comm_monoid Mᵢ] [module R' Mᵢ] (a : alternating_map R' Mᵢ N₁ ιa) (b : alternating_map R' Mᵢ N₂ ιb) (σ : equiv.perm.mod_sum_congr ιa ιb) {v : ιa ⊕ ιb → Mᵢ} {i j : ιa ⊕ ιb} (hv : v i = v j) (hij : i ≠ j) : ⇑(alternating_map.dom_coprod.summand a b σ) v + ⇑(alternating_map.dom_coprod.summand a b (equiv.swap i j • σ)) v = 0
theorem has_deriv_at_exp_of_mem_ball {𝕂 : Type u_1} [nondiscrete_normed_field 𝕂] [complete_space 𝕂] [char_zero 𝕂] {x : 𝕂} (hx : x ∈ emetric.ball 0 (exp_series 𝕂 𝕂).radius) : has_deriv_at (exp 𝕂) (exp 𝕂 x) x
theorem is_regular_one {R : Type u_1} [mul_one_class R] : is_regular 1
theorem measure_theory.measure_lt_top_of_is_compact_of_is_mul_left_invariant {G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {μ : measure_theory.measure G} [group G] [topological_group G] [μ.is_mul_left_invariant] (U : set G) (hU : is_open U) (h'U : U.nonempty) (h : ⇑μ U ≠ ⊤) {K : set G} (hK : is_compact K) : ⇑μ K < ⊤
theorem affine_independent.injective {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} [nontrivial k] {p : ι → P} (ha : affine_independent k p) : function.injective p
theorem fermat_42.exists_pos_odd_minimal {a b c : ℤ} (h : fermat_42 a b c) : ∃ (a0 b0 c0 : ℤ), fermat_42.minimal a0 b0 c0 ∧ a0 % 2 = 1 ∧ 0 < c0
theorem monotone.add_strict_mono {α : Type u_1} {β : Type u_2} [has_add α] [preorder α] [preorder β] [covariant_class α α has_add.add has_lt.lt] [covariant_class α α (function.swap has_add.add) has_le.le] {f g : β → α} (hf : monotone f) (hg : strict_mono g) : strict_mono (λ (x : β), f x + g x)
theorem witt_vector.map_frobenius_poly.key₂ (p : ℕ) [hp : fact (nat.prime p)] {n i j : ℕ} (hi : i < n) (hj : j < p ^ (n - i)) : j - pnat_multiplicity p ⟨j + 1, _⟩ + n = i + j + (n - i - pnat_multiplicity p ⟨j + 1, _⟩)
theorem affine.simplex.face_points {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : ℕ} (s : affine.simplex k P n) {fs : finset (fin (n + 1))} {m : ℕ} (h : fs.card = m + 1) (i : fin (m + 1)) : (s.face h).points i = s.points (⇑(fs.order_emb_of_fin h) i)
theorem finset.affine_combination_linear {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (p : ι → P) : (s.affine_combination p).linear = s.weighted_vsub p
theorem measure_theory.simple_func.integral_eq_lintegral' {α : Type u_1} {E : Type u_2} [normed_group E] {m : measurable_space α} {μ : measure_theory.measure α} {f : measure_theory.simple_func α E} {g : E → ennreal} (hf : measure_theory.integrable ⇑f μ) (hg0 : g 0 = 0) (ht : ∀ (b : E), g b ≠ ⊤) : measure_theory.simple_func.integral μ (measure_theory.simple_func.map (ennreal.to_real ∘ g) f) = (∫⁻ (a : α), g (⇑f a) ∂μ).to_real
theorem box_integral.box_additive_map.sum_boxes_congr {ι : Type u_1} {M : Type u_2} [add_comm_monoid M] {I₀ : with_top (box_integral.box ι)} {I : box_integral.box ι} [fintype ι] (f : box_integral.box_additive_map ι M I₀) (hI : ↑I ≤ I₀) {π₁ π₂ : box_integral.prepartition I} (h : π₁.Union = π₂.Union) : π₁.boxes.sum (λ (J : box_integral.box ι), ⇑f J) = π₂.boxes.sum (λ (J : box_integral.box ι), ⇑f J)
theorem list.split_on_intercalate {α : Type u} (ls : list (list α)) [decidable_eq α] (x : α) (hx : ∀ (l : list α), l ∈ ls → x ∉ l) (hls : ls ≠ list.nil) : list.split_on x ([x].intercalate ls) = ls
theorem add_monoid_hom.map_sum {β : Type u} {α : Type v} {γ : Type w} [add_comm_monoid β] [add_comm_monoid γ] (g : β →+ γ) (f : α → β) (s : finset α) : ⇑g (s.sum (λ (x : α), f x)) = s.sum (λ (x : α), ⇑g (f x))
theorem category_theory.is_pullback.paste_vert {C : Type u₁} [category_theory.category C] {X₁₁ X₁₂ X₂₁ X₂₂ X₃₁ X₃₂ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₂₁ : X₂₁ ⟶ X₂₂} {h₃₁ : X₃₁ ⟶ X₃₂} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₂₁ : X₂₁ ⟶ X₃₁} {v₂₂ : X₂₂ ⟶ X₃₂} (s : category_theory.is_pullback h₁₁ v₁₁ v₁₂ h₂₁) (t : category_theory.is_pullback h₂₁ v₂₁ v₂₂ h₃₁) : category_theory.is_pullback h₁₁ (v₁₁ ≫ v₂₁) (v₁₂ ≫ v₂₂) h₃₁
theorem units.ne_zero {M₀ : Type u_1} [monoid_with_zero M₀] [nontrivial M₀] (u : M₀ˣ) : ↑u ≠ 0
theorem Top.presheaf.covering_of_presieve.second_obj_iso_pi_inters_π {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) (U : topological_space.opens ↥X) (R : category_theory.presieve U) (f g : Σ (V : topological_space.opens ↥X), {f // R f}) : (Top.presheaf.covering_of_presieve.second_obj_iso_pi_inters F U R).hom ≫ category_theory.limits.pi.π (λ (p : (Σ (V : topological_space.opens ↥X), {f // R f}) × Σ (V : topological_space.opens ↥X), {f // R f}), F.obj (opposite.op (Top.presheaf.covering_of_presieve U R p.fst ⊓ Top.presheaf.covering_of_presieve U R p.snd))) (f, g) = category_theory.limits.pi.π (λ (fg : (Σ (V : topological_space.opens ↥X), {f // R f}) × Σ (W : topological_space.opens ↥X), {g // R g}), F.obj (opposite.op (category_theory.limits.pullback fg.fst.snd.val fg.snd.snd.val))) (f, g) ≫ F.map (category_theory.eq_to_hom _).op
theorem category_theory.limits.has_binary_product.swap {C : Type u} [category_theory.category C] (P Q : C) [category_theory.limits.has_binary_product P Q] : category_theory.limits.has_binary_product Q P
theorem pgame.zero_lf {x : pgame} : 0.lf x ↔ ∃ (i : x.left_moves), ∀ (j : (x.move_left i).right_moves), 0.lf ((x.move_left i).move_right j)
theorem polynomial_functions_closure_eq_top'  : (polynomial_functions unit_interval).topological_closure = ⊤
theorem category_theory.abelian.functor.preserves_exact_of_preserves_finite_colimits_of_epi {C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (F : C ⥤ D) {X Y Z : C} {f : X ⟶ Y} {g : Y ⟶ Z} [category_theory.abelian C] [category_theory.abelian D] [F.additive] [category_theory.limits.preserves_finite_colimits F] [category_theory.epi g] (ex : category_theory.exact f g) : category_theory.exact (F.map f) (F.map g)
theorem affine.simplex.orthogonal_projection_eq_circumcenter_of_exists_dist_eq {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P n) {p : P} (hr : ∃ (r : ℝ), ∀ (i : fin (n + 1)), has_dist.dist (s.points i) p = r) : ↑(⇑(s.orthogonal_projection_span) p) = s.circumcenter
theorem map_lt_line_map_iff_slope_lt_slope_right {k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k → E} {a b r : k} (h : 0 < (1 - r) * (b - a)) : f (⇑(affine_map.line_map a b) r) < ⇑(affine_map.line_map (f a) (f b)) r ↔ slope f a b < slope f (⇑(affine_map.line_map a b) r) b
theorem function.embedding.antisymm {α : Type u} {β : Type v} : (α ↪ β) → (β ↪ α) → nonempty (α ≃ β)
theorem euclidean_geometry.angle_add_angle_add_angle_eq_pi {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h2 : p2 ≠ p1) (h3 : p3 ≠ p1) : euclidean_geometry.angle p1 p2 p3 + euclidean_geometry.angle p2 p3 p1 + euclidean_geometry.angle p3 p1 p2 = real.pi
theorem map_zpow {G : Type u_6} {H : Type u_7} {F : Type u_8} [group G] [division_monoid H] [monoid_hom_class F G H] (f : F) (g : G) (n : ℤ) : ⇑f (g ^ n) = ⇑f g ^ n
theorem bilin_form.is_Ortho.nondegenerate_iff_not_is_ortho_basis_self {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] {n : Type w} [nontrivial R] [no_zero_divisors R] (B : bilin_form R M) (v : basis n R M) (hO : B.is_Ortho ⇑v) : B.nondegenerate ↔ ∀ (i : n), ¬B.is_ortho (⇑v i) (⇑v i)
theorem is_closed_proj_of_is_compact {X : Type u_1} [topological_space X] [compact_space X] {Y : Type u_2} [topological_space Y] : is_closed_map prod.snd
theorem is_prime_pow_iff_unique_prime_dvd {n : ℕ} : is_prime_pow n ↔ ∃! (p : ℕ), nat.prime p ∧ p ∣ n
theorem function.is_fixed_pt_id {α : Type u} (x : α) : function.is_fixed_pt id x
theorem cont_diff_on_iff_ftaylor_series {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {n : with_top ℕ} : cont_diff 𝕜 n f ↔ has_ftaylor_series_up_to n f (ftaylor_series 𝕜 f)
theorem clifford_algebra.ι_sq_scalar {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (Q : quadratic_form R M) (m : M) : ⇑(clifford_algebra.ι Q) m * ⇑(clifford_algebra.ι Q) m = ⇑(algebra_map R (clifford_algebra Q)) (⇑Q m)
theorem normed_space.noncompact_space (𝕜 : Type u_5) (E : Type u_6) [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [nontrivial E] : noncompact_space E
theorem continuous_multilinear_map.continuous_eval {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] : continuous (λ (p : continuous_multilinear_map 𝕜 E G × Π (i : ι), E i), ⇑(p.fst) p.snd)
theorem measure_theory.exists_absolutely_continuous_is_finite_measure {α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) [measure_theory.sigma_finite μ] : ∃ (ν : measure_theory.measure α), measure_theory.is_finite_measure ν ∧ μ.absolutely_continuous ν
theorem add_monoid.is_torsion.torsion_eq_top {G : Type u_1} [add_comm_monoid G] (tG : add_monoid.is_torsion G) : add_comm_monoid.add_torsion G = ⊤
theorem add_con.ext {M : Type u_1} [has_add M] {c d : add_con M} (H : ∀ (x y : M), ⇑c x y ↔ ⇑d x y) : c = d
theorem algebra.norm_eq_zero_iff {K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] [finite_dimensional K L] {x : L} : ⇑(algebra.norm K) x = 0 ↔ x = 0
theorem real.sin_gt_sub_cube {x : ℝ} (h : 0 < x) (h' : x ≤ 1) : x - x ^ 3 / 4 < real.sin x
theorem nndist_eq_zero {γ : Type w} [metric_space γ] {x y : γ} : has_nndist.nndist x y = 0 ↔ x = y
theorem subfield.multiset_prod_mem {K : Type u} [field K] (s : subfield K) (m : multiset K) : (∀ (a : K), a ∈ m → a ∈ s) → m.prod ∈ s
theorem category_theory.limits.has_terminal_of_has_terminal_of_preserves_limit {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (G : C ⥤ D) [category_theory.limits.has_terminal C] [category_theory.limits.preserves_limit (category_theory.functor.empty C) G] : category_theory.limits.has_terminal D
theorem matrix.det_mul_column {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (v : n → R) (A : matrix n n R) : matrix.det (λ (i j : n), v i * A i j) = finset.univ.prod (λ (i : n), v i) * A.det
theorem lt_of_sub_pos {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : 0 < a - b → b < a
theorem zmod.legendre_sym_sq_one' (p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_sym p (a ^ 2) = 1
theorem measure_theory.unif_integrable_fintype {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} [fintype ι] (hp_one : 1 ≤ p) (hp_top : p ≠ ⊤) {f : ι → α → β} (hf : ∀ (i : ι), measure_theory.mem_ℒp (f i) p μ) : measure_theory.unif_integrable f p μ
theorem cardinal.mk_union_le {α : Type u} (S T : set α) : cardinal.mk ↥(S ∪ T) ≤ cardinal.mk ↥S + cardinal.mk ↥T
theorem nnreal.inner_le_Lp_mul_Lq {ι : Type u} (s : finset ι) (f g : ι → nnreal) {p q : ℝ} (hpq : p.is_conjugate_exponent q) : s.sum (λ (i : ι), f i * g i) ≤ s.sum (λ (i : ι), f i ^ p) ^ (1 / p) * s.sum (λ (i : ι), g i ^ q) ^ (1 / q)
theorem ideal.is_domain_map_C_quotient {R : Type u} [comm_ring R] {P : ideal R} (H : P.is_prime) : is_domain (polynomial R ⧸ ideal.map polynomial.C P)
theorem linear_independent_monoid_hom (G : Type u_1) [monoid G] (L : Type u_2) [comm_ring L] [no_zero_divisors L] : linear_independent L (λ (f : G →* L), ⇑f)
theorem order.cofinal_meets_ideal_of_cofinals {P : Type u_1} [preorder P] (p : P) {ι : Type u_2} [encodable ι] (𝒟 : ι → order.cofinal P) (i : ι) : ∃ (x : P), x ∈ 𝒟 i ∧ x ∈ order.ideal_of_cofinals p 𝒟
theorem linear_equiv.to_add_monoid_hom_commutes {R : Type u_1} {S : Type u_6} {M : Type u_7} {M₂ : Type u_9} [semiring R] [semiring S] [add_comm_monoid M] [add_comm_monoid M₂] {module_M : module R M} {module_S_M₂ : module S M₂} {σ : R →+* S} {σ' : S →+* R} {re₁ : ring_hom_inv_pair σ σ'} {re₂ : ring_hom_inv_pair σ' σ} (e : M ≃ₛₗ[σ] M₂) : e.to_linear_map.to_add_monoid_hom = e.to_add_equiv.to_add_monoid_hom
theorem set.countable_set_of_finite_subset {α : Type u} {s : set α} : s.countable → {t : set α | t.finite ∧ t ⊆ s}.countable
theorem linear_independent_le_basis {R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {ι : Type u_1} (b : basis ι R M) {κ : Type u_1} (v : κ → M) (i : linear_independent R v) : cardinal.mk κ ≤ cardinal.mk ι
theorem matrix.inv_of_eq_nonsing_inv {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) [invertible A] : ⅟ A = A⁻¹
theorem subfield.closure_mono {K : Type u} [field K] ⦃s t : set K⦄ (h : s ⊆ t) : subfield.closure s ≤ subfield.closure t
theorem category_theory.Ran_is_sheaf_of_cover_lifting.glued_section_is_amalgamation {C D : Type u} [category_theory.category C] [category_theory.category D] {A : Type w} [category_theory.category A] [category_theory.limits.has_limits A] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {G : C ⥤ D} (hu : category_theory.cover_lifting J K G) (ℱ : category_theory.Sheaf J A) {X : A} {U : D} {S : category_theory.sieve U} (hS : S ∈ ⇑K U) {x : category_theory.presieve.family_of_elements ((category_theory.Ran G.op).obj ℱ.val ⋙ category_theory.coyoneda.obj (opposite.op X)) S.arrows} (hx : x.compatible) : x.is_amalgamation (category_theory.Ran_is_sheaf_of_cover_lifting.glued_section hu ℱ hS hx)
theorem linear_map.trace_eq_contract' (R : Type u_1) [comm_ring R] (M : Type u_2) [add_comm_group M] [module R M] [module.free R M] [module.finite R M] [nontrivial R] : linear_map.trace R M = (contract_left R M).comp (dual_tensor_hom_equiv R M M).symm.to_linear_map
theorem formal_multilinear_series.norm_le_div_pow_of_pos_of_lt_radius {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) {r : nnreal} (h0 : 0 < r) (h : ↑r < p.radius) : ∃ (C : ℝ) (H : C > 0), ∀ (n : ℕ), ∥p n∥ ≤ C / ↑r ^ n
theorem valuation_ring.of_integers {𝒪 : Type u} {K : Type v} {Γ : Type w} [comm_ring 𝒪] [is_domain 𝒪] [field K] [algebra 𝒪 K] [linear_ordered_comm_group_with_zero Γ] (v : valuation K Γ) (hh : v.integers 𝒪) : valuation_ring 𝒪
theorem eq.absolutely_continuous {α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} (h : μ = ν) : μ.absolutely_continuous ν
theorem finset.sum_erase_add {β : Type u} {α : Type v} [add_comm_monoid β] [decidable_eq α] (s : finset α) (f : α → β) {a : α} (h : a ∈ s) : (s.erase a).sum (λ (x : α), f x) + f a = s.sum (λ (x : α), f x)
theorem finprod_mem_empty {α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M} : finprod (λ (i : α), finprod (λ (H : i ∈ ∅), f i)) = 1
theorem matrix.is_symm_diagonal {α : Type u_1} {n : Type u_3} [decidable_eq n] [has_zero α] (v : n → α) : (matrix.diagonal v).is_symm
theorem continuous_linear_equiv.cont_diff_on_comp_iff {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {s : set E} {f : E → F} {n : with_top ℕ} (e : G ≃L[𝕜] E) : cont_diff_on 𝕜 n (f ∘ ⇑e) (⇑e ⁻¹' s) ↔ cont_diff_on 𝕜 n f s
theorem zmod.cast_neg_one {R : Type u_1} [ring R] (n : ℕ) : ↑-1 = ↑n - 1
theorem filter.has_basis.restrict_subset {α : Type u_1} {ι : Sort u_4} {l : filter α} {p : ι → Prop} {s : ι → set α} (h : l.has_basis p s) {V : set α} (hV : V ∈ l) : l.has_basis (λ (i : ι), p i ∧ s i ⊆ V) s
theorem is_compact_iff_finite_subfamily_closed {α : Type u} [topological_space α] {s : set α} : is_compact s ↔ ∀ {ι : Type u} (Z : ι → set α), (∀ (i : ι), is_closed (Z i)) → (s ∩ ⋂ (i : ι), Z i) = ∅ → (∃ (t : finset ι), (s ∩ ⋂ (i : ι) (H : i ∈ t), Z i) = ∅)
theorem tendsto_inv_zero_at_top {α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] : filter.tendsto (λ (x : α), x⁻¹) (nhds_within 0 (set.Ioi 0)) filter.at_top
theorem affine.triangle.orthocenter_eq_monge_point {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle ℝ P) : t.orthocenter = affine.simplex.monge_point t
theorem function.injective.comp_left {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {g : β → γ} (hg : function.injective g) : function.injective (function.comp g)
theorem ae_eq_const_or_norm_average_lt_of_norm_le_const {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {f : α → E} {C : ℝ} [strict_convex_space ℝ E] (h_le : ∀ᵐ (x : α) ∂μ, ∥f x∥ ≤ C) : f =ᵐ[μ] function.const α (⨍ (x : α), f x ∂μ) ∨ ∥⨍ (x : α), f x ∂μ∥ < C
theorem pgame.numeric_to_pgame (o : ordinal) : o.to_pgame.numeric
theorem tendsto_uniformly_on.tendsto_comp {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {s : set α} {x : α} {p : filter ι} {g : ι → α} [topological_space α] (h : tendsto_uniformly_on F f p s) (hf : continuous_within_at f s x) (hg : filter.tendsto g p (nhds_within x s)) : filter.tendsto (λ (n : ι), F n (g n)) p (nhds (f x))
theorem interval_integral.integrable_on_deriv_of_nonneg {a b : ℝ} {g' g : ℝ → ℝ} (hab : a ≤ b) (hcont : continuous_on g (set.Icc a b)) (hderiv : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x) (g'pos : ∀ (x : ℝ), x ∈ set.Ioo a b → 0 ≤ g' x) : measure_theory.integrable_on g' (set.Ioc a b) measure_theory.measure_space.volume
theorem affine.simplex.circumcenter_circumradius_unique_dist_eq {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P n) : (s.circumcenter_circumradius.fst ∈ affine_span ℝ (set.range s.points) ∧ ∀ (i : fin (n + 1)), has_dist.dist (s.points i) s.circumcenter_circumradius.fst = s.circumcenter_circumradius.snd) ∧ ∀ (cccr : P × ℝ), (cccr.fst ∈ affine_span ℝ (set.range s.points) ∧ ∀ (i : fin (n + 1)), has_dist.dist (s.points i) cccr.fst = cccr.snd) → cccr = s.circumcenter_circumradius
theorem strict_mono_on.continuous_at_left_of_exists_between {α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_on f s) (hs : s ∈ nhds_within a (set.Iic a)) (hfs : ∀ (b : β), b < f a → (∃ (c : α) (H : c ∈ s), f c ∈ set.Ico b (f a))) : continuous_within_at f (set.Iic a) a
theorem minpoly.zero (A : Type u_1) (B : Type u_2) [field A] [ring B] [algebra A B] [nontrivial B] : minpoly A 0 = polynomial.X
theorem category_theory.triangulated.pretriangulated.comp_dist_triangle_mor_zero₁₂ (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C ℤ] [category_theory.preadditive C] [∀ (n : ℤ), (category_theory.shift_functor C n).additive] [category_theory.triangulated.pretriangulated C] (T : category_theory.triangulated.triangle C) (H : T ∈ dist_triang C) : T.mor₁ ≫ T.mor₂ = 0
theorem subgroup.supr_induction' {G : Type u_1} [group G] {ι : Sort u_2} (S : ι → subgroup G) {C : Π (x : G), (x ∈ ⨆ (i : ι), S i) → Prop} (hp : ∀ (i : ι) (x : G) (H : x ∈ S i), C x _) (h1 : C 1 _) (hmul : ∀ (x y : G) (hx : x ∈ ⨆ (i : ι), S i) (hy : y ∈ ⨆ (i : ι), S i), C x hx → C y hy → C (x * y) _) {x : G} (hx : x ∈ ⨆ (i : ι), S i) : C x hx
theorem real.arsinh_sinh (x : ℝ) : real.arsinh (real.sinh x) = x
theorem real.pi_upper_bound_start (n : ℕ) {a : ℝ} (h : 2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 ≤ real.sqrt_two_add_series (↑0 / ↑1) n) (h₂ : 1 / 4 ^ n ≤ a) : real.pi < a
theorem function.injective.subsingleton {α : Sort u} {β : Sort v} {f : α → β} (hf : function.injective f) [subsingleton β] : subsingleton α
theorem euclidean_geometry.dist_orthogonal_projection_ne_zero_of_not_mem {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} [nonempty ↥s] [complete_space ↥(s.direction)] {p : P} (hp : p ∉ s) : has_dist.dist p ↑(⇑(euclidean_geometry.orthogonal_projection s) p) ≠ 0
theorem nat.diag_induction (P : ℕ → ℕ → Prop) (ha : ∀ (a : ℕ), P (a + 1) (a + 1)) (hb : ∀ (b : ℕ), P 0 (b + 1)) (hd : ∀ (a b : ℕ), a < b → P (a + 1) b → P a (b + 1) → P (a + 1) (b + 1)) (a b : ℕ) : a < b → P a b
theorem vsub_left_injective {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (λ (_x : P), _x -ᵥ p)
theorem least_descending_central_series_length_eq_nilpotency_class {G : Type u_1} [group G] [hG : group.is_nilpotent G] : nat.find _ = group.nilpotency_class G
theorem monovary.sum_smul_comp_perm_eq_sum_smul_iff {ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {σ : equiv.perm ι} {f : ι → α} {g : ι → β} [fintype ι] (hfg : monovary f g) : finset.univ.sum (λ (i : ι), f i • g (⇑σ i)) = finset.univ.sum (λ (i : ι), f i • g i) ↔ monovary f (g ∘ ⇑σ)
theorem affine_independent.range {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} {p : ι → P} (ha : affine_independent k p) : affine_independent k (λ (x : ↥(set.range p)), ↑x)
theorem has_lt.lt.not_is_max {α : Type u_1} [preorder α] {a b : α} (h : a < b) : ¬is_max a
theorem box_integral.prepartition.inj_on_set_of_mem_Icc_set_of_lower_eq {ι : Type u_1} {I : box_integral.box ι} (π : box_integral.prepartition I) (x : ι → ℝ) : set.inj_on (λ (J : box_integral.box ι), {i : ι | J.lower i = x i}) {J : box_integral.box ι | J ∈ π ∧ x ∈ ⇑box_integral.box.Icc J}
theorem eq_of_deriv_within_eq {E : Type u_1} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} {g : ℝ → E} (fdiff : differentiable_on ℝ f (set.Icc a b)) (gdiff : differentiable_on ℝ g (set.Icc a b)) (hderiv : set.eq_on (deriv_within f (set.Icc a b)) (deriv_within g (set.Icc a b)) (set.Ico a b)) (hi : f a = g a) (y : ℝ) (H : y ∈ set.Icc a b) : f y = g y
theorem spectrum.map_polynomial_aeval_of_nonempty {𝕜 : Type u} {A : Type v} [field 𝕜] [ring A] [algebra 𝕜 A] [is_alg_closed 𝕜] [nontrivial A] (a : A) (p : polynomial 𝕜) (hnon : (spectrum 𝕜 a).nonempty) : spectrum 𝕜 (⇑(polynomial.aeval a) p) = (λ (k : 𝕜), polynomial.eval k p) '' spectrum 𝕜 a
theorem list.prod_inv_reverse {G : Type u_7} [group G] (L : list G) : (L.prod)⁻¹ = (list.map (λ (x : G), x⁻¹) L).reverse.prod
theorem strongly_measurable_iff_measurable_separable {α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] [topological_space.pseudo_metrizable_space β] [measurable_space β] [borel_space β] : measure_theory.strongly_measurable f ↔ measurable f ∧ topological_space.is_separable (set.range f)
theorem quaternion_group.order_of_a_one {n : ℕ} : order_of (quaternion_group.a 1) = 2 * n
theorem function.periodic.integral_le_Sup_add_zsmul_of_pos {T : ℝ} {g : ℝ → ℝ} (hg : function.periodic g T) (h_int : ∀ (t₁ t₂ : ℝ), interval_integrable g measure_theory.measure_space.volume t₁ t₂) (hT : 0 < T) (t : ℝ) : ∫ (x : ℝ) in 0..t, g x ≤ has_Sup.Sup ((λ (t : ℝ), ∫ (x : ℝ) in 0..t, g x) '' set.Icc 0 T) + ⌊t / T⌋ • ∫ (x : ℝ) in 0..T, g x
theorem upper_semicontinuous_at.add' {α : Type u_1} [topological_space α] {x : α} {γ : Type u_4} [linear_ordered_add_comm_monoid γ] [topological_space γ] [order_topology γ] {f g : α → γ} (hf : upper_semicontinuous_at f x) (hg : upper_semicontinuous_at g x) (hcont : continuous_at (λ (p : γ × γ), p.fst + p.snd) (f x, g x)) : upper_semicontinuous_at (λ (z : α), f z + g z) x
theorem is_localization.lift_mk' {R : Type u_1} [comm_semiring R] {M : submonoid R} {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] {g : R →+* P} (hg : ∀ (y : ↥M), is_unit (⇑g ↑y)) (x : R) (y : ↥M) : ⇑(is_localization.lift hg) (is_localization.mk' S x y) = ⇑g x * ↑(⇑(is_unit.lift_right (g.to_monoid_hom.restrict M) hg) y)⁻¹
theorem phragmen_lindelof.eq_zero_on_quadrant_III {E : Type u_1} [normed_group E] [normed_space ℂ E] {f : ℂ → E} (hd : diff_cont_on_cl ℂ f (set.Iio 0 ×ℂ set.Iio 0)) (hB : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ filter.principal (set.Iio 0 ×ℂ set.Iio 0)] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hre : ∀ (x : ℝ), x ≤ 0 → f ↑x = 0) (him : ∀ (x : ℝ), x ≤ 0 → f (↑x * complex.I) = 0) : set.eq_on f 0 {z : ℂ | z.re ≤ 0 ∧ z.im ≤ 0}
theorem measure_theory.lintegral_eq_zero_of_is_mul_left_invariant {G : Type u_4} [measurable_space G] {μ : measure_theory.measure G} [topological_space G] [group G] [topological_group G] [borel_space G] [μ.is_mul_left_invariant] [μ.regular] (hμ : μ ≠ 0) {f : G → ennreal} (hf : continuous f) : ∫⁻ (x : G), f x ∂μ = 0 ↔ f = 0
theorem function.cSup_div_semiconj {α : Type u_1} {G : Type u_4} [conditionally_complete_lattice α] [group G] (f₁ f₂ : G →* α ≃o α) (hbdd : ∀ (x : α), bdd_above (set.range (λ (g : G), ⇑(⇑f₁ g)⁻¹ (⇑(⇑f₂ g) x)))) (g : G) : function.semiconj (λ (x : α), ⨆ (g' : G), ⇑(⇑f₁ g')⁻¹ (⇑(⇑f₂ g') x)) ⇑(⇑f₂ g) ⇑(⇑f₁ g)
theorem tensor_product.algebra_tensor_module.curry_injective {R : Type u_1} {A : Type u_2} {M : Type u_3} {N : Type u_4} {P : Type u_5} [comm_semiring R] [semiring A] [algebra R A] [add_comm_monoid M] [module R M] [module A M] [is_scalar_tower R A M] [add_comm_monoid N] [module R N] [add_comm_monoid P] [module R P] [module A P] [is_scalar_tower R A P] : function.injective tensor_product.algebra_tensor_module.curry
theorem category_theory.id_has_right_lifting_property {C : Type u} [category_theory.category C] {X : C} (i : category_theory.arrow C) : category_theory.has_lifting_property i (category_theory.arrow.mk (𝟙 X))
theorem finset.bdd_above {α : Type u} [semilattice_sup α] [nonempty α] (s : finset α) : bdd_above ↑s
theorem matrix.coe_units_inv {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : (matrix n n α)ˣ) : ↑A⁻¹ = (↑A)⁻¹
theorem neg_convex_on_iff {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [ordered_add_comm_group β] [has_scalar 𝕜 E] [module 𝕜 β] {s : set E} {f : E → β} : convex_on 𝕜 s (-f) ↔ concave_on 𝕜 s f
theorem measure_theory.measure.mk_metric_mono {X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] {m₁ m₂ : ennreal → ennreal} (hle : m₁ ≤ᶠ[nhds_within 0 (set.Ici 0)] m₂) : measure_theory.measure.mk_metric m₁ ≤ measure_theory.measure.mk_metric m₂
theorem affine_subspace.direction_eq_top_iff_of_nonempty {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s : affine_subspace k P} (h : ↑s.nonempty) : s.direction = ⊤ ↔ s = ⊤
theorem add_subgroup.subset_closure {G : Type u_1} [add_group G] {k : set G} : k ⊆ ↑(add_subgroup.closure k)
theorem category_theory.is_reflexive_pair.swap {C : Type u} [category_theory.category C] {A B : C} {f g : A ⟶ B} [category_theory.is_reflexive_pair f g] : category_theory.is_reflexive_pair g f
theorem con.lift_comp_mk' {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} {f : M →* P} (H : c ≤ con.ker f) : (c.lift f H).comp c.mk' = f
theorem equiv.swap_mul_self_mul {α : Type u} [decidable_eq α] (i j : α) (σ : equiv.perm α) : equiv.swap i j * (equiv.swap i j * σ) = σ
theorem add_subgroup.ker_normed_mk {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) : S.normed_mk.ker = S
theorem mul_right_bound {α : Type u_1} [non_unital_semi_normed_ring α] (x y : α) : ∥⇑(add_monoid_hom.mul_right x) y∥ ≤ ∥x∥ * ∥y∥
theorem polynomial.separable_X_pow_sub_C_unit {R : Type u} [comm_ring R] {n : ℕ} (u : Rˣ) (hn : is_unit ↑n) : (polynomial.X ^ n - ⇑polynomial.C ↑u).separable
theorem subsingleton_of_forall_eq {α : Sort u_1} (x : α) (h : ∀ (y : α), y = x) : subsingleton α
theorem measure_theory.ae_restrict_interval_oc_iff {α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} [linear_order α] {a b : α} {P : α → Prop} : (∀ᵐ (x : α) ∂μ.restrict (set.interval_oc a b), P x) ↔ (∀ᵐ (x : α) ∂μ.restrict (set.Ioc a b), P x) ∧ ∀ᵐ (x : α) ∂μ.restrict (set.Ioc b a), P x
theorem concave_on.le_map_average {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {f : α → E} {g : E → ℝ} [measure_theory.is_finite_measure μ] (hg : concave_on ℝ s g) (hgc : continuous_on g s) (hsc : is_closed s) (hμ : μ ≠ 0) (hfs : ∀ᵐ (x : α) ∂μ, f x ∈ s) (hfi : measure_theory.integrable f μ) (hgi : measure_theory.integrable (g ∘ f) μ) : ⨍ (x : α), g (f x) ∂μ ≤ g (⨍ (x : α), f x ∂μ)
theorem list.take_sum_join {α : Type u_1} (L : list (list α)) (i : ℕ) : list.take (list.take i (list.map list.length L)).sum L.join = (list.take i L).join
theorem measure_theory.lintegral_add_right_eq_self {G : Type u_4} [measurable_space G] {μ : measure_theory.measure G} [add_group G] [has_measurable_add G] [μ.is_add_right_invariant] (f : G → ennreal) (g : G) : ∫⁻ (x : G), f (x + g) ∂μ = ∫⁻ (x : G), f x ∂μ
theorem field.localization_map_bijective {K : Type u_1} {Kₘ : Type u_2} [field K] [comm_ring Kₘ] {M : submonoid K} (hM : 0 ∉ M) [algebra K Kₘ] [is_localization M Kₘ] : function.bijective ⇑(algebra_map K Kₘ)
theorem continuous_linear_map.ext_on {R₁ : Type u_1} {R₂ : Type u_2} [semiring R₁] [semiring R₂] {σ₁₂ : R₁ →+* R₂} {M₁ : Type u_4} [topological_space M₁] [add_comm_monoid M₁] {M₂ : Type u_6} [topological_space M₂] [add_comm_monoid M₂] [module R₁ M₁] [module R₂ M₂] [t2_space M₂] {s : set M₁} (hs : dense ↑(submodule.span R₁ s)) {f g : M₁ →SL[σ₁₂] M₂} (h : set.eq_on ⇑f ⇑g s) : f = g
theorem is_add_submonoid.smul_mem {M : Type u_1} [add_monoid M] {s : set M} {a : M} (hs : is_add_submonoid s) (h : a ∈ s) {n : ℕ} : n • a ∈ s
theorem ideal.quotient_map_injective {R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] {I : ideal S} {f : R →+* S} : function.injective ⇑(I.quotient_map f le_rfl)
theorem intermediate_field.inv_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x : L} : x ∈ S → x⁻¹ ∈ S
theorem uniform_space.compact_iff_seq_compact {X : Type u_1} [uniform_space X] {s : set X} [(uniformity X).is_countably_generated] : is_compact s ↔ is_seq_compact s
theorem module.ray.some_ray_vector_ray {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : module.ray R M) : ⟦x.some_ray_vector⟧ = x
theorem lower_semicontinuous.add {α : Type u_1} [topological_space α] {γ : Type u_4} [linear_ordered_add_comm_monoid γ] [topological_space γ] [order_topology γ] [has_continuous_add γ] {f g : α → γ} (hf : lower_semicontinuous f) (hg : lower_semicontinuous g) : lower_semicontinuous (λ (z : α), f z + g z)
theorem one_lt_mul_of_lt_of_le' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 ≤ b) : 1 < a * b
theorem measurable.ite {α : Type u_1} {β : Type u_2} {f g : α → β} {m : measurable_space α} {mβ : measurable_space β} {p : α → Prop} {_x : decidable_pred p} (hp : measurable_set {a : α | p a}) (hf : measurable f) (hg : measurable g) : measurable (λ (x : α), ite (p x) (f x) (g x))
theorem nhds_basis_opens {α : Type u} [topological_space α] (a : α) : (nhds a).has_basis (λ (s : set α), a ∈ s ∧ is_open s) (λ (s : set α), s)
theorem function.periodic.exists_mem_Ico {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x a : α) : ∃ (y : α) (H : y ∈ set.Ico a (a + c)), f x = f y
theorem affine_equiv.affine_independent_set_of_eq_iff {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {V₂ : Type u_5} {P₂ : Type u_6} [add_comm_group V₂] [module k V₂] [add_torsor V₂ P₂] {s : set P} (e : P ≃ᵃ[k] P₂) : affine_independent k coe ↔ affine_independent k coe
theorem algebraic_topology.alternating_face_map_complex.d_squared {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (X : category_theory.simplicial_object C) (n : ℕ) : algebraic_topology.alternating_face_map_complex.obj_d X (n + 1) ≫ algebraic_topology.alternating_face_map_complex.obj_d X n = 0
theorem orthogonal_projection_eq_self_iff {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K : submodule 𝕜 E} [complete_space ↥K] {v : E} : ↑(⇑(orthogonal_projection K) v) = v ↔ v ∈ K
theorem measure_theory.mem_ℒp.snorm_indicator_le' {α : Type u_1} {β : Type u_2} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} {f : α → β} (hp_one : 1 ≤ p) (hp_top : p ≠ ⊤) (hf : measure_theory.mem_ℒp f p μ) (hmeas : measure_theory.strongly_measurable f) {ε : ℝ} (hε : 0 < ε) : ∃ (δ : ℝ) (hδ : 0 < δ), ∀ (s : set α), measurable_set s → ⇑μ s ≤ ennreal.of_real δ → measure_theory.snorm (s.indicator f) p μ ≤ 2 * ennreal.of_real ε
theorem normed_group.tendsto_at_top' {α : Type u_1} [nonempty α] [semilattice_sup α] [no_max_order α] {β : Type u_2} [semi_normed_group β] {f : α → β} {b : β} : filter.tendsto f filter.at_top (nhds b) ↔ ∀ (ε : ℝ), 0 < ε → (∃ (N : α), ∀ (n : α), N < n → ∥f n - b∥ < ε)
theorem asymptotics.is_O.of_norm_right {α : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : α → E} {g' : α → F'} {l : filter α} : (f =O[l] λ (x : α), ∥g' x∥) → f =O[l] g'
theorem category_theory.simple_of_cosimple {C : Type u} [category_theory.category C] [category_theory.abelian C] (X : C) (h : ∀ {Z : C} (f : X ⟶ Z) [_inst_3 : category_theory.epi f], category_theory.is_iso f ↔ f ≠ 0) : category_theory.simple X
theorem class_group.norm_lt {R : Type u_1} {S : Type u_2} [euclidean_domain R] [comm_ring S] [is_domain S] [algebra R S] (abv : absolute_value R ℤ) {ι : Type u_5} [decidable_eq ι] [fintype ι] (bS : basis ι R S) {T : Type u_3} [linear_ordered_ring T] (a : S) {y : T} (hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y) : ↑(⇑abv (⇑(algebra.norm R) a)) < ↑(class_group.norm_bound abv bS) * y ^ fintype.card ι
theorem finset.sum_centroid_weights_indicator_eq_one_of_card_eq_add_one (k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) [char_zero k] [fintype ι] {n : ℕ} (h : s.card = n + 1) : finset.univ.sum (λ (i : ι), finset.centroid_weights_indicator k s i) = 1
theorem is_add_submonoid.inter {M : Type u_1} [add_monoid M] {s₁ s₂ : set M} (is₁ : is_add_submonoid s₁) (is₂ : is_add_submonoid s₂) : is_add_submonoid (s₁ ∩ s₂)
theorem con.ext'_iff {M : Type u_1} [has_mul M] {c d : con M} : setoid.r = setoid.r ↔ c = d
theorem monoid_algebra.map_domain_mul {α : Type u_1} {β : Type u_2} {α₂ : Type u_3} [semiring β] [has_mul α] [has_mul α₂] {F : Type u_4} [mul_hom_class F α α₂] (f : F) (x y : monoid_algebra β α) : finsupp.map_domain ⇑f (x * y) = finsupp.map_domain ⇑f x * finsupp.map_domain ⇑f y
theorem dual_number.alg_hom_ext {R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] ⦃f g : dual_number R →ₐ[R] A⦄ (h : ⇑f dual_number.eps = ⇑g dual_number.eps) : f = g
theorem same_ray_neg_iff {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R (-x) (-y) ↔ same_ray R x y
theorem category_theory.is_filtered.of_equivalence {C : Type u} [category_theory.category C] [category_theory.is_filtered C] {D : Type u₁} [category_theory.category D] (h : C ≌ D) : category_theory.is_filtered D
theorem polynomial.gal.gal_action_hom_bijective_of_prime_degree' {p : polynomial ℚ} (p_irr : irreducible p) (p_deg : nat.prime p.nat_degree) (p_roots1 : fintype.card ↥(p.root_set ℝ) + 1 ≤ fintype.card ↥(p.root_set ℂ)) (p_roots2 : fintype.card ↥(p.root_set ℂ) ≤ fintype.card ↥(p.root_set ℝ) + 3) : function.bijective ⇑(polynomial.gal.gal_action_hom p ℂ)
theorem measure_theory.measure.weakly_regular.restrict_of_measurable_set {α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [borel_space α] [μ.weakly_regular] (A : set α) (hA : measurable_set A) (h'A : ⇑μ A ≠ ⊤) : (μ.restrict A).weakly_regular
theorem add_subgroup.cyclic_of_min {G : Type u_1} [linear_ordered_add_comm_group G] [archimedean G] {H : add_subgroup G} {a : G} (ha : is_least {g : G | g ∈ H ∧ 0 < g} a) : H = add_subgroup.closure {a}
theorem left.add_neg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0
theorem norm_mk_lt {M : Type u_1} [semi_normed_group M] {S : add_subgroup M} (x : M ⧸ S) {ε : ℝ} (hε : 0 < ε) : ∃ (m : M), ⇑(quotient_add_group.mk' S) m = x ∧ ∥m∥ < ∥x∥ + ε
theorem liouville.liouville_number_rat_initial_terms {m : ℕ} (hm : 0 < m) (k : ℕ) : ∃ (p : ℕ), liouville.liouville_number_initial_terms ↑m k = ↑p / ↑m ^ k.factorial
theorem continuous_on.integrable_on_compact {X : Type u_1} {E : Type u_3} [measurable_space X] [topological_space X] [normed_group E] {f : X → E} {μ : measure_theory.measure X} [opens_measurable_space X] [topological_space.metrizable_space X] [measure_theory.is_locally_finite_measure μ] {K : set X} (hK : is_compact K) (hf : continuous_on f K) : measure_theory.integrable_on f K μ
theorem is_bot.of_dual {α : Type u_1} [has_le α] {a : αᵒᵈ} : is_bot a → is_top (⇑order_dual.of_dual a)
theorem ext_chart_preimage_mem_nhds_within' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] (x : M) {s t : set M} {x' : M} (h : x' ∈ (ext_chart_at I x).source) (ht : t ∈ nhds_within x' s) : ⇑((ext_chart_at I x).symm) ⁻¹' t ∈ nhds_within (⇑(ext_chart_at I x) x') (⇑((ext_chart_at I x).symm) ⁻¹' s ∩ set.range ⇑I)
theorem category_theory.limits.trident.is_limit.hom_iso_natural {J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J → (X ⟶ Y)} [nonempty J] {t : category_theory.limits.trident f} (ht : category_theory.limits.is_limit t) {Z Z' : C} (q : Z' ⟶ Z) (k : Z ⟶ t.X) : ↑(⇑(category_theory.limits.trident.is_limit.hom_iso ht Z') (q ≫ k)) = q ≫ ↑(⇑(category_theory.limits.trident.is_limit.hom_iso ht Z) k)
theorem monotone.pairwise_disjoint_on_Ico_pred {α : Type u_1} {β : Type u_2} [linear_order α] [pred_order α] [preorder β] {f : α → β} (hf : monotone f) : pairwise (disjoint on λ (n : α), set.Ico (f (order.pred n)) (f n))
theorem ring_hom.map_multiset_prod {β : Type u} {γ : Type w} [comm_semiring β] [comm_semiring γ] (f : β →+* γ) (s : multiset β) : ⇑f s.prod = (multiset.map ⇑f s).prod
theorem power_series.order_zero {R : Type u_1} [semiring R] : 0.order = ⊤
theorem tangent_bundle.tangent_map_tangent_bundle_pure {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] (p : tangent_bundle I M) : tangent_map I I.tangent (tangent_bundle.zero_section I M) p = ⟨⟨p.fst, 0⟩, (p.snd, 0)⟩
theorem is_of_fin_order.apply {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_order x) (i : η) : is_of_fin_order (x i)
theorem filter.tendsto.at_bot_div_const {α : Type u_3} {β : Type u_4} [linear_ordered_field α] {l : filter β} {f : β → α} {r : α} (hr : 0 < r) (hf : filter.tendsto f l filter.at_bot) : filter.tendsto (λ (x : β), f x / r) l filter.at_bot
theorem is_add_monoid_hom.map_add {α : Type u} {β : Type v} [add_zero_class α] [add_zero_class β] {f : α → β} (hf : is_add_monoid_hom f) (x y : α) : f (x + y) = f x + f y
theorem add_monoid_hom.map_closure {G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (f : G →+ N) (s : set G) : add_subgroup.map f (add_subgroup.closure s) = add_subgroup.closure (⇑f '' s)
theorem norm_add_sq_real {F : Type u_3} [inner_product_space ℝ F] {x y : F} : ∥x + y∥ ^ 2 = ∥x∥ ^ 2 + 2 * has_inner.inner x y + ∥y∥ ^ 2
theorem convex.add_smul_sub_mem_interior {E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) {x y : E} (hx : x ∈ s) (hy : y ∈ interior s) {t : 𝕜} (ht : t ∈ set.Ioc 0 1) : x + t • (y - x) ∈ interior s
theorem cont_diff_at_ring_inverse (𝕜 : Type u_1) [nondiscrete_normed_field 𝕜] {n : with_top ℕ} {R : Type u_6} [normed_ring R] [normed_algebra 𝕜 R] [complete_space R] (x : Rˣ) : cont_diff_at 𝕜 n ring.inverse ↑x
theorem localization.at_prime.map_eq_maximal_ideal {R : Type u_1} [comm_semiring R] {I : ideal R} [hI : I.is_prime] : ideal.map (algebra_map R (localization.at_prime I)) I = local_ring.maximal_ideal (localization I.prime_compl)
theorem subfield.inv_mem {K : Type u} [field K] (s : subfield K) {x : K} : x ∈ s → x⁻¹ ∈ s
theorem measure_theory.lintegral_mul_left_eq_self {G : Type u_4} [measurable_space G] {μ : measure_theory.measure G} [group G] [has_measurable_mul G] [μ.is_mul_left_invariant] (f : G → ennreal) (g : G) : ∫⁻ (x : G), f (g * x) ∂μ = ∫⁻ (x : G), f x ∂μ
theorem polynomial.is_coprime_of_is_root_of_eval_derivative_ne_zero {K : Type u_1} [field K] (f : polynomial K) (a : K) (hf' : polynomial.eval a (⇑polynomial.derivative f) ≠ 0) : is_coprime (polynomial.X - ⇑polynomial.C a) (f /ₘ (polynomial.X - ⇑polynomial.C a))
theorem Top.presheaf.is_sheaf_iff_is_sheaf_unique_gluing {C : Type u} [category_theory.category C] [category_theory.concrete_category C] [category_theory.limits.has_limits C] [category_theory.reflects_isomorphisms (category_theory.forget C)] [category_theory.limits.preserves_limits (category_theory.forget C)] {X : Top} (F : Top.presheaf C X) : F.is_sheaf ↔ F.is_sheaf_unique_gluing
theorem same_ray.pos_smul_right {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} {r : R} (h : same_ray R x y) (hr : 0 < r) : same_ray R x (r • y)
theorem continuous_on.is_separable_image {α : Type u} {β : Type v} [pseudo_metric_space α] [topological_space β] {f : α → β} {s : set α} (hf : continuous_on f s) (hs : topological_space.is_separable s) : topological_space.is_separable (f '' s)
theorem inner_product_space.is_self_adjoint.restrict_invariant {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {T : E →ₗ[𝕜] E} (hT : inner_product_space.is_self_adjoint T) {V : submodule 𝕜 E} (hV : ∀ (v : E), v ∈ V → ⇑T v ∈ V) : inner_product_space.is_self_adjoint (T.restrict hV)
theorem topological_space.is_topological_basis.mem_nhds_iff {α : Type u} [t : topological_space α] {a : α} {s : set α} {b : set (set α)} (hb : topological_space.is_topological_basis b) : s ∈ nhds a ↔ ∃ (t : set α) (H : t ∈ b), a ∈ t ∧ t ⊆ s
theorem simplex_category.δ_comp_σ_succ {n : ℕ} {i : fin (n + 1)} : simplex_category.δ i.succ ≫ simplex_category.σ i = 𝟙 (simplex_category.mk n)
theorem upper_central_series_step_eq_comap_center {G : Type u_1} [group G] (H : subgroup G) [H.normal] : upper_central_series_step H = subgroup.comap (quotient_group.mk' H) (subgroup.center (G ⧸ H))
theorem collinear_iff_finrank_le_one (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) [finite_dimensional k ↥(vector_span k s)] : collinear k s ↔ finite_dimensional.finrank k ↥(vector_span k s) ≤ 1
theorem pow_two_pos_of_ne_zero {R : Type u_4} [linear_ordered_ring R] (a : R) (h : a ≠ 0) : 0 < a ^ 2
theorem vector.to_list_reverse {n : ℕ} {α : Type u_1} {v : vector α n} : v.reverse.to_list = v.to_list.reverse
theorem linear_map.bijective_or_eq_zero {R : Type u_1} [ring R] {M : Type u_2} [add_comm_group M] [module R M] {N : Type u_3} [add_comm_group N] [module R N] [is_simple_module R M] [is_simple_module R N] (f : M →ₗ[R] N) : function.bijective ⇑f ∨ f = 0
theorem tendsto_self_mul_const_pow_of_lt_one {r : ℝ} (hr : 0 ≤ r) (h'r : r < 1) : filter.tendsto (λ (n : ℕ), ↑n * r ^ n) filter.at_top (nhds 0)
theorem algebra.discr_mul_is_integral_mem_adjoin (K : Type u) {L : Type v} [field K] [field L] [algebra K L] [module.finite K L] {R : Type z} [comm_ring R] [algebra R K] [algebra R L] [is_scalar_tower R K L] [is_domain R] [is_separable K L] [is_integrally_closed R] [is_fraction_ring R K] {B : power_basis K L} (hint : is_integral R B.gen) {z : L} (hz : is_integral R z) : algebra.discr K ⇑(B.basis) • z ∈ algebra.adjoin R {B.gen}
theorem metric.sigma.complete_space {ι : Type u_1} {E : ι → Type u_2} [Π (i : ι), metric_space (E i)] [∀ (i : ι), complete_space (E i)] : complete_space (Σ (i : ι), E i)
theorem injective_iff_map_eq_one {F : Type u_8} {G : Type u_1} {H : Type u_2} [group G] [mul_one_class H] [monoid_hom_class F G H] (f : F) : function.injective ⇑f ↔ ∀ (a : G), ⇑f a = 1 → a = 1
theorem asymptotics.is_o_of_tendsto {α : Type u_1} {𝕜 : Type u_14} [normed_field 𝕜] {l : filter α} {f g : α → 𝕜} (hgf : ∀ (x : α), g x = 0 → f x = 0) : filter.tendsto (λ (x : α), f x / g x) l (nhds 0) → f =o[l] g
theorem phragmen_lindelof.eq_zero_on_quadrant_IV {E : Type u_1} [normed_group E] [normed_space ℂ E] {f : ℂ → E} (hd : diff_cont_on_cl ℂ f (set.Ioi 0 ×ℂ set.Iio 0)) (hB : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ filter.principal (set.Ioi 0 ×ℂ set.Iio 0)] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hre : ∀ (x : ℝ), 0 ≤ x → f ↑x = 0) (him : ∀ (x : ℝ), x ≤ 0 → f (↑x * complex.I) = 0) : set.eq_on f 0 {z : ℂ | 0 ≤ z.re ∧ z.im ≤ 0}
theorem joined_in.joined_subtype {X : Type u_1} [topological_space X] {x y : X} {F : set X} (h : joined_in F x y) : joined ⟨x, _⟩ ⟨y, _⟩
theorem measure_theory.signed_measure.exists_is_compl_positive_negative {α : Type u_1} [measurable_space α] (s : measure_theory.signed_measure α) : ∃ (i j : set α), measurable_set i ∧ 0.restrict i ≤ measure_theory.vector_measure.restrict s i ∧ measurable_set j ∧ measure_theory.vector_measure.restrict s j ≤ 0.restrict j ∧ is_compl i j
theorem measurable.comap_le {α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : measurable f → measurable_space.comap f m₂ ≤ m₁
theorem emetric.cauchy_seq_iff_nnreal {α : Type u} {β : Type v} [pseudo_emetric_space α] [nonempty β] [semilattice_sup β] {u : β → α} : cauchy_seq u ↔ ∀ (ε : nnreal), 0 < ε → (∃ (N : β), ∀ (n : β), N ≤ n → has_edist.edist (u n) (u N) < ↑ε)
theorem ideal.quotient.mkₐ_ker (R₁ : Type u_3) {A : Type u_5} [comm_semiring R₁] [comm_ring A] [algebra R₁ A] (I : ideal A) : ↑(ideal.quotient.mkₐ R₁ I).ker = I
theorem analytic_on.fderiv {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {s : set E} [complete_space F] (h : analytic_on 𝕜 f s) : analytic_on 𝕜 (fderiv 𝕜 f) s
theorem affine_independent_iff_finrank_vector_span_eq (k : Type u_1) {V : Type u_2} {P : Type u_3} {ι : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype ι] (p : ι → P) {n : ℕ} (hc : fintype.card ι = n + 1) : affine_independent k p ↔ finite_dimensional.finrank k ↥(vector_span k (set.range p)) = n
theorem le_sub_left_of_add_le {α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : a + b ≤ c → b ≤ c - a
theorem subring.subset_closure {R : Type u} [ring R] {s : set R} : s ⊆ ↑(subring.closure s)
theorem phragmen_lindelof.eq_on_quadrant_I {E : Type u_1} [normed_group E] [normed_space ℂ E] {f g : ℂ → E} (hdf : diff_cont_on_cl ℂ f (set.Ioi 0 ×ℂ set.Ioi 0)) (hBf : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ filter.principal (set.Ioi 0 ×ℂ set.Ioi 0)] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hdg : diff_cont_on_cl ℂ g (set.Ioi 0 ×ℂ set.Ioi 0)) (hBg : ∃ (c : ℝ) (H : c < 2) (B : ℝ), g =O[filter.comap complex.abs filter.at_top ⊓ filter.principal (set.Ioi 0 ×ℂ set.Ioi 0)] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hre : ∀ (x : ℝ), 0 ≤ x → f ↑x = g ↑x) (him : ∀ (x : ℝ), 0 ≤ x → f (↑x * complex.I) = g (↑x * complex.I)) : set.eq_on f g {z : ℂ | 0 ≤ z.re ∧ 0 ≤ z.im}
theorem vector_span_eq_span_vsub_set_right (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p : P} (hp : p ∈ s) : vector_span k s = submodule.span k ((λ (_x : P), _x -ᵥ p) '' s)
theorem generalized_continued_fraction.exists_int_eq_of_part_denom {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {b : K} (nth_part_denom_eq : (generalized_continued_fraction.of v).partial_denominators.nth n = option.some b) : ∃ (z : ℤ), b = ↑z
theorem vitali_family.ae_tendsto_rn_deriv_of_absolutely_continuous {α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {ρ : measure_theory.measure α} [measure_theory.is_locally_finite_measure ρ] (hρ : ρ.absolutely_continuous μ) : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (a : set α), ⇑ρ a / ⇑μ a) (v.filter_at x) (nhds (ρ.rn_deriv μ x))
theorem polynomial.chebyshev.mul_T (R : Type u_1) [comm_ring R] (m k : ℕ) : 2 * polynomial.chebyshev.T R m * polynomial.chebyshev.T R (m + k) = polynomial.chebyshev.T R (2 * m + k) + polynomial.chebyshev.T R k
theorem vitali_family.measure_le_of_frequently_le {α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] {ρ : measure_theory.measure α} (ν : measure_theory.measure α) [measure_theory.is_locally_finite_measure ν] (hρ : ρ.absolutely_continuous μ) (s : set α) (hs : ∀ (x : α), x ∈ s → (∃ᶠ (a : set α) in v.filter_at x, ⇑ρ a ≤ ⇑ν a)) : ⇑ρ s ≤ ⇑ν s
theorem algebraic_topology.dold_kan.map_Hσ {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] {D : Type u_3} [category_theory.category D] [category_theory.preadditive D] (G : C ⥤ D) [G.additive] (X : category_theory.simplicial_object C) (q n : ℕ) : (algebraic_topology.dold_kan.Hσ q).f n = G.map ((algebraic_topology.dold_kan.Hσ q).f n)
theorem category_theory.limits.pullback.hom_ext {C : Type u} [category_theory.category C] {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} [category_theory.limits.has_pullback f g] {W : C} {k l : W ⟶ category_theory.limits.pullback f g} (h₀ : k ≫ category_theory.limits.pullback.fst = l ≫ category_theory.limits.pullback.fst) (h₁ : k ≫ category_theory.limits.pullback.snd = l ≫ category_theory.limits.pullback.snd) : k = l
theorem category_theory.is_cofiltered.of_left_adjoint {C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] {D : Type u₁} [category_theory.category D] {L : C ⥤ D} {R : D ⥤ C} (h : L ⊣ R) : category_theory.is_cofiltered D
theorem con.lift_unique {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} {f : M →* P} (H : c ≤ con.ker f) (g : c.quotient →* P) (Hg : g.comp c.mk' = f) : g = c.lift f H
theorem mem_upper_central_series_succ_iff (G : Type u_1) [group G] (n : ℕ) (x : G) : x ∈ upper_central_series G (n + 1) ↔ ∀ (y : G), x * y * x⁻¹ * y⁻¹ ∈ upper_central_series G n
theorem zmod.legendre_sym_mul (p : ℕ) [fact (nat.prime p)] (a b : ℤ) : zmod.legendre_sym p (a * b) = zmod.legendre_sym p a * zmod.legendre_sym p b
theorem bilin_form.is_compl_span_singleton_orthogonal {V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] {B : bilin_form K V} {x : V} (hx : ¬B.is_ortho x x) : is_compl (submodule.span K {x}) (B.orthogonal (submodule.span K {x}))
theorem is_right_regular.mul {R : Type u_1} {a b : R} [semigroup R] (rra : is_right_regular a) (rrb : is_right_regular b) : is_right_regular (a * b)
theorem exists_countable_dense_no_bot_top (α : Type u) [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] [topological_space.separable_space α] [nontrivial α] : ∃ (s : set α), s.countable ∧ dense s ∧ (∀ (x : α), is_bot x → x ∉ s) ∧ ∀ (x : α), is_top x → x ∉ s
theorem module.End.exp_ne_zero_of_has_generalized_eigenvalue {R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {μ : R} {k : ℕ} (h : f.has_generalized_eigenvalue μ k) : k ≠ 0
theorem mul_sub_le_image_sub_of_le_deriv {f : ℝ → ℝ} (hf : differentiable ℝ f) {C : ℝ} (hf'_ge : ∀ (x : ℝ), C ≤ deriv f x) ⦃x y : ℝ⦄ (hxy : x ≤ y) : C * (y - x) ≤ f y - f x
theorem category_theory.subobject.eq_mk_of_comm {C : Type u₁} [category_theory.category C] {B A : C} {X : category_theory.subobject B} (f : A ⟶ B) [category_theory.mono f] (i : ↑X ≅ A) (w : i.hom ≫ f = X.arrow) : X = category_theory.subobject.mk f
theorem category_theory.limits.has_colimit_of_has_limit_left_op {C : Type u₁} [category_theory.category C] {J : Type u₂} [category_theory.category J] (F : J ⥤ Cᵒᵖ) [category_theory.limits.has_limit F.left_op] : category_theory.limits.has_colimit F
theorem matrix.det_mul_row {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (v : n → R) (A : matrix n n R) : matrix.det (λ (i j : n), v j * A i j) = finset.univ.prod (λ (i : n), v i) * A.det
theorem besicovitch.exists_good_δ (E : Type u_1) [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] : ∃ (δ : ℝ), 0 < δ ∧ δ < 1 ∧ ∀ (s : finset E), (∀ (c : E), c ∈ s → ∥c∥ ≤ 2) → (∀ (c : E), c ∈ s → ∀ (d : E), d ∈ s → c ≠ d → 1 - δ ≤ ∥c - d∥) → s.card ≤ besicovitch.multiplicity E
theorem nat.prime_pow_prime_divisor {p k : ℕ} (hk : k ≠ 0) (hp : nat.prime p) : (p ^ k).factors.to_finset = {p}
theorem emetric.edist_le_diam_of_mem {α : Type u} [pseudo_emetric_space α] {x y : α} {s : set α} (hx : x ∈ s) (hy : y ∈ s) : has_edist.edist x y ≤ emetric.diam s
theorem category_theory.is_pullback.of_right {C : Type u₁} [category_theory.category C] {X₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₁₂ : X₁₂ ⟶ X₁₃} {h₂₁ : X₂₁ ⟶ X₂₂} {h₂₂ : X₂₂ ⟶ X₂₃} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₁₃ : X₁₃ ⟶ X₂₃} (s : category_theory.is_pullback (h₁₁ ≫ h₁₂) v₁₁ v₁₃ (h₂₁ ≫ h₂₂)) (p : h₁₁ ≫ v₁₂ = v₁₁ ≫ h₂₁) (t : category_theory.is_pullback h₁₂ v₁₂ v₁₃ h₂₂) : category_theory.is_pullback h₁₁ v₁₁ v₁₂ h₂₁
theorem setoid.eqv_classes_disjoint {α : Type u_1} {c : set (set α)} (H : ∀ (a : α), ∃! (b : set α) (H : b ∈ c), a ∈ b) : c.pairwise_disjoint id
theorem exp_neg_inv_glue.pos_of_pos {x : ℝ} (hx : 0 < x) : 0 < exp_neg_inv_glue x
theorem witt_vector.discrete_valuation_ring {p : ℕ} [hp : fact (nat.prime p)] {k : Type u_1} [field k] [char_p k p] [perfect_ring k p] : discrete_valuation_ring (witt_vector p k)
theorem add_monoid_algebra.non_unital_alg_hom_ext' (k : Type u₁) {G : Type u₂} [semiring k] [has_add G] {A : Type u₃} [non_unital_non_assoc_semiring A] [distrib_mul_action k A] {φ₁ φ₂ : add_monoid_algebra k G →ₙₐ[k] A} (h : φ₁.to_mul_hom.comp (add_monoid_algebra.of_magma k G) = φ₂.to_mul_hom.comp (add_monoid_algebra.of_magma k G)) : φ₁ = φ₂
theorem finset.filter_true_of_mem {α : Type u_1} {p : α → Prop} [decidable_pred p] {s : finset α} (h : ∀ (x : α), x ∈ s → p x) : finset.filter p s = s
theorem cardinal.aleph_0_le_mul_iff {a b : cardinal} : cardinal.aleph_0 ≤ a * b ↔ a ≠ 0 ∧ b ≠ 0 ∧ (cardinal.aleph_0 ≤ a ∨ cardinal.aleph_0 ≤ b)
theorem category_theory.tensor_right_hom_equiv_tensor {C : Type u₁} [category_theory.category C] [category_theory.monoidal_category C] {X X' Y Y' Z Z' : C} [category_theory.exact_pairing Y Y'] (f : X ⟶ Z ⊗ Y') (g : X' ⟶ Z') : ⇑((category_theory.tensor_right_hom_equiv (X' ⊗ X) Y Y' (Z' ⊗ Z)).symm) ((g ⊗ f) ≫ (α_ Z' Z Y').inv) = (α_ X' X Y).hom ≫ (g ⊗ ⇑((category_theory.tensor_right_hom_equiv X Y Y' Z).symm) f)
theorem measure_theory.condexp_ae_eq_restrict_of_measurable_space_eq_on {α : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space ℝ F'] [complete_space F'] {f : α → F'} {s : set α} {m m₂ m0 : measurable_space α} {μ : measure_theory.measure α} (hm : m ≤ m0) (hm₂ : m₂ ≤ m0) [measure_theory.sigma_finite (μ.trim hm)] [measure_theory.sigma_finite (μ.trim hm₂)] (hs_m : measurable_set s) (hs : ∀ (t : set α), measurable_set (s ∩ t) ↔ measurable_set (s ∩ t)) : measure_theory.condexp m μ f =ᵐ[μ.restrict s] measure_theory.condexp m₂ μ f
theorem dense_Union_interior_of_closed {α : Type u_1} {β : Type u_2} [topological_space α] [baire_space α] [encodable β] {f : β → set α} (hc : ∀ (s : β), is_closed (f s)) (hU : (⋃ (s : β), f s) = set.univ) : dense (⋃ (s : β), interior (f s))
theorem squeeze_zero_norm {α : Type u_1} {E : Type u_3} [semi_normed_group E] {f : α → E} {g : α → ℝ} {t₀ : filter α} (h : ∀ (n : α), ∥f n∥ ≤ g n) (h' : filter.tendsto g t₀ (nhds 0)) : filter.tendsto f t₀ (nhds 0)
theorem nnreal.tendsto_sum_nat_add (f : ℕ → nnreal) : filter.tendsto (λ (i : ℕ), ∑' (k : ℕ), f (k + i)) filter.at_top (nhds 0)
theorem category_theory.limits.has_binary_biproduct_of_total {C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} (b : category_theory.limits.binary_bicone X Y) (total : b.fst ≫ b.inl + b.snd ≫ b.inr = 𝟙 b.X) : category_theory.limits.has_binary_biproduct X Y
theorem nhds_inter_eq_singleton_of_mem_discrete {α : Type u} [topological_space α] {s : set α} [discrete_topology ↥s] {x : α} (hx : x ∈ s) : ∃ (U : set α) (H : U ∈ nhds x), U ∩ s = {x}
theorem map_infi_of_continuous_at_of_monotone {α : Type u} {β : Type v} [complete_linear_order α] [topological_space α] [order_topology α] [complete_linear_order β] [topological_space β] [order_topology β] {ι : Sort u_1} {f : α → β} {g : ι → α} (Cf : continuous_at f (infi g)) (Mf : monotone f) (ftop : f ⊤ = ⊤) : f (infi g) = infi (f ∘ g)
theorem uniform_add_group.uniform_continuous_iff_open_ker {α : Type u_1} {β : Type u_2} [uniform_space α] [add_group α] [uniform_add_group α] {hom : Type u_3} [uniform_space β] [discrete_topology β] [add_group β] [uniform_add_group β] [add_monoid_hom_class hom α β] {f : hom} : uniform_continuous ⇑f ↔ is_open ↑(↑f.ker)
theorem is_clopen_inter_of_disjoint_cover_clopen {α : Type u} [topological_space α] {Z a b : set α} (h : is_clopen Z) (cover : Z ⊆ a ∪ b) (ha : is_open a) (hb : is_open b) (hab : a ∩ b = ∅) : is_clopen (Z ∩ a)
theorem finset.mem_finsupp_iff_of_support_subset {ι : Type u_1} {α : Type u_2} [has_zero α] {s : finset ι} {f : ι →₀ α} {t : ι →₀ finset α} (ht : t.support ⊆ s) : f ∈ s.finsupp ⇑t ↔ ∀ (i : ι), ⇑f i ∈ ⇑t i
theorem Gromov_Hausdorff.isometry_optimal_GH_injr (X : Type u) (Y : Type v) [metric_space X] [compact_space X] [nonempty X] [metric_space Y] [compact_space Y] [nonempty Y] : isometry (Gromov_Hausdorff.optimal_GH_injr X Y)
theorem box_integral.has_integral_bot_divergence_of_forall_has_deriv_within_at {E : Type u} [normed_group E] [normed_space ℝ E] {n : ℕ} [complete_space E] (I : box_integral.box (fin (n + 1))) (f : (fin (n + 1) → ℝ) → fin (n + 1) → E) (f' : (fin (n + 1) → ℝ) → ((fin (n + 1) → ℝ) →L[ℝ] fin (n + 1) → E)) (s : set (fin (n + 1) → ℝ)) (hs : s.countable) (Hs : ∀ (x : fin (n + 1) → ℝ), x ∈ s → continuous_within_at f (⇑box_integral.box.Icc I) x) (Hd : ∀ (x : fin (n + 1) → ℝ), x ∈ ⇑box_integral.box.Icc I  s → has_fderiv_within_at f (f' x) (⇑box_integral.box.Icc I) x) : box_integral.has_integral I ⊥ (λ (x : fin (n + 1) → ℝ), finset.univ.sum (λ (i : fin (n + 1)), ⇑(f' x) (pi.single i 1) i)) box_integral.box_additive_map.volume (finset.univ.sum (λ (i : fin (n + 1)), box_integral.integral (I.face i) ⊥ (λ (x : fin n → ℝ), f (i.insert_nth (I.upper i) x) i) box_integral.box_additive_map.volume - box_integral.integral (I.face i) ⊥ (λ (x : fin n → ℝ), f (i.insert_nth (I.lower i) x) i) box_integral.box_additive_map.volume))
theorem ideal.eq_bot_or_top {K : Type u} [division_ring K] (I : ideal K) : I = ⊥ ∨ I = ⊤
theorem lp.tsum_mul_le_mul_norm {α : Type u_1} {E : α → Type u_2} [Π (i : α), normed_group (E i)] {p q : ennreal} (hpq : p.to_real.is_conjugate_exponent q.to_real) (f : ↥(lp E p)) (g : ↥(lp E q)) : summable (λ (i : α), ∥⇑f i∥ * ∥⇑g i∥) ∧ ∑' (i : α), ∥⇑f i∥ * ∥⇑g i∥ ≤ ∥f∥ * ∥g∥
theorem is_add_left_regular_of_left_cancel_add_semigroup {R : Type u_1} [add_left_cancel_semigroup R] (g : R) : is_add_left_regular g
theorem strict_convex_space.of_norm_add {E : Type u_2} [normed_group E] [normed_space ℝ E] (h : ∀ (x y : E), ∥x + y∥ = ∥x∥ + ∥y∥ → same_ray ℝ x y) : strict_convex_space ℝ E
theorem measure_theory.measure.add_haar_preimage_linear_map {E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] {f : E →ₗ[ℝ] E} (hf : ⇑linear_map.det f ≠ 0) (s : set E) : ⇑μ (⇑f ⁻¹' s) = ennreal.of_real |(⇑linear_map.det f)⁻¹| * ⇑μ s
theorem complex.partial_Gamma_add_one {s : ℂ} (hs : 0 < s.re) {X : ℝ} (hX : 0 ≤ X) : (s + 1).partial_Gamma X = s * s.partial_Gamma X - ↑(real.exp (-X)) * ↑X ^ s
theorem has_fpower_series_on_ball.comp_sub {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] {f : E → F} {p : formal_multilinear_series 𝕜 E F} {x : E} {r : ennreal} (hf : has_fpower_series_on_ball f p x r) (y : E) : has_fpower_series_on_ball (λ (z : E), f (z - y)) p (x + y) r
theorem add_tsub_assoc_of_le {α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {b c : α} [contravariant_class α α has_add.add has_le.le] (h : c ≤ b) (a : α) : a + b - c = a + (b - c)
theorem exp_neg_inv_glue.f_aux_deriv_pos (n : ℕ) (x : ℝ) (hx : 0 < x) : has_deriv_at (exp_neg_inv_glue.f_aux n) (polynomial.eval x (exp_neg_inv_glue.P_aux (n + 1)) * real.exp (-x⁻¹) / x ^ (2 * (n + 1))) x
theorem category_theory.functor.empty_ext' {C : Type u} [category_theory.category C] (F G : category_theory.discrete pempty ⥤ C) : F = G
theorem measure_theory.integrable_on.has_box_integral {ι : Type u} {E : Type v} [fintype ι] [normed_group E] [normed_space ℝ E] [complete_space E] {f : (ι → ℝ) → E} {μ : measure_theory.measure (ι → ℝ)} [measure_theory.is_locally_finite_measure μ] {I : box_integral.box ι} (hf : measure_theory.integrable_on f ↑I μ) (l : box_integral.integration_params) (hl : l.bRiemann = bool.ff) : box_integral.has_integral I l f μ.to_box_additive.to_smul (∫ (x : ι → ℝ) in ↑I, f x ∂μ)
theorem measure_theory.pdf.quasi_measure_preserving_has_pdf {α : Type u_1} {E : Type u_2} [measurable_space E] {m : measurable_space α} {ℙ : measure_theory.measure α} {μ : measure_theory.measure E} {F : Type u_3} [measurable_space F] {ν : measure_theory.measure F} {X : α → E} [measure_theory.has_pdf X «ℙ» μ] {g : E → F} (hg : measure_theory.measure.quasi_measure_preserving g μ ν) (hmap : (measure_theory.measure.map g (measure_theory.measure.map X «ℙ»)).have_lebesgue_decomposition ν) : measure_theory.has_pdf (g ∘ X) «ℙ» ν
theorem clifford_algebra.submodule_map_mul_reverse {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (Q : quadratic_form R M) (p q : submodule R (clifford_algebra Q)) : submodule.map clifford_algebra.reverse (p * q) = submodule.map clifford_algebra.reverse q * submodule.map clifford_algebra.reverse p
theorem std_simplex_subset_closed_ball {ι : Type u_1} [fintype ι] : std_simplex ℝ ι ⊆ metric.closed_ball 0 1
theorem reflection_bot {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] : reflection ⊥ = linear_isometry_equiv.neg 𝕜
theorem gauge_def' {E : Type u_1} [add_comm_group E] [module ℝ E] {s : set E} {x : E} : gauge s x = has_Inf.Inf {r ∈ set.Ioi 0 | r⁻¹ • x ∈ s}
theorem derivation.ext_of_adjoin_eq_top {R : Type u_1} [comm_semiring R] {A : Type u_2} [comm_semiring A] [algebra R A] {M : Type u_3} [add_comm_monoid M] [module A M] [module R M] {D1 D2 : derivation R A M} (s : set A) (hs : algebra.adjoin R s = ⊤) (h : set.eq_on ⇑D1 ⇑D2 s) : D1 = D2
theorem measure_theory.measure.hausdorff_measure_apply {X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] (d : ℝ) (s : set X) : ⇑(measure_theory.measure.hausdorff_measure d) s = ⨆ (r : ennreal) (hr : 0 < r), ⨅ (t : ℕ → set X) (hts : s ⊆ ⋃ (n : ℕ), t n) (ht : ∀ (n : ℕ), emetric.diam (t n) ≤ r), ∑' (n : ℕ), ⨆ (h : (t n).nonempty), emetric.diam (t n) ^ d
theorem has_le.le.trans_lf {x y z : pgame} (h₁ : x ≤ y) (h₂ : y.lf z) : x.lf z
theorem ideal.mem_quotient_iff_mem {R : Type u_1} [comm_ring R] {I J : ideal R} (hIJ : I ≤ J) {x : R} : ⇑(ideal.quotient.mk I) x ∈ ideal.map (ideal.quotient.mk I) J ↔ x ∈ J
theorem set.interval_subset_interval_union_interval {α : Type u} [linear_order α] {a b c : α} : set.interval a c ⊆ set.interval a b ∪ set.interval b c
theorem orientation.map_eq_det_inv_smul {R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {ι : Type u_3} [decidable_eq ι] [fintype ι] [finite_dimensional R M] (x : orientation R M ι) (f : M ≃ₗ[R] M) (h : fintype.card ι = finite_dimensional.finrank R M) : ⇑(orientation.map ι f) x = (⇑linear_equiv.det f)⁻¹ • x
theorem structure_groupoid.compatible {H : Type u_1} [topological_space H] (G : structure_groupoid H) {M : Type u_2} [topological_space M] [charted_space H M] [has_groupoid M G] {e e' : local_homeomorph M H} (he : e ∈ charted_space.atlas H M) (he' : e' ∈ charted_space.atlas H M) : e.symm.trans e' ∈ G
theorem add_neg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0
theorem fintype.is_prime_pow_card_of_field {α : Type u_1} [fintype α] [field α] : is_prime_pow (fintype.card α)
theorem convex.lipschitz_on_with_of_nnnorm_has_deriv_within_le {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_group G] [normed_space 𝕜 G] {f f' : 𝕜 → G} {s : set 𝕜} {C : nnreal} (hs : convex ℝ s) (hf : ∀ (x : 𝕜), x ∈ s → has_deriv_within_at f (f' x) s x) (bound : ∀ (x : 𝕜), x ∈ s → ∥f' x∥₊ ≤ C) : lipschitz_on_with C f s
theorem localization.at_prime.comap_maximal_ideal {R : Type u_1} [comm_semiring R] {I : ideal R} [hI : I.is_prime] : ideal.comap (algebra_map R (localization.at_prime I)) (local_ring.maximal_ideal (localization I.prime_compl)) = I
theorem orientation.oangle_neg_orientation_eq_neg {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x y : V) : (-o).oangle x y = -o.oangle x y
theorem filter.map_at_top_finset_sum_le_of_sum_eq {α : Type u_3} {β : Type u_4} {γ : Type u_5} [add_comm_monoid α] {f : β → α} {g : γ → α} (h_eq : ∀ (u : finset γ), ∃ (v : finset β), ∀ (v' : finset β), v ⊆ v' → (∃ (u' : finset γ), u ⊆ u' ∧ u'.sum (λ (x : γ), g x) = v'.sum (λ (b : β), f b))) : filter.map (λ (s : finset β), s.sum (λ (b : β), f b)) filter.at_top ≤ filter.map (λ (s : finset γ), s.sum (λ (x : γ), g x)) filter.at_top
theorem group.fg_iff_monoid.fg {G : Type u_3} [group G] : group.fg G ↔ monoid.fg G
theorem category_theory.abelian.pseudoelement.sub_of_eq_image {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P ⟶ Q) (x y : ↥P) : ⇑f x = ⇑f y → (∃ (z : ↥P), ⇑f z = 0 ∧ ∀ (R : C) (g : P ⟶ R), ⇑g y = 0 → ⇑g z = ⇑g x)
theorem padic_val_rat.pow (p : ℕ) [p_prime : fact (nat.prime p)] {q : ℚ} (hq : q ≠ 0) {k : ℕ} : padic_val_rat p (q ^ k) = ↑k * padic_val_rat p q
theorem fourier_subalgebra_closure_eq_top  : fourier_subalgebra.topological_closure = ⊤
theorem has_deriv_at.scomp {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {F : Type v} [normed_group F] [normed_space 𝕜 F] (x : 𝕜) {𝕜' : Type u_1} [nondiscrete_normed_field 𝕜'] [normed_algebra 𝕜 𝕜'] [normed_space 𝕜' F] [is_scalar_tower 𝕜 𝕜' F] {h : 𝕜 → 𝕜'} {h' : 𝕜'} {g₁ : 𝕜' → F} {g₁' : F} (hg : has_deriv_at g₁ g₁' (h x)) (hh : has_deriv_at h h' x) : has_deriv_at (g₁ ∘ h) (h' • g₁') x
theorem strict_mono.strict_convex_on_univ_of_deriv {f : ℝ → ℝ} (hf : differentiable ℝ f) (hf'_mono : strict_mono (deriv f)) : strict_convex_on ℝ set.univ f
theorem measure_theory.measure.restrict_mono' {α : Type u_1} {m0 : measurable_space α} ⦃s s' : set α⦄ ⦃μ ν : measure_theory.measure α⦄ (hs : s ≤ᵐ[μ] s') (hμν : μ ≤ ν) : μ.restrict s ≤ ν.restrict s'
theorem complex.tendsto_lim_of_differentiable_on_punctured_nhds_of_is_o {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] {f : ℂ → E} {c : ℂ} (hd : ∀ᶠ (z : ℂ) in nhds_within c {c}ᶜ, differentiable_at ℂ f z) (ho : (λ (z : ℂ), f z - f c) =o[nhds_within c {c}ᶜ] λ (z : ℂ), (z - c)⁻¹) : filter.tendsto f (nhds_within c {c}ᶜ) (nhds (lim (nhds_within c {c}ᶜ) f))
theorem neg_of_neg_pos {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : 0 < -a → a < 0
theorem pi_nat.exists_retraction_of_is_closed {E : ℕ → Type u_1} [Π (n : ℕ), topological_space (E n)] [∀ (n : ℕ), discrete_topology (E n)] {s : set (Π (n : ℕ), E n)} (hs : is_closed s) (hne : s.nonempty) : ∃ (f : (Π (n : ℕ), E n) → Π (n : ℕ), E n), (∀ (x : Π (n : ℕ), E n), x ∈ s → f x = x) ∧ set.range f = s ∧ continuous f
theorem algebra.power_basis.norm_gen_eq_coeff_zero_minpoly {S : Type u_2} [comm_ring S] {K : Type u_4} [field K] [algebra K S] (pb : power_basis K S) : ⇑(algebra.norm K) pb.gen = (-1) ^ pb.dim * (minpoly K pb.gen).coeff 0
theorem finprod_induction {M : Type u_2} {α : Sort u_4} [comm_monoid M] {f : α → M} (p : M → Prop) (hp₀ : p 1) (hp₁ : ∀ (x y : M), p x → p y → p (x * y)) (hp₂ : ∀ (i : α), p (f i)) : p (finprod (λ (i : α), f i))
theorem exists_norm_eq_infi_of_complete_convex {F : Type u_3} [inner_product_space ℝ F] {K : set F} (ne : K.nonempty) (h₁ : is_complete K) (h₂ : convex ℝ K) (u : F) : ∃ (v : F) (H : v ∈ K), ∥u - v∥ = ⨅ (w : ↥K), ∥u - ↑w∥
theorem real_inner_eq_norm_add_mul_self_sub_norm_mul_self_sub_norm_mul_self_div_two {F : Type u_3} [inner_product_space ℝ F] (x y : F) : has_inner.inner x y = (∥x + y∥ * ∥x + y∥ - ∥x∥ * ∥x∥ - ∥y∥ * ∥y∥) / 2
theorem exists_partition_approximates_linear_on_of_has_fderiv_within_at {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] [normed_group F] [normed_space ℝ F] [measurable_space E] [borel_space E] [topological_space.second_countable_topology F] (f : E → F) (s : set E) (f' : E → (E →L[ℝ] F)) (hf' : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (r : (E →L[ℝ] F) → nnreal) (rpos : ∀ (A : E →L[ℝ] F), r A ≠ 0) : ∃ (t : ℕ → set E) (A : ℕ → (E →L[ℝ] F)), pairwise (disjoint on t) ∧ (∀ (n : ℕ), measurable_set (t n)) ∧ (s ⊆ ⋃ (n : ℕ), t n) ∧ (∀ (n : ℕ), approximates_linear_on f (A n) (s ∩ t n) (r (A n))) ∧ (s.nonempty → ∀ (n : ℕ), ∃ (y : E) (H : y ∈ s), A n = f' y)
theorem is_topological_fiber_bundle_snd {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.snd
theorem nat.totient_prime_pow {p : ℕ} (hp : nat.prime p) {n : ℕ} (hn : 0 < n) : (p ^ n).totient = p ^ (n - 1) * (p - 1)
theorem Top.presheaf.to_Type_is_sheaf (X : Top) (T : Type u) : (X.presheaf_to_Type T).is_sheaf
theorem tendsto_rpow_div  : filter.tendsto (λ (x : ℝ), x ^ (1 / x)) filter.at_top (nhds 1)
theorem contract_left_assoc_coevaluation (K : Type u) [field K] (V : Type v) [add_comm_group V] [module K V] [finite_dimensional K V] : (linear_map.rtensor (module.dual K V) (contract_left K V)).comp ((tensor_product.assoc K (module.dual K V) V (module.dual K V)).symm.to_linear_map.comp (linear_map.ltensor (module.dual K V) (coevaluation K V))) = (tensor_product.lid K (module.dual K V)).symm.to_linear_map.comp (tensor_product.rid K (module.dual K V)).to_linear_map
theorem set.union_finset_finite_of_range_finite {α : Type u} {β : Type v} (f : α → finset β) (h : (set.range f).finite) : (⋃ (a : α), ↑(f a)).finite
theorem measurable.lintegral_prod_right' {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] {f : α × β → ennreal} (hf : measurable f) : measurable (λ (x : α), ∫⁻ (y : β), f (x, y) ∂ν)
theorem finset.card_Ico_finset {α : Type u_1} [decidable_eq α] {s t : finset α} (h : s ⊆ t) : (finset.Ico s t).card = 2 ^ (t.card - s.card) - 1
theorem minpoly.coeff_zero_eq_zero {A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) : (minpoly A x).coeff 0 = 0 ↔ x = 0
theorem real.Lp_add_le_has_sum_of_nonneg {ι : Type u} {f g : ι → ℝ} {p : ℝ} (hp : 1 ≤ p) (hf : ∀ (i : ι), 0 ≤ f i) (hg : ∀ (i : ι), 0 ≤ g i) {A B : ℝ} (hA : 0 ≤ A) (hB : 0 ≤ B) (hfA : has_sum (λ (i : ι), f i ^ p) (A ^ p)) (hgB : has_sum (λ (i : ι), g i ^ p) (B ^ p)) : ∃ (C : ℝ), 0 ≤ C ∧ C ≤ A + B ∧ has_sum (λ (i : ι), (f i + g i) ^ p) (C ^ p)
theorem convex.is_const_of_fderiv_within_eq_zero {E : Type u_1} [normed_group E] [normed_space ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_space 𝕜 E] [normed_group G] [normed_space 𝕜 G] {f : E → G} {s : set E} {x y : E} (hs : convex ℝ s) (hf : differentiable_on 𝕜 f s) (hf' : ∀ (x : E), x ∈ s → fderiv_within 𝕜 f s x = 0) (hx : x ∈ s) (hy : y ∈ s) : f x = f y
theorem vector_span_range_eq_span_range_vsub_right_ne (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} (p : ι → P) (i₀ : ι) : vector_span k (set.range p) = submodule.span k (set.range (λ (i : {x // x ≠ i₀}), p ↑i -ᵥ p i₀))
theorem normed_space.dual.is_closed_image_polar_of_mem_nhds (𝕜 : Type u_1) [nondiscrete_normed_field 𝕜] {E : Type u_2} [semi_normed_group E] [normed_space 𝕜 E] {s : set E} (s_nhd : s ∈ nhds 0) : is_closed (coe_fn '' normed_space.polar 𝕜 s)
theorem category_theory.is_pushout.of_is_coproduct {C : Type u₁} [category_theory.category C] {Z X Y : C} {c : category_theory.limits.binary_cofan X Y} (h : category_theory.limits.is_colimit c) (t : category_theory.limits.is_initial Z) : category_theory.is_pushout (t.to ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.left})) (t.to ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.right})) c.inl c.inr
theorem union_support_maximal_linear_independent_eq_range_basis {R : Type u} [ring R] {M : Type v} [add_comm_group M] [module R M] [nontrivial R] {ι : Type w} (b : basis ι R M) {κ : Type w'} (v : κ → M) (i : linear_independent R v) (m : i.maximal) : (⋃ (k : κ), ↑((⇑(b.repr) (v k)).support)) = set.univ
theorem category_theory.reflects_isomorphisms_forget₂ (C : Type (u+1)) [category_theory.category C] [category_theory.concrete_category C] (D : Type (u+1)) [category_theory.category D] [category_theory.concrete_category D] [category_theory.has_forget₂ C D] [category_theory.reflects_isomorphisms (category_theory.forget C)] : category_theory.reflects_isomorphisms (category_theory.forget₂ C D)
theorem continuous_linear_map.comp_analytic_on {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] [normed_group G] [normed_space 𝕜 G] {f : E → F} {s : set E} (g : F →L[𝕜] G) (h : analytic_on 𝕜 f s) : analytic_on 𝕜 (⇑g ∘ f) s
theorem dfinsupp.add_hom_ext' {ι : Type u} {β : ι → Type v} [dec : decidable_eq ι] [Π (i : ι), add_zero_class (β i)] {γ : Type w} [add_zero_class γ] ⦃f g : (Π₀ (i : ι), β i) →+ γ⦄ (H : ∀ (x : ι), f.comp (dfinsupp.single_add_hom β x) = g.comp (dfinsupp.single_add_hom β x)) : f = g
theorem strict_convex_iff_convex {𝕜 : Type u_1} [linear_ordered_field 𝕜] [topological_space 𝕜] [order_topology 𝕜] {s : set 𝕜} : strict_convex 𝕜 s ↔ convex 𝕜 s
theorem monoid_with_zero_hom.ext_int' {M : Type u_1} [monoid_with_zero M] {φ₁ φ₂ : ℤ →*₀ M} (h_neg_one : ⇑φ₁ (-1) = ⇑φ₂ (-1)) (h_pos : ∀ (n : ℕ), 0 < n → ⇑φ₁ ↑n = ⇑φ₂ ↑n) : φ₁ = φ₂
theorem category_theory.has_finite_products_of_has_binary_and_terminal {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_terminal C] : category_theory.limits.has_finite_products C
theorem category_theory.pretopology.to_grothendieck_bot (C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] : category_theory.pretopology.to_grothendieck C ⊥ = ⊥
theorem real.Lp_add_le_of_nonneg {ι : Type u} (s : finset ι) {f g : ι → ℝ} {p : ℝ} (hp : 1 ≤ p) (hf : ∀ (i : ι), i ∈ s → 0 ≤ f i) (hg : ∀ (i : ι), i ∈ s → 0 ≤ g i) : s.sum (λ (i : ι), (f i + g i) ^ p) ^ (1 / p) ≤ s.sum (λ (i : ι), f i ^ p) ^ (1 / p) + s.sum (λ (i : ι), g i ^ p) ^ (1 / p)
theorem affine_subspace.lt_iff_le_and_exists {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P) : s1 < s2 ↔ s1 ≤ s2 ∧ ∃ (p : P) (H : p ∈ s2), p ∉ s1
theorem continuous_at_of_monotone_on_of_image_mem_nhds {α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : monotone_on f s) (hs : s ∈ nhds a) (hfs : f '' s ∈ nhds (f a)) : continuous_at f a
theorem measure_theory.strongly_measurable.ite {α : Type u_1} {β : Type u_2} {f g : α → β} {m : measurable_space α} [topological_space β] {p : α → Prop} {_x : decidable_pred p} (hp : measurable_set {a : α | p a}) (hf : measure_theory.strongly_measurable f) (hg : measure_theory.strongly_measurable g) : measure_theory.strongly_measurable (λ (x : α), ite (p x) (f x) (g x))
theorem affine_subspace.affine_span_coe {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s : affine_subspace k P) : affine_span k ↑s = s
theorem matrix.is_diag.from_blocks {α : Type u_1} {n : Type u_4} {m : Type u_5} [has_zero α] {A : matrix m m α} {D : matrix n n α} (ha : A.is_diag) (hd : D.is_diag) : (matrix.from_blocks A 0 0 D).is_diag
theorem fintype.exists_lt_card_fiber_of_nsmul_lt_card {α : Type u} {β : Type v} {M : Type w} [decidable_eq β] [fintype α] [fintype β] (f : α → β) {b : M} [linear_ordered_comm_ring M] (hb : fintype.card β • b < ↑(fintype.card α)) : ∃ (y : β), b < ↑((finset.filter (λ (x : α), f x = y) finset.univ).card)
theorem equiv.add_right_symm_apply {G : Type u_10} [add_group G] (a : G) : ⇑(equiv.symm (equiv.add_right a)) = λ (x : G), x + -a
theorem finset.affine_combination_map {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} {ι₂ : Type u_5} (s₂ : finset ι₂) (e : ι₂ ↪ ι) (w : ι → k) (p : ι → P) : ⇑((finset.map e s₂).affine_combination p) w = ⇑(s₂.affine_combination (p ∘ ⇑e)) (w ∘ ⇑e)
theorem map_infi_of_continuous_at_of_monotone' {α : Type u} {β : Type v} [complete_linear_order α] [topological_space α] [order_topology α] [complete_linear_order β] [topological_space β] [order_topology β] {ι : Sort u_1} [nonempty ι] {f : α → β} {g : ι → α} (Cf : continuous_at f (infi g)) (Mf : monotone f) : f (⨅ (i : ι), g i) = ⨅ (i : ι), f (g i)
theorem continuous.fst {α : Type u} {β : Type v} {γ : Type u_1} [topological_space α] [topological_space β] [topological_space γ] {f : α → β × γ} (hf : continuous f) : continuous (λ (a : α), (f a).fst)
theorem has_le.le.lt_of_not_le {α : Type u} [preorder α] {a b : α} : a ≤ b → ¬b ≤ a → a < b
theorem category_theory.abelian.mono_of_epi_of_mono_of_mono {V : Type u} [category_theory.category V] [category_theory.abelian V] {A B C D A' B' C' D' : V} {f : A ⟶ B} {g : B ⟶ C} {h : C ⟶ D} {f' : A' ⟶ B'} {g' : B' ⟶ C'} {h' : C' ⟶ D'} {α : A ⟶ A'} {β : B ⟶ B'} {γ : C ⟶ C'} {δ : D ⟶ D'} (comm₁ : α ≫ f' = f ≫ β) (comm₂ : β ≫ g' = g ≫ γ) (comm₃ : γ ≫ h' = h ≫ δ) (hfg : category_theory.exact f g) (hgh : category_theory.exact g h) (hf'g' : category_theory.exact f' g') (hα : category_theory.epi α) (hβ : category_theory.mono β) (hδ : category_theory.mono δ) : category_theory.mono γ
theorem orientation.map_eq_iff_det_pos {R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {ι : Type u_3} [decidable_eq ι] [fintype ι] [finite_dimensional R M] (x : orientation R M ι) (f : M ≃ₗ[R] M) (h : fintype.card ι = finite_dimensional.finrank R M) : ⇑(orientation.map ι f) x = x ↔ 0 < ⇑linear_map.det ↑f
theorem affine_subspace.span_Union (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : ι → set P) : affine_span k (⋃ (i : ι), s i) = ⨆ (i : ι), affine_span k (s i)
theorem module.ray.units_smul_of_pos {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (u : Rˣ) (hu : 0 < ↑u) (v : module.ray R M) : u • v = v
theorem metric.inf_dist_le_inf_dist_add_Hausdorff_dist {α : Type u} [pseudo_metric_space α] {s t : set α} {x : α} (fin : emetric.Hausdorff_edist s t ≠ ⊤) : metric.inf_dist x t ≤ metric.inf_dist x s + metric.Hausdorff_dist s t
theorem affine.simplex.face_eq_mk_of_point {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : ℕ} (s : affine.simplex k P n) (i : fin (n + 1)) : s.face _ = affine.simplex.mk_of_point k (s.points i)
theorem continuous_on_prod_of_continuous_on_lipschitz_on {α : Type u} {β : Type v} {γ : Type w} [pseudo_emetric_space α] [topological_space β] [pseudo_emetric_space γ] (f : α × β → γ) {s : set α} {t : set β} (K : nnreal) (ha : ∀ (a : α), a ∈ s → continuous_on (λ (y : β), f (a, y)) t) (hb : ∀ (b : β), b ∈ t → lipschitz_on_with K (λ (x : α), f (x, b)) s) : continuous_on f (s ×ˢ t)
theorem equiv.mul_swap_involutive {α : Type u} [decidable_eq α] (i j : α) : function.involutive (λ (_x : equiv.perm α), _x * equiv.swap i j)
theorem continuous_map.continuous_at {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : C(α, β)) (x : α) : continuous_at ⇑f x
theorem nonempty_of_finsum_mem_ne_zero {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} {s : set α} (h : finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) ≠ 0) : s.nonempty
theorem measure_theory.submartingale.set_integral_le {α : Type u_1} {ι : Type u_3} [preorder ι] {m0 : measurable_space α} {μ : measure_theory.measure α} {ℱ : measure_theory.filtration ι m0} [measure_theory.sigma_finite_filtration μ ℱ] {f : ι → α → ℝ} (hf : measure_theory.submartingale f ℱ μ) {i j : ι} (hij : i ≤ j) {s : set α} (hs : measurable_set s) : ∫ (x : α) in s, f i x ∂μ ≤ ∫ (x : α) in s, f j x ∂μ
theorem re_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) : ⇑is_R_or_C.re (has_inner.inner x y) = (∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ - ∥x - y∥ * ∥x - y∥) / 2
theorem filter.tendsto_at_bot_at_bot_of_monotone' {ι : Type u_1} {α : Type u_3} [preorder ι] [linear_order α] {u : ι → α} (h : monotone u) (H : ¬bdd_below (set.range u)) : filter.tendsto u filter.at_bot filter.at_bot
theorem measure_theory.lintegral_le_of_forall_fin_meas_le' {α : Type u_1} {m m0 : measurable_space α} {μ : measure_theory.measure α} (hm : m ≤ m0) [measure_theory.sigma_finite (μ.trim hm)] (C : ennreal) {f : α → ennreal} (hf_meas : ae_measurable f μ) (hf : ∀ (s : set α), measurable_set s → ⇑μ s ≠ ⊤ → ∫⁻ (x : α) in s, f x ∂μ ≤ C) : ∫⁻ (x : α), f x ∂μ ≤ C
theorem convex.closure_subset_interior_image_homothety_of_one_lt {E : Type u_2} [add_comm_group E] [module ℝ E] [topological_space E] [topological_add_group E] [has_continuous_smul ℝ E] {s : set E} (hs : convex ℝ s) {x : E} (hx : x ∈ interior s) (t : ℝ) (ht : 1 < t) : closure s ⊆ interior (⇑(affine_map.homothety x t) '' s)
theorem category_theory.coyoneda.is_iso {C : Type u₁} [category_theory.category C] {X Y : Cᵒᵖ} (f : X ⟶ Y) [category_theory.is_iso (category_theory.coyoneda.map f)] : category_theory.is_iso f
theorem list.sublist.sum_le_sum {M : Type u_3} [add_monoid M] [preorder M] [covariant_class M M (function.swap has_add.add) has_le.le] [covariant_class M M has_add.add has_le.le] {l₁ l₂ : list M} (h : l₁ <+ l₂) (h₁ : ∀ (a : M), a ∈ l₂ → 0 ≤ a) : l₁.sum ≤ l₂.sum
theorem add_submonoid.localization_map.map_spec {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M →+ P} {T : add_submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ T) {Q : Type u_4} [add_comm_monoid Q] {k : T.localization_map Q} (z : N) (u : Q) : ⇑(f.map hy k) z = u ↔ ⇑(k.to_map) (⇑g (f.sec z).fst) = ⇑(k.to_map) (⇑g ↑((f.sec z).snd)) + u
theorem cont_diff_on.continuous_on_fderiv_within_apply {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {n : with_top ℕ} (h : cont_diff_on 𝕜 n f s) (hs : unique_diff_on 𝕜 s) (hn : 1 ≤ n) : continuous_on (λ (p : E × E), ⇑(fderiv_within 𝕜 f s p.fst) p.snd) (s ×ˢ set.univ)
theorem mv_polynomial.cardinal_mk_le_max {σ R : Type u} [comm_semiring R] : cardinal.mk (mv_polynomial σ R) ≤ linear_order.max (linear_order.max (cardinal.mk R) (cardinal.mk σ)) cardinal.aleph_0
theorem is_Gδ_bUnion {α : Type u_1} {ι : Type u_4} [topological_space α] {s : set ι} (hs : s.finite) {f : ι → set α} (h : ∀ (i : ι), i ∈ s → is_Gδ (f i)) : is_Gδ (⋃ (i : ι) (H : i ∈ s), f i)
theorem is_right_regular_of_non_zero_divisor {α : Type u} [non_unital_non_assoc_ring α] (k : α) (h : ∀ (x : α), x * k = 0 → x = 0) : is_right_regular k
theorem affine_homeomorph_image_I {𝕜 : Type u_1} [linear_ordered_field 𝕜] [topological_space 𝕜] [topological_ring 𝕜] (a b : 𝕜) (h : 0 < a) : ⇑(affine_homeomorph a b _) '' set.Icc 0 1 = set.Icc b (a + b)
theorem category_theory.equalizer.presieve.sheaf_condition {C : Type u₁} [category_theory.category C] (P : Cᵒᵖ ⥤ Type (max v₁ u₁)) {X : C} (R : category_theory.presieve X) [category_theory.limits.has_pullbacks C] : category_theory.presieve.is_sheaf_for P R ↔ nonempty (category_theory.limits.is_limit (category_theory.limits.fork.of_ι (category_theory.equalizer.fork_map P R) _))
theorem has_btw.btw.cyclic_right {α : Type u_1} [circular_preorder α] {a b c : α} (h : has_btw.btw a b c) : has_btw.btw c a b
theorem orientation.two_zsmul_oangle_smul_smul_self {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x : V) {r₁ r₂ : ℝ} : 2 • o.oangle (r₁ • x) (r₂ • x) = 0
theorem lt_of_tsub_lt_tsub_right {α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] (h : a - c < b - c) : a < b
theorem power_series.order_add_of_order_eq {R : Type u_1} [semiring R] (φ ψ : power_series R) (h : φ.order ≠ ψ.order) : (φ + ψ).order = φ.order ⊓ ψ.order
theorem min_cases {α : Type u} [linear_order α] (a b : α) : linear_order.min a b = a ∧ a ≤ b ∨ linear_order.min a b = b ∧ b < a
theorem pgame.le_def {x y : pgame} : x ≤ y ↔ (∀ (i : x.left_moves), (∃ (i' : y.left_moves), x.move_left i ≤ y.move_left i') ∨ ∃ (j : (x.move_left i).right_moves), (x.move_left i).move_right j ≤ y) ∧ ∀ (j : y.right_moves), (∃ (i : (y.move_right j).left_moves), x ≤ (y.move_right j).move_left i) ∨ ∃ (j' : x.right_moves), x.move_right j' ≤ y.move_right j
theorem measure_theory.Lp_to_Lp_restrict_add {α : Type u_1} {E : Type u_3} [measurable_space α] [normed_group E] {p : ennreal} {μ : measure_theory.measure α} (f g : ↥(measure_theory.Lp E p μ)) (s : set α) : measure_theory.mem_ℒp.to_Lp ⇑(f + g) _ = measure_theory.mem_ℒp.to_Lp ⇑f _ + measure_theory.mem_ℒp.to_Lp ⇑g _
theorem continuous_at_right_of_monotone_on_of_closure_image_mem_nhds_within {α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : monotone_on f s) (hs : s ∈ nhds_within a (set.Ici a)) (hfs : closure (f '' s) ∈ nhds_within (f a) (set.Ici (f a))) : continuous_within_at f (set.Ici a) a
theorem finset.center_mass_segment {R : Type u_1} {E : Type u_2} {ι : Type u_4} [linear_ordered_field R] [add_comm_group E] [module R E] (s : finset ι) (w₁ w₂ : ι → R) (z : ι → E) (hw₁ : s.sum (λ (i : ι), w₁ i) = 1) (hw₂ : s.sum (λ (i : ι), w₂ i) = 1) (a b : R) (hab : a + b = 1) : a • s.center_mass w₁ z + b • s.center_mass w₂ z = s.center_mass (λ (i : ι), a * w₁ i + b * w₂ i) z
theorem strict_convex_on_iff_slope_strict_mono_adjacent {𝕜 : Type u_1} [linear_ordered_field 𝕜] {s : set 𝕜} {f : 𝕜 → 𝕜} : strict_convex_on 𝕜 s f ↔ convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f y - f x) / (y - x) < (f z - f y) / (z - y)
theorem emetric.Hausdorff_edist_zero_iff_closure_eq_closure {α : Type u} [pseudo_emetric_space α] {s t : set α} : emetric.Hausdorff_edist s t = 0 ↔ closure s = closure t
theorem exists_open_with_compact_closure {α : Type u} [topological_space α] [locally_compact_space α] [t2_space α] (x : α) : ∃ (U : set α), is_open U ∧ x ∈ U ∧ is_compact (closure U)
theorem measure_theory.Lp_meas_subgroup_to_Lp_trim_right_inv {α : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space α} {μ : measure_theory.measure α} (hm : m ≤ m0) : function.right_inverse (measure_theory.Lp_trim_to_Lp_meas_subgroup F p μ hm) (measure_theory.Lp_meas_subgroup_to_Lp_trim F p μ hm)
theorem closure_operator.closure_le_mk₃_iff {α : Type u_1} [partial_order α] {f : α → α} {p : α → Prop} {hf : ∀ (x : α), x ≤ f x} {hfp : ∀ (x : α), p (f x)} {hmin : ∀ ⦃x y : α⦄, x ≤ y → p y → f x ≤ y} {x y : α} (hxy : x ≤ y) (hy : p y) : ⇑(closure_operator.mk₃ f p hf hfp hmin) x ≤ y
theorem submonoid.localization_map.inv_inj {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {f : M →* N} (hf : ∀ (y : ↥S), is_unit (⇑f ↑y)) {y z : ↥S} (h : (⇑(is_unit.lift_right (f.restrict S) hf) y)⁻¹ = (⇑(is_unit.lift_right (f.restrict S) hf) z)⁻¹) : ⇑f ↑y = ⇑f ↑z
theorem monoid_hom.map_zpow {α : Type u_1} {β : Type u_2} [group α] [division_monoid β] (f : α →* β) (g : α) (n : ℤ) : ⇑f (g ^ n) = ⇑f g ^ n
theorem le_nhds_Lim {α : Type u} [topological_space α] {f : filter α} (h : ∃ (a : α), f ≤ nhds a) : f ≤ nhds (Lim f)
theorem convex.translate_preimage_left {𝕜 : Type u_1} {E : Type u_2} [ordered_semiring 𝕜] [add_comm_monoid E] [module 𝕜 E] {s : set E} (hs : convex 𝕜 s) (z : E) : convex 𝕜 ((λ (x : E), x + z) ⁻¹' s)
theorem is_preconnected.bUnion_of_chain {α : Type u} {β : Type v} [topological_space α] [linear_order β] [succ_order β] [is_succ_archimedean β] {s : β → set α} {t : set β} (ht : t.ord_connected) (H : ∀ (n : β), n ∈ t → is_preconnected (s n)) (K : ∀ (n : β), n ∈ t → order.succ n ∈ t → (s n ∩ s (order.succ n)).nonempty) : is_preconnected (⋃ (n : β) (H : n ∈ t), s n)
theorem lie_algebra.infi_max_gen_zero_eigenspace_eq_top_of_nilpotent (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_algebra.is_nilpotent R L] : (⨅ (x : L), (⇑(lie_algebra.ad R L) x).maximal_generalized_eigenspace 0) = ⊤
theorem list.array_eq_of_fn {α : Type u} {n : ℕ} (a : array n α) : a.to_list = list.of_fn a.read
theorem real.tendsto_log_at_top  : filter.tendsto real.log filter.at_top filter.at_top
theorem cauchy_seq_bdd {α : Type u} [pseudo_metric_space α] {u : ℕ → α} (hu : cauchy_seq u) : ∃ (R : ℝ) (H : R > 0), ∀ (m n : ℕ), has_dist.dist (u m) (u n) < R
theorem discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization.to_unique_factorization_monoid {R : Type u_1} [comm_ring R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) [is_domain R] : unique_factorization_monoid R
theorem fintype.all_card_le_rel_image_card_iff_exists_injective {α : Type u} {β : Type v} [decidable_eq β] (r : α → β → Prop) [Π (a : α), fintype ↥(rel.image r {a})] : (∀ (A : finset α), A.card ≤ fintype.card ↥(rel.image r ↑A)) ↔ ∃ (f : α → β), function.injective f ∧ ∀ (x : α), r x (f x)
theorem generalized_continued_fraction.int_fract_pair.stream_is_seq {K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : (generalized_continued_fraction.int_fract_pair.stream v).is_seq
theorem not_interval_integrable_of_tendsto_norm_at_top_of_deriv_is_O_within_diff_singleton {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [topological_space.second_countable_topology E] [complete_space E] [normed_group F] {f : ℝ → E} {g : ℝ → F} {a b c : ℝ} (hne : a ≠ b) (hc : c ∈ set.interval a b) (h_deriv : ∀ᶠ (x : ℝ) in nhds_within c (set.interval a b  {c}), differentiable_at ℝ f x) (h_infty : filter.tendsto (λ (x : ℝ), ∥f x∥) (nhds_within c (set.interval a b  {c})) filter.at_top) (hg : deriv f =O[nhds_within c (set.interval a b  {c})] g) : ¬interval_integrable g measure_theory.measure_space.volume a b
theorem linear_map.convex_on {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [ordered_add_comm_monoid β] [module 𝕜 E] [module 𝕜 β] (f : E →ₗ[𝕜] β) {s : set E} (hs : convex 𝕜 s) : convex_on 𝕜 s ⇑f
theorem formal_multilinear_series.is_o_of_lt_radius {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) {r : nnreal} (h : ↑r < p.radius) : ∃ (a : ℝ) (H : a ∈ set.Ioo 0 1), (λ (n : ℕ), ∥p n∥ * ↑r ^ n) =o[filter.at_top] has_pow.pow a
theorem convolution_eq_right' {𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G → E} {g : G → E'} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 F] (L : E →L[𝕜] E' →L[𝕜] F) [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ F] [complete_space F] [semi_normed_group G] {x₀ : G} {R : ℝ} (hf : function.support f ⊆ metric.ball 0 R) (hg : ∀ (x : G), x ∈ metric.ball x₀ R → g x = g x₀) : convolution f g L μ x₀ = ∫ (t : G), ⇑(⇑L (f t)) (g x₀) ∂μ
theorem filter.map₂_distrib_le_right {α : Type u_1} {α' : Type u_2} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {ε : Type u_9} {f : filter α} {g : filter β} {h : filter γ} {m : δ → γ → ε} {n : α → β → δ} {m₁ : α → γ → α'} {m₂ : β → γ → β'} {n' : α' → β' → ε} (h_distrib : ∀ (a : α) (b : β) (c : γ), m (n a b) c = n' (m₁ a c) (m₂ b c)) : filter.map₂ m (filter.map₂ n f g) h ≤ filter.map₂ n' (filter.map₂ m₁ f h) (filter.map₂ m₂ g h)
theorem measurable_embedding.lintegral_map {α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [measurable_space β] {g : α → β} (hg : measurable_embedding g) (f : β → ennreal) : ∫⁻ (a : β), f a ∂measure_theory.measure.map g μ = ∫⁻ (a : α), f (g a) ∂μ
theorem finset.not_mem_map_subtype_of_not_property {α : Type u_1} {p : α → Prop} (s : finset {x // p x}) {a : α} (h : ¬p a) : a ∉ finset.map (function.embedding.subtype (λ (x : α), p x)) s
theorem category_theory.is_filtered.coeq_condition {C : Type u} [category_theory.category C] [category_theory.is_filtered C] {j j' : C} (f f' : j ⟶ j') : f ≫ category_theory.is_filtered.coeq_hom f f' = f' ≫ category_theory.is_filtered.coeq_hom f f'
theorem padic_val_nat.div {p : ℕ} [p_prime : fact (nat.prime p)] {b : ℕ} (dvd : p ∣ b) : padic_val_nat p (b / p) = padic_val_nat p b - 1
theorem same_ray_iff_inv_norm_smul_eq {F : Type u_2} [normed_group F] [normed_space ℝ F] {x y : F} : same_ray ℝ x y ↔ x = 0 ∨ y = 0 ∨ ∥x∥⁻¹ • x = ∥y∥⁻¹ • y
theorem function.antiperiodic.periodic {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [semiring α] [add_group β] (h : function.antiperiodic f c) : function.periodic f (2 * c)
theorem bilin_form.nondegenerate_of_anisotropic {R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] {B : bilin_form R M} (hB : B.to_quadratic_form.anisotropic) : B.nondegenerate
theorem affine.simplex.eq_circumradius_of_dist_eq {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P n) {p : P} (hp : p ∈ affine_span ℝ (set.range s.points)) {r : ℝ} (hr : ∀ (i : fin (n + 1)), has_dist.dist (s.points i) p = r) : r = s.circumradius
theorem submodule.finrank_add_inf_finrank_orthogonal {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K₁ K₂ : submodule 𝕜 E} [finite_dimensional 𝕜 ↥K₂] (h : K₁ ≤ K₂) : finite_dimensional.finrank 𝕜 ↥K₁ + finite_dimensional.finrank 𝕜 ↥(K₁ᗮ ⊓ K₂) = finite_dimensional.finrank 𝕜 ↥K₂
theorem is_submonoid.Inter {M : Type u_1} [monoid M] {ι : Sort u_2} {s : ι → set M} (h : ∀ (y : ι), is_submonoid (s y)) : is_submonoid (set.Inter s)
theorem add_submonoid.localization_map.eq_of_eq {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M →+ P} (hg : ∀ (y : ↥S), is_add_unit (⇑g ↑y)) {x y : M} (h : ⇑(f.to_map) x = ⇑(f.to_map) y) : ⇑g x = ⇑g y
theorem subsemiring.closure_eq {R : Type u} [non_assoc_semiring R] (s : subsemiring R) : subsemiring.closure ↑s = s
theorem same_ray.refl {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : M) : same_ray R x x
theorem ring_hom.map_finsupp_sum {α : Type u_1} {M : Type u_5} {R : Type u_11} {S : Type u_12} [has_zero M] [semiring R] [semiring S] (h : R →+* S) (f : α →₀ M) (g : α → M → R) : ⇑h (f.sum g) = f.sum (λ (a : α) (b : M), ⇑h (g a b))
theorem is_connected.bUnion_of_refl_trans_gen {α : Type u} [topological_space α] {ι : Type u_1} {t : set ι} {s : ι → set α} (ht : t.nonempty) (H : ∀ (i : ι), i ∈ t → is_connected (s i)) (K : ∀ (i : ι), i ∈ t → ∀ (j : ι), j ∈ t → relation.refl_trans_gen (λ (i j : ι), (s i ∩ s j).nonempty ∧ i ∈ t) i j) : is_connected (⋃ (n : ι) (H : n ∈ t), s n)
theorem measure_theory.lintegral_eq_nnreal {α : Type u_1} {m : measurable_space α} (f : α → ennreal) (μ : measure_theory.measure α) : ∫⁻ (a : α), f a ∂μ = ⨆ (φ : measure_theory.simple_func α nnreal) (hf : ∀ (x : α), ↑(⇑φ x) ≤ f x), (measure_theory.simple_func.map coe φ).lintegral μ
theorem indexed_partition.out_proj {ι : Type u_1} {α : Type u_2} {s : ι → set α} (hs : indexed_partition s) (x : α) : ⇑(hs.out) (hs.proj x) = hs.some (hs.index x)
theorem monotone.sup {α : Type u} {β : Type v} [preorder α] [semilattice_sup β] {f g : α → β} (hf : monotone f) (hg : monotone g) : monotone (f ⊔ g)
theorem option.subsingleton_iff_is_empty {α : Type u_1} : subsingleton (option α) ↔ is_empty α
theorem cardinal.sum_lt_prod {ι : Type u_1} (f g : ι → cardinal) (H : ∀ (i : ι), f i < g i) : cardinal.sum f < cardinal.prod g
theorem orientation.two_zsmul_oangle_neg_left {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x y : V) : 2 • o.oangle (-x) y = 2 • o.oangle x y
theorem category_theory.limits.is_colimit.exists_unique {J : Type u₁} [category_theory.category J] {C : Type u₃} [category_theory.category C] {F : J ⥤ C} {t : category_theory.limits.cocone F} (h : category_theory.limits.is_colimit t) (s : category_theory.limits.cocone F) : ∃! (d : t.X ⟶ s.X), ∀ (j : J), t.ι.app j ≫ d = s.ι.app j
theorem function.periodic.exists_mem_Ioc {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x a : α) : ∃ (y : α) (H : y ∈ set.Ioc a (a + c)), f x = f y
theorem tensor_product.smul_tmul {R : Type u_1} [comm_semiring R] {R' : Type u_2} [monoid R'] {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] [distrib_mul_action R' M] [distrib_mul_action R' N] [tensor_product.compatible_smul R R' M N] (r : R') (m : M) (n : N) : (r • m) ⊗ₜ[R] n = m ⊗ₜ[R] (r • n)
theorem fderiv_measurable_aux.D_subset_differentiable_set {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {K : set (E →L[𝕜] F)} (hK : is_complete K) : fderiv_measurable_aux.D f K ⊆ {x : E | differentiable_at 𝕜 f x ∧ fderiv 𝕜 f x ∈ K}
theorem emetric.diam_subsingleton {α : Type u} [pseudo_emetric_space α] {s : set α} (hs : s.subsingleton) : emetric.diam s = 0
theorem subfield.mem_supr_of_directed {K : Type u} [field K] {ι : Sort u_1} [hι : nonempty ι] {S : ι → subfield K} (hS : directed has_le.le S) {x : K} : (x ∈ ⨆ (i : ι), S i) ↔ ∃ (i : ι), x ∈ S i
theorem measure_theory.adapted.stopped_process_of_nat {α : Type u_1} {β : Type u_2} {m : measurable_space α} {f : measure_theory.filtration ℕ m} {u : ℕ → α → β} {τ : α → ℕ} [add_comm_monoid β] [topological_space β] [has_continuous_add β] (hu : measure_theory.adapted f u) (hτ : measure_theory.is_stopping_time f τ) : measure_theory.adapted f (measure_theory.stopped_process u τ)
theorem add_pos' {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
theorem inner_map_self_eq_zero {V : Type u_4} [inner_product_space ℂ V] (T : V →ₗ[ℂ] V) : (∀ (x : V), has_inner.inner (⇑T x) x = 0) ↔ T = 0
theorem submodule.not_mem_span_of_apply_not_mem_span_image {R : Type u_1} {R₂ : Type u_2} {M : Type u_4} {M₂ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring R₂] {σ₁₂ : R →+* R₂} [add_comm_monoid M₂] [module R₂ M₂] [ring_hom_surjective σ₁₂] (f : M →ₛₗ[σ₁₂] M₂) {x : M} {s : set M} (h : ⇑f x ∉ submodule.span R₂ (⇑f '' s)) : x ∉ submodule.span R s
theorem measurable.exists_continuous {α : Type u_1} {β : Type u_2} [t : topological_space α] [polish_space α] [measurable_space α] [borel_space α] [tβ : topological_space β] [topological_space.second_countable_topology β] [measurable_space β] [borel_space β] {f : α → β} (hf : measurable f) : ∃ (t' : topological_space α), t' ≤ t ∧ continuous f ∧ polish_space α
theorem tendsto_uniformly.continuous {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {p : filter ι} [topological_space α] (h : tendsto_uniformly F f p) (hc : ∀ᶠ (n : ι) in p, continuous (F n)) [p.ne_bot] : continuous f
theorem formal_multilinear_series.comp_summable_nnreal {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] [normed_group G] [normed_space 𝕜 G] (q : formal_multilinear_series 𝕜 F G) (p : formal_multilinear_series 𝕜 E F) (hq : 0 < q.radius) (hp : 0 < p.radius) : ∃ (r : nnreal) (H : r > 0), summable (λ (i : Σ (n : ℕ), composition n), ∥q.comp_along_composition p i.snd∥₊ * r ^ i.fst)
theorem rack.assoc_iff_id {R : Type u_1} [rack R] {x y z : R} : shelf.act x (shelf.act y z) = shelf.act (shelf.act x y) z ↔ shelf.act x z = z
theorem ring_hom.map_zero {α : Type u_2} {β : Type u_3} {rα : non_assoc_semiring α} {rβ : non_assoc_semiring β} (f : α →+* β) : ⇑f 0 = 0
theorem ring_hom.codomain_trivial_iff_map_one_eq_zero {α : Type u_2} {β : Type u_3} {rα : non_assoc_semiring α} {rβ : non_assoc_semiring β} (f : α →+* β) : 0 = 1 ↔ ⇑f 1 = 0
theorem orientation.two_zsmul_oangle_smul_left_of_ne_zero {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x y : V) {r : ℝ} (hr : r ≠ 0) : 2 • o.oangle (r • x) y = 2 • o.oangle x y
theorem complex.abs_add (z w : ℂ) : complex.abs (z + w) ≤ complex.abs z + complex.abs w
theorem sub_lt_self {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] [covariant_class α α (function.swap has_add.add) has_lt.lt] (a : α) {b : α} : 0 < b → a - b < a
theorem has_deriv_at.lhopital_zero_nhds_left {a : ℝ} {l : filter ℝ} {f f' g g' : ℝ → ℝ} (hff' : ∀ᶠ (x : ℝ) in nhds_within a (set.Iio a), has_deriv_at f (f' x) x) (hgg' : ∀ᶠ (x : ℝ) in nhds_within a (set.Iio a), has_deriv_at g (g' x) x) (hg' : ∀ᶠ (x : ℝ) in nhds_within a (set.Iio a), g' x ≠ 0) (hfa : filter.tendsto f (nhds_within a (set.Iio a)) (nhds 0)) (hga : filter.tendsto g (nhds_within a (set.Iio a)) (nhds 0)) (hdiv : filter.tendsto (λ (x : ℝ), f' x / g' x) (nhds_within a (set.Iio a)) l) : filter.tendsto (λ (x : ℝ), f x / g x) (nhds_within a (set.Iio a)) l
theorem affine_subspace.coe_direction_eq_vsub_set_left {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p : P} (hp : p ∈ s) : ↑(s.direction) = has_vsub.vsub p '' ↑s
theorem is_torsion.exponent_exists {G : Type u_1} [group G] (tG : monoid.is_torsion G) (bounded : (set.range (λ (g : G), order_of g)).finite) : monoid.exponent_exists G
theorem weak_dual.is_compact_closed_ball (𝕜 : Type u_1) [nondiscrete_normed_field 𝕜] {E : Type u_2} [semi_normed_group E] [normed_space 𝕜 E] [proper_space 𝕜] (x' : normed_space.dual 𝕜 E) (r : ℝ) : is_compact (⇑weak_dual.to_normed_dual ⁻¹' metric.closed_ball x' r)
theorem basis.equiv_fun_symm_apply {ι : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [fintype ι] (b : basis ι R M) (x : ι → R) : ⇑(b.equiv_fun.symm) x = finset.univ.sum (λ (i : ι), x i • ⇑b i)
theorem measure_theory.exists_upper_semicontinuous_lt_integral_gt {α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] {μ : measure_theory.measure α} [μ.weakly_regular] [measure_theory.sigma_finite μ] (f : α → ℝ) (hf : measure_theory.integrable f μ) {ε : ℝ} (εpos : 0 < ε) : ∃ (g : α → ereal), (∀ (x : α), g x < ↑(f x)) ∧ upper_semicontinuous g ∧ measure_theory.integrable (λ (x : α), (g x).to_real) μ ∧ (∀ᵐ (x : α) ∂μ, ⊥ < g x) ∧ ∫ (x : α), f x ∂μ < ∫ (x : α), (g x).to_real ∂μ + ε
theorem emetric.Hausdorff_edist_empty {α : Type u} [pseudo_emetric_space α] {s : set α} (ne : s.nonempty) : emetric.Hausdorff_edist s ∅ = ⊤
theorem not_not {a : Prop} : ¬¬a ↔ a
theorem orthonormal.two_zsmul_oangle_smul_left_self {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x : V) {r : ℝ} : 2 • hb.oangle (r • x) x = 0
theorem ennreal.lintegral_mul_le_Lp_mul_Lq {α : Type u_1} [measurable_space α] (μ : measure_theory.measure α) {p q : ℝ} (hpq : p.is_conjugate_exponent q) {f g : α → ennreal} (hf : ae_measurable f μ) (hg : ae_measurable g μ) : ∫⁻ (a : α), (f * g) a ∂μ ≤ (∫⁻ (a : α), f a ^ p ∂μ) ^ (1 / p) * (∫⁻ (a : α), g a ^ q ∂μ) ^ (1 / q)
theorem strict_anti.dual_left {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} : strict_anti f → strict_mono (f ∘ ⇑order_dual.of_dual)
theorem of_set_mem_cont_diff_groupoid (n : with_top ℕ) {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {s : set H} (hs : is_open s) : local_homeomorph.of_set s hs ∈ cont_diff_groupoid n I
theorem local_homeomorph.eq_on_source.source_eq {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {e e' : local_homeomorph α β} (h : e ≈ e') : e.to_local_equiv.source = e'.to_local_equiv.source
theorem category_theory.limits.has_colimit_of_iso {J : Type u₁} [category_theory.category J] {C : Type u} [category_theory.category C] {F G : J ⥤ C} [category_theory.limits.has_colimit F] (α : G ≅ F) : category_theory.limits.has_colimit G
theorem topological_space.exists_dense_seq (α : Type u) [t : topological_space α] [topological_space.separable_space α] [nonempty α] : ∃ (u : ℕ → α), dense_range u
theorem submodule.finrank_add_finrank_orthogonal {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [finite_dimensional 𝕜 E] (K : submodule 𝕜 E) : finite_dimensional.finrank 𝕜 ↥K + finite_dimensional.finrank 𝕜 ↥Kᗮ = finite_dimensional.finrank 𝕜 E
theorem measure_theory.is_stopping_time.piecewise_of_le {α : Type u_1} {ι : Type u_3} {m : measurable_space α} [preorder ι] {𝒢 : measure_theory.filtration ι m} {τ η : α → ι} {i : ι} {s : set α} [decidable_pred (λ (_x : α), _x ∈ s)] (hτ_st : measure_theory.is_stopping_time 𝒢 τ) (hη_st : measure_theory.is_stopping_time 𝒢 η) (hτ : ∀ (x : α), i ≤ τ x) (hη : ∀ (x : α), i ≤ η x) (hs : measurable_set s) : measure_theory.is_stopping_time 𝒢 (s.piecewise τ η)
theorem exists_subset_affine_independent_span_eq_top_of_open {V : Type u_1} {P : Type u_2} [normed_group V] [normed_space ℝ V] [metric_space P] [normed_add_torsor V P] {s u : set P} (hu : is_open u) (hsu : s ⊆ u) (hne : s.nonempty) (h : affine_independent ℝ coe) : ∃ (t : set P), s ⊆ t ∧ t ⊆ u ∧ affine_independent ℝ coe ∧ affine_span ℝ t = ⊤
theorem measure_theory.outer_measure.is_metric.borel_le_caratheodory {X : Type u_2} [emetric_space X] {μ : measure_theory.outer_measure X} (hm : μ.is_metric) : borel X ≤ μ.caratheodory
theorem same_ray_nonneg_smul_right {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (v : M) {r : R} (h : 0 ≤ r) : same_ray R v (r • v)
theorem algebraic_geometry.PresheafedSpace.glue_data.opens_image_preimage_map_app {C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) [category_theory.limits.has_limits C] (i j k : D.to_glue_data.J) (U : topological_space.opens ↥((D.to_glue_data.U i).carrier)) : D.opens_image_preimage_map i j U ≫ (D.to_glue_data.f j k).c.app (opposite.op ((topological_space.opens.map (D.to_glue_data.ι j).base).obj (_.functor.obj U))) = (category_theory.limits.pullback.fst ≫ D.to_glue_data.t j i ≫ D.to_glue_data.f i j).c.app (opposite.op U) ≫ _.inv_app (opposite.unop ((topological_space.opens.map (category_theory.limits.pullback.fst ≫ D.to_glue_data.t j i ≫ D.to_glue_data.f i j).base).op.obj (opposite.op U))) ≫ (D.to_glue_data.V (j, k)).presheaf.map (category_theory.eq_to_hom _)
theorem squeeze_zero_norm' {α : Type u_1} {E : Type u_3} [semi_normed_group E] {f : α → E} {g : α → ℝ} {t₀ : filter α} (h : ∀ᶠ (n : α) in t₀, ∥f n∥ ≤ g n) (h' : filter.tendsto g t₀ (nhds 0)) : filter.tendsto f t₀ (nhds 0)
theorem cont_diff_groupoid_prod {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I : model_with_corners 𝕜 E H} {I' : model_with_corners 𝕜 E' H'} {e : local_homeomorph H H} {e' : local_homeomorph H' H'} (he : e ∈ cont_diff_groupoid ⊤ I) (he' : e' ∈ cont_diff_groupoid ⊤ I') : e.prod e' ∈ cont_diff_groupoid ⊤ (I.prod I')
theorem strict_mono.dual_left {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} : strict_mono f → strict_anti (f ∘ ⇑order_dual.of_dual)
theorem is_torsion_free.quotient_torsion (G : Type u_1) [comm_group G] : monoid.is_torsion_free (G ⧸ torsion G)
theorem add_equiv.map_sum {β : Type u} {α : Type v} {γ : Type w} [add_comm_monoid β] [add_comm_monoid γ] (g : β ≃+ γ) (f : α → β) (s : finset α) : ⇑g (s.sum (λ (x : α), f x)) = s.sum (λ (x : α), ⇑g (f x))
theorem holder_on_with.hausdorff_measure_image_le {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [measurable_space X] [borel_space X] [measurable_space Y] [borel_space Y] {C r : nnreal} {f : X → Y} {s : set X} (h : holder_on_with C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) : ⇑(measure_theory.measure.hausdorff_measure d) (f '' s) ≤ ↑C ^ d * ⇑(measure_theory.measure.hausdorff_measure (↑r * d)) s
theorem euclidean_geometry.left_dist_ne_zero_of_angle_eq_pi {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : euclidean_geometry.angle p1 p2 p3 = real.pi) : has_dist.dist p1 p2 ≠ 0
theorem is_of_fin_order_inv_iff {G : Type u} [group G] {x : G} : is_of_fin_order x⁻¹ ↔ is_of_fin_order x
theorem continuous_multilinear_map.norm_image_sub_le' {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : continuous_multilinear_map 𝕜 E G) (m₁ m₂ : Π (i : ι), E i) : ∥⇑f m₁ - ⇑f m₂∥ ≤ ∥f∥ * finset.univ.sum (λ (i : ι), finset.univ.prod (λ (j : ι), ite (j = i) ∥m₁ i - m₂ i∥ (linear_order.max ∥m₁ j∥ ∥m₂ j∥)))
theorem complex.dist_le_dist_of_maps_to_ball_self {f : ℂ → ℂ} {c z : ℂ} {R : ℝ} (hd : differentiable_on ℂ f (metric.ball c R)) (h_maps : set.maps_to f (metric.ball c R) (metric.ball c R)) (hc : f c = c) (hz : z ∈ metric.ball c R) : has_dist.dist (f z) c ≤ has_dist.dist z c
theorem fg_of_fg_of_fg (A : Type w) (B : Type u₁) (C : Type u_1) [comm_ring A] [comm_ring B] [comm_ring C] [algebra A B] [algebra B C] [algebra A C] [is_scalar_tower A B C] [is_noetherian_ring A] (hAC : ⊤.fg) (hBC : ⊤.fg) (hBCi : function.injective ⇑(algebra_map B C)) : ⊤.fg
theorem monovary_on.sum_comp_perm_mul_lt_sum_mul_iff {ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {s : finset ι} {σ : equiv.perm ι} {f g : ι → α} (hfg : monovary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f (⇑σ i) * g i) < s.sum (λ (i : ι), f i * g i) ↔ ¬monovary_on (f ∘ ⇑σ) g ↑s
theorem finsupp.single_injective {α : Type u_1} {M : Type u_5} [has_zero M] (a : α) : function.injective (finsupp.single a)
theorem image_sub_lt_mul_sub_of_deriv_lt {f : ℝ → ℝ} (hf : differentiable ℝ f) {C : ℝ} (lt_hf' : ∀ (x : ℝ), deriv f x < C) ⦃x y : ℝ⦄ (hxy : x < y) : f y - f x < C * (y - x)
theorem add_monoid_hom.map_neg {α : Type u_1} {β : Type u_2} [add_group α] [subtraction_monoid β] (f : α →+ β) (a : α) : ⇑f (-a) = -⇑f a
theorem lie_module.is_nilpotent_iff (R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] : lie_module.is_nilpotent R L M ↔ ∃ (k : ℕ), lie_module.lower_central_series R L M k = ⊥
theorem disjoint.exists_open_convexes {E : Type u_2} [semi_normed_group E] [normed_space ℝ E] {s t : set E} (disj : disjoint s t) (hs₁ : convex ℝ s) (hs₂ : is_compact s) (ht₁ : convex ℝ t) (ht₂ : is_closed t) : ∃ (u v : set E), is_open u ∧ is_open v ∧ convex ℝ u ∧ convex ℝ v ∧ s ⊆ u ∧ t ⊆ v ∧ disjoint u v
theorem linear_map.pow_eq_aeval_mod_charpoly {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M →ₗ[R] M) (k : ℕ) : f ^ k = ⇑(polynomial.aeval f) (polynomial.X ^ k %ₘ f.charpoly)
theorem matrix.mul_mul_inv_of_self_cancel {m : Type u} {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix m n α) (B : matrix n n α) [invertible B] : (A.mul B).mul (⅟ B) = A
theorem emetric.mem_closure_iff_inf_edist_zero {α : Type u} [pseudo_emetric_space α] {x : α} {s : set α} : x ∈ closure s ↔ emetric.inf_edist x s = 0
theorem continuous.surjective' {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {δ : Type u_1} [linear_order δ] [topological_space δ] [order_closed_topology δ] {f : α → δ} (hf : continuous f) (h_top : filter.tendsto f filter.at_bot filter.at_top) (h_bot : filter.tendsto f filter.at_top filter.at_bot) : function.surjective f
theorem measure_theory.signed_measure.singular_part_add_with_density_rn_deriv_eq {α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) (s : measure_theory.signed_measure α) [s.have_lebesgue_decomposition μ] : s.singular_part μ + μ.with_densityᵥ (s.rn_deriv μ) = s
theorem exists_open_set_nhds' {α : Type u} [topological_space α] {s U : set α} (h : U ∈ ⨆ (x : α) (H : x ∈ s), nhds x) : ∃ (V : set α), s ⊆ V ∧ is_open V ∧ V ⊆ U
theorem strict_concave_on.translate_left {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_cancel_comm_monoid E] [ordered_add_comm_monoid β] [module 𝕜 E] [has_scalar 𝕜 β] {s : set E} {f : E → β} (hf : strict_concave_on 𝕜 s f) (c : E) : strict_concave_on 𝕜 ((λ (z : E), c + z) ⁻¹' s) (f ∘ λ (z : E), z + c)
theorem algebra.trace_algebra_map {K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] (x : K) : ⇑(algebra.trace K L) (⇑(algebra_map K L) x) = finite_dimensional.finrank K L • x
theorem measure_theory.lintegral_supr' {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : ℕ → α → ennreal} (hf : ∀ (n : ℕ), ae_measurable (f n) μ) (h_mono : ∀ᵐ (x : α) ∂μ, monotone (λ (n : ℕ), f n x)) : ∫⁻ (a : α), (⨆ (n : ℕ), f n a) ∂μ = ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
theorem polynomial.cyclotomic.irreducible_rat {n : ℕ} (hpos : 0 < n) : irreducible (polynomial.cyclotomic n ℚ)
theorem orthonormal.oangle_sub_eq_oangle_sub_rev_of_norm_eq {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y : V} (h : ∥x∥ = ∥y∥) : hb.oangle x (x - y) = hb.oangle (y - x) y
theorem is_pi_system.prod {α : Type u_1} {β : Type u_3} {C : set (set α)} {D : set (set β)} (hC : is_pi_system C) (hD : is_pi_system D) : is_pi_system (set.image2 has_set_prod.prod C D)
theorem has_strict_deriv_at_exp_zero_of_radius_pos {𝕂 : Type u_1} [nondiscrete_normed_field 𝕂] [complete_space 𝕂] (h : 0 < (exp_series 𝕂 𝕂).radius) : has_strict_deriv_at (exp 𝕂) 1 0
theorem spectrum.differentiable_on_inverse_one_sub_smul {𝕜 : Type u_1} {A : Type u_2} [nondiscrete_normed_field 𝕜] [normed_ring A] [normed_algebra 𝕜 A] [complete_space A] {a : A} {r : nnreal} (hr : ↑r < (spectral_radius 𝕜 a)⁻¹) : differentiable_on 𝕜 (λ (z : 𝕜), ring.inverse (1 - z • a)) (metric.closed_ball 0 ↑r)
theorem list.permutations_aux2_comp_append {α : Type u_1} {β : Type u_2} {t : α} {ts ys : list α} {r : list β} (f : list α → β) : (list.permutations_aux2 t list.nil r ys (λ (x : list α), f (x ++ ts))).snd = (list.permutations_aux2 t ts r ys f).snd
theorem relation.cut_expand_fibration {α : Type u_1} (r : α → α → Prop) : relation.fibration (relation.game_add (relation.cut_expand r) (relation.cut_expand r)) (relation.cut_expand r) (λ (s : multiset α × multiset α), s.fst + s.snd)
theorem nat.factors_count_eq {n p : ℕ} : list.count p n.factors = ⇑(n.factorization) p
theorem intermediate_field.mul_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} : x ∈ S → y ∈ S → x * y ∈ S
theorem antitone.min {α : Type u} {β : Type v} [preorder α] [linear_order β] {f g : α → β} (hf : antitone f) (hg : antitone g) : antitone (λ (x : α), linear_order.min (f x) (g x))
theorem asymptotics.is_o.of_norm_right {α : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : α → E} {g' : α → F'} {l : filter α} : (f =o[l] λ (x : α), ∥g' x∥) → f =o[l] g'
theorem cont_diff_on_of_continuous_on_differentiable_on_deriv {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {s : set 𝕜} {n : with_top ℕ} (Hcont : ∀ (m : ℕ), ↑m ≤ n → continuous_on (λ (x : 𝕜), iterated_deriv_within m f s x) s) (Hdiff : ∀ (m : ℕ), ↑m < n → differentiable_on 𝕜 (λ (x : 𝕜), iterated_deriv_within m f s x) s) : cont_diff_on 𝕜 n f s
theorem measure_theory.fin_strongly_measurable_iff_measurable {α : Type u_1} {G : Type u_5} [normed_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] {f : α → G} {m0 : measurable_space α} (μ : measure_theory.measure α) [measure_theory.sigma_finite μ] : measure_theory.fin_strongly_measurable f μ ↔ measurable f
theorem euclidean_geometry.angle_eq_angle_of_angle_eq_pi {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (p1 : P) {p2 p3 p4 : P} (h : euclidean_geometry.angle p2 p3 p4 = real.pi) : euclidean_geometry.angle p1 p2 p3 = euclidean_geometry.angle p1 p2 p4
theorem measure_theory.outer_measure.ext_nonempty {α : Type u_1} {μ₁ μ₂ : measure_theory.outer_measure α} (h : ∀ (s : set α), s.nonempty → ⇑μ₁ s = ⇑μ₂ s) : μ₁ = μ₂
theorem finset.prod_product' {β : Type u} {α : Type v} {γ : Type w} [comm_monoid β] {s : finset γ} {t : finset α} {f : γ → α → β} : (s.product t).prod (λ (x : γ × α), f x.fst x.snd) = s.prod (λ (x : γ), t.prod (λ (y : α), f x y))
theorem continuous_at_left_of_monotone_on_of_closure_image_mem_nhds_within {α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (hf : monotone_on f s) (hs : s ∈ nhds_within a (set.Iic a)) (hfs : closure (f '' s) ∈ nhds_within (f a) (set.Iic (f a))) : continuous_within_at f (set.Iic a) a
theorem Top.presheaf.is_sheaf_iff_is_sheaf_preserves_limit_pairwise_intersections {X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) : F.is_sheaf ↔ F.is_sheaf_preserves_limit_pairwise_intersections
theorem inner_product_geometry.angle_smul_left_of_neg {V : Type u_1} [inner_product_space ℝ V] (x y : V) {r : ℝ} (hr : r < 0) : inner_product_geometry.angle (r • x) y = inner_product_geometry.angle (-x) y
theorem category_theory.adjunction.has_limits_of_shape_of_equivalence {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {J : Type u} [category_theory.category J] (E : D ⥤ C) [category_theory.is_equivalence E] [category_theory.limits.has_limits_of_shape J C] : category_theory.limits.has_limits_of_shape J D
theorem antitone.dual_left {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} : antitone f → monotone (f ∘ ⇑order_dual.of_dual)
theorem measure_theory.ae_restrict_of_ae_eq_of_ae_restrict {α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {s t : α → Prop} (hst : s =ᵐ[μ] t) {p : α → Prop} : (∀ᵐ (x : α) ∂μ.restrict s, p x) → (∀ᵐ (x : α) ∂μ.restrict t, p x)
theorem exists_locally_finite_Union_eq_ball_radius_lt {α : Type u} [metric_space α] [proper_space α] {R : α → ℝ} (hR : ∀ (x : α), 0 < R x) : ∃ (ι : Type u) (c : ι → α) (r r' : ι → ℝ), (∀ (i : ι), 0 < r i ∧ r i < r' i ∧ r' i < R (c i)) ∧ locally_finite (λ (i : ι), metric.ball (c i) (r' i)) ∧ (⋃ (i : ι), metric.ball (c i) (r i)) = set.univ
theorem sylow.card_quotient_normalizer_modeq_card_quotient {G : Type u} [group G] [fintype G] {p n : ℕ} [hp : fact (nat.prime p)] {H : subgroup G} (hH : fintype.card ↥H = p ^ n) : fintype.card (↥(H.normalizer) ⧸ subgroup.comap H.normalizer.subtype H) ≡ fintype.card (G ⧸ H) [MOD p]
theorem power_series.order_le {R : Type u_1} [semiring R] {φ : power_series R} (n : ℕ) (h : ⇑(power_series.coeff R n) φ ≠ 0) : φ.order ≤ ↑n
theorem mdifferentiable_within_at.differentiable_within_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {f : E → E'} {s : set E} {x : E} : mdifferentiable_within_at (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f s x → differentiable_within_at 𝕜 f s x
theorem complex.continuous_at_cpow_zero_of_re_pos {z : ℂ} (hz : 0 < z.re) : continuous_at (λ (x : ℂ × ℂ), x.fst ^ x.snd) (0, z)
theorem add_submonoid.localization_map.lift_add_left {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M →+ P} (hg : ∀ (y : ↥S), is_add_unit (⇑g ↑y)) (z : N) : ⇑g ↑((f.sec z).snd) + ⇑(f.lift hg) z = ⇑g (f.sec z).fst
theorem nat.prod_pow_factorization_eq_self {f : ℕ →₀ ℕ} (hf : ∀ (p : ℕ), p ∈ f.support → nat.prime p) : (f.prod has_pow.pow).factorization = f
theorem compact_std_simplex (ι : Type u_1) [fintype ι] : is_compact (std_simplex ℝ ι)
theorem Gromov_Hausdorff.HD_candidates_b_dist_le {X : Type u} {Y : Type v} [metric_space X] [compact_space X] [nonempty X] [metric_space Y] [compact_space Y] [nonempty Y] : Gromov_Hausdorff.HD (Gromov_Hausdorff.candidates_b_dist X Y) ≤ metric.diam set.univ + 1 + metric.diam set.univ
theorem category_theory.abelian.image.fac {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_kernels C] [category_theory.limits.has_cokernels C] {P Q : C} (f : P ⟶ Q) : category_theory.abelian.factor_thru_image f ≫ category_theory.abelian.image.ι f = f
theorem not_bdd_above_iff' {α : Type u} [preorder α] {s : set α} : ¬bdd_above s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), ¬y ≤ x
theorem pythagorean_triple_comm {x y z : ℤ} : pythagorean_triple x y z ↔ pythagorean_triple y x z
theorem set.finite.dimH_zero {X : Type u_2} [emetric_space X] {s : set X} (hs : s.finite) : dimH s = 0
theorem is_dedekind_domain.inf_prime_pow_eq_prod {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] {ι : Type u_2} (s : finset ι) (f : ι → ideal R) (e : ι → ℕ) (prime : ∀ (i : ι), i ∈ s → _root_.prime (f i)) (coprime : ∀ (i : ι), i ∈ s → ∀ (j : ι), j ∈ s → i ≠ j → f i ≠ f j) : s.inf (λ (i : ι), f i ^ e i) = s.prod (λ (i : ι), f i ^ e i)
theorem int.le_zpow_iff_clog_le {R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r) : r ≤ ↑b ^ x ↔ int.clog b r ≤ x
theorem linear_map.is_Ortho.not_is_ortho_basis_self_of_separating_right {R : Type u_1} {M : Type u_5} {n : Type u_14} [comm_ring R] [add_comm_group M] [module R M] {I I' : R →+* R} [nontrivial R] {B : M →ₛₗ[I] M →ₛₗ[I'] R} {v : basis n R M} (h : B.is_Ortho ⇑v) (hB : B.separating_right) (i : n) : ¬B.is_ortho (⇑v i) (⇑v i)
theorem category_theory.presheaf.is_limit_iff_is_sheaf_for {C : Type u₁} [category_theory.category C] {A : Type u₂} [category_theory.category A] (P : Cᵒᵖ ⥤ A) {X : C} (S : category_theory.sieve X) : nonempty (category_theory.limits.is_limit (P.map_cone S.arrows.cocone.op)) ↔ ∀ (E : Aᵒᵖ), category_theory.presieve.is_sheaf_for (P ⋙ category_theory.coyoneda.obj E) ⇑S
theorem unique_mdiff_on.unique_diff_on_target_inter {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} (hs : unique_mdiff_on I s) (x : M) : unique_diff_on 𝕜 ((ext_chart_at I x).target ∩ ⇑((ext_chart_at I x).symm) ⁻¹' s)
theorem measure_theory.measure.le_map_apply {α : Type u_1} {β : Type u_2} {m0 : measurable_space α} [measurable_space β] {μ : measure_theory.measure α} {f : α → β} (hf : ae_measurable f μ) (s : set β) : ⇑μ (f ⁻¹' s) ≤ ⇑(measure_theory.measure.map f μ) s
theorem gram_schmidt_pairwise_orthogonal (𝕜 : Type u_1) {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_3} [linear_order ι] [order_bot ι] [locally_finite_order ι] [is_well_order ι has_lt.lt] (f : ι → E) : pairwise (λ (a b : ι), has_inner.inner (gram_schmidt 𝕜 f a) (gram_schmidt 𝕜 f b) = 0)
theorem convex.mem_Icc {𝕜 : Type u_1} [linear_ordered_field 𝕜] {x y : 𝕜} (h : x ≤ y) {z : 𝕜} : z ∈ set.Icc x y ↔ ∃ (a b : 𝕜), 0 ≤ a ∧ 0 ≤ b ∧ a + b = 1 ∧ a * x + b * y = z
theorem homology.ext {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {A B C : V} (f : A ⟶ B) [category_theory.limits.has_image f] (g : B ⟶ C) [category_theory.limits.has_kernel g] (w : f ≫ g = 0) [category_theory.limits.has_cokernel (image_to_kernel f g w)] {D : V} {k k' : homology f g w ⟶ D} (p : homology.π f g w ≫ k = homology.π f g w ≫ k') : k = k'
theorem add_is_torsion.quotient_iff {G : Type u_1} {H : Type u_2} [add_group G] {N : add_subgroup G} [add_group H] {f : G →+ H} (hf : function.surjective ⇑f) (hN : N = f.ker) (tN : add_monoid.is_torsion ↥N) : add_monoid.is_torsion H ↔ add_monoid.is_torsion G
theorem nat.le_induction {P : ℕ → Prop} {m : ℕ} (h0 : P m) (h1 : ∀ (n : ℕ), m ≤ n → P n → P (n + 1)) (n : ℕ) : m ≤ n → P n
theorem monovary.sum_comp_perm_smul_eq_sum_smul_iff {ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {σ : equiv.perm ι} {f : ι → α} {g : ι → β} [fintype ι] (hfg : monovary f g) : finset.univ.sum (λ (i : ι), f (⇑σ i) • g i) = finset.univ.sum (λ (i : ι), f i • g i) ↔ monovary (f ∘ ⇑σ) g
theorem euclidean_geometry.dist_orthogonal_projection_eq_zero_iff {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} [nonempty ↥s] [complete_space ↥(s.direction)] {p : P} : has_dist.dist p ↑(⇑(euclidean_geometry.orthogonal_projection s) p) = 0 ↔ p ∈ s
theorem finset.subset_vsub {α : Type u_2} {β : Type u_3} [decidable_eq α] [has_vsub α β] {u : finset α} {s t : set β} : ↑u ⊆ s -ᵥ t → (∃ (s' t' : finset β), ↑s' ⊆ s ∧ ↑t' ⊆ t ∧ u ⊆ s' -ᵥ t')
theorem monovary.sum_smul_comp_perm_le_sum_smul {ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {σ : equiv.perm ι} {f : ι → α} {g : ι → β} [fintype ι] (hfg : monovary f g) : finset.univ.sum (λ (i : ι), f i • g (⇑σ i)) ≤ finset.univ.sum (λ (i : ι), f i • g i)
theorem exists_seq_of_forall_finset_exists {α : Type u_1} (P : α → Prop) (r : α → α → Prop) (h : ∀ (s : finset α), (∀ (x : α), x ∈ s → P x) → (∃ (y : α), P y ∧ ∀ (x : α), x ∈ s → r x y)) : ∃ (f : ℕ → α), (∀ (n : ℕ), P (f n)) ∧ ∀ (m n : ℕ), m < n → r (f m) (f n)
theorem measure_theory.measure.have_lebesgue_decomposition_of_finite_measure {α : Type u_1} {m : measurable_space α} {μ ν : measure_theory.measure α} [measure_theory.is_finite_measure μ] [measure_theory.is_finite_measure ν] : μ.have_lebesgue_decomposition ν
theorem dense_Inter_of_open {α : Type u_1} {β : Type u_2} [topological_space α] [baire_space α] [encodable β] {f : β → set α} (ho : ∀ (s : β), is_open (f s)) (hd : ∀ (s : β), dense (f s)) : dense (⋂ (s : β), f s)
theorem orthonormal.rotation_eq_of_orientation_eq {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {b₂ : basis (fin 2) ℝ V} (hb₂ : orthonormal ℝ ⇑b₂) (ho : b.orientation = b₂.orientation) (θ : real.angle) : hb.rotation θ = hb₂.rotation θ
theorem is_of_fin_order_neg_iff {G : Type u} [add_group G] {x : G} : is_of_fin_add_order (-x) ↔ is_of_fin_add_order x
theorem generalized_continued_fraction.of_one_le_nth_part_denom {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {b : K} (nth_part_denom_eq : (generalized_continued_fraction.of v).partial_denominators.nth n = option.some b) : 1 ≤ b
theorem metric.continuous_inf_dist_pt {α : Type u} [pseudo_metric_space α] (s : set α) : continuous (λ (x : α), metric.inf_dist x s)
theorem contracting_with.is_fixed_pt_fixed_point_iterate {α : Type u_1} [metric_space α] {K : nnreal} {f : α → α} [nonempty α] [complete_space α] {n : ℕ} (hf : contracting_with K f^[n]) : function.is_fixed_pt f (contracting_with.fixed_point f^[n] hf)
theorem orientation.oangle_eq_two_zsmul_oangle_sub_of_norm_eq_real {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y z : V} (hxyne : x ≠ y) (hxzne : x ≠ z) {r : ℝ} (hx : ∥x∥ = r) (hy : ∥y∥ = r) (hz : ∥z∥ = r) : o.oangle y z = 2 • o.oangle (y - x) (z - x)
theorem orthonormal.two_zsmul_oangle_neg_self_left {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x : V) : 2 • hb.oangle (-x) x = 0
theorem measurable.of_comap_le {α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : measurable_space.comap f m₂ ≤ m₁ → measurable f
theorem besicovitch.tau_package.mem_Union_up_to_last_step {α : Type u_1} [metric_space α] {β : Type u} [nonempty β] (p : besicovitch.tau_package β α) (x : β) : p.to_ball_package.c x ∈ p.Union_up_to p.last_step
theorem ring_hom.not_one_mem_ker {R : Type u} {S : Type v} [semiring R] [semiring S] [nontrivial S] (f : R →+* S) : 1 ∉ f.ker
theorem finset.prod_subtype_eq_prod_filter {β : Type u} {α : Type v} {s : finset α} [comm_monoid β] (f : α → β) {p : α → Prop} [decidable_pred p] : (finset.subtype p s).prod (λ (x : subtype p), f ↑x) = (finset.filter p s).prod (λ (x : α), f x)
theorem zero_lt.left.mul_nonneg {α : Type u} {a b : α} [mul_zero_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a * b
theorem Top.open_embedding_of_pullback_open_embeddings {X Y S : Top} {f : X ⟶ S} {g : Y ⟶ S} (H₁ : open_embedding ⇑f) (H₂ : open_embedding ⇑g) : open_embedding ⇑(category_theory.limits.limit.π (category_theory.limits.cospan f g) category_theory.limits.walking_cospan.one)
theorem affine_subspace.sup_direction_le {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P) : s1.direction ⊔ s2.direction ≤ (s1 ⊔ s2).direction
theorem ideal.quotient.maximal_of_is_field {R : Type u} [comm_ring R] (I : ideal R) (hqf : is_field (R ⧸ I)) : I.is_maximal
theorem differentiable.analytic_at {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] {f : ℂ → E} (hf : differentiable ℂ f) (z : ℂ) : analytic_at ℂ f z
theorem is_preconnected.bUnion_of_refl_trans_gen {α : Type u} [topological_space α] {ι : Type u_1} {t : set ι} {s : ι → set α} (H : ∀ (i : ι), i ∈ t → is_preconnected (s i)) (K : ∀ (i : ι), i ∈ t → ∀ (j : ι), j ∈ t → relation.refl_trans_gen (λ (i j : ι), (s i ∩ s j).nonempty ∧ i ∈ t) i j) : is_preconnected (⋃ (n : ι) (H : n ∈ t), s n)
theorem smul_comm_class.symm (M : Type u_1) (N : Type u_2) (α : Type u_3) [has_scalar M α] [has_scalar N α] [smul_comm_class M N α] : smul_comm_class N M α
theorem bdd_above.continuous_convolution_right_of_integrable {𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G → E} {g : G → E'} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 F] (L : E →L[𝕜] E' →L[𝕜] F) [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ F] [complete_space F] [add_group G] [topological_space G] [topological_add_group G] [borel_space G] [topological_space.second_countable_topology G] (hbg : bdd_above (set.range (λ (x : G), ∥g x∥))) (hf : measure_theory.integrable f μ) (hg : continuous g) : continuous (convolution f g L μ)
theorem fixing_submonoid_Union (M : Type u_1) (α : Type u_2) [monoid M] [mul_action M α] {ι : Sort u_3} {s : ι → set α} : fixing_submonoid M (⋃ (i : ι), s i) = ⨅ (i : ι), fixing_submonoid M (s i)
theorem besicovitch.is_empty_satellite_config_multiplicity (E : Type u_1) [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] : is_empty (besicovitch.satellite_config E (besicovitch.multiplicity E) (besicovitch.good_τ E))
theorem formal_multilinear_series.comp_partial_sum_target_tendsto_at_top  : filter.tendsto (λ (N : ℕ), formal_multilinear_series.comp_partial_sum_target 0 N N) filter.at_top filter.at_top
theorem cont_diff_at_succ_iff_has_fderiv_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {x : E} {n : ℕ} : cont_diff_at 𝕜 ↑(n + 1) f x ↔ ∃ (f' : E → (E →L[𝕜] F)), (∃ (u : set E) (H : u ∈ nhds x), ∀ (x : E), x ∈ u → has_fderiv_at f (f' x) x) ∧ cont_diff_at 𝕜 ↑n f' x
theorem algebra.finite_type.of_finite_presentation {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_presentation R A → algebra.finite_type R A
theorem finset.weighted_vsub_of_point_eq_of_weights_eq {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (p : ι → P) (j : ι) (w₁ w₂ : ι → k) (hw : ∀ (i : ι), i ≠ j → w₁ i = w₂ i) : ⇑(s.weighted_vsub_of_point p (p j)) w₁ = ⇑(s.weighted_vsub_of_point p (p j)) w₂
theorem fin.coe_fin_lt {n : ℕ} {a b : fin n} : ↑a < ↑b ↔ a < b
theorem subgroup.closure_le {G : Type u_1} [group G] (K : subgroup G) {k : set G} : subgroup.closure k ≤ K ↔ k ⊆ ↑K
theorem zsmul_eq_zsmul_iff' {α : Type u_1} [linear_ordered_add_comm_group α] {n : ℤ} {a b : α} (hn : n ≠ 0) : n • a = n • b ↔ a = b
theorem padic_norm.div (p : ℕ) [hp : fact (nat.prime p)] (q r : ℚ) : padic_norm p (q / r) = padic_norm p q / padic_norm p r
theorem interval_integral.deriv_integral_of_tendsto_ae_left {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {c : E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (hb : filter.tendsto f (nhds a ⊓ measure_theory.measure_space.volume.ae) (nhds c)) : deriv (λ (u : ℝ), ∫ (x : ℝ) in u..b, f x) a = -c
theorem is_add_monoid_hom.is_add_monoid_hom_mul_right {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), y * x)
theorem is_localization.map_comp_map {R : Type u_1} [comm_semiring R] {M : submonoid R} {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] {g : R →+* P} {T : submonoid P} {Q : Type u_4} [comm_semiring Q] (hy : M ≤ submonoid.comap ↑g T) [algebra P Q] [is_localization T Q] {A : Type u_5} [comm_semiring A] {U : submonoid A} {W : Type u_6} [comm_semiring W] [algebra A W] [is_localization U W] {l : P →+* A} (hl : T ≤ submonoid.comap ↑l U) : (is_localization.map W l hl).comp (is_localization.map Q g hy) = is_localization.map W (l.comp g) _
theorem continuous_on.ae_strongly_measurable {α : Type u_1} {β : Type u_2} [measurable_space α] [topological_space α] [topological_space β] [h : second_countable_topology_either α β] [opens_measurable_space α] [topological_space.pseudo_metrizable_space β] {f : α → β} {s : set α} {μ : measure_theory.measure α} (hf : continuous_on f s) (hs : measurable_set s) : measure_theory.ae_strongly_measurable f (μ.restrict s)
theorem category_theory.grothendieck_topology.is_closed_pullback {C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) {X Y : C} (f : Y ⟶ X) (S : category_theory.sieve X) : J₁.is_closed S → J₁.is_closed (category_theory.sieve.pullback f S)
theorem linear_map.map_span_le {R : Type u_1} {R₂ : Type u_2} {M : Type u_4} {M₂ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring R₂] {σ₁₂ : R →+* R₂} [add_comm_monoid M₂] [module R₂ M₂] [ring_hom_surjective σ₁₂] (f : M →ₛₗ[σ₁₂] M₂) (s : set M) (N : submodule R₂ M₂) : submodule.map f (submodule.span R s) ≤ N ↔ ∀ (m : M), m ∈ s → ⇑f m ∈ N
theorem submonoid.closure_induction₂ {M : Type u_1} [mul_one_class M] {s : set M} {p : M → M → Prop} {x y : M} (hx : x ∈ submonoid.closure s) (hy : y ∈ submonoid.closure s) (Hs : ∀ (x : M), x ∈ s → ∀ (y : M), y ∈ s → p x y) (H1_left : ∀ (x : M), p 1 x) (H1_right : ∀ (x : M), p x 1) (Hmul_left : ∀ (x y z : M), p x z → p y z → p (x * y) z) (Hmul_right : ∀ (x y z : M), p z x → p z y → p z (x * y)) : p x y
theorem comp_smul_left (M : Type u_1) {α : Type u_6} [monoid M] [mul_action M α] (a₁ a₂ : M) : has_scalar.smul a₁ ∘ has_scalar.smul a₂ = has_scalar.smul (a₁ * a₂)
theorem subring.neg_mem {R : Type u} [ring R] (s : subring R) {x : R} : x ∈ s → -x ∈ s
theorem has_le.le.lt_or_eq {α : Type u} [partial_order α] {a b : α} : a ≤ b → a < b ∨ a = b
theorem unique_diff_on_Icc_zero_one  : unique_diff_on ℝ (set.Icc 0 1)
theorem strict_concave_on.inf {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [linear_ordered_add_comm_monoid β] [has_scalar 𝕜 E] [module 𝕜 β] [ordered_smul 𝕜 β] {s : set E} {f g : E → β} (hf : strict_concave_on 𝕜 s f) (hg : strict_concave_on 𝕜 s g) : strict_concave_on 𝕜 s (f ⊓ g)
theorem has_fpower_series_on_ball.tendsto_uniformly_on' {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] {f : E → F} {p : formal_multilinear_series 𝕜 E F} {x : E} {r : ennreal} {r' : nnreal} (hf : has_fpower_series_on_ball f p x r) (h : ↑r' < r) : tendsto_uniformly_on (λ (n : ℕ) (y : E), p.partial_sum n (y - x)) f filter.at_top (metric.ball x ↑r')
theorem linear_independent_le_infinite_basis {R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {ι : Type u_1} (b : basis ι R M) [infinite ι] {κ : Type u_1} (v : κ → M) (i : linear_independent R v) : cardinal.mk κ ≤ cardinal.mk ι
theorem exists_Ioo_extr_on_Icc (f : ℝ → ℝ) {a b : ℝ} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hfI : f a = f b) : ∃ (c : ℝ) (H : c ∈ set.Ioo a b), is_extr_on f (set.Icc a b) c
theorem has_fderiv_at_exp_of_mem_ball {𝕂 : Type u_1} {𝔸 : Type u_2} [nondiscrete_normed_field 𝕂] [normed_comm_ring 𝔸] [normed_algebra 𝕂 𝔸] [complete_space 𝔸] [char_zero 𝕂] {x : 𝔸} (hx : x ∈ emetric.ball 0 (exp_series 𝕂 𝔸).radius) : has_fderiv_at (exp 𝕂) (exp 𝕂 x • 1) x
theorem smul_add_smul_lt_smul_add_smul' {k : Type u_1} {M : Type u_2} [ordered_ring k] [ordered_add_comm_group M] [module k M] [ordered_smul k M] [covariant_class M M has_add.add has_lt.lt] [contravariant_class M M has_add.add has_lt.lt] {a b : k} {c d : M} (hba : b < a) (hdc : d < c) : a • d + b • c < a • c + b • d
theorem eckmann_hilton.mul_comm {X : Type u} {m₁ m₂ : X → X → X} {e₁ e₂ : X} (h₁ : eckmann_hilton.is_unital m₁ e₁) (h₂ : eckmann_hilton.is_unital m₂ e₂) (distrib : ∀ (a b c d : X), m₁ (m₂ a b) (m₂ c d) = m₂ (m₁ a c) (m₁ b d)) : is_commutative X m₂
theorem asymptotics.is_O_with.of_norm_left {α : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {c : ℝ} {g : α → F} {f' : α → E'} {l : filter α} : asymptotics.is_O_with c l (λ (x : α), ∥f' x∥) g → asymptotics.is_O_with c l f' g
theorem polynomial.induction_on' {R : Type u} [semiring R] {M : polynomial R → Prop} (p : polynomial R) (h_add : ∀ (p q : polynomial R), M p → M q → M (p + q)) (h_monomial : ∀ (n : ℕ) (a : R), M (⇑(polynomial.monomial n) a)) : M p
theorem real.has_strict_deriv_at_const_rpow_of_neg {a x : ℝ} (ha : a < 0) : has_strict_deriv_at (λ (x : ℝ), a ^ x) (a ^ x * real.log a - real.exp (real.log a * x) * real.sin (x * real.pi) * real.pi) x
theorem continuous_map.continuous_eval_const' {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α] (a : α) : continuous (λ (f : C(α, β)), ⇑f a)
theorem countable_of_isolated_left {α : Type u} [topological_space α] [linear_order α] [order_topology α] [topological_space.second_countable_topology α] : {x : α | ∃ (y : α), y < x ∧ set.Ioo y x = ∅}.countable
theorem range_circle_map (c : ℂ) (R : ℝ) : set.range (circle_map c R) = metric.sphere c |R|
theorem multilinear_map.map_add_univ {R : Type u} {ι : Type u'} {M₁ : ι → Type v₁} {M₂ : Type v₂} [decidable_eq ι] [semiring R] [Π (i : ι), add_comm_monoid (M₁ i)] [add_comm_monoid M₂] [Π (i : ι), module R (M₁ i)] [module R M₂] (f : multilinear_map R M₁ M₂) [fintype ι] (m m' : Π (i : ι), M₁ i) : ⇑f (m + m') = finset.univ.sum (λ (s : finset ι), ⇑f (s.piecewise m m'))
theorem interval_integral.integral_eq_sub_of_has_deriv_right_of_le {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} {f' : ℝ → E} (hab : a ≤ b) (hcont : continuous_on f (set.Icc a b)) (hderiv : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_within_at f (f' x) (set.Ioi x) x) (f'int : interval_integrable f' measure_theory.measure_space.volume a b) : ∫ (y : ℝ) in a..b, f' y = f b - f a
theorem measure_theory.measure.is_haar_measure_of_is_compact_nonempty_interior {G : Type u_1} [measurable_space G] [group G] [topological_space G] [topological_group G] [borel_space G] (μ : measure_theory.measure G) [μ.is_mul_left_invariant] (K : set G) (hK : is_compact K) (h'K : (interior K).nonempty) (h : ⇑μ K ≠ 0) (h' : ⇑μ K ≠ ⊤) : μ.is_haar_measure
theorem tsum_Union_decode₂ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [add_comm_monoid α] [topological_space α] [t2_space α] [encodable γ] (m : set β → α) (m0 : m ∅ = 0) (s : γ → set β) : ∑' (i : ℕ), m (⋃ (b : γ) (H : b ∈ encodable.decode₂ γ i), s b) = ∑' (b : γ), m (s b)
theorem finite_dimensional.of_injective {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {V₂ : Type v'} [add_comm_group V₂] [module K V₂] (f : V →ₗ[K] V₂) (w : function.injective ⇑f) [finite_dimensional K V₂] : finite_dimensional K V
theorem finsum_mem_Union {α : Type u_1} {ι : Type u_3} {M : Type u_5} [add_comm_monoid M] {f : α → M} [fintype ι] {t : ι → set α} (h : pairwise (disjoint on t)) (ht : ∀ (i : ι), (t i).finite) : finsum (λ (a : α), finsum (λ (H : a ∈ ⋃ (i : ι), t i), f a)) = finsum (λ (i : ι), finsum (λ (a : α), finsum (λ (H : a ∈ t i), f a)))
theorem concave_on_of_slope_anti_adjacent {𝕜 : Type u_1} [linear_ordered_field 𝕜] {s : set 𝕜} {f : 𝕜 → 𝕜} (hs : convex 𝕜 s) (hf : ∀ {x y z : 𝕜}, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) ≤ (f y - f x) / (y - x)) : concave_on 𝕜 s f
theorem measurable_set.nhds_within_is_measurably_generated {α : Type u_1} [topological_space α] [measurable_space α] [opens_measurable_space α] {s : set α} (hs : measurable_set s) (a : α) : (nhds_within a s).is_measurably_generated
theorem equiv.add_left_symm_apply {G : Type u_10} [add_group G] (a : G) : ⇑(equiv.symm (equiv.add_left a)) = has_add.add (-a)
theorem category_theory.limits.mono_of_is_limit_parallel_family {J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J → (X ⟶ Y)} [nonempty J] {c : category_theory.limits.cone (category_theory.limits.parallel_family f)} (i : category_theory.limits.is_limit c) : category_theory.mono (category_theory.limits.trident.ι c)
theorem direct_sum.of_smul (R : Type u) [semiring R] {ι : Type v} [dec_ι : decidable_eq ι] {M : ι → Type w} [Π (i : ι), add_comm_monoid (M i)] [Π (i : ι), module R (M i)] (i : ι) (c : R) (x : M i) : ⇑(direct_sum.of M i) (c • x) = c • ⇑(direct_sum.of M i) x
theorem multilinear_map.continuous_of_bound {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : multilinear_map 𝕜 E G) (C : ℝ) (H : ∀ (m : Π (i : ι), E i), ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : ι), ∥m i∥)) : continuous ⇑f
theorem category_theory.is_iso_of_fully_faithful {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) [category_theory.full F] [category_theory.faithful F] {X Y : C} (f : X ⟶ Y) [category_theory.is_iso (F.map f)] : category_theory.is_iso f
theorem measure_theory.integral_eq_of_has_deriv_within_at_off_countable {E : Type u} [normed_group E] [normed_space ℝ E] [complete_space E] (f f' : ℝ → E) {a b : ℝ} {s : set ℝ} (hs : s.countable) (Hc : continuous_on f (set.interval a b)) (Hd : ∀ (x : ℝ), x ∈ set.Ioo (linear_order.min a b) (linear_order.max a b)  s → has_deriv_at f (f' x) x) (Hi : interval_integrable f' measure_theory.measure_space.volume a b) : ∫ (x : ℝ) in a..b, f' x = f b - f a
theorem list.join_split_wrt_composition {α : Type u_1} (l : list α) (c : composition l.length) : (l.split_wrt_composition c).join = l
theorem convex_on_univ_of_deriv2_nonneg {f : ℝ → ℝ} (hf' : differentiable ℝ f) (hf'' : differentiable ℝ (deriv f)) (hf''_nonneg : ∀ (x : ℝ), 0 ≤ deriv^[2] f x) : convex_on ℝ set.univ f
theorem continuous_on.comp_fract'' {α : Type u_1} {β : Type u_2} [linear_ordered_ring α] [floor_ring α] [topological_space α] [order_topology α] [topological_add_group α] [topological_space β] {f : α → β} (h : continuous_on f (set.Icc 0 1)) (hf : f 0 = f 1) : continuous (f ∘ int.fract)
theorem strict_convex_on_of_deriv2_pos {D : set ℝ} (hD : convex ℝ D) {f : ℝ → ℝ} (hf : continuous_on f D) (hf' : differentiable_on ℝ f (interior D)) (hf'' : ∀ (x : ℝ), x ∈ interior D → 0 < deriv^[2] f x) : strict_convex_on ℝ D f
theorem order.lt_of_pred_lt_pred {α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α] : order.pred a < order.pred b → a < b
theorem mul_dvd_mul_iff_left {α : Type u_1} [cancel_monoid_with_zero α] {a b c : α} (ha : a ≠ 0) : a * b ∣ a * c ↔ b ∣ c
theorem minpoly.eq_of_algebra_map_eq {K : Type u_1} {S : Type u_2} {T : Type u_3} [field K] [comm_ring S] [comm_ring T] [algebra K S] [algebra K T] [algebra S T] [is_scalar_tower K S T] (hST : function.injective ⇑(algebra_map S T)) {x : S} {y : T} (hx : is_integral K x) (h : y = ⇑(algebra_map S T) x) : minpoly K x = minpoly K y
theorem vadd_comm_class.symm (M : Type u_1) (N : Type u_2) (α : Type u_3) [has_vadd M α] [has_vadd N α] [vadd_comm_class M N α] : vadd_comm_class N M α
theorem pi.nontrivial_at {I : Type u_3} {f : I → Type u_4} (i' : I) [inst : ∀ (i : I), nonempty (f i)] [nontrivial (f i')] : nontrivial (Π (i : I), f i)
theorem direct_sum.coe_to_module_eq_coe_to_add_monoid (R : Type u) [semiring R] (ι : Type v) [dec_ι : decidable_eq ι] {M : ι → Type w} [Π (i : ι), add_comm_monoid (M i)] [Π (i : ι), module R (M i)] (N : Type u₁) [add_comm_monoid N] [module R N] (φ : Π (i : ι), M i →ₗ[R] N) : ⇑(direct_sum.to_module R ι N φ) = ⇑(direct_sum.to_add_monoid (λ (i : ι), (φ i).to_add_monoid_hom))
theorem homeomorph.is_O_with_congr {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {E : Type u_3} [has_norm E] {F : Type u_4} [has_norm F] (e : α ≃ₜ β) {b : β} {f : β → E} {g : β → F} {C : ℝ} : asymptotics.is_O_with C (nhds b) f g ↔ asymptotics.is_O_with C (nhds (⇑(e.symm) b)) (f ∘ ⇑e) (g ∘ ⇑e)
theorem field.exists_primitive_element (F : Type u_1) (E : Type u_2) [field F] [field E] [algebra F E] [finite_dimensional F E] [is_separable F E] : ∃ (α : E), F⟮α⟯ = ⊤
theorem linear_ordered_comm_group_with_zero.nhds_coe_units {Γ₀ : Type u_1} [linear_ordered_comm_group_with_zero Γ₀] (γ : Γ₀ˣ) : nhds ↑γ = has_pure.pure ↑γ
theorem finset.property_of_mem_map_subtype {α : Type u_1} {p : α → Prop} (s : finset {x // p x}) {a : α} (h : a ∈ finset.map (function.embedding.subtype (λ (x : α), p x)) s) : p a
theorem category_theory.functor.ext {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {F G : C ⥤ D} (h_obj : ∀ (X : C), F.obj X = G.obj X) (h_map : ∀ (X Y : C) (f : X ⟶ Y), F.map f = category_theory.eq_to_hom _ ≫ G.map f ≫ category_theory.eq_to_hom _) : F = G
theorem set.maps_to.closure {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {s : set α} {t : set β} {f : α → β} (h : set.maps_to f s t) (hc : continuous f) : set.maps_to f (closure s) (closure t)
theorem normed_space.to_locally_convex_space' (𝕜 : Type u_1) {E : Type u_2} [normed_field 𝕜] [normed_space ℝ 𝕜] [semi_normed_group E] [normed_space 𝕜 E] [module ℝ E] [is_scalar_tower ℝ 𝕜 E] : locally_convex_space ℝ E
theorem exists_lt_subset_ball {α : Type u} [pseudo_metric_space α] [proper_space α] {x : α} {r : ℝ} {s : set α} (hs : is_closed s) (h : s ⊆ metric.ball x r) : ∃ (r' : ℝ) (H : r' < r), s ⊆ metric.ball x r'
theorem continuous_map.homotopy.continuous {X : Type u} {Y : Type v} [topological_space X] [topological_space Y] {f₀ f₁ : C(X, Y)} (F : f₀.homotopy f₁) : continuous ⇑F
theorem exists_subset_nhd_of_compact' {α : Type u} [topological_space α] {ι : Type u_1} [nonempty ι] {V : ι → set α} (hV : directed superset V) (hV_cpct : ∀ (i : ι), is_compact (V i)) (hV_closed : ∀ (i : ι), is_closed (V i)) {U : set α} (hU : ∀ (x : α), (x ∈ ⋂ (i : ι), V i) → U ∈ nhds x) : ∃ (i : ι), V i ⊆ U
theorem topological_space.metrizable_space_of_regular_second_countable (X : Type u_2) [topological_space X] [regular_space X] [topological_space.second_countable_topology X] : topological_space.metrizable_space X
theorem is_dedekind_domain.height_one_spectrum.int_valuation.map_add_le_max' {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x y : R) : v.int_valuation_def (x + y) ≤ linear_order.max (v.int_valuation_def x) (v.int_valuation_def y)
theorem subsemigroup.ext {M : Type u_1} [has_mul M] {S T : subsemigroup M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T) : S = T
theorem set.pairwise_disjoint.countable_of_is_open {α : Type u} [t : topological_space α] [topological_space.separable_space α] {ι : Type u_1} {s : ι → set α} {a : set ι} (h : a.pairwise_disjoint s) (ha : ∀ (i : ι), i ∈ a → is_open (s i)) (h'a : ∀ (i : ι), i ∈ a → (s i).nonempty) : a.countable
theorem category_theory.is_pullback.of_has_pullback {C : Type u₁} [category_theory.category C] {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) [category_theory.limits.has_pullback f g] : category_theory.is_pullback category_theory.limits.pullback.fst category_theory.limits.pullback.snd f g
theorem function.is_periodic_pt.eq_of_apply_eq {α : Type u_1} {f : α → α} {x y : α} {m n : ℕ} (hx : function.is_periodic_pt f m x) (hy : function.is_periodic_pt f n y) (hm : 0 < m) (hn : 0 < n) (h : f x = f y) : x = y
theorem is_unit.dvd_mul_left {α : Type u_1} [comm_monoid α] (a b u : α) (hu : is_unit u) : a ∣ u * b ↔ a ∣ b
theorem add_semiconj_by.add_units_neg_symm_left {M : Type u} [add_monoid M] {a : add_units M} {x y : M} (h : add_semiconj_by ↑a x y) : add_semiconj_by (↑-a) y x
theorem zero_lt.preorder.left.one_le_mul_of_le_of_le {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (a0 : 0 < a) : 1 ≤ a * b
theorem is_cyclotomic_extension.discr_prime_pow_ne_two' {p : ℕ+} {k : ℕ} {K : Type u} {L : Type v} {ζ : L} [field K] [field L] [algebra K L] [is_cyclotomic_extension {p ^ (k + 1)} K L] [hp : fact (nat.prime ↑p)] [ne_zero ↑↑p] (hζ : is_primitive_root ζ ↑(p ^ (k + 1))) (hirr : irreducible (polynomial.cyclotomic ↑(p ^ (k + 1)) K)) (hk : p ^ (k + 1) ≠ 2) : algebra.discr K ⇑((is_primitive_root.power_basis K hζ).basis) = (-1) ^ (↑p ^ k * (↑p - 1) / 2) * ↑p ^ (↑p ^ k * ((↑p - 1) * (k + 1) - 1))
theorem generalized_continued_fraction.int_fract_pair.succ_nth_stream_b_le_nth_stream_fr_inv {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n ifp_succ_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) (succ_nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n) : ↑(ifp_succ_n.b) ≤ (ifp_n.fr)⁻¹
theorem padic_val_rat.of_int_multiplicity {p : ℕ} (z : ℤ) (hp : p ≠ 1) (hz : z ≠ 0) : padic_val_rat p ↑z = ↑((multiplicity ↑p z).get _)
theorem relation.game_add_le_lex {α : Type u_1} {β : Type u_2} (rα : α → α → Prop) (rβ : β → β → Prop) : relation.game_add rα rβ ≤ prod.lex rα rβ
theorem dense.inter_of_open_left {α : Type u} [topological_space α] {s t : set α} (hs : dense s) (ht : dense t) (hso : is_open s) : dense (s ∩ t)
theorem image_norm_le_of_norm_deriv_right_le_deriv_boundary' {E : Type u_1} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} {f' : ℝ → E} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : ℝ → ℝ} (ha : ∥f a∥ ≤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at B (B' x) (set.Ici x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → ∥f' x∥ ≤ B' x) ⦃x : ℝ⦄ : x ∈ set.Icc a b → ∥f x∥ ≤ B x
theorem affine.triangle.orthocenter_eq_of_range_eq {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {t₁ t₂ : affine.triangle ℝ P} (h : set.range t₁.points = set.range t₂.points) : t₁.orthocenter = t₂.orthocenter
theorem orthonormal.oangle_eq_of_orientation_eq {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {b₂ : basis (fin 2) ℝ V} (hb₂ : orthonormal ℝ ⇑b₂) (ho : b.orientation = b₂.orientation) (x y : V) : hb.oangle x y = hb₂.oangle x y
theorem is_smul_regular.pow_iff {R : Type u_1} {M : Type u_3} {a : R} [monoid R] [mul_action R M] {n : ℕ} (n0 : 0 < n) : is_smul_regular M (a ^ n) ↔ is_smul_regular M a
theorem dist_le_of_le_geometric_of_tendsto {α : Type u_1} [pseudo_metric_space α] (r C : ℝ) (hr : r < 1) {f : ℕ → α} (hu : ∀ (n : ℕ), has_dist.dist (f n) (f (n + 1)) ≤ C * r ^ n) {a : α} (ha : filter.tendsto f filter.at_top (nhds a)) (n : ℕ) : has_dist.dist (f n) a ≤ C * r ^ n / (1 - r)
theorem polynomial.sum_taylor_eq {R : Type u_1} [comm_ring R] (f : polynomial R) (r : R) : (⇑(polynomial.taylor r) f).sum (λ (i : ℕ) (a : R), ⇑polynomial.C a * (polynomial.X - ⇑polynomial.C r) ^ i) = f
theorem measure_theory.forall_measure_preimage_add_iff {G : Type u_1} [measurable_space G] [has_add G] [has_measurable_add G] (μ : measure_theory.measure G) : (∀ (g : G) (A : set G), measurable_set A → ⇑μ ((λ (h : G), g + h) ⁻¹' A) = ⇑μ A) ↔ μ.is_add_left_invariant
theorem cont_mdiff_on.cont_mdiff_on_tangent_map_within_aux {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {m n : with_top ℕ} {f : H → H'} {s : set H} (hf : cont_mdiff_on I I' n f s) (hmn : m + 1 ≤ n) (hs : unique_mdiff_on I s) : cont_mdiff_on I.tangent I'.tangent m (tangent_map_within I I' f s) (tangent_bundle.proj I H ⁻¹' s)
theorem supr_eq_supr_finset' {α : Type u_1} {ι' : Sort u_5} [complete_lattice α] (s : ι' → α) : (⨆ (i : ι'), s i) = ⨆ (t : finset (plift ι')) (i : plift ι') (H : i ∈ t), s i.down
theorem set.pairwise_disjoint.countable_of_Ioo {α : Type u} [topological_space α] [linear_order α] [order_topology α] [topological_space.second_countable_topology α] {y : α → α} {s : set α} (h : s.pairwise_disjoint (λ (x : α), set.Ioo x (y x))) (h' : ∀ (x : α), x ∈ s → x < y x) : s.countable
theorem intermediate_value_Icc' {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {δ : Type u_1} [linear_order δ] [topological_space δ] [order_closed_topology δ] {a b : α} (hab : a ≤ b) {f : α → δ} (hf : continuous_on f (set.Icc a b)) : set.Icc (f b) (f a) ⊆ f '' set.Icc a b
theorem ennreal.tendsto_nhds {α : Type u_1} {f : filter α} {u : α → ennreal} {a : ennreal} (ha : a ≠ ⊤) : filter.tendsto u f (nhds a) ↔ ∀ (ε : ennreal), ε > 0 → (∀ᶠ (x : α) in f, u x ∈ set.Icc (a - ε) (a + ε))
theorem strict_concave_on.neg {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [ordered_add_comm_group β] [has_scalar 𝕜 E] [module 𝕜 β] {s : set E} {f : E → β} : strict_concave_on 𝕜 s f → strict_convex_on 𝕜 s (-f)
theorem dimH_image_le_of_locally_lipschitz_on {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [topological_space.second_countable_topology X] {f : X → Y} {s : set X} (hf : ∀ (x : X), x ∈ s → (∃ (C : nnreal) (t : set X) (H : t ∈ nhds_within x s), lipschitz_on_with C f t)) : dimH (f '' s) ≤ dimH s
theorem metric.isometry_inr {X : Type u} {Y : Type v} [metric_space X] [metric_space Y] : isometry sum.inr
theorem measurable_update {δ : Type u_4} {π : δ → Type u_7} [Π (a : δ), measurable_space (π a)] (f : Π (a : δ), π a) {a : δ} [decidable_eq δ] : measurable (function.update f a)
theorem add_semiconj_by.zero_right {M : Type u} [add_zero_class M] (a : M) : add_semiconj_by a 0 0
theorem composition_series.ext_fun {X : Type u} [lattice X] [jordan_holder_lattice X] {s₁ s₂ : composition_series X} (hl : s₁.length = s₂.length) (h : ∀ (i : fin (s₁.length + 1)), ⇑s₁ i = ⇑s₂ (⇑(fin.cast _) i)) : s₁ = s₂
theorem category_theory.iso.faithful_of_comp {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {E : Type u₃} [category_theory.category E] {F : C ⥤ D} {G : D ⥤ E} {H : C ⥤ E} [ℋ : category_theory.faithful H] (h : F ⋙ G ≅ H) : category_theory.faithful F
theorem measure_theory.measure.finite_at_filter.integrable_at_filter {α : Type u_1} {E : Type u_3} [measurable_space α] [normed_group E] {f : α → E} {μ : measure_theory.measure α} {l : filter α} [l.is_measurably_generated] (hfm : strongly_measurable_at_filter f l μ) (hμ : μ.finite_at_filter l) (hf : filter.is_bounded_under has_le.le l (has_norm.norm ∘ f)) : measure_theory.integrable_at_filter f l μ
theorem eq_orthogonal_projection_of_mem_of_inner_eq_zero {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K : submodule 𝕜 E} [complete_space ↥K] {u v : E} (hvm : v ∈ K) (hvo : ∀ (w : E), w ∈ K → has_inner.inner (u - v) w = 0) : ↑(⇑(orthogonal_projection K) u) = v
theorem local_homeomorph.ext {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e e' : local_homeomorph α β) (h : ∀ (x : α), ⇑e x = ⇑e' x) (hinv : ∀ (x : β), ⇑(e.symm) x = ⇑(e'.symm) x) (hs : e.to_local_equiv.source = e'.to_local_equiv.source) : e = e'
theorem generalized_continued_fraction.sub_convergents_eq {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp : generalized_continued_fraction.int_fract_pair K} (stream_nth_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp) : let g : generalized_continued_fraction K := generalized_continued_fraction.of v, B : K := (g.continuants_aux (n + 1)).b, pB : K := (g.continuants_aux n).b in v - g.convergents n = ite (ifp.fr = 0) 0 ((-1) ^ n / (B * ((ifp.fr)⁻¹ * B + pB)))
theorem box_integral.has_integral.congr_ae {ι : Type u} {E : Type v} [fintype ι] [normed_group E] [normed_space ℝ E] {l : box_integral.integration_params} {I : box_integral.box ι} {y : E} {f g : (ι → ℝ) → E} {μ : measure_theory.measure (ι → ℝ)} [measure_theory.is_locally_finite_measure μ] (hf : box_integral.has_integral I l f μ.to_box_additive.to_smul y) (hfg : f =ᵐ[μ.restrict ↑I] g) (hl : l.bRiemann = bool.ff) : box_integral.has_integral I l g μ.to_box_additive.to_smul y
theorem module.projective_of_basis {R : Type u} [ring R] {P : Type (max u v)} [add_comm_group P] [module R P] {ι : Type u_1} (b : basis ι R P) : module.projective R P
theorem iterated_deriv_succ' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {n : ℕ} {f : 𝕜 → F} : iterated_deriv (n + 1) f = iterated_deriv n (deriv f)
theorem colex.sum_two_pow_le_iff_lt (A B : finset ℕ) : A.sum (λ (i : ℕ), 2 ^ i) ≤ B.sum (λ (i : ℕ), 2 ^ i) ↔ A.to_colex ≤ B.to_colex
theorem zero_lt.left.one_le_mul_of_le_of_le {α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (a0 : 0 ≤ a) : 1 ≤ a * b
theorem real.lt_tan (x : ℝ) (h1 : 0 < x) (h2 : x < real.pi / 2) : x < real.tan x
theorem right.add_nonneg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a + b
theorem sylow.exists_subgroup_card_pow_succ {G : Type u} [group G] [fintype G] {p n : ℕ} [hp : fact (nat.prime p)] (hdvd : p ^ (n + 1) ∣ fintype.card G) {H : subgroup G} (hH : fintype.card ↥H = p ^ n) : ∃ (K : subgroup G), fintype.card ↥K = p ^ (n + 1) ∧ H ≤ K
theorem box_integral.integrable.tendsto_integral_sum_sum_integral {ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} [complete_space F] (h : box_integral.integrable I l f vol) (π₀ : box_integral.prepartition I) : filter.tendsto (box_integral.integral_sum f vol) (l.to_filter_Union I π₀) (nhds (π₀.boxes.sum (λ (J : box_integral.box ι), box_integral.integral J l f vol)))
theorem tensor_algebra.hom_ext {R : Type u_1} [comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {A : Type u_3} [semiring A] [algebra R A] {f g : tensor_algebra R M →ₐ[R] A} (w : f.to_linear_map.comp (tensor_algebra.ι R) = g.to_linear_map.comp (tensor_algebra.ι R)) : f = g
theorem order_ring_iso.subsingleton_left {α : Type u_2} {β : Type u_3} [linear_ordered_field α] [archimedean α] [linear_ordered_field β] : subsingleton (α ≃+*o β)
theorem is_localization.is_localization_of_submonoid_le {R : Type u_1} [comm_ring R] (S : Type u_2) [comm_ring S] [algebra R S] (T : Type u_4) [comm_ring T] [algebra R T] (M N : submonoid R) (h : M ≤ N) [is_localization M S] [is_localization N T] [algebra S T] [is_scalar_tower R S T] : is_localization (submonoid.map (algebra_map R S).to_monoid_hom N) T
theorem polish_space.exists_polish_space_forall_le {α : Type u_1} {ι : Type u_2} [encodable ι] [t : topological_space α] [p : polish_space α] (m : ι → topological_space α) (hm : ∀ (n : ι), m n ≤ t) (h'm : ∀ (n : ι), polish_space α) : ∃ (t' : topological_space α), (∀ (n : ι), t' ≤ m n) ∧ t' ≤ t ∧ polish_space α
theorem submonoid.localization_map.lift_mul_left {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M →* P} (hg : ∀ (y : ↥S), is_unit (⇑g ↑y)) (z : N) : ⇑g ↑((f.sec z).snd) * ⇑(f.lift hg) z = ⇑g (f.sec z).fst
theorem con.con_gen_eq {M : Type u_1} [has_mul M] (r : M → M → Prop) : con_gen r = has_Inf.Inf {s : con M | ∀ (x y : M), r x y → ⇑s x y}
theorem linear_map.concave_on {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [ordered_add_comm_monoid β] [module 𝕜 E] [module 𝕜 β] (f : E →ₗ[𝕜] β) {s : set E} (hs : convex 𝕜 s) : concave_on 𝕜 s ⇑f
theorem continuous_linear_equiv.ext₁ {R₁ : Type u_1} [semiring R₁] {M₁ : Type u_4} [topological_space M₁] [add_comm_monoid M₁] [module R₁ M₁] [topological_space R₁] {f g : R₁ ≃L[R₁] M₁} (h : ⇑f 1 = ⇑g 1) : f = g
theorem module.equiv_free_prod_direct_sum {R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {N : Type (max u v)} [add_comm_group N] [module R N] [h' : module.finite R N] : ∃ (n : ℕ) (ι : Type u) [_inst_8 : fintype ι] (p : ι → R) [_inst_9 : ∀ (i : ι), irreducible (p i)] (e : ι → ℕ), nonempty (N ≃ₗ[R] (fin n →₀ R) × direct_sum ι (λ (i : ι), R ⧸ submodule.span R {p i ^ e i}))
theorem is_local_extr.has_fderiv_at_eq_zero {E : Type u} [normed_group E] [normed_space ℝ E] {f : E → ℝ} {a : E} {f' : E →L[ℝ] ℝ} (h : is_local_extr f a) : has_fderiv_at f f' a → f' = 0
theorem mul_hom.congr_fun {M : Type u_3} {N : Type u_4} [has_mul M] [has_mul N] {f g : M →ₙ* N} (h : f = g) (x : M) : ⇑f x = ⇑g x
theorem algebraic_geometry.RingedSpace.is_unit_res_basic_open (X : algebraic_geometry.RingedSpace) {U : topological_space.opens ↥X} (f : ↥(X.to_PresheafedSpace.presheaf.obj (opposite.op U))) : is_unit (⇑(X.to_PresheafedSpace.presheaf.map (category_theory.hom_of_le _).op) f)
theorem norm_torus_integral_le_of_norm_le_const {n : ℕ} {E : Type u_1} [normed_group E] [normed_space ℂ E] [complete_space E] {f : (fin n → ℂ) → E} {c : fin n → ℂ} {R : fin n → ℝ} {C : ℝ} (hf : ∀ (θ : fin n → ℝ), ∥f (torus_map c R θ)∥ ≤ C) : ∥∯ (x : fin n → ℂ) in T(c, R), f x∥ ≤ (2 * real.pi) ^ n * finset.univ.prod (λ (i : fin n), |R i|) * C
theorem ennreal.infi_mul {ι : Sort u_1} [nonempty ι] {f : ι → ennreal} {x : ennreal} (h : x ≠ ⊤) : infi f * x = ⨅ (i : ι), f i * x
theorem orthonormal.comp_linear_isometry_equiv {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {E' : Type u_7} [inner_product_space 𝕜 E'] {v : ι → E} (hv : orthonormal 𝕜 v) (f : E ≃ₗᵢ[𝕜] E') : orthonormal 𝕜 (⇑f ∘ v)
theorem cardinal.aleph_0_le_mul_iff' {a b : cardinal} : cardinal.aleph_0 ≤ a * b ↔ a ≠ 0 ∧ cardinal.aleph_0 ≤ b ∨ cardinal.aleph_0 ≤ a ∧ b ≠ 0
theorem submonoid.one_mem {M : Type u_1} [mul_one_class M] (S : submonoid M) : 1 ∈ S
theorem dim_eq_card_basis {R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {ι : Type w} [fintype ι] (h : basis ι R M) : module.rank R M = ↑(fintype.card ι)
theorem tactic.ring2.correctness {α : Type u_1} [comm_semiring α] (t : tree α) (r₁ r₂ : tactic.ring2.csring_expr) (H : tactic.ring2.horner_expr.of_csexpr r₁ = tactic.ring2.horner_expr.of_csexpr r₂) : tactic.ring2.csring_expr.eval t r₁ = tactic.ring2.csring_expr.eval t r₂
theorem smul_neg_of_neg_of_pos {k : Type u_1} {M : Type u_2} [ordered_ring k] [ordered_add_comm_group M] [module k M] [ordered_smul k M] {a : M} {c : k} (hc : c < 0) : 0 < a → c • a < 0
theorem probability_theory.lintegral_mul_eq_lintegral_mul_lintegral_of_indep_fun {α : Type u_1} {mα : measurable_space α} {μ : measure_theory.measure α} {f g : α → ennreal} (h_meas_f : measurable f) (h_meas_g : measurable g) (h_indep_fun : probability_theory.indep_fun f g μ) : ∫⁻ (a : α), (f * g) a ∂μ = ∫⁻ (a : α), f a ∂μ * ∫⁻ (a : α), g a ∂μ
theorem orthonormal.oangle_add_oangle_rev {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x y : V) : hb.oangle x y + hb.oangle y x = 0
theorem exists_integral_multiples (A : Type u_2) (K : Type u_3) [comm_ring A] [field K] [is_domain A] [algebra A K] [is_fraction_ring A K] {L : Type u_4} [field L] [algebra K L] [finite_dimensional K L] [algebra A L] [is_scalar_tower A K L] (s : finset L) : ∃ (y : A) (H : y ≠ 0), ∀ (x : L), x ∈ s → is_integral A (y • x)
theorem local_homeomorph.eq_on_source.symm_eq_on_target {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {e e' : local_homeomorph α β} (h : e ≈ e') : set.eq_on ⇑(e.symm) ⇑(e'.symm) e.to_local_equiv.target
theorem metric.forall_of_forall_mem_closed_ball {α : Type u} [pseudo_metric_space α] (p : α → Prop) (x : α) (H : ∃ᶠ (R : ℝ) in filter.at_top, ∀ (y : α), y ∈ metric.closed_ball x R → p y) (y : α) : p y
theorem category_theory.preadditive.has_cokernel_of_has_coequalizer {C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} (f g : X ⟶ Y) [category_theory.limits.has_coequalizer f g] : category_theory.limits.has_cokernel (f - g)
theorem irrational_nrt_of_n_not_dvd_multiplicity {x : ℝ} (n : ℕ) {m : ℤ} (hm : m ≠ 0) (p : ℕ) [hp : fact (nat.prime p)] (hxr : x ^ n = ↑m) (hv : (multiplicity ↑p m).get _ % n ≠ 0) : irrational x
theorem smul_add_smul_le_smul_add_smul {k : Type u_1} {M : Type u_2} [ordered_ring k] [ordered_add_comm_group M] [module k M] [ordered_smul k M] [contravariant_class M M has_add.add has_le.le] {a b : k} {c d : M} (hab : a ≤ b) (hcd : c ≤ d) : a • d + b • c ≤ a • c + b • d
theorem discrete_valuation_ring.of_has_unit_mul_pow_irreducible_factorization {R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) : discrete_valuation_ring R
theorem exists_hilbert_basis (𝕜 : Type u_2) [is_R_or_C 𝕜] (E : Type u_3) [inner_product_space 𝕜 E] [cplt : complete_space E] : ∃ (w : set E) (b : hilbert_basis ↥w 𝕜 E), ⇑b = coe
theorem cont_diff_within_at_snd {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : with_top ℕ} {s : set (E × F)} {p : E × F} : cont_diff_within_at 𝕜 n prod.snd s p
theorem orthonormal.comp {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {ι' : Type u_3} {v : ι → E} (hv : orthonormal 𝕜 v) (f : ι' → ι) (hf : function.injective f) : orthonormal 𝕜 (v ∘ f)
theorem ideal.eq_jacobson_iff_Inf_maximal {R : Type u} [ring R] {I : ideal R} : I.jacobson = I ↔ ∃ (M : set (ideal R)), (∀ (J : ideal R), J ∈ M → J.is_maximal ∨ J = ⊤) ∧ I = has_Inf.Inf M
theorem lie_module.infi_max_gen_zero_eigenspace_eq_top_of_nilpotent (R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [lie_module.is_nilpotent R L M] : (⨅ (x : L), (⇑(lie_module.to_endomorphism R L M) x).maximal_generalized_eigenspace 0) = ⊤
theorem ring.two_ne_zero {R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2) : 2 ≠ 0
theorem is_primitive_root.sub_one_norm_prime_ne_two {p : ℕ+} {K : Type u} {L : Type v} [field L] {ζ : L} [field K] [algebra K L] [ne_zero ↑↑p] {k : ℕ} (hζ : is_primitive_root ζ ↑(p ^ (k + 1))) [hpri : fact (nat.prime ↑p)] [is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic ↑(p ^ (k + 1)) K)) (h : p ≠ 2) : ⇑(algebra.norm K) (ζ - 1) = ↑p
theorem continuous_multilinear_map.le_op_nnnorm {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : continuous_multilinear_map 𝕜 E G) (m : Π (i : ι), E i) : ∥⇑f m∥₊ ≤ ∥f∥₊ * finset.univ.prod (λ (i : ι), ∥m i∥₊)
theorem linear_map.finrank_range_add_finrank_ker {K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] {V₂ : Type v'} [add_comm_group V₂] [module K V₂] [finite_dimensional K V] (f : V →ₗ[K] V₂) : finite_dimensional.finrank K ↥(f.range) + finite_dimensional.finrank K ↥(f.ker) = finite_dimensional.finrank K V
theorem finsum_induction {M : Type u_2} {α : Sort u_4} [add_comm_monoid M] {f : α → M} (p : M → Prop) (hp₀ : p 0) (hp₁ : ∀ (x y : M), p x → p y → p (x + y)) (hp₂ : ∀ (i : α), p (f i)) : p (finsum (λ (i : α), f i))
theorem dense_Inter_of_open_nat {α : Type u_1} [topological_space α] [baire_space α] {f : ℕ → set α} (ho : ∀ (n : ℕ), is_open (f n)) (hd : ∀ (n : ℕ), dense (f n)) : dense (⋂ (n : ℕ), f n)
theorem measure_theory.measure.ext_of_Union_eq_univ {α : Type u_1} {ι : Type u_5} {m0 : measurable_space α} {μ ν : measure_theory.measure α} [encodable ι] {s : ι → set α} (hs : (⋃ (i : ι), s i) = set.univ) : (∀ (i : ι), μ.restrict (s i) = ν.restrict (s i)) → μ = ν
theorem filter.map_const_principal_coprod_map_id_principal {α : Type u_1} {β : Type u_2} {ι : Type u_3} (a : α) (b : β) (i : ι) : (filter.map (λ (_x : α), b) (filter.principal {a})).coprod (filter.map id (filter.principal {i})) = filter.principal ({b} ×ˢ set.univ ∪ set.univ ×ˢ {i})
theorem fractional_ideal.coe_ideal_mul_inv {A : Type u_2} {K : Type u_3} [comm_ring A] [field K] [is_domain A] [algebra A K] [is_fraction_ring A K] [h : is_dedekind_domain A] (I : ideal A) (hI0 : I ≠ ⊥) : ↑I * (↑I)⁻¹ = 1
theorem orthonormal.rotation_trans {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (θ₁ θ₂ : real.angle) : (hb.rotation θ₁).trans (hb.rotation θ₂) = hb.rotation (θ₂ + θ₁)
theorem unitization.linear_map_ext {S : Type u_2} {R : Type u_3} {A : Type u_4} {N : Type u_1} [semiring S] [add_comm_monoid R] [add_comm_monoid A] [add_comm_monoid N] [module S R] [module S A] [module S N] ⦃f g : unitization R A →ₗ[S] N⦄ (hl : ∀ (r : R), ⇑f (unitization.inl r) = ⇑g (unitization.inl r)) (hr : ∀ (a : A), ⇑f ↑a = ⇑g ↑a) : f = g
theorem category_theory.is_pushout.of_has_pushout {C : Type u₁} [category_theory.category C] {Z X Y : C} (f : Z ⟶ X) (g : Z ⟶ Y) [category_theory.limits.has_pushout f g] : category_theory.is_pushout f g category_theory.limits.pushout.inl category_theory.limits.pushout.inr
theorem algebra.finite_type.iff_quotient_mv_polynomial {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_type R A ↔ ∃ (s : finset A) (f : mv_polynomial {x // x ∈ s} R →ₐ[R] A), function.surjective ⇑f
theorem CompHaus.is_iso_of_bijective {X Y : CompHaus} (f : X ⟶ Y) (bij : function.bijective ⇑f) : category_theory.is_iso f
theorem category_theory.forget_enrichment_id {C : Type u₁} (W : Type (v+1)) [category_theory.category W] [category_theory.monoidal_category W] [category_theory.enriched_category W C] (X : category_theory.forget_enrichment W C) : category_theory.forget_enrichment.hom_to W (𝟙 X) = category_theory.e_id W (category_theory.forget_enrichment.to W X)
theorem metric.bounded_of_finite {α : Type u} [pseudo_metric_space α] {s : set α} (h : s.finite) : metric.bounded s
theorem filter.tendsto.at_top_mul_const {α : Type u_3} {β : Type u_4} [linear_ordered_field α] {l : filter β} {f : β → α} {r : α} (hr : 0 < r) (hf : filter.tendsto f l filter.at_top) : filter.tendsto (λ (x : β), f x * r) l filter.at_top
theorem free_product.lift_injective_of_ping_pong {ι : Type u_1} [hnontriv : nontrivial ι] {G : Type u_4} [group G] {H : ι → Type u_5} [Π (i : ι), group (H i)] (f : Π (i : ι), H i →* G) (hcard : 3 ≤ cardinal.mk ι ∨ ∃ (i : ι), 3 ≤ cardinal.mk (H i)) {α : Type u_6} [mul_action G α] (X : ι → set α) (hXnonempty : ∀ (i : ι), (X i).nonempty) (hXdisj : pairwise (λ (i j : ι), disjoint (X i) (X j))) (hpp : pairwise (λ (i j : ι), ∀ (h : H i), h ≠ 1 → ⇑(f i) h • X j ⊆ X i)) : function.injective ⇑(⇑free_product.lift f)
theorem finset.sum_smul_vsub_const_eq_affine_combination_vsub {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (w : ι → k) (p₁ : ι → P) (p₂ : P) (h : s.sum (λ (i : ι), w i) = 1) : s.sum (λ (i : ι), w i • (p₁ i -ᵥ p₂)) = ⇑(s.affine_combination p₁) w -ᵥ p₂
theorem orthonormal.linear_equiv_det_conj_lie {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) : ⇑linear_equiv.det hb.conj_lie.to_linear_equiv = -1
theorem affine_map.continuous_linear_iff {𝕜 : Type u_1} {V : Type u_2} {V₂ : Type u_4} {P : Type u_8} {P₂ : Type u_9} [normed_field 𝕜] [semi_normed_group V] [semi_normed_group V₂] [normed_space 𝕜 V] [normed_space 𝕜 V₂] [pseudo_metric_space P] [pseudo_metric_space P₂] [normed_add_torsor V P] [normed_add_torsor V₂ P₂] {f : P →ᵃ[𝕜] P₂} : continuous ⇑(f.linear) ↔ continuous ⇑f
theorem polynomial.cyclotomic_eq_minpoly {n : ℕ} {K : Type u_1} [field K] {μ : K} (h : is_primitive_root μ n) (hpos : 0 < n) [char_zero K] : polynomial.cyclotomic n ℤ = minpoly ℤ μ
theorem tendsto_pow_const_mul_const_pow_of_lt_one (k : ℕ) {r : ℝ} (hr : 0 ≤ r) (h'r : r < 1) : filter.tendsto (λ (n : ℕ), ↑n ^ k * r ^ n) filter.at_top (nhds 0)
theorem mv_polynomial.induction_on''' {R : Type u} {σ : Type u_1} [comm_semiring R] {M : mv_polynomial σ R → Prop} (p : mv_polynomial σ R) (h_C : ∀ (a : R), M (⇑mv_polynomial.C a)) (h_add_weak : ∀ (a : σ →₀ ℕ) (b : R) (f : (σ →₀ ℕ) →₀ R), a ∉ f.support → b ≠ 0 → M f → M (⇑(mv_polynomial.monomial a) b + f)) : M p
theorem ring_hom.map_multiset_sum {β : Type u} {γ : Type w} [non_assoc_semiring β] [non_assoc_semiring γ] (f : β →+* γ) (s : multiset β) : ⇑f s.sum = (multiset.map ⇑f s).sum
theorem is_closed.is_closed_le {α : Type u} {β : Type v} [topological_space α] [preorder α] [t : order_closed_topology α] [topological_space β] {f g : β → α} {s : set β} (hs : is_closed s) (hf : continuous_on f s) (hg : continuous_on g s) : is_closed {x ∈ s | f x ≤ g x}
theorem interval_integral.integral_has_strict_deriv_at_of_tendsto_ae_left {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {c : E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (ha : filter.tendsto f (nhds a ⊓ measure_theory.measure_space.volume.ae) (nhds c)) : has_strict_deriv_at (λ (u : ℝ), ∫ (x : ℝ) in u..b, f x) (-c) a
theorem list.of_fn_zero {α : Type u} (f : fin 0 → α) : list.of_fn f = list.nil
theorem affine.triangle.dist_orthocenter_reflection_circumcenter_finset {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle ℝ P) {i₁ i₂ : fin 3} (h : i₁ ≠ i₂) : has_dist.dist t.orthocenter (⇑(euclidean_geometry.reflection (affine_span ℝ (t.points '' ↑{i₁, i₂}))) (affine.simplex.circumcenter t)) = affine.simplex.circumradius t
theorem generalized_continued_fraction.of_correctness_of_terminates {K : Type u_1} [linear_ordered_field K] {v : K} [floor_ring K] (terminates : (generalized_continued_fraction.of v).terminates) : ∃ (n : ℕ), v = (generalized_continued_fraction.of v).convergents n
theorem equiv.option_congr_eq_equiv_function_map_equiv {α β : Type u_1} (e : α ≃ β) : e.option_congr = equiv_functor.map_equiv option e
theorem is_unit.mul_left_dvd {α : Type u_1} [comm_monoid α] (a b u : α) (hu : is_unit u) : u * a ∣ b ↔ a ∣ b
theorem continuous_linear_map.op_norm_lsmul (𝕜 : Type u_1) {E : Type u_4} [normed_group E] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] (𝕜' : Type u_12) [normed_field 𝕜'] [normed_algebra 𝕜 𝕜'] [normed_space 𝕜' E] [is_scalar_tower 𝕜 𝕜' E] [nontrivial E] : ∥continuous_linear_map.lsmul 𝕜 𝕜'∥ = 1
theorem continuous_linear_map.exists_approx_preimage_norm_le {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] (f : E →L[𝕜] F) [complete_space F] (surj : function.surjective ⇑f) : ∃ (C : ℝ) (H : C ≥ 0), ∀ (y : F), ∃ (x : E), has_dist.dist (⇑f x) y ≤ 1 / 2 * ∥y∥ ∧ ∥x∥ ≤ C * ∥y∥
theorem lucas_lehmer.X.units_card {q : ℕ+} (w : 1 < q) : fintype.card (lucas_lehmer.X q)ˣ < ↑q ^ 2
theorem finset.image_image₂_distrib_left {α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} [decidable_eq α'] [decidable_eq γ] [decidable_eq δ] {f : α → β → γ} {s : finset α} {t : finset β} {g : γ → δ} {f' : α' → β → δ} {g' : α → α'} (h_distrib : ∀ (a : α) (b : β), g (f a b) = f' (g' a) b) : finset.image g (finset.image₂ f s t) = finset.image₂ f' (finset.image g' s) t
theorem vitali_family.exists_measurable_supersets_lim_ratio {α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {ρ : measure_theory.measure α} [measure_theory.is_locally_finite_measure ρ] (hρ : ρ.absolutely_continuous μ) {p q : nnreal} (hpq : p < q) : ∃ (a b : set α), measurable_set a ∧ measurable_set b ∧ {x : α | v.lim_ratio ρ x < ↑p} ⊆ a ∧ {x : α | ↑q < v.lim_ratio ρ x} ⊆ b ∧ ⇑μ (a ∩ b) = 0
theorem cont_diff_on_succ_iff_deriv_within {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f₂ : 𝕜 → F} {s₂ : set 𝕜} {n : ℕ} (hs : unique_diff_on 𝕜 s₂) : cont_diff_on 𝕜 ↑(n + 1) f₂ s₂ ↔ differentiable_on 𝕜 f₂ s₂ ∧ cont_diff_on 𝕜 ↑n (deriv_within f₂ s₂) s₂
theorem add_subgroup.ext {G : Type u_1} [add_group G] {H K : add_subgroup G} (h : ∀ (x : G), x ∈ H ↔ x ∈ K) : H = K
theorem category_theory.limits.strong_epi_of_strong_epi_mono_factorisation {C : Type u} [category_theory.category C] {X Y : C} {f : X ⟶ Y} (F : category_theory.limits.strong_epi_mono_factorisation f) {F' : category_theory.limits.mono_factorisation f} (hF' : category_theory.limits.is_image F') : category_theory.strong_epi F'.e
theorem edist_ne_top {α : Type u} [pseudo_metric_space α] (x y : α) : has_edist.edist x y ≠ ⊤
theorem linear_independent.of_comp {ι : Type u_1} {R : Type u_3} {M : Type u_5} {M' : Type u_6} {v : ι → M} [semiring R] [add_comm_monoid M] [add_comm_monoid M'] [module R M] [module R M'] (f : M →ₗ[R] M') (hfv : linear_independent R (⇑f ∘ v)) : linear_independent R v
theorem real.not_summable_nat_cast_inv  : ¬summable (λ (n : ℕ), (↑n)⁻¹)
theorem first_order.language.ultraproduct.sentence_realize {α : Type u_1} {M : α → Type u_2} {u : ultrafilter α} {L : first_order.language} [Π (a : α), L.Structure (M a)] [∀ (a : α), nonempty (M a)] (φ : L.sentence) : ↑u.product M ⊨ φ ↔ ∀ᶠ (a : α) in ↑u, M a ⊨ φ
theorem char_eq_exp_char_iff (R : Type u) [semiring R] (p q : ℕ) [hp : char_p R p] [hq : exp_char R q] : p = q ↔ nat.prime p
theorem category_theory.simple_of_is_simple_order_subobject {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) [is_simple_order (category_theory.subobject X)] : category_theory.simple X
theorem subgroup.commute_of_normal_of_disjoint {G : Type u_1} [group G] (H₁ H₂ : subgroup G) (hH₁ : H₁.normal) (hH₂ : H₂.normal) (hdis : disjoint H₁ H₂) (x y : G) (hx : x ∈ H₁) (hy : y ∈ H₂) : commute x y
theorem mv_polynomial.fin_succ_equiv_coeff_coeff {R : Type u} [comm_semiring R] {n : ℕ} (m : fin n →₀ ℕ) (f : mv_polynomial (fin (n + 1)) R) (i : ℕ) : mv_polynomial.coeff m ((⇑(mv_polynomial.fin_succ_equiv R n) f).coeff i) = mv_polynomial.coeff (finsupp.cons i m) f
theorem tendsto_one_plus_div_pow_exp (t : ℝ) : filter.tendsto (λ (x : ℕ), (1 + t / ↑x) ^ x) filter.at_top (nhds (real.exp t))
theorem convex_on.comp_linear_map {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [add_comm_monoid F] [ordered_add_comm_monoid β] [module 𝕜 E] [module 𝕜 F] [has_scalar 𝕜 β] {f : F → β} {s : set F} (hf : convex_on 𝕜 s f) (g : E →ₗ[𝕜] F) : convex_on 𝕜 (⇑g ⁻¹' s) (f ∘ ⇑g)
theorem finprod_mem_dvd {α : Type u_1} {N : Type u_6} [comm_monoid N] {f : α → N} (a : α) (hf : (function.mul_support f).finite) : f a ∣ finprod f
theorem category_theory.functor.punit_ext' {C : Type u} [category_theory.category C] (F G : C ⥤ category_theory.discrete punit) : F = G
theorem box_integral.integral_nonneg {ι : Type u} {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {g : (ι → ℝ) → ℝ} (hg : ∀ (x : ι → ℝ), x ∈ ⇑box_integral.box.Icc I → 0 ≤ g x) (μ : measure_theory.measure (ι → ℝ)) [measure_theory.is_locally_finite_measure μ] : 0 ≤ box_integral.integral I l g μ.to_box_additive.to_smul
theorem witt_vector.is_poly.comp₂ {p : ℕ} {g : Π ⦃R : Type u_1⦄ [_inst_3 : comm_ring R], witt_vector p R → witt_vector p R} {f : Π ⦃R : Type u_1⦄ [_inst_3 : comm_ring R], witt_vector p R → witt_vector p R → witt_vector p R} (hg : witt_vector.is_poly p g) (hf : witt_vector.is_poly₂ p f) : witt_vector.is_poly₂ p (λ (R : Type u_1) (_Rcr : comm_ring R) (x y : witt_vector p R), g (f x y))
theorem witt_vector.neg_is_poly {p : ℕ} [hp : fact (nat.prime p)] : witt_vector.is_poly p (λ (R : Type u_1) (_x : comm_ring R), has_neg.neg)
theorem equiv.polish_space_induced {α : Type u_1} {β : Type u_2} [t : topological_space β] [polish_space β] (f : α ≃ β) : polish_space α
theorem tendsto_measure_cthickening_of_is_compact {α : Type u_1} [metric_space α] [measurable_space α] [opens_measurable_space α] [proper_space α] {μ : measure_theory.measure α} [measure_theory.is_finite_measure_on_compacts μ] {s : set α} (hs : is_compact s) : filter.tendsto (λ (r : ℝ), ⇑μ (metric.cthickening r s)) (nhds 0) (nhds (⇑μ s))
theorem multilinear_map.snoc_smul {R : Type u} {n : ℕ} {M : fin n.succ → Type v} {M₂ : Type v₂} [semiring R] [Π (i : fin n.succ), add_comm_monoid (M i)] [add_comm_monoid M₂] [Π (i : fin n.succ), module R (M i)] [module R M₂] (f : multilinear_map R M M₂) (m : Π (i : fin n), M (⇑fin.cast_succ i)) (c : R) (x : M (fin.last n)) : ⇑f (fin.snoc m (c • x)) = c • ⇑f (fin.snoc m x)
theorem linear_equiv.finite_dimensional {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {V₂ : Type v'} [add_comm_group V₂] [module K V₂] (f : V ≃ₗ[K] V₂) [finite_dimensional K V] : finite_dimensional K V₂
theorem category_theory.limits.has_pushouts_of_has_binary_coproducts_of_has_coequalizers (C : Type u) [𝒞 : category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_pushouts C
theorem is_group_hom.inv {α : Type u_1} {β : Type u_2} [group α] [comm_group β] {f : α → β} (hf : is_group_hom f) : is_group_hom (λ (a : α), (f a)⁻¹)
theorem polynomial.cyclotomic'_two (R : Type u_1) [comm_ring R] [is_domain R] (p : ℕ) [char_p R p] (hp : p ≠ 2) : polynomial.cyclotomic' 2 R = polynomial.X + 1
theorem list.prod_pos {R : Type u_8} [ordered_semiring R] [nontrivial R] (l : list R) (h : ∀ (a : R), a ∈ l → 0 < a) : 0 < l.prod
theorem affine.simplex.eq_circumcenter_of_dist_eq {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P n) {p : P} (hp : p ∈ affine_span ℝ (set.range s.points)) {r : ℝ} (hr : ∀ (i : fin (n + 1)), has_dist.dist (s.points i) p = r) : p = s.circumcenter
theorem subset_tangent_cone_prod_right {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {x : E} {s : set E} {t : set F} {y : F} (hs : x ∈ closure s) : ⇑(linear_map.inr 𝕜 E F) '' tangent_cone_at 𝕜 t y ⊆ tangent_cone_at 𝕜 (s ×ˢ t) (x, y)
theorem category_theory.presieve.is_sheaf_pretopology {C : Type u₁} [category_theory.category C] {P : Cᵒᵖ ⥤ Type w} [category_theory.limits.has_pullbacks C] (K : category_theory.pretopology C) : category_theory.presieve.is_sheaf (category_theory.pretopology.to_grothendieck C K) P ↔ ∀ {X : C} (R : category_theory.presieve X), R ∈ ⇑K X → category_theory.presieve.is_sheaf_for P R
theorem filter.map_coe_Ioi_at_top {α : Type u_3} [semilattice_sup α] [no_max_order α] (a : α) : filter.map coe filter.at_top = filter.at_top
theorem order.cof_nonempty {α : Type u_1} (r : α → α → Prop) [is_refl α r] : {c : cardinal | ∃ (S : set α), (∀ (a : α), ∃ (b : α) (H : b ∈ S), r a b) ∧ cardinal.mk ↥S = c}.nonempty
theorem game.not_le {x y : game} : ¬x ≤ y ↔ y.lf x
theorem category_theory.is_pushout.of_is_colimit {C : Type u₁} [category_theory.category C] {Z X Y : C} {f : Z ⟶ X} {g : Z ⟶ Y} {c : category_theory.limits.pushout_cocone f g} (h : category_theory.limits.is_colimit c) : category_theory.is_pushout f g c.inl c.inr
theorem ideal.exists_smith_normal_form {ι : Type u_1} {R : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] [fintype ι] {S : Type u_3} [comm_ring S] [is_domain S] [algebra R S] (b : basis ι R S) (I : ideal S) (hI : I ≠ ⊥) : ∃ (b' : basis ι R S) (a : ι → R) (ab' : basis ι R ↥I), ∀ (i : ι), ↑(⇑ab' i) = a i • ⇑b' i
theorem localization.r_eq_r' {M : Type u_1} [comm_monoid M] (S : submonoid M) : localization.r S = localization.r' S
theorem subgroup.is_open_of_one_mem_interior {G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 ∈ interior ↑H) : is_open ↑H
theorem orientation.oangle_smul_left_of_pos {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x y : V) {r : ℝ} (hr : 0 < r) : o.oangle (r • x) y = o.oangle x y
theorem dot_self_cross {R : Type u_1} [comm_ring R] (v w : fin 3 → R) : matrix.dot_product v (⇑(⇑cross_product v) w) = 0
theorem subgroup.exists_left_complement'_of_coprime {G : Type u} [group G] {N : subgroup G} [N.normal] (hN : (nat.card ↥N).coprime N.index) : ∃ (H : subgroup G), H.is_complement' N
theorem affine.simplex.circumradius_pos {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P (n + 1)) : 0 < s.circumradius
theorem interval_integral.deriv_within_integral_right {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set ℝ} [interval_integral.FTC_filter b (nhds_within b s) (nhds_within b t)] (hmeas : strongly_measurable_at_filter f (nhds_within b t) measure_theory.measure_space.volume) (hb : continuous_within_at f t b) (hs : unique_diff_within_at ℝ s b . "unique_diff_within_at_Ici_Iic_univ") : deriv_within (λ (u : ℝ), ∫ (x : ℝ) in a..u, f x) s b = f b
theorem vector.to_list_singleton {α : Type u_1} (v : vector α 1) : v.to_list = [v.head]
theorem map_csupr_of_continuous_at_of_monotone {α : Type u} {β : Type v} {γ : Type w} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [conditionally_complete_linear_order β] [topological_space β] [order_topology β] [nonempty γ] {f : α → β} {g : γ → α} (Cf : continuous_at f (⨆ (i : γ), g i)) (Mf : monotone f) (H : bdd_above (set.range g)) : f (⨆ (i : γ), g i) = ⨆ (i : γ), f (g i)
theorem add_monoid_algebra.ring_hom_ext {k : Type u₁} {G : Type u₂} {R : Type u_1} [semiring k] [add_monoid G] [semiring R] {f g : add_monoid_algebra k G →+* R} (h₀ : ∀ (b : k), ⇑f (finsupp.single 0 b) = ⇑g (finsupp.single 0 b)) (h_of : ∀ (a : G), ⇑f (finsupp.single a 1) = ⇑g (finsupp.single a 1)) : f = g
theorem zmod.χ₈_trichotomy (a : zmod 8) : ⇑zmod.χ₈ a = 0 ∨ ⇑zmod.χ₈ a = 1 ∨ ⇑zmod.χ₈ a = -1
theorem category_theory.Ran_is_sheaf_of_cover_lifting.helper {C D : Type u} [category_theory.category C] [category_theory.category D] {A : Type w} [category_theory.category A] [category_theory.limits.has_limits A] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {G : C ⥤ D} (hu : category_theory.cover_lifting J K G) (ℱ : category_theory.Sheaf J A) {X : A} {U : D} {S : category_theory.sieve U} (hS : S ∈ ⇑K U) {x : category_theory.presieve.family_of_elements ((category_theory.Ran G.op).obj ℱ.val ⋙ category_theory.coyoneda.obj (opposite.op X)) S.arrows} (hx : x.compatible) {V : D} (f : V ⟶ U) (y : X ⟶ ((category_theory.Ran G.op).obj ℱ.val).obj (opposite.op V)) (W : category_theory.structured_arrow (opposite.op V) G.op) (H : ∀ {V' : C} {fV : G.obj V' ⟶ V} (hV : S.arrows (fV ≫ f)), y ≫ ((category_theory.Ran G.op).obj ℱ.val).map fV.op = x (fV ≫ f) hV) : y ≫ category_theory.limits.limit.π (category_theory.Ran.diagram G.op ℱ.val (opposite.op V)) W = (category_theory.Ran_is_sheaf_of_cover_lifting.glued_limit_cone hu ℱ hS hx).π.app ((category_theory.structured_arrow.map f.op).obj W)
theorem finrank_eq_one_iff' {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : finite_dimensional.finrank K V = 1 ↔ ∃ (v : V) (n : v ≠ 0), ∀ (w : V), ∃ (c : K), c • v = w
theorem ennreal.of_real_of_nonpos {p : ℝ} : p ≤ 0 → ennreal.of_real p = 0
theorem measure_theory.tendsto_measure_Union {α : Type u_1} {ι : Type u_5} {m : measurable_space α} {μ : measure_theory.measure α} [semilattice_sup ι] [encodable ι] {s : ι → set α} (hm : monotone s) : filter.tendsto (⇑μ ∘ s) filter.at_top (nhds (⇑μ (⋃ (n : ι), s n)))
theorem submodule.pow_induction_on_right' {R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] (M : submodule R A) {C : Π (n : ℕ) (x : A), x ∈ M ^ n → Prop} (hr : ∀ (r : R), C 0 (⇑(algebra_map R A) r) _) (hadd : ∀ (x y : A) (i : ℕ) (hx : x ∈ M ^ i) (hy : y ∈ M ^ i), C i x hx → C i y hy → C i (x + y) _) (hmul : ∀ (i : ℕ) (x : A) (hx : x ∈ M ^ i), C i x hx → ∀ (m : A) (H : m ∈ M), C i.succ (x * m) _) {x : A} {n : ℕ} (hx : x ∈ M ^ n) : C n x hx
theorem nat.nth_eq_order_iso_of_nat (p : ℕ → Prop) [decidable_pred p] (i : infinite ↥(set_of p)) (n : ℕ) : nat.nth p n = ↑(⇑(nat.subtype.order_iso_of_nat (set_of p)) n)
theorem pgame.left_response_spec {x : pgame} (h : 0 ≤ x) (j : x.right_moves) : 0 ≤ (x.move_right j).move_left (pgame.left_response h j)
theorem is_compact.ultrafilter_le_nhds {α : Type u} [topological_space α] {s : set α} : is_compact s → ∀ (f : ultrafilter α), ↑f ≤ filter.principal s → (∃ (a : α) (H : a ∈ s), ↑f ≤ nhds a)
theorem function.not_surjective_Type {α : Type u} (f : α → Type (max u v)) : ¬function.surjective f
theorem has_deriv_at_interval_left_endpoint_of_tendsto_deriv {E : Type u_1} [normed_group E] [normed_space ℝ E] {s : set ℝ} {e : E} {a : ℝ} {f : ℝ → E} (f_diff : differentiable_on ℝ f s) (f_lim : continuous_within_at f s a) (hs : s ∈ nhds_within a (set.Ioi a)) (f_lim' : filter.tendsto (λ (x : ℝ), deriv f x) (nhds_within a (set.Ioi a)) (nhds e)) : has_deriv_within_at f e (set.Ici a) a
theorem continuous_map.continuous_eval {α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β] : continuous (λ (p : C(α, β) × α), ⇑(p.fst) p.snd)
theorem set.Union_lift_unary {α : Type u_1} {ι : Type u_2} {β : Type u_3} {S : ι → set α} {f : Π (i : ι), ↥(S i) → β} {hf : ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j), f i ⟨x, hxi⟩ = f j ⟨x, hxj⟩} {T : set α} (hT' : T = set.Union S) (u : ↥T → ↥T) (ui : Π (i : ι), ↥(S i) → ↥(S i)) (hui : ∀ (i : ι) (x : ↥(S i)), u (set.inclusion _ x) = set.inclusion _ (ui i x)) (uβ : β → β) (h : ∀ (i : ι) (x : ↥(S i)), f i (ui i x) = uβ (f i x)) (x : ↥T) : set.Union_lift S f hf T _ (u x) = uβ (set.Union_lift S f hf T _ x)
theorem is_primitive_root.pow_sub_one_norm_prime_pow_ne_two {p : ℕ+} {K : Type u} {L : Type v} [field L] {ζ : L} [field K] [algebra K L] [ne_zero ↑↑p] {k s : ℕ} (hζ : is_primitive_root ζ ↑(p ^ (k + 1))) [hpri : fact (nat.prime ↑p)] [is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic ↑(p ^ (k + 1)) K)) (hs : s ≤ k) (htwo : p ^ (k - s + 1) ≠ 2) : ⇑(algebra.norm K) (ζ ^ ↑p ^ s - 1) = ↑p ^ ↑p ^ s
theorem real.young_inequality_of_nonneg {a b p q : ℝ} (ha : 0 ≤ a) (hb : 0 ≤ b) (hpq : p.is_conjugate_exponent q) : a * b ≤ a ^ p / p + b ^ q / q
theorem cInf_insert {α : Type u_1} [conditionally_complete_lattice α] {s : set α} {a : α} (hs : bdd_below s) (sne : s.nonempty) : has_Inf.Inf (has_insert.insert a s) = a ⊓ has_Inf.Inf s
theorem mul_equiv.is_monoid_hom {M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (h : M ≃* N) : is_monoid_hom ⇑h
theorem symm_trans_mem_cont_diff_groupoid (n : with_top ℕ) {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] (e : local_homeomorph M H) : e.symm.trans e ∈ cont_diff_groupoid n I
theorem simple_graph.is_SRG_with.top {V : Type u} [fintype V] [decidable_eq V] {μ : ℕ} : ⊤.is_SRG_with (fintype.card V) (fintype.card V - 1) (fintype.card V - 2) μ
theorem is_compact.compl_mem_sets_of_nhds_within {α : Type u} [topological_space α] {s : set α} (hs : is_compact s) {f : filter α} (hf : ∀ (a : α), a ∈ s → (∃ (t : set α) (H : t ∈ nhds_within a s), tᶜ ∈ f)) : sᶜ ∈ f
theorem witt_vector.map_frobenius_poly.key₁ (p : ℕ) [hp : fact (nat.prime p)] (n j : ℕ) (hj : j < p ^ n) : p ^ (n - pnat_multiplicity p ⟨j + 1, _⟩) ∣ (p ^ n).choose (j + 1)
theorem real.tendsto_mul_exp_add_div_pow_at_top (b c : ℝ) (n : ℕ) (hb : 0 < b) : filter.tendsto (λ (x : ℝ), (b * real.exp x + c) / x ^ n) filter.at_top filter.at_top
theorem is_mul_hom.inv {α : Type u_1} {β : Type u_2} [has_mul α] [comm_group β] {f : α → β} (hf : is_mul_hom f) : is_mul_hom (λ (a : α), (f a)⁻¹)
theorem formal_multilinear_series.left_inv_comp {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) (i : E ≃L[𝕜] F) (h : p 1 = ⇑((continuous_multilinear_curry_fin1 𝕜 E F).symm) ↑i) : (p.left_inv i).comp p = formal_multilinear_series.id 𝕜 E
theorem pgame.le_iff_forall_lf {x y : pgame} : x ≤ y ↔ (∀ (i : x.left_moves), (x.move_left i).lf y) ∧ ∀ (j : y.right_moves), x.lf (y.move_right j)
theorem measure_theory.conservative.frequently_ae_mem_and_frequently_image_mem {α : Type u_2} [measurable_space α] {f : α → α} {s : set α} {μ : measure_theory.measure α} (hf : measure_theory.conservative f μ) (hs : measurable_set s) (h0 : ⇑μ s ≠ 0) : ∃ᵐ (x : α) ∂μ, x ∈ s ∧ ∃ᶠ (n : ℕ) in filter.at_top, f^[n] x ∈ s
theorem powers.is_submonoid {M : Type u_1} [monoid M] (x : M) : is_submonoid (powers x)
theorem add_semiconj_by.zero_left {M : Type u} [add_zero_class M] (x : M) : add_semiconj_by 0 x x
theorem con.Inf_def {M : Type u_1} [has_mul M] (S : set (con M)) : ⇑(has_Inf.Inf S) = has_Inf.Inf (coe_fn '' S)
theorem measure_theory.measure.is_add_haar_measure_map {G : Type u_1} [measurable_space G] [add_group G] [topological_space G] (μ : measure_theory.measure G) [μ.is_add_haar_measure] [borel_space G] [topological_add_group G] {H : Type u_2} [add_group H] [topological_space H] [measurable_space H] [borel_space H] [t2_space H] [topological_add_group H] (f : G ≃+ H) (hf : continuous ⇑f) (hfsymm : continuous ⇑(f.symm)) : (measure_theory.measure.map ⇑f μ).is_add_haar_measure
theorem ideal.rank_eq {R : Type u_1} {S : Type u_2} [comm_ring R] [strong_rank_condition R] [ring S] [is_domain S] [algebra R S] {n : Type u_3} {m : Type u_4} [fintype n] [fintype m] (b : basis n R S) {I : ideal S} (hI : I ≠ ⊥) (c : basis m R ↥I) : fintype.card m = fintype.card n
theorem continuous_map.exists_mem_subalgebra_near_continuous_of_separates_points {X : Type u_1} [topological_space X] [compact_space X] (A : subalgebra ℝ C(X, ℝ)) (w : A.separates_points) (f : X → ℝ) (c : continuous f) (ε : ℝ) (pos : 0 < ε) : ∃ (g : ↥A), ∀ (x : X), ∥⇑g x - f x∥ < ε
theorem int.zpow_lt_iff_lt_clog {R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r) : ↑b ^ x < r ↔ x < int.clog b r
theorem is_ring_hom.comp {α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (hf : is_ring_hom f) {γ : Type u_1} [ring γ] {g : β → γ} (hg : is_ring_hom g) : is_ring_hom (g ∘ f)
theorem contract_left_assoc_coevaluation' (K : Type u) [field K] (V : Type v) [add_comm_group V] [module K V] [finite_dimensional K V] : (linear_map.ltensor V (contract_left K V)).comp ((tensor_product.assoc K V (module.dual K V) V).to_linear_map.comp (linear_map.rtensor V (coevaluation K V))) = (tensor_product.rid K V).symm.to_linear_map.comp (tensor_product.lid K V).to_linear_map
theorem affine_combination_mem_affine_span {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} [nontrivial k] {s : finset ι} {w : ι → k} (h : s.sum (λ (i : ι), w i) = 1) (p : ι → P) : ⇑(s.affine_combination p) w ∈ affine_span k (set.range p)
theorem equiv.perm.is_cycle.support_congr {α : Type u_1} [decidable_eq α] [fintype α] {f g : equiv.perm α} (hf : f.is_cycle) (hg : g.is_cycle) (h : f.support ⊆ g.support) (h' : ∀ (x : α), x ∈ f.support → ⇑f x = ⇑g x) : f = g
theorem bdd_below.inter_of_right {α : Type u} [preorder α] {s t : set α} (h : bdd_below t) : bdd_below (s ∩ t)
theorem finset.card_Ioc_finset {α : Type u_1} [decidable_eq α] {s t : finset α} (h : s ⊆ t) : (finset.Ioc s t).card = 2 ^ (t.card - s.card) - 1
theorem category_theory.equiv_punit_iff_unique (C : Type u) [category_theory.category C] : nonempty (C ≌ category_theory.discrete punit) ↔ nonempty C ∧ ∀ (x y : C), nonempty (unique (x ⟶ y))
theorem inner_product_geometry.angle_eq_zero_iff {V : Type u_1} [inner_product_space ℝ V] {x y : V} : inner_product_geometry.angle x y = 0 ↔ x ≠ 0 ∧ ∃ (r : ℝ), 0 < r ∧ y = r • x
theorem category_theory.is_subterminal.mono_terminal_from {C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] (hA : category_theory.is_subterminal A) : category_theory.mono (category_theory.limits.terminal.from A)
theorem is_unit.nat_abs_eq {n : ℤ} : is_unit n → n.nat_abs = 1
theorem category_theory.is_cofiltered.of_is_left_adjoint {C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] {D : Type u₁} [category_theory.category D] (L : C ⥤ D) [category_theory.is_left_adjoint L] : category_theory.is_cofiltered D
theorem map_exp (𝕂 : Type u_1) {𝔸 : Type u_2} {𝔹 : Type u_3} [is_R_or_C 𝕂] [normed_ring 𝔸] [normed_algebra 𝕂 𝔸] [normed_ring 𝔹] [normed_algebra 𝕂 𝔹] [complete_space 𝔸] {F : Type u_4} [ring_hom_class F 𝔸 𝔹] (f : F) (hf : continuous ⇑f) (x : 𝔸) : ⇑f (exp 𝕂 x) = exp 𝕂 (⇑f x)
theorem same_ray.add_left {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y z : M} (hx : same_ray R x z) (hy : same_ray R y z) : same_ray R (x + y) z
theorem embedding.to_isometry {α : Type u_1} {β : Type u_2} [topological_space α] [metric_space β] {f : α → β} (h : embedding f) : isometry f
theorem isometry.edist_eq {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} (hf : isometry f) (x y : α) : has_edist.edist (f x) (f y) = has_edist.edist x y
theorem polynomial.X_pow_mul_assoc_C {R : Type u} [semiring R] {p : polynomial R} {n : ℕ} (r : R) : p * polynomial.X ^ n * ⇑polynomial.C r = p * ⇑polynomial.C r * polynomial.X ^ n
theorem nat.count_eq_card_fintype (p : ℕ → Prop) [decidable_pred p] (n : ℕ) : nat.count p n = fintype.card {k // k < n ∧ p k}
theorem interval_integral.integral_lt_integral_of_ae_le_of_measure_set_of_lt_ne_zero {f g : ℝ → ℝ} {a b : ℝ} {μ : measure_theory.measure ℝ} (hab : a ≤ b) (hfi : interval_integrable f μ a b) (hgi : interval_integrable g μ a b) (hle : f ≤ᵐ[μ.restrict (set.Ioc a b)] g) (hlt : ⇑(μ.restrict (set.Ioc a b)) {x : ℝ | f x < g x} ≠ 0) : ∫ (x : ℝ) in a..b, f x ∂μ < ∫ (x : ℝ) in a..b, g x ∂μ
theorem category_theory.limits.trident.equalizer_ext {J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J → (X ⟶ Y)} [nonempty J] (s : category_theory.limits.trident f) {W : C} {k l : W ⟶ s.X} (h : k ≫ s.ι = l ≫ s.ι) (j : category_theory.limits.walking_parallel_family J) : k ≫ s.π.app j = l ≫ s.π.app j
theorem basis.ext_elem {ι : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (b : basis ι R M) {x y : M} (h : ∀ (i : ι), ⇑(⇑(b.repr) x) i = ⇑(⇑(b.repr) y) i) : x = y
theorem convex_cone.to_ordered_smul {𝕜 : Type u_1} {E : Type u_2} [linear_ordered_field 𝕜] [ordered_add_comm_group E] [module 𝕜 E] (S : convex_cone 𝕜 E) (h : ∀ (x y : E), x ≤ y ↔ y - x ∈ S) : ordered_smul 𝕜 E
theorem mem_tangent_cone_of_segment_subset {G : Type u_4} [normed_group G] [normed_space ℝ G] {s : set G} {x y : G} (h : segment ℝ x y ⊆ s) : y - x ∈ tangent_cone_at ℝ s x
theorem emetric.nonempty_of_Hausdorff_edist_ne_top {α : Type u} [pseudo_emetric_space α] {s t : set α} (hs : s.nonempty) (fin : emetric.Hausdorff_edist s t ≠ ⊤) : t.nonempty
theorem category_theory.R_faithful_of_counit_is_iso {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {L : C ⥤ D} {R : D ⥤ C} (h : L ⊣ R) [category_theory.is_iso h.counit] : category_theory.faithful R
theorem add_localization.r_eq_r' {M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) : add_localization.r S = add_localization.r' S
theorem finprod_mem_sUnion {α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M} {t : set (set α)} (h : t.pairwise_disjoint id) (ht₀ : t.finite) (ht₁ : ∀ (x : set α), x ∈ t → x.finite) : finprod (λ (a : α), finprod (λ (H : a ∈ ⋃₀t), f a)) = finprod (λ (s : set α), finprod (λ (H : s ∈ t), finprod (λ (a : α), finprod (λ (H : a ∈ s), f a))))
theorem bilin_form.sum_repr_mul_repr_mul {R₂ : Type u_5} {M₂ : Type u_6} [comm_semiring R₂] [add_comm_monoid M₂] [module R₂ M₂] {B₂ : bilin_form R₂ M₂} {ι : Type u_13} (b : basis ι R₂ M₂) (x y : M₂) : (⇑(b.repr) x).sum (λ (i : ι) (xi : R₂), (⇑(b.repr) y).sum (λ (j : ι) (yj : R₂), xi • yj • ⇑B₂ (⇑b i) (⇑b j))) = ⇑B₂ x y
theorem module.direct_limit.of.zero_exact {R : Type u} [ring R] {ι : Type v} [dec_ι : decidable_eq ι] [preorder ι] {G : ι → Type w} [Π (i : ι), add_comm_group (G i)] [Π (i : ι), module R (G i)] {f : Π (i j : ι), i ≤ j → (G i →ₗ[R] G j)} [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] [is_directed ι has_le.le] {i : ι} {x : G i} (H : ⇑(module.direct_limit.of R ι G f i) x = 0) : ∃ (j : ι) (hij : i ≤ j), ⇑(f i j hij) x = 0
theorem algebraic_geometry.PresheafedSpace.is_open_immersion.to_iso {C : Type u} [category_theory.category C] {X Y : algebraic_geometry.PresheafedSpace C} (f : X ⟶ Y) [h : algebraic_geometry.PresheafedSpace.is_open_immersion f] [h' : category_theory.epi f.base] : category_theory.is_iso f
theorem measure_theory.measure.add_haar_image_continuous_linear_map {E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (f : E →L[ℝ] E) (s : set E) : ⇑μ (⇑f '' s) = ennreal.of_real |⇑linear_map.det ↑f| * ⇑μ s
theorem convex_on.map_sum_le {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} {ι : Type u_5} [linear_ordered_field 𝕜] [add_comm_group E] [ordered_add_comm_group β] [module 𝕜 E] [module 𝕜 β] [ordered_smul 𝕜 β] {s : set E} {f : E → β} {t : finset ι} {w : ι → 𝕜} {p : ι → E} (hf : convex_on 𝕜 s f) (h₀ : ∀ (i : ι), i ∈ t → 0 ≤ w i) (h₁ : t.sum (λ (i : ι), w i) = 1) (hmem : ∀ (i : ι), i ∈ t → p i ∈ s) : f (t.sum (λ (i : ι), w i • p i)) ≤ t.sum (λ (i : ι), w i • f (p i))
theorem fin.prod_univ_cast_succ {β : Type u_2} [comm_monoid β] {n : ℕ} (f : fin (n + 1) → β) : finset.univ.prod (λ (i : fin (n + 1)), f i) = finset.univ.prod (λ (i : fin n), f (⇑fin.cast_succ i)) * f (fin.last n)
theorem interval_integral.integral_has_fderiv_within_at {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {la lb : filter ℝ} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f la measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f lb measure_theory.measure_space.volume) {s t : set ℝ} [interval_integral.FTC_filter a (nhds_within a s) la] [interval_integral.FTC_filter b (nhds_within b t) lb] (ha : filter.tendsto f la (nhds (f a))) (hb : filter.tendsto f lb (nhds (f b))) : has_fderiv_within_at (λ (p : ℝ × ℝ), ∫ (x : ℝ) in p.fst..p.snd, f x) ((continuous_linear_map.snd ℝ ℝ ℝ).smul_right (f b) - (continuous_linear_map.fst ℝ ℝ ℝ).smul_right (f a)) (s ×ˢ t) (a, b)
theorem vadd_vsub {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (g : G) (p : P) : g +ᵥ p -ᵥ p = g
theorem cont_diff_within_at_local_invariant_prop {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners 𝕜 E' H') (n : with_top ℕ) : (cont_diff_groupoid ⊤ I).local_invariant_prop (cont_diff_groupoid ⊤ I') (cont_diff_within_at_prop I I' n)
theorem cont_diff_at.has_strict_deriv_at {n : with_top ℕ} {𝕂 : Type u_6} [is_R_or_C 𝕂] {F' : Type u_8} [normed_group F'] [normed_space 𝕂 F'] {f : 𝕂 → F'} {x : 𝕂} (hf : cont_diff_at 𝕂 n f x) (hn : 1 ≤ n) : has_strict_deriv_at f (deriv f x) x
theorem normed_space.polar_closed_ball {𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {r : ℝ} (hr : 0 < r) : normed_space.polar 𝕜 (metric.closed_ball 0 r) = metric.closed_ball 0 r⁻¹
theorem is_field.localization_map_bijective {R : Type u_1} {Rₘ : Type u_2} [comm_ring R] [comm_ring Rₘ] {M : submonoid R} (hM : 0 ∉ M) (hR : is_field R) [algebra R Rₘ] [is_localization M Rₘ] : function.bijective ⇑(algebra_map R Rₘ)
theorem has_sum.mapL {ι : Type u_10} {R : Type u_11} {R₂ : Type u_12} {M : Type u_13} {M₂ : Type u_14} [semiring R] [semiring R₂] [add_comm_monoid M] [module R M] [add_comm_monoid M₂] [module R₂ M₂] [topological_space M] [topological_space M₂] {σ : R →+* R₂} {f : ι → M} (φ : M →SL[σ] M₂) {x : M} (hf : has_sum f x) : has_sum (λ (b : ι), ⇑φ (f b)) (⇑φ x)
theorem padic_norm.nonneg (p : ℕ) (q : ℚ) : 0 ≤ padic_norm p q
theorem finset.inf_coe {α : Type u_1} {β : Type u_2} [semilattice_inf α] [order_top α] {P : α → Prop} {Ptop : P ⊤} {Pinf : ∀ ⦃x y : α⦄, P x → P y → P (x ⊓ y)} (t : finset β) (f : β → {x // P x}) : ↑(t.inf f) = t.inf (λ (x : β), ↑(f x))
theorem tsum_mul_tsum_eq_tsum_sum_antidiagonal {α : Type u_1} {f g : ℕ → α} [topological_space α] [non_unital_non_assoc_semiring α] [regular_space α] [topological_semiring α] (hf : summable f) (hg : summable g) (hfg : summable (λ (x : ℕ × ℕ), f x.fst * g x.snd)) : (∑' (n : ℕ), f n) * ∑' (n : ℕ), g n = ∑' (n : ℕ), (finset.nat.antidiagonal n).sum (λ (kl : ℕ × ℕ), f kl.fst * g kl.snd)
theorem range.is_add_submonoid {M : Type u_1} [add_monoid M] {γ : Type u_2} [add_monoid γ] {f : M → γ} (hf : is_add_monoid_hom f) : is_add_submonoid (set.range f)
theorem interval_integral.integral_eq_sub_of_has_deriv_at {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} {f' : ℝ → E} (hderiv : ∀ (x : ℝ), x ∈ set.interval a b → has_deriv_at f (f' x) x) (hint : interval_integrable f' measure_theory.measure_space.volume a b) : ∫ (y : ℝ) in a..b, f' y = f b - f a
theorem measurable_set.exists_is_compact_diff_lt {α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [opens_measurable_space α] [t2_space α] [μ.regular] ⦃A : set α⦄ (hA : measurable_set A) (h'A : ⇑μ A ≠ ⊤) {ε : ennreal} (hε : ε ≠ 0) : ∃ (K : set α) (H : K ⊆ A), is_compact K ∧ ⇑μ (A  K) < ε
theorem dense_range.subset_closure_image_preimage_of_is_open {β : Type u_2} [topological_space β] {κ : Type u_5} {f : κ → β} (hf : dense_range f) {s : set β} (hs : is_open s) : s ⊆ closure (f '' (f ⁻¹' s))
theorem add_action.stabilizer_vadd_eq_stabilizer_map_conj {α : Type u} {β : Type v} [add_group α] [add_action α β] (g : α) (x : β) : add_action.stabilizer α (g +ᵥ x) = add_subgroup.map (add_equiv.to_add_monoid_hom (⇑add_aut.conj g)) (add_action.stabilizer α x)
theorem filter.map_map₂_distrib_right {α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {m : α → β → γ} {f : filter α} {g : filter β} {n : γ → δ} {m' : α → β' → δ} {n' : β → β'} (h_distrib : ∀ (a : α) (b : β), n (m a b) = m' a (n' b)) : filter.map n (filter.map₂ m f g) = filter.map₂ m' f (filter.map n' g)
theorem category_theory.presieve.is_sheaf_for_iff_generate {C : Type u₁} [category_theory.category C] {P : Cᵒᵖ ⥤ Type w} {X : C} (R : category_theory.presieve X) : category_theory.presieve.is_sheaf_for P R ↔ category_theory.presieve.is_sheaf_for P ⇑(category_theory.sieve.generate R)
theorem acc.of_fibration {α : Type u_1} {β : Type u_2} {rα : α → α → Prop} {rβ : β → β → Prop} (f : α → β) (fib : relation.fibration rα rβ f) {a : α} (ha : acc rα a) : acc rβ (f a)
theorem affine.simplex.orthogonal_projection_circumcenter {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P n) {fs : finset (fin (n + 1))} {m : ℕ} (h : fs.card = m + 1) : ↑(⇑((s.face h).orthogonal_projection_span) s.circumcenter) = (s.face h).circumcenter
theorem map_le_line_map_iff_slope_le_slope {k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k → E} {a b r : k} (hab : a < b) (h₀ : 0 < r) (h₁ : r < 1) : f (⇑(affine_map.line_map a b) r) ≤ ⇑(affine_map.line_map (f a) (f b)) r ↔ slope f a (⇑(affine_map.line_map a b) r) ≤ slope f (⇑(affine_map.line_map a b) r) b
theorem convex_hull_basis_eq_std_simplex {R : Type u_1} (ι : Type u_4) [linear_ordered_field R] [fintype ι] : ⇑(convex_hull R) (set.range (λ (i j : ι), ite (i = j) 1 0)) = std_simplex R ι
theorem commute.eq {S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : a * b = b * a
theorem nnreal.rpow_arith_mean_le_arith_mean2_rpow (w₁ w₂ z₁ z₂ : nnreal) (hw' : w₁ + w₂ = 1) {p : ℝ} (hp : 1 ≤ p) : (w₁ * z₁ + w₂ * z₂) ^ p ≤ w₁ * z₁ ^ p + w₂ * z₂ ^ p
theorem euclidean_geometry.inner_weighted_vsub {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {ι₁ : Type u_3} {s₁ : finset ι₁} {w₁ : ι₁ → ℝ} (p₁ : ι₁ → P) (h₁ : s₁.sum (λ (i : ι₁), w₁ i) = 0) {ι₂ : Type u_4} {s₂ : finset ι₂} {w₂ : ι₂ → ℝ} (p₂ : ι₂ → P) (h₂ : s₂.sum (λ (i : ι₂), w₂ i) = 0) : has_inner.inner (⇑(s₁.weighted_vsub p₁) w₁) (⇑(s₂.weighted_vsub p₂) w₂) = -s₁.sum (λ (i₁ : ι₁), s₂.sum (λ (i₂ : ι₂), w₁ i₁ * w₂ i₂ * (has_dist.dist (p₁ i₁) (p₂ i₂) * has_dist.dist (p₁ i₁) (p₂ i₂)))) / 2
theorem finprod_mem_bUnion {α : Type u_1} {ι : Type u_3} {M : Type u_5} [comm_monoid M] {f : α → M} {I : set ι} {t : ι → set α} (h : I.pairwise_disjoint t) (hI : I.finite) (ht : ∀ (i : ι), i ∈ I → (t i).finite) : finprod (λ (a : α), finprod (λ (H : a ∈ ⋃ (x : ι) (H : x ∈ I), t x), f a)) = finprod (λ (i : ι), finprod (λ (H : i ∈ I), finprod (λ (j : α), finprod (λ (H : j ∈ t i), f j))))
theorem padic_norm_e.nonarchimedean' {p : ℕ} [fact (nat.prime p)] (q r : ℚ_[p]) : padic_norm_e (q + r) ≤ linear_order.max (padic_norm_e q) (padic_norm_e r)
theorem complex.det_conj_lie  : ⇑linear_map.det ↑(complex.conj_lie.to_linear_equiv) = -1
theorem add_hom.coe_inj {M : Type u_3} {N : Type u_4} [has_add M] [has_add N] ⦃f g : add_hom M N⦄ (h : ⇑f = ⇑g) : f = g
theorem measure_theory.lintegral_add_left_eq_self {G : Type u_4} [measurable_space G] {μ : measure_theory.measure G} [add_group G] [has_measurable_add G] [μ.is_add_left_invariant] (f : G → ennreal) (g : G) : ∫⁻ (x : G), f (g + x) ∂μ = ∫⁻ (x : G), f x ∂μ
theorem euclidean_geometry.dist_reflection_eq_of_mem {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ℝ P) [nonempty ↥s] [complete_space ↥(s.direction)] {p₁ : P} (hp₁ : p₁ ∈ s) (p₂ : P) : has_dist.dist p₁ (⇑(euclidean_geometry.reflection s) p₂) = has_dist.dist p₁ p₂
theorem phragmen_lindelof.quadrant_I {E : Type u_1} [normed_group E] [normed_space ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ} (hd : diff_cont_on_cl ℂ f (set.Ioi 0 ×ℂ set.Ioi 0)) (hB : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ filter.principal (set.Ioi 0 ×ℂ set.Ioi 0)] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hre : ∀ (x : ℝ), 0 ≤ x → ∥f ↑x∥ ≤ C) (him : ∀ (x : ℝ), 0 ≤ x → ∥f (↑x * complex.I)∥ ≤ C) (hz_re : 0 ≤ z.re) (hz_im : 0 ≤ z.im) : ∥f z∥ ≤ C
theorem add_con.map_of_surjective_eq_map_gen {M : Type u_1} {N : Type u_2} [has_add M] [has_add N] {c : add_con M} {f : M → N} (H : ∀ (x y : M), f (x + y) = f x + f y) (h : add_con.add_ker f H ≤ c) (hf : function.surjective f) : c.map_gen f = c.map_of_surjective f H h hf
theorem polynomial.exists_partition_polynomial_aux {Fq : Type u_1} [fintype Fq] [field Fq] (n : ℕ) {ε : ℝ} (hε : 0 < ε) {b : polynomial Fq} (hb : b ≠ 0) (A : fin n → polynomial Fq) : ∃ (t : fin n → fin (fintype.card Fq ^ ⌈-real.log ε / real.log ↑(fintype.card Fq)⌉₊)), ∀ (i₀ i₁ : fin n), t i₀ = t i₁ ↔ ↑(⇑polynomial.card_pow_degree (A i₁ % b - A i₀ % b)) < ⇑polynomial.card_pow_degree b • ε
theorem polynomial.mem_lifts_and_degree_eq {R : Type u} [semiring R] {S : Type v} [semiring S] {f : R →+* S} {p : polynomial S} (hlifts : p ∈ polynomial.lifts f) : ∃ (q : polynomial R), polynomial.map f q = p ∧ q.degree = p.degree
theorem nat.dvd_left_injective  : function.injective has_dvd.dvd
theorem weak_dual.is_closed_image_polar_of_mem_nhds (𝕜 : Type u_1) [nondiscrete_normed_field 𝕜] {E : Type u_2} [semi_normed_group E] [normed_space 𝕜 E] {s : set E} (s_nhd : s ∈ nhds 0) : is_closed (coe_fn '' weak_dual.polar 𝕜 s)
theorem multiset.map_count_true_eq_filter_card {α : Type u_1} (s : multiset α) (p : α → Prop) [decidable_pred p] : multiset.count true (multiset.map p s) = ⇑multiset.card (multiset.filter p s)
theorem strict_convex.ord_connected {𝕜 : Type u_1} [linear_ordered_field 𝕜] [topological_space 𝕜] [order_topology 𝕜] {s : set 𝕜} : strict_convex 𝕜 s → s.ord_connected
theorem rack.ad_conj {R : Type u_1} [rack R] (x y : R) : rack.act (shelf.act x y) = rack.act x * rack.act y * (rack.act x)⁻¹
theorem map_supr_of_continuous_at_of_monotone' {α : Type u} {β : Type v} [complete_linear_order α] [topological_space α] [order_topology α] [complete_linear_order β] [topological_space β] [order_topology β] {ι : Sort u_1} [nonempty ι] {f : α → β} {g : ι → α} (Cf : continuous_at f (supr g)) (Mf : monotone f) : f (⨆ (i : ι), g i) = ⨆ (i : ι), f (g i)
theorem list.eq_nil_of_suffix_nil {α : Type u_1} {l : list α} : l <:+ list.nil → l = list.nil
theorem module.ray.linear_equiv_smul_eq_map {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (e : M ≃ₗ[R] M) (v : module.ray R M) : e • v = ⇑(module.ray.map e) v
theorem seq_closure_subset_closure {X : Type u_1} [topological_space X] (s : set X) : seq_closure s ⊆ closure s
theorem add_monoid.fg_iff {M : Type u_1} [add_monoid M] : add_monoid.fg M ↔ ∃ (S : set M), add_submonoid.closure S = ⊤ ∧ S.finite
theorem category_theory.is_filtered.of_is_right_adjoint {C : Type u} [category_theory.category C] [category_theory.is_filtered C] {D : Type u₁} [category_theory.category D] (R : C ⥤ D) [category_theory.is_right_adjoint R] : category_theory.is_filtered D
theorem dense_range.quotient {α : Type u} {β : Type v} [setoid α] [topological_space α] {f : β → α} (hf : dense_range f) : dense_range (quotient.mk ∘ f)
theorem Kuratowski_embedding.embedding_of_subset_isometry {α : Type u} [metric_space α] (x : ℕ → α) (H : dense_range x) : isometry (Kuratowski_embedding.embedding_of_subset x)
theorem add_pos_of_nonneg_of_pos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 ≤ a) (hb : 0 < b) : 0 < a + b
theorem mul_add_mul_lt_mul_add_mul' {α : Type u} [ordered_semiring α] {a b c d : α} [has_exists_add_of_le α] (hba : b < a) (hdc : d < c) : a • d + b • c < a • c + b • d
theorem set.finite.bdd_below {α : Type u} [semilattice_inf α] [nonempty α] {s : set α} (hs : s.finite) : bdd_below s
theorem max_chain_spec {α : Type u_1} {r : α → α → Prop} : is_max_chain r (max_chain r)
theorem polynomial.is_primitive.int.irreducible_iff_irreducible_map_cast {p : polynomial ℤ} (hp : p.is_primitive) : irreducible p ↔ irreducible (polynomial.map (int.cast_ring_hom ℚ) p)
theorem list.chain.induction_head {α : Type u} {r : α → α → Prop} {a b : α} (p : α → Prop) (l : list α) (h : list.chain r a l) (hb : (a :: l).last _ = b) (carries : ∀ ⦃x y : α⦄, r x y → p y → p x) (final : p b) : p a
theorem strict_concave_on_open_of_deriv2_neg {D : set ℝ} (hD : convex ℝ D) (hD₂ : is_open D) {f : ℝ → ℝ} (hf' : differentiable_on ℝ f D) (hf'' : ∀ (x : ℝ), x ∈ D → deriv^[2] f x < 0) : strict_concave_on ℝ D f
theorem is_compact.elim_finite_subcover {α : Type u} [topological_space α] {s : set α} {ι : Type v} (hs : is_compact s) (U : ι → set α) (hUo : ∀ (i : ι), is_open (U i)) (hsU : s ⊆ ⋃ (i : ι), U i) : ∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i
theorem relation.church_rosser {α : Type u_1} {r : α → α → Prop} {a b c : α} (h : ∀ (a b c : α), r a b → r a c → (∃ (d : α), relation.refl_gen r b d ∧ relation.refl_trans_gen r c d)) (hab : relation.refl_trans_gen r a b) (hac : relation.refl_trans_gen r a c) : relation.join (relation.refl_trans_gen r) b c
theorem metric.dist_le_diam_of_mem {α : Type u} [pseudo_metric_space α] {s : set α} {x y : α} (h : metric.bounded s) (hx : x ∈ s) (hy : y ∈ s) : has_dist.dist x y ≤ metric.diam s
theorem convex.subset_interior_image_homothety_of_one_lt {E : Type u_2} [add_comm_group E] [module ℝ E] [topological_space E] [topological_add_group E] [has_continuous_smul ℝ E] {s : set E} (hs : convex ℝ s) {x : E} (hx : x ∈ interior s) (t : ℝ) (ht : 1 < t) : s ⊆ interior (⇑(affine_map.homothety x t) '' s)
theorem multilinear_map.comp_linear_equiv_eq_zero_iff {R : Type u} {ι : Type u'} {M₁ : ι → Type v₁} {M₂ : Type v₂} [decidable_eq ι] [semiring R] [Π (i : ι), add_comm_monoid (M₁ i)] [add_comm_monoid M₂] [Π (i : ι), module R (M₁ i)] [module R M₂] {M₁' : ι → Type u_1} [Π (i : ι), add_comm_monoid (M₁' i)] [Π (i : ι), module R (M₁' i)] (g : multilinear_map R M₁' M₂) (f : Π (i : ι), M₁ i ≃ₗ[R] M₁' i) : g.comp_linear_map (λ (i : ι), ↑(f i)) = 0 ↔ g = 0
theorem Top.presheaf.is_sheaf_opens_le_cover_iff_is_sheaf_pairwise_intersections {C : Type u} [category_theory.category C] {X : Top} (F : Top.presheaf C X) : F.is_sheaf_opens_le_cover ↔ F.is_sheaf_pairwise_intersections
theorem finsupp.add_hom_ext' {α : Type u_1} {M : Type u_5} {N : Type u_7} [add_zero_class M] [add_zero_class N] ⦃f g : (α →₀ M) →+ N⦄ (H : ∀ (x : α), f.comp (finsupp.single_add_hom x) = g.comp (finsupp.single_add_hom x)) : f = g
theorem bump_covering.exists_is_subordinate_of_locally_finite_of_prop {ι : Type u} {X : Type v} [topological_space X] {s : set X} [normal_space X] (p : (X → ℝ) → Prop) (h01 : ∀ (s t : set X), is_closed s → is_closed t → disjoint s t → (∃ (f : C(X, ℝ)), p ⇑f ∧ set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1)) (hs : is_closed s) (U : ι → set X) (ho : ∀ (i : ι), is_open (U i)) (hf : locally_finite U) (hU : s ⊆ ⋃ (i : ι), U i) : ∃ (f : bump_covering ι X s), (∀ (i : ι), p ⇑(⇑f i)) ∧ f.is_subordinate U
theorem metric.nonempty_Inter_of_nonempty_bInter {α : Type u} [pseudo_metric_space α] [complete_space α] {s : ℕ → set α} (hs : ∀ (n : ℕ), is_closed (s n)) (h's : ∀ (n : ℕ), metric.bounded (s n)) (h : ∀ (N : ℕ), (⋂ (n : ℕ) (H : n ≤ N), s n).nonempty) (h' : filter.tendsto (λ (n : ℕ), metric.diam (s n)) filter.at_top (nhds 0)) : (⋂ (n : ℕ), s n).nonempty
theorem add_mul {R : Type x} [has_mul R] [has_add R] [right_distrib_class R] (a b c : R) : (a + b) * c = a * c + b * c
theorem equiv.perm.cycle_factors_finset_noncomm_prod {α : Type u_1} [decidable_eq α] [fintype α] (f : equiv.perm α) (comm : (∀ (g : equiv.perm α), g ∈ f.cycle_factors_finset → ∀ (h : equiv.perm α), h ∈ f.cycle_factors_finset → commute (id g) (id h)) := _) : f.cycle_factors_finset.noncomm_prod id comm = f
theorem lie_ideal.comap_map_le {R : Type u} {L : Type v} {L' : Type w₂} [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] {f : L →ₗ⁅R⁆ L'} {I : lie_ideal R L} : I ≤ lie_ideal.comap f (lie_ideal.map f I)
theorem norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero {F : Type u_3} [inner_product_space ℝ F] (x y : F) : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ ↔ has_inner.inner x y = 0
theorem zero_lt.left.mul_lt_one_of_lt_of_le {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : a < 1) (hb : b ≤ 1) (a0 : 0 < a) : a * b < 1
theorem has_subset.subset.ssubset_of_not_subset {α : Type u} [has_subset α] [has_ssubset α] [is_nonstrict_strict_order α has_subset.subset has_ssubset.ssubset] {a b : α} (h₁ : a ⊆ b) (h₂ : ¬b ⊆ a) : a ⊂ b
theorem exists_multiset_prod_cons_le_and_prod_not_le {A : Type u_2} [comm_ring A] [is_domain A] [is_dedekind_domain A] (hNF : ¬is_field A) {I M : ideal A} (hI0 : I ≠ ⊥) (hIM : I ≤ M) [hM : M.is_maximal] : ∃ (Z : multiset (prime_spectrum A)), (M ::ₘ multiset.map prime_spectrum.as_ideal Z).prod ≤ I ∧ ¬(multiset.map prime_spectrum.as_ideal Z).prod ≤ I
theorem finprod_mem_eq_of_bij_on {α : Type u_1} {β : Type u_2} {M : Type u_5} [comm_monoid M] {s : set α} {t : set β} {f : α → M} {g : β → M} (e : α → β) (he₀ : set.bij_on e s t) (he₁ : ∀ (x : α), x ∈ s → f x = g (e x)) : finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) = finprod (λ (j : β), finprod (λ (H : j ∈ t), g j))
theorem witt_vector.frobenius_is_poly (p : ℕ) [hp : fact (nat.prime p)] : witt_vector.is_poly p (λ (R : Type u_1) (_Rcr : comm_ring R), ⇑witt_vector.frobenius)
theorem padic_val_rat.le_padic_val_rat_add_of_le (p : ℕ) [p_prime : fact (nat.prime p)] {q r : ℚ} (hqr : q + r ≠ 0) (h : padic_val_rat p q ≤ padic_val_rat p r) : padic_val_rat p q ≤ padic_val_rat p (q + r)
theorem is_top.of_dual {α : Type u_1} [has_le α] {a : αᵒᵈ} : is_top a → is_bot (⇑order_dual.of_dual a)
theorem fintype.eq_of_subsingleton_of_prod_eq {M : Type u_4} [comm_monoid M] {ι : Type u_1} [subsingleton ι] {s : finset ι} {f : ι → M} {b : M} (h : s.prod (λ (i : ι), f i) = b) (i : ι) (H : i ∈ s) : f i = b
theorem real.mul_le_sin {x : ℝ} (hx : 0 ≤ x) (hx' : x ≤ real.pi / 2) : 2 / real.pi * x ≤ real.sin x
theorem orthogonal_projection_mem_subspace_eq_self {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K : submodule 𝕜 E} [complete_space ↥K] (v : ↥K) : ⇑(orthogonal_projection K) ↑v = v
theorem affine_independent.subtype {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} {p : ι → P} (ha : affine_independent k p) (s : set ι) : affine_independent k (λ (i : ↥s), p ↑i)
theorem quotient_add_group.add_monoid_hom_ext {G : Type u} [add_group G] (N : add_subgroup G) [nN : N.normal] {H : Type v} [add_group H] ⦃f g : G ⧸ N →+ H⦄ (h : f.comp (quotient_add_group.mk' N) = g.comp (quotient_add_group.mk' N)) : f = g
theorem metric.mem_thickening_iff {δ : ℝ} {X : Type u} [pseudo_metric_space X] {E : set X} {x : X} : x ∈ metric.thickening δ E ↔ ∃ (z : X) (H : z ∈ E), has_dist.dist x z < δ
theorem interval_integral.integral_comp_smul_deriv'' {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {a b : ℝ} {f f' : ℝ → ℝ} {g : ℝ → E} (hf : continuous_on f (set.interval a b)) (hff' : ∀ (x : ℝ), x ∈ set.Ioo (linear_order.min a b) (linear_order.max a b) → has_deriv_within_at f (f' x) (set.Ioi x) x) (hf' : continuous_on f' (set.interval a b)) (hg : continuous_on g (f '' set.interval a b)) : ∫ (x : ℝ) in a..b, f' x • (g ∘ f) x = ∫ (u : ℝ) in f a..f b, g u
theorem Module.homology_ext {R : Type v} [ring R] {L M N K : Module R} {f : L ⟶ M} {g : M ⟶ N} (w : f ≫ g = 0) {h k : homology f g w ⟶ K} (w_1 : ∀ (x : ↥(linear_map.ker g)), ⇑h (⇑(category_theory.limits.cokernel.π (image_to_kernel f g w)) (⇑Module.to_kernel_subobject x)) = ⇑k (⇑(category_theory.limits.cokernel.π (image_to_kernel f g w)) (⇑Module.to_kernel_subobject x))) : h = k
theorem padic_val_rat.of_nat {p n : ℕ} : padic_val_rat p ↑n = ↑(padic_val_nat p n)
theorem orthonormal.rotation_pi {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) : hb.rotation ↑real.pi = linear_isometry_equiv.neg ℝ
theorem category_theory.limits.has_limits_of_shape_op_of_has_colimits_of_shape {C : Type u₁} [category_theory.category C] {J : Type u₂} [category_theory.category J] [category_theory.limits.has_colimits_of_shape Jᵒᵖ C] : category_theory.limits.has_limits_of_shape J Cᵒᵖ
theorem minpoly.root {A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) {y : A} (h : (minpoly A x).is_root y) : ⇑(algebra_map A B) y = x
theorem structure_groupoid.compatible_of_mem_maximal_atlas {H : Type u} {M : Type u_2} [topological_space H] [topological_space M] [charted_space H M] {G : structure_groupoid H} {e e' : local_homeomorph M H} (he : e ∈ structure_groupoid.maximal_atlas M G) (he' : e' ∈ structure_groupoid.maximal_atlas M G) : e.symm.trans e' ∈ G
theorem is_max.to_dual {α : Type u_1} [has_le α] {a : α} : is_max a → is_min (⇑order_dual.to_dual a)
theorem category_theory.functor.initial.has_limit_of_comp {C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ⥤ D) [F.initial] {E : Type u} [category_theory.category E] {G : D ⥤ E} [category_theory.limits.has_limit (F ⋙ G)] : category_theory.limits.has_limit G
theorem measure_theory.outer_measure.null_of_locally_null {α : Type u_1} [topological_space α] [topological_space.second_countable_topology α] (m : measure_theory.outer_measure α) (s : set α) (hs : ∀ (x : α), x ∈ s → (∃ (u : set α) (H : u ∈ nhds_within x s), ⇑m u = 0)) : ⇑m s = 0
theorem asymptotics.is_o.of_is_O_with {α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : α → E} {g : α → F} {l : filter α} : (∀ ⦃c : ℝ⦄, 0 < c → asymptotics.is_O_with c l f g) → f =o[l] g
theorem exists_lt_of_lt_csupr {α : Type u_1} {ι : Sort u_3} [conditionally_complete_linear_order α] {b : α} [nonempty ι] {f : ι → α} (h : b < supr f) : ∃ (i : ι), b < f i
theorem is_open_analytic_at (𝕜 : Type u_1) {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] [complete_space F] (f : E → F) : is_open {x : E | analytic_at 𝕜 f x}
theorem equiv.perm.swap_induction_on {α : Type u} [decidable_eq α] [fintype α] {P : equiv.perm α → Prop} (f : equiv.perm α) : P 1 → (∀ (f : equiv.perm α) (x y : α), x ≠ y → P f → P (equiv.swap x y * f)) → P f
theorem mul_hom.coe_inj {M : Type u_3} {N : Type u_4} [has_mul M] [has_mul N] ⦃f g : M →ₙ* N⦄ (h : ⇑f = ⇑g) : f = g
theorem is_preconnected_Icc {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {a b : α} : is_preconnected (set.Icc a b)
theorem exists_local_extr_Ioo (f : ℝ → ℝ) {a b : ℝ} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hfI : f a = f b) : ∃ (c : ℝ) (H : c ∈ set.Ioo a b), is_local_extr f c
theorem subgroup.normalizer_condition.normal_of_coatom {G : Type u_1} [group G] (H : subgroup G) (hnc : normalizer_condition G) (hmax : is_coatom H) : H.normal
theorem submonoid.localization_map.map_map {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M →* P} {T : submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ T) {Q : Type u_4} [comm_monoid Q] {k : T.localization_map Q} {A : Type u_5} [comm_monoid A] {U : submonoid A} {R : Type u_6} [comm_monoid R] (j : U.localization_map R) {l : P →* A} (hl : ∀ (w : ↥T), ⇑l ↑w ∈ U) (x : N) : ⇑(k.map hl j) (⇑(f.map hy k) x) = ⇑(f.map _ j) x
theorem order.pfilter.ext {P : Type u_1} [preorder P] (s t : order.pfilter P) (h : ↑s = ↑t) : s = t
theorem inv_le {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ ≤ b ↔ b⁻¹ ≤ a
theorem submodule.coe_sum {R : Type u} {M : Type v} {ι : Type w} [semiring R] [add_comm_monoid M] {module_M : module R M} (p : submodule R M) (x : ι → ↥p) (s : finset ι) : ↑(s.sum (λ (i : ι), x i)) = s.sum (λ (i : ι), ↑(x i))
theorem measure_theory.integral_divergence_of_has_fderiv_within_at_off_countable_aux₁ {E : Type u} [normed_group E] [normed_space ℝ E] [complete_space E] {n : ℕ} (I : box_integral.box (fin (n + 1))) (f : (fin (n + 1) → ℝ) → fin (n + 1) → E) (f' : (fin (n + 1) → ℝ) → ((fin (n + 1) → ℝ) →L[ℝ] fin (n + 1) → E)) (s : set (fin (n + 1) → ℝ)) (hs : s.countable) (Hc : continuous_on f (⇑box_integral.box.Icc I)) (Hd : ∀ (x : fin (n + 1) → ℝ), x ∈ ⇑box_integral.box.Icc I  s → has_fderiv_within_at f (f' x) (⇑box_integral.box.Icc I) x) (Hi : measure_theory.integrable_on (λ (x : fin (n + 1) → ℝ), finset.univ.sum (λ (i : fin (n + 1)), ⇑(f' x) (pi.single i 1) i)) (⇑box_integral.box.Icc I) measure_theory.measure_space.volume) : ∫ (x : fin (n + 1) → ℝ) in ⇑box_integral.box.Icc I, finset.univ.sum (λ (i : fin (n + 1)), ⇑(f' x) (pi.single i 1) i) = finset.univ.sum (λ (i : fin (n + 1)), (∫ (x : fin n → ℝ) in ⇑box_integral.box.Icc (I.face i), f (i.insert_nth (I.upper i) x) i) - ∫ (x : fin n → ℝ) in ⇑box_integral.box.Icc (I.face i), f (i.insert_nth (I.lower i) x) i)
theorem reflection_symm {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K : submodule 𝕜 E} [complete_space ↥K] : (reflection K).symm = reflection K
theorem mul_mem_class.mul_left_mem_add_closure {M : Type u_1} {R : Type u_4} [non_unital_non_assoc_semiring R] [set_like M R] [mul_mem_class M R] {S : M} {a b : R} (ha : a ∈ S) (hb : b ∈ add_submonoid.closure ↑S) : a * b ∈ add_submonoid.closure ↑S
theorem galois_connection.exists_eq_u {α : Type u} {β : Type v} [partial_order α] [preorder β] {l : α → β} {u : β → α} (gc : galois_connection l u) (a : α) : (∃ (b : β), a = u b) ↔ a = u (l a)
theorem submodule.supr_induction' {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] {ι : Sort u_2} (p : ι → submodule R M) {C : Π (x : M), (x ∈ ⨆ (i : ι), p i) → Prop} (hp : ∀ (i : ι) (x : M) (H : x ∈ p i), C x _) (h0 : C 0 _) (hadd : ∀ (x y : M) (hx : x ∈ ⨆ (i : ι), p i) (hy : y ∈ ⨆ (i : ι), p i), C x hx → C y hy → C (x + y) _) {x : M} (hx : x ∈ ⨆ (i : ι), p i) : C x hx
theorem box_integral.prepartition.exists_Union_eq_diff {ι : Type u_1} {I : box_integral.box ι} [fintype ι] (π : box_integral.prepartition I) : ∃ (π' : box_integral.prepartition I), π'.Union = ↑I  π.Union
theorem apply_ite2 {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} (f : α → β → γ) (P : Prop) [decidable P] (a b : α) (c d : β) : f (ite P a b) (ite P c d) = ite P (f a c) (f b d)
theorem path.continuous_extend {X : Type u_1} [topological_space X] {x y : X} (γ : path x y) : continuous γ.extend
theorem strict_concave_on.lt_on_open_segment {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [linear_ordered_add_comm_monoid β] [has_scalar 𝕜 E] [module 𝕜 β] [ordered_smul 𝕜 β] {s : set E} {f : E → β} (hf : strict_concave_on 𝕜 s f) {x y z : E} (hx : x ∈ s) (hy : y ∈ s) (hxy : x ≠ y) (hz : z ∈ open_segment 𝕜 x y) : linear_order.min (f x) (f y) < f z
theorem category_theory.exponential_ideal.mk' {C : Type u₁} {D : Type u₂} [category_theory.category C] [category_theory.category D] (i : D ⥤ C) [category_theory.limits.has_finite_products C] [category_theory.cartesian_closed C] (h : ∀ (B : D) (A : C), (category_theory.exp A).obj (i.obj B) ∈ i.ess_image) : category_theory.exponential_ideal i
theorem left.add_nonneg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a + b
theorem measure_theory.outer_measure.restrict_trim {α : Type u_1} [measurable_space α] {μ : measure_theory.outer_measure α} {s : set α} (hs : measurable_set s) : (⇑(measure_theory.outer_measure.restrict s) μ).trim = ⇑(measure_theory.outer_measure.restrict s) μ.trim
theorem set.range_unique {α : Type u} {ι : Sort x} {f : ι → α} [h : unique ι] : set.range f = {f inhabited.default}
theorem finite_dimensional.finrank_pos_iff {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V ↔ nontrivial V
theorem add_hom.map_mclosure {M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) (s : set M) : add_subsemigroup.map f (add_subsemigroup.closure s) = add_subsemigroup.closure (⇑f '' s)
theorem real.map_linear_map_volume_pi_eq_smul_volume_pi {ι : Type u_1} [fintype ι] {f : (ι → ℝ) →ₗ[ℝ] ι → ℝ} (hf : ⇑linear_map.det f ≠ 0) : measure_theory.measure.map ⇑f measure_theory.measure_space.volume = ennreal.of_real |(⇑linear_map.det f)⁻¹| • measure_theory.measure_space.volume
theorem multiset.nat.mem_antidiagonal {n : ℕ} {x : ℕ × ℕ} : x ∈ multiset.nat.antidiagonal n ↔ x.fst + x.snd = n
theorem monoid_hom.map_finprod_mem {α : Type u_1} {M : Type u_5} {N : Type u_6} [comm_monoid M] [comm_monoid N] {s : set α} (f : α → M) (g : M →* N) (hs : s.finite) : ⇑g (finprod (λ (j : α), finprod (λ (H : j ∈ s), f j))) = finprod (λ (i : α), finprod (λ (H : i ∈ s), ⇑g (f i)))
theorem orthonormal.eq_iff_oangle_eq_zero_of_norm_eq {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y : V} (h : ∥x∥ = ∥y∥) : x = y ↔ hb.oangle x y = 0
theorem measure_theory.measure.restrict_union_congr {α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} {s t : set α} : μ.restrict (s ∪ t) = ν.restrict (s ∪ t) ↔ μ.restrict s = ν.restrict s ∧ μ.restrict t = ν.restrict t
theorem orthonormal.linear_equiv_det_rotation {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (θ : real.angle) : ⇑linear_equiv.det (hb.rotation θ).to_linear_equiv = 1
theorem measure_theory.bounded_continuous_function.inner_to_Lp {α : Type u_1} [topological_space α] [measure_theory.measure_space α] [borel_space α] {𝕜 : Type u_2} [is_R_or_C 𝕜] (μ : measure_theory.measure α) [measure_theory.is_finite_measure μ] (f g : bounded_continuous_function α 𝕜) : has_inner.inner (⇑(bounded_continuous_function.to_Lp 2 μ 𝕜) f) (⇑(bounded_continuous_function.to_Lp 2 μ 𝕜) g) = ∫ (x : α), ⇑(star_ring_end 𝕜) (⇑f x) * ⇑g x ∂μ
theorem vsub_add_vsub_cancel {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p1 p2 p3 : P) : p1 -ᵥ p2 + (p2 -ᵥ p3) = p1 -ᵥ p3
theorem finsupp.prod_add_index {α : Type u_1} {M : Type u_5} {N : Type u_7} [add_zero_class M] [comm_monoid N] {f g : α →₀ M} {h : α → M → N} (h_zero : ∀ (a : α), a ∈ f.support ∪ g.support → h a 0 = 1) (h_add : ∀ (a : α), a ∈ f.support ∪ g.support → ∀ (b₁ b₂ : M), h a (b₁ + b₂) = h a b₁ * h a b₂) : (f + g).prod h = f.prod h * g.prod h
theorem is_primitive_root.sub_one_norm_is_prime_pow {n : ℕ+} {K : Type u} {L : Type v} [field L] {ζ : L} (hζ : is_primitive_root ζ ↑n) [field K] [algebra K L] [ne_zero ↑↑n] (hn : is_prime_pow ↑n) [is_cyclotomic_extension {n} K L] (hirr : irreducible (polynomial.cyclotomic ↑n K)) (h : n ≠ 2) : ⇑(algebra.norm K) (ζ - 1) = ↑(↑n.min_fac)
theorem ordinal.bdd_above_range {ι : Type u} (f : ι → ordinal) : bdd_above (set.range f)
theorem neg_vsub_eq_vsub_rev {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p1 p2 : P) : -(p1 -ᵥ p2) = p2 -ᵥ p1
theorem set.mem_of_mul_indicator_ne_one {α : Type u_1} {M : Type u_4} [has_one M] {s : set α} {f : α → M} {a : α} (h : s.mul_indicator f a ≠ 1) : a ∈ s
theorem antitone.map_is_greatest {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} (hf : antitone f) {a : α} {s : set α} : is_greatest s a → is_least (f '' s) (f a)
theorem cardinal.ord_aleph'_eq_enum_card  : cardinal.ord ∘ cardinal.aleph' = ordinal.enum_ord {b : ordinal | b.card.ord = b}
theorem mv_polynomial.exists_finset_rename {σ : Type u_1} {R : Type u_4} [comm_semiring R] (p : mv_polynomial σ R) : ∃ (s : finset σ) (q : mv_polynomial {x // x ∈ s} R), p = ⇑(mv_polynomial.rename coe) q
theorem is_extr_filter.undual {α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α} : is_extr_filter (⇑order_dual.to_dual ∘ f) l a → is_extr_filter f l a
theorem nat.totient_div_of_dvd {n d : ℕ} (hnd : d ∣ n) : (n / d).totient = (finset.filter (λ (k : ℕ), n.gcd k = d) (finset.range n)).card
theorem mul_dvd_mul_iff_right {α : Type u_1} [cancel_comm_monoid_with_zero α] {a b c : α} (hc : c ≠ 0) : a * c ∣ b * c ↔ a ∣ b
theorem finset.image_image₂_distrib_right {α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} [decidable_eq β'] [decidable_eq γ] [decidable_eq δ] {f : α → β → γ} {s : finset α} {t : finset β} {g : γ → δ} {f' : α → β' → δ} {g' : β → β'} (h_distrib : ∀ (a : α) (b : β), g (f a b) = f' a (g' b)) : finset.image g (finset.image₂ f s t) = finset.image₂ f' s (finset.image g' t)
theorem measurable_measure_prod_mk_right {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} [measure_theory.sigma_finite μ] {s : set (α × β)} (hs : measurable_set s) : measurable (λ (y : β), ⇑μ ((λ (x : α), (x, y)) ⁻¹' s))
theorem measure_theory.add_haar_image_eq_zero_of_det_fderiv_within_eq_zero_aux {E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {s : set E} {f : E → E} {f' : E → (E →L[ℝ] E)} [measurable_space E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (hf' : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (R : ℝ) (hs : s ⊆ metric.closed_ball 0 R) (ε : nnreal) (εpos : 0 < ε) (h'f' : ∀ (x : E), x ∈ s → (f' x).det = 0) : ⇑μ (f '' s) ≤ ↑ε * ⇑μ (metric.closed_ball 0 R)
theorem extend_partial_order {α : Type u} (r : α → α → Prop) [is_partial_order α r] : ∃ (s : α → α → Prop) (_x : is_linear_order α s), r ≤ s
theorem antitone_on.map_is_least {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {t : set α} (Hf : antitone_on f t) {a : α} : is_least t a → is_greatest (f '' t) (f a)
theorem commute.mul_right {S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) : commute a (b * c)
theorem circle_deg1_lift.exists_eq_add_translation_number (f : circle_deg1_lift) (hf : continuous ⇑f) : ∃ (x : ℝ), ⇑f x = x + f.translation_number
theorem is_greatest.cSup_eq {α : Type u_1} [conditionally_complete_lattice α] {s : set α} {a : α} (H : is_greatest s a) : has_Sup.Sup s = a
theorem collinear_singleton (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) : collinear k {p}
theorem mk_complex  : cardinal.mk ℂ = cardinal.continuum
theorem measure_theory.measure.finite_at_filter.of_inf_ae {α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {f : filter α} : μ.finite_at_filter (f ⊓ μ.ae) → μ.finite_at_filter f
theorem subfield.closure_induction {K : Type u} [field K] {s : set K} {p : K → Prop} {x : K} (h : x ∈ subfield.closure s) (Hs : ∀ (x : K), x ∈ s → p x) (H1 : p 1) (Hadd : ∀ (x y : K), p x → p y → p (x + y)) (Hneg : ∀ (x : K), p x → p (-x)) (Hinv : ∀ (x : K), p x → p x⁻¹) (Hmul : ∀ (x y : K), p x → p y → p (x * y)) : p x
theorem finset.order_emb_of_fin_unique {α : Type u_1} [linear_order α] {s : finset α} {k : ℕ} (h : s.card = k) {f : fin k → α} (hfs : ∀ (x : fin k), f x ∈ s) (hmono : strict_mono f) : f = ⇑(s.order_emb_of_fin h)
theorem finsum_mem_empty {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} : finsum (λ (i : α), finsum (λ (H : i ∈ ∅), f i)) = 0
theorem matrix.is_adj_matrix.adj_matrix_to_graph_eq {V : Type u_1} {α : Type u_2} [mul_zero_one_class α] [nontrivial α] {A : matrix V V α} (h : A.is_adj_matrix) [decidable_eq α] : simple_graph.adj_matrix α h.to_graph = A
theorem submodule.finrank_add_finrank_orthogonal' {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [finite_dimensional 𝕜 E] {K : submodule 𝕜 E} {n : ℕ} (h_dim : finite_dimensional.finrank 𝕜 ↥K + n = finite_dimensional.finrank 𝕜 E) : finite_dimensional.finrank 𝕜 ↥Kᗮ = n
theorem pythagorean_triple.zero  : pythagorean_triple 0 0 0
theorem strict_mono_on.strict_convex_on_of_deriv {D : set ℝ} (hD : convex ℝ D) {f : ℝ → ℝ} (hf : continuous_on f D) (hf' : differentiable_on ℝ f (interior D)) (hf'_mono : strict_mono_on (deriv f) (interior D)) : strict_convex_on ℝ D f
theorem category_theory.simplicial_object.δ_comp_σ_of_le {C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) {n : ℕ} {i : fin (n + 2)} {j : fin (n + 1)} (H : i ≤ ⇑fin.cast_succ j) : X.σ j.succ ≫ X.δ (⇑fin.cast_succ i) = X.δ i ≫ X.σ j
theorem comap_coe_Ioo_nhds_within_Iio {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a b : α) : filter.comap coe (nhds_within b (set.Iio b)) = filter.at_top
theorem is_coprime.ne_zero {R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 → R} (h : is_coprime (p 0) (p 1)) : p ≠ 0
theorem integral_sin_pow_mul_cos_pow_odd {a b : ℝ} (m n : ℕ) : ∫ (x : ℝ) in a..b, real.sin x ^ m * real.cos x ^ (2 * n + 1) = ∫ (u : ℝ) in real.sin a..real.sin b, u ^ m * (1 - u ^ 2) ^ n
theorem matrix.cramer_eq_adjugate_mul_vec {n : Type u} [decidable_eq n] [fintype n] {α : Type v} [comm_ring α] (A : matrix n n α) (b : n → α) : ⇑(A.cramer) b = A.adjugate.mul_vec b
theorem nat.succ_mul_central_binom_succ (n : ℕ) : (n + 1) * (n + 1).central_binom = 2 * (2 * n + 1) * n.central_binom
theorem set_like.coe_list_dprod {ι : Type u_1} {R : Type u_2} {α : Type u_3} {S : Type u_4} [set_like S R] [monoid R] [add_monoid ι] (A : ι → S) [set_like.graded_monoid A] (fι : α → ι) (fA : Π (a : α), ↥(A (fι a))) (l : list α) : ↑(l.dprod fι fA) = (list.map (λ (a : α), ↑(fA a)) l).prod
theorem category_theory.limits.has_colimit_span_of_has_colimit_pair_of_has_colimit_parallel_pair {C : Type u} [𝒞 : category_theory.category C] {X Y Z : C} (f : X ⟶ Y) (g : X ⟶ Z) [category_theory.limits.has_colimit (category_theory.limits.pair Y Z)] [category_theory.limits.has_colimit (category_theory.limits.parallel_pair (f ≫ category_theory.limits.coprod.inl) (g ≫ category_theory.limits.coprod.inr))] : category_theory.limits.has_colimit (category_theory.limits.span f g)
theorem ideal.comap_le_map_of_inverse {R : Type u} {S : Type v} [semiring R] [semiring S] (f : R →+* S) (g : S →+* R) (I : ideal S) (h : function.left_inverse ⇑g ⇑f) : ideal.comap f I ≤ ideal.map g I
theorem orthonormal.oangle_rotation_self_left {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x : V} (hx : x ≠ 0) (θ : real.angle) : hb.oangle (⇑(hb.rotation θ) x) x = -θ
theorem dense_range.prod_map {β : Type v} {γ : Type u_1} [topological_space β] [topological_space γ] {ι : Type u_2} {κ : Type u_3} {f : ι → β} {g : κ → γ} (hf : dense_range f) (hg : dense_range g) : dense_range (prod.map f g)
theorem bdd_below_insert {γ : Type w} [semilattice_inf γ] (a : γ) {s : set γ} : bdd_below (has_insert.insert a s) ↔ bdd_below s
theorem inner_product_geometry.norm_add_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two {V : Type u_1} [inner_product_space ℝ V] (x y : V) : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ ↔ inner_product_geometry.angle x y = real.pi / 2
theorem linear_independent_le_span' {R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {ι : Type u_1} (v : ι → M) (i : linear_independent R v) (w : set M) [fintype ↥w] (s : set.range v ≤ ↑(submodule.span R w)) : cardinal.mk ι ≤ ↑(fintype.card ↥w)
theorem category_theory.whiskering_preadditive_yoneda {C : Type u} [category_theory.category C] [category_theory.preadditive C] : category_theory.preadditive_yoneda ⋙ (category_theory.whiskering_right Cᵒᵖ AddCommGroup (Type v)).obj (category_theory.forget AddCommGroup) = category_theory.yoneda
theorem metric.inf_edist_le_inf_edist_thickening_add {α : Type u} [pseudo_emetric_space α] {δ : ℝ} {s : set α} {x : α} : emetric.inf_edist x s ≤ emetric.inf_edist x (metric.thickening δ s) + ennreal.of_real δ
theorem intermediate_field.sum_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {ι : Type u_3} {t : finset ι} {f : ι → L} (h : ∀ (c : ι), c ∈ t → f c ∈ S) : t.sum (λ (i : ι), f i) ∈ S
theorem nnnorm_tsum_le {ι : Type u_1} {E : Type u_3} [semi_normed_group E] {f : ι → E} (hf : summable (λ (i : ι), ∥f i∥₊)) : ∥∑' (i : ι), f i∥₊ ≤ ∑' (i : ι), ∥f i∥₊
theorem has_fderiv_at_integral_of_dominated_loc_of_lip {α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {𝕜 : Type u_2} [is_R_or_C 𝕜] {E : Type u_3} [normed_group E] [normed_space ℝ E] [normed_space 𝕜 E] [complete_space E] {H : Type u_4} [normed_group H] [normed_space 𝕜 H] {F : H → α → E} {F' : α → (H →L[𝕜] E)} {x₀ : H} {bound : α → ℝ} {ε : ℝ} (ε_pos : 0 < ε) (hF_meas : ∀ᶠ (x : H) in nhds x₀, measure_theory.ae_strongly_measurable (F x) μ) (hF_int : measure_theory.integrable (F x₀) μ) (hF'_meas : measure_theory.ae_strongly_measurable F' μ) (h_lip : ∀ᵐ (a : α) ∂μ, lipschitz_on_with (⇑real.nnabs (bound a)) (λ (x : H), F x a) (metric.ball x₀ ε)) (bound_integrable : measure_theory.integrable bound μ) (h_diff : ∀ᵐ (a : α) ∂μ, has_fderiv_at (λ (x : H), F x a) (F' a) x₀) : measure_theory.integrable F' μ ∧ has_fderiv_at (λ (x : H), ∫ (a : α), F x a ∂μ) (∫ (a : α), F' a ∂μ) x₀
theorem ordinal.div_nonempty {a b : ordinal} (h : b ≠ 0) : {o : ordinal | a < b * order.succ o}.nonempty
theorem finset.induction_on_union {α : Type u_1} [decidable_eq α] (P : finset α → finset α → Prop) (symm : ∀ {a b : finset α}, P a b → P b a) (empty_right : ∀ {a : finset α}, P a ∅) (singletons : ∀ {a b : α}, P {a} {b}) (union_of : ∀ {a b c : finset α}, P a c → P b c → P (a ∪ b) c) (a b : finset α) : P a b
theorem finset.nonempty.map {α : Type u_1} {β : Type u_2} {f : α ↪ β} {s : finset α} : s.nonempty → (finset.map f s).nonempty
theorem category_theory.sheaf.le_finest_topology {C : Type u} [category_theory.category C] (Ps : set (Cᵒᵖ ⥤ Type v)) (J : category_theory.grothendieck_topology C) (hJ : ∀ (P : Cᵒᵖ ⥤ Type v), P ∈ Ps → category_theory.presieve.is_sheaf J P) : J ≤ category_theory.sheaf.finest_topology Ps
theorem algebraic_independent.of_subtype_range {R : Type u_3} {A : Type u_5} [comm_ring R] [comm_ring A] [algebra R A] {ι : Type u_1} {f : ι → A} (hf : function.injective f) : algebraic_independent R coe → algebraic_independent R f
theorem mem_orthogonal_singleton_of_inner_right {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (u : E) {v : E} (hv : has_inner.inner u v = 0) : v ∈ (submodule.span 𝕜 {u})ᗮ
theorem nat.fib_coprime_fib_succ (n : ℕ) : (nat.fib n).coprime (nat.fib (n + 1))
theorem finset.sum_centroid_weights_eq_one_of_nonempty (k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) [char_zero k] (h : s.nonempty) : s.sum (λ (i : ι), finset.centroid_weights k s i) = 1
theorem list.sublist.prod_le_prod' {M : Type u_3} [monoid M] [preorder M] [covariant_class M M (function.swap has_mul.mul) has_le.le] [covariant_class M M has_mul.mul has_le.le] {l₁ l₂ : list M} (h : l₁ <+ l₂) (h₁ : ∀ (a : M), a ∈ l₂ → 1 ≤ a) : l₁.prod ≤ l₂.prod
theorem is_simple_group_of_prime_card {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_simple_group α
theorem bool.apply_apply_apply (f : bool → bool) (x : bool) : f (f (f x)) = f x
theorem has_le.le.antisymm' {α : Type u} [partial_order α] {a b : α} : a ≤ b → b ≤ a → b = a
theorem pi.single_comm {I : Type u} [decidable_eq I] {β : Type u_1} [has_zero β] (i : I) (x : β) (i' : I) : pi.single i x i' = pi.single i' x i
theorem has_continuous_mul_of_smooth {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space 𝕜 E] (I : model_with_corners 𝕜 E H) {G : Type u_4} [has_mul G] [topological_space G] [charted_space H G] [has_smooth_mul I G] : has_continuous_mul G
theorem normalizer_condition_iff_only_full_group_self_normalizing {G : Type u_1} [group G] : normalizer_condition G ↔ ∀ (H : subgroup G), H.normalizer = H → H = ⊤
theorem category_theory.category_of_elements.from_to_costructured_arrow_eq {C : Type u} [category_theory.category C] (F : Cᵒᵖ ⥤ Type v) : (category_theory.category_of_elements.to_costructured_arrow F).right_op ⋙ category_theory.category_of_elements.from_costructured_arrow F = 𝟭 F.elements
theorem metric.bounded_iff_subset_ball {α : Type u} [pseudo_metric_space α] {s : set α} (c : α) : metric.bounded s ↔ ∃ (r : ℝ), s ⊆ metric.closed_ball c r
theorem filter.has_antitone_basis.subbasis_with_rel {α : Type u_3} {f : filter α} {s : ℕ → set α} (hs : f.has_antitone_basis s) {r : ℕ → ℕ → Prop} (hr : ∀ (m : ℕ), ∀ᶠ (n : ℕ) in filter.at_top, r m n) : ∃ (φ : ℕ → ℕ), strict_mono φ ∧ (∀ ⦃m n : ℕ⦄, m < n → r (φ m) (φ n)) ∧ f.has_antitone_basis (s ∘ φ)
theorem measure_theory.exists_pos_lintegral_lt_of_sigma_finite {α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) [measure_theory.sigma_finite μ] {ε : ennreal} (ε0 : ε ≠ 0) : ∃ (g : α → nnreal), (∀ (x : α), 0 < g x) ∧ measurable g ∧ ∫⁻ (x : α), ↑(g x) ∂μ < ε
theorem linear_map.polar_weak_closed {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [normed_comm_ring 𝕜] [add_comm_monoid E] [add_comm_monoid F] [module 𝕜 E] [module 𝕜 F] (B : E →ₗ[𝕜] F →ₗ[𝕜] 𝕜) (s : set E) : is_closed (B.polar s)
theorem metric.self_subset_thickening {α : Type u} [pseudo_emetric_space α] {δ : ℝ} (δ_pos : 0 < δ) (E : set α) : E ⊆ metric.thickening δ E
theorem inner_product_geometry.angle_smul_left_of_pos {V : Type u_1} [inner_product_space ℝ V] (x y : V) {r : ℝ} (hr : 0 < r) : inner_product_geometry.angle (r • x) y = inner_product_geometry.angle x y
theorem category_theory.mono_iff_injective {X Y : Type u} (f : X ⟶ Y) : category_theory.mono f ↔ function.injective f
theorem strict_mono.add {α : Type u_1} {β : Type u_2} [has_add α] [preorder α] [preorder β] {f g : β → α} [covariant_class α α has_add.add has_lt.lt] [covariant_class α α (function.swap has_add.add) has_lt.lt] (hf : strict_mono f) (hg : strict_mono g) : strict_mono (λ (x : β), f x + g x)
theorem pow_gcd_card_eq_one_iff {G : Type u} {x : G} {n : ℕ} [fintype G] [group G] : x ^ n = 1 ↔ x ^ n.gcd (fintype.card G) = 1
theorem category_theory.presheaf.is_separated_iff_subsingleton {C : Type u₁} [category_theory.category C] {A : Type u₂} [category_theory.category A] (J : category_theory.grothendieck_topology C) (P : Cᵒᵖ ⥤ A) : (∀ (E : A), category_theory.presieve.is_separated J (P ⋙ category_theory.coyoneda.obj (opposite.op E))) ↔ ∀ ⦃X : C⦄ (S : category_theory.sieve X), S ∈ ⇑J X → ∀ (c : category_theory.limits.cone (S.arrows.diagram.op ⋙ P)), subsingleton (c ⟶ P.map_cone S.arrows.cocone.op)
theorem double_quot.ker_quot_quot_mk {R : Type u} [comm_ring R] (I J : ideal R) : (double_quot.quot_quot_mk I J).ker = I ⊔ J
theorem star_id_of_comm {R : Type u_1} [comm_semiring R] {x : R} : has_star.star x = x
theorem cauchy_seq_of_edist_le_geometric_two {α : Type u_1} [pseudo_emetric_space α] (C : ennreal) (hC : C ≠ ⊤) {f : ℕ → α} (hu : ∀ (n : ℕ), has_edist.edist (f n) (f (n + 1)) ≤ C / 2 ^ n) : cauchy_seq f
theorem nonarchimedean_ring.left_mul_subset {R : Type u_1} [ring R] [topological_space R] [nonarchimedean_ring R] (U : open_add_subgroup R) (r : R) : ∃ (V : open_add_subgroup R), r • ↑V ⊆ ↑U
theorem antitone_of_deriv_nonpos {f : ℝ → ℝ} (hf : differentiable ℝ f) (hf' : ∀ (x : ℝ), deriv f x ≤ 0) : antitone f
theorem commutative_of_add_cyclic_center_quotient {G : Type u_1} {H : Type u_2} [add_group G] [add_group H] [is_add_cyclic H] (f : G →+ H) (hf : f.ker ≤ add_subgroup.center G) (a b : G) : a + b = b + a
theorem add_con.add_con_gen_le {M : Type u_1} [has_add M] {r : M → M → Prop} {c : add_con M} (h : ∀ (x y : M), r x y → setoid.r x y) : add_con_gen r ≤ c
theorem finset.weighted_vsub_indicator_subset {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (w : ι → k) (p : ι → P) {s₁ s₂ : finset ι} (h : s₁ ⊆ s₂) : ⇑(s₁.weighted_vsub p) w = ⇑(s₂.weighted_vsub p) (↑s₁.indicator w)
theorem lipschitz_on_with.extend_real {α : Type u} [pseudo_metric_space α] {f : α → ℝ} {s : set α} {K : nnreal} (hf : lipschitz_on_with K f s) : ∃ (g : α → ℝ), lipschitz_with K g ∧ set.eq_on f g s
theorem riesz_lemma_of_norm_lt {𝕜 : Type u_1} [normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {c : 𝕜} (hc : 1 < ∥c∥) {R : ℝ} (hR : ∥c∥ < R) {F : subspace 𝕜 E} (hFc : is_closed ↑F) (hF : ∃ (x : E), x ∉ F) : ∃ (x₀ : E), ∥x₀∥ ≤ R ∧ ∀ (y : E), y ∈ F → 1 ≤ ∥x₀ - y∥
theorem polynomial.cyclotomic_expand_eq_cyclotomic {p n : ℕ} (hp : nat.prime p) (hdiv : p ∣ n) (R : Type u_1) [comm_ring R] : ⇑(polynomial.expand R p) (polynomial.cyclotomic n R) = polynomial.cyclotomic (n * p) R
theorem same_ray.add_right {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y z : M} (hy : same_ray R x y) (hz : same_ray R x z) : same_ray R x (y + z)
theorem generalized_continued_fraction.squash_gcf_nth_of_lt {K : Type u_1} {n : ℕ} {g : generalized_continued_fraction K} [division_ring K] {m : ℕ} (m_lt_n : m < n) : (g.squash_gcf (n + 1)).s.nth m = g.s.nth m
theorem padic_val_nat_def {p : ℕ} [hp : fact (nat.prime p)] {n : ℕ} (hn : 0 < n) : padic_val_nat p n = (multiplicity p n).get _
theorem quotient.surjective_quotient_mk' {α : Sort u_1} {s₁ : setoid α} : function.surjective quotient.mk'
theorem is_smul_regular.subsingleton {R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] (h : is_smul_regular M 0) : subsingleton M
theorem hindman.FP_partition_regular {M : Type u_1} [semigroup M] (a : stream M) (s : set (set M)) (sfin : s.finite) (scov : hindman.FP a ⊆ ⋃₀s) : ∃ (c : set M) (H : c ∈ s) (b : stream M), hindman.FP b ⊆ c
theorem complete_lattice.is_compact_element_iff_le_of_directed_Sup_le (α : Type u_1) [complete_lattice α] (k : α) : complete_lattice.is_compact_element k ↔ ∀ (s : set α), s.nonempty → directed_on has_le.le s → k ≤ has_Sup.Sup s → (∃ (x : α), x ∈ s ∧ k ≤ x)
theorem category_theory.normal_epi_category.mono_of_zero_kernel {C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_cokernels C] [category_theory.normal_epi_category C] {X Y : C} (f : X ⟶ Y) (Z : C) (l : category_theory.limits.is_limit (category_theory.limits.kernel_fork.of_ι 0 _)) : category_theory.mono f
theorem trans_gen_of_pred_of_ne {α : Type u_1} [linear_order α] [pred_order α] [is_pred_archimedean α] (r : α → α → Prop) {n m : α} (h1 : ∀ (i : α), i ∈ set.Ioc m n → r i (order.pred i)) (h2 : ∀ (i : α), i ∈ set.Ioc n m → r (order.pred i) i) (hnm : n ≠ m) : relation.trans_gen r n m
theorem has_fpower_series_at.comp {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] [normed_group G] [normed_space 𝕜 G] {g : F → G} {f : E → F} {q : formal_multilinear_series 𝕜 F G} {p : formal_multilinear_series 𝕜 E F} {x : E} (hg : has_fpower_series_at g q (f x)) (hf : has_fpower_series_at f p x) : has_fpower_series_at (g ∘ f) (q.comp p) x
theorem euclidean_geometry.dist_eq_of_angle_eq_angle_of_angle_ne_pi {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : euclidean_geometry.angle p1 p2 p3 = euclidean_geometry.angle p1 p3 p2) (hpi : euclidean_geometry.angle p2 p1 p3 ≠ real.pi) : has_dist.dist p1 p2 = has_dist.dist p1 p3
theorem perfection_map.mk' {p : ℕ} [fact (nat.prime p)] {R : Type u₁} [comm_semiring R] [char_p R p] {P : Type u₃} [comm_semiring P] [char_p P p] [perfect_ring P p] {f : P →+* R} (g : P ≃+* ring.perfection R p) (hfg : ⇑(perfection.lift p P R) f = ↑g) : perfection_map p f
theorem continuous_of_locally_uniform_approx_of_continuous_at {α : Type u_1} {β : Type u_2} [uniform_space β] {f : α → β} [topological_space α] (L : ∀ (x : α) (u : set (β × β)), u ∈ uniformity β → (∃ (t : set α) (H : t ∈ nhds x) (F : α → β), continuous_at F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u)) : continuous f
theorem lucas_lehmer.X.closed_form {q : ℕ+} (i : ℕ) : ↑(lucas_lehmer.s i) = lucas_lehmer.X.ω ^ 2 ^ i + lucas_lehmer.X.ωb ^ 2 ^ i
theorem dist_le_Ico_sum_dist {α : Type u} [pseudo_metric_space α] (f : ℕ → α) {m n : ℕ} (h : m ≤ n) : has_dist.dist (f m) (f n) ≤ (finset.Ico m n).sum (λ (i : ℕ), has_dist.dist (f i) (f (i + 1)))
theorem cont_diff_within_at.add {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {x : E} {n : with_top ℕ} {s : set E} {f g : E → F} (hf : cont_diff_within_at 𝕜 n f s x) (hg : cont_diff_within_at 𝕜 n g s x) : cont_diff_within_at 𝕜 n (λ (x : E), f x + g x) s x
theorem finset.image₂_image_left_comm {α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} [decidable_eq α'] [decidable_eq γ] [decidable_eq δ] {s : finset α} {t : finset β} {f : α' → β → γ} {g : α → α'} {f' : α → β → δ} {g' : δ → γ} (h_left_comm : ∀ (a : α) (b : β), f (g a) b = g' (f' a b)) : finset.image₂ f (finset.image g s) t = finset.image g' (finset.image₂ f' s t)
theorem measure_theory.Lp_meas_subgroup_to_Lp_trim_left_inv {α : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space α} {μ : measure_theory.measure α} (hm : m ≤ m0) : function.left_inverse (measure_theory.Lp_trim_to_Lp_meas_subgroup F p μ hm) (measure_theory.Lp_meas_subgroup_to_Lp_trim F p μ hm)
theorem finite_dimensional.nonempty_continuous_linear_equiv_iff_finrank_eq {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {E : Type v} [normed_group E] [normed_space 𝕜 E] {F : Type w} [normed_group F] [normed_space 𝕜 F] [complete_space 𝕜] [finite_dimensional 𝕜 E] [finite_dimensional 𝕜 F] : nonempty (E ≃L[𝕜] F) ↔ finite_dimensional.finrank 𝕜 E = finite_dimensional.finrank 𝕜 F
theorem eq_pos_convex_span_of_mem_convex_hull {𝕜 : Type u_1} {E : Type u} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] {s : set E} {x : E} (hx : x ∈ ⇑(convex_hull 𝕜) s) : ∃ (ι : Type u) (_x : fintype ι) (z : ι → E) (w : ι → 𝕜) (hss : set.range z ⊆ s) (hai : affine_independent 𝕜 z) (hw : ∀ (i : ι), 0 < w i), finset.univ.sum (λ (i : ι), w i) = 1 ∧ finset.univ.sum (λ (i : ι), w i • z i) = x
theorem category_theory.is_iso_of_mono_of_nonzero {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.simple Y] {f : X ⟶ Y} [category_theory.mono f] (w : f ≠ 0) : category_theory.is_iso f
theorem finrank_eq_one_iff {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (ι : Type u_1) [unique ι] : finite_dimensional.finrank K V = 1 ↔ nonempty (basis ι K V)
theorem measure_theory.condexp_L2_const_inner {α : Type u_1} {E : Type u_4} {𝕜 : Type u_11} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [complete_space E] {m m0 : measurable_space α} {μ : measure_theory.measure α} (hm : m ≤ m0) (f : ↥(measure_theory.Lp E 2 μ)) (c : E) : ⇑(⇑(measure_theory.condexp_L2 𝕜 hm) (measure_theory.mem_ℒp.to_Lp (λ (a : α), has_inner.inner c (⇑f a)) _)) =ᵐ[μ] λ (a : α), has_inner.inner c (⇑(⇑(measure_theory.condexp_L2 𝕜 hm) f) a)
theorem pgame.zero_add_equiv (x : pgame) : (0 + x).equiv x
theorem metric.cthickening_subset_of_subset {α : Type u} [pseudo_emetric_space α] (δ : ℝ) {E₁ E₂ : set α} (h : E₁ ⊆ E₂) : metric.cthickening δ E₁ ⊆ metric.cthickening δ E₂
theorem finset.induction_on_pi_max {ι : Type u_1} {α : ι → Type u_2} [fintype ι] [decidable_eq ι] [Π (i : ι), decidable_eq (α i)] [Π (i : ι), linear_order (α i)] {p : (Π (i : ι), finset (α i)) → Prop} (f : Π (i : ι), finset (α i)) (h0 : p (λ (_x : ι), ∅)) (step : ∀ (g : Π (i : ι), finset (α i)) (i : ι) (x : α i), (∀ (y : α i), y ∈ g i → y < x) → p g → p (function.update g i (has_insert.insert x (g i)))) : p f
theorem multilinear_map.norm_image_sub_le_of_bound {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : multilinear_map 𝕜 E G) {C : ℝ} (hC : 0 ≤ C) (H : ∀ (m : Π (i : ι), E i), ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : ι), ∥m i∥)) (m₁ m₂ : Π (i : ι), E i) : ∥⇑f m₁ - ⇑f m₂∥ ≤ C * ↑(fintype.card ι) * linear_order.max ∥m₁∥ ∥m₂∥ ^ (fintype.card ι - 1) * ∥m₁ - m₂∥
theorem is_of_fin_order.mul {G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)
theorem monotone.covariant_of_const' {N : Type u_2} {α : Type u_3} [preorder α] [preorder N] {f : N → α} {μ : N → N → N} [covariant_class N N (function.swap μ) has_le.le] (hf : monotone f) (m : N) : monotone (λ (n : N), f (μ n m))
theorem finset.exists_subset_of_mem_shadow {α : Type u_1} [decidable_eq α] {𝒜 : finset (finset α)} {s : finset α} (hs : s ∈ 𝒜.shadow) : ∃ (t : finset α) (H : t ∈ 𝒜), s ⊆ t
theorem vector.scanl_cons {n : ℕ} {α : Type u_1} {β : Type u_2} (f : β → α → β) (b : β) (v : vector α n) (x : α) : vector.scanl f b (x::ᵥv) = b::ᵥvector.scanl f (f b x) v
theorem linear_map.det_smul {𝕜 : Type u_1} [field 𝕜] {M : Type u_2} [add_comm_group M] [module 𝕜 M] (c : 𝕜) (f : M →ₗ[𝕜] M) : ⇑linear_map.det (c • f) = c ^ finite_dimensional.finrank 𝕜 M * ⇑linear_map.det f
theorem inner_lt_one_iff_real_of_norm_one {F : Type u_3} [inner_product_space ℝ F] {x y : F} (hx : ∥x∥ = 1) (hy : ∥y∥ = 1) : has_inner.inner x y < 1 ↔ x ≠ y
theorem padic_norm.of_int (p : ℕ) [hp : fact (nat.prime p)] (z : ℤ) : padic_norm p ↑z ≤ 1
theorem is_localization.is_domain_localization {A : Type u_6} [comm_ring A] [is_domain A] {M : submonoid A} (hM : M ≤ non_zero_divisors A) : is_domain (localization M)
theorem ae_eq_const_or_exists_average_ne_compl {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {f : α → E} [measure_theory.is_finite_measure μ] (hfi : measure_theory.integrable f μ) : f =ᵐ[μ] function.const α (⨍ (x : α), f x ∂μ) ∨ ∃ (t : set α), measurable_set t ∧ ⇑μ t ≠ 0 ∧ ⇑μ tᶜ ≠ 0 ∧ ⨍ (x : α) in t, f x ∂μ ≠ ⨍ (x : α) in tᶜ, f x ∂μ
theorem sub_mul {α : Type u} [non_unital_non_assoc_ring α] (a b c : α) : (a - b) * c = a * c - b * c
theorem filter.map_map₂_right_anticomm {α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {f : filter α} {g : filter β} {m : α → β' → γ} {n : β → β'} {m' : β → α → δ} {n' : δ → γ} (h_right_anticomm : ∀ (a : α) (b : β), m a (n b) = n' (m' b a)) : filter.map₂ m f (filter.map n g) = filter.map n' (filter.map₂ m' g f)
theorem is_ring_hom.of_semiring {α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (H : is_semiring_hom f) : is_ring_hom f
theorem basis.det_ne_zero {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {ι : Type u_4} [decidable_eq ι] [fintype ι] (e : basis ι R M) [nontrivial R] : e.det ≠ 0
theorem tsub_nonpos_of_le {α : Type u_1} [preorder α] [add_comm_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} : a ≤ b → a - b ≤ 0
theorem category_theory.limits.has_binary_biproduct.of_has_binary_product {C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_product X Y] : category_theory.limits.has_binary_biproduct X Y
theorem filter.tendsto_at_top_of_monotone_of_filter {ι : Type u_1} {α : Type u_3} [preorder ι] [preorder α] {l : filter ι} {u : ι → α} (h : monotone u) [l.ne_bot] (hu : filter.tendsto u l filter.at_top) : filter.tendsto u filter.at_top filter.at_top
theorem measure_theory.forall_measure_preimage_mul_right_iff {G : Type u_1} [measurable_space G] [has_mul G] [has_measurable_mul G] (μ : measure_theory.measure G) : (∀ (g : G) (A : set G), measurable_set A → ⇑μ ((λ (h : G), h * g) ⁻¹' A) = ⇑μ A) ↔ μ.is_mul_right_invariant
theorem measure_theory.L1.tendsto_set_to_L1 {α : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {m : measurable_space α} {μ : measure_theory.measure α} [complete_space F] {T : set α → (E →L[ℝ] F)} {C : ℝ} (hT : measure_theory.dominated_fin_meas_additive μ T C) (f : ↥(measure_theory.Lp E 1 μ)) {ι : Type u_4} (fs : ι → ↥(measure_theory.Lp E 1 μ)) {l : filter ι} (hfs : filter.tendsto fs l (nhds f)) : filter.tendsto (λ (i : ι), ⇑(measure_theory.L1.set_to_L1 hT) (fs i)) l (nhds (⇑(measure_theory.L1.set_to_L1 hT) f))
theorem is_dedekind_domain.height_one_spectrum.int_valuation_ne_zero {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x : R) (hx : x ≠ 0) : v.int_valuation_def x ≠ 0
theorem finite_dimensional.finrank_pos {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] [h : nontrivial V] : 0 < finite_dimensional.finrank K V
theorem inner_matrix_col_col {𝕜 : Type u_3} [is_R_or_C 𝕜] {n m : ℕ} (A B : matrix (fin n) (fin m) 𝕜) (i j : fin m) : has_inner.inner (A.transpose i) (B.transpose j) = A.conj_transpose.mul B i j
theorem injective_iff_map_eq_zero {F : Type u_8} {G : Type u_1} {H : Type u_2} [add_group G] [add_zero_class H] [add_monoid_hom_class F G H] (f : F) : function.injective ⇑f ↔ ∀ (a : G), ⇑f a = 0 → a = 0
theorem map_div {G : Type u_6} {H : Type u_7} {F : Type u_8} [group G] [division_monoid H] [monoid_hom_class F G H] (f : F) (a b : G) : ⇑f (a / b) = ⇑f a / ⇑f b
theorem submonoid.localization_map.map_comp_map {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M →* P} {T : submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ T) {Q : Type u_4} [comm_monoid Q] {k : T.localization_map Q} {A : Type u_5} [comm_monoid A] {U : submonoid A} {R : Type u_6} [comm_monoid R] (j : U.localization_map R) {l : P →* A} (hl : ∀ (w : ↥T), ⇑l ↑w ∈ U) : (k.map hl j).comp (f.map hy k) = f.map _ j
theorem affinity_unit_ball {E : Type u_2} [normed_group E] [normed_space ℝ E] {r : ℝ} (hr : 0 < r) (x : E) : x +ᵥ r • metric.ball 0 1 = metric.ball x r
theorem finsum_mem_sub_distrib {α : Type u_1} {G : Type u_4} {s : set α} [subtraction_comm_monoid G] (f g : α → G) (hs : s.finite) : finsum (λ (i : α), finsum (λ (H : i ∈ s), f i - g i)) = finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) - finsum (λ (i : α), finsum (λ (H : i ∈ s), g i))
theorem filter.Coprod_cocompact {δ : Type u_1} {κ : δ → Type u_2} [Π (d : δ), topological_space (κ d)] : filter.Coprod (λ (d : δ), filter.cocompact (κ d)) = filter.cocompact (Π (d : δ), κ d)
theorem units.open_embedding_coe {R : Type u_1} [normed_ring R] [complete_space R] : open_embedding coe
theorem prime_multiset.factor_multiset_prod (v : prime_multiset) : v.prod.factor_multiset = v
theorem is_open_map_snd {α : Type u} {β : Type v} [topological_space α] [topological_space β] : is_open_map prod.snd
theorem filter.has_basis.lift {α : Type u_1} {γ : Type u_3} {ι : Type u_2} {p : ι → Prop} {s : ι → set α} {f : filter α} (hf : f.has_basis p s) {β : ι → Type u_4} {pg : Π (i : ι), β i → Prop} {sg : Π (i : ι), β i → set γ} {g : set α → filter γ} (hg : ∀ (i : ι), (g (s i)).has_basis (pg i) (sg i)) (gm : monotone g) : (f.lift g).has_basis (λ (i : Σ (i : ι), β i), p i.fst ∧ pg i.fst i.snd) (λ (i : Σ (i : ι), β i), sg i.fst i.snd)
theorem orthonormal.oangle_smul_left_self_of_nonneg {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x : V) {r : ℝ} (hr : 0 ≤ r) : hb.oangle (r • x) x = 0
theorem collinear_iff_exists_forall_eq_smul_vadd (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : collinear k s ↔ ∃ (p₀ : P) (v : V), ∀ (p : P), p ∈ s → (∃ (r : k), p = r • v +ᵥ p₀)
theorem nat.factorization_prod {α : Type u_1} {S : finset α} {g : α → ℕ} (hS : ∀ (x : α), x ∈ S → g x ≠ 0) : (S.prod g).factorization = S.sum (λ (x : α), (g x).factorization)
theorem add_con.add_con_gen_idem {M : Type u_1} [has_add M] (r : M → M → Prop) : add_con_gen ⇑(add_con_gen r) = add_con_gen r
theorem strict_convex.affine_image {𝕜 : Type u_1} {E : Type u_3} {F : Type u_4} [ordered_ring 𝕜] [topological_space E] [topological_space F] [add_comm_group E] [add_comm_group F] [module 𝕜 E] [module 𝕜 F] {s : set E} (hs : strict_convex 𝕜 s) {f : E →ᵃ[𝕜] F} (hf : is_open_map ⇑f) : strict_convex 𝕜 (⇑f '' s)
theorem norm_add_le {E : Type u_3} [semi_normed_group E] (g h : E) : ∥g + h∥ ≤ ∥g∥ + ∥h∥
theorem exterior_algebra.ι_sq_zero {R : Type u1} [comm_semiring R] {M : Type u2} [add_comm_monoid M] [module R M] (m : M) : ⇑(exterior_algebra.ι R) m * ⇑(exterior_algebra.ι R) m = 0
theorem right_deriv_measurable_aux.differentiable_set_subset_D {F : Type u_1} [normed_group F] [normed_space ℝ F] {f : ℝ → F} (K : set F) : {x : ℝ | differentiable_within_at ℝ f (set.Ici x) x ∧ deriv_within f (set.Ici x) x ∈ K} ⊆ right_deriv_measurable_aux.D f K
theorem nat.add_choose_eq (m n k : ℕ) : (m + n).choose k = (finset.nat.antidiagonal k).sum (λ (ij : ℕ × ℕ), m.choose ij.fst * n.choose ij.snd)
theorem measure_theory.lintegral_supr_directed {α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [encodable β] {f : β → α → ennreal} (hf : ∀ (b : β), measurable (f b)) (h_directed : directed has_le.le f) : ∫⁻ (a : α), (⨆ (b : β), f b a) ∂μ = ⨆ (b : β), ∫⁻ (a : α), f b a ∂μ
theorem is_torsion_free.prod {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i)
theorem reflection_trans_reflection {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) [complete_space ↥K] : (reflection K).trans (reflection K) = linear_isometry_equiv.refl 𝕜 E
theorem formal_multilinear_series.comp_along_composition_norm {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] [normed_group G] [normed_space 𝕜 G] {n : ℕ} (q : formal_multilinear_series 𝕜 F G) (p : formal_multilinear_series 𝕜 E F) (c : composition n) : ∥q.comp_along_composition p c∥ ≤ ∥q c.length∥ * finset.univ.prod (λ (i : fin c.length), ∥p (c.blocks_fun i)∥)
theorem basis.repr_apply_eq {ι : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (b : basis ι R M) (f : M → ι → R) (hadd : ∀ (x y : M), f (x + y) = f x + f y) (hsmul : ∀ (c : R) (x : M), f (c • x) = c • f x) (f_eq : ∀ (i : ι), f (⇑b i) = ⇑(finsupp.single i 1)) (x : M) (i : ι) : ⇑(⇑(b.repr) x) i = f x i
theorem continued_fraction.convergents_eq_convergents' {K : Type u_1} [linear_ordered_field K] {c : continued_fraction K} : ↑c.convergents = ↑c.convergents'
theorem alternating_map.comp_linear_equiv_eq_zero_iff {R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] {ι : Type u_6} [decidable_eq ι] {M₂ : Type u_7} [add_comm_monoid M₂] [module R M₂] (f : alternating_map R M N ι) (g : M₂ ≃ₗ[R] M) : f.comp_linear_map ↑g = 0 ↔ f = 0
theorem euclidean_geometry.dist_smul_vadd_eq_dist {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {v : V} (p₁ p₂ : P) (hv : v ≠ 0) (r : ℝ) : has_dist.dist (r • v +ᵥ p₁) p₂ = has_dist.dist p₁ p₂ ↔ r = 0 ∨ r = (-2) * has_inner.inner v (p₁ -ᵥ p₂) / has_inner.inner v v
theorem one_lt_inv_of_inv {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a < 1 → 1 < a⁻¹
theorem asymptotics.is_O.exists_eq_mul {α : Type u_1} {𝕜 : Type u_14} [normed_field 𝕜] {l : filter α} {u v : α → 𝕜} : u =O[l] v → (∃ (φ : α → 𝕜) (hφ : filter.is_bounded_under has_le.le l (has_norm.norm ∘ φ)), u =ᶠ[l] φ * v)
theorem polynomial.cyclotomic_coeff_zero (R : Type u_1) [comm_ring R] {n : ℕ} (hn : 2 ≤ n) : (polynomial.cyclotomic n R).coeff 0 = 1
theorem measure_theory.lintegral_nnnorm_le_of_forall_fin_meas_integral_eq {α : Type u_1} {m m0 : measurable_space α} {μ : measure_theory.measure α} {s : set α} (hm : m ≤ m0) {f g : α → ℝ} (hf : measure_theory.strongly_measurable f) (hfi : measure_theory.integrable_on f s μ) (hg : measure_theory.strongly_measurable g) (hgi : measure_theory.integrable_on g s μ) (hgf : ∀ (t : set α), measurable_set t → ⇑μ t < ⊤ → ∫ (x : α) in t, g x ∂μ = ∫ (x : α) in t, f x ∂μ) (hs : measurable_set s) (hμs : ⇑μ s ≠ ⊤) : ∫⁻ (x : α) in s, ↑∥g x∥₊ ∂μ ≤ ∫⁻ (x : α) in s, ↑∥f x∥₊ ∂μ
theorem emetric.nonempty_compacts.to_closeds.uniform_embedding {α : Type u} [emetric_space α] : uniform_embedding topological_space.nonempty_compacts.to_closeds
theorem is_dedekind_domain.height_one_spectrum.valuation_le_one {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] {K : Type u_2} [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) (r : R) : ⇑(v.valuation) (⇑(algebra_map R K) r) ≤ 1
theorem Top.presheaf.is_sheaf_iff_is_sheaf_pairwise_intersections {X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) : F.is_sheaf ↔ F.is_sheaf_pairwise_intersections
theorem measure_theory.outer_measure.Union_nat_of_monotone_of_tsum_ne_top {α : Type u_1} (m : measure_theory.outer_measure α) {s : ℕ → set α} (h_mono : ∀ (n : ℕ), s n ⊆ s (n + 1)) (h0 : ∑' (k : ℕ), ⇑m (s (k + 1)  s k) ≠ ⊤) : ⇑m (⋃ (n : ℕ), s n) = ⨆ (n : ℕ), ⇑m (s n)
theorem norm_sub_eq_norm_add {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {v w : E} (h : has_inner.inner v w = 0) : ∥w - v∥ = ∥w + v∥
theorem set.image2_distrib_subset_right {α : Type u_1} {α' : Type u_2} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {ε : Type u_9} {s : set α} {t : set β} {u : set γ} {f : δ → γ → ε} {g : α → β → δ} {f₁ : α → γ → α'} {f₂ : β → γ → β'} {g' : α' → β' → ε} (h_distrib : ∀ (a : α) (b : β) (c : γ), f (g a b) c = g' (f₁ a c) (f₂ b c)) : set.image2 f (set.image2 g s t) u ⊆ set.image2 g' (set.image2 f₁ s u) (set.image2 f₂ t u)
theorem supr_and' {α : Type u_1} [complete_lattice α] {p q : Prop} {s : p → q → α} : (⨆ (h₁ : p) (h₂ : q), s h₁ h₂) = ⨆ (h : p ∧ q), s _ _
theorem orthonormal.oangle_add_swap {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle y z + hb.oangle x y = hb.oangle x z
theorem add_monoid_hom.map_sub {α : Type u_1} {β : Type u_2} [add_group α] [subtraction_monoid β] (f : α →+ β) (g h : α) : ⇑f (g - h) = ⇑f g - ⇑f h
theorem finset.center_mass_segment' {R : Type u_1} {E : Type u_2} {ι : Type u_4} {ι' : Type u_5} [linear_ordered_field R] [add_comm_group E] [module R E] (s : finset ι) (t : finset ι') (ws : ι → R) (zs : ι → E) (wt : ι' → R) (zt : ι' → E) (hws : s.sum (λ (i : ι), ws i) = 1) (hwt : t.sum (λ (i : ι'), wt i) = 1) (a b : R) (hab : a + b = 1) : a • s.center_mass ws zs + b • t.center_mass wt zt = (finset.map function.embedding.inl s ∪ finset.map function.embedding.inr t).center_mass (sum.elim (λ (i : ι), a * ws i) (λ (j : ι'), b * wt j)) (sum.elim zs zt)
theorem ring_hom.eq_nat_cast' {R : Type u_1} [non_assoc_semiring R] (f : ℕ →+* R) : f = nat.cast_ring_hom R
theorem orthonormal.oangle_smul_left_of_neg {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x y : V) {r : ℝ} (hr : r < 0) : hb.oangle (r • x) y = hb.oangle (-x) y
theorem interval_integral.integral_deriv_eq_sub {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} (hderiv : ∀ (x : ℝ), x ∈ set.interval a b → differentiable_at ℝ f x) (hint : interval_integrable (deriv f) measure_theory.measure_space.volume a b) : ∫ (y : ℝ) in a..b, deriv f y = f b - f a
theorem module.directed_system.map_map {R : Type u} [ring R] {ι : Type v} [preorder ι] {G : ι → Type w} [Π (i : ι), add_comm_group (G i)] [Π (i : ι), module R (G i)] (f : Π (i j : ι), i ≤ j → (G i →ₗ[R] G j)) [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] {i j k : ι} (hij : i ≤ j) (hjk : j ≤ k) (x : G i) : ⇑(f j k hjk) (⇑(f i j hij) x) = ⇑(f i k _) x
theorem exists_maximal_of_nonempty_chains_bounded {α : Type u_1} {r : α → α → Prop} [nonempty α] (h : ∀ (c : set α), is_chain r c → c.nonempty → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) (trans : ∀ {a b c : α}, r a b → r b c → r a c) : ∃ (m : α), ∀ (a : α), r m a → r a m
theorem pmf.to_measure_pure_apply {α : Type u_1} (a : α) (s : set α) [measurable_space α] (hs : measurable_set s) : ⇑((pmf.pure a).to_measure) s = ite (a ∈ s) 1 0
theorem finite_dimensional.eq_of_le_of_finrank_eq {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {S₁ S₂ : submodule K V} [finite_dimensional K ↥S₂] (hle : S₁ ≤ S₂) (hd : finite_dimensional.finrank K ↥S₁ = finite_dimensional.finrank K ↥S₂) : S₁ = S₂
theorem concave_on.ge_on_segment {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [linear_ordered_add_comm_monoid β] [has_scalar 𝕜 E] [module 𝕜 β] [ordered_smul 𝕜 β] {s : set E} {f : E → β} (hf : concave_on 𝕜 s f) {x y z : E} (hx : x ∈ s) (hy : y ∈ s) (hz : z ∈ segment 𝕜 x y) : linear_order.min (f x) (f y) ≤ f z
theorem metric.bounded.union {α : Type u} [pseudo_metric_space α] {s t : set α} (hs : metric.bounded s) (ht : metric.bounded t) : metric.bounded (s ∪ t)
theorem map_bit0 {α : Type u} {β : Type v} {F : Type u_1} [non_assoc_semiring α] [non_assoc_semiring β] [add_hom_class F α β] (f : F) (a : α) : ⇑f (bit0 a) = bit0 (⇑f a)
theorem has_deriv_within_at.congr_set {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {F : Type v} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜} {s t u : set 𝕜} (hu : u ∈ nhds x) (h : s ∩ u = t ∩ u) : has_deriv_within_at f f' s x → has_deriv_within_at f f' t x
theorem cauchy_seq_of_dist_le_of_summable {α : Type u_1} [pseudo_metric_space α] {f : ℕ → α} (d : ℕ → ℝ) (hf : ∀ (n : ℕ), has_dist.dist (f n) (f n.succ) ≤ d n) (hd : summable d) : cauchy_seq f
theorem measure_theory.exists_lt_lower_semicontinuous_lintegral_ge_of_ae_measurable {α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] (μ : measure_theory.measure α) [μ.weakly_regular] [measure_theory.sigma_finite μ] (f : α → nnreal) (fmeas : ae_measurable f μ) {ε : ennreal} (ε0 : ε ≠ 0) : ∃ (g : α → ennreal), (∀ (x : α), ↑(f x) < g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), g x ∂μ ≤ ∫⁻ (x : α), ↑(f x) ∂μ + ε
theorem nat.not_bdd_above_set_of_prime  : ¬bdd_above {p : ℕ | nat.prime p}
theorem category_theory.Sheaf.is_sheaf_of_is_limit {C : Type (max v u)} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] {K : Type (max v u)} [category_theory.small_category K] [category_theory.limits.has_limits_of_shape K D] (F : K ⥤ category_theory.Sheaf J D) (E : category_theory.limits.cone (F ⋙ category_theory.Sheaf_to_presheaf J D)) (hE : category_theory.limits.is_limit E) : category_theory.presheaf.is_sheaf J E.X
theorem finset.sum_range_by_parts {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (f : ℕ → R) (g : ℕ → M) (n : ℕ) : (finset.range n).sum (λ (i : ℕ), f i • g i) = f (n - 1) • (finset.range n).sum (λ (i : ℕ), g i) - (finset.range (n - 1)).sum (λ (i : ℕ), (f (i + 1) - f i) • (finset.range (i + 1)).sum (λ (i : ℕ), g i))
theorem multiset_sum_mem {B : Type u_3} {S : B} {M : Type u_1} [add_comm_monoid M] [set_like B M] [add_submonoid_class B M] (m : multiset M) (hm : ∀ (a : M), a ∈ m → a ∈ S) : m.sum ∈ S
theorem convex.norm_image_sub_le_of_norm_deriv_within_le {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_group G] [normed_space 𝕜 G] {f : 𝕜 → G} {s : set 𝕜} {x y : 𝕜} {C : ℝ} (hf : differentiable_on 𝕜 f s) (bound : ∀ (x : 𝕜), x ∈ s → ∥deriv_within f s x∥ ≤ C) (hs : convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∥f y - f x∥ ≤ C * ∥y - x∥
theorem interval_integral.integral_sub_integral_sub_linear_is_o_of_tendsto_ae {ι : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {ca cb : E} {la la' lb lb' : filter ℝ} {lt : filter ι} {a b : ℝ} {ua ub va vb : ι → ℝ} [interval_integral.FTC_filter a la la'] [interval_integral.FTC_filter b lb lb'] (hab : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f la' measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f lb' measure_theory.measure_space.volume) (ha_lim : filter.tendsto f (la' ⊓ measure_theory.measure_space.volume.ae) (nhds ca)) (hb_lim : filter.tendsto f (lb' ⊓ measure_theory.measure_space.volume.ae) (nhds cb)) (hua : filter.tendsto ua lt la) (hva : filter.tendsto va lt la) (hub : filter.tendsto ub lt lb) (hvb : filter.tendsto vb lt lb) : (λ (t : ι), ((∫ (x : ℝ) in va t..vb t, f x) - ∫ (x : ℝ) in ua t..ub t, f x) - ((vb t - ub t) • cb - (va t - ua t) • ca)) =o[lt] λ (t : ι), ∥va t - ua t∥ + ∥vb t - ub t∥
theorem continuous_map.tendsto_iff_forall_compact_tendsto_uniformly_on' {α : Type u₁} {β : Type u₂} [topological_space α] [uniform_space β] (f : C(α, β)) {ι : Type u₃} {p : filter ι} {F : ι → C(α, β)} : filter.tendsto F p (nhds f) ↔ ∀ (K : set α), is_compact K → tendsto_uniformly_on (λ (i : ι) (a : α), ⇑(F i) a) ⇑f p K
theorem category_theory.subobject.lower_iso {C : Type u₁} [category_theory.category C] {X Y : C} (F₁ F₂ : category_theory.mono_over X ⥤ category_theory.mono_over Y) (h : F₁ ≅ F₂) : category_theory.subobject.lower F₁ = category_theory.subobject.lower F₂
theorem has_strict_fderiv_at_exp_zero {𝕂 : Type u_1} {𝔸 : Type u_2} [is_R_or_C 𝕂] [normed_ring 𝔸] [normed_algebra 𝕂 𝔸] [complete_space 𝔸] : has_strict_fderiv_at (exp 𝕂) 1 0
theorem infinite_of_mem_nhds {α : Type u_1} [topological_space α] [t1_space α] (x : α) [hx : (nhds_within x {x}ᶜ).ne_bot] {s : set α} (hs : s ∈ nhds x) : s.infinite
theorem basis.eq_of_apply_eq {ι : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] {b₁ b₂ : basis ι R M} (h : ∀ (i : ι), ⇑b₁ i = ⇑b₂ i) : b₁ = b₂
theorem category_theory.is_connected_of_equivalent {J : Type u₁} [category_theory.category J] {K : Type u₁} [category_theory.category K] (e : J ≌ K) [category_theory.is_connected J] : category_theory.is_connected K
theorem convex.combo_self_interior_subset_interior {E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) {a b : 𝕜} (ha : 0 ≤ a) (hb : 0 < b) (hab : a + b = 1) : a • s + b • interior s ⊆ interior s
theorem one_lt_of_inv_lt_one {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 → 1 < a
theorem complex.integral_boundary_rect_eq_zero_of_differentiable_on_off_countable {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] (f : ℂ → E) (z w : ℂ) (s : set ℂ) (hs : s.countable) (Hc : continuous_on f (set.interval z.re w.re ×ℂ set.interval z.im w.im)) (Hd : ∀ (x : ℂ), x ∈ set.Ioo (linear_order.min z.re w.re) (linear_order.max z.re w.re) ×ℂ set.Ioo (linear_order.min z.im w.im) (linear_order.max z.im w.im)  s → differentiable_at ℂ f x) : (((∫ (x : ℝ) in z.re..w.re, f (↑x + ↑(z.im) * complex.I)) - ∫ (x : ℝ) in z.re..w.re, f (↑x + ↑(w.im) * complex.I)) + complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑(w.re) + ↑y * complex.I)) - complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑(z.re) + ↑y * complex.I) = 0
theorem category_theory.presieve.is_sheaf_bot {C : Type u₁} [category_theory.category C] {P : Cᵒᵖ ⥤ Type w} : category_theory.presieve.is_sheaf ⊥ P
theorem category_theory.functor.eq_of_iso {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {F₁ F₂ : D ⥤ C} [∀ (X Y : C), subsingleton (X ⟶ Y)] (hC : category_theory.skeletal C) (hF : F₁ ≅ F₂) : F₁ = F₂
theorem is_extr_on.undual {α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α} : is_extr_on (⇑order_dual.to_dual ∘ f) s a → is_extr_on f s a
theorem measure_theory.outer_measure.Inf_apply {α : Type u_1} {m : set (measure_theory.outer_measure α)} {s : set α} (h : m.nonempty) : ⇑(has_Inf.Inf m) s = ⨅ (t : ℕ → set α) (h2 : s ⊆ set.Union t), ∑' (n : ℕ), ⨅ (μ : measure_theory.outer_measure α) (h3 : μ ∈ m), ⇑μ (t n)
theorem padic_norm_e.one' {p : ℕ} [fact (nat.prime p)] : padic_norm_e 1 = 1
theorem nnreal.arith_mean_le_rpow_mean {ι : Type u} (s : finset ι) (w z : ι → nnreal) (hw' : s.sum (λ (i : ι), w i) = 1) {p : ℝ} (hp : 1 ≤ p) : s.sum (λ (i : ι), w i * z i) ≤ s.sum (λ (i : ι), w i * z i ^ p) ^ (1 / p)
theorem strict_mono_on.dual_left {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s : set α} : strict_mono_on f s → strict_anti_on (f ∘ ⇑order_dual.of_dual) s
theorem measure_theory.measure.is_add_haar_measure_of_is_compact_nonempty_interior {G : Type u_1} [measurable_space G] [add_group G] [topological_space G] [topological_add_group G] [borel_space G] (μ : measure_theory.measure G) [μ.is_add_left_invariant] (K : set G) (hK : is_compact K) (h'K : (interior K).nonempty) (h : ⇑μ K ≠ 0) (h' : ⇑μ K ≠ ⊤) : μ.is_add_haar_measure
theorem category_theory.is_filtered.sup_exists {C : Type u} [category_theory.category C] [category_theory.is_filtered C] (O : finset C) (H : finset (Σ' (X Y : C) (mX : X ∈ O) (mY : Y ∈ O), X ⟶ Y)) : ∃ (S : C) (T : Π {X : C}, X ∈ O → (X ⟶ S)), ∀ {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f : X ⟶ Y}, ⟨X, ⟨Y, ⟨mX, ⟨mY, f⟩⟩⟩⟩ ∈ H → f ≫ T mY = T mX
theorem eventually_closure_subset_of_is_compact_absorbing_of_is_open_of_omega_limit_subset' {τ : Type u_1} {α : Type u_2} {β : Type u_3} [topological_space β] (f : filter τ) (ϕ : τ → α → β) (s : set α) {c : set β} (hc₁ : is_compact c) (hc₂ : ∃ (v : set τ) (H : v ∈ f), closure (set.image2 ϕ v s) ⊆ c) {n : set β} (hn₁ : is_open n) (hn₂ : omega_limit f ϕ s ⊆ n) : ∃ (u : set τ) (H : u ∈ f), closure (set.image2 ϕ u s) ⊆ n
theorem least_ascending_central_series_length_eq_nilpotency_class {G : Type u_1} [group G] [hG : group.is_nilpotent G] : nat.find _ = group.nilpotency_class G
theorem emetric.exists_edist_lt_of_Hausdorff_edist_lt {α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} {r : ennreal} (h : x ∈ s) (H : emetric.Hausdorff_edist s t < r) : ∃ (y : α) (H : y ∈ t), has_edist.edist x y < r
theorem comm_of {α : Type u} (r : α → α → Prop) [is_symm α r] {a b : α} : r a b ↔ r b a
theorem exists_subset_nhd_of_compact {α : Type u} [topological_space α] [t2_space α] {ι : Type u_1} [nonempty ι] {V : ι → set α} (hV : directed superset V) (hV_cpct : ∀ (i : ι), is_compact (V i)) {U : set α} (hU : ∀ (x : α), (x ∈ ⋂ (i : ι), V i) → U ∈ nhds x) : ∃ (i : ι), V i ⊆ U
theorem set.finite.compl_mem_hyperfilter {α : Type u} [infinite α] {s : set α} (hf : s.finite) : sᶜ ∈ filter.hyperfilter α
theorem antivary_on.sum_smul_le_sum_smul_comp_perm {ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {s : finset ι} {σ : equiv.perm ι} {f : ι → α} {g : ι → β} (hfg : antivary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i • g i) ≤ s.sum (λ (i : ι), f i • g (⇑σ i))
theorem linear_map.ker_eq_bot_of_cancel {R : Type u_1} {R₂ : Type u_3} {M : Type u_9} {M₂ : Type u_12} [semiring R] [semiring R₂] [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module R₂ M₂] {τ₁₂ : R →+* R₂} {f : M →ₛₗ[τ₁₂] M₂} (h : ∀ (u v : ↥(f.ker) →ₗ[R] M), f.comp u = f.comp v → u = v) : f.ker = ⊥
theorem is_smul_regular.of_smul_eq_one {R : Type u_1} {S : Type u_2} {M : Type u_3} {a : R} {s : S} [monoid S] [has_scalar R M] [has_scalar R S] [mul_action S M] [is_scalar_tower R S M] (h : a • s = 1) : is_smul_regular M s
theorem finset.exists_le_sum_fiber_of_maps_to_of_nsmul_le_sum {α : Type u} {β : Type v} {M : Type w} [decidable_eq β] {s : finset α} {t : finset β} {f : α → β} {w : α → M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (hf : ∀ (a : α), a ∈ s → f a ∈ t) (ht : t.nonempty) (hb : t.card • b ≤ s.sum (λ (x : α), w x)) : ∃ (y : β) (H : y ∈ t), b ≤ (finset.filter (λ (x : α), f x = y) s).sum (λ (x : α), w x)
theorem locally_finite.exists_finset_nhd_support_subset {X : Type u_1} {R : Type u_9} {ι : Type u_10} {U : ι → set X} [topological_space X] [has_zero R] {f : ι → X → R} (hlf : locally_finite (λ (i : ι), function.support (f i))) (hso : ∀ (i : ι), tsupport (f i) ⊆ U i) (ho : ∀ (i : ι), is_open (U i)) (x : X) : ∃ (is : finset ι) {n : set X} (hn₁ : n ∈ nhds x) (hn₂ : n ⊆ ⋂ (i : ι) (H : i ∈ is), U i), ∀ (z : X), z ∈ n → function.support (λ (i : ι), f i z) ⊆ ↑is
theorem is_bot.eq_bot {α : Type u} [partial_order α] [order_bot α] {a : α} : is_bot a → a = ⊥
theorem nat.cofinite_eq_at_top  : filter.cofinite = filter.at_top
theorem set.nonempty_Ico_sdiff {α : Type u_1} [linear_ordered_add_comm_group α] {x dx y dy : α} (h : dy < dx) (hx : 0 < dx) : nonempty ↥(set.Ico x (x + dx)  set.Ico y (y + dy))
theorem char.quadratic_char_eq_neg_one_iff_not_one {F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0) : char.quadratic_char F a = -1 ↔ ¬char.quadratic_char F a = 1
theorem finset.sum_univ_pi {α : Type u_1} {β : Type u_2} [decidable_eq α] [fintype α] [add_comm_monoid β] {δ : α → Type u_3} {t : Π (a : α), finset (δ a)} (f : (Π (a : α), a ∈ finset.univ → δ a) → β) : (finset.univ.pi t).sum (λ (x : Π (a : α), a ∈ finset.univ → δ a), f x) = (fintype.pi_finset t).sum (λ (x : Π (a : α), δ a), f (λ (a : α) (_x : a ∈ finset.univ), x a))
theorem filter.map_prod_map_const_id_principal_coprod_principal {α : Type u_1} {β : Type u_2} {ι : Type u_3} (a : α) (b : β) (i : ι) : filter.map (prod.map (λ (_x : α), b) id) ((filter.principal {a}).coprod (filter.principal {i})) = filter.principal ({b} ×ˢ set.univ)
theorem probability_theory.strong_law_aux3 {Ω : Type u_1} [measure_theory.measure_space Ω] [measure_theory.is_probability_measure measure_theory.measure_space.volume] (X : ℕ → Ω → ℝ) (hint : measure_theory.integrable (X 0) measure_theory.measure_space.volume) (hident : ∀ (i : ℕ), probability_theory.ident_distrib (X i) (X 0) measure_theory.measure_space.volume measure_theory.measure_space.volume) : (λ (n : ℕ), (∫ (a : Ω), (finset.range n).sum (λ (i : ℕ), probability_theory.truncation (X i) ↑i) a) - ↑n * ∫ (a : Ω), X 0 a) =o[filter.at_top] coe
theorem liouville.liouville_number_eq_initial_terms_add_tail {m : ℝ} (hm : 1 < m) (k : ℕ) : liouville.liouville_number m = liouville.liouville_number_initial_terms m k + liouville.liouville_number_tail m k
theorem add_subgroup.norm_normed_mk_le {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) : ∥S.normed_mk∥ ≤ 1
theorem smul_neg_of_pos_of_neg {k : Type u_1} {M : Type u_2} [ordered_semiring k] [ordered_add_comm_group M] [module k M] [ordered_smul k M] {a : M} {c : k} (hc : 0 < c) : a < 0 → c • a < 0
theorem ennreal.lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_ne_top {α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {p q : ℝ} (hpq : p.is_conjugate_exponent q) {f g : α → ennreal} (hf : ae_measurable f μ) (hf_nontop : ∫⁻ (a : α), f a ^ p ∂μ ≠ ⊤) (hg_nontop : ∫⁻ (a : α), g a ^ q ∂μ ≠ ⊤) (hf_nonzero : ∫⁻ (a : α), f a ^ p ∂μ ≠ 0) (hg_nonzero : ∫⁻ (a : α), g a ^ q ∂μ ≠ 0) : ∫⁻ (a : α), (f * g) a ∂μ ≤ (∫⁻ (a : α), f a ^ p ∂μ) ^ (1 / p) * (∫⁻ (a : α), g a ^ q ∂μ) ^ (1 / q)
theorem is_square.exists_sq {α : Type u_2} [monoid α] (m : α) : is_square m → (∃ (c : α), m = c ^ 2)
theorem one_lt_mul_of_le_of_lt' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 ≤ a) (hb : 1 < b) : 1 < a * b
theorem is_dedekind_domain.height_one_spectrum.int_valuation_le_one {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x : R) : v.int_valuation_def x ≤ 1
theorem category_theory.limits.has_limits_op_of_has_colimits {C : Type u₁} [category_theory.category C] [category_theory.limits.has_colimits C] : category_theory.limits.has_limits Cᵒᵖ
theorem finset.weighted_vsub_of_point_map {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} {ι₂ : Type u_5} (s₂ : finset ι₂) (e : ι₂ ↪ ι) (w : ι → k) (p : ι → P) (b : P) : ⇑((finset.map e s₂).weighted_vsub_of_point p b) w = ⇑(s₂.weighted_vsub_of_point (p ∘ ⇑e) b) (w ∘ ⇑e)
theorem finset.induction_on_pi_min {ι : Type u_1} {α : ι → Type u_2} [fintype ι] [decidable_eq ι] [Π (i : ι), decidable_eq (α i)] [Π (i : ι), linear_order (α i)] {p : (Π (i : ι), finset (α i)) → Prop} (f : Π (i : ι), finset (α i)) (h0 : p (λ (_x : ι), ∅)) (step : ∀ (g : Π (i : ι), finset (α i)) (i : ι) (x : α i), (∀ (y : α i), y ∈ g i → x < y) → p g → p (function.update g i (has_insert.insert x (g i)))) : p f
theorem affine.simplex.monge_point_vsub_face_centroid_eq_weighted_vsub_of_points_with_circumcenter {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P (n + 2)) {i₁ i₂ : fin (n + 3)} (h : i₁ ≠ i₂) : s.monge_point -ᵥ finset.centroid ℝ {i₁, i₂}ᶜ s.points = ⇑(finset.univ.weighted_vsub s.points_with_circumcenter) (affine.simplex.monge_point_vsub_face_centroid_weights_with_circumcenter i₁ i₂)
theorem finset.prod_fn {α : Type u_1} {β : α → Type u_2} {γ : Type u_3} [Π (a : α), comm_monoid (β a)] (s : finset γ) (g : γ → Π (a : α), β a) : s.prod (λ (c : γ), g c) = λ (a : α), s.prod (λ (c : γ), g c a)
theorem ray_eq_iff {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {v₁ v₂ : M} (hv₁ : v₁ ≠ 0) (hv₂ : v₂ ≠ 0) : ray_of_ne_zero R v₁ hv₁ = ray_of_ne_zero R v₂ hv₂ ↔ same_ray R v₁ v₂
theorem finset.sum_ite_eq' {β : Type u} {α : Type v} [add_comm_monoid β] [decidable_eq α] (s : finset α) (a : α) (b : α → β) : s.sum (λ (x : α), ite (x = a) (b x) 0) = ite (a ∈ s) (b a) 0
theorem basis.total_coord {R : Type u_1} {M : Type u_2} {ι : Type u_5} [comm_ring R] [add_comm_group M] [module R M] [fintype ι] (b : basis ι R M) (f : ι →₀ R) (i : ι) : ⇑(⇑(finsupp.total ι (module.dual R M) R b.coord) f) (⇑b i) = ⇑f i
theorem cardinal.mk_quaternion_algebra {R : Type u_1} (c₁ c₂ : R) : cardinal.mk (quaternion_algebra R c₁ c₂) = cardinal.mk R ^ 4
theorem cont_diff_on.sub {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : with_top ℕ} {s : set E} {f g : E → F} (hf : cont_diff_on 𝕜 n f s) (hg : cont_diff_on 𝕜 n g s) : cont_diff_on 𝕜 n (λ (x : E), f x - g x) s
theorem continuous_at_of_monotone_on_of_exists_between {α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} {a : α} (h_mono : monotone_on f s) (hs : s ∈ nhds a) (hfs_l : ∀ (b : β), b < f a → (∃ (c : α) (H : c ∈ s), f c ∈ set.Ioo b (f a))) (hfs_r : ∀ (b : β), b > f a → (∃ (c : α) (H : c ∈ s), f c ∈ set.Ioo (f a) b)) : continuous_at f a
theorem con.sup_eq_con_gen {M : Type u_1} [has_mul M] (c d : con M) : c ⊔ d = con_gen (λ (x y : M), ⇑c x y ∨ ⇑d x y)
theorem basis.det_smul_mk_coord_eq_det_update {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {ι : Type u_4} [decidable_eq ι] [fintype ι] (e : basis ι R M) {v : ι → M} (hli : linear_independent R v) (hsp : submodule.span R (set.range v) = ⊤) (i : ι) : ⇑(e.det) v • (basis.mk hli hsp).coord i = e.det.to_multilinear_map.to_linear_map v i
theorem finset.exists_subset_of_mem_up_shadow {α : Type u_1} [decidable_eq α] [fintype α] {𝒜 : finset (finset α)} {s : finset α} (hs : s ∈ 𝒜.up_shadow) : ∃ (t : finset α) (H : t ∈ 𝒜), t ⊆ s
theorem category_theory.limits.types.pi_map_π_apply {β : Type u} {f g : β → Type u} (α : Π (j : β), f j ⟶ g j) (b : β) (x : ∏ λ (j : β), f j) : category_theory.limits.pi.π g b (category_theory.limits.pi.map α x) = α b (category_theory.limits.pi.π f b x)
theorem measure_theory.strongly_measurable.measurable {α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] [topological_space.pseudo_metrizable_space β] [measurable_space β] [borel_space β] (hf : measure_theory.strongly_measurable f) : measurable f
theorem mv_polynomial.is_domain_fintype (R : Type u) (σ : Type v) [comm_ring R] [fintype σ] [is_domain R] : is_domain (mv_polynomial σ R)
theorem multiset.mem_antidiagonal {α : Type u_1} {s : multiset α} {x : multiset α × multiset α} : x ∈ s.antidiagonal ↔ x.fst + x.snd = s
theorem polynomial.nat_degree_ne_zero_induction_on {R : Type u} [semiring R] {M : polynomial R → Prop} {f : polynomial R} (f0 : f.nat_degree ≠ 0) (h_C_add : ∀ {a : R} {p : polynomial R}, M p → M (⇑polynomial.C a + p)) (h_add : ∀ {p q : polynomial R}, M p → M q → M (p + q)) (h_monomial : ∀ {n : ℕ} {a : R}, a ≠ 0 → n ≠ 0 → M (⇑(polynomial.monomial n) a)) : M f
theorem add_monoid_algebra.finite_type_iff_fg {R : Type u_1} {M : Type u_2} [add_comm_monoid M] [comm_ring R] [nontrivial R] : algebra.finite_type R (add_monoid_algebra R M) ↔ add_monoid.fg M
theorem finset.sup_coe {α : Type u_1} {β : Type u_2} [semilattice_sup α] [order_bot α] {P : α → Prop} {Pbot : P ⊥} {Psup : ∀ ⦃x y : α⦄, P x → P y → P (x ⊔ y)} (t : finset β) (f : β → {x // P x}) : ↑(t.sup f) = t.sup (λ (x : β), ↑(f x))
theorem finite_dimensional.nonempty_linear_equiv_of_finrank_eq {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {V₂ : Type v'} [add_comm_group V₂] [module K V₂] [finite_dimensional K V] [finite_dimensional K V₂] (cond : finite_dimensional.finrank K V = finite_dimensional.finrank K V₂) : nonempty (V ≃ₗ[K] V₂)
theorem spectrum.map_polynomial_aeval_of_degree_pos {𝕜 : Type u} {A : Type v} [field 𝕜] [ring A] [algebra 𝕜 A] [is_alg_closed 𝕜] (a : A) (p : polynomial 𝕜) (hdeg : 0 < p.degree) : spectrum 𝕜 (⇑(polynomial.aeval a) p) = (λ (k : 𝕜), polynomial.eval k p) '' spectrum 𝕜 a
theorem nnreal.summable_condensed_iff {f : ℕ → nnreal} (hf : ∀ ⦃m n : ℕ⦄, 0 < m → m ≤ n → f n ≤ f m) : summable (λ (k : ℕ), 2 ^ k * f (2 ^ k)) ↔ summable f
theorem antitone_on.map_is_greatest {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {t : set α} (Hf : antitone_on f t) {a : α} : is_greatest t a → is_least (f '' t) (f a)
theorem polynomial.separable_X_pow_sub_C {F : Type u} [field F] {n : ℕ} (a : F) (hn : ↑n ≠ 0) (ha : a ≠ 0) : (polynomial.X ^ n - ⇑polynomial.C a).separable
theorem set.Iio_subset_Iio {α : Type u_1} [preorder α] {a b : α} (h : a ≤ b) : set.Iio a ⊆ set.Iio b
theorem has_compact_support.continuous_convolution_right_of_integrable {𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G → E} {g : G → E'} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 F] (L : E →L[𝕜] E' →L[𝕜] F) [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ F] [complete_space F] [add_group G] [topological_space G] [topological_add_group G] [borel_space G] [topological_space.second_countable_topology G] (hcg : has_compact_support g) (hf : measure_theory.integrable f μ) (hg : continuous g) : continuous (convolution f g L μ)
theorem nat.prime.multiplicity_le_multiplicity_choose_add {p : ℕ} (hp : nat.prime p) (n k : ℕ) : multiplicity p n ≤ multiplicity p (n.choose k) + multiplicity p k
theorem add_con.induction_on {M : Type u_1} [has_add M] {c : add_con M} {C : c.quotient → Prop} (q : c.quotient) (H : ∀ (x : M), C ↑x) : C q
theorem bounded_continuous_function.nnnorm_le {α : Type u} {β : Type v} [topological_space α] [semi_normed_group β] (f : bounded_continuous_function α β) (C : nnreal) : ∥f∥₊ ≤ C ↔ ∀ (x : α), ∥⇑f x∥₊ ≤ C
theorem image_le_of_deriv_right_lt_deriv_boundary' {f f' : ℝ → ℝ} {a b : ℝ} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : ℝ → ℝ} (ha : f a ≤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at B (B' x) (set.Ici x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → f x = B x → f' x < B' x) ⦃x : ℝ⦄ : x ∈ set.Icc a b → f x ≤ B x
theorem polynomial.prod_cyclotomic'_eq_X_pow_sub_one {K : Type u_1} [comm_ring K] [is_domain K] {ζ : K} {n : ℕ} (hpos : 0 < n) (h : is_primitive_root ζ n) : n.divisors.prod (λ (i : ℕ), polynomial.cyclotomic' i K) = polynomial.X ^ n - 1
theorem interval_integral.measure_integral_sub_linear_is_o_of_tendsto_ae_of_ge' {ι : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {c : E} {l l' : filter ℝ} {lt : filter ι} {μ : measure_theory.measure ℝ} {u v : ι → ℝ} [l'.is_measurably_generated] [filter.tendsto_Ixx_class set.Ioc l l'] (hfm : strongly_measurable_at_filter f l' μ) (hf : filter.tendsto f (l' ⊓ μ.ae) (nhds c)) (hl : μ.finite_at_filter l') (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) (huv : v ≤ᶠ[lt] u) : (λ (t : ι), ∫ (x : ℝ) in u t..v t, f x ∂μ + (⇑μ (set.Ioc (v t) (u t))).to_real • c) =o[lt] λ (t : ι), (⇑μ (set.Ioc (v t) (u t))).to_real
theorem quotient_norm_mk_eq {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) : ∥⇑(quotient_add_group.mk' S) m∥ = has_Inf.Inf ((λ (x : M), ∥m + x∥) '' ↑S)
theorem neg_lt_self {α : Type u} [add_group α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a : α} (h : 0 < a) : -a < a
theorem measure_theory.integrable_at_filter.of_inf_ae {α : Type u_1} {E : Type u_3} [measurable_space α] [normed_group E] {f : α → E} {μ : measure_theory.measure α} {l : filter α} : measure_theory.integrable_at_filter f (l ⊓ μ.ae) μ → measure_theory.integrable_at_filter f l μ
theorem submonoid.mul_mem {M : Type u_1} [mul_one_class M] (S : submonoid M) {x y : M} : x ∈ S → y ∈ S → x * y ∈ S
theorem quadratic_form.basis_repr_eq_of_is_Ortho {M : Type u_3} [add_comm_group M] {R₁ : Type u_4} [comm_ring R₁] [module R₁ M] {ι : Type u_6} [fintype ι] [invertible 2] (Q : quadratic_form R₁ M) (v : basis ι R₁ M) (hv₂ : (⇑quadratic_form.associated Q).is_Ortho ⇑v) : Q.basis_repr v = quadratic_form.weighted_sum_squares R₁ (λ (i : ι), ⇑Q (⇑v i))
theorem asymptotics.is_o.forall_is_O_with {α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : α → E} {g : α → F} {l : filter α} : f =o[l] g → ∀ ⦃c : ℝ⦄, 0 < c → asymptotics.is_O_with c l f g
theorem is_compact.measure_lt_top {α : Type u_1} {m0 : measurable_space α} [topological_space α] {μ : measure_theory.measure α} [measure_theory.is_finite_measure_on_compacts μ] ⦃K : set α⦄ (hK : is_compact K) : ⇑μ K < ⊤
theorem add_subsemigroup.closure_induction₂ {M : Type u_1} [has_add M] {s : set M} {p : M → M → Prop} {x y : M} (hx : x ∈ add_subsemigroup.closure s) (hy : y ∈ add_subsemigroup.closure s) (Hs : ∀ (x : M), x ∈ s → ∀ (y : M), y ∈ s → p x y) (Hmul_left : ∀ (x y z : M), p x z → p y z → p (x + y) z) (Hmul_right : ∀ (x y z : M), p z x → p z y → p z (x + y)) : p x y
theorem pgame.le_iff_forall_lt {x y : pgame} (ox : x.numeric) (oy : y.numeric) : x ≤ y ↔ (∀ (i : x.left_moves), x.move_left i < y) ∧ ∀ (j : y.right_moves), x < y.move_right j
theorem vsub_right_injective {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (has_vsub.vsub p)
theorem function.injective.no_zero_smul_divisors {R : Type u_1} {M : Type u_2} {N : Type u_3} [has_zero R] [has_zero M] [has_zero N] [has_scalar R M] [has_scalar R N] [no_zero_smul_divisors R N] (f : M → N) (hf : function.injective f) (h0 : f 0 = 0) (hs : ∀ (c : R) (x : M), f (c • x) = c • f x) : no_zero_smul_divisors R M
theorem exists_has_deriv_at_eq_slope (f f' : ℝ → ℝ) {a b : ℝ} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x) : ∃ (c : ℝ) (H : c ∈ set.Ioo a b), f' c = (f b - f a) / (b - a)
theorem affine_subspace.mk'_nonempty {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) (direction : submodule k V) : ↑(affine_subspace.mk' p direction).nonempty
theorem trans_gen_of_pred_of_lt {α : Type u_1} [partial_order α] [pred_order α] [is_pred_archimedean α] (r : α → α → Prop) {n m : α} (h : ∀ (i : α), i ∈ set.Ioc n m → r (order.pred i) i) (hmn : n < m) : relation.trans_gen r n m
theorem truncated_witt_vector.commutes_symm (p : ℕ) [hp : fact (nat.prime p)] (n : ℕ) {m : ℕ} (hm : n ≤ m) : (truncated_witt_vector.zmod_equiv_trunc p n).symm.to_ring_hom.comp (truncated_witt_vector.truncate hm) = (zmod.cast_hom _ (zmod (p ^ n))).comp (truncated_witt_vector.zmod_equiv_trunc p m).symm.to_ring_hom
theorem local_homeomorph.continuous_iff_continuous_comp_left {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] (e : local_homeomorph α β) {f : γ → α} (h : f ⁻¹' e.to_local_equiv.source = set.univ) : continuous f ↔ continuous (⇑e ∘ f)
theorem nat.fib_add_two {n : ℕ} : nat.fib (n + 2) = nat.fib n + nat.fib (n + 1)
theorem continuous_map.dist_le_two_norm {α : Type u_1} {E : Type u_3} [topological_space α] [compact_space α] [normed_group E] (f : C(α, E)) (x y : α) : has_dist.dist (⇑f x) (⇑f y) ≤ 2 * ∥f∥
theorem is_semiring_hom.to_is_monoid_hom {α : Type u} {β : Type v} [semiring α] [semiring β] {f : α → β} (hf : is_semiring_hom f) : is_monoid_hom f
theorem measure_theory.strongly_measurable.integral_prod_right' {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {ν : measure_theory.measure β} [normed_group E] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite ν] ⦃f : α × β → E⦄ (hf : measure_theory.strongly_measurable f) : measure_theory.strongly_measurable (λ (x : α), ∫ (y : β), f (x, y) ∂ν)
theorem inner_product_space.is_self_adjoint_iff_inner_map_self_real {V : Type u_4} [inner_product_space ℂ V] (T : V →ₗ[ℂ] V) : inner_product_space.is_self_adjoint T ↔ ∀ (v : V), ⇑(star_ring_end ℂ) (has_inner.inner (⇑T v) v) = has_inner.inner (⇑T v) v
theorem first_order.language.direct_limit.exists_of {L : first_order.language} {ι : Type v} [preorder ι] {G : ι → Type w} [Π (i : ι), L.Structure (G i)] {f : Π (i j : ι), i ≤ j → L.embedding (G i) (G j)} [is_directed ι has_le.le] [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] [nonempty ι] (z : first_order.language.direct_limit G f) : ∃ (i : ι) (x : G i), ⇑(first_order.language.direct_limit.of L ι G f i) x = z
theorem affine_subspace.direction_inf_of_mem_inf {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s₁ s₂ : affine_subspace k P} {p : P} (h : p ∈ s₁ ⊓ s₂) : (s₁ ⊓ s₂).direction = s₁.direction ⊓ s₂.direction
theorem affine_subspace.coe_direction_eq_vsub_set {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} (h : ↑s.nonempty) : ↑(s.direction) = ↑s -ᵥ ↑s
theorem subtype.is_empty_of_false {α : Sort u_1} {p : α → Prop} (hp : ∀ (a : α), ¬p a) : is_empty (subtype p)
theorem polynomial.irreducible_has_separable_contraction {F : Type} [field F] (q : ℕ) [hF : exp_char F q] (f : polynomial F) [irred : irreducible f] : polynomial.has_separable_contraction q f
theorem cont_diff_within_at.comp {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {n : with_top ℕ} {s : set E} {t : set F} {g : F → G} {f : E → F} (x : E) (hg : cont_diff_within_at 𝕜 n g t (f x)) (hf : cont_diff_within_at 𝕜 n f s x) (st : s ⊆ f ⁻¹' t) : cont_diff_within_at 𝕜 n (g ∘ f) s x
theorem convex.ord_connected {𝕜 : Type u_1} [linear_ordered_field 𝕜] {s : set 𝕜} : convex 𝕜 s → s.ord_connected
theorem measure_theory.outer_measure.trim_supr {α : Type u_1} [measurable_space α] {ι : Type u_2} [encodable ι] (μ : ι → measure_theory.outer_measure α) : (⨆ (i : ι), μ i).trim = ⨆ (i : ι), (μ i).trim
theorem module.free.rank_prod (R : Type u) (M : Type v) (N : Type w) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] [add_comm_group N] [module R N] [module.free R N] : module.rank R (M × N) = (module.rank R M).lift + (module.rank R N).lift
theorem orthonormal.rotation_eq_self_iff {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x : V) (θ : real.angle) : ⇑(hb.rotation θ) x = x ↔ x = 0 ∨ θ = 0
theorem nonarchimedean_group.prod_subset {G : Type u_1} [group G] [topological_space G] [nonarchimedean_group G] {K : Type u_3} [group K] [topological_space K] [nonarchimedean_group K] {U : set (G × K)} (hU : U ∈ nhds 1) : ∃ (V : open_subgroup G) (W : open_subgroup K), ↑V ×ˢ ↑W ⊆ U
theorem spectrum.limsup_pow_nnnorm_pow_one_div_le_spectral_radius {A : Type u_2} [normed_ring A] [normed_algebra ℂ A] [complete_space A] (a : A) : filter.at_top.limsup (λ (n : ℕ), ↑∥a ^ n∥₊ ^ (1 / ↑n)) ≤ spectral_radius ℂ a
theorem measure_theory.simple_func.lintegral_eq_of_measure_preimage {α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [measurable_space β] {f : measure_theory.simple_func α ennreal} {g : measure_theory.simple_func β ennreal} {ν : measure_theory.measure β} (H : ∀ (y : ennreal), ⇑μ (⇑f ⁻¹' {y}) = ⇑ν (⇑g ⁻¹' {y})) : f.lintegral μ = g.lintegral ν
theorem algebra.algebra_ext {R : Type u_1} [comm_semiring R] {A : Type u_2} [semiring A] (P Q : algebra R A) (w : ∀ (r : R), ⇑(algebra_map R A) r = ⇑(algebra_map R A) r) : P = Q
theorem besicovitch.tendsto_filter_at {α : Type u_1} [metric_space α] [topological_space.second_countable_topology α] [measurable_space α] [opens_measurable_space α] [has_besicovitch_covering α] (μ : measure_theory.measure α) [measure_theory.sigma_finite μ] (x : α) : filter.tendsto (λ (r : ℝ), metric.closed_ball x r) (nhds_within 0 (set.Ioi 0)) ((besicovitch.vitali_family μ).filter_at x)
theorem exponent_exists.is_torsion {G : Type u_1} [group G] (h : monoid.exponent_exists G) : monoid.is_torsion G
theorem asymptotics.is_O_with.neg_left {α : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {c : ℝ} {g : α → F} {f' : α → E'} {l : filter α} : asymptotics.is_O_with c l f' g → asymptotics.is_O_with c l (λ (x : α), -f' x) g
theorem topological_semiring_of_smooth {𝕜 : Type u_1} {R : Type u_2} {E : Type u_3} {H : Type u_4} [topological_space R] [topological_space H] [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [charted_space H R] (I : model_with_corners 𝕜 E H) [semiring R] [smooth_ring I R] : topological_semiring R
theorem add_submonoid.zero_mem {M : Type u_1} [add_zero_class M] (S : add_submonoid M) : 0 ∈ S
theorem continuous.bdd_above_range_of_has_compact_support {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_closed_topology α] [nonempty α] [topological_space β] [has_zero α] {f : β → α} (hf : continuous f) (h : has_compact_support f) : bdd_above (set.range f)
theorem simple_graph.is_clique.subsingleton {α : Type u_1} {s : set α} : ⊥.is_clique s → s.subsingleton
theorem has_fderiv_at.lim {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {x : E} (hf : has_fderiv_at f f' x) (v : E) {α : Type u_4} {c : α → 𝕜} {l : filter α} (hc : filter.tendsto (λ (n : α), ∥c n∥) l filter.at_top) : filter.tendsto (λ (n : α), c n • (f (x + (c n)⁻¹ • v) - f x)) l (nhds (⇑f' v))
theorem measure_theory.outer_measure.trim_op {α : Type u_1} [measurable_space α] {m₁ m₂ : measure_theory.outer_measure α} {op : ennreal → ennreal} (h : ∀ (s : set α), ⇑m₁ s = op (⇑m₂ s)) (s : set α) : ⇑(m₁.trim) s = op (⇑(m₂.trim) s)
theorem quadratic_form.nondegenerate_of_anisotropic {R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] [invertible 2] (Q : quadratic_form R M) (hB : Q.anisotropic) : (⇑quadratic_form.associated' Q).nondegenerate
theorem linear_equiv.det_coe_symm {M : Type u_2} [add_comm_group M] {𝕜 : Type u_1} [field 𝕜] [module 𝕜 M] (f : M ≃ₗ[𝕜] M) : ⇑linear_map.det ↑(f.symm) = (⇑linear_map.det ↑f)⁻¹
theorem thickened_indicator_aux_tendsto_indicator_closure {α : Type u_1} [pseudo_emetric_space α] {δseq : ℕ → ℝ} (δseq_lim : filter.tendsto δseq filter.at_top (nhds 0)) (E : set α) : filter.tendsto (λ (n : ℕ), thickened_indicator_aux (δseq n) E) filter.at_top (nhds ((closure E).indicator (λ (x : α), 1)))
theorem t2_separation {α : Type u} [topological_space α] [t2_space α] {x y : α} (h : x ≠ y) : ∃ (u v : set α), is_open u ∧ is_open v ∧ x ∈ u ∧ y ∈ v ∧ u ∩ v = ∅
theorem algebra.finite_type.iff_quotient_mv_polynomial'' {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_type R A ↔ ∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), function.surjective ⇑f
theorem vsub_right_cancel {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] {p1 p2 p : P} (h : p -ᵥ p1 = p -ᵥ p2) : p1 = p2
theorem measure_theory.add_haar_image_eq_zero_of_differentiable_on_of_add_haar_eq_zero {E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {s : set E} {f : E → E} [measurable_space E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (hf : differentiable_on ℝ f s) (hs : ⇑μ s = 0) : ⇑μ (f '' s) = 0
theorem convex.integral_mem {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {f : α → E} [measure_theory.is_probability_measure μ] (hs : convex ℝ s) (hsc : is_closed s) (hf : ∀ᵐ (x : α) ∂μ, f x ∈ s) (hfi : measure_theory.integrable f μ) : ∫ (x : α), f x ∂μ ∈ s
theorem tactic.ring_exp.sum_congr {α : Type u} [comm_semiring α] {p p' ps ps' : α} : p = p' → ps = ps' → p + ps = p' + ps'
theorem finsupp.sum_map_domain_index_add_monoid_hom {α : Type u_1} {β : Type u_2} {M : Type u_5} {N : Type u_7} [add_comm_monoid M] [add_comm_monoid N] {f : α → β} {s : α →₀ M} (h : β → M →+ N) : (finsupp.map_domain f s).sum (λ (b : β) (m : M), ⇑(h b) m) = s.sum (λ (a : α) (m : M), ⇑(h (f a)) m)
theorem mul_sub_lt_image_sub_of_lt_deriv {f : ℝ → ℝ} (hf : differentiable ℝ f) {C : ℝ} (hf'_gt : ∀ (x : ℝ), C < deriv f x) ⦃x y : ℝ⦄ (hxy : x < y) : C * (y - x) < f y - f x
theorem nat.eq_one_of_dvd_coprimes {a b k : ℕ} (h_ab_coprime : a.coprime b) (hka : k ∣ a) (hkb : k ∣ b) : k = 1
theorem is_compact.cthickening_eq_bUnion_closed_ball {α : Type u_1} [pseudo_metric_space α] {δ : ℝ} {E : set α} (hE : is_compact E) (hδ : 0 ≤ δ) : metric.cthickening δ E = ⋃ (x : α) (H : x ∈ E), metric.closed_ball x δ
theorem finset.mem_slice {α : Type u_1} {𝒜 : finset (finset α)} {A : finset α} {r : ℕ} : A ∈ 𝒜.slice r ↔ A ∈ 𝒜 ∧ A.card = r
theorem affine_independent.vector_span_eq_of_le_of_card_eq_finrank_add_one {k : Type u_1} {V : Type u_2} {P : Type u_3} {ι : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype ι] {p : ι → P} (hi : affine_independent k p) {sm : submodule k V} [finite_dimensional k ↥sm] (hle : vector_span k (set.range p) ≤ sm) (hc : fintype.card ι = finite_dimensional.finrank k ↥sm + 1) : vector_span k (set.range p) = sm
theorem generalized_continued_fraction.comp_exact_value_correctness_of_stream_eq_some {K : Type u_1} [linear_ordered_field K] {v : K} {n : ℕ} [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n → v = generalized_continued_fraction.comp_exact_value ((generalized_continued_fraction.of v).continuants_aux n) ((generalized_continued_fraction.of v).continuants_aux (n + 1)) ifp_n.fr
theorem category_theory.limits.kernel_subobject_comp_mono {C : Type u} [category_theory.category C] {X Y : C} [category_theory.limits.has_zero_morphisms C] (f : X ⟶ Y) [category_theory.limits.has_kernel f] {Z : C} (h : Y ⟶ Z) [category_theory.mono h] : category_theory.limits.kernel_subobject (f ≫ h) = category_theory.limits.kernel_subobject f
theorem add_con.map_apply {M : Type u_1} [add_zero_class M] {c d : add_con M} (h : c ≤ d) (x : c.quotient) : ⇑(c.map d h) x = ⇑(c.lift d.mk' _) x
theorem subgroup.fg_iff {G : Type u_3} [group G] (P : subgroup G) : P.fg ↔ ∃ (S : set G), subgroup.closure S = P ∧ S.finite
theorem finset.image₂_congr' {α : Type u_1} {β : Type u_3} {γ : Type u_5} [decidable_eq γ] {f f' : α → β → γ} {s : finset α} {t : finset β} (h : ∀ (a : α) (b : β), f a b = f' a b) : finset.image₂ f s t = finset.image₂ f' s t
theorem local_equiv.is_image.preimage_eq {α : Type u_1} {β : Type u_2} {e : local_equiv α β} {s : set α} {t : set β} : e.is_image s t → e.source ∩ ⇑e ⁻¹' t = e.source ∩ s
theorem linear_map.bound_of_ball_bound {𝕜 : Type u_1} {E : Type u_4} {Fₗ : Type u_7} [normed_group E] [normed_group Fₗ] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 Fₗ] {r : ℝ} (r_pos : 0 < r) (c : ℝ) (f : E →ₗ[𝕜] Fₗ) (h : ∀ (z : E), z ∈ metric.ball 0 r → ∥⇑f z∥ ≤ c) : ∃ (C : ℝ), ∀ (z : E), ∥⇑f z∥ ≤ C * ∥z∥
theorem continuous.Icc_extend {α : Type u_1} {β : Type u_2} {γ : Type u_3} [linear_order α] [topological_space γ] {a b : α} {h : a ≤ b} [topological_space α] [order_topology α] [topological_space β] {f : γ → ↥(set.Icc a b) → β} {g : γ → α} (hf : continuous ↿f) (hg : continuous g) : continuous (λ (a_1 : γ), set.Icc_extend h (f a_1) (g a_1))
theorem subgroup.bot_or_nontrivial {G : Type u_1} [group G] (H : subgroup G) : H = ⊥ ∨ nontrivial ↥H
theorem is_smul_regular_of_group {R : Type u_1} {G : Type u_4} [group G] [mul_action G R] (g : G) : is_smul_regular R g
theorem linear_isometry_equiv.reflections_generate_dim_aux {F : Type u_3} [inner_product_space ℝ F] [finite_dimensional ℝ F] {n : ℕ} (φ : F ≃ₗᵢ[ℝ] F) (hn : finite_dimensional.finrank ℝ ↥((continuous_linear_map.id ℝ F - ↑(φ.to_continuous_linear_equiv)).ker)ᗮ ≤ n) : ∃ (l : list F), l.length ≤ n ∧ φ = (list.map (λ (v : F), reflection (submodule.span ℝ {v})ᗮ) l).prod
theorem is_add_hom.comp {α : Type u} {β : Type v} [has_add α] [has_add β] {γ : Type u_1} [has_add γ] {f : α → β} {g : β → γ} (hf : is_add_hom f) (hg : is_add_hom g) : is_add_hom (g ∘ f)
theorem finprod_mem_image {α : Type u_1} {β : Type u_2} {M : Type u_5} [comm_monoid M] {f : α → M} {s : set β} {g : β → α} (hg : set.inj_on g s) : finprod (λ (i : α), finprod (λ (H : i ∈ g '' s), f i)) = finprod (λ (j : β), finprod (λ (H : j ∈ s), f (g j)))
theorem lipschitz_with.holder_with {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C : nnreal} {f : X → Y} : lipschitz_with C f → holder_with C 1 f
theorem matrix.pivot.list_transvec_col_mul_mul_list_transvec_row_last_row {𝕜 : Type u_3} [field 𝕜] {r : ℕ} (M : matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜) (hM : M (sum.inr ()) (sum.inr ()) ≠ 0) (i : fin r) : ((matrix.pivot.list_transvec_col M).prod.mul M).mul (matrix.pivot.list_transvec_row M).prod (sum.inl i) (sum.inr ()) = 0
theorem lipschitz_with.dimH_image_le {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X → Y} (h : lipschitz_with K f) (s : set X) : dimH (f '' s) ≤ dimH s
theorem refl_trans_gen_of_pred_of_le {α : Type u_1} [partial_order α] [pred_order α] [is_pred_archimedean α] (r : α → α → Prop) {n m : α} (h : ∀ (i : α), i ∈ set.Ioc n m → r (order.pred i) i) (hmn : n ≤ m) : relation.refl_trans_gen r n m
theorem finset.sum_comm' {β : Type u} {α : Type v} {γ : Type w} [add_comm_monoid β] {s : finset γ} {t : γ → finset α} {t' : finset α} {s' : α → finset γ} (h : ∀ (x : γ) (y : α), x ∈ s ∧ y ∈ t x ↔ x ∈ s' y ∧ y ∈ t') {f : γ → α → β} : s.sum (λ (x : γ), (t x).sum (λ (y : α), f x y)) = t'.sum (λ (y : α), (s' y).sum (λ (x : γ), f x y))
theorem category_theory.limits.has_wide_coequalizers_of_has_colimit_parallel_family (C : Type u) [category_theory.category C] [∀ {J : Type v} {X Y : C} {f : J → (X ⟶ Y)}, category_theory.limits.has_colimit (category_theory.limits.parallel_family f)] : category_theory.limits.has_wide_coequalizers C
theorem antivary.sum_mul_le_sum_mul_comp_perm {ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {σ : equiv.perm ι} {f g : ι → α} [fintype ι] (hfg : antivary f g) : finset.univ.sum (λ (i : ι), f i * g i) ≤ finset.univ.sum (λ (i : ι), f i * g (⇑σ i))
theorem filter.is_bounded_under_of {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {f : filter β} {u : β → α} : (∃ (b : α), ∀ (x : β), r (u x) b) → filter.is_bounded_under r f u
theorem linear_recurrence.sol_space_dim {α : Type u_1} [field α] (E : linear_recurrence α) : module.rank α ↥(E.sol_space) = ↑(E.order)
theorem mul_le_one' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1
theorem multilinear_map.comp_linear_map_assoc {R : Type u} {ι : Type u'} {M₁ : ι → Type v₁} {M₂ : Type v₂} [decidable_eq ι] [semiring R] [Π (i : ι), add_comm_monoid (M₁ i)] [add_comm_monoid M₂] [Π (i : ι), module R (M₁ i)] [module R M₂] {M₁' : ι → Type u_1} [Π (i : ι), add_comm_monoid (M₁' i)] [Π (i : ι), module R (M₁' i)] {M₁'' : ι → Type u_2} [Π (i : ι), add_comm_monoid (M₁'' i)] [Π (i : ι), module R (M₁'' i)] (g : multilinear_map R M₁'' M₂) (f₁ : Π (i : ι), M₁' i →ₗ[R] M₁'' i) (f₂ : Π (i : ι), M₁ i →ₗ[R] M₁' i) : (g.comp_linear_map f₁).comp_linear_map f₂ = g.comp_linear_map (λ (i : ι), (f₁ i).comp (f₂ i))
theorem is_fraction_ring.char_p_of_is_fraction_ring (R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] (p : ℕ) [char_p R p] : char_p K p
theorem vector_span_eq_span_vsub_set_left_ne (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p : P} (hp : p ∈ s) : vector_span k s = submodule.span k (has_vsub.vsub p '' (s  {p}))
theorem exp_neg_inv_glue.f_aux_iterated_deriv (n : ℕ) : iterated_deriv n (exp_neg_inv_glue.f_aux 0) = exp_neg_inv_glue.f_aux n
theorem interval_integral.integral_has_strict_deriv_at_left {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (ha : continuous_at f a) : has_strict_deriv_at (λ (u : ℝ), ∫ (x : ℝ) in u..b, f x) (-f a) a
theorem category_theory.limits.is_limit.hom_ext {J : Type u₁} [category_theory.category J] {C : Type u₃} [category_theory.category C] {F : J ⥤ C} {t : category_theory.limits.cone F} (h : category_theory.limits.is_limit t) {W : C} {f f' : W ⟶ t.X} (w : ∀ (j : J), f ≫ t.π.app j = f' ≫ t.π.app j) : f = f'
theorem list.split_on_p_eq_single {α : Type u} (p : α → Prop) [decidable_pred p] (xs : list α) (h : ∀ (x : α), x ∈ xs → ¬p x) : list.split_on_p p xs = [xs]
theorem inner_orthogonal_projection_left_eq_right {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) [complete_space E] [complete_space ↥K] (u v : E) : has_inner.inner ↑(⇑(orthogonal_projection K) u) v = has_inner.inner u ↑(⇑(orthogonal_projection K) v)
theorem refinement_of_locally_compact_sigma_compact_of_nhds_basis {X : Type v} [topological_space X] [locally_compact_space X] [sigma_compact_space X] [t2_space X] {ι : X → Type u} {p : Π (x : X), ι x → Prop} {B : Π (x : X), ι x → set X} (hB : ∀ (x : X), (nhds x).has_basis (p x) (B x)) : ∃ (α : Type v) (c : α → X) (r : Π (a : α), ι (c a)), (∀ (a : α), p (c a) (r a)) ∧ (⋃ (a : α), B (c a) (r a)) = set.univ ∧ locally_finite (λ (a : α), B (c a) (r a))
theorem subgroup.supr_induction {G : Type u_1} [group G] {ι : Sort u_2} (S : ι → subgroup G) {C : G → Prop} {x : G} (hx : x ∈ ⨆ (i : ι), S i) (hp : ∀ (i : ι) (x : G), x ∈ S i → C x) (h1 : C 1) (hmul : ∀ (x y : G), C x → C y → C (x * y)) : C x
theorem real_inner_mul_inner_self_le {F : Type u_3} [inner_product_space ℝ F] (x y : F) : has_inner.inner x y * has_inner.inner x y ≤ has_inner.inner x x * has_inner.inner y y
theorem monovary_on.sum_mul_comp_perm_lt_sum_mul_iff {ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {s : finset ι} {σ : equiv.perm ι} {f g : ι → α} (hfg : monovary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i • g (⇑σ i)) < s.sum (λ (i : ι), f i • g i) ↔ ¬monovary_on f (g ∘ ⇑σ) ↑s
theorem measurable_set.image_of_continuous_on_inj_on {γ : Type u_3} [tγ : topological_space γ] [polish_space γ] [measurable_space γ] [borel_space γ] {β : Type u_4} [tβ : topological_space β] [t2_space β] [measurable_space β] [borel_space β] {s : set γ} {f : γ → β} (hs : measurable_set s) (f_cont : continuous_on f s) (f_inj : set.inj_on f s) : measurable_set (f '' s)
theorem finsum_mem_union_inter' {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} {s t : set α} (hs : (s ∩ function.support f).finite) (ht : (t ∩ function.support f).finite) : finsum (λ (i : α), finsum (λ (H : i ∈ s ∪ t), f i)) + finsum (λ (i : α), finsum (λ (H : i ∈ s ∩ t), f i)) = finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) + finsum (λ (i : α), finsum (λ (H : i ∈ t), f i))
theorem complex.integral_boundary_rect_of_has_fderiv_at_real_off_countable {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] (f : ℂ → E) (f' : ℂ → (ℂ →L[ℝ] E)) (z w : ℂ) (s : set ℂ) (hs : s.countable) (Hc : continuous_on f (set.interval z.re w.re ×ℂ set.interval z.im w.im)) (Hd : ∀ (x : ℂ), x ∈ set.Ioo (linear_order.min z.re w.re) (linear_order.max z.re w.re) ×ℂ set.Ioo (linear_order.min z.im w.im) (linear_order.max z.im w.im)  s → has_fderiv_at f (f' x) x) (Hi : measure_theory.integrable_on (λ (z : ℂ), complex.I • ⇑(f' z) 1 - ⇑(f' z) complex.I) (set.interval z.re w.re ×ℂ set.interval z.im w.im) measure_theory.measure_space.volume) : (((∫ (x : ℝ) in z.re..w.re, f (↑x + ↑(z.im) * complex.I)) - ∫ (x : ℝ) in z.re..w.re, f (↑x + ↑(w.im) * complex.I)) + complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑(w.re) + ↑y * complex.I)) - complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑(z.re) + ↑y * complex.I) = ∫ (x : ℝ) in z.re..w.re, ∫ (y : ℝ) in z.im..w.im, complex.I • ⇑(f' (↑x + ↑y * complex.I)) 1 - ⇑(f' (↑x + ↑y * complex.I)) complex.I
theorem inv_le_one' {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a
theorem quadratic_form.exists_quadratic_form_ne_zero {R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] [invertible 2] {Q : quadratic_form R M} (hB₁ : ⇑quadratic_form.associated' Q ≠ 0) : ∃ (x : M), ⇑Q x ≠ 0
theorem emetric.diam_union {α : Type u} [pseudo_emetric_space α] {x y : α} {s t : set α} (xs : x ∈ s) (yt : y ∈ t) : emetric.diam (s ∪ t) ≤ emetric.diam s + has_edist.edist x y + emetric.diam t
theorem ideal.quotient_map_injective' {R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] {J : ideal R} {I : ideal S} {f : R →+* S} {H : J ≤ ideal.comap f I} (h : ideal.comap f I ≤ J) : function.injective ⇑(I.quotient_map f H)
theorem continuous_linear_map.op_nnnorm_le_bound {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [ring_hom_isometric σ₁₂] (f : E →SL[σ₁₂] F) (M : nnreal) (hM : ∀ (x : E), ∥⇑f x∥₊ ≤ M * ∥x∥₊) : ∥f∥₊ ≤ M
theorem phragmen_lindelof.eq_on_quadrant_IV {E : Type u_1} [normed_group E] [normed_space ℂ E] {f g : ℂ → E} (hdf : diff_cont_on_cl ℂ f (set.Ioi 0 ×ℂ set.Iio 0)) (hBf : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ filter.principal (set.Ioi 0 ×ℂ set.Iio 0)] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hdg : diff_cont_on_cl ℂ g (set.Ioi 0 ×ℂ set.Iio 0)) (hBg : ∃ (c : ℝ) (H : c < 2) (B : ℝ), g =O[filter.comap complex.abs filter.at_top ⊓ filter.principal (set.Ioi 0 ×ℂ set.Iio 0)] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hre : ∀ (x : ℝ), 0 ≤ x → f ↑x = g ↑x) (him : ∀ (x : ℝ), x ≤ 0 → f (↑x * complex.I) = g (↑x * complex.I)) : set.eq_on f g {z : ℂ | 0 ≤ z.re ∧ z.im ≤ 0}
theorem monoid_with_zero_hom.ext_rat_on_pnat {M : Type u_4} [group_with_zero M] {f g : ℚ →*₀ M} (same_on_neg_one : ⇑f (-1) = ⇑g (-1)) (same_on_pnat : ∀ (n : ℕ), 0 < n → ⇑f ↑n = ⇑g ↑n) : f = g
theorem local_equiv.trans_self_symm {α : Type u_1} {β : Type u_2} (e : local_equiv α β) : e.trans e.symm ≈ local_equiv.of_set e.source
theorem is_fraction_ring.is_domain (A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] : is_domain K
theorem cross_dot_cross {R : Type u_1} [comm_ring R] (u v w x : fin 3 → R) : matrix.dot_product (⇑(⇑cross_product u) v) (⇑(⇑cross_product w) x) = matrix.dot_product u w * matrix.dot_product v x - matrix.dot_product u x * matrix.dot_product v w
theorem ennreal.rpow_sum_le_const_mul_sum_rpow {ι : Type u} (s : finset ι) (f : ι → ennreal) {p : ℝ} (hp : 1 ≤ p) : s.sum (λ (i : ι), f i) ^ p ≤ ↑(s.card) ^ (p - 1) * s.sum (λ (i : ι), f i ^ p)
theorem sub_mul_action.stabilizer_of_sub_mul {R : Type u} {M : Type v} [group R] [mul_action R M] {p : sub_mul_action R M} (m : ↥p) : mul_action.stabilizer R m = mul_action.stabilizer R ↑m
theorem module.finite.of_basis {R : Type u_1} {M : Type u_2} {ι : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [fintype ι] (b : basis ι R M) : module.finite R M
theorem category_theory.abelian.pseudoelement.zero_morphism_ext {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P ⟶ Q) : (∀ (a : ↥P), ⇑f a = 0) → f = 0
theorem category_theory.abelian.epi_of_epi_of_epi_of_mono {V : Type u} [category_theory.category V] [category_theory.abelian V] {A B C D A' B' C' D' : V} {f : A ⟶ B} {g : B ⟶ C} {h : C ⟶ D} {f' : A' ⟶ B'} {g' : B' ⟶ C'} {h' : C' ⟶ D'} {α : A ⟶ A'} {β : B ⟶ B'} {γ : C ⟶ C'} {δ : D ⟶ D'} (comm₁ : α ≫ f' = f ≫ β) (comm₂ : β ≫ g' = g ≫ γ) (comm₃ : γ ≫ h' = h ≫ δ) (hgh : category_theory.exact g h) (hf'g' : category_theory.exact f' g') (hg'h' : category_theory.exact g' h') (hα : category_theory.epi α) (hγ : category_theory.epi γ) (hδ : category_theory.mono δ) : category_theory.epi β
theorem is_right_regular.of_mul {R : Type u_1} {a b : R} [semigroup R] (ab : is_right_regular (b * a)) : is_right_regular b
theorem add_equiv.ext {M : Type u_6} {N : Type u_7} [has_add M] [has_add N] {f g : M ≃+ N} (h : ∀ (x : M), ⇑f x = ⇑g x) : f = g
theorem nat.pow_le_iff_le_log {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : 0 < y) : b ^ x ≤ y ↔ x ≤ nat.log b y
theorem compact_space_uniformity {α : Type u_1} [uniform_space α] [compact_space α] [separated_space α] : uniformity α = ⨆ (x : α), nhds (x, x)
theorem image_le_of_deriv_right_le_deriv_boundary {f f' : ℝ → ℝ} {a b : ℝ} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : ℝ → ℝ} (ha : f a ≤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at B (B' x) (set.Ici x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → f' x ≤ B' x) ⦃x : ℝ⦄ : x ∈ set.Icc a b → f x ≤ B x
theorem is_p_group.disjoint_of_ne {G : Type u_1} [group G] (p₁ p₂ : ℕ) [hp₁ : fact (nat.prime p₁)] [hp₂ : fact (nat.prime p₂)] (hne : p₁ ≠ p₂) (H₁ H₂ : subgroup G) (hH₁ : is_p_group p₁ ↥H₁) (hH₂ : is_p_group p₂ ↥H₂) : disjoint H₁ H₂
theorem finset.subset_sub {α : Type u_2} [decidable_eq α] [has_sub α] {u : finset α} {s t : set α} : ↑u ⊆ s - t → (∃ (s' t' : finset α), ↑s' ⊆ s ∧ ↑t' ⊆ t ∧ u ⊆ s' - t')
theorem antivary.sum_mul_lt_sum_mul_comp_perm_iff {ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {σ : equiv.perm ι} {f g : ι → α} [fintype ι] (hfg : antivary f g) : finset.univ.sum (λ (i : ι), f i • g i) < finset.univ.sum (λ (i : ι), f i • g (⇑σ i)) ↔ ¬antivary f (g ∘ ⇑σ)
theorem denoms_clearable_nat_degree {R : Type u_1} {K : Type u_2} [semiring R] [comm_semiring K] {b : R} {bi : K} (i : R →+* K) (f : polynomial R) (a : R) (bu : bi * ⇑i b = 1) : denoms_clearable a b f.nat_degree f i
theorem int.subgroup_cyclic (H : add_subgroup ℤ) : ∃ (a : ℤ), H = add_subgroup.closure {a}
theorem polynomial.X_mul {R : Type u} [semiring R] {p : polynomial R} : polynomial.X * p = p * polynomial.X
theorem matrix.is_diag.from_blocks_of_is_symm {α : Type u_1} {n : Type u_4} {m : Type u_5} [has_zero α] {A : matrix m m α} {C : matrix n m α} {D : matrix n n α} (h : (matrix.from_blocks A 0 C D).is_symm) (ha : A.is_diag) (hd : D.is_diag) : (matrix.from_blocks A 0 C D).is_diag
theorem jacobi_cross {R : Type u_1} [comm_ring R] (u v w : fin 3 → R) : ⇑(⇑cross_product u) (⇑(⇑cross_product v) w) + ⇑(⇑cross_product v) (⇑(⇑cross_product w) u) + ⇑(⇑cross_product w) (⇑(⇑cross_product u) v) = 0
theorem antivary.sum_smul_eq_sum_smul_comp_perm_iff {ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {σ : equiv.perm ι} {f : ι → α} {g : ι → β} [fintype ι] (hfg : antivary f g) : finset.univ.sum (λ (i : ι), f i • g (⇑σ i)) = finset.univ.sum (λ (i : ι), f i • g i) ↔ antivary f (g ∘ ⇑σ)
theorem shrinking_lemma.partial_refinement.apply_eq_of_chain {ι : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : ι → set X} {s : set X} {c : set (shrinking_lemma.partial_refinement u s)} (hc : is_chain has_le.le c) {v₁ v₂ : shrinking_lemma.partial_refinement u s} (h₁ : v₁ ∈ c) (h₂ : v₂ ∈ c) {i : ι} (hi₁ : i ∈ v₁.carrier) (hi₂ : i ∈ v₂.carrier) : ⇑v₁ i = ⇑v₂ i
theorem euclidean_geometry.exists_circumcenter_eq_of_cospherical_subset {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} {ps : set P} (h : ps ⊆ ↑s) [nonempty ↥s] {n : ℕ} [finite_dimensional ℝ ↥(s.direction)] (hd : finite_dimensional.finrank ℝ ↥(s.direction) = n) (hc : euclidean_geometry.cospherical ps) : ∃ (c : P), ∀ (sx : affine.simplex ℝ P n), set.range sx.points ⊆ ps → sx.circumcenter = c
theorem iterated_fderiv_eq_equiv_comp {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {n : ℕ} {f : 𝕜 → F} : iterated_fderiv 𝕜 n f = ⇑(continuous_multilinear_map.pi_field_equiv 𝕜 (fin n) F) ∘ iterated_deriv n f
theorem cont_diff_at.exists_lipschitz_on_with_of_nnnorm_lt {𝕂 : Type u_6} [is_R_or_C 𝕂] {E' : Type u_7} [normed_group E'] [normed_space 𝕂 E'] {F' : Type u_8} [normed_group F'] [normed_space 𝕂 F'] {f : E' → F'} {x : E'} (hf : cont_diff_at 𝕂 1 f x) (K : nnreal) (hK : ∥fderiv 𝕂 f x∥₊ < K) : ∃ (t : set E') (H : t ∈ nhds x), lipschitz_on_with K f t
theorem power_series.order_eq {R : Type u_1} [semiring R] {φ : power_series R} {n : enat} : φ.order = n ↔ (∀ (i : ℕ), ↑i = n → ⇑(power_series.coeff R i) φ ≠ 0) ∧ ∀ (i : ℕ), ↑i < n → ⇑(power_series.coeff R i) φ = 0
theorem le_implies_le_of_le_of_le {α : Type u} {a b c d : α} [preorder α] (hca : c ≤ a) (hbd : b ≤ d) : a ≤ b → c ≤ d
theorem orthogonal_family.is_internal_iff_of_is_complete {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} [decidable_eq ι] {V : ι → submodule 𝕜 E} (hV : orthogonal_family 𝕜 (λ (i : ι), (V i).subtypeₗᵢ)) (hc : is_complete ↑(supr V)) : direct_sum.is_internal V ↔ (supr V)ᗮ = ⊥
theorem integral_cos_pow {a b : ℝ} (n : ℕ) : ∫ (x : ℝ) in a..b, real.cos x ^ (n + 2) = (real.cos b ^ (n + 1) * real.sin b - real.cos a ^ (n + 1) * real.sin a) / (↑n + 2) + (↑n + 1) / (↑n + 2) * ∫ (x : ℝ) in a..b, real.cos x ^ n
theorem list.duplicate_iff_sublist {α : Type u_1} {l : list α} {x : α} : list.duplicate x l ↔ [x, x] <+ l
theorem finset.eq_of_card_le_one_of_prod_eq {β : Type u} {α : Type v} [comm_monoid β] {s : finset α} (hc : s.card ≤ 1) {f : α → β} {b : β} (h : s.prod (λ (x : α), f x) = b) (x : α) (H : x ∈ s) : f x = b
theorem measure_theory.measure.rn_deriv_with_density {α : Type u_1} {m : measurable_space α} (ν : measure_theory.measure α) [measure_theory.sigma_finite ν] {f : α → ennreal} (hf : measurable f) : (ν.with_density f).rn_deriv ν =ᵐ[ν] f
theorem unit_interval.nonneg' {t : ↥unit_interval} : 0 ≤ t
theorem affine_subspace.vadd_mem_of_mem_direction {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {v : V} (hv : v ∈ s.direction) {p : P} (hp : p ∈ s) : v +ᵥ p ∈ s
theorem lie_submodule.quotient.lie_module_hom_ext {R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (N : lie_submodule R L M) ⦃f g : M ⧸ N →ₗ⁅R,L⁆ M⦄ (h : f.comp (lie_submodule.quotient.mk' N) = g.comp (lie_submodule.quotient.mk' N)) : f = g
theorem det_rotation (a : ↥circle) : ⇑linear_map.det ↑((⇑rotation a).to_linear_equiv) = 1
theorem polynomial.cyclotomic_eq_minpoly_rat {n : ℕ} {K : Type u_1} [field K] {μ : K} (h : is_primitive_root μ n) (hpos : 0 < n) [char_zero K] : polynomial.cyclotomic n ℚ = minpoly ℚ μ
theorem is_cyclotomic_extension.discr_prime_pow_eq_unit_mul_pow {p : ℕ+} {k : ℕ} {K : Type u} {L : Type v} {ζ : L} [field K] [field L] [algebra K L] [is_cyclotomic_extension {p ^ k} K L] [hp : fact (nat.prime ↑p)] [ne_zero ↑↑p] (hζ : is_primitive_root ζ ↑(p ^ k)) (hirr : irreducible (polynomial.cyclotomic ↑(p ^ k) K)) : ∃ (u : ℤˣ) (n : ℕ), algebra.discr K ⇑((is_primitive_root.power_basis K hζ).basis) = ↑u * ↑p ^ n
theorem filter.comap_cocompact_le {α : Type u} {β : Type v} [topological_space α] [topological_space β] {f : α → β} (hf : continuous f) : filter.comap f (filter.cocompact β) ≤ filter.cocompact α
theorem function_field_iff (Fq F : Type) [field Fq] [field F] (Fqt : Type u_1) [field Fqt] [algebra (polynomial Fq) Fqt] [is_fraction_ring (polynomial Fq) Fqt] [algebra (ratfunc Fq) F] [algebra Fqt F] [algebra (polynomial Fq) F] [is_scalar_tower (polynomial Fq) Fqt F] [is_scalar_tower (polynomial Fq) (ratfunc Fq) F] : function_field Fq F ↔ finite_dimensional Fqt F
theorem is_max_on.undual {α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α} : is_max_on (⇑order_dual.to_dual ∘ f) s a → is_min_on f s a
theorem list.relation_refl_trans_gen_of_exists_chain {α : Type u} {r : α → α → Prop} {a b : α} (l : list α) (hl₁ : list.chain r a l) (hl₂ : (a :: l).last _ = b) : relation.refl_trans_gen r a b
theorem has_btw.btw.sbtw_of_not_btw {α : Type u_1} [circular_preorder α] {a b c : α} (habc : has_btw.btw a b c) (hcba : ¬has_btw.btw c b a) : has_sbtw.sbtw a b c
theorem measure_theory.finite_measure.limsup_measure_closed_le_of_tendsto {α : Type u_1} {ι : Type u_2} {L : filter ι} [measurable_space α] [pseudo_emetric_space α] [opens_measurable_space α] {μ : measure_theory.finite_measure α} {μs : ι → measure_theory.finite_measure α} (μs_lim : filter.tendsto μs L (nhds μ)) {F : set α} (F_closed : is_closed F) : L.limsup (λ (i : ι), ⇑↑(μs i) F) ≤ ⇑↑μ F
theorem has_ftaylor_series_up_to_on.has_strict_fderiv_at {n : with_top ℕ} {𝕂 : Type u_6} [is_R_or_C 𝕂] {E' : Type u_7} [normed_group E'] [normed_space 𝕂 E'] {F' : Type u_8} [normed_group F'] [normed_space 𝕂 F'] {s : set E'} {f : E' → F'} {x : E'} {p : E' → formal_multilinear_series 𝕂 E' F'} (hf : has_ftaylor_series_up_to_on n f p s) (hn : 1 ≤ n) (hs : s ∈ nhds x) : has_strict_fderiv_at f (⇑(continuous_multilinear_curry_fin1 𝕂 E' F') (p x 1)) x
theorem tactic.interval_cases.mem_set_elems {α : Type u_1} [decidable_eq α] (s : set α) [fintype ↥s] {a : α} (h : a ∈ s) : a ∈ tactic.interval_cases.set_elems s
theorem finset.prod_univ_sum {α : Type u_1} {β : Type u_2} [decidable_eq α] [fintype α] [comm_semiring β] {δ : α → Type u_1} [Π (a : α), decidable_eq (δ a)] {t : Π (a : α), finset (δ a)} {f : Π (a : α), δ a → β} : finset.univ.prod (λ (a : α), (t a).sum (λ (b : δ a), f a b)) = (fintype.pi_finset t).sum (λ (p : Π (a : α), δ a), finset.univ.prod (λ (x : α), f x (p x)))
theorem cont_diff_fst {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : with_top ℕ} : cont_diff 𝕜 n prod.fst
theorem polynomial.cyclotomic_mul_prime_pow_eq (R : Type u_1) {p m : ℕ} [fact (nat.prime p)] [ring R] [char_p R p] (hm : ¬p ∣ m) {k : ℕ} : 0 < k → polynomial.cyclotomic (p ^ k * m) R = polynomial.cyclotomic m R ^ (p ^ k - p ^ (k - 1))
theorem category_theory.nat_trans.epi_app_of_epi {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {F G : C ⥤ D} (α : F ⟶ G) [∀ (X : C), category_theory.epi (α.app X)] : category_theory.epi α
theorem linear_map.pi_ext' {R : Type u} {M : Type v} {ι : Type x} [semiring R] {φ : ι → Type i} [Π (i : ι), add_comm_monoid (φ i)] [Π (i : ι), module R (φ i)] [fintype ι] [decidable_eq ι] [add_comm_monoid M] [module R M] {f g : (Π (i : ι), φ i) →ₗ[R] M} (h : ∀ (i : ι), f.comp (linear_map.single i) = g.comp (linear_map.single i)) : f = g
theorem linear_map.surjective_of_injective {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] {f : V →ₗ[K] V} (hinj : function.injective ⇑f) : function.surjective ⇑f
theorem zero_lt.preorder.right.one_le_mul_of_le_of_le {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (b0 : 0 < b) : 1 ≤ a * b
theorem measure_theory.integrable_prod_iff {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] ⦃f : α × β → E⦄ (h1f : measure_theory.ae_strongly_measurable f (μ.prod ν)) : measure_theory.integrable f (μ.prod ν) ↔ (∀ᵐ (x : α) ∂μ, measure_theory.integrable (λ (y : β), f (x, y)) ν) ∧ measure_theory.integrable (λ (x : α), ∫ (y : β), ∥f (x, y)∥ ∂ν) μ
theorem is_preconnected.Icc_subset {α : Type v} [linear_order α] [topological_space α] [order_closed_topology α] {s : set α} (hs : is_preconnected s) {a b : α} (ha : a ∈ s) (hb : b ∈ s) : set.Icc a b ⊆ s
theorem is_localization.localization_is_scalar_tower_of_submonoid_le {R : Type u_1} [comm_ring R] (S : Type u_2) [comm_ring S] [algebra R S] (T : Type u_4) [comm_ring T] [algebra R T] (M N : submonoid R) (h : M ≤ N) [is_localization M S] [is_localization N T] : is_scalar_tower R S T
theorem finset.subtype_map_of_mem {α : Type u_1} {s : finset α} {p : α → Prop} [decidable_pred p] (h : ∀ (x : α), x ∈ s → p x) : finset.map (function.embedding.subtype p) (finset.subtype p s) = s
theorem orthonormal.oangle_neg_neg {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x y : V) : hb.oangle (-x) (-y) = hb.oangle x y
theorem set_like.list_dprod_eq {ι : Type u_1} {R : Type u_2} {α : Type u_3} {S : Type u_4} [set_like S R] [monoid R] [add_monoid ι] (A : ι → S) [set_like.graded_monoid A] (fι : α → ι) (fA : Π (a : α), ↥(A (fι a))) (l : list α) : l.dprod fι fA = ⟨(list.map (λ (a : α), ↑(fA a)) l).prod, _⟩
theorem has_sum.tendsto_sum_nat {α : Type u_1} [add_comm_monoid α] [topological_space α] {a : α} {f : ℕ → α} (h : has_sum f a) : filter.tendsto (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), f i)) filter.at_top (nhds a)
theorem measurable_set.principal_is_measurably_generated {α : Type u_1} [measurable_space α] {s : set α} : measurable_set s → (filter.principal s).is_measurably_generated
theorem zmod.legendre_sym_eq_one_or_neg_one (p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_sym p a = 1 ∨ zmod.legendre_sym p a = -1
theorem dense_range.comp {β : Type u_2} {γ : Type u_3} [topological_space β] [topological_space γ] {κ : Type u_5} {g : β → γ} {f : κ → β} (hg : dense_range g) (hf : dense_range f) (cg : continuous g) : dense_range (g ∘ f)
theorem category_theory.preadditive.has_kernel_of_has_equalizer {C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} (f g : X ⟶ Y) [category_theory.limits.has_equalizer f g] : category_theory.limits.has_kernel (f - g)
theorem convex.mem_Ioc {𝕜 : Type u_1} [linear_ordered_field 𝕜] {x y : 𝕜} (h : x < y) {z : 𝕜} : z ∈ set.Ioc x y ↔ ∃ (a b : 𝕜), 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z
theorem embedding.is_compact_iff_is_compact_image {α : Type u} {β : Type v} [topological_space α] [topological_space β] {s : set α} {f : α → β} (hf : embedding f) : is_compact s ↔ is_compact (f '' s)
theorem add_monoid_hom.map_exists_right_neg {M : Type u_3} {N : Type u_4} {F : Type u_8} {mM : add_zero_class M} {mN : add_zero_class N} [add_monoid_hom_class F M N] (f : F) {x : M} (hx : ∃ (y : M), x + y = 0) : ∃ (y : N), ⇑f x + y = 0
theorem exterior_algebra.ι_range_disjoint_one {R : Type u1} [comm_semiring R] {M : Type u2} [add_comm_monoid M] [module R M] : disjoint (exterior_algebra.ι R).range 1
theorem norm_eq_infi_iff_real_inner_le_zero {F : Type u_3} [inner_product_space ℝ F] {K : set F} (h : convex ℝ K) {u v : F} (hv : v ∈ K) : (∥u - v∥ = ⨅ (w : ↥K), ∥u - ↑w∥) ↔ ∀ (w : F), w ∈ K → has_inner.inner (u - v) (w - v) ≤ 0
theorem mul_eq_mul_prime_pow {R : Type u_1} [cancel_comm_monoid_with_zero R] {x y a p : R} {n : ℕ} (hp : prime p) (hx : x * y = a * p ^ n) : ∃ (i j : ℕ) (b c : R), i + j = n ∧ a = b * c ∧ x = b * p ^ i ∧ y = c * p ^ j
theorem measure_theory.lintegral_abs_det_fderiv_eq_add_haar_image {E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {s : set E} {f : E → E} {f' : E → (E →L[ℝ] E)} [measurable_space E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (hs : measurable_set s) (hf' : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) : ∫⁻ (x : E) in s, ennreal.of_real |(f' x).det| ∂μ = ⇑μ (f '' s)
theorem measure_theory.exists_le_lower_semicontinuous_lintegral_ge {α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] (μ : measure_theory.measure α) [μ.weakly_regular] (f : α → ennreal) (hf : measurable f) {ε : ennreal} (εpos : ε ≠ 0) : ∃ (g : α → ennreal), (∀ (x : α), f x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), g x ∂μ ≤ ∫⁻ (x : α), f x ∂μ + ε
theorem is_cyclotomic_extension.empty (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] [h : is_cyclotomic_extension ∅ A B] : ⊥ = ⊤
theorem is_top.to_dual {α : Type u_1} [has_le α] {a : α} : is_top a → is_bot (⇑order_dual.to_dual a)
theorem measure_theory.tendsto_lintegral_filter_of_dominated_convergence {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {ι : Type u_2} {l : filter ι} [l.is_countably_generated] {F : ι → α → ennreal} {f : α → ennreal} (bound : α → ennreal) (hF_meas : ∀ᶠ (n : ι) in l, measurable (F n)) (h_bound : ∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, F n a ≤ bound a) (h_fin : ∫⁻ (a : α), bound a ∂μ ≠ ⊤) (h_lim : ∀ᵐ (a : α) ∂μ, filter.tendsto (λ (n : ι), F n a) l (nhds (f a))) : filter.tendsto (λ (n : ι), ∫⁻ (a : α), F n a ∂μ) l (nhds (∫⁻ (a : α), f a ∂μ))
theorem exists_mem_frontier_inf_dist_compl_eq_dist {E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {x : E} {s : set E} (hx : x ∈ s) (hs : s ≠ set.univ) : ∃ (y : E) (H : y ∈ frontier s), metric.inf_dist x sᶜ = has_dist.dist x y
theorem edist_le_of_edist_le_geometric_two_of_tendsto₀ {α : Type u_1} [pseudo_emetric_space α] (C : ennreal) {f : ℕ → α} (hu : ∀ (n : ℕ), has_edist.edist (f n) (f (n + 1)) ≤ C / 2 ^ n) {a : α} (ha : filter.tendsto f filter.at_top (nhds a)) : has_edist.edist (f 0) a ≤ 2 * C
theorem Top.presheaf.covering_of_presieve.fork_map_comp_first_obj_iso_pi_opens_eq {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) (U : topological_space.opens ↥X) (R : category_theory.presieve U) (hR : category_theory.sieve.generate R ∈ ⇑(opens.grothendieck_topology ↥X) U) : category_theory.presheaf.fork_map R F ≫ (Top.presheaf.covering_of_presieve.first_obj_iso_pi_opens F U R).hom = F.map (category_theory.eq_to_hom _).op ≫ Top.presheaf.sheaf_condition_equalizer_products.res F (Top.presheaf.covering_of_presieve U R)
theorem euclidean_geometry.orthogonal_projection_fn_mem_orthogonal {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} [nonempty ↥s] [complete_space ↥(s.direction)] (p : P) : euclidean_geometry.orthogonal_projection_fn s p ∈ affine_subspace.mk' p (s.direction)ᗮ
theorem finsum_sub_distrib {α : Type u_1} {G : Type u_4} [subtraction_comm_monoid G] {f g : α → G} (hf : (function.support f).finite) (hg : (function.support g).finite) : finsum (λ (i : α), f i - g i) = finsum (λ (i : α), f i) - finsum (λ (i : α), g i)
theorem odd.exists_bit1 {α : Type u_2} [semiring α] {a : α} : odd a → (∃ (b : α), a = bit1 b)
theorem padic_val_nat.mul (p : ℕ) [p_prime : fact (nat.prime p)] {q r : ℕ} (hq : q ≠ 0) (hr : r ≠ 0) : padic_val_nat p (q * r) = padic_val_nat p q + padic_val_nat p r
theorem category_theory.abelian.mono_inl_of_factor_thru_epi_mono_factorization {C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.limits.has_pushouts C] {W X Y Z : C} (f : X ⟶ Y) (g : X ⟶ Z) (g₁ : X ⟶ W) [category_theory.epi g₁] (g₂ : W ⟶ Z) [category_theory.mono g₂] (hg : g₁ ≫ g₂ = g) (f' : W ⟶ Y) (hf : g₁ ≫ f' = f) (t : category_theory.limits.pushout_cocone f g) (ht : category_theory.limits.is_colimit t) : category_theory.mono t.inl
theorem circle_deg1_lift.translation_number_of_map_pow_eq_add_int (f : circle_deg1_lift) {x : ℝ} {n : ℕ} {m : ℤ} (h : ⇑(f ^ n) x = x + ↑m) (hn : 0 < n) : f.translation_number = ↑m / ↑n
theorem add_subgroup.eq_zero_of_noncomm_sum_eq_zero_of_independent {G : Type u_1} [add_group G] {ι : Type u_2} (s : finset ι) (f : ι → G) (comm : ∀ (x : ι), x ∈ s → ∀ (y : ι), y ∈ s → add_commute (f x) (f y)) (K : ι → add_subgroup G) (hind : complete_lattice.independent K) (hmem : ∀ (x : ι), x ∈ s → f x ∈ K x) (heq1 : s.noncomm_sum f comm = 0) (i : ι) (H : i ∈ s) : f i = 0
theorem finprod_mem_insert {α : Type u_1} {M : Type u_5} [comm_monoid M] {a : α} {s : set α} (f : α → M) (h : a ∉ s) (hs : s.finite) : finprod (λ (i : α), finprod (λ (H : i ∈ has_insert.insert a s), f i)) = f a * finprod (λ (i : α), finprod (λ (H : i ∈ s), f i))
theorem inner_product_geometry.norm_sub_sq_eq_norm_sq_add_norm_sq_sub_two_mul_norm_mul_norm_mul_cos_angle {V : Type u_1} [inner_product_space ℝ V] (x y : V) : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ - 2 * ∥x∥ * ∥y∥ * real.cos (inner_product_geometry.angle x y)
theorem category_theory.limits.is_iso_π_of_is_initial {C : Type u₁} [category_theory.category C] {J : Type u} [category_theory.category J] {j : J} (I : category_theory.limits.is_initial j) (F : J ⥤ C) [category_theory.limits.has_limit F] : category_theory.is_iso (category_theory.limits.limit.π F j)
theorem div_self_mul_self {G₀ : Type u_2} [group_with_zero G₀] (a : G₀) : a / a * a = a
theorem add_hom.congr_fun {M : Type u_3} {N : Type u_4} [has_add M] [has_add N] {f g : add_hom M N} (h : f = g) (x : M) : ⇑f x = ⇑g x
theorem continuous_on.mono_rng {α : Type u_1} {β : Type u_2} {t₁ : topological_space α} {t₂ t₃ : topological_space β} (h₁ : t₂ ≤ t₃) {s : set α} {f : α → β} (h₂ : continuous_on f s) : continuous_on f s
theorem cardinal.mk_Ioi_real (a : ℝ) : cardinal.mk ↥(set.Ioi a) = cardinal.continuum
theorem add_subgroup.neg_mem {G : Type u_1} [add_group G] (H : add_subgroup G) {x : G} : x ∈ H → -x ∈ H
theorem category_theory.limits.initial_mono_class.of_initial {C : Type u₁} [category_theory.category C] [category_theory.limits.has_initial C] (h : ∀ (X : C), category_theory.mono (category_theory.limits.initial.to X)) : category_theory.limits.initial_mono_class C
theorem set.finset_prod_subset_finset_prod {α : Type u_2} {ι : Type u_5} [comm_monoid α] (t : finset ι) (f₁ f₂ : ι → set α) (hf : ∀ {i : ι}, i ∈ t → f₁ i ⊆ f₂ i) : t.prod (λ (i : ι), f₁ i) ⊆ t.prod (λ (i : ι), f₂ i)
theorem is_dedekind_domain.height_one_spectrum.valuation_uniformizer_ne_zero {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) : classical.some _ ≠ 0
theorem measure_theory.measure.mk_metric_mono_smul {X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] {m₁ m₂ : ennreal → ennreal} {c : ennreal} (hc : c ≠ ⊤) (h0 : c ≠ 0) (hle : m₁ ≤ᶠ[nhds_within 0 (set.Ici 0)] c • m₂) : measure_theory.measure.mk_metric m₁ ≤ c • measure_theory.measure.mk_metric m₂
theorem orthogonal_projection_mem_subspace_orthogonal_precomplement_eq_zero {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K : submodule 𝕜 E} [complete_space E] {v : E} (hv : v ∈ K) : ⇑(orthogonal_projection Kᗮ) v = 0
theorem structure_groupoid.id_mem_maximal_atlas {H : Type u} [topological_space H] (G : structure_groupoid H) : local_homeomorph.refl H ∈ structure_groupoid.maximal_atlas H G
theorem measure_theory.lintegral_add_left {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : α → ennreal} (hf : measurable f) (g : α → ennreal) : ∫⁻ (a : α), f a + g a ∂μ = ∫⁻ (a : α), f a ∂μ + ∫⁻ (a : α), g a ∂μ
theorem mul_equiv.is_mul_hom {M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (h : M ≃* N) : is_mul_hom ⇑h
theorem measure_theory.measure.regular.inner_regular_measurable {α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [μ.regular] : μ.inner_regular is_compact (λ (s : set α), measurable_set s ∧ ⇑μ s ≠ ⊤)
theorem asymptotics.is_O_with_of_eq_mul {α : Type u_1} {𝕜 : Type u_14} [normed_field 𝕜] {c : ℝ} {l : filter α} {u v : α → 𝕜} (φ : α → 𝕜) (hφ : ∀ᶠ (x : α) in l, ∥φ x∥ ≤ c) (h : u =ᶠ[l] φ * v) : asymptotics.is_O_with c l u v
theorem ennreal.rpow_arith_mean_le_arith_mean2_rpow (w₁ w₂ z₁ z₂ : ennreal) (hw' : w₁ + w₂ = 1) {p : ℝ} (hp : 1 ≤ p) : (w₁ * z₁ + w₂ * z₂) ^ p ≤ w₁ * z₁ ^ p + w₂ * z₂ ^ p
theorem con.ker_lift_range_eq {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {f : M →* P} : (con.ker_lift f).mrange = f.mrange
theorem category_theory.prod_comparison_iso {C : Type u₁} {D : Type u₂} [category_theory.category C] [category_theory.category D] (i : D ⥤ C) [category_theory.limits.has_finite_products C] [category_theory.reflective i] [category_theory.cartesian_closed C] [category_theory.exponential_ideal i] (A B : C) : category_theory.is_iso (category_theory.limits.prod_comparison (category_theory.left_adjoint i) A B)
theorem category_theory.presieve.is_sheaf_for_subsieve {C : Type u₁} [category_theory.category C] {X : C} (P : Cᵒᵖ ⥤ Type w) {S : category_theory.sieve X} {R : category_theory.presieve X} (h : ⇑S ≤ R) (trans : ∀ ⦃Y : C⦄ (f : Y ⟶ X), category_theory.presieve.is_sheaf_for P ⇑(category_theory.sieve.pullback f S)) : category_theory.presieve.is_sheaf_for P R
theorem con.eq {M : Type u_1} [has_mul M] (c : con M) {a b : M} : ↑a = ↑b ↔ ⇑c a b
theorem subsemiring.list_sum_mem {R : Type u} [non_assoc_semiring R] (s : subsemiring R) {l : list R} : (∀ (x : R), x ∈ l → x ∈ s) → l.sum ∈ s
theorem category_theory.limits.has_pushouts_of_has_colimit_span (C : Type u) [category_theory.category C] [∀ {X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z}, category_theory.limits.has_colimit (category_theory.limits.span f g)] : category_theory.limits.has_pushouts C
theorem nonempty_interior_of_Union_of_closed {α : Type u_1} {β : Type u_2} [topological_space α] [baire_space α] [nonempty α] [encodable β] {f : β → set α} (hc : ∀ (s : β), is_closed (f s)) (hU : (⋃ (s : β), f s) = set.univ) : ∃ (s : β), (interior (f s)).nonempty
theorem orthogonal_family.linear_isometry_equiv_symm_apply {ι : Type u_1} {𝕜 : Type u_2} [is_R_or_C 𝕜] {E : Type u_3} [inner_product_space 𝕜 E] [cplt : complete_space E] {G : ι → Type u_4} [Π (i : ι), inner_product_space 𝕜 (G i)] {V : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : orthogonal_family 𝕜 V) [∀ (i : ι), complete_space (G i)] (hV' : (⨆ (i : ι), (V i).to_linear_map.range).topological_closure = ⊤) (w : ↥(lp G 2)) : ⇑((hV.linear_isometry_equiv hV').symm) w = ∑' (i : ι), ⇑(V i) (⇑w i)
theorem function.is_fixed_pt.is_periodic_pt {α : Type u_1} {f : α → α} {x : α} (hf : function.is_fixed_pt f x) (n : ℕ) : function.is_periodic_pt f n x
theorem nat.sum_range_choose (n : ℕ) : (finset.range (n + 1)).sum (λ (m : ℕ), n.choose m) = 2 ^ n
theorem exists_polynomial_near_continuous_map (a b : ℝ) (f : C(↥(set.Icc a b), ℝ)) (ε : ℝ) (pos : 0 < ε) : ∃ (p : polynomial ℝ), ∥p.to_continuous_map_on (set.Icc a b) - f∥ < ε
theorem measurable_measure_prod_mk_left_finite {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {ν : measure_theory.measure β} [measure_theory.is_finite_measure ν] {s : set (α × β)} (hs : measurable_set s) : measurable (λ (x : α), ⇑ν (prod.mk x ⁻¹' s))
theorem sylow.card_normalizer_modeq_card {G : Type u} [group G] [fintype G] {p n : ℕ} [hp : fact (nat.prime p)] {H : subgroup G} (hH : fintype.card ↥H = p ^ n) : fintype.card ↥(H.normalizer) ≡ fintype.card G [MOD p ^ (n + 1)]
theorem is_closed.Icc_subset_of_forall_exists_gt {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {a b : α} {s : set α} (hs : is_closed (s ∩ set.Icc a b)) (ha : a ∈ s) (hgt : ∀ (x : α), x ∈ s ∩ set.Ico a b → ∀ (y : α), y ∈ set.Ioi x → (s ∩ set.Ioc x y).nonempty) : set.Icc a b ⊆ s
theorem exists_seq_norm_le_one_le_norm_sub' {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {E : Type v} [normed_group E] [normed_space 𝕜 E] [complete_space 𝕜] {c : 𝕜} (hc : 1 < ∥c∥) {R : ℝ} (hR : ∥c∥ < R) (h : ¬finite_dimensional 𝕜 E) : ∃ (f : ℕ → E), (∀ (n : ℕ), ∥f n∥ ≤ R) ∧ ∀ (m n : ℕ), m ≠ n → 1 ≤ ∥f m - f n∥
theorem le_cInf_inter {α : Type u_1} [conditionally_complete_lattice α] {s t : set α} : bdd_below s → bdd_below t → (s ∩ t).nonempty → has_Inf.Inf s ⊔ has_Inf.Inf t ≤ has_Inf.Inf (s ∩ t)
theorem left.inv_lt_one_iff {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a
theorem zmod.int_cast_comp_cast {n : ℕ} (R : Type u_1) [ring R] : coe ∘ coe = coe
theorem nat.choose_le_central_binom (r n : ℕ) : (2 * n).choose r ≤ n.central_binom
theorem pmf.to_measure_bind_on_support_apply {α : Type u_1} {β : Type u_2} {p : pmf α} (f : Π (a : α), a ∈ p.support → pmf β) (s : set β) [measurable_space β] (hs : measurable_set s) : ⇑((p.bind_on_support f).to_measure) s = ∑' (a : α), ↑(⇑p a) * dite (⇑p a = 0) (λ (h : ⇑p a = 0), 0) (λ (h : ¬⇑p a = 0), ⇑((f a h).to_measure) s)
theorem dense_sInter_of_open {α : Type u_1} [topological_space α] [baire_space α] {S : set (set α)} (ho : ∀ (s : set α), s ∈ S → is_open s) (hS : S.countable) (hd : ∀ (s : set α), s ∈ S → dense s) : dense (⋂₀ S)
theorem pi.single_smul' {I : Type u} {α : Type u_1} {β : Type u_2} [monoid α] [add_monoid β] [distrib_mul_action α β] [decidable_eq I] (i : I) (r : α) (x : β) : pi.single i (r • x) = r • pi.single i x
theorem complex.norm_eq_on_closed_ball_of_is_max_on {E : Type u} [normed_group E] [normed_space ℂ E] {F : Type v} [normed_group F] [normed_space ℂ F] {f : E → F} {z : E} {r : ℝ} (hd : diff_cont_on_cl ℂ f (metric.ball z r)) (hz : is_max_on (has_norm.norm ∘ f) (metric.ball z r) z) : set.eq_on (has_norm.norm ∘ f) (function.const E ∥f z∥) (metric.closed_ball z r)
theorem has_fderiv_within_at.unique_on {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {f' f₁' : E →L[𝕜] F} {x : E} {s : set E} (hf : has_fderiv_within_at f f' s x) (hg : has_fderiv_within_at f f₁' s x) : set.eq_on ⇑f' ⇑f₁' (tangent_cone_at 𝕜 s x)
theorem subtype.range_coe_subtype {α : Type u_1} {p : α → Prop} : set.range coe = {x : α | p x}
theorem is_add_regular_add_and_add_iff {R : Type u_1} {a b : R} [add_semigroup R] : is_add_regular (a + b) ∧ is_add_regular (b + a) ↔ is_add_regular a ∧ is_add_regular b
theorem lt_add_of_neg_add_lt {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : -b + a < c → a < b + c
theorem pow_two_sub_pow_two {R : Type u₁} [comm_ring R] (a b : R) : a ^ 2 - b ^ 2 = (a + b) * (a - b)
theorem finset.card_sym2 {α : Type u_1} [decidable_eq α] (s : finset α) : s.sym2.card = s.card * (s.card + 1) / 2
theorem function.injective.map_at_top_finset_prod_eq {α : Type u_3} {β : Type u_4} {γ : Type u_5} [comm_monoid α] {g : γ → β} (hg : function.injective g) {f : β → α} (hf : ∀ (x : β), x ∉ set.range g → f x = 1) : filter.map (λ (s : finset γ), s.prod (λ (i : γ), f (g i))) filter.at_top = filter.map (λ (s : finset β), s.prod (λ (i : β), f i)) filter.at_top
theorem topological_space.is_topological_basis.mem_closure_iff {α : Type u} [t : topological_space α] {b : set (set α)} (hb : topological_space.is_topological_basis b) {s : set α} {a : α} : a ∈ closure s ↔ ∀ (o : set α), o ∈ b → a ∈ o → (o ∩ s).nonempty
theorem multiset.nat.nodup_antidiagonal (n : ℕ) : (multiset.nat.antidiagonal n).nodup
theorem add_action.card_orbit_add_card_stabilizer_eq_card_add_group (α : Type u) {β : Type v} [add_group α] [add_action α β] (b : β) [fintype α] [fintype ↥(add_action.orbit α b)] [fintype ↥(add_action.stabilizer α b)] : fintype.card ↥(add_action.orbit α b) * fintype.card ↥(add_action.stabilizer α b) = fintype.card α
theorem measure_theory.lintegral_prod {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] (f : α × β → ennreal) (hf : ae_measurable f (μ.prod ν)) : ∫⁻ (z : α × β), f z ∂μ.prod ν = ∫⁻ (x : α), ∫⁻ (y : β), f (x, y) ∂ν ∂μ
theorem ray_vector.equiv_neg_iff {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {v₁ v₂ : ray_vector R M} : -v₁ ≈ -v₂ ↔ v₁ ≈ v₂
theorem is_compact.bdd_above {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] [nonempty α] {s : set α} (hs : is_compact s) : bdd_above s
theorem asymptotics.is_O_iff_is_O_with {α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : α → E} {g : α → F} {l : filter α} : f =O[l] g ↔ ∃ (c : ℝ), asymptotics.is_O_with c l f g
theorem measure_theory.integral_eq_zero_of_mul_right_eq_neg {G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure G} {f : G → E} {g : G} [group G] [has_measurable_mul G] [μ.is_mul_right_invariant] (hf' : ∀ (x : G), f (x * g) = -f x) : ∫ (x : G), f x ∂μ = 0
theorem qpf.recF_eq_of_Wequiv {F : Type u → Type u} [functor F] [q : qpf F] {α : Type u} (u : F α → α) (x y : (qpf.P F).W) : qpf.Wequiv x y → qpf.recF u x = qpf.recF u y
theorem measure_theory.is_fundamental_domain.mk' {G : Type u_1} {α : Type u_2} [group G] [mul_action G α] [measurable_space α] {s : set α} {μ : measure_theory.measure α} (h_meas : measure_theory.null_measurable_set s μ) (h_exists : ∀ (x : α), ∃! (g : G), g • x ∈ s) : measure_theory.is_fundamental_domain G s μ
theorem affine.simplex.dist_circumcenter_eq_circumradius {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P n) (i : fin (n + 1)) : has_dist.dist (s.points i) s.circumcenter = s.circumradius
theorem affine.simplex.circumcenter_mem_affine_span {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P n) : s.circumcenter ∈ affine_span ℝ (set.range s.points)
theorem continuous.exists_forall_le {α : Type u_1} {β : Type u_2} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [topological_space β] [nonempty β] {f : β → α} (hf : continuous f) (hlim : filter.tendsto f (filter.cocompact β) filter.at_top) : ∃ (x : β), ∀ (y : β), f x ≤ f y
theorem is_integral.linear_independent_pow {S : Type u_2} [comm_ring S] {K : Type u_6} [field K] [algebra K S] {x : S} (hx : is_integral K x) : linear_independent K (λ (i : fin (minpoly K x).nat_degree), x ^ ↑i)
theorem finprod_mem_union {α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M} {s t : set α} (hst : disjoint s t) (hs : s.finite) (ht : t.finite) : finprod (λ (i : α), finprod (λ (H : i ∈ s ∪ t), f i)) = finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ t), f i))
theorem nat.factorization_disjoint_of_coprime {a b : ℕ} (hab : a.coprime b) : disjoint a.factorization.support b.factorization.support
theorem image_le_of_deriv_right_lt_deriv_boundary {f f' : ℝ → ℝ} {a b : ℝ} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : ℝ → ℝ} (ha : f a ≤ B a) (hB : ∀ (x : ℝ), has_deriv_at B (B' x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → f x = B x → f' x < B' x) ⦃x : ℝ⦄ : x ∈ set.Icc a b → f x ≤ B x
theorem subfield.closure_eq {K : Type u} [field K] (s : subfield K) : subfield.closure ↑s = s
theorem lattice_ordered_comm_group.mabs_mul_le {α : Type u} [lattice α] [comm_group α] [covariant_class α α has_mul.mul has_le.le] (a b : α) : |a * b| ≤ |a| * |b|
theorem add_con.Sup_eq_add_con_gen {M : Type u_1} [has_add M] (S : set (add_con M)) : has_Sup.Sup S = add_con_gen (λ (x y : M), ∃ (c : add_con M), c ∈ S ∧ ⇑c x y)
theorem is_min_filter.undual {α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α} : is_min_filter (⇑order_dual.to_dual ∘ f) l a → is_max_filter f l a
theorem discrete_valuation_ring.irreducible_iff_uniformizer {R : Type u} [comm_ring R] [is_domain R] [discrete_valuation_ring R] (ϖ : R) : irreducible ϖ ↔ local_ring.maximal_ideal R = ideal.span {ϖ}
theorem has_le.le.eq_of_not_gt {α : Type u} [partial_order α] {a b : α} (hab : a ≤ b) (hba : ¬a < b) : b = a
theorem bounded_continuous_function.exists_extension_norm_eq_of_closed_embedding {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] (f : bounded_continuous_function X ℝ) {e : X → Y} (he : closed_embedding e) : ∃ (g : bounded_continuous_function Y ℝ), ∥g∥ = ∥f∥ ∧ ⇑g ∘ e = ⇑f
theorem measure_theory.Lp.mem_bounded_continuous_function_iff {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} {p : ennreal} {μ : measure_theory.measure α} [normed_group E] [topological_space α] [borel_space α] [second_countable_topology_either α E] {f : ↥(measure_theory.Lp E p μ)} : f ∈ measure_theory.Lp.bounded_continuous_function E p μ ↔ ∃ (f₀ : bounded_continuous_function α E), continuous_map.to_ae_eq_fun μ f₀.to_continuous_map = ↑f
theorem add_subgroup.multiset_sum_mem {G : Type u_1} [add_comm_group G] (K : add_subgroup G) (g : multiset G) : (∀ (a : G), a ∈ g → a ∈ K) → g.sum ∈ K
theorem finset.centroid_eq_affine_combination_fintype (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} (s : finset ι) [fintype ι] (p : ι → P) : finset.centroid k s p = ⇑(finset.univ.affine_combination p) (finset.centroid_weights_indicator k s)
theorem real.tendsto_exp_div_pow_at_top (n : ℕ) : filter.tendsto (λ (x : ℝ), real.exp x / x ^ n) filter.at_top filter.at_top
theorem nat.fib_add (m n : ℕ) : nat.fib (m + n + 1) = nat.fib m * nat.fib n + nat.fib (m + 1) * nat.fib (n + 1)
theorem affine_subspace.mem_affine_span_insert_iff {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p1 : P} (hp1 : p1 ∈ s) (p2 p : P) : p ∈ affine_span k (has_insert.insert p2 ↑s) ↔ ∃ (r : k) (p0 : P) (hp0 : p0 ∈ s), p = r • (p2 -ᵥ p1) +ᵥ p0
theorem finset.nonempty.cons_induction {α : Type u_1} {p : Π (s : finset α), s.nonempty → Prop} (h₀ : ∀ (a : α), p {a} _) (h₁ : ∀ ⦃a : α⦄ (s : finset α) (h : a ∉ s) (hs : s.nonempty), p s hs → p (finset.cons a s h) _) {s : finset α} (hs : s.nonempty) : p s hs
theorem fractional_ideal.mul_inv_cancel {A : Type u_2} {K : Type u_3} [comm_ring A] [field K] [is_domain A] [algebra A K] [is_fraction_ring A K] [is_dedekind_domain A] {I : fractional_ideal (non_zero_divisors A) K} (hne : I ≠ 0) : I * I⁻¹ = 1
theorem measurable_sub_const' {G : Type u_1} [sub_neg_monoid G] [measurable_space G] [has_measurable_add G] (g : G) : measurable (λ (h : G), h - g)
theorem con.ext' {M : Type u_1} [has_mul M] {c d : con M} (H : setoid.r = setoid.r) : c = d
theorem projective_spectrum.gc_set {R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_ring A] [algebra R A] (𝒜 : ℕ → submodule R A) [graded_algebra 𝒜] : galois_connection (λ (s : set A), projective_spectrum.zero_locus 𝒜 s) (λ (t : (set (projective_spectrum 𝒜))ᵒᵈ), ↑(projective_spectrum.vanishing_ideal t))
theorem measure_theory.measure.ext_of_generate_from_of_cover_subset {α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} {S T : set (set α)} (h_gen : m0 = measurable_space.generate_from S) (h_inter : is_pi_system S) (h_sub : T ⊆ S) (hc : T.countable) (hU : ⋃₀T = set.univ) (htop : ∀ (s : set α), s ∈ T → ⇑μ s ≠ ⊤) (h_eq : ∀ (s : set α), s ∈ S → ⇑μ s = ⇑ν s) : μ = ν
theorem monotone.tendsto_at_bot_at_bot_iff {α : Type u_3} {β : Type u_4} [nonempty α] [semilattice_inf α] [preorder β] {f : α → β} (hf : monotone f) : filter.tendsto f filter.at_bot filter.at_bot ↔ ∀ (b : β), ∃ (a : α), f a ≤ b
theorem matrix.det_succ_column_zero {R : Type v} [comm_ring R] {n : ℕ} (A : matrix (fin n.succ) (fin n.succ) R) : A.det = finset.univ.sum (λ (i : fin n.succ), (-1) ^ ↑i * A i 0 * (A.minor ⇑(i.succ_above) fin.succ).det)
theorem category_theory.has_colimits_of_shape_of_has_colimits_of_shape_creates_colimits_of_shape {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {J : Type w} [category_theory.category J] (F : C ⥤ D) [category_theory.limits.has_colimits_of_shape J D] [category_theory.creates_colimits_of_shape J F] : category_theory.limits.has_colimits_of_shape J C
theorem complex.circle_integral_sub_inv_smul_of_differentiable_on_off_countable {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] {R : ℝ} {c w : ℂ} {f : ℂ → E} {s : set ℂ} (hs : s.countable) (hw : w ∈ metric.ball c R) (hc : continuous_on f (metric.closed_ball c R)) (hd : ∀ (x : ℂ), x ∈ metric.ball c R  s → differentiable_at ℂ f x) : ∮ (z : ℂ) in C(c, R), (z - w)⁻¹ • f z = (2 * ↑real.pi * complex.I) • f w
theorem is_closed.mem_of_ge_of_forall_exists_gt {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {a b : α} {s : set α} (hs : is_closed (s ∩ set.Icc a b)) (ha : a ∈ s) (hab : a ≤ b) (hgt : ∀ (x : α), x ∈ s ∩ set.Ico a b → (s ∩ set.Ioc x b).nonempty) : b ∈ s
theorem pow_two_nonneg {R : Type u_4} [linear_ordered_ring R] (a : R) : 0 ≤ a ^ 2
theorem convex.add_haar_frontier {E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] {s : set E} (hs : convex ℝ s) : ⇑μ (frontier s) = 0
theorem generalized_continued_fraction.int_fract_pair.one_le_succ_nth_stream_b {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_succ_n : generalized_continued_fraction.int_fract_pair K} (succ_nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n) : 1 ≤ ifp_succ_n.b
theorem linear_map.trace_eq_matrix_trace_of_finset (R : Type u) [comm_semiring R] {M : Type v} [add_comm_monoid M] [module R M] {s : finset M} (b : basis ↥s R M) (f : M →ₗ[R] M) : ⇑(linear_map.trace R M) f = (⇑(linear_map.to_matrix b b) f).trace
theorem mv_polynomial.derivation_eq_on_supported {σ : Type u_1} {R : Type u_2} {A : Type u_3} [comm_semiring R] [add_comm_monoid A] [module R A] [module (mv_polynomial σ R) A] {D₁ D₂ : derivation R (mv_polynomial σ R) A} {s : set σ} (h : set.eq_on (⇑D₁ ∘ mv_polynomial.X) (⇑D₂ ∘ mv_polynomial.X) s) {f : mv_polynomial σ R} (hf : f ∈ mv_polynomial.supported R s) : ⇑D₁ f = ⇑D₂ f
theorem ideal.exists_ideal_over_maximal_of_is_integral {R : Type u_1} [comm_ring R] {S : Type u_2} [comm_ring S] [algebra R S] [is_domain S] (H : algebra.is_integral R S) (P : ideal R) [P_max : P.is_maximal] (hP : (algebra_map R S).ker ≤ P) : ∃ (Q : ideal S), Q.is_maximal ∧ ideal.comap (algebra_map R S) Q = P
theorem fixing_submonoid_fixed_points_gc (M : Type u_1) (α : Type u_2) [monoid M] [mul_action M α] : galois_connection (⇑order_dual.to_dual ∘ fixing_submonoid M) ((λ (P : submonoid M), mul_action.fixed_points ↥P α) ∘ ⇑order_dual.of_dual)
theorem is_preconnected.image {α : Type u} {β : Type v} [topological_space α] [topological_space β] {s : set α} (H : is_preconnected s) (f : α → β) (hf : continuous_on f s) : is_preconnected (f '' s)
theorem measure_theory.measure_preserving.prod {α : Type u_1} {β : Type u_3} {γ : Type u_5} [measurable_space α] [measurable_space β] [measurable_space γ] {δ : Type u_7} [measurable_space δ] {μa : measure_theory.measure α} {μb : measure_theory.measure β} {μc : measure_theory.measure γ} {μd : measure_theory.measure δ} [measure_theory.sigma_finite μb] [measure_theory.sigma_finite μd] {f : α → β} {g : γ → δ} (hf : measure_theory.measure_preserving f μa μb) (hg : measure_theory.measure_preserving g μc μd) : measure_theory.measure_preserving (prod.map f g) (μa.prod μc) (μb.prod μd)
theorem complex.tendsto_abs_cocompact_at_top  : filter.tendsto complex.abs (filter.cocompact ℂ) filter.at_top
theorem measurable_equiv.map_apply {α : Type u_1} {β : Type u_2} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} (f : α ≃ᵐ β) (s : set β) : ⇑(measure_theory.measure.map ⇑f μ) s = ⇑μ (⇑f ⁻¹' s)
theorem add_con.lift_coe {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} {f : M →+ P} (H : c ≤ add_con.ker f) (x : M) : ⇑(c.lift f H) ↑x = ⇑f x
theorem composition.sigma_composition_eq_iff {n : ℕ} (i j : Σ (a : composition n), composition a.length) : i = j ↔ i.fst.blocks = j.fst.blocks ∧ i.snd.blocks = j.snd.blocks
theorem discrim_le_zero {K : Type u_1} [linear_ordered_field K] {a b c : K} (h : ∀ (x : K), 0 ≤ a * x * x + b * x + c) : discrim a b c ≤ 0
theorem affine_subspace.self_mem_mk' {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) (direction : submodule k V) : p ∈ affine_subspace.mk' p direction
theorem con.induction_on {M : Type u_1} [has_mul M] {c : con M} {C : c.quotient → Prop} (q : c.quotient) (H : ∀ (x : M), C ↑x) : C q
theorem add_submonoid.supr_eq_mrange_dfinsupp_sum_add_hom {ι : Type u} {γ : Type w} [dec : decidable_eq ι] [add_comm_monoid γ] (S : ι → add_submonoid γ) : supr S = (dfinsupp.sum_add_hom (λ (i : ι), (S i).subtype)).mrange
theorem padic_norm.nonzero (p : ℕ) [hp : fact (nat.prime p)] {q : ℚ} (hq : q ≠ 0) : padic_norm p q ≠ 0
theorem is_projective.iff_projective {R : Type u} [ring R] {P : Type (max u v)} [add_comm_group P] [module R P] : module.projective R P ↔ category_theory.projective (Module.of R P)
theorem Module.has_kernels_Module {R : Type u} [ring R] : category_theory.limits.has_kernels (Module R)
theorem normed_ring.inverse_continuous_at {R : Type u_1} [normed_ring R] [complete_space R] (x : Rˣ) : continuous_at ring.inverse ↑x
theorem subsemiring.add_mem {R : Type u} [non_assoc_semiring R] (s : subsemiring R) {x y : R} : x ∈ s → y ∈ s → x + y ∈ s
theorem holder_with.dimH_range_le {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {C r : nnreal} {f : X → Y} (h : holder_with C r f) (hr : 0 < r) : dimH (set.range f) ≤ dimH set.univ / ↑r
theorem interval_integral.has_fderiv_at_integral_of_dominated_of_fderiv_le {𝕜 : Type u_1} [is_R_or_C 𝕜] {μ : measure_theory.measure ℝ} {E : Type u_2} [normed_group E] [normed_space ℝ E] [normed_space 𝕜 E] [complete_space E] {H : Type u_3} [normed_group H] [normed_space 𝕜 H] {a b ε : ℝ} {bound : ℝ → ℝ} {F : H → ℝ → E} {F' : H → ℝ → (H →L[𝕜] E)} {x₀ : H} (ε_pos : 0 < ε) (hF_meas : ∀ᶠ (x : H) in nhds x₀, measure_theory.ae_strongly_measurable (F x) (μ.restrict (set.interval_oc a b))) (hF_int : interval_integrable (F x₀) μ a b) (hF'_meas : measure_theory.ae_strongly_measurable (F' x₀) (μ.restrict (set.interval_oc a b))) (h_bound : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → ∀ (x : H), x ∈ metric.ball x₀ ε → ∥F' x t∥ ≤ bound t) (bound_integrable : interval_integrable bound μ a b) (h_diff : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → ∀ (x : H), x ∈ metric.ball x₀ ε → has_fderiv_at (λ (x : H), F x t) (F' x t) x) : has_fderiv_at (λ (x : H), ∫ (t : ℝ) in a..b, F x t ∂μ) (∫ (t : ℝ) in a..b, F' x₀ t ∂μ) x₀
theorem cSup_inter_le {α : Type u_1} [conditionally_complete_lattice α] {s t : set α} (hs : bdd_above s) (ht : bdd_above t) (hst : (s ∩ t).nonempty) : has_Sup.Sup (s ∩ t) ≤ has_Sup.Sup s ⊓ has_Sup.Sup t
theorem configuration.nondegenerate.exists_injective_of_card_le {P L : Type u} [has_mem P L] [configuration.nondegenerate P L] [fintype P] [fintype L] (h : fintype.card L ≤ fintype.card P) : ∃ (f : L → P), function.injective f ∧ ∀ (l : L), f l ∉ l
theorem is_local_extr_on.exists_multipliers_of_has_strict_fderiv_at_1d {E : Type u_1} [normed_group E] [normed_space ℝ E] [complete_space E] {φ : E → ℝ} {x₀ : E} {φ' : E →L[ℝ] ℝ} {f : E → ℝ} {f' : E →L[ℝ] ℝ} (hextr : is_local_extr_on φ {x : E | f x = f x₀} x₀) (hf' : has_strict_fderiv_at f f' x₀) (hφ' : has_strict_fderiv_at φ φ' x₀) : ∃ (a b : ℝ), (a, b) ≠ 0 ∧ a • f' + b • φ' = 0
theorem matrix.det_zero_of_column_eq {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] {M : matrix n n R} {i j : n} (i_ne_j : i ≠ j) (hij : ∀ (k : n), M k i = M k j) : M.det = 0
theorem order_of_eq_of_pow_and_pow_div_prime {G : Type u} {x : G} {n : ℕ} [monoid G] (hn : 0 < n) (hx : x ^ n = 1) (hd : ∀ (p : ℕ), nat.prime p → p ∣ n → x ^ (n / p) ≠ 1) : order_of x = n
theorem add_monoid.closure_singleton {M : Type u_1} [add_monoid M] {x : M} : add_monoid.closure {x} = multiples x
theorem is_local_extr_on.range_ne_top_of_has_strict_fderiv_at {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [complete_space E] [normed_group F] [normed_space ℝ F] [complete_space F] {f : E → F} {φ : E → ℝ} {x₀ : E} {f' : E →L[ℝ] F} {φ' : E →L[ℝ] ℝ} (hextr : is_local_extr_on φ {x : E | f x = f x₀} x₀) (hf' : has_strict_fderiv_at f f' x₀) (hφ' : has_strict_fderiv_at φ φ' x₀) : (f'.prod φ').range ≠ ⊤
theorem metric.bounded_sphere {α : Type u} [pseudo_metric_space α] {x : α} {r : ℝ} : metric.bounded (metric.sphere x r)
theorem is_cyclotomic_extension.discr_prime_pow_ne_two {p : ℕ+} {k : ℕ} {K : Type u} {L : Type v} {ζ : L} [field K] [field L] [algebra K L] [is_cyclotomic_extension {p ^ (k + 1)} K L] [hp : fact (nat.prime ↑p)] [ne_zero ↑↑p] (hζ : is_primitive_root ζ ↑(p ^ (k + 1))) (hirr : irreducible (polynomial.cyclotomic ↑(p ^ (k + 1)) K)) (hk : p ^ (k + 1) ≠ 2) : algebra.discr K ⇑((is_primitive_root.power_basis K hζ).basis) = (-1) ^ ((↑p ^ (k + 1)).totient / 2) * ↑p ^ (↑p ^ k * ((↑p - 1) * (k + 1) - 1))
theorem orthonormal.two_zsmul_oangle_neg_left {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x y : V) : 2 • hb.oangle (-x) y = 2 • hb.oangle x y
theorem eventually_uniformity_comp_subset {α : Type u_1} [uniform_space α] {s : set (α × α)} (hs : s ∈ uniformity α) : ∀ᶠ (t : set (α × α)) in (uniformity α).small_sets, comp_rel t t ⊆ s
theorem orthonormal.rotation_zero {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) : hb.rotation 0 = linear_isometry_equiv.refl ℝ V
theorem category_theory.limits.limit_π_is_iso_of_is_strict_terminal {C : Type u} [category_theory.category C] [category_theory.limits.has_strict_terminal_objects C] {J : Type v} [category_theory.small_category J] (F : J ⥤ C) [category_theory.limits.has_limit F] (i : J) (H : Π (j : J), j ≠ i → category_theory.limits.is_terminal (F.obj j)) [subsingleton (i ⟶ i)] : category_theory.is_iso (category_theory.limits.limit.π F i)
theorem measure_theory.ae_of_forall_measure_lt_top_ae_restrict' {α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} (ν : measure_theory.measure α) [measure_theory.sigma_finite μ] [measure_theory.sigma_finite ν] (P : α → Prop) (h : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ⇑ν s < ⊤ → (∀ᵐ (x : α) ∂μ.restrict s, P x)) : ∀ᵐ (x : α) ∂μ, P x
theorem lower_central_series_is_descending_central_series {G : Type u_1} [group G] : is_descending_central_series (lower_central_series G)
theorem pgame.right_response_spec {x : pgame} (h : x ≤ 0) (i : x.left_moves) : (x.move_left i).move_right (pgame.right_response h i) ≤ 0
theorem subgroup.schur_zassenhaus_induction.step7 {G : Type u} [group G] [fintype G] {N : subgroup G} [N.normal] (h1 : (fintype.card ↥N).coprime N.index) (h2 : ∀ (G' : Type u) [_inst_4 : group G'] [_inst_5 : fintype G'], fintype.card G' < fintype.card G → ∀ {N' : subgroup G'} [_inst_6 : N'.normal], (fintype.card ↥N').coprime N'.index → (∃ (H' : subgroup G'), N'.is_complement' H')) (h3 : ∀ (H : subgroup G), ¬N.is_complement' H) : N.is_commutative
theorem weak_dual.is_closed_polar (𝕜 : Type u_1) [nondiscrete_normed_field 𝕜] {E : Type u_2} [semi_normed_group E] [normed_space 𝕜 E] (s : set E) : is_closed (weak_dual.polar 𝕜 s)
theorem ODE_solution_unique {E : Type u_1} [normed_group E] [normed_space ℝ E] {v : ℝ → E → E} {K : nnreal} (hv : ∀ (t : ℝ), lipschitz_with K (v t)) {f g : ℝ → E} {a b : ℝ} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (t : ℝ), t ∈ set.Ico a b → has_deriv_within_at f (v t (f t)) (set.Ici t) t) (hg : continuous_on g (set.Icc a b)) (hg' : ∀ (t : ℝ), t ∈ set.Ico a b → has_deriv_within_at g (v t (g t)) (set.Ici t) t) (ha : f a = g a) (t : ℝ) (H : t ∈ set.Icc a b) : f t = g t
theorem module.free.rank_finsupp (R : Type u) [ring R] [strong_rank_condition R] {ι : Type v} : module.rank R (ι →₀ R) = (cardinal.mk ι).lift
theorem cont_diff_succ_iff_deriv {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f₂ : 𝕜 → F} {n : ℕ} : cont_diff 𝕜 ↑(n + 1) f₂ ↔ differentiable 𝕜 f₂ ∧ cont_diff 𝕜 ↑n (deriv f₂)
theorem polynomial.cyclotomic.is_primitive (n : ℕ) (R : Type u_1) [comm_ring R] : (polynomial.cyclotomic n R).is_primitive
theorem is_compact.diff {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_open t) : is_compact (s  t)
theorem zmod.χ₈_int_eq_if_mod_eight (n : ℤ) : ⇑zmod.χ₈ ↑n = ite (n % 2 = 0) 0 (ite (n % 8 = 1 ∨ n % 8 = 7) 1 (-1))
theorem has_fpower_series_on_cauchy_integral {E : Type u_1} [normed_group E] [normed_space ℂ E] [complete_space E] {f : ℂ → E} {c : ℂ} {R : nnreal} (hf : circle_integrable f c ↑R) (hR : 0 < R) : has_fpower_series_on_ball (λ (w : ℂ), (2 * ↑real.pi * complex.I)⁻¹ • ∮ (z : ℂ) in C(c, ↑R), (z - w)⁻¹ • f z) (cauchy_power_series f c ↑R) c ↑R
theorem subtype.mem {α : Type u_1} {s : set α} (p : ↥s) : ↑p ∈ s
theorem first_order.language.substructure.ext {L : first_order.language} {M : Type w} [L.Structure M] {S T : L.substructure M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T) : S = T
theorem sbtw_cyclic {α : Type u_1} [circular_preorder α] {a b c : α} : has_sbtw.sbtw a b c ↔ has_sbtw.sbtw c a b
theorem affine.simplex.sum_monge_point_vsub_face_centroid_weights_with_circumcenter {n : ℕ} {i₁ i₂ : fin (n + 3)} (h : i₁ ≠ i₂) : finset.univ.sum (λ (i : affine.simplex.points_with_circumcenter_index (n + 2)), affine.simplex.monge_point_vsub_face_centroid_weights_with_circumcenter i₁ i₂ i) = 0
theorem category_theory.topology_of_closure_operator_self {C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) : category_theory.topology_of_closure_operator J₁.closure_operator _ = J₁
theorem polynomial.cyclotomic'_one (R : Type u_1) [comm_ring R] [is_domain R] : polynomial.cyclotomic' 1 R = polynomial.X - 1
theorem category_theory.limits.colimit.ι_desc {J : Type u₁} [category_theory.category J] {C : Type u} [category_theory.category C] {F : J ⥤ C} [category_theory.limits.has_colimit F] (c : category_theory.limits.cocone F) (j : J) : category_theory.limits.colimit.ι F j ≫ category_theory.limits.colimit.desc F c = c.ι.app j
theorem measure_theory.is_fundamental_domain.is_mul_left_invariant_map {G : Type u_1} [group G] [measurable_space G] [topological_space G] [topological_group G] [borel_space G] {μ : measure_theory.measure G} {Γ : subgroup G} {𝓕 : set G} (h𝓕 : measure_theory.is_fundamental_domain ↥(Γ.opposite) 𝓕 μ) [encodable ↥Γ] [measurable_space (G ⧸ Γ)] [borel_space (G ⧸ Γ)] [Γ.normal] [μ.is_mul_left_invariant] [μ.is_mul_right_invariant] : (measure_theory.measure.map ⇑(quotient_group.mk' Γ) (μ.restrict 𝓕)).is_mul_left_invariant
theorem monovary_on.sum_smul_comp_perm_eq_sum_smul_iff {ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {s : finset ι} {σ : equiv.perm ι} {f : ι → α} {g : ι → β} (hfg : monovary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i • g (⇑σ i)) = s.sum (λ (i : ι), f i • g i) ↔ monovary_on f (g ∘ ⇑σ) ↑s
theorem measure_theory.set_integral_condexp_L1_clm {α : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space ℝ F'] [complete_space F'] {m m0 : measurable_space α} {μ : measure_theory.measure α} {hm : m ≤ m0} [measure_theory.sigma_finite (μ.trim hm)] {s : set α} (f : ↥(measure_theory.Lp F' 1 μ)) (hs : measurable_set s) : ∫ (x : α) in s, ⇑(⇑(measure_theory.condexp_L1_clm hm μ) f) x ∂μ = ∫ (x : α) in s, ⇑f x ∂μ
theorem formal_multilinear_series.radius_eq_liminf {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) : p.radius = filter.at_top.liminf (λ (n : ℕ), 1 / ↑(∥p n∥₊ ^ (1 / ↑n)))
theorem subring.prod_mem {R : Type u_1} [comm_ring R] (s : subring R) {ι : Type u_2} {t : finset ι} {f : ι → R} (h : ∀ (c : ι), c ∈ t → f c ∈ s) : t.prod (λ (i : ι), f i) ∈ s
theorem matrix.exists_mul_vec_eq_zero_iff_aux {n : Type u_3} [fintype n] {K : Type u_1} [decidable_eq n] [field K] {M : matrix n n K} : (∃ (v : n → K) (H : v ≠ 0), M.mul_vec v = 0) ↔ M.det = 0
theorem finsum_mem_union_inter {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} {s t : set α} (hs : s.finite) (ht : t.finite) : finsum (λ (i : α), finsum (λ (H : i ∈ s ∪ t), f i)) + finsum (λ (i : α), finsum (λ (H : i ∈ s ∩ t), f i)) = finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) + finsum (λ (i : α), finsum (λ (H : i ∈ t), f i))
theorem measure_theory.measure_mul_lintegral_eq {G : Type u_1} [measurable_space G] [group G] [has_measurable_mul₂ G] (μ ν : measure_theory.measure G) [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] {E : set G} [has_measurable_inv G] [μ.is_mul_left_invariant] [ν.is_mul_left_invariant] (Em : measurable_set E) (f : G → ennreal) (hf : measurable f) : ⇑μ E * ∫⁻ (y : G), f y ∂ν = ∫⁻ (x : G), ⇑ν ((λ (z : G), z * x) ⁻¹' E) * f x⁻¹ ∂μ
theorem metric.dist_le_diam_of_mem' {α : Type u} [pseudo_metric_space α] {s : set α} {x y : α} (h : emetric.diam s ≠ ⊤) (hx : x ∈ s) (hy : y ∈ s) : has_dist.dist x y ≤ metric.diam s
theorem pi_norm_lt_iff {ι : Type u_2} {π : ι → Type u_1} [fintype ι] [Π (i : ι), semi_normed_group (π i)] {r : ℝ} (hr : 0 < r) {x : Π (i : ι), π i} : ∥x∥ < r ↔ ∀ (i : ι), ∥x i∥ < r
theorem polynomial.cyclotomic_injective {R : Type u_1} [comm_ring R] [char_zero R] : function.injective (λ (n : ℕ), polynomial.cyclotomic n R)
theorem metric.controlled_of_uniform_embedding {α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {f : α → β} : uniform_embedding f → ((∀ (ε : ℝ), ε > 0 → (∃ (δ : ℝ) (H : δ > 0), ∀ {a b : α}, has_dist.dist a b < δ → has_dist.dist (f a) (f b) < ε)) ∧ ∀ (δ : ℝ), δ > 0 → (∃ (ε : ℝ) (H : ε > 0), ∀ {a b : α}, has_dist.dist (f a) (f b) < ε → has_dist.dist a b < δ))
theorem direct_sum.is_internal.submodule_supr_eq_top {R : Type u} [semiring R] {ι : Type v} [dec_ι : decidable_eq ι] {M : Type u_1} [add_comm_monoid M] [module R M] {A : ι → submodule R M} (h : direct_sum.is_internal A) : supr A = ⊤
theorem finsupp.prod_ite_eq' {α : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [comm_monoid N] [decidable_eq α] (f : α →₀ M) (a : α) (b : α → M → N) : f.prod (λ (x : α) (v : M), ite (x = a) (b x v) 1) = ite (a ∈ f.support) (b a (⇑f a)) 1
theorem alternating_group.normal_closure_swap_mul_swap_five  : subgroup.normal_closure {⟨equiv.swap 0 4 * equiv.swap 1 3, _⟩} = ⊤
theorem cInf_eq_of_forall_ge_of_forall_gt_exists_lt {α : Type u_1} [conditionally_complete_lattice α] {s : set α} {b : α} : s.nonempty → (∀ (a : α), a ∈ s → b ≤ a) → (∀ (w : α), b < w → (∃ (a : α) (H : a ∈ s), a < w)) → has_Inf.Inf s = b
theorem finset.up_shadow_empty {α : Type u_1} [decidable_eq α] [fintype α] : ∅.up_shadow = ∅
theorem is_compact.inter_right {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) : is_compact (s ∩ t)
theorem measure_theory.integral_divergence_of_has_fderiv_within_at_off_countable_of_equiv {E : Type u} [normed_group E] [normed_space ℝ E] [complete_space E] {n : ℕ} {F : Type u_1} [normed_group F] [normed_space ℝ F] [partial_order F] [measure_theory.measure_space F] [borel_space F] (eL : F ≃L[ℝ] fin (n + 1) → ℝ) (he_ord : ∀ (x y : F), ⇑eL x ≤ ⇑eL y ↔ x ≤ y) (he_vol : measure_theory.measure_preserving ⇑eL measure_theory.measure_space.volume measure_theory.measure_space.volume) (f : fin (n + 1) → F → E) (f' : fin (n + 1) → F → (F →L[ℝ] E)) (s : set F) (hs : s.countable) (a b : F) (hle : a ≤ b) (Hc : ∀ (i : fin (n + 1)), continuous_on (f i) (set.Icc a b)) (Hd : ∀ (x : F), x ∈ interior (set.Icc a b)  s → ∀ (i : fin (n + 1)), has_fderiv_at (f i) (f' i x) x) (DF : F → E) (hDF : ∀ (x : F), DF x = finset.univ.sum (λ (i : fin (n + 1)), ⇑(f' i x) (⇑(eL.symm) (pi.single i 1)))) (Hi : measure_theory.integrable_on DF (set.Icc a b) measure_theory.measure_space.volume) : ∫ (x : F) in set.Icc a b, DF x = finset.univ.sum (λ (i : fin (n + 1)), (∫ (x : fin n → ℝ) in set.Icc (⇑eL a ∘ ⇑(i.succ_above)) (⇑eL b ∘ ⇑(i.succ_above)), f i (⇑(eL.symm) (i.insert_nth (⇑eL b i) x))) - ∫ (x : fin n → ℝ) in set.Icc (⇑eL a ∘ ⇑(i.succ_above)) (⇑eL b ∘ ⇑(i.succ_above)), f i (⇑(eL.symm) (i.insert_nth (⇑eL a i) x)))
theorem dense.inter_of_Gδ {α : Type u_1} [topological_space α] [baire_space α] {s t : set α} (hs : is_Gδ s) (ht : is_Gδ t) (hsc : dense s) (htc : dense t) : dense (s ∩ t)
theorem integral_sin_pow_even_mul_cos_pow_even {a b : ℝ} (m n : ℕ) : ∫ (x : ℝ) in a..b, real.sin x ^ (2 * m) * real.cos x ^ (2 * n) = ∫ (x : ℝ) in a..b, ((1 - real.cos (2 * x)) / 2) ^ m * ((1 + real.cos (2 * x)) / 2) ^ n
theorem alternating_map.coe_alternatization {R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N' : Type u_5} [add_comm_group N'] [module R N'] {ι : Type u_6} [decidable_eq ι] [fintype ι] (a : alternating_map R M N' ι) : ⇑multilinear_map.alternatization ↑a = (fintype.card ι).factorial • a
theorem padic_val_int.zero {p : ℕ} : padic_val_int p 0 = 0
theorem lie_algebra.lie_ideal.solvable_iff_le_radical (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] (I : lie_ideal R L) : lie_algebra.is_solvable R ↥I ↔ I ≤ lie_algebra.radical R L
theorem add_con.coe_zero {M : Type u_1} [add_zero_class M] {c : add_con M} : ↑0 = 0
theorem metric.diam_union {α : Type u} [pseudo_metric_space α] {s : set α} {x y : α} {t : set α} (xs : x ∈ s) (yt : y ∈ t) : metric.diam (s ∪ t) ≤ metric.diam s + has_dist.dist x y + metric.diam t
theorem directed_of_sup {α : Type u} {β : Type v} [semilattice_sup α] {f : α → β} {r : β → β → Prop} (H : ∀ ⦃i j : α⦄, i ≤ j → r (f i) (f j)) : directed r f
theorem continuous_multilinear_map.map_sum {R : Type u} {ι : Type v} {M₁ : ι → Type w₁} {M₂ : Type w₂} [decidable_eq ι] [semiring R] [Π (i : ι), add_comm_monoid (M₁ i)] [add_comm_monoid M₂] [Π (i : ι), module R (M₁ i)] [module R M₂] [Π (i : ι), topological_space (M₁ i)] [topological_space M₂] (f : continuous_multilinear_map R M₁ M₂) {α : ι → Type u_1} [fintype ι] (g : Π (i : ι), α i → M₁ i) [Π (i : ι), fintype (α i)] : ⇑f (λ (i : ι), finset.univ.sum (λ (j : α i), g i j)) = finset.univ.sum (λ (r : Π (i : ι), α i), ⇑f (λ (i : ι), g i (r i)))
theorem continuous.exists_forall_le_of_has_compact_mul_support {α : Type u_1} {β : Type u_2} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [topological_space β] [nonempty β] [has_one α] {f : β → α} (hf : continuous f) (h : has_compact_mul_support f) : ∃ (x : β), ∀ (y : β), f x ≤ f y
theorem int.dvd_of_dvd_mul_left_of_gcd_one {a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd c = 1) : a ∣ b
theorem nndist_self {α : Type u} [pseudo_metric_space α] (a : α) : has_nndist.nndist a a = 0
theorem set.image2_subset {α : Type u_1} {β : Type u_3} {γ : Type u_5} {f : α → β → γ} {s s' : set α} {t t' : set β} (hs : s ⊆ s') (ht : t ⊆ t') : set.image2 f s t ⊆ set.image2 f s' t'
theorem finset.prod_erase_mul {β : Type u} {α : Type v} [comm_monoid β] [decidable_eq α] (s : finset α) (f : α → β) {a : α} (h : a ∈ s) : (s.erase a).prod (λ (x : α), f x) * f a = s.prod (λ (x : α), f x)
theorem mv_power_series.ext_iff {σ : Type u_1} {R : Type u_2} [semiring R] {φ ψ : mv_power_series σ R} : φ = ψ ↔ ∀ (n : σ →₀ ℕ), ⇑(mv_power_series.coeff R n) φ = ⇑(mv_power_series.coeff R n) ψ
theorem orthonormal.tsum_inner_products_le {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} (x : E) {v : ι → E} (hv : orthonormal 𝕜 v) : ∑' (i : ι), ∥has_inner.inner (v i) x∥ ^ 2 ≤ ∥x∥ ^ 2
theorem Inter_halfspaces_eq {E : Type u_2} [normed_group E] [normed_space ℝ E] {s : set E} (hs₁ : convex ℝ s) (hs₂ : is_closed s) : (⋂ (l : E →L[ℝ] ℝ), {x : E | ∃ (y : E) (H : y ∈ s), ⇑l x ≤ ⇑l y}) = s
theorem add_monoid_hom.congr_arg {M : Type u_3} {N : Type u_4} [add_zero_class M] [add_zero_class N] (f : M →+ N) {x y : M} (h : x = y) : ⇑f x = ⇑f y
theorem convex_on_open_of_deriv2_nonneg {D : set ℝ} (hD : convex ℝ D) (hD₂ : is_open D) {f : ℝ → ℝ} (hf' : differentiable_on ℝ f D) (hf'' : differentiable_on ℝ (deriv f) D) (hf''_nonneg : ∀ (x : ℝ), x ∈ D → 0 ≤ deriv^[2] f x) : convex_on ℝ D f
theorem exists_countable_dense_bot_top (α : Type u_1) [topological_space α] [topological_space.separable_space α] [partial_order α] : ∃ (s : set α), s.countable ∧ dense s ∧ (∀ (x : α), is_bot x → x ∈ s) ∧ ∀ (x : α), is_top x → x ∈ s
theorem module.End.maximal_generalized_eigenspace_eq {R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] [h : is_noetherian R M] (f : module.End R M) (μ : R) : f.maximal_generalized_eigenspace μ = ⇑(f.generalized_eigenspace μ) (f.maximal_generalized_eigenspace_index μ)
theorem strict_convex_on.translate_left {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_cancel_comm_monoid E] [ordered_add_comm_monoid β] [module 𝕜 E] [has_scalar 𝕜 β] {s : set E} {f : E → β} (hf : strict_convex_on 𝕜 s f) (c : E) : strict_convex_on 𝕜 ((λ (z : E), c + z) ⁻¹' s) (f ∘ λ (z : E), z + c)
theorem orthonormal.oangle_map {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x y : V) (f : V ≃ₗᵢ[ℝ] V) : _.oangle x y = hb.oangle (⇑(f.symm) x) (⇑(f.symm) y)
theorem Profinite.exists_locally_constant {J : Type u} [category_theory.small_category J] [category_theory.is_cofiltered J] {F : J ⥤ Profinite} (C : category_theory.limits.cone F) (hC : category_theory.limits.is_limit C) {α : Type u_1} (f : locally_constant ↥(C.X) α) : ∃ (j : J) (g : locally_constant ↥(F.obj j) α), f = locally_constant.comap ⇑(C.π.app j) g
theorem triple_product_eq_det {R : Type u_1} [comm_ring R] (u v w : fin 3 → R) : matrix.dot_product u (⇑(⇑cross_product v) w) = matrix.det ![u, v, w]
theorem function.periodic.tendsto_at_bot_interval_integral_of_pos {T : ℝ} {g : ℝ → ℝ} (hg : function.periodic g T) (h_int : ∀ (t₁ t₂ : ℝ), interval_integrable g measure_theory.measure_space.volume t₁ t₂) (h₀ : 0 < ∫ (x : ℝ) in 0..T, g x) (hT : 0 < T) : filter.tendsto (λ (t : ℝ), ∫ (x : ℝ) in 0..t, g x) filter.at_bot filter.at_bot
theorem inner_product_geometry.norm_add_sq_eq_norm_sq_add_norm_sq' {V : Type u_1} [inner_product_space ℝ V] (x y : V) (h : inner_product_geometry.angle x y = real.pi / 2) : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥
theorem polynomial.X_pow_sub_one_eq_prod {R : Type u_1} [comm_ring R] [is_domain R] {ζ : R} {n : ℕ} (hpos : 0 < n) (h : is_primitive_root ζ n) : polynomial.X ^ n - 1 = (polynomial.nth_roots_finset n R).prod (λ (ζ : R), polynomial.X - ⇑polynomial.C ζ)
theorem continuous_linear_map.lipschitz_apply {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [ring_hom_isometric σ₁₂] (x : E) : lipschitz_with ∥x∥₊ (λ (f : E →SL[σ₁₂] F), ⇑f x)
theorem dim_submodule_le_one_iff' {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (s : submodule K V) : module.rank K ↥s ≤ 1 ↔ ∃ (v₀ : V), s ≤ submodule.span K {v₀}
theorem clifford_algebra.reverse_prod_map_ι {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Q : quadratic_form R M} (l : list M) : ⇑clifford_algebra.reverse (list.map ⇑(clifford_algebra.ι Q) l).prod = (list.map ⇑(clifford_algebra.ι Q) l).reverse.prod
theorem euclidean_geometry.orthogonal_projection_vsub_mem_direction {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} [nonempty ↥s] [complete_space ↥(s.direction)] {p1 : P} (p2 : P) (hp1 : p1 ∈ s) : ↑(⇑(euclidean_geometry.orthogonal_projection s) p2 -ᵥ ⟨p1, hp1⟩) ∈ s.direction
theorem eq_zero_of_zero_eq_one {M₀ : Type u_1} [mul_zero_one_class M₀] (h : 0 = 1) (a : M₀) : a = 0
theorem cont_diff_at.exists_lipschitz_on_with {𝕂 : Type u_6} [is_R_or_C 𝕂] {E' : Type u_7} [normed_group E'] [normed_space 𝕂 E'] {F' : Type u_8} [normed_group F'] [normed_space 𝕂 F'] {f : E' → F'} {x : E'} (hf : cont_diff_at 𝕂 1 f x) : ∃ (K : nnreal) (t : set E') (H : t ∈ nhds x), lipschitz_on_with K f t
theorem local_homeomorph.singleton_has_groupoid {H : Type u} [topological_space H] {α : Type u_5} [topological_space α] (e : local_homeomorph α H) (h : e.to_local_equiv.source = set.univ) (G : structure_groupoid H) [closed_under_restriction G] : has_groupoid α G
theorem mem_nhds_within_Iic_iff_exists_Ioc_subset' {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a l' : α} {s : set α} (hl' : l' < a) : s ∈ nhds_within a (set.Iic a) ↔ ∃ (l : α) (H : l ∈ set.Iio a), set.Ioc l a ⊆ s
theorem complex.tendsto_exp_comap_re_at_bot  : filter.tendsto complex.exp (filter.comap complex.re filter.at_bot) (nhds 0)
theorem exp_neg_inv_glue.f_aux_deriv (n : ℕ) (x : ℝ) (hx : x ≠ 0) : has_deriv_at (λ (x : ℝ), polynomial.eval x (exp_neg_inv_glue.P_aux n) * real.exp (-x⁻¹) / x ^ (2 * n)) (polynomial.eval x (exp_neg_inv_glue.P_aux (n + 1)) * real.exp (-x⁻¹) / x ^ (2 * (n + 1))) x
theorem metric.closure_subset_thickening {α : Type u} [pseudo_emetric_space α] {δ : ℝ} (δ_pos : 0 < δ) (E : set α) : closure E ⊆ metric.thickening δ E
theorem norm_sub_sq_eq_norm_sq_add_norm_sq_real {F : Type u_3} [inner_product_space ℝ F] {x y : F} (h : has_inner.inner x y = 0) : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥
theorem list.tail_sum (L : list ℕ) : L.tail.sum = L.sum - L.head
theorem measure_theory.simple_func.induction {α : Type u_1} {γ : Type u_2} [measurable_space α] [add_monoid γ] {P : measure_theory.simple_func α γ → Prop} (h_ind : ∀ (c : γ) {s : set α} (hs : measurable_set s), P (measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0))) (h_add : ∀ ⦃f g : measure_theory.simple_func α γ⦄, disjoint (function.support ⇑f) (function.support ⇑g) → P f → P g → P (f + g)) (f : measure_theory.simple_func α γ) : P f
theorem finset.prod_congr_set {α : Type u_1} [comm_monoid α] {β : Type u_2} [fintype β] (s : set β) [decidable_pred (λ (_x : β), _x ∈ s)] (f : β → α) (g : ↥s → α) (w : ∀ (x : β) (h : x ∈ s), f x = g ⟨x, h⟩) (w' : ∀ (x : β), x ∉ s → f x = 1) : finset.univ.prod f = finset.univ.prod g
theorem cont_mdiff_at_iff_cont_mdiff_on_nhds {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M → M'} {x : M} {n : ℕ} : cont_mdiff_at I I' ↑n f x ↔ ∃ (u : set M) (H_1 : u ∈ nhds x), cont_mdiff_on I I' ↑n f u
theorem set.image3_congr' {α : Type u_1} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {g g' : α → β → γ → δ} {s : set α} {t : set β} {u : set γ} (h : ∀ (a : α) (b : β) (c : γ), g a b c = g' a b c) : set.image3 g s t u = set.image3 g' s t u
theorem free_group.red.cons_nil_iff_singleton {α : Type u} {L : list (α × bool)} {x : α} {b : bool} : free_group.red ((x, b) :: L) list.nil ↔ free_group.red L [(x, !b)]
theorem local_homeomorph.continuous_at_symm {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) {x : β} (h : x ∈ e.to_local_equiv.target) : continuous_at ⇑(e.symm) x
theorem monotone.add {α : Type u_1} {β : Type u_2} [has_add α] [preorder α] [preorder β] {f g : β → α} [covariant_class α α has_add.add has_le.le] [covariant_class α α (function.swap has_add.add) has_le.le] (hf : monotone f) (hg : monotone g) : monotone (λ (x : β), f x + g x)
theorem orthonormal.two_zsmul_oangle_smul_right_of_ne_zero {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x y : V) {r : ℝ} (hr : r ≠ 0) : 2 • hb.oangle x (r • y) = 2 • hb.oangle x y
theorem continuous.snd' {α : Type u} {β : Type v} {γ : Type u_1} [topological_space α] [topological_space β] [topological_space γ] {f : β → γ} (hf : continuous f) : continuous (λ (x : α × β), f x.snd)
theorem is_compact.uniform_continuous_on_of_continuous' {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] {s : set α} {f : α → β} (hs : is_compact s) (hs' : is_separated s) (hf : continuous_on f s) : uniform_continuous_on f s
theorem Compactum_to_CompHaus.faithful  : category_theory.faithful Compactum_to_CompHaus
theorem open_segment_subset_ball_of_ne {E : Type u_2} [normed_group E] [normed_space ℝ E] [strict_convex_space ℝ E] {x y z : E} {r : ℝ} (hx : x ∈ metric.closed_ball z r) (hy : y ∈ metric.closed_ball z r) (hne : x ≠ y) : open_segment ℝ x y ⊆ metric.ball z r
theorem simplex_category.mono_iff_injective {n m : simplex_category} {f : n ⟶ m} : category_theory.mono f ↔ function.injective ⇑(simplex_category.hom.to_order_hom f)
theorem probability_theory.indep_fun.integrable_mul {α : Type u_1} {mα : measurable_space α} {μ : measure_theory.measure α} {β : Type u_2} [measurable_space β] {X Y : α → β} [normed_division_ring β] [borel_space β] (hXY : probability_theory.indep_fun X Y μ) (hX : measure_theory.integrable X μ) (hY : measure_theory.integrable Y μ) : measure_theory.integrable (X * Y) μ
theorem measure_theory.signed_measure.of_symm_diff_compl_positive_negative {α : Type u_1} [measurable_space α] {s : measure_theory.signed_measure α} {i j : set α} (hi : measurable_set i) (hj : measurable_set j) (hi' : 0.restrict i ≤ measure_theory.vector_measure.restrict s i ∧ measure_theory.vector_measure.restrict s iᶜ ≤ 0.restrict iᶜ) (hj' : 0.restrict j ≤ measure_theory.vector_measure.restrict s j ∧ measure_theory.vector_measure.restrict s jᶜ ≤ 0.restrict jᶜ) : ⇑s (i ∆ j) = 0 ∧ ⇑s (iᶜ ∆ jᶜ) = 0
theorem polynomial.erase_mem_lifts {R : Type u} [semiring R] {S : Type v} [semiring S] {f : R →+* S} {p : polynomial S} (n : ℕ) (h : p ∈ polynomial.lifts f) : polynomial.erase n p ∈ polynomial.lifts f
theorem and_or_distrib_right {a b c : Prop} : a ∧ b ∨ c ↔ (a ∨ c) ∧ (b ∨ c)
theorem ring_hom.codomain_trivial_iff_range_trivial {α : Type u_2} {β : Type u_3} {rα : non_assoc_semiring α} {rβ : non_assoc_semiring β} (f : α →+* β) : 0 = 1 ↔ ∀ (x : α), ⇑f x = 0
theorem cont_diff_on_top_iff_deriv_within {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f₂ : 𝕜 → F} {s₂ : set 𝕜} (hs : unique_diff_on 𝕜 s₂) : cont_diff_on 𝕜 ⊤ f₂ s₂ ↔ differentiable_on 𝕜 f₂ s₂ ∧ cont_diff_on 𝕜 ⊤ (deriv_within f₂ s₂) s₂
theorem finset.sum_erase {β : Type u} {α : Type v} [add_comm_monoid β] [decidable_eq α] (s : finset α) {f : α → β} {a : α} (h : f a = 0) : (s.erase a).sum (λ (x : α), f x) = s.sum (λ (x : α), f x)
theorem torus_integrable.sub {n : ℕ} {E : Type u_1} [normed_group E] {f g : (fin n → ℂ) → E} {c : fin n → ℂ} {R : fin n → ℝ} (hf : torus_integrable f c R) (hg : torus_integrable g c R) : torus_integrable (f - g) c R
theorem unitization.ind {R : Type u_1} {A : Type u_2} [add_zero_class R] [add_zero_class A] {P : unitization R A → Prop} (h : ∀ (r : R) (a : A), P (unitization.inl r + ↑a)) (x : unitization R A) : P x
theorem algebra.is_algebraic_of_larger_base_of_injective {R : Type u_3} {S : Type u_4} {A : Type u_5} [comm_ring R] [comm_ring S] [comm_ring A] [algebra R S] [algebra S A] [algebra R A] [is_scalar_tower R S A] (hinj : function.injective ⇑(algebra_map R S)) (A_alg : algebra.is_algebraic R A) : algebra.is_algebraic S A
theorem is_localization.card {R : Type u} [comm_ring R] (S : submonoid R) (L : Type u) [comm_ring L] [algebra R L] [is_localization S L] (hS : S ≤ non_zero_divisors R) : cardinal.mk R = cardinal.mk L
theorem lebesgue_number_lemma_sUnion {α : Type u} [uniform_space α] {s : set α} {c : set (set α)} (hs : is_compact s) (hc₁ : ∀ (t : set α), t ∈ c → is_open t) (hc₂ : s ⊆ ⋃₀c) : ∃ (n : set (α × α)) (H : n ∈ uniformity α), ∀ (x : α), x ∈ s → (∃ (t : set α) (H : t ∈ c), ∀ (y : α), (x, y) ∈ n → y ∈ t)
theorem mul_le_of_le_inv_mul {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α} : b ≤ a⁻¹ * c → a * b ≤ c
theorem ideal.exists_nonzero_mem_of_ne_bot {R : Type u_1} [comm_ring R] {P : ideal (polynomial R)} (Pb : P ≠ ⊥) (hP : ∀ (x : R), ⇑polynomial.C x ∈ P → x = 0) : ∃ (p : polynomial R), p ∈ P ∧ polynomial.map (ideal.quotient.mk (ideal.comap polynomial.C P)) p ≠ 0
theorem powers.self_mem {M : Type u_1} [monoid M] {x : M} : x ∈ powers x
theorem quadratic_form.equivalent_one_neg_one_weighted_sum_squared {M : Type u_1} [add_comm_group M] [module ℝ M] [finite_dimensional ℝ M] (Q : quadratic_form ℝ M) (hQ : (⇑quadratic_form.associated Q).nondegenerate) : ∃ (w : fin (finite_dimensional.finrank ℝ M) → ℝ), (∀ (i : fin (finite_dimensional.finrank ℝ M)), w i = -1 ∨ w i = 1) ∧ Q.equivalent (quadratic_form.weighted_sum_squares ℝ w)
theorem matrix.det_fin_zero {R : Type v} [comm_ring R] {A : matrix (fin 0) (fin 0) R} : A.det = 1
theorem category_theory.finrank_endomorphism_eq_one {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (𝕜 : Type u_3) [field 𝕜] [is_alg_closed 𝕜] [category_theory.linear 𝕜 C] {X : C} (is_iso_iff_nonzero : ∀ (f : X ⟶ X), category_theory.is_iso f ↔ f ≠ 0) [I : finite_dimensional 𝕜 (X ⟶ X)] : finite_dimensional.finrank 𝕜 (X ⟶ X) = 1
theorem category_theory.Ran_is_sheaf_of_cover_lifting {C D : Type u} [category_theory.category C] [category_theory.category D] {A : Type w} [category_theory.category A] [category_theory.limits.has_limits A] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {G : C ⥤ D} (hG : category_theory.cover_lifting J K G) (ℱ : category_theory.Sheaf J A) : category_theory.presheaf.is_sheaf K ((category_theory.Ran G.op).obj ℱ.val)
theorem roth_number_nat_is_O_id  : (λ (N : ℕ), ↑(⇑roth_number_nat N)) =O[filter.at_top] λ (N : ℕ), ↑N
theorem modular_group.exists_smul_mem_fd (z : upper_half_plane) : ∃ (g : matrix.special_linear_group (fin 2) ℤ), g • z ∈ modular_group.fd
theorem interval_integral.integral_has_deriv_within_at_of_tendsto_ae_right {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {c : E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set ℝ} [interval_integral.FTC_filter b (nhds_within b s) (nhds_within b t)] (hmeas : strongly_measurable_at_filter f (nhds_within b t) measure_theory.measure_space.volume) (hb : filter.tendsto f (nhds_within b t ⊓ measure_theory.measure_space.volume.ae) (nhds c)) : has_deriv_within_at (λ (u : ℝ), ∫ (x : ℝ) in a..u, f x) c s b
theorem sum_hom_units_eq_zero {R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G →* R) (hf : f ≠ 1) : finset.univ.sum (λ (g : G), ⇑f g) = 0
theorem continuous.strongly_measurable {α : Type u_1} [measurable_space α] [topological_space α] [opens_measurable_space α] {β : Type u_2} [topological_space β] [topological_space.pseudo_metrizable_space β] [h : second_countable_topology_either α β] {f : α → β} (hf : continuous f) : measure_theory.strongly_measurable f
theorem left.mul_lt_one_of_le_of_lt {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1
theorem factorization_pow {α : Type u_1} [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] [normalization_monoid α] [decidable_eq α] {x : α} {n : ℕ} : factorization (x ^ n) = n • factorization x
theorem ereal.neg_le {a b : ereal} : -a ≤ b ↔ -b ≤ a
theorem list.perm.prod_eq' {α : Type uu} [monoid α] {l₁ l₂ : list α} (h : l₁ ~ l₂) (hc : list.pairwise (λ (x y : α), x * y = y * x) l₁) : l₁.prod = l₂.prod
theorem linear_equiv.dim_map_eq {R : Type u} [ring R] {M : Type v} [add_comm_group M] [module R M] {M₁ : Type v} [add_comm_group M₁] [module R M₁] (f : M ≃ₗ[R] M₁) (p : submodule R M) : module.rank R ↥(submodule.map ↑f p) = module.rank R ↥p
theorem box_integral.has_integral_of_bRiemann_eq_ff_of_forall_is_o {ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} (hl : l.bRiemann = bool.ff) (B : box_integral.box_additive_map ι ℝ ↑I) (hB0 : ∀ (J : box_integral.box ι), 0 ≤ ⇑B J) (g : box_integral.box_additive_map ι F ↑I) (s : set (ι → ℝ)) (hs : s.countable) (hlH : s.nonempty → l.bHenstock = bool.tt) (H₁ : ∀ (c : nnreal) (x : ι → ℝ), x ∈ ⇑box_integral.box.Icc I ∩ s → ∀ (ε : ℝ), ε > 0 → (∃ (δ : ℝ) (H : δ > 0), ∀ (J : box_integral.box ι), J ≤ I → ⇑box_integral.box.Icc J ⊆ metric.closed_ball x δ → x ∈ ⇑box_integral.box.Icc J → (↥(l.bDistortion) → J.distortion ≤ c) → has_dist.dist (⇑(⇑vol J) (f x)) (⇑g J) ≤ ε)) (H₂ : ∀ (c : nnreal) (x : ι → ℝ), x ∈ ⇑box_integral.box.Icc I  s → ∀ (ε : ℝ), ε > 0 → (∃ (δ : ℝ) (H : δ > 0), ∀ (J : box_integral.box ι), J ≤ I → ⇑box_integral.box.Icc J ⊆ metric.closed_ball x δ → (↥(l.bHenstock) → x ∈ ⇑box_integral.box.Icc J) → (↥(l.bDistortion) → J.distortion ≤ c) → has_dist.dist (⇑(⇑vol J) (f x)) (⇑g J) ≤ ε * ⇑B J)) : box_integral.has_integral I l f vol (⇑g I)
theorem ratfunc.induction_on {K : Type u} [hring : comm_ring K] [hdomain : is_domain K] {P : ratfunc K → Prop} (x : ratfunc K) (f : ∀ (p q : polynomial K), q ≠ 0 → P (⇑(algebra_map (polynomial K) (ratfunc K)) p / ⇑(algebra_map (polynomial K) (ratfunc K)) q)) : P x
theorem compact_covered_by_mul_left_translates {G : Type w} [topological_space G] [group G] [topological_group G] {K V : set G} (hK : is_compact K) (hV : (interior V).nonempty) : ∃ (t : finset G), K ⊆ ⋃ (g : G) (H : g ∈ t), (λ (h : G), g * h) ⁻¹' V
theorem nonempty_omega_limit_of_is_compact_absorbing {τ : Type u_1} {α : Type u_2} {β : Type u_3} [topological_space β] (f : filter τ) (ϕ : τ → α → β) (s : set α) [f.ne_bot] {c : set β} (hc₁ : is_compact c) (hc₂ : ∃ (v : set τ) (H : v ∈ f), closure (set.image2 ϕ v s) ⊆ c) (hs : s.nonempty) : (omega_limit f ϕ s).nonempty
theorem lipschitz_with.list_prod {α : Type u} {ι : Type x} [pseudo_emetric_space α] (f : ι → function.End α) (K : ι → nnreal) (h : ∀ (i : ι), lipschitz_with (K i) (f i)) (l : list ι) : lipschitz_with (list.map K l).prod (list.map f l).prod
theorem finsupp.is_pwo {α : Type u_1} {σ : Type u_2} [has_zero α] [linear_order α] [is_well_order α has_lt.lt] [fintype σ] (S : set (σ →₀ α)) : S.is_pwo
theorem add_units.is_add_unit_add_add_units {M : Type u_1} [add_monoid M] (a : M) (u : add_units M) : is_add_unit (a + ↑u) ↔ is_add_unit a
theorem complete_lattice.is_compact_element.directed_Sup_lt_of_lt {α : Type u_1} [complete_lattice α] {k : α} (hk : complete_lattice.is_compact_element k) {s : set α} (hemp : s.nonempty) (hdir : directed_on has_le.le s) (hbelow : ∀ (x : α), x ∈ s → x < k) : has_Sup.Sup s < k
theorem category_theory.concrete_category.hom_ext {C : Type v} [category_theory.category C] [category_theory.concrete_category C] {X Y : C} (f g : X ⟶ Y) (w : ∀ (x : ↥X), ⇑f x = ⇑g x) : f = g
theorem set.sum_indicator_subset {α : Type u_1} {M : Type u_4} [add_comm_monoid M] (f : α → M) {s t : finset α} (h : s ⊆ t) : s.sum (λ (i : α), f i) = t.sum (λ (i : α), ↑s.indicator f i)
theorem finset.weighted_vsub_of_point_erase {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (w : ι → k) (p : ι → P) (i : ι) : ⇑((s.erase i).weighted_vsub_of_point p (p i)) w = ⇑(s.weighted_vsub_of_point p (p i)) w
theorem inner_product_geometry.angle_comm {V : Type u_1} [inner_product_space ℝ V] (x y : V) : inner_product_geometry.angle x y = inner_product_geometry.angle y x
theorem setoid.map_of_surjective_eq_map {α : Type u_1} {β : Type u_2} {r : setoid α} {f : α → β} (h : setoid.ker f ≤ r) (hf : function.surjective f) : r.map f = r.map_of_surjective f h hf
theorem is_primitive_root.sub_one_norm_prime {p : ℕ+} {K : Type u} {L : Type v} [field L] {ζ : L} [field K] [algebra K L] [ne_zero ↑↑p] [hpri : fact (nat.prime ↑p)] [hcyc : is_cyclotomic_extension {p} K L] (hζ : is_primitive_root ζ ↑p) (hirr : irreducible (polynomial.cyclotomic ↑p K)) (h : p ≠ 2) : ⇑(algebra.norm K) (ζ - 1) = ↑p
theorem cardinal.cantor (a : cardinal) : a < 2 ^ a
theorem measure_theory.measure.mk_metric_le_liminf_tsum {X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] {β : Type u_1} {ι : β → Type u_3} [Π (n : β), encodable (ι n)] (s : set X) {l : filter β} (r : β → ennreal) (hr : filter.tendsto r l (nhds 0)) (t : Π (n : β), ι n → set X) (ht : ∀ᶠ (n : β) in l, ∀ (i : ι n), emetric.diam (t n i) ≤ r n) (hst : ∀ᶠ (n : β) in l, s ⊆ ⋃ (i : ι n), t n i) (m : ennreal → ennreal) : ⇑(measure_theory.measure.mk_metric m) s ≤ l.liminf (λ (n : β), ∑' (i : ι n), m (emetric.diam (t n i)))
theorem modular_group.c_eq_zero {g : matrix.special_linear_group (fin 2) ℤ} {z : upper_half_plane} (hz : z ∈ modular_group.fdo) (hg : g • z ∈ modular_group.fdo) : ↑g 1 0 = 0
theorem inner_product_space.is_self_adjoint.has_eigenvector_of_is_max_on {𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] [complete_space E] {T : E →L[𝕜] E} (hT : inner_product_space.is_self_adjoint ↑T) {x₀ : E} (hx₀ : x₀ ≠ 0) (hextr : is_max_on T.re_apply_inner_self (metric.sphere 0 ∥x₀∥) x₀) : module.End.has_eigenvector ↑T (↑⨆ (x : {x // x ≠ 0}), (λ (x : E), T.re_apply_inner_self x / ∥x∥ ^ 2) ↑x) x₀
theorem is_of_fin_add_order.apply {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_add_order x) (i : η) : is_of_fin_add_order (x i)
theorem affine_independent.map' {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} {V₂ : Type u_5} {P₂ : Type u_6} [add_comm_group V₂] [module k V₂] [add_torsor V₂ P₂] {p : ι → P} (hai : affine_independent k p) (f : P →ᵃ[k] P₂) (hf : function.injective ⇑f) : affine_independent k (⇑f ∘ p)
theorem dot_cross_self {R : Type u_1} [comm_ring R] (v w : fin 3 → R) : matrix.dot_product w (⇑(⇑cross_product v) w) = 0
theorem add_con.lift_on_coe {M : Type u_1} [has_add M] {β : Sort u_2} (c : add_con M) (f : M → β) (h : ∀ (a b : M), ⇑c a b → f a = f b) (x : M) : add_con.lift_on ↑x f h = f x
theorem is_compact.bdd_above_image {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_closed_topology α] [nonempty α] [topological_space β] {f : β → α} {K : set β} (hK : is_compact K) (hf : continuous_on f K) : bdd_above (f '' K)
theorem strict_convex_on_exp  : strict_convex_on ℝ set.univ real.exp
theorem continuous_map.mem_compact_convergence_uniformity {α : Type u₁} {β : Type u₂} [topological_space α] [uniform_space β] (X : set (C(α, β) × C(α, β))) : X ∈ continuous_map.compact_convergence_uniformity ↔ ∃ (K : set α) (V : set (β × β)) (hK : is_compact K) (hV : V ∈ uniformity β), {fg : C(α, β) × C(α, β) | ∀ (x : α), x ∈ K → (⇑(fg.fst) x, ⇑(fg.snd) x) ∈ V} ⊆ X
theorem submodule.orthogonal_orthogonal_monotone {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K₁ K₂ : submodule 𝕜 E} (h : K₁ ≤ K₂) : K₁ᗮᗮ ≤ K₂ᗮᗮ
theorem filter.tendsto_at_top_at_top_of_monotone' {ι : Type u_1} {α : Type u_3} [preorder ι] [linear_order α] {u : ι → α} (h : monotone u) (H : ¬bdd_above (set.range u)) : filter.tendsto u filter.at_top filter.at_top
theorem card_sylow_modeq_one (p : ℕ) (G : Type u_1) [group G] [fact (nat.prime p)] [fintype (sylow p G)] : fintype.card (sylow p G) ≡ 1 [MOD p]
theorem con.mul {M : Type u_1} [has_mul M] (c : con M) {w x y z : M} : ⇑c w x → ⇑c y z → ⇑c (w * y) (x * z)
theorem affine_subspace.direction_inf_of_mem {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s₁ s₂ : affine_subspace k P} {p : P} (h₁ : p ∈ s₁) (h₂ : p ∈ s₂) : (s₁ ⊓ s₂).direction = s₁.direction ⊓ s₂.direction
theorem sub_left_lt_of_lt_add {α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a < b + c → a - b < c
theorem multiset.count_map_eq_count {α : Type u_1} {β : Type u_2} [decidable_eq α] [decidable_eq β] (f : α → β) (s : multiset α) (hf : set.inj_on f {x : α | x ∈ s}) (x : α) (H : x ∈ s) : multiset.count (f x) (multiset.map f s) = multiset.count x s
theorem category_theory.triangulated.pretriangulated.inv_rot_of_dist_triangle (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C ℤ] [category_theory.preadditive C] [∀ (n : ℤ), (category_theory.shift_functor C n).additive] [category_theory.triangulated.pretriangulated C] (T : category_theory.triangulated.triangle C) (H : T ∈ dist_triang C) : T.inv_rotate ∈ dist_triang C
theorem cont_mdiff.comp {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M → M'} {n : with_top ℕ} {E'' : Type u_14} [normed_group E''] [normed_space 𝕜 E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners 𝕜 E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {g : M' → M''} (hg : cont_mdiff I' I'' n g) (hf : cont_mdiff I I' n f) : cont_mdiff I I'' n (g ∘ f)
theorem complex.linear_equiv_det_conj_lie  : ⇑linear_equiv.det complex.conj_lie.to_linear_equiv = -1
theorem category_theory.limits.has_pullback_symmetry {C : Type u} [category_theory.category C] {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) [category_theory.limits.has_pullback f g] : category_theory.limits.has_pullback g f
theorem orientation.rotation_eq_self_iff_angle_eq_zero {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x : V} (hx : x ≠ 0) (θ : real.angle) : ⇑(o.rotation θ) x = x ↔ θ = 0
theorem padic_val_int.of_nat {p n : ℕ} : padic_val_int p ↑n = padic_val_nat p n
theorem linear_equiv.lift_dim_eq {R : Type u} [ring R] {M : Type v} [add_comm_group M] [module R M] {M' : Type v'} [add_comm_group M'] [module R M'] (f : M ≃ₗ[R] M') : (module.rank R M).lift = (module.rank R M').lift
theorem category_theory.is_filtered.bowtie {C : Type u} [category_theory.category C] [category_theory.is_filtered C] {j₁ j₂ k₁ k₂ : C} (f₁ : j₁ ⟶ k₁) (g₁ : j₁ ⟶ k₂) (f₂ : j₂ ⟶ k₁) (g₂ : j₂ ⟶ k₂) : ∃ (s : C) (α : k₁ ⟶ s) (β : k₂ ⟶ s), f₁ ≫ α = g₁ ≫ β ∧ f₂ ≫ α = g₂ ≫ β
theorem inv_le_inv {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ ≤ b⁻¹ ↔ b ≤ a
theorem category_theory.Groupoid.id_to_functor {C : category_theory.Groupoid} : 𝟭 ↥C = 𝟙 C
theorem power_series.order_mul_ge {R : Type u_1} [semiring R] (φ ψ : power_series R) : φ.order + ψ.order ≤ (φ * ψ).order
theorem is_dedekind_domain.height_one_spectrum.int_valuation_zero_le {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x : ↥(non_zero_divisors R)) : 0 < v.int_valuation_def ↑x
theorem submonoid.bot_or_exists_ne_one {M : Type u_1} [mul_one_class M] (S : submonoid M) : S = ⊥ ∨ ∃ (x : M) (H : x ∈ S), x ≠ 1
theorem exists_ne_one_of_finprod_mem_ne_one {α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M} {s : set α} (h : finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) ≠ 1) : ∃ (x : α) (H : x ∈ s), f x ≠ 1
theorem indexed_partition.proj_out {ι : Type u_1} {α : Type u_2} {s : ι → set α} (hs : indexed_partition s) (x : hs.quotient) : hs.proj (⇑(hs.out) x) = x
theorem inv.is_group_hom {α : Type u} [comm_group α] : is_group_hom has_inv.inv
theorem totally_bounded.closure {α : Type u} [uniform_space α] {s : set α} (h : totally_bounded s) : totally_bounded (closure s)
theorem tendsto_rpow_neg_div  : filter.tendsto (λ (x : ℝ), x ^ ((-1) / x)) filter.at_top (nhds 1)
theorem measure_theory.set_integral_condexp_L1 {α : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space ℝ F'] [complete_space F'] {m m0 : measurable_space α} {μ : measure_theory.measure α} {hm : m ≤ m0} [measure_theory.sigma_finite (μ.trim hm)] {f : α → F'} {s : set α} (hf : measure_theory.integrable f μ) (hs : measurable_set s) : ∫ (x : α) in s, ⇑(measure_theory.condexp_L1 hm μ f) x ∂μ = ∫ (x : α) in s, f x ∂μ
theorem bounded_continuous_function.exists_extension_forall_exists_le_ge_of_closed_embedding {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] [nonempty X] (f : bounded_continuous_function X ℝ) {e : X → Y} (he : closed_embedding e) : ∃ (g : bounded_continuous_function Y ℝ), (∀ (y : Y), ∃ (x₁ x₂ : X), ⇑g y ∈ set.Icc (⇑f x₁) (⇑f x₂)) ∧ ⇑g ∘ e = ⇑f
theorem real.Gamma_integrand_is_o (s : ℝ) : (λ (x : ℝ), real.exp (-x) * x ^ s) =o[filter.at_top] λ (x : ℝ), real.exp (-(1 / 2) * x)
theorem simple_graph.is_SRG_with.compl {V : Type u} [fintype V] [decidable_eq V] {G : simple_graph V} [decidable_rel G.adj] {n k ℓ μ : ℕ} (h : G.is_SRG_with n k ℓ μ) : Gᶜ.is_SRG_with n (n - k - 1) (n - (2 * k - μ) - 2) (n - (2 * k - ℓ))
theorem is_closed_set_of_cluster_pt {α : Type u} [topological_space α] {f : filter α} : is_closed {x : α | cluster_pt x f}
theorem has_le.le.not_lt {α : Type u} [preorder α] {a b : α} (h : a ≤ b) : ¬b < a
theorem monotone.tendsto_alternating_series_of_tendsto_zero {f : ℕ → ℝ} (hfa : monotone f) (hf0 : filter.tendsto f filter.at_top (nhds 0)) : ∃ (l : ℝ), filter.tendsto (λ (n : ℕ), (finset.range (n + 1)).sum (λ (i : ℕ), (-1) ^ i * f i)) filter.at_top (nhds l)
theorem finset.sum_insert_zero {β : Type u} {α : Type v} {s : finset α} {a : α} {f : α → β} [add_comm_monoid β] [decidable_eq α] (h : f a = 0) : (has_insert.insert a s).sum (λ (x : α), f x) = s.sum (λ (x : α), f x)
theorem is_glb.of_subset_of_superset {α : Type u} [preorder α] {a : α} {s t p : set α} (hs : is_glb s a) (hp : is_glb p a) (hst : s ⊆ t) (htp : t ⊆ p) : is_glb t a
theorem measurable_liminf {α : Type u_1} {δ : Type u_5} [topological_space α] [measurable_space α] [borel_space α] [measurable_space δ] [complete_linear_order α] [order_topology α] [topological_space.second_countable_topology α] {f : ℕ → δ → α} (hf : ∀ (i : ℕ), measurable (f i)) : measurable (λ (x : δ), filter.at_top.liminf (λ (i : ℕ), f i x))
theorem exists_strongly_measurable_limit_of_tendsto_ae {α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [topological_space β] [topological_space.pseudo_metrizable_space β] {f : ℕ → α → β} (hf : ∀ (n : ℕ), measure_theory.ae_strongly_measurable (f n) μ) (h_ae_tendsto : ∀ᵐ (x : α) ∂μ, ∃ (l : β), filter.tendsto (λ (n : ℕ), f n x) filter.at_top (nhds l)) : ∃ (f_lim : α → β) (hf_lim_meas : measure_theory.strongly_measurable f_lim), ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (nhds (f_lim x))
theorem function.is_fixed_pt.comp {α : Type u} {f g : α → α} {x : α} (hf : function.is_fixed_pt f x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt (f ∘ g) x
theorem nat.base_pow_length_digits_le (b m : ℕ) (hb : 2 ≤ b) : m ≠ 0 → b ^ (b.digits m).length ≤ b * m
theorem convex.norm_image_sub_le_of_norm_fderiv_le {E : Type u_1} [normed_group E] [normed_space ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_space 𝕜 E] [normed_group G] [normed_space 𝕜 G] {f : E → G} {C : ℝ} {s : set E} {x y : E} (hf : ∀ (x : E), x ∈ s → differentiable_at 𝕜 f x) (bound : ∀ (x : E), x ∈ s → ∥fderiv 𝕜 f x∥ ≤ C) (hs : convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∥f y - f x∥ ≤ C * ∥y - x∥
theorem is_local_extr.deriv_eq_zero {f : ℝ → ℝ} {a : ℝ} (h : is_local_extr f a) : deriv f a = 0
theorem commutative_of_cyclic_center_quotient {G : Type u_1} {H : Type u_2} [group G] [group H] [is_cyclic H] (f : G →* H) (hf : f.ker ≤ subgroup.center G) (a b : G) : a * b = b * a
theorem measure_theory.measure.measure_inter_eq_of_measure_eq {α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {s t u : set α} (hs : measurable_set s) (h : ⇑μ t = ⇑μ u) (htu : t ⊆ u) (ht_ne_top : ⇑μ t ≠ ⊤) : ⇑μ (t ∩ s) = ⇑μ (u ∩ s)
theorem metric.thickening_subset_of_subset {α : Type u} [pseudo_emetric_space α] (δ : ℝ) {E₁ E₂ : set α} (h : E₁ ⊆ E₂) : metric.thickening δ E₁ ⊆ metric.thickening δ E₂
theorem lie_module.is_nilpotent_iff_forall {R : Type u₁} {L : Type u₂} {M : Type u₄} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [is_noetherian R L] : lie_module.is_nilpotent R L M ↔ ∀ (x : L), is_nilpotent (⇑(lie_module.to_endomorphism R L M) x)
theorem precise_refinement {ι : Type u} {X : Type v} [topological_space X] [paracompact_space X] (u : ι → set X) (uo : ∀ (a : ι), is_open (u a)) (uc : (⋃ (i : ι), u i) = set.univ) : ∃ (v : ι → set X), (∀ (a : ι), is_open (v a)) ∧ (⋃ (i : ι), v i) = set.univ ∧ locally_finite v ∧ ∀ (a : ι), v a ⊆ u a
theorem measure_theory.finite_measure.tendsto_test_against_nn_filter_of_le_const {α : Type u_1} [measurable_space α] [topological_space α] [opens_measurable_space α] {ι : Type u_2} {L : filter ι} [L.is_countably_generated] {μ : measure_theory.finite_measure α} {fs : ι → bounded_continuous_function α nnreal} {c : nnreal} (fs_le_const : ∀ᶠ (i : ι) in L, ∀ᵐ (a : α) ∂↑μ, ⇑(fs i) a ≤ c) {f : bounded_continuous_function α nnreal} (fs_lim : ∀ᵐ (a : α) ∂↑μ, filter.tendsto (λ (i : ι), ⇑(fs i) a) L (nhds (⇑f a))) : filter.tendsto (λ (i : ι), μ.test_against_nn (fs i)) L (nhds (μ.test_against_nn f))
theorem bernstein_polynomial.linear_independent (n : ℕ) : linear_independent ℚ (λ (ν : fin (n + 1)), bernstein_polynomial ℚ n ↑ν)
theorem is_add_submonoid.Inter {M : Type u_1} [add_monoid M] {ι : Sort u_2} {s : ι → set M} (h : ∀ (y : ι), is_add_submonoid (s y)) : is_add_submonoid (set.Inter s)
theorem measure_theory.measure.ext_of_Ici {α : Type u_1} [topological_space α] {m : measurable_space α} [topological_space.second_countable_topology α] [linear_order α] [order_topology α] [borel_space α] (μ ν : measure_theory.measure α) [measure_theory.is_finite_measure μ] (h : ∀ (a : α), ⇑μ (set.Ici a) = ⇑ν (set.Ici a)) : μ = ν
theorem Inf_sup_le_infi_sup {α : Type u_1} [complete_lattice α] {a : α} {s : set α} : has_Inf.Inf s ⊔ a ≤ ⨅ (b : α) (H : b ∈ s), b ⊔ a
theorem one_hom.ext_iff {M : Type u_3} {N : Type u_4} [has_one M] [has_one N] {f g : one_hom M N} : f = g ↔ ∀ (x : M), ⇑f x = ⇑g x
theorem euclidean_geometry.dist_reflection {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ℝ P) [nonempty ↥s] [complete_space ↥(s.direction)] (p₁ p₂ : P) : has_dist.dist p₁ (⇑(euclidean_geometry.reflection s) p₂) = has_dist.dist (⇑(euclidean_geometry.reflection s) p₁) p₂
theorem complete_lattice.independent.comp {ι : Sort u_1} {ι' : Sort u_2} {α : Type u_3} [complete_lattice α] {s : ι → α} (hs : complete_lattice.independent s) (f : ι' → ι) (hf : function.injective f) : complete_lattice.independent (s ∘ f)
theorem concave_on.exists_le_of_mem_convex_hull {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [linear_ordered_field 𝕜] [add_comm_group E] [linear_ordered_add_comm_group β] [module 𝕜 E] [module 𝕜 β] [ordered_smul 𝕜 β] {s : set E} {f : E → β} (hf : concave_on 𝕜 (⇑(convex_hull 𝕜) s) f) {x : E} (hx : x ∈ ⇑(convex_hull 𝕜) s) : ∃ (y : E) (H : y ∈ s), f y ≤ f x
theorem cardinal.ord_card_unbounded  : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b}
theorem filter.tendsto.at_top_mul_neg_const' {α : Type u_1} {R : Type u_2} {l : filter α} {f : α → R} {r : R} [linear_ordered_ring R] [archimedean R] (hr : r < 0) (hf : filter.tendsto f l filter.at_top) : filter.tendsto (λ (x : α), f x * r) l filter.at_bot
theorem monoid_with_zero_hom.coe_inj {M : Type u_3} {N : Type u_4} [mul_zero_one_class M] [mul_zero_one_class N] ⦃f g : M →*₀ N⦄ (h : ⇑f = ⇑g) : f = g
theorem modular_group.im_lt_im_S_smul {z : upper_half_plane} (h : ⇑complex.norm_sq ↑z < 1) : z.im < (modular_group.S • z).im
theorem convex_independent.comp_embedding {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] {ι' : Type u_4} (f : ι' ↪ ι) {p : ι → E} (hc : convex_independent 𝕜 p) : convex_independent 𝕜 (p ∘ ⇑f)
theorem finset.sum_Ico_by_parts {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (f : ℕ → R) (g : ℕ → M) {m n : ℕ} (hmn : m < n) : (finset.Ico m n).sum (λ (i : ℕ), f i • g i) = f (n - 1) • (finset.range n).sum (λ (i : ℕ), g i) - f m • (finset.range m).sum (λ (i : ℕ), g i) - (finset.Ico m (n - 1)).sum (λ (i : ℕ), (f (i + 1) - f i) • (finset.range (i + 1)).sum (λ (i : ℕ), g i))
theorem geometric_hahn_banach_compact_closed {E : Type u_2} [normed_group E] [normed_space ℝ E] {s t : set E} (hs₁ : convex ℝ s) (hs₂ : is_compact s) (ht₁ : convex ℝ t) (ht₂ : is_closed t) (disj : disjoint s t) : ∃ (f : E →L[ℝ] ℝ) (u v : ℝ), (∀ (a : E), a ∈ s → ⇑f a < u) ∧ u < v ∧ ∀ (b : E), b ∈ t → v < ⇑f b
theorem right.inv_lt_one_iff {α : Type u} [group α] [has_lt α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a
theorem dense_closure {α : Type u} [topological_space α] {s : set α} : dense (closure s) ↔ dense s
theorem hom_coe_pow {M : Type u_1} {F : Type u_2} [monoid F] (c : F → M → M) (h1 : c 1 = id) (hmul : ∀ (f g : F), c (f * g) = c f ∘ c g) (f : F) (n : ℕ) : c (f ^ n) = (c f^[n])
theorem local_equiv.ext {α : Type u_1} {β : Type u_2} {e e' : local_equiv α β} (h : ∀ (x : α), ⇑e x = ⇑e' x) (hsymm : ∀ (x : β), ⇑(e.symm) x = ⇑(e'.symm) x) (hs : e.source = e'.source) : e = e'
theorem continuous_linear_map.norm_id {𝕜 : Type u_1} {E : Type u_4} [normed_group E] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [nontrivial E] : ∥continuous_linear_map.id 𝕜 E∥ = 1
theorem Top.pullback_map_open_embedding_of_open_embeddings {W X Y Z S T : Top} (f₁ : W ⟶ S) (f₂ : X ⟶ S) (g₁ : Y ⟶ T) (g₂ : Z ⟶ T) {i₁ : W ⟶ Y} {i₂ : X ⟶ Z} (H₁ : open_embedding ⇑i₁) (H₂ : open_embedding ⇑i₂) (i₃ : S ⟶ T) [H₃ : category_theory.mono i₃] (eq₁ : f₁ ≫ i₃ = i₁ ≫ g₁) (eq₂ : f₂ ≫ i₃ = i₂ ≫ g₂) : open_embedding ⇑(category_theory.limits.pullback.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂)
theorem monotone.convex_on_univ_of_deriv {f : ℝ → ℝ} (hf : differentiable ℝ f) (hf'_mono : monotone (deriv f)) : convex_on ℝ set.univ f
theorem continuous.comp_div_cases {α : Type u_1} {β : Type u_2} {G₀ : Type u_3} [group_with_zero G₀] [topological_space G₀] [has_continuous_inv₀ G₀] [has_continuous_mul G₀] [topological_space α] [topological_space β] {f g : α → G₀} (h : α → G₀ → β) (hf : continuous f) (hg : continuous g) (hh : ∀ (a : α), g a ≠ 0 → continuous_at ↿h (a, f a / g a)) (h2h : ∀ (a : α), g a = 0 → filter.tendsto ↿h ((nhds a).prod ⊤) (nhds (h a 0))) : continuous (λ (x : α), h x (f x / g x))
theorem neg_pos_of_neg {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : a < 0 → 0 < -a
theorem asymptotics.is_O_with.of_bound {α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {c : ℝ} {f : α → E} {g : α → F} {l : filter α} : (∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g x∥) → asymptotics.is_O_with c l f g
theorem zmod.legendre_sym_eq_one_iff (p : ℕ) [fact (nat.prime p)] {a : ℤ} (ha0 : ↑a ≠ 0) : zmod.legendre_sym p a = 1 ↔ is_square ↑a
theorem weak_dual.is_compact_polar (𝕜 : Type u_1) [nondiscrete_normed_field 𝕜] {E : Type u_2} [semi_normed_group E] [normed_space 𝕜 E] [proper_space 𝕜] {s : set E} (s_nhd : s ∈ nhds 0) : is_compact (weak_dual.polar 𝕜 s)
theorem continuous_iff_seq_continuous {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X → Y} [sequential_space X] : continuous f ↔ seq_continuous f
theorem eq.trans_le {α : Type u} [preorder α] {a b c : α} (hab : a = b) (hbc : b ≤ c) : a ≤ c
theorem phragmen_lindelof.quadrant_IV {E : Type u_1} [normed_group E] [normed_space ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ} (hd : diff_cont_on_cl ℂ f (set.Ioi 0 ×ℂ set.Iio 0)) (hB : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ filter.principal (set.Ioi 0 ×ℂ set.Iio 0)] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hre : ∀ (x : ℝ), 0 ≤ x → ∥f ↑x∥ ≤ C) (him : ∀ (x : ℝ), x ≤ 0 → ∥f (↑x * complex.I)∥ ≤ C) (hz_re : 0 ≤ z.re) (hz_im : z.im ≤ 0) : ∥f z∥ ≤ C
theorem orientation.rotation_neg_orientation_eq_neg {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (θ : real.angle) : (-o).rotation θ = o.rotation (-θ)
theorem submodule.coe_scott_continuous {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] : omega_complete_partial_order.continuous' coe
theorem tendsto_prod_top_iff {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {p : filter ι} {c : β} : filter.tendsto ↿F (p.prod ⊤) (nhds c) ↔ tendsto_uniformly F (λ (_x : α), c) p
theorem relation.acc_of_singleton {α : Type u_1} {r : α → α → Prop} (hi : irreflexive r) {s : multiset α} : (∀ (a : α), a ∈ s → acc (relation.cut_expand r) {a}) → acc (relation.cut_expand r) s
theorem ordinal.enum_ord_def {S : set ordinal} (o : ordinal) : ordinal.enum_ord S o = has_Inf.Inf (S ∩ {b : ordinal | ∀ (c : ordinal), c < o → ordinal.enum_ord S c < b})
theorem affine.simplex.sum_circumcenter_weights_with_circumcenter (n : ℕ) : finset.univ.sum (λ (i : affine.simplex.points_with_circumcenter_index n), affine.simplex.circumcenter_weights_with_circumcenter n i) = 1
theorem metric.frontier_cthickening_subset {α : Type u} [pseudo_emetric_space α] (E : set α) {δ : ℝ} : frontier (metric.cthickening δ E) ⊆ {x : α | emetric.inf_edist x E = ennreal.of_real δ}
theorem exists_has_deriv_at_eq_zero (f f' : ℝ → ℝ) {a b : ℝ} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hfI : f a = f b) (hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x) : ∃ (c : ℝ) (H : c ∈ set.Ioo a b), f' c = 0
theorem is_local_max.has_fderiv_at_eq_zero {E : Type u} [normed_group E] [normed_space ℝ E] {f : E → ℝ} {a : E} {f' : E →L[ℝ] ℝ} (h : is_local_max f a) (hf : has_fderiv_at f f' a) : f' = 0
theorem continuous_map.compact_conv_nhd_nhd_basis {α : Type u₁} {β : Type u₂} [topological_space α] [uniform_space β] {K : set α} {V : set (β × β)} (f : C(α, β)) (hV : V ∈ uniformity β) : ∃ (V' : set (β × β)) (H : V' ∈ uniformity β), V' ⊆ V ∧ ∀ (g : C(α, β)), g ∈ continuous_map.compact_conv_nhd K V' f → continuous_map.compact_conv_nhd K V' g ⊆ continuous_map.compact_conv_nhd K V f
theorem category_theory.grothendieck_topology.covers_iff_mem_of_closed {C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) {X : C} {S : category_theory.sieve X} (h : J₁.is_closed S) {Y : C} (f : Y ⟶ X) : J₁.covers S f ↔ ⇑S f
theorem polynomial.is_root_cyclotomic_iff_char_zero {n : ℕ} {R : Type u_1} [comm_ring R] [is_domain R] [char_zero R] {μ : R} (hn : 0 < n) : (polynomial.cyclotomic n R).is_root μ ↔ is_primitive_root μ n
theorem mv_polynomial.map_right_inverse {R : Type u} {S₁ : Type v} {σ : Type u_1} [comm_semiring R] [comm_semiring S₁] {f : R →+* S₁} {g : S₁ →+* R} (hf : function.right_inverse ⇑f ⇑g) : function.right_inverse ⇑(mv_polynomial.map f) ⇑(mv_polynomial.map g)
theorem real.sin_pi_div_three  : real.sin (real.pi / 3) = real.sqrt 3 / 2
theorem Compactum.Lim_eq_str {X : Compactum} (F : ultrafilter ↥X) : F.Lim = X.str F
theorem padic_norm.neg (p : ℕ) (q : ℚ) : padic_norm p (-q) = padic_norm p q
theorem strict_convex.preimage_add_right {𝕜 : Type u_1} {E : Type u_3} [ordered_semiring 𝕜] [topological_space E] [add_cancel_comm_monoid E] [has_continuous_add E] [module 𝕜 E] {s : set E} (hs : strict_convex 𝕜 s) (z : E) : strict_convex 𝕜 ((λ (x : E), z + x) ⁻¹' s)
theorem measure_theory.outer_measure.exists_measurable_superset_forall_eq_trim {α : Type u_1} [measurable_space α] {ι : Type u_2} [encodable ι] (μ : ι → measure_theory.outer_measure α) (s : set α) : ∃ (t : set α), s ⊆ t ∧ measurable_set t ∧ ∀ (i : ι), ⇑(μ i) t = ⇑((μ i).trim) s
theorem int.le_induction {P : ℤ → Prop} {m : ℤ} (h0 : P m) (h1 : ∀ (n : ℤ), m ≤ n → P n → P (n + 1)) (n : ℤ) : m ≤ n → P n
theorem algebra.finite_presentation.iff_quotient_mv_polynomial' {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_presentation R A ↔ ∃ (ι : Type u_2) (_x : fintype ι) (f : mv_polynomial ι R →ₐ[R] A), function.surjective ⇑f ∧ f.to_ring_hom.ker.fg
theorem zmod.pow_totient {n : ℕ} [fact (0 < n)] (x : (zmod n)ˣ) : x ^ n.totient = 1
theorem add_submonoid.mem_supr_iff_exists_dfinsupp' {ι : Type u} {γ : Type w} [dec : decidable_eq ι] [add_comm_monoid γ] (S : ι → add_submonoid γ) [Π (i : ι) (x : ↥(S i)), decidable (x ≠ 0)] (x : γ) : x ∈ supr S ↔ ∃ (f : Π₀ (i : ι), ↥(S i)), f.sum (λ (i : ι) (xi : ↥(S i)), ↑xi) = x
theorem polynomial.nat_degree_cyclotomic' {R : Type u_1} [comm_ring R] [is_domain R] {ζ : R} {n : ℕ} (h : is_primitive_root ζ n) : (polynomial.cyclotomic' n R).nat_degree = n.totient
theorem is_least.union {γ : Type w} [linear_order γ] {a b : γ} {s t : set γ} (ha : is_least s a) (hb : is_least t b) : is_least (s ∪ t) (linear_order.min a b)
theorem set.image2_distrib_subset_left {α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {γ' : Type u_6} {δ : Type u_7} {ε : Type u_9} {s : set α} {t : set β} {u : set γ} {f : α → δ → ε} {g : β → γ → δ} {f₁ : α → β → β'} {f₂ : α → γ → γ'} {g' : β' → γ' → ε} (h_distrib : ∀ (a : α) (b : β) (c : γ), f a (g b c) = g' (f₁ a b) (f₂ a c)) : set.image2 f s (set.image2 g t u) ⊆ set.image2 g' (set.image2 f₁ s t) (set.image2 f₂ s u)
theorem measure_theory.measure.add_haar_closed_ball' {E : Type u_1} [normed_group E] [measurable_space E] [normed_space ℝ E] [finite_dimensional ℝ E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (x : E) {r : ℝ} (hr : 0 ≤ r) : ⇑μ (metric.closed_ball x r) = ennreal.of_real (r ^ finite_dimensional.finrank ℝ E) * ⇑μ (metric.closed_ball 0 1)
theorem is_smul_regular.not_zero_iff {R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] : ¬is_smul_regular M 0 ↔ nontrivial M
theorem two_mul_le_add_pow_two {R : Type u_4} [linear_ordered_comm_ring R] (a b : R) : 2 * a * b ≤ a ^ 2 + b ^ 2
theorem finset.sum_sigma {β : Type u} {α : Type v} [add_comm_monoid β] {σ : α → Type u_1} (s : finset α) (t : Π (a : α), finset (σ a)) (f : sigma σ → β) : (s.sigma t).sum (λ (x : Σ (i : α), σ i), f x) = s.sum (λ (a : α), (t a).sum (λ (s : σ a), f ⟨a, s⟩))
theorem totally_disconnected_space_iff_connected_component_singleton {α : Type u} [topological_space α] : totally_disconnected_space α ↔ ∀ (x : α), connected_component x = {x}
theorem cont_diff.dense_compl_range_of_finrank_lt_finrank {E : Type u_4} {F : Type u_5} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] [normed_group F] [normed_space ℝ F] [finite_dimensional ℝ F] {f : E → F} (h : cont_diff ℝ 1 f) (hEF : finite_dimensional.finrank ℝ E < finite_dimensional.finrank ℝ F) : dense (set.range f)ᶜ
theorem same_ray.inv_norm_smul_eq {F : Type u_2} [normed_group F] [normed_space ℝ F] {x y : F} (hx : x ≠ 0) (hy : y ≠ 0) : same_ray ℝ x y → ∥x∥⁻¹ • x = ∥y∥⁻¹ • y
theorem affine_subspace.not_mem_bot (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (p : P) : p ∉ ⊥
theorem matrix.det_mul_add_one_comm {m : Type u} {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] [fintype m] [decidable_eq m] (A : matrix m n α) (B : matrix n m α) : (A.mul B + 1).det = (B.mul A + 1).det
theorem add_submonoid.localization_map.add_neg_right {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {f : M →+ N} (h : ∀ (y : ↥S), is_add_unit (⇑f ↑y)) (y : ↥S) (w z : N) : z = w + ↑-⇑(is_add_unit.lift_right (f.restrict S) h) y ↔ z + ⇑f ↑y = w
theorem submodule.inf_orthogonal_eq_bot {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) : K ⊓ Kᗮ = ⊥
theorem measure_theory.signed_measure.eq_rn_deriv {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {s : measure_theory.signed_measure α} (t : measure_theory.signed_measure α) (f : α → ℝ) (hfi : measure_theory.integrable f μ) (htμ : measure_theory.vector_measure.mutually_singular t μ.to_ennreal_vector_measure) (hadd : s = t + μ.with_densityᵥ f) : f =ᵐ[μ] s.rn_deriv μ
theorem is_add_group_hom.map_zero {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : f 0 = 0
theorem dense_range.dense_of_maps_to {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (hf' : dense_range f) (hf : continuous f) {s : set α} (hs : dense s) {t : set β} (ht : set.maps_to f s t) : dense t
theorem roth_number_nat_add_le (M N : ℕ) : ⇑roth_number_nat (M + N) ≤ ⇑roth_number_nat M + ⇑roth_number_nat N
theorem antitone.cauchy_seq_series_mul_of_tendsto_zero_of_bounded {E : Type u_4} [normed_group E] [normed_space ℝ E] {b : ℝ} {f : ℕ → ℝ} {z : ℕ → E} (hfa : antitone f) (hf0 : filter.tendsto f filter.at_top (nhds 0)) (hzb : ∀ (n : ℕ), ∥(finset.range n).sum (λ (i : ℕ), z i)∥ ≤ b) : cauchy_seq (λ (n : ℕ), (finset.range (n + 1)).sum (λ (i : ℕ), f i • z i))
theorem emetric.diam_mono {α : Type u} [pseudo_emetric_space α] {s t : set α} (h : s ⊆ t) : emetric.diam s ≤ emetric.diam t
theorem convex_on_zpow (m : ℤ) : convex_on ℝ (set.Ioi 0) (λ (x : ℝ), x ^ m)
theorem add_eq_add_iff_eq_and_eq {α : Type u_1} [add_semigroup α] [partial_order α] [covariant_class α α has_add.add has_lt.lt] [covariant_class α α (function.swap has_add.add) has_le.le] [contravariant_class α α has_add.add has_le.le] [contravariant_class α α (function.swap has_add.add) has_le.le] {a b c d : α} (hac : a ≤ c) (hbd : b ≤ d) : a + b = c + d ↔ a = c ∧ b = d
theorem metric.diam_union' {α : Type u} [pseudo_metric_space α] {s t : set α} (h : (s ∩ t).nonempty) : metric.diam (s ∪ t) ≤ metric.diam s + metric.diam t
theorem fin.prod_univ_eq_prod_range {α : Type u_1} [comm_monoid α] (f : ℕ → α) (n : ℕ) : finset.univ.prod (λ (i : fin n), f ↑i) = (finset.range n).prod (λ (i : ℕ), f i)
theorem algebra.is_algebraic_of_finite (K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite : finite_dimensional K L] : algebra.is_algebraic K L
theorem fintype.sum_pow_mul_eq_add_pow (α : Type u_1) [fintype α] {R : Type u_2} [comm_semiring R] (a b : R) : finset.univ.sum (λ (s : finset α), a ^ s.card * b ^ (fintype.card α - s.card)) = (a + b) ^ fintype.card α
theorem nat.factorization_pow (n k : ℕ) : (n ^ k).factorization = k • n.factorization
theorem free_group.reduce.exact {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.reduce L₁ = free_group.reduce L₂) : free_group.mk L₁ = free_group.mk L₂
theorem list.head_mul_tail_prod_of_ne_nil {M : Type u_3} [monoid M] [inhabited M] (l : list M) (h : l ≠ list.nil) : l.head * l.tail.prod = l.prod
theorem monotone.ne_of_lt_of_lt_nat {α : Type u} [preorder α] {f : ℕ → α} (hf : monotone f) (n : ℕ) {x : α} (h1 : f n < x) (h2 : x < f (n + 1)) (a : ℕ) : f a ≠ x
theorem mul_equiv.map_one {M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (h : M ≃* N) : ⇑h 1 = 1
theorem polynomial.cyclotomic'_zero (R : Type u_1) [comm_ring R] [is_domain R] : polynomial.cyclotomic' 0 R = 1
theorem list.nodup.cyclic_permutations {α : Type u} {l : list α} (hn : l.nodup) : l.cyclic_permutations.nodup
theorem is_primitive_root.separable_minpoly_mod {n : ℕ} {K : Type u_8} [field K] {μ : K} (h : is_primitive_root μ n) [char_zero K] {p : ℕ} [fact (nat.prime p)] (hdiv : ¬p ∣ n) : (polynomial.map (int.cast_ring_hom (zmod p)) (minpoly ℤ μ)).separable
theorem has_strict_deriv_at_exp_zero {𝕂 : Type u_1} [is_R_or_C 𝕂] : has_strict_deriv_at (exp 𝕂) 1 0
theorem interval_integral.has_fderiv_at_integral_of_dominated_loc_of_lip {𝕜 : Type u_1} [is_R_or_C 𝕜] {μ : measure_theory.measure ℝ} {E : Type u_2} [normed_group E] [normed_space ℝ E] [normed_space 𝕜 E] [complete_space E] {H : Type u_3} [normed_group H] [normed_space 𝕜 H] {a b ε : ℝ} {bound : ℝ → ℝ} {F : H → ℝ → E} {F' : ℝ → (H →L[𝕜] E)} {x₀ : H} (ε_pos : 0 < ε) (hF_meas : ∀ᶠ (x : H) in nhds x₀, measure_theory.ae_strongly_measurable (F x) (μ.restrict (set.interval_oc a b))) (hF_int : interval_integrable (F x₀) μ a b) (hF'_meas : measure_theory.ae_strongly_measurable F' (μ.restrict (set.interval_oc a b))) (h_lip : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → lipschitz_on_with (⇑real.nnabs (bound t)) (λ (x : H), F x t) (metric.ball x₀ ε)) (bound_integrable : interval_integrable bound μ a b) (h_diff : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → has_fderiv_at (λ (x : H), F x t) (F' t) x₀) : interval_integrable F' μ a b ∧ has_fderiv_at (λ (x : H), ∫ (t : ℝ) in a..b, F x t ∂μ) (∫ (t : ℝ) in a..b, F' t ∂μ) x₀
theorem ennreal.sum_lt_top_iff {α : Type u_1} {s : finset α} {f : α → ennreal} : s.sum (λ (a : α), f a) < ⊤ ↔ ∀ (a : α), a ∈ s → f a < ⊤
theorem affine_map.affine_independent_iff {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} {V₂ : Type u_5} {P₂ : Type u_6} [add_comm_group V₂] [module k V₂] [add_torsor V₂ P₂] {p : ι → P} (f : P →ᵃ[k] P₂) (hf : function.injective ⇑f) : affine_independent k (⇑f ∘ p) ↔ affine_independent k p
theorem liouville.liouville_with {x : ℝ} (hx : liouville x) (p : ℝ) : liouville_with p x
theorem matrix.pivot.exists_list_transvec_mul_diagonal_mul_list_transvec {n : Type u_1} {𝕜 : Type u_3} [field 𝕜] [decidable_eq n] [fintype n] (M : matrix n n 𝕜) : ∃ (L L' : list (matrix.transvection_struct n 𝕜)) (D : n → 𝕜), M = ((list.map matrix.transvection_struct.to_matrix L).prod.mul (matrix.diagonal D)).mul (list.map matrix.transvection_struct.to_matrix L').prod
theorem finite_dimensional.finrank_eq_dim (K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : ↑(finite_dimensional.finrank K V) = module.rank K V
theorem add_pos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
theorem setoid.comap_eq {α : Type u_1} {β : Type u_2} {f : α → β} {r : setoid β} : setoid.comap f r = setoid.ker (quotient.mk ∘ f)
theorem real.summable_pow_div_factorial (x : ℝ) : summable (λ (n : ℕ), x ^ n / ↑(n.factorial))
theorem metric.uniform_continuous_inf_nndist_pt {α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_nndist x s)
theorem submodule.torsion_torsion_eq_top {R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] : submodule.torsion R ↥(submodule.torsion R M) = ⊤
theorem finset.all_card_le_bUnion_card_iff_exists_injective {ι : Type u} {α : Type v} [decidable_eq α] (t : ι → finset α) : (∀ (s : finset ι), s.card ≤ (s.bUnion t).card) ↔ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x
theorem colex.hom_fin_le_iff {n : ℕ} (A B : finset (fin n)) : (finset.image (λ (i : fin n), ↑i) A).to_colex ≤ (finset.image (λ (i : fin n), ↑i) B).to_colex ↔ A.to_colex ≤ B.to_colex
theorem finite_field.unit_is_square_iff {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) (a : Fˣ) : is_square a ↔ a ^ (fintype.card F / 2) = 1
theorem commute.is_of_fin_order_mul {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)
theorem interval_integral.integral_has_deriv_at_of_tendsto_ae_right {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {c : E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (hb : filter.tendsto f (nhds b ⊓ measure_theory.measure_space.volume.ae) (nhds c)) : has_deriv_at (λ (u : ℝ), ∫ (x : ℝ) in a..u, f x) c b
theorem mul_opposite.op_zpow {M : Type u} [div_inv_monoid M] (x : M) (z : ℤ) : mul_opposite.op (x ^ z) = mul_opposite.op x ^ z
theorem category_theory.epi_iff_surjective {X Y : Type u} (f : X ⟶ Y) : category_theory.epi f ↔ function.surjective f
theorem iterated_fderiv_within_of_is_open {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} (n : ℕ) (hs : is_open s) : set.eq_on (iterated_fderiv_within 𝕜 n f s) (iterated_fderiv 𝕜 n f) s
theorem algebraic_geometry.PresheafedSpace.glue_data.ι_inv_app_π {C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) [category_theory.limits.has_limits C] {i : D.to_glue_data.J} (U : topological_space.opens ↥((D.to_glue_data.U i).carrier)) : ∃ (eq_1 : opposite.op U = opposite.op ((topological_space.opens.map (category_theory.limits.colimit.ι D.to_glue_data.diagram.multispan (opposite.unop (opposite.op (category_theory.limits.walking_multispan.right i)))).base).obj (_.functor.obj U))), D.ι_inv_app U ≫ D.diagram_over_open_π U i = (D.to_glue_data.U i).presheaf.map (category_theory.eq_to_hom eq_1)
theorem is_min_on.dual {α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α} : is_min_on f s a → is_max_on (⇑order_dual.to_dual ∘ f) s a
theorem first_order.language.equiv.comp_assoc {L : first_order.language} {M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] {P : Type u_1} [L.Structure P] {Q : Type u_2} [L.Structure Q] (f : L.equiv M N) (g : L.equiv N P) (h : L.equiv P Q) : (h.comp g).comp f = h.comp (g.comp f)
theorem complex.abs_deriv_le_div_of_maps_to_ball {f : ℂ → ℂ} {c : ℂ} {R₁ R₂ : ℝ} (hd : differentiable_on ℂ f (metric.ball c R₁)) (h_maps : set.maps_to f (metric.ball c R₁) (metric.ball (f c) R₂)) (h₀ : 0 < R₁) : complex.abs (deriv f c) ≤ R₂ / R₁
theorem is_cyclotomic_extension.splitting_field_X_pow_sub_one (n : ℕ+) (K : Type w) (L : Type z) [field K] [field L] [algebra K L] [ne_zero ↑↑n] [is_cyclotomic_extension {n} K L] : polynomial.is_splitting_field K L (polynomial.X ^ ↑n - 1)
theorem has_ftaylor_series_up_to.has_fderiv_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {n : with_top ℕ} {p : E → formal_multilinear_series 𝕜 E F} (h : has_ftaylor_series_up_to n f p) (hn : 1 ≤ n) (x : E) : has_fderiv_at f (⇑(continuous_multilinear_curry_fin1 𝕜 E F) (p x 1)) x
theorem nat.support_factorization {n : ℕ} : n.factorization.support = n.factors.to_finset
theorem category_theory.finrank_hom_simple_simple_le_one {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (𝕜 : Type u_3) [field 𝕜] [is_alg_closed 𝕜] [category_theory.linear 𝕜 C] [category_theory.limits.has_kernels C] (X Y : C) [finite_dimensional 𝕜 (X ⟶ X)] [category_theory.simple X] [category_theory.simple Y] : finite_dimensional.finrank 𝕜 (X ⟶ Y) ≤ 1
theorem zmod.χ₄_trichotomy (a : zmod 4) : ⇑zmod.χ₄ a = 0 ∨ ⇑zmod.χ₄ a = 1 ∨ ⇑zmod.χ₄ a = -1
theorem antisymm_of {α : Type u} (r : α → α → Prop) [is_antisymm α r] {a b : α} : r a b → r b a → a = b
theorem add_pow_two {R : Type u₁} [comm_semiring R] (a b : R) : (a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2
theorem polynomial.cyclotomic'.monic (n : ℕ) (R : Type u_1) [comm_ring R] [is_domain R] : (polynomial.cyclotomic' n R).monic
theorem submodule.span_span_of_tower (R : Type u_1) {M : Type u_4} (S : Type u_7) [semiring R] [add_comm_monoid M] [module R M] (s : set M) [semiring S] [has_scalar R S] [module S M] [is_scalar_tower R S M] : submodule.span S ↑(submodule.span R s) = submodule.span S s
theorem linear_map.is_compl_span_singleton_orthogonal {K : Type u_8} {V : Type u_11} [field K] [add_comm_group V] [module K V] {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.is_ortho x x) : is_compl (submodule.span K {x}) ((submodule.span K {x}).orthogonal_bilin B)
theorem continuous_linear_map.inverse_non_equiv {R : Type u_1} {M : Type u_2} {M₂ : Type u_3} [topological_space M] [topological_space M₂] [semiring R] [add_comm_monoid M₂] [module R M₂] [add_comm_monoid M] [module R M] (f : M →L[R] M₂) (h : ¬∃ (e' : M ≃L[R] M₂), ↑e' = f) : f.inverse = 0
theorem zmod.legendre_sym_mod (p : ℕ) [fact (nat.prime p)] (a : ℤ) : zmod.legendre_sym p a = zmod.legendre_sym p (a % ↑p)
theorem universal_enveloping_algebra.hom_ext (R : Type u₁) {L : Type u₂} [comm_ring R] [lie_ring L] [lie_algebra R L] {A : Type u₃} [ring A] [algebra R A] {g₁ g₂ : universal_enveloping_algebra R L →ₐ[R] A} (h : ↑g₁.comp (universal_enveloping_algebra.ι R) = ↑g₂.comp (universal_enveloping_algebra.ι R)) : g₁ = g₂
theorem has_strict_deriv_at.of_local_left_inverse {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {f g : 𝕜 → 𝕜} {f' a : 𝕜} (hg : continuous_at g a) (hf : has_strict_deriv_at f f' (g a)) (hf' : f' ≠ 0) (hfg : ∀ᶠ (y : 𝕜) in nhds a, f (g y) = y) : has_strict_deriv_at g f'⁻¹ a
theorem finite_dimensional.finrank_self (K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1
theorem measure_theory.measure.hausdorff_measure_zero_or_top {X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] {d₁ d₂ : ℝ} (h : d₁ < d₂) (s : set X) : ⇑(measure_theory.measure.hausdorff_measure d₂) s = 0 ∨ ⇑(measure_theory.measure.hausdorff_measure d₁) s = ⊤
theorem real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul {F : Type u_3} [inner_product_space ℝ F] {x : F} {r : ℝ} (hx : x ≠ 0) (hr : 0 < r) : has_inner.inner x (r • x) / (∥x∥ * ∥r • x∥) = 1
theorem interval_integral.integral_pos_iff_support_of_nonneg_ae' {f : ℝ → ℝ} {a b : ℝ} {μ : measure_theory.measure ℝ} (hf : 0 ≤ᵐ[μ.restrict (set.interval_oc a b)] f) (hfi : interval_integrable f μ a b) : 0 < ∫ (x : ℝ) in a..b, f x ∂μ ↔ a < b ∧ 0 < ⇑μ (function.support f ∩ set.Ioc a b)
theorem one_add_mul_sub_le_pow {R : Type u₁} [linear_ordered_ring R] {a : R} (H : -1 ≤ a) (n : ℕ) : 1 + ↑n * (a - 1) ≤ a ^ n
theorem is_add_hom.to_is_add_monoid_hom {α : Type u} {β : Type v} [add_zero_class α] [add_group β] {f : α → β} (hf : is_add_hom f) : is_add_monoid_hom f
theorem has_mem.mem.ne_of_not_mem {α : Type u_1} {β : Type u_2} [has_mem α β] {s : β} {a b : α} : a ∈ s → b ∉ s → a ≠ b
theorem antitone.ne_of_lt_of_lt_nat {α : Type u} [preorder α] {f : ℕ → α} (hf : antitone f) (n : ℕ) {x : α} (h1 : f (n + 1) < x) (h2 : x < f n) (a : ℕ) : f a ≠ x
theorem category_theory.classifier_is_sheaf {C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) : category_theory.presieve.is_sheaf J₁ (category_theory.functor.closed_sieves J₁)
theorem witt_vector.map_teichmuller (p : ℕ) {R : Type u_1} {S : Type u_2} [hp : fact (nat.prime p)] [comm_ring R] [comm_ring S] (f : R →+* S) (r : R) : ⇑(witt_vector.map f) (⇑(witt_vector.teichmuller p) r) = ⇑(witt_vector.teichmuller p) (⇑f r)
theorem category_theory.limits.fork.equalizer_ext {C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} (s : category_theory.limits.fork f g) {W : C} {k l : W ⟶ s.X} (h : k ≫ s.ι = l ≫ s.ι) (j : category_theory.limits.walking_parallel_pair) : k ≫ s.π.app j = l ≫ s.π.app j
theorem finset.sum_smul_const_vsub_eq_vsub_affine_combination {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (w : ι → k) (p₂ : ι → P) (p₁ : P) (h : s.sum (λ (i : ι), w i) = 1) : s.sum (λ (i : ι), w i • (p₁ -ᵥ p₂ i)) = p₁ -ᵥ ⇑(s.affine_combination p₂) w
theorem nat.choose_le_succ_of_lt_half_left {r n : ℕ} (h : r < n / 2) : n.choose r ≤ n.choose (r + 1)
theorem mem_affine_span_iff_eq_affine_combination (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} [nontrivial k] {p1 : P} {p : ι → P} : p1 ∈ affine_span k (set.range p) ↔ ∃ (s : finset ι) (w : ι → k) (hw : s.sum (λ (i : ι), w i) = 1), p1 = ⇑(s.affine_combination p) w
theorem cont_diff_at.continuous_linear_map_comp {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {f : E → F} {x : E} {n : with_top ℕ} (g : F →L[𝕜] G) (hf : cont_diff_at 𝕜 n f x) : cont_diff_at 𝕜 n (⇑g ∘ f) x
theorem finset.card_Ioo_finset {α : Type u_1} [decidable_eq α] {s t : finset α} (h : s ⊆ t) : (finset.Ioo s t).card = 2 ^ (t.card - s.card) - 2
theorem basis.le_span'' {R : Type u} [ring R] [rank_condition R] {M : Type v} [add_comm_group M] [module R M] {ι : Type u_1} [fintype ι] (b : basis ι R M) {w : set M} [fintype ↥w] (s : submodule.span R w = ⊤) : fintype.card ι ≤ fintype.card ↥w
theorem cont_diff.fst' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {n : with_top ℕ} {f : E → G} (hf : cont_diff 𝕜 n f) : cont_diff 𝕜 n (λ (x : E × F), f x.fst)
theorem generalized_continued_fraction.int_fract_pair.seq1_fst_eq_of {K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} : (generalized_continued_fraction.int_fract_pair.seq1 v).fst = generalized_continued_fraction.int_fract_pair.of v
theorem set.pairwise_eq_iff_exists_eq {α : Type u_1} {ι : Type u_2} [nonempty ι] (s : set α) (f : α → ι) : s.pairwise (λ (x y : α), f x = f y) ↔ ∃ (z : ι), ∀ (x : α), x ∈ s → f x = z
theorem sym2.card_image_diag {α : Type u_1} [decidable_eq α] (s : finset α) : (finset.image quotient.mk s.diag).card = s.card
theorem iterated_fderiv_within_succ_eq_comp_left {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {n : ℕ} : iterated_fderiv_within 𝕜 (n + 1) f s = ⇑(continuous_multilinear_curry_left_equiv 𝕜 (λ (i : fin (n + 1)), E) F) ∘ fderiv_within 𝕜 (iterated_fderiv_within 𝕜 n f s) s
theorem add_lt_of_lt_sub_right {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a < c - b → a + b < c
theorem finite_dimensional.eq_top_of_finrank_eq {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] {S : submodule K V} (h : finite_dimensional.finrank K ↥S = finite_dimensional.finrank K V) : S = ⊤
theorem category_theory.presieve.is_sheaf_for_top_sieve {C : Type u₁} [category_theory.category C] {X : C} (P : Cᵒᵖ ⥤ Type w) : category_theory.presieve.is_sheaf_for P ⇑⊤
theorem list.subperm.cons {α : Type uu} (a : α) {l₁ l₂ : list α} : l₁ <+~ l₂ → a :: l₁ <+~ a :: l₂
theorem le_cinfi {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), c ≤ f x) : c ≤ infi f
theorem category_theory.is_equivalence.of_iso_refl {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) (hF : category_theory.is_equivalence F) : category_theory.is_equivalence.of_iso (category_theory.iso.refl F) hF = hF
theorem measure_theory.measure.ext_of_Iic {α : Type u_1} [topological_space α] {m : measurable_space α} [topological_space.second_countable_topology α] [linear_order α] [order_topology α] [borel_space α] (μ ν : measure_theory.measure α) [measure_theory.is_finite_measure μ] (h : ∀ (a : α), ⇑μ (set.Iic a) = ⇑ν (set.Iic a)) : μ = ν
theorem fintype.induction_subsingleton_or_nontrivial {P : Π (α : Type u_1) [_inst_1 : fintype α], Prop} (α : Type u_1) [fintype α] (hbase : ∀ (α : Type u_1) [_inst_3 : fintype α] [_inst_4 : subsingleton α], P α) (hstep : ∀ (α : Type u_1) [_inst_5 : fintype α] [_inst_6 : nontrivial α], (∀ (β : Type u_1) [_inst_7 : fintype β], fintype.card β < fintype.card α → P β) → P α) : P α
theorem measure_theory.exists_measurable_superset_forall_eq {α : Type u_1} [measurable_space α] {ι : Type u_2} [encodable ι] (μ : ι → measure_theory.measure α) (s : set α) : ∃ (t : set α), s ⊆ t ∧ measurable_set t ∧ ∀ (i : ι), ⇑(μ i) t = ⇑(μ i) s
theorem free_monoid.star_one {α : Type u_1} : has_star.star 1 = 1
theorem exists_dual_vector (𝕜 : Type v) [is_R_or_C 𝕜] {E : Type u} [normed_group E] [normed_space 𝕜 E] (x : E) (h : x ≠ 0) : ∃ (g : E →L[𝕜] 𝕜), ∥g∥ = 1 ∧ ⇑g x = ↑∥x∥
theorem category_theory.is_cofiltered.eq_condition {C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] {j j' : C} (f f' : j ⟶ j') : category_theory.is_cofiltered.eq_hom f f' ≫ f = category_theory.is_cofiltered.eq_hom f f' ≫ f'
theorem liouville_with.mul_rat_iff {p x : ℝ} {r : ℚ} (hr : r ≠ 0) : liouville_with p (x * ↑r) ↔ liouville_with p x
theorem finset.affine_combination_indicator_subset {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (w : ι → k) (p : ι → P) {s₁ s₂ : finset ι} (h : s₁ ⊆ s₂) : ⇑(s₁.affine_combination p) w = ⇑(s₂.affine_combination p) (↑s₁.indicator w)
theorem ideal.ker_lift_alg_injective {R₁ : Type u_3} {A : Type u_5} {B : Type u_6} [comm_semiring R₁] [comm_ring A] [comm_ring B] [algebra R₁ A] [algebra R₁ B] (f : A →ₐ[R₁] B) : function.injective ⇑(ideal.ker_lift_alg f)
theorem first_order.language.Structure.fg_iff {L : first_order.language} {M : Type u_3} [L.Structure M] : first_order.language.Structure.fg L M ↔ ∃ (S : set M), S.finite ∧ ⇑(first_order.language.substructure.closure L) S = ⊤
theorem linear_recurrence.sol_eq_of_eq_init {α : Type u_1} [comm_semiring α] (E : linear_recurrence α) (u v : ℕ → α) (hu : E.is_solution u) (hv : E.is_solution v) : u = v ↔ set.eq_on u v ↑(finset.range E.order)
theorem real.tendsto_exp_at_top  : filter.tendsto real.exp filter.at_top filter.at_top
theorem iterated_fderiv_within_congr {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f f₁ : E → F} {x : E} {n : ℕ} (hs : unique_diff_on 𝕜 s) (hL : ∀ (y : E), y ∈ s → f₁ y = f y) (hx : x ∈ s) : iterated_fderiv_within 𝕜 n f₁ s x = iterated_fderiv_within 𝕜 n f s x
theorem upper_semicontinuous_on.add {α : Type u_1} [topological_space α] {s : set α} {γ : Type u_4} [linear_ordered_add_comm_monoid γ] [topological_space γ] [order_topology γ] [has_continuous_add γ] {f g : α → γ} (hf : upper_semicontinuous_on f s) (hg : upper_semicontinuous_on g s) : upper_semicontinuous_on (λ (z : α), f z + g z) s
theorem acc.cut_expand {α : Type u_1} {r : α → α → Prop} (hi : irreflexive r) {a : α} (hacc : acc r a) : acc (relation.cut_expand r) {a}
theorem affine_subspace.mk'_eq {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p : P} (hp : p ∈ s) : affine_subspace.mk' p s.direction = s
theorem pequiv.equiv_to_pequiv_to_matrix {n : Type u_4} {α : Type v} [decidable_eq n] [has_zero α] [has_one α] (σ : n ≃ n) (i j : n) : σ.to_pequiv.to_matrix i j = 1 (⇑σ i) j
theorem homological_complex.image_to_kernel_as_boundaries_to_cycles {ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape ι} [category_theory.limits.has_zero_object V] [category_theory.limits.has_kernels V] [category_theory.limits.has_images V] (C : homological_complex V c) (i : ι) (h : C.boundaries i ≤ C.cycles i) : (C.boundaries i).of_le (C.cycles i) h = C.boundaries_to_cycles i
theorem pi.mul_single_comm {I : Type u} [decidable_eq I] {β : Type u_1} [has_one β] (i : I) (x : β) (i' : I) : pi.mul_single i x i' = pi.mul_single i' x i
theorem inner_eq_norm_mul_iff {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x y : E} : has_inner.inner x y = ↑∥x∥ * ↑∥y∥ ↔ ↑∥y∥ • x = ↑∥x∥ • y
theorem list.chain'.append_overlap {α : Type u} {R : α → α → Prop} {l₁ l₂ l₃ : list α} (h₁ : list.chain' R (l₁ ++ l₂)) (h₂ : list.chain' R (l₂ ++ l₃)) (hn : l₂ ≠ list.nil) : list.chain' R (l₁ ++ l₂ ++ l₃)
theorem quadratic_form.equivalent_sum_squares {M : Type u_1} [add_comm_group M] [module ℂ M] [finite_dimensional ℂ M] (Q : quadratic_form ℂ M) (hQ : (⇑quadratic_form.associated Q).nondegenerate) : Q.equivalent (quadratic_form.weighted_sum_squares ℂ 1)
theorem add_submonoid.localization_map.exists_of_sec_mk' {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] (f : S.localization_map N) (x : M) (y : ↥S) : ∃ (c : ↥S), x + ↑((f.sec (f.mk' x y)).snd) + ↑c = (f.sec (f.mk' x y)).fst + ↑y + ↑c
theorem affine.simplex.point_eq_affine_combination_of_points_with_circumcenter {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P n) (i : fin (n + 1)) : s.points i = ⇑(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.point_weights_with_circumcenter i)
theorem finrank_le_one {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (v : V) (h : ∀ (w : V), ∃ (c : K), c • v = w) : finite_dimensional.finrank K V ≤ 1
theorem inducing_infi_to_pi {ι : Type u_5} {π : ι → Type u_6} {X : Type u_1} [Π (i : ι), topological_space (π i)] (f : Π (i : ι), X → π i) : inducing (λ (x : X) (i : ι), f i x)
theorem finset.prod_insert_of_eq_one_if_not_mem {β : Type u} {α : Type v} {s : finset α} {a : α} {f : α → β} [comm_monoid β] [decidable_eq α] (h : a ∉ s → f a = 1) : (has_insert.insert a s).prod (λ (x : α), f x) = s.prod (λ (x : α), f x)
theorem continuous_linear_map.isometry_iff_norm {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →SL[σ₁₂] F) : isometry ⇑f ↔ ∀ (x : E), ∥⇑f x∥ = ∥x∥
theorem phragmen_lindelof.horizontal_strip {E : Type u_1} [normed_group E] [normed_space ℂ E] {a b C : ℝ} {f : ℂ → E} {z : ℂ} (hfd : diff_cont_on_cl ℂ f (complex.im ⁻¹' set.Ioo a b)) (hB : ∃ (c : ℝ) (H : c < real.pi / (b - a)) (B : ℝ), f =O[filter.comap (has_abs.abs ∘ complex.re) filter.at_top ⊓ filter.principal (complex.im ⁻¹' set.Ioo a b)] λ (z : ℂ), real.exp (B * real.exp (c * |z.re|))) (hle_a : ∀ (z : ℂ), z.im = a → ∥f z∥ ≤ C) (hle_b : ∀ (z : ℂ), z.im = b → ∥f z∥ ≤ C) (hza : a ≤ z.im) (hzb : z.im ≤ b) : ∥f z∥ ≤ C
theorem list.dprod_monoid (ι : Type u_1) {R : Type u_2} {α : Type u_3} [add_monoid ι] [monoid R] (l : list α) (fι : α → ι) (fA : α → R) : l.dprod fι fA = (list.map fA l).prod
theorem algebra.finite_type.iff_quotient_mv_polynomial' {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_type R A ↔ ∃ (ι : Type u_2) (_x : fintype ι) (f : mv_polynomial ι R →ₐ[R] A), function.surjective ⇑f
theorem closed_embedding.is_compact_preimage {α : Type u} {β : Type v} [topological_space α] [topological_space β] {f : α → β} (hf : closed_embedding f) {K : set β} (hK : is_compact K) : is_compact (f ⁻¹' K)
theorem pullback_nonzero {M₀ : Type u_1} {M₀' : Type u_3} [mul_zero_one_class M₀] [nontrivial M₀] [has_zero M₀'] [has_one M₀'] (f : M₀' → M₀) (zero : f 0 = 0) (one : f 1 = 1) : nontrivial M₀'
theorem is_closed_map_smul_of_ne_zero {α : Type u_2} {G₀ : Type u_4} [topological_space α] [group_with_zero G₀] [mul_action G₀ α] [has_continuous_const_smul G₀ α] {c : G₀} (hc : c ≠ 0) : is_closed_map (λ (x : α), c • x)
theorem euclidean_geometry.eq_or_eq_reflection_of_dist_eq {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} {s : affine.simplex ℝ P n} {p p₁ p₂ : P} {r : ℝ} (hp₁ : p₁ ∈ affine_span ℝ (has_insert.insert p (set.range s.points))) (hp₂ : p₂ ∈ affine_span ℝ (has_insert.insert p (set.range s.points))) (h₁ : ∀ (i : fin (n + 1)), has_dist.dist (s.points i) p₁ = r) (h₂ : ∀ (i : fin (n + 1)), has_dist.dist (s.points i) p₂ = r) : p₁ = p₂ ∨ p₁ = ⇑(euclidean_geometry.reflection (affine_span ℝ (set.range s.points))) p₂
theorem is_bounded_bilinear_map_comp_multilinear {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {ι : Type u_2} {E : ι → Type u_5} [decidable_eq ι] [fintype ι] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] : is_bounded_bilinear_map 𝕜 (λ (p : (F →L[𝕜] G) × continuous_multilinear_map 𝕜 E F), p.fst.comp_continuous_multilinear_map p.snd)
theorem euclidean_geometry.cospherical_iff_exists_mem_of_finite_dimensional {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} {ps : set P} (h : ps ⊆ ↑s) [nonempty ↥s] [finite_dimensional ℝ ↥(s.direction)] : euclidean_geometry.cospherical ps ↔ ∃ (center : P) (H : center ∈ s) (radius : ℝ), ∀ (p : P), p ∈ ps → has_dist.dist p center = radius
theorem has_fderiv_at_exp {𝕂 : Type u_1} {𝔸 : Type u_2} [is_R_or_C 𝕂] [normed_comm_ring 𝔸] [normed_algebra 𝕂 𝔸] [complete_space 𝔸] {x : 𝔸} : has_fderiv_at (exp 𝕂) (exp 𝕂 x • 1) x
theorem mv_polynomial.funext {R : Type u_1} [comm_ring R] [is_domain R] [infinite R] {σ : Type u_2} {p q : mv_polynomial σ R} (h : ∀ (x : σ → R), ⇑(mv_polynomial.eval x) p = ⇑(mv_polynomial.eval x) q) : p = q
theorem filter.frequently_low_scores {β : Type u_4} [linear_order β] [no_min_order β] {u : ℕ → β} (hu : filter.tendsto u filter.at_top filter.at_bot) : ∃ᶠ (n : ℕ) in filter.at_top, ∀ (k : ℕ), k < n → u n < u k
theorem matrix.det_conj {m : Type u} {α : Type v} [comm_ring α] [fintype m] [decidable_eq m] {M : matrix m m α} (h : is_unit M) (N : matrix m m α) : ((M.mul N).mul M⁻¹).det = N.det
theorem bounded_continuous_function.exists_extension_norm_eq_of_closed_embedding' {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] (f : bounded_continuous_function X ℝ) (e : C(X, Y)) (he : closed_embedding ⇑e) : ∃ (g : bounded_continuous_function Y ℝ), ∥g∥ = ∥f∥ ∧ g.comp_continuous e = f
theorem mul_eq_mul_iff_eq_and_eq {α : Type u_1} [semigroup α] [partial_order α] [covariant_class α α has_mul.mul has_lt.lt] [covariant_class α α (function.swap has_mul.mul) has_le.le] [contravariant_class α α has_mul.mul has_le.le] [contravariant_class α α (function.swap has_mul.mul) has_le.le] {a b c d : α} (hac : a ≤ c) (hbd : b ≤ d) : a * b = c * d ↔ a = c ∧ b = d
theorem con.inf_def {M : Type u_1} [has_mul M] {c d : con M} : setoid.r = setoid.r ⊓ setoid.r
theorem cont_diff_on_succ_iff_has_fderiv_within_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {n : ℕ} : cont_diff_on 𝕜 ↑(n + 1) f s ↔ ∀ (x : E), x ∈ s → (∃ (u : set E) (H : u ∈ nhds_within x (has_insert.insert x s)) (f' : E → (E →L[𝕜] F)), (∀ (x : E), x ∈ u → has_fderiv_within_at f (f' x) u x) ∧ cont_diff_on 𝕜 ↑n f' u)
theorem category_theory.strict_initial {C : Type u} [category_theory.category C] {A : C} [category_theory.limits.has_finite_products C] [category_theory.exponentiable A] {I : C} (t : category_theory.limits.is_initial I) (f : A ⟶ I) : category_theory.is_iso f
theorem mdifferentiable_on.differentiable_on {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {f : E → E'} {s : set E} : mdifferentiable_on (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f s → differentiable_on 𝕜 f s
theorem list.split_on_p_first {α : Type u} (p : α → Prop) [decidable_pred p] (xs : list α) (h : ∀ (x : α), x ∈ xs → ¬p x) (sep : α) (hsep : p sep) (as : list α) : list.split_on_p p (xs ++ sep :: as) = xs :: list.split_on_p p as
theorem units.dvd_mul_left {α : Type u_1} [comm_monoid α] {a b : α} {u : αˣ} : a ∣ ↑u * b ↔ a ∣ b
theorem has_sbtw.sbtw.btw {α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : has_btw.btw a b c
theorem affine.simplex.circumcenter_eq_affine_combination_of_points_with_circumcenter {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P n) : s.circumcenter = ⇑(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.circumcenter_weights_with_circumcenter n)
theorem is_noetherian_span_of_finite (R : Type u_1) {M : Type u_2} [ring R] [add_comm_group M] [module R M] [is_noetherian_ring R] {A : set M} (hA : A.finite) : is_noetherian R ↥(submodule.span R A)
theorem set.Ioi_subset_Ici {α : Type u_1} [preorder α] {a b : α} (h : a ≤ b) : set.Ioi b ⊆ set.Ici a
theorem finsum_mem_zero {α : Type u_1} {M : Type u_5} [add_comm_monoid M] (s : set α) : finsum (λ (i : α), finsum (λ (H : i ∈ s), 0)) = 0
theorem has_strict_fderiv_at_exp_zero_of_radius_pos {𝕂 : Type u_1} {𝔸 : Type u_2} [nondiscrete_normed_field 𝕂] [normed_ring 𝔸] [normed_algebra 𝕂 𝔸] [complete_space 𝔸] (h : 0 < (exp_series 𝕂 𝔸).radius) : has_strict_fderiv_at (exp 𝕂) 1 0
theorem finset.prod_bij {β : Type u} {α : Type v} {γ : Type w} [comm_monoid β] {s : finset α} {t : finset γ} {f : α → β} {g : γ → β} (i : Π (a : α), a ∈ s → γ) (hi : ∀ (a : α) (ha : a ∈ s), i a ha ∈ t) (h : ∀ (a : α) (ha : a ∈ s), f a = g (i a ha)) (i_inj : ∀ (a₁ a₂ : α) (ha₁ : a₁ ∈ s) (ha₂ : a₂ ∈ s), i a₁ ha₁ = i a₂ ha₂ → a₁ = a₂) (i_surj : ∀ (b : γ), b ∈ t → (∃ (a : α) (ha : a ∈ s), b = i a ha)) : s.prod (λ (x : α), f x) = t.prod (λ (x : γ), g x)
theorem Inf_within_of_ord_connected {α : Type u_1} [conditionally_complete_linear_order α] {s : set α} [hs : s.ord_connected] ⦃t : set ↥s⦄ (ht : t.nonempty) (h_bdd : bdd_below t) : has_Inf.Inf (coe '' t) ∈ s
theorem algebraic_geometry.LocallyRingedSpace.is_unit_res_to_Γ_Spec_map_basic_open (X : algebraic_geometry.LocallyRingedSpace) (r : ↥(algebraic_geometry.LocallyRingedSpace.Γ.obj (opposite.op X))) : is_unit (⇑(X.to_to_Γ_Spec_map_basic_open r) r)
theorem add_con.ker_lift_mk {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {f : M →+ P} (x : M) : ⇑(add_con.ker_lift f) ↑x = ⇑f x
theorem matrix.pivot.reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal {n : Type u_1} {p : Type u_2} {𝕜 : Type u_3} [field 𝕜] [decidable_eq n] [decidable_eq p] [fintype n] [fintype p] (M : matrix p p 𝕜) (e : p ≃ n) (H : ∃ (L L' : list (matrix.transvection_struct n 𝕜)) (D : n → 𝕜), ((list.map matrix.transvection_struct.to_matrix L).prod.mul (⇑(matrix.reindex_alg_equiv 𝕜 e) M)).mul (list.map matrix.transvection_struct.to_matrix L').prod = matrix.diagonal D) : ∃ (L L' : list (matrix.transvection_struct p 𝕜)) (D : p → 𝕜), ((list.map matrix.transvection_struct.to_matrix L).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L').prod = matrix.diagonal D
theorem algebraic_geometry.PresheafedSpace.is_iso_of_components {C : Type u} [category_theory.category C] {X Y : algebraic_geometry.PresheafedSpace C} (f : X ⟶ Y) [category_theory.is_iso f.base] [category_theory.is_iso f.c] : category_theory.is_iso f
theorem stieltjes_function.length_subadditive_Icc_Ioo (f : stieltjes_function) {a b : ℝ} {c d : ℕ → ℝ} (ss : set.Icc a b ⊆ ⋃ (i : ℕ), set.Ioo (c i) (d i)) : ennreal.of_real (⇑f b - ⇑f a) ≤ ∑' (i : ℕ), ennreal.of_real (⇑f (d i) - ⇑f (c i))
theorem finite_field.trace_to_zmod_nondegenerate (F : Type u_1) [field F] [fintype F] {a : F} (ha : a ≠ 0) : ∃ (b : F), ⇑(algebra.trace (zmod (ring_char F)) F) (a * b) ≠ 0
theorem CHSH_inequality_of_comm {R : Type u} [ordered_comm_ring R] [star_ordered_ring R] [algebra ℝ R] [ordered_smul ℝ R] (A₀ A₁ B₀ B₁ : R) (T : is_CHSH_tuple A₀ A₁ B₀ B₁) : A₀ * B₀ + A₀ * B₁ + A₁ * B₀ - A₁ * B₁ ≤ 2
theorem is_irreducible_iff_sInter {α : Type u} [topological_space α] {s : set α} : is_irreducible s ↔ ∀ (U : finset (set α)), (∀ (u : set α), u ∈ U → is_open u) → (∀ (u : set α), u ∈ U → (s ∩ u).nonempty) → (s ∩ ⋂₀ ↑U).nonempty
theorem image_range_order_of {G : Type u} {x : G} [fintype G] [group G] [decidable_eq G] : finset.image (λ (i : ℕ), x ^ i) (finset.range (order_of x)) = ↑(subgroup.zpowers x).to_finset
theorem add_submonoid.closure_induction {M : Type u_1} [add_zero_class M] {s : set M} {p : M → Prop} {x : M} (h : x ∈ add_submonoid.closure s) (Hs : ∀ (x : M), x ∈ s → p x) (H1 : p 0) (Hmul : ∀ (x y : M), p x → p y → p (x + y)) : p x
theorem function.is_periodic_pt.eq_of_apply_eq_same {α : Type u_1} {f : α → α} {x y : α} {n : ℕ} (hx : function.is_periodic_pt f n x) (hy : function.is_periodic_pt f n y) (hn : 0 < n) (h : f x = f y) : x = y
theorem torsion_eq_torsion_submonoid (G : Type u_1) [comm_group G] : comm_monoid.torsion G = (torsion G).to_submonoid
theorem is_sup_closed_compact.is_Sup_finite_compact (α : Type u_1) [complete_lattice α] : complete_lattice.is_sup_closed_compact α → complete_lattice.is_Sup_finite_compact α
theorem finset.prod_powerset {α : Type u} {β : Type v} [comm_monoid β] (s : finset α) (f : finset α → β) : s.powerset.prod (λ (t : finset α), f t) = (finset.range (s.card + 1)).prod (λ (j : ℕ), (finset.powerset_len j s).prod (λ (t : finset α), f t))
theorem free_group.reduce.min {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red (free_group.reduce L₁) L₂) : free_group.reduce L₁ = L₂
theorem measure_theory.is_add_fundamental_domain.mk' {G : Type u_1} {α : Type u_2} [add_group G] [add_action G α] [measurable_space α] {s : set α} {μ : measure_theory.measure α} (h_meas : measure_theory.null_measurable_set s μ) (h_exists : ∀ (x : α), ∃! (g : G), g +ᵥ x ∈ s) : measure_theory.is_add_fundamental_domain G s μ
theorem continuous_map.exists_restrict_eq_of_closed {Y : Type u_2} [topological_space Y] [normal_space Y] {s : set Y} (f : C(↥s, ℝ)) (hs : is_closed s) : ∃ (g : C(Y, ℝ)), continuous_map.restrict s g = f
theorem finsupp.add_sum_erase {α : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [add_comm_monoid N] (f : α →₀ M) (y : α) (g : α → M → N) (hyf : y ∈ f.support) : g y (⇑f y) + (finsupp.erase y f).sum g = f.sum g
theorem nat.partrec.code.eval_prec_zero (cf cg : nat.partrec.code) (a : ℕ) : (cf.prec cg).eval (nat.mkpair a 0) = cf.eval a
theorem ring_hom.map_neg {α : Type u_2} {β : Type u_3} [non_assoc_ring α] [non_assoc_ring β] (f : α →+* β) (x : α) : ⇑f (-x) = -⇑f x
theorem measure_theory.pdf.real.has_pdf_iff_of_measurable {α : Type u_1} {m : measurable_space α} {ℙ : measure_theory.measure α} [measure_theory.is_finite_measure «ℙ»] {X : α → ℝ} (hX : measurable X) : measure_theory.has_pdf X «ℙ» measure_theory.measure_space.volume ↔ (measure_theory.measure.map X «ℙ»).absolutely_continuous measure_theory.measure_space.volume
theorem category_theory.has_colimit_of_created {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ⥤ C) (F : C ⥤ D) [category_theory.limits.has_colimit (K ⋙ F)] [category_theory.creates_colimit K F] : category_theory.limits.has_colimit K
theorem integral_sin_mul_cos₂ {a b : ℝ} : ∫ (x : ℝ) in a..b, real.sin x * real.cos x = (real.cos a ^ 2 - real.cos b ^ 2) / 2
theorem local_homeomorph.has_strict_deriv_at_symm {𝕜 : Type u} [nondiscrete_normed_field 𝕜] (f : local_homeomorph 𝕜 𝕜) {a f' : 𝕜} (ha : a ∈ f.to_local_equiv.target) (hf' : f' ≠ 0) (htff' : has_strict_deriv_at ⇑f f' (⇑(f.symm) a)) : has_strict_deriv_at ⇑(f.symm) f'⁻¹ a
theorem linear_equiv.continuous_symm {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] [complete_space F] [complete_space E] (e : E ≃ₗ[𝕜] F) (h : continuous ⇑e) : continuous ⇑(e.symm)
theorem norm_image_sub_le_of_norm_deriv_le_segment_01' {E : Type u_1} [normed_group E] [normed_space ℝ E] {f f' : ℝ → E} {C : ℝ} (hf : ∀ (x : ℝ), x ∈ set.Icc 0 1 → has_deriv_within_at f (f' x) (set.Icc 0 1) x) (bound : ∀ (x : ℝ), x ∈ set.Ico 0 1 → ∥f' x∥ ≤ C) : ∥f 1 - f 0∥ ≤ C
theorem quaternion_group.card {n : ℕ} [fact (0 < n)] : fintype.card (quaternion_group n) = 4 * n
theorem subset_affine_span (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s ⊆ ↑(affine_span k s)
theorem cont_diff_at.has_strict_deriv_at' {n : with_top ℕ} {𝕂 : Type u_6} [is_R_or_C 𝕂] {F' : Type u_8} [normed_group F'] [normed_space 𝕂 F'] {f : 𝕂 → F'} {f' : F'} {x : 𝕂} (hf : cont_diff_at 𝕂 n f x) (hf' : has_deriv_at f f' x) (hn : 1 ≤ n) : has_strict_deriv_at f f' x
theorem orientation.oangle_add {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle x y + o.oangle y z = o.oangle x z
theorem affine_map.coe_mk {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] (f : P1 → P2) (linear : V1 →ₗ[k] V2) (add : ∀ (p : P1) (v : V1), f (v +ᵥ p) = ⇑linear v +ᵥ f p) : ⇑{to_fun := f, linear := linear, map_vadd' := add} = f
theorem emetric.inf_edist_le_edist_of_mem {α : Type u} [pseudo_emetric_space α] {x y : α} {s : set α} (h : y ∈ s) : emetric.inf_edist x s ≤ has_edist.edist x y
theorem linear_isometry.norm_to_continuous_linear_map_comp {𝕜 : Type u_1} {𝕜₂ : Type u_2} {𝕜₃ : Type u_3} {E : Type u_4} {F : Type u_6} {G : Type u_8} [normed_group E] [normed_group F] [normed_group G] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [nondiscrete_normed_field 𝕜₃] [normed_space 𝕜 E] [normed_space 𝕜₂ F] [normed_space 𝕜₃ G] {σ₁₂ : 𝕜 →+* 𝕜₂} {σ₂₃ : 𝕜₂ →+* 𝕜₃} {σ₁₃ : 𝕜 →+* 𝕜₃} [ring_hom_comp_triple σ₁₂ σ₂₃ σ₁₃] [ring_hom_isometric σ₁₂] (f : F →ₛₗᵢ[σ₂₃] G) {g : E →SL[σ₁₂] F} : ∥f.to_continuous_linear_map.comp g∥ = ∥g∥
theorem padic_int.to_zmod_spec {p : ℕ} [hp_prime : fact (nat.prime p)] (z : ℤ_[p]) : z - ↑(⇑padic_int.to_zmod z) ∈ local_ring.maximal_ideal ℤ_[p]
theorem bilin_form.exists_bilin_form_self_ne_zero {R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] [htwo : invertible 2] {B : bilin_form R M} (hB₁ : B ≠ 0) (hB₂ : B.is_symm) : ∃ (x : M), ¬B.is_ortho x x
theorem direct_sum.is_internal.subordinate_orthonormal_basis_subordinate {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [finite_dimensional 𝕜 E] {n : ℕ} (hn : finite_dimensional.finrank 𝕜 E = n) {ι : Type u_4} [fintype ι] [decidable_eq ι] {V : ι → submodule 𝕜 E} (hV : direct_sum.is_internal V) (a : fin n) : ⇑(direct_sum.is_internal.subordinate_orthonormal_basis hn hV) a ∈ V (direct_sum.is_internal.subordinate_orthonormal_basis_index hn hV a)
theorem is_complemented_of_is_atomistic {α : Type u_1} [complete_lattice α] [is_modular_lattice α] [is_compactly_generated α] [is_atomistic α] : is_complemented α
theorem isometry.closed_embedding {α : Type u} {β : Type v} [emetric_space α] [complete_space α] [emetric_space β] {f : α → β} (hf : isometry f) : closed_embedding f
theorem category_theory.over.over_has_terminal {C : Type u} [category_theory.category C] (B : C) : category_theory.limits.has_terminal (category_theory.over B)
theorem pfun.fix_stop {α : Type u_1} {β : Type u_2} {f : α →. β ⊕ α} (a : α) {b : β} (hb : sum.inl b ∈ f a) : b ∈ f.fix a
theorem one_smul_eq_id (M : Type u_1) {α : Type u_6} [monoid M] [mul_action M α] : has_scalar.smul 1 = id
theorem category_theory.subobject.nontrivial_of_not_is_zero {C : Type u₁} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (h : ¬category_theory.limits.is_zero X) : nontrivial (category_theory.subobject X)
theorem filter.tendsto.mul_at_top {α : Type u} {β : Type v} [linear_ordered_field α] [topological_space α] [order_topology α] {l : filter β} {f g : β → α} {C : α} (hC : 0 < C) (hf : filter.tendsto f l (nhds C)) (hg : filter.tendsto g l filter.at_top) : filter.tendsto (λ (x : β), f x * g x) l filter.at_top
theorem is_locally_homeomorph.mk {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (f : X → Y) (h : ∀ (x : X), ∃ (e : local_homeomorph X Y), x ∈ e.to_local_equiv.source ∧ ∀ (x : X), x ∈ e.to_local_equiv.source → f x = ⇑e x) : is_locally_homeomorph f
theorem measure_theory.measure.mk_metric_apply {X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] (m : ennreal → ennreal) (s : set X) : ⇑(measure_theory.measure.mk_metric m) s = ⨆ (r : ennreal) (hr : 0 < r), ⨅ (t : ℕ → set X) (h : s ⊆ set.Union t) (h' : ∀ (n : ℕ), emetric.diam (t n) ≤ r), ∑' (n : ℕ), ⨆ (h : (t n).nonempty), m (emetric.diam (t n))
theorem monoid.is_torsion.torsion_eq_top {G : Type u_1} [comm_monoid G] (tG : monoid.is_torsion G) : comm_monoid.torsion G = ⊤
theorem topological_space.exists_embedding_l_infty (X : Type u_2) [topological_space X] [regular_space X] [topological_space.second_countable_topology X] : ∃ (f : X → bounded_continuous_function ℕ ℝ), embedding f
theorem category_theory.over.epi_of_epi_left {T : Type u₁} [category_theory.category T] {X : T} {f g : category_theory.over X} (k : f ⟶ g) [hk : category_theory.epi k.left] : category_theory.epi k
theorem orthonormal.oangle_smul_left_of_pos {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x y : V) {r : ℝ} (hr : 0 < r) : hb.oangle (r • x) y = hb.oangle x y
theorem int.exists_greatest_of_bdd {P : ℤ → Prop} (Hbdd : ∃ (b : ℤ), ∀ (z : ℤ), P z → z ≤ b) (Hinh : ∃ (z : ℤ), P z) : ∃ (ub : ℤ), P ub ∧ ∀ (z : ℤ), P z → z ≤ ub
theorem polynomial.cyclotomic_zero (R : Type u_1) [ring R] : polynomial.cyclotomic 0 R = 1
theorem setoid.eqv_gen_idem {α : Type u_1} (r : α → α → Prop) : eqv_gen.setoid (eqv_gen.setoid r).rel = eqv_gen.setoid r
theorem subfield.div_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x / y ∈ s
theorem law_cos {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (p1 p2 p3 : P) : has_dist.dist p1 p3 * has_dist.dist p1 p3 = has_dist.dist p1 p2 * has_dist.dist p1 p2 + has_dist.dist p3 p2 * has_dist.dist p3 p2 - 2 * has_dist.dist p1 p2 * has_dist.dist p3 p2 * real.cos (euclidean_geometry.angle p1 p2 p3)
theorem finset.subset_smul {α : Type u_2} {β : Type u_3} [decidable_eq β] [has_scalar α β] {u : finset β} {s : set α} {t : set β} : ↑u ⊆ s • t → (∃ (s' : finset α) (t' : finset β), ↑s' ⊆ s ∧ ↑t' ⊆ t ∧ u ⊆ s' • t')
theorem is_irreducible_iff_sUnion_closed {α : Type u} [topological_space α] {s : set α} : is_irreducible s ↔ ∀ (Z : finset (set α)), (∀ (z : set α), z ∈ Z → is_closed z) → s ⊆ ⋃₀↑Z → (∃ (z : set α) (H : z ∈ Z), s ⊆ z)
theorem div_eq_mul_inv {G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * b⁻¹
theorem multiset.le.subset {α : Type u_1} {s t : multiset α} : s ≤ t → s ⊆ t
theorem Liminf_eq_of_le_nhds {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {f : filter α} {a : α} [f.ne_bot] (h : f ≤ nhds a) : f.Liminf = a
theorem function.periodic.compact_of_continuous {α : Type u} [topological_space α] {f : ℝ → α} {c : ℝ} (hp : function.periodic f c) (hc : c ≠ 0) (hf : continuous f) : is_compact (set.range f)
theorem polynomial.chebyshev.T_mul (R : Type u_1) [comm_ring R] (m n : ℕ) : polynomial.chebyshev.T R (m * n) = (polynomial.chebyshev.T R m).comp (polynomial.chebyshev.T R n)
theorem category_theory.limits.has_zero_object_of_has_terminal_object {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C] : category_theory.limits.has_zero_object C
theorem tendsto_pow_neg_at_top {α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] {n : ℕ} (hn : 1 ≤ n) : filter.tendsto (λ (x : α), x ^ -↑n) filter.at_top (nhds 0)
theorem matrix.is_symm_from_blocks_iff {α : Type u_1} {n : Type u_3} {m : Type u_4} {A : matrix m m α} {B : matrix m n α} {C : matrix n m α} {D : matrix n n α} : (matrix.from_blocks A B C D).is_symm ↔ A.is_symm ∧ B.transpose = C ∧ C.transpose = B ∧ D.is_symm
theorem mv_polynomial.ring_hom_ext' {R : Type u} {σ : Type u_1} [comm_semiring R] {A : Type u_2} [semiring A] {f g : mv_polynomial σ R →+* A} (hC : f.comp mv_polynomial.C = g.comp mv_polynomial.C) (hX : ∀ (i : σ), ⇑f (mv_polynomial.X i) = ⇑g (mv_polynomial.X i)) : f = g
theorem finite_field.pow_dichotomy {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) {a : F} (ha : a ≠ 0) : a ^ (fintype.card F / 2) = 1 ∨ a ^ (fintype.card F / 2) = -1
theorem linear_independent_of_ne_zero_of_inner_eq_zero {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_3} {v : ι → E} (hz : ∀ (i : ι), v i ≠ 0) (ho : ∀ (i j : ι), i ≠ j → has_inner.inner (v i) (v j) = 0) : linear_independent 𝕜 v
theorem not_is_left_regular_zero {R : Type u_1} [mul_zero_class R] [nR : nontrivial R] : ¬is_left_regular 0
theorem Top.presheaf.is_sheaf_iff_is_sheaf_comp {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (G : C ⥤ D) [category_theory.reflects_isomorphisms G] [category_theory.limits.has_limits C] [category_theory.limits.has_limits D] [category_theory.limits.preserves_limits G] {X : Top} (F : Top.presheaf C X) : F.is_sheaf ↔ Top.presheaf.is_sheaf (F ⋙ G)
theorem asymptotics.is_o.bound {α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : α → E} {g : α → F} {l : filter α} : f =o[l] g → ∀ ⦃c : ℝ⦄, 0 < c → (∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g x∥)
theorem is_principal_ideal_ring.of_surjective {R : Type u} {S : Type u_1} [ring R] [ring S] [is_principal_ideal_ring R] (f : R →+* S) (hf : function.surjective ⇑f) : is_principal_ideal_ring S
theorem category_theory.is_iso_of_epi_of_split_mono {C : Type u₁} [category_theory.category C] {X Y : C} (f : X ⟶ Y) [category_theory.split_mono f] [category_theory.epi f] : category_theory.is_iso f
theorem convex_on.map_average_le {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {f : α → E} {g : E → ℝ} [measure_theory.is_finite_measure μ] (hg : convex_on ℝ s g) (hgc : continuous_on g s) (hsc : is_closed s) (hμ : μ ≠ 0) (hfs : ∀ᵐ (x : α) ∂μ, f x ∈ s) (hfi : measure_theory.integrable f μ) (hgi : measure_theory.integrable (g ∘ f) μ) : g (⨍ (x : α), f x ∂μ) ≤ ⨍ (x : α), g (f x) ∂μ
theorem equiv.mul_right_symm_apply {G : Type u_10} [group G] (a : G) : ⇑(equiv.symm (equiv.mul_right a)) = λ (x : G), x * a⁻¹
theorem normal_space_of_regular_second_countable (α : Type u) [topological_space α] [topological_space.second_countable_topology α] [regular_space α] : normal_space α
theorem metric.Hausdorff_dist_le_of_mem_dist {α : Type u} [pseudo_metric_space α] {s t : set α} {r : ℝ} (hr : 0 ≤ r) (H1 : ∀ (x : α), x ∈ s → (∃ (y : α) (H : y ∈ t), has_dist.dist x y ≤ r)) (H2 : ∀ (x : α), x ∈ t → (∃ (y : α) (H : y ∈ s), has_dist.dist x y ≤ r)) : metric.Hausdorff_dist s t ≤ r
theorem euclidean_geometry.orthocentric_system.exists_circumradius_eq {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : set P} (ho : euclidean_geometry.orthocentric_system s) : ∃ (r : ℝ), ∀ (t : affine.triangle ℝ P), set.range t.points ⊆ s → affine.simplex.circumradius t = r
theorem mem_nhds_within_Iic_iff_exists_Ioc_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_min_order α] {a : α} {s : set α} : s ∈ nhds_within a (set.Iic a) ↔ ∃ (l : α) (H : l ∈ set.Iio a), set.Ioc l a ⊆ s
theorem lie_ideal.subsingleton_of_bot {R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : subsingleton (lie_ideal R ↥⊥)
theorem first_order.language.substructure.closure_le {L : first_order.language} {M : Type w} [L.Structure M] {S : L.substructure M} {s : set M} : ⇑(first_order.language.substructure.closure L) s ≤ S ↔ s ⊆ ↑S
theorem subgroup.multiset_prod_mem {G : Type u_1} [comm_group G] (K : subgroup G) (g : multiset G) : (∀ (a : G), a ∈ g → a ∈ K) → g.prod ∈ K
theorem add_monoid.not_is_torsion_iff (G : Type u_1) [add_monoid G] : ¬add_monoid.is_torsion G ↔ ∃ (g : G), ¬is_of_fin_add_order g
theorem fin.monotone_iff_le_succ {n : ℕ} {α : Type u_1} [preorder α] {f : fin (n + 1) → α} : monotone f ↔ ∀ (i : fin n), f (⇑fin.cast_succ i) ≤ f i.succ
theorem add_monoid_algebra.of'_mem_span {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_monoid M] [nontrivial R] {m : M} {S : set M} : add_monoid_algebra.of' R M m ∈ submodule.span R (add_monoid_algebra.of' R M '' S) ↔ m ∈ S
theorem finset.weighted_vsub_eq_linear_combination {k : Type u_1} {V : Type u_2} [ring k] [add_comm_group V] [module k V] {ι : Type u_3} (s : finset ι) {w : ι → k} {p : ι → V} (hw : s.sum w = 0) : ⇑(s.weighted_vsub p) w = s.sum (λ (i : ι), w i • p i)
theorem mem_affine_span_iff_eq_weighted_vsub_of_point_vadd (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} [nontrivial k] (p : ι → P) (j : ι) (q : P) : q ∈ affine_span k (set.range p) ↔ ∃ (s : finset ι) (w : ι → k), q = ⇑(s.weighted_vsub_of_point p (p j)) w +ᵥ p j
theorem is_clopen.bUnion_connected_component_eq {α : Type u} [topological_space α] {Z : set α} (h : is_clopen Z) : (⋃ (x : α) (H : x ∈ Z), connected_component x) = Z
theorem quadratic_eq_zero_iff_of_discrim_eq_zero {K : Type u_1} [field K] [invertible 2] {a b c : K} (ha : a ≠ 0) (h : discrim a b c = 0) (x : K) : a * x * x + b * x + c = 0 ↔ x = -b / (2 * a)
theorem norm_mk_lt' {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) {ε : ℝ} (hε : 0 < ε) : ∃ (s : M) (H : s ∈ S), ∥m + s∥ < ∥⇑(quotient_add_group.mk' S) m∥ + ε
theorem complex.norm_deriv_le_of_forall_mem_sphere_norm_le {F : Type v} [normed_group F] [normed_space ℂ F] {c : ℂ} {R C : ℝ} {f : ℂ → F} (hR : 0 < R) (hd : diff_cont_on_cl ℂ f (metric.ball c R)) (hC : ∀ (z : ℂ), z ∈ metric.sphere c R → ∥f z∥ ≤ C) : ∥deriv f c∥ ≤ C / R
theorem affine.simplex.dist_circumcenter_eq_circumradius' {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P n) (i : fin (n + 1)) : has_dist.dist s.circumcenter (s.points i) = s.circumradius
theorem vadd_vsub_assoc {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (g : G) (p1 p2 : P) : g +ᵥ p1 -ᵥ p2 = g + (p1 -ᵥ p2)
theorem formal_multilinear_series.comp_right_inv {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) (i : E ≃L[𝕜] F) (h : p 1 = ⇑((continuous_multilinear_curry_fin1 𝕜 E F).symm) ↑i) (h0 : p 0 = 0) : p.comp (p.right_inv i) = formal_multilinear_series.id 𝕜 F
theorem complex.linear_equiv_det_conj_ae  : ⇑linear_equiv.det complex.conj_ae.to_linear_equiv = -1
theorem padic_val_nat.pow (p q n : ℕ) [fact (nat.prime p)] (hq : q ≠ 0) : padic_val_nat p (q ^ n) = n * padic_val_nat p q
theorem is_primitive_root.sub_one_norm_two {K : Type u} {L : Type v} [field L] {ζ : L} [field K] [algebra K L] [ne_zero 2] {k : ℕ} (hζ : is_primitive_root ζ (2 ^ k)) (hk : 2 ≤ k) [H : is_cyclotomic_extension {2 ^ k} K L] (hirr : irreducible (polynomial.cyclotomic (2 ^ k) K)) : ⇑(algebra.norm K) (ζ - 1) = 2
theorem module.End.has_generalized_eigenvalue_of_has_generalized_eigenvalue_of_le {R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {μ : R} {k m : ℕ} (hm : k ≤ m) (hk : f.has_generalized_eigenvalue μ k) : f.has_generalized_eigenvalue μ m
theorem matrix.mul_inv_of_self_assoc {m : Type u} {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) (B : matrix n m α) [invertible A] : A.mul ((⅟ A).mul B) = B
theorem tangent_map_chart_symm {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {p : tangent_bundle I M} {q : tangent_bundle I H} (h : q.fst ∈ (charted_space.chart_at H p.fst).to_local_equiv.target) : tangent_map I I ⇑((charted_space.chart_at H p.fst).symm) q = ⇑((charted_space.chart_at (model_prod H E) p).symm) (⇑(equiv.sigma_equiv_prod H E) q)
theorem lattice_ordered_comm_group.pos_of_one_le {α : Type u} [lattice α] [comm_group α] (a : α) (h : 1 ≤ a) : a⁺ = a
theorem generalized_continued_fraction.of_correctness_at_top_of_terminates {K : Type u_1} [linear_ordered_field K] {v : K} [floor_ring K] (terminates : (generalized_continued_fraction.of v).terminates) : ∀ᶠ (n : ℕ) in filter.at_top, v = (generalized_continued_fraction.of v).convergents n
theorem equiv.mul_left_symm_apply {G : Type u_10} [group G] (a : G) : ⇑(equiv.symm (equiv.mul_left a)) = has_mul.mul a⁻¹
theorem multiset_prod_mem {B : Type u_3} {S : B} {M : Type u_1} [comm_monoid M] [set_like B M] [submonoid_class B M] (m : multiset M) (hm : ∀ (a : M), a ∈ m → a ∈ S) : m.prod ∈ S
theorem linear_ordered_comm_group_with_zero.has_basis_nhds_zero {Γ₀ : Type u_1} [linear_ordered_comm_group_with_zero Γ₀] : (nhds 0).has_basis (λ (_x : Γ₀ˣ), true) (λ (γ₀ : Γ₀ˣ), {γ : Γ₀ | γ < ↑γ₀})
theorem complex.has_strict_deriv_at_sinh (x : ℂ) : has_strict_deriv_at complex.sinh (complex.cosh x) x
theorem linear_map.comp_eq_id_comm {K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {f g : V →ₗ[K] V} : f.comp g = linear_map.id ↔ g.comp f = linear_map.id
theorem polynomial.cyclotomic_eq_prod_X_pow_sub_one_pow_moebius {n : ℕ} (R : Type u_1) [comm_ring R] [is_domain R] : ⇑(algebra_map (polynomial R) (ratfunc R)) (polynomial.cyclotomic n R) = n.divisors_antidiagonal.prod (λ (i : ℕ × ℕ), ⇑(algebra_map (polynomial R) (ratfunc R)) (polynomial.X ^ i.snd - 1) ^ ⇑nat.arithmetic_function.moebius i.fst)
theorem category_theory.is_iso_of_epi_of_strong_mono {C : Type u} [category_theory.category C] {P Q : C} (f : P ⟶ Q) [category_theory.epi f] [category_theory.strong_mono f] : category_theory.is_iso f
theorem order.ideal.sup_mem {P : Type u_1} [semilattice_sup P] {x y : P} {s : order.ideal P} (hx : x ∈ s) (hy : y ∈ s) : x ⊔ y ∈ s
theorem colex.lt_singleton_iff_mem_lt {α : Type u_1} [linear_order α] {r : α} {s : finset α} : s.to_colex < {r}.to_colex ↔ ∀ (x : α), x ∈ s → x < r
theorem measure_theory.continuous_integral_integral {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] : continuous (λ (f : ↥(measure_theory.Lp E 1 (μ.prod ν))), ∫ (x : α), ∫ (y : β), ⇑f (x, y) ∂ν ∂μ)
theorem local_equiv.is_image.of_preimage_eq {α : Type u_1} {β : Type u_2} {e : local_equiv α β} {s : set α} {t : set β} : e.source ∩ ⇑e ⁻¹' t = e.source ∩ s → e.is_image s t
theorem metric.Hausdorff_dist_comm {α : Type u} [pseudo_metric_space α] {s t : set α} : metric.Hausdorff_dist s t = metric.Hausdorff_dist t s
theorem category_theory.sheaf.is_sheaf_yoneda_obj {C : Type u} [category_theory.category C] (X : C) : category_theory.presieve.is_sheaf (category_theory.sheaf.canonical_topology C) (category_theory.yoneda.obj X)
theorem add_monoid_hom.map_add_neg {α : Type u_1} {β : Type u_2} [add_group α] [subtraction_monoid β] (f : α →+ β) (g h : α) : ⇑f (g + -h) = ⇑f g + -⇑f h
theorem measure_theory.mem_Lp_meas_subgroup_to_Lp_of_trim {α : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space α} {μ : measure_theory.measure α} (hm : m ≤ m0) (f : ↥(measure_theory.Lp F p (μ.trim hm))) : measure_theory.mem_ℒp.to_Lp ⇑f _ ∈ measure_theory.Lp_meas_subgroup F m p μ
theorem is_free_groupoid.spanning_tree.loop_of_hom_eq_id {G : Type u} [category_theory.groupoid G] [is_free_groupoid G] (T : wide_subquiver (quiver.symmetrify (is_free_groupoid.generators G))) [quiver.arborescence ↥T] {a b : is_free_groupoid.generators G} (e : a ⟶ b) (H : e ∈ quiver.wide_subquiver_symmetrify T a b) : is_free_groupoid.spanning_tree.loop_of_hom T (is_free_groupoid.of e) = 𝟙 (root' T)
theorem lipschitz_on_with.extend_pi {α : Type u} {ι : Type x} [pseudo_metric_space α] [fintype ι] {f : α → ι → ℝ} {s : set α} {K : nnreal} (hf : lipschitz_on_with K f s) : ∃ (g : α → ι → ℝ), lipschitz_with K g ∧ set.eq_on f g s
theorem tsum_sq_fourier_series_repr (f : ↥(measure_theory.Lp ℂ 2 haar_circle)) : ∑' (i : ℤ), ∥⇑(⇑(fourier_series.repr) f) i∥ ^ 2 = ∫ (t : ↥circle), ∥⇑f t∥ ^ 2 ∂haar_circle
theorem con.mul_ker_mk_eq {M : Type u_1} [has_mul M] (c : con M) : con.mul_ker coe _ = c
theorem continuous_map.tendsto_of_tendsto_locally_uniformly {α : Type u₁} {β : Type u₂} [topological_space α] [uniform_space β] {f : C(α, β)} {ι : Type u₃} {p : filter ι} {F : ι → C(α, β)} (h : tendsto_locally_uniformly (λ (i : ι) (a : α), ⇑(F i) a) ⇑f p) : filter.tendsto F p (nhds f)
theorem normed_ring.inverse_add_norm {R : Type u_1} [normed_ring R] [complete_space R] (x : Rˣ) : (λ (t : R), ring.inverse (↑x + t)) =O[nhds 0] λ (t : R), 1
theorem same_ray_pos_smul_left {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (v : M) {r : R} (h : 0 < r) : same_ray R (r • v) v
theorem category_theory.prod_id (C : Type u₁) [category_theory.category C] (D : Type u₂) [category_theory.category D] (X : C) (Y : D) : 𝟙 (X, Y) = (𝟙 X, 𝟙 Y)
theorem finsupp.sum_inner {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_3} (l : ι →₀ 𝕜) (v : ι → E) (x : E) : has_inner.inner (l.sum (λ (i : ι) (a : 𝕜), a • v i)) x = l.sum (λ (i : ι) (a : 𝕜), ⇑(star_ring_end 𝕜) a • has_inner.inner (v i) x)
theorem zmod.ring_char_zmod_n (n : ℕ) : ring_char (zmod n) = n
theorem real.map_matrix_volume_pi_eq_smul_volume_pi {ι : Type u_1} [fintype ι] [decidable_eq ι] {M : matrix ι ι ℝ} (hM : M.det ≠ 0) : measure_theory.measure.map ⇑(⇑matrix.to_lin' M) measure_theory.measure_space.volume = ennreal.of_real |(M.det)⁻¹| • measure_theory.measure_space.volume
theorem measure_theory.is_fundamental_domain.smul_invariant_measure_map {G : Type u_1} [group G] [measurable_space G] [topological_space G] [topological_group G] [borel_space G] {μ : measure_theory.measure G} {Γ : subgroup G} {𝓕 : set G} (h𝓕 : measure_theory.is_fundamental_domain ↥(Γ.opposite) 𝓕 μ) [encodable ↥Γ] [measurable_space (G ⧸ Γ)] [borel_space (G ⧸ Γ)] [μ.is_mul_left_invariant] [μ.is_mul_right_invariant] : measure_theory.smul_invariant_measure G (G ⧸ Γ) (measure_theory.measure.map quotient_group.mk (μ.restrict 𝓕))
theorem is_preconnected.mem_intervals {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {s : set α} (hs : is_preconnected s) : s ∈ {set.Icc (has_Inf.Inf s) (has_Sup.Sup s), set.Ico (has_Inf.Inf s) (has_Sup.Sup s), set.Ioc (has_Inf.Inf s) (has_Sup.Sup s), set.Ioo (has_Inf.Inf s) (has_Sup.Sup s), set.Ici (has_Inf.Inf s), set.Ioi (has_Inf.Inf s), set.Iic (has_Sup.Sup s), set.Iio (has_Sup.Sup s), set.univ, ∅}
theorem ennreal.to_nnreal_sum {α : Type u_1} {s : finset α} {f : α → ennreal} (hf : ∀ (a : α), a ∈ s → f a ≠ ⊤) : (s.sum (λ (a : α), f a)).to_nnreal = s.sum (λ (a : α), (f a).to_nnreal)
theorem eventually_residual {α : Type u_1} [topological_space α] [baire_space α] {p : α → Prop} : (∀ᶠ (x : α) in residual α, p x) ↔ ∃ (t : set α), is_Gδ t ∧ dense t ∧ ∀ (x : α), x ∈ t → p x
theorem category_theory.simplicial_object.δ_comp_δ {C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) {n : ℕ} {i j : fin (n + 2)} (H : i ≤ j) : X.δ j.succ ≫ X.δ i = X.δ (⇑fin.cast_succ i) ≫ X.δ j
theorem finset.centroid_eq_of_inj_on_of_image_eq (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} (s : finset ι) {ι₂ : Type u_5} (s₂ : finset ι₂) {p : ι → P} (hi : ∀ (i : ι), i ∈ s → ∀ (j : ι), j ∈ s → p i = p j → i = j) {p₂ : ι₂ → P} (hi₂ : ∀ (i : ι₂), i ∈ s₂ → ∀ (j : ι₂), j ∈ s₂ → p₂ i = p₂ j → i = j) (he : p '' ↑s = p₂ '' ↑s₂) : finset.centroid k s p = finset.centroid k s₂ p₂
theorem cont_mdiff_on.comp' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M → M'} {s : set M} {n : with_top ℕ} {E'' : Type u_14} [normed_group E''] [normed_space 𝕜 E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners 𝕜 E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {t : set M'} {g : M' → M''} (hg : cont_mdiff_on I' I'' n g t) (hf : cont_mdiff_on I I' n f s) : cont_mdiff_on I I'' n (g ∘ f) (s ∩ f ⁻¹' t)
theorem subgroup.normal_mul {G : Type u_1} [group G] (N H : subgroup G) [N.normal] : ↑(N ⊔ H) = ↑N * ↑H
theorem pi.mul_single_apply {I : Type u} [decidable_eq I] {β : Type u_1} [has_one β] (i : I) (x : β) (i' : I) : pi.mul_single i x i' = ite (i' = i) x 1
theorem tendsto_of_no_upcrossings {α : Type u} {β : Type v} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {f : filter β} {u : β → α} {s : set α} (hs : dense s) (H : ∀ (a : α), a ∈ s → ∀ (b : α), b ∈ s → a < b → ¬((∃ᶠ (n : β) in f, u n < a) ∧ ∃ᶠ (n : β) in f, b < u n)) (h : filter.is_bounded_under has_le.le f u . "is_bounded_default") (h' : filter.is_bounded_under ge f u . "is_bounded_default") : ∃ (c : α), filter.tendsto u f (nhds c)
theorem is_noetherian.disjoint_partial_sups_eventually_bot {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [I : is_noetherian R M] (f : ℕ → submodule R M) (h : ∀ (n : ℕ), disjoint (⇑(partial_sups f) n) (f (n + 1))) : ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → f m = ⊥
theorem strict_anti_on.dual_right {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s : set α} : strict_anti_on f s → strict_mono_on (⇑order_dual.to_dual ∘ f) s
theorem subring.sum_mem {R : Type u_1} [ring R] (s : subring R) {ι : Type u_2} {t : finset ι} {f : ι → R} (h : ∀ (c : ι), c ∈ t → f c ∈ s) : t.sum (λ (i : ι), f i) ∈ s
theorem embedding.comp_strongly_measurable_iff {α : Type u_1} {β : Type u_2} {γ : Type u_3} {m : measurable_space α} [topological_space β] [topological_space.pseudo_metrizable_space β] [topological_space γ] [topological_space.pseudo_metrizable_space γ] {g : β → γ} {f : α → β} (hg : embedding g) : measure_theory.strongly_measurable (λ (x : α), g (f x)) ↔ measure_theory.strongly_measurable f
theorem algebra.norm_algebra_map {K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] (x : K) : ⇑(algebra.norm K) (⇑(algebra_map K L) x) = x ^ finite_dimensional.finrank K L
theorem fin.cast_eq_cast' {n m : ℕ} (h : fin n = fin m) : cast h = ⇑(fin.cast _)
theorem im_inner_eq_norm_sub_I_smul_mul_self_sub_norm_add_I_smul_mul_self_div_four {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) : ⇑is_R_or_C.im (has_inner.inner x y) = (∥x - is_R_or_C.I • y∥ * ∥x - is_R_or_C.I • y∥ - ∥x + is_R_or_C.I • y∥ * ∥x + is_R_or_C.I • y∥) / 4
theorem nat.div_lt_self' (n b : ℕ) : (n + 1) / (b + 2) < n + 1
theorem preimage_connected_component_connected {α : Type u} {β : Type v} [topological_space α] [topological_space β] {f : α → β} (connected_fibers : ∀ (t : β), is_connected (f ⁻¹' {t})) (hcl : ∀ (T : set β), is_closed T ↔ is_closed (f ⁻¹' T)) (t : β) : is_connected (f ⁻¹' connected_component t)
theorem centroid_mem_affine_span_of_card_ne_zero (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} [char_zero k] {s : finset ι} (p : ι → P) (h : s.card ≠ 0) : finset.centroid k s p ∈ affine_span k (set.range p)
theorem submodule.span_coe_eq_restrict_scalars {R : Type u_1} {M : Type u_4} {S : Type u_7} [semiring R] [add_comm_monoid M] [module R M] (p : submodule R M) [semiring S] [has_scalar S R] [module S M] [is_scalar_tower S R M] : submodule.span S ↑p = submodule.restrict_scalars S p
theorem module.End.has_eigenvalue_of_has_generalized_eigenvalue {R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {μ : R} {k : ℕ} (hμ : f.has_generalized_eigenvalue μ k) : f.has_eigenvalue μ
theorem volume_region_between_eq_integral {α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {f g : α → ℝ} {s : set α} [measure_theory.sigma_finite μ] (f_int : measure_theory.integrable_on f s μ) (g_int : measure_theory.integrable_on g s μ) (hs : measurable_set s) (hfg : ∀ (x : α), x ∈ s → f x ≤ g x) : ⇑(μ.prod measure_theory.measure_space.volume) (region_between f g s) = ennreal.of_real (∫ (y : α) in s, (g - f) y ∂μ)
theorem intermediate_field.list_sum_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {l : list L} : (∀ (x : L), x ∈ l → x ∈ S) → l.sum ∈ S
theorem inner_product_geometry.angle_neg_neg {V : Type u_1} [inner_product_space ℝ V] (x y : V) : inner_product_geometry.angle (-x) (-y) = inner_product_geometry.angle x y
theorem category_theory.presieve.is_separated_for_and_exists_is_amalgamation_iff_sheaf_for {C : Type u₁} [category_theory.category C] {P : Cᵒᵖ ⥤ Type w} {X : C} {R : category_theory.presieve X} : (category_theory.presieve.is_separated_for P R ∧ ∀ (x : category_theory.presieve.family_of_elements P R), x.compatible → (∃ (t : P.obj (opposite.op X)), x.is_amalgamation t)) ↔ category_theory.presieve.is_sheaf_for P R
theorem finset.filter_eq {β : Type u_2} [decidable_eq β] (s : finset β) (b : β) : finset.filter (eq b) s = ite (b ∈ s) {b} ∅
theorem add_group_filter_basis.uniform_add_group {G : Type u_1} [add_comm_group G] (B : add_group_filter_basis G) : uniform_add_group G
theorem interval_integral.integral_lt_integral_of_continuous_on_of_le_of_exists_lt {f g : ℝ → ℝ} {a b : ℝ} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hgc : continuous_on g (set.Icc a b)) (hle : ∀ (x : ℝ), x ∈ set.Ioc a b → f x ≤ g x) (hlt : ∃ (c : ℝ) (H : c ∈ set.Icc a b), f c < g c) : ∫ (x : ℝ) in a..b, f x < ∫ (x : ℝ) in a..b, g x
theorem con.lift_funext {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} (f g : c.quotient →* P) (h : ∀ (a : M), ⇑f ↑a = ⇑g ↑a) : f = g
theorem box_integral.box.subbox_induction_on {ι : Type u_1} [fintype ι] {p : box_integral.box ι → Prop} (I : box_integral.box ι) (H_ind : ∀ (J : box_integral.box ι), J ≤ I → (∀ (J' : box_integral.box ι), J' ∈ box_integral.prepartition.split_center J → p J') → p J) (H_nhds : ∀ (z : ι → ℝ), z ∈ ⇑box_integral.box.Icc I → (∃ (U : set (ι → ℝ)) (H : U ∈ nhds_within z (⇑box_integral.box.Icc I)), ∀ (J : box_integral.box ι), J ≤ I → ∀ (m : ℕ), z ∈ ⇑box_integral.box.Icc J → ⇑box_integral.box.Icc J ⊆ U → (∀ (i : ι), J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) → p J)) : p I
theorem euclidean_geometry.inter_eq_singleton_orthogonal_projection {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} [nonempty ↥s] [complete_space ↥(s.direction)] (p : P) : ↑s ∩ ↑(affine_subspace.mk' p (s.direction)ᗮ) = {↑(⇑(euclidean_geometry.orthogonal_projection s) p)}
theorem antilipschitz_with.subsingleton {α : Type u_1} {β : Type u_2} [emetric_space α] [pseudo_emetric_space β] {f : α → β} (h : antilipschitz_with 0 f) : subsingleton α
theorem is_artinian.exists_endomorphism_iterate_ker_sup_range_eq_top {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [I : is_artinian R M] (f : M →ₗ[R] M) : ∃ (n : ℕ), n ≠ 0 ∧ (f ^ n).ker ⊔ (f ^ n).range = ⊤
theorem mul_is_right_regular_iff {R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_right_regular a) : is_right_regular (b * a) ↔ is_right_regular b
theorem lebesgue_number_lemma {α : Type u} [uniform_space α] {s : set α} {ι : Sort u_1} {c : ι → set α} (hs : is_compact s) (hc₁ : ∀ (i : ι), is_open (c i)) (hc₂ : s ⊆ ⋃ (i : ι), c i) : ∃ (n : set (α × α)) (H : n ∈ uniformity α), ∀ (x : α), x ∈ s → (∃ (i : ι), {y : α | (x, y) ∈ n} ⊆ c i)
theorem orthonormal.oangle_eq_iff_eq_pos_smul_rotation_or_eq_zero {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y : V} (θ : real.angle) : hb.oangle x y = θ ↔ (x ≠ 0 ∧ y ≠ 0 ∧ ∃ (r : ℝ), 0 < r ∧ y = r • ⇑(hb.rotation θ) x) ∨ θ = 0 ∧ (x = 0 ∨ y = 0)
theorem interval_integral.has_sum_integral_of_dominated_convergence {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {a b : ℝ} {f : ℝ → E} {μ : measure_theory.measure ℝ} {ι : Type u_1} [encodable ι] {F : ι → ℝ → E} (bound : ι → ℝ → ℝ) (hF_meas : ∀ (n : ι), measure_theory.ae_strongly_measurable (F n) (μ.restrict (set.interval_oc a b))) (h_bound : ∀ (n : ι), ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → ∥F n t∥ ≤ bound n t) (bound_summable : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → summable (λ (n : ι), bound n t)) (bound_integrable : interval_integrable (λ (t : ℝ), ∑' (n : ι), bound n t) μ a b) (h_lim : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → has_sum (λ (n : ι), F n t) (f t)) : has_sum (λ (n : ι), ∫ (t : ℝ) in a..b, F n t ∂μ) (∫ (t : ℝ) in a..b, f t ∂μ)
theorem zmod.card_units_eq_totient (n : ℕ) [fact (0 < n)] [fintype (zmod n)ˣ] : fintype.card (zmod n)ˣ = n.totient
theorem intermediate_field.finite_dimensional_bot (K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] : finite_dimensional K ↥⊥
theorem norm_sub_sq {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x y : E} : ∥x - y∥ ^ 2 = ∥x∥ ^ 2 - 2 * ⇑is_R_or_C.re (has_inner.inner x y) + ∥y∥ ^ 2
theorem sup_sdiff_inj_on {α : Type u_1} [generalized_boolean_algebra α] (u v : α) : set.inj_on (λ (x : α), (x ⊔ u)  v) {x : α | disjoint u x ∧ v ≤ x}
theorem filter.high_scores {β : Type u_4} [linear_order β] [no_max_order β] {u : ℕ → β} (hu : filter.tendsto u filter.at_top filter.at_top) (N : ℕ) : ∃ (n : ℕ) (H : n ≥ N), ∀ (k : ℕ), k < n → u k < u n
theorem is_adic_iff {R : Type u_1} [comm_ring R] [top : topological_space R] [topological_ring R] {J : ideal R} : is_adic J ↔ (∀ (n : ℕ), is_open ↑(J ^ n)) ∧ ∀ (s : set R), s ∈ nhds 0 → (∃ (n : ℕ), ↑(J ^ n) ⊆ s)
theorem measure_theory.measure.hausdorff_measure_mono {X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] {d₁ d₂ : ℝ} (h : d₁ ≤ d₂) (s : set X) : ⇑(measure_theory.measure.hausdorff_measure d₂) s ≤ ⇑(measure_theory.measure.hausdorff_measure d₁) s
theorem commute.mul_self_sub_mul_self_eq {R : Type x} [non_unital_non_assoc_ring R] {a b : R} (h : commute a b) : a * a - b * b = (a + b) * (a - b)
theorem has_fderiv_at.le_of_lip' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {x₀ : E} (hf : has_fderiv_at f f' x₀) {C : ℝ} (hC₀ : 0 ≤ C) (hlip : ∀ᶠ (x : E) in nhds x₀, ∥f x - f x₀∥ ≤ C * ∥x - x₀∥) : ∥f'∥ ≤ C
theorem vector_span_range_eq_span_range_vsub_left_ne (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} (p : ι → P) (i₀ : ι) : vector_span k (set.range p) = submodule.span k (set.range (λ (i : {x // x ≠ i₀}), p i₀ -ᵥ p ↑i))
theorem orientation.oangle_neg_self_left {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x : V} (hx : x ≠ 0) : o.oangle (-x) x = ↑real.pi
theorem subgroup.exists_right_complement'_of_coprime {G : Type u} [group G] {N : subgroup G} [N.normal] (hN : (nat.card ↥N).coprime N.index) : ∃ (H : subgroup G), N.is_complement' H
theorem bdd_below.mono {α : Type u} [preorder α] ⦃s t : set α⦄ (h : s ⊆ t) : bdd_below t → bdd_below s
theorem fourier_subalgebra_coe  : fourier_subalgebra.to_submodule = submodule.span ℂ (set.range fourier)
theorem box_integral.has_integral_McShane_of_forall_is_o {ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} (B : box_integral.box_additive_map ι ℝ ↑I) (hB0 : ∀ (J : box_integral.box ι), 0 ≤ ⇑B J) (g : box_integral.box_additive_map ι F ↑I) (H : nnreal → ∀ (x : ι → ℝ), x ∈ ⇑box_integral.box.Icc I → ∀ (ε : ℝ), ε > 0 → (∃ (δ : ℝ) (H : δ > 0), ∀ (J : box_integral.box ι), J ≤ I → ⇑box_integral.box.Icc J ⊆ metric.closed_ball x δ → has_dist.dist (⇑(⇑vol J) (f x)) (⇑g J) ≤ ε * ⇑B J)) : box_integral.has_integral I box_integral.integration_params.McShane f vol (⇑g I)
theorem affine.simplex.monge_plane_comm {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P (n + 2)) (i₁ i₂ : fin (n + 3)) : s.monge_plane i₁ i₂ = s.monge_plane i₂ i₁
theorem holder_on_with.dimH_image_le {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {C r : nnreal} {f : X → Y} {s : set X} (h : holder_on_with C r f s) (hr : 0 < r) : dimH (f '' s) ≤ dimH s / ↑r
theorem order.pred_lt_of_not_is_min {α : Type u_1} [preorder α] [pred_order α] {a : α} : ¬is_min a → order.pred a < a
theorem subgroup.map_equiv_normalizer_eq {G : Type u_1} [group G] {N : Type u_3} [group N] (H : subgroup G) (f : G ≃* N) : subgroup.map f.to_monoid_hom H.normalizer = (subgroup.map f.to_monoid_hom H).normalizer
theorem measure_theory.measure.ext_of_sUnion_eq_univ {α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} {S : set (set α)} (hc : S.countable) (hs : ⋃₀S = set.univ) : (∀ (s : set α), s ∈ S → μ.restrict s = ν.restrict s) → μ = ν
theorem pow_four_add_four_mul_pow_four' {R : Type u_1} [comm_ring R] {a b : R} : a ^ 4 + 4 * b ^ 4 = (a ^ 2 - 2 * a * b + 2 * b ^ 2) * (a ^ 2 + 2 * a * b + 2 * b ^ 2)
theorem has_le.le.wcovby_of_le {α : Type u_1} [preorder α] {a b : α} (h1 : a ≤ b) (h2 : b ≤ a) : a ⩿ b
theorem matrix.diagonal_transvection_induction {n : Type u_1} {𝕜 : Type u_3} [field 𝕜] [decidable_eq n] [fintype n] (P : matrix n n 𝕜 → Prop) (M : matrix n n 𝕜) (hdiag : ∀ (D : n → 𝕜), (matrix.diagonal D).det = M.det → P (matrix.diagonal D)) (htransvec : ∀ (t : matrix.transvection_struct n 𝕜), P t.to_matrix) (hmul : ∀ (A B : matrix n n 𝕜), P A → P B → P (A.mul B)) : P M
theorem measurable_of_tendsto_metrizable' {α : Type u_1} {β : Type u_2} [measurable_space α] [topological_space β] [topological_space.pseudo_metrizable_space β] [measurable_space β] [borel_space β] {ι : Type u_3} {f : ι → α → β} {g : α → β} (u : filter ι) [u.ne_bot] [u.is_countably_generated] (hf : ∀ (i : ι), measurable (f i)) (lim : filter.tendsto f u (nhds g)) : measurable g
theorem emetric.inf_edist_zero_of_mem {α : Type u} [pseudo_emetric_space α] {x : α} {s : set α} (h : x ∈ s) : emetric.inf_edist x s = 0
theorem is_primitive_root.pow_sub_one_norm_prime_ne_two {p : ℕ+} {K : Type u} {L : Type v} [field L] {ζ : L} [field K] [algebra K L] [ne_zero ↑↑p] {k : ℕ} (hζ : is_primitive_root ζ ↑(p ^ (k + 1))) [hpri : fact (nat.prime ↑p)] [is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic ↑(p ^ (k + 1)) K)) {s : ℕ} (hs : s ≤ k) (hodd : p ≠ 2) : ⇑(algebra.norm K) (ζ ^ ↑p ^ s - 1) = ↑p ^ ↑p ^ s
theorem finrank_le_one_iff {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : finite_dimensional.finrank K V ≤ 1 ↔ ∃ (v : V), ∀ (w : V), ∃ (c : K), c • v = w
theorem deriv.lhopital_zero_nhds {a : ℝ} {l : filter ℝ} {f g : ℝ → ℝ} (hdf : ∀ᶠ (x : ℝ) in nhds a, differentiable_at ℝ f x) (hg' : ∀ᶠ (x : ℝ) in nhds a, deriv g x ≠ 0) (hfa : filter.tendsto f (nhds a) (nhds 0)) (hga : filter.tendsto g (nhds a) (nhds 0)) (hdiv : filter.tendsto (λ (x : ℝ), deriv f x / deriv g x) (nhds a) l) : filter.tendsto (λ (x : ℝ), f x / g x) (nhds_within a (set.univ  {a})) l
theorem is_smul_regular.zero_iff_subsingleton {R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] : is_smul_regular M 0 ↔ subsingleton M
theorem ideal.quotient.maximal_ideal_iff_is_field_quotient {R : Type u} [comm_ring R] (I : ideal R) : I.is_maximal ↔ is_field (R ⧸ I)
theorem cont_mdiff_on.cont_mdiff_on_tangent_map_within {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M → M'} {s : set M} {m n : with_top ℕ} (hf : cont_mdiff_on I I' n f s) (hmn : m + 1 ≤ n) (hs : unique_mdiff_on I s) : cont_mdiff_on I.tangent I'.tangent m (tangent_map_within I I' f s) (tangent_bundle.proj I M ⁻¹' s)
theorem affine_basis.affine_independent_of_to_matrix_right_inv {ι : Type u₁} {k : Type u₂} {V : Type u₃} {P : Type u₄} [add_comm_group V] [add_torsor V P] [ring k] [module k V] (b : affine_basis ι k P) {ι' : Type u_1} [fintype ι'] [fintype ι] [decidable_eq ι'] (p : ι' → P) {A : matrix ι ι' k} (hA : (b.to_matrix p).mul A = 1) : affine_independent k p
theorem mem_range_of_exists_le_of_exists_ge {X : Type u} {α : Type v} [topological_space X] [linear_order α] [topological_space α] [order_closed_topology α] [preconnected_space X] {c : α} {f : X → α} (hf : continuous f) (h₁ : ∃ (a : X), f a ≤ c) (h₂ : ∃ (b : X), c ≤ f b) : c ∈ set.range f
theorem cauchy_seq_of_le_geometric_two {α : Type u_1} [pseudo_metric_space α] (C : ℝ) {f : ℕ → α} (hu₂ : ∀ (n : ℕ), has_dist.dist (f n) (f (n + 1)) ≤ C / 2 / 2 ^ n) : cauchy_seq f
theorem pgame.mk_lf_mk {xl xr : Type u_1} {xL : xl → pgame} {xR : xr → pgame} {yl yr : Type u_1} {yL : yl → pgame} {yR : yr → pgame} : (pgame.mk xl xr xL xR).lf (pgame.mk yl yr yL yR) ↔ (∃ (i : yl), pgame.mk xl xr xL xR ≤ yL i) ∨ ∃ (j : xr), xR j ≤ pgame.mk yl yr yL yR
theorem order_of_pos_iff {G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x
theorem probability_theory.ident_distrib.ae_strongly_measurable_fst {α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] [measurable_space β] [measurable_space γ] {μ : measure_theory.measure α} {ν : measure_theory.measure β} {f : α → γ} {g : β → γ} [topological_space γ] [topological_space.metrizable_space γ] [opens_measurable_space γ] [topological_space.second_countable_topology γ] (h : probability_theory.ident_distrib f g μ ν) : measure_theory.ae_strongly_measurable f μ
theorem convex_cone.ext' {𝕜 : Type u_1} {E : Type u_2} [ordered_semiring 𝕜] [add_comm_monoid E] [has_scalar 𝕜 E] {S T : convex_cone 𝕜 E} (h : ↑S = ↑T) : S = T
theorem measurable_space.cardinal_generate_measurable_le {α : Type u} (s : set (set α)) : cardinal.mk ↥{t : set α | measurable_space.generate_measurable s t} ≤ linear_order.max (cardinal.mk ↥s) 2 ^ cardinal.aleph_0
theorem vsub_sub_vsub_cancel_right {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p1 p2 p3 : P) : p1 -ᵥ p3 - (p2 -ᵥ p3) = p1 -ᵥ p2
theorem zmod.legendre_sym_sq_one (p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_sym p a ^ 2 = 1
theorem ring_equiv.to_equiv_commutes {R : Type u_4} {S : Type u_5} [non_assoc_semiring R] [non_assoc_semiring S] (f : R ≃+* S) : ↑f.to_equiv = ↑f.to_equiv
theorem is_cyclotomic_extension.finite_dimensional (S : set ℕ+) (K : Type w) [field K] (C : Type z) [fintype ↥S] [comm_ring C] [algebra K C] [is_domain C] [is_cyclotomic_extension S K C] : finite_dimensional K C
theorem bilin_form.linear_independent_of_is_Ortho {V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] {n : Type w} {B : bilin_form K V} {v : n → V} (hv₁ : B.is_Ortho v) (hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i)) : linear_independent K v
theorem has_lt.lt.trans_le' {α : Type u} [preorder α] {a b c : α} : b < c → a ≤ b → a < c
theorem is_left_regular.subsingleton {R : Type u_1} [mul_zero_class R] (h : is_left_regular 0) : subsingleton R
theorem monoid_algebra.finite_type_iff_group_fg {R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) ↔ group.fg G
theorem countable_cover_nhds_of_sigma_compact {α : Type u} [topological_space α] [sigma_compact_space α] {f : α → set α} (hf : ∀ (x : α), f x ∈ nhds x) : ∃ (s : set α), s.countable ∧ (⋃ (x : α) (H : x ∈ s), f x) = set.univ
theorem add_submonoid.mem_closure_pair {A : Type u_1} [add_comm_monoid A] (a b c : A) : c ∈ add_submonoid.closure {a, b} ↔ ∃ (m n : ℕ), m • a + n • b = c
theorem infinite_basis_le_maximal_linear_independent {R : Type u} [ring R] {M : Type v} [add_comm_group M] [module R M] [nontrivial R] {ι : Type w} (b : basis ι R M) [infinite ι] {κ : Type w} (v : κ → M) (i : linear_independent R v) (m : i.maximal) : cardinal.mk ι ≤ cardinal.mk κ
theorem measurable.lintegral_prod_left {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} [measure_theory.sigma_finite μ] {f : α → β → ennreal} (hf : measurable (function.uncurry f)) : measurable (λ (y : β), ∫⁻ (x : α), f x y ∂μ)
theorem tsub_eq_zero_of_le {α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} (h : a ≤ b) : a - b = 0
theorem padic_norm.padic_norm_p_lt_one_of_prime (p : ℕ) [fact (nat.prime p)] : padic_norm p ↑p < 1
theorem submodule.finite_dimensional_of_le {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {S₁ S₂ : submodule K V} [finite_dimensional K ↥S₂] (h : S₁ ≤ S₂) : finite_dimensional K ↥S₁
theorem add_valuation.top_iff {Γ₀ : Type u_3} [linear_ordered_add_comm_monoid_with_top Γ₀] [nontrivial Γ₀] {K : Type u_1} [division_ring K] (v : add_valuation K Γ₀) {x : K} : ⇑v x = ⊤ ↔ x = 0
theorem measure_theory.measure.haar_measure_unique {G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] (μ : measure_theory.measure G) [measure_theory.sigma_finite μ] [μ.is_mul_left_invariant] (K₀ : topological_space.positive_compacts G) : μ = ⇑μ ↑K₀ • measure_theory.measure.haar_measure K₀
theorem filter.tendsto_at_bot_embedding {α : Type u_3} {β : Type u_4} {γ : Type u_5} [preorder β] [preorder γ] {f : α → β} {e : β → γ} {l : filter α} (hm : ∀ (b₁ b₂ : β), e b₁ ≤ e b₂ ↔ b₁ ≤ b₂) (hu : ∀ (c : γ), ∃ (b : β), e b ≤ c) : filter.tendsto (e ∘ f) l filter.at_bot ↔ filter.tendsto f l filter.at_bot
theorem finset.mem_up_shadow_iff_erase_mem {α : Type u_1} [decidable_eq α] [fintype α] {𝒜 : finset (finset α)} {s : finset α} : s ∈ 𝒜.up_shadow ↔ ∃ (a : α) (H : a ∈ s), s.erase a ∈ 𝒜
theorem prime_factors_irreducible {α : Type u_1} [cancel_comm_monoid_with_zero α] {a : α} {f : multiset α} (ha : irreducible a) (pfa : (∀ (b : α), b ∈ f → prime b) ∧ associated f.prod a) : ∃ (p : α), associated a p ∧ f = {p}
theorem metric.cthickening_mono {α : Type u} [pseudo_emetric_space α] {δ₁ δ₂ : ℝ} (hle : δ₁ ≤ δ₂) (E : set α) : metric.cthickening δ₁ E ⊆ metric.cthickening δ₂ E
theorem polynomial.splits_iff_card_roots {K : Type v} [field K] {p : polynomial K} : polynomial.splits (ring_hom.id K) p ↔ ⇑multiset.card p.roots = p.nat_degree
theorem linear_map.to_matrix_eq_to_matrix' {R : Type u_1} [comm_semiring R] {n : Type u_4} [fintype n] [decidable_eq n] : linear_map.to_matrix (pi.basis_fun R n) (pi.basis_fun R n) = linear_map.to_matrix'
theorem mdifferentiable.differentiable {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {f : E → E'} : mdifferentiable (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f → differentiable 𝕜 f
theorem unique_diff_within_at.prod {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {x : E} {s : set E} {t : set F} {y : F} (hs : unique_diff_within_at 𝕜 s x) (ht : unique_diff_within_at 𝕜 t y) : unique_diff_within_at 𝕜 (s ×ˢ t) (x, y)
theorem category_theory.has_colimits_of_shape_of_reflective {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {J : Type u} [category_theory.category J] (R : D ⥤ C) [category_theory.reflective R] [category_theory.limits.has_colimits_of_shape J C] : category_theory.limits.has_colimits_of_shape J D
theorem is_add_submonoid.preimage {M : Type u_1} [add_monoid M] {N : Type u_2} [add_monoid N] {f : M → N} (hf : is_add_monoid_hom f) {s : set N} (hs : is_add_submonoid s) : is_add_submonoid (f ⁻¹' s)
theorem add_action.card_eq_sum_card_add_group_sub_card_stabilizer' (α : Type u) (β : Type v) [add_group α] [add_action α β] [fintype α] [fintype β] [fintype (quotient (add_action.orbit_rel α β))] [Π (b : β), fintype ↥(add_action.stabilizer α b)] {φ : quotient (add_action.orbit_rel α β) → β} (hφ : function.left_inverse quotient.mk' φ) : fintype.card β = finset.univ.sum (λ (ω : quotient (add_action.orbit_rel α β)), fintype.card α / fintype.card ↥(add_action.stabilizer α (φ ω)))
theorem lt_of_tsub_lt_tsub_left_of_le {α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b c : α} [contravariant_class α α has_add.add has_le.le] [contravariant_class α α has_add.add has_lt.lt] (hca : c ≤ a) (h : a - b < a - c) : c < b
theorem affine_span_singleton_union_vadd_eq_top_of_span_eq_top {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set V} (p : P) (h : submodule.span k (set.range coe) = ⊤) : affine_span k ({p} ∪ (λ (v : V), v +ᵥ p) '' s) = ⊤
theorem list.sum_neg_reverse {G : Type u_7} [add_group G] (L : list G) : -L.sum = (list.map (λ (x : G), -x) L).reverse.sum
theorem complete_lattice.set_independent.pairwise_disjoint {α : Type u_1} [complete_lattice α] {s : set α} (hs : complete_lattice.set_independent s) : s.pairwise_disjoint id
theorem direct_sum.is_internal_submodule_iff_is_compl {R : Type u} [ring R] {ι : Type v} [dec_ι : decidable_eq ι] {M : Type u_1} [add_comm_group M] [module R M] (A : ι → submodule R M) {i j : ι} (hij : i ≠ j) (h : set.univ = {i, j}) : direct_sum.is_internal A ↔ is_compl (A i) (A j)
theorem contracting_with.dist_fixed_point_fixed_point_of_dist_le' {α : Type u_1} [metric_space α] {K : nnreal} {f : α → α} (hf : contracting_with K f) (g : α → α) {x y : α} (hx : function.is_fixed_pt f x) (hy : function.is_fixed_pt g y) {C : ℝ} (hfg : ∀ (z : α), has_dist.dist (f z) (g z) ≤ C) : has_dist.dist x y ≤ C / (1 - ↑K)
theorem algebraic_geometry.LocallyRingedSpace.to_Γ_Spec_continuous (X : algebraic_geometry.LocallyRingedSpace) : continuous X.to_Γ_Spec_fun
theorem add_equiv.map_neg {G : Type u_10} {H : Type u_11} [add_group G] [subtraction_monoid H] (h : G ≃+ H) (x : G) : ⇑h (-x) = -⇑h x
theorem list_prod_mem {M : Type u_1} {B : Type u_3} [monoid M] [set_like B M] [submonoid_class B M] {S : B} {l : list M} (hl : ∀ (x : M), x ∈ l → x ∈ S) : l.prod ∈ S
theorem bilin_form.not_nondegenerate_zero (R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] [nontrivial M] : ¬0.nondegenerate
theorem monoid.not_is_torsion_iff (G : Type u_1) [monoid G] : ¬monoid.is_torsion G ↔ ∃ (g : G), ¬is_of_fin_order g
theorem line_map_le_map_iff_slope_le_slope_right {k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k → E} {a b r : k} (h : 0 < (1 - r) * (b - a)) : ⇑(affine_map.line_map (f a) (f b)) r ≤ f (⇑(affine_map.line_map a b) r) ↔ slope f (⇑(affine_map.line_map a b) r) b ≤ slope f a b
theorem con.map_apply {M : Type u_1} [mul_one_class M] {c d : con M} (h : c ≤ d) (x : c.quotient) : ⇑(c.map d h) x = ⇑(c.lift d.mk' _) x
theorem cont_diff_on.dimH_image_le {E : Type u_4} {F : Type u_5} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] [normed_group F] [normed_space ℝ F] {f : E → F} {s t : set E} (hf : cont_diff_on ℝ 1 f s) (hc : convex ℝ s) (ht : t ⊆ s) : dimH (f '' t) ≤ dimH t
theorem uniform_space.complete_of_convergent_controlled_sequences {α : Type u} [uniform_space α] [(uniformity α).is_countably_generated] (U : ℕ → set (α × α)) (U_mem : ∀ (n : ℕ), U n ∈ uniformity α) (HU : ∀ (u : ℕ → α), (∀ (N m n : ℕ), N ≤ m → N ≤ n → (u m, u n) ∈ U N) → (∃ (a : α), filter.tendsto u filter.at_top (nhds a))) : complete_space α
theorem category_theory.has_finite_coproducts_of_has_binary_and_terminal {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_initial C] : category_theory.limits.has_finite_coproducts C
theorem has_le.le.lt_of_ne' {α : Type u} [partial_order α] {a b : α} : a ≤ b → b ≠ a → a < b
theorem concave_on.neg {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [ordered_add_comm_group β] [has_scalar 𝕜 E] [module 𝕜 β] {s : set E} {f : E → β} : concave_on 𝕜 s f → convex_on 𝕜 s (-f)
theorem measure_theory.ae_nonneg_of_forall_set_integral_nonneg_of_finite_measure_of_strongly_measurable {α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} [measure_theory.is_finite_measure μ] {f : α → ℝ} (hfm : measure_theory.strongly_measurable f) (hf : measure_theory.integrable f μ) (hf_zero : ∀ (s : set α), measurable_set s → 0 ≤ ∫ (x : α) in s, f x ∂μ) : 0 ≤ᵐ[μ] f
theorem module.free.rank_tensor_product (R : Type u) (M : Type v) (N : Type w) [comm_ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] [add_comm_group N] [module R N] [module.free R N] : module.rank R (tensor_product R M N) = (module.rank R M).lift * (module.rank R N).lift
theorem is_connected.Icc_subset {α : Type v} [linear_order α] [topological_space α] [order_closed_topology α] {s : set α} (hs : is_connected s) {a b : α} (ha : a ∈ s) (hb : b ∈ s) : set.Icc a b ⊆ s
theorem continuous_linear_map.norm_id_le {𝕜 : Type u_1} {E : Type u_4} [semi_normed_group E] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] : ∥continuous_linear_map.id 𝕜 E∥ ≤ 1
theorem map_le_line_map_iff_slope_le_slope_right {k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k → E} {a b r : k} (h : 0 < (1 - r) * (b - a)) : f (⇑(affine_map.line_map a b) r) ≤ ⇑(affine_map.line_map (f a) (f b)) r ↔ slope f a b ≤ slope f (⇑(affine_map.line_map a b) r) b
theorem smul_pos_of_neg_of_neg {k : Type u_1} {M : Type u_2} [ordered_ring k] [ordered_add_comm_group M] [module k M] [ordered_smul k M] {a : M} {c : k} (hc : c < 0) : a < 0 → 0 < c • a
theorem fin.coe_coe_of_lt {n a : ℕ} (h : a < n + 1) : ↑↑a = a
theorem algebra.right_comm {R : Type u} {A : Type w} [comm_semiring R] [semiring A] [algebra R A] (x : A) (r : R) (y : A) : x * ⇑(algebra_map R A) r * y = x * y * ⇑(algebra_map R A) r
theorem category_theory.subobject.exists_iso_map {C : Type u₁} [category_theory.category C] {X Y : C} [category_theory.limits.has_images C] (f : X ⟶ Y) [category_theory.mono f] : category_theory.subobject.exists f = category_theory.subobject.map f
theorem ereal.le_neg_of_le_neg {a b : ereal} (h : a ≤ -b) : b ≤ -a
theorem add_subgroup.fg_iff {G : Type u_3} [add_group G] (P : add_subgroup G) : P.fg ↔ ∃ (S : set G), add_subgroup.closure S = P ∧ S.finite
theorem algebra.is_algebraic_iff {R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] : algebra.is_algebraic R A ↔ ⊤.is_algebraic
theorem multiset.nodup.dedup {α : Type u_1} [decidable_eq α] {s : multiset α} : s.nodup → s.dedup = s
theorem structure_groupoid.is_local_structomorph_within_at_local_invariant_prop {H : Type u_1} [topological_space H] (G : structure_groupoid H) [closed_under_restriction G] : G.local_invariant_prop G G.is_local_structomorph_within_at
theorem eckmann_hilton.one {X : Type u} {m₁ m₂ : X → X → X} {e₁ e₂ : X} (h₁ : eckmann_hilton.is_unital m₁ e₁) (h₂ : eckmann_hilton.is_unital m₂ e₂) (distrib : ∀ (a b c d : X), m₁ (m₂ a b) (m₂ c d) = m₂ (m₁ a c) (m₁ b d)) : e₁ = e₂
theorem metric.closure_eq_Inter_thickening' {α : Type u} [pseudo_emetric_space α] (E : set α) (s : set ℝ) (hs₀ : s ⊆ set.Ioi 0) (hs : ∀ (ε : ℝ), 0 < ε → (s ∩ set.Ioc 0 ε).nonempty) : closure E = ⋂ (δ : ℝ) (H : δ ∈ s), metric.thickening δ E
theorem measure_theory.measure_lintegral_div_measure {G : Type u_1} [measurable_space G] [group G] [has_measurable_mul₂ G] (μ ν : measure_theory.measure G) [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] {E : set G} [has_measurable_inv G] [μ.is_mul_left_invariant] [ν.is_mul_left_invariant] (Em : measurable_set E) (h2E : ⇑ν E ≠ 0) (h3E : ⇑ν E ≠ ⊤) (f : G → ennreal) (hf : measurable f) : ⇑μ E * ∫⁻ (y : G), f y⁻¹ / ⇑ν ((λ (x : G), x * y⁻¹) ⁻¹' E) ∂ν = ∫⁻ (x : G), f x ∂μ
theorem real.Sup_nonneg (S : set ℝ) (hS : ∀ (x : ℝ), x ∈ S → 0 ≤ x) : 0 ≤ has_Sup.Sup S
theorem measure_theory.integral_mul_right_eq_self {G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure G} [group G] [has_measurable_mul G] [μ.is_mul_right_invariant] (f : G → E) (g : G) : ∫ (x : G), f (x * g) ∂μ = ∫ (x : G), f x ∂μ
theorem has_ftaylor_series_up_to_on.continuous_linear_map_comp {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {s : set E} {f : E → F} {n : with_top ℕ} {p : E → formal_multilinear_series 𝕜 E F} (g : F →L[𝕜] G) (hf : has_ftaylor_series_up_to_on n f p s) : has_ftaylor_series_up_to_on n (⇑g ∘ f) (λ (x : E) (k : ℕ), g.comp_continuous_multilinear_map (p x k)) s
theorem summable.mapL {ι : Type u_10} {R : Type u_11} {R₂ : Type u_12} {M : Type u_13} {M₂ : Type u_14} [semiring R] [semiring R₂] [add_comm_monoid M] [module R M] [add_comm_monoid M₂] [module R₂ M₂] [topological_space M] [topological_space M₂] {σ : R →+* R₂} {f : ι → M} (φ : M →SL[σ] M₂) (hf : summable f) : summable (λ (b : ι), ⇑φ (f b))
theorem exists_mem_Ico_zpow {α : Type u_1} [linear_ordered_field α] [archimedean α] {x y : α} (hx : 0 < x) (hy : 1 < y) : ∃ (n : ℤ), x ∈ set.Ico (y ^ n) (y ^ (n + 1))
theorem solvable_by_rad.is_solvable' {F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] {α : E} {q : polynomial F} (q_irred : irreducible q) (q_aeval : ⇑(polynomial.aeval α) q = 0) (hα : is_solvable_by_rad F α) : is_solvable q.gal
theorem local_homeomorph.continuous_on_iff_continuous_on_comp_right {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] (e : local_homeomorph α β) {f : β → γ} {s : set β} (h : s ⊆ e.to_local_equiv.target) : continuous_on f s ↔ continuous_on (f ∘ ⇑e) (e.to_local_equiv.source ∩ ⇑e ⁻¹' s)
theorem submodule.orthogonal_disjoint {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) : disjoint K Kᗮ
theorem metric.exists_ball_inter_eq_singleton_of_mem_discrete {α : Type u} [pseudo_metric_space α] {s : set α} [discrete_topology ↥s] {x : α} (hx : x ∈ s) : ∃ (ε : ℝ) (H : ε > 0), metric.ball x ε ∩ s = {x}
theorem measure_theory.Lp.simple_func.measurable {α : Type u_1} {E : Type u_4} [measurable_space α] [normed_group E] {p : ennreal} {μ : measure_theory.measure α} [measurable_space E] (f : ↥(measure_theory.Lp.simple_func E p μ)) : measurable ⇑(measure_theory.Lp.simple_func.to_simple_func f)
theorem has_fderiv_at_iff_has_deriv_at {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {F : Type v} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {x : 𝕜} {f' : 𝕜 →L[𝕜] F} : has_fderiv_at f f' x ↔ has_deriv_at f (⇑f' 1) x
theorem first_order.language.substructure.closure_induction {L : first_order.language} {M : Type w} [L.Structure M] {s : set M} {p : M → Prop} {x : M} (h : x ∈ ⇑(first_order.language.substructure.closure L) s) (Hs : ∀ (x : M), x ∈ s → p x) (Hfun : ∀ {n : ℕ} (f : L.functions n), first_order.language.closed_under f (set_of p)) : p x
theorem category_theory.bicategory.left_unitor_whisker_right {B : Type u} [category_theory.bicategory B] {a b c : B} (f : a ⟶ b) (g : b ⟶ c) : category_theory.bicategory.whisker_right (category_theory.bicategory.left_unitor f).hom g = (category_theory.bicategory.associator (𝟙 a) f g).hom ≫ (category_theory.bicategory.left_unitor (f ≫ g)).hom
theorem finset.sum_smul_vsub_eq_affine_combination_vsub {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (w : ι → k) (p₁ p₂ : ι → P) : s.sum (λ (i : ι), w i • (p₁ i -ᵥ p₂ i)) = ⇑(s.affine_combination p₁) w -ᵥ ⇑(s.affine_combination p₂) w
theorem measure_theory.sum_measure_preimage_singleton {α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} (s : finset β) {f : α → β} (hf : ∀ (y : β), y ∈ s → measurable_set (f ⁻¹' {y})) : s.sum (λ (b : β), ⇑μ (f ⁻¹' {b})) = ⇑μ (f ⁻¹' ↑s)
theorem measure_theory.measure_inter_add_diff₀ {α : Type u_2} {m0 : measurable_space α} {μ : measure_theory.measure α} {t : set α} (s : set α) (ht : measure_theory.null_measurable_set t μ) : ⇑μ (s ∩ t) + ⇑μ (s  t) = ⇑μ s
theorem bilin_form.is_adjoint_pair_iff_eq_of_nondegenerate {V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (B : bilin_form K V) (b : B.nondegenerate) (ψ φ : V →ₗ[K] V) : B.is_adjoint_pair B ψ φ ↔ ψ = B.left_adjoint_of_nondegenerate b φ
theorem finset.map_perm {α : Type u_1} {s : finset α} {σ : equiv.perm α} (hs : {a : α | ⇑σ a ≠ a} ⊆ ↑s) : finset.map ↑σ s = s
theorem order.le_of_pred_le_pred {α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α] : order.pred a ≤ order.pred b → a ≤ b
theorem is_preconnected_iff_subset_of_disjoint_closed {α : Type u} [topological_space α] {s : set α} : is_preconnected s ↔ ∀ (u v : set α), is_closed u → is_closed v → s ⊆ u ∪ v → s ∩ (u ∩ v) = ∅ → s ⊆ u ∨ s ⊆ v
theorem fin.tail_update_succ {n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (i : fin n) (y : α i.succ) : fin.tail (function.update q i.succ y) = function.update (fin.tail q) i y
theorem algebraic_geometry.PresheafedSpace.is_open_immersion.app_inv_app' {C : Type u} [category_theory.category C] {X Y : algebraic_geometry.PresheafedSpace C} {f : X ⟶ Y} (H : algebraic_geometry.PresheafedSpace.is_open_immersion f) (U : topological_space.opens ↥Y) (hU : ↑U ⊆ set.range ⇑(f.base)) : f.c.app (opposite.op U) ≫ H.inv_app ((topological_space.opens.map f.base).obj U) = Y.presheaf.map (category_theory.eq_to_hom _).op
theorem fin.succ_above_lt_iff {n : ℕ} (p : fin (n + 1)) (i : fin n) : ⇑(p.succ_above) i < p ↔ ⇑fin.cast_succ i < p
theorem orthonormal.oangle_add_oangle_rev_neg_right {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x y : V) : hb.oangle x (-y) + hb.oangle y (-x) = 0
theorem filter.at_top_Ici_eq {α : Type u_3} [semilattice_sup α] (a : α) : filter.at_top = filter.comap coe filter.at_top
theorem asymptotics.is_O_with.of_neg_right {α : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {c : ℝ} {f : α → E} {g' : α → F'} {l : filter α} : asymptotics.is_O_with c l f (λ (x : α), -g' x) → asymptotics.is_O_with c l f g'
theorem finrank_vector_span_range_le (k : Type u_1) {V : Type u_2} {P : Type u_3} {ι : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype ι] (p : ι → P) {n : ℕ} (hc : fintype.card ι = n + 1) : finite_dimensional.finrank k ↥(vector_span k (set.range p)) ≤ n
theorem fin.is_some_find_iff {n : ℕ} {p : fin n → Prop} [decidable_pred p] : ↥((fin.find p).is_some) ↔ ∃ (i : fin n), p i
theorem coe_affine_span (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : ↑(affine_span k s) = span_points k s
theorem add_monoid_algebra.lift_unique {k : Type u₁} {G : Type u₂} [comm_semiring k] [add_monoid G] {A : Type u₃} [semiring A] [algebra k A] (F : add_monoid_algebra k G →ₐ[k] A) (f : monoid_algebra k G) : ⇑F f = finsupp.sum f (λ (a : G) (b : k), b • ⇑F (finsupp.single a 1))
theorem cont_diff.mul {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {n : with_top ℕ} {f g : E → 𝕜} (hf : cont_diff 𝕜 n f) (hg : cont_diff 𝕜 n g) : cont_diff 𝕜 n (λ (x : E), f x * g x)
theorem category_theory.grothendieck_topology.le_close {C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : S ≤ J₁.close S
theorem finset.sum_range_id (n : ℕ) : (finset.range n).sum (λ (i : ℕ), i) = n * (n - 1) / 2
theorem continuous_linear_map.op_norm_le_bound {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →SL[σ₁₂] F) {M : ℝ} (hMp : 0 ≤ M) (hM : ∀ (x : E), ∥⇑f x∥ ≤ M * ∥x∥) : ∥f∥ ≤ M
theorem has_ftaylor_series_up_to_on.eventually_has_fderiv_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {x : E} {n : with_top ℕ} {p : E → formal_multilinear_series 𝕜 E F} (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 ≤ n) (hx : s ∈ nhds x) : ∀ᶠ (y : E) in nhds x, has_fderiv_at f (⇑(continuous_multilinear_curry_fin1 𝕜 E F) (p y 1)) y
theorem lt_neg_of_lt_neg {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a < -b → b < -a
theorem formal_multilinear_series.comp_coeff_one {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [comm_ring 𝕜] [add_comm_group E] [add_comm_group F] [add_comm_group G] [module 𝕜 E] [module 𝕜 F] [module 𝕜 G] [topological_space E] [topological_space F] [topological_space G] [topological_add_group E] [has_continuous_const_smul 𝕜 E] [topological_add_group F] [has_continuous_const_smul 𝕜 F] [topological_add_group G] [has_continuous_const_smul 𝕜 G] (q : formal_multilinear_series 𝕜 F G) (p : formal_multilinear_series 𝕜 E F) (v : fin 1 → E) : ⇑(q.comp p 1) v = ⇑(q 1) (λ (i : fin 1), ⇑(p 1) v)
theorem topological_semiring.to_topological_ring {α : Type u_1} [topological_space α] [non_assoc_ring α] (h : topological_semiring α) : topological_ring α
theorem has_le.le.eq_or_lt {α : Type u} [partial_order α] {a b : α} (h : a ≤ b) : a = b ∨ a < b
theorem continuous_linear_map.eq_on_closure_span {R₁ : Type u_1} {R₂ : Type u_2} [semiring R₁] [semiring R₂] {σ₁₂ : R₁ →+* R₂} {M₁ : Type u_4} [topological_space M₁] [add_comm_monoid M₁] {M₂ : Type u_6} [topological_space M₂] [add_comm_monoid M₂] [module R₁ M₁] [module R₂ M₂] [t2_space M₂] {s : set M₁} {f g : M₁ →SL[σ₁₂] M₂} (h : set.eq_on ⇑f ⇑g s) : set.eq_on ⇑f ⇑g (closure ↑(submodule.span R₁ s))
theorem circle_deg1_lift.semiconj_of_is_unit_of_translation_number_eq {f₁ f₂ : circle_deg1_lift} (h₁ : is_unit f₁) (h₂ : is_unit f₂) (h : f₁.translation_number = f₂.translation_number) : ∃ (F : circle_deg1_lift), function.semiconj ⇑F ⇑f₁ ⇑f₂
theorem Kuratowski_embedding.isometry (α : Type u) [metric_space α] [topological_space.separable_space α] : isometry (Kuratowski_embedding α)
theorem inner_product_space.of_core.inner_add_add_self {𝕜 : Type u_1} {F : Type u_3} [is_R_or_C 𝕜] [add_comm_group F] [module 𝕜 F] [c : inner_product_space.core 𝕜 F] {x y : F} : has_inner.inner (x + y) (x + y) = has_inner.inner x x + has_inner.inner x y + has_inner.inner y x + has_inner.inner y y
theorem zero_at_infty_continuous_map.tendsto_iff_tendsto_uniformly {α : Type u} {β : Type v} [topological_space α] [metric_space β] [has_zero β] {ι : Type u_1} {F : ι → zero_at_infty_continuous_map α β} {f : zero_at_infty_continuous_map α β} {l : filter ι} : filter.tendsto F l (nhds f) ↔ tendsto_uniformly (λ (i : ι), ⇑(F i)) ⇑f l
theorem measure_theory.jordan_decomposition.to_signed_measure_injective {α : Type u_1} [measurable_space α] : function.injective measure_theory.jordan_decomposition.to_signed_measure
theorem continuous_linear_equiv.comp_cont_diff_on_iff {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {s : set E} {f : E → F} {n : with_top ℕ} (e : F ≃L[𝕜] G) : cont_diff_on 𝕜 n (⇑e ∘ f) s ↔ cont_diff_on 𝕜 n f s
theorem is_add_submonoid.multiples_subset {M : Type u_1} [add_monoid M] {s : set M} {a : M} (hs : is_add_submonoid s) (h : a ∈ s) : multiples a ⊆ s
theorem metric.is_compact_of_is_closed_bounded {α : Type u} [pseudo_metric_space α] {s : set α} [proper_space α] (hc : is_closed s) (hb : metric.bounded s) : is_compact s
theorem list.nth_le_split_wrt_composition {n : ℕ} {α : Type u_1} (l : list α) (c : composition n) {i : ℕ} (hi : i < (l.split_wrt_composition c).length) : (l.split_wrt_composition c).nth_le i hi = list.drop (c.size_up_to i) (list.take (c.size_up_to (i + 1)) l)
theorem measure_theory.measure.map_apply_of_ae_measurable {α : Type u_1} {β : Type u_2} {m0 : measurable_space α} [measurable_space β] {μ : measure_theory.measure α} {f : α → β} (hf : ae_measurable f μ) {s : set β} (hs : measurable_set s) : ⇑(measure_theory.measure.map f μ) s = ⇑μ (f ⁻¹' s)
theorem complex.Gamma_integral_convergent {s : ℂ} (hs : 0 < s.re) : measure_theory.integrable_on (λ (x : ℝ), ↑(real.exp (-x)) * ↑x ^ (s - 1)) (set.Ioi 0) measure_theory.measure_space.volume
theorem convex.combo_affine_apply {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [ordered_ring 𝕜] [add_comm_group E] [add_comm_group F] [module 𝕜 E] [module 𝕜 F] {a b : 𝕜} {x y : E} {f : E →ᵃ[𝕜] F} (h : a + b = 1) : ⇑f (a • x + b • y) = a • ⇑f x + b • ⇑f y
theorem linear_map.infi_invariant {R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] {σ : R →+* R} [ring_hom_surjective σ] {ι : Sort u_2} (f : M →ₛₗ[σ] M) {p : ι → submodule R M} (hf : ∀ (i : ι) (v : M), v ∈ p i → ⇑f v ∈ p i) (v : M) (H : v ∈ infi p) : ⇑f v ∈ infi p
theorem monoid.exists_list_of_mem_closure {M : Type u_1} [monoid M] {s : set M} {a : M} (h : a ∈ monoid.closure s) : ∃ (l : list M), (∀ (x : M), x ∈ l → x ∈ s) ∧ l.prod = a
theorem subset_tangent_cone_prod_left {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {x : E} {s : set E} {t : set F} {y : F} (ht : y ∈ closure t) : ⇑(linear_map.inl 𝕜 E F) '' tangent_cone_at 𝕜 s x ⊆ tangent_cone_at 𝕜 (s ×ˢ t) (x, y)
theorem has_lt.lt.trans_eq {α : Type u} [preorder α] {a b c : α} (hab : a < b) (hbc : b = c) : a < c
theorem measure_theory.lintegral_tendsto_of_tendsto_of_monotone {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : ℕ → α → ennreal} {F : α → ennreal} (hf : ∀ (n : ℕ), ae_measurable (f n) μ) (h_mono : ∀ᵐ (x : α) ∂μ, monotone (λ (n : ℕ), f n x)) (h_tendsto : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (nhds (F x))) : filter.tendsto (λ (n : ℕ), ∫⁻ (x : α), f n x ∂μ) filter.at_top (nhds (∫⁻ (x : α), F x ∂μ))
theorem orthonormal.inner_right_fintype {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} [fintype ι] {v : ι → E} (hv : orthonormal 𝕜 v) (l : ι → 𝕜) (i : ι) : has_inner.inner (v i) (finset.univ.sum (λ (i : ι), l i • v i)) = l i
theorem has_dvd.dvd.multiplicity_pos {α : Type u_1} [comm_monoid α] [decidable_rel has_dvd.dvd] {a b : α} : a ∣ b → 0 < multiplicity a b
theorem has_fpower_series_on_ball.image_sub_sub_deriv_le {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] {f : E → F} {p : formal_multilinear_series 𝕜 E F} {x : E} {r r' : ennreal} (hf : has_fpower_series_on_ball f p x r) (hr : r' < r) : ∃ (C : ℝ), ∀ (y : E), y ∈ emetric.ball x r' → ∀ (z : E), z ∈ emetric.ball x r' → ∥f y - f z - ⇑(p 1) (λ (_x : fin 1), y - z)∥ ≤ C * linear_order.max ∥y - x∥ ∥z - x∥ * ∥y - z∥
theorem upper_semicontinuous.add {α : Type u_1} [topological_space α] {γ : Type u_4} [linear_ordered_add_comm_monoid γ] [topological_space γ] [order_topology γ] [has_continuous_add γ] {f g : α → γ} (hf : upper_semicontinuous f) (hg : upper_semicontinuous g) : upper_semicontinuous (λ (z : α), f z + g z)
theorem finprod_mem_range {α : Type u_1} {β : Type u_2} {M : Type u_5} [comm_monoid M] {f : α → M} {g : β → α} (hg : function.injective g) : finprod (λ (i : α), finprod (λ (H : i ∈ set.range g), f i)) = finprod (λ (j : β), f (g j))
theorem basis.finite_index_of_dim_lt_aleph_0 {R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {ι : Type u_1} {s : set ι} (b : basis ↥s R M) (h : module.rank R M < cardinal.aleph_0) : s.finite
theorem real.angle.induction_on {p : real.angle → Prop} (θ : real.angle) (h : ∀ (x : ℝ), p ↑x) : p θ
theorem liouville_with.exists_pos {p x : ℝ} (h : liouville_with p x) : ∃ (C : ℝ) (h₀ : 0 < C), ∃ᶠ (n : ℕ) in filter.at_top, 1 ≤ n ∧ ∃ (m : ℤ), x ≠ ↑m / ↑n ∧ |x - ↑m / ↑n| < C / ↑n ^ p
theorem cinfi_le {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {f : ι → α} (H : bdd_below (set.range f)) (c : ι) : infi f ≤ f c
theorem power_series.exp_mul_exp_neg_eq_one {A : Type u_1} [comm_ring A] [algebra ℚ A] : power_series.exp A * ⇑power_series.eval_neg_hom (power_series.exp A) = 1
theorem category_theory.is_iso_left_of_is_iso_biprod_map {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_binary_biproducts C] {W X Y Z : C} (f : W ⟶ Y) (g : X ⟶ Z) [category_theory.is_iso (category_theory.limits.biprod.map f g)] : category_theory.is_iso f
theorem generalized_continued_fraction.continuants_aux_eq_continuants_aux_squash_gcf_of_le {K : Type u_1} {n : ℕ} {g : generalized_continued_fraction K} [division_ring K] {m : ℕ} : m ≤ n → g.continuants_aux m = (g.squash_gcf n).continuants_aux m
theorem fin.find_min {n : ℕ} {p : fin n → Prop} [decidable_pred p] {i : fin n} (hi : i ∈ fin.find p) {j : fin n} (hj : j < i) : ¬p j
theorem multilinear_map.dom_coprod_alternization_coe {ιa : Type u_7} {ιb : Type u_8} [decidable_eq ιa] [decidable_eq ιb] [fintype ιa] [fintype ιb] {R' : Type u_9} {Mᵢ : Type u_10} {N₁ : Type u_11} {N₂ : Type u_12} [comm_semiring R'] [add_comm_group N₁] [module R' N₁] [add_comm_group N₂] [module R' N₂] [add_comm_monoid Mᵢ] [module R' Mᵢ] (a : multilinear_map R' (λ (_x : ιa), Mᵢ) N₁) (b : multilinear_map R' (λ (_x : ιb), Mᵢ) N₂) : ↑(⇑multilinear_map.alternatization a).dom_coprod ↑(⇑multilinear_map.alternatization b) = finset.univ.sum (λ (σa : equiv.perm ιa), finset.univ.sum (λ (σb : equiv.perm ιb), ⇑equiv.perm.sign σa • ⇑equiv.perm.sign σb • (multilinear_map.dom_dom_congr σa a).dom_coprod (multilinear_map.dom_dom_congr σb b)))
theorem polynomial.X_pow_sub_one_splits {K : Type u_1} [field K] {ζ : K} {n : ℕ} (h : is_primitive_root ζ n) : polynomial.splits (ring_hom.id K) (polynomial.X ^ n - ⇑polynomial.C 1)
theorem list.take_append {α : Type u} {l₁ l₂ : list α} (i : ℕ) : list.take (l₁.length + i) (l₁ ++ l₂) = l₁ ++ list.take i l₂
theorem category_theory.limits.eq_of_mono_coequalizer {C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} [category_theory.limits.has_coequalizer f g] [category_theory.mono (category_theory.limits.coequalizer.π f g)] : f = g
theorem category_theory.exact_d_f {C : Type u} [category_theory.category C] [category_theory.enough_projectives C] [category_theory.abelian C] {X Y : C} (f : X ⟶ Y) : category_theory.exact (category_theory.projective.d f) f
theorem le_sub_right_of_add_le {α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b c : α} : a + b ≤ c → a ≤ c - b
theorem cont_diff_at_snd {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : with_top ℕ} {p : E × F} : cont_diff_at 𝕜 n prod.snd p
theorem right.mul_lt_one {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1
theorem geom_sum₂_mul_add {α : Type u} [comm_semiring α] (x y : α) (n : ℕ) : (finset.range n).sum (λ (i : ℕ), (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n
theorem is_antichain.disjoint_slice_shadow_falling {α : Type u_2} [decidable_eq α] {𝒜 : finset (finset α)} {m n : ℕ} (h𝒜 : is_antichain has_subset.subset ↑𝒜) : disjoint (𝒜.slice m) (finset.falling n 𝒜).shadow
theorem euclidean_geometry.exists_dist_eq_circumradius_of_subset_insert_orthocenter {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {t : affine.triangle ℝ P} (ho : t.orthocenter ∉ set.range t.points) {p : fin 3 → P} (hps : set.range p ⊆ has_insert.insert t.orthocenter (set.range t.points)) (hpi : function.injective p) : ∃ (c : P) (H : c ∈ affine_span ℝ (set.range t.points)), ∀ (p₁ : P), p₁ ∈ set.range p → has_dist.dist p₁ c = affine.simplex.circumradius t
theorem subsemiring.one_mem {R : Type u} [non_assoc_semiring R] (s : subsemiring R) : 1 ∈ s
theorem polynomial.bernoulli_succ_eval (n p : ℕ) : polynomial.eval ↑n (polynomial.bernoulli p.succ) = bernoulli p.succ + (↑p + 1) * (finset.range n).sum (λ (k : ℕ), ↑k ^ p)
theorem orthogonal_projection_mem_subspace_orthogonal_complement_eq_zero {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K : submodule 𝕜 E} [complete_space ↥K] {v : E} (hv : v ∈ Kᗮ) : ⇑(orthogonal_projection K) v = 0
theorem bernstein_polynomial.variance (R : Type u_1) [comm_ring R] (n : ℕ) : (finset.range (n + 1)).sum (λ (ν : ℕ), (n • polynomial.X - ↑ν) ^ 2 * bernstein_polynomial R n ν) = n • polynomial.X * (1 - polynomial.X)
theorem euclidean_domain.gcd_eq_gcd_ab {R : Type u} [euclidean_domain R] [decidable_eq R] (a b : R) : euclidean_domain.gcd a b = a * euclidean_domain.gcd_a a b + b * euclidean_domain.gcd_b a b
theorem is_mul_hom.id {α : Type u} [has_mul α] : is_mul_hom id
theorem liouville_with.mul_rat {p x : ℝ} {r : ℚ} (h : liouville_with p x) (hr : r ≠ 0) : liouville_with p (x * ↑r)
theorem category_theory.adjunction.has_limits_of_equivalence {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (E : D ⥤ C) [category_theory.is_equivalence E] [category_theory.limits.has_limits_of_size C] : category_theory.limits.has_limits_of_size D
theorem finrank_vector_span_le_iff_not_affine_independent (k : Type u_1) {V : Type u_2} {P : Type u_3} {ι : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype ι] (p : ι → P) {n : ℕ} (hc : fintype.card ι = n + 2) : finite_dimensional.finrank k ↥(vector_span k (set.range p)) ≤ n ↔ ¬affine_independent k p
theorem measure_theory.lintegral_le_of_forall_fin_meas_le_of_measurable {α : Type u_1} {m m0 : measurable_space α} {μ : measure_theory.measure α} (hm : m ≤ m0) [measure_theory.sigma_finite (μ.trim hm)] (C : ennreal) {f : α → ennreal} (hf_meas : measurable f) (hf : ∀ (s : set α), measurable_set s → ⇑μ s ≠ ⊤ → ∫⁻ (x : α) in s, f x ∂μ ≤ C) : ∫⁻ (x : α), f x ∂μ ≤ C
theorem cauchy_seq_of_edist_le_of_summable {α : Type u_1} [pseudo_emetric_space α] {f : ℕ → α} (d : ℕ → nnreal) (hf : ∀ (n : ℕ), has_edist.edist (f n) (f n.succ) ≤ ↑(d n)) (hd : summable d) : cauchy_seq f
theorem category_theory.simplicial_object.δ_comp_δ_self {C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) {n : ℕ} {i : fin (n + 2)} : X.δ (⇑fin.cast_succ i) ≫ X.δ i = X.δ i.succ ≫ X.δ i
theorem is_semiring_hom.id {α : Type u} [semiring α] : is_semiring_hom id
theorem ennreal.infi_mul_of_ne {ι : Sort u_1} {f : ι → ennreal} {x : ennreal} (h0 : x ≠ 0) (h : x ≠ ⊤) : infi f * x = ⨅ (i : ι), f i * x
theorem interval_integral.deriv_within_integral_of_tendsto_ae_left {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {c : E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set ℝ} [interval_integral.FTC_filter a (nhds_within a s) (nhds_within a t)] (hmeas : strongly_measurable_at_filter f (nhds_within a t) measure_theory.measure_space.volume) (ha : filter.tendsto f (nhds_within a t ⊓ measure_theory.measure_space.volume.ae) (nhds c)) (hs : unique_diff_within_at ℝ s a . "unique_diff_within_at_Ici_Iic_univ") : deriv_within (λ (u : ℝ), ∫ (x : ℝ) in u..b, f x) s a = -c
theorem monoid_algebra.lift_unique {k : Type u₁} {G : Type u₂} [comm_semiring k] [monoid G] {A : Type u₃} [semiring A] [algebra k A] (F : monoid_algebra k G →ₐ[k] A) (f : monoid_algebra k G) : ⇑F f = finsupp.sum f (λ (a : G) (b : k), b • ⇑F (finsupp.single a 1))
theorem fib_is_sol_fib_rec {α : Type u_1} [comm_semiring α] : fib_rec.is_solution (λ (x : ℕ), ↑(nat.fib x))
theorem category_theory.preadditive.exact_of_iso_of_exact' {V : Type u} [category_theory.category V] [category_theory.limits.has_images V] [category_theory.limits.has_zero_object V] [category_theory.preadditive V] [category_theory.limits.has_kernels V] [category_theory.limits.has_cokernels V] {A₁ B₁ C₁ A₂ B₂ C₂ : V} (f₁ : A₁ ⟶ B₁) (g₁ : B₁ ⟶ C₁) (f₂ : A₂ ⟶ B₂) (g₂ : B₂ ⟶ C₂) (α : A₁ ≅ A₂) (β : B₁ ≅ B₂) (γ : C₁ ≅ C₂) (hsq₁ : α.hom ≫ f₂ = f₁ ≫ β.hom) (hsq₂ : β.hom ≫ g₂ = g₁ ≫ γ.hom) (h : category_theory.exact f₁ g₁) : category_theory.exact f₂ g₂
theorem submodule.torsion_is_torsion {R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] : module.is_torsion R ↥(submodule.torsion R M)
theorem generalized_tube_lemma {α : Type u} {β : Type v} [topological_space α] [topological_space β] {s : set α} (hs : is_compact s) {t : set β} (ht : is_compact t) {n : set (α × β)} (hn : is_open n) (hp : s ×ˢ t ⊆ n) : ∃ (u : set α) (v : set β), is_open u ∧ is_open v ∧ s ⊆ u ∧ t ⊆ v ∧ u ×ˢ v ⊆ n
theorem trans_gen_of_succ_of_ne {α : Type u_1} [linear_order α] [succ_order α] [is_succ_archimedean α] (r : α → α → Prop) {n m : α} (h1 : ∀ (i : α), i ∈ set.Ico n m → r i (order.succ i)) (h2 : ∀ (i : α), i ∈ set.Ico m n → r (order.succ i) i) (hnm : n ≠ m) : relation.trans_gen r n m
theorem real.tendsto_div_pow_mul_exp_add_at_top (b c : ℝ) (n : ℕ) (hb : 0 ≠ b) : filter.tendsto (λ (x : ℝ), x ^ n / (b * real.exp x + c)) filter.at_top (nhds 0)
theorem metric.cthickening_thickening_subset {α : Type u} [pseudo_emetric_space α] {ε : ℝ} (hε : 0 ≤ ε) (δ : ℝ) (s : set α) : metric.cthickening ε (metric.thickening δ s) ⊆ metric.cthickening (ε + δ) s
theorem function.embedding.is_empty_of_card_lt {α : Type u_1} {β : Type u_2} [fintype α] [fintype β] (h : fintype.card β < fintype.card α) : is_empty (α ↪ β)
theorem minpoly.ne_one (A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : minpoly A x ≠ 1
theorem asymptotics.is_o.of_norm_norm {α : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_normed_group E'] [semi_normed_group F'] {f' : α → E'} {g' : α → F'} {l : filter α} : ((λ (x : α), ∥f' x∥) =o[l] λ (x : α), ∥g' x∥) → f' =o[l] g'
theorem linear_map.range_prod_eq {R : Type u} {M : Type v} {M₂ : Type w} {M₃ : Type y} [ring R] [add_comm_group M] [add_comm_group M₂] [add_comm_group M₃] [module R M] [module R M₂] [module R M₃] {f : M →ₗ[R] M₂} {g : M →ₗ[R] M₃} (h : f.ker ⊔ g.ker = ⊤) : (f.prod g).range = f.range.prod g.range
theorem probability_theory.ident_distrib.measure_preimage_eq {α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] [measurable_space β] [measurable_space γ] {μ : measure_theory.measure α} {ν : measure_theory.measure β} {f : α → γ} {g : β → γ} (h : probability_theory.ident_distrib f g μ ν) {s : set γ} (hs : measurable_set s) : ⇑μ (f ⁻¹' s) = ⇑ν (g ⁻¹' s)
theorem interval_integral.integral_has_deriv_within_at_of_tendsto_ae_left {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {c : E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set ℝ} [interval_integral.FTC_filter a (nhds_within a s) (nhds_within a t)] (hmeas : strongly_measurable_at_filter f (nhds_within a t) measure_theory.measure_space.volume) (ha : filter.tendsto f (nhds_within a t ⊓ measure_theory.measure_space.volume.ae) (nhds c)) : has_deriv_within_at (λ (u : ℝ), ∫ (x : ℝ) in u..b, f x) (-c) s a
theorem is_pushout.map {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) {W X Y Z : C} {f : W ⟶ X} {g : W ⟶ Y} {h : X ⟶ Z} {i : Y ⟶ Z} [category_theory.limits.preserves_colimit (category_theory.limits.span f g) F] (s : category_theory.is_pushout f g h i) : category_theory.is_pushout (F.map f) (F.map g) (F.map h) (F.map i)
theorem cont_diff_at.to_local_inverse {𝕂 : Type u_6} [is_R_or_C 𝕂] {E' : Type u_7} [normed_group E'] [normed_space 𝕂 E'] {F' : Type u_8} [normed_group F'] [normed_space 𝕂 F'] [complete_space E'] {f : E' → F'} {f' : E' ≃L[𝕂] F'} {a : E'} {n : with_top ℕ} (hf : cont_diff_at 𝕂 n f a) (hf' : has_fderiv_at f ↑f' a) (hn : 1 ≤ n) : cont_diff_at 𝕂 n (hf.local_inverse hf' hn) (f a)
theorem function.surjective.dense_range {β : Type u_2} [topological_space β] {κ : Type u_5} {f : κ → β} (hf : function.surjective f) : dense_range f
theorem category_theory.functor.right_derived_map_eq {C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] [category_theory.abelian C] [category_theory.has_injective_resolutions C] [category_theory.abelian D] (F : C ⥤ D) [F.additive] (n : ℕ) {X Y : C} (f : Y ⟶ X) {P : category_theory.InjectiveResolution X} {Q : category_theory.InjectiveResolution Y} (g : Q.cocomplex ⟶ P.cocomplex) (w : Q.ι ≫ g = (cochain_complex.single₀ C).map f ≫ P.ι) : (F.right_derived n).map f = (F.right_derived_obj_iso n Q).hom ≫ (homology_functor D (complex_shape.up ℕ) n).map ((F.map_homological_complex (complex_shape.up ℕ)).map g) ≫ (F.right_derived_obj_iso n P).inv
theorem basis.card_le_card_of_linear_independent_aux {R : Type u_1} [ring R] [strong_rank_condition R] (n : ℕ) {m : ℕ} (v : fin m → fin n → R) : linear_independent R v → m ≤ n
theorem tendsto_sum_nat_add {α : Type u_1} [add_comm_group α] [topological_space α] [topological_add_group α] [t2_space α] (f : ℕ → α) : filter.tendsto (λ (i : ℕ), ∑' (k : ℕ), f (k + i)) filter.at_top (nhds 0)
theorem upper_semicontinuous_within_at.add' {α : Type u_1} [topological_space α] {x : α} {s : set α} {γ : Type u_4} [linear_ordered_add_comm_monoid γ] [topological_space γ] [order_topology γ] {f g : α → γ} (hf : upper_semicontinuous_within_at f s x) (hg : upper_semicontinuous_within_at g s x) (hcont : continuous_at (λ (p : γ × γ), p.fst + p.snd) (f x, g x)) : upper_semicontinuous_within_at (λ (z : α), f z + g z) s x
theorem algebraic_independent_bounded_of_finset_algebraic_independent_bounded {R : Type u_3} {A : Type u_5} [comm_ring R] [comm_ring A] [algebra R A] {n : ℕ} (H : ∀ (s : finset A), algebraic_independent R (λ (i : ↥s), ↑i) → s.card ≤ n) (s : set A) : algebraic_independent R coe → cardinal.mk ↥s ≤ ↑n
theorem finset.noncomm_sum_union_of_disjoint {α : Type u_1} {β : Type u_2} [add_monoid β] [decidable_eq α] {s t : finset α} (h : disjoint s t) (f : α → β) (comm : ∀ (x : α), x ∈ s ∪ t → ∀ (y : α), y ∈ s ∪ t → add_commute (f x) (f y)) (scomm : (∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → add_commute (f x) (f y)) := _) (tcomm : (∀ (x : α), x ∈ t → ∀ (y : α), y ∈ t → add_commute (f x) (f y)) := _) : (s ∪ t).noncomm_sum f comm = s.noncomm_sum f scomm + t.noncomm_sum f tcomm
theorem uniform_space.complete_of_cauchy_seq_tendsto {α : Type u} [uniform_space α] [(uniformity α).is_countably_generated] (H' : ∀ (u : ℕ → α), cauchy_seq u → (∃ (a : α), filter.tendsto u filter.at_top (nhds a))) : complete_space α
theorem euclidean_geometry.reflection_reflection {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ℝ P) [nonempty ↥s] [complete_space ↥(s.direction)] (p : P) : ⇑(euclidean_geometry.reflection s) (⇑(euclidean_geometry.reflection s) p) = p
theorem polynomial.bernoulli_eq_sub_sum (n : ℕ) : ↑(n.succ) • polynomial.bernoulli n = ⇑(polynomial.monomial n) ↑(n.succ) - (finset.range n).sum (λ (k : ℕ), ↑((n + 1).choose k) • polynomial.bernoulli k)
theorem linear_map.is_Ortho.separating_left_of_not_is_ortho_basis_self {R : Type u_1} {M : Type u_5} {n : Type u_14} [comm_ring R] [add_comm_group M] [module R M] [no_zero_divisors R] {B : M →ₗ[R] M →ₗ[R] R} (v : basis n R M) (hO : B.is_Ortho ⇑v) (h : ∀ (i : n), ¬B.is_ortho (⇑v i) (⇑v i)) : B.separating_left
theorem module.free.rank_matrix' (R : Type u) [ring R] [strong_rank_condition R] (m n : Type v) [fintype m] [fintype n] : module.rank R (matrix m n R) = (cardinal.mk m * cardinal.mk n).lift
theorem add_nonneg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a + b
theorem exists_idempotent_in_compact_subsemigroup {M : Type u_1} [semigroup M] [topological_space M] [t2_space M] (continuous_mul_left : ∀ (r : M), continuous (λ (_x : M), _x * r)) (s : set M) (snemp : s.nonempty) (s_compact : is_compact s) (s_add : ∀ (x : M), x ∈ s → ∀ (y : M), y ∈ s → x * y ∈ s) : ∃ (m : M) (H : m ∈ s), m * m = m
theorem orientation.map_eq_neg_iff_det_neg {R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {ι : Type u_3} [decidable_eq ι] [fintype ι] [finite_dimensional R M] (x : orientation R M ι) (f : M ≃ₗ[R] M) (h : fintype.card ι = finite_dimensional.finrank R M) : ⇑(orientation.map ι f) x = -x ↔ ⇑linear_map.det ↑f < 0
theorem continuous_at_left_of_monotone_on_of_image_mem_nhds_within {α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : monotone_on f s) (hs : s ∈ nhds_within a (set.Iic a)) (hfs : f '' s ∈ nhds_within (f a) (set.Iic (f a))) : continuous_within_at f (set.Iic a) a
theorem mul_left_bound {α : Type u_1} [non_unital_semi_normed_ring α] (x y : α) : ∥⇑(add_monoid_hom.mul_left x) y∥ ≤ ∥x∥ * ∥y∥
theorem colex.singleton_lt_iff_lt {α : Type u_1} [linear_order α] {r s : α} : {r}.to_colex < {s}.to_colex ↔ r < s
theorem Top.presheaf.is_sheaf_punit {X : Top} (F : Top.presheaf (category_theory.discrete punit) X) : F.is_sheaf
theorem complex.differentiable_on_update_lim_of_bdd_above {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] {f : ℂ → E} {s : set ℂ} {c : ℂ} (hc : s ∈ nhds c) (hd : differentiable_on ℂ f (s  {c})) (hb : bdd_above (has_norm.norm ∘ f '' (s  {c}))) : differentiable_on ℂ (function.update f c (lim (nhds_within c {c}ᶜ) f)) s
theorem is_compact.inter_left {α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s) : is_compact (s ∩ t)
theorem dihedral_group.card {n : ℕ} [fact (0 < n)] : fintype.card (dihedral_group n) = 2 * n
theorem exists_compact_superset {α : Type u} [topological_space α] [locally_compact_space α] {K : set α} (hK : is_compact K) : ∃ (K' : set α), is_compact K' ∧ K ⊆ interior K'
theorem finprod_div_distrib {α : Type u_1} {G : Type u_4} [division_comm_monoid G] {f g : α → G} (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) : finprod (λ (i : α), f i / g i) = finprod (λ (i : α), f i) / finprod (λ (i : α), g i)
theorem finset.sum_subtype_eq_sum_filter {β : Type u} {α : Type v} {s : finset α} [add_comm_monoid β] (f : α → β) {p : α → Prop} [decidable_pred p] : (finset.subtype p s).sum (λ (x : subtype p), f ↑x) = (finset.filter p s).sum (λ (x : α), f x)
theorem filter.map_at_top_eq_of_gc {α : Type u_3} {β : Type u_4} [semilattice_sup α] [semilattice_sup β] {f : α → β} (g : β → α) (b' : β) (hf : monotone f) (gc : ∀ (a : α) (b : β), b ≥ b' → (f a ≤ b ↔ a ≤ g b)) (hgi : ∀ (b : β), b ≥ b' → b ≤ f (g b)) : filter.map f filter.at_top = filter.at_top
theorem mul_nonneg_of_three {α : Type u} [linear_ordered_ring α] (a b c : α) : 0 ≤ a * b ∨ 0 ≤ b * c ∨ 0 ≤ c * a
theorem monovary_on.sum_comp_perm_mul_le_sum_mul {ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {s : finset ι} {σ : equiv.perm ι} {f g : ι → α} (hfg : monovary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f (⇑σ i) * g i) ≤ s.sum (λ (i : ι), f i * g i)
theorem class_group.exists_mem_finset_approx' {R : Type u_1} {S : Type u_2} (L : Type u_4) [euclidean_domain R] [comm_ring S] [is_domain S] [field L] [algRL : algebra R L] [algebra R S] [algebra S L] [ist : is_scalar_tower R S L] [iic : is_integral_closure S R L] {abv : absolute_value R ℤ} {ι : Type u_5} [decidable_eq ι] [fintype ι] (bS : basis ι R S) (adm : abv.is_admissible) [infinite R] [decidable_eq R] (h : algebra.is_algebraic R L) (a : S) {b : S} (hb : b ≠ 0) : ∃ (q : S) (r : R) (H : r ∈ class_group.finset_approx bS adm), ⇑abv (⇑(algebra.norm R) (r • a - q * b)) < ⇑abv (⇑(algebra.norm R) b)
theorem bdd_above.union {γ : Type w} [semilattice_sup γ] {s t : set γ} : bdd_above s → bdd_above t → bdd_above (s ∪ t)
theorem image_norm_le_of_norm_deriv_right_lt_deriv_boundary {E : Type u_1} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} {f' : ℝ → E} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : ℝ → ℝ} (ha : ∥f a∥ ≤ B a) (hB : ∀ (x : ℝ), has_deriv_at B (B' x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → ∥f x∥ = B x → ∥f' x∥ < B' x) ⦃x : ℝ⦄ : x ∈ set.Icc a b → ∥f x∥ ≤ B x
theorem bdd_below_union {γ : Type w} [semilattice_inf γ] {s t : set γ} : bdd_below (s ∪ t) ↔ bdd_below s ∧ bdd_below t
theorem category_theory.arrow.square_from_iso_invert {T : Type u} [category_theory.category T] {X Y : T} (i : X ≅ Y) (p : category_theory.arrow T) (sq : category_theory.arrow.mk i.hom ⟶ p) : i.inv ≫ sq.left ≫ p.hom = sq.right
theorem ring.inverse_invertible {α : Type u} [monoid_with_zero α] (x : α) [invertible x] : ring.inverse x = ⅟ x
theorem is_cyclotomic_extension.zeta_primitive_root (n : ℕ+) (A : Type w) (B : Type z) [comm_ring A] [comm_ring B] [algebra A B] [is_cyclotomic_extension {n} A B] [is_domain B] [ne_zero ↑↑n] : is_primitive_root (is_cyclotomic_extension.zeta n A B) ↑n
theorem has_compact_support.continuous_convolution_left_of_integrable {𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G → E} {g : G → E'} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 F] (L : E →L[𝕜] E' →L[𝕜] F) [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ F] [complete_space F] [add_comm_group G] [topological_space G] [topological_add_group G] [borel_space G] [μ.is_add_left_invariant] [μ.is_neg_invariant] [topological_space.second_countable_topology G] (hcf : has_compact_support f) (hf : continuous f) (hg : measure_theory.integrable g μ) : continuous (convolution f g L μ)
theorem lower_semicontinuous_at.add' {α : Type u_1} [topological_space α] {x : α} {γ : Type u_4} [linear_ordered_add_comm_monoid γ] [topological_space γ] [order_topology γ] {f g : α → γ} (hf : lower_semicontinuous_at f x) (hg : lower_semicontinuous_at g x) (hcont : continuous_at (λ (p : γ × γ), p.fst + p.snd) (f x, g x)) : lower_semicontinuous_at (λ (z : α), f z + g z) x
theorem module.free.finrank_pi (R : Type u) [ring R] [strong_rank_condition R] {ι : Type v} [fintype ι] : finite_dimensional.finrank R (ι → R) = fintype.card ι
theorem finset.exists_card_fiber_lt_of_card_lt_mul {α : Type u} {β : Type v} [decidable_eq β] {s : finset α} {t : finset β} {f : α → β} {n : ℕ} (hn : s.card < t.card * n) : ∃ (y : β) (H : y ∈ t), (finset.filter (λ (x : α), f x = y) s).card < n
theorem category_theory.limits.limits_from_equalizers_and_products {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_limits C
theorem finset.sum_smul_const_vsub_eq_neg_weighted_vsub {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (w : ι → k) (p₂ : ι → P) (p₁ : P) (h : s.sum (λ (i : ι), w i) = 0) : s.sum (λ (i : ι), w i • (p₁ -ᵥ p₂ i)) = -⇑(s.weighted_vsub p₂) w
theorem fixing_subgroup_union (M : Type u_1) (α : Type u_2) [group M] [mul_action M α] {s t : set α} : fixing_subgroup M (s ∪ t) = fixing_subgroup M s ⊓ fixing_subgroup M t
theorem monotone.antitone_iterate_of_map_le {α : Type u_1} [preorder α] {f : α → α} {x : α} (hf : monotone f) (hx : f x ≤ x) : antitone (λ (n : ℕ), f^[n] x)
theorem category_theory.limits.has_binary_products_of_has_limit_pair (C : Type u) [category_theory.category C] [∀ {X Y : C}, category_theory.limits.has_limit (category_theory.limits.pair X Y)] : category_theory.limits.has_binary_products C
theorem topological_space.subset_trans {X : Type u_1} [tX : topological_space X] {s t : set X} (ts : t ⊆ s) : subtype.topological_space = topological_space.induced (set.inclusion ts) subtype.topological_space
theorem padic_val_rat.neg {p : ℕ} (q : ℚ) : padic_val_rat p (-q) = padic_val_rat p q
theorem affine_subspace.inter_eq_singleton_of_nonempty_of_is_compl {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s1 s2 : affine_subspace k P} (h1 : ↑s1.nonempty) (h2 : ↑s2.nonempty) (hd : is_compl s1.direction s2.direction) : ∃ (p : P), ↑s1 ∩ ↑s2 = {p}
theorem cont_mdiff_at.comp {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M → M'} {n : with_top ℕ} {E'' : Type u_14} [normed_group E''] [normed_space 𝕜 E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners 𝕜 E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {g : M' → M''} (x : M) (hg : cont_mdiff_at I' I'' n g (f x)) (hf : cont_mdiff_at I I' n f x) : cont_mdiff_at I I'' n (g ∘ f) x
theorem star_convex.affine_preimage {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [ordered_ring 𝕜] [add_comm_group E] [add_comm_group F] [module 𝕜 E] [module 𝕜 F] {x : E} (f : E →ᵃ[𝕜] F) {s : set F} (hs : star_convex 𝕜 (⇑f x) s) : star_convex 𝕜 x (⇑f ⁻¹' s)
theorem antitone.tendsto_alternating_series_of_tendsto_zero {f : ℕ → ℝ} (hfa : antitone f) (hf0 : filter.tendsto f filter.at_top (nhds 0)) : ∃ (l : ℝ), filter.tendsto (λ (n : ℕ), (finset.range (n + 1)).sum (λ (i : ℕ), (-1) ^ i * f i)) filter.at_top (nhds l)
theorem add_submonoid.bsupr_eq_mrange_dfinsupp_sum_add_hom {ι : Type u} {γ : Type w} [dec : decidable_eq ι] (p : ι → Prop) [decidable_pred p] [add_comm_monoid γ] (S : ι → add_submonoid γ) : (⨆ (i : ι) (h : p i), S i) = ((dfinsupp.sum_add_hom (λ (i : ι), (S i).subtype)).comp (dfinsupp.filter_add_monoid_hom (λ (i : ι), ↥(S i)) p)).mrange
theorem finset.filter_false_of_mem {α : Type u_1} {p : α → Prop} [decidable_pred p] {s : finset α} (h : ∀ (x : α), x ∈ s → ¬p x) : finset.filter p s = ∅
theorem nat.eq_zero_of_dvd_of_lt {a b : ℕ} (w : a ∣ b) (h : b < a) : b = 0
theorem generalized_continued_fraction.of_denom_mono {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] : (generalized_continued_fraction.of v).denominators n ≤ (generalized_continued_fraction.of v).denominators (n + 1)
theorem one_hom.coe_inj {M : Type u_3} {N : Type u_4} [has_one M] [has_one N] ⦃f g : one_hom M N⦄ (h : ⇑f = ⇑g) : f = g
theorem add_commute.eq {S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : a + b = b + a
theorem generate_from_eq_pi {ι : Type u_1} {α : ι → Type u_3} [fintype ι] [h : Π (i : ι), measurable_space (α i)] {C : Π (i : ι), set (set (α i))} (hC : ∀ (i : ι), measurable_space.generate_from (C i) = h i) (h2C : ∀ (i : ι), is_countably_spanning (C i)) : measurable_space.generate_from (set.univ.pi '' set.univ.pi C) = measurable_space.pi
theorem span_fourier_Lp_closure_eq_top {p : ennreal} [fact (1 ≤ p)] (hp : p ≠ ⊤) : (submodule.span ℂ (set.range (fourier_Lp p))).topological_closure = ⊤
theorem is_lower_set.to_dual {α : Type u_1} [has_le α] {s : set αᵒᵈ} : is_lower_set s → is_upper_set (⇑order_dual.to_dual ⁻¹' s)
theorem ultrafilter_extend_eq_iff {α : Type u} {γ : Type u_1} [topological_space γ] [t2_space γ] [compact_space γ] {f : α → γ} {b : ultrafilter α} {c : γ} : ultrafilter.extend f b = c ↔ ↑(ultrafilter.map f b) ≤ nhds c
theorem polynomial.order_of_root_cyclotomic_dvd {n : ℕ} (hpos : 0 < n) {p : ℕ} [fact (nat.prime p)] {a : ℕ} (hroot : (polynomial.cyclotomic n (zmod p)).is_root (⇑(nat.cast_ring_hom (zmod p)) a)) : order_of (zmod.unit_of_coprime a _) ∣ n
theorem continuous_at_of_monotone_on_of_closure_image_mem_nhds {α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : monotone_on f s) (hs : s ∈ nhds a) (hfs : closure (f '' s) ∈ nhds (f a)) : continuous_at f a
theorem monoid_algebra.of_mem_span_of_iff {R : Type u_1} {M : Type u_2} [comm_ring R] [comm_monoid M] [nontrivial R] {m : M} {S : set M} : ⇑(monoid_algebra.of R M) m ∈ submodule.span R (⇑(monoid_algebra.of R M) '' S) ↔ m ∈ S
theorem geom_gold_is_sol_fib_rec  : fib_rec.is_solution (has_pow.pow golden_ratio)
theorem ideal.ideal_prod_eq {R : Type u} {S : Type v} [ring R] [ring S] (I : ideal (R × S)) : I = (ideal.map (ring_hom.fst R S) I).prod (ideal.map (ring_hom.snd R S) I)
theorem tangent_cone_at.lim_zero {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {y : E} {α : Type u_3} (l : filter α) {c : α → 𝕜} {d : α → E} (hc : filter.tendsto (λ (n : α), ∥c n∥) l filter.at_top) (hd : filter.tendsto (λ (n : α), c n • d n) l (nhds y)) : filter.tendsto d l (nhds 0)
theorem Top.presheaf.covering_of_presieve.first_obj_iso_comp_right_res_eq {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) (U : topological_space.opens ↥X) (R : category_theory.presieve U) : category_theory.presheaf.second_map R F ≫ (Top.presheaf.covering_of_presieve.second_obj_iso_pi_inters F U R).hom = (Top.presheaf.covering_of_presieve.first_obj_iso_pi_opens F U R).hom ≫ Top.presheaf.sheaf_condition_equalizer_products.right_res F (Top.presheaf.covering_of_presieve U R)
theorem metric.diam_le_of_forall_dist_le_of_nonempty {α : Type u} [pseudo_metric_space α] {s : set α} (hs : s.nonempty) {C : ℝ} (h : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → has_dist.dist x y ≤ C) : metric.diam s ≤ C
theorem box_integral.prepartition.bUnion_index_of_mem {ι : Type u_1} {I J : box_integral.box ι} (π : box_integral.prepartition I) {πi : Π (J : box_integral.box ι), box_integral.prepartition J} (hJ : J ∈ π) {J' : box_integral.box ι} (hJ' : J' ∈ πi J) : π.bUnion_index πi J' = J
theorem summable_one_div_pow_of_le {m : ℝ} {f : ℕ → ℕ} (hm : 1 < m) (fi : ∀ (i : ℕ), i ≤ f i) : summable (λ (i : ℕ), 1 / m ^ f i)
theorem set.inv_on.bij_on {α : Type u} {β : Type v} {s : set α} {t : set β} {f : α → β} {f' : β → α} (h : set.inv_on f' f s t) (hf : set.maps_to f s t) (hf' : set.maps_to f' t s) : set.bij_on f s t
theorem finset.sup_indep.sup {α : Type u_1} {ι : Type u_3} {ι' : Type u_4} [distrib_lattice α] [order_bot α] [decidable_eq ι] {s : finset ι'} {g : ι' → finset ι} {f : ι → α} (hs : s.sup_indep (λ (i : ι'), (g i).sup f)) (hg : ∀ (i' : ι'), i' ∈ s → (g i').sup_indep f) : (s.sup g).sup_indep f
theorem exp_add_of_commute_of_mem_ball {𝕂 : Type u_1} {𝔸 : Type u_2} [nondiscrete_normed_field 𝕂] [normed_ring 𝔸] [normed_algebra 𝕂 𝔸] [complete_space 𝔸] [char_zero 𝕂] {x y : 𝔸} (hxy : commute x y) (hx : x ∈ emetric.ball 0 (exp_series 𝕂 𝔸).radius) (hy : y ∈ emetric.ball 0 (exp_series 𝕂 𝔸).radius) : exp 𝕂 (x + y) = exp 𝕂 x * exp 𝕂 y
theorem probability_theory.indep_fun_iff_integral_comp_mul {α : Type u_1} {mα : measurable_space α} {μ : measure_theory.measure α} [measure_theory.is_finite_measure μ] {β : Type u_2} {β' : Type u_3} {mβ : measurable_space β} {mβ' : measurable_space β'} {f : α → β} {g : α → β'} {hfm : measurable f} {hgm : measurable g} : probability_theory.indep_fun f g μ ↔ ∀ {φ : β → ℝ} {ψ : β' → ℝ}, measurable φ → measurable ψ → measure_theory.integrable (φ ∘ f) μ → measure_theory.integrable (ψ ∘ g) μ → measure_theory.integral μ (φ ∘ f * ψ ∘ g) = measure_theory.integral μ (φ ∘ f) * measure_theory.integral μ (ψ ∘ g)
theorem nat.filter_Ico_card_eq_of_periodic (n a : ℕ) (p : ℕ → Prop) [decidable_pred p] (pp : function.periodic p a) : (finset.filter p (finset.Ico n (n + a))).card = nat.count p a
theorem local_homeomorph.is_image.symm_preimage_eq' {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {e : local_homeomorph α β} {s : set α} {t : set β} : e.is_image s t → e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' (e.to_local_equiv.source ∩ s) = e.to_local_equiv.target ∩ t
theorem polynomial.sum_roots_eq_next_coeff_of_monic_of_split {K : Type v} [field K] {P : polynomial K} (hmo : P.monic) (hP : polynomial.splits (ring_hom.id K) P) : P.next_coeff = -P.roots.sum
theorem metric.bounded_ball {α : Type u} [pseudo_metric_space α] {x : α} {r : ℝ} : metric.bounded (metric.ball x r)
theorem has_deriv_at_iff_has_fderiv_at {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {F : Type v} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {x : 𝕜} {f' : F} : has_deriv_at f f' x ↔ has_fderiv_at f (1.smul_right f') x
theorem multilinear_map.norm_image_sub_le_of_bound' {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : multilinear_map 𝕜 E G) {C : ℝ} (hC : 0 ≤ C) (H : ∀ (m : Π (i : ι), E i), ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : ι), ∥m i∥)) (m₁ m₂ : Π (i : ι), E i) : ∥⇑f m₁ - ⇑f m₂∥ ≤ C * finset.univ.sum (λ (i : ι), finset.univ.prod (λ (j : ι), ite (j = i) ∥m₁ i - m₂ i∥ (linear_order.max ∥m₁ j∥ ∥m₂ j∥)))
theorem local_equiv.is_image.of_symm_preimage_eq {α : Type u_1} {β : Type u_2} {e : local_equiv α β} {s : set α} {t : set β} : e.target ∩ ⇑(e.symm) ⁻¹' s = e.target ∩ t → e.is_image s t
theorem linear_map.trace_eq_contract (R : Type u_1) [comm_ring R] (M : Type u_2) [add_comm_group M] [module R M] [module.free R M] [module.finite R M] [nontrivial R] : (linear_map.trace R M).comp (dual_tensor_hom R M M) = contract_left R M
theorem finset.mem_up_shadow_iff {α : Type u_1} [decidable_eq α] [fintype α] {𝒜 : finset (finset α)} {s : finset α} : s ∈ 𝒜.up_shadow ↔ ∃ (t : finset α) (H : t ∈ 𝒜) (a : α) (H : a ∉ t), has_insert.insert a t = s
theorem topological_space.compacts.equiv_to_fun_val {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α ≃ₜ β) (K : topological_space.compacts α) : (⇑(topological_space.compacts.equiv f) K).carrier = ⇑(f.symm) ⁻¹' K.carrier
theorem coe_fn_coe_base' {α : Sort u_1} {β : Sort u_2} {γ : out_param (Sort u_3)} [has_coe α β] [has_coe_to_fun β (λ (_x : β), γ)] (x : α) : ⇑x = ⇑↑x
theorem nat.factors_mul_to_finset {a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0) : (a * b).factors.to_finset = a.factors.to_finset ∪ b.factors.to_finset
theorem set.Ioi_subset_Ioi {α : Type u_1} [preorder α] {a b : α} (h : a ≤ b) : set.Ioi b ⊆ set.Ioi a
theorem linear_order.strict_convex_on_of_lt {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [ordered_add_comm_monoid β] [module 𝕜 E] [module 𝕜 β] [linear_order E] {s : set E} {f : E → β} (hs : convex 𝕜 s) (hf : ∀ ⦃x y : E⦄, x ∈ s → y ∈ s → x < y → ∀ ⦃a b : 𝕜⦄, 0 < a → 0 < b → a + b = 1 → f (a • x + b • y) < a • f x + b • f y) : strict_convex_on 𝕜 s f
theorem mul_action.card_eq_sum_card_group_div_card_stabilizer' (α : Type u) (β : Type v) [group α] [mul_action α β] [fintype α] [fintype β] [fintype (quotient (mul_action.orbit_rel α β))] [Π (b : β), fintype ↥(mul_action.stabilizer α b)] {φ : quotient (mul_action.orbit_rel α β) → β} (hφ : function.left_inverse quotient.mk' φ) : fintype.card β = finset.univ.sum (λ (ω : quotient (mul_action.orbit_rel α β)), fintype.card α / fintype.card ↥(mul_action.stabilizer α (φ ω)))
theorem antitone_on.dual_left {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s : set α} : antitone_on f s → monotone_on (f ∘ ⇑order_dual.of_dual) s
theorem has_sbtw.sbtw.cyclic_left {α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : has_sbtw.sbtw b c a
theorem interval_integral.integral_has_deriv_at_of_tendsto_ae_left {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {c : E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (ha : filter.tendsto f (nhds a ⊓ measure_theory.measure_space.volume.ae) (nhds c)) : has_deriv_at (λ (u : ℝ), ∫ (x : ℝ) in u..b, f x) (-c) a
theorem filter.tendsto.at_bot_mul_const' {α : Type u_1} {R : Type u_2} {l : filter α} {f : α → R} {r : R} [linear_ordered_ring R] [archimedean R] (hr : 0 < r) (hf : filter.tendsto f l filter.at_bot) : filter.tendsto (λ (x : α), f x * r) l filter.at_bot
theorem set.image2_image_left_anticomm {α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {s : set α} {t : set β} {f : α' → β → γ} {g : α → α'} {f' : β → α → δ} {g' : δ → γ} (h_left_anticomm : ∀ (a : α) (b : β), f (g a) b = g' (f' b a)) : set.image2 f (g '' s) t = g' '' set.image2 f' t s
theorem intermediate_value_interval {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {δ : Type u_1} [linear_order δ] [topological_space δ] [order_closed_topology δ] {a b : α} {f : α → δ} (hf : continuous_on f (set.interval a b)) : set.interval (f a) (f b) ⊆ f '' set.interval a b
theorem pnat.exists_eq_succ_of_ne_one {n : ℕ+} (h1 : n ≠ 1) : ∃ (k : ℕ+), n = k + 1
theorem differentiable_on.mdifferentiable_on {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {f : E → E'} {s : set E} : differentiable_on 𝕜 f s → mdifferentiable_on (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f s
theorem submodule.finrank_quotient_add_finrank {K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (s : submodule K V) : finite_dimensional.finrank K (V ⧸ s) + finite_dimensional.finrank K ↥s = finite_dimensional.finrank K V
theorem cocompact_map.compact_preimage {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [t2_space β] (f : cocompact_map α β) ⦃s : set β⦄ (hs : is_compact s) : is_compact (⇑f ⁻¹' s)
theorem local_homeomorph.continuous_within_at_iff_continuous_within_at_comp_right {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] (e : local_homeomorph α β) {f : β → γ} {s : set β} {x : β} (h : x ∈ e.to_local_equiv.target) : continuous_within_at f s x ↔ continuous_within_at (f ∘ ⇑e) (⇑e ⁻¹' s) (⇑(e.symm) x)
theorem minpoly.ne_zero {A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] {x : B} [nontrivial A] (hx : is_integral A x) : minpoly A x ≠ 0
theorem set.mem_bUnion {α : Type u_1} {β : Type u_2} {s : set α} {t : α → set β} {x : α} {y : β} (xs : x ∈ s) (ytx : y ∈ t x) : y ∈ ⋃ (x : α) (H : x ∈ s), t x
theorem witt_structure_rat_rec (p : ℕ) {idx : Type u_2} [hp : fact (nat.prime p)] (Φ : mv_polynomial idx ℚ) (n : ℕ) : witt_structure_rat p Φ n = ⇑mv_polynomial.C (1 / ↑p ^ n) * (⇑(mv_polynomial.bind₁ (λ (b : idx), ⇑(mv_polynomial.rename (λ (i : ℕ), (b, i))) (witt_polynomial p ℚ n))) Φ - (finset.range n).sum (λ (i : ℕ), ⇑mv_polynomial.C (↑p ^ i) * witt_structure_rat p Φ i ^ p ^ (n - i)))
theorem measure_theory.measure_lt_top_of_is_compact_of_is_add_left_invariant {G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {μ : measure_theory.measure G} [add_group G] [topological_add_group G] [μ.is_add_left_invariant] (U : set G) (hU : is_open U) (h'U : U.nonempty) (h : ⇑μ U ≠ ⊤) {K : set G} (hK : is_compact K) : ⇑μ K < ⊤
theorem combo_mem_ball_of_ne {E : Type u_2} [normed_group E] [normed_space ℝ E] [strict_convex_space ℝ E] {x y z : E} {a b r : ℝ} (hx : x ∈ metric.closed_ball z r) (hy : y ∈ metric.closed_ball z r) (hne : x ≠ y) (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) : a • x + b • y ∈ metric.ball z r
theorem continuous_at.snd {α : Type u} {β : Type v} {γ : Type u_1} [topological_space α] [topological_space β] [topological_space γ] {f : α → β × γ} {x : α} (hf : continuous_at f x) : continuous_at (λ (a : α), (f a).snd) x
theorem affine_map.map_vadd {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] (f : P1 →ᵃ[k] P2) (p : P1) (v : V1) : ⇑f (v +ᵥ p) = ⇑(f.linear) v +ᵥ ⇑f p
theorem linear_map.separating_right_iff_flip_ker_eq_bot {R : Type u_1} {R₁ : Type u_2} {R₂ : Type u_3} {M₁ : Type u_6} {M₂ : Type u_7} [comm_semiring R] [comm_semiring R₁] [add_comm_monoid M₁] [module R₁ M₁] [comm_semiring R₂] [add_comm_monoid M₂] [module R₂ M₂] {I₁ : R₁ →+* R} {I₂ : R₂ →+* R} {B : M₁ →ₛₗ[I₁] M₂ →ₛₗ[I₂] R} : B.separating_right ↔ B.flip.ker = ⊥
theorem category_theory.is_iso_of_regular_mono_of_epi {C : Type u₁} [category_theory.category C] {X Y : C} (f : X ⟶ Y) [category_theory.regular_mono f] [e : category_theory.epi f] : category_theory.is_iso f
theorem linear_map.adjoint_comp {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [inner_product_space 𝕜 F] [inner_product_space 𝕜 G] [finite_dimensional 𝕜 E] [finite_dimensional 𝕜 F] [finite_dimensional 𝕜 G] (A : F →ₗ[𝕜] G) (B : E →ₗ[𝕜] F) : ⇑linear_map.adjoint (A.comp B) = (⇑linear_map.adjoint B).comp (⇑linear_map.adjoint A)
theorem comm_group.nilpotency_class_le_one {G : Type u_1} [comm_group G] : group.nilpotency_class G ≤ 1
theorem category_theory.limits.types.coequalizer_preimage_image_eq_of_preimage_eq {X Y Z : Type u} (f g : X ⟶ Y) (π : Y ⟶ Z) (e : f ≫ π = g ≫ π) (h : category_theory.limits.is_colimit (category_theory.limits.cofork.of_π π e)) (U : set Y) (H : f ⁻¹' U = g ⁻¹' U) : π ⁻¹' (π '' U) = U
theorem neg_lt_of_neg_lt {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : -a < b → -b < a
theorem inner_sum_smul_sum_smul_of_sum_eq_zero {F : Type u_3} [inner_product_space ℝ F] {ι₁ : Type u_1} {s₁ : finset ι₁} {w₁ : ι₁ → ℝ} (v₁ : ι₁ → F) (h₁ : s₁.sum (λ (i : ι₁), w₁ i) = 0) {ι₂ : Type u_2} {s₂ : finset ι₂} {w₂ : ι₂ → ℝ} (v₂ : ι₂ → F) (h₂ : s₂.sum (λ (i : ι₂), w₂ i) = 0) : has_inner.inner (s₁.sum (λ (i₁ : ι₁), w₁ i₁ • v₁ i₁)) (s₂.sum (λ (i₂ : ι₂), w₂ i₂ • v₂ i₂)) = -s₁.sum (λ (i₁ : ι₁), s₂.sum (λ (i₂ : ι₂), w₁ i₁ * w₂ i₂ * (∥v₁ i₁ - v₂ i₂∥ * ∥v₁ i₁ - v₂ i₂∥))) / 2
theorem convex_on_norm {E : Type u_2} [semi_normed_group E] [normed_space ℝ E] {s : set E} (hs : convex ℝ s) : convex_on ℝ s has_norm.norm
theorem covby.to_dual {α : Type u_1} [has_lt α] {a b : α} : a ⋖ b → ⇑order_dual.to_dual b ⋖ ⇑order_dual.to_dual a
theorem is_localization.lift_mem_adjoin_finset_integer_multiple {R S : Type u} [comm_ring R] [comm_ring S] (M : submonoid R) (S' : Type u) [comm_ring S'] [algebra S S'] [algebra R S] [algebra R S'] [is_scalar_tower R S S'] [is_localization (submonoid.map ↑(algebra_map R S) M) S'] (x : S) (s : finset S') (hx : ⇑(algebra_map S S') x ∈ algebra.adjoin R ↑s) : ∃ (m : ↥M), m • x ∈ algebra.adjoin R ↑(is_localization.finset_integer_multiple (submonoid.map ↑(algebra_map R S) M) s)
theorem finset.le_sum_of_subadditive_on_pred {ι : Type u_1} {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [ordered_add_comm_monoid N] (f : M → N) (p : M → Prop) (h_one : f 0 = 0) (h_mul : ∀ (x y : M), p x → p y → f (x + y) ≤ f x + f y) (hp_mul : ∀ (x y : M), p x → p y → p (x + y)) (g : ι → M) {s : finset ι} (hs : ∀ (i : ι), i ∈ s → p (g i)) : f (s.sum (λ (i : ι), g i)) ≤ s.sum (λ (i : ι), f (g i))
theorem add_submonoid.localization_map.of_add_equiv_of_dom_id {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] (f : S.localization_map N) : f.of_add_equiv_of_dom _ = f
theorem polynomial.degree_cyclotomic_pos (n : ℕ) (R : Type u_1) (hpos : 0 < n) [ring R] [nontrivial R] : 0 < (polynomial.cyclotomic n R).degree
theorem finsum_mem_union' {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} {s t : set α} (hst : disjoint s t) (hs : (s ∩ function.support f).finite) (ht : (t ∩ function.support f).finite) : finsum (λ (i : α), finsum (λ (H : i ∈ s ∪ t), f i)) = finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) + finsum (λ (i : α), finsum (λ (H : i ∈ t), f i))
theorem convex.norm_image_sub_le_of_norm_fderiv_le' {E : Type u_1} [normed_group E] [normed_space ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_space 𝕜 E] [normed_group G] [normed_space 𝕜 G] {f : E → G} {C : ℝ} {s : set E} {x y : E} {φ : E →L[𝕜] G} (hf : ∀ (x : E), x ∈ s → differentiable_at 𝕜 f x) (bound : ∀ (x : E), x ∈ s → ∥fderiv 𝕜 f x - φ∥ ≤ C) (hs : convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∥f y - f x - ⇑φ (y - x)∥ ≤ C * ∥y - x∥
theorem seminorm.convex_ball {𝕜 : Type u_3} {E : Type u_4} [normed_field 𝕜] [add_comm_group E] [normed_space ℝ 𝕜] [module 𝕜 E] [module ℝ E] [is_scalar_tower ℝ 𝕜 E] (p : seminorm 𝕜 E) (x : E) (r : ℝ) : convex ℝ (p.ball x r)
theorem measure_theory.measure_Inter_eq_infi {α : Type u_1} {ι : Type u_5} {m : measurable_space α} {μ : measure_theory.measure α} [encodable ι] {s : ι → set α} (h : ∀ (i : ι), measurable_set (s i)) (hd : directed superset s) (hfin : ∃ (i : ι), ⇑μ (s i) ≠ ⊤) : ⇑μ (⋂ (i : ι), s i) = ⨅ (i : ι), ⇑μ (s i)
theorem parallelogram_law {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x y : E} : has_inner.inner (x + y) (x + y) + has_inner.inner (x - y) (x - y) = 2 * (has_inner.inner x x + has_inner.inner y y)
theorem category_theory.grothendieck_topology.pullback_close {C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) {X Y : C} (f : Y ⟶ X) (S : category_theory.sieve X) : J₁.close (category_theory.sieve.pullback f S) = category_theory.sieve.pullback f (J₁.close S)
theorem bornology.is_cobounded.of_compl {α : Type u_2} [bornology α] {s : set α} : bornology.is_cobounded sᶜ → bornology.is_bounded s
theorem witt_vector.verschiebung_zmod {p : ℕ} [hp : fact (nat.prime p)] (x : witt_vector p (zmod p)) : ⇑witt_vector.verschiebung x = x * ↑p
theorem affine.simplex.circumcenter_eq_of_range_eq {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} {s₁ s₂ : affine.simplex ℝ P n} (h : set.range s₁.points = set.range s₂.points) : s₁.circumcenter = s₂.circumcenter
theorem affine_independent.affine_span_disjoint_of_disjoint {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} [nontrivial k] {p : ι → P} (ha : affine_independent k p) {s1 s2 : set ι} (hd : s1 ∩ s2 = ∅) : ↑(affine_span k (p '' s1)) ∩ ↑(affine_span k (p '' s2)) = ∅
theorem exp_add {𝕂 : Type u_1} {𝔸 : Type u_2} [is_R_or_C 𝕂] [normed_comm_ring 𝔸] [normed_algebra 𝕂 𝔸] [complete_space 𝔸] {x y : 𝔸} : exp 𝕂 (x + y) = exp 𝕂 x * exp 𝕂 y
theorem measure_theory.is_locally_finite_measure_of_is_finite_measure_on_compacts {α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} [topological_space α] [locally_compact_space α] [measure_theory.is_finite_measure_on_compacts μ] : measure_theory.is_locally_finite_measure μ
theorem fin.update_cons_zero {n : ℕ} {α : fin (n + 1) → Type u} (x : α 0) (p : Π (i : fin n), α i.succ) (z : α 0) : function.update (fin.cons x p) 0 z = fin.cons z p
theorem finset.induction_on_pi {ι : Type u_1} {α : ι → Type u_2} [fintype ι] [decidable_eq ι] [Π (i : ι), decidable_eq (α i)] {p : (Π (i : ι), finset (α i)) → Prop} (f : Π (i : ι), finset (α i)) (h0 : p (λ (_x : ι), ∅)) (step : ∀ (g : Π (i : ι), finset (α i)) (i : ι) (x : α i), x ∉ g i → p g → p (function.update g i (has_insert.insert x (g i)))) : p f
theorem multiset.count_map_eq_count' {α : Type u_1} {β : Type u_2} [decidable_eq α] [decidable_eq β] (f : α → β) (s : multiset α) (hf : function.injective f) (x : α) : multiset.count (f x) (multiset.map f s) = multiset.count x s
theorem submodule.orthogonal_le {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K₁ K₂ : submodule 𝕜 E} (h : K₁ ≤ K₂) : K₂ᗮ ≤ K₁ᗮ
theorem list.prod_update_nth' {G : Type u_7} [comm_group G] (L : list G) (n : ℕ) (a : G) : (L.update_nth n a).prod = L.prod * dite (n < L.length) (λ (hn : n < L.length), (L.nth_le n hn)⁻¹ * a) (λ (hn : ¬n < L.length), 1)
theorem affine_independent.units_line_map {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} {p : ι → P} (hp : affine_independent k p) (j : ι) (w : ι → kˣ) : affine_independent k (λ (i : ι), ⇑(affine_map.line_map (p j) (p i)) ↑(w i))
theorem finset.nonempty.inv {α : Type u_2} [decidable_eq α] [has_inv α] {s : finset α} : s⁻¹.nonempty → s.nonempty
theorem has_fderiv_within_at.comp_has_deriv_within_at {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {F : Type v} [normed_group F] [normed_space 𝕜 F] {E : Type w} [normed_group E] [normed_space 𝕜 E] {f : 𝕜 → F} {f' : F} (x : 𝕜) {s : set 𝕜} {l : F → E} {l' : F →L[𝕜] E} {t : set F} (hl : has_fderiv_within_at l l' t (f x)) (hf : has_deriv_within_at f f' s x) (hst : set.maps_to f s t) : has_deriv_within_at (l ∘ f) (⇑l' f') s x
theorem nndist_edist {α : Type u} [pseudo_metric_space α] (x y : α) : has_nndist.nndist x y = (has_edist.edist x y).to_nnreal
theorem matrix.mv_polynomial_X_map_matrix_aeval {m : Type u_1} (R : Type u_3) {S : Type u_4} [fintype m] [decidable_eq m] [comm_semiring R] [comm_semiring S] [algebra R S] (A : matrix m m S) : ⇑((mv_polynomial.aeval (λ (p : m × m), A p.fst p.snd)).map_matrix) (matrix.mv_polynomial_X m m R) = A
theorem subsingleton_iff_zero_eq_one {M₀ : Type u_1} [mul_zero_one_class M₀] : 0 = 1 ↔ subsingleton M₀
theorem cardinal.mul_eq_self {c : cardinal} (h : cardinal.aleph_0 ≤ c) : c * c = c
theorem phragmen_lindelof.is_O_sub_exp_rpow {E : Type u_1} [normed_group E] {a : ℝ} {f g : ℂ → E} {l : filter ℂ} (hBf : ∃ (c : ℝ) (H : c < a) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ l] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hBg : ∃ (c : ℝ) (H : c < a) (B : ℝ), g =O[filter.comap complex.abs filter.at_top ⊓ l] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) : ∃ (c : ℝ) (H : c < a) (B : ℝ), (f - g) =O[filter.comap complex.abs filter.at_top ⊓ l] λ (z : ℂ), real.exp (B * complex.abs z ^ c)
theorem filter.eventually.set_eq {α : Type u} {s t : set α} {l : filter α} : (∀ᶠ (x : α) in l, x ∈ s ↔ x ∈ t) → s =ᶠ[l] t
theorem strict_mono_on.continuous_at_left_of_closure_image_mem_nhds_within {α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_on f s) (hs : s ∈ nhds_within a (set.Iic a)) (hfs : closure (f '' s) ∈ nhds_within (f a) (set.Iic (f a))) : continuous_within_at f (set.Iic a) a
theorem cont_diff_bump_of_inner.normed_convolution_eq_right {G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G → E'} [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ E'] [inner_product_space ℝ G] [complete_space E'] {φ : cont_diff_bump_of_inner 0} [borel_space G] [measure_theory.is_locally_finite_measure μ] [μ.is_open_pos_measure] [finite_dimensional ℝ G] {x₀ : G} (hg : ∀ (x : G), x ∈ metric.ball x₀ φ.R → g x = g x₀) : convolution (φ.normed μ) g (continuous_linear_map.lsmul ℝ ℝ) μ x₀ = g x₀
theorem CompHaus.is_closed_map {X Y : CompHaus} (f : X ⟶ Y) : is_closed_map ⇑f
theorem mul_equiv.map_div {G : Type u_10} {H : Type u_11} [group G] [division_monoid H] (h : G ≃* H) (x y : G) : ⇑h (x / y) = ⇑h x / ⇑h y
theorem local_equiv.eq_on_source.source_eq {α : Type u_1} {β : Type u_2} {e e' : local_equiv α β} (h : e ≈ e') : e.source = e'.source
theorem is_preconnected.intermediate_value₂ {X : Type u} {α : Type v} [topological_space X] [linear_order α] [topological_space α] [order_closed_topology α] {s : set X} (hs : is_preconnected s) {a b : X} (ha : a ∈ s) (hb : b ∈ s) {f g : X → α} (hf : continuous_on f s) (hg : continuous_on g s) (ha' : f a ≤ g a) (hb' : g b ≤ f b) : ∃ (x : X) (H : x ∈ s), f x = g x
theorem complex.continuous_at_cpow_const_of_re_pos {z w : ℂ} (hz : 0 ≤ z.re ∨ z.im ≠ 0) (hw : 0 < w.re) : continuous_at (λ (x : ℂ), x ^ w) z
theorem interval_integral.integral_eq_sub_of_has_deriv_at_of_le {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} {f' : ℝ → E} (hab : a ≤ b) (hcont : continuous_on f (set.Icc a b)) (hderiv : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x) (hint : interval_integrable f' measure_theory.measure_space.volume a b) : ∫ (y : ℝ) in a..b, f' y = f b - f a
theorem measure_theory.measure.ext_of_Ioc {α : Type u_1} [topological_space α] {m : measurable_space α} [topological_space.second_countable_topology α] [conditionally_complete_linear_order α] [order_topology α] [borel_space α] [no_min_order α] (μ ν : measure_theory.measure α) [measure_theory.is_locally_finite_measure μ] (h : ∀ ⦃a b : α⦄, a < b → ⇑μ (set.Ioc a b) = ⇑ν (set.Ioc a b)) : μ = ν
theorem measure_theory.conservative.exists_gt_measure_inter_ne_zero {α : Type u_2} [measurable_space α] {f : α → α} {s : set α} {μ : measure_theory.measure α} (hf : measure_theory.conservative f μ) (hs : measurable_set s) (h0 : ⇑μ s ≠ 0) (N : ℕ) : ∃ (m : ℕ) (H : m > N), ⇑μ (s ∩ f^[m] ⁻¹' s) ≠ 0
theorem continuous_inf_dom_left₂ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {f : α → β → γ} {ta1 ta2 : topological_space α} {tb1 tb2 : topological_space β} {tc1 : topological_space γ} (h : continuous (λ (p : α × β), f p.fst p.snd)) : continuous (λ (p : α × β), f p.fst p.snd)
theorem box_integral.prepartition.is_partition.exists_split_many_le {ι : Type u_1} [fintype ι] {I : box_integral.box ι} {π : box_integral.prepartition I} (h : π.is_partition) : ∃ (s : finset (ι × ℝ)), box_integral.prepartition.split_many I s ≤ π
theorem category_theory.cocone_of_representable_naturality {C : Type u₁} [category_theory.small_category C] {P₁ P₂ : Cᵒᵖ ⥤ Type u₁} (α : P₁ ⟶ P₂) (j : (P₁.elements)ᵒᵖ) : (category_theory.cocone_of_representable P₁).ι.app j ≫ α = (category_theory.cocone_of_representable P₂).ι.app ((category_theory.category_of_elements.map α).op.obj j)
theorem interval_integral.measure_integral_sub_integral_sub_linear_is_o_of_tendsto_ae {ι : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} {ca cb : E} {la la' lb lb' : filter ℝ} {lt : filter ι} {μ : measure_theory.measure ℝ} {ua va ub vb : ι → ℝ} [interval_integral.FTC_filter a la la'] [interval_integral.FTC_filter b lb lb'] [measure_theory.is_locally_finite_measure μ] (hab : interval_integrable f μ a b) (hmeas_a : strongly_measurable_at_filter f la' μ) (hmeas_b : strongly_measurable_at_filter f lb' μ) (ha_lim : filter.tendsto f (la' ⊓ μ.ae) (nhds ca)) (hb_lim : filter.tendsto f (lb' ⊓ μ.ae) (nhds cb)) (hua : filter.tendsto ua lt la) (hva : filter.tendsto va lt la) (hub : filter.tendsto ub lt lb) (hvb : filter.tendsto vb lt lb) : (λ (t : ι), ∫ (x : ℝ) in va t..vb t, f x ∂μ - ∫ (x : ℝ) in ua t..ub t, f x ∂μ - (∫ (x : ℝ) in ub t..vb t, cb ∂μ - ∫ (x : ℝ) in ua t..va t, ca ∂μ)) =o[lt] λ (t : ι), ∥∫ (x : ℝ) in ua t..va t, 1 ∂μ∥ + ∥∫ (x : ℝ) in ub t..vb t, 1 ∂μ∥
theorem generate_from_pi {ι : Type u_1} {α : ι → Type u_3} [fintype ι] [Π (i : ι), measurable_space (α i)] : measurable_space.generate_from (set.univ.pi '' set.univ.pi (λ (i : ι), {s : set (α i) | measurable_set s})) = measurable_space.pi
theorem continuous_map.exists_extension_of_closed_embedding {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] (f : C(X, ℝ)) (e : X → Y) (he : closed_embedding e) : ∃ (g : C(Y, ℝ)), ⇑g ∘ e = ⇑f
theorem nat.prime.multiplicity_factorial {p : ℕ} (hp : nat.prime p) {n b : ℕ} : nat.log p n < b → multiplicity p n.factorial = ↑((finset.Ico 1 b).sum (λ (i : ℕ), n / p ^ i))
theorem nilpotent_iff_finite_ascending_central_series (G : Type u_1) [group G] : group.is_nilpotent G ↔ ∃ (n : ℕ) (H : ℕ → subgroup G), is_ascending_central_series H ∧ H n = ⊤
theorem finprod_mem_mul_distrib {α : Type u_1} {M : Type u_5} [comm_monoid M] {f g : α → M} {s : set α} (hs : s.finite) : finprod (λ (i : α), finprod (λ (H : i ∈ s), f i * g i)) = finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ s), g i))
theorem linear_map.re_inner_adjoint_mul_self_nonneg {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [finite_dimensional 𝕜 E] (T : E →ₗ[𝕜] E) (x : E) : 0 ≤ ⇑is_R_or_C.re (has_inner.inner x (⇑(⇑linear_map.adjoint T * T) x))
theorem normed_space.exists_lt_norm (𝕜 : Type u_5) (E : Type u_6) [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [nontrivial E] (c : ℝ) : ∃ (x : E), c < ∥x∥
theorem cont_diff_on_iff_continuous_on_differentiable_on_deriv {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {s : set 𝕜} {n : with_top ℕ} (hs : unique_diff_on 𝕜 s) : cont_diff_on 𝕜 n f s ↔ (∀ (m : ℕ), ↑m ≤ n → continuous_on (iterated_deriv_within m f s) s) ∧ ∀ (m : ℕ), ↑m < n → differentiable_on 𝕜 (iterated_deriv_within m f s) s
theorem is_min_filter.dual {α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α} : is_min_filter f l a → is_max_filter (⇑order_dual.to_dual ∘ f) l a
theorem measure_theory.absolutely_continuous_of_is_mul_left_invariant {G : Type u_1} [measurable_space G] [group G] [has_measurable_mul₂ G] (μ ν : measure_theory.measure G) [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] [has_measurable_inv G] [μ.is_mul_left_invariant] [ν.is_mul_left_invariant] (hν : ν ≠ 0) : μ.absolutely_continuous ν
theorem sum_mem {B : Type u_3} {S : B} {M : Type u_1} [add_comm_monoid M] [set_like B M] [add_submonoid_class B M] {ι : Type u_2} {t : finset ι} {f : ι → M} (h : ∀ (c : ι), c ∈ t → f c ∈ S) : t.sum (λ (c : ι), f c) ∈ S
theorem complex.exists_mem_frontier_is_max_on_norm {E : Type u} [normed_group E] [normed_space ℂ E] {F : Type v} [normed_group F] [normed_space ℂ F] [nontrivial E] [finite_dimensional ℂ E] {f : E → F} {U : set E} (hb : metric.bounded U) (hne : U.nonempty) (hd : diff_cont_on_cl ℂ f U) : ∃ (z : E) (H : z ∈ frontier U), is_max_on (has_norm.norm ∘ f) (closure U) z
theorem supr_inf_le_Sup_inf {α : Type u_1} [complete_lattice α] {a : α} {s : set α} : (⨆ (b : α) (H : b ∈ s), b ⊓ a) ≤ has_Sup.Sup s ⊓ a
theorem filter.tendsto_abs_at_top_at_top {α : Type u_3} [linear_ordered_add_comm_group α] : filter.tendsto has_abs.abs filter.at_top filter.at_top
theorem uniform_continuous_of_continuous_at_zero {α : Type u_1} {β : Type u_2} [uniform_space α] [add_group α] [uniform_add_group α] {hom : Type u_3} [uniform_space β] [add_group β] [uniform_add_group β] [add_monoid_hom_class hom α β] (f : hom) (hf : continuous_at ⇑f 0) : uniform_continuous ⇑f
theorem unitization.alg_hom_ext' {R : Type u_2} {A : Type u_3} [comm_semiring R] [non_unital_semiring A] [module R A] [smul_comm_class R A A] [is_scalar_tower R A A] {C : Type u_5} [ring C] [algebra R C] {φ ψ : unitization R A →ₐ[R] C} (h : φ.to_non_unital_alg_hom.comp (unitization.coe_non_unital_alg_hom R A) = ψ.to_non_unital_alg_hom.comp (unitization.coe_non_unital_alg_hom R A)) : φ = ψ
theorem measure_theory.norm_Lp_to_Lp_restrict_le {α : Type u_1} {E : Type u_3} [measurable_space α] [normed_group E] {p : ennreal} {μ : measure_theory.measure α} (s : set α) (f : ↥(measure_theory.Lp E p μ)) : ∥measure_theory.mem_ℒp.to_Lp ⇑f _∥ ≤ ∥f∥
theorem affine_subspace.mem_inf_iff {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (p : P) (s1 s2 : affine_subspace k P) : p ∈ s1 ⊓ s2 ↔ p ∈ s1 ∧ p ∈ s2
theorem liouville.tsum_one_div_pow_factorial_lt (n : ℕ) {m : ℝ} (m1 : 1 < m) : ∑' (i : ℕ), 1 / m ^ (i + (n + 1)).factorial < (1 - 1 / m)⁻¹ * (1 / m ^ (n + 1).factorial)
theorem is_noetherian.induction {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] [is_noetherian R M] {P : submodule R M → Prop} (hgt : ∀ (I : submodule R M), (∀ (J : submodule R M), J > I → P J) → P I) (I : submodule R M) : P I
theorem dist_le_of_trajectories_ODE {E : Type u_1} [normed_group E] [normed_space ℝ E] {v : ℝ → E → E} {K : nnreal} (hv : ∀ (t : ℝ), lipschitz_with K (v t)) {f g : ℝ → E} {a b δ : ℝ} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (t : ℝ), t ∈ set.Ico a b → has_deriv_within_at f (v t (f t)) (set.Ici t) t) (hg : continuous_on g (set.Icc a b)) (hg' : ∀ (t : ℝ), t ∈ set.Ico a b → has_deriv_within_at g (v t (g t)) (set.Ici t) t) (ha : has_dist.dist (f a) (g a) ≤ δ) (t : ℝ) (H : t ∈ set.Icc a b) : has_dist.dist (f t) (g t) ≤ δ * real.exp (↑K * (t - a))
theorem measure_theory.measure.inner_regular.measurable_set_of_open {α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} {p : set α → Prop} [μ.outer_regular] (H : μ.inner_regular p is_open) (h0 : p ∅) (hd : ∀ ⦃s U : set α⦄, p s → is_open U → p (s  U)) : μ.inner_regular p (λ (s : set α), measurable_set s ∧ ⇑μ s ≠ ⊤)
theorem finset.weighted_vsub_of_point_indicator_subset {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (w : ι → k) (p : ι → P) (b : P) {s₁ s₂ : finset ι} (h : s₁ ⊆ s₂) : ⇑(s₁.weighted_vsub_of_point p b) w = ⇑(s₂.weighted_vsub_of_point p b) (↑s₁.indicator w)
theorem reflection_map {𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} {E' : Type u_3} [inner_product_space 𝕜 E] [inner_product_space 𝕜 E'] (f : E ≃ₗᵢ[𝕜] E') (K : submodule 𝕜 E) [complete_space ↥K] : reflection (submodule.map ↑(f.to_linear_equiv) K) = f.symm.trans ((reflection K).trans f)
theorem measure_theory.measure.hausdorff_measure_le_liminf_tsum {X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] {β : Type u_1} {ι : β → Type u_3} [hι : Π (n : β), encodable (ι n)] (d : ℝ) (s : set X) {l : filter β} (r : β → ennreal) (hr : filter.tendsto r l (nhds 0)) (t : Π (n : β), ι n → set X) (ht : ∀ᶠ (n : β) in l, ∀ (i : ι n), emetric.diam (t n i) ≤ r n) (hst : ∀ᶠ (n : β) in l, s ⊆ ⋃ (i : ι n), t n i) : ⇑(measure_theory.measure.hausdorff_measure d) s ≤ l.liminf (λ (n : β), ∑' (i : ι n), emetric.diam (t n i) ^ d)
theorem discrete_valuation_ring.exists_prime (R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R] : ∃ (ϖ : R), prime ϖ
theorem quotient_norm_mk_le {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) : ∥⇑(quotient_add_group.mk' S) m∥ ≤ ∥m∥
theorem category_theory.abelian.pseudoelement.pseudo_injective_of_mono {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P ⟶ Q) [category_theory.mono f] : function.injective ⇑f
theorem first_order.language.substructure.closure_eq {L : first_order.language} {M : Type w} [L.Structure M] (S : L.substructure M) : ⇑(first_order.language.substructure.closure L) ↑S = S
theorem Profinite.exists_clopen_of_cofiltered {J : Type u} [category_theory.small_category J] [category_theory.is_cofiltered J] {F : J ⥤ Profinite} (C : category_theory.limits.cone F) (hC : category_theory.limits.is_limit C) {U : set ↥(C.X)} (hU : is_clopen U) : ∃ (j : J) (V : set ↥(F.obj j)) (hV : is_clopen V), U = ⇑(C.π.app j) ⁻¹' V
theorem linear_equiv.is_unit_det' {M : Type u_2} [add_comm_group M] {A : Type u_1} [comm_ring A] [module A M] (f : M ≃ₗ[A] M) : is_unit (⇑linear_map.det ↑f)
theorem vsub_set_subset_vector_span (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s -ᵥ s ⊆ ↑(vector_span k s)
theorem mul_mem_class.mul_mem_add_closure {M : Type u_1} {R : Type u_4} [non_unital_non_assoc_semiring R] [set_like M R] [mul_mem_class M R] {S : M} {a b : R} (ha : a ∈ add_submonoid.closure ↑S) (hb : b ∈ add_submonoid.closure ↑S) : a * b ∈ add_submonoid.closure ↑S
theorem finset.mem_shadow_iff_exists_mem_card_add_one {α : Type u_1} [decidable_eq α] {𝒜 : finset (finset α)} {s : finset α} : s ∈ 𝒜.shadow ↔ ∃ (t : finset α) (H : t ∈ 𝒜), s ⊆ t ∧ t.card = s.card + 1
theorem unique_factorization_monoid.multiplicity_eq_count_normalized_factors {R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] [nontrivial R] [normalization_monoid R] [decidable_eq R] [dec_dvd : decidable_rel has_dvd.dvd] {a b : R} (ha : irreducible a) (hb : b ≠ 0) : multiplicity a b = ↑(multiset.count (⇑normalize a) (unique_factorization_monoid.normalized_factors b))
theorem euclidean_geometry.exists_dist_eq_iff_exists_dist_orthogonal_projection_eq {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} [nonempty ↥s] [complete_space ↥(s.direction)] {ps : set P} (hps : ps ⊆ ↑s) (p : P) : (∃ (r : ℝ), ∀ (p1 : P), p1 ∈ ps → has_dist.dist p1 p = r) ↔ ∃ (r : ℝ), ∀ (p1 : P), p1 ∈ ps → has_dist.dist p1 ↑(⇑(euclidean_geometry.orthogonal_projection s) p) = r
theorem exp_sum {𝕂 : Type u_1} {𝔸 : Type u_2} [is_R_or_C 𝕂] [normed_comm_ring 𝔸] [normed_algebra 𝕂 𝔸] [complete_space 𝔸] {ι : Type u_3} (s : finset ι) (f : ι → 𝔸) : exp 𝕂 (s.sum (λ (i : ι), f i)) = s.prod (λ (i : ι), exp 𝕂 (f i))
theorem emetric.inf_edist_union {α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} : emetric.inf_edist x (s ∪ t) = emetric.inf_edist x s ⊓ emetric.inf_edist x t
theorem real.deriv_tan_sub_id (x : ℝ) (h : real.cos x ≠ 0) : deriv (λ (y : ℝ), real.tan y - y) x = 1 / real.cos x ^ 2 - 1
theorem cont_diff_on.comp {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {n : with_top ℕ} {s : set E} {t : set F} {g : F → G} {f : E → F} (hg : cont_diff_on 𝕜 n g t) (hf : cont_diff_on 𝕜 n f s) (st : s ⊆ f ⁻¹' t) : cont_diff_on 𝕜 n (g ∘ f) s
theorem basis.to_matrix_reindex' {ι : Type u_1} {ι' : Type u_2} {R : Type u_5} {M : Type u_6} [comm_semiring R] [add_comm_monoid M] [module R M] [fintype ι'] [fintype ι] [decidable_eq ι] [decidable_eq ι'] (b : basis ι R M) (v : ι' → M) (e : ι ≃ ι') : (b.reindex e).to_matrix v = ⇑(matrix.reindex_alg_equiv R e) (b.to_matrix (v ∘ ⇑e))
theorem finset.dimH_zero {X : Type u_2} [emetric_space X] (s : finset X) : dimH ↑s = 0
theorem function.is_fixed_pt.to_left_inverse {α : Type u} {f g : α → α} {x : α} (hf : function.is_fixed_pt f x) (h : function.left_inverse g f) : function.is_fixed_pt g x
theorem exists_gcd_eq_mul_add_mul {R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] [gcd_monoid R] (a b : R) : ∃ (x y : R), gcd_monoid.gcd a b = a * x + b * y
theorem algebra.finite_presentation.mv_polynomial (R : Type u_1) [comm_ring R] (ι : Type u_2) [fintype ι] : algebra.finite_presentation R (mv_polynomial ι R)
theorem fin.strict_anti_iff_succ_lt {n : ℕ} {α : Type u_1} [preorder α] {f : fin (n + 1) → α} : strict_anti f ↔ ∀ (i : fin n), f i.succ < f (⇑fin.cast_succ i)
theorem orthonormal.oangle_eq_neg_of_orientation_eq_neg {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {b₂ : basis (fin 2) ℝ V} (hb₂ : orthonormal ℝ ⇑b₂) (ho : b.orientation = -b₂.orientation) (x y : V) : hb.oangle x y = -hb₂.oangle x y
theorem strict_mono_on.continuous_at_right_of_closure_image_mem_nhds_within {α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_on f s) (hs : s ∈ nhds_within a (set.Ici a)) (hfs : closure (f '' s) ∈ nhds_within (f a) (set.Ici (f a))) : continuous_within_at f (set.Ici a) a
theorem has_deriv_within_at.limsup_norm_slope_le {E : Type u} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {f' : E} {s : set ℝ} {x r : ℝ} (hf : has_deriv_within_at f f' s x) (hr : ∥f'∥ < r) : ∀ᶠ (z : ℝ) in nhds_within x s, ∥z - x∥⁻¹ * ∥f z - f x∥ < r
theorem category_theory.grothendieck_topology.plus.sep {C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] [∀ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)ᵒᵖ D] [∀ (P : Cᵒᵖ ⥤ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [Π (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)ᵒᵖ (category_theory.forget D)] {X : C} (P : Cᵒᵖ ⥤ D) (S : J.cover X) (x y : ↥((J.plus_obj P).obj (opposite.op X))) (h : ∀ (I : S.arrow), ⇑((J.plus_obj P).map I.f.op) x = ⇑((J.plus_obj P).map I.f.op) y) : x = y
theorem setoid.eqv_gen_le {α : Type u_1} {r : α → α → Prop} {s : setoid α} (h : ∀ (x y : α), r x y → s.rel x y) : eqv_gen.setoid r ≤ s
theorem is_open.exists_lt_is_closed {α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [μ.weakly_regular] ⦃U : set α⦄ (hU : is_open U) {r : ennreal} (hr : r < ⇑μ U) : ∃ (F : set α) (H : F ⊆ U), is_closed F ∧ r < ⇑μ F
theorem has_fpower_series_on_ball.analytic_at_of_mem {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] [complete_space F] {f : E → F} {p : formal_multilinear_series 𝕜 E F} {x y : E} {r : ennreal} (hf : has_fpower_series_on_ball f p x r) (h : y ∈ emetric.ball x r) : analytic_at 𝕜 f y
theorem pgame.lf_zero {x : pgame} : x.lf 0 ↔ ∃ (j : x.right_moves), ∀ (i : (x.move_right j).left_moves), ((x.move_right j).move_left i).lf 0
theorem orientation.oangle_smul_left_of_neg {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x y : V) {r : ℝ} (hr : r < 0) : o.oangle (r • x) y = o.oangle (-x) y
theorem orthogonal_family.range_linear_isometry {ι : Type u_1} {𝕜 : Type u_2} [is_R_or_C 𝕜] {E : Type u_3} [inner_product_space 𝕜 E] [cplt : complete_space E] {G : ι → Type u_4} [Π (i : ι), inner_product_space 𝕜 (G i)] {V : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : orthogonal_family 𝕜 V) [∀ (i : ι), complete_space (G i)] : hV.linear_isometry.to_linear_map.range = (⨆ (i : ι), (V i).to_linear_map.range).topological_closure
theorem submodule.exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (I : ideal R) (N : submodule R M) (hn : N.fg) (hin : N ≤ I • N) : ∃ (r : R), r - 1 ∈ I ∧ ∀ (n : M), n ∈ N → r • n = 0
theorem orientation.linear_equiv_det_rotation {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (θ : real.angle) : ⇑linear_equiv.det (o.rotation θ).to_linear_equiv = 1
theorem subtype.forall' {α : Sort u_1} {p : α → Prop} {q : Π (x : α), p x → Prop} : (∀ (x : α) (h : p x), q x h) ↔ ∀ (x : {a // p a}), q ↑x _
theorem is_of_fin_order_one {G : Type u} [monoid G] : is_of_fin_order 1
theorem circle_integral.integral_sub_zpow_of_ne {n : ℤ} (hn : n ≠ -1) (c w : ℂ) (R : ℝ) : ∮ (z : ℂ) in C(c, R), (z - w) ^ n = 0
theorem mul_hom.ext_iff {M : Type u_3} {N : Type u_4} [has_mul M] [has_mul N] {f g : M →ₙ* N} : f = g ↔ ∀ (x : M), ⇑f x = ⇑g x
theorem measurable_space.cardinal_measurable_set_le {α : Type u} (s : set (set α)) : cardinal.mk ↥{t : set α | measurable_set t} ≤ linear_order.max (cardinal.mk ↥s) 2 ^ cardinal.aleph_0
theorem normed_group_hom.le_op_norm {V₁ : Type u_2} {V₂ : Type u_3} [semi_normed_group V₁] [semi_normed_group V₂] (f : normed_group_hom V₁ V₂) (x : V₁) : ∥⇑f x∥ ≤ ∥f∥ * ∥x∥
theorem monovary.sum_mul_comp_perm_le_sum_mul {ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {σ : equiv.perm ι} {f g : ι → α} [fintype ι] (hfg : monovary f g) : finset.univ.sum (λ (i : ι), f i * g (⇑σ i)) ≤ finset.univ.sum (λ (i : ι), f i * g i)
theorem units.dvd_mul_right {α : Type u_1} [monoid α] {a b : α} {u : αˣ} : a ∣ b * ↑u ↔ a ∣ b
theorem orthonormal_fourier  : orthonormal ℂ (fourier_Lp 2)
theorem matrix.inv_eq_left_inv {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {A B : matrix n n α} (h : B.mul A = 1) : A⁻¹ = B
theorem zero_mul_eq_const {M₀ : Type u_1} [mul_zero_class M₀] : has_mul.mul 0 = function.const M₀ 0
theorem polynomial.is_root_cyclotomic_prime_pow_mul_iff_of_char_p {m k p : ℕ} {R : Type u_1} [comm_ring R] [is_domain R] [hp : fact (nat.prime p)] [hchar : char_p R p] {μ : R} [ne_zero ↑m] : (polynomial.cyclotomic (p ^ k * m) R).is_root μ ↔ is_primitive_root μ m
theorem same_ray_smul_right_iff_of_ne {R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] [no_zero_smul_divisors R M] {v : M} (hv : v ≠ 0) {r : R} (hr : r ≠ 0) : same_ray R v (r • v) ↔ 0 < r
theorem is_bounded_bilinear_map.is_bounded_linear_map_deriv {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {f : E × F → G} (h : is_bounded_bilinear_map 𝕜 f) : is_bounded_linear_map 𝕜 (λ (p : E × F), h.deriv p)
theorem linear_map.is_Ortho.separating_right_iff_not_is_ortho_basis_self {R : Type u_1} {M : Type u_5} {n : Type u_14} [comm_ring R] [add_comm_group M] [module R M] [no_zero_divisors R] {B : M →ₗ[R] M →ₗ[R] R} (v : basis n R M) (hO : B.is_Ortho ⇑v) (h : ∀ (i : n), ¬B.is_ortho (⇑v i) (⇑v i)) : B.separating_right
theorem ideal.eq_zero_of_polynomial_mem_map_range {R : Type u} [comm_ring R] (I : ideal (polynomial R)) (x : ↥(((ideal.quotient.mk I).comp polynomial.C).range)) (hx : ⇑polynomial.C x ∈ ideal.map (polynomial.map_ring_hom ((ideal.quotient.mk I).comp polynomial.C).range_restrict) I) : x = 0
theorem liouville_with.rat_mul_iff {p x : ℝ} {r : ℚ} (hr : r ≠ 0) : liouville_with p (↑r * x) ↔ liouville_with p x
theorem semilattice_sup_mk'_partial_order_eq_semilattice_inf_mk'_partial_order {α : Type u_1} [has_sup α] [has_inf α] (sup_comm : ∀ (a b : α), a ⊔ b = b ⊔ a) (sup_assoc : ∀ (a b c : α), a ⊔ b ⊔ c = a ⊔ (b ⊔ c)) (sup_idem : ∀ (a : α), a ⊔ a = a) (inf_comm : ∀ (a b : α), a ⊓ b = b ⊓ a) (inf_assoc : ∀ (a b c : α), a ⊓ b ⊓ c = a ⊓ (b ⊓ c)) (inf_idem : ∀ (a : α), a ⊓ a = a) (sup_inf_self : ∀ (a b : α), a ⊔ a ⊓ b = a) (inf_sup_self : ∀ (a b : α), a ⊓ (a ⊔ b) = a) : semilattice_sup.to_partial_order α = semilattice_inf.to_partial_order α
theorem ultrafilter_is_open_basic {α : Type u} (s : set α) : is_open {u : ultrafilter α | s ∈ u}
theorem ideal.is_jacobson_iff_Inf_maximal {R : Type u_1} [comm_ring R] : ideal.is_jacobson R ↔ ∀ {I : ideal R}, I.is_prime → (∃ (M : set (ideal R)), (∀ (J : ideal R), J ∈ M → J.is_maximal ∨ J = ⊤) ∧ I = has_Inf.Inf M)
theorem affine_subspace.vadd_mem_mk' {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {v : V} (p : P) {direction : submodule k V} (hv : v ∈ direction) : v +ᵥ p ∈ affine_subspace.mk' p direction
theorem function.periodic.Inf_add_zsmul_le_integral_of_pos {T : ℝ} {g : ℝ → ℝ} (hg : function.periodic g T) (h_int : ∀ (t₁ t₂ : ℝ), interval_integrable g measure_theory.measure_space.volume t₁ t₂) (hT : 0 < T) (t : ℝ) : has_Inf.Inf ((λ (t : ℝ), ∫ (x : ℝ) in 0..t, g x) '' set.Icc 0 T) + ⌊t / T⌋ • ∫ (x : ℝ) in 0..T, g x ≤ ∫ (x : ℝ) in 0..t, g x
theorem asymptotics.is_o.neg_left {α : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : α → F} {f' : α → E'} {l : filter α} : f' =o[l] g → (λ (x : α), -f' x) =o[l] g
theorem one_pos {α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 1
theorem monoid_hom.map_mul_inv {α : Type u_1} {β : Type u_2} [group α] [division_monoid β] (f : α →* β) (g h : α) : ⇑f (g * h⁻¹) = ⇑f g * (⇑f h)⁻¹
theorem norm_le_gronwall_bound_of_norm_deriv_right_le {E : Type u_1} [normed_group E] [normed_space ℝ E] {f f' : ℝ → E} {δ K ε a b : ℝ} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at f (f' x) (set.Ici x) x) (ha : ∥f a∥ ≤ δ) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → ∥f' x∥ ≤ K * ∥f x∥ + ε) (x : ℝ) (H : x ∈ set.Icc a b) : ∥f x∥ ≤ gronwall_bound δ K ε (x - a)
theorem submonoid.subset_closure {M : Type u_1} [mul_one_class M] {s : set M} : s ⊆ ↑(submonoid.closure s)
theorem cont_diff_on_of_differentiable_on_deriv {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {s : set 𝕜} {n : with_top ℕ} (h : ∀ (m : ℕ), ↑m ≤ n → differentiable_on 𝕜 (iterated_deriv_within m f s) s) : cont_diff_on 𝕜 n f s
theorem measurable.measurable_of_countable_ne {α : Type u_1} {β : Type u_2} {f g : α → β} {m : measurable_space α} {mβ : measurable_space β} [measurable_singleton_class α] (hf : measurable f) (h : {x : α | f x ≠ g x}.countable) : measurable g
theorem is_mul_hom.comp {α : Type u} {β : Type v} [has_mul α] [has_mul β] {γ : Type u_1} [has_mul γ] {f : α → β} {g : β → γ} (hf : is_mul_hom f) (hg : is_mul_hom g) : is_mul_hom (g ∘ f)
theorem cont_mdiff_on.continuous_on_tangent_map_within_aux {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {n : with_top ℕ} {f : H → H'} {s : set H} (hf : cont_mdiff_on I I' n f s) (hn : 1 ≤ n) (hs : unique_mdiff_on I s) : continuous_on (tangent_map_within I I' f s) (tangent_bundle.proj I H ⁻¹' s)
theorem is_monoid_hom.comp {α : Type u} {β : Type v} [mul_one_class α] [mul_one_class β] {f : α → β} (hf : is_monoid_hom f) {γ : Type u_1} [mul_one_class γ] {g : β → γ} (hg : is_monoid_hom g) : is_monoid_hom (g ∘ f)
theorem measure_theory.content.inner_content_Sup_nat {G : Type w} [topological_space G] (μ : measure_theory.content G) [t2_space G] (U : ℕ → topological_space.opens G) : μ.inner_content (⨆ (i : ℕ), U i) ≤ ∑' (i : ℕ), μ.inner_content (U i)
theorem module.End.eigenspace_le_generalized_eigenspace {R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {μ : R} {k : ℕ} (hk : 0 < k) : f.eigenspace μ ≤ ⇑(f.generalized_eigenspace μ) k
theorem add_subsemigroup.closure_le {M : Type u_1} [has_add M] {s : set M} {S : add_subsemigroup M} : add_subsemigroup.closure s ≤ S ↔ s ⊆ ↑S
theorem monoid_hom.mrange_top_of_surjective {M : Type u_1} [mul_one_class M] {N : Type u_2} [mul_one_class N] (f : M →* N) (hf : function.surjective ⇑f) : f.mrange = ⊤
theorem solvable_by_rad.induction3 {F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] {α : ↥(solvable_by_rad F E)} {n : ℕ} (hn : n ≠ 0) (hα : solvable_by_rad.P (α ^ n)) : solvable_by_rad.P α
theorem vitali.exists_disjoint_covering_ae {α : Type u_1} [metric_space α] [measurable_space α] [opens_measurable_space α] [topological_space.second_countable_topology α] (μ : measure_theory.measure α) [measure_theory.is_locally_finite_measure μ] (s : set α) (t : set (set α)) (hf : ∀ (x : α), x ∈ s → ∀ (ε : ℝ), ε > 0 → (∃ (a : set α) (H : a ∈ t), x ∈ a ∧ a ⊆ metric.closed_ball x ε)) (ht : ∀ (a : set α), a ∈ t → (interior a).nonempty) (h't : ∀ (a : set α), a ∈ t → is_closed a) (C : nnreal) (h : ∀ (a : set α), a ∈ t → (∃ (x : α) (H : x ∈ a), ⇑μ (metric.closed_ball x (3 * metric.diam a)) ≤ ↑C * ⇑μ a)) : ∃ (u : set (set α)) (H : u ⊆ t), u.countable ∧ u.pairwise_disjoint id ∧ ⇑μ (s  ⋃ (a : set α) (H : a ∈ u), a) = 0
theorem disjointed_unique {α : Type u_1} [generalized_boolean_algebra α] {f d : ℕ → α} (hdisj : pairwise (disjoint on d)) (hsups : partial_sups d = partial_sups f) : d = disjointed f
theorem measurable.ae_strongly_measurable {α : Type u_1} {β : Type u_2} [topological_space β] {f : α → β} {m : measurable_space α} {μ : measure_theory.measure α} [measurable_space β] [topological_space.pseudo_metrizable_space β] [topological_space.second_countable_topology β] [opens_measurable_space β] (hf : measurable f) : measure_theory.ae_strongly_measurable f μ
theorem continuous.matrix_mul {X : Type u_1} {m : Type u_4} {n : Type u_5} {p : Type u_6} {R : Type u_8} [topological_space X] [topological_space R] [fintype n] [has_mul R] [add_comm_monoid R] [has_continuous_add R] [has_continuous_mul R] {A : X → matrix m n R} {B : X → matrix n p R} (hA : continuous A) (hB : continuous B) : continuous (λ (x : X), (A x).mul (B x))
theorem finset.nat.antidiagonal_zero  : finset.nat.antidiagonal 0 = {(0, 0)}
theorem ring_hom.map_sum {β : Type u} {α : Type v} {γ : Type w} [non_assoc_semiring β] [non_assoc_semiring γ] (g : β →+* γ) (f : α → β) (s : finset α) : ⇑g (s.sum (λ (x : α), f x)) = s.sum (λ (x : α), ⇑g (f x))
theorem orientation.rotation_zero {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) : o.rotation 0 = linear_isometry_equiv.refl ℝ V
theorem filter.at_bot_Iic_eq {α : Type u_3} [semilattice_inf α] (a : α) : filter.at_bot = filter.comap coe filter.at_bot
theorem free_group.red.nil_iff {α : Type u} {L : list (α × bool)} : free_group.red list.nil L ↔ L = list.nil
theorem intermediate_field.zero_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) : 0 ∈ S
theorem category_theory.limits.complete_lattice.limit_eq_infi {α : Type u} [complete_lattice α] {J : Type u} [category_theory.small_category J] (F : J ⥤ α) : category_theory.limits.limit F = infi F.obj
theorem topological_fiber_bundle_core.continuous_const_section {ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (v : F) (h : ∀ (i j : ι) (x : B), x ∈ Z.base_set i ∩ Z.base_set j → Z.coord_change i j x v = v) : continuous (show B → Z.total_space, from λ (x : B), ⟨x, v⟩)
theorem zero_hom.congr_arg {M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] (f : zero_hom M N) {x y : M} (h : x = y) : ⇑f x = ⇑f y
theorem one_le_inv' {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : 1 ≤ a⁻¹ ↔ a ≤ 1
theorem inner_product_space.is_self_adjoint.has_eigenvalue_supr_of_finite_dimensional {𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] [finite_dimensional 𝕜 E] [nontrivial E] {T : E →ₗ[𝕜] E} (hT : inner_product_space.is_self_adjoint T) : module.End.has_eigenvalue T (↑⨆ (x : {x // x ≠ 0}), ⇑is_R_or_C.re (has_inner.inner (⇑T ↑x) ↑x) / ∥↑x∥ ^ 2)
theorem sub_mem {M : Type u_3} {S : Type u_4} [sub_neg_monoid M] [set_like S M] [hSM : add_subgroup_class S M] {H : S} {x y : M} (hx : x ∈ H) (hy : y ∈ H) : x - y ∈ H
theorem measurable_set_region_between {α : Type u_1} [measurable_space α] {f g : α → ℝ} {s : set α} (hf : measurable f) (hg : measurable g) (hs : measurable_set s) : measurable_set (region_between f g s)
theorem image_norm_le_of_norm_deriv_right_lt_deriv_boundary' {E : Type u_1} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} {f' : ℝ → E} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : ℝ → ℝ} (ha : ∥f a∥ ≤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at B (B' x) (set.Ici x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → ∥f x∥ = B x → ∥f' x∥ < B' x) ⦃x : ℝ⦄ : x ∈ set.Icc a b → ∥f x∥ ≤ B x
theorem norm_smul_inv_norm {𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {x : E} (hx : x ≠ 0) : ∥(↑∥x∥)⁻¹ • x∥ = 1
theorem neg_lt_zero {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : -a < 0 ↔ 0 < a
theorem fin.cast_eq_cast {n m : ℕ} (h : n = m) : ⇑(fin.cast h) = cast _
theorem matrix.det_reindex_alg_equiv {m : Type u_2} {n : Type u_3} (R : Type u_11) [comm_ring R] [fintype m] [decidable_eq m] [fintype n] [decidable_eq n] (e : m ≃ n) (A : matrix m m R) : (⇑(matrix.reindex_alg_equiv R e) A).det = A.det
theorem continuous_map.continuous_eval_const {α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β] (x : α) : continuous (λ (f : C(α, β)), ⇑f x)
theorem quot.lift_mk {α : Sort u_1} {γ : Sort u_4} {r : α → α → Prop} (f : α → γ) (h : ∀ (a₁ a₂ : α), r a₁ a₂ → f a₁ = f a₂) (a : α) : quot.lift f h (quot.mk r a) = f a
theorem is_left_regular_of_non_zero_divisor {α : Type u} [non_unital_non_assoc_ring α] (k : α) (h : ∀ (x : α), k * x = 0 → x = 0) : is_left_regular k
theorem mul_action.to_perm_injective {α : Type u} {β : Type v} [group α] [mul_action α β] [has_faithful_smul α β] : function.injective mul_action.to_perm
theorem submodule.span_subset_span (R : Type u_1) {M : Type u_4} (S : Type u_7) [semiring R] [add_comm_monoid M] [module R M] (s : set M) [semiring S] [has_scalar R S] [module S M] [is_scalar_tower R S M] : ↑(submodule.span R s) ⊆ ↑(submodule.span S s)
theorem real_inner_smul_self_left {F : Type u_3} [inner_product_space ℝ F] (x : F) (r : ℝ) : has_inner.inner (r • x) x = r * (∥x∥ * ∥x∥)
theorem filter.tendsto.le_comap {α : Type u} {β : Type v} {f : α → β} {l₁ : filter α} {l₂ : filter β} : filter.tendsto f l₁ l₂ → l₁ ≤ filter.comap f l₂
theorem interval_integral.integral_comp_mul_deriv {a b : ℝ} {f f' g : ℝ → ℝ} (h : ∀ (x : ℝ), x ∈ set.interval a b → has_deriv_at f (f' x) x) (h' : continuous_on f' (set.interval a b)) (hg : continuous g) : ∫ (x : ℝ) in a..b, (g ∘ f) x * f' x = ∫ (x : ℝ) in f a..f b, g x
theorem continuous_sigma {β : Type v} {ι : Type u_5} {σ : ι → Type u_6} [Π (i : ι), topological_space (σ i)] [topological_space β] {f : sigma σ → β} (h : ∀ (i : ι), continuous (λ (a : σ i), f ⟨i, a⟩)) : continuous f
theorem finset.sum_centroid_weights_indicator_eq_one_of_nonempty (k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) [char_zero k] [fintype ι] (h : s.nonempty) : finset.univ.sum (λ (i : ι), finset.centroid_weights_indicator k s i) = 1
theorem add_monoid_hom.map_exists_left_neg {M : Type u_3} {N : Type u_4} {F : Type u_8} {mM : add_zero_class M} {mN : add_zero_class N} [add_monoid_hom_class F M N] (f : F) {x : M} (hx : ∃ (y : M), y + x = 0) : ∃ (y : N), y + ⇑f x = 0
theorem convex.combo_interior_self_subset_interior {E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) {a b : 𝕜} (ha : 0 < a) (hb : 0 ≤ b) (hab : a + b = 1) : a • interior s + b • s ⊆ interior s
theorem not_wcovby_iff {α : Type u_1} [preorder α] {a b : α} (h : a ≤ b) : ¬a ⩿ b ↔ ∃ (c : α), a < c ∧ c < b
theorem subgroup.map_injective_of_ker_le {G : Type u_1} [group G] {N : Type u_3} [group N] (f : G →* N) {H K : subgroup G} (hH : f.ker ≤ H) (hK : f.ker ≤ K) (hf : subgroup.map f H = subgroup.map f K) : H = K
theorem inv_mul_lt_of_lt_mul {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : a < b * c → b⁻¹ * a < c
theorem finite_dimensional.finrank_fintype_fun_eq_card (K : Type u) [division_ring K] {ι : Type v} [fintype ι] : finite_dimensional.finrank K (ι → K) = fintype.card ι
theorem submodule.finrank_le {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] (s : submodule K V) : finite_dimensional.finrank K ↥s ≤ finite_dimensional.finrank K V
theorem measure_theory.integral_integral_symm {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] {f : α → β → E} (hf : measure_theory.integrable (function.uncurry f) (μ.prod ν)) : ∫ (x : α), ∫ (y : β), f x y ∂ν ∂μ = ∫ (z : β × α), f z.snd z.fst ∂ν.prod μ
theorem emetric.inf_edist_le_inf_edist_add_Hausdorff_edist {α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} : emetric.inf_edist x t ≤ emetric.inf_edist x s + emetric.Hausdorff_edist s t
theorem witt_vector.frobenius_verschiebung {p : ℕ} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (x : witt_vector p R) : ⇑witt_vector.frobenius (⇑witt_vector.verschiebung x) = x * ↑p
theorem cont_diff_within_at.cont_mdiff_within_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {n : with_top ℕ} {f : E → E'} {s : set E} {x : E} : cont_diff_within_at 𝕜 n f s x → cont_mdiff_within_at (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n f s x
theorem generalized_continued_fraction.int_fract_pair.nth_stream_fr_nonneg {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : 0 ≤ ifp_n.fr
theorem measurable_set.exists_is_closed_lt_add {α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [μ.weakly_regular] {s : set α} (hs : measurable_set s) (hμs : ⇑μ s ≠ ⊤) {ε : ennreal} (hε : ε ≠ 0) : ∃ (K : set α) (H : K ⊆ s), is_closed K ∧ ⇑μ s < ⇑μ K + ε
theorem subgroup.list_prod_mem {G : Type u_1} [group G] (K : subgroup G) {l : list G} : (∀ (x : G), x ∈ l → x ∈ K) → l.prod ∈ K
theorem continuous_on.surj_on_of_tendsto' {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {δ : Type u_1} [linear_order δ] [topological_space δ] [order_closed_topology δ] {f : α → δ} {s : set α} [s.ord_connected] (hs : s.nonempty) (hf : continuous_on f s) (hbot : filter.tendsto (λ (x : ↥s), f ↑x) filter.at_bot filter.at_top) (htop : filter.tendsto (λ (x : ↥s), f ↑x) filter.at_top filter.at_bot) : set.surj_on f s set.univ
theorem real.nat_sqrt_le_real_sqrt {a : ℕ} : ↑(nat.sqrt a) ≤ real.sqrt ↑a
theorem category_theory.presieve.is_sheaf_for.hom_ext {C : Type u₁} [category_theory.category C] {X : C} {S : category_theory.sieve X} {P : Cᵒᵖ ⥤ Type v₁} (h : category_theory.presieve.is_sheaf_for P ⇑S) (t₁ t₂ : category_theory.yoneda.obj X ⟶ P) (ht : S.functor_inclusion ≫ t₁ = S.functor_inclusion ≫ t₂) : t₁ = t₂
theorem dense_compl_singleton_iff_not_open {α : Type u} [topological_space α] {x : α} : dense {x}ᶜ ↔ ¬is_open {x}
theorem list.prod_reverse_noncomm {G : Type u_7} [group G] (L : list G) : L.reverse.prod = ((list.map (λ (x : G), x⁻¹) L).prod)⁻¹
theorem con.inf_iff_and {M : Type u_1} [has_mul M] {c d : con M} {x y : M} : ⇑(c ⊓ d) x y ↔ ⇑c x y ∧ ⇑d x y
theorem spectrum.smul_eq_smul {𝕜 : Type u} {A : Type v} [field 𝕜] [ring A] [algebra 𝕜 A] [nontrivial A] (k : 𝕜) (a : A) (ha : (spectrum 𝕜 a).nonempty) : spectrum 𝕜 (k • a) = k • spectrum 𝕜 a
theorem monotone.cauchy_seq_alternating_series_of_tendsto_zero {f : ℕ → ℝ} (hfa : monotone f) (hf0 : filter.tendsto f filter.at_top (nhds 0)) : cauchy_seq (λ (n : ℕ), (finset.range (n + 1)).sum (λ (i : ℕ), (-1) ^ i * f i))
theorem convex_cone.blunt.salient {𝕜 : Type u_1} {E : Type u_2} [ordered_semiring 𝕜] [add_comm_group E] [has_scalar 𝕜 E] {S : convex_cone 𝕜 E} : S.blunt → S.salient
theorem measure_theory.lintegral_add_mul_meas_add_le_le_lintegral {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f g : α → ennreal} (hle : f ≤ᵐ[μ] g) (hg : ae_measurable g μ) (ε : ennreal) : ∫⁻ (a : α), f a ∂μ + ε * ⇑μ {x : α | f x + ε ≤ g x} ≤ ∫⁻ (a : α), g a ∂μ
theorem finsum_mem_range' {α : Type u_1} {β : Type u_2} {M : Type u_5} [add_comm_monoid M] {f : α → M} {g : β → α} (hg : set.inj_on g (function.support (f ∘ g))) : finsum (λ (i : α), finsum (λ (H : i ∈ set.range g), f i)) = finsum (λ (j : β), f (g j))
theorem cont_diff_of_differentiable_iterated_deriv {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {n : with_top ℕ} (h : ∀ (m : ℕ), ↑m ≤ n → differentiable 𝕜 (iterated_deriv m f)) : cont_diff 𝕜 n f
theorem affine.simplex.monge_point_eq_smul_vsub_vadd_circumcenter {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P n) : s.monge_point = (↑(n + 1) / ↑(n - 1)) • (finset.centroid ℝ finset.univ s.points -ᵥ s.circumcenter) +ᵥ s.circumcenter
theorem module.free.finrank_tensor_product (R : Type u) [comm_ring R] [strong_rank_condition R] (M : Type v) (N : Type w) [add_comm_group M] [module R M] [module.free R M] [add_comm_group N] [module R N] [module.free R N] : finite_dimensional.finrank R (tensor_product R M N) = finite_dimensional.finrank R M * finite_dimensional.finrank R N
theorem polynomial.root_multiplicity_of_dvd {R : Type u} [comm_ring R] [is_domain R] {p : polynomial R} {a : R} {n : ℕ} (hzero : p ≠ 0) (h : (polynomial.X - ⇑polynomial.C a) ^ n ∣ p) : n ≤ polynomial.root_multiplicity a p
theorem finset.all_card_le_bUnion_card_iff_exists_injective' {ι : Type u_1} {α : Type u_2} [fintype ι] [decidable_eq α] (t : ι → finset α) : (∀ (s : finset ι), s.card ≤ (s.bUnion t).card) ↔ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x
theorem local_equiv.eq_on_source.eq_on {α : Type u_1} {β : Type u_2} {e e' : local_equiv α β} (h : e ≈ e') : set.eq_on ⇑e ⇑e' e.source
theorem linear_map.bound_of_ball_bound' {𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {r : ℝ} (r_pos : 0 < r) (c : ℝ) (f : E →ₗ[𝕜] 𝕜) (h : ∀ (z : E), z ∈ metric.closed_ball 0 r → ∥⇑f z∥ ≤ c) (z : E) : ∥⇑f z∥ ≤ c / r * ∥z∥
theorem emetric.is_closed_subsets_of_is_closed {α : Type u} [emetric_space α] {s : set α} (hs : is_closed s) : is_closed {t : topological_space.closeds α | ↑t ⊆ s}
theorem continuous.tendsto' {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (hf : continuous f) (x : α) (y : β) (h : f x = y) : filter.tendsto f (nhds x) (nhds y)
theorem measure_theory.mem_ℒp.snorm_indicator_norm_ge_pos_le {α : Type u_1} {β : Type u_2} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} {f : α → β} (hf : measure_theory.mem_ℒp f p μ) (hmeas : measure_theory.strongly_measurable f) {ε : ℝ} (hε : 0 < ε) : ∃ (M : ℝ), 0 < M ∧ measure_theory.snorm ({x : α | M ≤ ↑∥f x∥₊}.indicator f) p μ ≤ ennreal.of_real ε
theorem cont_diff_on_of_locally_cont_diff_on {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {n : with_top ℕ} (h : ∀ (x : E), x ∈ s → (∃ (u : set E), is_open u ∧ x ∈ u ∧ cont_diff_on 𝕜 n f (s ∩ u))) : cont_diff_on 𝕜 n f s
theorem category_theory.limits.fork.is_limit.hom_iso_natural {C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} {t : category_theory.limits.fork f g} (ht : category_theory.limits.is_limit t) {Z Z' : C} (q : Z' ⟶ Z) (k : Z ⟶ t.X) : ↑(⇑(category_theory.limits.fork.is_limit.hom_iso ht Z') (q ≫ k)) = q ≫ ↑(⇑(category_theory.limits.fork.is_limit.hom_iso ht Z) k)
theorem local_homeomorph.has_deriv_at_symm {𝕜 : Type u} [nondiscrete_normed_field 𝕜] (f : local_homeomorph 𝕜 𝕜) {a f' : 𝕜} (ha : a ∈ f.to_local_equiv.target) (hf' : f' ≠ 0) (htff' : has_deriv_at ⇑f f' (⇑(f.symm) a)) : has_deriv_at ⇑(f.symm) f'⁻¹ a
theorem dense.diff_singleton {α : Type u} [topological_space α] [t1_space α] {s : set α} (hs : dense s) (x : α) [(nhds_within x {x}ᶜ).ne_bot] : dense (s  {x})
theorem measure_theory.tendsto_Lp_of_tendsto_ae_of_meas {α : Type u_1} {β : Type u_2} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} [measure_theory.is_finite_measure μ] (hp : 1 ≤ p) (hp' : p ≠ ⊤) {f : ℕ → α → β} {g : α → β} (hf : ∀ (n : ℕ), measure_theory.strongly_measurable (f n)) (hg : measure_theory.strongly_measurable g) (hg' : measure_theory.mem_ℒp g p μ) (hui : measure_theory.unif_integrable f p μ) (hfg : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (nhds (g x))) : filter.tendsto (λ (n : ℕ), measure_theory.snorm (f n - g) p μ) filter.at_top (nhds 0)
theorem is_coatom.covby_top {α : Type u_1} [partial_order α] [order_top α] {a : α} : is_coatom a → a ⋖ ⊤
theorem tendsto_of_tendsto_of_tendsto_of_le_of_le' {α : Type u} {β : Type v} [topological_space α] [partial_order α] [t : order_topology α] {f g h : β → α} {b : filter β} {a : α} (hg : filter.tendsto g b (nhds a)) (hh : filter.tendsto h b (nhds a)) (hgf : ∀ᶠ (b : β) in b, g b ≤ f b) (hfh : ∀ᶠ (b : β) in b, f b ≤ h b) : filter.tendsto f b (nhds a)
theorem monotone_stabilizes_iff_artinian {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] : (∀ (f : ℕ →o (submodule R M)ᵒᵈ), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m) ↔ is_artinian R M
theorem is_localization.eq_of_eq {R : Type u_1} [comm_semiring R] {M : submonoid R} {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] {g : R →+* P} (hg : ∀ (y : ↥M), is_unit (⇑g ↑y)) {x y : R} (h : ⇑(algebra_map R S) x = ⇑(algebra_map R S) y) : ⇑g x = ⇑g y
theorem is_regular_of_ne_zero {R : Type u_1} {a : R} [cancel_monoid_with_zero R] (a0 : a ≠ 0) : is_regular a
theorem nat.dvd_right_iff_eq {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n
theorem minpoly.irreducible {A : Type u_1} {B : Type u_2} [comm_ring A] [is_domain A] [ring B] [algebra A B] {x : B} [is_domain B] (hx : is_integral A x) : irreducible (minpoly A x)
theorem add_monoid_hom.mk_normed_group_hom_norm_le {V₁ : Type u_2} {V₂ : Type u_3} [semi_normed_group V₁] [semi_normed_group V₂] (f : V₁ →+ V₂) {C : ℝ} (hC : 0 ≤ C) (h : ∀ (x : V₁), ∥⇑f x∥ ≤ C * ∥x∥) : ∥f.mk_normed_group_hom C h∥ ≤ C
theorem antitone_on.map_bdd_below {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s t : set α} (Hf : antitone_on f t) (Hst : s ⊆ t) : (lower_bounds s ∩ t).nonempty → bdd_above (f '' s)
theorem graded_monoid.list_prod_map_eq_dprod {ι : Type u_1} {α : Type u_2} {A : ι → Type u_3} [add_monoid ι] [graded_monoid.gmonoid A] (l : list α) (f : α → graded_monoid A) : (list.map f l).prod = graded_monoid.mk (l.dprod_index (λ (i : α), (f i).fst)) (l.dprod (λ (i : α), (f i).fst) (λ (i : α), (f i).snd))
theorem filter.tendsto.at_top_mul_const' {α : Type u_1} {R : Type u_2} {l : filter α} {f : α → R} {r : R} [linear_ordered_semiring R] [archimedean R] (hr : 0 < r) (hf : filter.tendsto f l filter.at_top) : filter.tendsto (λ (x : α), f x * r) l filter.at_top
theorem measure_theory.measure_preserving.conservative {α : Type u_2} [measurable_space α] {f : α → α} {μ : measure_theory.measure α} [measure_theory.is_finite_measure μ] (h : measure_theory.measure_preserving f μ μ) : measure_theory.conservative f μ
theorem eq.superset {α : Type u} [has_subset α] {a b : α} [is_refl α has_subset.subset] : a = b → b ⊆ a
theorem mem_nhds_within_Iic_iff_exists_Icc_subset' {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_min_order α] [densely_ordered α] {a : α} {s : set α} : s ∈ nhds_within a (set.Iic a) ↔ ∃ (l : α) (H : l ∈ set.Iio a), set.Icc l a ⊆ s
theorem minpoly.dvd (A : Type u_1) {B : Type u_2} [field A] [ring B] [algebra A B] (x : B) {p : polynomial A} (hp : ⇑(polynomial.aeval x) p = 0) : minpoly A x ∣ p
theorem finset.image_image₂_antidistrib_right {α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} [decidable_eq α'] [decidable_eq γ] [decidable_eq δ] {f : α → β → γ} {s : finset α} {t : finset β} {g : γ → δ} {f' : β → α' → δ} {g' : α → α'} (h_antidistrib : ∀ (a : α) (b : β), g (f a b) = f' b (g' a)) : finset.image g (finset.image₂ f s t) = finset.image₂ f' t (finset.image g' s)
theorem is_group_hom.id {α : Type u} [group α] : is_group_hom id
theorem continuous.exists_forall_ge' {α : Type u_1} {β : Type u_2} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [topological_space β] {f : β → α} (hf : continuous f) (x₀ : β) (h : ∀ᶠ (x : β) in filter.cocompact β, f x ≤ f x₀) : ∃ (x : β), ∀ (y : β), f y ≤ f x
theorem set.mem_bInter {α : Type u_1} {β : Type u_2} {s : set α} {t : α → set β} {y : β} (h : ∀ (x : α), x ∈ s → y ∈ t x) : y ∈ ⋂ (x : α) (H : x ∈ s), t x
theorem circle_deg1_lift.forall_map_sub_of_Icc (f : circle_deg1_lift) (P : ℝ → Prop) (h : ∀ (x : ℝ), x ∈ set.Icc 0 1 → P (⇑f x - x)) (x : ℝ) : P (⇑f x - x)
theorem finrank_vector_span_image_finset_le (k : Type u_1) {V : Type u_2} {P : Type u_3} {ι : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : ι → P) (s : finset ι) {n : ℕ} (hc : s.card = n + 1) : finite_dimensional.finrank k ↥(vector_span k ↑(finset.image p s)) ≤ n
theorem local_homeomorph.continuous_within_at_iff_continuous_within_at_comp_left {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] (e : local_homeomorph α β) {f : γ → α} {s : set γ} {x : γ} (hx : f x ∈ e.to_local_equiv.source) (h : f ⁻¹' e.to_local_equiv.source ∈ nhds_within x s) : continuous_within_at f s x ↔ continuous_within_at (⇑e ∘ f) s x
theorem function.injective.pairwise_ne {α : Type u_1} {ι : Type u_2} {f : ι → α} : function.injective f → pairwise (ne on f)
theorem sym.map_id' {α : Type u_1} {n : ℕ} (s : sym α n) : sym.map (λ (x : α), x) s = s
theorem representation.char_one {k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_ring k] [group G] [add_comm_group V] [module k V] (ρ : representation k G V) [nontrivial k] [module.free k V] [module.finite k V] : ρ.character 1 = ↑(finite_dimensional.finrank k V)
theorem affine_map.decomp {k : Type u_1} {V1 : Type u_2} {V2 : Type u_4} [ring k] [add_comm_group V1] [module k V1] [add_comm_group V2] [module k V2] (f : V1 →ᵃ[k] V2) : ⇑f = ⇑(f.linear) + λ (z : V1), ⇑f 0
theorem phragmen_lindelof.quadrant_II {E : Type u_1} [normed_group E] [normed_space ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ} (hd : diff_cont_on_cl ℂ f (set.Iio 0 ×ℂ set.Ioi 0)) (hB : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ filter.principal (set.Iio 0 ×ℂ set.Ioi 0)] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hre : ∀ (x : ℝ), x ≤ 0 → ∥f ↑x∥ ≤ C) (him : ∀ (x : ℝ), 0 ≤ x → ∥f (↑x * complex.I)∥ ≤ C) (hz_re : z.re ≤ 0) (hz_im : 0 ≤ z.im) : ∥f z∥ ≤ C
theorem add_monoid_algebra.exists_finset_adjoin_eq_top {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_monoid M] [h : algebra.finite_type R (add_monoid_algebra R M)] : ∃ (G : finset M), algebra.adjoin R (add_monoid_algebra.of' R M '' ↑G) = ⊤
theorem first_order.language.substructure.dense_induction {L : first_order.language} {M : Type w} [L.Structure M] {p : M → Prop} (x : M) {s : set M} (hs : ⇑(first_order.language.substructure.closure L) s = ⊤) (Hs : ∀ (x : M), x ∈ s → p x) (Hfun : ∀ {n : ℕ} (f : L.functions n), first_order.language.closed_under f (set_of p)) : p x
theorem box_integral.box.subbox_induction_on' {ι : Type u_1} {p : box_integral.box ι → Prop} (I : box_integral.box ι) (H_ind : ∀ (J : box_integral.box ι), J ≤ I → (∀ (s : set ι), p (J.split_center_box s)) → p J) (H_nhds : ∀ (z : ι → ℝ), z ∈ ⇑box_integral.box.Icc I → (∃ (U : set (ι → ℝ)) (H : U ∈ nhds_within z (⇑box_integral.box.Icc I)), ∀ (J : box_integral.box ι), J ≤ I → ∀ (m : ℕ), z ∈ ⇑box_integral.box.Icc J → ⇑box_integral.box.Icc J ⊆ U → (∀ (i : ι), J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) → p J)) : p I
theorem analytic_on.iterated_fderiv {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {s : set E} [complete_space F] (h : analytic_on 𝕜 f s) (n : ℕ) : analytic_on 𝕜 (iterated_fderiv 𝕜 n f) s
theorem add_submonoid.localization_map.lift_mk' {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M →+ P} (hg : ∀ (y : ↥S), is_add_unit (⇑g ↑y)) (x : M) (y : ↥S) : ⇑(f.lift hg) (f.mk' x y) = ⇑g x + ↑-⇑(is_add_unit.lift_right (g.restrict S) hg) y
theorem fintype.card_compl_eq_card_compl {α : Type u_1} [fintype α] (p q : α → Prop) [fintype {x // p x}] [fintype {x // ¬p x}] [fintype {x // q x}] [fintype {x // ¬q x}] (h : fintype.card {x // p x} = fintype.card {x // q x}) : fintype.card {x // ¬p x} = fintype.card {x // ¬q x}
theorem category_theory.presieve.is_sheaf_for_iso {C : Type u₁} [category_theory.category C] {P : Cᵒᵖ ⥤ Type w} {X : C} {R : category_theory.presieve X} {P' : Cᵒᵖ ⥤ Type w} (i : P ≅ P') : category_theory.presieve.is_sheaf_for P R → category_theory.presieve.is_sheaf_for P' R
theorem convex.norm_image_sub_le_of_norm_has_deriv_within_le {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_group G] [normed_space 𝕜 G] {f f' : 𝕜 → G} {s : set 𝕜} {x y : 𝕜} {C : ℝ} (hf : ∀ (x : 𝕜), x ∈ s → has_deriv_within_at f (f' x) s x) (bound : ∀ (x : 𝕜), x ∈ s → ∥f' x∥ ≤ C) (hs : convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∥f y - f x∥ ≤ C * ∥y - x∥
theorem finprod_mem_insert' {α : Type u_1} {M : Type u_5} [comm_monoid M] {a : α} {s : set α} (f : α → M) (h : a ∉ s) (hs : (s ∩ function.mul_support f).finite) : finprod (λ (i : α), finprod (λ (H : i ∈ has_insert.insert a s), f i)) = f a * finprod (λ (i : α), finprod (λ (H : i ∈ s), f i))
theorem is_local_min_on.has_fderiv_within_at_nonneg {E : Type u} [normed_group E] [normed_space ℝ E] {f : E → ℝ} {a : E} {f' : E →L[ℝ] ℝ} {s : set E} (h : is_local_min_on f s a) (hf : has_fderiv_within_at f f' s a) {y : E} (hy : y ∈ pos_tangent_cone_at s a) : 0 ≤ ⇑f' y
theorem nonempty_sections_of_fintype_inverse_system {J : Type u} [preorder J] [is_directed J has_le.le] (F : Jᵒᵖ ⥤ Type v) [Π (j : Jᵒᵖ), fintype (F.obj j)] [∀ (j : Jᵒᵖ), nonempty (F.obj j)] : F.sections.nonempty
theorem hindman.exists_FP_of_finite_cover {M : Type u_1} [semigroup M] [nonempty M] (s : set (set M)) (sfin : s.finite) (scov : ⊤ ⊆ ⋃₀s) : ∃ (c : set M) (H : c ∈ s) (a : stream M), hindman.FP a ⊆ c
theorem monotone.cauchy_seq_series_mul_of_tendsto_zero_of_bounded {E : Type u_4} [normed_group E] [normed_space ℝ E] {b : ℝ} {f : ℕ → ℝ} {z : ℕ → E} (hfa : monotone f) (hf0 : filter.tendsto f filter.at_top (nhds 0)) (hgb : ∀ (n : ℕ), ∥(finset.range n).sum (λ (i : ℕ), z i)∥ ≤ b) : cauchy_seq (λ (n : ℕ), (finset.range (n + 1)).sum (λ (i : ℕ), f i • z i))
theorem neg_dvd {α : Type u} [semigroup α] [has_distrib_neg α] (a b : α) : -a ∣ b ↔ a ∣ b
theorem metric.tendsto_uniformly_iff {α : Type u} {β : Type v} [pseudo_metric_space α] {ι : Type u_1} {F : ι → β → α} {f : β → α} {p : filter ι} : tendsto_uniformly F f p ↔ ∀ (ε : ℝ), ε > 0 → (∀ᶠ (n : ι) in p, ∀ (x : β), has_dist.dist (f x) (F n x) < ε)
theorem basis.map_orientation_eq_det_inv_smul {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {ι : Type u_4} [fintype ι] [decidable_eq ι] (e : basis ι R M) (x : orientation R M ι) (f : M ≃ₗ[R] M) : ⇑(orientation.map ι f) x = (⇑linear_equiv.det f)⁻¹ • x
theorem finset.univ_perm_option {α : Type u_1} [decidable_eq α] [fintype α] : finset.univ = finset.map equiv.perm.decompose_option.symm.to_embedding finset.univ
theorem cauchy_seq_range_of_norm_bounded {E : Type u_3} [semi_normed_group E] {f : ℕ → E} (g : ℕ → ℝ) (hg : cauchy_seq (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), g i))) (hf : ∀ (i : ℕ), ∥f i∥ ≤ g i) : cauchy_seq (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), f i))
theorem set.finite.is_closed_convex_hull {E : Type u_2} [add_comm_group E] [module ℝ E] [topological_space E] [topological_add_group E] [has_continuous_smul ℝ E] [t2_space E] {s : set E} (hs : s.finite) : is_closed (⇑(convex_hull ℝ) s)
theorem matrix.pivot.is_two_block_diagonal_list_transvec_col_mul_mul_list_transvec_row {𝕜 : Type u_3} [field 𝕜] {r : ℕ} (M : matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜) (hM : M (sum.inr ()) (sum.inr ()) ≠ 0) : (((matrix.pivot.list_transvec_col M).prod.mul M).mul (matrix.pivot.list_transvec_row M).prod).is_two_block_diagonal
theorem affine_subspace.direction_mk' {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) (direction : submodule k V) : (affine_subspace.mk' p direction).direction = direction
theorem eq.trans_ge {α : Type u} [preorder α] {a b c : α} : b = c → a ≤ b → a ≤ c
theorem orientation.eq_iff_norm_eq_of_oangle_eq_zero {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y : V} (h : o.oangle x y = 0) : x = y ↔ ∥x∥ = ∥y∥
theorem list.intercalate_split_on {α : Type u} (xs : list α) (x : α) [decidable_eq α] : [x].intercalate (list.split_on x xs) = xs
theorem norm_image_of_norm_zero {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {f : E →ₛₗ[σ₁₂] F} (hf : continuous ⇑f) {x : E} (hx : ∥x∥ = 0) : ∥⇑f x∥ = 0
theorem list.exists_chain_of_relation_refl_trans_gen {α : Type u} {r : α → α → Prop} {a b : α} (h : relation.refl_trans_gen r a b) : ∃ (l : list α), list.chain r a l ∧ (a :: l).last _ = b
theorem subfield.zero_mem {K : Type u} [field K] (s : subfield K) : 0 ∈ s
theorem submonoid.mem_closure_pair {A : Type u_1} [comm_monoid A] (a b c : A) : c ∈ submonoid.closure {a, b} ↔ ∃ (m n : ℕ), a ^ m * b ^ n = c
theorem mv_polynomial.mem_ideal_of_coeff_mem_ideal {R : Type u} {σ : Type v} [comm_ring R] (I : ideal (mv_polynomial σ R)) (p : mv_polynomial σ R) (hcoe : ∀ (m : σ →₀ ℕ), mv_polynomial.coeff m p ∈ ideal.comap mv_polynomial.C I) : p ∈ I
theorem first_order.language.exists_cg_is_age_of {L : first_order.language} {K : set (category_theory.bundled L.Structure)} (hn : K.nonempty) (h : ∀ (M N : category_theory.bundled L.Structure), nonempty (L.equiv ↥M ↥N) → (M ∈ K ↔ N ∈ K)) (hc : (quotient.mk '' K).countable) (fg : ∀ (M : category_theory.bundled L.Structure), M ∈ K → first_order.language.Structure.fg L ↥M) (hp : first_order.language.hereditary K) (jep : first_order.language.joint_embedding K) : ∃ (M : category_theory.bundled L.Structure), first_order.language.Structure.cg L ↥M ∧ L.age ↥M = K
theorem set.finset_sum_subset_finset_sum {α : Type u_2} {ι : Type u_5} [add_comm_monoid α] (t : finset ι) (f₁ f₂ : ι → set α) (hf : ∀ {i : ι}, i ∈ t → f₁ i ⊆ f₂ i) : t.sum (λ (i : ι), f₁ i) ⊆ t.sum (λ (i : ι), f₂ i)
theorem topological_fiber_bundle.trivialization.continuous_at_proj {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] (e : topological_fiber_bundle.trivialization F proj) {x : Z} (ex : x ∈ e.to_local_homeomorph.to_local_equiv.source) : continuous_at proj x
theorem matrix.is_unit_diagonal {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {v : n → α} : is_unit (matrix.diagonal v) ↔ is_unit v
theorem real.sign_apply_eq_of_ne_zero (r : ℝ) (h : r ≠ 0) : r.sign = -1 ∨ r.sign = 1
theorem fermat_42.coprime_of_minimal {a b c : ℤ} (h : fermat_42.minimal a b c) : is_coprime a b
theorem ordered_add_comm_group.lt_of_add_lt_add_left {α : Type u_1} [has_add α] [has_lt α] [contravariant_class α α has_add.add has_lt.lt] {a b c : α} (bc : a + b < a + c) : b < c
theorem has_subset.subset.eq_or_ssubset {α : Type u} [has_subset α] [has_ssubset α] [is_nonstrict_strict_order α has_subset.subset has_ssubset.ssubset] {a b : α} [is_antisymm α has_subset.subset] (h : a ⊆ b) : a = b ∨ a ⊂ b
theorem interval_integral.integral_comp_mul_deriv'' {a b : ℝ} {f f' g : ℝ → ℝ} (hf : continuous_on f (set.interval a b)) (hff' : ∀ (x : ℝ), x ∈ set.Ioo (linear_order.min a b) (linear_order.max a b) → has_deriv_within_at f (f' x) (set.Ioi x) x) (hf' : continuous_on f' (set.interval a b)) (hg : continuous_on g (f '' set.interval a b)) : ∫ (x : ℝ) in a..b, (g ∘ f) x * f' x = ∫ (u : ℝ) in f a..f b, g u
theorem pgame.lf_def {x y : pgame} : x.lf y ↔ (∃ (i : y.left_moves), (∀ (i' : x.left_moves), (x.move_left i').lf (y.move_left i)) ∧ ∀ (j : (y.move_left i).right_moves), x.lf ((y.move_left i).move_right j)) ∨ ∃ (j : x.right_moves), (∀ (i : (x.move_right j).left_moves), ((x.move_right j).move_left i).lf y) ∧ ∀ (j' : y.right_moves), (x.move_right j).lf (y.move_right j')
theorem subsemigroup.closure_mono {M : Type u_1} [has_mul M] ⦃s t : set M⦄ (h : s ⊆ t) : subsemigroup.closure s ≤ subsemigroup.closure t
theorem submodule.span_le_restrict_scalars (R : Type u_1) {M : Type u_4} (S : Type u_7) [semiring R] [add_comm_monoid M] [module R M] (s : set M) [semiring S] [has_scalar R S] [module S M] [is_scalar_tower R S M] : submodule.span R s ≤ submodule.restrict_scalars R (submodule.span S s)
theorem free_group.red.singleton_iff {α : Type u} {L₁ : list (α × bool)} {x : α × bool} : free_group.red [x] L₁ ↔ L₁ = [x]
theorem well_founded_gt_exact_sequence {α : Type u_1} [lattice α] [is_modular_lattice α] {β : Type u_2} {γ : Type u_3} [preorder β] [partial_order γ] (h₁ : well_founded gt) (h₂ : well_founded gt) (K : α) (f₁ : β → α) (f₂ : α → β) (g₁ : γ → α) (g₂ : α → γ) (gci : galois_coinsertion f₁ f₂) (gi : galois_insertion g₂ g₁) (hf : ∀ (a : α), f₁ (f₂ a) = a ⊓ K) (hg : ∀ (a : α), g₁ (g₂ a) = a ⊔ K) : well_founded gt
theorem bernstein_approximation.lt_of_mem_S {f : C(↥unit_interval, ℝ)} {ε : ℝ} {h : 0 < ε} {n : ℕ} {x : ↥unit_interval} {k : fin (n + 1)} (m : k ∈ bernstein_approximation.S f ε h n x) : |⇑f (bernstein.z k) - ⇑f x| < ε / 2
theorem complex.has_strict_deriv_at_sin (x : ℂ) : has_strict_deriv_at complex.sin (complex.cos x) x
theorem complete_lattice.independent.pairwise_disjoint {α : Type u_1} {ι : Type u_3} [complete_lattice α] {t : ι → α} (ht : complete_lattice.independent t) : pairwise (disjoint on t)
theorem ray_vector.coe_neg {M : Type u_2} [add_comm_group M] {R : Type u_1} (v : ray_vector R M) : ↑-v = -↑v
theorem multilinear_map.map_smul_univ {R : Type u} {ι : Type u'} {M₁ : ι → Type v₁} {M₂ : Type v₂} [decidable_eq ι] [comm_semiring R] [Π (i : ι), add_comm_monoid (M₁ i)] [add_comm_monoid M₂] [Π (i : ι), module R (M₁ i)] [module R M₂] (f : multilinear_map R M₁ M₂) [fintype ι] (c : ι → R) (m : Π (i : ι), M₁ i) : ⇑f (λ (i : ι), c i • m i) = finset.univ.prod (λ (i : ι), c i) • ⇑f m
theorem nat.multiplicity_eq_card_pow_dvd {m n b : ℕ} (hm : m ≠ 1) (hn : 0 < n) (hb : nat.log m n < b) : multiplicity m n = ↑((finset.filter (λ (i : ℕ), m ^ i ∣ n) (finset.Ico 1 b)).card)
theorem submodule.is_internal_prime_power_torsion_of_is_torsion_by_ideal {R : Type u} [comm_ring R] [is_domain R] {M : Type v} [add_comm_group M] [module R M] [is_dedekind_domain R] {I : ideal R} (hI : I ≠ ⊥) (hM : module.is_torsion_by_set R M ↑I) : ∃ (P : finset (ideal R)) [_inst_6 : decidable_eq ↥P] [_inst_7 : ∀ (p : ideal R), p ∈ P → prime p] (e : ↥P → ℕ), direct_sum.is_internal (λ (p : ↥P), submodule.torsion_by_set R M ↑(↑p ^ e p))
theorem continuous.integrable_of_has_compact_support {X : Type u_1} {E : Type u_3} [measurable_space X] [topological_space X] [normed_group E] {f : X → E} {μ : measure_theory.measure X} [opens_measurable_space X] [topological_space.metrizable_space X] [measure_theory.is_locally_finite_measure μ] (hf : continuous f) (hcf : has_compact_support f) : measure_theory.integrable f μ
theorem cardinal.exists_infinite_fiber {β α : Type u_1} (f : β → α) (w : cardinal.mk α < cardinal.mk β) (w' : infinite α) : ∃ (a : α), infinite ↥(f ⁻¹' {a})
theorem free_abelian_group.lift.ext {α : Type u} {β : Type v} [add_comm_group β] (g h : free_abelian_group α →+ β) (H : ∀ (x : α), ⇑g (free_abelian_group.of x) = ⇑h (free_abelian_group.of x)) : g = h
theorem basis.range_reindex' {ι : Type u_1} {ι' : Type u_2} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (b : basis ι R M) (e : ι ≃ ι') : set.range (⇑b ∘ ⇑(e.symm)) = set.range ⇑b
theorem generalized_continued_fraction.of_correctness_of_nth_stream_eq_none {K : Type u_1} [linear_ordered_field K] {v : K} {n : ℕ} [floor_ring K] (nth_stream_eq_none : generalized_continued_fraction.int_fract_pair.stream v n = option.none) : v = (generalized_continued_fraction.of v).convergents (n - 1)
theorem continuous_multilinear_map.unit_le_op_norm {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : continuous_multilinear_map 𝕜 E G) (m : Π (i : ι), E i) (h : ∥m∥ ≤ 1) : ∥⇑f m∥ ≤ ∥f∥
theorem nonempty_measurable_superset {α : Type u_1} {m : measurable_space α} (s : set α) : nonempty {t // s ⊆ t ∧ measurable_set t}
theorem filter.coprod_cofinite {α : Type u_2} {β : Type u_3} : filter.cofinite.coprod filter.cofinite = filter.cofinite
theorem uniformity_has_basis_open_symmetric {α : Type u_1} [uniform_space α] : (uniformity α).has_basis (λ (V : set (α × α)), V ∈ uniformity α ∧ is_open V ∧ symmetric_rel V) id
theorem dvd_add_self_right {α : Type u} [ring α] {a b : α} : a ∣ b + a ↔ a ∣ b
theorem strict_mono_on.Iic_union_Ici {α : Type u_1} {β : Type u_2} [linear_order α] [preorder β] {a : α} {f : α → β} (h₁ : strict_mono_on f (set.Iic a)) (h₂ : strict_mono_on f (set.Ici a)) : strict_mono f
theorem equiv.perm.is_three_cycle.alternating_normal_closure {α : Type u_1} [fintype α] [decidable_eq α] (h5 : 5 ≤ fintype.card α) {f : equiv.perm α} (hf : f.is_three_cycle) : subgroup.normal_closure {⟨f, _⟩} = ⊤
theorem add_monoid_hom.map_mclosure {M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (f : M →+ N) (s : set M) : add_submonoid.map f (add_submonoid.closure s) = add_submonoid.closure (⇑f '' s)
theorem fractional_ideal.div_eq_mul_inv {A : Type u_2} {K : Type u_3} [comm_ring A] [field K] [is_domain A] [algebra A K] [is_fraction_ring A K] [is_dedekind_domain A] (I J : fractional_ideal (non_zero_divisors A) K) : I / J = I * J⁻¹
theorem filter.tendsto.add_at_top {α : Type u} {β : Type v} [topological_space α] [linear_ordered_add_comm_group α] [order_topology α] {l : filter β} {f g : β → α} {C : α} (hf : filter.tendsto f l (nhds C)) (hg : filter.tendsto g l filter.at_top) : filter.tendsto (λ (x : β), f x + g x) l filter.at_top
theorem char.quadratic_char_sum_zero {F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F ≠ 2) : finset.univ.sum (λ (a : F), char.quadratic_char F a) = 0
theorem ring_hom.map_one {α : Type u_2} {β : Type u_3} {rα : non_assoc_semiring α} {rβ : non_assoc_semiring β} (f : α →+* β) : ⇑f 1 = 1
theorem collinear_iff_dim_le_one (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : collinear k s ↔ module.rank k ↥(vector_span k s) ≤ 1
theorem dense.inter_of_open_right {α : Type u} [topological_space α] {s t : set α} (hs : dense s) (ht : dense t) (hto : is_open t) : dense (s ∩ t)
theorem multilinear_map.dom_coprod_dom_dom_congr_sum_congr {R : Type u_1} {ι₁ : Type u_2} {ι₂ : Type u_3} {ι₃ : Type u_4} {ι₄ : Type u_5} [comm_semiring R] [decidable_eq ι₁] [decidable_eq ι₂] [decidable_eq ι₃] [decidable_eq ι₄] {N₁ : Type u_6} [add_comm_monoid N₁] [module R N₁] {N₂ : Type u_7} [add_comm_monoid N₂] [module R N₂] {N : Type u_8} [add_comm_monoid N] [module R N] (a : multilinear_map R (λ (_x : ι₁), N) N₁) (b : multilinear_map R (λ (_x : ι₂), N) N₂) (σa : ι₁ ≃ ι₃) (σb : ι₂ ≃ ι₄) : multilinear_map.dom_dom_congr (σa.sum_congr σb) (a.dom_coprod b) = (multilinear_map.dom_dom_congr σa a).dom_coprod (multilinear_map.dom_dom_congr σb b)
theorem metric.mem_closure_iff_inf_dist_zero {α : Type u} [pseudo_metric_space α] {s : set α} {x : α} (h : s.nonempty) : x ∈ closure s ↔ metric.inf_dist x s = 0
theorem left.add_nonpos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0) : a + b ≤ 0
theorem is_fw_invariant.is_invariant {τ : Type u_1} {α : Type u_2} [canonically_ordered_add_monoid τ] {ϕ : τ → α → α} {s : set α} (h : is_fw_invariant ϕ s) : is_invariant ϕ s
theorem submonoid.closure_le {M : Type u_1} [mul_one_class M] {s : set M} {S : submonoid M} : submonoid.closure s ≤ S ↔ s ⊆ ↑S
theorem submonoid.localization_map.inv_unique {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {f : M →* N} (h : ∀ (y : ↥S), is_unit (⇑f ↑y)) {y : ↥S} {z : N} (H : ⇑f ↑y * z = 1) : ↑(⇑(is_unit.lift_right (f.restrict S) h) y)⁻¹ = z
theorem finset.order_emb_of_fin_last {α : Type u_1} [linear_order α] {s : finset α} {k : ℕ} (h : s.card = k) (hz : 0 < k) : ⇑(s.order_emb_of_fin h) ⟨k - 1, _⟩ = s.max' _
theorem semiconj_by.units_inv_symm_left {M : Type u} [monoid M] {a : Mˣ} {x y : M} (h : semiconj_by ↑a x y) : semiconj_by ↑a⁻¹ y x
theorem algebraic_geometry.LocallyRingedSpace.Γ_Spec_left_triangle (X : algebraic_geometry.LocallyRingedSpace) : algebraic_geometry.to_Spec_Γ (algebraic_geometry.LocallyRingedSpace.Γ.obj (opposite.op X)) ≫ X.to_Γ_Spec.val.c.app (opposite.op ⊤) = 𝟙 (algebraic_geometry.LocallyRingedSpace.Γ.obj (opposite.op X))
theorem is_o_coe_const_pow_of_one_lt {R : Type u_1} [normed_ring R] {r : ℝ} (hr : 1 < r) : coe =o[filter.at_top] λ (n : ℕ), r ^ n
theorem measurable_measure_prod_mk_left {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] {s : set (α × β)} (hs : measurable_set s) : measurable (λ (x : α), ⇑ν (prod.mk x ⁻¹' s))
theorem tendsto_of_tendsto_of_dist {α : Type u} [pseudo_metric_space α] {ι : Type u_1} {f₁ f₂ : ι → α} {p : filter ι} {a : α} (h₁ : filter.tendsto f₁ p (nhds a)) (h : filter.tendsto (λ (x : ι), has_dist.dist (f₁ x) (f₂ x)) p (nhds 0)) : filter.tendsto f₂ p (nhds a)
theorem function.cantor_surjective {α : Type u_1} (f : α → set α) : ¬function.surjective f
theorem cont_diff_at.cont_diff_bump {E : Type u_1} {X : Type u_2} [inner_product_space ℝ E] [normed_group X] [normed_space ℝ X] {n : with_top ℕ} {c g : X → E} {f : Π (x : X), cont_diff_bump_of_inner (c x)} {x : X} (hc : cont_diff_at ℝ n c x) (hr : cont_diff_at ℝ n (λ (x : X), (f x).r) x) (hR : cont_diff_at ℝ n (λ (x : X), (f x).R) x) (hg : cont_diff_at ℝ n g x) : cont_diff_at ℝ n (λ (x : X), ⇑(f x) (g x)) x
theorem exists_nat_pow_near_of_lt_one {α : Type u_1} [linear_ordered_field α] [archimedean α] {x y : α} (xpos : 0 < x) (hx : x ≤ 1) (ypos : 0 < y) (hy : y < 1) : ∃ (n : ℕ), y ^ (n + 1) < x ∧ x ≤ y ^ n
theorem subring.list_prod_mem {R : Type u} [ring R] (s : subring R) {l : list R} : (∀ (x : R), x ∈ l → x ∈ s) → l.prod ∈ s
theorem category_theory.grothendieck_topology.plus.is_sheaf_of_sep {C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] [∀ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)ᵒᵖ D] [∀ (P : Cᵒᵖ ⥤ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [Π (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)ᵒᵖ (category_theory.forget D)] [category_theory.reflects_isomorphisms (category_theory.forget D)] (P : Cᵒᵖ ⥤ D) (hsep : ∀ (X : C) (S : J.cover X) (x y : ↥(P.obj (opposite.op X))), (∀ (I : S.arrow), ⇑(P.map I.f.op) x = ⇑(P.map I.f.op) y) → x = y) : category_theory.presheaf.is_sheaf J (J.plus_obj P)
theorem finite_dimensional.proper_is_R_or_C (K : Type u_1) [is_R_or_C K] (E : Type u_2) [normed_group E] [normed_space K E] [finite_dimensional K E] : proper_space E
theorem measure_theory.tendsto_set_lintegral_zero {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {ι : Type u_2} {f : α → ennreal} (h : ∫⁻ (x : α), f x ∂μ ≠ ⊤) {l : filter ι} {s : ι → set α} (hl : filter.tendsto (⇑μ ∘ s) l (nhds 0)) : filter.tendsto (λ (i : ι), ∫⁻ (x : α) in s i, f x ∂μ) l (nhds 0)
theorem exists_Union_eq_closure_subset {ι : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : ι → set X} (uo : ∀ (i : ι), is_open (u i)) (uf : ∀ (x : X), {i : ι | x ∈ u i}.finite) (uU : (⋃ (i : ι), u i) = set.univ) : ∃ (v : ι → set X), set.Union v = set.univ ∧ (∀ (i : ι), is_open (v i)) ∧ ∀ (i : ι), closure (v i) ⊆ u i
theorem ring_hom.map_field_closure {K : Type u} {L : Type v} [field K] [field L] (f : K →+* L) (s : set K) : subfield.map f (subfield.closure s) = subfield.closure (⇑f '' s)
theorem emetric.diam_le {α : Type u} [pseudo_emetric_space α] {s : set α} {d : ennreal} (h : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → has_edist.edist x y ≤ d) : emetric.diam s ≤ d
theorem orientation.oangle_map {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x y : V) (f : V ≃ₗᵢ[ℝ] V) : (⇑(orientation.map (fin 2) f.to_linear_equiv) o).oangle x y = o.oangle (⇑(f.symm) x) (⇑(f.symm) y)
theorem measurable_space.cardinal_measurable_set_le_continuum {α : Type u} {s : set (set α)} : cardinal.mk ↥s ≤ cardinal.continuum → cardinal.mk ↥{t : set α | measurable_set t} ≤ cardinal.continuum
theorem is_open.is_Gδ {α : Type u_1} [topological_space α] {s : set α} (h : is_open s) : is_Gδ s
theorem ring.direct_limit.of_injective {ι : Type v} [preorder ι] {G : ι → Type w} [Π (i : ι), comm_ring (G i)] (f' : Π (i j : ι), i ≤ j → G i →+* G j) [is_directed ι has_le.le] [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f' i j h))] (hf : ∀ (i j : ι) (hij : i ≤ j), function.injective ⇑(f' i j hij)) (i : ι) : function.injective ⇑(ring.direct_limit.of G (λ (i j : ι) (h : i ≤ j), ⇑(f' i j h)) i)
theorem is_primitive_root.norm_eq_one {n : ℕ+} {K : Type u} {L : Type v} [field L] {ζ : L} (hζ : is_primitive_root ζ ↑n) [field K] [algebra K L] [ne_zero ↑↑n] [is_cyclotomic_extension {n} K L] (hn : n ≠ 2) (hirr : irreducible (polynomial.cyclotomic ↑n K)) : ⇑(algebra.norm K) ζ = 1
theorem continuous_linear_map.op_norm_comp_le {𝕜 : Type u_1} {𝕜₂ : Type u_2} {𝕜₃ : Type u_3} {E : Type u_4} {F : Type u_6} {G : Type u_8} [semi_normed_group E] [semi_normed_group F] [semi_normed_group G] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [nondiscrete_normed_field 𝕜₃] [normed_space 𝕜 E] [normed_space 𝕜₂ F] [normed_space 𝕜₃ G] {σ₁₂ : 𝕜 →+* 𝕜₂} {σ₂₃ : 𝕜₂ →+* 𝕜₃} {σ₁₃ : 𝕜 →+* 𝕜₃} [ring_hom_comp_triple σ₁₂ σ₂₃ σ₁₃] [ring_hom_isometric σ₁₂] [ring_hom_isometric σ₂₃] (h : F →SL[σ₂₃] G) (f : E →SL[σ₁₂] F) : ∥h.comp f∥ ≤ ∥h∥ * ∥f∥
theorem measure_theory.measure_eq_div_smul {G : Type u_1} [measurable_space G] [group G] [has_measurable_mul₂ G] (μ ν : measure_theory.measure G) [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] {E : set G} [has_measurable_inv G] [μ.is_mul_left_invariant] [ν.is_mul_left_invariant] (hE : measurable_set E) (h2E : ⇑ν E ≠ 0) (h3E : ⇑ν E ≠ ⊤) : μ = (⇑μ E / ⇑ν E) • ν
theorem summable_of_norm_bounded {ι : Type u_1} {E : Type u_3} [semi_normed_group E] [complete_space E] {f : ι → E} (g : ι → ℝ) (hg : summable g) (h : ∀ (i : ι), ∥f i∥ ≤ g i) : summable f
theorem affine_independent.mono {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s t : set P} (ha : affine_independent k (λ (x : ↥t), ↑x)) (hs : s ⊆ t) : affine_independent k (λ (x : ↥s), ↑x)
theorem Top.presheaf.presieve_of_covering.mem_grothendieck_topology {X : Top} {ι : Type v} (U : ι → topological_space.opens ↥X) : category_theory.sieve.generate (Top.presheaf.presieve_of_covering U) ∈ ⇑(opens.grothendieck_topology ↥X) (supr U)
theorem multilinear_map.mk_continuous_norm_le' {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : multilinear_map 𝕜 E G) {C : ℝ} (H : ∀ (m : Π (i : ι), E i), ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : ι), ∥m i∥)) : ∥f.mk_continuous C H∥ ≤ linear_order.max C 0
theorem list.exists_of_mem_map {α : Type u} {β : Type v} {f : α → β} {b : β} {l : list α} : b ∈ list.map f l → (∃ (a : α), a ∈ l ∧ f a = b)
theorem complete_lattice.independent_iff_sup_indep_univ {α : Type u_1} {ι : Type u_3} [complete_lattice α] [fintype ι] {f : ι → α} : complete_lattice.independent f ↔ finset.univ.sup_indep f
theorem is_add_right_regular.add {R : Type u_1} {a b : R} [add_semigroup R] (rra : is_add_right_regular a) (rrb : is_add_right_regular b) : is_add_right_regular (a + b)
theorem set.image_image {α : Type u} {β : Type v} {γ : Type w} (g : β → γ) (f : α → β) (s : set α) : g '' (f '' s) = (λ (x : α), g (f x)) '' s
theorem lebesgue_number_of_compact_open {α : Type u_1} [uniform_space α] {K U : set α} (hK : is_compact K) (hU : is_open U) (hKU : K ⊆ U) : ∃ (V : set (α × α)) (H : V ∈ uniformity α), is_open V ∧ ∀ (x : α), x ∈ K → uniform_space.ball x V ⊆ U
theorem box_integral.box.exists_tagged_partition_is_Henstock_is_subordinate_homothetic {ι : Type u_1} [fintype ι] (I : box_integral.box ι) (r : (ι → ℝ) → ↥(set.Ioi 0)) : ∃ (π : box_integral.tagged_prepartition I), π.is_partition ∧ π.is_Henstock ∧ π.is_subordinate r ∧ (∀ (J : box_integral.box ι), J ∈ π → (∃ (m : ℕ), ∀ (i : ι), J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m)) ∧ π.distortion = I.distortion
theorem disjoint.one_not_mem_div_set {α : Type u_2} [group α] {s t : set α} : disjoint s t → 1 ∉ s / t
theorem power_series.is_unit_constant_coeff {R : Type u_1} [semiring R] (φ : power_series R) (h : is_unit φ) : is_unit (⇑(power_series.constant_coeff R) φ)
theorem has_fpower_series_on_ball.continuous_on {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] {f : E → F} {p : formal_multilinear_series 𝕜 E F} {x : E} {r : ennreal} (hf : has_fpower_series_on_ball f p x r) : continuous_on f (emetric.ball x r)
theorem fin.succ_above_above {n : ℕ} (p : fin (n + 1)) (i : fin n) (h : p ≤ ⇑fin.cast_succ i) : ⇑(p.succ_above) i = i.succ
theorem is_Gδ_set_of_continuous_at {α : Type u_1} {β : Type u_2} [topological_space α] [uniform_space β] [(uniformity β).is_countably_generated] (f : α → β) : is_Gδ {x : α | continuous_at f x}
theorem mem_vector_span_iff_eq_weighted_vsub (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} {v : V} {p : ι → P} : v ∈ vector_span k (set.range p) ↔ ∃ (s : finset ι) (w : ι → k) (h : s.sum (λ (i : ι), w i) = 0), v = ⇑(s.weighted_vsub p) w
theorem filter.tendsto.germ_tendsto {α : Type u_1} {β : Type u_2} {l : filter α} {f : α → β} {lb : filter β} : filter.tendsto f l lb → ↑f.tendsto lb
theorem finset.eq_affine_combination_subset_iff_eq_affine_combination_subtype (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} {p0 : P} {s : set ι} {p : ι → P} : (∃ (fs : finset ι) (hfs : ↑fs ⊆ s) (w : ι → k) (hw : fs.sum (λ (i : ι), w i) = 1), p0 = ⇑(fs.affine_combination p) w) ↔ ∃ (fs : finset ↥s) (w : ↥s → k) (hw : fs.sum (λ (i : ↥s), w i) = 1), p0 = ⇑(fs.affine_combination (λ (i : ↥s), p ↑i)) w
theorem ennreal.add_le_cancellable_iff_ne {a : ennreal} : add_le_cancellable a ↔ a ≠ ⊤
theorem polynomial.root_multiplicity_add {R : Type u} [comm_ring R] [is_domain R] {p q : polynomial R} (a : R) (hzero : p + q ≠ 0) : linear_order.min (polynomial.root_multiplicity a p) (polynomial.root_multiplicity a q) ≤ polynomial.root_multiplicity a (p + q)
theorem dist_add_dist_eq_iff {E : Type u_2} [normed_group E] [normed_space ℝ E] [strict_convex_space ℝ E] {x y z : E} : has_dist.dist x y + has_dist.dist y z = has_dist.dist x z ↔ y ∈ segment ℝ x z
theorem mem_exposed_points_iff_exposed_singleton {𝕜 : Type u_1} {E : Type u_2} [normed_linear_ordered_field 𝕜] [normed_group E] [normed_space 𝕜 E] {A : set E} {x : E} : x ∈ set.exposed_points 𝕜 A ↔ is_exposed 𝕜 A {x}
theorem matrix.pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction {𝕜 : Type u_3} [field 𝕜] {r : ℕ} (IH : ∀ (M : matrix (fin r) (fin r) 𝕜), ∃ (L₀ L₀' : list (matrix.transvection_struct (fin r) 𝕜)) (D₀ : fin r → 𝕜), ((list.map matrix.transvection_struct.to_matrix L₀).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L₀').prod = matrix.diagonal D₀) (M : matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜) : ∃ (L L' : list (matrix.transvection_struct (fin r ⊕ unit) 𝕜)) (D : fin r ⊕ unit → 𝕜), ((list.map matrix.transvection_struct.to_matrix L).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L').prod = matrix.diagonal D
theorem add_tsub_le_right {α : Type u_1} [preorder α] [has_add α] [has_sub α] [has_ordered_sub α] {a b : α} : a + b - b ≤ a
theorem differentiable.has_fpower_series_on_ball {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] {f : ℂ → E} (h : differentiable ℂ f) (z : ℂ) {R : nnreal} (hR : 0 < R) : has_fpower_series_on_ball f (cauchy_power_series f z ↑R) z ⊤
theorem filter.eventually_le.eventually_le_nhds {α : Type u} {β : Type v} [topological_space α] [has_le β] {f g : α → β} {a : α} (h : f ≤ᶠ[nhds a] g) : ∀ᶠ (y : α) in nhds a, f ≤ᶠ[nhds y] g
theorem metric.nonempty_compacts.dist_eq {α : Type u} [metric_space α] {x y : topological_space.nonempty_compacts α} : has_dist.dist x y = metric.Hausdorff_dist ↑x ↑y
theorem function.involutive.ite_not {α : Sort u} {f : α → α} (h : function.involutive f) (P : Prop) [decidable P] (x : α) : f (ite P x (f x)) = ite (¬P) x (f x)
theorem measurable.strongly_measurable {α : Type u_1} {β : Type u_2} {f : α → β} {mα : measurable_space α} [measurable_space β] [topological_space β] [topological_space.pseudo_metrizable_space β] [topological_space.second_countable_topology β] [opens_measurable_space β] (hf : measurable f) : measure_theory.strongly_measurable f
theorem power_series.X_prime {R : Type u_1} [comm_ring R] [is_domain R] : prime power_series.X
theorem category_theory.has_limits_of_shape_of_has_limits_of_shape_creates_limits_of_shape {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {J : Type w} [category_theory.category J] (F : C ⥤ D) [category_theory.limits.has_limits_of_shape J D] [category_theory.creates_limits_of_shape J F] : category_theory.limits.has_limits_of_shape J C
theorem cont_diff_snd {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : with_top ℕ} : cont_diff 𝕜 n prod.snd
theorem reflection_eq_self_iff {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K : submodule 𝕜 E} [complete_space ↥K] (x : E) : ⇑(reflection K) x = x ↔ x ∈ K
theorem fin.add_nat_cast {n n' m : ℕ} (i : fin n') (h : n' = n) : ⇑(fin.add_nat m) (⇑(fin.cast h) i) = ⇑(fin.cast _) (⇑(fin.add_nat m) i)
theorem exp_neg_inv_glue.nonneg (x : ℝ) : 0 ≤ exp_neg_inv_glue x
theorem tsub_lt_tsub_iff_left_of_le {α : Type u_1} [canonically_linear_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b c : α} [contravariant_class α α has_add.add has_le.le] (h : b ≤ a) : a - b < a - c ↔ c < b
theorem is_localization.surjective_quotient_map_of_maximal_of_localization {R : Type u_1} [comm_ring R] (M : submonoid R) (S : Type u_2) [comm_ring S] [algebra R S] [is_localization M S] {I : ideal S} [I.is_prime] {J : ideal R} {H : J ≤ ideal.comap (algebra_map R S) I} (hI : (ideal.comap (algebra_map R S) I).is_maximal) : function.surjective ⇑(I.quotient_map (algebra_map R S) H)
theorem category_theory.limits.has_colimits_op_of_has_limits {C : Type u₁} [category_theory.category C] [category_theory.limits.has_limits C] : category_theory.limits.has_colimits Cᵒᵖ
theorem subsemigroup.dense_induction {M : Type u_1} [has_mul M] {p : M → Prop} (x : M) {s : set M} (hs : subsemigroup.closure s = ⊤) (Hs : ∀ (x : M), x ∈ s → p x) (Hmul : ∀ (x y : M), p x → p y → p (x * y)) : p x
theorem finsupp.prod_add_index_of_disjoint {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f1 f2 : α →₀ M} (hd : disjoint f1.support f2.support) {β : Type u_2} [comm_monoid β] (g : α → M → β) : (f1 + f2).prod g = f1.prod g * f2.prod g
theorem mvqpf.cofix.bisim_rel {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} (r : mvqpf.cofix F α → mvqpf.cofix F α → Prop) (h : ∀ (x y : mvqpf.cofix F α), r x y → mvfunctor.map (typevec.id ::: quot.mk r) x.dest = mvfunctor.map (typevec.id ::: quot.mk r) y.dest) (x y : mvqpf.cofix F α) : r x y → x = y
theorem ideal.map_of_equiv {R : Type u} {S : Type v} [ring R] [ring S] (I : ideal R) (f : R ≃+* S) : ideal.map ↑(f.symm) (ideal.map ↑f I) = I
theorem prime_spectrum.punit (x : prime_spectrum punit) : false
theorem exists_prime_order_of_dvd_card {G : Type u_1} [group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G) : ∃ (x : G), order_of x = p
theorem continuous_linear_map.antilipschitz_of_uniform_embedding {𝕜 : Type u_1} {E : Type u_4} {Fₗ : Type u_7} [normed_group E] [normed_group Fₗ] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 Fₗ] (f : E →L[𝕜] Fₗ) (hf : uniform_embedding ⇑f) : ∃ (K : nnreal), antilipschitz_with K ⇑f
theorem cardinal.mk_powerset {α : Type u} (s : set α) : cardinal.mk (↥𝒫s) = 2 ^ cardinal.mk ↥s
theorem linear_order.convex_on_of_lt {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [ordered_add_comm_monoid β] [module 𝕜 E] [module 𝕜 β] [linear_order E] {s : set E} {f : E → β} (hs : convex 𝕜 s) (hf : ∀ ⦃x y : E⦄, x ∈ s → y ∈ s → x < y → ∀ ⦃a b : 𝕜⦄, 0 < a → 0 < b → a + b = 1 → f (a • x + b • y) ≤ a • f x + b • f y) : convex_on 𝕜 s f
theorem simple_graph.even_card_odd_degree_vertices {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] : even (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card
theorem local_homeomorph.continuous_at_iff_continuous_at_comp_right {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] (e : local_homeomorph α β) {f : β → γ} {x : β} (h : x ∈ e.to_local_equiv.target) : continuous_at f x ↔ continuous_at (f ∘ ⇑e) (⇑(e.symm) x)
theorem id_eq_sum_orthogonal_projection_self_orthogonal_complement {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) [complete_space E] [complete_space ↥K] : continuous_linear_map.id 𝕜 E = K.subtypeL.comp (orthogonal_projection K) + Kᗮ.subtypeL.comp (orthogonal_projection Kᗮ)
theorem finset.sum_range_induction {M : Type u_1} [add_comm_monoid M] (f s : ℕ → M) (h0 : s 0 = 0) (h : ∀ (n : ℕ), s (n + 1) = s n + f n) (n : ℕ) : (finset.range n).sum (λ (k : ℕ), f k) = s n
theorem finset.weighted_vsub_map {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} {ι₂ : Type u_5} (s₂ : finset ι₂) (e : ι₂ ↪ ι) (w : ι → k) (p : ι → P) : ⇑((finset.map e s₂).weighted_vsub p) w = ⇑(s₂.weighted_vsub (p ∘ ⇑e)) (w ∘ ⇑e)
theorem circle_integrable_sub_zpow_iff {c w : ℂ} {R : ℝ} {n : ℤ} : circle_integrable (λ (z : ℂ), (z - w) ^ n) c R ↔ R = 0 ∨ 0 ≤ n ∨ w ∉ metric.sphere c |R|
theorem covby.cast_int {a b : ℕ} : a ⋖ b → ↑a ⋖ ↑b
theorem Module.projective_of_free {R : Type u} [ring R] {M : Module R} {ι : Type u_1} (b : basis ι R ↥M) : category_theory.projective M
theorem lt_sub_right_of_add_lt {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a + b < c → a < c - b
theorem function.is_fixed_pt.iterate {α : Type u} {f : α → α} {x : α} (hf : function.is_fixed_pt f x) (n : ℕ) : function.is_fixed_pt f^[n] x
theorem measure_theory.tsum_measure_preimage_singleton {α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} {s : set β} (hs : s.countable) {f : α → β} (hf : ∀ (y : β), y ∈ s → measurable_set (f ⁻¹' {y})) : ∑' (b : ↥s), ⇑μ (f ⁻¹' {↑b}) = ⇑μ (f ⁻¹' s)
theorem cont_diff_on_succ_iff_deriv_of_open {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f₂ : 𝕜 → F} {s₂ : set 𝕜} {n : ℕ} (hs : is_open s₂) : cont_diff_on 𝕜 ↑(n + 1) f₂ s₂ ↔ differentiable_on 𝕜 f₂ s₂ ∧ cont_diff_on 𝕜 ↑n (deriv f₂) s₂
theorem category_theory.reflects_epi {C : Type u₁} {D : Type u₂} [category_theory.category C] [category_theory.category D] (F : C ⥤ D) {X Y : C} (f : X ⟶ Y) [category_theory.limits.reflects_colimit (category_theory.limits.span f f) F] [category_theory.epi (F.map f)] : category_theory.epi f
theorem cont_diff_on_top_iff_fderiv_of_open {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} (hs : is_open s) : cont_diff_on 𝕜 ⊤ f s ↔ differentiable_on 𝕜 f s ∧ cont_diff_on 𝕜 ⊤ (λ (y : E), fderiv 𝕜 f y) s
theorem is_open.exists_lt_is_compact {α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [μ.regular] ⦃U : set α⦄ (hU : is_open U) {r : ennreal} (hr : r < ⇑μ U) : ∃ (K : set α) (H : K ⊆ U), is_compact K ∧ r < ⇑μ K
theorem omega.nat.preterm.val_constant (v w : ℕ → ℕ) (t : omega.nat.preterm) : (∀ (x : ℕ), x < t.fresh_index → v x = w x) → omega.nat.preterm.val v t = omega.nat.preterm.val w t
theorem dist_edist {α : Type u} [pseudo_metric_space α] (x y : α) : has_dist.dist x y = (has_edist.edist x y).to_real
theorem first_order.language.exists_elementary_substructure_card_eq (L : first_order.language) {M : Type w} [nonempty M] [L.Structure M] (s : set M) (κ : cardinal) (h1 : cardinal.aleph_0 ≤ κ) (h2 : (cardinal.mk ↥s).lift ≤ κ.lift) (h3 : L.card.lift ≤ κ.lift) (h4 : κ.lift ≤ (cardinal.mk M).lift) : ∃ (S : L.elementary_substructure M), s ⊆ ↑S ∧ (cardinal.mk ↥S).lift = κ.lift
theorem ordinal.eq_enum_ord {S : set ordinal} (f : ordinal → ordinal) (hS : set.unbounded has_lt.lt S) : strict_mono f ∧ set.range f = S ↔ f = ordinal.enum_ord S
theorem omega.unsat_of_unsat_eq_elim (ee : list omega.ee) (c : omega.clause) : (omega.eq_elim ee c).unsat → c.unsat
theorem measure_theory.integrable_condexp_L2_indicator {α : Type u_1} {E' : Type u_5} {𝕜 : Type u_11} [is_R_or_C 𝕜] [inner_product_space 𝕜 E'] [complete_space E'] [normed_space ℝ E'] {m m0 : measurable_space α} {μ : measure_theory.measure α} {s : set α} (hm : m ≤ m0) [measure_theory.sigma_finite (μ.trim hm)] (hs : measurable_set s) (hμs : ⇑μ s ≠ ⊤) (x : E') : measure_theory.integrable ⇑(⇑(measure_theory.condexp_L2 𝕜 hm) (measure_theory.indicator_const_Lp 2 hs hμs x)) μ
theorem add_monoid_hom.range_top_of_surjective {G : Type u_1} [add_group G] {N : Type u_2} [add_group N] (f : G →+ N) (hf : function.surjective ⇑f) : f.range = ⊤
theorem affine_subspace.coe_affine_span_singleton (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (p : P) : ↑(affine_span k {p}) = {p}
theorem composition.size_up_to_size_up_to_add {n : ℕ} (a : composition n) (b : composition a.length) {i j : ℕ} (hi : i < b.length) (hj : j < b.blocks_fun ⟨i, hi⟩) : a.size_up_to (b.size_up_to i + j) = (a.gather b).size_up_to i + (a.sigma_composition_aux b ⟨i, _⟩).size_up_to j
theorem path.trans_prod_eq_prod_trans {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {a₁ a₂ a₃ : X} {b₁ b₂ b₃ : Y} (γ₁ : path a₁ a₂) (δ₁ : path a₂ a₃) (γ₂ : path b₁ b₂) (δ₂ : path b₂ b₃) : (γ₁.prod γ₂).trans (δ₁.prod δ₂) = (γ₁.trans δ₁).prod (γ₂.trans δ₂)
theorem algebraic_geometry.RingedSpace.is_unit_of_is_unit_germ (X : algebraic_geometry.RingedSpace) (U : topological_space.opens ↥X) (f : ↥(X.to_PresheafedSpace.presheaf.obj (opposite.op U))) (h : ∀ (x : ↥U), is_unit (⇑(X.to_PresheafedSpace.presheaf.germ x) f)) : is_unit f
theorem cont_mdiff_at.comp_cont_mdiff_within_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M → M'} {s : set M} {n : with_top ℕ} {E'' : Type u_14} [normed_group E''] [normed_space 𝕜 E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners 𝕜 E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {g : M' → M''} (x : M) (hg : cont_mdiff_at I' I'' n g (f x)) (hf : cont_mdiff_within_at I I' n f s x) : cont_mdiff_within_at I I'' n (g ∘ f) s x
theorem is_regular_mul_and_mul_iff {R : Type u_1} {a b : R} [semigroup R] : is_regular (a * b) ∧ is_regular (b * a) ↔ is_regular a ∧ is_regular b
theorem cauchy_seq_tendsto_of_is_complete {α : Type u} {β : Type v} [uniform_space α] [semilattice_sup β] {K : set α} (h₁ : is_complete K) {u : β → α} (h₂ : ∀ (n : β), u n ∈ K) (h₃ : cauchy_seq u) : ∃ (v : α) (H : v ∈ K), filter.tendsto u filter.at_top (nhds v)
theorem topological_space.is_topological_basis_of_open_of_nhds {α : Type u} [t : topological_space α] {s : set (set α)} (h_open : ∀ (u : set α), u ∈ s → is_open u) (h_nhds : ∀ (a : α) (u : set α), a ∈ u → is_open u → (∃ (v : set α) (H : v ∈ s), a ∈ v ∧ v ⊆ u)) : topological_space.is_topological_basis s
theorem is_primitive_root.minpoly_eq_pow_coprime {n : ℕ} {K : Type u_8} [field K] {μ : K} (h : is_primitive_root μ n) [char_zero K] {m : ℕ} (hcop : m.coprime n) : minpoly ℤ μ = minpoly ℤ (μ ^ m)
theorem padic_norm.padic_norm_of_prime_of_ne {p q : ℕ} [p_prime : fact (nat.prime p)] [q_prime : fact (nat.prime q)] (neq : p ≠ q) : padic_norm p ↑q = 1
theorem lt_mul_of_inv_mul_lt_left {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : b⁻¹ * a < c → a < b * c
theorem add_con.add_ker_mk_eq {M : Type u_1} [has_add M] (c : add_con M) : add_con.add_ker coe _ = c
theorem finprod_mem_Union {α : Type u_1} {ι : Type u_3} {M : Type u_5} [comm_monoid M] {f : α → M} [fintype ι] {t : ι → set α} (h : pairwise (disjoint on t)) (ht : ∀ (i : ι), (t i).finite) : finprod (λ (a : α), finprod (λ (H : a ∈ ⋃ (i : ι), t i), f a)) = finprod (λ (i : ι), finprod (λ (a : α), finprod (λ (H : a ∈ t i), f a)))
theorem cont_diff.prod_map {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : with_top ℕ} {E' : Type u_6} [normed_group E'] [normed_space 𝕜 E'] {F' : Type u_7} [normed_group F'] [normed_space 𝕜 F'] {f : E → F} {g : E' → F'} (hf : cont_diff 𝕜 n f) (hg : cont_diff 𝕜 n g) : cont_diff 𝕜 n (prod.map f g)
theorem category_theory.mem_ess_image_of_unit_split_mono {C : Type u₁} {D : Type u₂} [category_theory.category C] [category_theory.category D] {i : D ⥤ C} [category_theory.reflective i] {A : C} [category_theory.split_mono ((category_theory.adjunction.of_right_adjoint i).unit.app A)] : A ∈ i.ess_image
theorem tendsto_comp_of_locally_uniform_limit_within {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {s : set α} {x : α} {p : filter ι} {g : ι → α} [topological_space α] (h : continuous_within_at f s x) (hg : filter.tendsto g p (nhds_within x s)) (hunif : ∀ (u : set (β × β)), u ∈ uniformity β → (∃ (t : set α) (H : t ∈ nhds_within x s), ∀ᶠ (n : ι) in p, ∀ (y : α), y ∈ t → (f y, F n y) ∈ u)) : filter.tendsto (λ (n : ι), F n (g n)) p (nhds (f x))
theorem measure_theory.measure.count_apply_infinite {α : Type u_1} {s : set α} [measurable_space α] (hs : s.infinite) : ⇑measure_theory.measure.count s = ⊤
theorem category_theory.presieve.extension_iff_amalgamation {C : Type u₁} [category_theory.category C] {X : C} {S : category_theory.sieve X} {P : Cᵒᵖ ⥤ Type v₁} (x : S.functor ⟶ P) (g : category_theory.yoneda.obj X ⟶ P) : S.functor_inclusion ≫ g = x ↔ (⇑category_theory.presieve.nat_trans_equiv_compatible_family x).val.is_amalgamation (⇑category_theory.yoneda_equiv g)
theorem box_integral.prepartition.split_of_not_mem_Ioo {ι : Type u_1} {I : box_integral.box ι} {i : ι} {x : ℝ} (h : x ∉ set.Ioo (I.lower i) (I.upper i)) : box_integral.prepartition.split I i x = ⊤
theorem finprod_mem_mul_distrib' {α : Type u_1} {M : Type u_5} [comm_monoid M] {f g : α → M} {s : set α} (hf : (s ∩ function.mul_support f).finite) (hg : (s ∩ function.mul_support g).finite) : finprod (λ (i : α), finprod (λ (H : i ∈ s), f i * g i)) = finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ s), g i))
theorem inv_int_cast_smul_comm {α : Type u_1} {E : Type u_2} (R : Type u_3) [add_comm_group E] [division_ring R] [monoid α] [module R E] [distrib_mul_action α E] (n : ℤ) (s : α) (x : E) : (↑n)⁻¹ • s • x = s • (↑n)⁻¹ • x
theorem cardinal.mk_univ_quaternion (R : Type u_1) [has_one R] [has_neg R] : cardinal.mk ↥set.univ = cardinal.mk R ^ 4
theorem map_cSup_of_continuous_at_of_monotone {α : Type u} {β : Type v} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [conditionally_complete_linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} (Cf : continuous_at f (has_Sup.Sup s)) (Mf : monotone f) (ne : s.nonempty) (H : bdd_above s) : f (has_Sup.Sup s) = has_Sup.Sup (f '' s)
theorem finset.min'_lt_max'_of_card {α : Type u_1} [linear_order α] (s : finset α) (h₂ : 1 < s.card) : s.min' _ < s.max' _
theorem is_totally_disconnected_of_clopen_set {X : Type u_1} [topological_space X] (hX : ∀ {x y : X}, x ≠ y → (∃ (U : set X) (h_clopen : is_clopen U), x ∈ U ∧ y ∉ U)) : is_totally_disconnected set.univ
theorem homotopy.map_null_homotopic_map {ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D : homological_complex V c} {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] (G : V ⥤ W) [G.additive] (hom : Π (i j : ι), C.X i ⟶ D.X j) : (G.map_homological_complex c).map (homotopy.null_homotopic_map hom) = homotopy.null_homotopic_map (λ (i j : ι), G.map (hom i j))
theorem ext_nat'' {A : Type u_1} {F : Type u_2} [mul_zero_one_class A] [monoid_with_zero_hom_class F ℕ A] (f g : F) (h_pos : ∀ {n : ℕ}, 0 < n → ⇑f n = ⇑g n) : f = g
theorem measure_theory.set_integral_condexp_L1_clm_of_measure_ne_top {α : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space ℝ F'] [complete_space F'] {m m0 : measurable_space α} {μ : measure_theory.measure α} {hm : m ≤ m0} [measure_theory.sigma_finite (μ.trim hm)] {s : set α} (f : ↥(measure_theory.Lp F' 1 μ)) (hs : measurable_set s) (hμs : ⇑μ s ≠ ⊤) : ∫ (x : α) in s, ⇑(⇑(measure_theory.condexp_L1_clm hm μ) f) x ∂μ = ∫ (x : α) in s, ⇑f x ∂μ
theorem orientation.eq_iff_norm_eq_and_oangle_eq_zero {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x y : V) : x = y ↔ ∥x∥ = ∥y∥ ∧ o.oangle x y = 0
theorem fin.succ_above_lt_ge {n : ℕ} (p : fin (n + 1)) (i : fin n) : ⇑fin.cast_succ i < p ∨ p ≤ ⇑fin.cast_succ i
theorem fin.cast_succ_pos {n : ℕ} {i : fin (n + 1)} (h : 0 < i) : 0 < ⇑fin.cast_succ i
theorem inner_product_geometry.inner_eq_mul_norm_iff_angle_eq_zero {V : Type u_1} [inner_product_space ℝ V] {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : has_inner.inner x y = ∥x∥ * ∥y∥ ↔ inner_product_geometry.angle x y = 0
theorem normed_group_hom.equalizer.norm_lift_le {V : Type u_1} {W : Type u_2} {V₁ : Type u_3} [semi_normed_group V] [semi_normed_group W] [semi_normed_group V₁] {f g : normed_group_hom V W} (φ : normed_group_hom V₁ V) (h : f.comp φ = g.comp φ) (C : ℝ) (hφ : ∥φ∥ ≤ C) : ∥normed_group_hom.equalizer.lift φ h∥ ≤ C
theorem prime.dvd_prod_iff {M : Type u_1} [comm_monoid_with_zero M] {p : M} {L : list M} (pp : prime p) : p ∣ L.prod ↔ ∃ (a : M) (H : a ∈ L), p ∣ a
theorem continuous_linear_map.op_norm_zero {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [ring_hom_isometric σ₁₂] : ∥0∥ = 0
theorem right.one_lt_mul_of_le_of_lt {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 < b) : 1 < a * b
theorem algebraic_geometry.RingedSpace.is_unit_res_of_is_unit_germ (X : algebraic_geometry.RingedSpace) (U : topological_space.opens ↥X) (f : ↥(X.to_PresheafedSpace.presheaf.obj (opposite.op U))) (x : ↥U) (h : is_unit (⇑(X.to_PresheafedSpace.presheaf.germ x) f)) : ∃ (V : topological_space.opens ↥X) (i : V ⟶ U) (hxV : x.val ∈ V), is_unit (⇑(X.to_PresheafedSpace.presheaf.map i.op) f)
theorem category_theory.limits.has_colimit_of_equivalence_comp {J : Type u₁} [category_theory.category J] {K : Type u₂} [category_theory.category K] {C : Type u} [category_theory.category C] {F : J ⥤ C} (e : K ≌ J) [category_theory.limits.has_colimit (e.functor ⋙ F)] : category_theory.limits.has_colimit F
theorem metric.Hausdorff_edist_ne_top_of_nonempty_of_bounded {α : Type u} [pseudo_metric_space α] {s t : set α} (hs : s.nonempty) (ht : t.nonempty) (bs : metric.bounded s) (bt : metric.bounded t) : emetric.Hausdorff_edist s t ≠ ⊤
theorem convex.image_sub_lt_mul_sub_of_deriv_lt {D : set ℝ} (hD : convex ℝ D) {f : ℝ → ℝ} (hf : continuous_on f D) (hf' : differentiable_on ℝ f (interior D)) {C : ℝ} (lt_hf' : ∀ (x : ℝ), x ∈ interior D → deriv f x < C) (x : ℝ) (H : x ∈ D) (y : ℝ) (H_1 : y ∈ D) : x < y → f y - f x < C * (y - x)
theorem is_seq_closed.mem_of_tendsto {X : Type u_1} [topological_space X] {s : set X} (hs : is_seq_closed s) {x : ℕ → X} (hmem : ∀ (n : ℕ), x n ∈ s) {a : X} (ha : filter.tendsto x filter.at_top (nhds a)) : a ∈ s
theorem category_theory.functor.ess_image.of_iso {C : Type u₁} {D : Type u₂} [category_theory.category C] [category_theory.category D] {F : C ⥤ D} {Y Y' : D} (h : Y ≅ Y') (hY : Y ∈ F.ess_image) : Y' ∈ F.ess_image
theorem interval_integral.tendsto_integral_filter_of_dominated_convergence {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {a b : ℝ} {f : ℝ → E} {μ : measure_theory.measure ℝ} {ι : Type u_1} {l : filter ι} [l.is_countably_generated] {F : ι → ℝ → E} (bound : ℝ → ℝ) (hF_meas : ∀ᶠ (n : ι) in l, measure_theory.ae_strongly_measurable (F n) (μ.restrict (set.interval_oc a b))) (h_bound : ∀ᶠ (n : ι) in l, ∀ᵐ (x : ℝ) ∂μ, x ∈ set.interval_oc a b → ∥F n x∥ ≤ bound x) (bound_integrable : interval_integrable bound μ a b) (h_lim : ∀ᵐ (x : ℝ) ∂μ, x ∈ set.interval_oc a b → filter.tendsto (λ (n : ι), F n x) l (nhds (f x))) : filter.tendsto (λ (n : ι), ∫ (x : ℝ) in a..b, F n x ∂μ) l (nhds (∫ (x : ℝ) in a..b, f x ∂μ))
theorem add_subsemigroup.dense_induction {M : Type u_1} [has_add M] {p : M → Prop} (x : M) {s : set M} (hs : add_subsemigroup.closure s = ⊤) (Hs : ∀ (x : M), x ∈ s → p x) (Hmul : ∀ (x y : M), p x → p y → p (x + y)) : p x
theorem measure_theory.exists_lt_lower_semicontinuous_integral_gt_nnreal {α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] {μ : measure_theory.measure α} [μ.weakly_regular] [measure_theory.sigma_finite μ] (f : α → nnreal) (fint : measure_theory.integrable (λ (x : α), ↑(f x)) μ) {ε : ℝ} (εpos : 0 < ε) : ∃ (g : α → ennreal), (∀ (x : α), ↑(f x) < g x) ∧ lower_semicontinuous g ∧ (∀ᵐ (x : α) ∂μ, g x < ⊤) ∧ measure_theory.integrable (λ (x : α), (g x).to_real) μ ∧ ∫ (x : α), (g x).to_real ∂μ < ∫ (x : α), ↑(f x) ∂μ + ε
theorem monoid_hom.congr_fun {M : Type u_3} {N : Type u_4} [mul_one_class M] [mul_one_class N] {f g : M →* N} (h : f = g) (x : M) : ⇑f x = ⇑g x
theorem module.End.generalized_eigenvec_disjoint_range_ker {K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (f : module.End K V) (μ : K) : disjoint (f.generalized_eigenrange μ (finite_dimensional.finrank K V)) (⇑(f.generalized_eigenspace μ) (finite_dimensional.finrank K V))
theorem algebra.discr_of_matrix_mul_vec {A : Type u} {B : Type v} {ι : Type w} [comm_ring A] [comm_ring B] [algebra A B] [fintype ι] [decidable_eq ι] (b : ι → B) (P : matrix ι ι A) : algebra.discr A ((P.map ⇑(algebra_map A B)).mul_vec b) = P.det ^ 2 * algebra.discr A b
theorem function.update_apply {α : Sort u} [decidable_eq α] {β : Sort u_1} (f : α → β) (a' : α) (b : β) (a : α) : function.update f a' b a = ite (a = a') b (f a)
theorem filter.eventually.small_sets {α : Type u_1} {l : filter α} {p : α → Prop} : (∀ᶠ (x : α) in l, p x) → (∀ᶠ (s : set α) in l.small_sets, ∀ (x : α), x ∈ s → p x)
theorem fin.cast_succ_eq {n n' : ℕ} (i : fin n) (h : n.succ = n'.succ) : ⇑(fin.cast h) i.succ = (⇑(fin.cast _) i).succ
theorem cardinal.lift_sup_le_lift_sup {ι : Type v} {ι' : Type v'} (f : ι → cardinal) (f' : ι' → cardinal) (g : ι → ι') (h : ∀ (i : ι), (f i).lift ≤ (f' (g i)).lift) : (cardinal.sup f).lift ≤ (cardinal.sup f').lift
theorem finsupp.total_id_surjective (R : Type u_5) [semiring R] (M : Type u_1) [add_comm_monoid M] [module R M] : function.surjective ⇑(finsupp.total M M R id)
theorem continuous_map.continuous_map_mem_subalgebra_closure_of_separates_points {X : Type u_1} [topological_space X] [compact_space X] (A : subalgebra ℝ C(X, ℝ)) (w : A.separates_points) (f : C(X, ℝ)) : f ∈ A.topological_closure
theorem filter.tendsto.integral_sub_linear_is_o_ae {α : Type u_1} {E : Type u_3} [measurable_space α] {ι : Type u_5} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {l : filter α} [l.is_measurably_generated] {f : α → E} {b : E} (h : filter.tendsto f (l ⊓ μ.ae) (nhds b)) (hfm : strongly_measurable_at_filter f l μ) (hμ : μ.finite_at_filter l) {s : ι → set α} {li : filter ι} (hs : filter.tendsto s li l.small_sets) (m : ι → ℝ := λ (i : ι), (⇑μ (s i)).to_real) (hsμ : (λ (i : ι), (⇑μ (s i)).to_real) =ᶠ[li] m . "refl") : (λ (i : ι), ∫ (x : α) in s i, f x ∂μ - m i • b) =o[li] m
theorem measure_theory.measure.measure_to_measurable_inter_of_sigma_finite {α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} [measure_theory.sigma_finite μ] {s : set α} (hs : measurable_set s) (t : set α) : ⇑μ (measure_theory.to_measurable μ t ∩ s) = ⇑μ (t ∩ s)
theorem simple_graph.sum_degrees_eq_twice_card_edges {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [decidable_eq V] : finset.univ.sum (λ (v : V), G.degree v) = 2 * G.edge_finset.card
theorem category_theory.equalizer.sieve.compatible_iff {C : Type u₁} [category_theory.category C] (P : Cᵒᵖ ⥤ Type (max v₁ u₁)) {X : C} (S : category_theory.sieve X) (x : category_theory.equalizer.first_obj P ⇑S) : ((category_theory.equalizer.first_obj_eq_family P ⇑S).hom x).compatible ↔ category_theory.equalizer.sieve.first_map P S x = category_theory.equalizer.sieve.second_map P S x
theorem function_field.class_number_eq_one_iff (Fq F : Type) [field Fq] [fintype Fq] [field F] [algebra (polynomial Fq) F] [algebra (ratfunc Fq) F] [is_scalar_tower (polynomial Fq) (ratfunc Fq) F] [function_field Fq F] [is_separable (ratfunc Fq) F] : function_field.class_number Fq F = 1 ↔ is_principal_ideal_ring ↥(function_field.ring_of_integers Fq F)
theorem closure_Iio' {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a : α} (h : (set.Iio a).nonempty) : closure (set.Iio a) = set.Iic a
theorem affine_independent_iff_not_collinear (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : fin 3 → P) : affine_independent k p ↔ ¬collinear k (set.range p)
theorem finite_field.even_card_iff_char_two {F : Type u_3} [field F] [fintype F] : ring_char F = 2 ↔ fintype.card F % 2 = 0
theorem differentiable.apply_eq_apply_of_bounded {E : Type u} [normed_group E] [normed_space ℂ E] {F : Type v} [normed_group F] [normed_space ℂ F] {f : E → F} (hf : differentiable ℂ f) (hb : metric.bounded (set.range f)) (z w : E) : f z = f w
theorem category_theory.limits.equalizer.ι_of_eq {C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} [category_theory.limits.has_equalizer f g] (h : f = g) : category_theory.is_iso (category_theory.limits.equalizer.ι f g)
theorem continuous_on.surj_on_interval {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {δ : Type u_1} [linear_order δ] [topological_space δ] [order_closed_topology δ] {s : set α} [hs : s.ord_connected] {f : α → δ} (hf : continuous_on f s) {a b : α} (ha : a ∈ s) (hb : b ∈ s) : set.surj_on f s (set.interval (f a) (f b))
theorem char.quadratic_char_neg_one_iff_not_is_square {F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} : char.quadratic_char F a = -1 ↔ ¬is_square a
theorem mul_left_continuous {α : Type u_1} [topological_space α] [non_unital_non_assoc_ring α] [topological_ring α] (x : α) : continuous ⇑(add_monoid_hom.mul_left x)
theorem decidable.em (p : Prop) [decidable p] : p ∨ ¬p
theorem formal_multilinear_series.norm_mul_pow_le_mul_pow_of_lt_radius {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) {r : nnreal} (h : ↑r < p.radius) : ∃ (a : ℝ) (H : a ∈ set.Ioo 0 1) (C : ℝ) (H : C > 0), ∀ (n : ℕ), ∥p n∥ * ↑r ^ n ≤ C * a ^ n
theorem category_theory.is_connected.of_induct {J : Type u₁} [category_theory.category J] [nonempty J] {j₀ : J} (h : ∀ (p : set J), j₀ ∈ p → (∀ {j₁ j₂ : J}, (j₁ ⟶ j₂) → (j₁ ∈ p ↔ j₂ ∈ p)) → ∀ (j : J), j ∈ p) : category_theory.is_connected J
theorem add_submonoid.list_sum_mem {M : Type u_1} [add_monoid M] (s : add_submonoid M) {l : list M} (hl : ∀ (x : M), x ∈ l → x ∈ s) : l.sum ∈ s
theorem pmf.to_measure_bind_apply {α : Type u_1} {β : Type u_2} (p : pmf α) (f : α → pmf β) (s : set β) [measurable_space β] (hs : measurable_set s) : ⇑((p.bind f).to_measure) s = ∑' (a : α), ↑(⇑p a) * ⇑((f a).to_measure) s
theorem subgroup.one_mem {G : Type u_1} [group G] (H : subgroup G) : 1 ∈ H
theorem category_theory.is_cofiltered.of_equivalence {C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] {D : Type u₁} [category_theory.category D] (h : C ≌ D) : category_theory.is_cofiltered D
theorem vector_span_eq_span_vsub_set_right_ne (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p : P} (hp : p ∈ s) : vector_span k s = submodule.span k ((λ (_x : P), _x -ᵥ p) '' (s  {p}))
theorem inner_mul_inner_self_le {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) : is_R_or_C.abs (has_inner.inner x y) * is_R_or_C.abs (has_inner.inner y x) ≤ ⇑is_R_or_C.re (has_inner.inner x x) * ⇑is_R_or_C.re (has_inner.inner y y)
theorem nat.modeq.modeq_cancel_right_of_coprime {a b c m : ℕ} (hmc : m.gcd c = 1) (h : a * c ≡ b * c [MOD m]) : a ≡ b [MOD m]
theorem submodule.span_induction {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] {x : M} {s : set M} {p : M → Prop} (h : x ∈ submodule.span R s) (Hs : ∀ (x : M), x ∈ s → p x) (H0 : p 0) (H1 : ∀ (x y : M), p x → p y → p (x + y)) (H2 : ∀ (a : R) (x : M), p x → p (a • x)) : p x
theorem exists_lt_of_cinfi_lt {α : Type u_1} {ι : Sort u_3} [conditionally_complete_linear_order α] {a : α} [nonempty ι] {f : ι → α} (h : infi f < a) : ∃ (i : ι), f i < a
theorem continuous_linear_equiv.cont_diff_within_at_comp_iff {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {s : set E} {f : E → F} {x : E} {n : with_top ℕ} (e : G ≃L[𝕜] E) : cont_diff_within_at 𝕜 n (f ∘ ⇑e) (⇑e ⁻¹' s) (⇑(e.symm) x) ↔ cont_diff_within_at 𝕜 n f s x
theorem mul_equiv.ext {M : Type u_6} {N : Type u_7} [has_mul M] [has_mul N] {f g : M ≃* N} (h : ∀ (x : M), ⇑f x = ⇑g x) : f = g
theorem category_theory.functor.final_of_adjunction {C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] {L : C ⥤ D} {R : D ⥤ C} (adj : L ⊣ R) : R.final
theorem tendsto_exp_mul_div_rpow_at_top (s b : ℝ) (hb : 0 < b) : filter.tendsto (λ (x : ℝ), real.exp (b * x) / x ^ s) filter.at_top filter.at_top
theorem polynomial.leading_coeff_prod' {R : Type u} {ι : Type w} (s : finset ι) [comm_semiring R] (f : ι → polynomial R) (h : s.prod (λ (i : ι), (f i).leading_coeff) ≠ 0) : (s.prod (λ (i : ι), f i)).leading_coeff = s.prod (λ (i : ι), (f i).leading_coeff)
theorem Top.presheaf.covering_presieve_eq_self {X : Top} {Y : topological_space.opens ↥X} (R : category_theory.presieve Y) : Top.presheaf.presieve_of_covering_aux (Top.presheaf.covering_of_presieve Y R) Y = R
theorem fintype.sum_bijective {α : Type u_1} {β : Type u_2} {M : Type u_3} [fintype α] [fintype β] [add_comm_monoid M] (e : α → β) (he : function.bijective e) (f : α → M) (g : β → M) (h : ∀ (x : α), f x = g (e x)) : finset.univ.sum (λ (x : α), f x) = finset.univ.sum (λ (x : β), g x)
theorem cont_diff_within_at.continuous_linear_map_comp {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {s : set E} {f : E → F} {x : E} {n : with_top ℕ} (g : F →L[𝕜] G) (hf : cont_diff_within_at 𝕜 n f s x) : cont_diff_within_at 𝕜 n (⇑g ∘ f) s x
theorem intermediate_field.mem_fixing_subgroup_iff {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E : intermediate_field K L) (σ : L ≃ₐ[K] L) : σ ∈ E.fixing_subgroup ↔ ∀ (x : L), x ∈ E → ⇑σ x = x
theorem vadd_right_cancel {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] {g1 g2 : G} (p : P) (h : g1 +ᵥ p = g2 +ᵥ p) : g1 = g2
theorem injective_of_increasing {α : Type u_1} {β : Type u_2} (r : α → α → Prop) (s : β → β → Prop) [is_trichotomous α r] [is_irrefl β s] (f : α → β) (hf : ∀ {x y : α}, r x y → s (f x) (f y)) : function.injective f
theorem measure_theory.measure.sub_apply {α : Type u_1} {m : measurable_space α} {μ ν : measure_theory.measure α} {s : set α} [measure_theory.is_finite_measure ν] (h₁ : measurable_set s) (h₂ : ν ≤ μ) : ⇑(μ - ν) s = ⇑μ s - ⇑ν s
theorem set.image2_congr' {α : Type u_1} {β : Type u_3} {γ : Type u_5} {f f' : α → β → γ} {s : set α} {t : set β} (h : ∀ (a : α) (b : β), f a b = f' a b) : set.image2 f s t = set.image2 f' s t
theorem add_con.to_setoid_inj {M : Type u_1} [has_add M] {c d : add_con M} (H : c.to_setoid = d.to_setoid) : c = d
theorem category_theory.limits.kernel_subobject_comp_le {C : Type u} [category_theory.category C] {X Y : C} [category_theory.limits.has_zero_morphisms C] (f : X ⟶ Y) [category_theory.limits.has_kernel f] {Z : C} (h : Y ⟶ Z) [category_theory.limits.has_kernel (f ≫ h)] : category_theory.limits.kernel_subobject f ≤ category_theory.limits.kernel_subobject (f ≫ h)
theorem algebraic_geometry.polynomial.image_of_Df_eq_comap_C_compl_zero_locus {R : Type u_1} [comm_ring R] {f : polynomial R} : algebraic_geometry.polynomial.image_of_Df f = ⇑(prime_spectrum.comap polynomial.C) '' (prime_spectrum.zero_locus {f})ᶜ
theorem measure_theory.tendsto_measure_Inter {α : Type u_1} {ι : Type u_5} {m : measurable_space α} {μ : measure_theory.measure α} [encodable ι] [semilattice_sup ι] {s : ι → set α} (hs : ∀ (n : ι), measurable_set (s n)) (hm : antitone s) (hf : ∃ (i : ι), ⇑μ (s i) ≠ ⊤) : filter.tendsto (⇑μ ∘ s) filter.at_top (nhds (⇑μ (⋂ (n : ι), s n)))
theorem is_metric_separated.finite_Union_left {X : Type u_1} [emetric_space X] {ι : Type u_2} {I : set ι} (hI : I.finite) {s : ι → set X} {t : set X} : (∀ (i : ι), i ∈ I → is_metric_separated (s i) t) → is_metric_separated (⋃ (i : ι) (H : i ∈ I), s i) t
theorem linear_map.mul_eq_one_comm {K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {f g : V →ₗ[K] V} : f * g = 1 ↔ g * f = 1
theorem inner_product_geometry.angle_neg_self_of_nonzero {V : Type u_1} [inner_product_space ℝ V] {x : V} (hx : x ≠ 0) : inner_product_geometry.angle (-x) x = real.pi
theorem euclidean_geometry.dist_eq_iff_dist_orthogonal_projection_eq {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} [nonempty ↥s] [complete_space ↥(s.direction)] {p1 p2 : P} (p3 : P) (hp1 : p1 ∈ s) (hp2 : p2 ∈ s) : has_dist.dist p1 p3 = has_dist.dist p2 p3 ↔ has_dist.dist p1 ↑(⇑(euclidean_geometry.orthogonal_projection s) p3) = has_dist.dist p2 ↑(⇑(euclidean_geometry.orthogonal_projection s) p3)
theorem add_submonoid.sum_mem {M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) {ι : Type u_2} {t : finset ι} {f : ι → M} (h : ∀ (c : ι), c ∈ t → f c ∈ S) : t.sum (λ (c : ι), f c) ∈ S
theorem category_theory.constant_of_preserves_morphisms {J : Type u₁} [category_theory.category J] [category_theory.is_preconnected J] {α : Type u₁} (F : J → α) (h : ∀ (j₁ j₂ : J), (j₁ ⟶ j₂) → F j₁ = F j₂) (j j' : J) : F j = F j'
theorem formal_multilinear_series.change_origin_radius {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) {x : E} : p.radius - ↑∥x∥₊ ≤ (p.change_origin x).radius
theorem is_prime_pow_iff_pow_succ {R : Type u_1} [comm_monoid_with_zero R] (n : R) : is_prime_pow n ↔ ∃ (p : R) (k : ℕ), prime p ∧ p ^ (k + 1) = n
theorem periodic_circle_map (c : ℂ) (R : ℝ) : function.periodic (circle_map c R) (2 * real.pi)
theorem edist_triangle_left {α : Type u} [pseudo_emetric_space α] (x y z : α) : has_edist.edist x y ≤ has_edist.edist z x + has_edist.edist z y
theorem euclidean_geometry.reflection_eq_iff_orthogonal_projection_eq {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (s₁ s₂ : affine_subspace ℝ P) [nonempty ↥s₁] [nonempty ↥s₂] [complete_space ↥(s₁.direction)] [complete_space ↥(s₂.direction)] (p : P) : ⇑(euclidean_geometry.reflection s₁) p = ⇑(euclidean_geometry.reflection s₂) p ↔ ↑(⇑(euclidean_geometry.orthogonal_projection s₁) p) = ↑(⇑(euclidean_geometry.orthogonal_projection s₂) p)
theorem equiv.perm.prod_prod_extend_right {β : Type v} {α : Type u_1} [decidable_eq α] (σ : α → equiv.perm β) {l : list α} (hl : l.nodup) (mem_l : ∀ (a : α), a ∈ l) : (list.map (λ (a : α), equiv.perm.prod_extend_right a (σ a)) l).prod = equiv.prod_congr_right σ
theorem is_primitive_root.pow_sub_one_norm_two {K : Type u} {L : Type v} [field L] {ζ : L} [field K] [algebra K L] [ne_zero 2] {k : ℕ} (hζ : is_primitive_root ζ (2 ^ (k + 1))) [is_cyclotomic_extension {2 ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic (2 ^ (k + 1)) K)) : ⇑(algebra.norm K) (ζ ^ 2 ^ k - 1) = (-2) ^ 2 ^ k
theorem measure_theory.integral_divergence_of_has_fderiv_within_at_off_countable {E : Type u} [normed_group E] [normed_space ℝ E] [complete_space E] {n : ℕ} (a b : fin (n + 1) → ℝ) (hle : a ≤ b) (f : (fin (n + 1) → ℝ) → fin (n + 1) → E) (f' : (fin (n + 1) → ℝ) → ((fin (n + 1) → ℝ) →L[ℝ] fin (n + 1) → E)) (s : set (fin (n + 1) → ℝ)) (hs : s.countable) (Hc : continuous_on f (set.Icc a b)) (Hd : ∀ (x : fin (n + 1) → ℝ), x ∈ set.univ.pi (λ (i : fin (n + 1)), set.Ioo (a i) (b i))  s → has_fderiv_at f (f' x) x) (Hi : measure_theory.integrable_on (λ (x : fin (n + 1) → ℝ), finset.univ.sum (λ (i : fin (n + 1)), ⇑(f' x) (pi.single i 1) i)) (set.Icc a b) measure_theory.measure_space.volume) : ∫ (x : fin (n + 1) → ℝ) in set.Icc a b, finset.univ.sum (λ (i : fin (n + 1)), ⇑(f' x) (pi.single i 1) i) = finset.univ.sum (λ (i : fin (n + 1)), (∫ (x : fin n → ℝ) in set.Icc (a ∘ ⇑(i.succ_above)) (b ∘ ⇑(i.succ_above)), f (i.insert_nth (b i) x) i) - ∫ (x : fin n → ℝ) in set.Icc (a ∘ ⇑(i.succ_above)) (b ∘ ⇑(i.succ_above)), f (i.insert_nth (a i) x) i)
theorem asymptotics.is_o_iff {α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : α → E} {g : α → F} {l : filter α} : f =o[l] g ↔ ∀ ⦃c : ℝ⦄, 0 < c → (∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g x∥)
theorem left.add_lt_add {α : Type u_1} [has_add α] [preorder α] [covariant_class α α has_add.add has_lt.lt] [covariant_class α α (function.swap has_add.add) has_le.le] {a b c d : α} (h₁ : a < b) (h₂ : c < d) : a + c < b + d
theorem linear_recurrence.mk_sol_eq_init {α : Type u_1} [comm_semiring α] (E : linear_recurrence α) (init : fin E.order → α) (n : fin E.order) : E.mk_sol init ↑n = init n
theorem category_theory.presheaf.is_sheaf_iff_is_sheaf' {C : Type u₁} [category_theory.category C] {A : Type u₂} [category_theory.category A] (J : category_theory.grothendieck_topology C) (P : Cᵒᵖ ⥤ A) [category_theory.limits.has_products A] [category_theory.limits.has_pullbacks C] : category_theory.presheaf.is_sheaf J P ↔ category_theory.presheaf.is_sheaf' J P
theorem euclidean_geometry.circumcenter_eq_of_cospherical_subset {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} {ps : set P} (h : ps ⊆ ↑s) [nonempty ↥s] {n : ℕ} [finite_dimensional ℝ ↥(s.direction)] (hd : finite_dimensional.finrank ℝ ↥(s.direction) = n) (hc : euclidean_geometry.cospherical ps) {sx₁ sx₂ : affine.simplex ℝ P n} (hsx₁ : set.range sx₁.points ⊆ ps) (hsx₂ : set.range sx₂.points ⊆ ps) : sx₁.circumcenter = sx₂.circumcenter
theorem infi_option_elim {α : Type u_1} {β : Type u_2} [complete_lattice α] (a : α) (f : β → α) : (⨅ (o : option β), option.elim a f o) = a ⊓ ⨅ (b : β), f b
theorem measure_theory.tendsto_in_measure_of_tendsto_Lp {α : Type u_1} {ι : Type u_2} {E : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [normed_group E] {p : ennreal} [hp : fact (1 ≤ p)] {f : ι → ↥(measure_theory.Lp E p μ)} {g : ↥(measure_theory.Lp E p μ)} {l : filter ι} (hfg : filter.tendsto f l (nhds g)) : measure_theory.tendsto_in_measure μ (λ (n : ι), ⇑(f n)) l ⇑g
theorem add_equiv.apply_symm_apply {M : Type u_6} {N : Type u_7} [has_add M] [has_add N] (e : M ≃+ N) (y : N) : ⇑e (⇑(e.symm) y) = y
theorem filter.low_scores {β : Type u_4} [linear_order β] [no_min_order β] {u : ℕ → β} (hu : filter.tendsto u filter.at_top filter.at_bot) (N : ℕ) : ∃ (n : ℕ) (H : n ≥ N), ∀ (k : ℕ), k < n → u n < u k
theorem finsupp.mul_prod_erase' {α : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [comm_monoid N] (f : α →₀ M) (y : α) (g : α → M → N) (hg : ∀ (i : α), g i 0 = 1) : g y (⇑f y) * (finsupp.erase y f).prod g = f.prod g
theorem vsub_left_cancel_iff {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] {p1 p2 p : P} : p1 -ᵥ p = p2 -ᵥ p ↔ p1 = p2
theorem mul_self_add_mul_self_eq_zero {α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0
theorem right.add_neg' {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0
theorem finset.card_le_one_of_subsingleton {α : Type u_1} [subsingleton α] (s : finset α) : s.card ≤ 1
theorem comap_uniformity_of_spaced_out {β : Type u_2} [uniform_space β] {α : Type u_1} {f : α → β} {s : set (β × β)} (hs : s ∈ uniformity β) (hf : pairwise (λ (x y : α), (f x, f y) ∉ s)) : filter.comap (prod.map f f) (uniformity β) = filter.principal id_rel
theorem category_theory.is_iso_of_hom_simple {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] {X Y : C} [category_theory.simple X] [category_theory.simple Y] {f : X ⟶ Y} (w : f ≠ 0) : category_theory.is_iso f
theorem is_p_group.card_modeq_card_fixed_points {p : ℕ} {G : Type u_1} [group G] (hG : is_p_group p G) [hp : fact (nat.prime p)] (α : Type u_2) [mul_action G α] [fintype α] [fintype ↥(mul_action.fixed_points G α)] : fintype.card α ≡ fintype.card ↥(mul_action.fixed_points G α) [MOD p]
theorem category_theory.zero_not_simple (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] [category_theory.simple 0] : false
theorem is_add_right_regular_of_add_eq_zero {R : Type u_1} {a b : R} [add_monoid R] (h : a + b = 0) : is_add_right_regular a
theorem is_add_group_hom.add {α : Type u_1} {β : Type u_2} [add_group α] [add_comm_group β] {f g : α → β} (hf : is_add_group_hom f) (hg : is_add_group_hom g) : is_add_group_hom (λ (a : α), f a + g a)
theorem is_torsion_free.not_torsion {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G → ¬monoid.is_torsion G
theorem dfinsupp.lsum_single {ι : Type u_1} {R : Type u_2} (S : Type u_3) {M : ι → Type u_4} {N : Type u_5} [dec_ι : decidable_eq ι] [semiring R] [Π (i : ι), add_comm_monoid (M i)] [Π (i : ι), module R (M i)] [add_comm_monoid N] [module R N] [semiring S] [module S N] [smul_comm_class R S N] (F : Π (i : ι), M i →ₗ[R] N) (i : ι) (x : M i) : ⇑(⇑(dfinsupp.lsum S) F) (dfinsupp.single i x) = ⇑(F i) x
theorem generalized_continued_fraction.ext_iff {α : Type u_1} {g g' : generalized_continued_fraction α} : g = g' ↔ g.h = g'.h ∧ g.s = g'.s
theorem has_deriv_at.lhopital_zero_nhds_right {a : ℝ} {l : filter ℝ} {f f' g g' : ℝ → ℝ} (hff' : ∀ᶠ (x : ℝ) in nhds_within a (set.Ioi a), has_deriv_at f (f' x) x) (hgg' : ∀ᶠ (x : ℝ) in nhds_within a (set.Ioi a), has_deriv_at g (g' x) x) (hg' : ∀ᶠ (x : ℝ) in nhds_within a (set.Ioi a), g' x ≠ 0) (hfa : filter.tendsto f (nhds_within a (set.Ioi a)) (nhds 0)) (hga : filter.tendsto g (nhds_within a (set.Ioi a)) (nhds 0)) (hdiv : filter.tendsto (λ (x : ℝ), f' x / g' x) (nhds_within a (set.Ioi a)) l) : filter.tendsto (λ (x : ℝ), f x / g x) (nhds_within a (set.Ioi a)) l
theorem tendsto_locally_uniformly.continuous {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {p : filter ι} [topological_space α] (h : tendsto_locally_uniformly F f p) (hc : ∀ᶠ (n : ι) in p, continuous (F n)) [p.ne_bot] : continuous f
theorem linear_isometry_equiv.reflections_generate_dim {F : Type u_3} [inner_product_space ℝ F] [finite_dimensional ℝ F] (φ : F ≃ₗᵢ[ℝ] F) : ∃ (l : list F), l.length ≤ finite_dimensional.finrank ℝ F ∧ φ = (list.map (λ (v : F), reflection (submodule.span ℝ {v})ᗮ) l).prod
theorem is_localization.exist_integer_multiples {R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] {ι : Type u_3} (s : finset ι) (f : ι → S) : ∃ (b : ↥M), ∀ (i : ι), i ∈ s → is_localization.is_integer R (↑b • f i)
theorem formal_multilinear_series.id_apply_one (𝕜 : Type u_1) (E : Type u_2) [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] (v : fin 1 → E) : ⇑(formal_multilinear_series.id 𝕜 E 1) v = v 0
theorem algebraic_geometry.PresheafedSpace.stalk_map.congr {C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X Y : algebraic_geometry.PresheafedSpace C} (α β : X ⟶ Y) (h₁ : α = β) (x x' : ↥X) (h₂ : x = x') : algebraic_geometry.PresheafedSpace.stalk_map α x ≫ category_theory.eq_to_hom _ = category_theory.eq_to_hom _ ≫ algebraic_geometry.PresheafedSpace.stalk_map β x'
theorem strict_mono.add_monotone {α : Type u_1} {β : Type u_2} [has_add α] [preorder α] [preorder β] {f g : β → α} [covariant_class α α has_add.add has_le.le] [covariant_class α α (function.swap has_add.add) has_lt.lt] (hf : strict_mono f) (hg : monotone g) : strict_mono (λ (x : β), f x + g x)
theorem Inf_eq_of_forall_ge_of_forall_gt_exists_lt {α : Type u_1} [complete_lattice α] {s : set α} {b : α} : (∀ (a : α), a ∈ s → b ≤ a) → (∀ (w : α), b < w → (∃ (a : α) (H : a ∈ s), a < w)) → has_Inf.Inf s = b
theorem set.preimage_equiv_eq_image_symm {α : Type u_1} {β : Type u_2} (S : set α) (f : β ≃ α) : ⇑f ⁻¹' S = ⇑(f.symm) '' S
theorem gauge_smul {E : Type u_1} [add_comm_group E] [module ℝ E] {α : Type u_2} [linear_ordered_field α] [mul_action_with_zero α ℝ] [ordered_smul α ℝ] [module α E] [is_scalar_tower α ℝ (set E)] {s : set E} (symmetric : ∀ (x : E), x ∈ s → -x ∈ s) (r : α) (x : E) : gauge s (r • x) = |r| • gauge s x
theorem continuous_map.norm_le {α : Type u_1} {E : Type u_3} [topological_space α] [compact_space α] [normed_group E] (f : C(α, E)) {C : ℝ} (C0 : 0 ≤ C) : ∥f∥ ≤ C ↔ ∀ (x : α), ∥⇑f x∥ ≤ C
theorem monotone.continuous_of_dense_range {α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} (h_mono : monotone f) (h_dense : dense_range f) : continuous f
theorem metric.diam_mono {α : Type u} [pseudo_metric_space α] {s t : set α} (h : s ⊆ t) (ht : metric.bounded t) : metric.diam s ≤ metric.diam t
theorem add_con.Inf_to_setoid {M : Type u_1} [has_add M] (S : set (add_con M)) : (has_Inf.Inf S).to_setoid = has_Inf.Inf (add_con.to_setoid '' S)
theorem ennreal.mul_infi_of_ne {ι : Sort u_1} {f : ι → ennreal} {x : ennreal} (h0 : x ≠ 0) (h : x ≠ ⊤) : x * infi f = ⨅ (i : ι), x * f i
theorem add_equiv.is_add_hom {M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (h : M ≃+ N) : is_add_hom ⇑h
theorem add_con.add {M : Type u_1} [has_add M] (c : add_con M) {w x y z : M} : ⇑c w x → ⇑c y z → ⇑c (w + y) (x + z)
theorem topological_space.is_separable.separable_space {α : Type u} [pseudo_metric_space α] {s : set α} (hs : topological_space.is_separable s) : topological_space.separable_space ↥s
theorem linear_independent_bounded_of_finset_linear_independent_bounded {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] {n : ℕ} (H : ∀ (s : finset M), linear_independent R (λ (i : ↥s), ↑i) → s.card ≤ n) (s : set M) : linear_independent R coe → cardinal.mk ↥s ≤ ↑n
theorem subring.ext {R : Type u} [ring R] {S T : subring R} (h : ∀ (x : R), x ∈ S ↔ x ∈ T) : S = T
theorem intermediate_field.add_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} : x ∈ S → y ∈ S → x + y ∈ S
theorem emetric.tendsto_locally_uniformly_on_iff {α : Type u} {β : Type v} [pseudo_emetric_space α] {ι : Type u_1} [topological_space β] {F : ι → β → α} {f : β → α} {p : filter ι} {s : set β} : tendsto_locally_uniformly_on F f p s ↔ ∀ (ε : ennreal), ε > 0 → ∀ (x : β), x ∈ s → (∃ (t : set β) (H : t ∈ nhds_within x s), ∀ᶠ (n : ι) in p, ∀ (y : β), y ∈ t → has_edist.edist (f y) (F n y) < ε)
theorem category_theory.limits.initial_mono_class.of_is_initial {C : Type u₁} [category_theory.category C] {I : C} (hI : category_theory.limits.is_initial I) (h : ∀ (X : C), category_theory.mono (hI.to X)) : category_theory.limits.initial_mono_class C
theorem empty_wf {α : Sort u} : well_founded empty_relation
theorem filter.tendsto.inv {α : Type u} {G : Type w} [topological_space G] [has_inv G] [has_continuous_inv G] {f : α → G} {l : filter α} {y : G} (h : filter.tendsto f l (nhds y)) : filter.tendsto (λ (x : α), (f x)⁻¹) l (nhds y⁻¹)
theorem filter.tendsto_of_subseq_tendsto {α : Type u_1} {ι : Type u_2} {x : ι → α} {f : filter α} {l : filter ι} [l.is_countably_generated] (hxy : ∀ (ns : ℕ → ι), filter.tendsto ns filter.at_top l → (∃ (ms : ℕ → ℕ), filter.tendsto (λ (n : ℕ), x (ns (ms n))) filter.at_top f)) : filter.tendsto x l f
theorem set.image_image2_distrib_left {α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {f : α → β → γ} {s : set α} {t : set β} {g : γ → δ} {f' : α' → β → δ} {g' : α → α'} (h_distrib : ∀ (a : α) (b : β), g (f a b) = f' (g' a) b) : g '' set.image2 f s t = set.image2 f' (g' '' s) t
theorem finsum_mem_add_distrib' {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f g : α → M} {s : set α} (hf : (s ∩ function.support f).finite) (hg : (s ∩ function.support g).finite) : finsum (λ (i : α), finsum (λ (H : i ∈ s), f i + g i)) = finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) + finsum (λ (i : α), finsum (λ (H : i ∈ s), g i))
theorem matrix.pivot.mul_list_transvec_row_last_col {𝕜 : Type u_3} [field 𝕜] {r : ℕ} (M : matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜) (i : fin r ⊕ unit) : M.mul (matrix.pivot.list_transvec_row M).prod i (sum.inr ()) = M i (sum.inr ())
theorem differentiable_at.conformal_at {E : Type u_1} [normed_group E] [normed_space ℂ E] {z : ℂ} {f : ℂ → E} (h : differentiable_at ℂ f z) (hf' : deriv f z ≠ 0) : conformal_at f z
theorem module.is_torsion_by_iff_torsion_by_eq_top {R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] (a : R) : module.is_torsion_by R M a ↔ submodule.torsion_by R M a = ⊤
theorem basis.orientation_eq_iff_det_pos {R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {ι : Type u_3} [decidable_eq ι] [fintype ι] (e₁ e₂ : basis ι R M) : e₁.orientation = e₂.orientation ↔ 0 < ⇑(e₁.det) ⇑e₂
theorem is_dedekind_domain.height_one_spectrum.valuation_exists_uniformizer {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) : ∃ (π : K), ⇑(v.valuation) π = ↑(⇑multiplicative.of_add (-1))
theorem list.nodup.of_attach {α : Type u} {l : list α} : l.attach.nodup → l.nodup
theorem is_local_max_on.fderiv_within_eq_zero {E : Type u} [normed_group E] [normed_space ℝ E] {f : E → ℝ} {a : E} {s : set E} (h : is_local_max_on f s a) {y : E} (hy : y ∈ pos_tangent_cone_at s a) (hy' : -y ∈ pos_tangent_cone_at s a) : ⇑(fderiv_within ℝ f s a) y = 0
theorem mv_power_series.is_unit_constant_coeff {σ : Type u_1} {R : Type u_2} [semiring R] (φ : mv_power_series σ R) (h : is_unit φ) : is_unit (⇑(mv_power_series.constant_coeff σ R) φ)
theorem num_dvd_of_is_root {A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} {r : K} (hr : ⇑(polynomial.aeval r) p = 0) : is_fraction_ring.num A r ∣ p.coeff 0
theorem probability_theory.lintegral_mul_eq_lintegral_mul_lintegral_of_indep_fun' {α : Type u_1} {mα : measurable_space α} {μ : measure_theory.measure α} {f g : α → ennreal} (h_meas_f : ae_measurable f μ) (h_meas_g : ae_measurable g μ) (h_indep_fun : probability_theory.indep_fun f g μ) : ∫⁻ (a : α), (f * g) a ∂μ = ∫⁻ (a : α), f a ∂μ * ∫⁻ (a : α), g a ∂μ
theorem measure_theory.lintegral_mul_right_eq_self {G : Type u_4} [measurable_space G] {μ : measure_theory.measure G} [group G] [has_measurable_mul G] [μ.is_mul_right_invariant] (f : G → ennreal) (g : G) : ∫⁻ (x : G), f (x * g) ∂μ = ∫⁻ (x : G), f x ∂μ
theorem is_integral_of_mem_of_fg {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (S : subalgebra R A) (HS : S.to_submodule.fg) (x : A) (hx : x ∈ S) : is_integral R x
theorem algebraic_geometry.structure_sheaf.comap_id_eq_map {R : Type u} [comm_ring R] (U V : topological_space.opens ↥(algebraic_geometry.prime_spectrum.Top R)) (iVU : V ⟶ U) : algebraic_geometry.structure_sheaf.comap (ring_hom.id R) U V _ = (algebraic_geometry.Spec.structure_sheaf R).val.map iVU.op
theorem add_monoid.mem_closure_union_iff {M : Type u_1} [add_comm_monoid M] {s t : set M} {x : M} : x ∈ add_monoid.closure (s ∪ t) ↔ ∃ (y : M) (H : y ∈ add_monoid.closure s) (z : M) (H : z ∈ add_monoid.closure t), y + z = x
theorem inner_product_geometry.norm_add_eq_norm_sub_iff_angle_eq_pi_div_two {V : Type u_1} [inner_product_space ℝ V] (x y : V) : ∥x + y∥ = ∥x - y∥ ↔ inner_product_geometry.angle x y = real.pi / 2
theorem metric.is_open_thickening {α : Type u} [pseudo_emetric_space α] {δ : ℝ} {E : set α} : is_open (metric.thickening δ E)
theorem antitone.map_bdd_above {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} (hf : antitone f) {s : set α} : bdd_above s → bdd_below (f '' s)
theorem pnat.xgcd_type.step_v (u : pnat.xgcd_type) (hr : u.r ≠ 0) : u.step.v = u.v.swap
theorem subset_span_points (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s ⊆ span_points k s
theorem order.lt_of_succ_lt_succ {α : Type u_1} [preorder α] [succ_order α] {a b : α} [no_max_order α] : order.succ a < order.succ b → a < b
theorem uv.mem_of_mem_compression {α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] {s : finset α} {u v a : α} (ha : a ∈ uv.compression u v s) (hva : v ≤ a) (hvu : v = ⊥ → u = ⊥) : a ∈ s
theorem phragmen_lindelof.eq_zero_on_quadrant_II {E : Type u_1} [normed_group E] [normed_space ℂ E] {f : ℂ → E} (hd : diff_cont_on_cl ℂ f (set.Iio 0 ×ℂ set.Ioi 0)) (hB : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ filter.principal (set.Iio 0 ×ℂ set.Ioi 0)] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hre : ∀ (x : ℝ), x ≤ 0 → f ↑x = 0) (him : ∀ (x : ℝ), 0 ≤ x → f (↑x * complex.I) = 0) : set.eq_on f 0 {z : ℂ | z.re ≤ 0 ∧ 0 ≤ z.im}
theorem monotone.tendsto_at_top_at_top {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] {f : α → β} (hf : monotone f) (h : ∀ (b : β), ∃ (a : α), b ≤ f a) : filter.tendsto f filter.at_top filter.at_top
theorem differentiable.mdifferentiable {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {f : E → E'} : differentiable 𝕜 f → mdifferentiable (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f
theorem sub_one_div_inv_le_two {α : Type u_1} [linear_ordered_field α] {a : α} (a2 : 2 ≤ a) : (1 - 1 / a)⁻¹ ≤ 2
theorem lie_algebra.abelian_radical_iff_solvable_is_abelian (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : is_lie_abelian ↥(lie_algebra.radical R L) ↔ ∀ (I : lie_ideal R L), lie_algebra.is_solvable R ↥I → is_lie_abelian ↥I
theorem category_theory.has_limits_of_reflective {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (R : D ⥤ C) [category_theory.limits.has_limits_of_size C] [category_theory.reflective R] : category_theory.limits.has_limits_of_size D
theorem exists_dual_vector' (𝕜 : Type v) [is_R_or_C 𝕜] {E : Type u} [normed_group E] [normed_space 𝕜 E] [nontrivial E] (x : E) : ∃ (g : E →L[𝕜] 𝕜), ∥g∥ = 1 ∧ ⇑g x = ↑∥x∥
theorem is_smul_regular.smul {R : Type u_1} {S : Type u_2} {M : Type u_3} {a : R} {s : S} [has_scalar R M] [has_scalar R S] [has_scalar S M] [is_scalar_tower R S M] (ra : is_smul_regular M a) (rs : is_smul_regular M s) : is_smul_regular M (a • s)
theorem quotient_group.subgroup_eq_top_of_subsingleton {G : Type u} [group G] (H : subgroup G) (h : subsingleton (G ⧸ H)) : H = ⊤
theorem matrix.is_symm.from_blocks {α : Type u_1} {n : Type u_3} {m : Type u_4} {A : matrix m m α} {B : matrix m n α} {C : matrix n m α} {D : matrix n n α} (hA : A.is_symm) (hBC : B.transpose = C) (hD : D.is_symm) : (matrix.from_blocks A B C D).is_symm
theorem hindman.FP.mul {M : Type u_1} [semigroup M] {a : stream M} {m : M} (hm : m ∈ hindman.FP a) : ∃ (n : ℕ), ∀ (m' : M), m' ∈ hindman.FP (stream.drop n a) → m * m' ∈ hindman.FP a
theorem orthonormal.oangle_eq_iff_eq_pos_smul_rotation_of_ne_zero {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : real.angle) : hb.oangle x y = θ ↔ ∃ (r : ℝ), 0 < r ∧ y = r • ⇑(hb.rotation θ) x
theorem convex.to_cone_is_least {𝕜 : Type u_1} {E : Type u_2} [linear_ordered_field 𝕜] [ordered_add_comm_group E] [module 𝕜 E] {s : set E} (hs : convex 𝕜 s) : is_least {t : convex_cone 𝕜 E | s ⊆ ↑t} (convex.to_cone s hs)
theorem iterated_fderiv_within_apply_eq_iterated_deriv_within_mul_prod {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {n : ℕ} {f : 𝕜 → F} {s : set 𝕜} {x : 𝕜} {m : fin n → 𝕜} : ⇑(iterated_fderiv_within 𝕜 n f s x) m = finset.univ.prod (λ (i : fin n), m i) • iterated_deriv_within n f s x
theorem clifford_algebra_complex.of_complex_conj (c : ℂ) : ⇑clifford_algebra_complex.of_complex (⇑(star_ring_end ℂ) c) = ⇑clifford_algebra.involute (⇑clifford_algebra_complex.of_complex c)
theorem orthonormal.exists_linear_isometry_equiv_eq {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (f : V ≃ₗᵢ[ℝ] V) : ∃ (θ : real.angle), f = hb.rotation θ ∨ f = hb.conj_lie.trans (hb.rotation θ)
theorem measure_theory.tendsto_lintegral_of_dominated_convergence' {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {F : ℕ → α → ennreal} {f : α → ennreal} (bound : α → ennreal) (hF_meas : ∀ (n : ℕ), ae_measurable (F n) μ) (h_bound : ∀ (n : ℕ), F n ≤ᵐ[μ] bound) (h_fin : ∫⁻ (a : α), bound a ∂μ ≠ ⊤) (h_lim : ∀ᵐ (a : α) ∂μ, filter.tendsto (λ (n : ℕ), F n a) filter.at_top (nhds (f a))) : filter.tendsto (λ (n : ℕ), ∫⁻ (a : α), F n a ∂μ) filter.at_top (nhds (∫⁻ (a : α), f a ∂μ))
theorem nnreal.geom_mean_le_arith_mean_weighted {ι : Type u} (s : finset ι) (w z : ι → nnreal) (hw' : s.sum (λ (i : ι), w i) = 1) : s.prod (λ (i : ι), z i ^ ↑(w i)) ≤ s.sum (λ (i : ι), w i * z i)
theorem liouville.transcendental {x : ℝ} (lx : liouville x) : transcendental ℤ x
theorem interval_integral.interval_integral_pos_of_pos {f : ℝ → ℝ} {a b : ℝ} (hfi : interval_integrable f measure_theory.measure_space.volume a b) (h : ∀ (x : ℝ), 0 < f x) (hab : a < b) : 0 < ∫ (x : ℝ) in a..b, f x
theorem SemiNormedGroup.explicit_coker.map_desc {A B C D B' D' : SemiNormedGroup} {fab : A ⟶ B} {fbd : B ⟶ D} {fac : A ⟶ C} {fcd : C ⟶ D} {h : fab ≫ fbd = fac ≫ fcd} {fbb' : B ⟶ B'} {fdd' : D ⟶ D'} {condb : fab ≫ fbb' = 0} {condd : fcd ≫ fdd' = 0} {g : B' ⟶ D'} (h' : fbb' ≫ g = fbd ≫ fdd') : SemiNormedGroup.explicit_cokernel_desc condb ≫ g = SemiNormedGroup.explicit_cokernel.map h ≫ SemiNormedGroup.explicit_cokernel_desc condd
theorem polynomial.to_laurent_apply {R : Type u_1} [semiring R] (p : polynomial R) : ⇑polynomial.to_laurent p = finsupp.map_domain coe p.to_finsupp
theorem has_ftaylor_series_up_to_on.exists_lipschitz_on_with {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {f : E → F} {p : E → formal_multilinear_series ℝ E F} {s : set E} {x : E} (hf : has_ftaylor_series_up_to_on 1 f p (has_insert.insert x s)) (hs : convex ℝ s) : ∃ (K : nnreal) (t : set E) (H : t ∈ nhds_within x s), lipschitz_on_with K f t
theorem mem_span_set {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] {m : M} {s : set M} : m ∈ submodule.span R s ↔ ∃ (c : M →₀ R), ↑(c.support) ⊆ s ∧ c.sum (λ (mi : M) (r : R), r • mi) = m
theorem induced_bot {X : Type u_1} {Y : Type u_2} {f : X → Y} (hf : function.injective f) : topological_space.induced f ⊥ = ⊥
theorem subgroup.smul_invariant_measure {G : Type u_1} [group G] [measurable_space G] [topological_space G] [topological_group G] [borel_space G] {μ : measure_theory.measure G} {Γ : subgroup G} [μ.is_mul_right_invariant] : measure_theory.smul_invariant_measure ↥(Γ.opposite) G μ
theorem ennreal.tendsto_tsum_compl_at_top_zero {α : Type u_1} {f : α → ennreal} (hf : ∑' (x : α), f x ≠ ⊤) : filter.tendsto (λ (s : finset α), ∑' (b : {x // x ∉ s}), f ↑b) filter.at_top (nhds 0)
theorem formal_multilinear_series.id_apply_ne_one (𝕜 : Type u_1) (E : Type u_2) [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] {n : ℕ} (h : n ≠ 1) : formal_multilinear_series.id 𝕜 E n = 0
theorem bounded_continuous_function.lipschitz_comp {α : Type u} {β : Type v} {γ : Type w} [topological_space α] [pseudo_metric_space β] [pseudo_metric_space γ] {G : β → γ} {C : nnreal} (H : lipschitz_with C G) : lipschitz_with C (bounded_continuous_function.comp G H)
theorem turing.list_blank.cons_head_tail {Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ) : turing.list_blank.cons l.head l.tail = l
theorem set.image_subset {α : Type u} {β : Type v} {a b : set α} (f : α → β) (h : a ⊆ b) : f '' a ⊆ f '' b
theorem add_subgroup.le_normalizer_comap {G : Type u_1} [add_group G] {H : add_subgroup G} {N : Type u_3} [add_group N] (f : N →+ G) : add_subgroup.comap f H.normalizer ≤ (add_subgroup.comap f H).normalizer
theorem category_theory.limits.is_iso_ι_of_is_terminal {C : Type u₁} [category_theory.category C] {J : Type u} [category_theory.category J] {j : J} (I : category_theory.limits.is_terminal j) (F : J ⥤ C) [category_theory.limits.has_colimit F] : category_theory.is_iso (category_theory.limits.colimit.ι F j)
theorem dist_le_of_approx_trajectories_ODE_of_mem_set {E : Type u_1} [normed_group E] [normed_space ℝ E] {v : ℝ → E → E} {s : ℝ → set E} {K : ℝ} (hv : ∀ (t : ℝ) (x : E), x ∈ s t → ∀ (y : E), y ∈ s t → has_dist.dist (v t x) (v t y) ≤ K * has_dist.dist x y) {f g f' g' : ℝ → E} {a b εf εg δ : ℝ} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (t : ℝ), t ∈ set.Ico a b → has_deriv_within_at f (f' t) (set.Ici t) t) (f_bound : ∀ (t : ℝ), t ∈ set.Ico a b → has_dist.dist (f' t) (v t (f t)) ≤ εf) (hfs : ∀ (t : ℝ), t ∈ set.Ico a b → f t ∈ s t) (hg : continuous_on g (set.Icc a b)) (hg' : ∀ (t : ℝ), t ∈ set.Ico a b → has_deriv_within_at g (g' t) (set.Ici t) t) (g_bound : ∀ (t : ℝ), t ∈ set.Ico a b → has_dist.dist (g' t) (v t (g t)) ≤ εg) (hgs : ∀ (t : ℝ), t ∈ set.Ico a b → g t ∈ s t) (ha : has_dist.dist (f a) (g a) ≤ δ) (t : ℝ) (H : t ∈ set.Icc a b) : has_dist.dist (f t) (g t) ≤ gronwall_bound δ K (εf + εg) (t - a)
theorem add_con.inf_iff_and {M : Type u_1} [has_add M] {c d : add_con M} {x y : M} : ⇑(c ⊓ d) x y ↔ ⇑c x y ∧ ⇑d x y
theorem algebra.finite_presentation.equiv {R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [algebra R A] [comm_ring B] [algebra R B] (hfp : algebra.finite_presentation R A) (e : A ≃ₐ[R] B) : algebra.finite_presentation R B
theorem free_product.neword.of_word {ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] (w : free_product.word M) (h : w ≠ free_product.word.empty) : ∃ (i j : ι) (w' : free_product.neword M i j), w'.to_word = w
theorem category_theory.cosimplicial_object.δ_comp_σ_of_le {C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) {n : ℕ} {i : fin (n + 2)} {j : fin (n + 1)} (H : i ≤ ⇑fin.cast_succ j) : X.δ (⇑fin.cast_succ i) ≫ X.σ j.succ = X.σ j ≫ X.δ i
theorem is_bounded_linear_map.cont_diff {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {n : with_top ℕ} (hf : is_bounded_linear_map 𝕜 f) : cont_diff 𝕜 n f
theorem finset.exists_sum_fiber_lt_of_sum_fiber_nonneg_of_sum_lt_nsmul {α : Type u} {β : Type v} {M : Type w} [decidable_eq β] {s : finset α} {t : finset β} {f : α → β} {w : α → M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (ht : ∀ (y : β), y ∉ t → 0 ≤ (finset.filter (λ (x : α), f x = y) s).sum (λ (x : α), w x)) (hb : s.sum (λ (x : α), w x) < t.card • b) : ∃ (y : β) (H : y ∈ t), (finset.filter (λ (x : α), f x = y) s).sum (λ (x : α), w x) < b
theorem power_series.exp_pow_eq_rescale_exp {A : Type u_1} [comm_ring A] [algebra ℚ A] (k : ℕ) : power_series.exp A ^ k = ⇑(power_series.rescale ↑k) (power_series.exp A)
theorem has_strict_fderiv_at.of_local_left_inverse {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {f' : E ≃L[𝕜] F} {g : F → E} {a : F} (hg : continuous_at g a) (hf : has_strict_fderiv_at f ↑f' (g a)) (hfg : ∀ᶠ (y : F) in nhds a, f (g y) = y) : has_strict_fderiv_at g ↑(f'.symm) a
theorem monoid_algebra.support_gen_of_gen {R : Type u_1} {M : Type u_2} [comm_semiring R] [monoid M] {S : set (monoid_algebra R M)} (hS : algebra.adjoin R S = ⊤) : algebra.adjoin R (⋃ (f : monoid_algebra R M) (H : f ∈ S), ⇑(monoid_algebra.of R M) '' ↑(f.support)) = ⊤
theorem Gromov_Hausdorff.GH_dist_eq_Hausdorff_dist (X : Type u) [metric_space X] [compact_space X] [nonempty X] (Y : Type v) [metric_space Y] [compact_space Y] [nonempty Y] : ∃ (Φ : X → ↥(lp (λ (n : ℕ), ℝ) ⊤)) (Ψ : Y → ↥(lp (λ (n : ℕ), ℝ) ⊤)), isometry Φ ∧ isometry Ψ ∧ Gromov_Hausdorff.GH_dist X Y = metric.Hausdorff_dist (set.range Φ) (set.range Ψ)
theorem finite_dimensional.of_surjective {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {V₂ : Type v'} [add_comm_group V₂] [module K V₂] (f : V →ₗ[K] V₂) (w : function.surjective ⇑f) [finite_dimensional K V] : finite_dimensional K V₂
theorem second_derivative_symmetric {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {x : E} {f : E → F} {f' : E → (E →L[ℝ] F)} {f'' : E →L[ℝ] E →L[ℝ] F} (hf : ∀ (y : E), has_fderiv_at f (f' y) y) (hx : has_fderiv_at f' f'' x) (v w : E) : ⇑(⇑f'' v) w = ⇑(⇑f'' w) v
theorem setoid.sup_eq_eqv_gen {α : Type u_1} (r s : setoid α) : r ⊔ s = eqv_gen.setoid (λ (x y : α), r.rel x y ∨ s.rel x y)
theorem infi_eq_infi_finset' {α : Type u_1} {ι' : Sort u_5} [complete_lattice α] (s : ι' → α) : (⨅ (i : ι'), s i) = ⨅ (t : finset (plift ι')) (i : plift ι') (H : i ∈ t), s i.down
theorem orthonormal.exists_linear_isometry_equiv_eq_of_det_neg {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {f : V ≃ₗᵢ[ℝ] V} (hd : ⇑linear_map.det ↑(f.to_linear_equiv) < 0) : ∃ (θ : real.angle), f = hb.conj_lie.trans (hb.rotation θ)
theorem category_theory.normal_mono_category.has_limit_parallel_pair {C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_kernels C] [category_theory.normal_mono_category C] {X Y : C} (f g : X ⟶ Y) : category_theory.limits.has_limit (category_theory.limits.parallel_pair f g)
theorem finsupp.prod_add_index' {α : Type u_1} {M : Type u_5} {N : Type u_7} [add_zero_class M] [comm_monoid N] {f g : α →₀ M} {h : α → M → N} (h_zero : ∀ (a : α), h a 0 = 1) (h_add : ∀ (a : α) (b₁ b₂ : M), h a (b₁ + b₂) = h a b₁ * h a b₂) : (f + g).prod h = f.prod h * g.prod h
theorem is_metric_separated.finset_Union_left {X : Type u_1} [emetric_space X] {ι : Type u_2} {I : finset ι} {s : ι → set X} {t : set X} : (∀ (i : ι), i ∈ I → is_metric_separated (s i) t) → is_metric_separated (⋃ (i : ι) (H : i ∈ I), s i) t
theorem linear_map.eq_on_span' {R : Type u_1} {R₂ : Type u_2} {M : Type u_4} {M₂ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring R₂] [add_comm_monoid M₂] [module R₂ M₂] {σ₁₂ : R →+* R₂} {s : set M} {f g : M →ₛₗ[σ₁₂] M₂} (H : set.eq_on ⇑f ⇑g s) : set.eq_on ⇑f ⇑g ↑(submodule.span R s)
theorem vsub_left_cancel {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] {p1 p2 p : P} (h : p1 -ᵥ p = p2 -ᵥ p) : p1 = p2
theorem linear_recurrence.eq_mk_of_is_sol_of_eq_init' {α : Type u_1} [comm_semiring α] (E : linear_recurrence α) {u : ℕ → α} {init : fin E.order → α} (h : E.is_solution u) (heq : ∀ (n : fin E.order), u ↑n = init n) : u = E.mk_sol init
theorem euclidean_geometry.dist_eq_add_dist_of_angle_eq_pi {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : euclidean_geometry.angle p1 p2 p3 = real.pi) : has_dist.dist p1 p3 = has_dist.dist p1 p2 + has_dist.dist p3 p2
theorem mdifferentiable_within_at_iff_differentiable_within_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {f : E → E'} {s : set E} {x : E} : mdifferentiable_within_at (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f s x ↔ differentiable_within_at 𝕜 f s x
theorem measure_theory.simple_func.map_integral {α : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_group F] [normed_space ℝ F] {m : measurable_space α} {μ : measure_theory.measure α} (f : measure_theory.simple_func α E) (g : E → F) (hf : measure_theory.integrable ⇑f μ) (hg : g 0 = 0) : measure_theory.simple_func.integral μ (measure_theory.simple_func.map g f) = f.range.sum (λ (x : E), (⇑μ (⇑f ⁻¹' {x})).to_real • g x)
theorem mul_opposite.op_pow {M : Type u} [monoid M] (x : M) (n : ℕ) : mul_opposite.op (x ^ n) = mul_opposite.op x ^ n
theorem exists_ne_zero_of_finsum_mem_ne_zero {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} {s : set α} (h : finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) ≠ 0) : ∃ (x : α) (H : x ∈ s), f x ≠ 0
theorem measure_theory.simple_func.exists_le_lower_semicontinuous_lintegral_ge {α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] (μ : measure_theory.measure α) [μ.weakly_regular] (f : measure_theory.simple_func α nnreal) {ε : ennreal} (ε0 : ε ≠ 0) : ∃ (g : α → nnreal), (∀ (x : α), ⇑f x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f x) ∂μ + ε
theorem ordinal.opow_le_iff_le_log {b x c : ordinal} (b1 : 1 < b) (x0 : 0 < x) : b ^ c ≤ x ↔ c ≤ ordinal.log b x
theorem nilpotent_iff_finite_descending_central_series (G : Type u_1) [group G] : group.is_nilpotent G ↔ ∃ (n : ℕ) (H : ℕ → subgroup G), is_descending_central_series H ∧ H n = ⊥
theorem measure_theory.strongly_measurable.integral_prod_left' {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} [normed_group E] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] ⦃f : α × β → E⦄ (hf : measure_theory.strongly_measurable f) : measure_theory.strongly_measurable (λ (y : β), ∫ (x : α), f (x, y) ∂μ)
theorem finset.prod_insert_one {β : Type u} {α : Type v} {s : finset α} {a : α} {f : α → β} [comm_monoid β] [decidable_eq α] (h : f a = 1) : (has_insert.insert a s).prod (λ (x : α), f x) = s.prod (λ (x : α), f x)
theorem fin_injective  : function.injective fin
theorem measure_theory.ae_measurable_of_exist_almost_disjoint_supersets {α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) {β : Type u_2} [complete_linear_order β] [densely_ordered β] [topological_space β] [order_topology β] [topological_space.second_countable_topology β] [measurable_space β] [borel_space β] (s : set β) (s_count : s.countable) (s_dense : dense s) (f : α → β) (h : ∀ (p : β), p ∈ s → ∀ (q : β), q ∈ s → p < q → (∃ (u v : set α), measurable_set u ∧ measurable_set v ∧ {x : α | f x < p} ⊆ u ∧ {x : α | q < f x} ⊆ v ∧ ⇑μ (u ∩ v) = 0)) : ae_measurable f μ
theorem star_mul' {R : Type u} [comm_semigroup R] [star_semigroup R] (x y : R) : has_star.star (x * y) = has_star.star x * has_star.star y
theorem tendsto_inf_principal_nhds_iff_of_forall_eq {α : Type u} {β : Type v} [topological_space α] {f : β → α} {l : filter β} {s : set β} {a : α} (h : ∀ (x : β), x ∉ s → f x = a) : filter.tendsto f (l ⊓ filter.principal s) (nhds a) ↔ filter.tendsto f l (nhds a)
theorem submodule.torsion_by_set_eq_torsion_by_span {R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] (s : set R) : submodule.torsion_by_set R M s = submodule.torsion_by_set R M ↑(ideal.span s)
theorem normed_group_hom.norm_id {V : Type u_1} [normed_group V] [nontrivial V] : ∥normed_group_hom.id V∥ = 1
theorem is_alg_closed.cardinal_eq_cardinal_transcendence_basis_of_aleph_0_lt {R K : Type u} [comm_ring R] [field K] [algebra R K] [is_alg_closed K] {ι : Type u} (v : ι → K) [nontrivial R] (hv : is_transcendence_basis R v) (hR : cardinal.mk R ≤ cardinal.aleph_0) (hK : cardinal.aleph_0 < cardinal.mk K) : cardinal.mk K = cardinal.mk ι
theorem con.mk'_ker {M : Type u_1} [mul_one_class M] (c : con M) : con.ker c.mk' = c
theorem smul_add_smul_lt_smul_add_smul {k : Type u_1} {M : Type u_2} [ordered_ring k] [ordered_add_comm_group M] [module k M] [ordered_smul k M] [covariant_class M M has_add.add has_lt.lt] [contravariant_class M M has_add.add has_lt.lt] {a b : k} {c d : M} (hab : a < b) (hcd : c < d) : a • d + b • c < a • c + b • d
theorem supr_nhds_le_uniformity {α : Type u_1} [uniform_space α] : (⨆ (x : α), nhds (x, x)) ≤ uniformity α
theorem measure_theory.outer_measure.mk_metric'_is_metric {X : Type u_2} [emetric_space X] (m : set X → ennreal) : (measure_theory.outer_measure.mk_metric' m).is_metric
theorem submonoid.localization_map.mul_inv {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {f : M →* N} (h : ∀ (y : ↥S), is_unit (⇑f ↑y)) {x₁ x₂ : M} {y₁ y₂ : ↥S} : ⇑f x₁ * ↑(⇑(is_unit.lift_right (f.restrict S) h) y₁)⁻¹ = ⇑f x₂ * ↑(⇑(is_unit.lift_right (f.restrict S) h) y₂)⁻¹ ↔ ⇑f (x₁ * ↑y₂) = ⇑f (x₂ * ↑y₁)
theorem cont_diff.neg {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : with_top ℕ} {f : E → F} (hf : cont_diff 𝕜 n f) : cont_diff 𝕜 n (λ (x : E), -f x)
theorem minpoly.gcd_domain_dvd {A : Type u_1} {R : Type u_2} (K : Type u_3) [comm_ring A] [is_domain A] [normalized_gcd_monoid A] [field K] [comm_ring R] [is_domain R] [algebra A K] [is_fraction_ring A K] [algebra K R] [algebra A R] [is_scalar_tower A K R] {x : R} (hx : is_integral A x) {P : polynomial A} (hprim : P.is_primitive) (hroot : ⇑(polynomial.aeval x) P = 0) : minpoly A x ∣ P
theorem euclidean_geometry.eq_of_dist_eq_of_dist_eq_of_mem_of_finrank_eq_two {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} [finite_dimensional ℝ ↥(s.direction)] (hd : finite_dimensional.finrank ℝ ↥(s.direction) = 2) {c₁ c₂ p₁ p₂ p : P} (hc₁s : c₁ ∈ s) (hc₂s : c₂ ∈ s) (hp₁s : p₁ ∈ s) (hp₂s : p₂ ∈ s) (hps : p ∈ s) {r₁ r₂ : ℝ} (hc : c₁ ≠ c₂) (hp : p₁ ≠ p₂) (hp₁c₁ : has_dist.dist p₁ c₁ = r₁) (hp₂c₁ : has_dist.dist p₂ c₁ = r₁) (hpc₁ : has_dist.dist p c₁ = r₁) (hp₁c₂ : has_dist.dist p₁ c₂ = r₂) (hp₂c₂ : has_dist.dist p₂ c₂ = r₂) (hpc₂ : has_dist.dist p c₂ = r₂) : p = p₁ ∨ p = p₂
theorem affine.simplex.monge_plane_def {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P (n + 2)) (i₁ i₂ : fin (n + 3)) : s.monge_plane i₁ i₂ = affine_subspace.mk' (finset.centroid ℝ {i₁, i₂}ᶜ s.points) (submodule.span ℝ {s.points i₁ -ᵥ s.points i₂})ᗮ ⊓ affine_span ℝ (set.range s.points)
theorem alternating_map.comp_linear_map_id {R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] {ι : Type u_6} [decidable_eq ι] (f : alternating_map R M N ι) : f.comp_linear_map linear_map.id = f
theorem cont_diff.comp_cont_diff_on {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {n : with_top ℕ} {s : set E} {g : F → G} {f : E → F} (hg : cont_diff 𝕜 n g) (hf : cont_diff_on 𝕜 n f s) : cont_diff_on 𝕜 n (g ∘ f) s
theorem composition.sigma_pi_composition_eq_iff {n : ℕ} (u v : Σ (c : composition n), Π (i : fin c.length), composition (c.blocks_fun i)) : u = v ↔ list.of_fn (λ (i : fin u.fst.length), (u.snd i).blocks) = list.of_fn (λ (i : fin v.fst.length), (v.snd i).blocks)
theorem list.nat.mem_antidiagonal {n : ℕ} {x : ℕ × ℕ} : x ∈ list.nat.antidiagonal n ↔ x.fst + x.snd = n
theorem interval_integrable_inv_iff {a b : ℝ} : interval_integrable (λ (x : ℝ), x⁻¹) measure_theory.measure_space.volume a b ↔ a = b ∨ 0 ∉ set.interval a b
theorem dense_range.dense_image {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (hf' : dense_range f) (hf : continuous f) {s : set α} (hs : dense s) : dense (f '' s)
theorem ext_chart_model_space_eq_id (𝕜 : Type u_1) [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] (x : E) : ext_chart_at (model_with_corners_self 𝕜 E) x = local_equiv.refl E
theorem not_interval_integrable_of_tendsto_norm_at_top_of_deriv_is_O_filter {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [topological_space.second_countable_topology E] [complete_space E] [normed_group F] {f : ℝ → E} {g : ℝ → F} {a b : ℝ} (l : filter ℝ) [l.ne_bot] [filter.tendsto_Ixx_class set.Icc l l] (hl : set.interval a b ∈ l) (hd : ∀ᶠ (x : ℝ) in l, differentiable_at ℝ f x) (hf : filter.tendsto (λ (x : ℝ), ∥f x∥) l filter.at_top) (hfg : deriv f =O[l] g) : ¬interval_integrable g measure_theory.measure_space.volume a b
theorem local_homeomorph.cont_diff_at_symm {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : with_top ℕ} [complete_space E] (f : local_homeomorph E F) {f₀' : E ≃L[𝕜] F} {a : F} (ha : a ∈ f.to_local_equiv.target) (hf₀' : has_fderiv_at ⇑f ↑f₀' (⇑(f.symm) a)) (hf : cont_diff_at 𝕜 n ⇑f (⇑(f.symm) a)) : cont_diff_at 𝕜 n ⇑(f.symm) a
theorem pairwise.set_of_subtype {α : Type u_1} (s : set α) (r : α → α → Prop) : pairwise (λ (x y : ↥s), r ↑x ↑y) → s.pairwise r
theorem matrix.fin.circulant_ite (α : Type u_1) [has_zero α] [has_one α] (n : ℕ) : matrix.circulant (λ (i : fin n), ite (↑i = 0) 1 0) = 1
theorem matrix.nondegenerate.exists_not_ortho_of_ne_zero {m : Type u_1} {R : Type u_2} [fintype m] [comm_ring R] {M : matrix m m R} (hM : M.nondegenerate) {v : m → R} (hv : v ≠ 0) : ∃ (w : m → R), matrix.dot_product v (M.mul_vec w) ≠ 0
theorem normed_ring.tsum_geometric_of_norm_lt_1 {R : Type u_4} [normed_ring R] [complete_space R] (x : R) (h : ∥x∥ < 1) : ∥∑' (n : ℕ), x ^ n∥ ≤ ∥1∥ - 1 + (1 - ∥x∥)⁻¹
theorem ring_hom.comp_assoc {α : Type u_2} {β : Type u_3} {γ : Type u_4} [rα : non_assoc_semiring α] [rβ : non_assoc_semiring β] {rγ : non_assoc_semiring γ} {δ : Type u_1} {rδ : non_assoc_semiring δ} (f : α →+* β) (g : β →+* γ) (h : γ →+* δ) : (h.comp g).comp f = h.comp (g.comp f)
theorem inducing.is_compact_iff {α : Type u} {β : Type v} [topological_space α] [topological_space β] {f : α → β} (hf : inducing f) {s : set α} : is_compact (f '' s) ↔ is_compact s
theorem affine_span_mono (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s₁ s₂ : set P} (h : s₁ ⊆ s₂) : affine_span k s₁ ≤ affine_span k s₂
theorem is_artinian.bijective_of_injective_endomorphism {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [is_artinian R M] (f : M →ₗ[R] M) (s : function.injective ⇑f) : function.bijective ⇑f
theorem dfinsupp.sum_add_hom_apply {ι : Type u} {γ : Type w} {β : ι → Type v} [dec : decidable_eq ι] [Π (i : ι), add_zero_class (β i)] [Π (i : ι) (x : β i), decidable (x ≠ 0)] [add_comm_monoid γ] (φ : Π (i : ι), β i →+ γ) (f : Π₀ (i : ι), β i) : ⇑(dfinsupp.sum_add_hom φ) f = f.sum (λ (x : ι), ⇑(φ x))
theorem sq {M : Type u} [monoid M] (a : M) : a ^ 2 = a * a
theorem inv_nat_cast_smul_comm {α : Type u_1} {E : Type u_2} (R : Type u_3) [add_comm_group E] [division_ring R] [monoid α] [module R E] [distrib_mul_action α E] (n : ℕ) (s : α) (x : E) : (↑n)⁻¹ • s • x = s • (↑n)⁻¹ • x
theorem linear_independent.of_subtype_range {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] {ι : Type u_1} {f : ι → M} (hf : function.injective f) : linear_independent R coe → linear_independent R f
theorem affine_independent_iff_not_finrank_vector_span_le (k : Type u_1) {V : Type u_2} {P : Type u_3} {ι : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype ι] (p : ι → P) {n : ℕ} (hc : fintype.card ι = n + 2) : affine_independent k p ↔ ¬finite_dimensional.finrank k ↥(vector_span k (set.range p)) ≤ n
theorem continuous_on_extend_from {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [regular_space Y] {f : X → Y} {A B : set X} (hB : B ⊆ closure A) (hf : ∀ (x : X), x ∈ B → (∃ (y : Y), filter.tendsto f (nhds_within x A) (nhds y))) : continuous_on (extend_from A f) B
theorem submodule.span_induction' {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] {s : set M} {p : Π (x : M), x ∈ submodule.span R s → Prop} (Hs : ∀ (x : M) (h : x ∈ s), p x _) (H0 : p 0 _) (H1 : ∀ (x : M) (hx : x ∈ submodule.span R s) (y : M) (hy : y ∈ submodule.span R s), p x hx → p y hy → p (x + y) _) (H2 : ∀ (a : R) (x : M) (hx : x ∈ submodule.span R s), p x hx → p (a • x) _) {x : M} (hx : x ∈ submodule.span R s) : p x hx
theorem affine.simplex.inner_monge_point_vsub_face_centroid_vsub {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P (n + 2)) {i₁ i₂ : fin (n + 3)} : has_inner.inner (s.monge_point -ᵥ finset.centroid ℝ {i₁, i₂}ᶜ s.points) (s.points i₁ -ᵥ s.points i₂) = 0
theorem absorbent_nhds_zero {𝕜 : Type u_1} {E : Type u_3} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] {A : set E} [topological_space E] [has_continuous_smul 𝕜 E] (hA : A ∈ nhds 0) : absorbent 𝕜 A
theorem measure_theory.signed_measure.eq_singular_part {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {s : measure_theory.signed_measure α} (t : measure_theory.signed_measure α) (f : α → ℝ) (htμ : measure_theory.vector_measure.mutually_singular t μ.to_ennreal_vector_measure) (hadd : s = t + μ.with_densityᵥ f) : t = s.singular_part μ
theorem is_bounded_bilinear_map.cont_diff {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {b : E × F → G} {n : with_top ℕ} (hb : is_bounded_bilinear_map 𝕜 b) : cont_diff 𝕜 n b
theorem add_con.ext' {M : Type u_1} [has_add M] {c d : add_con M} (H : setoid.r = setoid.r) : c = d
theorem category_theory.limits.has_colimits_of_size_shrink (C : Type u) [category_theory.category C] [category_theory.limits.has_colimits_of_size C] : category_theory.limits.has_colimits_of_size C
theorem exp_neg_inv_glue.f_aux_has_deriv_at (n : ℕ) (x : ℝ) : has_deriv_at (exp_neg_inv_glue.f_aux n) (exp_neg_inv_glue.f_aux (n + 1) x) x
theorem polynomial.cyclotomic_mul_prime_eq_pow_of_not_dvd (R : Type u_1) {p n : ℕ} [hp : fact (nat.prime p)] [ring R] [char_p R p] (hn : ¬p ∣ n) : polynomial.cyclotomic (n * p) R = polynomial.cyclotomic n R ^ (p - 1)
theorem interval_integral.deriv_integral_left {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (hb : continuous_at f a) : deriv (λ (u : ℝ), ∫ (x : ℝ) in u..b, f x) a = -f a
theorem box_integral.integrable.to_subbox {ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I J : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} [complete_space F] (h : box_integral.integrable I l f vol) (hJ : J ≤ I) : box_integral.integrable J l f vol
theorem cont_diff_at.sub {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {x : E} {n : with_top ℕ} {f g : E → F} (hf : cont_diff_at 𝕜 n f x) (hg : cont_diff_at 𝕜 n g x) : cont_diff_at 𝕜 n (λ (x : E), f x - g x) x
theorem integral_sin_pow_odd_mul_cos_pow {a b : ℝ} (m n : ℕ) : ∫ (x : ℝ) in a..b, real.sin x ^ (2 * m + 1) * real.cos x ^ n = ∫ (u : ℝ) in real.cos b..real.cos a, u ^ n * (1 - u ^ 2) ^ m
theorem hall_marriage_theorem.hall_hard_inductive_step_B {ι : Type u} {α : Type v} [fintype ι] {t : ι → finset α} [decidable_eq α] {n : ℕ} (hn : fintype.card ι = n + 1) (ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card) (ih : ∀ {ι' : Type u} [_inst_3 : fintype ι'] (t' : ι' → finset α), fintype.card ι' ≤ n → (∀ (s' : finset ι'), s'.card ≤ (s'.bUnion t').card) → (∃ (f : ι' → α), function.injective f ∧ ∀ (x : ι'), f x ∈ t' x)) (s : finset ι) (hs : s.nonempty) (hns : s ≠ finset.univ) (hus : s.card = (s.bUnion t).card) : ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x
theorem homotopy.comp_null_homotopic_map {ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D E : homological_complex V c} (f : C ⟶ D) (hom : Π (i j : ι), D.X i ⟶ E.X j) : f ≫ homotopy.null_homotopic_map hom = homotopy.null_homotopic_map (λ (i j : ι), f.f i ≫ hom i j)
theorem cont_mdiff_within_at_iff'' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M → M'} {s : set M} {x : M} {n : with_top ℕ} : cont_mdiff_within_at I I' n f s x ↔ continuous_within_at f s x ∧ cont_diff_within_at 𝕜 n (written_in_ext_chart_at I I' x f) (⇑((ext_chart_at I x).symm) ⁻¹' s ∩ set.range ⇑I) (⇑(ext_chart_at I x) x)
theorem nonpos_of_neg_nonneg {α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : 0 ≤ -a → a ≤ 0
theorem measure_theory.nonempty_inter_of_measure_lt_add' {α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) {s t u : set α} (hs : measurable_set s) (h's : s ⊆ u) (h't : t ⊆ u) (h : ⇑μ u < ⇑μ s + ⇑μ t) : (s ∩ t).nonempty
theorem continuous_linear_map.op_norm_comp_linear_isometry_equiv {𝕜₂ : Type u_2} {𝕜₃ : Type u_3} {F : Type u_6} {G : Type u_8} [normed_group F] [normed_group G] [nondiscrete_normed_field 𝕜₂] [nondiscrete_normed_field 𝕜₃] [normed_space 𝕜₂ F] [normed_space 𝕜₃ G] {σ₂₃ : 𝕜₂ →+* 𝕜₃} {𝕜₂' : Type u_10} [nondiscrete_normed_field 𝕜₂'] {F' : Type u_11} [normed_group F'] [normed_space 𝕜₂' F'] {σ₂' : 𝕜₂' →+* 𝕜₂} {σ₂'' : 𝕜₂ →+* 𝕜₂'} {σ₂₃' : 𝕜₂' →+* 𝕜₃} [ring_hom_inv_pair σ₂' σ₂''] [ring_hom_inv_pair σ₂'' σ₂'] [ring_hom_comp_triple σ₂' σ₂₃ σ₂₃'] [ring_hom_comp_triple σ₂'' σ₂₃' σ₂₃] [ring_hom_isometric σ₂₃] [ring_hom_isometric σ₂'] [ring_hom_isometric σ₂''] [ring_hom_isometric σ₂₃'] (f : F →SL[σ₂₃] G) (g : F' ≃ₛₗᵢ[σ₂'] F) : ∥f.comp g.to_linear_isometry.to_continuous_linear_map∥ = ∥f∥
theorem fin.coe_cast {n m : ℕ} (h : n = m) (i : fin n) : ↑(⇑(fin.cast h) i) = ↑i
theorem dfinsupp.lift_add_hom_apply_single {ι : Type u} {γ : Type w} {β : ι → Type v} [dec : decidable_eq ι] [Π (i : ι), add_zero_class (β i)] [add_comm_monoid γ] (f : Π (i : ι), β i →+ γ) (i : ι) (x : β i) : ⇑(⇑dfinsupp.lift_add_hom f) (dfinsupp.single i x) = ⇑(f i) x
theorem submodule.exists_sum_of_mem_ideal_smul_span {R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] (I : ideal R) {ι : Type u_1} (s : set ι) (f : ι → M) (x : M) (hx : x ∈ I • submodule.span R (f '' s)) : ∃ (a : ↥s →₀ R) (ha : ∀ (i : ↥s), ⇑a i ∈ I), a.sum (λ (i : ↥s) (c : R), c • f ↑i) = x
theorem strict_mono_on.continuous_at_right_of_surj_on {α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_on f s) (hs : s ∈ nhds_within a (set.Ici a)) (hfs : set.surj_on f s (set.Ioi (f a))) : continuous_within_at f (set.Ici a) a
theorem subring.zero_mem {R : Type u} [ring R] (s : subring R) : 0 ∈ s
theorem orthonormal.oangle_eq_two_zsmul_oangle_sub_of_norm_eq_real {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y z : V} (hxyne : x ≠ y) (hxzne : x ≠ z) {r : ℝ} (hx : ∥x∥ = r) (hy : ∥y∥ = r) (hz : ∥z∥ = r) : hb.oangle y z = 2 • hb.oangle (y - x) (z - x)
theorem affine_subspace.bot_coe (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : ↑⊥ = ∅
theorem dvd_of_mul_left_eq {α : Type u_1} [comm_semigroup α] {a b : α} (c : α) (h : c * a = b) : a ∣ b
theorem is_integral_tower_bot_of_is_integral {R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [comm_ring B] [algebra A B] [algebra R B] [algebra R A] [is_scalar_tower R A B] (H : function.injective ⇑(algebra_map A B)) {x : A} (h : is_integral R (⇑(algebra_map A B) x)) : is_integral R x
theorem semiconj_by.one_left {M : Type u} [mul_one_class M] (x : M) : semiconj_by 1 x x
theorem char_zero_of_injective_algebra_map {R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] (h : function.injective ⇑(algebra_map R A)) [char_zero R] : char_zero A
theorem category_theory.limits.wide_coequalizer.hom_ext {J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J → (X ⟶ Y)} [category_theory.limits.has_wide_coequalizer f] [nonempty J] {W : C} {k l : category_theory.limits.wide_coequalizer f ⟶ W} (h : category_theory.limits.wide_coequalizer.π f ≫ k = category_theory.limits.wide_coequalizer.π f ≫ l) : k = l
theorem inner_product_space.is_self_adjoint.orthogonal_supr_eigenspaces_eq_bot {𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] {T : E →ₗ[𝕜] E} (hT : inner_product_space.is_self_adjoint T) [finite_dimensional 𝕜 E] : (⨆ (μ : 𝕜), module.End.eigenspace T μ)ᗮ = ⊥
theorem rel_sup_add {α : Type u_1} {β : Type u_2} [add_comm_monoid α] [topological_space α] [t2_space α] [complete_lattice β] (m : β → α) (m0 : m ⊥ = 0) (R : α → α → Prop) (m_supr : ∀ (s : ℕ → β), R (m (⨆ (i : ℕ), s i)) (∑' (i : ℕ), m (s i))) (s₁ s₂ : β) : R (m (s₁ ⊔ s₂)) (m s₁ + m s₂)
theorem category_theory.limits.image_subobject_comp_le {C : Type u} [category_theory.category C] {X Y X' : C} (h : X' ⟶ X) (f : X ⟶ Y) [category_theory.limits.has_image f] [category_theory.limits.has_image (h ≫ f)] : category_theory.limits.image_subobject (h ≫ f) ≤ category_theory.limits.image_subobject f
theorem complex.schwarz_aux {R₁ R₂ : ℝ} {c z : ℂ} {f : ℂ → ℂ} (hd : differentiable_on ℂ f (metric.ball c R₁)) (h_maps : set.maps_to f (metric.ball c R₁) (metric.ball (f c) R₂)) (hz : z ∈ metric.ball c R₁) : ∥dslope f c z∥ ≤ R₂ / R₁
theorem zero_lt.right.mul_lt_one_of_le_of_lt {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1
theorem set.finite.convex_hull_eq_image {R : Type u_1} {E : Type u_2} [linear_ordered_field R] [add_comm_group E] [module R E] {s : set E} (hs : s.finite) : ⇑(convex_hull R) s = ⇑(finset.univ.sum (λ (x : ↥s), (linear_map.proj x).smul_right x.val)) '' std_simplex R ↥s
theorem polynomial.derivative_eval₂_C {R : Type u} [comm_semiring R] (p q : polynomial R) : ⇑polynomial.derivative (polynomial.eval₂ polynomial.C q p) = polynomial.eval₂ polynomial.C q (⇑polynomial.derivative p) * ⇑polynomial.derivative q
theorem valuation.subgroups_basis {R : Type u} [ring R] {Γ₀ : Type v} [linear_ordered_comm_group_with_zero Γ₀] (v : valuation R Γ₀) : ring_subgroups_basis (λ (γ : Γ₀ˣ), v.lt_add_subgroup γ)
theorem inseparable.nhds_eq {X : Type u_1} [topological_space X] {x y : X} : inseparable x y → nhds x = nhds y
theorem matrix.to_lin_mul_apply {R : Type u_1} [comm_semiring R] {l : Type u_2} {m : Type u_3} {n : Type u_4} [fintype n] [fintype m] [decidable_eq n] {M₁ : Type u_5} {M₂ : Type u_6} [add_comm_monoid M₁] [add_comm_monoid M₂] [module R M₁] [module R M₂] (v₁ : basis n R M₁) (v₂ : basis m R M₂) {M₃ : Type u_7} [add_comm_monoid M₃] [module R M₃] (v₃ : basis l R M₃) [fintype l] [decidable_eq m] (A : matrix l m R) (B : matrix m n R) (x : M₁) : ⇑(⇑(matrix.to_lin v₁ v₃) (A.mul B)) x = ⇑(⇑(matrix.to_lin v₂ v₃) A) (⇑(⇑(matrix.to_lin v₁ v₂) B) x)
theorem finset.sum_smul_vsub_eq_weighted_vsub_sub {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (w : ι → k) (p₁ p₂ : ι → P) : s.sum (λ (i : ι), w i • (p₁ i -ᵥ p₂ i)) = ⇑(s.weighted_vsub p₁) w - ⇑(s.weighted_vsub p₂) w
theorem is_cyclotomic_extension.singleton_one (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] [h : is_cyclotomic_extension {1} A B] : ⊥ = ⊤
theorem finprod_mem_induction {α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M} {s : set α} (p : M → Prop) (hp₀ : p 1) (hp₁ : ∀ (x y : M), p x → p y → p (x * y)) (hp₂ : ∀ (x : α), x ∈ s → p (f x)) : p (finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)))
theorem interval_integral.deriv_within_integral_left {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set ℝ} [interval_integral.FTC_filter a (nhds_within a s) (nhds_within a t)] (hmeas : strongly_measurable_at_filter f (nhds_within a t) measure_theory.measure_space.volume) (ha : continuous_within_at f t a) (hs : unique_diff_within_at ℝ s a . "unique_diff_within_at_Ici_Iic_univ") : deriv_within (λ (u : ℝ), ∫ (x : ℝ) in u..b, f x) s a = -f a
theorem lower_semicontinuous_within_at.add' {α : Type u_1} [topological_space α] {x : α} {s : set α} {γ : Type u_4} [linear_ordered_add_comm_monoid γ] [topological_space γ] [order_topology γ] {f g : α → γ} (hf : lower_semicontinuous_within_at f s x) (hg : lower_semicontinuous_within_at g s x) (hcont : continuous_at (λ (p : γ × γ), p.fst + p.snd) (f x, g x)) : lower_semicontinuous_within_at (λ (z : α), f z + g z) s x
theorem phragmen_lindelof.eq_zero_on_vertical_strip {E : Type u_1} [normed_group E] [normed_space ℂ E] {a b : ℝ} {f : ℂ → E} (hd : diff_cont_on_cl ℂ f (complex.re ⁻¹' set.Ioo a b)) (hB : ∃ (c : ℝ) (H : c < real.pi / (b - a)) (B : ℝ), f =O[filter.comap (has_abs.abs ∘ complex.im) filter.at_top ⊓ filter.principal (complex.re ⁻¹' set.Ioo a b)] λ (z : ℂ), real.exp (B * real.exp (c * |z.im|))) (ha : ∀ (z : ℂ), z.re = a → f z = 0) (hb : ∀ (z : ℂ), z.re = b → f z = 0) : set.eq_on f 0 (complex.re ⁻¹' set.Icc a b)
theorem cardinal.bdd_above_iff_small (s : set cardinal) : bdd_above s ↔ small ↥s
theorem module.ext' {R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] (P Q : module R M) (w : ∀ (r : R) (m : M), r • m = r • m) : P = Q
theorem has_le.le.eq_or_lt_dec {α : Type u} [partial_order α] [decidable_rel has_le.le] {a b : α} (hab : a ≤ b) : a = b ∨ a < b
theorem add_submonoid.mem_closure_singleton {A : Type u_2} [add_monoid A] {x y : A} : y ∈ add_submonoid.closure {x} ↔ ∃ (n : ℕ), n • x = y
theorem zero_lt.left.mul_pos {α : Type u} {a b : α} [mul_zero_class α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 0 < a) (hb : 0 < b) : 0 < a * b
theorem orthonormal.linear_independent {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : orthonormal 𝕜 v) : linear_independent 𝕜 v
theorem continuous_at.comp_div_cases {α : Type u_1} {β : Type u_2} {G₀ : Type u_3} [group_with_zero G₀] [topological_space G₀] [has_continuous_inv₀ G₀] [has_continuous_mul G₀] [topological_space α] [topological_space β] {a : α} {f g : α → G₀} (h : α → G₀ → β) (hf : continuous_at f a) (hg : continuous_at g a) (hh : g a ≠ 0 → continuous_at ↿h (a, f a / g a)) (h2h : g a = 0 → filter.tendsto ↿h ((nhds a).prod ⊤) (nhds (h a 0))) : continuous_at (λ (x : α), h x (f x / g x)) a
theorem complete_lattice.independent.map_order_iso {ι : Sort u_1} {α : Type u_2} {β : Type u_3} [complete_lattice α] [complete_lattice β] (f : α ≃o β) {a : ι → α} (ha : complete_lattice.independent a) : complete_lattice.independent (⇑f ∘ a)
theorem category_theory.endofunctor.algebra.initial.str_is_iso {C : Type u} [category_theory.category C] {F : C ⥤ C} {A : category_theory.endofunctor.algebra F} (h : category_theory.limits.is_initial A) : category_theory.is_iso A.str
theorem algebra.trace_algebra_map_of_basis {R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] [algebra R S] {ι : Type w} [fintype ι] (b : basis ι R S) (x : R) : ⇑(algebra.trace R S) (⇑(algebra_map R S) x) = fintype.card ι • x
theorem monoid_algebra.mv_polynomial_aeval_of_surjective_of_closure {R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_semiring R] {S : set M} (hS : submonoid.closure S = ⊤) : function.surjective ⇑(mv_polynomial.aeval (λ (s : ↥S), ⇑(monoid_algebra.of R M) ↑s))
theorem is_cyclotomic_extension.discr_odd_prime {p : ℕ+} {K : Type u} {L : Type v} {ζ : L} [field K] [field L] [algebra K L] [is_cyclotomic_extension {p} K L] [hp : fact (nat.prime ↑p)] [ne_zero ↑↑p] (hζ : is_primitive_root ζ ↑p) (hirr : irreducible (polynomial.cyclotomic ↑p K)) (hodd : p ≠ 2) : algebra.discr K ⇑((is_primitive_root.power_basis K hζ).basis) = (-1) ^ ((↑p - 1) / 2) * ↑p ^ (↑p - 2)
theorem linear_map.adjoint_inner_left {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [inner_product_space 𝕜 F] [finite_dimensional 𝕜 E] [finite_dimensional 𝕜 F] (A : E →ₗ[𝕜] F) (x : E) (y : F) : has_inner.inner (⇑(⇑linear_map.adjoint A) y) x = has_inner.inner y (⇑A x)
theorem cont_diff_on.dense_compl_image_of_dimH_lt_finrank {E : Type u_4} {F : Type u_5} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] [normed_group F] [normed_space ℝ F] [finite_dimensional ℝ F] {f : E → F} {s t : set E} (h : cont_diff_on ℝ 1 f s) (hc : convex ℝ s) (ht : t ⊆ s) (htF : dimH t < ↑(finite_dimensional.finrank ℝ F)) : dense (f '' t)ᶜ
theorem nilpotency_class_prod {G₁ : Type u_2} {G₂ : Type u_3} [group G₁] [group G₂] [group.is_nilpotent G₁] [group.is_nilpotent G₂] : group.nilpotency_class (G₁ × G₂) = linear_order.max (group.nilpotency_class G₁) (group.nilpotency_class G₂)
theorem antivary_on.sum_smul_lt_sum_smul_comp_perm_iff {ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {s : finset ι} {σ : equiv.perm ι} {f : ι → α} {g : ι → β} (hfg : antivary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i • g i) < s.sum (λ (i : ι), f i • g (⇑σ i)) ↔ ¬antivary_on f (g ∘ ⇑σ) ↑s
theorem ennreal.Lp_add_le {ι : Type u} (s : finset ι) (f g : ι → ennreal) {p : ℝ} (hp : 1 ≤ p) : s.sum (λ (i : ι), (f i + g i) ^ p) ^ (1 / p) ≤ s.sum (λ (i : ι), f i ^ p) ^ (1 / p) + s.sum (λ (i : ι), g i ^ p) ^ (1 / p)
theorem dist_nndist {α : Type u} [pseudo_metric_space α] (x y : α) : has_dist.dist x y = ↑(has_nndist.nndist x y)
theorem countable_of_isolated_right {α : Type u} [topological_space α] [linear_order α] [order_topology α] [topological_space.second_countable_topology α] : {x : α | ∃ (y : α), x < y ∧ set.Ioo x y = ∅}.countable
theorem linear_independent.fin_cons' {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] {m : ℕ} (x : M) (v : fin m → M) (hli : linear_independent R v) (x_ortho : ∀ (c : R) (y : ↥(submodule.span R (set.range v))), c • x + ↑y = 0 → c = 0) : linear_independent R (fin.cons x v)
theorem add_submonoid.subset_closure {M : Type u_1} [add_zero_class M] {s : set M} : s ⊆ ↑(add_submonoid.closure s)
theorem list.prod_range_succ' {α : Type u} [monoid α] (f : ℕ → α) (n : ℕ) : (list.map f (list.range n.succ)).prod = f 0 * (list.map (λ (i : ℕ), f i.succ) (list.range n)).prod
theorem continuous_linear_map.lmul_left_right_is_bounded_bilinear (𝕜 : Type u_1) [nondiscrete_normed_field 𝕜] (𝕜' : Type u_2) [normed_ring 𝕜'] [normed_algebra 𝕜 𝕜'] : is_bounded_bilinear_map 𝕜 (λ (p : 𝕜' × 𝕜'), ⇑(⇑(continuous_linear_map.lmul_left_right 𝕜 𝕜') p.fst) p.snd)
theorem convex.combo_interior_closure_subset_interior {E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) {a b : 𝕜} (ha : 0 < a) (hb : 0 ≤ b) (hab : a + b = 1) : a • interior s + b • closure s ⊆ interior s
theorem complex.Gamma_integral_add_one {s : ℂ} (hs : 0 < s.re) : (s + 1).Gamma_integral = s * s.Gamma_integral
theorem ideal.mem_map_C_iff {R : Type u} [comm_semiring R] {I : ideal R} {f : polynomial R} : f ∈ ideal.map polynomial.C I ↔ ∀ (n : ℕ), f.coeff n ∈ I
theorem category_theory.idempotents.is_idempotent_complete_iff_of_equivalence {C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] (ε : C ≌ D) : category_theory.is_idempotent_complete C ↔ category_theory.is_idempotent_complete D
theorem two_pos {α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 2
theorem list.nodup.attach {α : Type u} {l : list α} : l.nodup → l.attach.nodup
theorem category_theory.limits.types.unique_of_type_equalizer {X Y Z : Type u} (f : X ⟶ Y) {g h : Y ⟶ Z} (w : f ≫ g = f ≫ h) (t : category_theory.limits.is_limit (category_theory.limits.fork.of_ι f w)) (y : Y) (hy : g y = h y) : ∃! (x : X), f x = y
theorem iterated_fderiv_succ_eq_comp_left {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {n : ℕ} : iterated_fderiv 𝕜 (n + 1) f = ⇑(continuous_multilinear_curry_left_equiv 𝕜 (λ (i : fin (n + 1)), E) F) ∘ fderiv 𝕜 (iterated_fderiv 𝕜 n f)
theorem is_Gδ_Inter {α : Type u_1} {ι : Type u_4} [topological_space α] [encodable ι] {s : ι → set α} (hs : ∀ (i : ι), is_Gδ (s i)) : is_Gδ (⋂ (i : ι), s i)
theorem matrix.det_mv_polynomial_X_ne_zero (m : Type u_1) (R : Type u_3) [decidable_eq m] [fintype m] [comm_ring R] [nontrivial R] : (matrix.mv_polynomial_X m m R).det ≠ 0
theorem exists_embedding_euclidean_of_compact {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] [t2_space M] [compact_space M] : ∃ (n : ℕ) (e : M → euclidean_space ℝ (fin n)), smooth I (model_with_corners_self ℝ (euclidean_space ℝ (fin n))) e ∧ closed_embedding e ∧ ∀ (x : M), function.injective ⇑(mfderiv I (model_with_corners_self ℝ (euclidean_space ℝ (fin n))) e x)
theorem sym2.card_image_off_diag {α : Type u_1} [decidable_eq α] (s : finset α) : (finset.image quotient.mk s.off_diag).card = s.card.choose 2
theorem category_theory.limits.has_colimit_of_coequalizer_and_coproduct {C : Type u} [category_theory.category C] {J : Type v} [category_theory.small_category J] (F : J ⥤ C) [category_theory.limits.has_colimit (category_theory.discrete.functor F.obj)] [category_theory.limits.has_colimit (category_theory.discrete.functor (λ (f : Σ (p : J × J), p.fst ⟶ p.snd), F.obj f.fst.fst))] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_colimit F
theorem has_fpower_series_at.eq_zero {𝕜 : Type u_1} {E : Type u_2} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] {p : formal_multilinear_series 𝕜 𝕜 E} {x : 𝕜} (h : has_fpower_series_at 0 p x) : p = 0
theorem is_submonoid.inter {M : Type u_1} [monoid M] {s₁ s₂ : set M} (is₁ : is_submonoid s₁) (is₂ : is_submonoid s₂) : is_submonoid (s₁ ∩ s₂)
theorem minpoly.aeval (A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) : ⇑(polynomial.aeval x) (minpoly A x) = 0
theorem finprod_mem_mul_diff {α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M} {s t : set α} (hst : s ⊆ t) (ht : t.finite) : finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ t  s), f i)) = finprod (λ (i : α), finprod (λ (H : i ∈ t), f i))
theorem eq_zero_of_mul_eq_self_left {M₀ : Type u_1} [cancel_monoid_with_zero M₀] {a b : M₀} (h₁ : b ≠ 1) (h₂ : b * a = a) : a = 0
theorem right.inv_le_one_iff {α : Type u} [group α] [has_le α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a
theorem finite_dimensional.finrank_zero_iff {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : finite_dimensional.finrank K V = 0 ↔ subsingleton V
theorem monoid_algebra.fg_of_finite_type {R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R] [h : algebra.finite_type R (monoid_algebra R M)] : monoid.fg M
theorem con.induction_on₂ {M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] {c : con M} {d : con N} {C : c.quotient → d.quotient → Prop} (p : c.quotient) (q : d.quotient) (H : ∀ (x : M) (y : N), C ↑x ↑y) : C p q
theorem metric.closed_ball_subset_cthickening {α : Type u_1} [pseudo_metric_space α] {x : α} {E : set α} (hx : x ∈ E) (δ : ℝ) : metric.closed_ball x δ ⊆ metric.cthickening δ E
theorem category_theory.paths.ext_functor {V : Type u₁} [quiver V] {C : Type u_1} [category_theory.category C] {F G : category_theory.paths V ⥤ C} (h_obj : F.obj = G.obj) (h : ∀ (a b : V) (e : a ⟶ b), F.map e.to_path = category_theory.eq_to_hom _ ≫ G.map e.to_path ≫ category_theory.eq_to_hom _) : F = G
theorem convex.is_o_alternate_sum_square {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {s : set E} (s_conv : convex ℝ s) {f : E → F} {f' : E → (E →L[ℝ] F)} {f'' : E →L[ℝ] E →L[ℝ] F} (hf : ∀ (x : E), x ∈ interior s → has_fderiv_at f (f' x) x) {x : E} (xs : x ∈ s) (hx : has_fderiv_within_at f' f'' (interior s) x) {v w : E} (h4v : x + 4 • v ∈ interior s) (h4w : x + 4 • w ∈ interior s) : (λ (h : ℝ), f (x + h • (2 • v + 2 • w)) + f (x + h • (v + w)) - f (x + h • (2 • v + w)) - f (x + h • (v + 2 • w)) - h ^ 2 • ⇑(⇑f'' v) w) =o[nhds_within 0 (set.Ioi 0)] λ (h : ℝ), h ^ 2
theorem is_cyclotomic_extension.rat.discr_prime_pow' {p : ℕ+} {k : ℕ} {K : Type u} [field K] [char_zero K] {ζ : K} [hp : fact (nat.prime ↑p)] [is_cyclotomic_extension {p ^ k} ℚ K] (hζ : is_primitive_root ζ ↑(p ^ k)) : algebra.discr ℚ ⇑((is_primitive_root.sub_one_power_basis ℚ hζ).basis) = (-1) ^ ((↑p ^ k).totient / 2) * ↑p ^ (↑p ^ (k - 1) * ((↑p - 1) * k - 1))
theorem continuous_linear_map.nnnorm_smul_right_apply {𝕜 : Type u_1} {E : Type u_4} {Fₗ : Type u_7} [normed_group E] [normed_group Fₗ] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 Fₗ] (c : E →L[𝕜] 𝕜) (f : Fₗ) : ∥c.smul_right f∥₊ = ∥c∥₊ * ∥f∥₊
theorem smul_mul_assoc {α : Type u_6} {β : Type u_7} [has_mul β] [has_scalar α β] [is_scalar_tower α β β] (r : α) (x y : β) : r • x * y = r • (x * y)
theorem category_theory.is_pullback.of_is_limit {C : Type u₁} [category_theory.category C] {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} {c : category_theory.limits.pullback_cone f g} (h : category_theory.limits.is_limit c) : category_theory.is_pullback c.fst c.snd f g
theorem finsum_mem_comm {α : Type u_1} {β : Type u_2} {M : Type u_5} [add_comm_monoid M] {s : set α} {t : set β} (f : α → β → M) (hs : s.finite) (ht : t.finite) : finsum (λ (i : α), finsum (λ (H : i ∈ s), finsum (λ (j : β), finsum (λ (H : j ∈ t), f i j)))) = finsum (λ (j : β), finsum (λ (H : j ∈ t), finsum (λ (i : α), finsum (λ (H : i ∈ s), f i j))))
theorem pi.mul_single_commute {I : Type u} {f : I → Type v} [decidable_eq I] [Π (i : I), mul_one_class (f i)] : pairwise (λ (i j : I), ∀ (x : f i) (y : f j), commute (pi.mul_single i x) (pi.mul_single j y))
theorem banach_steinhaus {E : Type u_1} {F : Type u_2} {𝕜 : Type u_3} {𝕜₂ : Type u_4} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [ring_hom_isometric σ₁₂] {ι : Type u_5} [complete_space E] {g : ι → (E →SL[σ₁₂] F)} (h : ∀ (x : E), ∃ (C : ℝ), ∀ (i : ι), ∥⇑(g i) x∥ ≤ C) : ∃ (C' : ℝ), ∀ (i : ι), ∥g i∥ ≤ C'
theorem category_theory.free_bicategory.normalize_naturality {B : Type u} [quiver B] {a b c : B} (p : quiver.path a b) {f g : category_theory.free_bicategory.hom b c} (η : f ⟶ g) : category_theory.bicategory.whisker_left ((category_theory.free_bicategory.preinclusion B).map {as := p}) η ≫ (category_theory.free_bicategory.normalize_iso p g).hom = (category_theory.free_bicategory.normalize_iso p f).hom ≫ (category_theory.free_bicategory.preinclusion B).map₂ (category_theory.eq_to_hom _)
theorem algebraic_geometry.structure_sheaf.comap_id {R : Type u} [comm_ring R] (U V : topological_space.opens ↥(algebraic_geometry.prime_spectrum.Top R)) (hUV : U = V) : algebraic_geometry.structure_sheaf.comap (ring_hom.id R) U V _ = category_theory.eq_to_hom _
theorem right.add_pos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
theorem submodule.fg_iff_finite_dimensional {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (s : submodule K V) : s.fg ↔ finite_dimensional K ↥s
theorem finset.mem_shadow_iff {α : Type u_1} [decidable_eq α] {𝒜 : finset (finset α)} {s : finset α} : s ∈ 𝒜.shadow ↔ ∃ (t : finset α) (H : t ∈ 𝒜) (a : α) (H : a ∈ t), t.erase a = s
theorem metric.inf_dist_zero_of_mem {α : Type u} [pseudo_metric_space α] {s : set α} {x : α} (h : x ∈ s) : metric.inf_dist x s = 0
theorem category_theory.endofunctor.algebra.iso_of_iso {C : Type u} [category_theory.category C] {F : C ⥤ C} {A₀ A₁ : category_theory.endofunctor.algebra F} (f : A₀ ⟶ A₁) [category_theory.is_iso f.f] : category_theory.is_iso f
theorem subgroup.closure_induction₂ {G : Type u_1} [group G] {k : set G} {p : G → G → Prop} {x y : G} (hx : x ∈ subgroup.closure k) (hy : y ∈ subgroup.closure k) (Hk : ∀ (x : G), x ∈ k → ∀ (y : G), y ∈ k → p x y) (H1_left : ∀ (x : G), p 1 x) (H1_right : ∀ (x : G), p x 1) (Hmul_left : ∀ (x₁ x₂ y : G), p x₁ y → p x₂ y → p (x₁ * x₂) y) (Hmul_right : ∀ (x y₁ y₂ : G), p x y₁ → p x y₂ → p x (y₁ * y₂)) (Hinv_left : ∀ (x y : G), p x y → p x⁻¹ y) (Hinv_right : ∀ (x y : G), p x y → p x y⁻¹) : p x y
theorem Top.pullback_map_embedding_of_embeddings {W X Y Z S T : Top} (f₁ : W ⟶ S) (f₂ : X ⟶ S) (g₁ : Y ⟶ T) (g₂ : Z ⟶ T) {i₁ : W ⟶ Y} {i₂ : X ⟶ Z} (H₁ : embedding ⇑i₁) (H₂ : embedding ⇑i₂) (i₃ : S ⟶ T) (eq₁ : f₁ ≫ i₃ = i₁ ≫ g₁) (eq₂ : f₂ ≫ i₃ = i₂ ≫ g₂) : embedding ⇑(category_theory.limits.pullback.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂)
theorem algebraic_geometry.PresheafedSpace.glue_data.snd_inv_app_t_app' {C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) (i j k : D.to_glue_data.J) (U : topological_space.opens ↥((category_theory.limits.pullback (D.to_glue_data.f i j) (D.to_glue_data.f i k)).carrier)) : ∃ (eq_1 : (topological_space.opens.map (D.to_glue_data.t k i).base).op.obj (opposite.op (_.open_functor.obj U)) = opposite.op (_.open_functor.obj (opposite.unop ((topological_space.opens.map (D.to_glue_data.t' k i j).base).op.obj (opposite.op U))))), _.inv_app U ≫ (D.to_glue_data.t k i).c.app (opposite.op (_.open_functor.obj U)) ≫ (D.to_glue_data.V (k, i)).presheaf.map (category_theory.eq_to_hom eq_1) = (D.to_glue_data.t' k i j).c.app (opposite.op U) ≫ _.inv_app (opposite.unop ((topological_space.opens.map (D.to_glue_data.t' k i j).base).op.obj (opposite.op U)))
theorem continuous_extend_from {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [regular_space Y] {f : X → Y} {A : set X} (hA : dense A) (hf : ∀ (x : X), ∃ (y : Y), filter.tendsto f (nhds_within x A) (nhds y)) : continuous (extend_from A f)
theorem algebraic_geometry.PresheafedSpace.glue_data.snd_inv_app_t_app {C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) (i j k : D.to_glue_data.J) (U : topological_space.opens ↥((category_theory.limits.pullback (D.to_glue_data.f i j) (D.to_glue_data.f i k)).carrier)) : _.inv_app U ≫ (D.to_glue_data.t k i).c.app (opposite.op (_.open_functor.obj U)) = (D.to_glue_data.t' k i j).c.app (opposite.op U) ≫ _.inv_app (opposite.unop ((topological_space.opens.map (D.to_glue_data.t' k i j).base).op.obj (opposite.op U))) ≫ (D.to_glue_data.V (k, i)).presheaf.map (category_theory.eq_to_hom _)
theorem category_theory.presieve.is_sheaf_for_subsieve_aux {C : Type u₁} [category_theory.category C] {X : C} (P : Cᵒᵖ ⥤ Type w) {S : category_theory.sieve X} {R : category_theory.presieve X} (h : ⇑S ≤ R) (hS : category_theory.presieve.is_sheaf_for P ⇑S) (trans : ∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, R f → category_theory.presieve.is_separated_for P ⇑(category_theory.sieve.pullback f S)) : category_theory.presieve.is_sheaf_for P R
theorem is_add_regular.and_of_add_of_add {R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_regular (a + b)) (ba : is_add_regular (b + a)) : is_add_regular a ∧ is_add_regular b
theorem is_cyclotomic_extension.iff_adjoin_eq_top (S : set ℕ+) (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] : is_cyclotomic_extension S A B ↔ (∀ (a : ℕ+), a ∈ S → (∃ (r : B), ⇑(polynomial.aeval r) (polynomial.cyclotomic ↑a A) = 0)) ∧ algebra.adjoin A {b : B | ∃ (a : ℕ+), a ∈ S ∧ b ^ ↑a = 1} = ⊤
theorem holder_on_with.uniform_continuous_on {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C r : nnreal} {f : X → Y} {s : set X} (hf : holder_on_with C r f s) (h0 : 0 < r) : uniform_continuous_on f s
theorem lt_of_neg_lt_neg {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : -a < -b → b < a
theorem multiset.well_founded_lt {α : Type u_1} : well_founded has_lt.lt
theorem finprod_mem_image' {α : Type u_1} {β : Type u_2} {M : Type u_5} [comm_monoid M] {f : α → M} {s : set β} {g : β → α} (hg : set.inj_on g (s ∩ function.mul_support (f ∘ g))) : finprod (λ (i : α), finprod (λ (H : i ∈ g '' s), f i)) = finprod (λ (j : β), finprod (λ (H : j ∈ s), f (g j)))
theorem add_con.trans {M : Type u_1} [has_add M] (c : add_con M) {x y z : M} : ⇑c x y → ⇑c y z → ⇑c x z
theorem orthonormal.sum_inner_products_le {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} (x : E) {v : ι → E} {s : finset ι} (hv : orthonormal 𝕜 v) : s.sum (λ (i : ι), ∥has_inner.inner (v i) x∥ ^ 2) ≤ ∥x∥ ^ 2
theorem polynomial.C_eq_algebra_map {R : Type u} [comm_semiring R] (r : R) : ⇑polynomial.C r = ⇑(algebra_map R (polynomial R)) r
theorem order_ring_hom.subsingleton {α : Type u_2} {β : Type u_3} [linear_ordered_field α] [linear_ordered_field β] [archimedean β] : subsingleton (α →+*o β)
theorem nat.modeq.pow_totient {x n : ℕ} (h : x.coprime n) : x ^ n.totient ≡ 1 [MOD n]
theorem function.periodic.interval_integral_add_eq {E : Type u_1} [normed_group E] [normed_space ℝ E] [complete_space E] {f : ℝ → E} {T : ℝ} (hf : function.periodic f T) (t s : ℝ) : ∫ (x : ℝ) in t..t + T, f x = ∫ (x : ℝ) in s..s + T, f x
theorem not_bdd_below_iff' {α : Type u} [preorder α] {s : set α} : ¬bdd_below s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), ¬x ≤ y
theorem euclidean_geometry.dist_sq_mul_dist_add_dist_sq_mul_dist {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (a b c p : P) (h : euclidean_geometry.angle b p c = real.pi) : has_dist.dist a b ^ 2 * has_dist.dist c p + has_dist.dist a c ^ 2 * has_dist.dist b p = has_dist.dist b c * (has_dist.dist a p ^ 2 + has_dist.dist b p * has_dist.dist c p)
theorem filter.limsup_const_bot {α : Type u_1} {β : Type u_2} [complete_lattice α] {f : filter β} : f.limsup (λ (x : β), ⊥) = ⊥
theorem con.coe_mul {M : Type u_1} [has_mul M] {c : con M} (x y : M) : ↑(x * y) = ↑x * ↑y
theorem finset.prod_add {α : Type u} {β : Type v} [comm_semiring β] (f g : α → β) (s : finset α) : s.prod (λ (a : α), f a + g a) = s.powerset.sum (λ (t : finset α), t.prod (λ (a : α), f a) * (s  t).prod (λ (a : α), g a))
theorem bernoulli'_odd_eq_zero {n : ℕ} (h_odd : odd n) (hlt : 1 < n) : bernoulli' n = 0
theorem fin.succ_above_right_injective {n : ℕ} {x : fin (n + 1)} : function.injective ⇑(x.succ_above)
theorem first_order.language.Theory.is_satisfiable_iff_is_finitely_satisfiable {L : first_order.language} {T : L.Theory} : T.is_satisfiable ↔ T.is_finitely_satisfiable
theorem measure_theory.integral_divergence_of_has_fderiv_within_at_off_countable' {E : Type u} [normed_group E] [normed_space ℝ E] [complete_space E] {n : ℕ} (a b : fin (n + 1) → ℝ) (hle : a ≤ b) (f : fin (n + 1) → (fin (n + 1) → ℝ) → E) (f' : fin (n + 1) → (fin (n + 1) → ℝ) → ((fin (n + 1) → ℝ) →L[ℝ] E)) (s : set (fin (n + 1) → ℝ)) (hs : s.countable) (Hc : ∀ (i : fin (n + 1)), continuous_on (f i) (set.Icc a b)) (Hd : ∀ (x : fin (n + 1) → ℝ), x ∈ set.univ.pi (λ (i : fin (n + 1)), set.Ioo (a i) (b i))  s → ∀ (i : fin (n + 1)), has_fderiv_at (f i) (f' i x) x) (Hi : measure_theory.integrable_on (λ (x : fin (n + 1) → ℝ), finset.univ.sum (λ (i : fin (n + 1)), ⇑(f' i x) (pi.single i 1))) (set.Icc a b) measure_theory.measure_space.volume) : ∫ (x : fin (n + 1) → ℝ) in set.Icc a b, finset.univ.sum (λ (i : fin (n + 1)), ⇑(f' i x) (pi.single i 1)) = finset.univ.sum (λ (i : fin (n + 1)), (∫ (x : fin n → ℝ) in set.Icc (a ∘ ⇑(i.succ_above)) (b ∘ ⇑(i.succ_above)), f i (i.insert_nth (b i) x)) - ∫ (x : fin n → ℝ) in set.Icc (a ∘ ⇑(i.succ_above)) (b ∘ ⇑(i.succ_above)), f i (i.insert_nth (a i) x))
theorem bilin_form.exists_orthogonal_basis {V : Type u} {K : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] [hK : invertible 2] {B : bilin_form K V} (hB₂ : B.is_symm) : ∃ (v : basis (fin (finite_dimensional.finrank K V)) K V), B.is_Ortho ⇑v
theorem euclidean_geometry.angle_le_pi {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (p1 p2 p3 : P) : euclidean_geometry.angle p1 p2 p3 ≤ real.pi
theorem add_tsub_le_assoc {α : Type u_1} [preorder α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] {a b c : α} [covariant_class α α has_add.add has_le.le] : a + b - c ≤ a + (b - c)
theorem orthonormal.oangle_neg_left {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : hb.oangle (-x) y = hb.oangle x y + ↑real.pi
theorem sub_pos_of_lt {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : b < a → 0 < a - b
theorem cont_diff_on.comp' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {n : with_top ℕ} {s : set E} {t : set F} {g : F → G} {f : E → F} (hg : cont_diff_on 𝕜 n g t) (hf : cont_diff_on 𝕜 n f s) : cont_diff_on 𝕜 n (g ∘ f) (s ∩ f ⁻¹' t)
theorem metric.inf_dist_nonneg {α : Type u} [pseudo_metric_space α] {s : set α} {x : α} : 0 ≤ metric.inf_dist x s
theorem is_topological_fiber_bundle.exists_trivialization_Icc_subset {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] [conditionally_complete_linear_order B] [order_topology B] (h : is_topological_fiber_bundle F proj) (a b : B) : ∃ (e : topological_fiber_bundle.trivialization F proj), set.Icc a b ⊆ e.base_set
theorem divisor_chain.second_of_chain_is_irreducible {M : Type u_1} [cancel_comm_monoid_with_zero M] {q : associates M} {n : ℕ} (hn : n ≠ 0) {c : fin (n + 1) → associates M} (h₁ : strict_mono c) (h₂ : ∀ {r : associates M}, r ≤ q ↔ ∃ (i : fin (n + 1)), r = c i) (hq : q ≠ 0) : irreducible (c 1)
theorem strict_mono.mul_monotone' {α : Type u_1} {β : Type u_2} [has_mul α] [preorder α] [preorder β] {f g : β → α} [covariant_class α α has_mul.mul has_le.le] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] (hf : strict_mono f) (hg : monotone g) : strict_mono (λ (x : β), f x * g x)
theorem fin.succ_above_zero {n : ℕ} : ⇑(0.succ_above) = fin.succ
theorem polish_space.exists_nat_nat_continuous_surjective (α : Type u_1) [topological_space α] [polish_space α] [nonempty α] : ∃ (f : (ℕ → ℕ) → α), continuous f ∧ function.surjective f
theorem nat.multiplicative_factorization' {β : Type u_1} [comm_monoid β] (f : ℕ → β) (h_mult : ∀ (x y : ℕ), x.coprime y → f (x * y) = f x * f y) (hf0 : f 0 = 1) (hf1 : f 1 = 1) {n : ℕ} : f n = n.factorization.prod (λ (p k : ℕ), f (p ^ k))
theorem polynomial.mul_eq_sum_sum {R : Type u} [semiring R] {p q : polynomial R} : p * q = p.support.sum (λ (i : ℕ), q.sum (λ (j : ℕ) (a : R), ⇑(polynomial.monomial (i + j)) (p.coeff i * a)))
theorem tensor_product.ext {R : Type u_1} [comm_semiring R] {M : Type u_4} {N : Type u_5} {P : Type u_6} [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [module R M] [module R N] [module R P] {g h : tensor_product R M N →ₗ[R] P} (H : (tensor_product.mk R M N).compr₂ g = (tensor_product.mk R M N).compr₂ h) : g = h
theorem iterated_fderiv_within_inter_open {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s u : set E} {f : E → F} {x : E} {n : ℕ} (hu : is_open u) (hs : unique_diff_on 𝕜 (s ∩ u)) (hx : x ∈ s ∩ u) : iterated_fderiv_within 𝕜 n f (s ∩ u) x = iterated_fderiv_within 𝕜 n f s x
theorem vitali_family.ae_eventually_measure_zero_of_singular {α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {ρ : measure_theory.measure α} [measure_theory.is_locally_finite_measure ρ] (hρ : ρ.mutually_singular μ) : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (a : set α), ⇑ρ a / ⇑μ a) (v.filter_at x) (nhds 0)
theorem set.image_image2_antidistrib_right {α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {f : α → β → γ} {s : set α} {t : set β} {g : γ → δ} {f' : β → α' → δ} {g' : α → α'} (h_antidistrib : ∀ (a : α) (b : β), g (f a b) = f' b (g' a)) : g '' set.image2 f s t = set.image2 f' t (g' '' s)
theorem lipschitz_on_with.of_dist_le_mul {α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {K : nnreal} {s : set α} {f : α → β} : (∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → has_dist.dist (f x) (f y) ≤ ↑K * has_dist.dist x y) → lipschitz_on_with K f s
theorem int.not_is_field  : ¬is_field ℤ
theorem finset.le_prod_of_submultiplicative_on_pred {ι : Type u_1} {M : Type u_4} {N : Type u_5} [comm_monoid M] [ordered_comm_monoid N] (f : M → N) (p : M → Prop) (h_one : f 1 = 1) (h_mul : ∀ (x y : M), p x → p y → f (x * y) ≤ f x * f y) (hp_mul : ∀ (x y : M), p x → p y → p (x * y)) (g : ι → M) {s : finset ι} (hs : ∀ (i : ι), i ∈ s → p (g i)) : f (s.prod (λ (i : ι), g i)) ≤ s.prod (λ (i : ι), f (g i))
theorem is_local_max.fderiv_eq_zero {E : Type u} [normed_group E] [normed_space ℝ E] {f : E → ℝ} {a : E} (h : is_local_max f a) : fderiv ℝ f a = 0
theorem has_lt.lt.eq_bot {α : Type u_1} [preorder α] [bounded_order α] [is_simple_order α] {a b : α} (h : a < b) : a = ⊥
theorem free_group.red.inv_of_red_of_ne {α : Type u} {L₁ L₂ : list (α × bool)} {x1 : α} {b1 : bool} {x2 : α} {b2 : bool} (H1 : (x1, b1) ≠ (x2, b2)) (H2 : free_group.red ((x1, b1) :: L₁) ((x2, b2) :: L₂)) : free_group.red L₁ ((x1, !b1) :: (x2, b2) :: L₂)
theorem filter.has_basis.restrict {α : Type u_1} {ι : Sort u_4} {l : filter α} {p : ι → Prop} {s : ι → set α} (h : l.has_basis p s) {q : ι → Prop} (hq : ∀ (i : ι), p i → (∃ (j : ι), p j ∧ q j ∧ s j ⊆ s i)) : l.has_basis (λ (i : ι), p i ∧ q i) s
theorem category_theory.presheaf.is_sheaf_iff_is_sheaf_forget {C : Type u₁} [category_theory.category C] {A : Type u₂} [category_theory.category A] (J : category_theory.grothendieck_topology C) (P : Cᵒᵖ ⥤ A) [category_theory.limits.has_pullbacks C] (s : A ⥤ Type (max v₁ u₁)) [category_theory.limits.has_limits A] [category_theory.limits.preserves_limits s] [category_theory.reflects_isomorphisms s] : category_theory.presheaf.is_sheaf J P ↔ category_theory.presheaf.is_sheaf J (P ⋙ s)
theorem interval_integral.integral_pos_iff_support_of_nonneg_ae {f : ℝ → ℝ} {a b : ℝ} {μ : measure_theory.measure ℝ} (hf : 0 ≤ᵐ[μ] f) (hfi : interval_integrable f μ a b) : 0 < ∫ (x : ℝ) in a..b, f x ∂μ ↔ a < b ∧ 0 < ⇑μ (function.support f ∩ set.Ioc a b)
theorem strict_mono_on.continuous_at_of_closure_image_mem_nhds {α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_on f s) (hs : s ∈ nhds a) (hfs : closure (f '' s) ∈ nhds (f a)) : continuous_at f a
theorem antitone.pairwise_disjoint_on_Ico_succ {α : Type u_1} {β : Type u_2} [linear_order α] [succ_order α] [preorder β] {f : α → β} (hf : antitone f) : pairwise (disjoint on λ (n : α), set.Ico (f (order.succ n)) (f n))
theorem category_theory.is_subterminal_of_mono_is_terminal_from {C : Type u₁} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)] : category_theory.is_subterminal A
theorem measure_theory.forall_measure_preimage_mul_iff {G : Type u_1} [measurable_space G] [has_mul G] [has_measurable_mul G] (μ : measure_theory.measure G) : (∀ (g : G) (A : set G), measurable_set A → ⇑μ ((λ (h : G), g * h) ⁻¹' A) = ⇑μ A) ↔ μ.is_mul_left_invariant
theorem dim_le_one_iff {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : module.rank K V ≤ 1 ↔ ∃ (v₀ : V), ∀ (v : V), ∃ (r : K), r • v₀ = v
theorem tsum_of_norm_bounded {ι : Type u_1} {E : Type u_3} [semi_normed_group E] {f : ι → E} {g : ι → ℝ} {a : ℝ} (hg : has_sum g a) (h : ∀ (i : ι), ∥f i∥ ≤ g i) : ∥∑' (i : ι), f i∥ ≤ a
theorem exists_compact_mem_nhds {α : Type u} [topological_space α] [locally_compact_space α] (x : α) : ∃ (K : set α), is_compact K ∧ K ∈ nhds x
theorem convex.lipschitz_on_with_of_nnnorm_fderiv_le {E : Type u_1} [normed_group E] [normed_space ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_space 𝕜 E] [normed_group G] [normed_space 𝕜 G] {f : E → G} {s : set E} {C : nnreal} (hf : ∀ (x : E), x ∈ s → differentiable_at 𝕜 f x) (bound : ∀ (x : E), x ∈ s → ∥fderiv 𝕜 f x∥₊ ≤ C) (hs : convex ℝ s) : lipschitz_on_with C f s
theorem iterated_deriv_within_eq_iterate {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {n : ℕ} {f : 𝕜 → F} {s : set 𝕜} {x : 𝕜} (hs : unique_diff_on 𝕜 s) (hx : x ∈ s) : iterated_deriv_within n f s x = (λ (g : 𝕜 → F), deriv_within g s)^[n] f x
theorem cont_diff_at.add {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {x : E} {n : with_top ℕ} {f g : E → F} (hf : cont_diff_at 𝕜 n f x) (hg : cont_diff_at 𝕜 n g x) : cont_diff_at 𝕜 n (λ (x : E), f x + g x) x
theorem exists_deriv_eq_zero' {f : ℝ → ℝ} {a b l : ℝ} (hab : a < b) (hfa : filter.tendsto f (nhds_within a (set.Ioi a)) (nhds l)) (hfb : filter.tendsto f (nhds_within b (set.Iio b)) (nhds l)) : ∃ (c : ℝ) (H : c ∈ set.Ioo a b), deriv f c = 0
theorem finset.sum_centroid_weights_indicator_eq_one_of_card_ne_zero (k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) [char_zero k] [fintype ι] (h : s.card ≠ 0) : finset.univ.sum (λ (i : ι), finset.centroid_weights_indicator k s i) = 1
theorem composition_series.ext {X : Type u} [lattice X] [jordan_holder_lattice X] {s₁ s₂ : composition_series X} (h : ∀ (x : X), x ∈ s₁ ↔ x ∈ s₂) : s₁ = s₂
theorem measure_theory.integrable_on_image_iff_integrable_on_abs_det_fderiv_smul {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] [normed_group F] [normed_space ℝ F] {s : set E} {f : E → E} {f' : E → (E →L[ℝ] E)} [measurable_space E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (hs : measurable_set s) (hf' : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) (g : E → F) : measure_theory.integrable_on g (f '' s) μ ↔ measure_theory.integrable_on (λ (x : E), |(f' x).det| • g (f x)) s μ
theorem bounded_continuous_function.mem_Lp {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} {p : ennreal} {μ : measure_theory.measure α} [normed_group E] [topological_space α] [borel_space α] [second_countable_topology_either α E] [measure_theory.is_finite_measure μ] (f : bounded_continuous_function α E) : continuous_map.to_ae_eq_fun μ f.to_continuous_map ∈ measure_theory.Lp E p μ
theorem orthonormal.inner_finsupp_eq_zero {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : orthonormal 𝕜 v) {s : set ι} {i : ι} (hi : i ∉ s) {l : ι →₀ 𝕜} (hl : l ∈ finsupp.supported 𝕜 𝕜 s) : has_inner.inner (⇑(finsupp.total ι E 𝕜 v) l) (v i) = 0
theorem monoid_algebra.exists_finset_adjoin_eq_top {R : Type u_1} {M : Type u_2} [comm_ring R] [comm_monoid M] [h : algebra.finite_type R (monoid_algebra R M)] : ∃ (G : finset M), algebra.adjoin R (⇑(monoid_algebra.of R M) '' ↑G) = ⊤
theorem list.nth_zero_mul_tail_prod {M : Type u_3} [monoid M] (l : list M) : (l.nth 0).get_or_else 1 * l.tail.prod = l.prod
theorem isometry.uniform_embedding {α : Type u} {β : Type v} [emetric_space α] [pseudo_emetric_space β] {f : α → β} (hf : isometry f) : uniform_embedding f
theorem ratfunc.eval_mul {K : Type u} [hfield : field K] {L : Type u_1} [field L] (f : K →+* L) (a : L) {x y : ratfunc K} (hx : polynomial.eval₂ f a x.denom ≠ 0) (hy : polynomial.eval₂ f a y.denom ≠ 0) : ratfunc.eval f a (x * y) = ratfunc.eval f a x * ratfunc.eval f a y
theorem Top.stalk_to_fiber_injective {X : Top} {T : ↥X → Type v} (P : Top.local_predicate T) (x : ↥X) (w : ∀ (U V : topological_space.open_nhds x) (fU : Π (y : ↥(U.val)), T ↑y), P.to_prelocal_predicate.pred fU → ∀ (fV : Π (y : ↥(V.val)), T ↑y), P.to_prelocal_predicate.pred fV → fU ⟨x, _⟩ = fV ⟨x, _⟩ → (∃ (W : topological_space.open_nhds x) (iU : W ⟶ U) (iV : W ⟶ V), ∀ (w : ↥(W.val)), fU (⇑iU w) = fV (⇑iV w))) : function.injective (Top.stalk_to_fiber P x)
theorem left.one_lt_mul_of_lt_of_le {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 ≤ b) : 1 < a * b
theorem power_series.order_one {R : Type u_1} [semiring R] [nontrivial R] : 1.order = 0
theorem category_theory.idempotents.karoubi.decomp_id {C : Type u_1} [category_theory.category C] (P : category_theory.idempotents.karoubi C) : 𝟙 P = P.decomp_id_i ≫ P.decomp_id_p
theorem vector.last_def {n : ℕ} {α : Type u_1} {v : vector α (n + 1)} : v.last = v.nth (fin.last n)
theorem dense_inducing.prod {α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} [topological_space α] [topological_space β] [topological_space γ] [topological_space δ] {e₁ : α → β} {e₂ : γ → δ} (de₁ : dense_inducing e₁) (de₂ : dense_inducing e₂) : dense_inducing (λ (p : α × γ), (e₁ p.fst, e₂ p.snd))
theorem is_bounded_bilinear_map_smul_right {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] : is_bounded_bilinear_map 𝕜 (λ (p : (E →L[𝕜] 𝕜) × F), p.fst.smul_right p.snd)
theorem refinement_of_locally_compact_sigma_compact_of_nhds_basis_set {X : Type v} [topological_space X] [locally_compact_space X] [sigma_compact_space X] [t2_space X] {ι : X → Type u} {p : Π (x : X), ι x → Prop} {B : Π (x : X), ι x → set X} {s : set X} (hs : is_closed s) (hB : ∀ (x : X), x ∈ s → (nhds x).has_basis (p x) (B x)) : ∃ (α : Type v) (c : α → X) (r : Π (a : α), ι (c a)), (∀ (a : α), c a ∈ s ∧ p (c a) (r a)) ∧ (s ⊆ ⋃ (a : α), B (c a) (r a)) ∧ locally_finite (λ (a : α), B (c a) (r a))
theorem cardinal.le_range_of_union_finset_eq_top {α : Type u_1} {β : Type u_2} [infinite β] (f : α → finset β) (w : (⋃ (a : α), ↑(f a)) = ⊤) : cardinal.mk β ≤ cardinal.mk ↥(set.range f)
theorem measure_theory.conservative.ae_mem_imp_frequently_image_mem {α : Type u_2} [measurable_space α] {f : α → α} {s : set α} {μ : measure_theory.measure α} (hf : measure_theory.conservative f μ) (hs : measurable_set s) : ∀ᵐ (x : α) ∂μ, x ∈ s → (∃ᶠ (n : ℕ) in filter.at_top, f^[n] x ∈ s)
theorem linear_map.adjoint_adjoint {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [inner_product_space 𝕜 F] [finite_dimensional 𝕜 E] [finite_dimensional 𝕜 F] (A : E →ₗ[𝕜] F) : ⇑linear_map.adjoint (⇑linear_map.adjoint A) = A
theorem mdifferentiable_on_iff_differentiable_on {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {f : E → E'} {s : set E} : mdifferentiable_on (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f s ↔ differentiable_on 𝕜 f s
theorem list.Ico.trichotomy (n a b : ℕ) : n < a ∨ b ≤ n ∨ n ∈ list.Ico a b
theorem monotone.covariant_of_const {M : Type u_1} {N : Type u_2} {μ : M → N → N} {α : Type u_3} [preorder α] [preorder N] {f : N → α} [covariant_class M N μ has_le.le] (hf : monotone f) (m : M) : monotone (λ (n : N), f (μ m n))
theorem pseudo_metric_space.ext {α : Type u_1} {m m' : pseudo_metric_space α} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist) : m = m'
theorem vitali_family.with_density_le_mul {α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {ρ : measure_theory.measure α} [measure_theory.is_locally_finite_measure ρ] (hρ : ρ.absolutely_continuous μ) {s : set α} (hs : measurable_set s) {t : nnreal} (ht : 1 < t) : ⇑(μ.with_density (v.lim_ratio_meas hρ)) s ≤ ↑t ^ 2 * ⇑ρ s
theorem cont_diff_at.snd {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {n : with_top ℕ} {f : E → F × G} {x : E} (hf : cont_diff_at 𝕜 n f x) : cont_diff_at 𝕜 n (λ (x : E), (f x).snd) x
theorem summable_condensed_iff_of_nonneg {f : ℕ → ℝ} (h_nonneg : ∀ (n : ℕ), 0 ≤ f n) (h_mono : ∀ ⦃m n : ℕ⦄, 0 < m → m ≤ n → f n ≤ f m) : summable (λ (k : ℕ), 2 ^ k * f (2 ^ k)) ↔ summable f
theorem euclidean_geometry.angle_eq_angle_of_angle_eq_pi_of_angle_eq_pi {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 p4 p5 : P} (hapc : euclidean_geometry.angle p1 p5 p3 = real.pi) (hbpd : euclidean_geometry.angle p2 p5 p4 = real.pi) : euclidean_geometry.angle p1 p5 p2 = euclidean_geometry.angle p3 p5 p4
theorem riesz_extension.step {E : Type u_2} [add_comm_group E] [module ℝ E] (s : convex_cone ℝ E) (f : linear_pmap ℝ E ℝ) (nonneg : ∀ (x : ↥(f.domain)), ↑x ∈ s → 0 ≤ ⇑f x) (dense : ∀ (y : E), ∃ (x : ↥(f.domain)), ↑x + y ∈ s) (hdom : f.domain ≠ ⊤) : ∃ (g : linear_pmap ℝ E ℝ), f < g ∧ ∀ (x : ↥(g.domain)), ↑x ∈ s → 0 ≤ ⇑g x
theorem ring_equiv.to_monoid_hom_commutes {R : Type u_4} {S : Type u_5} [non_assoc_semiring R] [non_assoc_semiring S] (f : R ≃+* S) : ↑f.to_monoid_hom = ↑f.to_monoid_hom
theorem category_theory.over.construct_products.over_finite_products_of_finite_wide_pullbacks {C : Type u} [category_theory.category C] [category_theory.limits.has_finite_wide_pullbacks C] {B : C} : category_theory.limits.has_finite_products (category_theory.over B)
theorem bounded_continuous_function.norm_eq {α : Type u} {β : Type v} [topological_space α] [semi_normed_group β] (f : bounded_continuous_function α β) : ∥f∥ = has_Inf.Inf {C : ℝ | 0 ≤ C ∧ ∀ (x : α), ∥⇑f x∥ ≤ C}
theorem vitali_family.ae_tendsto_measure_inter_div {α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] (s : set α) : ∀ᵐ (x : α) ∂μ.restrict s, filter.tendsto (λ (a : set α), ⇑μ (s ∩ a) / ⇑μ a) (v.filter_at x) (nhds 1)
theorem dist_le_of_le_geometric_two_of_tendsto₀ {α : Type u_1} [pseudo_metric_space α] (C : ℝ) {f : ℕ → α} (hu₂ : ∀ (n : ℕ), has_dist.dist (f n) (f (n + 1)) ≤ C / 2 / 2 ^ n) {a : α} (ha : filter.tendsto f filter.at_top (nhds a)) : has_dist.dist (f 0) a ≤ C
theorem tangent_cone_inter_nhds {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {x : E} {s t : set E} (ht : t ∈ nhds x) : tangent_cone_at 𝕜 (s ∩ t) x = tangent_cone_at 𝕜 s x
theorem metric.exists_dist_lt_of_Hausdorff_dist_lt' {α : Type u} [pseudo_metric_space α] {s t : set α} {y : α} {r : ℝ} (h : y ∈ t) (H : metric.Hausdorff_dist s t < r) (fin : emetric.Hausdorff_edist s t ≠ ⊤) : ∃ (x : α) (H : x ∈ s), has_dist.dist x y < r
theorem category_theory.epi_of_nonzero_to_simple {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] {X Y : C} [category_theory.simple Y] {f : X ⟶ Y} [category_theory.limits.has_image f] (w : f ≠ 0) : category_theory.epi f
theorem asymptotics.is_o.norm_norm {α : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_normed_group E'] [semi_normed_group F'] {f' : α → E'} {g' : α → F'} {l : filter α} : f' =o[l] g' → ((λ (x : α), ∥f' x∥) =o[l] λ (x : α), ∥g' x∥)
theorem dfinsupp.lhom_ext' {ι : Type u_1} {R : Type u_2} {M : ι → Type u_4} {N : Type u_5} [dec_ι : decidable_eq ι] [semiring R] [Π (i : ι), add_comm_monoid (M i)] [Π (i : ι), module R (M i)] [add_comm_monoid N] [module R N] ⦃φ ψ : (Π₀ (i : ι), M i) →ₗ[R] N⦄ (h : ∀ (i : ι), φ.comp (dfinsupp.lsingle i) = ψ.comp (dfinsupp.lsingle i)) : φ = ψ
theorem cont_mdiff.cont_mdiff_tangent_map {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M → M'} {m n : with_top ℕ} (hf : cont_mdiff I I' n f) (hmn : m + 1 ≤ n) : cont_mdiff I.tangent I'.tangent m (tangent_map I I' f)
theorem quaternion_group.order_of_a {n : ℕ} [fact (0 < n)] (i : zmod (2 * n)) : order_of (quaternion_group.a i) = 2 * n / (2 * n).gcd i.val
theorem affine.simplex.sum_centroid_weights_with_circumcenter {n : ℕ} {fs : finset (fin (n + 1))} (h : fs.nonempty) : finset.univ.sum (λ (i : affine.simplex.points_with_circumcenter_index n), affine.simplex.centroid_weights_with_circumcenter fs i) = 1
theorem add_con.le_def {M : Type u_1} [has_add M] {c d : add_con M} : c ≤ d ↔ ∀ {x y : M}, ⇑c x y → ⇑d x y
theorem is_monoid_hom.id {α : Type u} [mul_one_class α] : is_monoid_hom id
theorem finite_dimensional_of_is_compact_closed_ball₀ (𝕜 : Type u) [nondiscrete_normed_field 𝕜] {E : Type v} [normed_group E] [normed_space 𝕜 E] [complete_space 𝕜] {r : ℝ} (rpos : 0 < r) (h : is_compact (metric.closed_ball 0 r)) : finite_dimensional 𝕜 E
theorem lt_cSup_of_lt {α : Type u_1} [conditionally_complete_lattice α] {s : set α} {a b : α} (hs : bdd_above s) (ha : a ∈ s) (h : b < a) : b < has_Sup.Sup s
theorem multilinear_map.dom_coprod_alternization {ιa : Type u_7} {ιb : Type u_8} [decidable_eq ιa] [decidable_eq ιb] [fintype ιa] [fintype ιb] {R' : Type u_9} {Mᵢ : Type u_10} {N₁ : Type u_11} {N₂ : Type u_12} [comm_semiring R'] [add_comm_group N₁] [module R' N₁] [add_comm_group N₂] [module R' N₂] [add_comm_monoid Mᵢ] [module R' Mᵢ] (a : multilinear_map R' (λ (_x : ιa), Mᵢ) N₁) (b : multilinear_map R' (λ (_x : ιb), Mᵢ) N₂) : ⇑multilinear_map.alternatization (a.dom_coprod b) = (⇑multilinear_map.alternatization a).dom_coprod (⇑multilinear_map.alternatization b)
theorem pgame.add_zero_equiv (x : pgame) : (x + 0).equiv x
theorem strong_rank_condition_iff_succ (R : Type u) [semiring R] : strong_rank_condition R ↔ ∀ (n : ℕ) (f : (fin (n + 1) → R) →ₗ[R] fin n → R), ¬function.injective ⇑f
theorem padic_norm.padic_norm_p_of_prime (p : ℕ) [fact (nat.prime p)] : padic_norm p ↑p = 1 / ↑p
theorem matrix.mul_inv_of_self {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) [invertible A] : A.mul (⅟ A) = 1
theorem uv.card_compress {α : Type u_1} [decidable_eq α] {U V : finset α} (hUV : U.card = V.card) (A : finset α) : (uv.compress U V A).card = A.card
theorem laurent_polynomial.C_eq_algebra_map {R : Type u_1} [comm_semiring R] (r : R) : ⇑laurent_polynomial.C r = ⇑(algebra_map R (laurent_polynomial R)) r
theorem eq_vadd_iff_vsub_eq {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p1 : P) (g : G) (p2 : P) : p1 = g +ᵥ p2 ↔ p1 -ᵥ p2 = g
theorem algebra.is_integral_trans {R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [comm_ring B] [algebra A B] [algebra R B] [algebra R A] [is_scalar_tower R A B] (hA : algebra.is_integral R A) (hB : algebra.is_integral A B) : algebra.is_integral R B
theorem set.Union_Inter_of_monotone {ι : Type u_1} {ι' : Type u_2} {α : Type u_3} [fintype ι] [preorder ι'] [is_directed ι' has_le.le] [nonempty ι'] {s : ι → ι' → set α} (hs : ∀ (i : ι), monotone (s i)) : (⋃ (j : ι'), ⋂ (i : ι), s i j) = ⋂ (i : ι), ⋃ (j : ι'), s i j
theorem mv_polynomial.map_left_inverse {R : Type u} {S₁ : Type v} {σ : Type u_1} [comm_semiring R] [comm_semiring S₁] {f : R →+* S₁} {g : S₁ →+* R} (hf : function.left_inverse ⇑f ⇑g) : function.left_inverse ⇑(mv_polynomial.map f) ⇑(mv_polynomial.map g)
theorem category_theory.limits.has_colimit.of_cocones_iso {J : Type u₁} [category_theory.category J] {C : Type u} [category_theory.category C] {K : Type u₁} [category_theory.category K] (F : J ⥤ C) (G : K ⥤ C) (h : F.cocones ≅ G.cocones) [category_theory.limits.has_colimit F] : category_theory.limits.has_colimit G
theorem set.finite.nmem_hyperfilter {α : Type u} [infinite α] {s : set α} (hf : s.finite) : s ∉ filter.hyperfilter α
theorem left.mul_le_one {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1
theorem monoid_hom.is_of_fin_order {G : Type u} [monoid G] {H : Type v} [monoid H] (f : G →* H) {x : G} (h : is_of_fin_order x) : is_of_fin_order (⇑f x)
theorem filter.tendsto.uniformity_symm {α : Type u_1} {β : Type u_2} [uniform_space α] {l : filter β} {f : β → α × α} (h : filter.tendsto f l (uniformity α)) : filter.tendsto (λ (x : β), ((f x).snd, (f x).fst)) l (uniformity α)
theorem filter.map₂_map_left_anticomm {α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {f : filter α} {g : filter β} {m : α' → β → γ} {n : α → α'} {m' : β → α → δ} {n' : δ → γ} (h_left_anticomm : ∀ (a : α) (b : β), m (n a) b = n' (m' b a)) : filter.map₂ m (filter.map n f) g = filter.map n' (filter.map₂ m' g f)
theorem int.units_pow_two (u : ℤˣ) : u ^ 2 = 1
theorem compact_open_separated_add_right {G : Type w} [topological_space G] [add_group G] [topological_add_group G] {K U : set G} (hK : is_compact K) (hU : is_open U) (hKU : K ⊆ U) : ∃ (V : set G) (H : V ∈ nhds 0), K + V ⊆ U
theorem is_nilpotent_of_finite_tfae {G : Type u_1} [hG : group G] [hf : fintype G] : [group.is_nilpotent G, normalizer_condition G, ∀ (H : subgroup G), is_coatom H → H.normal, ∀ (p : ℕ), fact (nat.prime p) → ∀ (P : sylow p G), ↑P.normal, nonempty ((Π (p : ↥((fintype.card G).factorization.support)) (P : sylow ↑p G), ↥↑P) ≃* G)].tfae
theorem measure_theory.tendsto_set_to_fun_filter_of_dominated_convergence {α : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {m : measurable_space α} {μ : measure_theory.measure α} [complete_space F] {T : set α → (E →L[ℝ] F)} {C : ℝ} (hT : measure_theory.dominated_fin_meas_additive μ T C) {ι : Type u_4} {l : filter ι} [l.is_countably_generated] {fs : ι → α → E} {f : α → E} (bound : α → ℝ) (hfs_meas : ∀ᶠ (n : ι) in l, measure_theory.ae_strongly_measurable (fs n) μ) (h_bound : ∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, ∥fs n a∥ ≤ bound a) (bound_integrable : measure_theory.integrable bound μ) (h_lim : ∀ᵐ (a : α) ∂μ, filter.tendsto (λ (n : ι), fs n a) l (nhds (f a))) : filter.tendsto (λ (n : ι), measure_theory.set_to_fun μ T hT (fs n)) l (nhds (measure_theory.set_to_fun μ T hT f))
theorem ordinal.log_nonempty {b x : ordinal} (h : 1 < b) : {o : ordinal | x < b ^ o}.nonempty
theorem nat.prime.sq_add_sq {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p
theorem continuous.surjective {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {δ : Type u_1} [linear_order δ] [topological_space δ] [order_closed_topology δ] {f : α → δ} (hf : continuous f) (h_top : filter.tendsto f filter.at_top filter.at_top) (h_bot : filter.tendsto f filter.at_bot filter.at_bot) : function.surjective f
theorem phragmen_lindelof.eq_on_quadrant_II {E : Type u_1} [normed_group E] [normed_space ℂ E] {f g : ℂ → E} (hdf : diff_cont_on_cl ℂ f (set.Iio 0 ×ℂ set.Ioi 0)) (hBf : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ filter.principal (set.Iio 0 ×ℂ set.Ioi 0)] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hdg : diff_cont_on_cl ℂ g (set.Iio 0 ×ℂ set.Ioi 0)) (hBg : ∃ (c : ℝ) (H : c < 2) (B : ℝ), g =O[filter.comap complex.abs filter.at_top ⊓ filter.principal (set.Iio 0 ×ℂ set.Ioi 0)] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hre : ∀ (x : ℝ), x ≤ 0 → f ↑x = g ↑x) (him : ∀ (x : ℝ), 0 ≤ x → f (↑x * complex.I) = g (↑x * complex.I)) : set.eq_on f g {z : ℂ | z.re ≤ 0 ∧ 0 ≤ z.im}
theorem polynomial.map_alg_eq_map {R : Type u} [comm_semiring R] {S : Type v} [semiring S] [algebra R S] (p : polynomial R) : ⇑(polynomial.map_alg R S) p = polynomial.map (algebra_map R S) p
theorem finset.sum_smul_const_vsub_eq_sub_weighted_vsub_of_point {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (w : ι → k) (p₂ : ι → P) (p₁ b : P) : s.sum (λ (i : ι), w i • (p₁ -ᵥ p₂ i)) = s.sum (λ (i : ι), w i) • (p₁ -ᵥ b) - ⇑(s.weighted_vsub_of_point p₂ b) w
theorem commute.symm {S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : commute b a
theorem emetric.mk_uniformity_basis {α : Type u} [pseudo_emetric_space α] {β : Type u_1} {p : β → Prop} {f : β → ennreal} (hf₀ : ∀ (x : β), p x → 0 < f x) (hf : ∀ (ε : ennreal), 0 < ε → (∃ (x : β) (hx : p x), f x ≤ ε)) : (uniformity α).has_basis p (λ (x : β), {p : α × α | has_edist.edist p.fst p.snd < f x})
theorem polynomial.leading_coeff_multiset_prod' {R : Type u} [comm_semiring R] (t : multiset (polynomial R)) (h : (multiset.map polynomial.leading_coeff t).prod ≠ 0) : t.prod.leading_coeff = (multiset.map polynomial.leading_coeff t).prod
theorem convex_cone.ext'_iff {𝕜 : Type u_1} {E : Type u_2} [ordered_semiring 𝕜] [add_comm_monoid E] [has_scalar 𝕜 E] {S T : convex_cone 𝕜 E} : ↑S = ↑T ↔ S = T
theorem pgame.lf.trans_lt {x y z : pgame} (h₁ : x.lf y) (h₂ : y < z) : x.lf z
theorem affine.simplex.reflection_circumcenter_eq_affine_combination_of_points_with_circumcenter {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P n) {i₁ i₂ : fin (n + 1)} (h : i₁ ≠ i₂) : ⇑(euclidean_geometry.reflection (affine_span ℝ (s.points '' {i₁, i₂}))) s.circumcenter = ⇑(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.reflection_circumcenter_weights_with_circumcenter i₁ i₂)
theorem category_theory.is_iso_of_regular_epi_of_mono {C : Type u₁} [category_theory.category C] {X Y : C} (f : X ⟶ Y) [category_theory.regular_epi f] [m : category_theory.mono f] : category_theory.is_iso f
theorem measure_theory.is_clopenable_iff_measurable_set {γ : Type u_3} [tγ : topological_space γ] [polish_space γ] [measurable_space γ] [borel_space γ] {s : set γ} : polish_space.is_clopenable s ↔ measurable_set s
theorem comap_coe_Ioo_nhds_within_Ioi {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a b : α) : filter.comap coe (nhds_within a (set.Ioi a)) = filter.at_bot
theorem is_cyclotomic_extension.splits_cyclotomic (n : ℕ+) (S : set ℕ+) (K : Type w) (L : Type z) [field K] [field L] [algebra K L] [ne_zero ↑↑n] [is_cyclotomic_extension S K L] (hS : n ∈ S) : polynomial.splits (algebra_map K L) (polynomial.cyclotomic ↑n K)
theorem is_dedekind_domain.height_one_spectrum.int_valuation.map_mul' {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x y : R) : v.int_valuation_def (x * y) = v.int_valuation_def x * v.int_valuation_def y
theorem mem_omega_limit_iff_frequently {τ : Type u_1} {α : Type u_2} {β : Type u_3} [topological_space β] (f : filter τ) (ϕ : τ → α → β) (s : set α) (y : β) : y ∈ omega_limit f ϕ s ↔ ∀ (n : set β), n ∈ nhds y → (∃ᶠ (t : τ) in f, (s ∩ ϕ t ⁻¹' n).nonempty)
theorem lower_semicontinuous_within_at.add {α : Type u_1} [topological_space α] {x : α} {s : set α} {γ : Type u_4} [linear_ordered_add_comm_monoid γ] [topological_space γ] [order_topology γ] [has_continuous_add γ] {f g : α → γ} (hf : lower_semicontinuous_within_at f s x) (hg : lower_semicontinuous_within_at g s x) : lower_semicontinuous_within_at (λ (z : α), f z + g z) s x
theorem has_sum_cauchy_power_series_integral {E : Type u_1} [normed_group E] [normed_space ℂ E] [complete_space E] {f : ℂ → E} {c : ℂ} {R : ℝ} {w : ℂ} (hf : circle_integrable f c R) (hw : complex.abs w < R) : has_sum (λ (n : ℕ), ⇑(cauchy_power_series f c R n) (λ (_x : fin n), w)) ((2 * ↑real.pi * complex.I)⁻¹ • ∮ (z : ℂ) in C(c, R), (z - (c + w))⁻¹ • f z)
theorem set.pairwise.of_refl {α : Type u_1} {r : α → α → Prop} {s : set α} [is_refl α r] : s.pairwise r → ∀ ⦃a : α⦄, a ∈ s → ∀ ⦃b : α⦄, b ∈ s → r a b
theorem convex_on.map_set_average_le {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {t : set α} {f : α → E} {g : E → ℝ} (hg : convex_on ℝ s g) (hgc : continuous_on g s) (hsc : is_closed s) (h0 : ⇑μ t ≠ 0) (ht : ⇑μ t ≠ ⊤) (hfs : ∀ᵐ (x : α) ∂μ.restrict t, f x ∈ s) (hfi : measure_theory.integrable_on f t μ) (hgi : measure_theory.integrable_on (g ∘ f) t μ) : g (⨍ (x : α) in t, f x ∂μ) ≤ ⨍ (x : α) in t, g (f x) ∂μ
theorem abs_inner_div_norm_mul_norm_eq_one_iff {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) : is_R_or_C.abs (has_inner.inner x y / (↑∥x∥ * ↑∥y∥)) = 1 ↔ x ≠ 0 ∧ ∃ (r : 𝕜), r ≠ 0 ∧ y = r • x
theorem class_group.exists_mk0_eq_mk0 {R : Type u_1} {S : Type u_2} (L : Type u_4) [euclidean_domain R] [comm_ring S] [is_domain S] [field L] [algRL : algebra R L] [algebra R S] [algebra S L] [ist : is_scalar_tower R S L] [iic : is_integral_closure S R L] {abv : absolute_value R ℤ} {ι : Type u_5} [decidable_eq ι] [fintype ι] (bS : basis ι R S) (adm : abv.is_admissible) [infinite R] [decidable_eq R] [is_dedekind_domain S] [is_fraction_ring S L] (h : algebra.is_algebraic R L) (I : ↥(non_zero_divisors (ideal S))) : ∃ (J : ↥(non_zero_divisors (ideal S))), ⇑(class_group.mk0 L) I = ⇑(class_group.mk0 L) J ∧ ⇑(algebra_map R S) ((class_group.finset_approx bS adm).prod (λ (m : R), m)) ∈ ↑J
theorem measure_theory.measure_is_open_pos_of_smul_invariant_of_compact_ne_zero (G : Type u_1) {α : Type u_3} {m : measurable_space α} [group G] [mul_action G α] [measurable_space G] [has_measurable_smul G α] {μ : measure_theory.measure α} [measure_theory.smul_invariant_measure G α μ] [topological_space α] [has_continuous_const_smul G α] [mul_action.is_minimal G α] {K U : set α} (hK : is_compact K) (hμK : ⇑μ K ≠ 0) (hU : is_open U) (hne : U.nonempty) : 0 < ⇑μ U
theorem pos_of_neg_neg {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : -a < 0 → 0 < a
theorem monoid.subset_closure {M : Type u_1} [monoid M] {s : set M} : s ⊆ monoid.closure s
theorem category_theory.limits.colimits_from_coequalizers_and_coproducts {C : Type u} [category_theory.category C] [category_theory.limits.has_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_colimits C
theorem list.sum_update_nth' {G : Type u_7} [add_comm_group G] (L : list G) (n : ℕ) (a : G) : (L.update_nth n a).sum = L.sum + dite (n < L.length) (λ (hn : n < L.length), -L.nth_le n hn + a) (λ (hn : ¬n < L.length), 0)
theorem strict_convex_on_of_slope_strict_mono_adjacent {𝕜 : Type u_1} [linear_ordered_field 𝕜] {s : set 𝕜} {f : 𝕜 → 𝕜} (hs : convex 𝕜 s) (hf : ∀ {x y z : 𝕜}, x ∈ s → z ∈ s → x < y → y < z → (f y - f x) / (y - x) < (f z - f y) / (z - y)) : strict_convex_on 𝕜 s f
theorem con.map_of_surjective_eq_map_gen {M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] {c : con M} {f : M → N} (H : ∀ (x y : M), f (x * y) = f x * f y) (h : con.mul_ker f H ≤ c) (hf : function.surjective f) : c.map_gen f = c.map_of_surjective f H h hf
theorem fixing_subgroup_Union (M : Type u_1) (α : Type u_2) [group M] [mul_action M α] {ι : Sort u_3} {s : ι → set α} : fixing_subgroup M (⋃ (i : ι), s i) = ⨅ (i : ι), fixing_subgroup M (s i)
theorem measure_theory.measure.haar.haar_content_self {G : Type u_1} [group G] [topological_space G] [topological_group G] [t2_space G] {K₀ : topological_space.positive_compacts G} : ⇑(measure_theory.measure.haar.haar_content K₀) K₀.to_compacts = 1
theorem bdd_above_union {γ : Type w} [semilattice_sup γ] {s t : set γ} : bdd_above (s ∪ t) ↔ bdd_above s ∧ bdd_above t
theorem one_le_of_inv_le_one {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : a⁻¹ ≤ 1 → 1 ≤ a
theorem sum_range_pow (n p : ℕ) : (finset.range n).sum (λ (k : ℕ), ↑k ^ p) = (finset.range (p + 1)).sum (λ (i : ℕ), bernoulli i * ↑((p + 1).choose i) * ↑n ^ (p + 1 - i) / (↑p + 1))
theorem alg_hom.map_coe_real_complex {A : Type u_3} [semiring A] [algebra ℝ A] (f : ℂ →ₐ[ℝ] A) (x : ℝ) : ⇑f ↑x = ⇑(algebra_map ℝ A) x
theorem top_fixed_by_finite {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] : ⊤ ∈ fixed_by_finite K L
theorem subsemiring.sum_mem {R : Type u} [non_assoc_semiring R] (s : subsemiring R) {ι : Type u_1} {t : finset ι} {f : ι → R} (h : ∀ (c : ι), c ∈ t → f c ∈ s) : t.sum (λ (i : ι), f i) ∈ s
theorem submodule.pow_induction_on_left' {R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] (M : submodule R A) {C : Π (n : ℕ) (x : A), x ∈ M ^ n → Prop} (hr : ∀ (r : R), C 0 (⇑(algebra_map R A) r) _) (hadd : ∀ (x y : A) (i : ℕ) (hx : x ∈ M ^ i) (hy : y ∈ M ^ i), C i x hx → C i y hy → C i (x + y) _) (hmul : ∀ (m : A) (H : m ∈ M) (i : ℕ) (x : A) (hx : x ∈ M ^ i), C i x hx → C i.succ (m * x) _) {x : A} {n : ℕ} (hx : x ∈ M ^ n) : C n x hx
theorem finsupp.ext_iff {α : Type u_1} {M : Type u_5} [has_zero M] {f g : α →₀ M} : f = g ↔ ∀ (a : α), ⇑f a = ⇑g a
theorem dense_inducing.interior_compact_eq_empty {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {i : α → β} [t2_space β] (di : dense_inducing i) (hd : dense (set.range i)ᶜ) {s : set α} (hs : is_compact s) : interior s = ∅
theorem Top.presheaf.is_sheaf_iff_is_sheaf_opens_le_cover {C : Type u} [category_theory.category C] {X : Top} [category_theory.limits.has_products C] (F : Top.presheaf C X) : F.is_sheaf ↔ F.is_sheaf_opens_le_cover
theorem list.eq_iff_join_eq {α : Type u_1} (L L' : list (list α)) : L = L' ↔ L.join = L'.join ∧ list.map list.length L = list.map list.length L'
theorem cont_diff_at.differentiable_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {x : E} {n : with_top ℕ} (h : cont_diff_at 𝕜 n f x) (hn : 1 ≤ n) : differentiable_at 𝕜 f x
theorem nnreal.lintegral_mul_le_Lp_mul_Lq {α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {p q : ℝ} (hpq : p.is_conjugate_exponent q) {f g : α → nnreal} (hf : ae_measurable f μ) (hg : ae_measurable g μ) : ∫⁻ (a : α), ↑((f * g) a) ∂μ ≤ (∫⁻ (a : α), ↑(f a) ^ p ∂μ) ^ (1 / p) * (∫⁻ (a : α), ↑(g a) ^ q ∂μ) ^ (1 / q)
theorem metric.cthickening_empty {α : Type u} [pseudo_emetric_space α] (δ : ℝ) : metric.cthickening δ ∅ = ∅
theorem metric.closure_eq_Inter_cthickening' {α : Type u} [pseudo_emetric_space α] (E : set α) (s : set ℝ) (hs : ∀ (ε : ℝ), 0 < ε → (s ∩ set.Ioc 0 ε).nonempty) : closure E = ⋂ (δ : ℝ) (H : δ ∈ s), metric.cthickening δ E
theorem category_theory.functor.final.has_colimit_of_comp {C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ⥤ D) [F.final] {E : Type u} [category_theory.category E] {G : D ⥤ E} [category_theory.limits.has_colimit (F ⋙ G)] : category_theory.limits.has_colimit G
theorem measure_theory.lintegral_prod_symm' {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] (f : α × β → ennreal) (hf : measurable f) : ∫⁻ (z : α × β), f z ∂μ.prod ν = ∫⁻ (y : β), ∫⁻ (x : α), f (x, y) ∂μ ∂ν
theorem reflection_apply {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K : submodule 𝕜 E} [complete_space ↥K] (p : E) : ⇑(reflection K) p = bit0 ↑(⇑(orthogonal_projection K) p) - p
theorem topological_space.first_countable_topology.tendsto_subseq {α : Type u} [t : topological_space α] [topological_space.first_countable_topology α] {u : ℕ → α} {x : α} (hx : map_cluster_pt x filter.at_top u) : ∃ (ψ : ℕ → ℕ), strict_mono ψ ∧ filter.tendsto (u ∘ ψ) filter.at_top (nhds x)
theorem monovary.sum_comp_perm_mul_eq_sum_mul_iff {ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {σ : equiv.perm ι} {f g : ι → α} [fintype ι] (hfg : monovary f g) : finset.univ.sum (λ (i : ι), f (⇑σ i) * g i) = finset.univ.sum (λ (i : ι), f i * g i) ↔ monovary (f ∘ ⇑σ) g
theorem interval_integral.integral_has_fderiv_at_of_tendsto_ae {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {ca cb : E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (ha : filter.tendsto f (nhds a ⊓ measure_theory.measure_space.volume.ae) (nhds ca)) (hb : filter.tendsto f (nhds b ⊓ measure_theory.measure_space.volume.ae) (nhds cb)) : has_fderiv_at (λ (p : ℝ × ℝ), ∫ (x : ℝ) in p.fst..p.snd, f x) ((continuous_linear_map.snd ℝ ℝ ℝ).smul_right cb - (continuous_linear_map.fst ℝ ℝ ℝ).smul_right ca) (a, b)
theorem is_local_min.has_fderiv_at_eq_zero {E : Type u} [normed_group E] [normed_space ℝ E] {f : E → ℝ} {a : E} {f' : E →L[ℝ] ℝ} (h : is_local_min f a) (hf : has_fderiv_at f f' a) : f' = 0
theorem is_max_on.dual {α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α} : is_max_on f s a → is_min_on (⇑order_dual.to_dual ∘ f) s a
theorem continuous_affine_map.cont_diff {𝕜 : Type u_1} {V : Type u_2} {W : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group V] [normed_space 𝕜 V] [normed_group W] [normed_space 𝕜 W] {n : with_top ℕ} (f : V →A[𝕜] W) : cont_diff 𝕜 n ⇑f
theorem orthogonal_eq_inter {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) : Kᗮ = ⨅ (v : ↥K), (⇑innerSL ↑v).ker
theorem category_theory.shift_comm' {C : Type u} {A : Type u_1} [category_theory.category C] [add_comm_monoid A] [category_theory.has_shift C A] {X Y : C} (f : X ⟶ Y) (i j : A) : (category_theory.shift_functor C j).map ((category_theory.shift_functor C i).map f) = (category_theory.shift_comm X i j).hom ≫ (category_theory.shift_functor C i).map ((category_theory.shift_functor C j).map f) ≫ (category_theory.shift_comm Y j i).hom
theorem refl_trans_gen_of_pred {α : Type u_1} [linear_order α] [pred_order α] [is_pred_archimedean α] (r : α → α → Prop) {n m : α} (h1 : ∀ (i : α), i ∈ set.Ioc m n → r i (order.pred i)) (h2 : ∀ (i : α), i ∈ set.Ioc n m → r (order.pred i) i) : relation.refl_trans_gen r n m
theorem continuous_linear_map.lipschitz {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [ring_hom_isometric σ₁₂] (f : E →SL[σ₁₂] F) : lipschitz_with ∥f∥₊ ⇑f
theorem setoid.eqv_gen_of_setoid {α : Type u_1} (r : setoid α) : eqv_gen.setoid setoid.r = r
theorem metric.thickening_subset_cthickening {α : Type u} [pseudo_emetric_space α] (δ : ℝ) (E : set α) : metric.thickening δ E ⊆ metric.cthickening δ E
theorem bounded_continuous_function.coe_star {α : Type u} {β : Type v} [topological_space α] [semi_normed_group β] [star_add_monoid β] [normed_star_group β] (f : bounded_continuous_function α β) : ⇑(has_star.star f) = has_star.star ⇑f
theorem clifford_algebra_complex.reverse_apply (x : clifford_algebra clifford_algebra_complex.Q) : ⇑clifford_algebra.reverse x = x
theorem convex.strict_mono_on_of_deriv_pos {D : set ℝ} (hD : convex ℝ D) {f : ℝ → ℝ} (hf : continuous_on f D) (hf' : ∀ (x : ℝ), x ∈ interior D → 0 < deriv f x) : strict_mono_on f D
theorem Top.is_topological_basis_cofiltered_limit {J : Type v} [category_theory.small_category J] [category_theory.is_cofiltered J] (F : J ⥤ Top) (C : category_theory.limits.cone F) (hC : category_theory.limits.is_limit C) (T : Π (j : J), set (set ↥(F.obj j))) (hT : ∀ (j : J), topological_space.is_topological_basis (T j)) (univ : ∀ (i : J), set.univ ∈ T i) (inter : ∀ (i : J) (U1 U2 : set ↥(F.obj i)), U1 ∈ T i → U2 ∈ T i → U1 ∩ U2 ∈ T i) (compat : ∀ (i j : J) (f : i ⟶ j) (V : set ↥(F.obj j)), V ∈ T j → ⇑(F.map f) ⁻¹' V ∈ T i) : topological_space.is_topological_basis {U : set ↥(C.X) | ∃ (j : J) (V : set ↥(F.obj j)), V ∈ T j ∧ U = ⇑(C.π.app j) ⁻¹' V}
theorem maximal_orthonormal_iff_basis_of_finite_dimensional {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {v : set E} [finite_dimensional 𝕜 E] (hv : orthonormal 𝕜 coe) : (∀ (u : set E), u ⊇ v → orthonormal 𝕜 coe → u = v) ↔ ∃ (b : basis ↥v 𝕜 E), ⇑b = coe
theorem linear_ordered_comm_group_with_zero.nhds_of_ne_zero {Γ₀ : Type u_1} [linear_ordered_comm_group_with_zero Γ₀] (γ : Γ₀) (h : γ ≠ 0) : nhds γ = has_pure.pure γ
theorem finset.prod_one_sub_ordered {ι : Type u_1} {R : Type u_2} [comm_ring R] [linear_order ι] (s : finset ι) (f : ι → R) : s.prod (λ (i : ι), 1 - f i) = 1 - s.sum (λ (i : ι), f i * (finset.filter (λ (_x : ι), _x < i) s).prod (λ (j : ι), 1 - f j))
theorem category_theory.inv_counit_map {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {L : C ⥤ D} {R : D ⥤ C} (h : L ⊣ R) {X : D} [category_theory.is_iso (h.counit.app X)] : category_theory.inv (R.map (h.counit.app X)) = h.unit.app (R.obj X)
theorem circle_integral.integral_eq_zero_of_has_deriv_within_at {E : Type u_1} [normed_group E] [normed_space ℂ E] [complete_space E] {f f' : ℂ → E} {c : ℂ} {R : ℝ} (hR : 0 ≤ R) (h : ∀ (z : ℂ), z ∈ metric.sphere c R → has_deriv_within_at f (f' z) (metric.sphere c R) z) : ∮ (z : ℂ) in C(c, R), f' z = 0
theorem category_theory.limits.has_pullbacks_of_has_limit_cospan (C : Type u) [category_theory.category C] [∀ {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z}, category_theory.limits.has_limit (category_theory.limits.cospan f g)] : category_theory.limits.has_pullbacks C
theorem nat.desc_factorial_eq_div {n k : ℕ} (h : k ≤ n) : n.desc_factorial k = n.factorial / (n - k).factorial
theorem finset.sum_powerset_insert {α : Type u} {β : Type v} [decidable_eq α] [add_comm_monoid β] {s : finset α} {x : α} (h : x ∉ s) (f : finset α → β) : (has_insert.insert x s).powerset.sum (λ (a : finset α), f a) = s.powerset.sum (λ (a : finset α), f a) + s.powerset.sum (λ (t : finset α), f (has_insert.insert x t))
theorem metric.inductive_limit_dist_eq_dist {X : ℕ → Type u} [Π (n : ℕ), metric_space (X n)] {f : Π (n : ℕ), X n → X (n + 1)} (I : ∀ (n : ℕ), isometry (f n)) (x y : Σ (n : ℕ), X n) (m : ℕ) (hx : x.fst ≤ m) (hy : y.fst ≤ m) : metric.inductive_limit_dist f x y = has_dist.dist (nat.le_rec_on hx f x.snd) (nat.le_rec_on hy f y.snd)
theorem abs_inner_eq_norm_iff {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) (hx0 : x ≠ 0) (hy0 : y ≠ 0) : is_R_or_C.abs (has_inner.inner x y) = ∥x∥ * ∥y∥ ↔ ∃ (r : 𝕜), r ≠ 0 ∧ y = r • x
theorem finset.mem_shadow_iff_insert_mem {α : Type u_1} [decidable_eq α] {𝒜 : finset (finset α)} {s : finset α} : s ∈ 𝒜.shadow ↔ ∃ (a : α) (H : a ∉ s), has_insert.insert a s ∈ 𝒜
theorem category_theory.abelian.pseudoelement.apply_zero {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P ⟶ Q) : ⇑f 0 = 0
theorem is_group_hom.comp {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) {γ : Type u_1} [group γ] {g : β → γ} (hg : is_group_hom g) : is_group_hom (g ∘ f)
theorem multilinear_map.map_sum_finset {R : Type u} {ι : Type u'} {M₁ : ι → Type v₁} {M₂ : Type v₂} [decidable_eq ι] [semiring R] [Π (i : ι), add_comm_monoid (M₁ i)] [add_comm_monoid M₂] [Π (i : ι), module R (M₁ i)] [module R M₂] (f : multilinear_map R M₁ M₂) {α : ι → Type u_1} (g : Π (i : ι), α i → M₁ i) (A : Π (i : ι), finset (α i)) [fintype ι] : ⇑f (λ (i : ι), (A i).sum (λ (j : α i), g i j)) = (fintype.pi_finset A).sum (λ (r : Π (a : ι), α a), ⇑f (λ (i : ι), g i (r i)))
theorem linear_ordered_comm_group_with_zero.nhds_fun_ok (Γ₀ : Type u_1) [linear_ordered_comm_group_with_zero Γ₀] (x : Γ₀) {s : set Γ₀} (s_in : s ∈ linear_ordered_comm_group_with_zero.nhds_fun Γ₀ x) : ∃ (t : set Γ₀) (H : t ∈ linear_ordered_comm_group_with_zero.nhds_fun Γ₀ x), t ⊆ s ∧ ∀ (y : Γ₀), y ∈ t → s ∈ linear_ordered_comm_group_with_zero.nhds_fun Γ₀ y
theorem convex.add_smul_sub_mem_interior' {E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) {x y : E} (hx : x ∈ closure s) (hy : y ∈ interior s) {t : 𝕜} (ht : t ∈ set.Ioc 0 1) : x + t • (y - x) ∈ interior s
theorem is_fraction_ring.comap_is_algebraic_iff {A : Type u_4} {K : Type u_5} {C : Type u_6} [comm_ring A] [is_domain A] [field K] [algebra A K] [is_fraction_ring A K] [comm_ring C] [algebra A C] [algebra K C] [is_scalar_tower A K C] : algebra.is_algebraic A C ↔ algebra.is_algebraic K C
theorem measure_theory.is_fundamental_domain.ess_sup_measure_restrict {G : Type u_1} {α : Type u_2} [group G] [mul_action G α] [measurable_space α] {s : set α} {μ : measure_theory.measure α} [measurable_space G] [has_measurable_smul G α] [measure_theory.smul_invariant_measure G α μ] [encodable G] (hs : measure_theory.is_fundamental_domain G s μ) {f : α → ennreal} (hf : ∀ (γ : G) (x : α), f (γ • x) = f x) : ess_sup f (μ.restrict s) = ess_sup f μ
theorem polynomial.C_leading_coeff_mul_prod_multiset_X_sub_C {K : Type u_1} [comm_ring K] [is_domain K] {p : polynomial K} (hroots : ⇑multiset.card p.roots = p.nat_degree) : ⇑polynomial.C p.leading_coeff * (multiset.map (λ (a : K), polynomial.X - ⇑polynomial.C a) p.roots).prod = p
theorem monotone.inf {α : Type u} {β : Type v} [preorder α] [semilattice_inf β] {f g : α → β} (hf : monotone f) (hg : monotone g) : monotone (f ⊓ g)
theorem rel_supr_tsum {α : Type u_1} {β : Type u_2} {γ : Type u_3} [add_comm_monoid α] [topological_space α] [t2_space α] [encodable γ] [complete_lattice β] (m : β → α) (m0 : m ⊥ = 0) (R : α → α → Prop) (m_supr : ∀ (s : ℕ → β), R (m (⨆ (i : ℕ), s i)) (∑' (i : ℕ), m (s i))) (s : γ → β) : R (m (⨆ (b : γ), s b)) (∑' (b : γ), m (s b))
theorem category_theory.limits.is_colimit.hom_is_iso {J : Type u₁} [category_theory.category J] {C : Type u₃} [category_theory.category C] {F : J ⥤ C} {s t : category_theory.limits.cocone F} (P : category_theory.limits.is_colimit s) (Q : category_theory.limits.is_colimit t) (f : s ⟶ t) : category_theory.is_iso f
theorem metric.emetric_closed_ball_nnreal {α : Type u} [pseudo_metric_space α] {x : α} {ε : nnreal} : emetric.closed_ball x ↑ε = metric.closed_ball x ↑ε
theorem affine_subspace.affine_span_eq_Inf (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s : set P) : affine_span k s = has_Inf.Inf {s' : affine_subspace k P | s ⊆ ↑s'}
theorem matrix.is_hermitian_iff_is_self_adjoint {α : Type u_1} {n : Type u_4} [is_R_or_C α] [fintype n] [decidable_eq n] {A : matrix n n α} : A.is_hermitian ↔ inner_product_space.is_self_adjoint (⇑((pi_Lp.linear_equiv α (λ (_x : n), α)).symm.conj) (⇑matrix.to_lin' A))
theorem uniform_space.completion.dist_eq {α : Type u} [pseudo_metric_space α] (x y : α) : has_dist.dist ↑x ↑y = has_dist.dist x y
theorem well_founded.game_add {α : Type u_1} {β : Type u_2} {rα : α → α → Prop} {rβ : β → β → Prop} (hα : well_founded rα) (hβ : well_founded rβ) : well_founded (relation.game_add rα rβ)
theorem probability_theory.indep_fun.variance_sum {Ω : Type u_1} [measure_theory.measure_space Ω] [measure_theory.is_probability_measure measure_theory.measure_space.volume] {ι : Type u_2} {X : ι → Ω → ℝ} {s : finset ι} (hs : ∀ (i : ι), i ∈ s → measure_theory.mem_ℒp (X i) 2 measure_theory.measure_space.volume) (h : ↑s.pairwise (λ (i j : ι), probability_theory.indep_fun (X i) (X j) measure_theory.measure_space.volume)) : probability_theory.variance (s.sum (λ (i : ι), X i)) measure_theory.measure_space.volume = s.sum (λ (i : ι), probability_theory.variance (X i) measure_theory.measure_space.volume)
theorem is_integral_leading_coeff_smul {R : Type u_1} {S : Type u_4} [comm_ring R] [comm_ring S] (p : polynomial R) (x : S) [algebra R S] (h : ⇑(polynomial.aeval x) p = 0) : is_integral R (p.leading_coeff • x)
theorem polynomial.prod_cyclotomic_eq_X_pow_sub_one {n : ℕ} (hpos : 0 < n) (R : Type u_1) [comm_ring R] : n.divisors.prod (λ (i : ℕ), polynomial.cyclotomic i R) = polynomial.X ^ n - 1
theorem matrix.pivot.exists_is_two_block_diagonal_list_transvec_mul_mul_list_transvec {𝕜 : Type u_3} [field 𝕜] {r : ℕ} (M : matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜) : ∃ (L L' : list (matrix.transvection_struct (fin r ⊕ unit) 𝕜)), (((list.map matrix.transvection_struct.to_matrix L).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L').prod).is_two_block_diagonal
theorem centroid_mem_affine_span_of_cast_card_ne_zero {k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} {s : finset ι} (p : ι → P) (h : ↑(s.card) ≠ 0) : finset.centroid k s p ∈ affine_span k (set.range p)
theorem finpartition.is_partition_parts {α : Type u_1} (f : finpartition set.univ) : setoid.is_partition ↑(f.parts)
theorem is_primitive_root.is_roots_of_minpoly {n : ℕ} {K : Type u_8} [field K] {μ : K} (h : is_primitive_root μ n) [char_zero K] : primitive_roots n K ⊆ (polynomial.map (int.cast_ring_hom K) (minpoly ℤ μ)).roots.to_finset
theorem fin.tail_init_eq_init_tail {n : ℕ} {β : Type u_1} (q : fin (n + 2) → β) : fin.tail (fin.init q) = fin.init (fin.tail q)
theorem circle_deg1_lift.translation_number_of_eq_add_int (f : circle_deg1_lift) {x : ℝ} {m : ℤ} (h : ⇑f x = x + ↑m) : f.translation_number = ↑m
theorem measure_theory.map_prod_inv_mul_eq {G : Type u_1} [measurable_space G] [group G] [has_measurable_mul₂ G] (μ ν : measure_theory.measure G) [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] [has_measurable_inv G] [ν.is_mul_left_invariant] : measure_theory.measure.map (λ (z : G × G), (z.fst, (z.fst)⁻¹ * z.snd)) (μ.prod ν) = μ.prod ν
theorem has_deriv_at_exp_zero {𝕂 : Type u_1} [is_R_or_C 𝕂] : has_deriv_at (exp 𝕂) 1 0
theorem cauchy_seq_tendsto_of_complete {α : Type u} {β : Type v} [uniform_space α] [semilattice_sup β] [complete_space α] {u : β → α} (H : cauchy_seq u) : ∃ (x : α), filter.tendsto u filter.at_top (nhds x)
theorem euclidean_geometry.mul_dist_eq_abs_sub_sq_dist {V : Type u_1} [inner_product_space ℝ V] {P : Type u_2} [metric_space P] [normed_add_torsor V P] {a b p q : P} (hp : ∃ (k : ℝ), k ≠ 1 ∧ b -ᵥ p = k • (a -ᵥ p)) (hq : has_dist.dist a q = has_dist.dist b q) : has_dist.dist a p * has_dist.dist b p = |has_dist.dist b q ^ 2 - has_dist.dist p q ^ 2|
theorem interval_integral.interval_integrable_rpow' {a b r : ℝ} (h : -1 < r) : interval_integrable (λ (x : ℝ), x ^ r) measure_theory.measure_space.volume a b
theorem matrix.is_hermitian.spectral_theorem {𝕜 : Type u_1} [is_R_or_C 𝕜] [decidable_eq 𝕜] {n : Type u_2} [fintype n] [decidable_eq n] {A : matrix n n 𝕜} (hA : A.is_hermitian) : hA.eigenvector_matrix_inv.mul A = (matrix.diagonal (coe ∘ hA.eigenvalues)).mul hA.eigenvector_matrix_inv
theorem simple_graph.exists_minimal_degree_vertex {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [nonempty V] : ∃ (v : V), G.min_degree = G.degree v
theorem add_commute.add_right {S : Type u_1} [add_semigroup S] {a b c : S} (hab : add_commute a b) (hac : add_commute a c) : add_commute a (b + c)
theorem list.sublist_iff_exists_fin_order_embedding_nth_le_eq {α : Type u_1} {l l' : list α} : l <+ l' ↔ ∃ (f : fin l.length ↪o fin l'.length), ∀ (ix : fin l.length), l.nth_le ↑ix _ = l'.nth_le ↑(⇑f ix) _
theorem algebraic_geometry.local_ring_hom_comp_stalk_iso {R S : CommRing} (f : R ⟶ S) (p : prime_spectrum ↥S) : (algebraic_geometry.structure_sheaf.stalk_iso ↥R (⇑(prime_spectrum.comap f) p)).hom ≫ localization.local_ring_hom (⇑(prime_spectrum.comap f) p).as_ideal p.as_ideal f rfl ≫ (algebraic_geometry.structure_sheaf.stalk_iso ↥S p).inv = algebraic_geometry.PresheafedSpace.stalk_map (algebraic_geometry.Spec.SheafedSpace_map f) p
theorem polynomial.smul_mem_lifts {R : Type u} [comm_semiring R] {S : Type v} [semiring S] [algebra R S] {p : polynomial S} (r : R) (hp : p ∈ polynomial.lifts (algebra_map R S)) : r • p ∈ polynomial.lifts (algebra_map R S)
theorem list_sum_mem {M : Type u_1} {B : Type u_3} [add_monoid M] [set_like B M] [add_submonoid_class B M] {S : B} {l : list M} (hl : ∀ (x : M), x ∈ l → x ∈ S) : l.sum ∈ S
theorem box_integral.integrable.dist_integral_sum_sum_integral_le_of_mem_base_set_of_Union_eq {ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} {π : box_integral.tagged_prepartition I} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} {c : nnreal} {ε : ℝ} [complete_space F] (h : box_integral.integrable I l f vol) (h0 : 0 < ε) (hπ : l.mem_base_set I c (h.convergence_r ε c) π) {π₀ : box_integral.prepartition I} (hU : π.Union = π₀.Union) : has_dist.dist (box_integral.integral_sum f vol π) (π₀.boxes.sum (λ (J : box_integral.box ι), box_integral.integral J l f vol)) ≤ ε
theorem topological_vector_bundle.trivialization.coord_change_apply' {R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B → Type u_5} [semiring R] [Π (x : B), add_comm_monoid (E x)] [Π (x : B), module R (E x)] [topological_space F] [add_comm_monoid F] [module R F] [topological_space B] [topological_space (bundle.total_space E)] (e e' : topological_vector_bundle.trivialization R F E) {b : B} (hb : b ∈ e.to_fiber_bundle_trivialization.base_set ∩ e'.to_fiber_bundle_trivialization.base_set) (y : F) : ⇑(e.coord_change e' b) y = (⇑e' (⇑(e.to_fiber_bundle_trivialization.to_local_homeomorph.symm) (b, y))).snd
theorem real.sinh_surjective  : function.surjective real.sinh
theorem mem_residual {α : Type u_1} [topological_space α] [baire_space α] {s : set α} : s ∈ residual α ↔ ∃ (t : set α) (H : t ⊆ s), is_Gδ t ∧ dense t
theorem multilinear_map.zero_comp_linear_map {R : Type u} {ι : Type u'} {M₁ : ι → Type v₁} {M₂ : Type v₂} [decidable_eq ι] [semiring R] [Π (i : ι), add_comm_monoid (M₁ i)] [add_comm_monoid M₂] [Π (i : ι), module R (M₁ i)] [module R M₂] {M₁' : ι → Type u_1} [Π (i : ι), add_comm_monoid (M₁' i)] [Π (i : ι), module R (M₁' i)] (f : Π (i : ι), M₁ i →ₗ[R] M₁' i) : 0.comp_linear_map f = 0
theorem le_nhds_iff {α : Type u} [topological_space α] {f : filter α} {a : α} : f ≤ nhds a ↔ ∀ (s : set α), a ∈ s → is_open s → s ∈ f
theorem polynomial.expand_injective {R : Type u} [comm_semiring R] {n : ℕ} (hn : 0 < n) : function.injective ⇑(polynomial.expand R n)
theorem tactic.ring_exp.prod_congr {α : Type u} [comm_semiring α] {p p' ps ps' : α} : p = p' → ps = ps' → p * ps = p' * ps'
theorem matrix.circulant_is_symm_iff {α : Type u_1} {n : Type u_4} [add_group n] {v : n → α} : (matrix.circulant v).is_symm ↔ ∀ (i : n), v (-i) = v i
theorem iterated_fderiv_apply_eq_iterated_deriv_mul_prod {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {n : ℕ} {f : 𝕜 → F} {x : 𝕜} {m : fin n → 𝕜} : ⇑(iterated_fderiv 𝕜 n f x) m = finset.univ.prod (λ (i : fin n), m i) • iterated_deriv n f x
theorem same_ray_iff_norm_add {E : Type u_2} [normed_group E] [normed_space ℝ E] [strict_convex_space ℝ E] {x y : E} : same_ray ℝ x y ↔ ∥x + y∥ = ∥x∥ + ∥y∥
theorem ideal.mem_quotient_iff_mem_sup {R : Type u_1} [comm_ring R] {I J : ideal R} {x : R} : ⇑(ideal.quotient.mk I) x ∈ ideal.map (ideal.quotient.mk I) J ↔ x ∈ J ⊔ I
theorem category_theory.limits.biprod.cone_point_unique_up_to_iso_inv {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) [category_theory.limits.has_binary_biproduct X Y] {b : category_theory.limits.binary_bicone X Y} (hb : b.is_bilimit) : (hb.is_limit.cone_point_unique_up_to_iso (category_theory.limits.binary_biproduct.is_limit X Y)).inv = category_theory.limits.biprod.desc b.inl b.inr
theorem add_con.ext'_iff {M : Type u_1} [has_add M] {c d : add_con M} : setoid.r = setoid.r ↔ c = d
theorem con.Sup_def {M : Type u_1} [has_mul M] {S : set (con M)} : has_Sup.Sup S = con_gen (has_Sup.Sup (coe_fn '' S))
theorem multilinear_map.cons_smul {R : Type u} {n : ℕ} {M : fin n.succ → Type v} {M₂ : Type v₂} [semiring R] [Π (i : fin n.succ), add_comm_monoid (M i)] [add_comm_monoid M₂] [Π (i : fin n.succ), module R (M i)] [module R M₂] (f : multilinear_map R M M₂) (m : Π (i : fin n), M i.succ) (c : R) (x : M 0) : ⇑f (fin.cons (c • x) m) = c • ⇑f (fin.cons x m)
theorem category_theory.limits.is_colimit.hom_ext {J : Type u₁} [category_theory.category J] {C : Type u₃} [category_theory.category C] {F : J ⥤ C} {t : category_theory.limits.cocone F} (h : category_theory.limits.is_colimit t) {W : C} {f f' : t.X ⟶ W} (w : ∀ (j : J), t.ι.app j ≫ f = t.ι.app j ≫ f') : f = f'
theorem inner_product_geometry.norm_add_eq_add_norm_of_angle_eq_zero {V : Type u_1} [inner_product_space ℝ V] {x y : V} (h : inner_product_geometry.angle x y = 0) : ∥x + y∥ = ∥x∥ + ∥y∥
theorem nat.coprime_prod_right {ι : Type u_1} {x : ℕ} {s : ι → ℕ} {t : finset ι} : (∀ (i : ι), i ∈ t → x.coprime (s i)) → x.coprime (t.prod (λ (i : ι), s i))
theorem nat.cast_le_pow_sub_div_sub {K : Type u_1} [linear_ordered_field K] {a : K} (H : 1 < a) (n : ℕ) : ↑n ≤ (a ^ n - 1) / (a - 1)
theorem omega_complete_partial_order.continuous_hom.forall_forall_merge {α : Type u} {β : Type v} [omega_complete_partial_order α] [omega_complete_partial_order β] (c₀ : omega_complete_partial_order.chain (α →𝒄 β)) (c₁ : omega_complete_partial_order.chain α) (z : β) : (∀ (i j : ℕ), ⇑(⇑c₀ i) (⇑c₁ j) ≤ z) ↔ ∀ (i : ℕ), ⇑(⇑c₀ i) (⇑c₁ i) ≤ z
theorem function.id_le_iterate_of_id_le {α : Type u_1} [preorder α] {f : α → α} (h : id ≤ f) (n : ℕ) : id ≤ (f^[n])
theorem concave_on.exists_le_of_center_mass {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} {ι : Type u_5} [linear_ordered_field 𝕜] [add_comm_group E] [linear_ordered_add_comm_group β] [module 𝕜 E] [module 𝕜 β] [ordered_smul 𝕜 β] {s : set E} {f : E → β} {t : finset ι} {w : ι → 𝕜} {p : ι → E} (h : concave_on 𝕜 s f) (hw₀ : ∀ (i : ι), i ∈ t → 0 ≤ w i) (hw₁ : 0 < t.sum (λ (i : ι), w i)) (hp : ∀ (i : ι), i ∈ t → p i ∈ s) : ∃ (i : ι) (H : i ∈ t), f (p i) ≤ f (t.center_mass w p)
theorem cont_mdiff_on_of_mem_maximal_atlas {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {n : with_top ℕ} {e : local_homeomorph M H} (h : e ∈ smooth_manifold_with_corners.maximal_atlas I M) : cont_mdiff_on I I n ⇑e e.to_local_equiv.source
theorem measure_theory.strongly_measurable.ae_measurable {α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] [topological_space.pseudo_metrizable_space β] [measurable_space β] [borel_space β] {μ : measure_theory.measure α} (hf : measure_theory.strongly_measurable f) : ae_measurable f μ
theorem sub_nonpos_of_le {α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : a ≤ b → a - b ≤ 0
theorem affine_map.is_open_map_linear_iff {𝕜 : Type u_1} {V : Type u_2} {V₂ : Type u_4} {P : Type u_8} {P₂ : Type u_9} [normed_field 𝕜] [semi_normed_group V] [semi_normed_group V₂] [normed_space 𝕜 V] [normed_space 𝕜 V₂] [pseudo_metric_space P] [pseudo_metric_space P₂] [normed_add_torsor V P] [normed_add_torsor V₂ P₂] {f : P →ᵃ[𝕜] P₂} : is_open_map ⇑(f.linear) ↔ is_open_map ⇑f
theorem is_alg_closed.ring_equiv_of_cardinal_eq_of_char_zero {K L : Type} [field K] [field L] [is_alg_closed K] [is_alg_closed L] [char_zero K] [char_zero L] (hK : cardinal.aleph_0 < cardinal.mk K) (hKL : cardinal.mk K = cardinal.mk L) : K ≃+* L
theorem is_integral_localization_at_leading_coeff {R : Type u_1} [comm_ring R] {M : submonoid R} {S : Type u_2} [comm_ring S] [algebra R S] {Rₘ : Type u_4} {Sₘ : Type u_5} [comm_ring Rₘ] [comm_ring Sₘ] [algebra R Rₘ] [is_localization M Rₘ] [algebra S Sₘ] [is_localization (algebra.algebra_map_submonoid S M) Sₘ] {x : S} (p : polynomial R) (hp : ⇑(polynomial.aeval x) p = 0) (hM : p.leading_coeff ∈ M) : (is_localization.map Sₘ (algebra_map R S) _).is_integral_elem (⇑(algebra_map S Sₘ) x)
theorem has_subset.subset.ssubset_or_eq {α : Type u} [has_subset α] [has_ssubset α] [is_nonstrict_strict_order α has_subset.subset has_ssubset.ssubset] {a b : α} [is_antisymm α has_subset.subset] (h : a ⊆ b) : a ⊂ b ∨ a = b
theorem algebraic_geometry.SheafedSpace.is_open_immersion.of_stalk_iso {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] [category_theory.limits.has_limits C] [category_theory.limits.has_colimits C] [category_theory.concrete_category C] [category_theory.reflects_isomorphisms (category_theory.forget C)] [category_theory.limits.preserves_limits (category_theory.forget C)] [category_theory.limits.preserves_filtered_colimits (category_theory.forget C)] {X Y : algebraic_geometry.SheafedSpace C} (f : X ⟶ Y) (hf : open_embedding ⇑(f.base)) [H : ∀ (x : ↥X), category_theory.is_iso (algebraic_geometry.PresheafedSpace.stalk_map f x)] : algebraic_geometry.SheafedSpace.is_open_immersion f
theorem cont_diff_on.add {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : with_top ℕ} {s : set E} {f g : E → F} (hf : cont_diff_on 𝕜 n f s) (hg : cont_diff_on 𝕜 n g s) : cont_diff_on 𝕜 n (λ (x : E), f x + g x) s
theorem polynomial.int_coeff_of_cyclotomic' {K : Type u_1} [comm_ring K] [is_domain K] {ζ : K} {n : ℕ} (h : is_primitive_root ζ n) : ∃ (P : polynomial ℤ), polynomial.map (int.cast_ring_hom K) P = polynomial.cyclotomic' n K ∧ P.degree = (polynomial.cyclotomic' n K).degree ∧ P.monic
theorem prod.map_map {α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} {ε : Type u_5} {ζ : Type u_6} (f : α → β) (f' : γ → δ) (g : β → ε) (g' : δ → ζ) (x : α × γ) : prod.map g g' (prod.map f f' x) = prod.map (g ∘ f) (g' ∘ f') x
theorem fin.succ_above_left_inj {n : ℕ} {x y : fin (n + 1)} : x.succ_above = y.succ_above ↔ x = y
theorem is_closed_map_smul₀ {𝕜 : Type u_1} {M : Type u_2} [division_ring 𝕜] [add_comm_monoid M] [topological_space M] [t1_space M] [module 𝕜 M] [has_continuous_const_smul 𝕜 M] (c : 𝕜) : is_closed_map (λ (x : M), c • x)
theorem tendsto_of_liminf_eq_limsup {α : Type u} {β : Type v} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {f : filter β} {u : β → α} {a : α} (hinf : f.liminf u = a) (hsup : f.limsup u = a) (h : filter.is_bounded_under has_le.le f u . "is_bounded_default") (h' : filter.is_bounded_under ge f u . "is_bounded_default") : filter.tendsto u f (nhds a)
theorem submodule.inf_orthogonal {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K₁ K₂ : submodule 𝕜 E) : K₁ᗮ ⊓ K₂ᗮ = (K₁ ⊔ K₂)ᗮ
theorem vector.nth_cons_nil {α : Type u_1} {ix : fin 1} (x : α) : (x::ᵥvector.nil).nth ix = x
theorem measurable_space.cardinal_generate_measurable_rec_le {α : Type u} (s : set (set α)) (i : (quotient.out (cardinal.aleph 1).ord).α) : cardinal.mk ↥(measurable_space.generate_measurable_rec s i) ≤ linear_order.max (cardinal.mk ↥s) 2 ^ cardinal.aleph_0
theorem algebra.adjoin_induction' {R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] {s : set A} {p : ↥(algebra.adjoin R s) → Prop} (Hs : ∀ (x : A) (h : x ∈ s), p ⟨x, _⟩) (Halg : ∀ (r : R), p (⇑(algebra_map R ↥(algebra.adjoin R s)) r)) (Hadd : ∀ (x y : ↥(algebra.adjoin R s)), p x → p y → p (x + y)) (Hmul : ∀ (x y : ↥(algebra.adjoin R s)), p x → p y → p (x * y)) (x : ↥(algebra.adjoin R s)) : p x
theorem category_theory.adjunction.has_colimits_of_equivalence {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (E : C ⥤ D) [category_theory.is_equivalence E] [category_theory.limits.has_colimits_of_size D] : category_theory.limits.has_colimits_of_size C
theorem orientation.oangle_eq_iff_eq_pos_smul_rotation_of_ne_zero {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : real.angle) : o.oangle x y = θ ↔ ∃ (r : ℝ), 0 < r ∧ y = r • ⇑(o.rotation θ) x
theorem exists_has_deriv_at_eq_zero' {f f' : ℝ → ℝ} {a b l : ℝ} (hab : a < b) (hfa : filter.tendsto f (nhds_within a (set.Ioi a)) (nhds l)) (hfb : filter.tendsto f (nhds_within b (set.Iio b)) (nhds l)) (hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x) : ∃ (c : ℝ) (H : c ∈ set.Ioo a b), f' c = 0
theorem fermat_42.exists_odd_minimal {a b c : ℤ} (h : fermat_42 a b c) : ∃ (a0 b0 c0 : ℤ), fermat_42.minimal a0 b0 c0 ∧ a0 % 2 = 1
theorem rack.to_envel_group.map_aux.well_def {R : Type u_1} [rack R] {G : Type u_2} [group G] (f : shelf_hom R (quandle.conj G)) {a b : rack.pre_envel_group R} : rack.pre_envel_group_rel' R a b → rack.to_envel_group.map_aux f a = rack.to_envel_group.map_aux f b
theorem fintype.card_of_is_empty {α : Type u_1} [is_empty α] : fintype.card α = 0
theorem finset.weighted_vsub_of_point_insert {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) [decidable_eq ι] (w : ι → k) (p : ι → P) (i : ι) : ⇑((has_insert.insert i s).weighted_vsub_of_point p (p i)) w = ⇑(s.weighted_vsub_of_point p (p i)) w
theorem real_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two {F : Type u_3} [inner_product_space ℝ F] (x y : F) : has_inner.inner x y = (∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ - ∥x - y∥ * ∥x - y∥) / 2
theorem matrix.to_lin_eq_to_lin' {R : Type u_1} [comm_semiring R] {m : Type u_3} {n : Type u_4} [fintype n] [fintype m] [decidable_eq n] : matrix.to_lin (pi.basis_fun R n) (pi.basis_fun R m) = matrix.to_lin'
theorem odd.nat_abs {n : ℤ} : odd n → odd n.nat_abs
theorem power_basis.trace_gen_eq_next_coeff_minpoly {S : Type u_2} [comm_ring S] {K : Type u_4} [field K] [algebra K S] [nontrivial S] (pb : power_basis K S) : ⇑(algebra.trace K S) pb.gen = -(minpoly K pb.gen).next_coeff
theorem card_class_group_eq_one {R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_principal_ideal_ring R] : fintype.card (class_group R K) = 1
theorem pSet.equiv.eq {x y : pSet} : x.equiv y ↔ x.to_set = y.to_set
theorem ennreal.sum_eq_top_iff {α : Type u_1} {s : finset α} {f : α → ennreal} : s.sum (λ (x : α), f x) = ⊤ ↔ ∃ (a : α) (H : a ∈ s), f a = ⊤
theorem probability_theory.indep_fun.integral_mul_of_nonneg {α : Type u_1} {mα : measurable_space α} {μ : measure_theory.measure α} {X Y : α → ℝ} (hXY : probability_theory.indep_fun X Y μ) (hXp : 0 ≤ X) (hYp : 0 ≤ Y) (hXm : ae_measurable X μ) (hYm : ae_measurable Y μ) : measure_theory.integral μ (X * Y) = measure_theory.integral μ X * measure_theory.integral μ Y
theorem convex_on.set_average_mem_epigraph {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {t : set α} {f : α → E} {g : E → ℝ} (hg : convex_on ℝ s g) (hgc : continuous_on g s) (hsc : is_closed s) (h0 : ⇑μ t ≠ 0) (ht : ⇑μ t ≠ ⊤) (hfs : ∀ᵐ (x : α) ∂μ.restrict t, f x ∈ s) (hfi : measure_theory.integrable_on f t μ) (hgi : measure_theory.integrable_on (g ∘ f) t μ) : (⨍ (x : α) in t, f x ∂μ, ⨍ (x : α) in t, g (f x) ∂μ) ∈ {p : E × ℝ | p.fst ∈ s ∧ g p.fst ≤ p.snd}
theorem filter.tendsto.neg_mul_at_top {α : Type u} {β : Type v} [linear_ordered_field α] [topological_space α] [order_topology α] {l : filter β} {f g : β → α} {C : α} (hC : C < 0) (hf : filter.tendsto f l (nhds C)) (hg : filter.tendsto g l filter.at_top) : filter.tendsto (λ (x : β), f x * g x) l filter.at_bot
theorem measure_theory.lintegral_le_of_forall_fin_meas_le {α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} [measure_theory.sigma_finite μ] (C : ennreal) {f : α → ennreal} (hf_meas : ae_measurable f μ) (hf : ∀ (s : set α), measurable_set s → ⇑μ s ≠ ⊤ → ∫⁻ (x : α) in s, f x ∂μ ≤ C) : ∫⁻ (x : α), f x ∂μ ≤ C
theorem units.is_regular {R : Type u_1} [monoid R] (a : Rˣ) : is_regular ↑a
theorem not_covby {α : Type u_1} [has_lt α] {a b : α} [densely_ordered α] : ¬a ⋖ b
theorem category_theory.cosimplicial_object.δ_comp_σ_self {C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) {n : ℕ} {i : fin (n + 1)} : X.δ (⇑fin.cast_succ i) ≫ X.σ i = 𝟙 (X.obj (simplex_category.mk n))
theorem lie_ideal.comap_bracket_incl_of_le {R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (I : lie_ideal R L) {I₁ I₂ : lie_ideal R L} (h₁ : I₁ ≤ I) (h₂ : I₂ ≤ I) : ⁅lie_ideal.comap I.incl I₁,lie_ideal.comap I.incl I₂⁆ = lie_ideal.comap I.incl ⁅I₁,I₂⁆
theorem euclidean_geometry.orthogonal_projection_linear {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} [nonempty ↥s] [complete_space ↥(s.direction)] : (euclidean_geometry.orthogonal_projection s).linear = ↑(orthogonal_projection s.direction)
theorem is_compact_sphere {α : Type u_1} [pseudo_metric_space α] [proper_space α] (x : α) (r : ℝ) : is_compact (metric.sphere x r)
theorem add_con.inf_def {M : Type u_1} [has_add M] {c d : add_con M} : setoid.r = setoid.r ⊓ setoid.r
theorem con.zpow {M : Type u_1} [group M] (c : con M) (n : ℤ) {w x : M} : ⇑c w x → ⇑c (w ^ n) (x ^ n)
theorem measure_theory.tendsto_integral_filter_of_dominated_convergence {α : Type u_1} {E : Type u_2} [normed_group E] [normed_space ℝ E] [complete_space E] {m : measurable_space α} {μ : measure_theory.measure α} {ι : Type u_3} {l : filter ι} [l.is_countably_generated] {F : ι → α → E} {f : α → E} (bound : α → ℝ) (hF_meas : ∀ᶠ (n : ι) in l, measure_theory.ae_strongly_measurable (F n) μ) (h_bound : ∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, ∥F n a∥ ≤ bound a) (bound_integrable : measure_theory.integrable bound μ) (h_lim : ∀ᵐ (a : α) ∂μ, filter.tendsto (λ (n : ι), F n a) l (nhds (f a))) : filter.tendsto (λ (n : ι), ∫ (a : α), F n a ∂μ) l (nhds (∫ (a : α), f a ∂μ))
theorem mem_nhds_within_Ioi_iff_exists_Ioc_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_max_order α] [densely_ordered α] {a : α} {s : set α} : s ∈ nhds_within a (set.Ioi a) ↔ ∃ (u : α) (H : u ∈ set.Ioi a), set.Ioc a u ⊆ s
theorem finset.card_insert_eq_ite {α : Type u_1} {s : finset α} {a : α} [decidable_eq α] : (has_insert.insert a s).card = ite (a ∈ s) s.card (s.card + 1)
theorem neg_ray_of_ne_zero (R : Type u_1) [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (v : M) (h : v ≠ 0) : -ray_of_ne_zero R v h = ray_of_ne_zero R (-v) _
theorem isometry.diam_image {α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {f : α → β} (hf : isometry f) (s : set α) : metric.diam (f '' s) = metric.diam s
theorem subfield.sub_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x - y ∈ s
theorem mv_polynomial.C_dvd_iff_zmod {σ : Type u_1} (n : ℕ) (φ : mv_polynomial σ ℤ) : ⇑mv_polynomial.C ↑n ∣ φ ↔ ⇑(mv_polynomial.map (int.cast_ring_hom (zmod n))) φ = 0
theorem char.quadratic_char_one_iff_is_square {F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0) : char.quadratic_char F a = 1 ↔ is_square a
theorem is_add_unit.is_add_regular {R : Type u_1} {a : R} [add_monoid R] (ua : is_add_unit a) : is_add_regular a
theorem intermediate_value_Icc {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {δ : Type u_1} [linear_order δ] [topological_space δ] [order_closed_topology δ] {a b : α} (hab : a ≤ b) {f : α → δ} (hf : continuous_on f (set.Icc a b)) : set.Icc (f a) (f b) ⊆ f '' set.Icc a b
theorem list.head_le_sum (L : list ℕ) : L.head ≤ L.sum
theorem set.image_image2_right_comm {α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {s : set α} {t : set β} {f : α → β' → γ} {g : β → β'} {f' : α → β → δ} {g' : δ → γ} (h_right_comm : ∀ (a : α) (b : β), f a (g b) = g' (f' a b)) : set.image2 f s (g '' t) = g' '' set.image2 f' s t
theorem module.End.eigenspace_restrict_le_eigenspace {R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) {p : submodule R M} (hfp : ∀ (x : M), x ∈ p → ⇑f x ∈ p) (μ : R) : submodule.map p.subtype (module.End.eigenspace (linear_map.restrict f hfp) μ) ≤ f.eigenspace μ
theorem is_submonoid_Union_of_directed {M : Type u_1} [monoid M] {ι : Type u_2} [hι : nonempty ι] {s : ι → set M} (hs : ∀ (i : ι), is_submonoid (s i)) (directed : ∀ (i j : ι), ∃ (k : ι), s i ⊆ s k ∧ s j ⊆ s k) : is_submonoid (⋃ (i : ι), s i)
theorem filter.tendsto.op_zero_is_bounded_under_le {α : Type u_1} {E : Type u_3} {F : Type u_4} {G : Type u_5} [semi_normed_group E] [semi_normed_group F] [semi_normed_group G] {f : α → E} {g : α → F} {l : filter α} (hf : filter.tendsto f l (nhds 0)) (hg : filter.is_bounded_under has_le.le l (has_norm.norm ∘ g)) (op : E → F → G) (h_op : ∀ (x : E) (y : F), ∥op x y∥ ≤ ∥x∥ * ∥y∥) : filter.tendsto (λ (x : α), op (f x) (g x)) l (nhds 0)
theorem has_deriv_within_at.liminf_right_slope_norm_le {E : Type u} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {f' : E} {x r : ℝ} (hf : has_deriv_within_at f f' (set.Ici x) x) (hr : ∥f'∥ < r) : ∃ᶠ (z : ℝ) in nhds_within x (set.Ioi x), (z - x)⁻¹ * (∥f z∥ - ∥f x∥) < r
theorem algebraic_geometry.PresheafedSpace.glue_data.f_inv_app_f_app {C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) (i j k : D.to_glue_data.J) (U : topological_space.opens ↥((D.to_glue_data.V (i, j)).carrier)) : _.inv_app U ≫ (D.to_glue_data.f i k).c.app (opposite.op (_.open_functor.obj U)) = category_theory.limits.pullback.fst.c.app (opposite.op U) ≫ _.inv_app (opposite.unop ((topological_space.opens.map category_theory.limits.pullback.fst.base).op.obj (opposite.op U))) ≫ (D.to_glue_data.V (i, k)).presheaf.map (category_theory.eq_to_hom _)
theorem add_submonoid.closure_le {M : Type u_1} [add_zero_class M] {s : set M} {S : add_submonoid M} : add_submonoid.closure s ≤ S ↔ s ⊆ ↑S
theorem asymptotics.is_O.of_norm_left {α : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : α → F} {f' : α → E'} {l : filter α} : (λ (x : α), ∥f' x∥) =O[l] g → f' =O[l] g
theorem same_ray_map_iff {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] {x y : M} (e : M ≃ₗ[R] N) : same_ray R (⇑e x) (⇑e y) ↔ same_ray R x y
theorem with_top.sum_lt_top {ι : Type u_1} {M : Type u_4} [ordered_add_comm_monoid M] {s : finset ι} {f : ι → with_top M} (h : ∀ (i : ι), i ∈ s → f i ≠ ⊤) : s.sum (λ (i : ι), f i) < ⊤
theorem exists_lt_of_cInf_lt {α : Type u_1} [conditionally_complete_linear_order α] {s : set α} {b : α} (hs : s.nonempty) (hb : has_Inf.Inf s < b) : ∃ (a : α) (H : a ∈ s), a < b
theorem contracting_with.restrict {α : Type u_1} [emetric_space α] {K : nnreal} {f : α → α} (hf : contracting_with K f) {s : set α} (hs : set.maps_to f s s) : contracting_with K (set.maps_to.restrict f s s hs)
theorem set.finite.compact_convex_hull {E : Type u_2} [add_comm_group E] [module ℝ E] [topological_space E] [topological_add_group E] [has_continuous_smul ℝ E] {s : set E} (hs : s.finite) : is_compact (⇑(convex_hull ℝ) s)
theorem subgroup.closure_mul_image_eq {G : Type u_1} [group G] {H : subgroup G} {R S : set G} (hR : R ∈ subgroup.right_transversals ↑H) (hR1 : 1 ∈ R) (hS : subgroup.closure S = ⊤) : subgroup.closure ((λ (g : G), g * (↑(subgroup.mem_right_transversals.to_fun hR g))⁻¹) '' (R * S)) = H
theorem metric.second_countable_of_almost_dense_set {α : Type u} [pseudo_metric_space α] (H : ∀ (ε : ℝ), ε > 0 → (∃ (s : set α), s.countable ∧ ∀ (x : α), ∃ (y : α) (H : y ∈ s), has_dist.dist x y ≤ ε)) : topological_space.second_countable_topology α
theorem interval_integral.integral_has_fderiv_within_at_of_tendsto_ae {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {ca cb : E} {la lb : filter ℝ} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set ℝ} [interval_integral.FTC_filter a (nhds_within a s) la] [interval_integral.FTC_filter b (nhds_within b t) lb] (hmeas_a : strongly_measurable_at_filter f la measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f lb measure_theory.measure_space.volume) (ha : filter.tendsto f (la ⊓ measure_theory.measure_space.volume.ae) (nhds ca)) (hb : filter.tendsto f (lb ⊓ measure_theory.measure_space.volume.ae) (nhds cb)) : has_fderiv_within_at (λ (p : ℝ × ℝ), ∫ (x : ℝ) in p.fst..p.snd, f x) ((continuous_linear_map.snd ℝ ℝ ℝ).smul_right cb - (continuous_linear_map.fst ℝ ℝ ℝ).smul_right ca) (s ×ˢ t) (a, b)
theorem vector.scanl_nth {n : ℕ} {α : Type u_1} {β : Type u_2} (f : β → α → β) (b : β) (v : vector α n) (i : fin n) : (vector.scanl f b v).nth i.succ = f ((vector.scanl f b v).nth (⇑fin.cast_succ i)) (v.nth i)
theorem normed_space.dual.dual_norm_topology_le_weak_dual_topology {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [semi_normed_group E] [normed_space 𝕜 E] : uniform_space.to_topological_space ≤ weak_dual.topological_space 𝕜 E
theorem cont_diff_on_top_iff_fderiv_within {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} (hs : unique_diff_on 𝕜 s) : cont_diff_on 𝕜 ⊤ f s ↔ differentiable_on 𝕜 f s ∧ cont_diff_on 𝕜 ⊤ (λ (y : E), fderiv_within 𝕜 f s y) s
theorem is_ring_hom.map_zero {α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (hf : is_ring_hom f) : f 0 = 0
theorem convex.average_mem_interior_of_set {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {t : set α} {f : α → E} [measure_theory.is_finite_measure μ] (hs : convex ℝ s) (h0 : ⇑μ t ≠ 0) (hfs : ∀ᵐ (x : α) ∂μ, f x ∈ s) (hfi : measure_theory.integrable f μ) (ht : ⨍ (x : α) in t, f x ∂μ ∈ interior s) : ⨍ (x : α), f x ∂μ ∈ interior s
theorem monoid_hom.eq_on_closure {G : Type u_1} [group G] {N : Type u_3} [group N] {f g : G →* N} {s : set G} (h : set.eq_on ⇑f ⇑g s) : set.eq_on ⇑f ⇑g ↑(subgroup.closure s)
theorem alternating_map.dom_coprod.summand_eq_zero_of_smul_invariant {ιa : Type u_7} {ιb : Type u_8} [decidable_eq ιa] [decidable_eq ιb] [fintype ιa] [fintype ιb] {R' : Type u_9} {Mᵢ : Type u_10} {N₁ : Type u_11} {N₂ : Type u_12} [comm_semiring R'] [add_comm_group N₁] [module R' N₁] [add_comm_group N₂] [module R' N₂] [add_comm_monoid Mᵢ] [module R' Mᵢ] (a : alternating_map R' Mᵢ N₁ ιa) (b : alternating_map R' Mᵢ N₂ ιb) (σ : equiv.perm.mod_sum_congr ιa ιb) {v : ιa ⊕ ιb → Mᵢ} {i j : ιa ⊕ ιb} (hv : v i = v j) (hij : i ≠ j) : equiv.swap i j • σ = σ → ⇑(alternating_map.dom_coprod.summand a b σ) v = 0
theorem cinfi_eq_of_forall_ge_of_forall_gt_exists_lt {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {b : α} [nonempty ι] {f : ι → α} (h₁ : ∀ (i : ι), b ≤ f i) (h₂ : ∀ (w : α), b < w → (∃ (i : ι), f i < w)) : (⨅ (i : ι), f i) = b
theorem mul_action.card_orbit_mul_card_stabilizer_eq_card_group (α : Type u) {β : Type v} [group α] [mul_action α β] (b : β) [fintype α] [fintype ↥(mul_action.orbit α b)] [fintype ↥(mul_action.stabilizer α b)] : fintype.card ↥(mul_action.orbit α b) * fintype.card ↥(mul_action.stabilizer α b) = fintype.card α
theorem ennreal.mul_infi {ι : Sort u_1} [nonempty ι] {f : ι → ennreal} {x : ennreal} (h : x ≠ ⊤) : x * infi f = ⨅ (i : ι), x * f i
theorem matrix.cons_val_one {α : Type u} {m : ℕ} (x : α) (u : fin m.succ → α) : matrix.vec_cons x u 1 = matrix.vec_head u
theorem set.pairwise_disjoint.sup_indep {α : Type u_1} {ι : Type u_3} [distrib_lattice α] [order_bot α] {s : finset ι} {f : ι → α} : ↑s.pairwise_disjoint f → s.sup_indep f
theorem function.injective.nontrivial {α : Type u_1} {β : Type u_2} [nontrivial α] {f : α → β} (hf : function.injective f) : nontrivial β
theorem tendsto_rpow_neg_at_top {y : ℝ} (hy : 0 < y) : filter.tendsto (λ (x : ℝ), x ^ -y) filter.at_top (nhds 0)
theorem vsub_sub_vsub_cancel_left {G : Type u_1} {P : Type u_2} [add_comm_group G] [add_torsor G P] (p1 p2 p3 : P) : p3 -ᵥ p2 - (p3 -ᵥ p1) = p1 -ᵥ p2
theorem subgroup.exists_left_complement'_of_coprime_of_fintype {G : Type u} [group G] [fintype G] {N : subgroup G} [N.normal] (hN : (fintype.card ↥N).coprime N.index) : ∃ (H : subgroup G), H.is_complement' N
theorem monotone_of_deriv_nonneg {f : ℝ → ℝ} (hf : differentiable ℝ f) (hf' : ∀ (x : ℝ), 0 ≤ deriv f x) : monotone f
theorem colex.sdiff_lt_sdiff_iff_lt {α : Type u_1} [has_lt α] [decidable_eq α] (A B : finset α) : (A  B).to_colex < (B  A).to_colex ↔ A.to_colex < B.to_colex
theorem nat.choose_le_middle (r n : ℕ) : n.choose r ≤ n.choose (n / 2)
theorem local_ring.of_nonunits_add {R : Type u} [comm_semiring R] [nontrivial R] (h : ∀ (a b : R), a ∈ nonunits R → b ∈ nonunits R → a + b ∈ nonunits R) : local_ring R
theorem strict_convex_iff_div {𝕜 : Type u_1} {E : Type u_3} [linear_ordered_field 𝕜] [topological_space E] [add_comm_group E] [module 𝕜 E] {s : set E} : strict_convex 𝕜 s ↔ s.pairwise (λ (x y : E), ∀ ⦃a b : 𝕜⦄, 0 < a → 0 < b → (a / (a + b)) • x + (b / (a + b)) • y ∈ interior s)
theorem polynomial.cyclotomic_eq_prod_X_sub_primitive_roots {K : Type u_1} [comm_ring K] [is_domain K] {ζ : K} {n : ℕ} (hz : is_primitive_root ζ n) : polynomial.cyclotomic n K = (primitive_roots n K).prod (λ (μ : K), polynomial.X - ⇑polynomial.C μ)
theorem affine.simplex.orthogonal_projection_eq_circumcenter_of_dist_eq {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P n) {p : P} {r : ℝ} (hr : ∀ (i : fin (n + 1)), has_dist.dist (s.points i) p = r) : ↑(⇑(s.orthogonal_projection_span) p) = s.circumcenter
theorem is_add_monoid_hom.id {α : Type u} [add_zero_class α] : is_add_monoid_hom id
theorem finset.prod_range_div {M : Type u_1} [comm_group M] (f : ℕ → M) (n : ℕ) : (finset.range n).prod (λ (i : ℕ), f (i + 1) * (f i)⁻¹) = f n * (f 0)⁻¹
theorem vector_span_image_eq_span_vsub_set_left_ne (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} (p : ι → P) {s : set ι} {i : ι} (hi : i ∈ s) : vector_span k (p '' s) = submodule.span k (has_vsub.vsub (p i) '' (p '' (s  {i})))
theorem function.injective.nat_tendsto_at_top {f : ℕ → ℕ} (hf : function.injective f) : filter.tendsto f filter.at_top filter.at_top
theorem self_adjoint.coe_re_map_spectrum' {A : Type u_1} [normed_ring A] [normed_algebra ℂ A] [complete_space A] [star_ring A] [cstar_ring A] [star_module ℂ A] [nontrivial A] (a : ↥(self_adjoint A)) : spectrum ℂ ↑a = coe ∘ complex.re '' spectrum ℂ ↑a
theorem category_theory.sheaf.is_sheaf_of_representable {C : Type u} [category_theory.category C] (P : Cᵒᵖ ⥤ Type v) [P.representable] : category_theory.presieve.is_sheaf (category_theory.sheaf.canonical_topology C) P
theorem finset.card_powerset_len {α : Type u_1} (n : ℕ) (s : finset α) : (finset.powerset_len n s).card = s.card.choose n
theorem add_monoid_algebra.support_gen_of_gen {R : Type u_1} {M : Type u_2} [comm_semiring R] [add_monoid M] {S : set (add_monoid_algebra R M)} (hS : algebra.adjoin R S = ⊤) : algebra.adjoin R (⋃ (f : add_monoid_algebra R M) (H : f ∈ S), add_monoid_algebra.of' R M '' ↑(f.support)) = ⊤
theorem module.free.rank_eq_card_choose_basis_index (R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] : module.rank R M = cardinal.mk (module.free.choose_basis_index R M)
theorem cont_diff_on.differentiable_on_iterated_deriv_within {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {s : set 𝕜} {n : with_top ℕ} {m : ℕ} (h : cont_diff_on 𝕜 n f s) (hmn : ↑m < n) (hs : unique_diff_on 𝕜 s) : differentiable_on 𝕜 (iterated_deriv_within m f s) s
theorem affine_map.decomp' {k : Type u_1} {V1 : Type u_2} {V2 : Type u_4} [ring k] [add_comm_group V1] [module k V1] [add_comm_group V2] [module k V2] (f : V1 →ᵃ[k] V2) : ⇑(f.linear) = ⇑f - λ (z : V1), ⇑f 0
theorem vector.singleton_tail {α : Type u_1} (v : vector α 1) : v.tail = vector.nil
theorem differentiable.exists_const_forall_eq_of_bounded {E : Type u} [normed_group E] [normed_space ℂ E] {F : Type v} [normed_group F] [normed_space ℂ F] {f : E → F} (hf : differentiable ℂ f) (hb : metric.bounded (set.range f)) : ∃ (c : F), ∀ (z : E), f z = c
theorem orthonormal.inner_right_sum {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : orthonormal 𝕜 v) (l : ι → 𝕜) {s : finset ι} {i : ι} (hi : i ∈ s) : has_inner.inner (v i) (s.sum (λ (i : ι), l i • v i)) = l i
theorem is_localization.ring_hom_ext {R : Type u_1} [comm_semiring R] (M : submonoid R) {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] ⦃j k : S →+* P⦄ (h : j.comp (algebra_map R S) = k.comp (algebra_map R S)) : j = k
theorem is_primitive_root.is_root_cyclotomic {R : Type u_1} {n : ℕ} [comm_ring R] [is_domain R] (hpos : 0 < n) {μ : R} (h : is_primitive_root μ n) : (polynomial.cyclotomic n R).is_root μ
theorem metric.Hausdorff_dist_closure₂ {α : Type u} [pseudo_metric_space α] {s t : set α} : metric.Hausdorff_dist s (closure t) = metric.Hausdorff_dist s t
theorem measure_theory.measure.eq_singular_part {α : Type u_1} {m : measurable_space α} {μ ν s : measure_theory.measure α} {f : α → ennreal} (hf : measurable f) (hs : s.mutually_singular ν) (hadd : μ = s + ν.with_density f) : s = μ.singular_part ν
theorem is_localization.is_prime_iff_is_prime_disjoint {R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] (J : ideal S) : J.is_prime ↔ (ideal.comap (algebra_map R S) J).is_prime ∧ disjoint ↑M ↑(ideal.comap (algebra_map R S) J)
theorem Top.presheaf.is_sheaf_unique_gluing_of_is_sheaf_types {X : Top} (F : Top.presheaf (Type v) X) (Fsh : F.is_sheaf) : F.is_sheaf_unique_gluing
theorem finset.exists_lt_sum_fiber_of_sum_fiber_nonpos_of_nsmul_lt_sum {α : Type u} {β : Type v} {M : Type w} [decidable_eq β] {s : finset α} {t : finset β} {f : α → β} {w : α → M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (ht : ∀ (y : β), y ∉ t → (finset.filter (λ (x : α), f x = y) s).sum (λ (x : α), w x) ≤ 0) (hb : t.card • b < s.sum (λ (x : α), w x)) : ∃ (y : β) (H : y ∈ t), b < (finset.filter (λ (x : α), f x = y) s).sum (λ (x : α), w x)
theorem convex.closure {E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) : convex 𝕜 (closure s)
theorem tendsto_self_mul_const_pow_of_abs_lt_one {r : ℝ} (hr : |r| < 1) : filter.tendsto (λ (n : ℕ), ↑n * r ^ n) filter.at_top (nhds 0)
theorem submodule.supr_induction {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] {ι : Sort u_2} (p : ι → submodule R M) {C : M → Prop} {x : M} (hx : x ∈ ⨆ (i : ι), p i) (hp : ∀ (i : ι) (x : M), x ∈ p i → C x) (h0 : C 0) (hadd : ∀ (x y : M), C x → C y → C (x + y)) : C x
theorem colex.sdiff_le_sdiff_iff_le {α : Type u_1} [linear_order α] (A B : finset α) : (A  B).to_colex ≤ (B  A).to_colex ↔ A.to_colex ≤ B.to_colex
theorem local_homeomorph.is_image.preimage_eq' {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {e : local_homeomorph α β} {s : set α} {t : set β} : e.is_image s t → e.to_local_equiv.source ∩ ⇑e ⁻¹' (e.to_local_equiv.target ∩ t) = e.to_local_equiv.source ∩ s
theorem basis.ext_multilinear {R : Type u_1} {ι : Type u_2} {M₂ : Type u_4} {M₃ : Type u_5} [comm_semiring R] [add_comm_monoid M₂] [add_comm_monoid M₃] [module R M₂] [module R M₃] [decidable_eq ι] [fintype ι] {f g : multilinear_map R (λ (i : ι), M₂) M₃} {ι₁ : Type u_3} (e : basis ι₁ R M₂) (h : ∀ (v : ι → ι₁), ⇑f (λ (i : ι), ⇑e (v i)) = ⇑g (λ (i : ι), ⇑e (v i))) : f = g
theorem ratfunc.eval_add {K : Type u} [hfield : field K] {L : Type u_1} [field L] (f : K →+* L) (a : L) {x y : ratfunc K} (hx : polynomial.eval₂ f a x.denom ≠ 0) (hy : polynomial.eval₂ f a y.denom ≠ 0) : ratfunc.eval f a (x + y) = ratfunc.eval f a x + ratfunc.eval f a y
theorem is_compact.compl_mem_sets {α : Type u} [topological_space α] {s : set α} (hs : is_compact s) {f : filter α} (hf : ∀ (a : α), a ∈ s → sᶜ ∈ nhds a ⊓ f) : sᶜ ∈ f
theorem Top.presheaf.germ_exist {C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X : Top} [category_theory.concrete_category C] [category_theory.limits.preserves_filtered_colimits (category_theory.forget C)] (F : Top.presheaf C X) (x : ↥X) (t : ↥(F.stalk x)) : ∃ (U : topological_space.opens ↥X) (m : x ∈ U) (s : ↥(F.obj (opposite.op U))), ⇑(F.germ ⟨x, m⟩) s = t
theorem finset.exists_intermediate_set {α : Type u_1} {A B : finset α} (i : ℕ) (h₁ : i + B.card ≤ A.card) (h₂ : B ⊆ A) : ∃ (C : finset α), B ⊆ C ∧ C ⊆ A ∧ C.card = i + B.card
theorem finite_dimensional.proper (𝕜 : Type u) [nondiscrete_normed_field 𝕜] (E : Type v) [normed_group E] [normed_space 𝕜 E] [proper_space 𝕜] [finite_dimensional 𝕜 E] : proper_space E
theorem even_of_exists_two_nsmul {α : Type u_2} [add_monoid α] (m : α) : (∃ (c : α), m = 2 • c) → even m
theorem convex_on.le_on_segment' {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [linear_ordered_add_comm_monoid β] [has_scalar 𝕜 E] [module 𝕜 β] [ordered_smul 𝕜 β] {s : set E} {f : E → β} (hf : convex_on 𝕜 s f) {x y : E} (hx : x ∈ s) (hy : y ∈ s) {a b : 𝕜} (ha : 0 ≤ a) (hb : 0 ≤ b) (hab : a + b = 1) : f (a • x + b • y) ≤ linear_order.max (f x) (f y)
theorem submodule.inner_left_of_mem_orthogonal {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K : submodule 𝕜 E} {u v : E} (hu : u ∈ K) (hv : v ∈ Kᗮ) : has_inner.inner v u = 0
theorem cInf_le_cSup {α : Type u_1} [conditionally_complete_lattice α] {s : set α} (hb : bdd_below s) (ha : bdd_above s) (ne : s.nonempty) : has_Inf.Inf s ≤ has_Sup.Sup s
theorem set.image2_image_left_comm {α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {s : set α} {t : set β} {f : α' → β → γ} {g : α → α'} {f' : α → β → δ} {g' : δ → γ} (h_left_comm : ∀ (a : α) (b : β), f (g a) b = g' (f' a b)) : set.image2 f (g '' s) t = g' '' set.image2 f' s t
theorem category_theory.is_pullback.of_is_limit' {C : Type u₁} [category_theory.category C] {P X Y Z : C} {fst : P ⟶ X} {snd : P ⟶ Y} {f : X ⟶ Z} {g : Y ⟶ Z} (w : category_theory.comm_sq fst snd f g) (h : category_theory.limits.is_limit w.cone) : category_theory.is_pullback fst snd f g
theorem sub_le_self {α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] [covariant_class α α (function.swap has_add.add) has_le.le] (a : α) {b : α} : 0 ≤ b → a - b ≤ a
theorem is_cyclotomic_extension.finrank {n : ℕ+} {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [is_cyclotomic_extension {n} K L] (hirr : irreducible (polynomial.cyclotomic ↑n K)) [ne_zero ↑↑n] : finite_dimensional.finrank K L = ↑n.totient
theorem lie_submodule.ucs_le_of_centralizer_eq_self {R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] {N₁ : lie_submodule R L M} (h : N₁.centralizer = N₁) (k : ℕ) : lie_submodule.ucs k ⊥ ≤ N₁
theorem complex.to_matrix_conj_ae  : ⇑(linear_map.to_matrix complex.basis_one_I complex.basis_one_I) complex.conj_ae.to_linear_map = ![![1, 0], ![0, -1]]
theorem is_primitive_root.norm_eq_one_of_linearly_ordered {n : ℕ+} {L : Type v} [field L] {ζ : L} (hζ : is_primitive_root ζ ↑n) {K : Type u_1} [linear_ordered_field K] [algebra K L] (hodd : odd ↑n) : ⇑(algebra.norm K) ζ = 1
theorem subgroup.comap_normalizer_eq_of_surjective {G : Type u_1} [group G] {N : Type u_3} [group N] (H : subgroup G) {f : N →* G} (hf : function.surjective ⇑f) : subgroup.comap f H.normalizer = (subgroup.comap f H).normalizer
theorem add_con.lift_mk' {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} {f : M →+ P} (H : c ≤ add_con.ker f) (x : M) : ⇑(c.lift f H) (⇑(c.mk') x) = ⇑f x
theorem inner_product_geometry.angle_zero_right {V : Type u_1} [inner_product_space ℝ V] (x : V) : inner_product_geometry.angle x 0 = real.pi / 2
theorem category_theory.zigzag_obj_of_zigzag {J : Type u₁} [category_theory.category J] {K : Type u₂} [category_theory.category K] (F : J ⥤ K) {j₁ j₂ : J} (h : category_theory.zigzag j₁ j₂) : category_theory.zigzag (F.obj j₁) (F.obj j₂)
theorem pi.sum_nnnorm_apply_le_nnnorm {ι : Type u_2} {π : ι → Type u_1} [fintype ι] [Π (i : ι), semi_normed_group (π i)] (x : Π (i : ι), π i) : finset.univ.sum (λ (i : ι), ∥x i∥₊) ≤ fintype.card ι • ∥x∥₊
theorem module.ray.ind (R : Type u_1) [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {C : module.ray R M → Prop} (h : ∀ (v : M) (hv : v ≠ 0), C (ray_of_ne_zero R v hv)) (x : module.ray R M) : C x
theorem finset.centroid_eq_centroid_image_of_inj_on (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} (s : finset ι) {p : ι → P} (hi : ∀ (i : ι), i ∈ s → ∀ (j : ι), j ∈ s → p i = p j → i = j) {ps : set P} [fintype ↥ps] (hps : ps = p '' ↑s) : finset.centroid k s p = finset.centroid k finset.univ (λ (x : ↥ps), ↑x)
theorem liouville_with.irrational {p x : ℝ} (h : liouville_with p x) (hp : 1 < p) : irrational x
theorem is_add_regular_zero {R : Type u_1} [add_zero_class R] : is_add_regular 0
theorem fixing_subgroup_fixed_points_gc (M : Type u_1) (α : Type u_2) [group M] [mul_action M α] : galois_connection (⇑order_dual.to_dual ∘ fixing_subgroup M) ((λ (P : subgroup M), mul_action.fixed_points ↥P α) ∘ ⇑order_dual.of_dual)
theorem affine_independent_def (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} (p : ι → P) : affine_independent k p ↔ ∀ (s : finset ι) (w : ι → k), s.sum (λ (i : ι), w i) = 0 → ⇑(s.weighted_vsub p) w = 0 → ∀ (i : ι), i ∈ s → w i = 0
theorem topological_add_group_of_lie_add_group {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space 𝕜 E] (I : model_with_corners 𝕜 E H) {G : Type u_5} [topological_space G] [charted_space H G] [add_group G] [lie_add_group I G] : topological_add_group G
theorem not_is_regular_zero {R : Type u_1} [mul_zero_class R] [nontrivial R] : ¬is_regular 0
theorem cont_diff_within_at.differentiable_within_at' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {x : E} {n : with_top ℕ} (h : cont_diff_within_at 𝕜 n f s x) (hn : 1 ≤ n) : differentiable_within_at 𝕜 f (has_insert.insert x s) x
theorem exists_open_superset_and_is_compact_closure {α : Type u} [topological_space α] [locally_compact_space α] [t2_space α] {K : set α} (hK : is_compact K) : ∃ (V : set α), is_open V ∧ K ⊆ V ∧ is_compact (closure V)
theorem uniform_cauchy_seq_on.tendsto_uniformly_on_of_tendsto {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {s : set α} {p : filter ι} [p.ne_bot] (hF : uniform_cauchy_seq_on F p s) (hF' : ∀ (x : α), x ∈ s → filter.tendsto (λ (n : ι), F n x) p (nhds (f x))) : tendsto_uniformly_on F f p s
theorem emetric.inf_edist_closure {α : Type u} [pseudo_emetric_space α] {x : α} {s : set α} : emetric.inf_edist x (closure s) = emetric.inf_edist x s
theorem filter.has_basis_infi_principal_finite {α : Type u_1} {ι : Type u_2} (s : ι → set α) : (⨅ (i : ι), filter.principal (s i)).has_basis (λ (t : set ι), t.finite) (λ (t : set ι), ⋂ (i : ι) (H : i ∈ t), s i)
theorem complex.circle_integral_sub_center_inv_smul_of_differentiable_on_off_countable_of_tendsto {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] {c : ℂ} {R : ℝ} (h0 : 0 < R) {f : ℂ → E} {y : E} {s : set ℂ} (hs : s.countable) (hc : continuous_on f (metric.closed_ball c R  {c})) (hd : ∀ (z : ℂ), z ∈ metric.ball c R  {c}  s → differentiable_at ℂ f z) (hy : filter.tendsto f (nhds_within c {c}ᶜ) (nhds y)) : ∮ (z : ℂ) in C(c, R), (z - c)⁻¹ • f z = (2 * ↑real.pi * complex.I) • y
theorem measurable_set.measure_eq_supr_is_compact_of_ne_top {α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [μ.regular] ⦃A : set α⦄ (hA : measurable_set A) (h'A : ⇑μ A ≠ ⊤) : ⇑μ A = ⨆ (K : set α) (H : K ⊆ A) (h : is_compact K), ⇑μ K
theorem left.add_pos_of_nonneg_of_pos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 ≤ a) (hb : 0 < b) : 0 < a + b
theorem implies.trans {p q r : Prop} (h₁ : implies p q) (h₂ : implies q r) : implies p r
theorem integral_closure_map_alg_equiv {R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [comm_ring B] [algebra R A] [algebra R B] (f : A ≃ₐ[R] B) : (integral_closure R A).map ↑f = integral_closure R B
theorem has_le.le.lt_or_eq_dec {α : Type u} [partial_order α] [decidable_rel has_le.le] {a b : α} (hab : a ≤ b) : a < b ∨ a = b
theorem continuous_map.tendsto_locally_uniformly_of_tendsto {α : Type u₁} {β : Type u₂} [topological_space α] [uniform_space β] {f : C(α, β)} {ι : Type u₃} {p : filter ι} {F : ι → C(α, β)} (hα : ∀ (x : α), ∃ (n : set α), is_compact n ∧ n ∈ nhds x) (h : filter.tendsto F p (nhds f)) : tendsto_locally_uniformly (λ (i : ι) (a : α), ⇑(F i) a) ⇑f p
theorem lt_of_sub_neg {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a - b < 0 → a < b
theorem finset.centroid_weights_apply (k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) (i : ι) : finset.centroid_weights k s i = (↑(s.card))⁻¹
theorem cont_mdiff_at.cont_diff_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {n : with_top ℕ} {f : E → E'} {x : E} : cont_mdiff_at (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n f x → cont_diff_at 𝕜 n f x
theorem has_le.le.trans_eq {α : Type u} [preorder α] {a b c : α} (hab : a ≤ b) (hbc : b = c) : a ≤ c
theorem int.exists_lt_and_lt_iff_not_dvd (m : ℤ) {n : ℤ} (hn : 0 < n) : (∃ (k : ℤ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m
theorem complex.deriv_eq_smul_circle_integral {F : Type v} [normed_group F] [normed_space ℂ F] [complete_space F] {R : ℝ} {c : ℂ} {f : ℂ → F} (hR : 0 < R) (hf : diff_cont_on_cl ℂ f (metric.ball c R)) : deriv f c = (2 * ↑real.pi * complex.I)⁻¹ • ∮ (z : ℂ) in C(c, R), (z - c) ^ -2 • f z
theorem alternating_map.comp_linear_map_injective {R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] {ι : Type u_6} [decidable_eq ι] {M₂ : Type u_7} [add_comm_monoid M₂] [module R M₂] (f : M₂ →ₗ[R] M) (hf : function.surjective ⇑f) : function.injective (λ (g : alternating_map R M N ι), g.comp_linear_map f)
theorem category_theory.L_faithful_of_unit_is_iso {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {L : C ⥤ D} {R : D ⥤ C} (h : L ⊣ R) [category_theory.is_iso h.unit] : category_theory.faithful L
theorem quadratic_form.anisotropic_of_prod {M₁ : Type u_3} {M₂ : Type u_4} [add_comm_group M₁] [add_comm_group M₂] {R : Type u_1} [ordered_ring R] [module R M₁] [module R M₂] {Q₁ : quadratic_form R M₁} {Q₂ : quadratic_form R M₂} (h : (Q₁.prod Q₂).anisotropic) : Q₁.anisotropic ∧ Q₂.anisotropic
theorem pnat.count_factor_multiset (m : ℕ+) (p : nat.primes) (k : ℕ) : ↑p ^ k ∣ m ↔ k ≤ multiset.count p m.factor_multiset
theorem zsqrtd.lift_injective {R : Type} [comm_ring R] [char_zero R] {d : ℤ} (r : {r // r * r = ↑d}) (hd : ∀ (n : ℤ), d ≠ n * n) : function.injective ⇑(⇑zsqrtd.lift r)
theorem mv_polynomial.homogeneous_submodule_eq_finsupp_supported (σ : Type u_1) (R : Type u_3) [comm_semiring R] (n : ℕ) : mv_polynomial.homogeneous_submodule σ R n = finsupp.supported R R {d : σ →₀ ℕ | d.support.sum (λ (i : σ), ⇑d i) = n}
theorem dist_eq_norm_vsub (V : Type u_2) {P : Type u_3} [semi_normed_group V] [pseudo_metric_space P] [normed_add_torsor V P] (x y : P) : has_dist.dist x y = ∥x -ᵥ y∥
theorem polynomial.has_strict_deriv_at {𝕜 : Type u} [nondiscrete_normed_field 𝕜] (p : polynomial 𝕜) (x : 𝕜) : has_strict_deriv_at (λ (x : 𝕜), polynomial.eval x p) (polynomial.eval x (⇑polynomial.derivative p)) x
theorem antitone.map_bdd_below {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} (hf : antitone f) {s : set α} : bdd_below s → bdd_above (f '' s)
theorem picard_lindelof.exists_solution {E : Type u_1} [normed_group E] [normed_space ℝ E] (v : picard_lindelof E) [complete_space E] : ∃ (f : ℝ → E), f ↑(v.t₀) = v.x₀ ∧ ∀ (t : ℝ), t ∈ set.Icc v.t_min v.t_max → has_deriv_within_at f (⇑v t (f t)) (set.Icc v.t_min v.t_max) t
theorem ideal.eq_zero_of_constant_mem_of_maximal {R : Type u} [ring R] (hR : is_field R) (I : ideal (polynomial R)) [hI : I.is_maximal] (x : R) (hx : ⇑polynomial.C x ∈ I) : x = 0
theorem category_theory.limits.has_binary_biproduct.of_has_binary_coproduct {C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y] : category_theory.limits.has_binary_biproduct X Y
theorem local_homeomorph.continuous_at {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) {x : α} (h : x ∈ e.to_local_equiv.source) : continuous_at ⇑e x
theorem ultrafilter.exists_le {α : Type u} (f : filter α) [h : f.ne_bot] : ∃ (u : ultrafilter α), ↑u ≤ f
theorem linear_map.prod_ext {R : Type u} {M : Type v} {M₂ : Type w} {M₃ : Type y} [semiring R] [add_comm_monoid M] [add_comm_monoid M₂] [add_comm_monoid M₃] [module R M] [module R M₂] [module R M₃] {f g : M × M₂ →ₗ[R] M₃} (hl : f.comp (linear_map.inl R M M₂) = g.comp (linear_map.inl R M M₂)) (hr : f.comp (linear_map.inr R M M₂) = g.comp (linear_map.inr R M M₂)) : f = g
theorem category_theory.limits.has_binary_coproducts_of_has_colimit_pair (C : Type u) [category_theory.category C] [∀ {X Y : C}, category_theory.limits.has_colimit (category_theory.limits.pair X Y)] : category_theory.limits.has_binary_coproducts C
theorem matrix.det_eq_of_forall_row_eq_smul_add_const {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] {A B : matrix n n R} (c : n → R) (k : n) (hk : c k = 0) (A_eq : ∀ (i j : n), A i j = B i j + c i * B k j) : A.det = B.det
theorem finset.nat.antidiagonal_congr {n : ℕ} {p q : ℕ × ℕ} (hp : p ∈ finset.nat.antidiagonal n) (hq : q ∈ finset.nat.antidiagonal n) : p = q ↔ p.fst = q.fst
theorem quaternion_group.order_of_xa {n : ℕ} [hpos : fact (0 < n)] (i : zmod (2 * n)) : order_of (quaternion_group.xa i) = 4
theorem finset.sum_add_sum_compl {β : Type u} {α : Type v} [add_comm_monoid β] [fintype α] [decidable_eq α] (s : finset α) (f : α → β) : s.sum (λ (i : α), f i) + sᶜ.sum (λ (i : α), f i) = finset.univ.sum (λ (i : α), f i)
theorem submodule.eq_bot_of_le_smul_of_le_jacobson_bot {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (I : ideal R) (N : submodule R M) (hN : N.fg) (hIN : N ≤ I • N) (hIjac : I ≤ ⊥.jacobson) : N = ⊥
theorem is_add_regular_add_iff {R : Type u_1} {a b : R} [add_comm_semigroup R] : is_add_regular (a + b) ↔ is_add_regular a ∧ is_add_regular b
theorem measure_theory.lintegral_lintegral {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] ⦃f : α → β → ennreal⦄ (hf : ae_measurable (function.uncurry f) (μ.prod ν)) : ∫⁻ (x : α), ∫⁻ (y : β), f x y ∂ν ∂μ = ∫⁻ (z : α × β), f z.fst z.snd ∂μ.prod ν
theorem exists_open_set_nhds {α : Type u} [topological_space α] {s U : set α} (h : ∀ (x : α), x ∈ s → U ∈ nhds x) : ∃ (V : set α), s ⊆ V ∧ is_open V ∧ V ⊆ U
theorem combinatorics.line.exists_mono_in_high_dimension (α : Type u) [fintype α] (κ : Type v) [fintype κ] : ∃ (ι : Type) [_inst_3 : fintype ι], ∀ (C : (ι → α) → κ), ∃ (l : combinatorics.line α ι), combinatorics.line.is_mono C l
theorem is_compact_iff_finite_subcover {α : Type u} [topological_space α] {s : set α} : is_compact s ↔ ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)
theorem category_theory.forget_enrichment_comp {C : Type u₁} (W : Type (v+1)) [category_theory.category W] [category_theory.monoidal_category W] [category_theory.enriched_category W C] {X Y Z : category_theory.forget_enrichment W C} (f : X ⟶ Y) (g : Y ⟶ Z) : category_theory.forget_enrichment.hom_to W (f ≫ g) = ((λ_ (𝟙_ W)).inv ≫ (category_theory.forget_enrichment.hom_to W f ⊗ category_theory.forget_enrichment.hom_to W g)) ≫ category_theory.e_comp W (category_theory.forget_enrichment.to W X) (category_theory.forget_enrichment.to W Y) (category_theory.forget_enrichment.to W Z)
theorem metric.dist_mem_uniformity {α : Type u} [pseudo_metric_space α] {ε : ℝ} (ε0 : 0 < ε) : {p : α × α | has_dist.dist p.fst p.snd < ε} ∈ uniformity α
theorem left.one_lt_mul_of_le_of_lt {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 ≤ a) (hb : 1 < b) : 1 < a * b
theorem filter.eventually_eq.mem_iff {α : Type u} {s t : set α} {l : filter α} : s =ᶠ[l] t → (∀ᶠ (x : α) in l, x ∈ s ↔ x ∈ t)
theorem function.is_fixed_pt.left_of_comp {α : Type u} {f g : α → α} {x : α} (hfg : function.is_fixed_pt (f ∘ g) x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt f x
theorem orientation.oangle_rotation {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x y : V) (θ : real.angle) : o.oangle (⇑(o.rotation θ) x) (⇑(o.rotation θ) y) = o.oangle x y
theorem ordinal.enum_ord_def_nonempty {S : set ordinal} (hS : set.unbounded has_lt.lt S) {o : ordinal} : {x : ordinal | x ∈ S ∧ ∀ (c : ordinal), c < o → ordinal.enum_ord S c < x}.nonempty
theorem is_noetherian_of_range_eq_ker {R : Type u_1} {M : Type u_2} {P : Type u_3} {N : Type w} [ring R] [add_comm_group M] [module R M] [add_comm_group N] [module R N] [add_comm_group P] [module R P] [is_noetherian R M] [is_noetherian R P] (f : M →ₗ[R] N) (g : N →ₗ[R] P) (hf : function.injective ⇑f) (hg : function.surjective ⇑g) (h : f.range = g.ker) : is_noetherian R N
theorem category_theory.abelian.pseudoelement.Module.eq_range_of_pseudoequal {R : Type u_1} [comm_ring R] {G : Module R} {x y : category_theory.over G} (h : category_theory.abelian.pseudo_equal G x y) : linear_map.range x.hom = linear_map.range y.hom
theorem linear_map.finite_dimensional_of_det_ne_one {M : Type u_2} [add_comm_group M] {𝕜 : Type u_1} [field 𝕜] [module 𝕜 M] (f : M →ₗ[𝕜] M) (hf : ⇑linear_map.det f ≠ 1) : finite_dimensional 𝕜 M
theorem list.nth_le_map_rev {α : Type u} {β : Type v} (f : α → β) {l : list α} {n : ℕ} (H : n < l.length) : f (l.nth_le n H) = (list.map f l).nth_le n _
theorem algebra_map_isometry (𝕜 : Type u_5) (𝕜' : Type u_6) [normed_field 𝕜] [semi_normed_ring 𝕜'] [normed_algebra 𝕜 𝕜'] [norm_one_class 𝕜'] : isometry ⇑(algebra_map 𝕜 𝕜')
theorem pgame.left_distrib_equiv (x y z : pgame) : (x * (y + z)).equiv (x * y + x * z)
theorem set.subset_Union_of_subset {α : Type u_1} {ι : Sort u_4} {s : set α} {t : ι → set α} (i : ι) (h : s ⊆ t i) : s ⊆ ⋃ (i : ι), t i
theorem mv_polynomial.vars_prod {R : Type u} {σ : Type u_1} [comm_semiring R] {ι : Type u_2} {s : finset ι} (f : ι → mv_polynomial σ R) : (s.prod (λ (i : ι), f i)).vars ⊆ s.bUnion (λ (i : ι), (f i).vars)
theorem eq.faithful_of_comp {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {E : Type u₃} [category_theory.category E] {F : C ⥤ D} {G : D ⥤ E} {H : C ⥤ E} [ℋ : category_theory.faithful H] (h : F ⋙ G = H) : category_theory.faithful F
theorem tendsto_rpow_at_top {y : ℝ} (hy : 0 < y) : filter.tendsto (λ (x : ℝ), x ^ y) filter.at_top filter.at_top
theorem pi.single_apply_commute {I : Type u} {f : I → Type v} [decidable_eq I] [Π (i : I), add_zero_class (f i)] (x : Π (i : I), f i) (i j : I) : add_commute (pi.single i (x i)) (pi.single j (x j))
theorem int.eq_zero_of_dvd_of_nat_abs_lt_nat_abs {a b : ℤ} (w : a ∣ b) (h : b.nat_abs < a.nat_abs) : b = 0
theorem affine.simplex.affine_span_pair_eq_altitude_iff {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P (n + 1)) (i : fin (n + 2)) (p : P) : affine_span ℝ {p, s.points i} = s.altitude i ↔ p ≠ s.points i ∧ p ∈ affine_span ℝ (set.range s.points) ∧ p -ᵥ s.points i ∈ ((affine_span ℝ (s.points '' ↑(finset.univ.erase i))).direction)ᗮ
theorem formal_multilinear_series.radius_right_inv_pos_of_radius_pos_aux2 {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : ℕ} (hn : 2 ≤ n + 1) (p : formal_multilinear_series 𝕜 E F) (i : E ≃L[𝕜] F) {r a C : ℝ} (hr : 0 ≤ r) (ha : 0 ≤ a) (hC : 0 ≤ C) (hp : ∀ (n : ℕ), ∥p n∥ ≤ C * r ^ n) : (finset.Ico 1 (n + 1)).sum (λ (k : ℕ), a ^ k * ∥p.right_inv i k∥) ≤ ∥↑(i.symm)∥ * a + ∥↑(i.symm)∥ * C * (finset.Ico 2 (n + 1)).sum (λ (k : ℕ), (r * (finset.Ico 1 n).sum (λ (j : ℕ), a ^ j * ∥p.right_inv i j∥)) ^ k)
theorem bernstein_approximation_uniform (f : C(↥unit_interval, ℝ)) : filter.tendsto (λ (n : ℕ), bernstein_approximation n f) filter.at_top (nhds f)
theorem has_ftaylor_series_up_to_on.prod {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {s : set E} {f : E → F} {n : with_top ℕ} {p : E → formal_multilinear_series 𝕜 E F} (hf : has_ftaylor_series_up_to_on n f p s) {g : E → G} {q : E → formal_multilinear_series 𝕜 E G} (hg : has_ftaylor_series_up_to_on n g q s) : has_ftaylor_series_up_to_on n (λ (y : E), (f y, g y)) (λ (y : E) (k : ℕ), (p y k).prod (q y k)) s
theorem metric.inf_dist_eq_closure {α : Type u} [pseudo_metric_space α] {s : set α} {x : α} : metric.inf_dist x (closure s) = metric.inf_dist x s
theorem free_group.reduce.eq_of_red {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red L₁ L₂) : free_group.reduce L₁ = free_group.reduce L₂
theorem lt_inv_of_lt_inv {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} : a < b⁻¹ → b < a⁻¹
theorem measure_theory.set_integral_prod {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] (f : α × β → E) {s : set α} {t : set β} (hf : measure_theory.integrable_on f (s ×ˢ t) (μ.prod ν)) : ∫ (z : α × β) in s ×ˢ t, f z ∂μ.prod ν = ∫ (x : α) in s, ∫ (y : β) in t, f (x, y) ∂ν ∂μ
theorem nat.dvd_left_iff_eq {m n : ℕ} : (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n
theorem fin.succ_above_last {n : ℕ} : (fin.last n).succ_above = fin.cast_succ
theorem convex_on_exp  : convex_on ℝ set.univ real.exp
theorem embedding.metrizable_space {X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.metrizable_space Y] {f : X → Y} (hf : embedding f) : topological_space.metrizable_space X
theorem generalized_continued_fraction.int_fract_pair.succ_nth_stream_eq_some_iff {K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} {n : ℕ} {ifp_succ_n : generalized_continued_fraction.int_fract_pair K} : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n ↔ ∃ (ifp_n : generalized_continued_fraction.int_fract_pair K), generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n ∧ ifp_n.fr ≠ 0 ∧ generalized_continued_fraction.int_fract_pair.of (ifp_n.fr)⁻¹ = ifp_succ_n
theorem measure_theory.pdf.integral_mul_eq_integral {α : Type u_1} {m : measurable_space α} {ℙ : measure_theory.measure α} [measure_theory.is_finite_measure «ℙ»] {X : α → ℝ} [measure_theory.has_pdf X «ℙ» measure_theory.measure_space.volume] : ∫ (x : ℝ), x * (measure_theory.pdf X «ℙ» measure_theory.measure_space.volume x).to_real = ∫ (x : α), X x ∂«ℙ»
theorem measure_theory.lintegral_lintegral_swap {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] ⦃f : α → β → ennreal⦄ (hf : ae_measurable (function.uncurry f) (μ.prod ν)) : ∫⁻ (x : α), ∫⁻ (y : β), f x y ∂ν ∂μ = ∫⁻ (y : β), ∫⁻ (x : α), f x y ∂μ ∂ν
theorem linear_map.congr_fun {R : Type u_1} {S : Type u_6} {M : Type u_9} {M₃ : Type u_12} [semiring R] [semiring S] [add_comm_monoid M] [add_comm_monoid M₃] [module R M] [module S M₃] {σ : R →+* S} {f g : M →ₛₗ[σ] M₃} (h : f = g) (x : M) : ⇑f x = ⇑g x
theorem polynomial.is_separable_contraction.degree_eq {F : Type} [field F] (q : ℕ) {f : polynomial F} (hf : polynomial.has_separable_contraction q f) [hF : exp_char F q] (g : polynomial F) (hg : polynomial.is_separable_contraction q f g) : g.nat_degree = hf.degree
theorem vector.reverse_nth_zero {n : ℕ} {α : Type u_1} {v : vector α (n + 1)} : v.reverse.head = v.last
theorem measure_theory.mem_ℒp_trim_of_mem_Lp_meas_subgroup {α : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space α} {μ : measure_theory.measure α} (hm : m ≤ m0) (f : ↥(measure_theory.Lp F p μ)) (hf_meas : f ∈ measure_theory.Lp_meas_subgroup F m p μ) : measure_theory.mem_ℒp (Exists.some _) p (μ.trim hm)
theorem orientation.oangle_smul_smul_self_of_nonneg {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x : V) {r₁ r₂ : ℝ} (hr₁ : 0 ≤ r₁) (hr₂ : 0 ≤ r₂) : o.oangle (r₁ • x) (r₂ • x) = 0
theorem pgame.equiv_nim_grundy_value (G : pgame) [G.impartial] : G.equiv (nim G.grundy_value)
theorem add_subgroup.map_equiv_normalizer_eq {G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (H : add_subgroup G) (f : G ≃+ N) : add_subgroup.map f.to_add_monoid_hom H.normalizer = (add_subgroup.map f.to_add_monoid_hom H).normalizer
theorem submodule.smul_sup_eq_smul_sup_of_le_smul_of_le_jacobson {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {I J : ideal R} {N N' : submodule R M} (hN' : N'.fg) (hIJ : I ≤ J.jacobson) (hNN : N ⊔ N' ≤ N ⊔ I • N') : N ⊔ I • N' = N ⊔ J • N'
theorem category_theory.is_pushout.of_is_colimit' {C : Type u₁} [category_theory.category C] {Z X Y P : C} {f : Z ⟶ X} {g : Z ⟶ Y} {inl : X ⟶ P} {inr : Y ⟶ P} (w : category_theory.comm_sq f g inl inr) (h : category_theory.limits.is_colimit w.cocone) : category_theory.is_pushout f g inl inr
theorem has_le.le.trans {α : Type u} [preorder α] {a b c : α} : a ≤ b → b ≤ c → a ≤ c
theorem generalized_continued_fraction.determinant {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] (not_terminated_at_n : ¬(generalized_continued_fraction.of v).terminated_at n) : (generalized_continued_fraction.of v).numerators n * (generalized_continued_fraction.of v).denominators (n + 1) - (generalized_continued_fraction.of v).denominators n * (generalized_continued_fraction.of v).numerators (n + 1) = (-1) ^ (n + 1)
theorem is_add_group_hom.id {α : Type u} [add_group α] : is_add_group_hom id
theorem affine_map.linear_map_vsub {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] (f : P1 →ᵃ[k] P2) (p1 p2 : P1) : ⇑(f.linear) (p1 -ᵥ p2) = ⇑f p1 -ᵥ ⇑f p2
theorem is_submonoid.multiset_prod_mem {M : Type u_1} [comm_monoid M] {s : set M} (hs : is_submonoid s) (m : multiset M) : (∀ (a : M), a ∈ m → a ∈ s) → m.prod ∈ s
theorem tfae_exists_lt_is_o_pow (f : ℕ → ℝ) (R : ℝ) : [∃ (a : ℝ) (H : a ∈ set.Ioo (-R) R), f =o[filter.at_top] has_pow.pow a, ∃ (a : ℝ) (H : a ∈ set.Ioo 0 R), f =o[filter.at_top] has_pow.pow a, ∃ (a : ℝ) (H : a ∈ set.Ioo (-R) R), f =O[filter.at_top] has_pow.pow a, ∃ (a : ℝ) (H : a ∈ set.Ioo 0 R), f =O[filter.at_top] has_pow.pow a, ∃ (a : ℝ) (H : a < R) (C : ℝ) (h₀ : 0 < C ∨ 0 < R), ∀ (n : ℕ), |f n| ≤ C * a ^ n, ∃ (a : ℝ) (H : a ∈ set.Ioo 0 R) (C : ℝ) (H : C > 0), ∀ (n : ℕ), |f n| ≤ C * a ^ n, ∃ (a : ℝ) (H : a < R), ∀ᶠ (n : ℕ) in filter.at_top, |f n| ≤ a ^ n, ∃ (a : ℝ) (H : a ∈ set.Ioo 0 R), ∀ᶠ (n : ℕ) in filter.at_top, |f n| ≤ a ^ n].tfae
theorem linear_map.continuous_of_is_closed_ker {𝕜 : Type u} [hnorm : nondiscrete_normed_field 𝕜] {E : Type v} [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_smul 𝕜 E] (l : E →ₗ[𝕜] 𝕜) (hl : is_closed ↑(l.ker)) : continuous ⇑l
theorem deriv.lhopital_zero_nhds_right {a : ℝ} {l : filter ℝ} {f g : ℝ → ℝ} (hdf : ∀ᶠ (x : ℝ) in nhds_within a (set.Ioi a), differentiable_at ℝ f x) (hg' : ∀ᶠ (x : ℝ) in nhds_within a (set.Ioi a), deriv g x ≠ 0) (hfa : filter.tendsto f (nhds_within a (set.Ioi a)) (nhds 0)) (hga : filter.tendsto g (nhds_within a (set.Ioi a)) (nhds 0)) (hdiv : filter.tendsto (λ (x : ℝ), deriv f x / deriv g x) (nhds_within a (set.Ioi a)) l) : filter.tendsto (λ (x : ℝ), f x / g x) (nhds_within a (set.Ioi a)) l
theorem category_theory.abelian_of_adjunction.has_cokernels {C : Type u₁} [category_theory.category C] [category_theory.preadditive C] {D : Type u₂} [category_theory.category D] [category_theory.abelian D] (F : C ⥤ D) (G : D ⥤ C) [G.preserves_zero_morphisms] (i : F ⋙ G ≅ 𝟭 C) (adj : G ⊣ F) : category_theory.limits.has_cokernels C
theorem norm_sub_mul_self {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x y : E} : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ - 2 * ⇑is_R_or_C.re (has_inner.inner x y) + ∥y∥ * ∥y∥
theorem nonempty_sections_of_fintype_cofiltered_system.init {J : Type u} [category_theory.small_category J] [category_theory.is_cofiltered J] (F : J ⥤ Type u) [hf : Π (j : J), fintype (F.obj j)] [hne : ∀ (j : J), nonempty (F.obj j)] : F.sections.nonempty
theorem measure_theory.tendsto_Lp_of_tendsto_in_measure {α : Type u_1} {β : Type u_2} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} {f : ℕ → α → β} {g : α → β} [measure_theory.is_finite_measure μ] (hp : 1 ≤ p) (hp' : p ≠ ⊤) (hf : ∀ (n : ℕ), measure_theory.ae_strongly_measurable (f n) μ) (hg : measure_theory.mem_ℒp g p μ) (hui : measure_theory.unif_integrable f p μ) (hfg : measure_theory.tendsto_in_measure μ f filter.at_top g) : filter.tendsto (λ (n : ℕ), measure_theory.snorm (f n - g) p μ) filter.at_top (nhds 0)
theorem euclidean_geometry.orthogonal_projection_fn_mem {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} [nonempty ↥s] [complete_space ↥(s.direction)] (p : P) : euclidean_geometry.orthogonal_projection_fn s p ∈ s
theorem filter.tendsto.add_at_bot {α : Type u} {β : Type v} [topological_space α] [linear_ordered_add_comm_group α] [order_topology α] {l : filter β} {f g : β → α} {C : α} (hf : filter.tendsto f l (nhds C)) (hg : filter.tendsto g l filter.at_bot) : filter.tendsto (λ (x : β), f x + g x) l filter.at_bot
theorem euclidean_geometry.angle_eq_zero_of_angle_eq_pi_right {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : euclidean_geometry.angle p1 p2 p3 = real.pi) : euclidean_geometry.angle p2 p3 p1 = 0
theorem ordered_semiring.to_char_zero {R : Type u_1} [ordered_semiring R] [nontrivial R] : char_zero R
theorem interval_integral.integral_has_strict_fderiv_at {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (ha : continuous_at f a) (hb : continuous_at f b) : has_strict_fderiv_at (λ (p : ℝ × ℝ), ∫ (x : ℝ) in p.fst..p.snd, f x) ((continuous_linear_map.snd ℝ ℝ ℝ).smul_right (f b) - (continuous_linear_map.fst ℝ ℝ ℝ).smul_right (f a)) (a, b)
theorem is_algebraic_of_larger_base_of_injective {R : Type u_3} {S : Type u_4} {A : Type u_5} [comm_ring R] [comm_ring S] [comm_ring A] [algebra R S] [algebra S A] [algebra R A] [is_scalar_tower R S A] (hinj : function.injective ⇑(algebra_map R S)) {x : A} (A_alg : is_algebraic R x) : is_algebraic S x
theorem rescale_to_shell {α : Type u_1} [normed_field α] {E : Type u_5} [normed_group E] [normed_space α E] {c : α} (hc : 1 < ∥c∥) {ε : ℝ} (εpos : 0 < ε) {x : E} (hx : x ≠ 0) : ∃ (d : α), d ≠ 0 ∧ ∥d • x∥ < ε ∧ ε / ∥c∥ ≤ ∥d • x∥ ∧ ∥d∥⁻¹ ≤ ε⁻¹ * ∥c∥ * ∥x∥
theorem generalized_continued_fraction.of_part_num_eq_one_and_exists_int_part_denom_eq {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {gp : generalized_continued_fraction.pair K} (nth_s_eq : (generalized_continued_fraction.of v).s.nth n = option.some gp) : gp.a = 1 ∧ ∃ (z : ℤ), gp.b = ↑z
theorem convex_independent.mem_convex_hull_iff {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] {p : ι → E} (hc : convex_independent 𝕜 p) (s : set ι) (i : ι) : p i ∈ ⇑(convex_hull 𝕜) (p '' s) ↔ i ∈ s
theorem finset.weighted_vsub_empty {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (w : ι → k) (p : ι → P) : ⇑(∅.weighted_vsub p) w = 0
theorem matrix.det_comm' {A : Type u_5} [comm_ring A] {m : Type u_6} {n : Type u_7} [fintype m] [fintype n] [decidable_eq m] [decidable_eq n] {M : matrix n m A} {N M' : matrix m n A} (hMM' : M.mul M' = 1) (hM'M : M'.mul M = 1) : (M.mul N).det = (N.mul M).det
theorem basis.orientation_neg_single {R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {ι : Type u_3} [decidable_eq ι] [fintype ι] [nontrivial R] (e : basis ι R M) (i : ι) : (e.units_smul (function.update 1 i (-1))).orientation = -e.orientation
theorem finsum_mem_bUnion {α : Type u_1} {ι : Type u_3} {M : Type u_5} [add_comm_monoid M] {f : α → M} {I : set ι} {t : ι → set α} (h : I.pairwise_disjoint t) (hI : I.finite) (ht : ∀ (i : ι), i ∈ I → (t i).finite) : finsum (λ (a : α), finsum (λ (H : a ∈ ⋃ (x : ι) (H : x ∈ I), t x), f a)) = finsum (λ (i : ι), finsum (λ (H : i ∈ I), finsum (λ (j : α), finsum (λ (H : j ∈ t i), f j))))
theorem category_theory.functor.ess_image.unit_is_iso {C : Type u₁} {D : Type u₂} [category_theory.category C] [category_theory.category D] {i : D ⥤ C} [category_theory.reflective i] {A : C} (h : A ∈ i.ess_image) : category_theory.is_iso ((category_theory.adjunction.of_right_adjoint i).unit.app A)
theorem zero_eq_mul {M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : 0 = a * b ↔ a = 0 ∨ b = 0
theorem vector.tail_nil {α : Type u_1} : vector.nil.tail = vector.nil
theorem finset.card_div_choose_le_card_shadow_div_choose {𝕜 : Type u_1} {α : Type u_2} [linear_ordered_field 𝕜] [decidable_eq α] [fintype α] {𝒜 : finset (finset α)} {r : ℕ} (hr : r ≠ 0) (h𝒜 : set.sized r ↑𝒜) : ↑(𝒜.card) / ↑((fintype.card α).choose r) ≤ ↑(𝒜.shadow.card) / ↑((fintype.card α).choose (r - 1))
theorem dense_inducing_pure {α : Type u} : dense_inducing has_pure.pure
theorem power_series.coeff_of_lt_order {R : Type u_1} [semiring R] {φ : power_series R} (n : ℕ) (h : ↑n < φ.order) : ⇑(power_series.coeff R n) φ = 0
theorem monoid_hom.map_inv {α : Type u_1} {β : Type u_2} [group α] [division_monoid β] (f : α →* β) (a : α) : ⇑f a⁻¹ = (⇑f a)⁻¹
theorem refl_trans_gen_of_pred_of_ge {α : Type u_1} [partial_order α] [pred_order α] [is_pred_archimedean α] (r : α → α → Prop) {n m : α} (h : ∀ (i : α), i ∈ set.Ioc m n → r i (order.pred i)) (hnm : m ≤ n) : relation.refl_trans_gen r n m
theorem exp_neg_inv_glue.f_aux_zero_eq  : exp_neg_inv_glue.f_aux 0 = exp_neg_inv_glue
theorem is_o_pow_exp_pos_mul_at_top (k : ℕ) {b : ℝ} (hb : 0 < b) : (λ (x : ℝ), x ^ k) =o[filter.at_top] λ (x : ℝ), real.exp (b * x)
theorem nat.arithmetic_function.prod_eq_iff_prod_pow_moebius_eq {R : Type u_1} [comm_group R] {f g : ℕ → R} : (∀ (n : ℕ), 0 < n → n.divisors.prod (λ (i : ℕ), f i) = g n) ↔ ∀ (n : ℕ), 0 < n → n.divisors_antidiagonal.prod (λ (x : ℕ × ℕ), g x.snd ^ ⇑nat.arithmetic_function.moebius x.fst) = f n
theorem bilin_form.ext_basis {R₂ : Type u_5} {M₂ : Type u_6} [comm_semiring R₂] [add_comm_monoid M₂] [module R₂ M₂] {B₂ F₂ : bilin_form R₂ M₂} {ι : Type u_13} (b : basis ι R₂ M₂) (h : ∀ (i j : ι), ⇑B₂ (⇑b i) (⇑b j) = ⇑F₂ (⇑b i) (⇑b j)) : B₂ = F₂
theorem inner_product_geometry.angle_neg_left {V : Type u_1} [inner_product_space ℝ V] (x y : V) : inner_product_geometry.angle (-x) y = real.pi - inner_product_geometry.angle x y
theorem finrank_eq_one {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (v : V) (n : v ≠ 0) (h : ∀ (w : V), ∃ (c : K), c • v = w) : finite_dimensional.finrank K V = 1
theorem equiv.perm.is_cycle.eq_on_support_inter_nonempty_congr {α : Type u_1} [decidable_eq α] [fintype α] {f g : equiv.perm α} (hf : f.is_cycle) (hg : g.is_cycle) (h : ∀ (x : α), x ∈ f.support ∩ g.support → ⇑f x = ⇑g x) {x : α} (hx : ⇑f x = ⇑g x) (hx' : x ∈ f.support) : f = g
theorem is_ring_hom.map_neg {α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} {x : α} (hf : is_ring_hom f) : f (-x) = -f x
theorem field.exists_primitive_element_of_fintype_bot (F : Type u_1) [field F] (E : Type u_2) [field E] [algebra F E] [fintype F] [finite_dimensional F E] : ∃ (α : E), F⟮α⟯ = ⊤
theorem euclidean_geometry.angle_eq_left {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (p1 p2 : P) : euclidean_geometry.angle p1 p1 p2 = real.pi / 2
theorem set.sized.union {α : Type u_1} {A B : set (finset α)} {r : ℕ} : set.sized r A ∧ set.sized r B → set.sized r (A ∪ B)
theorem interval_integral.integral_comp_smul_deriv' {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {a b : ℝ} {f f' : ℝ → ℝ} {g : ℝ → E} (h : ∀ (x : ℝ), x ∈ set.interval a b → has_deriv_at f (f' x) x) (h' : continuous_on f' (set.interval a b)) (hg : continuous_on g (f '' set.interval a b)) : ∫ (x : ℝ) in a..b, f' x • (g ∘ f) x = ∫ (x : ℝ) in f a..f b, g x
theorem add_con.ker_apply_eq_preimage {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {f : M →+ P} (x : M) : ⇑(add_con.ker f) x = ⇑f ⁻¹' {⇑f x}
theorem dihedral_group.order_of_sr {n : ℕ} (i : zmod n) : order_of (dihedral_group.sr i) = 2
theorem measure_theory.integrable_prod_iff' {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] ⦃f : α × β → E⦄ (h1f : measure_theory.ae_strongly_measurable f (μ.prod ν)) : measure_theory.integrable f (μ.prod ν) ↔ (∀ᵐ (y : β) ∂ν, measure_theory.integrable (λ (x : α), f (x, y)) μ) ∧ measure_theory.integrable (λ (y : β), ∫ (x : α), ∥f (x, y)∥ ∂μ) ν
theorem convex_on.translate_right {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [ordered_add_comm_monoid β] [module 𝕜 E] [has_scalar 𝕜 β] {s : set E} {f : E → β} (hf : convex_on 𝕜 s f) (c : E) : convex_on 𝕜 ((λ (z : E), c + z) ⁻¹' s) (f ∘ λ (z : E), c + z)
theorem first_order.language.age.countable_quotient {L : first_order.language} (M : Type w) [L.Structure M] (h : set.univ.countable) : (quotient.mk '' L.age M).countable
theorem measurable_space.generate_measurable_eq_rec {α : Type u} (s : set (set α)) : {t : set α | measurable_space.generate_measurable s t} = ⋃ (i : (quotient.out (cardinal.aleph 1).ord).α), measurable_space.generate_measurable_rec s i
theorem forall_liouville_with_iff {x : ℝ} : (∀ (p : ℝ), liouville_with p x) ↔ liouville x
theorem is_submonoid.finset_prod_mem {M : Type u_1} {A : Type u_2} [comm_monoid M] {s : set M} (hs : is_submonoid s) (f : A → M) (t : finset A) : (∀ (b : A), b ∈ t → f b ∈ s) → t.prod (λ (b : A), f b) ∈ s
theorem equiv.coe_fn_injective {α : Sort u} {β : Sort v} : function.injective coe_fn
theorem orientation.oangle_sub_right {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle x z - o.oangle y z = o.oangle x y
theorem topological_space.is_topological_basis.open_eq_sUnion' {α : Type u} [t : topological_space α] {B : set (set α)} (hB : topological_space.is_topological_basis B) {u : set α} (ou : is_open u) : u = ⋃₀{s ∈ B | s ⊆ u}
theorem order.le_of_succ_le_succ {α : Type u_1} [preorder α] [succ_order α] {a b : α} [no_max_order α] : order.succ a ≤ order.succ b → a ≤ b
theorem box_integral.tagged_prepartition.is_Henstock.card_filter_tag_eq_le {ι : Type u_1} {I : box_integral.box ι} {π : box_integral.tagged_prepartition I} [fintype ι] (h : π.is_Henstock) (x : ι → ℝ) : (finset.filter (λ (J : box_integral.box ι), π.tag J = x) π.to_prepartition.boxes).card ≤ 2 ^ fintype.card ι
theorem alg_hom.subsingleton {R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [algebra R A] [semiring B] [algebra R B] [subsingleton (subalgebra R A)] : subsingleton (A →ₐ[R] B)
theorem nat.dvd_add_self_right {m n : ℕ} : m ∣ n + m ↔ m ∣ n
theorem finite_dimensional.exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) : ∃ (f : V → K), t.sum (λ (e : V), f e • e) = 0 ∧ t.sum (λ (e : V), f e) = 0 ∧ ∃ (x : V) (H : x ∈ t), f x ≠ 0
theorem mk_eq_mk_of_basis {ι : Type w} {ι' : Type w'} {R : Type u} [ring R] [invariant_basis_number R] {M : Type v} [add_comm_group M] [module R M] (v : basis ι R M) (v' : basis ι' R M) : (cardinal.mk ι).lift = (cardinal.mk ι').lift
theorem measure_theory.measure.measure_prod_null {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] {s : set (α × β)} (hs : measurable_set s) : ⇑(μ.prod ν) s = 0 ↔ (λ (x : α), ⇑ν (prod.mk x ⁻¹' s)) =ᵐ[μ] 0
theorem tendsto_pow_at_top_nhds_0_of_norm_lt_1 {R : Type u_1} [normed_ring R] {x : R} (h : ∥x∥ < 1) : filter.tendsto (λ (n : ℕ), x ^ n) filter.at_top (nhds 0)
theorem minpoly.prime {A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) : prime (minpoly A x)
theorem first_order.language.hom.eq_on_closure {L : first_order.language} {M : Type w} {N : Type u_1} [L.Structure M] [L.Structure N] {f g : L.hom M N} {s : set M} (h : set.eq_on ⇑f ⇑g s) : set.eq_on ⇑f ⇑g ↑(⇑(first_order.language.substructure.closure L) s)
theorem uniformity_has_basis_open {α : Type u_1} [uniform_space α] : (uniformity α).has_basis (λ (V : set (α × α)), V ∈ uniformity α ∧ is_open V) id
theorem le_of_sub_nonneg {α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : 0 ≤ a - b → b ≤ a
theorem submonoid.localization_map.map_spec {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M →* P} {T : submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ T) {Q : Type u_4} [comm_monoid Q] {k : T.localization_map Q} (z : N) (u : Q) : ⇑(f.map hy k) z = u ↔ ⇑(k.to_map) (⇑g (f.sec z).fst) = ⇑(k.to_map) (⇑g ↑((f.sec z).snd)) * u
theorem count_succ_eq_succ_count {p : ℕ → Prop} [decidable_pred p] {n : ℕ} : p n → nat.count p (n + 1) = nat.count p n + 1
theorem wcovby.of_dual {α : Type u_1} [preorder α] {a b : αᵒᵈ} : b ⩿ a → ⇑order_dual.of_dual a ⩿ ⇑order_dual.of_dual b
theorem add_monoid.closure_mono {M : Type u_1} [add_monoid M] {s t : set M} (h : s ⊆ t) : add_monoid.closure s ⊆ add_monoid.closure t
theorem dense_range.equalizer {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space β] [topological_space γ] [t2_space γ] {f : α → β} (hfd : dense_range f) {g h : β → γ} (hg : continuous g) (hh : continuous h) (H : g ∘ f = h ∘ f) : g = h
theorem number_field.ring_of_integers.not_is_field (K : Type u_1) [field K] [number_field K] : ¬is_field ↥(number_field.ring_of_integers K)
theorem measure_theory.measure.absolutely_continuous_iff_with_density_rn_deriv_eq {α : Type u_1} {m : measurable_space α} {μ ν : measure_theory.measure α} [μ.have_lebesgue_decomposition ν] : μ.absolutely_continuous ν ↔ ν.with_density (μ.rn_deriv ν) = μ
theorem diff_cont_on_cl.has_fpower_series_on_ball {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] {R : nnreal} {c : ℂ} {f : ℂ → E} (hf : diff_cont_on_cl ℂ f (metric.ball c ↑R)) (hR : 0 < R) : has_fpower_series_on_ball f (cauchy_power_series f c ↑R) c ↑R
theorem fundamental_groupoid_functor.proj_map {I : Type u} (X : I → Top) (i : I) (x₀ x₁ : ↥(fundamental_groupoid.fundamental_groupoid_functor.obj (Top.of (Π (i : I), ↥(X i))))) (p : x₀ ⟶ x₁) : (fundamental_groupoid_functor.proj X i).map p = path.homotopic.proj i p
theorem nat.sub_succ' (a b : ℕ) : a - b.succ = a - b - 1
theorem discrete_topology_induced {X : Type u_1} {Y : Type u_2} [tY : topological_space Y] [discrete_topology Y] {f : X → Y} (hf : function.injective f) : discrete_topology X
theorem matrix.pivot.mul_list_transvec_row_last_row {𝕜 : Type u_3} [field 𝕜] {r : ℕ} (M : matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜) (hM : M (sum.inr ()) (sum.inr ()) ≠ 0) (i : fin r) : M.mul (matrix.pivot.list_transvec_row M).prod (sum.inr ()) (sum.inl i) = 0
theorem filter.is_bounded.is_cobounded_flip {α : Type u_1} {r : α → α → Prop} {f : filter α} [is_trans α r] [f.ne_bot] : filter.is_bounded r f → filter.is_cobounded (flip r) f
theorem cardinal.cantor_function_injective {c : ℝ} (h1 : 0 < c) (h2 : c < 1 / 2) : function.injective (cardinal.cantor_function c)
theorem orientation.rotation_pi {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) : o.rotation ↑real.pi = linear_isometry_equiv.neg ℝ
theorem polynomial.dickson_one_one_mul (R : Type u_1) [comm_ring R] (m n : ℕ) : polynomial.dickson 1 1 (m * n) = (polynomial.dickson 1 1 m).comp (polynomial.dickson 1 1 n)
theorem max_cases {α : Type u} [linear_order α] (a b : α) : linear_order.max a b = a ∧ b ≤ a ∨ linear_order.max a b = b ∧ a < b
theorem finset.prod_comm' {β : Type u} {α : Type v} {γ : Type w} [comm_monoid β] {s : finset γ} {t : γ → finset α} {t' : finset α} {s' : α → finset γ} (h : ∀ (x : γ) (y : α), x ∈ s ∧ y ∈ t x ↔ x ∈ s' y ∧ y ∈ t') {f : γ → α → β} : s.prod (λ (x : γ), (t x).prod (λ (y : α), f x y)) = t'.prod (λ (y : α), (s' y).prod (λ (x : γ), f x y))
theorem affine_subspace.le_def' {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P) : s1 ≤ s2 ↔ ∀ (p : P), p ∈ s1 → p ∈ s2
theorem sylow.normalizer_sup_eq_top {G : Type u_1} [group G] {p : ℕ} [fact (nat.prime p)] {N : subgroup G} [N.normal] [fintype (sylow p ↥N)] (P : sylow p ↥N) : (subgroup.map N.subtype ↑P).normalizer ⊔ N = ⊤
theorem dense.quotient {α : Type u} [setoid α] [topological_space α] {s : set α} (H : dense s) : dense (quotient.mk '' s)
theorem complete_lattice.lsum_comp_map_range_to_span_singleton {ι : Type u_1} {R : Type u_2} {N : Type u_5} [dec_ι : decidable_eq ι] [semiring R] [add_comm_monoid N] [module R N] [Π (m : R), decidable (m ≠ 0)] (p : ι → submodule R N) {v : ι → N} (hv : ∀ (i : ι), v i ∈ p i) : (⇑(dfinsupp.lsum ℕ) (λ (i : ι), (p i).subtype)).comp ((dfinsupp.map_range.linear_map (λ (i : ι), linear_map.to_span_singleton R ↥(p i) ⟨v i, _⟩)).comp (finsupp_lequiv_dfinsupp R).to_linear_map) = finsupp.total ι N R v
theorem cauchy_seq_of_edist_le_geometric {α : Type u_1} [pseudo_emetric_space α] (r C : ennreal) (hr : r < 1) (hC : C ≠ ⊤) {f : ℕ → α} (hu : ∀ (n : ℕ), has_edist.edist (f n) (f (n + 1)) ≤ C * r ^ n) : cauchy_seq f
theorem subring.closure_le {R : Type u} [ring R] {s : set R} {t : subring R} : subring.closure s ≤ t ↔ s ⊆ ↑t
theorem exists_pos_lt_subset_ball {α : Type u} [pseudo_metric_space α] [proper_space α] {x : α} {r : ℝ} {s : set α} (hr : 0 < r) (hs : is_closed s) (h : s ⊆ metric.ball x r) : ∃ (r' : ℝ) (H : r' ∈ set.Ioo 0 r), s ⊆ metric.ball x r'
theorem measure_theory.vadd_invariant_measure_tfae (G : Type u_1) {α : Type u_3} {m : measurable_space α} [add_group G] [add_action G α] [measurable_space G] [has_measurable_vadd G α] (μ : measure_theory.measure α) : [measure_theory.vadd_invariant_measure G α μ, ∀ (c : G) (s : set α), measurable_set s → ⇑μ (has_vadd.vadd c ⁻¹' s) = ⇑μ s, ∀ (c : G) (s : set α), measurable_set s → ⇑μ (c +ᵥ s) = ⇑μ s, ∀ (c : G) (s : set α), ⇑μ (has_vadd.vadd c ⁻¹' s) = ⇑μ s, ∀ (c : G) (s : set α), ⇑μ (c +ᵥ s) = ⇑μ s, ∀ (c : G), measure_theory.measure.map (has_vadd.vadd c) μ = μ, ∀ (c : G), measure_theory.measure_preserving (has_vadd.vadd c) μ μ].tfae
theorem linear_map.adjoint_inner_right {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [inner_product_space 𝕜 F] [finite_dimensional 𝕜 E] [finite_dimensional 𝕜 F] (A : E →ₗ[𝕜] F) (x : E) (y : F) : has_inner.inner x (⇑(⇑linear_map.adjoint A) y) = has_inner.inner (⇑A x) y
theorem strict_convex_space.of_strict_convex_closed_unit_ball (𝕜 : Type u_1) {E : Type u_2} [normed_linear_ordered_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_space ℝ E] [linear_map.compatible_smul E E 𝕜 ℝ] (h : strict_convex 𝕜 (metric.closed_ball 0 1)) : strict_convex_space 𝕜 E
theorem quadratic_form.to_fun_eq_coe {R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] {Q : quadratic_form R M} : Q.to_fun = ⇑Q
theorem category_theory.initial_mono {C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] {I : C} (B : C) (t : category_theory.limits.is_initial I) [category_theory.cartesian_closed C] : category_theory.mono (t.to B)
theorem category_theory.limits.image.ι_zero' {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_equalizers C] {X Y : C} {f : X ⟶ Y} (h : f = 0) [category_theory.limits.has_image f] : category_theory.limits.image.ι f = 0
theorem measure_theory.ext_of_generate_finite {α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} (C : set (set α)) (hA : m0 = measurable_space.generate_from C) (hC : is_pi_system C) [measure_theory.is_finite_measure μ] (hμν : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s) (h_univ : ⇑μ set.univ = ⇑ν set.univ) : μ = ν
theorem subgroup.mul_normal {G : Type u_1} [group G] (H N : subgroup G) [N.normal] : ↑(H ⊔ N) = ↑H * ↑N
theorem generalized_continued_fraction.squash_seq_eq_self_of_terminated {K : Type u_1} {n : ℕ} {s : seq (generalized_continued_fraction.pair K)} [division_ring K] (terminated_at_succ_n : s.terminated_at (n + 1)) : generalized_continued_fraction.squash_seq s n = s
theorem finset.affine_combination_eq_weighted_vsub_of_point_vadd_of_sum_eq_one {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (w : ι → k) (p : ι → P) (h : s.sum (λ (i : ι), w i) = 1) (b : P) : ⇑(s.affine_combination p) w = ⇑(s.weighted_vsub_of_point p b) w +ᵥ b
theorem acc.game_add {α : Type u_1} {β : Type u_2} {rα : α → α → Prop} {rβ : β → β → Prop} {a : α} {b : β} (ha : acc rα a) (hb : acc rβ b) : acc (relation.game_add rα rβ) (a, b)
theorem exists_Union_eq_closed_subset {ι : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : ι → set X} (uo : ∀ (i : ι), is_open (u i)) (uf : ∀ (x : X), {i : ι | x ∈ u i}.finite) (uU : (⋃ (i : ι), u i) = set.univ) : ∃ (v : ι → set X), set.Union v = set.univ ∧ (∀ (i : ι), is_closed (v i)) ∧ ∀ (i : ι), v i ⊆ u i
theorem continuous_on.strongly_measurable_at_filter_nhds_within {α : Type u_1} {β : Type u_2} [measurable_space α] [topological_space α] [opens_measurable_space α] [topological_space β] [topological_space.pseudo_metrizable_space β] [second_countable_topology_either α β] {f : α → β} {s : set α} {μ : measure_theory.measure α} (hf : continuous_on f s) (hs : measurable_set s) (x : α) : strongly_measurable_at_filter f (nhds_within x s) μ
theorem category_theory.monad.has_limit_of_comp_forget_has_limit {C : Type u₁} [category_theory.category C] {T : category_theory.monad C} {J : Type u} [category_theory.category J] (D : J ⥤ T.algebra) [category_theory.limits.has_limit (D ⋙ T.forget)] : category_theory.limits.has_limit D
theorem tendsto_one_plus_div_rpow_exp (t : ℝ) : filter.tendsto (λ (x : ℝ), (1 + t / x) ^ x) filter.at_top (nhds (real.exp t))
theorem convex.antitone_on_of_deriv_nonpos {D : set ℝ} (hD : convex ℝ D) {f : ℝ → ℝ} (hf : continuous_on f D) (hf' : differentiable_on ℝ f (interior D)) (hf'_nonpos : ∀ (x : ℝ), x ∈ interior D → deriv f x ≤ 0) : antitone_on f D
theorem function.involutive.eq_iff {α : Sort u} {f : α → α} (h : function.involutive f) {x y : α} : f x = y ↔ x = f y
theorem zmod.nat_cast_zmod_val {n : ℕ} [fact (0 < n)] (a : zmod n) : ↑(a.val) = a
theorem nat.frequently_modeq {n : ℕ} (h : n ≠ 0) (d : ℕ) : ∃ᶠ (m : ℕ) in filter.at_top, m ≡ d [MOD n]
theorem basis.eq_of_repr_eq_repr {ι : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] {b₁ b₂ : basis ι R M} (h : ∀ (x : M) (i : ι), ⇑(⇑(b₁.repr) x) i = ⇑(⇑(b₂.repr) x) i) : b₁ = b₂
theorem is_local_min.has_deriv_at_eq_zero {f : ℝ → ℝ} {f' a : ℝ} (h : is_local_min f a) (hf : has_deriv_at f f' a) : f' = 0
theorem analytic_on.cont_diff_on {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {s : set E} [complete_space F] (h : analytic_on 𝕜 f s) {n : with_top ℕ} : cont_diff_on 𝕜 n f s
theorem monoid_algebra.mem_span_support {k : Type u₁} {G : Type u₂} [semiring k] [mul_one_class G] (f : monoid_algebra k G) : f ∈ submodule.span k (⇑(monoid_algebra.of k G) '' ↑(f.support))
theorem category_theory.functor.initial_of_adjunction {C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] {L : C ⥤ D} {R : D ⥤ C} (adj : L ⊣ R) : L.initial
theorem list.prod_eq_zero_iff {M₀ : Type u_6} [monoid_with_zero M₀] [nontrivial M₀] [no_zero_divisors M₀] {L : list M₀} : L.prod = 0 ↔ 0 ∈ L
theorem is_torsion.add_subgroup {G : Type u_1} [add_group G] (tG : add_monoid.is_torsion G) (H : add_subgroup G) : add_monoid.is_torsion ↥H
theorem right.one_lt_mul' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
theorem convex.mem_Ioo {𝕜 : Type u_1} [linear_ordered_field 𝕜] {x y : 𝕜} (h : x < y) {z : 𝕜} : z ∈ set.Ioo x y ↔ ∃ (a b : 𝕜), 0 < a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z
theorem generalized_continued_fraction.terminated_stable {K : Type u_1} {g : generalized_continued_fraction K} {n m : ℕ} (n_le_m : n ≤ m) (terminated_at_n : g.terminated_at n) : g.terminated_at m
theorem is_submonoid.pow_mem {M : Type u_1} [monoid M] {s : set M} {a : M} (hs : is_submonoid s) (h : a ∈ s) {n : ℕ} : a ^ n ∈ s
theorem has_fderiv_within_at.has_mfderiv_within_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {f : E → E'} {s : set E} {x : E} {f' : tangent_space (model_with_corners_self 𝕜 E) x →L[𝕜] tangent_space (model_with_corners_self 𝕜 E') (f x)} : has_fderiv_within_at f f' s x → has_mfderiv_within_at (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f s x f'
theorem affine_subspace.span_points_subset_coe_of_subset_coe {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {s1 : affine_subspace k P} (h : s ⊆ ↑s1) : span_points k s ⊆ ↑s1
theorem fintype.exists_lt_sum_fiber_of_nsmul_lt_sum {α : Type u} {β : Type v} {M : Type w} [decidable_eq β] [fintype α] [fintype β] (f : α → β) {w : α → M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (hb : fintype.card β • b < finset.univ.sum (λ (x : α), w x)) : ∃ (y : β), b < (finset.filter (λ (x : α), f x = y) finset.univ).sum (λ (x : α), w x)
theorem continuous_map.dist_le {α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β] {f g : C(α, β)} {C : ℝ} (C0 : 0 ≤ C) : has_dist.dist f g ≤ C ↔ ∀ (x : α), has_dist.dist (⇑f x) (⇑g x) ≤ C
theorem leibniz_cross {R : Type u_1} [comm_ring R] (u v w : fin 3 → R) : ⇑(⇑cross_product u) (⇑(⇑cross_product v) w) = ⇑(⇑cross_product (⇑(⇑cross_product u) v)) w + ⇑(⇑cross_product v) (⇑(⇑cross_product u) w)
theorem finset.card_mul_le_card_mul {α : Type u_1} {β : Type u_2} (r : α → β → Prop) {s : finset α} {t : finset β} {m n : ℕ} [Π (a : α) (b : β), decidable (r a b)] (hm : ∀ (a : α), a ∈ s → m ≤ (finset.bipartite_above r t a).card) (hn : ∀ (b : β), b ∈ t → (finset.bipartite_below r s b).card ≤ n) : s.card * m ≤ t.card * n
theorem metric.forall_of_forall_mem_ball {α : Type u} [pseudo_metric_space α] (p : α → Prop) (x : α) (H : ∃ᶠ (R : ℝ) in filter.at_top, ∀ (y : α), y ∈ metric.ball x R → p y) (y : α) : p y
theorem is_upper_set.to_dual {α : Type u_1} [has_le α] {s : set αᵒᵈ} : is_upper_set s → is_lower_set (⇑order_dual.to_dual ⁻¹' s)
theorem algebra.left_comm {R : Type u} {A : Type w} [comm_semiring R] [semiring A] [algebra R A] (x : A) (r : R) (y : A) : x * (⇑(algebra_map R A) r * y) = ⇑(algebra_map R A) r * (x * y)
theorem is_primitive_root.disjoint {R : Type u_5} [comm_ring R] [is_domain R] {k l : ℕ} (h : k ≠ l) : disjoint (primitive_roots k R) (primitive_roots l R)
theorem is_right_regular_of_right_cancel_semigroup {R : Type u_1} [right_cancel_semigroup R] (g : R) : is_right_regular g
theorem finite_cover_balls_of_compact {α : Type u} [pseudo_metric_space α] {s : set α} (hs : is_compact s) {e : ℝ} (he : 0 < e) : ∃ (t : set α) (H : t ⊆ s), t.finite ∧ s ⊆ ⋃ (x : α) (H : x ∈ t), metric.ball x e
theorem set.Icc_diff_pi_univ_Ioo_subset {ι : Type u_1} {α : ι → Type u_2} [decidable_eq ι] [Π (i : ι), linear_order (α i)] (x y x' y' : Π (i : ι), α i) : set.Icc x y  set.univ.pi (λ (i : ι), set.Ioo (x' i) (y' i)) ⊆ (⋃ (i : ι), set.Icc x (function.update y i (x' i))) ∪ ⋃ (i : ι), set.Icc (function.update x i (y' i)) y
theorem le_nhds_of_cauchy_adhp {α : Type u} [uniform_space α] {f : filter α} {x : α} (hf : cauchy f) (adhs : cluster_pt x f) : f ≤ nhds x
theorem equiv.perm.cycle_factors_finset_injective {α : Type u_1} [decidable_eq α] [fintype α] : function.injective equiv.perm.cycle_factors_finset
theorem units.coe_dvd {α : Type u_1} [monoid α] {a : α} {u : αˣ} : ↑u ∣ a
theorem fintype.exists_card_fiber_le_of_card_le_nsmul {α : Type u} {β : Type v} {M : Type w} [decidable_eq β] [fintype α] [fintype β] (f : α → β) {b : M} [linear_ordered_comm_ring M] [nonempty β] (hb : ↑(fintype.card α) ≤ fintype.card β • b) : ∃ (y : β), ↑((finset.filter (λ (x : α), f x = y) finset.univ).card) ≤ b
theorem finset.sum_card_inter {α : Type u_2} [decidable_eq α] {s : finset α} {B : finset (finset α)} {n : ℕ} (h : ∀ (a : α), a ∈ s → (finset.filter (has_mem.mem a) B).card = n) : B.sum (λ (t : finset α), (s ∩ t).card) = s.card * n
theorem finset.exists_le_sum_fiber_of_sum_fiber_nonpos_of_nsmul_le_sum {α : Type u} {β : Type v} {M : Type w} [decidable_eq β] {s : finset α} {t : finset β} {f : α → β} {w : α → M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (hf : ∀ (y : β), y ∉ t → (finset.filter (λ (x : α), f x = y) s).sum (λ (x : α), w x) ≤ 0) (ht : t.nonempty) (hb : t.card • b ≤ s.sum (λ (x : α), w x)) : ∃ (y : β) (H : y ∈ t), b ≤ (finset.filter (λ (x : α), f x = y) s).sum (λ (x : α), w x)
theorem reflection_reflection {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) [complete_space ↥K] (p : E) : ⇑(reflection K) (⇑(reflection K) p) = p
theorem real.summable_one_div_nat_pow {p : ℕ} : summable (λ (n : ℕ), 1 / ↑n ^ p) ↔ 1 < p
theorem is_compact_of_finite_subfamily_closed {α : Type u} [topological_space α] {s : set α} (h : ∀ {ι : Type u} (Z : ι → set α), (∀ (i : ι), is_closed (Z i)) → (s ∩ ⋂ (i : ι), Z i) = ∅ → (∃ (t : finset ι), (s ∩ ⋂ (i : ι) (H : i ∈ t), Z i) = ∅)) : is_compact s
theorem compact_open_separated_mul_left {G : Type w} [topological_space G] [group G] [topological_group G] {K U : set G} (hK : is_compact K) (hU : is_open U) (hKU : K ⊆ U) : ∃ (V : set G) (H : V ∈ nhds 1), V * K ⊆ U
theorem no_min_order.infinite {α : Type u_1} [preorder α] [nonempty α] [no_min_order α] : infinite α
theorem cont_diff_succ_iff_fderiv_apply {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] [complete_space 𝕜] [finite_dimensional 𝕜 E] {n : ℕ} {f : E → F} : cont_diff 𝕜 ↑(n + 1) f ↔ differentiable 𝕜 f ∧ ∀ (y : E), cont_diff 𝕜 ↑n (λ (x : E), ⇑(fderiv 𝕜 f x) y)
theorem matrix.det_from_blocks₂₂ {m : Type u} {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] [fintype m] [decidable_eq m] (A : matrix m m α) (B : matrix m n α) (C : matrix n m α) (D : matrix n n α) [invertible D] : (matrix.from_blocks A B C D).det = D.det * (A - (B.mul (⅟ D)).mul C).det
theorem linear_map.aeval_eq_aeval_mod_charpoly {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M →ₗ[R] M) (p : polynomial R) : ⇑(polynomial.aeval f) p = ⇑(polynomial.aeval f) (p %ₘ f.charpoly)
theorem Top.presheaf.is_gluing_iff_eq_res {X : Top} (F : Top.presheaf (Type v) X) {ι : Type v} (U : ι → topological_space.opens ↥X) (sf : Top.presheaf.sheaf_condition_equalizer_products.pi_opens F U) (s : F.obj (opposite.op (supr U))) : F.is_gluing U ((F.pi_opens_iso_sections_family U).hom sf) s ↔ Top.presheaf.sheaf_condition_equalizer_products.res F U s = sf
theorem monotone_on.convex_on_of_deriv {D : set ℝ} (hD : convex ℝ D) {f : ℝ → ℝ} (hf : continuous_on f D) (hf' : differentiable_on ℝ f (interior D)) (hf'_mono : monotone_on (deriv f) (interior D)) : convex_on ℝ D f
theorem antitone.cauchy_seq_alternating_series_of_tendsto_zero {f : ℕ → ℝ} (hfa : antitone f) (hf0 : filter.tendsto f filter.at_top (nhds 0)) : cauchy_seq (λ (n : ℕ), (finset.range (n + 1)).sum (λ (i : ℕ), (-1) ^ i * f i))
theorem Vieta_formula_quadratic {α : Type u} [non_unital_comm_ring α] {b c x : α} (h : x * x - b * x + c = 0) : ∃ (y : α), y * y - b * y + c = 0 ∧ x + y = b ∧ x * y = c
theorem is_min_on.of_is_local_min_on_of_convex_on_Icc {β : Type u_2} [ordered_add_comm_group β] [module ℝ β] [ordered_smul ℝ β] {f : ℝ → β} {a b : ℝ} (a_lt_b : a < b) (h_local_min : is_local_min_on f (set.Icc a b) a) (h_conv : convex_on ℝ (set.Icc a b) f) : is_min_on f (set.Icc a b) a
theorem free_product.ext_hom {ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] {N : Type u_3} [monoid N] (f g : free_product M →* N) (h : ∀ (i : ι), f.comp free_product.of = g.comp free_product.of) : f = g
theorem con.ext_iff {M : Type u_1} [has_mul M] {c d : con M} : (∀ (x y : M), ⇑c x y ↔ ⇑d x y) ↔ c = d
theorem finsupp.inner_sum {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_3} (l : ι →₀ 𝕜) (v : ι → E) (x : E) : has_inner.inner x (l.sum (λ (i : ι) (a : 𝕜), a • v i)) = l.sum (λ (i : ι) (a : 𝕜), a • has_inner.inner x (v i))
theorem power_series.le_order_add {R : Type u_1} [semiring R] (φ ψ : power_series R) : linear_order.min φ.order ψ.order ≤ (φ + ψ).order
theorem norm_mk_nonneg {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) : 0 ≤ ∥⇑(quotient_add_group.mk' S) m∥
theorem norm_add_mul_self {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x y : E} : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + 2 * ⇑is_R_or_C.re (has_inner.inner x y) + ∥y∥ * ∥y∥
theorem local_homeomorph.has_fderiv_at_symm {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] (f : local_homeomorph E F) {f' : E ≃L[𝕜] F} {a : F} (ha : a ∈ f.to_local_equiv.target) (htff' : has_fderiv_at ⇑f ↑f' (⇑(f.symm) a)) : has_fderiv_at ⇑(f.symm) ↑(f'.symm) a
theorem setoid.mk_classes_classes {α : Type u_1} (r : setoid α) : setoid.mk_classes r.classes setoid.classes_eqv_classes = r
theorem generate_from_eq_prod {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {C : set (set α)} {D : set (set β)} (hC : measurable_space.generate_from C = _inst_1) (hD : measurable_space.generate_from D = _inst_3) (h2C : is_countably_spanning C) (h2D : is_countably_spanning D) : measurable_space.generate_from (set.image2 has_set_prod.prod C D) = prod.measurable_space
theorem cardinal.mk_Ici_real (a : ℝ) : cardinal.mk ↥(set.Ici a) = cardinal.continuum
theorem vitali_family.ae_tendsto_measure_inter_div_of_measurable_set {α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {s : set α} (hs : measurable_set s) : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (a : set α), ⇑μ (s ∩ a) / ⇑μ a) (v.filter_at x) (nhds (s.indicator 1 x))
theorem same_ray.symm {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} (h : same_ray R x y) : same_ray R y x
theorem polynomial.gal.gal_action_hom_bijective_of_prime_degree {p : polynomial ℚ} (p_irr : irreducible p) (p_deg : nat.prime p.nat_degree) (p_roots : fintype.card ↥(p.root_set ℂ) = fintype.card ↥(p.root_set ℝ) + 2) : function.bijective ⇑(polynomial.gal.gal_action_hom p ℂ)
theorem add_equiv.symm_apply_apply {M : Type u_6} {N : Type u_7} [has_add M] [has_add N] (e : M ≃+ N) (x : M) : ⇑(e.symm) (⇑e x) = x
theorem measure_theory.measure.preimage_null_of_map_null {α : Type u_1} {β : Type u_2} {m0 : measurable_space α} [measurable_space β] {μ : measure_theory.measure α} {f : α → β} (hf : ae_measurable f μ) {s : set β} (hs : ⇑(measure_theory.measure.map f μ) s = 0) : ⇑μ (f ⁻¹' s) = 0
theorem formal_multilinear_series.comp_along_composition_bound {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] [normed_group G] [normed_space 𝕜 G] {n : ℕ} (p : formal_multilinear_series 𝕜 E F) (c : composition n) (f : continuous_multilinear_map 𝕜 (λ (i : fin c.length), F) G) (v : fin n → E) : ∥⇑(continuous_multilinear_map.comp_along_composition p c f) v∥ ≤ ∥f∥ * finset.univ.prod (λ (i : fin c.length), ∥p (c.blocks_fun i)∥) * finset.univ.prod (λ (i : fin n), ∥v i∥)
theorem submonoid.closure_mono {M : Type u_1} [mul_one_class M] ⦃s t : set M⦄ (h : s ⊆ t) : submonoid.closure s ≤ submonoid.closure t
theorem one_div_lt_one_div {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : 1 / a < 1 / b ↔ b < a
theorem convex_iff_div {𝕜 : Type u_1} {E : Type u_2} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] {s : set E} : convex 𝕜 s ↔ ∀ ⦃x y : E⦄, x ∈ s → y ∈ s → ∀ ⦃a b : 𝕜⦄, 0 ≤ a → 0 ≤ b → 0 < a + b → (a / (a + b)) • x + (b / (a + b)) • y ∈ s
theorem innerSL_apply_norm {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x : E} : ∥⇑innerSL x∥ = ∥x∥
theorem filter.at_top_le_cofinite {α : Type u_2} [preorder α] [no_max_order α] : filter.at_top ≤ filter.cofinite
theorem padic_int.lift_spec {p : ℕ} [hp_prime : fact (nat.prime p)] {R : Type u_1} [non_assoc_semiring R] {f : Π (k : ℕ), R →+* zmod (p ^ k)} (f_compat : ∀ (k1 k2 : ℕ) (hk : k1 ≤ k2), (zmod.cast_hom _ (zmod (p ^ k1))).comp (f k2) = f k1) (n : ℕ) : (padic_int.to_zmod_pow n).comp (padic_int.lift f_compat) = f n
theorem local_ring.of_unique_max_ideal {R : Type u} [comm_semiring R] (h : ∃! (I : ideal R), I.is_maximal) : local_ring R
theorem finset.prod_subtype_map_embedding {β : Type u} {α : Type v} [comm_monoid β] {p : α → Prop} {s : finset {x // p x}} {f : {x // p x} → β} {g : α → β} (h : ∀ (x : {x // p x}), x ∈ s → g ↑x = f x) : (finset.map (function.embedding.subtype (λ (x : α), p x)) s).prod (λ (x : α), g x) = s.prod (λ (x : {x // p x}), f x)
theorem set.mem_fintype_sum {α : Type u_2} {ι : Type u_5} [add_comm_monoid α] [fintype ι] (f : ι → set α) (a : α) : a ∈ finset.univ.sum (λ (i : ι), f i) ↔ ∃ (g : ι → α) (hg : ∀ (i : ι), g i ∈ f i), finset.univ.sum (λ (i : ι), g i) = a
theorem polynomial.taylor_coeff {R : Type u_1} [semiring R] (r : R) (f : polynomial R) (n : ℕ) : (⇑(polynomial.taylor r) f).coeff n = polynomial.eval r (⇑(polynomial.hasse_deriv n) f)
theorem nat.upto.wf {p : ℕ → Prop} : (∃ (x : ℕ), p x) → well_founded (nat.upto.gt p)
theorem measure_theory.tendsto_uniformly_on_of_ae_tendsto {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} [metric_space β] {μ : measure_theory.measure α} [semilattice_sup ι] [nonempty ι] [encodable ι] {f : ι → α → β} {g : α → β} {s : set α} (hf : ∀ (n : ι), measure_theory.strongly_measurable (f n)) (hg : measure_theory.strongly_measurable g) (hsm : measurable_set s) (hs : ⇑μ s ≠ ⊤) (hfg : ∀ᵐ (x : α) ∂μ, x ∈ s → filter.tendsto (λ (n : ι), f n x) filter.at_top (nhds (g x))) {ε : ℝ} (hε : 0 < ε) : ∃ (t : set α) (H : t ⊆ s), measurable_set t ∧ ⇑μ t ≤ ennreal.of_real ε ∧ tendsto_uniformly_on f g filter.at_top (s  t)
theorem exists_closed_cover_approximates_linear_on_of_has_fderiv_within_at {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] [normed_group F] [normed_space ℝ F] [topological_space.second_countable_topology F] (f : E → F) (s : set E) (f' : E → (E →L[ℝ] F)) (hf' : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (r : (E →L[ℝ] F) → nnreal) (rpos : ∀ (A : E →L[ℝ] F), r A ≠ 0) : ∃ (t : ℕ → set E) (A : ℕ → (E →L[ℝ] F)), (∀ (n : ℕ), is_closed (t n)) ∧ (s ⊆ ⋃ (n : ℕ), t n) ∧ (∀ (n : ℕ), approximates_linear_on f (A n) (s ∩ t n) (r (A n))) ∧ (s.nonempty → ∀ (n : ℕ), ∃ (y : E) (H : y ∈ s), A n = f' y)
theorem bilin_form.restrict_nondegenerate_iff_is_compl_orthogonal {V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {B : bilin_form K V} {W : subspace K V} (b₁ : B.is_refl) : (B.restrict W).nondegenerate ↔ is_compl W (B.orthogonal W)
theorem category_theory.presieve.family_of_elements.compatible.functor_pushforward {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {K : category_theory.grothendieck_topology D} {G : C ⥤ D} (hG : category_theory.compatible_preserving K G) (ℱ : category_theory.SheafOfTypes K) {Z : C} {T : category_theory.presieve Z} {x : category_theory.presieve.family_of_elements (G.op ⋙ ℱ.val) T} (h : x.compatible) : (category_theory.presieve.family_of_elements.functor_pushforward G x).compatible
theorem mv_polynomial.prod_X_add_C_eval {R : Type u_1} [comm_semiring R] (σ : Type u_2) [fintype σ] (r : σ → R) : finset.univ.prod (λ (i : σ), ⇑polynomial.C (r i) + polynomial.X) = (finset.range (fintype.card σ + 1)).sum (λ (i : ℕ), (finset.powerset_len i finset.univ).sum (λ (t : finset σ), t.prod (λ (i : σ), ⇑polynomial.C (r i))) * polynomial.X ^ (fintype.card σ - i))
theorem norm_image_sub_le_of_norm_deriv_right_le_segment {E : Type u_1} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} {f' : ℝ → E} {C : ℝ} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at f (f' x) (set.Ici x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → ∥f' x∥ ≤ C) (x : ℝ) (H : x ∈ set.Icc a b) : ∥f x - f a∥ ≤ C * (x - a)
theorem has_lt.lt.ne_top {α : Type u} [preorder α] [order_top α] {a b : α} (h : a < b) : a ≠ ⊤
theorem subgroup.closure_mono {G : Type u_1} [group G] ⦃h k : set G⦄ (h' : h ⊆ k) : subgroup.closure h ≤ subgroup.closure k
theorem con.lift_surjective_of_surjective {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} {f : M →* P} (h : c ≤ con.ker f) (hf : function.surjective ⇑f) : function.surjective ⇑(c.lift f h)
theorem squeeze_zero' {α : Type u_1} {f g : α → ℝ} {t₀ : filter α} (hf : ∀ᶠ (t : α) in t₀, 0 ≤ f t) (hft : ∀ᶠ (t : α) in t₀, f t ≤ g t) (g0 : filter.tendsto g t₀ (nhds 0)) : filter.tendsto f t₀ (nhds 0)
theorem nnreal.inner_le_Lp_mul_Lq_tsum {ι : Type u} {f g : ι → nnreal} {p q : ℝ} (hpq : p.is_conjugate_exponent q) (hf : summable (λ (i : ι), f i ^ p)) (hg : summable (λ (i : ι), g i ^ q)) : summable (λ (i : ι), f i * g i) ∧ ∑' (i : ι), f i * g i ≤ (∑' (i : ι), f i ^ p) ^ (1 / p) * (∑' (i : ι), g i ^ q) ^ (1 / q)
theorem finite_dimensional.of_fintype_basis {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type w} [fintype ι] (h : basis ι K V) : finite_dimensional K V
theorem set.pairwise.subsingleton {α : Type u_1} {s : set α} : s.pairwise ⊥ → s.subsingleton
theorem is_o_pow_const_mul_const_pow_const_pow_of_norm_lt {R : Type u_1} [normed_ring R] (k : ℕ) {r₁ : R} {r₂ : ℝ} (h : ∥r₁∥ < r₂) : (λ (n : ℕ), ↑n ^ k * r₁ ^ n) =o[filter.at_top] λ (n : ℕ), r₂ ^ n
theorem list.drop_append_eq_append_drop {α : Type u} {l₁ l₂ : list α} {n : ℕ} : list.drop n (l₁ ++ l₂) = list.drop n l₁ ++ list.drop (n - l₁.length) l₂
theorem fintype.linear_independent_iff' {ι : Type u_1} {R : Type u_3} {M : Type u_5} {v : ι → M} [semiring R] [add_comm_monoid M] [module R M] [fintype ι] : linear_independent R v ↔ (⇑(linear_map.lsum R (λ (i : ι), R) ℕ) (λ (i : ι), linear_map.id.smul_right (v i))).ker = ⊥
theorem category_theory.grothendieck_topology.intersection_covering {C : Type u} [category_theory.category C] {X : C} {S R : category_theory.sieve X} (J : category_theory.grothendieck_topology C) (rj : R ∈ ⇑J X) (sj : S ∈ ⇑J X) : R ⊓ S ∈ ⇑J X
theorem category_theory.limits.initial_mono_class.of_terminal {C : Type u₁} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] (h : category_theory.mono (category_theory.limits.initial.to (⊤_ C))) : category_theory.limits.initial_mono_class C
theorem first_order.language.age_direct_limit {L : first_order.language} {ι : Type w} [preorder ι] [is_directed ι has_le.le] [nonempty ι] (G : ι → Type (max w w')) [Π (i : ι), L.Structure (G i)] (f : Π (i j : ι), i ≤ j → L.embedding (G i) (G j)) [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] : L.age (first_order.language.direct_limit G f) = ⋃ (i : ι), L.age (G i)
theorem witt_vector.add_is_poly₂ {p : ℕ} [fact (nat.prime p)] : witt_vector.is_poly₂ p (λ (_x : Type u_1) (_x_1 : comm_ring _x), has_add.add)
theorem finprod_mem_insert_of_eq_one_if_not_mem {α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M} {a : α} {s : set α} (h : a ∉ s → f a = 1) : finprod (λ (i : α), finprod (λ (H : i ∈ has_insert.insert a s), f i)) = finprod (λ (i : α), finprod (λ (H : i ∈ s), f i))
theorem is_extr_filter.dual {α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α} : is_extr_filter f l a → is_extr_filter (⇑order_dual.to_dual ∘ f) l a
theorem is_dedekind_domain.height_one_spectrum.int_valuation_exists_uniformizer {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) : ∃ (π : R), v.int_valuation_def π = ↑(⇑multiplicative.of_add (-1))
theorem commute.add_pow {R : Type u_1} [semiring R] {x y : R} (h : commute x y) (n : ℕ) : (x + y) ^ n = (finset.range (n + 1)).sum (λ (m : ℕ), x ^ m * y ^ (n - m) * ↑(n.choose m))
theorem trans_gen_of_pred_of_gt {α : Type u_1} [partial_order α] [pred_order α] [is_pred_archimedean α] (r : α → α → Prop) {n m : α} (h : ∀ (i : α), i ∈ set.Ioc m n → r i (order.pred i)) (hnm : m < n) : relation.trans_gen r n m
theorem monoid_hom.map_mclosure {M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (f : M →* N) (s : set M) : submonoid.map f (submonoid.closure s) = submonoid.closure (⇑f '' s)
theorem submonoid.localization_map.exists_of_sec_mk' {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] (f : S.localization_map N) (x : M) (y : ↥S) : ∃ (c : ↥S), x * ↑((f.sec (f.mk' x y)).snd) * ↑c = (f.sec (f.mk' x y)).fst * ↑y * ↑c
theorem maximal_orthonormal_iff_orthogonal_complement_eq_bot {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {v : set E} (hv : orthonormal 𝕜 coe) : (∀ (u : set E), u ⊇ v → orthonormal 𝕜 coe → u = v) ↔ (submodule.span 𝕜 v)ᗮ = ⊥
theorem multilinear_map.exists_bound_of_continuous {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : multilinear_map 𝕜 E G) (hf : continuous ⇑f) : ∃ (C : ℝ), 0 < C ∧ ∀ (m : Π (i : ι), E i), ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : ι), ∥m i∥)
theorem char.quadratic_char_exists_neg_one {F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F ≠ 2) : ∃ (a : F), char.quadratic_char F a = -1
theorem re_inner_eq_norm_add_mul_self_sub_norm_mul_self_sub_norm_mul_self_div_two {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) : ⇑is_R_or_C.re (has_inner.inner x y) = (∥x + y∥ * ∥x + y∥ - ∥x∥ * ∥x∥ - ∥y∥ * ∥y∥) / 2
theorem add_subgroup.zero_mem {G : Type u_1} [add_group G] (H : add_subgroup G) : 0 ∈ H
theorem finset.exists_smaller_set {α : Type u_1} (A : finset α) (i : ℕ) (h₁ : i ≤ A.card) : ∃ (B : finset α), B ⊆ A ∧ B.card = i
theorem measure_theory.tendsto_in_measure_of_tendsto_ae_of_strongly_measurable {α : Type u_1} {E : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [metric_space E] {f : ℕ → α → E} {g : α → E} [measure_theory.is_finite_measure μ] (hf : ∀ (n : ℕ), measure_theory.strongly_measurable (f n)) (hg : measure_theory.strongly_measurable g) (hfg : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (nhds (g x))) : measure_theory.tendsto_in_measure μ f filter.at_top g
theorem category_theory.abelian.functor.left_derived_zero_to_self_natural {C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (F : C ⥤ D) [category_theory.abelian C] [category_theory.abelian D] [F.additive] [category_theory.enough_projectives C] {X Y : C} (f : X ⟶ Y) (P : category_theory.ProjectiveResolution X) (Q : category_theory.ProjectiveResolution Y) : (F.left_derived 0).map f ≫ category_theory.abelian.functor.left_derived_zero_to_self_app F Q = category_theory.abelian.functor.left_derived_zero_to_self_app F P ≫ F.map f
theorem metric.cauchy_seq_iff' {α : Type u} {β : Type v} [pseudo_metric_space α] [nonempty β] [semilattice_sup β] {u : β → α} : cauchy_seq u ↔ ∀ (ε : ℝ), ε > 0 → (∃ (N : β), ∀ (n : β), n ≥ N → has_dist.dist (u n) (u N) < ε)
theorem bounded_continuous_function.continuous_comp {α : Type u} {β : Type v} {γ : Type w} [topological_space α] [pseudo_metric_space β] [pseudo_metric_space γ] {G : β → γ} {C : nnreal} (H : lipschitz_with C G) : continuous (bounded_continuous_function.comp G H)
theorem order_iso.map_tsub {M : Type u_1} {N : Type u_2} [preorder M] [has_add M] [has_sub M] [has_ordered_sub M] [partial_order N] [has_add N] [has_sub N] [has_ordered_sub N] (e : M ≃o N) (h_add : ∀ (a b : M), ⇑e (a + b) = ⇑e a + ⇑e b) (a b : M) : ⇑e (a - b) = ⇑e a - ⇑e b
theorem Top.presheaf.covering_of_presieve.supr_eq_of_mem_grothendieck {X : Top} (U : topological_space.opens ↥X) (R : category_theory.presieve U) (hR : category_theory.sieve.generate R ∈ ⇑(opens.grothendieck_topology ↥X) U) : supr (Top.presheaf.covering_of_presieve U R) = U
theorem equiv.cardinal_eq {α β : Type u} (e : α ≃ β) : cardinal.mk α = cardinal.mk β
theorem tendsto_div_of_monotone_of_exists_subseq_tendsto_div (u : ℕ → ℝ) (l : ℝ) (hmono : monotone u) (hlim : ∀ (a : ℝ), 1 < a → (∃ (c : ℕ → ℕ), (∀ᶠ (n : ℕ) in filter.at_top, ↑(c (n + 1)) ≤ a * ↑(c n)) ∧ filter.tendsto c filter.at_top filter.at_top ∧ filter.tendsto (λ (n : ℕ), u (c n) / ↑(c n)) filter.at_top (nhds l))) : filter.tendsto (λ (n : ℕ), u n / ↑n) filter.at_top (nhds l)
theorem monovary_on.sum_comp_perm_smul_le_sum_smul {ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {s : finset ι} {σ : equiv.perm ι} {f : ι → α} {g : ι → β} (hfg : monovary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f (⇑σ i) • g i) ≤ s.sum (λ (i : ι), f i • g i)
theorem strict_convex.preimage_add_left {𝕜 : Type u_1} {E : Type u_3} [ordered_semiring 𝕜] [topological_space E] [add_cancel_comm_monoid E] [has_continuous_add E] [module 𝕜 E] {s : set E} (hs : strict_convex 𝕜 s) (z : E) : strict_convex 𝕜 ((λ (x : E), x + z) ⁻¹' s)
theorem dense_range_stone_cech_unit {α : Type u} [topological_space α] : dense_range stone_cech_unit
theorem vsub_mem_vector_span (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p1 p2 : P} (hp1 : p1 ∈ s) (hp2 : p2 ∈ s) : p1 -ᵥ p2 ∈ vector_span k s
theorem measure_theory.integrable.ae_eq_of_with_densityᵥ_eq {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {E : Type u_3} [normed_group E] [normed_space ℝ E] [complete_space E] {f g : α → E} (hf : measure_theory.integrable f μ) (hg : measure_theory.integrable g μ) (hfg : μ.with_densityᵥ f = μ.with_densityᵥ g) : f =ᵐ[μ] g
theorem pgame.fuzzy.lf {x y : pgame} (h : x.fuzzy y) : x.lf y
theorem algebra.norm_eq_prod_embeddings (K : Type u_4) {L : Type u_5} [field K] [field L] [algebra K L] (E : Type u_7) [field E] [algebra K E] [finite_dimensional K L] [is_separable K L] [is_alg_closed E] {x : L} : ⇑(algebra_map K E) (⇑(algebra.norm K) x) = finset.univ.prod (λ (σ : L →ₐ[K] E), ⇑σ x)
theorem euclidean_geometry.orthogonal_projection_mem {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} [nonempty ↥s] [complete_space ↥(s.direction)] (p : P) : ↑(⇑(euclidean_geometry.orthogonal_projection s) p) ∈ s
theorem is_free_group.unique_lift {G : Type u_1} [group G] [is_free_group G] {H : Type u_2} [group H] (f : is_free_group.generators G → H) : ∃! (F : G →* H), ∀ (a : is_free_group.generators G), ⇑F (is_free_group.of a) = f a
theorem probability_theory.meas_ge_le_variance_div_sq {Ω : Type u_1} [measure_theory.measure_space Ω] [measure_theory.is_probability_measure measure_theory.measure_space.volume] {X : Ω → ℝ} (hX : measure_theory.mem_ℒp X 2 measure_theory.measure_space.volume) {c : ℝ} (hc : 0 < c) : ⇑measure_theory.measure_space.volume {ω : Ω | c ≤ |X ω - ∫ (a : Ω), X a|} ≤ ennreal.of_real (probability_theory.variance X measure_theory.measure_space.volume / c ^ 2)
theorem finset.sup_indep.bUnion {α : Type u_1} {ι : Type u_3} {ι' : Type u_4} [distrib_lattice α] [order_bot α] [decidable_eq ι] {s : finset ι'} {g : ι' → finset ι} {f : ι → α} (hs : s.sup_indep (λ (i : ι'), (g i).sup f)) (hg : ∀ (i' : ι'), i' ∈ s → (g i').sup_indep f) : (s.bUnion g).sup_indep f
theorem measure_theory.measurable_image_of_fderiv_within {E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {s : set E} {f : E → E} {f' : E → (E →L[ℝ] E)} [measurable_space E] [borel_space E] (hs : measurable_set s) (hf' : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) : measurable_set (f '' s)
theorem tsub_lt_tsub_iff_left_of_le_of_le {α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b c : α} [contravariant_class α α has_add.add has_le.le] [contravariant_class α α has_add.add has_lt.lt] (h₁ : b ≤ a) (h₂ : c ≤ a) : a - b < a - c ↔ c < b
theorem inner_product_space.is_self_adjoint.coe_re_apply_inner_self_apply {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {T : E →L[𝕜] E} (hT : inner_product_space.is_self_adjoint ↑T) (x : E) : ↑(T.re_apply_inner_self x) = has_inner.inner (⇑T x) x
theorem probability_theory.indep_fun.integral_mul_of_integrable {α : Type u_1} {mα : measurable_space α} {μ : measure_theory.measure α} {X Y : α → ℝ} (hXY : probability_theory.indep_fun X Y μ) (hX : measure_theory.integrable X μ) (hY : measure_theory.integrable Y μ) : measure_theory.integral μ (X * Y) = measure_theory.integral μ X * measure_theory.integral μ Y
theorem ae_strongly_measurable_iff_ae_measurable_separable {α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [topological_space β] {f : α → β} [topological_space.pseudo_metrizable_space β] [measurable_space β] [borel_space β] : measure_theory.ae_strongly_measurable f μ ↔ ae_measurable f μ ∧ ∃ (t : set β), topological_space.is_separable t ∧ ∀ᵐ (x : α) ∂μ, f x ∈ t
theorem quotient_group.monoid_hom_ext {G : Type u} [group G] (N : subgroup G) [nN : N.normal] {H : Type v} [group H] ⦃f g : G ⧸ N →* H⦄ (h : f.comp (quotient_group.mk' N) = g.comp (quotient_group.mk' N)) : f = g
theorem local_equiv.eq_on_source.target_eq {α : Type u_1} {β : Type u_2} {e e' : local_equiv α β} (h : e ≈ e') : e.target = e'.target
theorem submonoid.localization_map.lift_spec {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M →* P} (hg : ∀ (y : ↥S), is_unit (⇑g ↑y)) (z : N) (v : P) : ⇑(f.lift hg) z = v ↔ ⇑g (f.sec z).fst = ⇑g ↑((f.sec z).snd) * v
theorem bounded_std_simplex (ι : Type u_1) [fintype ι] : metric.bounded (std_simplex ℝ ι)
theorem finprod_mem_union_inter {α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M} {s t : set α} (hs : s.finite) (ht : t.finite) : finprod (λ (i : α), finprod (λ (H : i ∈ s ∪ t), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ s ∩ t), f i)) = finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ t), f i))
theorem intermediate_field.adjoin_le_subfield (F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] (S : set E) {K : subfield E} (HF : set.range ⇑(algebra_map F E) ⊆ ↑K) (HS : S ⊆ ↑K) : (intermediate_field.adjoin F S).to_subfield ≤ K
theorem linear_recurrence.is_sol_iff_mem_sol_space {α : Type u_1} [comm_semiring α] (E : linear_recurrence α) (u : ℕ → α) : E.is_solution u ↔ u ∈ E.sol_space
theorem mv_polynomial.is_domain_fin (R : Type u) [comm_ring R] [is_domain R] (n : ℕ) : is_domain (mv_polynomial (fin n) R)
theorem comp_symm_mem_uniformity_sets {α : Type u_1} [uniform_space α] {s : set (α × α)} (hs : s ∈ uniformity α) : ∃ (t : set (α × α)) (H : t ∈ uniformity α), symmetric_rel t ∧ comp_rel t t ⊆ s
theorem measure_theory.measure.measure_to_measurable_inter {α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {s t : set α} (hs : measurable_set s) (ht : ⇑μ t ≠ ⊤) : ⇑μ (measure_theory.to_measurable μ t ∩ s) = ⇑μ (t ∩ s)
theorem cont_mdiff_on.comp {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M → M'} {s : set M} {n : with_top ℕ} {E'' : Type u_14} [normed_group E''] [normed_space 𝕜 E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners 𝕜 E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {t : set M'} {g : M' → M''} (hg : cont_mdiff_on I' I'' n g t) (hf : cont_mdiff_on I I' n f s) (st : s ⊆ f ⁻¹' t) : cont_mdiff_on I I'' n (g ∘ f) s
theorem finset.affine_combination_apply {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (w : ι → k) (p : ι → P) : ⇑(s.affine_combination p) w = ⇑(s.weighted_vsub_of_point p (classical.choice add_torsor.nonempty)) w +ᵥ classical.choice add_torsor.nonempty
theorem fin.cast_to_equiv {n m : ℕ} (h : n = m) : (fin.cast h).to_equiv = equiv.cast _
theorem metric.ediam_le_of_forall_dist_le {α : Type u} [pseudo_metric_space α] {s : set α} {C : ℝ} (h : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → has_dist.dist x y ≤ C) : emetric.diam s ≤ ennreal.of_real C
theorem Sup_within_of_ord_connected {α : Type u_1} [conditionally_complete_linear_order α] {s : set α} [hs : s.ord_connected] ⦃t : set ↥s⦄ (ht : t.nonempty) (h_bdd : bdd_above t) : has_Sup.Sup (coe '' t) ∈ s
theorem category_theory.is_connected_zigzag {J : Type u₁} [category_theory.category J] [category_theory.is_connected J] (j₁ j₂ : J) : category_theory.zigzag j₁ j₂
theorem inner_product_geometry.cos_angle {V : Type u_1} [inner_product_space ℝ V] (x y : V) : real.cos (inner_product_geometry.angle x y) = has_inner.inner x y / (∥x∥ * ∥y∥)
theorem homeomorph.is_o_congr {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {E : Type u_3} [has_norm E] {F : Type u_4} [has_norm F] (e : α ≃ₜ β) {b : β} {f : β → E} {g : β → F} : f =o[nhds b] g ↔ (f ∘ ⇑e) =o[nhds (⇑(e.symm) b)] (g ∘ ⇑e)
theorem totally_bounded.bounded {α : Type u} [pseudo_metric_space α] {s : set α} (h : totally_bounded s) : metric.bounded s
theorem measure_theory.conservative.id {α : Type u_2} [measurable_space α] (μ : measure_theory.measure α) : measure_theory.conservative id μ
theorem measure_theory.measure.eq_of_ae_eq {X : Type u_1} {Y : Type u_2} [topological_space X] {m : measurable_space X} [topological_space Y] [t2_space Y] {μ : measure_theory.measure X} [μ.is_open_pos_measure] {f g : X → Y} (h : f =ᵐ[μ] g) (hf : continuous f) (hg : continuous g) : f = g
theorem measurable.find {α : Type u_1} {β : Type u_2} {mβ : measurable_space β} {m : measurable_space α} {f : ℕ → α → β} {p : ℕ → α → Prop} [Π (n : ℕ), decidable_pred (p n)] (hf : ∀ (n : ℕ), measurable (f n)) (hp : ∀ (n : ℕ), measurable_set {x : α | p n x}) (h : ∀ (x : α), ∃ (n : ℕ), p n x) : measurable (λ (x : α), f (nat.find _) x)
theorem is_min_on.of_is_local_min_of_convex_univ {E : Type u_1} {β : Type u_2} [add_comm_group E] [topological_space E] [module ℝ E] [topological_add_group E] [has_continuous_smul ℝ E] [ordered_add_comm_group β] [module ℝ β] [ordered_smul ℝ β] {f : E → β} {a : E} (h_local_min : is_local_min f a) (h_conv : convex_on ℝ set.univ f) (x : E) : f a ≤ f x
theorem category_theory.nat_iso.is_iso_of_is_iso_app {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {F G : C ⥤ D} (α : F ⟶ G) [∀ (X : C), category_theory.is_iso (α.app X)] : category_theory.is_iso α
theorem right.one_le_inv_iff {α : Type u} [group α] [has_le α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a : α} : 1 ≤ a⁻¹ ↔ a ≤ 1
theorem orthonormal.two_zsmul_oangle_neg_self_right {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x : V) : 2 • hb.oangle x (-x) = 0
theorem subsingleton_floor_ring {α : Type u_1} [linear_ordered_ring α] : subsingleton (floor_ring α)
theorem sum_div_pow_sq_le_div_sq (N : ℕ) {j : ℝ} (hj : 0 < j) {c : ℝ} (hc : 1 < c) : (finset.filter (λ (i : ℕ), j < c ^ i) (finset.range N)).sum (λ (i : ℕ), 1 / (c ^ i) ^ 2) ≤ c ^ 3 * (c - 1)⁻¹ / j ^ 2
theorem orthonormal.inner_finsupp_eq_sum_right {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : orthonormal 𝕜 v) (l₁ l₂ : ι →₀ 𝕜) : has_inner.inner (⇑(finsupp.total ι E 𝕜 v) l₁) (⇑(finsupp.total ι E 𝕜 v) l₂) = l₂.sum (λ (i : ι) (y : 𝕜), ⇑(star_ring_end 𝕜) (⇑l₁ i) * y)
theorem category_theory.normal_epi_category.pushout_of_epi {C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_cokernels C] [category_theory.normal_epi_category C] {X Y Z : C} (a : X ⟶ Y) (b : X ⟶ Z) [category_theory.epi a] [category_theory.epi b] : category_theory.limits.has_colimit (category_theory.limits.span a b)
theorem nat.eq_of_test_bit_eq {n m : ℕ} (h : ∀ (i : ℕ), n.test_bit i = m.test_bit i) : n = m
theorem tendsto_nhds_of_cauchy_seq_of_subseq {α : Type u} {β : Type v} [uniform_space α] [semilattice_sup β] {u : β → α} (hu : cauchy_seq u) {ι : Type u_1} {f : ι → β} {p : filter ι} [p.ne_bot] (hf : filter.tendsto f p filter.at_top) {a : α} (ha : filter.tendsto (u ∘ f) p (nhds a)) : filter.tendsto u filter.at_top (nhds a)
theorem matrix.mul_nonsing_inv {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) (h : is_unit A.det) : A.mul A⁻¹ = 1
theorem category_theory.limits.has_strict_initial_objects_of_initial_is_strict {C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] (h : ∀ (A : C) (f : A ⟶ ⊥_ C), category_theory.is_iso f) : category_theory.limits.has_strict_initial_objects C
theorem affine_subspace.mem_direction_iff_eq_vsub_right {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p : P} (hp : p ∈ s) (v : V) : v ∈ s.direction ↔ ∃ (p2 : P) (H : p2 ∈ s), v = p2 -ᵥ p
theorem has_sum_iff_tendsto_nat_of_nonneg {f : ℕ → ℝ} (hf : ∀ (i : ℕ), 0 ≤ f i) (r : ℝ) : has_sum f r ↔ filter.tendsto (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), f i)) filter.at_top (nhds r)
theorem filter.tendsto.at_bot_mul_neg {α : Type u} {β : Type v} [linear_ordered_field α] [topological_space α] [order_topology α] {l : filter β} {f g : β → α} {C : α} (hC : C < 0) (hf : filter.tendsto f l filter.at_bot) (hg : filter.tendsto g l (nhds C)) : filter.tendsto (λ (x : β), f x * g x) l filter.at_top
theorem complete_lattice.independent.disjoint_bsupr {ι : Type u_1} {α : Type u_2} [complete_lattice α] {t : ι → α} (ht : complete_lattice.independent t) {x : ι} {y : set ι} (hx : x ∉ y) : disjoint (t x) (⨆ (i : ι) (H : i ∈ y), t i)
theorem algebra.finite_presentation.quotient {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] {I : ideal A} (h : I.fg) (hfp : algebra.finite_presentation R A) : algebra.finite_presentation R (A ⧸ I)
theorem submodule.finset_span_is_compact_element {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (S : finset M) : complete_lattice.is_compact_element (submodule.span R ↑S)
theorem zero_lt.left.mul_lt_one_of_lt_of_lt {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : a < 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1
theorem finset.order_emb_of_fin_singleton {α : Type u_1} [linear_order α] (a : α) (i : fin 1) : ⇑({a}.order_emb_of_fin _) i = a
theorem is_glb.bdd_below {α : Type u} [preorder α] {s : set α} {a : α} (h : is_glb s a) : bdd_below s
theorem filter.is_bounded_iff {α : Type u_1} {r : α → α → Prop} {f : filter α} : filter.is_bounded r f ↔ ∃ (s : set α) (H : s ∈ f.sets) (b : α), s ⊆ {x : α | r x b}
theorem measure_theory.measure.ae_ae_of_ae_prod {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] {p : α × β → Prop} (h : ∀ᵐ (z : α × β) ∂μ.prod ν, p z) : ∀ᵐ (x : α) ∂μ, ∀ᵐ (y : β) ∂ν, p (x, y)
theorem complex.eq_on_of_eq_on_frontier {E : Type u} [normed_group E] [normed_space ℂ E] {F : Type v} [normed_group F] [normed_space ℂ F] [nontrivial E] {f g : E → F} {U : set E} (hU : metric.bounded U) (hf : diff_cont_on_cl ℂ f U) (hg : diff_cont_on_cl ℂ g U) (hfg : set.eq_on f g (frontier U)) : set.eq_on f g U
theorem has_compact_support.norm {α : Type u_1} {E : Type u_3} [normed_group E] [topological_space α] {f : α → E} : has_compact_support f → has_compact_support (λ (x : α), ∥f x∥)
theorem padic_norm.one (p : ℕ) : padic_norm p 1 = 1
theorem sub_eq_add_neg {G : Type u_1} [sub_neg_monoid G] (a b : G) : a - b = a + -b
theorem clifford_algebra.submodule_map_pow_reverse {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (Q : quadratic_form R M) (p : submodule R (clifford_algebra Q)) (n : ℕ) : submodule.map clifford_algebra.reverse (p ^ n) = submodule.map clifford_algebra.reverse p ^ n
theorem psigma.subtype_ext {α : Sort u_1} {β : Sort u_2} {p : α → β → Prop} {x₀ x₁ : Σ' (a : α), subtype (p a)} : x₀.fst = x₁.fst → ↑(x₀.snd) = ↑(x₁.snd) → x₀ = x₁
theorem category_theory.over.construct_products.over_binary_product_of_pullback {C : Type u} [category_theory.category C] [category_theory.limits.has_pullbacks C] {B : C} : category_theory.limits.has_binary_products (category_theory.over B)
theorem uniform_embedding_iff' {β : Type v} {γ : Type w} [emetric_space γ] [emetric_space β] {f : γ → β} : uniform_embedding f ↔ (∀ (ε : ennreal), ε > 0 → (∃ (δ : ennreal) (H : δ > 0), ∀ {a b : γ}, has_edist.edist a b < δ → has_edist.edist (f a) (f b) < ε)) ∧ ∀ (δ : ennreal), δ > 0 → (∃ (ε : ennreal) (H : ε > 0), ∀ {a b : γ}, has_edist.edist (f a) (f b) < ε → has_edist.edist a b < δ)
theorem besicovitch.card_le_of_separated {E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] (s : finset E) (hs : ∀ (c : E), c ∈ s → ∥c∥ ≤ 2) (h : ∀ (c : E), c ∈ s → ∀ (d : E), d ∈ s → c ≠ d → 1 ≤ ∥c - d∥) : s.card ≤ 5 ^ finite_dimensional.finrank ℝ E
theorem fermat_42.neg_of_minimal {a b c : ℤ} : fermat_42.minimal a b c → fermat_42.minimal a b (-c)
theorem fractional_ideal.is_fractional_adjoin_integral {R : Type u_1} [comm_ring R] (S : submonoid R) {P : Type u_2} [comm_ring P] [algebra R P] [loc : is_localization S P] (x : P) (hx : is_integral R x) : is_fractional S (algebra.adjoin R {x}).to_submodule
theorem affine_map.comp_apply {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} {V3 : Type u_6} {P3 : Type u_7} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] [add_comm_group V3] [module k V3] [add_torsor V3 P3] (f : P2 →ᵃ[k] P3) (g : P1 →ᵃ[k] P2) (p : P1) : ⇑(f.comp g) p = ⇑f (⇑g p)
theorem colex.mem_le_of_singleton_le {α : Type u_1} [linear_order α] {r : α} {s : finset α} : {r}.to_colex ≤ s.to_colex ↔ ∃ (x : α) (H : x ∈ s), r ≤ x
theorem formal_multilinear_series.is_o_one_of_lt_radius {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) {r : nnreal} (h : ↑r < p.radius) : (λ (n : ℕ), ∥p n∥ * ↑r ^ n) =o[filter.at_top] λ (_x : ℕ), 1
theorem probability_theory.tendsto_integral_truncation {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : α → ℝ} (hf : measure_theory.integrable f μ) : filter.tendsto (λ (A : ℝ), ∫ (x : α), probability_theory.truncation f A x ∂μ) filter.at_top (nhds (∫ (x : α), f x ∂μ))
theorem measure_theory.unif_integrable_of_tendsto_Lp {α : Type u_1} {β : Type u_2} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} {f : ℕ → α → β} {g : α → β} (hp : 1 ≤ p) (hp' : p ≠ ⊤) (hf : ∀ (n : ℕ), measure_theory.mem_ℒp (f n) p μ) (hg : measure_theory.mem_ℒp g p μ) (hfg : filter.tendsto (λ (n : ℕ), measure_theory.snorm (f n - g) p μ) filter.at_top (nhds 0)) : measure_theory.unif_integrable f p μ
theorem exists_subset_affine_independent_affine_span_eq_top {k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} (h : affine_independent k (λ (p : ↥s), ↑p)) : ∃ (t : set P), s ⊆ t ∧ affine_independent k (λ (p : ↥t), ↑p) ∧ affine_span k t = ⊤
theorem complete_lattice.set_independent.disjoint_Sup {α : Type u_1} [complete_lattice α] {s : set α} (hs : complete_lattice.set_independent s) {x : α} {y : set α} (hx : x ∈ s) (hy : y ⊆ s) (hxy : x ∉ y) : disjoint x (has_Sup.Sup y)
theorem group_topology.continuous_inv' {α : Type u} [group α] (g : group_topology α) : continuous has_inv.inv
theorem concave_on.comp_linear_map {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [add_comm_monoid F] [ordered_add_comm_monoid β] [module 𝕜 E] [module 𝕜 F] [has_scalar 𝕜 β] {f : F → β} {s : set F} (hf : concave_on 𝕜 s f) (g : E →ₗ[𝕜] F) : concave_on 𝕜 (⇑g ⁻¹' s) (f ∘ ⇑g)
theorem add_pos_of_pos_of_nonneg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 ≤ b) : 0 < a + b
theorem measure_theory.measure.add_haar_eq_zero_of_disjoint_translates_aux {E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] {s : set E} (u : ℕ → E) (sb : metric.bounded s) (hu : metric.bounded (set.range u)) (hs : pairwise (disjoint on λ (n : ℕ), {u n} + s)) (h's : measurable_set s) : ⇑μ s = 0
theorem continuous_on.ae_measurable {α : Type u_1} {β : Type u_2} [measurable_space α] [topological_space α] [opens_measurable_space α] [measurable_space β] [topological_space β] [borel_space β] {f : α → β} {s : set α} {μ : measure_theory.measure α} (hf : continuous_on f s) (hs : measurable_set s) : ae_measurable f (μ.restrict s)
theorem polynomial.cyclotomic_mul_prime_dvd_eq_pow (R : Type u_1) {p n : ℕ} [hp : fact (nat.prime p)] [ring R] [char_p R p] (hn : p ∣ n) : polynomial.cyclotomic (n * p) R = polynomial.cyclotomic n R ^ p
theorem ideal.polynomial.is_integral_is_localization_polynomial_quotient {R : Type u_1} [comm_ring R] {Rₘ : Type u_3} {Sₘ : Type u_4} [comm_ring Rₘ] [comm_ring Sₘ] (P : ideal (polynomial R)) (pX : polynomial R) (hpX : pX ∈ P) [algebra (R ⧸ ideal.comap polynomial.C P) Rₘ] [is_localization.away (polynomial.map (ideal.quotient.mk (ideal.comap polynomial.C P)) pX).leading_coeff Rₘ] [algebra (polynomial R ⧸ P) Sₘ] [is_localization (submonoid.map ↑(P.quotient_map polynomial.C le_rfl) (submonoid.powers (polynomial.map (ideal.quotient.mk (ideal.comap polynomial.C P)) pX).leading_coeff)) Sₘ] : (is_localization.map Sₘ (P.quotient_map polynomial.C le_rfl) _).is_integral
theorem category_theory.eq_whisker {C : Type u} [category_theory.category C] {X Y Z : C} {f g : X ⟶ Y} (w : f = g) (h : Y ⟶ Z) : f ≫ h = g ≫ h
theorem has_deriv_within_at.Ici_of_Ioi {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {F : Type v} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜} [partial_order 𝕜] : has_deriv_within_at f f' (set.Ioi x) x → has_deriv_within_at f f' (set.Ici x) x
theorem lp.tendsto_lp_of_tendsto_pi {α : Type u_1} {E : α → Type u_2} {p : ennreal} [Π (i : α), normed_group (E i)] [fact (1 ≤ p)] {F : ℕ → ↥(lp E p)} (hF : cauchy_seq F) {f : ↥(lp E p)} (hf : filter.tendsto (id (λ (i : ℕ), ⇑(F i))) filter.at_top (nhds ⇑f)) : filter.tendsto F filter.at_top (nhds f)
theorem norm_le_insert {E : Type u_3} [semi_normed_group E] (u v : E) : ∥v∥ ≤ ∥u∥ + ∥u - v∥
theorem measure_theory.integral_integral_add' {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] ⦃f g : α × β → E⦄ (hf : measure_theory.integrable f (μ.prod ν)) (hg : measure_theory.integrable g (μ.prod ν)) : ∫ (x : α), ∫ (y : β), (f + g) (x, y) ∂ν ∂μ = ∫ (x : α), ∫ (y : β), f (x, y) ∂ν ∂μ + ∫ (x : α), ∫ (y : β), g (x, y) ∂ν ∂μ
theorem antivary_on.sum_smul_le_sum_comp_perm_smul {ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {s : finset ι} {σ : equiv.perm ι} {f : ι → α} {g : ι → β} (hfg : antivary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i • g i) ≤ s.sum (λ (i : ι), f (⇑σ i) • g i)
theorem concave_on_of_deriv2_nonpos {D : set ℝ} (hD : convex ℝ D) {f : ℝ → ℝ} (hf : continuous_on f D) (hf' : differentiable_on ℝ f (interior D)) (hf'' : differentiable_on ℝ (deriv f) (interior D)) (hf''_nonpos : ∀ (x : ℝ), x ∈ interior D → deriv^[2] f x ≤ 0) : concave_on ℝ D f
theorem con.lift_mk' {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} {f : M →* P} (H : c ≤ con.ker f) (x : M) : ⇑(c.lift f H) (⇑(c.mk') x) = ⇑f x
theorem approximates_linear_on.to_inv {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {f' : E ≃L[𝕜] F} {s : set E} {c : nnreal} (hf : approximates_linear_on f ↑f' s c) (hc : subsingleton E ∨ c < ∥↑(f'.symm)∥₊⁻¹) : approximates_linear_on ⇑((hf.to_local_equiv hc).symm) ↑(f'.symm) (f '' s) (∥↑(f'.symm)∥₊ * (∥↑(f'.symm)∥₊⁻¹ - c)⁻¹ * c)
theorem set.image2_eq_Union {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β → γ) (s : set α) (t : set β) : set.image2 f s t = ⋃ (i : α) (H : i ∈ s) (j : β) (H : j ∈ t), {f i j}
theorem set.finite_of_forall_between_eq_endpoints {α : Type u_1} [linear_order α] (s : set α) (h : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → ∀ (z : α), z ∈ s → x ≤ y → y ≤ z → x = y ∨ y = z) : s.finite
theorem padic_seq.lift_index_left {p : ℕ} [fact (nat.prime p)] {f : padic_seq p} (hf : ¬f ≈ 0) (v1 v3 : ℕ) : padic_norm p (⇑f (padic_seq.stationary_point hf)) = padic_norm p (⇑f (linear_order.max v1 (linear_order.max (padic_seq.stationary_point hf) v3)))
theorem deriv_forall_lt_or_forall_gt_of_forall_ne {f f' : ℝ → ℝ} {s : set ℝ} (hs : convex ℝ s) (hf : ∀ (x : ℝ), x ∈ s → has_deriv_at f (f' x) x) {m : ℝ} (hf' : ∀ (x : ℝ), x ∈ s → f' x ≠ m) : (∀ (x : ℝ), x ∈ s → f' x < m) ∨ ∀ (x : ℝ), x ∈ s → m < f' x
theorem is_primitive_root.squarefree_minpoly_mod {n : ℕ} {K : Type u_8} [field K] {μ : K} (h : is_primitive_root μ n) [char_zero K] {p : ℕ} [fact (nat.prime p)] (hdiv : ¬p ∣ n) : squarefree (polynomial.map (int.cast_ring_hom (zmod p)) (minpoly ℤ μ))
theorem is_torsion_free.subgroup {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) : monoid.is_torsion_free ↥H
theorem finset.univ_perm_fin_succ {n : ℕ} : finset.univ = finset.map equiv.perm.decompose_fin.symm.to_embedding finset.univ
theorem add_semiconj_by.transitive {S : Type u} [add_semigroup S] : transitive (λ (a b : S), ∃ (c : S), add_semiconj_by c a b)
theorem convex_on.exists_ge_of_center_mass {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} {ι : Type u_5} [linear_ordered_field 𝕜] [add_comm_group E] [linear_ordered_add_comm_group β] [module 𝕜 E] [module 𝕜 β] [ordered_smul 𝕜 β] {s : set E} {f : E → β} {t : finset ι} {w : ι → 𝕜} {p : ι → E} (h : convex_on 𝕜 s f) (hw₀ : ∀ (i : ι), i ∈ t → 0 ≤ w i) (hw₁ : 0 < t.sum (λ (i : ι), w i)) (hp : ∀ (i : ι), i ∈ t → p i ∈ s) : ∃ (i : ι) (H : i ∈ t), f (t.center_mass w p) ≤ f (p i)
theorem nat.eq_prime_pow_of_dvd_least_prime_pow {a p k : ℕ} (pp : nat.prime p) (h₁ : ¬a ∣ p ^ k) (h₂ : a ∣ p ^ (k + 1)) : a = p ^ (k + 1)
theorem subgroup.nilpotency_class_le {G : Type u_1} [group G] (H : subgroup G) [hG : group.is_nilpotent G] : group.nilpotency_class ↥H ≤ group.nilpotency_class G
theorem category_theory.transfer_nat_trans_self_of_iso {C : Type u₁} {D : Type u₂} [category_theory.category C] [category_theory.category D] {L₁ L₂ : C ⥤ D} {R₁ R₂ : D ⥤ C} (adj₁ : L₁ ⊣ R₁) (adj₂ : L₂ ⊣ R₂) (f : L₂ ⟶ L₁) [category_theory.is_iso (⇑(category_theory.transfer_nat_trans_self adj₁ adj₂) f)] : category_theory.is_iso f
theorem category_theory.subobject.mk_eq_of_comm {C : Type u₁} [category_theory.category C] {B A : C} {X : category_theory.subobject B} (f : A ⟶ B) [category_theory.mono f] (i : A ≅ ↑X) (w : i.hom ≫ X.arrow = f) : category_theory.subobject.mk f = X
theorem algebraic_geometry.Γ_Spec.right_triangle (R : CommRing) : algebraic_geometry.identity_to_Γ_Spec.app (algebraic_geometry.Spec.to_LocallyRingedSpace.obj (opposite.op R)) ≫ algebraic_geometry.Spec.to_LocallyRingedSpace.map (algebraic_geometry.Spec_Γ_identity.inv.app R).op = 𝟙 ((𝟭 algebraic_geometry.LocallyRingedSpace).obj (algebraic_geometry.Spec.to_LocallyRingedSpace.obj (opposite.op R)))
theorem category_theory.presieve.is_sheaf_for_singleton_iso {C : Type u₁} [category_theory.category C] {X : C} (P : Cᵒᵖ ⥤ Type w) : category_theory.presieve.is_sheaf_for P (category_theory.presieve.singleton (𝟙 X))
theorem convex.affine_image {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [ordered_ring 𝕜] [add_comm_group E] [add_comm_group F] [module 𝕜 E] [module 𝕜 F] {s : set E} (f : E →ᵃ[𝕜] F) (hs : convex 𝕜 s) : convex 𝕜 (⇑f '' s)
theorem complex.has_deriv_at_cosh (x : ℂ) : has_deriv_at complex.cosh (complex.sinh x) x
theorem metric.to_inductive_limit_commute {X : ℕ → Type u} [Π (n : ℕ), metric_space (X n)] {f : Π (n : ℕ), X n → X (n + 1)} (I : ∀ (n : ℕ), isometry (f n)) (n : ℕ) : metric.to_inductive_limit I n.succ ∘ f n = metric.to_inductive_limit I n
theorem one_hom.congr_fun {M : Type u_3} {N : Type u_4} [has_one M] [has_one N] {f g : one_hom M N} (h : f = g) (x : M) : ⇑f x = ⇑g x
theorem connected_components_preimage_singleton {α : Type u} [topological_space α] {x : α} : coe ⁻¹' {↑x} = connected_component x
theorem ordinal.unbounded_of_unbounded_sUnion {α : Type u_1} (r : α → α → Prop) [wo : is_well_order α r] {s : set (set α)} (h₁ : set.unbounded r (⋃₀s)) (h₂ : cardinal.mk ↥s < strict_order.cof r) : ∃ (x : set α) (H : x ∈ s), set.unbounded r x
theorem continuous_linear_map.is_compact_closure_image_coe_of_bounded {𝕜 : Type u_1} {𝕜₂ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {E' : Type u_10} [semi_normed_group E'] [normed_space 𝕜 E'] [ring_hom_isometric σ₁₂] [proper_space F] {s : set (E' →SL[σ₁₂] F)} (hb : metric.bounded s) : is_compact (closure (coe_fn '' s))
theorem category_theory.limits.is_iso_limit_cone_parallel_pair_of_epi {C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} {c : category_theory.limits.fork f g} (h : category_theory.limits.is_limit c) [category_theory.epi c.ι] : category_theory.is_iso c.ι
theorem padic_val_rat.div (p : ℕ) [p_prime : fact (nat.prime p)] {q r : ℚ} (hq : q ≠ 0) (hr : r ≠ 0) : padic_val_rat p (q / r) = padic_val_rat p q - padic_val_rat p r
theorem interval_integrable_iff {E : Type u_3} [normed_group E] {f : ℝ → E} {a b : ℝ} {μ : measure_theory.measure ℝ} : interval_integrable f μ a b ↔ measure_theory.integrable_on f (set.interval_oc a b) μ
theorem linear_map.continuous_iff_is_closed_ker {𝕜 : Type u} [hnorm : nondiscrete_normed_field 𝕜] {E : Type v} [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_smul 𝕜 E] (l : E →ₗ[𝕜] 𝕜) : continuous ⇑l ↔ is_closed ↑(l.ker)
theorem matrix.det_fin_three {R : Type v} [comm_ring R] (A : matrix (fin 3) (fin 3) R) : A.det = A 0 0 * A 1 1 * A 2 2 - A 0 0 * A 1 2 * A 2 1 - A 0 1 * A 1 0 * A 2 2 + A 0 1 * A 1 2 * A 2 0 + A 0 2 * A 1 0 * A 2 1 - A 0 2 * A 1 1 * A 2 0
theorem category_theory.reflects_mono {C : Type u₁} {D : Type u₂} [category_theory.category C] [category_theory.category D] (F : C ⥤ D) {X Y : C} (f : X ⟶ Y) [category_theory.limits.reflects_limit (category_theory.limits.cospan f f) F] [category_theory.mono (F.map f)] : category_theory.mono f
theorem zero_ne_one {M₀ : Type u_1} [mul_zero_one_class M₀] [nontrivial M₀] : 0 ≠ 1
theorem equiv.mul_swap_mul_self {α : Type u} [decidable_eq α] (i j : α) (σ : equiv.perm α) : σ * equiv.swap i j * equiv.swap i j = σ
theorem nat.three_dvd_iff (n : ℕ) : 3 ∣ n ↔ 3 ∣ (10.digits n).sum
theorem circle_integral.integral_sub_zpow_of_undef {n : ℤ} {c w : ℂ} {R : ℝ} (hn : n < 0) (hw : w ∈ metric.sphere c |R|) : ∮ (z : ℂ) in C(c, R), (z - w) ^ n = 0
theorem category_theory.presieve.extend_restrict {C : Type u₁} [category_theory.category C] {P : Cᵒᵖ ⥤ Type w} {X : C} {R : category_theory.presieve X} {x : category_theory.presieve.family_of_elements P ⇑(category_theory.sieve.generate R)} (t : x.compatible) : (category_theory.presieve.family_of_elements.restrict _ x).sieve_extend = x
theorem category_theory.strong_mono_of_strong_mono {C : Type u} [category_theory.category C] {P Q R : C} (f : P ⟶ Q) (g : Q ⟶ R) [category_theory.strong_mono (f ≫ g)] : category_theory.strong_mono f
theorem rat_cast_smul_eq {E : Type u_1} (R : Type u_2) (S : Type u_3) [add_comm_group E] [division_ring R] [division_ring S] [module R E] [module S E] (r : ℚ) (x : E) : ↑r • x = ↑r • x
theorem category_theory.limits.cotrident.coequalizer_ext {J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J → (X ⟶ Y)} [nonempty J] (s : category_theory.limits.cotrident f) {W : C} {k l : s.X ⟶ W} (h : s.π ≫ k = s.π ≫ l) (j : category_theory.limits.walking_parallel_family J) : s.ι.app j ≫ k = s.ι.app j ≫ l
theorem polynomial.degree_cyclotomic (n : ℕ) (R : Type u_1) [ring R] [nontrivial R] : (polynomial.cyclotomic n R).degree = ↑(n.totient)
theorem interval_integral.interval_integrable_deriv_of_nonneg {a b : ℝ} {g' g : ℝ → ℝ} (hcont : continuous_on g (set.interval a b)) (hderiv : ∀ (x : ℝ), x ∈ set.Ioo (linear_order.min a b) (linear_order.max a b) → has_deriv_at g (g' x) x) (hpos : ∀ (x : ℝ), x ∈ set.Ioo (linear_order.min a b) (linear_order.max a b) → 0 ≤ g' x) : interval_integrable g' measure_theory.measure_space.volume a b
theorem measurable_set_of_differentiable_at_of_is_complete (𝕜 : Type u_1) [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] (f : E → F) [measurable_space E] [opens_measurable_space E] {K : set (E →L[𝕜] F)} (hK : is_complete K) : measurable_set {x : E | differentiable_at 𝕜 f x ∧ fderiv 𝕜 f x ∈ K}
theorem polynomial.leading_coeff_multiset_prod {R : Type u} [comm_semiring R] [no_zero_divisors R] (t : multiset (polynomial R)) : t.prod.leading_coeff = (multiset.map (λ (f : polynomial R), f.leading_coeff) t).prod
theorem category_theory.is_pullback.zero_left {C : Type u₁} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] (X : C) : category_theory.is_pullback 0 0 (𝟙 X) 0
theorem nat.prime.pow_dvd_factorial_iff {p n r b : ℕ} (hp : nat.prime p) (hbn : nat.log p n < b) : p ^ r ∣ n.factorial ↔ r ≤ (finset.Ico 1 b).sum (λ (i : ℕ), n / p ^ i)
theorem list.nat.length_antidiagonal (n : ℕ) : (list.nat.antidiagonal n).length = n + 1
theorem monotone.iterate_le_of_le {α : Type u_1} [preorder α] {f g : α → α} (hf : monotone f) (h : f ≤ g) (n : ℕ) : f^[n] ≤ (g^[n])
theorem filter.tendsto.at_top_add {α : Type u} {β : Type v} [topological_space α] [linear_ordered_add_comm_group α] [order_topology α] {l : filter β} {f g : β → α} {C : α} (hf : filter.tendsto f l filter.at_top) (hg : filter.tendsto g l (nhds C)) : filter.tendsto (λ (x : β), f x + g x) l filter.at_top
theorem finset.subtype_map {α : Type u_1} {s : finset α} (p : α → Prop) [decidable_pred p] : finset.map (function.embedding.subtype p) (finset.subtype p s) = finset.filter p s
theorem affine_independent.mem_affine_span_iff {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} [nontrivial k] {p : ι → P} (ha : affine_independent k p) (i : ι) (s : set ι) : p i ∈ affine_span k (p '' s) ↔ i ∈ s
theorem add_con.lift_surjective_of_surjective {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} {f : M →+ P} (h : c ≤ add_con.ker f) (hf : function.surjective ⇑f) : function.surjective ⇑(c.lift f h)
theorem is_pi_system_prod {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] : is_pi_system (set.image2 has_set_prod.prod {s : set α | measurable_set s} {t : set β | measurable_set t})
theorem orientation.fin_orthonormal_basis_orthonormal {E : Type u_1} [inner_product_space ℝ E] {n : ℕ} (hn : 0 < n) (h : finite_dimensional.finrank ℝ E = n) (x : orientation ℝ E (fin n)) : orthonormal ℝ ⇑(orientation.fin_orthonormal_basis hn h x)
theorem category_theory.limits.has_equalizers_of_has_limit_parallel_pair (C : Type u) [category_theory.category C] [∀ {X Y : C} {f g : X ⟶ Y}, category_theory.limits.has_limit (category_theory.limits.parallel_pair f g)] : category_theory.limits.has_equalizers C
theorem add_submonoid.supr_induction {M : Type u_1} [add_zero_class M] {ι : Sort u_2} (S : ι → add_submonoid M) {C : M → Prop} {x : M} (hx : x ∈ ⨆ (i : ι), S i) (hp : ∀ (i : ι) (x : M), x ∈ S i → C x) (h1 : C 0) (hmul : ∀ (x y : M), C x → C y → C (x + y)) : C x
theorem fourier_add_half_inv_index {n : ℤ} (hn : n ≠ 0) (z : ↥circle) : ⇑(fourier n) (⇑exp_map_circle ((↑n)⁻¹ * real.pi) * z) = -⇑(fourier n) z
theorem with_top.is_glb_Inf' {β : Type u_1} [conditionally_complete_lattice β] {s : set (with_top β)} (hs : bdd_below s) : is_glb s (has_Inf.Inf s)
theorem fin.succ_above_pos {n : ℕ} (p : fin (n + 2)) (i : fin (n + 1)) (h : 0 < i) : 0 < ⇑(p.succ_above) i
theorem category_theory.whisker_eq {C : Type u} [category_theory.category C] {X Y Z : C} (f : X ⟶ Y) {g h : Y ⟶ Z} (w : g = h) : f ≫ g = f ≫ h
theorem directed_of_inf {α : Type u} {β : Type v} [semilattice_inf α] {r : β → β → Prop} {f : α → β} (hf : ∀ (a₁ a₂ : α), a₁ ≤ a₂ → r (f a₂) (f a₁)) : directed r f
theorem module.free.rank_matrix (R : Type u) [ring R] [strong_rank_condition R] (m : Type v) (n : Type w) [fintype m] [fintype n] : module.rank R (matrix m n R) = (cardinal.mk m).lift * (cardinal.mk n).lift
theorem matrix.map_op_smul' {n : Type u_3} {α : Type v} {β : Type w} [has_mul α] [has_mul β] (f : α → β) (r : α) (A : matrix n n α) (hf : ∀ (a₁ a₂ : α), f (a₁ * a₂) = f a₁ * f a₂) : (mul_opposite.op r • A).map f = mul_opposite.op (f r) • A.map f
theorem has_strict_deriv_at.has_strict_fderiv_at {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {F : Type v} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜} : has_strict_deriv_at f f' x → has_strict_fderiv_at f (1.smul_right f') x
theorem nat.le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ nat.clog b x ≤ y
theorem monoid_hom.map_exists_left_inv {M : Type u_3} {N : Type u_4} {F : Type u_8} {mM : mul_one_class M} {mN : mul_one_class N} [monoid_hom_class F M N] (f : F) {x : M} (hx : ∃ (y : M), y * x = 1) : ∃ (y : N), y * ⇑f x = 1
theorem metric.is_closed_cthickening {α : Type u} [pseudo_emetric_space α] {δ : ℝ} {E : set α} : is_closed (metric.cthickening δ E)
theorem discrete_topology_iff_nhds {X : Type u_1} [topological_space X] : discrete_topology X ↔ nhds = has_pure.pure
theorem generalized_continued_fraction.exists_rat_eq_of_terminates {K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} (terminates : (generalized_continued_fraction.of v).terminates) : ∃ (q : ℚ), v = ↑q
theorem algebraic_geometry.LocallyRingedSpace.to_Γ_Spec_preim_basic_open_eq (X : algebraic_geometry.LocallyRingedSpace) (r : ↥(algebraic_geometry.LocallyRingedSpace.Γ.obj (opposite.op X))) : X.to_Γ_Spec_fun ⁻¹' (prime_spectrum.basic_open r).val = (X.to_RingedSpace.basic_open r).val
theorem algebra.discr_not_zero_of_basis {ι : Type w} [fintype ι] (K : Type u) {L : Type v} [field K] [field L] [algebra K L] [module.finite K L] [is_separable K L] (b : basis ι K L) : algebra.discr K ⇑b ≠ 0
theorem finset.sum_smul_vsub_eq_weighted_vsub_of_point_sub {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (w : ι → k) (p₁ p₂ : ι → P) (b : P) : s.sum (λ (i : ι), w i • (p₁ i -ᵥ p₂ i)) = ⇑(s.weighted_vsub_of_point p₁ b) w - ⇑(s.weighted_vsub_of_point p₂ b) w
theorem map_neg {G : Type u_6} {H : Type u_7} {F : Type u_8} [add_group G] [subtraction_monoid H] [add_monoid_hom_class F G H] (f : F) (a : G) : ⇑f (-a) = -⇑f a
theorem has_deriv_at.comp {𝕜 : Type u} [nondiscrete_normed_field 𝕜] (x : 𝕜) {𝕜' : Type u_1} [nondiscrete_normed_field 𝕜'] [normed_algebra 𝕜 𝕜'] {h : 𝕜 → 𝕜'} {h₂ : 𝕜' → 𝕜'} {h' h₂' : 𝕜'} (hh₂ : has_deriv_at h₂ h₂' (h x)) (hh : has_deriv_at h h' x) : has_deriv_at (h₂ ∘ h) (h₂' * h') x
theorem submonoid.prod_mem {M : Type u_1} [comm_monoid M] (S : submonoid M) {ι : Type u_2} {t : finset ι} {f : ι → M} (h : ∀ (c : ι), c ∈ t → f c ∈ S) : t.prod (λ (c : ι), f c) ∈ S
theorem category_theory.over.construct_products.has_over_limit_discrete_of_wide_pullback_limit {J : Type v} {C : Type u} [category_theory.category C] {B : C} (F : category_theory.discrete J ⥤ category_theory.over B) [category_theory.limits.has_limit (category_theory.over.construct_products.wide_pullback_diagram_of_diagram_over B F)] : category_theory.limits.has_limit F
theorem ideal.prod_eq_bot {R : Type u_1} [comm_ring R] [is_domain R] {s : multiset (ideal R)} : s.prod = ⊥ ↔ ∃ (I : ideal R) (H : I ∈ s), I = ⊥
theorem measure_theory.measure.exists_positive_of_not_mutually_singular {α : Type u_1} {m : measurable_space α} (μ ν : measure_theory.measure α) [measure_theory.is_finite_measure μ] [measure_theory.is_finite_measure ν] (h : ¬μ.mutually_singular ν) : ∃ (ε : nnreal), 0 < ε ∧ ∃ (E : set α), measurable_set E ∧ 0 < ⇑ν E ∧ 0.restrict E ≤ (μ.to_signed_measure - (ε • ν).to_signed_measure).restrict E
theorem uniform_inducing.uniform_embedding {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] [separated_space α] {f : α → β} (hf : uniform_inducing f) : uniform_embedding f
theorem tsum_mul_tsum {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [regular_space α] [non_unital_non_assoc_semiring α] [topological_semiring α] {f : β → α} {g : γ → α} (hf : summable f) (hg : summable g) (hfg : summable (λ (x : β × γ), f x.fst * g x.snd)) : (∑' (x : β), f x) * ∑' (y : γ), g y = ∑' (z : β × γ), f z.fst * g z.snd
theorem measure_theory.measurable_set_range_of_continuous_injective {γ : Type u_3} [tγ : topological_space γ] [polish_space γ] {β : Type u_1} [topological_space β] [t2_space β] [measurable_space β] [borel_space β] {f : γ → β} (f_cont : continuous f) (f_inj : function.injective f) : measurable_set (set.range f)
theorem inner_product_space.is_self_adjoint.has_eigenvector_of_is_local_extr_on {𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] [complete_space E] {T : E →L[𝕜] E} (hT : inner_product_space.is_self_adjoint ↑T) {x₀ : E} (hx₀ : x₀ ≠ 0) (hextr : is_local_extr_on T.re_apply_inner_self (metric.sphere 0 ∥x₀∥) x₀) : module.End.has_eigenvector ↑T ↑((λ (x : E), T.re_apply_inner_self x / ∥x∥ ^ 2) x₀) x₀
theorem padic_norm.triangle_ineq (p : ℕ) [hp : fact (nat.prime p)] (q r : ℚ) : padic_norm p (q + r) ≤ padic_norm p q + padic_norm p r
theorem is_max_filter.dual {α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α} : is_max_filter f l a → is_min_filter (⇑order_dual.to_dual ∘ f) l a
theorem module.End.eigenspace_restrict_eq_bot {R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {p : submodule R M} (hfp : ∀ (x : M), x ∈ p → ⇑f x ∈ p) {μ : R} (hμp : disjoint (f.eigenspace μ) p) : module.End.eigenspace (linear_map.restrict f hfp) μ = ⊥
theorem integrable_of_is_O_exp_neg {f : ℝ → ℝ} {a b : ℝ} (h0 : 0 < b) (h1 : continuous_on f (set.Ici a)) (h2 : f =O[filter.at_top] λ (x : ℝ), real.exp (-b * x)) : measure_theory.integrable_on f (set.Ioi a) measure_theory.measure_space.volume
theorem measure_theory.add_haar_measure_eq_volume  : measure_theory.measure.add_haar_measure topological_space.positive_compacts.Icc01 = measure_theory.measure_space.volume
theorem algebra.finite_presentation.self (R : Type u_1) [comm_ring R] : algebra.finite_presentation R R
theorem antitone.pairwise_disjoint_on_Ioo_pred {α : Type u_1} {β : Type u_2} [linear_order α] [pred_order α] [preorder β] {f : α → β} (hf : antitone f) : pairwise (disjoint on λ (n : α), set.Ioo (f n) (f (order.pred n)))
theorem finsum_mem_of_eq_on_zero {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} {s : set α} (hf : set.eq_on f 0 s) : finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) = 0
theorem submonoid.localization_map.mk'_sec {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] (f : S.localization_map N) (z : N) : f.mk' (f.sec z).fst (f.sec z).snd = z
theorem nat.exists_strict_mono (α : Type u) [preorder α] [nonempty α] [no_max_order α] : ∃ (f : ℕ → α), strict_mono f
theorem has_lt.lt.ne_bot {α : Type u} [preorder α] [order_bot α] {a b : α} (h : a < b) : b ≠ ⊥
theorem filter.eventually_eq.germ_eq {α : Type u_1} {β : Type u_2} {l : filter α} {f g : α → β} : f =ᶠ[l] g → ↑f = ↑g
theorem orientation.oangle_neg_right {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : o.oangle x (-y) = o.oangle x y + ↑real.pi
theorem is_localization.algebra_map_surjective_of_fintype {R : Type u} [comm_ring R] (S : submonoid R) {L : Type u} [comm_ring L] [algebra R L] [is_localization S L] [fintype R] : function.surjective ⇑(algebra_map R L)
theorem finset.sum_bij' {β : Type u} {α : Type v} {γ : Type w} [add_comm_monoid β] {s : finset α} {t : finset γ} {f : α → β} {g : γ → β} (i : Π (a : α), a ∈ s → γ) (hi : ∀ (a : α) (ha : a ∈ s), i a ha ∈ t) (h : ∀ (a : α) (ha : a ∈ s), f a = g (i a ha)) (j : Π (a : γ), a ∈ t → α) (hj : ∀ (a : γ) (ha : a ∈ t), j a ha ∈ s) (left_inv : ∀ (a : α) (ha : a ∈ s), j (i a ha) _ = a) (right_inv : ∀ (a : γ) (ha : a ∈ t), i (j a ha) _ = a) : s.sum (λ (x : α), f x) = t.sum (λ (x : γ), g x)
theorem well_founded.fix_eq {α : Sort u} {C : α → Sort v} {r : α → α → Prop} (hwf : well_founded r) (F : Π (x : α), (Π (y : α), r y x → C y) → C x) (x : α) : hwf.fix F x = F x (λ (y : α) (h : r y x), hwf.fix F y)
theorem to_matrix_rotation (a : ↥circle) : ⇑(linear_map.to_matrix complex.basis_one_I complex.basis_one_I) ↑((⇑rotation a).to_linear_equiv) = ⇑(matrix.plane_conformal_matrix ↑a.re ↑a.im _)
theorem is_dedekind_domain.height_one_spectrum.int_valuation_lt_one_iff_dvd {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (r : R) : v.int_valuation_def r < 1 ↔ v.as_ideal ∣ ideal.span {r}
theorem measure_theory.integral_fn_integral_sub {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] {E' : Type u_7} [normed_group E'] [complete_space E'] [normed_space ℝ E'] ⦃f g : α × β → E⦄ (F : E → E') (hf : measure_theory.integrable f (μ.prod ν)) (hg : measure_theory.integrable g (μ.prod ν)) : ∫ (x : α), F (∫ (y : β), f (x, y) - g (x, y) ∂ν) ∂μ = ∫ (x : α), F (∫ (y : β), f (x, y) ∂ν - ∫ (y : β), g (x, y) ∂ν) ∂μ
theorem subgroup.exists_right_complement'_of_coprime_of_fintype {G : Type u} [group G] [fintype G] {N : subgroup G} [N.normal] (hN : (fintype.card ↥N).coprime N.index) : ∃ (H : subgroup G), N.is_complement' H
theorem minpoly.eq_X_sub_C_of_algebra_map_inj {A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] [nontrivial B] (a : A) (hf : function.injective ⇑(algebra_map A B)) : minpoly A (⇑(algebra_map A B) a) = polynomial.X - ⇑polynomial.C a
theorem affine.simplex.face_points' {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : ℕ} (s : affine.simplex k P n) {fs : finset (fin (n + 1))} {m : ℕ} (h : fs.card = m + 1) : (s.face h).points = s.points ∘ ⇑(fs.order_emb_of_fin h)
theorem is_square.inv {α : Type u_2} [division_monoid α] {a : α} : is_square a → is_square a⁻¹
theorem exp_sum_of_commute {𝕂 : Type u_1} {𝔸 : Type u_2} [is_R_or_C 𝕂] [normed_ring 𝔸] [normed_algebra 𝕂 𝔸] [complete_space 𝔸] {ι : Type u_3} (s : finset ι) (f : ι → 𝔸) (h : ∀ (i : ι), i ∈ s → ∀ (j : ι), j ∈ s → commute (f i) (f j)) : exp 𝕂 (s.sum (λ (i : ι), f i)) = s.noncomm_prod (λ (i : ι), exp 𝕂 (f i)) _
theorem finset.sized_slice {α : Type u_1} {𝒜 : finset (finset α)} {r : ℕ} : set.sized r ↑(𝒜.slice r)
theorem ennreal.prod_lt_top {α : Type u_1} {s : finset α} {f : α → ennreal} (h : ∀ (a : α), a ∈ s → f a ≠ ⊤) : s.prod (λ (a : α), f a) < ⊤
theorem line_map_slope_slope_sub_div_sub {k : Type u_1} {E : Type u_2} {PE : Type u_3} [field k] [add_comm_group E] [module k E] [add_torsor E PE] (f : k → PE) (a b c : k) (h : a ≠ c) : ⇑(affine_map.line_map (slope f a b) (slope f b c)) ((c - b) / (c - a)) = slope f a c
theorem linear_pmap.sup_h_of_disjoint {R : Type u_1} [ring R] {E : Type u_2} [add_comm_group E] [module R E] {F : Type u_3} [add_comm_group F] [module R F] (f g : linear_pmap R E F) (h : disjoint f.domain g.domain) (x : ↥(f.domain)) (y : ↥(g.domain)) (hxy : ↑x = ↑y) : ⇑f x = ⇑g y
theorem centroid_mem_affine_span_of_card_eq_add_one (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} [char_zero k] {s : finset ι} (p : ι → P) {n : ℕ} (h : s.card = n + 1) : finset.centroid k s p ∈ affine_span k (set.range p)
theorem affine_subspace.mem_affine_span_singleton (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (p1 p2 : P) : p1 ∈ affine_span k {p2} ↔ p1 = p2
theorem category_theory.triangulated.pretriangulated.rot_of_dist_triangle (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C ℤ] [category_theory.preadditive C] [∀ (n : ℤ), (category_theory.shift_functor C n).additive] [category_theory.triangulated.pretriangulated C] (T : category_theory.triangulated.triangle C) (H : T ∈ dist_triang C) : T.rotate ∈ dist_triang C
theorem polynomial.cyclotomic_one (R : Type u_1) [ring R] : polynomial.cyclotomic 1 R = polynomial.X - 1
theorem continuous_on.measurable_piecewise {α : Type u_1} {γ : Type u_3} [topological_space α] [measurable_space α] [opens_measurable_space α] [topological_space γ] [measurable_space γ] [borel_space γ] {f g : α → γ} {s : set α} [Π (j : α), decidable (j ∈ s)] (hf : continuous_on f s) (hg : continuous_on g sᶜ) (hs : measurable_set s) : measurable (s.piecewise f g)
theorem interval_integrable.def {E : Type u_3} [normed_group E] {f : ℝ → E} {a b : ℝ} {μ : measure_theory.measure ℝ} (h : interval_integrable f μ a b) : measure_theory.integrable_on f (set.interval_oc a b) μ
theorem nnreal.is_greatest_Lp {ι : Type u} (s : finset ι) (f : ι → nnreal) {p q : ℝ} (hpq : p.is_conjugate_exponent q) : is_greatest ((λ (g : ι → nnreal), s.sum (λ (i : ι), f i * g i)) '' {g : ι → nnreal | s.sum (λ (i : ι), g i ^ q) ≤ 1}) (s.sum (λ (i : ι), f i ^ p) ^ (1 / p))
theorem padic_norm.zero (p : ℕ) : padic_norm p 0 = 0
theorem measurable_set.measure_eq_supr_is_closed_of_ne_top {α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [μ.weakly_regular] ⦃A : set α⦄ (hA : measurable_set A) (h'A : ⇑μ A ≠ ⊤) : ⇑μ A = ⨆ (K : set α) (H : K ⊆ A) (h : is_closed K), ⇑μ K
theorem finsupp.distrib_mul_action_hom_ext' {α : Type u_1} {M : Type u_5} {N : Type u_7} {R : Type u_11} [semiring R] [add_comm_monoid M] [add_comm_monoid N] [distrib_mul_action R M] [distrib_mul_action R N] {f g : (α →₀ M) →+[R] N} (h : ∀ (a : α), f.comp (finsupp.distrib_mul_action_hom.single a) = g.comp (finsupp.distrib_mul_action_hom.single a)) : f = g
theorem module.finite.injective_of_surjective_endomorphism {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (f : M →ₗ[R] M) [hfg : module.finite R M] (f_surj : function.surjective ⇑f) : function.injective ⇑f
theorem spectrum.subset_polynomial_aeval {𝕜 : Type u} {A : Type v} [field 𝕜] [ring A] [algebra 𝕜 A] (a : A) (p : polynomial 𝕜) : (λ (k : 𝕜), polynomial.eval k p) '' spectrum 𝕜 a ⊆ spectrum 𝕜 (⇑(polynomial.aeval a) p)
theorem metric.inf_dist_zero_of_mem_closure {α : Type u} [pseudo_metric_space α] {s : set α} {x : α} (hx : x ∈ closure s) : metric.inf_dist x s = 0
theorem euclidean_geometry.angle_eq_of_ne {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 : P} (h : p1 ≠ p2) : euclidean_geometry.angle p1 p2 p1 = 0
theorem linear_equiv.dim_eq {R : Type u} [ring R] {M : Type v} [add_comm_group M] [module R M] {M₁ : Type v} [add_comm_group M₁] [module R M₁] (f : M ≃ₗ[R] M₁) : module.rank R M = module.rank R M₁
theorem interval_integral.continuous_within_at_of_dominated_interval {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {μ : measure_theory.measure ℝ} {X : Type u_5} [topological_space X] [topological_space.first_countable_topology X] {F : X → ℝ → E} {x₀ : X} {bound : ℝ → ℝ} {a b : ℝ} {s : set X} (hF_meas : ∀ᶠ (x : X) in nhds_within x₀ s, measure_theory.ae_strongly_measurable (F x) (μ.restrict (set.interval_oc a b))) (h_bound : ∀ᶠ (x : X) in nhds_within x₀ s, ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → ∥F x t∥ ≤ bound t) (bound_integrable : interval_integrable bound μ a b) (h_cont : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → continuous_within_at (λ (x : X), F x t) s x₀) : continuous_within_at (λ (x : X), ∫ (t : ℝ) in a..b, F x t ∂μ) s x₀
theorem ext_chart_preimage_mem_nhds {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] (x : M) {t : set M} (ht : t ∈ nhds x) : ⇑((ext_chart_at I x).symm) ⁻¹' t ∈ nhds (⇑(ext_chart_at I x) x)
theorem set.Icc_union_Icc {α : Type u_1} [linear_order α] {a b c d : α} (h₁ : linear_order.min a b < linear_order.max c d) (h₂ : linear_order.min c d < linear_order.max a b) : set.Icc a b ∪ set.Icc c d = set.Icc (linear_order.min a c) (linear_order.max b d)
theorem set_of_is_preconnected_subset_of_ordered {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] : {s : set α | is_preconnected s} ⊆ set.range (function.uncurry set.Icc) ∪ set.range (function.uncurry set.Ico) ∪ set.range (function.uncurry set.Ioc) ∪ set.range (function.uncurry set.Ioo) ∪ (set.range set.Ici ∪ set.range set.Ioi ∪ set.range set.Iic ∪ set.range set.Iio ∪ {set.univ, ∅})
theorem matrix.det_eq_of_forall_col_eq_smul_add_pred {R : Type v} [comm_ring R] {n : ℕ} {A B : matrix (fin (n + 1)) (fin (n + 1)) R} (c : fin n → R) (A_zero : ∀ (i : fin (n + 1)), A i 0 = B i 0) (A_succ : ∀ (i : fin (n + 1)) (j : fin n), A i j.succ = B i j.succ + c j * A i (⇑fin.cast_succ j)) : A.det = B.det
theorem real.Lp_add_le_tsum_of_nonneg {ι : Type u} {f g : ι → ℝ} {p : ℝ} (hp : 1 ≤ p) (hf : ∀ (i : ι), 0 ≤ f i) (hg : ∀ (i : ι), 0 ≤ g i) (hf_sum : summable (λ (i : ι), f i ^ p)) (hg_sum : summable (λ (i : ι), g i ^ p)) : summable (λ (i : ι), (f i + g i) ^ p) ∧ (∑' (i : ι), (f i + g i) ^ p) ^ (1 / p) ≤ (∑' (i : ι), f i ^ p) ^ (1 / p) + (∑' (i : ι), g i ^ p) ^ (1 / p)
theorem metric.diam_ball {α : Type u} [pseudo_metric_space α] {x : α} {r : ℝ} (h : 0 ≤ r) : metric.diam (metric.ball x r) ≤ 2 * r
theorem fin.succ_above_left_injective {n : ℕ} : function.injective fin.succ_above
theorem laurent_polynomial.mul_T_assoc {R : Type u_1} [semiring R] (f : laurent_polynomial R) (m n : ℤ) : f * laurent_polynomial.T m * laurent_polynomial.T n = f * laurent_polynomial.T (m + n)
theorem finset.order_emb_of_fin_unique' {α : Type u_1} [linear_order α] {s : finset α} {k : ℕ} (h : s.card = k) {f : fin k ↪o α} (hfs : ∀ (x : fin k), ⇑f x ∈ s) : f = s.order_emb_of_fin h
theorem has_sbtw.sbtw.cyclic_right {α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : has_sbtw.sbtw c a b
theorem nilpotency_class_quotient_le {G : Type u_1} [group G] (H : subgroup G) [H.normal] [h : group.is_nilpotent G] : group.nilpotency_class (G ⧸ H) ≤ group.nilpotency_class G
theorem Top.presheaf.stalk_hom_ext {C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X : Top} (F : Top.presheaf C X) {x : ↥X} {Y : C} {f₁ f₂ : F.stalk x ⟶ Y} (ih : ∀ (U : topological_space.opens ↥X) (hxU : x ∈ U), F.germ ⟨x, hxU⟩ ≫ f₁ = F.germ ⟨x, hxU⟩ ≫ f₂) : f₁ = f₂
theorem submodule.coe_norm {𝕜 : Type u_1} {_x : ring 𝕜} {E : Type u_2} [semi_normed_group E] {_x_1 : module 𝕜 E} {s : submodule 𝕜 E} (x : ↥s) : ∥x∥ = ∥↑x∥
theorem geometry.simplicial_complex.disjoint_or_exists_inter_eq_convex_hull {𝕜 : Type u_1} {E : Type u_2} [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] {K : geometry.simplicial_complex 𝕜 E} {s t : finset E} (hs : s ∈ K.faces) (ht : t ∈ K.faces) : disjoint (⇑(convex_hull 𝕜) ↑s) (⇑(convex_hull 𝕜) ↑t) ∨ ∃ (u : finset E) (H : u ∈ K.faces), ⇑(convex_hull 𝕜) ↑s ∩ ⇑(convex_hull 𝕜) ↑t = ⇑(convex_hull 𝕜) ↑u
theorem sylow.exists_subgroup_card_pow_prime_le {G : Type u} [group G] [fintype G] (p : ℕ) {n m : ℕ} [hp : fact (nat.prime p)] (hdvd : p ^ m ∣ fintype.card G) (H : subgroup G) (hH : fintype.card ↥H = p ^ n) (hnm : n ≤ m) : ∃ (K : subgroup G), fintype.card ↥K = p ^ m ∧ H ≤ K
theorem integral_closure.is_fraction_ring_of_finite_extension {A : Type u_4} (K : Type u_5) [comm_ring A] [is_domain A] (L : Type u_6) [field K] [field L] [algebra A K] [is_fraction_ring A K] [algebra A L] [algebra K L] [is_scalar_tower A K L] [finite_dimensional K L] : is_fraction_ring ↥(integral_closure A L) L
theorem measure_theory.strongly_measurable_const' {α : Type u_1} {β : Type u_2} {m : measurable_space α} [topological_space β] {f : α → β} (hf : ∀ (x y : α), f x = f y) : measure_theory.strongly_measurable f
theorem antitone.concave_on_univ_of_deriv {f : ℝ → ℝ} (hf : differentiable ℝ f) (hf'_anti : antitone (deriv f)) : concave_on ℝ set.univ f
theorem tendsto_subseq_of_frequently_bounded {X : Type u_1} [pseudo_metric_space X] [proper_space X] {s : set X} (hs : metric.bounded s) {x : ℕ → X} (hx : ∃ᶠ (n : ℕ) in filter.at_top, x n ∈ s) : ∃ (a : X) (H : a ∈ closure s) (φ : ℕ → ℕ), strict_mono φ ∧ filter.tendsto (x ∘ φ) filter.at_top (nhds a)
theorem algebraic_topology.dold_kan.cs_down_0_not_rel_left (j : ℕ) : ¬algebraic_topology.dold_kan.c.rel 0 j
theorem affine.simplex.centroid_eq_iff {k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [char_zero k] {n : ℕ} (s : affine.simplex k P n) {fs₁ fs₂ : finset (fin (n + 1))} {m₁ m₂ : ℕ} (h₁ : fs₁.card = m₁ + 1) (h₂ : fs₂.card = m₂ + 1) : finset.centroid k fs₁ s.points = finset.centroid k fs₂ s.points ↔ fs₁ = fs₂
theorem char.quadratic_char_mul {F : Type u_1} [field F] [fintype F] [decidable_eq F] (a b : F) : char.quadratic_char F (a * b) = char.quadratic_char F a * char.quadratic_char F b
theorem add_submonoid.localization_map.map_add_right {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M →+ P} {T : add_submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ T) {Q : Type u_4} [add_comm_monoid Q] {k : T.localization_map Q} (z : N) : ⇑(f.map hy k) z + ⇑(k.to_map) (⇑g ↑((f.sec z).snd)) = ⇑(k.to_map) (⇑g (f.sec z).fst)
theorem vector_span_range_eq_span_range_vsub_right (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} (p : ι → P) (i0 : ι) : vector_span k (set.range p) = submodule.span k (set.range (λ (i : ι), p i -ᵥ p i0))
theorem isometry_subtype_coe {α : Type u} [pseudo_emetric_space α] {s : set α} : isometry coe
theorem finset.sum_pow_mul_eq_add_pow {α : Type u_1} {R : Type u_2} [comm_semiring R] (a b : R) (s : finset α) : s.powerset.sum (λ (t : finset α), a ^ t.card * b ^ (s.card - t.card)) = (a + b) ^ s.card
theorem interval_integral.measure_integral_sub_linear_is_o_of_tendsto_ae_of_le' {ι : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {c : E} {l l' : filter ℝ} {lt : filter ι} {μ : measure_theory.measure ℝ} {u v : ι → ℝ} [l'.is_measurably_generated] [filter.tendsto_Ixx_class set.Ioc l l'] (hfm : strongly_measurable_at_filter f l' μ) (hf : filter.tendsto f (l' ⊓ μ.ae) (nhds c)) (hl : μ.finite_at_filter l') (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) (huv : u ≤ᶠ[lt] v) : (λ (t : ι), ∫ (x : ℝ) in u t..v t, f x ∂μ - (⇑μ (set.Ioc (u t) (v t))).to_real • c) =o[lt] λ (t : ι), (⇑μ (set.Ioc (u t) (v t))).to_real
theorem ideal.comap_of_equiv {R : Type u} {S : Type v} [ring R] [ring S] (I : ideal R) (f : R ≃+* S) : ideal.comap ↑f (ideal.comap ↑(f.symm) I) = I
theorem subfield.mul_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x * y ∈ s
theorem right.add_lt_add {α : Type u_1} [has_add α] [preorder α] [covariant_class α α has_add.add has_le.le] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c d : α} (h₁ : a < b) (h₂ : c < d) : a + c < b + d
theorem has_ssubset.ssubset.ne {α : Type u} [has_ssubset α] [is_irrefl α has_ssubset.ssubset] {a b : α} : a ⊂ b → a ≠ b
theorem affine_subspace.direction_top (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : ⊤.direction = ⊤
theorem is_right_regular_of_mul_eq_one {R : Type u_1} {a b : R} [monoid R] (h : a * b = 1) : is_right_regular a
theorem measurable.le_map {α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : measurable f → m₂ ≤ measurable_space.map f m₁
theorem asymptotics.bound_of_is_O_cofinite {α : Type u_1} {E : Type u_3} {F'' : Type u_10} [has_norm E] [normed_group F''] {f : α → E} {g'' : α → F''} (h : f =O[filter.cofinite] g'') : ∃ (C : ℝ) (H : C > 0), ∀ ⦃x : α⦄, g'' x ≠ 0 → ∥f x∥ ≤ C * ∥g'' x∥
theorem normed_ring.inverse_add_norm_diff_second_order {R : Type u_1} [normed_ring R] [complete_space R] (x : Rˣ) : (λ (t : R), ring.inverse (↑x + t) - ↑x⁻¹ + ↑x⁻¹ * t * ↑x⁻¹) =O[nhds 0] λ (t : R), ∥t∥ ^ 2
theorem star_convex.preimage_add_left {𝕜 : Type u_1} {E : Type u_2} [ordered_semiring 𝕜] [add_comm_monoid E] [module 𝕜 E] {x z : E} {s : set E} (hs : star_convex 𝕜 (x + z) s) : star_convex 𝕜 x ((λ (x : E), x + z) ⁻¹' s)
theorem monoid_algebra.mem_adjoint_support {R : Type u_1} {M : Type u_2} [comm_semiring R] [monoid M] (f : monoid_algebra R M) : f ∈ algebra.adjoin R (⇑(monoid_algebra.of R M) '' ↑(f.support))
theorem polynomial.gal.restrict_smul {F : Type u_1} [field F] {p : polynomial F} {E : Type u_2} [field E] [algebra F E] [fact (polynomial.splits (algebra_map F E) p)] (ϕ : E ≃ₐ[F] E) (x : ↥(p.root_set E)) : ↑(⇑(polynomial.gal.restrict p E) ϕ • x) = ⇑ϕ ↑x
theorem linear_independent_iff_card_eq_finrank_span {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type u_1} [fintype ι] {b : ι → V} : linear_independent K b ↔ fintype.card ι = set.finrank K (set.range b)
theorem inner_product_geometry.sin_angle_sub_add_angle_sub_rev_eq_sin_angle {V : Type u_1} [inner_product_space ℝ V] {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : real.sin (inner_product_geometry.angle x (x - y) + inner_product_geometry.angle y (y - x)) = real.sin (inner_product_geometry.angle x y)
theorem is_right_regular_iff {R : Type u_1} [has_mul R] {a : R} : is_right_regular a ↔ is_smul_regular R (mul_opposite.op a)
theorem interior_convex_hull_aff_basis {ι : Type u_1} {E : Type u_2} [fintype ι] [normed_group E] [normed_space ℝ E] (b : affine_basis ι ℝ E) : interior (⇑(convex_hull ℝ) (set.range b.points)) = {x : E | ∀ (i : ι), 0 < ⇑(b.coord i) x}
theorem box_integral.integrable.tendsto_integral_sum_to_filter_prod_self_inf_Union_eq_uniformity {ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} (h : box_integral.integrable I l f vol) : filter.tendsto (λ (π : box_integral.tagged_prepartition I × box_integral.tagged_prepartition I), (box_integral.integral_sum f vol π.fst, box_integral.integral_sum f vol π.snd)) ((l.to_filter I).prod (l.to_filter I) ⊓ filter.principal {π : box_integral.tagged_prepartition I × box_integral.tagged_prepartition I | π.fst.Union = π.snd.Union}) (uniformity F)
theorem set.subset_bUnion_of_mem {α : Type u_1} {β : Type u_2} {s : set α} {u : α → set β} {x : α} (xs : x ∈ s) : u x ⊆ ⋃ (x : α) (H : x ∈ s), u x
theorem cont_diff_bump_of_inner.dist_normed_convolution_le {G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G → E'} [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ E'] [inner_product_space ℝ G] [complete_space E'] {φ : cont_diff_bump_of_inner 0} [borel_space G] [measure_theory.is_locally_finite_measure μ] [μ.is_open_pos_measure] [finite_dimensional ℝ G] [μ.is_add_left_invariant] {x₀ : G} {ε : ℝ} (hmg : measure_theory.ae_strongly_measurable g μ) (hg : ∀ (x : G), x ∈ metric.ball x₀ φ.R → has_dist.dist (g x) (g x₀) ≤ ε) : has_dist.dist (convolution (φ.normed μ) g (continuous_linear_map.lsmul ℝ ℝ) μ x₀) (g x₀) ≤ ε
theorem submodule.mem_orthogonal {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) (v : E) : v ∈ Kᗮ ↔ ∀ (u : E), u ∈ K → has_inner.inner u v = 0
theorem add_con.eq {M : Type u_1} [has_add M] (c : add_con M) {a b : M} : ↑a = ↑b ↔ ⇑c a b
theorem order_of_pos {G : Type u} [fintype G] [left_cancel_monoid G] (x : G) : 0 < order_of x
theorem set.Inter_subset_of_subset {α : Type u_1} {ι : Sort u_4} {s : ι → set α} {t : set α} (i : ι) (h : s i ⊆ t) : (⋂ (i : ι), s i) ⊆ t
theorem set.subsingleton_coe {α : Type u} (s : set α) : subsingleton ↥s ↔ s.subsingleton
theorem map_Sup_of_continuous_at_of_monotone {α : Type u} {β : Type v} [complete_linear_order α] [topological_space α] [order_topology α] [complete_linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} (Cf : continuous_at f (has_Sup.Sup s)) (Mf : monotone f) (fbot : f ⊥ = ⊥) : f (has_Sup.Sup s) = has_Sup.Sup (f '' s)
theorem nsmul_eq_smul_cast (R : Type u_2) {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (n : ℕ) (b : M) : n • b = ↑n • b
theorem first_order.language.embedding.is_elementary_of_exists {L : first_order.language} {M : Type u_3} {N : Type u_4} [L.Structure M] [L.Structure N] (f : L.embedding M N) (htv : ∀ (n : ℕ) (φ : L.bounded_formula empty (n + 1)) (x : fin n → M) (a : N), φ.realize inhabited.default (fin.snoc (⇑f ∘ x) a) → (∃ (b : M), φ.realize inhabited.default (fin.snoc (⇑f ∘ x) (⇑f b)))) {n : ℕ} (φ : L.formula (fin n)) (x : fin n → M) : φ.realize (⇑f ∘ x) ↔ φ.realize x
theorem cont_diff_at.fst {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {n : with_top ℕ} {f : E → F × G} {x : E} (hf : cont_diff_at 𝕜 n f x) : cont_diff_at 𝕜 n (λ (x : E), (f x).fst) x
theorem complex.norm_dslope_le_div_of_maps_to_ball {E : Type u_1} [normed_group E] [normed_space ℂ E] {R₁ R₂ : ℝ} {f : ℂ → E} {c z : ℂ} (hd : differentiable_on ℂ f (metric.ball c R₁)) (h_maps : set.maps_to f (metric.ball c R₁) (metric.ball (f c) R₂)) (hz : z ∈ metric.ball c R₁) : ∥dslope f c z∥ ≤ R₂ / R₁
theorem absolute_value.is_admissible.exists_partition {R : Type u_1} [euclidean_domain R] {abv : absolute_value R ℤ} {ι : Type u_2} [fintype ι] {ε : ℝ} (hε : 0 < ε) {b : R} (hb : b ≠ 0) (A : ι → R) (h : abv.is_admissible) : ∃ (t : ι → fin (h.card ε)), ∀ (i₀ i₁ : ι), t i₀ = t i₁ → ↑(⇑abv (A i₁ % b - A i₀ % b)) < ⇑abv b • ε
theorem measure_theory.outer_measure.trim_sup {α : Type u_1} [measurable_space α] (m₁ m₂ : measure_theory.outer_measure α) : (m₁ ⊔ m₂).trim = m₁.trim ⊔ m₂.trim
theorem int.exists_least_of_bdd {P : ℤ → Prop} (Hbdd : ∃ (b : ℤ), ∀ (z : ℤ), P z → b ≤ z) (Hinh : ∃ (z : ℤ), P z) : ∃ (lb : ℤ), P lb ∧ ∀ (z : ℤ), P z → lb ≤ z
theorem complex.exists_root {f : polynomial ℂ} (hf : 0 < f.degree) : ∃ (z : ℂ), f.is_root z
theorem mem_gal_basis_iff (K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] (U : set (L ≃ₐ[K] L)) : U ∈ gal_basis K L ↔ U ∈ subgroup.carrier '' fixed_by_finite K L
theorem category_theory.functor.conj_eq_to_hom_iff_heq {C : Type u₁} [category_theory.category C] {W X Y Z : C} (f : W ⟶ X) (g : Y ⟶ Z) (h : W = Y) (h' : X = Z) : f = category_theory.eq_to_hom h ≫ g ≫ category_theory.eq_to_hom _ ↔ f == g
theorem affine_independent.finrank_vector_span_image_finset {k : Type u_1} {V : Type u_2} {P : Type u_3} {ι : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {p : ι → P} (hi : affine_independent k p) {s : finset ι} {n : ℕ} (hc : s.card = n + 1) : finite_dimensional.finrank k ↥(vector_span k ↑(finset.image p s)) = n
theorem asymptotics.is_O.eventually_mul_div_cancel {α : Type u_1} {𝕜 : Type u_14} [normed_field 𝕜] {l : filter α} {u v : α → 𝕜} (h : u =O[l] v) : u / v * v =ᶠ[l] u
theorem disjoint_nhds_within_of_mem_discrete {α : Type u} [topological_space α] {s : set α} [discrete_topology ↥s] {x : α} (hx : x ∈ s) : ∃ (U : set α) (H : U ∈ nhds_within x {x}ᶜ), disjoint U s
theorem finset.bdd_below {α : Type u} [semilattice_inf α] [nonempty α] (s : finset α) : bdd_below ↑s
theorem vsub_eq_zero_iff_eq {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] {p1 p2 : P} : p1 -ᵥ p2 = 0 ↔ p1 = p2
theorem is_ring_hom.map_sub {α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} {x y : α} (hf : is_ring_hom f) : f (x - y) = f x - f y
theorem monovary_on.sum_comp_perm_mul_eq_sum_mul_iff {ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {s : finset ι} {σ : equiv.perm ι} {f g : ι → α} (hfg : monovary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f (⇑σ i) * g i) = s.sum (λ (i : ι), f i * g i) ↔ monovary_on (f ∘ ⇑σ) g ↑s
theorem function.update_comp_eq_of_injective {α : Sort u} {α' : Sort w} [decidable_eq α] [decidable_eq α'] {β : Sort u_1} (g : α' → β) {f : α → α'} (hf : function.injective f) (i : α) (a : β) : function.update g (f i) a ∘ f = function.update (g ∘ f) i a
theorem continuous_at_right_of_monotone_on_of_exists_between {α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} {a : α} (h_mono : monotone_on f s) (hs : s ∈ nhds_within a (set.Ici a)) (hfs : ∀ (b : β), b > f a → (∃ (c : α) (H : c ∈ s), f c ∈ set.Ioo (f a) b)) : continuous_within_at f (set.Ici a) a
theorem category_theory.limits.biproduct.cone_point_unique_up_to_iso_hom {J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (f : J → C) [category_theory.limits.has_biproduct f] {b : category_theory.limits.bicone f} (hb : b.is_bilimit) : (hb.is_limit.cone_point_unique_up_to_iso (category_theory.limits.biproduct.is_limit f)).hom = category_theory.limits.biproduct.lift b.π
theorem phragmen_lindelof.eq_on_quadrant_III {E : Type u_1} [normed_group E] [normed_space ℂ E] {f g : ℂ → E} (hdf : diff_cont_on_cl ℂ f (set.Iio 0 ×ℂ set.Iio 0)) (hBf : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ filter.principal (set.Iio 0 ×ℂ set.Iio 0)] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hdg : diff_cont_on_cl ℂ g (set.Iio 0 ×ℂ set.Iio 0)) (hBg : ∃ (c : ℝ) (H : c < 2) (B : ℝ), g =O[filter.comap complex.abs filter.at_top ⊓ filter.principal (set.Iio 0 ×ℂ set.Iio 0)] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hre : ∀ (x : ℝ), x ≤ 0 → f ↑x = g ↑x) (him : ∀ (x : ℝ), x ≤ 0 → f (↑x * complex.I) = g (↑x * complex.I)) : set.eq_on f g {z : ℂ | z.re ≤ 0 ∧ z.im ≤ 0}
theorem not_interval_integrable_of_sub_inv_is_O_punctured {F : Type u_2} [normed_group F] {f : ℝ → F} {a b c : ℝ} (hf : (λ (x : ℝ), (x - c)⁻¹) =O[nhds_within c {c}ᶜ] f) (hne : a ≠ b) (hc : c ∈ set.interval a b) : ¬interval_integrable f measure_theory.measure_space.volume a b
theorem measure_theory.lintegral_with_density_eq_lintegral_mul₀' {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : α → ennreal} (hf : ae_measurable f μ) {g : α → ennreal} (hg : ae_measurable g (μ.with_density f)) : ∫⁻ (a : α), g a ∂μ.with_density f = ∫⁻ (a : α), (f * g) a ∂μ
theorem add_monoid_algebra.mem_span_support {k : Type u₁} {G : Type u₂} [semiring k] [add_zero_class G] (f : add_monoid_algebra k G) : f ∈ submodule.span k (⇑(add_monoid_algebra.of k G) '' ↑(f.support))
theorem category_theory.limits.mono_of_is_limit_fork {C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} {c : category_theory.limits.fork f g} (i : category_theory.limits.is_limit c) : category_theory.mono c.ι
theorem add_con.lift_comp_mk' {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} {f : M →+ P} (H : c ≤ add_con.ker f) : (c.lift f H).comp c.mk' = f
theorem add_monoid_hom.map_finsupp_sum {α : Type u_1} {M : Type u_5} {N : Type u_7} {P : Type u_8} [has_zero M] [add_comm_monoid N] [add_comm_monoid P] (h : N →+ P) (f : α →₀ M) (g : α → M → N) : ⇑h (f.sum g) = f.sum (λ (a : α) (b : M), ⇑h (g a b))
theorem zmod.χ₈'_eq_χ₄_mul_χ₈ (a : zmod 8) : ⇑zmod.χ₈' a = ⇑zmod.χ₄ ↑a * ⇑zmod.χ₈ a
theorem left.one_lt_mul' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
theorem topological_vector_bundle_core.continuous_proj {R : Type u_1} {B : Type u_3} {F : Type u_4} [nondiscrete_normed_field R] [normed_group F] [normed_space R F] [topological_space B] {ι : Type u_6} (Z : topological_vector_bundle_core R B F ι) : continuous Z.proj
theorem fintype.exists_ne_map_eq_of_infinite {α : Type u_1} {β : Type u_2} [infinite α] [fintype β] (f : α → β) : ∃ (x y : α), x ≠ y ∧ f x = f y
theorem map_bit1 {F : Type u_1} {α : Type u_2} {β : Type u_3} [non_assoc_semiring α] [non_assoc_semiring β] [ring_hom_class F α β] (f : F) (a : α) : ⇑f (bit1 a) = bit1 (⇑f a)
theorem metric.exists_dist_lt_of_Hausdorff_dist_lt {α : Type u} [pseudo_metric_space α] {s t : set α} {x : α} {r : ℝ} (h : x ∈ s) (H : metric.Hausdorff_dist s t < r) (fin : emetric.Hausdorff_edist s t ≠ ⊤) : ∃ (y : α) (H : y ∈ t), has_dist.dist x y < r
theorem associates.eq_pow_find_of_dvd_irreducible_pow {α : Type u_1} [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] {a p : associates α} (hp : irreducible p) [Π (n : ℕ), decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n) : a = p ^ nat.find _
theorem subsemiring.list_prod_mem {R : Type u_1} [semiring R] (s : subsemiring R) {l : list R} : (∀ (x : R), x ∈ l → x ∈ s) → l.prod ∈ s
theorem continuous_linear_map.op_norm_add_le {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [ring_hom_isometric σ₁₂] (f g : E →SL[σ₁₂] F) : ∥f + g∥ ≤ ∥f∥ + ∥g∥
theorem measure_theory.ae_strongly_measurable.integral_prod_right' {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] ⦃f : α × β → E⦄ (hf : measure_theory.ae_strongly_measurable f (μ.prod ν)) : measure_theory.ae_strongly_measurable (λ (x : α), ∫ (y : β), f (x, y) ∂ν) μ
theorem AddMon.filtered_colimits.colimit_add_mk_eq {J : Type v} [category_theory.small_category J] (F : J ⥤ AddMon) [category_theory.is_filtered J] (x y : Σ (j : J), ↥(F.obj j)) (k : J) (f : x.fst ⟶ k) (g : y.fst ⟶ k) : AddMon.filtered_colimits.M.mk F x + AddMon.filtered_colimits.M.mk F y = AddMon.filtered_colimits.M.mk F ⟨k, ⇑(F.map f) x.snd + ⇑(F.map g) y.snd⟩
theorem absolute_value.exists_partition_int (n : ℕ) {ε : ℝ} (hε : 0 < ε) {b : ℤ} (hb : b ≠ 0) (A : fin n → ℤ) : ∃ (t : fin n → fin ⌈1 / ε⌉₊), ∀ (i₀ i₁ : fin n), t i₀ = t i₁ → ↑|A i₁ % b - A i₀ % b| < |b| • ε
theorem measure_theory.measure.add_haar_preimage_continuous_linear_map {E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] {f : E →L[ℝ] E} (hf : ⇑linear_map.det ↑f ≠ 0) (s : set E) : ⇑μ (⇑f ⁻¹' s) = ennreal.of_real |(⇑linear_map.det ↑f)⁻¹| * ⇑μ s
theorem add_monoid.is_torsion_free.not_torsion {G : Type u_1} [add_group G] [hN : nontrivial G] : add_monoid.is_torsion_free G → ¬add_monoid.is_torsion G
theorem local_homeomorph.preimage_interior {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) (s : set β) : e.to_local_equiv.source ∩ ⇑e ⁻¹' interior s = e.to_local_equiv.source ∩ interior (⇑e ⁻¹' s)
theorem mul_equiv.map_inv {G : Type u_10} {H : Type u_11} [group G] [division_monoid H] (h : G ≃* H) (x : G) : ⇑h x⁻¹ = (⇑h x)⁻¹
theorem same_ray.nonneg_smul_left {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} {r : R} (h : same_ray R x y) (hr : 0 ≤ r) : same_ray R (r • x) y
theorem orientation.oangle_rotation_oangle_left {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x y : V) : o.oangle (⇑(o.rotation (o.oangle x y)) x) y = 0
theorem uniformity_has_basis_closure {α : Type u_1} [uniform_space α] : (uniformity α).has_basis (λ (V : set (α × α)), V ∈ uniformity α) closure
theorem finite_dimensional.finrank_eq_card_basis' {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] {ι : Type w} (h : basis ι K V) : ↑(finite_dimensional.finrank K V) = cardinal.mk ι
theorem finsupp.coe_fn_injective {α : Type u_1} {M : Type u_5} [has_zero M] : function.injective coe_fn
theorem formal_multilinear_series.lt_radius_of_is_O {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) {r : nnreal} (h₀ : r ≠ 0) {a : ℝ} (ha : a ∈ set.Ioo (-1) 1) (hp : (λ (n : ℕ), ∥p n∥ * ↑r ^ n) =O[filter.at_top] has_pow.pow a) : ↑r < p.radius
theorem fin.update_snoc_last {n : ℕ} {α : fin (n + 1) → Type u} (x : α (fin.last n)) (p : Π (i : fin n), α (⇑fin.cast_succ i)) (z : α (fin.last n)) : function.update (fin.snoc p x) (fin.last n) z = fin.snoc p z
theorem exists_open_between_and_is_compact_closure {α : Type u} [topological_space α] [locally_compact_space α] [regular_space α] {K U : set α} (hK : is_compact K) (hU : is_open U) (hKU : K ⊆ U) : ∃ (V : set α), is_open V ∧ K ⊆ V ∧ closure V ⊆ U ∧ is_compact (closure V)
theorem char_p.quotient' {R : Type u_1} [comm_ring R] (p : ℕ) [char_p R p] (I : ideal R) (h : ∀ (x : ℕ), ↑x ∈ I → ↑x = 0) : char_p (R ⧸ I) p
theorem is_alg_closed.is_cyclotomic_extension (K : Type u_1) [field K] [is_alg_closed K] (S : set ℕ+) : is_cyclotomic_extension S K K
theorem has_subset.subset.trans {α : Type u} [has_subset α] [is_trans α has_subset.subset] {a b c : α} : a ⊆ b → b ⊆ c → a ⊆ c
theorem measure_theory.condexp_indicator_aux {α : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space ℝ F'] [complete_space F'] {m m0 : measurable_space α} {μ : measure_theory.measure α} {f : α → F'} {s : set α} (hm : m ≤ m0) (hs : measurable_set s) (hf : f =ᵐ[μ.restrict sᶜ] 0) : measure_theory.condexp m μ (s.indicator f) =ᵐ[μ] s.indicator (measure_theory.condexp m μ f)
theorem circle_deg1_lift.tendsto_translation_number (f : circle_deg1_lift) (x : ℝ) : filter.tendsto (λ (n : ℕ), (⇑(f ^ n) x - x) / ↑n) filter.at_top (nhds f.translation_number)
theorem csupr_eq_of_forall_le_of_forall_lt_exists_gt {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {b : α} [nonempty ι] {f : ι → α} (h₁ : ∀ (i : ι), f i ≤ b) (h₂ : ∀ (w : α), w < b → (∃ (i : ι), w < f i)) : (⨆ (i : ι), f i) = b
theorem concave_on.inf {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [linear_ordered_add_comm_monoid β] [has_scalar 𝕜 E] [module 𝕜 β] [ordered_smul 𝕜 β] {s : set E} {f g : E → β} (hf : concave_on 𝕜 s f) (hg : concave_on 𝕜 s g) : concave_on 𝕜 s (f ⊓ g)
theorem finsupp.add_sum_erase' {α : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [add_comm_monoid N] (f : α →₀ M) (y : α) (g : α → M → N) (hg : ∀ (i : α), g i 0 = 0) : g y (⇑f y) + (finsupp.erase y f).sum g = f.sum g
theorem category_theory.strong_mono_comp {C : Type u} [category_theory.category C] {P Q R : C} (f : P ⟶ Q) (g : Q ⟶ R) [category_theory.strong_mono f] [category_theory.strong_mono g] : category_theory.strong_mono (f ≫ g)
theorem measure_theory.outer_measure.mk_metric_mono_smul {X : Type u_2} [emetric_space X] {m₁ m₂ : ennreal → ennreal} {c : ennreal} (hc : c ≠ ⊤) (h0 : c ≠ 0) (hle : m₁ ≤ᶠ[nhds_within 0 (set.Ici 0)] c • m₂) : measure_theory.outer_measure.mk_metric m₁ ≤ c • measure_theory.outer_measure.mk_metric m₂
theorem measurable_of_tendsto_ennreal' {α : Type u_1} [measurable_space α] {ι : Type u_2} {f : ι → α → ennreal} {g : α → ennreal} (u : filter ι) [u.ne_bot] [u.is_countably_generated] (hf : ∀ (i : ι), measurable (f i)) (lim : filter.tendsto f u (nhds g)) : measurable g
theorem smul_inv'' {M : Type u} [monoid M] {F : Type v} [division_ring F] [mul_semiring_action M F] (x : M) (m : F) : x • m⁻¹ = (x • m)⁻¹
theorem edist_le_tsum_of_edist_le_of_tendsto {α : Type u_1} [pseudo_emetric_space α] {f : ℕ → α} (d : ℕ → ennreal) (hf : ∀ (n : ℕ), has_edist.edist (f n) (f n.succ) ≤ d n) {a : α} (ha : filter.tendsto f filter.at_top (nhds a)) (n : ℕ) : has_edist.edist (f n) a ≤ ∑' (m : ℕ), d (n + m)
theorem measure_theory.measure.add_haar_preimage_linear_equiv {E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (f : E ≃ₗ[ℝ] E) (s : set E) : ⇑μ (⇑f ⁻¹' s) = ennreal.of_real |⇑linear_map.det ↑(f.symm)| * ⇑μ s
theorem category_theory.category_of_elements.to_from_costructured_arrow_eq {C : Type u} [category_theory.category C] (F : Cᵒᵖ ⥤ Type v) : (category_theory.category_of_elements.from_costructured_arrow F).right_op ⋙ category_theory.category_of_elements.to_costructured_arrow F = 𝟭 (category_theory.costructured_arrow category_theory.yoneda F)
theorem probability_theory.cond_is_probability_measure {α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) {s : set α} [measure_theory.is_finite_measure μ] (hcs : ⇑μ s ≠ 0) : measure_theory.is_probability_measure (probability_theory.cond μ s)
theorem orientation.two_zsmul_oangle_neg_self_right {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x : V) : 2 • o.oangle x (-x) = 0
theorem monoid_with_zero_hom.ext_int {M : Type u_1} [monoid_with_zero M] {f g : ℤ →*₀ M} (h_neg_one : ⇑f (-1) = ⇑g (-1)) (h_nat : f.comp int.of_nat_hom.to_monoid_with_zero_hom = g.comp int.of_nat_hom.to_monoid_with_zero_hom) : f = g
theorem normed_group_hom.op_norm_le_bound {V₁ : Type u_2} {V₂ : Type u_3} [semi_normed_group V₁] [semi_normed_group V₂] (f : normed_group_hom V₁ V₂) {M : ℝ} (hMp : 0 ≤ M) (hM : ∀ (x : V₁), ∥⇑f x∥ ≤ M * ∥x∥) : ∥f∥ ≤ M
theorem set.image_id' {α : Type u} (s : set α) : (λ (x : α), x) '' s = s
theorem inner_product_geometry.angle_zero_left {V : Type u_1} [inner_product_space ℝ V] (x : V) : inner_product_geometry.angle 0 x = real.pi / 2
theorem fin.strict_mono_unique {n : ℕ} {α : Type u_1} [preorder α] {f g : fin n → α} (hf : strict_mono f) (hg : strict_mono g) (h : set.range f = set.range g) : f = g
theorem is_square_of_char_two' {R : Type u_1} [fintype R] [comm_ring R] [is_reduced R] [char_p R 2] (a : R) : is_square a
theorem measure_theory.measure.restrict_apply' {α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {s t : set α} (hs : measurable_set s) : ⇑(μ.restrict s) t = ⇑μ (t ∩ s)
theorem asymptotics.is_O_iff_eventually {α : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : α → E} {g' : α → F'} {l : filter α} : f =O[l] g' ↔ ∀ᶠ (c : ℝ) in filter.at_top, ∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g' x∥
theorem submodule.infi_orthogonal {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_3} (K : ι → submodule 𝕜 E) : (⨅ (i : ι), (K i)ᗮ) = (supr K)ᗮ
theorem mem_adjoin_of_smul_prime_pow_smul_of_minpoly_is_eiseinstein_at {R : Type u} {K : Type v} {L : Type z} {p : R} [comm_ring R] [field K] [field L] [algebra K L] [algebra R L] [algebra R K] [is_scalar_tower R K L] [is_separable K L] [is_domain R] [normalized_gcd_monoid R] [is_fraction_ring R K] [is_integrally_closed R] {B : power_basis K L} (hp : prime p) (hBint : is_integral R B.gen) {n : ℕ} {z : L} (hzint : is_integral R z) (hz : p ^ n • z ∈ algebra.adjoin R {B.gen}) (hei : (minpoly R B.gen).is_eisenstein_at (submodule.span R {p})) : z ∈ algebra.adjoin R {B.gen}
theorem metric.bounded_range_iff {α : Type u} {β : Type v} [pseudo_metric_space α] {f : β → α} : metric.bounded (set.range f) ↔ ∃ (C : ℝ), ∀ (x y : β), has_dist.dist (f x) (f y) ≤ C
theorem matrix.pow_eq_aeval_mod_charpoly {R : Type u} [comm_ring R] {n : Type v} [decidable_eq n] [fintype n] (M : matrix n n R) (k : ℕ) : M ^ k = ⇑(polynomial.aeval M) (polynomial.X ^ k %ₘ M.charpoly)
theorem finset.induction_on_min {α : Type u_1} [linear_order α] [decidable_eq α] {p : finset α → Prop} (s : finset α) (h0 : p ∅) (step : ∀ (a : α) (s : finset α), (∀ (x : α), x ∈ s → a < x) → p s → p (has_insert.insert a s)) : p s
theorem category_theory.normal_epi_category.has_colimit_parallel_pair {C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_cokernels C] [category_theory.normal_epi_category C] {X Y : C} (f g : X ⟶ Y) : category_theory.limits.has_colimit (category_theory.limits.parallel_pair f g)
theorem affine_independent.affine_span_eq_top_iff_card_eq_finrank_add_one {k : Type u_1} {V : Type u_2} {P : Type u_3} {ι : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [finite_dimensional k V] [fintype ι] {p : ι → P} (hi : affine_independent k p) : affine_span k (set.range p) = ⊤ ↔ fintype.card ι = finite_dimensional.finrank k V + 1
theorem euclidean_geometry.angle_midpoint_eq_pi {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (p1 p2 : P) (hp1p2 : p1 ≠ p2) : euclidean_geometry.angle p1 (midpoint ℝ p1 p2) p2 = real.pi
theorem fixed_points_submonoid_sup (M : Type u_1) (α : Type u_2) [monoid M] [mul_action M α] {P Q : submonoid M} : mul_action.fixed_points ↥(P ⊔ Q) α = mul_action.fixed_points ↥P α ∩ mul_action.fixed_points ↥Q α
theorem set.center_units_eq {M : Type u_1} [group_with_zero M] : set.center Mˣ = coe ⁻¹' set.center M
theorem measure_theory.outer_measure.is_metric.finset_Union_of_pairwise_separated {ι : Type u_1} {X : Type u_2} [emetric_space X] {μ : measure_theory.outer_measure X} (hm : μ.is_metric) {I : finset ι} {s : ι → set X} (hI : ∀ (i : ι), i ∈ I → ∀ (j : ι), j ∈ I → i ≠ j → is_metric_separated (s i) (s j)) : ⇑μ (⋃ (i : ι) (H : i ∈ I), s i) = I.sum (λ (i : ι), ⇑μ (s i))
theorem list.nth_of_fn {α : Type u} {n : ℕ} (f : fin n → α) (i : ℕ) : (list.of_fn f).nth i = list.of_fn_nth_val f i
theorem tendsto_pow_const_mul_const_pow_of_abs_lt_one (k : ℕ) {r : ℝ} (hr : |r| < 1) : filter.tendsto (λ (n : ℕ), ↑n ^ k * r ^ n) filter.at_top (nhds 0)
theorem norm_add_pow_two {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x y : E} : ∥x + y∥ ^ 2 = ∥x∥ ^ 2 + 2 * ⇑is_R_or_C.re (has_inner.inner x y) + ∥y∥ ^ 2
theorem real_inner_div_norm_mul_norm_eq_one_iff {F : Type u_3} [inner_product_space ℝ F] (x y : F) : has_inner.inner x y / (∥x∥ * ∥y∥) = 1 ↔ x ≠ 0 ∧ ∃ (r : ℝ), 0 < r ∧ y = r • x
theorem bump_covering.exists_is_subordinate_of_prop {ι : Type u} {X : Type v} [topological_space X] {s : set X} [normal_space X] [paracompact_space X] (p : (X → ℝ) → Prop) (h01 : ∀ (s t : set X), is_closed s → is_closed t → disjoint s t → (∃ (f : C(X, ℝ)), p ⇑f ∧ set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1)) (hs : is_closed s) (U : ι → set X) (ho : ∀ (i : ι), is_open (U i)) (hU : s ⊆ ⋃ (i : ι), U i) : ∃ (f : bump_covering ι X s), (∀ (i : ι), p ⇑(⇑f i)) ∧ f.is_subordinate U
theorem pfun.fix_fwd {α : Type u_1} {β : Type u_2} {f : α →. β ⊕ α} (a a' : α) (ha' : sum.inr a' ∈ f a) : f.fix a = f.fix a'
theorem is_closed_fixed_points {α : Type u_1} [topological_space α] [t2_space α] {f : α → α} (hf : continuous f) : is_closed (function.fixed_points f)
theorem is_preconnected.convex {s : set ℝ} : is_preconnected s → convex ℝ s
theorem circle_deg1_lift.units_semiconj_of_translation_number_eq {f₁ f₂ : circle_deg1_liftˣ} (h : ↑f₁.translation_number = ↑f₂.translation_number) : ∃ (F : circle_deg1_lift), function.semiconj ⇑F ⇑f₁ ⇑f₂
theorem add_con.ker_rel {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] (f : M →+ P) {x y : M} : ⇑(add_con.ker f) x y ↔ ⇑f x = ⇑f y
theorem category_theory.eq_to_hom_map {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) {X Y : C} (p : X = Y) : F.map (category_theory.eq_to_hom p) = category_theory.eq_to_hom _
theorem measure_theory.map_with_density_abs_det_fderiv_eq_add_haar {E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {s : set E} {f : E → E} {f' : E → (E →L[ℝ] E)} [measurable_space E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (hs : measurable_set s) (hf' : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) (h'f : measurable f) : measure_theory.measure.map f ((μ.restrict s).with_density (λ (x : E), ennreal.of_real |(f' x).det|)) = μ.restrict (f '' s)
theorem con.Inf_to_setoid {M : Type u_1} [has_mul M] (S : set (con M)) : (has_Inf.Inf S).to_setoid = has_Inf.Inf (con.to_setoid '' S)
theorem filter.at_top_Ioi_eq {α : Type u_3} [semilattice_sup α] (a : α) : filter.at_top = filter.comap coe filter.at_top
theorem tsum_mul_tsum_eq_tsum_sum_range_of_summable_norm {α : Type u_1} [normed_ring α] [complete_space α] {f g : ℕ → α} (hf : summable (λ (x : ℕ), ∥f x∥)) (hg : summable (λ (x : ℕ), ∥g x∥)) : (∑' (n : ℕ), f n) * ∑' (n : ℕ), g n = ∑' (n : ℕ), (finset.range (n + 1)).sum (λ (k : ℕ), f k * g (n - k))
theorem real.tendsto_sum_range_one_div_nat_succ_at_top  : filter.tendsto (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), 1 / (↑i + 1))) filter.at_top filter.at_top
theorem unique_factorization_monoid.factors_eq_normalized_factors {M : Type u_1} [cancel_comm_monoid_with_zero M] [decidable_eq M] [unique_factorization_monoid M] [unique Mˣ] (x : M) : unique_factorization_monoid.factors x = unique_factorization_monoid.normalized_factors x
theorem function.update_comp_eq_of_not_mem_range {α : Sort u_1} {β : Type u_2} {γ : Sort u_3} [decidable_eq β] (g : β → γ) {f : α → β} {i : β} (a : γ) (h : i ∉ set.range f) : function.update g i a ∘ f = g ∘ f
theorem map_exp_of_mem_ball {𝕂 : Type u_1} {𝔸 : Type u_2} {𝔹 : Type u_3} [nondiscrete_normed_field 𝕂] [normed_ring 𝔸] [normed_ring 𝔹] [normed_algebra 𝕂 𝔸] [normed_algebra 𝕂 𝔹] [complete_space 𝔸] {F : Type u_4} [ring_hom_class F 𝔸 𝔹] (f : F) (hf : continuous ⇑f) (x : 𝔸) (hx : x ∈ emetric.ball 0 (exp_series 𝕂 𝔸).radius) : ⇑f (exp 𝕂 x) = exp 𝕂 (⇑f x)
theorem convex.is_preconnected {s : set ℝ} : convex ℝ s → is_preconnected s
theorem filter.tendsto_at_top_at_top {α : Type u_3} {β : Type u_4} [nonempty α] [semilattice_sup α] [preorder β] {f : α → β} : filter.tendsto f filter.at_top filter.at_top ↔ ∀ (b : β), ∃ (i : α), ∀ (a : α), i ≤ a → b ≤ f a
theorem subsemiring.ext {R : Type u} [non_assoc_semiring R] {S T : subsemiring R} (h : ∀ (x : R), x ∈ S ↔ x ∈ T) : S = T
theorem exists_forall_deriv_within_Icc_eq_of_lipschitz_of_continuous {E : Type u_1} [normed_group E] [normed_space ℝ E] [complete_space E] {v : ℝ → E → E} {t_min t₀ t_max : ℝ} (ht₀ : t₀ ∈ set.Icc t_min t_max) (x₀ : E) {C R : ℝ} (hR : 0 ≤ R) {L : nnreal} (Hlip : ∀ (t : ℝ), t ∈ set.Icc t_min t_max → lipschitz_on_with L (v t) (metric.closed_ball x₀ R)) (Hcont : ∀ (x : E), x ∈ metric.closed_ball x₀ R → continuous_on (λ (t : ℝ), v t x) (set.Icc t_min t_max)) (Hnorm : ∀ (t : ℝ), t ∈ set.Icc t_min t_max → ∀ (x : E), x ∈ metric.closed_ball x₀ R → ∥v t x∥ ≤ C) (Hmul_le : C * linear_order.max (t_max - t₀) (t₀ - t_min) ≤ R) : ∃ (f : ℝ → E), f t₀ = x₀ ∧ ∀ (t : ℝ), t ∈ set.Icc t_min t_max → has_deriv_within_at f (v t (f t)) (set.Icc t_min t_max) t
theorem real.diam_eq {s : set ℝ} (h : metric.bounded s) : metric.diam s = has_Sup.Sup s - has_Inf.Inf s
theorem is_primitive_root.card_nth_roots {R : Type u_5} [comm_ring R] [is_domain R] {ζ : R} {n : ℕ} (h : is_primitive_root ζ n) : ⇑multiset.card (polynomial.nth_roots n 1) = n
theorem category_theory.is_filtered.tulip {C : Type u} [category_theory.category C] [category_theory.is_filtered C] {j₁ j₂ j₃ k₁ k₂ l : C} (f₁ : j₁ ⟶ k₁) (f₂ : j₂ ⟶ k₁) (f₃ : j₂ ⟶ k₂) (f₄ : j₃ ⟶ k₂) (g₁ : j₁ ⟶ l) (g₂ : j₃ ⟶ l) : ∃ (s : C) (α : k₁ ⟶ s) (β : l ⟶ s) (γ : k₂ ⟶ s), f₁ ≫ α = g₁ ≫ β ∧ f₂ ≫ α = f₃ ≫ γ ∧ f₄ ≫ γ = g₂ ≫ β
theorem finset.mul_prod_erase {β : Type u} {α : Type v} [comm_monoid β] [decidable_eq α] (s : finset α) (f : α → β) {a : α} (h : a ∈ s) : f a * (s.erase a).prod (λ (x : α), f x) = s.prod (λ (x : α), f x)
theorem topological_fiber_bundle_core.is_topological_fiber_bundle {ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : is_topological_fiber_bundle F Z.proj
theorem has_le.le.dual {α : Type u_1} [has_le α] {a b : α} : b ≤ a → ⇑order_dual.to_dual a ≤ ⇑order_dual.to_dual b
theorem uniform_space.completion.eq_of_dist_eq_zero {α : Type u} [pseudo_metric_space α] (x y : uniform_space.completion α) (h : has_dist.dist x y = 0) : x = y
theorem prod_induced_induced {β : Type v} {δ : Type u_2} [topological_space β] [topological_space δ] {α : Type u_1} {γ : Type u_3} (f : α → β) (g : γ → δ) : prod.topological_space = topological_space.induced (λ (p : α × γ), (f p.fst, g p.snd)) prod.topological_space
theorem pgame.zero_mul_equiv (x : pgame) : (0 * x).equiv 0
theorem euclidean_geometry.dist_eq_abs_sub_dist_iff_angle_eq_zero {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (hp1p2 : p1 ≠ p2) (hp3p2 : p3 ≠ p2) : has_dist.dist p1 p3 = |has_dist.dist p1 p2 - has_dist.dist p3 p2| ↔ euclidean_geometry.angle p1 p2 p3 = 0
theorem W_type.cardinal_mk_le_max_aleph_0_of_fintype {α : Type u} {β : α → Type u} [Π (a : α), fintype (β a)] : cardinal.mk (W_type β) ≤ linear_order.max (cardinal.mk α) cardinal.aleph_0
theorem exists_cont_diff_bump_function_of_mem_nhds {E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {x : E} {s : set E} (hs : s ∈ nhds x) : ∃ (f : E → ℝ), f =ᶠ[nhds x] 1 ∧ (∀ (y : E), f y ∈ set.Icc 0 1) ∧ cont_diff ℝ ⊤ f ∧ has_compact_support f ∧ tsupport f ⊆ s
theorem ray_pos_smul {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {v : M} (h : v ≠ 0) {r : R} (hr : 0 < r) (hrv : r • v ≠ 0) : ray_of_ne_zero R (r • v) hrv = ray_of_ne_zero R v h
theorem category_theory.cover_dense.types.pushforward_family_compatible {C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {G : C ⥤ D} (H : category_theory.cover_dense K G) [category_theory.full G] {ℱ : Dᵒᵖ ⥤ Type v} {ℱ' : category_theory.SheafOfTypes K} (α : G.op ⋙ ℱ ⟶ G.op ⋙ ℱ'.val) {X : D} (x : ℱ.obj (opposite.op X)) : (category_theory.cover_dense.types.pushforward_family H α x).compatible
theorem mem_nhds_within_Ioi_iff_exists_Ioo_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_max_order α] {a : α} {s : set α} : s ∈ nhds_within a (set.Ioi a) ↔ ∃ (u : α) (H : u ∈ set.Ioi a), set.Ioo a u ⊆ s
theorem with_top.prod_lt_top {ι : Type u_1} {R : Type u_8} [canonically_ordered_comm_semiring R] [nontrivial R] [decidable_eq R] {s : finset ι} {f : ι → with_top R} (h : ∀ (i : ι), i ∈ s → f i ≠ ⊤) : s.prod (λ (i : ι), f i) < ⊤
theorem basis.det_units_smul {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {ι : Type u_4} [decidable_eq ι] [fintype ι] (e : basis ι R M) (w : ι → Rˣ) : ⇑(e.det) ⇑(e.units_smul w) = finset.univ.prod (λ (i : ι), ↑(w i))
theorem antivary.sum_smul_le_sum_comp_perm_smul {ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {σ : equiv.perm ι} {f : ι → α} {g : ι → β} [fintype ι] (hfg : antivary f g) : finset.univ.sum (λ (i : ι), f i • g i) ≤ finset.univ.sum (λ (i : ι), f (⇑σ i) • g i)
theorem charted_space.locally_compact (H : Type u) (M : Type u_2) [topological_space H] [topological_space M] [charted_space H M] [locally_compact_space H] : locally_compact_space M
theorem not_or_distrib {a b : Prop} : ¬(a ∨ b) ↔ ¬a ∧ ¬b
theorem modular_group.eq_smul_self_of_mem_fdo_mem_fdo {g : matrix.special_linear_group (fin 2) ℤ} {z : upper_half_plane} (hz : z ∈ modular_group.fdo) (hg : g • z ∈ modular_group.fdo) : z = g • z
theorem finset.prod_ite_eq' {β : Type u} {α : Type v} [comm_monoid β] [decidable_eq α] (s : finset α) (a : α) (b : α → β) : s.prod (λ (x : α), ite (x = a) (b x) 1) = ite (a ∈ s) (b a) 1
theorem no_zero_smul_divisors.of_algebra_map_injective {R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] [no_zero_divisors A] (h : function.injective ⇑(algebra_map R A)) : no_zero_smul_divisors R A
theorem cardinal.lift_sup {ι : Type v} (f : ι → cardinal) : (cardinal.sup f).lift = cardinal.sup (λ (i : ι), (f i).lift)
theorem algebraic_geometry.Scheme.pullback.lift_comp_ι {X Y Z : algebraic_geometry.Scheme} (𝒰 : X.open_cover) (f : X ⟶ Z) (g : Y ⟶ Z) [∀ (i : 𝒰.J), category_theory.limits.has_pullback (𝒰.map i ≫ f) g] (i : 𝒰.J) : category_theory.limits.pullback.lift category_theory.limits.pullback.snd (category_theory.limits.pullback.fst ≫ algebraic_geometry.Scheme.pullback.p2 𝒰 f g) _ ≫ (algebraic_geometry.Scheme.pullback.gluing 𝒰 f g).ι i = category_theory.limits.pullback.fst
theorem list.nth_le_join {α : Type u_1} (L : list (list α)) {i j : ℕ} (hi : i < L.length) (hj : j < (L.nth_le i hi).length) : L.join.nth_le ((list.take i (list.map list.length L)).sum + j) _ = (L.nth_le i hi).nth_le j hj
theorem asymptotics.is_O.of_neg_left {α : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : α → F} {f' : α → E'} {l : filter α} : (λ (x : α), -f' x) =O[l] g → f' =O[l] g
theorem category_theory.transfer_nat_trans_self_symm_of_iso {C : Type u₁} {D : Type u₂} [category_theory.category C] [category_theory.category D] {L₁ L₂ : C ⥤ D} {R₁ R₂ : D ⥤ C} (adj₁ : L₁ ⊣ R₁) (adj₂ : L₂ ⊣ R₂) (f : R₁ ⟶ R₂) [category_theory.is_iso (⇑((category_theory.transfer_nat_trans_self adj₁ adj₂).symm) f)] : category_theory.is_iso f
theorem game.not_lf {x y : game} : ¬x.lf y ↔ y ≤ x
theorem set.sized.shadow {α : Type u_1} [decidable_eq α] {𝒜 : finset (finset α)} {r : ℕ} (h𝒜 : set.sized r ↑𝒜) : set.sized (r - 1) ↑(𝒜.shadow)
theorem eq_orthogonal_projection_of_eq_submodule {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K : submodule 𝕜 E} [complete_space ↥K] {K' : submodule 𝕜 E} [complete_space ↥K'] (h : K = K') (u : E) : ↑(⇑(orthogonal_projection K) u) = ↑(⇑(orthogonal_projection K') u)
theorem is_add_submonoid.list_sum_mem {M : Type u_1} [add_monoid M] {s : set M} (hs : is_add_submonoid s) {l : list M} : (∀ (x : M), x ∈ l → x ∈ s) → l.sum ∈ s
theorem affine_span_insert_affine_span (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) (ps : set P) : affine_span k (has_insert.insert p ↑(affine_span k ps)) = affine_span k (has_insert.insert p ps)
theorem representation.char_conj {k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_ring k] [group G] [add_comm_group V] [module k V] (ρ : representation k G V) (g h : G) : ρ.character (h * g * h⁻¹) = ρ.character g
theorem finite_dimensional_vector_span_of_finite (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} (h : s.finite) : finite_dimensional k ↥(vector_span k s)
theorem add_monoid.image_closure {M : Type u_1} [add_monoid M] {A : Type u_2} [add_monoid A] {f : M → A} (hf : is_add_monoid_hom f) (s : set M) : f '' add_monoid.closure s = add_monoid.closure (f '' s)
theorem measure_theory.outer_measure.trim_add {α : Type u_1} [measurable_space α] (m₁ m₂ : measure_theory.outer_measure α) : (m₁ + m₂).trim = m₁.trim + m₂.trim
theorem mul_action.card_eq_sum_card_group_div_card_stabilizer (α : Type u) (β : Type v) [group α] [mul_action α β] [fintype α] [fintype β] [fintype (quotient (mul_action.orbit_rel α β))] [Π (b : β), fintype ↥(mul_action.stabilizer α b)] : fintype.card β = finset.univ.sum (λ (ω : quotient (mul_action.orbit_rel α β)), fintype.card α / fintype.card ↥(mul_action.stabilizer α ω.out'))
theorem finset.exists_ne_map_eq_of_card_lt_of_maps_to {α : Type u_1} {β : Type u_2} {s : finset α} {t : finset β} (hc : t.card < s.card) {f : α → β} (hf : ∀ (a : α), a ∈ s → f a ∈ t) : ∃ (x : α) (H : x ∈ s) (y : α) (H : y ∈ s), x ≠ y ∧ f x = f y
theorem is_artinian.surjective_of_injective_endomorphism {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [is_artinian R M] (f : M →ₗ[R] M) (s : function.injective ⇑f) : function.surjective ⇑f
theorem algebraic_topology.dold_kan.Hσ_eq_zero {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] {X : category_theory.simplicial_object C} (q : ℕ) : (algebraic_topology.dold_kan.Hσ q).f 0 = 0
theorem box_integral.has_integral_of_le_Henstock_of_forall_is_o {ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} (hl : l ≤ box_integral.integration_params.Henstock) (B : box_integral.box_additive_map ι ℝ ↑I) (hB0 : ∀ (J : box_integral.box ι), 0 ≤ ⇑B J) (g : box_integral.box_additive_map ι F ↑I) (s : set (ι → ℝ)) (hs : s.countable) (H₁ : ∀ (c : nnreal) (x : ι → ℝ), x ∈ ⇑box_integral.box.Icc I ∩ s → ∀ (ε : ℝ), ε > 0 → (∃ (δ : ℝ) (H : δ > 0), ∀ (J : box_integral.box ι), J ≤ I → ⇑box_integral.box.Icc J ⊆ metric.closed_ball x δ → x ∈ ⇑box_integral.box.Icc J → (↥(l.bDistortion) → J.distortion ≤ c) → has_dist.dist (⇑(⇑vol J) (f x)) (⇑g J) ≤ ε)) (H₂ : ∀ (c : nnreal) (x : ι → ℝ), x ∈ ⇑box_integral.box.Icc I  s → ∀ (ε : ℝ), ε > 0 → (∃ (δ : ℝ) (H : δ > 0), ∀ (J : box_integral.box ι), J ≤ I → ⇑box_integral.box.Icc J ⊆ metric.closed_ball x δ → x ∈ ⇑box_integral.box.Icc J → (↥(l.bDistortion) → J.distortion ≤ c) → has_dist.dist (⇑(⇑vol J) (f x)) (⇑g J) ≤ ε * ⇑B J)) : box_integral.has_integral I l f vol (⇑g I)
theorem set.prod_subset_prod_iff {α : Type u_1} {β : Type u_2} {s s₁ : set α} {t t₁ : set β} : s ×ˢ t ⊆ s₁ ×ˢ t₁ ↔ s ⊆ s₁ ∧ t ⊆ t₁ ∨ s = ∅ ∨ t = ∅
theorem ring_hom.domain_local_ring {R : Type u_1} {S : Type u_2} [comm_semiring R] [comm_semiring S] [H : local_ring S] (f : R →+* S) [is_local_ring_hom f] : local_ring R
theorem nat.prod_pow_pos_of_zero_not_mem_support {f : ℕ →₀ ℕ} (hf : 0 ∉ f.support) : 0 < f.prod has_pow.pow
theorem dGamma_integral_abs_convergent (s : ℝ) (hs : 1 < s) : measure_theory.integrable_on (λ (x : ℝ), ∥real.exp (-x) * real.log x * x ^ (s - 1)∥) (set.Ioi 0) measure_theory.measure_space.volume
theorem finset.sum_product_right' {β : Type u} {α : Type v} {γ : Type w} [add_comm_monoid β] {s : finset γ} {t : finset α} {f : γ → α → β} : (s.product t).sum (λ (x : γ × α), f x.fst x.snd) = t.sum (λ (y : α), s.sum (λ (x : γ), f x y))
theorem modular_group.norm_sq_S_smul_lt_one {z : upper_half_plane} (h : 1 < ⇑complex.norm_sq ↑z) : ⇑complex.norm_sq ↑(modular_group.S • z) < 1
theorem self_adjoint.mem_spectrum_eq_re {A : Type u_1} [normed_ring A] [normed_algebra ℂ A] [complete_space A] [star_ring A] [cstar_ring A] [star_module ℂ A] [nontrivial A] {a : A} (ha : a ∈ self_adjoint A) {z : ℂ} (hz : z ∈ spectrum ℂ a) : z = ↑(z.re)
theorem linear_map.pi_apply_eq_sum_univ {R : Type u_1} {M : Type u_9} {ι : Type u_17} [semiring R] [add_comm_monoid M] [module R M] [fintype ι] [decidable_eq ι] (f : (ι → R) →ₗ[R] M) (x : ι → R) : ⇑f x = finset.univ.sum (λ (i : ι), x i • ⇑f (λ (j : ι), ite (i = j) 1 0))
theorem continuous_on_of_locally_uniform_approx_of_continuous_within_at {α : Type u_1} {β : Type u_2} [uniform_space β] {f : α → β} {s : set α} [topological_space α] (L : ∀ (x : α), x ∈ s → ∀ (u : set (β × β)), u ∈ uniformity β → (∃ (t : set α) (H : t ∈ nhds_within x s) (F : α → β), continuous_within_at F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u)) : continuous_on f s
theorem dense_sInter_of_Gδ {α : Type u_1} [topological_space α] [baire_space α] {S : set (set α)} (ho : ∀ (s : set α), s ∈ S → is_Gδ s) (hS : S.countable) (hd : ∀ (s : set α), s ∈ S → dense s) : dense (⋂₀ S)
theorem category_theory.glue_data.ι_jointly_surjective {C : Type u₁} [category_theory.category C] (D : category_theory.glue_data C) [category_theory.limits.has_multicoequalizer D.diagram] (F : C ⥤ Type v) [category_theory.limits.preserves_colimit D.diagram.multispan F] [Π (i j k : D.J), category_theory.limits.preserves_limit (category_theory.limits.cospan (D.f i j) (D.f i k)) F] (x : F.obj D.glued) : ∃ (i : D.J) (y : F.obj (D.U i)), F.map (D.ι i) y = x
theorem interval_integral.measure_integral_sub_linear_is_o_of_tendsto_ae' {ι : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {c : E} {l l' : filter ℝ} {lt : filter ι} {μ : measure_theory.measure ℝ} {u v : ι → ℝ} [l'.is_measurably_generated] [filter.tendsto_Ixx_class set.Ioc l l'] (hfm : strongly_measurable_at_filter f l' μ) (hf : filter.tendsto f (l' ⊓ μ.ae) (nhds c)) (hl : μ.finite_at_filter l') (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) : (λ (t : ι), ∫ (x : ℝ) in u t..v t, f x ∂μ - ∫ (x : ℝ) in u t..v t, c ∂μ) =o[lt] λ (t : ι), ∫ (x : ℝ) in u t..v t, 1 ∂μ
theorem unique_factorization_monoid.count_normalized_factors_eq {R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] [nontrivial R] [normalization_monoid R] [decidable_eq R] {p x : R} (hp : irreducible p) (hnorm : ⇑normalize p = p) {n : ℕ} (hle : p ^ n ∣ x) (hlt : ¬p ^ (n + 1) ∣ x) : multiset.count p (unique_factorization_monoid.normalized_factors x) = n
theorem closure_operator.closure_mem_mk₃ {α : Type u_1} [partial_order α] {f : α → α} {p : α → Prop} {hf : ∀ (x : α), x ≤ f x} {hfp : ∀ (x : α), p (f x)} {hmin : ∀ ⦃x y : α⦄, x ≤ y → p y → f x ≤ y} (x : α) : p (⇑(closure_operator.mk₃ f p hf hfp hmin) x)
theorem matrix.det_minor_equiv_self {m : Type u_1} {n : Type u_2} [decidable_eq n] [fintype n] [decidable_eq m] [fintype m] {R : Type v} [comm_ring R] (e : n ≃ m) (A : matrix m m R) : (A.minor ⇑e ⇑e).det = A.det
theorem measure_theory.measure.mk_metric_le_liminf_sum {X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] {β : Type u_1} {ι : β → Type u_3} [hι : Π (n : β), fintype (ι n)] (s : set X) {l : filter β} (r : β → ennreal) (hr : filter.tendsto r l (nhds 0)) (t : Π (n : β), ι n → set X) (ht : ∀ᶠ (n : β) in l, ∀ (i : ι n), emetric.diam (t n i) ≤ r n) (hst : ∀ᶠ (n : β) in l, s ⊆ ⋃ (i : ι n), t n i) (m : ennreal → ennreal) : ⇑(measure_theory.measure.mk_metric m) s ≤ l.liminf (λ (n : β), finset.univ.sum (λ (i : ι n), m (emetric.diam (t n i))))
theorem tsum_coe_mul_geometric_of_norm_lt_1 {𝕜 : Type u_1} [normed_field 𝕜] [complete_space 𝕜] {r : 𝕜} (hr : ∥r∥ < 1) : ∑' (n : ℕ), ↑n * r ^ n = r / (1 - r) ^ 2
theorem category_theory.simplicial_object.δ_comp_σ_of_gt {C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) {n : ℕ} {i : fin (n + 2)} {j : fin (n + 1)} (H : ⇑fin.cast_succ j < i) : X.σ (⇑fin.cast_succ j) ≫ X.δ i.succ = X.δ i ≫ X.σ j
theorem add_monoid_algebra.ring_hom_ext' {k : Type u₁} {G : Type u₂} {R : Type u_1} [semiring k] [add_monoid G] [semiring R] {f g : add_monoid_algebra k G →+* R} (h₁ : f.comp add_monoid_algebra.single_zero_ring_hom = g.comp add_monoid_algebra.single_zero_ring_hom) (h_of : ↑f.comp (add_monoid_algebra.of k G) = ↑g.comp (add_monoid_algebra.of k G)) : f = g
theorem is_left_regular.ne_zero {R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_left_regular a) : a ≠ 0
theorem cInf_union {α : Type u_1} [conditionally_complete_lattice α] {s t : set α} (hs : bdd_below s) (sne : s.nonempty) (ht : bdd_below t) (tne : t.nonempty) : has_Inf.Inf (s ∪ t) = has_Inf.Inf s ⊓ has_Inf.Inf t
theorem asymptotics.is_O_with.norm_left {α : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {c : ℝ} {g : α → F} {f' : α → E'} {l : filter α} : asymptotics.is_O_with c l f' g → asymptotics.is_O_with c l (λ (x : α), ∥f' x∥) g
theorem span_gram_schmidt (𝕜 : Type u_1) {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_3} [linear_order ι] [order_bot ι] [locally_finite_order ι] [is_well_order ι has_lt.lt] [succ_order ι] [is_succ_archimedean ι] (f : ι → E) (c : ι) : submodule.span 𝕜 (gram_schmidt 𝕜 f '' set.Iio c) = submodule.span 𝕜 (f '' set.Iio c)
theorem submodule.bsupr_eq_range_dfinsupp_lsum {ι : Type u_1} {R : Type u_2} {N : Type u_5} [dec_ι : decidable_eq ι] [semiring R] [add_comm_monoid N] [module R N] (p : ι → Prop) [decidable_pred p] (S : ι → submodule R N) : (⨆ (i : ι) (h : p i), S i) = ((⇑(dfinsupp.lsum ℕ) (λ (i : ι), (S i).subtype)).comp (dfinsupp.filter_linear_map R (λ (i : ι), ↥(S i)) p)).range
theorem path.homotopic.proj_left_prod {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {a₁ a₂ : α} {b₁ b₂ : β} (q₁ : path.homotopic.quotient a₁ a₂) (q₂ : path.homotopic.quotient b₁ b₂) : path.homotopic.proj_left (path.homotopic.prod q₁ q₂) = q₁
theorem complete_lattice.independent_iff_dfinsupp_sum_add_hom_injective {ι : Type u_1} {N : Type u_5} [dec_ι : decidable_eq ι] [add_comm_group N] (p : ι → add_subgroup N) : complete_lattice.independent p ↔ function.injective ⇑(dfinsupp.sum_add_hom (λ (i : ι), (p i).subtype))
theorem list.prod_inv {G : Type u_7} [comm_group G] (L : list G) : (L.prod)⁻¹ = (list.map (λ (x : G), x⁻¹) L).prod
theorem subsingleton_or_nontrivial (α : Type u_1) : subsingleton α ∨ nontrivial α
theorem affine_subspace.direction_sup {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s1 s2 : affine_subspace k P} {p1 p2 : P} (hp1 : p1 ∈ s1) (hp2 : p2 ∈ s2) : (s1 ⊔ s2).direction = s1.direction ⊔ s2.direction ⊔ submodule.span k {p2 -ᵥ p1}
theorem category_theory.limits.is_limit.of_nat_iso.cone_fac {J : Type u₁} [category_theory.category J] {C : Type u₃} [category_theory.category C] {F : J ⥤ C} {X : C} (h : category_theory.yoneda.obj X ⋙ category_theory.ulift_functor ≅ F.cones) (s : category_theory.limits.cone F) : (category_theory.limits.is_limit.of_nat_iso.limit_cone h).extend (category_theory.limits.is_limit.of_nat_iso.hom_of_cone h s) = s
theorem polynomial.exists_approx_polynomial_aux {Fq : Type u_1} [fintype Fq] [ring Fq] {d m : ℕ} (hm : fintype.card Fq ^ d ≤ m) (b : polynomial Fq) (A : fin m.succ → polynomial Fq) (hA : ∀ (i : fin m.succ), (A i).degree < b.degree) : ∃ (i₀ i₁ : fin m.succ), i₀ ≠ i₁ ∧ (A i₁ - A i₀).degree < ↑(b.nat_degree - d)
theorem iterated_fderiv_within_inter {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s u : set E} {f : E → F} {x : E} {n : ℕ} (hu : u ∈ nhds x) (hs : unique_diff_on 𝕜 s) (xs : x ∈ s) : iterated_fderiv_within 𝕜 n f (s ∩ u) x = iterated_fderiv_within 𝕜 n f s x
theorem cont_mdiff_exp_map_circle  : cont_mdiff (model_with_corners_self ℝ ℝ) (model_with_corners_self ℝ (euclidean_space ℝ (fin 1))) ⊤ ⇑exp_map_circle
theorem submodule.mapq_comp {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (p : submodule R M) {R₂ : Type u_3} {M₂ : Type u_4} [ring R₂] [add_comm_group M₂] [module R₂ M₂] {τ₁₂ : R →+* R₂} {R₃ : Type u_5} {M₃ : Type u_6} [ring R₃] [add_comm_group M₃] [module R₃ M₃] (p₂ : submodule R₂ M₂) (p₃ : submodule R₃ M₃) {τ₂₃ : R₂ →+* R₃} {τ₁₃ : R →+* R₃} [ring_hom_comp_triple τ₁₂ τ₂₃ τ₁₃] (f : M →ₛₗ[τ₁₂] M₂) (g : M₂ →ₛₗ[τ₂₃] M₃) (hf : p ≤ submodule.comap f p₂) (hg : p₂ ≤ submodule.comap g p₃) (h : p ≤ submodule.comap f (submodule.comap g p₃) := _) : p.mapq p₃ (g.comp f) h = (p₂.mapq p₃ g hg).comp (p.mapq p₂ f hf)
theorem char.quadratic_char_eq_pow_of_char_ne_two {F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F ≠ 2) {a : F} (ha : a ≠ 0) : char.quadratic_char F a = ite (a ^ (fintype.card F / 2) = 1) 1 (-1)
theorem measure_theory.ae_restrict_congr_set {α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {s t : α → Prop} (hst : s =ᵐ[μ] t) {p : α → Prop} : (∀ᵐ (x : α) ∂μ.restrict s, p x) ↔ ∀ᵐ (x : α) ∂μ.restrict t, p x
theorem cont_diff_at.smul {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {x : E} {n : with_top ℕ} {f : E → 𝕜} {g : E → F} (hf : cont_diff_at 𝕜 n f x) (hg : cont_diff_at 𝕜 n g x) : cont_diff_at 𝕜 n (λ (x : E), f x • g x) x
theorem ring_hom.srange_top_of_surjective {R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] (f : R →+* S) (hf : function.surjective ⇑f) : f.srange = ⊤
theorem exp_series_eq_exp_series (𝕂 : Type u_1) (𝕂' : Type u_2) (𝔸 : Type u_3) [field 𝕂] [field 𝕂'] [ring 𝔸] [algebra 𝕂 𝔸] [algebra 𝕂' 𝔸] [topological_space 𝔸] [topological_ring 𝔸] (n : ℕ) (x : 𝔸) : ⇑(exp_series 𝕂 𝔸 n) (λ (_x : fin n), x) = ⇑(exp_series 𝕂' 𝔸 n) (λ (_x : fin n), x)
theorem is_conformal_map_iff {E : Type u_1} {F : Type u_2} [inner_product_space ℝ E] [inner_product_space ℝ F] (f : E →L[ℝ] F) : is_conformal_map f ↔ ∃ (c : ℝ), 0 < c ∧ ∀ (u v : E), has_inner.inner (⇑f u) (⇑f v) = c * has_inner.inner u v
theorem filter.map_map₂_antidistrib_right {α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {m : α → β → γ} {f : filter α} {g : filter β} {n : γ → δ} {m' : β → α' → δ} {n' : α → α'} (h_antidistrib : ∀ (a : α) (b : β), n (m a b) = m' b (n' a)) : filter.map n (filter.map₂ m f g) = filter.map₂ m' g (filter.map n' f)
theorem nat.factorization_central_binom_of_two_mul_self_lt_three_mul {p n : ℕ} (n_big : 2 < n) (p_le_n : p ≤ n) (big : 2 * n < 3 * p) : ⇑(n.central_binom.factorization) p = 0
theorem set.Icc_diff_pi_univ_Ioc_subset {ι : Type u_1} {α : ι → Type u_2} [decidable_eq ι] [Π (i : ι), linear_order (α i)] (x y z : Π (i : ι), α i) : set.Icc x z  set.univ.pi (λ (i : ι), set.Ioc (y i) (z i)) ⊆ ⋃ (i : ι), set.Icc x (function.update z i (y i))
theorem inner_product_geometry.norm_sub_eq_add_norm_of_angle_eq_pi {V : Type u_1} [inner_product_space ℝ V] {x y : V} (h : inner_product_geometry.angle x y = real.pi) : ∥x - y∥ = ∥x∥ + ∥y∥
theorem monotone.dual_right {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} : monotone f → antitone (⇑order_dual.to_dual ∘ f)
theorem units_inv_smul {R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (u : Rˣ) (v : module.ray R M) : u⁻¹ • v = u • v
theorem is_compact.exists_forall_ge {α : Type u_1} {β : Type u_2} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [topological_space β] {s : set β} : is_compact s → s.nonempty → ∀ {f : β → α}, continuous_on f s → (∃ (x : β) (H : x ∈ s), ∀ (y : β), y ∈ s → f y ≤ f x)
theorem is_open.polish_space {α : Type u_1} [topological_space α] [polish_space α] {s : set α} (hs : is_open s) : polish_space ↥s
theorem category_theory.limits.zero_of_from_zero {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] {X : C} (f : 0 ⟶ X) : f = 0
theorem clifford_algebra_quaternion.to_quaternion_involute_reverse {R : Type u_1} [comm_ring R] {c₁ c₂ : R} (c : clifford_algebra (clifford_algebra_quaternion.Q c₁ c₂)) : ⇑clifford_algebra_quaternion.to_quaternion (⇑clifford_algebra.involute (⇑clifford_algebra.reverse c)) = ⇑quaternion_algebra.conj (⇑clifford_algebra_quaternion.to_quaternion c)
theorem lucas_primality (p : ℕ) (a : zmod p) (ha : a ^ (p - 1) = 1) (hd : ∀ (q : ℕ), nat.prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) : nat.prime p
theorem Profinite.is_closed_map {X Y : Profinite} (f : X ⟶ Y) : is_closed_map ⇑f
theorem normed_group_hom.lipschitz {V₁ : Type u_2} {V₂ : Type u_3} [semi_normed_group V₁] [semi_normed_group V₂] (f : normed_group_hom V₁ V₂) : lipschitz_with ⟨∥f∥, _⟩ ⇑f
theorem set.abs_sub_right_of_mem_interval {α : Type u} [linear_ordered_add_comm_group α] {a b x : α} (h : x ∈ set.interval a b) : |b - x| ≤ |b - a|
theorem metric.diam_eq_zero_of_unbounded {α : Type u} [pseudo_metric_space α] {s : set α} (h : ¬metric.bounded s) : metric.diam s = 0
theorem is_integral_closure.exists_smul_eq_mul {R : Type u_1} {S : Type u_2} [comm_ring R] [is_domain R] [comm_ring S] {L : Type u_3} [field L] [algebra R S] [algebra S L] [algebra R L] [is_scalar_tower R S L] [is_integral_closure S R L] (h : algebra.is_algebraic R L) (inj : function.injective ⇑(algebra_map R L)) (a : S) {b : S} (hb : b ≠ 0) : ∃ (c : S) (d : R) (H : d ≠ 0), d • a = b * c
theorem antivary_on.sum_smul_eq_sum_comp_perm_smul_iff {ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {s : finset ι} {σ : equiv.perm ι} {f : ι → α} {g : ι → β} (hfg : antivary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f (⇑σ i) • g i) = s.sum (λ (i : ι), f i • g i) ↔ antivary_on (f ∘ ⇑σ) g ↑s
theorem bornology.is_bounded.compl {α : Type u_2} [bornology α] {s : set α} : bornology.is_bounded s → bornology.is_cobounded sᶜ
theorem closure_Ioi' {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a : α} (h : (set.Ioi a).nonempty) : closure (set.Ioi a) = set.Ici a
theorem semidirect_product.hom_ext {N : Type u_1} {G : Type u_2} {H : Type u_3} [group N] [group G] [group H] {φ : G →* mul_aut N} {f g : N ⋊[φ] G →* H} (hl : f.comp semidirect_product.inl = g.comp semidirect_product.inl) (hr : f.comp semidirect_product.inr = g.comp semidirect_product.inr) : f = g
theorem strict_convex_on.lt_on_open_segment' {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [linear_ordered_add_comm_monoid β] [has_scalar 𝕜 E] [module 𝕜 β] [ordered_smul 𝕜 β] {s : set E} {f : E → β} (hf : strict_convex_on 𝕜 s f) {x y : E} (hx : x ∈ s) (hy : y ∈ s) (hxy : x ≠ y) {a b : 𝕜} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) : f (a • x + b • y) < linear_order.max (f x) (f y)
theorem finset.prod_induction {α : Type v} {s : finset α} {M : Type u_1} [comm_monoid M] (f : α → M) (p : M → Prop) (p_mul : ∀ (a b : M), p a → p b → p (a * b)) (p_one : p 1) (p_s : ∀ (x : α), x ∈ s → p (f x)) : p (s.prod (λ (x : α), f x))
theorem concave_on.le_map_center_mass {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} {ι : Type u_5} [linear_ordered_field 𝕜] [add_comm_group E] [ordered_add_comm_group β] [module 𝕜 E] [module 𝕜 β] [ordered_smul 𝕜 β] {s : set E} {f : E → β} {t : finset ι} {w : ι → 𝕜} {p : ι → E} (hf : concave_on 𝕜 s f) (h₀ : ∀ (i : ι), i ∈ t → 0 ≤ w i) (h₁ : 0 < t.sum (λ (i : ι), w i)) (hmem : ∀ (i : ι), i ∈ t → p i ∈ s) : t.center_mass w (f ∘ p) ≤ f (t.center_mass w p)
theorem strict_anti.dual_right {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} : strict_anti f → strict_mono (⇑order_dual.to_dual ∘ f)
theorem add_group.fg_iff_add_monoid.fg {G : Type u_3} [add_group G] : add_group.fg G ↔ add_monoid.fg G
theorem category_theory.limits.limit.pre_eq {J : Type u₁} [category_theory.category J] {K : Type u₂} [category_theory.category K] {C : Type u} [category_theory.category C] {F : J ⥤ C} [category_theory.limits.has_limit F] {E : K ⥤ J} [category_theory.limits.has_limit (E ⋙ F)] (s : category_theory.limits.limit_cone (E ⋙ F)) (t : category_theory.limits.limit_cone F) : category_theory.limits.limit.pre F E = (category_theory.limits.limit.iso_limit_cone t).hom ≫ s.is_limit.lift (category_theory.limits.cone.whisker E t.cone) ≫ (category_theory.limits.limit.iso_limit_cone s).inv
theorem continuous_of_continuous_at_one {G : Type w} [topological_space G] [group G] [topological_group G] {M : Type u_1} {hom : Type u_2} [mul_one_class M] [topological_space M] [has_continuous_mul M] [monoid_hom_class hom G M] (f : hom) (hf : continuous_at ⇑f 1) : continuous ⇑f
theorem add_subgroup.normed_mk.apply {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) : ⇑(S.normed_mk) m = ⇑(quotient_add_group.mk' S) m
theorem matrix.is_diag.kronecker {α : Type u_1} {n : Type u_4} {m : Type u_5} [mul_zero_class α] {A : matrix m m α} {B : matrix n n α} (hA : A.is_diag) (hB : B.is_diag) : (matrix.kronecker_map has_mul.mul A B).is_diag
theorem has_deriv_at_exp_zero_of_radius_pos {𝕂 : Type u_1} [nondiscrete_normed_field 𝕂] [complete_space 𝕂] (h : 0 < (exp_series 𝕂 𝕂).radius) : has_deriv_at (exp 𝕂) 1 0
theorem set.Union_Inter_of_antitone {ι : Type u_1} {ι' : Type u_2} {α : Type u_3} [fintype ι] [preorder ι'] [is_directed ι' (function.swap has_le.le)] [nonempty ι'] {s : ι → ι' → set α} (hs : ∀ (i : ι), antitone (s i)) : (⋃ (j : ι'), ⋂ (i : ι), s i j) = ⋂ (i : ι), ⋃ (j : ι'), s i j
theorem add_subgroup.supr_induction' {G : Type u_1} [add_group G] {ι : Sort u_2} (S : ι → add_subgroup G) {C : Π (x : G), (x ∈ ⨆ (i : ι), S i) → Prop} (hp : ∀ (i : ι) (x : G) (H : x ∈ S i), C x _) (h1 : C 0 _) (hmul : ∀ (x y : G) (hx : x ∈ ⨆ (i : ι), S i) (hy : y ∈ ⨆ (i : ι), S i), C x hx → C y hy → C (x + y) _) {x : G} (hx : x ∈ ⨆ (i : ι), S i) : C x hx
theorem function.injective.cod_restrict {α : Type u} {β : Type v} {t : set β} {f : α → β} (h : ∀ (x : α), f x ∈ t) : function.injective f → function.injective (set.cod_restrict f t h)
theorem simple_graph.walk.take_spec {V : Type u} {G : simple_graph V} [decidable_eq V] {u v w : V} (p : G.walk v w) (h : u ∈ p.support) : (p.take_until u h).append (p.drop_until u h) = p
theorem measure_theory.simple_func.lintegral_mono {α : Type u_1} {m : measurable_space α} {μ ν : measure_theory.measure α} {f g : measure_theory.simple_func α ennreal} (hfg : f ≤ g) (hμν : μ ≤ ν) : f.lintegral μ ≤ g.lintegral ν
theorem subgroup.eq_one_of_noncomm_prod_eq_one_of_independent {G : Type u_1} [group G] {ι : Type u_2} (s : finset ι) (f : ι → G) (comm : ∀ (x : ι), x ∈ s → ∀ (y : ι), y ∈ s → commute (f x) (f y)) (K : ι → subgroup G) (hind : complete_lattice.independent K) (hmem : ∀ (x : ι), x ∈ s → f x ∈ K x) (heq1 : s.noncomm_prod f comm = 1) (i : ι) (H : i ∈ s) : f i = 1
theorem pi.sum_norm_apply_le_norm {ι : Type u_2} {π : ι → Type u_1} [fintype ι] [Π (i : ι), semi_normed_group (π i)] (x : Π (i : ι), π i) : finset.univ.sum (λ (i : ι), ∥x i∥) ≤ fintype.card ι • ∥x∥
theorem pnat.xgcd_type.rq_eq (u : pnat.xgcd_type) : u.r + (u.bp + 1) * u.q = u.ap + 1
theorem ordinal.infinite_pigeonhole {β α : Type u} (f : β → α) (h₁ : cardinal.aleph_0 ≤ cardinal.mk β) (h₂ : cardinal.mk α < (cardinal.mk β).ord.cof) : ∃ (a : α), cardinal.mk ↥(f ⁻¹' {a}) = cardinal.mk β
theorem measure_theory.ae_cover.integral_eq_of_tendsto {α : Type u_1} {ι : Type u_2} {E : Type u_3} [measurable_space α] {μ : measure_theory.measure α} {l : filter ι} [normed_group E] [normed_space ℝ E] [complete_space E] [l.ne_bot] [l.is_countably_generated] {φ : ι → set α} (hφ : measure_theory.ae_cover μ l φ) {f : α → E} (I : E) (hfi : measure_theory.integrable f μ) (h : filter.tendsto (λ (n : ι), ∫ (x : α) in φ n, f x ∂μ) l (nhds I)) : ∫ (x : α), f x ∂μ = I
theorem finset.le_prod_nonempty_of_submultiplicative_on_pred {ι : Type u_1} {M : Type u_4} {N : Type u_5} [comm_monoid M] [ordered_comm_monoid N] (f : M → N) (p : M → Prop) (h_mul : ∀ (x y : M), p x → p y → f (x * y) ≤ f x * f y) (hp_mul : ∀ (x y : M), p x → p y → p (x * y)) (g : ι → M) (s : finset ι) (hs_nonempty : s.nonempty) (hs : ∀ (i : ι), i ∈ s → p (g i)) : f (s.prod (λ (i : ι), g i)) ≤ s.prod (λ (i : ι), f (g i))
theorem set.finite.bounded {α : Type u} [pseudo_metric_space α] {s : set α} (h : s.finite) : metric.bounded s
theorem is_compact_univ_pi {ι : Type u_1} {π : ι → Type u_2} [Π (i : ι), topological_space (π i)] {s : Π (i : ι), set (π i)} (h : ∀ (i : ι), is_compact (s i)) : is_compact (set.univ.pi s)
theorem polynomial.degree_list_prod {R : Type u} [semiring R] [no_zero_divisors R] [nontrivial R] (l : list (polynomial R)) : l.prod.degree = (list.map polynomial.degree l).sum
theorem equiv_functor.map_equiv_trans (f : Type u₀ → Type u₁) [equiv_functor f] {α β γ : Type u₀} (ab : α ≃ β) (bc : β ≃ γ) : (equiv_functor.map_equiv f ab).trans (equiv_functor.map_equiv f bc) = equiv_functor.map_equiv f (ab.trans bc)
theorem is_smul_regular.one {R : Type u_1} (M : Type u_3) [monoid R] [mul_action R M] : is_smul_regular M 1
theorem category_theory.grothendieck_topology.is_glb_Inf {C : Type u} [category_theory.category C] (s : set (category_theory.grothendieck_topology C)) : is_glb s (has_Inf.Inf s)
theorem cont_diff.cont_diff_fderiv_apply {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {m n : with_top ℕ} {f : E → F} (hf : cont_diff 𝕜 n f) (hmn : m + 1 ≤ n) : cont_diff 𝕜 m (λ (p : E × E), ⇑(fderiv 𝕜 f p.fst) p.snd)
theorem monoid_hom.map_finsupp_prod {α : Type u_1} {M : Type u_5} {N : Type u_7} {P : Type u_8} [has_zero M] [comm_monoid N] [comm_monoid P] (h : N →* P) (f : α →₀ M) (g : α → M → N) : ⇑h (f.prod g) = f.prod (λ (a : α) (b : M), ⇑h (g a b))
theorem real.is_O_one_exp_comp {α : Type u_1} {l : filter α} {f : α → ℝ} : ((λ (x : α), 1) =O[l] λ (x : α), real.exp (f x)) ↔ filter.is_bounded_under ge l f
theorem first_order.language.Theory.exists_large_model_of_infinite_model {L : first_order.language} (T : L.Theory) (κ : cardinal) (M : Type w') [L.Structure M] [M ⊨ T] [infinite M] : ∃ (N : T.Model), κ.lift ≤ cardinal.mk ↥N
theorem add_subgroup.coe_norm {E : Type u_1} [semi_normed_group E] {s : add_subgroup E} (x : ↥s) : ∥x∥ = ∥↑x∥
theorem real.exists_extension_norm_eq {E : Type u_1} [semi_normed_group E] [normed_space ℝ E] (p : subspace ℝ E) (f : ↥p →L[ℝ] ℝ) : ∃ (g : E →L[ℝ] ℝ), (∀ (x : ↥p), ⇑g ↑x = ⇑f x) ∧ ∥g∥ = ∥f∥
theorem setoid.ker_eq_lift_of_injective {α : Type u_1} {β : Type u_2} {r : setoid α} (f : α → β) (H : ∀ (x y : α), r.rel x y → f x = f y) (h : function.injective (quotient.lift f H)) : setoid.ker f = r
theorem emetric.Hausdorff_edist_zero_iff_eq_of_closed {α : Type u} [pseudo_emetric_space α] {s t : set α} (hs : is_closed s) (ht : is_closed t) : emetric.Hausdorff_edist s t = 0 ↔ s = t
theorem reflexive_ne_imp_iff {α : Type u_1} {r : α → α → Prop} [is_refl α r] {x y : α} : x ≠ y → r x y ↔ r x y
theorem linear_ordered_comm_group_with_zero.pure_le_nhds_fun (Γ₀ : Type u_1) [linear_ordered_comm_group_with_zero Γ₀] : has_pure.pure ≤ linear_ordered_comm_group_with_zero.nhds_fun Γ₀
theorem fin.cons_injective2 {n : ℕ} {α : fin (n + 1) → Type u} : function.injective2 fin.cons
theorem orientation.oangle_add_cyc3_neg_left {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle (-x) y + o.oangle (-y) z + o.oangle (-z) x = ↑real.pi
theorem div_eq_one_of_eq {G : Type u_2} [group G] {a b : G} : a = b → a / b = 1
theorem has_le.le.trans_lt {α : Type u} [preorder α] {a b c : α} : a ≤ b → b < c → a < c
theorem normed_group_hom.op_norm_zero_iff {V₁ : Type u_1} {V₂ : Type u_2} [normed_group V₁] [normed_group V₂] {f : normed_group_hom V₁ V₂} : ∥f∥ = 0 ↔ f = 0
theorem lt_add_of_sub_left_lt {α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a - b < c → a < b + c
theorem power_basis.trace_gen_eq_sum_roots {S : Type u_2} [comm_ring S] {K : Type u_4} [field K] {F : Type u_6} [field F] [algebra K S] [algebra K F] [nontrivial S] (pb : power_basis K S) (hf : polynomial.splits (algebra_map K F) (minpoly K pb.gen)) : ⇑(algebra_map K F) (⇑(algebra.trace K S) pb.gen) = (polynomial.map (algebra_map K F) (minpoly K pb.gen)).roots.sum
theorem add_submonoid.bot_or_exists_ne_zero {M : Type u_1} [add_zero_class M] (S : add_submonoid M) : S = ⊥ ∨ ∃ (x : M) (H : x ∈ S), x ≠ 0
theorem loc_unif_bound_dGamma_integrand {t : ℂ} {s1 s2 x : ℝ} (ht1 : s1 ≤ t.re) (ht2 : t.re ≤ s2) (hx : 0 < x) : ∥dGamma_integrand t x∥ ≤ dGamma_integrand_real s1 x + dGamma_integrand_real s2 x
theorem submonoid.closure_induction' {M : Type u_1} [mul_one_class M] (s : set M) {p : Π (x : M), x ∈ submonoid.closure s → Prop} (Hs : ∀ (x : M) (h : x ∈ s), p x _) (H1 : p 1 _) (Hmul : ∀ (x : M) (hx : x ∈ submonoid.closure s) (y : M) (hy : y ∈ submonoid.closure s), p x hx → p y hy → p (x * y) _) {x : M} (hx : x ∈ submonoid.closure s) : p x hx
theorem module.free.finrank_finsupp (R : Type u) [ring R] [strong_rank_condition R] {ι : Type v} [fintype ι] : finite_dimensional.finrank R (ι →₀ R) = fintype.card ι
theorem category_theory.limits.is_iso_limit_cone_parallel_pair_of_eq {C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} (h₀ : f = g) {c : category_theory.limits.fork f g} (h : category_theory.limits.is_limit c) : category_theory.is_iso c.ι
theorem measure_theory.measure.regular_of_is_mul_left_invariant {G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] {μ : measure_theory.measure G} [measure_theory.sigma_finite μ] [μ.is_mul_left_invariant] {K : set G} (hK : is_compact K) (h2K : (interior K).nonempty) (hμK : ⇑μ K ≠ ⊤) : μ.regular
theorem polynomial.nat_degree_sub_eq_of_prod_eq {R : Type u} [semiring R] [no_zero_divisors R] {p₁ p₂ q₁ q₂ : polynomial R} (hp₁ : p₁ ≠ 0) (hq₁ : q₁ ≠ 0) (hp₂ : p₂ ≠ 0) (hq₂ : q₂ ≠ 0) (h_eq : p₁ * q₂ = p₂ * q₁) : ↑(p₁.nat_degree) - ↑(q₁.nat_degree) = ↑(p₂.nat_degree) - ↑(q₂.nat_degree)
theorem cardinal.lift_sup_le {ι : Type v} (f : ι → cardinal) (t : cardinal) (w : ∀ (i : ι), (f i).lift ≤ t) : (cardinal.sup f).lift ≤ t
theorem cluster_pt_principal_iff {α : Type u} [topological_space α] {x : α} {s : set α} : cluster_pt x (filter.principal s) ↔ ∀ (U : set α), U ∈ nhds x → (U ∩ s).nonempty
theorem fintype.exists_card_fiber_lt_of_card_lt_mul {α : Type u} {β : Type v} [decidable_eq β] [fintype α] [fintype β] (f : α → β) {n : ℕ} (hn : fintype.card α < fintype.card β * n) : ∃ (y : β), (finset.filter (λ (x : α), f x = y) finset.univ).card < n
theorem dfinsupp.coe_fn_injective {ι : Type u} {β : ι → Type v} [Π (i : ι), has_zero (β i)] : function.injective coe_fn
theorem nonarchimedean_group.prod_self_subset {G : Type u_1} [group G] [topological_space G] [nonarchimedean_group G] {U : set (G × G)} (hU : U ∈ nhds 1) : ∃ (V : open_subgroup G), ↑V ×ˢ ↑V ⊆ U
theorem add_submonoid.supr_induction' {M : Type u_1} [add_zero_class M] {ι : Sort u_2} (S : ι → add_submonoid M) {C : Π (x : M), (x ∈ ⨆ (i : ι), S i) → Prop} (hp : ∀ (i : ι) (x : M) (H : x ∈ S i), C x _) (h1 : C 0 _) (hmul : ∀ (x y : M) (hx : x ∈ ⨆ (i : ι), S i) (hy : y ∈ ⨆ (i : ι), S i), C x hx → C y hy → C (x + y) _) {x : M} (hx : x ∈ ⨆ (i : ι), S i) : C x hx
theorem submodule.mem_supr_iff_exists_finset {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] {ι : Type u_3} {p : ι → submodule R M} {m : M} : (m ∈ ⨆ (i : ι), p i) ↔ ∃ (s : finset ι), m ∈ ⨆ (i : ι) (H : i ∈ s), p i
theorem list.prod_eq_zero {M₀ : Type u_6} [monoid_with_zero M₀] {L : list M₀} (h : 0 ∈ L) : L.prod = 0
theorem alternating_map.eq_smul_basis_det {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {ι : Type u_4} [decidable_eq ι] [fintype ι] (e : basis ι R M) (f : alternating_map R M R ι) : f = ⇑f ⇑e • e.det
theorem order.pfilter.inf_mem {P : Type u_1} [semilattice_inf P] {x y : P} {F : order.pfilter P} (hx : x ∈ F) (hy : y ∈ F) : x ⊓ y ∈ F
theorem con.symm {M : Type u_1} [has_mul M] (c : con M) {x y : M} : ⇑c x y → ⇑c y x
theorem convex.second_derivative_within_at_symmetric {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {s : set E} (s_conv : convex ℝ s) (hne : (interior s).nonempty) {f : E → F} {f' : E → (E →L[ℝ] F)} {f'' : E →L[ℝ] E →L[ℝ] F} (hf : ∀ (x : E), x ∈ interior s → has_fderiv_at f (f' x) x) {x : E} (xs : x ∈ s) (hx : has_fderiv_within_at f' f'' (interior s) x) (v w : E) : ⇑(⇑f'' v) w = ⇑(⇑f'' w) v
theorem function.bij_on_fixed_pts_comp {α : Type u} {β : Type v} (f : α → β) (g : β → α) : set.bij_on g (function.fixed_points (f ∘ g)) (function.fixed_points (g ∘ f))
theorem continuous_linear_map.to_ring_inverse {R : Type u_1} {M : Type u_2} {M₂ : Type u_3} [topological_space M] [topological_space M₂] [ring R] [add_comm_group M] [topological_add_group M] [module R M] [add_comm_group M₂] [module R M₂] (e : M ≃L[R] M₂) (f : M →L[R] M₂) : f.inverse = (ring.inverse (↑(e.symm).comp f)).comp ↑(e.symm)
theorem orientation.rotation_symm {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (θ : real.angle) : (o.rotation θ).symm = o.rotation (-θ)
theorem has_strict_deriv_at.real_of_complex {e : ℂ → ℂ} {e' : ℂ} {z : ℝ} (h : has_strict_deriv_at e e' ↑z) : has_strict_deriv_at (λ (x : ℝ), (e ↑x).re) e'.re z
theorem cont_diff_prod_assoc {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] : cont_diff 𝕜 ⊤ ⇑(equiv.prod_assoc E F G)
theorem continuous_linear_map.exists_preimage_norm_le {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] (f : E →L[𝕜] F) [complete_space F] [complete_space E] (surj : function.surjective ⇑f) : ∃ (C : ℝ) (H : C > 0), ∀ (y : F), ∃ (x : E), ⇑f x = y ∧ ∥x∥ ≤ C * ∥y∥
theorem measure_theory.is_add_fundamental_domain.measure_eq {G : Type u_1} {α : Type u_2} [add_group G] [add_action G α] [measurable_space α] {s t : set α} {μ : measure_theory.measure α} [measurable_space G] [has_measurable_vadd G α] [measure_theory.vadd_invariant_measure G α μ] [encodable G] (hs : measure_theory.is_add_fundamental_domain G s μ) (ht : measure_theory.is_add_fundamental_domain G t μ) : ⇑μ s = ⇑μ t
theorem ring_equiv.map_zero {R : Type u_4} {S : Type u_5} [non_unital_non_assoc_semiring R] [non_unital_non_assoc_semiring S] (f : R ≃+* S) : ⇑f 0 = 0
theorem fin_succ_equiv'_zero {n : ℕ} : fin_succ_equiv' 0 = fin_succ_equiv n
theorem complex.conj_conj {R : Type u} [comm_semiring R] [star_ring R] (x : R) : ⇑(star_ring_end R) (⇑(star_ring_end R) x) = x
theorem submonoid.localization_map.map_mul_left {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M →* P} {T : submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ T) {Q : Type u_4} [comm_monoid Q] {k : T.localization_map Q} (z : N) : ⇑(k.to_map) (⇑g ↑((f.sec z).snd)) * ⇑(f.map hy k) z = ⇑(k.to_map) (⇑g (f.sec z).fst)
theorem category_theory.grothendieck_topology.superset_covering {C : Type u} [category_theory.category C] {X : C} {S R : category_theory.sieve X} (J : category_theory.grothendieck_topology C) (Hss : S ≤ R) (sjx : S ∈ ⇑J X) : R ∈ ⇑J X
theorem subfield.list_prod_mem {K : Type u} [field K] (s : subfield K) {l : list K} : (∀ (x : K), x ∈ l → x ∈ s) → l.prod ∈ s
theorem affine.simplex.ext {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : ℕ} {s1 s2 : affine.simplex k P n} (h : ∀ (i : fin (n + 1)), s1.points i = s2.points i) : s1 = s2
theorem measurable_set.image_of_measurable_inj_on {γ : Type u_3} [tγ : topological_space γ] [polish_space γ] [measurable_space γ] [borel_space γ] {β : Type u_4} [tβ : topological_space β] [t2_space β] [measurable_space β] [borel_space β] {s : set γ} {f : γ → β} [topological_space.second_countable_topology β] (hs : measurable_set s) (f_meas : measurable f) (f_inj : set.inj_on f s) : measurable_set (f '' s)
theorem intermediate_field.fixing_subgroup_is_closed {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E : intermediate_field K L) [finite_dimensional K ↥E] : is_closed ↑(E.fixing_subgroup)
theorem finset.weighted_vsub_of_point_apply_const {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (w : ι → k) (p b : P) : ⇑(s.weighted_vsub_of_point (λ (_x : ι), p) b) w = s.sum (λ (i : ι), w i) • (p -ᵥ b)
theorem list.nat.nodup_antidiagonal_tuple (k n : ℕ) : (list.nat.antidiagonal_tuple k n).nodup
theorem finset.order_emb_of_fin_zero {α : Type u_1} [linear_order α] {s : finset α} {k : ℕ} (h : s.card = k) (hz : 0 < k) : ⇑(s.order_emb_of_fin h) ⟨0, hz⟩ = s.min' _
theorem metric.Hausdorff_dist_zero_iff_closure_eq_closure {α : Type u} [pseudo_metric_space α] {s t : set α} (fin : emetric.Hausdorff_edist s t ≠ ⊤) : metric.Hausdorff_dist s t = 0 ↔ closure s = closure t
theorem free_group.of_injective {α : Type u} : function.injective free_group.of
theorem mul_eq_zero_comm {M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b = 0 ↔ b * a = 0
theorem colex.colex_le_of_subset {α : Type u_1} [linear_order α] {A B : finset α} (h : A ⊆ B) : A.to_colex ≤ B.to_colex
theorem continuous_on.comp_fract' {α : Type u_1} {β : Type u_2} {γ : Type u_3} [linear_ordered_ring α] [floor_ring α] [topological_space α] [order_topology α] [topological_add_group α] [topological_space β] [topological_space γ] {f : β → α → γ} (h : continuous_on (function.uncurry f) (set.univ ×ˢ set.Icc 0 1)) (hf : ∀ (s : β), f s 0 = f s 1) : continuous (λ (st : β × α), f st.fst (int.fract st.snd))
theorem class_group.exists_mem_finset_approx {R : Type u_1} {S : Type u_2} [euclidean_domain R] [comm_ring S] [is_domain S] [algebra R S] {abv : absolute_value R ℤ} {ι : Type u_5} [decidable_eq ι] [fintype ι] (bS : basis ι R S) (adm : abv.is_admissible) [infinite R] [decidable_eq R] (a : S) {b : R} (hb : b ≠ 0) : ∃ (q : S) (r : R) (H : r ∈ class_group.finset_approx bS adm), ⇑abv (⇑(algebra.norm R) (r • a - b • q)) < ⇑abv (⇑(algebra.norm R) (⇑(algebra_map R S) b))
theorem is_unit.mul_right_dvd {α : Type u_1} [monoid α] {a b u : α} (hu : is_unit u) : a * u ∣ b ↔ a ∣ b
theorem padic_norm.padic_norm_p_lt_one {p : ℕ} (hp : 1 < p) : padic_norm p ↑p < 1
theorem fin.pred_succ_above_pred {n : ℕ} {a : fin (n + 2)} {b : fin (n + 1)} (ha : a ≠ 0) (hb : b ≠ 0) (hk : ⇑(a.succ_above) b ≠ 0 := _) : ⇑((a.pred ha).succ_above) (b.pred hb) = (⇑(a.succ_above) b).pred hk
theorem polynomial.alg_hom_ext' {R : Type u} {A' : Type u_1} {B' : Type u_2} [comm_semiring A'] [semiring B'] [comm_semiring R] [algebra R A'] [algebra R B'] {f g : polynomial A' →ₐ[R] B'} (h₁ : f.comp (is_scalar_tower.to_alg_hom R A' (polynomial A')) = g.comp (is_scalar_tower.to_alg_hom R A' (polynomial A'))) (h₂ : ⇑f polynomial.X = ⇑g polynomial.X) : f = g
theorem monotone.forall_le_of_antitone {α : Type u} [semilattice_sup α] {β : Type u_1} [preorder β] {f g : α → β} (hf : monotone f) (hg : antitone g) (h : f ≤ g) (m n : α) : f m ≤ g n
theorem polynomial.cyclotomic_eq_geom_sum {R : Type u_1} [comm_ring R] {p : ℕ} (hp : nat.prime p) : polynomial.cyclotomic p R = (finset.range p).sum (λ (i : ℕ), polynomial.X ^ i)
theorem box_integral.integrable_of_continuous_on {ι : Type u} {E : Type v} [normed_group E] [normed_space ℝ E] [fintype ι] (l : box_integral.integration_params) [complete_space E] {I : box_integral.box ι} {f : (ι → ℝ) → E} (hc : continuous_on f (⇑box_integral.box.Icc I)) (μ : measure_theory.measure (ι → ℝ)) [measure_theory.is_locally_finite_measure μ] : box_integral.integrable I l f μ.to_box_additive.to_smul
theorem has_strict_fderiv_at.to_local_left_inverse {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] [cs : complete_space E] {f : E → F} {f' : E ≃L[𝕜] F} {a : E} (hf : has_strict_fderiv_at f ↑f' a) {g : F → E} (hg : ∀ᶠ (x : E) in nhds a, g (f x) = x) : has_strict_fderiv_at g ↑(f'.symm) (f a)
theorem category_theory.is_iso_of_mono_of_strong_epi {C : Type u} [category_theory.category C] {P Q : C} (f : P ⟶ Q) [category_theory.mono f] [category_theory.strong_epi f] : category_theory.is_iso f
theorem measure_theory.forall_measure_preimage_add_right_iff {G : Type u_1} [measurable_space G] [has_add G] [has_measurable_add G] (μ : measure_theory.measure G) : (∀ (g : G) (A : set G), measurable_set A → ⇑μ ((λ (h : G), h + g) ⁻¹' A) = ⇑μ A) ↔ μ.is_add_right_invariant
theorem basis.to_matrix_mul_to_matrix {ι : Type u_1} {ι' : Type u_2} {R : Type u_5} {M : Type u_6} [comm_semiring R] [add_comm_monoid M] [module R M] (b : basis ι R M) (b' : basis ι' R M) {ι'' : Type u_3} [fintype ι'] (b'' : ι'' → M) : (b.to_matrix ⇑b').mul (b'.to_matrix b'') = b.to_matrix b''
theorem add_subgroup.closure_induction' {G : Type u_1} [add_group G] {k : set G} {p : Π (x : G), x ∈ add_subgroup.closure k → Prop} (Hs : ∀ (x : G) (h : x ∈ k), p x _) (H1 : p 0 _) (Hmul : ∀ (x : G) (hx : x ∈ add_subgroup.closure k) (y : G) (hy : y ∈ add_subgroup.closure k), p x hx → p y hy → p (x + y) _) (Hinv : ∀ (x : G) (hx : x ∈ add_subgroup.closure k), p x hx → p (-x) _) {x : G} (hx : x ∈ add_subgroup.closure k) : p x hx
theorem homological_complex.eq_to_hom_comp_d {ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape ι} (C : homological_complex V c) {i i' j : ι} (rij : c.rel i j) (rij' : c.rel i' j) : category_theory.eq_to_hom _ ≫ C.d i' j = C.d i j
theorem generalized_continued_fraction.exists_rat_eq_nth_convergent {K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) (n : ℕ) : ∃ (q : ℚ), (generalized_continued_fraction.of v).convergents n = ↑q
theorem ennreal.inner_le_Lp_mul_Lq {ι : Type u} (s : finset ι) (f g : ι → ennreal) {p q : ℝ} (hpq : p.is_conjugate_exponent q) : s.sum (λ (i : ι), f i * g i) ≤ s.sum (λ (i : ι), f i ^ p) ^ (1 / p) * s.sum (λ (i : ι), g i ^ q) ^ (1 / q)
theorem phragmen_lindelof.right_half_plane_of_tendsto_zero_on_real {E : Type u_1} [normed_group E] [normed_space ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ} (hd : diff_cont_on_cl ℂ f {z : ℂ | 0 < z.re}) (hexp : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ filter.principal {z : ℂ | 0 < z.re}] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hre : filter.tendsto (λ (x : ℝ), f ↑x) filter.at_top (nhds 0)) (him : ∀ (x : ℝ), ∥f (↑x * complex.I)∥ ≤ C) (hz : 0 ≤ z.re) : ∥f z∥ ≤ C
theorem cont_mdiff_on_of_locally_cont_mdiff_on {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M → M'} {s : set M} {n : with_top ℕ} (h : ∀ (x : M), x ∈ s → (∃ (u : set M), is_open u ∧ x ∈ u ∧ cont_mdiff_on I I' n f (s ∩ u))) : cont_mdiff_on I I' n f s
theorem mv_polynomial.hom_congr_vars {R : Type u} {S : Type v} {σ : Type u_1} [comm_semiring R] [comm_semiring S] {f₁ f₂ : mv_polynomial σ R →+* S} {p₁ p₂ : mv_polynomial σ R} (hC : f₁.comp mv_polynomial.C = f₂.comp mv_polynomial.C) (hv : ∀ (i : σ), i ∈ p₁.vars → i ∈ p₂.vars → ⇑f₁ (mv_polynomial.X i) = ⇑f₂ (mv_polynomial.X i)) (hp : p₁ = p₂) : ⇑f₁ p₁ = ⇑f₂ p₂
theorem is_smul_regular.pow {R : Type u_1} {M : Type u_3} {a : R} [monoid R] [mul_action R M] (n : ℕ) (ra : is_smul_regular M a) : is_smul_regular M (a ^ n)
theorem lie_algebra.is_nilpotent_iff_forall {R : Type u₁} {L : Type u₂} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : lie_algebra.is_nilpotent R L ↔ ∀ (x : L), is_nilpotent (⇑(lie_algebra.ad R L) x)
theorem orthonormal.oangle_neg_self_left {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x : V} (hx : x ≠ 0) : hb.oangle (-x) x = ↑real.pi
theorem formal_multilinear_series.id_apply_one' (𝕜 : Type u_1) (E : Type u_2) [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] {n : ℕ} (h : n = 1) (v : fin n → E) : ⇑(formal_multilinear_series.id 𝕜 E n) v = v ⟨0, _⟩
theorem affine_subspace.mem_direction_iff_eq_vsub {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} (h : ↑s.nonempty) (v : V) : v ∈ s.direction ↔ ∃ (p1 : P) (H : p1 ∈ s) (p2 : P) (H : p2 ∈ s), v = p1 -ᵥ p2
theorem normed_ring.summable_geometric_of_norm_lt_1 {R : Type u_4} [normed_ring R] [complete_space R] (x : R) (h : ∥x∥ < 1) : summable (λ (n : ℕ), x ^ n)
theorem antilipschitz_with.of_le_mul_nndist {α : Type u_1} {β : Type u_2} [pseudo_metric_space α] [pseudo_metric_space β] {K : nnreal} {f : α → β} : (∀ (x y : α), has_nndist.nndist x y ≤ K * has_nndist.nndist (f x) (f y)) → antilipschitz_with K f
theorem exp_char_one_iff_char_zero (R : Type u) [semiring R] [nontrivial R] (p q : ℕ) [char_p R p] [exp_char R q] : q = 1 ↔ p = 0
theorem affine_subspace.affine_span_eq_top_iff_vector_span_eq_top_of_nonempty (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s : set P} (hs : s.nonempty) : affine_span k s = ⊤ ↔ vector_span k s = ⊤
theorem metric.totally_bounded_of_finite_discretization {α : Type u} [pseudo_metric_space α] {s : set α} (H : ∀ (ε : ℝ), ε > 0 → (∃ (β : Type u) (_x : fintype β) (F : ↥s → β), ∀ (x y : ↥s), F x = F y → has_dist.dist ↑x ↑y < ε)) : totally_bounded s
theorem is_chain.exists_max_chain {α : Type u_1} {r : α → α → Prop} {c : set α} (hc : is_chain r c) : ∃ (M : set α), is_max_chain r M ∧ c ⊆ M
theorem prod.map_comp_map {α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} {ε : Type u_5} {ζ : Type u_6} (f : α → β) (f' : γ → δ) (g : β → ε) (g' : δ → ζ) : prod.map g g' ∘ prod.map f f' = prod.map (g ∘ f) (g' ∘ f')
theorem multilinear_map.map_piecewise_smul {R : Type u} {ι : Type u'} {M₁ : ι → Type v₁} {M₂ : Type v₂} [decidable_eq ι] [comm_semiring R] [Π (i : ι), add_comm_monoid (M₁ i)] [add_comm_monoid M₂] [Π (i : ι), module R (M₁ i)] [module R M₂] (f : multilinear_map R M₁ M₂) (c : ι → R) (m : Π (i : ι), M₁ i) (s : finset ι) : ⇑f (s.piecewise (λ (i : ι), c i • m i) m) = s.prod (λ (i : ι), c i) • ⇑f m
theorem gauge_nonneg {E : Type u_1} [add_comm_group E] [module ℝ E] {s : set E} (x : E) : 0 ≤ gauge s x
theorem category_theory.presieve.family_of_elements.compatible.sieve_extend {C : Type u₁} [category_theory.category C] {P : Cᵒᵖ ⥤ Type w} {X : C} {R : category_theory.presieve X} {x : category_theory.presieve.family_of_elements P R} (hx : x.compatible) : x.sieve_extend.compatible
theorem interior_frontier {α : Type u} [topological_space α] {s : set α} (h : is_closed s) : interior (frontier s) = ∅
theorem subring.multiset_prod_mem {R : Type u_1} [comm_ring R] (s : subring R) (m : multiset R) : (∀ (a : R), a ∈ m → a ∈ s) → m.prod ∈ s
theorem first_order.language.Structure.cg_iff {L : first_order.language} {M : Type u_3} [L.Structure M] : first_order.language.Structure.cg L M ↔ ∃ (S : set M), S.countable ∧ ⇑(first_order.language.substructure.closure L) S = ⊤
theorem complex.has_deriv_at_Gamma_integral {s : ℂ} (hs : 1 < s.re) : measure_theory.integrable_on (λ (x : ℝ), ↑(real.exp (-x)) * ↑(real.log x) * ↑x ^ (s - 1)) (set.Ioi 0) measure_theory.measure_space.volume ∧ has_deriv_at complex.Gamma_integral (∫ (x : ℝ) in set.Ioi 0, ↑(real.exp (-x)) * ↑(real.log x) * ↑x ^ (s - 1)) s
theorem category_theory.limits.has_pushout_symmetry {C : Type u} [category_theory.category C] {X Y Z : C} (f : X ⟶ Y) (g : X ⟶ Z) [category_theory.limits.has_pushout f g] : category_theory.limits.has_pushout g f
theorem isometry.embedding {α : Type u} {β : Type v} [emetric_space α] [pseudo_emetric_space β] {f : α → β} (hf : isometry f) : embedding f
theorem monoid_hom.unop_map_list_prod {M : Type u_3} {N : Type u_4} [monoid M] [monoid N] (f : M →* Nᵐᵒᵖ) (l : list M) : mul_opposite.unop (⇑f l.prod) = (list.map (mul_opposite.unop ∘ ⇑f) l).reverse.prod
theorem continuous_linear_map.adjoint_inner_right {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [inner_product_space 𝕜 F] [complete_space E] [complete_space F] (A : E →L[𝕜] F) (x : E) (y : F) : has_inner.inner x (⇑(⇑continuous_linear_map.adjoint A) y) = has_inner.inner (⇑A x) y
theorem valuation.supp_quot {R : Type u_2} {Γ₀ : Type u_3} [comm_ring R] [linear_ordered_comm_monoid_with_zero Γ₀] (v : valuation R Γ₀) {J : ideal R} (hJ : J ≤ v.supp) : (v.on_quot hJ).supp = ideal.map (ideal.quotient.mk J) v.supp
theorem finset.order_emb_of_fin_eq_order_emb_of_fin_iff {α : Type u_1} [linear_order α] {k l : ℕ} {s : finset α} {i : fin k} {j : fin l} {h : s.card = k} {h' : s.card = l} : ⇑(s.order_emb_of_fin h) i = ⇑(s.order_emb_of_fin h') j ↔ ↑i = ↑j
theorem mem_omega_limit_iff_frequently₂ {τ : Type u_1} {α : Type u_2} {β : Type u_3} [topological_space β] (f : filter τ) (ϕ : τ → α → β) (s : set α) (y : β) : y ∈ omega_limit f ϕ s ↔ ∀ (n : set β), n ∈ nhds y → (∃ᶠ (t : τ) in f, (ϕ t '' s ∩ n).nonempty)
theorem cont_diff_within_at.prod {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {x : E} {n : with_top ℕ} {s : set E} {f : E → F} {g : E → G} (hf : cont_diff_within_at 𝕜 n f s x) (hg : cont_diff_within_at 𝕜 n g s x) : cont_diff_within_at 𝕜 n (λ (x : E), (f x, g x)) s x
theorem span_fourier_closure_eq_top  : (submodule.span ℂ (set.range fourier)).topological_closure = ⊤
theorem monotone_on.map_bdd_below {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s t : set α} (Hf : monotone_on f t) (Hst : s ⊆ t) : (lower_bounds s ∩ t).nonempty → bdd_below (f '' s)
theorem measure_theory.add_haar_image_le_mul_of_det_lt {E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] [measurable_space E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (A : E →L[ℝ] E) {m : nnreal} (hm : ennreal.of_real |A.det| < ↑m) : ∀ᶠ (δ : nnreal) in nhds_within 0 (set.Ioi 0), ∀ (s : set E) (f : E → E), approximates_linear_on f A s δ → ⇑μ (f '' s) ≤ ↑m * ⇑μ s
theorem filter.tendsto.mul_at_bot {α : Type u} {β : Type v} [linear_ordered_field α] [topological_space α] [order_topology α] {l : filter β} {f g : β → α} {C : α} (hC : 0 < C) (hf : filter.tendsto f l (nhds C)) (hg : filter.tendsto g l filter.at_bot) : filter.tendsto (λ (x : β), f x * g x) l filter.at_bot
theorem category_theory.limits.has_finite_biproducts.of_has_finite_products {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_products C] : category_theory.limits.has_finite_biproducts C
theorem add_submonoid.localization_map.lift_spec_add {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M →+ P} (hg : ∀ (y : ↥S), is_add_unit (⇑g ↑y)) (z : N) (w v : P) : ⇑(f.lift hg) z + w = v ↔ ⇑g (f.sec z).fst + w = ⇑g ↑((f.sec z).snd) + v
theorem is_smul_regular.mul_and_mul_iff {R : Type u_1} {M : Type u_3} {a b : R} [has_scalar R M] [has_mul R] [is_scalar_tower R R M] : is_smul_regular M (a * b) ∧ is_smul_regular M (b * a) ↔ is_smul_regular M a ∧ is_smul_regular M b
theorem strict_concave_on_of_deriv2_neg {D : set ℝ} (hD : convex ℝ D) {f : ℝ → ℝ} (hf : continuous_on f D) (hf' : differentiable_on ℝ f (interior D)) (hf'' : ∀ (x : ℝ), x ∈ interior D → deriv^[2] f x < 0) : strict_concave_on ℝ D f
theorem matrix.is_hermitian.from_blocks {α : Type u_1} {m : Type u_3} {n : Type u_4} [non_unital_semiring α] [star_ring α] {A : matrix m m α} {B : matrix m n α} {C : matrix n m α} {D : matrix n n α} (hA : A.is_hermitian) (hBC : B.conj_transpose = C) (hD : D.is_hermitian) : (matrix.from_blocks A B C D).is_hermitian
theorem finite_dimensional.finrank_map_le (K : Type u) {V : Type v} [division_ring K] [add_comm_group V] [module K V] {V₂ : Type v'} [add_comm_group V₂] [module K V₂] (f : V →ₗ[K] V₂) (p : submodule K V) [finite_dimensional K ↥p] : finite_dimensional.finrank K ↥(submodule.map f p) ≤ finite_dimensional.finrank K ↥p
theorem vsub_right_cancel_iff {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] {p1 p2 p : P} : p -ᵥ p1 = p -ᵥ p2 ↔ p1 = p2
theorem quotient_norm_add_le {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (x y : M ⧸ S) : ∥x + y∥ ≤ ∥x∥ + ∥y∥
theorem category_theory.mem_ess_image_of_unit_is_iso {C : Type u₁} {D : Type u₂} [category_theory.category C] [category_theory.category D] {i : D ⥤ C} [category_theory.is_right_adjoint i] (A : C) [category_theory.is_iso ((category_theory.adjunction.of_right_adjoint i).unit.app A)] : A ∈ i.ess_image
theorem category_theory.limits.complete_lattice.prod_eq_inf {α : Type u} [semilattice_inf α] [order_top α] (x y : α) : (x ⨯ y) = x ⊓ y
theorem list.split_wrt_composition_join {α : Type u_1} (L : list (list α)) (c : composition L.join.length) (h : list.map list.length L = c.blocks) : L.join.split_wrt_composition c = L
theorem matrix.circulant_smul {α : Type u_1} {n : Type u_4} {R : Type u_5} [has_sub n] [has_scalar R α] (k : R) (v : n → α) : matrix.circulant (k • v) = k • matrix.circulant v
theorem affine_subspace.vadd_mem_iff_mem_direction {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} (v : V) {p : P} (hp : p ∈ s) : v +ᵥ p ∈ s ↔ v ∈ s.direction
theorem is_noetherian_of_tower (R : Type u_1) {S : Type u_2} {M : Type u_3} [semiring R] [semiring S] [add_comm_monoid M] [has_scalar R S] [module S M] [module R M] [is_scalar_tower R S M] (h : is_noetherian R M) : is_noetherian S M
theorem category_theory.is_connected_of_zigzag {J : Type u₁} [category_theory.category J] [nonempty J] (h : ∀ (j₁ j₂ : J), ∃ (l : list J), list.chain category_theory.zag j₁ l ∧ (j₁ :: l).last _ = j₂) : category_theory.is_connected J
theorem ideal.is_maximal_of_is_maximal_disjoint {R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] (y : R) [algebra R S] [is_localization.away y S] [ideal.is_jacobson R] (I : ideal R) (hI : I.is_maximal) (hy : y ∉ I) : (ideal.map (algebra_map R S) I).is_maximal
theorem continuous_map.subalgebra_is_R_or_C_topological_closure_eq_top_of_separates_points {𝕜 : Type u_1} {X : Type u_2} [is_R_or_C 𝕜] [topological_space X] [compact_space X] (A : subalgebra 𝕜 C(X, 𝕜)) (hA : A.separates_points) (hA' : continuous_map.conj_invariant_subalgebra (subalgebra.restrict_scalars ℝ A)) : A.topological_closure = ⊤
theorem is_open_iff_ball_subset {α : Type u_1} [uniform_space α] {s : set α} : is_open s ↔ ∀ (x : α), x ∈ s → (∃ (V : set (α × α)) (H : V ∈ uniformity α), uniform_space.ball x V ⊆ s)
theorem matrix.pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux {𝕜 : Type u_3} [field 𝕜] (n : Type) [fintype n] [decidable_eq n] (M : matrix n n 𝕜) : ∃ (L L' : list (matrix.transvection_struct n 𝕜)) (D : n → 𝕜), ((list.map matrix.transvection_struct.to_matrix L).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L').prod = matrix.diagonal D
theorem affine.simplex.face_centroid_eq_iff {k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [char_zero k] {n : ℕ} (s : affine.simplex k P n) {fs₁ fs₂ : finset (fin (n + 1))} {m₁ m₂ : ℕ} (h₁ : fs₁.card = m₁ + 1) (h₂ : fs₂.card = m₂ + 1) : finset.centroid k finset.univ (s.face h₁).points = finset.centroid k finset.univ (s.face h₂).points ↔ fs₁ = fs₂
theorem con.lift_range {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} {f : M →* P} (H : c ≤ con.ker f) : (c.lift f H).mrange = f.mrange
theorem topological_group_of_lie_group {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space 𝕜 E] (I : model_with_corners 𝕜 E H) {G : Type u_5} [topological_space G] [charted_space H G] [group G] [lie_group I G] : topological_group G
theorem metric.uniform_continuous_inf_dist_pt {α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_dist x s)
theorem ideal.is_maximal_iff_is_maximal_disjoint {R : Type u_1} (S : Type u_2) [comm_ring R] [comm_ring S] (y : R) [algebra R S] [is_localization.away y S] [H : ideal.is_jacobson R] (J : ideal S) : J.is_maximal ↔ (ideal.comap (algebra_map R S) J).is_maximal ∧ y ∉ ideal.comap (algebra_map R S) J
theorem continuous_map.homotopy.heq_path_of_eq_image {X₁ X₂ Y : Top} {f : C(↥X₁, ↥Y)} {g : C(↥X₂, ↥Y)} {x₀ x₁ : ↥X₁} {x₂ x₃ : ↥X₂} {p : path x₀ x₁} {q : path x₂ x₃} (hfg : ∀ (t : ↥unit_interval), ⇑f (⇑p t) = ⇑g (⇑q t)) : (fundamental_groupoid.fundamental_groupoid_functor.map f).map ⟦p⟧ == (fundamental_groupoid.fundamental_groupoid_functor.map g).map ⟦q⟧
theorem setoid.eq_eqv_class_of_mem {α : Type u_1} {c : set (set α)} (H : ∀ (a : α), ∃! (b : set α) (H : b ∈ c), a ∈ b) {s : set α} {y : α} (hs : s ∈ c) (hy : y ∈ s) : s = {x : α | (setoid.mk_classes c H).rel x y}
theorem measurable_set_of_differentiable_within_at_Ici_of_is_complete {F : Type u_1} [normed_group F] [normed_space ℝ F] (f : ℝ → F) {K : set F} (hK : is_complete K) : measurable_set {x : ℝ | differentiable_within_at ℝ f (set.Ici x) x ∧ deriv_within f (set.Ici x) x ∈ K}
theorem category_theory.subobject.inf_pullback {C : Type u₁} [category_theory.category C] [category_theory.limits.has_pullbacks C] {X Y : C} (g : X ⟶ Y) (f₁ f₂ : category_theory.subobject Y) : (category_theory.subobject.pullback g).obj (f₁ ⊓ f₂) = (category_theory.subobject.pullback g).obj f₁ ⊓ (category_theory.subobject.pullback g).obj f₂
theorem ring_hom.unop_map_list_prod {β : Type u} {γ : Type w} [semiring β] [semiring γ] (f : β →+* γᵐᵒᵖ) (l : list β) : mul_opposite.unop (⇑f l.prod) = (list.map (mul_opposite.unop ∘ ⇑f) l).reverse.prod
theorem ordinal.principal_mul_iff_le_two_or_omega_opow_opow {o : ordinal} : ordinal.principal has_mul.mul o ↔ o ≤ 2 ∨ ∃ (a : ordinal), o = ordinal.omega ^ ordinal.omega ^ a
theorem simple_graph.degree_le_max_degree {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (v : V) : G.degree v ≤ G.max_degree
theorem homotopy.null_homotopic_map_comp {ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D E : homological_complex V c} (hom : Π (i j : ι), C.X i ⟶ D.X j) (g : D ⟶ E) : homotopy.null_homotopic_map hom ≫ g = homotopy.null_homotopic_map (λ (i j : ι), hom i j ≫ g.f j)
theorem orientation.rotation_eq_basis_rotation {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (h : b.orientation = o) (θ : ℝ) : o.rotation ↑θ = hb.rotation ↑θ
theorem intermediate_field.multiset_prod_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) (m : multiset L) : (∀ (a : L), a ∈ m → a ∈ S) → m.prod ∈ S
theorem discrete_valuation_ring.of_ufd_of_unique_irreducible {R : Type u} [comm_ring R] [is_domain R] [unique_factorization_monoid R] (h₁ : ∃ (p : R), irreducible p) (h₂ : ∀ ⦃p q : R⦄, irreducible p → irreducible q → associated p q) : discrete_valuation_ring R
theorem function.semiconj.maps_to_fixed_pts {α : Type u} {β : Type v} {fa : α → α} {fb : β → β} {g : α → β} (h : function.semiconj g fa fb) : set.maps_to g (function.fixed_points fa) (function.fixed_points fb)
theorem discrete_valuation_ring.exists_irreducible (R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R] : ∃ (ϖ : R), irreducible ϖ
theorem right.one_le_mul {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b
theorem is_closed.exists_closed_singleton {α : Type u_1} [topological_space α] [t0_space α] [compact_space α] {S : set α} (hS : is_closed S) (hne : S.nonempty) : ∃ (x : α), x ∈ S ∧ is_closed {x}
theorem sum_div_nat_floor_pow_sq_le_div_sq (N : ℕ) {j : ℝ} (hj : 0 < j) {c : ℝ} (hc : 1 < c) : (finset.filter (λ (i : ℕ), j < ↑⌊c ^ i⌋₊) (finset.range N)).sum (λ (i : ℕ), 1 / ↑⌊c ^ i⌋₊ ^ 2) ≤ c ^ 5 * (c - 1)⁻¹ ^ 3 / j ^ 2
theorem linear_independent_le_span {R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {ι : Type u_1} (v : ι → M) (i : linear_independent R v) (w : set M) [fintype ↥w] (s : submodule.span R w = ⊤) : cardinal.mk ι ≤ ↑(fintype.card ↥w)
theorem inv_le_of_inv_le' {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} : a⁻¹ ≤ b → b⁻¹ ≤ a
theorem real.inner_le_Lp_mul_Lq_of_nonneg {ι : Type u} (s : finset ι) {f g : ι → ℝ} {p q : ℝ} (hpq : p.is_conjugate_exponent q) (hf : ∀ (i : ι), i ∈ s → 0 ≤ f i) (hg : ∀ (i : ι), i ∈ s → 0 ≤ g i) : s.sum (λ (i : ι), f i * g i) ≤ s.sum (λ (i : ι), f i ^ p) ^ (1 / p) * s.sum (λ (i : ι), g i ^ q) ^ (1 / q)
theorem metric.second_countable_of_countable_discretization {α : Type u} [metric_space α] (H : ∀ (ε : ℝ), ε > 0 → (∃ (β : Type u_1) (_x : encodable β) (F : α → β), ∀ (x y : α), F x = F y → has_dist.dist x y ≤ ε)) : topological_space.second_countable_topology α
theorem vector_span_singleton (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) : vector_span k {p} = ⊥
theorem zero_lt.left.mul_le_one_of_le_of_le {α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (a0 : 0 ≤ a) : a * b ≤ 1
theorem add_monoid_algebra.alg_hom_ext' {k : Type u₁} {G : Type u₂} [comm_semiring k] [add_monoid G] {A : Type u₃} [semiring A] [algebra k A] ⦃φ₁ φ₂ : add_monoid_algebra k G →ₐ[k] A⦄ (h : ↑φ₁.comp (add_monoid_algebra.of k G) = ↑φ₂.comp (add_monoid_algebra.of k G)) : φ₁ = φ₂
theorem has_sum_sum_of_ne_finset_zero {α : Type u_1} {β : Type u_2} [add_comm_monoid α] [topological_space α] {f : β → α} {s : finset β} (hf : ∀ (b : β), b ∉ s → f b = 0) : has_sum f (s.sum (λ (b : β), f b))
theorem has_ftaylor_series_up_to_on.differentiable_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {x : E} {n : with_top ℕ} {p : E → formal_multilinear_series 𝕜 E F} (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 ≤ n) (hx : s ∈ nhds x) : differentiable_at 𝕜 f x
theorem matrix.circulant_mul {α : Type u_1} {n : Type u_4} [semiring α] [fintype n] [add_group n] (v w : n → α) : (matrix.circulant v).mul (matrix.circulant w) = matrix.circulant ((matrix.circulant v).mul_vec w)
theorem add_submonoid.localization_map.lift_spec {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M →+ P} (hg : ∀ (y : ↥S), is_add_unit (⇑g ↑y)) (z : N) (v : P) : ⇑(f.lift hg) z = v ↔ ⇑g (f.sec z).fst = ⇑g ↑((f.sec z).snd) + v
theorem quotient_norm_neg {M : Type u_1} [semi_normed_group M] {S : add_subgroup M} (x : M ⧸ S) : ∥-x∥ = ∥x∥
theorem add_monoid_hom.mul_op_ext {α : Type u_1} {β : Type u_2} [add_zero_class α] [add_zero_class β] (f g : αᵐᵒᵖ →+ β) (h : f.comp mul_opposite.op_add_equiv.to_add_monoid_hom = g.comp mul_opposite.op_add_equiv.to_add_monoid_hom) : f = g
theorem category_theory.is_preconnected_induction {J : Type u₁} [category_theory.category J] [category_theory.is_preconnected J] (Z : J → Sort u_1) (h₁ : Π {j₁ j₂ : J}, (j₁ ⟶ j₂) → Z j₁ → Z j₂) (h₂ : Π {j₁ j₂ : J}, (j₁ ⟶ j₂) → Z j₂ → Z j₁) {j₀ : J} (x : Z j₀) (j : J) : nonempty (Z j)
theorem measure_theory.measure.add_haar_eq_zero_of_disjoint_translates {E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] {s : set E} (u : ℕ → E) (hu : metric.bounded (set.range u)) (hs : pairwise (disjoint on λ (n : ℕ), {u n} + s)) (h's : measurable_set s) : ⇑μ s = 0
theorem bounded_continuous_function.continuous_eval {α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] : continuous (λ (p : bounded_continuous_function α β × α), ⇑(p.fst) p.snd)
theorem eq_orthogonal_projection_of_mem_orthogonal {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K : submodule 𝕜 E} [complete_space ↥K] {u v : E} (hv : v ∈ K) (hvo : u - v ∈ Kᗮ) : ↑(⇑(orthogonal_projection K) u) = v
theorem linear_independent.map' {ι : Type u_1} {R : Type u_3} {M : Type u_5} {M' : Type u_6} {v : ι → M} [semiring R] [add_comm_monoid M] [add_comm_monoid M'] [module R M] [module R M'] (hv : linear_independent R v) (f : M →ₗ[R] M') (hf_inj : f.ker = ⊥) : linear_independent R (⇑f ∘ v)
theorem abs_inner_le_norm {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) : is_R_or_C.abs (has_inner.inner x y) ≤ ∥x∥ * ∥y∥
theorem submodule.supr_eq_to_submodule_range {ι : Type u_1} {S : Type u_3} {R : Type u_4} [decidable_eq ι] [add_monoid ι] [comm_semiring S] [semiring R] [algebra S R] (A : ι → submodule S R) [set_like.graded_monoid A] : (⨆ (i : ι), A i) = (direct_sum.coe_alg_hom A).range.to_submodule
theorem measure_theory.outer_measure.binfi_apply' {α : Type u_1} {ι : Type u_2} (I : set ι) (m : ι → measure_theory.outer_measure α) {s : set α} (hs : s.nonempty) : (⇑⨅ (i : ι) (H : i ∈ I), m i) s = ⨅ (t : ℕ → set α) (h2 : s ⊆ set.Union t), ∑' (n : ℕ), ⨅ (i : ι) (H : i ∈ I), ⇑(m i) (t n)
theorem norm_sub_pow_two {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x y : E} : ∥x - y∥ ^ 2 = ∥x∥ ^ 2 - 2 * ⇑is_R_or_C.re (has_inner.inner x y) + ∥y∥ ^ 2
theorem direct_sum.is_internal.is_compl {R : Type u} [semiring R] {ι : Type v} [dec_ι : decidable_eq ι] {M : Type u_1} [add_comm_monoid M] [module R M] {A : ι → submodule R M} {i j : ι} (hij : i ≠ j) (h : set.univ = {i, j}) (hi : direct_sum.is_internal A) : is_compl (A i) (A j)
theorem measure_theory.integral_eq_zero_of_mul_left_eq_neg {G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure G} {f : G → E} {g : G} [group G] [has_measurable_mul G] [μ.is_mul_left_invariant] (hf' : ∀ (x : G), f (g * x) = -f x) : ∫ (x : G), f x ∂μ = 0
theorem category_theory.limits.coequalizer.π_of_eq {C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} [category_theory.limits.has_coequalizer f g] (h : f = g) : category_theory.is_iso (category_theory.limits.coequalizer.π f g)
theorem interval_integral.fderiv_integral {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (ha : continuous_at f a) (hb : continuous_at f b) : fderiv ℝ (λ (p : ℝ × ℝ), ∫ (x : ℝ) in p.fst..p.snd, f x) (a, b) = (continuous_linear_map.snd ℝ ℝ ℝ).smul_right (f b) - (continuous_linear_map.fst ℝ ℝ ℝ).smul_right (f a)
theorem exp_neg_integrable_on_Ioi (a : ℝ) {b : ℝ} (h : 0 < b) : measure_theory.integrable_on (λ (x : ℝ), real.exp (-b * x)) (set.Ioi a) measure_theory.measure_space.volume
theorem polynomial.cyclotomic'_splits {K : Type u_1} [field K] (n : ℕ) : polynomial.splits (ring_hom.id K) (polynomial.cyclotomic' n K)
theorem category_theory.sieve.generate_of_contains_split_epi {C : Type u₁} [category_theory.category C] {X Y : C} {R : category_theory.presieve X} (f : Y ⟶ X) [category_theory.split_epi f] (hf : R f) : category_theory.sieve.generate R = ⊤
theorem set.Inter_eq_Inter_finset' {α : Type u_1} {ι' : Sort u_5} (s : ι' → set α) : (⋂ (i : ι'), s i) = ⋂ (t : finset (plift ι')) (i : plift ι') (H : i ∈ t), s i.down
theorem vector.map_id {α : Type u_1} {n : ℕ} (v : vector α n) : vector.map id v = v
theorem algebra.finite_presentation.mv_polynomial_of_finite_presentation {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (hfp : algebra.finite_presentation R A) (ι : Type u_3) [fintype ι] : algebra.finite_presentation R (mv_polynomial ι A)
theorem monotone.map_bdd_below {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} (Hf : monotone f) {s : set α} : bdd_below s → bdd_below (f '' s)
theorem measure_theory.measure.restrict_to_outer_measure_eq_to_outer_measure_restrict {α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {s : set α} (h : measurable_set s) : (μ.restrict s).to_outer_measure = ⇑(measure_theory.outer_measure.restrict s) μ.to_outer_measure
theorem set.finite_of_fintype {α : Type u} (s : set α) [h : fintype ↥s] : s.finite
theorem padic_val_rat.defn (p : ℕ) [p_prime : fact (nat.prime p)] {q : ℚ} {n d : ℤ} (hqz : q ≠ 0) (qdf : q = rat.mk n d) : padic_val_rat p q = ↑((multiplicity ↑p n).get _) - ↑((multiplicity ↑p d).get _)
theorem Top.presheaf.covering_of_presieve.first_obj_iso_pi_opens_π {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) (U : topological_space.opens ↥X) (R : category_theory.presieve U) (f : Σ (V : topological_space.opens ↥X), {f // R f}) : (Top.presheaf.covering_of_presieve.first_obj_iso_pi_opens F U R).hom ≫ category_theory.limits.pi.π (λ (i : Σ (V : topological_space.opens ↥X), {f // R f}), F.obj (opposite.op (Top.presheaf.covering_of_presieve U R i))) f = category_theory.limits.pi.π (λ (f : Σ (V : topological_space.opens ↥X), {f // R f}), F.obj (opposite.op f.fst)) f
theorem lower_central_series_length_eq_nilpotency_class {G : Type u_1} [group G] [hG : group.is_nilpotent G] : nat.find _ = group.nilpotency_class G
theorem is_local_min_on.has_fderiv_within_at_eq_zero {E : Type u} [normed_group E] [normed_space ℝ E] {f : E → ℝ} {a : E} {f' : E →L[ℝ] ℝ} {s : set E} (h : is_local_min_on f s a) (hf : has_fderiv_within_at f f' s a) {y : E} (hy : y ∈ pos_tangent_cone_at s a) (hy' : -y ∈ pos_tangent_cone_at s a) : ⇑f' y = 0
theorem norm_add_mul_self_real {F : Type u_3} [inner_product_space ℝ F] {x y : F} : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + 2 * has_inner.inner x y + ∥y∥ * ∥y∥
theorem intermediate_field.smul_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {y : L} : y ∈ S → ∀ {x : K}, x • y ∈ S
theorem category_theory.idempotents.to_karoubi_comp_karoubi_functor_category_embedding (J : Type u_1) (C : Type u_2) [category_theory.category J] [category_theory.category C] : category_theory.idempotents.to_karoubi (J ⥤ C) ⋙ category_theory.idempotents.karoubi_functor_category_embedding J C = (category_theory.whiskering_right J C (category_theory.idempotents.karoubi C)).obj (category_theory.idempotents.to_karoubi C)
theorem tactic.ring2.horner_expr.cseval_of_csexpr {α : Type u_1} [comm_semiring α] (t : tree α) (r : tactic.ring2.csring_expr) : (tactic.ring2.horner_expr.of_csexpr r).is_cs ∧ tactic.ring2.horner_expr.cseval t (tactic.ring2.horner_expr.of_csexpr r) = tactic.ring2.csring_expr.eval t r
theorem finset.weighted_vsub_vadd_affine_combination {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (w₁ w₂ : ι → k) (p : ι → P) : ⇑(s.weighted_vsub p) w₁ +ᵥ ⇑(s.affine_combination p) w₂ = ⇑(s.affine_combination p) (w₁ + w₂)
theorem affine_subspace.direction_affine_span_insert {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p1 p2 : P} (hp1 : p1 ∈ s) : (affine_span k (has_insert.insert p2 ↑s)).direction = submodule.span k {p2 -ᵥ p1} ⊔ s.direction
theorem filter.tendsto.neg_mul_at_bot {α : Type u} {β : Type v} [linear_ordered_field α] [topological_space α] [order_topology α] {l : filter β} {f g : β → α} {C : α} (hC : C < 0) (hf : filter.tendsto f l (nhds C)) (hg : filter.tendsto g l filter.at_bot) : filter.tendsto (λ (x : β), f x * g x) l filter.at_top
theorem category_theory.limits.initial_mono_class.of_is_terminal {C : Type u₁} [category_theory.category C] {I T : C} (hI : category_theory.limits.is_initial I) (hT : category_theory.limits.is_terminal T) (f : category_theory.mono (hI.to T)) : category_theory.limits.initial_mono_class C
theorem set.countable.preimage_cexp {s : set ℂ} : s.countable → (complex.exp ⁻¹' s).countable
theorem matrix.is_diag_iff_diagonal_diag {α : Type u_1} {n : Type u_4} [has_zero α] [decidable_eq n] (A : matrix n n α) : A.is_diag ↔ matrix.diagonal A.diag = A
theorem metric.tendsto_locally_uniformly_on_iff {α : Type u} {β : Type v} [pseudo_metric_space α] {ι : Type u_1} [topological_space β] {F : ι → β → α} {f : β → α} {p : filter ι} {s : set β} : tendsto_locally_uniformly_on F f p s ↔ ∀ (ε : ℝ), ε > 0 → ∀ (x : β), x ∈ s → (∃ (t : set β) (H : t ∈ nhds_within x s), ∀ᶠ (n : ι) in p, ∀ (y : β), y ∈ t → has_dist.dist (f y) (F n y) < ε)
theorem lp.norm_le_of_tendsto {α : Type u_1} {E : α → Type u_2} {p : ennreal} [Π (i : α), normed_group (E i)] {ι : Type u_3} {l : filter ι} [l.ne_bot] [fact (1 ≤ p)] {C : ℝ} {F : ι → ↥(lp E p)} (hCF : ∀ᶠ (k : ι) in l, ∥F k∥ ≤ C) {f : ↥(lp E p)} (hf : filter.tendsto (id (λ (i : ι), ⇑(F i))) l (nhds ⇑f)) : ∥f∥ ≤ C
theorem metric.Hausdorff_dist_image {α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {s t : set α} {Φ : α → β} (h : isometry Φ) : metric.Hausdorff_dist (Φ '' s) (Φ '' t) = metric.Hausdorff_dist s t
theorem add_monoid_hom.map_zero {M : Type u_3} {N : Type u_4} [add_zero_class M] [add_zero_class N] (f : M →+ N) : ⇑f 0 = 0
theorem cont_mdiff_neg_sphere {E : Type u_1} [inner_product_space ℝ E] {n : ℕ} [fact (finite_dimensional.finrank ℝ E = n + 1)] : cont_mdiff (model_with_corners_self ℝ (euclidean_space ℝ (fin n))) (model_with_corners_self ℝ (euclidean_space ℝ (fin n))) ⊤ (λ (x : ↥(metric.sphere 0 1)), -x)
theorem module.End.supr_generalized_eigenspace_eq_top {K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] [is_alg_closed K] [finite_dimensional K V] (f : module.End K V) : (⨆ (μ : K) (k : ℕ), ⇑(f.generalized_eigenspace μ) k) = ⊤
theorem is_submonoid.list_prod_mem {M : Type u_1} [monoid M] {s : set M} (hs : is_submonoid s) {l : list M} : (∀ (x : M), x ∈ l → x ∈ s) → l.prod ∈ s
theorem normed_group.tendsto_at_top {α : Type u_1} [nonempty α] [semilattice_sup α] {β : Type u_2} [semi_normed_group β] {f : α → β} {b : β} : filter.tendsto f filter.at_top (nhds b) ↔ ∀ (ε : ℝ), 0 < ε → (∃ (N : α), ∀ (n : α), N ≤ n → ∥f n - b∥ < ε)
theorem list.sum_reverse_noncomm {G : Type u_7} [add_group G] (L : list G) : L.reverse.sum = -(list.map (λ (x : G), -x) L).sum
theorem measure_theory.is_open_pos_measure_of_mul_left_invariant_of_regular {G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {μ : measure_theory.measure G} [group G] [topological_group G] [μ.is_mul_left_invariant] [μ.regular] (h₀ : μ ≠ 0) : μ.is_open_pos_measure
theorem iterated_deriv_succ {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {n : ℕ} {f : 𝕜 → F} : iterated_deriv (n + 1) f = deriv (iterated_deriv n f)
theorem tsum_supr_decode₂ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [add_comm_monoid α] [topological_space α] [t2_space α] [encodable γ] [complete_lattice β] (m : β → α) (m0 : m ⊥ = 0) (s : γ → β) : ∑' (i : ℕ), m (⨆ (b : γ) (H : b ∈ encodable.decode₂ γ i), s b) = ∑' (b : γ), m (s b)
theorem is_group_hom.map_one {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : f 1 = 1
theorem has_ftaylor_series_up_to_on_succ_iff_right {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {p : E → formal_multilinear_series 𝕜 E F} {n : ℕ} : has_ftaylor_series_up_to_on ↑(n + 1) f p s ↔ (∀ (x : E), x ∈ s → (p x 0).uncurry0 = f x) ∧ (∀ (x : E), x ∈ s → has_fderiv_within_at (λ (y : E), p y 0) (p x 1).curry_left s x) ∧ has_ftaylor_series_up_to_on ↑n (λ (x : E), ⇑(continuous_multilinear_curry_fin1 𝕜 E F) (p x 1)) (λ (x : E), (p x).shift) s
theorem filter.eq_top_of_ne_bot {α : Type u} [subsingleton α] (l : filter α) [l.ne_bot] : l = ⊤
theorem real.tendsto_mul_log_one_plus_div_at_top (t : ℝ) : filter.tendsto (λ (x : ℝ), x * real.log (1 + t / x)) filter.at_top (nhds t)
theorem continuous.snd {α : Type u} {β : Type v} {γ : Type u_1} [topological_space α] [topological_space β] [topological_space γ] {f : α → β × γ} (hf : continuous f) : continuous (λ (a : α), (f a).snd)
theorem nonneg_of_neg_nonpos {α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : -a ≤ 0 → 0 ≤ a
theorem subgroup.mem_closure_singleton {G : Type u_1} [group G] {x y : G} : y ∈ subgroup.closure {x} ↔ ∃ (n : ℤ), x ^ n = y
theorem setoid.eqv_gen_eq {α : Type u_1} (r : α → α → Prop) : eqv_gen.setoid r = has_Inf.Inf {s : setoid α | ∀ ⦃x y : α⦄, r x y → s.rel x y}
theorem add_subgroup.list_sum_mem {G : Type u_1} [add_group G] (K : add_subgroup G) {l : list G} : (∀ (x : G), x ∈ l → x ∈ K) → l.sum ∈ K
theorem controlled_closure_of_complete {G : Type u_1} [normed_group G] [complete_space G] {H : Type u_2} [normed_group H] {f : normed_group_hom G H} {K : add_subgroup H} {C ε : ℝ} (hC : 0 < C) (hε : 0 < ε) (hyp : f.surjective_on_with K C) : f.surjective_on_with K.topological_closure (C + ε)
theorem ufm_of_gcd_of_wf_dvd_monoid {α : Type u_1} [cancel_comm_monoid_with_zero α] [wf_dvd_monoid α] [gcd_monoid α] : unique_factorization_monoid α
theorem category_theory.essentially_small_iff (C : Type u) [category_theory.category C] : category_theory.essentially_small C ↔ small (category_theory.skeleton C) ∧ category_theory.locally_small C
theorem int.eq_of_mod_eq_of_nat_abs_sub_lt_nat_abs {a b c : ℤ} (h1 : a % b = c) (h2 : (a - c).nat_abs < b.nat_abs) : a = c
theorem power_series.order_X {R : Type u_1} [semiring R] [nontrivial R] : power_series.X.order = 1
theorem linear_equiv.det_symm_mul_det {M : Type u_2} [add_comm_group M] {A : Type u_1} [comm_ring A] [module A M] (f : M ≃ₗ[A] M) : ⇑linear_map.det ↑(f.symm) * ⇑linear_map.det ↑f = 1
theorem simplex_category.δ_comp_σ_self {n : ℕ} {i : fin (n + 1)} : simplex_category.δ (⇑fin.cast_succ i) ≫ simplex_category.σ i = 𝟙 (simplex_category.mk n)
theorem measure_theory.is_fundamental_domain.map_restrict_quotient {G : Type u_1} [group G] [measurable_space G] [topological_space G] [topological_group G] [borel_space G] {μ : measure_theory.measure G} {Γ : subgroup G} {𝓕 : set G} (h𝓕 : measure_theory.is_fundamental_domain ↥(Γ.opposite) 𝓕 μ) [encodable ↥Γ] [measurable_space (G ⧸ Γ)] [borel_space (G ⧸ Γ)] [t2_space (G ⧸ Γ)] [topological_space.second_countable_topology (G ⧸ Γ)] (K : topological_space.positive_compacts (G ⧸ Γ)) [Γ.normal] [μ.is_haar_measure] [μ.is_mul_right_invariant] (h𝓕_finite : ⇑μ 𝓕 < ⊤) : measure_theory.measure.map ⇑(quotient_group.mk' Γ) (μ.restrict 𝓕) = ⇑μ (𝓕 ∩ ⇑(quotient_group.mk' Γ) ⁻¹' ↑K) • measure_theory.measure.haar_measure K
theorem measure_theory.integral_indicator {α : Type u_1} {E : Type u_3} [measurable_space α] [normed_group E] {f : α → E} {s : set α} {μ : measure_theory.measure α} [complete_space E] [normed_space ℝ E] (hs : measurable_set s) : ∫ (x : α), s.indicator f x ∂μ = ∫ (x : α) in s, f x ∂μ
theorem category_theory.presieve.is_sheaf_iso {C : Type u₁} [category_theory.category C] {P : Cᵒᵖ ⥤ Type w} (J : category_theory.grothendieck_topology C) {P' : Cᵒᵖ ⥤ Type w} (i : P ≅ P') (h : category_theory.presieve.is_sheaf J P) : category_theory.presieve.is_sheaf J P'
theorem category_theory.arrow.square_to_iso_invert {T : Type u} [category_theory.category T] (i : category_theory.arrow T) {X Y : T} (p : X ≅ Y) (sq : i ⟶ category_theory.arrow.mk p.hom) : i.hom ≫ sq.right ≫ p.inv = sq.left
theorem cardinal.nsmul_lt_aleph_0_iff_of_ne_zero {n : ℕ} {a : cardinal} (h : n ≠ 0) : n • a < cardinal.aleph_0 ↔ a < cardinal.aleph_0
theorem filter.eventually_eq.eventually_eq_nhds {α : Type u} {β : Type v} [topological_space α] {f g : α → β} {a : α} (h : f =ᶠ[nhds a] g) : ∀ᶠ (y : α) in nhds a, f =ᶠ[nhds y] g
theorem abs_real_inner_le_norm {F : Type u_3} [inner_product_space ℝ F] (x y : F) : |has_inner.inner x y| ≤ ∥x∥ * ∥y∥
theorem Gromov_Hausdorff.isometry_optimal_GH_injl (X : Type u) (Y : Type v) [metric_space X] [compact_space X] [nonempty X] [metric_space Y] [compact_space Y] [nonempty Y] : isometry (Gromov_Hausdorff.optimal_GH_injl X Y)
theorem set.finset_sum_mem_finset_sum {α : Type u_2} {ι : Type u_5} [add_comm_monoid α] (t : finset ι) (f : ι → set α) (g : ι → α) (hg : ∀ (i : ι), i ∈ t → g i ∈ f i) : t.sum (λ (i : ι), g i) ∈ t.sum (λ (i : ι), f i)
theorem lt_neg_add_of_add_lt {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a + b < c → b < -a + c
theorem complex.norm_eq_norm_of_is_max_on_of_ball_subset {E : Type u} [normed_group E] [normed_space ℂ E] {F : Type v} [normed_group F] [normed_space ℂ F] {f : E → F} {s : set E} {z w : E} (hd : diff_cont_on_cl ℂ f s) (hz : is_max_on (has_norm.norm ∘ f) s z) (hsub : metric.ball z (has_dist.dist w z) ⊆ s) : ∥f w∥ = ∥f z∥
theorem linear_independent.restrict_scalars {ι : Type u_1} {R : Type u_3} {K : Type u_4} {M : Type u_5} {v : ι → M} [semiring R] [add_comm_monoid M] [module R M] [semiring K] [smul_with_zero R K] [module K M] [is_scalar_tower R K M] (hinj : function.injective (λ (r : R), r • 1)) (li : linear_independent K v) : linear_independent R v
theorem star_convex_iff_pointwise_add_subset {𝕜 : Type u_1} {E : Type u_2} [ordered_semiring 𝕜] [add_comm_monoid E] [has_scalar 𝕜 E] {x : E} {s : set E} : star_convex 𝕜 x s ↔ ∀ ⦃a b : 𝕜⦄, 0 ≤ a → 0 ≤ b → a + b = 1 → a • {x} + b • s ⊆ s
theorem basic_smooth_vector_bundle_core.smooth_const_section {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] (Z : basic_smooth_vector_bundle_core I M E') (v : E') (h : ∀ (i j : ↥(charted_space.atlas H M)) (x : M), x ∈ i.val.to_local_equiv.source ∩ j.val.to_local_equiv.source → ⇑(Z.coord_change i j (⇑(i.val) x)) v = v) : smooth I (I.prod (model_with_corners_self 𝕜 E')) (show M → Z.to_topological_vector_bundle_core.total_space, from λ (x : M), ⟨x, v⟩)
theorem category_theory.functor.final.cofinal_of_colimit_comp_coyoneda_iso_punit {C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ⥤ D) [F.final] (I : Π (d : D), category_theory.limits.colimit (F ⋙ category_theory.coyoneda.obj (opposite.op d)) ≅ punit) : F.final
theorem conformal_at_iff' {E : Type u_1} {F : Type u_2} [inner_product_space ℝ E] [inner_product_space ℝ F] {f : E → F} {x : E} : conformal_at f x ↔ ∃ (c : ℝ), 0 < c ∧ ∀ (u v : E), has_inner.inner (⇑(fderiv ℝ f x) u) (⇑(fderiv ℝ f x) v) = c * has_inner.inner u v
theorem measure_theory.integral_eq_of_has_deriv_within_at_off_countable_of_le {E : Type u} [normed_group E] [normed_space ℝ E] [complete_space E] (f f' : ℝ → E) {a b : ℝ} (hle : a ≤ b) {s : set ℝ} (hs : s.countable) (Hc : continuous_on f (set.Icc a b)) (Hd : ∀ (x : ℝ), x ∈ set.Ioo a b  s → has_deriv_at f (f' x) x) (Hi : interval_integrable f' measure_theory.measure_space.volume a b) : ∫ (x : ℝ) in a..b, f' x = f b - f a
theorem measure_theory.lintegral_prod_symm {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] (f : α × β → ennreal) (hf : ae_measurable f (μ.prod ν)) : ∫⁻ (z : α × β), f z ∂μ.prod ν = ∫⁻ (y : β), ∫⁻ (x : α), f (x, y) ∂μ ∂ν
theorem inner_product_geometry.angle_eq_pi_iff {V : Type u_1} [inner_product_space ℝ V] {x y : V} : inner_product_geometry.angle x y = real.pi ↔ x ≠ 0 ∧ ∃ (r : ℝ), r < 0 ∧ y = r • x
theorem category_theory.monad.forget_creates_colimits.commuting {C : Type u₁} [category_theory.category C] {T : category_theory.monad C} {J : Type u} [category_theory.category J] {D : J ⥤ T.algebra} (c : category_theory.limits.cocone (D ⋙ T.forget)) (t : category_theory.limits.is_colimit c) [category_theory.limits.preserves_colimit (D ⋙ T.forget) ↑T] (j : J) : ↑T.map (c.ι.app j) ≫ category_theory.monad.forget_creates_colimits.lambda c t = (D.obj j).a ≫ c.ι.app j
theorem is_localization.exists_integer_multiple' {R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] (a : S) : ∃ (b : ↥M), is_localization.is_integer R (a * ⇑(algebra_map R S) ↑b)
theorem btw_cyclic {α : Type u_1} [circular_preorder α] {a b c : α} : has_btw.btw a b c ↔ has_btw.btw c a b
theorem add_subgroup.surjective_normed_mk {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) : function.surjective ⇑(S.normed_mk)
theorem dihedral_group.order_of_r_one {n : ℕ} : order_of (dihedral_group.r 1) = n
theorem function.surjective.nontrivial {α : Type u_1} {β : Type u_2} [nontrivial β] {f : α → β} (hf : function.surjective f) : nontrivial α
theorem matrix.update_row_eq_transvection {n : Type u_1} {R : Type u₂} [decidable_eq n] [comm_ring R] (i j : n) [fintype n] (c : R) : 1.update_row i (1 i + c • 1 j) = matrix.transvection i j c
theorem exists_dvd_and_dvd_of_dvd_mul {α : Type u_1} [cancel_comm_monoid_with_zero α] [gcd_monoid α] {m n k : α} (H : k ∣ m * n) : ∃ (d₁ : α) (hd₁ : d₁ ∣ m) (d₂ : α) (hd₂ : d₂ ∣ n), k = d₁ * d₂
theorem dense.closure {α : Type u} [topological_space α] {s : set α} : dense s → dense (closure s)
theorem ordinal.cof_lsub_def_nonempty (o : ordinal) : {a : cardinal | ∃ {ι : Type u} (f : ι → ordinal), ordinal.lsub f = o ∧ cardinal.mk ι = a}.nonempty
theorem finset.card_powerset {α : Type u_1} (s : finset α) : s.powerset.card = 2 ^ s.card
theorem has_strict_fderiv_at_exp_of_mem_ball {𝕂 : Type u_1} {𝔸 : Type u_2} [nondiscrete_normed_field 𝕂] [normed_comm_ring 𝔸] [normed_algebra 𝕂 𝔸] [complete_space 𝔸] [char_zero 𝕂] {x : 𝔸} (hx : x ∈ emetric.ball 0 (exp_series 𝕂 𝔸).radius) : has_strict_fderiv_at (exp 𝕂) (exp 𝕂 x • 1) x
theorem category_theory.limits.kernel.ι_of_mono {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ⟶ Y) [category_theory.limits.has_zero_object C] [category_theory.limits.has_kernel f] [category_theory.mono f] : category_theory.limits.kernel.ι f = 0
theorem is_unit.dvd {α : Type u_1} [monoid α] {a u : α} (hu : is_unit u) : u ∣ a
theorem measurable_limsup' {α : Type u_1} {δ : Type u_5} [topological_space α] [measurable_space α] [borel_space α] [measurable_space δ] [complete_linear_order α] [order_topology α] [topological_space.second_countable_topology α] {ι : Type u_2} {ι' : Type u_3} {f : ι → δ → α} {u : filter ι} (hf : ∀ (i : ι), measurable (f i)) {p : ι' → Prop} {s : ι' → set ι} (hu : u.has_countable_basis p s) (hs : ∀ (i : ι'), (s i).countable) : measurable (λ (x : δ), u.limsup (λ (i : ι), f i x))
theorem is_cyclotomic_extension.number_field (S : set ℕ+) (K : Type w) (L : Type z) [field K] [field L] [algebra K L] [h : number_field K] [fintype ↥S] [is_cyclotomic_extension S K L] : number_field L
theorem subalgebra.mul_to_submodule {R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_semiring A] [algebra R A] (S T : subalgebra R A) : S.to_submodule * T.to_submodule = (S ⊔ T).to_submodule
theorem eq_zero_of_same_ray_self_neg {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x : M} [no_zero_smul_divisors R M] (h : same_ray R x (-x)) : x = 0
theorem measure_theory.measure.eq_rn_deriv {α : Type u_1} {m : measurable_space α} {μ ν : measure_theory.measure α} [measure_theory.sigma_finite ν] {s : measure_theory.measure α} {f : α → ennreal} (hf : measurable f) (hs : s.mutually_singular ν) (hadd : μ = s + ν.with_density f) : f =ᵐ[ν] μ.rn_deriv ν
theorem fin.antitone_iff_succ_le {n : ℕ} {α : Type u_1} [preorder α] {f : fin (n + 1) → α} : antitone f ↔ ∀ (i : fin n), f i.succ ≤ f (⇑fin.cast_succ i)
theorem is_square_zero (M : Type u_1) [monoid_with_zero M] : is_square 0
theorem basis.finite_of_vector_space_index_of_dim_lt_aleph_0 {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (h : module.rank K V < cardinal.aleph_0) : (basis.of_vector_space_index K V).finite
theorem cont_mdiff_within_at_iff {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M → M'} {s : set M} {x : M} {n : with_top ℕ} : cont_mdiff_within_at I I' n f s x ↔ continuous_within_at f s x ∧ cont_diff_within_at 𝕜 n (⇑(ext_chart_at I' (f x)) ∘ f ∘ ⇑((ext_chart_at I x).symm)) ((ext_chart_at I x).target ∩ ⇑((ext_chart_at I x).symm) ⁻¹' (s ∩ f ⁻¹' (ext_chart_at I' (f x)).source)) (⇑(ext_chart_at I x) x)
theorem inner_product_space.is_self_adjoint.invariant_orthogonal_eigenspace {𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] {T : E →ₗ[𝕜] E} (hT : inner_product_space.is_self_adjoint T) (μ : 𝕜) (v : E) (hv : v ∈ (module.End.eigenspace T μ)ᗮ) : ⇑T v ∈ (module.End.eigenspace T μ)ᗮ
theorem is_regular.pow_iff {R : Type u_1} {a : R} [monoid R] {n : ℕ} (n0 : 0 < n) : is_regular (a ^ n) ↔ is_regular a
theorem category_theory.is_subterminal_of_mono_terminal_from {C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] [category_theory.mono (category_theory.limits.terminal.from A)] : category_theory.is_subterminal A
theorem Top.stalk_to_fiber_surjective {X : Top} {T : ↥X → Type v} (P : Top.local_predicate T) (x : ↥X) (w : ∀ (t : T x), ∃ (U : topological_space.open_nhds x) (f : Π (y : ↥(U.val)), T ↑y) (h : P.to_prelocal_predicate.pred f), f ⟨x, _⟩ = t) : function.surjective (Top.stalk_to_fiber P x)
theorem finset.induction_on_pi_of_choice {ι : Type u_1} {α : ι → Type u_2} [fintype ι] [decidable_eq ι] [Π (i : ι), decidable_eq (α i)] (r : Π (i : ι), α i → finset (α i) → Prop) (H_ex : ∀ (i : ι) (s : finset (α i)), s.nonempty → (∃ (x : α i) (H : x ∈ s), r i x (s.erase x))) {p : (Π (i : ι), finset (α i)) → Prop} (f : Π (i : ι), finset (α i)) (h0 : p (λ (_x : ι), ∅)) (step : ∀ (g : Π (i : ι), finset (α i)) (i : ι) (x : α i), r i x (g i) → p g → p (function.update g i (has_insert.insert x (g i)))) : p f
theorem is_local_max_on.has_fderiv_within_at_nonpos {E : Type u} [normed_group E] [normed_space ℝ E] {f : E → ℝ} {a : E} {f' : E →L[ℝ] ℝ} {s : set E} (h : is_local_max_on f s a) (hf : has_fderiv_within_at f f' s a) {y : E} (hy : y ∈ pos_tangent_cone_at s a) : ⇑f' y ≤ 0
theorem category_theory.is_connected.of_any_functor_const_on_obj {J : Type u₁} [category_theory.category J] [nonempty J] (h : ∀ {α : Type u₁} (F : J ⥤ category_theory.discrete α) (j j' : J), F.obj j = F.obj j') : category_theory.is_connected J
theorem category_theory.is_iso_of_reflects_iso {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {A B : C} (f : A ⟶ B) (F : C ⥤ D) [category_theory.is_iso (F.map f)] [category_theory.reflects_isomorphisms F] : category_theory.is_iso f
theorem affine_independent.of_comp {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} {V₂ : Type u_5} {P₂ : Type u_6} [add_comm_group V₂] [module k V₂] [add_torsor V₂ P₂] {p : ι → P} (f : P →ᵃ[k] P₂) (hai : affine_independent k (⇑f ∘ p)) : affine_independent k p
theorem convolution_flip {𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G → E} {g : G → E'} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 F] (L : E →L[𝕜] E' →L[𝕜] F) [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ F] [complete_space F] [add_comm_group G] [topological_space G] [topological_add_group G] [borel_space G] [μ.is_add_left_invariant] [μ.is_neg_invariant] : convolution g f L.flip μ = convolution f g L μ
theorem subsemiring.closure_le {R : Type u} [non_assoc_semiring R] {s : set R} {t : subsemiring R} : subsemiring.closure s ≤ t ↔ s ⊆ ↑t
theorem geometric_hahn_banach_open {E : Type u_2} [normed_group E] [normed_space ℝ E] {s t : set E} (hs₁ : convex ℝ s) (hs₂ : is_open s) (ht : convex ℝ t) (disj : disjoint s t) : ∃ (f : E →L[ℝ] ℝ) (u : ℝ), (∀ (a : E), a ∈ s → ⇑f a < u) ∧ ∀ (b : E), b ∈ t → u ≤ ⇑f b
theorem eventually_singleton_add_smul_subset {𝕜 : Type u_1} {E : Type u_2} [normed_field 𝕜] [semi_normed_group E] [normed_space 𝕜 E] {x : E} {s : set E} (hs : metric.bounded s) {u : set E} (hu : u ∈ nhds x) : ∀ᶠ (r : 𝕜) in nhds 0, {x} + r • s ⊆ u
theorem normed_ring.inverse_add_nth_order {R : Type u_1} [normed_ring R] [complete_space R] (x : Rˣ) (n : ℕ) : ∀ᶠ (t : R) in nhds 0, ring.inverse (↑x + t) = (finset.range n).sum (λ (i : ℕ), (-↑x⁻¹ * t) ^ i) * ↑x⁻¹ + (-↑x⁻¹ * t) ^ n * ring.inverse (↑x + t)
theorem dense.diff_finset {α : Type u} [topological_space α] [t1_space α] [∀ (x : α), (nhds_within x {x}ᶜ).ne_bot] {s : set α} (hs : dense s) (t : finset α) : dense (s  ↑t)
theorem linear_map.det_zero {𝕜 : Type u_1} [field 𝕜] {M : Type u_2} [add_comm_group M] [module 𝕜 M] : ⇑linear_map.det 0 = 0 ^ finite_dimensional.finrank 𝕜 M
theorem measure_theory.outer_measure.of_function_union_of_top_of_nonempty_inter {α : Type u_1} {m : set α → ennreal} {m_empty : m ∅ = 0} {s t : set α} (h : ∀ (u : set α), (s ∩ u).nonempty → (t ∩ u).nonempty → m u = ⊤) : ⇑(measure_theory.outer_measure.of_function m m_empty) (s ∪ t) = ⇑(measure_theory.outer_measure.of_function m m_empty) s + ⇑(measure_theory.outer_measure.of_function m m_empty) t
theorem category_theory.limits.has_initial_of_has_initial_of_preserves_colimit {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (G : C ⥤ D) [category_theory.limits.has_initial C] [category_theory.limits.preserves_colimit (category_theory.functor.empty C) G] : category_theory.limits.has_initial D
theorem add_con.mk'_surjective {M : Type u_1} [add_zero_class M] {c : add_con M} : function.surjective ⇑(c.mk')
theorem category_theory.abelian.functor.right_derived_zero_to_self_natural {C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (F : C ⥤ D) [category_theory.abelian C] [category_theory.abelian D] [F.additive] [category_theory.enough_injectives C] {X Y : C} (f : X ⟶ Y) (P : category_theory.InjectiveResolution X) (Q : category_theory.InjectiveResolution Y) : F.map f ≫ category_theory.abelian.functor.right_derived_zero_to_self_app_inv F Q = category_theory.abelian.functor.right_derived_zero_to_self_app_inv F P ≫ (F.right_derived 0).map f
theorem is_antichain.max_minimals {α : Type u_1} {r : α → α → Prop} {s t : set α} (ht : is_antichain r t) (h : minimals r s ⊆ t) (hs : ∀ ⦃a : α⦄, a ∈ t → (∃ (b : α) (H : b ∈ minimals r s), r a b)) : minimals r s = t
theorem measure_theory.integral_condexp_L2_eq {α : Type u_1} {E' : Type u_5} {𝕜 : Type u_11} [is_R_or_C 𝕜] [inner_product_space 𝕜 E'] [complete_space E'] [normed_space ℝ E'] {m m0 : measurable_space α} {μ : measure_theory.measure α} {s : set α} (hm : m ≤ m0) (f : ↥(measure_theory.Lp E' 2 μ)) (hs : measurable_set s) (hμs : ⇑μ s ≠ ⊤) : ∫ (x : α) in s, ⇑(⇑(measure_theory.condexp_L2 𝕜 hm) f) x ∂μ = ∫ (x : α) in s, ⇑f x ∂μ
theorem interval_integral.integral_comp_mul_deriv' {a b : ℝ} {f f' g : ℝ → ℝ} (h : ∀ (x : ℝ), x ∈ set.interval a b → has_deriv_at f (f' x) x) (h' : continuous_on f' (set.interval a b)) (hg : continuous_on g (f '' set.interval a b)) : ∫ (x : ℝ) in a..b, (g ∘ f) x * f' x = ∫ (x : ℝ) in f a..f b, g x
theorem group.normal_closure.is_subgroup {G : Type u_1} [group G] (s : set G) : is_subgroup (group.normal_closure s)
theorem function.is_fixed_pt.map {α : Type u} {β : Type v} {fa : α → α} {fb : β → β} {x : α} (hx : function.is_fixed_pt fa x) {g : α → β} (h : function.semiconj g fa fb) : function.is_fixed_pt fb (g x)
theorem iterated_deriv_eq_iterate {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {n : ℕ} {f : 𝕜 → F} : iterated_deriv n f = deriv^[n] f
theorem nat.cast_le_pow_div_sub {K : Type u_1} [linear_ordered_field K] {a : K} (H : 1 < a) (n : ℕ) : ↑n ≤ a ^ n / (a - 1)
theorem finset.image₂_image_left_anticomm {α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} [decidable_eq α'] [decidable_eq γ] [decidable_eq δ] {s : finset α} {t : finset β} {f : α' → β → γ} {g : α → α'} {f' : β → α → δ} {g' : δ → γ} (h_left_anticomm : ∀ (a : α) (b : β), f (g a) b = g' (f' b a)) : finset.image₂ f (finset.image g s) t = finset.image g' (finset.image₂ f' t s)
theorem category_theory.subobject.mk_eq_mk_of_comm {C : Type u₁} [category_theory.category C] {B A₁ A₂ : C} (f : A₁ ⟶ B) (g : A₂ ⟶ B) [category_theory.mono f] [category_theory.mono g] (i : A₁ ≅ A₂) (w : i.hom ≫ g = f) : category_theory.subobject.mk f = category_theory.subobject.mk g
theorem set.pairwise_disjoint.set_independent {α : Type u_1} [order.frame α] {s : set α} : s.pairwise_disjoint id → complete_lattice.set_independent s
theorem euclidean_geometry.exists_circumcenter_eq_of_cospherical {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {ps : set P} {n : ℕ} [finite_dimensional ℝ V] (hd : finite_dimensional.finrank ℝ V = n) (hc : euclidean_geometry.cospherical ps) : ∃ (c : P), ∀ (sx : affine.simplex ℝ P n), set.range sx.points ⊆ ps → sx.circumcenter = c
theorem strict_mono_on.continuous_at_left_of_image_mem_nhds_within {α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_on f s) (hs : s ∈ nhds_within a (set.Iic a)) (hfs : f '' s ∈ nhds_within (f a) (set.Iic (f a))) : continuous_within_at f (set.Iic a) a
theorem eventually_closure_subset_of_is_compact_absorbing_of_is_open_of_omega_limit_subset {τ : Type u_1} {α : Type u_2} {β : Type u_3} [topological_space β] (f : filter τ) (ϕ : τ → α → β) (s : set α) [t2_space β] {c : set β} (hc₁ : is_compact c) (hc₂ : ∀ᶠ (t : τ) in f, set.maps_to (ϕ t) s c) {n : set β} (hn₁ : is_open n) (hn₂ : omega_limit f ϕ s ⊆ n) : ∃ (u : set τ) (H : u ∈ f), closure (set.image2 ϕ u s) ⊆ n
theorem uv.mem_compression {α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] {s : finset α} {u v a : α} : a ∈ uv.compression u v s ↔ a ∈ s ∧ uv.compress u v a ∈ s ∨ a ∉ s ∧ ∃ (b : α) (H : b ∈ s), uv.compress u v b = a
theorem continuous_linear_map.norm_id_of_nontrivial_seminorm {𝕜 : Type u_1} {E : Type u_4} [semi_normed_group E] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] (h : ∃ (x : E), ∥x∥ ≠ 0) : ∥continuous_linear_map.id 𝕜 E∥ = 1
theorem is_local_min_on.fderiv_within_eq_zero {E : Type u} [normed_group E] [normed_space ℝ E] {f : E → ℝ} {a : E} {s : set E} (h : is_local_min_on f s a) {y : E} (hy : y ∈ pos_tangent_cone_at s a) (hy' : -y ∈ pos_tangent_cone_at s a) : ⇑(fderiv_within ℝ f s a) y = 0
theorem mvqpf.cofix.bisim' {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} {β : Type u_1} (Q : β → Prop) (u v : β → mvqpf.cofix F α) (h : ∀ (x : β), Q x → (∃ (a : (mvqpf.P F).A) (f' : ((mvqpf.P F).drop.B a).arrow α) (f₀ f₁ : (mvqpf.P F).last.B a → mvqpf.cofix F α), (u x).dest = mvqpf.abs ⟨a, (mvqpf.P F).append_contents f' f₀⟩ ∧ (v x).dest = mvqpf.abs ⟨a, (mvqpf.P F).append_contents f' f₁⟩ ∧ ∀ (i : (mvqpf.P F).last.B a), ∃ (x' : β), Q x' ∧ f₀ i = u x' ∧ f₁ i = v x')) (x : β) : Q x → u x = v x
theorem linear_independent_finset_map_embedding_subtype {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (s : set M) (li : linear_independent R coe) (t : finset ↥s) : linear_independent R coe
theorem finset.affine_combination_vsub {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (w₁ w₂ : ι → k) (p : ι → P) : ⇑(s.affine_combination p) w₁ -ᵥ ⇑(s.affine_combination p) w₂ = ⇑(s.weighted_vsub p) (w₁ - w₂)
theorem category_theory.strong_epi_of_strong_epi {C : Type u} [category_theory.category C] {P Q R : C} (f : P ⟶ Q) (g : Q ⟶ R) [category_theory.strong_epi (f ≫ g)] : category_theory.strong_epi g
theorem continuous_at_cpow {p : ℂ × ℂ} (hp_fst : 0 < p.fst.re ∨ p.fst.im ≠ 0) : continuous_at (λ (x : ℂ × ℂ), x.fst ^ x.snd) p
theorem closed_ball_pi' {β : Type v} {π : β → Type u_1} [fintype β] [Π (b : β), pseudo_metric_space (π b)] [nonempty β] (x : Π (b : β), π b) (r : ℝ) : metric.closed_ball x r = set.univ.pi (λ (b : β), metric.closed_ball (x b) r)
theorem real.cos_pi_div_three  : real.cos (real.pi / 3) = 1 / 2
theorem fin.univ_succ_above (n : ℕ) (p : fin (n + 1)) : finset.univ = finset.cons p (finset.map p.succ_above.to_embedding finset.univ) _
theorem inner_product_geometry.conformal_at.preserves_angle {E : Type u_1} {F : Type u_2} [inner_product_space ℝ E] [inner_product_space ℝ F] {f : E → F} {x : E} {f' : E →L[ℝ] F} (h : has_fderiv_at f f' x) (H : conformal_at f x) (u v : E) : inner_product_geometry.angle (⇑f' u) (⇑f' v) = inner_product_geometry.angle u v
theorem power_series.exp_mul_exp_eq_exp_add {A : Type u_1} [comm_ring A] [algebra ℚ A] (a b : A) : ⇑(power_series.rescale a) (power_series.exp A) * ⇑(power_series.rescale b) (power_series.exp A) = ⇑(power_series.rescale (a + b)) (power_series.exp A)
theorem measure_theory.measure.ext_iff_of_bUnion_eq_univ {α : Type u_1} {ι : Type u_5} {m0 : measurable_space α} {μ ν : measure_theory.measure α} {S : set ι} {s : ι → set α} (hc : S.countable) (hs : (⋃ (i : ι) (H : i ∈ S), s i) = set.univ) : μ = ν ↔ ∀ (i : ι), i ∈ S → μ.restrict (s i) = ν.restrict (s i)
theorem measure_theory.Lp_meas.ae_fin_strongly_measurable' {α : Type u_1} {F : Type u_6} {𝕜 : Type u_11} {p : ennreal} [is_R_or_C 𝕜] [normed_group F] [normed_space 𝕜 F] {m m0 : measurable_space α} {μ : measure_theory.measure α} (hm : m ≤ m0) (f : ↥(measure_theory.Lp_meas F 𝕜 m p μ)) (hp_ne_zero : p ≠ 0) (hp_ne_top : p ≠ ⊤) : ∃ (g : α → F), measure_theory.fin_strongly_measurable g (μ.trim hm) ∧ ⇑f =ᵐ[μ] g
theorem nat.pow_two_sub_pow_two (a b : ℕ) : a ^ 2 - b ^ 2 = (a + b) * (a - b)
theorem pequiv.single_mul_single_right {k : Type u_1} {l : Type u_2} {m : Type u_3} {n : Type u_4} {α : Type v} [fintype n] [fintype k] [decidable_eq n] [decidable_eq k] [decidable_eq m] [semiring α] (a : m) (b : n) (c : k) (M : matrix k l α) : (pequiv.single a b).to_matrix.mul ((pequiv.single b c).to_matrix.mul M) = (pequiv.single a c).to_matrix.mul M
theorem exists_subset_Union_ball_radius_pos_lt {α : Type u} {ι : Type v} [metric_space α] [proper_space α] {c : ι → α} {s : set α} {r : ι → ℝ} (hr : ∀ (i : ι), 0 < r i) (hs : is_closed s) (uf : ∀ (x : α), x ∈ s → {i : ι | x ∈ metric.ball (c i) (r i)}.finite) (us : s ⊆ ⋃ (i : ι), metric.ball (c i) (r i)) : ∃ (r' : ι → ℝ), (s ⊆ ⋃ (i : ι), metric.ball (c i) (r' i)) ∧ ∀ (i : ι), r' i ∈ set.Ioo 0 (r i)
theorem is_primitive_root.minpoly_dvd_X_pow_sub_one {n : ℕ} {K : Type u_8} [field K] {μ : K} (h : is_primitive_root μ n) [char_zero K] : minpoly ℤ μ ∣ polynomial.X ^ n - 1
theorem circle_deg1_lift.semiconj_of_group_action_of_forall_translation_number_eq {G : Type u_1} [group G] (f₁ f₂ : G →* circle_deg1_lift) (h : ∀ (g : G), (⇑f₁ g).translation_number = (⇑f₂ g).translation_number) : ∃ (F : circle_deg1_lift), ∀ (g : G), function.semiconj ⇑F ⇑(⇑f₁ g) ⇑(⇑f₂ g)
theorem finsum_mem_finset_product' {α : Type u_1} {β : Type u_2} {M : Type u_5} [add_comm_monoid M] [decidable_eq α] [decidable_eq β] (s : finset (α × β)) (f : α × β → M) : finsum (λ (ab : α × β), finsum (λ (h : ab ∈ s), f ab)) = finsum (λ (a : α), finsum (λ (b : β), finsum (λ (h : b ∈ finset.image prod.snd (finset.filter (λ (ab : α × β), ab.fst = a) s)), f (a, b))))
theorem add_subgroup.le_normalizer_map {G : Type u_1} [add_group G] {H : add_subgroup G} {N : Type u_3} [add_group N] (f : G →+ N) : add_subgroup.map f H.normalizer ≤ (add_subgroup.map f H).normalizer
theorem function.injective.comap_cofinite_eq {α : Type u_2} {β : Type u_3} {f : α → β} (hf : function.injective f) : filter.comap f filter.cofinite = filter.cofinite
theorem fintype.prod_bijective {α : Type u_1} {β : Type u_2} {M : Type u_3} [fintype α] [fintype β] [comm_monoid M] (e : α → β) (he : function.bijective e) (f : α → M) (g : β → M) (h : ∀ (x : α), f x = g (e x)) : finset.univ.prod (λ (x : α), f x) = finset.univ.prod (λ (x : β), g x)
theorem complex.alg_hom_ext {A : Type u_3} [semiring A] [algebra ℝ A] ⦃f g : ℂ →ₐ[ℝ] A⦄ (h : ⇑f complex.I = ⇑g complex.I) : f = g
theorem affine_map.to_fun_eq_coe {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] (f : P1 →ᵃ[k] P2) : f.to_fun = ⇑f
theorem dist_le_of_le_geometric_of_tendsto₀ {α : Type u_1} [pseudo_metric_space α] (r C : ℝ) (hr : r < 1) {f : ℕ → α} (hu : ∀ (n : ℕ), has_dist.dist (f n) (f (n + 1)) ≤ C * r ^ n) {a : α} (ha : filter.tendsto f filter.at_top (nhds a)) : has_dist.dist (f 0) a ≤ C / (1 - r)
theorem category_theory.cover_dense.compatible_preserving {C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {G : C ⥤ D} (H : category_theory.cover_dense K G) [category_theory.full G] [category_theory.faithful G] : category_theory.compatible_preserving K G
theorem matrix.left_inv_eq_left_inv {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {A B C : matrix n n α} (h : B.mul A = 1) (g : C.mul A = 1) : B = C
theorem multilinear_map.restr_norm_le {𝕜 : Type u} {G : Type wG} {G' : Type wG'} [nondiscrete_normed_field 𝕜] [normed_group G] [normed_space 𝕜 G] [normed_group G'] [normed_space 𝕜 G'] {k n : ℕ} (f : multilinear_map 𝕜 (λ (i : fin n), G) G') (s : finset (fin n)) (hk : s.card = k) (z : G) {C : ℝ} (H : ∀ (m : fin n → G), ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : fin n), ∥m i∥)) (v : fin k → G) : ∥⇑(f.restr s hk z) v∥ ≤ C * ∥z∥ ^ (n - k) * finset.univ.prod (λ (i : fin k), ∥v i∥)
theorem add_monoid_algebra.non_unital_alg_hom_ext (k : Type u₁) {G : Type u₂} [semiring k] [has_add G] {A : Type u₃} [non_unital_non_assoc_semiring A] [distrib_mul_action k A] {φ₁ φ₂ : add_monoid_algebra k G →ₙₐ[k] A} (h : ∀ (x : G), ⇑φ₁ (finsupp.single x 1) = ⇑φ₂ (finsupp.single x 1)) : φ₁ = φ₂
theorem maps_to_tangent_cone_pi {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {ι : Type u_2} [decidable_eq ι] {E : ι → Type u_3} [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] {s : Π (i : ι), set (E i)} {x : Π (i : ι), E i} {i : ι} (hi : ∀ (j : ι), j ≠ i → x j ∈ closure (s j)) : set.maps_to ⇑(linear_map.single i) (tangent_cone_at 𝕜 (s i) (x i)) (tangent_cone_at 𝕜 (set.univ.pi s) x)
theorem module.punctured_nhds_ne_bot (R : Type u_1) (M : Type u_2) [ring R] [topological_space R] [topological_space M] [add_comm_group M] [has_continuous_add M] [module R M] [has_continuous_smul R M] [nontrivial M] [(nhds_within 0 {0}ᶜ).ne_bot] [no_zero_smul_divisors R M] (x : M) : (nhds_within x {x}ᶜ).ne_bot
theorem asymptotics.is_o.of_norm_left {α : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : α → F} {f' : α → E'} {l : filter α} : (λ (x : α), ∥f' x∥) =o[l] g → f' =o[l] g
theorem orthogonal_family.linear_isometry_equiv_symm_apply_single {ι : Type u_1} {𝕜 : Type u_2} [is_R_or_C 𝕜] {E : Type u_3} [inner_product_space 𝕜 E] [cplt : complete_space E] {G : ι → Type u_4} [Π (i : ι), inner_product_space 𝕜 (G i)] {V : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : orthogonal_family 𝕜 V) [∀ (i : ι), complete_space (G i)] (hV' : (⨆ (i : ι), (V i).to_linear_map.range).topological_closure = ⊤) {i : ι} (x : G i) : ⇑((hV.linear_isometry_equiv hV').symm) (lp.single 2 i x) = ⇑(V i) x
theorem basis.mk_coord_apply_ne {ι : Type u_1} {R : Type u_3} {M : Type u_5} {v : ι → M} [ring R] [add_comm_group M] [module R M] {hli : linear_independent R v} {hsp : submodule.span R (set.range v) = ⊤} {i j : ι} (h : j ≠ i) : ⇑((basis.mk hli hsp).coord i) (v j) = 0
theorem continuous_map.homotopy.eval_at_eq {X Y : Top} {f g : C(↥X, ↥Y)} (H : f.homotopy g) (x : ↥X) : ⟦H.eval_at x⟧ = continuous_map.homotopy.hcast _ ≫ (fundamental_groupoid.fundamental_groupoid_functor.map H.ulift_map).map (continuous_map.homotopy.prod_to_prod_Top_I unit_interval.uhpath01 (𝟙 x)) ≫ continuous_map.homotopy.hcast _
theorem add_submonoid.closure_eq {M : Type u_1} [add_zero_class M] (S : add_submonoid M) : add_submonoid.closure ↑S = S
theorem algebra.discr_eq_det_embeddings_matrix_reindex_pow_two {ι : Type w} [fintype ι] (K : Type u) {L : Type v} (E : Type z) [field K] [field L] [field E] [algebra K L] [algebra K E] [module.finite K L] [is_alg_closed E] (b : ι → L) [decidable_eq ι] [is_separable K L] (e : ι ≃ (L →ₐ[K] E)) : ⇑(algebra_map K E) (algebra.discr K b) = (algebra.embeddings_matrix_reindex K E b e).det ^ 2
theorem category_theory.limits.has_pullbacks_of_has_binary_products_of_has_equalizers (C : Type u) [𝒞 : category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_pullbacks C
theorem loc_compact_Haus_tot_disc_of_zero_dim {H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] [totally_disconnected_space H] : topological_space.is_topological_basis {s : set H | is_clopen s}
theorem bounded_continuous_function.dist_coe_le_dist {α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {f g : bounded_continuous_function α β} (x : α) : has_dist.dist (⇑f x) (⇑g x) ≤ has_dist.dist f g
theorem category_theory.limits.has_limits_of_size_shrink (C : Type u) [category_theory.category C] [category_theory.limits.has_limits_of_size C] : category_theory.limits.has_limits_of_size C
theorem add_con.comap_eq {M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] {c : add_con M} {f : N →+ M} : add_con.comap ⇑f _ c = add_con.ker (c.mk'.comp f)
theorem is_dedekind_domain.height_one_spectrum.int_valuation.map_zero' {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) : v.int_valuation_def 0 = 0
theorem ideal.quotient.mkₐ_surjective (R₁ : Type u_3) {A : Type u_5} [comm_semiring R₁] [comm_ring A] [algebra R₁ A] (I : ideal A) : function.surjective ⇑(ideal.quotient.mkₐ R₁ I)
theorem finsum_mem_union {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} {s t : set α} (hst : disjoint s t) (hs : s.finite) (ht : t.finite) : finsum (λ (i : α), finsum (λ (H : i ∈ s ∪ t), f i)) = finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) + finsum (λ (i : α), finsum (λ (H : i ∈ t), f i))
theorem lt_tsub_iff_right {α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] : a < b - c ↔ a + c < b
theorem affine.triangle.orthocenter_mem_affine_span {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle ℝ P) : t.orthocenter ∈ affine_span ℝ (set.range t.points)
theorem cardinal.mk_Iic_real (a : ℝ) : cardinal.mk ↥(set.Iic a) = cardinal.continuum
theorem generalized_continued_fraction.squash_seq_nth_of_not_terminated {K : Type u_1} {n : ℕ} {s : seq (generalized_continued_fraction.pair K)} [division_ring K] {gp_n gp_succ_n : generalized_continued_fraction.pair K} (s_nth_eq : s.nth n = option.some gp_n) (s_succ_nth_eq : s.nth (n + 1) = option.some gp_succ_n) : (generalized_continued_fraction.squash_seq s n).nth n = option.some {a := gp_n.a, b := gp_n.b + gp_succ_n.a / gp_succ_n.b}
theorem opens.pretopology_to_grothendieck (T : Type u) [topological_space T] : category_theory.pretopology.to_grothendieck (topological_space.opens T) (opens.pretopology T) = opens.grothendieck_topology T
theorem is_compact.exists_forall_le {α : Type u_1} {β : Type u_2} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [topological_space β] {s : set β} (hs : is_compact s) (ne_s : s.nonempty) {f : β → α} (hf : continuous_on f s) : ∃ (x : β) (H : x ∈ s), ∀ (y : β), y ∈ s → f x ≤ f y
theorem mv_polynomial.induction_on {R : Type u} {σ : Type u_1} [comm_semiring R] {M : mv_polynomial σ R → Prop} (p : mv_polynomial σ R) (h_C : ∀ (a : R), M (⇑mv_polynomial.C a)) (h_add : ∀ (p q : mv_polynomial σ R), M p → M q → M (p + q)) (h_X : ∀ (p : mv_polynomial σ R) (n : σ), M p → M (p * mv_polynomial.X n)) : M p
theorem module.End.map_generalized_eigenrange_le {K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] {f : module.End K V} {μ : K} {n : ℕ} : submodule.map f (f.generalized_eigenrange μ n) ≤ f.generalized_eigenrange μ n
theorem category_theory.limits.zero_of_to_zero {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] {X : C} (f : X ⟶ 0) : f = 0
theorem nat.partition.count_of_sums_of_ne_zero {n : ℕ} {l : multiset ℕ} (hl : l.sum = n) {i : ℕ} (hi : i ≠ 0) : multiset.count i (nat.partition.of_sums n l hl).parts = multiset.count i l
theorem category_theory.sheaf.subcanonical.of_yoneda_is_sheaf {C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) (h : ∀ (X : C), category_theory.presieve.is_sheaf J (category_theory.yoneda.obj X)) : category_theory.sheaf.subcanonical J
theorem affine_independent.comp_embedding {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} {ι2 : Type u_5} (f : ι2 ↪ ι) {p : ι → P} (ha : affine_independent k p) : affine_independent k (p ∘ ⇑f)
theorem interval_integral.deriv_integral_of_tendsto_ae_right {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {c : E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (hb : filter.tendsto f (nhds b ⊓ measure_theory.measure_space.volume.ae) (nhds c)) : deriv (λ (u : ℝ), ∫ (x : ℝ) in a..u, f x) b = c
theorem add_equiv.map_finsupp_sum {α : Type u_1} {M : Type u_5} {N : Type u_7} {P : Type u_8} [has_zero M] [add_comm_monoid N] [add_comm_monoid P] (h : N ≃+ P) (f : α →₀ M) (g : α → M → N) : ⇑h (f.sum g) = f.sum (λ (a : α) (b : M), ⇑h (g a b))
theorem con.refl {M : Type u_1} [has_mul M] (c : con M) (x : M) : ⇑c x x
theorem colex.hom_lt_iff {α : Type u_1} {β : Type u_2} [linear_order α] [decidable_eq β] [preorder β] {f : α → β} (h₁ : strict_mono f) (A B : finset α) : (finset.image f A).to_colex < (finset.image f B).to_colex ↔ A.to_colex < B.to_colex
theorem seminorm.absorbent_ball {𝕜 : Type u_3} {E : Type u_4} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] (p : seminorm 𝕜 E) {r : ℝ} {x : E} (hpr : ⇑p x < r) : absorbent 𝕜 (p.ball x r)
theorem finite_dimensional.fact_finite_dimensional_of_finrank_eq_succ {K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] (n : ℕ) [fact (finite_dimensional.finrank K V = n + 1)] : finite_dimensional K V
theorem has_lt.lt.le {α : Type u} [preorder α] {a b : α} : a < b → a ≤ b
theorem mul_equiv.map_prod {β : Type u} {α : Type v} {γ : Type w} [comm_monoid β] [comm_monoid γ] (g : β ≃* γ) (f : α → β) (s : finset α) : ⇑g (s.prod (λ (x : α), f x)) = s.prod (λ (x : α), ⇑g (f x))
theorem interval_integral.continuous_at_of_dominated_interval {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {μ : measure_theory.measure ℝ} {X : Type u_5} [topological_space X] [topological_space.first_countable_topology X] {F : X → ℝ → E} {x₀ : X} {bound : ℝ → ℝ} {a b : ℝ} (hF_meas : ∀ᶠ (x : X) in nhds x₀, measure_theory.ae_strongly_measurable (F x) (μ.restrict (set.interval_oc a b))) (h_bound : ∀ᶠ (x : X) in nhds x₀, ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → ∥F x t∥ ≤ bound t) (bound_integrable : interval_integrable bound μ a b) (h_cont : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → continuous_at (λ (x : X), F x t) x₀) : continuous_at (λ (x : X), ∫ (t : ℝ) in a..b, F x t ∂μ) x₀
theorem has_deriv_at.lhopital_zero_at_bot {l : filter ℝ} {f f' g g' : ℝ → ℝ} (hff' : ∀ᶠ (x : ℝ) in filter.at_bot, has_deriv_at f (f' x) x) (hgg' : ∀ᶠ (x : ℝ) in filter.at_bot, has_deriv_at g (g' x) x) (hg' : ∀ᶠ (x : ℝ) in filter.at_bot, g' x ≠ 0) (hfbot : filter.tendsto f filter.at_bot (nhds 0)) (hgbot : filter.tendsto g filter.at_bot (nhds 0)) (hdiv : filter.tendsto (λ (x : ℝ), f' x / g' x) filter.at_bot l) : filter.tendsto (λ (x : ℝ), f x / g x) filter.at_bot l
theorem fintype.eq_of_subsingleton_of_sum_eq {M : Type u_4} [add_comm_monoid M] {ι : Type u_1} [subsingleton ι] {s : finset ι} {f : ι → M} {b : M} (h : s.sum (λ (i : ι), f i) = b) (i : ι) (H : i ∈ s) : f i = b
theorem has_strict_fderiv_at.map_implicit_function_eq {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] [complete_space 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] [finite_dimensional 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {a : E} (hf : has_strict_fderiv_at f f' a) (hf' : f'.range = ⊤) : ∀ᶠ (p : F × ↥(f'.ker)) in nhds (f a, 0), f (has_strict_fderiv_at.implicit_function f f' hf hf' p.fst p.snd) = p.fst
theorem real.sin_lt {x : ℝ} (h : 0 < x) : real.sin x < x
theorem is_add_regular_of_cancel_add_monoid {R : Type u_1} [add_cancel_monoid R] (g : R) : is_add_regular g
theorem add_salem_spencer_frontier {𝕜 : Type u_4} {E : Type u_5} [linear_ordered_field 𝕜] [topological_space E] [add_comm_monoid E] [module 𝕜 E] {s : set E} (hs₀ : is_closed s) (hs₁ : strict_convex 𝕜 s) : add_salem_spencer (frontier s)
theorem subsemiring.mul_mem {R : Type u} [non_assoc_semiring R] (s : subsemiring R) {x y : R} : x ∈ s → y ∈ s → x * y ∈ s
theorem submodule.mem_span_finite_of_mem_span {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] {S : set M} {x : M} (hx : x ∈ submodule.span R S) : ∃ (T : finset M), ↑T ⊆ S ∧ x ∈ submodule.span R ↑T
theorem category_theory.abelian.pseudoelement.pseudo_surjective_of_epi {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P ⟶ Q) [category_theory.epi f] : function.surjective ⇑f
theorem dfinsupp.add_hom_ext {ι : Type u} {β : ι → Type v} [dec : decidable_eq ι] [Π (i : ι), add_zero_class (β i)] {γ : Type w} [add_zero_class γ] ⦃f g : (Π₀ (i : ι), β i) →+ γ⦄ (H : ∀ (i : ι) (y : β i), ⇑f (dfinsupp.single i y) = ⇑g (dfinsupp.single i y)) : f = g
theorem affine_subspace.le_def {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P) : s1 ≤ s2 ↔ ↑s1 ⊆ ↑s2
theorem add_monoid_hom.ext_int {A : Type u_1} [add_monoid A] {f g : ℤ →+ A} (h1 : ⇑f 1 = ⇑g 1) : f = g
theorem zsmul_right_injective {α : Type u_1} [linear_ordered_add_comm_group α] {n : ℤ} (hn : n ≠ 0) : function.injective (λ (_x : α), n • _x)
theorem right.add_neg_of_nonpos_of_neg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a ≤ 0) (hb : b < 0) : a + b < 0
theorem function.periodic.bounded_of_continuous {α : Type u} [pseudo_metric_space α] {f : ℝ → α} {c : ℝ} (hp : function.periodic f c) (hc : c ≠ 0) (hf : continuous f) : metric.bounded (set.range f)
theorem orthonormal.oangle_add {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle x y + hb.oangle y z = hb.oangle x z
theorem metric.cthickening_cthickening_subset {α : Type u} [pseudo_emetric_space α] {δ ε : ℝ} (hε : 0 ≤ ε) (hδ : 0 ≤ δ) (s : set α) : metric.cthickening ε (metric.cthickening δ s) ⊆ metric.cthickening (ε + δ) s
theorem convex_hull_eq {R : Type u_1} {E : Type u_2} [linear_ordered_field R] [add_comm_group E] [module R E] (s : set E) : ⇑(convex_hull R) s = {x : E | ∃ (ι : Type u') (t : finset ι) (w : ι → R) (z : ι → E) (hw₀ : ∀ (i : ι), i ∈ t → 0 ≤ w i) (hw₁ : t.sum (λ (i : ι), w i) = 1) (hz : ∀ (i : ι), i ∈ t → z i ∈ s), t.center_mass w z = x}
theorem inv_of_one_lt_inv {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : 1 < a⁻¹ → a < 1
theorem subgroup.normal_closure_le_normal {G : Type u_1} [group G] {s : set G} {N : subgroup G} [N.normal] (h : s ⊆ ↑N) : subgroup.normal_closure s ≤ N
theorem polynomial.nat_degree_cyclotomic (n : ℕ) (R : Type u_1) [ring R] [nontrivial R] : (polynomial.cyclotomic n R).nat_degree = n.totient
theorem cardinal.mk_Iio_real (a : ℝ) : cardinal.mk ↥(set.Iio a) = cardinal.continuum
theorem directed_on.directed_coe {α : Type u} {r : α → α → Prop} {s : set α} : directed_on r s → directed r coe
theorem module.free.finrank_matrix (R : Type u) [ring R] [strong_rank_condition R] (m n : Type v) [fintype m] [fintype n] : finite_dimensional.finrank R (matrix m n R) = fintype.card m * fintype.card n
theorem vitali.exists_disjoint_subfamily_covering_enlargment {α : Type u_1} (t : set (set α)) (δ : set α → ℝ) (τ : ℝ) (hτ : 1 < τ) (δnonneg : ∀ (a : set α), a ∈ t → 0 ≤ δ a) (R : ℝ) (δle : ∀ (a : set α), a ∈ t → δ a ≤ R) (hne : ∀ (a : set α), a ∈ t → a.nonempty) : ∃ (u : set (set α)) (H : u ⊆ t), u.pairwise_disjoint id ∧ ∀ (a : set α), a ∈ t → (∃ (b : set α) (H : b ∈ u), (a ∩ b).nonempty ∧ δ a ≤ τ * δ b)
theorem polynomial.eval_multiset_prod {R : Type u} [comm_semiring R] (s : multiset (polynomial R)) (x : R) : polynomial.eval x s.prod = (multiset.map (polynomial.eval x) s).prod
theorem setoid.lift_unique {α : Type u_1} {β : Type u_2} {r : setoid α} {f : α → β} (H : r ≤ setoid.ker f) (g : quotient r → β) (Hg : f = g ∘ quotient.mk) : quotient.lift f H = g
theorem matrix.det_reindex_linear_equiv_self {m : Type u_2} {n : Type u_3} (R : Type u_11) [comm_ring R] [fintype m] [decidable_eq m] [fintype n] [decidable_eq n] (e : m ≃ n) (M : matrix m m R) : (⇑(matrix.reindex_linear_equiv R R e e) M).det = M.det
theorem convex.strict_convex {𝕜 : Type u_1} {E : Type u_3} [ordered_semiring 𝕜] [topological_space E] [add_comm_monoid E] [module 𝕜 E] {s : set E} (h : is_open s) (hs : convex 𝕜 s) : strict_convex 𝕜 s
theorem is_right_regular_zero_iff_subsingleton {R : Type u_1} [mul_zero_class R] : is_right_regular 0 ↔ subsingleton R
theorem cont_mdiff.cont_diff {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {n : with_top ℕ} {f : E → E'} : cont_mdiff (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n f → cont_diff 𝕜 n f
theorem continuous.exists_forall_le' {α : Type u_1} {β : Type u_2} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [topological_space β] {f : β → α} (hf : continuous f) (x₀ : β) (h : ∀ᶠ (x : β) in filter.cocompact β, f x₀ ≤ f x) : ∃ (x : β), ∀ (y : β), f x ≤ f y
theorem category_theory.cover_dense.sheaf_hom_eq {C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {A : Type u_7} [category_theory.category A] {G : C ⥤ D} (H : category_theory.cover_dense K G) [category_theory.full G] {ℱ : Dᵒᵖ ⥤ A} {ℱ' : category_theory.Sheaf K A} (α : ℱ ⟶ ℱ'.val) : H.sheaf_hom (category_theory.whisker_left G.op α) = α
theorem measure_theory.is_add_fundamental_domain.ess_sup_measure_restrict {G : Type u_1} {α : Type u_2} [add_group G] [add_action G α] [measurable_space α] {s : set α} {μ : measure_theory.measure α} [measurable_space G] [has_measurable_vadd G α] [measure_theory.vadd_invariant_measure G α μ] [encodable G] (hs : measure_theory.is_add_fundamental_domain G s μ) {f : α → ennreal} (hf : ∀ (γ : G) (x : α), f (γ +ᵥ x) = f x) : ess_sup f (μ.restrict s) = ess_sup f μ
theorem pgame.mk_le_mk {xl xr : Type u_1} {xL : xl → pgame} {xR : xr → pgame} {yl yr : Type u_1} {yL : yl → pgame} {yR : yr → pgame} : pgame.mk xl xr xL xR ≤ pgame.mk yl yr yL yR ↔ (∀ (i : xl), (xL i).lf (pgame.mk yl yr yL yR)) ∧ ∀ (j : yr), (pgame.mk xl xr xL xR).lf (yR j)
theorem is_complemented_of_Sup_atoms_eq_top {α : Type u_1} [complete_lattice α] [is_modular_lattice α] [is_compactly_generated α] (h : has_Sup.Sup {a : α | is_atom a} = ⊤) : is_complemented α
theorem monoid_hom.map_closure {G : Type u_1} [group G] {N : Type u_3} [group N] (f : G →* N) (s : set G) : subgroup.map f (subgroup.closure s) = subgroup.closure (⇑f '' s)
theorem affine.simplex.points_with_circumcenter_eq_circumcenter {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P n) : s.points_with_circumcenter affine.simplex.points_with_circumcenter_index.circumcenter_index = s.circumcenter
theorem subsemiring.multiset_sum_mem {R : Type u} [non_assoc_semiring R] (s : subsemiring R) (m : multiset R) : (∀ (a : R), a ∈ m → a ∈ s) → m.sum ∈ s
theorem basis.ext {ι : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (b : basis ι R M) {R₁ : Type u_9} [semiring R₁] {σ : R →+* R₁} {M₁ : Type u_10} [add_comm_monoid M₁] [module R₁ M₁] {f₁ f₂ : M →ₛₗ[σ] M₁} (h : ∀ (i : ι), ⇑f₁ (⇑b i) = ⇑f₂ (⇑b i)) : f₁ = f₂
theorem coe_lower_central_series_ideal_quot_eq {R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] {I : lie_ideal R L} (k : ℕ) : ↑(lie_module.lower_central_series R L (L ⧸ I) k) = ↑(lie_module.lower_central_series R (L ⧸ I) (L ⧸ I) k)
theorem int.modeq.pow_card_sub_one_eq_one {p : ℕ} (hp : nat.prime p) {n : ℤ} (hpn : is_coprime n ↑p) : n ^ (p - 1) ≡ 1 [ZMOD ↑p]
theorem finset.sum_induction {α : Type v} {s : finset α} {M : Type u_1} [add_comm_monoid M] (f : α → M) (p : M → Prop) (p_mul : ∀ (a b : M), p a → p b → p (a + b)) (p_one : p 0) (p_s : ∀ (x : α), x ∈ s → p (f x)) : p (s.sum (λ (x : α), f x))
theorem left.add_neg' {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0
theorem affine_independent_iff_le_finrank_vector_span (k : Type u_1) {V : Type u_2} {P : Type u_3} {ι : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype ι] (p : ι → P) {n : ℕ} (hc : fintype.card ι = n + 1) : affine_independent k p ↔ n ≤ finite_dimensional.finrank k ↥(vector_span k (set.range p))
theorem submodule.span_eq_restrict_scalars (R : Type u_1) (A : Type u_2) (M : Type u_3) [comm_semiring R] [semiring A] [algebra R A] [add_comm_monoid M] [module R M] [module A M] [is_scalar_tower R A M] (X : set M) (hsur : function.surjective ⇑(algebra_map R A)) : submodule.span R X = submodule.restrict_scalars R (submodule.span A X)
theorem matrix.det_neg_eq_smul {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (A : matrix n n R) : (-A).det = (-1) ^ fintype.card n • A.det
theorem inner_product_geometry.angle_nonneg {V : Type u_1} [inner_product_space ℝ V] (x y : V) : 0 ≤ inner_product_geometry.angle x y
theorem sub_mul_add_eq_of_mul_add_eq_mul_add {α : Type u} [non_unital_non_assoc_ring α] {a b c d e : α} : a * e + c = b * e + d → (a - b) * e + c = d
theorem cont_diff_on_succ_iff_fderiv_within {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {n : ℕ} (hs : unique_diff_on 𝕜 s) : cont_diff_on 𝕜 ↑(n + 1) f s ↔ differentiable_on 𝕜 f s ∧ cont_diff_on 𝕜 ↑n (λ (y : E), fderiv_within 𝕜 f s y) s
theorem cont_mdiff_within_at_iff' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M → M'} {s : set M} {x : M} {n : with_top ℕ} {x' : M} {y : M'} (hx : x' ∈ (charted_space.chart_at H x).to_local_equiv.source) (hy : f x' ∈ (charted_space.chart_at H' y).to_local_equiv.source) : cont_mdiff_within_at I I' n f s x' ↔ continuous_within_at f s x' ∧ cont_diff_within_at 𝕜 n (⇑(ext_chart_at I' y) ∘ f ∘ ⇑((ext_chart_at I x).symm)) ((ext_chart_at I x).target ∩ ⇑((ext_chart_at I x).symm) ⁻¹' (s ∩ f ⁻¹' (ext_chart_at I' y).source)) (⇑(ext_chart_at I x) x')
theorem is_localization.is_localization_is_localization_at_prime_is_localization {R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] (T : Type u_4) [comm_ring T] [algebra R T] [algebra S T] [is_scalar_tower R S T] [is_localization M S] (p : ideal S) [Hp : p.is_prime] [is_localization.at_prime T p] : is_localization.at_prime T (ideal.comap (algebra_map R S) p)
theorem orientation.oangle_eq_two_zsmul_oangle_sub_of_norm_eq {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y z : V} (hxyne : x ≠ y) (hxzne : x ≠ z) (hxy : ∥x∥ = ∥y∥) (hxz : ∥x∥ = ∥z∥) : o.oangle y z = 2 • o.oangle (y - x) (z - x)
theorem has_fpower_series_on_ball.fderiv {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {p : formal_multilinear_series 𝕜 E F} {r : ennreal} {f : E → F} {x : E} [complete_space F] (h : has_fpower_series_on_ball f p x r) : has_fpower_series_on_ball (fderiv 𝕜 f) (↑(continuous_multilinear_curry_fin1 𝕜 E F).comp_formal_multilinear_series (p.change_origin_series 1)) x r
theorem is_primitive_root.sub_one_norm_eq_eval_cyclotomic {n : ℕ+} {K : Type u} {L : Type v} [field L] {ζ : L} (hζ : is_primitive_root ζ ↑n) [field K] [algebra K L] [ne_zero ↑↑n] [is_cyclotomic_extension {n} K L] (h : 2 < ↑n) (hirr : irreducible (polynomial.cyclotomic ↑n K)) : ⇑(algebra.norm K) (ζ - 1) = ↑(polynomial.eval 1 (polynomial.cyclotomic ↑n ℤ))
theorem exists_lt_of_lt_cSup {α : Type u_1} [conditionally_complete_linear_order α] {s : set α} {b : α} (hs : s.nonempty) (hb : b < has_Sup.Sup s) : ∃ (a : α) (H : a ∈ s), b < a
theorem interval_integral.integral_has_strict_deriv_at_of_tendsto_ae_right {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {c : E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (hb : filter.tendsto f (nhds b ⊓ measure_theory.measure_space.volume.ae) (nhds c)) : has_strict_deriv_at (λ (u : ℝ), ∫ (x : ℝ) in a..u, f x) c b
theorem collinear_empty (k : Type u_1) {V : Type u_2} (P : Type u_3) [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] : collinear k ∅
theorem iterated_fderiv_within_succ_eq_comp_right {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {x : E} {n : ℕ} (hs : unique_diff_on 𝕜 s) (hx : x ∈ s) : iterated_fderiv_within 𝕜 (n + 1) f s x = (⇑(continuous_multilinear_curry_right_equiv' 𝕜 n E F) ∘ iterated_fderiv_within 𝕜 n (λ (y : E), fderiv_within 𝕜 f s y) s) x
theorem dimH_range_le_of_locally_lipschitz_on {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [topological_space.second_countable_topology X] {f : X → Y} (hf : ∀ (x : X), ∃ (C : nnreal) (s : set X) (H : s ∈ nhds x), lipschitz_on_with C f s) : dimH (set.range f) ≤ dimH set.univ
theorem measure_theory.conservative.measure_mem_forall_ge_image_not_mem_eq_zero {α : Type u_2} [measurable_space α] {f : α → α} {s : set α} {μ : measure_theory.measure α} (hf : measure_theory.conservative f μ) (hs : measurable_set s) (n : ℕ) : ⇑μ {x ∈ s | ∀ (m : ℕ), m ≥ n → f^[m] x ∉ s} = 0
theorem unique_mdiff_on.unique_diff_on {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {s : set E} : unique_mdiff_on (model_with_corners_self 𝕜 E) s → unique_diff_on 𝕜 s
theorem pred.rec {α : Type u_1} [preorder α] [pred_order α] [is_pred_archimedean α] {P : α → Prop} {m : α} (h0 : P m) (h1 : ∀ (n : α), n ≤ m → P n → P (order.pred n)) ⦃n : α⦄ (hmn : n ≤ m) : P n
theorem right.one_lt_mul {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
theorem sum_eight_sq_mul_sum_eight_sq {R : Type u_1} [comm_ring R] {x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ y₁ y₂ y₃ y₄ y₅ y₆ y₇ y₈ : R} : (x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2 + x₅ ^ 2 + x₆ ^ 2 + x₇ ^ 2 + x₈ ^ 2) * (y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2 + y₅ ^ 2 + y₆ ^ 2 + y₇ ^ 2 + y₈ ^ 2) = (x₁ * y₁ - x₂ * y₂ - x₃ * y₃ - x₄ * y₄ - x₅ * y₅ - x₆ * y₆ - x₇ * y₇ - x₈ * y₈) ^ 2 + (x₁ * y₂ + x₂ * y₁ + x₃ * y₄ - x₄ * y₃ + x₅ * y₆ - x₆ * y₅ - x₇ * y₈ + x₈ * y₇) ^ 2 + (x₁ * y₃ - x₂ * y₄ + x₃ * y₁ + x₄ * y₂ + x₅ * y₇ + x₆ * y₈ - x₇ * y₅ - x₈ * y₆) ^ 2 + (x₁ * y₄ + x₂ * y₃ - x₃ * y₂ + x₄ * y₁ + x₅ * y₈ - x₆ * y₇ + x₇ * y₆ - x₈ * y₅) ^ 2 + (x₁ * y₅ - x₂ * y₆ - x₃ * y₇ - x₄ * y₈ + x₅ * y₁ + x₆ * y₂ + x₇ * y₃ + x₈ * y₄) ^ 2 + (x₁ * y₆ + x₂ * y₅ - x₃ * y₈ + x₄ * y₇ - x₅ * y₂ + x₆ * y₁ - x₇ * y₄ + x₈ * y₃) ^ 2 + (x₁ * y₇ + x₂ * y₈ + x₃ * y₅ - x₄ * y₆ - x₅ * y₃ + x₆ * y₄ + x₇ * y₁ - x₈ * y₂) ^ 2 + (x₁ * y₈ - x₂ * y₇ + x₃ * y₆ + x₄ * y₅ - x₅ * y₄ - x₆ * y₃ + x₇ * y₂ + x₈ * y₁) ^ 2
theorem char_zero.of_module (R : Type u_2) (M : Type u_5) [semiring R] [add_comm_monoid M] [module R M] [has_one M] [char_zero M] : char_zero R
theorem left.add_neg_of_neg_of_nonpos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b ≤ 0) : a + b < 0
theorem add_submonoid.fg_iff {M : Type u_1} [add_monoid M] (P : add_submonoid M) : P.fg ↔ ∃ (S : set M), add_submonoid.closure S = P ∧ S.finite
theorem basis.ext_alternating {ι : Type u_6} [decidable_eq ι] {ι₁ : Type u_7} [fintype ι] {R' : Type u_8} {N₁ : Type u_9} {N₂ : Type u_10} [comm_semiring R'] [add_comm_monoid N₁] [add_comm_monoid N₂] [module R' N₁] [module R' N₂] {f g : alternating_map R' N₁ N₂ ι} (e : basis ι₁ R' N₁) (h : ∀ (v : ι → ι₁), function.injective v → ⇑f (λ (i : ι), ⇑e (v i)) = ⇑g (λ (i : ι), ⇑e (v i))) : f = g
theorem list.chain.induction {α : Type u} {r : α → α → Prop} {a b : α} (p : α → Prop) (l : list α) (h : list.chain r a l) (hb : (a :: l).last _ = b) (carries : ∀ ⦃x y : α⦄, r x y → p y → p x) (final : p b) (i : α) (H : i ∈ a :: l) : p i
theorem continuous_multilinear_map.op_norm_le_bound {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : continuous_multilinear_map 𝕜 E G) {M : ℝ} (hMp : 0 ≤ M) (hM : ∀ (m : Π (i : ι), E i), ∥⇑f m∥ ≤ M * finset.univ.prod (λ (i : ι), ∥m i∥)) : ∥f∥ ≤ M
theorem category_theory.preadditive.exact_iff_homology_zero {V : Type u} [category_theory.category V] [category_theory.limits.has_images V] [category_theory.limits.has_zero_object V] [category_theory.preadditive V] [category_theory.limits.has_kernels V] [category_theory.limits.has_cokernels V] {A B C : V} (f : A ⟶ B) (g : B ⟶ C) : category_theory.exact f g ↔ ∃ (w : f ≫ g = 0), nonempty (homology f g w ≅ 0)
theorem category_theory.is_subterminal_of_is_iso_diag {C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_binary_product A A] [category_theory.is_iso (category_theory.limits.diag A)] : category_theory.is_subterminal A
theorem measure_theory.measure.map_haar_inv {G : Type u_1} [comm_group G] [topological_space G] [topological_group G] [t2_space G] [measurable_space G] [borel_space G] [locally_compact_space G] [topological_space.second_countable_topology G] (μ : measure_theory.measure G) [μ.is_haar_measure] : measure_theory.measure.map has_inv.inv μ = μ
theorem category_theory.is_subterminal.is_iso_diag {C : Type u₁} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) [category_theory.limits.has_binary_product A A] : category_theory.is_iso (category_theory.limits.diag A)
theorem fixed_points.to_alg_hom_bijective (G : Type u) (F : Type v) [group G] [field F] [fintype G] [mul_semiring_action G F] [has_faithful_smul G F] : function.bijective (mul_semiring_action.to_alg_hom ↥(fixed_points.subfield G F) F)
theorem perfection_map.id (p : ℕ) [fact (nat.prime p)] (R : Type u₁) [comm_semiring R] [char_p R p] [perfect_ring R p] : perfection_map p (ring_hom.id R)
theorem is_fraction_ring.char_zero_of_is_fraction_ring (R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [char_zero R] : char_zero K
theorem eq_orthogonal_projection_of_mem_orthogonal' {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {K : submodule 𝕜 E} [complete_space ↥K] {u v z : E} (hv : v ∈ K) (hz : z ∈ Kᗮ) (hu : u = v + z) : ↑(⇑(orthogonal_projection K) u) = v
theorem metric.Hausdorff_dist_triangle' {α : Type u} [pseudo_metric_space α] {s t u : set α} (fin : emetric.Hausdorff_edist t u ≠ ⊤) : metric.Hausdorff_dist s u ≤ metric.Hausdorff_dist s t + metric.Hausdorff_dist t u
theorem lower_semicontinuous_on.add' {α : Type u_1} [topological_space α] {s : set α} {γ : Type u_4} [linear_ordered_add_comm_monoid γ] [topological_space γ] [order_topology γ] {f g : α → γ} (hf : lower_semicontinuous_on f s) (hg : lower_semicontinuous_on g s) (hcont : ∀ (x : α), x ∈ s → continuous_at (λ (p : γ × γ), p.fst + p.snd) (f x, g x)) : lower_semicontinuous_on (λ (z : α), f z + g z) s
theorem complex.Gamma_add_one (s : ℂ) (h2 : s ≠ 0) : (s + 1).Gamma = s * s.Gamma
theorem con.ker_apply_eq_preimage {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {f : M →* P} (x : M) : ⇑(con.ker f) x = ⇑f ⁻¹' {⇑f x}
theorem module.free.finrank_pi_fintype (R : Type u) [ring R] [strong_rank_condition R] {ι : Type v} [fintype ι] {M : ι → Type w} [Π (i : ι), add_comm_group (M i)] [Π (i : ι), module R (M i)] [∀ (i : ι), module.free R (M i)] [∀ (i : ι), module.finite R (M i)] : finite_dimensional.finrank R (Π (i : ι), M i) = finset.univ.sum (λ (i : ι), finite_dimensional.finrank R (M i))
theorem convex_independent_set_iff_not_mem_convex_hull_diff {𝕜 : Type u_1} {E : Type u_2} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] {s : set E} : convex_independent 𝕜 (λ (x : ↥s), ↑x) ↔ ∀ (x : E), x ∈ s → x ∉ ⇑(convex_hull 𝕜) (s  {x})
theorem one_lt_inv' {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : 1 < a⁻¹ ↔ a < 1
theorem antitone.sup {α : Type u} {β : Type v} [preorder α] [semilattice_sup β] {f g : α → β} (hf : antitone f) (hg : antitone g) : antitone (f ⊔ g)
theorem dense.bUnion_uniformity_ball {α : Type u_1} [uniform_space α] {s : set α} {U : set (α × α)} (hs : dense s) (hU : U ∈ uniformity α) : (⋃ (x : α) (H : x ∈ s), uniform_space.ball x U) = set.univ
theorem linear_map.ext_on {R : Type u_1} {R₂ : Type u_2} {M : Type u_4} {M₂ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring R₂] [add_comm_monoid M₂] [module R₂ M₂] {σ₁₂ : R →+* R₂} {s : set M} {f g : M →ₛₗ[σ₁₂] M₂} (hv : submodule.span R s = ⊤) (h : set.eq_on ⇑f ⇑g s) : f = g
theorem irrational_sqrt_two  : irrational (real.sqrt 2)
theorem is_compact.bdd_below_image {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_closed_topology α] [nonempty α] [topological_space β] {f : β → α} {K : set β} (hK : is_compact K) (hf : continuous_on f K) : bdd_below (f '' K)
theorem pi.single_commute {I : Type u} {f : I → Type v} [decidable_eq I] [Π (i : I), add_zero_class (f i)] : pairwise (λ (i j : I), ∀ (x : f i) (y : f j), add_commute (pi.single i x) (pi.single j y))
theorem filter.Coprod_cofinite {ι : Type u_1} {α : ι → Type u_2} [fintype ι] : filter.Coprod (λ (i : ι), filter.cofinite) = filter.cofinite
theorem ring_hom.range_top_of_surjective {R : Type u} {S : Type v} [ring R] [ring S] (f : R →+* S) (hf : function.surjective ⇑f) : f.range = ⊤
theorem finset.inf_univ_eq_infi {α : Type u_1} {β : Type u_2} [fintype α] [complete_lattice β] (f : α → β) : finset.univ.inf f = infi f
theorem unique_diff_on.pi {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] (ι : Type u_2) [fintype ι] (E : ι → Type u_3) [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] (s : Π (i : ι), set (E i)) (I : set ι) (h : ∀ (i : ι), i ∈ I → unique_diff_on 𝕜 (s i)) : unique_diff_on 𝕜 (I.pi s)
theorem category_theory.limits.has_colimits_of_shape_op_of_has_limits_of_shape {C : Type u₁} [category_theory.category C] {J : Type u₂} [category_theory.category J] [category_theory.limits.has_limits_of_shape Jᵒᵖ C] : category_theory.limits.has_colimits_of_shape J Cᵒᵖ
theorem continuous_map.compact_open_eq_compact_convergence {α : Type u₁} {β : Type u₂} [topological_space α] [uniform_space β] : continuous_map.compact_open = continuous_map.compact_convergence_topology
theorem monotone.ne_of_lt_of_lt_int {α : Type u} [preorder α] {f : ℤ → α} (hf : monotone f) (n : ℤ) {x : α} (h1 : f n < x) (h2 : x < f (n + 1)) (a : ℤ) : f a ≠ x
theorem homotopy.map_null_homotopic_map' {ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D : homological_complex V c} {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] (G : V ⥤ W) [G.additive] (hom : Π (i j : ι), c.rel j i → (C.X i ⟶ D.X j)) : (G.map_homological_complex c).map (homotopy.null_homotopic_map' hom) = homotopy.null_homotopic_map' (λ (i j : ι) (hij : c.rel j i), G.map (hom i j hij))
theorem measure_theory.analytic_set.Union {α : Type u_1} [topological_space α] {ι : Type u_2} [encodable ι] {s : ι → set α} (hs : ∀ (n : ι), measure_theory.analytic_set (s n)) : measure_theory.analytic_set (⋃ (n : ι), s n)
theorem matrix.det_conj_of_mul_eq_one {A : Type u_5} [comm_ring A] {m : Type u_6} {n : Type u_7} [fintype m] [fintype n] [decidable_eq m] [decidable_eq n] {M : matrix m n A} {M' : matrix n m A} {N : matrix n n A} (hMM' : M.mul M' = 1) (hM'M : M'.mul M = 1) : ((M.mul N).mul M').det = N.det
theorem ordinal.fp_bfamily_unbounded {o : ordinal} {f : Π (b : ordinal), b < o → ordinal → ordinal} (H : ∀ (i : ordinal) (hi : i < o), ordinal.is_normal (f i hi)) : set.unbounded has_lt.lt (⋂ (i : ordinal) (hi : i < o), function.fixed_points (f i hi))
theorem clifford_algebra.even_odd_induction {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) (n : zmod 2) {P : Π (x : clifford_algebra Q), x ∈ clifford_algebra.even_odd Q n → Prop} (hr : ∀ (v : clifford_algebra Q) (h : v ∈ (clifford_algebra.ι Q).range ^ n.val), P v _) (hadd : ∀ {x y : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q n} {hy : y ∈ clifford_algebra.even_odd Q n}, P x hx → P y hy → P (x + y) _) (hιι_mul : ∀ (m₁ m₂ : M) {x : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q n}, P x hx → P (⇑(clifford_algebra.ι Q) m₁ * ⇑(clifford_algebra.ι Q) m₂ * x) _) (x : clifford_algebra Q) (hx : x ∈ clifford_algebra.even_odd Q n) : P x hx
theorem category_theory.cover_dense.iso_of_restrict_iso {C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {A : Type u_7} [category_theory.category A] {G : C ⥤ D} (H : category_theory.cover_dense K G) [category_theory.full G] {ℱ ℱ' : category_theory.Sheaf K A} (α : ℱ ⟶ ℱ') (i : category_theory.is_iso (category_theory.whisker_left G.op α.val)) : category_theory.is_iso α
theorem finite_of_is_noetherian_linear_independent {R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] [is_noetherian R M] {s : set M} (hi : linear_independent R coe) : s.finite
theorem cont_mdiff.cod_restrict_sphere {E : Type u_1} [inner_product_space ℝ E] {F : Type u_2} [normed_group F] [normed_space ℝ F] {H : Type u_3} [topological_space H] {I : model_with_corners ℝ F H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {n : ℕ} [fact (finite_dimensional.finrank ℝ E = n + 1)] {m : with_top ℕ} {f : M → E} (hf : cont_mdiff I (model_with_corners_self ℝ E) m f) (hf' : ∀ (x : M), f x ∈ metric.sphere 0 1) : cont_mdiff I (model_with_corners_self ℝ (euclidean_space ℝ (fin n))) m (set.cod_restrict (λ (x : M), f x) (metric.sphere 0 1) hf')
theorem filter.frequently.eventually {α : Type u} {f : ultrafilter α} {p : α → Prop} : (∃ᶠ (x : α) in ↑f, p x) → (∀ᶠ (x : α) in ↑f, p x)
theorem affine_basis.to_matrix_inv_vec_mul_to_matrix {ι : Type u₁} {k : Type u₂} {V : Type u₃} {P : Type u₄} [add_comm_group V] [add_torsor V P] [comm_ring k] [module k V] [decidable_eq ι] [fintype ι] (b b₂ : affine_basis ι k P) (x : P) : matrix.vec_mul (⇑(b.coords) x) (b.to_matrix b₂.points)⁻¹ = ⇑(b₂.coords) x
theorem orthonormal_iff_ite {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} [dec_ι : decidable_eq ι] {v : ι → E} : orthonormal 𝕜 v ↔ ∀ (i j : ι), has_inner.inner (v i) (v j) = ite (i = j) 1 0
theorem continuous_linear_map.continuous₂ {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] (f : E →L[𝕜] F →L[𝕜] G) : continuous (function.uncurry (λ (x : E) (y : F), ⇑(⇑f x) y))
theorem generalized_continued_fraction.int_fract_pair.of_inv_fr_num_lt_num_of_pos {q : ℚ} (q_pos : 0 < q) : (generalized_continued_fraction.int_fract_pair.of q⁻¹).fr.num < q.num
theorem has_lt.lt.exists_lt_lt {α : Type u_1} [has_lt α] {a b : α} (h : a < b) : ¬a ⋖ b → (∃ (c : α), a < c ∧ c < b)
theorem one_div_lt_one_div_of_neg {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : a < 0) (hb : b < 0) : 1 / a < 1 / b ↔ b < a
theorem ideal.supr_infi_eq_top_iff_pairwise {ι : Type u_1} {R : Type u_2} [comm_semiring R] {t : finset ι} (h : t.nonempty) (I : ι → ideal R) : (⨆ (i : ι) (H : i ∈ t), ⨅ (j : ι) (hj : j ∈ t) (ij : j ≠ i), I j) = ⊤ ↔ ↑t.pairwise (λ (i j : ι), I i ⊔ I j = ⊤)
theorem is_o_pow_const_const_pow_of_one_lt {R : Type u_1} [normed_ring R] (k : ℕ) {r : ℝ} (hr : 1 < r) : (λ (n : ℕ), ↑n ^ k) =o[filter.at_top] λ (n : ℕ), r ^ n
theorem affine_subspace.span_union (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s t : set P) : affine_span k (s ∪ t) = affine_span k s ⊔ affine_span k t
theorem tactic.coherence.assoc_lift_hom {C : Type u} [category_theory.category C] [category_theory.monoidal_category C] {W X Y Z : C} [category_theory.monoidal_category.lift_obj W] [category_theory.monoidal_category.lift_obj X] [category_theory.monoidal_category.lift_obj Y] (f : W ⟶ X) (g : X ⟶ Y) (h : Y ⟶ Z) [category_theory.monoidal_category.lift_hom f] [category_theory.monoidal_category.lift_hom g] : f ≫ g ≫ h = (f ≫ g) ≫ h
theorem category_theory.abelian.coimage.fac {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_kernels C] [category_theory.limits.has_cokernels C] {P Q : C} (f : P ⟶ Q) : category_theory.abelian.coimage.π f ≫ category_theory.abelian.factor_thru_coimage f = f
theorem emetric.nonempty_compacts.is_closed_in_closeds {α : Type u} [emetric_space α] [complete_space α] : is_closed (set.range topological_space.nonempty_compacts.to_closeds)
theorem orientation.eq_rotation_self_iff {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x : V) (θ : real.angle) : x = ⇑(o.rotation θ) x ↔ x = 0 ∨ θ = 0
theorem algebra.discr_is_integral {ι : Type w} [fintype ι] (K : Type u) {L : Type v} [field K] [field L] [algebra K L] [module.finite K L] {R : Type z} [comm_ring R] [algebra R K] [algebra R L] [is_scalar_tower R K L] {b : ι → L} (h : ∀ (i : ι), is_integral R (b i)) : is_integral R (algebra.discr K b)
theorem has_strict_fderiv_at_of_has_fderiv_at_of_continuous_at {𝕜 : Type u_3} [is_R_or_C 𝕜] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {H : Type u_5} [normed_group H] [normed_space 𝕜 H] {f : G → H} {f' : G → (G →L[𝕜] H)} {x : G} (hder : ∀ᶠ (y : G) in nhds x, has_fderiv_at f (f' y) y) (hcont : continuous_at f' x) : has_strict_fderiv_at f (f' x) x
theorem ring_hom.domain_nontrivial {α : Type u_2} {β : Type u_3} {rα : non_assoc_semiring α} {rβ : non_assoc_semiring β} (f : α →+* β) [nontrivial β] : nontrivial α
theorem seminorm.le_insert' {𝕜 : Type u_3} {E : Type u_4} [semi_normed_ring 𝕜] [add_comm_group E] [module 𝕜 E] (p : seminorm 𝕜 E) (x y : E) : ⇑p x ≤ ⇑p y + ⇑p (x - y)
theorem add_subgroup.closure_mono {G : Type u_1} [add_group G] ⦃h k : set G⦄ (h' : h ⊆ k) : add_subgroup.closure h ≤ add_subgroup.closure k
theorem cardinal.infinite_pigeonhole_card_lt {β α : Type u} (f : β → α) (w : cardinal.mk α < cardinal.mk β) (w' : cardinal.aleph_0 ≤ cardinal.mk α) : ∃ (a : α), cardinal.mk α < cardinal.mk ↥(f ⁻¹' {a})
theorem category_theory.elementwise_of {α : Sort u_1} (hh : α) {β : Prop} (x : tactic.calculated_Prop β hh . "derive_elementwise_proof") : β
theorem polynomial.nat_degree_le_of_degree_le {R : Type u} [semiring R] {p : polynomial R} {n : ℕ} : p.degree ≤ ↑n → p.nat_degree ≤ n
theorem convex_independent.injective {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] {p : ι → E} (hc : convex_independent 𝕜 p) : function.injective p
theorem besicovitch.ae_tendsto_rn_deriv {β : Type u} [metric_space β] [measurable_space β] [borel_space β] [sigma_compact_space β] [has_besicovitch_covering β] (ρ μ : measure_theory.measure β) [measure_theory.is_locally_finite_measure μ] [measure_theory.is_locally_finite_measure ρ] : ∀ᵐ (x : β) ∂μ, filter.tendsto (λ (r : ℝ), ⇑ρ (metric.closed_ball x r) / ⇑μ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds (ρ.rn_deriv μ x))
theorem category_theory.limits.complete_lattice.colimit_eq_supr {α : Type u} [complete_lattice α] {J : Type u} [category_theory.small_category J] (F : J ⥤ α) : category_theory.limits.colimit F = supr F.obj
theorem finsum_mem_add_distrib {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f g : α → M} {s : set α} (hs : s.finite) : finsum (λ (i : α), finsum (λ (H : i ∈ s), f i + g i)) = finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) + finsum (λ (i : α), finsum (λ (H : i ∈ s), g i))
theorem bounded_continuous_function.arzela_ascoli {α : Type u} {β : Type v} [topological_space α] [compact_space α] [pseudo_metric_space β] [t2_space β] (s : set β) (hs : is_compact s) (A : set (bounded_continuous_function α β)) (in_s : ∀ (f : bounded_continuous_function α β) (x : α), f ∈ A → ⇑f x ∈ s) (H : ∀ (x : α) (ε : ℝ), ε > 0 → (∃ (U : set α) (H : U ∈ nhds x), ∀ (y : α), y ∈ U → ∀ (z : α), z ∈ U → ∀ (f : bounded_continuous_function α β), f ∈ A → has_dist.dist (⇑f y) (⇑f z) < ε)) : is_compact (closure A)
theorem has_deriv_within_at.limsup_slope_norm_le {E : Type u} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {f' : E} {s : set ℝ} {x r : ℝ} (hf : has_deriv_within_at f f' s x) (hr : ∥f'∥ < r) : ∀ᶠ (z : ℝ) in nhds_within x s, ∥z - x∥⁻¹ * (∥f z∥ - ∥f x∥) < r
theorem liouville_with.frequently_lt_rpow_neg {p q x : ℝ} (h : liouville_with p x) (hlt : q < p) : ∃ᶠ (n : ℕ) in filter.at_top, ∃ (m : ℤ), x ≠ ↑m / ↑n ∧ |x - ↑m / ↑n| < ↑n ^ -q
theorem matrix.det_one_add_col_mul_row {m : Type u} {α : Type v} [comm_ring α] [fintype m] [decidable_eq m] (u v : m → α) : (1 + (matrix.col u).mul (matrix.row v)).det = 1 + matrix.dot_product v u
theorem zero_lt.left.mul_lt_one_of_le_of_lt {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : a ≤ 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1
theorem real.abs_log_sub_add_sum_range_le {x : ℝ} (h : |x| < 1) (n : ℕ) : |(finset.range n).sum (λ (i : ℕ), x ^ (i + 1) / (↑i + 1)) + real.log (1 - x)| ≤ |x| ^ (n + 1) / (1 - |x|)
theorem affine.simplex.circumradius_nonneg {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P n) : 0 ≤ s.circumradius
theorem monoid_hom.map_prod {β : Type u} {α : Type v} {γ : Type w} [comm_monoid β] [comm_monoid γ] (g : β →* γ) (f : α → β) (s : finset α) : ⇑g (s.prod (λ (x : α), f x)) = s.prod (λ (x : α), ⇑g (f x))
theorem category_theory.limits.prod_comparison_inv_natural {C : Type u} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) {A A' B B' : C} [category_theory.limits.has_binary_product A B] [category_theory.limits.has_binary_product A' B'] [category_theory.limits.has_binary_product (F.obj A) (F.obj B)] [category_theory.limits.has_binary_product (F.obj A') (F.obj B')] (f : A ⟶ A') (g : B ⟶ B') [category_theory.is_iso (category_theory.limits.prod_comparison F A B)] [category_theory.is_iso (category_theory.limits.prod_comparison F A' B')] : category_theory.inv (category_theory.limits.prod_comparison F A B) ≫ F.map (category_theory.limits.prod.map f g) = category_theory.limits.prod.map (F.map f) (F.map g) ≫ category_theory.inv (category_theory.limits.prod_comparison F A' B')
theorem affine_subspace.vector_span_eq_top_of_affine_span_eq_top (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s : set P} (h : affine_span k s = ⊤) : vector_span k s = ⊤
theorem thickened_indicator_tendsto_indicator_closure {α : Type u_1} [pseudo_emetric_space α] {δseq : ℕ → ℝ} (δseq_pos : ∀ (n : ℕ), 0 < δseq n) (δseq_lim : filter.tendsto δseq filter.at_top (nhds 0)) (E : set α) : filter.tendsto (λ (n : ℕ), ⇑(thickened_indicator _ E)) filter.at_top (nhds ((closure E).indicator (λ (x : α), 1)))
theorem affine.triangle.affine_span_orthocenter_point_le_altitude {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle ℝ P) (i : fin 3) : affine_span ℝ {t.orthocenter, t.points i} ≤ affine.simplex.altitude t i
theorem cont_diff_on.prod_map {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : with_top ℕ} {E' : Type u_4} [normed_group E'] [normed_space 𝕜 E'] {F' : Type u_5} [normed_group F'] [normed_space 𝕜 F'] {s : set E} {t : set E'} {f : E → F} {g : E' → F'} (hf : cont_diff_on 𝕜 n f s) (hg : cont_diff_on 𝕜 n g t) : cont_diff_on 𝕜 n (prod.map f g) (s ×ˢ t)
theorem cont_diff.snd' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {n : with_top ℕ} {f : F → G} (hf : cont_diff 𝕜 n f) : cont_diff 𝕜 n (λ (x : E × F), f x.snd)
theorem finset.nonempty.sym2 {α : Type u_1} [decidable_eq α] {s : finset α} : s.nonempty → s.sym2.nonempty
theorem exists_open_nhds_one_mul_subset {M : Type u_4} [topological_space M] [monoid M] [has_continuous_mul M] {U : set M} (hU : U ∈ nhds 1) : ∃ (V : set M), is_open V ∧ 1 ∈ V ∧ V * V ⊆ U
theorem has_fpower_series_at.apply_eq_zero {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] {p : formal_multilinear_series 𝕜 E F} {x : E} (h : has_fpower_series_at 0 p x) (n : ℕ) (y : E) : ⇑(p n) (λ (i : fin n), y) = 0
theorem lipschitz_with.dist_le_mul {α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {K : nnreal} {f : α → β} : lipschitz_with K f → ∀ (x y : α), has_dist.dist (f x) (f y) ≤ ↑K * has_dist.dist x y
theorem module.free.finrank_direct_sum (R : Type u) [ring R] [strong_rank_condition R] {ι : Type v} [fintype ι] (M : ι → Type w) [Π (i : ι), add_comm_group (M i)] [Π (i : ι), module R (M i)] [∀ (i : ι), module.free R (M i)] [∀ (i : ι), module.finite R (M i)] : finite_dimensional.finrank R (direct_sum ι (λ (i : ι), M i)) = finset.univ.sum (λ (i : ι), finite_dimensional.finrank R (M i))
theorem concave_on.translate_left {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [ordered_add_comm_monoid β] [module 𝕜 E] [has_scalar 𝕜 β] {s : set E} {f : E → β} (hf : concave_on 𝕜 s f) (c : E) : concave_on 𝕜 ((λ (z : E), c + z) ⁻¹' s) (f ∘ λ (z : E), z + c)
theorem mem_nhds_within_Iic_iff_exists_Icc_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_min_order α] [densely_ordered α] {a : α} {s : set α} : s ∈ nhds_within a (set.Iic a) ↔ ∃ (l : α), l < a ∧ set.Icc l a ⊆ s
theorem nat.factorization_eq_of_coprime_right {p a b : ℕ} (hab : a.coprime b) (hpb : p ∈ b.factors) : ⇑((a * b).factorization) p = ⇑(b.factorization) p
theorem lie_submodule.lie_ideal_oper_eq_linear_span {R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (N : lie_submodule R L M) (I : lie_ideal R L) : ↑⁅I,N⁆ = submodule.span R {m : M | ∃ (x : ↥I) (n : ↥N), ⁅↑x,↑n⁆ = m}
theorem minpoly.degree_pos {A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] [nontrivial B] {x : B} (hx : is_integral A x) : 0 < (minpoly A x).degree
theorem is_conformal_map_iff_is_complex_or_conj_linear {g : ℂ →L[ℝ] ℂ} : is_conformal_map g ↔ ((∃ (map : ℂ →L[ℂ] ℂ), continuous_linear_map.restrict_scalars ℝ map = g) ∨ ∃ (map : ℂ →L[ℂ] ℂ), continuous_linear_map.restrict_scalars ℝ map = g.comp ↑complex.conj_cle) ∧ g ≠ 0
theorem is_min.to_dual {α : Type u_1} [has_le α] {a : α} : is_min a → is_max (⇑order_dual.to_dual a)
theorem orthonormal.oangle_add_cyc3_neg_left {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle (-x) y + hb.oangle (-y) z + hb.oangle (-z) x = ↑real.pi
theorem inner_product_geometry.sin_angle_add_angle_sub_add_angle_sub_eq_zero {V : Type u_1} [inner_product_space ℝ V] {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : real.sin (inner_product_geometry.angle x y + inner_product_geometry.angle x (x - y) + inner_product_geometry.angle y (y - x)) = 0
theorem nat.fib_gcd (m n : ℕ) : nat.fib (m.gcd n) = (nat.fib m).gcd (nat.fib n)
theorem convex.closure_subset_image_homothety_interior_of_one_lt {E : Type u_2} [add_comm_group E] [module ℝ E] [topological_space E] [topological_add_group E] [has_continuous_smul ℝ E] {s : set E} (hs : convex ℝ s) {x : E} (hx : x ∈ interior s) (t : ℝ) (ht : 1 < t) : closure s ⊆ ⇑(affine_map.homothety x t) '' interior s
theorem is_cyclotomic_extension.prime_ne_two_norm_zeta_sub_one {p : ℕ+} {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [ne_zero ↑↑p] [hpri : fact (nat.prime ↑p)] [hcyc : is_cyclotomic_extension {p} K L] (hirr : irreducible (polynomial.cyclotomic ↑p K)) (h : p ≠ 2) : ⇑(algebra.norm K) (is_cyclotomic_extension.zeta p K L - 1) = ↑p
theorem asymptotics.is_o.neg_right {α : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : α → E} {g' : α → F'} {l : filter α} : f =o[l] g' → (f =o[l] λ (x : α), -g' x)
theorem real.sqrt_one_add_sinh_sq (x : ℝ) : real.sqrt (1 + real.sinh x ^ 2) = real.cosh x
theorem measure_theory.measure.add_haar_image_linear_map {E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (f : E →ₗ[ℝ] E) (s : set E) : ⇑μ (⇑f '' s) = ennreal.of_real |⇑linear_map.det f| * ⇑μ s
theorem supr_inf_le_inf_Sup {α : Type u_1} [complete_lattice α] {a : α} {s : set α} : (⨆ (b : α) (H : b ∈ s), a ⊓ b) ≤ a ⊓ has_Sup.Sup s
theorem quotient_norm_nonneg {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (x : M ⧸ S) : 0 ≤ ∥x∥
theorem unique_mdiff_on.smooth_bundle_preimage {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} {F : Type u_8} [normed_group F] [normed_space 𝕜 F] (Z : basic_smooth_vector_bundle_core I M F) (hs : unique_mdiff_on I s) : unique_mdiff_on (I.prod (model_with_corners_self 𝕜 F)) (Z.to_topological_vector_bundle_core.proj ⁻¹' s)
theorem function.commute.right_bij_on_fixed_pts_comp {α : Type u} {f g : α → α} (h : function.commute f g) : set.bij_on g (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g))
theorem is_complete_image_iff {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] {m : α → β} {s : set α} (hm : uniform_inducing m) : is_complete (m '' s) ↔ is_complete s
theorem tsum_lt_tsum_of_nonneg {i : ℕ} {f g : ℕ → ℝ} (h0 : ∀ (b : ℕ), 0 ≤ f b) (h : ∀ (b : ℕ), f b ≤ g b) (hi : f i < g i) (hg : summable g) : ∑' (n : ℕ), f n < ∑' (n : ℕ), g n
theorem is_preirreducible.subset_irreducible {α : Type u} [topological_space α] {S U Z : set α} (hZ : is_preirreducible Z) (hU : U.nonempty) (hU' : is_open U) (h₁ : U ⊆ S) (h₂ : S ⊆ Z) : is_irreducible S
theorem continuous_at_of_tendsto_nhds {α : Type u} {β : Type v} [topological_space α] [topological_space β] [t1_space β] {f : α → β} {a : α} {b : β} (h : filter.tendsto f (nhds a) (nhds b)) : continuous_at f a
theorem matrix.sum_cramer {n : Type u} [decidable_eq n] [fintype n] {α : Type v} [comm_ring α] (A : matrix n n α) {β : Type u_1} (s : finset β) (f : β → n → α) : s.sum (λ (x : β), ⇑(A.cramer) (f x)) = ⇑(A.cramer) (s.sum (λ (x : β), f x))
theorem monoid_algebra.alg_hom_ext {k : Type u₁} {G : Type u₂} [comm_semiring k] [monoid G] {A : Type u₃} [semiring A] [algebra k A] ⦃φ₁ φ₂ : monoid_algebra k G →ₐ[k] A⦄ (h : ∀ (x : G), ⇑φ₁ (finsupp.single x 1) = ⇑φ₂ (finsupp.single x 1)) : φ₁ = φ₂
theorem topological_space.is_topological_basis.sum {α : Type u} {β : Type u_1} [topological_space α] [topological_space β] {s : set (set α)} (hs : topological_space.is_topological_basis s) {t : set (set β)} (ht : topological_space.is_topological_basis t) : topological_space.is_topological_basis ((λ (u : set α), sum.inl '' u) '' s ∪ (λ (u : set β), sum.inr '' u) '' t)
theorem add_hom.congr_arg {M : Type u_3} {N : Type u_4} [has_add M] [has_add N] (f : add_hom M N) {x y : M} (h : x = y) : ⇑f x = ⇑f y
theorem zmod.legendre_sym_neg_one (p : ℕ) [fact (nat.prime p)] (hp : p ≠ 2) : zmod.legendre_sym p (-1) = ⇑zmod.χ₄ ↑p
theorem subgroup.closure_mul_image_eq_top {G : Type u_1} [group G] {H : subgroup G} {R S : set G} (hR : R ∈ subgroup.right_transversals ↑H) (hR1 : 1 ∈ R) (hS : subgroup.closure S = ⊤) : subgroup.closure ((λ (g : G), ⟨g * (↑(subgroup.mem_right_transversals.to_fun hR g))⁻¹, _⟩) '' (R * S)) = ⊤
theorem category_theory.induct_on_objects {J : Type u₁} [category_theory.category J] [category_theory.is_preconnected J] (p : set J) {j₀ : J} (h0 : j₀ ∈ p) (h1 : ∀ {j₁ j₂ : J}, (j₁ ⟶ j₂) → (j₁ ∈ p ↔ j₂ ∈ p)) (j : J) : j ∈ p
theorem measure_theory.lintegral_supr {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : ℕ → α → ennreal} (hf : ∀ (n : ℕ), measurable (f n)) (h_mono : monotone f) : ∫⁻ (a : α), (⨆ (n : ℕ), f n a) ∂μ = ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
theorem mul_neg_one {α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : a * -1 = -a
theorem measure_theory.measure.haar.is_left_invariant_haar_content {G : Type u_1} [group G] [topological_space G] [topological_group G] [t2_space G] {K₀ : topological_space.positive_compacts G} (g : G) (K : topological_space.compacts G) : ⇑(measure_theory.measure.haar.haar_content K₀) (topological_space.compacts.map (λ (b : G), g * b) _ K) = ⇑(measure_theory.measure.haar.haar_content K₀) K
theorem three_pos {α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 3
theorem norm_image_sub_le_of_norm_deriv_le_segment' {E : Type u_1} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} {f' : ℝ → E} {C : ℝ} (hf : ∀ (x : ℝ), x ∈ set.Icc a b → has_deriv_within_at f (f' x) (set.Icc a b) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → ∥f' x∥ ≤ C) (x : ℝ) (H : x ∈ set.Icc a b) : ∥f x - f a∥ ≤ C * (x - a)
theorem indexed_partition.index_out' {ι : Type u_1} {α : Type u_2} {s : ι → set α} (hs : indexed_partition s) (x : hs.quotient) : hs.index (quotient.out' x) = hs.index (⇑(hs.out) x)
theorem affine.simplex.monge_point_vsub_face_centroid_weights_with_circumcenter_eq_sub {n : ℕ} {i₁ i₂ : fin (n + 3)} (h : i₁ ≠ i₂) : affine.simplex.monge_point_vsub_face_centroid_weights_with_circumcenter i₁ i₂ = affine.simplex.monge_point_weights_with_circumcenter n - affine.simplex.centroid_weights_with_circumcenter {i₁, i₂}ᶜ
theorem finset.max'_singleton {α : Type u_1} [linear_order α] (a : α) : {a}.max' _ = a
theorem nat.partrec.code.exists_code {f : ℕ →. ℕ} : nat.partrec f ↔ ∃ (c : nat.partrec.code), c.eval = f
theorem path.homotopic.comp_prod_eq_prod_comp {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {a₁ a₂ a₃ : α} {b₁ b₂ b₃ : β} (q₁ : path.homotopic.quotient a₁ a₂) (q₂ : path.homotopic.quotient b₁ b₂) (r₁ : path.homotopic.quotient a₂ a₃) (r₂ : path.homotopic.quotient b₂ b₃) : (path.homotopic.prod q₁ q₂).comp (path.homotopic.prod r₁ r₂) = path.homotopic.prod (q₁.comp r₁) (q₂.comp r₂)
theorem category_theory.is_pullback.of_is_product {C : Type u₁} [category_theory.category C] {X Y Z : C} {c : category_theory.limits.binary_fan X Y} (h : category_theory.limits.is_limit c) (t : category_theory.limits.is_terminal Z) : category_theory.is_pullback c.fst c.snd (t.from ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.left})) (t.from ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.right}))
theorem continuous_map.continuous_eval' {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α] : continuous (λ (p : C(α, β) × α), ⇑(p.fst) p.snd)
theorem inner_product_geometry.cos_angle_sub_add_angle_sub_rev_eq_neg_cos_angle {V : Type u_1} [inner_product_space ℝ V] {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : real.cos (inner_product_geometry.angle x (x - y) + inner_product_geometry.angle y (y - x)) = -real.cos (inner_product_geometry.angle x y)
theorem add_is_add_left_regular_iff {R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_left_regular a) : is_add_left_regular (a + b) ↔ is_add_left_regular b
theorem metric.complete_of_convergent_controlled_sequences {α : Type u} [pseudo_metric_space α] (B : ℕ → ℝ) (hB : ∀ (n : ℕ), 0 < B n) (H : ∀ (u : ℕ → α), (∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < B N) → (∃ (x : α), filter.tendsto u filter.at_top (nhds x))) : complete_space α
theorem convex_hull_exists_dist_ge {E : Type u_2} [semi_normed_group E] [normed_space ℝ E] {s : set E} {x : E} (hx : x ∈ ⇑(convex_hull ℝ) s) (y : E) : ∃ (x' : E) (H : x' ∈ s), has_dist.dist x y ≤ has_dist.dist x' y
theorem continuous_multilinear_map.op_norm_add_le {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f g : continuous_multilinear_map 𝕜 E G) : ∥f + g∥ ≤ ∥f∥ + ∥g∥
theorem topological_group.continuous_conj {G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] (g : G) : continuous (λ (h : G), g * h * g⁻¹)
theorem inner_product_geometry.norm_sub_eq_abs_sub_norm_iff_angle_eq_zero {V : Type u_1} [inner_product_space ℝ V] {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : ∥x - y∥ = |∥x∥ - ∥y∥| ↔ inner_product_geometry.angle x y = 0
theorem vitali.exists_disjoint_subfamily_covering_enlargment_closed_ball {α : Type u_1} [metric_space α] (t : set (set α)) (R : ℝ) (ht : ∀ (s : set α), s ∈ t → (∃ (x : α) (r : ℝ), s = metric.closed_ball x r ∧ r ≤ R)) : ∃ (u : set (set α)) (H : u ⊆ t), u.pairwise_disjoint id ∧ ∀ (a : set α), a ∈ t → (∃ (x : α) (r : ℝ), metric.closed_ball x r ∈ u ∧ a ⊆ metric.closed_ball x (5 * r))
theorem convex.mem_Ico {𝕜 : Type u_1} [linear_ordered_field 𝕜] {x y : 𝕜} (h : x < y) {z : 𝕜} : z ∈ set.Ico x y ↔ ∃ (a b : 𝕜), 0 < a ∧ 0 ≤ b ∧ a + b = 1 ∧ a * x + b * y = z
theorem neg_pow_two {R : Type u₁} [monoid R] [has_distrib_neg R] (a : R) : (-a) ^ 2 = a ^ 2
theorem submodule.no_zero_smul_divisors_iff_torsion_eq_bot {R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] [no_zero_divisors R] [nontrivial R] : no_zero_smul_divisors R M ↔ submodule.torsion R M = ⊥
theorem pi_nat.cylinder_longest_prefix_eq_of_longest_prefix_lt_first_diff {E : ℕ → Type u_1} [Π (n : ℕ), topological_space (E n)] [∀ (n : ℕ), discrete_topology (E n)] {x y : Π (n : ℕ), E n} {s : set (Π (n : ℕ), E n)} (hs : is_closed s) (hne : s.nonempty) (H : pi_nat.longest_prefix x s < pi_nat.first_diff x y) (xs : x ∉ s) (ys : y ∉ s) : pi_nat.cylinder x (pi_nat.longest_prefix x s) = pi_nat.cylinder y (pi_nat.longest_prefix y s)
theorem add_action.card_eq_sum_card_add_group_sub_card_stabilizer (α : Type u) (β : Type v) [add_group α] [add_action α β] [fintype α] [fintype β] [fintype (quotient (add_action.orbit_rel α β))] [Π (b : β), fintype ↥(add_action.stabilizer α b)] : fintype.card β = finset.univ.sum (λ (ω : quotient (add_action.orbit_rel α β)), fintype.card α / fintype.card ↥(add_action.stabilizer α ω.out'))
theorem local_equiv.eq_on_source.restr {α : Type u_1} {β : Type u_2} {e e' : local_equiv α β} (he : e ≈ e') (s : set α) : e.restr s ≈ e'.restr s
theorem mul_self_sub_mul_self {R : Type x} [comm_ring R] (a b : R) : a * a - b * b = (a + b) * (a - b)
theorem function.injective.no_zero_divisors {M₀ : Type u_1} {M₀' : Type u_3} [has_mul M₀] [has_zero M₀] [has_mul M₀'] [has_zero M₀'] [no_zero_divisors M₀'] (f : M₀ → M₀') (hf : function.injective f) (zero : f 0 = 0) (mul : ∀ (x y : M₀), f (x * y) = f x * f y) : no_zero_divisors M₀
theorem continuous_map.continuous_uncurry {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] [locally_compact_space α] [locally_compact_space β] : continuous continuous_map.uncurry
theorem matrix.circulant_is_symm_apply {α : Type u_1} {n : Type u_4} [add_group n] {v : n → α} (h : (matrix.circulant v).is_symm) (i : n) : v (-i) = v i
theorem set.finite.finite_subsets {α : Type u} {a : set α} (h : a.finite) : {b : set α | b ⊆ a}.finite
theorem mv_polynomial.esymm_eq_sum_monomial (σ : Type u_1) (R : Type u_2) [comm_semiring R] [fintype σ] (n : ℕ) : mv_polynomial.esymm σ R n = (finset.powerset_len n finset.univ).sum (λ (t : finset σ), ⇑(mv_polynomial.monomial (t.sum (λ (i : σ), finsupp.single i 1))) 1)
theorem normed_group_hom.equalizer.lift_norm_noninc {V : Type u_1} {W : Type u_2} {V₁ : Type u_3} [semi_normed_group V] [semi_normed_group W] [semi_normed_group V₁] {f g : normed_group_hom V W} (φ : normed_group_hom V₁ V) (h : f.comp φ = g.comp φ) (hφ : φ.norm_noninc) : (normed_group_hom.equalizer.lift φ h).norm_noninc
theorem measure_theory.outer_measure.infi_apply {α : Type u_1} {ι : Sort u_2} [nonempty ι] (m : ι → measure_theory.outer_measure α) (s : set α) : (⇑⨅ (i : ι), m i) s = ⨅ (t : ℕ → set α) (h2 : s ⊆ set.Union t), ∑' (n : ℕ), ⨅ (i : ι), ⇑(m i) (t n)
theorem measure_theory.uniform_integrable_subsingleton {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [normed_group β] {p : ennreal} {f : ι → α → β} [subsingleton ι] (hp_one : 1 ≤ p) (hp_top : p ≠ ⊤) (hf : ∀ (i : ι), measure_theory.strongly_measurable (f i)) (hf' : ∀ (i : ι), measure_theory.mem_ℒp (f i) p μ) : measure_theory.uniform_integrable f p μ
theorem add_con.ker_eq_lift_of_injective {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] (c : add_con M) (f : M →+ P) (H : c ≤ add_con.ker f) (h : function.injective ⇑(c.lift f H)) : add_con.ker f = c
theorem matrix.right_inv_eq_right_inv {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {A B C : matrix n n α} (h : A.mul B = 1) (g : A.mul C = 1) : B = C
theorem mv_polynomial.mem_map_C_iff {R : Type u} {σ : Type v} [comm_ring R] {I : ideal R} {f : mv_polynomial σ R} : f ∈ ideal.map mv_polynomial.C I ↔ ∀ (m : σ →₀ ℕ), mv_polynomial.coeff m f ∈ I
theorem continuous_linear_map.has_sum {ι : Type u_10} {R : Type u_11} {R₂ : Type u_12} {M : Type u_13} {M₂ : Type u_14} [semiring R] [semiring R₂] [add_comm_monoid M] [module R M] [add_comm_monoid M₂] [module R₂ M₂] [topological_space M] [topological_space M₂] {σ : R →+* R₂} {f : ι → M} (φ : M →SL[σ] M₂) {x : M} (hf : has_sum f x) : has_sum (λ (b : ι), ⇑φ (f b)) (⇑φ x)
theorem filter.exists_ultrafilter_le {α : Type u} (f : filter α) [h : f.ne_bot] : ∃ (u : ultrafilter α), ↑u ≤ f
theorem orthonormal.eq_iff_norm_eq_of_oangle_eq_zero {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y : V} (h : hb.oangle x y = 0) : x = y ↔ ∥x∥ = ∥y∥
theorem subgroup.is_normal_topological_closure {G : Type u_1} [topological_space G] [group G] [topological_group G] (N : subgroup G) [N.normal] : N.topological_closure.normal
theorem linear_independent.injective_total {ι : Type u_1} {R : Type u_3} {M : Type u_5} {v : ι → M} [ring R] [add_comm_group M] [module R M] : linear_independent R v → function.injective ⇑(finsupp.total ι M R v)
theorem set.subsingleton_of_image {α : Type u_1} {β : Type u_2} {f : α → β} (hf : function.injective f) (s : set α) (hs : (f '' s).subsingleton) : s.subsingleton
theorem affine_subspace.exists_of_lt {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s1 s2 : affine_subspace k P} (h : s1 < s2) : ∃ (p : P) (H : p ∈ s2), p ∉ s1
theorem mem_ball_comp {β : Type u_2} {V W : set (β × β)} {x y z : β} (h : y ∈ uniform_space.ball x V) (h' : z ∈ uniform_space.ball y W) : z ∈ uniform_space.ball x (comp_rel V W)
theorem monotone_on.dual_right {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s : set α} : monotone_on f s → antitone_on (⇑order_dual.to_dual ∘ f) s
theorem finite_dimensional.finrank_fin_fun (K : Type u) [division_ring K] {n : ℕ} : finite_dimensional.finrank K (fin n → K) = n
theorem vsub_self {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : p -ᵥ p = 0
theorem submodule.eq_smul_of_le_smul_of_le_jacobson {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {I J : ideal R} {N : submodule R M} (hN : N.fg) (hIN : N ≤ I • N) (hIjac : I ≤ J.jacobson) : N = J • N
theorem right.mul_lt_mul {α : Type u_1} [has_mul α] [preorder α] [covariant_class α α has_mul.mul has_le.le] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b c d : α} (h₁ : a < b) (h₂ : c < d) : a * c < b * d
theorem metric.bounded_of_bdd_above_of_bdd_below {α : Type u} [pseudo_metric_space α] [preorder α] [compact_Icc_space α] {s : set α} (h₁ : bdd_above s) (h₂ : bdd_below s) : metric.bounded s
theorem nsmul_eq_mod_nsmul {M : Type u_1} [add_monoid M] {x : M} (m : ℕ) {n : ℕ} (h : n • x = 0) : m • x = (m % n) • x
theorem real_inner_sub_sub_self {F : Type u_3} [inner_product_space ℝ F] {x y : F} : has_inner.inner (x - y) (x - y) = has_inner.inner x x - 2 * has_inner.inner x y + has_inner.inner y y
theorem linear_map.continuous_of_seq_closed_graph {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] [complete_space F] [complete_space E] (g : E →ₗ[𝕜] F) (hg : ∀ (u : ℕ → E) (x : E) (y : F), filter.tendsto u filter.at_top (nhds x) → filter.tendsto (⇑g ∘ u) filter.at_top (nhds y) → y = ⇑g x) : continuous ⇑g
theorem category_theory.sheaf.is_sheaf_for_trans {C : Type u} [category_theory.category C] {X : C} (P : Cᵒᵖ ⥤ Type v) (R S : category_theory.sieve X) (hR : category_theory.presieve.is_sheaf_for P ⇑R) (hR' : ∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, ⇑S f → category_theory.presieve.is_separated_for P ⇑(category_theory.sieve.pullback f R)) (hS : ∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, ⇑R f → category_theory.presieve.is_sheaf_for P ⇑(category_theory.sieve.pullback f S)) : category_theory.presieve.is_sheaf_for P ⇑S
theorem asymptotics.is_O_with_iff {α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {c : ℝ} {f : α → E} {g : α → F} {l : filter α} : asymptotics.is_O_with c l f g ↔ ∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g x∥
theorem multilinear_map.map_sum_finset_aux {R : Type u} {ι : Type u'} {M₁ : ι → Type v₁} {M₂ : Type v₂} [decidable_eq ι] [semiring R] [Π (i : ι), add_comm_monoid (M₁ i)] [add_comm_monoid M₂] [Π (i : ι), module R (M₁ i)] [module R M₂] (f : multilinear_map R M₁ M₂) {α : ι → Type u_1} (g : Π (i : ι), α i → M₁ i) (A : Π (i : ι), finset (α i)) [fintype ι] {n : ℕ} (h : finset.univ.sum (λ (i : ι), (A i).card) = n) : ⇑f (λ (i : ι), (A i).sum (λ (j : α i), g i j)) = (fintype.pi_finset A).sum (λ (r : Π (a : ι), α a), ⇑f (λ (i : ι), g i (r i)))
theorem category_theory.limits.is_iso_limit_cocone_parallel_pair_of_epi {C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} {c : category_theory.limits.cofork f g} (h : category_theory.limits.is_colimit c) [category_theory.mono c.π] : category_theory.is_iso c.π
theorem add_monoid_hom.map_list_sum {M : Type u_3} {N : Type u_4} [add_monoid M] [add_monoid N] (f : M →+ N) (l : list M) : ⇑f l.sum = (list.map ⇑f l).sum
theorem inner_product_space.is_self_adjoint.direct_sum_is_internal {𝕜 : Type u_1} [is_R_or_C 𝕜] [dec_𝕜 : decidable_eq 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] {T : E →ₗ[𝕜] E} (hT : inner_product_space.is_self_adjoint T) [finite_dimensional 𝕜 E] : direct_sum.is_internal (λ (μ : module.End.eigenvalues T), module.End.eigenspace T ↑μ)
theorem exists_seq_of_forall_finset_exists' {α : Type u_1} (P : α → Prop) (r : α → α → Prop) [is_symm α r] (h : ∀ (s : finset α), (∀ (x : α), x ∈ s → P x) → (∃ (y : α), P y ∧ ∀ (x : α), x ∈ s → r x y)) : ∃ (f : ℕ → α), (∀ (n : ℕ), P (f n)) ∧ ∀ (m n : ℕ), m ≠ n → r (f m) (f n)
theorem zmod.euler_criterion_units (p : ℕ) [fact (nat.prime p)] (x : (zmod p)ˣ) : (∃ (y : (zmod p)ˣ), y ^ 2 = x) ↔ x ^ (p / 2) = 1
theorem category_theory.free_bicategory.normalize_aux_congr {B : Type u} [quiver B] {a b c : B} (p : quiver.path a b) {f g : category_theory.free_bicategory.hom b c} (η : f ⟶ g) : category_theory.free_bicategory.normalize_aux p f = category_theory.free_bicategory.normalize_aux p g
theorem transcendental.irrational {r : ℝ} (tr : transcendental ℚ r) : irrational r
theorem riesz_extension {E : Type u_2} [add_comm_group E] [module ℝ E] (s : convex_cone ℝ E) (f : linear_pmap ℝ E ℝ) (nonneg : ∀ (x : ↥(f.domain)), ↑x ∈ s → 0 ≤ ⇑f x) (dense : ∀ (y : E), ∃ (x : ↥(f.domain)), ↑x + y ∈ s) : ∃ (g : E →ₗ[ℝ] ℝ), (∀ (x : ↥(f.domain)), ⇑g ↑x = ⇑f x) ∧ ∀ (x : E), x ∈ s → 0 ≤ ⇑g x
theorem ae_measurable.ae_strongly_measurable {α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [topological_space β] {f : α → β} [measurable_space β] [topological_space.pseudo_metrizable_space β] [opens_measurable_space β] [topological_space.second_countable_topology β] (hf : ae_measurable f μ) : measure_theory.ae_strongly_measurable f μ
theorem finsum_mem_induction {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} {s : set α} (p : M → Prop) (hp₀ : p 0) (hp₁ : ∀ (x y : M), p x → p y → p (x + y)) (hp₂ : ∀ (x : α), x ∈ s → p (f x)) : p (finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)))
theorem multiples.add_mem {M : Type u_1} [add_monoid M] {x y z : M} : y ∈ multiples x → z ∈ multiples x → y + z ∈ multiples x
theorem torus_integrable.torus_integrable_const {n : ℕ} {E : Type u_1} [normed_group E] (a : E) (c : fin n → ℂ) (R : fin n → ℝ) : torus_integrable (λ (_x : fin n → ℂ), a) c R
theorem orthonormal.oangle_rotation {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x y : V) (θ : real.angle) : hb.oangle (⇑(hb.rotation θ) x) (⇑(hb.rotation θ) y) = hb.oangle x y
theorem abs_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x : E} {r : 𝕜} (hx : x ≠ 0) (hr : r ≠ 0) : is_R_or_C.abs (has_inner.inner x (r • x)) / (∥x∥ * ∥r • x∥) = 1
theorem measure_theory.tendsto_integral_of_L1 {α : Type u_1} {E : Type u_2} [normed_group E] [normed_space ℝ E] [complete_space E] {m : measurable_space α} {μ : measure_theory.measure α} {ι : Type u_3} (f : α → E) (hfi : measure_theory.integrable f μ) {F : ι → α → E} {l : filter ι} (hFi : ∀ᶠ (i : ι) in l, measure_theory.integrable (F i) μ) (hF : filter.tendsto (λ (i : ι), ∫⁻ (x : α), ↑∥F i x - f x∥₊ ∂μ) l (nhds 0)) : filter.tendsto (λ (i : ι), ∫ (x : α), F i x ∂μ) l (nhds (∫ (x : α), f x ∂μ))
theorem cont_mdiff_on_symm_of_mem_maximal_atlas {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {n : with_top ℕ} {e : local_homeomorph M H} (h : e ∈ smooth_manifold_with_corners.maximal_atlas I M) : cont_mdiff_on I I n ⇑(e.symm) e.to_local_equiv.target
theorem finsupp.sum_ite_eq' {α : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [add_comm_monoid N] [decidable_eq α] (f : α →₀ M) (a : α) (b : α → M → N) : f.sum (λ (x : α) (v : M), ite (x = a) (b x v) 0) = ite (a ∈ f.support) (b a (⇑f a)) 0
theorem orthonormal.oangle_smul_right_self_of_nonneg {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x : V) {r : ℝ} (hr : 0 ≤ r) : hb.oangle x (r • x) = 0
theorem left.one_le_inv_iff {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : 1 ≤ a⁻¹ ↔ a ≤ 1
theorem same_ray.exists_nonneg_left {R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} (h : same_ray R x y) (hx : x ≠ 0) : ∃ (r : R), 0 ≤ r ∧ r • x = y
theorem module.directed_system.map_self {R : Type u} [ring R] {ι : Type v} [preorder ι] {G : ι → Type w} [Π (i : ι), add_comm_group (G i)] [Π (i : ι), module R (G i)] (f : Π (i j : ι), i ≤ j → (G i →ₗ[R] G j)) [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] (i : ι) (x : G i) (h : i ≤ i) : ⇑(f i i h) x = x
theorem first_order.language.Theory.exists_elementary_embedding_card_eq {L : first_order.language} (M : Type w') [L.Structure M] [iM : infinite M] (κ : cardinal) (h1 : L.card.lift ≤ κ.lift) (h2 : (cardinal.mk M).lift ≤ κ.lift) : ∃ (N : category_theory.bundled L.Structure), nonempty (L.elementary_embedding M ↥N) ∧ cardinal.mk ↥N = κ.lift
theorem cardinal.lift_mk_le' {α : Type u} {β : Type v} : (cardinal.mk α).lift ≤ (cardinal.mk β).lift ↔ nonempty (α ↪ β)
theorem metric.Hausdorff_dist_empty' {α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist ∅ s = 0
theorem module.End.eigenspaces_independent {K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] (f : module.End K V) : complete_lattice.independent f.eigenspace
theorem category_theory.presheaf.subsingleton_iff_is_separated_for {C : Type u₁} [category_theory.category C] {A : Type u₂} [category_theory.category A] (P : Cᵒᵖ ⥤ A) {X : C} (S : category_theory.sieve X) : (∀ (c : category_theory.limits.cone (S.arrows.diagram.op ⋙ P)), subsingleton (c ⟶ P.map_cone S.arrows.cocone.op)) ↔ ∀ (E : Aᵒᵖ), category_theory.presieve.is_separated_for (P ⋙ category_theory.coyoneda.obj E) ⇑S
theorem list.head_add_tail_sum (L : list ℕ) : L.head + L.tail.sum = L.sum
theorem nat.perm_factors_mul {a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0) : (a * b).factors ~ a.factors ++ b.factors
theorem continuous_linear_map.le_op_norm {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [ring_hom_isometric σ₁₂] (f : E →SL[σ₁₂] F) (x : E) : ∥⇑f x∥ ≤ ∥f∥ * ∥x∥
theorem zero_lt.left.one_lt_mul_of_lt_of_lt {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 1 < a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b
theorem real.rpow_sum_le_const_mul_sum_rpow_of_nonneg {ι : Type u} (s : finset ι) {f : ι → ℝ} {p : ℝ} (hp : 1 ≤ p) (hf : ∀ (i : ι), i ∈ s → 0 ≤ f i) : s.sum (λ (i : ι), f i) ^ p ≤ ↑(s.card) ^ (p - 1) * s.sum (λ (i : ι), f i ^ p)
theorem linear_map.det_to_matrix_eq_det_to_matrix {M : Type u_2} [add_comm_group M] {ι : Type u_4} [decidable_eq ι] [fintype ι] {A : Type u_5} [comm_ring A] [module A M] {κ : Type u_6} [fintype κ] [decidable_eq κ] (b : basis ι A M) (c : basis κ A M) (f : M →ₗ[A] M) : (⇑(linear_map.to_matrix b b) f).det = (⇑(linear_map.to_matrix c c) f).det
theorem set.partially_well_ordered_on.partially_well_ordered_on_sublist_forall₂ {α : Type u_1} (r : α → α → Prop) [is_refl α r] [is_trans α r] {s : set α} (h : s.partially_well_ordered_on r) : {l : list α | ∀ (x : α), x ∈ l → x ∈ s}.partially_well_ordered_on (list.sublist_forall₂ r)
theorem category_theory.functor.left_derived_map_eq {C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] [category_theory.preadditive C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] [category_theory.has_projective_resolutions C] [category_theory.preadditive D] [category_theory.limits.has_zero_object D] [category_theory.limits.has_equalizers D] [category_theory.limits.has_cokernels D] [category_theory.limits.has_images D] [category_theory.limits.has_image_maps D] (F : C ⥤ D) [F.additive] (n : ℕ) {X Y : C} (f : X ⟶ Y) {P : category_theory.ProjectiveResolution X} {Q : category_theory.ProjectiveResolution Y} (g : P.complex ⟶ Q.complex) (w : g ≫ Q.π = P.π ≫ (chain_complex.single₀ C).map f) : (F.left_derived n).map f = (F.left_derived_obj_iso n P).hom ≫ (homology_functor D (complex_shape.down ℕ) n).map ((F.map_homological_complex (complex_shape.down ℕ)).map g) ≫ (F.left_derived_obj_iso n Q).inv
theorem fin.cons_snoc_eq_snoc_cons {n : ℕ} {β : Type u_1} (a : β) (q : fin n → β) (b : β) : fin.cons a (fin.snoc q b) = fin.snoc (fin.cons a q) b
theorem nat.squarefree_mul {m n : ℕ} (hmn : m.coprime n) : squarefree (m * n) ↔ squarefree m ∧ squarefree n
theorem is_pullback.map {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) {W X Y Z : C} {f : W ⟶ X} {g : W ⟶ Y} {h : X ⟶ Z} {i : Y ⟶ Z} [category_theory.limits.preserves_limit (category_theory.limits.cospan h i) F] (s : category_theory.is_pullback f g h i) : category_theory.is_pullback (F.map f) (F.map g) (F.map h) (F.map i)
theorem euclidean_geometry.angle_add_angle_eq_pi_of_angle_eq_pi {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (p1 : P) {p2 p3 p4 : P} (h : euclidean_geometry.angle p2 p3 p4 = real.pi) : euclidean_geometry.angle p1 p3 p2 + euclidean_geometry.angle p1 p3 p4 = real.pi
theorem category_theory.limits.colimit.pre_eq {J : Type u₁} [category_theory.category J] {K : Type u₂} [category_theory.category K] {C : Type u} [category_theory.category C] {F : J ⥤ C} [category_theory.limits.has_colimit F] {E : K ⥤ J} [category_theory.limits.has_colimit (E ⋙ F)] (s : category_theory.limits.colimit_cocone (E ⋙ F)) (t : category_theory.limits.colimit_cocone F) : category_theory.limits.colimit.pre F E = (category_theory.limits.colimit.iso_colimit_cocone s).hom ≫ s.is_colimit.desc (category_theory.limits.cocone.whisker E t.cocone) ≫ (category_theory.limits.colimit.iso_colimit_cocone t).inv
theorem emetric.mem_closure_iff {α : Type u} [pseudo_emetric_space α] {x : α} {s : set α} : x ∈ closure s ↔ ∀ (ε : ennreal), ε > 0 → (∃ (y : α) (H : y ∈ s), has_edist.edist x y < ε)
theorem category_theory.limits.has_finite_coproducts_of_has_coproducts (C : Type u) [category_theory.category C] [category_theory.limits.has_coproducts C] : category_theory.limits.has_finite_coproducts C
theorem ring_equiv.map_mul {R : Type u_4} {S : Type u_5} [has_mul R] [has_add R] [has_mul S] [has_add S] (e : R ≃+* S) (x y : R) : ⇑e (x * y) = ⇑e x * ⇑e y
theorem seq.ge_stable {α : Type u} (s : seq α) {aₙ : α} {n m : ℕ} (m_le_n : m ≤ n) (s_nth_eq_some : s.nth n = option.some aₙ) : ∃ (aₘ : α), s.nth m = option.some aₘ
theorem lipschitz_on_with.of_le_add_mul' {α : Type u} [pseudo_metric_space α] {s : set α} {f : α → ℝ} (K : ℝ) (h : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → f x ≤ f y + K * has_dist.dist x y) : lipschitz_on_with K.to_nnreal f s
theorem nat.not_exists_sq {n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬∃ (t : ℕ), t * t = n
theorem pi.single_eq_of_ne' {I : Type u} {f : I → Type v₁} [decidable_eq I] [Π (i : I), has_zero (f i)] {i i' : I} (h : i ≠ i') (x : f i) : pi.single i x i' = 0
theorem complete_space_of_is_complete_univ {α : Type u} [uniform_space α] (h : is_complete set.univ) : complete_space α
theorem multiset.Ico_eq_zero {α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → multiset.Ico a b = 0
theorem multilinear_map.map_piecewise_add {R : Type u} {ι : Type u'} {M₁ : ι → Type v₁} {M₂ : Type v₂} [decidable_eq ι] [semiring R] [Π (i : ι), add_comm_monoid (M₁ i)] [add_comm_monoid M₂] [Π (i : ι), module R (M₁ i)] [module R M₂] (f : multilinear_map R M₁ M₂) (m m' : Π (i : ι), M₁ i) (t : finset ι) : ⇑f (t.piecewise (m + m') m') = t.powerset.sum (λ (s : finset ι), ⇑f (s.piecewise m m'))
theorem continuous_at.fst'' {α : Type u} {β : Type v} {γ : Type u_1} [topological_space α] [topological_space β] [topological_space γ] {f : α → γ} {x : α × β} (hf : continuous_at f x.fst) : continuous_at (λ (x : α × β), f x.fst) x
theorem polynomial.cyclotomic_irreducible_pow_of_irreducible_pow {p : ℕ} (hp : nat.prime p) {R : Type u_1} [comm_ring R] [is_domain R] {n m : ℕ} (hmn : m ≤ n) (h : irreducible (polynomial.cyclotomic (p ^ n) R)) : irreducible (polynomial.cyclotomic (p ^ m) R)
theorem finite_dimensional.finrank_pos_iff_exists_ne_zero {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V ↔ ∃ (x : V), x ≠ 0
theorem linear_independent.eq_of_smul_apply_eq_smul_apply {ι : Type u_1} {R : Type u_3} [ring R] {M : Type u_2} [add_comm_group M] [module R M] {v : ι → M} (li : linear_independent R v) (c d : R) (i j : ι) (hc : c ≠ 0) (h : c • v i = d • v j) : i = j
theorem category_theory.limits.complete_lattice.pullback_eq_inf {α : Type u} [semilattice_inf α] [order_top α] {x y z : α} (f : x ⟶ z) (g : y ⟶ z) : category_theory.limits.pullback f g = x ⊓ y
theorem dense_bInter_of_Gδ {α : Type u_1} {β : Type u_2} [topological_space α] [baire_space α] {S : set β} {f : Π (x : β), x ∈ S → set α} (ho : ∀ (s : β) (H : s ∈ S), is_Gδ (f s H)) (hS : S.countable) (hd : ∀ (s : β) (H : s ∈ S), dense (f s H)) : dense (⋂ (s : β) (H : s ∈ S), f s H)
theorem besicovitch.tau_package.color_lt {α : Type u_1} [metric_space α] {β : Type u} [nonempty β] (p : besicovitch.tau_package β α) {i : ordinal} (hi : i < p.last_step) {N : ℕ} (hN : is_empty (besicovitch.satellite_config α N p.τ)) : p.color i < N
theorem metric.uniform_cauchy_seq_on_iff {α : Type u} {β : Type v} [pseudo_metric_space α] [nonempty β] [semilattice_sup β] {γ : Type u_1} {F : β → γ → α} {s : set γ} : uniform_cauchy_seq_on F filter.at_top s ↔ ∀ (ε : ℝ), ε > 0 → (∃ (N : β), ∀ (m : β), m ≥ N → ∀ (n : β), n ≥ N → ∀ (x : γ), x ∈ s → has_dist.dist (F m x) (F n x) < ε)
theorem orthonormal.inner_products_summable {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} (x : E) {v : ι → E} (hv : orthonormal 𝕜 v) : summable (λ (i : ι), ∥has_inner.inner (v i) x∥ ^ 2)
theorem mem_closure_iff_seq_limit {X : Type u_1} [topological_space X] [sequential_space X] {s : set X} {a : X} : a ∈ closure s ↔ ∃ (x : ℕ → X), (∀ (n : ℕ), x n ∈ s) ∧ filter.tendsto x filter.at_top (nhds a)
theorem finite_dimensional.exists_relation_sum_zero_pos_coefficient_of_dim_succ_lt_card {L : Type u_1} [linear_ordered_field L] {W : Type v} [add_comm_group W] [module L W] [finite_dimensional L W] {t : finset W} (h : finite_dimensional.finrank L W + 1 < t.card) : ∃ (f : W → L), t.sum (λ (e : W), f e • e) = 0 ∧ t.sum (λ (e : W), f e) = 0 ∧ ∃ (x : W) (H : x ∈ t), 0 < f x
theorem ring_hom.eq_on_set_closure {R : Type u} {S : Type v} [ring R] [ring S] {f g : R →+* S} {s : set R} (h : set.eq_on ⇑f ⇑g s) : set.eq_on ⇑f ⇑g ↑(subring.closure s)
theorem finset.affine_combination_of_eq_one_of_eq_zero {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (w : ι → k) (p : ι → P) {i : ι} (his : i ∈ s) (hwi : w i = 1) (hw0 : ∀ (i2 : ι), i2 ∈ s → i2 ≠ i → w i2 = 0) : ⇑(s.affine_combination p) w = p i
theorem edist_le_range_sum_of_edist_le {α : Type u} [pseudo_emetric_space α] {f : ℕ → α} (n : ℕ) {d : ℕ → ennreal} (hd : ∀ {k : ℕ}, k < n → has_edist.edist (f k) (f (k + 1)) ≤ d k) : has_edist.edist (f 0) (f n) ≤ (finset.range n).sum (λ (i : ℕ), d i)
theorem function.periodic.tendsto_at_top_interval_integral_of_pos {T : ℝ} {g : ℝ → ℝ} (hg : function.periodic g T) (h_int : ∀ (t₁ t₂ : ℝ), interval_integrable g measure_theory.measure_space.volume t₁ t₂) (h₀ : 0 < ∫ (x : ℝ) in 0..T, g x) (hT : 0 < T) : filter.tendsto (λ (t : ℝ), ∫ (x : ℝ) in 0..t, g x) filter.at_top filter.at_top
theorem padic_val_rat.finite_int_prime_iff {p : ℕ} [p_prime : fact (nat.prime p)] {a : ℤ} : multiplicity.finite ↑p a ↔ a ≠ 0
theorem inner_product_geometry.inner_eq_neg_mul_norm_iff_angle_eq_pi {V : Type u_1} [inner_product_space ℝ V] {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : has_inner.inner x y = -(∥x∥ * ∥y∥) ↔ inner_product_geometry.angle x y = real.pi
theorem char.quadratic_char_sq_one {F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0) : char.quadratic_char F a ^ 2 = 1
theorem is_bounded_linear_map_continuous_multilinear_map_comp_linear {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {ι : Type u_5} [decidable_eq ι] [fintype ι] (g : G →L[𝕜] E) : is_bounded_linear_map 𝕜 (λ (f : continuous_multilinear_map 𝕜 (λ (i : ι), E) F), f.comp_continuous_linear_map (λ (_x : ι), g))
theorem generalized_continued_fraction.int_fract_pair.nth_stream_fr_nonneg_lt_one {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : 0 ≤ ifp_n.fr ∧ ifp_n.fr < 1
theorem metric.uniform_embedding_iff' {β : Type v} {γ : Type w} [metric_space γ] [metric_space β] {f : γ → β} : uniform_embedding f ↔ (∀ (ε : ℝ), ε > 0 → (∃ (δ : ℝ) (H : δ > 0), ∀ {a b : γ}, has_dist.dist a b < δ → has_dist.dist (f a) (f b) < ε)) ∧ ∀ (δ : ℝ), δ > 0 → (∃ (ε : ℝ) (H : ε > 0), ∀ {a b : γ}, has_dist.dist (f a) (f b) < ε → has_dist.dist a b < δ)
theorem matrix.is_unit_iff_is_unit_det {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) : is_unit A ↔ is_unit A.det
theorem function.cantor_injective {α : Type u_1} (f : set α → α) : ¬function.injective f
theorem finite_field.exists_root_sum_quadratic {R : Type u_2} [comm_ring R] [is_domain R] [fintype R] {f g : polynomial R} (hf2 : f.degree = 2) (hg2 : g.degree = 2) (hR : fintype.card R % 2 = 1) : ∃ (a b : R), polynomial.eval a f + polynomial.eval b g = 0
theorem affine.simplex.monge_point_eq_of_range_eq {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} {s₁ s₂ : affine.simplex ℝ P n} (h : set.range s₁.points = set.range s₂.points) : s₁.monge_point = s₂.monge_point
theorem order.lt_succ_of_not_is_max {α : Type u_1} [preorder α] [succ_order α] {a : α} : ¬is_max a → a < order.succ a
theorem ring_equiv.unop_map_list_prod {R : Type u_4} {S : Type u_5} [semiring R] [semiring S] (f : R ≃+* Sᵐᵒᵖ) (l : list R) : mul_opposite.unop (⇑f l.prod) = (list.map (mul_opposite.unop ∘ ⇑f) l).reverse.prod
theorem module.End.eigenvectors_linear_independent {K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] (f : module.End K V) (μs : set K) (xs : ↥μs → V) (h_eigenvec : ∀ (μ : ↥μs), f.has_eigenvector ↑μ (xs μ)) : linear_independent K xs
theorem seq_continuous.continuous {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X → Y} [sequential_space X] : seq_continuous f → continuous f
theorem cont_diff_on_fderiv_within_apply {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {m n : with_top ℕ} {s : set E} {f : E → F} (hf : cont_diff_on 𝕜 n f s) (hs : unique_diff_on 𝕜 s) (hmn : m + 1 ≤ n) : cont_diff_on 𝕜 m (λ (p : E × E), ⇑(fderiv_within 𝕜 f s p.fst) p.snd) (s ×ˢ set.univ)
theorem add_monoid.not_is_torsion_free_iff (G : Type u_1) [add_monoid G] : ¬add_monoid.is_torsion_free G ↔ ∃ (g : G), g ≠ 0 ∧ is_of_fin_add_order g
theorem add_order_of_pos {G : Type u} [fintype G] [add_left_cancel_monoid G] (x : G) : 0 < add_order_of x
theorem finset.weighted_vsub_apply {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (w : ι → k) (p : ι → P) : ⇑(s.weighted_vsub p) w = s.sum (λ (i : ι), w i • (p i -ᵥ classical.choice add_torsor.nonempty))
theorem subsemigroup.closure_induction' {M : Type u_1} [has_mul M] (s : set M) {p : Π (x : M), x ∈ subsemigroup.closure s → Prop} (Hs : ∀ (x : M) (h : x ∈ s), p x _) (Hmul : ∀ (x : M) (hx : x ∈ subsemigroup.closure s) (y : M) (hy : y ∈ subsemigroup.closure s), p x hx → p y hy → p (x * y) _) {x : M} (hx : x ∈ subsemigroup.closure s) : p x hx
theorem metric.Hausdorff_dist_le_diam {α : Type u} [pseudo_metric_space α] {s t : set α} (hs : s.nonempty) (bs : metric.bounded s) (ht : t.nonempty) (bt : metric.bounded t) : metric.Hausdorff_dist s t ≤ metric.diam (s ∪ t)
theorem mem_omega_limit_singleton_iff_map_cluster_point {τ : Type u_1} {α : Type u_2} {β : Type u_3} [topological_space β] (f : filter τ) (ϕ : τ → α → β) (x : α) (y : β) : y ∈ omega_limit f ϕ {x} ↔ map_cluster_pt y f (λ (t : τ), ϕ t x)
theorem right.add_nonpos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0) : a + b ≤ 0
theorem subsemigroup.subset_closure {M : Type u_1} [has_mul M] {s : set M} : s ⊆ ↑(subsemigroup.closure s)
theorem convex_on.sup {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [linear_ordered_add_comm_monoid β] [has_scalar 𝕜 E] [module 𝕜 β] [ordered_smul 𝕜 β] {s : set E} {f g : E → β} (hf : convex_on 𝕜 s f) (hg : convex_on 𝕜 s g) : convex_on 𝕜 s (f ⊔ g)
theorem filter.tendsto.op_zero_is_bounded_under_le' {α : Type u_1} {E : Type u_3} {F : Type u_4} {G : Type u_5} [semi_normed_group E] [semi_normed_group F] [semi_normed_group G] {f : α → E} {g : α → F} {l : filter α} (hf : filter.tendsto f l (nhds 0)) (hg : filter.is_bounded_under has_le.le l (has_norm.norm ∘ g)) (op : E → F → G) (h_op : ∃ (A : ℝ), ∀ (x : E) (y : F), ∥op x y∥ ≤ A * ∥x∥ * ∥y∥) : filter.tendsto (λ (x : α), op (f x) (g x)) l (nhds 0)
theorem padic_val_rat.zero (m : ℕ) : padic_val_rat m 0 = 0
theorem add_con.coe_add {M : Type u_1} [has_add M] {c : add_con M} (x y : M) : ↑(x + y) = ↑x + ↑y
theorem continuous_map.continuous_curry' {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] (f : C(α × β, γ)) : continuous f.curry'
theorem gauge_zero {E : Type u_1} [add_comm_group E] [module ℝ E] {s : set E} : gauge s 0 = 0
theorem rel_supr_sum {α : Type u_1} {β : Type u_2} {δ : Type u_4} [add_comm_monoid α] [topological_space α] [t2_space α] [complete_lattice β] (m : β → α) (m0 : m ⊥ = 0) (R : α → α → Prop) (m_supr : ∀ (s : ℕ → β), R (m (⨆ (i : ℕ), s i)) (∑' (i : ℕ), m (s i))) (s : δ → β) (t : finset δ) : R (m (⨆ (d : δ) (H : d ∈ t), s d)) (t.sum (λ (d : δ), m (s d)))
theorem cardinal.lift_mk_eq' {α : Type u} {β : Type v} : (cardinal.mk α).lift = (cardinal.mk β).lift ↔ nonempty (α ≃ β)
theorem support_factorization {α : Type u_1} [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] [normalization_monoid α] [decidable_eq α] {n : α} : (factorization n).support = (unique_factorization_monoid.normalized_factors n).to_finset
theorem finset.subset_div {α : Type u_2} [decidable_eq α] [has_div α] {u : finset α} {s t : set α} : ↑u ⊆ s / t → (∃ (s' t' : finset α), ↑s' ⊆ s ∧ ↑t' ⊆ t ∧ u ⊆ s' / t')
theorem inner_product_geometry.angle_sub_eq_angle_sub_rev_of_norm_eq {V : Type u_1} [inner_product_space ℝ V] {x y : V} (h : ∥x∥ = ∥y∥) : inner_product_geometry.angle x (x - y) = inner_product_geometry.angle y (y - x)
theorem intermediate_field.adjoin_adjoin_left (F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] (S T : set E) : ↑(intermediate_field.adjoin ↥(intermediate_field.adjoin F S) T) = intermediate_field.adjoin F (S ∪ T)
theorem commute.add_pow' {R : Type u_1} [semiring R] {x y : R} (h : commute x y) (n : ℕ) : (x + y) ^ n = (finset.nat.antidiagonal n).sum (λ (m : ℕ × ℕ), n.choose m.fst • (x ^ m.fst * y ^ m.snd))
theorem inner_product_space.is_self_adjoint.orthogonal_supr_eigenspaces_invariant {𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] {T : E →ₗ[𝕜] E} (hT : inner_product_space.is_self_adjoint T) ⦃v : E⦄ (hv : v ∈ (⨆ (μ : 𝕜), module.End.eigenspace T μ)ᗮ) : ⇑T v ∈ (⨆ (μ : 𝕜), module.End.eigenspace T μ)ᗮ
theorem quotient.induction_on' {α : Sort u_1} {s₁ : setoid α} {p : quotient s₁ → Prop} (q : quotient s₁) (h : ∀ (a : α), p (quotient.mk' a)) : p q
theorem complete_lattice.independent.dfinsupp_lsum_injective {ι : Type u_1} {R : Type u_2} {N : Type u_5} [dec_ι : decidable_eq ι] [ring R] [add_comm_group N] [module R N] {p : ι → submodule R N} (h : complete_lattice.independent p) : function.injective ⇑(⇑(dfinsupp.lsum ℕ) (λ (i : ι), (p i).subtype))
theorem besicovitch.exists_disjoint_closed_ball_covering_ae_of_finite_measure_aux {α : Type u_1} [metric_space α] [topological_space.second_countable_topology α] [measurable_space α] [opens_measurable_space α] [has_besicovitch_covering α] (μ : measure_theory.measure α) [measure_theory.is_finite_measure μ] (f : α → set ℝ) (s : set α) (hf : ∀ (x : α), x ∈ s → ∀ (δ : ℝ), δ > 0 → (f x ∩ set.Ioo 0 δ).nonempty) : ∃ (t : set (α × ℝ)), t.countable ∧ (∀ (p : α × ℝ), p ∈ t → p.fst ∈ s) ∧ (∀ (p : α × ℝ), p ∈ t → p.snd ∈ f p.fst) ∧ ⇑μ (s  ⋃ (p : α × ℝ) (hp : p ∈ t), metric.closed_ball p.fst p.snd) = 0 ∧ t.pairwise_disjoint (λ (p : α × ℝ), metric.closed_ball p.fst p.snd)
theorem ring_hom.map_mul {α : Type u_2} {β : Type u_3} {rα : non_assoc_semiring α} {rβ : non_assoc_semiring β} (f : α →+* β) (a b : α) : ⇑f (a * b) = ⇑f a * ⇑f b
theorem list.sum_take_map_length_lt1 {α : Type u_1} (L : list (list α)) {i j : ℕ} (hi : i < L.length) (hj : j < (L.nth_le i hi).length) : (list.take i (list.map list.length L)).sum + j < (list.take (i + 1) (list.map list.length L)).sum
theorem subtype.exists' {α : Sort u_1} {p : α → Prop} {q : Π (x : α), p x → Prop} : (∃ (x : α) (h : p x), q x h) ↔ ∃ (x : {a // p a}), q ↑x _
theorem zmod.pow_card {p : ℕ} [fact (nat.prime p)] (x : zmod p) : x ^ p = x
theorem add_con.induction_on₂ {M : Type u_1} {N : Type u_2} [has_add M] [has_add N] {c : add_con M} {d : add_con N} {C : c.quotient → d.quotient → Prop} (p : c.quotient) (q : d.quotient) (H : ∀ (x : M) (y : N), C ↑x ↑y) : C p q
theorem strongly_measurable_of_tendsto {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} [topological_space β] [topological_space.pseudo_metrizable_space β] (u : filter ι) [u.ne_bot] [u.is_countably_generated] {f : ι → α → β} {g : α → β} (hf : ∀ (i : ι), measure_theory.strongly_measurable (f i)) (lim : filter.tendsto f u (nhds g)) : measure_theory.strongly_measurable g
theorem measure_theory.integral_integral_swap {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] ⦃f : α → β → E⦄ (hf : measure_theory.integrable (function.uncurry f) (μ.prod ν)) : ∫ (x : α), ∫ (y : β), f x y ∂ν ∂μ = ∫ (y : β), ∫ (x : α), f x y ∂μ ∂ν
theorem list.split_on_p_spec {α : Type u} (p : α → Prop) [decidable_pred p] (as : list α) : (list.zip_with has_append.append (list.split_on_p p as) (list.map (λ (x : α), [x]) (list.filter p as) ++ [list.nil])).join = as
theorem bdd_above.convolution_exists_at {𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G → E} {g : G → E'} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 F] (L : E →L[𝕜] E' →L[𝕜] F) [measurable_space G] {μ : measure_theory.measure G} [add_comm_group G] [has_measurable_add₂ G] [has_measurable_neg G] [μ.is_add_left_invariant] [measure_theory.sigma_finite μ] {x₀ : G} {s : set G} (hbg : bdd_above ((λ (i : G), ∥g i∥) '' ((λ (t : G), x₀ - t) ⁻¹' s))) (hs : measurable_set s) (h2s : function.support (λ (t : G), ⇑(⇑L (f t)) (g (x₀ - t))) ⊆ s) (hf : measure_theory.integrable_on f s μ) (hmf : measure_theory.ae_strongly_measurable f μ) (hmg : measure_theory.ae_strongly_measurable g μ) : convolution_exists_at f g x₀ L μ
theorem add_con.refl {M : Type u_1} [has_add M] (c : add_con M) (x : M) : ⇑c x x
theorem lt_of_tsub_lt_tsub_right_of_le {α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b c : α} (h : c ≤ b) (h2 : a - c < b - c) : a < b
theorem real.Sup_nonpos (S : set ℝ) (hS : ∀ (x : ℝ), x ∈ S → x ≤ 0) : has_Sup.Sup S ≤ 0
theorem map_Inf_of_continuous_at_of_monotone {α : Type u} {β : Type v} [complete_linear_order α] [topological_space α] [order_topology α] [complete_linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} (Cf : continuous_at f (has_Inf.Inf s)) (Mf : monotone f) (ftop : f ⊤ = ⊤) : f (has_Inf.Inf s) = has_Inf.Inf (f '' s)
theorem is_preconnected.subset_closure {α : Type u} [topological_space α] {s t : set α} (H : is_preconnected s) (Kst : s ⊆ t) (Ktcs : t ⊆ closure s) : is_preconnected t
theorem convex.norm_image_sub_le_of_norm_has_fderiv_within_le' {E : Type u_1} [normed_group E] [normed_space ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_space 𝕜 E] [normed_group G] [normed_space 𝕜 G] {f : E → G} {C : ℝ} {s : set E} {x y : E} {f' : E → (E →L[𝕜] G)} {φ : E →L[𝕜] G} (hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (bound : ∀ (x : E), x ∈ s → ∥f' x - φ∥ ≤ C) (hs : convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∥f y - f x - ⇑φ (y - x)∥ ≤ C * ∥y - x∥
theorem supr_limsup_dimH {X : Type u_2} [emetric_space X] [topological_space.second_countable_topology X] (s : set X) : (⨆ (x : X), (nhds_within x s).small_sets.limsup dimH) = dimH s
theorem same_ray.smul {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} {S : Type u_3} [monoid S] [distrib_mul_action S M] [smul_comm_class R S M] (h : same_ray R x y) (s : S) : same_ray R (s • x) (s • y)
theorem map_sub {G : Type u_6} {H : Type u_7} {F : Type u_8} [add_group G] [subtraction_monoid H] [add_monoid_hom_class F G H] (f : F) (a b : G) : ⇑f (a - b) = ⇑f a - ⇑f b
theorem exists_subset_Union_ball_radius_lt {α : Type u} {ι : Type v} [metric_space α] [proper_space α] {c : ι → α} {s : set α} {r : ι → ℝ} (hs : is_closed s) (uf : ∀ (x : α), x ∈ s → {i : ι | x ∈ metric.ball (c i) (r i)}.finite) (us : s ⊆ ⋃ (i : ι), metric.ball (c i) (r i)) : ∃ (r' : ι → ℝ), (s ⊆ ⋃ (i : ι), metric.ball (c i) (r' i)) ∧ ∀ (i : ι), r' i < r i
theorem is_add_group_hom.to_is_add_monoid_hom {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : is_add_monoid_hom f
theorem category_theory.abelian.pseudoelement.mono_of_zero_of_map_zero {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P ⟶ Q) : (∀ (a : ↥P), ⇑f a = 0 → a = 0) → category_theory.mono f
theorem normed_group_hom.norm_id_le (V : Type u_1) [semi_normed_group V] : ∥normed_group_hom.id V∥ ≤ 1
theorem category_theory.yoneda.is_iso {C : Type u₁} [category_theory.category C] {X Y : C} (f : X ⟶ Y) [category_theory.is_iso (category_theory.yoneda.map f)] : category_theory.is_iso f
theorem affine_subspace.direction_le {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s1 s2 : affine_subspace k P} (h : s1 ≤ s2) : s1.direction ≤ s2.direction
theorem concave_on.le_map_set_average {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {t : set α} {f : α → E} {g : E → ℝ} (hg : concave_on ℝ s g) (hgc : continuous_on g s) (hsc : is_closed s) (h0 : ⇑μ t ≠ 0) (ht : ⇑μ t ≠ ⊤) (hfs : ∀ᵐ (x : α) ∂μ.restrict t, f x ∈ s) (hfi : measure_theory.integrable_on f t μ) (hgi : measure_theory.integrable_on (g ∘ f) t μ) : ⨍ (x : α) in t, g (f x) ∂μ ≤ g (⨍ (x : α) in t, f x ∂μ)
theorem orthonormal.rotation_eq_rotation_neg_of_orientation_eq_neg {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {b₂ : basis (fin 2) ℝ V} (hb₂ : orthonormal ℝ ⇑b₂) (ho : b.orientation = -b₂.orientation) (θ : real.angle) : hb.rotation θ = hb₂.rotation (-θ)
theorem strict_convex_on_univ_of_deriv2_pos {f : ℝ → ℝ} (hf' : differentiable ℝ f) (hf'' : ∀ (x : ℝ), 0 < deriv^[2] f x) : strict_convex_on ℝ set.univ f
theorem antitone_on.concave_on_of_deriv {D : set ℝ} (hD : convex ℝ D) {f : ℝ → ℝ} (hf : continuous_on f D) (hf' : differentiable_on ℝ f (interior D)) (h_anti : antitone_on (deriv f) (interior D)) : concave_on ℝ D f
theorem category_theory.over.construct_products.over_product_of_wide_pullback {J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_limits_of_shape (category_theory.limits.wide_pullback_shape J) C] {B : C} : category_theory.limits.has_limits_of_shape (category_theory.discrete J) (category_theory.over B)
theorem fractional_ideal.right_inverse_eq (K : Type u_3) [field K] {R₁ : Type u_4} [comm_ring R₁] [is_domain R₁] [algebra R₁ K] [is_fraction_ring R₁ K] (I J : fractional_ideal (non_zero_divisors R₁) K) (h : I * J = 1) : J = I⁻¹
theorem fourier_subalgebra_conj_invariant  : continuous_map.conj_invariant_subalgebra (subalgebra.restrict_scalars ℝ fourier_subalgebra)
theorem is_Gδ_sInter {α : Type u_1} [topological_space α] {S : set (set α)} (h : ∀ (s : set α), s ∈ S → is_Gδ s) (hS : S.countable) : is_Gδ (⋂₀ S)
theorem continuous_linear_map.smul_comp_LpL_apply {α : Type u_1} {E : Type u_2} {F : Type u_3} {m0 : measurable_space α} {p : ennreal} {μ : measure_theory.measure α} [normed_group E] [normed_group F] {𝕜 : Type u_5} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 F] [fact (1 ≤ p)] {𝕜' : Type u_4} [normed_field 𝕜'] [normed_space 𝕜' F] [smul_comm_class 𝕜 𝕜' F] (c : 𝕜') (L : E →L[𝕜] F) (f : ↥(measure_theory.Lp E p μ)) : ⇑(continuous_linear_map.comp_LpL p μ (c • L)) f = c • ⇑(continuous_linear_map.comp_LpL p μ L) f
theorem embedding_sigma_map {ι : Type u_5} {σ : ι → Type u_6} [Π (i : ι), topological_space (σ i)] {τ : ι → Type u_1} [Π (i : ι), topological_space (τ i)] {f : Π (i : ι), σ i → τ i} (hf : ∀ (i : ι), embedding (f i)) : embedding (sigma.map id f)
theorem path.trans_pi_eq_pi_trans {ι : Type u_3} {χ : ι → Type u_4} [Π (i : ι), topological_space (χ i)] {as bs cs : Π (i : ι), χ i} (γ₀ : Π (i : ι), path (as i) (bs i)) (γ₁ : Π (i : ι), path (bs i) (cs i)) : (path.pi γ₀).trans (path.pi γ₁) = path.pi (λ (i : ι), (γ₀ i).trans (γ₁ i))
theorem matrix.is_symm.ext_iff {α : Type u_1} {n : Type u_3} {A : matrix n n α} : A.is_symm ↔ ∀ (i j : n), A j i = A i j
theorem category_theory.limits.complete_lattice.finite_colimit_eq_finset_univ_sup {α J : Type u} [category_theory.small_category J] [category_theory.fin_category J] [semilattice_sup α] [order_bot α] (F : J ⥤ α) : category_theory.limits.colimit F = finset.univ.sup F.obj
theorem category_theory.limits.kernel.lift_map {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y Z X' Y' Z' : C} (f : X ⟶ Y) (g : Y ⟶ Z) [category_theory.limits.has_kernel g] (w : f ≫ g = 0) (f' : X' ⟶ Y') (g' : Y' ⟶ Z') [category_theory.limits.has_kernel g'] (w' : f' ≫ g' = 0) (p : X ⟶ X') (q : Y ⟶ Y') (r : Z ⟶ Z') (h₁ : f ≫ q = p ≫ f') (h₂ : g ≫ r = q ≫ g') : category_theory.limits.kernel.lift g f w ≫ category_theory.limits.kernel.map g g' q r h₂ = p ≫ category_theory.limits.kernel.lift g' f' w'
theorem measurable.of_le_map {α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : m₂ ≤ measurable_space.map f m₁ → measurable f
theorem measure_theory.exists_lt_lower_semicontinuous_integral_lt {α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] {μ : measure_theory.measure α} [μ.weakly_regular] [measure_theory.sigma_finite μ] (f : α → ℝ) (hf : measure_theory.integrable f μ) {ε : ℝ} (εpos : 0 < ε) : ∃ (g : α → ereal), (∀ (x : α), ↑(f x) < g x) ∧ lower_semicontinuous g ∧ measure_theory.integrable (λ (x : α), (g x).to_real) μ ∧ (∀ᵐ (x : α) ∂μ, g x < ⊤) ∧ ∫ (x : α), (g x).to_real ∂μ < ∫ (x : α), f x ∂μ + ε
theorem besicovitch.ae_tendsto_measure_inter_div {β : Type u} [metric_space β] [measurable_space β] [borel_space β] [sigma_compact_space β] [has_besicovitch_covering β] (μ : measure_theory.measure β) [measure_theory.is_locally_finite_measure μ] (s : set β) : ∀ᵐ (x : β) ∂μ.restrict s, filter.tendsto (λ (r : ℝ), ⇑μ (s ∩ metric.closed_ball x r) / ⇑μ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds 1)
theorem continuous_prod_of_continuous_lipschitz {α : Type u} {β : Type v} {γ : Type w} [pseudo_emetric_space α] [topological_space β] [pseudo_emetric_space γ] (f : α × β → γ) (K : nnreal) (ha : ∀ (a : α), continuous (λ (y : β), f (a, y))) (hb : ∀ (b : β), lipschitz_with K (λ (x : α), f (x, b))) : continuous f
theorem differentiable_on.has_fpower_series_on_ball {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] {R : nnreal} {c : ℂ} {f : ℂ → E} (hd : differentiable_on ℂ f (metric.closed_ball c ↑R)) (hR : 0 < R) : has_fpower_series_on_ball f (cauchy_power_series f c ↑R) c ↑R
theorem measure_theory.measure.prod_eq_generate_from {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} {C : set (set α)} {D : set (set β)} (hC : measurable_space.generate_from C = _inst_1) (hD : measurable_space.generate_from D = _inst_3) (h2C : is_pi_system C) (h2D : is_pi_system D) (h3C : μ.finite_spanning_sets_in C) (h3D : ν.finite_spanning_sets_in D) {μν : measure_theory.measure (α × β)} (h₁ : ∀ (s : set α), s ∈ C → ∀ (t : set β), t ∈ D → ⇑μν (s ×ˢ t) = ⇑μ s * ⇑ν t) : μ.prod ν = μν
theorem category_theory.is_iso_of_op {C : Type u₁} [category_theory.category C] {X Y : C} (f : X ⟶ Y) [category_theory.is_iso f.op] : category_theory.is_iso f
theorem Top.presheaf.is_sheaf_of_iso {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} {F G : Top.presheaf C X} (α : F ≅ G) (h : F.is_sheaf) : G.is_sheaf
theorem linear_map.continuous_on_pi {ι : Type u_1} {𝕜 : Type u_2} {F : Type u_3} [fintype ι] [semiring 𝕜] [topological_space 𝕜] [add_comm_monoid F] [module 𝕜 F] [topological_space F] [has_continuous_add F] [has_continuous_smul 𝕜 F] (f : (ι → 𝕜) →ₗ[𝕜] F) : continuous ⇑f
theorem measure_theory.measurable_embedding_of_fderiv_within {E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {s : set E} {f : E → E} {f' : E → (E →L[ℝ] E)} [measurable_space E] [borel_space E] (hs : measurable_set s) (hf' : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) : measurable_embedding (s.restrict f)
theorem category_theory.limits.kernel.ι_of_zero {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) : category_theory.is_iso (category_theory.limits.kernel.ι 0)
theorem le_of_sub_nonpos {α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : a - b ≤ 0 → a ≤ b
theorem trans_gen_of_succ_of_gt {α : Type u_1} [partial_order α] [succ_order α] [is_succ_archimedean α] (r : α → α → Prop) {n m : α} (h : ∀ (i : α), i ∈ set.Ico m n → r (order.succ i) i) (hmn : m < n) : relation.trans_gen r n m
theorem vitali_family.mul_measure_le_of_subset_lt_lim_ratio_meas {α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {ρ : measure_theory.measure α} [measure_theory.is_locally_finite_measure ρ] (hρ : ρ.absolutely_continuous μ) {q : nnreal} {s : set α} (h : s ⊆ {x : α | ↑q < v.lim_ratio_meas hρ x}) : ↑q * ⇑μ s ≤ ⇑ρ s
theorem nat.four_pow_le_two_mul_self_mul_central_binom (n : ℕ) (n_pos : 0 < n) : 4 ^ n ≤ 2 * n * n.central_binom
theorem measure_theory.pdf.is_uniform.integral_eq {α : Type u_1} {m : measurable_space α} {ℙ : measure_theory.measure α} [measure_theory.is_finite_measure «ℙ»] {X : α → ℝ} {s : set ℝ} (hms : measurable_set s) (hns : ⇑measure_theory.measure_space.volume s ≠ 0) (hnt : ⇑measure_theory.measure_space.volume s ≠ ⊤) (huX : measure_theory.pdf.is_uniform X s «ℙ» measure_theory.measure_space.volume) : ∫ (x : α), X x ∂«ℙ» = (⇑measure_theory.measure_space.volume s)⁻¹.to_real * ∫ (x : ℝ) in s, x
theorem continuous_multilinear_map.map_add_univ {R : Type u} {ι : Type v} {M₁ : ι → Type w₁} {M₂ : Type w₂} [decidable_eq ι] [semiring R] [Π (i : ι), add_comm_monoid (M₁ i)] [add_comm_monoid M₂] [Π (i : ι), module R (M₁ i)] [module R M₂] [Π (i : ι), topological_space (M₁ i)] [topological_space M₂] (f : continuous_multilinear_map R M₁ M₂) [fintype ι] (m m' : Π (i : ι), M₁ i) : ⇑f (m + m') = finset.univ.sum (λ (s : finset ι), ⇑f (s.piecewise m m'))
theorem closure_compl_singleton {α : Type u} [topological_space α] (x : α) [(nhds_within x {x}ᶜ).ne_bot] : closure {x}ᶜ = set.univ
theorem concave_on.comp_affine_map {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {β : Type u_4} [linear_ordered_field 𝕜] [add_comm_group E] [add_comm_group F] [ordered_add_comm_monoid β] [module 𝕜 E] [module 𝕜 F] [has_scalar 𝕜 β] {f : F → β} (g : E →ᵃ[𝕜] F) {s : set F} (hf : concave_on 𝕜 s f) : concave_on 𝕜 (⇑g ⁻¹' s) (f ∘ ⇑g)
theorem padic_val_rat.one {p : ℕ} : padic_val_rat p 1 = 0
theorem subobject_of_le_as_image_to_kernel {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {A B C : V} (f : A ⟶ B) [category_theory.limits.has_image f] (g : B ⟶ C) [category_theory.limits.has_kernel g] (w : f ≫ g = 0) (h : category_theory.limits.image_subobject f ≤ category_theory.limits.kernel_subobject g) : (category_theory.limits.image_subobject f).of_le (category_theory.limits.kernel_subobject g) h = image_to_kernel f g w
theorem function.injective2.right {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) (a : α) : function.injective (f a)
theorem is_group_hom.to_is_monoid_hom {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : is_monoid_hom f
theorem category_theory.limits.coequalizer.hom_ext {C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} [category_theory.limits.has_coequalizer f g] {W : C} {k l : category_theory.limits.coequalizer f g ⟶ W} (h : category_theory.limits.coequalizer.π f g ≫ k = category_theory.limits.coequalizer.π f g ≫ l) : k = l
theorem even.strict_convex_on_pow {n : ℕ} (hn : even n) (h : n ≠ 0) : strict_convex_on ℝ set.univ (λ (x : ℝ), x ^ n)
theorem polynomial.is_noetherian_ring {R : Type u} [comm_ring R] [is_noetherian_ring R] : is_noetherian_ring (polynomial R)
theorem convex.image_sub_le_mul_sub_of_deriv_le {D : set ℝ} (hD : convex ℝ D) {f : ℝ → ℝ} (hf : continuous_on f D) (hf' : differentiable_on ℝ f (interior D)) {C : ℝ} (le_hf' : ∀ (x : ℝ), x ∈ interior D → deriv f x ≤ C) (x : ℝ) (H : x ∈ D) (y : ℝ) (H_1 : y ∈ D) : x ≤ y → f y - f x ≤ C * (y - x)
theorem is_left_regular_iff {R : Type u_1} [has_mul R] {a : R} : is_left_regular a ↔ is_smul_regular R a
theorem matrix.kronecker_map_bilinear_mul_mul {R : Type u_1} {α : Type u_2} {β : Type u_4} {γ : Type u_6} {l : Type u_8} {m : Type u_9} {n : Type u_10} {l' : Type u_14} {m' : Type u_15} {n' : Type u_16} [comm_semiring R] [fintype m] [fintype m'] [non_unital_non_assoc_semiring α] [non_unital_non_assoc_semiring β] [non_unital_non_assoc_semiring γ] [module R α] [module R β] [module R γ] (f : α →ₗ[R] β →ₗ[R] γ) (h_comm : ∀ (a b : α) (a' b' : β), ⇑(⇑f (a * b)) (a' * b') = ⇑(⇑f a) a' * ⇑(⇑f b) b') (A : matrix l m α) (B : matrix m n α) (A' : matrix l' m' β) (B' : matrix m' n' β) : ⇑(⇑(matrix.kronecker_map_bilinear f) (A.mul B)) (A'.mul B') = (⇑(⇑(matrix.kronecker_map_bilinear f) A) A').mul (⇑(⇑(matrix.kronecker_map_bilinear f) B) B')
theorem finset.sup_product_left {α : Type u_1} {β : Type u_2} {γ : Type u_3} [semilattice_sup α] [order_bot α] (s : finset β) (t : finset γ) (f : β × γ → α) : (s.product t).sup f = s.sup (λ (i : β), t.sup (λ (i' : γ), f (i, i')))
theorem is_dedekind_domain_inv.is_dedekind_domain {A : Type u_2} [comm_ring A] [is_domain A] (h : is_dedekind_domain_inv A) : is_dedekind_domain A
theorem filter.tendsto_at_bot_of_monotone_of_filter {ι : Type u_1} {α : Type u_3} [preorder ι] [preorder α] {l : filter ι} {u : ι → α} (h : monotone u) [l.ne_bot] (hu : filter.tendsto u l filter.at_bot) : filter.tendsto u filter.at_bot filter.at_bot
theorem equiv_iff_same_ray {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {v₁ v₂ : ray_vector R M} : v₁ ≈ v₂ ↔ same_ray R ↑v₁ ↑v₂
theorem four_pos {α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 4
theorem finsum_comp {α : Type u_1} {β : Type u_2} {M : Type u_5} [add_comm_monoid M] {g : β → M} (e : α → β) (he₀ : function.bijective e) : finsum (λ (i : α), g (e i)) = finsum (λ (j : β), g j)
theorem euclidean_geometry.angle_nonneg {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (p1 p2 p3 : P) : 0 ≤ euclidean_geometry.angle p1 p2 p3
theorem nat.choose_two_right (n : ℕ) : n.choose 2 = n * (n - 1) / 2
theorem eq_sum_orthogonal_projection_self_orthogonal_complement {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) [complete_space E] [complete_space ↥K] (w : E) : w = ↑(⇑(orthogonal_projection K) w) + ↑(⇑(orthogonal_projection Kᗮ) w)
theorem affine_subspace.sup_direction_lt_of_nonempty_of_inter_empty {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s1 s2 : affine_subspace k P} (h1 : ↑s1.nonempty) (h2 : ↑s2.nonempty) (he : ↑s1 ∩ ↑s2 = ∅) : s1.direction ⊔ s2.direction < (s1 ⊔ s2).direction
theorem category_theory.equivalence.unit_inverse_comp {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (e : C ≌ D) (Y : D) : e.unit.app (e.inverse.obj Y) ≫ e.inverse.map (e.counit.app Y) = 𝟙 (e.inverse.obj Y)
theorem eq.trans_gt {α : Type u} [preorder α] {a b c : α} : b = c → a < b → a < c
theorem module.free.finrank_eq_rank (R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] : ↑(finite_dimensional.finrank R M) = module.rank R M
theorem continuous_map.exists_restrict_eq_forall_mem_of_closed {Y : Type u_2} [topological_space Y] [normal_space Y] {s : set Y} (f : C(↥s, ℝ)) {t : set ℝ} [t.ord_connected] (ht : ∀ (x : ↥s), ⇑f x ∈ t) (hne : t.nonempty) (hs : is_closed s) : ∃ (g : C(Y, ℝ)), (∀ (y : Y), ⇑g y ∈ t) ∧ continuous_map.restrict s g = f
theorem ereal.continuous_at_add {p : ereal × ereal} (h : p.fst ≠ ⊤ ∨ p.snd ≠ ⊥) (h' : p.fst ≠ ⊥ ∨ p.snd ≠ ⊤) : continuous_at (λ (p : ereal × ereal), p.fst + p.snd) p
theorem tendsto_uniformly_on.comp {α : Type u_1} {β : Type u_2} {γ : Type u_3} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {s : set α} {p : filter ι} (h : tendsto_uniformly_on F f p s) (g : γ → α) : tendsto_uniformly_on (λ (n : ι), F n ∘ g) (f ∘ g) p (g ⁻¹' s)
theorem dense_compl_singleton {α : Type u} [topological_space α] (x : α) [(nhds_within x {x}ᶜ).ne_bot] : dense {x}ᶜ
theorem fin.snoc_init_self {n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) : fin.snoc (fin.init q) (q (fin.last n)) = q
theorem algebra.smul_mul_assoc {R : Type u} {A : Type w} [comm_semiring R] [semiring A] [algebra R A] (r : R) (x y : A) : r • x * y = r • (x * y)
theorem not_small_ordinal  : ¬small ordinal
theorem metric.closure_eq_Inter_cthickening {α : Type u} [pseudo_emetric_space α] (E : set α) : closure E = ⋂ (δ : ℝ) (h : 0 < δ), metric.cthickening δ E
theorem strict_convex_on.neg {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [ordered_add_comm_group β] [has_scalar 𝕜 E] [module 𝕜 β] {s : set E} {f : E → β} : strict_convex_on 𝕜 s f → strict_concave_on 𝕜 s (-f)
theorem submodule.finrank_lt {K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {s : submodule K V} (h : s < ⊤) : finite_dimensional.finrank K ↥s < finite_dimensional.finrank K V
theorem measure_theory.continuous_map.inner_to_Lp {α : Type u_1} [topological_space α] [measure_theory.measure_space α] [borel_space α] {𝕜 : Type u_2} [is_R_or_C 𝕜] (μ : measure_theory.measure α) [measure_theory.is_finite_measure μ] [compact_space α] (f g : C(α, 𝕜)) : has_inner.inner (⇑(continuous_map.to_Lp 2 μ 𝕜) f) (⇑(continuous_map.to_Lp 2 μ 𝕜) g) = ∫ (x : α), ⇑(star_ring_end 𝕜) (⇑f x) * ⇑g x ∂μ
theorem eq_of_has_deriv_right_eq {E : Type u_1} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} {f' g : ℝ → E} (derivf : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at f (f' x) (set.Ici x) x) (derivg : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at g (f' x) (set.Ici x) x) (fcont : continuous_on f (set.Icc a b)) (gcont : continuous_on g (set.Icc a b)) (hi : f a = g a) (y : ℝ) (H : y ∈ set.Icc a b) : f y = g y
theorem orientation.oangle_eq_pi_sub_two_zsmul_oangle_sub_of_norm_eq {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y : V} (hn : x ≠ y) (h : ∥x∥ = ∥y∥) : o.oangle y x = ↑real.pi - 2 • o.oangle (y - x) y
theorem add_is_add_right_regular_iff {R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_right_regular a) : is_add_right_regular (b + a) ↔ is_add_right_regular b
theorem summable.tendsto_cofinite_zero {α : Type u_1} {G : Type u_5} [topological_space G] [add_comm_group G] [topological_add_group G] {f : α → G} (hf : summable f) : filter.tendsto f filter.cofinite (nhds 0)
theorem complex.integral_boundary_rect_of_differentiable_on_real {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] (f : ℂ → E) (z w : ℂ) (Hd : differentiable_on ℝ f (set.interval z.re w.re ×ℂ set.interval z.im w.im)) (Hi : measure_theory.integrable_on (λ (z : ℂ), complex.I • ⇑(fderiv ℝ f z) 1 - ⇑(fderiv ℝ f z) complex.I) (set.interval z.re w.re ×ℂ set.interval z.im w.im) measure_theory.measure_space.volume) : (((∫ (x : ℝ) in z.re..w.re, f (↑x + ↑(z.im) * complex.I)) - ∫ (x : ℝ) in z.re..w.re, f (↑x + ↑(w.im) * complex.I)) + complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑(w.re) + ↑y * complex.I)) - complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑(z.re) + ↑y * complex.I) = ∫ (x : ℝ) in z.re..w.re, ∫ (y : ℝ) in z.im..w.im, complex.I • ⇑(fderiv ℝ f (↑x + ↑y * complex.I)) 1 - ⇑(fderiv ℝ f (↑x + ↑y * complex.I)) complex.I
theorem finite_dimensional_of_is_compact_closed_ball (𝕜 : Type u) [nondiscrete_normed_field 𝕜] {E : Type v} [normed_group E] [normed_space 𝕜 E] [complete_space 𝕜] {r : ℝ} (rpos : 0 < r) {c : E} (h : is_compact (metric.closed_ball c r)) : finite_dimensional 𝕜 E
theorem is_add_group_hom.injective_iff {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 0 → a = 0
theorem uniformity_dist_of_mem_uniformity {α : Type u} {β : Type v} [linear_order β] {U : filter (α × α)} (z : β) (D : α → α → β) (H : ∀ (s : set (α × α)), s ∈ U ↔ ∃ (ε : β) (H : ε > z), ∀ {a b : α}, D a b < ε → (a, b) ∈ s) : U = ⨅ (ε : β) (H : ε > z), filter.principal {p : α × α | D p.fst p.snd < ε}
theorem monovary.sum_comp_perm_smul_le_sum_smul {ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {σ : equiv.perm ι} {f : ι → α} {g : ι → β} [fintype ι] (hfg : monovary f g) : finset.univ.sum (λ (i : ι), f (⇑σ i) • g i) ≤ finset.univ.sum (λ (i : ι), f i • g i)
theorem nat.exists_lt_and_lt_iff_not_dvd (m : ℕ) {n : ℕ} (hn : 0 < n) : (∃ (k : ℕ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m
theorem iterated_deriv_within_eq_equiv_comp {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {n : ℕ} {f : 𝕜 → F} {s : set 𝕜} : iterated_deriv_within n f s = ⇑((continuous_multilinear_map.pi_field_equiv 𝕜 (fin n) F).symm) ∘ iterated_fderiv_within 𝕜 n f s
theorem preimage_interior_subset_interior_preimage {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} {s : set β} (hf : continuous f) : f ⁻¹' interior s ⊆ interior (f ⁻¹' s)
theorem tsum_ite_eq_extract {α : Type u_1} {β : Type u_2} [add_comm_group α] [topological_space α] [topological_add_group α] {f : β → α} [t2_space α] [decidable_eq β] (hf : summable f) (b : β) : ∑' (n : β), f n = f b + ∑' (n : β), ite (n = b) 0 (f n)
theorem polynomial.monic_X_pow_sub_C {R : Type u} [ring R] (a : R) {n : ℕ} (h : n ≠ 0) : (polynomial.X ^ n - ⇑polynomial.C a).monic
theorem generalized_continued_fraction.succ_nth_fib_le_of_nth_denom {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] (hyp : n = 0 ∨ ¬(generalized_continued_fraction.of v).terminated_at (n - 1)) : ↑(nat.fib (n + 1)) ≤ (generalized_continued_fraction.of v).denominators n
theorem map_supr_of_continuous_at_of_monotone {α : Type u} {β : Type v} [complete_linear_order α] [topological_space α] [order_topology α] [complete_linear_order β] [topological_space β] [order_topology β] {ι : Sort u_1} {f : α → β} {g : ι → α} (Cf : continuous_at f (supr g)) (Mf : monotone f) (fbot : f ⊥ = ⊥) : f (⨆ (i : ι), g i) = ⨆ (i : ι), f (g i)
theorem concave_on_univ_of_deriv2_nonpos {f : ℝ → ℝ} (hf' : differentiable ℝ f) (hf'' : differentiable ℝ (deriv f)) (hf''_nonpos : ∀ (x : ℝ), deriv^[2] f x ≤ 0) : concave_on ℝ set.univ f
theorem category_theory.functor_skeletal {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] [∀ (X Y : C), subsingleton (X ⟶ Y)] (hC : category_theory.skeletal C) : category_theory.skeletal (D ⥤ C)
theorem ratfunc.induction_on' {K : Type u} [hring : comm_ring K] [hdomain : is_domain K] {P : ratfunc K → Prop} (x : ratfunc K) (f : ∀ (p q : polynomial K), q ≠ 0 → P (ratfunc.mk p q)) : P x
theorem submodule.supr_eq_range_dfinsupp_lsum {ι : Type u_1} {R : Type u_2} {N : Type u_5} [dec_ι : decidable_eq ι] [semiring R] [add_comm_monoid N] [module R N] (p : ι → submodule R N) : supr p = (⇑(dfinsupp.lsum ℕ) (λ (i : ι), (p i).subtype)).range
theorem refl_trans_gen_of_succ_of_ge {α : Type u_1} [partial_order α] [succ_order α] [is_succ_archimedean α] (r : α → α → Prop) {n m : α} (h : ∀ (i : α), i ∈ set.Ico m n → r (order.succ i) i) (hmn : m ≤ n) : relation.refl_trans_gen r n m
theorem urysohns.CU.continuous_lim {X : Type u_1} [topological_space X] [normal_space X] (c : urysohns.CU X) : continuous c.lim
theorem fintype.exists_le_card_fiber_of_mul_le_card {α : Type u} {β : Type v} [decidable_eq β] [fintype α] [fintype β] (f : α → β) {n : ℕ} [nonempty β] (hn : fintype.card β * n ≤ fintype.card α) : ∃ (y : β), n ≤ (finset.filter (λ (x : α), f x = y) finset.univ).card
theorem real.coe_fib_eq'  : (λ (n : ℕ), ↑(nat.fib n)) = λ (n : ℕ), (golden_ratio ^ n - golden_conj ^ n) / real.sqrt 5
theorem inducing.is_open_map {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (hi : inducing f) (ho : is_open (set.range f)) : is_open_map f
theorem filter.map_coe_Iio_at_bot {α : Type u_3} [semilattice_inf α] [no_min_order α] (a : α) : filter.map coe filter.at_bot = filter.at_bot
theorem measure_theory.mem_ℒp.induction_strongly_measurable {α : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space α} {μ : measure_theory.measure α} [fact (1 ≤ p)] [normed_space ℝ F] (hm : m ≤ m0) (hp_ne_top : p ≠ ⊤) (P : (α → F) → Prop) (h_ind : ∀ (c : F) ⦃s : set α⦄, measurable_set s → ⇑μ s < ⊤ → P (s.indicator (λ (_x : α), c))) (h_add : ∀ ⦃f g : α → F⦄, disjoint (function.support f) (function.support g) → measure_theory.mem_ℒp f p μ → measure_theory.mem_ℒp g p μ → measure_theory.strongly_measurable f → measure_theory.strongly_measurable g → P f → P g → P (f + g)) (h_closed : is_closed {f : ↥(measure_theory.Lp_meas F ℝ m p μ) | P ⇑f}) (h_ae : ∀ ⦃f g : α → F⦄, f =ᵐ[μ] g → measure_theory.mem_ℒp f p μ → P f → P g) ⦃f : α → F⦄ (hf : measure_theory.mem_ℒp f p μ) (hfm : measure_theory.ae_strongly_measurable' m f μ) : P f
theorem nilpotent_of_mul_equiv {G : Type u_1} [group G] {G' : Type u_2} [group G'] [h : group.is_nilpotent G] (f : G ≃* G') : group.is_nilpotent G'
theorem minpoly.eq_X_sub_C {A : Type u_1} (B : Type u_2) [field A] [ring B] [algebra A B] [nontrivial B] (a : A) : minpoly A (⇑(algebra_map A B) a) = polynomial.X - ⇑polynomial.C a
theorem emetric.Hausdorff_edist_le_of_mem_edist {α : Type u} [pseudo_emetric_space α] {s t : set α} {r : ennreal} (H1 : ∀ (x : α), x ∈ s → (∃ (y : α) (H : y ∈ t), has_edist.edist x y ≤ r)) (H2 : ∀ (x : α), x ∈ t → (∃ (y : α) (H : y ∈ s), has_edist.edist x y ≤ r)) : emetric.Hausdorff_edist s t ≤ r
theorem polynomial.eval_list_prod {R : Type u} [comm_semiring R] (l : list (polynomial R)) (x : R) : polynomial.eval x l.prod = (list.map (polynomial.eval x) l).prod
theorem tangent_bundle_model_space_chart_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) (p : tangent_bundle I H) : (charted_space.chart_at (model_prod H E) p).to_local_equiv = (equiv.sigma_equiv_prod H E).to_local_equiv
theorem complex.liouville_theorem_aux {F : Type v} [normed_group F] [normed_space ℂ F] {f : ℂ → F} (hf : differentiable ℂ f) (hb : metric.bounded (set.range f)) (z w : ℂ) : f z = f w
theorem matrix.is_hermitian_diagonal {n : Type u_4} [decidable_eq n] (v : n → ℝ) : (matrix.diagonal v).is_hermitian
theorem category_theory.comp_cover_lifting {C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {E : Type u_5} [category_theory.category E] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {L : category_theory.grothendieck_topology E} {F : C ⥤ D} (hu : category_theory.cover_lifting J K F) {G : D ⥤ E} (hv : category_theory.cover_lifting K L G) : category_theory.cover_lifting J L (F ⋙ G)
theorem measure_theory.simple_func.measurable {α : Type u_1} {β : Type u_2} [measurable_space α] [measurable_space β] (f : measure_theory.simple_func α β) : measurable ⇑f
theorem category_theory.frobenius_morphism_iso_of_exp_comparison_iso {C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] [category_theory.limits.has_finite_products C] [category_theory.limits.has_finite_products D] (F : C ⥤ D) {L : D ⥤ C} [category_theory.cartesian_closed C] [category_theory.cartesian_closed D] [category_theory.limits.preserves_limits_of_shape (category_theory.discrete category_theory.limits.walking_pair) F] (h : L ⊣ F) (A : C) [i : category_theory.is_iso (category_theory.exp_comparison F A)] : category_theory.is_iso (category_theory.frobenius_morphism F h A)
theorem nat.fib_add_two_strict_mono  : strict_mono (λ (n : ℕ), nat.fib (n + 2))
theorem mul_equiv.map_mul {M : Type u_6} {N : Type u_7} [has_mul M] [has_mul N] (f : M ≃* N) (x y : M) : ⇑f (x * y) = ⇑f x * ⇑f y
theorem matrix.is_diag_zero {α : Type u_1} {n : Type u_4} [has_zero α] : 0.is_diag
theorem representation.average_map_invariant {k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_semiring k] [group G] [add_comm_monoid V] [module k V] (ρ : representation k G V) [fintype G] [invertible ↑(fintype.card G)] (v : V) : ⇑(ρ.average_map) v ∈ ρ.invariants
theorem finset.prod_add_prod_eq {β : Type u} {α : Type v} [comm_semiring β] {s : finset α} {i : α} {f g h : α → β} (hi : i ∈ s) (h1 : g i + h i = f i) (h2 : ∀ (j : α), j ∈ s → j ≠ i → g j = f j) (h3 : ∀ (j : α), j ∈ s → j ≠ i → h j = f j) : s.prod (λ (i : α), g i) + s.prod (λ (i : α), h i) = s.prod (λ (i : α), f i)
theorem finset.mem_powerset_len {α : Type u_1} {n : ℕ} {s t : finset α} : s ∈ finset.powerset_len n t ↔ s ⊆ t ∧ s.card = n
theorem set.Union_eq_Union_finset {α : Type u_1} {ι : Type u_4} (s : ι → set α) : (⋃ (i : ι), s i) = ⋃ (t : finset ι) (i : ι) (H : i ∈ t), s i
theorem phragmen_lindelof.is_O_sub_exp_exp {E : Type u_1} [normed_group E] {a : ℝ} {f g : ℂ → E} {l : filter ℂ} {u : ℂ → ℝ} (hBf : ∃ (c : ℝ) (H : c < a) (B : ℝ), f =O[l] λ (z : ℂ), real.exp (B * real.exp (c * |u z|))) (hBg : ∃ (c : ℝ) (H : c < a) (B : ℝ), g =O[l] λ (z : ℂ), real.exp (B * real.exp (c * |u z|))) : ∃ (c : ℝ) (H : c < a) (B : ℝ), (f - g) =O[l] λ (z : ℂ), real.exp (B * real.exp (c * |u z|))
theorem exponent_exists.is_add_torsion {G : Type u_1} [add_group G] (h : add_monoid.exponent_exists G) : add_monoid.is_torsion G
theorem bounded_continuous_function.arzela_ascoli₁ {α : Type u} {β : Type v} [topological_space α] [compact_space α] [pseudo_metric_space β] [compact_space β] (A : set (bounded_continuous_function α β)) (closed : is_closed A) (H : ∀ (x : α) (ε : ℝ), ε > 0 → (∃ (U : set α) (H : U ∈ nhds x), ∀ (y : α), y ∈ U → ∀ (z : α), z ∈ U → ∀ (f : bounded_continuous_function α β), f ∈ A → has_dist.dist (⇑f y) (⇑f z) < ε)) : is_compact A
theorem quotient.induction_on₃' {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {s₁ : setoid α} {s₂ : setoid β} {s₃ : setoid γ} {p : quotient s₁ → quotient s₂ → quotient s₃ → Prop} (q₁ : quotient s₁) (q₂ : quotient s₂) (q₃ : quotient s₃) (h : ∀ (a₁ : α) (a₂ : β) (a₃ : γ), p (quotient.mk' a₁) (quotient.mk' a₂) (quotient.mk' a₃)) : p q₁ q₂ q₃
theorem is_scalar_tower.of_algebra_map_eq' {R : Type u} {S : Type v} {A : Type w} [comm_semiring R] [comm_semiring S] [semiring A] [algebra R S] [algebra S A] [algebra R A] (h : algebra_map R A = (algebra_map S A).comp (algebra_map R S)) : is_scalar_tower R S A
theorem int.zpow_le_iff_le_log {R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r) : ↑b ^ x ≤ r ↔ x ≤ int.log b r
theorem submodule.exists_sum_mem_mem_orthogonal {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) [complete_space ↥K] (v : E) : ∃ (y : E) (H : y ∈ K) (z : E) (H : z ∈ Kᗮ), v = y + z
theorem mul_hom.eq_on_mclosure {M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] {f g : M →ₙ* N} {s : set M} (h : set.eq_on ⇑f ⇑g s) : set.eq_on ⇑f ⇑g ↑(subsemigroup.closure s)
theorem local_homeomorph.has_strict_fderiv_at_symm {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] (f : local_homeomorph E F) {f' : E ≃L[𝕜] F} {a : F} (ha : a ∈ f.to_local_equiv.target) (htff' : has_strict_fderiv_at ⇑f ↑f' (⇑(f.symm) a)) : has_strict_fderiv_at ⇑(f.symm) ↑(f'.symm) a
theorem convex_independent.mono {𝕜 : Type u_1} {E : Type u_2} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] {s t : set E} (hc : convex_independent 𝕜 (λ (x : ↥t), ↑x)) (hs : s ⊆ t) : convex_independent 𝕜 (λ (x : ↥s), ↑x)
theorem category_theory.abelian.epi_fst_of_factor_thru_epi_mono_factorization {C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.limits.has_pullbacks C] {W X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) (g₁ : Y ⟶ W) [category_theory.epi g₁] (g₂ : W ⟶ Z) [category_theory.mono g₂] (hg : g₁ ≫ g₂ = g) (f' : X ⟶ W) (hf : f' ≫ g₂ = f) (t : category_theory.limits.pullback_cone f g) (ht : category_theory.limits.is_limit t) : category_theory.epi t.fst
theorem exists_open_singleton_of_open_finite {α : Type u} [topological_space α] [t0_space α] {s : set α} (hfin : s.finite) (hne : s.nonempty) (ho : is_open s) : ∃ (x : α) (H : x ∈ s), is_open {x}
theorem equiv.perm.swap_induction_on' {α : Type u} [decidable_eq α] [fintype α] {P : equiv.perm α → Prop} (f : equiv.perm α) : P 1 → (∀ (f : equiv.perm α) (x y : α), x ≠ y → P f → P (f * equiv.swap x y)) → P f
theorem local_homeomorph.is_image.of_preimage_eq' {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {e : local_homeomorph α β} {s : set α} {t : set β} : e.to_local_equiv.source ∩ ⇑e ⁻¹' (e.to_local_equiv.target ∩ t) = e.to_local_equiv.source ∩ s → e.is_image s t
theorem coe_coe {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} [has_coe α β] [has_coe_t β γ] (a : α) : ↑a = ↑↑a
theorem metric.inf_dist_empty {α : Type u} [pseudo_metric_space α] {x : α} : metric.inf_dist x ∅ = 0
theorem exists_nat_pow_near {α : Type u_1} [linear_ordered_ring α] [archimedean α] {x y : α} (hx : 1 ≤ x) (hy : 1 < y) : ∃ (n : ℕ), y ^ n ≤ x ∧ x < y ^ (n + 1)
theorem measure_theory.Lp_meas_to_Lp_trim_lie_symm_indicator {α : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space α} [one_le_p : fact (1 ≤ p)] [normed_space ℝ F] {hm : m ≤ m0} {s : set α} {μ : measure_theory.measure α} (hs : measurable_set s) (hμs : ⇑(μ.trim hm) s ≠ ⊤) (c : F) : ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F ℝ p μ hm).symm) (measure_theory.indicator_const_Lp p hs hμs c)) = measure_theory.indicator_const_Lp p _ _ c
theorem finprod_mem_range' {α : Type u_1} {β : Type u_2} {M : Type u_5} [comm_monoid M] {f : α → M} {g : β → α} (hg : set.inj_on g (function.mul_support (f ∘ g))) : finprod (λ (i : α), finprod (λ (H : i ∈ set.range g), f i)) = finprod (λ (j : β), f (g j))
theorem is_noetherian.dim_lt_aleph_0 (K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [is_noetherian K V] : module.rank K V < cardinal.aleph_0
theorem fermat_42.minimal_comm {a b c : ℤ} : fermat_42.minimal a b c → fermat_42.minimal b a c
theorem strict_convex_space.of_norm_add_lt {E : Type u_2} [normed_group E] [normed_space ℝ E] {a b : ℝ} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) (h : ∀ (x y : E), ∥x∥ ≤ 1 → ∥y∥ ≤ 1 → x ≠ y → ∥a • x + b • y∥ < 1) : strict_convex_space ℝ E
theorem complex.cos_add_sin_mul_I_pow (n : ℕ) (z : ℂ) : (complex.cos z + complex.sin z * complex.I) ^ n = complex.cos (↑n * z) + complex.sin (↑n * z) * complex.I
theorem category_theory.colimit_adj.restrict_yoneda_hom_equiv_natural {C : Type u₁} [category_theory.small_category C] {ℰ : Type u₂} [category_theory.category ℰ] (A : C ⥤ ℰ) (P : Cᵒᵖ ⥤ Type u₁) (E₁ E₂ : ℰ) (g : E₁ ⟶ E₂) {c : category_theory.limits.cocone ((category_theory.category_of_elements.π P).left_op ⋙ A)} (t : category_theory.limits.is_colimit c) (k : c.X ⟶ E₁) : ⇑(category_theory.colimit_adj.restrict_yoneda_hom_equiv A P E₂ t) (k ≫ g) = ⇑(category_theory.colimit_adj.restrict_yoneda_hom_equiv A P E₁ t) k ≫ (category_theory.colimit_adj.restricted_yoneda A).map g
theorem homotopy.comp_null_homotopic_map' {ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D E : homological_complex V c} (f : C ⟶ D) (hom : Π (i j : ι), c.rel j i → (D.X i ⟶ E.X j)) : f ≫ homotopy.null_homotopic_map' hom = homotopy.null_homotopic_map' (λ (i j : ι) (hij : c.rel j i), f.f i ≫ hom i j hij)
theorem category_theory.limits.braid_natural {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] {W X Y Z : C} (f : X ⟶ Y) (g : Z ⟶ W) : category_theory.limits.prod.map f g ≫ (category_theory.limits.prod.braiding Y W).hom = (category_theory.limits.prod.braiding X Z).hom ≫ category_theory.limits.prod.map g f
theorem first_order.language.elementary_embedding.comp_assoc {L : first_order.language} {M : Type u_3} {N : Type u_4} {P : Type u_5} {Q : Type u_6} [L.Structure M] [L.Structure N] [L.Structure P] [L.Structure Q] (f : L.elementary_embedding M N) (g : L.elementary_embedding N P) (h : L.elementary_embedding P Q) : (h.comp g).comp f = h.comp (g.comp f)
theorem emetric.subset_countable_closure_of_almost_dense_set {α : Type u} [pseudo_emetric_space α] (s : set α) (hs : ∀ (ε : ennreal), ε > 0 → (∃ (t : set α), t.countable ∧ s ⊆ ⋃ (x : α) (H : x ∈ t), emetric.closed_ball x ε)) : ∃ (t : set α) (H : t ⊆ s), t.countable ∧ s ⊆ closure t
theorem ideal.exists_le_maximal {α : Type u} [semiring α] (I : ideal α) (hI : I ≠ ⊤) : ∃ (M : ideal α), M.is_maximal ∧ I ≤ M
theorem linear_map.is_unit_det {M : Type u_2} [add_comm_group M] {A : Type u_1} [comm_ring A] [module A M] (f : M →ₗ[A] M) (hf : is_unit f) : is_unit (⇑linear_map.det f)
theorem direction_affine_span (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : (affine_span k s).direction = vector_span k s
theorem is_max.eq_top {α : Type u} [partial_order α] [order_top α] {a : α} : is_max a → a = ⊤
theorem edist_le_tsum_of_edist_le_of_tendsto₀ {α : Type u_1} [pseudo_emetric_space α] {f : ℕ → α} (d : ℕ → ennreal) (hf : ∀ (n : ℕ), has_edist.edist (f n) (f n.succ) ≤ d n) {a : α} (ha : filter.tendsto f filter.at_top (nhds a)) : has_edist.edist (f 0) a ≤ ∑' (m : ℕ), d m
theorem is_compact_of_finite_subcover {α : Type u} [topological_space α] {s : set α} (h : ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)) : is_compact s
theorem intermediate_field.sub_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} : x ∈ S → y ∈ S → x - y ∈ S
theorem function.periodic.interval_integral_add_eq_of_pos {E : Type u_1} [normed_group E] [normed_space ℝ E] [complete_space E] {f : ℝ → E} {T : ℝ} (hf : function.periodic f T) (hT : 0 < T) (t s : ℝ) : ∫ (x : ℝ) in t..t + T, f x = ∫ (x : ℝ) in s..s + T, f x
theorem add_subgroup.sub_mem {G : Type u_1} [add_group G] (H : add_subgroup G) {x y : G} (hx : x ∈ H) (hy : y ∈ H) : x - y ∈ H
theorem subadditive.tendsto_lim {u : ℕ → ℝ} (h : subadditive u) (hbdd : bdd_below (set.range (λ (n : ℕ), u n / ↑n))) : filter.tendsto (λ (n : ℕ), u n / ↑n) filter.at_top (nhds h.lim)
theorem add_monoid_hom.map_finsum_mem' {α : Type u_1} {M : Type u_5} {N : Type u_6} [add_comm_monoid M] [add_comm_monoid N] {s : set α} {f : α → M} (g : M →+ N) (h₀ : (s ∩ function.support f).finite) : ⇑g (finsum (λ (j : α), finsum (λ (H : j ∈ s), f j))) = finsum (λ (i : α), finsum (λ (H : i ∈ s), ⇑g (f i)))
theorem measure_theory.hahn_decomposition {α : Type u_1} [measurable_space α] {μ ν : measure_theory.measure α} [measure_theory.is_finite_measure μ] [measure_theory.is_finite_measure ν] : ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
theorem order_bot.bdd_below {γ : Type w} [preorder γ] [order_bot γ] (s : set γ) : bdd_below s
theorem metric.Hausdorff_dist_triangle {α : Type u} [pseudo_metric_space α] {s t u : set α} (fin : emetric.Hausdorff_edist s t ≠ ⊤) : metric.Hausdorff_dist s u ≤ metric.Hausdorff_dist s t + metric.Hausdorff_dist t u
theorem monovary_on.sum_comp_perm_smul_eq_sum_smul_iff {ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {s : finset ι} {σ : equiv.perm ι} {f : ι → α} {g : ι → β} (hfg : monovary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f (⇑σ i) • g i) = s.sum (λ (i : ι), f i • g i) ↔ monovary_on (f ∘ ⇑σ) g ↑s
theorem finset.le_sum_card {α : Type u_2} [decidable_eq α] {B : finset (finset α)} {n : ℕ} [fintype α] (h : ∀ (a : α), n ≤ (finset.filter (has_mem.mem a) B).card) : fintype.card α * n ≤ B.sum (λ (s : finset α), s.card)
theorem orientation.oangle_add_swap {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle y z + o.oangle x y = o.oangle x z
theorem function.periodic.tendsto_at_top_interval_integral_of_pos' {T : ℝ} {g : ℝ → ℝ} (hg : function.periodic g T) (h_int : ∀ (t₁ t₂ : ℝ), interval_integrable g measure_theory.measure_space.volume t₁ t₂) (h₀ : ∀ (x : ℝ), 0 < g x) (hT : 0 < T) : filter.tendsto (λ (t : ℝ), ∫ (x : ℝ) in 0..t, g x) filter.at_top filter.at_top
theorem finset.finite_to_set {α : Type u} (s : finset α) : ↑s.finite
theorem unop_map_list_prod {M : Type u_3} {N : Type u_4} [monoid M] [monoid N] {F : Type u_1} [monoid_hom_class F M Nᵐᵒᵖ] (f : F) (l : list M) : mul_opposite.unop (⇑f l.prod) = (list.map (mul_opposite.unop ∘ ⇑f) l).reverse.prod
theorem category_theory.limits.is_colimit.of_nat_iso.cocone_of_hom_fac {J : Type u₁} [category_theory.category J] {C : Type u₃} [category_theory.category C] {F : J ⥤ C} {X : C} (h : category_theory.coyoneda.obj (opposite.op X) ⋙ category_theory.ulift_functor ≅ F.cocones) {Y : C} (f : X ⟶ Y) : category_theory.limits.is_colimit.of_nat_iso.cocone_of_hom h f = (category_theory.limits.is_colimit.of_nat_iso.colimit_cocone h).extend f
theorem finsupp.span_eq_range_total {M : Type u_2} (R : Type u_5) [semiring R] [add_comm_monoid M] [module R M] (s : set M) : submodule.span R s = (finsupp.total ↥s M R coe).range
theorem map_nonunit {R : Type u} {S : Type v} [comm_semiring R] [local_ring R] [comm_semiring S] [local_ring S] (f : R →+* S) [is_local_ring_hom f] (a : R) (h : a ∈ local_ring.maximal_ideal R) : ⇑f a ∈ local_ring.maximal_ideal S
theorem subsingleton_of_zero_eq_one {M₀ : Type u_1} [mul_zero_one_class M₀] : 0 = 1 → subsingleton M₀
theorem list.nth_le_drop {α : Type u} (L : list α) {i j : ℕ} (h : i + j < L.length) : L.nth_le (i + j) h = (list.drop i L).nth_le j _
theorem set.definable.image_comp {M : Type w} {A : set M} {L : first_order.language} [L.Structure M] {α : Type u_1} {β : Type u_2} {s : set (β → M)} (h : A.definable L s) (f : α → β) [fintype α] [fintype β] : A.definable L ((λ (g : β → M), g ∘ f) '' s)
theorem cont_diff_within_at_fst {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : with_top ℕ} {s : set (E × F)} {p : E × F} : cont_diff_within_at 𝕜 n prod.fst s p
theorem group.fg_iff {G : Type u_3} [group G] : group.fg G ↔ ∃ (S : set G), subgroup.closure S = ⊤ ∧ S.finite
theorem differentiable_at.mdifferentiable_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {f : E → E'} {x : E} : differentiable_at 𝕜 f x → mdifferentiable_at (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f x
theorem linear_map.span_singleton_eq_range (R : Type u_1) (M : Type u_4) [semiring R] [add_comm_monoid M] [module R M] (x : M) : submodule.span R {x} = (linear_map.to_span_singleton R M x).range
theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0
theorem linear_isometry_equiv.reflections_generate {F : Type u_3} [inner_product_space ℝ F] [finite_dimensional ℝ F] : subgroup.closure (set.range (λ (v : F), reflection (submodule.span ℝ {v})ᗮ)) = ⊤
theorem orientation.oangle_sub_eq_oangle_sub_rev_of_norm_eq {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y : V} (h : ∥x∥ = ∥y∥) : o.oangle x (x - y) = o.oangle (y - x) y
theorem ring.neg_one_ne_one_of_char_ne_two {R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R ≠ 2) : -1 ≠ 1
theorem star_module.re_add_im {E : Type u_1} [add_comm_group E] [star_add_monoid E] [module ℂ E] [star_module ℂ E] (x : E) : ↑(⇑star_module.re x) + complex.I • ↑(⇑star_module.im x) = x
theorem left.inv_le_one_iff {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a
theorem cinfi_mono {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {f g : ι → α} (B : bdd_below (set.range f)) (H : ∀ (x : ι), f x ≤ g x) : infi f ≤ infi g
theorem has_le.le.absolutely_continuous {α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} (h : μ ≤ ν) : μ.absolutely_continuous ν
theorem finset.sum_card {α : Type u_2} [decidable_eq α] {B : finset (finset α)} {n : ℕ} [fintype α] (h : ∀ (a : α), (finset.filter (has_mem.mem a) B).card = n) : B.sum (λ (s : finset α), s.card) = fintype.card α * n
theorem power_series.coeff_order {R : Type u_1} [semiring R] {φ : power_series R} (h : φ.order.dom) : ⇑(power_series.coeff R (φ.order.get h)) φ ≠ 0
theorem local_equiv.eq_on_source.trans' {α : Type u_1} {β : Type u_2} {γ : Type u_3} {e e' : local_equiv α β} {f f' : local_equiv β γ} (he : e ≈ e') (hf : f ≈ f') : e.trans f ≈ e'.trans f'
theorem lt_tsub_iff_left_of_le {α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b c : α} [contravariant_class α α has_add.add has_le.le] (h : c ≤ b) : a < b - c ↔ c + a < b
theorem dense.diff_finite {α : Type u} [topological_space α] [t1_space α] [∀ (x : α), (nhds_within x {x}ᶜ).ne_bot] {s : set α} (hs : dense s) {t : set α} (ht : t.finite) : dense (s  t)
theorem continuous_within_at_of_locally_uniform_approx_of_continuous_within_at {α : Type u_1} {β : Type u_2} [uniform_space β] {f : α → β} {s : set α} {x : α} [topological_space α] (hx : x ∈ s) (L : ∀ (u : set (β × β)), u ∈ uniformity β → (∃ (t : set α) (H : t ∈ nhds_within x s) (F : α → β), continuous_within_at F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u)) : continuous_within_at f s x
theorem weighted_vsub_mem_vector_span {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} {s : finset ι} {w : ι → k} (h : s.sum (λ (i : ι), w i) = 0) (p : ι → P) : ⇑(s.weighted_vsub p) w ∈ vector_span k (set.range p)
theorem neg_strict_concave_on_iff {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [ordered_semiring 𝕜] [add_comm_monoid E] [ordered_add_comm_group β] [has_scalar 𝕜 E] [module 𝕜 β] {s : set E} {f : E → β} : strict_concave_on 𝕜 s (-f) ↔ strict_convex_on 𝕜 s f
theorem interval_integral.fderiv_integral_of_tendsto_ae {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {ca cb : E} {a b : ℝ} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (ha : filter.tendsto f (nhds a ⊓ measure_theory.measure_space.volume.ae) (nhds ca)) (hb : filter.tendsto f (nhds b ⊓ measure_theory.measure_space.volume.ae) (nhds cb)) : fderiv ℝ (λ (p : ℝ × ℝ), ∫ (x : ℝ) in p.fst..p.snd, f x) (a, b) = (continuous_linear_map.snd ℝ ℝ ℝ).smul_right cb - (continuous_linear_map.fst ℝ ℝ ℝ).smul_right ca
theorem zero_lt.right.mul_pos {α : Type u} {a b : α} [mul_zero_class α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 0 < a) (hb : 0 < b) : 0 < a * b
theorem left.add_neg_of_nonpos_of_neg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a ≤ 0) (hb : b < 0) : a + b < 0
theorem cSup_singleton {α : Type u_1} [conditionally_complete_lattice α] (a : α) : has_Sup.Sup {a} = a
theorem fintype.exists_sum_fiber_le_of_sum_le_nsmul {α : Type u} {β : Type v} {M : Type w} [decidable_eq β] [fintype α] [fintype β] (f : α → β) {w : α → M} {b : M} [linear_ordered_cancel_add_comm_monoid M] [nonempty β] (hb : finset.univ.sum (λ (x : α), w x) ≤ fintype.card β • b) : ∃ (y : β), (finset.filter (λ (x : α), f x = y) finset.univ).sum (λ (x : α), w x) ≤ b
theorem mem_nhds_within_Ici_iff_exists_Icc_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_max_order α] [densely_ordered α] {a : α} {s : set α} : s ∈ nhds_within a (set.Ici a) ↔ ∃ (u : α), a < u ∧ set.Icc a u ⊆ s
theorem inner_product_space.of_core.inner_mul_inner_self_le {𝕜 : Type u_1} {F : Type u_3} [is_R_or_C 𝕜] [add_comm_group F] [module 𝕜 F] [c : inner_product_space.core 𝕜 F] (x y : F) : is_R_or_C.abs (has_inner.inner x y) * is_R_or_C.abs (has_inner.inner y x) ≤ ⇑is_R_or_C.re (has_inner.inner x x) * ⇑is_R_or_C.re (has_inner.inner y y)
theorem trans_gen_of_pred_of_reflexive {α : Type u_1} [linear_order α] [pred_order α] [is_pred_archimedean α] (r : α → α → Prop) {n m : α} (hr : reflexive r) (h1 : ∀ (i : α), i ∈ set.Ioc m n → r i (order.pred i)) (h2 : ∀ (i : α), i ∈ set.Ioc n m → r (order.pred i) i) : relation.trans_gen r n m
theorem matrix.det_unique {R : Type v} [comm_ring R] {n : Type u_1} [unique n] [decidable_eq n] [fintype n] (A : matrix n n R) : A.det = A inhabited.default inhabited.default
theorem category_theory.limits.is_iso_colimit_cocone_parallel_pair_of_eq {C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} (h₀ : f = g) {c : category_theory.limits.cofork f g} (h : category_theory.limits.is_colimit c) : category_theory.is_iso c.π
theorem real.add_one_le_exp_of_nonneg {x : ℝ} (hx : 0 ≤ x) : x + 1 ≤ real.exp x
theorem padic_norm.add_eq_max_of_ne (p : ℕ) [hp : fact (nat.prime p)] {q r : ℚ} (hne : padic_norm p q ≠ padic_norm p r) : padic_norm p (q + r) = linear_order.max (padic_norm p q) (padic_norm p r)
theorem geom_gold_conj_is_sol_fib_rec  : fib_rec.is_solution (has_pow.pow golden_conj)
theorem add_subgroup.norm_normed_mk {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (h : ↑(S.topological_closure) ≠ set.univ) : ∥S.normed_mk∥ = 1
theorem ascending_central_series_le_upper {G : Type u_1} [group G] (H : ℕ → subgroup G) (hH : is_ascending_central_series H) (n : ℕ) : H n ≤ upper_central_series G n
theorem continuous_of_continuous_at_zero {G : Type w} [topological_space G] [add_group G] [topological_add_group G] {M : Type u_1} {hom : Type u_2} [add_zero_class M] [topological_space M] [has_continuous_add M] [add_monoid_hom_class hom G M] (f : hom) (hf : continuous_at ⇑f 0) : continuous ⇑f
theorem continuous_map.exists_tendsto_compact_open_iff_forall {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α] [t2_space α] [t2_space β] {ι : Type u_3} {l : filter ι} [l.ne_bot] (F : ι → C(α, β)) : (∃ (f : C(α, β)), filter.tendsto F l (nhds f)) ↔ ∀ (s : set α), is_compact s → (∃ (f : C(↥s, β)), filter.tendsto (λ (i : ι), continuous_map.restrict s (F i)) l (nhds f))
theorem metric.exists_lt_mem_ball_of_mem_ball {α : Type u} [pseudo_metric_space α] {x y : α} {ε : ℝ} (h : x ∈ metric.ball y ε) : ∃ (ε' : ℝ) (H : ε' < ε), x ∈ metric.ball y ε'
theorem closure_convex_hull_extreme_points {E : Type u_1} [normed_group E] [normed_space ℝ E] {s : set E} (hscomp : is_compact s) (hAconv : convex ℝ s) : closure (⇑(convex_hull ℝ) (set.extreme_points ℝ s)) = s
theorem multilinear_map.mk_continuous_norm_le {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : multilinear_map 𝕜 E G) {C : ℝ} (hC : 0 ≤ C) (H : ∀ (m : Π (i : ι), E i), ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : ι), ∥m i∥)) : ∥f.mk_continuous C H∥ ≤ C
theorem metric.mem_closure_iff {α : Type u} [pseudo_metric_space α] {s : set α} {a : α} : a ∈ closure s ↔ ∀ (ε : ℝ), ε > 0 → (∃ (b : α) (H : b ∈ s), has_dist.dist a b < ε)
theorem filter.tendsto.at_top_mul {α : Type u} {β : Type v} [linear_ordered_field α] [topological_space α] [order_topology α] {l : filter β} {f g : β → α} {C : α} (hC : 0 < C) (hf : filter.tendsto f l filter.at_top) (hg : filter.tendsto g l (nhds C)) : filter.tendsto (λ (x : β), f x * g x) l filter.at_top
theorem metric.cauchy_seq_iff {α : Type u} {β : Type v} [pseudo_metric_space α] [nonempty β] [semilattice_sup β] {u : β → α} : cauchy_seq u ↔ ∀ (ε : ℝ), ε > 0 → (∃ (N : β), ∀ (m : β), m ≥ N → ∀ (n : β), n ≥ N → has_dist.dist (u m) (u n) < ε)
theorem orthonormal.conj_lie_symm {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) : hb.conj_lie.symm = hb.conj_lie
theorem real.inner_le_Lp_mul_Lq_has_sum_of_nonneg {ι : Type u} {f g : ι → ℝ} {p q : ℝ} (hpq : p.is_conjugate_exponent q) {A B : ℝ} (hA : 0 ≤ A) (hB : 0 ≤ B) (hf : ∀ (i : ι), 0 ≤ f i) (hg : ∀ (i : ι), 0 ≤ g i) (hf_sum : has_sum (λ (i : ι), f i ^ p) (A ^ p)) (hg_sum : has_sum (λ (i : ι), g i ^ q) (B ^ q)) : ∃ (C : ℝ), 0 ≤ C ∧ C ≤ A * B ∧ has_sum (λ (i : ι), f i * g i) C
theorem category_theory.abelian.pseudo_equal_trans {C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} : transitive (category_theory.abelian.pseudo_equal P)
theorem first_order.language.substructure.subset_closure {L : first_order.language} {M : Type w} [L.Structure M] {s : set M} : s ⊆ ↑(⇑(first_order.language.substructure.closure L) s)
theorem modular_group.smul_eq_lc_row0_add {g : matrix.special_linear_group (fin 2) ℤ} (z : upper_half_plane) {p : fin 2 → ℤ} (hp : is_coprime (p 0) (p 1)) (hg : ↑g 1 = p) : ↑(g • z) = ↑(⇑(modular_group.lc_row0 p) ↑↑g) / (↑(p 0) ^ 2 + ↑(p 1) ^ 2) + (↑(p 1) * ↑z - ↑(p 0)) / ((↑(p 0) ^ 2 + ↑(p 1) ^ 2) * (↑(p 0) * ↑z + ↑(p 1)))
theorem prod_mem {B : Type u_3} {S : B} {M : Type u_1} [comm_monoid M] [set_like B M] [submonoid_class B M] {ι : Type u_2} {t : finset ι} {f : ι → M} (h : ∀ (c : ι), c ∈ t → f c ∈ S) : t.prod (λ (c : ι), f c) ∈ S
theorem exists_ratio_deriv_eq_ratio_slope (f : ℝ → ℝ) {a b : ℝ} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hfd : differentiable_on ℝ f (set.Ioo a b)) (g : ℝ → ℝ) (hgc : continuous_on g (set.Icc a b)) (hgd : differentiable_on ℝ g (set.Ioo a b)) : ∃ (c : ℝ) (H : c ∈ set.Ioo a b), (g b - g a) * deriv f c = (f b - f a) * deriv g c
theorem formal_multilinear_series.radius_right_inv_pos_of_radius_pos {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) (i : E ≃L[𝕜] F) (hp : 0 < p.radius) : 0 < (p.right_inv i).radius
theorem is_dedekind_domain_iff_is_dedekind_domain_inv {A : Type u_2} [comm_ring A] [is_domain A] : is_dedekind_domain A ↔ is_dedekind_domain_inv A
theorem finrank_eq_one_iff_of_nonzero {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (v : V) (nz : v ≠ 0) : finite_dimensional.finrank K V = 1 ↔ submodule.span K {v} = ⊤
theorem inner_product_geometry.norm_sub_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two {V : Type u_1} [inner_product_space ℝ V] (x y : V) : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ ↔ inner_product_geometry.angle x y = real.pi / 2
theorem volume_region_between_eq_lintegral {α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {f g : α → ℝ} {s : set α} [measure_theory.sigma_finite μ] (hf : ae_measurable f (μ.restrict s)) (hg : ae_measurable g (μ.restrict s)) (hs : measurable_set s) : ⇑(μ.prod measure_theory.measure_space.volume) (region_between f g s) = ∫⁻ (y : α) in s, ennreal.of_real ((g - f) y) ∂μ
theorem con.con_gen_mono {M : Type u_1} [has_mul M] {r s : M → M → Prop} (h : ∀ (x y : M), r x y → s x y) : con_gen r ≤ con_gen s
theorem algebraic_geometry.LocallyRingedSpace.to_Γ_Spec_map_basic_open_eq (X : algebraic_geometry.LocallyRingedSpace) (r : ↥(algebraic_geometry.LocallyRingedSpace.Γ.obj (opposite.op X))) : X.to_Γ_Spec_map_basic_open r = X.to_RingedSpace.basic_open r
theorem zero_lt.right.one_le_mul_of_le_of_le {α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (b0 : 0 ≤ b) : 1 ≤ a * b
theorem even.convex_on_pow {n : ℕ} (hn : even n) : convex_on ℝ set.univ (λ (x : ℝ), x ^ n)
theorem cont_diff_on_succ_iff_fderiv_of_open {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {n : ℕ} (hs : is_open s) : cont_diff_on 𝕜 ↑(n + 1) f s ↔ differentiable_on 𝕜 f s ∧ cont_diff_on 𝕜 ↑n (λ (y : E), fderiv 𝕜 f y) s
theorem multiset.sub_le_iff_le_add {α : Type u_1} [decidable_eq α] {s t u : multiset α} : s - t ≤ u ↔ s ≤ u + t
theorem continuous_map.continuous_coe' {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α] : continuous coe_fn
theorem disjoint_nested_nhds {α : Type u} [topological_space α] [regular_space α] {x y : α} (h : x ≠ y) : ∃ (U₁ : set α) (H : U₁ ∈ nhds x) (V₁ : set α) (H : V₁ ∈ nhds x) (U₂ : set α) (H : U₂ ∈ nhds y) (V₂ : set α) (H : V₂ ∈ nhds y), is_closed V₁ ∧ is_closed V₂ ∧ is_open U₁ ∧ is_open U₂ ∧ V₁ ⊆ U₁ ∧ V₂ ⊆ U₂ ∧ U₁ ∩ U₂ = ∅
theorem has_dvd.dvd.mul_left {α : Type u_1} [comm_semigroup α] {a b : α} (h : a ∣ b) (c : α) : a ∣ c * b
theorem has_deriv_within_at_iff_has_fderiv_within_at {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {F : Type v} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {x : 𝕜} {s : set 𝕜} {f' : F} : has_deriv_within_at f f' s x ↔ has_fderiv_within_at f (1.smul_right f') s x
theorem smooth_bump_covering.exists_immersion_euclidean {ι : Type uι} {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] [t2_space M] [fintype ι] (f : (smooth_bump_covering ι I M)) : ∃ (n : ℕ) (e : M → euclidean_space ℝ (fin n)), smooth I (model_with_corners_self ℝ (euclidean_space ℝ (fin n))) e ∧ function.injective e ∧ ∀ (x : M), function.injective ⇑(mfderiv I (model_with_corners_self ℝ (euclidean_space ℝ (fin n))) e x)
theorem monoid_with_zero_hom.map_zpow {G₀ : Type u_1} {G₀' : Type u_2} [group_with_zero G₀] [group_with_zero G₀'] (f : G₀ →*₀ G₀') (x : G₀) (n : ℤ) : ⇑f (x ^ n) = ⇑f x ^ n
theorem bdd_below.image2 {α : Type u} {β : Type v} {γ : Type w} [preorder α] [preorder β] [preorder γ] {f : α → β → γ} {s : set α} {t : set β} (h₀ : ∀ (b : β), monotone (function.swap f b)) (h₁ : ∀ (a : α), monotone (f a)) : bdd_below s → bdd_below t → bdd_below (set.image2 f s t)
theorem count_succ_eq_count {p : ℕ → Prop} [decidable_pred p] {n : ℕ} : ¬p n → nat.count p (n + 1) = nat.count p n
theorem con.div {M : Type u_1} [group M] (c : con M) {w x y z : M} : ⇑c w x → ⇑c y z → ⇑c (w / y) (x / z)
theorem smooth_partition_of_unity.exists_is_subordinate {ι : Type uι} {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] [t2_space M] [sigma_compact_space M] {s : set M} (hs : is_closed s) (U : ι → set M) (ho : ∀ (i : ι), is_open (U i)) (hU : s ⊆ ⋃ (i : ι), U i) : ∃ (f : smooth_partition_of_unity ι I M s), f.is_subordinate U
theorem neg.is_add_group_hom {α : Type u} [add_comm_group α] : is_add_group_hom has_neg.neg
theorem line_map_slope_line_map_slope_line_map {k : Type u_1} {E : Type u_2} {PE : Type u_3} [field k] [add_comm_group E] [module k E] [add_torsor E PE] (f : k → PE) (a b r : k) : ⇑(affine_map.line_map (slope f (⇑(affine_map.line_map a b) r) b) (slope f a (⇑(affine_map.line_map a b) r))) r = slope f a b
theorem nat.partrec.code.smn  : ∃ (f : nat.partrec.code → ℕ → nat.partrec.code), computable₂ f ∧ ∀ (c : nat.partrec.code) (n x : ℕ), (f c n).eval x = c.eval (nat.mkpair n x)
theorem affine_independent.finrank_vector_span {k : Type u_1} {V : Type u_2} {P : Type u_3} {ι : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype ι] {p : ι → P} (hi : affine_independent k p) {n : ℕ} (hc : fintype.card ι = n + 1) : finite_dimensional.finrank k ↥(vector_span k (set.range p)) = n
theorem free_group.red.sublist {α : Type u} {L₁ L₂ : list (α × bool)} : free_group.red L₁ L₂ → L₂ <+ L₁
theorem zmod.quadratic_reciprocity (p q : ℕ) [fact (nat.prime p)] [fact (nat.prime q)] (hp1 : p ≠ 2) (hq1 : q ≠ 2) (hpq : p ≠ q) : zmod.legendre_sym q ↑p * zmod.legendre_sym p ↑q = (-1) ^ (p / 2 * (q / 2))
theorem continuous_map.exists_extension_forall_mem_of_closed_embedding {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] (f : C(X, ℝ)) {t : set ℝ} {e : X → Y} [hs : t.ord_connected] (hf : ∀ (x : X), ⇑f x ∈ t) (hne : t.nonempty) (he : closed_embedding e) : ∃ (g : C(Y, ℝ)), (∀ (y : Y), ⇑g y ∈ t) ∧ ⇑g ∘ e = ⇑f
theorem is_algebraic_iff_is_integral {K : Type u} {A : Type v} [field K] [ring A] [algebra K A] {x : A} : is_algebraic K x ↔ is_integral K x
theorem probability_theory.cond_count_add_compl_eq {α : Type u_1} [measurable_space α] [measurable_singleton_class α] {s : set α} (u t : set α) (hs : s.finite) : ⇑(probability_theory.cond_count (s ∩ u)) t * ⇑(probability_theory.cond_count s) u + ⇑(probability_theory.cond_count (s ∩ uᶜ)) t * ⇑(probability_theory.cond_count s) uᶜ = ⇑(probability_theory.cond_count s) t
theorem has_dvd.dvd.mul_right {α : Type u_1} [semigroup α] {a b : α} (h : a ∣ b) (c : α) : a ∣ b * c
theorem same_ray.exists_eq_smul {R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {v₁ v₂ : M} (h : same_ray R v₁ v₂) : ∃ (u : M) (a b : R), 0 ≤ a ∧ 0 ≤ b ∧ a + b = 1 ∧ v₁ = a • u ∧ v₂ = b • u
theorem finset.exists_lt_card_fiber_of_mul_lt_card_of_maps_to {α : Type u} {β : Type v} [decidable_eq β] {s : finset α} {t : finset β} {f : α → β} {n : ℕ} (hf : ∀ (a : α), a ∈ s → f a ∈ t) (hn : t.card * n < s.card) : ∃ (y : β) (H : y ∈ t), n < (finset.filter (λ (x : α), f x = y) s).card
theorem is_lub.of_subset_of_superset {α : Type u} [preorder α] {a : α} {s t p : set α} (hs : is_lub s a) (hp : is_lub p a) (hst : s ⊆ t) (htp : t ⊆ p) : is_lub t a
theorem polynomial.map_cyclotomic_int (n : ℕ) (R : Type u_1) [ring R] : polynomial.map (int.cast_ring_hom R) (polynomial.cyclotomic n ℤ) = polynomial.cyclotomic n R
theorem char.quadratic_char_eq_one_of_char_two {F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F = 2) {a : F} (ha : a ≠ 0) : char.quadratic_char F a = 1
theorem polynomial.nat_degree_prod {R : Type u} {ι : Type w} (s : finset ι) [comm_semiring R] [no_zero_divisors R] (f : ι → polynomial R) (h : ∀ (i : ι), i ∈ s → f i ≠ 0) : (s.prod (λ (i : ι), f i)).nat_degree = s.sum (λ (i : ι), (f i).nat_degree)
theorem measure_theory.uniform_integrable_iff {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [normed_group β] {p : ennreal} {f : ι → α → β} [measure_theory.is_finite_measure μ] (hp : 1 ≤ p) (hp' : p ≠ ⊤) : measure_theory.uniform_integrable f p μ ↔ (∀ (i : ι), measure_theory.strongly_measurable (f i)) ∧ ∀ (ε : ℝ), 0 < ε → (∃ (C : nnreal), ∀ (i : ι), measure_theory.snorm ({x : α | C ≤ ∥f i x∥₊}.indicator (f i)) p μ ≤ ennreal.of_real ε)
theorem has_deriv_at_of_has_deriv_at_of_ne {E : Type u_1} [normed_group E] [normed_space ℝ E] {f g : ℝ → E} {x : ℝ} (f_diff : ∀ (y : ℝ), y ≠ x → has_deriv_at f (g y) y) (hf : continuous_at f x) (hg : continuous_at g x) : has_deriv_at f (g x) x
theorem affinity_unit_closed_ball {E : Type u_2} [normed_group E] [normed_space ℝ E] {r : ℝ} (hr : 0 ≤ r) (x : E) : x +ᵥ r • metric.closed_ball 0 1 = metric.closed_ball x r
theorem nat.asc_factorial_eq_div (n k : ℕ) : n.asc_factorial k = (n + k).factorial / n.factorial
theorem orthonormal.two_zsmul_oangle_smul_smul_self {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x : V) {r₁ r₂ : ℝ} : 2 • hb.oangle (r₁ • x) (r₂ • x) = 0
theorem simple_graph.adj.card_common_neighbors_lt_degree {V : Type u} [fintype V] {G : simple_graph V} [decidable_rel G.adj] {v w : V} (h : G.adj v w) : fintype.card ↥(G.common_neighbors v w) < G.degree v
theorem matrix.aeval_self_charpoly {R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : ⇑(polynomial.aeval M) M.charpoly = 0
theorem ring_hom.map_sclosure {R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] (f : R →+* S) (s : set R) : subsemiring.map f (subsemiring.closure s) = subsemiring.closure (⇑f '' s)
theorem category_theory.idempotents.is_idempotent_complete_iff_has_equalizer_of_id_and_idempotent (C : Type u_1) [category_theory.category C] : category_theory.is_idempotent_complete C ↔ ∀ (X : C) (p : X ⟶ X), p ≫ p = p → category_theory.limits.has_equalizer (𝟙 X) p
theorem exists_dual_vector'' (𝕜 : Type v) [is_R_or_C 𝕜] {E : Type u} [normed_group E] [normed_space 𝕜 E] (x : E) : ∃ (g : E →L[𝕜] 𝕜), ∥g∥ ≤ 1 ∧ ⇑g x = ↑∥x∥
theorem set.definable.image_comp_embedding {M : Type w} {A : set M} {L : first_order.language} [L.Structure M] {α : Type u_1} {β : Type u_2} {s : set (β → M)} (h : A.definable L s) (f : α ↪ β) [fintype β] : A.definable L ((λ (g : β → M), g ∘ ⇑f) '' s)
theorem metric.closure_eq_Inter_thickening {α : Type u} [pseudo_emetric_space α] (E : set α) : closure E = ⋂ (δ : ℝ) (h : 0 < δ), metric.thickening δ E
theorem polynomial.of_finsupp_inj {R : Type u} [semiring R] {a b : add_monoid_algebra R ℕ} : {to_finsupp := a} = {to_finsupp := b} ↔ a = b
theorem cont_diff_at.snd'' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {n : with_top ℕ} {f : F → G} {x : E × F} (hf : cont_diff_at 𝕜 n f x.snd) : cont_diff_at 𝕜 n (λ (x : E × F), f x.snd) x
theorem fin.univ_succ (n : ℕ) : finset.univ = finset.cons 0 (finset.map {to_fun := fin.succ n, inj' := _} finset.univ) _
theorem vector.scanl_head {n : ℕ} {α : Type u_1} {β : Type u_2} (f : β → α → β) (b : β) (v : vector α n) : (vector.scanl f b v).head = b
theorem monotone.bUnion_Ico_Ioc_map_succ {α : Type u_1} {β : Type u_2} [linear_order α] [succ_order α] [is_succ_archimedean α] [linear_order β] {f : α → β} (hf : monotone f) (m n : α) : (⋃ (i : α) (H : i ∈ set.Ico m n), set.Ioc (f i) (f (order.succ i))) = set.Ioc (f m) (f n)
theorem measure_theory.measure.eq_on_open_of_ae_eq {X : Type u_1} {Y : Type u_2} [topological_space X] {m : measurable_space X} [topological_space Y] [t2_space Y] {μ : measure_theory.measure X} [μ.is_open_pos_measure] {U : set X} {f g : X → Y} (h : f =ᵐ[μ.restrict U] g) (hU : is_open U) (hf : continuous_on f U) (hg : continuous_on g U) : set.eq_on f g U
theorem polynomial.cyclotomic.is_coprime_rat {n m : ℕ} (h : n ≠ m) : is_coprime (polynomial.cyclotomic n ℚ) (polynomial.cyclotomic m ℚ)
theorem is_cyclotomic_extension.rat.discr_prime_pow_eq_unit_mul_pow' {p : ℕ+} {k : ℕ} {K : Type u} [field K] [char_zero K] {ζ : K} [hp : fact (nat.prime ↑p)] [is_cyclotomic_extension {p ^ k} ℚ K] (hζ : is_primitive_root ζ ↑(p ^ k)) : ∃ (u : ℤˣ) (n : ℕ), algebra.discr ℚ ⇑((is_primitive_root.sub_one_power_basis ℚ hζ).basis) = ↑u * ↑p ^ n
theorem nnreal.pow_arith_mean_le_arith_mean_pow {ι : Type u} (s : finset ι) (w z : ι → nnreal) (hw' : s.sum (λ (i : ι), w i) = 1) (n : ℕ) : s.sum (λ (i : ι), w i * z i) ^ n ≤ s.sum (λ (i : ι), w i * z i ^ n)
theorem ring_equiv.to_add_monoid_hom_commutes {R : Type u_4} {S : Type u_5} [non_assoc_semiring R] [non_assoc_semiring S] (f : R ≃+* S) : ↑f.to_add_monoid_hom = ↑f.to_add_monoid_hom
theorem antivary.sum_mul_le_sum_comp_perm_mul {ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {σ : equiv.perm ι} {f g : ι → α} [fintype ι] (hfg : antivary f g) : finset.univ.sum (λ (i : ι), f i * g i) ≤ finset.univ.sum (λ (i : ι), f (⇑σ i) * g i)
theorem matrix.nonsing_inv_mul {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) (h : is_unit A.det) : A⁻¹.mul A = 1
theorem interval_integral.has_deriv_at_integral_of_dominated_loc_of_deriv_le {𝕜 : Type u_1} [is_R_or_C 𝕜] {μ : measure_theory.measure ℝ} {E : Type u_2} [normed_group E] [normed_space ℝ E] [normed_space 𝕜 E] [complete_space E] {a b ε : ℝ} {bound : ℝ → ℝ} {F F' : 𝕜 → ℝ → E} {x₀ : 𝕜} (ε_pos : 0 < ε) (hF_meas : ∀ᶠ (x : 𝕜) in nhds x₀, measure_theory.ae_strongly_measurable (F x) (μ.restrict (set.interval_oc a b))) (hF_int : interval_integrable (F x₀) μ a b) (hF'_meas : measure_theory.ae_strongly_measurable (F' x₀) (μ.restrict (set.interval_oc a b))) (h_bound : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → ∀ (x : 𝕜), x ∈ metric.ball x₀ ε → ∥F' x t∥ ≤ bound t) (bound_integrable : interval_integrable bound μ a b) (h_diff : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → ∀ (x : 𝕜), x ∈ metric.ball x₀ ε → has_deriv_at (λ (x : 𝕜), F x t) (F' x t) x) : interval_integrable (F' x₀) μ a b ∧ has_deriv_at (λ (x : 𝕜), ∫ (t : ℝ) in a..b, F x t ∂μ) (∫ (t : ℝ) in a..b, F' x₀ t ∂μ) x₀
theorem has_fderiv_at_integral_of_dominated_of_fderiv_le {α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {𝕜 : Type u_2} [is_R_or_C 𝕜] {E : Type u_3} [normed_group E] [normed_space ℝ E] [normed_space 𝕜 E] [complete_space E] {H : Type u_4} [normed_group H] [normed_space 𝕜 H] {F : H → α → E} {F' : H → α → (H →L[𝕜] E)} {x₀ : H} {bound : α → ℝ} {ε : ℝ} (ε_pos : 0 < ε) (hF_meas : ∀ᶠ (x : H) in nhds x₀, measure_theory.ae_strongly_measurable (F x) μ) (hF_int : measure_theory.integrable (F x₀) μ) (hF'_meas : measure_theory.ae_strongly_measurable (F' x₀) μ) (h_bound : ∀ᵐ (a : α) ∂μ, ∀ (x : H), x ∈ metric.ball x₀ ε → ∥F' x a∥ ≤ bound a) (bound_integrable : measure_theory.integrable bound μ) (h_diff : ∀ᵐ (a : α) ∂μ, ∀ (x : H), x ∈ metric.ball x₀ ε → has_fderiv_at (λ (x : H), F x a) (F' x a) x) : has_fderiv_at (λ (x : H), ∫ (a : α), F x a ∂μ) (∫ (a : α), F' x₀ a ∂μ) x₀
theorem metric.inf_dist_lt_iff {α : Type u} [pseudo_metric_space α] {s : set α} {x : α} {r : ℝ} (hs : s.nonempty) : metric.inf_dist x s < r ↔ ∃ (y : α) (H : y ∈ s), has_dist.dist x y < r
theorem is_add_submonoid.multiset_sum_mem {M : Type u_1} [add_comm_monoid M] {s : set M} (hs : is_add_submonoid s) (m : multiset M) : (∀ (a : M), a ∈ m → a ∈ s) → m.sum ∈ s
theorem polynomial.C'_mem_lifts {R : Type u} [semiring R] {S : Type v} [semiring S] {f : R →+* S} {s : S} (h : s ∈ set.range ⇑f) : ⇑polynomial.C s ∈ polynomial.lifts f
theorem affine_subspace.direction_inf {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P) : (s1 ⊓ s2).direction ≤ s1.direction ⊓ s2.direction
theorem ae_mono' {α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} : μ.absolutely_continuous ν → μ.ae ≤ ν.ae
theorem padic_val_rat.self {p : ℕ} (hp : 1 < p) : padic_val_rat p ↑p = 1
theorem list.take_append_eq_append_take {α : Type u} {l₁ l₂ : list α} {n : ℕ} : list.take n (l₁ ++ l₂) = list.take n l₁ ++ list.take (n - l₁.length) l₂
theorem nat.factorization_inj  : set.inj_on nat.factorization {x : ℕ | x ≠ 0}
theorem add_submonoid.bot_or_nontrivial {M : Type u_1} [add_zero_class M] (S : add_submonoid M) : S = ⊥ ∨ nontrivial ↥S
theorem star_convex_iff_div {𝕜 : Type u_1} {E : Type u_2} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] {x : E} {s : set E} : star_convex 𝕜 x s ↔ ∀ ⦃y : E⦄, y ∈ s → ∀ ⦃a b : 𝕜⦄, 0 ≤ a → 0 ≤ b → 0 < a + b → (a / (a + b)) • x + (b / (a + b)) • y ∈ s
theorem norm_add_pow_two_real {F : Type u_3} [inner_product_space ℝ F] {x y : F} : ∥x + y∥ ^ 2 = ∥x∥ ^ 2 + 2 * has_inner.inner x y + ∥y∥ ^ 2
theorem finset.prod_mul_prod_compl {β : Type u} {α : Type v} [comm_monoid β] [fintype α] [decidable_eq α] (s : finset α) (f : α → β) : s.prod (λ (i : α), f i) * sᶜ.prod (λ (i : α), f i) = finset.univ.prod (λ (i : α), f i)
theorem ideal.le_of_dvd {R : Type u} [comm_semiring R] {I J : ideal R} : I ∣ J → J ≤ I
theorem list.sorted.insertion_sort_eq {α : Type uu} {r : α → α → Prop} [decidable_rel r] {l : list α} (h : list.sorted r l) : list.insertion_sort r l = l
theorem has_subset.subset.antisymm' {α : Type u} [has_subset α] {a b : α} [is_antisymm α has_subset.subset] (h : a ⊆ b) (h' : b ⊆ a) : b = a
theorem category_theory.limits.wide_equalizer.hom_ext {J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J → (X ⟶ Y)} [category_theory.limits.has_wide_equalizer f] [nonempty J] {W : C} {k l : W ⟶ category_theory.limits.wide_equalizer f} (h : k ≫ category_theory.limits.wide_equalizer.ι f = l ≫ category_theory.limits.wide_equalizer.ι f) : k = l
theorem nat.pow_dvd_pow_iff_le_right {x k l : ℕ} (w : 1 < x) : x ^ k ∣ x ^ l ↔ k ≤ l
theorem fintype.univ_of_is_empty {α : Type u_1} [is_empty α] : finset.univ = ∅
theorem is_topological_fiber_bundle.surjective_proj {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : function.surjective proj
theorem matrix.det_mul_right_comm {m : Type u_1} [decidable_eq m] [fintype m] {R : Type v} [comm_ring R] (M N P : matrix m m R) : ((M.mul N).mul P).det = ((M.mul P).mul N).det
theorem measure_theory.map_prod_mul_eq_swap {G : Type u_1} [measurable_space G] [group G] [has_measurable_mul₂ G] (μ ν : measure_theory.measure G) [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] [μ.is_mul_left_invariant] : measure_theory.measure.map (λ (z : G × G), (z.snd, z.snd * z.fst)) (μ.prod ν) = ν.prod μ
theorem mul_action.stabilizer_smul_eq_stabilizer_map_conj {α : Type u} {β : Type v} [group α] [mul_action α β] (g : α) (x : β) : mul_action.stabilizer α (g • x) = subgroup.map (mul_equiv.to_monoid_hom (⇑mul_aut.conj g)) (mul_action.stabilizer α x)
theorem simplex_category.δ_comp_σ_of_gt {n : ℕ} {i : fin (n + 2)} {j : fin (n + 1)} (H : ⇑fin.cast_succ j < i) : simplex_category.δ i.succ ≫ simplex_category.σ (⇑fin.cast_succ j) = simplex_category.σ j ≫ simplex_category.δ i
theorem strict_convex_on.ae_eq_const_or_map_average_lt {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {f : α → E} {g : E → ℝ} [measure_theory.is_finite_measure μ] (hg : strict_convex_on ℝ s g) (hgc : continuous_on g s) (hsc : is_closed s) (hfs : ∀ᵐ (x : α) ∂μ, f x ∈ s) (hfi : measure_theory.integrable f μ) (hgi : measure_theory.integrable (g ∘ f) μ) : f =ᵐ[μ] function.const α (⨍ (x : α), f x ∂μ) ∨ g (⨍ (x : α), f x ∂μ) < ⨍ (x : α), g (f x) ∂μ
theorem measure_theory.finite_measure.tendsto_lintegral_nn_of_le_const {α : Type u_1} [measurable_space α] [topological_space α] [opens_measurable_space α] (μ : measure_theory.finite_measure α) {fs : ℕ → bounded_continuous_function α nnreal} {c : nnreal} (fs_le_const : ∀ (n : ℕ) (a : α), ⇑(fs n) a ≤ c) {f : α → nnreal} (fs_lim : ∀ (a : α), filter.tendsto (λ (n : ℕ), ⇑(fs n) a) filter.at_top (nhds (f a))) : filter.tendsto (λ (n : ℕ), ∫⁻ (a : α), ↑(⇑(fs n) a) ∂↑μ) filter.at_top (nhds (∫⁻ (a : α), ↑(f a) ∂↑μ))
theorem balanced_ball_zero {𝕜 : Type u_3} {E : Type u_4} [normed_field 𝕜] [semi_normed_group E] [normed_space 𝕜 E] {r : ℝ} : balanced 𝕜 (metric.ball 0 r)
theorem tendsto_uniformly.tendsto_at {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {p : filter ι} (h : tendsto_uniformly F f p) (x : α) : filter.tendsto (λ (n : ι), F n x) p (nhds (f x))
theorem subfield.ext {K : Type u} [field K] {S T : subfield K} (h : ∀ (x : K), x ∈ S ↔ x ∈ T) : S = T
theorem filter.tendsto.at_bot_mul_const {α : Type u_3} {β : Type u_4} [linear_ordered_field α] {l : filter β} {f : β → α} {r : α} (hr : 0 < r) (hf : filter.tendsto f l filter.at_bot) : filter.tendsto (λ (x : β), f x * r) l filter.at_bot
theorem category_theory.abelian.of_coimage_image_comparison_is_iso.has_images {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] [category_theory.limits.has_cokernels C] [∀ {X Y : C} (f : X ⟶ Y), category_theory.is_iso (category_theory.abelian.coimage_image_comparison f)] : category_theory.limits.has_images C
theorem alg_equiv.coe_ring_hom_commutes {R : Type u} {A₁ : Type v} {A₂ : Type w} [comm_semiring R] [semiring A₁] [semiring A₂] [algebra R A₁] [algebra R A₂] (e : A₁ ≃ₐ[R] A₂) : ↑↑e = ↑↑e
theorem add_con.mk'_ker {M : Type u_1} [add_zero_class M] (c : add_con M) : add_con.ker c.mk' = c
theorem measure_theory.Lp.mul_meas_ge_le_pow_norm' {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} {p : ennreal} {μ : measure_theory.measure α} [normed_group E] (f : ↥(measure_theory.Lp E p μ)) (hp_ne_zero : p ≠ 0) (hp_ne_top : p ≠ ⊤) (ε : ennreal) : ε ^ p.to_real * ⇑μ {x : α | ε ≤ ↑∥⇑f x∥₊} ≤ ennreal.of_real ∥f∥ ^ p.to_real
theorem Mon.filtered_colimits.colimit_mul_mk_eq {J : Type v} [category_theory.small_category J] (F : J ⥤ Mon) [category_theory.is_filtered J] (x y : Σ (j : J), ↥(F.obj j)) (k : J) (f : x.fst ⟶ k) (g : y.fst ⟶ k) : Mon.filtered_colimits.M.mk F x * Mon.filtered_colimits.M.mk F y = Mon.filtered_colimits.M.mk F ⟨k, ⇑(F.map f) x.snd * ⇑(F.map g) y.snd⟩
theorem is_closed.not_mem_iff_inf_dist_pos {α : Type u} [pseudo_metric_space α] {s : set α} {x : α} (h : is_closed s) (hs : s.nonempty) : x ∉ s ↔ 0 < metric.inf_dist x s
theorem nat.partrec.code.eval_prec_succ (cf cg : nat.partrec.code) (a k : ℕ) : (cf.prec cg).eval (nat.mkpair a k.succ) = (cf.prec cg).eval (nat.mkpair a k) >>= λ (ih : ℕ), cg.eval (nat.mkpair a (nat.mkpair k ih))
theorem iterated_deriv_eq_equiv_comp {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {n : ℕ} {f : 𝕜 → F} : iterated_deriv n f = ⇑((continuous_multilinear_map.pi_field_equiv 𝕜 (fin n) F).symm) ∘ iterated_fderiv 𝕜 n f
theorem continuous_at.fst {α : Type u} {β : Type v} {γ : Type u_1} [topological_space α] [topological_space β] [topological_space γ] {f : α → β × γ} {x : α} (hf : continuous_at f x) : continuous_at (λ (a : α), (f a).fst) x
theorem is_topological_fiber_bundle.quotient_map_proj {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : quotient_map proj
theorem closure_Ioo {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b) : closure (set.Ioo a b) = set.Icc a b
theorem monoid_with_zero_hom.ext_iff {M : Type u_3} {N : Type u_4} [mul_zero_one_class M] [mul_zero_one_class N] {f g : M →*₀ N} : f = g ↔ ∀ (x : M), ⇑f x = ⇑g x
theorem ordering.compares.swap {α : Type u_1} [has_lt α] {a b : α} {o : ordering} : o.compares b a → o.swap.compares a b
theorem antitone_on.map_bdd_above {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s t : set α} (Hf : antitone_on f t) (Hst : s ⊆ t) : (upper_bounds s ∩ t).nonempty → bdd_below (f '' s)
theorem group_topology.continuous_mul' {α : Type u} [group α] (g : group_topology α) : continuous (λ (p : α × α), p.fst * p.snd)
theorem metric.bounded_union {α : Type u} [pseudo_metric_space α] {s t : set α} : metric.bounded (s ∪ t) ↔ metric.bounded s ∧ metric.bounded t
theorem category_theory.le_of_hom {X : Type u} [preorder X] {x y : X} (h : x ⟶ y) : x ≤ y
theorem quiver.shortest_path_spec {V : Type u} [quiver V] (r : V) [quiver.rooted_connected r] {a : V} (p : quiver.path r a) : (quiver.shortest_path r a).length ≤ p.length
theorem matrix.conj_transpose_eq_adjoint {𝕜 : Type u_1} [is_R_or_C 𝕜] {m : Type u_5} {n : Type u_6} [fintype m] [decidable_eq m] [fintype n] [decidable_eq n] (A : matrix m n 𝕜) : ⇑matrix.to_lin' A.conj_transpose = ⇑linear_map.adjoint (⇑matrix.to_lin' A)
theorem metric.inf_dist_singleton {α : Type u} [pseudo_metric_space α] {x y : α} : metric.inf_dist x {y} = has_dist.dist x y
theorem is_regular.and_of_mul_of_mul {R : Type u_1} {a b : R} [semigroup R] (ab : is_regular (a * b)) (ba : is_regular (b * a)) : is_regular a ∧ is_regular b
theorem monotone.pairwise_disjoint_on_Ico_succ {α : Type u_1} {β : Type u_2} [linear_order α] [succ_order α] [preorder β] {f : α → β} (hf : monotone f) : pairwise (disjoint on λ (n : α), set.Ico (f n) (f (order.succ n)))
theorem zero_lt.right.one_lt_mul_of_lt_of_lt {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 1 < a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b
theorem measure_theory.exists_upper_semicontinuous_le_lintegral_le {α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] {μ : measure_theory.measure α} [μ.weakly_regular] (f : α → nnreal) (int_f : ∫⁻ (x : α), ↑(f x) ∂μ ≠ ⊤) {ε : ennreal} (ε0 : ε ≠ 0) : ∃ (g : α → nnreal), (∀ (x : α), g x ≤ f x) ∧ upper_semicontinuous g ∧ ∫⁻ (x : α), ↑(f x) ∂μ ≤ ∫⁻ (x : α), ↑(g x) ∂μ + ε
theorem has_lt.lt.dual {α : Type u_1} [has_lt α] {a b : α} : b < a → ⇑order_dual.to_dual a < ⇑order_dual.to_dual b
theorem sub_neg_of_lt {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a < b → a - b < 0
theorem cardinal.mk_quaternion (R : Type u_1) [has_one R] [has_neg R] : cardinal.mk (quaternion R) = cardinal.mk R ^ 4
theorem finset.image_image₂_right_comm {α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} [decidable_eq β'] [decidable_eq γ] [decidable_eq δ] {s : finset α} {t : finset β} {f : α → β' → γ} {g : β → β'} {f' : α → β → δ} {g' : δ → γ} (h_right_comm : ∀ (a : α) (b : β), f a (g b) = g' (f' a b)) : finset.image₂ f s (finset.image g t) = finset.image g' (finset.image₂ f' s t)
theorem orthonormal.oangle_rev {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x y : V) : hb.oangle y x = -hb.oangle x y
theorem is_local_min.deriv_eq_zero {f : ℝ → ℝ} {a : ℝ} (h : is_local_min f a) : deriv f a = 0
theorem bilin_form.is_Ortho.not_is_ortho_basis_self_of_nondegenerate {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] {n : Type w} [nontrivial R] {B : bilin_form R M} {v : basis n R M} (h : B.is_Ortho ⇑v) (hB : B.nondegenerate) (i : n) : ¬B.is_ortho (⇑v i) (⇑v i)
theorem basis.to_matrix_is_unit_smul {ι : Type u_1} {R₂ : Type u_7} {M₂ : Type u_8} [comm_ring R₂] [add_comm_group M₂] [module R₂ M₂] [decidable_eq ι] (e : basis ι R₂ M₂) {w : ι → R₂} (hw : ∀ (i : ι), is_unit (w i)) : e.to_matrix ⇑(e.is_unit_smul hw) = matrix.diagonal w
theorem spectrum.nonempty_of_is_alg_closed_of_finite_dimensional (𝕜 : Type u) {A : Type v} [field 𝕜] [ring A] [algebra 𝕜 A] [is_alg_closed 𝕜] [nontrivial A] [I : finite_dimensional 𝕜 A] (a : A) : ∃ (k : 𝕜), k ∈ spectrum 𝕜 a
theorem intermediate_field.neg_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x : L} : x ∈ S → -x ∈ S
theorem mt {a b : Prop} (h₁ : a → b) (h₂ : ¬b) : ¬a
theorem bornology.is_cobounded.compl {α : Type u_2} [bornology α] {s : set α} : bornology.is_cobounded s → bornology.is_bounded sᶜ
theorem function.periodic_orbit_def {α : Type u_1} (f : α → α) (x : α) : function.periodic_orbit f x = ↑(list.map (λ (n : ℕ), f^[n] x) (list.range (function.minimal_period f x)))
theorem measure_theory.set_integral_condexp {α : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space ℝ F'] [complete_space F'] {m m0 : measurable_space α} {μ : measure_theory.measure α} {f : α → F'} {s : set α} (hm : m ≤ m0) [measure_theory.sigma_finite (μ.trim hm)] (hf : measure_theory.integrable f μ) (hs : measurable_set s) : ∫ (x : α) in s, measure_theory.condexp m μ f x ∂μ = ∫ (x : α) in s, f x ∂μ
theorem convex.lipschitz_on_with_of_nnnorm_fderiv_within_le {E : Type u_1} [normed_group E] [normed_space ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_space 𝕜 E] [normed_group G] [normed_space 𝕜 G] {f : E → G} {s : set E} {C : nnreal} (hf : differentiable_on 𝕜 f s) (bound : ∀ (x : E), x ∈ s → ∥fderiv_within 𝕜 f s x∥₊ ≤ C) (hs : convex ℝ s) : lipschitz_on_with C f s
theorem antivary_on.sum_smul_eq_sum_smul_comp_perm_iff {ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {s : finset ι} {σ : equiv.perm ι} {f : ι → α} {g : ι → β} (hfg : antivary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i • g (⇑σ i)) = s.sum (λ (i : ι), f i • g i) ↔ antivary_on f (g ∘ ⇑σ) ↑s
theorem semiconj_by.one_right {M : Type u} [mul_one_class M] (a : M) : semiconj_by a 1 1
theorem category_theory.nat_trans.mono_app_of_mono {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {F G : C ⥤ D} (α : F ⟶ G) [∀ (X : C), category_theory.mono (α.app X)] : category_theory.mono α
theorem submonoid.localization_map.mul_inv_left {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {f : M →* N} (h : ∀ (y : ↥S), is_unit (⇑f ↑y)) (y : ↥S) (w z : N) : w * ↑(⇑(is_unit.lift_right (f.restrict S) h) y)⁻¹ = z ↔ w = ⇑f ↑y * z
theorem measure_theory.mul_meas_ge_le_lintegral₀ {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : α → ennreal} (hf : ae_measurable f μ) (ε : ennreal) : ε * ⇑μ {x : α | ε ≤ f x} ≤ ∫⁻ (a : α), f a ∂μ
theorem subfield.one_mem {K : Type u} [field K] (s : subfield K) : 1 ∈ s
theorem basis.ext' {ι : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (b : basis ι R M) {R₁ : Type u_9} [semiring R₁] {σ : R →+* R₁} {σ' : R₁ →+* R} [ring_hom_inv_pair σ σ'] [ring_hom_inv_pair σ' σ] {M₁ : Type u_10} [add_comm_monoid M₁] [module R₁ M₁] {f₁ f₂ : M ≃ₛₗ[σ] M₁} (h : ∀ (i : ι), ⇑f₁ (⇑b i) = ⇑f₂ (⇑b i)) : f₁ = f₂
theorem category_theory.is_cofiltered.inf_objs_exists {C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] (O : finset C) : ∃ (S : C), ∀ {X : C}, X ∈ O → nonempty (S ⟶ X)
theorem measure_theory.Lp.induction {α : Type u_1} {E : Type u_4} [measurable_space α] [normed_group E] {p : ennreal} {μ : measure_theory.measure α} [fact (1 ≤ p)] (hp_ne_top : p ≠ ⊤) (P : ↥(measure_theory.Lp E p μ) → Prop) (h_ind : ∀ (c : E) {s : set α} (hs : measurable_set s) (hμs : ⇑μ s < ⊤), P ↑(measure_theory.Lp.simple_func.indicator_const p hs _ c)) (h_add : ∀ ⦃f g : α → E⦄ (hf : measure_theory.mem_ℒp f p μ) (hg : measure_theory.mem_ℒp g p μ), disjoint (function.support f) (function.support g) → P (measure_theory.mem_ℒp.to_Lp f hf) → P (measure_theory.mem_ℒp.to_Lp g hg) → P (measure_theory.mem_ℒp.to_Lp f hf + measure_theory.mem_ℒp.to_Lp g hg)) (h_closed : is_closed {f : ↥(measure_theory.Lp E p μ) | P f}) (f : ↥(measure_theory.Lp E p μ)) : P f
theorem finset.fold_ite' {α : Type u_1} {β : Type u_2} {op : β → β → β} [hc : is_commutative β op] [ha : is_associative β op] {f : α → β} {b : β} {s : finset α} {g : α → β} (hb : op b b = b) (p : α → Prop) [decidable_pred p] : finset.fold op b (λ (i : α), ite (p i) (f i) (g i)) s = op (finset.fold op b f (finset.filter p s)) (finset.fold op b g (finset.filter (λ (i : α), ¬p i) s))
theorem box_integral.integrable_iff_cauchy_basis {ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} [complete_space F] : box_integral.integrable I l f vol ↔ ∀ (ε : ℝ), ε > 0 → (∃ (r : nnreal → (ι → ℝ) → ↥(set.Ioi 0)), (∀ (c : nnreal), l.r_cond (r c)) ∧ ∀ (c₁ c₂ : nnreal) (π₁ π₂ : box_integral.tagged_prepartition I), l.mem_base_set I c₁ (r c₁) π₁ → π₁.is_partition → l.mem_base_set I c₂ (r c₂) π₂ → π₂.is_partition → has_dist.dist (box_integral.integral_sum f vol π₁) (box_integral.integral_sum f vol π₂) ≤ ε)
theorem box_integral.integrable.dist_integral_sum_sum_integral_le_of_mem_base_set {ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} {π : box_integral.tagged_prepartition I} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} {c : nnreal} {ε : ℝ} [complete_space F] (h : box_integral.integrable I l f vol) (h0 : 0 < ε) (hπ : l.mem_base_set I c (h.convergence_r ε c) π) : has_dist.dist (box_integral.integral_sum f vol π) (π.to_prepartition.boxes.sum (λ (J : box_integral.box ι), box_integral.integral J l f vol)) ≤ ε
theorem char.is_square_neg_one_iff {F : Type u_1} [field F] [fintype F] : is_square (-1) ↔ fintype.card F % 4 ≠ 3
theorem is_fixed_pt_of_tendsto_iterate {α : Type u_1} [topological_space α] [t2_space α] {f : α → α} {x y : α} (hy : filter.tendsto (λ (n : ℕ), f^[n] x) filter.at_top (nhds y)) (hf : continuous_at f y) : function.is_fixed_pt f y
theorem has_sum_fourier_series (f : ↥(measure_theory.Lp ℂ 2 haar_circle)) : has_sum (λ (i : ℤ), ⇑(⇑(fourier_series.repr) f) i • fourier_Lp 2 i) f
theorem generalized_continued_fraction.succ_nth_convergent'_eq_squash_gcf_nth_convergent' {K : Type u_1} {n : ℕ} {g : generalized_continued_fraction K} [division_ring K] : g.convergents' (n + 1) = (g.squash_gcf n).convergents' n
theorem basis.nonempty_fintype_index_of_dim_lt_aleph_0 {R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {ι : Type u_1} (b : basis ι R M) (h : module.rank R M < cardinal.aleph_0) : nonempty (fintype ι)
theorem complex.circle_integral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable {E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] {c : ℂ} {r R : ℝ} (h0 : 0 < r) (hle : r ≤ R) {f : ℂ → E} {s : set ℂ} (hs : s.countable) (hc : continuous_on f (metric.closed_ball c R  metric.ball c r)) (hd : ∀ (z : ℂ), z ∈ metric.ball c R  metric.closed_ball c r  s → differentiable_at ℂ f z) : ∮ (z : ℂ) in C(c, R), (z - c)⁻¹ • f z = ∮ (z : ℂ) in C(c, r), (z - c)⁻¹ • f z
theorem affine.simplex.points_with_circumcenter_point {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P n) (i : fin (n + 1)) : s.points_with_circumcenter (affine.simplex.points_with_circumcenter_index.point_index i) = s.points i
theorem category_theory.limits.has_coproducts_opposite {C : Type u₁} [category_theory.category C] (X : Type v₁) [category_theory.limits.has_products_of_shape X C] : category_theory.limits.has_coproducts_of_shape X Cᵒᵖ
theorem lower_semicontinuous.add' {α : Type u_1} [topological_space α] {γ : Type u_4} [linear_ordered_add_comm_monoid γ] [topological_space γ] [order_topology γ] {f g : α → γ} (hf : lower_semicontinuous f) (hg : lower_semicontinuous g) (hcont : ∀ (x : α), continuous_at (λ (p : γ × γ), p.fst + p.snd) (f x, g x)) : lower_semicontinuous (λ (z : α), f z + g z)
theorem edist_ne_top_of_mem_ball {β : Type u_2} [emetric_space β] {a : β} {r : ennreal} (x y : ↥(emetric.ball a r)) : has_edist.edist x.val y.val ≠ ⊤
theorem finsupp.comap_domain_zero {α : Type u_1} {β : Type u_2} {M : Type u_5} [has_zero M] (f : α → β) (hif : set.inj_on f (f ⁻¹' ↑(0.support)) := _) : finsupp.comap_domain f 0 hif = 0
theorem convex.null_measurable_set {E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] {s : set E} (hs : convex ℝ s) : measure_theory.null_measurable_set s μ
theorem le_neg_add_of_add_le {α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : a + b ≤ c → b ≤ -a + c
theorem is_totally_separated.is_totally_disconnected {α : Type u} [topological_space α] {s : set α} (H : is_totally_separated s) : is_totally_disconnected s
theorem bornology.is_vonN_bounded_singleton {𝕜 : Type u_1} {E : Type u_2} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [has_continuous_smul 𝕜 E] (x : E) : bornology.is_vonN_bounded 𝕜 {x}
theorem one_div_le_one_div_of_neg {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : a < 0) (hb : b < 0) : 1 / a ≤ 1 / b ↔ b ≤ a
theorem linear_map.is_Ortho.not_is_ortho_basis_self_of_separating_left {R : Type u_1} {M : Type u_5} {n : Type u_14} [comm_ring R] [add_comm_group M] [module R M] {I I' : R →+* R} [nontrivial R] {B : M →ₛₗ[I] M →ₛₗ[I'] R} {v : basis n R M} (h : B.is_Ortho ⇑v) (hB : B.separating_left) (i : n) : ¬B.is_ortho (⇑v i) (⇑v i)
theorem finsupp.on_finset_sum {α : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [add_comm_monoid N] {s : finset α} {f : α → M} {g : α → M → N} (hf : ∀ (a : α), f a ≠ 0 → a ∈ s) (hg : ∀ (a : α), g a 0 = 0) : (finsupp.on_finset s f hf).sum g = s.sum (λ (a : α), g a (f a))
theorem is_open_prod_iff' {α : Type u} {β : Type v} [topological_space α] [topological_space β] {s : set α} {t : set β} : is_open (s ×ˢ t) ↔ is_open s ∧ is_open t ∨ s = ∅ ∨ t = ∅
theorem modular_group.exists_row_one_eq_and_min_re (z : upper_half_plane) {cd : fin 2 → ℤ} (hcd : is_coprime (cd 0) (cd 1)) : ∃ (g : matrix.special_linear_group (fin 2) ℤ), ↑g 1 = cd ∧ ∀ (g' : matrix.special_linear_group (fin 2) ℤ), ↑g 1 = ↑g' 1 → |(g • z).re| ≤ |(g' • z).re|
theorem set.Union_lift_const {α : Type u_1} {ι : Type u_2} {β : Type u_3} {S : ι → set α} {f : Π (i : ι), ↥(S i) → β} {hf : ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j), f i ⟨x, hxi⟩ = f j ⟨x, hxj⟩} {T : set α} {hT : T ⊆ set.Union S} (c : ↥T) (ci : Π (i : ι), ↥(S i)) (hci : ∀ (i : ι), ↑(ci i) = ↑c) (cβ : β) (h : ∀ (i : ι), f i (ci i) = cβ) : set.Union_lift S f hf T hT c = cβ
theorem measure_theory.exists_subordinate_pairwise_disjoint {ι : Type u_1} {α : Type u_2} {m0 : measurable_space α} {μ : measure_theory.measure α} [encodable ι] {s : ι → set α} (h : ∀ (i : ι), measure_theory.null_measurable_set (s i) μ) (hd : pairwise (measure_theory.ae_disjoint μ on s)) : ∃ (t : ι → set α), (∀ (i : ι), t i ⊆ s i) ∧ (∀ (i : ι), s i =ᵐ[μ] t i) ∧ (∀ (i : ι), measurable_set (t i)) ∧ pairwise (disjoint on t)
theorem add_subgroup.closure_induction {G : Type u_1} [add_group G] {k : set G} {p : G → Prop} {x : G} (h : x ∈ add_subgroup.closure k) (Hk : ∀ (x : G), x ∈ k → p x) (H1 : p 0) (Hmul : ∀ (x y : G), p x → p y → p (x + y)) (Hinv : ∀ (x : G), p x → p (-x)) : p x
theorem Top.presheaf.is_sheaf_iff_is_sheaf_unique_gluing_types {X : Top} (F : Top.presheaf (Type v) X) : F.is_sheaf ↔ F.is_sheaf_unique_gluing
theorem category_theory.limits.cokernel.π_of_zero {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) : category_theory.is_iso (category_theory.limits.cokernel.π 0)
theorem set.Inter_eq_Inter_finset {α : Type u_1} {ι : Type u_4} (s : ι → set α) : (⋂ (i : ι), s i) = ⋂ (t : finset ι) (i : ι) (H : i ∈ t), s i
theorem lipschitz_with.uniform_continuous {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {K : nnreal} {f : α → β} (hf : lipschitz_with K f) : uniform_continuous f
theorem approximates_linear_on.exists_homeomorph_extension {E : Type u_1} [normed_group E] [normed_space ℝ E] {F : Type u_2} [normed_group F] [normed_space ℝ F] [finite_dimensional ℝ F] {s : set E} {f : E → F} {f' : E ≃L[ℝ] F} {c : nnreal} (hf : approximates_linear_on f ↑f' s c) (hc : subsingleton E ∨ lipschitz_extension_constant F * c < ∥↑(f'.symm)∥₊⁻¹) : ∃ (g : E ≃ₜ F), set.eq_on f ⇑g s
theorem direct_sum.linear_map_ext (R : Type u) [semiring R] {ι : Type v} [dec_ι : decidable_eq ι] {M : ι → Type w} [Π (i : ι), add_comm_monoid (M i)] [Π (i : ι), module R (M i)] {N : Type u₁} [add_comm_monoid N] [module R N] ⦃ψ ψ' : direct_sum ι (λ (i : ι), M i) →ₗ[R] N⦄ (H : ∀ (i : ι), ψ.comp (direct_sum.lof R ι M i) = ψ'.comp (direct_sum.lof R ι M i)) : ψ = ψ'
theorem neg_cross {R : Type u_1} [comm_ring R] (v w : fin 3 → R) : -⇑(⇑cross_product v) w = ⇑(⇑cross_product w) v
theorem padic_val_rat.padic_val_rat_le_padic_val_rat_iff (p : ℕ) [p_prime : fact (nat.prime p)] {n₁ n₂ d₁ d₂ : ℤ} (hn₁ : n₁ ≠ 0) (hn₂ : n₂ ≠ 0) (hd₁ : d₁ ≠ 0) (hd₂ : d₂ ≠ 0) : padic_val_rat p (rat.mk n₁ d₁) ≤ padic_val_rat p (rat.mk n₂ d₂) ↔ ∀ (n : ℕ), ↑p ^ n ∣ n₁ * d₂ → ↑p ^ n ∣ n₂ * d₁
theorem function.periodic_orbit_eq_cycle_map {α : Type u_1} (f : α → α) (x : α) : function.periodic_orbit f x = cycle.map (λ (n : ℕ), f^[n] x) ↑(list.range (function.minimal_period f x))
theorem is_R_or_C.conj_conj {R : Type u} [comm_semiring R] [star_ring R] (x : R) : ⇑(star_ring_end R) (⇑(star_ring_end R) x) = x
theorem has_fderiv_within_at.maps_to_tangent_cone {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {s : set E} {f' : E →L[𝕜] F} {x : E} (h : has_fderiv_within_at f f' s x) : set.maps_to ⇑f' (tangent_cone_at 𝕜 s x) (tangent_cone_at 𝕜 (f '' s) (f x))
theorem set.definable.image_comp_sum_inl_fin {M : Type w} {A : set M} {L : first_order.language} [L.Structure M] {α : Type u_1} (m : ℕ) {s : set (α ⊕ fin m → M)} (h : A.definable L s) : A.definable L ((λ (g : α ⊕ fin m → M), g ∘ sum.inl) '' s)
theorem approximates_linear_on.lipschitz_on_with {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {s : set E} {c : nnreal} : approximates_linear_on f f' s c → lipschitz_on_with c (f - ⇑f') s
theorem cont_diff_on.ftaylor_series_within {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {n : with_top ℕ} (h : cont_diff_on 𝕜 n f s) (hs : unique_diff_on 𝕜 s) : has_ftaylor_series_up_to_on n f (ftaylor_series_within 𝕜 f s) s
theorem metric.emetric_ball_nnreal {α : Type u} [pseudo_metric_space α] {x : α} {ε : nnreal} : emetric.ball x ↑ε = metric.ball x ↑ε
theorem list.sum_take_map_length_lt2 {α : Type u_1} (L : list (list α)) {i j : ℕ} (hi : i < L.length) (hj : j < (L.nth_le i hi).length) : (list.take i (list.map list.length L)).sum + j < L.join.length
theorem asymptotics.is_O.of_norm_norm {α : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_normed_group E'] [semi_normed_group F'] {f' : α → E'} {g' : α → F'} {l : filter α} : ((λ (x : α), ∥f' x∥) =O[l] λ (x : α), ∥g' x∥) → f' =O[l] g'
theorem continuous_linear_map.norm_smul_right_apply {𝕜 : Type u_1} {E : Type u_4} {Fₗ : Type u_7} [normed_group E] [normed_group Fₗ] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 Fₗ] (c : E →L[𝕜] 𝕜) (f : Fₗ) : ∥c.smul_right f∥ = ∥c∥ * ∥f∥
theorem padic_val_rat.mul (p : ℕ) [p_prime : fact (nat.prime p)] {q r : ℚ} (hq : q ≠ 0) (hr : r ≠ 0) : padic_val_rat p (q * r) = padic_val_rat p q + padic_val_rat p r
theorem linear_ordered_comm_group_with_zero.singleton_nhds_of_ne_zero {Γ₀ : Type u_1} [linear_ordered_comm_group_with_zero Γ₀] (γ : Γ₀) (h : γ ≠ 0) : {γ} ∈ nhds γ
theorem module.End.exists_eigenvalue {K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] [is_alg_closed K] [finite_dimensional K V] [nontrivial V] (f : module.End K V) : ∃ (c : K), f.has_eigenvalue c
theorem Gromov_Hausdorff.to_GH_space_eq_to_GH_space_iff_isometric {X : Type u} [metric_space X] [compact_space X] [nonempty X] {Y : Type v} [metric_space Y] [compact_space Y] [nonempty Y] : Gromov_Hausdorff.to_GH_space X = Gromov_Hausdorff.to_GH_space Y ↔ nonempty (X ≃ᵢ Y)
theorem induced_topology_pure {α : Type u} : topological_space.induced has_pure.pure ultrafilter.topological_space = ⊥
theorem lucas_lehmer.mersenne_coe_X (p : ℕ) : ↑(mersenne p) = 0
theorem category_theory.comp_right_adjoint_mate {C : Type u₁} [category_theory.category C] [category_theory.monoidal_category C] {X Y Z : C} [category_theory.has_right_dual X] [category_theory.has_right_dual Y] [category_theory.has_right_dual Z] {f : X ⟶ Y} {g : Y ⟶ Z} : (f ≫ g)ᘁ = gᘁ ≫ fᘁ
theorem isometry_id {α : Type u} [pseudo_emetric_space α] : isometry id
theorem asymptotics.is_o.exists_eq_mul {α : Type u_1} {𝕜 : Type u_14} [normed_field 𝕜] {l : filter α} {u v : α → 𝕜} : u =o[l] v → (∃ (φ : α → 𝕜) (hφ : filter.tendsto φ l (nhds 0)), u =ᶠ[l] φ * v)
theorem finset.prod_bij' {β : Type u} {α : Type v} {γ : Type w} [comm_monoid β] {s : finset α} {t : finset γ} {f : α → β} {g : γ → β} (i : Π (a : α), a ∈ s → γ) (hi : ∀ (a : α) (ha : a ∈ s), i a ha ∈ t) (h : ∀ (a : α) (ha : a ∈ s), f a = g (i a ha)) (j : Π (a : γ), a ∈ t → α) (hj : ∀ (a : γ) (ha : a ∈ t), j a ha ∈ s) (left_inv : ∀ (a : α) (ha : a ∈ s), j (i a ha) _ = a) (right_inv : ∀ (a : γ) (ha : a ∈ t), i (j a ha) _ = a) : s.prod (λ (x : α), f x) = t.prod (λ (x : γ), g x)
theorem finite_dimensional.of_subalgebra_to_submodule {K : Type u_1} {V : Type u_2} [field K] [ring V] [algebra K V] {s : subalgebra K V} (h : finite_dimensional K ↥(s.to_submodule)) : finite_dimensional K ↥s
theorem list.map_length_split_wrt_composition {α : Type u_1} (l : list α) (c : composition l.length) : list.map list.length (l.split_wrt_composition c) = c.blocks
theorem pnat.xgcd_type.step_wf (u : pnat.xgcd_type) (hr : u.r ≠ 0) : sizeof u.step < sizeof u
theorem eq_of_forall_edist_le {γ : Type w} [emetric_space γ] {x y : γ} (h : ∀ (ε : ennreal), ε > 0 → has_edist.edist x y ≤ ε) : x = y
theorem is_fraction_ring.is_algebraic_iff (A : Type u_4) (K : Type u_5) (C : Type u_6) [comm_ring A] [is_domain A] [field K] [algebra A K] [is_fraction_ring A K] [comm_ring C] [algebra A C] [algebra K C] [is_scalar_tower A K C] {x : C} : is_algebraic A x ↔ is_algebraic K x
theorem line_map_lt_map_iff_slope_lt_slope_right {k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k → E} {a b r : k} (h : 0 < (1 - r) * (b - a)) : ⇑(affine_map.line_map (f a) (f b)) r < f (⇑(affine_map.line_map a b) r) ↔ slope f (⇑(affine_map.line_map a b) r) b < slope f a b
theorem finset.centroid_map (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} {ι₂ : Type u_5} (s₂ : finset ι₂) (e : ι₂ ↪ ι) (p : ι → P) : finset.centroid k (finset.map e s₂) p = finset.centroid k s₂ (p ∘ ⇑e)
theorem is_of_fin_order_iff_coe {G : Type u} [monoid G] (H : submonoid G) (x : ↥H) : is_of_fin_order x ↔ is_of_fin_order ↑x
theorem continuous_on.exists_forall_le' {α : Type u_1} {β : Type u_2} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [topological_space β] {s : set β} {f : β → α} (hf : continuous_on f s) (hsc : is_closed s) {x₀ : β} (h₀ : x₀ ∈ s) (hc : ∀ᶠ (x : β) in filter.cocompact β ⊓ filter.principal s, f x₀ ≤ f x) : ∃ (x : β) (H : x ∈ s), ∀ (y : β), y ∈ s → f x ≤ f y
theorem setoid.eqv_classes_of_disjoint_union {α : Type u_1} {c : set (set α)} (hu : ⋃₀c = set.univ) (H : c.pairwise_disjoint id) (a : α) : ∃! (b : set α) (H : b ∈ c), a ∈ b
theorem unique_diff_within_at_convex {G : Type u_4} [normed_group G] [normed_space ℝ G] {s : set G} (conv : convex ℝ s) (hs : (interior s).nonempty) {x : G} (hx : x ∈ closure s) : unique_diff_within_at ℝ s x
theorem nat.prime_counting'_add_le {a k : ℕ} (h0 : 0 < a) (h1 : a < k) (n : ℕ) : (k + n).prime_counting' ≤ k.prime_counting' + a.totient * (n / a + 1)
theorem smooth_bump_function.exists_r_pos_lt_subset_ball {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {c : M} (f : smooth_bump_function I c) {s : set M} (hsc : is_closed s) (hs : s ⊆ function.support ⇑f) : ∃ (r : ℝ) (hr : r ∈ set.Ioo 0 f.to_cont_diff_bump.to_cont_diff_bump_of_inner.R), s ⊆ (charted_space.chart_at H c).to_local_equiv.source ∩ ⇑(ext_chart_at I c) ⁻¹' euclidean.ball (⇑(ext_chart_at I c) c) r
theorem parser.nat_of_done_as_digit {cb : char_buffer} {n n' val : ℕ} (h : parser.nat cb n = parse_result.done n' val) (hn : n' ≤ buffer.size cb) (k : ℕ) (hk : k < n') : n ≤ k → '0' ≤ buffer.read cb ⟨k, _⟩ ∧ buffer.read cb ⟨k, _⟩ ≤ '9'
theorem prime_multiset.prod_zero  : 0.prod = 1
theorem setoid.eq_iff_classes_eq {α : Type u_1} {r₁ r₂ : setoid α} : r₁ = r₂ ↔ ∀ (x : α), {y : α | r₁.rel x y} = {y : α | r₂.rel x y}
theorem measure_theory.is_open_pos_measure_of_mul_left_invariant_of_compact {G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {μ : measure_theory.measure G} [group G] [topological_group G] [μ.is_mul_left_invariant] (K : set G) (hK : is_compact K) (h : ⇑μ K ≠ 0) : μ.is_open_pos_measure
theorem exists_norm_le_le_norm_sub_of_finset {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {E : Type v} [normed_group E] [normed_space 𝕜 E] [complete_space 𝕜] {c : 𝕜} (hc : 1 < ∥c∥) {R : ℝ} (hR : ∥c∥ < R) (h : ¬finite_dimensional 𝕜 E) (s : finset E) : ∃ (x : E), ∥x∥ ≤ R ∧ ∀ (y : E), y ∈ s → 1 ≤ ∥y - x∥
theorem homotopy.null_homotopic_map'_comp {ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D E : homological_complex V c} (hom : Π (i j : ι), c.rel j i → (C.X i ⟶ D.X j)) (g : D ⟶ E) : homotopy.null_homotopic_map' hom ≫ g = homotopy.null_homotopic_map' (λ (i j : ι) (hij : c.rel j i), hom i j hij ≫ g.f j)
theorem module.free.rank_lt_aleph_0 (R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] : module.rank R M < cardinal.aleph_0
theorem filter.tendsto_pow_at_top {α : Type u_3} [ordered_semiring α] {n : ℕ} (hn : 1 ≤ n) : filter.tendsto (λ (x : α), x ^ n) filter.at_top filter.at_top
theorem set.Union_eq_Union_finset' {α : Type u_1} {ι' : Sort u_5} (s : ι' → set α) : (⋃ (i : ι'), s i) = ⋃ (t : finset (plift ι')) (i : plift ι') (H : i ∈ t), s i.down
theorem nat.arithmetic_function.sum_eq_iff_sum_smul_moebius_eq {R : Type u_1} [add_comm_group R] {f g : ℕ → R} : (∀ (n : ℕ), 0 < n → n.divisors.sum (λ (i : ℕ), f i) = g n) ↔ ∀ (n : ℕ), 0 < n → n.divisors_antidiagonal.sum (λ (x : ℕ × ℕ), ⇑nat.arithmetic_function.moebius x.fst • g x.snd) = f n
theorem category_theory.limits.biprod.symmetry {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_binary_biproducts C] (P Q : C) : (category_theory.limits.biprod.braiding P Q).hom ≫ (category_theory.limits.biprod.braiding Q P).hom = 𝟙 (P ⊞ Q)
theorem complex.abs_deriv_le_one_of_maps_to_ball {f : ℂ → ℂ} {c : ℂ} {R : ℝ} (hd : differentiable_on ℂ f (metric.ball c R)) (h_maps : set.maps_to f (metric.ball c R) (metric.ball c R)) (hc : f c = c) (h₀ : 0 < R) : complex.abs (deriv f c) ≤ 1
theorem polynomial.X_pow_mem_lifts {R : Type u} [semiring R] {S : Type v} [semiring S] (f : R →+* S) (n : ℕ) : polynomial.X ^ n ∈ polynomial.lifts f
theorem category_theory.monad.algebra_iso_of_iso {C : Type u₁} [category_theory.category C] (T : category_theory.monad C) {A B : T.algebra} (f : A ⟶ B) [category_theory.is_iso f.f] : category_theory.is_iso f
theorem monovary.sum_mul_comp_perm_eq_sum_mul_iff {ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {σ : equiv.perm ι} {f g : ι → α} [fintype ι] (hfg : monovary f g) : finset.univ.sum (λ (i : ι), f i * g (⇑σ i)) = finset.univ.sum (λ (i : ι), f i * g i) ↔ monovary f (g ∘ ⇑σ)
theorem inner_product_space.is_self_adjoint.has_eigenvalue_infi_of_finite_dimensional {𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] [finite_dimensional 𝕜 E] [nontrivial E] {T : E →ₗ[𝕜] E} (hT : inner_product_space.is_self_adjoint T) : module.End.has_eigenvalue T (↑⨅ (x : {x // x ≠ 0}), ⇑is_R_or_C.re (has_inner.inner (⇑T ↑x) ↑x) / ∥↑x∥ ^ 2)
theorem polynomial.leading_coeff_div_by_monic_of_monic {R : Type u} [comm_ring R] {p q : polynomial R} (hmonic : q.monic) (hdegree : q.degree ≤ p.degree) : (p /ₘ q).leading_coeff = p.leading_coeff
theorem subsemiring.subset_closure {R : Type u} [non_assoc_semiring R] {s : set R} : s ⊆ ↑(subsemiring.closure s)
theorem measure_theory.condexp_indicator {α : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space ℝ F'] [complete_space F'] {m m0 : measurable_space α} {μ : measure_theory.measure α} {f : α → F'} {s : set α} (hf_int : measure_theory.integrable f μ) (hs : measurable_set s) : measure_theory.condexp m μ (s.indicator f) =ᵐ[μ] s.indicator (measure_theory.condexp m μ f)
theorem nat.factorization_eq_of_coprime_left {p a b : ℕ} (hab : a.coprime b) (hpa : p ∈ a.factors) : ⇑((a * b).factorization) p = ⇑(a.factorization) p
theorem pnat.factor_multiset_le_iff {m n : ℕ+} : m.factor_multiset ≤ n.factor_multiset ↔ m ∣ n
theorem mul_eq_zero {M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b = 0 ↔ a = 0 ∨ b = 0
theorem seminorm.le_insert {𝕜 : Type u_3} {E : Type u_4} [semi_normed_ring 𝕜] [add_comm_group E] [module 𝕜 E] (p : seminorm 𝕜 E) (x y : E) : ⇑p y ≤ ⇑p x + ⇑p (x - y)
theorem orthonormal.oangle_smul_smul_self_of_nonneg {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x : V) {r₁ r₂ : ℝ} (hr₁ : 0 ≤ r₁) (hr₂ : 0 ≤ r₂) : hb.oangle (r₁ • x) (r₂ • x) = 0
theorem continuous_linear_equiv.comp_cont_diff_within_at_iff {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] {s : set E} {f : E → F} {x : E} {n : with_top ℕ} (e : F ≃L[𝕜] G) : cont_diff_within_at 𝕜 n (⇑e ∘ f) s x ↔ cont_diff_within_at 𝕜 n f s x
theorem real.sinh_arsinh (x : ℝ) : real.sinh (real.arsinh x) = x
theorem list.length_pos_of_sum_pos {M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : 0 < L.sum) : 0 < L.length
theorem orthogonal_family.independent {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {V : ι → submodule 𝕜 E} (hV : orthogonal_family 𝕜 (λ (i : ι), (V i).subtypeₗᵢ)) : complete_lattice.independent V
theorem sum_inner {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_3} (s : finset ι) (f : ι → E) (x : E) : has_inner.inner (s.sum (λ (i : ι), f i)) x = s.sum (λ (i : ι), has_inner.inner (f i) x)
theorem nonarchimedean_group.nonarchimedean_of_emb {G : Type u_1} [group G] [topological_space G] [nonarchimedean_group G] {H : Type u_2} [group H] [topological_space H] [topological_group H] (f : G →* H) (emb : open_embedding ⇑f) : nonarchimedean_group H
theorem padic_val_rat.of_int {p : ℕ} {z : ℤ} : padic_val_rat p ↑z = ↑(padic_val_int p z)
theorem submodule.fg_iff_compact {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (s : submodule R M) : s.fg ↔ complete_lattice.is_compact_element s
theorem right.mul_lt_one' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1
theorem dfinsupp.lift_add_hom_single_add_hom {ι : Type u} {β : ι → Type v} [dec : decidable_eq ι] [Π (i : ι), add_comm_monoid (β i)] : ⇑dfinsupp.lift_add_hom (dfinsupp.single_add_hom β) = add_monoid_hom.id (Π₀ (i : ι), β i)
theorem measure_theory.integrable_condexp_ind_smul {α : Type u_1} {G : Type u_8} [normed_group G] {m m0 : measurable_space α} {μ : measure_theory.measure α} {s : set α} [normed_space ℝ G] (hm : m ≤ m0) [measure_theory.sigma_finite (μ.trim hm)] (hs : measurable_set s) (hμs : ⇑μ s ≠ ⊤) (x : G) : measure_theory.integrable ⇑(measure_theory.condexp_ind_smul hm hs hμs x) μ
theorem lipschitz_on_with.holder_on_with {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C : nnreal} {f : X → Y} {s : set X} : lipschitz_on_with C f s → holder_on_with C 1 f s
theorem finset.sum_comp {β : Type u} {α : Type v} {γ : Type w} {s : finset α} [add_comm_monoid β] [decidable_eq γ] (f : γ → β) (g : α → γ) : s.sum (λ (a : α), f (g a)) = (finset.image g s).sum (λ (b : γ), (finset.filter (λ (a : α), g a = b) s).card • f b)
theorem zero_lt.preorder.right.mul_le_one_of_le_of_le {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (b0 : 0 < b) : a * b ≤ 1
theorem monoid_with_zero_hom.map_inv {G₀ : Type u_2} {G₀' : Type u_4} [group_with_zero G₀] [group_with_zero G₀'] (f : G₀ →*₀ G₀') (a : G₀) : ⇑f a⁻¹ = (⇑f a)⁻¹
theorem category_theory.limits.coprod.symmetry {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] (P Q : C) : (category_theory.limits.coprod.braiding P Q).hom ≫ (category_theory.limits.coprod.braiding Q P).hom = 𝟙 (P ⨿ Q)
theorem orientation.det_rotation {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (θ : real.angle) : ⇑linear_map.det ↑((o.rotation θ).to_linear_equiv) = 1
theorem category_theory.limits.cones.cone_iso_of_hom_iso {J : Type u₁} [category_theory.category J] {C : Type u₃} [category_theory.category C] {K : J ⥤ C} {c d : category_theory.limits.cone K} (f : c ⟶ d) [i : category_theory.is_iso f.hom] : category_theory.is_iso f
theorem galois_connection.exists_eq_l {α : Type u} {β : Type v} [preorder α] [partial_order β] {l : α → β} {u : β → α} (gc : galois_connection l u) (b : β) : (∃ (a : α), b = l a) ↔ b = l (u b)
theorem set.Inter_Union_of_monotone {ι : Type u_1} {ι' : Type u_2} {α : Type u_3} [fintype ι] [preorder ι'] [is_directed ι' (function.swap has_le.le)] [nonempty ι'] {s : ι → ι' → set α} (hs : ∀ (i : ι), monotone (s i)) : (⋂ (j : ι'), ⋃ (i : ι), s i j) = ⋃ (i : ι), ⋂ (j : ι'), s i j
theorem convex.average_mem {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {f : α → E} [measure_theory.is_finite_measure μ] (hs : convex ℝ s) (hsc : is_closed s) (hμ : μ ≠ 0) (hfs : ∀ᵐ (x : α) ∂μ, f x ∈ s) (hfi : measure_theory.integrable f μ) : ⨍ (x : α), f x ∂μ ∈ s
theorem add_monoid.is_torsion_free.prod {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_group (Gs i)] (tfGs : ∀ (i : η), add_monoid.is_torsion_free (Gs i)) : add_monoid.is_torsion_free (Π (i : η), Gs i)
theorem module.direct_limit.exists_of {R : Type u} [ring R] {ι : Type v} [dec_ι : decidable_eq ι] [preorder ι] {G : ι → Type w} [Π (i : ι), add_comm_group (G i)] [Π (i : ι), module R (G i)] {f : Π (i j : ι), i ≤ j → (G i →ₗ[R] G j)} [nonempty ι] [is_directed ι has_le.le] (z : module.direct_limit G f) : ∃ (i : ι) (x : G i), ⇑(module.direct_limit.of R ι G f i) x = z
theorem simple_graph.is_adj_matrix_adj_matrix {V : Type u_1} (α : Type u_2) (G : simple_graph V) [decidable_rel G.adj] [has_zero α] [has_one α] : (simple_graph.adj_matrix α G).is_adj_matrix
theorem category_theory.is_iso.of_epi_section {C : Type u₁} [category_theory.category C] {X Y : C} {f : X ⟶ Y} [category_theory.split_epi f] [category_theory.epi (category_theory.section_ f)] : category_theory.is_iso f
theorem char.quadratic_char_eq_zero_iff {F : Type u_1} [field F] [fintype F] [decidable_eq F] (a : F) : char.quadratic_char F a = 0 ↔ a = 0
theorem affine_subspace.vsub_left_mem_direction_iff_mem {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p : P} (hp : p ∈ s) (p2 : P) : p -ᵥ p2 ∈ s.direction ↔ p2 ∈ s
theorem dvd_of_mul_right_eq {α : Type u_1} [semigroup α] {a b : α} (c : α) (h : a * c = b) : a ∣ b
theorem compact_of_is_closed_subset {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) : is_compact t
theorem continuous_inf_dom_right₂ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {f : α → β → γ} {ta1 ta2 : topological_space α} {tb1 tb2 : topological_space β} {tc1 : topological_space γ} (h : continuous (λ (p : α × β), f p.fst p.snd)) : continuous (λ (p : α × β), f p.fst p.snd)
theorem monoid_hom.map_one {M : Type u_3} {N : Type u_4} [mul_one_class M] [mul_one_class N] (f : M →* N) : ⇑f 1 = 1
theorem measure_theory.L2.inner_indicator_const_Lp_eq_set_integral_inner {α : Type u_1} {E : Type u_2} (𝕜 : Type u_4) [is_R_or_C 𝕜] [measurable_space α] {μ : measure_theory.measure α} [inner_product_space 𝕜 E] {s : set α} (f : ↥(measure_theory.Lp E 2 μ)) (hs : measurable_set s) (c : E) (hμs : ⇑μ s ≠ ⊤) : has_inner.inner (measure_theory.indicator_const_Lp 2 hs hμs c) f = ∫ (x : α) in s, has_inner.inner c (⇑f x) ∂μ
theorem vsub_vadd {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p1 p2 : P) : p1 -ᵥ p2 +ᵥ p2 = p1
theorem configuration.has_lines.card_le (P L : Type u) [has_mem P L] [configuration.has_lines P L] [fintype P] [fintype L] : fintype.card P ≤ fintype.card L
theorem euclidean_geometry.dist_eq_abs_sub_dist_of_angle_eq_zero {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : euclidean_geometry.angle p1 p2 p3 = 0) : has_dist.dist p1 p3 = |has_dist.dist p1 p2 - has_dist.dist p3 p2|
theorem finset.sum_smul_vsub_const_eq_weighted_vsub_of_point_sub {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (w : ι → k) (p₁ : ι → P) (p₂ b : P) : s.sum (λ (i : ι), w i • (p₁ i -ᵥ p₂)) = ⇑(s.weighted_vsub_of_point p₁ b) w - s.sum (λ (i : ι), w i) • (p₂ -ᵥ b)
theorem set.countable_iff_exists_surjective_to_subtype {α : Type u} {s : set α} (hs : s.nonempty) : s.countable ↔ ∃ (f : ℕ → ↥s), function.surjective f
theorem has_strict_deriv_at_exp_of_mem_ball {𝕂 : Type u_1} [nondiscrete_normed_field 𝕂] [complete_space 𝕂] [char_zero 𝕂] {x : 𝕂} (hx : x ∈ emetric.ball 0 (exp_series 𝕂 𝕂).radius) : has_strict_deriv_at (exp 𝕂) (exp 𝕂 x) x
theorem dense_bUnion_interior_of_closed {α : Type u_1} {β : Type u_2} [topological_space α] [baire_space α] {S : set β} {f : β → set α} (hc : ∀ (s : β), s ∈ S → is_closed (f s)) (hS : S.countable) (hU : (⋃ (s : β) (H : s ∈ S), f s) = set.univ) : dense (⋃ (s : β) (H : s ∈ S), interior (f s))
theorem fin.succ_above_pred_above {n : ℕ} {p : fin n} {i : fin (n + 1)} (h : i ≠ ⇑fin.cast_succ p) : ⇑((⇑fin.cast_succ p).succ_above) (p.pred_above i) = i
theorem euclidean_geometry.reflection_eq_self_iff {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} [nonempty ↥s] [complete_space ↥(s.direction)] (p : P) : ⇑(euclidean_geometry.reflection s) p = p ↔ p ∈ s
theorem fintype.card_of_subsingleton {α : Type u_1} (a : α) [subsingleton α] : fintype.card α = 1
theorem category_theory.over.construct_products.over_products_of_wide_pullbacks {C : Type u} [category_theory.category C] [category_theory.limits.has_wide_pullbacks C] {B : C} : category_theory.limits.has_products (category_theory.over B)
theorem real_inner_div_norm_mul_norm_eq_neg_one_iff {F : Type u_3} [inner_product_space ℝ F] (x y : F) : has_inner.inner x y / (∥x∥ * ∥y∥) = -1 ↔ x ≠ 0 ∧ ∃ (r : ℝ), r < 0 ∧ y = r • x
theorem is_of_fin_add_order.add {G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)
theorem convolution_eq_swap {𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G → E} {g : G → E'} {x : G} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 F] (L : E →L[𝕜] E' →L[𝕜] F) [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ F] [complete_space F] [add_comm_group G] [topological_space G] [topological_add_group G] [borel_space G] [μ.is_add_left_invariant] [μ.is_neg_invariant] : convolution f g L μ x = ∫ (t : G), ⇑(⇑L (f (x - t))) (g t) ∂μ
theorem minpoly.not_is_unit (A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : ¬is_unit (minpoly A x)
theorem filter.infi_ne_bot_of_directed' {α : Type u} {ι : Sort x} {f : ι → filter α} [nonempty ι] (hd : directed ge f) (hb : ∀ (i : ι), (f i).ne_bot) : (infi f).ne_bot
theorem int_smul_eq_zsmul {M : Type u_5} [add_comm_group M] (h : module ℤ M) (n : ℤ) (x : M) : n • x = n • x
theorem finset.centroid_eq_center_mass {R : Type u_1} {E : Type u_2} {ι : Type u_4} [linear_ordered_field R] [add_comm_group E] [module R E] (s : finset ι) (hs : s.nonempty) (p : ι → E) : finset.centroid R s p = s.center_mass (finset.centroid_weights R s) p
theorem has_lt.lt.not_is_min {α : Type u_1} [preorder α] {a b : α} (h : b < a) : ¬is_min a
theorem local_homeomorph.continuous_at_iff_continuous_at_comp_left {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] (e : local_homeomorph α β) {f : γ → α} {x : γ} (h : f ⁻¹' e.to_local_equiv.source ∈ nhds x) : continuous_at f x ↔ continuous_at (⇑e ∘ f) x
theorem sub_nonneg_of_le {α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : b ≤ a → 0 ≤ a - b
theorem path.truncate_continuous_family {X : Type u_1} [topological_space X] {a b : X} (γ : path a b) : continuous (λ (x : ℝ × ℝ × ↥unit_interval), ⇑(γ.truncate x.fst x.snd.fst) x.snd.snd)
theorem mfderiv_eq_fderiv {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {f : E → E'} {x : E} : mfderiv (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f x = fderiv 𝕜 f x
theorem is_complete.nonempty_Inter_of_nonempty_bInter {α : Type u} [pseudo_metric_space α] {s : ℕ → set α} (h0 : is_complete (s 0)) (hs : ∀ (n : ℕ), is_closed (s n)) (h's : ∀ (n : ℕ), metric.bounded (s n)) (h : ∀ (N : ℕ), (⋂ (n : ℕ) (H : n ≤ N), s n).nonempty) (h' : filter.tendsto (λ (n : ℕ), metric.diam (s n)) filter.at_top (nhds 0)) : (⋂ (n : ℕ), s n).nonempty
theorem compact_open_separated_mul_right {G : Type w} [topological_space G] [group G] [topological_group G] {K U : set G} (hK : is_compact K) (hU : is_open U) (hKU : K ⊆ U) : ∃ (V : set G) (H : V ∈ nhds 1), K * V ⊆ U
theorem ideal.subset_union_prime {ι : Type u_1} {R : Type u} [comm_ring R] {s : finset ι} {f : ι → ideal R} (a b : ι) (hp : ∀ (i : ι), i ∈ s → i ≠ a → i ≠ b → (f i).is_prime) {I : ideal R} : (↑I ⊆ ⋃ (i : ι) (H : i ∈ ↑s), ↑(f i)) ↔ ∃ (i : ι) (H : i ∈ s), I ≤ f i
theorem intermediate_field.algebra_map_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) (x : K) : ⇑(algebra_map K L) x ∈ S
theorem list.next_or_eq_next_or_of_mem_of_ne {α : Type u_1} [decidable_eq α] (xs : list α) (x d d' : α) (x_mem : x ∈ xs) (x_ne : x ≠ xs.last _) : xs.next_or x d = xs.next_or x d'
theorem is_preconnected.intermediate_value {X : Type u} {α : Type v} [topological_space X] [linear_order α] [topological_space α] [order_closed_topology α] {s : set X} (hs : is_preconnected s) {a b : X} (ha : a ∈ s) (hb : b ∈ s) {f : X → α} (hf : continuous_on f s) : set.Icc (f a) (f b) ⊆ f '' s
theorem basis.mk_coord_apply_eq {ι : Type u_1} {R : Type u_3} {M : Type u_5} {v : ι → M} [ring R] [add_comm_group M] [module R M] {hli : linear_independent R v} {hsp : submodule.span R (set.range v) = ⊤} (i : ι) : ⇑((basis.mk hli hsp).coord i) (v i) = 1
theorem multiset.Icc_eq_zero {α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a ≤ b → multiset.Icc a b = 0
theorem add_monoid_hom.congr_fun {M : Type u_3} {N : Type u_4} [add_zero_class M] [add_zero_class N] {f g : M →+ N} (h : f = g) (x : M) : ⇑f x = ⇑g x
theorem euclidean_geometry.mul_dist_eq_mul_dist_of_cospherical_of_angle_eq_zero {V : Type u_1} [inner_product_space ℝ V] {P : Type u_2} [metric_space P] [normed_add_torsor V P] {a b c d p : P} (h : euclidean_geometry.cospherical {a, b, c, d}) (hab : a ≠ b) (hcd : c ≠ d) (hapb : euclidean_geometry.angle a p b = 0) (hcpd : euclidean_geometry.angle c p d = 0) : has_dist.dist a p * has_dist.dist b p = has_dist.dist c p * has_dist.dist d p
theorem one_le_pow_mul_abs_eval_div {K : Type u_1} [linear_ordered_field K] {f : polynomial ℤ} {a b : ℤ} (b0 : 0 < b) (fab : polynomial.eval (↑a / ↑b) (polynomial.map (algebra_map ℤ K) f) ≠ 0) : 1 ≤ ↑b ^ f.nat_degree * |polynomial.eval (↑a / ↑b) (polynomial.map (algebra_map ℤ K) f)|
theorem antitone.pairwise_disjoint_on_Ioo_succ {α : Type u_1} {β : Type u_2} [linear_order α] [succ_order α] [preorder β] {f : α → β} (hf : antitone f) : pairwise (disjoint on λ (n : α), set.Ioo (f (order.succ n)) (f n))
theorem pnat.factor_multiset_of_prime (p : nat.primes) : ↑p.factor_multiset = prime_multiset.of_prime p
theorem units.coe_neg {α : Type u} [ring α] (u : αˣ) : ↑-u = -↑u
theorem con.con_gen_idem {M : Type u_1} [has_mul M] (r : M → M → Prop) : con_gen ⇑(con_gen r) = con_gen r
theorem measure_theory.measure_limsup_eq_zero {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {s : ℕ → set α} (hs : ∑' (i : ℕ), ⇑μ (s i) ≠ ⊤) : ⇑μ (filter.at_top.limsup s) = 0
theorem algebra.discr_power_basis_eq_prod' (K : Type u) {L : Type v} (E : Type z) [field K] [field L] [field E] [algebra K L] [algebra K E] [module.finite K L] [is_alg_closed E] (pb : power_basis K L) [is_separable K L] (e : fin pb.dim ≃ (L →ₐ[K] E)) : ⇑(algebra_map K E) (algebra.discr K ⇑(pb.basis)) = finset.univ.prod (λ (i : fin pb.dim), (finset.filter (λ (j : fin pb.dim), i < j) finset.univ).prod (λ (j : fin pb.dim), -((⇑(⇑e j) pb.gen - ⇑(⇑e i) pb.gen) * (⇑(⇑e i) pb.gen - ⇑(⇑e j) pb.gen))))
theorem metric.emetric_closed_ball {α : Type u} [pseudo_metric_space α] {x : α} {ε : ℝ} (h : 0 ≤ ε) : emetric.closed_ball x (ennreal.of_real ε) = metric.closed_ball x ε
theorem power_basis.finite_dimensional {S : Type u_2} [comm_ring S] {K : Type u_6} [field K] [algebra K S] (pb : power_basis K S) : finite_dimensional K S
theorem is_primitive_root.nth_roots_one_eq_bUnion_primitive_roots' {R : Type u_5} [comm_ring R] [is_domain R] {ζ : R} {n : ℕ+} (h : is_primitive_root ζ ↑n) : polynomial.nth_roots_finset ↑n R = ↑n.divisors.bUnion (λ (i : ℕ), primitive_roots i R)
theorem measure_theory.ae_disjoint.exists_disjoint_diff {α : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} {s t : set α} (h : measure_theory.ae_disjoint μ s t) : ∃ (u : set α), measurable_set u ∧ ⇑μ u = 0 ∧ disjoint (s  u) t
theorem add_lt_of_lt_sub_left {α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : b < c - a → a + b < c
theorem add_monoid.exists_list_of_mem_closure {M : Type u_1} [add_monoid M] {s : set M} {a : M} (h : a ∈ add_monoid.closure s) : ∃ (l : list M), (∀ (x : M), x ∈ l → x ∈ s) ∧ l.sum = a
theorem dense_iff_exists_between {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] [nontrivial α] {s : set α} : dense s ↔ ∀ (a b : α), a < b → (∃ (c : α) (H : c ∈ s), a < c ∧ c < b)
theorem caratheodory.mem_convex_hull_erase {𝕜 : Type u_1} {E : Type u} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [decidable_eq E] {t : finset E} (h : ¬affine_independent 𝕜 coe) {x : E} (m : x ∈ ⇑(convex_hull 𝕜) ↑t) : ∃ (y : ↥↑t), x ∈ ⇑(convex_hull 𝕜) ↑(t.erase ↑y)
theorem inv_lt {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ < b ↔ b⁻¹ < a
theorem cont_diff.dimH_range_le {E : Type u_4} {F : Type u_5} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] [normed_group F] [normed_space ℝ F] {f : E → F} (h : cont_diff ℝ 1 f) : dimH (set.range f) ≤ ↑(finite_dimensional.finrank ℝ E)
theorem nat.mem_factors_mul_left {p a b : ℕ} (hpa : p ∈ a.factors) (hb : b ≠ 0) : p ∈ (a * b).factors
theorem subgroup.card_subgroup_dvd_card {α : Type u_1} [group α] [fintype α] (s : subgroup α) [fintype ↥s] : fintype.card ↥s ∣ fintype.card α
theorem submodule.mem_supr_iff_exists_dfinsupp' {ι : Type u_1} {R : Type u_2} {N : Type u_5} [dec_ι : decidable_eq ι] [semiring R] [add_comm_monoid N] [module R N] (p : ι → submodule R N) [Π (i : ι) (x : ↥(p i)), decidable (x ≠ 0)] (x : N) : x ∈ supr p ↔ ∃ (f : Π₀ (i : ι), ↥(p i)), f.sum (λ (i : ι) (xi : ↥(p i)), ↑xi) = x
theorem category_theory.functor.pi_ext {I : Type w₀} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {A : Type u₁} [category_theory.category A] (f f' : A ⥤ Π (i : I), C i) (h : ∀ (i : I), f ⋙ category_theory.pi.eval C i = f' ⋙ category_theory.pi.eval C i) : f = f'
theorem Top.presheaf.covering_of_presieve.first_obj_iso_comp_left_res_eq {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) (U : topological_space.opens ↥X) (R : category_theory.presieve U) : category_theory.presheaf.first_map R F ≫ (Top.presheaf.covering_of_presieve.second_obj_iso_pi_inters F U R).hom = (Top.presheaf.covering_of_presieve.first_obj_iso_pi_opens F U R).hom ≫ Top.presheaf.sheaf_condition_equalizer_products.left_res F (Top.presheaf.covering_of_presieve U R)
theorem exists_Union_ball_eq_radius_lt {α : Type u} {ι : Type v} [metric_space α] [proper_space α] {c : ι → α} {r : ι → ℝ} (uf : ∀ (x : α), {i : ι | x ∈ metric.ball (c i) (r i)}.finite) (uU : (⋃ (i : ι), metric.ball (c i) (r i)) = set.univ) : ∃ (r' : ι → ℝ), (⋃ (i : ι), metric.ball (c i) (r' i)) = set.univ ∧ ∀ (i : ι), r' i < r i
theorem strict_order.cof_nonempty {α : Type u_1} (r : α → α → Prop) [is_irrefl α r] : {c : cardinal | ∃ (S : set α), set.unbounded r S ∧ cardinal.mk ↥S = c}.nonempty
theorem zsmul_eq_smul_cast (R : Type u_2) {M : Type u_5} [ring R] [add_comm_group M] [module R M] (n : ℤ) (b : M) : n • b = ↑n • b
theorem filter.has_basis.mem_lift_iff {α : Type u_1} {γ : Type u_3} {ι : Sort u_2} {p : ι → Prop} {s : ι → set α} {f : filter α} (hf : f.has_basis p s) {β : ι → Type u_4} {pg : Π (i : ι), β i → Prop} {sg : Π (i : ι), β i → set γ} {g : set α → filter γ} (hg : ∀ (i : ι), (g (s i)).has_basis (pg i) (sg i)) (gm : monotone g) {s_1 : set γ} : s_1 ∈ f.lift g ↔ ∃ (i : ι) (hi : p i) (x : β i) (hx : pg i x), sg i x ⊆ s_1
theorem module.free.rank_finsupp' (R : Type u) [ring R] [strong_rank_condition R] {ι : Type u} : module.rank R (ι →₀ R) = cardinal.mk ι
theorem complete_lattice.Iic_coatomic_of_compact_element {α : Type u_1} [complete_lattice α] {k : α} (h : complete_lattice.is_compact_element k) : is_coatomic ↥(set.Iic k)
theorem set.sized.subset_powerset_len_univ {α : Type u_1} [fintype α] {𝒜 : finset (finset α)} {r : ℕ} : set.sized r ↑𝒜 → 𝒜 ⊆ finset.powerset_len r finset.univ
theorem subsemigroup.closure_induction₂ {M : Type u_1} [has_mul M] {s : set M} {p : M → M → Prop} {x y : M} (hx : x ∈ subsemigroup.closure s) (hy : y ∈ subsemigroup.closure s) (Hs : ∀ (x : M), x ∈ s → ∀ (y : M), y ∈ s → p x y) (Hmul_left : ∀ (x y z : M), p x z → p y z → p (x * y) z) (Hmul_right : ∀ (x y z : M), p z x → p z y → p z (x * y)) : p x y
theorem affine_subspace.span_empty (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : affine_span k ∅ = ⊥
theorem set.Inter_Union_of_antitone {ι : Type u_1} {ι' : Type u_2} {α : Type u_3} [fintype ι] [preorder ι'] [is_directed ι' has_le.le] [nonempty ι'] {s : ι → ι' → set α} (hs : ∀ (i : ι), antitone (s i)) : (⋂ (j : ι'), ⋃ (i : ι), s i j) = ⋃ (i : ι), ⋂ (j : ι'), s i j
theorem euclidean_geometry.cospherical.affine_independent {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : set P} (hs : euclidean_geometry.cospherical s) {p : fin 3 → P} (hps : set.range p ⊆ s) (hpi : function.injective p) : affine_independent ℝ p
theorem not_is_left_regular_zero_iff {R : Type u_1} [mul_zero_class R] : ¬is_left_regular 0 ↔ nontrivial R
theorem is_compact.bounded {α : Type u} [pseudo_metric_space α] {s : set α} (h : is_compact s) : metric.bounded s
theorem holor.sum_unit_vec_mul_slice {α : Type} {d : ℕ} {ds : list ℕ} [ring α] (x : holor α (d :: ds)) : (finset.range d).attach.sum (λ (i : {x // x ∈ finset.range d}), (holor.unit_vec d ↑i).mul (x.slice ↑i _)) = x
theorem category_theory.cosimplicial_object.δ_comp_σ_succ {C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) {n : ℕ} {i : fin (n + 1)} : X.δ i.succ ≫ X.σ i = 𝟙 (X.obj (simplex_category.mk n))
theorem category_theory.id_cover_preserving {C : Type u₁} [category_theory.category C] (J : category_theory.grothendieck_topology C) : category_theory.cover_preserving J J (𝟭 C)
theorem set.finite.bdd_above {α : Type u} [semilattice_sup α] [nonempty α] {s : set α} (hs : s.finite) : bdd_above s
theorem polynomial.degree_multiset_prod {R : Type u} [comm_semiring R] [no_zero_divisors R] (t : multiset (polynomial R)) [nontrivial R] : t.prod.degree = (multiset.map (λ (f : polynomial R), f.degree) t).sum
theorem category_theory.essentially_small_iff_of_thin {C : Type u} [category_theory.category C] [∀ (X Y : C), subsingleton (X ⟶ Y)] : category_theory.essentially_small C ↔ small (category_theory.skeleton C)
theorem dite_not {α : Sort u_1} (P : Prop) [decidable P] (x : ¬P → α) (y : ¬¬P → α) : dite (¬P) x y = dite P (λ (h : P), y _) x
theorem subring.closure_eq {R : Type u} [ring R] (s : subring R) : subring.closure ↑s = s
theorem algebra.adjoin_induction₂ {R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] {s : set A} {p : A → A → Prop} {a b : A} (ha : a ∈ algebra.adjoin R s) (hb : b ∈ algebra.adjoin R s) (Hs : ∀ (x : A), x ∈ s → ∀ (y : A), y ∈ s → p x y) (Halg : ∀ (r₁ r₂ : R), p (⇑(algebra_map R A) r₁) (⇑(algebra_map R A) r₂)) (Halg_left : ∀ (r : R) (x : A), x ∈ s → p (⇑(algebra_map R A) r) x) (Halg_right : ∀ (r : R) (x : A), x ∈ s → p x (⇑(algebra_map R A) r)) (Hadd_left : ∀ (x₁ x₂ y : A), p x₁ y → p x₂ y → p (x₁ + x₂) y) (Hadd_right : ∀ (x y₁ y₂ : A), p x y₁ → p x y₂ → p x (y₁ + y₂)) (Hmul_left : ∀ (x₁ x₂ y : A), p x₁ y → p x₂ y → p (x₁ * x₂) y) (Hmul_right : ∀ (x y₁ y₂ : A), p x y₁ → p x y₂ → p x (y₁ * y₂)) : p a b
theorem filter.supr_ultrafilter_le_eq {α : Type u} (f : filter α) : (⨆ (g : ultrafilter α) (hg : ↑g ≤ f), ↑g) = f
theorem inner_product_geometry.norm_eq_of_angle_sub_eq_angle_sub_rev_of_angle_ne_pi {V : Type u_1} [inner_product_space ℝ V] {x y : V} (h : inner_product_geometry.angle x (x - y) = inner_product_geometry.angle y (y - x)) (hpi : inner_product_geometry.angle x y ≠ real.pi) : ∥x∥ = ∥y∥
theorem multiple_mem_span_of_mem_localization_span {R S : Type u} [comm_ring R] [comm_ring S] (M : submonoid R) (R' : Type u) [comm_ring R'] [algebra R R'] [algebra R' S] [algebra R S] [is_scalar_tower R R' S] [is_localization M R'] (s : set S) (x : S) (hx : x ∈ submodule.span R' s) : ∃ (t : ↥M), t • x ∈ submodule.span R s
theorem category_theory.grothendieck_topology.plus.is_sheaf_plus_plus {C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w} [category_theory.category D] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] [∀ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)ᵒᵖ D] [∀ (P : Cᵒᵖ ⥤ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [Π (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)ᵒᵖ (category_theory.forget D)] [category_theory.reflects_isomorphisms (category_theory.forget D)] (P : Cᵒᵖ ⥤ D) : category_theory.presheaf.is_sheaf J (J.plus_obj (J.plus_obj P))
theorem formal_multilinear_series.left_inv_remove_zero {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) (i : E ≃L[𝕜] F) : p.remove_zero.left_inv i = p.left_inv i
theorem Top.presheaf.presieve_of_covering.fork_ι_comp_pi_opens_to_first_obj_to_pi_opens_eq {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) {ι : Type v} (U : ι → topological_space.opens ↥X) (s : category_theory.limits.fork (Top.presheaf.sheaf_condition_equalizer_products.left_res F U) (Top.presheaf.sheaf_condition_equalizer_products.right_res F U)) : s.ι ≫ Top.presheaf.presieve_of_covering.pi_opens_to_first_obj F U ≫ Top.presheaf.presieve_of_covering.first_obj_to_pi_opens F U = s.ι
theorem monoid_algebra.ring_hom_ext {k : Type u₁} {G : Type u₂} {R : Type u_1} [semiring k] [mul_one_class G] [semiring R] {f g : monoid_algebra k G →+* R} (h₁ : ∀ (b : k), ⇑f (finsupp.single 1 b) = ⇑g (finsupp.single 1 b)) (h_of : ∀ (a : G), ⇑f (finsupp.single a 1) = ⇑g (finsupp.single a 1)) : f = g
theorem measure_theory.measure.prod_eq {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] {μν : measure_theory.measure (α × β)} (h : ∀ (s : set α) (t : set β), measurable_set s → measurable_set t → ⇑μν (s ×ˢ t) = ⇑μ s * ⇑ν t) : μ.prod ν = μν
theorem csupr_mono {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {f g : ι → α} (B : bdd_above (set.range g)) (H : ∀ (x : ι), f x ≤ g x) : supr f ≤ supr g
theorem add_con.zsmul {M : Type u_1} [add_group M] (c : add_con M) (n : ℤ) {w x : M} : ⇑c w x → ⇑c (n • w) (n • x)
theorem cont_diff_on.cont_mdiff_on {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {n : with_top ℕ} {f : E → E'} {s : set E} : cont_diff_on 𝕜 n f s → cont_mdiff_on (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n f s
theorem mul_smul_comm {α : Type u_6} {β : Type u_7} [has_mul β] [has_scalar α β] [smul_comm_class α β β] (s : α) (x y : β) : x * s • y = s • (x * y)
theorem closure_operator_gi_self {α : Type u_1} [partial_order α] (c : closure_operator α) : _.closure_operator = c
theorem well_founded.is_sup_closed_compact (α : Type u_1) [complete_lattice α] : well_founded gt → complete_lattice.is_sup_closed_compact α
theorem affine.simplex.range_face_points {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : ℕ} (s : affine.simplex k P n) {fs : finset (fin (n + 1))} {m : ℕ} (h : fs.card = m + 1) : set.range (s.face h).points = s.points '' ↑fs
theorem lipschitz_on_with.dimH_image_le {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X → Y} {s : set X} (h : lipschitz_on_with K f s) : dimH (f '' s) ≤ dimH s
theorem finite_dimensional.nontrivial_of_finrank_pos {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (h : 0 < finite_dimensional.finrank K V) : nontrivial V
theorem set.subsingleton.dimH_zero {X : Type u_2} [emetric_space X] {s : set X} (h : s.subsingleton) : dimH s = 0
theorem tfae_mem_nhds_within_Ioi {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a b : α} (hab : a < b) (s : set α) : [s ∈ nhds_within a (set.Ioi a), s ∈ nhds_within a (set.Ioc a b), s ∈ nhds_within a (set.Ioo a b), ∃ (u : α) (H : u ∈ set.Ioc a b), set.Ioo a u ⊆ s, ∃ (u : α) (H : u ∈ set.Ioi a), set.Ioo a u ⊆ s].tfae
theorem algebra.discr_is_unit_of_basis {ι : Type w} [fintype ι] (K : Type u) {L : Type v} [field K] [field L] [algebra K L] [module.finite K L] [is_separable K L] (b : basis ι K L) : is_unit (algebra.discr K ⇑b)
theorem smul_unit_ball_of_pos {E : Type u_2} [semi_normed_group E] [normed_space ℝ E] {r : ℝ} (hr : 0 < r) : r • metric.ball 0 1 = metric.ball 0 r
theorem orthonormal.inner_right_finsupp {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : orthonormal 𝕜 v) (l : ι →₀ 𝕜) (i : ι) : has_inner.inner (v i) (⇑(finsupp.total ι E 𝕜 v) l) = ⇑l i
theorem ite_not {α : Sort u_1} (P : Prop) [decidable P] (a b : α) : ite (¬P) a b = ite P b a
theorem is_chain.symm {α : Type u_1} {r : α → α → Prop} {s : set α} (h : is_chain r s) : is_chain (flip r) s
theorem emetric.Hausdorff_edist_le_of_inf_edist {α : Type u} [pseudo_emetric_space α] {s t : set α} {r : ennreal} (H1 : ∀ (x : α), x ∈ s → emetric.inf_edist x t ≤ r) (H2 : ∀ (x : α), x ∈ t → emetric.inf_edist x s ≤ r) : emetric.Hausdorff_edist s t ≤ r
theorem linear_map.comp_multilinear_map_alternatization {R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N' : Type u_5} [add_comm_group N'] [module R N'] {ι : Type u_6} [decidable_eq ι] {N'₂ : Type u_7} [add_comm_group N'₂] [module R N'₂] [fintype ι] (g : N' →ₗ[R] N'₂) (f : multilinear_map R (λ (_x : ι), M) N') : ⇑multilinear_map.alternatization (g.comp_multilinear_map f) = ⇑(g.comp_alternating_map) (⇑multilinear_map.alternatization f)
theorem uniform_embedding.to_isometry {α : Type u_1} {β : Type u_2} [uniform_space α] [metric_space β] {f : α → β} (h : uniform_embedding f) : isometry f
theorem asymptotics.is_o_of_tendsto' {α : Type u_1} {𝕜 : Type u_14} [normed_field 𝕜] {l : filter α} {f g : α → 𝕜} (hgf : ∀ᶠ (x : α) in l, g x = 0 → f x = 0) : filter.tendsto (λ (x : α), f x / g x) l (nhds 0) → f =o[l] g
theorem is_antichain.sperner {α : Type u_2} [fintype α] {𝒜 : finset (finset α)} (h𝒜 : is_antichain has_subset.subset ↑𝒜) : 𝒜.card ≤ (fintype.card α).choose (fintype.card α / 2)
theorem is_primitive_root.totient_le_degree_minpoly {n : ℕ} {K : Type u_8} [field K] {μ : K} (h : is_primitive_root μ n) [char_zero K] : n.totient ≤ (minpoly ℤ μ).nat_degree
theorem finset.card_mul_le_card_shadow_mul {α : Type u_2} [decidable_eq α] [fintype α] {𝒜 : finset (finset α)} {r : ℕ} (h𝒜 : set.sized r ↑𝒜) : 𝒜.card * r ≤ 𝒜.shadow.card * (fintype.card α - r + 1)
theorem ennreal.sub_top {a : ennreal} : a - ⊤ = 0
theorem module.equiv_direct_sum_of_is_torsion {R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {N : Type (max u v)} [add_comm_group N] [module R N] [h' : module.finite R N] (hN : module.is_torsion R N) : ∃ (ι : Type u) [_inst_8 : fintype ι] (p : ι → R) [_inst_9 : ∀ (i : ι), irreducible (p i)] (e : ι → ℕ), nonempty (N ≃ₗ[R] direct_sum ι (λ (i : ι), R ⧸ submodule.span R {p i ^ e i}))
theorem vadd_mem_span_points_of_mem_span_points_of_mem_vector_span (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p : P} {v : V} (hp : p ∈ span_points k s) (hv : v ∈ vector_span k s) : v +ᵥ p ∈ span_points k s
theorem set.pairwise_disjoint.countable_of_nonempty_interior {α : Type u} [t : topological_space α] [topological_space.separable_space α] {ι : Type u_1} {s : ι → set α} {a : set ι} (h : a.pairwise_disjoint s) (ha : ∀ (i : ι), i ∈ a → (interior (s i)).nonempty) : a.countable
theorem category_theory.concrete_category.mono_of_injective {C : Type v} [category_theory.category C] [category_theory.concrete_category C] {X Y : C} (f : X ⟶ Y) (i : function.injective ⇑f) : category_theory.mono f
theorem affine_subspace.coe_injective {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] : function.injective coe
theorem is_cyclic_of_subgroup_is_domain {R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G →* R) (hf : function.injective ⇑f) : is_cyclic G
theorem Top.range_pullback_map {W X Y Z S T : Top} (f₁ : W ⟶ S) (f₂ : X ⟶ S) (g₁ : Y ⟶ T) (g₂ : Z ⟶ T) (i₁ : W ⟶ Y) (i₂ : X ⟶ Z) (i₃ : S ⟶ T) [H₃ : category_theory.mono i₃] (eq₁ : f₁ ≫ i₃ = i₁ ≫ g₁) (eq₂ : f₂ ≫ i₃ = i₂ ≫ g₂) : set.range ⇑(category_theory.limits.pullback.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂) = ⇑category_theory.limits.pullback.fst ⁻¹' set.range ⇑i₁ ∩ ⇑category_theory.limits.pullback.snd ⁻¹' set.range ⇑i₂
theorem finset.exists_sum_fiber_le_of_maps_to_of_sum_le_nsmul {α : Type u} {β : Type v} {M : Type w} [decidable_eq β] {s : finset α} {t : finset β} {f : α → β} {w : α → M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (hf : ∀ (a : α), a ∈ s → f a ∈ t) (ht : t.nonempty) (hb : s.sum (λ (x : α), w x) ≤ t.card • b) : ∃ (y : β) (H : y ∈ t), (finset.filter (λ (x : α), f x = y) s).sum (λ (x : α), w x) ≤ b
theorem euclidean_geometry.reflection_involutive {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ℝ P) [nonempty ↥s] [complete_space ↥(s.direction)] : function.involutive ⇑(euclidean_geometry.reflection s)
theorem inner_product_geometry.angle_add_angle_sub_add_angle_sub_eq_pi {V : Type u_1} [inner_product_space ℝ V] {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : inner_product_geometry.angle x y + inner_product_geometry.angle x (x - y) + inner_product_geometry.angle y (y - x) = real.pi
theorem affine.simplex.centroid_eq_affine_combination_of_points_with_circumcenter {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P n) (fs : finset (fin (n + 1))) : finset.centroid ℝ fs s.points = ⇑(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.centroid_weights_with_circumcenter fs)
theorem finset.sum_card_slice_div_choose_le_one {𝕜 : Type u_1} {α : Type u_2} [linear_ordered_field 𝕜] {𝒜 : finset (finset α)} [fintype α] (h𝒜 : is_antichain has_subset.subset ↑𝒜) : (finset.range (fintype.card α + 1)).sum (λ (r : ℕ), ↑((𝒜.slice r).card) / ↑((fintype.card α).choose r)) ≤ 1
theorem le_gronwall_bound_of_liminf_deriv_right_le {f f' : ℝ → ℝ} {δ K ε a b : ℝ} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → ∀ (r : ℝ), f' x < r → (∃ᶠ (z : ℝ) in nhds_within x (set.Ioi x), (z - x)⁻¹ * (f z - f x) < r)) (ha : f a ≤ δ) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → f' x ≤ K * f x + ε) (x : ℝ) (H : x ∈ set.Icc a b) : f x ≤ gronwall_bound δ K ε (x - a)
theorem list.duplicate_iff_exists_distinct_nth_le {α : Type u_1} {l : list α} {x : α} : list.duplicate x l ↔ ∃ (n : ℕ) (hn : n < l.length) (m : ℕ) (hm : m < l.length) (h : n < m), x = l.nth_le n hn ∧ x = l.nth_le m hm
theorem lt_mul_of_inv_mul_lt {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : b⁻¹ * a < c → a < b * c
theorem rel_hom.injective_of_increasing {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} [is_trichotomous α r] [is_irrefl β s] (f : r →r s) : function.injective ⇑f
theorem category_theory.adjunction.has_colimits_of_shape_of_equivalence {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {J : Type u} [category_theory.category J] (E : C ⥤ D) [category_theory.is_equivalence E] [category_theory.limits.has_colimits_of_shape J D] : category_theory.limits.has_colimits_of_shape J C
theorem generalized_continued_fraction.numerators_recurrence {K : Type u_1} {g : generalized_continued_fraction K} {n : ℕ} [division_ring K] {gp : generalized_continued_fraction.pair K} {ppredA predA : K} (succ_nth_s_eq : g.s.nth (n + 1) = option.some gp) (nth_num_eq : g.numerators n = ppredA) (succ_nth_num_eq : g.numerators (n + 1) = predA) : g.numerators (n + 2) = gp.b * predA + gp.a * ppredA
theorem subfield.multiset_sum_mem {K : Type u} [field K] (s : subfield K) (m : multiset K) : (∀ (a : K), a ∈ m → a ∈ s) → m.sum ∈ s
theorem asymptotics.is_O.norm_left {α : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : α → F} {f' : α → E'} {l : filter α} : f' =O[l] g → (λ (x : α), ∥f' x∥) =O[l] g
theorem disjoint.zero_not_mem_sub_set {α : Type u_2} [add_group α] {s t : set α} : disjoint s t → 0 ∉ s - t
theorem normed_group_hom.mk_normed_group_hom_norm_le' {V₁ : Type u_2} {V₂ : Type u_3} [semi_normed_group V₁] [semi_normed_group V₂] (f : V₁ →+ V₂) {C : ℝ} (h : ∀ (x : V₁), ∥⇑f x∥ ≤ C * ∥x∥) : ∥f.mk_normed_group_hom C h∥ ≤ linear_order.max C 0
theorem cauchy_seq_finset_of_geometric_bound {α : Type u_1} [semi_normed_group α] {r C : ℝ} {f : ℕ → α} (hr : r < 1) (hf : ∀ (n : ℕ), ∥f n∥ ≤ C * r ^ n) : cauchy_seq (λ (s : finset ℕ), s.sum (λ (x : ℕ), f x))
theorem norm_sub_pow_two_real {F : Type u_3} [inner_product_space ℝ F] {x y : F} : ∥x - y∥ ^ 2 = ∥x∥ ^ 2 - 2 * has_inner.inner x y + ∥y∥ ^ 2
theorem exists_deriv_eq_slope (f : ℝ → ℝ) {a b : ℝ} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hfd : differentiable_on ℝ f (set.Ioo a b)) : ∃ (c : ℝ) (H : c ∈ set.Ioo a b), deriv f c = (f b - f a) / (b - a)
theorem cInf_lt_of_lt {α : Type u_1} [conditionally_complete_lattice α] {s : set α} {a b : α} : bdd_below s → a ∈ s → a < b → has_Inf.Inf s < b
theorem category_theory.abelian.functor.preserves_exact_of_preserves_finite_limits_of_mono {C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (F : C ⥤ D) {X Y Z : C} {f : X ⟶ Y} {g : Y ⟶ Z} [category_theory.abelian C] [category_theory.abelian D] [F.additive] [category_theory.limits.preserves_finite_limits F] [category_theory.mono f] (ex : category_theory.exact f g) : category_theory.exact (F.map f) (F.map g)
theorem euclidean_geometry.cospherical_iff_exists_mem_of_complete {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} {ps : set P} (h : ps ⊆ ↑s) [nonempty ↥s] [complete_space ↥(s.direction)] : euclidean_geometry.cospherical ps ↔ ∃ (center : P) (H : center ∈ s) (radius : ℝ), ∀ (p : P), p ∈ ps → has_dist.dist p center = radius
theorem zero_lt.right.mul_lt_one_of_lt_of_le {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : a < 1) (hb : b ≤ 1) (b0 : 0 < b) : a * b < 1
theorem closure_operator.eq_mk₃_closed {α : Type u_1} [partial_order α] (c : closure_operator α) : c = closure_operator.mk₃ ⇑c c.closed _ _ _
theorem linear_map.map_span {R : Type u_1} {R₂ : Type u_2} {M : Type u_4} {M₂ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring R₂] {σ₁₂ : R →+* R₂} [add_comm_monoid M₂] [module R₂ M₂] [ring_hom_surjective σ₁₂] (f : M →ₛₗ[σ₁₂] M₂) (s : set M) : submodule.map f (submodule.span R s) = submodule.span R₂ (⇑f '' s)
theorem list.permutations_aux2_append {α : Type u_1} {β : Type u_2} (t : α) (ts : list α) (r : list β) (ys : list α) (f : list α → β) : (list.permutations_aux2 t ts list.nil ys f).snd ++ r = (list.permutations_aux2 t ts r ys f).snd
theorem euclidean_geometry.reflection_vadd_smul_vsub_orthogonal_projection {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} [nonempty ↥s] [complete_space ↥(s.direction)] {p₁ : P} (p₂ : P) (r : ℝ) (hp₁ : p₁ ∈ s) : ⇑(euclidean_geometry.reflection s) (r • (p₂ -ᵥ ↑(⇑(euclidean_geometry.orthogonal_projection s) p₂)) +ᵥ p₁) = -(r • (p₂ -ᵥ ↑(⇑(euclidean_geometry.orthogonal_projection s) p₂))) +ᵥ p₁
theorem sum_cauchy_power_series_eq_integral {E : Type u_1} [normed_group E] [normed_space ℂ E] [complete_space E] {f : ℂ → E} {c : ℂ} {R : ℝ} {w : ℂ} (hf : circle_integrable f c R) (hw : complex.abs w < R) : (cauchy_power_series f c R).sum w = (2 * ↑real.pi * complex.I)⁻¹ • ∮ (z : ℂ) in C(c, R), (z - (c + w))⁻¹ • f z
theorem linear_independent.restrict_scalars_algebras {R : Type u_1} {S : Type u_2} {M : Type u_3} {ι : Type u_4} [comm_semiring R] [semiring S] [add_comm_monoid M] [algebra R S] [module R M] [module S M] [is_scalar_tower R S M] (hinj : function.injective ⇑(algebra_map R S)) {v : ι → M} (li : linear_independent S v) : linear_independent R v
theorem inner_product_space.of_core.abs_inner_le_norm {𝕜 : Type u_1} {F : Type u_3} [is_R_or_C 𝕜] [add_comm_group F] [module 𝕜 F] [c : inner_product_space.core 𝕜 F] (x y : F) : is_R_or_C.abs (has_inner.inner x y) ≤ ∥x∥ * ∥y∥
theorem dihedral_group.order_of_r {n : ℕ} [fact (0 < n)] (i : zmod n) : order_of (dihedral_group.r i) = n / n.gcd i.val
theorem set_smul_mem_nhds_smul {α : Type u_2} {G₀ : Type u_6} [group_with_zero G₀] [mul_action G₀ α] [topological_space α] [has_continuous_const_smul G₀ α] {c : G₀} {s : set α} {x : α} (hs : s ∈ nhds x) (hc : c ≠ 0) : c • s ∈ nhds (c • x)
theorem is_submonoid.preimage {M : Type u_1} [monoid M] {N : Type u_2} [monoid N] {f : M → N} (hf : is_monoid_hom f) {s : set N} (hs : is_submonoid s) : is_submonoid (f ⁻¹' s)
theorem exists_ratio_has_deriv_at_eq_ratio_slope (f f' : ℝ → ℝ) {a b : ℝ} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x) (g g' : ℝ → ℝ) (hgc : continuous_on g (set.Icc a b)) (hgg' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x) : ∃ (c : ℝ) (H : c ∈ set.Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c
theorem measure_theory.null_measurable_set.preimage {α : Type u_1} {β : Type u_2} {m0 : measurable_space α} [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} {f : α → β} {t : set β} (ht : measure_theory.null_measurable_set t ν) (hf : measure_theory.measure.quasi_measure_preserving f μ ν) : measure_theory.null_measurable_set (f ⁻¹' t) μ
theorem euclidean_geometry.dist_affine_combination {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {ι : Type u_3} {s : finset ι} {w₁ w₂ : ι → ℝ} (p : ι → P) (h₁ : s.sum (λ (i : ι), w₁ i) = 1) (h₂ : s.sum (λ (i : ι), w₂ i) = 1) : has_dist.dist (⇑(s.affine_combination p) w₁) (⇑(s.affine_combination p) w₂) * has_dist.dist (⇑(s.affine_combination p) w₁) (⇑(s.affine_combination p) w₂) = -s.sum (λ (i₁ : ι), s.sum (λ (i₂ : ι), (w₁ - w₂) i₁ * (w₁ - w₂) i₂ * (has_dist.dist (p i₁) (p i₂) * has_dist.dist (p i₁) (p i₂)))) / 2
theorem div_lt_div_of_mul_sub_mul_div_neg {α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : (a * d - b * c) / (c * d) < 0 → a / c < b / d
theorem generalized_continued_fraction.convergents_eq_convergents' {K : Type u_1} {n : ℕ} {g : generalized_continued_fraction K} [linear_ordered_field K] (s_pos : ∀ {gp : generalized_continued_fraction.pair K} {m : ℕ}, m < n → g.s.nth m = option.some gp → 0 < gp.a ∧ 0 < gp.b) : g.convergents n = g.convergents' n
theorem category_theory.limits.has_binary_biproducts.of_has_binary_coproducts {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_coproducts C] : category_theory.limits.has_binary_biproducts C
theorem function.surjective.range_eq {α : Type u} {ι : Sort x} {f : ι → α} : function.surjective f → set.range f = set.univ
theorem set.nonempty.pairwise_eq_iff_exists_eq {α : Type u_1} {ι : Type u_2} {s : set α} (hs : s.nonempty) {f : α → ι} : s.pairwise (λ (x y : α), f x = f y) ↔ ∃ (z : ι), ∀ (x : α), x ∈ s → f x = z
theorem subsemigroup.closure_induction {M : Type u_1} [has_mul M] {s : set M} {p : M → Prop} {x : M} (h : x ∈ subsemigroup.closure s) (Hs : ∀ (x : M), x ∈ s → p x) (Hmul : ∀ (x y : M), p x → p y → p (x * y)) : p x
theorem padic_val_rat.min_le_padic_val_rat_add (p : ℕ) [p_prime : fact (nat.prime p)] {q r : ℚ} (hqr : q + r ≠ 0) : linear_order.min (padic_val_rat p q) (padic_val_rat p r) ≤ padic_val_rat p (q + r)
theorem basis.orientation_adjust_to_orientation {R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {ι : Type u_3} [decidable_eq ι] [fintype ι] [nontrivial R] [nonempty ι] (e : basis ι R M) (x : orientation R M ι) : (e.adjust_to_orientation x).orientation = x
theorem cont_diff_bump_of_inner.convolution_tendsto_right {G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G → E'} [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ E'] [inner_product_space ℝ G] [complete_space E'] [borel_space G] [measure_theory.is_locally_finite_measure μ] [μ.is_open_pos_measure] [finite_dimensional ℝ G] [μ.is_add_left_invariant] {ι : Type u_1} {φ : ι → cont_diff_bump_of_inner 0} {l : filter ι} (hφ : filter.tendsto (λ (i : ι), (φ i).R) l (nhds 0)) (hg : continuous g) (x₀ : G) : filter.tendsto (λ (i : ι), convolution (λ (x : G), (φ i).normed μ x) g (continuous_linear_map.lsmul ℝ ℝ) μ x₀) l (nhds (g x₀))
theorem char_dvd_card_solutions_family {K : Type u_1} {σ : Type u_2} [fintype K] [field K] [fintype σ] [decidable_eq K] [decidable_eq σ] (p : ℕ) [char_p K p] {ι : Type u_3} {s : finset ι} {f : ι → mv_polynomial σ K} (h : s.sum (λ (i : ι), (f i).total_degree) < fintype.card σ) : p ∣ fintype.card {x // ∀ (i : ι), i ∈ s → ⇑(mv_polynomial.eval x) (f i) = 0}
theorem prime_dvd_char_iff_dvd_card {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : p ∣ ring_char R ↔ p ∣ fintype.card R
theorem exists_compact_subset {α : Type u} [topological_space α] [locally_compact_space α] {x : α} {U : set α} (hU : is_open U) (hx : x ∈ U) : ∃ (K : set α), is_compact K ∧ x ∈ interior K ∧ K ⊆ U
theorem category_theory.exp_comparison_iso_of_frobenius_morphism_iso {C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] [category_theory.limits.has_finite_products C] [category_theory.limits.has_finite_products D] (F : C ⥤ D) {L : D ⥤ C} [category_theory.cartesian_closed C] [category_theory.cartesian_closed D] [category_theory.limits.preserves_limits_of_shape (category_theory.discrete category_theory.limits.walking_pair) F] (h : L ⊣ F) (A : C) [i : category_theory.is_iso (category_theory.frobenius_morphism F h A)] : category_theory.is_iso (category_theory.exp_comparison F A)
theorem finset.fold_ite {α : Type u_1} {β : Type u_2} {op : β → β → β} [hc : is_commutative β op] [ha : is_associative β op] {f : α → β} {b : β} {s : finset α} [is_idempotent β op] {g : α → β} (p : α → Prop) [decidable_pred p] : finset.fold op b (λ (i : α), ite (p i) (f i) (g i)) s = op (finset.fold op b f (finset.filter p s)) (finset.fold op b g (finset.filter (λ (i : α), ¬p i) s))
theorem measure_theory.exists_lt_lower_semicontinuous_lintegral_ge {α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] (μ : measure_theory.measure α) [μ.weakly_regular] [measure_theory.sigma_finite μ] (f : α → nnreal) (fmeas : measurable f) {ε : ennreal} (ε0 : ε ≠ 0) : ∃ (g : α → ennreal), (∀ (x : α), ↑(f x) < g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), g x ∂μ ≤ ∫⁻ (x : α), ↑(f x) ∂μ + ε
theorem polynomial.mem_lifts_iff_mem_alg (R : Type u) [comm_semiring R] {S : Type v} [semiring S] [algebra R S] (p : polynomial S) : p ∈ polynomial.lifts (algebra_map R S) ↔ p ∈ (polynomial.map_alg R S).range
theorem same_ray.neg {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R x y → same_ray R (-x) (-y)
theorem asymptotics.is_o.of_bound {α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : α → E} {g : α → F} {l : filter α} : (∀ ⦃c : ℝ⦄, 0 < c → (∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g x∥)) → f =o[l] g
theorem box_integral.prepartition.compl_congr {ι : Type u_1} {I : box_integral.box ι} [fintype ι] {π₁ π₂ : box_integral.prepartition I} (h : π₁.Union = π₂.Union) : π₁.compl = π₂.compl
theorem unique_factorization_monoid.dvd_of_dvd_mul_left_of_no_prime_factors {R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] {a b c : R} (ha : a ≠ 0) : (∀ {d : R}, d ∣ a → d ∣ c → ¬prime d) → a ∣ b * c → a ∣ b
theorem gram_schmidt_ne_zero (𝕜 : Type u_1) {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_3} [linear_order ι] [order_bot ι] [locally_finite_order ι] [is_well_order ι has_lt.lt] [succ_order ι] [is_succ_archimedean ι] (f : ι → E) (n : ι) (h₀ : linear_independent 𝕜 f) : gram_schmidt 𝕜 f n ≠ 0
theorem orientation.oangle_eq_basis_oangle {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (h : b.orientation = o) (x y : V) : o.oangle x y = hb.oangle x y
theorem has_deriv_at.of_local_left_inverse {𝕜 : Type u} [nondiscrete_normed_field 𝕜] {f g : 𝕜 → 𝕜} {f' a : 𝕜} (hg : continuous_at g a) (hf : has_deriv_at f f' (g a)) (hf' : f' ≠ 0) (hfg : ∀ᶠ (y : 𝕜) in nhds a, f (g y) = y) : has_deriv_at g f'⁻¹ a
theorem algebra.norm_algebra_map_of_basis {R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] [algebra R S] {ι : Type w} [fintype ι] (b : basis ι R S) (x : R) : ⇑(algebra.norm R) (⇑(algebra_map R S) x) = x ^ fintype.card ι
theorem ring_hom_surjective.comp {R₁ : Type u_1} {R₂ : Type u_2} {R₃ : Type u_3} [semiring R₁] [semiring R₂] [semiring R₃] {σ₁₂ : R₁ →+* R₂} {σ₂₃ : R₂ →+* R₃} {σ₁₃ : R₁ →+* R₃} [ring_hom_comp_triple σ₁₂ σ₂₃ σ₁₃] [ring_hom_surjective σ₁₂] [ring_hom_surjective σ₂₃] : ring_hom_surjective σ₁₃
theorem inv_mul_mul_self {G₀ : Type u_2} [group_with_zero G₀] (a : G₀) : a⁻¹ * a * a = a
theorem neg_nonneg {α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : 0 ≤ -a ↔ a ≤ 0
theorem add_monoid_hom.map_finsum_mem {α : Type u_1} {M : Type u_5} {N : Type u_6} [add_comm_monoid M] [add_comm_monoid N] {s : set α} (f : α → M) (g : M →+ N) (hs : s.finite) : ⇑g (finsum (λ (j : α), finsum (λ (H : j ∈ s), f j))) = finsum (λ (i : α), finsum (λ (H : i ∈ s), ⇑g (f i)))
theorem metric.thickening_thickening_subset {α : Type u} [pseudo_emetric_space α] (ε δ : ℝ) (s : set α) : metric.thickening ε (metric.thickening δ s) ⊆ metric.thickening (ε + δ) s
theorem is_add_hom.neg {α : Type u_1} {β : Type u_2} [has_add α] [add_comm_group β] {f : α → β} (hf : is_add_hom f) : is_add_hom (λ (a : α), -f a)
theorem interval_integral.integral_congr {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f g : ℝ → E} {μ : measure_theory.measure ℝ} {a b : ℝ} (h : set.eq_on f g (set.interval a b)) : ∫ (x : ℝ) in a..b, f x ∂μ = ∫ (x : ℝ) in a..b, g x ∂μ
theorem liouville.frequently_exists_num {x : ℝ} (hx : liouville x) (n : ℕ) : ∃ᶠ (b : ℕ) in filter.at_top, ∃ (a : ℤ), x ≠ ↑a / ↑b ∧ |x - ↑a / ↑b| < 1 / ↑b ^ n
theorem finprod_mem_finset_product {α : Type u_1} {β : Type u_2} {M : Type u_5} [comm_monoid M] (s : finset (α × β)) (f : α × β → M) : finprod (λ (ab : α × β), finprod (λ (h : ab ∈ s), f ab)) = finprod (λ (a : α), finprod (λ (b : β), finprod (λ (h : (a, b) ∈ s), f (a, b))))
theorem submodule.torsion_by_is_torsion_by {R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] (a : R) : module.is_torsion_by R ↥(submodule.torsion_by R M a) a
theorem list.nth_le_rotate' {α : Type u} (l : list α) (n k : ℕ) (hk : k < l.length) : (l.rotate n).nth_le ((l.length - n % l.length + k) % l.length) _ = l.nth_le k hk
theorem metric.inf_dist_le_inf_dist_of_subset {α : Type u} [pseudo_metric_space α] {s t : set α} {x : α} (h : s ⊆ t) (hs : s.nonempty) : metric.inf_dist x t ≤ metric.inf_dist x s
theorem summable.of_abs {α : Type u_1} {β : Type u_2} [linear_ordered_add_comm_group β] [uniform_space β] [uniform_add_group β] [complete_space β] {f : α → β} : summable (λ (x : α), |f x|) → summable f
theorem subgroup.prod_mem {G : Type u_1} [comm_group G] (K : subgroup G) {ι : Type u_2} {t : finset ι} {f : ι → G} (h : ∀ (c : ι), c ∈ t → f c ∈ K) : t.prod (λ (c : ι), f c) ∈ K
theorem con.trans {M : Type u_1} [has_mul M] (c : con M) {x y z : M} : ⇑c x y → ⇑c y z → ⇑c x z
theorem finset.nat.card_antidiagonal (n : ℕ) : (finset.nat.antidiagonal n).card = n + 1
theorem continuous.bdd_above_range_of_has_compact_mul_support {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_closed_topology α] [nonempty α] [topological_space β] [has_one α] {f : β → α} (hf : continuous f) (h : has_compact_mul_support f) : bdd_above (set.range f)
theorem lipschitz_with.continuous {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {K : nnreal} {f : α → β} (hf : lipschitz_with K f) : continuous f
theorem has_fderiv_at.has_mfderiv_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {f : E → E'} {x : E} {f' : tangent_space (model_with_corners_self 𝕜 E) x →L[𝕜] tangent_space (model_with_corners_self 𝕜 E') (f x)} : has_fderiv_at f f' x → has_mfderiv_at (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f x f'
theorem order.pred_ne_pred {α : Type u_1} [partial_order α] [pred_order α] {a b : α} [no_min_order α] : a ≠ b → order.pred a ≠ order.pred b
theorem local_homeomorph.cont_diff_at_symm_deriv {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {n : with_top ℕ} [complete_space 𝕜] (f : local_homeomorph 𝕜 𝕜) {f₀' a : 𝕜} (h₀ : f₀' ≠ 0) (ha : a ∈ f.to_local_equiv.target) (hf₀' : has_deriv_at ⇑f f₀' (⇑(f.symm) a)) (hf : cont_diff_at 𝕜 n ⇑f (⇑(f.symm) a)) : cont_diff_at 𝕜 n ⇑(f.symm) a
theorem normed_ring.inverse_add_norm_diff_nth_order {R : Type u_1} [normed_ring R] [complete_space R] (x : Rˣ) (n : ℕ) : (λ (t : R), ring.inverse (↑x + t) - (finset.range n).sum (λ (i : ℕ), (-↑x⁻¹ * t) ^ i) * ↑x⁻¹) =O[nhds 0] λ (t : R), ∥t∥ ^ n
theorem exists_norm_eq_infi_of_complete_subspace {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) (h : is_complete ↑K) (u : E) : ∃ (v : E) (H : v ∈ K), ∥u - v∥ = ⨅ (w : ↥↑K), ∥u - ↑w∥
theorem measure_theory.induced_outer_measure_caratheodory {α : Type u_1} {P : set α → Prop} {m : Π (s : set α), P s → ennreal} {P0 : P ∅} {m0 : m ∅ P0 = 0} (PU : ∀ ⦃f : ℕ → set α⦄, (∀ (i : ℕ), P (f i)) → P (⋃ (i : ℕ), f i)) (msU : ∀ ⦃f : ℕ → set α⦄ (hm : ∀ (i : ℕ), P (f i)), m (⋃ (i : ℕ), f i) _ ≤ ∑' (i : ℕ), m (f i) _) (m_mono : ∀ ⦃s₁ s₂ : set α⦄ (hs₁ : P s₁) (hs₂ : P s₂), s₁ ⊆ s₂ → m s₁ hs₁ ≤ m s₂ hs₂) (s : set α) : measurable_set s ↔ ∀ (t : set α), P t → ⇑(measure_theory.induced_outer_measure m P0 m0) (t ∩ s) + ⇑(measure_theory.induced_outer_measure m P0 m0) (t  s) ≤ ⇑(measure_theory.induced_outer_measure m P0 m0) t
theorem orthonormal.oangle_self {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x : V) : hb.oangle x x = 0
theorem right_iff_left_not_left_of {α : Type u} (r s : α → α → Prop) [is_nonstrict_strict_order α r s] {a b : α} : s a b ↔ r a b ∧ ¬r b a
theorem measure_theory.integral_integral_add {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] ⦃f g : α × β → E⦄ (hf : measure_theory.integrable f (μ.prod ν)) (hg : measure_theory.integrable g (μ.prod ν)) : ∫ (x : α), ∫ (y : β), f (x, y) + g (x, y) ∂ν ∂μ = ∫ (x : α), ∫ (y : β), f (x, y) ∂ν ∂μ + ∫ (x : α), ∫ (y : β), g (x, y) ∂ν ∂μ
theorem is_preconnected.subset_clopen {α : Type u} [topological_space α] {s t : set α} (hs : is_preconnected s) (ht : is_clopen t) (hne : (s ∩ t).nonempty) : s ⊆ t
theorem lt_sub_left_of_add_lt {α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a + b < c → b < c - a
theorem ring_hom.map_prod {β : Type u} {α : Type v} {γ : Type w} [comm_semiring β] [comm_semiring γ] (g : β →+* γ) (f : α → β) (s : finset α) : ⇑g (s.prod (λ (x : α), f x)) = s.prod (λ (x : α), ⇑g (f x))
theorem list.sum_range_succ' {α : Type u} [add_monoid α] (f : ℕ → α) (n : ℕ) : (list.map f (list.range n.succ)).sum = f 0 + (list.map (λ (i : ℕ), f i.succ) (list.range n)).sum
theorem measurable.lintegral_prod_right {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] {f : α → β → ennreal} (hf : measurable (function.uncurry f)) : measurable (λ (x : α), ∫⁻ (y : β), f x y ∂ν)
theorem algebra.discr_power_basis_eq_prod'' (K : Type u) {L : Type v} (E : Type z) [field K] [field L] [field E] [algebra K L] [algebra K E] [module.finite K L] [is_alg_closed E] (pb : power_basis K L) [is_separable K L] (e : fin pb.dim ≃ (L →ₐ[K] E)) : ⇑(algebra_map K E) (algebra.discr K ⇑(pb.basis)) = (-1) ^ (finite_dimensional.finrank K L * (finite_dimensional.finrank K L - 1) / 2) * finset.univ.prod (λ (i : fin pb.dim), (finset.filter (λ (j : fin pb.dim), i < j) finset.univ).prod (λ (j : fin pb.dim), (⇑(⇑e j) pb.gen - ⇑(⇑e i) pb.gen) * (⇑(⇑e i) pb.gen - ⇑(⇑e j) pb.gen)))
theorem one_add_mul_le_pow' {R : Type u₁} [ordered_semiring R] {a : R} (Hsq : 0 ≤ a * a) (Hsq' : 0 ≤ (1 + a) * (1 + a)) (H : 0 ≤ 2 + a) (n : ℕ) : 1 + ↑n * a ≤ (1 + a) ^ n
theorem fixed_points_subgroup_supr (M : Type u_1) (α : Type u_2) [group M] [mul_action M α] {ι : Sort u_3} {P : ι → subgroup M} : mul_action.fixed_points ↥(supr P) α = ⋂ (i : ι), mul_action.fixed_points ↥(P i) α
theorem add_monoid_algebra.alg_hom_ext {k : Type u₁} {G : Type u₂} [comm_semiring k] [add_monoid G] {A : Type u₃} [semiring A] [algebra k A] ⦃φ₁ φ₂ : add_monoid_algebra k G →ₐ[k] A⦄ (h : ∀ (x : G), ⇑φ₁ (finsupp.single x 1) = ⇑φ₂ (finsupp.single x 1)) : φ₁ = φ₂
theorem subring.add_mem {R : Type u} [ring R] (s : subring R) {x y : R} : x ∈ s → y ∈ s → x + y ∈ s
theorem volume_Union_set_of_liouville_with  : ⇑measure_theory.measure_space.volume (⋃ (p : ℝ) (hp : 2 < p), {x : ℝ | liouville_with p x}) = 0
theorem inner_product_geometry.cos_angle_add_angle_sub_add_angle_sub_eq_neg_one {V : Type u_1} [inner_product_space ℝ V] {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : real.cos (inner_product_geometry.angle x y + inner_product_geometry.angle x (x - y) + inner_product_geometry.angle y (y - x)) = -1
theorem measure_theory.unif_integrable_of' {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} (hp : 1 ≤ p) (hp' : p ≠ ⊤) {f : ι → α → β} (hf : ∀ (i : ι), measure_theory.strongly_measurable (f i)) (h : ∀ (ε : ℝ), 0 < ε → (∃ (C : nnreal), 0 < C ∧ ∀ (i : ι), measure_theory.snorm ({x : α | C ≤ ∥f i x∥₊}.indicator (f i)) p μ ≤ ennreal.of_real ε)) : measure_theory.unif_integrable f p μ
theorem category_theory.presheaf.is_sheaf_iff_is_limit {C : Type u₁} [category_theory.category C] {A : Type u₂} [category_theory.category A] (J : category_theory.grothendieck_topology C) (P : Cᵒᵖ ⥤ A) : category_theory.presheaf.is_sheaf J P ↔ ∀ ⦃X : C⦄ (S : category_theory.sieve X), S ∈ ⇑J X → nonempty (category_theory.limits.is_limit (P.map_cone S.arrows.cocone.op))
theorem neg_le_of_neg_le {α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : -a ≤ b → -b ≤ a
theorem triv_sq_zero_ext.linear_map_ext {S : Type u_2} {R : Type u} {M : Type v} {N : Type u_1} [semiring S] [add_comm_monoid R] [add_comm_monoid M] [add_comm_monoid N] [module S R] [module S M] [module S N] ⦃f g : triv_sq_zero_ext R M →ₗ[S] N⦄ (hl : ∀ (r : R), ⇑f (triv_sq_zero_ext.inl r) = ⇑g (triv_sq_zero_ext.inl r)) (hr : ∀ (m : M), ⇑f (triv_sq_zero_ext.inr m) = ⇑g (triv_sq_zero_ext.inr m)) : f = g
theorem fderiv_measurable_aux.differentiable_set_subset_D {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} (K : set (E →L[𝕜] F)) : {x : E | differentiable_at 𝕜 f x ∧ fderiv 𝕜 f x ∈ K} ⊆ fderiv_measurable_aux.D f K
theorem category_theory.indecomposable_of_simple {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] (X : C) [category_theory.simple X] : category_theory.indecomposable X
theorem inner_product_geometry.inner_eq_neg_mul_norm_of_angle_eq_pi {V : Type u_1} [inner_product_space ℝ V] {x y : V} (h : inner_product_geometry.angle x y = real.pi) : has_inner.inner x y = -(∥x∥ * ∥y∥)
theorem pgame.one_mul_equiv (x : pgame) : (1 * x).equiv x
theorem measure_theory.content.borel_le_caratheodory {G : Type w} [topological_space G] (μ : measure_theory.content G) [t2_space G] [S : measurable_space G] [borel_space G] : S ≤ μ.outer_measure.caratheodory
theorem con.lift_apply_mk' {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} (f : c.quotient →* P) : c.lift (f.comp c.mk') _ = f
theorem setoid.eq_iff_rel_eq {α : Type u_1} {r₁ r₂ : setoid α} : r₁ = r₂ ↔ r₁.rel = r₂.rel
theorem convex_independent.range {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] {p : ι → E} (hc : convex_independent 𝕜 p) : convex_independent 𝕜 (λ (x : ↥(set.range p)), ↑x)
theorem is_add_right_regular_of_right_cancel_add_semigroup {R : Type u_1} [add_right_cancel_semigroup R] (g : R) : is_add_right_regular g
theorem orientation.oangle_add_oangle_rev_neg_right {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x y : V) : o.oangle x (-y) + o.oangle y (-x) = 0
theorem lp.uniform_continuous_coe {α : Type u_1} {E : α → Type u_2} {p : ennreal} [Π (i : α), normed_group (E i)] [fact (1 ≤ p)] : uniform_continuous coe
theorem mv_polynomial.vanishing_ideal_zero_locus_eq_radical {k : Type u_1} [field k] {σ : Type u_2} [is_alg_closed k] [fintype σ] (I : ideal (mv_polynomial σ k)) : mv_polynomial.vanishing_ideal (mv_polynomial.zero_locus I) = I.radical
theorem finset.exists_sum_fiber_le_of_sum_fiber_nonneg_of_sum_le_nsmul {α : Type u} {β : Type v} {M : Type w} [decidable_eq β] {s : finset α} {t : finset β} {f : α → β} {w : α → M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (hf : ∀ (y : β), y ∉ t → 0 ≤ (finset.filter (λ (x : α), f x = y) s).sum (λ (x : α), w x)) (ht : t.nonempty) (hb : s.sum (λ (x : α), w x) ≤ t.card • b) : ∃ (y : β) (H : y ∈ t), (finset.filter (λ (x : α), f x = y) s).sum (λ (x : α), w x) ≤ b
theorem continuous.bdd_below_range_of_has_compact_support {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_closed_topology α] [nonempty α] [topological_space β] [has_zero α] {f : β → α} (hf : continuous f) (h : has_compact_support f) : bdd_below (set.range f)
theorem measure_theory.measure_preimage_mul {G : Type u_1} [measurable_space G] [group G] [has_measurable_mul G] (μ : measure_theory.measure G) [μ.is_mul_left_invariant] (g : G) (A : set G) : ⇑μ ((λ (h : G), g * h) ⁻¹' A) = ⇑μ A
theorem has_ftaylor_series_up_to_on.eq_ftaylor_series_of_unique_diff_on {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {x : E} {n : with_top ℕ} {p : E → formal_multilinear_series 𝕜 E F} (h : has_ftaylor_series_up_to_on n f p s) {m : ℕ} (hmn : ↑m ≤ n) (hs : unique_diff_on 𝕜 s) (hx : x ∈ s) : p x m = iterated_fderiv_within 𝕜 m f s x
theorem div_le_of_nonneg_of_le_mul {α : Type u_1} [linear_ordered_field α] {a b c : α} (hb : 0 ≤ b) (hc : 0 ≤ c) (h : a ≤ c * b) : a / b ≤ c
theorem continuous.flow {τ : Type u_1} [add_monoid τ] [topological_space τ] [has_continuous_add τ] {α : Type u_2} [topological_space α] (ϕ : flow τ α) {β : Type u_3} [topological_space β] {t : β → τ} (ht : continuous t) {f : β → α} (hf : continuous f) : continuous (λ (x : β), ⇑ϕ (t x) (f x))
theorem finset.exists_le_card_fiber_of_mul_le_card_of_maps_to {α : Type u} {β : Type v} [decidable_eq β] {s : finset α} {t : finset β} {f : α → β} {n : ℕ} (hf : ∀ (a : α), a ∈ s → f a ∈ t) (ht : t.nonempty) (hn : t.card * n ≤ s.card) : ∃ (y : β) (H : y ∈ t), n ≤ (finset.filter (λ (x : α), f x = y) s).card
theorem to_matrix_dual_tensor_hom {R : Type u_2} {M : Type u_3} {N : Type u_4} [comm_semiring R] [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] {m : Type u_1} {n : Type u_5} [fintype m] [fintype n] [decidable_eq m] [decidable_eq n] (bM : basis m R M) (bN : basis n R N) (j : m) (i : n) : ⇑(linear_map.to_matrix bM bN) (⇑(dual_tensor_hom R M N) (bM.coord j ⊗ₜ[R] ⇑bN i)) = matrix.std_basis_matrix i j 1
theorem polynomial.chebyshev.sin_nat_succ_mul (n : ℕ) (θ : ℂ) : complex.sin ((↑n + 1) * θ) = polynomial.eval (complex.cos θ) (polynomial.chebyshev.U ℂ n) * complex.sin θ
theorem mv_polynomial.prod_X_add_C_coeff {R : Type u_1} [comm_semiring R] (σ : Type u_2) [fintype σ] (r : σ → R) (k : ℕ) (h : k ≤ fintype.card σ) : (finset.univ.prod (λ (i : σ), ⇑polynomial.C (r i) + polynomial.X)).coeff k = (finset.powerset_len (fintype.card σ - k) finset.univ).sum (λ (t : finset σ), t.prod (λ (i : σ), r i))
theorem connected_component_eq_Inter_clopen {α : Type u} [topological_space α] [t2_space α] [compact_space α] (x : α) : connected_component x = ⋂ (Z : {Z // is_clopen Z ∧ x ∈ Z}), ↑Z
theorem finset.centroid_pair (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} [invertible 2] (p : ι → P) (i₁ i₂ : ι) : finset.centroid k {i₁, i₂} p = 2⁻¹ • (p i₂ -ᵥ p i₁) +ᵥ p i₁
theorem add_subgroup.closure_le {G : Type u_1} [add_group G] (K : add_subgroup G) {k : set G} : add_subgroup.closure k ≤ K ↔ k ⊆ ↑K
theorem linear_map.is_Ortho.nondegenerate_of_not_is_ortho_basis_self {R : Type u_1} {M : Type u_5} {n : Type u_14} [comm_ring R] [add_comm_group M] [module R M] [no_zero_divisors R] {B : M →ₗ[R] M →ₗ[R] R} (v : basis n R M) (hO : B.is_Ortho ⇑v) (h : ∀ (i : n), ¬B.is_ortho (⇑v i) (⇑v i)) : B.nondegenerate
theorem matrix.det_permute {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (σ : equiv.perm n) (M : matrix n n R) : matrix.det (λ (i : n), M (⇑σ i)) = ↑(⇑equiv.perm.sign σ) * M.det
theorem orthonormal.oangle_smul_right_of_neg {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x y : V) {r : ℝ} (hr : r < 0) : hb.oangle x (r • y) = hb.oangle x (-y)
theorem exterior_algebra.hom_ext {R : Type u1} [comm_semiring R] {M : Type u2} [add_comm_monoid M] [module R M] {A : Type u_1} [semiring A] [algebra R A] {f g : exterior_algebra R M →ₐ[R] A} (h : f.to_linear_map.comp (exterior_algebra.ι R) = g.to_linear_map.comp (exterior_algebra.ι R)) : f = g
theorem euclidean_geometry.dist_sq_smul_orthogonal_vadd_smul_orthogonal_vadd {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} {p1 p2 : P} (hp1 : p1 ∈ s) (hp2 : p2 ∈ s) (r1 r2 : ℝ) {v : V} (hv : v ∈ (s.direction)ᗮ) : has_dist.dist (r1 • v +ᵥ p1) (r2 • v +ᵥ p2) * has_dist.dist (r1 • v +ᵥ p1) (r2 • v +ᵥ p2) = has_dist.dist p1 p2 * has_dist.dist p1 p2 + (r1 - r2) * (r1 - r2) * (∥v∥ * ∥v∥)
theorem measurable.measurable_embedding {γ : Type u_3} [tγ : topological_space γ] [polish_space γ] [measurable_space γ] [borel_space γ] {β : Type u_4} [tβ : topological_space β] [t2_space β] [measurable_space β] [borel_space β] {f : γ → β} [topological_space.second_countable_topology β] (f_meas : measurable f) (f_inj : function.injective f) : measurable_embedding f
theorem cardinal.mk_univ_real  : cardinal.mk ↥set.univ = cardinal.continuum
theorem metric.mk_uniformity_basis {α : Type u} [pseudo_metric_space α] {β : Type u_1} {p : β → Prop} {f : β → ℝ} (hf₀ : ∀ (i : β), p i → 0 < f i) (hf : ∀ ⦃ε : ℝ⦄, 0 < ε → (∃ (i : β) (hi : p i), f i ≤ ε)) : (uniformity α).has_basis p (λ (i : β), {p : α × α | has_dist.dist p.fst p.snd < f i})
theorem mul_add {R : Type x} [has_mul R] [has_add R] [left_distrib_class R] (a b c : R) : a * (b + c) = a * b + a * c
theorem nat.cast_div_le {α : Type u_1} [linear_ordered_field α] {m n : ℕ} : ↑(m / n) ≤ ↑m / ↑n
theorem orientation.oangle_smul_left_self_of_nonneg {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x : V) {r : ℝ} (hr : 0 ≤ r) : o.oangle (r • x) x = 0
theorem filter.eventually_le.measure_le {α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {s t : set α} (H : s ≤ᵐ[μ] t) : ⇑μ s ≤ ⇑μ t
theorem monotone.pairwise_disjoint_on_Ioc_pred {α : Type u_1} {β : Type u_2} [linear_order α] [pred_order α] [preorder β] {f : α → β} (hf : monotone f) : pairwise (disjoint on λ (n : α), set.Ioc (f (order.pred n)) (f n))
theorem affine.simplex.direction_monge_plane {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P (n + 2)) {i₁ i₂ : fin (n + 3)} : (s.monge_plane i₁ i₂).direction = (submodule.span ℝ {s.points i₁ -ᵥ s.points i₂})ᗮ ⊓ vector_span ℝ (set.range s.points)
theorem add_con.ker_lift_injective {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] (f : M →+ P) : function.injective ⇑(add_con.ker_lift f)
theorem set.nonempty.closure {α : Type u} [topological_space α] {s : set α} : s.nonempty → (closure s).nonempty
theorem finprod_mem_finset_product' {α : Type u_1} {β : Type u_2} {M : Type u_5} [comm_monoid M] [decidable_eq α] [decidable_eq β] (s : finset (α × β)) (f : α × β → M) : finprod (λ (ab : α × β), finprod (λ (h : ab ∈ s), f ab)) = finprod (λ (a : α), finprod (λ (b : β), finprod (λ (h : b ∈ finset.image prod.snd (finset.filter (λ (ab : α × β), ab.fst = a) s)), f (a, b))))
theorem is_locally_constant.apply_eq_of_is_preconnected {X : Type u_1} {Y : Type u_2} [topological_space X] {f : X → Y} (hf : is_locally_constant f) {s : set X} (hs : is_preconnected s) {x y : X} (hx : x ∈ s) (hy : y ∈ s) : f x = f y
theorem finset.prod_add_prod_le' {ι : Type u_1} {R : Type u_8} [canonically_ordered_comm_semiring R] {f g h : ι → R} {s : finset ι} {i : ι} (hi : i ∈ s) (h2i : g i + h i ≤ f i) (hgf : ∀ (j : ι), j ∈ s → j ≠ i → g j ≤ f j) (hhf : ∀ (j : ι), j ∈ s → j ≠ i → h j ≤ f j) : s.prod (λ (i : ι), g i) + s.prod (λ (i : ι), h i) ≤ s.prod (λ (i : ι), f i)
theorem same_ray.map {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] {x y : M} (f : M →ₗ[R] N) (h : same_ray R x y) : same_ray R (⇑f x) (⇑f y)
theorem measure_theory.simple_func.integral_eq_lintegral {α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : measure_theory.simple_func α ℝ} (hf : measure_theory.integrable ⇑f μ) (h_pos : 0 ≤ᵐ[μ] ⇑f) : measure_theory.simple_func.integral μ f = (∫⁻ (a : α), ennreal.of_real (⇑f a) ∂μ).to_real
theorem affine_independent_of_ne (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {p₁ p₂ : P} (h : p₁ ≠ p₂) : affine_independent k ![p₁, p₂]
theorem finset.Ico_eq_empty {α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → finset.Ico a b = ∅
theorem monoid_algebra.support_gen_of_gen' {R : Type u_1} {M : Type u_2} [comm_semiring R] [monoid M] {S : set (monoid_algebra R M)} (hS : algebra.adjoin R S = ⊤) : algebra.adjoin R (⇑(monoid_algebra.of R M) '' ⋃ (f : monoid_algebra R M) (H : f ∈ S), ↑(f.support)) = ⊤
theorem units.is_unit_mul_units {M : Type u_1} [monoid M] (a : M) (u : Mˣ) : is_unit (a * ↑u) ↔ is_unit a
theorem finset.prod_powerset_insert {α : Type u} {β : Type v} [decidable_eq α] [comm_monoid β] {s : finset α} {x : α} (h : x ∉ s) (f : finset α → β) : (has_insert.insert x s).powerset.prod (λ (a : finset α), f a) = s.powerset.prod (λ (a : finset α), f a) * s.powerset.prod (λ (t : finset α), f (has_insert.insert x t))
theorem measurable_set.exists_is_compact_lt_add {α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [μ.regular] ⦃A : set α⦄ (hA : measurable_set A) (h'A : ⇑μ A ≠ ⊤) {ε : ennreal} (hε : ε ≠ 0) : ∃ (K : set α) (H : K ⊆ A), is_compact K ∧ ⇑μ A < ⇑μ K + ε
theorem is_compact.nonempty_Inter_of_directed_nonempty_compact_closed {α : Type u} [topological_space α] {ι : Type v} [hι : nonempty ι] (Z : ι → set α) (hZd : directed superset Z) (hZn : ∀ (i : ι), (Z i).nonempty) (hZc : ∀ (i : ι), is_compact (Z i)) (hZcl : ∀ (i : ι), is_closed (Z i)) : (⋂ (i : ι), Z i).nonempty
theorem affine_basis.det_smul_coords_eq_cramer_coords {ι : Type u₁} {k : Type u₂} {V : Type u₃} {P : Type u₄} [add_comm_group V] [add_torsor V P] [comm_ring k] [module k V] [decidable_eq ι] [fintype ι] (b b₂ : affine_basis ι k P) (x : P) : (b.to_matrix b₂.points).det • ⇑(b₂.coords) x = ⇑((b.to_matrix b₂.points).transpose.cramer) (⇑(b.coords) x)
theorem quotient_norm_mk_le' {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) : ∥↑m∥ ≤ ∥m∥