congr
exact he b hb
congr <;> rw [h x, h y]
constructor <;> exact inferInstance
rw [Subsingleton.elim i default]
rw [Function.bijective_iff_has_inverse]
refine' ⟨default, _, _⟩ <;> intro x <;> simp
simp only [nontrivial_iff_exists_ne x, Subtype.exists, Ne.def, Subtype.ext_iff, Subtype.coe_mk]
intro h
exact Subsingleton.elim
rw [← not_nontrivial_iff_subsingleton, or_comm']
exact Classical.em _
cases f
cases g
congr
simp
-- Error, `f` has type `fin 3 ≃ fin 3` but is expected to have type `fin 3 ↪ ?m_1 : Type ?`
simp
simp [set_value]
simp
simp [Subtype.ext_iff]
simp
congr
injection h
cases e₁
cases e₂
congr
cases h
rfl
cases h
rfl
rw [perm.subsingleton_eq_refl e, coe_refl]
subst h
simp
simp [H.symm]
simp [H]
cases e
rfl
cases e
rfl
cases e
rfl
simp
simp
simp [perm_congr_def]
simp
simp
apply arrow_congr_comp
cases u
rfl
cases u
rfl
simp
simp
funext x
cases f x
rfl
cases u
rfl
rw [Subsingleton.elim b a]
rfl
cases u
rfl
cases x
rfl
cases x
rfl
simp
constructor <;> intro h₂ x
· rw [← f.right_inv x]
    apply h.mp
    apply h₂
apply h.mpr
apply h₂
apply Equiv.forall_congr
intros
apply Equiv.forall_congr
intros
apply h
apply Equiv.forall₂_congr
intros
apply Equiv.forall_congr
intros
apply h
simp
simp only [e.symm_apply_apply]
simp
simp
simp [Equiv.symm_apply_eq]
simp [Equiv.Perm.viaFintypeEmbedding]
dsimp only [extend_subtype]
simp only [subtype_congr, Equiv.trans_apply, Equiv.sum_congr_apply]
rw [sum_compl_apply_symm_of_pos _ _ hx, Sum.map_inl, sum_compl_apply_inl]
dsimp only [extend_subtype]
simp only [subtype_congr, Equiv.trans_apply, Equiv.sum_congr_apply]
rw [sum_compl_apply_symm_of_neg _ _ hx, Sum.map_inr, sum_compl_apply_inr]
rw [← e.right_inv hy, h]
rw [← e.left_inv hx, h]
cases e
rfl
rw [← image_source_eq_target, ball_image_iff]
rw [← image_source_eq_target, bex_image_iff]
rw [e.left_inv hx, h hx]
simp only [is_image, Set.ext_iff, mem_inter_iff, and_congr_right_iff, mem_preimage]
rw [← h.image_eq, ← h'.image_eq, ← hs, Heq.image_eq]
simp [hx]
rw [hs.inter_eq, ht.inter_eq, image_empty]
rw [inter_comm, e.left_inv_on.image_inter', image_source_eq_target, inter_comm]
rw [inter_comm, e.left_inv_on.image_inter, image_source_eq_target, inter_comm]
rw [← e.image_source_inter_eq', inter_eq_self_of_subset_right h]
simp only [mem_preimage, e.left_inv hx]
simp [inter_eq_self_of_subset_left h]
simp
change univ
simp [h.symm, hx]
simp [h, hy]
simp [hx, h.symm]
simp [hy, h]
cases e <;> cases e' <;> rfl
rw [e.trans_source', e.symm_image_target_inter_eq]
simp [trans_source, @preimage_comp α β γ, inter_assoc]
simp [trans_source]
simp [trans_source, preimage_id]
simp [trans_source]
simp [trans_source]
rw [← inter_assoc, inter_self]
simp [eq_on_source]
simp [eq_on_source, h.1.symm]
exact fun x hx => (h.2 hx).symm
simp only [← image_source_eq_target, ← h.source_eq, h.2.image_eq]
refine' ⟨h.target_eq, eq_on_of_left_inv_on_of_right_inv_on e.left_inv_on _ _⟩ <;>
    simp only [symm_source, h.target_eq, h.source_eq, e'.symm_maps_to]
exact e'.right_inv_on.congr_right e'.symm_maps_to (h.source_eq ▸ h.eq_on.symm)
constructor
· rw [trans_source'', trans_source'', ← he.target_eq, ← hf.1]
    exact (he.symm'.eq_on.mono <| inter_subset_left _ _).image_eq
· intro x hx
    rw [trans_source] at hx
    simp [(he.2 hx.1).symm, hf.2 hx.2]
constructor
· simp [he.1]
· intro x hx
    simp only [mem_inter_iff, restr_source] at hx
    exact he.2 hx.1
rw [he.eq_on.inter_preimage_eq, he.source_eq]
simp [A]
apply LocalEquiv.ext (fun x => _) (fun x => _) h.1
· apply h.2
    rw [s]
    exact mem_univ _
· apply h.symm'.2
    rw [symm_source, t]
    exact mem_univ _
simp at hp
simp [hp]
simp at hp
simp [map_target, hp]
simp at hp
simp [hp]
simp at hp
simp [hp]
simp [LocalEquiv.trans_source, Equiv.toLocalEquiv]
apply e.symm.injective
simp
intros
rfl
apply e.symm.injective
simp
apply e.symm.injective
simp
intros
rfl
let mul := e.HasMul
skip <;> apply e.injective.semigroup _ <;> intros <;> exact e.apply_symm_apply _
let mul := e.HasMul
let zero := e.HasZero
skip <;> apply e.injective.semigroup_with_zero _ <;> intros <;> exact e.apply_symm_apply _
let mul := e.HasMul
skip <;> apply e.injective.comm_semigroup _ <;> intros <;> exact e.apply_symm_apply _
let zero := e.HasZero
let mul := e.HasMul
skip <;> apply e.injective.mul_zero_class _ <;> intros <;> exact e.apply_symm_apply _
let one := e.HasOne
let mul := e.HasMul
skip <;> apply e.injective.mul_one_class _ <;> intros <;> exact e.apply_symm_apply _
let zero := e.HasZero
let one := e.HasOne
let mul := e.HasMul
skip <;> apply e.injective.mul_zero_one_class _ <;> intros <;> exact e.apply_symm_apply _
let one := e.HasOne
let mul := e.HasMul
let pow := e.HasPow ℕ
skip <;> apply e.injective.monoid _ <;> intros <;> exact e.apply_symm_apply _
let one := e.HasOne
let mul := e.HasMul
let pow := e.HasPow ℕ
skip <;> apply e.injective.comm_monoid _ <;> intros <;> exact e.apply_symm_apply _
let one := e.HasOne
let mul := e.HasMul
let inv := e.HasInv
let div := e.HasDiv
let npow := e.HasPow ℕ
let zpow := e.HasPow ℤ
skip <;> apply e.injective.group _ <;> intros <;> exact e.apply_symm_apply _
let one := e.HasOne
let mul := e.HasMul
let inv := e.HasInv
let div := e.HasDiv
let npow := e.HasPow ℕ
let zpow := e.HasPow ℤ
skip <;> apply e.injective.comm_group _ <;> intros <;> exact e.apply_symm_apply _
let zero := e.HasZero
let add := e.HasAdd
let mul := e.HasMul
let nsmul := e.HasSmul ℕ
skip <;> apply e.injective.non_unital_non_assoc_semiring _ <;> intros <;>
    exact e.apply_symm_apply _
let zero := e.HasZero
let add := e.HasAdd
let mul := e.HasMul
let nsmul := e.HasSmul ℕ
skip <;> apply e.injective.non_unital_semiring _ <;> intros <;> exact e.apply_symm_apply _
simp [zero_def]
simp [add_def, one_def]
rw [Int.cast_ofNat] <;> rfl
let mul := e.HasMul
let add_monoid_with_one := e.AddMonoidWithOne
skip <;> apply e.injective.non_assoc_semiring _ <;> intros <;> exact e.apply_symm_apply _
let mul := e.HasMul
let add_monoid_with_one := e.AddMonoidWithOne
let npow := e.HasPow ℕ
skip <;> apply e.injective.semiring _ <;> intros <;> exact e.apply_symm_apply _
let zero := e.HasZero
let add := e.HasAdd
let mul := e.HasMul
let nsmul := e.HasSmul ℕ
skip <;> apply e.injective.non_unital_comm_semiring _ <;> intros <;> exact e.apply_symm_apply _
let mul := e.HasMul
let add_monoid_with_one := e.AddMonoidWithOne
let npow := e.HasPow ℕ
skip <;> apply e.injective.comm_semiring _ <;> intros <;> exact e.apply_symm_apply _
let zero := e.HasZero
let add := e.HasAdd
let mul := e.HasMul
let neg := e.HasNeg
let sub := e.HasSub
let nsmul := e.HasSmul ℕ
let zsmul := e.HasSmul ℤ
skip <;> apply e.injective.non_unital_non_assoc_ring _ <;> intros <;> exact e.apply_symm_apply _
let zero := e.HasZero
let add := e.HasAdd
let mul := e.HasMul
let neg := e.HasNeg
let sub := e.HasSub
let nsmul := e.HasSmul ℕ
let zsmul := e.HasSmul ℤ
skip <;> apply e.injective.non_unital_ring _ <;> intros <;> exact e.apply_symm_apply _
let add_group_with_one := e.AddGroupWithOne
let mul := e.HasMul
skip <;> apply e.injective.non_assoc_ring _ <;> intros <;> exact e.apply_symm_apply _
let mul := e.HasMul
let add_group_with_one := e.AddGroupWithOne
let npow := e.HasPow ℕ
skip <;> apply e.injective.ring _ <;> intros <;> exact e.apply_symm_apply _
let zero := e.HasZero
let add := e.HasAdd
let mul := e.HasMul
let neg := e.HasNeg
let sub := e.HasSub
let nsmul := e.HasSmul ℕ
let zsmul := e.HasSmul ℤ
skip <;> apply e.injective.non_unital_comm_ring _ <;> intros <;> exact e.apply_symm_apply _
let mul := e.HasMul
let add_group_with_one := e.AddGroupWithOne
let npow := e.HasPow ℕ
skip <;> apply e.injective.comm_ring _ <;> intros <;> exact e.apply_symm_apply _
let add_group_with_one := e.AddGroupWithOne
let mul := e.HasMul
let inv := e.HasInv
let div := e.HasDiv
let mul := e.HasMul
let npow := e.HasPow ℕ
let zpow := e.HasPow ℤ
let rat_cast := e.HasRatCast
let qsmul := e.HasSmul ℚ
skip <;> apply e.injective.division_ring _ <;> intros <;> exact e.apply_symm_apply _
let add_group_with_one := e.AddGroupWithOne
let mul := e.HasMul
let neg := e.HasNeg
let inv := e.HasInv
let div := e.HasDiv
let mul := e.HasMul
let npow := e.HasPow ℕ
let zpow := e.HasPow ℤ
let rat_cast := e.HasRatCast
let qsmul := e.HasSmul ℚ
skip <;> apply e.injective.field _ <;> intros <;> exact e.apply_symm_apply _
simp [smul_def]
simp [smul_def, mul_smul]
simp [zero_def, smul_def]
simp [add_def, smul_def, smul_add]
simp [zero_def, smul_def]
simp [add_def, smul_def, add_smul]
apply e.symm.injective
simp
rfl
apply e.symm.injective
simp
rfl
simp only [bodd_bit, div2_bit, uncurry_apply_pair, bodd_div2_eq]
simp only [bit_decomp, bodd_div2_eq, uncurry_apply_pair]
simp
simp
subst h
exact w
cases k
rfl
cases k
rfl
simp
simp
cases x <;> dsimp <;> simp
simp [finSuccEquiv']
rw [← Fin.succ_above_below _ _ h, fin_succ_equiv'_succ_above]
rw [← Fin.succ_above_above _ _ h, fin_succ_equiv'_succ_above]
simp [finSuccEquivLast]
simp [Fin.insert_nth_eq_iff]
simp
refine' Fin.addCases (fun i => _) (fun i => _) x <;> simp
simp [finAddFlip]
simp [finAddFlip]
dsimp [finRotate]
simp [h, add_comm]
dsimp [finRotate]
rw [fin_add_flip_apply_mk_right]
simp
simp only [not_lt] at h'
exact (Nat.eq_of_le_of_lt_succ h' h).symm
rw [fin_rotate_succ_apply, zero_add]
rw [fin_rotate_succ_apply]
have : (i : ℕ) < n := lt_of_le_of_ne (nat.succ_le_succ_iff.mp i.2) (fin.coe_injective.ne h)
exact Fin.coe_add_one_of_lt this
rw [fin_rotate_succ_apply, Fin.coe_add_one i]
ac_rfl
rw [Nat.div_eq_of_lt y.2]
simp
simp
simp
simp
simp
simp
simp
simp
cases s <;> rfl
cases s <;> rfl
simp
simp
cases b <;> rfl
cases o <;> rfl
decide
cases a <;> rfl
simp
cases s <;> rfl
simp [perm.subtype_congr.apply, h]
simp [perm.subtype_congr.apply, h]
dsimp
rw [dif_neg h]
simp
simp
cases p
rfl
cases p
rfl
cases n <;> rfl
rw [List.map_map, e.symm_comp_self, List.map_id]
rw [List.map_map, e.self_comp_symm, List.map_id]
simp
simp
simp
rw [← f.2 i]
exact (f.1 i).2
cases x <;> rfl
funext x'
dsimp
erw [dif_pos x'.2, Subtype.coe_eta]
simp [perm.extend_domain]
simp [perm.extend_domain, h]
simp [perm.extend_domain, h]
simp [perm.extend_domain]
simp [perm.extend_domain, perm_congr_trans]
rw [Quotient.sound hab]
simp (config := { contextual := true }) [swap_apply_def]
refine' ⟨fun h => (Equiv.refl _).Injective _, fun h => h ▸ swap_self _⟩
rw [← h, swap_apply_left, h, refl_apply]
cases π
rfl
rw [update_apply _ i j, update_apply _ j i, Equiv.swap_apply_def, id.def]
rw [swap_eq_update, comp_update, comp_update, comp.right_id]
rw [@eq_comm _ (e.symm x)]
constructor <;> intros <;> simp_all
rw [← Equiv.trans_apply, Equiv.swap_swap, Equiv.refl_apply]
rw [apply_eq_iff_eq_symm_apply, symm_swap]
dsimp [set_value]
simp [swap_apply_left]
rw [← e.symm_apply_apply x]
exact f (e x)
  left_inv f
dsimp
rw [e.symm_apply_apply]
rw [e.apply_symm_apply]
simp
simp
rw [← update_comp_eq_of_injective _ g.injective, g.apply_symm_apply]
simp [(e.Pi_congr_left' P).symm_apply_eq, Pi_congr_left'_update]
simp [map_map]
simp [map_map]
simp [bimap_bimap, id_bimap]
simp [bimap_bimap, id_bimap]
rw [image_subset_iff, e.image_eq_preimage]
rw [e.symm.subset_image]
rw [e.symm_symm]
simp
simp
simp
simp
simp at h
subst x
simp
simp_all
simp [Set.ext_iff]
simp
simp [inter_diff_self]
simp [union_diff_self, union_eq_self_of_subset_left h]
apply (Equiv.Set.sumDiffSubset h).Injective
simp only [apply_symm_apply, sum_diff_subset_apply_inl]
exact Subtype.eq rfl
apply (Equiv.Set.sumDiffSubset h).Injective
simp only [apply_symm_apply, sum_diff_subset_apply_inr]
exact Subtype.eq rfl
rw [union_diff_self]
simp only [Sum.map_inl, trans_apply, sum_congr_apply, set.sum_compl_apply_inl,
        set.sum_compl_symm_apply]
simp only [Sum.map_inr, subtype_equiv_apply, set.sum_compl_apply_inr, Function.comp_apply,
        sum_congr_apply, Equiv.coe_trans, Subtype.coe_eta, Subtype.coe_mk,
        set.sum_compl_symm_apply_compl]
apply (Set.image f s H).Injective
simp [(Set.image f s H).apply_symm_apply]
simp
simp [apply_range_splitting f]
apply (of_injective f hf).Injective
simp [apply_of_injective_symm hf]
rw [Subtype.coe_mk]
simp
simp [f_eq]
simp
simp [f_eq]
simp
simp [remove_none_aux, option.is_some_iff_exists.mpr h]
simp [remove_none_aux, option.not_is_some_iff_eq_none.mpr h]
simp [EquivFunctor.map]
cases a
· simp
simp only [cases_on'_some, Function.comp_apply, Subtype.coe_eta, symm_apply_apply,
            dite_eq_ite]
exact if_neg (e a).property
dsimp only [option_subtype]
simp
simp only [option_subtype, coe_fn_symm_mk, Subtype.coe_mk, Subtype.coe_eta, dite_eq_ite,
    ite_eq_right_iff]
exact fun h => False.elim (b.property h)
rw [decode_list]
unfold enle Order.Preimage <;> infer_instance
simp [encode_multiset, decode_multiset, encodek]
rw [decode_list] <;> exact ⟨_, rfl, rfl⟩
rw [← @encode_list_nil α, of_nat_encode]
rw [raise, lower, add_tsub_cancel_right, lower_raise]
have : n ≤ m := List.rel_of_sorted_cons h _ (l.mem_cons_self _)
simp [raise, lower, tsub_add_cancel_of_le this, raise_lower h.of_cons]
have :=
          raise_lower (List.sorted_cons.2 ⟨fun n _ => zero_le n, (s.map encode).sort_sorted _⟩) <;>
        simp [-Multiset.coe_map, this]
simp [-Multiset.coe_map, List.merge_sort_eq_self _ (raise_sorted _ _), lower_raise]
simp [raise', lower', add_tsub_cancel_right, lower_raise']
simp [-Multiset.coe_map, raise'_finset,
          raise_lower' (fun n _ => zero_le n) (Finset.sort_sorted_lt _)]
simp [-Multiset.coe_map, Finset.map, raise'_finset, Finset.sort,
        List.merge_sort_eq_self (· ≤ ·) ((raise'_sorted _ _).imp (@le_of_lt _ _)), lower_raise']
simp
rw [add_assoc, add_assoc, add_left_cancel_iff]
refine' Multiset.induction _ _ s
· exact fun _ => (Acc.intro 0) fun s h => (not_cut_expand_zero s h).elim
· intro a s ih hacc
    rw [← s.singleton_add a]
    exact
      ((hacc a <| s.mem_cons_self a).prod_game_add <|
            ih fun a ha => hacc a <| mem_cons_of_mem ha).of_fibration
        _ (cut_expand_fibration r)
infer_instance
simp only [← not_nonempty_iff, nonempty_Prop]
simp only [← not_nonempty_iff, Classical.nonempty_pi, not_forall]
simp only [← not_nonempty_iff, nonempty_sigma, not_exists]
simp only [← not_nonempty_iff, nonempty_psigma, not_exists]
simp only [← not_nonempty_iff, nonempty_subtype, not_exists]
simp only [← not_nonempty_iff, nonempty_prod, not_and_or]
simp only [← not_nonempty_iff, nonempty_pprod, not_and_or]
simp only [← not_nonempty_iff, nonempty_sum, not_or]
simp only [← not_nonempty_iff, nonempty_psum, not_or]
simp only [← not_nonempty_iff, nonempty_ulift]
simp only [← not_nonempty_iff, nonempty_plift]
rw [iterate_succ, ihn, comp.left_id]
rw [Nat.add_succ, iterate_succ, iterate_succ, iterate_add]
rw [iterate_add]
simp only [Nat.mul_zero, iterate_zero]
simp only [Nat.mul_succ, Nat.mul_one, iterate_one, iterate_add, iterate_mul n]
rw [iterate_succ_apply, h, ihn]
simp only [iterate_succ_apply, hx, (h.iterate_left n).Eq, ihn, ((refl g).iterate_right n).Eq]
rw [iterate_succ, (commute.self_iterate f n).comp_eq]
rw [iterate_succ']
rw [← iterate_succ, Nat.succ_pred_eq_of_pos hn]
rw [← iterate_succ', Nat.succ_pred_eq_of_pos hn]
rw [iterate_succ']
exact h _
rw [iterate_succ', iterate_succ]
exact ihn.comp hg
rw [Nat.mul_comm]
rw [length_cons, foldr, foldr_const l, iterate_succ_apply']
rw [comp_app, h.eq, h'.eq]
simp only [comp_app, hab.eq, hbc.eq]
rw [← hb (f (ga' x)), ← h.eq, ha x]
simp only [hf'.eq, hf.eq, comp_app]
simp only [← h.eq, @IsAssociative.assoc _ ga]
simp only [h.eq, @IsAssociative.assoc _ gb]
simp only [← h.eq, @IsIdempotent.idempotent _ ga]
rw [h.eq, @IsIdempotent.idempotent _ gb]
intro a
exact h a a (HEq.refl a)
funext a
exact type_eq_of_heq (this a)
dsimp only at h
specialize h (fun _ => True) (fun y => ∃ x, f x = y) (funext fun x => _)
· simp only [(· ∘ ·), exists_apply_eq_apply]
· intro y
    have : True = ∃ x, f x = y := congr_fun h y
    rw [← this]
    exact trivial
simp only [cast_cast, cast_eq] at this
assumption
rw [hf (i a), hh a]
rw [h₂.comp_eq_id, comp.right_id]
rw [← comp.assoc, h₁.comp_eq_id, comp.left_id]
rw [partial_inv, dif_pos h'] at h
injection h with h
subst h
apply Classical.choose_spec h'
rw [partial_inv, dif_neg h'] at h <;> contradiction
simp only [inv_fun, dif_pos h, h.some_spec]
rw [hg b]
exact inv_fun_eq ⟨g b, hg b⟩
rw [← and_forall_ne a, update_same]
simp (config := { contextual := true })
rw [← not_forall_not, forall_update_iff f fun a b => ¬p a b]
simp [not_and_or]
simp [update_eq_iff]
simp [eq_update_iff]
funext c
simp only [update]
funext b
unfold extend
congr
simp only [extend_def, dif_pos, exists_apply_eq_apply]
exact hf (Classical.choose_spec (exists_apply_eq_apply f a))
simp [Function.extend_def, hb]
simp only [comp_app, hf.extend_apply]
rw [Classical.choose_spec h, comp_apply, hf]
intro g₁ g₂ hg
refine' funext fun x => _
have H := congr_fun hg (f x)
simp only [hf.extend_apply] at H
exact H
simp only [comp_app, hf.extend_apply e']
simp only [comp.assoc g _ f, (left_inverse_surj_inv hf).comp_eq_id, comp.right_id]
rw [apply_ite f, h, ite_not]
rw [h]
rw [h]
rw [← encodek, e, encodek]
simp [Encodable.encodek, linv]
simp
cases o <;> dsimp <;> simp [encodek, Nat.succ_ne_zero]
simp [decode₂] <;> exact ⟨fun ⟨_, h₁, rfl, h₂⟩ => ⟨h₁, h₂⟩, fun ⟨h₁, h₂⟩ => ⟨_, h₁, rfl, h₂⟩⟩
rw [← decode₂_is_partial_inv (Option.get h), Option.some_get]
rw [← hn, encodek₂] <;> exact rfl
dsimp <;> rw [← Option.some_inj, Option.some_get, encodek₂]
apply Subtype.eq
dsimp
conv => 
      rhs
      rw [← hx]
rw [encode_injective.eq_iff, ← Option.some_inj, Option.some_get, ← hx, encodek₂]
cases s <;> simp [encode_sum, decode_sum, encodek] <;> rfl
change (decode_sum n).map _ = none
rw [this]
rfl
decide
simp [encode_sigma, decode_sigma, unpair_mkpair, encodek]
cases n.unpair <;> rfl
simp <;> cases decode α n.unpair.1 <;> simp <;> cases decode β n.unpair.2 <;> rfl
simp [encode_subtype, decode_subtype, encodek, h]
cases a <;> rfl
cases n <;> unfold good <;> infer_instance
simp [good, encodek, pw]
simp only [Directed.sequence, encodek]
exact (Classical.choose_spec (hf _ a)).2
rw [supr_comm]
simp [mem_decode₂]
simp
apply H0
intro a b
cases a
cases b
congr
have : x = y := Subsingleton.elim _ _
cases this
rfl
cases h₂
cases h₁
rfl
rw [h]
rw [h]
rw [← h]
rw [h]
rw [h]
rw [h]
simp only [ha, true_and_iff, true_imp_iff]
simp only [ha, false_or_iff, false_and_iff, false_imp_iff]
simp [Xor']
simp [Xor']
simp [Xor']
simp [Xor', or_comm', and_comm']
simp only [and_left_comm, and_comm]
rw [← and_assoc', @and_right_comm a, and_assoc']
rw [and_and_and_comm, and_self_iff]
rw [and_and_and_comm, and_self_iff]
simp only [and_left_comm, and_comm]
rw [@Iff.comm p, and_iff_left_iff_imp]
rw [and_comm', iff_self_and]
simp [ha] at h <;> exact h
simp only [and_comm, ← and_congr_right_iff]
rw [or_assoc', or_assoc', or_comm' b]
rw [← or_assoc', @or_right_comm a, or_assoc']
rw [or_or_or_comm, or_self_iff]
rw [or_or_or_comm, or_self_iff]
simp only [or_left_comm, or_comm]
rw [Decidable.or_iff_not_imp_right, Decidable.or_iff_not_imp_right]
exact imp_congr_right h
rw [Decidable.or_iff_not_imp_left, Decidable.or_iff_not_imp_left]
exact imp_congr_right h
rw [or_comm', or_iff_left_iff_imp]
simp [Decidable.imp_iff_not_or, or_comm, or_left_comm]
rw [@iff_def ¬a, @iff_def' a] <;> exact decidable.not_imp_not.and Decidable.not_imp_not
rw [@iff_def ¬a, @iff_def ¬b] <;> exact decidable.not_imp_comm.and imp_not_comm
intro h <;> cases h <;> simp only [h, iff_true_iff, iff_false_iff]
rw [@iff_def a, @iff_def b] <;> exact imp_not_comm.and Decidable.not_imp_comm
rw [iff_iff_implies_and_implies a b]
simp only [Decidable.imp_iff_not_or, or_comm]
rw [← not_or, Decidable.not_not]
rw [← Decidable.not_and_distrib, Decidable.not_not]
simp only [not_and, Xor', not_or, not_not, ← iff_iff_implies_and_implies]
simp only [← @xor_not_right a, not_not]
simp only [← @xor_not_left _ b, not_not]
have : p = q := propext ⟨fun _ => hq, fun _ => hp⟩
subst q <;> rfl
cases h
rfl
cases h <;> rfl
subst Eq <;> exact h
subst h₁
subst h₂
rw [h]
rw [h]
subst hx
subst hy
simp [Decidable.not_not]
simp
simp [and_comm']
simp [@eq_comm _ a']
simp only [← @forall_eq _ p a, ← forall_and, ← or_imp, Classical.em, forall_const]
simp only [or_imp, forall_and, forall_eq]
simp only [eq_comm, ExistsUnique, and_self_iff, forall_eq', exists_eq']
simp only [ExistsUnique, and_self_iff, forall_eq', exists_eq']
rw [forall_swap]
simp
simp [@eq_comm _ _ (f _)]
rw [forall_swap]
simp
simp [@eq_comm _ a']
simp [@eq_comm _ a']
simp only [@exists_comm (κ₁ _), @exists_comm ι₁]
simp [or_comm', Decidable.forall_or_left]
simp
simp only [exists_unique_iff_exists] at h₂
apply h₂.elim
exact fun x ⟨hxp, hxq⟩ H => h₁ x hxp hxq fun y hyp hyq => H y ⟨hyp, hyq⟩
simp only [exists_unique_iff_exists]
exact ExistsUnique.intro w ⟨hp, hq⟩ fun y ⟨hyp, hyq⟩ => H y hyp hyq
simp only [exists_unique_iff_exists] at h
exact h.unique ⟨hpy₁, hqy₁⟩ ⟨hpy₂, hqy₂⟩
infer_instance
infer_instance
infer_instance
infer_instance
simp only [exists_prop, exists_eq_left]
simp
simp only [exists_prop] <;> exact Iff.trans (exists_congr fun x => or_and_right) exists_or
rw [exists_prop, exists_prop]
rw [ne_comm]
simp only [Ne.def, dite_eq_right_iff, not_forall]
rw [exists_prop]
rw [exists_prop]
rw [dif_neg (h p), dif_pos p]
funext a b <;> exact iff_eq_eq
  rw [this, eq_comp]
funext a b <;> exact iff_eq_eq
  rw [this, comp_eq]
funext a d
apply propext
constructor
exact fun ⟨c, ⟨b, hab, hbc⟩, hcd⟩ => ⟨b, hab, c, hbc, hcd⟩
exact fun ⟨b, hab, c, hbc, hcd⟩ => ⟨c, ⟨b, hab, hbc⟩, hcd⟩
funext c a
apply propext
constructor
exact fun ⟨b, hab, hbc⟩ => ⟨b, hbc, hab⟩
exact fun ⟨b, hbc, hab⟩ => ⟨b, hab, hbc⟩
rfl
rfl
induction hbc
case refl => assumption
case tail c d hbc hcd hac => exact hac.tail hcd
induction hbc
case refl => exact refl.tail hab
case tail c d hbc hcd hac => exact hac.tail hcd
induction h generalizing P
case refl => exact refl
case tail b c hab hbc ih => 
    apply ih
    show P b _; exact head hbc _ refl
    show ∀ a a', r a a' → refl_trans_gen r a' b → P a' _ → P a _
    exact fun a a' hab hbc => head hab _
induction h
case refl => exact ih₁ a
case tail b c hab hbc ih => exact ih₃ hab (single hbc) ih (ih₂ hbc)
induction hbc
case refl => assumption
case tail c d hbc hcd hac => exact hac.tail hcd
induction hab generalizing c
case refl c hac => exact single hac
case tail d b hab hdb IH => exact tail (IH hdb) hbc
induction h generalizing P
case single a h => exact base h
case tail b c hab hbc h_ih => 
    apply h_ih
    show ∀ a, r a b → P a _; exact fun a h => ih h (single hbc) (base hbc)
    show ∀ a a', r a a' → trans_gen r a' b → P a' _ → P a _; exact fun a a' hab hbc => ih hab _
induction h
case single a h => exact base h
case tail b c hab hbc h_ih => exact ih hab (single hbc) h_ih (base hbc)
induction hbc
case single c hbc => exact tail' hab hbc
case tail c d hbc hcd hac => exact hac.tail hcd
rfl
rfl
induction h
case single c hc => exact hc
case tail c d hac hcd hac => exact trans hac hcd
induction hab
case single c hac => exact trans_gen.single (h a c hac)
case tail c d hac hcd hac => exact trans_gen.tail hac (h c d hcd)
rw [cases_head_iff] <;> simp [h, eq_comm]
intro h
induction h
case rel => assumption
case refl => exact h.1 _
case symm => apply h.2.1; assumption
case trans a b c _ _ hab hbc => exact h.2.2 hab hbc
induction h
case rel a b h => exact EqvGen.rel _ _ (hrp _ _ h)
case refl => exact EqvGen.refl _
case symm a b h ih => exact EqvGen.symm _ _ ih
case trans a b c ih1 ih2 hab hbc => exact EqvGen.trans _ _ _ hab hbc
simp
apply of_nat_of_decode <;> show Option.map _ _ = _ <;> simp
cases n
· refine' ⟨none, _, encode_none⟩
      rw [decode_option_zero, Option.mem_def]
refine' ⟨some (of_nat α n), _, _⟩
· rw [decode_option_succ, decode_eq_of_nat, Option.map_some', Option.mem_def]
rw [encode_some, encode_of_nat]
simp
rw [← decode_eq_of_nat, decode_sigma_val] <;> simp <;> rfl
simp <;> rfl
simp [-Multiset.range_succ]
rw [hk] <;> exact add_le_add_right (add_le_add_left this _) _
simp
simp [List.mem_filter, Subtype.ext_iff_val, t] <;> intros <;> rfl
rw [← List.maximum_eq_none.1 hmax, hmt] <;> exact h
rw [ha] <;> exact wf _ hmax
rw [ha] <;> cases m <;> exact List.le_maximum_of_mem (hmt.2 hz) hmax
rw [Set.range_comp coe, of_nat_range, Set.image_univ, Subtype.range_coe]
rw [to_fun_aux, List.countp_eq_length_filter] <;> rfl
simp
simp only [h.2, and_true_iff] <;>
            exact Or.symm (lt_or_eq_of_le ((@lt_succ_iff_le _ _ _ ⟨m, h.2⟩ _).1 h.1))
cases nonempty_denumerable α
cases nonempty_denumerable β
exact ⟨(Denumerable.eqv _).trans (Denumerable.eqv _).symm⟩
simp
rw [(CompleteLattice.well_founded_characterisations <| Submodule R M).out 0 3]
exact
    ⟨fun ⟨h⟩ => fun k => (fg_iff_compact k).mp (h k), fun h =>
      ⟨fun k => (fg_iff_compact k).mpr (h k)⟩⟩
rw [Finset.coe_singleton]
rw [is_noetherian_iff_well_founded, WellFounded.wellFounded_iff_has_max']
rw [is_noetherian_iff_well_founded, WellFounded.monotone_chain_condition]
intro a b
rw [span_le_span_iff hs (this a) (this b),
      Set.image_subset_image_iff (subtype.coe_injective.comp f.injective), Set.subset_def]
exact ⟨fun hab x (hxa : x ≤ a) => le_trans hxa hab, fun hx => hx a (le_refl a)⟩
simp (config := { contextual := true }) [le_antisymm_iff, (this _ _).symm]
simp [Submodule.map_comap_eq, inf_comm]
simp [Submodule.comap_map_eq, h]
rw [Set.Finite.coe_to_finset, Submodule.span_eq]
rw [is_noetherian_iff_well_founded] at h⊢
exact OrderEmbedding.wellFounded (Submodule.MapSubtype.orderEmbedding N).dual h
rw [is_noetherian_iff_well_founded] at h⊢
exact OrderEmbedding.wellFounded (Submodule.ComapMkq.orderEmbedding N).dual h
rw [is_noetherian_iff_well_founded] at h⊢
refine' (Submodule.restrictScalarsEmbedding R S M).dual.WellFounded h
infer_instance
rw [is_noetherian_ring_iff, is_noetherian_iff_well_founded] at H⊢
exact OrderEmbedding.wellFounded (Ideal.orderEmbeddingOfSurjective f hf).dual H
simp only [hq x hx, hp x hx, add_zero, RingHom.map_add]
simp only [hq x hx, Algebra.id.smul_eq_mul, mul_zero, RingHom.map_mul]
simp
intro p hp x hx
rw [← mem_vanishing_ideal_singleton_iff]
rw [radical_eq_Inf] at hp
refine'
    (mem_Inf.mp hp)
      ⟨le_trans (le_vanishing_ideal_zero_locus I)
          (vanishing_ideal_anti_mono fun y hy => hy.symm ▸ hx),
        is_maximal.is_prime' _⟩
infer_instance
infer_instance
infer_instance
simp only [span_singleton_one, Units.mul_inv', span_singleton_mul_span_singleton]
simp only [span_singleton_one, Units.inv_mul', span_singleton_mul_span_singleton]
simp only [Units.val_mk, Units.val_mul, span_singleton_mul_span_singleton]
simp only [span_singleton_one, Units.val_mk, Units.val_one]
rw [ClassGroup.mk, MonoidHom.comp_apply, ← MonoidHom.comp_apply (Units.map _), ← Units.map_comp, ←
      RingEquiv.coe_monoid_hom_trans, FractionalIdeal.canonical_equiv_trans_canonical_equiv] <;>
    rfl
simp
simp
simp only [FractionalIdeal.coe_mk0, coe_coe, FractionalIdeal.canonical_equiv_coe_ideal]
rw [ClassGroup.mk0, MonoidHom.comp_apply, ← ClassGroup.mk_canonical_equiv K (FractionRing R),
    FractionalIdeal.map_canonical_equiv_mk0]
rw [← hx, coe_span_singleton]
apply Subtype.coe_injective
rw [hx, coe_span_singleton]
apply h.equiv.injective
refine' (h.equiv.apply_symm_apply _).trans _
simp
delta IsTensorProduct.lift
simp
delta IsTensorProduct.map
simp
rw [h.equiv.symm_apply_eq, h.equiv_tmul, one_smul]
refine' { f' with map_smul' := fun r x => _ }
apply TensorProduct.induction_on x
· simp only [map_zero, smul_zero, LinearMap.to_fun_eq_coe]
· intro x y
      simp only [Algebra.of_id_apply, Algebra.id.smul_eq_mul, AlgHom.to_linear_map_apply,
        LinearMap.mul_apply, TensorProduct.lift.tmul', LinearMap.smul_apply, RingHom.id_apply,
        Module.algebra_map_End_apply, f', _root_.map_mul, TensorProduct.smul_tmul',
        LinearMap.coe_restrict_scalars_eq_coe, LinearMap.flip_apply]
· intro x y hx hy
      dsimp at hx hy⊢
      simp only [hx, hy, smul_add, map_add]
refine' (hg₂ _ _).symm
rfl
intros
exact ⟨h.lift g, h.lift_comp g, fun g' e => h.alg_hom_ext' _ _ (e.trans (h.lift_comp g).symm)⟩
rw [Algebra.smul_def, mul_smul]
rfl
rw [f.map_smul, smul_mul_assoc]
rw [Algebra.pushout_desc_apply, Algebra.algebra_map_eq_smul_one, LinearMap.map_smul, ←
    Algebra.pushout_desc_apply S' f g H, _root_.map_one]
exact mul_one (f x)
rw [h.algebra_map_eq, RingHom.comp_apply]
rw [h.ker_map, Ideal.mem_span_singleton]
rw [← h.mem_ker_map, RingHom.mem_ker]
rw [aeval_C, h.algebra_map_apply]
rw [AlgHom.map_add, RingHom.map_add, ihp, ihq]
rw [AlgHom.map_mul, aeval_C, AlgHom.map_pow, aeval_X, RingHom.map_mul, ← h.algebra_map_apply,
      RingHom.map_pow, map_X]
rw [aeval_eq, map_self]
rw [← h.ker_map, RingHom.mem_ker, h.map_repr]
rw [← h.ker_map, RingHom.mem_ker, map_sub, h.map_repr, map_add, h.map_repr, h.map_repr, sub_self]
cases h
cases h'
congr
exact RingHom.ext Eq
rw [← h.aeval_eq, ← h'.aeval_eq, Eq]
rw [h.eval₂_repr_eq_eval₂_of_map_eq hx _ _ (map_zero _), eval₂_zero]
rw [h.eval₂_repr_eq_eval₂_of_map_eq hx _ (h.repr z + h.repr w), eval₂_add]
· rw [map_add, map_repr, map_repr]
rw [h.eval₂_repr_eq_eval₂_of_map_eq hx _ _ (map_one _), eval₂_one]
rw [h.eval₂_repr_eq_eval₂_of_map_eq hx _ (h.repr z * h.repr w), eval₂_mul]
· rw [map_mul, map_repr, map_repr]
rw [lift, RingHom.coe_mk, h.eval₂_repr_eq_eval₂_of_map_eq hx _ _ rfl]
rw [← h.map_X, lift_map, eval₂_X]
rw [h.algebra_map_apply, lift_map, eval₂_C]
rw [← h.map_repr a, Polynomial.as_sum_range_C_mul_X_pow (h.repr a)]
simp only [map_sum, map_mul, map_pow, h.map_X, hroot, ← h.algebra_map_apply, hmap, lift_root,
    lift_algebra_map]
rw [← lift_algebra_map_apply, lift_map, aeval_def]
rw [← lift_algebra_map_apply, lift_root]
rw [← h.mem_ker_map, RingHom.sub_mem_ker_iff, map_repr]
simp only [map_add, Finsupp.comap_domain_add_of_injective Fin.coe_injective, to_finsupp_add]
simp only [map_smul, Finsupp.comap_domain_smul_of_injective Fin.coe_injective,
          RingHom.id_apply, to_finsupp_smul]
rw [h.basis_apply, Fin.coe_mk, pow_one]
simp only [coeff, LinearMap.comp_apply, Finsupp.lcoe_fun_apply, Finsupp.lmap_domain_apply,
    LinearEquiv.coe_coe, lift_polyₗ_apply, LinearMap.coe_mk, h.basis_repr]
rfl
rw [h.basis_apply, Fin.coe_mk]
rw [h.basis.repr_self, ← Finsupp.single_eq_pi_single,
          Finsupp.single_apply_left Fin.coe_injective]
rw [Fin.coe_mk, Fin.coe_mk]
rw [← h.coeff_root_pow h.deg_pos, pow_zero]
rw [← h.coeff_root_pow hdeg, pow_one]
simp
rw [Basis.equiv_fun_apply, ← h.coeff_apply_coe, Basis.equiv_fun_apply, ← h.coeff_apply_coe,
          hxy i i.prop]
rw [← h.map_repr x, lift_map, ← aeval_def, h.aeval_eq]
rw [← h.map_repr x, lift_hom_map, aeval_eq, lift_hom_map, aeval_eq]
rw [← h'.map_repr x, lift_hom_map, aeval_eq, lift_hom_map, aeval_eq]
rw [aequiv, AlgEquiv.coe_mk, lift_hom_map, aeval_eq]
rw [aequiv, AlgEquiv.coe_mk, lift_hom_root]
rw [← h.map_repr z, aequiv_map, lift_map, lift_map]
rw [← RingHom.comap_ker, RingHom.ker_coe_equiv, ← RingHom.ker_eq_comap_bot, h.ker_map]
subst hdeg <;> subst hnum
subst hdeg <;> subst hdenom
induction y using Quotient.induction_on
unfold HomogeneousLocalization.val HasSmul.smul
simp only [Quotient.liftOn₂'_mk, Quotient.liftOn'_mk]
change Localization.mk _ _ = n
change Localization.mk _ _ = Localization.mk _ _
simp only [num_neg, denom_neg, ← Localization.neg_mk]
exact congr_arg (fun c => -c) h
induction y1 using Quotient.induction_on
induction y2 using Quotient.induction_on
unfold HomogeneousLocalization.val Add.add
simp only [Quotient.liftOn₂'_mk, Quotient.liftOn'_mk]
change Localization.mk _ _ = Localization.mk _ _ + Localization.mk _ _
dsimp only
rw [Localization.add_mk]
rfl
induction y1 using Quotient.induction_on
induction y2 using Quotient.induction_on
unfold HomogeneousLocalization.val Mul.mul
simp only [Quotient.liftOn₂'_mk, Quotient.liftOn'_mk]
change Localization.mk _ _ = Localization.mk _ _ * Localization.mk _ _
dsimp only
rw [Localization.mk_mul]
rfl
induction y using Quotient.induction_on
unfold HomogeneousLocalization.val Neg.neg
simp only [Quotient.liftOn₂'_mk, Quotient.liftOn'_mk]
change Localization.mk _ _ = -Localization.mk _ _
dsimp only
rw [Localization.neg_mk]
rfl
rw [show y1 - y2 = y1 + -y2 from rfl, add_val, neg_val] <;> rfl
induction y using Quotient.induction_on
unfold HomogeneousLocalization.val Pow.pow
simp only [Quotient.liftOn₂'_mk, Quotient.liftOn'_mk]
change Localization.mk _ _ = Localization.mk _ _ ^ n
rw [Localization.mk_pow]
dsimp only
congr 1
induction n <;> simp [Nat.unaryCast, zero_val, one_val, *]
cases n <;> simp [Int.castDef, zero_val, one_val, *]
erw [Localization.mk_self 1]
simp only [ext_iff_val, mul_val, one_val] at eq1 eq2
exact ⟨⟨f.val, b.val, eq1, eq2⟩, rfl⟩
simp only [← is_unit_iff_is_unit_val, sub_val, one_val]
induction a using Quotient.inductionOn'
simp only [HomogeneousLocalization.val_mk', ← Subtype.val_eq_coe]
rw [GradedRing.proj_apply, decompose_symm_of, Equiv.apply_symm_apply]
rw [GradedAlgebra.proj_apply, decompose_symm_of, Equiv.apply_symm_apply]
rw [decompose_zero]
rfl
rw [decompose_add]
rfl
intro x y hxy
simp only [add_sum_erase, mem_filter, mem_product]
exact ⟨⟨mem_of_mem_filter _ mem_max₁, mem_of_mem_filter _ mem_max₂⟩, rfl⟩
rw [mem_filter] at mem_max₁ mem_max₂
exact ⟨mem_max₁.2, mem_max₂.2⟩
rw [h.radical_eq]
exact Ideal.IsHomogeneous.Inf fun _ => And.left
simp [h]
rw [Subtype.image_preimage_coe] at h
exact h.2
rw [Ideal.IsHomogeneous.iff_eq, eq_comm]
exact ((set.image_preimage.compose (Submodule.gi _ _).gc).exists_eq_l _).symm
simp only [Ideal.mem_bot] at hr
rw [hr, decompose_zero, zero_apply]
apply Ideal.zero_mem
simp only [Submodule.mem_top]
intro i x hx
simp only [Ideal.mem_infi] at hx⊢
exact fun j => h _ _ (hx j)
rw [Sup_eq_supr]
exact supr₂ h
rw [Inf_eq_infi]
exact infi₂ h
rw [supr, to_ideal_Sup, supr_range]
rw [infi, to_ideal_Inf, infi_range]
change (decompose 𝒜 (decompose 𝒜 r _ : A) 0 : A) = 0
simp [Submodule.map_comap_eq, inf_comm]
simp [Submodule.comap_map_eq, h]
intro α β e hα M _ _ _ _
exact is_artinian_of_linear_equiv (LinearEquiv.piCongrLeft R M e)
intro M _ _ _ _
infer_instance
intro α _ ih M _ _ _ _
exact is_artinian_of_linear_equiv (LinearEquiv.piOptionEquivProd R).symm
intro a b
rw [span_le_span_iff hs (this b) (this a),
      Set.image_subset_image_iff (subtype.coe_injective.comp f.injective), Set.subset_def]
simp only [Set.mem_setOf_eq]
exact ⟨fun hab x => le_trans hab, fun h => h _ le_rfl⟩
simp (config := { contextual := true }) [le_antisymm_iff, (this _ _).symm]
rw [is_artinian_iff_well_founded, WellFounded.wellFounded_iff_has_min']
rw [is_artinian_iff_well_founded]
exact well_founded.monotone_chain_condition.symm
rw [← w]
exact mem_range_self _
dsimp at hy⊢
rw [← smul_assoc, smul_eq_mul, ← pow_add, ← hy, add_tsub_cancel_of_le h]
infer_instance
rw [is_artinian_iff_well_founded] at h⊢
refine' (Submodule.restrictScalarsEmbedding R S M).WellFounded h
rw [is_artinian_ring_iff, is_artinian_iff_well_founded] at H⊢
exact (Ideal.orderEmbeddingOfSurjective f hf).WellFounded H
rw [pow_succ, ← mul_assoc]
simp [J]
rw [IsLocalization.mk'_eq_mul_mk'_one, map_mul, h]
rw [content]
rw [← C_0, content_C, normalize_zero]
rw [← C_1, content_C, normalize_one]
rw [← mul_one X, content_X_mul, content_one]
rw [← C_mul_X_pow_eq_monomial, content_C_mul, content_X_pow, mul_one]
rw [C_dvd_iff_dvd_coeff]
constructor
· intro h i
    apply h.trans (content_dvd_coeff _)
· intro h
    rw [content, Finset.dvd_gcd_iff]
    intro i hi
    apply h i
rw [← one_mul p.prim_part, ← C_1, ← hp.content_eq_one, ← p.eq_C_content_mul_prim_part]
rw [← RingHom.map_mul, Units.inv_mul, C_1]
rw [← RingHom.map_mul, Units.mul_inv, C_1]
rw [gcd_comm (content _) _, gcd_comm (content _) _]
apply gcd_content_eq_of_dvd_sub
rw [← self_sub_C_mul_X_pow, ← self_sub_C_mul_X_pow, sub_mul, sub_sub, add_comm, sub_add,
    sub_sub_cancel, leading_coeff_mul, RingHom.map_mul, mul_assoc, mul_assoc]
apply dvd_sub (Dvd.intro _ rfl) (Dvd.intro _ rfl)
rw [is_primitive_iff_content_eq_one, content_mul, hp.content_eq_one, hq.content_eq_one, mul_one]
rw [gcd_comm]
exact degree_gcd_le_left hq p
rw [h, Polynomial.map_mul]
simp
rw [← dvd_dvd_iff_associated, ← normalize_eq_normalize_iff, normalize.map_mul,
      normalize.map_mul, normalize_content, normalize_content, ←
      mul_one (normalize c * normalize d), ← hp.content_eq_one, ← content_C, ← content_C, ←
      content_mul, ← content_mul, ← content_mul, h1]
simp (config := { contextual := true }) [scale_roots, coeff_monomial]
rw [leading_coeff, coeff_scale_roots, tsub_self, pow_zero, mul_one]
intro h
have : p.coeff p.nat_degree ≠ 0 := mt leading_coeff_eq_zero.mp hp
have : (scale_roots p s).coeff p.nat_degree = 0 :=
    congr_fun (congr_arg (coeff : R[X] → ℕ → R) h) p.nat_degree
rw [coeff_scale_roots_nat_degree] at this
contradiction
intro i
simp only [coeff_scale_roots, Polynomial.mem_support_iff]
intro p_ne_zero ps_zero
have := pow_mem hs (p.nat_degree - i) _ ps_zero
contradiction
simp only [nat_degree, degree_scale_roots]
simp only [monic, leading_coeff, nat_degree_scale_roots, coeff_scale_roots_nat_degree]
simp [eval₂_eq_sum, sum_def]
rw [mul_assoc, mul_left_comm, tsub_add_cancel_of_le]
exact le_nat_degree_of_ne_zero (polynomial.mem_support_iff.mp hi)
simp [eval₂_eq_sum, sum_def]
rw [scale_roots_eval₂_mul, hr, _root_.mul_zero]
apply is_root_of_eval₂_map_eq_zero (IsFractionRing.injective A K)
refine' scale_roots_aeval_eq_zero_of_aeval_mk'_eq_zero _
rw [mk'_num_denom]
exact hr
refine'
      dvd_of_dvd_mul_left_of_no_prime_factors (mem_non_zero_divisors_iff_ne_zero.mp (denom A r).2) _
        this
intro q dvd_denom dvd_num_pow hq
apply hq.not_unit
exact num_denom_reduced A r (hq.dvd_of_dvd_pow dvd_num_pow) dvd_denom
simp only [cyclotomic', Finset.prod_empty, primitive_roots_zero]
simp only [cyclotomic', Finset.prod_singleton, RingHom.map_one,
    IsPrimitiveRoot.primitive_roots_one]
simp only [Finset.eq_singleton_iff_unique_mem, mem_primitive_roots two_pos]
exact ⟨IsPrimitiveRoot.neg_one p hp, fun x => IsPrimitiveRoot.eq_neg_one_of_two_right⟩
rw [cyclotomic']
rw [nat_degree_prod (primitiveRoots n R) fun z : R => X - C z]
simp only [IsPrimitiveRoot.card_primitive_roots h, mul_one, nat_degree_X_sub_C, Nat.cast_id,
    Finset.sum_const, nsmul_eq_mul]
intro z hz
exact X_sub_C_ne_zero z
simp only [degree_eq_nat_degree (cyclotomic'_ne_zero n R), nat_degree_cyclotomic' h]
rw [cyclotomic']
exact roots_prod_X_sub_C (primitiveRoots n R)
apply splits_prod (RingHom.id K)
intro z hz
simp only [splits_X_sub_C (RingHom.id K)]
rw [splits_iff_card_roots, ← nth_roots, IsPrimitiveRoot.card_nth_roots h, nat_degree_X_pow_sub_C]
have hd : (n.divisors : Set ℕ).PairwiseDisjoint fun k => primitiveRoots k K :=
    fun x hx y hy hne => IsPrimitiveRoot.disjoint hne
simp only [X_pow_sub_one_eq_prod hpos h, cyclotomic', ← Finset.prod_bUnion hd,
    h.nth_roots_one_eq_bUnion_primitive_roots]
apply monic_prod_of_monic
intro i hi
exact cyclotomic'.monic i K
rw [mul_comm]
apply monic_prod_of_monic
intro i hi
exact cyclotomic'.monic i K
constructor
· rw [zero_add, mul_comm, ← prod_cyclotomic'_eq_X_pow_sub_one hpos h,
        Nat.divisors_eq_proper_divisors_insert_self_of_pos hpos]
      simp only [true_and_iff, Finset.prod_insert, not_lt, Nat.mem_proper_divisors, dvd_refl]
rw [degree_zero, bot_lt_iff_ne_bot]
intro habs
exact (monic.ne_zero Bmo) (degree_eq_bot.1 habs)
apply map_injective (Int.castRingHom ℂ) Int.cast_injective
rw [h, (int_cyclotomic_spec n).1]
rw [← map_cyclotomic_int n R, ← map_cyclotomic_int n S, map_map]
congr
rw [← map_cyclotomic n f, eval_map, eval₂_at_apply]
simp only [cyclotomic, dif_pos]
simp only [cyclotomic'_one, PNat.one_coe, map_X, Polynomial.map_one, Polynomial.map_sub]
rw [← map_cyclotomic_int]
exact (int_cyclotomic_spec n).2.2.map _
rw [nat_degree, degree_cyclotomic, WithBot.unbot'_coe]
apply map_injective (Int.castRingHom ℂ) Int.cast_injective
simp only [Polynomial.map_prod, int_cyclotomic_spec, Polynomial.map_pow, map_X,
      Polynomial.map_one, Polynomial.map_sub]
exact prod_cyclotomic'_eq_X_pow_sub_one hpos (Complex.is_primitive_root_exp n hpos.ne')
rw [cyclotomic_prime, geom_sum_mul]
simp [cyclotomic_prime]
simp [cyclotomic_prime, sum_range_succ']
rw [← mem_nth_roots h, nth_roots, mem_roots <| X_pow_sub_C_ne_zero h _, C_1, ←
      prod_cyclotomic_eq_X_pow_sub_one h, is_root_prod] <;>
    infer_instance
intro n hn
rw [← prod_cyclotomic_eq_X_pow_sub_one hn R, RingHom.map_prod]
apply monic_prod_of_monic
intro i hi
exact cyclotomic.monic i R
rw [mul_comm]
rw [is_root_of_unity_iff hnpos]
exact ⟨n, n.mem_divisors_self hnpos.ne', hμ⟩
apply order_of_pos'
rw [is_of_fin_order_iff_pow_eq_one]
exact ⟨n, hnpos, hμn⟩
rw [← cyclotomic.roots_to_finset_eq_primitive_roots]
apply monic_prod_of_monic
intro i hi
exact cyclotomic.monic i R
intro m
have := eq_cyclotomic_iff (pow_pos hp.pos (m + 1)) _
rw [eq_comm] at this
rw [this, Nat.prod_proper_divisors_prime_pow hp]
rw [cyclotomic_prime_pow_eq_geom_sum hn.out, geom_sum_mul, ← pow_mul, pow_succ, mul_comm]
intro j hj
apply Nat.succ_le_of_lt
exact
        (Ne.le_iff_lt (Finset.mem_erase.1 hj).1.symm).mp
          (Nat.succ_le_of_lt (Nat.pos_of_mem_proper_divisors (Finset.mem_erase.1 hj).2))
intro j hj
exact hi j (Nat.mem_proper_divisors.1 (Finset.mem_erase.1 hj).2).2 (hleq j hj)
rw [Finset.prod_congr (refl (n.proper_divisors.erase 1)) hcongr]
simp only [Finset.prod_const_one]
rw [← prod_cyclotomic_eq_X_pow_sub_one (lt_of_lt_of_le zero_lt_two hn),
      Nat.divisors_eq_proper_divisors_insert_self_of_pos (lt_of_lt_of_le zero_lt_two hn),
      Finset.prod_insert Nat.properDivisors.not_self_mem, mul_coeff_zero, coeff_zero_prod, hprod,
      mul_neg, mul_one]
rw [coeff_zero_eq_eval_zero _]
simp only [zero_pow (lt_of_lt_of_le zero_lt_two hn), eval_X, eval_one, zero_sub, eval_pow,
      eval_sub]
rw [← map_cyclotomic_int, cyclotomic_eq_minpoly h hpos]
exact (minpoly.gcd_domain_eq_field_fractions' _ (IsIntegral h hpos)).symm
rw [cyclotomic_eq_minpoly (is_primitive_root_exp n hpos.ne') hpos]
apply minpoly.irreducible
exact (is_primitive_root_exp n hpos.ne').IsIntegral hpos
rw [← map_cyclotomic_int]
exact
    (is_primitive.int.irreducible_iff_irreducible_map_cast (cyclotomic.is_primitive n ℤ)).1
      (cyclotomic.irreducible hpos)
rw [← map_cyclotomic_int, ← map_expand, this, Polynomial.map_mul, map_cyclotomic_int]
simp [h]
rw [← map_cyclotomic_int, ← map_expand, this, map_cyclotomic_int]
rw [← map_cyclotomic _ (algebraMap (Zmod p) R), ← map_cyclotomic _ (algebraMap (Zmod p) R),
      this, Polynomial.map_pow]
rw [← map_cyclotomic _ (algebraMap (Zmod p) R), ← map_cyclotomic _ (algebraMap (Zmod p) R),
      this, Polynomial.map_pow]
rw [pow_one, Nat.sub_self, pow_zero, mul_comm, cyclotomic_mul_prime_eq_pow_of_not_dvd R hm]
rw [← mul_assoc, pow_succ]
simp only [cyclotomic_prime, eval_X, one_pow, Finset.sum_const, eval_pow, eval_finset_sum,
    Finset.card_range, smul_one_eq_coe]
simp
simp only [cyclotomic_prime_pow_eq_geom_sum hn.out, eval_X, one_pow, Finset.sum_const, eval_pow,
    eval_finset_sum, Finset.card_range, smul_one_eq_coe]
simp
decide
decide
simp [hq']
simp [this]
simp [hq']
erw [cyclotomic.eval_apply q n (algebraMap ℝ ℂ)]
simp only [Complex.coe_algebra_map, Complex.of_real_eq_zero]
exact (cyclotomic_pos' n hq').Ne.symm
simp [this]
simp [hhζ]
simp
refine' (is_weakly_eisenstein_at_iff _ _).2 fun n hn => _
rw [coeff_map]
exact mem_map_of_mem _ (hf.mem (lt_of_lt_of_le hn (nat_degree_map_le _ _)))
exact mul_mem_right (x ^ k) 𝓟 this
  rw [is_root.def, eval_eq_sum_range, Finset.range_add_one,
    Finset.sum_insert Finset.not_mem_range_self, Finset.sum_range, hmo.coeff_nat_degree, one_mul]
refine' ⟨fun i hi => _⟩
rw [coeff_scale_roots]
rw [nat_degree_scale_roots, ← tsub_pos_iff_lt] at hi
exact Ideal.mul_mem_left _ _ (Ideal.pow_mem_of_mem P hP _ hi)
cases ne_iff_lt_or_gt.1 hn
· exact hf.mem h
· rw [coeff_eq_zero_of_nat_degree_lt h]
    exact Ideal.zero_mem _
simp
simp
simp
simp
rw [pow_succ]
rw [← deg_K_P, minpoly.gcd_domain_eq_field_fractions' K hBint,
      (minpoly.monic hBint).nat_degree_map (algebraMap R K)]
intro i hi
simp only [mem_range, mem_erase] at hi
rw [hn]
exact le_add_pred_of_pos _ hi.1
refine'
      is_integral_sub (is_integral_mul hzint (IsIntegral.pow hBint _))
        (IsIntegral.sum _ fun i hi => is_integral_smul _ _)
exact adjoin_le_integral_closure hBint (hf _ (aux i hi)).1
rw [pow_zero]
rw [hQ, Algebra.smul_mul_assoc]
intro i hi
rw [← pow_add, ← (hf _ (aux i hi)).2, ← Algebra.smul_def, smul_smul, mul_comm _ p, smul_smul]
rw [algebra_map_eq R K L]
exact (algebraMap K L).Injective.comp (IsFractionRing.injective R K)
induction.
  -- The base case is `dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at`.
  refine' mem_adjoin_of_dvd_coeff_of_dvd_aeval hp.ne_zero (fun i => _) hQ
  refine' Nat.case_strong_induction_on i _ fun j hind => _
  · intro H
    exact dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at hp hBint hQ hzint hei
  · intro hj
    refine' hp.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd _ hndiv
    exact n
    -- Two technical results we will need about `P.nat_degree` and `Q.nat_degree`.
rw [← add_comm 1, ← add_comm 1, add_assoc, add_right_inj, ←
        Nat.add_sub_assoc (Nat.lt_of_succ_lt_succ (mem_range.1 hj)).le, add_comm,
        Nat.add_sub_cancel]
    -- By induction hypothesis we can find `g : ℕ → R` such that
    -- `k ∈ range (j + 1) → Q.coeff k • B.gen ^ k = (algebra_map R L) p * g k • B.gen ^ k`-
simp
simp [bernsteinPolynomial, Nat.choose_eq_zero_of_lt h]
simp [bernsteinPolynomial]
simp [bernsteinPolynomial, h, tsub_tsub_assoc, mul_right_comm]
simp [← flip _ _ _ h, Polynomial.comp_assoc]
cases n
· simp [bernsteinPolynomial]
· rw [Nat.cast_succ]
    apply derivative_succ_aux
simp [bernsteinPolynomial, Polynomial.derivative_pow]
rw [← Nat.succ_le_iff] at h''
rw [← tsub_add_eq_tsub_tsub, add_comm, tsub_add_cancel_of_le h'']
intro w
rw [flip' _ _ _ (tsub_pos_iff_lt.mp (pos_of_gt w)).le]
simp [Polynomial.eval_comp, iterate_derivative_at_0_eq_zero_of_lt R n w]
rw [bernsteinPolynomial.iterate_derivative_at_1 _ _ _ h, Ne.def, neg_one_pow_mul_eq_zero_iff, ←
    Nat.cast_succ, ← pochhammer_eval_cast, ← Nat.cast_zero, Nat.cast_inj]
exact (pochhammer_pos _ _ (Nat.succ_pos ν)).ne'
rw [this]
exact (iterate_derivative_at_1_ne_zero ℚ n k h).symm
induction that the collection of `bernstein_polynomial n ν
rw [add_pow]
simp only [bernsteinPolynomial, mul_comm, mul_assoc, mul_left_comm]
simp
rw [pderiv_X]
rfl
rw [pderiv_X]
rfl
rw [pderiv_X]
rfl
rw [pderiv_X]
rfl
rw [aeval_def, aeval_def, eval₂_map, IsScalarTower.algebra_map_eq R A B]
rw [aeval_def, aeval_def, hom_eval₂, ← IsScalarTower.algebra_map_eq]
rw [aeval_algebra_map_apply, Algebra.algebra_map_eq_smul_one, smul_eq_zero,
    iff_false_intro (one_ne_zero' B), or_false_iff]
rw [aeval_algebra_map_apply, ← (algebraMap A B).map_zero, h.eq_iff]
rw [← map_nat_cast C, ← C_0, C_inj, h]
simp only [degree_le, Submodule.mem_infi, degree_le_iff_coeff_zero, LinearMap.mem_ker] <;> rfl
rw [LinearEquiv.map_eq_zero_iff, Submodule.mk_eq_zero]
simp [frange, eq_comm]
simp [frange, Finset.image_subset_iff]
simp only [← C_1, coeff_C]
intro n hn
simp only [exists_prop, ite_eq_right_iff, not_forall] at hn
simp [hn]
simp only [frange, exists_prop, mem_support_iff, Finset.mem_image, Ne.def]
exact ⟨n, h, rfl⟩
rw [H]
rfl
rw [coeff_map, Algebra.algebra_map_of_subring_apply, coeff_restriction]
simp [degree]
simp [nat_degree]
rw [H]
rfl
simp only [restriction, Finset.sum_empty, support_zero]
simp only [eval₂_eq_sum, Sum, support_restriction, ← @coeff_restriction _ _ p]
rfl
rw [H]
rfl
simp [degree]
simp [nat_degree]
rw [H]
rfl
simp [frange_zero]
simp only [of_subring, coeff_monomial, finset_sum_coeff, mem_support_iff, Finset.sum_ite_eq',
    ite_eq_right_iff, Ne.def, ite_not, not_not, ite_eq_left_iff]
intro h
rw [h]
rfl
rw [← C_mul']
exact I.mul_mem_left _ H
simp [I.add_mem (hf n) (hg n)]
intro a ha
rw [RingHom.comp_apply, quotient.eq_zero_iff_mem]
exact mem_map_of_mem _ ha
intro a ha
rw [← sum_monomial_eq a]
dsimp
rw [eval₂_sum]
refine' Finset.sum_eq_zero fun n hn => _
dsimp
rw [eval₂_monomial (C.comp (Quotient.mk'' I)) X]
refine' mul_eq_zero_of_left (Polynomial.ext fun m => _) (X ^ n)
erw [coeff_C]
simp only [coe_eval₂_ring_hom, eval₂_mul]
simp only [eval₂_add, coe_eval₂_ring_hom]
rw [polynomial_quotient_equiv_quotient_polynomial, RingEquiv.symm_mk, RingEquiv.coe_mk,
    Ideal.Quotient.lift_mk, coe_eval₂_ring_hom, eval₂_eq_eval_map, ← Polynomial.map_map, ←
    eval₂_eq_eval_map, Polynomial.eval₂_C_X]
apply (polynomial_quotient_equiv_quotient_polynomial I).symm.Injective
rw [RingEquiv.symm_apply_apply, polynomial_quotient_equiv_quotient_polynomial_symm_mk]
rw [← C_inj, h]
simp
rw [← constant_coeff_C _ r]
exact h.map _
apply RingHom.congr_fun this
infer_instance
refine' WellFounded.not_lt_min (well_founded_submodule_gt _ _) _ _ _ <;>
                exact ⟨k, rfl⟩
rfl
rw [HN]
exact
                hm2 k
                  ((I.mem_leading_coeff_nth _ _).2
                    ⟨_, hp, hn ▸ Polynomial.degree_le_nat_degree, rfl⟩)
intro H
rw [← Polynomial.leading_coeff_eq_zero] at H
rw [hlqp, Polynomial.leading_coeff_eq_zero] at H
exact hp0 H
rw [Polynomial.degree_mul', Polynomial.degree_X_pow]
rw [Polynomial.degree_eq_nat_degree hp0, Polynomial.degree_eq_nat_degree hq0]
rw [← WithBot.coe_add, add_tsub_cancel_of_le, hn]
· refine' le_trans (Polynomial.nat_degree_le_of_degree_le hdq) (le_of_lt h)
rw [Polynomial.leading_coeff_X_pow, mul_one]
exact mt Polynomial.leading_coeff_eq_zero.1 hq0
rw [← hlqp, Polynomial.leading_coeff_mul_X_pow]
rw [linear_independent_iff]
simp only [Finsupp.total_apply, aeval_endomorphism, forall_iff_forall_finsupp, Sum, support,
    coeff, of_finsupp_eq_zero]
exact Iff.rfl
simp only [LinearMap.mul_apply, aeval_mul]
simp only [LinearMap.mul_apply, aeval_mul]
rw [mul_comm, aeval_mul, LinearMap.mul_apply, LinearMap.mem_ker.1 hx, LinearMap.map_zero]
rw [aeval_mul, LinearMap.mul_apply, LinearMap.mem_ker.1 hy, LinearMap.map_zero]
rw [mul_comm, mul_assoc, mul_comm, mul_assoc, mul_comm q p]
rw [aeval_mul, LinearMap.mul_apply, LinearMap.mem_ker.1 hv, LinearMap.map_zero]
rw [← mul_assoc, mul_comm]
rw [aeval_mul, LinearMap.mul_apply, LinearMap.mem_ker.1 hv, LinearMap.map_zero]
cases nonempty_fintype σ <;>
    exact
      @is_noetherian_ring_of_ring_equiv (MvPolynomial (Fin (Fintype.card σ)) R) _ _ _
        (rename_equiv R (Fintype.equivFin σ).symm).toRingEquiv is_noetherian_ring_fin
apply NoZeroDivisors.toIsDomain _
exact AddMonoidAlgebra.nontrivial
exact MvPolynomial.no_zero_divisors
simp only [Function.comp_apply, RingHom.coe_comp, Ideal.Quotient.eq_zero_iff_mem]
exact Ideal.mem_map_of_mem _ hi
exact Submodule.sum_mem I this
exact I.mul_mem_right (monomial m 1) this
  simpa [Ideal.mem_comap]
simp [I.add_mem (hf n) (hg n)]
exact Submodule.sum_mem _ this
exact Ideal.mul_mem_right _ _ this
rw [← @Ideal.mk_ker R _ I, RingHom.mem_ker] at this
simp only [this, C_0]
simp [h]
erw [Multiset.prod_hom, ← map_mul, hw]
simp [pochhammer]
rw [pochhammer]
rw [← pochhammer_map (algebraMap ℕ S), eval_map, ← eq_nat_cast (algebraMap ℕ S),
    eval₂_at_nat_cast, Nat.cast_id, eq_nat_cast]
cases n
· simp
· simp [X_mul, Nat.succ_ne_zero, pochhammer_succ_left]
simp
simp [pochhammer_eval_zero, h]
rw [pochhammer_succ_right, mul_add, eval_add, eval_mul_X, ← Nat.cast_comm, ← C_eq_nat_cast,
    eval_C_mul, Nat.cast_comm, ← mul_add]
rw [mul_add, add_comp, mul_X_comp, ← Nat.cast_comm, nat_cast_mul_comp, Nat.cast_comm, mul_add]
erw [eval_one] <;> rfl
cases b
· rw [Nat.desc_factorial_zero, pochhammer_zero, Polynomial.eval_one]
rw [Nat.add_succ, Nat.succ_sub_succ, tsub_zero]
cases a
·
    rw [pochhammer_ne_zero_eval_zero _ b.succ_ne_zero, zero_add,
      Nat.desc_factorial_of_lt b.lt_succ_self]
·
    rw [Nat.succ_add, ← Nat.add_succ, Nat.add_desc_factorial_eq_asc_factorial,
      pochhammer_nat_eq_asc_factorial]
simp only [pochhammer_nat_eq_asc_factorial, Nat.succ_asc_factorial, add_right_comm]
rw [T]
simp only [T, sub_left_inj, sq, mul_assoc]
rw [U]
simp only [U_add_two, U_eq_X_mul_U_add_T n, U_eq_X_mul_U_add_T (n + 1)]
simp only [U_add_two, T_add_two]
rw [U_eq_X_mul_U_add_T, add_comm (X * U R n), add_sub_cancel]
simp only [T_eq_X_mul_T_sub_pol_U]
rw [T_add_two _ (n + 1), U_add_two]
rw [T_eq_X_mul_T_sub_pol_U, ← sub_add, sub_self, zero_add]
simp only [T_zero, Polynomial.map_one]
simp only [T_one, map_X]
simp only [T_add_two, Polynomial.map_mul, Polynomial.map_sub, map_X, bit0, Polynomial.map_add,
      Polynomial.map_one]
rw [map_T (n + 1), map_T n]
simp only [U_zero, Polynomial.map_one]
simp only [U_add_two, Polynomial.map_mul, Polynomial.map_sub, map_X, bit0, Polynomial.map_add,
      Polynomial.map_one]
rw [map_U (n + 1), map_U n]
simp only [T_one, U_zero, derivative_X, Nat.cast_zero, zero_add, mul_one]
simp only [T_add_two _ (n + 1), derivative_sub, derivative_mul, derivative_X,
          derivative_bit0, derivative_one, bit0_zero, zero_mul, zero_add, mul_one]
rw [U_add_two]
rw [T_derivative_eq_U]
rw [one_sub_X_sq_mul_U_eq_pol_in_T, T_add_two]
rw [← U_eq_X_mul_U_add_T, ← T_derivative_eq_U, ← Nat.cast_one, ← Nat.cast_add, Nat.cast_one, ←
        T_derivative_eq_U (n + 1)]
rw [h]
simp [two_mul, add_mul]
simp [add_comm]
simp [add_comm, add_assoc]
simp [add_assoc]
simp [add_assoc]
simp
simp
simp [op_ring_equiv]
simp only [op_ring_equiv, RingEquiv.trans_apply, RingEquiv.op_apply_apply,
    RingEquiv.to_add_equiv_eq_coe, AddEquiv.mul_op_apply, [anonymous], AddEquiv.coe_trans,
    op_add_equiv_apply, RingEquiv.coe_to_add_equiv, op_add_equiv_symm_apply, Function.comp_apply,
    unop_op, to_finsupp_iso_apply, to_finsupp_monomial, AddMonoidAlgebra.op_ring_equiv_single,
    to_finsupp_iso_symm_apply, of_finsupp_single]
simp only [X_pow_mul, op_mul, op_pow, map_mul, map_pow, op_ring_equiv_op_X, op_ring_equiv_op_C]
simp
rw [C_mul_X_pow_eq_monomial, op_ring_equiv_symm_monomial, ← C_mul_X_pow_eq_monomial]
induction p using MulOpposite.rec
cases p
rfl
induction p using MulOpposite.rec
cases p
exact Finsupp.support_map_range_of_injective _ _ op_injective
rw [leading_coeff, coeff_op_ring_equiv, nat_degree_op_ring_equiv, leading_coeff]
rw [if_neg this]
rw [Finset.prod, prod_X_add_C_coeff' _ r h, Finset.esymm_map_val]
rfl
simp only [dickson, sq]
rw [dickson]
simp only [dickson_zero, Polynomial.map_sub, Polynomial.map_nat_cast, bit1, bit0,
      Polynomial.map_add, Polynomial.map_one]
simp only [dickson_one, map_X]
simp only [dickson_add_two, Polynomial.map_sub, Polynomial.map_mul, map_X, map_C]
rw [map_dickson, map_dickson]
simp only [dickson_one, pow_one]
simp only [dickson_add_two, C_0, zero_mul, sub_zero]
rw [dickson_two_zero, pow_add X (n + 1) 1, mul_comm, pow_one]
simp only [eval_X, dickson_one, pow_one]
rw [← dickson_one_one_mul, mul_comm, dickson_one_one_mul]
rw [← f.char_p_iff_char_p]
infer_instance
rw [H, eval_zero]
simp [Inv.inv, dif_neg ha]
exact Fintype.right_inverse_bij_inv _ _
simp [Inv.inv, dif_pos rfl]
cases nonempty_fintype R
exact @Field.toIsField R (@Fintype.fieldOfDomain R _ _ (Classical.decEq R) _)
refine'
    is_cyclic_of_subgroup_is_domain ⟨(coe : S → R), _, _⟩ (units.ext.comp Subtype.val_injective)
· simp
· intros
    simp
simp
simp only [mem_univ, forall_true_iff]
simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow, Units.val_pow_eq_pow_val,
                coe_coe]
rw [← pow_eq_mod_order_of, hn]
simp_all only [Set.mem_setOf_eq, mul_pow, one_mul]
simp_all only [Set.mem_setOf_eq, inv_pow, inv_one]
simp only [mem_roots_of_unity, mem_nth_roots k.pos, Units.ext_iff, Units.val_one,
    Units.val_pow_eq_pow_val]
simp [mem_roots_of_unity']
rw [primitiveRoots, mem_filter, Multiset.mem_to_finset, mem_nth_roots h0, and_iff_right_iff_imp]
exact IsPrimitiveRoot.pow_eq_one
rw [primitiveRoots, nth_roots_zero, Multiset.to_finset_zero, Finset.filter_empty]
exact this ▸ k.gcd_dvd_right l
  rw [eq_iff_le_not_lt]
  refine' ⟨Nat.le_of_dvd hk (k.gcd_dvd_left l), _⟩
  intro h'
  apply h _ (Nat.gcd_pos_of_pos_left _ hk) h'
  exact pow_gcd_eq_one _ h1 hl
apply isUnit_of_mul_eq_one ζ (ζ ^ (k - 1))
rw [← pow_succ, tsub_add_cancel_of_le h0.nat_succ_le, h.pow_eq_one]
simp [iff_def, ← SubmonoidClass.coe_pow]
simp only [iff_def, Units.ext_iff, Units.val_pow_eq_pow_val, Units.val_one]
rw [← pow_mul', pow_mul, h.pow_eq_one, one_pow]
refine'
    ⟨fun h => ⟨h.pow_eq_one, fun l hl' hl => _⟩, fun ⟨hζ, hl⟩ =>
      IsPrimitiveRoot.mk_of_lt ζ hk hζ hl⟩
rw [h.eq_order_of] at hl
exact pow_ne_one_of_lt_order_of' hl'.ne' hl
exact this ▸ IsPrimitiveRoot.order_of (ζ ^ p)
  rw [order_of_pow' _ hp, ← eq_order_of h, Nat.gcd_eq_right hdiv]
rw [← map_pow, h.pow_eq_one, _root_.map_one]
rw [h.eq_order_of]
intro l hl
rw [← map_pow, ← map_one f] at hl
exact order_of_dvd_of_pow_eq_one (hf hl)
rw [zpow_ofNat]
exact h.pow_eq_one
simp only [not_le, neg_nonneg] at h0⊢
exact le_of_lt h0
simp only [h.pow_eq_one, inv_one, eq_self_iff_true, inv_pow]
intro l hl
apply h.dvd_of_pow_eq_one l
rw [← inv_inj, ← inv_pow, hl, inv_one]
refine' ⟨_, fun h => inv h⟩
intro h
rw [← inv_inv ζ]
exact inv h
simp only [not_le, neg_nonneg] at h0⊢
exact le_of_lt h0
apply Finset.eq_singleton_iff_unique_mem.2
constructor
· simp only [IsPrimitiveRoot.one_right_iff, mem_primitive_roots zero_lt_one]
· intro x hx
    rw [mem_primitive_roots zero_lt_one, IsPrimitiveRoot.one_right_iff] at hx
    exact hx
apply (eq_or_eq_neg_of_sq_eq_sq ζ 1 _).resolve_left
· rw [← pow_one ζ]
    apply h.pow_ne_one_of_pos_of_lt <;> decide
· simp only [h.pow_eq_one, one_pow]
refine' eq_zero_of_ne_zero_of_mul_left_eq_zero (sub_ne_zero_of_ne (hζ.ne_one hk).symm) _
rw [mul_neg_geom_sum, hζ.pow_eq_one, sub_self]
rw [eq_neg_iff_add_eq_zero, add_comm, ← sum_range_succ, ← Nat.succ_eq_add_one,
    Nat.succ_pred_eq_of_pos (pos_of_gt hk), hζ.geom_sum_eq_zero hk]
simp only [zpow_zero]
rfl
intro i j
simp only [zpow_add]
rfl
rw [← h.zmod_equiv_zpowers.symm_apply_apply i, zmod_equiv_zpowers_apply_coe_int]
rw [← h.zmod_equiv_zpowers.symm_apply_apply i, zmod_equiv_zpowers_apply_coe_nat]
rw [h.zpowers_eq]
rw [nth_roots_finset, ← Multiset.to_finset_eq (nth_roots_nodup h), card_mk, h.card_nth_roots]
rw [← Zmod.expand_card, map_expand]
rw [is_primitive.int.dvd_iff_map_cast_dvd_map_cast (P * Q) (X ^ n - 1) PQprim
        (monic_X_pow_sub_C (1 : ℤ) (ne_of_gt hpos)).IsPrimitive,
      Polynomial.map_mul]
refine' IsCoprime.mul_dvd _ _ _
· have aux := is_primitive.int.irreducible_iff_irreducible_map_cast Pmonic.is_primitive
      refine' (dvd_or_coprime _ _ (aux.1 Pirr)).resolve_left _
      rw [map_dvd_map (Int.castRingHom ℚ) Int.cast_injective Pmonic]
      intro hdiv
      refine' hdiff (eq_of_monic_of_associated Pmonic Qmonic _)
      exact associated_of_dvd_dvd hdiv (Pirr.dvd_symm Qirr hdiv)
· apply (map_dvd_map (Int.castRingHom ℚ) Int.cast_injective Pmonic).2
      exact minpoly_dvd_X_pow_sub_one h
· apply (map_dvd_map (Int.castRingHom ℚ) Int.cast_injective Qmonic).2
      exact minpoly_dvd_X_pow_sub_one (pow_of_prime h hprime.1 hdiv)
rw [hμ.eq_order_of, ← hμ.coe_to_roots_of_unity_coe, order_of_units, order_of_subgroup]
simp
rw [hg p hp, zero_smul]
simp [Basis.smul]
rw [Nat.gcd_mul_lcm]
decide
rw [if_pos h, Units.val_one, mul_one]
rw [if_neg (not_le_of_gt h), Units.val_neg, Units.val_one, mul_neg_one]
rw [← Int.ofNat_mul, gcd_mul_lcm, coe_nat_abs_eq_normalize]
exact normalize_associated (a * b)
rw [← gcd_eq_one_iff_coprime, Nat.coprime_iff_gcd_eq_one, gcd_eq_nat_abs]
simp only [gcd_eq_one_iff_coprime, ← not_and_or, not_iff_not, IsCoprime.mul_right_iff]
rw [← coe_gcd, h, Int.ofNat_one]
exact isUnit_one
apply Nat.dvd_antisymm <;> rw [← Int.coe_nat_dvd]
· rw [Int.natAbs_dvd]
    exact Int.dvd_gcd (EuclideanDomain.gcd_dvd_left _ _) (EuclideanDomain.gcd_dvd_right _ _)
· rw [Int.dvd_natAbs]
    exact EuclideanDomain.dvd_gcd (Int.gcd_dvd_left _ _) (Int.gcd_dvd_right _ _)
refine' ⟨fun z => z.out.nat_abs, fun n => Associates.mk n, _, _⟩
· refine' fun a =>
      (Quotient.inductionOn' a) fun a =>
        Associates.mk_eq_mk_iff_associated.2 <| Associated.symm <| ⟨norm_unit a, _⟩
    show normalize a = Int.natAbs (normalize a)
    rw [Int.coe_nat_abs_eq_normalize, normalize_idem]
· intro n
    dsimp
    rw [← normalize_apply, ← Int.coe_nat_abs_eq_normalize, Int.natAbs_ofNat, Int.natAbs_ofNat]
apply (Nat.Prime.dvd_mul hp).mp
rw [← Int.natAbs_mul]
exact int.coe_nat_dvd_left.mp h
rw [Int.coe_nat_dvd_left, Int.coe_nat_dvd_left]
exact Int.Prime.dvd_mul hp h
apply @Nat.Prime.dvd_of_dvd_pow _ _ k hp
rw [← Int.nat_abs_pow]
exact int.coe_nat_dvd_left.mp h
rw [Int.coe_nat_dvd_left]
exact Int.Prime.dvd_pow hp h
cases n
· simp
rw [← Multiset.rel_eq, ← associated_eq_eq]
apply factors_unique irreducible_of_normalized_factor _
· rw [Multiset.coe_prod, Nat.prod_factors n.succ_ne_zero]
    apply normalized_factors_prod (Nat.succ_ne_zero _)
· infer_instance
· intro x hx
    rw [Nat.irreducible_iff_prime, ← Nat.prime_iff]
    exact Nat.prime_of_mem_factors hx
rw [← Multiset.rel_eq, ← associated_eq_eq]
apply
    UniqueFactorizationMonoid.factors_unique irreducible_of_normalized_factor h
      (normalized_factors_prod _)
rw [Ne.def, Multiset.prod_eq_zero_iff]
intro con
exact not_irreducible_zero (h 0 Con)
simp only [finite_def, ← Int.natAbs_dvd_natAbs, Int.nat_abs_pow]
rw [finite_int_iff_nat_abs_finite, finite_nat_iff, pos_iff_ne_zero, Int.natAbs_ne_zero]
apply UniqueFactorizationMonoid.induction_on_prime
exact h₀
· intro n h
    rw [Nat.isUnit_iff.1 h]
    exact h₁
· intro a p _ hp ha
    exact h p a hp.nat_prime ha
rw [← dvd_dvd_iff_associated, ← Int.natAbs_dvd_natAbs, ← Int.natAbs_dvd_natAbs,
    dvd_dvd_iff_associated]
exact associated_iff_eq
rw [Int.associated_iff_nat_abs]
exact Int.natAbs_eq_natAbs_iff
rw [Ideal.span_singleton_eq_span_singleton]
exact (associated_nat_abs _).symm
simp
rw [← @span_singleton_eq_bot R M, span_singleton_generator]
simp only [mul_comm, smul_eq_mul]
rw [← mem_iff_generator_dvd, Submodule.mem_map]
exact ⟨x, hx, rfl⟩
rw [← mem_iff_generator_dvd, LinearMap.mem_submodule_image_of_le hNO]
exact ⟨x, hx, rfl⟩
simp only [not_and_or, Set.mem_setOf_eq, not_ne_iff] at this
cases this
cases this ((mod_mem_iff hmin.1).2 hx)
exact this
unfold factors
rw [dif_neg h]
exact Classical.choose_spec (WfDvdMonoid.exists_factors a h)
rw [← Set.image_singleton, ← Submodule.map_span, is_principal.span_singleton_generator,
        Submodule.map_comap_eq_of_surjective hf]
rw [Ideal.submodule_span_eq, ← Set.image_singleton, ← Ideal.map_span,
        Ideal.span_singleton_generator, Ideal.map_comap_of_surjective f hf]
rw [← mem_span_pair, hd, Ideal.mem_span_singleton]
rw [← gcd_dvd_iff_exists]
rw [IsCoprime, ← mem_span_pair, ← span_gcd, ← span_singleton_eq_top, eq_top_iff_one]
rw [← gcd_is_unit_iff]
refine' (Surjective.wellFounded_iff mk_surjective _).1 well_founded_dvd_not_unit
intros
rw [mk_dvd_not_unit_mk_iff]
rw [s.prod_cons i]
exact hs.2.mul_left i
simp [h]
apply WfDvdMonoid.well_founded_associates
rw [← Associates.irreducible_iff_prime_iff]
apply UniqueFactorizationMonoid.irreducible_iff_prime
simp
simp
simp [hq]
simp
simp [hq]
refine' mt (fun con => _) h
rw [b_eq, Con, mul_zero]
erw [Multiset.prod_hom, ← e.map_mul, h]
simp
simp [ha0]
simp [hb0]
simp_all
rw [hx, Multiset.prod_cons] <;> exact hfx.2.mul_left _
rw [Multiset.prod_add]
rw [factors, dif_neg ane0]
exact (Classical.choose_spec (exists_prime_factors a ane0)).2
intro ha
rw [factors, dif_pos ha] at h
exact Multiset.not_mem_zero _ h
have ane0 := ne_zero_of_mem_factors hx
rw [factors, dif_neg ane0] at hx
exact (Classical.choose_spec (UniqueFactorizationMonoid.exists_prime_factors a ane0)).1 x hx
simp [factors]
simp_all
rw [Multiset.prod_cons] <;> exact (factors_prod hb0).symm.mul_left _
simp
rw [hp]
exact Multiset.mem_singleton_self _
simp_all
rw [Multiset.prod_cons] <;> exact (normalized_factors_prod hb0).symm.mul_left _
simp
simp [normalized_factors, factors]
rw [normalized_factors_pow, normalized_factors_irreducible hp, Multiset.nsmul_singleton]
rw [h]
rw [normalized_factors_pow, normalized_factors_irreducible hp, Multiset.nsmul_singleton]
rw [← normalize_normalized_factor a ha, ← normalize_normalized_factor b hb,
    normalize_eq_normalize_iff]
apply Associated.dvd_dvd h
simp
intro x
dsimp
simp only [zero_dvd_iff]
intros
contradiction
apply le_antisymm
· apply PartEnat.le_of_lt_add_one
    rw [← Nat.cast_one, ← Nat.cast_add, lt_iff_not_ge, ge_iff_le,
      le_multiplicity_iff_repeat_le_normalized_factors ha hb, ← le_count_iff_repeat_le]
    simp
rw [le_multiplicity_iff_repeat_le_normalized_factors ha hb, ← le_count_iff_repeat_le]
rw [mul_one]
simp only [h1 isUnit_one, hf1, mul_zero]
simp only [h1 isUnit_one, hf1, mul_zero]
rw [mul_one]
rw [← h1 isUnit_one, one_mul, one_mul]
simp
simp
rw [← WithTop.coe_sup, ← WithTop.coe_inf, ← WithTop.coe_add, ← WithTop.coe_add,
        WithTop.coe_eq_coe]
exact Multiset.union_add_inter _ _
simp
simp
rw [← factor_set.coe_add, prod_coe, prod_coe, prod_coe, Multiset.map_add, Multiset.prod_add]
simp <;> exact le_top
simp [factors', Multiset.map_pmap, Multiset.pmap_eq_map]
simp [quotient_mk_eq_mk, this]
simp_all
rw [← Option.isSome_iff_exists, ← Option.ne_none_iff_isSome, Ne.def, Ne.def,
    factors_eq_none_iff_zero]
rw [h]
rw [h]
intro p hp
rw [← count_some, ← count_some, h p hp]
cases subsingleton_or_nontrivial α
· simp [Subsingleton.elim a 0]
refine' eq_of_prod_eq_prod (eq_of_factors_eq_factors _)
rw [prod_add, factors_prod, factors_prod, factors_prod]
rw [factors_mul] <;> exact le_add_of_nonneg_right bot_le
constructor
· rw [← mk_dvd_mk]
    apply dvd_of_mem_factors'
    apply ha0
· apply mem_factors'_of_dvd ha0
rw [factors_mk _ ha0]
exact mem_factor_set_some.mpr (mem_factors'_of_dvd ha0 hp hd)
constructor
· rw [← mk_dvd_mk]
    apply dvd_of_mem_factors
    exact (irreducible_mk p).mpr hp
· apply mem_factors_of_dvd ha0 hp
rw [factors_prod, factor_set.prod, map_singleton, prod_singleton, Subtype.coe_mk]
rw [Associates.factors_prod, factor_set.prod, Multiset.map_repeat, Multiset.prod_repeat,
        Subtype.coe_mk]
simp [factors_self hp, Associates.count_some hp]
apply eq_of_prod_eq_prod
rw [Associates.factors_prod]
exact Multiset.prod_zero
rw [count_pow ha hp]
apply dvd_mul_right
simp only [Subtype.coe_eta, Subtype.val_eq_coe]
rw [← quot_mk_eq_mk, Quot.out_eq]
rw [← mk_eq_mk_iff_associated, ← Associates.mk_mul_mk, ← associated_iff_eq, Associates.quot_out,
      Associates.quot_out, mul_comm, sup_mul_inf, Associates.mk_mul_mk]
rw [dvd_out_iff, le_inf_iff, mk_le_mk_iff_dvd_iff, mk_le_mk_iff_dvd_iff] <;>
          exact ⟨hac, hab⟩
simp
simp
rw [← out_mul, mul_comm, sup_mul_inf, mk_mul_mk, out_mk]
exact normalize_associated (a * b)
intro hz
apply hy (eq_zero_of_zero_dvd _)
have hz := (@Multiset.prod_eq_zero_iff M _ _ _ s.fst).mp hz
rw [← (normalized_factors_prod hy).dvd_iff_dvd_right]
exact Multiset.dvd_prod (Multiset.mem_of_le hs hz)
simp [factorization]
simp [factorization]
simp [factorization]
simp [factorization, Multiset.to_finsupp_support]
simp [factorization, normalized_factors_mul ha hb]
cases D1
cases D2
congr
exact FunLike.coe_injective h
rw [← mul_one r, RingHom.map_mul, RingHom.map_one, ← smul_def, map_smul, map_one_eq_zero,
    smul_zero]
rw [← nsmul_one, D.map_smul_of_tower n, map_one_eq_zero, smul_zero]
rw [← pow_succ, Nat.sub_add_cancel hpos]
simp only [map_add, *]
simp only [leibniz, *]
simp only [add_zero, LinearMap.zero_apply, smul_zero]
simp
simp only [leibniz, LinearMap.add_apply, coe_fn_coe, smul_add, add_add_add_comm]
rw [LinearMap.smul_apply, coe_fn_coe, D.map_one_eq_zero, smul_zero]
simp only [LinearMap.smul_apply, coe_fn_coe, leibniz, smul_add, smul_comm r]
simp only [LinearMap.comp_apply, coe_fn_coe, map_one_eq_zero, map_zero]
simp only [coe_fn_coe, LinearMap.comp_apply, LinearMap.map_add, leibniz,
          LinearMap.coe_coe_is_scalar_tower, LinearMap.map_smul]
rw [← zsmul_one, D.map_smul_of_tower n, map_one_eq_zero, smul_zero]
simp only [smul_smul, h, one_smul, sq]
rw [leibniz, smul_add, add_comm]
rw [h, map_one_eq_zero, smul_zero]
simp only [LinearMap.neg_apply, smul_neg, neg_add_rev, leibniz, coe_fn_coe, add_comm]
simp only [LinearMap.sub_apply, leibniz, coe_fn_coe, smul_sub, add_sub_add_comm]
intro x
change f₁ x - f₂ x ∈ I
rw [← Ideal.Quotient.eq, ← Ideal.Quotient.mkₐ_eq_mk R, ← AlgHom.comp_apply, e]
rfl
rw [map_one, f.map_one_eq_zero, Submodule.coe_zero, zero_add]
dsimp
simp [← IsScalarTower.algebra_map_apply R A B r]
rw [lift_of_derivation_to_square_zero_apply, map_add,
    ideal.quotient.eq_zero_iff_mem.mpr (d x).Prop, zero_add]
rfl
simp [RingHom.mem_ker]
rw [hx, TensorProduct.zero_tmul, sub_zero]
dsimp [KaehlerDifferential.D_linear_map_apply]
rw [Ideal.to_cotangent_eq_zero, Subtype.coe_mk, sub_self]
exact zero_mem _
exact this.some_spec
  apply Submodule.span_induction this
  · rintro _ ⟨x, rfl⟩
    refine' ⟨KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R x, _⟩
    apply Submodule.subset_span
    exact ⟨x, KaehlerDifferential.D_linear_map_apply R S x⟩
  · exact ⟨zero_mem _, zero_mem _⟩
  · rintro x y ⟨hx₁, hx₂⟩ ⟨hy₁, hy₂⟩
    exact ⟨add_mem hx₁ hy₁, add_mem hx₂ hy₂⟩
  · rintro r x ⟨hx₁, hx₂⟩
    exact
      ⟨((KaehlerDifferential.ideal R S).restrictScalars S).smul_mem r hx₁,
        Submodule.smul_mem _ r hx₂⟩
rw [KaehlerDifferential.span_range_derivation]
trivial
rw [← Derivation.lift_kaehler_differential_apply, Derivation.lift_kaehler_differential_D]
rfl
intro x
rw [AlgHom.coe_to_ring_hom, ← AlgHom.comp_apply, tensor_product.lmul'_comp_include_left]
rfl
rw [Submodule.mkq_apply, Submodule.Quotient.mk_eq_zero, ← Finsupp.smul_single_one _ y]
exact Submodule.smul_mem _ _ (Submodule.subset_span (Or.inr <| ⟨_, rfl⟩))
rw [← (algebraMap R S).map_one, KaehlerDifferential.ker_total_mkq_single_algebra_map]
rw [Algebra.smul_def, KaehlerDifferential.ker_total_mkq_single_mul,
    KaehlerDifferential.ker_total_mkq_single_algebra_map, add_zero, ← LinearMap.map_smul_of_tower,
    Finsupp.smul_single, mul_comm, Algebra.smul_def]
rw [← LinearMap.range_eq_top, Finsupp.range_total, KaehlerDifferential.span_range_derivation]
simp
simp
simp [hab] <;> rw [mul_assoc] <;> rw [IsUnit.mul_val_inv ha] <;> rw [mul_one]
apply Multiset.eq_repeat_of_mem
intro b hb
refine'
        eq_second_of_chain_of_prime_dvd hn h₁ (fun r' => h₂) (prime_of_normalized_factor b hb) hr
          (dvd_of_mem_normalized_factors hb)
have := UniqueFactorizationMonoid.normalized_factors_prod (ne_zero_of_dvd_ne_zero hq hr)
rw [associated_iff_eq, hi, Multiset.prod_repeat] at this
rw [this]
simp
simp only [Subtype.coe_eta, OrderIso.symm_apply_apply, Subtype.coe_mk]
rw [this]
apply Subtype.prop (d ⟨p ^ s, hs'⟩)
simp
rw [this, OrderIso.map_bot d] at hx
refine' (Subtype.mk_eq_bot_iff _ _).mp hx.symm
exact bot_le
rw [d.symm_apply_apply ⟨p, dvd_of_mem_normalized_factors hp⟩, Subtype.coe_mk] at this
exact this
simp only [Subtype.coe_eta, Equiv.symm_apply_apply, Subtype.coe_mk,
      associates_equiv_of_unique_units_apply, mk_out, out_mk, normalize_eq]
simp only [Subtype.coe_eta, Equiv.apply_symm_apply, Subtype.coe_mk,
      associates_equiv_of_unique_units_apply, out_mk, normalize_eq, mk_out]
simp [dvd_of_mem_normalized_factors hp]
simp only [dvd_of_mem_normalized_factors hp, associates_equiv_of_unique_units_apply,
                out_mk, normalize_eq, associates_equiv_of_unique_units_symm_apply]
simp only [associates_equiv_of_unique_units_symm_apply] <;>
              exact mk_dvd_mk.mpr (dvd_of_mem_normalized_factors hp)
rw [mk_factor_order_iso_of_factor_dvd_equiv_apply_coe]
simp only [Subtype.coe_mk]
simp [dvd_of_mem_normalized_factors hp]
simp only [dvd_of_mem_normalized_factors hp,
                associates_equiv_of_unique_units_symm_apply, associates_equiv_of_unique_units_apply,
                out_mk, normalize_eq]
rw [associates_equiv_of_unique_units_symm_apply] <;>
              exact mk_le_mk_of_dvd (dvd_of_mem_normalized_factors hp)
rw [mk_factor_order_iso_of_factor_dvd_equiv_apply_coe]
rfl
simp
simp
rw [← aeval_def, aeval_map_algebra_map, aeval_def, hpx]
erw [Algebra.adjoin_empty, Finset.coe_singleton, ← one_eq_span, one_eq_range,
            LinearMap.mem_range, Algebra.mem_bot]
rfl
rw [← Set.union_singleton, Algebra.adjoin_union_coe_submodule] <;>
        exact
          fg.mul (ih fun i hi => his i <| Set.mem_insert_of_mem a hi)
            (fg_adjoin_singleton_of_integral _ <| his a <| Set.mem_insert a s)
rw [← hy]
exact subset_span hp
  -- Now `S` is a subalgebra so the product of two elements of `y` is also in `S`.
exact this hz
      refine' Subring.closure_le.2 (Set.union_subset _ fun t ht => subset_span <| Or.inr ht)
      rw [Set.range_subset_iff]
      intro y
      rw [Algebra.algebra_map_eq_smul_one]
      exact smul_mem _ y (subset_span (Or.inl rfl))
rw [Algebra.smul_def, IsScalarTower.algebra_map_apply R S A]
exact is_integral_mul is_integral_algebra_map hx
rw [Algebra.adjoin_le_iff]
simp only [SetLike.mem_coe, Set.singleton_subset_iff]
exact hx
simp only [← le_integral_closure_iff_is_integral, sup_le_iff]
rw [Matrix.det_apply]
exact IsIntegral.sum _ fun σ hσ => IsIntegral.zsmul (IsIntegral.prod _ fun i hi => h _ _) _
apply le_antisymm
· exact Finset.sup_mono (normalize_scale_roots_support p)
· rw [← degree_scale_roots, ← leading_coeff_smul_normalize_scale_roots]
    exact degree_smul_le _ _
rw [h'', nat_degree_zero] at h'
exact Nat.not_succ_le_zero 0 h'
exact (hp this).rec _
      rw [eq_C_of_nat_degree_eq_zero h', map_C, h, C_eq_zero]
rw [aeval_def] at h
rw [Algebra.smul_def]
exact (algebraMap R S).is_integral_elem_leading_coeff_mul p x h
rw [algebra_map_mk', RingHom.map_one]
rw [algebra_map_mk', RingHom.map_zero]
simp only [algebra_map_mk', RingHom.map_add]
simp only [algebra_map_mk', RingHom.map_mul]
rw [algebra_map_mk', ← IsScalarTower.algebra_map_apply]
simp only [RingHom.map_one, mk'_one]
simp only [RingHom.map_zero, mk'_zero]
intro i
rw [← Set.mem_range]
exact (Polynomial.mem_map_range _).2 fun i => ⟨⟨_, coeffs_mem i⟩, rfl⟩
let g := Ideal.Quotient.mk (I.comap f)
have := Ideal.quotient_map_comp_mk le_rfl
refine' ⟨fun h => _, fun h => RingHom.is_integral_tower_top_of_is_integral g _ (this ▸ h)⟩
refine' this ▸ RingHom.is_integral_trans g (Ideal.quotientMap I f le_rfl) _ h
exact RingHom.is_integral_of_surjective g Ideal.Quotient.mk_surjective
rw [← pow_add a_inv, tsub_add_cancel_of_le (Nat.le_of_lt_succ (finset.mem_range.mp hi))]
funext k
exact mul_n_coeff n x k
rw [bind₁_bind₁]
exact eval₂_hom_congr (RingHom.ext_rat _ _) rfl rfl
rw [bind₁_X_in_terms_of_W_witt_polynomial p _ n, bind₁_X_right]
rw [bind₁_witt_polynomial_X_in_terms_of_W p, bind₁_X_right]
rw [witt_structure_rat_rec_aux]
rw [← pow_add, ← add_assoc]
congr 2
rw [add_comm, ← tsub_eq_iff_eq_add_of_le hk]
rw [← pow_succ, ← tsub_add_eq_add_tsub hk]
rw [RingHom.map_sum]
apply Finset.sum_congr rfl
intro i hi
rw [Finset.mem_range] at hi
simp only [IH i hi, RingHom.map_mul, RingHom.map_pow, map_C]
rfl
apply MvPolynomial.map_injective (Int.castRingHom ℚ) Int.cast_injective
simp only [map_rename, map_witt_structure_int, wittStructureRat, rename_bind₁, rename_rename,
    bind₁_rename]
rfl
simp only [wittStructureRat, bind₁, map_aeval, X_in_terms_of_W_zero, constant_coeff_rename,
    constant_coeff_witt_polynomial, aeval_X, constant_coeff_comp_algebra_map, eval₂_hom_zero'_apply,
    RingHom.id_apply]
simp only [wittStructureRat, eval₂_hom_zero'_apply, h, bind₁, map_aeval, constant_coeff_rename,
    constant_coeff_witt_polynomial, constant_coeff_comp_algebra_map, RingHom.id_apply,
    constant_coeff_X_in_terms_of_W]
intro m n
exact int.cast_inj.mp
intro m n
exact int.cast_inj.mp
have : Function.Injective (Int.castRingHom ℚ) := Int.cast_injective
rw [← vars_map_of_injective _ this, map_witt_structure_int]
apply witt_structure_rat_vars
delta frobenius_poly_rat
rw [← bind₁_bind₁, bind₁_X_in_terms_of_W_witt_polynomial, bind₁_X_right]
rw [frobenius_poly_aux, ← Fin.sum_univ_eq_sum_range]
rw [← multiplicity.finite_iff_dom, multiplicity.finite_nat_iff]
exact ⟨hp.1.ne_one, Nat.choose_pos hj⟩
rw [tsub_add_eq_add_tsub this.2, add_comm i j,
      add_tsub_assoc_of_le (this.1.trans (Nat.sub_le n i)), add_assoc, tsub_right_comm, add_comm i,
      tsub_add_cancel_of_le (le_tsub_of_add_le_right ((le_tsub_iff_left hi.le).mp this.1))]
rw [← h]
exact multiplicity.pow_multiplicity_dvd _
rw [← tsub_eq_of_eq_add_rev hc]
apply Nat.sub_le
rw [← mul_pow, mul_invOf_self, one_pow]
rw [frobenius_poly, RingHom.map_add, RingHom.map_pow, RingHom.map_mul, map_X, map_C]
simp only [Int.cast_ofNat, add_zero, eq_int_cast, Zmod.nat_cast_self, zero_mul, C_0]
apply MvPolynomial.map_injective (Int.castRingHom ℚ) Int.cast_injective
simp only [map_bind₁, map_frobenius_poly, bind₁_frobenius_poly_rat_witt_polynomial,
    map_witt_polynomial]
rw [frobenius_fun, coeff_mk]
intros
funext n
apply coeff_frobenius_fun
simp only [ghost_component_apply, frobenius_fun, coeff_mk, ← bind₁_frobenius_poly_witt_polynomial,
    aeval_bind₁]
simp only [ext_iff, coeff_frobenius_char_p, Zmod.pow_card, eq_self_iff_true, forall_const]
rw [frobenius_eq_map_frobenius]
exact pth_root_frobenius _
rw [frobenius_eq_map_frobenius]
exact frobenius_pth_root _
cases x
cases y
simp only at h
simp [Function.funext_iff, h]
rw [h]
apply MvPolynomial.map_injective (Int.castRingHom ℚ) Int.cast_injective
simp only [witt_zero, wittStructureRat, bind₁, aeval_zero', constant_coeff_X_in_terms_of_W,
    RingHom.map_zero, AlgHom.map_zero, map_witt_structure_int]
apply MvPolynomial.map_injective (Int.castRingHom ℚ) Int.cast_injective
simp only [witt_one, wittStructureRat, X_in_terms_of_W_zero, AlgHom.map_one, RingHom.map_one,
    bind₁_X_right, map_witt_structure_int]
apply MvPolynomial.map_injective (Int.castRingHom ℚ) Int.cast_injective
simp only [witt_one, wittStructureRat, RingHom.map_zero, AlgHom.map_one, RingHom.map_one,
    map_witt_structure_int]
revert hn
apply Nat.strong_induction_on n
clear n
intro n IH hn
rw [X_in_terms_of_W_eq]
simp only [AlgHom.map_mul, AlgHom.map_sub, AlgHom.map_sum, AlgHom.map_pow, bind₁_X_right,
    bind₁_C_right]
rw [sub_mul, one_mul]
rw [Finset.sum_eq_single 0]
· simp only [invOf_eq_inv, one_mul, inv_pow, tsub_zero, RingHom.map_one, pow_zero]
    simp only [one_pow, one_mul, X_in_terms_of_W_zero, sub_self, bind₁_X_right]
· intro i hin hi0
    rw [Finset.mem_range] at hin
    rw [IH _ hin (Nat.pos_of_ne_zero hi0), zero_pow (pow_pos hp.1.Pos _), mul_zero]
· rw [Finset.mem_range]
    intro
    contradiction
apply MvPolynomial.map_injective (Int.castRingHom ℚ) Int.cast_injective
simp only [witt_add, wittStructureRat, AlgHom.map_add, RingHom.map_add, rename_X,
    X_in_terms_of_W_zero, map_X, witt_polynomial_zero, bind₁_X_right, map_witt_structure_int]
apply MvPolynomial.map_injective (Int.castRingHom ℚ) Int.cast_injective
simp only [witt_sub, wittStructureRat, AlgHom.map_sub, RingHom.map_sub, rename_X,
    X_in_terms_of_W_zero, map_X, witt_polynomial_zero, bind₁_X_right, map_witt_structure_int]
apply MvPolynomial.map_injective (Int.castRingHom ℚ) Int.cast_injective
simp only [witt_mul, wittStructureRat, rename_X, X_in_terms_of_W_zero, map_X,
    witt_polynomial_zero, RingHom.map_mul, bind₁_X_right, AlgHom.map_mul, map_witt_structure_int]
apply MvPolynomial.map_injective (Int.castRingHom ℚ) Int.cast_injective
simp only [witt_neg, wittStructureRat, rename_X, X_in_terms_of_W_zero, map_X,
    witt_polynomial_zero, RingHom.map_neg, AlgHom.map_neg, bind₁_X_right, map_witt_structure_int]
apply constant_coeff_witt_structure_int p _ _ n
simp only [add_zero, RingHom.map_add, constant_coeff_X]
apply constant_coeff_witt_structure_int p _ _ n
simp only [sub_zero, RingHom.map_sub, constant_coeff_X]
apply constant_coeff_witt_structure_int p _ _ n
simp only [mul_zero, RingHom.map_mul, constant_coeff_X]
apply constant_coeff_witt_structure_int p _ _ n
simp only [neg_zero, RingHom.map_neg, constant_coeff_X]
apply constant_coeff_witt_structure_int p _ _ n
simp only [smul_zero, map_nsmul, constant_coeff_X]
apply constant_coeff_witt_structure_int p _ _ n
simp only [smul_zero, map_zsmul, constant_coeff_X]
simp only [witt_zero_eq_zero, AlgHom.map_zero]
simp only [witt_one_zero_eq_one, AlgHom.map_one]
simp only [hn, witt_one_pos_eq_zero, AlgHom.map_zero]
simp [(· + ·), eval]
simp [Sub.sub, eval]
simp [(· * ·), eval]
simp [Neg.neg, eval, Matrix.cons_fin_one]
simp [HasSmul.smul, eval, Matrix.cons_fin_one]
simp [HasSmul.smul, eval, Matrix.cons_fin_one]
simp [Pow.pow, eval, Matrix.cons_fin_one]
simp [add_coeff, peval]
simp [mul_coeff, peval]
refine' LinearEquiv.ofBijective F₀ ⟨_, _⟩
· rw [← LinearMap.ker_eq_bot]
      exact LinearMap.ker_to_span_singleton K
refine'
    map_injective (MvPolynomial.map (Int.castRingHom ℚ))
      (MvPolynomial.map_injective _ Int.cast_injective) _
simp only [teichmuller_mul_aux₁, map_teichmuller_fun, RingHom.map_mul]
apply Fin.is_lt
rw [← mul_ne_zero_iff]
intro h
rw [h] at hab
exact p_nonzero p k hab
rw [verschiebung_fun, coeff_mk]
rw [verschiebung_fun_coeff, if_pos rfl]
rw [ghost_component_apply, aeval_witt_polynomial, Finset.range_one, Finset.sum_singleton,
    verschiebung_fun_coeff_zero, pow_zero, pow_zero, pow_one, one_mul]
cases n
· simp only [verschiebung_poly, verschiebung_fun_coeff_zero, if_pos rfl, AlgHom.map_zero]
·
    rw [verschiebung_poly, verschiebung_fun_coeff_succ, if_neg n.succ_ne_zero, aeval_X,
      Nat.succ_eq_add_one, add_tsub_cancel_right]
rw [h]
rw [out, WittVector.coeff_mk, dif_pos i.is_lt, Fin.eta]
rw [truncate_fun, TruncatedWittVector.coeff_mk]
simp only [WittVector.truncateFun, coeff_out, mk_coeff]
show coeff i (truncate_fun _ 0 : TruncatedWittVector p n R) = 0
rw [coeff_truncate_fun, WittVector.zero_coeff]
simp only [RingHom.mem_ker, truncate, truncate_fun, RingHom.coe_mk, TruncatedWittVector.ext_iff,
    TruncatedWittVector.coeff_mk, coeff_zero]
exact Fin.forall_iff
intro x
simp only [WittVector.mem_ker_truncate]
intro h i hi
exact h i (lt_of_lt_of_le hi hm)
simp only [TruncatedWittVector, Fintype.card_fin, Fintype.card_fun]
intro _ _ h
simp only [← RingHom.comp_assoc, truncate_comp_witt_vector_truncate]
rw [wittPolynomial, RingHom.map_sum, wittPolynomial, sum_congr rfl]
intro i hi
rw [map_monomial, RingHom.map_pow, map_nat_cast]
simp only [wittPolynomial, X, sum_singleton, range_one, pow_zero]
simp only [witt_polynomial_eq_sum_C_mul_X_pow, sum_range_succ_comm, range_one, sum_singleton,
    one_mul, pow_one, C_1, pow_zero]
simp [wittPolynomial, AlgHom.map_sum, aeval_monomial, Finsupp.prod_single_index]
simp only [witt_polynomial_eq_sum_C_mul_X_pow]
rw [sum_range_succ, ← Nat.cast_pow, CharP.cast_eq_zero (Zmod (p ^ (n + 1))) (p ^ (n + 1)), C_0,
    zero_mul, add_zero, AlgHom.map_sum, sum_congr rfl]
intro k hk
rw [AlgHom.map_mul, AlgHom.map_pow, expand_X, alg_hom_C, ← pow_mul, ← pow_succ]
congr
rw [mem_range] at hk
rw [add_comm, add_tsub_assoc_of_le (nat.lt_succ_iff.mp hk), ← add_comm]
intro i
refine' vars_monomial_single i (pow_ne_zero _ hp.1) _
rw [← Nat.cast_pow, Nat.cast_ne_zero]
exact pow_ne_zero i hp.1
rw [← map_witt_polynomial p (Int.castRingHom R), ← witt_polynomial_vars p ℤ]
apply vars_map
rw [xInTermsOfW, ← Fin.sum_univ_eq_sum_range]
apply Nat.strong_induction_on n <;> clear n
intro n IH
rw [X_in_terms_of_W_eq, mul_comm, RingHom.map_mul, RingHom.map_sub, RingHom.map_sum,
    constant_coeff_C, sum_eq_zero]
· simp only [constant_coeff_X, sub_zero, mul_zero]
· intro m H
    rw [mem_range] at H
    simp only [RingHom.map_mul, RingHom.map_pow, constant_coeff_C, IH m H]
    rw [zero_pow, mul_zero]
    apply pow_pos hp.1.Pos
rw [X_in_terms_of_W_eq, range_zero, sum_empty, pow_zero, C_1, mul_one, sub_zero]
rw [X_in_terms_of_W_eq, mul_assoc, ← C_mul, ← mul_pow, invOf_mul_self, one_pow, C_1, mul_one]
rw [witt_polynomial_eq_sum_C_mul_X_pow, AlgHom.map_sum]
simp only [AlgHom.map_pow, C_pow, AlgHom.map_mul, alg_hom_C]
rw [sum_range_succ_comm, tsub_self, pow_zero, pow_one, bind₁_X_right, mul_comm, ← C_pow,
    X_in_terms_of_W_aux]
simp only [C_pow, bind₁_X_right, sub_add_cancel]
simp only [witt_polynomial_eq_sum_C_mul_X_pow, tsub_self, sum_range_succ_comm, pow_one,
      add_sub_cancel, pow_zero]
induction n <;> simp [*, Nat.unaryCast, add, one, zero] <;> rfl
cases n <;> simp [*, Int.castDef, add, one, neg, zero, nat_cast] <;> rfl
induction i <;>
      simp [*, Nat.unaryCast, ghost_fun_zero, ghost_fun_one, ghost_fun_add, -Pi.coe_nat]
cases i <;> simp [*, Int.castDef, ghost_fun_nat_cast, ghost_fun_neg, -Pi.coe_nat, -Pi.coe_int]
simp
simp
rw [RingHom.map_pow, map_nat_cast]
rw [card, Zmod.card]
rfl
rw [commutes _ _ hm] <;> rfl
apply (zmod_equiv_trunc p n).Injective
rw [← commutes']
simp
rw [commutes_symm, RingHom.comp_assoc]
rw [RingHom.comp_assoc, truncate_comp_witt_vector_truncate]
rw [← RingHom.comp_assoc, commutes, RingHom.comp_assoc, PadicInt.zmod_cast_comp_to_zmod_pow]
rw [← PadicInt.to_zmod_pow_eq_iff_ext]
intro n
rw [← RingHom.comp_assoc, to_padic_int, PadicInt.lift_spec]
simp only [from_padic_int, to_zmod_pow, RingHom.comp_id]
rw [RingHom.comp_assoc, truncate_comp_lift, ← RingHom.comp_assoc]
simp only [RingEquiv.symm_to_ring_hom_comp_to_ring_hom, RingHom.id_comp]
rw [to_padic_int_comp_from_padic_int]
apply WittVector.hom_ext
intro n
rw [from_padic_int, ← RingHom.comp_assoc, truncate_comp_lift, RingHom.comp_assoc]
simp only [to_padic_int, to_zmod_pow, RingHom.comp_id, PadicInt.lift_spec, RingHom.id_comp, ←
    RingHom.comp_assoc, RingEquiv.to_ring_hom_comp_symm_to_ring_hom]
rw [from_padic_int_comp_to_padic_int]
rw [← frobenius_verschiebung, frobenius_zmodp]
rw [coeff_p, if_neg]
exact zero_ne_one
rw [coeff_p, if_pos rfl]
rw [← frobenius_verschiebung, coeff_frobenius_char_p, verschiebung_coeff_zero, zero_pow]
exact Nat.Prime.pos hp.out
rw [← frobenius_verschiebung, coeff_frobenius_char_p, verschiebung_coeff_succ]
rw [verschiebung_frobenius, frobenius_verschiebung]
calc
    _ = (verschiebung^[i]) (x * (frobenius^[i]) ((verschiebung^[j]) y)) := _
    _ = (verschiebung^[i]) (x * (verschiebung^[j]) ((frobenius^[i]) y)) := _
    _ = (verschiebung^[i]) ((verschiebung^[j]) ((frobenius^[i]) y) * x) := _
    _ = (verschiebung^[i]) ((verschiebung^[j]) ((frobenius^[i]) y * (frobenius^[j]) x)) := _
    _ = (verschiebung^[i + j]) ((frobenius^[i]) y * (frobenius^[j]) x) := _
    _ = _ := _
· apply iterate_verschiebung_mul_left
· rw [verschiebung_frobenius_comm.iterate_iterate] <;> infer_instance
· rw [mul_comm]
· rw [iterate_verschiebung_mul_left]
· rw [iterate_add_apply]
· rw [mul_comm]
rw [← hx, ← hy, select_add_select_not P z]
simp only [init, tail, ← not_lt, select_add_select_not]
rw [degree_mul, degree_C]
· simp only [Nat.cast_with_bot, add_zero, degree_X, degree_pow, Nat.smul_one_eq_coe]
· exact pow_ne_zero _ ha₁
simp only [succ_nth_defining_poly_degree p n a₁ a₂ bs ha₁ ha₂, hp.out.ne_zero,
      WithTop.coe_eq_zero, Ne.def, not_false_iff]
simp only [hq, tsub_zero, Nat.succ_sub_succ_eq_sub]
apply Fin.is_lt
simp [h]
simp [h]
intros
simp only [aeval_X, id]
intros
funext n
simp only [Pi.zero_apply, AlgHom.map_zero, zero_coeff]
rw [← aeval_eq_bind₁, aeval_zero, constant_coeff_witt_polynomial, RingHom.map_zero]
rw [witt_polynomial_eq_sum_C_mul_X_pow, AlgHom.map_sum, Finset.sum_eq_single 0]
·
    simp only [one_poly, one_pow, one_mul, AlgHom.map_pow, C_1, pow_zero, bind₁_X_right, if_true,
      eq_self_iff_true]
· intro i hi hi0
    simp only [one_poly, if_neg hi0, zero_pow (pow_pos hp.1.Pos _), mul_zero, AlgHom.map_pow,
      bind₁_X_right, AlgHom.map_mul]
· rw [Finset.mem_range]
    decide
intros
funext n
cases n
· simp only [one_poly, if_true, eq_self_iff_true, one_coeff_zero, AlgHom.map_one]
·
        simp only [one_poly, Nat.succ_pos', one_coeff_eq_of_pos, if_neg n.succ_ne_zero,
          AlgHom.map_zero]
intros
dsimp only [WittVector.hasAdd]
simp [eval]
intros
dsimp only [WittVector.hasMul]
simp [eval]
rw [witt_poly_prod]
apply subset.trans (vars_mul _ _)
apply union_subset <;>
    · apply subset.trans (vars_rename _ _)
      simp [witt_polynomial_vars, image_subset_iff]
simp only [Int.cast_ofNat, eq_int_cast]
rw [Finsupp.support_eq_singleton]
simp only [and_true_iff, Finsupp.single_eq_same, eq_self_iff_true, Ne.def]
exact pow_ne_zero _ hp.out.ne_zero
simp only [Int.cast_ofNat, eq_int_cast, C_pow, eq_self_iff_true]
  -- unfold definitions and peel off the last entries of the sums.
rw [← add_sub_assoc, eq_sub_iff_add_eq, mul_poly_of_interest_aux2]
exact mul_poly_of_interest_aux3 _ _
rw [mul_poly_of_interest_aux5]
apply subset.trans (vars_sub_subset _ _)
apply union_subset
· apply remainder_vars
· apply witt_poly_prod_remainder_vars
simp only [Int.cast_ofNat, eq_int_cast, C_pow, eq_self_iff_true]
rw [poly_of_interest_vars_eq] <;> apply mul_poly_of_interest_vars
rw [eq_int_cast, Int.cast_ofNat]
intros
rw [mvpz, MvPolynomial.eval₂_C]
intro y
rw [Finset.sum_eq_single_of_mem 0]
· simp
· simp
· intro j _ hj
      simp [zero_pow (zero_lt_iff.mpr hj)]
have x'_eq_zero : x' = 0 := x'_mem_zero
simp [x'_eq_x.symm, x'_eq_zero]
simp [hx]
rw [h, coe_to_fractional_ideal_bot]
simp [h]
simp [h]
rw [coe_one_eq_coe_submodule_top, coe_submodule_top]
rw [succ_nsmul]
exact h.sup (_root_.is_fractional.nsmul n h)
induction n <;> simp [*, Nat.unaryCast]
rw [Ideal.one_eq_top, coe_ideal_top]
rw [← map_comp, g.symm_comp, map_id]
rw [← map_comp, g.comp_symm, map_id]
rw [← map_comp, AlgEquiv.symm_comp, map_id]
rw [← map_comp, AlgEquiv.comp_symm, map_id]
simp
rw [smul_zero]
exact is_integer_zero
rw [smul_add]
exact is_integer_add hx hy
rw [smul_comm]
exact is_integer_smul hx
rw [Units.mul_inv]
exact one_mem_one _
rw [← coe_ideal_fg S inj I]
exact fg_of_is_unit I h
rw [RingEquiv.to_monoid_hom_refl, Submonoid.map_id]
rw [canonical_equiv, map_equiv_apply, mem_map]
exact ⟨fun ⟨y, mem, Eq⟩ => ⟨y, mem, Eq⟩, fun ⟨y, mem, Eq⟩ => ⟨y, mem, Eq⟩⟩
rw [mem_canonical_equiv_apply, canonical_equiv, map_equiv_symm, map_equiv, RingEquiv.coe_mk,
        mem_map]
exact ⟨fun ⟨y, mem, Eq⟩ => ⟨y, mem, Eq⟩, fun ⟨y, mem, Eq⟩ => ⟨y, mem, Eq⟩⟩
rw [← canonical_equiv_symm, RingEquiv.symm_apply_apply]
rw [← Algebra.smul_def, ← hy', y'_eq_zero, RingHom.map_zero]
rw [div_nonzero h]
exact Submodule.mem_div_iff_forall_mul_mem
rw [map_div, map_one]
simp only [← coe_to_submodule_injective.eq_iff, span_finset_coe, coe_zero, Submodule.span_eq_bot,
    Set.mem_image, Finset.mem_coe, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂]
simp
rw [← Submodule.span_singleton_eq_span_singleton]
exact Subtype.mk_eq_mk
simp [h]
apply coe_to_submodule_injective
simp only [coe_mul, coe_span_singleton, span_mul_span, singleton_mul_singleton]
rw [span_singleton_mul_span_singleton, mul_comm, ← IsLocalization.mk'_eq_mul_mk'_one,
      IsLocalization.mk'_self, span_singleton_one]
simp [h]
simp [h]
rw [← one_div_span_singleton]
exact congr_arg Subtype.val this
simp only [FractionalIdeal.mem_singleton_mul, eq_comm]
simp only [le_antisymm_iff, FractionalIdeal.le_span_singleton_mul_iff,
    FractionalIdeal.span_singleton_mul_le_iff]
rw [coe_zero] at hI
rw [le_bot_iff.mp hI]
exact fg_bot
refine' ⟨1, _, _, _⟩
· rw [sub_self]
      exact I.zero_mem
· rw [hs]
      intro n hn
      rw [mem_comap]
      change (1 : R)
rw [Finset.coe_empty, span_empty]
simp [Algebra.to_submodule_bot]
rw [hs.coe_to_finset]
rw [span_union, ht₁.2, ht₂.2]
rw [span_image, ht.2]
rw [f.map_span, Finset.coe_preimage, Set.image_preimage_eq_inter_range,
        Set.inter_eq_self_of_subset_left, ht]
rw [← LinearMap.range_coe, ← span_le, ht, ← map_top]
exact map_mono le_top
rw [LinearMap.span_inl_union_inr, htb.2, htc.2]
rw [← ht1]
exact subset_span hy
rw [mem_map]
exact ⟨x, hx, rfl⟩
rw [H, ← hS]
exact Submodule.subset_span s.2
rfl
rw [Sup_eq_supr, supr_image, ← span_eq_supr_of_singleton_spans, eq_comm, span_eq]
      --
simp [one_eq_span]
rw [← LinearMap.range_eq_top.2 hf, ← Submodule.map_top]
exact hM.1.map f
rw [← Submodule.prod_top]
exact hM.1.Prod hN.1
rw [← Submodule.pi_top]
exact Submodule.fg_pi fun i => (h i).1
rw [Set.image2_smul, Submodule.span_smul_of_span_eq_top hs (↑t : Set B), ht,
            Submodule.restrict_scalars_top]
refine' is_jacobson_iff.trans ⟨fun h I hI => h I hI.IsRadical, _⟩
refine' fun h I hI => le_antisymm (fun x hx => _) fun x hx => mem_Inf.mpr fun _ hJ => hJ.left hx
rw [← hI.radical, radical_eq_Inf I, mem_Inf]
intro P hP
rw [Set.mem_setOf_eq] at hP
erw [mem_Inf] at hx
erw [← h P hP.right, mem_Inf]
exact fun J hJ => hx ⟨le_trans hP.left hJ.left, hJ.right⟩
rw [h, jacobson_eq_top_iff]
rw [is_jacobson_iff_prime_eq]
intro P hP
rw [is_maximal_iff_is_maximal_disjoint S y,
    comap_map_of_is_prime_disjoint (powers y) S I (is_maximal.is_prime hI)
      ((disjoint_powers_iff_not_mem y hI.is_prime.is_radical).2 hy)]
exact ⟨hI, hy⟩
rw [Ideal.jacobson, mem_Inf]
intro J hJ
rw [← RingHom.ker_eq_comap_bot, ← RingHom.injective_iff_ker_eq_bot]
exact IsLocalization.injective Sₘ hM
simp only [coe_eval₂_ring_hom, RingHom.id_apply, eval₂_C]
rw [le_antisymm bot_le
        (comap_bot_le_of_injective _
          (IsLocalization.map_injective_of_injective M (Localization M) (Localization M')
            quotient_map_injective))]
refine' is_maximal_comap_of_is_integral_of_is_maximal' _ _
rw [← @mk_ker _ _ P, RingHom.ker_eq_comap_bot, comap_comap]
exact
    is_maximal_comap_of_is_integral_of_is_maximal' _ (quotient_mk_comp_C_is_integral_of_jacobson P)
rw [Submonoid.map_powers]
assumption
rw [Ne.def, Submodule.annihilator_eq_top_iff]
rw [← Set.mem_singleton_iff]
change algebraMap R (Localization.AtPrime p) x ∈ (0 : Submodule R (Localization.AtPrime p))
rw [← h]
exact Submodule.mem_map_of_mem hx
rw [← hm', mul_comm]
rw [hT]
trivial
rw [Submodule.span_le]
exact Submodule.subset_span
  -- Now, since `y ∈ span T`, and `(f r)⁻¹ ∈ R'`, `x / (f r)` is in `span T` as well.
simp [Algebra.algebra_map_eq_smul_one]
  -- We first obtain the `y' ∈ M` such that `s' = y' • s` is falls in the image of `S` in `S'`.
change ∃ t : M, t
intro r
rw [Submonoid.map_powers]
exact Localization.is_localization
rw [s₂ r]
trivial
rw [hT]
trivial
rw [Algebra.adjoin_le_iff]
exact Algebra.subset_adjoin
rw [hx₁]
exact Set.image_subset _ hA₁
intro r
rw [Submonoid.map_powers]
exact Localization.is_localization
rw [s₂ r]
trivial
have h2 : ¬IsUnit ϖ := show ϖ ∈ maximal_ideal R from h.symm ▸ Submodule.mem_span_singleton_self ϖ
refine' ⟨h2, _⟩
intro a b hab
rw [irreducible_iff_uniformizer] at ha hb
rw [← span_singleton_eq_span_singleton, ← ha, hb]
apply Associated.trans (this hp) (this hq).symm
decide
constructor
intro I
rw [Ne.def, ← eq_bot_iff_generator_eq_zero]
assumption
rw [add_val, add_valuation_apply, hr,
    eq_of_associated_left
      (associated_of_irreducible R hϖ (Classical.choose_spec (exists_prime R)).Irreducible),
    eq_of_associated_right (Associated.symm ⟨u, mul_comm _ _⟩),
    multiplicity_pow_self_of_prime (PrincipalIdealRing.irreducible_iff_prime.1 hϖ)]
rw [add_val_pow, add_val_uniformizer h, nsmul_one]
rw [EuclideanDomain.gcd_mul_lcm]
delta Algebra.IsAlgebraic Subalgebra.IsAlgebraic
simp only [Algebra.mem_top, forall_prop_of_true, iff_self_iff]
simp only [IsAlgebraic, injective_iff_map_eq_zero, not_forall, and_comm, exists_prop]
rw [_root_.map_sub, aeval_X, aeval_C, sub_self]
rw [← _root_.map_one _]
exact is_algebraic_algebra_map 1
rw [← map_nat_cast _]
exact is_algebraic_algebra_map n
rw [← _root_.map_int_cast (algebraMap R A)]
exact is_algebraic_algebra_map n
rw [← map_rat_cast (algebraMap R A)]
exact is_algebraic_algebra_map n
rw [aeval_algebra_map_apply, hf₂, map_zero]
rw [aeval_alg_hom, f.comp_apply, ha, map_zero]
simp only [IsAlgebraic, is_algebraic_iff_is_integral] at L_alg A_alg⊢
exact is_integral_trans L_alg A_alg
rw [this]
exact A.smul_mem (aeval x _).2 _
rw [Subalgebra.aeval_coe, aeval_eq, Subalgebra.coe_zero]
infer_instance
simp only [Polynomial.aeval_one, Pi.one_apply, map_one]
simp only [Pi.mul_apply, map_mul]
simp only [Polynomial.aeval_zero, Pi.zero_apply, map_zero]
simp only [Polynomial.aeval_add, Pi.add_apply, map_add]
simp only [Algebra.algebra_map_eq_smul_one, polynomial_smul_apply', one_mul, Pi.mul_apply,
          Algebra.smul_mul_assoc]
rw [← Set.is_simple_order_Iic_iff_is_atom]
apply OrderIso.is_simple_order_iff
exact Submodule.MapSubtype.relIso m
rw [← Set.is_simple_order_Ici_iff_is_coatom]
apply OrderIso.is_simple_order_iff
exact Submodule.ComapMkq.relIso m
intro
exact IsSemisimpleModule.Sup_simples_eq_top
rw [← ker_eq_bot, ← ker_eq_top]
apply eq_bot_or_eq_top
rw [← range_eq_top, ← range_eq_bot, or_comm']
apply eq_bot_or_eq_top
rw [← is_simple_module_iff_is_coatom]
exact IsSimpleModule.congr (f.quot_ker_equiv_of_surjective hf)
rw [sup_comm, inf_comm]
exact (LinearMap.quotientInfEquivSupQuotient B A).symm
rw [Finset.coe_singleton]
exact Polynomial.adjoin_X
rw [Finset.coe_image, Finset.coe_univ, Set.image_univ]
exact MvPolynomial.adjoin_range_X
apply (Algebra.adjoin_le _ : _ ≤ Subalgebra.restrictScalars R (adjoin A ↑S))
simp only [Subalgebra.coe_restrict_scalars]
exact Algebra.subset_adjoin
infer_instance
rw [← Subalgebra.prod_top]
exact hA.1.Prod hB.1
rw [← f.comp_id]
exact (id A).comp_surjective hf
exact this (mem_span_support f)
intro s hs
exact Set.mem_Union₂.2 ⟨f, ⟨hf, hs⟩⟩
rw [this]
exact support_gen_of_gen hS
simp only [Finset.set_bUnion_coe, Finset.coe_bUnion]
rw [AlgHom.map_mul, hP₁, hP₂, of_apply, of_apply, of_apply, single_mul_single,
              one_mul] <;>
            rfl
simp only [hS, top_to_submodule, Submodule.mem_top]
exact this (mem_span_support f)
intro s hs
exact Set.mem_Union₂.2 ⟨f, ⟨hf, hs⟩⟩
rw [this]
exact support_gen_of_gen hS
simp only [Finset.set_bUnion_coe, Finset.coe_bUnion]
rw [AlgHom.map_mul, hP₁, hP₂, of_apply, of_apply, of_apply, single_mul_single, one_mul]
intro
simp
simp
rw [coe_power_series, of_power_series_apply_coeff]
refine' Eq.trans _ (congr rfl x.single_order_mul_power_series_part)
rw [← mul_assoc, single_mul_single, neg_add_self, mul_one, ← C_apply, C_one, one_mul,
    coe_power_series]
intro z
cases i
·
    rw [Int.nat_abs_of_nat_core, Int.ofNat_eq_coe, coeff_coe_power_series,
      if_neg (Int.coe_nat_nonneg _).not_lt]
· rw [coe_power_series, of_power_series_apply, emb_domain_notin_image_support,
      if_pos (Int.negSucc_lt_zero _)]
    simp only [not_exists, RelEmbedding.coe_fn_mk, Set.mem_image, not_and,
      Function.Embedding.coeFn_mk, Ne.def, to_power_series_symm_apply_coeff, mem_support,
      Int.coe_nat_eq, imp_true_iff, not_false_iff]
rw [trace_apply, LinearMap.trace_eq_matrix_trace _ b, ← to_matrix_lmul_eq]
rfl
rw [BilinForm.to_matrix_apply, trace_form_apply]
rw [PowerBasis.trace_gen_eq_next_coeff_minpoly, RingHom.map_neg, ←
    next_coeff_map (algebraMap K F).Injective,
    sum_roots_eq_next_coeff_of_monic_of_split ((minpoly.monic (PowerBasis.is_integral_gen _)).map _)
      ((splits_id_iff_splits _).2 hf),
    neg_neg]
rw [trace_eq_trace_adjoin K x, Algebra.smul_def, RingHom.map_mul, ← Algebra.smul_def,
    IntermediateField.AdjoinSimple.trace_gen_eq_sum_roots _ hF, IsScalarTower.algebra_map_smul]
apply NoZeroSmulDivisors.algebra_map_injective L (AlgebraicClosure L)
rw [map_sum (algebraMap L (AlgebraicClosure L))]
rw [← Fintype.sum_equiv (Normal.algHomEquivAut K (AlgebraicClosure L) L)]
· rw [← trace_eq_sum_embeddings (AlgebraicClosure L)]
    · simp only [algebra_map_eq_smul_one, smul_one_smul]
    · exact IsGalois.to_is_separable
· intro σ
    simp only [Normal.algHomEquivAut, AlgHom.restrictNormal', Equiv.coe_fn_mk,
      AlgEquiv.coe_of_bijective, AlgHom.restrict_normal_commutes, id.map_eq_id, RingHom.id_apply]
refine' AddEquiv.injective (transpose_add_equiv _ _ _) _
rw [transpose_add_equiv_apply, transpose_add_equiv_apply, ← vec_mul_transpose, ← transpose_map,
    trace_matrix_of_matrix_vec_mul, transpose_transpose, transpose_mul, transpose_transpose,
    transpose_mul]
rw [trace_matrix_eq_embeddings_matrix_mul_trans, embeddings_matrix_reindex, reindex_apply,
    transpose_submatrix, ← submatrix_mul_transpose_submatrix, ← Equiv.coe_refl, Equiv.refl_symm]
refine' mt (fun ht => _) this
rw [ht, RingHom.map_zero]
simp only [← det_mul, Matrix.mul_assoc, Matrix.transpose_mul]
simp only [Basis.to_matrix_mul_to_matrix_flip, Matrix.transpose_one, Matrix.mul_one,
          Matrix.det_one]
rw [add_comm, H]
rw [one_mul, zero_mul, add_zero]
rw [one_mul, zero_mul, zero_add]
let ⟨a, b, H⟩ := H1
rw [← mul_one y, ← H, mul_add, ← mul_assoc, mul_left_comm]
exact dvd_add (dvd_mul_left _ _) (H2.mul_left _)
let ⟨a, b, H⟩ := H1
rw [← one_mul z, ← H, add_mul, mul_right_comm, mul_assoc b]
exact dvd_add (dvd_mul_left _ _) (H2.mul_left _)
rw [h1, h2, mul_one]
rw [is_coprime_comm] at H1 H2⊢
exact H1.mul_left H2
rw [mul_comm] at H
exact H.of_mul_left_left
rw [is_coprime_comm] at H⊢
exact H.of_mul_left_left
rw [mul_comm] at H
exact H.of_mul_right_left
rw [is_coprime_comm, IsCoprime.mul_left_iff, is_coprime_comm, @is_coprime_comm _ _ z]
rw [← f.map_mul, ← f.map_mul, ← f.map_add, h, f.map_one]
rw [mul_comm] at h
exact h.of_add_mul_left_left
rw [is_coprime_comm] at h⊢
exact h.of_add_mul_left_left
rw [mul_comm] at h
exact h.of_add_mul_left_right
rw [add_comm] at h
exact h.of_add_mul_left_left
rw [add_comm] at h
exact h.of_add_mul_right_left
rw [add_comm] at h
exact h.of_add_mul_left_right
rw [add_comm] at h
exact h.of_add_mul_right_right
rw [mul_comm]
exact h.add_mul_left_left z
rw [is_coprime_comm]
exact h.symm.add_mul_left_left z
rw [is_coprime_comm]
exact h.symm.add_mul_right_left z
rw [add_comm]
exact h.add_mul_left_left z
rw [add_comm]
exact h.add_mul_right_left z
rw [add_comm]
exact h.add_mul_left_right z
rw [add_comm]
exact h.add_mul_right_right z
rw [Int.ofNat_one, ← H]
exact
          dvd_add (dvd_mul_of_dvd_right (Int.coe_nat_dvd.2 <| Nat.gcd_dvd_left m n) _)
            (dvd_mul_of_dvd_right (Int.coe_nat_dvd.2 <| Nat.gcd_dvd_right m n) _)
rw [mul_comm _ (m : ℤ), mul_comm _ (n : ℤ), ← Nat.gcd_eq_gcd_ab, show _ = _ from H,
        Int.ofNat_one]
rw [Finset.prod_insert hbt]
rw [Finset.forall_mem_insert] at H
exact H.1.mul_left (ih H.2)
rw [Finset.prod_insert hbt, IsCoprime.mul_left_iff, ih, Finset.forall_mem_insert]
rw [mem_sdiff, mem_singleton]
exact ⟨mem_insert_self _ _, fun ha => hat (ha.symm.cases_on hx)⟩
rw [← mul_sum, ← sum_mul, hμ, one_mul]
rw [← Finset.card_range m, ← Finset.prod_const]
exact IsCoprime.prod_left fun _ _ => H
rw [← Finset.card_range n, ← Finset.prod_const]
exact IsCoprime.prod_right fun _ _ => H
refine' ⟨fun h => _, IsCoprime.pow_left⟩
rw [← Finset.card_range m, ← Finset.prod_const] at h
exact h.of_prod_left 0 (finset.mem_range.mpr hm)
simp (config := { contextual := true })
rw [mul_comm, mul_right_mem_non_zero_divisors_eq_zero_iff hr]
refine' ⟨fun h => _, congr_arg _⟩
rw [← sub_eq_zero, ← mul_right_mem_non_zero_divisors_eq_zero_iff hr, sub_mul, h, sub_self]
apply (Ideal.quotientKerAlgEquivOfSurjective hg).symm.Injective
change _ = ((Ideal.quotientKerAlgEquivOfSurjective hg).symm.toAlgHom.comp f) x
rw [←
    formally_smooth.mk_lift _ hg' ((Ideal.quotientKerAlgEquivOfSurjective hg).symm.toAlgHom.comp f)]
apply (Ideal.quotientKerAlgEquivOfSurjective hg).Injective
rw [AlgEquiv.apply_symm_apply, Ideal.quotientKerAlgEquivOfSurjective,
    Ideal.quotientKerAlgEquivOfRightInverse.apply]
exact (Ideal.ker_lift_alg_mk _ _).symm
constructor
intro C _ _ I hI f₁ f₂ e'
rw [← f₁.comp_id, ← f₂.comp_id, ← e.comp_symm, ← AlgHom.comp_assoc, ← AlgHom.comp_assoc]
congr 1
refine' formally_unramified.comp_injective I hI _
rw [← AlgHom.comp_assoc, e', AlgHom.comp_assoc]
rw [← AlgHom.comp_assoc, e, AlgHom.comp_assoc]
rw [← AlgHom.comp_assoc, ← this, AlgHom.comp_assoc, hg, AlgHom.comp_id]
rw [AlgHom.ker_ker_sqare_lift, Ideal.cotangent_ideal_square, Ideal.zero_eq_bot]
rw [TensorProduct.smul_tmul', smul_eq_mul, mul_one]
induction n <;> simp [zero_mem, add_mem, one_mem, *]
rw [← nsmul_one]
exact nsmul_mem (one_mem _) _
cases p <;> cases q <;> congr
simp [Nat.cast] <;> rfl
simp [Nat.cast] <;> rfl
simp
simp
simp [← Submonoid.subsemiring_closure_to_add_submonoid, Submonoid.subsemiring_closure_eq_closure]
rw [List.map_singleton, List.sum_singleton, ht2]
rw [List.prod_append, ht2, hu2]
rw [List.map_append, List.sum_append, HL2, HM2]
simp [mem_prod, MonoidHom.coe_fst]
simp [mem_prod, MonoidHom.coe_snd]
simp [mem_supr_of_directed hS]
simp [mem_Sup_of_directed_on Sne hS]
rw [coe_srange, coe_top]
rw [← hx', h x']
simp only [zero_mul, mul_zero]
simp only [zero_mul, mul_zero]
simp only [one_mul, mul_one]
simp only [one_mul, mul_one]
simp only [add_mul, mul_add, h₁, h₂]
simp only [add_mul, mul_add, h₁, h₂]
rw [mul_assoc, h₂, ← mul_assoc, h₁, mul_assoc]
rw [← mul_assoc, h₁, mul_assoc, h₂, ← mul_assoc]
rw [pow_zero]
exact one_dvd _
rw [pow_zero]
exact one_dvd _
rw [PartEnat.coe_get]
rw [PartEnat.lt_coe_iff] at hm <;> exact Nat.find_spec hm.fst ((pow_dvd_pow _ hm.snd).trans h)
have : Finite a b := ⟨k, hsucc⟩
rw [PartEnat.le_coe_iff]
exact ⟨this, Nat.find_min' _ hsucc⟩
rw [← PartEnat.coe_inj, PartEnat.coe_get, Unique hk hsucc]
rw [pow_dvd_iff_le_multiplicity, not_le]
rw [PartEnat.lt_coe_iff]
exact ⟨h₁, lt_succ_self _⟩
rw [pow_zero]
exact one_dvd _
rw [PartEnat.get_eq_iff_eq_coe, eq_coe_iff, pow_zero]
simp [not_dvd_one_of_finite_one_right ha]
rw [← Nat.cast_zero, eq_coe_iff]
simp
rw [Ne.def, eq_top_iff_not_finite, not_not]
rw [lt_top_iff_ne_top, ne_top_iff_finite]
simp
rw [← PartEnat.coe_get (finite_iff_dom.1 hab)] <;>
        exact le_multiplicity_of_pow_dvd (h _ (pow_multiplicity_dvd _))
cases h <;> simp [*]
rw [mul_comm] <;> exact finite_of_finite_mul_right
simp only [pow_zero, one_dvd]
rw [pow_one]
exact fun h => mt (isUnit_of_dvd_unit h) ha hb
rw [finite_iff_dom, PartEnat.not_dom_iff_eq_top] at h this
rw [h, this]
rw [← Associates.mk_pow, Associates.mk_dvd_mk]
exact not_finite_iff_forall.mp h n
rw [min_eq_left h, multiplicity_le_multiplicity_iff] <;>
        exact fun n hn => dvd_add hn (multiplicity_le_multiplicity_iff.1 h n hn)
rw [min_eq_right h, multiplicity_le_multiplicity_iff] <;>
      exact fun n hn => dvd_add (multiplicity_le_multiplicity_iff.1 h n hn) hn
simp only [multiplicity, PartEnat.find, dvd_neg]
rw [PartEnat.coe_get] <;>
          exact
            Eq.symm
              (Unique ((dvd_neg _ _).2 (pow_multiplicity_dvd _))
                (mt (dvd_neg _ _).1 (is_greatest' _ (lt_succ_self _))))
simp [hs, pow_add, mul_comm, mul_assoc, mul_left_comm]
decide
rw [tsub_add_cancel_of_le (succ_le_of_lt hn0)] at hy <;>
                    simp [hy, pow_add, mul_comm, mul_assoc, mul_left_comm]
rw [tsub_add_eq_add_tsub (succ_le_of_lt hn0), tsub_add_cancel_of_le this]
clear _fun_match _fun_match finite_mul_aux
simp_all [mul_comm, mul_assoc, mul_left_comm, pow_add]
decide
rw [tsub_add_cancel_of_le (succ_le_of_lt hm0)] at hy <;>
                  simp [hy, pow_add, mul_comm, mul_assoc, mul_left_comm]
rw [add_assoc, tsub_add_cancel_of_le (succ_le_of_lt hm0)]
clear _fun_match _fun_match finite_mul_aux
simp_all [mul_comm, mul_assoc, mul_left_comm, pow_add]
simp [mt isUnit_iff_dvd_one.2 hp.2.1]
rw [pow_succ] <;> exact finite_mul hp ha (finite_pow ha)
simp
simp
clear _fun_match <;> simp_all
simp [pow_add]
rw [hpoweq] <;> apply mul_dvd_mul <;> assumption
rw [← PartEnat.coe_get (finite_iff_dom.1 h.1), ← PartEnat.coe_get (finite_iff_dom.1 h.2), ←
        PartEnat.coe_get (finite_iff_dom.1 (finite_mul hp h.1 h.2)), ← Nat.cast_add,
        PartEnat.coe_inj, multiplicity.mul' hp] <;>
      rfl
simp [one_right hp.not_unit]
rw [pow_succ]
simp [one_right hp.not_unit]
simp [pow_succ, succ_nsmul, pow, multiplicity.mul hp]
rw [multiplicity_le_multiplicity_iff] at hle
rw [← nonpos_iff_eq_zero, ← not_lt, PartEnat.pos_iff_one_le, ← Nat.cast_one, ←
    pow_dvd_iff_le_multiplicity]
intro h
have := Nat.dvd_gcd h (hle _ h)
rw [coprime.gcd_eq_one hab, Nat.dvd_one, pow_one] at this
exact hp this
rw [neg_sub, sub_smul, mul_smul, hr.2 n hn, one_smul, smul_zero, sub_zero]
rw [eq_smul_of_le_smul_of_le_jacobson hN hIN hIjac, Submodule.bot_smul]
rw [← map_smul'', this] <;> exact le_rfl
rw [← sup_eq_left, smul_sup_eq_smul_sup_of_le_smul_of_le_jacobson hN' hIJ hNN, bot_smul,
    sup_bot_eq]
rw [hs]
trivial
apply finite_stable_under_composition.respects_iso
intros
exact Finite.of_surjective _ e.to_equiv.surjective
apply surjective_stable_under_composition.respects_iso
intros
exact e.surjective
rw [hs]
trivial
rw [hq, degree_mul, hc0, zero_add, degree_pow, degree_X, nsmul_one, Nat.cast_with_bot]
rw [← coeff_zero_eq_eval_zero, ← eq_zero_iff_mem, ← coeff_map, coeff_zero_eq_eval_zero, hq,
    eval_mul, eval_pow, eval_X, zero_pow hn0, mul_zero]
rw [eq_C_of_degree_le_zero (nat_degree_eq_zero_iff_degree_le_zero.1 hpm), is_unit_C]
refine' hu _ _
rw [← eq_C_of_degree_le_zero (nat_degree_eq_zero_iff_degree_le_zero.1 hpm)]
exact dvd_mul_right _ _
simp_all only [not_true, Submodule.zero_mem, coeff_zero]
simp_all only [lt_irrefl]
intro hm0 hn0
refine' h0 _
rw [coeff_zero_eq_eval_zero, eval_mul, sq]
exact
        Ideal.mul_mem_mul (eval_zero_mem_ideal_of_eq_mul_X_pow hp hm0)
          (eval_zero_mem_ideal_of_eq_mul_X_pow hq hn0)
simp_all only [zero_mul, eq_self_iff_true, not_true, Ne.def]
simp_all only [eq_self_iff_true, not_true, Ne.def, mul_zero]
infer_instance
exact this.antisymm (H.2 ⟨inferInstance, bot_le⟩ this)
  intro x hx
rw [Ideal.mk_ker, e]
exact H.1.2
rw [minimalPrimes, ← Ideal.comap_minimal_primes_eq_of_surjective Ideal.Quotient.mk_surjective, ←
    RingHom.ker_eq_comap_bot, Ideal.mk_ker]
apply le_antisymm
· exact Inf_le ⟨LocalRing.le_maximal_ideal h, LocalRing.maximalIdeal.is_maximal R⟩
· exact le_Inf fun J (hJ : I ≤ J ∧ J.IsMaximal) => le_of_eq (LocalRing.eq_maximal_ideal hJ.2).symm
rw [hb]
exact Units.isUnit _
erw [Ideal.Quotient.eq_zero_iff_mem]
exact map_nonunit f a ha
simp only [map_map, RingEquiv.symm_comp, map_id, RingHom.id_apply]
simp only [map_map, RingEquiv.comp_symm, map_id, RingHom.id_apply]
constructor
intro a ha
rw [h, sub_zero] <;> exact isUnit_one
rw [smul_eq_mul]
exact e.ge
rw [Submodule.mem_annihilator]
constructor
· intro h n
    exact h _ (Submodule.subset_span n.prop)
· intro h n hn
    apply Submodule.span_induction hn
    · intro x hx
      exact h ⟨x, hx⟩
    · exact smul_zero _
    · intro x y hx hy
      rw [smul_add, hx, hy, zero_add]
    · intro a x hx
      rw [smul_comm, hx, smul_zero]
simp [mem_annihilator_span]
rw [add_smul, hy1, hy2]
rw [mul_comm, annihilator_mul]
rw [top_smul] at this
exact this (subset_span (Set.mem_singleton x))
rw [← I.span_eq, Submodule.span_smul_span, I.span_eq] <;> rfl
rw [← Submodule.mem_ideal_smul_span_iff_exists_sum, ← Set.image_eq_range]
change _ ↔ N.subtype x ∈ I
rw [Submodule.map_smul'', Submodule.map_top, Submodule.range_subtype]
refine' submodule.smul_le.mpr fun r hr x hx => _
rw [Submodule.mem_comap] at hx⊢
rw [f.map_smul]
exact Submodule.smul_mem_smul hr hx
erw [Submodule.one_eq_range, LinearMap.range_id]
unfold span
rw [Submodule.span_mul_span]
unfold span
rw [Submodule.span_mul_span, Set.singleton_mul_singleton]
simp only [mul_comm, mem_mul_span_singleton]
simp only [mem_span_singleton_mul]
simp only [span_singleton_mul_le_iff, mem_span_singleton_mul, eq_comm]
simp only [le_antisymm_iff, le_span_singleton_mul_iff, span_singleton_mul_le_iff]
simp only [le_antisymm_iff, span_singleton_mul_le_span_singleton_mul, eq_comm]
rw [mul_comm]
exact sup_mul_eq_of_coprime_left h
rw [sup_comm] at h
rw [sup_comm, sup_mul_eq_of_coprime_left h, sup_comm]
rw [sup_comm] at h
rw [sup_comm, sup_mul_eq_of_coprime_right h, sup_comm]
rw [one_eq_top, sup_top_eq]
rw [← Finset.card_range n, ← Finset.prod_const]
exact sup_prod_eq_top fun _ _ => h
rw [← Finset.card_range n, ← Finset.prod_const]
exact prod_sup_eq_top fun _ _ => h
induction n
· rw [pow_zero, pow_zero]
    exact rfl.le
· rw [pow_succ, pow_succ]
    exact Ideal.mul_mono e n_ih
cases h <;> rw [← Ideal.mul_bot, h, Ideal.mul_comm]
rw [le_antisymm_iff, and_iff_left le_radical, is_radical]
rw [pow_add, ← hpqrn, ← hcxq, ← hfgrk, ← hdyg, add_mul, mul_add (c * x),
                      mul_assoc c x (d * y), mul_left_comm x, ← mul_assoc] <;>
                    refine'
                      m.add_mem (m.mul_mem_right _ hpm)
                        (m.add_mem (m.mul_mem_left _ hfm) (m.mul_mem_left _ hxym))
rw [pow_succ, ih, top_mul]
decide
rw [pow_succ]
exact radical_mul _ _
rw [ih H]
refine' Set.Subset.trans hi <| Set.Subset.trans _ <| Set.subset_union_right _ _ <;>
            exact Set.subset_bUnion_of_mem (Finset.mem_coe.2 his)
rw [Finset.forall_mem_insert] at hp⊢
exact ⟨hp.1, hp.2.2⟩
rw [Finset.coe_insert] at h⊢
rw [Finset.coe_insert] at h
simp only [Set.bUnion_insert] at h⊢
rw [← Set.union_assoc ↑(f i)] at h
erw [Set.union_eq_self_of_subset_right hfji] at h
exact h
rw [Finset.coe_insert, Set.bUnion_insert, ← Set.union_assoc, Set.union_assoc ↑(f a)] at h
erw [Set.union_eq_self_of_subset_left Hb] at h
exact h
rw [mul_top, h]
rw [is_unit_iff.mp u.is_unit, one_eq_top]
simp only [Set.mem_preimage, SetLike.mem_coe, map_add, add_mem hx hy] at *
simp only [Set.mem_preimage, map_zero, SetLike.mem_coe, Submodule.zero_mem]
simp only [smul_eq_mul, Set.mem_preimage, map_mul, SetLike.mem_coe] at *
exact mul_mem_left I _ hx
rw [mem_comap, map_one] <;> exact (ne_top_iff_one _).1 hK
simp only [mem_comap, map_mul] <;> apply hK.2
rw [h, comap_top]
rw [infi_image]
refine' le_trans (fun x hx => _) bot_le
rw [mem_comap, Submodule.mem_bot, ← map_zero f] at hx
exact Eq.symm (hf hx) ▸ Submodule.zero_mem
rw [map_sub, hfsr, sub_self]
refine' or_iff_not_imp_left.2 fun ne_top => ⟨⟨fun h => ne_top h, fun J hJ => _⟩⟩
· refine'
      (rel_iso_of_surjective f hf).Injective
        (Subtype.ext_iff.2 (Eq.trans (H.1.2 (comap f J) (lt_of_le_of_ne _ _)) comap_top.symm))
    · exact map_le_iff_le_comap.1 (le_of_lt hJ)
    · exact fun h => hJ.right (le_map_of_comap_le_of_surjective f hf (le_of_eq h.symm))
simp [← RingEquiv.to_ring_hom_eq_coe, map_map]
simp [← RingEquiv.to_ring_hom_eq_coe, comap_comap]
rw [h]
rw [comap_top]
rw [map_mul] <;> exact mul_mem_mul (mem_map_of_mem f hri) (mem_map_of_mem f hsj)
rw [← map_mul] <;> exact mem_map_of_mem f (mul_mem_mul hri hsj)
rw [← hK.radical, comap_radical]
apply radical_is_radical
induction n
· rw [pow_zero, pow_zero, Ideal.one_eq_top, Ideal.one_eq_top]
    exact rfl.le
· rw [pow_succ, pow_succ]
    exact (Ideal.mul_mono_right n_ih).trans (Ideal.le_comap_mul f)
rw [mul_pow] at hxy
cases hi.2 hxy
· exact Or.inl ⟨m, h⟩
· exact Or.inr (mem_radical_of_pow_mem h)
dsimp [finsupp_total]
rw [Finsupp.total_apply, Finsupp.sum_map_range_index]
exact fun _ => zero_smul _ _
rw [finsupp_total_apply, Finsupp.sum_fintype]
exact fun _ => zero_smul _ _
simp only [basis_span_singleton, Basis.map_apply, LinearEquiv.trans_apply,
    Submodule.restrict_scalars_equiv_apply, LinearEquiv.of_injective_apply,
    LinearEquiv.coe_of_eq_apply, LinearEquiv.restrict_scalars_apply, Algebra.coe_lmul_eq_mul,
    LinearMap.mul_apply']
erw [Basis.constr_basis, Function.comp_apply, basis_span_singleton_apply, LinearMap.mul_apply']
rw [Associates.mk_ne_zero, Ideal.zero_eq_bot, Ne.def, Ideal.span_singleton_eq_bot]
rw [ker, Ideal.mem_comap, Submodule.mem_bot]
rw [RingHom.ker_eq_comap_bot, Ideal.comap_comap, RingHom.ker_eq_comap_bot]
rw [mem_ker, map_one]
exact one_ne_zero
rw [SetLike.ext'_iff, ker_eq, Set.ext_iff]
exact injective_iff_map_eq_zero' f
rw [← injective_iff_map_eq_zero f, injective_iff_ker_eq_bot]
rw [mem_ker, map_sub, sub_eq_zero]
rw [mem_ker, map_sub, h, sub_self]
rw [Ne.def, Ideal.eq_top_iff_one]
exact not_one_mem_ker f
rw [RingHom.ker, eq_bot_iff, map_le_iff_le_comap]
apply h J hJ
rw [RingHom.mem_ker, map_sub, hx, sub_self]
rw [map_eq_bot_iff_le_ker, (RingHom.injective_iff_ker_eq_bot f).mp hf, le_bot_iff]
simp only [RingHom.ker_equiv, bot_le]
rw [map_eq_bot_iff_le_ker, mk_ker]
exact h
rw [← (comap_injective_of_surjective f hf).eq_iff, comap_map_of_surjective f hf,
    comap_map_of_surjective f hf, RingHom.ker_eq_comap_bot]
rw [← mem_comap, comap_map_of_surjective (Quotient.mk'' I) quotient.mk_surjective, ←
    RingHom.ker_eq_comap_bot, mk_ker]
rw [mem_quotient_iff_mem_sup, sup_eq_left.mpr hIJ]
infer_instance
simp only [Function.comp_apply, RingHom.coe_comp, Ideal.quotient_map_mk]
rw [hIJ]
exact @le_comap_map _ S _ _ _ _ _ _
rw [hIJ]
exact le_of_eq (map_comap_of_equiv I f)
simp [hx, hy]
simp
simp only [quotient_map_mkₐ, quotient.mkₐ_eq_mk, AlgHom.comp_apply]
simp
simp
rw [← g.map_one, ← sub_eq_zero, ← g.map_sub, ← g.mem_ker]
apply hg
rw [f.mem_ker, f.map_sub, sub_eq_zero, f.map_one]
exact hf 1
intro x y
rw [← g.map_mul, ← sub_eq_zero, ← g.map_sub, ← g.mem_ker]
apply hg
rw [f.mem_ker, f.map_sub, sub_eq_zero, f.map_mul]
simp only [hf _]
simp [(mem_ker _).mp hx]
simp only [mk_ker, sup_idem, sup_comm, quot_left_to_quot_sup, quotient.factor, ker_quotient_lift,
    map_eq_iff_sup_ker_eq_of_surjective I quotient.mk_surjective, ← sup_assoc]
rw [RingHom.ker_eq_comap_bot, quot_quot_mk, ← comap_comap, ← RingHom.ker, mk_ker,
    comap_map_of_surjective (Ideal.Quotient.mk I) quotient.mk_surjective, ← RingHom.ker, mk_ker,
    sup_comm]
simp [h]
simp
rw [← Set.singleton_zero, span_singleton_eq_bot]
rw [← Set.singleton_one, span_singleton_one]
rw [lt_iff_le_not_le] <;>
          exact
            ⟨fun H x h hx₁ hx₂ => J.eq_top_iff_one.1 <| H ⟨h, not_subset.2 ⟨_, hx₂, hx₁⟩⟩,
              fun H ⟨h₁, h₂⟩ =>
              let ⟨x, xJ, xI⟩ := not_subset.1 h₂
              J.eq_top_iff_one.2 <| H x h₁ xI xJ⟩
apply CompleteLattice.coatomic_of_top_compact
rw [← span_singleton_one]
exact Submodule.singletonSpanIsCompactElement 1
simp [mem_span_insert, mem_span_singleton', @eq_comm _ _ z]
rw [eq_comm, mul_comm]
rw [← dvd_dvd_iff_associated, le_antisymm_iff, and_comm']
apply and_congr <;> rw [span_singleton_le_span_singleton]
rw [mul_comm, span_singleton_mul_right_unit h2]
rw [isUnit_iff_dvd_one, ← span_singleton_le_span_singleton, span_singleton_one, eq_top_iff]
simp [is_prime_iff, Prime, span_singleton_eq_top, hp, mem_span_singleton]
rw [lt_iff_le_not_le, span_singleton_le_span_singleton, span_singleton_le_span_singleton,
    dvd_and_not_dvd_iff]
decide
rw [add_mul, one_mul, add_assoc, add_comm n 1, ← add_assoc, add_tsub_assoc_of_le h]
rw [span_le, Set.singleton_subset_iff]
exact subset_span ⟨x, x.prop, rfl⟩
rw [or_iff_not_imp_right]
change _ ≠ _ → _
rw [Ideal.ne_top_iff_one]
intro h1
rw [eq_bot_iff]
intro r hr
rw [← h] <;> simp
intro H
rw [Ideal.span_singleton_eq_top] at H
contradiction
intro c hc
rw [Submodule.mem_annihilator_span_singleton] at hc⊢
rw [smul_comm, hc, smul_zero]
rw [mul_sub, sub_mul, sub_add_sub_cancel, mul_comm, mul_comm b₁]
simp [Nat.cast]
simp [Nat.cast] <;> rfl
rw [eq_top_iff_one, ← subsingleton_iff_zero_eq_one, eq_comm, ← I, quotient.eq_zero_iff_mem]
simp
rw [← Eq, sub_add_eq_sub_sub_swap, sub_self, zero_sub] <;> exact I.neg_mem hi
skip
infer_instance
rw [dif_neg ha] <;> exact Classical.choose_spec (exists_inv ha)
    inv_zero
intro c₁ m₁ c₂ m₂ hc hm
apply Ideal.Quotient.eq.2
rw [Submodule.quotient_rel_r_def] at hc hm
intro i
exact I.mul_sub_mul_mem hc (hm i)
rw [hrs] <;> rfl
simp [infi, inf_comm]
simp
simp
refine' trans (ideal_prod_eq _) _
simp [map_map]
simp
simp only [← ideal_prod_equiv_symm_apply, ideal_prod_equiv.symm.injective.eq_iff, Prod.mk.inj_iff]
rw [Prod.mk_mul_mk, mul_one, mem_prod]
exact ⟨hxy, trivial⟩
apply @is_prime_of_is_prime_prod_top _ R
rw [← map_prod_comm_prod]
exact map_is_prime_of_equiv _
rw [← map_prod_comm_prod]
apply map_is_prime_of_equiv _
exact is_prime_ideal_prod_top
simp
simp [hJ]
simp [hI]
delta cotangent
constructor
intro s s' x
rw [← @IsScalarTower.algebra_map_smul S' R, ← @IsScalarTower.algebra_map_smul S' R, ← smul_assoc,
    ← IsScalarTower.to_alg_hom_apply S S' R, map_smul]
rfl
delta cotangent
infer_instance
simp [Ideal.toCotangent, Submodule.map_smul'', pow_two]
rw [← I.map_to_cotangent_ker]
simp
rw [← sub_eq_zero, ← map_sub]
exact I.mem_to_cotangent_ker
constructor
· intro H
    refine' (pow_two I).symm.trans (le_antisymm (Ideal.pow_le_self two_ne_zero) _)
    exact fun x hx => (I.to_cotangent_eq_zero ⟨x, hx⟩).mp (Subsingleton.elim _ _)
·
    exact fun e =>
      ⟨fun x y =>
        (Quotient.inductionOn₂' x y) fun x y =>
          I.to_cotangent_eq.mpr <| ((pow_two I).trans e).symm ▸ I.sub_mem x.Prop y.Prop⟩
rw [← Submodule.map_le_iff_le_comap, Submodule.map_smul'', Submodule.map_top,
        Submodule.range_subtype, smul_eq_mul, pow_two]
exact rfl.le
rw [← to_quotient_square_range]
exact LinearMap.mem_range_self _ _
refine' { Ideal.Quotient.lift (f.to_ring_hom.ker ^ 2) f.to_ring_hom _ with commutes' := _ }
· intro a ha
    exact Ideal.pow_le_self two_ne_zero ha
· intro r
    rw [IsScalarTower.algebra_map_apply R A, RingHom.toFun_eq_coe, Ideal.Quotient.algebra_map_eq,
      Ideal.Quotient.lift_mk]
    exact f.map_algebra_map r
refine' (Ideal.quotEquivOfEq (Ideal.map_eq_submodule_map _ _).symm).trans _
refine' (DoubleQuot.quotQuotEquivQuotSup _ _).trans _
exact Ideal.quotEquivOfEq (sup_eq_right.mpr <| Ideal.pow_le_self two_ne_zero)
rw [← p.div_X_mul_X_add, eval₂_add, eval₂_C, eval₂_mul, eval₂_X] at hp
refine' mem_comap.mpr ((I.add_mem_iff_right _).mp hp)
exact I.mul_mem_left _ hr
rw [quotient.algebra_map_eq, quotient.algebra_map_quotient_map_quotient,
      quotient.mk_algebra_map]
simp [quotient.eq_zero_iff_mem]
refine' eq_bot_iff.2 fun x hx => _
induction on this
let quot := R
simp [hIP]
simp [SetLike.ext_iff]
simp
simp
simp only [← Ideal.span_singleton_le_iff_mem, ← Ideal.dvd_iff_le, pow_succ, ←
    Ideal.span_singleton_mul_span_singleton] at a_not_mem ab_mem⊢
exact (prime_pow_succ_dvd_mul (Ideal.prime_of_is_prime hP P_prime) ab_mem).resolve_left a_not_mem
simp [ideal.is_unit_iff.mp hI, Ideal.mul_top]
rw [card_quot_mul]
rw [Ideal.one_eq_top, card_quot_top]
rw [Ideal.zero_eq_bot, card_quot_bot]
rw [← Ideal.zero_eq_bot, _root_.map_zero]
rw [← Ideal.one_eq_top, _root_.map_one]
rw [abs_norm_apply, card_quot_eq_one_iff]
infer_instance
intro i
rw [f_apply, b'.equiv_apply, Equiv.refl_apply, ab_eq]
intro c i
simp only [← MulAction.mul_smul, b'.repr_sum_self, mul_comm]
rw [LinearMap.det_to_matrix]
rw [Matrix.det_diagonal]
rw [Basis.det_comp_basis]
rw [Algebra.norm_apply]
rw [abs_norm_span_singleton]
intro x
change e.to_linear_map.restrict_scalars R x = f'.to_linear_map x
congr 1
apply TensorProduct.ext'
intro x y
simp [IsBaseChange.equiv_tmul, Algebra.smul_def]
refine'
        Polynomial.splits_of_splits_of_dvd _
          (Polynomial.map_ne_zero <| minpoly.ne_zero H1 : Polynomial.map (algebraMap _ _) _ ≠ 0)
          ((Polynomial.splits_map_iff _ _).2 _) (minpoly.dvd _ _ _)
· rw [← IsScalarTower.algebra_map_eq]
        exact H2
· rw [Polynomial.aeval_map_algebra_map, minpoly.aeval]
rw [← hp']
exact subset_span hx
rw [← hq']
exact subset_span hy
rw [ht]
exact hx
rw [Algebra.top_to_submodule, eq_top_iff, ← hs, span_le]
exact Algebra.subset_adjoin
rw [Finset.coe_image, Algebra.adjoin_image, hs]
rw [← Algebra.adjoin_image, Finset.coe_preimage, Set.image_preimage_eq_of_subset, hs]
rw [← AlgHom.coe_range, ← Algebra.adjoin_le_iff, hs, ← Algebra.map_top]
exact map_mono le_top
rw [← S.range_val, ← Algebra.map_top]
exact fg.map _ h
rw [Algebra.map_top, range_val]
exact h
rw [adjoin_restrict_scalars C E, adjoin_restrict_scalars C D, ← hS, ← hT, ← Algebra.adjoin_image,
    ← Algebra.adjoin_image, ← AlgHom.coe_to_ring_hom, ← AlgHom.coe_to_ring_hom,
    IsScalarTower.coe_to_alg_hom, IsScalarTower.coe_to_alg_hom, ← adjoin_union_eq_adjoin_adjoin, ←
    adjoin_union_eq_adjoin_adjoin, Set.union_comm]
rw [Finset.coe_union, Finset.coe_image, Algebra.adjoin_union_eq_adjoin_adjoin,
      Algebra.adjoin_algebra_map, hs, Algebra.map_top, IsScalarTower.adjoin_range_to_alg_hom, ht,
      Subalgebra.restrict_scalars_top]
refine' adjoin_induction hb _ (fun r => _) (Hadd_right a) (Hmul_right a)
·
    exact
      adjoin_induction ha Hs Halg_left (fun x y Hx Hy z hz => Hadd_left x y z (Hx z hz) (Hy z hz))
        fun x y Hx Hy z hz => Hmul_left x y z (Hx z hz) (Hy z hz)
·
    exact
      adjoin_induction ha (Halg_right r) (fun r' => Halg r' r)
        (fun x y => Hadd_left x y ((algebraMap R A) r)) fun x y =>
        Hmul_left x y ((algebraMap R A) r)
refine' Exists.elim _ fun (hx : x ∈ adjoin R s) (hc : p ⟨x, hx⟩) => hc
exact
      adjoin_induction hx (fun x hx => ⟨subset_adjoin hx, Hs x hx⟩)
        (fun r => ⟨Subalgebra.algebra_map_mem _ r, Halg r⟩)
        (fun x y hx hy =>
          (Exists.elim hx) fun hx' hx =>
            (Exists.elim hy) fun hy' hy => ⟨Subalgebra.add_mem _ hx' hy', Hadd _ _ hx hy⟩)
        fun x y hx hy =>
        (Exists.elim hx) fun hx' hx =>
          (Exists.elim hy) fun hy' hy => ⟨Subalgebra.mul_mem _ hx' hy', Hmul _ _ hx hy⟩
refine'
    eq_top_iff.2 fun x =>
      adjoin_induction' (fun a ha => _) (fun r => _) (fun _ _ => _) (fun _ _ => _) x
· exact subset_adjoin ha
· exact Subalgebra.algebra_map_mem _ r
· exact Subalgebra.add_mem _
· exact Subalgebra.mul_mem _
apply GaloisConnection.l_bot
exact Algebra.gc
rw [adjoin_eq_span, span_le]
rw [commutes]
simp only [add_mul, mul_add, h₁, h₂]
simp only [add_mul, mul_add, h₁, h₂]
rw [mul_assoc, h₂, ← mul_assoc y₁, ← h₁, mul_assoc x₁]
rw [mul_assoc x₂, ← h₂, ← mul_assoc x₂, ← h₁, ← mul_assoc]
rw [adjoin_eq_span, adjoin_eq_span, adjoin_eq_span, span_mul_span]
congr 1
apply le_antisymm (adjoin_le _)
· exact adjoin_mono subset_adjoin
· change adjoin R s ≤ (adjoin A s).restrictScalars R
    refine' adjoin_le _
    exact subset_adjoin
intro i
rw [← B.basis.sum_repr x, ← B.basis.sum_repr y, Finset.sum_mul_sum, LinearEquiv.map_sum,
    Finset.sum_apply']
refine' IsIntegral.sum _ fun I hI => _
simp only [Algebra.smul_mul_assoc, Algebra.mul_smul_comm, LinearEquiv.map_smulₛₗ,
    RingHom.id_apply, Finsupp.coe_smul, Pi.smul_apply, id.smul_eq_mul]
refine' is_integral_mul (hy _) (is_integral_mul (hx _) _)
simp only [coe_basis, ← pow_add]
refine' repr_gen_pow_is_integral hB hmin _ _
intro i j
rw [B.basis.to_matrix_apply, B'.coe_basis]
refine' repr_pow_is_integral hB (fun i => _) hmin _ _
rw [← h, aeval_eq_sum_range, LinearEquiv.map_sum, Finset.sum_apply']
refine' IsIntegral.sum _ fun n hn => _
rw [Algebra.smul_def, IsScalarTower.algebra_map_apply R K S, ← Algebra.smul_def,
    LinearEquiv.map_smul, algebra_map_smul]
exact is_integral_smul _ (repr_gen_pow_is_integral hB hmin _ _)
intro n
dsimp only [c, Nat.rec_add_one]
rfl
      -- we now spend some time determining properties of the sequence `c : ℕ → R`
      -- `hc_mod`: for every `n`, we have `c n ≡ a₀ [SMOD I]`
      -- `hf'c`  : for every `n`, `f'.eval (c n)` is a unit
      -- `hfcI`  : for every `n`, `f.eval (c n)` is contained in `I ^ (n+1)`
exact IsHausdorff.haus' _ this
        intro n
        specialize ha n
        rw [← Ideal.one_eq_top, Ideal.smul_eq_mul, mul_one]
rw [coeff_smul] at hc
apply ha
intro h
apply hc
rw [h]
exact smul_zero r
apply is_homogeneous_monomial
simp only [Finsupp.zero_apply, Finset.sum_const_zero]
apply is_homogeneous_monomial
simp only [Finsupp.support_single_ne_zero _ one_ne_zero, Finset.sum_singleton]
exact Finsupp.single_eq_same
simp only [C_mul', LinearMap.map_smul]
apply homogeneous_component_eq_zero'
rw [total_degree, Finset.sup_lt_iff] at h
· intro d hd
    exact ne_of_lt (h d hd)
· exact lt_of_le_of_lt (Nat.zero_le _) h
rw [AlgHom.map_mul, ha, hb]
rw [AlgHom.map_add, ha, hb]
rw [← map_rename, hφ]
simp only [esymm, powerset_len_zero, sum_singleton, prod_empty]
simp [Finset.powerset_len_map, -Finset.map_univ_equiv]
rw [Finset.map_univ_equiv]
intro
rw [rename_esymm]
rw [support_esymm']
exact bUnion_singleton
rw [aeval_def, aeval_def, eval₂_map, IsScalarTower.algebra_map_eq R A B]
rw [aeval_def, aeval_def, ← coe_eval₂_hom, ← coe_eval₂_hom, map_eval₂_hom, ←
    IsScalarTower.algebra_map_eq]
rw [aeval_algebra_map_apply, Algebra.algebra_map_eq_smul_one, smul_eq_zero,
    iff_false_intro (one_ne_zero' B), or_false_iff]
rw [aeval_algebra_map_apply, ← (algebraMap A B).map_zero, h.eq_iff]
rw [← C_eq_coe_nat, ← C_0, C_inj, CharP.cast_eq_zero_iff R p]
rw [total_degree, Finset.sup_le_iff]
rfl
rw [restrict_degree, Finsupp.mem_supported]
rfl
simp only [mem_restrict_degree, degrees, Multiset.count_finset_sup, Finsupp.count_to_multiset,
    Finset.sup_le_iff]
exact ⟨fun h n s hs => h s hs n, fun h s hs n => h n s hs⟩
refine' eq_bot_iff.trans _
constructor
· rw [is_integrally_closed_iff K]
    intro h x hx
    exact set.mem_range.mp (algebra.mem_bot.mp (h hx))
    assumption
· intro h x hx
    rw [Algebra.mem_bot, Set.mem_range]
    exact is_integral_iff.mp hx
rw [IsDedekindDomain.HeightOneSpectrum.maxPowDividing, int.coe_nat_eq_zero.mp h_zero,
        pow_zero _]
have h_ne_zero := Associates.finprod_ne_zero I
have hv : Irreducible (Associates.mk v.as_ideal) := v.associates_irreducible
have h_dvd := finprod_mem_dvd v (Ideal.finite_mul_support hI)
have h_not_dvd := Ideal.finprod_not_dvd v I hI
simp only [IsDedekindDomain.HeightOneSpectrum.maxPowDividing] at h_dvd h_ne_zero h_not_dvd
rw [← Associates.mk_dvd_mk, Associates.dvd_eq_le, Associates.mk_pow,
    Associates.prime_pow_dvd_iff_le h_ne_zero hv] at h_dvd h_not_dvd
rw [not_le] at h_not_dvd
apply Nat.eq_of_le_of_lt_succ h_dvd h_not_dvd
change _ = _ * _
rw [Units.val_inv_eq_inv_val]
change _ = ite _ _ _ * (ite (coe _ = _) _ _)
rw [← WithZero.coe_inj, valuation_of_ne_zero_to_fun_eq]
exact map_one _
rw [← WithZero.coe_inj, WithZero.coe_mul]
simp only [valuation_of_ne_zero_to_fun_eq]
exact map_mul _ _ _
rw [valuation_of_ne_zero_mod, MonoidHom.comp_apply, ← QuotientGroup.coe_mk',
    QuotientGroup.map_mk', valuation_of_unit_eq, QuotientGroup.coe_one, map_one]
rw [map_one]
rw [map_mul, hx v hv, hy v hv, one_mul]
rw [map_inv, hx v hv, inv_one]
simp only [pow_monoid_hom_apply, map_pow]
refine' le_trans _ (IsIntegralClosure.range_le_span_dual_basis (integralClosure A L) b hb_int)
intro x hx
exact ⟨⟨x, hx⟩, rfl⟩
refine' mt ((injective_iff_map_eq_zero (algebraMap A L)).mp _ _) hy
rw [IsScalarTower.algebra_map_eq A K L]
exact (algebraMap K L).Injective.comp (IsFractionRing.injective A K)
simp only [mem_inv_iff hI, mem_inv_iff hJ]
exact fun h y hy => h y (hIJ hy)
rw [inv_eq, FractionalIdeal.map_div, FractionalIdeal.map_one, inv_eq]
constructor
· intro hI hg
    apply FractionalIdeal.ne_zero_of_mul_eq_one _ _ hI
    rw [FractionalIdeal.eq_span_singleton_of_principal I, hg, FractionalIdeal.span_singleton_zero]
· intro hg
    apply invertible_of_principal
    rw [FractionalIdeal.eq_span_singleton_of_principal I]
    intro hI
    have := FractionalIdeal.mem_span_singleton_self _ (generator (I : Submodule R₁ K))
    rw [hI, FractionalIdeal.mem_zero_iff] at this
    contradiction
apply FractionalIdeal.coe_to_submodule_injective
simp
refine' is_noetherian_ring_iff.mpr ⟨fun I : Ideal A => _⟩
rw [← h.inv_mul_eq_one M'_ne]
exact FractionalIdeal.mul_left_mono _ ((coe_ideal_le_coe_ideal (FractionRing A)).mpr hM.le)
apply hle
rw [Multiset.prod_cons]
exact Submodule.smul_mem_smul h_Iy hbZ
rw [mem_inv_iff (FractionalIdeal.coe_ideal_ne_zero hI)]
intro y hy
rw [one_mul]
exact coe_ideal_le_one hy
assumption
apply mul_inv_cancel_of_le_one hI0
infer_instance
rw [← hmul, h, mul_one]
rw [← Associates.dvd_eq_le, ← Associates.mk_pow, Associates.mk_dvd_mk, Ideal.dvd_span_singleton]
rw [gcd_eq_normalize _ _, normalize_eq]
· rw [dvd_iff_le, sup_le_iff, ← dvd_iff_le, ← dvd_iff_le]
      exact ⟨gcd_dvd_left _ _, gcd_dvd_right _ _⟩
· rw [dvd_gcd_iff, dvd_iff_le, dvd_iff_le]
      simp
rw [lcm_eq_normalize _ _, normalize_eq]
· rw [lcm_dvd_iff, dvd_iff_le, dvd_iff_le]
      simp
· rw [dvd_iff_le, le_inf_iff, ← dvd_iff_le, ← dvd_iff_le]
      exact ⟨dvd_lcm_left _ _, dvd_lcm_right _ _⟩
simp only [zero_eq_bot, bot_inf_eq]
simp only [zero_eq_bot, inf_bot_eq]
rw [associated_iff_eq, sup_mul_inf]
rw [← associated_iff_eq.mp (gcd_mul_lcm I J), lcm_eq_inf I J, gcd_eq_sup, coprime, top_mul]
apply normalized_factors_prod_of_prime
intro p hp
rw [mem_inter] at hp
exact prime_of_normalized_factor p hp.left
rw [sup_eq_prod_inf_factors (pow_ne_zero n hJ.ne_zero) hI, ← inf_eq_inter,
    normalized_factors_of_irreducible_pow hJ, normalize_eq J, repeat_inf, prod_repeat]
have : J.ker ≤ comap J (map f (map I X)) := ker_le_comap J
rw [mk_ker] at this
exact dvd_iff_le.mpr this
exact le_sup_of_le_left this
    rwa [map_le_iff_le_comap, comap_map_of_surjective I quotient.mk_surjective, ←
      RingHom.ker_eq_comap_bot, mk_ker, sup_eq_left.mpr <| le_of_dvd hY]
simp only [idealFactorsFunOfQuotHom, map_id, OrderHom.coe_fun_mk, OrderHom.id_coe, id.def,
        comap_map_of_surjective J quotient.mk_surjective, ← RingHom.ker_eq_comap_bot J, mk_ker,
        sup_eq_left.mpr (dvd_iff_le.mp X.prop), Subtype.coe_eta]
refine' OrderHom.ext _ _ (funext fun x => _)
rw [idealFactorsFunOfQuotHom, idealFactorsFunOfQuotHom, OrderHom.comp_coe, OrderHom.coe_fun_mk,
    OrderHom.coe_fun_mk, Function.comp_apply, idealFactorsFunOfQuotHom, OrderHom.coe_fun_mk,
    Subtype.mk_eq_mk, Subtype.coe_mk, map_comap_of_surjective J quotient.mk_surjective, map_map]
simp only [← ideal_factors_fun_of_quot_hom_id, OrderHom.coe_eq, OrderHom.coe_eq,
        ideal_factors_fun_of_quot_hom_comp, ← RingEquiv.to_ring_hom_eq_coe, ←
        RingEquiv.to_ring_hom_eq_coe, ← RingEquiv.to_ring_hom_trans, RingEquiv.symm_trans_self,
        RingEquiv.to_ring_hom_refl]
simp only [← ideal_factors_fun_of_quot_hom_id, OrderHom.coe_eq, OrderHom.coe_eq,
        ideal_factors_fun_of_quot_hom_comp, ← RingEquiv.to_ring_hom_eq_coe, ←
        RingEquiv.to_ring_hom_eq_coe, ← RingEquiv.to_ring_hom_trans, RingEquiv.self_trans_symm,
        RingEquiv.to_ring_hom_refl]
rw [dvd_iff_le, dvd_iff_le, Subtype.coe_le_coe, this, Subtype.mk_le_mk]
rw [ideal_factors_equiv_of_quot_equiv_symm]
exact
        ideal_factors_equiv_of_quot_equiv_mem_normalized_factors_of_mem_normalized_factors f.symm hI
          j.prop
simp
simp
rw [normalizedFactorsEquivOfQuotEquiv, Equiv.coe_fn_mk, Subtype.coe_mk]
exact
    multiplicity_factor_dvd_iso_eq_multiplicity_of_mem_normalized_factor hI hJ hL
      fun ⟨l, hl⟩ ⟨l', hl'⟩ => ideal_factors_equiv_of_quot_equiv_is_dvd_iso f hl hl'
cases n
· simp
simp only [← Ideal.dvd_iff_le] at coprime hJ hK⊢
simp only [← prod_eq, Finset.inf_eq_infi, Finset.mem_univ, cinfi_pos, ←
            IsDedekindDomain.inf_prime_pow_eq_prod _ _ _ (fun i _ => Prime i) fun i _ j _ =>
              coprime i j]
rw [Multiset.map_id']
rw [finite_iff_dom, PartEnat.not_dom_iff_eq_top] at h this
rw [h, this]
rw [Ideal.span_singleton_pow, span_singleton_dvd_span_singleton_iff_dvd]
exact not_finite_iff_forall.mp h n
simp only [normalizedFactorsEquivSpanNormalizedFactors, multiplicity_eq_multiplicity_span,
    Subtype.coe_mk, Equiv.of_bijective_apply]
rw [int_valuation_def, if_neg hx]
exact WithZero.coe_ne_zero
rw [v.int_valuation_def_if_neg (nonZeroDivisors.coe_ne_zero x)]
exact WithZero.zero_lt_coe _
rw [int_valuation_def]
rw [Ne.def, Ideal.zero_eq_bot, Ideal.span_singleton_eq_bot]
exact hr
apply v.irreducible
apply v.associates_irreducible
apply v.associates_irreducible
simp only [int_valuation_def]
apply associates.mk_ne_zero'.mpr hx
apply associates.mk_ne_zero'.mpr hy
apply v.associates_irreducible
rw [le_max_iff, of_add_le, of_add_le, neg_le_neg_iff, neg_le_neg_iff, Int.ofNat_le, Int.ofNat_le,
    ← min_le_iff]
rw [← Associates.le_singleton_iff x nmin _,
            Associates.prime_pow_dvd_iff_le (associates.mk_ne_zero'.mpr hx) _]
exact min_le_left _ _
apply v.associates_irreducible
rw [← Associates.le_singleton_iff y nmin _,
            Associates.prime_pow_dvd_iff_le (associates.mk_ne_zero'.mpr hy) _]
exact min_le_right _ _
apply v.associates_irreducible
rw [Associates.le_singleton_iff]
exact Ideal.add_mem (v.as_ideal ^ nmin) h_dvd_x h_dvd_y
rw [← Ideal.dvd_not_unit_iff_lt]
exact
      ⟨v.ne_bot, v.as_ideal, (not_congr Ideal.is_unit_iff).mpr (Ideal.IsPrime.ne_top v.is_prime),
        sq v.as_ideal⟩
rw [Associates.mk_ne_zero']
intro h
rw [h] at nmem
exact nmem (Submodule.zero_mem (v.as_ideal ^ 2))
rw [valuation_def, Valuation.extend_to_localization_apply_map_apply]
rw [valuation_of_algebra_map]
exact v.int_valuation_le_one r
rw [valuation_of_algebra_map]
exact v.int_valuation_lt_one_iff_dvd r
simp [hx]
rw [← hbc, mul_comm]
rw [insert_union, htus]
simp [hbc, prod_insert hit, mul_assoc, mul_comm, mul_left_comm]
rw [union_insert, htus]
simp [← hbc, prod_insert hiu, mul_assoc, mul_comm, mul_left_comm]
rw [← card_disjoint_union htu, htus, card_range]
simp
simp only [← zsmul_one, zsmul_mem, one_mem]
cases p <;> cases q <;> congr
simp
simp
simp only [infi, coe_Inf, Set.bInter_range]
simp only [infi, mem_Inf, Set.forall_range_iff]
refine'
    closure_induction hb _ (H0_right _) (H1_right _) (Hadd_right a) (Hneg_right a) (Hmul_right a)
refine' closure_induction ha Hs (fun x _ => H0_left x) (fun x _ => H1_left x) _ _ _
· exact fun x y H₁ H₂ z zs => Hadd_left x y z (H₁ z zs) (H₂ z zs)
· exact fun x hx z zs => Hneg_left x z (hx z zs)
· exact fun x y H₁ H₂ z zs => Hmul_left x y z (H₁ z zs) (H₂ z zs)
rw [zero_mul q]
apply AddSubgroup.zero_mem _
rw [add_mul p₁ p₂ q]
apply AddSubgroup.add_mem _ ihp₁ ihp₂
simp
rw [mul_zero x]
apply AddSubgroup.zero_mem _
rw [mul_add x q₁ q₂]
apply AddSubgroup.add_mem _ ihq₁ ihq₂
simp
simp only [mul_zero, zero_mul]
simp only [mul_zero, zero_mul]
simp only [mul_one, one_mul]
simp only [mul_one, one_mul]
simp only [mul_neg, neg_mul, hxy]
simp only [mul_neg, neg_mul, hxy]
simp only [add_mul, mul_add, h₁, h₂]
simp only [add_mul, mul_add, h₁, h₂]
rw [← mul_assoc, ← h₁, mul_assoc x₁ y x₂, ← h₂, mul_assoc]
rw [← mul_assoc, h₁, mul_assoc, h₂, ← mul_assoc]
simp
simp [hl2, hm2]
simp
simp (config := { contextual := true }) [List.map_cons, add_comm]
simp [mem_prod, MonoidHom.coe_fst]
simp [mem_prod, MonoidHom.coe_snd]
simp [mem_supr_of_directed hS]
simp [mem_Sup_of_directed_on Sne hS]
rw [coe_range, coe_top]
rw [← hx', h x']
rw [List.map_cons, List.sum_cons]
exact ha this (ih HL.2)
rw [List.prod_cons, List.prod_cons, HP]
rw [List.prod_cons, hhd, neg_one_mul, HP]
rw [List.prod_cons, List.prod_cons, HP, neg_mul_eq_mul_neg]
rw [List.prod_cons, hhd, HP, neg_one_mul, neg_neg]
simp
simp
simp
cases p <;> cases q <;> congr
simp_all
simp_all
simp
simp
simp [← Subsemigroup.non_unital_subsemiring_closure_to_add_submonoid,
    Subsemigroup.non_unital_subsemiring_closure_eq_closure]
simp [mem_prod, MonoidHom.coe_fst]
simp [mem_prod, MonoidHom.coe_snd]
simp [mem_supr_of_directed hS]
simp [mem_Sup_of_directed_on Sne hS]
rw [coe_srange, coe_top]
rw [← hx', h x']
rw [mul_comm n s, mul_comm m s, h]
rw [mul_comm]
apply Quotient.sound
refine' ⟨s, t * s, _, _⟩ <;> dsimp <;> rw [mul_assoc] <;> rfl
simp [← mul_assoc]
rw [hr₂]
simp [← mul_assoc]
rw [h]
simp [← mul_assoc]
rw [hr₂]
simp [← mul_assoc]
rw [← hs₂, ← S.coe_mul]
exact SetLike.coe_mem (s₂ * u)
simp
simp
rw [← mul_assoc, ← h₂, ← h₁, mul_assoc, h₃]
simp only [mul_assoc]
rw [mul_assoc, mul_assoc, ← mul_assoc ↑s₂', ← h₃, ← mul_assoc]
exact S.mul_mem hr (SetLike.coe_mem s_flat)
simp [← mul_assoc, h₂]
simp
simp
cases s <;> apply OreLocalization.div_eq_one'
simp
simp
simp
simp
simp
simp
simp
simp only [← hf, SetLike.coe_mk, MonoidHom.map_mul]
rw [OreLocalization.one_def, lift_expand_of] <;> simp
simp [numerator_hom_apply, universal_mul_hom_apply]
simp [mul_comm]
simp
rw [← mul_assoc, ← hb, mul_assoc, ← hc, ← mul_assoc, ← mul_assoc, ha]
rw [← mul_assoc, ← hb, mul_assoc, ← hc, ← mul_assoc, ← ha, mul_assoc]
simp
simp
induction x using OreLocalization.ind
rw [← zero_div_eq_zero, add_ore_div]
simp
rw [OreLocalization.add_comm, OreLocalization.zero_add]
simp
simp
simp [ha, ← mul_assoc]
simp
rw [← ha] <;> apply SetLike.coe_mem
rw [MonoidHom.to_fun_eq_coe, OreLocalization.zero_def, universal_mul_hom_apply]
simp
rw [← h₃]
exact SetLike.coe_mem (s₁ * s₃)
simp [numerator_hom_apply, universal_hom_apply]
rw [neg_mul_eq_neg_mul, ← OreLocalization.expand]
rw [OreLocalization.one_def, OreLocalization.zero_def] at h
apply nonZeroDivisors.coe_ne_zero 1 (numerator_hom_inj hS h).symm
intro r t s hst
rw [OreLocalization.zero_def, OreLocalization.inv_def]
simp
infer_instance
have h : (AlgHom.comp (↑e) f).toRingHom = e.to_alg_hom.to_ring_hom.comp f.to_ring_hom := rfl
have h1 : ↑e.to_ring_equiv = e.to_alg_hom.toRingHom := rfl
rw [h, h1]
cases nonempty_fintype ι <;>
    exact
      let eqv := (MvPolynomial.renameEquiv R <| Fintype.equivFin ι).symm
      ⟨Fintype.card ι, eqv, eqv.Surjective,
        ((RingHom.injective_iff_ker_eq_bot _).1 eqv.Injective).symm ▸ Submodule.fg_bot⟩
infer_instance
refine' add_mem _ hq
rw [hs] at this
exact this hx
rw [adjoin_range_X]
trivial
rw [← f.comp_id]
exact (id A).comp_surjective hf hker
simp only [Algebra.smul_def, RingHom.map_mul, mul_assoc]
rfl
simp
simp
simp
rw [← Ideal.span_singleton_le_span_singleton] at hx hy⊢
rw [span_gcd, Ideal.span_insert, sup_le_iff]
exact ⟨hx, hy⟩
rw [← span_gcd]
apply Ideal.subset_span
simp
dsimp
intro p
rw [AlgHom.mem_range]
refine' ⟨MvPolynomial.rename (cod_restrict x (range x) mem_range_self) p, _⟩
simp [Function.comp, aeval_rename]
intro s li
apply Cardinal.card_le_of
intro t
rw [← Finset.card_map (embedding.subtype s)]
apply H
apply algebraic_independent_finset_map_embedding_subtype _ li
simp
apply @algebraic_independent_comp_subtype _ _ _ id
simp
have h : IsScalarTower R (MvPolynomial ι R) (Polynomial (MvPolynomial ι R)) :=
    @Polynomial.is_scalar_tower (MvPolynomial ι R) _ R _ _ _ _ _ _ _
rw [AlgebraicIndependent.mv_polynomial_option_equiv_polynomial_adjoin_apply, aeval_C,
    @IsScalarTower.algebra_map_apply _ _ _ _ _ _ _ _ _ h, ← Polynomial.C_eq_algebra_map,
    Polynomial.map_C, RingHom.coe_coe, AlgEquiv.commutes]
rw [AlgebraicIndependent.mv_polynomial_option_equiv_polynomial_adjoin_apply, aeval_X,
    Option.elim', Polynomial.map_X]
rw [AlgebraicIndependent.mv_polynomial_option_equiv_polynomial_adjoin_apply, aeval_X,
    Option.elim', Polynomial.map_C, RingHom.coe_coe]
erw [algebraic_independent_iff_injective_aeval, is_algebraic_iff_not_injective, not_not, ←
    AlgHom.coe_to_ring_hom, ← hx.aeval_comp_mv_polynomial_option_equiv_polynomial_adjoin,
    RingHom.coe_comp, injective.of_comp_iff' _ (RingEquiv.bijective _), AlgHom.coe_to_ring_hom]
rw [h]
exact ⟨none, rfl⟩
rw [algebraic_independent_empty_type_iff]
exact RingHom.injective _
intro j
simp [mul_comm]
rw [discr_def, trace_matrix_of_matrix_vec_mul, det_mul, det_mul, det_transpose, mul_comm, ←
    mul_assoc, discr_def, pow_two]
rw [discr_def, trace_matrix_of_matrix_mul_vec, det_mul, det_mul, det_transpose, mul_comm, ←
    mul_assoc, discr_def, pow_two]
rw [discr_def, RingHom.map_det, RingHom.map_matrix_apply,
    trace_matrix_eq_embeddings_matrix_reindex_mul_trans, det_mul, det_transpose, pow_two]
simp [Nat.succ_le_iff, Fin.is_lt]
rw [← AlgHom.card K L E, ← Fintype.card_fin pb.dim]
exact card_congr (Equiv.symm e)
simp
rw [← hn, Nat.one_le_iff_ne_zero, ← zero_lt_iff, FiniteDimensional.finrank_pos_iff]
infer_instance
refine' equiv_of_card_eq _
rw [Fintype.card_fin, AlgHom.card]
exact (PowerBasis.finrank pb).symm
simp at hi
simp [hij.1]
rw [← RingHom.map_one (algebraMap ℤ ℚ)] at this
exact (IsFractionRing.injective ℤ ℚ) this
congr
exact trace_matrix_of_basis_mul_vec _ _
congr 1
exact Multiset.map_add _ _ _
simp
rw [← Multiset.map_map, ← AddMonoidHom.map_multiset_sum]
exact F.congr_arg (Multiset.sum_map_singleton x')
rw [RingHom.map_neg, RingHom.map_one, f.map_neg, f.map_one]
rw [RingHom.map_add, f.map_add, ihx, ihy]
rw [RingHom.map_mul, f.map_mul, ihx, ihy]
rw [Int.cast_add, Int.cast_one] <;> exact is_supported_add hi is_supported_one
rw [Int.cast_sub, Int.cast_one] <;> exact is_supported_sub hi is_supported_one
rw [H]
rw [(FreeMonoid.lift _).map_mul, FreeMonoid.lift_eval_of, ih]
rfl
have :
        (coe_ring_hom _ : FreeRing α → FreeCommRing α) =
          Functor.mapEquiv FreeAbelianGroup (Multiset.subsingletonEquiv α) :=
        coe_eq α
rw [this]
apply Equiv.bijective
rw [← (subsingleton_equiv_free_comm_ring α).symm_apply_apply (y * x),
        (subsingleton_equiv_free_comm_ring α).map_mul, mul_comm, ←
        (subsingleton_equiv_free_comm_ring α).map_mul,
        (subsingleton_equiv_free_comm_ring α).symm_apply_apply]
simp
rw [aeval_C]
rfl
rw [AlgHom.map_add, RingHom.map_add, ihp, ihq]
rw [AlgHom.map_mul, aeval_C, AlgHom.map_pow, aeval_X, RingHom.map_mul, mk_C, RingHom.map_pow,
      mk_X]
rfl
rw [← algebra_map_eq, ← aeval_def, aeval_eq, mk_self]
rw [is_root, eval_map, eval₂_root]
rw [root, lift_mk, eval₂_X]
rw [← mk_C x, lift_mk, eval₂_C]
have h : ϕ.to_ring_hom.comp (of f) = algebraMap R S := ring_hom.ext_iff.mpr ϕ.commutes
rw [aeval_def, ← h, ← RingHom.map_zero ϕ.to_ring_hom, ← eval₂_root f, hom_eval₂]
rfl
exact (AlgHom.ext fun x => (set_like.ext_iff.mp this x).mpr Algebra.mem_top).symm
rw [← f.commutes, ← f.map_mul, algebra_map_eq, root_is_inv, map_one]
rw [← g.commutes, ← g.map_mul, algebra_map_eq, root_is_inv, map_one]
rw [← commutes, RingHom.comp_apply, mk_self, RingHom.map_zero]
rw [power_basis_gen, minpoly_root hf]
rw [minpoly_power_basis_gen hf', hf.leading_coeff, inv_one, C.map_one, mul_one]
simp [← Subalgebra.coe_eq_zero, aeval_subalgebra_coe]
simp [← Subalgebra.coe_eq_zero, aeval_subalgebra_coe]
simp
rw [lift_hom_mk, pb.lift_aeval, aeval_eq]
rw [power_basis_gen, minpoly_root hf, Polynomial.map_mul, roots_mul, Polynomial.map_C,
        roots_C, add_zero, Equiv.refl_apply]
· rw [← Polynomial.map_mul]
        exact map_monic_ne_zero (monic_mul_leading_coeff_inv hf)
rw [of, AdjoinRoot.mk, Ideal.map_map]
rw [quot_map_of_equiv_quot_map_C_map_span_mk, Ideal.quot_equiv_of_eq_symm, quot_equiv_of_eq_mk]
rw [map_span, Set.image_singleton, RingEquiv.coe_to_ring_hom,
        polynomial_quotient_equiv_quotient_polynomial_map_mk I f]
simp only [polynomial.quot_quot_equiv_comm, quotient_equiv_mk,
    polynomial_quotient_equiv_quotient_polynomial_map_mk]
simp only [polynomial.quot_quot_equiv_comm, quotient_equiv_symm_mk,
    polynomial_quotient_equiv_quotient_polynomial_symm_mk]
rw [map_span, Set.image_singleton]
rw [quot_adjoin_root_equiv_quot_polynomial_quot, RingEquiv.trans_apply, RingEquiv.trans_apply,
    RingEquiv.trans_apply, quot_map_of_equiv_quot_map_C_map_span_mk_mk,
    quot_map_C_map_span_mk_equiv_quot_map_C_quot_map_span_mk_mk, quot_quot_mk, RingHom.comp_apply,
    quot_equiv_of_eq_mk, polynomial.quot_quot_equiv_comm_symm_mk_mk]
rw [quot_adjoin_root_equiv_quot_polynomial_quot, RingEquiv.symm_trans_apply,
    RingEquiv.symm_trans_apply, RingEquiv.symm_trans_apply, RingEquiv.symm_symm,
    polynomial.quot_quot_equiv_comm_mk, Ideal.quot_equiv_of_eq_symm, Ideal.quot_equiv_of_eq_mk, ←
    RingHom.comp_apply, ← DoubleQuot.quotQuotMk,
    quot_map_C_map_span_mk_equiv_quot_map_C_quot_map_span_mk_symm_quot_quot_mk,
    quot_map_of_equiv_quot_map_C_map_span_mk_symm_mk]
rw [AdjoinRoot.quot_equiv_quot_map_apply,
    AdjoinRoot.quot_adjoin_root_equiv_quot_polynomial_quot_mk_of]
rw [AdjoinRoot.quot_equiv_quot_map_symm_apply,
    AdjoinRoot.quot_adjoin_root_equiv_quot_polynomial_quot_symm_mk_mk]
rw [AdjoinRoot.aeval_eq, AdjoinRoot.mk_self]
rw [Ideal.map_map, AlgEquiv.to_ring_equiv_eq_coe, ←
                      AlgEquiv.coe_ring_hom_commutes, ← AdjoinRoot.algebra_map_eq,
                      AlgHom.comp_algebra_map]
rw [← Ideal.Quotient.mk_algebra_map, Ideal.quotient_equiv_apply, RingHom.toFun_eq_coe,
            Ideal.quotient_map_mk, AlgEquiv.to_ring_equiv_eq_coe, RingEquiv.coe_to_ring_hom,
            AlgEquiv.coe_ring_equiv, AlgEquiv.commutes, quotient.mk_algebra_map]
rw [PowerBasis.quotientEquivQuotientMinpolyMap, AlgEquiv.trans_apply,
    AlgEquiv.of_ring_equiv_apply, quotient_equiv_mk, AlgEquiv.coe_ring_equiv',
    AdjoinRoot.equiv'_symm_apply, PowerBasis.lift_aeval, AdjoinRoot.aeval_eq,
    AdjoinRoot.quot_equiv_quot_map_apply_mk]
simp only [quotient_equiv_quotient_minpoly_map, to_ring_equiv_eq_coe, symm_trans_apply,
    quot_equiv_quot_map_symm_apply_mk, of_ring_equiv_symm_apply, quotient_equiv_symm_mk,
    to_ring_equiv_symm, RingEquiv.symm_symm, AdjoinRoot.equiv'_apply, coe_ring_equiv, lift_hom_mk,
    symm_to_ring_equiv]
simp
rw [support, support_nonempty_iff, Ne.def, coeff_fun_eq_zero_iff]
rw [← single_coeff_same a r, ← single_coeff_same a s, rs]
rw [order_of_ne hx]
exact x.is_wf_support.min_mem (support_nonempty_iff.2 hx)
rw [emb_domain]
dsimp only
rw [Function.support_neg]
exact x.is_pwo_support
simp
rw [mul_coeff]
apply sum_subset_zero_on_sdiff (add_antidiagonal_mono_right hys) _ fun _ _ => rfl
intro b hb
simp only [not_and, mem_sdiff, mem_add_antidiagonal, mem_support, not_imp_not] at hb
rw [hb.2 hb.1.1 hb.1.2.2, mul_zero]
rw [mul_coeff]
apply sum_subset_zero_on_sdiff (add_antidiagonal_mono_left hxs) _ fun _ _ => rfl
intro b hb
simp only [not_and', mem_sdiff, mem_add_antidiagonal, mem_support, not_ne_iff] at hb
rw [hb.2 ⟨hb.1.2.1, hb.1.2.2⟩, zero_mul]
simp [hx]
rw [← add_zero a, mul_single_coeff_add, add_zero]
rw [← add_zero a, single_mul_coeff_add, add_zero]
apply le_antisymm
· apply order_le_of_coeff_ne_zero
    rw [mul_coeff_order_add_order x y]
    exact mul_ne_zero (coeff_order_ne_zero hx) (coeff_order_ne_zero hy)
· rw [order_of_ne hx, order_of_ne hy, order_of_ne (mul_ne_zero hx hy), ← Set.IsWf.min_add]
    exact Set.IsWf.min_le_min_of_subset support_mul_subset_add_support
rw [single_mul_single, zero_add]
simp
simp only [Function.Embedding.coeFn_mk]
exact Nat.cast_le
simp
simp [order_of_ne]
rw [add_val_apply_of_ne (ne_zero_of_coeff_ne_zero h), WithTop.coe_le_coe]
exact order_le_of_coeff_ne_zero h
change f1 = f2 at h
subst h
rw [← Set.Union_union_distrib]
exact Set.Union_mono fun a => support_add_subset
simp
simp
simp only [neg_coeff', Pi.neg_apply, Ne.def, neg_eq_zero]
exact s.finite_co_support g
apply (x.is_pwo_support.add s.is_pwo_Union_support).mono
refine' Set.Subset.trans (Set.Union_mono fun a => support_mul_subset_add_support) _
intro g
simp only [Set.mem_Union, exists_imp]
exact fun a ha => (Set.add_subset_add (Set.Subset.refl _) (Set.subset_Union _ a)) ha
rw [← lsum_apply, LinearMap.map_sub, lsum_apply, lsum_apply]
rw [Finsupp.mem_support_iff, ← support_nonempty_iff]
exact ⟨g, hg⟩
refine' s.is_pwo_Union_support.mono (Set.Union_subset fun b g h => _)
intro b h
rw [emb_domain_apply, dif_pos (Set.mem_range_self a)]
exact congr rfl (f.injective (Classical.choose_spec (Set.mem_range_self a)))
rw [emb_domain_apply, dif_neg h]
have hpwo := is_pwo_Union_support_powers hx
apply summable_family.ext fun n => _
cases n
· rw [emb_domain_notin_range, sub_apply, coe_powers, pow_zero, coe_of_finsupp,
      Finsupp.single_eq_same, sub_self]
    rw [Set.mem_range, not_exists]
    exact Nat.succ_ne_zero
· refine' Eq.trans (emb_domain_image _ ⟨Nat.succ, Nat.succ_injective⟩) _
    simp only [pow_succ, coe_powers, coe_sub, smul_apply, coe_of_finsupp, Pi.sub_apply]
    rw [Finsupp.single_eq_of_ne n.succ_ne_zero.symm, sub_zero]
refine' (congr rfl (dif_neg x0)).trans _
have h :=
        summable_family.one_sub_self_mul_hsum_powers
          (unit_aux x (inv_mul_cancel (coeff_order_ne_zero x0)))
rw [sub_sub_cancel] at h
rw [← mul_assoc, mul_comm x, h]
rw [zero_smul]
apply Quotient.sound'
rw [inv_zero]
apply Setoid.refl'
intro α β
have := dvd_total p q
rw [Irreducible.dvd_comm hp hq, or_self_iff] at this
exact associated_of_dvd_dvd (Irreducible.dvd_symm hq hp this) this
simp
simp
simp
constructor
intro a b
constructor
intro a b
rw [← one_mul (v _), ← hvx, ← v.map_mul, ← hu, u.mul_inv, hu, hvx, v.map_one]
rw [RingHom.map_mul, RingHom.map_one, hr1, hr2, Units.mul_inv]
rw [RingHom.map_mul, RingHom.map_one, hr1, hr2, Units.inv_mul]
let ⟨z, hz⟩ := h
rw [← mul_one (v (algebraMap O R x)), hz, RingHom.map_mul, v.map_mul]
exact mul_le_mul_left' (hv.2 z) _
rw [← v.map_one, ← inv_mul_cancel hy, v.map_mul, v.map_mul]
exact mul_le_mul_left' h _
refine'
    Finset.induction_on s (fun _ => trans_rel_right (· ≤ ·) v.map_zero zero_le')
      (fun a s has ih hf => _) hf
rw [Finset.forall_mem_insert] at hf
rw [Finset.sum_insert has]
exact v.map_add_le hf.1 (ih hf.2)
refine'
    Finset.induction_on s (fun _ => trans_rel_right (· < ·) v.map_zero (zero_lt_iff.2 hg))
      (fun a s has ih hf => _) hf
rw [Finset.forall_mem_insert] at hf
rw [Finset.sum_insert has]
exact v.map_add_lt hf.1 (ih hf.2)
simp only [comp_app, map_add, f.map_add]
rw [sub_eq_add_neg]
rw [map_neg]
rw [sub_eq_add_neg]
exact v.map_add_le hx (le_trans (le_of_eq (v.map_neg y)) hy)
simp
rw [add_comm]
exact map_add_eq_of_lt_right _ h
subst h
rw [H.le_iff_le]
rw [H.le_iff_le]
intro x y
rw [one_mul]
simp
simp
constructor
· intro h x
    simp only [lt_iff_le_and_ne,
      and_congr ((is_equiv_iff_val_le_one _ _).1 h) ((is_equiv_iff_val_eq_one _ _).1 h).Not]
· rw [is_equiv_iff_val_eq_one]
    intro h x
rw [is_equiv_iff_val_lt_one]
exact (Equiv.subRight 1).Surjective.forall
rw [h]
trivial
show v x = 0 ∨ v y = 0
change v (x * y) = 0 at hxy
rw [v.map_mul x y] at hxy
exact eq_zero_or_eq_zero_of_mul_eq_zero hxy
intro a' s' h'
refine' le_trans (v.map_add a' s') (max_le le_rfl _)
simp [h']
simp
simp
rw [mem_supp_iff, Ideal.mem_comap, mem_supp_iff]
rfl
rw [comap_supp, ← Ideal.map_le_iff_le_comap]
simp
rw [supp_quot]
exact Ideal.map_quotient_self _
intro b hb
exact Irreducible.associated_of_dvd hx' (hf₁ b hb) ((H b).mp (hf₁ b hb).1)
rw [Ideal.radical_eq_Inf]
apply le_antisymm
· exact Inf_le ⟨hle, inferInstance⟩
· refine'
          le_Inf fun I hI =>
            (eq_maximal_ideal <| IsDedekindDomain.dimension_le_one _ (fun e => ha₂ _) hI.2).ge
        rw [← Ideal.span_singleton_eq_bot, eq_bot_iff, ← e]
        exact hI.1
rw [← this]
apply Ideal.exists_radical_pow_le_of_fg
exact IsNoetherian.noetherian _
intro m hm
rw [← Ideal.mem_span_singleton']
apply Nat.find_spec this
rw [hn, pow_succ']
exact Ideal.mul_mem_mul hb₁ hm
rw [← mul_div_right_comm, ← map_mul, ← hk, map_mul, mul_div_cancel _ ha₃]
have ne_bot := Ring.ne_bot_of_is_maximal_of_not_is_field maximal_ideal.is_maximal R h
        classical
          rw [ finrank_eq_one_iff' ]
            tfae_have 1 → 2
            · intro infer_instance
            tfae_have 2 → 1
            ·
              intro
                haveI
rw [ hx ]
refine' sup_le le_sup_left _
                        rintro m hm
                        obtain ⟨ c , hc ⟩
rw [ LocalRing.jacobson_eq_maximal_ideal ]
cases x
cases y
congr
infer_instance
infer_instance
infer_instance
intro c
rw [c, A.valuation.map_zero] at h
exact zero_ne_one h
rw [← valuation_le_one_iff, map_inv₀, h, inv_one]
rw [LocalRing.mem_maximal_ideal]
dsimp [nonunits]
rw [valuation_eq_one_iff]
exact (A.valuation_le_one a).lt_iff_ne.symm
apply
    Localization.subalgebra.is_localization_of_field K P.prime_compl
      P.prime_compl_le_non_zero_divisors
rw [← IsLocalization.AtPrime.is_unit_to_map_iff (A.of_prime P) P x, valuation_eq_one_iff]
rfl
rw [h]
exact R.zero_mem
apply of_prime_le_of_le
exact h
rw [h]
rw [is_equiv_iff_val_le_one]
intro x
rw [ValuationSubring.valuation_le_one_iff]
rfl
constructor
· intro h x hx
    rw [← A.valuation_le_one_iff x, le_iff_lt_or_eq] at hx
constructor
· intro h x hx
intro a b ha hb
refine' lt_of_le_of_lt _ (max_lt hb ha)
rw [← one_mul (A.valuation (b - 1)), ← A.valuation.map_one_add_of_lt ha, add_sub_cancel'_right,
      ← Valuation.map_mul, mul_sub_one, ← sub_add_sub_cancel]
exact A.valuation.map_add _ _
simp
constructor
· intro h x hx
simp
simp
rfl
simp [ValuationSubring.mem_or_inv_mem]
rw [coeff_add]
exact Ideal.add_mem _ (hf i) (hg i)
apply forall_congr'
intro a
rw [mem_support_iff, Iff.comm, imp_iff_right_iff, Ne.def, ← imp_iff_not_or]
exact fun e => e.symm ▸ (I ^ a).zero_mem
simp (config := { contextual := true }) [mem_rees_algebra_iff_support, coeff_monomial, ←
    imp_iff_not_or]
dsimp [to_fun_bilinear_apply_apply, aeval_def, eval₂_eq_sum, Polynomial.sum]
rw [Finset.smul_sum]
congr
rw [to_fun_linear_tmul_apply, to_fun_bilinear_apply_apply, Polynomial.aeval_one, algebra_map_smul,
    Algebra.algebra_map_eq_smul_one]
dsimp [to_fun_alg_hom]
rw [to_fun_linear_tmul_apply, to_fun_bilinear_apply_eq_sum]
simp only [inv_fun, eval₂_add]
apply Polynomial.induction_on' x
· intro p q hp hq
    simp only [inv_fun_add, AlgHom.map_add, hp, hq]
· intro n a
    rw [inv_fun_monomial, Algebra.TensorProduct.include_left_apply, Algebra.TensorProduct.tmul_pow,
        one_pow, Algebra.TensorProduct.tmul_mul_tmul, mul_one, one_mul, to_fun_alg_hom_apply_tmul,
        X_pow_eq_monomial, sum_monomial_index] <;>
      simp
simp
rw [← eq_top_iff, ← @Submodule.restrict_scalars_eq_top_iff Rₛ R, eq_top_iff, ← b.span_eq]
apply Submodule.span_le_restrict_scalars
rw [coe_submodule, Submodule.map_bot]
rw [coe_submodule, Submodule.map_top, Submodule.one_eq_range]
rw [IsLocalization.coeSubmodule, Ideal.span, Submodule.map_span]
rfl
rw [coe_submodule_span, Set.image_singleton]
rw [is_noetherian_ring_iff, is_noetherian_iff_well_founded] at h⊢
exact OrderEmbedding.wellFounded (IsLocalization.orderEmbedding M S).dual h
rw [mk'_one, _root_.map_one, one_smul]
rw [mk'_one, _root_.map_one, one_smul]
rw [h, mk'_num_denom]
rw [h, mk'_num_denom]
rw [h]
rw [zero_mul, h, RingHom.map_zero]
simp
simp [hy.right]
rw [← mul_assoc, hc]
exact I.mul_mem_right c b.2
rw [is_prime_iff_is_prime_disjoint M S, comap_map_of_is_prime_disjoint M S I hp hd]
exact ⟨hp, hd⟩
simp [Ideal.Quotient.eq_zero_iff_mem, this]
rw [← RingHom.map_mul, ← mk'_eq_mul_mk'_one, mk'_self, RingHom.map_one]
rw [mul_comm, sec_spec]
rw [hx, (algebraMap R S).map_zero] at h
exact (IsUnit.mul_left_eq_zero (IsLocalization.map_units S y)).1 h
rw [← mk'_spec S x y, ← IsUnit.mul_left_inj (IsLocalization.map_units S y), right_distrib]
rw [← (map_units S s).mul_left_inj, mk'_spec, zero_mul, map_eq_zero_iff M]
rw [eq_comm, IsLocalization.eq_mk'_iff_mul_eq, zero_mul, map_zero]
rw [← mk'_mul, mul_comm] <;> exact mk'_self _ _
rw [mul_comm, ← one_mul z₁, ← Units.inv_mul (IsUnit.liftRight (g.to_monoid_hom.restrict M) h y),
    mul_assoc, ← mul_add, Units.inv_mul_eq_iff_eq_mul, Units.inv_mul_cancel_left,
    IsUnit.coe_liftRight]
simp only [RingHom.toMonoidHom_eq_coe, MonoidHom.restrict_apply, [anonymous]]
show _ * _ * _ + _ = _ ↔ _ = _
erw [mul_comm, ← mul_assoc, mul_add_inv_left hg, mul_comm]
rfl
rw [f.comp_algebra_map, g.comp_algebra_map]
rw [← map_comp_map hy hl] <;> rfl
rw [Algebra.smul_def, Algebra.smul_def, RingHom.map_mul, map_eq]
intro a
induction a
induction default
congr
rfl
rfl
unfold Add.add Localization.add
apply lift_on₂_mk
simp only [smul_mk, zero_nsmul, mk_zero]
simp only [smul_mk, succ_nsmul, add_mk_self]
simp only [← Localization.mk_zero 1, Localization.smul_mk, smul_zero]
intros
simp only [Localization.smul_mk, zero_smul, mk_zero]
intros
simp only [Localization.smul_mk, add_smul, add_mk_self]
rw [← mk_zero (1 : M), mk_one_eq_monoid_of_mk]
simp only [← mk_one_eq_monoid_of_mk, add_mk, Submonoid.coe_one, one_mul, add_comm]
intro r x
dsimp
simp only [← mk_one_eq_monoid_of_mk, mk_mul, Localization.smul_mk, one_mul,
          Algebra.smul_def]
intro r x
dsimp
simp only [← mk_one_eq_monoid_of_mk, mk_mul, Localization.smul_mk, one_mul, mul_one,
          Algebra.commutes]
rw [mk_eq_monoid_of_mk'_apply, mk', to_localization_map_eq_monoid_of]
rw [mk_eq_mk', mk'_eq_iff_eq_mul, Submonoid.coe_one, map_one, mul_one] <;> rfl
rw [mk_eq_mk', alg_equiv_mk']
rw [mk_eq_mk', alg_equiv_symm_mk']
unfold Neg.neg Localization.neg
apply lift_on_mk
simp only [smul_mk, zero_zsmul, mk_zero]
simp [smul_mk, add_mk_self, -mk_eq_monoid_of_mk', add_comm (n : ℤ) 1, add_smul]
rw [smul_mk, smul_mk, neg_mk, ← neg_smul]
rfl
rw [neg_mk]
have hsec := sec_spec M x
intro hfst
rw [hfst, map_zero, mul_eq_zero, _root_.map_eq_zero_iff] at hsec
· exact Or.elim hsec hx (sec_snd_ne_zero hM x)
· exact IsLocalization.injective S hM
apply NoZeroDivisors.toIsDomain _
·
    exact
      ⟨⟨(algebraMap A S) 0, (algebraMap A S) 1, fun h =>
          zero_ne_one (IsLocalization.injective S hM h)⟩⟩
· exact no_zero_divisors_of_le_non_zero_divisors _ hM
erw [eq_mk'_iff_mul_eq, ← map_mul, mul_assoc, mul_comm n, hn, mul_one]
simp
refine' ⟨fun a b h => _, Set.surjective_onto_range⟩
refine' (IsLocalization.lift_injective_iff _).2 (fun a b => _) (Subtype.ext_iff.1 h)
exact
            ⟨fun h => congr_arg _ (IsLocalization.injective _ hS h), fun h =>
              congr_arg _ (IsFractionRing.injective A K h)⟩
dsimp only [Localization.subalgebra]
rw [Subalgebra.copy_eq]
infer_instance
dsimp only [Localization.subalgebra.ofField]
rw [Subalgebra.copy_eq]
infer_instance
rw [← (IsLocalization.map_units S x).mul_left_inj]
simp
rw [dif_neg hx, ←
      IsUnit.mul_left_inj
        (map_units K
          ⟨(sec _ x).1,
            mem_non_zero_divisors_iff_ne_zero.2 fun h0 =>
              hx <| eq_zero_of_fst_eq_zero (sec_spec (nonZeroDivisors A) x) h0⟩),
      one_mul, mul_assoc]
rw [mk'_spec, ← eq_mk'_iff_mul_eq]
exact (mk'_sec _ x).symm
infer_instance
rw [h, mk'_zero]
rw [hxy, mk'_self']
simp only [mk'_eq_div, map_div₀, lift_algebra_map]
apply nontrivial_of_ne
intro h
apply @zero_ne_one R
exact
    IsLocalization.injective S (le_of_eq rfl)
      (((algebraMap R S).map_zero.trans h).trans (algebraMap R S).map_one.symm)
rw [Localization.mk_eq_mk', IsFractionRing.mk'_eq_div]
rw [IsScalarTower.algebra_map_eq R A]
exact
        Function.Injective.comp (NoZeroSmulDivisors.algebra_map_injective _ _)
          (NoZeroSmulDivisors.algebra_map_injective _ _)
rw [hIJ, hJK, Ideal.comap_comap f g]
simp only [Function.comp_apply, RingHom.coe_comp, local_ring_hom_to_map]
rw [mul_mk'_eq_mk'_of_mul, mk'_self]
simp
simp only [map_sub, map_mul, aeval_C, aeval_X, IsLocalization.Away.mul_inv_self, aeval_one,
        sub_self]
apply localization_localization_is_localization_of_has_all_units M p.prime_compl T
intro x hx hx'
exact (Hp.1 : ¬_) (p.eq_top_of_is_unit_mem hx' hx)
intro a ha
rw [mem_non_zero_divisors_iff_ne_zero]
exact fun h => ha (h.symm ▸ x.zero_mem)
simp only [coeff_integer_normalization, h, mem_support_iff, eq_self_iff_true, not_true, Ne.def,
    dif_neg, not_false_iff]
simp (config := { contextual := true }) [integer_normalization, coeff_monomial,
    coeff_integer_normalization_of_not_mem_support]
rw [coeff_map, coeff_smul]
exact hb i
rw [hb, ← IsScalarTower.algebra_map_smul S (b : R) p, eval₂_smul, hx, mul_zero]
rw [aeval_def, IsScalarTower.algebra_map_eq R S R', integer_normalization_eval₂_eq_zero _ _ _ hx]
simp [h]
rw [Polynomial.lifts_iff_coeff_lifts]
intro n
rw [Polynomial.coeff_scale_roots]
rw [IsScalarTower.algebra_map_apply A C L, h, RingHom.map_zero]
rw [SetLike.coe_mk, algebra_map_mk', ← IsScalarTower.algebra_map_apply A C L, hxy]
induction i
· simp
· rw [pow_succ, mul_smul, Nat.succ_eq_add_one, add_assoc, add_comm 1, ← add_assoc]
    exact (Submodule.smul_mono_right i_ih).trans (F.smul_le _)
rw [add_comm, pow_add, mul_smul]
exact Submodule.smul_mono_right (F.pow_smul_le i j)
rw [add_comm, pow_add, mul_smul]
exact Submodule.smul_le_right
rw [add_comm, pow_add, mul_smul, pow_one]
exact le_refl _
rw [← Submodule.span_closure, submodule_closure_single]
simp
rw [Finset.coe_image, ← Submodule.span_span_of_tower R, ← Submodule.map_span, hs]
rfl
simp
rw [eq_bot_iff]
intro x hx
rw [norm_eq_matrix_det pb.basis, det_eq_sign_charpoly_coeff, charpoly_left_mul_matrix,
    Fintype.card_fin]
rw [power_basis.norm_gen_eq_coeff_zero_minpoly, ← pb.nat_degree_minpoly, RingHom.map_mul, ←
    coeff_map,
    prod_roots_eq_coeff_zero_of_monic_of_split
      ((minpoly.monic (PowerBasis.is_integral_gen _)).map _) ((splits_id_iff_splits _).2 hf),
    nat_degree_map, map_pow, ← mul_assoc, ← mul_pow]
simp
rw [norm_eq_norm_adjoin K x, map_pow, IntermediateField.AdjoinSimple.norm_gen_eq_prod_roots _ hF]
apply NoZeroSmulDivisors.algebra_map_injective L (AlgebraicClosure L)
rw [map_prod (algebraMap L (AlgebraicClosure L))]
rw [← Fintype.prod_equiv (Normal.algHomEquivAut K (AlgebraicClosure L) L)]
· rw [← norm_eq_prod_embeddings]
    simp only [algebra_map_eq_smul_one, smul_one_smul]
· intro σ
    simp only [Normal.algHomEquivAut, AlgHom.restrictNormal', Equiv.coe_fn_mk,
      AlgEquiv.coe_of_bijective, AlgHom.restrict_normal_commutes, id.map_eq_id, RingHom.id_apply]
rw [RingHom.map_pow]
exact f.2 n
apply coeff_pow_p f n
erw [Function.iterate_succ_apply', coeff_frobenius, ih]
rw [RingHom.comp_apply, RingHom.id_apply, coeff_pth_root, coeff_frobenius]
rw [RingHom.comp_apply, RingHom.id_apply, RingHom.map_frobenius, coeff_pth_root, ←
        RingHom.map_frobenius, coeff_frobenius]
erw [← coeff_pow_p, RingHom.map_pow, h, zero_pow hp.1.Pos]
rw [← f.map_pow, Function.iterate_succ_apply', pth_root_pow_p]
rw [← coeff_iterate_frobenius _ 0 n, zero_add, ← RingHom.map_iterate_frobenius,
            right_inverse_pth_root_frobenius.iterate]
rw [← φ.map_pow, coeff_pow_p']
rw [hfg, ← coe_fn_coe_base, hx]
rw [Function.iterate_succ_apply', pth_root_pow_p _, ih, hf]
rw [map_map, Perfection.coeff_map]
rw [hx, pre_val_zero] at h
exact not_lt_zero' h
rw [← v_p_lt_pre_val, hvx] at hx0
exact not_lt_zero' hx0
rw [lt_iff_not_le, not_iff_not, ← map_nat_cast (algebraMap O K) p, hv.le_iff_dvd,
    Ideal.Quotient.eq_zero_iff_mem, Ideal.mem_span_singleton]
erw [RingHom.map_pow, hx, ← RingHom.map_pow, coeff_pow_p]
exact coeff_nat_find_add_ne_zero k
rw [pow_zero, pow_one, RingHom.map_one, ← (Ideal.Quotient.mk _).map_one, ModP.pre_val_mk,
      RingHom.map_one, v.map_one]
change (1 : ModP K v O hv p) ≠ 0
exact one_ne_zero
rw [RingHom.map_mul]
refine' ModP.mul_ne_zero_of_pow_p_ne_zero _ _
· rw [← RingHom.map_pow, coeff_pow_p f]
      assumption
· rw [← RingHom.map_pow, coeff_pow_p g]
      assumption
simp only [comp_apply, Algebra.lsmul_coe, smul_tmul', lift.tmul,
              coe_restrict_scalars_eq_coe, f.map_smul, smul_apply]
simp only [lift_tmul, add_apply]
simp only [lift_tmul, smul_apply, RingHom.id_apply]
apply TensorProduct.curry
exact mk R A _ _
rw [← comp_apply, ← comp_apply]
simp only [ltensor_comp_rtensor, rtensor_comp_ltensor]
simp only [mul_aux_apply, LinearMap.add_apply, add_mul, add_tmul]
simp only [mul_aux_apply, LinearMap.smul_apply, smul_tmul', smul_mul_assoc]
simp only [mul_aux_apply, LinearMap.add_apply, add_mul, tmul_add]
simp only [mul_aux_apply, LinearMap.smul_apply, smul_tmul, smul_tmul', smul_mul_assoc]
intros
apply TensorProduct.induction_on x
· simp only [LinearMap.map_zero, LinearMap.zero_apply]
apply TensorProduct.induction_on y
· simp only [LinearMap.map_zero, forall_const, LinearMap.zero_apply]
apply TensorProduct.induction_on z
· simp only [LinearMap.map_zero, forall_const]
· intros
    simp only [h]
· intros
    simp only [LinearMap.map_add, *]
· intros
    simp only [LinearMap.map_add, *, LinearMap.add_apply]
· intros
    simp only [LinearMap.map_add, *, LinearMap.add_apply]
intros
simp only [mul_apply, mul_assoc]
apply TensorProduct.induction_on x <;> simp (config := { contextual := true })
apply TensorProduct.induction_on x <;> simp (config := { contextual := true })
infer_instance
infer_instance
simp
simp
simp
simp
simp
simp [add_tmul]
simp
infer_instance
apply TensorProduct.induction_on x
· simp
· intro a b
        dsimp
        rw [Algebra.commutes, _root_.mul_one, _root_.one_mul]
· intro y y' h h'
        dsimp at h h'⊢
        simp only [mul_add, add_mul, h, h']
apply TensorProduct.induction_on x
· simp [smul_zero]
· intro a b
        dsimp
        rw [TensorProduct.smul_tmul', Algebra.smul_def r a, _root_.one_mul]
· intros
        dsimp
        simp [smul_add, mul_add, *]
simp
simp
simp
simp [tmul_add]
simp
infer_instance
infer_instance
infer_instance
apply TensorProduct.induction_on x
· simp
· intro a₁ b₁
        apply TensorProduct.induction_on y
        · simp
        · intro a₂ b₂
          simp [mul_comm]
        · intro a₂ b₂ ha hb
          simp [mul_add, add_mul, ha, hb]
· intro x₁ x₂ h₁ h₂
        simp [mul_add, add_mul, h₁, h₂]
infer_instance
infer_instance
rw [← (algebraMap R C).map_one, ← w₂, (algebraMap R A).map_one] <;> rfl
rw [LinearMap.to_fun_eq_coe, map_zero]
rw [LinearMap.to_fun_eq_coe]
apply TensorProduct.induction_on x
· rw [zero_mul, map_zero, zero_mul]
· intro a₁ b₁
        apply TensorProduct.induction_on y
        · rw [mul_zero, map_zero, mul_zero]
        · intro a₂ b₂
          rw [tmul_mul_tmul, w₁]
        · intro x₁ x₂ h₁ h₂
          rw [mul_add, map_add, map_add, mul_add, h₁, h₂]
· intro x₁ x₂ h₁ h₂
        rw [add_mul, map_add, map_add, add_mul, h₁, h₂]
rw [LinearMap.to_fun_eq_coe, algebra_map_apply, w₂]
apply TensorProduct.induction_on x
· simp only [map_zero, zero_mul]
· intro ab₁ c₁
        apply TensorProduct.induction_on y
        · simp only [map_zero, mul_zero]
        · intro ab₂ c₂
          apply TensorProduct.induction_on ab₁
          · simp only [zero_tmul, map_zero, zero_mul]
          · intro a₁ b₁
            apply TensorProduct.induction_on ab₂
            · simp only [zero_tmul, map_zero, mul_zero]
            · intros
              simp only [tmul_mul_tmul, w₁]
            · intro x₁ x₂ h₁ h₂
              simp only [tmul_mul_tmul] at h₁ h₂
              simp only [tmul_mul_tmul, mul_add, add_tmul, map_add, h₁, h₂]
          · intro x₁ x₂ h₁ h₂
            simp only [tmul_mul_tmul] at h₁ h₂
            simp only [tmul_mul_tmul, add_mul, add_tmul, map_add, h₁, h₂]
        · intro x₁ x₂ h₁ h₂
          simp only [tmul_mul_tmul, map_add, mul_add, add_mul, h₁, h₂]
· intro x₁ x₂ h₁ h₂
        simp only [tmul_mul_tmul, map_add, mul_add, add_mul, h₁, h₂]
simp [w₂]
simp [mul_smul]
simp [Algebra.smul_def]
simp [TensorProduct.lid]
simp [mul_smul]
simp [Algebra.smul_def]
simp [TensorProduct.rid]
simp
simp [TensorProduct.comm]
simp
simp [AlgHom.commutes]
simp
simp
simp
simp
simp only [LinearMap.mul'_apply, mul_mul_mul_comm]
simp only [LinearMap.mul'_apply, _root_.mul_one]
unfold product_map lmul'
simp
simp
simp
simp
simp
rw [product_map, AlgHom.range_comp, map_range, map_sup, ← AlgHom.range_comp, ← AlgHom.range_comp,
    ← AlgHom.comp_assoc, ← AlgHom.comp_assoc, lmul'_comp_include_left, lmul'_comp_include_right,
    AlgHom.id_comp, AlgHom.id_comp]
dsimp
simp
simp
simp only [TensorProduct.smul_tmul', basis_aux_tmul, smul_assoc]
simp [hx, hy]
simp [Basis, Equiv.uniqueProd_symm_apply, basis_aux]
simp only [End_tensor_End_alg_hom,
    Algebra.TensorProduct.alg_hom_of_linear_map_tensor_product_apply, hom_tensor_hom_map_apply]
rw [← E1.range_val, ← E2.range_val, ← Algebra.TensorProduct.product_map_range]
exact (Algebra.TensorProduct.productMap E1.val E2.val).toLinearMap.finite_dimensional_range
simp [module_aux]
simp only [map_zero, LinearMap.zero_apply]
simp only [map_zero]
simp only [map_add]
simp only [map_add, LinearMap.add_apply]
simp only [module_aux_apply, Algebra.TensorProduct.one_def, one_smul]
apply TensorProduct.induction_on x <;> apply TensorProduct.induction_on y
· simp only [mul_zero, map_zero, LinearMap.zero_apply]
· intro a b
      simp only [zero_mul, map_zero, LinearMap.zero_apply]
· intro z w hz hw
      simp only [zero_mul, map_zero, LinearMap.zero_apply]
· intro a b
      simp only [mul_zero, map_zero, LinearMap.zero_apply]
· intro a₁ b₁ a₂ b₂
      simp only [module_aux_apply, mul_smul, smul_comm a₁ b₂, Algebra.TensorProduct.tmul_mul_tmul,
        LinearMap.mul_apply]
· intro z w hz hw a b
      simp only at hz hw
      simp only [mul_add, hz, hw, map_add, LinearMap.add_apply]
· intro z w hz hw
      simp only [mul_zero, map_zero, LinearMap.zero_apply]
· intro a b z w hz hw
      simp only at hz hw
      simp only [map_add, add_mul, LinearMap.add_apply, hz, hw]
· intro u v hu hv z w hz hw
      simp only at hz hw
      simp only [add_mul, hz, hw, map_add, LinearMap.add_apply]
rw [← coeff_zero_eq_constant_coeff_apply, coeff_inv_units_sub, zero_add, pow_one]
simp [mul_sub, sub_sub_cancel]
rw [← coeff_zero_eq_constant_coeff_apply, coeff_exp]
simp
rw [sin, coeff_mk, if_pos (even_bit0 n)]
rw [sin, coeff_mk, if_neg n.not_even_bit1, Nat.bit1_div_two, ← mul_one_div, map_mul, map_pow,
    map_neg, map_one, coeff_exp]
rw [cos, coeff_mk, if_pos (even_bit0 n), Nat.bit0_div_two, ← mul_one_div, map_mul, map_pow,
    map_neg, map_one, coeff_exp]
rw [cos, coeff_mk, if_neg n.not_even_bit1]
rw [coeff, monomial_def, LinearMap.proj_apply, LinearMap.std_basis_apply, Function.update_apply,
    Pi.zero_apply]
simp [Nat.cast]
simp [Nat.cast, monomial_zero_one]
simp [coeff_mul]
simp [coeff_mul]
rw [coeff_monomial_mul, if_pos, add_tsub_cancel_left]
exact le_add_right le_rfl
rw [coeff_mul_monomial, if_pos, add_tsub_cancel_right]
exact le_add_left le_rfl
simp only [coeff_mul, mul_add, Finset.sum_add_distrib, LinearMap.map_add]
simp only [coeff_mul, add_mul, Finset.sum_add_distrib, LinearMap.map_add]
simp only [coeff_X, single_left_inj one_ne_zero]
rw [coeff_X, if_neg]
intro h
exact one_ne_zero (single_eq_zero.mp h.symm)
rw [X_pow_eq s n, coeff_monomial]
rw [← (φ.commute_X s).Eq, coeff_zero_mul_X]
simp [coeff_mul, support_single_ne_zero]
simp
simp [MvPowerSeries.x]
change (MvPowerSeries.map σ (algebraMap R A)).comp (C σ R) r = _
simp
simp [trunc_fun, MvPolynomial.coeff_sum]
simp [Trunc, coeff_trunc_fun]
rw [← pow_one (X s : MvPowerSeries σ R), X_pow_dvd_iff]
constructor <;> intro h m hm
· exact h m (hm.symm ▸ zero_lt_one)
· exact h m (Nat.eq_zero_of_le_zero <| Nat.le_of_succ_le_succ hm)
rw [← coeff_zero_eq_constant_coeff_apply, coeff_inv_of_unit, if_pos rfl]
rw [H]
simp [coeff_mul, support_single_ne_zero, h]
rw [Finsupp.mem_antidiagonal, zero_add]
simp [this]
rw [← coeff_zero_eq_constant_coeff_apply, coeff_inv, if_pos rfl]
rw [inv_eq_zero, constant_coeff_zero]
rw [← inv_of_unit_eq φ (h.symm ▸ u.ne_zero)]
congr 1
rw [Units.ext_iff]
exact h.symm
rw [← inv_of_unit_eq φ h, mul_inv_of_unit φ (Units.mk0 _ h) rfl]
rw [mul_comm, φ.mul_inv_cancel h]
simp [k, mul_assoc, MvPowerSeries.inv_mul_cancel _ h]
simp [← k, mul_assoc, MvPowerSeries.mul_inv_cancel _ h]
rw [← MvPowerSeries.eq_mul_inv_iff_mul_eq h, one_mul]
rw [eq_comm, MvPowerSeries.eq_inv_iff_mul_eq_one h]
rw [MvPowerSeries.inv_eq_iff_mul_eq_one, mul_one]
simp
rw [inv_eq_zero, constant_coeff_X]
simp [smul_eq_C_mul, mul_comm]
simp only [coeff_coe, MvPowerSeries.coeff_mul, coeff_mul]
rw [bit1, bit1, coe_add, coe_one, coe_bit0]
rw [← coe_zero, coe_inj]
rw [← coe_one, coe_inj]
simp [algebra_map_apply, MvPowerSeries.algebra_map_apply]
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
erw [coeff, ← h, ← Finsupp.unique_single s]
rw [← coeff_def]
· apply h
rfl
simp only [Finsupp.unique_single_eq_iff]
rw [coeff_monomial, coeff_mk]
rw [coeff, Finsupp.single_zero]
rfl
rw [coeff_zero_eq_constant_coeff] <;> rfl
rw [monomial, Finsupp.single_zero, MvPowerSeries.monomial_zero_eq_C, C]
simp
rw [← monomial_zero_eq_C_apply, coeff_monomial]
rw [← monomial_zero_eq_C_apply, coeff_monomial_same 0 a]
rw [X_eq, coeff_monomial]
rw [coeff, Finsupp.single_zero, X, MvPowerSeries.coeff_zero_X]
rw [coeff_X, if_pos rfl]
rw [X_pow_eq, coeff_monomial]
rw [coeff_X_pow, if_pos rfl]
simp
simp
simp [X_pow_eq, coeff_monomial]
simp
simp [Trunc, Polynomial.coeff_sum, Polynomial.coeff_monomial, Nat.lt_succ_iff]
rw [← coeff_zero_eq_constant_coeff_apply, coeff_inv_of_unit, if_pos rfl]
rw [rescale_X, map_neg, map_one, neg_one_mul]
rw [this]
exact RingHom.ker_is_prime _
intro p q h
rw [PowerSeries.ext_iff] at *
intro n
specialize h n
rw [coeff_rescale, coeff_rescale, mul_eq_mul_left_iff] at h
apply h.resolve_right
intro h'
exact ha (pow_eq_zero h')
have := Exists.intro n h
rw [order, dif_neg]
· simp only [PartEnat.coe_le_coe, Nat.find_le_iff]
    exact ⟨n, le_rfl, h⟩
· exact exists_coeff_ne_zero_iff_ne_zero.mp ⟨n, h⟩
refine' le_order _ _ _
simp (config := { contextual := true }) [coeff_of_lt_order]
rw [le_inf_iff, this]
exact ⟨le_rfl, le_of_lt H⟩
refine' le_antisymm _ (le_order_add _ _)
rw [order_monomial, if_neg h]
simp [coeff_mul_of_lt_order h, mul_sub]
apply Finset.induction_on s
· simp
· intro a s ha ih t
    simp only [Finset.mem_insert, forall_eq_or_imp] at t
    rw [Finset.prod_insert ha, ← mul_assoc, mul_right_comm, coeff_mul_one_sub_of_lt_order _ t.1]
    exact ih t.2
simp [ho]
rw [X_pow_eq, order_monomial_of_ne_zero]
exact one_ne_zero
simp only [coeff_coe, PowerSeries.coeff_mul, coeff_mul]
rw [bit1, bit1, coe_add, coe_one, coe_bit0]
rw [← coe_zero, coe_inj]
rw [← coe_one, coe_inj]
simp [algebra_map_apply, PowerSeries.algebra_map_apply]
rw [FiniteDimensional.finrank_eq_card_basis pb.basis, Fintype.card_fin]
rw [degree_eq_nat_degree NeZero, WithBot.coe_le_coe]
exact h.dim_le_nat_degree_of_root NeZero root
unfold minpoly_gen
rw [degree_sub_eq_left_of_degree_lt] <;> rw [degree_X_pow]
apply degree_sum_fin_lt
apply (monic_X_pow _).sub_of_left _
rw [degree_X_pow]
exact degree_sum_fin_lt _
refine'
    le_antisymm _
      (dim_le_nat_degree_of_root pb (minpoly.ne_zero pb.is_integral_gen) (minpoly.aeval _ _))
rw [← nat_degree_minpoly_gen]
apply nat_degree_le_of_degree_le
rw [← degree_eq_nat_degree (minpoly_gen_monic pb).NeZero]
exact minpoly.min _ _ (minpoly_gen_monic pb) (aeval_minpoly_gen pb)
rw [← pb.nat_degree_minpoly]
apply nat_degree_lt_nat_degree hf
exact degree_mod_
rw [aeval_alg_hom_apply, minpoly.aeval, f.map_zero]
rw [mem_roots, is_root.def, Equiv.refl_apply, ← eval₂_eq_eval_map, ← aeval_def]
exact map_monic_ne_zero (minpoly.monic pb.is_integral_gen)
intro i
simp only [f, Finsupp.sum, coeff_monomial, finset_sum_coeff]
rw [Finset.sum_eq_single, if_pos rfl]
· intro b _ hb
      rw [if_neg (mt (fun h => _) hb)]
      exact Fin.coe_injective h
· intro hi
      rw [if_pos rfl]
      exact finsupp.not_mem_support_iff.mp hi
apply not_le_of_lt
rw [degree_eq_nat_degree (minpoly.ne_zero hx), degree_lt_iff_coeff_zero]
intro i hi
rw [f_def' i, dif_neg]
exact hi.not_lt
rw [Basis.map_apply, pb.basis_eq_pow, e.to_linear_equiv_apply, e.map_pow]
dsimp only [minpoly_gen, map_dim]
  -- Turn `fin (pb.map e).dim` into `fin pb.dim`
simp only [LinearEquiv.trans_apply, map_basis, Basis.map_repr, map_gen,
    AlgEquiv.to_linear_equiv_apply, e.to_linear_equiv_symm, AlgEquiv.map_pow,
    AlgEquiv.symm_apply_apply, sub_right_inj]
rw [_root_.eq_top_iff, ← B.adjoin_gen_eq_top]
refine' adjoin_le _
simp [hx]
rw [mul_assoc, ← mul_add_one, hr, ← hpq, ← neg_sub, add_sub_cancel] <;>
            exact I.neg_mem hpi
rw [mul_assoc, ← mul_add_one, neg_mul, ← sub_eq_iff_eq_add.mpr df.symm, neg_sub,
                    sub_add_cancel]
exact M.mul_mem_left _ hi
intro h x hx
erw [mem_Inf] at hx⊢
exact fun K ⟨hK, hK_max⟩ => hx ⟨trans h hK, hK_max⟩
rw [← hpq, mul_comm, ← hr, ← neg_sub, add_sub_cancel] <;> exact I.neg_mem hpi
rw [← mul_one x, ← sub_sub_cancel (z * y) 1, mul_sub, mul_left_comm] <;>
          exact I.sub_mem (I.mul_mem_left _ hxy) (I.mul_mem_left _ hz)
simp [to_fun_alg_hom, alg_hom_of_linear_map_tensor_product, to_fun_linear]
simp [inv_fun]
simp [inv_fun, add_tmul, Finset.sum_add_distrib]
simp [inv_fun, Finset.mul_sum]
simp [matrixEquivTensor, to_fun_alg_hom, alg_hom_of_linear_map_tensor_product, to_fun_linear]
rfl
constructor
intro x hx
apply hf
rw [map_zero]
exact (hx.map f).eq_zero
simp only [this, nsmul_eq_mul, mul_zero]
rw [h_comm.eq]
exact h_comm.symm.is_nilpotent_mul_left h
rw [← neg_right_iff] at h_comm
rw [← is_nilpotent_neg_iff] at hy
rw [sub_eq_add_neg]
exact h_comm.is_nilpotent_add hx hy
rw [← mem_nilradical, nilradical_eq_Inf, Submodule.mem_Inf]
rfl
rw [map_one, _root_.map_mul, hy, IsUnit.mul_val_inv]
rw [← Ideal.mem_bot, ← e]
exact Ideal.pow_mem_pow this _
infer_instance
rw [Finset.coe_union]
exact μ.is_lower_set.union ν.is_lower_set
rw [Finset.coe_inter]
exact μ.is_lower_set.inter ν.is_lower_set
simp only [Finset.mem_coe, Equiv.finset_congr_apply, Finset.mem_map_equiv]
intro hcell
apply μ.is_lower_set _ hcell
simp [h]
simp [transpose]
rw [transpose_eq_iff_eq_transpose]
simp
simp
simp
simp
simp [row]
simp [row]
cases h
rfl
rfl
rfl
simp [row_eq_prod]
rfl
simp [col]
simp [col]
simp [row_len, col_len]
simp [row_len, col_len]
rw [← row_len_transpose, ← mem_iff_lt_row_len]
simp
simp [col_eq_prod]
simp only [row_lens, List.nth_le_range, List.nth_le_map']
simp only [row_lens, List.length_map, List.length_range]
simp only [length_row_lens, col_len, Nat.find_eq_iff, mem_cells, mem_of_row_lens,
    lt_self_iff_false, IsEmpty.exists_iff, not_not]
exact ⟨id, fun n hn => ⟨hn, hpos _ (List.nth_le_mem _ _ hn)⟩⟩
simp [row_len, Nat.find_eq_iff, mem_of_row_lens, hi]
cases T
cases T'
congr
cases eq_or_lt_of_le hj
subst h
exact T.row_weak h cell
cases eq_or_lt_of_le hi
subst h
exact le_of_lt (T.col_strict h cell)
rfl
rfl
apply lt_of_le_of_lt (sum_le_sum_of_subset fun t => mem_range.2 ∘ h₁)
have z := geom_sum_mul_add 1 k
rw [mul_one, one_add_one_eq_two] at z
rw [← z]
apply Nat.lt_succ_self
infer_instance
infer_instance
infer_instance
rw [le_iff_le_iff_lt_iff_lt, hom_lt_iff h₁]
rw [← not_lt]
simp [lt_singleton_iff_mem_lt]
simp [lt_singleton_iff_mem_lt]
rw [le_iff_le_iff_lt_iff_lt, singleton_lt_iff_lt]
rw [le_iff_le_iff_lt_iff_lt, sdiff_lt_sdiff_iff_lt]
simp
rw [← sdiff_le_sdiff_iff_le, sdiff_eq_empty_iff_subset.2 h]
apply empty_to_colex_le
infer_instance
infer_instance
infer_instance
infer_instance
rw [le_iff_le_iff_lt_iff_lt, sum_two_pow_lt_iff_lt]
rw [mul_mul_mul_comm, h, mul_mul_mul_comm]
rw [mul_mul_mul_comm, h, mul_mul_mul_comm]
refine' mul_salem_spencer_insert.trans _
rw [← and_assoc']
exact and_iff_left fun b c hb hc h => ((mul_lt_mul_of_lt_of_lt (hs _ hb) (hs _ hc)).Ne h).elim
rw [mul_mul_mul_comm, h, mul_mul_mul_comm]
rw [mul_mul_mul_comm, h, mul_mul_mul_comm]
rw [← inter_distrib_left, (inter_eq_left_iff_subset _ _).2 hus]
rw [coe_map]
exact hu.mul_left
rw [← mul_left_embedding_eq_mul_right_embedding, mul_roth_number_map_mul_left s a]
simp only [box, Fintype.mem_pi_finset, mem_range]
simp [box]
simp [box]
simp (config := { contextual := true }) [sphere, Function.funext_iff]
simp [sphere]
rw [Set.mem_preimage, mem_sphere_zero_iff_norm, norm_of_mem_sphere hx]
simp [map]
simp [map, Fin.sum_univ_succ, pow_succ', ← mul_assoc, ← sum_mul]
dsimp
exact sum_le_sum fun i _ => Nat.mul_le_mul_right _ <| h i
rw [map_succ, Nat.add_mul_mod_self_right]
rw [map_succ', map_succ', h.1, h.2]
rw [← mod_eq_of_lt (hx₁ _), ← map_mod, ← mod_eq_of_lt (hx₂ _), ← map_mod, h]
rw [card_fin, smul_eq_mul]
refine' (Nat.div_eq_of_eq_mul_left zero_lt_two _).symm
rw [← sum_range fun i => d * (2 * d + 1) ^ (i : ℕ), ← mul_sum, mul_right_comm, mul_comm d, ←
    geom_sum_mul_add, add_tsub_cancel_right, mul_comm]
refine' exists_le_card_fiber_of_nsmul_le_card_of_maps_to (fun x hx => _) nonempty_range_succ _
· rw [mem_range, lt_succ_iff]
    exact sum_sq_le_of_mem_box hx
· rw [card_range, _root_.nsmul_eq_mul, mul_div_assoc', cast_add_one, mul_div_cancel_left,
      card_box]
    exact (cast_add_one_pos _).ne'
rw [le_sub_iff_add_le]
apply (add_le_add_left h₁.le _).trans_eq
rw [← add_assoc, sub_add_cancel]
rfl
rw [exp_neg, inv_eq_one_div]
refine' one_div_le_one_div_of_le (add_pos hx zero_lt_one) _
apply le_trans _ (add_one_le_exp_of_nonneg <| add_nonneg hx.le zero_le_one)
exact le_add_of_nonneg_right zero_le_one
simp [div_eq_mul_inv a b]
simp
rw [← div_inv_eq_mul, ← card_inv B, ← card_inv (B * C), mul_inv, ← div_eq_mul_inv]
exact card_div_mul_le_card_div_mul_card_div _ _ _
rw [← div_inv_eq_mul, ← div_inv_eq_mul B]
exact card_div_mul_le_card_div_mul_card_div _ _ _
rw [← div_inv_eq_mul, div_eq_mul_inv B]
exact card_div_mul_le_card_mul_mul_card_mul _ _ _
rw [hA', inter_mul_singleton, (is_unit_singleton x).div_mul_cancel]
rw [hC', insert_eq, union_comm, mul_union]
refine' (sup_sdiff_eq_sup _).symm
rw [mul_right_comm, mul_right_comm A, h₀]
exact mul_subset_mul_right (inter_subset_right _ _)
rw [h₁]
refine' (card_union_le _ _).trans_eq _
rw [card_sdiff h₂, ← add_tsub_assoc_of_le (card_le_of_subset h₂), card_mul_singleton,
      card_mul_singleton]
rw [div_eq_mul_inv, ← card_inv B, ← card_inv (B / C), inv_div', div_inv_eq_mul]
exact card_mul_mul_card_le_card_mul_mul_card_mul _ _ _
rw [div_eq_mul_inv, div_eq_mul_inv]
exact card_mul_mul_card_le_card_mul_mul_card_mul _ _ _
rw [← div_inv_eq_mul, div_eq_mul_inv]
exact card_mul_mul_le_card_div_mul_card_div _ _ _
rw [← card_inv, inv_div', ← inv_pow, ← inv_pow, div_eq_mul_inv A]
exact card_pow_div_pow_le hA _ _ _
simp [← and_imp]
simp [multiplicative_energy]
simp [multiplicative_energy]
simp [← (Nat.zero_le _).not_gt_iff_eq, not_and_or]
rw [multiplicative_energy, ← Finset.card_map (Equiv.prodComm _ _).toEmbedding, map_filter]
simp [-Finset.card_map, eq_comm, multiplicative_energy, mul_comm, map_eq_image, Function.comp]
simp [mul_right_comm, h.2]
rw [multiplicative_energy_comm, multiplicative_energy_univ_left]
simp [intersecting]
rw [Fintype.card, ← this, two_mul, card_disj_union, card_map]
rw [coe_singleton]
exact intersecting_singleton.2 top_ne_bot
simp only [shadow, mem_sup, mem_image]
rw [card_sdiff hst, h, add_tsub_cancel_left]
rw [add_comm, hcard]
exact le_succ _
rw [card_sdiff hts, ← h, add_tsub_cancel_left]
rw [add_comm, ← hcard]
exact add_le_add_left (zero_lt_succ _) _
refine' fun j hj => (hf₁ _ hj).2.2.is_upper_set' ((hf₁ _ hj).2.2.is_max_iff_card_eq.2 _)
rw [Fintype.card_finset]
exact (hf₁ _ hj).2.1
rw [(sized_shadow_iff this).1 h𝒜.shadow ht.1, h𝒜.shadow hs]
rw [mem_member_subfamily, mem_non_member_subfamily]
exact And.imp_left (h <| subset_insert _ _)
rw [inter_comm, mul_comm 𝒜.card]
exact hℬ.card_inter_le_finset h𝒜
dsimp at hab
rw [hab]
rw [mem_compression]
have h : filter (fun a => compress u v a ∉ 𝓒 u v s) (𝓒 u v s) = ∅ :=
    filter_false_of_mem fun a ha h => h <| compress_mem_compression_of_mem_compression ha
rw [compression, image_filter, h, image_empty, ← h]
exact filter_union_filter_neg_eq _ (compression u v s)
rw [← disjoint_self]
apply Disjoint.mono_right hva
rw [← compress_idem, compress_of_disjoint_of_le hua hva]
exact disjoint_sdiff_self_right
unfold member_subfamily
rw [filter_inter_distrib, image_inter_of_inj_on _ _ ((erase_inj_on' _).mono _)]
rw [← coe_union, ← filter_union, coe_filter]
exact Set.inter_subset_right _ _
rw [member_subfamily, non_member_subfamily, card_image_of_inj_on,
    filter_card_add_filter_neg_card_eq_card]
exact (erase_inj_on' _).mono fun s hs => (mem_filter.1 hs).2
rw [compression, card_disj_union, image_filter,
    card_image_of_inj_on ((erase_inj_on' _).mono fun s hs => _), ← card_disjoint_union,
    filter_union_filter_neg_eq]
· exact disjoint_filter_filter_neg _ _ _
rw [mem_coe, mem_filter] at hs
exact not_imp_comm.1 erase_eq_of_not_mem (ne_of_mem_of_not_mem hs.1 hs.2).symm
rw [Finset.singleton_bUnion]
rw [hn, Nat.add_succ_sub_one, add_zero]
simp only [disjoint_left, not_exists, mem_image, exists_prop, SetCoe.exists, exists_and_right,
      exists_eq_right, Subtype.coe_mk]
intro x hx hc h
exact absurd hx hc
simp [disj, card_image_of_injective _ Subtype.coe_injective]
apply Nat.le_of_lt_succ
calc
      Fintype.card s = s.card := Fintype.card_coe _
      _ < Fintype.card ι := (card_lt_iff_ne_univ _).mpr hns
      _ = n.succ := hn
intro x' hx'
rw [mem_bUnion]
exact ⟨x', hx', hsf' _⟩
intro x'' hx''
have h := hsf'' ⟨x'', hx''⟩
rw [mem_sdiff] at h
exact h.2
intro _ _ hx' hx'' h
apply f''_not_mem_bUnion hx''
rw [← h]
apply f'_mem_bUnion
intro ι' _ _ hι' ht'
exact ih _ (Nat.lt_succ_of_le hι') ht' _ rfl
intro ι'
rw [hallMatchingsFunctor]
infer_instance
      -- Apply the compactness argument
simp only [Opposite.unop_op, mem_singleton]
simp
simp
simp [Rel.image]
simp
intro a
simp only [Fintype.card_fin, Finset.card_fin, Fintype.card_of_finset, Finset.filter_ne' _ a,
      Set.mem_compl_singleton_iff, Finset.card_erase_of_mem (Finset.mem_univ a),
      add_tsub_cancel_right]
simp only [card_fin, card_option]
  -- rewrite the LHS and substitute in our fintype-level equivalence
rw [← card_derangements_invariant (card_fin _)]
exact card_derangements_fin_eq_num_derangements
simp
refine' Equiv.sumCongr (subtype_equiv_right fun f => _) (subtype_equiv_right fun f => _)
· rw [Set.eq_singleton_iff_unique_mem, and_comm']
        rfl
· rw [Set.eq_empty_iff_forall_not_mem]
        refine' ⟨fun h x hx => h.2 (h.1 hx ▸ hx), fun h => ⟨fun x hx => (h _ hx).elim, h _⟩⟩
simp [remove_none.fiber, derangements]
rw [equiv.remove_none.fiber_none]
exact IsEmpty.false
exact (this p).trans (this q).symm
  refine' fun p =>
    or_not.elim (fun h₂ => _) fun h₂ => (has_lines.line_count_eq_point_count h h₂).trans hl₂
  refine' or_not.elim (fun h₃ => _) fun h₃ => (has_lines.line_count_eq_point_count h h₃).trans hl₃
  rwa [(eq_or_eq h₂ h₂₂ h₃ h₂₃).resolve_right fun h =>
      h₃₃ ((congr_arg (Membership.Mem p₃) h).mp h₃₂)]
cases nonempty_fintype P
cases nonempty_fintype L
exact has_lines.line_count_eq_point_count (card_points_eq_card_lines P L) hq
rw [← reverse_inj, reverse_reverse]
simp only [Prefunctor.comp_map, Prefunctor.map_reverse']
induction q
· simp
· simp [q_ih]
induction p
· simp
· simp only [path.reverse, path.reverse_comp, path.reverse_to_path, reverse_reverse, p_ih]
    rfl
dsimp [lift]
cases f
· simp only
    rfl
· simp only [reverse_reverse]
    rfl
cases e <;> rfl
cases F
constructor
apply reverse
exact F_f
cases F
constructor
apply reverse
exact F_f
cases F
dsimp [reverse]
congr
apply reverse_reverse
simp [of_reverse]
intro p
apply this
rw [hu, hv]
subst_vars
rfl
subst_vars
rfl
subst_vars
rfl
rw [hom.cast_eq_cast]
exact cast_eq_iff_heq
rw [eq_comm, hom.cast_eq_iff_heq]
exact ⟨HEq.symm, HEq.symm⟩
rw [hu, hv]
subst_vars
rfl
subst_vars
rfl
rw [path.cast_eq_cast]
exact cast_heq _ _
rw [path.cast_eq_cast]
exact cast_eq_iff_heq
subst_vars
rfl
rw [path.cast_eq_iff_heq]
exact heq_of_cons_eq_cons h
rw [hom.cast_eq_iff_heq]
exact hom_heq_of_cons_eq_cons h
cases F
rfl
cases F
rfl
rw [← h X, ← h Y]
exact φ.map f
injection h
injection h
injection h
cases p
· rfl
· cases Nat.succ_ne_zero _ hzero
rw [comp_cons, nil_comp]
rw [comp_cons, comp_cons, comp_cons, comp_assoc]
simp
simp [to_list_comp]
cases h
cases h
dsimp
rw [map_path_comp]
rw [← coe_nonempty, coe_bipartite_above]
exact hs _ h
simp [size_up_to]
simp only [size_up_to]
rw [sum_take_succ _ _ h]
rw [c.size_up_to_succ h]
simp
simp [boundary, Fin.ext_iff]
simp [boundary, Fin.ext_iff]
simp [boundaries]
simp only [boundaries, Finset.mem_univ, exists_prop_of_true, Finset.mem_map]
exact ⟨0, rfl⟩
simp only [boundaries, Finset.mem_univ, exists_prop_of_true, Finset.mem_map]
exact ⟨Fin.last c.length, c.boundary_last⟩
refine' (Finset.order_emb_of_fin_unique' _ _).symm
exact fun i => (Finset.mem_map' _).2 (Finset.mem_univ _)
rw [tsub_lt_iff_right, add_comm, ← size_up_to_succ']
· exact lt_size_up_to_index_succ _ _
· exact size_up_to_index_le _ _
rw [Fin.ext_iff]
apply add_tsub_cancel_of_le (c.size_up_to_index_le j)
constructor
· rw [← not_imp_not]
    intro h
    exact Set.disjoint_right.1 (c.disjoint_range h) (c.mem_range_embedding j)
· intro h
    rw [h]
    exact c.mem_range_embedding j
rw [H]
rw [← c.blocks_sum, ← c'.blocks_sum, H]
simp [List.eq_of_mem_repeat hi]
simp
simp [blocks_fun, ones, blocks, i.2]
simp [size_up_to, ones_blocks, take_repeat]
simp [le_antisymm_iff, c.one_le_blocks hj]
simp [length_n]
simp [blocks_fun]
simp [eq_ones_iff_length, le_antisymm_iff, c.length_le]
simp [h]
simp
simp [blocks_fun, single, blocks, i.2]
simp
simp
intro j
simp only [c.sum_blocks_fun, hi]
simp [split_wrt_composition_aux]
induction ns generalizing l <;> simp [*]
have : l'.length ∈ (l.split_wrt_composition c).map List.length :=
    List.mem_map_of_mem List.length h
rw [map_length_split_wrt_composition] at this
exact c.blocks_pos this
congr
exact map_length_split_wrt_composition l c
simp only [eq_self_iff_true, and_self_iff, eq_iff_join_eq, join_split_wrt_composition,
    map_length_split_wrt_composition, h]
apply (add_lt_add_left i.is_lt 1).trans_le
rw [Nat.succ_eq_add_one, add_comm]
exact add_le_add (Nat.sub_le n 1) (le_refl 1)
simp
simp
rw [add_comm]
exact Nat.succ_pred_eq_of_pos (pos_iff_ne_zero.mpr i_ne_zero)
simp
rw [c.card_boundaries_eq_succ_length]
exact lt_add_one _
rw [boundary, Finset.order_emb_of_fin_zero rfl c.card_boundaries_pos]
exact le_antisymm (Finset.min'_le _ _ c.zero_mem) (Fin.zero_le _)
rw [c.card_boundaries_eq_succ_length] at h
simp [blocks, Nat.lt_of_succ_lt_succ h]
simp [blocks, length, Nat.sub_le]
simp [blocks]
simp only [blocks, forall_mem_of_fn_iff, blocks_fun_pos c, forall_true_iff]
simp [Composition.toCompositionAsSet, CompositionAsSet.length, c.card_boundaries_eq_succ_length]
simp [CompositionAsSet.toComposition, Composition.length, Composition.blocks]
simp
rw [← composition_as_set_card n]
exact Fintype.card_congr (compositionEquiv n)
rw [catalan]
rw [catalan]
simp [catalan_succ]
rw [l.proper.some_spec, Option.map_none']
simp only [Option.get_or_else_none, h, l.apply]
rw [l.apply, Option.get_or_else_of_ne_none h]
simp only [line.apply, line.map, Option.get_or_else_map]
funext i
cases i <;> rfl
funext i
cases i <;> rfl
funext i
cases i <;> rfl
induction on `α
rw [← lc x, line.map_apply]
intro κ _
intro α _ ihα κ _
cases nonempty_fintype κ
      -- Later we'll need `α` to be nonempty. So we first deal with the trivial case where `α` is empty.
      -- Then `option α` has only one element, so any line is monochromatic.
induction on `r
rw [← hc]
simp only [Ultrafilter.eventually_mul, mul_assoc]
rw [← U_idem] at hs
exact hs
intro m hm
exact this _ m hm ⟨s₀, sU⟩ rfl
simp [-Set.bot_eq_empty]
simp [-Set.bot_eq_empty]
rw [← G.mem_edge_set, ← h]
exact hvw
simp
simp
simp
simp
simp
intro H H' h
constructor
· intro
    simp only [comap_verts, Set.mem_preimage]
    apply h.1
· intro v w
    simp (config := { contextual := true }) only [comap_adj, and_imp, true_and_iff]
    intro
    apply h.2
simp only [inclusion, RelHom.coe_fn_mk, Subtype.mk_eq_mk] at h
exact Subtype.ext h
rw [degree, Set.to_finset_card]
rw [← card_neighbor_set_eq_degree]
exact Set.card_le_of_subset (G'.neighbor_set_subset v)
rw [← card_neighbor_set_eq_degree]
exact Fintype.card_congr (coe_neighbor_set_equiv v)
rw [← card_neighbor_set_eq_degree, subgraph.degree]
congr
rw [← finset_card_neighbor_set_eq_degree, Finset.card_eq_one, Finset.singleton_iff_unique_mem]
simp only [Set.mem_to_finset, mem_neighbor_set]
refine' ⟨fun h => h.1 (Set.mem_singleton v), _⟩
intro h
constructor
· simp [h]
· simp [-Set.bot_eq_empty]
simp [h]
simp
rw [subgraph_of_adj_symm hvw.symm]
exact neighbor_set_fst_subgraph_of_adj hvw.symm
constructor <;> simp [-Set.bot_eq_empty]
constructor <;> simp [-Set.bot_eq_empty]
simp [G'.adj_comm, Sym2.eq_swap]
constructor <;> simp (config := { contextual := true })
constructor <;>
    simp (config := { contextual := true }) only [delete_edges_verts, delete_edges_adj,
      true_and_iff, and_imp]
exact fun v w hvw hs' hs => hs' (h hs)
simp (config := { contextual := true })
constructor
· simp [hs]
· simp (config := { contextual := true }) only [induce_adj, true_and_iff, and_imp]
    intro v w hv hw ha
    exact ⟨hs hv, hs hw, hg.2 ha⟩
rfl
rfl
simp [and_assoc']
simp [delete_verts]
constructor <;> simp [Set.diff_subset]
simp [or_comm']
rw [card_common_neighbors_top]
exact h
apply @Nat.add_right_cancel _ (Fintype.card (G.common_neighbors v w))
rw [Nat.sub_add_cancel, ← Set.to_finset_card]
·
    simp [neighbor_finset, common_neighbors, Set.to_finset_inter, Finset.card_union_add_card_inter,
      h.regular.degree_eq, two_mul]
· apply le_trans (card_common_neighbors_le_degree_left _ _ _)
    simp [h.regular.degree_eq, two_mul]
rw [← h.of_not_adj v w hne ha]
apply h.card_neighbor_finset_union_eq
rw [← h.of_adj v w ha]
apply h.card_neighbor_finset_union_eq
rw [← h.card, Nat.sub_sub, add_comm, ← Nat.sub_sub]
exact h.regular.compl
simp [is_acyclic_iff_forall_adj_is_bridge, Sym2.forall]
simp only [walk.is_path_def, hc.2]
rw [← not_iff_not, not_clique_free_iff, not_isEmpty_iff]
simp [h.apply_diag i]
rw [← apply_ne_one_iff h, not_not]
simp [h]
simp only [to_graph]
infer_instance
simp [compl]
simp [h]
simp [neighbor_finset_eq_filter, dot_product, sum_filter]
simp [neighbor_finset_eq_filter, dot_product, sum_filter, Finset.sum_apply]
rw [mul_vec, adj_matrix_dot_product]
simp [mul_apply, neighbor_finset_eq_filter, sum_filter]
simp [mul_apply, neighbor_finset_eq_filter, sum_filter, adj_comm]
simp [Matrix.trace]
simp [degree]
simp [degree]
simp [hd v]
subst_vars
rfl
subst_vars
rfl
subst_vars
rfl
subst_vars
rfl
cases w <;> rfl
rw [cons_append, append_nil]
dsimp only [append]
rw [append_assoc]
subst_vars
rfl
simp [reverse_aux_append p' (cons (G.symm h) q) r]
simp [reverse]
simp [reverse]
subst_vars
rfl
simp [reverse]
simp [reverse_reverse]
subst_vars
rfl
simp
simp [length_append, add_left_comm, add_comm]
simp!
simp [length_reverse_aux, Nat.add_succ, Nat.succ_add]
simp [reverse]
cases p <;> simp
subst_vars
rfl
induction p <;> cases p' <;> simp [*]
induction p <;> simp [support_append, *]
cases p <;> simp
rw [support_append, List.tail_append_of_ne_nil _ _ (support_ne_nil _)]
cases p <;> simp
cases p <;> simp
induction p <;> simp [*]
cases p <;> simp
simp
rw [tail_support_append, List.mem_append]
simp only [mem_support_iff, mem_tail_support_append_iff]
simp only [walk.support_append, List.subset_append_left]
intro h
simp (config := { contextual := true }) only [mem_support_append_iff, or_true_iff, imp_true_iff]
cases p <;> rfl
rw [support_append, ← Multiset.coe_add, coe_support]
rw [support_append, ← Multiset.coe_add]
simp only [coe_support]
rw [add_comm {v}]
simp only [← add_assoc, add_tsub_cancel_right]
subst_vars
rfl
induction p <;> simp [*]
induction p <;> simp [*, Sym2.eq_swap]
simp
induction p <;> simp! [*]
induction p <;> simp! [*]
subst_vars
rfl
simp [edges]
simp [edges]
induction p <;> simp [*]
induction p <;> simp [*]
simp [edges]
simp [h]
rw [Sym2.eq_swap] at he
exact p.fst_mem_support_of_mem_edges he
induction p
· simp
· simp only [darts_cons, support_cons, List.nodup_cons] at h⊢
    refine' ⟨fun h' => h.1 (dart_fst_mem_support_of_mem_darts p_p h'), p_ih h.2⟩
induction p
· simp
· simp only [edges_cons, support_cons, List.nodup_cons] at h⊢
    exact ⟨fun h' => h.1 (fst_mem_support_of_mem_edges p_p h'), p_ih h.2⟩
subst_vars
rfl
subst_vars
rfl
subst_vars
rfl
subst_vars
rfl
simp [edges]
simp [is_trail_def]
simp [is_trail_def, and_comm']
rw [is_trail_def, edges_append, List.nodup_append] at h
exact ⟨h.1⟩
rw [is_trail_def, edges_append, List.nodup_append] at h
exact ⟨h.2.1⟩
simp [is_path_def]
constructor <;> simp (config := { contextual := true }) [is_path_def]
cases p <;> simp [is_path.nil]
simp only [is_path_def, support_append]
exact List.Nodup.of_append_left
rw [← is_path_reverse_iff] at h⊢
rw [reverse_append] at h
apply h.of_append_left
rw [is_path_def]
infer_instance
rw [Nat.lt_iff_add_one_le, ← length_support]
exact hp.support_nodup.length_le_card
rw [mem_support_nil_iff.mp h]
subst u
rw [mem_support_nil_iff.mp h]
subst u
exact cons r p
subst_vars
exact h
subst_vars
rfl
subst_vars
exact h
subst_vars
rfl
rw [← take_spec p h, mem_support_append_iff]
exact Or.inl hx
rw [← take_spec p h, mem_support_append_iff]
exact Or.inr hx
rw [← take_spec p h, darts_append, List.mem_append]
exact Or.inl hx
rw [← take_spec p h, darts_append, List.mem_append]
exact Or.inr hx
have := congr_arg walk.length (p.take_spec h)
rw [length_append] at this
exact Nat.le.intro this
have := congr_arg walk.length (p.take_spec h)
rw [length_append, add_comm] at this
exact Nat.le.intro this
simp only [rotate, tail_support_append]
apply List.IsRotated.trans List.is_rotated_append
rw [← tail_support_append, take_spec]
simp only [rotate, darts_append]
apply List.IsRotated.trans List.is_rotated_append
rw [← darts_append, take_spec]
rw [is_trail_def, (c.rotate_edges h).Perm.nodup_iff]
exact hc.edges_nodup
refine' ⟨hc.to_circuit.rotate _, _⟩
rw [List.IsRotated.nodup_iff (support_rotate _ _)]
exact hc.support_nodup
simp [h.ne]
simp [singleton]
simp [p.loop_eq]
simp [walk.is_cycle_def, walk.cons_is_trail_iff, he]
subst_vars
rfl
rw [hu]
rw [hv]
subst_vars
rfl
induction p <;> simp [*]
induction p <;> simp [*]
rw [h]
rw [h]
subst_vars
rfl
cases p <;> simp
induction p <;> simp [*]
induction p <;> simp [*]
induction p <;> simp [map_append, *]
induction p <;> simp [*]
induction p <;> simp [*]
induction p <;> simp [*]
rw [is_cycle_def, is_cycle_def, map_is_trail_iff_of_injective hinj, Ne.def, map_eq_nil_iff,
    support_map, ← List.map_tail, List.nodup_map_iff hinj]
simp
simp [he]
induction p <;> simp only [*, transfer, eq_self_iff_true, heq_iff_eq, and_self_iff]
induction p <;>
    simp only [*, transfer, map_cons, hom.map_spanning_subgraphs_apply, eq_self_iff_true,
      heq_iff_eq, and_self_iff, map_nil]
induction p <;> simp only [*, transfer, edges_nil, edges_cons, eq_self_iff_true, and_self_iff]
induction p <;> simp only [*, transfer, eq_self_iff_true, and_self_iff, support_nil, support_cons]
induction p <;> simp [*]
cases p <;>
    simp only [transfer, is_cycle.not_of_nil, cons_is_cycle_iff, transfer, edges_transfer] at pc⊢
· exact pc
· exact ⟨pc.left.transfer _, pc.right⟩
rw [p.edges_transfer hp]
exact hp'
induction p <;> simp only [transfer, eq_self_iff_true, heq_iff_eq, true_and_iff]
apply p_ih
apply hpq
simp [he]
apply hpq
simp [he]
induction p <;>
    simp only [transfer, nil_append, cons_append, eq_self_iff_true, heq_iff_eq, true_and_iff]
apply p_ih
simp only [edges_reverse, List.mem_reverse]
exact hp
induction p <;> simp only [*, transfer_append, transfer, reverse_nil, reverse_cons]
rfl
simp only [edge_set_delete_edges, Set.mem_diff]
exact fun e ep => ⟨edges_subset_edge_set p ep, hp e ep⟩
rw [← transfer_eq_map_of_le, transfer_transfer, transfer_self]
subst_vars
exact h
subst_vars
rfl
rw [← Set.nonempty_iff_univ_nonempty]
exact hconn u v
subst u
exact {walk.nil}
simp
rw [← Finset.mem_coe, coe_finset_walk_length_eq]
rw [← Finset.mem_coe, coe_finset_walk_length_eq]
simp [walk.mem_finset_walk_length_iff_length_eq, and_comm']
unfold preconnected
infer_instance
rw [connected_iff, ← Finset.univ_nonempty_iff]
exact And.decidable
simp [reachable_comm]
simp
rw [is_bridge_iff, and_congr_right']
rw [reachable_delete_edges_iff_exists_walk, not_exists_not]
simp
  -- We have two walks from v to w
  --      pvu     puw
  --   v ----> u ----> w
  --   |               ^
  --    `-------------'
  --      pwv.reverse
  -- so they both contain the edge ⟦(v, w)⟧, but that's a contradiction since c is a trail.
simp [dist, Nat.Inf_eq_zero, reachable]
simp
simp [hr]
simp [h, hne]
simp [hconn u v]
simp [hconn.dist_eq_zero_iff, hne]
simp [h]
intro v w
cases v <;> cases w <;> simp
intro v
cases v <;> simp
unfold neighbor_set
infer_instance
simp only [mem_edge_set, exists_prop, SetCoe.exists, exists_eq_right, Subtype.coe_mk]
erw [← Sym2.other_spec h, Sym2.eq_swap] at he
exact G.ne_of_adj he
rw [edge_set_bot]
infer_instance
rw [edge_set_sup]
infer_instance
rw [edge_set_inf]
exact Set.fintypeInter _ _
rw [edge_set_sdiff]
exact Set.fintypeDiff _ _
simp
rw [edge_set_from_edge_set s]
infer_instance
simp [edge_finset]
simp [edge_finset]
simp [edge_finset]
simp [edge_finset]
simp [edge_finset]
simp [edge_finset]
simp [edge_finset]
simp [incidence_set]
simp only [mem_incidence_set, mem_neighbor_set]
simp [other_vertex_of_incident]
simp
simp [adj_comm, Sym2.eq_swap]
intro
simp (config := { contextual := true })
simp (config := { contextual := true }) only [delete_edges_adj, and_imp, true_and_iff]
exact fun ha hn hs => hn (h hs)
intro G G' h _ _ ha
exact h ha
rw [map_le_iff_le_comap]
exact le_refl _
simp only [degree, card_pos, Finset.Nonempty, mem_neighbor_finset]
rw [Fintype.card_congr (G.incidence_set_equiv_neighbor_set v)]
simp
rw [← G.card_incidence_set_eq_degree]
apply Set.to_finset_card
intro v
rw [degree_compl, h v]
simp only [neighbor_finset, neighbor_set_compl, Set.to_finset_diff, Set.to_finset_compl,
    Set.to_finset_singleton]
erw [degree, neighbor_finset_eq_filter, filter_ne, card_erase_of_mem (mem_univ v), card_univ]
erw [degree, neighbor_finset_eq_filter, filter_false]
exact Finset.card_empty
intro v
simp
simp [min_degree, ht]
simp
rw [← card_neighbor_set_eq_degree]
exact Set.card_le_of_subset (Set.inter_subset_left _ _)
simp only [common_neighbors_top_eq, ← Set.to_finset_card, Set.to_finset_diff]
rw [Finset.card_sdiff]
· simp [Finset.card_univ, h]
· simp only [Set.to_finset_subset, Set.subset_univ]
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp [h]
simp
rw [← Fintype.card_fin n] at hn
exact G.recolor_of_card_le hn hc.some
simp
simp
dsimp only [chromatic_number]
rw [Nat.Inf_def]
apply Nat.find_spec
exact colorable_set_nonempty_of_colorable hc
cases nonempty_fintype V
exact colorable_chromatic_number G.colorable_of_fintype
rw [← nonpos_iff_eq_zero]
apply cInf_le chromatic_number_bdd_below
apply colorable_of_is_empty
have h' := G.colorable_chromatic_number_of_fintype
rw [h] at h'
exact G.is_empty_of_colorable_zero h'
apply le_cInf (colorable_set_nonempty_of_colorable hc)
intro m hm
apply cInf_le chromatic_number_bdd_below
apply h
apply colorable_chromatic_number hc
intro v w
cases v <;> cases w <;> simp
simp
cases nonempty_fintype V
exact h.card_le_of_colorable G.colorable_chromatic_number_of_fintype
rw [inc_matrix_apply_mul_inc_matrix_apply, Set.indicator_of_not_mem]
rw [G.incidence_set_inter_incidence_set_of_not_adj h hab]
exact Set.not_mem_empty e
rw [inc_matrix_apply, Set.indicator_of_not_mem h]
rw [inc_matrix_apply, Set.indicator_of_mem h, Pi.one_apply]
simp only [inc_matrix_apply, Set.indicator_apply_eq_zero, Pi.one_apply, one_ne_zero]
exact Iff.rfl
simp [inc_matrix_apply', sum_boole, Set.filter_mem_univ_eq_to_finset]
rw [← sum_inc_matrix_apply]
simp [Matrix.mul_apply, inc_matrix_apply', ← ite_and_mul_zero]
simp only [interedges, and_assoc', mem_filter, Finset.mem_product]
rw [interedges, Finset.empty_product, filter_empty]
simp only [mem_bUnion, mem_interedges_iff, exists_and_right]
simp only [mem_interedges_iff, mem_bUnion, ← exists_and_left, ← exists_and_right]
rw [edge_density, Finset.card_empty, Nat.cast_zero, zero_mul, div_zero]
rw [edge_density, Finset.card_empty, Nat.cast_zero, mul_zero, div_zero]
simp [hs₂.ne_empty, ht₂.ne_empty]
rw [abs_sub_le_iff, ← sub_zero (1 : ℚ)]
constructor <;> exact sub_le_sub (edge_density_le_one r _ _) (edge_density_nonneg r _ _)
rw [mem_interedges_iff, mem_interedges_iff, hr.iff]
exact and_left_comm
rw [edge_density, mul_comm, card_interedges_comm hr, edge_density]
refine' filter_congr fun x hx => _
rw [mem_product] at hx
rw [compl_adj, and_iff_right (h.forall_ne_finset hx.1 hx.2)]
rw [is_trail_def, List.nodup_iff_count_le_one]
intro e
simp only [Finset.mem_mk, Multiset.mem_coe, h.mem_edges_iff]
simp
rw [mem_edge_finset]
apply dart.edge_mem
rw [hg]
apply Nat.succ_pos
have := h₀ (empty_subset _)
rw [coe_empty, Finset.card_empty, cast_zero, delete_edges_empty_eq] at this
exact nonpos_of_mul_nonpos_left (this h₁) (cast_pos.2 <| sq_pos_of_pos Fintype.card_pos)
simp [and_comm', or_comm', eq_comm, adj_comm]
simp
rw [box_prod_adj, and_iff_left rfl, or_iff_left fun h : H.adj b b ∧ _ => h.1.Ne rfl]
rw [box_prod_adj, and_iff_left rfl, or_iff_right fun h : G.adj a a ∧ _ => h.1.Ne rfl]
simp only [box_prod_adj, Equiv.prod_assoc_apply, or_and_right, or_assoc', Prod.ext_iff,
      and_assoc', @and_comm (x.1.1 = _)]
rw [hH.2] <;> exact w.of_box_prod_left
rw [hG.2] <;> exact w.of_box_prod_right
rw [hucard, mul_add, mul_one, ← add_assoc, ← add_mul,
    Nat.sub_add_cancel ((Nat.le_succ _).trans a_add_one_le_four_pow_parts_card), mul_comm]
rw [step_bound, ← Nat.div_div_eq_div_mul]
exact Nat.div_mul_le_self _ _
refine' (hε hs' ht' (le_trans _ hs) (le_trans _ ht)).trans_le h <;>
    exact mul_le_mul_of_nonneg_left h (Nat.cast_nonneg _)
rw [edge_density_comm _ t', edge_density_comm _ t]
exact h hs' ht' hs ht
simp
simp
intro s' hs' t' ht' hs ht
rw [mul_one] at hs ht
rw [eq_of_subset_of_card_le hs' (Nat.cast_le.1 hs),
    eq_of_subset_of_card_le ht' (Nat.cast_le.1 ht), sub_self, abs_zero]
exact zero_lt_one
unfold is_uniform
simp only [not_forall, not_lt, exists_prop]
rw [nonuniform_witnesses, dif_pos h]
exact (not_is_uniform_iff.1 h).some_spec.1
rw [nonuniform_witnesses, dif_pos h]
exact (not_is_uniform_iff.1 h).some_spec.2.some_spec.2.1
rw [nonuniform_witnesses, dif_pos h]
exact (not_is_uniform_iff.1 h).some_spec.2.some_spec.1
rw [nonuniform_witnesses, dif_pos h]
exact (not_is_uniform_iff.1 h).some_spec.2.some_spec.2.2.1
rw [nonuniform_witnesses, dif_pos h]
exact (not_is_uniform_iff.1 h).some_spec.2.some_spec.2.2.2
rw [non_uniforms, mem_filter, mem_off_diag, and_assoc', and_assoc']
rw [Finpartition.IsUniform, Finpartition.card_bot, non_uniforms_bot _ hε, Finset.card_empty,
    Nat.cast_zero]
exact mul_nonneg (Nat.cast_nonneg _) hε.le
rw [is_uniform, mul_one, Nat.cast_le]
refine' (card_filter_le _ _).trans _
rw [off_diag_card, Nat.mul_sub_left_distrib, mul_one]
simp [is_uniform, hP, non_uniforms]
rw [off_diag_card, one_mul, ← Nat.cast_pow, Nat.cast_le, sq]
exact tsub_le_self
simp
simp
simp [Unique.eq_default P]
simp [hab.2]
rw [card_sdiff (htu.trans <| P.le hu₁), htn, hn₃]
rw [← filter_or, filter_true_of_mem]
exact fun x => card_eq_of_mem_parts_equitabilise
rw [← filter_true_of_mem fun x => card_eq_of_mem_parts_equitabilise, filter_or, card_union_eq,
    P.card_filter_equitabilise_small _ hm, P.card_filter_equitabilise_big]
exact disjoint_filter.2 fun x _ h₀ h₁ => Nat.succ_ne_self m <| h₁.symm.trans h₀
infer_instance
rw [tsub_mul, mul_add, ← add_assoc,
      tsub_add_cancel_of_le (Nat.mul_le_mul_right _ (mod_lt _ hn).le), mul_one, add_comm,
      mod_add_div]
simp only [is_matching.to_edge, Subtype.mk_eq_mk]
congr
exact ((h (M.edge_vert hvw)).some_spec.2 w hvw).symm
rw [h.to_edge_eq_of_adj hv ha, h.to_edge_eq_of_adj hw (M.symm ha), Subtype.mk_eq_mk, Sym2.eq_swap]
simp [degree_eq_one_iff_unique_adj, is_perfect_matching_iff]
intro hn
have hw := P.mem_part_of_vertex w
rw [← hn] at hw
exact P.independent _ (P.part_of_vertex_mem v) (P.mem_part_of_vertex v) hw (G.ne_of_adj h) h
rw [Ne.def, Subtype.mk_eq_mk]
exact P.part_of_vertex_ne_of_adj hvw
rw [Multiset.coe_sum, c.blocks_sum]
apply of_mem_filter hi
  parts_sum
rw [Multiset.sum_eq_zero_iff]
simp
rw [w]
induction U using Opposite.rec
cases U
rfl
induction U using Opposite.rec
cases U
simp only [id_c]
dsimp
simp
subst h
subst h
dsimp
simp
rw [← map_comp, ← map_comp]
rfl
cases V
simp [opens.map, Set.preimage_image_eq _ hf.inj]
dsimp
rw [opens.inclusion_top_functor X.carrier]
rfl
rw [restrict_top_presheaf, ← presheaf.pushforward.comp_eq]
erw [iso.inv_hom_id]
rw [presheaf.pushforward.id_eq]
rw [iso.inv_comp_eq, iso_restrict_hom_of_restrict]
rw [← H.iso_restrict_hom_of_restrict]
apply mono_comp
dsimp only [opens.map, IsOpenMap.functor, PresheafedSpace.comp_base]
congr 1
rw [coe_comp, ← Set.image_image, Set.preimage_image_eq _ hg.base_open.inj]
dsimp only [IsOpenMap.functor]
congr 1
rw [comp_base, coe_comp, ← Set.image_image]
congr
simp [opens.map, Set.preimage_image_eq _ H.base_open.inj]
simp only [inv_app, ← category.assoc]
rw [is_iso.comp_inv_eq]
simp only [category.assoc, f.c.naturality, is_iso.inv_hom_id_assoc, ← X.presheaf.map_comp]
erw [← X.presheaf.map_comp]
congr
delta inv_app
infer_instance
simp [opens.map, Set.preimage_image_eq _ H.base_open.inj]
rw [← cancel_epi (H.inv_app U)]
rw [is_iso.hom_inv_id]
delta inv_app
simp [← functor.map_comp]
simp [opens.map, Set.preimage_image_eq _ H.base_open.inj]
rw [inv_app, category.assoc, is_iso.inv_hom_id, category.comp_id]
erw [← category.assoc]
rw [is_iso.comp_inv_eq, f.c.naturality]
congr
apply LE.le.antisymm
· exact Set.image_preimage_subset f.base U.1
· change U
erw [← category.assoc]
rw [is_iso.comp_inv_eq, f.c.naturality]
congr
cases U
dsimp only [opens.map, IsOpenMap.functor]
congr 1
rw [Set.preimage_image_eq _ hf.inj]
rfl
delta PresheafedSpace.is_open_immersion.inv_app
rw [is_iso.comp_inv_eq, category.id_comp]
change X.presheaf.map _ = X.presheaf.map _
congr
rw [set.range_iff_surjective.mpr ((TopCat.epi_iff_surjective _).mp h')]
trivial
induction U using Opposite.rec
cases U
dsimp only [functor.op, opens.map]
congr
exact (Set.image_preimage_eq _ ((TopCat.epi_iff_surjective _).mp h')).symm
rw [← H.iso_restrict_hom_of_restrict]
rw [PresheafedSpace.stalk_map.comp]
infer_instance
intro U V i
induction U using Opposite.rec
induction V using Opposite.rec
simp only [Quiver.Hom.unop_op, TopCat.Presheaf.pushforward_obj_map, category.assoc,
          nat_trans.naturality_assoc, functor.op_map, inv_naturality_assoc, ← Y.presheaf.map_comp]
erw [← Y.presheaf.map_comp]
congr
erw [s.snd.c.naturality_assoc]
rw [category.assoc]
erw [← s.X.presheaf.map_comp, ← s.X.presheaf.map_comp]
congr
erw [CategoryTheory.Limits.PullbackCone.mk_snd]
infer_instance
delta pullback.snd
rw [← limit.iso_limit_cone_hom_π ⟨_, pullback_cone_of_left_is_limit f g⟩ walking_cospan.right]
infer_instance
rw [← pullback_symmetry_hom_comp_snd]
infer_instance
rw [← limit.w (cospan f g) walking_cospan.hom.inl, cospan_map_inl]
infer_instance
erw [category.assoc]
rw [is_iso.inv_comp_eq]
exact pullback.condition
rw [← cancel_mono f, hl, lift_fac]
rw [← cancel_mono f]
simp
rw [← cancel_mono g]
simp
apply TopCat.Presheaf.is_sheaf_of_iso (sheaf_iso_of_iso H.iso_restrict.symm).symm
apply TopCat.Sheaf.pushforward_sheaf_of_sheaf
exact (Y.restrict H.base_open).IsSheaf
cases X
rfl
cases X
delta to_LocallyRingedSpace
simp
infer_instance
apply has_limit_of_iso (diagramIsoCospan.{v} _).symm
change has_limit (cospan (forget.map f) (forget.map g))
infer_instance
apply has_limit_of_iso (diagramIsoCospan.{v} _).symm
change has_limit (cospan (forget.map g) (forget.map f))
infer_instance
congr
congr
rw [← limit.w (cospan f g) hom.inl, cospan_map_inl]
infer_instance
infer_instance
infer_instance
delta pullback.snd
rw [← limit.iso_limit_cone_hom_π ⟨_, pullback_cone_of_left_is_limit f g⟩ walking_cospan.right]
infer_instance
rw [← pullback_symmetry_hom_comp_snd]
infer_instance
rw [← limit.w (cospan f g) walking_cospan.hom.inl, cospan_map_inl]
infer_instance
apply (is_limit_map_cone_pullback_cone_equiv _ _).symm.toFun
apply is_limit_of_is_limit_pullback_cone_map SheafedSpace.forget_to_PresheafedSpace
exact PresheafedSpace.is_open_immersion.pullback_cone_of_left_is_limit f.1 g.1
apply (is_limit_map_cone_pullback_cone_equiv _ _).symm.toFun
exact PresheafedSpace.is_open_immersion.pullback_cone_of_left_is_limit f.1 g.1
erw [category.assoc]
rw [is_iso.inv_comp_eq]
exact pullback.condition
rw [← cancel_mono f, hl, lift_fac]
apply LocallyRingedSpace.iso_of_SheafedSpace_iso
refine' SheafedSpace.forget_to_PresheafedSpace.preimage_iso _
exact H.iso_restrict
infer_instance
intro x
erw [coe_comp]
rw [Set.range_comp, set.range_iff_surjective.mpr, Set.image_univ]
erw [Subtype.range_coe_subtype]
exact (X.local_affine x).some.2
rw [← TopCat.epi_iff_surjective]
change epi ((SheafedSpace.forget _).map (LocallyRingedSpace.forget_to_SheafedSpace.map _))
infer_instance
rw [set.range_iff_surjective.mpr]
· trivial
rw [← TopCat.epi_iff_surjective]
infer_instance
rw [e₂, Scheme.comp_val_base, coe_comp, Set.range_comp, set.range_iff_surjective.mpr,
        Set.image_univ, e₁.right_inverse_symm]
· exact 𝒰.covers x
· rw [← TopCat.epi_iff_surjective]
        infer_instance
rw [e₂]
infer_instance
rw [set.range_iff_surjective.mpr ((TopCat.epi_iff_surjective _).mp _)]
· exact trivial
· infer_instance
erw [coe_comp, Set.range_comp]
congr
exact (PrimeSpectrum.localization_away_comap_range (Localization.Away r) r : _)
rw [← e] at haU
exact haU
delta open_cover.finite_subcover
infer_instance
cases X
cases Y
congr
exact H
apply Scheme_eq_of_LocallyRingedSpace_eq
exact LocallyRingedSpace_to_LocallyRingedSpace f
infer_instance
infer_instance
infer_instance
apply has_limit_of_iso (diagramIsoCospan.{u} _).symm
change has_limit (cospan (forget.map f) (forget.map g))
infer_instance
apply has_limit_of_iso (diagramIsoCospan.{u} _).symm
change has_limit (cospan (forget.map g) (forget.map f))
infer_instance
simp
simp
have := preserves_pullback.iso_hom_snd forget f g
dsimp only [Scheme.forget_to_LocallyRingedSpace, induced_functor_map] at this
rw [← this]
change LocallyRingedSpace.is_open_immersion _
infer_instance
rw [← pullback_symmetry_hom_comp_snd]
infer_instance
rw [pullback.condition, Scheme.comp_val_base, coe_comp, Set.range_comp,
    range_pullback_snd_of_left, opens.map_obj, Subtype.coe_mk, Set.image_preimage_eq_inter_range,
    Set.inter_comm]
rw [Scheme.comp_val_base, coe_comp, Set.range_comp, range_pullback_fst_of_right, opens.map_obj,
    Subtype.coe_mk, Set.image_preimage_eq_inter_range, Set.inter_comm]
rw [← cancel_mono f]
simp
rw [← cancel_mono g]
simp
change Set.range coe
intro U V i
dsimp [-Subtype.val_eq_coe, -Scheme.restrict_functor_map_left]
rw [X.restrict_functor_map_app, ← functor.map_comp, ← functor.map_comp]
congr 1
rw [Set.eq_univ_iff_forall]
intro x
rw [Set.mem_Union]
exact ⟨𝒰.f x, 𝒰.covers x⟩
rw [opens.coe_supr]
exact 𝒰.Union_range
cases nonempty_fintype 𝒰.J
rw [← is_compact_univ_iff, ← 𝒰.Union_range]
apply is_compact_Union
intro i
rw [is_compact_iff_compact_space]
exact
    @Homeomorph.compact_space _ _ (H i)
      (TopCat.homeoOfIso
        (as_iso
          (is_open_immersion.iso_of_range_eq (𝒰.map i)
                  (X.of_restrict (opens.open_embedding ⟨_, (𝒰.is_open i).base_open.open_range⟩))
                  subtype.range_coe.symm).Hom.1.base))
rw [is_open_immersion.range_pullback_to_base_of_left]
exact ⟨𝒰₁.covers x, 𝒰₂.covers x⟩
refine' is_open_immersion.iso_of_range_eq pullback.fst (X.of_restrict _) _
rw [is_open_immersion.range_pullback_fst_of_right]
dsimp [opens.inclusion]
rw [Subtype.range_coe, Subtype.range_coe]
rfl
delta pullback_restrict_iso_restrict
simp
delta pullback_restrict_iso_restrict
simp
delta morphism_restrict
rw [category.assoc, pullback.condition.symm, pullback_restrict_iso_restrict_inv_fst_assoc]
delta morphism_restrict
infer_instance
rw [category.comp_id, category.id_comp]
rw [category.comp_id, is_open_immersion.iso_of_range_eq_hom, is_open_immersion.lift_fac]
subst e
refine' morphism_restrict_restrict _ _ _
delta morphism_restrict
infer_instance
erw [PresheafedSpace.stalk_map.id]
apply is_local_ring_hom_id
erw [PresheafedSpace.stalk_map.comp]
exact @is_local_ring_hom_comp _ _ _ _ _ _ _ _ (f.2 _) (g.2 _)
infer_instance
intro x
dsimp at *
    -- We show that the stalk of the restriction is isomorphic to the original stalk,
apply @RingEquiv.local_ring _ _ _ (X.local_ring (f x))
exact (X.to_PresheafedSpace.restrict_stalk_iso h x).symm.commRingIsoToRingEquiv
induction U using Opposite.rec
cases U
rfl
subst e
subst e
dsimp
simp
rw [← is_iso.inv_comp_eq, ← functor.map_inv, f.val.c.naturality, presheaf.pushforward_obj_map]
congr
rw [is_iso.eq_comp_inv]
erw [← Scheme.comp_val_c_app]
rw [Scheme.congr_app (is_iso.hom_inv_id f), Scheme.id_app, ← functor.map_comp, eq_to_hom_trans,
    eq_to_hom_op]
rfl
rw [unop_id, Spec_map_id]
rw [unop_comp, Spec_map_comp]
exact this
  erw [← is_unit_map_iff (structure_sheaf.stalk_to_fiber_ring_hom R x),
    structure_sheaf.stalk_to_fiber_ring_hom_to_stalk]
  exact
    (IsLocalization.AtPrime.is_unit_to_map_iff (Localization.AtPrime (PrimeSpectrum.asIdeal x))
        (PrimeSpectrum.asIdeal x) f :
      _)
apply RingHom.toAlgebra
exact X.presheaf.stalk_specializes ((generic_point_spec X.carrier).Specializes trivial)
change CommRingCat.of R
apply (generic_point_spec (Scheme.Spec.obj <| op R).carrier).Eq
simp [is_generic_point_def, ← PrimeSpectrum.zero_locus_vanishing_ideal_eq_closure]
dsimp
rw [opens.open_embedding_obj_top]
infer_instance
erw [←
    show _ = (coequalizer.π f g).base from
      ι_comp_coequalizer_comparison f g (SheafedSpace.forget C)]
rw [← preserves_coequalizer.iso_hom]
apply epi_comp
have := ι_comp_coequalizer_comparison f.1 g.1 SheafedSpace.forget_to_PresheafedSpace
rw [← preserves_coequalizer.iso_hom] at this
erw [SheafedSpace.congr_app this.symm (op U)]
rw [PresheafedSpace.comp_c_app, ←
    PresheafedSpace.colimit_presheaf_obj_iso_componentwise_limit_hom_π]
infer_instance
injection this
    delta image_basic_open
    rw [preimage_basic_open f, preimage_basic_open g]
    dsimp only [functor.op, unop_op]
    rw [← comp_apply, ← SheafedSpace.comp_c_app', ← comp_apply, ← SheafedSpace.comp_c_app',
      SheafedSpace.congr_app (coequalizer.condition f.1 g.1), comp_apply]
    erw [X.to_RingedSpace.basic_open_res]
    apply inf_eq_right.mpr
    refine' (RingedSpace.basic_open_le _ _).trans _
    rw [coequalizer.condition f.1 g.1]
    exact fun _ h => h
rw [←
    (TopCat.homeoOfIso
        (preserves_coequalizer.iso (SheafedSpace.forget _) f.1 g.1)).is_open_preimage,
    TopCat.coequalizer_is_open_iff, ← Set.preimage_comp]
erw [← coe_comp]
rw [preserves_coequalizer.iso_hom, ι_comp_coequalizer_comparison]
dsimp only [SheafedSpace.forget]
rw [image_basic_open_image_preimage]
exact (image_basic_open f g U s).2
rw [PresheafedSpace.stalk_map.congr_hom _ _ H.symm x]
infer_instance
injection s.condition
  use coequalizer.desc s.π.1 e
  · intro x
    rcases
rw [← h]
rfl
apply preserves_colimit_of_iso_diagram _ (diagram_iso_parallel_pair F).symm
apply preserves_colimit_of_preserves_colimit_cocone (coequalizer_cofork_is_colimit _ _)
apply (is_colimit_map_cocone_cofork_equiv _ _).symm _
dsimp only [forget_to_SheafedSpace]
exact coequalizer_is_coequalizer _ _
infer_instance
refine' ⟨fun U => ⟨fun s hs => _⟩⟩
apply presheaf.section_ext X.sheaf U s 0
intro x
rw [RingHom.map_zero]
change X.presheaf.germ x s = 0
exact (hs.map _).eq_zero
dsimp
infer_instance
rw [affine_is_reduced_iff]
exact h
rw [← Set.image_univ, Set.preimage_image_eq _ hf.base_open.inj, Set.top_eq_univ]
change x ∈ f.val.base
infer_instance
infer_instance
simp
trivial
rw [affine_is_integral_iff]
exact h
rw [← mem_Spec_ess_image] at h⊢
exact functor.ess_image.of_iso (as_iso f).symm h
refine' is_affine_of_iso (is_open_immersion.iso_of_range_eq f (Y.of_restrict _) _).inv
exact subtype.range_coe.symm
infer_instance
delta is_affine_open.from_Spec
infer_instance
delta is_affine_open.from_Spec
erw [← category.assoc, Scheme.comp_val_base]
rw [coe_comp, Set.range_comp, set.range_iff_surjective.mpr, Set.image_univ]
exact Subtype.range_coe
rw [← TopCat.epi_iff_surjective]
infer_instance
rw [X.presheaf.map_id, op_id, Scheme.Spec.map_id]
rw [← hU.Spec_Γ_identity_hom_app_from_Spec, iso.inv_hom_id_app_assoc]
rw [Set.image_preimage_eq_inter_range, Set.inter_eq_left_iff_subset, hU.from_Spec_range]
exact Scheme.basic_open_le _ _
apply
    (is_affine_open_iff_of_is_open_immersion (X.of_restrict (X.basic_open r).OpenEmbedding) _).mp
delta PresheafedSpace.is_open_immersion.open_functor
dsimp
rw [opens.functor_obj_map_obj, opens.open_embedding_obj_top, inf_comm, ←
    Scheme.basic_open_res _ _ (hom_of_le le_top).op]
exact hU.basic_open_is_affine _
refine' (Scheme.image_basic_open (X.of_restrict U.open_embedding) r).trans _
erw [← Scheme.basic_open_res_eq _ _ (eq_to_hom U.open_embedding_obj_top).op]
rw [← comp_apply, ← CategoryTheory.Functor.map_comp, ← op_comp, eq_to_hom_trans, eq_to_hom_refl,
      op_id, CategoryTheory.Functor.map_id, Scheme.hom.inv_app]
erw [PresheafedSpace.is_open_immersion.of_restrict_inv_app]
congr
erw [LocallyRingedSpace.preimage_basic_open]
refine'
    Eq.trans _
      (RingedSpace.basic_open_res_eq
        (Scheme.Spec.obj <| op <| X.presheaf.obj (op U)).toLocallyRingedSpace.toRingedSpace
        (eq_to_hom hU.from_Spec_base_preimage).op _)
congr
rw [← comp_apply]
congr
erw [← hU.Spec_Γ_identity_hom_app_from_Spec]
rw [iso.inv_hom_id_app_assoc]
rw [opens.inclusion_map_eq_top]
rw [opens.inclusion_map_eq_top]
rfl
rw [opens.inclusion_map_eq_top]
rfl
rw [← Scheme.basic_open_res_eq _ _ (eq_to_hom hU.from_Spec_base_preimage.symm).op,
    basic_open_eq_of_affine', is_affine_open.from_Spec_app_eq]
congr
rw [← comp_apply, ← comp_apply, category.assoc, ← functor.map_comp_assoc, eq_to_hom_op,
    eq_to_hom_op, eq_to_hom_trans, eq_to_hom_refl, CategoryTheory.Functor.map_id, category.id_comp,
    ← iso.app_inv, iso.inv_hom_id]
rfl
simp
rw [h]
rw [← hU.basic_open_union_eq_self_iff, @comm _ Eq]
refine' ⟨fun h => le_antisymm h _, le_of_eq⟩
simp only [supr_le_iff, SetCoe.forall]
intro x hx
exact X.basic_open_le x
erw [LocalRing.mem_maximal_ideal, not_not]
rw [basic_open_one] <;> trivial
dsimp [adjunction, adjunction.restrict_fully_faithful]
simp
congr 2
exact adjunction_hom_equiv _ _
rw [← adjunction.hom_equiv_symm_id, ← adjunction.hom_equiv_symm_id,
    adjunction_hom_equiv_symm_apply]
rfl
rw [← adjunction.hom_equiv_id, ← adjunction.hom_equiv_id, adjunction_hom_equiv_apply]
rfl
have := congr_app Γ_Spec.adjunction.left_triangle X
dsimp at this
rw [← is_iso.eq_comp_inv] at this
simp only [Γ_Spec.LocallyRingedSpace_adjunction_counit, nat_trans.op_app, category.id_comp,
    Γ_Spec.adjunction_counit_app] at this
rw [← op_inv, nat_iso.inv_inv_app, quiver.hom.op_inj.eq_iff] at this
exact this
erw [RingHom.map_zero, Subtype.val_eq_coe, Subring.coe_zero, Pi.zero_apply, zero_mul]
rw [const_mul, const_congr R rfl (mul_comm g f), const_self]
rw [const_mul, const_ext]
rw [mul_assoc]
rw [mul_comm, const_mul_cancel]
rw [RingHom.map_one, mul_one]
rfl
rw [← to_open_germ]
rfl
rw [to_open_eq_const, const_mul_rev]
erw [← germ_to_open R (basic_open (f : R)) ⟨x, f.2⟩ (f : R)]
exact RingHom.is_unit_map _ (is_unit_to_basic_open_self R f)
erw [← germ_to_open R (basic_open s) ⟨x, s.2⟩, ← germ_to_open R (basic_open s) ⟨x, s.2⟩, ←
      RingHom.map_mul, to_open_eq_const, to_open_eq_const, const_mul_cancel']
cases x
exact stalk_to_fiber_ring_hom_germ' R U _ _ _
erw [to_stalk, category.assoc, germ_comp_stalk_to_fiber_ring_hom]
rfl
rw [to_open_eq_const, to_open_eq_const, const_mul_cancel']
rw [to_basic_open, IsLocalization.Away.lift, RingHom.comp_apply, IsLocalization.lift_eq]
simp only [Set.mem_setOf_eq, mul_zero]
dsimp at hr₁ hr₂⊢
simp only [mul_add, hr₁, hr₂]
dsimp at hr₂⊢
simp only [mul_comm r₁ r₂, ← mul_assoc, hr₂]
rw [← category.assoc]
change to_open R
change _
rw [Subtype.coe_mk, Subtype.val_eq_coe, comap_fun, (sections_subring R (op U)).coe_one,
          Pi.one_apply, RingHom.map_one]
rfl
rw [Subtype.coe_mk, Subtype.val_eq_coe, comap_fun, (sections_subring R (op U)).coe_zero,
          Pi.zero_apply, RingHom.map_zero]
rfl
rw [Subtype.coe_mk, Subtype.val_eq_coe, comap_fun, (sections_subring R (op U)).coe_add,
          Pi.add_apply, RingHom.map_add]
rfl
rw [Subtype.coe_mk, Subtype.val_eq_coe, comap_fun, (sections_subring R (op U)).coe_mul,
          Pi.mul_apply, RingHom.map_mul]
rfl
rw [comap_apply, const_apply, const_apply]
erw [Localization.local_ring_hom_mk']
rfl
rw [hUV]
erw [comap_id_eq_map U V (eq_to_hom hUV.symm), eq_to_hom_op, eq_to_hom_map]
rw [comap_id U U rfl]
rfl
rw [comap_apply]
erw [Localization.local_ring_hom_comp _ (PrimeSpectrum.comap g p.1).asIdeal]
        -- refl works here, because `prime_spectrum.comap (g.comp f) p` is defeq to
        -- `prime_spectrum.comap f (prime_spectrum.comap g p)`
rfl
rw [Units.val_mul, Units.val_pow_eq_pow_val, coe_Δ', E.variable_change_Δ]
rw [variable_change_Δ', Units.val_mul, Units.val_pow_eq_pow_val]
rw [variable_change_Δ', mul_inv, inv_pow, inv_inv, Units.val_mul, Units.val_pow_eq_pow_val]
rw [u.mul_inv, one_pow]
rw [Units.coe_map, [anonymous], coe_Δ', E.base_change_Δ]
rw [stalk_map, stalk_functor_map_germ_assoc, stalk_pushforward_germ]
rw [← restrict_stalk_iso_hom_eq_germ, category.assoc, iso.hom_inv_id, category.comp_id]
rw [← restrict_stalk_iso_inv_eq_of_restrict]
infer_instance
rw [h₂]
rw [h₁, h₂]
subst h₁
subst h₂
simp
rw [h]
rw [← stalk_map.congr α β h x x rfl, eq_to_hom_refl, category.comp_id]
rw [h]
rw [h]
rw [stalk_map.congr α α rfl x x' h]
rw [is_iso.hom_inv_id α, id_base, TopCat.id_app]
    -- Intuitively, the inverse of the stalk map of `α` at `x` should just be the stalk map of `β`
    -- at `α x`. Unfortunately, we have a problem with dependent type theory here: Because `x`
    -- is not *definitionally* equal to `β (α x)`, the map `stalk_map β (α x)` has not the correct
    -- type for an inverse.
    -- To get a proper inverse, we need to compose with the `eq_to_hom` arrow
    -- `X.stalk x ⟶ X.stalk ((α ≫ β).base x)`.
rw [h_eq]
delta PresheafedSpace.stalk_map
simp [stalk_map]
intro X Y Z f g h₁ h₂
infer_instance
apply is_open_immersion_stable_under_composition.respects_iso
intro _ _ _
infer_instance
intro X Y Z f g H
infer_instance
intro U V hU hU' hV hV'
exact this ⟨U, hU⟩ hU' ⟨V, hV⟩ hV'
rw [quasi_separated_eq_diagonal_is_quasi_compact, quasi_compact_eq_affine_property]
exact
    diagonal_target_affine_locally_eq_target_affine_locally _ quasi_compact.affine_property_is_local
rw [quasi_separated_eq_affine_property_diagonal, quasi_compact_affine_property_diagonal_eq]
rw [quasi_separated_eq_affine_property,
    quasi_separated.affine_property_is_local.affine_target_iff f, quasi_separated.affine_property]
rw [quasi_separated_eq_affine_property,
    quasi_separated.affine_property_is_local.affine_open_cover_iff f 𝒰]
rfl
simp
erw [X.basic_open_res]
exact inf_le_left
erw [X.basic_open_res]
exact inf_le_right
rw [X.basic_open_res]
exact inf_le_left
rw [X.basic_open_res]
exact inf_le_right
intro i
exact
        exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux X i.1 S U (hs₁ i) (hs₂ i) hy₁
          hy₂
rw [←
    preserves_pullback.iso_inv_fst AffineScheme.forget_to_Scheme (AffineScheme.of_hom f)
      (AffineScheme.of_hom g),
    op_comp, functor.map_comp, hP'.cancel_right_is_iso, AffineScheme.forget_to_Scheme_map]
have :=
    _root_.congr_arg Quiver.Hom.unop
      (preserves_pullback.iso_hom_fst AffineScheme.Γ.right_op (AffineScheme.of_hom f)
        (AffineScheme.of_hom g))
simp only [Quiver.Hom.unop_op, functor.right_op_map, unop_comp] at this
delta AffineScheme.Γ at this
simp only [Quiver.Hom.unop_op, functor.comp_map, AffineScheme.forget_to_Scheme_map,
    functor.op_map] at this
rw [← this, hP'.cancel_right_is_iso, ←
    pushout_iso_unop_pullback_inl_hom (Quiver.Hom.unop _) (Quiver.Hom.unop _),
    hP'.cancel_right_is_iso]
exact hP.pushout_inl _ hP' _ _ H
exact this _ rfl
      intro V hV
      rw [Scheme.preimage_basic_open]
apply ((hP.open_cover_tfae g).out 0 3).mp H
intro i
refine' Scheme.open_cover.bind _ fun i => Scheme.affine_cover _
apply
      Scheme.open_cover.pushforward_iso _
        (pullback_right_pullback_fst_iso g (Z.affine_cover.map i) f).Hom
apply Scheme.pullback.open_cover_of_right
exact (pullback g (Z.affine_cover.map i)).affineCover
dsimp
infer_instance
dsimp
infer_instance
intro i
refine' Scheme.open_cover.bind _ fun i => Scheme.affine_cover _
apply
      Scheme.open_cover.pushforward_iso _
        (pullback_right_pullback_fst_iso g (S.affine_cover.map i) f).Hom
apply Scheme.pullback.open_cover_of_right
exact (pullback g (S.affine_cover.map i)).affineCover
rw [universally_closed_eq]
exact stable_under_composition.universally fun X Y Z f g hf hg => IsClosedMap.comp hg hf
delta affine_target_morphism_property.to_property
simp [*]
rw [← P.to_property_apply, ← P.to_property_apply, hP.cancel_left_is_iso]
rw [← P.to_property_apply, ← P.to_property_apply, hP.cancel_right_is_iso]
refine' (pullback_symmetry _ _).Hom
simp
refine'
          pullback_symmetry _ _
simp
simp
rw [category.assoc, category.assoc, pullback.condition]
rw [category.assoc, category.assoc, pullback.condition]
apply
    opens.is_compact_open_iff_eq_finite_Union_of_is_basis (coe : X.affine_opens → opens X.carrier)
· rw [Subtype.range_coe]
    exact is_basis_affine_open X
· intro i
    exact i.2.IsCompact
apply opens.is_compact_open_iff_eq_finite_Union_of_is_basis
· exact is_basis_basic_open X
· intro i
    exact ((top_is_affine_open _).basic_open_is_affine _).IsCompact
delta affine_target_morphism_property.to_property quasi_compact.affine_property
simp
apply hom_of_le
change _
dsimp [𝒰]
infer_instance
intro i
dsimp
infer_instance
simp
intro i
change (i : opens X.carrier) ≤ U
rw [e]
exact le_supr _ _
subst e
apply X.sheaf.eq_of_locally_eq fun i : s => (i : opens X.carrier)
intro i
rw [map_zero]
apply this
delta forget_to_Top LocallyRingedSpace.forget_to_Top
infer_instance
rw [← D.ι_iso_LocallyRingedSpace_inv]
infer_instance
simp
refine' (PresheafedSpace.forget _).mapIso _
rw [← (TopCat.homeoOfIso D.iso_carrier.symm).is_open_preimage]
rw [TopCat.GlueData.is_open_iff]
apply forall_congr'
intro i
erw [← Set.preimage_comp, ← coe_comp, ι_iso_carrier_inv]
refine' (pullback_right_pullback_fst_iso _ _ _).Hom
delta glued_cover_t'
simp
delta glued_cover_t'
simp
delta glued_cover_t'
simp
delta glued_cover_t'
simp
apply pullback.hom_ext <;> simp
apply pullback.hom_ext <;> simp [pullback.condition]
apply pullback.hom_ext <;> simp
  -- The `cocycle` field could have been `
refine' inv 𝒰.from_glued
rw [← ι_from_glued, category.assoc]
erw [is_iso.hom_inv_id_assoc, multicoequalizer.π_desc]
rw [← cancel_epi 𝒰.from_glued]
apply multicoequalizer.hom_ext
intro x
erw [multicoequalizer.π_desc_assoc]
erw [multicoequalizer.π_desc_assoc]
exact h x
infer_instance
induction U using Opposite.rec
cases U
rfl
induction U using Opposite.rec
cases U
simp only [id_c]
dsimp
simp
subst h
infer_instance
infer_instance
refine' IsNoetherian.induction (fun (M : Ideal R) hgt => _) I
intro z hz
refine' lt_of_le_of_ne le_sup_left fun m_eq => hz _
rw [m_eq]
exact Ideal.mem_sup_right (mem_span_singleton_self z)
apply ring.not_is_field_iff_exists_prime.mp h_fA
intro z hz
refine' lt_of_le_of_ne le_sup_left fun m_eq => hz _
rw [m_eq]
exact mem_sup_right (mem_span_singleton_self z)
rw [(noetherian_space_tfae <| PrimeSpectrum R).out 0 1]
have H := ‹IsNoetherianRing R›
rw [is_noetherian_ring_iff, is_noetherian_iff_well_founded] at H
exact (closeds_embedding R).dual.WellFounded H
cases x
rfl
cases x
rfl
rw [← SetLike.mem_coe, coe_vanishing_ideal, Set.mem_setOf_eq]
simp [vanishing_ideal]
rw [mem_vanishing_ideal, Ideal.radical_eq_Inf, Submodule.mem_Inf]
exact ⟨fun h x hx => h ⟨x, hx.2⟩ hx.1, fun h x hx => h x.1 ⟨hx, x.2⟩⟩
rw [← zero_locus_span {f}, ← zero_locus_span {g}, zero_locus_subset_zero_locus_iff, Ideal.span_le,
    Set.singleton_subset_iff, SetLike.mem_coe]
infer_instance
rw [Ideal.eq_top_iff_one]
exact hx h
rw [← top_le_iff, ← subset_zero_locus_iff_le_vanishing_ideal, Submodule.top_coe, zero_locus_univ,
    Set.subset_empty_iff]
simp only [zero_locus_Union]
rw [zero_locus_inf]
simp
rw [Set.mem_compl_iff, mem_zero_locus, Set.singleton_subset_iff] <;> rfl
simp
rw [← is_open_compl_iff, is_open_iff, compl_compl]
rw [is_closed_iff_zero_locus]
exact ⟨s, rfl⟩
rw [← zero_locus_vanishing_ideal_eq_closure, vanishing_ideal_singleton]
rw [← vanishing_ideal_closure, ← zero_locus_vanishing_ideal_eq_closure,
    vanishing_ideal_zero_locus_eq_radical]
apply Ideal.radical_is_radical
rw [Set.ssubset_def, vanishing_ideal_anti_mono_iff hs, vanishing_ideal_anti_mono_iff ht,
    lt_iff_le_not_le]
rw [← is_irreducible_iff_closure, ← zero_locus_vanishing_ideal_eq_closure,
    is_irreducible_zero_locus_iff_of_radical _ (is_radical_vanishing_ideal s)]
rw [IsGenericPoint, closure_singleton, zero_locus_vanishing_ideal_eq_closure, h₂.closure_eq]
rw [preimage_comap_zero_locus, surjective.image_preimage hf, hF]
rw [range_comap_of_surjective _ f hf]
exact is_closed_zero_locus ↑(ker f)
simp
simp
rw [TopologicalSpace.Opens.le_def, basic_open_eq_zero_locus_compl, basic_open_eq_zero_locus_compl,
    Set.le_eq_subset, Set.compl_subset_compl, zero_locus_subset_zero_locus_singleton_iff]
simp [zero_locus_singleton_mul]
rw [basic_open_mul f g]
exact inf_le_left
rw [basic_open_mul f g]
exact inf_le_right
rw [← vanishing_ideal_zero_locus_eq_radical]
apply vanishing_ideal_anti_mono hZ
exact subset_vanishing_ideal_zero_locus {f} (Set.mem_singleton f)
rw [← subtype.coe_injective.eq_iff, basic_open_eq_zero_locus_compl]
simp only [Set.eq_univ_iff_forall, Set.singleton_subset_iff, TopologicalSpace.Opens.coe_bot,
    nilpotent_iff_mem_prime, Set.compl_empty_iff, mem_zero_locus, SetLike.mem_coe]
exact ⟨fun h I hI => h ⟨I, hI⟩, fun h ⟨I, hI⟩ => h I hI⟩
rw [localization_away_comap_range S r]
exact is_open_basic_open
rw [← as_ideal_le_as_ideal, ← zero_locus_vanishing_ideal_eq_closure, mem_zero_locus,
    vanishing_ideal_singleton, SetLike.coe_subset_coe]
rw [(local_hom_tfae f).out 0 4, PrimeSpectrum.ext_iff]
rfl
rw [image_of_Df, set_of_exists fun i (x : PrimeSpectrum R) => coeff f i ∉ x.asIdeal]
exact is_open_Union fun i => is_open_basic_open
rw [← mul_one <| algebraMap R K y, ← Algebra.smul_def, hy, one_smul]
rw [Algebra.smul_def, mul_one, map_mul, smul_comm, Algebra.smul_def, Algebra.smul_def,
            mul_comm <| algebraMap R K d,
            inv_mul_cancel_right₀ <|
              (map_ne_zero_iff _ <| NoZeroSmulDivisors.algebra_map_injective R K).mpr fun h =>
                (h ▸ hd) max.zero_mem]
rw [map_one, inv_one, mul_one]
rw [map_one, inv_one, mul_one]
have eq₁ : _ = (π₁ i, j, k).base := preserves_pullback.iso_hom_fst (forget C) _ _
have eq₂ : _ = (π₂ i, j, k).base := preserves_pullback.iso_hom_snd (forget C) _ _
rw [coe_to_fun_eq, coe_to_fun_eq, ← eq₁, ← eq₂, coe_comp, Set.image_comp, coe_comp,
    Set.preimage_comp, Set.image_preimage_eq, TopCat.pullback_snd_image_fst_preimage]
rfl
rw [← TopCat.epi_iff_surjective]
infer_instance
delta is_open_immersion.open_functor
dsimp only [functor.op, IsOpenMap.functor, opens.map, unop_op]
congr
apply pullback_base
constructor
delta ι_inv_app
rw [limit.lift_π]
change D.opens_image_preimage_map i i U = _
dsimp [opens_image_preimage_map]
rw [congr_app (D.t_id _), id_c_app, ← functor.map_comp]
erw [is_open_immersion.inv_naturality_assoc, is_open_immersion.app_inv_app'_assoc]
simp only [eq_to_hom_op, eq_to_hom_trans, eq_to_hom_map (functor.op _), ← functor.map_comp]
rw [set.range_iff_surjective.mpr _]
· simp
· rw [← TopCat.epi_iff_surjective]
    infer_instance
erw [← colimit_presheaf_obj_iso_componentwise_limit_hom_π]
infer_instance
rw [← D.ι_iso_PresheafedSpace_inv]
infer_instance
delta is_open_immersion
rw [← D.ι_iso_SheafedSpace_inv]
apply PresheafedSpace.is_open_immersion.comp
simp
rfl
cases U
dsimp
simp [PresheafedSpace.congr_app (F.map_id j)]
rfl
rw [F.map_comp]
rfl
cases U
dsimp
simp only [PresheafedSpace.congr_app (F.map_comp f g)]
dsimp
simp
dsimp
simp
rw [← colimit.w F f.unop, comp_base]
rfl
refine'
    limit.lift _
        { x := s.X.presheaf.obj U
          π :=
            { app := fun j => _
              naturality' := fun j j' f => _ } }
apply CategoryTheory.Limits.colimit.hom_ext
intro j
apply ContinuousMap.ext
intro x
dsimp
simp only [colimit.ι_desc_apply, map_cocone_ι_app]
rw [← w j]
simp
rw [← iso.eq_inv_comp, colimit_presheaf_obj_iso_componentwise_limit_inv_ι_app]
rw [← SetLike.mem_coe, coe_vanishing_ideal, Set.mem_setOf_eq]
simp [vanishing_ideal]
simp only [zero_locus_Union]
rw [zero_locus_inf]
simp
rw [Set.mem_compl_iff, mem_zero_locus, Set.singleton_subset_iff] <;> rfl
simp
intro Zs h
rw [Set.sInter_eq_Inter]
let f : Zs → Set _ := fun i => Classical.choose (h i.2)
have hf : ∀ i : Zs, ↑i = zero_locus 𝒜 (f i) := fun i => (Classical.choose_spec (h i.2)).symm
simp only [hf]
exact ⟨_, zero_locus_Union 𝒜 _⟩
rw [← is_open_compl_iff, is_open_iff, compl_compl]
rw [is_closed_iff_zero_locus]
exact ⟨s, rfl⟩
simp
simp
simp [zero_locus_singleton_mul]
rw [basic_open_mul 𝒜 f g]
exact inf_le_left
rw [basic_open_mul 𝒜 f g]
exact inf_le_right
rw [← as_ideal_le_as_ideal, ← zero_locus_vanishing_ideal_eq_closure, mem_zero_locus,
    vanishing_ideal_singleton]
simp only [coe_subset_coe, Subtype.coe_le_coe, coe_coe]
cases x
exact stalk_to_fiber_ring_hom_germ' 𝒜 U _ _ _
rw [ProjectiveSpectrum.mem_basic_open]
exact f.denom_mem
rw [← ProjectiveSpectrum.mem_basic_open] <;>
                  exact le_of_hom (opens.inf_le_right _ _) hy
rw [homogeneous_localization_to_stalk]
erw [stalk_to_fiber_ring_hom_germ 𝒜 (ProjectiveSpectrum.basicOpen 𝒜 f.denom) ⟨x, _⟩
              (section_in_basic_open _ x f)]
simp only [section_in_basic_open, Subtype.ext_iff_val,
            HomogeneousLocalization.ext_iff_val, HomogeneousLocalization.val_mk',
            f.eq_num_div_denom]
rfl
rw [pow_add]
rw [Localization.mk_mul, mul_one, one_mul]
rw [Localization.mk_mul, mul_one, one_mul]
rw [mk_mul, one_mul, mul_one]
congr
rw [hk]
delta t
simp only [category.assoc, id.def, pullback_symmetry_hom_comp_fst_assoc,
    pullback_assoc_hom_snd_fst, pullback.lift_fst_assoc, pullback_symmetry_hom_comp_snd,
    pullback_assoc_inv_fst_fst, pullback_symmetry_hom_comp_fst]
delta t
simp only [pullback_symmetry_hom_comp_snd_assoc, category.comp_id, category.assoc, id.def,
    pullback_symmetry_hom_comp_fst_assoc, pullback_assoc_hom_snd_snd, pullback.lift_snd,
    pullback_assoc_inv_snd]
delta t
simp only [pullback_symmetry_hom_comp_snd_assoc, category.assoc, id.def,
    pullback_symmetry_hom_comp_snd, pullback_assoc_hom_fst, pullback.lift_fst_assoc,
    pullback_symmetry_hom_comp_fst, pullback_assoc_inv_fst_snd]
apply pullback.hom_ext <;> rw [category.id_comp]
apply pullback.hom_ext
· rw [← cancel_mono (𝒰.map i)]
    simp only [pullback.condition, category.assoc, t_fst_fst]
· simp only [category.assoc, t_fst_snd]
· rw [← cancel_mono (𝒰.map i)]
    simp only [pullback.condition, t_snd, category.assoc]
refine' (pullback_right_pullback_fst_iso _ _ _).Hom
delta t'
simp only [category.assoc, pullback_symmetry_hom_comp_fst_assoc,
    pullback_right_pullback_fst_iso_inv_snd_fst_assoc, pullback.lift_fst_assoc, t_fst_fst,
    pullback_right_pullback_fst_iso_hom_fst_assoc]
delta t'
simp only [category.assoc, pullback_symmetry_hom_comp_fst_assoc,
    pullback_right_pullback_fst_iso_inv_snd_fst_assoc, pullback.lift_fst_assoc, t_fst_snd,
    pullback_right_pullback_fst_iso_hom_fst_assoc]
delta t'
simp only [category.comp_id, category.assoc, pullback_symmetry_hom_comp_fst_assoc,
    pullback_right_pullback_fst_iso_inv_snd_snd, pullback.lift_snd,
    pullback_right_pullback_fst_iso_hom_snd]
delta t'
simp only [category.assoc, pullback_symmetry_hom_comp_snd_assoc,
    pullback_right_pullback_fst_iso_inv_fst_assoc, pullback.lift_fst_assoc, t_fst_fst,
    pullback_right_pullback_fst_iso_hom_fst_assoc]
delta t'
simp only [category.assoc, pullback_symmetry_hom_comp_snd_assoc,
    pullback_right_pullback_fst_iso_inv_fst_assoc, pullback.lift_fst_assoc, t_fst_snd,
    pullback_right_pullback_fst_iso_hom_fst_assoc]
delta t'
simp only [category.assoc, pullback_symmetry_hom_comp_snd_assoc,
    pullback_right_pullback_fst_iso_inv_fst_assoc, pullback.lift_fst_assoc, t_snd,
    pullback_right_pullback_fst_iso_hom_fst_assoc]
simp only [t'_fst_fst_fst, t'_fst_snd, t'_snd_snd]
simp only [t'_fst_fst_snd]
simp only [t'_fst_snd, t'_snd_snd, t'_fst_fst_fst]
rw [← cancel_mono (𝒰.map i)]
simp only [pullback.condition_assoc, t'_snd_fst_fst, t'_fst_snd, t'_snd_snd]
simp only [pullback.condition_assoc, t'_snd_fst_snd]
simp only [t'_snd_snd, t'_fst_fst_fst, t'_fst_snd]
apply pullback.hom_ext
apply pullback.hom_ext
all_goals
      simp only [t'_snd_fst_fst, t'_snd_fst_snd, t'_snd_snd, t_fst_fst, t_fst_snd, t_snd,
        category.assoc]
apply multicoequalizer.hom_ext
intro i
erw [multicoequalizer.π_desc_assoc, multicoequalizer.π_desc_assoc]
rw [category.assoc, pullback.condition]
change pullback pullback.fst pullback.fst
delta glued_lift_pullback_map
simp only [category.assoc, id.def, pullback.lift_fst,
    pullback_right_pullback_fst_iso_hom_fst_assoc]
delta glued_lift_pullback_map
simp only [category.assoc, category.comp_id, id.def, pullback.lift_snd,
    pullback_right_pullback_fst_iso_hom_snd]
delta pullback_fst_ι_to_V
simp only [iso.trans_hom, pullback.congr_hom_hom, category.assoc, pullback.lift_fst,
    category.comp_id, pullback_right_pullback_fst_iso_hom_fst, pullback_symmetry_hom_comp_fst]
delta pullback_fst_ι_to_V
simp only [iso.trans_hom, pullback.congr_hom_hom, category.assoc, pullback.lift_snd,
    category.comp_id, pullback_right_pullback_fst_iso_hom_snd, pullback_symmetry_hom_comp_snd_assoc]
rw [← pullback.condition_assoc, category.assoc, p_comm]
rw [← pullback.condition_assoc, category.assoc, p_comm]
erw [multicoequalizer.π_desc]
delta pullback_p1_iso
simp only [pullback.lift_fst]
delta pullback_p1_iso
simp only [pullback.lift_snd]
delta pullback_p1_iso
simp only [pullback.lift_fst]
delta pullback_p1_iso
simp only [pullback.lift_snd]
rw [← pullback_p1_iso_inv_fst, iso.hom_inv_id_assoc]
apply pullback_cone.is_limit_aux'
intro s
refine' ⟨glued_lift 𝒰 f g s, glued_lift_p1 𝒰 f g s, glued_lift_p2 𝒰 f g s, _⟩
intro m h₁ h₂
change m
rw [← Spec.image_preimage f, ← Spec.image_preimage g]
exact
    ⟨⟨⟨_, is_limit_of_has_pullback_of_preserves_limit Spec (Spec.preimage f) (Spec.preimage g)⟩⟩⟩
simp
simp
rw [pullback_map_eq_pullback_fst_fst_iso_inv]
infer_instance
rw [unop_id, Spec.Top_map_id]
rw [unop_comp, Spec.Top_map_comp]
dsimp
rw [CategoryTheory.Functor.map_id]
rw [category.comp_id]
erw [comap_comp f g]
rfl
rw [unop_id, Spec.SheafedSpace_map_id]
rw [unop_comp, Spec.SheafedSpace_map_comp]
rw [w]
infer_instance
rw [stalk_iso_hom, stalk_iso_inv, comp_apply, comp_apply, localization_to_stalk_of,
          stalk_map_to_stalk_apply, stalk_to_fiber_ring_hom_to_stalk]
rw [Spec.LocallyRingedSpace_map_val, Spec.SheafedSpace_map_id]
rfl
rw [Spec.LocallyRingedSpace_map_val, Spec.SheafedSpace_map_comp]
rfl
rw [unop_id, Spec.LocallyRingedSpace_map_id]
rw [unop_comp, Spec.LocallyRingedSpace_map_comp]
cases R
apply structure_sheaf.is_iso_to_global
infer_instance
rw [structure_sheaf.to_stalk]
erw [category.assoc]
rw [TopCat.Presheaf.stalk_functor_map_germ]
exact Spec_Γ_naturality_assoc f _
refine' Eq.trans _ e
rfl
intro x hxU
rw [opens.mem_coe, opens.mem_supr]
exact ⟨⟨x, hxU⟩, m ⟨x, hxU⟩⟩
  -- Let `g x` denote the inverse of `f` in `U x`.
trivial
apply le_antisymm
· rw [X.basic_open_res i f]
    exact inf_le_right
· have := X.basic_open_res (inv i) (X.presheaf.map i f)
    rw [← comp_apply, ← X.presheaf.map_comp, is_iso.hom_inv_id, X.presheaf.map_id] at this
    erw [this]
    exact inf_le_right
apply le_antisymm
· exact X.basic_open_le f
intro x hx
erw [X.mem_basic_open f (⟨x, hx⟩ : U)]
exact RingHom.is_unit_map _ hf
rw [hammingDist, card_eq_zero, filter_eq_empty_iff]
exact fun _ _ H => H rfl
rw [hamming_dist_comm z]
exact hamming_dist_triangle _ _ _
rw [hamming_dist_comm y]
exact hamming_dist_triangle _ _ _
funext x y
exact hamming_dist_comm _ _
rw [H]
exact hamming_dist_self _
rw [eq_comm, hamming_dist_eq_zero]
rw [← hamming_dist_ne_zero, iff_not_comm, not_lt, le_zero_iff]
rw [Nat.lt_one_iff, hamming_dist_eq_zero]
refine' le_antisymm (hamming_dist_comp_le_hamming_dist _) _
exact card_mono ((monotone_filter_right _) fun i H1 H2 => H1 <| hf i H2)
rw [hamming_dist_comm, hamming_dist_zero_right]
rw [δ_comp_δ]
· rfl
· exact H
subst H
rw [δ_comp_δ_self]
subst H
rw [δ_comp_σ_self]
subst H
rw [δ_comp_σ_succ]
simp
rw [← functor.mono_map_iff_mono skeletal_equivalence.Functor]
dsimp only [skeletal_equivalence, functor.as_equivalence_functor]
rw [NonemptyFinLinOrdCat.mono_iff_injective, skeletal_functor.coe_map,
    Function.Injective.of_comp_iff ULift.up_injective,
    Function.Injective.of_comp_iff' _ ULift.down_bijective]
rw [← functor.epi_map_iff_epi skeletal_equivalence.Functor]
dsimp only [skeletal_equivalence, functor.as_equivalence_functor]
rw [NonemptyFinLinOrdCat.epi_iff_surjective, skeletal_functor.coe_map,
    Function.Surjective.of_comp_iff' ULift.up_bijective,
    Function.Surjective.of_comp_iff _ ULift.down_surjective]
rw [mono_iff_injective]
exact Fin.succ_above_right_injective
rw [epi_iff_surjective]
intro b
simp only [σ, mk_hom, hom.to_order_hom_mk, OrderHom.coe_fun_mk]
rw [Fin.succ_pred]
rw [← h]
infer_instance
rw [← h]
infer_instance
rw [← cancel_mono i, fac, ← image_ι_eq fac, image.fac]
simp
simp
dsimp
simp
dsimp
erw [category.assoc, arrow.w, augmented.to_arrow_obj_hom, nat_trans.naturality_assoc,
            functor.const_obj_map, category.id_comp]
rw [wide_pushout.arrow_ι fun i => f.hom]
rw [← arrow.w_assoc F, wide_pushout.arrow_ι fun i => g.hom]
dsimp
simp
unfold wide_cospan <;> dsimp <;> infer_instance
cases f
· cases i
              all_goals dsimp; simp
· dsimp
              simp only [terminal.comp_from]
              exact Subsingleton.elim _ _
cases nonempty_fintype ι
exact ⟨⟨wide_cospan.limit_cone ι X⟩⟩
intro j
simp only [category.assoc]
dsimp only [cech_nerve_terminal_from, wide_pullback.π, pi.lift]
erw [wide_pullback.lift_π,
            limit.cone_point_unique_up_to_iso_inv_comp (wide_cospan.limit_cone _ _).2,
            (limit.is_limit _).cone_point_unique_up_to_iso_inv_comp (wide_cospan.limit_cone _ _).2,
            limit.lift_π]
rfl
rw [h₁]
infer_instance
rw [eq_id_iff_len_eq]
constructor
· intro h
    rw [h]
· exact le_antisymm (len_le_of_epi (inferInstance : epi A.e))
constructor
· intro h
    dsimp at h
    subst h
    dsimp only [id, e]
    infer_instance
· intro h
    rw [eq_id_iff_len_le]
    exact len_le_of_mono h
dsimp only [ι_summand, iso.hom]
erw [colimit.ι_desc, cofan.mk_ι_app]
erw [ι_summand_eq, X.map_id, comp_id]
rfl
simp only [ι_summand_eq_assoc, φ, nat_trans.naturality, assoc]
dsimp only [ι_summand, desc]
simp only [assoc, iso.hom_inv_id_assoc, ι_coprod]
erw [colimit.ι_desc, cofan.mk_ι_app]
dsimp [ι_summand]
erw [colimit.ι_desc, colimit.ι_desc, cofan.mk_ι_app, cofan.mk_ι_app]
dsimp only [index_set.epi_comp, index_set.e]
rw [op_comp, X.map_comp, assoc, Quiver.Hom.op_unop]
rw [h]
rw [h]
rw [S₁.s.ι_summand_eq, S₂.s.ι_summand_eq, assoc, Φ.F.naturality, ← Φ.comm_assoc]
intro h
apply α.property
exact Function.Surjective.of_comp h
intro h
apply α.property
rw [Set.eq_univ_iff_forall] at h⊢
intro j
apply Or.imp _ id (h j)
intro hj
exact Set.range_comp_subset_range _ _ hj
simp
cases n <;>
    dsimp
simp
simp
simp
apply ChainComplex.of_d
dsimp
erw [comp_id, ← F.map_comp, ed.s'_comp_ε, F.map_id]
dsimp
erw [comp_id, ← F.map_comp, ← F.map_comp, ed.s₀_comp_δ₁]
dsimp
erw [← F.map_comp, ed.s_comp_δ₀, F.map_id]
dsimp
erw [← F.map_comp, ← F.map_comp, ed.s_comp_δ]
rfl
dsimp
erw [← F.map_comp, ← F.map_comp, ed.s_comp_σ]
rfl
have h := w₀ e.inv
dsimp at h⊢
simp only [assoc, ← simplicial_object.δ_naturality, ed.s₀_comp_δ₁_assoc, reassoc_of h]
have h := ed.s_comp_δ' n i
dsimp at h⊢
simp only [assoc, ← simplicial_object.δ_naturality, reassoc_of h, ←
      simplicial_object.δ_naturality_assoc]
have h := ed.s_comp_σ' n i
dsimp at h⊢
simp only [assoc, ← simplicial_object.σ_naturality, reassoc_of h, ←
      simplicial_object.σ_naturality_assoc]
intro h₂
subst h₂
exact h₁ (le_antisymm hi (Fin.zero_le _))
apply wide_pullback.lift_base
rw [id_comp]
simp only [augmented_cech_nerve_hom_app, assoc, wide_pullback.lift_base, split_epi.id]
congr
dsimp [simplicial_object]
infer_instance
dsimp [simplicial_object]
infer_instance
rw [h]
dsimp [δ]
simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_δ H]
dsimp [δ]
simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_δ' H]
dsimp [δ]
simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_δ'' H]
dsimp [δ]
simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_δ_self]
subst H
rw [δ_comp_δ_self]
dsimp [δ, σ]
simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_σ_of_le H]
dsimp [δ, σ]
simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_σ_self, op_id, X.map_id]
subst H
rw [δ_comp_σ_self]
dsimp [δ, σ]
simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_σ_succ, op_id, X.map_id]
subst H
rw [δ_comp_σ_succ]
dsimp [δ, σ]
simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_σ_of_gt H]
dsimp [δ, σ]
simp only [← X.map_comp, ← op_comp, SimplexCategory.σ_comp_σ H]
dsimp [truncated]
infer_instance
dsimp [truncated]
infer_instance
dsimp
rw [← nat_trans.comp_app]
erw [η.w]
rfl
dsimp
rw [SimplexCategory.hom_zero_zero ([0].const 0), op_id, X.map_id, category.id_comp]
dsimp [cosimplicial_object]
infer_instance
dsimp [cosimplicial_object]
infer_instance
rw [h]
dsimp [δ]
simp only [← X.map_comp, SimplexCategory.δ_comp_δ H]
dsimp [δ]
simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_δ' H]
dsimp [δ]
simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_δ'' H]
dsimp [δ]
simp only [← X.map_comp, SimplexCategory.δ_comp_δ_self]
subst H
rw [δ_comp_δ_self]
dsimp [δ, σ]
simp only [← X.map_comp, SimplexCategory.δ_comp_σ_of_le H]
dsimp [δ, σ]
simp only [← X.map_comp, SimplexCategory.δ_comp_σ_self, X.map_id]
subst H
rw [δ_comp_σ_self]
dsimp [δ, σ]
simp only [← X.map_comp, SimplexCategory.δ_comp_σ_succ, X.map_id]
subst H
rw [δ_comp_σ_succ]
dsimp [δ, σ]
simp only [← X.map_comp, SimplexCategory.δ_comp_σ_of_gt H]
dsimp [δ, σ]
simp only [← X.map_comp, SimplexCategory.σ_comp_σ H]
dsimp [truncated]
infer_instance
dsimp [truncated]
infer_instance
dsimp
rw [← nat_trans.comp_app]
erw [← η.w]
rfl
dsimp
rw [SimplexCategory.hom_zero_zero ([0].const 0), X.map_id, category.comp_id]
simp
simp
simp
simp
rw [Finset.sum_add_sum_compl]
apply ChainComplex.of_d
apply ChainComplex.of_d
simp only [alternating_face_map_complex.obj_d]
rw [comp_sum]
let t := fun j : Fin (n + 2) =>
      (normalized_Moore_complex.obj_X X (n + 1)).arrow
intro j
rfl
simp only [Finset.mem_univ]
simp only [d_eq_unop_d, ← unop_comp, alternating_face_map_complex.d_squared, unop_zero]
simp only [map_eq, ← Path.Homotopic.map_lift]
apply Path.Homotopic.hpath_hext
exact hfg
rw [functor.conj_eq_to_hom_iff_heq]
exact heq_path_of_eq_image hfg
apply Quotient.induction_on p
intro p'
apply @eq_path_of_eq_image _ _ _ _ H.ulift_map _ _ _ _ _ ((Path.refl (ULift.up _)).Prod p')
simp
apply Quotient.induction_on p
intro p'
apply @eq_path_of_eq_image _ _ _ _ H.ulift_map _ _ _ _ _ ((Path.refl (ULift.up _)).Prod p')
simp
dsimp only [prod_to_prod_Top_I, uhpath01, hcast]
refine' (@functor.conj_eq_to_hom_iff_heq (πₓ Y) _ _ _ _ _ _ _ _ _).mpr _
simp only [id_eq_path_refl, prod_to_prod_Top_map, Path.Homotopic.prod_lift, map_eq, ←
    Path.Homotopic.map_lift]
apply Path.Homotopic.hpath_hext
intro
rfl
rw [(H.eq_diag_path p).1, (H.eq_diag_path p).2]
apply nat_iso.is_iso_of_is_iso_app
change pi_to_pi_Top X
change CategoryTheory.Functor.pi' (proj X)
apply limits.preserves_limit_of_preserves_limit_cone (TopCat.piFanIsLimit.{u} X)
apply (limits.is_limit.of_cone_equiv (cone_discrete_comp X)).toFun
simp only [cone_discrete_comp_obj_map_cone]
apply limits.is_limit.of_iso_limit _ (as_iso (pi_Top_to_pi_cone X)).symm
exact Groupoid.pi_limit_fan_is_limit _
change prod_to_prod_Top A B
change (proj_left A B).prod' (proj_right A B)
decide
decide
simp
simp
simp [comp_eq, ← Path.Homotopic.map_lift, ← Path.Homotopic.comp_lift]
rw [simply_connected_def, equiv_punit_iff_unique]
rfl
intro
constructor <;> infer_instance
simp only [Finset.mem_univ]
cases n
· apply top_factors
· rw [P_infty_f, normalized_Moore_complex.obj_X, finset_inf_factors]
    intro i hi
    apply kernel_subobject_factors
    exact (higher_faces_vanish.of_P (n + 1) n) i le_add_self
rw [← cancel_mono (normalized_Moore_complex.obj_X X n).arrow, assoc, assoc, factor_thru_arrow, ←
      inclusion_of_Moore_complex_map_f, ← normalized_Moore_complex_obj_d, ←
      (inclusion_of_Moore_complex_map X).comm' (n + 1) n rfl, inclusion_of_Moore_complex_map_f,
      factor_thru_arrow_assoc, ← alternating_face_map_complex_obj_d]
exact P_infty.comm' (n + 1) n rfl
simp only [← cancel_mono (inclusion_of_Moore_complex_map X), assoc, id_comp,
      P_infty_to_normalized_Moore_complex_comp_inclusion_of_Moore_complex_map,
      inclusion_of_Moore_complex_map_comp_P_infty]
rw [assoc, v j hj, comp_zero]
intro d
rw [add_assoc, add_comm d, ← add_assoc, hnaq]
simp only [this, Fin.nat_add_mk, Fin.cast_mk, zero_comp, smul_zero]
intro a b c d e f h1 h2 h3
rw [add_assoc c d e, h2, add_zero, add_comm a b, add_assoc, add_comm a c, h3, add_zero, h1]
simp only [Hσ, Homotopy.null_homotopic_map'_f (c_mk (n + 2) (n + 1) rfl) (c_mk (n + 1) n rfl)]
rw [hσ'_eq_zero hqn (c_mk (n + 1) n rfl), comp_zero, zero_add]
intro j hj₁
dsimp
simp only [comp_add, add_comp, comp_id]
  -- when n < q, the result follows immediately from the assumption
rw [← add_left_inj a, ha, ham'', add_comm]
induction. The idea is to
induction that the `q
intro hj
dsimp at hj
apply Nat.not_succ_le_zero j
rw [Nat.succ_eq_add_one, hj]
congr
congr
rw [hσ'_eq ha rfl, eq_to_hom_refl, comp_id]
rfl
unfold Hσ
have eq := HomologicalComplex.congr_hom (map_null_homotopic_map' G (hσ' q)) n
simp only [functor.map_homological_complex_map_f, ← map_hσ'] at eq
rw [Eq]
let h := (functor.congr_obj (map_alternating_face_map_complex G) X).symm
congr
simp only [HomologicalComplex.sub_f_apply, HomologicalComplex.id_f, Q, P_f_0_eq, sub_self]
unfold P
exact (of_P q n).induction
simp only [hnaq, Fin.coe_mk, Nat.succ_eq_add_one, add_assoc]
constructor
· intro hφ
    rw [← hφ]
    apply higher_faces_vanish.of_comp
    apply higher_faces_vanish.of_P
· exact higher_faces_vanish.comp_P_eq_self
cases n
· rw [P_f_0_eq q, comp_id]
· exact (higher_faces_vanish.of_P q n).comp_P_eq_self
simp only [Q, HomologicalComplex.sub_f_apply, HomologicalComplex.id_f, comp_sub, P_f_naturality,
    sub_comp, sub_left_inj]
dsimp
simp only [comp_id, id_comp]
refine' (s.iso Δ).inv
subst h
rfl
dsimp [ι_summand, π_summand]
simp only [summand, assoc, is_iso.hom_inv_id_assoc]
erw [colimit.ι_desc, cofan.mk_ι_app]
dsimp
simp only [eq_self_iff_true, if_true]
dsimp [ι_summand, π_summand]
simp only [summand, assoc, is_iso.hom_inv_id_assoc]
erw [colimit.ι_desc, cofan.mk_ι_app]
apply dif_neg
exact h.symm
apply s.hom_ext'
intro A
rw [comp_id, comp_sum, Finset.sum_eq_single A, ι_π_summand_eq_id_assoc]
· intro B h₁ h₂
    rw [s.ι_π_summand_eq_zero_assoc _ _ h₂, zero_comp]
· simp only [Finset.mem_univ, not_true, IsEmpty.forall_iff]
rw [SimplicialObject.Splitting.IndexSet.eq_id_iff_mono] at hA
rw [SimplicialObject.Splitting.ι_summand_eq, assoc, degeneracy_comp_P_infty X n A.e hA, comp_zero]
constructor
· intro h
    cases n
    · dsimp at h
      rw [comp_id] at h
      rw [h, zero_comp]
    · have h' := f
rw [A.eq_id_iff_mono] at hA
rw [← assoc, ← s.comp_P_infty_eq_zero_iff, assoc, ← P_infty.comm j k, s.ι_summand_eq, assoc,
    degeneracy_comp_P_infty_assoc X j A.e hA, zero_comp, comp_zero]
simp only [d, K[X].shape i j hij, zero_comp, comp_zero]
erw [id_comp, HomologicalComplex.d_comp_d_assoc, zero_comp]
dsimp
rw [assoc, assoc, assoc, π_summand_comp_ι_summand_comp_P_infty_eq_P_infty,
              HomologicalComplex.Hom.comm]
dsimp
erw [← ι_summand_naturality_symm_assoc Φ (splitting.index_set.id (op [i])),
          ((alternating_face_map_complex C).map Φ.F).comm_assoc i j]
simp only [assoc]
congr 2
apply S₁.s.hom_ext'
intro A
dsimp [alternating_face_map_complex]
erw [ι_summand_naturality_symm_assoc Φ A]
rw [Fin.cast_succ_zero]
rw [P_infty_f, σ_comp_P_eq_zero X i]
simp only [le_add_iff_nonneg_left, zero_le]
rfl
unfold φ post_comp
simp only [add_comp, sum_comp, assoc]
unfold φ pre_comp
simp only [P_infty_f, comp_add]
congr 1
· simp only [P_f_naturality_assoc]
· simp only [comp_sum, P_f_naturality_assoc, simplicial_object.δ_naturality_assoc]
rw [← h] at h₁
exact h₁ rfl
rw [is_δ₀.iff]
exact hb'
apply (Γ₀.splitting K[X]).hom_ext'
intro A
change _
apply (Γ₀.splitting K[X]).hom_ext
intro n
dsimp [N₁]
simp only [← splitting.ι_summand_id, splitting.ι_desc, comp_id, splitting.ι_desc_assoc,
          assoc, P_infty_f_idem_assoc]
simp only [N₂Γ₂_inv_app_f_f, N₂_obj_p_f, assoc]
dsimp [N₂]
simp only [Γ₂N₂.nat_trans_app_f_app, P_infty_on_Γ₀_splitting_summand_eq_self_assoc,
      functor.comp_map, compatibility_Γ₂N₁_Γ₂N₂_hom, nat_trans.comp_app, eq_to_hom_app, assoc,
      karoubi.comp_f, karoubi.eq_to_hom_f, eq_to_hom_refl, comp_id, karoubi.decomp_id_p_f,
      karoubi.comp_p_assoc, Γ₂_map_f_app, N₂_map_f_f, karoubi.decomp_id_i_f,
      Γ₂N₁.nat_trans_app_f_app]
erw [splitting.ι_desc_assoc, assoc, assoc, splitting.ι_desc_assoc]
dsimp [splitting.index_set.id, splitting.index_set.e]
simp only [assoc, nat_trans.naturality, P_infty_f_naturality_assoc, app_idem_assoc,
      P_infty_f_idem_assoc]
erw [P.X.map_id, comp_id]
have h := identity_N₂_objectwise P
erw [hom_comp_eq_id] at h
rw [h]
infer_instance
intro X
rw [compatibility_Γ₂N₁_Γ₂N₂_nat_trans]
infer_instance
cases n
· simp only [P_f_0_eq]
· unfold P
    simp only [add_right_eq_self, comp_add, HomologicalComplex.comp_f,
      HomologicalComplex.add_f_apply, comp_id]
    exact (higher_faces_vanish.of_P q n).comp_Hσ_eq_zero (nat.succ_le_iff.mp hqn)
simp only [Q, HomologicalComplex.sub_f_apply, P_is_eventually_constant hqn]
rfl
dsimp [Q_infty]
simp only [sub_self]
simp only [P_infty_f, P_f_idem]
dsimp only [Q_infty]
simp only [HomologicalComplex.sub_f_apply, HomologicalComplex.id_f, comp_sub, comp_id,
    P_infty_f_idem, sub_self]
dsimp only [Q_infty]
simp only [HomologicalComplex.sub_f_apply, HomologicalComplex.id_f, sub_comp, id_comp,
    P_infty_f_idem, sub_self]
dsimp only [Q_infty]
simp only [add_sub_cancel'_right]
simp only [P_infty_f, map_P]
have h := functor.congr_obj (to_karoubi_comp_karoubi_functor_category_embedding _ _) Y₂
simp only [← nat_trans_P_infty_f_app]
congr
refine'
      Homotopy.trans (Homotopy.ofEq _)
        (Homotopy.trans
          (Homotopy.add (homotopy_P_to_id q) (Homotopy.compLeft (homotopy_Hσ_to_zero q) (P q)))
          (Homotopy.ofEq _))
· unfold P
      simp only [comp_add, comp_id]
· simp only [add_zero, comp_zero]
unfold homotopy_P_to_id
simp only [homotopy_Hσ_to_zero, hσ'_eq_zero hqn (c_mk (n + 1) n rfl), Homotopy.trans_hom,
    Pi.add_apply, Homotopy.of_eq_hom, Pi.zero_apply, Homotopy.add_hom, Homotopy.comp_left_hom,
    Homotopy.null_homotopy'_hom, ComplexShape.down_rel, eq_self_iff_true, dite_eq_ite, if_true,
    comp_zero, add_zero, zero_add]
congr
unfold map_mono
simp only [eq_self_iff_true, eq_to_hom_refl, dite_eq_ite, if_true]
rw [is_δ₀.iff]
simp only [map, colimit.ι_desc, cofan.mk_ι_app]
have h := SimplexCategory.image_eq fac
subst h
congr
· exact SimplexCategory.image_ι_eq fac
· dsimp only [SimplicialObject.Splitting.IndexSet.pull]
    congr
    exact SimplexCategory.factor_thru_image_eq fac
rw [unop_id, comp_id, id_comp]
rw [unop_comp, assoc]
rfl
rw [Γ₀.splitting_map_eq_id]
apply is_iso.id
dsimp only [SimplicialObject.Splitting.ιSummand, SimplicialObject.Splitting.ιCoprod]
simp only [assoc, Γ₀.splitting_iso_hom_eq_id, id_comp, comp_id]
exact Γ₀.obj.map_on_summand₀ K A fac
apply obj.map_on_summand
apply image.fac
apply (Γ₀.splitting K).hom_ext'
intro A
simp only [(splitting K).ι_desc_assoc, obj.map_on_summand'_assoc K _ θ, (splitting K).ι_desc,
      assoc, obj.map_on_summand' K' _ θ]
apply obj.termwise.map_mono_naturality_assoc
rw [N₁Γ₀_hom_app]
apply comp_id
rw [N₁Γ₀_inv_app]
apply id_comp
have h :=
    functor.congr_obj
      (functor_extension₂_comp_whiskering_left_to_karoubi (ChainComplex C ℕ) (simplicial_object C))
      Γ₀
have h' :=
    functor.congr_obj
      (functor_extension₁_comp_whiskering_left_to_karoubi (simplicial_object C) (ChainComplex C ℕ))
      N₁
dsimp [N₂, Γ₂, functor_extension₁] at h h'⊢
rw [← functor.assoc, h, functor.assoc, h']
dsimp only [N₂Γ₂, functor.preimage_iso, iso.trans]
simp only [whiskering_left_obj_preimage_app, N₂Γ₂_to_karoubi_iso_inv, functor.id_map,
    nat_trans.comp_app, eq_to_hom_app, functor.comp_map, assoc, karoubi.comp_f, karoubi.eq_to_hom_f,
    eq_to_hom_refl, comp_id, karoubi.comp_p_assoc, N₂_map_f_f, HomologicalComplex.comp_f,
    N₁Γ₀_inv_app_f_f, P_infty_on_Γ₀_splitting_summand_eq_self_assoc,
    splitting.to_karoubi_nondeg_complex_iso_N₁_hom_f_f, Γ₂_map_f_app, karoubi.decomp_id_p_f]
dsimp [to_karoubi]
rw [splitting.ι_desc]
dsimp [splitting.index_set.id]
rw [karoubi.homological_complex.p_idem_assoc]
intro
    -- The following functor `F` reflects isomorphism because it is
    -- a composition of four functors which reflects isomorphisms.
    -- Then, it suffices to show that `F.map f` is an isomorphism.
let F :=
      karoubi_functor_category_embedding SimplexCategory
dsimp only [F]
rw [← compatibility_N₂_N₁_karoubi, functor.comp_map]
apply functor.map_is_iso
simp
rw [to_pou_fun, h, zero_mul]
refine' congr_arg _ (finprod_cond_eq_prod_of_cond_iff _ fun j hj => _)
rw [Ne.def, sub_eq_self] at hj
rw [Finset.mem_filter, Iff.comm, and_iff_right_iff_imp]
exact flip (ht j) hj
rw [hs]
exact fun i hi => f.support_to_pou_fun_subset i hi
rw [hs, mul_support_one_sub]
exact fun i => id
refine'
    (f i).Continuous.mul <|
      continuous_finprod_cond (fun j _ => continuous_const.sub (f j).Continuous) _
simp only [mul_support_one_sub]
exact f.locally_finite
simp only [ContinuousMap.coe_mk, sum_to_pou_fun_eq, sub_eq_self]
apply finprod_eq_zero (fun i => 1 - f i x) (f.ind x hx)
· simp only [f.ind_apply x hx, sub_self]
· rw [mul_support_one_sub]
      exact f.point_finite x
simp only [ContinuousMap.coe_mk, sum_to_pou_fun_eq, sub_le_self_iff]
exact finprod_nonneg fun i => sub_nonneg.2 <| f.le_one i x
simp only [(· ∘ ·), Rat.cast_add] <;>
      exact
        real.uniform_continuous_add.comp
          (rat.uniform_continuous_coe_real.prod_map Rat.uniform_continuous_coe_real)
infer_instance
simp [(· ∘ ·)] <;>
      exact real.continuous_mul.comp (rat.continuous_coe_real.prod_map Rat.continuous_coe_real)
rw [nhds_discrete]
exact is_countably_generated_pure
simp only [eq_iff_true_of_subsingleton]
refine' ⟨fun h => ⟨_⟩, fun h => ⟨_⟩⟩
· rw [h.eq_bot]
    exact bot_topological_space_eq_generate_from_of_pred_succ_order
· rw [h.topology_eq_generate_intervals]
    exact bot_topological_space_eq_generate_from_of_pred_succ_order.symm
rw [inter_comm, Ici_inter_Iic, Icc_self a]
refine' ⟨fun h => ⟨_⟩, fun h => ⟨_⟩⟩
· rw [h.eq_bot]
    exact LinearOrder.bot_topological_space_eq_generate_from
· rw [h.topology_eq_generate_intervals]
    exact linear_order.bot_topological_space_eq_generate_from.symm
rw [DiscreteTopology.eq_bot α]
exact @UniformSpace.metrizableSpace α
infer_instance
rw [Real.closed_ball_eq_Icc]
apply is_compact_Icc
simp (config := { contextual := true }) [is_open_Ioo]
simp only [mem_Union]
exact ⟨q, p, Rat.cast_lt.1 <| hqa.trans hap, rfl⟩
simp only [← comap_dist_right_at_top_eq_cocompact (0 : ℝ), Real.dist_eq, sub_zero,
    comap_abs_at_top]
simp [mem_closure_iff_nhds_basis nhds_basis_ball, Real.dist_eq]
rw [Real.ball_eq_Ioo] <;> apply totally_bounded_Ioo
intro H
exact H' a ⟨H, ha.1⟩
infer_instance
intro
exact not_countably_generated_nhds_infty_alexandroff inferInstance
intro
exact not_first_countable_topology_alexandroff inferInstance
refine' ⟨fun s hsu hs x hx y hy => _⟩
clear hsu
rw [← preimage_ball, Real.ball_eq_Ioo, preimage_Ioo]
rw [← preimage_closed_ball, Real.closed_ball_eq_Icc, preimage_Icc]
intro x r
rw [closed_ball_eq_Icc]
exact (Set.finite_Icc _ _).IsCompact
simp only [← comap_dist_right_at_top_eq_cocompact (0 : ℤ), dist_eq, sub_zero, cast_zero, ←
    cast_abs, ← @comap_comap _ _ _ _ abs, Int.comap_coe_at_top, comap_abs_at_top]
rw [← cocompact_eq_cofinite, cocompact_eq]
simp [AddSubgroup.mem_zmultiples_iff]
rw [← coe_nat_zsmul, Int.toNat_of_nonneg hx.le]
simp
rw [zero_add]
rw [image_eq_range]
exact (equiv_Ico p).symm.range_eq_univ
rw [AddMonoidHom.map_zmultiples, AddMonoidHom.coe_coe, AddAut.mul_right_apply, Units.val_mul,
      Units.val_mk0, Units.val_inv_eq_inv_val, Units.val_mk0, mul_inv_cancel_left₀ hp]
simp only [algebraMap.coe_zero, QuotientAddGroup.coe_zero, inv_zero, zero_mul]
rw [← coe_nsmul, nsmul_eq_mul, ← mul_assoc, mul_div, mul_div_cancel_left _ hn₀, ← nsmul_eq_mul,
      QuotientAddGroup.eq_zero_iff]
exact nsmul_mem_zmultiples p m
induction m
· simp only [Int.ofNat_eq_coe, Int.cast_ofNat, Int.natAbs_ofNat] at h⊢
    exact add_order_of_div_of_gcd_eq_one hn h
· simp only [Int.cast_negSucc, neg_div, neg_mul, coe_neg, order_of_neg]
    exact add_order_of_div_of_gcd_eq_one hn h
simp
rw [← hxu] at h
exact add_order_of_pos' h
rw [← hxu, ← mul_div_right_comm, hm, mul_comm _ x, mul_div_cancel x hn₀]
rw [← is_compact_univ_iff, ← coe_image_Icc_eq p]
exact is_compact_Icc.image (AddCircle.continuous_mk' p)
infer_instance

-- short-circuit type class inference
simp [Ioi]
simp [Iio]
rw [Ennreal.Ico_eq_Iio]
exact is_open_Iio
rw [nhds_coe, Filter.map_map]
refine' (Homeomorph.setCongr <| Set.ext fun x => _).trans ne_top_homeomorph_nnreal <;>
    simp only [mem_set_of_eq, lt_top_iff_ne_top]
simp [lt_top_iff_ne_top, Ioi]
simp only [nhds_top', tendsto_infi, tendsto_principal, mem_Ioi]
simp [bot_lt_iff_ne_bot, Iio]
rw [_root_.mem_nhds_iff]
simp only [nhds_of_ne_top ha, tendsto_infi, tendsto_principal, mem_Icc]
rw [Ennreal.tendsto_nhds zero_ne_top]
simp only [true_and_iff, zero_tsub, zero_le, zero_add, Set.mem_Icc]
simp only [Ennreal.tendsto_nhds ha, mem_at_top_sets, mem_set_of_eq, Filter.Eventually]
simp only [one_lt_top, add_lt_top, coe_lt_top, and_self_iff]
simp only [one_lt_top, add_lt_top, coe_lt_top, and_self_iff]
simp [this, tendsto_const_nhds]
rfl
rfl
rfl
simp only [limsup_eq_infi_supr, inv_map_infi, inv_map_supr, liminf_eq_supr_infi]
simp only [limsup_eq_infi_supr, inv_map_infi, inv_map_supr, liminf_eq_supr_infi]
apply tendsto.mul hma _ (Ennreal.tendsto_inv_iff.2 hmb) _ <;> simp [ha, hb]
apply tendsto.const_mul (Ennreal.tendsto_inv_iff.2 hm)
simp [hb]
apply tendsto.mul_const hm
simp [ha]
simp only [add_comm a, bsupr_add' h]
rw [Sup_eq_supr, bsupr_add hs]
rw [add_comm, supr_add] <;> simp [add_comm]
refine' Finset.induction_on s _ _
· simp
· intro a s has ih
    simp only [Finset.sum_insert has]
    rw [ih, supr_add_supr_of_monotone (hf a)]
    intro i j h
    exact Finset.sum_le_sum fun a ha => hf a h
simp only [Sup_eq_supr, mul_supr]
simp (config := { contextual := true }) [le_of_lt]
simp
simp
apply tendsto.mono_left _ (Filter.prod_mono nhds_within_le_nhds nhds_within_le_nhds)
rw [← nhds_prod_eq]
exact tendsto_add
rw [hr.tsum_eq, Ennreal.tsum_coe_eq hr]
simp [h]
have key := not_imp_not.mpr Ennreal.tsum_eq_top_of_eq_top
simp only [not_exists] at key
exact lt_top_iff_ne_top.mpr (key tsum_ne_top j)
apply Ennreal.Tendsto.mul_const tendsto_nat_nhds_top
simp only [true_or_iff, top_ne_zero, Ne.def, not_false_iff]
simp [h]
simp [mul_comm, Ennreal.tsum_mul_left]
simp
refine' ⟨HasSum.tendsto_sum_nat, fun h => _⟩
rw [← supr_eq_of_tendsto _ h, ← Ennreal.tsum_eq_supr_nat]
· exact ennreal.summable.has_sum
· exact fun s t hst => Finset.sum_le_sum_of_subset (Finset.range_subset.2 hst)
rw [← has_sum_iff_tendsto_nat]
exact ennreal.summable.has_sum
rw [← Nat.cofinite_eq_at_top]
exact tendsto_cofinite_zero_of_tsum_ne_top hf
rw [Ennreal.tsum_add, Ennreal.add_sub_cancel_right h₁]
simp only [tsum_subtype]
apply Ennreal.tsum_le_tsum
exact indicator_le_indicator_of_subset h fun _ => zero_le _
apply tsum_congr_subtype
rw [union_diff_self]
simp
simp
rw [eq_empty_iff_forall_not_mem]
intro i hi
have oops := (le_trans hi (le_tsum' (@Ennreal.summable _ a) i)).trans tsum_le_c
rw [h] at oops
exact c_ne_top (le_antisymm le_top oops)
rw [Nnreal.summable_coe]
exact tsum_coe_ne_top_iff_summable
refine' has_sum_le (fun b => _) ennreal.summable.has_sum (Ennreal.has_sum_coe.2 hfr)
exact Ennreal.coe_le_coe.2 (hgf _)
rw [← Ennreal.has_sum_coe, Ennreal.has_sum_iff_tendsto_nat]
simp only [ennreal.coe_finset_sum.symm]
exact Ennreal.tendsto_coe
rw [← not_iff_not, not_not, not_summable_iff_tendsto_nat_at_top]
have A : ∀ a : α, (f a : ℝ) ≤ g a := fun a => Nnreal.coe_le_coe.2 (h a)
have : (sf : ℝ) < sg :=
    has_sum_lt A (Nnreal.coe_lt_coe.2 hi) (has_sum_coe.2 hf) (has_sum_coe.2 hg)
exact Nnreal.coe_lt_coe.1 this
rw [← tsum_zero]
exact tsum_lt_tsum (fun a => zero_le _) hi hg
simp only [Ennreal.toReal, tsum_to_nnreal_eq hf, Nnreal.coe_tsum]
apply Nnreal.summable_coe.1
refine' summable_of_nonneg_of_le (fun n => Nnreal.coe_nonneg _) (fun n => _) hf.abs
simp only [le_abs_self, Real.coe_to_nnreal', max_le_iff, abs_nonneg, and_self_iff]
rw [← not_iff_not, not_not, not_summable_iff_tendsto_nat_at_top_of_nonneg hf]
intro hs
rw [Emetric.cauchy_seq_iff] at hs
    /- `s` is Cauchy sequence. The sequence `b` will be constructed
simp only [and_imp, Set.mem_image, Set.mem_setOf_eq, exists_imp, Prod.exists]
intro d p q hp hq hd
rw [← hd]
exact le_of_lt (hN p (le_trans hn hp) q (le_trans hn hq))
rw [hεC]
rw [hεC]
rw [← mul_two, mul_comm]
simp only [Metric.diam, Emetric.diam_closure]
simp only [← lipschitz_on_univ, is_closed_set_of_lipschitz_on_with]
rw [Metric.diam, Real.ediam_eq h, Ennreal.to_real_of_real]
rw [Real.bounded_iff_bdd_below_bdd_above] at h
exact sub_nonneg.2 (Real.Inf_le_Sup s h.1 h.2)
simp [Metric.diam, Ennreal.to_real_of_real, sub_nonneg.2 h]
simp [Metric.diam, Ennreal.to_real_of_real, sub_nonneg.2 h]
simp [Metric.diam, Ennreal.to_real_of_real, sub_nonneg.2 h]
simp [Metric.diam, Ennreal.to_real_of_real, sub_nonneg.2 h]
refine' le_of_tendsto (tendsto_const_nhds.edist ha) (mem_at_top_sets.2 ⟨n, fun m hnm => _⟩)
refine' le_trans (edist_le_Ico_sum_of_edist_le hnm fun k _ _ => hf k) _
rw [Finset.sum_Ico_eq_sum_range]
exact sum_le_tsum _ (fun _ _ => zero_le _) Ennreal.summable
intro x r
rw [closed_ball_eq_Icc]
exact (Set.finite_Icc _ _).IsCompact
simp [Filter.atTopNeBot]
cases i <;> cases j <;> refine' Continuous.matrix_elem _ i j <;> assumption
simp
simp
infer_instance
simp (config := { contextual := true }) [or_imp, is_open_lt', is_open_gt']
simp
simp [Ioi]
simp [Iio]
simp only [imp_self, Ereal.coe_eq_coe_iff]
simp [not_or] at ha
exact ha.2
simp [not_or] at ha
exact ha.1
simp [Ioi]
simp [Iio]
simp only [imp_self, coe_ennreal_eq_coe_ennreal_iff]
simp [lt_top_iff_ne_top, Ioi]
simp
simp
simp [le_refl]
simp [le_refl]
simp only [nhds_top', mem_Ioi, tendsto_infi, tendsto_principal]
simp [bot_lt_iff_ne_bot]
simp
simp
simp [le_refl]
simp [le_refl]
simp only [nhds_bot', mem_Iio, tendsto_infi, tendsto_principal]
simp only [ContinuousAt, nhds_coe_coe, ← coe_add, tendsto_map'_iff, (· ∘ ·), tendsto_coe,
    tendsto_add]
simp [-Ereal.coe_sub]
simp [zero_lt_one]
simp [-coe_add, zero_lt_one]
simp [bot_lt_iff_ne_bot]
simp only [HasSum, coe_sum.symm, tendsto_coe]
constructor
exact fun ⟨a, ha⟩ => ⟨⟨a, has_sum_le (fun a => (f a).2) has_sum_zero ha⟩, has_sum_coe.1 ha⟩
exact fun ⟨a, ha⟩ => ⟨a.1, has_sum_coe.2 ha⟩
simp [tsum, hf, mt summable_coe.1 hf]
simp only [coe_tsum, Nnreal.coe_mul, tsum_mul_left]
simp only [coe_tsum, Nnreal.coe_mul, tsum_mul_right]
rw [← summable_coe, ← summable_coe]
exact @summable_nat_add_iff ℝ _ _ _ (fun i => (f i : ℝ)) k
simp [← has_sum_coe, coe_sum, Nnreal.coe_add, ← has_sum_nat_add_iff k]
rw [← Nnreal.coe_eq, coe_tsum, Nnreal.coe_add, coe_sum, coe_tsum,
    sum_add_tsum_nat_add k (Nnreal.summable_coe.2 hf)]
have h_f_coe : f = fun n => Real.toNnreal (f n : ℝ) := funext fun n => real.to_nnreal_coe.symm
rw [h_f_coe, ← @Real.to_nnreal_coe 0]
exact tendsto_real_to_nnreal (summable_coe.mpr hf).tendsto_cofinite_zero
rw [← Nat.cofinite_eq_at_top]
exact tendsto_cofinite_zero_of_summable hf
simp [Path.refl, CoeFun.coe, coeFn]
simp
simp
simp
simp
simp [hx]
simp [hy]
intro hf hg
apply continuous_uncurry_iff.mp
exact trans_continuous_family _ (continuous_uncurry_iff.mpr hf) _ (continuous_uncurry_iff.mpr hg)
simp
simp
simp
simp
rw [min_eq_left h]
rw [← γ.extend_range]
simp only [range_subset_iff, SetCoe.exists, SetCoe.forall]
intro x hx
simp only [CoeFun.coe, coeFn, Path.truncate, mem_range_self]
rw [min_self]
rw [min_self, γ.extend_zero]
rw [min_self, γ.extend_one]
simp [zero_le_one, extend_zero]
simp
simp [hf₀]
simp [hf₁]
constructor <;> apply γ_in
  simpa
simp
simp
simp
simp [JoinedIn, Joined, exists_true_iff_nonempty]
simp
simp
simp [pathComponentIn, pathComponent, JoinedIn, Joined, exists_true_iff_nonempty]
simp [x_in]
simp
intro i hi
simp [p', Nat.lt_succ_of_le hi, hp]
congr
assumption
simp [path_connected_space_iff_univ, is_path_connected_iff_eq]
rw [is_connected_iff_connected_space]
rw [is_path_connected_iff_path_connected_space] at hF
exact @PathConnectedSpace.connected_space _ _ hF
infer_instance
infer_instance
rfl
simp
simp [LowerSemicontinuousWithinAt, LowerSemicontinuousAt, nhds_within_univ]
simp [LowerSemicontinuousOn, LowerSemicontinuous, lower_semicontinuous_within_at_univ_iff]
intro x z hz
intro x z hz
rw [lower_semicontinuous_iff_is_open_preimage]
trace
    "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr ∀ y, (_ : exprProp())]]"
rw [← is_open_compl_iff, ← preimage_compl, compl_Iic]
intro y hy
simp [zlt, ha, le_refl]
simp only [← lower_semicontinuous_within_at_univ_iff] at hf⊢
exact hg.comp_lower_semicontinuous_within_at hf gmon
simp
simp
simp
simp
simp [UpperSemicontinuousWithinAt, UpperSemicontinuousAt, nhds_within_univ]
simp [UpperSemicontinuousOn, UpperSemicontinuous, upper_semicontinuous_within_at_univ_iff]
rw [upper_semicontinuous_iff_is_open_preimage]
trace
    "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr ∀ y, (_ : exprProp())]]"
rw [← is_open_compl_iff, ← preimage_compl, compl_Ici]
simp only [ContinuousOn, continuous_within_at_iff_lower_upper_semicontinuous_within_at]
exact
    ⟨fun H => ⟨fun x hx => (H x hx).1, fun x hx => (H x hx).2⟩, fun H x hx => ⟨H.1 x hx, H.2 x hx⟩⟩
simp [mem_map, Filter.Eventually, mem_prod_iff, preimage]
simp [tendsto_uniformly_on_iff_tendsto_uniformly_on_filter,
    tendsto_uniformly_on_filter_iff_tendsto]
apply forall₂_congr
intro u hu
simp
simp [tendsto_uniformly_iff_tendsto_uniformly_on_filter, tendsto_uniformly_on_filter_iff_tendsto]
simp [TendstoUniformlyOn, TendstoUniformly]
refine' fun u hu => ((hf u hu).And hff').mono fun n h => _
rw [← h.right]
exact h.left
rw [tendsto_uniformly_on_iff_tendsto_uniformly_on_filter] at hf⊢
refine' hf.congr _
rw [eventually_iff] at hff'⊢
simp only [Set.EqOn] at hff'
simp only [mem_prod_principal, hff', mem_set_of_eq]
simp only [hx, hy, Function.comp_apply]
rw [← tendsto_uniformly_on_univ, ← univ_prod_univ] at *
exact h.prod_map h'
rw [tendsto_uniformly_on_iff_tendsto_uniformly_on_filter]
exact tendsto_prod_filter_iff
rw [tendsto_uniformly_iff_tendsto_uniformly_on_filter]
exact tendsto_prod_filter_iff
simp
simp [mem_prod_principal, preimage]
simp
simp only [UniformCauchySeqOn, UniformCauchySeqOnFilter]
refine' forall₂_congr fun u hu => _
rw [eventually_prod_principal_iff]
simp
simp
simp
simp
rw [uniform_cauchy_seq_on_iff_uniform_cauchy_seq_on_filter] at hf⊢
exact hf.mono_right (le_principal_iff.mpr <| mem_principal.mpr hss')
simp only [hx, hy, Function.comp_apply]
simp [hy.1]
rw [bUnion_eq_Union]
exact tendsto_locally_uniformly_on_Union (fun i => hS _ i.2) fun i => h _ i.2
rw [sUnion_eq_bUnion]
exact tendsto_locally_uniformly_on_bUnion hS h
rw [← sUnion_pair]
refine' tendsto_locally_uniformly_on_sUnion _ _ _ <;> simp [*]
simp [TendstoLocallyUniformlyOn, TendstoLocallyUniformly, nhds_within_univ]
rw [← tendsto_locally_uniformly_on_univ] at h⊢
rw [continuous_iff_continuous_on_univ] at cg
exact h.comp _ (maps_to_univ _ _) cg
rw [← continuous_within_at_univ] at h
rw [← nhds_within_univ] at hunif hg
exact tendsto_comp_of_locally_uniform_limit_within h hg hunif
delta gen
simp [map_lift'_eq, monotone_set_of, Filter.monotone_mem, Function.comp,
        image_swap_eq_preimage_swap, -Subtype.val_eq_coe]
have h := fun p : CauchyCat α × CauchyCat α => @Filter.prod_comm _ _ p.2.val p.1.val
simp [Function.comp, h, -Subtype.val_eq_coe, mem_map']
exact le_rfl
rw [lift'_lift'_assoc]
exact monotone_gen
exact monotone_comp_rel monotone_id monotone_id
rw [lift'_lift'_assoc]
exact monotone_comp_rel monotone_id monotone_id
exact monotone_gen
simp [preimage, gen, pure_cauchy, prod_principal_principal]
simp [this]
dsimp [gen] <;> exact this
simp [nhds_eq_uniformity] <;> assumption
rw [extend, if_pos hf]
exact uniformly_extend_of_ind uniform_inducing_pure_cauchy dense_range_pure_cauchy hf _
congr
infer_instance
intro f x xf
rw [closure_eq_cluster_pts]
exact f.2.1.mono (le_inf f.2.le_nhds_Lim (le_principal_iff.2 xf))
rw [← (@uniform_embedding_pure_cauchy α _).comap_uniformity, Filter.mem_comap] at hs <;>
          exact hs
simp
infer_instance
infer_instance
infer_instance
intro a <;> simp only [hg, hf, hf.comp hg, (· ∘ ·), map_coe, extension_coe]
rw [hg x]
simp only [symm_comp_self, uniform_inducing_id]
simp [hf.to_uniform_inducing.uniform_continuous_iff, uniform_continuous_subtype_coe]
simp only [UniformContinuous, PiCat.uniformity, tendsto_infi, tendsto_comap_iff]
intro i
have key : Cauchy (map (fun a : ∀ i : ι, α i => a i) f) :=
        hf.map (PiCat.uniform_continuous_proj α i)
exact cauchy_iff_exists_le_nhds.1 key
rw [div_add_div_same, add_self_div_two]
rw [infi_subtype] at this
exact this
simp (config := { contextual := true }) [lt_min_iff, (· ≥ ·)]
simp [eq_comm, Filter.ext_iff, subset_def, h]
rw [← Prod.map_def, Prod.map_id, comap_id]
simp only [Cauchy, map_ne_bot_iff, prod_map_map_eq, map_le_iff_le_comap, ← hf.comap_uniformity]
refine' ⟨le_antisymm _ hf.le_comap⟩
rw [← hgf.1, ← Prod.map_def, ← Prod.map_def, ← Prod.map_comp_map f f g g, ←
    @comap_comap _ _ _ _ (Prod.map f f)]
exact comap_mono hg.le_comap
erw [uniformity_subtype, uniformity_subtype, comap_comap]
congr
simp only [uniform_embedding_def, uniform_continuous_def] <;>
    exact
      ⟨fun ⟨I, H⟩ => ⟨I, fun s su => (H _).2 ⟨s, su, fun x y => id⟩, fun s => (H s).1⟩,
        fun ⟨I, H₁, H₂⟩ =>
        ⟨I, fun s => ⟨H₂ s, fun ⟨t, tu, h⟩ => mem_of_superset (H₁ t tu) fun ⟨a, b⟩ => h a b⟩⟩⟩
refine' le_antisymm _ _
· change comap (f.prod_congr f) _ ≤ _
        rw [← map_equiv_symm (f.prod_congr f)]
        exact h₂
· rw [← map_le_iff_le_comap]
        exact h₁
simp [UniformContinuous, hf.comap_uniformity.symm, tendsto_comap]
dsimp only [UniformContinuous, tendsto]
rw [← hg.comap_uniformity, ← map_le_iff_le_comap, Filter.map_map]
simp [(· ∘ ·), uniformity_prod, h₁.comap_uniformity.symm, h₂.comap_uniformity.symm, comap_inf,
      comap_comap]
intro b' hb'
rw [nhds_eq_uniformity, lift'_inf_principal_eq, lift'_ne_bot_iff]
exact fun s => this b' s hb'
exact monotone_preimage.inter monotone_const
rw [closure_eq_cluster_pts] <;> exact this b' hb'
simp [comap_comap, (· ∘ ·), DenseEmbedding.subtypeEmb, uniformity_subtype,
        ue.comap_uniformity.symm]
simp [hs]
rw [complete_space_iff_is_complete_univ, ← is_complete_image_iff hf, image_univ]
rw [complete_space_iff_is_complete_range he.to_uniform_inducing, e.range_eq_univ,
    complete_space_iff_is_complete_univ]
rw [Subtype.range_coe]
assumption
rw [complete_space_iff_is_complete_univ, ← range_inl_union_range_inr]
exact
    uniform_embedding_inl.to_uniform_inducing.is_complete_range.union
      uniform_embedding_inr.to_uniform_inducing.is_complete_range
rw [nhds_eq_comap_uniformity]
exact uniformity_has_basis_closed.comap _
simp [separated_space_iff, id_rel_subset.2 separated_equiv.1, subset.antisymm_iff] <;>
    simp [subset_def, separationRel]
rw [← not_imp_not] <;> simp [not_forall]
unfold separationRel
rw [h.sInter_sets]
simp [uniformity_has_basis_closure.separation_rel]
simp [Quotient.exists_rep]
simp [Prod.swap, (· ∘ ·)] <;> exact tendsto_map.comp tendsto_swap_uniformity
  comp
rw [a_eq.right, b_eq.left]
rw [map_lift'_eq] <;>
          exact monotone_comp_rel monotone_id (monotone_comp_rel monotone_id monotone_id)
simp (config := { contextual := true })
dsimp [preimage]
exact h t ht
infer_instance
rw [lift, dif_pos h] <;> rfl
rw [map, lift_mk (uniform_continuous_quotient_mk.comp h)]
simp only [(· ∘ ·), map_mk, hf, hg]
simp [p_α, eqv_α r_α r_α_in]
simp [p_β, eqv_β r_β r_β_in]
simp
simp [image_swap_eq_preimage_swap] <;> exact eq_comm
simp
simp [SymmetricRel, symmetrizeRel, preimage_inter, inter_comm, ← preimage_comp]
rw [SymmetricRel, preimage_inter, hU.eq, hV.eq]
intro r ru
rw [mem_lift'_sets]
exact comp _ ru
apply monotone_comp_rel <;> exact monotone_id
simp <;> intro <;> exact univ_mem
  is_open_inter
congr
exact h
rw [UniformSpace.Core.toTopologicalSpace, UniformSpace.is_open_uniformity]
rw [o₁, o₂] <;> simp [this]
rw [map_swap_eq_comap_swap] <;> exact map_le_iff_le_comap.1 tendsto_swap_uniformity
apply (𝓤 α).inter_sets h
rw [← image_swap_eq_preimage_swap, uniformity_eq_symm]
exact image_mem_map h
rw [map_lift_eq2 hg, image_swap_eq_preimage_swap] <;> exact h
rw [lift_lift'_assoc]
exact monotone_comp_rel monotone_id monotone_id
exact h
rw [lift_lift'_same_eq_lift']
exact fun x => monotone_comp_rel monotone_const <| monotone_comp_rel monotone_id monotone_id
exact fun x => monotone_comp_rel monotone_id monotone_const
unfold SymmetricRel at hV
rw [hV]
rw [mem_ball_symmetry hV] at hx
exact ⟨z, hx, hy⟩
rw [uniformity_eq_symm, mem_nhds_uniformity_iff_right]
rfl
simp [h.symm, hp]
rw [nhds_eq_comap_uniformity]
exact h.comap (Prod.mk x)
rw [nhds_eq_comap_uniformity, mem_comap]
exact Iff.rfl
rw [UniformSpace.mem_nhds_iff]
exact ⟨V, V_in, subset.refl _⟩
simp [UniformSpace.mem_nhds_iff_symm, and_assoc']
simp [mem_closure_iff_nhds_basis (has_basis_nhds x), Set.Nonempty]
simp [mem_closure_iff_nhds_basis' (nhds_basis_uniformity' (𝓤 α).basis_sets)]
rw [nhds_eq_uniformity]
exact
        Filter.lift_assoc <| monotone_principal.comp <| monotone_preimage.comp monotone_preimage
rw [← uniformity_eq_symm]
simp [image_swap_eq_preimage_swap]
rw [nhds_eq_uniformity', nhds_eq_uniformity, prod_lift'_lift']
· rfl
· exact monotone_preimage
· exact monotone_preimage
rw [nhds_prod_eq, nhds_nhds_eq_uniformity_uniformity_prod, lift_lift'_same_eq_lift']
· intro s
    exact monotone_const.set_prod monotone_preimage
· intro t
    exact monotone_preimage.set_prod monotone_const
rw [nhds_eq_uniformity_prod, mem_lift'_sets]
exact ⟨d, hd, fun ⟨a, b⟩ ⟨ha, hb⟩ => ⟨x, y, ha, hp, hb⟩⟩
exact monotone_preimage.set_prod monotone_preimage
simp [Classical.skolem] at this <;> simp <;> assumption
simp <;> exact ⟨a, b, hp, (ht (a, b) hp).right.right⟩
rw [nhds_prod_eq]
exact prod_mem_prod (ball_mem_nhds x w_in) (ball_mem_nhds x w_in)
simp only [comp_rel_assoc]
rw [uniformity_eq_uniformity_interior] <;> exact mem_lift' hs
simp only [Prod.forall, subset_def]
simp only [← and_assoc']
refine' uniformity_has_basis_open.restrict fun s hs => ⟨symmetrizeRel s, _⟩
exact
    ⟨⟨symmetrize_mem_uniformity hs.1, IsOpen.inter hs.2 (hs.2.Preimage continuous_swap)⟩,
      symmetric_symmetrize_rel s, symmetrize_rel_subset_self s⟩
rw [UniformContinuousOn, UniformContinuous, univ_prod_univ, principal_univ, inf_top_eq]
simp [comap_principal, this, univ_mem]
simp [UniformContinuous] <;> exact tendsto_id
simp only [Prod.forall]
simp [tendsto] <;> apply subset.refl
      comp
rw [lift'_principal]
· simp
exact monotone_comp_rel monotone_id monotone_id
simp (config := { contextual := true }) [is_open_fold, subset_def, idRel]
simp <;> exact fun ⟨a, b⟩ (h : a = b) => h ▸ rfl
simp [tendsto_comap_iff, Prod.swap, (· ∘ ·)] <;>
      exact tendsto_swap_uniformity.comp tendsto_comap
rw [comap_lift'_eq, comap_lift'_eq2]
exact lift'_mono' fun s hs ⟨a₁, a₂⟩ ⟨x, h₁, h₂⟩ => ⟨f x, h₁, h₂⟩
exact monotone_comp_rel monotone_id monotone_id
rw [h]
rfl
intro u₁ u₂ hu
change 𝓤 _ ≤ 𝓤 _
rw [uniformity_comap rfl]
exact comap_mono hu
rw [uniform_continuous_iff, uniform_space_comap_id, id]
rw [@nhds_eq_uniformity α u₁ a, @nhds_eq_uniformity α u₂ a] <;> exact lift'_mono h le_rfl
refine' eq_of_nhds_eq_nhds fun a => _
rw [nhds_infi, nhds_eq_uniformity]
change (infi u).uniformity.lift' (preimage <| Prod.mk a) = _
rw [infi_uniformity, lift'_infi_of_map_univ _ preimage_univ]
· simp only [nhds_eq_uniformity]
    rfl
· exact ball_inter _
rw [Inf_eq_infi]
simp only [← to_topological_space_infi]
rw [UniformContinuous, Inf_eq_infi', infi_uniformity']
exact tendsto_infi' ⟨u, h₁⟩ hf
rw [UniformContinuous, Inf_eq_infi', infi_uniformity']
exact tendsto_infi.mpr fun ⟨u, hu⟩ => h u hu
rw [UniformContinuous, infi_uniformity']
exact tendsto_infi' i hf
rw [(@map_nhds_subtype_coe_eq α _ s a (mem_of_mem_nhds ha) ha).symm] <;>
    exact tendsto_map' (continuous_iff_continuous_at.mp hf.continuous _)
rw [uniform_continuous_on_iff_restrict] at h
rw [continuous_on_iff_continuous_restrict]
exact h.continuous
rw [uniformity_prod, Filter.prod, comap_inf, comap_comap, comap_comap]
rw [map_swap4_eq_comap, uniformity_prod_eq_comap_prod]
rw [uniformity_prod] <;> exact inter_mem_inf (preimage_mem_comap ha) (preimage_mem_comap hb)
rw [UniformContinuous, uniformity_prod] <;>
    exact tendsto_inf.2 ⟨tendsto_comap_iff.2 h₁, tendsto_comap_iff.2 h₂⟩
let t : UniformSpace (α × β) := Prod.uniformSpace
have ha := uniform_continuous_Inf_dom ha uniform_continuous_id
have hb := uniform_continuous_Inf_dom hb uniform_continuous_id
have h_unif_cont_id := @UniformContinuous.prod_map _ _ _ _ (Inf uas) (Inf ubs) ua ub _ _ ha hb
exact @UniformContinuous.comp _ _ _ (id _) (id _) _ _ _ hf h_unif_cont_id
rw [UniformContinuous₂, uncurry_curry]
intro k hk
simp only [mem_Union, SetCoe.exists]
exact ⟨k, hk, UniformSpace.mem_ball_self k (hW ⟨k, hk⟩).1⟩
rw [ContinuousAt, tendsto_nhds_right]
rw [ContinuousAt, tendsto_nhds_left]
rw [ContinuousWithinAt, tendsto_nhds_right]
rw [ContinuousWithinAt, tendsto_nhds_left]
simp [ContinuousOn, continuous_within_at_iff'_right]
simp [ContinuousOn, continuous_within_at_iff'_left]
simp only [(has_basis_nhds_compact_convergence f).tendsto_right_iff, TendstoUniformlyOn, and_imp,
    Prod.forall]
refine' forall_congr' fun K => _
rw [forall_swap]
exact forall₃_congr fun hK V hV => Iff.rfl
simp [hx, mem_ball_self (f x) hZ₁]
simp [subset_closure]
apply closure_mono
simp
simp [compact_open.gen, hfC]
rw [← nhds_compact_convergence]
exact @IsOpen.mem_nhds C
simp only [has_basis_compact_convergence_uniformity_aux.mem_iff, exists_prop, Prod.exists,
    and_assoc']
simp only [compact_convergence_uniformity, and_imp, Filter.le_principal_iff, Prod.forall,
      Filter.mem_principal, mem_set_of_eq, le_infi_iff, id_rel_subset]
exact fun K V hK hV f x hx => refl_mem_uniformity hV
simp
rw [compact_open_eq_compact_convergence, tendsto_iff_forall_compact_tendsto_uniformly_on']
rw [tendsto_iff_forall_compact_tendsto_uniformly_on]
intro K hK
rw [← tendsto_locally_uniformly_on_iff_tendsto_uniformly_on_of_compact hK]
exact h.tendsto_locally_uniformly_on
rw [tendsto_iff_forall_compact_tendsto_uniformly_on, ← tendsto_uniformly_on_univ]
exact ⟨fun h => h univ is_compact_univ, fun h K hK => h.mono (subset_univ K)⟩
infer_instance
simp only [UniformContinuous, Matrix.uniformity, Filter.tendsto_infi, Filter.tendsto_comap_iff]
infer_instance
infer_instance
rw [uniformity_prod_eq_comap_prod]
exact (𝓤 α).basis_sets.prod_self.comap _
refine' le_of_eq _
rw [Filter.map_supr]
congr
intro h
apply this
apply diag_subset
simp [h]
    -- Since γ is compact and Hausdorff, it is normal, hence T₃.
simp
rw [compact_space_uniformity]
rw [Filter.map_supr]
rw [uniform_continuous_on_iff_restrict]
rw [is_compact_iff_compact_space] at hs
rw [continuous_on_iff_continuous_restrict] at hf
skip
exact CompactSpace.uniform_continuous_of_continuous hf
rw [equicontinuous_iff_continuous] at h
rw [uniform_equicontinuous_iff_uniform_continuous]
exact CompactSpace.uniform_continuous_of_continuous h
rw [UniformFun.filter, ← FilterBasis.generate, sets_iff_generate]
change _ ≤ _
rw [map_le_iff_le_comap,
    (UniformFun.has_basis_uniformity α β).le_basis_iff ((𝓤 _).basis_sets.comap _)]
exact fun U hU => ⟨U, hU, fun uv huv => huv x⟩
rw [inf_eq_infi, inf_eq_infi, UniformFun.infi_eq]
refine' infi_congr fun i => _
cases i <;> rfl
rw [uniform_continuous_pi]
intro x
exact uniform_continuous_eval β x
rw [(UniformFun.has_basis_nhds α β f).tendsto_right_iff, TendstoUniformly]
exact Iff.rfl
constructor
change
        comap (Prod.map (Equiv.arrowProdEquivProdArrow _ _ _) (Equiv.arrowProdEquivProdArrow _ _ _))
            _ =
          _
rw [← uniformity_comap rfl]
congr
rw [Prod.uniformSpace, Prod.uniformSpace, UniformSpace.comap_inf, UniformFun.inf_eq]
congr <;> rw [← UniformSpace.comap_comap, UniformFun.comap_eq] <;> rfl
constructor
change comap (Prod.map Function.swap Function.swap) _ = _
rw [← uniformity_comap rfl]
congr
rw [PiCat.uniformSpace, UniformSpace.of_core_eq_to_core, PiCat.uniformSpace,
        UniformSpace.of_core_eq_to_core, UniformSpace.comap_infi, UniformFun.infi_eq]
refine' infi_congr fun i => _
rw [← UniformSpace.comap_comap, UniformFun.comap_eq]
simp only [UniformOnFun.topologicalSpace, to_topological_space_infi, to_topological_space_infi,
    to_topological_space_comap]
rfl
simp only [infi_uniformity']
exact
    has_basis_binfi_of_directed h (fun S => UniformOnFun.gen 𝔖 S ∘ s) _
      (fun S hS => UniformOnFun.has_basis_uniformity_of_basis_aux₁ α β 𝔖 hb S)
      (UniformOnFun.has_basis_uniformity_of_basis_aux₂ α β 𝔖 h' hb)
change _ ≤ _
rw [UniformOnFun.uniformSpace, map_le_iff_le_comap, uniformity, infi_uniformity]
refine' infi_le_of_le s _
rw [infi_uniformity]
exact infi_le _ h
rw [inf_eq_infi, inf_eq_infi, UniformOnFun.infi_eq]
refine' infi_congr fun i => _
cases i <;> rfl
intro s hs
change e.symm
rw [UniformOnFun.topological_space_eq, nhds_infi, tendsto_infi]
refine' forall_congr' fun s => _
rw [nhds_infi, tendsto_infi]
refine' forall_congr' fun hs => _
rw [nhds_induced, tendsto_comap_iff, tendsto_uniformly_on_iff_tendsto_uniformly_comp_coe,
    UniformFun.tendsto_iff_tendsto_uniformly]
rfl
constructor
change
        comap (Prod.map (Equiv.arrowProdEquivProdArrow _ _ _) (Equiv.arrowProdEquivProdArrow _ _ _))
            _ =
          _
rw [← uniformity_comap rfl]
congr
rw [Prod.uniformSpace, Prod.uniformSpace, UniformSpace.comap_inf, UniformOnFun.inf_eq]
congr <;> rw [← UniformSpace.comap_comap, UniformOnFun.comap_eq] <;> rfl
constructor
change comap (Prod.map Function.swap Function.swap) _ = _
rw [← uniformity_comap rfl]
congr
rw [PiCat.uniformSpace, UniformSpace.of_core_eq_to_core, PiCat.uniformSpace,
        UniformSpace.of_core_eq_to_core, UniformSpace.comap_infi, UniformOnFun.infi_eq]
refine' infi_congr fun i => _
rw [← UniformSpace.comap_comap, UniformOnFun.comap_eq]
simp only [subset_def, Prod.forall, mem_prod_eq, and_imp, id, ball_mem_comm]
simp only [subset_def, Prod.forall, mem_prod_eq, and_imp, id, ball_mem_comm]
rw [Cauchy, map_ne_bot_iff, prod_map_map_eq, tendsto]
refine' ⟨hf.1.Prod hg.1, _⟩
simp only [uniformity_prod, le_inf_iff, ← map_le_iff_le_comap, ← prod_map_map_eq]
exact
    ⟨le_trans (prod_mono tendsto_fst tendsto_fst) hf.2,
      le_trans (prod_mono tendsto_snd tendsto_snd) hg.2⟩
simp only [prod_at_top_at_top_eq, Prod.map_def]
rw [cauchy_seq_iff_tendsto] at hu
exact ((hu.comp <| hf.prod_at_top hg).comp tendsto_at_top_diagonal).subseq_mem hV
simp [cauchy_seq_iff', Filter.eventually_at_top_prod_self', Prod_map]
rw [cauchy_seq_iff_tendsto, ← prod_at_top_at_top_eq]
refine' (at_top_basis.prod_self.tendsto_iff h).trans _
simp only [exists_prop, true_and_iff, maps_to, preimage, subset_def, Prod.forall, mem_prod_eq,
    mem_set_of_eq, mem_Ici, and_imp, Prod.map, ge_iff_le, @forall_swap (_ ≤ _) β]
simp only [le_principal_iff, Ultrafilter.mem_coe]
simp only [is_complete_iff_ultrafilter', Ultrafilter.union_mem_iff, or_imp] at *
exact fun l hl =>
    ⟨fun hsl => (hs l hl hsl).imp fun x hx => ⟨Or.inl hx.fst, hx.snd⟩, fun htl =>
      (ht l hl htl).imp fun x hx => ⟨Or.inr hx.fst, hx.snd⟩⟩
rw [nhds_prod_eq, Filter.prod_def] <;>
        exact
          Filter.le_lift.2 fun s hs => Filter.le_lift'.2 fun t ht => inter_mem (hx1 hs) (hx2 ht)
simp [complete_space_iff_is_complete_univ, is_complete_iff_ultrafilter]
simp [image_subset_iff]
simp [subset_def] at hct
intro x hx
simp
exact hct x hx
simp
refine' ⟨fun hs f => f.cauchy_of_totally_bounded hs, fun H => totally_bounded_iff_filter.2 _⟩
intro f hf hfs
exact ⟨Ultrafilter.of f, Ultrafilter.of_le f, H _ ((Ultrafilter.of_le f).trans hfs)⟩
intro p hp
refine' (set_seq_aux hf U_mem N).2.snd ⟨_, _⟩ <;> apply set_seq_sub_aux
exact set_seq_mono hf U_mem hm hp.1
exact set_seq_mono hf U_mem hn hp.2
rw [nhds_eq_comap_uniformity]
infer_instance
infer_instance
infer_instance
infer_instance
rw [Rat.uniform_space_eq]
exact rat.uniform_embedding_coe_real.to_uniform_inducing
rw [pkg.extend_def hf]
exact pkg.dense_inducing.extend_eq hf.continuous a
congr
intro a
change pkg.extend (ι' ∘ f) _ = _
simp only [(· ∘ ·), h]
rw [pkg.extend_coe (hg.comp pkg.uniform_continuous_coe)]
rw [pkg.extend_coe (hf.comp hg), comp_app, pkg.map_coe pkg' hg, pkg'.extend_coe hf]
have uc := pkg.uniform_continuous_compare pkg'
have uc' := pkg'.uniform_continuous_compare pkg
apply pkg'.funext (uc.comp uc').Continuous continuous_id
intro a
rw [comp_app, pkg'.compare_coe pkg, pkg.compare_coe pkg']
rfl
infer_instance
infer_instance
rw [uniform_continuous₂_def, AbstractCompletion.extend₂, uncurry_curry]
apply uniform_continuous_extend
rw [← comp_range_splitting F] <;> exact h.comp _
rw [← comp_range_splitting F] <;> exact h.comp _
rw [ContinuousAt, (UniformFun.has_basis_nhds ι α _).tendsto_right_iff] <;> rfl
rw [UniformContinuous, (UniformFun.has_basis_uniformity ι α).tendsto_right_iff] <;> rfl
rw [equicontinuous_at_iff_continuous_at, ContinuousAt,
    hX.tendsto_iff (UniformFun.has_basis_nhds ι α _)]
rfl
rw [equicontinuous_at_iff_continuous_at, ContinuousAt,
    (UniformFun.has_basis_nhds_of_basis ι α _ hα).tendsto_right_iff]
rfl
rw [equicontinuous_at_iff_continuous_at, ContinuousAt,
    hX.tendsto_iff (UniformFun.has_basis_nhds_of_basis ι α _ hα)]
rfl
rw [uniform_equicontinuous_iff_uniform_continuous, UniformContinuous,
    (UniformFun.has_basis_uniformity_of_basis ι α hα).tendsto_right_iff]
rfl
have := (UniformFun.postcomp_uniform_inducing hu).Inducing
rw [equicontinuous_at_iff_continuous_at, equicontinuous_at_iff_continuous_at,
    this.continuous_at_iff]
rfl
trace
    "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr ∀ x, (_ : exprProp())]]"
rw [hu.equicontinuous_at_iff]
have := UniformFun.postcomp_uniform_inducing hu
rw [uniform_equicontinuous_iff_uniform_continuous, uniform_equicontinuous_iff_uniform_continuous,
    this.uniform_continuous_iff]
rfl
simp only [specializes_iff_mem_closure, hf.closure_eq_preimage_closure_image, image_singleton,
    mem_preimage]
simp only [Specializes, nhds_prod_eq, prod_le_prod]
simp only [Specializes, nhds_pi, pi_le_pi]
simp only [inseparable_iff_specializes_and, specializes_iff_forall_open, ← forall_and, ← iff_def,
    Iff.comm]
simp [inseparable_iff_forall_open, ← xor_iff_not_iff]
simp only [inseparable_iff_specializes_and, specializes_iff_forall_closed, ← forall_and, ←
    iff_def]
simp only [specializes_iff_mem_closure, and_comm']
simp only [inseparable_iff_specializes_and, specializes_iff_closure_subset, ← subset_antisymm_iff,
    eq_comm]
simp only [inseparable_iff_specializes_and, hf.specializes_iff]
simp only [Inseparable, nhds_prod_eq, prod_inj]
simp only [Inseparable, nhds_pi, funext_iff, pi_inj]
rw [range_mk]
exact is_closed_univ
rw [← comap_mk_nhds_mk, map_comap_of_surjective surjective_mk]
rw [← comap_mk_nhds_set_image, map_comap_of_surjective surjective_mk]
rw [nhds_prod_eq, ← prod_map_map_eq', map_mk_nhds, map_mk_nhds, nhds_prod_eq]
rw [nhdsWithin, ← comap_principal, Filter.push_pull, nhdsWithin, map_mk_nhds]
simp only [← map_mk_nhds, tendsto_map'_iff, lift_comp_mk]
simp only [← map_mk_nhds_within_preimage, tendsto_map'_iff, lift_comp_mk]
simp only [ContinuousOn, surjective_mk.forall, continuous_within_at_lift, mem_preimage]
simp only [continuous_iff_continuous_on_univ, continuous_on_lift, preimage_univ]
rw [← map_prod_map_mk_nhds, tendsto_map'_iff]
rfl
rw [nhdsWithin, ← map_prod_map_mk_nhds, ← Filter.push_pull, comap_principal]
rfl
simp only [continuous_iff_continuous_on_univ, continuous_on_lift₂, preimage_univ]
rw [← comp_apply, h, comp_apply]
rw [quasi_separated_space_iff]
simp [IsQuasiSeparated]
intro U V hU hU' hU'' hV hV' hV''
exact ht U V (hU.trans h) hU' hU'' (hV.trans h) hV' hV''
rw [polynomial_functions_closure_eq_top _ _]
simp
simp only [hf x hx, hg x hx, coe_add, Pi.add_apply, add_zero]
simp only [ideal_of_set, Submodule.coe_set_mk, Set.set_of_forall]
exact
    is_closed_Inter fun x =>
      is_closed_Inter fun hx => is_closed_eq (continuous_eval_const' x) continuous_const
rw [← Set.mem_compl_iff, set_of_ideal, compl_compl, Set.mem_setOf]
simp only [set_of_ideal, Set.set_of_forall, is_open_compl_iff]
exact
    is_closed_Inter fun f =>
      is_closed_Inter fun hf => is_closed_eq (map_continuous f) continuous_const
simp only [mem_ideal_of_set, compl_compl, Set.mem_singleton_iff, forall_eq]
simp only [coe_sub, coe_one, coe_comp, ContinuousMap.coe_coe, Pi.sub_apply,
              Pi.one_apply, Function.comp_apply, algebra_map_clm_apply]
simp only [Algebra.algebra_map_eq_smul_one, Nnreal.smul_def, Nnreal.coe_sub (hg x),
              sub_smul, Nonneg.coe_one, one_smul]
simp only [mul_sub, coe_sub, coe_one, Pi.sub_apply, Pi.one_apply, mul_one]
rw [Ideal.is_maximal_def]
refine' (ideal_opens_gi X 𝕜).is_coatom_iff (fun I hI => _) s
rw [← Ideal.is_maximal_def] at hI
skip
exact ideal_of_set_of_ideal_is_closed inferInstance
rw [character_space.eq_set_map_one_map_mul]
exact ⟨rfl, fun f g => rfl⟩
rw [polynomial_comp_attach_bound]
apply SetLike.coe_mem
intro x
simp only [coe_fn_coe_base'] at w₁
simp [coe_fn_coe_base', w₁]
  -- For each `x`, we define `W x` to be `{z | h x z < f z + ε}`,
intros
simp only [← Metric.mem_ball, Real.ball_eq_Ioo, Set.mem_Ioo, and_comm']
rw [subalgebra_topological_closure_eq_top_of_separates_points A w]
simp
simp
simp [dist_eq, dist_comm]
rw [(ext isEmptyElim : f = g), dist_self]
cases isEmpty_or_nonempty α
· rw [supr_of_empty', Real.Sup_empty, dist_zero_of_empty]
refine' (dist_le_iff_of_nonempty.mpr <| le_csupr _).antisymm (csupr_le dist_coe_le_dist)
exact dist_set_exists.imp fun C hC => forall_range_iff.2 hC.2
rw [inducing_iff_nhds]
refine' fun f => eq_of_forall_le_iff fun l => _
rw [← tendsto_iff_comap, ← tendsto_id', tendsto_iff_tendsto_uniformly,
    UniformFun.tendsto_iff_tendsto_uniformly]
rfl
simp [le_rfl]
refine' Metric.tendsto_uniformly_iff.2 fun ε ε0 => _
refine' ((tendsto_order.1 b_lim).2 ε ε0).mono fun n hn x => _
rw [dist_comm]
exact lt_of_le_of_lt (fF_bdd x n) hn
rw [← bounded_range_iff, range_extend f.injective, Metric.bounded_union]
exact ⟨g.bounded_range, h.bounded_image _⟩
rw [extend_apply' x.coe_prop, extend_apply' x.coe_prop]
simp [dist_nonneg]
infer_instance
rw [add_halves, add_halves]
rw [F_f_g]
intro x y
refine' le_trans (lipschitz_with_lipschitz_const_add ⟨f x, g x⟩ ⟨f y, g y⟩) _
rw [Prod.dist_eq]
refine' mul_le_mul_of_nonneg_left _ (HasLipschitzAdd.c β).coe_nonneg
apply max_le_max
exact Classical.choose_spec f.bounded x y
exact Classical.choose_spec g.bounded x y
rw [nsmulRec, zero_smul, coe_zero]
rw [nsmulRec, succ_nsmul, coe_add, coe_nsmul_rec]
simp
simp [norm_def, BoundedContinuousFunction.dist_eq]
simp [dist_zero_right]
simp only [norm_eq, coe_norm_comp, norm_norm]
simp only [norm_eq_supr_norm, coe_one, Pi.one_apply, norm_one, csupr_const]
simp only [sub_eq_add_neg]
exact
        le_trans (norm_add_le _ _)
          (add_le_add (f.norm_coe_le_norm x) <|
            trans_rel_right _ (norm_neg _) (g.norm_coe_le_norm x))
rw [zsmulRec, Int.ofNat_eq_coe, coe_nsmul_rec, coe_nat_zsmul]
rw [zsmulRec, zsmul_neg_succ_of_nat, coe_neg, coe_nsmul_rec]
simp only [norm_eq, dist_eq, dist_eq_norm, sub_apply]
rw [dist_eq_norm]
exact (f - g).norm_coe_le_norm x
rw [Nnreal.coe_one, one_mul, dist_zero_right]
refine' (dist_smul_pair c (f x) (f y)).trans _
refine' mul_le_mul_of_nonneg_left _ dist_nonneg
exact hb x y
rw [dist_le (mul_nonneg dist_nonneg dist_nonneg)]
intro x
refine' (dist_smul_pair c (f₁ x) (f₂ x)).trans _
exact mul_le_mul_of_nonneg_left (dist_coe_le_dist x) dist_nonneg
refine' norm_of_normed_add_comm_group_le _ (mul_nonneg (norm_nonneg _) (norm_nonneg _)) _
exact fun x =>
      trans_rel_right _ (norm_smul _ _)
        (mul_le_mul_of_nonneg_left (f.norm_coe_le_norm _) (norm_nonneg _))
rw [npowRec, pow_zero, coe_one]
rw [npowRec, pow_succ, coe_mul, coe_npow_rec]
rw [Algebra.algebra_map_eq_smul_one]
rfl
simp only [norm_eq, star_apply, norm_star]
intro f g h₁ h t
simp only [coe_to_continuous_fun, Pi.add_apply, add_le_add_iff_left, coe_add,
        ContinuousMap.to_fun_eq_coe]
exact h₁ _
funext x
dsimp
simp only [max_zero_sub_max_neg_zero_eq_self]
funext x
dsimp
simp only [max_zero_add_max_neg_zero_eq_abs_self]
rw [h]
exact f.continuous_to_fun
refine' CocompactMap.tendsto_of_forall_preimage fun K hK => _
erw [K.preimage_equiv_eq_image_symm]
exact hK.image f.symm.continuous
simp
rw [Algebra.algebra_map_eq_smul_one]
rfl
simp only [ContinuousMap.comp_star_alg_hom'_apply, ContinuousMap.comp_assoc,
        to_continuous_map_comp_symm, ContinuousMap.comp_id]
simp only [ContinuousMap.comp_star_alg_hom'_apply, ContinuousMap.comp_assoc,
        symm_comp_to_continuous_map, ContinuousMap.comp_id]
cases f <;> cases g <;> congr
cases f <;> cases g <;> congr
rw [← comp_apply, h, comp_apply]
rw [← coeTrans, self_trans_symm, coe_refl]
rw [← coeTrans, symm_trans_self, coe_refl]
simp [Set.preimage]
intro x1 x2 h
apply Inseparable.eq
rw [← Inducing.inseparable_iff (product_of_mem_opens_inducing X), h]
refine'
    continuous_induced_rng.2
      (Continuous.prod_mk f.continuous
        (mul_opposite.continuous_op.comp (continuous_iff_continuous_at.mpr fun x => _)))
have := NormedRing.inverse_continuous_at (h x).Unit
simp only [← Ring.inverse_unit, IsUnit.unit_spec, ← Function.comp_apply] at this⊢
exact this.comp (f.continuous_at x)
rw [h]
exact f.continuous_to_fun
simp
simp
rw [nsmulRec, zero_smul, coe_zero]
rw [nsmulRec, succ_nsmul, coe_add, coe_nsmul_rec]
rw [zsmulRec, Int.ofNat_eq_coe, coe_nsmul_rec, coe_nat_zsmul]
rw [zsmulRec, zsmul_neg_succ_of_nat, coe_neg, coe_nsmul_rec]
intro x
infer_instance
simp only [← dist_mk_of_compact, dist_coe_le_dist, ← mk_of_compact_apply]
simp only [← dist_mk_of_compact, dist_le C0, mk_of_compact_apply]
simp only [← dist_mk_of_compact, dist_le_iff_of_nonempty, mk_of_compact_apply]
simp only [← dist_mk_of_compact, dist_lt_iff_of_nonempty_compact, mk_of_compact_apply]
simp only [← dist_mk_of_compact, dist_lt_iff_of_compact C0, mk_of_compact_apply]
rw [← norm_mk_of_compact, ← dist_mk_of_compact, dist_eq_norm, mk_of_compact_sub]
simp only [← norm_mk_of_compact, mk_of_compact_one, norm_one]
refine' metric.continuous_iff.mpr _
intro g ε ε_pos
refine' ⟨ε, ε_pos, fun g' h => _⟩
rw [ContinuousMap.dist_lt_iff ε_pos] at h⊢
· exact fun x => h (f x)
rw [← BoundedContinuousFunction.norm_mk_of_compact,
      BoundedContinuousFunction.mk_of_compact_star, norm_star,
      BoundedContinuousFunction.norm_mk_of_compact]
simp [le_refl]
simp [le_refl]
simp [le_def.mp w₁ a, le_def.mp w₂ a]
simp [le_refl]
simp [le_refl]
simp [le_def.mp w₁ a, le_def.mp w₂ a]
apply Polynomial.induction_on' g
· intro p q hp hq
    simp [hp, hq]
· intro n a
    simp [Pi.pow_apply]
refine' ⟨_, ⟨⟨_, ⟨⟨Polynomial.x, ⟨Algebra.mem_top, rfl⟩⟩, rfl⟩⟩, _⟩⟩
dsimp
simp only [Polynomial.eval_X]
exact fun h' => h (Subtype.ext h')
refine' ⟨fun H x => _, di.dense.dense_image di.continuous⟩
rw [di.to_inducing.closure_eq_preimage_closure_image, H.closure_eq, preimage_univ]
trivial
simp <;> exact fun h₁ h₂ => ⟨de₁.inj h₁, de₂.inj h₂⟩
simp [subtype_emb, nhds_subtype_eq_comap, de.to_inducing.nhds_eq_comap, comap_comap,
          (· ∘ ·)]
rw [hf.to_inducing.nhds_eq_comap x]
exact ⟨T', hT₁, subset.rfl⟩
simp [symm]
simp [symm]
simp [symm]
infer_instance
simp [h]
let e := Homeomorph.image (affineHomeomorph (b - a) a (sub_pos.mpr h).Ne.symm) (Set.icc 0 1)
refine' (e.trans _).symm
apply Homeomorph.setCongr
simp [sub_pos.mpr h]
delta restrict_open restrict
rw [← comp_apply, ← functor.map_comp]
rfl
delta restrict_open restrict
rw [← comp_apply, nat_trans.naturality, comp_apply]
rw [h]
dsimp [functor.op]
apply Quiver.Hom.op
apply eq_to_hom
rw [h]
simp [pushforward_eq]
rw [h]
dsimp [pushforward_eq]
simp
unfold pushforward_obj
rw [opens.map_id_eq]
erw [functor.id_comp]
dsimp [id]
simp
dsimp [id]
simp
erw [α.naturality]
rfl
simp
simp
rw [← category.id_comp ((id ℱ).inv.app (op U)), ← nat_iso.app_inv, iso.comp_inv_eq]
dsimp [id]
rw [colimit.ι_desc_assoc]
dsimp
rw [← ℱ.map_comp, ← ℱ.map_id]
rfl
simp [opens.map, Set.preimage_preimage]
delta to_pushforward_of_iso
simp only [Equiv.to_fun_as_coe, nat_trans.comp_app, equivalence.equivalence_mk'_unit,
    eq_to_hom_map, eq_to_hom_op, eq_to_hom_trans, presheaf_equiv_of_iso_unit_iso_hom_app_app,
    equivalence.to_adjunction, equivalence.equivalence_mk'_counit,
    presheaf_equiv_of_iso_inverse_map_app, adjunction.mk_of_unit_counit_hom_equiv_apply]
congr
simp [opens.map, Set.preimage_preimage]
infer_instance
dsimp [presheaf.germ, stalk_to_fiber]
cases x
simp
rfl
erw [if_pos h, if_pos (le_of_hom i.unop h)]
simp only [skyscraper_presheaf_map]
change dite _ _ _
rw [← c.w (hom_of_le <| (le_top : unop U ≤ _)).op]
change _
rw [← h, skyscraper_presheaf_cocone_of_specializes_ι_app, eq_to_hom_trans_assoc, eq_to_hom_refl,
      category.id_comp]
change _ = c.ι.app (op U.unop)
simp only [← c.w (hom_of_le <| @inf_le_left _ _ h1.some U.unop).op, ←
        c.w (hom_of_le <| @inf_le_right _ _ h1.some U.unop).op, ← category.assoc]
congr 1
refine' ((if_neg _).symm.rec terminal_is_terminal).hom_ext _ _
exact fun h => h1.some_spec h.1
rw [← category.id_comp f, ← H, ← category.assoc]
congr 1
apply terminal_is_terminal.hom_ext
dsimp
rw [if_neg]
exact terminal_is_terminal
exact Set.not_mem_empty PUnit.unit
dsimp
erw [← category.assoc, colimit.ι_map, colimit.iso_colimit_cocone_ι_hom_assoc,
        skyscraper_presheaf_cocone_of_specializes_ι_app, category.assoc, colimit.ι_desc,
        whiskering_left_obj_map, whisker_left_app, SkyscraperPresheafFunctor.map'_app,
        dif_pos U.unop.2, skyscraper_presheaf_cocone_of_specializes_ι_app, comp_eq_to_hom_iff,
        category.assoc, eq_to_hom_comp_iff, ← category.assoc, eq_to_hom_trans, eq_to_hom_refl,
        category.id_comp, comp_eq_to_hom_iff, category.assoc, eq_to_hom_trans, eq_to_hom_refl,
        category.comp_id, CategoryTheory.Functor.id_map]
rw [res, limit.lift_π, fan.mk_π_app]
intros
rfl
erw [← F.map_comp]
congr
erw [← F.map_comp]
congr
refine' (presheaf.is_sheaf_iff_is_limit _ _).trans _
constructor
· intro h ι U
    rw [(is_limit_opens_le_equiv_generate₁ F U rfl).nonempty_congr]
    apply h
    apply presieve_of_covering.mem_grothendieck_topology
· intro h Y S
    rw [← sieve.generate_sieve S]
    intro hS
    rw [← (is_limit_opens_le_equiv_generate₂ F S hS).nonempty_congr]
    apply h
rw [is_sheaf_iff_is_sheaf_opens_le_cover,
    is_sheaf_opens_le_cover_iff_is_sheaf_pairwise_intersections]
rw [← F.1.map_comp, ← F.1.map_comp]
congr
erw [category.assoc, ← F.1.map_comp]
exact
    (F.presheaf.is_sheaf_iff_is_sheaf_pairwise_intersections.mp F.2 _).some.fac _
      (op <| pairwise.single (ULift.up walking_pair.left))
erw [category.assoc, ← F.1.map_comp]
exact
    (F.presheaf.is_sheaf_iff_is_sheaf_pairwise_intersections.mp F.2 _).some.fac _
      (op <| pairwise.single (ULift.up walking_pair.right))
rw [is_sheaf_iff_is_sheaf_pairwise_intersections] at h⊢ <;>
    exact sheaf_condition_pairwise_intersections.pushforward_sheaf_of_sheaf f h
rw [stalk_pushforward, germ, colimit.ι_map_assoc, colimit.ι_pre, whisker_right_app]
erw [CategoryTheory.Functor.map_id, category.id_comp]
rfl
erw [category.comp_id]
exact F.germ_res i.left.unop _
erw [colimit.pre_desc, category.comp_id]
congr
simp
simp
simp
erw [← F.germ_res iWU ⟨x, hxW⟩, ← F.germ_res iWV ⟨x, hxW⟩, comp_apply, comp_apply, ih]
rw [stalk_functor_map_germ_apply, stalk_functor_map_germ_apply, hst]
intro m
exact stalk_mono_of_mono _
intro m
exact mono_of_stalk_mono _
intro x hxU
rw [opens.mem_coe, opens.mem_supr]
exact ⟨⟨x, hxU⟩, mV ⟨x, hxU⟩⟩
  -- Since `F` is a sheaf, we can glue all the local preimages together to get a global preimage.
exact is_iso_of_reflects_iso (f.1.app (op U)) (forget C)
exact is_iso_of_fully_faithful (sheaf.forget C X) f
  -- We show that all components of `f` are isomorphisms.
exact @nat_iso.is_iso_of_is_iso_app _ _ _ _ F.1 G.1 f.1 this
constructor
· intro h x
    skip
    exact @functor.map_is_iso _ _ _ _ _ _ (stalk_functor C x) f.1 ((sheaf.forget C X).map_is_iso f)
· intro h
    exact is_iso_of_stalk_functor_map_iso f
apply IsLocalization.ring_hom_ext (G.obj U)
any_goals dsimp; infer_instance
refine' (IsLocalization.map_comp _).trans _
rw [F.map_id]
rfl
simp
simp only [IsCoveringMap, IsCoveringMapOn, Set.mem_univ, forall_true_left]
simp only [specializes_iff_mem_closure, IsGenericPoint, Set.ext_iff]
rw [h.mem_open_set_iff hU, ← not_disjoint_iff_nonempty_inter, not_not]
rw [← h.def, hZ.closure_subset_iff, singleton_subset_iff]
rw [is_generic_point_def, ← h.def, ← image_singleton]
exact
    subset.antisymm (closure_mono (image_subset _ subset_closure))
      (closure_minimal (image_closure_subset_closure_image hf) is_closed_closure)
simp
change _
rw [← hT.closure_eq]
exact closure_mono (Set.inter_subset_left _ _) hx.mem
rw [hS'']
trivial
intro t x hx
dsimp only [coe_mk, pi_eval, to_fun_eq_coe, homotopy_with.coe_to_continuous_map]
simp only [Function.funext_iff, ← forall_and]
intro i
exact (homotopies i).prop' t x hx
simp only [prod_eval, homotopy.apply_zero]
simp only [prod_eval, homotopy.apply_one]
intro t x hx
have hF := F.prop' t x hx
have hG := G.prop' t x hx
simp only [coe_mk, prod_eval, Prod.mk.inj_iff, homotopy.prod] at hF hG⊢
exact ⟨⟨hF.1, hG.1⟩, ⟨hF.2, hG.2⟩⟩
unfold pi
simp
apply Quotient.induction_on_pi γ₁
apply Quotient.induction_on_pi γ₀
intros
simp only [pi_lift]
rw [← Path.Homotopic.comp_lift, Path.trans_pi_eq_pi_trans, ← pi_lift]
rfl
apply Quotient.induction_on₂ q₁ q₂
apply Quotient.induction_on₂ r₁ r₂
intros
simp only [prod_lift, ← Path.Homotopic.comp_lift, Path.trans_prod_eq_prod_trans]
refine' homotopic.trans _ h₁.left_inv
change (h₁.inv_fun.comp h₂.inv_fun).comp (h₂.to_fun.comp h₁.to_fun) with
      h₁.inv_fun.comp ((h₂.inv_fun.comp h₂.to_fun).comp h₁.to_fun)
refine' homotopic.hcomp _ (homotopic.refl _)
refine' homotopic.trans ((homotopic.refl _).hcomp h₂.left_inv) _
    -- simp,
rw [ContinuousMap.id_comp]
refine' homotopic.trans _ h₂.right_inv
change (h₂.to_fun.comp h₁.to_fun).comp (h₁.inv_fun.comp h₂.inv_fun) with
      h₂.to_fun.comp ((h₁.to_fun.comp h₁.inv_fun).comp h₂.inv_fun)
refine' homotopic.hcomp _ (homotopic.refl _)
refine' homotopic.trans ((homotopic.refl _).hcomp h₁.right_inv) _
rw [id_comp]
congr
exact h
rfl
intro h
exact e.symm.contractible_space
intro h
exact e.contractible_space
rw [← F.apply_zero]
exact ContinuousMap.congr_fun (Set.Icc_extend_of_le_left (zero_le_one' ℝ) F.curry ht) x
rw [← F.apply_one]
exact ContinuousMap.congr_fun (Set.Icc_extend_of_right_le (zero_le_one' ℝ) F.curry ht) x
simp [← h₀]
simp [← h₁]
simp
simp
simp [F.eq_snd _ hx, F.fst_eq_snd hx]
simp
simp
simp
simp [Path.symm]
simp [Path.symm]
cases hx
· rw [hx]
      simp
· rw [Set.mem_singleton_iff] at hx
      rw [hx]
      simp
simp
simp
cases hx
· simp [hx]
· rw [Set.mem_singleton_iff] at hx
      simp [hx]
induction on `n
simp only [CU.lim, approx_of_mem_C, h, csupr_const]
simp only [CU.lim, approx_of_nmem_U c _ h, csupr_const]
refine' tendsto_nhds_unique (c.tendsto_approx_at_top x) ((tendsto_add_at_top_iff_nat 1).1 _)
simp only [approx]
exact (c.left.tendsto_approx_at_top x).midpoint (c.right.tendsto_approx_at_top x)
rw [hm, preimage_gen g hs hu] <;> exact ContinuousMap.is_open_gen hs (hu.preimage g.2)
rw [hm, image_gen f hs hu]
exact ContinuousMap.is_open_gen (hs.image f.2) hu
assumption
assumption
assumption
rw [continuous_iff_le_induced]
exact compact_open_le_induced s
rw [compact_open_eq_Inf_induced]
simp [nhds_infi, nhds_induced]
rw [compact_open_eq_Inf_induced]
simp [nhds_infi, nhds_induced, Filter.tendsto_comap_iff]
apply continuous_of_continuous_uncurry
rw [← Homeomorph.comp_continuous_iff' (Homeomorph.prodAssoc _ _ _)]
apply Continuous.comp continuous_eval' (Continuous.prod_map continuous_eval' continuous_id) <;>
    infer_instance
rw [hf.continuous_iff]
exact Gf.continuous
rw [Set.preimage_comp]
exact hf _
rw [Set.preimage_comp]
exact hf.is_open_preimage _ (hg _)
let U := f
cases isEmpty_or_nonempty X
· exact ⟨Classical.arbitrary Y, funext <| h.elim⟩
· exact ⟨f (Classical.arbitrary X), hf.eq_const _⟩
rw [h]
rw [iff_exists_open]
exact fun x => ⟨connectedComponent x, is_open_connected_component, mem_connected_component, h x⟩
have : f = g := h
subst f
rw [Set.preimage_comp]
apply g.is_locally_constant
rw [comap, dif_pos hf]
rfl
rw [cond]
exact h.2
rw [mul_indicator_apply]
apply Set.mul_indicator_of_mem h
rw [mul_indicator_apply]
apply Set.mul_indicator_of_not_mem h
simp only [(has_basis_nhds_set s).disjoint_iff (has_basis_nhds_set t), SeparatedNhds, exists_prop,
    ← exists_and_left, and_assoc, and_comm, and_left_comm]
cases h,
    disjoint_empty _
simp only [t0_space_iff_inseparable, Ne.def, not_imp_not]
simp only [t0_space_iff_not_inseparable, xor_iff_not_iff, not_forall, exists_prop,
    inseparable_iff_forall_open]
simp only [t0_space_iff_not_inseparable, inseparable_iff_mem_closure, not_and_or]
rw [diff_eq, inter_comm, nhds_within_inter_of_mem]
exact mem_nhds_within_of_mem_nhds (is_open_ne.mem_nhds h)
rw [← bUnion_of_singleton s]
exact is_closed_bUnion hs fun i hi => is_closed_singleton
change s
simp only [ Disjoint.comm , ne_comm ]
simp only [Antitone, t1_space_iff_continuous_cofinite_of, continuous_iff_le_induced]
exact fun t₁ t₂ h => h.trans
simp only [← continuous_within_at_univ, continuous_within_at_update_of_ne hne]
rw [ContinuousOn, ← and_forall_ne x, and_comm']
refine' and_congr ⟨fun H z hz => _, fun H z hzx hzs => _⟩ (forall_congr' fun hxs => _)
· specialize H z hz.2 hz.1
    rw [continuous_within_at_update_of_ne hz.2] at H
    exact H.mono (diff_subset _ _)
· rw [continuous_within_at_update_of_ne hzx]
    refine' (H z ⟨hzs, hzx⟩).mono_of_mem (inter_mem_nhds_within _ _)
    exact is_open_ne.mem_nhds hzx
· exact continuous_within_at_update_same
simp
simp
rw [← nhds_set_singleton, nhds_set_le_iff, singleton_subset_iff]
simp only [singleton_subset_iff, mem_of_mem_nhds hs]
refine' fun hsf => hx.1 _
rw [← is_open_singleton_iff_punctured_nhds]
exact is_open_singleton_of_finite_mem_nhds x hs hsf
apply singletons_open_iff_discrete.mp
intro x
rw [← is_closed_compl_iff]
exact (Set.to_finite _).IsClosed
simp [nhds_discrete]
rw [inter_assoc, h', compl_inter_self]
change
    tX.induced ((coe : s → X) ∘ Set.inclusion ts) =
      TopologicalSpace.induced (Set.inclusion ts) (tX.induced _)
rw [← induced_compose]
simp [nhds_induced, ← Set.image_singleton, hf.preimage_image, nhds_bot]
apply DiscreteTopology.mk <;> · rw [DiscreteTopology.eq_bot Y, induced_bot hf]
rw [hf.induced, DiscreteTopology.eq_bot Y, induced_bot hf.inj]
rw [TopologicalSpace.subset_trans ts, ds.eq_bot]
exact { eq_bot := induced_bot (Set.inclusion_injective ts) }
refine' (t2_space_iff α).trans (forall₃_congr fun x y hne => _)
simp only [(nhds_basis_opens x).disjoint_iff (nhds_basis_opens y), exists_prop, ← exists_and_left,
    and_assoc, and_comm', and_left_comm]
simp only [t2_space_iff_disjoint_nhds, disjoint_iff, ne_bot_iff, Ne.def, not_imp_comm]
simp only [t2_space_iff_disjoint_nhds, Filter.disjoint_iff]
simp only [← exists_ultrafilter_iff, and_imp, le_inf_iff, exists_imp]
simp only [t2_space_iff_disjoint_nhds, ← is_open_compl_iff, is_open_iff_mem_nhds, Prod.forall,
    nhds_prod_eq, compl_diagonal_mem_prod, mem_compl_iff, mem_diagonal_iff]
rw [is_open_iff_ultrafilter]
refine' ⟨fun h F hF => h F.lim hF F F.le_nhds_Lim, _⟩
intro cond x hx f h
rw [← Ultrafilter.Lim_eq_iff_le_nhds.2 h] at hx
exact cond _ hx
intro x hx
have : (𝓝[s] x).ne_bot := mem_closure_iff_cluster_pt.mp (hts hx)
exact
    tendsto_nhds_unique_of_eventually_eq ((hf x hx).mono_left <| nhds_within_mono _ hst)
      ((hg x hx).mono_left <| nhds_within_mono _ hst) (h.eventually_eq_of_mem self_mem_nhds_within)
simp only [SeparatedNhds, prod_subset_compl_diagonal_iff_disjoint.symm] at hst⊢ <;>
    exact generalized_tube_lemma hs ht is_closed_diagonal.is_open_compl hst
simp [coclosed_compact, cocompact, infi_and', and_iff_right_of_imp IsCompact.is_closed]
rw [Bornology.ext_iff] <;> exact Filter.coclosed_compact_eq_cocompact
rw [← diff_inter, hO.inter_eq, diff_empty]
refine' ⟨fun h x hx y hy => _, Set.Subsingleton.is_preirreducible⟩
rw [IsIrreducible, is_preirreducible_iff_subsingleton,
    exists_eq_singleton_iff_nonempty_subsingleton]
rw [← nhds_set_singleton, disjoint_nhds_set_nhds, specializes_iff_mem_closure]
simp only [← disjoint_nhds_nhds_iff_not_specializes.not_left, Disjoint.comm]
simp only [← is_open_compl_iff, compl_set_of, ← disjoint_nhds_nhds_iff_not_specializes,
    is_open_set_of_disjoint_nhds_nhds]
simp only [← specializes_iff_inseparable, is_closed_set_of_specializes]
rw [hf.nhds_eq_comap b]
exact (closed_nhds_basis _).comap _
intro a
rw [nhds_Inf, ← infi_subtype'']
exact has_basis_infi fun t : T => @closed_nhds_basis X t (h t t.2) a
rw [inf_eq_infi]
exact regularSpaceInfi (Bool.forall_bool.2 ⟨h₂, h₁⟩)
rw [← disjoint_comap_iff surjective_mk, comap_mk_nhds_mk, comap_mk_nhds_set]
exact RegularSpace.regular (hs.preimage continuous_mk) ha
rw [← disjoint_comap_iff surjective_mk, comap_mk_nhds_set, comap_mk_nhds_set]
exact
        separated_nhds_iff_disjoint.1
          (normal_separation (hs.preimage continuous_mk) (ht.preimage continuous_mk)
            (hd.preimage mk))
apply eq_of_subset_of_subset connected_component_subset_Inter_clopen
  -- Reduce to showing that the clopen intersection is connected.
refine' IsPreconnected.subset_connected_component _ (mem_Inter.2 fun Z => Z.2.2)
  -- We do this
refine' ⟨_, comp.is_closed.closed_embedding_subtype_coe.closed_iff_image_closed.1 clopen_in_s.2⟩
let v : Set u := (coe : u → s)
rw [this, Set.range_comp, Subtype.range_coe, Subtype.image_preimage_coe]
apply Set.inter_eq_self_of_subset_left interior_subset
rw [this, image_comp coe coe, Subtype.image_preimage_coe, inter_eq_self_of_subset_left V_sub]
simp [Vx, h xt]
constructor
· intro h
    exact totally_separated_space_of_t1_of_basis_clopen loc_compact_Haus_tot_disc_of_zero_dim
apply TotallySeparatedSpace.totally_disconnected_space
rw [continuous_iff_continuous_at]
intro x
rw [ContinuousAt, nhds_induced, nhds_induced, tendsto_iff_comap, ←
        Function.Semiconj.filter_comap Units.val_inv_eq_inv_val _]
apply comap_mono
rw [← tendsto_iff_comap, Units.val_inv_eq_inv_val]
exact continuous_at_inv₀ x.ne_zero
intro x hx
simp only [add_sub_cancel]
exact mul_div_cancel_left x h
simp [mul_div_cancel' _ h]
rw [hφ.induced]
exact topological_add_group_induced φ
rw [hφ.induced, nhds_induced, map_zero]
exact (UniformOnFun.has_basis_nhds_zero 𝔖 h𝔖₁ h𝔖₂).comap φ
simp
infer_instance
rfl
constructor
· intro hc
    rw [decomp' f]
    have := hc.sub continuous_const
    exact this
· intro hc
    rw [decomp f]
    have := hc.add continuous_const
    exact this
simp only [continuous_iff_continuous_at, continuous_at_const_smul_iff]
rw [dense_iff_closure_eq] at hs⊢ <;> rw [closure_smul, hs, smul_set_univ]
intro U hU
rw [is_open_coinduced, MulAction.quotient_preimage_image_eq_union_mul U]
exact is_open_Union fun γ => (Homeomorph.smul γ).IsOpenMap U hU
apply f_op.image_mem_nhds (inter_mem ((bInter_mem bad_Γ_finite).mpr fun γ hγ => _) K₀_in)
exact (continuous_const_smul _).ContinuousAt (hu γ)
refine' ⟨fun h => _, fun h => set_smul_mem_nhds_smul h hc⟩
rw [← inv_smul_smul₀ hc x, ← inv_smul_smul₀ hc s]
exact set_smul_mem_nhds_smul h (inv_ne_zero hc)
refine' Iff.trans _ (set_smul_mem_nhds_smul_iff hc)
rw [smul_zero]
infer_instance
simp
simp
rw [← coe_one, ← coe_mul, one_mul]
rw [← coe_one, ← coe_mul, mul_one]
rw [← coe_mul, ← coe_mul, ← coe_mul, ← coe_mul, mul_assoc]
rw [← coe_add, ← coe_mul, ← coe_mul, ← coe_mul, ← coe_add, mul_add]
rw [← coe_add, ← coe_mul, ← coe_mul, ← coe_mul, ← coe_add, add_mul]
rw [← coe_zero, extension_coe hf, f.map_zero]
rw [← coe_add, extension_coe hf, extension_coe hf, extension_coe hf, f.map_add]
rw [← coe_one, extension_coe hf, f.map_one]
rw [← coe_mul, extension_coe hf, extension_coe hf, extension_coe hf, f.map_mul]
rw [← coe_mul, ← coe_mul, mul_comm]
infer_instance
rfl
rw [@ring_sep_rel α r] <;> rfl
rfl
rw [ring_sep_quot α] <;> infer_instance
rw [← coe_zero, ← coe_smul, MulActionWithZero.smul_zero r]
rw [← coe_smul, zero_smul, coe_zero]
rw [← coe_smul, ← coe_zero, zero_smul]
simp only [← coe_add, ← coe_smul, smul_add]
rw [← coe_zero, ← coe_smul, smul_zero r]
change ↑x + ↑y = ↑y + ↑x
rw [← coe_add, ← coe_add, add_comm]
rw [← coe_zero, extension_coe hf, f.map_zero]
simp [Filter.has_basis_iff, is_topological_valuation]
rw [uniformity_eq_comap_nhds_zero]
exact (has_basis_nhds_zero R Γ₀).comap _
simp only [← nhds_translation_add_neg x, ← sub_eq_add_neg, preimage_set_of_eq, exists_true_left,
    ((has_basis_nhds_zero R Γ₀).comap fun y => y - x).mem_iff]
simp only [mem_nhds, sub_zero]
refine'
            ⟨({ f with 
                  map_one' := of_not_not hf1
                  map_mul' := this } :
                ContinuousMonoidHom A B),
              ContinuousMap.ext fun _ => rfl⟩
infer_instance
dsimp [Inv.inv]
simp [if_neg x_ne, mul_hat_inv_cancel x_ne]
rw [coe_inv, inv_zero]
intro y y_ne
rw [mem_compl_singleton_iff] at y_ne
dsimp [Inv.inv]
rw [if_neg y_ne]
simp only [set_of_forall]
refine' is_closed_Inter fun i => is_closed_eq (continuous_apply _) (continuous_apply _).inv
rw [← image_inv]
exact hs.image continuous_inv
rw [← Inf_range]
exact has_continuous_inv_Inf (set.forall_range_iff.mpr h')
rw [inf_eq_infi]
refine' has_continuous_inv_infi fun b => _
cases b <;> assumption
simp [tendsto_principal_principal]
simp [tendsto_principal_principal]
simp [tendsto_principal_principal]
simp [tendsto_principal_principal]
rw [SetLike.ext'_iff] at hs⊢
simp only [Subgroup.topological_closure_coe, Subgroup.coe_top, ← dense_iff_closure_eq] at hs⊢
exact hf'.dense_image hf hs
apply map_mem_closure (TopologicalGroup.continuous_conj g) hn
exact fun m hm => Subgroup.Normal.conj_mem inferInstance m hm g
simp only [mul_one]
rw [← inv_one]
exact
    Continuous.image_connected_component_subset continuous_inv _
      ((Set.mem_image _ _ _).mp ⟨g, hg, rfl⟩)
simp
simp
rw [← @nhds_translation_mul_inv G t _ _ x, ← @nhds_translation_mul_inv G t' _ _ x, ← h]
rw [hleft]
rw [Filter.map_map]
rw [key]
rw [← Filter.map_map]
simp [this, le_refl]
rw [nhds_prod_eq]
rw [hleft x₀, hleft y₀, prod_map_map_eq, Filter.map_map]
rw [key]
rw [← Filter.map_map, ← prod_map_map_eq', map_id]
rw [Filter.map_map]
apply IsOpenMap.to_quotient_map
· exact (QuotientGroup.is_open_map_coe N).Prod (QuotientGroup.is_open_map_coe N)
· exact continuous_quot_mk.prod_map continuous_quot_mk
· exact (surjective_quot_mk _).prod_map (surjective_quot_mk _)
simp only [div_eq_mul_inv]
exact continuous_fst.mul continuous_snd.inv
rw [← bUnion_smul_set]
exact is_open_bUnion fun a _ => ht.smul _
rw [← bUnion_op_smul_set]
exact is_open_bUnion fun a _ => hs.smul _
rw [← Union_div_left_image]
exact is_open_bUnion fun a ha => is_open_map_div_left a t ht
rw [← Union_div_right_image]
exact is_open_bUnion fun a ha => is_open_map_div_right a s hs
rw [← inv_inv (closure s * t), mul_inv_rev, inv_closure, ht.inv.mul_closure, mul_inv_rev, inv_inv,
    inv_inv]
exact @TopologicalGroup.t3Space _ _ _ _ this
simp
rw [← (Homeomorph.mulLeft x).apply_symm_apply 1] at hL1
exact
        (dense_range_dense_seq G).inter_nhds_nonempty
          ((Homeomorph.mulLeft x).Continuous.ContinuousAt <| hL1)
simp only [singleton_mul, one_mul, image_id']
induction x using QuotientGroup.induction_on
exact continuous_quotient_mk.comp (continuous_mul_right x)
rw [← Inf_range]
exact topological_group_Inf (set.forall_range_iff.mpr h')
rw [inf_eq_infi]
refine' topological_group_infi fun b => _
cases b <;> assumption
cases f
cases g
congr
simp [F, Homeomorph.mul_left_symm]
change Continuous fun p : G × G => QuotientGroup.mk (p.1 * p.2)
refine' continuous_coinduced_rng.comp continuous_mul
simp only [AlgHomClass.commutes]
simp only [map_add, hx, hy]
simp only [map_mul, hx, hy]
simp only [map_star, hx]
refine' ⟨fun h => _, fun h => _⟩
· simp only [Algebra.smul_def]
    exact (h.comp continuous_fst).mul continuous_snd
· rw [algebra_map_eq_smul_one']
    exact h.comp (continuous_id.prod_mk continuous_const)
apply SetLike.ext'
simp only [Subalgebra.topological_closure_coe]
simp only [Subalgebra.coe_comap, Subsemiring.coe_comap, AlgHom.coe_to_ring_hom]
rw [w]
exact f'.preimage_closure _
rw [mem_singleton_iff] at hy hz
rw [hy, hz]
rw [nhds_eq_update, update_same]
rw [nhds_zero]
refine' has_basis_binfi_principal _ ⟨1, one_ne_zero⟩
exact directedOn_iff_directed.2 (directed_of_inf fun a b hab => Iio_subset_Iio hab)
simp [nhds_zero]
rw [nhds_eq_update, update_noteq h₀]
simp
simp [h]
rw [nhds_of_ne_zero h]
exact has_basis_pure _
rw [nhds_of_ne_zero h, tendsto_pure]
rw [is_open_iff_mem_nhds, ← and_forall_ne (0 : Γ₀)]
simp (config := { contextual := true }) [nhds_of_ne_zero, imp_iff_not_or,
    has_basis_nhds_zero.mem_iff]
simp only [← is_open_compl_iff, is_open_iff, mem_compl_iff, not_not, ← compl_Ici,
    compl_subset_compl]
rw [ContinuousAt, nhds_of_ne_zero h]
exact pure_le_nhds γ
rw [nhds_prod_eq]
rw [uncurry, hleft x₀, hright y₀, prod_map_map_eq, Filter.map_map]
rw [key, ← Filter.map_map]
rw [← Filter.map_map, ← hright, hleft y₀, Filter.map_map, key₂, ← hleft]
simp only [set_of_forall]
exact
    is_closed_Inter fun x =>
      is_closed_Inter fun y =>
        is_closed_eq (continuous_apply _) ((continuous_apply _).mul (continuous_apply _))
rw [← image_mul_prod]
exact (hs.prod ht).image continuous_mul
simp [tendsto_const_nhds]
simp only [List.map_cons, List.prod_cons]
exact
      (h f (List.mem_cons_self _ _)).mul
        (tendsto_list_prod l fun c hc => h c (List.mem_cons_of_mem _ hc))
intro x hx
rw [continuous_within_at_iff_continuous_at_restrict _ hx]
refine' tendsto_list_prod _ fun i hi => _
specialize h i hi x hx
rw [continuous_within_at_iff_continuous_at_restrict _ hx] at h
exact h
simp only [pow_succ]
exact continuous_id.mul (continuous_pow _)
simp (config := { singlePass := true }) only [← smul_one_mul q (_ : A)]
exact continuous_const.mul continuous_id
simp (config := { singlePass := true }) only [← mul_smul_one q (_ : A)]
exact continuous_id.mul continuous_const
simp only [← finprod_subtype_eq_finprod_cond]
exact continuous_finprod (fun i => hc i i.2) (hf.comp_injective Subtype.coe_injective)
rw [← Inf_range]
exact has_continuous_mul_Inf (set.forall_range_iff.mpr h')
rw [inf_eq_infi]
refine' has_continuous_mul_infi fun b => _
cases b <;> assumption
simp [ha, tsum] <;> exact some_spec ha
simp [HasSum, tendsto_const_nhds]
simp [tsum, h]
simp only [HasSum, tendsto, hg.map_at_top_finset_sum_eq hf]
rw [← Set.indicator_range_comp, Subtype.range_coe,
    has_sum_subtype_iff_of_support_subset Set.support_indicator_subset]
rw [← sum_attach]
exact has_sum_fintype _
simp
have : (g ∘ coe) ∘ e = f ∘ coe := funext he
rw [← has_sum_subtype_support, ← this, e.has_sum_iff, has_sum_subtype_support]
refine' ⟨fun h => h.tendsto_sum_nat, fun h => _⟩
rw [tendsto_nhds_unique h hf.has_sum.tendsto_sum_nat]
exact hf.has_sum
simp only [HasSum, sum_add_distrib] <;> exact hf.add hg
simp only [has_sum_zero, sum_empty, forall_true_iff]
simp (config := { contextual := true }) only [HasSum.add, sum_insert, mem_insert,
        forall_eq_or_imp, forall₂_true_iff, not_false_iff, forall_true_iff]
rw [has_sum_subtype_iff_indicator] at *
rw [Set.indicator_union_of_disjoint hs]
exact ha.add hb
rw [h]
exact this _ (Classical.choose_spec _)
rw [tsum_fintype, Finset.sum_eq_add] <;> simp
have hf : ¬Summable f := mt (hes.summable_iff_of_has_sum_iff @h).1 hg
simp [tsum, hf, hg, h0]
rw [← Set.image_univ, tsum_image f (hg.inj_on _), tsum_univ (f ∘ g)]
erw [← tsum_prod' h h₁, ← tsum_prod' h.prod_symm h₂, ← (Equiv.prodComm γ β).tsum_eq (uncurry f)]
rfl
simp [m0]
cases nonempty_encodable γ
rw [← supr_decode₂, ← tsum_supr_decode₂ _ m0 s]
exact m_supr _
rw [supr_subtype', ← Finset.tsum_subtype]
exact relSuprTsum m m0 R m_supr _
simp [HasSum, ← prod_mk_sum, Filter.Tendsto.prod_mk_nhds hf hg]
simp only [HasSum, tendsto_pi_nhds, sum_apply]
simp only [Summable, Pi.has_sum, skolem]
simp only [sub_eq_add_neg]
exact hf.add hg.neg
rw [add_sub_cancel'_right]
rw [add_comm]
rw [(has_sum_ite_eq_extract hf.has_sum b).tsum_eq]
exact (add_sub_cancel'_right _ _).symm
refine' Iff.trans _ (range k).has_sum_compl_iff
rw [← (notMemRangeEquiv k).symm.has_sum_iff]
rfl
simp [has_sum_nat_add_iff]
simp [ha]
rw [tsum_eq_zero_of_not_summable hf,
        tsum_eq_zero_of_not_summable (mt (summable_mul_left_iff ha).2 hf), mul_zero]
simp [ha]
rw [tsum_eq_zero_of_not_summable hf,
        tsum_eq_zero_of_not_summable (mt (summable_mul_right_iff ha).2 hf), zero_mul]
rw [← tsum_zero]
exact tsum_lt_tsum hg hi summable_zero hsum
rw [← has_sum_zero_iff, hf.has_sum_iff]
rw [Ne.def, tsum_eq_zero_iff hf, not_forall]
simp only [(Finset.sum_sdiff ht₁).symm, (Finset.sum_sdiff ht₂).symm, add_sub_add_right_eq_sub]
rw [summable_iff_cauchy_seq_finset, cauchy_seq_finset_iff_vanishing]
refine' Finset.sum_subset (Finset.filter_subset _ _) _
intro b hbt hb
simp only [(· ∉ ·), Finset.mem_filter, and_iff_right hbt] at hb
exact (h b).resolve_right hb
simp
simp
rw [← tsum_subtype_add_tsum_subtype_compl hf s]
simp only [Finset.tsum_subtype', add_right_inj]
rfl
rw [← Nat.cofinite_eq_at_top]
exact hf.tendsto_cofinite_zero
simp only [h1, h2]
simp only [summable_neg_iff, summable_subtype_and_compl]
refine' le_of_tendsto (tendsto_const_nhds.dist ha) (eventually_at_top.2 ⟨n, fun m hnm => _⟩)
refine' le_trans (dist_le_Ico_sum_of_dist_le hnm fun k _ _ => hf k) _
rw [sum_Ico_eq_sum_range]
refine' sum_le_tsum (range _) (fun _ _ => le_trans dist_nonneg (hf _)) _
exact hd.comp_injective (add_right_injective n)
rw [summable_mul_prod_iff_summable_mul_sigma_antidiagonal] at h
conv => 
    congr
    ext
    rw [← Finset.sum_finset_coe, ← tsum_fintype]
exact h.sigma' fun n => (has_sum_fintype _).Summable
have : UniformContinuous fun x => 1 / f x := uniform_continuous_const.div hf
simp_all
simp [Filter.map_map, (· ∘ ·)] <;> exact filter.map_id.symm
      _ ≤ (𝓤 α).map fun x : α × α => (x.1 * a, x.2 * a)
rw [← Inf_range]
exact uniform_group_Inf (set.forall_range_iff.mpr h')
rw [inf_eq_infi]
refine' uniform_group_infi fun b => _
cases b <;> assumption
rw [← comap_swap_uniformity, uniformity_eq_comap_nhds_one, comap_comap, (· ∘ ·)]
rfl
refine' uniform_space_eq _
change @uniformity _ u = @uniformity _ v
rw [@uniformity_eq_comap_nhds_one _ u _ hu, @uniformity_eq_comap_nhds_one _ v _ hv, h]
rw [uniformity_eq_comap_nhds_one]
exact Filter.comap.is_countably_generated _ _
rw [← comap_uniformity_mul_opposite, uniformity_eq_comap_nhds_one, ← op_one, ← comap_unop_nhds,
    comap_comap, comap_comap]
simp [(· ∘ ·)]
rw [← comap_swap_uniformity, uniformity_eq_comap_inv_mul_nhds_one, comap_comap, (· ∘ ·)]
rfl
rw [uniformity_eq_comap_nhds_one]
exact h.comap _
rw [uniformity_eq_comap_inv_mul_nhds_one]
exact h.comap _
rw [uniformity_eq_comap_nhds_one_swapped]
exact h.comap _
rw [uniformity_eq_comap_inv_mul_nhds_one_swapped]
exact h.comap _
rw [this.closure_eq_preimage_closure_image, uniformity_eq_comap_nhds_one α, sInter_comap_sets]
simp [mem_closure_iff_nhds, inter_singleton_nonempty, sub_eq_add_neg, add_assoc]
simp only [map_div]
simp [← preimage_smul_inv, preimage]
refine' map_le_iff_le_comap.1 (le_trans _ (pure_le_nhds 1)) <;>
      simp (config := { contextual := true }) [Set.subset_def]
exists V, V_nhds <;> rfl
apply CompactSpace.uniform_continuous_of_continuous
exact continuous_div'
have :=
      tendsto.prod_mk (tendsto_sub_comap_self de x₀)
        (tendsto_const_nhds : tendsto (fun p : β × β => y₁) (comap ee <| 𝓝 (x₀, x₀)) (𝓝 y₁))
rw [nhds_prod_eq, prod_comap_comap_eq, ← nhds_prod_eq]
exact (this : _)
show Continuous (Φ ∘ Prod.swap)
exact hφ.comp continuous_swap
rw [← @UniformGroup.to_uniform_space_eq _ us _ _] at hG
infer_instance
simp
simp only [N, one_mul, map_id']
simp [mul_assoc]
rw [B.nhds_eq]
simp only [N, one_mul]
exact map_id
rw [B.nhds_eq]
apply B.has_basis
rw [B.nhds_one_eq]
exact B.to_filter_basis.has_basis
rw [B.nhds_one_has_basis.mem_iff]
exact ⟨U, hU, rfl.subset⟩
simp only [inducing_embed_product.continuous_iff, embed_product_apply, (· ∘ ·),
    continuous_prod_mk, op_homeomorph.symm.inducing.continuous_iff, op_homeomorph_symm_apply,
    unop_op]
simp only [image_univ, h_dense.closure_eq, univ_mem]
rw [sub_add_cancel b x]
rw [div_self hx₀]
rw [← mul_div_assoc', div_self (ne_of_lt <| abs_pos.2 hx₀).symm, mul_one]
rw [nhds_prod_eq]
rw [uncurry, nhds_eq_map_mul_left_nhds_one hx₀, nhds_eq_map_mul_right_nhds_one hy₀,
          prod_map_map_eq, Filter.map_map]
rw [key, ← Filter.map_map]
rw [← Filter.map_map, ← nhds_eq_map_mul_right_nhds_one hy₀,
          nhds_eq_map_mul_left_nhds_one hy₀, Filter.map_map, key₂, ←
          nhds_eq_map_mul_left_nhds_one hxy]
simp only [div_eq_mul_inv]
exact mul_zero a ▸ h.mul (tendsto_inv_at_top_zero.comp hg)
simp [tendsto_const_mul_pow_nhds_iff', hc]
simp [comap_comap, inv_mul_cancel hx.ne.symm, comap_id, one_mul_eq_id]
let S := s
rw [this]
exact IsClosed.inter hs is_closed_Icc
refine' subset.antisymm set_of_is_preconnected_subset_of_ordered _
simp only [subset_def, -mem_range, forall_range_iff, uncurry, or_imp, forall_and, mem_union,
    mem_set_of_eq, insert_eq, mem_singleton_iff, forall_eq, forall_true_iff, and_true_iff,
    is_preconnected_Icc, is_preconnected_Ico, is_preconnected_Ioc, is_preconnected_Ioo,
    is_preconnected_Ioi, is_preconnected_Iio, is_preconnected_Ici, is_preconnected_Iic,
    is_preconnected_univ, is_preconnected_empty]
cases le_total (f a) (f b) <;> simp [*, is_preconnected_interval.intermediate_value]
simp only [← Ici_diff_left, continuous_within_at_diff_self]
rw [← nhds_within_union, Iic_union_Ici, nhds_within_univ]
rw [← nhds_within_union, Iio_union_Ici, nhds_within_univ]
rw [← nhds_within_union, Iic_union_Ioi, nhds_within_univ]
rw [← nhds_within_union, Iio_union_Ioi]
simp only [ContinuousWithinAt, ContinuousAt, ← tendsto_sup, nhds_left_sup_nhds_right]
rw [continuous_within_at_Ioi_iff_Ici, continuous_within_at_Iio_iff_Iic,
    continuous_at_iff_continuous_left_right]
refine' ⟨fun f s h => _⟩
simp only [is_lub_pi, ← range_restrict] at h
exact tendsto_pi_nhds.2 fun i => tendsto_at_top_is_lub ((monotone_eval _).restrict _) (h i)
rw [h'α.topology_eq_generate_intervals] at h
simp [left_lim, ite_eq_left_iff, h]
apply le_antisymm (left_lim_le hf (le_refl _))
rw [h]
exact le_right_lim hf (le_refl _)
apply StrictMonoOn.inj_on
intro x hx y hy hxy
calc
      f x < z x := (hz x hx).1
      _ ≤ f y := (hz x hx).2 y hxy
      
  -- show that `f s` is countable
rw [floor_int_cast]
exact (lt_add_one _).le
rw [ceil_int_cast]
exact (sub_one_lt _).le
rw [← nhds_within_univ]
exact tendsto_nhds_within_mono_right (subset_univ _) (tendsto_floor_left n)
rw [← nhds_within_univ]
exact tendsto_nhds_within_mono_right (subset_univ _) (tendsto_ceil_right n)
simp [uncurry, hf]
have := @continuous_on_Ico_extend_from_Ioo α
simp [hpt, hab]
simp only [← Icc_bot_top, is_compact_Icc]
rw [h.image_Icc (nonempty_Icc.mp (Set.nonempty_of_mem hc))]
exact
    cInf_le bdd_below_Icc
      (mem_Icc.mpr
        ⟨cInf_le (is_compact_Icc.bdd_below_image h) ⟨c, hc, rfl⟩,
          le_cSup (is_compact_Icc.bdd_above_image h) ⟨c, hc, rfl⟩⟩)
rw [h.image_Icc (nonempty_Icc.mp (Set.nonempty_of_mem hc))]
exact
    le_cSup bdd_above_Icc
      (mem_Icc.mpr
        ⟨cInf_le (is_compact_Icc.bdd_below_image h) ⟨c, hc, rfl⟩,
          le_cSup (is_compact_Icc.bdd_above_image h) ⟨c, hc, rfl⟩⟩)
refine' mem_nhds_within_of_mem_nhds _
rw [← mem_interior_iff_mem_nhds, interior_compl]
exact disjoint_left.1 hd ha
rw [interval_of_ge (hx.2.trans this).le]
exact ⟨hx.2.le, this.le⟩
rw [← nhds_left_sup_nhds_right, mem_sup]
exact
    ⟨compl_section_ord_separating_set_mem_nhds_within_Iic hd ha,
      compl_section_ord_separating_set_mem_nhds_within_Ici hd ha⟩
rw [← mem_interior_iff_mem_nhds, interior_compl]
exact disjoint_left.1 hd hx
simp
refine' infi_eq_of_forall_ge_of_forall_gt_exists_lt (fun i => x_le i) _
apply fun w x_lt_w => ‹Filter.NeBot F›.nonempty_of_mem (eventually_lt_of_tendsto_lt x_lt_w as_lim)
rw [this, add_zero]
exact hle _ le_rfl
simp
dsimp only [eval₂_eq_sum, Finsupp.sum]
exact continuous_finset_sum _ fun c hc => continuous_const.mul (continuous_pow _)
rw [eq_C_of_degree_le_zero (le_of_not_gt hp0)] <;> simp
rw [card_map, hs.2]
refine' Set.Subset.trans (Set.prod_mono _ _) ‹_› <;> simp
simp
infer_instance
infer_instance
infer_instance
infer_instance
rw [← @Inf_singleton _ _ ‹TopologicalSpace M›]
exact
        continuous_Inf_rng.2 fun t ht =>
          continuous_Inf_dom₂ (Eq.refl _) ht
            (@HasContinuousSmul.continuous_smul _ _ _ _ t (h t ht))
rw [inf_eq_infi]
refine' has_continuous_smul_infi fun b => _
cases b <;> assumption
intro h
apply y_ne
rw [h, v.map_zero] at key
exact v.zero_iff.1 key.symm
rw [decomp]
rw [map_inv₀, map_inv₀]
rw [mul_assoc, mul_comm, key, mul_assoc, mul_inv_rev]
rw [Valuation.map_sub_swap]
infer_instance
rw [Valuation.map_one]
exact zero_ne_one.symm
intro x
simp only [mul_assoc, mul_inv_cancel h, mul_one]
intro x
simp only [mul_assoc, inv_mul_cancel h, mul_one]
rw [mul_assoc, inv_mul_cancel z₀_ne, mul_one]
rw [this, one_mul]
refine' completion.dense_inducing_coe.extend_eq_of_tendsto _
rw [← completion.dense_inducing_coe.nhds_eq_comap]
exact valued.continuous_valuation.continuous_at
rw [← v.map_zero, ← Valued.extension_extends (0 : K)]
rfl
rw [← completion.coe_one, Valued.extension_extends (1 : K)]
exact Valuation.map_one _
simp
rw [strong_topology, UniformAddGroup.to_uniform_space_eq] <;> rfl
rw [smul_eq_mul 𝕜, mul_assoc, inv_mul_cancel hξ0, mul_one] at this
exact not_mem_compl_iff.mpr (mem_singleton ξ₀) ((balanced_core_subset _) this)
      -- For that, we use that `𝓑` is balanced : since `‖ξ₀‖ < ε < ‖ξ‖`, we have `‖ξ₀ / ξ‖ ≤ 1`,
      -- hence `ξ₀ = (ξ₀ / ξ) • ξ ∈ 𝓑` because `ξ ∈ 𝓑`.
rw [zero_smul]
rw [← LinearMap.ker_eq_bot]
exact Submodule.ker_liftq_eq_bot _ _ _ (le_refl _)
rw [← LinearMap.range_eq_top, Submodule.range_liftq]
exact eq_top_of_finrank_eq ((finrank_self 𝕜).symm ▸ this)
rw [hlφ]
exact this.comp continuous_quot_mk
    -- The pullback
refine'
        unique_topology_of_t2 (topological_add_group_induced φ.symm.to_linear_map)
          (has_continuous_smul_induced φ.symm.to_linear_map) _
rw [t2_space_iff]
exact fun x y hxy =>
        @separated_
rw [mem_interior_iff_mem_nhds]
exact mem_of_superset (hs₁.mem_nhds hx) hs₃
rw [← s_dim]
exact (finrank_eq_card_basis b).symm
infer_instance
intro f
have Z := f.finrank_range_add_finrank_ker
rw [finrank_eq_card_basis ξ, hn] at Z
have : finrank 𝕜 f.range = 1 :=
            le_antisymm (finrank_self 𝕜 ▸ f.range.finrank_le) (zero_lt_iff.mpr H)
rw [this, add_comm, Nat.add_one] at Z
exact Nat.succ.inj Z
rw [← to_multilinear_map_inj.eq_iff, MultilinearMap.ext_iff] <;> rfl
rw [inf_eq_infi]
refine' locally_convex_space_infi fun b => _
cases b <;> assumption
rw [← sub_self a₀]
exact tendsto_id.sub tendsto_const_nhds
rw [← sub_self m₀]
exact tendsto_id.sub tendsto_const_nhds
rw [embedding_subtype_coe.to_inducing.continuous_iff]
exact continuous_fst.smul (continuous_subtype_coe.comp continuous_snd)
simp [closure_prod_eq]
rw [← SetLike.coe_set_eq, dense_iff_closure_eq]
simp
simp only [Set.set_of_forall]
exact
    is_closed_Inter fun c =>
      is_closed_Inter fun x => is_closed_eq (continuous_apply _) ((continuous_apply _).const_smul _)
intro f g H
cases f
cases g
congr
simp only [RingHom.id_apply, ContinuousLinearMap.map_smulₛₗ]
rw [SetLike.ext'_iff] at hs⊢
simp only [Submodule.topological_closure_coe, Submodule.top_coe, ← dense_iff_closure_eq] at hs⊢
exact hf'.dense_image f.continuous hs
rw [← coe_id, coe_inj]
simp only [← coe_coe, coe_sum, LinearMap.coe_fn_sum]
simp only [coe_sum', Finset.sum_apply]
simp only [ext_ring_iff, smul_right_apply, one_apply, one_smul]
simp only [ext_iff, pi_apply, Function.funext_iff]
exact forall_swap
simp [h (f₁ x)]
simp
simp [h y]
simp
simp [hx]
simp only [← coe_inj, LinearMap.prod_ext_iff]
rfl
rw [← smul_eq_mul, map_smul, h, map_smul]
rw [e.symm.image_eq_preimage, e.symm_symm]
simp only [ContinuousLinearMap.comp_apply, symm_apply_apply, coe_coe]
simp only [ContinuousLinearMap.comp_apply, apply_symm_apply, coe_coe]
simp
simp
rw [f.inv_val]
simp
rw [f.val_inv]
simp
simp
simp
rw [← smul_eq_mul, ← map_smul, smul_eq_mul, mul_one, symm_apply_apply]
rw [← smul_eq_mul, ← map_smul, smul_eq_mul, mul_one, apply_symm_apply]
simp
simp
simp
simp [h x]
simp [this, h₁]
simp only [zero_apply, eq_zero_of_bot_submodule x]
simp
constructor
have quot : QuotientMap fun au : R × M => (au.1, S.mkq au.2) :=
    IsOpenMap.to_quotient_map (is_open_map.id.prod S.is_open_map_mkq)
      (continuous_id.prod_map continuous_quot_mk)
      (function.surjective_id.prod_map <| surjective_quot_mk _)
rw [quot.continuous_iff]
exact continuous_quot_mk.comp continuous_smul
rw [← tendsto_pi_nhds, Embedding.tendsto_nhds_iff (Embedding hB)]
infer_instance
rw [← hf]
exact Submodule.topological_closure_mono (le_graph_of_le hfg)
refine' exists_unique_of_exists_of_unique hf fun _ _ hy₁ hy₂ => eq_of_eq_graph _
rw [← hy₁, ← hy₂]
simp [closure, hf]
simp [closure, hf]
rw [closure_def hf]
exact hf.some_spec
refine' le_of_le_graph _
rw [← (hg.le_is_closable h).graph_closure_eq_closure_graph]
rw [← hg.graph_closure_eq_closure_graph]
exact Submodule.topological_closure_mono (le_graph_of_le h)
rw [IsClosed, ← hf.graph_closure_eq_closure_graph]
exact f.graph.is_closed_topological_closure
simp
simp only [Subsingleton.elim x 0, map_zero]
simp [Set.eq_of_mem_singleton h₀]
simp only [union_zero, Set.set_of_forall]
exact
    is_closed_Inter fun x =>
      is_closed_Inter fun y =>
        is_closed_eq (eval_continuous _) <| (eval_continuous _).mul (eval_continuous _)
rw [mul_sub, sub_eq_zero, mul_one, ← map_mul φ, one_mul]
simp only [map_mul φ, h₂, mul_zero]
simp only [AlgHomClass.commutes, Algebra.id.map_eq_id, RingHom.id_apply]
change UniformContinuous fun m => MulOpposite.op c
have : _ = (_ : completion X → completion X) :=
      map_comp (uniform_continuous_const_smul m) (uniform_continuous_const_smul n)
refine' Eq.trans _ (congr_fun this.symm x)
exact congr_arg (fun f => completion.map f x) (funext (smul_assoc _ _))
rw [← coe_smul, one_smul]
simp only [← coe_smul, mul_smul]
rw [mulTsupport, closure_empty_iff, mul_support_eq_empty_iff]
rfl
rw [has_compact_mul_support_def, Function.mul_support_comp_eq_preimage]
refine' is_compact_of_is_closed_subset (hg.is_compact_preimage hf) is_closed_closure _
rw [hg.to_embedding.closure_eq_preimage_closure_image]
exact preimage_mono (closure_mono <| image_preimage_subset _ _)
apply hf.comp₂_left hf' (mul_one 1)
rw [inter_assoc] at hz
exact mem_of_mem_inter_left hz
simp [eventually_nhds_within_iff, not_and']
simp [mem_closure_iff_frequently, frequently_nhds_within_iff]
refine' ⟨fun h => _, fun h => (eventually_nhds_nhds_within.2 h).filter_mono inf_le_left⟩
simp only [eventually_nhds_within_iff] at h⊢
exact h.mono fun x hx hxs => (hx hxs).self_of_nhds hxs
rw [nhdsWithin, principal_univ, inf_top_eq]
rw [nhdsWithin, diff_eq, diff_eq, ← inf_principal, ← inf_assoc]
exact inter_mem_inf hs (mem_principal_self _)
rw [← nhds_within_univ]
apply nhds_within_le_of_mem
exact univ_mem
rw [nhds_within_restrict' t hs, nhds_within_restrict' u hs, h₂]
rw [nhds_within_restrict t h₀ h₁, nhds_within_restrict u h₀ h₁, h₂]
rw [← ht.nhds_within_eq h]
exact preimage_nhds_within_coinduced' h ht hs
rw [nhdsWithin, principal_empty, inf_bot_eq]
delta nhdsWithin
rw [← inf_sup_left, sup_principal]
delta nhdsWithin
rw [inf_left_comm, inf_assoc, inf_principal, ← inf_assoc, inf_idem]
delta nhdsWithin
rw [← inf_principal, inf_assoc]
rw [nhds_within_inter, inf_eq_right]
exact nhds_within_le_of_mem h
rw [nhdsWithin, principal_singleton, inf_eq_right.2 (pure_le_nhds a)]
rw [← singleton_union, nhds_within_union, nhds_within_singleton]
simp
simp [mem_of_superset h]
simp only [nhdsWithin, mem_inf_principal, mem_compl_iff, mem_singleton_iff, or_iff_not_imp_left,
    insert_def]
rw [← nhds_within_singleton, ← nhds_within_union, compl_union_self, nhds_within_univ]
delta nhdsWithin
rw [nhds_prod_eq, ← Filter.prod_inf_prod, Filter.prod_principal_principal]
rw [nhds_within_prod_eq]
exact prod_mem_prod hu hv
simp only [nhdsWithin, nhds_pi, Filter.pi, comap_inf, comap_infi, pi_def, comap_principal, ←
    infi_principal_finite hI, ← infi_inf_eq]
simp only [nhdsWithin, nhds_pi, Filter.pi, pi_def, ← infi_principal_finite hI, comap_inf,
    comap_principal, eval]
rw [infi_split _ fun i => i ∈ I, inf_right_comm]
simp only [infi_inf_eq]
simp only [nhdsWithin, nhds_pi, pi_inf_principal_pi_eq_bot]
simp [ne_bot_iff, nhds_within_pi_eq_bot]
rw [comap_principal, Set.preimage_image_eq _ Subtype.coe_injective]
simp only [mem_closure_iff_nhds_within_ne_bot, nhds_within_pi_ne_bot]
simp only [dense_iff_closure_eq, closure_pi_set, pi_congr rfl fun i hi => (hs i hi).closure_eq,
    pi_univ]
rw [nhdsWithin, nhds_subtype, principal_subtype, ← comap_inf, ← nhdsWithin]
rw [nhds_within_eq_map_subtype_coe a.coe_prop, mem_map, preimage_image_eq _ Subtype.coe_injective,
    Subtype.coe_eta]
simp only [mem_nhds_subtype_iff_nhds_within, Subtype.image_preimage_coe, inter_mem_iff,
    self_mem_nhds_within, and_true_iff]
simp only [tendsto, nhds_within_eq_map_subtype_coe h, Filter.map_map, restrict]
rw [ContinuousAt, ContinuousWithinAt, nhds_within_univ]
unfold ContinuousWithinAt at *
rw [nhds_within_prod_eq, Prod.map, nhds_prod_eq]
exact hf.prod_map hg
simp only [ContinuousOn, ContinuousWithinAt, tendsto_nhds, mem_nhds_within]
rw [continuous_on_iff'] at h₂⊢
intro t ht
exact h₂ t (h₁ t ht)
intro t
rw [is_closed_induced_iff, Set.restrict_eq, Set.preimage_comp]
simp only [Subtype.preimage_coe_eq_preimage_coe_iff, eq_comm]
simp [continuous_iff_continuous_at, ContinuousOn, ContinuousAt, ContinuousWithinAt,
    nhds_within_univ]
simp [ContinuousWithinAt, nhds_within_restrict'' s h]
simp [ContinuousWithinAt, nhds_within_restrict' s h]
simp only [ContinuousWithinAt, nhds_within_union, tendsto_sup]
simp only [ContinuousWithinAt, nhds_within_singleton, tendsto_pure_nhds]
simp only [← singleton_union, continuous_within_at_union, continuous_within_at_singleton,
    true_and_iff]
simp only [diff_union_self, subset_union_left]
rw [compl_eq_univ_diff, continuous_within_at_diff_self, continuous_within_at_univ]
rw [← continuous_within_at_diff_self, ContinuousWithinAt, Function.update_same]
rw [← continuous_within_at_univ, continuous_within_at_update_same, compl_eq_univ_diff]
rw [← image_univ]
exact (hf.restrict is_open_univ).continuous_on_image_of_left_inv_on fun x _ => hleft x
intro x hx
unfold ContinuousWithinAt
have A := (h x (h₁ hx)).mono h₁
unfold ContinuousWithinAt at A
rw [← h' hx] at A
exact A.congr' h'.eventually_eq_nhds_within.symm
rw [← univ_inter s, continuous_within_at_inter h, continuous_within_at_univ]
rw [continuous_iff_continuous_on_univ] at h
exact h.mono (subset_univ _)
rw [continuous_iff_continuous_on_univ] at *
exact hg.comp hf fun x _ => hs x
rw [ContinuousWithinAt, hx, tendsto_congr' h, ContinuousWithinAt]
rw [interior_inter, hs.interior_eq]
rw [preimage_inter, inter_assoc, inter_left_comm _ s, ← inter_assoc s s, inter_self]
rw [nhdsWithin, map_inf hf.inj, hf.map_nhds_eq, map_principal, ← nhds_within_inter',
    inter_eq_self_of_subset_right (image_subset_range _ _)]
rw [hf.to_embedding.map_nhds_within_eq, image_preimage_eq_inter_range]
apply nhds_within_eq_nhds_within (mem_range_self _) hf.open_range
rw [inter_assoc, inter_self]
intro hx
rw [mem_closure_iff_nhds_within_ne_bot, ne_bot_iff, not_not] at hx
rw [ContinuousWithinAt, hx]
exact tendsto_bot
intro x hx
rw [continuous_iff_continuous_on_univ]
apply ContinuousOn.if' <;> simp [*] <;> assumption
rw [continuous_iff_continuous_on_univ]
apply ContinuousOn.if <;> simp <;> assumption
rw [closure_eq_self_union_frontier, inter_union_distrib_left, inter_union_distrib_left,
    ite_inter_self, ite_inter_of_inter_eq _ ht]
simp only [← Subtype.preimage_coe_eq_preimage_coe_iff,
    ht.is_open_map_subtype_coe.preimage_frontier_eq_frontier_preimage continuous_subtype_coe,
    Subtype.preimage_coe_inter_self]
rw [le_cofinite_iff_compl_singleton_mem]
intro x
change {x}
rw [is_bounded_def, is_cobounded_def, compl_compl]
rw [is_bounded_def, compl_empty]
exact univ_mem
rw [is_bounded_def]
exact le_cofinite _ (finite_singleton x).compl_mem_cofinite
simp only [← is_cobounded_compl_iff, compl_union, is_cobounded_inter]
rw [is_bounded_def, ← Filter.mem_sets, of_bounded_cobounded_sets, Set.mem_setOf_eq, compl_compl]
simp only [← is_cobounded_compl_iff, compl_Union, is_cobounded_bInter hs]
rw [sUnion_eq_bUnion, is_bounded_bUnion hs]
rw [← sUnion_range, is_bounded_sUnion (finite_range s), forall_range_iff]
rw [← is_bounded_univ, is_bounded_def, compl_univ, empty_mem_iff_bot]
simp [← cobounded_eq_bot_iff, cobounded_prod]
simp [← cobounded_eq_bot_iff, cobounded_pi]
rw [← is_bounded_univ, is_bounded_induced, image_univ]
rw [bounded_space_induced_iff, Subtype.range_coe_subtype]
cases f
cases g
congr
rw [← comp_apply, h, comp_apply]
rw [inter_comm]
exact K i
rw [inter_comm]
exact K i
rw [inter_comm]
exact h3 hj hi hk
intro x hx
simp only [IsConnected, ← univ_pi_nonempty_iff, forall_and, and_congr_right_iff]
refine' fun hne => ⟨fun hc i => _, is_preconnected_univ_pi⟩
rw [← eval_image_univ_pi hne]
exact hc.image _ (continuous_apply _).ContinuousOn
simp [Classical.em]
simp
simp
simp [connected_component_in_eq_image hx, mem_connected_component, hx]
rw [mem_preimage]
exact hxs
rw [← h]
exact is_preconnected_connected_component
rw [univ_eq_empty_iff.mpr hα]
exact is_preconnected_empty
rw [← h (Classical.choice hα)]
exact is_preconnected_connected_component
rw [← univ_prod_univ]
exact is_preconnected_univ.prod is_preconnected_univ
rw [← pi_univ univ]
exact is_preconnected_univ_pi fun i => is_preconnected_univ
infer_instance
rw [← compl_compl s, h2, compl_empty]
simp only [nonempty_iff_ne_empty, Ne.def, frontier_eq_empty_iff, not_or]
intro t' ht'
apply is_preconnected_iff_subset_of_disjoint_closed.1 (connected_fibers t').2 u v hu hv
· exact subset.trans (hf.preimage_subset_preimage_iff.2 (singleton_subset_iff.2 ht')) huv
rw [uv_disj.inter_eq, inter_empty]
refine' Disjoint.of_preimage hf _
rw [T₁_u, T₂_v, disjoint_iff_inter_eq_empty, ← inter_inter_distrib_left, uv_disj.inter_eq,
      inter_empty]
  -- Now we do cases on whether (connected_component t) is a subset of T₁ or T₂ to show
  -- that the preimage is a subset of u or v.
exact subset.trans (subset.trans this T₁_u.1) (inter_subset_right _ _)
exact subset.trans (subset.trans this T₂_v.1) (inter_subset_right _ _)
rw [← hf.preimage_connected_component h_fibers, image_preimage_eq _ hf.surjective]
rw [is_open_iff_mem_nhds]
intro y hy
rw [connected_component_in_eq hy]
exact
    connected_component_in_mem_nhds
      (is_open_iff_mem_nhds.mp hF y <| connected_component_in_subset F x hy)
rw [← connected_component_in_univ]
exact is_open_univ.connected_component_in
constructor
· intro h
    exact fun F hF x _ => hF.connectedComponentIn
· intro h
    rw [locally_connected_space_iff_open_connected_subsets]
    refine' fun x U hU =>
        ⟨connectedComponentIn (interior U) x,
          (connected_component_in_subset _ _).trans interior_subset, h _ is_open_interior x _,
          mem_connected_component_in _, is_connected_connected_component_in_iff.mpr _⟩ <;>
      exact mem_interior_iff_mem_nhds.mpr hU
rw [locally_connected_space_iff_connected_subsets]
trace
    "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr ∀ x, (_ : exprProp())]]"
exact filter.has_basis_self.symm
rw [locally_connected_space_iff_connected_basis]
exact fun x =>
    (hbasis x).to_has_basis
      (fun i hi => ⟨b x i, ⟨(hbasis x).mem_of_mem hi, hconnected x i hi⟩, subset_rfl⟩) fun s hs =>
      ⟨(hbasis x).index s hs.1, ⟨(hbasis x).property_index hs.1, (hbasis x).set_index_subset hs.1⟩⟩
rw [totally_disconnected_space_iff_connected_component_subsingleton]
apply forall_congr' fun x => _
rw [subsingleton_iff_singleton]
exact mem_connected_component
intro t hts ht x x_in y y_in
trivial
simp only [connected_components_preimage_singleton, preimage_Union₂, image_eq_Union]
rw [totally_disconnected_space_iff_connected_component_singleton]
refine' connected_components.surjective_coe.forall.2 fun x => _
rw [← connected_components.quotient_map_coe.image_connected_component, ←
    connected_components_preimage_singleton, image_preimage_eq _ ConnectedComponents.surjective_coe]
refine' connected_components.surjective_coe.forall.2 fun y => _
rw [connected_components_preimage_singleton]
exact is_connected_connected_component
unfold IsPreconnected
apply (continuous_on_indicator_iff_clopen _ _).mpr ⟨_, _⟩
· exact continuous_subtype_coe.is_open_preimage u u_op
· rw [preimage_subtype_coe_eq_compl hsuv H]
      exact (continuous_subtype_coe.is_open_preimage v v_op).is_closed_compl
rw [hg x]
simp only [symm_comp_self, inducing_id]
simp only [self_comp_symm, QuotientMap.id]
simp [hf.continuous_iff, continuous_subtype_coe]
rw [← image_symm] <;> exact h.symm.is_compact_image
rw [← h.comap_cocompact, map_comap_of_surjective h.surjective]
rw [← image_univ_of_surjective h.surjective, h.is_compact_image]
apply CompactSpace.is_compact_univ
rw [← preimage_symm, is_open_preimage]
simp only [← is_open_compl_iff, ← preimage_compl, is_open_preimage]
rw [← preimage_symm, is_closed_preimage]
rw [← preimage_symm, preimage_closure]
rw [← preimage_symm, preimage_interior]
simp
rw [h.symm.map_nhds_eq, h.symm_apply_apply]
rw [h.nhds_eq_comap, h.apply_symm_apply]
simp
refine' ⟨_, fun hf => h.is_open_map.comp hf⟩
intro hf
rw [← Function.comp.left_id f, ← h.symm_comp_self, Function.comp.assoc]
exact h.symm.is_open_map.comp hf
refine' ⟨_, fun hf => hf.comp h.is_open_map⟩
intro hf
rw [← Function.comp.right_id f, ← h.self_comp_symm, ← Function.comp.assoc]
exact hf.comp h.symm.is_open_map
apply Continuous.prod_mk <;> exact continuous_pi fun j => continuous_apply j
rw [coe_injective.compl_image_eq, compl_range_coe]
induction x using Alexandroff.rec <;> simp
rw [← mem_compl_iff, compl_range_coe, mem_singleton_iff]
simp
simp [is_open_def, h]
simp only [is_open_iff_of_mem' h, is_closed_compl_iff, and_comm]
simp [is_open_def, h]
rw [← is_open_compl_iff, is_open_iff_of_mem (mem_compl h), ← preimage_compl, compl_compl]
rw [is_open_iff_of_not_mem infty_not_mem_image_coe, preimage_image_eq _ coe_injective]
rw [is_open_iff_of_mem, ← preimage_compl, compl_compl, preimage_image_eq _ coe_injective]
exact infty_not_mem_image_coe
rw [← is_open_compl_iff, is_open_compl_image_coe]
rw [← compl_range_coe, is_closed_compl_iff]
exact is_open_range_coe
rw [nhds_within_compl_infty_eq]
infer_instance
rw [← nhds_within_compl_infty_eq, nhds_within_compl_singleton_sup_pure]
rw [nhds_infty_eq]
exact (has_basis_coclosed_compact.map _).sup_pure _
simp [nhds_infty_eq, comap_sup, comap_map coe_injective]
simp only [has_basis_nhds_infty.ge_iff, and_imp]
simp only [le_nhds_infty, ← compl_image_coe, Ultrafilter.mem_coe,
    Ultrafilter.compl_mem_iff_not_mem]
simp [nhds_infty_eq, and_comm']
simp only [tendsto_pure_left, has_basis_coclosed_compact.tendsto_left_iff, forall_and,
      and_assoc', exists_prop]
simp only [has_basis_coclosed_compact.tendsto_left_iff, exists_prop, and_assoc']
rw [ContinuousAt, nhds_coe_eq, tendsto_map'_iff, ContinuousAt]
rw [DenseRange, ← compl_infty]
exact dense_compl_singleton _
induction x using Alexandroff.rec <;> induction y using Alexandroff.rec <;>
    simp [not_inseparable_infty_coe, not_inseparable_coe_infty, coe_eq_coe]
rw [nhds_infty_eq]
exact (tendsto_map.mono_left cocompact_le_coclosed_compact).mono_right le_sup_left
induction z using Alexandroff.rec
· exact is_closed_infty
· rw [← image_singleton, is_closed_image_coe]
      exact ⟨is_closed_singleton, is_compact_singleton⟩
simp only [inf_edist, le_infi_iff]
simp only [Ennreal.infi_add]
rw [add_comm]
exact inf_edist_le_inf_edist_add_edist
simp
simp only [one_mul, inf_edist_le_inf_edist_add_edist, forall₂_true_iff]
rw [add_assoc, Ennreal.add_halves]
rw [← inf_edist_closure]
exact inf_edist_zero_of_mem h
rw [mem_closure_iff_inf_edist_zero, pos_iff_ne_zero]
rw [inf_edist_closure, inf_edist_pos_iff_not_mem_closure]
simp only [inf_edist, infi_image, hΦ.edist_eq]
simp only [Union_subset_iff, F_subset, forall_const]
rw [Hausdorff_edist]
simp only [Hausdorff_edist_def, sup_idem, Ennreal.supr_eq_zero]
exact fun x hx => inf_edist_zero_of_mem hx
unfold Hausdorff_edist <;> apply sup_comm
simp only [Hausdorff_edist, sup_le_iff, supr_le_iff]
exact ⟨H1, H2⟩
rw [Hausdorff_edist_def]
refine' le_trans _ le_sup_left
exact le_supr₂ x h
simp [Ennreal.add_halves, add_comm, add_left_comm]
simp only [Hausdorff_edist_def, supr_image, inf_edist_image h]
simp [Hausdorff_edist_comm, add_comm]
simp only [Hausdorff_edist_def, Ennreal.sup_eq_zero, Ennreal.supr_eq_zero, ←
        mem_closure_iff_inf_edist_zero, subset_def]
rw [Hausdorff_edist_zero_iff_closure_eq_closure, closure_closure]
simp [Hausdorff_edist_comm]
simp
simp [@Hausdorff_edist_comm _ _ s _]
simp
rw [Hausdorff_edist_zero_iff_closure_eq_closure, hs.closure_eq, ht.closure_eq]
simp [inf_dist]
simp [inf_dist]
simp [inf_edist_zero_of_mem h, inf_dist]
simp [inf_dist, inf_edist, dist_edist]
rw [dist_edist, inf_dist, Ennreal.to_real_le_to_real (inf_edist_ne_top ⟨_, h⟩) (edist_ne_top _ _)]
exact inf_edist_le_edist_of_mem h
have ht : t.nonempty := hs.mono h
rw [inf_dist, inf_dist, Ennreal.to_real_le_to_real (inf_edist_ne_top ht) (inf_edist_ne_top hs)]
exact inf_edist_anti h
simp [inf_dist, inf_edist_closure]
rw [← inf_dist_eq_closure]
exact inf_dist_zero_of_mem hx
simp [mem_closure_iff_inf_edist_zero, inf_dist, Ennreal.to_real_eq_zero_iff, inf_edist_ne_top h]
rw [← mem_closure_iff_inf_dist_zero hs, h.closure_eq]
simp [inf_dist, inf_edist_image hΦ]
rw [inf_dist, dist_edist, hy]
simp [Hausdorff_dist]
simp [Hausdorff_dist]
simp [Hausdorff_dist, Hausdorff_edist_comm]
simp [Hausdorff_dist_comm]
have ht : t.nonempty := nonempty_of_Hausdorff_edist_ne_top ⟨x, hx⟩ Fin
rw [Hausdorff_dist, inf_dist, Ennreal.to_real_le_to_real (inf_edist_ne_top ht) Fin]
exact inf_edist_le_Hausdorff_edist_of_mem hx
simp [Hausdorff_dist, Hausdorff_edist_image h]
simp [Hausdorff_dist, h]
simp [Hausdorff_edist_comm]
simp [Hausdorff_dist]
simp [Hausdorff_dist]
simp [Hausdorff_dist]
simp [Hausdorff_dist]
simp [Hausdorff_edist_zero_iff_closure_eq_closure.symm, Hausdorff_dist,
    Ennreal.to_real_eq_zero_iff, Fin]
simp [← Hausdorff_edist_zero_iff_eq_of_closed hs ht, Hausdorff_dist, Ennreal.to_real_eq_zero_iff,
    Fin]
simp only [thickening, set_of_false, inf_edist_empty, not_top_lt]
simp only [edist_dist, Ennreal.of_real_lt_top]
rw [add_comm]
exact dist_triangle _ _ _
apply mem_cthickening_of_edist_le x y δ E h
rw [edist_dist]
exact Ennreal.of_real_le_of_real h'
simp only [cthickening, Ennreal.of_real_ne_top, set_of_false, inf_edist_empty, top_le_iff]
cases le_total δ 0 <;> simp [cthickening_of_nonpos, *]
intro x hx
rw [thickening, mem_set_of_eq] at hx
exact hx.le
have : bounded (thickening (max (δ + 1) 1) E) := h.thickening
apply bounded.mono _ this
exact
    cthickening_subset_thickening' (zero_lt_one.trans_le (le_max_right _ _))
      ((lt_add_one _).trans_le (le_max_left _ _)) _
rw [← cthickening_of_nonpos (min_le_right δ 0)]
exact cthickening_mono (min_le_left δ 0) E
rw [← cthickening_zero]
exact cthickening_subset_thickening' δ_pos δ_pos E
simp
rw [← Ennreal.coe_add, Nnreal.add_halves]
rw [← cthickening_max_zero, cthickening_eq_Inter_thickening]
exact le_max_left _ _
rw [← cthickening_zero]
exact cthickening_eq_Inter_cthickening E
rw [← cthickening_zero]
apply cthickening_eq_Inter_thickening' le_rfl _ hs₀ hs
rw [← cthickening_zero]
exact cthickening_eq_Inter_thickening rfl.ge E
rw [edist_dist] at D1
exact (Ennreal.of_real_le_of_real_iff hδ).1 D1
rw [cthickening_eq_bUnion_closed_ball E hδ, hE.closure_eq]
simp only [Isometry, edist_nndist, Ennreal.coe_eq_coe]
simp only [isometry_iff_nndist_eq, ← coe_nndist, Nnreal.coe_eq]
simp only [h x y, Ennreal.coe_one, one_mul, le_refl]
rw [Subsingleton.elim x y] <;> simp
rw [← h, hg _, hg _]
simp only [Emetric.diam_le_iff, ball_image_iff, hf.edist_eq]
rw [← image_univ]
exact hf.ediam_image univ
rw [Metric.diam, Metric.diam, hf.ediam_image]
rw [← image_univ]
exact hf.diam_image univ
infer_instance
apply Isometry.ofDistEq
intro x y
rfl
infer_instance
apply Isometry.ofDistEq
intro x y
rfl
dsimp at H
subst e₁
rw [← h.range_eq_univ, h.isometry.ediam_range]
rw [← image_symm, ediam_image]
rw [← h.isometry.preimage_emetric_ball (h.symm x) r, h.apply_symm_apply]
rw [← h.isometry.preimage_emetric_closed_ball (h.symm x) r, h.apply_symm_apply]
rw [← h.preimage_symm, h.symm.preimage_emetric_ball, symm_symm]
rw [← h.preimage_symm, h.symm.preimage_emetric_closed_ball, symm_symm]
rw [← image_symm, diam_image]
rw [← h.isometry.preimage_ball (h.symm x) r, h.apply_symm_apply]
rw [← h.isometry.preimage_sphere (h.symm x) r, h.apply_symm_apply]
rw [← h.isometry.preimage_closed_ball (h.symm x) r, h.apply_symm_apply]
rw [← h.preimage_symm, h.symm.preimage_ball, symm_symm]
rw [← h.preimage_symm, h.symm.preimage_sphere, symm_symm]
rw [← h.preimage_symm, h.symm.preimage_closed_ball, symm_symm]
intro n
simp [pow_succ, ← mul_assoc, Ennreal.mul_inv_cancel]
    -- Consider an open covering `S : set (set α)`
simp only [D]
rw [Nat.strongRecOn'_beta]
intro n i y
rw [Dn n i]
simp only [mem_Union, mem_ball]
    -- The sets `D n i` cover the whole space. Indeed, for each `x` we can choose `n` such that
    -- `ball x (3 / 2 ^ n) ⊆ s (ind x)`, then either `x ∈ D n i`, or `x ∈ D m i` for some `m < n`.
rw [← two_mul, h2pow]
          
      -- For each `m ≤ n + k` there is at most one `j` such that `D m j ∩ B` is nonempty.
trace
              "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr ennreal.add_lt_add, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
simp only [two_mul, add_comm]
rw [mul_add, h2pow, bit1, add_mul, one_mul]
          
      -- Finally, we glue `Hgt` and `Hle`
rw [mul_comm, ← div_eq_mul_inv]
exact Ennreal.div_le_of_le_mul' (hf x y)
simp only [Ennreal.coe_one, one_mul, id, le_refl]
rw [Ennreal.coe_mul, mul_assoc]
simp only [Subsingleton.elim x y, edist_self, zero_le]
apply properSpaceOfCompactClosedBallOfLe 0 fun x₀ r hr => _
let K := f
simp [dist_self]
refine' reverse_surjective.infi_congr _ fun l => _
rw [← sum_reverse, zip_with_distrib_reverse, reverse_append, reverse_reverse,
        reverse_singleton, singleton_append, reverse_cons, reverse_reverse,
        zip_with_comm_of_comm _ dist_comm]
simp only [length, length_append]
simp
induction on the length `n
simp
simp [s]
intro x y
dsimp only [d]
simp only [@SymmetricRel.mk_mem_comm _ _ (hU_symm _) x y]
refine' PseudoMetricSpace.le_two_mul_dist_of_prenndist _ _ _ fun x₁ x₂ x₃ x₄ => _
apply induction_on x
· refine' is_closed_eq _ continuous_const
    exact completion.continuous_dist continuous_id continuous_id
· intro a
    rw [completion.dist_eq, dist_self]
apply induction_on₂ x y
·
    exact
      is_closed_eq (completion.continuous_dist continuous_fst continuous_snd)
        (completion.continuous_dist continuous_snd continuous_fst)
· intro a b
    rw [completion.dist_eq, completion.dist_eq, dist_comm]
apply induction_on₃ x y z
·
    refine' is_closed_le _ (Continuous.add _ _) <;>
      trace
        "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr completion.continuous_dist, \",\", expr continuous.fst, \",\", expr continuous.snd, \",\", expr continuous_id, \"]\"],\n  []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
· intro a b c
    rw [completion.dist_eq, completion.dist_eq, completion.dist_eq]
    exact dist_triangle a b c
constructor
infer_instance
infer_instance
simp [LipschitzOnWith, LipschitzWith]
simp only [LipschitzOnWith, LipschitzWith, SetCoe.forall', restrict, Subtype.edist_eq]
rw [mul_comm, ← div_eq_mul_inv]
exact Ennreal.div_le_of_le_mul' (h x y)
simp only [Ennreal.coe_one, one_mul, h]
simp only [edist_self, zero_le]
rw [← mul_assoc, Ennreal.coe_mul]
intro x y
rw [ennreal.coe_mono.map_max, Prod.edist_eq, Ennreal.max_mul]
exact max_le_max (hf x y) (hg x y)
rw [pow_succ'] <;> exact (iterate n).comp hf
simp only [List.map_cons, List.prod_cons]
exact (h i).mul (list_prod l)
rw [pow_succ, pow_succ]
exact h.mul (pow n)
rw [add_comm]
apply dist_triangle
simp only [continuous_iff_continuous_on_univ, ← univ_prod_univ, ← lipschitz_on_univ] at *
exact continuous_on_prod_of_continuous_on_lipschitz_on f K (fun a _ => ha a) fun b _ => hb b
refine'
    tendsto_iff_dist_tendsto_zero.2
      (squeeze_zero' (eventually_of_forall fun _ => dist_nonneg)
        (mem_of_superset (ball_mem_nhds _ hr) h) _)
  -- Then show that `K * dist y x` tends to zero as `y → x`
refine' (continuous_const.mul (continuous_id.dist continuous_const)).tendsto' _ _ _
simp
simp only [hs, nonempty_coe_sort]
rw [add_assoc, ← mul_add, add_comm (dist y z)]
exact add_le_add_left (mul_le_mul_of_nonneg_left (dist_triangle _ _ _) K.2) _
apply LipschitzOnWith.ofDistLeMul fun x hx y hy => _
exact (dist_le_pi_dist _ _ i).trans (hf.dist_le_mul x hx y hy)
simp
rw [add_assoc, Hausdorff_edist_comm]
rw [← mul_two, mul_comm]
simp [B, Ennreal.pow_pos]
simp [B, Ennreal.pow_ne_top]
  /- Consider a sequence of closed sets `s n` with `edist (s n) (s (n+1)) < B n`.
    We will show that it converges. The limit set is t0 = ⋂n, closure (⋃m≥n, s m).
    We will have to show that a point in `s n` is close to a point in `t0`, and a point
    in `t0` is close to a point in `s n`. The completeness then follows from a
    standard criterion. -/
induction.
refine' exists_edist_lt_of_Hausdorff_edist_lt _ _
· exact s (n + l)
· exact z.2
simp only [B, Ennreal.inv_pow, div_eq_mul_inv]
rw [← pow_add]
apply hs <;> simp
simp only [exists_prop, Set.mem_Union, Filter.eventually_at_top, Set.mem_preimage,
              Set.preimage_Union]
exact ⟨k, fun m hm => ⟨n + m, zero_add k ▸ add_le_add (zero_le n) hm, (z m).2⟩⟩
apply mem_Inter.1 xt0 n
    rcases mem_closure_iff.1 this (B n) (B_pos n)
simp [Ennreal.one_lt_two]
simp
simp
rw [nonempty_compacts.to_closeds.uniform_embedding.embedding.is_compact_iff_is_compact_image]
rw [image_univ]
exact nonempty_compacts.is_closed_in_closeds.is_compact
simp [c, -mem_image] <;> exact ⟨yv, ⟨x, hx, Dxy⟩⟩
        exact ⟨y, this, le_of_lt Dxy⟩
      -- points in `c` are well approximated
rw [dist_comm]
exact inf_dist_le_inf_dist_add_Hausdorff_dist (edist_ne_top t s)
rw [← lipschitz_with_iff_dist_le_mul]
exact lipschitzWithLipschitzConstMulEdist
simp (config := { contextual := true }) [Set.subset_def, idRel, edist_self, (· > ·)]
simp
rw [Ennreal.add_halves]
simp [edist_comm]
intros
rfl
rw [edist_comm z] <;> apply edist_triangle
rw [edist_comm y] <;> apply edist_triangle
rw [Nat.Ico_succ_right_eq_insert_Ico hn, Finset.sum_insert, add_comm] <;> simp
intro h
exact ⟨uniform_continuous_iff.1 (uniform_embedding_iff.1 h).2.1, (uniform_embedding_iff.1 h).2.2⟩
rw [← ne_bot_iff] <;> exact uniformity_basis_edist.cauchy_iff
simp only [← tendsto_locally_uniformly_on_univ, tendsto_locally_uniformly_on_iff, mem_univ,
    forall_const, exists_prop, nhds_within_univ]
simp only [← tendsto_uniformly_on_univ, tendsto_uniformly_on_iff, mem_univ, forall_const]
simp
simp [edist_comm]
simp
unfold edist <;> congr <;> funext a <;> exact edist_comm _ _
  edist_triangle f g h
simp only [Finset.sup_le_iff]
intro b hb
exact le_trans (edist_triangle _ (g b) _) (add_le_add (le_sup hb) (le_sup hb))
simp only [PiCat.uniformity, PseudoEmetricSpace.uniformity_edist, comap_infi, gt_iff_lt,
      preimage_set_of_eq, comap_principal]
rw [infi_comm]
congr
funext ε
rw [infi_comm]
congr
funext εpos
change 0 < ε at εpos
simp [Set.ext_iff, εpos]
simp only [Finset.mem_univ, forall_const]
rw [edist_comm, mem_ball]
rw [edist_comm, mem_closed_ball]
rw [edist_self] <;> assumption
rw [edist_self] <;> exact bot_le
rw [mem_ball', mem_ball]
rw [mem_closed_ball', mem_closed_ball]
rw [edist_self]
exact Ennreal.coe_lt_top
rw [Emetric.ball_eq_empty_iff]
rw [← nhds_within_univ b, tendsto_nhds_within_nhds_within]
simp only [mem_univ, true_and_iff]
simp [is_open_iff_nhds, mem_nhds_iff]
rw [Ennreal.top_add]
exact le_of_not_lt hy
simp only [mem_ball, edist_comm x]
simp only [exists_prop, true_and_iff, mem_Ici, mem_ball]
simp [inseparable_iff_mem_closure, mem_closure_iff, edist_comm, forall_lt_iff_le']
simp
exact UniformSpace.second_countable_of_separable α
  choose T hTsub hTc hsubT
exact UniformSpace.second_countable_of_separable α
  rcases subset_countable_closure_of_almost_dense_set (univ : Set α) fun ε ε0 => _
simp only [diam, supr_le_iff]
simp only [diam_le_iff, ball_image_iff]
cases o <;> simp
simp only [diam_le_iff, ball_insert_iff, edist_self, edist_comm x, max_le_iff, supr_le_iff,
      zero_le, true_and_iff, forall_and, and_self_iff, ← and_assoc']
simp only [supr_singleton, diam_insert, diam_singleton, Ennreal.max_zero_right]
simp only [diam_insert, supr_insert, supr_singleton, diam_singleton, Ennreal.max_zero_right,
    Ennreal.sup_eq_max]
apply diam_le fun x hx y hy => edist_pi_le_iff.mpr _
rw [mem_univ_pi] at hx hy
exact fun b => diam_le_iff.1 (h b) (x b) (hx b) (y b) (hy b)
simp [← not_le]
have eq1 : (sup univ fun b : β => edist (f b) (g b)) ≤ 0 := le_of_eq eq0
simp only [Finset.sup_le_iff] at eq1
exact funext fun b => edist_le_zero.1 <| eq1 b <| mem_univ b
simp only [pos_iff_ne_zero, Ne.def, diam_eq_zero_iff, Set.Subsingleton, not_forall]
intro n
simp only [B, one_div, one_mul, Ennreal.inv_pos]
exact pow_ne_top two_ne_top
  /- Translate the density assumption into two functions `center` and `radius` associating
    to any n, x, δ, δpos a center and a positive radius such that
    `closed_ball center radius` is included both in `f n` and in `closed_ball x δ`.
    We can also require `radius ≤ (1/2)^(n+1)`, to ensure we get a Cauchy sequence later. -/
intro n
refine' Nat.le_induction _ fun m hnm h => _
· exact subset.refl _
· exact subset.trans (incl m) (subset.trans (inter_subset_left _ _) h)
intro n
refine' is_closed_ball.mem_of_tendsto ylim _
refine' (Filter.eventually_ge_at_top n).mono fun m hm => _
exact I n m hm mem_closed_ball_self
refine' fun n K => exists_positive_compacts_subset ((ho n).inter is_open_interior) _
rw [inter_comm]
exact (hd n).inter_open_nonempty _ is_open_interior K.interior_nonempty
intro x hx
simp only [mem_inter_iff, mem_Inter] at hx⊢
exact ⟨hK₀ <| hx 0, fun n => (hK_decreasing n (hx (n + 1))).1⟩
  /- Prove that `⋂ n : ℕ, K n` is not empty, as an intersection of a decreasing sequence
    of nonempty compact subsets.-/
rw [hf] <;> exact mem_range_self _
    rw [hf, sInter_range]
    exact dense_Inter_of_open_nat (fun n => ho _ (F n)) fun n => hd _ (F n)
simp only [sInter_Union, (hsT _ _).symm, ← sInter_eq_bInter]
rw [← sInter_range]
exact dense_sInter_of_Gδ (forall_range_iff.2 ‹_›) (countable_range _) (forall_range_iff.2 ‹_›)
rw [inter_eq_Inter]
apply dense_Inter_of_Gδ <;> simp [Bool.forall_bool, *]
simp only [residual, infi_and]
simp
simp [and_assoc']
let g i := frontier (f i)
refine' dense_Inter_of_open hgo fun i x => _
rw [closure_compl, interior_frontier (hc _)]
exact id
dsimp only [NonemptyCompacts.kuratowskiEmbedding]
rw [rangeΨ] <;> rfl
infer_instance
infer_instance
infer_instance
change to_GH_space (Quot.out p : nonempty_compacts ℓ_infty_ℝ) = p
rw [← eq_to_GH_space]
exact Quot.out_eq p
dsimp only [NonemptyCompacts.kuratowskiEmbedding]
rfl
dsimp only [NonemptyCompacts.kuratowskiEmbedding]
rfl
rw [GH_dist, p.to_GH_space_rep, q.to_GH_space_rep]
infer_instance
rw [ΦΦ', ΨΨ', range_comp, range_comp]
exact Hausdorff_dist_image isometrySubtypeCoe
rw [eq_to_GH_space_iff]
exact ⟨fun x => F (Φ' x), (kuratowskiEmbedding.isometry _).comp IΦ', range_comp _ _⟩
rw [eq_to_GH_space_iff]
exact ⟨fun x => F (Ψ' x), (kuratowskiEmbedding.isometry _).comp IΨ', range_comp _ _⟩
rw [Ψrange]
have : Φ xX ∈ ↑p := Φrange.subst (mem_range_self _)
exact
          exists_dist_lt_of_Hausdorff_dist_lt this bound
            (Hausdorff_edist_ne_top_of_nonempty_of_bounded p.nonempty q.nonempty
              p.is_compact.bounded q.is_compact.bounded)
rw [DΦ, DΨ]
apply add_le_add (add_le_add le_rfl (le_of_lt dy)) le_rfl
intro z
cases z
· apply mem_union_left
                  apply mem_range_self
· apply mem_union_right
                  apply mem_range_self
rw [hy]
rw [hx]
intro p q hp hq
let F := kuratowskiEmbedding (optimal_GH_coupling X Y)
let Φ := F ∘ optimal_GH_injl X Y
let Ψ := F ∘ optimal_GH_injr X Y
refine' ⟨Φ, Ψ, _, _, _⟩
· exact (kuratowskiEmbedding.isometry _).comp (isometry_optimal_GH_injl X Y)
· exact (kuratowskiEmbedding.isometry _).comp (isometry_optimal_GH_injr X Y)
· rw [← image_univ, ← image_univ, image_comp F, image_univ, image_comp F (optimal_GH_injr X Y),
      image_univ, ← Hausdorff_dist_optimal]
    exact (Hausdorff_dist_image (kuratowskiEmbedding.isometry _)).symm
have hΦ : IsCompact (range Φ) := is_compact_range Φisom.continuous
have hΨ : IsCompact (range Ψ) := is_compact_range Ψisom.continuous
apply (IsClosed.Hausdorff_dist_zero_iff_eq _ _ _).1 DΦΨ.symm
· exact hΦ.is_closed
· exact hΨ.is_closed
·
        exact
          Hausdorff_edist_ne_top_of_nonempty_of_bounded (range_nonempty _) (range_nonempty _)
            hΦ.bounded hΨ.bounded
rw [this]
rw [x.to_GH_space_rep, z.to_GH_space_rep]
refine'
          Hausdorff_dist_triangle
            (Hausdorff_edist_ne_top_of_nonempty_of_bounded (range_nonempty _) (range_nonempty _) _
              _)
·
          exact
            (is_compact_range
                (Isometry.continuous
                  ((to_glue_l_isometry hΦ hΨ).comp (isometry_optimal_GH_injl X Y)))).Bounded
·
          exact
            (is_compact_range
                (Isometry.continuous
                  ((to_glue_l_isometry hΦ hΨ).comp (isometry_optimal_GH_injr X Y)))).Bounded
simp only [← range_comp, Comm, eq_self_iff_true, add_right_inj]
rw [Hausdorff_dist_image (to_glue_l_isometry hΦ hΨ),
          Hausdorff_dist_image (to_glue_r_isometry hΦ hΨ)]
rw [Hausdorff_dist_optimal, Hausdorff_dist_optimal, GH_dist, GH_dist]
rw [x.to_GH_space_rep, y.to_GH_space_rep, z.to_GH_space_rep]
have ha : Isometry (coe : p → X) := isometrySubtypeCoe
have hb : Isometry (coe : q → X) := isometrySubtypeCoe
have A : dist p q = Hausdorff_dist (p : Set X) q := rfl
have I : ↑p = range (coe : p → X) := subtype.range_coe_subtype.symm
have J : ↑q = range (coe : q → X) := subtype.range_coe_subtype.symm
rw [A, I, J]
exact GH_dist_le_Hausdorff_dist ha hb
infer_instance
rw [Fin.ext_iff, Fin.coe_mk]
rw [ihi_eq]
exact (E q).symm_apply_apply ⟨y, ys⟩
simp only [Φ, Ψ]
rw [C1, C2, C3]
rfl
simp only [Equiv.apply_symm_apply, Fin.coe_cast]
      -- introduce `j`, that codes both `y` and `Φ y` in `fin (N p) = fin (N q)`
simp only [Equiv.apply_symm_apply, Fin.val_eq_coe, Fin.coe_cast]
      -- Express `dist x y` in terms of `F p`
simp only [F, (E p).symm_apply_apply]
rw [← this]
congr <;> apply Fin.ext_iff.2 <;> rfl
      -- Express `dist (Φ x) (Φ y)` in terms of `F q`
simp only [F, (E q).symm_apply_apply]
rw [mul_inv_cancel (ne_of_gt εpos), one_mul]
rw [abs_of_nonneg (le_of_lt (inv_pos.2 εpos)), mul_assoc]
have := hn n le_rfl
simp only [Real.dist_eq, add_zero, sub_eq_add_neg, neg_zero] at this
exact le_of_lt (lt_of_le_of_lt (le_abs_self _) this)
  -- construct a finite subset `s p` of `p` which is `ε`-dense and has cardinal `≤ K n`
intro p
rw [← Fintype.card_eq]
simp only [empty_card', Fintype.card_fin]
rw [hN, Cardinal.mk_fin]
rw [Fin.ext_iff, Fin.coe_mk]
rw [ihi_eq]
exact (E q).symm_apply_apply ⟨y, ys⟩
simp only [Φ, Ψ]
rw [C1, C2, C3]
rfl
simp only [Equiv.apply_symm_apply, Fin.coe_cast]
      -- introduce `j`, that codes both `y` and `Φ y` in `fin (N p) = fin (N q)`
simp only [Equiv.apply_symm_apply, Fin.coe_cast]
      -- Express `dist x y` in terms of `F p`
congr <;> apply Fin.ext_iff.2 <;> rfl
simp only [F, (E p).symm_apply_apply]
refine' min_eq_right (Nat.floor_mono _)
refine' mul_le_mul_of_nonneg_left (le_trans _ (le_max_left _ _)) (inv_pos.2 εpos).le
change dist (x : p.rep) y ≤ C
refine'
              le_trans (dist_le_diam_of_mem is_compact_univ.bounded (mem_univ _) (mem_univ _)) _
exact hdiam p pt
          
      -- Express `dist (Φ x) (Φ y)` in terms of `F q`
simp only [F, (E q).symm_apply_apply]
refine' min_eq_right (Nat.floor_mono _)
refine' mul_le_mul_of_nonneg_left (le_trans _ (le_max_left _ _)) (inv_pos.2 εpos).le
change dist (Ψ x : q.rep) (Ψ y) ≤ C
refine'
              le_trans (dist_le_diam_of_mem is_compact_univ.bounded (mem_univ _) (mem_univ _)) _
exact hdiam q qt
          
      -- use the equality between `F p` and `F q` to deduce that the distances have equal
      -- integer parts
rw [mul_inv_cancel (ne_of_gt εpos), one_mul]
rw [abs_of_nonneg (le_of_lt (inv_pos.2 εpos)), mul_assoc]
infer_instance
infer_instance
infer_instance
simp only [Y, aux_gluing]
rfl
intro n
apply Isometry.comp
· intro x y
      rfl
· apply to_glue_l_isometry
  -- consider the inductive limit `Z0` of the `Y n`, and then its completion `Z`
intro n
refine' uniform_space.completion.coe_isometry.comp _
exact (to_inductive_limit_isometry _ _).comp (Y n).isom
  -- The Hausdorff distance of `X2 n` and `X2 (n+1)` is
change
        X2 n =
          range
            (coeZ ∘
              Φ n.succ ∘
                c n ∘
                  to_glue_r (Y n).isom (isometry_optimal_GH_injl (X n) (X n.succ)) ∘
                    optimal_GH_injl (X n) (X n.succ))
simp only [X2, Φ]
rw [← to_inductive_limit_commute I]
simp only [f]
rw [← to_glue_commute]
rfl
simp [hf.1]
rw [edist_comm y, add_right_comm]
rw [hy.eq, dist_comm]
rw [iterate_succ']
apply hf.dist_fixed_point_le
simp (config := { contextual := true }) [Set.subset_def, idRel, dist_self, (· > ·)]
rw [div_add_div_same, add_self_div_two]
simp [dist_comm]
simp
rw [dist_comm]
exact hC hy
rw [eq_of_mem_singleton hx, eq_of_mem_singleton hy]
exact (dist_self z).le
rw [dist_comm x y, two_mul]
rw [← dist_self x] <;> apply dist_triangle
      
  nonneg_of_mul_nonneg_right this zero_lt_two
intros
rfl
intros
rfl
rw [dist_comm z] <;> apply dist_triangle
rw [dist_comm y] <;> apply dist_triangle
rw [add_left_comm, dist_comm x₁, ← add_assoc]
apply dist_triangle4
rw [add_right_comm, dist_comm y₁]
apply dist_triangle4
rw [Nat.Ico_succ_right_eq_insert_Ico hn, Finset.sum_insert, add_comm] <;> simp
funext x y <;> exact dist_comm _ _
simp [nndist, edist_dist, Real.toNnreal, max_eq_left dist_nonneg, Ennreal.ofReal]
rw [edist_nndist, Ennreal.coe_lt_coe]
rw [edist_nndist, Ennreal.coe_le_coe]
rw [edist_dist, Ennreal.of_real_lt_of_real_iff_of_nonneg dist_nonneg]
rw [edist_dist, Ennreal.of_real_le_of_real_iff hr]
rw [dist_nndist, Real.to_nnreal_coe]
rw [edist_dist, Ennreal.to_real_of_real dist_nonneg]
rw [dist_comm, mem_ball]
rw [dist_self] <;> assumption
rw [← not_nonempty_iff_eq_empty, nonempty_ball, not_lt]
rw [ball_eq_empty]
rw [dist_comm, mem_closed_ball]
rw [dist_comm, mem_sphere]
simp only [sphere_eq_empty_of_subsingleton hε, Set.hasEmptyc.Emptyc.is_empty α]
rw [dist_self] <;> assumption
rw [← not_nonempty_iff_eq_empty, nonempty_closed_ball, not_le]
rw [union_comm, ball_union_sphere]
rw [← ball_union_sphere, Set.union_diff_cancel_right sphere_disjoint_ball.symm.le_bot]
rw [← ball_union_sphere, Set.union_diff_cancel_left sphere_disjoint_ball.symm.le_bot]
rw [mem_ball', mem_ball]
rw [mem_closed_ball', mem_closed_ball]
rw [mem_sphere', mem_sphere]
rw [inter_comm] at h
rw [add_comm, dist_comm]
exact dist_lt_add_of_nonempty_closed_ball_inter_ball h
rw [← inter_Union, Union_closed_ball_nat, inter_univ]
rw [← add_sub_cancel'_right ε₁ ε₂] <;>
    exact lt_of_le_of_lt (dist_triangle z x y) (add_lt_add_of_lt_of_le zx h)
rw [sub_self_div_two] <;> exact le_of_lt h
rw [sub_sub_self]
rw [is_bounded_def, ← Filter.mem_sets, (@PseudoMetricSpace.cobounded_sets α _).out, mem_set_of_eq,
    compl_compl]
simp only [is_bounded_iff_exists_ge 0, Nnreal.exists, ← Nnreal.coe_le_coe, ← dist_nndist,
    Nnreal.coe_mk, exists_prop]
rw [← pseudo_metric_space.uniformity_dist.symm]
refine' has_basis_binfi_principal _ nonempty_Ioi
exact fun r (hr : 0 < r) p (hp : 0 < p) =>
    ⟨min r p, lt_min hr hp, fun x (hx : dist _ _ < _) => lt_of_lt_of_le hx (min_le_left r p),
      fun x (hx : dist _ _ < _) => lt_of_lt_of_le hx (min_le_right r p)⟩
intro h
exact ⟨uniform_continuous_iff.1 (uniform_embedding_iff.1 h).2.1, (uniform_embedding_iff.1 h).2.2⟩
intro ε ε_pos
rw [totally_bounded_iff_subset] at hs
exact hs _ (dist_mem_uniformity ε_pos)
simp only [← tendsto_locally_uniformly_on_univ, tendsto_locally_uniformly_on_iff,
    nhds_within_univ, mem_univ, forall_const, exists_prop]
rw [← tendsto_uniformly_on_univ, tendsto_uniformly_on_iff]
simp
simp only [is_open_iff_mem_nhds, mem_nhds_iff]
rw [← nhds_within_univ b, tendsto_nhds_within_nhds_within]
simp only [mem_univ, true_and_iff]
rw [ContinuousAt, tendsto_nhds_nhds]
rw [ContinuousWithinAt, tendsto_nhds_within_nhds]
simp [ContinuousOn, continuous_within_at_iff]
rw [ContinuousAt, tendsto_nhds]
rw [ContinuousWithinAt, tendsto_nhds]
simp [ContinuousOn, continuous_within_at_iff']
simp only [exists_prop, true_and_iff]
rfl
simp only [exists_prop, true_and_iff]
rfl
simp [is_open_iff, subset_singleton_iff, mem_ball]
simp [hε]
simp [edist_dist]
simp only [edist_dist, dist_comm] <;> simp
rw [Emetric.inseparable_iff, edist_nndist, dist_nndist, Ennreal.coe_eq_zero, Nnreal.coe_eq_zero]
simp [h]
simp [h, PseudoEmetricSpace.edist_comm]
simp only [h]
rw [← Ennreal.to_real_add (edist_ne_top _ _) (edist_ne_top _ _),
          Ennreal.to_real_le_to_real (edist_ne_top _ _)]
· exact edist_triangle _ _ _
· simp [Ennreal.add_eq_top, edist_ne_top]
simp [h, Ennreal.of_real_to_real, edist_ne_top]
rw [uniformity_pseudoedist, Metric.uniformity_edist]
rfl
rw [is_bounded_iff, mem_set_of_eq, compl_compl]
simp [abs_zero]
simp [Real.dist_eq]
simp only [nhds_basis_ball.eq_binfi, ball, Real.dist_eq, abs_sub_comm]
rw [mem_ball, dist_comm, Real.dist_eq, abs_sub_lt_iff, mem_Ioo, ← sub_lt_iff_lt_add',
      sub_lt_comm]
rw [Real.ball_eq_Ioo, ← sub_div, add_comm, ← sub_add, add_sub_cancel', add_self_div_two, ←
    add_div, add_assoc, add_sub_cancel'_right, add_self_div_two]
rw [Real.closed_ball_eq_Icc, ← sub_div, add_comm, ← sub_add, add_sub_cancel', add_self_div_two, ←
    add_div, add_assoc, add_sub_cancel'_right, add_self_div_two]
rw [cauchy_seq_iff_tendsto, Metric.uniformity_eq_comap_nhds_zero, tendsto_comap_iff, Prod.map_def]
rw [Metric.uniformity_eq_comap_nhds_zero, tendsto_comap_iff]
simp
apply @uniformity_dist_of_mem_uniformity _ _ _ _ _ fun x y => dist (f x) (f y)
refine' compl_surjective.forall.2 fun s => compl_mem_comap.trans <| mem_uniformity_dist.trans _
simp only [mem_compl_iff, @imp_not_comm _ (_ ∈ _), ← Prod.forall', Prod.mk.eta, ball_image_iff]
simp only [compl_mem_comap, Filter.mem_sets, ← is_bounded_def, mem_set_of_eq, compl_compl,
          is_bounded_iff, ball_image_iff]
simp only [Nnreal.nndist_eq, max_eq_right, tsub_zero, zero_tsub, zero_le']
rw [nndist_comm]
exact Nnreal.nndist_zero_eq_val z
rfl
simp only [sup_eq_max, dist_edist, ←
          Ennreal.to_real_max (edist_ne_top _ _) (edist_ne_top _ _),
          Prod.edist_eq]
simp only [← is_bounded_image_fst_and_snd, is_bounded_iff_eventually, ball_image_iff, ←
      eventually_and, ← forall_and, ← max_le_iff]
rfl
simp [Prod.dist_eq, dist_nonneg]
simp [Prod.dist_eq, dist_nonneg]
simp [Prod.dist_eq]
simp [Prod.dist_eq]
simp only [@nhds_eq_comap_uniformity α, Metric.uniformity_eq_comap_nhds_zero, comap_comap,
    (· ∘ ·), dist_comm]
rw [← nhds_comap_dist a, tendsto_comap_iff]
simp only [mem_ball, dist_comm]
simp only [mem_closure_iff, exists_range_iff]
simp only [mem_ball, dist_comm, exists_range_iff, forall_const]
simp only [mem_closure_iff, Set.Nonempty, exists_prop, mem_inter_iff, mem_ball', and_comm']
simp only [mem_closure_iff, exists_range_iff]
have : second_countable_topology s :=
    haveI
simp [nndist_pi_def]
rw [nndist_pi_def]
exact Finset.le_sup (Finset.mem_univ b)
simp only [dist_nndist, Nnreal.coe_le_coe, nndist_le_pi_nndist f g b]
simp [ball_eq_empty.2 hr]
simp [closed_ball_eq_empty.2 hr]
simp [nndist_pi_le_iff, i.forall_iff_succ_above]
simp only [dist_nndist, Fin.nndist_insert_nth_insert_nth, Nnreal.coe_max]
exact Emetric.second_countable_of_sigma_compact α
  rcases em (Nonempty α)
intro x r
intro f hf
    /- We want to show that the Cauchy filter `f` is converging. It suffices to find a closed
      ball (therefore compact
refine' properSpaceOfCompactClosedBallOfLe 0 fun x r hr => _
rw [closed_ball_pi _ hr]
apply is_compact_univ_pi fun b => _
apply (h b).is_compact_closed_ball
change bounded s ↔ s
simp
simp only [mem_closed_ball] at *
calc
      dist y z ≤ dist y x + dist z x := dist_triangle_right _ _ _
      _ ≤ r + r := add_le_add hy hz
simp
simp
simp
simp
simp [or_imp, forall_and, IH]
simp only [image_empty, bounded_empty, empty_inter]
simp only [diam, Emetric.diam_subsingleton hs, Ennreal.zero_to_real]
simp only [diam, Emetric.diam_pair, dist_edist]
simp only [Metric.diam, Emetric.diam_triple, dist_edist]
rw [Ennreal.to_real_max, Ennreal.to_real_max] <;>
    trace
      "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr ne_of_lt, \",\", expr edist_lt_top, \",\", expr max_lt, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
rw [diam, dist_edist]
rw [Ennreal.to_real_le_to_real (edist_ne_top _ _) h]
exact Emetric.edist_le_diam_of_mem hx hy
rw [← not_compact_space_iff, compact_space_iff_bounded_univ, bounded_iff_ediam_ne_top, not_not]
simp [diam]
rw [diam, ediam_of_unbounded h, Ennreal.top_to_real]
unfold diam
rw [Ennreal.to_real_le_to_real (bounded.mono h ht).ediam_ne_top ht.ediam_ne_top]
exact Emetric.diam_mono h
simp [mul_two, mul_comm]
intro n N hn
apply mem_of_subset_of_mem _ (h N).some_spec
intro x hx
simp only [mem_Inter] at hx
exact hx n hn
apply cauchy_seq_of_le_tendsto_0 _ _ h'
intro m n N hm hn
exact dist_le_diam_of_mem (h's N) (I _ _ hm) (I _ _ hn)
rw [eq_comm, dist_eq_zero]
simp only [← Nnreal.eq_iff, ← dist_nndist, imp_self, Nnreal.coe_zero, dist_eq_zero]
simp only [← Nnreal.eq_iff, ← dist_nndist, imp_self, Nnreal.coe_zero, dist_eq_zero]
simp only [← Nnreal.eq_iff, ← dist_nndist, imp_self, Nnreal.coe_zero, zero_eq_dist]
infer_instance
rw [add_zero]
rw [add_zero]
rw [zero_add]
simp only [edist_dist, eq0, Ennreal.of_real_zero]
rw [hs] <;> exact is_compact_empty
rw [hxy, hyz]
simp
simp [Hxx']
simp [PseudoMetricSpace.dist_comm, Hyy']
simp [PseudoMetricSpace.dist_comm, Hxx']
simp [Hyy']
refine' Quotient.ind fun y => _
exact PseudoMetricSpace.dist_self _
rw [← add_zero (0 : ℝ)] <;> exact add_le_add dist_nonneg dist_nonneg
simp
rw [eq_of_dist_eq_zero h]
rw [eq_of_dist_eq_zero h]
cases p <;> cases q <;> first |rfl|simp [sum.dist, glue_dist, dist_comm, add_comm, add_left_comm]
cases x <;> cases y <;> simp only [sum.dist, dist_comm, add_comm, add_left_comm]
rw [sum.dist_comm] <;> exact sum.one_dist_le
cases x <;> simp only [sum.dist, dist_self]
cases p <;> cases q
· simp only [sum.dist, dist_eq_zero, imp_self]
· intro h
      simp only [dist, sum.dist_eq_glue_dist p q] at h
      exact glue_eq_of_dist_eq_zero _ _ _ zero_lt_one _ _ h
· intro h
      simp only [dist, sum.dist_eq_glue_dist q p] at h
      exact glue_eq_of_dist_eq_zero _ _ _ zero_lt_one _ _ h
· simp only [sum.dist, dist_eq_zero, imp_self]
rw [h]
simp [HasDist.dist, sigma.dist]
simp [HasDist.dist, sigma.dist, h]
trace
            "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr add_le_add, \",\", expr le_rfl, \",\", expr dist_nonneg, \",\", expr zero_le_one, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
trace
            "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr add_le_add, \",\", expr le_rfl, \",\", expr dist_triangle, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
trace
              "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr add_le_add, \",\", expr le_rfl, \",\", expr dist_triangle, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
simp only [add_zero, zero_add]
trace
              "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr add_le_add, \",\", expr zero_le_one, \",\", expr dist_nonneg, \",\", expr le_rfl, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
rw [h]
exact zero_lt_one
simp
intro i
simp only [s, ← range_sigma_mk]
exact (isometry_mk i).UniformInducing.is_complete_range
rw [hΦ.dist_eq, hΨ.dist_eq] <;> simp
rw [nonpos_iff_eq_zero.1 hx, nonpos_iff_eq_zero.1 hy]
simp
simp [hx, hy]
simp [dist, inductive_limit_dist]
let m := max x.1 y.1
have hx : x.1 ≤ m := le_max_left _ _
have hy : y.1 ≤ m := le_max_right _ _
unfold dist
rw [inductive_limit_dist_eq_dist I x y m hx hy, inductive_limit_dist_eq_dist I y x m hy hx,
      dist_comm]
rw [inductive_limit_dist_eq_dist I x y m hx hy, inductive_limit_dist_eq_dist I y z m hy hz]
change inductive_limit_dist f ⟨n, x⟩ ⟨n, y⟩ = dist x y
rw [inductive_limit_dist_eq_dist I ⟨n, x⟩ ⟨n, y⟩ n (le_refl n) (le_refl n), le_rec_on_self,
      le_rec_on_self]
rfl
simp [thickenedIndicatorAux, inf_edist_zero_of_mem x_in_E, tsub_zero]
rw [← thickened_indicator_aux_closure_eq, thickened_indicator_aux_one δ (closure E) x_mem]
intro a
rw [tendsto_pi_nhds]
intro x
simp only [x_mem_closure, indicator_of_mem]
simp only [x_mem_closure, indicator_of_not_mem, not_false_iff]
apply
      ContinuousOn.comp_continuous continuous_on_to_nnreal
        (continuous_thickened_indicator_aux δ_pos E)
intro x
exact (lt_of_le_of_lt (@thickened_indicator_aux_le_one _ _ δ E x) one_lt_top).Ne
rw [thickened_indicator_apply, thickened_indicator_aux_one_of_mem_closure δ E x_mem,
    one_to_nnreal]
rw [thickened_indicator_apply, thickened_indicator_aux_zero δ_pos E x_out, zero_to_nnreal]
intro a
intro x
apply
    (to_nnreal_le_to_nnreal thickened_indicator_aux_lt_top.ne thickened_indicator_aux_lt_top.ne).mpr
apply thickened_indicator_aux_mono hle
refine' (congr_fun (comp_indicator_const 1 Ennreal.toNnreal zero_to_nnreal) x).symm
infer_instance
assumption
simp
rw [isometry_inl.diam_image, isometry_inr.diam_image]
rfl
simp
rw [candidates_symm fA]
rw [@sum.dist_eq X Y]
rfl
simp
simp
simp
rw [@sum.dist_eq X Y]
rfl
simp
simp [sub_eq_add_neg, add_assoc]
apply add_le_add
apply
        mul_le_mul_of_nonneg_left (le_max_left (dist x z) (dist t y))
          (zero_le_one.trans (one_le_max_var X Y))
apply
        mul_le_mul_of_nonneg_left (le_max_right (dist x z) (dist t y))
          (zero_le_one.trans (one_le_max_var X Y))
rfl
rfl
apply add_le_add (add_le_add _ le_rfl)
exact dist_le_diam_of_mem bounded_of_compact_space (mem_univ _) (mem_univ _)
any_goals exact OrderedAddCommMonoid.to_CovariantClass_left ℝ
any_goals exact OrderedAddCommMonoid.to_CovariantClass_right ℝ
exact dist_le_diam_of_mem bounded_of_compact_space (mem_univ _) (mem_univ _)
apply add_le_add (add_le_add _ le_rfl)
exact dist_le_diam_of_mem bounded_of_compact_space (mem_univ _) (mem_univ _)
any_goals exact OrderedAddCommMonoid.to_CovariantClass_left ℝ
any_goals exact OrderedAddCommMonoid.to_CovariantClass_right ℝ
exact dist_le_diam_of_mem bounded_of_compact_space (mem_univ _) (mem_univ _)
cases Classical.choose_spec (exists_minimizer X Y) <;> assumption
refine' Isometry.ofDistEq fun x y => _
change dist
refine' Isometry.ofDistEq fun x y => _
change dist
rw [hz']
exact le_of_lt hr'
rw [hz']
exact le_of_lt hr'
rw [first_diff, dif_pos h]
exact Nat.find_spec (ne_iff.1 h)
simp [cylinder_eq_pi]
simp
constructor
· intro hy
    apply subset.antisymm
    · intro z hz i hi
      rw [← hy i hi]
      exact hz i hi
    · intro z hz i hi
      rw [hy i hi]
      exact hz i hi
· intro h
    rw [← h]
    exact self_mem_cylinder _ _
simp [mem_cylinder_iff_eq, eq_comm]
constructor
· intro h
rw [← mem_cylinder_iff_eq]
intro i hi
exact apply_eq_of_lt_first_diff (hi.trans_le hn)
simp [hi.ne]
simp [dist, h]
simp [dist]
simp [dist, @eq_comm _ x y, first_diff_comm]
simp
simp
simp
rw [mem_cylinder_comm] at hy
exact mem_cylinder_iff_dist_le.1 hy
rw [longest_prefix, le_tsub_iff_right]
· exact first_diff_lt_shortest_prefix_diff hs hx hy
· exact shortest_prefix_diff_pos hs ⟨y, hy⟩ hx
simp [xs]
rw [← mem_cylinder_iff_eq]
apply mem_cylinder_first_diff
rw [← mem_cylinder_iff_eq, first_diff_comm]
apply cylinder_anti y _ A.some_spec.2
exact first_diff_le_longest_prefix hs ys xs
rw [← mem_cylinder_iff_eq]
apply cylinder_anti x _ A.some_spec.2
apply first_diff_le_longest_prefix hs xs ys
rw [← mem_cylinder_iff_eq]
exact cylinder_anti x H.1 Ax.some_spec.2
rw [eq_comm, ← mem_cylinder_iff_eq]
exact cylinder_anti y H.2 Ay.some_spec.2
rw [I1, I2, I3]
simp [← f_range]
rw [← B]
simp
have : tendsto (fun n : ℕ => (2 : ℝ) * (1 / 2) ^ n) at_top (𝓝 (2 * 0)) :=
        (tendsto_pow_at_top_nhds_0_of_lt_1 I0.le I1).const_mul _
rw [mul_zero] at this
exact
        squeeze_zero (fun n => diam_nonneg) (fun n => diam_closed_ball (pow_nonneg I0.le _)) this
simp
simp [dist_eq_tsum]
simp [dist_eq_tsum, dist_comm]
simp
infer_instance
rw [complete_space_iff_is_complete_range hf.to_embedding.to_isometry.uniform_inducing]
apply IsClosed.is_complete
exact hf.closed_range
infer_instance
simp only [mem_set_of_eq]
intro i
apply Continuous.comp _ (continuous_apply i)
apply continuous_def.2 fun s hs => _
exact hm i s hs
rw [hxy]
constructor
· exact K
· exact f_closed
infer_instance
simp [dist_complete_copy_eq]
simp [dist_complete_copy_eq, dist_comm, abs_sub_comm]
rw [← Real.dist_eq, ← Real.dist_eq, ← Real.dist_eq]
exact add_le_add (dist_triangle _ _ _) (dist_triangle _ _ _)
intro x y hxy
apply Subtype.coe_injective
refine' dist_le_zero.1 _
rw [← hxy]
exact dist_le_dist_complete_copy x y
apply LipschitzWith.mkOne
exact dist_le_dist_complete_copy
rw [← hs.is_closed_compl.not_mem_iff_inf_dist_pos h's]
simp
simp
apply embedding_subtype_coe.tendsto_nhds_iff.2
exact xlim
rw [Real.dist_0_eq_abs]
exact le_abs_self _
apply lt_of_le_of_lt _ (hC 0)
simp [inf_dist_nonneg]
apply (hs.is_closed_compl.not_mem_iff_inf_dist_pos h's).1
simp
infer_instance
simp only [Equiv.symm_symm, Equiv.symm_preimage_preimage]
apply IsClosed.preimage
· exact @Homeomorph.continuous _ _ t' _ g
· exact is_closed_range_inl
apply IsOpen.preimage
· exact @Homeomorph.continuous _ _ t' _ g
· exact is_open_range_inl
apply is_open_Union
intro n
apply t'm n
exact m_open n
rw [pos_iff_ne_zero, Ne.def, einfsep_zero]
simp only [not_forall, not_exists, not_lt]
rw [einfsep_top]
exact fun _ hx _ hy hxy => (hxy <| hs hx hy).elim
cases o <;> simp
rw [pair_comm] <;> exact einfsep_pair_le_left hxy.symm
rw [einfsep_top] at hs
exact fun _ hx _ hy => of_not_not fun hxy => edist_ne_top _ _ (hs _ hx _ hy hxy)
rw [lt_top_iff_ne_top]
exact hs.einfsep_ne_top
cases nonempty_fintype s
rw [← einfsep_pos]
exact einfsep_pos_of_finite
rw [infsep, Ennreal.to_real_eq_zero_iff]
rw [infsep_pair_eq_to_real, edist_dist]
exact Ennreal.to_real_of_real dist_nonneg
simp only [infsep, einfsep_triple hxy hyz hxz, Ennreal.to_real_inf, edist_ne_top x y,
    edist_ne_top x z, edist_ne_top y z, dist_edist, Ne.def, inf_eq_top_iff, and_self_iff,
    not_false_iff]
rw [Finset.coe_infsep, dif_pos hs]
rw [← Finset.not_nonempty_iff_eq_empty] at hs
rw [Finset.coe_infsep, dif_neg hs]
rw [infsep_zero, einfsep_eq_top_iff, or_iff_right_iff_imp]
exact fun H => (einfsep_pos_of_finite.ne' H).elim
rw [infsep_pos, einfsep_lt_top_iff, and_iff_right_iff_imp]
exact fun _ => einfsep_pos_of_finite
simp
simp only [embedding_of_subset_coe, sub_sub_sub_cancel_right]
trace
          "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr add_le_add_left, \",\", expr le_abs_self, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
simp only [HolderOnWith, HolderWith, mem_univ, true_imp_iff]
simp only [HolderOnWith, LipschitzOnWith, Nnreal.coe_one, Ennreal.rpow_one]
intro x hx y hy
rw [Ennreal.coe_mul, mul_comm rg, Nnreal.coe_mul, Ennreal.rpow_mul, mul_assoc, ←
    Ennreal.coe_rpow_of_nonneg _ rg.coe_nonneg, ← Ennreal.mul_rpow_of_nonneg _ _ rg.coe_nonneg]
exact hg.edist_le_of_le (hst hx) (hst hy) (hf.edist_le hx hy)
simp [Real.dist_eq]
rw [dimH_def]
exact le_supr₂ d h
rw [sUnion_eq_bUnion, dimH_bUnion hS]
rw [union_eq_Union, dimH_Union, supr_bool_eq, cond, cond, Ennreal.sup_eq_max]
simp only [dimH_bUnion hs, dimH_singleton, Ennreal.supr_zero_eq_zero]
simp
rw [← e.image_symm, e.symm.dimH_image]
rw [← e.dimH_preimage univ, preimage_univ]
rw [← e.image_symm_eq_preimage, e.symm.dimH_image]
rw [← e.dimH_preimage, preimage_univ]
rw [hausdorff_measure_pi_real, Real.volume_pi_ball _ hr]
rw [dimH_ball_pi x hr, Fintype.card_fin]
simp only [← Metric.Union_ball_nat_succ (0 : ι → ℝ), dimH_Union,
    dimH_ball_pi _ (Nat.cast_add_one_pos _), supr_const]
rw [dimH_univ_pi, Fintype.card_fin]
rw [← e.map_nhds_eq]
exact image_mem_map h
rw [dimH_univ_eq_finrank ℝ, FiniteDimensional.finrank_self, Nat.cast_one]
refine' fun x => mem_closure_iff_nhds.2 fun t ht => nonempty_iff_ne_empty.2 fun he => hs.not_le _
rw [← diff_eq, diff_eq_empty] at he
rw [← Real.dimH_of_mem_nhds ht]
exact dimH_mono he
rw [image_univ]
simp [hf₀ (subset_closure hx)]
simp [hf₁ hx]
rw [hxy]
refine' (eventually_all_finite h_fin).2 fun UV hUV => _
exact (f UV).Continuous.Tendsto x (closed_ball_mem_nhds _ δ0)
simp [empty_mem]
rw [union_eq_Union] <;> exact is_open_Union (Bool.forall_bool.2 ⟨h₂, h₁⟩)
rw [← sUnion_empty] <;> exact is_open_sUnion fun a => False.elim
rw [sInter_empty] <;> exact is_open_univ
rw [sInter_insert] <;>
      exact IsOpen.inter (h _ <| mem_insert _ _) (ih fun t => h t ∘ mem_insert_of_mem _)
rw [bInter_empty] <;> exact is_open_univ
rw [bInter_insert] <;>
      exact IsOpen.inter (h a (mem_insert _ _)) (ih fun i hi => h i (mem_insert_of_mem _ hi))
simp only [this] <;> exact is_open_univ
simp only [this] <;> exact is_open_empty
rw [← is_open_compl_iff, compl_empty]
exact is_open_univ
rw [← is_open_compl_iff, compl_univ]
exact is_open_empty
rw [← is_open_compl_iff] at *
rw [compl_union]
exact IsOpen.inter h₁ h₂
rw [← is_open_compl_iff, compl_compl]
rw [← is_open_compl_iff] at *
rw [compl_inter]
exact IsOpen.union h₁ h₂
rw [bUnion_empty] <;> exact is_closed_empty
rw [bUnion_insert] <;>
      exact IsClosed.union (h a (mem_insert _ _)) (ih fun i hi => h i (mem_insert_of_mem _ hi))
simp only [interior, mem_sUnion, mem_set_of_eq, exists_prop, and_assoc', and_left_comm]
simp only [interior_eq_iff_is_open.symm, subset.antisymm_iff, interior_subset, true_and_iff]
simp
rw [← subset_interior_iff_is_open] <;> simp only [subset_def, mem_interior]
rw [sInter_eq_bInter]
rw [diff_subset_iff, union_eq_self_of_subset_left subset_closure]
rw [subset.antisymm subset_closure h] <;> exact is_closed_closure
simp only [nonempty_iff_ne_empty, Ne.def, closure_empty_iff]
simp
rw [interior, closure, compl_sUnion, compl_image_set_of]
simp only [compl_subset_compl, is_open_compl_iff]
simp [closure_eq_compl_interior_compl]
simp [closure_eq_compl_interior_compl]
rw [lift'_bot (monotone_closure _), closure_empty, principal_empty]
rw [dense_iff_closure_eq, closure_compl, compl_univ_iff]
rw [Dense, Dense, closure_closure]
simp only [h.closure_eq]
rw [frontier, diff_diff_right_self, inter_eq_self_of_subset_right interior_subset_closure]
rw [frontier, diff_diff_right, diff_eq_empty.2 subset_closure,
    inter_eq_self_of_subset_right interior_subset, empty_union]
rw [closure_compl, frontier, diff_eq]
simp only [frontier_eq_closure_inter_closure, compl_compl, inter_comm]
simp [frontier]
simp [frontier]
rw [frontier, hs.closure_eq]
rw [frontier, hs.interior_eq]
rw [hs.frontier_eq, inter_diff_self]
rw [frontier_eq_closure_inter_closure] <;>
    exact IsClosed.inter is_closed_closure is_closed_closure
rw [A] <;> exact interior_mono (diff_subset _ _)
rw [← frontier_compl, ← closure_compl]
rfl
rw [frontier_eq_inter_compl_interior]
simp only [compl_inter, compl_compl]
rw [nhds]
simp only [nhds_def, mem_set_of_eq, and_comm' (a ∈ _), infi_and]
simp only [is_open_compl_iff, mem_compl_iff]
simp [nhds_def]
rw [nhds_def] <;> exact infi_le_of_le s (infi_le_of_le ⟨h, o⟩ sf)
simp only [subset_def, exists_prop, mem_set_of_eq]
simp only [and_comm' (x ∈ _), and_imp]
rw [rtendsto'_def]
apply all_mem_nhds_filter
apply Rel.preimage_mono
simp only [and_imp, exists_prop, true_and_iff, mem_Ici, ge_iff_le]
simp only [cluster_pt_principal_iff, frequently_iff, Set.Nonempty, exists_prop, mem_inter_iff]
simp only [ClusterPt, inf_eq_left.mpr H, nhdsNeBot]
simp only [mem_interior, mem_nhds_iff, mem_set_of_eq]
simp only [le_principal_iff]
rw [interior_eq_nhds', mem_set_of_eq]
simp only [← interior_set_of_eq, is_open_interior]
rw [interior_eq_nhds] <;> rfl
constructor
· intro h
    apply le_antisymm _ (pure_le_nhds a)
    rw [le_pure_iff]
    exact h.mem_nhds (mem_singleton a)
· intro h
    simp [is_open_iff_nhds, h]
rw [is_open_singleton_iff_nhds_eq_pure, nhdsWithin, ← mem_iff_inf_principal_compl, ← le_pure_iff,
    nhds_ne_bot.le_pure_iff]
rw [Filter.Frequently, Filter.Eventually, ← mem_interior_iff_mem_nhds,
      closure_eq_compl_interior_compl] <;>
    rfl
rw [← closure_subset_iff_is_closed]
apply forall_congr' fun x => _
rw [mem_closure_iff_frequently]
simp only [mem_closure_iff_nhds, Set.inter_nonempty_iff_exists_right, SetCoe.exists,
    Subtype.coe_mk]
simp only [exists_prop, forall_const]
simp only [Set.Nonempty, mem_inter_iff, exists_prop, and_comm']
simp [closure_eq_cluster_pts, ClusterPt, ← exists_ultrafilter_iff, and_comm]
simp only [subset_def, mem_closure_iff_cluster_pt]
rw [hs.closure_eq, inter_univ]
rw [sup_principal]
rw [inf_principal_eq_bot.mpr h₁]
simp [hs.closure_eq, ht.closure_eq]
simp only [diff_eq, inter_comm]
simp only [diff_eq, inter_comm]
simp only [ContinuousAt, tendsto_congr' h, h.eq_of_nhds]
rw [← mem_compl_iff, ← interior_compl, mem_interior_iff_mem_nhds, Function.compl_support] <;> rfl
rw [← is_closed_compl_iff, ← is_closed_compl_iff] <;> exact hf _
simp only [continuous_iff_continuous_at, continuous_at_iff_ultrafilter]
rw [← (is_closed_closure.preimage hf).closure_eq]
exact closure_mono (preimage_mono subset_closure)
rw [← Pfun.preimage_univ] <;> exact h _ is_open_univ
intro s hs
have : ptendsto' f (𝓝 x) (𝓝 y) := hf fxy
rw [ptendsto'_def] at this
exact this s hs
simp only [maps_to, mem_closure_iff_cluster_pt]
exact fun x hx => hx.map hc.continuous_at (tendsto_principal_principal.2 h)
rw [← Set.image_subset_iff]
exact image_closure_subset_closure_image h
simp [hf.range_eq]
rw [← image_univ, ← hs.closure_eq]
exact image_closure_subset_closure_image hf
rw [image_preimage_eq_inter_range]
exact hf.open_subset_closure_inter hs
rw [DenseRange, range_comp]
exact hg.dense_image cg hf
simp [e₁, e₂]
simp
rw [← ι_preserves_colimits_iso_hom]
simp [h]
dsimp [glue_data.diagram]
simp
simp [eq₁]
simp
simp [← hx]
rw [← Set.preimage_image_eq (Set.range (D.f j i)) (D.ι_injective j), ← Set.image_univ, ←
    Set.image_univ, ← Set.image_comp, ← coe_comp, Set.image_univ, Set.image_univ, ← image_inter,
    Set.preimage_range_inter]
refine' (pullback_iso_prod_subtype _ _).Hom
rw [sUnion_insert, empty_union, h.sUnion_eq]
rw [sUnion_diff_singleton_empty, h.sUnion_eq]
simp [is_open_iff_mem_nhds, hb.mem_nhds_iff]
simp only [exists_prop, and_assoc']
rw [hb.eq_generate_from]
exact generate_open.basic s hs
rw [← sUnion_eq_Union]
apply hB.open_eq_sUnion' ou
simp only [and_imp]
simp only [Dense, hb.mem_closure_iff]
exact ⟨fun h o hb ⟨a, ha⟩ => h a o hb ha, fun h a o hb ha => h o hb ⟨a, ha⟩⟩
refine' ⟨fun H o ho => H _ (hB.is_open ho), fun hf o ho => _⟩
rw [hB.open_eq_sUnion' ho, sUnion_eq_Union, image_Union]
exact is_open_Union fun s => hf s s.2.1
rw [hB.eq_generate_from]
exact continuous_generated_from hf
refine'
      injective_iff_pairwise_ne.mpr ((h.subtype _ _).mono fun i j hij hfij => hij.le_bot ⟨hfs i, _⟩)
simp only [congr_arg coe hfij, hfs j]
rw [← Filter.mem_pi', ← nhds_pi]
exact hU.mem_nhds ha
rw [nhds_prod_eq]
infer_instance
rw [nhds_pi]
infer_instance
rw [hf.1]
exact second_countable_topology_induced α β f
refine' IsLinearMap.mk' (e.symm b) _
rw [coe_linear_map_at]
rw [e.linear_map_at_def_of_mem hb]
exact (e.linear_equiv_at R b hb).left_inv y
rw [e.linear_map_at_def_of_mem hb]
exact (e.linear_equiv_at R b hb).right_inv y
rw [coe_linear_map_at]
rw [e.coord_changeL_apply e' hb, e.mk_symm hb.1]
dsimp
rw [e.coe_linear_map_at b]
refine' continuous_if_const _ (fun hb => _) fun _ => continuous_zero
exact
        continuous_snd.comp
          (e.to_local_homeomorph.continuous_on.comp_continuous
            (FiberBundle.total_space_mk_inducing F E b).Continuous fun x => e.mem_source.mpr hb)
cases x
rfl
rw [e.target_eq]
exact ⟨hb, mem_univ _⟩
dsimp [VectorBundleCore.TotalSpace, VectorBundleCore.Fiber] <;>
    exact Z.to_fiber_bundle_core.local_triv i
simp only [ContinuousLinearMap.map_add, mfld_simps]
simp only [ContinuousLinearMap.map_smul, mfld_simps]
dsimp [VectorBundleCore.Fiber] <;> exact Iff.rfl
apply (Z.local_triv i).symmApply hb v
rw [local_triv_at, mem_local_triv_source]
exact Z.mem_base_set_at b
intro e he
rw [eq_trivialization B F e]
infer_instance
rw [symm_apply]
rfl
exact hb
infer_instance
infer_instance
simp [is_ωSup, IsLub, IsLeast, upperBounds, lowerBounds]
intro x y' h
simp only [notBelow, setOf, le_Prop_eq]
intro h₀ h₁
apply h₀ (le_trans h h₁)
constructor
· apply le_ωSup
· apply ωSup_le
simp [*]
simp [hea]
infer_instance
erw [mem_prod]
simp
erw [mem_prod]
simp only [and_true_iff, mem_univ]
simp only [mfld_simps]
rfl
rw [continuous_on_open_iff (Z.open_source' i)]
intro s s_open
apply TopologicalSpace.GenerateOpen.basic
simp only [exists_prop, mem_Union, mem_singleton_iff]
exact ⟨i, s, s_open, rfl⟩
rw [(Z.local_triv_as_local_equiv_trans i j).source_inter_preimage_eq]
exact
        (continuous_on_open_iff (Z.triv_change i j).open_source).1 (Z.triv_change i j).ContinuousOn
          _ s_open
apply continuous_iff_continuous_at.2 fun x => _
have A : Z.base_set (Z.index_at x) ∈ 𝓝 x :=
    IsOpen.mem_nhds (Z.is_open_base_set (Z.index_at x)) (Z.mem_base_set_at x)
apply ((Z.local_triv_at x).toLocalHomeomorph.continuous_at_iff_continuous_at_comp_left _).2
· simp only [(· ∘ ·), mfld_simps]
    apply continuous_at_id.prod
    have : ContinuousOn (fun y : B => v) (Z.base_set (Z.index_at x)) := continuous_on_const
    apply (this.congr _).ContinuousAt A
    intro y hy
    simp only [h, hy, mem_base_set_at, mfld_simps]
· exact A
rw [local_triv_at, local_triv_apply, coord_change_self]
exact Z.mem_base_set_at p.1
rw [local_triv_at, mem_local_triv_source]
exact Z.mem_base_set_at b
rw [local_triv_at, ← base_set_at]
exact Z.mem_base_set_at b
refine'
    id fun z H =>
      id fun U h => preimage_nhds_within_coinduced' H e.open_target (le_def.1 (nhds_mono _) U h)
exact le_supr₂ e he
rw [inter_assoc, inter_self]
rfl
simp only [preimage_inter, inter_univ, Subtype.coe_preimage_self, hu3.symm]
rfl
simp only [(a.pretrivialization_at b).source_eq, mem_preimage, total_space.proj]
exact a.mem_base_pretrivialization_at b
apply eq_univ_of_univ_subset
rw [(a.pretrivialization_at b).source_eq, ← preimage_comp, Function.comp]
simp only [total_space.proj]
rw [preimage_const_of_mem _]
exact a.mem_base_pretrivialization_at b
rw [← continuous_iff_continuous_on_univ, continuous_iff_le_induced]
simp only [Prod.topologicalSpace, induced_inf, induced_compose]
exact le_rfl
rw [← continuous_iff_continuous_on_univ, continuous_iff_le_induced]
simp only [bundle.total_space.topological_space, induced_inf, induced_compose]
exact le_rfl
simp only [univ_prod_univ]
infer_instance
rw [(prod.inducing_diag E₁ E₂).continuous_on_iff]
have H₁ : Continuous fun p : B × F₁ × F₂ => ((p.1, p.2.1), (p.1, p.2.2)) :=
    (continuous_id.prod_map continuous_fst).prod_mk (continuous_id.prod_map continuous_snd)
refine' (e₁.continuous_on_symm.prod_map e₂.continuous_on_symm).comp H₁.continuous_on _
exact fun x h => ⟨⟨h.1.1, mem_univ _⟩, ⟨h.1.2, mem_univ _⟩⟩
rw [(prod.inducing_diag E₁ E₂).inducing_iff]
exact (total_space_mk_inducing F₁ E₁ b).prod_mk (total_space_mk_inducing F₂ E₂ b)
infer_instance
infer_instance
infer_instance
infer_instance
rw [continuous_iff_le_induced, Pullback.TotalSpace.topologicalSpace, pullbackTopology]
exact inf_le_left
rw [continuous_iff_le_induced, Pullback.TotalSpace.topologicalSpace, pullbackTopology]
exact inf_le_right
simp only [continuous_iff_le_induced, Pullback.TotalSpace.topologicalSpace, induced_compose,
    induced_inf, Function.comp, total_space_mk, total_space.proj, induced_const, top_inf_eq,
    pullbackTopology]
exact le_of_eq (FiberBundle.total_space_mk_inducing F E (f x)).induced
dsimp only
rw [e.source_eq]
rfl
infer_instance
rw [e.source_eq, mem_preimage]
rw [e.target_eq, prod_univ, mem_preimage]
rw [← e.coe_fst ex, Prod.mk.eta, ← e.coe_coe, e.to_local_equiv.left_inv ex]
refine' inter_eq_right_iff_subset.mpr fun x hx => _
simp only [mem_preimage, LocalEquiv.inv_fun_as_coe, e.proj_symm_apply hx]
exact e.mem_target.mp hx
rw [inter_comm, f.target_eq, e.source_eq, f.preimage_symm_proj_inter]
rw [LocalEquiv.trans_source, LocalEquiv.symm_source, e.target_inter_preimage_symm_source_eq]
rw [LocalEquiv.trans_symm_eq_symm_trans_symm, LocalEquiv.symm_symm]
rw [LocalEquiv.trans_source, e'.source_eq, LocalEquiv.symm_source, e.target_eq, inter_comm,
    e.preimage_symm_proj_inter, inter_comm]
rw [← LocalEquiv.symm_source, symm_trans_symm, symm_trans_source_eq, inter_comm]
rw [e.symm_apply hb, total_space.mk_cast, total_space.eta]
rw [e.symm_apply hz, cast_eq_iff_heq, e.mk_proj_snd' hz, e.symm_apply_apply (e.mem_source.mpr hz)]
rw [e.mk_symm hb, e.apply_symm_apply (e.mk_mem_target.mpr hb)]
intro e e'
rw [Pretrivialization.ext_iff, Trivialization.ext_iff, ←
    local_homeomorph.to_local_equiv_injective.eq_iff]
exact id
rw [e.source_eq, mem_preimage]
rw [← e.coe_fst ex, ← map_congr (e.coe_fst_eventually_eq_proj ex), ← map_map, ← e.coe_coe,
    e.to_local_homeomorph.map_nhds_eq ex, map_fst_nhds]
rw [mem_preimage, e.proj_symm_apply' hb, mem_singleton_iff]
simp [e.source_eq, preimage_preimage]
simp [e.target_eq]
rw [LocalEquiv.symm_target, e.mem_source]
exact he
rw [e.to_local_homeomorph.continuous_at_iff_continuous_at_comp_left]
· exact hf
rw [e.source_eq, ← preimage_comp]
exact hf_proj.preimage_mem_nhds (e.open_base_set.mem_nhds he)
rw [e'.target_eq]
exact e'.open_base_set.prod is_open_univ
simp [e.target_eq, prod_univ, preimage_preimage]
rw [coord_change, e₁.symm_apply_mk_proj (e₁.mem_source.2 h)]
rw [coord_change, e.apply_symm_apply' h]
simp only [*, coord_change_coord_change, coord_change_same_apply]
simp only [*, coord_change_coord_change, coord_change_same_apply]
simp [e.coe_fst', hx]
simp [e.source_eq]
simp [e.target_eq, prod_univ]
rw [← (e.is_image_preimage_prod s).frontier.preimage_eq, frontier_prod_univ_eq,
    (e.is_image_preimage_prod _).preimage_eq, e.source_eq, preimage_inter]
rw [e.frontier_preimage, e'.frontier_preimage, Hs]
simp [e.source_eq, e'.source_eq]
simp [e.target_eq, e'.target_eq, prod_univ]
simp [He, He', mem_singleton_iff.1 (frontier_Iic_subset _ hx)]
rw [e.source_eq, e'.source_eq]
exact H.preimage _
rw [e.target_eq, e'.target_eq, disjoint_iff_inf_le]
intro x hx
exact H.le_bot ⟨hx.1.1, hx.2.1⟩
cases f
cases g
congr
rw [← comp_apply, h, comp_apply]
rw [hf.induced, hg.induced, induced_compose]
rw [hgf.induced, ← continuous_iff_le_induced]
apply hg.comp continuous_induced_dom
simp only [nhdsSet, Sup_image, comap_supr, hf.nhds_eq_comap, supr_image]
rw [hg.nhds_eq_comap, tendsto_comap_iff]
refine' ⟨fun h => hg.comp h, fun hgf => inducing_of_inducing_compose _ hg.continuous hgf⟩
rw [hg.continuous_iff]
exact hgf.continuous
rw [hf.induced, is_closed_induced_iff]
rw [hf.induced, is_closed_induced_iff']
rw [hf.induced, is_open_induced_iff]
simp only [Dense, hf.closure_eq_preimage_closure_image, mem_preimage]
simp [h, (· ∘ ·)]
rw [hg.right, hf.right, coinduced_compose]
rw [hgf.right, ← continuous_iff_coinduced_le]
apply continuous_coinduced_rng.comp hf
rw [continuous_iff_coinduced_le, continuous_iff_coinduced_le, hf.right, coinduced_compose]
simp only [← is_open_compl_iff, ← preimage_compl, hf.is_open_preimage]
intro s hs <;> rw [image_comp] <;> exact hg _ (hf _ hs)
rw [← image_univ]
exact hf _ is_open_univ
rw [map_map, hgf.comp_eq_id, map_id]
rw [hgx]
rw [← compl_subset_compl]
simp only [← interior_compl, ← preimage_compl, hf.interior_preimage_subset_preimage_interior]
simp only [frontier_eq_closure_inter_closure, preimage_inter, preimage_compl,
    hf.preimage_closure_eq_closure_preimage hfc]
rw [hu.interior_eq]
intro s hs
rw [image_comp]
exact hg _ (hf _ hs)
rw [hc.closure_eq]
simp only [open_embedding_iff_embedding_open, embedding_iff, inducing_iff_nhds, *, and_true_iff]
exact fun a =>
    le_antisymm (h₁.tendsto _).le_comap (@comap_map _ _ (𝓝 a) _ h₂ ▸ comap_mono (h₃.nhds_le _))
simp only [is_open_map_iff_nhds_le, ← @map_map _ _ _ _ f g, ← hg.map_nhds_eq,
    map_le_map_iff hg.inj]
simp only [open_embedding_iff_continuous_injective_open, ← hg.is_open_map_iff, ←
    hg.1.continuous_iff, hg.inj.of_comp_iff]
rw [range_comp, ← hg.closed_iff_image_closed] <;> exact hf.closed_range
intro x
simp
simp
change (of_le h ∘ A.proj) x = _
simp
rw [h2, h1]
rw [nhdsSet, ← range_diag, ← range_comp]
rfl
rw [← subset_interior_iff_mem_nhds_set, subset_interior_iff]
simp [mem_nhds_set_iff_exists, and_assoc']
rw [← subset_interior_iff_mem_nhds_set, interior_eq_iff_is_open.mpr hU]
rw [← principal_le_nhds_set.le_iff_eq, le_principal_iff, mem_nhds_set_iff_forall,
    is_open_iff_mem_nhds]
rw [is_open_empty.nhds_set_eq, principal_empty]
simp
rw [is_open_univ.nhds_set_eq, principal_univ]
simp only [nhdsSet, image_union, Sup_union]
rw [nhds_set_union]
exact union_mem_sup h₁ h₂
erw [← continuous_iff_continuous_on_univ]
exact e.continuous_to_fun
erw [← continuous_iff_continuous_on_univ]
exact e.continuous_inv_fun
cases e
subst e'
rfl
cases e
cases e'
cases h
rfl
rw [mem_singleton_iff, ← e.left_inv hx, ← h, hx']
simp
rw [e.left_inv hx]
rw [e.map_nhds_within_eq hx, e.image_source_inter_eq', e.target_inter_inv_preimage_preimage,
    e.nhds_within_target_inter (e.map_source hx)]
rw [e.map_nhds_eq hx]
rw [e.eventually_nhds _ hx]
refine' eventually_congr ((e.eventually_left_inverse hx).mono fun y hy => _)
rw [hy]
refine' Iff.trans _ eventually_map
rw [e.map_nhds_within_eq hx, e.image_source_inter_eq', e.nhds_within_target_inter (e.maps_to hx)]
rw [e.eventually_nhds_within _ hx]
refine'
    eventually_congr
      ((eventually_nhds_within_of_eventually_nhds <| e.eventually_left_inverse hx).mono fun y hy =>
        _)
rw [hy]
rw [iff_symm_preimage_eq, ← image_source_inter_eq, ← image_source_inter_eq']
rw [e.map_nhds_within_eq hx, h.image_eq, e.nhds_within_target_inter (e.map_source hx)]
simp only [mem_closure_iff_nhds_within_ne_bot, ← h.map_nhds_within_eq hx, map_ne_bot_iff]
rw [e.restr_source, hs.interior_eq]
rw [e.restr_to_local_equiv, hs.interior_eq]
apply eq_of_local_equiv_eq
rw [restr_to_local_equiv]
apply LocalEquiv.restr_eq_of_source_subset
exact interior_maximal h e.open_source
refine' LocalHomeomorph.ext _ _ (fun x => rfl) (fun x => rfl) _
simp [e.open_source.interior_eq, ← inter_assoc]
apply e'.continuous_to_fun.comp e.continuous_to_fun
rw [← h]
exact e.to_local_equiv.source_subset_preimage_target
apply e.continuous_inv_fun.comp e'.continuous_inv_fun
rw [h]
exact e'.to_local_equiv.target_subset_preimage_source
simp [inter_comm]
cases e <;> cases e' <;> rfl
simp [LocalEquiv.trans_source, (e.preimage_interior _).symm, hs.interior_eq]
rw [trans_of_set, restr_source_inter]
simp [LocalEquiv.trans_source, hs.interior_eq, inter_comm]
rw [of_set_trans, restr_source_inter]
constructor
· rw [e'.restr_source' _ e.open_source]
    rw [e.restr_source' _ e'.open_source]
    exact Set.inter_comm _ _
· rw [e.restr_source' _ e'.open_source]
    refine' (eq_on.trans _ h).trans _ <;> simp only [mfld_simps]
dsimp only [trans_to_local_equiv, prod_to_local_equiv] <;> apply LocalEquiv.prod_trans
rw [eq_comm, prod_eq_prod_of_nonempty h, eq_comm, @eq_comm _ e₂']
rw [e.open_source.inter_frontier_eq, (Hs.symm.frontier_right e'.open_source).inter_eq]
rw [e.open_source.inter_frontier_eq]
exact eq_on_empty _ _
rw [← continuous_within_at_univ, e.continuous_within_at_iff_continuous_within_at_comp_right h,
    preimage_univ, continuous_within_at_univ]
simp only [← e.symm_image_eq_source_inter_preimage h, ContinuousOn, ball_image_iff]
refine' forall₂_congr fun x hx => _
rw [e.continuous_within_at_iff_continuous_within_at_comp_right (h hx),
    e.symm_image_eq_source_inter_preimage h, inter_comm, continuous_within_at_inter]
exact IsOpen.mem_nhds e.open_source (e.map_target (h hx))
simp [e.left_inv hy.2]
simp [e.left_inv hx]
simp only [continuous_iff_continuous_on_univ]
exact e.continuous_on_iff_continuous_on_comp_left (Eq.symm h).Subset
rw [h]
exact mem_univ _
rw [h']
exact mem_univ _
simp only [local_homeomorph_subtype_coe, Subtype.range_coe_subtype, mfld_simps]
rfl
simp only [subtype_restr_def, mfld_simps]
unfold nhds
rfl
unfold nhds
rfl
unfold nhds
rfl
unfold nhds
rfl
unfold nhds
rfl
unfold nhds
rfl
unfold Sum.topologicalSpace <;> simp [hα.eq_bot, hβ.eq_bot]
unfold Sigma.topologicalSpace
simp [fun a => (h a).eq_bot]
rw [inf_principal_eq_bot_iff_comap, nhdsWithin, nhdsWithin, comap_inf, comap_principal,
    nhds_induced]
rw [← nhds_within_subtype_eq_bot_iff, preimage_compl, ← image_singleton,
    subtype.coe_injective.preimage_image]
rw [ne_bot_iff, ne_bot_iff, not_iff_not, nhds_ne_subtype_eq_bot_iff]
simp
simp only [is_open_iff, nonempty_iff_ne_empty, or_iff_not_imp_left]
simp [← is_open_compl_iff, is_open_iff']
simp [nhds_eq]
let t : TopologicalSpace (α × β) := Prod.topologicalSpace
have ha := continuous_Inf_dom ha continuous_id
have hb := continuous_Inf_dom hb continuous_id
have h_continuous_id := @Continuous.prod_map _ _ _ _ ta tb (Inf tas) (Inf tbs) _ _ ha hb
exact @Continuous.comp _ _ _ (id _) (id _) _ _ _ hf h_continuous_id
rw [Filter.prod, Prod.topologicalSpace, nhds_inf, nhds_induced, nhds_induced]
rw [nhds_prod_eq, mem_prod_iff]
cases x
rw [nhds_prod_eq, Filter.tendsto_prod_iff']
rw [nhds_prod_eq]
exact ha.prod hb
cases ab
exact ha.prod_nhds hb
rw [nhds_prod_eq, nhds_discrete α, nhds_discrete β, nhds_bot, Filter.prod_pure_pure]
rw [nhds_prod_eq, prod_mem_prod_iff]
rw [nhds_prod_eq, Filter.prod_comm, nhds_prod_eq] <;> rfl
rw [nhds_prod_eq] <;> exact Filter.Tendsto.prod_mk ha hb
rw [nhds_prod_eq] at h
exact h.curry
rw [← this]
exact
              is_open_Union fun v =>
                is_open_Union fun hv => generate_open.basic _ ⟨_, hu, _, hv, rfl⟩
rw [← this]
exact
              is_open_Union fun u =>
                is_open_Union fun hu => generate_open.basic _ ⟨_, hu, _, hv, rfl⟩
simp only [ContinuousAt, nhds_prod_eq, nhds_discrete α, pure_prod, tendsto_map'_iff, (· ∘ ·),
      uncurry, (h a).Tendsto]
rw [← prod_inf_prod, prod_principal_principal]
simp only [mem_interior_iff_mem_nhds, mem_prod, prod_mem_nhds_iff]
simp only [frontier, closure_prod_eq, interior_prod_eq, prod_diff_prod]
simp [frontier_prod_eq]
simp [frontier_prod_eq]
simp only [h₁.closure_eq, h₂.closure_eq, closure_prod_eq]
rw [closure_prod_eq]
exact ⟨hs x.1, ht x.2⟩
rw [Prod.topologicalSpace, Prod.topologicalSpace, hf.induced, hg.induced, induced_compose,
      induced_compose, induced_inf, induced_compose, induced_compose]
simp <;> exact fun h₁ h₂ => ⟨hf.inj h₁, hg.inj h₂⟩
rw [← is_open_compl_iff, compl_range_inl]
exact is_open_range_inr
rw [← is_open_compl_iff, compl_range_inr]
exact is_open_range_inl
simp only [continuous_sup_dom, continuous_coinduced_dom, Sum.elim_comp_inl, Sum.elim_comp_inr]
simp only [is_open_map_iff_nhds_le, Sum.forall, nhds_inl, nhds_inr, Filter.map_map]
simp only [is_open_map_sum, elim_inl, elim_inr]
rw [inducing_coe.dense_iff, SetCoe.forall]
rfl
rw [nhds_subtype_eq_comap, tendsto_comap_iff, Subtype.coe_mk]
simp only [continuous_infi_rng, continuous_induced_rng]
simp only [nhds_infi, nhds_induced, Filter.pi]
rw [nhds_pi, Filter.tendsto_pi]
rw [pi_def] <;> exact (is_open_bInter hi) fun a ha => (hs _ ha).Preimage (continuous_apply _)
rw [pi_def] <;>
    exact is_closed_Inter fun a => is_closed_Inter fun ha => (hs _ ha).Preimage (continuous_apply _)
rw [nhds_pi] at hs
exact mem_of_pi_mem_pi hs hi
rw [pi_def, bInter_mem hi]
exact fun a ha => (continuous_apply a).ContinuousAt (hs a ha)
rw [nhds_pi, pi_mem_pi_iff hI]
infer_instance
simp [hs]
simp [ht, Eq]
rw [hg]
apply mem_univ
simp_all [Set.pi]
simp only [is_open_supr_iff, is_open_coinduced]
simp only [← is_open_compl_iff, is_open_sigma_iff, preimage_compl]
cases x
apply Sigma.nhds_mk
rw [← bUnion_of_singleton s, preimage_Union₂]
simp only [← range_sigma_mk]
exact is_open_bUnion fun _ _ => is_open_range_sigma_mk
simp only [continuous_supr_dom, continuous_coinduced_dom]
simp only [Sigma.map, embedding_sigma_mk.continuous_iff]
simp only [is_open_map_iff_nhds_le, Sigma.forall, Sigma.nhds_eq, map_map]
simp only [inducing_iff_nhds, Sigma.forall, Sigma.nhds_mk, Sigma.map, ← map_sigma_mk_comap h₁,
    map_inj sigma_mk_injective]
simp only [embedding_iff, injective.sigma_map, inducing_sigma_map h, forall_and, h.sigma_map_iff]
simp only [open_embedding_iff_embedding_open, is_open_map_sigma_map, embedding_sigma_map h,
    forall_and]
rw [noetherian_space_iff, CompleteLattice.well_founded_iff_is_Sup_finite_compact,
    CompleteLattice.is_Sup_finite_compact_iff_all_elements_compact]
exact forall_congr' opens.is_compact_element_iff
refine' OrderIso.compl (Set α)

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers [] [] [] [] [] [])
     (Command.theorem
      "theorem"
      (Command.declId `noetherian_space_tfae [])
      (Command.declSig
       []
       (Term.typeSpec
        ":"
        (Term.app
         `Tfae
         [(«term[_]»
           "["
           [(Term.app `NoetherianSpace [`α])
            ","
            (Term.app
             `WellFounded
             [(Term.fun
               "fun"
               (Term.basicFun
                [`s `t]
                [(Term.typeSpec ":" (Term.app `Closeds [`α]))]
                "=>"
                («term_<_» `s "<" `t)))])
            ","
            (Term.forall
             "∀"
             [`s]
             [(Term.typeSpec ":" (Term.app `Set [`α]))]
             ","
             (Term.app `IsCompact [`s]))
            ","
            (Term.forall
             "∀"
             [`s]
             [(Term.typeSpec ":" (Term.app `Opens [`α]))]
             ","
             (Term.app `IsCompact [(Term.typeAscription "(" `s ":" [(Term.app `Set [`α])] ")")]))]
           "]")])))
      (Command.declValSimple
       ":="
       (Term.
exact Set.Finite.subset ((Set.Finite.intro inferInstance).image _) this
simp
exact this.antisymm (hK.2 (hS₁ ⟨s, hs⟩) this)
    simpa
simp [compl_inter, hunion ht₁ ht₂]
apply hι.elim
intro i₀
let Z' i := Z i
exact this.mono (Inter_mono fun i => inter_subset_left (Z i) (Z i₀))
rw [H, inter_empty]
rw [nonempty_iff_ne_empty] at this
contradiction
rw [empty_mem_iff_bot, hf x hxs]
rw [mem_inf_iff] at this <;> exact this
rw [ht, inter_comm]
exact inter_mem_nhds_within _ ht₁
rw [mem_Inter₂] at hx
exact hx i hit
rw [← bUnion_univ] <;> exact finite_univ.is_compact_bUnion fun i _ => h i
simp [nhds_discrete]
cases b <;> assumption
rw [e]
intro l hne hle
simp [has_basis_coclosed_compact.mem_iff, and_assoc']
simp only [mem_coclosed_compact, compl_subset_comm]
change s
simp
simp
rw [eq_top_iff]
exact s
simp only [Filter.cocompact_eq_cofinite, Filter.cofiniteNeBot]

-- Note: We can't make this into an instance because it loops with `finite.compact_space`.
rw [← image_univ] <;> exact is_compact_univ.image hf
rw [map_principal]
simp [πY]
rw [nhds_prod_eq, Filter.prod]
ac_rfl
rw [Filter.push_pull]
rw [inf_comm]
rw [hf.nhds_eq_comap]
rw [is_compact_iff_is_compact_in_subtype, image_univ, Subtype.range_coe] <;> rfl
rw [← univ_prod_univ]
exact is_compact_univ.prod is_compact_univ
rw [← range_inl_union_range_inr]
exact (is_compact_range continuous_inl).union (is_compact_range continuous_inr)
refine' ⟨_⟩
rw [sigma.univ]
exact is_compact_Union fun i => is_compact_range continuous_sigma_mk

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
simp [← Filter.cocompact_ne_bot_iff, ← Filter.coprod_cocompact, Filter.coprod_ne_bot_iff]
refine' fun i => h i (f.map _) (mem_map.2 _)
exact mem_of_superset hfs fun x hx => hx i
rw [← pi_univ univ]
exact is_compact_univ_pi fun i => is_compact_univ
rw [← range_quot_mk]
exact is_compact_range continuous_quot_mk
intro x
rw [hf.to_embedding.to_inducing.nhds_eq_comap]
exact (compact_basis_nhds _).comap _
intro x
rw [hf.to_embedding.to_inducing.nhds_eq_comap]
exact
      ((compact_basis_nhds _).restrict_subset <| hf.open_range.mem_nhds <| mem_range_self _).comap _
simp
rw [compactCovering, Union_accumulate]
exact (Classical.choose_spec SigmaCompactSpace.exists_compact_covering).2
simp only [find_shiftr, not_le, Nat.lt_succ_self]
rw [IsClopen, ← closure_eq_iff_is_closed, ← interior_eq_iff_is_open, frontier, diff_eq_empty]
refine' ⟨fun h => (h.2.trans h.1.symm).Subset, fun h => _⟩
exact
    ⟨interior_subset.antisymm (subset_closure.trans h),
      (h.trans interior_subset).antisymm subset_closure⟩
rw [continuous_on_iff_continuous_restrict, ← continuous_bool_indicator_iff_clopen]
rfl
rw [← closure_eq_iff_is_closed, eq_comm]
exact subset_closure.antisymm (H.2 H.1.closure subset_closure)
simp
rw [hg₁ (mem_image_of_mem _ hle₁), abs_of_nonneg (sub_nonneg.2 hle₁)]
rw [hg₂ (mem_image_of_mem _ hle₂), abs_sub_comm, abs_of_nonneg (sub_nonneg.2 hle₂)]
rw [g_succ, dist_eq_norm', add_sub_cancel']
rw [dist_eq_norm', one_div, div_eq_inv_mul]
ac_rfl
rw [hsub, add_sub_cancel'_right]
          
  /- Now we deal with the case `∀ x, f x ≠ b`. The proof is the same as in the first case, with
    minor modifications that make it hard to deduplicate code. -/
rw [← hsub, sub_sub_cancel]
rw [← hsub, sub_sub_cancel]
cases s
cases t
congr
simp [infi_def]
simp [infi_def]
simp [← SetLike.mem_coe]
simp only [coe_sup, coe_infi, coe_Inf, Set.union_Inter₂]
simp [closeds.compl_compl]
simp [opens.compl_compl]
simp [opens.compl_compl]
simp [closeds.compl_compl]
rw [← s.compl_compl, ← is_atom_dual_iff_is_coatom]
change IsAtom (closeds.compl_order_iso α s.compl) ↔ _
rw [(closeds.compl_order_iso α).is_atom_iff, closeds.is_atom_iff]
trace
    "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr «expr∃ , »((x), _)]]"
exact closeds.compl_bijective.injective.eq_iff.symm
cases s
cases t
congr
cases s
cases t
congr
simp only [compacts.carrier_eq_coe, compacts.coe_prod, interior_prod_eq]
exact K.interior_nonempty.prod L.interior_nonempty
rw [supr_def]
simp
simp [supr_def]
rw [← mem_coe]
simp
simp only [coe_inf, coe_supr, coe_Sup, Set.inter_Union₂]
rw [Set.range_inclusion i]
exact U.property.preimage continuous_subtype_val
rw [← subtype.coe_injective.eq_iff, opens.coe_bot, ← Set.not_nonempty_iff_eq_empty]
rw [Ne.def, ← opens.not_nonempty_iff_eq_bot, not_not]
simp only [coe_Sup, preimage_Union, coe_mk, mem_image, Union_exists, bUnion_and',
        Union_Union_eq_right]
rw [← comp_apply, h, comp_apply]
rw [← comp_apply, h, comp_apply]
rw [← comp_apply, h, comp_apply]
rw [nhds_prod_eq] <;> exact hf.prod_mk hg
simp [lt_iff_not_ge, -not_le] <;> exact (is_closed_le hg hf).is_open_compl
simp only [interior_Ioo, subset_closure]
rw [inter_comm, Ioi_inter_Iio] <;> exact Ioo_subset_Ioo_left H.1
simp only [ContinuousWithinAt, nhds_within_Ioc_eq_nhds_within_Ioi h]
simp only [ContinuousWithinAt, nhds_within_Ioo_eq_nhds_within_Ioi h]
simp only [ContinuousWithinAt, nhds_within_Ico_eq_nhds_within_Iio h]
simp only [ContinuousWithinAt, nhds_within_Ioo_eq_nhds_within_Iio h]
simp only [inter_comm, Ici_inter_Iio, Ico_subset_Ico_left H.1]
simp only [ContinuousWithinAt, nhds_within_Icc_eq_nhds_within_Ici h]
simp only [ContinuousWithinAt, nhds_within_Ico_eq_nhds_within_Ici h]
simp only [ContinuousWithinAt, nhds_within_Icc_eq_nhds_within_Iic h]
simp only [ContinuousWithinAt, nhds_within_Ioc_eq_nhds_within_Iic h]
simp only [min_def]
exact hf.if_le hg hf hg fun x => id
constructor
simp only [Pi.le_def, set_of_forall]
exact
    is_closed_Inter fun i =>
      is_closed_le ((continuous_apply i).comp continuous_fst)
        ((continuous_apply i).comp continuous_snd)
rw [t.topology_eq_generate_intervals] <;> rfl
rw [@is_open_iff_generate_intervals α _ _ t] <;> exact generate_open.basic _ ⟨a, Or.inl rfl⟩
rw [@is_open_iff_generate_intervals α _ _ t] <;> exact generate_open.basic _ ⟨a, Or.inr rfl⟩
simp [nhds_eq_order a, tendsto_inf, tendsto_infi, tendsto_principal]
have : ∃ u, u ∈ ioi a := hu
have : ∃ l, l ∈ iio a := hl
simp only [nhds_eq_order, inf_binfi, binfi_inf, *, inf_principal, Ioi_inter_Iio]
rfl
rw [nhds_order_unbounded hu hl] <;>
    exact
      tendsto_infi.2 fun l =>
        tendsto_infi.2 fun hl =>
          tendsto_infi.2 fun u => tendsto_infi.2 fun hu => tendsto_principal.2 <| h l u hl hu
constructor
conv in (𝓝 f).smallSets => rw [nhds_pi, Filter.pi]
simp only [small_sets_infi, small_sets_comap, tendsto_infi, tendsto_lift', (· ∘ ·),
    mem_powerset_iff]
intro i s hs
have : tendsto (fun g : ∀ i, α i => g i) (𝓝 f) (𝓝 (f i)) := (continuous_apply i).Tendsto f
refine' (tendsto_lift'.1 ((this.comp tendsto_fst).icc (this.comp tendsto_snd)) s hs).mono _
exact fun p hp g hg => hp ⟨hg.1 _, hg.2 _⟩
rw [nhdsWithin, nhds_eq_order]
refine' le_antisymm (inf_le_inf_right _ inf_le_right) (le_inf (le_inf _ inf_le_left) inf_le_right)
exact inf_le_right.trans (le_infi₂ fun l hl => principal_mono.2 <| Ici_subset_Ioi.2 hl)
simp only [nhds_within_Ici_eq'', binfi_inf ha, inf_principal, Iio_inter_Ici]
simp only [nhds_within_Iic_eq'', binfi_inf ha, inf_principal, Ioi_inter_Iic]
rw [← Icc_union_Ioo_eq_Ico le_rfl hab, H, union_empty]
simp
intro x hx
intro x hx
refine' mem_of_superset (set_pi_mem_nhds (Set.to_finite _) fun i _ => _) (pi_univ_Iio_subset a)
exact Iio_mem_nhds (ha i)
refine' mem_of_superset (set_pi_mem_nhds (Set.to_finite _) fun i _ => _) (pi_univ_Ioc_subset a b)
exact Ioc_mem_nhds (ha i) (hb i)
refine' mem_of_superset (set_pi_mem_nhds (Set.to_finite _) fun i _ => _) (pi_univ_Ico_subset a b)
exact Ico_mem_nhds (ha i) (hb i)
refine' mem_of_superset (set_pi_mem_nhds (Set.to_finite _) fun i _ => _) (pi_univ_Ioo_subset a b)
exact Ioo_mem_nhds (ha i) (hb i)
simp [Ioi]
simp [Iio]
simp [nhds_eq_infi_abs_sub, abs_sub_comm a]
simp only [abs_sub_comm, mem_principal_self]
simp [ε_pos]
conv in _ + _ => rw [add_comm]
exact hg.add_at_top hf
conv in _ + _ => rw [add_comm]
exact hg.add_at_bot hf
cases n
· exact (hf 0 l hl).1
· exact (hf n.succ (u n) (I n)).1
apply subset.antisymm
· exact closure_minimal Ioi_subset_Ici_self is_closed_Ici
· rw [← diff_subset_closure_iff, Ici_diff_Ioi_same, singleton_subset_iff]
    exact is_glb_Ioi.mem_closure h
apply subset.antisymm
· exact closure_minimal Ioc_subset_Icc_self is_closed_Icc
· apply subset.trans _ (closure_mono Ioo_subset_Ioc_self)
    rw [closure_Ioo hab]
apply subset.antisymm
· exact closure_minimal Ico_subset_Icc_self is_closed_Icc
· apply subset.trans _ (closure_mono Ioo_subset_Ico_self)
    rw [closure_Ioo hab]
rw [← compl_Iio, interior_compl, closure_Iio' ha, compl_Iic]
rw [← Ici_inter_Iic, interior_inter, interior_Ici, interior_Iic, Ioi_inter_Iio]
rw [← Ici_inter_Iio, interior_inter, interior_Ici, interior_Iio, Ioi_inter_Iio]
rw [← Ioi_inter_Iic, interior_inter, interior_Ioi, interior_Iic, Ioi_inter_Iio]
simp [frontier, ha]
simp [frontier, ha]
simp [frontier, closure_Ioi' ha, Iic_diff_Iio, Icc_self]
simp [frontier, closure_Iio' ha, Iic_diff_Iio, Icc_self]
simp [frontier, le_of_lt h, Icc_diff_Ioo_same]
rw [frontier, closure_Ioo h.ne, interior_Ioo, Icc_diff_Ioo_same h.le]
rw [frontier, closure_Ico h.ne, interior_Ico, Icc_diff_Ioo_same h.le]
rw [frontier, closure_Ioc h.ne, interior_Ioc, Icc_diff_Ioo_same h.le]
rw [← map_coe_Ioo_at_top h, tendsto_map'_iff]
rw [← map_coe_Ioo_at_bot h, tendsto_map'_iff]
rw [← map_coe_Ioi_at_bot, tendsto_map'_iff]
rw [← map_coe_Iio_at_top, tendsto_map'_iff]
rw [← comap_coe_Ioo_nhds_within_Iio, tendsto_comap_iff]
rw [← comap_coe_Ioo_nhds_within_Ioi, tendsto_comap_iff]
rw [← comap_coe_Ioi_nhds_within_Ioi, tendsto_comap_iff]
rw [← comap_coe_Iio_nhds_within_Iio, tendsto_comap_iff]
rw [supr, Mf.map_Sup_of_continuous_at' Cf (range_nonempty g), ← range_comp, supr]
rw [supr, Mf.map_Sup_of_continuous_at Cf fbot, ← range_comp, supr]
refine' ((is_lub_cSup (ne.image f) (Mf.map_bdd_above H)).unique _).symm
refine' (is_lub_cSup Ne H).is_lub_of_tendsto (fun x hx y hy xy => Mf xy) Ne _
exact Cf.mono_left inf_le_left
rw [supr, Mf.map_cSup_of_continuous_at Cf (range_nonempty _) H, ← range_comp, supr]
simp [h]
rw [he x hx] <;> exact e.map_source' hx
        left_inv'
rw [he x hx] <;> exact e.left_inv' hx
        right_inv'
rw [he _ (e.map_target' hy)] <;> exact e.right_inv' hy
        continuous_to_fun
simp only [IsLocallyHomeomorph, IsLocallyHomeomorphOn, Set.mem_univ, forall_true_left]
simp [hfs hx]
simp [hft hx]
intro x y h
have : {x} ∈ (pure x : Ultrafilter α) := singleton_mem_pure
rw [h] at this
exact (mem_singleton_iff.mp (mem_pure.mp this)).symm
rw [le_principal_iff] <;> exact univ_mem
let b' : Ultrafilter (Ultrafilter α) := b.map pure
have t : ↑b' ≤ 𝓝 b := ultrafilter_converges_iff.mpr (bind_pure _).symm
rw [← h]
have := (continuous_ultrafilter_extend f).Tendsto b
refine' le_trans _ (le_trans (map_mono t) this)
change _ ≤ map (Ultrafilter.extend f ∘ pure) ↑b
rw [ultrafilter_extend_extends]
exact le_rfl
unfold StoneCech <;> infer_instance
unfold StoneCech <;> infer_instance
rw [ultrafilter_converges_iff] <;> exact (bind_pure _).symm
simp [h]
rw [sInter_image]
rw [sInter_range]
rw [inter_eq_Inter]
exact is_Gδ_Inter (Bool.forall_bool.2 ⟨ht, hs⟩)
simp
rw [← bUnion_of_singleton s, compl_Union₂]
exact is_Gδ_bInter hs fun x _ => is_Gδ_compl_singleton x
rw [← seq_closure_eq_closure]
rfl
refine' ⟨fun s x hcx => _⟩
specialize h (· ∉ s) x
rw [← closure_eq_iff_is_closed, ← seq_closure_eq_closure, hs.seq_closure_eq]
simp only [← is_compact_univ_iff, seq_compact_space_iff,
    UniformSpace.is_compact_iff_is_seq_compact]
simp
simp only [exists_subset_range_iff, sUnion_image]
simp only [mem_set_of_eq, and_comm' (l ∈ _), infi_and, infi_range, Filter.lift', Filter.lift,
      (· ∘ ·), mem_Iic, le_principal_iff]
simp only [nhds_eq', tendsto_lift', mem_set_of_eq]
rw [nhds_eq]
exact h.lift' monotone_principal.Iic
simp [nhds_eq, lift'_bot monotone_principal.Iic]
simp [nhds_eq]
rw [← principal_singleton, nhds_principal, principal_singleton, Iic_pure]
simp only [nhds_eq]
apply lift'_infi_of_map_univ <;> simp
simp only [nhds_eq, sInter_lift'_sets monotone_principal.Iic, Iic, le_principal_iff, ←
    set_of_forall, ← Filter.le_def]
refine' ⟨fun h => _, fun h => monotone_nhds h⟩
rw [← Iic_subset_Iic, ← Inter_nhds, ← Inter_nhds]
exact sInter_subset_sInter h
rw [mem_interior_iff_mem_nhds, mem_nhds_iff]
simp only [closure_eq_compl_interior_compl, Filter.mem_interior, mem_compl_iff, not_exists,
    not_forall, not_not, exists_prop, not_and, and_comm', subset_def, mem_Iic, le_principal_iff]
simp only [specializes_iff_closure_subset, Filter.closure_singleton, Ici_subset_Ici]
simp only [at_top, nhds_infi, nhds_principal]
simp only [nhds_at_top, tendsto_infi, tendsto_principal, mem_Iic, le_principal_iff]
simp only [(nhds_basis_opens x).nhds.eq_binfi, infi_and, @infi_comm _ (_ ∈ _)]
simp (config := { contextual := true }) only [nhds_nhds, comap_infi, comap_principal,
        Iic_principal, preimage_set_of_eq, ← mem_interior_iff_mem_nhds, set_of_mem_eq,
        IsOpen.interior_eq]
let U := f
intro a
simp [G]
simp
simp
change f.map (fun a b => if a = b then (0 : Fin 2) else 1) x = _
rw [h, LocallyConstant.coe_comap _ _ (C.π.app j).Continuous]
change TotallyDisconnectedSpace
apply limits.comp_preserves_limits ProfiniteCat.toTop (forget TopCat)
intro A B f hf <;> exact ProfiniteCat.is_iso_of_bijective _ ((is_iso_iff_bijective f).mp hf)
rw [continuous_iff_is_closed]
intro S hS
rw [← E.image_eq_preimage]
exact IsClosedMap f S hS
intro A B f hf <;> exact CompHausCat.is_iso_of_bijective _ ((is_iso_iff_bijective f).mp hf)
show CompactSpace
unfold open_nhds
infer_instance
simp
simp
simp
simp
dsimp
erw [← S.w f]
rfl
refine' is_limit.of_faithful forget (types.limit_cone_is_limit _) (fun s => ⟨_, _⟩) fun s => rfl
exact
    continuous_iff_coinduced_le.mpr
      (le_infi fun j =>
        coinduced_le_iff_le_induced.mp <|
          (continuous_iff_coinduced_le.mp (s.π.app j).Continuous : _))
refine'
    is_colimit.of_faithful forget (types.colimit_cocone_is_colimit _) (fun s => ⟨_, _⟩) fun s => rfl
exact
    continuous_iff_le_induced.mpr
      (supr_le fun j =>
        coinduced_le_iff_le_induced.mp <|
          (continuous_iff_coinduced_le.mp (s.ι.app j).Continuous : _))
simp [pi_iso_pi]
have := pi_iso_pi_inv_π α i
rw [iso.inv_comp_eq] at this
exact concrete_category.congr_hom this x
simp [sigma_iso_sigma]
rw [← sigma_iso_sigma_hom_ι_apply, ← comp_app]
simp
simp [iso.inv_comp_eq]
simp [iso.inv_comp_eq]
constructor
simp only [prod_topology, induced_compose, ← coe_comp, limits.prod.map_fst, limits.prod.map_snd,
    induced_inf]
simp only [coe_comp]
rw [← @induced_compose _ _ _ _ _ f, ← @induced_compose _ _ _ _ _ g, ← hf.induced, ← hg.induced]
rw [← iso.eq_inv_comp, pullback_iso_prod_subtype_inv_fst]
rw [← iso.eq_inv_comp, pullback_iso_prod_subtype_inv_snd]
simp [prod_topology, pullback_topology, induced_compose, ← coe_comp]
apply (TopCat.mono_iff_injective _).mp H₃
simp only [← comp_apply, eq₁, eq₂]
simp only [comp_apply, hx₁, hx₂]
simp only [← comp_apply, pullback.condition]
simp
simp
simp
simp
rw [pullback_fst_range]
exact ⟨_, (H (Set.mem_range_self x)).some_spec.symm⟩
rw [pullback_snd_range]
exact ⟨_, (H (Set.mem_range_self x)).some_spec⟩
simp
simp
rw [eq_compl_iff_is_compl.mpr h₃.symm]
exact fun _ => or_not
rw [colimit_is_open_iff.{u}]
constructor
· intro H
    exact H _
· intro H j
    cases j
    · rw [← colimit.w F walking_parallel_pair_hom.left]
      exact (F.map walking_parallel_pair_hom.left).continuous_to_fun.is_open_preimage _ H
    · exact H
rw [h]
exact V
apply Finset.mem_union_left
rw [Finset.mem_image]
refine' ⟨f, hf, rfl⟩
apply Finset.mem_union_right
rw [Finset.mem_image]
refine' ⟨f, hf, rfl⟩
simp only [true_or_iff, eq_self_iff_true, Finset.mem_insert]
simp only [eq_self_iff_true, or_true_iff, Finset.mem_insert, Finset.mem_singleton]
rw [this, CategoryTheory.epi_iff_surjective]
rfl
rw [this, CategoryTheory.mono_iff_injective]
rfl
simp
apply Subtype.eq
rw [supr_def, supr_def, map_obj]
dsimp
rw [Set.preimage_Union]
rfl
simp [map, Set.preimage_preimage]
intro _ _ _
simp
simp [map, Set.preimage_preimage]
intro _ _ _
simp
simp
rw [← is_open_compl_iff]
constructor
· intro cond F h
simp
exact claim6 _ this
  -- Finish
  apply claim4.finite_inter_mem
  intro t ht
  exact finite_inter_closure.basic (@hT t ht)
rw [is_closed_iff]
intro F hF
exact cl_cl _ ⟨F, hF, rfl⟩
intro A hA h
intro A hA
exact claim1 (cl A) (is_closed_cl A) (mem_of_superset hA (subset_cl A))
  -- T0 is closed under intersections.
simp [basic_inter]
rw [t2_iff_ultrafilter]
intro _ _ F hx hy
rw [← str_eq_of_le_nhds _ _ hx, ← str_eq_of_le_nhds _ _ hy]
rw [continuous_iff_ultrafilter]
intro x _ h
rw [tendsto, ← coe_map]
apply le_nhds_of_str_eq
rw [← str_hom_commute, str_eq_of_le_nhds _ x h]
intro U F h1 hU
exact c1 ▸ is_open_iff_ultrafilter.mp hU _ h1 _ (Ultrafilter.le_nhds_Lim _)
apply mem_of_superset this
intro P hP
exact c2 U P hP hU
rw [is_open_iff_ultrafilter'] at h
exact h
rw [is_open_iff_ultrafilter']
intro _ h2
exact h1 _ h2
apply equivalence.of_fully_faithfully_ess_surj _
exact compactumToCompHaus.full
exact compactumToCompHaus.faithful
exact compactumToCompHaus.ess_surj
cases f
cases g
dsimp
apply Continuous.comp <;> assumption
infer_instance
apply Subtype.eq
funext x
exact congr_fun (completion.extension_comp_coe f.property) x
dsimp
erw [extension_comp_coe]
apply Subtype.eq
funext x
cases f
exact
              @completion.extension_coe _ _ _ _ _ (CpltSepUniformSpaceCat.separated_space _)
                f_property _
apply hom_ext
funext x
dsimp
erw [coe_comp, ← completion.extension_map]
rfl
exact g.property
exact f.property
dsimp at h
exact opens.comap_injective (Quiver.Hom.op_inj h)
simp only [locally_finite_iff_small_sets, ← forall_and, ← finite_preimage_inl_and_inr,
    preimage_set_of_eq, (· ∘ ·), eventually_and]
simp only [← (Equiv.optionEquivSumPUnit.{u} ι).symm.locally_finite_comp_iff, locally_finite_sum,
    locally_finite_of_finite, and_true_iff]
rfl
rw [nhds_generate_from] <;>
    exact
      tendsto_infi.2 fun s => tendsto_infi.2 fun ⟨hbs, hsg⟩ => tendsto_principal.2 <| h s hsg hbs
rw [nhds_discrete, mem_pure]
simp only [is_open_iff_nhds, le_principal_iff]
exact fun hs a ha => h _ <| hs _ ha
constructor <;> intro h
· intro x
    rw [nhds_discrete]
· constructor
    apply eq_of_nhds_eq_nhds
    simp [h, nhds_discrete]
rw [discrete_topology_iff_nhds]
apply forall_congr' fun x => _
rw [nhdsWithin, inf_principal_eq_bot, compl_compl]
constructor <;> intro h
· rw [h]
    exact singleton_mem_pure
· exact le_antisymm (le_pure_iff.mpr h) (pure_le_nhds x)
simp only [preimage_compl, compl_inj_iff]
rw [preimage_univ] <;> exact t.is_open_univ
  is_open_inter s₁ s₂ h₁ h₂
rw [preimage_inter] <;> exact t.is_open_inter _ _ h₁ h₂
  is_open_sUnion s h
rw [← e.symm.induced_symm, e.symm_symm]
rw [induced_generate_from_eq]
apply le_generate_from
simp only [mem_image, and_imp, forall_apply_eq_imp_iff₂, exists_imp]
exact h
rw [le_nhds_iff]
exact ⟨fun H s hs has => H _ has hs, fun H s has hs => H _ hs has⟩
rw [is_open_singleton_iff_nhds_eq_pure]
exact nhds_adjoint_nhds_of_ne a f hb
change _ ↔ _ ∧ ∀ b : α, b ≠ a → IsOpen {b}
rw [le_nhds_adjoint_iff', and_congr_right_iff]
apply fun h => forall_congr' fun b => _
rw [@is_open_singleton_iff_nhds_eq_pure α t b]
rw [continuous_def]
intro s h
exact ⟨_, h, rfl⟩
simp only [continuous_iff_le_induced, induced_compose]
rw [continuous_def]
intro s h
exact h
simp only [continuous_iff_coinduced_le, coinduced_compose]
rw [continuous_def] at h₂⊢
intro s h
exact h₁ _ (h₂ s h)
rw [continuous_def] at h₂⊢
intro s h
exact h₂ s (h₁ s h)
simp only [continuous_iff_le_induced, sup_le_iff]
simp only [continuous_iff_le_induced, Sup_le_iff]
simp only [continuous_iff_le_induced, supr_le_iff]
simp only [continuous_iff_coinduced_le, le_inf_iff]
simp only [continuous_iff_coinduced_le, le_Inf_iff]
simp only [continuous_iff_coinduced_le, le_infi_iff]
rw [ueq] <;> exact usub
rw [h, nhds_induced]
rw [nhds_induced, map_comap_of_surjective hf]
rw [nhds_induced, Filter.map_comap, nhdsWithin]
rw [nhds_induced, Filter.map_comap_of_mem h]
simp only [mem_closure_iff_frequently, nhds_induced, frequently_comap, mem_image, and_comm']
simp only [← closure_subset_iff_is_closed, subset_def, closure_induced]
simp [@and_comm (_ ∈ _)]
simp [hs, preimage, eq_true_iff, h]
simp [set_of_is_open_supr]
simp [← is_open_compl_iff, is_open_supr_iff]
rw [nhds_list, List.traverse_nil _] <;> infer_instance
rw [nhds_list, List.traverse_cons _, ← nhds_list] <;> infer_instance
rw [nhds_cons, tendsto, Filter.map_prod] <;> exact le_rfl
simp only [nhds_cons, Filter.prod_eq, (Filter.map_def _ _).symm,
      (Filter.seq_eq_filter_seq _ _).symm]
simp [-Filter.seq_eq_filter_seq, -Filter.map_def, (· ∘ ·), functor_norm]
rw [tendsto_cons_iff] <;> exact h_cons l a (tendsto_nhds l)
simp only [ContinuousAt, nhds_discrete]
refine' tendsto_nhds _ _
· exact tendsto_pure_pure _ _
· intro l a ih
    dsimp only [List.length]
    refine' tendsto.comp (tendsto_pure_pure (fun x => x + 1) _) _
    refine' tendsto.comp ih tendsto_snd
simp
simp only [nhds_cons, Filter.prod_eq, ← Filter.map_def, ← Filter.seq_eq_filter_seq]
simp [-Filter.seq_eq_filter_seq, -Filter.map_def, (· ∘ ·), functor_norm]
rw [ContinuousAt, nhds_prod_eq] <;> exact tendsto_insert_nth'
rw [nhds_nil] <;> exact tendsto_pure_nhds _ _
rw [tendsto_cons_iff] <;> exact tendsto_snd
rw [tendsto_cons_iff]
dsimp [remove_nth]
exact tendsto_fst.cons ((@tendsto_remove_nth n l).comp tendsto_snd)
unfold Vector <;> infer_instance
simp [tendsto_subtype_rng, ← Subtype.val_eq_coe, cons_val]
exact tendsto_fst.cons (tendsto.comp continuous_at_subtype_coe tendsto_snd)
rw [insert_nth, tendsto_subtype_rng]
simp [insert_nth_val]
exact
      List.tendsto_insert_nth tendsto_fst (tendsto.comp continuous_at_subtype_coe tendsto_snd : _)
rw [ContinuousAt, nhds_prod_eq] <;> exact tendsto_insert_nth
rw [ContinuousAt, remove_nth, tendsto_subtype_rng]
simp only [← Subtype.val_eq_coe, Vector.remove_nth_val]
exact tendsto.comp List.tendsto_remove_nth continuous_at_subtype_coe
simp [leftCoset, rightCoset, (image_comp _ _ _).symm, Function.comp, mul_assoc]
simp [leftCoset, rightCoset, (image_comp _ _ _).symm, Function.comp, mul_assoc]
simp [leftCoset, rightCoset, (image_comp _ _ _).symm, Function.comp, mul_assoc]
simp [leftCoset]
simp [rightCoset]
rw [← SetLike.mem_coe, ← ha] <;> exact mem_own_left_coset s a
rw [← SetLike.mem_coe, ← ha] <;> exact mem_own_right_coset s a
simp [Eq.symm, hb]
simp
simp [Eq.symm, hb]
simp
simp [mem_left_coset_iff, mul_mem_cancel_left (s.inv_mem ha)]
simp [mem_right_coset_iff, mul_mem_cancel_right (s.inv_mem ha)]
simp [mem_left_coset_iff, mem_right_coset_iff] <;> rw [N.mem_comm_iff]
rw [← mem_right_coset_iff, ← h] <;> exact mem_left_coset g ha
simp only [inv_mul_eq_iff_eq_mul, eq_mul_inv_iff_mul_eq]
simp [SetLike.exists]
simp only [eq_iff_iff]
apply left_rel_apply
rw [left_rel_eq]
exact ‹DecidablePred (· ∈ s)› _
simp only [mul_inv_eq_iff_eq_mul, eq_inv_mul_iff_mul_eq]
simp [SetLike.exists]
simp only [eq_iff_iff]
apply right_rel_apply
rw [right_rel_eq]
exact ‹DecidablePred (· ∈ s)› _
simp only [inv_inv]
exact Quotient.exact' rfl
simp only [inv_inv]
exact Quotient.exact' rfl
rw [left_rel_apply]
rw [SetLike.coe_mk, mul_inv_cancel_left]
rw [mem_left_coset_iff, Set.mem_setOf_eq, eq_comm, QuotientGroup.eq, SetLike.mem_coe]
simp
simp
simp
simp
rw [← eq_class_eq_left_coset]
show
          (_root_.subtype fun x : α => Quotient.mk' x = L)
rw [left_rel_apply] at h⊢
change (f a.1 * b)
rw [← Fintype.card_prod] <;> exact Fintype.card_congr Subgroup.groupEquivQuotientTimesSubgroup
simp [card_eq_card_quotient_mul_card_subgroup s, @dvd_mul_right ℕ]
simp [h hx ha, hx]
simp
simp [h hx ha]
exact monoid_hom.ext_iff.mp this
rw [tree_hom, Unique.default_eq]
rw [loop_of_hom, ← category.assoc, is_iso.comp_inv_eq, category.id_comp]
cases H
· rw [tree_hom_eq T (path.cons default ⟨Sum.inl e, H⟩), hom_of_path]
    rfl
· rw [tree_hom_eq T (path.cons default ⟨Sum.inr e, H⟩), hom_of_path]
    simp only [is_iso.inv_hom_id, category.comp_id, category.assoc, tree_hom]
intro a
rw [loop_of_hom, category.id_comp, is_iso.hom_inv_id, ← End.one_def, f.map_one, id_as_one]
intros
rw [comp_as_mul, ← f.map_mul]
simp only [is_iso.inv_hom_id_assoc, loop_of_hom, End.mul_def, category.assoc]
simp only [this, tree_hom, comp_as_mul, inv_as_inv, loop_of_hom, inv_one, mul_one,
            one_mul, functor.map_inv, functor.map_comp]
decide
rw [h, swap_mul_self_mul]
cases hστ <;> cases hτυ <;> try rw [hστ, hτυ, swap_mul_self_mul] <;> simp [hστ, hτυ]
cases nonempty_fintype s <;>
    exact fun x hx =>
      set.mem_to_finset.mp <|
        perm_inv_on_of_perm_on_finset
          (fun a ha => set.mem_to_finset.mpr (h (set.mem_to_finset.mp ha)))
          (set.mem_to_finset.mpr hx)
rw [hστ.commute.mul_pow, disjoint.mul_eq_one_iff (hστ.pow_disjoint_pow n n)]
intro b
rw [List.prod_nil]
exact (not_not.1 (mt h (List.not_mem_nil _))).symm
simp
rw [List.prod_cons, m.2.1, ← mul_assoc, mul_def (swap x (f x)), swap_swap, ← one_def,
          one_mul]
simp
rw [mul_inv_rev, swap_inv, swap_inv, mul_assoc (swap w y), mul_assoc (swap w y), ←
        mul_assoc _ (swap x z), swap_mul_swap_mul_swap hwx hwz, ← mul_assoc,
        swap_mul_swap_mul_swap hwz.symm hyz.symm]
rw [swap_comm y z, h hyz.symm hwy]
simp only [fin_pairs_lt, Fin.lt_iff_coe_lt_coe, true_and_iff, mem_attach_fin, mem_range, mem_univ,
    mem_sigma]
dsimp [sign_bij_aux]
rw [apply_inv_self, apply_inv_self, if_pos (mem_fin_pairs_lt.1 ha)]
dsimp [sign_bij_aux]
rw [apply_inv_self, apply_inv_self, if_neg (mem_fin_pairs_lt.1 ha).le.not_lt]
rw [sign_bij_aux, dif_pos h, if_neg h.not_le, apply_inv_self, apply_inv_self,
          if_neg (mem_fin_pairs_lt.1 hab).not_le]
rw [sign_bij_aux, if_pos (le_of_not_gt h), dif_neg h, apply_inv_self, apply_inv_self,
          if_pos (mem_fin_pairs_lt.1 hab).le]
rw [Ne.def, f.injective.eq_iff, g.injective.eq_iff]
exact ne_of_lt hab
simp (config := { contextual := true }) [mem_fin_pairs_lt, Fin.one_pos]
simp
      -- TODO : fix properly
simp
      -- TODO
decide
decide
decide
decide
decide
decide
have : f = 1 := Equiv.ext fun y => not_not.1 (mt (h y) (List.not_mem_nil _))
rw [this, one_def, Equiv.trans_refl, Equiv.symm_trans_self, ← one_def, sign_aux_one, sign_aux2]
rw [sign_aux2]
simp only [h.mem_iff]
rw [← sign_aux_eq_sign_aux2 _ _ e fun _ _ => h₁ _, ←
          sign_aux_eq_sign_aux2 _ _ e fun _ _ => h₂ _]
simp [mul_apply]
rw [← mul_def, sign_mul]
rw [MonoidHom.map_inv sign f, Int.units_inv_eq_self]
simp [H, swap_self]
simp [sign_swap H, H]
simp only [Equiv.coe_trans, apply_eq_iff_eq, symm_trans_apply]
simp
simp [h]
rw [sign_swap hxy, h]
rw [← is_conj_iff_eq, ← Or.resolve_right (Int.units_eq_one_or _) h, hab']
exact s.map_is_conj (is_conj_swap hab hxy)
rw [← l.prod_hom s, List.eq_repeat'.2 this, List.prod_repeat, one_pow]
decide
rw [l.1.prod_hom of_subtype, l.2.1, of_subtype_subtype_perm _ h₂]
simp [h]
simp
simp
have : f (f x) ≠ f x := mt (fun h => f.Injective h) x.2
rw [← h _ x.2 this]
exact mt (hi _ _ this x.2) x.2
simp [eq_of_prod_extend_right_ne hab]
simp
apply eq_top_iff.mpr
intro b _
exact list.mem_to_finset.mpr (mem_l b)
simp
rw [← this.1, ← this.2, ← sign_mul, sum_congr_mul, one_mul, mul_one]
simp [subtype_congr]
simp only [Equiv.Perm.extendDomain, sign_subtype_congr, sign_perm_congr, sign_refl, mul_one]
induction s using Quot.induction_on
exact List.is_cycle_form_perm h (length_nontrivial hn)
simp [to_list, cycle_of_one]
simp [to_list]
simp [to_list]
simp
simp [to_list]
simp [to_list]
apply ext_le
· simp
· intro n hn hn'
    rw [nth_le_to_list, nth_le_rotate, nth_le_to_list, length_to_list,
      pow_mod_card_support_cycle_of_self_apply, pow_add, mul_apply]
rw [mem_to_list_iff, and_iff_right_iff_imp]
refine' fun _ => same_cycle.symm _
rw [same_cycle_pow_left_iff]
simp
simp
simp
simp
simp [this]
decide
rw [cycle_type_def]
congr
rw [cycle_factors_finset_eq_finset]
exact ⟨h1, h2, h0⟩
simp [cycle_type_def, cycle_factors_finset_eq_empty_iff]
rw [card_eq_zero, cycle_type_eq_zero]
rw [cycle_type_def, cycle_type_def, cycle_type_def, h.cycle_factors_finset_mul_eq_union, ←
    Multiset.map_add, Finset.union_val, multiset.add_eq_union_iff_disjoint.mpr _]
rw [← Finset.disjoint_val]
exact h.disjoint_cycle_factors_finset
rw [hσ.cycle_type, hσ.inv.cycle_type, support_inv]
rw [mul_inv_rev, hστ.cycle_type, ← hσ, ← hτ, add_comm,
      disjoint.cycle_type fun x =>
        Or.imp (fun h : τ x = x => inv_eq_iff_eq.mpr h.symm)
          (fun h : σ x = x => inv_eq_iff_eq.mpr h.symm) (hστ x).symm]
rw [cycle_type_one, sum_zero, support_one, Finset.card_empty]
rw [hσ.cycle_type, coe_sum, List.sum_singleton]
rw [hστ.cycle_type, sum_add, hσ, hτ, hστ.card_support_mul]
rw [sign_one, cycle_type_one, Multiset.map_zero, prod_zero]
rw [hσ.sign, hσ.cycle_type, coe_map, coe_prod, List.map_singleton, List.prod_singleton]
rw [sign_mul, hσ, hτ, hστ.cycle_type, Multiset.map_add, prod_add]
rw [Equiv.Perm.cycle_type_one, sign_one, Multiset.sum_zero, Multiset.card_zero, pow_zero]
rw [Equiv.Perm.IsCycle.cycle_type hf, hf.sign, coe_sum, List.sum_cons, sum_nil, add_zero,
        coe_card, length_singleton, pow_add, pow_one, mul_comm, neg_mul,
        one_mul]
rw [Equiv.Perm.Disjoint.cycle_type hfg, Multiset.sum_add, Multiset.card_add, ← add_assoc,
      add_comm f.cycle_type.sum g.cycle_type.sum, add_assoc g.cycle_type.sum _ _,
      add_comm g.cycle_type.sum _, add_assoc, pow_add, ← Pf, ← Pg, Equiv.Perm.sign_mul]
rw [cycle_type_one, lcm_zero, order_of_one]
rw [hσ.cycle_type, coe_singleton, lcm_singleton, order_of_is_cycle hσ, normalize_eq]
rw [hστ.cycle_type, lcm_add, lcm_eq_nat_lcm, hστ.order_of, hσ, hτ]
rw [← lcm_cycle_type]
exact dvd_lcm h
rw [le_antisymm
          (Nat.le_of_dvd zero_lt_two <|
            (dvd_of_mem_cycle_type hn).trans <| order_of_dvd_of_pow_eq_one hσ)
          (two_le_of_mem_cycle_type hn)]
rw [tsub_add_cancel_of_le (cycle_type_le_of_mem_cycle_factors_finset hf)] at this
simp [← this]
simp [← cycle_type_def, ← hπ, hσ.cycle_type]
rw [← Finset.mem_def, mem_cycle_factors_finset_iff] at hσ'l
rw [hσ.cycle_type, ← hσ', hσ'l.left.cycle_type]
apply cycle_induction_on _ g
· rw [extend_domain_one, cycle_type_one, cycle_type_one]
· intro σ hσ
    rw [(hσ.extend_domain f).cycleType, hσ.cycle_type, card_support_extend_domain]
· intro σ τ hd hc hσ hτ
    rw [hd.cycle_type, ← extend_domain_mul, (hd.extend_domain f).cycleType, hσ, hτ]
rw [h, pow_zero]
rw [Finset.mem_compl, mem_support, not_not]
rw [zero_eq]
exact Set.uniqueSingleton Vector.nil
rw [one_eq]
exact Set.uniqueSingleton (vector.nil.cons 1)
rw [mem_iff, Vector.to_list_cons, List.prod_cons, inv_mul_self]
rw [← List.prod_cons, ← Vector.to_list_cons, v.1.cons_head_tail]
exact v.2
rw [hn]
apply equiv_of_unique
rw [tsub_add_cancel_of_le (Nat.pos_of_ne_zero hn).nat_succ_le]
rw [hf2, add_tsub_cancel_of_le hp.out.one_lt.le, hf3]
rw [hf2, tsub_add_cancel_of_le hp.out.one_lt.le, hf3]
rw [pow_one, hσ, hf3, one_apply]
rw [sum_add, sum_cycle_type, Multiset.sum_repeat, nsmul_eq_mul, Nat.cast_id, mul_one,
      add_tsub_cancel_of_le σ.support.card_le_univ]
rw [parts_partition, filter_add, Multiset.filter_eq_self.2 fun _ => two_le_of_mem_cycle_type,
    Multiset.filter_eq_nil.2 fun a h => _, add_zero]
rw [Multiset.eq_of_mem_repeat h]
decide
rw [is_conj_iff_cycle_type_eq]
refine' ⟨fun h => _, fun h => _⟩
·
    rw [Nat.Partition.ext_iff, parts_partition, parts_partition, ← sum_cycle_type, ← sum_cycle_type,
      h]
· rw [← filter_parts_partition_eq_cycle_type, ← filter_parts_partition_eq_cycle_type, h]
rw [← sum_cycle_type, h.cycle_type, Multiset.sum_singleton]
refine' ⟨fun h => _, is_three_cycle.card_support⟩
rw [← card_cycle_type_eq_one, h.cycle_type, card_singleton]
rw [Equiv.Perm.sign_of_cycle_type, h.cycle_type]
rfl
rw [← inv_inv f]
apply inv
rw [← lcm_cycle_type, ht.cycle_type, Multiset.lcm_singleton, normalize_eq]
simp [swap_comm c a, mul_assoc]
rw [zpow_neg, ← hi, inv_apply_self]
rw [zpow_add, mul_apply, hi, hj]
simp [same_cycle]
rw [← hi, ← mul_apply, ← zpow_one_add, add_comm, zpow_add_one, mul_apply,
    (f ^ i).Injective.eq_iff]
rw [zpow_add, mul_apply, hi, zpow_neg_one, inv_apply_self]
rw [zpow_add, mul_apply, hi, zpow_one]
rw [← same_cycle_inv, same_cycle_apply, same_cycle_inv]
cases n
· exact same_cycle_pow_left_iff
· rw [zpow_negSucc, ← inv_pow, ← same_cycle_inv, same_cycle_pow_left_iff, same_cycle_inv]
rw [Int.natAbs_of_nonneg
                (Int.emod_nonneg _ <| Int.coe_nat_ne_zero.2 (order_of_pos _).ne')]
· refine' (Int.emod_lt _ <| Int.coe_nat_ne_zero_iff_pos.2 <| order_of_pos _).trans_le _
              simp [order_of_le_card_univ]
infer_instance
rw [← zpow_ofNat,
          Int.natAbs_of_nonneg
            (Int.emod_nonneg _ <| Int.coe_nat_ne_zero_iff_pos.2 <| order_of_pos _),
          ← zpow_eq_mod_order_of, hi]
infer_instance
simp [ha1]
rw [← ha, ← mul_apply, ← zpow_add, sub_add_cancel, hb]
simp
rw [mul_apply, apply_inv_self, swap_apply_of_ne_of_ne this.2 (Ne.symm hfbx), Ne.def, ←
          f.injective.eq_iff, apply_inv_self]
exact this.1
rw [add_comm, zpow_add, mul_apply, hi, zpow_one, mul_apply, apply_inv_self,
          swap_apply_of_ne_of_ne (ne_and_ne_of_swap_mul_apply_ne_self hb).2 (Ne.symm hfbx)]
rw [← zpow_ofNat, ← h, ← mul_apply, ← mul_apply, ← mul_apply, zpow_negSucc, ← inv_pow,
              pow_succ', mul_assoc, mul_assoc, inv_mul_self, mul_one, zpow_ofNat, ← pow_succ', ←
              pow_succ]
rw [mul_apply, inv_apply_self, swap_apply_left]
rw [← add_sub_cancel i 1, neg_sub, sub_eq_add_neg, zpow_add, zpow_one, zpow_neg, ← inv_zpow,
          mul_inv_rev, swap_inv, mul_swap_eq_swap_mul, inv_apply_self, swap_comm _ x, zpow_add,
          zpow_one, mul_apply, mul_apply (_ ^ i), h, hi, mul_apply, apply_inv_self,
          swap_apply_of_ne_of_ne this.2 (Ne.symm hfbx')]
simp [hyx]
simp [hfyx, hffx]
simp [swap_apply_def, mul_apply, if_neg hffx, f.injective.eq_iff, if_neg hx, hx]
rw [zpow_one, mul_apply]
rw [← mul_assoc, mul_def, mul_def, swap_swap, trans_refl]
rw [hf.eq_swap_of_apply_apply_eq_self hx.1 h1]
simp only [perm.mul_def, perm.one_def, swap_apply_left, swap_swap]
rw [← insert_erase (mem_support.2 hx.1), support_swap_mul_eq _ _ h1,
              card_insert_of_not_mem (not_mem_erase _ _), sdiff_singleton_eq_erase]
rw [← zpow_apply_eq_self_of_apply_eq_self hy i, (f ^ i).Injective.eq_iff] at hi
rw [hi, hy]
intro x hx
exact h' x (mem_of_mem_inter_left hx)
rw [order_of_is_cycle h, hr, order_of_is_cycle hf]
simp [h]
simp [h]
rw [pow_sub _ hab, mul_inv_eq_one] at this
rw [this]
refine' Nat.Coprime.symm _
rw [Nat.Prime.coprime_iff_not_dvd hf']
exact Nat.not_dvd_of_pos_of_lt hn hn'
rw [pow_succ, mul_apply, cycle_of_apply, cycle_of_pow_apply_self, if_pos, pow_succ, mul_apply]
exact ⟨n, rfl⟩
rw [zpow_negSucc, ← inv_pow, cycle_of_inv, zpow_negSucc, ← inv_pow, cycle_of_pow_apply_self]
apply of_subtype_apply_of_mem
exact h
apply of_subtype_apply_of_not_mem
exact h
rw [same_cycle.cycle_of_apply]
· rw [add_comm, zpow_add, zpow_one, mul_apply]
· exact ⟨k, rfl⟩
rw [h.cycle_of_apply]
rw [cycle_of_apply_of_not_same_cycle h, not_not.1 (mt ((same_cycle_cycle hx).1 hf).2 h)]
rw [cycle_of_zpow_apply_self, hi]
rw [cycle_of_apply_of_not_same_cycle hxy] at h
exact (h rfl).elim
rw [← two_le_card_support_cycle_of_iff, ← Nat.succ_le_iff]
exact ⟨fun h => Or.resolve_left h.eq_or_lt (card_support_ne_one _).symm, zero_lt_two.trans_le⟩
rw [← cycle_of_pow_apply_self f, ← cycle_of_pow_apply_self f, pow_eq_mod_order_of]
simp
constructor
· intro hx
    rw [Ne.def]
    rw [← cycle_of_eq_one_iff f]
    exact Equiv.Perm.IsCycle.ne_one hx
· intro hx
    apply Equiv.Perm.is_cycle_cycle_of
    exact hx
rw [h, mul_apply, Ne.def, inv_eq_iff_eq, cycle_of_apply_self] at hy
exact hy rfl
rw [List.prod_cons, hm₁]
simp
exact ⟨fun hσ => ⟨h1 σ hσ, (this (h1 σ hσ)).mp hσ⟩, fun hσ => (this hσ.1).mpr hσ.2⟩
intro x hx
rw [h x (mem_support.mp (mem_of_mem_inter_left hx)), hτl x (mem_of_mem_inter_right hx)]
rw [cycle_factors_finset, ← hl, Trunc.lift_mk]
simp [cycle_factors_finset_eq_empty_iff]
simp [cycle_factors_finset_eq_finset]
rw [cycle_factors_finset_eq_finset]
refine' ⟨_, _, _⟩
· simp [or_imp, mem_cycle_factors_finset_iff, forall_swap]
· rw [coe_union, Set.pairwise_union_of_symmetric disjoint.symmetric]
    exact
      ⟨cycle_factors_finset_pairwise_disjoint _, cycle_factors_finset_pairwise_disjoint _,
        fun x hx y hy hxy =>
        h.mono (mem_cycle_factors_finset_support_le hx) (mem_cycle_factors_finset_support_le hy)⟩
· rw [noncomm_prod_union_of_disjoint h.disjoint_cycle_factors_finset]
    rw [cycle_factors_finset_noncomm_prod, cycle_factors_finset_noncomm_prod]
rw [mem_cycle_factors_finset_iff] at h
intro x
rw [this]
apply symm
exact
      Equiv.Perm.IsCycle.cycle_of_eq (equiv.perm.mem_cycle_factors_finset_iff.mp hc).left
        (equiv.perm.mem_support.mp ha)
simp
simp
intro y z
rw [order_of_is_cycle hσ, h, order_of_is_cycle hτ]
simp
rw [lt_tsub_iff_left, ← lt_tsub_iff_right, ← Finset.card_compl, Finset.compl_filter]
exact one_lt_card_support_of_ne_one h
simp only [Disjoint, or_comm, imp_self]
simp [mul_apply, hf, hg]
simp [mul_apply, hf, g.injective hg]
simp [mul_apply, f.injective hf, hg]
simp [mul_apply, hf, hg]
intro x
rw [inv_eq_iff_eq, eq_comm]
exact h x
rw [disjoint_comm, disjoint_inv_left_iff, disjoint_comm]
cases H1 x <;> cases H2 x <;> simp [*]
rw [disjoint_comm]
exact H1.symm.mul_left H2.symm
rw [this] at h_mem
exact h1 h_mem
rw [pow_succ', mul_apply, hfx, pow_apply_eq_self_of_apply_eq_self]
rw [zpow_negSucc, inv_eq_iff_eq, pow_apply_eq_self_of_apply_eq_self hfx]
rw [pow_succ, mul_apply, h]
rw [pow_succ, mul_apply, h, hffx]
rw [zpow_negSucc, inv_eq_iff_eq, ← f.injective.eq_iff, ← mul_apply, ← pow_succ, eq_comm,
      inv_eq_iff_eq, ← mul_apply, ← pow_succ', @eq_comm _ x, or_comm]
exact pow_apply_eq_of_apply_apply_eq_self hffx _
rw [mul_apply, h.2, h.1]
simp only [Ne.def] at hxy
exact hxy.1
simp only [hxy.2, of_subtype_swap_eq]
rfl
simp only [swap_apply_def, mul_apply, f.injective.eq_iff] at *
simp
intro x
simp only [perm.coe_mul, Function.comp_apply, Ne.def, Set.mem_union, Set.mem_setOf_eq]
rw [support, mem_filter, and_iff_right (mem_univ x)]
simp
rw [support_eq_empty_iff]
rw [mem_support, mem_support, Ne.def, Ne.def, not_iff_not, apply_eq_iff_eq]
cases n
· rw [Int.ofNat_eq_coe, zpow_ofNat, pow_apply_mem_support]
· rw [zpow_negSucc, ← support_inv, ← inv_pow, pow_apply_mem_support]
simp [disjoint_iff_eq_or_eq, disjoint_iff, Finset.ext_iff, not_and_or]
refine' le_antisymm (support_mul_le _ _) fun a => _
rw [mem_union, mem_support, mem_support, mem_support, mul_apply, ← not_and_or, not_imp_not]
exact
    (h a).elim (fun hf h => ⟨hf, f.apply_eq_iff_eq.mp (h.trans hf.symm)⟩) fun hg h =>
      ⟨(congr_arg f hg).symm.trans h, hg⟩
rw [h]
exact mem_singleton.mpr rfl
simp only [mem_support, swap_apply_def, mul_apply, f.injective.eq_iff] at *
rw [disjoint_iff_disjoint_support] at h⊢
exact h.mono hf hg
simp
rw [eq_symm_apply]
exact Subtype.coe_injective hb
simp
rw [Finset.card_eq_zero, support_eq_empty_iff]
rw [le_iff_lt_or_eq, Nat.lt_succ_iff, le_zero_iff, card_support_eq_zero, or_iff_not_imp_right,
    imp_iff_right f.card_support_ne_one]
simp
simp [hxy]
simp [support_swap hxy, *, Finset.ext_iff]
rw [← mem_support, ← hins, mem_insert, mem_singleton]
simp [Equiv.Perm.decomposeFin, Equiv.permCongr_def]
simp [Equiv.Perm.decomposeFin]
refine' Fin.cases _ _ p
· simp [Equiv.Perm.decomposeFin, EquivFunctor.map]
· intro i
rw [← Fin.succ_zero_eq_one, Equiv.Perm.decompose_fin_symm_apply_succ e p 0]
refine' Fin.cases _ _ p <;> simp [Equiv.Perm.decomposeFin, Fin.succ_ne_zero]
decide
rw [is_cycle_fin_rotate.cycle_type, support_fin_rotate, ← Fintype.card, Fintype.card_fin]
rfl
simp
rw [cycle_range_of_le h.le, if_neg h.ne]
rw [coe_cycle_range_of_le h.le, if_neg h.ne]
rw [cycle_range_of_le h.le, if_pos h]
simp [cycle_range]
simp
simp
rw [is_three_cycle, cycle_type_cycle_range] <;> decide
rw [← Equiv.Perm.mul_apply, ← Equiv.Perm.mul_apply, zpow_mul_comm]
rw [Function.iterate_succ, pow_add, iterate_eq_pow]
rfl
simp only [perm.inv_apply_self, Subtype.coe_eta, Subtype.coe_mk]
simp only [perm.apply_inv_self, Subtype.coe_eta, Subtype.coe_mk]
rw [zpow_negSucc]
exact inv_aux.1 (pow_aux hf)
simp [h, of_subtype_apply_of_not_mem f h]
rw [swap_mul_eq_mul_swap, perm.inv_apply_self, perm.inv_apply_self]
rw [mul_swap_eq_swap_mul, mul_inv_cancel_right]
rw [← mul_assoc, swap_mul_self, one_mul]
rw [mul_assoc, swap_mul_self, mul_one]
have swap_id : swap i j = 1 := mul_right_cancel (trans h (one_mul σ).symm)
rw [← swap_apply_right i j, swap_id]
rfl
erw [h, swap_self, one_mul]
have swap_id : swap i j = 1 := mul_left_cancel (trans h (one_mul σ).symm)
rw [← swap_apply_right i j, swap_id]
rfl
erw [h, swap_self, mul_one]
apply perm.swap_induction_on e
· simp [perm.one_def]
· intro f x y hne h
    simp [h, hne, perm.mul_def, ← Equiv.optionCongr_trans]
simp [h]
simp
simp
simp [← mul_assoc]
simp
simp
simp
rw [nth_le_cons_length, form_perm_apply_last] <;> rfl
simp [form_perm_apply_of_not_mem _ _ h.not_mem]
rw [form_perm_apply_last]
simp
simp
rw [← Nat.succ_eq_add_one, Nat.mod_eq_of_lt hk']
simp
rw [Ne.def, form_perm_apply_mem_eq_self_iff _ hl x hx, not_le]
exact ⟨Nat.succ_le_of_lt, Nat.lt_of_succ_le⟩
rw [← mem_to_finset]
exact support_form_perm_le' _ this
simp [form_perm_eq_one_iff, hl, -form_perm_cons_cons]
apply FreeGroup.ext_hom
intro x
simp only [MonoidHom.coe_comp, Function.comp_apply, MonoidHom.id_apply, FreeGroup.lift.of,
          lift_of]
intro H _ f a <;> simp [← lift_of (lift.symm f)]
simp
simp
simp
rw [← MonoidHom.map_inv, inl_aut, inv_inv]
simp [right_hom]
simp [right_hom]
simp (config := { contextual := true }) [MonoidHom.mem_ker, eq_comm]
simp
have := fun n g => MonoidHom.ext_iff.1 (h n) g
simp only [MulAut.conj_apply, MonoidHom.comp_apply, MulEquiv.coe_toMonoidHom] at this
simp [this, mul_assoc]
simp [lift]
simp [lift]
rw [lift_unique f, lift_unique g]
simp only [*]
simp
simp [map]
simp [map]
rw [← hk, pow_order_of_eq_one]
rw [← hG, pow_card_eq_one]
refine' fun h => Exists.elim (hϕ h) fun g hg => Exists.imp (fun k hk => _) (hG g)
rw [← hg, ← ϕ.map_pow, hk, ϕ.map_one]
rw [order_eq_card_zpowers'] <;> rfl
rw [hk0, pow_zero] at hk <;> exact fintype.one_lt_card.ne' hk
simp <;> rfl
simp only [Quotient.eq'] <;> congr
rw [key, mem_fixed_points_iff_card_orbit_eq_one.mp a.2]
rw [hk, this, pow_zero]
rw [← H.subtype_range, MonoidHom.map_range]
exact hH.of_surjective (ϕ.restrict H).range_restrict (ϕ.restrict H).range_restrict_surjective
rw [← hn₁, ← hn₂]
apply (Finset.noncomm_prod_eq_pow_card _ _ _ _ _).trans (one_pow _)
simp
change finset.univ.noncomm_prod (fun j => ϕ j (Pi.mulSingle i y j)) _ = ϕ i y
simp (config := { singlePass := true }) only [← Finset.insert_erase (Finset.mem_univ i)]
rw [Finset.noncomm_prod_insert_of_not_mem _ _ _ _ (Finset.not_mem_erase i _)]
rw [Pi.mulSingle_eq_same]
rw [Finset.noncomm_prod_eq_pow_card]
· rw [one_pow]
    exact mul_one _
· intro j hj
    simp only [Finset.mem_erase] at hj
    simp [hj]
simp
simp
rw [← hg'f]
exact (order_of_map_dvd _ _).trans order_of_dvd_card_univ
rw [← hgf, ← Fintype.card_pi]
exact (order_of_map_dvd _ _).trans order_of_dvd_card_univ
apply MonoidHom.noncomm_pi_coprod_mul_single
simp [noncomm_pi_coprod, MonoidHom.noncomm_pi_coprod_range]
rw [mem_alternating_group, sign_prod_list_swap hl, ← Units.val_eq_one, Units.val_pow_eq_pow_val,
    Units.coe_neg_one, neg_one_pow_eq_one_iff_even]
decide
rw [mem_alternating_group, bit1, sign_fin_rotate, pow_bit0', Int.units_mul_self, one_pow]
let this := (QuotientGroup.quotientKerEquivOfSurjective _ (sign_surjective α)).toEquiv
rw [← Fintype.card_units_int, ← Fintype.card_congr this]
exact (Subgroup.card_eq_card_quotient_mul_card_subgroup _).symm
rw [Finset.card_compl, le_tsub_iff_left σ.support.card_le_univ]
exact hσ
rw [disjoint_iff_disjoint_support, support_swap ab, Finset.disjoint_insert_left,
          Finset.disjoint_singleton_left]
exact ⟨Finset.mem_compl.1 ha, Finset.mem_compl.1 hb⟩
decide
rw [card_fin]
exact le_add_left (le_refl 3)
decide
rw [card_fin]
decide
decide
decide
rw [Subtype.ext_iff]
simp only [Fin.coe_mk, Subgroup.coe_mul, Subgroup.coe_inv, Fin.coe_mk]
decide
decide
decide
decide
rw [card_fin]
decide
decide
decide
rw [← fintype.card_eq.mpr ⟨fintype_helper⟩, Fintype.card_sum, Zmod.card, two_mul]
rw [r_one_pow, one_def]
congr 1
exact Zmod.nat_cast_self _
rw [sr_mul_sr, sub_self, one_def]
rw [order_of_eq_prime _ _]
· exact ⟨Nat.prime_two⟩
rw [sq, sr_mul_self]
decide
rw [Subsingleton.elim x 1]
exact mem_zpowers 1
rw [← h]
apply card_subgroup_dvd_card
contradiction
change g ∈ Subgroup.zpowers g
exact Subgroup.mem_zpowers g
rw [← hk, Int.eq_zero_of_natAbs_eq_zero h, zpow_zero]
rw [Int.natAbs_ofNat, ← zpow_ofNat, hk] <;> exact hx₁
rw [Int.nat_abs_of_neg_succ_of_nat, ← Subgroup.inv_mem_iff H] <;> simp_all
rw [← zpow_ofNat, zpow_mul]
rw [← zpow_add, Int.mod_add_div, hk] <;> exact hx
rw [Int.natAbs_of_nonneg
              (Int.emod_nonneg _ (Int.coe_nat_ne_zero_iff_pos.2 (Nat.find_spec hex).1))]
rw [← hk₄] <;> exact Int.emod_lt_of_pos _ (Int.coe_nat_pos.2 (Nat.find_spec hex).1)
rw [Subgroup.mem_bot.1 h] <;> exact H.one_mem
rw [pow_mul, hm, ← pow_gcd_card_eq_one_iff] <;> exact (mem_filter.1 hx).2
rw [hm0, mul_zero, Fintype.card_eq_zero_iff] at hm
exact hm.elim' 1
rw [← order_of_eq_card_of_forall_mem_zpowers ha, IsCyclic.image_range_order_of ha]
let ⟨i, hi⟩ := b.2
rw [← hi, ← zpow_ofNat, ← zpow_mul, mul_comm, zpow_mul, zpow_ofNat,
                    pow_order_of_eq_one, one_zpow]
refine' Finset.sum_congr rfl fun m hm => _
simp only [mem_filter, mem_range, mem_proper_divisors] at hm
refine' IH m hm.2 (hm.1.trans hd) (Finset.card_pos.2 ⟨a ^ (d / m), _⟩)
simp only [mem_filter, mem_univ, order_of_pow a, ha, true_and_iff,
      Nat.gcd_eq_right (div_dvd_of_dvd hm.1), Nat.div_div_self hm.1 hd_pos.ne']
rw [← filter_dvd_eq_divisors hd_pos.ne', sum_card_order_of_eq_card_pow_eq_one hd_pos,
      filter_dvd_eq_divisors hd_pos.ne', sum_totient, ← ha, card_pow_eq_one_eq_order_of_aux hn a]
let c := Fintype.card α
have hc0 : 0 < c := Fintype.card_pos_iff.2 ⟨1⟩
apply card_order_of_eq_totient_aux₁ hn hd
simp only [← filter_dvd_eq_divisors hc0.ne', sum_card_order_of_eq_card_pow_eq_one hc0]
apply congr_arg card
simp
rw [card_order_of_eq_totient_aux₂ hn dvd_rfl] <;>
        exact totient_pos (Fintype.card_pos_iff.2 ⟨1⟩)
rw [f.mem_ker, f.map_mul, f.map_zpow, hxy, zpow_neg, hm, inv_mul_self]
rw [f.mem_ker, f.map_mul, f.map_zpow, hxy, zpow_neg, hn, inv_mul_self]
simp [mul_assoc]
rw [mem_center_iff.1 ha]
simp [mul_assoc]
rw [mem_center_iff.1 hb]
infer_instance
infer_instance
rw [zero_sub]
decide
rw [a_one_pow, one_def]
congr 1
exact Zmod.nat_cast_self _
simp [sq]
apply is_cyclic_of_order_of_eq_card
rw [card, mul_one]
exact order_of_xa 0
simp [hS]
simp [← Submonoid.to_add_submonoid_closure, hS]
simp [← AddSubmonoid.to_submonoid'_closure, hT]
rw [Finset.coe_univ] <;> exact Submonoid.closure_univ
rw [Finset.coe_image, MonoidHom.map_mclosure]
refine' ⟨⟨s.preimage coe (subtype.coe_injective.inj_on _), _⟩⟩
rw [Finset.coe_preimage, Submonoid.closure_closure_coe_preimage]
simp [hS]
rw [Subgroup.fg_iff_submonoid_fg, AddSubgroup.FgIffAddSubmonoid.fg]
exact (Subgroup.toSubmonoid P).fg_iff_add_fg
rw [AddSubgroup.FgIffAddSubmonoid.fg, Subgroup.fg_iff_submonoid_fg]
exact AddSubmonoid.fg_iff_mul_fg (AddSubgroup.toAddSubmonoid P)
rw [Finset.coe_univ] <;> exact Subgroup.closure_univ
refine' ⟨⟨s.preimage coe (subtype.coe_injective.inj_on _), _⟩⟩
rw [Finset.coe_preimage, ← Subgroup.coe_subtype, Subgroup.closure_preimage_eq_top]
subst h
rw [Finset.coe_preimage]
exact closure_preimage_eq_top s
simp [mem_centralizer_iff]
simp [mem_centralizer_iff]
rw [mul_assoc, ← hb g hg, ← mul_assoc, ha g hg, mul_assoc]
rw [mul_inv_eq_iff_eq_mul, mul_assoc, eq_inv_mul_iff_mul_eq, ha g hg]
rw [add_mul, mul_add, ha c hc, hb c hc]
rw [mul_neg, ha c hc, neg_mul]
rw [h, inv_zero]
exact zero_mem_centralizer S
rw [mul_inv_eq_iff_eq_mul₀ ha0, mul_assoc, eq_inv_mul_iff_mul_eq₀ ha0, ha c hc]
rw [div_eq_mul_inv]
exact mul_mem_centralizer ha (inv_mem_centralizer hb)
rw [div_eq_mul_inv]
exact mul_mem_centralizer ha (inv_mem_centralizer₀ hb)
simp [mem_supr_of_directed hS]
simp only [Sup_eq_supr', mem_supr_of_directed hS.directed_coe, SetCoe.exists, Subtype.coe_mk]
simp [mem_Sup_of_directed_on hS]
simp [mem_center_iff]
simp [mem_center_iff]
rw [mul_assoc, ← hb g, ← mul_assoc, ha g, mul_assoc]
rw [← inv_inj, mul_inv_rev, inv_inv, ← ha, mul_inv_rev, inv_inv]
rw [add_mul, mul_add, ha c, hb c]
rw [← neg_mul_comm, ha (-c), neg_mul_comm]
rw [div_eq_mul_inv]
exact mul_mem_center ha (inv_mem_center hb)
rw [div_eq_mul_inv]
exact mul_mem_center ha (inv_mem_center₀ hb)
cases x <;> rfl
cases x <;> rfl
cases x <;> rfl
cases x <;> rfl
rw [map_mul] <;> exact mul_mem ha hb
simp
rw [map_mul] <;> rfl
simp [mem_comap, mem_map, hf.eq_iff]
simp [hy, h]
refine' closure_induction' _ (fun g hg => _) (fun g₁ g₂ hg₁ hg₂ => _) hx
· exact subset_closure hg
· exact Subsemigroup.mul_mem _
simp [mem_prod, MulHom.coe_fst]
simp [mem_prod, MulHom.coe_snd]
simp [coe_prod, Prod.one_eq_mk]
rw [coe_srange, coe_top]
simp only [eq_top_iff, le_prod_iff, ← (gc_map_comap _).le_iff_le, ← srange_eq_map, srange_fst,
    srange_snd]
rw [← hx', h x']
cases p <;> cases q <;> congr
simp
apply Set.mem_Inter₂.1 hx i h
apply Set.mem_Inter₂.1 hy i h
simp only [infi, mem_Inf, Set.forall_range_iff]
simp only [infi, coe_Inf, Set.bInter_range]
refine' Exists.elim _ fun (hx : x ∈ closure s) (hc : p x hx) => hc
exact
    closure_induction hx (fun x hx => ⟨_, Hs x hx⟩) fun x y ⟨hx', hx⟩ ⟨hy', hy⟩ =>
      ⟨_, Hmul _ _ _ _ hx hy⟩
rw [closure_le, singleton_subset_iff, SetLike.mem_coe]
rw [← closure_singleton_le_iff_mem, le_supr_iff]
simp only [closure_singleton_le_iff_mem]
simp [*]
simp only [← mul_assoc, h₁, h₂]
rw [dif_neg hn] <;> exact (H hn a).some_spec
rw [zsmul_eq_mul, (Int.cast_commute n _).Eq, div_mul_cancel q (int.cast_ne_zero.mpr hn)]
rw [← hpow (RootableBy.root y n) n, RootableBy.root_cancel _ hn, hy]
simp [mem_supr_of_directed hS]
simp [mem_Sup_of_directed_on Sne hS]
rw [closure_singleton_eq, mem_mrange] <;> rfl
simp [eq_bot_iff_forall, mem_closure_singleton]
rw [mrange_eq_map, ← FreeMonoid.closure_range_of, map_mclosure, ← Set.range_comp,
    FreeMonoid.lift_comp_of]
rw [FreeMonoid.mrange_lift, Subtype.range_coe]
rw [closure_eq_mrange, coe_mrange, ← List.range_map_coe, ← Set.range_comp]
rfl
rw [hs]
exact mem_top _
rw [hs]
exact mem_top _
simp <;> rfl
simp only [pow, map_mul, ofAdd_add, toAdd_mul]
simp only [powers_eq_closure, map_mclosure f, Set.image_singleton]
refine' ⟨fun x => Submonoid.induction_of_closure_eq_top_left htop x _ _⟩
· intro y z
    rw [one_smul, one_smul]
· clear x
    intro x hx x' hx' y z
    rw [mul_smul, mul_smul, hs x hx, hx']
refine' ⟨fun x => Submonoid.induction_of_closure_eq_top_left htop x _ _⟩
· intro y z
    rw [one_smul, one_smul]
· clear x
    intro x hx x' hx' y z
    rw [mul_smul, mul_smul, hx', hs x hx]
rw [mrange_eq_map, ← mrange_inl_sup_mrange_inr, map_sup, map_mrange, coprod_comp_inl, map_mrange,
    coprod_comp_inr, range_subtype, range_subtype]
simp only [sup_eq_range, mem_mrange, coprod_apply, Prod.exists, SetLike.exists, coeSubtype,
    Subtype.coe_mk]
rw [closure_singleton_eq, AddMonoidHom.mem_mrange] <;> rfl
simp [eq_bot_iff_forall, mem_closure_singleton, nsmul_zero]
simp <;> rfl
simp only [zero_mul, (AddSubmonoid.closure (S : Set R)).zero_mem]
simp only [mul_zero, (AddSubmonoid.closure (S : Set R)).zero_mem]
infer_instance
infer_instance
rw [coe_mul, ← mul_assoc, mul_assoc a, hb, mul_one, ha]
rw [inv_inv (hS hx).Unit]
rfl
rw [mul_comm, mul_from_left_inv]
rw [← IsUnit.mul_right_inj (left_inv_le_is_unit _ a.prop), S.mul_from_left_inv, eq_comm]
rw [from_left_inv_eq_iff, mul_comm x, Submonoid.coe_mul, Submonoid.coe_mul, mul_assoc, ←
        mul_assoc (x : M), mul_from_left_inv, one_mul, mul_from_left_inv]
rw [h.some_spec]
simp
simp
rw [← mul_right_inj (x : M), mul_right_inv, mul_from_left_inv]
rw [← mul_right_inj (x : M), mul_right_inv, mul_left_inv_equiv_symm]
infer_instance
cases x <;> rfl
cases x <;> rfl
cases x <;> rfl
cases x <;> rfl
rw [map_one] <;> exact S.one_mem
  mul_mem' a b ha hb
rw [map_mul] <;> exact S.mul_mem ha hb
simp
rw [map_mul] <;> rfl
simp [mem_comap, mem_map, hf.eq_iff]
simp [hy, h]
refine' closure_induction' _ (fun g hg => _) _ (fun g₁ g₂ hg₁ hg₂ => _) hx
· exact subset_closure hg
· exact Submonoid.one_mem _
· exact Submonoid.mul_mem _
simp [mem_prod, MonoidHom.coe_fst]
simp [mem_prod, MonoidHom.coe_snd]
simp [coe_prod, Prod.one_eq_mk]
rw [coe_mrange, coe_top]
rw [← comap_bot', ← comap_bot', ← comap_bot', ← prod_map_comap_prod', bot_prod_bot]
simp only [eq_bot_iff, prod_le_iff, (gc_map_comap _).le_iff_le, comap_bot', mker_inl, mker_inr]
simp only [eq_top_iff, le_prod_iff, ← (gc_map_comap _).le_iff_le, ← mrange_eq_map, mrange_fst,
    mrange_snd]
simp only [mrange_inl, mrange_inr, prod_bot_sup_bot_prod, top_prod_top]
simp (config := { contextual := true }) [iff_def, S.one_mem]
simp only [Ne.def]
simp only [eq_bot_iff_forall, nontrivial_iff_exists_ne_one, ← not_forall, Classical.em]
rw [← hx', h x']
infer_instance
rw [pow_zero]
exact OneMemClass.one_mem S
rw [pow_succ]
exact MulMemClass.mul_mem hx (pow_mem n)
cases p <;> cases q <;> congr
simp only [Set.mem_singleton_iff] at *
rw [ha, hb, mul_one]
apply Set.mem_Inter₂.1 hx i h
apply Set.mem_Inter₂.1 hy i h
simp only [infi, mem_Inf, Set.forall_range_iff]
simp only [infi, coe_Inf, Set.bInter_range]
simp [Submonoid.one_mem]
refine' Exists.elim _ fun (hx : x ∈ closure s) (hc : p x hx) => hc
exact
    closure_induction hx (fun x hx => ⟨_, Hs x hx⟩) ⟨_, H1⟩ fun x y ⟨hx', hx⟩ ⟨hy', hy⟩ =>
      ⟨_, Hmul _ _ _ _ hx hy⟩
rw [closure_le, singleton_subset_iff, SetLike.mem_coe]
rw [← closure_singleton_le_iff_mem, le_supr_iff]
simp only [closure_singleton_le_iff_mem]
rw [Set.mem_setOf_eq, f.map_one, g.map_one]
simp [*]
simp only [isUnit_one, Set.mem_setOf_eq]
intro a b ha hb
rw [Set.mem_setOf_eq] at *
exact IsUnit.mul ha hb
change a ∈ setOf IsUnit ↔ IsUnit a
rw [Set.mem_setOf_eq]
rw [one_mul, h1, one_mul]
rw [mul_assoc, ha, ha, hb, mul_assoc]
simp [h1]
simp only [← mul_assoc, h₁, h₂]
rw [pow_one]
rw [inv_one]
exact S.one_mem
rw [mul_inv_rev]
exact S.mul_mem hb ha
apply le_antisymm
· rw [closure_le, coe_inv, ← Set.inv_subset, inv_inv]
    exact subset_closure
· rw [inv_le, closure_le, coe_inv, ← Set.inv_subset]
    exact subset_closure
rw [closure_inv, mem_inv]
simp only [closure_singleton_eq, mul_one, one_eq_mrange]
congr 1
rw [← closure_mul_closure, closure_eq, closure_eq]
rw [AddSubmonoid.mem_bot] at hn⊢ <;> rw [hn, mul_zero]
rw [AddSubmonoid.mem_bot] at hm⊢ <;> rw [hm, zero_mul]
refine'
          le_antisymm (mul_le.2 fun m hm n hn => _)
            ((AddSubmonoid.neg_le _ _).2 <| mul_le.2 fun m hm n hn => _) <;>
        simp only [AddSubmonoid.mem_neg, ← neg_mul] at *
· exact mul_mem_mul hm hn
· exact mul_mem_mul (neg_mem_neg.2 hm) hn
refine'
          le_antisymm (mul_le.2 fun m hm n hn => _)
            ((AddSubmonoid.neg_le _ _).2 <| mul_le.2 fun m hm n hn => _) <;>
        simp only [AddSubmonoid.mem_neg, ← mul_neg] at *
· exact mul_mem_mul hm hn
· exact mul_mem_mul hm (neg_mem_neg.2 hn)
rw [one_eq_closure_one_set, ← closure_eq M, closure_mul_closure, one_mul]
rw [one_eq_closure_one_set, ← closure_eq M, closure_mul_closure, mul_one]
rw [pow_zero, pow_zero, one_eq_closure_one_set]
rw [pow_succ, pow_succ, closure_pow, closure_mul_closure]
rw [← closure_pow, closure_eq]
rw [Submonoid.closure_eq_image_prod]
refine' (h.partially_well_ordered_on_sublist_forall₂ (· ≤ ·)).image_of_monotone_on _
exact fun l1 hl1 l2 hl2 h12 => h12.prod_le_prod' fun x hx => hpos x <| hl2 x hx
rw [Disjoint.comm] at h
have ha : a ∈ doset b H K := mem_doset_of_not_disjoint h
apply doset_eq_of_mem ha
rw [one_mul, mul_inv_cancel_left]
rw [mul_one, inv_mul_cancel_right]
rw [Quotient.eq']
apply rel_iff
rw [Eq]
exact mem_doset.mp (h.symm ▸ mem_doset_self H K b)
rw [commutatorElement_def, mul_inv_eq_one, mul_inv_eq_iff_eq_mul]
rw [eq_bot_iff, commutator_le]
refine'
    forall_congr' fun p => forall_congr' fun hp => forall_congr' fun q => forall_congr' fun hq => _
rw [mem_bot, commutator_element_eq_one_iff_mul_comm, eq_comm]
rw [← diff_inv, h, inv_one]
rw [← diff_mul_diff, h, h', one_mul]
rw [Subtype.ext_iff, coe_mk, coe_one, mul_one, inv_mul_self]
rw [Subtype.ext_iff, coe_mk, coe_mul, coe_mul, coe_mk, coe_mk, mul_assoc, mul_assoc,
          mul_assoc, mul_assoc, mul_assoc, mul_inv_cancel_left]
rw [inv_one] <;> apply one_smul G
rw [← diff_inv, smul_diff', diff_self, one_mul, inv_pow, inv_inv]
rw [inv_pow, ← pow_coprime_apply hH, Equiv.apply_symm_apply, mul_inv_self]
contradiction
rw [← N.relindex_top_right, ← hK]
exact (relindex_sup_right K N).symm
rw [← K.index_mul_card]
exact lt_mul_of_one_lt_left Fintype.card_pos (one_lt_index_of_ne_top h3)
rw [h4]
exact h1.coprime_dvd_left (card_comap_dvd_of_injective N K.subtype Subtype.coe_injective)
rw [hH, ← N.index_mul_card, mul_comm]
rw [← index_eq_card, ← K.index_mul_card]
refine'
      lt_mul_of_one_lt_right (Nat.pos_of_ne_zero index_ne_zero_of_finite)
        (K.one_lt_card_iff_ne_bot.mpr h4.1)
apply ih _ hG'
rfl
rw [← N.card_mul_index]
exact mul_ne_zero hN1 hN2
infer_instance
infer_instance
simp only [one h₁ h₂ Distrib, h₁.left_id, h₁.right_id, h₂.left_id, h₂.right_id]
simp only [Distrib, h₁.left_id, h₁.right_id, h₂.left_id, h₂.right_id]
let f : G → R := fun g => to_fun hR g
let U : Set G := (R * S).image fun g => g * (f g)
rw [Finset.coe_image, Finset.coe_mul]
exact closure_mul_image_eq_top hR hR1 hS
have h2 := card_commutator_dvd_index_center_pow (closureCommutatorRepresentatives G)
refine' Nat.finite_of_card_ne_zero fun h => _
rw [card_commutator_closure_commutator_representatives, h, zero_dvd_iff] at h2
exact finite_index.finite_index (pow_eq_zero h2)
refine' (subtype.ext_iff.mp _).trans (Subtype.coe_mk (f q) ⟨q, rfl⟩)
exact (to_equiv (range_mem_left_transversals hf)).apply_eq_iff_eq_symm_apply.mpr (hf q).symm
rw [mul_inv_rev, inv_inv]
refine' (subtype.ext_iff.mp _).trans (Subtype.coe_mk (f q) ⟨q, rfl⟩)
exact (to_equiv (range_mem_right_transversals hf)).apply_eq_iff_eq_symm_apply.mpr (hf q).symm
rw [mul_inv_rev, inv_inv]
rw [smul_to_equiv, smul_inv_smul]
rw [apply_eq_iff_eq_symm_apply, quotient_equiv_sigma_zmod_symm_apply, Zmod.coe_int_cast,
    zpow_smul_mod_minimal_period]
rw [transfer_function_apply, ← smul_eq_mul, coe_smul_out', ← quotient_equiv_sigma_zmod_symm_apply,
    Sigma.eta, symm_apply_apply]
rw [transfer_transversal_apply, transfer_function_apply, ← quotient_equiv_sigma_zmod_symm_apply,
    apply_symm_apply]
rw [smul_apply_eq_smul_apply_inv_smul, transfer_transversal_apply, transfer_function_apply, ←
    mul_smul, ← zpow_neg_one, ← zpow_add, quotient_equiv_sigma_zmod_apply, smul_eq_mul, ← mul_assoc,
    ← zpow_one_add, Int.cast_add, Int.cast_neg, Int.cast_one, int_cast_cast, cast_id', id.def, ←
    sub_eq_neg_add, cast_sub_one, add_sub_cancel'_right]
rw [is_periodic_pt, is_fixed_pt, mul_left_iterate, mul_one]
rw [← f.map_pow, hn, f.map_one]
rw [orderOf, one_mul_eq_id, minimal_period_id]
rw [orderOf, is_fixed_point_iff_minimal_period_eq_one, is_fixed_pt, mul_one]
rw [Nat.mod_add_div]
simp [pow_add, pow_mul, pow_order_of_eq_one]
rw [pow_eq_mod_order_of, Nat.mod_eq_zero_of_dvd h, pow_zero]
apply order_of_dvd_of_pow_eq_one
rw [← map_pow, pow_order_of_eq_one]
apply map_one
rw [h, pow_one, pow_one]
rw [order_of_eq_one_iff.mp h1, one_pow, one_pow]
rw [← pow_mul, pow_eq_mod_order_of, hm, pow_one]
simp [this, ha]
  -- Assume `a` is not one...
rw [← hk, pow_order_of_eq_one]
rw [modeq_zero_iff_dvd, order_of_dvd_iff_pow_eq_one]
simp [order_of_eq_order_of_iff]
rw [Int.mod_add_div]
simp [zpow_add, zpow_mul, pow_order_of_eq_one]
let ⟨m, hm⟩ := h.2
rw [hm, pow_mul, pow_order_of_eq_one, one_pow]
rw [Equiv.symm_apply_eq, fin_equiv_powers_apply, Subtype.mk_eq_mk, pow_eq_mod_order_of,
    Fin.coe_mk]
rw [powersEquivPowers, Equiv.trans_apply, Equiv.trans_apply, fin_equiv_powers_symm_apply, ←
    Equiv.eq_symm_apply, fin_equiv_powers_symm_apply]
simp [h]
simp_all
rw [← mem_powers_iff_mem_zpowers, mem_powers_iff_mem_range_order_of]
rw [finEquivZpowers, Equiv.symm_trans_apply, Equiv.Set.of_eq_symm_apply]
exact fin_equiv_powers_symm_apply x n
rw [zpowersEquivZpowers, Equiv.trans_apply, Equiv.trans_apply, fin_equiv_zpowers_symm_apply, ←
    Equiv.eq_symm_apply, fin_equiv_zpowers_symm_apply]
simp [h]
rw [eq₁, eq₂, mul_comm]
rw [← Nat.card_eq_fintype_card, pow_card_eq_one']
rw [← eq_one_iff, QuotientGroup.coe_pow H, index, pow_card_eq_one']
rw [pow_eq_mod_order_of, ← Nat.mod_mod_of_dvd n order_of_dvd_card_univ, ← pow_eq_mod_order_of]
rw [zpow_eq_mod_order_of, ← Int.emod_emod_of_dvd n (Int.coe_nat_dvd.2 order_of_dvd_card_univ), ←
    zpow_eq_mod_order_of]
let ⟨m, hm⟩ := gcd_dvd_left n (Fintype.card G)
rw [hm, pow_mul, h, one_pow]
cases n
· intro a b
      refine' (mem_bot.1 _).trans (mem_bot.1 _).symm <;>
        · rw [← hn]
          exact mem_top _
· rw [IsSimpleGroup.derived_series_succ] at hn
      intro a b
      rw [← mul_inv_eq_one, mul_inv_rev, ← mul_assoc, ← mem_bot, ← hn, commutator_eq_closure]
      exact subset_closure ⟨a, b, rfl⟩
decide
decide
decide
decide
decide
decide
decide
decide
simp [a_in]
refine' a_min ⟨_, _⟩
· exact AddSubgroup.sub_mem H g_in (AddSubgroup.zsmul_mem H a_in k)
· exact lt_of_le_of_ne nonneg (Ne.symm h)
simp only [mul_inv_rev, mul_assoc, inv_mul_cancel_left]
simp only [← _root_.eq_inv_mul_iff_mul_eq, exists_prop, exists_eq_right]
refine' quotient_group.eq.trans _
rw [mul_one, Subgroup.inv_mem_iff]
refine' eq_comm.trans (quotient_group.eq.trans _)
rw [nN.mem_comm_iff, div_eq_mul_inv]
rw [mul_inv_rev, inv_inv, mul_inv_cancel_left]
rw [φ.map_mul, HN _ (N.inv_mem h), mul_one]
refine' QuotientGroup.lift N ((mk' M).comp f) _
intro x hx
refine' QuotientGroup.eq.2 _
rw [mul_one, Subgroup.inv_mem_iff]
exact h hx
refine' induction_on' x fun x => _
simp only [map_coe, MonoidHom.id_apply]
refine' induction_on' x fun x => _
simp only [map_coe, MonoidHom.comp_apply]
rw [map_map] <;>
        simp only [map_map, ← MulEquiv.coe_monoidHom_trans, MulEquiv.self_trans_symm,
          MulEquiv.coe_monoidHom_refl, map_id_apply]
rw [map_map] <;>
        simp only [← MulEquiv.coe_monoidHom_trans, MulEquiv.symm_trans_self,
          MulEquiv.coe_monoidHom_refl, map_id_apply]
rw [left_rel_apply, mem_ker, φ.map_mul, ← h, φ.map_inv, inv_mul_self]
rw [left_rel_apply, ← ker_range_restrict, mem_ker, φ.range_restrict.map_mul, ← h,
        φ.range_restrict.map_inv, inv_mul_self]
rw [Function.comp_apply, ker_lift_mk', hφ]
simp [← comap_ker]
dsimp [HasQuotient.quotient, subgroup.has_quotient, Quotient]
rw [left_rel_eq]
exact @Trunc.subsingleton G
simp [Commensurable]
rw [← Quotient.eq', ← Quotient.eq', QuotientGroup.eq', QuotientGroup.eq',
      Subgroup.mem_subgroup_of, Subgroup.mem_subgroup_of, [anonymous], [anonymous], ←
      MulEquiv.map_inv, ← MulEquiv.map_mul, Subgroup.equiv_smul_apply_coe,
      Subgroup.smul_mem_pointwise_smul_iff]
rw [commensurable_conj, inv_smul_smul]
rw [Set.mem_setOf_eq, one_smul]
rw [Set.mem_setOf_eq, mul_smul]
exact trans ((commensurable_conj a).mp hb) ha
refine' FreeAbelianGroup.induction_on a _ _ _ _
· simp only [(lift _).map_zero, zero_add]
· intro x
    simp only [lift.of, Pi.add_apply]
· intro x h
    simp only [map_neg, lift.of, Pi.add_apply, neg_add]
· intro x y hx hy
    simp only [(lift _).map_add, hx, hy, add_add_add_comm]
simp only [FreeAbelianGroup.map_add]
exact lift.add' f _ _
rw [FreeAbelianGroup.map_neg, ih]
rw [FreeAbelianGroup.map_add, ihx, ihy]
rw [FreeAbelianGroup.map_zero, zero_seq, seq_zero]
rw [FreeAbelianGroup.map_zero, FreeAbelianGroup.map_zero, zero_seq]
rw [map_pure, map_pure, pure_seq, map_pure]
rw [FreeAbelianGroup.map_neg, FreeAbelianGroup.map_neg, neg_seq, ih]
rw [FreeAbelianGroup.map_add, FreeAbelianGroup.map_add, add_seq, ih1, ih2]
rw [FreeAbelianGroup.map_neg, neg_seq, seq_neg, ih]
rw [FreeAbelianGroup.map_add, add_seq, seq_add, ih1, ih2]
apply FreeAbelianGroup.induction_on x
· exact AddMonoidHom.map_zero _
· intro y
    rfl
· intro x h
    simp only [h, AddMonoidHom.map_neg]
· intro x y h₁ h₂
    simp only [h₁, h₂, AddMonoidHom.map_add]
rw [map_id]
rfl
rw [map_comp]
rfl
simp only [(· * ·), map_add, ← Pi.add_def, lift.add']
simp [← add_mul]
simp
simp
simp
unfold Mul.mul Semigroup.mul One.one
rw [lift.of]
refine'
        FreeAbelianGroup.induction_on x rfl (fun L => _) (fun L ih => _) fun x1 x2 ih1 ih2 => _
· erw [lift.of]
        congr 1
        exact mul_one L
· rw [map_neg, ih]
· rw [map_add, ih1, ih2]
unfold Mul.mul Semigroup.mul One.one
refine' FreeAbelianGroup.induction_on x rfl _ _ _
· intro L
        rw [lift.of, lift.of]
        congr 1
        exact one_mul L
· intro L ih
        rw [map_neg, ih]
· intro x1 x2 ih1 ih2
        rw [map_add, ih1, ih2]
simp only [zero_smul, AddMonoidHom.map_zero]
simp only [one_smul, lift.of]
simp
simp only [AddMonoidHom.map_add, add_smul] at *
rw [hx, hy]
rw [AddMonoidHom.map_zsmul, lift.of]
exact zsmul_int_one n
intro x
rw [← map_comp_apply, Equiv.symm_comp_self, map_id]
rfl
intro x
rw [← map_comp_apply, Equiv.self_comp_symm, map_id]
rfl
rw [List.length_append, List.length_append] <;> rfl
cases b <;> exact step.bnot
rw [← List.append_assoc, ← List.append_assoc] <;> constructor
simp
simp [step.cons_left_iff, not_step_nil]
simp (config := { contextual := true }) [step.cons_left_iff, iff_def, or_imp]
simp
simp [step.append_left_iff l, step.cons_cons_iff]
injections <;> subst_vars <;> simp
injections <;> subst_vars <;> simp
injections <;> subst_vars <;> simp
simp [H1, H3]
rfl
rfl
simp [append_append_left_iff L, cons_cons_iff]
rfl
rfl
simp
simp
have h₁ : Red ((x, not b)::(x, b)::L) [(x, not b)] := cons_cons h
have h₂ : Red ((x, not b)::(x, b)::L) L := ReflTransGen.single Step.cons_bnot_rev
let ⟨L', h₁, h₂⟩ := church_rosser h₁ h₂
rw [singleton_iff] at h₁ <;> subst L' <;> assumption
cases H <;> simp <;> constructor <;> constructor <;> rfl
ac_rfl
rfl
rfl
simp [inv_rev]
simp [inv_rev, (· ∘ ·)]
intro a b h
cases h
simp [inv_rev]
simp [inv_rev, one_eq_mk]
simp at ih⊢ <;> exact s.mul_mem (s.inv_mem <| H ⟨x, rfl⟩) ih
simp at ih⊢ <;> exact s.mul_mem (H ⟨x, rfl⟩) ih
simp only [lift.of]
cases H <;> simp
simp [g.map_mul, g.map_inv, hg, ih]
simp [g.map_mul, hg, ih]
simp
simp [Function.comp, map.comp]
simp [Function.comp, map.comp]
rw [← lift.unique (prod.comp (map f))]
· rfl
· simp
revert x
apply MonoidHom.toFun
apply map fun _ => (1 : ℤ)
cases b <;> simp [zpow_add] at ih⊢ <;> rw [ih] <;> rfl
simp
simp at ih <;> simp [zpow_add, ih]
simp at ih <;> simp [zpow_add, ih, sub_eq_add_neg, -Int.add_neg_one]
rw [map_inv, ih]
rw [map_mul, ihx, ihy]
rw [one_bind, map_one]
rw [pure_bind, map_pure]
rw [inv_bind, map_inv, ih]
rw [mul_bind, map_mul, ihx, ihy]
cases L2 <;> injections
dsimp
decide
simp only [norm, to_word_inv, inv_rev_length]
simp only [norm, List.length_eq_zero, to_word_eq_nil_iff]
rw [← mul_mk, mk_to_word, mk_to_word]
rw [f.map_mul, f.map_inv]
rfl
rw [relindex, subgroup_of, comap_comap, index_comap, ← f.map_range, K.subtype_range]
rw [← relindex_subgroup_of hKL]
exact relindex_mul_index fun x hx => hHK hx
rw [relindex, relindex, inf_subgroup_of_right]
rw [inf_comm, inf_relindex_right]
rw [sup_comm, relindex_sup_right]
rw [mul_mem_iff_of_index_two h]
rw [relindex, bot_subgroup_of, index_bot]
rw [relindex, subgroup_of_bot_eq_top, index_top]
rw [relindex, subgroup_of_self, index_top]
rw [← MonoidHom.comap_bot, index_comap, relindex_bot_left]
rfl
rw [← MonoidHom.comap_bot, relindex_comap, relindex_bot_left]
rfl
rw [← relindex_bot_left, ← index_bot]
exact relindex_mul_index bot_le
rw [Nat.card_congr (MonoidHom.ofInjective hf).toEquiv]
exact Dvd.intro f.range.index f.range.card_mul_index
rw [← Nat.card_congr (QuotientGroup.quotientKerEquivOfSurjective f hf).toEquiv]
exact Dvd.intro_left (Nat.card f.ker) f.ker.card_mul_index
simp only [← Nat.card_eq_fintype_card, nat_card_dvd_of_surjective f hf]
rw [← comap_map_eq, index_comap, relindex_mul_index (H.map_le_range f)]
rw [index_map, f.range_top_of_surjective hf, index_top, mul_one]
exact index_dvd_of_le le_sup_left
rw [index_map, sup_of_le_left hf]
apply dvd_mul_right
rw [← relindex_bot_left_eq_card, ← index_bot_eq_card, mul_comm] <;>
    exact relindex_mul_index bot_le
rw [← relindex_top_right] at hH hK⊢
exact relindex_inf_ne_zero hH hK
rw [normal_core_eq_ker]
infer_instance
rw [is_torsion, not_forall]
erw [← pow_succ', tsub_add_cancel_of_le, pow_order_of_eq_one]
exact order_of_pos' (tG g)
rw [pow_mul, ← h, ← Subgroup.coe_pow, hnn, Subgroup.coe_one]
simp only [nsmul_eq_smul_cast R _ f, ← nsmul_one, hn, zero_smul]
rw [mul_left_iterate, _root_.mul_one, Submonoid.coe_pow, Subtype.coe_mk, Submonoid.coe_one,
        (is_periodic_pt_mul_iff_pow_eq_one _).mp hn]
rw [pow_zero, order_of_one]
rw [mul_pow, pow_add, pow_mul, hm, one_pow, Monoid.one_mul, mul_comm, pow_mul, hn,
            one_pow]
dsimp [Setoid.ker, on_fun] at *
rw [h, h1, h2, h]
apply ext_iff.2 h
rw [← hr] <;> exact h c hS
rw [con_gen_eq] <;> exact Inf_le h
rw [con_gen_eq] <;> exact Inf_le fun _ _ => id
rw [con_gen_eq]
apply congr_arg Inf
simp only [le_def, or_imp, ← forall_and]
rw [sup_eq_con_gen] <;> rfl
rw [Sup_eq_con_gen, Sup_image]
congr
rw [H, hw, hy]
rw [H, hx, hz]
rw [← con_gen_of_con (c.map_of_surjective f H h hf)] <;> rfl
rw [H, H] <;> exact c.mul h1 h2
rw [mul_ker_mk_eq] <;> exact d.2
rw [c.eq.2 h] <;> exact d.refl _
rw [mul_ker_mk_eq] at h <;> exact c.eq.2 h ▸ d.refl _
    ext fun x y =>
      ⟨fun h =>
        let ⟨a, b, hx, hy, H⟩ := h
        hx ▸ hy ▸ H,
        (Con.induction_on₂ x y) fun w z h => ⟨w, z, rfl, rfl, h⟩⟩
  map_rel_iff' s t
rw [H]
rw [← c.eq] <;> rfl
rw [← f.map_one] <;> rfl
rw [c.eq.2 h]
rw [← lift_apply_mk' f, ← lift_apply_mk' g]
congr 1
exact MonoidHom.ext_iff.2 h
subst f
rfl
rw [Function.comp_apply, ker_lift_mk, hf]
rw [← d.mk'.map_mul] <;> rfl
rw [MonoidHom.comp_apply, MonoidHom.comp_apply, ← of_apply, ← MonoidHom.comp_apply, ←
        MonoidHom.comp_apply, h]
simp only [lift_of, Pi.mulSingle_eq_same, MonoidHom.id_apply]
simp only [lift_of]
intro m
rw [inv_def]
apply m.induction_on
· rw [MonoidHom.map_one, MulOpposite.unop_one, one_mul]
· intro i m
        change of m
simp only [lift_of]
simp [fst_idx]
rw [rcons, dif_neg]
rfl
exact h1 ⟨i, m⟩ (ls.mem_cons_self _)
rw [rcons, dif_pos hm, hm, MonoidHom.map_one, one_mul]
rw [rcons, dif_neg hm, Prod, List.map_cons, List.prod_cons, Prod]
cases ij <;> exact fst_idx_ne_iff.mpr h2.rel_head'
cases ij <;> exact cons_eq_rcons.symm
simp only [mul_assoc, ← equiv_pair_symm, Equiv.apply_symm_apply]
rw [cons_eq_rcons, of_smul_def, equiv_pair_eq_of_fst_idx_ne _] <;> simp only [mul_one]
apply m.induction_on
· intro
    rw [one_smul, one_mul]
· intros
    rw [of_smul_def, prod_rcons, of.map_mul, mul_assoc, ← prod_rcons, ← equiv_pair_symm,
      Equiv.symm_apply_apply]
· intro x y hx hy w
    rw [mul_smul, hx, hy, mul_assoc]
dsimp only <;> rw [prod_smul, prod_empty, mul_one]
apply smul_induction
· dsimp only
      rw [prod_empty, one_smul]
· dsimp only
      intro i m w ih
      rw [prod_smul, mul_smul, ih]
rw [← Option.mem_def]
induction w
· rw [Option.mem_def]
    rfl
· exact List.head'_append w_ih_w₁
rw [← Option.mem_def]
induction w
· rw [Option.mem_def]
    rfl
· exact List.last'_append w_ih_w₂
induction w
· exact List.chain'_singleton _
· apply List.Chain'.append w_ih_w₁ w_ih_w₂
      intro x hx y hy
      rw [w_w₁.to_list_last', Option.mem_some_iff] at hx
      rw [w_w₂.to_list_head', Option.mem_some_iff] at hy
      subst hx
      subst hy
      exact w_hne
simp [to_word, Prod, word.prod]
simp [to_word, Prod, word.prod]
induction w
rfl
exact w_ih_w₁ _ _
induction w
rfl
exact w_ih_w₁ _ _
unfold mul_head
induction w
· simp [mul_head, replace_head]
· specialize w_ih_w₁ _ hnotone
    clear w_ih_w₂
    simp [replace_head, ← mul_assoc] at *
    congr 1
induction w <;> simp [inv, *]
induction w <;> simp [inv, *]
induction w <;> simp [inv, *]
simp [MulAction.mul_smul]
rw [← div_inv_eq_mul]
exact div_ne_one_of_ne hnh
rw [zpow_add, zpow_one]
rw [zpow_sub, zpow_one]
cases P <;> cases Q <;> congr
rw [← P.3 (hQ.map ϕ) (le_trans (ge_of_eq (map_comap_eq_self h)) (map_mono hle))]
exact (comap_map_eq_self ((P.1.ker_le_comap ϕ).trans hle)).symm
rw [SetLike.ext_iff] at h⊢
exact fun g => ⟨fun hg => (h ⟨g, hP hg⟩).mp hg, fun hg => (h ⟨g, hQ hg⟩).mpr hg⟩
simp only [← hg, h]
cases nonempty_fintype (Sylow p G)
infer_instance
simp only [Sylow.smul_eq_iff_mem_normalizer, normalizer_eq_top.mpr h, mem_top]
rw [P.sylow_mem_fixed_points_iff, ← inf_eq_left, hP.inf_normalizer_sylow, inf_eq_left]
exact Exists.elim this fun R hR => (congr_arg _ (Sylow.ext (H.mp hR))).mp R.2
rw [this]
infer_instance
simp [this]
rw [this]
rw [← Classical.choose_spec (exists_smul_eq G P Q)]
exact P.equiv_smul (Classical.choose (exists_smul_eq G P Q))
rw [P.orbit_eq_top]
rw [P.stabilizer_eq_normalizer]
apply h.comap_of_ker_is_p_group
rw [QuotientGroup.ker_mk]
exact P.2
rw [← Sylow.normalizer_sup_eq_top (P.subtype hP), P.coe_subtype, subgroup_of_map_subtype,
    inf_of_le_left hP]
rw [← Fintype.card_prod, Fintype.card_congr (preimage_mk_equiv_subgroup_times_set _ _)]
intros
rw [setoidHasEquiv]
simp only [left_rel_apply]
rfl
rw [← Fintype.card_congr (fixed_points_mul_left_cosets_equiv_quotient H)]
exact ((IsPGroup.of_card hH).card_modeq_card_fixed_points _).symm
show
      card
rw [hK'.1, tsub_add_cancel_of_le h0m.nat_succ_le]
simp [hH, hnm]
simp
rw [← normalizer_eq_top, ← normalizer_sup_eq_top' P le_normalizer, sup_idem]
congr 1
rw [div_eq_mul_inv] <;> exact mul_mem hx (inv_mem hy)
rw [zpow_ofNat]
exact pow_mem hx n
rw [zpow_negSucc]
exact inv_mem (pow_mem hx n.succ)
rw [← inv_mem_iff, div_eq_mul_inv, div_eq_mul_inv, mul_inv_rev, inv_inv]
simp [hx]
cases x
rfl
cases x
rfl
cases x
rfl
cases a
simp only [inclusion, SetLike.coe_mk, MonoidHom.mk'_apply]
cases p <;> cases q <;> congr
cases x <;> rfl
cases x <;> rfl
cases x <;> rfl
cases x <;> rfl
simp
cases a
simp only [inclusion, coe_mk, MonoidHom.mk'_apply]
simp [*]
rw [Subgroup.eq_bot_iff_forall]
intro y hy
rw [← Subgroup.coe_mk H y hy, Subsingleton.elim (⟨y, hy⟩ : H) 1, Subgroup.coe_one]
rfl
rw [hg]
infer_instance
simp [h]
simp
apply Set.mem_Inter₂.1 hx i h
simp only [infi, mem_Inf, Set.forall_range_iff]
simp only [infi, coe_Inf, Set.bInter_range]
simp [Subgroup.one_mem]
refine' Exists.elim _ fun (hx : x ∈ closure k) (hc : p x hx) => hc
exact
    closure_induction hx (fun x hx => ⟨_, Hs x hx⟩) ⟨_, H1⟩
      (fun x y ⟨hx', hx⟩ ⟨hy', hy⟩ => ⟨_, Hmul _ _ _ _ hx hy⟩) fun x ⟨hx', hx⟩ => ⟨_, Hinv _ _ hx⟩
refine' closure_induction' (fun g hg => _) _ (fun g₁ g₂ hg₁ hg₂ => _) (fun g hg => _) hx
· exact subset_closure hg
· exact one_mem _
· exact mul_mem
· exact inv_mem
simp only [mul_one, one_mul]
simp only [mul_one, one_mul]
rw [mul_assoc, h₂, ← mul_assoc, h₁, mul_assoc]
rw [← mul_assoc, h₁, mul_assoc, h₂, ← mul_assoc]
rw [inv_mul_eq_iff_eq_mul, ← mul_assoc, h, mul_assoc, mul_inv_self, mul_one]
rw [mul_inv_eq_iff_eq_mul, mul_assoc, h, ← mul_assoc, inv_mul_self, one_mul]
rw [← le_bot_iff]
exact closure_le _
simp [eq_bot_iff_forall, mem_closure_singleton]
simp [mem_supr_of_directed hS]
rw [f.map_inv] <;> exact H.inv_mem ha
rw [← SetLike.coe_set_eq]
simp [Set.image_inter hf]
rw [inf_comm, inf_subgroup_of_right]
rw [disjoint_iff, ← bot_subgroup_of, subgroup_of_inj, bot_inf_eq]
rw [← top_subgroup_of, subgroup_of_inj, top_inf_eq, inf_eq_right]
simp [mem_prod, MonoidHom.coe_fst]
simp [mem_prod, MonoidHom.coe_snd]
simp [coe_prod, Prod.one_eq_mk]
simp [mem_pi]
simp [mem_pi]
simp
simp [mul_comm, mul_left_comm]
refine' characteristic_iff_comap_le.mpr fun ϕ g hg h => _
rw [← ϕ.injective.eq_iff, ϕ.map_mul, ϕ.map_mul]
exact hg (ϕ h)
rw [eq_top_iff']
intro x y
exact mul_comm y x
rw [eq_top_iff'] at h
intro x y
exact h y x
simp
rw [hb, ha]
simp [mul_assoc]
simp
rw [hb, ha]
simp [mul_assoc]
rw [Set.card_image_of_injective S conj_injective]
rw [← inv_mem_iff, mem_normalizer_iff, inv_inv]
rw [h, mul_assoc, mul_inv_cancel_right]
rw [mul_assoc, ← h, inv_mul_cancel_right]
rw [H.mul_mem_cancel_right (H.inv_mem xH), H.mul_mem_cancel_left xH]
simp [← mem_center_iff.mp hx y, mul_assoc]
simp only [mem_normalizer_iff, mem_comap]
intro h n
simp [h (f n)]
simp only [mem_centralizer_iff, mul_inv_eq_iff_eq_mul, one_mul]
refine' subgroup.characteristic_iff_comap_le.mpr fun ϕ g hg h hh => ϕ.Injective _
rw [map_mul, map_mul]
exact hg (ϕ h) (subgroup.characteristic_iff_le_comap.mp hH ϕ hh)
intro a w
refine' closure_induction w (fun x hx => _) _ (fun x y ihx ihy => _) fun x ihx => _
· exact conjugates_of_set_subset h hx
· exact one_mem _
· exact mul_mem ihx ihy
· exact inv_mem ihx
infer_instance
simp only [subset_normal_closure, closure_le]
rw [mul_one, mul_inv_self] <;> exact H.one_mem
  inv_mem' a h b
rw [← mul_one a, ← inv_one, ← one_mul a]
exact h 1
rw [mul_assoc, mul_assoc, ← mul_inv_rev, ← mul_assoc, ← mul_assoc] <;> exact h (c * b)
simp [Set.ext_iff]
rw [coe_range, coe_top]
rw [hx, one_mul]
rw [← map_mul, mul_inv_self, map_one]
constructor <;> intro h
· rw [mem_ker, map_mul, h, ← map_mul, inv_mul_self, map_one]
· rw [← one_mul x, ← mul_inv_self y, mul_assoc, map_mul, f.mem_ker.1 h, mul_one]
rw [← comap_bot, ← comap_bot, ← comap_bot, ← prod_map_comap_prod, bot_prod_bot]
rw [mem_ker, map_mul, map_mul, f.mem_ker.1 hx, mul_one, map_mul_eq_one f (mul_inv_self y)]
rw [SetLike.mem_coe, mem_comap] <;> exact subset_closure hx
rw [← normalizer_eq_top, ← top_le_iff, ← f.range_top_of_surjective hf, f.range_eq_map, ←
    normalizer_eq_top.2 h]
exact le_normalizer_map _
rw [map_eq_bot_iff, f.ker_eq_bot_iff.mpr hf, le_bot_iff]
rw [coe_map, coe_comap, Set.image_preimage_eq_inter_range, coe_inf, coe_range, Set.inter_comm]
simp [mem_ker, hy']
simp only [le_antisymm_iff, comap_le_comap_of_surjective h, imp_self]
rw [map_le_iff_le_comap, comap_map_eq]
simp only [map_le_map_iff, sup_le_iff, le_sup_right, and_true_iff]
simp only [le_antisymm_iff, map_le_map_iff']
rw [f.range_eq_map, map_eq_map_iff, codisjoint_iff, top_sup_eq]
rw [map_le_iff_le_comap, comap_map_eq_self_of_injective hf]
rw [coe_map, coe_comap, Set.image_eq_preimage_of_inverse hl hr]
rw [map_comap_eq, map_sup, map_comap_eq, map_comap_eq, inf_eq_right.mpr hH,
        inf_eq_right.mpr hK, inf_eq_right.mpr (sup_le hH hK)]
apply Subgroup.map_injective hf
rw [map_comap_eq_self h]
apply le_antisymm
· refine' le_trans (le_of_eq _) (map_mono (le_normalizer_comap _))
    rw [map_comap_eq_self h]
· refine' le_trans (le_normalizer_map f) (le_of_eq _)
    rw [map_comap_eq_self (le_trans le_normalizer h)]
intro x y
rw [← g.map_mul, ← mul_inv_eq_one, ← g.map_inv, ← g.map_mul, ← g.mem_ker]
apply hg
rw [f.mem_ker, f.map_mul, f.map_inv, mul_inv_eq_one, f.map_mul]
simp only [hf _]
dsimp [lift_of_right_inverse_aux]
rw [← mul_inv_eq_one, ← g.map_inv, ← g.map_mul, ← g.mem_ker]
apply hg
rw [f.mem_ker, f.map_mul, f.map_inv, mul_inv_eq_one]
simp only [hf _]
simp [(mem_ker _).mp hx]
simp (config := { contextual := true }) [Subgroup.mem_comap, hH.conj_mem]
simp
rw [Subgroup.zpowers_eq_closure, Subgroup.zpowers_eq_closure, f.map_closure, Set.image_singleton]
rw [mul_comm, eq_comm, ← smul_eq_mul]
rw [Subtype.ext_iff, coe_mul, coe_mul, Subtype.coe_mk, Subtype.coe_mk, ← h₁, ← h₂,
        zpow_mul_comm]
rw [zpowers_eq_closure, closure_le, Set.singleton_subset_iff, SetLike.mem_coe]
rw [eq_bot_iff, zpowers_le, mem_bot]
rw [← centralizer_top, ← hS, centralizer_closure]
rw [center_eq_infi S hS, ← infi_subtype'']
simp
simp
simp only [SetLike.exists, coe_mk]
refine' (iH.comap f).eq_bot_or_eq_top.imp (fun h => _) fun h => _
· rw [← map_bot f, ← h, map_comap_eq_self_of_surjective hf]
· rw [← comap_top f] at h
      exact comap_injective hf h
refine'
    map_injective_of_ker_le B.subtype (ker_le_comap _ _)
      (le_trans (ker_le_comap B.subtype _) le_sup_left) _
· simp only [subgroup_of, map_comap_eq, map_sup, subtype_range]
    rw [inf_of_le_right (sup_le hA hA'), inf_of_le_right hA', inf_of_le_right hA]
simp only [Disjoint, SetLike.le_def, mem_inf, mem_bot, and_imp]
refine' (hH this).imp _ id
simp only [IsEmpty.forall_iff, Nat.succ_ne_zero]
rw [SetLike.mem_coe, ← Subgroup.inv_mem_iff]
exact subset_closure (mem_inv.mp hs)
simp only [← to_submonoid_eq, closure_to_submonoid, inv_inv, union_comm]
rw [mul_one]
simp [← ha, ← hb, mul_assoc]
rw [mul_assoc h, inv_mul_cancel_left, ← hx, mul_inv_rev]
rw [sup_eq_closure]
apply Inf_le _
dsimp
rfl
rw [mul_one]
simp [← ha, ← hb, mul_assoc]
rw [mul_inv_cancel_right, ← mul_inv_rev, hx]
rw [sup_eq_closure]
apply Inf_le _
dsimp
rfl
simp [SetLike.ext_iff, mem_pointwise_smul_iff_inv_smul_mem]
simp [commutator, Subgroup.commutator_def, commutatorSet]
simp [commutator, Subgroup.commutator_def', commutatorSet]
rw [commutator_eq_closure]
apply Group.closure_finite_fg
rw [Subgroup.rank_congr (commutator_eq_closure G)]
apply Subgroup.rank_closure_finite_le_nat_card
rw [two_mul]
exact
    (Subgroup.rank_closure_finite_le_nat_card _).trans
      ((Set.card_union_le _ _).trans
        (add_le_add ((Finite.card_image_le _).trans (Finite.card_range_le _))
          ((Finite.card_image_le _).trans (Finite.card_range_le _))))
rw [← image_commutator_set_closure_commutator_representatives G]
exact Nat.card_congr (Equiv.Set.image _ _ (subtype_injective _))
rw [commutator_eq_closure G, ← image_commutator_set_closure_commutator_representatives, ←
    MonoidHom.map_closure, ← commutator_eq_closure]
exact Nat.card_congr (Equiv.Set.image _ _ (subtype_injective _))
apply Nat.finite_of_card_ne_zero
rw [card_commutator_set_closure_commutator_representatives]
exact finite.card_pos.ne'
ac_rfl
rw [ht₁]
ac_rfl
rw [ht₂]
ac_rfl
ac_rfl
rw [ht₁, ht₂]
ac_rfl
simp
rw [r_eq_r' S] <;> rfl
cases y
cases z
exact H h
rw [eq_rec_constant, H h]
rw [h]
unfold HasSmul.smul Localization.smul
apply lift_on_mk
simp only [smul_mk, smul_comm s t r]
simp only [smul_mk, smul_assoc s t r]
simp only [smul_mk, smul_eq_mul, mk_mul, mul_comm r₁, smul_mul_assoc]
simp only [smul_mk, smul_eq_mul, mk_mul, smul_mul_assoc]
simp only [smul_mk, op_smul_eq_smul]
intros
simp only [Localization.smul_mk, one_smul]
intros
simp only [Localization.smul_mk, mul_smul]
simp only [← Localization.mk_one, Localization.smul_mk, smul_one]
simp only [Localization.smul_mk, Localization.mk_mul, smul_mul']
rw [mul_comm, sec_spec]
rw [eq_comm, mul_inv_left h, mul_comm, eq_comm]
rw [mul_inv_right h, mul_assoc, mul_comm _ (f y₂), ← mul_assoc, mul_inv_left h, mul_comm x₂,
    f.map_mul, f.map_mul]
rw [mul_comm _ x, mul_comm _ y, h]
rw [← mul_assoc, ← mul_assoc, mul_inv_right f.map_units, mul_assoc, mul_assoc,
          mul_comm _ (f.to_map x₂), ← mul_assoc, ← mul_assoc, mul_inv_right f.map_units,
          Submonoid.coe_mul, f.to_map.map_mul, f.to_map.map_mul] <;>
        ac_rfl
rw [mk', MonoidHom.map_one] <;> exact mul_one _
rw [← sec_spec, mul_inv_left, mul_comm]
rw [mul_assoc, mul_comm _ (f.to_map y), ← mul_assoc, mul_inv_left, mul_comm]
rw [mul_comm, mk'_spec]
rw [H, mk'_spec]
erw [mul_inv_right, H] <;> rfl
rw [eq_comm, eq_mk'_iff_mul_eq, eq_comm]
rw [f.to_map.map_mul, f.mk'_eq_iff_eq_mul.1 H, mul_assoc, mul_comm (f.to_map _), ← mul_assoc,
      mk'_spec, f.to_map.map_mul]
rw [mk'_eq_iff_eq_mul, mk', mul_assoc, mul_comm _ (f.to_map y₁), ← mul_assoc, ←
      f.to_map.map_mul, ← H, f.to_map.map_mul, mul_inv_right f.map_units]
rw [f.eq, Localization.r_iff_exists]
rw [mul_inv_left, mul_one]
rw [← mk'_one, ← mk'_mul, one_mul]
rw [mul_comm, mul_mk'_eq_mk'_of_mul]
rw [mul_mk'_eq_mk'_of_mul, mul_one]
rw [← mul_mk'_one_eq_mk', f.to_map.map_mul, mul_assoc, mul_mk'_one_eq_mk', mk'_self', mul_one]
rw [mul_comm, mk'_mul_cancel_right]
rw [← sec_spec, one_mul]
rw [f.to_map.map_mul, f.to_map.map_mul, sec_spec', mul_assoc, f.mk'_spec, mul_comm]
rw [mul_comm]
show _ * (_ * _) = _ ↔ _
rw [← mul_assoc, mul_inv_left hg, mul_comm]
rw [f.lift_mk' hg] <;> exact mul_inv_left hg _ _ _
erw [mul_assoc, IsUnit.liftRight_inv_mul, mul_one]
rw [mul_comm, lift_mul_right]
rw [sec_spec', f.to_map.map_mul]
rw [lift_mk', lift_mk', mul_inv hg]
rw [← f.lift_of_comp j, ← f.lift_of_comp k]
congr 1
rw [map, lift_mk', mul_inv_left]
· show k.to_map (g x) = k.to_map (g y) * _
    rw [mul_mk'_eq_mk'_of_mul]
    exact (k.mk'_mul_cancel_left (g x) ⟨g y, hy y⟩).symm
rw [mul_comm, f.map_mul_right]
rw [k.to_map.map_mul, k.to_map.map_mul, sec_spec', mul_assoc, map_mul_right]
rw [← f.map_comp_map hy j hl] <;> rfl
rw [mul_mk'_eq_mk'_of_mul, mk'_self]
rw [add_mk'_eq_mk'_of_add, mk'_self]
rw [← hx, k.map_mul, ← hz] <;> rfl
rw [mul_equiv_of_localizations_left_inv]
erw [hv, hw, hx] <;> rfl
erw [← hd, ← k.map_mul, ← k.map_mul] at hc <;> exact k.to_equiv.injective hc
erw [← k.map_mul] <;> rw [hc, k.map_mul] <;> rfl
rw [mk_mul, mul_one]
rw [mk_mul, mul_one, one_mul, mk_self]
rw [mk_mul, mul_comm x.fst, ← mk_mul, mk_self, one_mul]
rw [mul_one, mul_one]
rw [mul_comm 1 y, mk_mul]
rw [mul_one, mul_one]
rw [← mk_eq_monoid_of_mk', lift_on_mk]
rw [← mk_eq_monoid_of_mk', lift_on₂_mk]
rw [mk_eq_monoid_of_mk'_apply] <;> exact mul_equiv_of_quotient_mk' _ _
rw [mk_eq_monoid_of_mk'_apply] <;> exact mul_equiv_of_quotient_symm_mk' _ _
intros
refine' mk_eq_mk_iff.mpr (r_of_eq _)
simp only [zero_mul, mul_zero]
simp
rw [← mk_zero 1, lift_on_mk]
rw [localization_map.sec_spec', mul_zero]
rw [MonoidHom.to_fun_eq_coe, localization_map.lift_spec, mul_zero, ← map_zero g, ←
        g.to_monoid_hom_coe]
refine' f.to_localization_map.eq_of_eq hg _
rw [localization_map.sec_zero_fst]
exact f.to_monoid_with_zero_hom.map_zero.symm
rw [← AddMonoidHom.comp_apply, Finsupp.to_free_abelian_group_comp_to_finsupp,
    AddMonoidHom.id_apply]
simp only [to_finsupp, lift.of]
rw [← AddMonoidHom.comp_apply, to_finsupp_comp_to_free_abelian_group, AddMonoidHom.id_apply]
rw [support, Finsupp.mem_support_iff]
exact Iff.rfl
rw [support, Finsupp.not_mem_support_iff]
exact Iff.rfl
simp only [support, Finsupp.support_zero, AddMonoidHom.map_zero]
simp only [support, to_finsupp_of, Finsupp.support_single_ne_zero _ one_ne_zero]
simp only [support, AddMonoidHom.map_neg, Finsupp.support_neg]
simp only [support, AddMonoidHom.map_add]
apply Finsupp.support_add
rw [one_smul, diff_self]
rw [mul_smul, ← diff_mul_diff, smul_diff_smul]
rw [transfer, ← diff_mul_diff, ← smul_diff_smul, mul_comm, diff_mul_diff] <;> rfl
rw [← mul_right_inj, hk, mul_inv_cancel_right]
apply transfer_eq_pow
have hf : Function.Bijective ((transfer_sylow P hP).restrict (P : Subgroup G)) :=
    (transfer_sylow_restrict_eq_pow P hP).symm ▸
      (P.2.powEquiv'
          (not_dvd_index_sylow P
            (mt index_eq_zero_of_relindex_eq_zero index_ne_zero_of_finite))).Bijective
rw [Function.Bijective, ← range_top_iff_surjective, restrict_range] at hf
have := range_top_iff_surjective.mp (top_le_iff.mp (hf.2.ge.trans (map_le_range _ P)))
rw [← (comap_injective this).eq_iff, comap_top, comap_map_eq, sup_comm, SetLike.ext'_iff,
    normal_mul, ← ker_eq_bot_iff, ← (map_injective (P : Subgroup G).subtype_injective).eq_iff,
    ker_restrict, subgroup_of_map_subtype, Subgroup.map_bot, coe_top] at hf
exact is_complement'_of_disjoint_and_mul_eq_univ (disjoint_iff.2 hf.1) hf.2
rw [← mul_smul, mul_comm, mul_smul]
rw [smul_assoc, smul_assoc, smul_comm b]
infer_instance
simp only [smul, mul_smul]
rw [← f.map_one, hsmul, one_smul]
simp only [← f.map_mul, hsmul, mul_smul]
rw [smul_mul_assoc, mul_smul_comm, ← smul_assoc, smul_eq_mul]
simp [g.map_one, MulAction.one_smul]
simp [g.map_mul, MulAction.mul_smul]
rw [smul_assoc, one_smul]
rw [smul_mul_assoc, one_mul]
rw [← smul_eq_mul, ← smul_comm, smul_eq_mul, mul_one]
rw [← h, smul_eq_mul, mul_assoc, h, smul_eq_mul]
rw [← H x z, smul_eq_mul, ← H, smul_eq_mul, mul_assoc]
rw [smul_one_mul, smul_smul]
simp only [smul, map_zero, smul_zero]
simp only [← map_zero f, ← smul, smul_zero]
rw [hsmul, smul_zero]
simp only [smul, map_add, smul_add]
simp only [hsmul, smul_add]
rw [← smul_add, neg_add_self, smul_zero]
rw [sub_eq_add_neg, sub_eq_add_neg, smul_add, smul_neg]
simp only [smul, f.map_mul, smul_mul']
simp only [smul, f.map_one, smul_one]
simp only [← f.map_one, ← smul, smul_one]
simp [units_smul_def]
simp [units_smul_def, mul_assoc, mul_inv_rev]
simp [units_smul_def, mul_assoc]
simp [units_smul_def]
rw [units_smul_def, units_smul_def, mul_smul_comm, smul_mul_assoc]
simp [units_smul_def]
simp [units_smul_def, mul_add, add_mul]
simp [smul_def]
simp [smul_def, mul_assoc, mul_inv_rev]
rw [smul_def, smul_def, mul_smul_comm, smul_mul_assoc]
simp [smul_def]
simp [smul_def, mul_add, add_mul]
simp [smul_def, mul_assoc]
simp [smul_def]
simp [smul_def]
simp [smul_def, mul_assoc]
rw [smul_def, smul_def, mul_smul_comm, smul_mul_assoc]
change _ * _
cases p <;> cases q <;> congr
refine' { toFun := coe.. } <;> simp [coe_smul]
rw [← one_smul R x, ← smul_assoc]
exact p.smul_mem _ h
rw [← Subgroup.to_submonoid_eq]
exact stabilizer_of_sub_mul.submonoid m
rw [← neg_one_smul R]
exact p.smul_mem _ hx
rw [← neg_neg x]
exact neg_mem _ h
cases x
rw [smul_mk, smul_mk, smul_mk, smul_assoc]
cases x
rw [smul_mk, smul_mk, smul_mk, smul_mk, smul_comm]
cases x
rw [smul_mk, smul_mk, op_smul_eq_smul]
cases x
rw [smul_mk, smul_mk, smul_mk, mul_smul]
cases x
rw [smul_mk, one_smul]
rw [mul_smul, hy z, hx z]
rw [inv_smul_eq_iff, hx z]
rw [pow_one, pow_one]
rw [pow_succ _ (n + 1), pow_succ _ (n + 1), coe_mul, coe_pow n.succ_ne_zero]
rw [pow_zero, pow_zero]
exact subset_coe_one
simp [MulAction.one_smul]
rw [← smul_smul, hb, ha]
simp [h x, hx.symm]
rw [inv_smul_eq_iff, ha]
rw [inv_smul_smul]
simp only [orbit_smul, mem_orbit_self]
simp only [orbit_smul, mem_orbit]
simp [orbit_eq_iff.symm, eq_comm]
simp (config := { contextual := true }) [orbit_eq_iff.symm, eq_comm]
induction x using Quotient.inductionOn'
rw [Quotient.eq']
rfl
rw [← hg, stabilizer_smul_eq_stabilizer_map_conj]
rw [← hg, stabilizer_vadd_eq_stabilizer_map_conj]
rw [← sub_eq_zero]
refine' h _ _
rw [smul_sub, h', sub_self]
rw [smul_mul_smul, Units.mul_inv, mul_right_inv, one_smul]
rw [smul_mul_smul, Units.inv_mul, mul_left_inv, one_smul]
rw [← quotient.smul_mk, QuotientGroup.out_eq']
rw [mul_assoc, ← QuotientGroup.eq', QuotientGroup.out_eq', ← smul_eq_mul, quotient.mk_smul_out',
    eq_comm, pow_smul_eq_iff_minimal_period_dvd]
rw [smul_smul, mul_inv_cancel_left]
rw [← Fintype.card_prod, Fintype.card_congr (orbit_prod_stabilizer_equiv_group α b)]
infer_instance
refine'
    le_antisymm
      (fun g hg =>
        Equiv.Perm.ext fun q =>
          QuotientGroup.induction_on q fun g' =>
            (MulAction.quotient.smul_mk H g g').trans (quotient_group.eq.mpr _))
      (subgroup.normal_le_normal_core.mpr fun g hg => _)
· rw [smul_eq_mul, mul_inv_rev, ← inv_inv g', inv_inv]
    exact H.normal_core.inv_mem hg g'
rw [smul_smul, mul_left_inv, one_smul]
rw [smul_smul, mul_right_inv, one_smul]
rw [inv_eq_iff_mul_eq_one, smul_mul_smul, mul_right_inv, mul_right_inv, one_smul]
cases p <;> simp [smul_pow, smul_inv]
rw [Commute.symm_iff, Commute.smul_right_iff, Commute.symm_iff]
rw [← inv_smul_smul a x, h, smul_zero]
intro
simp only [inv_one, one_smul]
intros
simp only [mul_smul, mul_inv_rev]
rw [Prod.smul_mk, smul_zero]
rw [Prod.smul_mk, smul_zero]
injection h (a, b)
injection h (a, b)
simp [smul_def, mul_def, mul_smul_comm]
simp [smul_def, mul_def, smul_mul_assoc]
cases x <;> rfl
injection h (inl a)
injection h (inr b)
induction y using MulOpposite.rec
simp [smul_mul_assoc]
injection h (some b)
refine' div_le_one_of_le _ (sq_nonneg (Nat.card M))
rw [← Nat.cast_pow, Nat.cast_le, sq, ← Nat.card_prod]
apply Finite.card_subtype_le
rw [commProb, card_comm_eq_card_conj_classes_mul_card, Nat.cast_mul, sq]
exact mul_div_mul_right _ _ (nat.cast_ne_zero.mpr finite.card_pos.ne')
rw [comm_prob_def', comm_prob_def', div_le_iff, mul_assoc, ← Nat.cast_mul, ← Subgroup.index,
    H.card_mul_index, div_mul_cancel, Nat.cast_le]
· apply Finite.card_le_of_surjective
    show Function.Surjective (ConjClasses.map (QuotientGroup.mk' H))
    exact ConjClasses.map_surjective Quotient.surjective_Quotient_mk''
· exact nat.cast_ne_zero.mpr finite.card_pos.ne'
· exact nat.cast_pos.mpr Finite.card_pos
simp only [exponent_exists_iff_ne_zero, not_not]
rw [Nat.mod_add_div]
simp [pow_add, pow_mul, pow_exponent_eq_one]
have h : ∃ n, 0 < n ∧ ∀ g : G, g ^ n = 1 := ⟨n, hpos, hG⟩
rw [exponent, dif_pos]
exact (Nat.find_spec h).1
rw [exponent, dif_pos]
· apply Nat.find_min'
    exact ⟨hpos, hG⟩
· exact ⟨n, hpos, hG⟩
apply le_antisymm
· apply exponent_min' _ Nat.one_pos
    simp
· apply Nat.succ_le_of_lt
    apply exponent_pos_of_exists 1 Nat.one_pos
    simp
apply Finset.lcm_dvd
intro g hg
exact order_dvd_exponent g
rw [h, pow_zero, order_of_one]
rw [ht] at h
apply h
rw [bot_eq_zero, Nat.factorization_zero, Finsupp.zero_apply]
intro h
rw [h, zero_dvd_iff] at this
exact htpos.ne' this
rw [ht] at this
exact this.not_le (le_cSup hfin.bdd_above <| Set.mem_range_self _)
rw [order_of_pow' t (pow_ne_zero k hp.ne_zero), Nat.gcd_eq_right hpk]
simp
rw [← Finset.Nonempty.cSup_eq_max', Finset.coe_image, Finset.coe_univ, Set.image_univ, ← supr]
exact exponent_eq_supr_order_of order_of_pos
rw [← MonoidHom.range_top_iff_surjective, eq_top_iff, ← hS2, closure_le]
exact fun g hg => ⟨Pi.mulSingle ⟨g, hg⟩ ⟨g, mem_zpowers g⟩, noncomm_pi_coprod_mul_single _ _⟩
simp [Subgroup.one_mem]
specialize hx y
rw [upper_central_series_step_eq_comap_center]
infer_instance
rw [mul_inv_eq_one, mul_inv_eq_iff_eq_mul, eq_comm]
intro x hx
rw [mem_upper_central_series_succ_iff]
exact fun y => ascending_central_series_le_upper n (hH.2 x n hx y)
constructor
rfl
intro x n hxn g
exact commutator_mem_commutator hxn (mem_top g)
constructor
· intro h
    exact Nat.find_le h
· intro h
    apply eq_top_iff.mpr
    rw [← upper_central_series_nilpotency_class]
    exact upper_central_series_mono _ h
rw [← lower_central_series_length_eq_nilpotency_class]
exact Nat.find_spec (nilpotent_iff_lower_central_series.mp _)
constructor
· intro h
    rw [← lower_central_series_length_eq_nilpotency_class]
    exact Nat.find_le h
· intro h
    apply eq_bot_iff.mpr
    rw [← lower_central_series_nilpotency_class]
    exact lower_central_series_antitone h
simp
simp [f.map_one, Subgroup.one_mem _]
simp [MonoidHom.map_mul, Subgroup.mul_mem _ hy hz]
simp [f.map_inv, Subgroup.inv_mem _ hy]
simp [commutatorElement_def]
rw [← lower_central_series_length_eq_nilpotency_class]
apply Nat.find_min'
refine' lower_central_series_succ_eq_bot (le_trans ((map_eq_bot_iff _).mp _) hf1)
apply eq_bot_iff.mpr
apply le_trans (lowerCentralSeries.map f _)
simp only [lower_central_series_nilpotency_class, le_bot_iff]
rw [hn]
rw [hn]
subst h
rw [upper_central_series_step_eq_comap_center]
simp [Group.nilpotencyClass, Nat.find_eq_zero, subsingleton_iff_bot_eq_top]
simp [nilpotency_class_quotient_center, h]
apply upper_central_series_eq_top_iff_nilpotency_class_le.mp
rw [upper_central_series_one]
apply CommGroup.center_eq_top
rw [← upper_central_series_one]
exact upper_central_series_eq_top_iff_nilpotency_class_le.mpr h
rw [ih]
simp
rw [nilpotent_iff_lower_central_series]
refine' ⟨max (Group.nilpotencyClass G₁) (Group.nilpotencyClass G₂), _⟩
rw [lower_central_series_prod,
    lower_central_series_eq_bot_iff_nilpotency_class_le.mpr (le_max_left _ _),
    lower_central_series_eq_bot_iff_nilpotency_class_le.mpr (le_max_right _ _), bot_prod_bot]
refine' eq_of_forall_ge_iff fun k => _
simp only [max_le_iff, ← lower_central_series_eq_bot_iff_nilpotency_class_le,
    lower_central_series_prod, prod_eq_bot_iff]
simp [pi, pi_top]
rw [nilpotent_iff_lower_central_series]
refine' ⟨n, _⟩
rw [eq_bot_iff]
apply le_trans (lower_central_series_pi_le _)
rw [← eq_bot_iff, pi_eq_bot_iff]
intro i
apply lower_central_series_eq_bot_iff_nilpotency_class_le.mpr (h i)
rw [ih]
simp [pi, pi_top]
cases nonempty_fintype η
rw [nilpotent_iff_lower_central_series]
refine' ⟨finset.univ.sup fun i => Group.nilpotencyClass (Gs i), _⟩
rw [lower_central_series_pi_of_finite, pi_eq_bot_iff]
intro i
apply lower_central_series_eq_bot_iff_nilpotency_class_le.mpr
exact
    @Finset.le_sup _ _ _ _ Finset.univ (fun i => Group.nilpotencyClass (Gs i)) _ (Finset.mem_univ i)
apply eq_of_forall_ge_iff
intro k
simp only [Finset.sup_le_iff, ← lower_central_series_eq_bot_iff_nilpotency_class_le,
    lower_central_series_pi_of_finite, pi_eq_bot_iff, Finset.mem_univ, true_imp_iff]
apply comap_injective hsur
rw [comap_normalizer_eq_of_surjective _ hsur, comap_map_eq_self hkh]
exact hH
rw [card_eq_card_quotient_mul_card_subgroup (center G)]
apply lt_mul_of_one_lt_right
exact fintype.card_pos_iff.mpr One.nonempty
exact (Subgroup.one_lt_card_iff_ne_bot _).mpr (ne_of_gt h.bot_lt_center)
cases p
cases q
congr
rw [models_iff_not_satisfiable, ← compl_empty_iff, compl_set_of_mem, ← set_of_subset_eq_empty_iff]
simp
rw [← is_satisfiable_on_Theory_iff (Lhom_with_constants_injective L α)]
rw [nonempty_iff_univ_nonempty, nonempty_iff_ne_empty, Ne.def, not_iff_comm, ←
    union_empty ((L.Lhom_with_constants α).onTheory T), ← set_of_subset_eq_empty_iff]
simp
simp [Nat.leRecOn_trans ij jk]
simp only [of_apply, Quotient.eq]
refine' Setoid.symm ⟨j, hij, refl j, _⟩
simp only [DirectedSystem.map_self]
simp
change (lift L ι G f g Hg).toFun
simp
rw [F.comp_apply, F.comp_apply, of_f]
rw [lift_of] <;> rfl
rw [functions.apply₁, term.realize]
refine' congr rfl (funext fun i => _)
simp only [Matrix.cons_val_fin_one]
rw [functions.apply₂, term.realize]
refine' congr rfl (funext (Fin.cases _ _))
· simp only [Matrix.cons_val_zero]
· simp only [Matrix.cons_val_succ, Matrix.cons_val_fin_one, forall_const]
simp [Top.top]
simp [HasInf.inf, realize]
simp only [realize]
rw [relations.bounded_formula₁, realize_rel, iff_eq_eq]
refine' congr rfl (funext fun _ => _)
simp only [Matrix.cons_val_fin_one]
rw [relations.bounded_formula₂, realize_rel, iff_eq_eq]
refine' congr rfl (funext (Fin.cases _ _))
· simp only [Matrix.cons_val_zero]
· simp only [Matrix.cons_val_succ, Matrix.cons_val_fin_one, forall_const]
simp only [bounded_formula.iff, realize_inf, realize_imp, and_imp, ← iff_def]
subst h
simp only [cast_le_rfl, cast_refl, OrderIso.coe_refl, Function.comp.right_id]
rw [relabel, realize_map_term_rel_add_cast_le] <;> intros <;> simp
rw [add_assoc, add_comm 1 n', ← add_assoc]
rw [realize_lift_at_one (refl n), iff_eq_eq]
refine' congr rfl (congr rfl (funext fun i => _))
rw [if_pos i.is_lt]
simp
refine'
    bounded_formula.rec_on φ (fun _ _ => Iff.rfl) (fun _ _ _ _ => Iff.rfl)
      (fun _ _ _ _ _ => Iff.rfl) (fun _ f1 f2 h1 h2 _ => _) fun _ f h xs => _
· rw [to_prenex, realize_to_prenex_imp f1.to_prenex_is_prenex f2.to_prenex_is_prenex, realize_imp,
      realize_imp, h1, h2]
    infer_instance
· rw [realize_all, to_prenex, realize_all]
    exact forall_congr' fun a => h
simp
rw [relations.formula₁, realize_rel, iff_eq_eq]
refine' congr rfl (funext fun _ => _)
simp only [Matrix.cons_val_fin_one]
rw [relations.formula₂, realize_rel, iff_eq_eq]
refine' congr rfl (funext (Fin.cases _ _))
· simp only [Matrix.cons_val_zero]
· simp only [Matrix.cons_val_succ, Matrix.cons_val_fin_one, forall_const]
rw [realize, realize, relabel, bounded_formula.realize_relabel, iff_eq_eq, Fin.cast_add_zero]
exact congr rfl (funext finZeroElim)
rw [bounded_formula.realize_relabel, formula.realize, Sum.elim_comp_inr, Fin.cast_add_zero,
    cast_refl, OrderIso.coe_refl, Function.comp.right_id,
    Subsingleton.elim (x ∘ (nat_add n : Fin 0 → Fin n)) default]
simp [term.equal, realize]
simp only [formula.graph, term.realize, realize_equal, Fin.cons_zero, Fin.cons_succ]
rw [eq_comm]
simp only [equiv_sentence, Equiv.symm_symm, Equiv.coe_trans, realize,
    bounded_formula.realize_relabel_equiv]
refine' trans _ bounded_formula.realize_constants_vars_equiv
congr
rw [← realize_equiv_sentence_symm_con M (equiv_sentence φ), _root_.equiv.symm_apply_apply]
simp only [elementarily_equivalent, Set.ext_iff, complete_theory, Set.mem_setOf_eq]
simp [Theory.model_iff, Lhom.on_Theory]
simp only [model_iff, Set.mem_union] at *
exact fun φ hφ => hφ.elim (h _) (h' _)
simp
rw [formula.realize, formula.realize, ← g.realize_bounded_formula φ, iff_eq_eq,
    Unique.eq_default (g ∘ default)]
rw [sentence.realize, sentence.realize, ← g.realize_formula, Unique.eq_default (g ∘ default)]
simp [infinite_theory, infinite_iff, aleph_0_le]
simp only [nonempty_theory, Theory.model_iff, Set.mem_singleton_iff, forall_eq,
    sentence.realize_card_ge, Nat.cast_one, one_le_iff_ne_zero, mk_ne_zero_iff]
rw [Theory.model_iff_subset_complete_theory, Theory.model_iff_subset_complete_theory,
    h.complete_theory_eq]
rw [definable, Equiv.exists_congr_left (Lequiv.add_empty_constants L (∅ : Set M)).onFormula]
simp
rw [definable_iff_empty_definable_with_params] at *
exact hAs.map_expansion (L.Lhom_with_constants_map (Set.inclusion hAB))
rw [← Finset.inf_set_eq_bInter]
exact definable_finset_inf hf s
rw [← Finset.sup_set_eq_bUnion]
exact definable_finset_sup hf s
refine' fun a => ⟨(var a).equal (var (range_splitting f (range_factorization f a))), ext _⟩
simp
refine' ((Lhom.on_Theory_model _ _).2 inferInstance).union _
rw [model_distinct_constants_theory]
refine' fun a as b bs ab => _
rw [← Subtype.coe_mk a as, ← Subtype.coe_mk b bs, ← Subtype.ext_iff]
exact
      h.some.injective
        ((subtype.coe_injective.extend_apply h.some default ⟨a, as⟩).symm.trans
          (ab.trans (subtype.coe_injective.extend_apply h.some default ⟨b, bs⟩)))
simp
rw [← lift_inj.{_, w + 1}, lift_lift, lift_lift] at hS
exact small_iff_lift_mk_lt_univ.2 (lt_of_eq_of_lt hS κ.lift_lt_univ')
simp only [Set.union_singleton, model_iff, Set.mem_insert_iff, forall_eq_or_imp,
      sentence.realize_not]
rw [← model_iff]
exact ⟨h, inferInstance⟩
refine' (h.mem_or_not_mem φ).resolve_right fun con => _
rw [models_iff_not_satisfiable, Set.union_singleton, Set.insert_eq_of_mem con] at hφ
exact hφ h.1
rw [bounded_formula.realize_iff]
rw [bounded_formula.realize_iff, Iff.comm, ← bounded_formula.realize_iff]
exact h M v xs
have h1' := h1 M v xs
have h2' := h2 M v xs
rw [bounded_formula.realize_iff] at *
exact ⟨h2'.1 ∘ h1'.1, h1'.2 ∘ h2'.2⟩
simp
simp [imp_iff_not_or]
simp [imp_iff_not_or]
simp [and_iff_not_or_not]
simp
simp
skip
rw [realize_iff, realize_all_lift_at_one_self]
rw [realize_iff, realize_to_prenex]
rw [empty.nonempty_equiv_iff, hM, hN]
simp
rw [Finset.coe_empty, closure_empty]
rw [hs.coe_to_finset]
rw [closure_union, ht₁.2, ht₂.2]
rw [closure_image, ht.2]
rw [closure_union, ht₁.2, ht₂.2]
rw [closure_image, ht.2]
rw [fg_def, substructure.fg_def]
rw [hom.range_eq_map]
exact (fg_def.1 h).map f
rw [← hom.range_eq_top] at hs
rw [fg_def, ← hs]
exact h.range f
rw [cg_def, substructure.cg_def]
rw [hom.range_eq_map]
exact (cg_def.1 h).map f
rw [← hom.range_eq_top] at hs
rw [cg_def, ← hs]
exact h.range f
rw [cg_def, cg_iff_countable, top_equiv.to_equiv.countable_iff]
rw [Structure.fg_def]
refine' ⟨fun h => fg.of_map_embedding S.subtype _, fun h => _⟩
· rw [← hom.range_eq_map, range_subtype]
    exact h
· have h := h.map S.subtype.to_hom
    rw [← hom.range_eq_map, range_subtype] at h
    exact h
rw [Structure.cg_def]
refine' ⟨fun h => cg.of_map_embedding S.subtype _, fun h => _⟩
· rw [← hom.range_eq_map, range_subtype]
    exact h
· have h := h.map S.subtype.to_hom
    rw [← hom.range_eq_map, range_subtype] at h
    exact h
apply (Lhom.sum_inl.substructure_reduct S).is_elementary_of_exists
intro n φ x a h
let φ' : (L.sum L.skolem₁).Functions n := Lhom.sum_inr.on_function φ
exact
    ⟨⟨fun_map φ' (coe ∘ x), S.fun_mem (Lhom.sum_inr.on_function φ) (coe ∘ x) fun i => (x i).2⟩,
      Classical.epsilon_spec ⟨a, h⟩⟩
rw [coe_sort_elementary_skolem₁_reduct]
infer_instance
rw [sum_nat_eq_add_sum_succ, sum_nat_eq_add_sum_succ, sum_nat_eq_add_sum_succ]
simp [add_assoc]
simp [card, symbols]
simp [card_eq_card_functions_add_card_relations]
simp only [language.symbols, isEmpty_sum, isEmpty_sigma]
exact ⟨fun _ => inferInstance, fun _ => inferInstance⟩
simp [language.sum]
simp [language.sum]
simp [card_eq_card_functions_add_card_relations, add_assoc]
cases f
cases g
cases h
rfl
simp [h]
simp only [Equiv.to_fun_as_coe]
rw [Equiv.symm_apply_eq]
refine' Eq.trans _ (f.map_fun' f' (f.to_equiv.symm ∘ x)).symm
rw [← Function.comp.assoc, Equiv.to_fun_as_coe, Equiv.self_comp_symm, Function.comp.left_id]
simp only [Equiv.to_fun_as_coe]
refine' (f.map_rel' r (f.to_equiv.symm ∘ x)).symm.trans _
rw [← Function.comp.assoc, Equiv.to_fun_as_coe, Equiv.self_comp_symm, Function.comp.left_id]
simp [← Function.comp.assoc e.symm e x]
simp [← Function.comp.assoc e.symm e x]
cases p <;> cases q <;> congr
simp only [infi, mem_Inf, Set.forall_range_iff]
simp only [infi, coe_Inf, Set.bInter_range]
rw [← SetLike.coe_sort_coe, substructure.coe_closure_eq_range_term_realize]
exact small_range _
rw [← SetLike.mem_coe, coe_closure_eq_range_term_realize, mem_range]
rw [← lift_umax]
refine' lift_card_closure_le_card_term.trans (term.card_le.trans _)
rw [mk_sum, lift_umax]
rw [← closure_empty]
exact substructure.small_closure
rw [mem_preimage, φ.map_fun]
exact S.fun_mem f (φ ∘ x) hx
simp
simp only [hom.map_fun, SetLike.mem_coe]
exact congr rfl (funext fun i => (Classical.choose_spec (hx i)).2)
simp [mem_comap, mem_map, hf.eq_iff]
simp [hy, h]
simp
refine' Exists.elim _ fun (hx : x ∈ closure L s) (hc : p x hx) => hc
exact closure_induction hx (fun x hx => ⟨subset_closure hx, Hs x hx⟩) @Hfun
have h := S.fun_mem (φ.on_function f) x hx
simp only [Lhom.map_on_function, substructure.mem_carrier] at h
exact h
simp only [SetLike.coe_set_eq] at h
exact h
cases f
· exact S.fun_mem f
· cases n
      · exact fun _ _ => h f.2
      · exact isEmptyElim f
intro a ha
simp only [SetLike.mem_coe]
let a' : L[[A]].Constants := Sum.inr ⟨a, ha⟩
exact constants_mem a'
refine' closure_eq_of_le ((A.subset_union_right s).trans subset_closure) _
rw [← (L.Lhom_with_constants A).substructureReduct.le_iff_le]
simp only [subset_closure, reduct_with_constants, closure_le, Lhom.coe_substructure_reduct,
    Set.union_subset_iff, and_true_iff]
· exact subset_closure_with_constants
· infer_instance
· infer_instance
rw [SetLike.ext'_iff, range_coe, coe_top, Set.range_iff_surjective]
rw [range_eq_map, map_le_iff_le_comap, eq_top_iff]
simp only
rw [← p.subtype.map_rel, Function.comp.assoc]
change rel_map r (hom.comp p.subtype.to_hom (f.to_hom.cod_restrict p h) ∘ x) ↔ _
rw [hom.subtype_comp_cod_restrict, ← f.map_rel]
rfl
simp
simp
rw [Function.leftInverse_iff_comp, ← Lhom.comp_on_term, φ.left_inv, Lhom.id_on_term]
rw [Function.rightInverse_iff_comp, ← Lhom.comp_on_term, φ.right_inv, Lhom.id_on_term]
rw [add_assoc, add_comm 1, add_assoc]
simp
simp
simp [bounded_formula.not]
rw [relabel, map_term_rel, relabel]
simp
simp [bounded_formula.ex]
cases con
cases con
simp [h.all]
simp [h.ex]
rw [Function.leftInverse_iff_comp, ← Lhom.comp_on_bounded_formula, φ.left_inv,
      Lhom.id_on_bounded_formula]
rw [Function.rightInverse_iff_comp, ← Lhom.comp_on_bounded_formula, φ.right_inv,
      Lhom.id_on_bounded_formula]
cases F
rfl
cases F
rfl
simp
simp
simp
simp
simp
simp
simp
simp
rw [Lhom.comp_assoc, ← Lhom.comp_assoc e'.inv_Lhom, e'.left_inv, Lhom.id_comp, e.left_inv]
rw [Lhom.comp_assoc, ← Lhom.comp_assoc e.to_Lhom, e.right_inv, Lhom.id_comp, e'.right_inv]
simp
rw [with_constants, card_sum, card_constants_on]
rw [Lhom_with_constants, Lhom.sum_elim_comp_inl]
simp only [Lhom.comp_sum_elim, Lhom_with_constants, Lhom.comp_id]
exact trans (congr rfl (Subsingleton.elim _ _)) Lhom.sum_elim_inl_inr
rw [formula.realize, formula.realize, ← f.map_bounded_formula, Unique.eq_default (f ∘ default)]
rw [sentence.realize, sentence.realize, ← f.map_formula, Unique.eq_default (f ∘ default)]
simp only [Theory.model_iff, f.map_sentence]
intro x y
have h :=
    φ.map_formula ((var 0).equal (var 1) : L.formula (Fin 2)) fun i => if i = 0 then x else y
rw [formula.realize_equal, formula.realize_equal] at h
simp only [Nat.one_ne_zero, term.realize, Fin.one_eq_zero_iff, if_true, eq_self_iff_true,
    Function.comp_apply, if_false] at h
exact h.1
have h := φ.map_formula (formula.graph f) (Fin.cons (fun_map f x) x)
rw [formula.realize_graph, Fin.comp_cons, formula.realize_graph] at h
rw [eq_comm, h]
rw [← substructure.top_equiv.realize_bounded_formula φ]
simp
rw [← substructure.top_equiv.realize_formula φ]
simp
congr
exact h
simp only [Theory.model_iff, realize_sentence]
simp [Theory.simple_graph]
simp only [Theory.simple_graph_model_iff, rel_map_apply₂]
exact ⟨G.loopless, G.symm⟩
refine' mem_of_superset (Inter_mem.2 xy) fun a ha => _
simp only [Set.mem_Inter, Set.mem_setOf_eq] at ha
simp only [Set.mem_setOf_eq, ha]
apply fun_map_quotient_mk
refine' fun m a => funext (Fin.reverseInduction _ fun i hi => _)
· simp only [Fin.snoc_last]
· simp only [Fin.snoc_cast_succ]
intro i
rw [h, nth_append, nth_map]
· simp only [Option.map_eq_some', Function.comp_apply, nth_eq_some]
          refine' ⟨i, ⟨lt_of_lt_of_le i.2 (ge_of_eq (length_fin_range _)), _⟩, rfl⟩
          rw [nth_le_fin_range, Fin.eta]
· refine' lt_of_lt_of_le i.2 _
          simp
have h := list_decode_encode_list [t]
rw [bind_singleton] at h
simp only [h, Option.join, head', List.map, Option.some_bind, id.def]
rw [← bind_singleton list_encode, list_decode_encode_list]
simp only [Option.join, head', List.map, Option.some_bind, id.def]
refine' mk_le_aleph_0_iff.1 (card_le.trans (max_le_iff.2 _))
simp only [le_refl, mk_sum, add_le_aleph_0, lift_le_aleph_0, true_and_iff]
exact ⟨Cardinal.mk_le_aleph_0, Cardinal.mk_le_aleph_0⟩
rw [h]
rw [h]
simp only [List.sizeof, ← add_assoc]
exact le_max_of_le_right le_add_self
rw [h' i]
decide
intro i
simp only [Option.join, map_append, map_map, Option.bind_eq_some, id.def, exists_eq_right,
            nth_eq_some, length_append, length_map, length_fin_range]
refine' ⟨lt_of_lt_of_le i.2 le_self_add, _⟩
rw [nth_le_append, nth_le_map]
·
            simp only [Sum.getLeft, nth_le_fin_range, Fin.eta, Function.comp_apply,
              eq_self_iff_true, heq_iff_eq, and_self_iff]
· exact lt_of_lt_of_le i.is_lt (ge_of_eq (length_fin_range _))
· rw [length_map, length_fin_range]
            exact i.2
have h := list_decode_encode_list [φ]
rw [bind_singleton] at h
rw [h]
rfl
refine' lift_le.1 (bounded_formula.encoding.card_le_card_list.trans _)
rw [encoding_Γ, mk_list_eq_max_mk_aleph_0, lift_max, lift_aleph_0, lift_max, lift_aleph_0,
    max_le_iff]
refine' ⟨_, le_max_left _ _⟩
rw [mk_sum, term.card_sigma, mk_sum, ← add_eq_max le_rfl, mk_sum, mk_nat]
simp only [lift_add, lift_lift, lift_aleph_0]
rw [← add_assoc, add_comm, ← add_assoc, ← add_assoc, aleph_0_add_aleph_0, add_assoc,
    add_eq_max le_rfl, add_assoc, card, symbols, mk_sum, lift_add, lift_lift, lift_lift]
change
    Quotient.map (@fun_map L M ps.to_structure n f) prestructure.fun_equiv (Quotient.finChoice _) =
      _
rw [Quotient.fin_choice_eq, Quotient.map_mk]
change
    Quotient.lift (@rel_map L M ps.to_structure n r) prestructure.rel_equiv (Quotient.finChoice _) ↔
      _
rw [Quotient.fin_choice_eq, Quotient.lift_mk]
rw [is_ordered_structure_iff, order_Lhom_order]
exact Lhom.id_is_expansion_on M
simp only [Theory.preorder, Theory.model_iff, Set.mem_insert_iff, Set.mem_singleton_iff,
    forall_eq_or_imp, relations.realize_reflexive, rel_map_apply₂, forall_eq,
    relations.realize_transitive]
exact ⟨le_refl, fun _ _ _ => le_trans⟩
simp only [Theory.partial_order, Theory.model_iff, Set.mem_insert_iff, Set.mem_singleton_iff,
    forall_eq_or_imp, relations.realize_reflexive, rel_map_apply₂, relations.realize_antisymmetric,
    forall_eq, relations.realize_transitive]
exact ⟨le_refl, fun _ _ => le_antisymm, fun _ _ _ => le_trans⟩
simp only [Theory.linear_order, Theory.model_iff, Set.mem_insert_iff, Set.mem_singleton_iff,
    forall_eq_or_imp, relations.realize_reflexive, rel_map_apply₂, relations.realize_antisymmetric,
    relations.realize_transitive, forall_eq, relations.realize_total]
exact ⟨le_refl, fun _ _ => le_antisymm, fun _ _ _ => le_trans, le_total⟩
rw [← order_Lhom_le_symb, Lhom.map_on_relation]
rfl
simp [term.le]
simp [term.lt, lt_iff_le_not_le]
simp only [sentence.no_top_order, sentence.realize, formula.realize, bounded_formula.realize_all,
    bounded_formula.realize_ex, bounded_formula.realize_not, realize, term.realize_le, Sum.elim_inr]
refine' ⟨fun h => ⟨fun a => h a⟩, _⟩
intro h a
exact exists_not_le a
simp only [sentence.no_bot_order, sentence.realize, formula.realize, bounded_formula.realize_all,
    bounded_formula.realize_ex, bounded_formula.realize_not, realize, term.realize_le, Sum.elim_inr]
refine' ⟨fun h => ⟨fun a => h a⟩, _⟩
intro h a
exact exists_not_ge a
simp only [sentence.densely_ordered, sentence.realize, formula.realize,
    bounded_formula.realize_imp, bounded_formula.realize_all, realize, term.realize_lt,
    Sum.elim_inr, bounded_formula.realize_ex, bounded_formula.realize_inf]
refine' ⟨fun h => ⟨fun a b ab => h a b ab⟩, _⟩
intro h a b ab
exact exists_between ab
simp only [Theory.DLO, Set.union_insert, Set.union_singleton, Theory.model_iff,
    Set.mem_insert_iff, forall_eq_or_imp, realize_no_top_order, realize_no_bot_order,
    realize_densely_ordered, true_and_iff]
rw [← Theory.model_iff]
infer_instance
simp [smul]
simp [smul]
simp only [← f.map_zero, ← smul, smul_zero]
simp
simp
simp [mul_smul]
simp
have : 0 < nB :=
        haveI
rw [Int.fract_add_floor]
simp [fract_eq_zero]
        
    -- int.fract v ≠ 0; the claim then easily follows
injection Eq.trans nth_stream_eq'.symm nth_stream_eq
      cases this
injection Eq.trans nth_stream_eq'.symm nth_stream_eq
      cases this
      -- get the correspondence between ifp_n and g.s.nth n
rw [nth_cont_eq_succ_nth_cont_aux]
exact exists_gcf_pair_rat_eq_of_nth_conts_aux v <| n + 1
simp [int_fract_pair.of, v_eq_q]
funext n
exact int_fract_pair.coe_stream_nth_rat_eq v_eq_q n
unfold of int_fract_pair.seq1
rw [← int_fract_pair.coe_of_rat_eq v_eq_q]
simp
injection gcf_v_eq
  simp [coe_of_h_rat_eq rfl, coe_of_s_rat_eq rfl, gcf_v_eq]
injection Eq.trans stream_nth_eq.symm stream_nth_eq'
  cases this
  rw [← int_fract_pair.of_eq_ifp_succ_n]
  cases' nth_stream_fr_nonneg_lt_one stream_nth_eq with zero_le_ifp_n_fract ifp_n_fract_lt_one
injection stream_zero_eq
    simp [le_refl, this.symm]
  case succ
have : 0 ≤ fract_q_num := rat.num_nonneg_iff_zero_le.elim_right (Int.fract_nonneg q)
simp [Int.natAbs_of_nonneg this, sub_add_eq_sub_sub_swap, sub_right_comm]
intro _ hyp
simp [int_fract_pair.stream, hyp]
injection nth_stream_eq
    rw [← this, int_fract_pair.of]
    exact ⟨fract_nonneg _, fract_lt_one _⟩
  case succ
have h : 0 < ifp_n.fr :=
      lt_of_le_of_ne (nth_stream_fr_nonneg nth_stream_eq) stream_nth_fr_ne_zero.symm
apply one_le_inv h this
cases n
case zero => exact Or.inl <| le_refl 1
case succ => exact Or.inr (Or.resolve_left hyp n.succ_ne_zero)
rw [denom_eq_conts_b, nth_cont_eq_succ_nth_cont_aux]
exact zero_le_of_continuants_aux_b
rw [denom_eq_conts_b, nth_cont_eq_succ_nth_cont_aux]
exact le_of_succ_succ_nth_continuants_aux_b nth_part_denom_eq
assumption
simp [stream_nth_eq]
rw [div_sub_div _ _ this.symm zero_ne_B.symm]
rw [determinant_eq]
ac_rfl
simp [nextConts, continuants_aux_recurrence s_nth_eq pred_conts_eq conts_eq, gp_a_eq_one,
      pred_conts_eq.symm, conts_eq.symm, add_comm]
rw [nextConts_b_eq]
congr 1
have : 0 ≤ pred_conts.b :=
          haveI
let g := of v
let B := g.denominators n
let nB := g.denominators (n + 1)
have not_terminated_at_n : ¬g.terminated_at n :=
    haveI
simp [nth_part_denom_eq]
simp [int_fract_pair.stream, h, stream_nth_eq, this]
simp [stream_succ_nth_eq]
injection this
cases aux_seq_eq : int_fract_pair.seq1 v
simp [of, aux_seq_eq]
simp [of_h_eq_int_fract_pair_seq1_fst_b, int_fract_pair.of]
rw [of_terminated_at_iff_int_fract_pair_seq1_terminated_at, Seq.TerminatedAt,
    int_fract_pair.nth_seq1_eq_succ_nth_stream]
unfold of int_fract_pair.seq1 at s_nth_eq
unfold of int_fract_pair.seq1
rw [Seq.map_tail, Seq.nth_tail, Seq.map_nth]
simp [Seq.nth, stream_succ_nth_eq]
cases ifp_n
simp [int_fract_pair.stream, stream_nth_eq, nth_fr_ne_zero]
rfl
induction. The case `n = 0
induction. To make the induction work, we need
change s.nth (n + 1) = none at terminated_at_succ_n
cases s_nth_eq : s.nth n <;> simp only [*, squash_seq]
simp [*, squash_seq, Seq.zip_with_nth_some (Seq.nats_nth n) s_nth_eq _]
cases `m = n
cases n
case zero => 
    change g.s.nth 0 = none at terminated_at_n
    simp only [convergents', squash_gcf, convergents'_aux, terminated_at_n]
case succ => cases g; simp [squash_seq_eq_self_of_terminated terminated_at_n, squash_gcf]
simp only [squash_gcf, squash_seq_nth_of_lt m_lt_n]
cases n
case zero =>
    cases g_s_head_eq : g.s.nth 0 <;>
      simp [g_s_head_eq, squash_gcf, convergents', convergents'_aux, Seq.head]
case succ =>
    simp only [succ_succ_nth_convergent'_aux_eq_succ_nth_convergent'_aux_squash_seq, convergents',
      squash_gcf]
rw [mul_div_cancel_left _ b_ne_zero]
have : g'.s.nth n' = some ⟨pa, pb + a / b⟩ :=
          squash_seq_nth_of_not_terminated s_n'th_eq s_nth_eq
rw [convergent_eq_conts_a_div_conts_b,
          continuants_recurrence_aux this n'th_conts_aux_eq'.symm succ_n'th_conts_aux_eq'.symm]
have : g.continuants_aux (n' + 2) = ⟨pb * pA + pa * ppA, pb * pB + pa * ppB⟩ :=
          continuants_aux_recurrence s_n'th_eq n'th_conts_aux_eq.symm succ_n'th_conts_aux_eq.symm
        -- and a second time
rw [convergent_eq_conts_a_div_conts_b,
          continuants_recurrence_aux s_nth_eq succ_n'th_conts_aux_eq.symm this]
simp [*, (continuants_aux_eq_continuants_aux_squash_gcf_of_le <| le_refl <| n' + 1).symm,
            (continuants_aux_eq_continuants_aux_squash_gcf_of_le n'.le_succ).symm]
rw [terminated_at_iff_s_none] at terminated_at_n
simp only [terminated_at_n, continuants_aux]
simp only [Seq.TerminatedAt, s.nth_tail, terminated_at_n]
simp only [nth_cont_eq_succ_nth_cont_aux,
    continuants_aux_stable_of_terminated (nat.pred_le_iff.elim_left n_le_m) terminated_at_n]
simp only [num_eq_conts_a, continuants_stable_of_terminated n_le_m terminated_at_n]
simp only [denom_eq_conts_b, continuants_stable_of_terminated n_le_m terminated_at_n]
simp only [convergents, denominators_stable_of_terminated n_le_m terminated_at_n,
    numerators_stable_of_terminated n_le_m terminated_at_n]
simp only [convergents', convergents'_aux_stable_of_terminated n_le_m terminated_at_n]
unfold terminated_at
infer_instance
cases h
unfold SimpleContinuedFraction
infer_instance
cases h
unfold ContinuedFraction
infer_instance
cases g
cases g'
simp
rfl
rfl
cases s_nth_eq : g.s.nth n <;> simp [partial_numerators, s_nth_eq]
rw [terminated_at_iff_s_none, part_num_none_iff_s_none]
cases s_nth_eq : g.s.nth n <;> simp [partial_denominators, s_nth_eq]
rw [terminated_at_iff_s_none, part_denom_none_iff_s_none]
simp [partial_numerators, s_nth_eq]
simp [partial_denominators, s_nth_eq]
simp [convergent_eq_num_div_denom, num_eq_conts_a, denom_eq_conts_b, div_one]
simp [zeroth_s_eq, continuants_aux, next_continuants, next_denominator, next_numerator]
simp [nth_cont_eq_succ_nth_cont_aux, second_continuant_aux_eq zeroth_s_eq]
simp [num_eq_conts_a, first_continuant_eq zeroth_s_eq]
simp [denom_eq_conts_b, first_continuant_eq zeroth_s_eq]
simp [convergents']
simp [*, continuants_aux, next_continuants, next_denominator, next_numerator]
simp [nth_cont_eq_succ_nth_cont_aux,
    continuants_aux_recurrence nth_s_eq nth_conts_aux_eq succ_nth_conts_aux_eq]
rw [nth_cont_eq_succ_nth_cont_aux] at nth_conts_eq succ_nth_conts_eq
exact continuants_recurrence_aux succ_nth_s_eq nth_conts_eq succ_nth_conts_eq
intros
simp only [map_mul, *]
rw [mul_bind, mul_bind, mul_bind, ih1, ih2]
rw [map_mul', ih1, ih2]
rw [traverse_mul, ih1, ih2, mul_map_seq]
skip <;> simp only [traverse_pure, traverse_pure', functor_norm]
skip <;> rw [traverse_mul, ih1, ih2, traverse_mul] <;>
          simp only [traverse_mul', functor_norm]
simp only [traverse_pure, functor_norm]
simp only [traverse_mul, functor_norm] <;> rw [ih1, ih2]
rw [traverse_mul, ih1, ih2, map_mul', mul_map_seq] <;> rfl
simp [length, ← add_assoc, add_right_comm]
simp only [map_mul, *]
simp only [head_mul, tail_mul, ← List.foldl_map f, List.foldl_append, List.foldl_cons,
          List.foldl_assoc]
rw [map_mul, lift_of]
simp only [map_mul, length_mul, *]
rw [mul_bind, mul_bind, mul_bind, ih1, ih2]
rw [map_mul', ih1, ih2]
rw [ih] <;> simp only [(· ∘ ·), (mul_assoc _ _ _).symm, functor_norm]
rw [traverse_mul, ih1, ih2, mul_map_seq]
skip <;> simp only [traverse_pure, traverse_pure', functor_norm]
skip <;> rw [traverse_mul, ih1, ih2, traverse_mul] <;>
          simp only [traverse_mul', functor_norm]
simp only [traverse_pure, functor_norm]
skip <;> simp only [traverse_mul, functor_norm] <;> rw [ih1, ih2]
rw [traverse_mul, ih1, ih2, map_mul', mul_map_seq] <;> rfl
rw [map_mul, FreeSemigroup.length_mul, length, hx, hy]
rw [← Nat.cast_two, CharP.cast_eq_zero]
rw [← two_smul R x, two_eq_zero, zero_smul]
simp
simp
rw [neg_eq_iff_add_eq_zero, ← two_smul R x, two_eq_zero, zero_smul]
rw [sub_eq_add_neg, neg_eq]
rw [← pow_two, ← pow_two, ← pow_two, add_sq]
refine' ⟨fun h => _, fun h => @CharTwo.neg_eq _ (ringChar.of_eq h) 1⟩
rw [eq_comm, ← sub_eq_zero, sub_neg_eq_add, ← Nat.cast_one, ← Nat.cast_add] at h
exact ((Nat.dvd_prime Nat.prime_two).mp (ringChar.dvd h)).resolve_left CharP.ring_char_ne_one
rw [Nat.mul_div_cancel' (Nat.ord_proj_dvd q r)]
rw [Nat.cast_pow, ← @mul_one R _ (r ^ n), mul_comm, ←
        Classical.choose_spec a_unit.exists_left_inv, mul_assoc, ← Nat.cast_pow, ← Nat.cast_mul, ←
        q_eq_a_mul_rn, CharP.cast_eq_zero R q]
simp
rw [map_nat_cast, h]
rw [h, RingHom.map_zero]
rw [← CharP.cast_eq_zero_iff R p x]
change algebraMap ℕ A x = 0 ↔ algebraMap ℕ R x = 0
rw [IsScalarTower.algebra_map_apply ℕ R A x]
refine' Iff.trans _ h.eq_iff
rw [RingHom.map_zero]
change algebraMap ℕ A x = algebraMap ℕ A y at hxy
rw [IsScalarTower.algebra_map_apply ℕ R A x] at hxy
rw [IsScalarTower.algebra_map_apply ℕ R A y] at hxy
exact CharZero.cast_injective (h hxy)
rw [ringChar.eq_iff, Algebra.char_p_iff K L]
apply ringChar.char_p
rw [map_nat_cast, h]
rw [h, RingHom.map_zero]
rw [map_nat_cast, h]
rw [h, RingHom.map_zero]
rw [← nsmul_one, card_nsmul_eq_zero]
rw [← Nat.smul_one_eq_coe, add_order_of_dvd_iff_nsmul_eq_zero]
rw [eq_comm, ← sub_eq_zero, ← Int.cast_sub, CharP.int_cast_eq_zero_iff R p, Int.modeq_iff_dvd]
rw [zero_dvd_iff, ← Nat.cast_zero, Nat.cast_inj]
rw [← Nat.mul_div_cancel' H1, Nat.cast_mul,
            of_not_not (not_not_of_not_imp <| Nat.find_spec (not_forall.1 H)), zero_mul]
rw [ringChar.spec]
rw [this]
simp
induction n
· simp
rw [pow_succ', pow_mul, pow_mul, pow_mul, n_ih]
apply add_pow_char_of_commute
apply Commute.pow_pow h
induction n
· simp
rw [pow_succ', pow_mul, pow_mul, pow_mul, n_ih]
apply sub_pow_char_of_commute
apply Commute.pow_pow h
rw [eq_comm, ← sub_eq_zero, ← Int.cast_sub, CharP.int_cast_eq_zero_iff R p, Int.modeq_iff_dvd]
decide
simp only [char_p_iff, ← f.injective.eq_iff, map_nat_cast f, f.map_zero]
induction n
· simp
rw [Function.iterate_succ', pow_succ', pow_mul, Function.comp_apply, frobenius_def, n_ih]
rw [← sub_eq_zero] at H⊢
rw [← frobenius_sub] at H
exact IsReduced.eq_zero _ ⟨_, H⟩
cases nonempty_fintype R
exact
    Exists.imp (fun b h => pow_two b ▸ Eq.symm h)
      (((Fintype.bijective_iff_injective_and_card _).mpr ⟨frobenius_inj R 2, rfl⟩).Surjective a)
rw [Nat.mod_add_div]
simp [cast_eq_zero]
rw [‹e = p›] at hmul <;> rw [one_mul] <;> exact Eq.symm hmul
rw [this a, this b]
rw [one_mul]
rw [Nat.cast_one]
rw [CharP.cast_eq_zero]
rw [zero_mul]
rw [← hn, CharP.cast_card_eq_zero]
rw [← CharP.cast_eq_zero_iff R c, ← hn, CharP.cast_card_eq_zero]
apply hR i hi
rw [← Nat.cast_pow, ← hc, CharP.cast_eq_zero]
simp [Prod.ext_iff, CharP.cast_eq_zero_iff R p, CharP.cast_eq_zero_iff S q, Nat.lcm_dvd_iff]
intro a ha b hb h
apply eq_of_sub_eq_zero
rw [← ringChar.spec, ← Ne.def]
exact nonzero_of_invertible (t : K)
decide
decide
rw [← cast_eq_zero_iff R p x, ← map_nat_cast (Ideal.Quotient.mk I)]
refine' ideal.quotient.eq.trans (_ : ↑x - 0 ∈ I ↔ _)
rw [sub_zero]
exact ⟨h x, fun h' => h'.symm ▸ I.zero_mem⟩
rw [← Ideal.span_singleton_eq_top]
  -- So
apply Units.ext
rw [Units.val_one]
change ((EqualCharZero.pnat_coe_is_unit R 1).Unit : R) = 1
rw [IsUnit.unit_spec (EqualCharZero.pnat_coe_is_unit R 1)]
rw [coe_coe, PNat.one_coe, Nat.cast_one]
change ((EqualCharZero.pnat_coe_is_unit R n).Unit : R) = ↑n
simp only [IsUnit.unit_spec]
simp [divp]
simp [EqualCharZero.pnat_coe_units_eq_one]
intro p p_pos
refine' split_
refine' split_
cases hq
· exact CharP.eq R hp inferInstance
· exact False.elim (CharP.char_ne_one R 1 rfl)
cases hq
· assumption
· exact False.elim (CharP.char_ne_one R 1 rfl)
rw [← cast_zero, cast_inj]
rw [← cast_one, cast_inj]
rw [← cast_pow, cast_eq_one]
exact pow_eq_one_iff hn
decide
simp only [(two_mul a).symm, mul_eq_zero, two_ne_zero, false_or_iff]
rw [eq_comm]
exact bit0_eq_zero
simp only [bit1, add_left_inj] at h
exact bit0_injective h
simp
rw [eq_comm]
exact bit1_eq_one
rw [← mul_two, mul_div_cancel a two_ne_zero]
rw [← add_div, half_add_self]
rw [sub_eq_iff_eq_add, add_halves']
rw [← neg_sub, sub_half]
rw [← map_nat_cast ϕ, ← map_nat_cast ϕ, h]
unfold HasStar.star
simp only [Function.comp_apply]
refine' FreeAlgebra.induction R X _ _ _ _ x
· intros
      simp only [AlgHom.commutes, MulOpposite.algebra_map_apply, MulOpposite.unop_op]
· intros
      simp only [lift_ι_apply, MulOpposite.unop_op]
· intros
      simp only [*, map_mul, MulOpposite.unop_mul]
· intros
      simp only [*, map_add, MulOpposite.unop_add]
simp only [Function.comp_apply, map_mul, MulOpposite.unop_mul]
simp only [Function.comp_apply, map_add, MulOpposite.unop_add]
simp [star, HasStar.star]
simp [star, HasStar.star]
simp [star_algebra_map]
simp only [selfAdjoint.mem_iff, star_smul, add_comm, StarAddMonoid.star_add, star_inv',
        star_bit0, star_one, star_star, star_inv_of (2 : R), star_trivial]
simp only [skewAdjoint.mem_iff, star_smul, star_sub, star_star, star_trivial, ← smul_neg,
        neg_sub]
simp only [smul_sub, self_adjoint_part_apply_coe, smul_add, skew_adjoint_part_apply_coe,
    add_add_sub_cancel, inv_of_two_smul_add_inv_of_two_smul]
simp only [Algebra.algebra_map_eq_smul_one, star_smul, star_one]
simp [Algebra.smul_def]
dsimp [P]
simp only [star_add, star_sub, star_mul, star_bit0, star_one, T.A₀_sa, T.A₁_sa, T.B₀_sa,
        T.B₁_sa, mul_comm B₀, mul_comm B₁]
rw [zsmul_eq_smul_cast ℝ, ← mul_smul]
dsimp [P]
simp only [star_smul, star_add, star_sub, star_id_of_comm, T.A₀_sa, T.A₁_sa, T.B₀_sa, T.B₁_sa]
dsimp [Q]
simp only [star_smul, star_add, star_sub, star_id_of_comm, T.A₀_sa, T.A₁_sa, T.B₀_sa, T.B₁_sa]
simp only [IsSelfAdjoint, star_mul, star_star]
simp only [is_self_adjoint_iff, star_add, hx.star_eq, hy.star_eq]
simp only [is_self_adjoint_iff, star_neg, hx.star_eq]
simp only [is_self_adjoint_iff, star_sub, hx.star_eq, hy.star_eq]
simp only [is_self_adjoint_iff, star_bit0, hx.star_eq]
simp only [is_self_adjoint_iff, star_mul, star_star, mul_assoc, hx.star_eq]
simp only [is_self_adjoint_iff, star_mul, star_star, mul_assoc, hx.star_eq]
simp only [hx.star_eq]
simp only [is_self_adjoint_iff, star_bit1, hx.star_eq]
simp only [is_self_adjoint_iff, star_pow, hx.star_eq]
simp only [is_self_adjoint_iff, star_mul', hx.star_eq, hy.star_eq]
simp only [is_self_adjoint_iff, star_inv', hx.star_eq]
simp only [is_self_adjoint_iff, star_div', hx.star_eq, hy.star_eq]
simp only [is_self_adjoint_iff, star_zpow₀, hx.star_eq]
simp only [is_self_adjoint_iff, star_smul, star_trivial, hx.star_eq]
simp only [star_zero, neg_zero]
rw [star_add x y, hx, hy, neg_add]
simp only [hx, star_neg]
rw [← AddSubgroup.mem_carrier]
exact Iff.rfl
simp [zero_mem]
cases n <;> simp [show ↑n ∈ selfAdjoint R from (n : selfAdjoint R).2]
refine' add_mem (is_self_adjoint_one R).neg (n : selfAdjoint R).2.neg
rw [IsSelfAdjoint, Rat.cast_mk', star_mul', star_inv', star_nat_cast, star_int_cast]
rw [Rat.smul_def] <;> exact (rat_cast_mem a).mul x.prop
rw [← AddSubgroup.mem_carrier]
exact Iff.rfl
rw [mem_iff, star_bit0, mem_iff.mp hx, bit0, bit0, neg_add]
simp only [mem_iff, star_mul, star_star, mem_iff.mp hx, neg_mul, mul_neg, mul_assoc]
simp only [mem_iff, star_mul, star_star, mem_iff.mp hx, neg_mul, mul_neg, mul_assoc]
simp only [mem_iff] at hx
simp only [hx, Commute.neg_left]
rw [mem_iff, star_smul, star_trivial, mem_iff.mp h, smul_neg r]
simp only [star_comm_self, star_zero]
simp only [star_comm_self, star_one]
rw [star_star, star_comm_self']
rw [star_trivial]
simp only [map_star, NonUnitalAlgHom.to_fun_eq_coe, eq_self_iff_true,
        NonUnitalAlgHom.coe_comp, coe_to_non_unital_alg_hom, Function.comp_apply, forall_const]
simp
simp only [map_star, AlgHom.to_fun_eq_coe, AlgHom.coe_comp, coe_to_alg_hom,
        Function.comp_apply, eq_self_iff_true, forall_const]
simp [map_star, Prod.star_def]
simp [Prod.star_def, map_star]
simp only [Algebra.algebra_map_eq_smul_one, map_smul, map_one]
cases f
cases g
congr
rw [e₁.map_smul', e₂.map_smul']
rw [e₁.map_star', e₂.map_star']
cases p <;> cases q <;> congr
rw [← mem_to_subalgebra, ← mem_to_subalgebra, h]
simp only [Set.mem_star, Subalgebra.mem_carrier] at *
exact (star_mul x y).symm ▸ mul_mem hy hx
simp only [Set.mem_star, Subalgebra.mem_carrier] at *
exact (star_add x y).symm ▸ add_mem hx hy
intro s S
rw [← to_subalgebra_le_iff, adjoin_to_subalgebra, Algebra.adjoin_le_iff, coe_to_subalgebra]
exact
    ⟨fun h => (Set.subset_union_left s _).trans h, fun h =>
      (Set.union_subset h) fun x hx => star_star x ▸ star_mem (show star x ∈ S from h hx)⟩
rw [Set.mem_singleton_iff] at ha hb
rw [ha, hb]
simp only [← SetLike.mem_coe, coe_Inf, Set.mem_Inter₂]
simp
simp [infi]
simp only [infi, mem_Inf, Set.forall_range_iff]
simp
rw [← mem_to_subalgebra, bot_to_subalgebra, Algebra.mem_bot]
simp [Set.ext_iff, mem_bot]
rw [h] <;> exact mem_top
rw [Set.mem_setOf_eq, map_mul f, map_mul g, ha, hb]
rw [Set.mem_setOf_eq, map_add f, map_add g, ha, hb]
simp only [Set.mem_setOf_eq, AlgHomClass.commutes]
rw [Set.mem_setOf_eq, map_star f, map_star g, ha]
refine'
    FunLike.ext f g fun a =>
      adjoin_induction' a (fun x hx => _) (fun r => _) (fun x y hx hy => _) (fun x y hx hy => _)
        fun x hx => _
· exact h ⟨x, subset_adjoin R s hx⟩ hx
· simp only [AlgHomClass.commutes]
· rw [map_add, map_add, hx, hy]
· rw [map_mul, map_mul, hx, hy]
· rw [map_star, map_star, hx]
simp only [mul_one, and_self_iff, Set.mem_setOf_eq, star_one]
simp only [mul_assoc, star_mul]
rw [← mul_assoc]
rw [hA₁, mul_one, hB₁]
rw [star_mul]
rw [hB₂, mul_one, hA₂]
rw [star_star, mul_star_self_of_mem hU]
rw [star_star, star_mul_self_of_mem hU]
simp only [div_eq_mul_inv, coe_inv, Submonoid.coe_mul]
induction z
· simp [SubmonoidClass.coe_pow]
· simp [coe_inv]
simp [h]
simp [bit0]
simp [bit1]
infer_instance
infer_instance
infer_instance
rw [star_mul, ← mul_assoc, mul_assoc _ _ c]
rw [← star_mul, mul_invOf_self, star_one]
rw [← star_mul, invOf_mul_self, star_one]
simp only [mem_star, star_star]
simp only [← star_preimage]
rw [image_eq_preimage_of_inverse] <;> intro <;> simp only [star_star]
simp only [← star_preimage, preimage_preimage, star_star, preimage_id']
rw [← star_subset_star, star_star]
infer_instance
rw [LinearMap.map_add, of_f, of_f, ihx, ihy] <;> rfl
rw [← hx, SetLike.mem_coe, LinearMap.sub_mem_ker_iff, DirectSum.to_module_lof,
        DirectSum.to_module_lof, Hg]
rw [LinearMap.comp_apply, of_f] <;> rfl
rw [lift_of] <;> rfl
rw [← @Dfinsupp.sum_single ι G _ _ _ x]
unfold Dfinsupp.sum
simp only [LinearMap.map_sum]
refine' Finset.sum_congr rfl fun k hk => _
rw [DirectSum.single_eq_lof R k (x k), DirectSum.to_module_lof, DirectSum.to_module_lof,
    totalize_of_le (hx k hk), totalize_of_le (le_trans (hx k hk) hij), DirectedSystem.map_map]
infer_instance
simp [LinearMap.map_add, hxi, hyj, to_module_totalize_of_le hik hi,
            to_module_totalize_of_le hjk hj]
simp [LinearMap.map_smul, hxi]
simp [hx0]
simp [DirectSum.apply_eq_component, hx0]
simp
simp
infer_instance
rw [(of _ _ _).map_mul, of_f, of_f, hs] <;> rfl
rw [(of _ _ _).map_neg, ih] <;> rfl
rw [(of _ _ _).map_add, of_f, of_f, ihx, ihy] <;> rfl
rw [map_C, h]
rw [Polynomial.map_mul, map_C, h, Polynomial.map_pow, map_X]
infer_instance
rw [restriction_of, dif_pos hixs, lift_of] at hx <;> exact hx
intro x y hxy
rw [← sub_eq_zero]
apply this
rw [(of G _ i).map_sub, hxy, sub_self]
intro x hx
exact (mem_bot P).1 (this hx)
simp
simp
infer_instance
rw [h, (Ring.DirectLimit.of _ _ _).map_zero]
rw [inv, dif_neg hp, Classical.choose_spec (direct_limit.exists_inv G f hp)]
rw [_root_.mul_comm, direct_limit.mul_inv_cancel G f hp]
simp
rw [this]
simp
refine' Multiset.induction_on t _ fun a t ht => _
· simp
rw [Multiset.prod_cons, Multiset.map_cons, Multiset.prod_cons, Polynomial.mul_coeff_zero, ht]
rw [next_coeff_multiset_prod]
· simp only [next_coeff_X_sub_C]
    exact t.sum_hom (-AddMonoidHom.id R)
· intros
    apply monic_X_sub_C
assumption
rw [← leading_coeff_hom_apply, MonoidHom.map_multiset_prod]
rfl
rw [smul_C, eval_C, eval_C]
rw [smul_add, eval_add, ihf, ihg, eval_add, smul_add]
rw [smul_mul', smul_pow', smul_C, smul_X, eval_mul, eval_C, eval_pow, eval_X, eval_mul, eval_C,
      eval_pow, eval_X, smul_mul', smul_pow']
rw [← smul_eval_smul, smul_inv_smul]
rw [← smul_eval_smul, smul_inv_smul]
simp
rw [of_quotient_stabilizer_smul, smul_sub, Polynomial.smul_X, Polynomial.smul_C]
rw [← Polynomial.coeff_smul, prodXSubSmul.smul]
rw [smul_C, map_C, coe_fn_coe, g.map_smul, map_C, coe_fn_coe, smul_C]
rw [smul_add, Polynomial.map_add, ihp, ihq, Polynomial.map_add, smul_add]
rw [smul_mul', smul_C, smul_pow', smul_X, Polynomial.map_mul, map_C, Polynomial.map_pow,
        map_X, coe_fn_coe, g.map_smul, Polynomial.map_mul, map_C, Polynomial.map_pow, map_X,
        smul_mul', smul_C, smul_pow', smul_X, coe_fn_coe]
dsimp only [List.dprodIndex]
induction l
· simp
· simp [l_ih]
induction l
· simp
    rfl
· simp [← l_ih, GradedMonoid.mk_mul_mk, List.prod_cons]
    rfl
rw [List.of_fn_eq_map, GradedMonoid.list_prod_map_eq_dprod]
induction l
· rw [List.dprod_nil, List.map_nil, List.prod_nil]
    rfl
· rw [List.dprod_cons, List.map_cons, List.prod_cons, l_ih]
    rfl
induction n
· rw [pow_zero, zero_nsmul]
    exact one_mem_graded _
· rw [pow_succ', succ_nsmul']
    exact mul_mem_graded n_ih h
induction l
· rw [List.map_nil, List.map_nil, List.prod_nil, List.sum_nil]
    exact one_mem_graded _
· rw [List.map_cons, List.map_cons, List.prod_cons, List.sum_cons]
    exact
      mul_mem_graded (h _ <| List.mem_cons_self _ _)
        (l_ih fun j hj => h _ <| List.mem_cons_of_mem _ hj)
rw [List.of_fn_eq_map, List.of_fn_eq_map]
exact list_prod_map_mem_graded _ _ _ fun _ _ => h _
induction l
· rw [List.dprod_nil, coe_ghas_one, List.map_nil, List.prod_nil]
· rw [List.dprod_cons, coe_ghas_mul, List.map_cons, List.prod_cons, l_ih]
apply Iff.trans Multiset.lcm_dvd
simp only [Multiset.mem_map, and_imp, exists_imp]
exact ⟨fun k b hb => k _ _ hb rfl, fun k a' b hb h => h ▸ k _ hb⟩
simp [lcm_def]
rw [empty_union, lcm_empty, lcm_one_left, normalize_lcm]
rw [insert_union, lcm_insert, lcm_insert, ih, lcm_assoc]
subst hs
exact Finset.fold_congr hfg
simp only [Multiset.mem_map, lcm_def, Multiset.lcm_eq_zero_iff, Set.mem_image, mem_coe, ←
    Finset.mem_def]
apply Iff.trans Multiset.dvd_gcd
simp only [Multiset.mem_map, and_imp, exists_imp]
exact ⟨fun k b hb => k _ _ hb rfl, fun k a' b hb h => h ▸ k _ hb⟩
simp [gcd_def]
rw [empty_union, gcd_empty, gcd_zero_left, normalize_gcd]
rw [insert_union, gcd_insert, gcd_insert, ih, gcd_assoc]
subst hs
exact Finset.fold_congr hfg
rw [h b hb, gcd_eq_zero_iff.2 h, mul_one]
simp
rw [norm_unit_one, Units.val_one, mul_one]
rw [hx, zero_mul, zero_mul, zero_mul]
rw [hy, mul_zero, zero_mul, mul_zero]
simp only [norm_unit_mul hx hy, Units.val_mul] <;> simp only [mul_assoc, mul_left_comm y]
simp
simp
rw [mul_right_comm a]
simp
simp
simp only [Associates.quotient_mk_eq_mk, out_mk, mk_mul_mk, normalize.map_mul]
simp [Associates.out_mk, Associates.quotient_mk_eq_mk, mk_le_mk_iff_dvd_iff]
simp [Associates.out_mk, Associates.quotient_mk_eq_mk, mk_le_mk_iff_dvd_iff]
let ⟨ca, ha⟩ := gcd_dvd_left a b
let ⟨cb, hb⟩ := gcd_dvd_right a b
rw [h, zero_mul] at ha hb <;> exact ⟨ha, hb⟩
rw [ha, hb, ← zero_dvd_iff]
apply dvd_gcd <;> rfl
simp only [mul_comm, gcd_mul_left]
simp only [mul_comm, gcd_mul_left']
rw [mul_comm] at H⊢
exact dvd_gcd_mul_of_dvd_mul H
apply (dvd_gcd_mul_of_dvd_mul h2).trans
rw [IsUnit.mul_left_dvd _ _ _ h1]
intro hdk
rw [hdk] at h3
apply absurd (zero_dvd_iff.mp h3) ha
rw [h]
exact dvd_pow_self _ hk.ne'
apply (mul_right_inj' h0₁).mp
rw [mul_one]
apply (mul_right_inj' h0₂).mp
rw [← h]
rw [mul_assoc, mul_comm a', ← mul_assoc _ b', ← mul_assoc b', mul_comm b']
rw [h, zero_mul]
rw [h, zero_mul]
rw [h, mul_zero]
rw [lcm_units_coe_left, normalize_coe_units]
simp only [mul_comm, lcm_mul_left]
rw [gcd_comm _ a, gcd_comm _ a, gcd_eq_of_dvd_sub_right h]
rw [this, normalize_idem]
rw [← normalize_gcd]
exact normalize_eq_normalize (gcd_dvd_left _ _) (dvd_gcd (dvd_refl a) (dvd_zero a))
simp [x0, y0, mul_comm]
rw [dif_neg (Units.ne_zero _), Units.mk0_val]
infer_instance
simp [if_pos h]
simp [if_neg h]
simp [if_pos h]
simp [if_neg h]
simp [norm_unit, h0]
simp [normalize_apply, h0]
rw [mul_comm, he]
rw [isUnit_iff_dvd_one, ← one_pow]
exact
        (dvd_gcd this <| dvd_refl y).trans
          (gcd_pow_left_dvd_pow_gcd.trans <| pow_dvd_pow_of_dvd (isUnit_iff_dvd_one.1 hg) _)
simp [lcm]
simp
simp (config := { contextual := true }) [or_imp, forall_and, lcm_dvd_iff]
simp
simp
simp
rw [← lcm_dedup, dedup_ext.2, lcm_dedup, lcm_add]
simp
rw [← lcm_dedup, dedup_ext.2, lcm_dedup, lcm_add]
simp
rw [← lcm_dedup, dedup_ext.2, lcm_dedup, lcm_cons]
simp
simp [gcd]
simp
simp (config := { contextual := true }) [or_imp, forall_and, dvd_gcd_iff]
simp
simp
constructor
· intro h x hx
    apply eq_zero_of_zero_dvd
    rw [← h]
    apply gcd_dvd hx
· apply s.induction_on
    · simp
    intro a s sgcd h
    simp [h a (mem_cons_self a s), sgcd fun x hx => h x (mem_cons_of_mem hx)]
simp
rw [← gcd_dedup, dedup_ext.2, gcd_dedup, gcd_add]
simp
rw [← gcd_dedup, dedup_ext.2, gcd_dedup, gcd_add]
simp
rw [← gcd_dedup, dedup_ext.2, gcd_dedup, gcd_cons]
simp
rw [add_comm a b, add_comm a c]
exact rel.add_left h
simp only [neg_eq_neg_one_mul a, neg_eq_neg_one_mul b, rel.mul_right h]
simp only [sub_eq_add_neg, h.add_left]
simp only [sub_eq_add_neg, h.neg.add_right]
simp only [Algebra.smul_def, rel.mul_right h]
rw [zero]
rw [one]
show add r _ _ = _
rw [add]
rfl
show mul r _ _ = _
rw [mul]
rfl
show npow r _ _ = _
rw [npow]
show neg r _ = _
rw [neg]
rfl
show sub r _ _ = _
rw [sub]
rfl
show smul r _ _ = _
rw [smul]
rfl
simp [Nat.cast, nat_cast, ← zero_quot]
simp [Nat.cast, nat_cast, ← one_quot, add_quot]
simp [← one_quot]
simp [mul_quot]
simp [← zero_quot]
simp [add_quot]
simp [← one_quot]
simp [mul_quot]
simp [← zero_quot]
simp [add_quot]
simp [mk_ring_hom, Quot.sound (rel.of w)]
simp [← zero_quot, f.map_zero]
simp [← one_quot, f.map_one]
dsimp
rw [mk_ring_hom_rel h]
dsimp
rw [mk_ring_hom_rel h]
induction h
· exact rel.of (hr _ _ h_h)
· rw [star_add, star_add]
    exact rel.add_left h_ih
· rw [star_mul, star_mul]
    exact rel.mul_right h_ih
· rw [star_mul, star_mul]
    exact rel.mul_left h_ih
show star' r _ _ = _
rw [star']
rfl
simp [mk_alg_hom, mk_ring_hom, Quot.sound (rel.of w)]
simp [← zero_quot, f.map_zero]
simp [← one_quot, f.map_one]
dsimp
erw [mk_alg_hom_rel S h]
dsimp
erw [mk_alg_hom_rel S h]
simp only [unop_op, op_inj]
exact self_distrib_inv
simp
simp
rw [← right_inv x y, ← self_distrib]
simp
simp
rw [← left_cancel x, right_inv]
exact ((h x).LeftInverse y).symm
rw [self_distrib]
rw [left_cancel]
simp
simp
rw [← left_cancel x]
simp
induction x using MulOpposite.rec
simp
simp
simp
constructor
apply pre_envel_group_rel.refl
constructor
apply pre_envel_group_rel.symm
apply pre_envel_group_rel.trans
simp [to_envel_group.map_aux, well_def ha, well_def hb]
simp [to_envel_group.map_aux, well_def ha]
apply mul_assoc
simp [to_envel_group.map_aux]
simp [to_envel_group.map_aux]
simp [to_envel_group.map_aux]
simp [to_envel_group.map_aux]
change Quotient.liftOn
change Quotient.liftOn
induction instead of going through `f s.prod
cases f <;> cases g <;> congr
rw [map_id', map_id', h]
rw [Multiset.map_const, Multiset.map_const, prod_repeat, prod_repeat, hs, ht]
rw [prod_map_mul, prod_map_mul, map_prod_eq_map_prod f hsA htA hs ht h,
          map_prod_eq_map_prod g hsA htA hs ht h]
rw [prod_map_inv, prod_map_inv, map_prod_eq_map_prod f hsA htA hs ht h]
rw [prod_map_div, prod_map_div, map_prod_eq_map_prod f hsA htA hs ht h,
          map_prod_eq_map_prod g hsA htA hs ht h]
rw [prod_map_pow, prod_map_pow, map_prod_eq_map_prod f hsA htA hs ht h]
rw [prod_map_zpow, prod_map_zpow, map_prod_eq_map_prod f hsA htA hs ht h]
rw [← f.map_multiset_prod, h, f.map_multiset_prod]
rw [pow_zero, h1]
rfl
rw [pow_succ, iterate_succ', hmul, hom_coe_pow]
rw [iterate_zero, id.def, pow_zero, one_smul]
rw [iterate_succ', comp_app, ih, pow_succ, mul_smul]
simp [mul_right_iterate]
rw [← mul_assoc, h.eq, mul_assoc]
cases f <;> cases g <;> congr
refine' { toFun := id.. } <;> intros <;> rfl
rw [← comp_apply, h, comp_apply]
simp [bit1]
cases f <;> cases g <;> congr
rw [map_one, eq_comm]
rw [← mul_one x, map_mul, h, mul_zero]
simp [← hx, h x]
rw [h, map_zero]
refine' { toFun := id.. } <;> intros <;> rfl
simp
rw [← comp_apply, h, comp_apply]
have hxy := h (x + y)
rw [mul_add, add_mul, add_mul, f.map_add, f.map_add, f.map_add, f.map_add, h x, h y, add_mul,
        mul_add, mul_add, ← sub_eq_zero, add_comm, ← sub_sub, ← sub_sub, ← sub_sub, mul_comm y x,
        mul_comm (f y) (f x)] at hxy
simp only [add_assoc, add_sub_assoc, add_sub_cancel'_right] at hxy
rw [sub_sub, ← two_mul, ← add_sub_assoc, ← two_mul, ← mul_sub, mul_eq_zero, sub_eq_zero,
        or_iff_not_imp_left] at hxy
exact hxy h_two
rw [h₂ x, h₂ y]
rw [f.map_mul]
rw [← f.map_one, h₁]
rw [← map_mul, one_mul]
rw [← map_mul, zero_mul]
cases f
cases g
congr
rw [h1.map_mul, h2.map_mul]
simp [div_eq_mul_inv]
simp [div_eq_mul_inv]
simp [div_eq_mul_inv]
simp [div_eq_mul_inv]
simp [mul_assoc]
simp [mul_assoc]
simp [mul_assoc]
simp [add_assoc]
simp [add_assoc]
simp [add_assoc]
simp
simp [mul_pow]
simp
simp [mul_zpow]
rw [f.map_one, one_apply]
rw [f.map_mul, mul_apply]
cases f <;> cases g <;> congr
rw [f.map_smul]
rw [comp_apply, id_apply]
rw [comp_apply, id_apply]
rw [h₂]
rw [f.map_smul]
rw [h₁]
cases f <;> cases g <;> congr
simp
rw [comp_apply, id_apply]
rw [comp_apply, id_apply]
cases f <;> cases g <;> congr
rw [comp_apply, id_apply]
rw [comp_apply, id_apply]
rw [← f.map_mul, u.val_inv, f.map_one]
rw [← f.map_mul, u.inv_val, f.map_one]
rw [div_eq_mul_inv, divp, u.coe_inv]
simp only [h, coe_mul, f.map_mul]
rw [Units.mul_inv_eq_iff_eq_mul, one_mul, coe_lift_right]
rw [Units.inv_mul_eq_iff_eq_mul, mul_one, coe_lift_right]
rw [div_eq_mul_inv, h.mul_inv_cancel]
rw [div_eq_mul_inv, h.inv_mul_cancel_right]
rw [div_eq_mul_inv, h.mul_inv_cancel_right]
simp [h]
simp [h]
rw [div_eq_mul_inv]
exact ha.mul hb.inv
rw [div_eq_mul_inv, h.mul_inv_eq_iff_eq_mul]
rw [div_eq_mul_inv, h.eq_mul_inv_iff_mul_eq]
rw [div_eq_mul_inv, mul_inv_rev, h.mul_inv_cancel_left, one_div]
simp only [div_eq_mul_inv, mul_inv_rev, mul_assoc, h.mul_inv_cancel_left]
simp [h]
rw [mul_comm, h.div_mul_left]
rw [mul_comm, h.mul_div_cancel]
rw [mul_comm, h.div_mul_cancel]
rw [mul_comm c, mul_comm c, h.mul_div_mul_right]
rw [← mul_one a, ← hb.div_self, ← mul_comm_div, h, div_mul_eq_mul_div, hd.div_mul_cancel]
rw [← (hb.mul hd).mul_left_inj, ← mul_assoc, hb.div_mul_cancel, ← mul_assoc, mul_right_comm,
    hd.div_mul_cancel]
rw [div_div_eq_mul_div, h.mul_div_cancel_left]
rw [← ZeroHomClass.map_zero f]
exact hf.ne (Ne r)
cases f <;> cases g <;> congr
cases f <;> cases g <;> congr
cases f <;> cases g <;> congr
rw [← map_mul, h, map_one]
rw [div_eq_mul_inv, div_eq_mul_inv, map_mul, hf]
rw [map_mul, map_inv]
rw [pow_zero, pow_zero, map_one]
rw [pow_succ, pow_succ, map_mul, map_pow]
rw [zpow_ofNat, map_pow, zpow_ofNat]
rw [zpow_negSucc, hf, map_pow, ← zpow_negSucc]
cases f <;> cases g <;> congr
simp
simp
simp
simp
simp
simp
simp
rw [← OneHom.comp_apply, h, OneHom.comp_apply]
rw [← MulHom.comp_apply, h, MulHom.comp_apply]
rw [← MonoidHom.comp_apply, h, MonoidHom.comp_apply]
rw [← MonoidWithZeroHom.comp_apply, h, MonoidWithZeroHom.comp_apply]
intros
show f (x * y) * g (x * y) = f x * g x * (f y * g y)
rw [f.map_mul, g.map_mul, ← mul_assoc, ← mul_assoc, mul_right_comm (f x)]
simp
intros
show f (x * y) * g (x * y) = f x * g x * (f y * g y)
rw [f.map_mul, g.map_mul, ← mul_assoc, ← mul_assoc, mul_right_comm (f x)]
rw [map_mul, hxy, ← map_mul, mul_inv_self, map_one]
rw [← map_mul, mul_one]
simp only [one_mul, inv_one, ← map_div, inv_inv]
simp only [map_div]
simp only [mul_right_inv, one_mul, inv_inv]
rw [← mul_inv, f.map_mul]
simp [div_eq_mul_inv, mul_assoc, mul_left_comm, mul_comm]
rw [map_zero, zero_mul]
simp
simp
simp only [Pi.prod, Prod.zero_eq_mk, map_zero]
simp only [Pi.prod, Prod.mk_add_mk, map_add]
simp only [Pi.prod, Prod.mk_mul_mk, map_mul]
simp only [Pi.prod, Prod.smul_mk, map_smul, RingHom.id_apply]
cases f
cases g
congr
rw [← comp_apply, h, comp_apply]
simp [map_mul_left, mul_add]
simp [map_mul_right, add_mul]
change n
change n
rw [comp_app, map_mul_right, map_mul_left, ← map_mul_right, ← map_mul_left]
simp [map_mul_left]
simp [map_mul_right]
simp [map_mul_left, mul_sub]
simp [map_mul_right, sub_mul]
change n
change n
refine' { PUnit.commGroup, PUnit.addCommGroup with natCast := fun _ => PUnit.unit.. } <;>
      intros <;>
    exact Subsingleton.elim _ _
refine' { PUnit.commRing with .. } <;> intros <;> exact Subsingleton.elim _ _
refine'
        { gcd := fun _ _ => star
          lcm := fun _ _ => star
          normUnit := fun x => 1
          gcd_dvd_left := fun _ _ => ⟨star, Subsingleton.elim _ _⟩
          gcd_dvd_right := fun _ _ => ⟨star, Subsingleton.elim _ _⟩
          dvd_gcd := fun _ _ _ _ _ => ⟨star, Subsingleton.elim _ _⟩
          gcd_mul_lcm := fun _ _ => ⟨1, Subsingleton.elim _ _⟩.. } <;>
      intros <;>
    exact Subsingleton.elim _ _
refine'
        { PUnit.commRing, PUnit.completeBooleanAlgebra with
          exists_add_of_le := fun _ _ _ => ⟨star, Subsingleton.elim _ _⟩.. } <;>
      intros <;>
    trivial
refine' { PUnit.hasSmul with .. } <;> intros <;> exact Subsingleton.elim _ _
refine' { PUnit.hasSmul with .. } <;> intros <;> exact Subsingleton.elim _ _
refine' { PUnit.mulAction with .. } <;> intros <;> exact Subsingleton.elim _ _
refine' { PUnit.mulAction with .. } <;> intros <;> exact Subsingleton.elim _ _
refine' { PUnit.distribMulAction with .. } <;> intros <;> exact Subsingleton.elim _ _
simp
rw [← le_aleph_0_iff_set_countable, ← lift_le]
apply (cardinal_mk_lift_le_max R A).trans
simp
rw [finite.mem_to_finset] at hx
exact hs hx
rw [← finprod_one]
congr
subst q
exact finprod_congr hfg
rw [finprod_eq_prod_plift_of_mul_support_subset h.coe_to_finset.ge,
    finprod_eq_prod_plift_of_mul_support_subset, f.map_prod]
rw [h.coe_to_finset]
exact mul_support_comp_subset f.map_one (g ∘ PLift.down)
rw [← mem_mul_support, finprod_eq_mul_indicator_apply, mul_indicator_mul_support]
rw [mul_support_comp_eq_preimage]
exact (equiv.plift.symm.image_eq_preimage _).symm
rw [A, Finset.coe_map]
exact image_subset _ h
rw [Set.mul_support_mul_indicator]
intro x hx
exact (h hx.2).1 hx.1
apply finprod_cond_eq_prod_of_cond_iff
intro x hx
rw [Finset.mem_erase, finite.mem_to_finset, mem_mul_support]
exact ⟨fun h => And.intro h hx, fun h => h.1⟩
simp [inter_assoc]
simp [inter_comm, inter_left_comm]
rw [coe_to_finset]
rw [hs.coe_to_finset]
simp (config := { contextual := true }) [h]
rw [finprod_mem_def, finprod_mem_def, mul_indicator_inter_mul_support]
rw [← finprod_mem_inter_mul_support, h, finprod_mem_inter_mul_support]
simp (config := { contextual := true }) [h]
simp only [div_eq_mul_inv, finprod_mul_distrib hf ((mul_support_inv g).symm.rec hg),
    finprod_inv_distrib]
rw [← mul_support_mul_indicator] at hf hg
simp only [finprod_mem_def, mul_indicator_mul, finprod_mul_distrib hf hg]
simp
rw [← finprod_mem_one s]
exact finprod_mem_congr rfl hf
simp only [div_eq_mul_inv, finprod_mem_mul_distrib hs, finprod_mem_inv_distrib g hs]
simp
rw [← finprod_mem_union_inter' hs ht, disjoint_iff_inter_eq_empty.1 hst, finprod_mem_empty,
    mul_one]
rw [← finprod_mem_inter_mul_support f s, ← finprod_mem_inter_mul_support f t, ←
    finprod_mem_union hst hs ht, ← union_inter_distrib_right, finprod_mem_inter_mul_support]
rw [← Finset.coe_singleton, finprod_mem_coe_finset, Finset.prod_singleton]
simp [@eq_comm _ a]
rw [← Set.BijOn.image_eq he₀, finprod_mem_image he₀.2.1]
exact finprod_mem_congr rfl he₁
rw [← finprod_mem_univ f, ← finprod_mem_univ g]
exact finprod_mem_eq_of_bij_on _ (bijective_iff_bij_on_univ.mp he₀) fun x _ => he₁ x
rw [← finprod_mem_range, Subtype.range_coe]
exact Subtype.coe_injective
rw [← finprod_mem_inter_mul_diff' _ ht, inter_eq_self_of_subset_right hst]
rw [Set.sUnion_eq_bUnion]
exact finprod_mem_bUnion h ht₀ ht₁
intro x hx
rw [Finset.mem_sdiff, Finset.mem_singleton, finite.mem_to_finset, mem_mul_support]
exact ⟨fun h => And.intro hx h, fun h => h.2⟩
simp
simp
apply Finset.induction
· simp
· intro a s has H
    rw [Finset.prod_insert has, Finset.sum_insert has, pow_add, H]
rw [sum_product, sum_mul, sum_congr rfl]
intros
rw [mul_sum]
simp
simp
simp only [div_eq_mul_inv, sum_mul]
rw [eq₂, eq₃, Eq]
simp
simp_all
simp
simp
rw [prod_sub_ordered]
simp
rw [← prod_const, prod_add]
refine' Finset.sum_congr rfl fun t ht => _
rw [prod_const, prod_const, ← card_sdiff (mem_powerset.1 ht)]
rw [powerset_card_disj_Union, prod_disj_Union]
simp only [add_mul, mul_add, add_assoc, sum_range_succ]
simp [mul_left_comm]
simp [mul_left_comm]
simp [mul_right_comm]
simp [mul_comm]
rw [← s.coe_to_list, coe_erase, coe_prod, coe_prod, List.prod_erase (mem_to_list.2 h)]
rw [← m.coe_to_list, coe_erase, coe_map, coe_map, coe_prod, coe_prod,
    List.prod_map_erase f (mem_to_list.2 h)]
simp only [mul_one, prod_cons, ← cons_zero, eq_self_iff_true, prod_zero]
rw [insert_eq_cons, prod_cons, prod_singleton]
simp
rw [zero_nsmul, pow_zero]
rfl
rw [add_nsmul, one_nsmul, pow_add, pow_one, prod_add, prod_nsmul n]
rw [filter_eq, prod_repeat]
simp only [l.prod_hom f, quot_mk_to_coe, coe_map, coe_prod]
simp only [l.prod_hom₂ f hf hf', quot_mk_to_coe, coe_map, coe_prod]
simp only [l.prod_hom_rel h₁ h₂, quot_mk_to_coe, coe_map, coe_prod]
rw [map_const, prod_repeat, one_pow]
refine' Quotient.ind _ s
simp
simp
simp [ih]
simp [mul_left_comm]
apply Multiset.induction_on' S
· simp
intro a T haS _ IH
simp [mul_dvd_mul (h a haS) IH]
rw [quot_mk_to_coe, coe_prod]
exact List.prod_eq_zero_iff
simp
simp [ih, mul_add]
simp
simp [ih, add_mul]
rw [sum_cons]
exact dvd_add (h _ (mem_cons_self _ _)) (ih fun y hy => h _ <| mem_cons.2 <| Or.inr hy)
apply Quotient.induction_on s
simp only [quot_mk_to_coe, coe_prod, mem_coe]
exact fun l => List.all_one_of_le_one_le_of_prod_eq_one
rw [← Multiset.prod_repeat, ← Multiset.map_const]
exact prod_map_le_prod _ h
revert s
refine' Multiset.induction _ _
· simp [le_of_eq h_one]
intro a s hs hpsa
have hps : ∀ x, x ∈ s → p x := fun x hx => hpsa x (mem_cons_of_mem hx)
have hp_prod : p s.prod := prod_induction p s hp_mul hp_one hps
rw [prod_cons, map_cons, prod_cons]
exact (h_mul a s.prod (hpsa a (mem_cons_self a s)) hp_prod).trans (mul_le_mul_left' (hs hps) _)
simp
simp
simp [h_mul]
simp
simp
simp
simp
induction s using Quotient.induction_on
rw [quot_mk_to_coe, coe_sum]
exact Commute.list_sum_right _ _ h
rw [List.map_cons, h₁, h₂]
rw [xs_eq]
rw [← ys_eq, xs_eq]
rw [← xs_eq] <;> rfl
rw [← ys_eq, ← Multiset.coe_map, xs_eq]
congr <;> assumption
rw [List.prod_cons, his, hi]
rw [← h₂, ← Multiset.coe_prod, h₁]
rw [← hs, Finset.prod_mk, Multiset.coe_map, Multiset.coe_prod, hx]
rw [antidiagonal_succ, prod_cons, Prod_map]
rfl
rw [← prod_antidiagonal_swap, prod_antidiagonal_succ, ← prod_antidiagonal_swap]
rfl
rw [nat.mem_antidiagonal.1 hp]
simp (config := { contextual := true }) [Prod.ext_iff]
simp [mt isUnit_iff_dvd_one.2 hp.not_unit]
simp only [Multiset.map_id', associated_eq_eq, Multiset.countp_eq_card_filter, ←
            Multiset.count_eq_card_filter_eq, ← Multiset.nodup_iff_count_le_one, s.nodup]
simp
simp [ih, Associates.mk_mul_mk]
rw [Finset.prod_eq_multiset_prod, ← Multiset.map_map, prod_mk, ← Finset.prod_eq_multiset_prod]
rw [← Multiset.rel_eq, Multiset.rel_map]
simp only [mk_eq_mk_iff_associated]
simp
simp (config := { contextual := true }) [mul_eq_one_iff, or_imp, forall_and]
simp [univ_def]
rw [List.of_fn_eq_map, prod_univ_def]
rw [univ_succ_above, prod_cons, Finset.prod_map, RelEmbedding.coe_fn_to_embedding]
simp
simp [prod_univ_succ]
rw [prod_univ_cast_succ, prod_univ_two]
rfl
rw [prod_univ_cast_succ, prod_univ_three]
rfl
rw [prod_univ_cast_succ, prod_univ_four]
rfl
rw [prod_univ_cast_succ, prod_univ_five]
rfl
rw [prod_univ_cast_succ, prod_univ_six]
rfl
rw [prod_univ_cast_succ, prod_univ_seven]
rfl
simp
simp
rw [Ioi_zero_eq_map, Finset.prod_map, RelEmbedding.coe_fn_to_embedding, coe_succ_embedding]
rw [Ioi_succ, Finset.prod_map, RelEmbedding.coe_fn_to_embedding, coe_succ_embedding]
simp [partial_prod]
simp [partial_prod, List.take_succ, List.ofFnNthVal, dif_pos j.is_lt, ← Option.coe_def]
simp
simp only [coe_eq_cast_succ, Pi.smul_apply, smul_eq_mul] at hx⊢
rw [partial_prod_succ, ← mul_assoc, hx, mul_inv_cancel_left]
simp
rw [← length_of_fn f] at h
have : length (of_fn f) ≤ i := not_lt.mp h
rw [take_all_of_le this, take_all_of_le (le_trans this (Nat.le_succ _))]
intro j
have : (j : ℕ) < i := lt_of_lt_of_le j.2 (not_lt.mp h)
simp [this, lt_trans this (Nat.lt_succ_self _)]
simp
rw [Finset.prod, Multiset.map_id]
simp only [sum_eq_multiset_sum, Multiset.sum_map_singleton]
simp only [Finset.prod_eq_multiset_prod, map_multiset_prod, Multiset.map_map]
rw [univ_eq_empty, prod_empty]
rw [prod_insert (not_mem_singleton.2 h), prod_singleton]
simp only [Finset.prod, Multiset.map_const, Multiset.prod_repeat, one_pow]
rw [Finset.prod, Finset.map_val, Multiset.map_map] <;> rfl
rw [h] <;> exact fold_congr
refine' Eq.trans _ (fold_disj_union h)
rw [one_mul]
rfl
refine' Eq.trans _ (fold_disj_Union h)
dsimp [Finset.prod, Multiset.prod, Multiset.fold, Finset.disjUnion, Finset.fold]
congr
exact prod_const_one.symm
rw [← prod_union_inter, disjoint_iff_inter_eq_empty.mp h] <;> exact (mul_one _).symm
rw [Finset.prod, ← Multiset.coe_prod, ← Multiset.coe_map, Finset.coe_to_list]
rw [← prod_union sdiff_disjoint, sdiff_union_of_subset h]
rw [← map_inl_disj_union_map_inr, prod_disj_union, Prod_map, Prod_map]
rfl
simp
rw [← disj_Union_eq_bUnion _ _ hs, prod_disj_Union]
refine' Eq.trans _ (prod_sigma s t fun p => f (p.1, p.2))
exact
    prod_bij' (fun p hp => ⟨p.1, p.2⟩) (fun p => mem_sigma.mpr ∘ (h p).mp)
      (fun p hp => congr_arg f prod.mk.eta.symm) (fun p hp => (p.1, p.2))
      (fun p => (h (p.1, p.2)).mpr ∘ mem_sigma.mp) (fun p hp => Prod.mk.eta) fun p hp => p.eta
refine' Eq.trans _ (prod_sigma s t fun p => f (p.2, p.1))
exact
    prod_bij' (fun p hp => ⟨p.2, p.1⟩) (fun p => mem_sigma.mpr ∘ (h p).mp)
      (fun p hp => congr_arg f prod.mk.eta.symm) (fun p hp => (p.2, p.1))
      (fun p => (h (p.2, p.1)).mpr ∘ mem_sigma.mp) (fun p hp => Prod.mk.eta) fun p hp => p.eta
rw [← disj_Union_filter_eq_of_maps_to h]
rw [prod_disj_Union]
rw [one_mul] <;> rfl
delta Finset.prod
apply Multiset.prod_hom_rel <;> assumption
rw [← prod_sdiff h, prod_eq_one hg, one_mul]
exact prod_congr rfl hfg
rw [if_pos (mem_filter.1 h).2]
refine' prod_subset (filter_subset _ s) fun x hs h => _
rw [mem_filter, not_and] at h
exact if_neg (h hs)
refine' insert_subset.mpr _
apply And.intro ha
apply singleton_subset_iff.mpr hb
intro c hc hcs
apply h₀ c hc
apply not_or_distrib.mp
intro hab
apply hcs
apply mem_insert.mpr
rw [mem_singleton]
exact hab
rw [prod_image] <;> exact fun x _ y _ => Subtype.eq
rw [attach_image_val]
rw [Finset.prod_map]
exact Finset.prod_congr rfl h
have : (· ∈ s) = p := Set.ext h
subst p
rw [← prod_coe_sort]
congr
simp
simp [prod_apply_dite _ _ fun x => x]
simp [prod_apply_ite _ _ fun x => x]
rw [prod_ite]
simp [filter_false_of_mem h, filter_true_of_mem h]
rw [← Finset.prod_filter, Finset.filter_mem_eq_inter]
simp
dsimp
rw [dif_neg]
simp
simp
dsimp
rw [dif_pos]
simp
rw [range_succ, prod_insert not_mem_range_self]
simp only [mul_comm, prod_range_succ_comm]
rw [prod_range_succ _ n, mul_right_comm, ← prod_range_succ', prod_range_succ]
rw [range_zero, prod_empty]
rw [range_one]
apply @prod_singleton β ℕ 0 f
rw [prod_list_count]
refine' prod_subset hs fun x _ hx => _
rw [mem_to_finset] at hx
rw [count_eq_zero_of_not_mem hx, pow_zero]
simp [Finset.sum, sum_map_count_dedup_filter_eq_countp p l]
refine' Quot.induction_on s fun l => _
simp [prod_list_map_count l f]
revert hs
refine' Quot.induction_on m fun l => _
simp only [quot_mk_to_coe'', coe_prod, coe_count]
apply prod_list_count_of_subset l s
simp [nonempty_iff_ne_empty.mp hs_nonempty]
apply prod_range_induction <;> simp
apply prod_range_induction <;> simp
rw [prod_range_div, mul_div_cancel'_right]
refine' sum_range_induction _ _ (tsub_self _) (fun n => _) _
have h₁ : f n ≤ f (n + 1) := h (Nat.le_succ _)
have h₂ : f 0 ≤ f n := h (Nat.zero_le _)
rw [tsub_add_eq_add_tsub h₂, add_tsub_cancel_of_le h₁]
simp
rw [← g_inv x hx, ← g_inv y hy] <;> simp [h]
simp [h]
rw [← insert_erase hx, prod_insert (not_mem_erase _ _), ←
              insert_erase (mem_erase.2 ⟨g_ne x hx hx1, g_mem x hx⟩),
              prod_insert (not_mem_erase _ _), ih', mul_one, h x hx]
simp
simp (config := { contextual := true })
rw [piecewise, prod_ite, filter_mem_eq_inter, ← sdiff_eq_filter]
rw [prod_eq_mul_prod_diff_singleton h, mul_comm]
refine' (Finset.prod_image' f fun x hx => _).symm
rfl
intro eq
rw [Eq] at hj
exact h hj
rw [update_eq_piecewise, prod_piecewise]
simp [h]
intro x hx
rw [← prod_insert (not_mem_erase a s), insert_erase h]
rw [mul_comm, mul_prod_erase s f h]
simp
simp
rw [← Nat.nsmul_eq_mul, ← sum_const]
apply sum_congr rfl h₁
simp only [add_zero, mul_one, Finset.sum_const, nsmul_eq_mul, eq_self_iff_true,
    Finset.sum_const_zero, Finset.sum_ite]
rw [eq_div_iff_mul_eq', prod_sdiff h]
simp [← Finset.prod_sdiff (@inf_le_left _ _ s₁ s₂), ← Finset.prod_sdiff (@inf_le_right _ _ s₁ s₂)]
rw [eq_div_iff_mul_eq', prod_erase_mul _ _ h]
simp
simp
simp
rw [bUnion_insert] <;> exact Finset.card_union_le _ _
rw [sum_insert has] <;> exact add_le_add_left ih _
simp only [card_eq_sum_ones, sum_fiberwise_of_maps_to H]
simp
rw [h.eq_singleton_default, Finset.prod_singleton]
rw [univ_unique, prod_singleton]
rw [eq_empty_of_is_empty (univ : Finset α), Finset.prod_empty]
simp
let ⟨not_mem, hl⟩ := List.nodup_cons.mp hl
simp [Finset.prod_insert (mt list.mem_to_finset.mp not_mem), prod_to_finset hl]
rw [quot_mk_to_coe, Multiset.coe_sum]
exact disjoint_list_sum_left
simp only [smul_eq_mul, mul_one]
simp
dsimp only [Finset.sum]
rw [count_sum]
rw [← Finset.sum_multiset_map_count, Multiset.sum_map_singleton]
apply Finset.sum_congr rfl
intro x hx
rw [← mul_nsmul', Nat.mul_div_cancel' (h x (mem_to_finset.mp hx))]
rw [Finset.prod_eq_multiset_prod]
refine' Multiset.prod_dvd_prod_of_le _
simp [Multiset.dedup_le S]
rw [← map_add_right_Ico, Prod_map]
rfl
rw [Nat.Ico_succ_right_eq_insert_Ico hab, sum_insert right_not_mem_Ico, add_comm]
simp
rw [← Ioc_union_Ioc_eq_Ioc hmn hnk, prod_union]
apply disjoint_left.2 fun x hx h'x => _
exact lt_irrefl _ ((mem_Ioc.1 h'x).1.trans_le (mem_Ioc.1 hx).2)
rw [← prod_Ioc_consecutive _ hab (Nat.le_succ b), Nat.Ioc_succ_singleton, prod_singleton]
rw [mul_comm] <;> exact prod_range_mul_prod_Ico f h
intro i hi
exact (add_le_add_iff_right 1).1 (le_trans (Nat.lt_iff_add_one_le.1 hi) h)
cases n
· simp
· simp only [← Nat.Ico_zero_eq_range, Nat.succ_sub_succ_eq_sub, tsub_zero]
    rw [prod_Ico_reflect _ _ le_rfl]
    simp
rw [prod_Ico_succ_top <| Nat.succ_le_succ <| zero_le n, Nat.factorial_succ,
      prod_Ico_id_eq_factorial n, Nat.succ_eq_add_one, mul_comm]
simp [Finset.range_succ, prod_range_add_one_eq_factorial n]
rw [sum_range_reflect (fun i => i) n, mul_two]
rw [sum_const, card_range, Nat.nsmul_eq_mul]
decide
conv in n => rw [← Nat.sub_add_cancel (Nat.one_le_of_lt hmn)]
rw [← sum_Ico_add']
rw [← sum_Ico_sub_bot _ hmn, ← sum_Ico_succ_sub_top _ (Nat.le_pred_of_lt hmn),
      Nat.sub_add_cancel (pos_of_gt hmn), sub_add_cancel]
simp
rw [not_mem_support_iff.1 H, h0]
dsimp [Finsupp.prod]
rw [f.support.prod_ite_eq]
dsimp [Finsupp.prod]
rw [f.support.prod_ite_eq']
simp (config := { contextual := true }) [*]
rw [Finsupp.prod, Finsupp.prod, ← Finset.mul_prod_erase _ _ hyf, Finsupp.support_erase,
    Finset.prod_congr rfl]
intro h hx
rw [Finsupp.erase_ne (ne_of_mem_erase hx)]
rw [Multiset.sum_cons, single_add, ih, Multiset.map_cons, Multiset.sum_cons]
apply h_add x hx
simp [single]
simp [single]
rw [lift_add_hom_symm_apply, AddMonoidHom.comp_assoc, lift_add_hom_comp_single]
rw [prod_insert has, ih, sum_insert has, prod_add_index' h_zero h_add]
rw [Multiset.sum_cons, Multiset.map_cons, Multiset.sum_cons, sum_add_index' h₀ h₁, ih]
apply Finset.induction_on s
· simp
· intro i s hi
    simp only [hi, sum_insert, not_false_iff, bUnion_insert]
    intro hs
    rw [Finsupp.support_add_eq, hs]
    rw [hs, Finset.disjoint_bUnion_right]
    intro j hj
    refine' h _ _ (ne_of_mem_of_not_mem hj hi).symm
simp only [not_mem_support_iff.mp (disjoint_left.mp hd hx), add_zero]
simp only [Finsupp.prod, Finsupp.prod_mul]
rw [← sdiff_union_of_subset h1, prod_union sdiff_disjoint]
apply dvd_mul_of_dvd_right
apply prod_dvd_prod_of_dvd
exact h2
simp only [Finsupp.sum, Finset.sum_mul]
simp only [Finsupp.sum, Finset.mul_sum]
subst H
exact hf ha
simp [insert_none]
rw [map_some_erase_none]
refine' le_trans (Multiset.le_prod_nonempty_of_submultiplicative_on_pred f p h_mul hp_mul _ _ _) _
· simp [hs_nonempty.ne_empty]
· exact multiset.forall_mem_map_iff.mpr hs
rw [Multiset.map_map]
rfl
refine' le_trans (Multiset.le_prod_of_submultiplicative f h_one h_mul _) _
rw [Multiset.map_map]
rfl
rw [prod_const_one]
rw [prod_const_one]
rw [sdiff_union_of_subset h]
rw [abs_of_nonneg (Finset.sum_nonneg hf)]
rw [abs_of_nonneg (Finset.sum_nonneg' hf)]
simp [mul_comm]
simp [mul_comm]
rw [← card_eq_sum_card_fiberwise Hf]
rw [card_bUnion hs, card_eq_sum_ones]
exact sum_le_sum fun i hi => (hf i hi).card_pos
rw [← Finset.filter_card_add_filter_neg_card_eq_card fun i => f i = ∅, add_comm]
exact
    add_le_add_right
      (((card_le_card_bUnion (hs.subset <| filter_subset _ _)) fun i hi =>
            nonempty_of_ne_empty <| (mem_filter.1 hi).2).trans <|
        card_le_of_subset <| bUnion_subset_bUnion_of_subset_left _ <| filter_subset _ _)
      _
rw [← prod_union, filter_union_filter_neg_eq] <;>
          exact disjoint_filter.2 fun _ _ h n_h => n_h h
simp only [mem_filter, and_imp] <;> exact fun _ _ => le_of_eq
apply prod_le_prod_of_subset_of_one_le'
· simp [Finset.insert_subset, h, ht]
· intro x hx h'x
          simp only [mem_insert, not_or] at h'x
          exact hle x hx h'x.2
rw [prod_const_one]
rw [prod_const_one]
simp only [lt_top_iff_ne_top, Ne.def, sum_eq_top_iff, not_exists]
refine' fun x y xy => ab (_ : x * (b * a) = y * (b * a))
rw [← mul_assoc, ← mul_assoc]
exact congr_fun (congr_arg (· * ·) xy) a
rw [h]
exact is_regular_one.left
rw [h]
exact is_regular_one.right
rw [← smul_eq_mul] at ab
exact ab.of_smul _
rw [h]
exact one M
refine' ⟨_, pow n⟩
rw [← Nat.succ_pred_eq_of_pos n0, pow_succ', ← smul_eq_mul]
exact of_smul _
rw [h]
exact one M
simp only [IsLeftRegular, ← mul_left_iterate, rla.iterate n]
rw [IsRightRegular, ← mul_right_iterate]
exact rra.iterate n
refine' ⟨_, IsLeftRegular.pow n⟩
rw [← Nat.succ_pred_eq_of_pos n0, pow_succ']
exact IsLeftRegular.of_mul
refine' ⟨_, IsRightRegular.pow n⟩
rw [← Nat.succ_pred_eq_of_pos n0, pow_succ]
exact IsRightRegular.of_mul
simp [right_distrib]
rw [add_mul, one_mul]
rw [mul_add, mul_one]
rw [add_mul, one_mul]
rw [mul_add, mul_one]
simp
simp
simp
simp
simp only [← ite_and, ite_mul, mul_ite, mul_zero, zero_mul, and_comm']
simp only [two_mul, add_mul, mul_add, add_assoc, mul_comm b]
simp
simp
simp
simp
simp
rw [← zero_mul (0 : α), ← neg_mul, mul_zero, mul_zero]
rw [← right_distrib, add_left_neg, zero_mul]
rw [← left_distrib, add_left_neg, mul_zero]
simp [add_comm]
rw [h]
simp
rw [← h]
simp
simp [sub_mul, sub_add_eq_add_sub]
simp [sub_mul, sub_add_eq_add_sub]
rw [h]
simp [@add_sub_cancel α]
rw [sub_mul, one_mul]
rw [mul_sub, mul_one]
rw [sub_mul, one_mul]
rw [mul_sub, mul_one]
rw [← add_mul, zero_add, add_zero]
rw [← mul_add, add_zero, add_zero]
rw [← add_mul, zero_add, add_zero]
rw [← mul_add, add_zero, add_zero]
rw [IsIdempotentElem, mul_assoc, ← mul_assoc q, ← h.eq, mul_assoc p, h₂.eq, ← mul_assoc, h₁.eq]
rw [IsIdempotentElem, mul_sub, mul_one, sub_mul, one_mul, h.eq, sub_self, sub_zero]
rw [pow_succ, ih, h.eq]
refine'
    Iff.intro (fun h => or_iff_not_imp_left.mpr fun hp => _) fun h =>
      h.elim (fun hp => hp.symm ▸ zero) fun hp => hp.symm ▸ one
exact mul_left_cancel₀ hp (h.trans (mul_one p).symm)
simp only [SemiconjBy, left_distrib, right_distrib, h.eq, h'.eq]
simp only [SemiconjBy, left_distrib, right_distrib, ha.eq, hb.eq]
simp only [SemiconjBy, h.eq, neg_mul, mul_neg]
simp only [SemiconjBy, h.eq, neg_mul, mul_neg]
cases e
cases f
congr
rw [← e.map_mul, hxy, e.map_zero]
rw [← RingHom.comp_apply, comp_eq]
simp
rw [← RingHom.comp_apply, comp_eq₂]
simp
simp only [comp_eq]
simp only [comp_eq₂]
rw [mul_self]
rw [add_mul, mul_add]
rw [mul_self]
rw [add_zero]
rw [← neg_add_self, add_assoc]
rw [add_self, zero_add]
rw [neg_eq]
rw [mul_self]
rw [add_mul, mul_add, mul_add]
simp only [mul_self]
rw [sub_eq_add_neg, add_right_inj, neg_eq]
rw [mul_add, mul_one, mul_self, add_self]
rw [← add_eq_zero, mul_add_mul]
simp only [mul_self, add_self, add_zero]
rw [zero_mul, zero_add, add_zero]
simp only [mul_self, add_self, add_zero]
rw [symmDiff_eq_sup_sdiff_inf]
exact of_boolalg_symm_diff_aux _ _
simp [left_distrib, hd, he]
simp [hc]
simp [hc]
rw [sub_eq_add_neg]
exact dvd_add h₁ (dvd_neg_of_dvd h₂)
rw [add_comm] <;> exact dvd_add_iff_left h
rw [add_mul, mul_sub, mul_sub, h.eq, sub_add_sub_cancel]
rw [mul_add, sub_mul, sub_mul, h.eq, sub_add_sub_cancel]
rw [← sub_eq_zero, h.mul_self_sub_mul_self_eq, mul_eq_zero, or_comm', sub_eq_zero,
    add_eq_zero_iff_eq_neg]
rw [← (Commute.one_right a).mul_self_sub_mul_self_eq, mul_one]
rw [← (Commute.one_right a).mul_self_eq_mul_self_iff, mul_one]
rw [eq_comm, eq_inv_iff_mul_eq_one, neg_mul, mul_neg, neg_neg, mul_left_inv]
simp [mul_sub, mul_comm]
simp
rw [this]
simp [h]
refine' ⟨fun x y h => _⟩
refine' ⟨fun x y h => _⟩
rw [← sub_eq_zero, ← mul_sub] at h
exact sub_eq_zero.1 ((eq_zero_or_eq_zero_of_mul_eq_zero h).resolve_left ha)
rw [← sub_eq_zero, ← sub_mul] at h
exact sub_eq_zero.1 ((eq_zero_or_eq_zero_of_mul_eq_zero h).resolve_right hb)
simp
simp
simp only [divp, neg_mul]
simp only [divp, add_mul]
rw [sub_eq_add_neg, sub_eq_add_neg, neg_divp, divp_add_divp_same]
simp only [divp, add_mul, Units.mul_inv_cancel_right]
simp only [divp, sub_mul, Units.mul_inv_cancel_right]
simp only [divp, add_mul, Units.mul_inv_cancel_right]
simp only [prod_apply, coe_fst, coe_snd, comp_apply, Prod.mk.eta]
simp only [prod_apply, coe_fst, coe_snd, comp_apply, Prod.mk.eta]
simp
simp
cases x <;> simp
simp
simp
cases x <;> simp
simp
simp only [*, left_distrib]
simp only [*, right_distrib]
simp only [← add, ← mul, left_distrib]
simp only [← add, ← mul, right_distrib]
erw [neg, mul, neg, neg_mul, mul]
erw [neg, mul, neg, mul_neg, mul]
erw [← neg, ← mul, neg_mul, neg, mul]
rfl
erw [← neg, ← mul, mul_neg, neg, mul]
rfl
refine' fun x y (h' : k * x = k * y) => sub_eq_zero.mp (h _ _)
rw [mul_sub, sub_eq_zero, h']
refine' fun x y (h' : x * k = y * k) => sub_eq_zero.mp (h _ _)
rw [sub_mul, sub_eq_zero, h']
infer_instance
infer_instance
simp only [div_eq_mul_inv, csupr_mul hf]
simp only [mul_sum, ← pow_succ, sum_range_succ', pow_zero]
simp [geom_sum_succ']
simp [geom_sum_succ']
simp
simp
rw [geom_sum_succ']
simp [zero_geom_sum]
simp
simp
simp only [op_sum, op_mul, op_pow]
rw [← sum_range_reflect]
refine' sum_congr rfl fun j j_in => _
rw [mem_range, Nat.lt_iff_add_one_le] at j_in
congr
apply tsub_tsub_cancel_of_le
exact le_tsub_of_add_le_right j_in
rw [one_pow, mul_one]
dsimp [f]
rw [← tsub_add_eq_tsub_tsub, Nat.add_comm, tsub_self, pow_zero, mul_one]
dsimp [f]
have : Commute y ((x + y) ^ i) := (h.symm.add_right (Commute.refl y)).pow_right i
rw [← mul_assoc, this.eq, mul_assoc, ← pow_succ y (n - 1 - i)]
congr 2
rw [add_tsub_cancel_right, ← tsub_add_eq_tsub_tsub, add_comm 1 i]
have : i + 1 + (n - (i + 1)) = n := add_tsub_cancel_of_le (mem_range.mp hi)
rw [add_comm (i + 1)] at this
rw [← this, add_tsub_cancel_right, add_comm i 1, ← add_assoc, add_tsub_cancel_right]
rw [Finset.card_range, nsmul_eq_mul]
have := (Commute.one_right x).geom_sum₂_mul_add n
rw [one_pow, geom_sum₂_with_one] at this
exact this
have := (h.sub_left (Commute.refl y)).geom_sum₂_mul_add n
rw [sub_add_cancel] at this
rw [← this, add_sub_cancel]
apply op_injective
simp only [op_mul, op_sub, op_geom_sum₂, op_pow]
exact (Commute.op h.symm).geom_sum₂_mul n
rw [← neg_sub (y ^ n), ← h.mul_neg_geom_sum₂, ← neg_mul, neg_sub]
have := (Commute.one_right x).geom_sum₂_mul n
rw [one_pow, geom_sum₂_with_one] at this
exact this
have := congr_arg Neg.neg (geom_sum_mul x n)
rw [neg_sub, ← mul_neg, neg_sub] at this
exact this
simp_all [-sub_eq_add_neg, sub_eq_iff_eq_add]
simp_all [-sub_eq_add_neg, sub_eq_iff_eq_add]
refine' sum_congr rfl fun j j_in => _
rw [← pow_add]
congr
rw [mem_range, Nat.lt_iff_add_one_le, add_comm] at j_in
have h' : n - m + (m - (1 + j)) = n - (1 + j) := tsub_add_tsub_cancel hmn j_in
rw [← tsub_add_eq_tsub_tsub m, h', ← tsub_add_eq_tsub_tsub]
rw [this]
refine' sum_congr rfl fun k k_in => _
apply Commute.pow_pow (Commute.op h.symm)
rw [sum_Ico_eq_sub _ hmn, sub_mul, geom_sum_mul, geom_sum_mul, sub_sub_sub_cancel_right]
rw [sum_Ico_eq_sub _ hmn, sub_mul, geom_sum_mul_neg, geom_sum_mul_neg, sub_sub_sub_cancel_left]
simp_all [-sub_eq_add_neg, sub_eq_iff_eq_add]
simp only [sum_Ico_eq_sub _ hmn, geom_sum_eq hx, div_sub_div_same, sub_sub_sub_cancel_right]
simp
rw [pow_succ, mul_inv_rev, ← mul_assoc, h, mul_assoc, mul_inv_cancel hx0, mul_assoc,
        inv_mul_cancel hx0]
simp [f.map_sum]
simp [f.map_sum]
rw [tsub_mul, mul_comm, sum_mul, one_mul, sum_range_succ', sum_range_succ, pow_zero,
        Nat.div_one]
refine' tsub_le_tsub_right (add_le_add_right (sum_le_sum fun i _ => _) _) _
rw [pow_succ', ← Nat.div_div_eq_div_mul]
exact Nat.div_mul_le_self _ _
refine' (Nat.le_div_iff_mul_le <| tsub_pos_of_lt hb).2 _
cases n
· rw [sum_range_zero, zero_mul]
    exact Nat.zero_le _
rw [mul_comm]
exact (Nat.pred_mul_geom_sum_le a b n).trans tsub_le_self
rw [pow_zero, Nat.div_one]
rw [range_eq_Ico, ← Nat.Ico_insert_succ_left (Nat.succ_pos _), sum_insert]
exact fun h => zero_lt_one.not_le (mem_Ico.1 h).1
rw [← mul_add, add_tsub_cancel_of_le (one_le_two.trans hb)]
rw [mul_one, Nat.add_mul_div_right _ _ (tsub_pos_of_lt hb), add_comm]
simp
refine' Nat.le_induction _ _ n (show 2 ≤ n from hn)
· rw [geom_sum_two]
    exact ⟨hx', (add_lt_iff_neg_right _).2 hx⟩
clear hn n
intro n hn ihn
rw [geom_sum_succ, add_lt_iff_neg_right, ← neg_lt_iff_pos_add', neg_mul_eq_neg_mul]
exact
    ⟨mul_lt_one_of_nonneg_of_lt_one_left (neg_nonneg.2 hx.le) (neg_lt_iff_pos_add'.2 hx') ihn.2.le,
      mul_neg_of_neg_of_pos hx ihn.1⟩
have hx0 : x < 0 := ((le_add_iff_nonneg_right _).2 zero_le_one).trans_lt hx
refine' Nat.le_induction _ _ n (show 2 ≤ n from hn)
· simp only [geom_sum_two, hx, true_or_iff, even_bit0, if_true_left_eq_or]
clear hn n
intro n hn ihn
simp only [Nat.even_add_one, geom_sum_succ]
simp only [Nat.succ_ne_zero, Ne.def, not_false_iff]
decide
simp only [h, hn, neg_one_geom_sum, if_true]
rw [← not_iff_not, not_lt, le_iff_lt_or_eq, eq_comm,
    or_congr (geom_sum_pos_iff hn) (geom_sum_eq_zero_iff_neg_one hn), Nat.odd_iff_not_even, ←
    add_eq_zero_iff_eq_neg, not_and, not_lt, le_iff_lt_or_eq, eq_comm, ← imp_iff_not_or, or_comm',
    and_comm', Decidable.and_or_imp, or_comm']
intros
rfl
intros
rfl
rw [hxz, mul_one]
rw [← mul_assoc, hf.mul_comm y x]
rw [hxy, one_mul]
rw [← div_self h, add_div]
rw [← div_self h, add_div]
rw [mul_add, one_div_mul_cancel ha, add_mul, one_mul, mul_assoc, mul_one_div_cancel hb, mul_one,
    add_comm]
rw [right_distrib, div_mul_cancel _ hc]
rw [add_div, mul_div_cancel _ hc]
rw [neg_mul_neg, one_mul]
rw [neg_eq_neg_one_mul]
rw [one_div_mul_one_div_rev]
rw [one_div_neg_one_eq_neg_one]
rw [mul_neg, mul_one]
rw [← inv_eq_one_div, division_def]
rw [one_div_neg_eq_neg_one_div]
rw [neg_mul_eq_mul_neg]
rw [mul_one_div]
rw [neg_eq_neg_one_mul, mul_div_assoc, ← neg_eq_neg_one_mul]
simp [neg_div]
rw [div_neg_eq_neg_div, neg_div, neg_neg]
rw [inv_eq_one_div, inv_eq_one_div, div_neg_eq_neg_div]
rw [← div_neg_eq_neg_div]
rw [neg_inv]
rw [div_neg_eq_neg_div, div_self h]
rw [neg_div, div_self h]
rw [sub_eq_add_neg, ← neg_div, div_add_div_same, sub_eq_add_neg]
rw [mul_sub, sub_mul, mul_inv_cancel_right₀ hb, inv_mul_cancel ha, one_mul]
rw [mul_sub_left_distrib (1 / a), one_div_mul_cancel ha, mul_sub_right_distrib, one_mul,
    mul_assoc, mul_one_div_cancel hb, mul_one]
rw [← mul_div_mul_right _ b hd, ← mul_div_mul_left c d hb, div_add_div_same]
rw [div_add_div _ _ ha hb, one_mul, mul_one, add_comm]
rw [inv_eq_one_div, inv_eq_one_div, one_div_add_one_div ha hb]
simp [sub_eq_add_neg]
rw [neg_eq_neg_one_mul, ← mul_div_assoc, div_add_div _ _ hb hd, ← mul_assoc, mul_comm b,
    mul_assoc, ← neg_eq_neg_one_mul]
rw [inv_eq_one_div, inv_eq_one_div, div_sub_div _ _ ha hb, one_mul, mul_one]
erw [rat_cast, mul, inv, int_cast, nat_cast] <;> exact DivisionRing.ratCast_mk a b h1 h2
erw [qsmul, mul, Rat.smul_def, rat_cast]
erw [rat_cast, mul, inv, int_cast, nat_cast] <;> exact DivisionRing.ratCast_mk a b h1 h2
erw [qsmul, mul, Rat.smul_def, rat_cast]
rw [zpow_bit1', zpow_bit1', neg_mul_neg, neg_mul_eq_mul_neg]
rw [h.neg_zpow, one_zpow]
rw [SemiconjBy, mul_comm, ← Units.mul_inv_eq_iff_eq_mul, mul_assoc, c.mul_inv, mul_one] at hc
exact hc
rw [h]
rw [Units.coe_map, SemiconjBy, ← f.map_mul, hc.eq, f.map_mul]
rw [h]
induction i
· simp
· simp [zpow_negSucc, conj_pow]
rw [← Units.val_inv_eq_inv_val, Units.mul_inv_eq_iff_eq_mul]
exact ⟨c.ne_zero, hc⟩
rw [SemiconjBy, ← Units.mul_inv_eq_iff_eq_mul, Units.val_inv_eq_inv_val, Units.val_mk0]
exact hc
rw [Function.RightInverse, Function.LeftInverse, forall_is_conj]
intro x
rw [← quotient_mk_eq_mk, ← quotient_mk_eq_mk, Quotient.lift_mk, id.def]
revert b
rw [forall_is_conj]
intro b
rw [carrier, eq_comm, mk_eq_mk_iff_is_conj, ← quotient_mk_eq_mk, Quotient.lift_mk]
rfl
intros
rfl
intros
rfl
intros
rfl
intros
rfl
rw [← one_mul c, ← hba, mul_assoc, hac, mul_one b]
intros
rfl
intros
rfl
intros
rfl
intros
rfl
intros
rfl
intros
rfl
intros
rfl
intros
rfl
rw [← zpow_ofNat]
exact DivInvMonoid.zpow_neg' n a
rw [← mul_assoc, mul_left_inv, one_mul]
rw [← mul_assoc, mul_right_inv, one_mul]
rw [mul_assoc, mul_right_inv, mul_one]
rw [mul_assoc, mul_left_inv, mul_one]
rw [mul_assoc, mul_inv_cancel_left, mul_right_inv]
rw [← mul_inv_cancel_right a b, h, mul_inv_cancel_right]
rw [← inv_mul_cancel_left a b, h, inv_mul_cancel_left]
rw [SemiconjBy, mul_one, one_mul]
rw [Units.inv_mul_cancel_left]
rw [← h.eq, mul_assoc, Units.mul_inv_cancel_right]
rw [Units.mul_inv_cancel_right]
rw [← h.eq, ← mul_assoc, Units.inv_mul_cancel_left]
unfold SemiconjBy <;> rw [mul_assoc, inv_mul_self, mul_one]
rw [h, SemiconjBy, mul_comm]
unfold SemiconjBy <;> rw [Units.inv_mul_cancel_right]
delta IsConj SemiconjBy
infer_instance
simp only [mul_assoc, h.eq]
simp only [← mul_assoc, h.eq]
rw [← mul_assoc, hu, u.mul_inv]
have : Commute a u := hu ▸ (Commute.refl _).mul_right hc
rw [← this.units_inv_right.right_comm, ← hc.eq, hu, u.mul_inv]
rw [h.inv_left.eq, inv_mul_cancel_right]
rw [← mul_assoc, h.inv_mul_cancel]
rw [h.eq, mul_inv_cancel_right]
rw [← mul_assoc, h.mul_inv_cancel]
simp only [mul_left_comm, mul_assoc]
simp only [mul_left_comm, mul_comm]
simp only [mul_left_comm, mul_comm]
rw [add_comm, bit1_add, add_comm]
rw [bit1, bit0_zero, zero_add]
rw [mul_one]
rw [one_mul]
simp [h]
rw [div_eq_mul_inv, one_mul]
rw [div_eq_mul_inv, one_mul, div_eq_mul_inv]
rw [div_eq_mul_inv, div_eq_mul_inv, mul_assoc _ _ _]
simp only [mul_assoc, div_eq_mul_inv]
rw [div_eq_mul_inv, one_div]
simp [div_eq_mul_inv]
rw [← inv_eq_of_mul_eq_one_right h, inv_inv]
rw [eq_inv_of_mul_eq_one_left h, one_div]
rw [eq_inv_of_mul_eq_one_right h, one_div]
simp
simp
simp
simp
simp
rw [← one_div_one_div a, h, one_div_one_div]
simp
simp
simp only [mul_assoc, mul_inv_rev, div_eq_mul_inv]
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
rw [div_eq_mul_inv, mul_left_eq_self]
simp [h.symm]
simp [h.symm]
simp [h]
simp [h]
simp [h.symm]
simp [h.symm, mul_inv_cancel_left]
rw [h, mul_inv_cancel_left]
simp [h]
rw [h, mul_left_inv]
rw [mul_eq_one_iff_eq_inv, eq_inv_iff_eq_inv, eq_comm]
rw [h, inv_mul_cancel_right]
rw [← h, mul_inv_cancel_right]
rw [h, mul_inv_cancel_left]
rw [← h, inv_mul_cancel_left]
rw [← h, mul_inv_cancel_left]
rw [h, inv_mul_cancel_left]
rw [← h, inv_mul_cancel_right]
rw [h, mul_inv_cancel_right]
rw [mul_eq_one_iff_eq_inv, inv_inv]
rw [mul_eq_one_iff_eq_inv, inv_inj]
rw [div_eq_mul_inv, inv_mul_cancel_right a b]
rw [div_eq_mul_inv, mul_right_inv a]
rw [div_eq_mul_inv, mul_inv_cancel_right a b]
rw [div_mul_eq_div_div_swap] <;> simp only [mul_left_inj, eq_self_iff_true, mul_div_cancel'']
simp [← h]
simp [h]
simp [← h]
simp [h]
rw [div_eq_mul_inv, div_eq_mul_inv]
exact mul_left_inj _
rw [← mul_div_assoc, div_mul_cancel']
rw [← inv_div c b, div_inv_eq_mul, div_mul_div_cancel']
rw [h, div_self']
rw [div_eq_mul_inv, mul_right_eq_self, inv_eq_one]
rw [div_eq_mul_inv, eq_mul_inv_iff_mul_eq]
rw [div_eq_mul_inv, mul_inv_eq_iff_eq_mul]
rw [← div_eq_one, H, div_eq_one]
rw [h, div_eq_mul_inv, mul_comm, inv_mul_cancel_left]
simp
simp [h.symm]
simp [h.symm]
simp [h]
rw [mul_comm c, mul_inv_cancel_left]
simp [mul_left_comm c]
simp
rw [eq_div_iff_mul_eq', mul_comm]
rw [div_eq_iff_eq_mul, mul_comm]
rw [div_eq_inv_mul, inv_mul_cancel_left]
rw [← mul_div_assoc, mul_div_cancel''']
rw [← inv_div, mul_div_cancel''']
rw [← div_eq_mul_inv, mul_div_cancel'_right a b]
rw [mul_assoc, mul_div_cancel'_right]
rw [mul_left_comm, div_mul_cancel', mul_comm]
rw [mul_comm] <;> apply div_mul_div_cancel'
rw [← div_mul, mul_div_cancel''']
rw [← inv_div b c, div_inv_eq_mul, mul_comm, div_mul_div_cancel']
rw [div_eq_iff_eq_mul, div_mul_eq_mul_div, eq_comm, div_eq_iff_eq_mul']
simp only [mul_comm, eq_comm]
rw [div_eq_iff_eq_mul, div_mul_eq_mul_div, div_eq_iff_eq_mul', mul_div_assoc]
rw [mul_assoc, ← mul_assoc u₂.val, val_inv, one_mul, val_inv]
rw [mul_assoc, ← mul_assoc u₁.inv, inv_val, one_mul, inv_val]
rw [← Units.val_one, eq_iff]
rw [← h, u.inv_mul]
rw [← h, u.mul_inv]
rw [← mul_assoc, mul_inv, one_mul]
rw [← mul_assoc, inv_mul, one_mul]
rw [mul_assoc, mul_inv, mul_one]
rw [mul_assoc, inv_mul, mul_one]
rw [h, inv_mul_cancel_right]
rw [← h, mul_inv_cancel_right]
rw [h, mul_inv_cancel_left]
rw [← h, inv_mul_cancel_left]
rw [← h, mul_inv_cancel_left]
rw [h, inv_mul_cancel_left]
rw [← h, inv_mul_cancel_right]
rw [h, mul_inv_cancel_right]
rw [one_mul]
rw [← h, mul_inv_cancel_right]
rw [mul_one]
rw [← h, inv_mul_cancel_left]
rw [← mul_inv_eq_one, inv_inv]
rw [← inv_mul_eq_one, inv_inv]
rw [h, u₂.mul_inv]
rw [Units.inv_mul, mul_one]
rw [Units.mul_inv, mul_one]
simp only [divp, mul_inv_rev, Units.val_mul, mul_assoc]
rw [divp_mul_cancel] <;> exact ⟨Eq.symm, Eq.symm⟩
rw [eq_comm, divp_eq_iff_mul_eq]
rw [divp_mul_cancel, one_mul]
rw [one_divp]
rw [one_div, one_divp]
rw [divp, division_def, Units.val_mul]
rw [divp_eq_iff_mul_eq, divp_mul_eq_mul_divp, divp_eq_iff_mul_eq]
rw [divp_mul_eq_mul_divp, divp_assoc', divp_divp_eq_divp_mul]
simp [isUnit_iff_exists_inv, mul_comm]
exists v * u
exists u
change ↑(h a).Unit
change ↑(h a).Unit
cases a <;> rfl
cases a <;> rfl
simp
contradiction
contradiction
cases n
show (((1 : ℕ) : α) : WithZero α) = 0 + 1
· rw [Nat.cast_one, coe_one, zero_add]
show (((n + 2 : ℕ) : α) : WithZero α) = ((n + 1 : ℕ) : α) + 1
· rw [Nat.cast_succ, coe_add, coe_one]
rw [one_mul]
exact (one_mul _).symm
rw [mul_one]
exact (mul_one _).symm
induction x using WithOne.cases_on <;> rfl
induction x using WithOne.cases_on <;> · simp
induction x using WithOne.cases_on <;> · simp
rw [mk_mul_mk, mul_one]
rw [mk_mul_mk, mul_one]
simp only [prod_apply, coe_fst, coe_snd, comp_apply, Prod.mk.eta]
simp
simp only [prod_apply, coe_fst, coe_snd, comp_apply, Prod.mk.eta]
simp [coprod_apply]
simp [coprod_apply]
simp [coprod_apply, inl_apply, inr_apply, ← map_mul]
simp
simp
simp
simp
simp [Units.map]
simp only [inv_one, eq_self_iff_true, Units.val_one, op_one, Prod.mk_eq_one, and_self_iff]
simp only [mul_inv_rev, op_mul, Units.val_mul, Prod.mk_mul_mk]
erw [mul, mul, mul, mul, mul_assoc]
erw [mul, mul, mul_comm]
erw [← mul, ← mul, H] <;> rfl
erw [← mul, ← mul, H] <;> rfl
erw [mul, one, one_mul]
erw [mul, one, mul_one]
erw [npow, one, pow_zero]
erw [npow, pow_succ, mul, npow]
erw [nat_cast, Nat.cast_zero, zero]
erw [nat_cast, Nat.cast_succ, add, one, nat_cast]
rw [inv, inv, inv_inv]
erw [zpow, zpow_zero, one]
erw [zpow, mul, zpow_ofNat, pow_succ, zpow, zpow_ofNat]
erw [zpow, zpow_negSucc, inv, zpow, zpow_ofNat]
erw [div, mul, inv, div_eq_mul_inv]
erw [inv, mul, mul_inv_rev, mul, inv, inv]
erw [← mul, h, one]
erw [mul, inv, mul_left_inv, one]
simp only [nat_cast, int_cast, Int.cast_ofNat]
erw [int_cast, neg, nat_cast, Int.cast_neg, Int.cast_ofNat]
simp only [← mul, mul_assoc]
erw [← mul, ← mul, mul_comm]
erw [← one, ← mul, one_mul]
erw [← one, ← mul, mul_one]
erw [← npow, pow_zero, ← one]
erw [← npow, pow_succ, ← npow, ← mul]
rw [← nat_cast, Nat.cast_zero, zero]
rfl
rw [← nat_cast, Nat.cast_succ, add, one, nat_cast]
rfl
erw [← inv, ← inv, inv_inv]
erw [← zpow, zpow_zero, ← one]
erw [← zpow, ← zpow, zpow_ofNat, zpow_ofNat, pow_succ, ← mul]
erw [← zpow, ← zpow, zpow_negSucc, zpow_ofNat, inv]
erw [← inv, ← mul, ← div, div_eq_mul_inv]
erw [← inv, ← mul, mul_left_inv, one] <;> rfl
rw [← int_cast, Int.cast_ofNat, nat_cast]
rw [← int_cast, Int.cast_neg, Int.cast_ofNat, neg, nat_cast]
rfl
rfl
rfl
simp
intro a b ha hb ab
rw [← hf.eq_iff, ← hf.eq_iff]
rw [← hf.eq_iff, map_mul, map_mul] at ab
exact u (finset.mem_preimage.mp ha) (finset.mem_preimage.mp hb) ab
simp
simp
rw [Int.cast_ofNat]
erw [unop_op, Int.cast_negSucc] <;> rfl
rw [unop_op, zpow_ofNat, zpow_ofNat, pow_succ', unop_mul, unop_op]
simp [div_eq_mul_inv]
simp only [SemiconjBy, ← op_mul, op_inj, eq_comm]
simp [(hf x y).Eq]
simp [(hf x y).Eq]
simp
simp
simp
simp (config := { contextual := true }) only [this, mem_support_iff, mul_zero, Ne.def,
          ite_eq_right_iff, eq_self_iff_true, imp_true_iff]
simp (config := { contextual := true }) only [this, sum_single_index, ite_eq_right_iff,
          eq_self_iff_true, imp_true_iff, zero_mul]
rw [of, MonoidHom.coe_mk, ← Finsupp.supported_eq_span_single, Finsupp.mem_supported]
rw [of, MonoidHom.coe_mk, ← Finsupp.supported_eq_span_single, Finsupp.mem_supported]
rw [of', ← Finsupp.supported_eq_span_single, Finsupp.mem_supported]
simp only [mul_def, sum_add_index, mul_add, mul_zero, single_zero, single_add,
        eq_self_iff_true, forall_true_iff, forall₃_true_iff, sum_add]
simp only [mul_def, sum_add_index, add_mul, zero_mul, single_zero, single_add,
        eq_self_iff_true, forall_true_iff, forall₃_true_iff, sum_zero, sum_add]
simp only [mul_def, sum_zero_index]
simp only [mul_def, sum_zero_index, sum_zero]
simp only [mul_def, sum_sum_index, sum_zero_index, sum_add_index, sum_single_index,
        single_zero, single_add, eq_self_iff_true, forall_true_iff, forall₃_true_iff, add_mul,
        mul_add, add_assoc, mul_assoc, zero_mul, mul_zero, sum_zero, sum_add]
simp [one_def]
simp [Nat.cast]
simp [Nat.cast] <;> rfl
simp only [mul_def, one_def, sum_single_index, zero_mul, single_zero, sum_zero, zero_add,
        one_mul, sum_single]
simp only [mul_def, one_def, sum_single_index, mul_zero, single_zero, sum_zero, add_zero,
        mul_one, sum_single]
simp only [mul_def, Finsupp.sum, mul_comm]
rw [Finset.sum_comm]
simp only [mul_comm]
rw [mul_def]
simp only [Finsupp.sum_apply, single_apply]
simp only [mem_filter, mem_support_iff, not_and, not_not] at hp⊢
simp only [zero_mul, single_zero, sum_zero]
rw [mul_zero, single_zero]
simp only [pow_zero]
rfl
simp only [pow_succ, single_pow n, single_mul_single]
simp only [mul_def, mul_one, sum_single_index, single_eq_zero, mul_zero]
simp
simp
simp only [mul_apply, A, H]
rw [mul_one]
simp
simp only [H]
rw [one_mul]
let g : G → k → A := fun m t => t
intros
exact zero_smul k (f m)
intros
rw [← add_smul]
rw [single_add_hom, single_mul_single, one_mul]
rw [← one_mul a, ← mul_one b, ← single_mul_single, f.coe_add_monoid_hom, g.coe_add_monoid_hom,
        f.map_mul, g.map_mul, h₁, h_of]
simp
simp
simp [lift_nc_ring_hom]
simp only [lift_apply', Algebra.smul_def]
rw [of_apply, ← lift_symm_apply, Equiv.symm_apply_apply]
rw [lift_def, lift_nc_single, Algebra.smul_def, [anonymous]]
simp only [coe_algebra_map, map_domain_single, map_one]
simp
apply Finsupp.induction c
· simp
· intro g r c' nm nz w
      dsimp at *
      simp only [add_smul, f.map_add, w, add_left_inj, single_eq_algebra_map_mul_of, ← smul_smul]
      erw [algebra_map_smul (MonoidAlgebra k G) r, algebra_map_smul (MonoidAlgebra k G) r,
        f.map_smul, h g v, of_apply]
      all_goals infer_instance
rw [prod_cons has, ih, single_mul_single, prod_cons has, prod_cons has]
rw [← Finsupp.sum_apply, ← Finsupp.sum_mul, f.sum_single]
simp only [single_mul_apply, Finsupp.sum]
rw [← Finsupp.sum_apply, ← Finsupp.mul_sum, g.sum_single]
simp only [mul_single_apply, Finsupp.sum]
simp
simp
simp only [mul_def, sum_add_index, mul_add, mul_zero, single_zero, single_add,
        eq_self_iff_true, forall_true_iff, forall₃_true_iff, sum_add]
simp only [mul_def, sum_add_index, add_mul, mul_zero, zero_mul, single_zero, single_add,
        eq_self_iff_true, forall_true_iff, forall₃_true_iff, sum_zero, sum_add]
simp only [mul_def, sum_zero_index]
simp only [mul_def, sum_zero_index, sum_zero]
simp only [mul_def, sum_sum_index, sum_zero_index, sum_add_index, sum_single_index,
        single_zero, single_add, eq_self_iff_true, forall_true_iff, forall₃_true_iff, add_mul,
        mul_add, add_assoc, mul_assoc, zero_mul, mul_zero, sum_zero, sum_add]
simp [Nat.cast]
simp [Nat.cast] <;> rfl
simp only [mul_def, one_def, sum_single_index, zero_mul, single_zero, sum_zero, zero_add,
        one_mul, sum_single]
simp only [mul_def, one_def, sum_single_index, mul_zero, single_zero, sum_zero, add_zero,
        mul_one, sum_single]
simp only [pow_zero, zero_nsmul]
rfl
rw [pow_succ, pow_succ, single_pow n, single_mul_single, add_comm, add_nsmul, one_nsmul]
rw [add_zero]
rw [zero_add]
rw [single_add_hom, single_mul_single, zero_add]
simp
simp
simp [lift_nc_ring_hom]
simp only [lift_apply', Algebra.smul_def]
rw [of_apply, ← lift_symm_apply, Equiv.symm_apply_apply]
rw [lift_def, lift_nc_single, Algebra.smul_def, [anonymous]]
rw [prod_cons has, ih, single_mul_single, sum_cons has, prod_cons has]
simp only [Function.comp_apply, map_domain_single, AddMonoidAlgebra.coe_algebra_map, map_zero]
simp [AddMonoidAlgebra.toMultiplicative]
simp [MonoidAlgebra.toAdditive]
rfl
rfl
rw [← Finset.coe_subset, Finset.coe_singleton]
rfl
rw [mem_grade_iff, Finsupp.support_subset_singleton']
apply exists_congr
intro r
constructor <;> exact Eq.symm
intro x hx
rw [finset.mem_singleton.mp (Finsupp.support_single_subset hx)]
rw [one_def] at h
apply grade_
rw [one_mul, toAdd_mul]
refine' (lift_single _ _ _).trans _
refine' (DirectSum.of_smul _ _ _ _).symm.trans _
apply DirectSum.of_eq_of_graded_monoid_eq
refine' Sigma.subtype_ext rfl _
refine' (Finsupp.smul_single' _ _ _).trans _
rw [mul_one]
rfl
infer_instance
infer_instance
rw [List.prod_cons, List.map_cons, List.sum_cons]
exact (sup_support_mul_le degbm _ _).trans (add_le_add_left (sup_support_list_prod_le _) _)
rw [← List.prod_repeat, ← List.sum_repeat]
refine' (sup_support_list_prod_le degb0 degbm _).trans_eq _
rw [List.map_repeat]
induction m using Quot.induction_on
rw [Multiset.quot_mk_to_coe'', Multiset.coe_map, Multiset.coe_sum, Multiset.coe_prod]
exact sup_support_list_prod_le degb0 degbm m
rw [Multiset.map_map] <;> rfl
simp [not_mem_support_iff.mp af0]
simp [not_mem_support_iff.mp bf0]
rw [one_mul]
rw [mul_one]
rw [support_mul_single] <;> simp [support_nonempty_iff.mpr fg.1]
rw [mul_one]
rw [mul_one]
rw [support_single_mul] <;> simp [support_nonempty_iff.mpr fg.2]
rw [one_mul]
rw [one_mul]
simp_all
simp only [hg c, h (g x), AddHom.map_add, comp_app]
simp_all
simp_all
simp_all
intro x
simp_all [← add_assoc]
let h := h2.neg
simp_all [sub_eq_add_neg, add_comm c₁, ← add_assoc]
induction n <;> simp_all [Nat.succ_eq_add_one, add_nsmul, ← add_assoc, zero_nsmul]
rw [add_zero]
simp [two_mul, ← add_assoc, h _]
rw [← add_assoc, h, h.periodic.nat_mul]
rw [← add_assoc, h, h.periodic.int_mul]
rw [mul_left_comm, ← mul_assoc]
simp only [eq_neg_iff_eq_neg.mp (h (x - c)), sub_add_cancel]
simp_all
simp_all [← add_assoc]
let h := h2.neg
simp_all [sub_eq_add_neg, add_comm c₁, ← add_assoc]
simp_all [← add_assoc]
let h := h2.neg
simp_all [sub_eq_add_neg, add_comm c₁, ← add_assoc]
simp_all
simp_all [neg_div_neg_eq]
change algebraMap _ _ _ = _
simp
change algebraMap _ _ _ = _
simp
rw [← lift_symm_apply]
exact (lift R).apply_symm_apply g
rw [← lift_symm_apply, ← lift_symm_apply] at w
exact (lift R).symm.Injective w
apply MonoidAlgebra.alg_hom_ext
intro x
apply FreeMonoid.recOn x
· simp
        rfl
· intro x y ih
        simp at ih
        simp [ih]
simp [algebra_map_inv]
simp only [is_prime_pow_def, not_exists, not_and', and_imp]
intro x n hn hx
rw [pow_eq_zero hx]
simp
simp
rw [pow_mul', hn]
simp only [is_prime_pow_def, Nat.prime_iff]
rw [add_comm _ b, add_comm _ c]
exact h.add_right _
rw [← smul_one_smul R t a, ← smul_one_smul R t b]
exact h.smul _
induction h
case lie_self a' => simp only [lift_aux_map_mul, NonUnitalAlgHom.map_zero, lie_self]
case leibniz_lie a' b' c' =>
    simp only [lift_aux_map_mul, lift_aux_map_add, sub_add_cancel, lie_lie]
case smul t a' b' h₁ h₂ => simp only [lift_aux_map_smul, h₂]
case add_right a' b' c' h₁ h₂ => simp only [lift_aux_map_add, h₂]
case mul_left a' b' c' h₁ h₂ => simp only [lift_aux_map_mul, h₂]
case mul_right a' b' c' h₁ h₂ => simp only [lift_aux_map_mul, h₂]
rw [← Function.comp_apply (lift R f) (of R) x, of_comp_lift]
rw [← lift_symm_apply]
exact (lift R).apply_symm_apply F
rw [← sub_eq_zero, ← sl_bracket, c.trivial]
rfl
erw [mem_skew_adjoint_matrices_submodule]
simp only [Matrix.IsSkewAdjoint, Matrix.IsAdjointPair, Matrix.mul_one, Matrix.one_mul]
erw [LieEquiv.trans_apply, LieEquiv.of_eq_apply, skew_adjoint_matrices_lie_subalgebra_equiv_apply]
rw [← Matrix.diagonal_one, Matrix.diagonal_neg, Matrix.from_blocks_diagonal]
rfl
simp [PD, JD, Matrix.from_blocks_transpose, Matrix.from_blocks_multiply]
rw [← smul_add, ← two_smul R _, smul_smul, invOf_mul_self, one_smul]
infer_instance
rw [PB, Matrix.mul_eq_mul, Matrix.from_blocks_multiply, Matrix.mul_inv_of_self]
simp only [Matrix.mul_zero, Matrix.mul_one, Matrix.zero_mul, zero_add, add_zero,
    Matrix.from_blocks_one]
simp [PB, JB, JD_transform, Matrix.from_blocks_transpose, Matrix.from_blocks_multiply,
    Matrix.from_blocks_smul]
infer_instance
apply h.trivial
simp only [LieModule.ker, LieHom.mem_ker, LinearMap.ext_iff, LinearMap.zero_apply,
    to_endomorphism_apply_apply]
rw [lie_add, hx, hy, add_zero]
rw [lie_smul, hx, smul_zero]
rw [hm, lie_zero]
simp
rw [f.property x, LinearMap.zero_apply]
simp
simp
apply h.trivial
rw [lie_add]
exact N.add_mem' (hm₁ x) (hm₂ x)
simp
rw [lie_smul]
exact N.smul_mem' t (hm x)
intro m hm
rw [mem_centralizer]
exact fun x => N.lie_mem hm
intro N₁ N₂ h m hm
rw [mem_centralizer] at hm⊢
exact fun x => h (hm x)
rw [coe_bracket_of_module, mem_to_lie_submodule, leibniz_lie, ← lie_skew y, ← sub_eq_add_neg]
exact H.sub_mem (hz ⟨_, hy x⟩) (hy ⟨_, hz x⟩)
rw [Subtype.forall']
rfl
rw [mem_normalizer_iff']
refine' forall₂_congr fun y hy => _
rw [← lie_skew, neg_mem_iff]
rw [← lie_skew, neg_mem_iff]
exact hx ⟨y, hy⟩
rw [exists_nested_lie_ideal_coe_eq_iff]
exact fun x y hx hy => ideal_in_normalizer (h₂ hx) hy
cases N <;> cases O <;> congr
rw [(Submodule.mem_bot R).1 h]
apply lie_zero
cases p
rfl
cases x
cases y
congr
injection h
intro x y m
apply SetCoe.ext
apply add_lie
intro x m n
apply SetCoe.ext
apply lie_add
intro x y m
apply SetCoe.ext
apply leibniz_lie
intro t x y
apply SetCoe.ext
apply lie_smul
intro t x y
apply SetCoe.ext
apply smul_lie
rw [← lie_skew, ← neg_lie]
apply lie_mem_right
assumption
intro x y hx hy
apply lie_mem_right
exact hy
simp only [← coe_to_submodule_eq_iff, LieIdeal.coe_to_lie_subalgebra_to_submodule,
    Submodule.exists_lie_submodule_coe_eq_iff L]
exact Iff.rfl
simp only [Submodule.mem_carrier, mem_Inter, Submodule.Inf_coe, mem_set_of_eq,
          forall_apply_eq_imp_iff₂, exists_imp] at *
intro N hN
apply N.lie_mem (h N hN)
intros
rfl
rw [mem_bot] at h
rw [h]
exact N.zero_mem'
rw [← mem_coe_submodule, ← mem_coe_submodule, ← mem_coe_submodule, inf_coe_to_submodule,
    Submodule.mem_inf]
rw [← mem_coe_submodule, sup_coe_to_submodule, Submodule.mem_sup]
exact Iff.rfl
rw [eq_bot_iff]
exact Iff.rfl
simp only [← coe_submodule_le_coe_submodule, sup_coe_to_submodule, inf_coe_to_submodule]
exact IsModularLattice.sup_inf_le_assoc_of_le ↑N₂
rw [← subsingleton_iff_bot_eq_top, ← subsingleton_iff_bot_eq_top, ← coe_to_submodule_eq_iff,
      top_coe_submodule, bot_coe_submodule]
simp only [hom_of_le_apply, imp_self, Subtype.mk_eq_mk, SetLike.coe_eq_coe, Subtype.val_eq_coe]
change x ∈ (lie_span R L s : Set M) ↔ _
erw [Inf_coe]
exact mem_Inter₂
intro m hm
erw [mem_lie_span]
intro N hN
exact hN hm
rw [Submodule.span_le]
apply subset_lie_span
constructor
· exact subset.trans subset_lie_span
· intro hs m hm
    rw [mem_lie_span] at hm
    exact hm _ hs
rw [lie_span_le]
exact subset.trans h subset_lie_span
rw [p.exists_lie_submodule_coe_eq_iff L]
constructor <;> intro h
· intro x m hm
    rw [← h, mem_coe_submodule]
    exact lie_mem _ (subset_lie_span hm)
· rw [← coe_to_submodule_mk p h, coe_to_submodule, coe_to_submodule_eq_iff, lie_span_eq]
rw [_root_.eq_bot_iff, lie_span_le, bot_coe, subset_singleton_iff]
simp [this]
simp [this]
rw [SetLike.ext'_iff, LieSubmodule.coe_to_submodule, h, Submodule.map_coe]
rfl
rw [map_le]
exact Set.image_subset_iff
rw [map_le_iff_le_comap]
exact le_rfl
rw [← map_le_iff_le_comap]
exact le_rfl
rw [← SetLike.coe_subset_coe] at h⊢
exact Set.preimage_mono h
apply le_antisymm
· erw [LieSubmodule.lie_span_le, Submodule.map_coe, h]
· rw [← SetLike.coe_subset_coe, ← h]
    exact LieSubmodule.subset_lie_span
rw [f.ideal_range_eq_map]
exact LieIdeal.map_mono le_top
simp only [ker_coe_submodule, LinearMap.mem_ker, coe_to_linear_map]
rw [ideal_range_eq_map]
exact LieIdeal.mem_map (LieSubmodule.mem_top x)
rw [f.is_ideal_morphism_def] at h
rw [← LieSubmodule.mem_coe, ← LieIdeal.coe_to_subalgebra, h, f.range_coe, Set.mem_range]
constructor <;> intro h x hx
· specialize h hx
    rw [mem_ker] at h
    exact h
· rw [mem_ker]
    apply h x hx
rw [← LieSubmodule.coe_to_submodule_eq_iff, ker_coe_submodule, LieSubmodule.bot_coe_submodule,
    LinearMap.ker_eq_bot, coe_to_linear_map]
rw [← LieSubalgebra.coe_to_submodule_eq_iff, range_coe_submodule, LieSubalgebra.top_coe_submodule]
exact LinearMap.range_eq_top
rw [is_ideal_morphism_def, f.ideal_range_eq_top_of_surjective h, f.range_eq_top.mpr h,
    LieIdeal.top_coe_lie_subalgebra]
rw [← le_bot_iff]
exact LieIdeal.map_le_iff_le_comap
rw [← f.ker_eq_bot] at h₁
change comap f
simp only [hom_of_le_apply, imp_self, Subtype.mk_eq_mk, SetLike.coe_eq_coe, Subtype.val_eq_coe]
exact le_antisymm this (LieIdeal.map_mono le_sup_left)
rw [← LieSubmodule.coe_to_submodule_eq_iff, comap_coe_submodule, I.map_coe_submodule f h,
    LieSubmodule.sup_coe_to_submodule, f.ker_coe_submodule, Submodule.comap_map_eq]
rw [← LieSubmodule.coe_to_submodule_eq_iff, LieSubmodule.top_coe_submodule,
    LieIdeal.comap_coe_submodule, LieIdeal.incl_coe, Submodule.comap_subtype_self]
rw [← LieSubmodule.coe_to_submodule_eq_iff, I.incl.ker_coe_submodule,
    LieSubmodule.bot_coe_submodule, incl_coe, Submodule.ker_subtype]
rw [I.incl.is_ideal_morphism_def, incl_ideal_range]
exact (I : LieSubalgebra R L).incl_range.symm
rw [← LieSubmodule.coe_to_submodule_eq_iff, ker_coe_submodule, LieSubmodule.bot_coe_submodule,
    LinearMap.ker_eq_bot, coe_to_linear_map]
rw [ker, eq_bot_iff, LieSubmodule.map_le_iff_le_comap]
simp [← LieSubmodule.coe_to_submodule_eq_iff]
simp [← LieSubmodule.coe_to_submodule_eq_iff]
simp [← LieSubmodule.coe_to_submodule_eq_iff]
rfl
rfl
rw [LieHom.map_lie, LieRing.of_associative_ring_bracket, mul_comm, sub_self]
rw [LieModule.IsTrivial.trivial, LieRing.of_associative_ring_bracket, mul_comm, sub_self,
          LinearMap.to_fun_eq_coe, LinearMap.map_zero]
infer_instance
infer_instance
simp [pre_weight_space, -LinearMap.pow_apply]
simp only [hk₁, zero_tmul, LinearMap.rtensor_tmul, LinearMap.rtensor_pow]
simp only [hk₂, tmul_zero, LinearMap.ltensor_tmul, LinearMap.ltensor_pow]
  -- It's now just an application of the binomial theorem.
rw [this]
apply smul_zero
  -- Finish off with appropriate case analysis.
simp only [this, Submodule.mem_top]
rw [← LieSubmodule.coe_to_submodule_eq_iff, LieSubmodule.top_coe_submodule]
exact infi_max_gen_zero_eigenspace_eq_top_of_nilpotent R L M
rw [is_weight, LieHom.coe_zero, zero_weight_space_eq_top_of_nilpotent]
exact top_ne_bot
simp only [LieHom.coe_to_linear_map, LieSubalgebra.coe_incl, Function.comp_apply,
      LinearMap.coe_comp, Submodule.coe_eq_zero] at this
simp only [mem_weight_space, mem_pre_weight_space, LieSubalgebra.coe_incl',
      LieSubmodule.mem_comap, this]
simp only [LieSubmodule.coe_add, lie_add]
rfl
simp only [root_space_weight_space_product, root_space_weight_space_product_aux, lift_apply,
    LieModuleHom.coe_to_linear_map, coe_lift_lie_eq_lift_coe, Submodule.coe_mk, LinearMap.coe_mk,
    LieModuleHom.coe_mk]
simp only [root_space_product_def, coe_root_space_weight_space_product_tmul]
simp only [zero_root_subalgebra, mem_weight_space, mem_pre_weight_space, Pi.zero_apply, sub_zero,
    SetLike.mem_coe, zero_smul, LieSubmodule.mem_coe_submodule, Submodule.mem_carrier,
    LieSubalgebra.mem_mk_iff]
rw [← LieSubalgebra.coe_submodule_le_coe_submodule, ← H.coe_to_lie_submodule,
    coe_zero_root_subalgebra, LieSubmodule.coe_submodule_le_coe_submodule]
exact to_lie_submodule_le_root_space_zero R L H
rw [← h]
exact zero_root_subalgebra_normalizer_eq_self R L H
exact fun x hx => this hx
  obtain ⟨k, hk⟩
infer_instance
simp
intros
simp
rw [← LieSubmodule.mem_coe_submodule, ← coe_zero_root_subalgebra]
exact x.property
rw [AlgHom.map_mul] at this
simp [LieRing.of_associative_ring_bracket, ← this]
rw [← Function.comp_apply (lift R f) (ι R) x, ι_comp_lift]
rw [← LieSubmodule.coe_to_submodule_eq_iff, coe_centralizer_eq_normalizer,
    is_cartan_subalgebra.self_normalizing, coe_to_lie_submodule]
infer_instance
have hk' := hk (k + 1) k.le_succ
rw [LieSubmodule.ucs_succ, hk k (le_refl k)] at hk'
rw [← LieSubalgebra.coe_to_submodule_eq_iff, ←
            LieSubalgebra.coe_centralizer_eq_normalizer, hk', LieSubalgebra.coe_to_lie_submodule]
rw [← top_coe_lie_subalgebra, normalizer_eq_top, top_coe_lie_subalgebra]
simp [LieSubmodule.lie_le_right, LieSubmodule.lie_le_left, le_sup_of_le_right]
rw [eq_bot_iff]
exact derived_series_of_ideal_le_self
rw [derived_series_of_ideal_succ, derived_series_of_ideal_zero,
    LieSubmodule.lie_abelian_iff_lie_self_eq_bot]
rw [add_comm, derived_series_of_ideal_add I 1 k, abelian_iff_derived_one_eq_bot]
rw [derived_series_eq_derived_series_of_ideal_comap, map_comap_incl, inf_eq_right]
apply derived_series_of_ideal_le_self
rw [← derived_series_eq_derived_series_of_ideal_map, map_eq_bot_iff, ker_incl, eq_bot_iff]
rw [hI, hJ]
simp
constructor <;> intro h
· exact e.symm.injective.lie_algebra_is_solvable
· exact e.injective.lie_algebra_is_solvable
infer_instance
intro contra
apply h₂
rw [contra]
apply derived_series_of_bot_eq_bot
rw [(Submodule.mem_bot R).1 hx, zero_lie]
exact Submodule.zero_mem (0 : Submodule R L)
intros
apply SetCoe.ext
apply lie_add
intros
apply SetCoe.ext
apply add_lie
intros
apply SetCoe.ext
apply lie_self
intros
apply SetCoe.ext
apply leibniz_lie
intros
apply SetCoe.ext
apply lie_smul
cases p
rfl
rw [SetLike.ext'_iff] at h
rw [← coe_set_eq]
exact h
simp only [coe_bracket_of_module, smul_lie, Submodule.coe_smul_of_tower]
simp only [coe_bracket_of_module, lie_smul]
simp only [LinearMap.to_fun_eq_coe, Submodule.subtype_apply]
rfl
simp only [coe_bracket_of_module, LinearMap.to_fun_eq_coe, Submodule.subtype_apply,
        coe_bracket]
apply Subtype.ext
exact f.map_lie x y
simp only [Subtype.mk_eq_mk, range_restrict_apply] at hxy
exact h hxy
rw [← coe_to_submodule_eq_iff]
exact (K : Submodule R L).range_subtype
simp [this]
simp only [Submodule.mem_carrier, mem_Inter, Submodule.Inf_coe, mem_set_of_eq,
          forall_apply_eq_imp_iff₂, exists_imp] at *
intro K hK
exact K.lie_mem (hx K hK) (hy K hK)
intros
exact Iff.rfl
rw [mem_bot] at h
rw [h]
exact N.zero_mem'
rw [← mem_coe_submodule, ← mem_coe_submodule, ← mem_coe_submodule, inf_coe_to_submodule,
    Submodule.mem_inf]
rw [eq_bot_iff]
exact Iff.rfl
simp
simp only [hom_of_le_apply, imp_self, Subtype.mk_eq_mk, SetLike.coe_eq_coe, Subtype.val_eq_coe]
change x ∈ (lie_span R L s : Set L) ↔ _
erw [Inf_coe]
exact Set.mem_Inter₂
intro m hm
erw [mem_lie_span]
intro K hK
exact hK hm
rw [Submodule.span_le]
apply subset_lie_span
constructor
· exact Set.Subset.trans subset_lie_span
· intro hs m hm
    rw [mem_lie_span] at hm
    exact hm _ hs
rw [lie_span_le]
exact Set.Subset.trans h subset_lie_span
rw [p.exists_lie_subalgebra_coe_eq_iff]
constructor <;> intro h
· intro x m hm
    rw [← h, mem_coe_submodule]
    exact lie_mem _ (subset_lie_span hm)
· rw [← coe_to_submodule_mk p h, coe_to_submodule, coe_to_submodule_eq_iff, lie_span_eq]
apply SetCoe.ext
simp
rw [← h]
rfl
rw [← lie_add]
apply lie_self
  simpa [neg_eq_iff_add_eq_zero]
rw [← lie_skew, ← lie_skew x m, LieAlgebra.lie_smul, smul_neg]
apply LieAlgebra.lie_smul
rw [← sub_eq_zero, sub_neg_eq_add, ← add_lie]
simp
rw [← sub_eq_zero, sub_neg_eq_add, ← lie_add]
simp
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
rw [leibniz_lie, add_sub_cancel]
simp only [smul_sub, LinearMap.map_smul, lie_smul, RingHom.id_apply]
simp
rw [map_lie]
simp only [LieHom.map_add, add_lie]
simp only [lie_lie, sub_add_cancel, LieHom.map_lie]
simp only [smul_lie, LieHom.map_smul]
simp only [lie_smul]
simp only [sub_add_cancel, map_lie, LieHom.lie_apply]
simp
rw [h₂]
rw [map_lie]
simp
simp
simp
simp
simp
simp
simp [LinearEquiv.conj_apply, Matrix.lieConj, LinearMap.to_matrix'_comp,
    LinearMap.to_matrix'_to_lin']
simp [LinearEquiv.symm_conj_apply, Matrix.lieConj, LinearMap.to_matrix'_comp,
    LinearMap.to_matrix'_to_lin']
simp only [LieRing.of_associative_ring_bracket, Matrix.reindex_apply,
        Matrix.submatrix_mul_equiv, Matrix.mul_eq_mul, Matrix.submatrix_sub, Pi.sub_apply]
intro x y
apply Quotient.liftOn₂' x y fun x' y' => mk
simp [-lie_skew, sub_eq_add_neg, add_assoc]
intro x'
apply Quotient.inductionOn' x'
intro x
rw [is_quotient_mk, ← mk_bracket]
apply congr_arg
apply lie_self
rw [← LieModuleHom.le_ker_iff_map, mk'_ker]
rw [← neg_mul_neg g f]
exact hf.mul hg
rw [← neg_mul_neg f g]
exact hg.mul hf
simp [skewAdjointLieSubalgebraEquiv]
simp [skewAdjointLieSubalgebraEquiv]
simp
simp only [LieSubalgebra.mem_coe, Submodule.mem_map_equiv, LieSubalgebra.mem_map_submodule,
          coe_coe]
exact this
simp [skewAdjointMatricesLieSubalgebraEquiv]
simp only [component, lapply_apply, lie_module_bracket_apply, LinearMap.to_fun_eq_coe]
simp only [component, bracket_apply, lapply_apply, LinearMap.to_fun_eq_coe]
apply lie_algebra_ext R ι L
intro k
rw [LieHom.map_lie]
simp only [component, of, lapply_apply, single_add_hom_apply, lie_algebra_component_apply,
    single_apply, zero_apply]
simp only [Ring.lie_def, right_distrib, left_distrib, sub_eq_add_neg, add_comm, add_left_comm,
      forall_const, eq_self_iff_true, neg_add_rev]
simp only [Ring.lie_def, right_distrib, left_distrib, sub_eq_add_neg, add_comm, add_left_comm,
      forall_const, eq_self_iff_true, neg_add_rev]
simp only [Ring.lie_def, forall_const, sub_self]
simp [LieRing.of_associative_ring_bracket, sub_smul, mul_smul, sub_add_cancel]
rw [LieRing.of_associative_ring_bracket, LieRing.of_associative_ring_bracket,
      Algebra.mul_smul_comm, Algebra.smul_mul_assoc, smul_sub]
simp only [LieRing.of_associative_ring_bracket, AlgHom.map_sub, AlgHom.map_mul]
simp only [LieRing.of_associative_ring_bracket, LinearMap.mul_eq_comp, e.conj_comp,
          LinearEquiv.map_sub]
simp [LieRing.of_associative_ring_bracket]
simp
simp only [← coe_to_submodule_eq_iff, I.coe_lcs_eq, hk, bot_coe_submodule]
simp [this]
rw [← LieSubalgebra.coe_submodule_le_coe_submodule]
exact sup_le ((Submodule.span_singleton_le_iff_mem _ _).mpr hx₁) hK₂.le
rw [← is_nilpotent_of_top_iff]
apply this M
simp [LieSubalgebra.to_endomorphism_eq, h]
refine' hK₁ _ fun x => _
have hx := LieAlgebra.is_nilpotent_ad_of_is_nilpotent (h x)
exact Module.EndCat.IsNilpotent.mapq _ hx
exact le_antisymm (this I J) (this J I)
  clear I J
  intro I J
  rw [lie_ideal_oper_eq_span, lie_span_le]
  rintro x ⟨y, z, h⟩
  rw [← h]
  rw [← lie_skew, ← lie_neg, ← LieSubmodule.coe_neg]
  apply lie_coe_mem_lie
rw [lie_comm]
exact lie_le_right I J
rw [le_inf_iff]
exact ⟨lie_le_left I J, lie_le_right J I⟩
rw [eq_bot_iff]
apply lie_le_right
exact le_antisymm this h
  clear h
  rw [lie_ideal_oper_eq_span, lie_span_le]
  rintro m ⟨x, ⟨n, hn⟩, h⟩
  erw [LieSubmodule.mem_sup]
  erw [LieSubmodule.mem_sup]
exact le_antisymm this h
  clear h
  rw [lie_ideal_oper_eq_span, lie_span_le]
  rintro m ⟨⟨x, hx⟩, n, h⟩
  erw [LieSubmodule.mem_sup]
  erw [LieSubmodule.mem_sup]
simp
rw [SetLike.ext'_iff]
exact Set.image_preimage_eq_of_subset hf
rw [SetLike.ext'_iff]
exact (N : Set M).preimage_image_eq (f.ker_eq_bot.mp hf)
rw [← coe_to_submodule_eq_iff]
exact (N : Submodule R M).map_comap_subtype N'
exact le_antisymm (map_bracket_le f) this
  rw [← LieSubmodule.coe_submodule_le_coe_submodule, coe_map_of_surjective h,
    LieSubmodule.lie_ideal_oper_eq_linear_span, LieSubmodule.lie_ideal_oper_eq_linear_span,
    LinearMap.map_span]
  apply Submodule.span_mono
  rintro x ⟨⟨z₁, h₁⟩, ⟨z₂, h₂⟩, rfl⟩
  obtain ⟨y₁, rfl⟩
rw [← map_le_iff_le_comap]
exact le_trans (map_bracket_le f) (LieSubmodule.mono_lie _ _ _ _ map_comap_le map_comap_le)
rw [LieSubmodule.mem_inf]
exact ⟨f.mem_ideal_range, hz₁⟩
rw [LieSubmodule.mem_inf]
exact ⟨f.mem_ideal_range, hz₂⟩
rw [← map_sup_ker_eq_map, ← comap_bracket_eq h, map_comap_eq h, inf_eq_right]
exact le_trans (LieSubmodule.lie_le_left _ _) inf_le_left
rw [comap_bracket_incl]
rw [← inf_eq_right] at h₁ h₂
rw [h₁, h₂]
simp only [← LinearMap.add_apply]
rw [← LinearMap.comp_apply, this]
rfl
simp only [has_bracket_aux, LinearMap.rtensor_tmul, to_endomorphism_apply_apply,
      LinearMap.add_apply, LinearMap.ltensor_tmul]
rw [← this, LieModuleHom.coe_to_linear_map]
simp only [coe_lift_lie_eq_lift_coe, LieModuleHom.coe_to_linear_map, lift_apply]
simp only [LinearMap.to_fun_eq_coe]
apply t.induction_on
· simp only [LinearMap.map_zero, lie_zero]
· intro m n
        simp only [LieModuleHom.coe_to_linear_map, lie_tmul_right, LieModuleHom.map_lie, map_tmul,
          LinearMap.map_add]
· intro t₁ t₂ ht₁ ht₂
        simp only [ht₁, ht₂, lie_add, LinearMap.map_add]
simp only [to_module_hom, TensorProduct.LieModule.lift_lie_apply, to_endomorphism_apply_apply,
    LieHom.coe_to_linear_map, LieModuleHom.coe_mk, LinearMap.coe_mk, LinearMap.to_fun_eq_coe]
rw [is_semisimple_iff_no_abelian_ideals] at h
apply h
infer_instance
rw [is_lie_abelian_iff_center_eq_top R L, center_eq_bot_of_semisimple] at h
exact (LieSubmodule.subsingleton_iff R L L).mp (subsingleton_of_bot_eq_top h)
rw [is_semisimple.semisimple]
exact is_lie_abelian_bot R L
simp
simp [bracket']
rw [bracket_def, bracket'_tmul]
rw [LinearMap.map_add, LinearMap.map_add, LinearMap.add_apply, LinearMap.add_apply, h₁, h₂,
        zero_add, add_zero, add_comm, this]
simp only [bracket_def]
apply x.induction_on
· simp only [LinearMap.map_zero, add_zero, eq_self_iff_true, LinearMap.zero_apply]
· intro a₁ l₁
    apply y.induction_on
    · simp only [LinearMap.map_zero, add_zero, eq_self_iff_true, LinearMap.zero_apply]
    · intro a₂ l₂
      apply z.induction_on
      · simp only [LinearMap.map_zero, add_zero]
      · intro a₃ l₃
        simp only [bracket'_tmul]
        rw [mul_left_comm a₂ a₁ a₃, mul_assoc, leibniz_lie, TensorProduct.tmul_add]
      · intro u₁ u₂ h₁ h₂
        simp only [add_add_add_comm, h₁, h₂, LinearMap.map_add]
    · intro u₁ u₂ h₁ h₂
      simp only [add_add_add_comm, h₁, h₂, LinearMap.add_apply, LinearMap.map_add]
· intro u₁ u₂ h₁ h₂
    simp only [add_add_add_comm, h₁, h₂, LinearMap.add_apply, LinearMap.map_add]
simp only [bracket_def, LinearMap.add_apply, LinearMap.map_add]
simp only [bracket_def, LinearMap.map_add]
apply x.induction_on
· simp only [zero_lie, smul_zero]
· intro a₁ l₁
    apply y.induction_on
    · simp only [lie_zero, smul_zero]
    · intro a₂ l₂
      simp only [bracket_def, bracket', TensorProduct.smul_tmul', mul_left_comm a₁ a a₂,
        TensorProduct.curry_apply, LinearMap.mul'_apply, Algebra.id.smul_eq_mul,
        Function.comp_apply, LinearEquiv.coe_coe, LinearMap.coe_comp, TensorProduct.map_tmul,
        TensorProduct.tensor_tensor_tensor_comm_tmul]
    · intro z₁ z₂ h₁ h₂
      simp only [h₁, h₂, smul_add, lie_add]
· intro z₁ z₂ h₁ h₂
    simp only [h₁, h₂, smul_add, add_lie]
rw [N.range_incl]
apply lcs_le_self
rw [lower_central_series_eq_lcs_comap, LieSubmodule.map_comap_incl, inf_eq_right]
apply lcs_le_self
simp only [le_top]
rw [is_nilpotent_iff]
refine' exists_congr fun k => _
rw [N.lower_central_series_eq_lcs_comap k, LieSubmodule.comap_incl_eq_bot,
    inf_eq_right.mpr (N.lcs_le_self k)]
infer_instance
rw [LieSubmodule.nontrivial_iff_ne_bot, lower_central_series_last]
cases h : nilpotency_length R L M
· rw [nilpotency_length_eq_zero_iff, ← not_nontrivial_iff_subsingleton] at h
    contradiction
· rw [nilpotency_length_eq_succ_iff] at h
    exact h.2
rw [eq_top_iff, ← lcs_le_iff]
rfl
simp [ucs_eq_top_iff]
simp only [← LieSubmodule.mem_coe_submodule] at this
simp [← LieSubmodule.mem_coe_submodule, ← ih, LieSubmodule.lie_ideal_oper_eq_linear_span',
        Submodule.map_span, -Submodule.span_image, this]
infer_instance
exact LieModule.nilpotent_of_nilpotent_quotient R L L h₁ this
rw [← f.ideal_range_eq_map]
exact f.ideal_range_eq_top_of_surjective h
constructor <;> intro h
· exact e.symm.injective.lie_algebra_is_nilpotent
· exact e.injective.lie_algebra_is_nilpotent
simp
rw [IsCommJordan.mul_comm, IsCommJordan.mul_comm a b]
rw [IsCommJordan.mul_comm (a * a) (a * b), IsCommJordan.lmul_comm_rmul_rmul,
      IsCommJordan.mul_comm b (a * a)]
rw [IsCommJordan.mul_comm (a * a) (b * a), IsCommJordan.mul_comm b a,
      IsCommJordan.lmul_comm_rmul_rmul, IsCommJordan.mul_comm, IsCommJordan.mul_comm b (a * a)]
rw [IsCommJordan.mul_comm b a, IsCommJordan.lmul_comm_rmul_rmul, IsCommJordan.mul_comm]
rw [mul_assoc]
rw [mul_assoc, mul_assoc]
rw [mul_assoc]
rw [← mul_assoc]
rw [← mul_assoc, ← mul_assoc]
rw [(commute_lmul_lmul_sq (a + b + c)).lie_eq]
rw [add_mul, add_mul, mul_add, mul_add, mul_add, mul_add, mul_add, mul_add, map_add, map_add,
        map_add, map_add, map_add, map_add, map_add, map_add, map_add, map_add]
rw [IsCommJordan.mul_comm b a, IsCommJordan.mul_comm c a, IsCommJordan.mul_comm c b]
rw [add_lie, add_lie, lie_add, lie_add, lie_add, lie_add, lie_add, lie_add, lie_add, lie_add,
        lie_add, lie_add, lie_add, lie_add, lie_add, lie_add, lie_add]
rw [(commute_lmul_lmul_sq a).lie_eq, (commute_lmul_lmul_sq b).lie_eq,
        (commute_lmul_lmul_sq c).lie_eq, zero_add, add_zero, add_zero]
simp only [lie_nsmul]
rw [nsmul_add, nsmul_add]
cases f
cases g
congr
simp only [Algebra.smul_def, map_mul, commutes]
rw [← e.to_ring_equiv.symm_apply_apply (algebraMap R A₁ r)]
congr
change _ = e _
rw [e.commutes]
rw [e₁.commutes', e₂.commutes']
simp only [AlgHom.comp_assoc, to_alg_hom_eq_coe, symm_comp]
simp only [← AlgHom.comp_assoc, symm_comp, AlgHom.id_comp, AlgHom.comp_id]
simp only [AlgHom.comp_assoc, to_alg_hom_eq_coe, comp_symm]
simp only [← AlgHom.comp_assoc, comp_symm, AlgHom.id_comp, AlgHom.comp_id]
rw [algebra_map_apply R S A]
exact U.algebra_map_mem _
rw [← mem_restrict_scalars R, H, mem_restrict_scalars]
rw [this]
cases p <;> cases q <;> congr
rw [← mem_to_subsemiring, ← mem_to_subsemiring, h]
rw [← mem_to_subring, ← mem_to_subring, h]
apply SetLike.ext_iff.1 h
rw [Algebra.algebra_map_eq_smul_one, ← smul_one_smul R x (1 : A), ←
        Algebra.algebra_map_eq_smul_one]
exact algebra_map_mem S _
rw [Algebra.algebra_map_eq_smul_one]
exact p.smul_mem _ h_one
rw [Algebra.algebra_map_eq_smul_one]
exact hsmul r h1
rw [Set.mem_setOf_eq, ϕ.map_add, ψ.map_add, hx, hy]
rw [Set.mem_setOf_eq, ϕ.map_mul, ψ.map_mul, hx, hy]
rw [Set.mem_setOf_eq, AlgHom.commutes, AlgHom.commutes]
rw [← hx', h x']
simp only [← SetLike.mem_coe, coe_Inf, Set.mem_Inter₂]
simp
simp
simp [infi]
simp only [infi, mem_Inf, Set.forall_range_iff]
simp
rw [← this, ← SetLike.mem_coe, AlgHom.coe_range]
rfl
simp [Set.ext_iff, Algebra.mem_bot]
rw [h] <;> exact mem_top
simp only [← Set.range_comp, (· ∘ ·), Algebra.coe_bot, Subalgebra.coe_map, f.commutes]
simp only [Subsingleton.elim x 0, zero_mem B, zero_mem C]
rw [← f.symm_symm, Subsingleton.elim f.symm g.symm, g.symm_symm]
intro S
refine' le_antisymm (fun r hr => _) bot_le
simp only [Set.mem_range, mem_bot, id.map_eq_self, exists_apply_eq_apply, default]
let ⟨k, hik, hjk⟩ := dir i j
rw [hf i k hik, hf j k hjk]
rfl
rw [coe_supr_of_directed dir] <;> rfl
simp
simp
simp
simp
erw [AlgHom.commutes (f i)]
subst T <;> exact Set.Union_lift_inclusion _ _
subst hT <;> exact Set.Union_lift_mk x hx
subst hT <;> exact Set.Union_lift_of_mem x hx
rw [algebra_map_eq, Algebra.id.map_eq_id, RingHom.id_comp, ← to_subsemiring_subtype,
    Subsemiring.srange_subtype]
rw [algebra_map_eq, Algebra.id.map_eq_id, RingHom.id_comp, ← to_subring_subtype,
    Subring.range_subtype]
simp [Algebra.commutes, Set.mem_center_iff]
rw [Ideal.eq_top_iff_one, Ideal.span, Finsupp.mem_span_iff_total]
refine'
        ⟨(Finsupp.ofSupportFinite (fun i : ι' => (⟨l i, hl i⟩ : S')) (Set.to_finite _)).mapDomain
            fun i => ⟨s' i, i, i.2, rfl⟩,
          S'.to_submodule.injective_subtype _⟩
rw [Finsupp.total_map_domain, Finsupp.total_apply, Finsupp.sum_fintype, map_sum,
        Submodule.subtype_apply, Subalgebra.coe_one]
· exact finset.sum_attach.trans e
· exact fun _ => zero_smul _ _
rw [Int.cast_sub, Int.cast_one]
exact S.sub_mem ih S.one_mem
rw [Submodule.mul_le]
intro y hy z hz
show y * z ∈ S
apply le_antisymm
· refine' (mul_to_submodule_le _ _).trans_eq _
    rw [sup_idem]
· intro x hx1
    rw [← mul_one x]
    exact Submodule.mul_mem_mul hx1 (show (1 : A) ∈ S from one_mem S)
rw [algebra_map_eq_smul_one]
apply Submodule.ext
intro a
simp only [mem_one, mem_span_singleton, Algebra.smul_def, mul_one]
rw [← comap_equiv_eq_map_symm, comap_op_one]
rw [← map_equiv_eq_comap_symm, map_op_one]
rw [← mem_to_add_submonoid, mul_to_add_submonoid] at hr
exact AddSubmonoid.mul_induction_on hr hm ha
refine' Exists.elim _ fun (hr : r ∈ M * N) (hc : C r hr) => hc
exact
    Submodule.mul_induction_on hr (fun x hx y hy => ⟨_, hm _ hx _ hy⟩) fun x y ⟨_, hx⟩ ⟨_, hy⟩ =>
      ⟨_, ha _ _ _ _ hx hy⟩
rw [← map_comp, map_op_mul, ← map_comp, ← map_comp, LinearEquiv.comp_coe,
      LinearEquiv.symm_trans_self, LinearEquiv.refl_to_linear_map, map_id, map_id, map_id]
rw [pow_zero, pow_zero, one_eq_span_one_set]
rw [pow_succ, pow_succ, span_pow, span_mul_span]
rw [← span_pow, span_eq]
simp [comap_equiv_eq_map_symm, ← op_add]
rw [map_equiv_eq_comap_symm, map_equiv_eq_comap_symm, comap_unop_pow]
rw [← comap_equiv_eq_map_symm, ← comap_equiv_eq_map_symm, comap_op_pow]
erw [span_mul_span, ← image_mul_prod]
rw [prod_span, Set.finset_prod_singleton]
erw [span_union, right_distrib]
rw [← mul_assoc, span_mul_span, ← image_mul_prod]
erw [span_empty, bot_mul]
rw [zero_mul]
apply Submodule.zero_mem
rw [add_mul]
exact Submodule.add_mem _ (ha _ hy) (hb _ hy)
rw [Algebra.smul_mul_assoc]
exact Submodule.smul_mem _ _ (hx _ hy)
rw [← xy'_eq_y]
apply h
assumption
rw [le_div_iff, mul_le]
rw [← mul_one I]
apply mul_le_mul_right (one_le_one_div.mpr hI)
rw [Submodule.mul_le]
intro m hm n hn
rw [Submodule.mem_div_iff_forall_mul_mem] at hn
rw [mul_comm]
exact hn m hm
rw [Algebra.algebra_map_eq_smul_one, smul_assoc, one_smul]
rw [algebra_map_eq R S A, RingHom.comp_apply]
rw [algebra_map_apply R S A r, f.commutes, ← algebra_map_apply R S B]
rw [algebra_map_apply R S A, algebra_map_apply R S B]
exact f.commutes (algebraMap R S r)
rw [algebra_map_apply R S A, algebra_map_apply R S B]
exact f.commutes (algebraMap R S r)
rw [zero_smul]
exact zero_mem _
rw [add_smul]
exact add_mem ih₁ ih₂
rw [IsScalarTower.smul_assoc]
exact smul_mem _ _ hc
rw [smul_zero]
exact zero_mem _
rw [smul_add]
exact add_mem ihx ihy
let ⟨p, q, hp, hq, hpq⟩ := Set.mem_smul.1 hx
rw [← hpq, smul_smul]
exact smul_mem_span_smul_of_mem (hs.symm ▸ mem_top) hq
rw [smul_zero]
exact zero_mem _
rw [smul_add]
exact add_mem ihx ihy
rw [span_algebra_map_image_of_tower, mem_map]
exact ⟨x, hx, rfl⟩
rw [h₁, mul_smul]
simp only [h₁, h₂]
simp only [h₁]
rw [h₁, one_mul]
rw [h₂, mul_one]
simp [smul_def'']
simp [smul_def'', mul_assoc]
simp [smul_def'', mul_add]
simp [smul_def'']
simp [smul_def'', add_mul]
simp [smul_def'']
rw [← mul_assoc, ← commutes, mul_assoc]
rw [mul_assoc, commutes, ← mul_assoc]
rw [smul_eq_mul, smul_eq_mul, smul_def, smul_def, mul_assoc]
rw [smul_def, smul_def, left_comm]
rw [algebra_map_eq_smul_one, smul_comm a r (1 : A), smul_one]
simp [bit0, add_smul]
simp [bit0, add_smul, smul_add]
simp [bit0, add_smul, smul_add]
simp [bit0, add_smul, smul_add]
simp [bit1, add_smul]
simp [bit1, bit0, add_smul, smul_add]
simp [bit1, add_smul, smul_add]
simp [Algebra.smul_def]
rw [mul_sub, ← commutes, sub_mul]
dsimp
simp only [op_mul, Algebra.smul_def, Algebra.commutes, op_unop]
dsimp <;> simp only [← op_mul, Algebra.commutes]
simp
simp
rw [← Algebra.smul_def, ← Algebra.smul_def, map_smul]
rw [← Algebra.commutes, ← Algebra.commutes, map_algebra_map_mul]
rw [Algebra.smul_def, mul_one, eq_rat_cast]
rw [← one_smul A m, ← smul_assoc, Algebra.smul_def, mul_one, one_smul]
simp only [to_ring_hom_eq_coe, RingHom.toFun_eq_coe, RingHom.prod_apply, coe_to_ring_hom,
        commutes, Prod.algebra_map_apply]
simp only [smul_zero, add_zero, mul_zero]
simp only [zero_smul, zero_add]
rw [smul_zero, add_zero, zero_mul, add_zero]
rw [smul_zero, zero_add, mul_zero, add_zero]
rw [one_smul, smul_zero, add_zero, zero_mul, add_zero]
rw [smul_zero, zero_add, one_smul, mul_zero, add_zero]
rw [zero_smul, zero_add, smul_zero, zero_mul, add_zero]
rw [smul_zero, zero_add, zero_smul, mul_zero, add_zero]
simp only [snd_star, star_zero, snd_inl]
simp only [fst_star, star_zero, fst_coe]
simp
simp
simp [star_mul]
induction x using Unitization.ind
simp only [mul_add, add_mul, RingHom.toFun_eq_coe, RingHom.coe_comp, Function.comp_apply,
        inl_ring_hom_apply, inl_mul_inl]
rw [inl_mul_coe, coe_mul_inl, mul_comm]
induction x using Unitization.ind
simp only [mul_add, smul_add, RingHom.toFun_eq_coe, RingHom.coe_comp, Function.comp_apply,
        inl_ring_hom_apply, Algebra.algebra_map_eq_smul_one]
rw [inl_mul_inl, inl_mul_coe, smul_one_mul, inl_smul, coe_smul, smul_one_smul]
simp [AlgHom.commutes]
simp only [fst_one, map_one, snd_one, φ.map_zero, add_zero]
induction x using Unitization.ind
induction y using Unitization.ind
simp only [mul_add, add_mul, coe_mul, fst_add, fst_mul, fst_inl, fst_coe, mul_zero,
          add_zero, zero_mul, map_mul, snd_add, snd_mul, snd_inl, smul_zero, snd_coe, zero_add,
          φ.map_add, φ.map_smul, φ.map_mul, zero_smul, zero_add]
rw [← Algebra.commutes _ (φ x_a)]
simp only [Algebra.algebra_map_eq_smul_one, smul_one_mul, add_assoc]
simp only [fst_zero, map_zero, snd_zero, φ.map_zero, add_zero]
induction x using Unitization.ind
induction y using Unitization.ind
simp only [fst_add, fst_inl, fst_coe, add_zero, map_add, snd_add, snd_inl, snd_coe,
          zero_add, φ.map_add]
rw [add_add_add_comm]
simp only [algebra_map_eq_inl, fst_inl, snd_inl, φ.map_zero, add_zero]
rw [mul_smul_comm, ← smul_mul_assoc, smul_sub, smul_inv_smul, h.mul_coe_inv]
rw [smul_mul_assoc, ← mul_smul_comm, smul_sub, smul_inv_smul, h.coe_inv_mul]
apply not_iff_not.mp
simp [Set.not_not_mem, mem_iff]
rw [mem_iff, map_zero, zero_sub, IsUnit.neg_iff]
rw [zero_mem_iff, not_not]
rw [spectrum, resolvent_set_of_subsingleton, Set.compl_univ]
rw [mul_sub, mul_smul_comm, a.mul_inv, mul_one]
rw [sub_mul, smul_mul_assoc, a.inv_mul, one_mul]
simp only [mem_iff, sub_neg_eq_add, ← sub_sub, map_add]
rw [add_mem_iff, neg_add_cancel_left]
simp only [mem_iff, not_iff_not, Algebra.algebra_map_eq_smul_one, smul_assoc, ← smul_sub,
    is_unit_smul_iff]
simp
simp
simp only [Units.inv_eq_val_inv, IsUnit.mul_val_inv, mul_one, sub_add_cancel]
simp only [Units.inv_eq_val_inv, IsUnit.val_inv_mul, mul_one, sub_add_cancel]
rw [singleton_add, image_add_left, mem_preimage, add_comm, add_mem_iff, map_neg, neg_neg]
simp only [mem_neg, mem_iff, map_neg, ← neg_add', IsUnit.neg_iff, sub_neg_eq_add]
rw [sub_eq_add_neg, neg_eq, singleton_add_eq, sub_eq_add_neg]
simp [Algebra.algebra_map_eq_smul_one, mem_iff]
rw [Algebra.algebra_map_eq_smul_one, one_smul]
simp only [eval_C, eval_sub, sub_self, is_root.def]
simp only [aeval_C, AlgHom.map_sub, sub_left_inj]
simp only [aeval_C, AlgHom.map_sub, sub_left_inj]
rw [← aeval_def] at h_eval_p
rw [h_eval_p]
simp
simp only [RingHom.mem_ker, map_sub, RingHom.coe_coe, AlgHomClass.commutes,
      Algebra.id.map_eq_id, RingHom.id_apply, sub_self]
simp only [LinearMap.mul', TensorProduct.lift.tmul, mul_apply']
constructor <;> intro h
· rw [← mul_one a, ← mul_left_apply a 1, h, LinearMap.zero_apply]
· rw [h]
    exact mul_left_zero_eq_zero
constructor <;> intro h
· rw [← one_mul a, ← mul_right_apply a 1, h, LinearMap.zero_apply]
· rw [h]
    exact mul_right_zero_eq_zero
simp only [mul_right, ← Algebra.coe_lmul_eq_mul]
exact LinearMap.coe_injective (((mul_right R a).coe_pow n).symm ▸ mul_right_iterate a n)
rw [Algebra.smul_def, mul_smul]
rfl
rw [Algebra.smul_def, mul_smul]
rfl
simp only [Algebra.smul_def, map_mul, commutes, RingHom.id_apply]
cases f
cases g
congr
simp only [Algebra.algebra_map_eq_smul_one, h, f.map_one]
rw [← φ₁.commutes, ← φ₂.commutes] <;> rfl
simp only [Algebra.algebra_map_eq_smul_one, f.map_smul, map_one]
simp
simp
simp only [Set.ext_iff, mem_mul_support, Ne.def, imp_not_comm, ← forall_and, ← iff_def, ←
    xor_iff_not_iff', ← xor_iff_iff_not]
rw [Disjoint.comm, mul_support_disjoint_iff]
rw [nonempty_iff_ne_empty, Ne.def, mul_support_eq_empty_iff]
simp only [hf, hg, op1]
rw [mul_support_subset_iff']
simp only [mem_Union, not_exists, nmem_mul_support]
intro x hx
simp only [hx, csupr_const]
simp only [(· ∘ ·), *]
simp only [mul_support, not_and_or, mem_union, mem_set_of_eq, Prod.mk_eq_one, Ne.def]
simp only [← mul_support_prod_mk, Prod.mk.eta]
simp
simp only [hf, zero_mul]
simp only [hg, mul_zero]
rw [Pi.smul_apply, hf, smul_zero]
rw [Pi.smul_apply', hf, zero_smul]
simp only [hc, mem_support, Pi.smul_apply, Ne.def, smul_eq_zero, false_or_iff]
simp [div_eq_mul_inv]
rw [mul_support_subset_iff']
simp only [mem_Union, not_exists, nmem_mul_support]
exact fun x => Finset.prod_eq_one
simp only [support, Ne.def, Finset.prod_eq_zero_iff, mem_set_of_eq, Set.mem_Inter, not_exists]
rw [sub_eq_add_neg, mul_support_one_add', support_neg']
rw [mul_support_comp_eq_preimage f g, image_inter_preimage]
simp
rw [mul_support_mul_single_of_ne hb, mul_support_mul_single_of_ne hb', disjoint_singleton]
refine' ⟨fun h a b c bc => _, fun h a b c bc => _⟩
· rw [← inv_mul_cancel_left a b, ← inv_mul_cancel_left a c]
    exact h a
refine' ⟨fun h a b c bc => _, fun h a b c bc => _⟩
· rw [← mul_inv_cancel_right b a, ← mul_inv_cancel_right c a]
    exact h a
rw [IsSymmOp.flip_eq]
rw [IsSymmOp.flip_eq]
simp [h]
simp
simp
rw [mul_comm] at h'
exact hp.pow_dvd_of_dvd_mul_left n h h'
refine' mul_left_cancel₀ (pow_ne_zero n hp.ne_zero) _
rw [← mul_assoc _ p, ← pow_succ', ← hy, mul_pow, ← mul_assoc (a ^ n.succ), mul_comm _ (p ^ n),
      mul_assoc]
  -- So `p ∣ a` (and we're done) or `p ∣ x`, which can't be the case since it implies `p^2 ∣ b`.
simp [irreducible_iff]
simp_all [Prime]
conv => 
                    lhs
                    rw [hx] <;>
                  simp [mul_comm, mul_assoc, mul_left_comm]
simp_all [Prime]
conv => 
                  lhs
                  rw [hx] <;>
                simp [mul_comm, mul_assoc, mul_left_comm]
simp [*, pow_succ, mul_comm, mul_left_comm, mul_assoc]
simp [*, pow_succ, mul_comm, mul_left_comm, mul_assoc]
simp
rw [mul_assoc, Units.mul_inv, mul_one]
rw [Units.val_mul, mul_assoc]
simp [h]
rw [mul_comm]
exact associated_mul_unit_left _ _ hu
rw [mul_comm]
exact associated_mul_is_unit_left_iff hu
simp [h₁.symm, h₂.symm, mul_assoc, mul_comm, mul_left_comm]
intro con
rw [con, zero_mul] at a_eq
apply ha0 a_eq
rw [← mul_assoc, ← a_eq, mul_one]
rw [← mul_assoc, ← a_eq, mul_one]
let ⟨u, hu⟩ := h
simp [hu.symm, ha]
let ⟨u, hu⟩ := h.symm
simp [hu.symm, hb]
simp [hv, hu.symm]
simp [Units.mul_right_dvd]
intro a b
exact hp.dvd_or_dvd
simp [hv, hu.symm]
simp
rw [hu] <;> simp [hab, mul_assoc]
simp [hv]
rw [← hv, mul_assoc c (v : α) d, mul_left_comm c, ← hu]
simp [hv.symm, mul_assoc, mul_comm, mul_left_comm]
rw [mul_comm a, mul_comm c] <;> exact Associated.of_mul_left
rw [← h.dvd_iff_dvd_right]
apply dvd_pow_self _ hk₁.ne'
rw [pp.dvd_prime_iff_associated qp, ← associated_eq_eq]
rw [← associated_iff_eq] at h⊢
apply h.of_pow_associated_of_prime hp₁ hp₂ hk₁
rw [← associated_iff_eq] at h⊢
apply h.of_pow_associated_of_prime' hp₁ hp₂ hk₁
apply Quotient.recOnSubsingleton₂
intro a b
congr
simp [h₁.symm, h₂.symm, mul_assoc, mul_comm, mul_left_comm]
simp
simp
rw [mul_assoc]
rw [mul_comm]
induction n <;> simp [*, pow_succ, associates.mk_mul_mk.symm]
simp (config := { contextual := true })
simp
rw [Associates.is_unit_iff_eq_one, bot_eq_one]
rw [is_unit_iff_eq_one, one_eq_mk_one, mk_eq_mk_iff_associated]
simp [hx, hy, mul_comm, mul_assoc, mul_left_comm]
rw [mul_comm] <;> exact le_mul_right
ac_rfl
simp [hc] <;> rfl
simp [this]
simp [this] at hp0 <;> contradiction
rw [← Associates.bot_eq_one, le_bot_iff]
refine' injective_of_lt_imp_ne fun n m h => DvdNotUnit.ne ⟨pow_ne_zero n hq', q ^ (m - n), _, _⟩
· exact not_isUnit_of_not_isUnit_dvd hq (dvd_pow (dvd_refl _) (Nat.sub_pos_of_lt h).ne')
· exact (pow_mul_pow_sub q h.le).symm
rw [@eq_comm _ (f a)]
simp only [funext_iff, subset_def, mem_mul_support, mul_indicator_apply_eq_self, not_imp_comm]
rw [mul_indicator_eq_self] at h1⊢
exact subset.trans h1 h2
simp only [funext_iff, mul_indicator_apply_eq_one, Set.disjoint_left, mem_mul_support,
    not_imp_not]
simp only [Ne.def, mul_indicator_apply_eq_one, not_imp, mem_inter_iff, mem_mul_support]
simp [Function.mem_mul_support, mul_indicator_apply_eq_one]
simp only [mul_support_one, empty_disjoint]
rw [← mul_indicator_mul_indicator, mul_indicator_mul_support]
rw [← mul_indicator_comp_right, preimage_image_eq _ hg]
simp [mul_indicator_preimage, Pi.one_def, Set.preimage_const_of_not_mem ht]
simp [mul_indicator, ite_eq_iff, exists_or, eq_univ_iff_forall, and_comm', or_comm',
    @eq_comm _ r 1]
rw [← mul_indicator_union_mul_inter_apply f s t, mul_indicator_of_not_mem h, mul_one]
simp [ha]
simp [ha]
simp [ha]
simp [ha]
refine' (mul_indicator_congr fun x hx => _).trans mul_indicator_mul_support
have : g x = 1 := nmem_mul_support.1 (disjoint_left.1 h hx)
rw [Pi.mul_apply, this, mul_one]
refine' (mul_indicator_congr fun x hx => _).trans mul_indicator_mul_support
have : f x = 1 := nmem_mul_support.1 (disjoint_right.1 h hx)
rw [Pi.mul_apply, this, one_mul]
rw [sub_eq_add_neg, indicator_compl']
rw [Pi.mul_def, ← mul_indicator_union_of_disjoint disjoint_diff.symm f, diff_union_self,
      union_eq_self_of_subset_right h]
rw [indicator_diff' h, sub_eq_add_neg]
refine' (Finset.prod_filter_mul_prod_filter_not s (fun i => g i ∈ t i) _).symm.trans _
refine' Eq.trans _ (mul_one _)
exact
    congr_arg₂ (· * ·)
      ((Finset.prod_congr rfl) fun x hx => mul_indicator_of_mem (Finset.mem_filter.1 hx).2 _)
      (Finset.prod_eq_one fun x hx => mul_indicator_of_not_mem (Finset.mem_filter.1 hx).2 _)
rw [Set.mul_indicator_finset_bUnion I s h]
rw [← Set.indicator_indicator]
simp [indicator]
simp only [count, countp_of, Pi.single_apply, eq_comm]
rw [countp_of', ofAdd_zero]
simp only [count, countp_of, Pi.mulSingle_apply, eq_comm]
induction xs <;> simp [*, List.join]
simp
simp only [h, hxs, MonoidHom.map_mul]
simp only [to_list_mul, List.map_append, List.prod_append]
rw [mk_sol] <;> simp
rw [mk_sol]
simp only [n.is_lt, dif_pos, Fin.mk_coe, Fin.eta]
rw [mk_sol, ← tsub_add_cancel_of_le (le_of_not_lt h'), h (n - E.order)]
simp [h']
congr
simp
simp [mul_add, sum_add_distrib, hu n, hv n]
ac_rfl
simp [neZero_iff]
rw [pow_succ, zero_mul]
rw [pow_succ]
exact zero_mul _
rw [← tsub_add_cancel_of_le hn, pow_add, hx, mul_zero]
cases (zero_le n).eq_or_gt <;> simp [*, ne_of_gt]
rw [pow_zero, pow_zero, Ring.inverse_one]
rw [pow_succ, pow_succ', Ring.mul_inverse_rev' ((Commute.refl r).pow_left n), Ring.inverse_pow]
rw [← pow_succ', mul_one]
exact (pow_dvd_pow _ (Nat.succ_le_of_lt hmn)).trans h
simp only [sq, add_mul_self_eq]
rw [add_sq, add_assoc, add_comm _ (b ^ 2), add_assoc]
rw [pow_succ, h, neg_one_mul, neg_neg]
rw [pow_succ, h, mul_one]
rw [pow_bit0', neg_mul_neg, pow_bit0']
simp only [bit1, pow_succ, neg_pow_bit0, neg_mul_eq_neg_mul]
simp [sq]
rw [neg_sq, one_pow]
rw [sq, sq, h.mul_self_sub_mul_self_eq]
rw [← sub_eq_zero, h.sq_sub_sq, mul_eq_zero, add_eq_zero_iff_eq_neg, sub_eq_zero, or_comm']
rw [← (Commute.one_right a).sq_eq_sq_iff_eq_or_eq_neg, one_pow]
rw [sub_eq_add_neg, add_sq, neg_sq, mul_neg, ← sub_eq_add_neg]
rw [sub_eq_add_neg, add_sq', neg_sq, mul_neg, ← sub_eq_add_neg]
rw [pow_succ, pow_zero, mul_one]
rw [pow_succ, pow_one]
rw [pow_succ', pow_two]
rw [pow_succ, pow_two]
simp
rw [← pow_mul, Nat.mul_comm, pow_mul]
rw [Nat.mul_comm, pow_mul]
rw [← pow_add, Nat.add_comm, Nat.sub_add_cancel h]
rw [← pow_add, Nat.sub_add_cancel h]
have t := congr_arg (fun a => x ^ a) ((Nat.add_comm _ _).trans (Nat.mod_add_div _ _)).symm
dsimp at t
rw [t, pow_add, pow_mul, h, one_pow, one_mul]
rw [bit1, pow_succ', pow_bit0]
simp only [pow_zero, one_mul]
simp only [pow_succ, ihn, ← mul_assoc, (h.pow_left n).right_comm]
rw [pow_bit0, (Commute.refl a).mul_pow]
rw [bit1, pow_succ', pow_bit0']
rw [pow_succ', pow_succ]
simp only [mul_assoc]
simp [h, hn]
rw [pow_succ]
exact hxy.mul_right _
rw [pow_zero, pow_zero, inv_one]
rw [pow_succ', pow_succ, inv_pow, mul_inv_rev]
rw [zpow_ofNat, one_pow]
rw [zpow_negSucc, one_pow, inv_one]
change a ^ (0 : ℤ) = (a ^ (0 : ℤ))
rw [zpow_negSucc, inv_inv, ← zpow_ofNat]
rfl
rw [zpow_ofNat, zpow_ofNat, inv_pow]
rw [zpow_negSucc, zpow_negSucc, inv_pow]
rw [inv_zpow, zpow_neg]
simp [h.mul_pow n]
simp [h.mul_pow, (h.pow_pow _ _).Eq, mul_inv_rev]
simp only [div_eq_mul_inv, mul_pow, inv_pow]
simp only [div_eq_mul_inv, mul_zpow, inv_zpow]
rw [← pow_add, Nat.sub_add_cancel h]
rw [← pow_add, Nat.add_comm, Nat.sub_add_cancel h]
simp [zpow_ofNat, h.pow_right n]
simp [(h.pow_right n.succ).inv_right]
rw [← (commute_invOf m).symm.mul_pow, invOf_mul_self, one_pow]
rw [← (commute_invOf m).mul_pow, mul_invOf_self, one_pow]
cases n <;> simp
rw [zpow_ofNat, zpow_ofNat, ← pow_mul, ← zpow_ofNat]
rfl
rw [zpow_ofNat, zpow_negSucc, ← pow_mul, coe_nat_mul_neg_succ, zpow_neg, inv_inj, ← zpow_ofNat]
rfl
rw [zpow_ofNat, zpow_negSucc, ← inv_pow, ← pow_mul, neg_succ_mul_coe_nat, zpow_neg, inv_pow,
      inv_inj, ← zpow_ofNat]
rfl
rw [zpow_negSucc, zpow_negSucc, neg_succ_mul_neg_succ, inv_pow, inv_inv, ← pow_mul, ←
      zpow_ofNat]
rfl
rw [mul_comm, zpow_mul]
simp only [zpow_ofNat, ← Int.ofNat_bit0, pow_bit0]
rw [zpow_bit0', zpow_bit0', neg_mul_neg]
simp only [← Int.ofNat_succ, zpow_ofNat, pow_succ']
erw [zpow_zero, zpow_negSucc, pow_one, mul_left_inv]
rw [zpow_negSucc, pow_succ, mul_inv_rev, inv_mul_cancel_right]
rw [Int.negSucc_eq, neg_add, add_assoc, neg_add_self, add_zero]
exact zpow_negSucc _ _
rw [← zpow_add_one, sub_add_cancel]
rw [sub_eq_add_neg, zpow_add, zpow_neg]
rw [zpow_add, zpow_one]
rw [bit1, zpow_add, zpow_bit0, zpow_one]
rw [← zpow_add]
simp
rw [← zpow_add]
simp
rw [← one_lt_div', ← div_zpow]
exact one_lt_zpow' (one_lt_div'.2 hab) hn
rw [← one_le_div', ← div_zpow]
exact one_le_zpow (one_le_div'.2 hab) hn
cases hn.symm.lt_or_lt
· exact (zpow_strict_mono_left α h).Injective
· refine' fun a b (hab : a ^ n = b ^ n) => (zpow_strict_mono_left α (neg_pos.mpr h)).Injective _
    rw [zpow_neg, zpow_neg, hab]
simp [a0, a0.le, a0.not_le, b0, abs_of_neg, abs_of_nonneg]
simp only [le_antisymm h b0, abs_of_neg a0, add_zero]
rw [nsmul_eq_mul', (n.cast_commute a).Eq]
dsimp [bit0]
rw [add_mul, add_zsmul, one_zsmul]
dsimp [bit0]
rw [mul_add, add_zsmul, one_zsmul]
dsimp [bit1]
rw [add_mul, bit0_mul, one_mul]
dsimp [bit1]
rw [mul_add, mul_bit0, mul_one]
rw [coe_nat_zsmul, nsmul_eq_mul, Int.cast_ofNat]
simp [Nat.cast_succ, neg_add_rev, Int.cast_negSucc, add_mul]
rw [zsmul_eq_mul, (n.cast_commute a).Eq]
simp
simp
rw [← Nat.mod_add_div n 2, pow_add, pow_mul] <;> simp [sq]
simp
simp
simp [add_mul, mul_add, bit0, mul_assoc, (n.cast_commute (_ : R)).left_comm]
ac_rfl
simp only [pow_succ, mul_assoc]
simp
rw [← add_assoc, ← one_mul (a ^ i), pow_succ]
exact mul_le_mul ha (pow_le_pow_of_le_one_aux _) (pow_nonneg h _) zero_le_one
let ⟨k, hk⟩ := Nat.exists_eq_add_of_le hij
rw [hk] <;> exact pow_le_pow_of_le_one_aux h ha _ _
simp only [le_iff_lt_or_eq, pow_bit1_neg_iff, pow_eq_zero_iff (bit1_pos (zero_le n))]
rw [sq, Int.natAbs_mul_self', sq]
exact Function.Injective.of_comp this
simp [← f.map_pow, ← ofAdd_nsmul]
simp [← f.map_zpow, ← ofAdd_zsmul]
rw [← powers_hom_symm_apply, ← powers_hom_apply, Equiv.apply_symm_apply]
rw [f.apply_mnat, g.apply_mnat, h]
rw [← zpowers_hom_symm_apply, ← zpowers_hom_apply, Equiv.apply_symm_apply]
rw [← multiples_hom_symm_apply, ← multiples_hom_apply, Equiv.apply_symm_apply]
rw [← zmultiples_hom_symm_apply, ← zmultiples_hom_apply, Equiv.apply_symm_apply]
simp [mul_pow]
simp [mul_zpow]
simp [nsmul_add]
simp [zsmul_add]
simp only [zpow_ofNat, Units.val_pow_eq_pow_val, h, pow_right]
simp only [zpow_negSucc, Units.val_pow_eq_pow_val, units_inv_right, h, pow_right]
rw [← mul_one (m : R)]
exact (one_left a).cast_int_mul_left m
rw [← mul_one (m : R)]
exact (one_right a).cast_int_mul_right m
induction b <;> simp [*, mul_add, pow_succ, add_comm]
simp
simp (config := { contextual := true }) [zpow_add, mul_add]
simp (config := { contextual := true }) [zpow_add, mul_add, sub_eq_add_neg, -Int.add_neg_one]
simp
rw [pow_succ, pow_succ]
exact mul_le_mul' hab (pow_le_pow_of_le_left' k)
simp
rw [pow_succ]
exact one_le_mul H (one_le_pow_of_one_le' k)
rw [← hk, pow_add]
rw [pow_succ]
exact Left.one_le_mul hx Left.one_le_pow_of_le
rw [pow_succ]
exact Left.mul_le_one hx Left.pow_le_one_of_le
rw [pow_succ]
exact Right.one_le_mul hx Right.one_le_pow_of_le
rw [pow_succ]
exact Right.mul_le_one hx Right.pow_le_one_of_le
rw [pow_succ]
exact mul_lt_one h ih
rw [pow_succ]
exact Right.mul_lt_one h ih
simp only [le_antisymm_iff, pow_le_one_iff hn, one_le_pow_iff hn]
rw [zero_pow n.succ_pos]
exact zero_le_one
rw [pow_succ _ n, pow_succ _ n]
exact le_add_of_nonneg_right h1
rw [add_mul, mul_add, mul_add, add_comm (y * x ^ n), ← add_assoc, ← add_assoc,
        add_assoc (x * x ^ n) (x * y ^ n), add_comm (x * y ^ n) (y * y ^ n), ← add_assoc]
rw [pow_succ _ n]
exact mul_le_mul_of_nonneg_left (ih (Nat.succ_ne_zero k)) h2
rw [pow_succ]
exact mul_lt_one_of_nonneg_of_lt_one_left h₀ h₁ (pow_le_one _ h₀ h₁.le)
rw [pow_zero]
rw [pow_succ]
exact le_mul_of_one_le_left (pow_nonneg (zero_le_one.trans h) _) h
simp
rw [pow_succ, pow_succ]
exact mul_le_mul hab (pow_le_pow_of_le_left _) (pow_nonneg ha _) (le_trans ha hab)
rw [pow_succ]
exact one_lt_mul_of_lt_of_le ha (one_le_pow_of_one_le ha.le _)
rw [sq]
exact mul_pos ha ha
rw [pow_bit0']
exact pow_pos (mul_pos_of_neg_of_neg ha ha) _
rw [bit1, pow_succ]
exact mul_neg_of_neg_of_pos ha (pow_bit0_pos_of_neg ha n)
refine' ⟨_, pow_le_one n ha⟩
rw [← not_lt, ← not_lt]
exact mt fun h => one_lt_pow h hn
refine' ⟨_, fun h => one_le_pow_of_one_le h n⟩
rw [← not_lt, ← not_lt]
exact mt fun h => pow_lt_one ha h hn
decide
rw [← pow_abs, abs_neg, abs_one, one_pow]
rw [pow_bit0]
exact mul_self_nonneg _
simp only [le_antisymm_iff, sq_le_sq]
rw [← one_mul (a ^ n), pow_succ]
exact mul_lt_right₀ _ ha (pow_ne_zero _ (zero_lt_one.trans ha).ne')
rw [← map_pow, neg_one_sq, map_one]
rw [← neg_one_mul, map_mul, map_neg_one, one_mul]
rw [← map_neg, neg_sub]
cases q₁
cases q₂
congr
rw [← q₁_i_mul_j, ← q₂_i_mul_j]
congr
rw [← i_mul_j, ← mul_assoc, i_mul_i, smul_mul_assoc, one_mul]
rw [← i_mul_j, mul_assoc, j_mul_i, mul_neg, i_mul_k, neg_smul]
rw [← i_mul_j, mul_assoc, j_mul_j, mul_smul_comm, mul_one]
rw [← i_mul_j, ← mul_assoc, j_mul_i, neg_mul, k_mul_j, neg_smul]
rw [← i_mul_j, mul_assoc, ← mul_assoc q.j _ _, j_mul_i, ← i_mul_j, ← mul_assoc, mul_neg, ←
    mul_assoc, i_mul_i, smul_mul_assoc, one_mul, neg_mul, smul_mul_assoc, j_mul_j, smul_smul]
simp [lift]
simp [lift]
simp [lift, mul_smul, ← Algebra.smul_def]
rw [← F.map_mul, q.i_mul_i, F.map_smul, F.map_one]
rw [← F.map_mul, q.j_mul_j, F.map_smul, F.map_one]
rw [← F.map_mul, q.i_mul_j]
rw [← F.map_mul, q.j_mul_i, F.map_neg]
rw [← vadd_vsub g1, h, vadd_vsub]
apply vadd_right_cancel p2
rw [vsub_vadd, add_vadd, vsub_vadd]
rw [← vsub_vadd p1 p2, h, zero_vadd]
apply vadd_right_cancel p3
rw [add_vadd, vsub_vadd, vsub_vadd, vsub_vadd]
refine' neg_eq_of_add_eq_zero_right (vadd_right_cancel p1 _)
rw [vsub_add_vsub_cancel, vsub_self]
rw [vadd_vsub_assoc, sub_eq_add_neg, neg_vsub_eq_vsub_rev]
rw [← vsub_vadd_eq_vsub_sub, vsub_vadd]
rw [eq_vadd_iff_vsub_eq, vadd_vsub_assoc, ← add_right_inj (-v₁), neg_add_cancel_left, eq_comm]
rw [Set.singleton_vsub_singleton, vsub_self]
rw [vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, vsub_self, add_zero]
rw [sub_eq_add_neg, neg_vsub_eq_vsub_rev, add_comm, vsub_add_vsub_cancel]
rw [vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, add_sub_cancel']
rw [← @vsub_eq_zero_iff_eq G, vadd_vsub_assoc, vsub_vadd_eq_vsub_sub]
simp
rw [vadd_eq_vadd_iff_neg_add_eq_vsub, neg_add_eq_sub]
rw [← vsub_vadd_eq_vsub_sub, vsub_vadd_comm, vsub_vadd_eq_vsub_sub]
simp
simp [add_vadd]
simp
simp
simp
simp [vsub_vadd_eq_vsub_sub]
simp [vadd_vadd]
simp [vadd_vadd]
simp [point_reflection]
rw [point_reflection_symm]
rw [point_reflection_apply, eq_comm, eq_vadd_iff_vsub_eq, ← neg_vsub_eq_vsub_rev,
    neg_eq_iff_add_eq_zero, ← bit0, ← bit0_zero, h.eq_iff, vsub_eq_zero_iff_eq, eq_comm]
rw [← mul_assoc, invOf_mul_self, one_mul]
rw [← mul_assoc, mul_invOf_self, one_mul]
simp [mul_assoc]
simp [mul_assoc]
apply invOf_eq_right_inv
rw [h, mul_invOf_self]
congr
exact left_inv_eq_right_inv hba hac
rw [hs, invOf_mul_self]
rw [hs, mul_invOf_self]
simp
simp
simp
simp
simp
rw [mul_sub, mul_invOf_self, mul_one, bit0, add_sub_cancel]
rw [← two_mul, mul_invOf_self]
simp [← mul_assoc]
simp [← mul_assoc]
simp [← mul_assoc]
simp [mul_assoc]
rw [h.eq]
simp [mul_assoc]
simp [mul_assoc]
rw [h.eq]
simp [mul_assoc]
simp [ha]
simp [← mul_div_assoc]
simp [← mul_div_assoc]
simp [← mul_div_assoc]
simp
simp
rw [← map_mul, invOf_mul_self, map_one]
rw [← map_mul, mul_invOf_self, map_one]
rw [infi, ← Set.image_univ, ← coe_univ, trop_Inf_image]
rw [infi, ← Set.image_univ, ← coe_univ, untrop_sum_eq_Inf_image]
rw [trop_add_def, trop_eq_iff_eq_untrop, ← untrop_le_iff, min_eq_left_iff]
rw [trop_add_def, trop_eq_iff_eq_untrop, ← untrop_le_iff, min_eq_right_iff]
rw [trop_add_def, trop_eq_iff_eq_untrop]
simp [min_eq_iff]
cases n <;> simp [Nat.cast]
simp [← untrop_inj_iff, WithTop.add_eq_top]
rw [← coeff_eq_a, h, coeff_eq_a]
rw [← coeff_eq_b, h, coeff_eq_b]
rw [← coeff_eq_c, h, coeff_eq_c]
rw [← coeff_eq_d, h, coeff_eq_d]
rw [to_poly, ha, C_0, zero_mul, zero_add]
rw [of_a_eq_zero ha, hb, C_0, zero_mul, zero_add]
rw [of_b_eq_zero ha hb, hc, C_0, zero_mul, zero_add]
rw [of_c_eq_zero ha hb hc, hd, C_0]
rw [← zero, to_poly_injective]
rw [of_a_eq_zero ha, leading_coeff_quadratic hb]
rw [of_b_eq_zero ha hb, leading_coeff_linear hc]
rw [of_c_eq_zero ha hb hc, leading_coeff_C]
rw [ha]
exact one_ne_zero
rw [hb]
exact one_ne_zero
rw [hc]
exact one_ne_zero
rw [monic, leading_coeff_of_c_eq_zero ha hb hc, hd]
rw [of_a_eq_zero ha, degree_quadratic hb]
rw [of_b_eq_zero ha hb, degree_linear hc]
rw [of_c_eq_zero ha hb hc, degree_C hd]
rw [of_d_eq_zero ha hb hc hd, degree_zero]
rw [of_a_eq_zero ha, nat_degree_quadratic hb]
rw [of_b_eq_zero ha hb, nat_degree_linear hc]
rw [of_c_eq_zero ha hb hc, nat_degree_C]
simp only [map, to_poly, map_C, map_X, Polynomial.map_add, Polynomial.map_mul, Polynomial.map_pow]
rw [roots, map_to_poly]
rw [roots, mem_roots h0, is_root, to_poly]
simp only [eval_C, eval_X, eval_add, eval_mul, eval_pow]
apply (to_finset_card_le P.to_poly.roots).trans
rw [hP, nat_degree_zero]
exact zero_le 3
rw [splits_iff_card_roots ha, card_eq_three]
injection eq_sum_three_roots ha h3
injection eq_sum_three_roots ha h3
injection eq_sum_three_roots ha h3
rw [to_finset_card_of_nodup <| (disc_ne_zero_iff_roots_nodup ha h3).mp hd, ←
    splits_iff_card_roots ha, splits_iff_roots_eq_three ha]
exact ⟨x, ⟨y, ⟨z, h3⟩⟩⟩
cases a <;> rfl
simp only [h₀, sub_top, WithTop.map_zero, coe_zero, map_top]
simp only [← coe_sub, map_coe, h]
rw [tsub_le_iff_right, add_comm]
rw [tsub_le_iff_left, tsub_le_iff_right]
rw [tsub_le_iff_left, add_left_comm]
exact add_le_add_left le_add_tsub a
rw [add_comm, add_comm _ b]
exact add_tsub_le_assoc
rw [add_assoc]
exact add_le_add_left le_add_tsub a
rw [add_comm a, add_comm (a - c)]
exact add_le_add_add_tsub
rw [tsub_le_iff_left, ← add_assoc, add_right_comm]
exact le_add_tsub.trans (add_le_add_right le_add_tsub _)
rw [tsub_le_iff_left, tsub_le_iff_left, add_left_comm]
exact le_tsub_add.trans (add_le_add_left le_add_tsub _)
rw [add_comm c, tsub_le_iff_left, add_assoc, ← tsub_le_iff_left, ← tsub_le_iff_left]
refine' (tsub_le_tsub_right add_tsub_le_assoc c).trans _
rw [add_comm a, add_comm (a - c)]
exact add_tsub_le_assoc
rw [tsub_le_iff_left, add_assoc]
exact add_le_add_left le_add_tsub _
rw [tsub_le_iff_left, add_right_comm]
exact add_le_add_right le_add_tsub c
rw [add_comm]
exact hb.le_add_tsub_swap
rw [tsub_le_iff_left, add_zero]
apply le_antisymm
· rw [tsub_le_iff_left, tsub_le_iff_left, ← add_assoc, ← tsub_le_iff_left]
· rw [tsub_le_iff_left, add_assoc, ← tsub_le_iff_left, ← tsub_le_iff_left]
rw [add_comm]
apply tsub_add_eq_tsub_tsub
rw [h]
exact hb.le_add_tsub
rw [add_comm, h]
rw [add_comm]
rw [add_comm a b, add_comm a c, add_tsub_add_eq_tsub_right]
rw [add_comm]
exact add_tsub_cancel_of_le h
rw [tsub_le_iff_right, tsub_add_cancel_of_le h]
rw [tsub_tsub, add_tsub_cancel_of_le h]
rw [eq_comm, hb.eq_tsub_iff_add_eq_of_le h, eq_comm]
rw [add_comm a, hb.add_tsub_assoc_of_le h, add_comm]
rw [add_assoc, add_tsub_cancel_of_le h₂, tsub_add_cancel_of_le h₁]
rw [hb.tsub_add_eq_add_tsub hba, ← hd.add_tsub_assoc_of_le hdc, tsub_tsub, add_comm d]
rw [add_comm]
exact ha.le_tsub_iff_left h
rw [add_comm]
exact hb.tsub_lt_iff_left hba
rw [hb.tsub_lt_iff_left h₁, hc.tsub_lt_iff_right h₂]
rw [ha.le_tsub_iff_left h₁, hc.le_tsub_iff_right h₂]
rw [add_comm]
exact hc.lt_tsub_iff_right_of_le h
rw [← hab.inj]
rw [tsub_add_cancel_of_le h₁, h₃, tsub_add_cancel_of_le h₂]
rw [add_assoc, add_tsub_cancel_of_le h, add_comm]
rw [tsub_right_comm, hab.tsub_tsub_cancel_of_le h]
rw [add_comm]
exact add_tsub_cancel_iff_le
rw [← nonpos_iff_eq_zero, tsub_le_iff_left, add_zero]
rw [pos_iff_ne_zero, Ne.def, tsub_eq_zero_iff_le]
refine' ⟨_, fun h => tsub_le_tsub_left h a⟩
rw [tsub_le_iff_left, ← hc.add_tsub_assoc_of_le h, hc.le_tsub_iff_right (h.trans le_add_self),
    add_comm b]
apply ha
infer_instance
rw [tsub_pos_iff_not_le, not_le]
rw [hc.lt_tsub_iff_left, add_tsub_cancel_of_le h]
refine' tsub_le_self.lt_of_ne fun h => _
rw [← h, tsub_pos_iff_lt] at h₁
exact h₂.not_le (ha.add_le_iff_nonpos_left.1 <| add_le_of_le_tsub_left_of_le h₁.le h.ge)
rw [add_comm, max_comm, tsub_add_eq_max]
rw [← tsub_min, tsub_add_cancel_of_le]
apply min_le_left
rw [tsub_le_iff_right, ← f.map_add]
exact hf le_tsub_add
rw [← neg_neg a, smul_neg, neg_neg_iff_pos, neg_neg_iff_pos]
exact smul_pos_iff_of_pos hc
rw [← neg_neg c, neg_smul, neg_smul (-c), neg_lt_neg_iff]
exact smul_lt_smul_of_pos h (neg_pos_of_neg hc)
rw [← neg_neg c, neg_smul, neg_smul (-c), neg_le_neg_iff]
exact smul_le_smul_of_nonneg h (neg_nonneg_of_nonpos hc)
rw [← neg_neg c, neg_smul, neg_smul (-c), neg_inj] at hab
exact eq_of_smul_eq_smul_of_pos_of_le hab (neg_pos_of_neg hc) h
rw [← neg_neg c, neg_smul, neg_smul (-c), neg_lt_neg_iff] at h
exact lt_of_smul_lt_smul_of_nonneg h (neg_nonneg_of_nonpos hc)
rw [← neg_neg c, neg_smul, neg_smul (-c), neg_lt_neg_iff]
exact smul_lt_smul_iff_of_pos (neg_pos_of_neg hc)
rw [← neg_neg c, neg_smul, neg_neg_iff_pos]
exact smul_pos_iff_of_pos (neg_pos_of_neg hc)
rw [← neg_neg c, neg_smul, neg_pos]
exact smul_neg_iff_of_pos (neg_pos_of_neg hc)
rw [← neg_neg c, neg_smul, neg_smul (-c), neg_le_neg_iff]
exact smul_le_smul_iff_of_pos (neg_pos_of_neg hc)
rw [← smul_le_smul_iff_of_neg h, smul_inv_smul₀ h.ne]
infer_instance
rw [← smul_lt_smul_iff_of_neg h, smul_inv_smul₀ h.ne]
infer_instance
rw [← smul_le_smul_iff_of_neg h, smul_inv_smul₀ h.ne]
infer_instance
rw [← smul_lt_smul_iff_of_neg h, smul_inv_smul₀ h.ne]
infer_instance
rw [← comp_apply, h, comp_apply]
erw [← map_le_map_iff e, e.1.apply_symm_apply, e.1.apply_symm_apply]
rw [← map_zero f]
exact OrderHomClass.mono _ ha
rw [← map_zero f]
exact OrderHomClass.mono _ ha
rw [← map_zero f]
apply h
rw [← sub_add_cancel b a, map_add f]
exact le_add_of_nonneg_left (h _ <| sub_nonneg.2 hl)
rw [← map_zero f]
apply h
rw [← sub_add_cancel b a, map_add f]
exact lt_add_of_pos_left _ (h _ <| sub_pos.2 hl)
rw [← comp_apply, h, comp_apply]
rw [← comp_apply, h, comp_apply]
rw [add_comm, toIcoMod]
rw [add_comm, toIocMod]
rw [toIcoMod, add_sub_cancel']
rw [toIocMod, add_sub_cancel']
rw [toIcoMod, sub_add_cancel', neg_smul]
rw [toIocMod, sub_add_cancel', neg_smul]
rw [toIcoMod, add_sub_cancel]
rw [toIocMod, add_sub_cancel]
rw [← neg_sub, to_Ico_mod_sub_to_Ico_div_zsmul]
rw [← neg_sub, to_Ioc_mod_sub_to_Ioc_div_zsmul]
refine' (eq_to_Ico_div_of_add_zsmul_mem_Ico hb _).symm
simp [hb]
refine' (eq_to_Ioc_div_of_add_zsmul_mem_Ioc hb _).symm
simp [hb]
rw [to_Ico_mod_eq_iff hb]
refine' ⟨le_refl _, lt_add_of_pos_right _ hb, 0, _⟩
simp
rw [to_Ioc_mod_eq_iff hb]
refine' ⟨lt_add_of_pos_right _ hb, le_refl _, 1, _⟩
simp
refine' (eq_to_Ico_div_of_add_zsmul_mem_Ico hb _).symm
simp [hb]
refine' (eq_to_Ioc_div_of_add_zsmul_mem_Ioc hb _).symm
simp [hb]
rw [to_Ico_mod_eq_iff hb]
refine' ⟨le_refl _, lt_add_of_pos_right _ hb, -1, _⟩
simp
rw [to_Ioc_mod_eq_iff hb]
refine' ⟨lt_add_of_pos_right _ hb, le_refl _, 0, _⟩
simp
rw [add_comm, to_Ico_div_add_zsmul]
rw [add_comm, to_Ioc_div_add_zsmul]
rw [sub_eq_add_neg, ← neg_smul, to_Ico_div_add_zsmul, sub_neg_eq_add]
rw [sub_eq_add_neg, ← neg_smul, to_Ioc_div_add_zsmul, sub_neg_eq_add]
rw [add_comm, to_Ico_div_add_right]
rw [add_comm, to_Ioc_div_add_right]
rw [← sub_neg_eq_add, to_Ico_div_sub', sub_eq_add_neg]
rw [← sub_neg_eq_add, to_Ioc_div_sub', sub_eq_add_neg]
rw [← neg_neg x, to_Ico_div_neg, neg_neg, neg_neg, sub_sub_cancel]
rw [add_comm, to_Ico_mod_add_zsmul]
rw [add_comm, to_Ioc_mod_add_zsmul]
rw [sub_eq_add_neg, ← neg_smul, to_Ico_mod_add_zsmul]
rw [sub_eq_add_neg, ← neg_smul, to_Ioc_mod_add_zsmul]
rw [add_comm, to_Ico_mod_add_right]
rw [add_comm, to_Ioc_mod_add_right]
rw [to_Ico_mod_eq_iff]
refine' ⟨fun h => ⟨h.1, h.2.1⟩, fun h => ⟨h.1, h.2, 0, _⟩⟩
simp
rw [to_Ioc_mod_eq_iff]
refine' ⟨fun h => ⟨h.1, h.2.1⟩, fun h => ⟨h.1, h.2, 0, _⟩⟩
simp
rw [to_Ico_mod_eq_to_Ico_mod]
exact ⟨-toIcoDiv a₂ hb x, self_sub_to_Ico_mod a₂ hb x⟩
rw [to_Ico_mod_eq_to_Ico_mod]
exact ⟨-toIocDiv a₂ hb x, self_sub_to_Ioc_mod a₂ hb x⟩
rw [to_Ioc_mod_eq_to_Ioc_mod]
exact ⟨-toIocDiv a₂ hb x, self_sub_to_Ioc_mod a₂ hb x⟩
rw [to_Ioc_mod_eq_to_Ioc_mod]
exact ⟨-toIcoDiv a₂ hb x, self_sub_to_Ico_mod a₂ hb x⟩
induction x using QuotientAddGroup.induction_on'
dsimp
rw [QuotientAddGroup.eq_iff_sub_mem, to_Ico_mod_sub_self]
apply AddSubgroup.zsmul_mem_zmultiples
induction x using QuotientAddGroup.induction_on'
dsimp
rw [QuotientAddGroup.eq_iff_sub_mem, to_Ioc_mod_sub_self]
apply AddSubgroup.zsmul_mem_zmultiples
refine' (eq_to_Ico_div_of_add_zsmul_mem_Ico hb _).symm
rw [Set.mem_Ico, zsmul_eq_mul, Int.cast_neg, neg_mul, ← sub_nonneg, add_comm, add_sub_assoc,
    add_comm, ← sub_eq_add_neg]
refine' ⟨Int.sub_floor_div_mul_nonneg _ hb, _⟩
rw [add_comm a, ← sub_lt_iff_lt_add, add_sub_assoc, add_comm, ← sub_eq_add_neg]
exact Int.sub_floor_div_mul_lt _ hb
refine' (eq_to_Ioc_div_of_add_zsmul_mem_Ioc hb _).symm
rw [Set.mem_Ioc, zsmul_eq_mul, ← sub_nonneg, sub_add_eq_sub_sub]
refine' ⟨_, Int.sub_floor_div_mul_nonneg _ hb⟩
rw [← add_lt_add_iff_right b, add_assoc, add_comm x, ← sub_lt_iff_lt_add, add_comm (_ * _), ←
    sub_lt_iff_lt_add]
exact Int.sub_floor_div_mul_lt _ hb
simp [to_Ico_div_eq_neg_floor]
simp [to_Ico_mod_eq_add_fract_mul]
simp [to_Ico_mod_eq_add_fract_mul]
rw [abs_eq_nat_abs, abs_eq_nat_abs, coe_nat_lt]
cases a <;> simp [mul_def, h] <;> rfl
cases a <;> simp [mul_def, h] <;> rfl
simp [this]
simp [this]
simp [*, mul_def]
rfl
simp [hb]
rw [← coe_one, ← coe_mul, one_mul]
rw [← coe_one, ← coe_mul, mul_one]
simp only [or_comm', mul_def, Option.bind_comm a b, mul_comm]
rw [mul_comm, distrib', mul_comm b, mul_comm c]
rfl
simp [this]
simp [this]
simp [*, mul_def]
rfl
rw [pow_zero]
exact zero_le_one
rw [pow_succ]
exact mul_nonneg H (pow_nonneg _)
rw [mul_add, mul_two, add_assoc]
simp
rw [h, le_add_iff_nonneg_right]
exact hc
rw [pow_succ]
exact mul_pos H (pow_pos _)
rw [← b0, mul_zero] <;> exact mul_pos (h3.trans_lt h1) (h4.trans_lt h2)
rw [bit0, bit0, ← two_mul, ← two_mul, mul_le_mul_left (zero_lt_two : 0 < (2 : α))]
rw [bit0, bit0, ← two_mul, ← two_mul, mul_lt_mul_left (zero_lt_two : 0 < (2 : α))]
rw [bit1, le_add_iff_nonneg_left, bit0, ← two_mul, zero_le_mul_left (zero_lt_two : 0 < (2 : α))]
rw [bit1, lt_add_iff_pos_left, bit0, ← two_mul, zero_lt_mul_left (zero_lt_two : 0 < (2 : α))]
rw [bit0, ← two_mul, zero_le_mul_left (zero_lt_two : 0 < (2 : α))]
rw [bit0, ← two_mul, zero_lt_mul_left (zero_lt_two : 0 < (2 : α))]
rw [← sub_eq_zero, ← mul_sub] at h
exact sub_eq_zero.1 ((eq_zero_or_eq_zero_of_mul_eq_zero h).resolve_left ha)
rw [← sub_eq_zero, ← sub_mul] at h
exact sub_eq_zero.1 ((eq_zero_or_eq_zero_of_mul_eq_zero h).resolve_right hb)
rw [← neg_pos, neg_mul_eq_mul_neg, mul_pos_iff, neg_pos, neg_lt_zero]
rw [← neg_nonneg, neg_mul_eq_mul_neg, mul_nonneg_iff, neg_nonneg, neg_nonpos]
simp [neg_le_iff_add_nonneg, ← two_mul, mul_nonneg_iff, zero_le_one, (zero_lt_two' α).not_le]
simp [neg_lt_iff_pos_add, ← two_mul, mul_pos_iff, zero_lt_one, (zero_lt_two' α).not_lt]
rw [neg_neg]
rw [neg_neg]
rw [add_eq_zero_iff', mul_self_eq_zero, mul_self_eq_zero] <;> apply mul_self_nonneg
simp only [pos_iff_ne_zero, Ne.def, mul_eq_zero, not_or]
simp only [mul_comm _ c] at *
exact h.mul_tsub
simp only [zero, one, zero_le_one]
rw [abs_mul, abs_mul_abs_self]
simp [abs_eq_max_neg]
simp [abs_eq_max_neg]
rw [← abs_mul_abs_self, ← abs_mul_abs_self b]
exact (mul_self_inj (abs_nonneg a) (abs_nonneg b)).symm
rw [← abs_mul_abs_self, ← abs_mul_abs_self b]
exact mul_self_lt_mul_self_iff (abs_nonneg a) (abs_nonneg b)
rw [← abs_mul_abs_self, ← abs_mul_abs_self b]
exact mul_self_le_mul_self_iff (abs_nonneg a) (abs_nonneg b)
rw [abs_mul_abs_self]
simp only [mul_add, add_comm, add_left_comm, mul_comm, sub_eq_add_neg, mul_one, mul_neg,
    neg_add_rev, neg_neg]
rw [Nat.cast_succ]
apply lt_add_one
rw [mul_one]
rw [mul_one]
rw [mul_one]
rw [mul_one]
rw [one_mul]
rw [one_mul]
rw [one_mul]
rw [one_mul]
simp! only [mul_comm]
simp! only [mul_comm]
simp! only [mul_comm]
simp! only [mul_comm]
rw [coe_lt_induced_map_iff, coe_lt_induced_map_iff, Iff.comm, coe_lt_induced_map_iff]
rw [induced_map_induced_map, induced_map_self]
rw [induced_map, cut_map_add]
exact
    cSup_add (cut_map_nonempty β x) (cut_map_bdd_above β x) (cut_map_nonempty β y)
      (cut_map_bdd_above β y)
simp [ne_of_gt ha, zero_lt_one]
simp only [le_iff_eq_or_lt, inv_pos, zero_eq_inv]
simp only [← not_le, inv_nonneg]
simp only [← not_lt, inv_pos]
rw [div_eq_mul_inv]
exact mul_pos ha (inv_pos.2 hb)
rw [div_eq_mul_inv]
exact mul_nonneg ha (inv_nonneg.2 hb)
rw [div_eq_mul_inv]
exact mul_nonpos_of_nonpos_of_nonneg ha (inv_nonneg.2 hb)
rw [div_eq_mul_inv]
exact mul_nonpos_of_nonneg_of_nonpos ha (inv_nonpos.2 hb)
rw [zpow_ofNat]
exact pow_nonneg ha _
rw [zpow_negSucc]
exact inv_nonneg.2 (pow_nonneg ha _)
rw [zpow_ofNat]
exact pow_pos ha _
rw [zpow_negSucc]
exact inv_pos.2 (pow_pos ha _)
rw [mul_comm, le_div_iff hc]
rw [div_mul_cancel _ (ne_of_lt hb).symm]
refine' (div_eq_iff (ne_of_gt hb)).mpr rfl
rw [mul_comm, div_le_iff hb]
rw [mul_comm, lt_div_iff hc]
rw [mul_comm, div_lt_iff hc]
rw [inv_eq_one_div, mul_comm, ← div_eq_mul_one_div]
exact div_le_iff' h
rw [inv_mul_le_iff h, mul_comm]
rw [mul_comm, inv_mul_le_iff h]
rw [mul_comm, inv_mul_le_iff' h]
simp [h]
simp [h]
rw [inv_eq_one_div, mul_comm, ← div_eq_mul_one_div]
exact div_lt_iff' h
rw [inv_mul_lt_iff h, mul_comm]
rw [mul_comm, inv_mul_lt_iff h]
rw [mul_comm, inv_mul_lt_iff' h]
rw [inv_eq_one_div]
exact div_le_iff ha
rw [inv_eq_one_div]
exact div_le_iff' ha
rw [inv_eq_one_div]
exact div_lt_iff ha
rw [inv_eq_one_div]
exact div_lt_iff' ha
rw [← one_div, div_le_iff ha, ← div_eq_inv_mul, le_div_iff hb, one_mul]
rw [← inv_le_inv hb (inv_pos.2 ha), inv_inv]
rw [← inv_le_inv (inv_pos.2 hb) ha, inv_inv]
rw [div_eq_mul_one_div a c, div_eq_mul_one_div b c]
exact mul_le_mul_of_nonneg_right h (one_div_nonneg.2 hc)
rw [div_eq_mul_inv, div_eq_mul_inv]
exact mul_le_mul_of_nonneg_left ((inv_le_inv (hc.trans_le h) hc).mpr h) ha
rw [div_eq_mul_one_div a c, div_eq_mul_one_div b c]
exact mul_lt_mul_of_pos_right h (one_div_pos.2 hc)
simp only [div_eq_mul_inv, mul_lt_mul_left ha, inv_lt_inv hb hc]
rw [lt_div_iff d0, div_mul_eq_mul_div, div_lt_iff b0]
rw [le_div_iff d0, div_mul_eq_mul_div, div_le_iff b0]
rw [div_le_div_iff (hd.trans_le hbd) hd]
exact mul_le_mul hac hbd hd.le hc
rw [le_div_iff hb, one_mul]
rw [div_le_iff hb, one_mul]
rw [lt_div_iff hb, one_mul]
rw [div_lt_iff hb, one_mul]
rw [div_add_div_same, ← two_mul, mul_div_cancel_left a two_ne_zero]
rw [← mul_two, mul_div_cancel a two_ne_zero]
rw [div_lt_iff (zero_lt_two' α)]
exact lt_mul_of_one_lt_right h one_lt_two
simp [lt_div_iff, mul_two]
simp [div_lt_iff, mul_two]
rw [div_mul_eq_div_mul_one_div, div_mul_eq_div_mul_one_div]
exact mul_le_mul_of_nonneg_right h (one_div_nonneg.2 he)
have : 0 < a / max (b + 1) 1 := div_pos h (lt_max_iff.2 (Or.inr zero_lt_one))
refine' ⟨a / max (b + 1) 1, this, _⟩
rw [← lt_div_iff this, div_div_cancel' h.ne']
exact lt_max_iff.2 (Or.inl <| lt_add_one _)
refine' (one_div_le_one_div _ _).mpr (pow_le_pow a1 mn) <;>
    exact pow_pos (zero_lt_one.trans_le a1) _
refine' (one_div_lt_one_div _ _).mpr (pow_lt_pow a1 mn) <;> exact pow_pos (trans zero_lt_one a1) _
simp [division_def, mul_pos_iff]
simp [division_def, mul_neg_iff]
simp [division_def, mul_nonneg_iff]
simp [division_def, mul_nonpos_iff]
rw [mul_comm, div_le_iff_of_neg hc]
rw [← neg_neg c, mul_neg, div_neg, le_neg, div_le_iff (neg_pos.2 hc), neg_mul]
rw [mul_comm, le_div_iff_of_neg hc]
rw [mul_comm, div_lt_iff_of_neg hc]
rw [mul_comm, lt_div_iff_of_neg hc]
rw [← one_div, div_le_iff_of_neg ha, ← div_eq_inv_mul, div_le_iff_of_neg hb, one_mul]
rw [← inv_le_inv_of_neg hb (inv_lt_zero.2 ha), inv_inv]
rw [← inv_le_inv_of_neg (inv_lt_zero.2 hb) ha, inv_inv]
rw [div_eq_mul_one_div a c, div_eq_mul_one_div b c]
exact mul_le_mul_of_nonpos_right h (one_div_nonpos.2 hc)
rw [div_eq_mul_one_div a c, div_eq_mul_one_div b c]
exact mul_lt_mul_of_neg_right h (one_div_neg.2 hc)
rw [le_div_iff_of_neg hb, one_mul]
rw [div_le_iff_of_neg hb, one_mul]
rw [lt_div_iff_of_neg hb, one_mul]
rw [div_lt_iff_of_neg hb, one_mul]
rw [mul_comm b c, ← div_sub_div _ _ hc hd, sub_lt_zero]
rw [mul_comm b c, ← div_sub_div _ _ hc hd, sub_nonpos]
subst a
have : b = 0 := le_antisymm (neg_nonneg.1 a0) b0
rw [this, neg_zero]
rw [abs_div, abs_one]
simp only [inv_nonneg, zpow_neg]
change 0 ≤ a ^ ((2 : ℕ) : ℤ)
rw [zpow_ofNat]
apply sq_nonneg
rw [← zpow_ofNat, ← zpow_add₀ ha₀.ne', hk, add_sub_cancel'_right]
rw [bit1, zpow_add_one₀ h.ne] <;> exact mul_neg_of_pos_of_neg (zpow_bit0_pos h.ne _) h
rw [le_iff_lt_or_eq, le_iff_lt_or_eq, zpow_bit1_neg_iff, zpow_eq_zero_iff (Int.bit1_ne_zero n)]
rw [← mul_le_mul_iff_left a]
simp
rw [← mul_le_mul_iff_left a]
simp
rw [← mul_le_mul_iff_left a]
simp
rw [← mul_le_mul_iff_left b, mul_inv_cancel_left]
rw [mul_inv_self]
rw [mul_inv_self]
rw [← mul_le_mul_iff_left b, mul_one, mul_inv_cancel_left]
rw [mul_one]
rw [← mul_lt_mul_iff_left a, mul_inv_self, mul_one]
rw [← mul_lt_mul_iff_left a, mul_inv_self, mul_one]
rw [← mul_lt_mul_iff_left a]
simp
rw [← mul_lt_mul_iff_left b, mul_inv_cancel_left]
rw [mul_inv_self]
rw [mul_inv_self]
rw [← mul_lt_mul_iff_left b, mul_one, mul_inv_cancel_left]
rw [mul_one]
rw [← mul_le_mul_iff_right a]
simp
rw [← mul_le_mul_iff_right a]
simp
rw [inv_mul_self]
rw [inv_mul_self]
rw [inv_mul_cancel_right]
rw [inv_mul_cancel_right]
rw [one_mul]
rw [← mul_le_mul_iff_right b, one_mul, inv_mul_cancel_right]
rw [one_mul]
rw [← mul_lt_mul_iff_right a, inv_mul_self, one_mul]
rw [← mul_lt_mul_iff_right a, inv_mul_self, one_mul]
rw [inv_mul_self]
rw [inv_mul_self]
rw [← mul_lt_mul_iff_right b, inv_mul_cancel_right]
rw [inv_mul_cancel_right]
rw [← mul_lt_mul_iff_right b, inv_mul_cancel_right, one_mul]
rw [← mul_lt_mul_iff_right b, one_mul, inv_mul_cancel_right]
rw [one_mul]
rw [← mul_le_mul_iff_left a, ← mul_le_mul_iff_right b]
simp
rw [← mul_le_mul_iff_left d, ← mul_le_mul_iff_right b, mul_inv_cancel_left, mul_assoc,
    inv_mul_cancel_right]
simp [div_eq_mul_inv]
simp [div_eq_mul_inv]
rw [← mul_lt_mul_iff_left a, ← mul_lt_mul_iff_right b]
simp
rw [← inv_lt_inv_iff, inv_inv]
rw [← inv_lt_inv_iff, inv_inv]
rw [← mul_lt_mul_iff_left d, ← mul_lt_mul_iff_right b, mul_inv_cancel_left, mul_assoc,
    inv_mul_cancel_right]
simp [div_eq_mul_inv]
rw [inv_mul_le_iff_le_mul, mul_comm]
rw [← inv_mul_le_iff_le_mul, mul_comm]
rw [mul_comm c, mul_inv_le_inv_mul_iff, mul_comm]
rw [inv_mul_lt_iff_lt_mul, mul_comm]
rw [← inv_mul_lt_iff_lt_mul, mul_comm]
rw [mul_comm c, mul_inv_lt_inv_mul_iff, mul_comm]
rw [← mul_le_mul_iff_right b, one_mul, div_eq_mul_inv, inv_mul_cancel_right]
rw [← mul_le_mul_iff_right b, one_mul, div_eq_mul_inv, inv_mul_cancel_right]
rw [← mul_le_mul_iff_right b, div_eq_mul_inv, inv_mul_cancel_right]
rw [← mul_le_mul_iff_right c, div_eq_mul_inv, inv_mul_cancel_right]
rw [le_div_iff_mul_le, mul_comm]
rw [div_le_iff_le_mul, mul_comm]
rw [inv_le_div_iff_le_mul, mul_comm]
rw [div_eq_mul_inv, div_eq_mul_inv, mul_comm b, mul_inv_le_inv_mul_iff, mul_comm]
exact mul_le_mul' hab hcd
rw [← mul_lt_mul_iff_right b, one_mul, div_eq_mul_inv, inv_mul_cancel_right]
rw [← mul_lt_mul_iff_right b, one_mul, div_eq_mul_inv, inv_mul_cancel_right]
rw [← mul_lt_mul_iff_right b, div_eq_mul_inv, inv_mul_cancel_right]
rw [← mul_lt_mul_iff_right c, div_eq_mul_inv, inv_mul_cancel_right]
rw [div_eq_mul_inv, lt_mul_inv_iff_mul_lt, inv_mul_lt_iff_lt_mul]
rw [lt_div_iff_mul_lt, mul_comm]
rw [div_lt_iff_lt_mul, mul_comm]
rw [div_eq_mul_inv, div_eq_mul_inv, mul_comm b, mul_inv_lt_inv_mul_iff, mul_comm]
exact mul_lt_mul_of_lt_of_lt hab hcd
rw [← cmp_mul_right' _ _ b, one_mul, div_mul_cancel']
rw [div_eq_mul_inv, mul_inv_le_inv_mul_iff]
exact
    ⟨fun h => not_lt.mp fun k => not_lt.mpr h (mul_lt_mul_of_lt_of_lt k k), fun h =>
      mul_le_mul' h h⟩
rw [div_eq_mul_inv b, mul_comm]
exact div_le_inv_mul_iff
simp <;> rw [C.pos_iff] <;> simp
simp [C.zero_nonneg]
simp [-sub_eq_add_neg] <;> rw [← sub_add_sub_cancel] <;> exact C.add_nonneg nbc nab
rw [neg_sub] <;> exact nab
rw [abs_eq_max_neg, max_comm, neg_neg, abs_eq_max_neg]
rw [← add_right_neg a]
apply add_le_add_left
exact neg_le_abs_self a
rw [abs_of_nonpos ha, abs_of_nonpos (hab.trans ha)]
exact neg_le_neg_iff.mpr hab
rw [neg_lt]
rw [abs_sub_comm]
exact max_sub_min_eq_abs' _ _
rw [abs_le', and_comm, neg_le]
rw [le_abs, or_comm, le_neg]
rw [sub_eq_add_neg, ← abs_neg b]
exact abs_add a _
rw [abs_le, neg_le_sub_iff_le_add, sub_le_iff_le_add', and_comm', sub_le_iff_le_add']
rw [abs_lt, neg_lt_sub_iff_lt_add', sub_lt_iff_lt_add', and_comm', sub_lt_iff_lt_add']
rw [sub_add_cancel]
rw [abs_sub_comm] <;> apply abs_sub_abs_le_abs_sub
simp [hbc.trans (le_abs_self c)]
simp [(neg_le_neg_iff.mpr hab).trans (neg_le_abs_self a)]
rw [sub_add_sub_cancel]
simp only [div_eq_mul_inv, min_mul_mul_left, min_inv_inv']
simp only [div_eq_mul_inv, max_mul_mul_left, max_inv_inv']
simp only [sub_le_iff_le_add, max_le_iff]
constructor
calc
    a = a - c + c := (sub_add_cancel a c).symm
    _ ≤ max (a - c) (b - d) + max c d := add_le_add (le_max_left _ _) (le_max_left _ _)
calc
    b = b - d + d := (sub_add_cancel b d).symm
    _ ≤ max (a - c) (b - d) + max c d := add_le_add (le_max_right _ _) (le_max_right _ _)
refine' abs_sub_le_iff.2 ⟨_, _⟩
· exact (max_sub_max_le_max _ _ _ _).trans (max_le_max (le_abs_self _) (le_abs_self _))
· rw [abs_sub_comm a c, abs_sub_comm b d]
    exact (max_sub_max_le_max _ _ _ _).trans (max_le_max (le_abs_self _) (le_abs_self _))
simp [← abv.map_mul]
rw [← abv.map_mul, neg_mul_neg, abv.map_mul]
rw [← neg_sub, abv.map_neg]
rw [abv.map_sub] <;> apply abv.le_sub
simp only [NonemptyInterval.pure_one, one_mul, ← id_def, Option.map_id, id]
simp only [NonemptyInterval.pure_one, mul_one, ← id_def, Option.map_id, id]
cases s
· simp [WithBot.none_eq_bot]
cases t
· simp [WithBot.none_eq_bot]
· simp [WithBot.some_eq_coe, ← NonemptyInterval.coe_mul_interval, NonemptyInterval.mul_eq_one_iff]
simp [sub_eq_add_neg]
simp
simp
simp only [zero, one, LinearOrderedCommMonoidWithZero.zero_le_one]
simp [ha]
simp [inv_ne_zero hb, hc, hd]
rw [ha, zero_mul, zero_lt_iff]
exact mul_ne_zero hb hd
rw [hc, mul_zero, zero_lt_iff]
exact mul_ne_zero hb hd
rw [mul_comm] at *
exact mul_inv_lt_of_lt_mul₀ h
simp only [mul_comm a]
exact mul_le_mul_right₀ ha
rw [div_eq_mul_inv, div_eq_mul_inv, mul_le_mul_right₀ (inv_ne_zero hc)]
simp only [div_eq_mul_inv, mul_le_mul_left₀ ha, inv_le_inv₀ hb hc]
rw [div_eq_mul_inv, le_mul_inv_iff₀ hc]
rw [div_eq_mul_inv, mul_inv_le_iff₀ hc]
rw [Nat.cast_id]
rfl
rw [Nat.cast_id]
rfl
rw [Nat.cast_one]
rw [le_floor_iff, Nat.cast_le]
exact n.cast_nonneg
rw [← Nat.cast_zero, floor_coe]
rw [← Nat.cast_one, floor_coe]
rw [← lt_one_iff, ← @cast_one α]
exact floor_lt' Nat.one_ne_zero
rw [← le_floor_iff ha, ← Nat.cast_one, ← Nat.cast_add, ← floor_lt ha, Nat.lt_add_one_iff,
    le_antisymm_iff, and_comm]
rw [← le_floor_iff' hn, ← Nat.cast_one, ← Nat.cast_add, ← floor_lt' (Nat.add_one_ne_zero n),
    Nat.lt_add_one_iff, le_antisymm_iff, and_comm]
rw [← Nat.lt_ceil, Nat.add_one_le_iff]
rw [← zero_add 1, Nat.add_one_le_ceil_iff, Nat.cast_zero]
rw [ceil_le, Nat.cast_add, Nat.cast_one]
exact (lt_floor_add_one a).le
rw [ceil_le, cast_le]
rw [← Nat.cast_zero, ceil_nat_cast]
rw [← Nat.cast_one, ceil_nat_cast]
rw [← le_zero_iff, ceil_le, Nat.cast_zero]
rw [lt_ceil, cast_zero]
rw [← ceil_le, ← not_le, ← ceil_le, not_le,
    tsub_lt_iff_right (Nat.add_one_le_iff.2 (pos_iff_ne_zero.2 hn)), Nat.lt_add_one_iff,
    le_antisymm_iff, and_comm]
rw [ceil_le, Nat.cast_add]
exact add_le_add (le_ceil _) (le_ceil _)
rw [Int.cast_id]
rfl
rw [Int.cast_id]
rfl
rw [neg_le, ← gc_coe_floor, Int.cast_neg, neg_le_neg_iff]
rw [le_neg, gc_ceil_coe, Int.cast_neg, neg_le_neg_iff]
simp [fract]
rw [le_floor, Int.cast_zero]
rw [← floor_lt, le_sub_one_iff]
rw [← zero_sub (1 : ℤ), floor_le_sub_one_iff, cast_zero]
rw [← @cast_le α, Int.cast_zero]
exact (floor_le a).trans ha
rw [le_floor, Int.cast_le]
rw [le_floor, ← cast_coe_nat, cast_le]
rw [← cast_zero, floor_int_cast]
rw [← cast_one, floor_int_cast]
rw [le_floor, ← sub_le_iff_le_add, ← sub_le_iff_le_add, le_floor, Int.cast_sub]
rw [le_floor, Int.cast_add]
exact add_le_add (floor_le _) (floor_le _)
rw [← sub_le_iff_le_add, le_floor, Int.cast_sub, sub_le_comm, Int.cast_sub, Int.cast_one]
refine' le_trans _ (sub_one_lt_floor _).le
rw [sub_le_iff_le_add', ← add_sub_assoc, sub_le_sub_iff_right]
exact floor_le _
rw [← Int.cast_ofNat, floor_add_int]
rw [← Int.cast_ofNat, floor_int_add]
rw [Int.cast_neg, sub_eq_add_neg]
rw [← Int.cast_ofNat, floor_sub_int]
rw [le_antisymm_iff, le_floor, ← Int.lt_add_one_iff, floor_lt, Int.cast_add, Int.cast_one,
    and_comm]
simp [floor_eq_iff]
rw [fract]
simp
rw [fract]
simp
rw [fract]
simp
rw [add_comm, fract_add_int]
rw [fract]
simp
rw [add_comm, fract_add_nat]
rw [fract, fract, fract, sub_add_sub_comm, sub_le_sub_iff_left, ← Int.cast_add, Int.cast_le]
exact le_floor_add _ _
rw [fract, floor_zero, cast_zero, sub_self]
simp [fract]
unfold fract
rw [floor_int_cast]
exact sub_self _
simp [fract]
rw [floor_eq_iff, Int.cast_zero, zero_add] <;> exact ⟨fract_nonneg _, fract_lt_one _⟩
unfold fract at h
rw [Int.cast_sub, sub_eq_sub_iff_sub_eq_sub.1 h]
simp
rw [zsmul_eq_mul, ← add_mul, fract_add_floor, div_mul_cancel b ha]
rw [← one_add_mul, ← div_lt_iff hb, add_comm]
exact lt_floor_add_one _
rw [le_neg, ceil_le, le_floor, Int.cast_neg, le_neg]
rw [neg_le, ceil_le, le_floor, Int.cast_neg, neg_le]
rw [← lt_ceil, add_one_le_iff]
rw [← zero_add (1 : ℤ), add_one_le_ceil_iff, cast_zero]
rw [ceil_le, Int.cast_add, Int.cast_one]
exact (lt_floor_add_one a).le
rw [ceil_le, Int.cast_le]
rw [ceil_le, ← cast_coe_nat, cast_le]
rw [← neg_inj, neg_add', ← floor_neg, ← floor_neg, neg_add', floor_sub_int]
rw [← Int.cast_ofNat, ceil_add_int]
rw [Int.cast_neg, sub_eq_add_neg]
rw [eq_sub_iff_add_eq, ← ceil_add_one, sub_add_cancel]
rw [← lt_ceil, ← Int.cast_one, ceil_add_int]
apply lt_add_one
rw [ceil_le, Int.cast_add]
exact add_le_add (le_ceil _) (le_ceil _)
rw [← le_sub_iff_add_le, ceil_le, Int.cast_sub, Int.cast_add, Int.cast_one, le_sub_comm]
refine' (ceil_lt_add_one _).le.trans _
rw [le_sub_iff_add_le', ← add_assoc, add_le_add_iff_right]
exact le_ceil _
rw [lt_ceil, cast_zero]
rw [← cast_zero, ceil_int_cast]
rw [← cast_one, ceil_int_cast]
rw [← ceil_le, ← Int.cast_one, ← Int.cast_sub, ← lt_ceil, Int.sub_one_lt_iff, le_antisymm_iff,
    and_comm]
simp [ceil_eq_iff]
simp
simp [round]
simp [round]
simp [round]
simp [round]
rw [round, round, Int.fract_add_int, Int.floor_add_int, Int.ceil_add_int, ← apply_ite₂, if_t_t]
rw [round, round, fract_add_nat, Int.floor_add_nat, Int.ceil_add_nat, ← apply_ite₂, if_t_t]
rw [add_comm, round_add_int, add_comm]
rw [add_comm, round_add_nat, add_comm]
simp only [lt_div_iff', two_pos]
simp only [round_eq, ← one_div, add_halves', floor_one]
simp only [round_eq, ← one_div, add_left_neg, floor_zero]
rw [← map_nat_cast f, hf.le_iff_le]
rw [← map_nat_cast f, hf.le_iff_le]
rw [← map_int_cast f, hf.le_iff_le]
rw [← map_int_cast f, hf.le_iff_le]
rw [Int.le_toNat (Int.floor_nonneg.2 ha), Int.le_floor, Int.cast_ofNat]
rw [Int.to_nat_le, Int.ceil_le, Int.cast_ofNat]
rw [← Int.floor_to_nat, Int.toNat_of_nonneg (Int.floor_nonneg.2 ha)]
rw [← Nat.cast_floor_eq_int_floor ha, Int.cast_ofNat]
rw [← Int.ceil_to_nat, Int.toNat_of_nonneg (Int.ceil_nonneg ha)]
rw [← Nat.cast_ceil_eq_int_ceil ha, Int.cast_ofNat]
refine' ⟨fun H₁ H₂ => _⟩
have : H₁.floor = H₂.floor :=
    funext fun a => (H₁.gc_coe_floor.u_unique H₂.gc_coe_floor) fun _ => rfl
have : H₁.ceil = H₂.ceil := funext fun a => (H₁.gc_ceil_coe.l_unique H₂.gc_ceil_coe) fun _ => rfl
cases H₁
cases H₂
congr <;> assumption
intro n hn
apply (zsmul_le_zsmul_iff ha).mp
rw [← coe_nat_zsmul] at hk
exact le_trans hn hk
rw [add_comm]
rw [Int.cast_neg] <;> exact neg_lt.1 h
rw [hn0, pow_zero] at hn <;> exact not_le_of_gt hn hx
rw [zpow_neg y ↑N, zpow_ofNat]
exact (inv_lt hx (lt_trans (inv_pos.2 hx) hN)).1 hN
rw [Rat.cast_id]
rw [smul_zero]
cases n
· simp only [Int.ofNat_eq_coe, Int.coe_nat_pos, coe_nat_zsmul] at hn⊢
      exact strict_mono_smul_left hn
· cases (Int.negSucc_not_pos _).1 hn
refine' fun a b c hab hc => (h hab hc).lt_of_ne _
rw [Ne.def, hc.ne'.is_unit.smul_left_cancel]
exact hab.ne
rw [← smul_le_smul_iff_of_pos h, smul_inv_smul₀ h.ne']
infer_instance
rw [← smul_lt_smul_iff_of_pos h, smul_inv_smul₀ h.ne']
infer_instance
rw [← smul_le_smul_iff_of_pos h, smul_inv_smul₀ h.ne']
infer_instance
rw [← smul_lt_smul_iff_of_pos h, smul_inv_smul₀ h.ne']
infer_instance
rw [← hs.upper_closure_inter_lower_closure, smul_set_inter]
exact (upperClosure _).upper.smul.OrdConnected.inter (lowerClosure _).lower.smul.OrdConnected
rw [← smul_eq_mul, ← bUnion_smul_set]
exact is_upper_set_Union₂ fun x hx => ht.smul
rw [mul_comm]
exact hs.mul_left
rw [div_eq_mul_inv]
exact ht.inv.mul_left
rw [div_eq_mul_inv]
exact hs.mul_right
rw [← smul_eq_mul, ← bUnion_smul_set]
exact Union₂_subset fun _ => s.upper.smul_subset
rw [mul_comm]
exact one_mul _
rw [← smul_eq_mul, ← bUnion_smul_set]
exact Union₂_subset fun _ => s.lower.smul_subset
rw [mul_comm]
exact one_mul _
rw [UpperSet.coe_mul, mul_upper_closure, upper_closure_mul, UpperSet.upper_closure]
rw [LowerSet.coe_mul, mul_lower_closure, lower_closure_mul, LowerSet.lower_closure]
simp only [mul_invOf_self, zero_lt_one]
simp only [← not_lt, invOf_pos]
simp only [mul_invOf_self, zero_lt_one]
simp only [← not_le, invOf_nonneg]
simp
simp
simp
simp
simp
simp
apply le_antisymm
· refine' le_inf _ _
    · rw [inv_le_inv_iff]
      exact le_sup_left
    · rw [inv_le_inv_iff]
      exact le_sup_right
· rw [← inv_le_inv_iff, inv_inv]
    refine' sup_le _ _
    · rw [← inv_le_inv_iff]
      simp
    · rw [← inv_le_inv_iff]
      simp
rw [inv_inf_eq_sup_inv, sup_comm]
rw [mul_comm, inv_mul_cancel_right]
rw [m_neg_part_def, inv_one, sup_idem]
rw [m_neg_part_def, ← inv_inj, inv_sup_eq_inv_inf_inv, inv_inv, inv_inv, inv_one]
rw [m_pos_part_def, sup_le_iff]
simp
rw [m_neg_part_def, sup_le_iff]
simp
rw [le_antisymm_iff]
simp only [one_le_pos, and_true_iff]
exact pos_le_one_iff
rw [le_antisymm_iff]
simp only [one_le_neg, and_true_iff]
rw [neg_le_one_iff]
rw [le_antisymm_iff]
simp only [one_le_neg, and_true_iff]
rw [neg_le_one_iff, inv_le_one']
simp [neg_eq_pos_inv]
simp
rw [mul_one b, div_eq_mul_inv, mul_comm a, mul_inv_cancel_left]
rw [← mul_sup (a / b) 1 b]
rw [mul_one a, div_eq_mul_inv, mul_comm b, mul_inv_cancel_left]
rw [← mul_inf_eq_mul_inf_mul 1 (b / a) a]
rw [inf_comm]
rw [inv_one]
rw [← inv_sup_eq_inv_inf_inv, ← div_eq_mul_inv]
constructor <;> intro h
· constructor
    · exact sup_le (h.trans (m_le_pos b)) (one_le_pos b)
    · rw [← inv_le_inv_iff] at h
      exact sup_le (h.trans (inv_le_neg a)) (one_le_neg a)
· rw [← pos_div_neg a, ← pos_div_neg b]
    exact div_le_div'' h.1 h.2
refine' le_antisymm _ _
· rw [← pos_inf_neg_eq_one a]
    apply le_inf
    · rw [pos_eq_neg_inv]
      exact ((m_le_iff_pos_le_neg_ge _ _).mp (inv_le_abs a)).right
    · exact And.right (Iff.mp (m_le_iff_pos_le_neg_ge _ _) (le_mabs a))
· exact one_le_neg _
rw [← m_pos_abs]
exact one_le_pos _
rw [← inf_mul_sup a b, ← sup_div_inf_eq_abs_div, div_eq_mul_inv, ← mul_assoc, mul_comm, mul_assoc,
    ← pow_two, inv_mul_cancel_left]
rw [← inf_mul_sup a b, ← sup_div_inf_eq_abs_div, div_eq_mul_inv, div_eq_mul_inv, mul_inv_rev,
    inv_inv, mul_assoc, mul_inv_cancel_comm_assoc, ← pow_two]
rw [sup_div_inf_eq_abs_div]
rw [div_mul_div_comm]
rw [div_eq_mul_inv, mul_inv_rev, mul_assoc, mul_inv_cancel_left, ← div_eq_mul_inv]
rw [sup_div_inf_eq_abs_div]
rw [m_pos_part_def]
exact sup_of_le_left h
rw [m_pos_part_def, right_lt_sup, not_le] at hx
rw [m_pos_part_def, sup_eq_left]
exact hx.le
rw [neg_eq_pos_inv]
exact pos_of_one_le _ h
refine' neg_of_one_le_inv _ _
rw [one_le_inv']
exact h
unfold Abs.abs
rw [sup_eq_mul_pos_div, div_eq_mul_inv, inv_inv, ← pow_two, inv_mul_eq_iff_eq_mul, ← pow_two,
    pos_of_one_le]
rw [pow_two]
apply one_le_mul h h
apply le_of_mul_le_of_one_le_left
· rw [abs_div_sup_mul_abs_div_inf]
· exact one_le_abs _
apply le_of_mul_le_of_one_le_right
· rw [abs_div_sup_mul_abs_div_inf]
· exact one_le_abs _
apply sup_le
· exact mul_le_mul' (le_mabs a) (le_mabs b)
· rw [mul_inv]
    exact mul_le_mul' (inv_le_abs _) (inv_le_abs _)
unfold Abs.abs
rw [inv_div a b, ← inv_inv (a / b), inv_div, sup_comm]
simp [*, -nsmul_eq_mul, nsmul_coe]
refine' (FloorSemiring.gc_floor (show 0 ≤ (a : α) from ha)).trans _
rw [← Subtype.coe_le_coe, Nonneg.coe_nat_cast]
refine' (FloorSemiring.gc_ceil (a : α) n).trans _
rw [← Subtype.coe_le_coe, Nonneg.coe_nat_cast]
simp [Nat.cast]
simp [Nat.cast] <;> rfl
infer_instance
infer_instance
simp [to_nonneg, h]
cases a <;> rfl
cases a <;> cases b <;> simp [none_eq_top, some_eq_coe, ← WithTop.coe_add]
simp [none_eq_top]
simp [none_eq_top]
simp only [some_eq_coe, ← coe_add, coe_eq_coe, exists_and_left, exists_eq_left]
induction x using WithTop.recTopCoe <;> simp [← coe_add]
induction y using WithTop.recTopCoe <;> simp [← coe_add]
induction a using WithTop.recTopCoe
· exact (not_none_lt _ h).elim
induction b using WithTop.recTopCoe
· exact (not_none_lt _ h).elim
induction c using WithTop.recTopCoe
· exact coe_lt_top _
· exact coe_lt_coe.2 (lt_of_add_lt_add_left <| coe_lt_coe.1 h)
cases a <;> cases b <;> try exact (not_none_lt _ h).elim
cases c
· exact coe_lt_top _
· exact coe_lt_coe.2 (lt_of_add_lt_add_right <| coe_lt_coe.1 h)
induction a using WithTop.recTopCoe
· exact (top_add _).symm
· induction b using WithTop.recTopCoe
    · exact (add_top _).symm
    · rw [map_coe, map_coe, ← coe_add, ← coe_add, ← map_add]
      rfl
refine' WithTop.recTopCoe _ _
· simp
· intro
        rw [← WithTop.coe_zero, ← WithTop.coe_add, zero_add]
refine' WithTop.recTopCoe _ _
· simp
· intro
        rw [← WithTop.coe_zero, ← WithTop.coe_add, add_zero]
rw [Nat.cast_zero, WithTop.coe_zero]
rw [Nat.cast_add_one, WithTop.coe_add, WithTop.coe_one]
simp
rw [WithTop.map_one, map_one, coe_one]
cases a <;> rfl
rw [WithBot.map_one, map_one, coe_one]
rw [mul, mul]
apply mul_le_mul_left'
exact ab
simp only [WithZero.coe_le_coe, le_max_iff]
simp only [WithZero.coe_le_coe, min_le_iff]
apply WithZero.cases_on a
· exact bot_le
apply WithZero.cases_on b
· exact fun b' => le_rfl
· exact fun a' b' => WithZero.coe_le_coe.2 le_self_add
rw [mul_comm]
exact le_self_mul
simp only [one_lt_iff_ne_one, Ne.def, mul_eq_one_iff, not_and_or]
simp
simp
rw [mul_one]
rw [one_mul]
rw [mul_one]
rw [one_mul]
rw [mul_one]
rw [one_mul]
rw [mul_one]
rw [one_mul]
rw [ha', hb', mul_one]
rw [mul_comm b, mul_comm c, ha.mul_le_mul_iff_left]
rw [mul_one]
rw [mul_one]
rw [mul_comm, ha.le_mul_iff_one_le_right]
rw [mul_comm, ha.mul_le_iff_le_one_right]
rw [← image_inv]
exact ((OrderIso.inv α).map_cInf' hs₀ hs₁).symm
rw [← image_inv]
exact ((OrderIso.inv α).map_cSup' hs₀ hs₁).symm
rw [div_eq_mul_inv, cSup_mul hs₀ hs₁ ht₀.inv ht₁.inv, cSup_inv ht₀ ht₁, div_eq_mul_inv]
rw [div_eq_mul_inv, cInf_mul hs₀ hs₁ ht₀.inv ht₁.inv, cInf_inv ht₀ ht₁, div_eq_mul_inv]
rw [← image_inv, Sup_image]
exact ((OrderIso.inv α).map_Inf _).symm
rw [← image_inv, Inf_image]
exact ((OrderIso.inv α).map_Sup _).symm
simp [← hfg.sum_smul_comp_perm_eq_sum_smul_iff hσ, lt_iff_le_and_ne,
    hfg.sum_smul_comp_perm_le_sum_smul hσ]
simp only [set_support_inv_eq, hσ]
simp [← hfg.sum_comp_perm_smul_eq_sum_smul_iff hσ, lt_iff_le_and_ne,
    hfg.sum_comp_perm_smul_le_sum_smul hσ]
simp [← hfg.sum_smul_eq_sum_smul_comp_perm_iff hσ, lt_iff_le_and_ne, eq_comm,
    hfg.sum_smul_le_sum_smul_comp_perm hσ]
simp [← hfg.sum_smul_eq_sum_comp_perm_smul_iff hσ, eq_comm, lt_iff_le_and_ne,
    hfg.sum_smul_le_sum_comp_perm_smul hσ]
simp [(hfg.monovary_on _).sum_smul_comp_perm_eq_sum_smul_iff fun i _ => mem_univ _]
simp [(hfg.monovary_on _).sum_smul_comp_perm_lt_sum_smul_iff fun i _ => mem_univ _]
simp [(hfg.monovary_on _).sum_comp_perm_smul_eq_sum_smul_iff fun i _ => mem_univ _]
simp [(hfg.monovary_on _).sum_comp_perm_smul_lt_sum_smul_iff fun i _ => mem_univ _]
simp [(hfg.antivary_on _).sum_smul_eq_sum_smul_comp_perm_iff fun i _ => mem_univ _]
simp [(hfg.antivary_on _).sum_smul_lt_sum_smul_comp_perm_iff fun i _ => mem_univ _]
simp [(hfg.antivary_on _).sum_smul_eq_sum_comp_perm_smul_iff fun i _ => mem_univ _]
simp [(hfg.antivary_on _).sum_smul_lt_sum_comp_perm_smul_iff fun i _ => mem_univ _]
simp
contradiction
rw [irreducible_sq_not_dvd_iff_eq_zero_and_no_irreducibles_or_squarefree, ← not_exists]
simp only [hr, not_true, false_or_iff, and_false_iff]
intro h'
rw [quadratic_eq_zero_iff_discrim_eq_sq h2 ha, sq] at h'
exact h _ h'
rw [h, mul_zero]
rw [quadratic_eq_zero_iff_of_discrim_eq_zero ha h' (-b / (2 * a))]
simp
simp
rw [Int.cast_neg, Int.cast_ofNat, coe_neg]
rw [← coe_commutes, coe_mul_eq_smul]
rw [coe_mul, coe_mul_eq_smul]
simp
rw [conj_mul, conj_conj]
rw [conj_mul, conj_conj]
simp only [self_add_conj', two_mul, coe_add]
rw [add_comm, self_add_conj']
rw [add_comm, self_add_conj]
rw [a.conj_eq_two_re_sub]
exact (coe_commute (2 * a.re) a).sub_left (Commute.refl a)
rw [h.eq]
rw [h, coe_re]
simp [ext_iff, neg_eq_iff_add_eq_zero, add_self_eq_zero]
rw [a.commute_self_conj.eq]
exact a.conj_mul_eq_coe
simp
simp
simp only [one_mul, neg_mul, sub_eq_add_neg, neg_neg]
simp only [one_mul, neg_mul, sub_eq_add_neg, neg_neg]
simp only [one_mul, neg_mul, sub_eq_add_neg, neg_neg]
simp only [one_mul, neg_mul, sub_eq_add_neg, neg_neg]
rw [conj_zero, zero_mul, zero_re]
rw [conj_one, one_mul, one_re]
simp only [norm_sq_def, sq, mul_neg, sub_neg_eq_add, mul_re, conj_re, conj_im_i, conj_im_j,
    conj_im_k]
rw [norm_sq_def, conj_coe, ← coe_mul, coe_re, sq]
simp only [norm_sq_def, conj_neg, neg_mul_neg]
rw [mul_conj_eq_coe, norm_sq_def]
rw [← a.commute_self_conj.eq, self_mul_conj]
simp [← self_mul_conj, mul_add, add_mul, add_assoc]
refine' ⟨fun h => _, fun h => h.symm ▸ norm_sq.map_zero⟩
rw [norm_sq_def', add_eq_zero_iff', add_eq_zero_iff', add_eq_zero_iff'] at h
exact ext a 0 (pow_eq_zero h.1.1.1) (pow_eq_zero h.1.1.2) (pow_eq_zero h.1.2) (pow_eq_zero h.2)
all_goals
    trace
      "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr sq_nonneg, \",\", expr add_nonneg, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
rw [norm_sq_def']
trace
    "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr sq_nonneg, \",\", expr add_nonneg, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
rw [has_inv_inv, conj_zero, smul_zero]
rw [has_inv_inv, Algebra.mul_smul_comm, self_mul_conj, smul_coe,
        inv_mul_cancel (norm_sq_ne_zero.2 ha), coe_one]
simp
rw [mk_quaternion_algebra, pow_four]
rw [mk_univ, mk_quaternion_algebra]
rw [mk_univ_quaternion_algebra, pow_four]
rw [mk_quaternion, pow_four]
rw [mk_univ_quaternion, pow_four]
rfl
rfl
rw [sym_mul_sym, mul_invOf_self, invOf_mul_self, ← bit0, invOf_mul_self, sym_one]
rw [sym_mul_sym, mul_invOf_self, invOf_mul_self, ← bit0, invOf_mul_self, sym_one]
rw [mul_def, unsym_zero, zero_mul, mul_zero, add_zero, mul_zero, sym_zero]
rw [mul_def, unsym_zero, zero_mul, mul_zero, add_zero, mul_zero, sym_zero]
rw [mul_def, unsym_one, mul_one, one_mul, ← two_mul, invOf_mul_self_assoc, sym_unsym]
rw [mul_def, unsym_one, mul_one, one_mul, ← two_mul, invOf_mul_self_assoc, sym_unsym]
rw [sym_mul_sym, sym_mul_sym, ← sym_add, sym_mul_sym, ← sym_add, mul_add a, add_mul _ _ a,
          add_add_add_comm, mul_add]
rw [sym_mul_sym, sym_mul_sym, ← sym_add, sym_mul_sym, ← sym_add, mul_add c, add_mul _ _ c,
          add_add_add_comm, mul_add]
rw [mul_def, unsym_sym, ← two_mul, invOf_mul_self_assoc]
rw [sym_mul_sym, ← two_mul, invOf_mul_self_assoc]
rw [mul_def, mul_def, add_comm]
rw [Int.natAbs_of_nonneg (Int.emod_nonneg _ b0), ← Int.abs_eq_natAbs]
exact Int.emod_lt _ b0
rw [← mul_one a.nat_abs, Int.natAbs_mul]
exact mul_le_mul_of_nonneg_left (Int.natAbs_pos_of_ne_zero b0) (Nat.zero_le _)
simp [hnb]
rw [mul_comm]
exact mod_add_div _ _
rw [mul_comm]
exact div_add_mod _ _
rw [div_add_mod]
rw [mul_comm]
exact mul_left_not_lt b h
rw [gcd]
exact if_pos rfl
unfold xgcd_aux
exact if_pos rfl
conv => 
    lhs
    rw [xgcd_aux]
exact if_neg h
unfold gcd_a
rw [xgcd, xgcd_zero_left]
unfold gcd_b
rw [xgcd, xgcd_zero_left]
have := mul_left_not_lt a h
rw [mul_sub, sub_eq_iff_eq_add'.2 (div_add_mod (a * b) a).symm] at this
exact this (mod_lt _ a0)
rw [mul_comm]
exact mul_div_cancel_left a b0
rw [← div_add_mod a b, h, add_zero]
exact dvd_mul_right _ _
rw [dvd_add_iff_right (h.mul_right _), div_add_mod]
rw [← h, mul_div_cancel _ hb]
rw [← h, mul_div_cancel_left _ ha]
rw [gcd_zero_left]
exact ⟨dvd_zero _, dvd_rfl⟩
rw [gcd_val]
exact ⟨IH₂, (dvd_mod_iff IH₂).1 IH₁⟩
rw [gcd_val]
exact IH ((dvd_mod_iff ca).2 cb) ca
rw [← h]
apply gcd_dvd_right
rw [gcd_val, mod_eq_zero.2 h, gcd_zero_left]
intros
rw [xgcd_zero_left, gcd_zero_left]
simp only [xgcd_aux_rec h, if_neg h, IH]
rw [← gcd_val]
rw [xgcd, ← xgcd_aux_fst x y 1 0 0 1, Prod.mk.eta]
rw [xgcd_aux_rec h]
refine' IH _ p
unfold P at p p'⊢
rw [mul_sub, mul_sub, add_sub, sub_add_eq_add_sub, ← p', sub_sub, mul_comm _ s, ← mul_assoc,
      mul_comm _ t, ← mul_assoc, ← add_mul, ← p, mod_eq_sub_mul_div]
rw [P, mul_one, mul_zero, add_zero]
rw [P, mul_one, mul_zero, zero_add]
rw [← mul_div_cancel a h0.2, h, zero_div]
rw [lcm, hxy, div_zero]
exact dvd_zero _
rw [mul_right_comm, mul_assoc, ← hz]
rw [lcm, hxy, div_zero]
exact dvd_zero _
rw [← mul_assoc, mul_right_comm, ← hz]
rw [lcm]
rw [lcm, zero_mul, zero_div]
rw [lcm, mul_zero, zero_div]
constructor
· intro hxy
    rw [lcm, mul_div_assoc _ (gcd_dvd_right _ _), mul_eq_zero] at hxy
    apply or_of_or_of_imp_right hxy
    intro hy
rw [lcm]
rw [h]
rw [Submodule.supr_eq_range_dfinsupp_lsum, LinearMap.range_eq_top]
exact Function.Bijective.surjective h
simp
rw [← Sup_pair, supr, ← Set.image_univ, h, Set.image_insert_eq, Set.image_singleton]
simp only [AddMonoidHom.map_zero, AddMonoidHom.zero_apply]
simp only [AddMonoidHom.map_zero]
simp only [AddMonoidHom.map_add]
simp only [AddMonoidHom.map_add, AddMonoidHom.add_apply]
unfold MulHom
rw [to_add_monoid_of, flip_apply, to_add_monoid_of, flip_apply, coe_comp, Function.comp_apply,
    comp_hom_apply_apply, coe_comp, Function.comp_apply, gmul_hom_apply_apply]
rw [gsemiring.nat_cast_zero, map_zero]
rw [gsemiring.nat_cast_succ, map_add]
rfl
induction l
· simp only [List.map_nil, List.prod_nil, List.dprod_nil]
    rfl
· simp only [List.map_cons, List.prod_cons, List.dprod_cons, ← l_ih, DirectSum.of_mul_of]
    rfl
rw [List.of_fn_eq_map, of_list_dprod]
simp only [mul_eq_dfinsupp_sum, Dfinsupp.sum, Finset.sum_product]
suffices mulHom A = (mulHom A).flip from AddMonoidHom.congr_fun (AddMonoidHom.congr_fun this a) b
apply add_hom_ext
intro ai ax
apply add_hom_ext
intro bi bx
rw [AddMonoidHom.flip_apply, mul_hom_of_of, mul_hom_of_of]
exact of_eq_of_graded_monoid_eq (gcomm_semiring.mul_comm ⟨ai, ax⟩ ⟨bi, bx⟩)
rw [pow_zero, pow_zero, DirectSum.of_zero_one]
rw [pow_succ, pow_succ, of_zero_mul, of_zero_pow]
change (to_add_monoid f) (of _ 0 _) = 1
rw [to_add_monoid_of]
exact hone
simp only [AddMonoidHom.comp_apply, [anonymous]]
rw [← F.map_one]
rfl
simp only [AddMonoidHom.comp_apply, [anonymous]]
rw [← F.map_mul, of_mul_of]
rw [DirectSum.of_mul_of, Mul.ghas_mul_mul]
rw [← decompose_symm_of, Equiv.apply_symm_apply]
rw [decompose_of_mem _ hx, DirectSum.of_eq_same, Subtype.coe_mk]
rw [decompose_of_mem _ hx, DirectSum.of_eq_of_ne _ _ _ _ hij, ZeroMemClass.coe_zero]
infer_instance
simp only [AddMonoidHom.comp_apply]
rw [of_mul_of]
apply Dfinsupp.single_eq_of_sigma_eq (galgebra.map_mul a b)
infer_instance
infer_instance
rw [Algebra.algebra_map_eq_smul_one]
exact (A 0).smul_mem s <| SetLike.one_mem_graded _
induction n
· rw [Nat.cast_zero]
    exact zero_mem (A 0)
· rw [Nat.cast_succ]
    exact add_mem n_ih (SetLike.one_mem_graded _)
induction z
· rw [Int.cast_of_nat]
    exact SetLike.nat_cast_mem_graded _ _
· rw [Int.cast_negSucc]
    exact neg_mem (SetLike.nat_cast_mem_graded _ _)
rw [eq_tsub_iff_add_eq_of_le h, add_comm]
rw [← one_le, pow_zero]
exact le_rfl
rw [pow_add]
exact Submodule.mul_mem_mul hp hq
rw [from_add_monoid, to_add_monoid_of]
rfl
rw [from_add_monoid_of, AddMonoidHom.coe_comp]
rw [AddMonoidHom.map_zero, AddMonoidHom.map_zero]
rw [Unique.default_eq p, to_add_monoid_of] <;> rfl
rw [AddMonoidHom.map_add, AddMonoidHom.map_add, ihx, ihy]
rw [AddSubmonoid.supr_eq_mrange_dfinsupp_sum_add_hom, AddMonoidHom.mrange_top_iff_surjective]
exact Function.Bijective.surjective h
infer_instance
infer_instance
simp
simp
infer_instance
intros
simp only [preadditive.add_comp]
intros
simp only [preadditive.comp_add]
refine' Quot.lift (colimit_inv_aux F) _ x
intro x y h
apply colimit_inv_aux_eq_of_rel
apply types.filtered_colimit.rel_of_quot_rel
exact h
intros
rw [RingHom.id_apply, g.to_fun_eq_coe, map_zsmul]
intros
rw [RingHom.id_apply, f.to_fun_eq_coe, map_zsmul]
rw [mono_iff_injective]
intro _ _ h
exact ((ModuleCat.mono_iff_injective f).mp m) h
induction x
dsimp
apply Quot.sound
apply relation.zero_add
rfl
induction x
dsimp
apply Quot.sound
apply relation.add_zero
rfl
induction x
dsimp
apply Quot.sound
apply relation.add_left_neg
rfl
induction x
induction y
dsimp
apply Quot.sound
apply relation.add_comm
rfl
rfl
induction x
induction y
induction z
dsimp
apply Quot.sound
apply relation.add_assoc
rfl
rfl
rfl
apply Quot.sound <;> apply relation.zero
  map_add'
intros <;> apply Quot.sound <;> apply relation.add
rw [← cocone_naturality F f]
rfl
induction x <;> induction y <;> rfl
intro x H_1
cases H_1
induction H_1_h
simp only [cokernel.condition_apply, zero_apply]
rw [int_smul_eq_zsmul, int_smul_eq_zsmul, map_zsmul, RingHom.id_apply]
simp [h]
change Group (F.obj j)
infer_instance
simp only [forget_map_eq_coe, functor.comp_map, Pi.inv_apply, MonoidHom.map_inv, inv_inj]
dsimp [functor.sections] at ah
rw [ah f]
change Group (sections_subgroup F)
infer_instance
apply is_limit.unique_up_to_iso (MonCat.HasLimits.limitConeIsLimit _) t
      makesLimit
infer_instance
change CommGroup (F.obj j)
infer_instance
apply is_limit.unique_up_to_iso (GroupCat.limitConeIsLimit _) t
      makesLimit
apply MonCat.HasLimits.limitConeIsLimit _
infer_instance
infer_instance
change (kernel.ι f) g ∈ f.ker
simp [AddMonoidHom.mem_ker]
simp
rw [h]
change from_coset _ = from_coset _
simp only [← Subtype.val_eq_coe, left_coset_assoc]
change from_coset _ = from_coset _
simp only [← Subtype.val_eq_coe, one_left_coset, Subtype.ext_iff_val]
rw [tau, Equiv.symm_swap, Equiv.swap_apply_left]
rw [tau, Equiv.symm_swap, Equiv.swap_apply_right]
dsimp only
rw [← mul_smul, mul_left_inv, one_smul]
dsimp only
rw [← mul_smul, mul_right_inv, one_smul]
simp [H, τ_symm_apply_from_coset, g_apply_infinity, τ_apply_infinity]
simp
simp
simp [H, tau, g_apply_infinity]
rw [← eq1, ← eq2, FunLike.congr_fun hb]
simp [← agree]
refine' ⟨_, Group_AddGroup_equivalence.inverse.epi_of_epi_map⟩
intro e'
apply Group_AddGroup_equivalence.inverse.map_epi
rw [epi_iff_range_eq_top, MonoidHom.range_top_iff_surjective]
cases R
exact localization_unit_is_iso _
cases R
exact IsLocalization.epi M _
infer_instance
induction x
dsimp
apply Quot.sound
apply relation.zero_add
rfl
induction x
dsimp
apply Quot.sound
apply relation.add_zero
rfl
induction x
dsimp
apply Quot.sound
apply relation.add_left_neg
rfl
induction x
induction y
induction z
dsimp
apply Quot.sound
apply relation.add_assoc
rfl
rfl
rfl
induction x
dsimp
apply Quot.sound
apply relation.one_mul
rfl
induction x
dsimp
apply Quot.sound
apply relation.mul_one
rfl
induction x
induction y
dsimp
apply Quot.sound
apply relation.add_comm
rfl
rfl
induction x
induction y
dsimp
apply Quot.sound
apply relation.mul_comm
rfl
rfl
induction x
induction y
induction z
dsimp
apply Quot.sound
apply relation.add_assoc
rfl
rfl
rfl
induction x
induction y
induction z
dsimp
apply Quot.sound
apply relation.mul_assoc
rfl
rfl
rfl
induction x
induction y
induction z
dsimp
apply Quot.sound
apply relation.left_distrib
rfl
rfl
rfl
induction x
induction y
induction z
dsimp
apply Quot.sound
apply relation.right_distrib
rfl
rfl
rfl
apply Quot.sound <;> apply relation.one
  map_mul'
intros <;> apply Quot.sound <;> apply relation.mul
  map_zero'
apply Quot.sound <;> apply relation.zero
  map_add'
intros <;> apply Quot.sound <;> apply relation.add
rw [← cocone_naturality F f]
rfl
induction x <;> induction y <;> rfl
induction x <;> induction y <;> rfl
simp [h]
infer_instance
rw [← f.map_one, ← f.map_zero]
congr
infer_instance
have : _ = limit.π F (walking_parallel_pair_op_equiv.functor.obj _) :=
    (limit.iso_limit_cone_inv_π
        ⟨_, is_limit.whisker_equivalence (limit.is_limit F) walking_parallel_pair_op_equiv⟩
        walking_parallel_pair.zero :
      _)
erw [← this]
infer_instance
change Semiring (F.obj j)
infer_instance
change CommSemiring (F.obj j)
infer_instance
apply is_limit.unique_up_to_iso (SemiRingCat.HasLimits.limitConeIsLimit _) t
      makesLimit
apply SemiRingCat.HasLimits.limitConeIsLimit _
infer_instance
change Ring (F.obj j)
infer_instance
apply is_limit.unique_up_to_iso (SemiRingCat.HasLimits.limitConeIsLimit _) t
      makesLimit
apply SemiRingCat.HasLimits.limitConeIsLimit _
infer_instance
change CommRing (F.obj j)
infer_instance
apply is_limit.unique_up_to_iso (RingCat.limitConeIsLimit _) t
      makesLimit
infer_instance
intros
exact Finsupp.lmap_domain_id _ _
intros
exact Finsupp.lmap_domain_comp _ _ _ _
dsimp
infer_instance
dsimp
infer_instance
dsimp
    -- This imitates the proof of associativity for `monoid_algebra`.
simp only [sum_sum_index, sum_single_index, single_zero, single_add, eq_self_iff_true,
      forall_true_iff, forall₃_true_iff, add_mul, mul_add, category.assoc, mul_assoc, zero_mul,
      mul_zero, sum_zero, sum_add]
dsimp
rw [Finsupp.sum_add_index] <;> · simp [add_mul]
dsimp
rw [Finsupp.sum_smul_index] <;> simp [Finsupp.smul_sum, mul_assoc]
dsimp
simp
simp
dsimp [CategoryTheory.categoryFree]
simp
apply Finsupp.induction_linear f
· simp only [limits.zero_comp, sum_zero_index]
· intro f₁ f₂ w₁ w₂
      rw [add_comp]
      rw [Finsupp.sum_add_index, Finsupp.sum_add_index]
      · simp only [w₁, w₂, add_comp]
      · intros
        rw [zero_smul]
      · intros
        simp only [add_smul]
      · intros
        rw [zero_smul]
      · intros
        simp only [add_smul]
· intro f' r
      apply Finsupp.induction_linear g
      · simp only [limits.comp_zero, sum_zero_index]
      · intro f₁ f₂ w₁ w₂
        rw [comp_add]
        rw [Finsupp.sum_add_index, Finsupp.sum_add_index]
        · simp only [w₁, w₂, comp_add]
        · intros
          rw [zero_smul]
        · intros
          simp only [add_smul]
        · intros
          rw [zero_smul]
        · intros
          simp only [add_smul]
      · intro g' s
        erw [single_comp_single]
        simp [mul_comm r s, mul_smul]
simp
dsimp
rw [Finsupp.sum_add_index] <;> simp [add_smul]
dsimp
rw [Finsupp.sum_smul_index] <;> simp [Finsupp.smul_sum, mul_smul]
intro X Y f
apply Finsupp.induction_linear f
· simp
· intro f₁ f₂ w₁ w₂
        simp only [F.map_add, G.map_add, add_comp, comp_add, w₁, w₂]
· intro f' r
        rw [iso.app_hom, iso.app_hom, ← smul_single_one, F.map_smul, G.map_smul, smul_comp,
          comp_smul]
        change r
rw [abelian.exact_iff' f g (kernel_is_limit _) (cokernel_is_colimit _)]
exact
    ⟨fun h => le_antisymm (range_le_ker_iff.2 h.1) (ker_le_range_iff.2 h.2), fun h =>
      ⟨range_le_ker_iff.1 <| le_of_eq h, ker_le_range_iff.1 <| le_of_eq h.symm⟩⟩
refine' Quot.lift (colimit_smul_aux F r) _ x
intro x y h
apply colimit_smul_aux_eq_of_rel
apply types.filtered_colimit.rel_of_quot_rel
exact h
erw [colimit_zero_eq _ (is_filtered.nonempty.some : J), colimit_smul_mk_eq, smul_zero]
rfl
erw [colimit_smul_mk_eq F r ⟨j, x⟩]
rfl
simp [← mul_smul, mul_comm]
apply TensorProduct.ext_threefold
intro x y z
rfl
apply TensorProduct.ext_fourfold
intro w x y z
rfl
apply TensorProduct.ext_threefold
intro x y z
change R at y
dsimp [tensor_hom, associator]
erw [TensorProduct.lid_tmul, TensorProduct.rid_tmul]
exact (TensorProduct.smul_tmul _ _ _).symm
infer_instance
apply TensorProduct.ext'
intro x y
rfl
apply TensorProduct.ext_threefold
intro x y z
rfl
apply (cancel_epi (α_ X Y Z).Hom).1
apply TensorProduct.ext_threefold
intro x y z
rfl
refine' ⟨_, _, _, _⟩ <;> dsimp only [autoParam] <;> intros <;>
      refine' TensorProduct.ext (LinearMap.ext fun x => LinearMap.ext fun y => _) <;>
    simp only [LinearMap.compr₂_apply, TensorProduct.mk_apply, monoidal_category.hom_apply,
      LinearMap.zero_apply, TensorProduct.tmul_zero, TensorProduct.zero_tmul, LinearMap.add_apply,
      TensorProduct.tmul_add, TensorProduct.add_tmul]
refine' ⟨_, _⟩ <;> dsimp only [autoParam] <;> intros <;>
      refine' TensorProduct.ext (LinearMap.ext fun x => LinearMap.ext fun y => _) <;>
    simp only [LinearMap.compr₂_apply, TensorProduct.mk_apply, monoidal_category.hom_apply,
      LinearMap.smul_apply, TensorProduct.tmul_smul, TensorProduct.smul_tmul]
simp only [monoidal_closed.uncurry, ihom.adjunction, is_left_adjoint.adj]
simp
apply DistribMulAction.toAddMonoidHom M r
      naturality'
intro r
simp
erw [← image_iso_range_inv_image_ι f, iso.hom_inv_id_assoc]
induction x
dsimp
apply Quot.sound
apply relation.zero_add
rfl
induction x
dsimp
apply Quot.sound
apply relation.add_zero
rfl
induction x
dsimp
apply Quot.sound
apply relation.add_left_neg
rfl
induction x
induction y
dsimp
apply Quot.sound
apply relation.add_comm
rfl
rfl
induction x
induction y
induction z
dsimp
apply Quot.sound
apply relation.add_assoc
rfl
rfl
rfl
induction x
dsimp
apply Quot.sound
apply relation.one_smul
rfl
induction x
dsimp
apply Quot.sound
apply relation.mul_smul
rfl
induction x
induction y
dsimp
apply Quot.sound
apply relation.smul_add
rfl
rfl
apply Quot.sound
apply relation.smul_zero
  add_smul s t x
induction x
dsimp
apply Quot.sound
apply relation.add_smul
rfl
induction x
dsimp
apply Quot.sound
apply relation.zero_smul
rfl
intros
apply Quot.sound
apply relation.smul
intros <;> apply Quot.sound <;> apply relation.add
rw [← cocone_naturality F f]
rfl
induction x <;> rfl
induction x <;> induction y <;> rfl
rw [← @Function.comp_apply _ _ _ f (fork.ι s) c, ← coe_comp, fork.condition,
            has_zero_morphisms.comp_zero (fork.ι s) N]
rfl
subst w
simp
infer_instance
infer_instance
simp
simp
simp
simp
simp
simp
apply LinearMap.ext
intro x
rfl
simp [to_kernel_subobject]
subst w
simp
change AddCommGroup (F.obj j)
infer_instance
change Module R (F.obj j)
infer_instance
simp only [forget_map_eq_coe, functor.comp_map, Pi.smul_apply, LinearMap.map_smul]
dsimp [functor.sections] at sh
rw [sh f]
infer_instance
infer_instance
infer_instance
apply LinearMap.ext
intro x
apply Module.DirectedSystem.map_self
apply LinearMap.ext
intro x
exact direct_limit.of_f
rw [← s.w (hom_of_le h)]
rfl
apply LinearMap.ext
intro x
dsimp
exact direct_limit.lift_of s.ι.app _ x
funext i
rw [← h]
rfl
simp [Basis.constr]
rw [mono_iff_ker_eq_bot, LinearMap.ker_eq_bot]
rw [epi_iff_range_eq_top, LinearMap.range_eq_top]
simp
simp
simp
simp
simp
simp
infer_instance
change Semiring (F.obj j)
infer_instance
change Algebra R (F.obj j)
infer_instance
change Ring (sections_subalgebra F)
infer_instance
rfl
change Module.Finite R V
infer_instance
dsimp [FgModule]
infer_instance
dsimp [forget₂_monoidal]
infer_instance
dsimp [forget₂_monoidal]
infer_instance
dsimp [forget₂_monoidal]
infer_instance
infer_instance
apply coevaluation K V.obj
apply coevaluation_apply_one K V.obj
apply contractLeft K V.obj
apply contract_left_apply f x
apply contract_left_assoc_coevaluation K V.obj
apply contract_left_assoc_coevaluation' K V.obj
dsimp
infer_instance
infer_instance
intro j
change FiniteDimensional k (F.obj j).obj
infer_instance
infer_instance
infer_instance
apply M.mk_eq
refine' ⟨max' _ j, left_to_max _ j, right_to_max _ j, _⟩
simp
refine' Quot.lift₂ (colimit_mul_aux F) _ _ x y
· intro x y y' h
      apply colimit_mul_aux_eq_of_rel_right
      apply types.filtered_colimit.rel_of_quot_rel
      exact h
· intro x x' y h
      apply colimit_mul_aux_eq_of_rel_left
      apply types.filtered_colimit.rel_of_quot_rel
      exact h
rw [colimit_one_eq F is_filtered.nonempty.some]
exact MonoidHom.map_one _
apply Quot.induction_on₂ x y
clear x y
intro x y
let k := max' x.1 y.1
let f := left_to_max x.1 y.1
let g := right_to_max x.1 y.1
rw [colimit_mul_mk_eq _ x y k f g, colimit_mul_mk_eq _ y x k g f]
dsimp
rw [mul_comm]
induction x
induction y
induction z
dsimp
apply Quot.sound
apply relation.mul_assoc
rfl
rfl
rfl
induction x
dsimp
apply Quot.sound
apply relation.one_mul
rfl
induction x
dsimp
apply Quot.sound
apply relation.mul_one
rfl
infer_instance
rw [← cocone_naturality F f]
rfl
induction x <;> induction y <;> rfl
simp
rw [mul_assoc x y (x * y), ← mul_assoc y x y, mul_comm y x, mul_assoc, mul_assoc]
infer_instance
change Monoid (F.obj j)
infer_instance
simp
simp only [forget_map_eq_coe, functor.comp_map, MonoidHom.map_mul, Pi.mul_apply]
dsimp [functor.sections] at ah bh
rw [ah f, bh f]
change CommMonoid (F.obj j)
infer_instance
apply is_limit.unique_up_to_iso (MonCat.HasLimits.limitConeIsLimit _) t
      makesLimit
infer_instance
cases x
  mul_assoc x y z
cases x
rw [smul_sub, sub_eq_zero, ha]
rw [← mem_bot _, hs]
trivial
rw [← f.to_linear_map_eq_coe, this, LinearMap.id_comp]
rw [← quotient.mk_smul, (@hN x).some_spec, quotient.mk_zero]
rw [smul_assoc]
rw [one_smul]
rw [one_smul, smul_zero, smul_zero, one_smul]
dsimp only <;> rw [one_smul]
rw [mk_add_mk, mk_add_mk, add_comm, mul_comm]
rw [one_smul, mul_smul, one_smul]
rw [one_smul, mul_smul, one_smul]
infer_instance
infer_instance
simp only [zero_mul, smul_zero]
simp only [mul_zero, smul_zero]
simp only [one_mul, one_smul]
simp only [mul_one, one_smul]
infer_instance
simp only [one_smul, mul_comm]
infer_instance
infer_instance
infer_instance
infer_instance
simp only [one_smul, mul_comm]
unfold HasSmul.smul
rw [Localization.lift_on_mk, lift_on_mk]
simp only [mul_smul, one_smul]
rw [smul_comm]
simp
simp [mul_smul]
erw [mk_smul_mk r m 1 s, one_mul]
rw [Algebra.algebra_map_eq_smul_one]
change _
infer_instance
simp [mk_add_mk]
rw [mul_smul, mul_smul, smul_comm c, eq1, smul_comm s] <;> infer_instance
intros
simp [LocalizedModule.lift_on_mk, smul'_mk]
erw [← g.map_smul, ← g.map_smul, ← g.map_smul, ← g.map_smul, eq1]
rfl
rw [Function.injective_iff_has_left_inverse]
refine' ⟨(h c).Unit, _⟩
intro x
change ((h c).Unit.1 * (h c).Unit.inv) x = x
simp only [Units.inv_eq_val_inv, IsUnit.mul_val_inv, LinearMap.one_apply]
rw [LocalizedModule.lift'_smul, RingHom.id_apply]
intros
rfl
intro m t
refine' ⟨⟨m, t⟩, _⟩
erw [LocalizedModule.smul'_mk, LocalizedModule.mk_linear_map_apply, Submonoid.coe_subtype,
          LocalizedModule.mk_cancel t]
rw [from_localized_module'_smul, RingHom.id_apply]
rw [from_localized_module_mk, Module.End_algebra_map_is_unit_inv_apply_eq_iff, ← eq1]
rfl
rw [← lift_unique S f (k.comp f) map_unit j h, lift_unique]
rfl
delta mk'
rw [← LocalizedModule.smul'_mk, LinearMap.map_smul]
delta mk'
rw [← map_add, LocalizedModule.mk_add_mk]
rw [← zero_smul R (0 : M), mk'_smul, zero_smul]
delta mk'
rw [from_localized_module_mk, Module.End_algebra_map_is_unit_inv_apply_eq_iff, Submonoid.coe_one,
    one_smul]
delta mk'
rw [LocalizedModule.mk_cancel, ← mk'_one S f]
rfl
rw [Submonoid.smul_def, ← mk'_smul, ← Submonoid.smul_def, mk'_cancel]
delta mk'
rw [LocalizedModule.mk_cancel_common_left]
delta mk'
rw [LocalizedModule.mk_cancel_common_right]
rw [mk'_add_mk', ← smul_add, mk'_cancel_left]
delta mk'
rw [(from_localized_module.inj S f).eq_iff, LocalizedModule.mk_eq]
delta mk'
rw [LocalizedModule.mk_neg, map_neg]
rw [sub_eq_add_neg, sub_eq_add_neg, mk'_add, mk'_neg]
rw [sub_eq_add_neg, ← mk'_neg, mk'_add_mk', smul_neg, ← sub_eq_add_neg]
rw [← smul_inj f s, Submonoid.smul_def, ← mk'_smul, ← Submonoid.smul_def, mk'_cancel]
rw [mk'_eq_iff, smul_zero]
rw [eq_comm, mk'_eq_iff, Submonoid.smul_def, LocalizedModule.smul'_mk, ← Submonoid.smul_def,
    LocalizedModule.mk_cancel, LocalizedModule.mk_linear_map_apply]
rw [h]
have eq1 : _ + _ = (x + y).1 := congr_arg₂ (· + ·) x.2.some_spec y.2.some_spec
rw [← map_add, ← (x + y).2.some_spec] at eq1
rw [← Fact.out (Function.Injective i) eq1, map_add]
simp only [LinearPmap.mk_apply, LinearMap.coe_mk]
congr
exact Fact.out (Function.Injective i) (⟨i m, ⟨_, rfl⟩⟩ : i.range).2.some_spec.symm
rw [← eq1, ← eq2]
simp [← (extension_of_max i f).toLinearPmap.map_add, add_smul]
simp [← (extension_of_max i f).toLinearPmap.map_smul, mul_smul] <;> rfl
rw [eq1] <;> exact Submodule.zero_mem _
simp only [extension_of_max_adjoin.extend_ideal_to_is_extension i f h _ _ hr,
    extension_of_max_adjoin.ideal_to, LinearMap.coe_mk, Subtype.coe_mk]
rw [← eq2] <;> exact Submodule.sub_mem _ (extension_of_max_adjoin.fst i x).2 ha
rw [extension_of_max_adjoin.eqn, smul_add, smul_eq_mul, mul_smul]
rfl
simp only [LinearPmap.mk_apply, LinearMap.coe_mk]
rw [(extension_of_max i f).is_extension,
      extension_of_max_adjoin.extension_to_fun_wd i f h _ ⟨i m, _⟩ 0 _, map_zero, add_zero]
simp
simp [EQ]
refine' submodule.eq_top_iff'.mpr fun y => _
rw [← extension_of_max_is_max i f _ (extension_of_max_le i f h), extension_of_max_adjoin,
    Submodule.mem_sup]
exact ⟨0, Submodule.zero_mem _, y, Submodule.mem_span_singleton_self _, zero_add _⟩
rw [← LinearPmap.map_add]
congr
rw [← LinearPmap.map_smul]
congr
cases f
cases g
congr
rw [map_smulₛₗ]
cases e
rfl
erw [e.to_add_monoid_hom.map_nsmul]
rfl
rw [Finset.sum_product, Finset.sum_smul, Finset.sum_congr rfl]
intros
rw [Finset.smul_sum]
rw [Finset.sum_const, Nat.smul_one_eq_coe]
rw [← add_smul, h, one_smul]
rw [bit0, add_smul, one_smul]
simp only [smul, f.map_add, add_smul]
simp only [smul, zero_smul, f.map_zero]
rw [← f.map_zero, hsmul, zero_smul]
simp only [← f.map_add, hsmul, add_smul]
simp [add_smul]
simp
simp [add_smul]
rw [← one_smul R x, ← zero_eq_one, zero_smul]
rw [← add_smul, add_sub_cancel'_right, one_smul]
rw [smul_sub, Convex.combo_self h]
rw [← add_smul, add_left_neg, zero_smul]
rw [neg_smul, smul_neg, neg_neg]
rw [Units.smul_def, Units.val_neg, neg_smul, Units.smul_def]
simp
simp [add_smul, sub_eq_add_neg]
rw [← one_smul R x, ← one_smul R y, Subsingleton.elim (1 : R) 0, zero_smul, zero_smul]
rw [nsmul_eq_smul_cast ℕ n x, Nat.cast_id]
infer_instance
simp only [zero_smul]
simp only [Nat.succ_eq_add_one, add_smul, one_smul, ih]
rw [zsmul_eq_smul_cast ℤ n x, Int.cast_id]
infer_instance
simp only [← zsmul_eq_smul_cast, map_zsmul]
simp only [← nsmul_eq_smul_cast, map_nsmul]
simp [this]
simp [this]
rw [Rat.cast_def, Rat.cast_def, div_eq_mul_inv, div_eq_mul_inv, mul_smul, mul_smul,
    map_int_cast_smul f R S, map_inv_nat_cast_smul f R S]
rw [← hs, h, h0]
rw [Ne.def, smul_eq_zero, not_or]
intro c x
rw [nsmul_eq_smul_cast R, smul_eq_zero]
simp
refine' ⟨fun m n h => @Nat.cast_injective M _ _ _ _ _⟩
rw [← nsmul_one, ← nsmul_one, nsmul_eq_smul_cast R m (1 : M), nsmul_eq_smul_cast R n (1 : M), h]
rw [← two_nsmul_eq_zero R M, two_smul, add_eq_zero_iff_eq_neg]
rw [eq_comm, self_eq_neg R M]
rw [nsmul_eq_mul, mul_one]
rw [zsmul_eq_mul, mul_one]
exact this.symm ▸ p.smul_mem _ hm
  simp [TensorProduct.Algebra.smul_def]
exact this.symm ▸ p.smul_mem _ hm
  simp [TensorProduct.Algebra.smul_def]
simp [torsion_of]
simp [h]
rw [smul_add, mul_smul, mul_comm, mul_smul, hx, hy, smul_zero, smul_zero, add_zero]
rw [smul_comm, h, smul_zero]
show b₁
induction x using Quotient.induction_on
refine' (Submodule.Quotient.mk_eq_zero _).mpr (Submodule.smul_mem_smul r.prop _)
trivial
rw [← @mem_torsion'_iff R, h]
trivial
rw [← hb, smul_comm, ← Submonoid.smul_def, hax, smul_zero]
infer_instance
infer_instance
rw [← zero_smul R (0 : M), map_smulₛₗ]
simp
rw [map_smulₛₗ, RingHom.id_apply]
simp
cases f <;> cases g <;> congr
simp
apply h
simp [w]
subst w
simp
simp only [RingHom.id_apply, map_smulₛₗ h]
rw [← smul_one_smul S c x, ← smul_one_smul S c (fₗ x), map_smul]
rw [← mul_one x, ← smul_eq_mul, f.map_smulₛₗ, g.map_smulₛₗ, h]
rw [← one_mul x, ← op_smul_eq_mul, f.map_smulₛₗ, g.map_smulₛₗ, h]
simp only [map_add, forall_const, eq_self_iff_true, comp_app]
rw [comp_app, map_smulₛₗ, map_smulₛₗ, RingHomCompTriple.comp_apply]
rw [← comp_apply, h, comp_apply]
rw [← h₁ (g (x + y)), ← h₁ (g x + g y)] <;> simp [h₂]
induction c using Int.induction_on
case hz => simp
case hp n ih => simp [add_smul, ih]
case hn n ih => simp [sub_smul, ih]
refine' IsLinearMap.mk (smul_add c) _
intro _ _
simp only [smul_smul, mul_comm]
simp only [Pi.smul_apply, f.map_add, smul_add]
simp [Pi.smul_apply, smul_comm (σ₁₂ c)]
simp
simp
rw [comp_apply, zero_apply, zero_apply, g.map_zero]
simp [add_comm, add_left_comm]
simp [smul_add]
simp [add_comm]
simp
simp only [Pi.sub_apply, map_add, add_sub_add_comm]
simp [Pi.sub_apply, map_smul, smul_sub]
refine' ⟨fun i => Classical.choose (h i <| Set.mem_univ _), fun i hi => _, funext fun i => _⟩
· exact (Classical.choose_spec (h i _)).left
· exact (Classical.choose_spec (h i _)).right
cases p <;> cases q <;> congr
refine' { toFun := coe.. } <;> simp [coe_smul]
infer_instance
simp [SetLike.le_def]
rw [sub_eq_add_neg, p.add_mem_iff_left (p.neg_mem hy)]
rw [sub_eq_add_neg, p.add_mem_iff_right hx, p.neg_mem_iff]
simp (config := { contextual := true })
simp [SetLike.ext_iff]
simp (config := { contextual := true }) [zero_mem]
rw [eq_bot_iff]
intro v hv
exact congr_arg coe (Subsingleton.elim (⟨v, hv⟩ : p) 0)
simp [SetLike.ext_iff]
simp
intros
rfl
intros
rfl
intro x
rfl
simp [zero_mem]
simp (config := { contextual := true }) [add_mem]
simp (config := { contextual := true }) [smul_mem]
simp [zero_mem]
simp (config := { contextual := true }) [add_mem]
simp (config := { contextual := true }) [smul_mem]
rw [← SetLike.mem_coe, infi_coe, Set.mem_Inter] <;> rfl
simp only [← SetLike.mem_coe, finset_inf_coe, Set.mem_Inter]
rw [sub_eq_add_neg]
exact add_mem_sup hs (neg_mem ht)
simp
apply le_antisymm
· rw [span_le, coe_set_neg, ← Set.neg_subset, neg_neg]
    exact subset_span
· rw [neg_le, span_le, coe_set_neg, ← Set.neg_subset]
    exact subset_span
rw [Submodule.mem_bot] at hn⊢
rw [hn, LinearMap.map_zero]
rw [Submodule.mem_bot] at hm⊢
rw [hm, LinearMap.map_zero₂]
rw [← map₂_span_span, span_eq, span_eq]
rw [this, zero_min, pow_zero, Ideal.one_eq_top]
simp
simp [smul_add]
simp
simp [mul_smul]
simp [smul_add]
simp [smul_zero]
simp [add_smul]
simp [zero_smul]
cases j <;>
          · dsimp
            simp
cases j <;>
          · dsimp
            simp
rw [C.shape]
simp only [ComplexShape.up_rel, zero_add]
exact (Nat.one_lt_succ_succ _).Ne
rw [C.shape j j' w]
simp
dsimp
rw [if_pos h]
dsimp
rw [if_pos h]
simp
simp
rfl
have := congr_hom w j
dsimp at this
simp only [dif_pos] at this
rw [← is_iso.inv_comp_eq, inv_eq_to_hom, eq_to_hom_trans_assoc, eq_to_hom_refl,
      category.id_comp, ← is_iso.comp_inv_eq, category.assoc, inv_eq_to_hom, eq_to_hom_trans,
      eq_to_hom_refl, category.comp_id] at this
exact this
simp
simp
rw [d_to_eq ((single₀ V).obj X) rfl]
simp
cases i
· rw [d_from_eq_zero]
    simp
· rw [d_from_eq ((single₀ V).obj X) rfl]
    simp
simp
simp
simp
simp
rw [← f.comm 1 0]
simp
rw [d_from_eq ((single₀ V).obj X) rfl]
simp
cases i
· rw [d_to_eq_zero]
    simp
· rw [d_to_eq ((single₀ V).obj X) rfl]
    simp
simp
simp
simp
simp
rw [f.comm 0 1]
simp
apply c.next_eq _ h
dsimp only [next]
rw [dif_pos]
exact Exists.choose_spec ⟨j, h⟩
apply c.prev_eq _ h
dsimp only [prev]
rw [dif_pos]
exact Exists.choose_spec ⟨i, h⟩
change is_iso ((homologyFunctor V c i).mapIso (as_iso f)).Hom
infer_instance
rw [functor.map_comp]
infer_instance
rw [← f.2 1 0 rfl] <;> exact comp_zero
rw [← f.2 1 0 rfl] <;> exact comp_zero
simp only [← f.2 1 0 rfl, ChainComplex.single₀_obj_X_d, comp_zero]
rw [f.2 0 1 rfl] <;> exact zero_comp
rw [f.2 0 1 rfl] <;> exact zero_comp
simp only [HomologicalComplex.Hom.comm, CochainComplex.single₀_obj_X_d, zero_comp]
rw [← functor.comp_map, ← nat_iso.naturality_2 (F.homology_functor_iso i) f, functor.comp_map]
infer_instance
dsimp [prevD]
simp only [category.assoc, g.comm]
rw [ChainComplex.next_nat_succ]
rfl
rw [CochainComplex.prev_nat_succ]
rfl
simp [h.comm]
simp only [AddMonoidHom.map_zero, zero_add, h]
rw [Pi.neg_apply, Pi.neg_apply, h.zero i j w, neg_zero]
rw [AddMonoidHom.map_neg, AddMonoidHom.map_neg, h.comm, ← neg_add, ← add_assoc, neg_add_self,
      zero_add]
rw [Pi.add_apply, Pi.add_apply, h.zero i j w, k.zero i j w, zero_add]
rw [Pi.add_apply, Pi.add_apply, h₁.zero' i j hij, h₂.zero' i j hij, add_zero]
rw [h.zero i j w, zero_comp]
simp only [h.comm i, d_next_comp_right, preadditive.add_comp, prev_d_comp_right, comp_f]
rw [h.zero i j w, comp_zero]
simp only [h.comm i, d_next_comp_left, preadditive.comp_add, prev_d_comp_left, comp_f]
simp only [prevD, AddMonoidHom.mk'_apply, category.assoc, d_comp_d, comp_zero]
simp only [dNext, AddMonoidHom.mk'_apply, d_comp_d_assoc, zero_comp]
intro i
rw [HomologicalComplex.zero_f_apply, add_zero]
rfl
dsimp only [null_homotopic_map]
rw [d_next_eq hom r₁₀, prev_d_eq hom r₂₁]
dsimp only [null_homotopic_map]
rw [prev_d_eq hom r₁₀, dNext, AddMonoidHom.mk'_apply, C.shape, zero_comp, zero_add]
exact hk₀ _
dsimp only [null_homotopic_map]
rw [d_next_eq hom r₁₀, prevD, AddMonoidHom.mk'_apply, D.shape, comp_zero, add_zero]
exact hk₁ _
simp only [← null_homotopic_map']
exact null_homotopic_map_f_eq_zero hk₀ hk₀' fun i j => dite (c.rel j i) (h i j) fun _ => 0
dsimp [prevD]
have : (ComplexShape.down ℕ).prev j = j + 1 := ChainComplex.prev ℕ j
congr 2
dsimp [dNext]
have : (ComplexShape.down ℕ).next (i + 1) = i := ChainComplex.next_nat_succ _
congr 2
dsimp [dNext]
rw [P.shape, zero_comp]
rw [ChainComplex.next_nat_zero]
dsimp
decide
induction a family of diagrams,
but don't require
induction.
rw [aux]
dsimp [dNext]
have : (ComplexShape.up ℕ).next j = j + 1 := CochainComplex.next ℕ j
congr 2
dsimp [prevD]
have : (ComplexShape.up ℕ).prev (i + 1) = i := CochainComplex.prev_nat_succ i
congr 2
dsimp [prevD]
rw [Q.shape, comp_zero]
rw [CochainComplex.prev_nat_zero]
dsimp
decide
induction a family of diagrams,
but don't require
induction.
rw [aux]
simp
simp
rw [← functor.map_comp, homology_map_eq_of_homotopy f.homotopy_hom_inv_id,
      CategoryTheory.Functor.map_id]
rw [← functor.map_comp, homology_map_eq_of_homotopy f.homotopy_inv_hom_id,
      CategoryTheory.Functor.map_id]
rw [h.zero i j w, F.map_zero]
dsimp [dNext, prevD] at *
rw [h.comm i]
simp only [F.map_add, ← F.map_comp]
rfl
rw [← (F.map_homological_complex c).map_comp, ← (F.map_homological_complex c).map_id]
exact F.map_homotopy h.homotopy_hom_inv_id
rw [← (F.map_homological_complex c).map_comp, ← (F.map_homological_complex c).map_id]
exact F.map_homotopy h.homotopy_inv_hom_id
rw [eq_top_iff]
apply le_kernel_subobject
rw [C.d_from_eq_zero h, comp_zero]
rw [eq_bot_iff]
refine' image_subobject_le _ 0 _
rw [C.d_to_eq_zero h, zero_comp]
dsimp <;> rw [C.d_to_eq hij, category.comp_id]
dsimp <;> rw [C.d_from_comp_X_next_iso hjk, category.id_comp]
rw [C.d_to_eq rfl] <;> exact (category.comp_id _).symm
rw [CochainComplex.prev_nat_zero] <;> exact one_ne_zero
simp
simp
simp
simp
dsimp only [cyclesMap]
simp
dsimp only [cyclesMap]
simp [subobject.factor_thru_right]
cases h
rfl
cases h
dsimp
simp
cases h
simp
cases h
simp
simp [h]
dsimp at h⊢
subst h
delta homological_complex_to_dgo
simp
dsimp at h⊢
subst h
delta homological_complex_to_dgo
simp
have := C.d_comp_d i j k
rw [nat_trans.ext_iff, Function.funext_iff] at this
exact this t
have := C.shape _ _ h
rw [nat_trans.ext_iff, Function.funext_iff] at this
exact this t
apply homotopy_of_eq
simp
rw [← (Quotient V c).map_comp, ← (Quotient V c).map_id]
exact eq_of_homotopy _ _ f.homotopy_hom_inv_id
rw [← (Quotient V c).map_comp, ← (Quotient V c).map_id]
exact eq_of_homotopy _ _ f.homotopy_inv_hom_id
simp
rfl
simp
rfl
rw [← (HomotopyCategory.quotient W c).map_id]
apply HomotopyCategory.eq_of_homotopy
rw [← (F.map_homological_complex c).map_id]
apply F.map_homotopy
apply HomotopyCategory.homotopyOfEq
exact Quot.out_eq _
rw [← cancel_mono α.hom.right]
simp only [iso.symm_hom, ← comma.comp_right, α.inv_hom_id]
simp only [p, ← comma.comp_left, arrow.id_right, arrow.id_left, iso.inv_hom_id]
rfl
refine' ⟨⟨subobject.of_le _ _ p.ge, _⟩⟩
dsimp [imageToKernel]
simp only [subobject.of_le_comp_of_le, subobject.of_le_refl]
simp
simp [h.w]
simp [hgh.w]
rw [← is_iso.inv_hom_id_assoc f g]
exact exact_epi_comp w
simp [hfg.w_assoc]
rw [category.assoc, hfg.1]
simp
rw [← kernel_subobject_arrow', exact_iso_comp]
exact exact_kernel_subobject_arrow
rw [← factor_thru_image_subobject_comp_image_to_kernel]
apply epi_comp
rw [← factor_thru_kernel_subobject_comp_kernel_subobject_iso]
apply epi_comp
rw [← kernel_subobject_arrow']
simp [kernel_subobject_arrow_eq_zero_of_exact_zero_left A h]
simp
rw [← kernel.lift_ι _ _ hι, ← cokernel.π_desc _ _ hπ, category.assoc,
    kernel_comp_cokernel_assoc _ _ h, zero_comp, comp_zero]
simp
simp
subst h
rfl
rw [← d_comp_eq_to_hom C r r']
apply kernel_subobject_comp_mono
rw [← eq_to_hom_comp_d C r r']
apply image_subobject_iso_comp
rw [← c.prev_eq' r]
rw [← c.next_eq' r]
simp [C.d_to_eq r]
simp [h]
simp [C.d_from_eq r]
simp [h]
rw [C.d_from_eq r]
apply kernel_subobject_comp_mono
rw [C.d_to_eq r]
apply image_subobject_iso_comp
simp
rw [hf i j hij]
simp
subst h
rw [dif_neg (Ne.symm w)]
dsimp [of]
rw [if_pos rfl, category.id_comp]
dsimp [of]
rw [dif_neg h]
induction a family of commutative squares,
but don't require
induction on commutative squares.
dsimp [mk_hom, mk_hom_aux]
induction n <;> congr
subst h
rw [dif_neg]
exact w
dsimp [of]
rw [if_pos rfl, category.comp_id]
dsimp [of]
rw [dif_neg h]
induction a family of commutative squares,
but don't require
induction on commutative squares.
dsimp [mk_hom, mk_hom_aux]
induction n <;> congr
simp
simp [imageToKernel]
simp [reassoc_of w]
simp [w]
simp
simp
simp [homology.π, homology.desc]
simp
simp
simp
simp
simp
rw [image_subobject_map_comp_image_to_kernel_assoc w w' α β p]
simp only [cokernel.condition, comp_zero]
simp only [homology.π, homology.map, cokernel.π_desc]
simp only [image_subobject_map_comp_image_to_kernel_assoc w w' α β p, z, comp_zero]
simp only [comma.comp_left, comma.comp_right, p₁, p₂]
rw [← cancel_mono α.hom.right, ← comma.comp_right, α.inv_hom_id, comma.id_right, p, ←
          comma.comp_left, β.inv_hom_id, comma.id_left]
rfl
cases pf
cases pg
rw [homology.map_comp, ← homology.map_id]
congr 1 <;> exact category.comp_id _
cases pf
cases pg
rw [homology.map_comp, ← homology.map_id]
congr 1 <;> exact category.comp_id _
simp only [image_subobject_iso_image_to_kernel']
simp only [image_to_kernel'_kernel_subobject_iso]
apply coequalizer.hom_ext
simp only [iso.hom_inv_id_assoc, cokernel.π_desc, cokernel.π_desc_assoc, category.assoc,
      coequalizer_as_cokernel]
exact (category.comp_id _).symm
refine' homologyIsoCokernelImageToKernel' f g w
refine' @as_iso _ _ _ _ i (id _)
refine'
      is_iso_of_short_exact_of_is_iso_of_is_iso h _ _ _ _ (h1.trans (category.id_comp _).symm).symm
        (h2.trans (category.comp_id _).symm)
constructor
apply exact_inl_snd
refine' (@as_iso _ _ _ _ i (id _)).symm
refine'
      is_iso_of_short_exact_of_is_iso_of_is_iso _ h _ _ _ (h1.trans (category.id_comp _).symm).symm
        (h2.trans (category.comp_id _).symm)
constructor
apply exact_inl_snd
rw [iso.symm_hom, as_iso_inv, is_iso.comp_inv_eq, h1]
rw [iso.symm_hom, as_iso_inv, is_iso.inv_comp_eq, h2]
simp only [biprod.lift_snd]
rw [hφ]
infer_instance
rw [hχ]
infer_instance
rw [h2]
infer_instance
rw [h1]
infer_instance
rw [iso.comp_inv_eq, h.comp_iso_eq_inl]
rw [iso.inv_comp_eq, h.iso_comp_snd_eq]
delta splitting.section
simp
delta retraction
simp
delta splitting.section retraction
simp
simp
simp
simp [hZ.eq_of_tgt _ 0]
simp
apply mono_of_mono _ h.retraction
rw [h.ι_retraction]
infer_instance
delta splitting.section
infer_instance
delta retraction
apply epi_comp
delta splitting.section retraction
rw [← cancel_mono h.iso.hom, ← cancel_epi h.iso.inv]
simp only [category.comp_id, category.id_comp, category.assoc, iso.inv_hom_id_assoc,
    iso.inv_hom_id, limits.biprod.total, preadditive.comp_add, preadditive.add_comp,
    splitting.comp_iso_eq_inl, splitting.iso_comp_eq_snd_assoc]
let φ := h.iso.hom
simp [preadditive.nsmul_comp, preadditive.comp_nsmul]
simp [preadditive.zsmul_comp, preadditive.comp_zsmul]
rw [C.shape _ _ w, F.map_zero]
rw [← F.map_comp, C.d_comp_d, F.map_zero]
dsimp
rw [← F.map_comp, ← F.map_comp, f.comm]
rw [← F.map_comp, sq n, functor.map_zero]
simp [h]
simp [h]
simp
simp [single_map_homological_complex]
simp [single_map_homological_complex, h]
simp
simp [single_map_homological_complex]
simp [single_map_homological_complex, h]
simp [x.2]
rw [smul_zero, zero_add, smul_zero]
rw [zero_smul, zero_add, zero_smul]
rw [smul_zero, add_zero]
rw [smul_zero, zero_add]
rw [one_smul, smul_zero, add_zero]
rw [smul_zero, zero_add, one_smul]
simp [Nat.cast]
rw [zero_smul, zero_add, smul_zero]
rw [smul_zero, zero_add, zero_smul]
rw [smul_zero, add_zero, algebra_map_smul]
rw [map_zero, map_one, add_zero]
dsimp
simp only [add_zero, zero_add, add_mul, mul_add, smul_mul_smul, hf, smul_zero]
rw [← RingHom.map_mul, LinearMap.map_add, ← Algebra.commutes _ (f _), ← Algebra.smul_def, ←
          Algebra.smul_def, add_right_comm, add_assoc, LinearMap.map_smul, LinearMap.map_smul]
rw [RingHom.map_zero, zero_add]
rw [← unop_mul, ← hc, unop_op]
simp [hc]
simp
simp [IsSquare, pow_two]
rw [h.neg_pow, one_pow]
refine' ⟨fun h => _, fun h => _⟩
· rw [← is_square_op_iff, ← inv_inv a]
    exact h.map (MulEquiv.inv' α)
· exact ((is_square_op_iff a).mpr h).map (MulEquiv.inv' α).symm
rw [h.neg_zpow, one_zpow]
cases abs_choice a <;> simp only [h, even_neg]
rw [div_eq_mul_inv]
exact ha.mul hb.inv
simp [even_iff_exists_two_nsmul]
simp [Even, Dvd.Dvd, two_mul]
rw [pow_succ]
exact hm.mul_right _
rw [two_mul]
rfl
rw [mul_add, ← two_mul, add_assoc]
rw [add_comm]
exact hn.add_odd hm
simp [two_mul]
rw [pow_zero]
exact odd_one
rw [pow_succ]
exact hm.mul Odd.pow
rw [h.neg_pow, one_pow]
simp only [even_neg, even_two]
simp
rw [sub_eq_add_neg]
exact ha.add_even hb.neg
rw [sub_eq_add_neg]
exact ha.add_odd hb.neg
rw [sub_eq_add_neg]
exact ha.add_odd hb.neg
rw [ha, zero_pow h₀] at h
exact lt_irrefl 0 h
rw [← abs_pow, abs_eq_self]
exact hp.pow_nonneg _
rw [mul_comm, mul_comm c] at h
exact IsLeftCancelMulZero.mul_left_cancel_of_ne_zero ha h
rw [mul_comm a, mul_comm a c] at h
exact IsRightCancelMulZero.mul_right_cancel_of_ne_zero ha h
rw [one_mul]
rw [h, zero_mul]
rw [h, zero_mul]
rw [one_mul]
rw [zero, one]
exact zero_ne_one
rw [eq_comm, mul_eq_zero]
simp
simp
simp only [SemiconjBy, mul_zero, zero_mul]
simp only [SemiconjBy, mul_zero, zero_mul]
simp only [ha, inv_zero, SemiconjBy.zero_left]
rw [div_eq_mul_inv, div_eq_mul_inv]
exact h.mul_right h'.inv_right₀
simp
rw [mul_assoc, mul_right_inj' ha]
rw [mul_right_comm, mul_left_inj' hc]
rw [hd, mul_assoc, ← he, mul_one]
conv => 
                  lhs
                  rw [he, hdx] <;>
                simp [mul_assoc]
rw [div_eq_mul_inv]
exact hac.mul_left hbc.inv_left₀
rw [ha, zero_mul]
rw [h ha, mul_zero]
rw [← mul_one a, ← h, mul_zero]
rw [mul_one]
rw [one_mul]
simp [h]
simp [h]
simp [inv_ne_zero h]
simp [h]
simp [inv_ne_zero h]
simp [h]
simp [h]
rw [← inv_mul_cancel_left₀ (left_ne_zero_of_mul_eq_one h) b, h, mul_one]
rw [div_eq_mul_inv, zero_mul]
rw [div_eq_mul_inv, inv_zero, mul_zero]
rw [div_eq_mul_inv, mul_self_mul_inv a]
rw [div_eq_mul_inv, mul_inv_mul_self a]
simp [mul_inv_rev]
rw [inv_eq_iff_inv_eq, inv_zero, eq_comm]
rw [div_div_eq_mul_div]
exact mul_self_div_self a
rw [ha, div_zero] at h
contradiction
simp [← mul_assoc, mul_inv_cancel h]
simp [mul_assoc, inv_mul_cancel h]
simp only [Units.isUnit, inverse, dif_pos]
exact Units.inv_unique rfl
rw [mul_assoc, mul_inverse_cancel x h, mul_one]
rw [mul_assoc, inverse_mul_cancel x h, mul_one]
rw [← mul_assoc, mul_inverse_cancel x h, one_mul]
rw [← mul_assoc, inverse_mul_cancel x h, one_mul]
rw [← h1, mul_inverse_cancel_left _ _ h]
rw [h1, inverse_mul_cancel_left _ _ h]
rw [h1, inverse_mul_cancel_right _ _ h]
rw [← h1, mul_inverse_cancel_right _ _ h]
injection h
simp [exists0]
rw [← inv_mul_cancel_left₀ hx y, h, inv_mul_cancel_left₀ hx z]
rw [← mul_inv_cancel_right₀ hy x, h, mul_inv_cancel_right₀ hy z]
rw [div_eq_mul_inv]
exact mul_ne_zero ha (inv_ne_zero hb)
simp [div_eq_mul_inv]
rw [div_div_eq_mul_div, div_mul_cancel _ hc]
rw [← mul_div_assoc, div_mul_cancel _ hc]
simp [*]
simp [*]
rw [mul_comm, mul_div_cancel_of_imp h]
rw [mul_comm, div_mul_cancel_of_imp h]
rw [← mul_one a, ← div_self hb, ← mul_comm_div, h, div_mul_eq_mul_div, div_mul_cancel _ hd]
rw [div_mul_eq_mul_div, one_mul, div_mul_right _ h]
simp only [mul, zero, zero_mul]
simp only [mul, zero, mul_zero]
simp only [← zero, ← mul, mul_zero]
simp only [← zero, ← mul, zero_mul]
rw [← mul, H, zero]
erw [← mul, ← mul, H] <;> rfl
erw [← mul, ← mul, H] <;> rfl
erw [inv, zero, inv_zero]
erw [one, mul, inv, mul_inv_cancel ((hf.ne_iff' zero).2 hx)]
erw [← zero, ← inv, inv_zero]
erw [← inv, ← mul, mul_inv_cancel (mt (congr_arg f) <| trans_rel_left Ne hx zero.symm)] <;>
          exact one
rw [← pow_add, h1]
rw [pow_sub₀ _ (inv_ne_zero ha) h, inv_pow, inv_pow, inv_inv]
simp
simp only [← Int.ofNat_succ, zpow_ofNat, pow_succ']
erw [zpow_zero, zpow_negSucc, pow_one, inv_mul_cancel ha]
rw [Int.negSucc_eq, zpow_neg, neg_add, neg_add_cancel_right, zpow_neg, ← Int.ofNat_succ,
      zpow_ofNat, zpow_ofNat, pow_succ _ (n + 1), mul_inv_rev, mul_assoc, inv_mul_cancel ha,
      mul_one]
rw [mul_assoc, mul_inv_cancel ha, mul_one]
rw [← zpow_add_one₀ ha, sub_add_cancel]
rw [zpow_add₀ h, zpow_one]
simp [h.pow_right n]
simp [(h.pow_right (n + 1)).inv_right₀]
rw [zpow_ofNat]
exact pow_ne_zero _ ha
rw [zpow_negSucc]
exact inv_ne_zero (pow_ne_zero _ ha)
rw [sub_eq_add_neg, zpow_add₀ ha, zpow_neg, div_eq_mul_inv]
rw [zpow_bit1₀, (Commute.refl a).mul_zpow]
rw [zpow_neg]
exact inv_mul_cancel (zpow_ne_zero n h)
rw [mul_comm] at h
apply h
rw [mul_comm]
exact h.mul_right _
simp
simp [ceq]
rw [pow_zero, pow_zero]
rw [pow_succ, pow_succ]
exact mul_dvd_mul h (pow_dvd_pow_of_dvd n)
simp
rw [← mul_assoc, ← Eq, Units.mul_inv_cancel_right]
rw [mul_assoc, u.mul_inv, mul_one]
rw [mul_comm]
apply dvd_mul_right
rw [mul_comm]
apply mul_right_dvd
rw [h, mul_comm]
rw [← not_lt, ← not_lt, aleph_idx_lt]
rw [Ordinal.univ_id] <;> exact Quotient.sound ⟨aleph_idx.rel_iso⟩
rw [← nonpos_iff_eq_zero, ← aleph'_aleph_idx 0, aleph'_le]
apply Ordinal.zero_le
apply (succ_le_of_lt <| aleph'_lt.2 <| lt_succ o).antisymm' (Cardinal.aleph_idx_le.1 <| _)
rw [aleph_idx_aleph', succ_le_iff, ← aleph'_lt, aleph'_aleph_idx]
apply lt_succ
rw [aleph'_succ, aleph'_nat, nat_succ]
rw [← aleph'_aleph_idx c, aleph'_le, limit_le l]
intro x h'
rw [← aleph'_le, aleph'_aleph_idx]
exact h _ h'
refine' le_antisymm _ (csupr_le' fun i => aleph'_le.2 (le_of_lt i.2))
rw [aleph'_le_of_limit ho]
exact fun a ha => le_csupr (bdd_above_of_small _) (⟨a, ha⟩ : Iio o)
simp only [forall_eq, aleph'_nat]
rw [aleph, add_succ, aleph'_succ, aleph]
rw [aleph, add_zero, aleph'_omega]
rw [← aleph'_omega, aleph'_le]
rw [aleph, aleph_0_le_aleph']
apply Ordinal.le_add_right
rw [out_nonempty_iff_ne_zero, ← ord_zero]
exact fun h => (ord_injective h).not_gt (aleph_pos o)
simp only [ord_le, aleph'_le_of_limit l]
rw [← aleph_zero, ← aleph_succ, Ordinal.succ_zero]
rw [← succ_aleph_0]
apply lt_succ
rw [← succ_aleph_0, lt_succ_iff, le_aleph_0_iff_set_countable]
dsimp
rw [card_ord]
dsimp
rw [card_ord]
apply limit_rec_on o
· simp
· intro o h
    rw [aleph_succ, beth_succ, succ_le_iff]
    exact (cantor _).trans_le (power_le_power_left two_ne_zero h)
· intro o ho IH
    rw [aleph_limit ho, beth_limit ho]
    exact csupr_mono (bdd_above_of_small _) fun x => IH x.1 x.2
rw [beth_limit ho, ord_le]
exact csupr_le' fun b => ord_le.1 (ha _ b.2)
exact card_le_card this
  refine' le_of_forall_lt fun o h => _
  rcases typein_surj s h
intro q h
simp only [s, embedding.coe_fn_mk, Order.Preimage, typein_lt_typein, Prod.lex_def,
        typein_inj] at h
exact max_le_iff.1 (le_iff_lt_or_eq.2 <| h.imp_right And.left)
rw [Cardinal.mul_eq_max (aleph_0_le_aleph o₁) (aleph_0_le_aleph o₂), max_aleph_eq]
rw [mul_eq_self h]
exact max_lt h1 h2
rw [mul_comm, max_comm]
exact mul_eq_max_of_aleph_0_le_left h h'
rw [mul_eq_max_of_aleph_0_le_left ha hb', max_eq_left hb]
rw [mul_comm, mul_eq_left hb ha ha']
rw [mul_comm]
exact le_mul_left h
rw [add_comm, max_comm, add_eq_max ha]
rw [add_eq_self h] <;> exact max_lt h1 h2
rw [add_eq_max ha, max_eq_left hb]
rw [add_comm, add_eq_left hb ha]
rw [add_comm, add_eq_left_iff]
rw [← not_le]
intro hc
apply lt_irrefl ℵ₀
apply (hc.trans (self_le_add_left _ a)).trans_lt
rw [← h]
apply add_lt_aleph_0 ha hb
rw [add_comm a b, add_comm c b] at h
exact Cardinal.eq_of_add_eq_add_left h hb
rw [Cardinal.add_eq_max (aleph_0_le_aleph o₁), max_aleph_eq]
rw [lt_ord, Ordinal.card_add] at *
exact add_lt_of_lt hc ha hb
rw [Nat.cast_zero, power_zero]
exact one_lt_aleph_0
rw [Nat.cast_succ, power_add, power_one]
exact mul_le_mul_right' ih _
rw [← lift_id' (Prod c), lift_prod, ← lift_two_power]
apply le_antisymm
· refine' (prod_le_prod _ _ h₂).trans_eq _
    rw [prod_const, lift_lift, ← lift_power, power_self_eq (aleph_0_le_mk ι), lift_umax.{u, v}]
· rw [← prod_const', lift_prod]
    refine' prod_le_prod _ _ fun i => _
    rw [lift_two, ← lift_two.{u, v}, lift_le]
    exact h₁ i
cases le_or_lt ℵ₀ c
· rw [powerlt_aleph_0 h]
    apply le_max_left
rw [powerlt_le]
exact fun c' hc' => (power_lt_aleph_0 h hc').le.trans (le_max_right _ _)
simp [H1]
cases finite_or_infinite α
· rw [mk_list_eq_aleph_0, eq_comm, max_eq_right]
    exact mk_le_aleph_0
· rw [mk_list_eq_mk, eq_comm, max_eq_left]
    exact aleph_0_le_mk α
cases finite_or_infinite α
· exact mk_le_aleph_0.trans (le_max_left _ _)
· rw [mk_list_eq_mk]
    apply le_max_right
rw [mk_prod, mul_eq_max_of_aleph_0_le_left] <;> simp
simp
simp
simp
simp
simp
simp
rw [← add_one_eq (aleph_0_le_mk α)]
refine' eq_of_add_eq_of_aleph_0_le _ h2 (aleph_0_le_mk α)
exact mk_sum_compl s
apply mk_compl_of_infinite
exact (finset_card_lt_aleph_0 s).trans_le (aleph_0_le_mk α)
rw [mk_compl_of_infinite s hs, mk_compl_of_infinite t ht]
simp [bit0]
simp [bit1]
rw [← not_iff_not]
simp [bit0]
simp [bit0, add_lt_aleph_0_iff]
rw [← not_iff_not]
simp
simp [bit1, bit0, add_lt_aleph_0_iff, one_lt_aleph_0]
rw [← not_iff_not]
simp
simp [← bit1_zero]
simp [← bit1_zero]
rw [Nat.cast_two]
rw [Nat.cast_two]
simp
simp only [Nat.card, mk_prod, to_nat_mul, to_nat_lift]
cases n
· exact Nat.card_eq_zero_of_infinite
· rw [Nat.card_eq_fintype_card, Zmod.card]
simp
intro h
rw [h, zero_dvd_iff, mul_eq_zero] at hbc
cases hbc <;> contradiction
simp
rw [← lift_umax]
exact lift_mk_le
rw [power_add, power_one, mul_comm']
rw [bit1, ← power_bit0, power_add, power_one]
simp
simp
rw [mul_comm b c]
exact induction_on₃ a b c fun α β γ => mk_congr <| Equiv.curry γ β α
simp [bit1]
simp
simp [Set, mk_arrow]
simp
infer_instance
rw [← not_le, le_one_iff_subsingleton, ← not_nontrivial_iff_subsingleton, not_not]
injection h
simp
rw [← lift_mk_eq, mk_out, mk_out, lift_lift]
rw [Equiv.image_eq_preimage]
simp [Set.preimage]
rw [← this]
apply bdd_above_range.{u, u}
rw [bdd_above_iff_small] at hs⊢
exact small_lift _
rw [range_comp]
exact bdd_above_image g hf
rw [← (supr f).lift_id, ← lift_umax, lift_umax.{max u v, u}, ← sum_const]
exact sum_le_sum _ _ (le_csupr <| bdd_above_range.{u, v} f)
refine' (Equiv.sigmaNatSucc fun i => Quotient.out (f i)).cardinal_eq.trans _
simp only [mk_sum, mk_out, lift_id, mk_sigma]
rw [← lift_umax', lift_mk_shrink.{max u v, v, 0} α, ← lift_umax, lift_id]
simp [prod_eq_zero]
rw [← lift_lift, ← lift_lift, lift_inj]
rw [supr, supr, lift_Sup hf, ← range_comp]
rw [lift_supr hf]
exact csupr_le' w
rw [lift_supr hf]
exact csupr_le_iff' (bdd_above_range_comp hf _)
rw [lift_supr hf, lift_supr hf']
exact csupr_mono' (bdd_above_range_comp hf' _) fun i => ⟨_, h i⟩
rw [← lift_aleph_0, lift_le]
rw [← lift_aleph_0, lift_le]
simp
induction n <;> simp [*]
rw [← lift_nat_cast.{v} n, lift_inj]
simp
simp
simp
simp
induction n <;> simp [pow_succ', power_add, *]
rw [← lift_mk_fin, ← lift_mk_fin, lift_le, le_def, Function.Embedding.nonempty_iff_card_le,
    Fintype.card_fin, Fintype.card_fin]
simp [lt_iff_le_not_le, ← not_le]
rw [← succ_zero, succ_le_iff]
rw [one_le_iff_pos, pos_iff_ne_zero]
rw [← nat_succ, ← lift_mk_fin, aleph_0, lift_mk_le.{0, 0, u}]
exact ⟨⟨coe, fun a b => Fin.ext⟩⟩
simp only [mem_Iio, mem_range, eq_comm, lt_aleph_0]
simp only [lt_aleph_0, mk_eq_nat_iff, finite_iff_exists_equiv_fin]
rw [mk_le_aleph_0_iff, countable_coe_iff]
rw [← Nat.cast_add] <;> apply nat_lt_aleph_0
simp only [← not_lt, add_lt_aleph_0_iff, not_and_or]
rw [← Nat.cast_mul] <;> apply nat_lt_aleph_0
have : ∀ {a : Cardinal.{u}}, ℵ₀ ≤ a → a ≠ 0 := fun a => ne_bot_of_le_ne_bot aleph_0_ne_zero
simp only [aleph_0_le_mul_iff, and_or_left, and_iff_right_of_imp this, @and_left_comm (a ≠ 0)]
simp only [and_comm, or_comm]
simp [mul_lt_aleph_0_iff, ha, hb]
rw [← nat_cast_pow] <;> apply nat_lt_aleph_0
rw [← not_lt, lt_aleph_0_iff_finite, not_finite_iff_infinite]
rw [mul_comm, nat_mul_aleph_0 hn]
rw [add_comm, aleph_0_add_nat]
have h : 0 < ℵ₀ := nat_lt_aleph_0 0
rw [dif_pos h, ← Cardinal.nat_cast_inj, ← Classical.choose_spec (lt_aleph_0.1 h),
      Nat.cast_zero]
rw [to_nat_apply_of_lt_aleph_0 h, ← Classical.choose_spec (lt_aleph_0.1 h)]
rw [to_nat_apply_of_aleph_0_le h, Nat.cast_zero]
rw [← nat_cast_le, cast_to_nat_of_lt_aleph_0 hc, cast_to_nat_of_lt_aleph_0 hd]
rw [← nat_cast_lt, cast_to_nat_of_lt_aleph_0 hc, cast_to_nat_of_lt_aleph_0 hd]
rw [to_nat_apply_of_lt_aleph_0 (nat_lt_aleph_0 n), ← nat_cast_inj]
exact (Classical.choose_spec (lt_aleph_0.1 (nat_lt_aleph_0 n))).symm
simp
rw [← to_nat_cast 0, Nat.cast_zero]
rw [← to_nat_cast 1, Nat.cast_one]
rw [to_nat_eq_iff one_ne_zero, Nat.cast_one]
rw [← to_nat_lift, lift_mk_eq.mpr ⟨e⟩, to_nat_lift]
rw [← lift_aleph_0]
exact lift_lt.2 ha
rw [← lift_aleph_0]
exact lift_lt.2 hb
simp [if_pos (zero_lt_one.trans one_lt_aleph_0)]
rw [to_part_enat_apply_of_lt_aleph_0 (nat_lt_aleph_0 n), to_nat_cast]
simp
refine' ⟨fun i => Classical.choice <| mk_ne_zero_iff.1 _⟩
rw [mk_out]
exact (H i).ne_bot
intro i
simp only [-not_exists, not_exists.symm, not_forall.symm]
refine' fun h => (H i).not_le _
rw [← mk_out (f i), ← mk_out (g i)]
exact ⟨embedding.of_surjective _ h⟩
simp
simp
rw [sUnion_eq_Union]
apply mk_Union_le
rw [bUnion_eq_Union]
apply mk_Union_le
rw [← mk_univ, mk_set_eq_nat_iff_finset]
rw [diff_union_of_subset h]
simp
rw [le_mk_iff_exists_set, ← Subtype.exists_set_subtype]
apply exists_congr
intro t
rw [mk_image_eq]
apply Subtype.val_injective
rw [← Nat.cast_two, nat_succ, succ_le_iff, Nat.cast_one, one_lt_iff_nontrivial, nontrivial_iff]
rw [two_le_iff, ← nontrivial_iff, nontrivial_iff_exists_ne x]
apply @le_csupr _ _ _ (fun y : Iio b => a^y) _ ⟨c, h⟩
rw [← image_eq_range]
exact bdd_above_image.{u, u} _ bdd_above_Iio
rw [powerlt, csupr_le_iff']
· simp
· rw [← image_eq_range]
    exact bdd_above_image.{u, u} _ bdd_above_Iio
apply (powerlt_le.2 fun c hc => zero_power_le _).antisymm
rw [← power_zero]
exact le_powerlt 0 (pos_iff_ne_zero.2 h)
rw [← two_power_aleph_0, lift_two_power, lift_aleph_0, two_power_aleph_0]
simp
rw [← succ_aleph_0]
exact Order.succ_le_of_lt aleph_0_lt_continuum
rw [← two_power_aleph_0, ← power_mul, mul_eq_left le_rfl le_rfl aleph_0_ne_zero]
intro b <;> cases b <;> rfl
simp at e <;> congr <;> injections
rw [cof_eq_Inf_lsub]
exact cInf_le' card_mem_cof
rw [cof_eq_Inf_lsub]
exact Inf_mem (cof_lsub_def_nonempty o)
rw [cof_eq_Inf_lsub]
exact cInf_le' ⟨ι, f, rfl, rfl⟩
rw [← hb]
exact H _ hf
subst h
exact (cof_lsub_le_lift f).not_lt hι
rw [← sup_eq_lsub_iff_lt_sup] at H
rw [H]
exact cof_lsub_le_lift f
rw [← ord_lt_ord, supr_ord (Cardinal.bdd_above_range _)]
refine' sup_lt_ord_lift hι fun i => _
rw [ord_lt_ord]
apply hf
rw [← o.card.lift_id]
exact cof_blsub_le_lift f
rw [← bsup_eq_blsub_iff_lt_bsup] at H
rw [H]
exact cof_blsub_le_lift f
rw [← o.card.lift_id]
exact cof_bsup_le_lift
simp [e]
rw [e] <;> exact one_ne_zero
simp [e]
rw [← hf.2.2]
exact (ord_le_ord.2 (cof_blsub_le f)).trans (ord_card_le o)
rw [hf.cof_eq]
have H := hf.cof_eq
subst H
exact hf
rw [cof_zero, ord_zero]
refine' ⟨_, fun i j hi hj h => _, blsub_const Ordinal.one_ne_zero o⟩
· rw [cof_succ, ord_one]
· rw [lt_one_iff_zero] at hi hj
    rw [hi, hj] at h
    exact h.false.elim
rw [← hg.2.2]
apply lt_blsub
refine' ⟨_, fun i j _ _ h => hf.2.1 _ _ (hg.2.1 _ _ h), _⟩
· rw [hf.cof_eq]
    exact hg.1.trans (ord_cof_le o)
· rw [@blsub_comp.{u, u, u} o _ f (@is_fundamental_sequence.monotone _ _ f hf)]
    exact hf.2.2
rw [← this]
apply cof_lsub_le
rw [← card_omega]
apply cof_le_card
rw [typein_enum]
exact lt_succ (typein _ _)
dsimp [g] <;> simp
rw [Cardinal.lt_ord]
exact H.pos
simp
rw [← succ_aleph_0]
exact is_regular_succ le_rfl
rw [aleph'_succ]
exact is_regular_succ (aleph_0_le_aleph'.2 h)
rw [aleph_succ]
exact is_regular_succ (aleph_0_le_aleph o)
rw [infinite_coe_iff]
apply mt (union_finset_finite_of_range_finite f)
rw [w]
exact infinite_univ
simp
simp
rw [hc.cof_eq]
exact lt_of_le_of_ne hc.1 hc'.symm
rw [hc.cof_eq]
exact lt_of_le_of_ne hc.1 hc'.symm
simp
have b0 : b ≠ 0 := (zero_lt_one.trans b1).ne'
apply lt_imp_lt_of_le_imp_le (power_le_power_left <| power_ne_zero a b0)
rw [← power_mul, mul_eq_self ha]
exact lt_power_cof (ha.trans <| (cantor' _ b1).le)
simp [hs]
rw [← hns, g'g.image_image]
rw [← range_iff_surjective, range_piecewise, hg'ns, union_compl_self]
cases hx <;> cases hy
· simp [hx, hy]
· subst x
              exact fun i e => (hf i y hy e.symm).elim
· subst y
              exact fun i e => (hf i x hx e).elim
· exact hs x hx y hy
let ⟨sa, ea⟩ := hf a
let ⟨sb, eb⟩ := hf b
rw [← ea, ← eb, hs _ sa _ sb _ e']
rw [mem_right] at h
apply Finset.mem_erase_of_ne_of_mem _ h.2
exact ne_of_apply_ne Prod.fst (pred_ne_self m.1)
rw [mem_left] at h
apply Finset.mem_erase_of_ne_of_mem _ h.2
exact ne_of_apply_ne Prod.snd (pred_ne_self m.2)
have w₁ : m ∈ b := (Finset.mem_inter.1 h).1
have w₂ : (m.1, m.2 - 1) ∈ b.erase m := snd_pred_mem_erase_of_mem_left h
have i₁ := Finset.card_erase_lt_of_mem w₁
have i₂ := Nat.lt_of_le_of_lt (Nat.zero_le _) (Finset.card_erase_lt_of_mem w₂)
exact Nat.lt_of_le_of_lt i₂ i₁
have w₁ : m ∈ b := (Finset.mem_inter.1 h).1
have w₂ := fst_pred_mem_erase_of_mem_right h
have i₁ := Finset.card_erase_lt_of_mem w₁
have i₂ := Nat.lt_of_le_of_lt (Nat.zero_le _) (Finset.card_erase_lt_of_mem w₂)
exact Nat.lt_of_le_of_lt i₂ i₁
dsimp [move_left]
rw [Finset.card_erase_of_mem (snd_pred_mem_erase_of_mem_left h)]
rw [Finset.card_erase_of_mem (Finset.mem_of_mem_inter_left h)]
exact tsub_add_cancel_of_le (card_of_mem_left h)
dsimp [move_right]
rw [Finset.card_erase_of_mem (fst_pred_mem_erase_of_mem_right h)]
rw [Finset.card_erase_of_mem (Finset.mem_of_mem_inter_left h)]
exact tsub_add_cancel_of_le (card_of_mem_right h)
simp [← move_left_card h, lt_add_one]
simp [← move_right_card h, lt_add_one]
dsimp [domineering]
infer_instance
dsimp [domineering.one]
infer_instance
dsimp [domineering.L]
infer_instance
intro h
have t := state.left_bound m
rw [h] at t
exact Nat.not_succ_le_zero _ t
intro h
have t := state.right_bound m
rw [h] at t
exact Nat.not_succ_le_zero _ t
induction n <;> rfl
induction n <;> rfl
apply Fintype.ofEquiv _ (left_moves_of_state_aux _ _).symm
infer_instance
apply Fintype.ofEquiv _ (right_moves_of_state_aux _ _).symm
infer_instance
dsimp [Pgame.ofState]
infer_instance
rw [to_pgame]
rw [to_pgame, left_moves]
rw [to_pgame, right_moves]
rw [to_pgame_left_moves]
infer_instance
rw [to_pgame_right_moves]
infer_instance
rw [to_pgame]
rfl
simp
simp
simp
refine' le_iff_forall_lf.2 ⟨fun i => _, isEmptyElim⟩
rw [to_pgame_move_left']
exact to_pgame_lf ((to_left_moves_to_pgame_symm_lt i).trans_le h)
rw [Pgame.Equiv, le_antisymm_iff, to_pgame_le_iff, to_pgame_le_iff]
rw [le_lf]
rfl
cases x
cases y
exact mk_le_mk
rw [le_lf]
rfl
cases x
cases y
exact mk_lf_mk
rw [← Pgame.not_le]
apply em
rw [Pgame.not_le]
rfl
rw [← Pgame.not_le] at h₂⊢
exact fun h₃ => h₂ (h₃.trans h₁)
rw [← Pgame.not_le] at h₁⊢
exact fun h₃ => h₁ (h₂.trans h₃)
rw [le_iff_forall_lf]
conv => 
    lhs
    simp only [lf_iff_exists_le]
rw [lf_iff_exists_le]
conv => 
    lhs
    simp only [le_iff_forall_lf]
rw [le_iff_forall_lf]
simp
rw [le_iff_forall_lf]
simp
rw [lf_iff_exists_le]
simp
rw [lf_iff_exists_le]
simp
rw [le_def]
simp
rw [le_def]
simp
rw [lf_def]
simp
rw [lf_def]
simp
subst h
rw [lf_congr hx hy, lf_congr hy hx]
rw [lf_iff_lt_or_fuzzy, fuzzy.swap_iff]
exact lt_or_equiv_or_gt_or_fuzzy x y
simp
simp
simp
simp
dsimp [Zero.zero, Neg.neg, neg]
congr <;> funext i <;> cases i
rw [is_option_iff, is_option_iff, or_comm']
cases y
apply or_congr <;>
    · apply exists_congr
      intro
      rw [← neg_eq_iff_neg_eq]
      exact eq_comm
rw [is_option_neg, neg_neg]
cases x
rfl
cases x
rfl
cases x
rfl
cases x
rfl
simp
simp
simp
simp
rw [lt_iff_le_and_lf, lt_iff_le_and_lf, neg_le_neg_iff, neg_lf_neg_iff]
rw [Equiv, Equiv, neg_le_neg_iff, neg_le_neg_iff, and_comm]
rw [fuzzy, fuzzy, neg_lf_neg_iff, neg_lf_neg_iff, and_comm]
rw [← neg_neg x, neg_le_neg_iff, neg_neg]
rw [← neg_neg x, neg_lf_neg_iff, neg_neg]
rw [← neg_neg x, neg_lt_neg_iff, neg_neg]
rw [← neg_neg y, neg_equiv_neg_iff, neg_neg]
rw [← neg_neg y, neg_fuzzy_neg_iff, neg_neg]
rw [← neg_neg x, neg_le_neg_iff, neg_neg]
rw [← neg_neg x, neg_lf_neg_iff, neg_neg]
rw [← neg_neg x, neg_lt_neg_iff, neg_neg]
rw [neg_le_iff, neg_zero]
rw [le_neg_iff, neg_zero]
rw [neg_lf_iff, neg_zero]
rw [lf_neg_iff, neg_zero]
rw [neg_lt_iff, neg_zero]
rw [lt_neg_iff, neg_zero]
rw [neg_equiv_iff, neg_zero]
rw [neg_fuzzy_iff, neg_zero]
rw [← neg_equiv_iff, neg_zero]
rw [← neg_fuzzy_iff, neg_zero]
cases x
cases y
rfl
cases x
cases y
rfl
cases x
cases y
rfl
cases x
cases y
rfl
rw [neg_zero]
refine' ⟨Equiv.refl _, Equiv.refl _, _, _⟩
all_goals
      exact fun j =>
        Sum.casesOn j (fun j => neg_add_relabelling _ _) fun j =>
          neg_add_relabelling ⟨xl, xr, xL, xR⟩ _ decreasing_
rw [← neg_le_neg_iff, neg_zero]
exact neg_add_le.trans (add_left_neg_le_zero _)
rw [← Pgame.not_le] at h⊢
exact mt this h
rw [lf_congr add_comm_equiv add_comm_equiv]
apply add_lf_add_right h
simp [star]
cases x
rw [birthday]
rfl
cases x
rw [birthday]
exact lt_max_of_lt_left (lt_lsub _ i)
cases x
rw [birthday]
exact lt_max_of_lt_right (lt_lsub _ i)
rw [birthday_def, max_eq_zero, lsub_eq_zero_iff, lsub_eq_zero_iff]
simp [PEmpty.is_empty]
rw [birthday_def]
simp
rw [birthday_def]
simp
simp [le_birthday (xL i)]
simp
simp
simp
simp
simp [birthday_nat_cast]
simp
simp
rw [impartial_aux]
rw [impartial_def]
dsimp
simp
intro h
exact
      impartial_def.2
        ⟨e.symm.equiv.trans ((neg_equiv_self G).trans (neg_equiv_neg_iff.2 e.equiv)), fun i =>
          impartial_congr (e.move_left_symm i), fun j =>
          impartial_congr (e.move_right_symm j)⟩
intro hG hH
rw [impartial_def]
refine'
      ⟨(add_congr (neg_equiv_self _) (neg_equiv_self _)).trans (neg_add_relabelling _ _).Equiv.symm,
        fun k => _, fun k => _⟩
· apply left_moves_add_cases k
      all_goals 
        intro i; simp only [add_move_left_inl, add_move_left_inr]
        apply impartial_add
· apply right_moves_add_cases k
      all_goals 
        intro i; simp only [add_move_right_inl, add_move_right_inr]
        apply impartial_add decreasing_
intro hG
rw [impartial_def]
refine' ⟨_, fun i => _, fun i => _⟩
· rw [neg_neg]
      exact (neg_equiv_self G).symm
· rw [move_left_neg']
      apply impartial_neg
· rw [move_right_neg']
      apply impartial_neg decreasing_
have h' := neg_lt_neg_iff.2 h
rw [neg_zero, lt_congr_left (neg_equiv_self G).symm] at h'
exact (h.trans h').False
have h' := neg_lt_neg_iff.2 h
rw [neg_zero, lt_congr_right (neg_equiv_self G).symm] at h'
exact (h.trans h').False
rw [← zero_le_neg_iff, le_congr_right (neg_equiv_self G)]
rw [← zero_lf_neg_iff, lf_congr_right (neg_equiv_self G)]
refine' ⟨fun hb => _, fun hp i => _⟩
· rw [equiv_zero_iff_le G, le_zero_lf]
    exact fun i => (hb i).1
· rw [fuzzy_zero_iff_lf]
    exact hp.1.move_left_lf i
refine' ⟨fun hb => _, fun hp i => _⟩
· rw [equiv_zero_iff_ge G, zero_le_lf]
    exact fun i => (hb i).2
· rw [fuzzy_zero_iff_gf]
    exact hp.2.lf_move_right i
cases x
cases y
rfl
cases x
cases y
rfl
cases x
cases y
rfl
cases x
cases y
rfl
cases x
apply Sum.is_empty
cases x
apply Sum.is_empty
cases x
apply Sum.is_empty
cases x
apply Sum.is_empty
simp only [quot_mul_comm, quot_left_distrib]
change mk _ _ _ _
rw [lt_self_iff_false]
infer_instance
rw [inv_eq_of_pos Pgame.zero_lt_one]
exact inv'_one
(cases x; dsimp at *) <;> exact short.mk sL sR
cases x
dsimp
infer_instance
cases x
dsimp
infer_instance
cases i
infer_instance
cases j
skip
apply short.mk
· intros
      infer_instance
· intros
      apply Pgame.listShortNthLe
rw [← L.right_inv i]
apply short_of_relabelling (rL (L.symm i)) inferInstance
skip
exact short.mk (fun i => short_neg _) fun i => short_neg _ decreasing_
dsimp [bit0]
infer_instance
dsimp [bit1]
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance

-- No longer works since definitional reduction of well-founded definitions has been restricted.
-- example : (0 : pgame) ≤ 0 := dec_trivial
-- example : (1 : pgame) ≤ 1 := dec_trivial
rw [nim]
rfl
rw [nim_def]
rfl
rw [nim_def]
rfl
rw [nim_def]
rfl
rw [nim_def]
rfl
simp
simp
rw [← to_left_moves_nim.apply_symm_apply i]
apply H
rw [← to_right_moves_nim.apply_symm_apply i]
apply H
rw [nim_def]
exact Ordinal.is_empty_out_zero
rw [nim_def]
exact Ordinal.is_empty_out_zero
simp
simp
simp
simp
rw [nim_def]
refine' ⟨_, _, fun i => _, fun j => _⟩
any_goals dsimp; apply Equiv.equivOfUnique
all_goals simp; exact nim_zero_relabelling
simp
simp
rw [iff_not_comm, impartial.not_fuzzy_zero_iff, nim_add_equiv_zero_iff]
rw [impartial.equiv_iff_add_equiv_zero, nim_add_equiv_zero_iff]
rw [grundy_value]
intro h
rw [← nim_equiv_iff_eq]
exact (equiv_nim_grundy_value G).symm.trans h
rw [← grundy_value_eq_iff_equiv, grundy_value_zero]
rw [grundy_value_eq_iff_equiv_nim, neg_equiv_iff, neg_nim, ← grundy_value_eq_iff_equiv_nim]
rw [← grundy_value_eq_iff_equiv_nim, grundy_value_nim_add_nim]
cases a <;> simp [cons]
induction l <;> simp [*]
rw [h] <;> exact l
      ofList (toList l') = l'
simp [mem_def, or_and_right, exists_or]
induction l₁
· exact subset.nil
refine' subset.cons (Lists.Equiv.refl _) _ (l₁_ih (List.subset_of_cons_subset h))
simp at h
simp [h]
rw [← Lists'.of_to_list l] <;> exact of_list_subset (List.Subset.refl _)
rw [← of_to_list l₁]
revert H
induction to_list l₁ <;> intro
· exact subset.nil
· simp at H
      exact cons_subset.2 ⟨H.1, ih H.2⟩
simp [of_list, of']
simp [of_list, of']
unfold Lists <;> infer_instance
unfold Lists <;> infer_instance
exact ⟨fun ⟨b, l⟩ => (this _).1, fun l => (this l).2⟩
  intros
  induction' l
cases h <;> rfl
let trans := fun l₁ : Lists α => ∀ ⦃l₂ l₃⦄, l₁
exact this.1
  apply induction_mut
  · intro a l₂ l₃ h₁ h₂
    rwa [← equiv_atom.1 h₁]
simp [atom]
unfold Finsets <;> infer_instance
rw [mem_inter] at hz⊢
exact ⟨hx.mem_trans hw hz.1, hy.mem_trans hw hz.2⟩
simp
cases x
apply mem.mk
simp [to_set]
simp [PSet.Nonempty]
rw [← eta (A a)] at e
exact
        let ⟨βt, tβ⟩ := e
        let ⟨c, bc⟩ := βt b
        ⟨⟨a, c⟩, yb.trans bc⟩
exact small_of_surjective this
    rintro ⟨y, hb⟩
    induction y
simp [subset_def, Set.subset_def]
simp [h]
simp [to_set]
simp [SetCat.Nonempty]
rw [SetCat.sound h]
rfl
simp [mem_powerset, subset_iff]
rw [mk_func]
exact Eq.ndrec d (Eq.symm eb)
unfold Union.union
rw [SetCat.union]
simp
rw [← mem_to_set]
simp
rw [@Quotient.sound PSet _ _ _ ha]
exact IH a
simp [pair]
simp
simp [h]
simp only [eq_self_iff_true, or_true_iff]
simp
simp
simp
simp
simp [Prod]
simp [funs, is_func]
let ⟨w, wx, we⟩ := mem_image.1 yx
let ⟨wz, fy⟩ := pair_injective we
rw [← fy, wz]
change (x : ClassCat.{u}) z ↔ (y : ClassCat.{u}) z
rw [h]
refine' Iff.trans _ Set.mem_sUnion.symm
exact ⟨fun ⟨_, ⟨a, rfl, ax⟩, za⟩ => ⟨a, ax, za⟩, fun ⟨a, ax, za⟩ => ⟨_, ⟨a, rfl, ax⟩, za⟩⟩
let ⟨wy, fw⟩ := SetCat.pair_injective pr
rw [← fw, wy]
subst e
exact ⟨_, h, rfl⟩
delta choice
rw [map_fval yx, ClassCat.mem_hom_left, ClassCat.mem_hom_right]
exact choice_mem_aux x h y yx
cases n <;> rfl
cases n <;> cases i <;> rfl
cases n <;> exact PUnit.unique
rw [← lf_iff_lt numeric_zero (numeric_pow_half n), zero_lf_le]
simp
rw [two_nsmul]
exact Quotient.sound (Pgame.add_pow_half_succ_self_eq_pow_half n)
simp only [add_smul, mul_comm, add_comm]
simp only [zsmul_pow_two_pow_half]
rw [← Localization.mk_eq_mk']
rfl
rw [dyadic_map_apply, @Submonoid.log_pow_int_eq_self 2 one_lt_two]
cases x
rfl
cases x
exact o.1 i j
cases x
exact o.2.1 i
cases x
exact o.2.2 j
refine' le_iff_forall_lf.trans (and_congr _ _) <;>
      refine' forall_congr' fun i => lf_iff_lt _ _ <;>
    trace
      "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr numeric.move_left, \",\", expr numeric.move_right, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
rw [← lf_iff_lt ox oy, lf_iff_exists_le]
rw [← lf_iff_lt ox oy, lf_def]
refine' or_congr _ _ <;> refine' exists_congr fun x_1 => _ <;> refine' and_congr _ _ <;>
      refine' forall_congr' fun i => lf_iff_lt _ _ <;>
    trace
      "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr numeric.move_left, \",\", expr numeric.move_right, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
rw [← add_one_eq_succ, lift_add, lift_one]
rfl
intro b
cases e : f (Sum.inr b)
· rw [← fl] at e
                have := f.inj' e
                contradiction
· exact ⟨_, rfl⟩
rw [fr, fr, h]
rw [fr] <;> exact Sum.lex_inr_inr.2 H
simp only [le_antisymm_iff, add_le_add_iff_left]
rw [← not_le, ← not_le, add_le_add_iff_left]
simp
rw [nat_cast_succ, add_succ, add_succ, succ_le_succ_iff, add_le_add_iff_right]
simp only [le_antisymm_iff, add_le_add_iff_right]
let ⟨a, e⟩ := h
rw [e, pred_succ] <;> exact le_succ a
rw [pred, dif_neg h]
rw [e', pred_succ] at e <;> exact (lt_succ a).Ne e
simp only [le_antisymm_iff, pred_le_self, true_and_iff, not_le]
simp only [e, pred_succ]
let ⟨c, e⟩ := h
rw [e, pred_succ, succ_lt_succ_iff]
simp only [pred, dif_neg h, succ_lt_of_not_succ h]
rw [h, ← e, lift_succ]
simp only [h, lift_succ]
rw [pred_eq_iff_not_succ.2 h, pred_eq_iff_not_succ.2 (mt lift_is_succ.1 h)]
rw [o0] <;> exact H₁
rw [← succ_pred_iff_is_succ.2 h] <;> exact H₂ _ (IH _ <| pred_lt_iff_is_succ.2 h)
rw [limit_rec_on, lt_wf.fix_eq, dif_pos rfl] <;> rfl
have h : ∃ a, succ o = succ a := ⟨_, rfl⟩
rw [limit_rec_on, lt_wf.fix_eq, dif_neg (succ_ne_zero o), dif_pos h]
generalize limit_rec_on._proof_2 (succ o) h = h₂
generalize limit_rec_on._proof_3 (succ o) h = h₃
revert h₂ h₃
generalize e : pred (succ o) = o'
intros
rw [pred_succ] at e
subst o'
rfl
rw [limit_rec_on, lt_wf.fix_eq, dif_neg h.1, dif_neg (not_succ_of_is_limit h)] <;> rfl
rw [type_lt]
exact lt_succ o
rw [lift_card, ← type_subrel_lt, card_type]
simp only [le_antisymm_iff, H.le_iff]
cases h <;> assumption
rw [← add_le_add_iff_left b, Ordinal.add_sub_cancel_of_le h]
rw [← Ordinal.le_zero] <;> apply sub_le_self
rw [sub_le, sub_le, sub_le, add_assoc]
rw [← sub_sub, add_sub_cancel]
rw [lt_sub, add_succ] <;> exact l.2 _ (lt_sub.1 h)
rw [← Ordinal.add_sub_cancel_of_le h, ← add_assoc, one_add_omega]
rw [zero_smul, Nat.cast_zero, mul_zero]
rw [succ_nsmul', Nat.cast_add, mul_add, Nat.cast_one, mul_one, smul_eq_mul]
rw [div_def a h] <;> exact Inf_mem (div_nonempty h)
rw [div_def a b0] <;> exact cInf_le' h
rw [← not_le, div_le h, not_lt]
simp [lt_div h]
apply limit_rec_on a
· simp only [mul_zero, Ordinal.zero_le]
· intros
    rw [succ_le_iff, lt_div c0]
·
    simp (config := { contextual := true }) only [mul_le_of_limit, limit_le, iff_self_iff,
      forall_true_iff]
simp only [b0, div_zero, Ordinal.zero_le]
simp only [b0, zero_mul, Ordinal.zero_le]
apply le_antisymm
· apply (div_le b0).2
    rw [mul_succ, mul_add, add_assoc, add_lt_add_iff_left]
    apply lt_mul_div_add _ b0
· rw [le_div b0, mul_add, add_le_add_iff_left]
    apply mul_div_le
simp only [a0, zero_mul, sub_self]
rw [sub_le, ← le_div a0, sub_le, ← le_div a0, mul_add_div _ a0]
rw [mul_sub, ← e, add_sub_cancel]
rw [e, ← mul_add]
apply dvd_mul_right
rw [mul_div_cancel _ a0]
subst a <;> exact (eq_zero_of_zero_dvd h₁).symm
subst b <;> exact eq_zero_of_zero_dvd h₂
simp only [mod_def, div_zero, zero_mul, sub_zero]
simp only [mod_def, div_eq_zero_of_lt h, mul_zero, sub_zero]
simp only [mod_def, zero_div, mul_zero, sub_self]
rw [div_add_mod] <;> exact lt_mul_div_add a h
simp only [a0, zero_mod]
simp only [mod_def, div_self a0, mul_one, sub_self]
simp only [mod_def, div_one, one_mul, sub_self]
rw [← ho]
exact typein_lt_type r i
simp only [bfamily_of_family', enum_typein]
simp only [family_of_bfamily', typein_enum]
rw [← range_family_of_bfamily]
exact @Set.range_const _ o.out.α (out_nonempty_iff_ne_zero.2 ho) c
simp
refine'
    ⟨fun h i => _, fun h =>
      le_antisymm (sup_le fun i => Ordinal.le_zero.2 (h i)) (Ordinal.zero_le _)⟩
rw [← Ordinal.le_zero, ← h]
exact le_sup f i
rw [sup_le_iff, comp, H.le_set' Set.univ Set.univ_nonempty g] <;> simp [sup_le_iff]
rw [type_lt]
exact b.prop
rw [← Iio_succ]
infer_instance
rw [cSup_le_iff'
        (bdd_above_iff_small.2 (@small_image _ _ _ s (Cardinal.bdd_above_iff_small.1 hs))),
      ord_le, cSup_le_iff' hs]
simp [ord_le]
rw [ho', ← ho]
exact typein_lt_type r i
simp
congr
rw [range_family_of_bfamily]
simp only [← sup_eq_bsup' r, enum_typein, family_of_bfamily', bfamily_of_family']
rw [bsup_eq_sup', bsup_eq_sup']
subst ho
rw [← family_of_bfamily_enum o f]
exact h _
rw [← sup_eq_bsup] at *
exact sup_not_succ_of_ne_sup fun i => hf _
refine'
    ⟨fun h i hi => _, fun h =>
      le_antisymm (bsup_le fun i hi => Ordinal.le_zero.2 (h i hi)) (Ordinal.zero_le _)⟩
rw [← Ordinal.le_zero, ← h]
exact le_bsup f i hi
cases eq_or_lt_of_le (sup_le_lsub f)
· exact Or.inl h
· exact Or.inr ((succ_le_of_lt h).antisymm (lsub_le_sup_succ f))
refine' ⟨fun h => _, fun hf => le_antisymm (sup_le_lsub f) (lsub_le fun i => _)⟩
· rw [← h]
    exact fun a => sup_not_succ_of_ne_sup fun i => (lsub_le_iff.1 (le_of_eq h.symm) i).Ne
rw [← HEq]
exact lt_succ (sup f)
rw [h]
apply lt_lsub
rw [← Ordinal.le_zero, lsub_le_iff]
exact h.elim
refine' ⟨fun h => ⟨fun i => _⟩, fun h => @lsub_empty _ h _⟩
have := @lsub_pos _ ⟨i⟩ f
rw [h] at this
exact this.false
rw [lsub_eq_blsub', lsub_eq_blsub']
rw [blsub_eq_lsub', blsub_eq_lsub']
subst ho
rw [← sup_eq_bsup, ← lsub_eq_blsub]
exact sup_eq_lsub_or_sup_succ_eq_lsub _
rw [← sup_eq_bsup, ← lsub_eq_blsub]
apply sup_eq_lsub_iff_succ
rw [h]
apply lt_blsub
rw [bsup_eq_blsub_iff_lt_bsup]
exact fun i hi => (hf i hi).trans_le (le_bsup f _ _)
rw [← lsub_eq_blsub, lsub_eq_zero_iff]
exact out_empty_iff_eq_zero
rw [← hg]
apply lt_blsub
rw [← hg]
apply lt_blsub
rw [← IsNormal.bsup.{u, u} H (fun x _ => x) h.1, bsup_id_limit h.2]
rw [← H.bsup_eq h, bsup_eq_blsub_of_lt_succ_limit h]
exact fun a _ => H.1 a
rw [← h₂ o ho]
exact bsup_le_iff
simp [h]
simp [ha]
rw [← range_family_of_bfamily]
apply mex_not_mem_range
rw [← mk_ordinal_out]
exact mex_lt_ord_succ_mk (family_of_bfamily o f)
rw [enum_ord_def']
exact Inf_mem (enum_ord_def'_nonempty hS _)
rw [H b hb]
exact hf hb
rw [← range_id]
exact enum_ord_range strictMono_id
rw [enum_ord_def]
simp [Ordinal.not_lt_zero]
rw [enum_ord_def]
exact
    cInf_le' ⟨ha, fun c hc => ((enum_ord_strict_mono hS).Monotone (le_of_lt_succ hc)).trans_lt hb⟩
apply Ordinal.induction a
intro b H
rw [enum_ord_def]
exact cInf_le' ⟨hST (enum_ord_mem hS b), fun c h => (H c h).trans_lt (enum_ord_strict_mono hS h)⟩
rw [enum_ord_zero]
exact cInf_le' hs
rw [range_eq_iff]
exact ⟨enum_ord_mem hS, enum_ord_surjective hS⟩
simp only [opow_def, if_pos rfl]
subst a <;> simp only [zero_opow (succ_ne_zero _), mul_zero]
simp only [opow_def, limit_rec_on_succ, if_neg h]
simp only [opow_def, if_neg a0] <;> rw [limit_rec_on_limit _ _ _ _ h] <;> rfl
rw [opow_limit a0 h, bsup_le_iff]
rw [← not_iff_not, not_exists] <;> simp only [not_lt, opow_le_of_limit b0 h, exists_prop, not_and]
rw [← succ_zero, opow_succ] <;> simp only [opow_zero, one_mul]
simp only [opow_zero, zero_lt_one]
rw [opow_succ, opow_succ]
exact
    (mul_le_mul_right' (opow_le_opow_left c ab.le) a).trans_lt
      (mul_lt_mul_of_pos_left ab (opow_pos c ((Ordinal.zero_le a).trans_lt ab)))
rw [opow_add, opow_one]
rw [← Ordinal.add_sub_cancel_of_le h, opow_add]
apply dvd_mul_right
simp only [log, dif_pos h]
simp only [log, dif_neg h]
rw [log_def b1, ← Ordinal.le_zero, pred_le]
apply cInf_le'
dsimp
rw [succ_zero, opow_one]
exact zero_lt_one.trans b1
simp only [log_of_not_one_lt_left b1]
simp only [hx, log_zero_right, Ordinal.zero_le]
simp only [log_of_not_one_lt_left hb, Ordinal.zero_le]
simp only [hx, log_zero_right, Ordinal.zero_le]
simp only [log_of_not_one_lt_left hb, Ordinal.zero_le]
cases eq_or_ne (o % (b^log b o)) 0
· rw [h, log_zero_right]
    apply log_pos hb ho hbo
· rw [← succ_le_iff, succ_log_def hb h]
    apply cInf_le'
    apply mod_lt
    rw [← Ordinal.pos_iff_ne_zero]
    exact opow_pos _ (zero_lt_one.trans hb)
have hne' := (opow_mul_add_pos (zero_lt_one.trans hb).ne' u hv w).ne'
rw [div_lt (opow_pos _ (zero_lt_one.trans hb)).ne', ← opow_succ]
exact lt_opow_succ_log_self hb o
rw [← Nat.cast_one, ← Nat.cast_add, add_comm]
rfl
simp
rw [Nat.mul_succ, Nat.cast_add, nat_cast_mul, Nat.cast_succ, mul_add_one]
simp
rw [pow_succ', nat_cast_mul, nat_cast_opow, Nat.cast_succ, add_one_eq_succ, opow_succ]
rw [← Cardinal.ord_nat, ← Cardinal.ord_nat, Cardinal.ord_le_ord, Cardinal.nat_cast_le]
simp only [lt_iff_le_not_le, nat_cast_le]
simp only [le_antisymm_iff, nat_cast_le]
rw [← add_left_cancel, div_add_mod, ← nat_cast_div, ← nat_cast_mul, ← Nat.cast_add,
    Nat.div_add_mod]
simp
simp [lift_nat_cast n]
rw [← IsNormal.bsup_eq.{u, u} (add_is_normal b) h, lt_bsup]
let ⟨n, e⟩ := lt_omega.1 h
rw [e] <;> exact nat_lt_omega (n + 1)
let ⟨n, e⟩ := lt_omega.1 h
rw [e, ← succ_le_iff] <;> exact H (n + 1)
apply (mul_le_mul_left' (le_succ c') _).trans
rw [IH _ h]
apply (add_le_add_left _ _).trans
· rw [← mul_succ]
        exact mul_le_mul_left' (succ_le_of_lt <| l.2 _ h) _
· infer_instance
· rw [← ba]
        exact le_add_right _ _
apply limit_rec_on c
· simp only [succ_zero, mul_one]
· intro c IH
    rw [mul_succ, IH, ← add_assoc, add_assoc _ b, ba, ← mul_succ]
· intro c l IH
    have := add_mul_limit_aux ba l IH
    rw [mul_succ, add_mul_limit_aux ba l IH, mul_succ, add_assoc]
rw [← add_zero a]
exact (h _ hb).le
rw [← sup_nat_cast, IsNormal.sup.{0, u, u} hf]
rw [one_opow]
change ((Acc.intro a) fun _ => h.inv).rank = _
rfl
rw [hb.rank_eq]
refine' le_trans _ (Ordinal.le_sup _ ⟨a, h⟩)
rfl
rw [rank, Acc.rank_eq]
rfl
infer_instance
rw [← mem_closure_iff_sup, hs.closure_eq]
rw [← mem_closure_iff_bsup, hs.closure_eq]
rw [is_closed_iff_sup]
refine' ⟨fun H o ho f hf => H (out_nonempty_iff_ne_zero.2 ho) _ _, fun H ι hι f hf => _⟩
· exact fun i => hf _ _
· rw [← bsup_eq_sup]
    apply H (type_ne_zero_iff_nonempty.2 hι)
    exact fun i hi => hf _
simp only [frontier_eq_closure_inter_closure, Set.mem_inter_iff, mem_closure_iff] at ha
rw [← this]
exact enum_ord_mem hs _
unfold nfp_family
rw [@is_normal.sup _ H _ _ ⟨[]⟩]
apply le_antisymm <;> refine' Ordinal.sup_le fun l => _
· exact le_sup _ (i::l)
· exact (H.self_le _).trans (le_sup _ _)
rw [List.foldr_fixed' h l]
rw [← hi]
exact nfp_family_fp (H i) a
rw [deriv_family_succ, ← succ_le_iff] <;> apply le_nfp_family
rw [deriv_family_limit _ l, bsup_le_iff]
refine' limit_rec_on o _ (fun o IH => _) _
· rw [deriv_family_zero]
    exact nfp_family_fp H 0
· rw [deriv_family_succ]
    exact nfp_family_fp H _
· intro o l IH
    rw [deriv_family_limit _ l,
      IsNormal.bsup.{max u v, u, max u v} H (fun a _ => deriv_family f a) l.1]
    refine' eq_of_forall_ge_iff fun c => _
    simp (config := { contextual := true }) only [bsup_le_iff, IH]
unfold nfp_bfamily
rw [←
    @apply_lt_nfp_family_iff _ (family_of_bfamily o f) (out_nonempty_iff_ne_zero.2 ho) fun i =>
      H _ _]
refine' ⟨fun h i => h _ (typein_lt_self i), fun h i hio => _⟩
rw [← family_of_bfamily_enum o f]
apply h
rw [← family_of_bfamily_enum o f]
apply nfp_family_fp
rw [family_of_bfamily_enum]
exact H
refine' ⟨fun h => _, fun h i hi => _⟩
· have ho' : 0 < o := Ordinal.pos_iff_ne_zero.2 ho
    exact ((H 0 ho').self_le b).trans (h 0 ho')
rw [← nfp_bfamily_fp (H i hi)]
exact (H i hi).Monotone h
rw [Set.mem_Inter₂]
exact fun i hi => nfp_bfamily_fp (H i hi) _
rw [← family_of_bfamily_enum o f]
apply deriv_family_fp
rw [family_of_bfamily_enum]
exact H
unfold deriv_bfamily
rw [← le_iff_deriv_family]
· refine' ⟨fun h i => h _ _, fun h i hi => _⟩
    rw [← family_of_bfamily_enum o f]
    apply h
exact fun _ => H _ _
rw [← le_iff_deriv_bfamily H]
refine' ⟨fun h i hi => le_of_eq (h i hi), fun h i hi => _⟩
rw [← (H i hi).le_iff_eq]
exact h i hi
refine' funext fun a => le_antisymm _ (sup_le fun l => _)
· rw [sup_le_iff]
    intro n
    rw [← List.length_repeat Unit.unit n, ← List.foldr_const f a]
    apply le_sup
· rw [List.foldr_const f a l]
    exact le_sup _ _
rw [← sup_iterate_eq_nfp]
exact le_sup _ n
rw [← sup_iterate_eq_nfp]
exact lt_sup
rw [← sup_iterate_eq_nfp]
exact sup_le_iff
unfold nfp
rw [← @apply_lt_nfp_family_iff Unit (fun _ => f) _ (fun _ => H) a b]
exact ⟨fun h _ => h, fun h => h Unit.unit⟩
simp [h]
unfold deriv
rw [← le_iff_deriv_family fun _ : Unit => H]
exact ⟨fun h _ => h, fun h => h Unit.unit⟩
rw [← H.le_iff_eq, H.le_iff_deriv]
simp [h]
apply le_antisymm (nfp_le_fp (add_is_normal a).Monotone hba _)
· rw [← nfp_add_zero]
    exact nfp_monotone (add_is_normal a).Monotone (Ordinal.zero_le b)
· rw [← mul_one_add, one_add_omega]
rw [← add_eq_right_iff_mul_omega_le]
exact (add_is_normal a).le_iff_eq
revert b
rw [← funext_iff, is_normal.eq_iff_zero_and_succ (deriv_is_normal _) (add_is_normal _)]
refine' ⟨_, fun a h => _⟩
· rw [deriv_zero, add_zero]
    exact nfp_add_zero a
· rw [deriv_succ, h, add_succ]
    exact nfp_eq_self (add_eq_right_iff_mul_omega_le.2 ((le_add_right _ _).trans (le_succ _)))
rw [← mul_eq_right_iff_opow_omega_dvd]
exact (mul_is_normal ha).le_iff_eq
revert b
rw [← funext_iff,
    is_normal.eq_iff_zero_and_succ (deriv_is_normal _) (mul_is_normal (opow_pos omega ha))]
refine' ⟨_, fun c h => _⟩
· rw [deriv_zero, nfp_mul_zero, mul_zero]
· rw [deriv_succ, h]
    exact nfp_mul_opow_omega_add c ha zero_lt_one (one_le_iff_pos.2 (opow_pos _ ha))
cases n <;> simp
injection h
injection h
rw [lt_def, repr, repr_one] <;> exact zero_lt_one
rw [← of_nat_one] <;> infer_instance
rw [lt_def]
unfold repr
exact add_lt_add_left h _
injection h
rw [← opow_one ω, ← one_le_iff_ne_zero] <;> exact h.of_dvd_omega_opow
intro b o <;> cases o <;> delta top_below <;> infer_instance
simp
cases o <;> exact NF_below.zero
cases o <;> exact (Ordinal.zero_sub _).symm
cases o <;> rfl
cases o <;> rfl
have IH := oadd_mul_NF_below h₂.snd
cases o <;> exact NF.zero
cases o <;> exact (zero_mul _).symm
refine' repr_inj.1 _
simp
have := mt repr_inj.1 e0
exact Ordinal.add_sub_cancel_of_le (one_le_iff_ne_zero.2 this)
have := mt repr_inj.1 e0
rw [← opow_add, Ordinal.add_sub_cancel_of_le (one_le_iff_ne_zero.2 this)]
infer_instance
simp
rw [scale_eq_mul] <;> infer_instance
simp [scale_eq_mul]
cases o <;> cases n <;> rfl
simp <;> infer_instance
cases k <;> exact NF.zero
cases m <;> simp [opow_aux]
rw [nat_cast_succ, RR, ← mul_assoc]
rw [← mul_add, nat_cast_succ, opow_succ, IH.2]
cases k <;> simp [R, opow_aux]
simp
have := PNat.nat_pred_add_one m
rw [e'] at this
exact PNat.coe_inj.1 this.symm
rw [← e', ← PNat.coe_inj, Nat.succPNat_coe, ← Nat.add_one, PNat.nat_pred_add_one]
rw [repr, ihb.1, add_succ, repr]
rw [lt_def, h.1]
apply lt_succ
      fun i => (fast_growing a^[i]) i
subst x
rw [fast_growing]
rw [fast_growing_def h]
rfl
rw [fast_growing_def h]
rfl
rw [fast_growing_def h]
rfl
simp [fast_growing_ε₀]
simp [fast_growing_ε₀, show oadd 0 1 0 = 1 from rfl]
unfold Nonote <;> infer_instance
skip
dsimp [cmp]
have := Onote.cmp_compares a b
cases Onote.cmp a b <;> try exact this
exact Subtype.mk_eq_mk.2 this
rw [CNF_rec, dif_pos rfl]
rfl
rw [CNF_rec, dif_neg ho]
simp [CNF_ne_zero ho]
simp [CNF_ne_zero ho]
simp [CNF_ne_zero ho, log_eq_zero hb]
rw [CNF_zero]
rfl
rw [CNF_ne_zero ho, List.foldr_cons, IH, div_add_mod]
rw [hx] <;> exact cantor _
cases o
rfl
cases w
rfl
rw [Ordinal.type, WellOrder.eta, Quotient.out_eq]
simp
rw [← @type_eq_zero_iff_is_empty o.out.α (· < ·), type_lt]
rw [← @type_ne_zero_iff_nonempty o.out.α (· < ·), type_lt]
change α.out.r
change α.out.r
rw [RelEmbedding.trans_apply] <;> exact f.to_rel_embedding.map_rel_iff.2 h
rw [Subsingleton.elim f' g']
intros
subst e
let ⟨a, e⟩ := typein_surj r h
clear _let_match <;> subst e <;> rw [enum_typein]
rw [← typein_lt_typein r, typein_enum, typein_enum]
simp only [e, card_zero]
rw [← lift_umax]
exact lift_type_le
simp only [le_antisymm_iff, lift_le]
simp only [lt_iff_le_not_le, lift_le]
rw [lift_card] <;> exact card_le_card h
apply iff_of_true <;> apply Sum.Lex.sep
apply iff_of_false <;> exact Sum.lex_inr_inl
rw [h] <;> exact Or.inl (le_add_right _ _)
rw [h] <;> exact Or.inr (le_add_left _ _)
rw [← succ_zero, succ_le_iff]
rw [one_le_iff_pos, Ordinal.pos_iff_ne_zero]
simp only [← add_one_eq_succ, card_add, card_one]
simp
rw [← enum_typein (· < ·) a]
unfold default
congr
rw [← lt_one_iff_zero]
apply typein_lt_self
simp
rw [one_out_eq x, typein_enum]
rw [← not_lt, typein_lt_typein]
rw [typein_le_typein]
exact not_lt
rw [← @not_lt _ _ o' o, enum_lt_enum ho']
rw [← enum_le_enum (· < ·), ← not_lt]
rw [← enum_typein r a, enum_le_enum r]
apply Ordinal.zero_le
rw [← not_lt]
apply enum_zero_le
rw [type_lt]
exact lt_succ o
rw [← enum_typein (· < ·) a, enum_le_enum', ← lt_succ_iff]
apply typein_lt_self
rw [type_lt]
exact x.2
simp only [lift.principal_seg_top, univ_id]
rw [Ordinal.type_lt]
let ⟨r, _, e⟩ := ord_eq α
simp only [mk_def, e, card_type]
simp
rw [← lt_ord, h]
apply typein_lt_type
rw [← lt_ord]
apply typein_lt_self
intro c c' h
rw [← card_ord c, ← card_ord c', h]
simp only [e.symm, lift_lift]
rw [← Cardinal.ord_le, Cardinal.ord_nat]
rw [← succ_le_iff, ← succ_le_iff, ← nat_succ, nat_le_card]
rfl
simp only [le_antisymm_iff, card_le_nat, nat_le_card]
rw [← card_eq_nat, card_type, mk_fintype]
simp
rw [nadd]
rw [nadd_def]
simp [lt_blsub_iff]
rw [nadd_def]
simp [blsub_le_iff]
rw [nadd_comm, nadd_zero]
rw [nadd_comm, nadd_one]
rw [nadd_comm, nadd_nat]
rw [← to_ordinal_cast_nat n]
rfl
constructor <;> exact fun h a b ha hb => h hb ha
refine' le_antisymm _ (H.self_le _)
rw [← IsNormal.bsup_eq.{u, u} H ho', bsup_le_iff]
exact fun b hbo => (ho hao hbo).le
rw [← Ordinal.add_sub_cancel_of_le h₂, ← add_assoc, add_omega_opow h₁]
rw [principal_one_iff]
exact zero_mul _
rw [← nat_cast_mul]
apply nat_lt_omega
rw [← mul_assoc, mul_omega a0 ha]
apply le_antisymm
· have hbl := principal_mul_is_limit hb₂ hb
    rw [← IsNormal.bsup_eq.{u, u} (mul_is_normal (Ordinal.pos_iff_ne_zero.2 ha)) hbl, bsup_le_iff]
    intro c hcb
    have hb₁ : 1 < b := (lt_succ 1).trans hb₂
    have hbo₀ : (b^b.log a) ≠ 0 := Ordinal.pos_iff_ne_zero.1 (opow_pos _ (zero_lt_one.trans hb₁))
    apply le_trans (mul_le_mul_right' (le_of_lt (lt_mul_succ_div a hbo₀)) c)
    rw [mul_assoc, opow_succ]
    refine' mul_le_mul_left' (le_of_lt (hb (hbl.2 _ _) hcb)) _
    rw [div_lt hbo₀, ← opow_succ]
    exact lt_opow_succ_log_self hb₁ _
· rw [opow_succ]
    exact mul_le_mul_right' (opow_log_le_self b ha) b
infer_instance
change AddCommGroup ((forget₂ (RepCat k G) (ModuleCat k)).obj V)
infer_instance
change Module k ((forget₂ (RepCat k G) (ModuleCat k)).obj V)
infer_instance
infer_instance
infer_instance
rw [linearization_obj_ρ, Finsupp.lmap_domain_apply, Finsupp.map_domain_single]
rw [linearization_map_hom, Finsupp.lmap_domain_apply, Finsupp.map_domain_single]
infer_instance
infer_instance
infer_instance
apply MonoidAlgebra.induction_on r
· intro g
    simp only [one_smul, MonoidAlgebra.lift_single, MonoidAlgebra.of_apply]
    exact LinearMap.congr_fun (w g) x
· intro g h gw hw
    simp only [map_add, add_left_inj, LinearMap.add_apply, hw, gw]
· intro r g w
    simp only [AlgHom.map_smul, w, RingHom.id_apply, LinearMap.smul_apply, LinearMap.map_smulₛₗ]
dsimp [of_Module_monoid_algebra, to_Module_monoid_algebra]
refine' V.ρ.as_module_equiv.symm.trans _
exact (RestrictScalars.addEquiv _ _ _).symm
dsimp [counit_iso_add_equiv]
simp
dsimp [unit_iso_add_equiv, of_Module_monoid_algebra, to_Module_monoid_algebra]
simp only [AddEquiv.apply_eq_iff_eq, AddEquiv.apply_symm_apply,
    Representation.as_module_equiv_symm_map_rho, Representation.of_module_as_module_act]
dsimp [unit_iso_add_equiv]
simp only [Representation.as_module_equiv_symm_map_smul,
            RestrictScalars.add_equiv_symm_map_algebra_map_smul]
simp only [to_tensor_aux, lift_apply, sum_single_index, TensorProduct.smul_tmul']
· simp
simp [of_mul_action_def, to_tensor_aux_single, mul_assoc, inv_mul_cancel_left]
simp [of_tensor_aux, sum_single_index, smul_sum, mul_comm m]
simp [of_mul_action_def, of_tensor_aux_single, mul_smul]
refine'
    LinearMap.ext_iff.1
      (@Finsupp.lhom_ext _ _ _ k _ _ _ _ _
        (LinearMap.comp (of_tensor_aux _ _ _) (to_tensor_aux _ _ _)) LinearMap.id fun x y => _)
      x
dsimp
rw [to_tensor_aux_single x y, of_tensor_aux_single, Finsupp.lift_apply, Finsupp.sum_single_index,
    one_smul, Fin.partial_prod_left_inv]
· rw [zero_smul]
simp
simp [hz, hw]
rw [← Finsupp.smul_single', TensorProduct.smul_tmul, Finsupp.smul_single_one]
simp [of_tensor, of_tensor_aux]
rw [RingHom.id_apply, LinearEquiv.to_fun_eq_coe, ← LinearEquiv.map_smul]
congr 1
refine' x.induction_on _ (fun x y => _) fun y z hy hz => _
· simp only [smul_zero]
· simp only [TensorProduct.smul_tmul']
        show (r * x)
refine' is_limit.hom_ext (ActionCat.ofMulActionLimitCone.{u, 0} _ _).2 fun j => _
dsimp only [cech_nerve_terminal_from, pi.lift]
dsimp
rw [category.assoc, limit.iso_limit_cone_hom_π, limit.lift_π, category.assoc]
exact (limit.iso_limit_cone_hom_π _ _).symm
simp [d]
rw [← forget₂_to_Module_homotopy_equiv_f_0_eq, ←
        (forget₂_to_Module_homotopy_equiv k G).1.2 1 0 rfl] <;>
      exact comp_zero
refine' ChainComplex.to_single₀_ext _ _ _
dsimp
rw [category.comp_id]
exact (forget₂_to_Module_homotopy_equiv_f_0_eq k G).symm
let this :=
      (((linear_yoneda k (RepCat k G)).obj V).rightOp.leftDerivedObjIso n
            (GroupCohomology.projectiveResolution k G)).unop.symm <;>
    exact this
rw [MonoidHom.map_one]
rfl
rw [inv_mul_self, ρ_one]
rw [mul_inv_self, ρ_one]
rw [← category.assoc, p.comm, category.assoc, q.comm, ← category.assoc]
rw [iso.conj_apply, iso.eq_inv_comp]
simp [f.hom.comm']
intro g
simp
simp
simp [f.comm, g.comm]
simp [f.comm]
simp [f.comm]
dsimp [monoidal.transport_associator]
simp
dsimp [monoidal.transport_associator]
simp
dsimp [monoidal.transport_left_unitor]
simp
dsimp [monoidal.transport_left_unitor]
simp
dsimp [monoidal.transport_right_unitor]
simp
dsimp [monoidal.transport_right_unitor]
simp
change faithful (forget V G)
infer_instance
change faithful (forget V G)
infer_instance
change is_equivalence (ActionCat.functorCategoryEquivalence _ _).Functor
infer_instance
rw [← single_obj.inv_as_inv]
rfl
rw [← single_obj.inv_as_inv]
rfl
simp
assumption
simp only [End.one_def, ActionCat.ρ_one, F.map_id]
simp only [End.mul_def, F.map_comp, map_mul]
dsimp
rw [← F.map_comp, f.comm, F.map_comp]
dsimp
erw [category.id_comp, CategoryTheory.Functor.map_id, category.comp_id]
infer_instance
infer_instance
simp only [trace_mul_comm, character, map_mul]
simp only [character, map_one, trace_one]
rw [char_mul_comm, inv_mul_cancel_left]
rw [← char_iso (dual_tensor_iso_lin_hom _ _), char_tensor, Pi.mul_apply, char_dual]
rw [← (is_proj_average_map V.ρ).trace]
simp [character, GroupAlgebra.average, _root_.map_sum]
infer_instance
change AddCommGroup ((forget₂ (FdRep k G) (FgModule k)).obj V).obj
infer_instance
change Module k ((forget₂ (FdRep k G) (FgModule k)).obj V).obj
infer_instance
change FiniteDimensional k ((forget₂ (FdRep k G) (FgModule k)).obj V).obj
infer_instance
rw [FdRep.isoToLinearEquiv, ← FgModule.Iso.conj_eq_conj, iso.conj_apply]
rw [iso.eq_inv_comp ((ActionCat.forget (FgModule k) (MonCat.of G)).mapIso i)]
exact (i.hom.comm g).symm
infer_instance
infer_instance
infer_instance
infer_instance

-- Verify that Schur's lemma applies out of the box.
change right_rigid_category (ActionCat (FgModule k) (GroupCat.of G))
infer_instance
simp only [map_zero]
simp only [hv g, hw g, map_add]
simp only [hv g, LinearMap.map_smulₛₗ, RingHom.id_apply]
rfl
rw [average_map, ← as_algebra_hom_single_one, ← LinearMap.mul_apply, ← map_mul (as_algebra_hom ρ),
    mul_average_left]
rw [mem_invariants] at hv
simp [average, map_sum, hv, Finset.card_univ, nsmul_eq_smul_cast k _ v, smul_smul]
dsimp
erw [← ρ_Aut_apply_inv]
rw [← LinearMap.comp_assoc, ← ModuleCat.comp_def, ← ModuleCat.comp_def, iso.inv_comp_eq,
    ρ_Aut_apply_hom]
exact comm
rw [← FdRep.forget₂_ρ, ← FdRep.forget₂_ρ]
exact lin_hom.invariants_equiv_Rep_hom _ _
simp only [as_algebra_hom_def, MonoidAlgebra.lift_single]
simp
simp only [MonoidAlgebra.of_apply, as_algebra_hom_single, one_smul]
apply MonoidAlgebra.induction_on r
· intro g
    simp only [one_smul, MonoidAlgebra.lift_symm_apply, MonoidAlgebra.of_apply,
      Representation.as_algebra_hom_single, Representation.ofModule, AddEquiv.apply_eq_iff_eq,
      RestrictScalars.lsmul_apply_apply]
· intro f g fw gw
    simp only [fw, gw, map_add, add_smul, LinearMap.add_apply]
· intro r f w
    simp only [w, AlgHom.map_smul, LinearMap.smul_apply,
      RestrictScalars.add_equiv_symm_map_smul_smul]
dsimp
simp only [AddEquiv.apply_symm_apply, of_module_as_algebra_hom_apply_apply]
intro h₁ h₂
simp
simp only [hx, hy, add_mul, add_smul]
simp only [as_group_hom, MonoidHom.coe_toHomUnits]
simp only [map_one, TensorProduct.map_one]
simp only [map_mul, TensorProduct.map_mul]
show as_algebra_hom _ _ _ = as_algebra_hom _ _ _
show as_algebra_hom _ _ _ = _
simp only [add_comp]
dsimp [conjugate]
simp only [← i.map_smul, h, ← mul_smul, single_mul_single, mul_one, mul_left_inv]
change (1 : MonoidAlgebra k G)
rw [equivariant_projection, smul_apply, sum_of_conjugates_equivariant,
    equivariant_of_linear_of_comm_apply, sum_of_conjugates]
rw [LinearMap.sum_apply]
simp only [conjugate_i π i h]
rw [Finset.sum_const, Finset.card_univ, nsmul_eq_smul_cast k, ← mul_smul,
    Invertible.inv_of_mul_self, one_smul]
simp [Fintype.card_eq_zero_iff]
simp only [hf, Submodule.restrict_scalars_bot, LinearMap.ker_restrict_scalars]
trace
      "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `reflect_name #[]"
trace
            "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `reflect_name #[]"
trace
            "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `reflect_name #[]"
trace
            "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `reflect_name #[]"
infer_instance
simp [flip, functor_norm]
funext α x
apply H1
funext α β f x
apply H2
skip
apply Functor.ext
intros
exact (L1_pure_seq_eq_map _ _).symm.trans (L2_pure_seq_eq_map _ _)
refine' { .. } <;> intros <;> rfl
simp
simp [(· ∘ ·), functor_norm]
simp [(· ∘ ·), functor_norm]
simp [Applicative.pure_seq_eq_map', functor_norm]
rw [id_map]
refine' { .. } <;> intros <;> simp [mul_assoc, (· <$> ·), (· <*> ·), pure]
refine' { .. } <;> intros <;> simp [add_assoc, (· <$> ·), (· <*> ·), pure]
simp [Mvfunctor.map_map]
simp only [map_map, comp_assoc, subtype_val_to_subtype'] <;> simp [comp]
simp only [pred_last] <;> erw [const_iff_true]
simp only [pred_last] <;> erw [const_iff_true]
simp only [rel_last] <;> erw [repeat_eq_iff_eq]
simp only [rel_last] <;> erw [repeat_eq_iff_eq]
dsimp only [bind, pure, ULift.pure, ULift.bind]
cases f x
rfl
dsimp only [bind, pure, ULift.pure, ULift.bind]
cases f x
rfl

/- warning: ulift.rec.constant clashes with ULift.rec.constant -> ULift.rec.constant
warning: ulift.rec.constant -> ULift.rec.constant is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Sort.{u2}} (b : β), Eq.{imax (succ (max u1 u3)) u2} (forall (n : ULift.{u3, u1} α), (fun (_x : ULift.{u3, u1} α) => β) n) (ULift.rec.{u2, u3, u1} α (fun (_x : ULift.{u3, u1} α) => β) (fun (_x : α) => b)) (fun (_x : ULift.{u3, u1} α) => b)
but is expected to have type
  forall {α : Type.{u2}} {β : Sort.{u3}} (b : β), Eq.{imax (max (succ u2) (succ u1)) u3} ((ULift.{u1, u2} α) -> β) (ULift.rec.{u3, u1, u2} α (fun (_x : ULift.{u1, u2} α) => β) (fun (_x : α) => b)) (fun (_x : ULift.{u1, u2} α) => b)
Case conversion may be inaccurate. Consider using '#align ulift.rec.constant ULift.rec.constantₓ'. -/
simp [fst, bimap_bimap]
simp [fst, bimap_bimap]
simp [snd, bimap_bimap]
simp [snd, bimap_bimap]
refine' { .. } <;> intros <;> cases x <;> rfl
refine' { .. } <;> intros <;> rfl
refine' { .. } <;> intros <;> simp [bimap, functor_norm]
refine' { .. } <;> intros <;> cases x <;> rfl
refine' { .. } <;> intros <;> simp [Functor.map, functor_norm]
constructor <;> intros <;> simp [bimap, map_id, map_comp_map, functor_norm]
constructor <;> intros <;> simp [bimap, functor_norm]
constructor <;> intros <;> cases x <;> simp [bitraverse, Prod.bitraverse, functor_norm] <;> rfl
constructor <;> intros <;> cases x <;> simp [bitraverse, Sum.bitraverse, functor_norm] <;> rfl
constructor <;> intros <;> simp [bitraverse, Const.bitraverse, functor_norm] <;> rfl
constructor <;> intros <;> simp [traverse, comp_tsnd, functor_norm]
· rfl
· simp [tsnd_eq_snd_id]
    rfl
· simp [tsnd, binaturality, Function.comp, functor_norm]
constructor <;> intros <;>
    simp [bitraverse, Bicompl.bitraverse, bimap, traverse_id, bitraverse_id_id, comp_bitraverse,
      functor_norm]
· simp [traverse_eq_map_id', bitraverse_eq_bimap_id]
· revert x
    dsimp only [bicompl]
    simp [binaturality, naturality_pf]
constructor <;> intros <;> simp [bitraverse, Bicompr.bitraverse, bitraverse_id_id, functor_norm]
· simp [bitraverse_eq_bimap_id', traverse_eq_map_id']
    rfl
· revert x
    dsimp only [bicompr]
    intro
    simp [naturality, binaturality']
rw [← comp_bitraverse] <;> simp [tfst, map_comp_pure, Pure.pure]
rw [← comp_bitraverse] <;> simp [tfst, tsnd]
rw [← comp_bitraverse] <;> simp [tfst, tsnd]
rw [← comp_bitraverse] <;> simp [tsnd] <;> rfl
simp [tfst, fst, pure_eq_id_mk_comp_id, -comp.right_id, bitraverse_eq_bimap_id]
simp [tsnd, snd, pure_eq_id_mk_comp_id, -comp.right_id, bitraverse_eq_bimap_id]
rw [bind_pure_comp_eq_map]
cases x <;> cases x' <;> congr <;> apply h
intros
cases x
simp [(· <$> ·), WriterT.bind, WriterT.pure]
intros
simp [(· >>= ·), WriterT.bind, mul_assoc, functor_norm]
intros
rfl
cases x <;> rfl
cases x <;> rfl
cases x <;> rfl
cases x <;> rfl
cases x <;> rfl
funext r <;> simp
funext r <;> simp
apply Nat.find_min h'
rw [hk, Nat.succ_add, ← Nat.add_succ]
apply Nat.lt_of_succ_le
apply Nat.le_add_left
dsimp [Part.fix] <;> rw [assert_neg h']
simp [(pure_seq_eq_map _ _).symm]
simp [seq_assoc, (comp_map _ _ _).symm, (· ∘ ·)]
simp [pure_seq_eq_map]
simp [(pure_seq_eq_map _ _).symm] <;> simp [seq_assoc]
rw [← bind_pure_comp_eq_map, bind_assoc] <;> simp [bind_pure_comp_eq_map]
rw [← bind_pure_comp_eq_map, bind_assoc] <;> simp [pure_bind]
simp only [(· >=> ·), functor_norm]
simp only [(· >=> ·), functor_norm]
simp only [(· >=> ·), functor_norm]
simp only [joinM, (· ∘ ·), id.def, (bind_pure_comp_eq_map _ _).symm, bind_assoc, map_bind,
    pure_bind]
simp only [joinM, (· ∘ ·), id.def, map_bind, (bind_pure_comp_eq_map _ _).symm, bind_assoc,
    pure_bind]
simp only [joinM, (· ∘ ·), id.def, map_bind, (bind_pure_comp_eq_map _ _).symm, bind_assoc,
    pure_bind, bind_pure]
simp [guard]
simp [guard]
intros
rfl
intros
cases f <;> rfl
simp [seq_map_assoc, map_seq, seq_assoc, seq_pure, map_map]
rw [CommApplicative.commutative_prod] <;>
        simp [seq_map_assoc, map_seq, seq_assoc, seq_pure, map_map]
apply funext <;> apply id_map
apply funext <;> intro <;> rw [comp_map]
funext α β f x <;> apply H
    congr
funext α β
constructor <;> intros <;> rfl
simp [comp.map, Functor.map_id]
simp [comp.map, Functor.map_comp_map g' h, functor_norm]
intros <;> simp only [FreeMonoid.to_list_mul, flip, unop_op, List.foldl_append, op_inj] <;> rfl
intros
simp only [f.map_mul, (· <*> ·)]
intros
simp only [f.map_one, pure]
simp only [List.reverse_reverse]
simp only [List.foldr_eta]
simp [flip, List.foldr_reverse, foldl.of_free_monoid, unop_op]
rw [fold_map_hom_free (foldl.of_free_monoid (flip <| @cons α))]
· simp only [to_list, foldl, List.reverse_inj, foldl.get, foldl.of_free_monoid_comp_of]
· infer_instance
simp only [fold_map, traverse_map]
rw [← FreeMonoid.to_list_of_list (to_list xs), ← foldl.unop_of_free_monoid]
simp only [foldl, to_list_spec, fold_map_hom_free, foldl.of_free_monoid_comp_of, foldl.get,
    FreeMonoid.of_list_to_list]
change _ = foldr.of_free_monoid _ (FreeMonoid.ofList <| to_list xs) _
rw [to_list_spec, foldr, foldr.get, FreeMonoid.of_list_to_list, fold_map_hom_free,
    foldr.of_free_monoid_comp_of]
simp only [to_list_spec, free.map_eq_map, fold_map_hom, fold_map_map, FreeMonoid.of_list_to_list,
    FreeMonoid.map_of, (· ∘ ·)]
simp only [foldl, fold_map_map, (· ∘ ·), flip]
simp only [foldr, fold_map_map, (· ∘ ·), flip]
simp only [mfoldl, to_list_spec, fold_map_hom_free (mfoldl.of_free_monoid f),
        mfoldl.of_free_monoid_comp_of, mfoldl.get, FreeMonoid.of_list_to_list]
simp [mfoldl.of_free_monoid, unop_op, flip]
change _ = mfoldr.of_free_monoid f (FreeMonoid.ofList <| to_list xs) x
simp only [mfoldr, to_list_spec, fold_map_hom_free (mfoldr.of_free_monoid f),
    mfoldr.of_free_monoid_comp_of, mfoldr.get, FreeMonoid.of_list_to_list]
simp only [mfoldl, fold_map_map, (· ∘ ·), flip]
simp only [mfoldr, fold_map_map, (· ∘ ·), flip]
rw [← le_tsub_iff_right hxy] <;> apply le_of_succ_le_succ z.is_lt
decide
cases x <;> rfl
cases x <;> simp! [functor_norm] <;> rfl
cases x <;> rfl
induction xs <;> simp! [*, functor_norm] <;> rfl
induction x <;> simp! [*, functor_norm] <;> rfl
induction x <;> simp! [*, functor_norm] <;> rfl
induction x <;> simp! [*, functor_norm]
simp [traverse_append as bs, functor_norm] <;> congr
simp
simp
simp
simp [mem_traverse as bs]
cases x <;> simp [Sum.traverse, id_map, functor_norm] <;> rfl
cases x <;> rfl
cases x <;> simp! [Sum.traverse, map_id, functor_norm] <;> rfl
induction x <;> simp! [*, functor_norm] <;> rfl
cases x <;> simp [Sum.traverse, id_map, functor_norm] <;> congr <;> rfl
cases x <;> simp! [Sum.traverse, functor_norm]
simp [Equiv.map, id_map]
simp [Equiv.map] <;> apply comp_map
simp! [Equiv.traverse, idBind, id_traverse, Functor.map, functor_norm]
simp [Equiv.traverse, traverse_eq_map_id, functor_norm] <;> rfl
simp only [Equiv.traverse, functor_norm]
refine' { to_is_lawful_functor := Equiv.is_lawful_functor' eqv @h₀ @h₁.. } <;>
    intros
cases η
cases η'
congr
exact h
rw [← pure_seq_eq_map, η.preserves_seq] <;> simp [functor_norm]
simp
simp
simp [functor_norm]
simp [functor_norm]
refine' { .. } <;> intros <;> rfl
simp only [map_pure, seq_pure]
rfl
rw [@map_eq_traverse_id t _ _ _ _ f]
refine' (comp_traverse (id.mk ∘ f) g x).symm.trans _
congr
apply comp.applicative_comp_id
rw [@map_eq_traverse_id t _ _ _ _ g]
refine' (comp_traverse f (id.mk ∘ g) x).symm.trans _
congr
apply comp.applicative_id_comp
simp [sequence, traverse_map, id_traverse] <;> rfl
simp [sequence, traverse_map] <;> rw [← comp_traverse] <;> simp [map_id]
simp [sequence, naturality, traverse_map]
simp [map_equiv, map_trans']
rw [mem_iff f]
exact ⟨_, hh⟩
rw [fix_eq_ωSup f, hc]
apply le_antisymm
· apply ωSup_le_ωSup_of_le _
    intro i
    exists i
    intro x
    -- intros x y hx,
    apply le_f_of_mem_approx _ ⟨i, rfl⟩
· apply ωSup_le_ωSup_of_le _
    intro i
    exists i.succ
    rfl
rw [Part.fix_eq (to_unit_cont f hc)] <;> rfl
dsimp [fix]
conv => 
      lhs
      erw [LawfulFix.fix_eq (uncurry_curry_continuous hc)]
rfl
rw [← of_real_nat_cast, of_real_re]
exact h -- succeeds
decide
simp [add_comm] <;> rfl
have := congr_arg (coe : ZNum → ℤ) e
simp at this
have := sub_eq_zero.1 this
rw [← Num.to_nat_to_int, ← Num.to_nat_to_int] at this
exact Num.to_nat_inj.1 (Int.ofNat.inj this)
cases n <;> rfl
simp! [h, *]
simp! [h, *]
simp! [h, *]
simp [horner]
simp [h.symm, horner, pow_add, mul_assoc]
simp [h.symm, horner, add_assoc]
simp [h₂.symm, h₁.symm, horner, mul_add, mul_assoc]
simp [h₂.symm, h₁.symm, horner, add_mul, mul_right_comm]
rw [← h₂, ← h₁] <;> simp [horner, mul_add, mul_comm, mul_left_comm, mul_assoc]
rw [← H, ← h₂, ← h₁, ← h₃, ← h₄] <;> simp [horner, mul_add, mul_comm, mul_left_comm, mul_assoc]
simp [h₁.symm, h₂.symm, horner, mul_pow, pow_mul]
rw [← h₂, ← h₁, pow_succ']
simp [horner]
rw [prl, prr, prt]
rw [sub_eq_add_neg, h]
rw [div_eq_mul_inv, h]
simp [horner, mul_comm]
simp [mul_assoc]
simp [pow_add]
simp [pow_add, mul_assoc]
simp
simp
simp
simp
simp
simp
simp
simp
simp [h.symm, term] <;> ac_rfl
simp [h.symm, termg] <;> ac_rfl
simp [h.symm, term, add_assoc]
simp [h.symm, termg, add_assoc]
simp [h₁.symm, h₂.symm, term, add_nsmul] <;> ac_rfl
simp [h₁.symm, h₂.symm, termg, add_zsmul] <;> ac_rfl
simp [term, zero_nsmul, one_nsmul]
simp [termg]
simp [h₂.symm, h₁.symm, termg] <;> ac_rfl
simp [smul, nsmul_zero]
simp [smulg, zsmul_zero]
simp [h₂.symm, h₁.symm, term, smul, nsmul_add, mul_nsmul']
simp [h₂.symm, h₁.symm, termg, smulg, zsmul_add, mul_zsmul]
simp [term]
simp [termg]
rw [sub_eq_add_neg, h]
simp [prl, prr, prt]
simp [prl, prr, prt]
simp [← prt, prl₁, ← prl₂, prr, smul, smulg]
simp
simp only [add_zero, eq_self_iff_true, zero_add]
simp only [ n0 , zero_mul , zero_le ]
rw [prl, prr, prt]
rw [prl, prr, prt]
simp [pra, prt]
simp [bit1, bit0, add_left_comm, add_assoc]
simp [bit0, add_left_comm, add_assoc]
simp [bit0, bit1, add_left_comm, add_assoc]
simp [bit0, bit1, add_left_comm, add_comm, add_assoc]
simp [bit0, bit1, add_left_comm, add_comm, add_assoc]
simp [bit0, add_left_comm, add_assoc]
simp [bit0, add_left_comm, add_assoc]
simp [bit1, bit0, add_left_comm, add_assoc]
simp [bit1, bit0, add_left_comm, add_assoc]
simp [bit1, bit0, add_left_comm, add_assoc]
simp [bit1, bit0, add_left_comm, add_assoc]
simp [bit1, bit0, add_left_comm, add_assoc]
simp [bit1, bit0, add_left_comm, add_assoc]
simp [bit0, add_mul]
simp [bit0, mul_add]
rw [← he, ← hd, ← hc] <;> simp [bit1, bit0, mul_add, add_mul, add_left_comm, add_assoc]
simp [bit0, bit1, zero_lt_one, add_assoc]
simp
simp
simp
simp
simp
rw [mul_assoc c, hd, hc, ← h, ← ha.2, ← hb.2, ← mul_assoc, mul_right_comm a]
simp
simp
simp
simp only [inv_eq_one_div, one_div_neg_eq_neg_one_div]
rw [one_div, inv_inv]
simp only [inv_eq_one_div, one_div_div]
simp [pow_bit0, h]
rw [← h₃, ← h₂] <;> simp [pow_bit1, h]
rw [← h, hb, zpow_ofNat]
rw [← hc, ← h, hb, zpow_neg_coe_of_pos _ b0]
rw [← h] <;> simp
simp only [Int.to_nat_of_nonpos, h.le, neg_nonpos]
rw [← h] <;> simp
rw [← h] <;> simp
rw [← h₂, ← h₁] <;> rfl
simp
rw [← h, ← hm, Nat.add_mul_div_right _ _ (lt_of_le_of_lt (Nat.zero_le _) h₂), Nat.div_eq_of_lt h₂,
    zero_add]
rw [← h, ← hm, Int.add_mul_ediv_right _ _ (ne_of_gt (lt_of_le_of_lt h₁ h₂)),
    Int.div_eq_zero_of_lt h₁ h₂, zero_add]
rw [← h, ← hm, Nat.add_mul_mod_self_right, Nat.mod_eq_of_lt h₂]
rw [← h, ← hm, Int.add_mul_emod_self, Int.mod_eq_of_lt h₁ h₂]
rw [← h₁, Nat.dvd_iff_mod_eq_zero]
rw [← h₁, Int.dvd_iff_emod_eq_zero]
rw [← hx, ← hy]
apply h
cases on to make progress.
      
        Pre-condition
cases. The decision what expression
  to do the distinction on is driven
decide
simp
rw [Int.ediv_self ha.ne']
exact zero_lt_one
rw [← Int.cast_zero]
exact Int.cast_mono hn
simp only
rw [mul_assoc, ← zpow_add]
rw [mul_assoc, mul_self_zpow]
rw [mul_assoc, mul_zpow_self]
rw [mul_assoc, ← zpow_add] <;> rfl
simp
simp
simp
simp
rw [pq_pf]
rw [pq_pf]
rw [ps_pf, qs_pf]
rw [ps_pf, qs_pf]
rw [pps_pf, qqs_pf]
rw [pq_pf, pqs_pf]
simp [symm psqs_pf, pow_add, ps_pf, qs_pf] <;> ac_rfl
rw [ps_pf, zero_mul]
rw [pps_pf]
rw [qs_pf, mul_zero]
rw [qs_pf]
rw [pps_pf]
rw [psqs_pf]
rw [ps_pf, one_pow]
rw [pps_pf]
rw [pqs_pf, psqs_pf]
rw [ps_pf, qs_pf]
rw [ps_pf, qs_pf]
rw [qs_pf]
rw [pqqs_pf]
rw [pps_pf, add_zero, pqs_pf]
rw [qs_pf]
rw [qqs_pf]
simp
simp
simp
simp
simp
simp
cases a
cases b
rfl
cases x
cases y
rfl
cases x
cases y
rfl
decide
simp [names_nonempty]
simp only [val_between]
simp only [val_between_nil m, Omega.Coeffs.valBetween, get_nil, zero_add, zero_mul,
      Int.default_eq_zero]
rw [add_zero] at h1
rw [tsub_eq_zero_iff_le.mpr h1]
rw [← Nat.lt_succ_iff]
apply h1
intro h1
unfold val
rw [val_between_eq_of_le k _]
rfl
rw [zero_add]
exact h1
rw [← add_assoc]
apply lt_add_one
apply @Eq.trans _ _ (val_between v [] l m)
· apply val_between_eq_val_between
          · intros
            rfl
          · intro x h4 h5
            rw [get_nil, get_set_eq_of_ne, get_nil]
            apply ne_of_lt h5
apply val_between_nil
apply ne_of_gt h2
      rw [@val_between_set m h1 h2, get_set_eq_of_ne _ _ h3]
      simp only [h3, get_nil, add_zero, zero_mul, Int.default_eq_zero]
apply val_between_set (zero_le _)
rw [length_set, zero_add]
exact lt_max_of_lt_right (lt_add_one _)
unfold val_between
rw [neg_add, neg_mul_eq_neg_mul]
apply fun_mono_2
apply val_between_neg
apply fun_mono_2 _ rfl
apply get_neg
unfold val
rw [val_between_add]
apply fun_mono_2 <;> apply val_between_eq_of_le <;> rw [zero_add, length_add]
apply le_max_left
apply le_max_right
unfold val
rw [val_between_sub]
apply fun_mono_2 <;> apply val_between_eq_of_le <;> rw [zero_add, length_sub]
apply le_max_left
apply le_max_right
apply val_except_eq_val_except update_eq_of_ne (get_set_eq_of_ne _)
simp only [val_between, add_zero]
rw [add_comm, tsub_add_cancel_of_le h1]
simp only [val_between, mul_zero, List.map]
unfold val_between
rw [@val_between_map_mul m, mul_add]
apply fun_mono_2 rfl
apply forall_val_of_forall_mem _ h1
apply dvd_zero
unfold val_between
apply dvd_add
apply dvd_val_between h1
apply dvd_mul_of_dvd_left
apply dvd_val_between
simp only [Int.zero_div, val_between, List.map]
apply fun_mono_2 _ rfl
rw [get_map']
apply Int.zero_div
apply val_between_eq_zero
constructor <;> intro h1
· cases h1
    apply le_antisymm <;> assumption
· constructor <;> apply le_of_eq <;> rw [h1]
intro v h1
apply implies_neg_elim_core
apply (nnf_equiv v).elimRight h1
intro h1
apply univ_close_of_valid
apply valid_of_unsat_not
intro h2
apply h1
apply preform.sat_of_implies_of_sat implies_neg_elim h2
simp only [val]
simp only [val_var]
apply congr_arg fun y => m * y
apply h1 _ (lt_add_one _)
simp only [val_add]
have ht := val_constant t fun x hx => h1 _ (lt_of_lt_of_le hx (le_max_left _ _))
have hs := val_constant s fun x hx => h1 _ (lt_of_lt_of_le hx (le_max_right _ _))
rw [ht, hs]
simp only [val_sub]
have ht := val_constant t fun x hx => h1 _ (lt_of_lt_of_le hx (le_max_left _ _))
have hs := val_constant s fun x hx => h1 _ (lt_of_lt_of_le hx (le_max_right _ _))
rw [ht, hs]
simp only [canonize, preterm.val_const, term.val, coeffs.val_nil, add_zero]
simp only [preterm.val_var, coeffs.val_set, term.val, zero_add, Int.ofNat_mul, canonize]
simp only [val_canonize h1.left, val_canonize h1.right, Int.ofNat_add, canonize, term.val_add,
      preterm.val_add]
have h2 : n ≠ k := ne_of_lt h1
simp only [sub_subst, preterm.val]
rw [update_eq_of_ne _ h2]
simp only [sub_subst, val_add]
apply fun_mono_2 <;> apply val_sub_subst (le_trans _ h1)
apply le_max_left
apply le_max_right
simp only [sub_subst, val_sub]
simp only [preform.holds, preform.sub_subst]
apply pred_mono_2 <;> apply preterm.val_sub_subst (le_trans _ h1)
apply le_max_left
apply le_max_right
simp only [preform.holds, preform.sub_subst]
apply pred_mono_2 <;> apply preterm.val_sub_subst (le_trans _ h1)
apply le_max_left
apply le_max_right
apply not_congr
apply sub_subst_equiv p h1
simp only [preform.holds, preform.sub_subst]
apply pred_mono_2 <;> apply propext <;> apply sub_subst_equiv _ (le_trans _ h1)
apply le_max_left
apply le_max_right
simp only [preform.holds, preform.sub_subst]
apply pred_mono_2 <;> apply propext <;> apply sub_subst_equiv _ (le_trans _ h1)
apply le_max_left
apply le_max_right
simp only [holds]
apply pred_mono_2 <;> apply preterm.val_constant <;> intro x h2 <;>
      apply h1 _ (lt_of_lt_of_le h2 _)
apply le_max_left
apply le_max_right
simp only [holds]
apply pred_mono_2 <;> apply preterm.val_constant <;> intro x h2 <;>
      apply h1 _ (lt_of_lt_of_le h2 _)
apply le_max_left
apply le_max_right
apply not_congr
apply holds_constant p h1
simp only [holds]
apply pred_mono_2' <;> apply holds_constant <;> intro x h2 <;> apply h1 _ (lt_of_lt_of_le h2 _)
apply le_max_left
apply le_max_right
simp only [holds]
apply pred_mono_2' <;> apply holds_constant <;> intro x h2 <;> apply h1 _ (lt_of_lt_of_le h2 _)
apply le_max_left
apply le_max_right
intro h1 h2
apply Exists.imp h1 h2
simp only [preform.sat, preform.unsat, preform.valid, preform.holds]
rw [not_exists_not]
intro h
assumption
cases h2
simp only [nonneg_consts_core]
rw [List.forall_mem_cons]
constructor
· simp only [term.val, one_mul, zero_add, coeffs.val_set]
      apply h1
· apply holds_nonneg_consts_core (k + 1) bs
apply holds_nonneg_consts_core h1
simp only [dnf]
rw [List.mem_map]
refine' ⟨c, h4, rfl⟩
intro hnf hsf h1 h2
apply h1
apply exists_clause_sat hnf hsf h2
unfold clauses.sat at h3
rw [List.exists_mem_cons_iff] at h3
cases h3 <;> contradiction
apply univ_close_of_valid
apply valid_of_unsat_not
apply unsat_of_clauses_unsat
exact h1
simp only [preterm.val, add_zero, term.val, canonize, coeffs.val_nil]
simp only [canonize, val_canonize, term.val_add, preterm.val]
intro h1 h2
apply Exists.imp h1 h2
simp only [preform.sat, preform.unsat, preform.valid, preform.holds]
rw [not_exists_not]
intro h
assumption
constructor <;> intro h1
· cases h1
    apply le_antisymm <;> assumption
· constructor <;> apply le_of_eq <;> rw [h1]
intro h1 h2
apply h1
apply clauses_sat_dnf_core
apply neg_free_neg_elim _ (is_nnf_nnf _)
apply preform.sat_of_implies_of_sat implies_neg_elim
have hrw := exists_congr (@nnf_equiv p)
apply hrw.elim_right h2
simp only [add_zero, term.val, lin_comb, coeffs.val_nil]
simp only [add_zero, term.val, lin_comb, coeffs.val_nil]
simp only [add_zero, term.val, lin_comb, coeffs.val_nil]
apply add_nonneg
· apply mul_nonneg
        apply Int.coe_nat_nonneg
        apply h _ (Or.inl rfl)
· apply lin_comb_holds
        apply List.forall_mem_of_forall_mem_cons h
intro h1 h2
exact ⟨h1, h2⟩
rw [h1, h2]
rw [h1, h2]
rw [h1, h2]
simp only [update, if_pos rfl]
intro h1
unfold update
rw [if_neg h1]
unfold symdiv
unfold symmod
rw [mul_symdiv_eq, sub_sub_cancel]
exists (0 : Int)
simp only [add_zero, mul_zero, coeffs.val_between]
apply ne_of_gt
apply lt_trans h0
simp [a_n, m]
simp only [coeffs.val, List.length_map]
apply rhs_correct_aux
apply ne_of_gt
apply lt_trans h1
simp only [m, lt_add_iff_pos_right]
unfold term.val
rw [← coeffs.val_except_add_eq n, rhs_correct n h1 h2]
simp only [a_n, add_assoc]
rw [Function.funext_iff]
intro x
rfl
simp only [m]
rw [add_sub_cancel]
simp only [coeffs_reduce, term.val, m, a_n]
rw [← coeffs.val_except_add_eq n, coeffs.val_except_update_set, get_set, update_eq]
rw [← coeffs.val_except_add_eq n, get_set, zero_mul, add_zero, coeffs.val_except_update_set]
decide
decide
cases e <;> simp only [eq_elim] <;> apply sat_empty
unfold eq_elim
rw [← h3]
apply dvd_zero
simp only [eq_elim]
simp only [eq_elim]
intro h1 h2
apply h1
apply sat_eq_elim h2
cases t1
cases t2
simp only [add_assoc, coeffs.val_sub, neg_add_rev, val, sub, add_comm, add_left_comm,
    sub_eq_add_neg]
cases t1
cases t2
simp only [coeffs.val_add, add, val, add_comm, add_left_comm]
cases t
simp only [mul, mul_add, add_mul, List.length_map, coeffs.val, coeffs.val_between_map_mul, val,
    List.map]
intro h1 h2
simp only [val, div, List.map]
rw [Int.add_ediv_of_dvd_left h1]
apply fun_mono_2 rfl
rw [← coeffs.val_map_div h2]
constructor
contradiction
apply ne_of_gt
apply Nat.lt_add_of_pos_right
apply Nat.pos_of_ne_zero
contradiction
contradiction
infer_instance
contradiction
simp [*]
simp [*]
simp [*]
simp [*]
simp [*]
simp [*]
simp [h]
simp [h]
rw [← h3, mul_comm n1, mul_assoc n2, ← mul_assoc n1, h1, ← mul_assoc n2, mul_comm n2, mul_assoc,
    h2]
rw [← h3, mul_assoc, mul_div_left_comm, h2, ← mul_assoc, h1, mul_comm, one_mul]
simp [left_distrib, *]
simp [left_distrib, *, sub_eq_add_neg]
simp [*]
rw [mul_lt_mul_left, ← ha, ← hb, ← mul_assoc, ← mul_assoc, mul_comm bd, mul_lt_mul_left]
exact mul_pos had hbd
exact one_div_pos.2 hgcd
rw [mul_le_mul_left, ← ha, ← hb, ← mul_assoc, ← mul_assoc, mul_comm bd, mul_le_mul_left]
exact mul_pos had hbd
exact one_div_pos.2 hgcd
contradiction
rw [hn] <;> exact h2
rw [← h.coe] <;> exact a.2
simp only [normalize_fin, ← h] at * <;> rw [Nat.add_mod, ← ha, ← hb, Fin.add_def]
simp only [normalize_fin, ← h] at * <;> rw [Nat.mul_mod, ← ha, ← hb, Fin.mul_def]
cases f
cases g
cases h
rfl
simp [f.map_eq_zero_of_eq v h hij]
simp [a.map_eq_zero_of_eq v h hij, b.map_eq_zero_of_eq v h hij]
simp
simp [f.map_eq_zero_of_eq v h hij]
simp [f.map_eq_zero_of_eq v h hij, g.map_eq_zero_of_eq v h hij]
simp [f.map_eq_zero_of_eq v h hij]
rw [Function.update_same, Function.update_noteq hij.symm]
rw [Function.update_same, Function.update_noteq hij, Function.update_same]
rw [add_comm]
exact f.map_swap_add v hij
rw [g.map_perm, smul_smul]
simp
rw [f.map_smul, Function.update_eq_self, smul_eq_zero] at this
exact Or.resolve_left this hz
simp [perm.sign_swap i_ne_j, apply_swap_eq_self hv]
simp only [alternatization_def, smul_apply, sum_apply]
apply σ.induction_on' fun σ => _
exact _root_.congr_arg Quotient.mk' (Equiv.swap_mul_involutive i j σ)
simp
apply σ.induction_on' fun σ => _
dsimp only [Quotient.lift_on'_mk', Quotient.map'_mk', MultilinearMap.smul_apply,
    MultilinearMap.dom_dom_congr_apply, MultilinearMap.dom_coprod_apply, dom_coprod.summand]
intro hσ
cases hi : σ
simp only [dom_coprod', TensorProduct.lift.tmul, LinearMap.mk₂_apply]
rw [MultilinearMap.dom_coprod_alternization, coe_alternatization, coe_alternatization, mul_smul, ←
    dom_coprod'_apply, ← dom_coprod'_apply, ← TensorProduct.smul_tmul', TensorProduct.tmul_smul,
    LinearMap.map_smul_of_tower dom_coprod', LinearMap.map_smul_of_tower dom_coprod']
  -- typeclass resolution is a little confused here
infer_instance
infer_instance
refine' AlternatingMap.coe_multilinear_map_injective ((Basis.ext_multilinear e) fun v => _)
simp
refine' Fin.cases _ _
· rfl
· simp
rw [Orientation.map, AlternatingMap.dom_lcongr_refl, Module.Ray.map_refl]
simp
simp [Fin.sum_univ_succ]
simp
rw [← e₁.det.eq_smul_basis_det e₂]
rw [orientation_map, e.map_orientation_eq_det_inv_smul, units_inv_smul, units_smul_eq_self_iff,
    LinearEquiv.coe_det]
rw [orientation_map, e.map_orientation_eq_det_inv_smul, units_inv_smul, units_smul_eq_neg_iff,
    LinearEquiv.coe_det]
rw [orientation_units_smul, Finset.prod_update_of_mem (Finset.mem_univ _)]
simp
rw [← h]
exact Fintype.card_pos
rw [← h]
exact Fintype.card_pos
rw [e0, v, LinearMap.comp_apply, LinearMap.inl_apply, ← LinearMap.map_smul, Prod.smul_mk,
    smul_zero, smul_eq_mul, mul_one, ← LinearMap.map_add, Prod.mk_add_mk, zero_add, add_zero]
simp
simp
refine' neg_eq_of_add_eq_zero_right ((ι_mul_ι_add_swap _ _).trans _)
dsimp [QuadraticForm.polar]
simp only [add_zero, mul_zero, mul_one, zero_add, neg_zero, QuadraticForm.map_zero,
    add_sub_cancel, sub_self, map_zero, zero_sub]
rw [neg_eq_iff_neg_eq]
exact neg_e0_mul_v _ m
rw [← neg_v_mul_e0, ← neg_mul, mul_assoc, e0_mul_e0, mul_neg_one, neg_neg]
rw [to_even, CliffordAlgebra.lift_ι_apply, LinearMap.cod_restrict_apply]
rfl
intro m
rw [ι_sq_scalar, ← RingHom.map_mul, ← RingHom.map_sub, sub_eq_add_neg, Q'_apply, sub_eq_add_neg]
rw [of_even_ι, AlgHom.map_mul, AlgHom.map_add, AlgHom.map_sub, AlgHom.commutes,
                  AlgHom.commutes, Subalgebra.coe_mul, Subalgebra.coe_add, Subalgebra.coe_sub,
                  to_even_ι, to_even_ι, Subalgebra.coe_algebra_map, Subalgebra.coe_algebra_map]
rw [mul_sub, add_mul, add_mul, ← Algebra.commutes, ← Algebra.smul_def, ← map_mul, ←
                  Algebra.smul_def, sub_add_eq_sub_sub, smul_mul_assoc, smul_mul_assoc]
rw [← mul_assoc, e0_mul_v_mul_e0]
rw [mul_smul_comm, smul_mul_assoc, ← smul_neg, neg_e0_mul_v]
rw [Algebra.algebra_map_eq_smul_one, smul_mul_smul, e0_mul_e0, smul_neg]
rw [ι_eq_v_add_smul_e0, ι_eq_v_add_smul_e0, mul_add, add_mul, add_mul, add_assoc]
rw [Subtype.coe_eta]
rw [map_one, map_zero, map_zero, sub_zero, zero_add, one_mul]
induction x using CliffordAlgebra.induction
case h_grade0 r => simp only [AlgHom.commutes, Subalgebra.coe_algebra_map, reverse.commutes]
case h_grade1 m =>
    simp only [involute_ι, Subalgebra.coe_neg, to_even_ι, reverse.map_mul, reverse_v, reverse_e0,
      reverse_ι, neg_e0_mul_v, map_neg]
case h_mul x y hx hy => simp only [map_mul, Subalgebra.coe_mul, reverse.map_mul, hx, hy]
case h_add x y hx hy => simp only [map_add, Subalgebra.coe_add, hx, hy]
induction x using CliffordAlgebra.induction
case h_grade0 r => apply Algebra.commutes
case h_grade1 x => simp
case h_add x₁ x₂ hx₁ hx₂ => rw [mul_add, add_mul, hx₁, hx₂]
case h_mul x₁ x₂ hx₁ hx₂ => rw [mul_assoc, hx₂, ← mul_assoc, hx₁, ← mul_assoc]
induction x using CliffordAlgebra.induction
case h_grade0 r => exact reverse.commutes _
case h_grade1 x => rw [ι_eq_zero, LinearMap.zero_apply, reverse.map_zero]
case h_mul x₁ x₂ hx₁ hx₂ => rw [reverse.map_mul, mul_comm, hx₁, hx₂]
case h_add x₁ x₂ hx₁ hx₂ => rw [reverse.map_add, hx₁, hx₂]
dsimp [LinearMap.toSpanSingleton, LinearMap.id]
rw [mul_mul_mul_comm]
simp
simp only [involute_ι, to_complex_ι, AlgHom.map_neg, one_smul, Complex.conj_I]
exact AlgHom.congr_fun this c
rw [CliffordAlgebra.ι_sq_scalar, Q_apply, one_mul, RingHom.map_neg, RingHom.map_one]
rw [AlgEquiv.map_mul, mul_comm, AlgEquiv.map_mul]
induction x using CliffordAlgebra.induction
case h_grade0 r => exact reverse.commutes _
case h_grade1 x => rw [reverse_ι]
case h_mul x₁ x₂ hx₁ hx₂ => rw [reverse.map_mul, mul_comm, hx₁, hx₂]
case h_add x₁ x₂ hx₁ hx₂ => rw [reverse.map_add, hx₁, hx₂]
rw [equiv_apply, equiv_apply, to_complex_involute, to_complex_of_complex, to_complex_of_complex]
rw [ι_sq_scalar, Q_apply, ← Algebra.algebra_map_eq_smul_one]
simp
rw [ι_sq_scalar, Q_apply, ← Algebra.algebra_map_eq_smul_one]
simp
rw [eq_neg_iff_add_eq_zero, ι_mul_ι_add_swap, QuadraticForm.polar]
simp
simp
simp only [CliffordAlgebra.star_def']
induction c using CliffordAlgebra.induction
case h_grade0 r =>
    simp only [reverse.commutes, AlgHom.commutes, QuaternionAlgebra.coe_algebra_map,
      QuaternionAlgebra.conj_coe]
case h_grade1 x =>
    rw [reverse_ι, involute_ι, to_quaternion_ι, AlgHom.map_neg, to_quaternion_ι,
      QuaternionAlgebra.neg_mk, conj_mk, neg_zero]
case h_mul x₁ x₂ hx₁ hx₂ =>
    simp only [reverse.map_mul, AlgHom.map_mul, hx₁, hx₂, QuaternionAlgebra.conj_mul]
case h_add x₁ x₂ hx₁ hx₂ =>
    simp only [reverse.map_add, AlgHom.map_add, hx₁, hx₂, QuaternionAlgebra.conj_add]
rw [equiv_apply, equiv_apply, to_quaternion_star, to_quaternion_of_quaternion,
      to_quaternion_of_quaternion]
rw [← mul_one r₁, ← mul_one r₂, ← smul_eq_mul R, ← smul_eq_mul R, LinearMap.map_smul,
    LinearMap.map_smul, smul_mul_smul, ι_sq_scalar, QuadraticForm.zero_apply, RingHom.map_zero,
    smul_zero]
simp only [LinearMap.map_add, add_mul]
rfl
simp only [LinearMap.map_smul, smul_mul_assoc]
rfl
simp only [LinearMap.map_add, mul_add]
rfl
simp only [LinearMap.map_smul, mul_smul_comm]
rfl
simp only [mul_assoc]
rw [Algebra.smul_def, ι_sq_scalar, Algebra.left_comm]
rw [map_add, add_mul]
rw [LinearMap.map_smul, smul_mul_assoc]
rw [foldr_ι, foldr_ι]
exact mul_one _
simp only [contract_left_aux_apply_apply]
rw [mul_sub, ← mul_assoc, ι_sq_scalar, ← Algebra.smul_def, ← sub_add, mul_smul_comm, sub_self,
    zero_add]
rw [contract_right_eq, reverse.map_mul, reverse_ι, contract_left_ι_mul, map_sub, map_smul,
    reverse_reverse, reverse.map_mul, reverse_ι, contract_right_eq]
rw [← Algebra.smul_def, map_smul, Algebra.smul_def]
rw [← Algebra.commutes, contract_left_algebra_map_mul, Algebra.commutes]
rw [← Algebra.smul_def, LinearMap.map_smul₂, Algebra.smul_def]
rw [← Algebra.commutes, contract_right_algebra_map_mul, Algebra.commutes]
rw [contract_right_eq, reverse_ι, contract_left_ι, reverse.commutes]
rw [contract_right_eq, reverse.commutes, contract_left_algebra_map, map_zero]
rw [contract_right_eq, contract_right_eq, reverse_reverse, contract_left_contract_left, map_zero]
rw [contract_right_eq, contract_right_eq, contract_right_eq, contract_right_eq, reverse_reverse,
    reverse_reverse, contract_left_comm, map_neg]
simp only [change_form_aux_apply_apply]
rw [mul_sub, ← mul_assoc, ι_sq_scalar, map_sub, contract_left_ι_mul, ← sub_add, sub_sub_sub_comm,
    ← Algebra.smul_def, BilinForm.to_lin_apply, sub_self, sub_zero, contract_left_contract_left,
    add_zero, sub_smul]
dsimp [← BilinForm.to_quadratic_form_apply]
rw [h, QuadraticForm.sub_apply, sub_sub_cancel]
simp [QuadraticForm.to_quadratic_form_associated]
rw [change_form_aux_apply_apply, mul_one, contract_left_one, sub_zero]
rw [foldr_ι]
rfl
rw [change_form_ι_mul, change_form_ι, contract_left_ι, BilinForm.to_lin_apply]
erw [← AlgHom.map_mul, RingQuot.mk_alg_hom_rel R (rel.of m), AlgHom.commutes]
rfl
rw [← AlgHom.map_mul, ι_sq_scalar, AlgHom.commutes]
induction h
rw [AlgHom.commutes, AlgHom.map_mul, TensorAlgebra.lift_ι_apply, f.prop]
rw [LinearMap.comp_apply, AlgHom.to_linear_map_apply, comp_ι_sq_scalar]
intro h
apply (lift Q).symm.Injective
rw [lift_symm_apply, lift_symm_apply]
simp only [h]
rw [ι_sq_scalar, ι_sq_scalar, ι_sq_scalar]
rw [← RingHom.map_sub, ← RingHom.map_sub]
rw [ι_mul_comm, sub_mul, mul_assoc, ι_sq_scalar, ← Algebra.smul_def, ← Algebra.commutes, ←
    Algebra.smul_def, ← map_smul, ← map_smul, ← map_sub]
rw [← LinearMap.range_comp, ι_comp_lift]
rw [map_smul, smul_mul_assoc, ι_sq_scalar, Algebra.smul_def, ← map_mul, invOf_mul_self, map_one]
rw [map_smul, mul_smul_comm, ι_sq_scalar, Algebra.smul_def, ← map_mul, invOf_mul_self, map_one]
rw [inv_of_ι, map_smul, mul_smul_comm, ι_mul_ι_mul_ι, ← map_smul, smul_sub, smul_smul, smul_smul,
    invOf_mul_self, one_smul]
rw [inv_of_ι, map_smul, smul_mul_assoc, smul_mul_assoc, ι_mul_ι_mul_ι, ← map_smul, smul_sub,
    smul_smul, smul_smul, invOf_mul_self, one_smul]
simp [to_clifford]
rw [← foldr_reverse, reverse_ι, foldr_ι]
rw [← foldr_reverse, reverse.commutes, foldr_algebra_map]
rw [← foldr_reverse, reverse.map_one, foldr_one]
rw [← foldr_reverse, ← foldr_reverse, ← foldr_reverse, reverse.map_mul, foldr_mul]
rw [← foldr_reverse, reverse_prod_map_ι, ← List.map_reverse, foldr_prod_map_ι, List.foldr_reverse]
simp
simp
simp [reverse]
simp [reverse]
simp [reverse]
simp
simp [reverse_prod_map_ι xs]
simp
simp [pow_add, involute_prod_map_ι xs]
rw [← submodule_map_involute_eq_comap, ι_range_map_involute]
rw [← submodule_map_involute_eq_comap, even_odd_map_involute]
rw [reverse, Submodule.map_comp, ι_range_map_lift, LinearMap.range_comp, ← Submodule.map_comp]
exact Submodule.map_id _
rw [← submodule_map_reverse_eq_comap, ι_range_map_reverse]
rw [← submodule_map_reverse_eq_comap, even_odd_map_reverse]
refine' le_trans _ (le_supr _ ⟨0, Nat.cast_zero⟩)
exact (pow_zero _).ge
refine' le_trans _ (le_supr _ ⟨1, Nat.cast_one⟩)
exact (pow_one _).ge
rw [Subtype.coe_mk, pow_two]
exact
        Submodule.mul_mem_mul (LinearMap.mem_range_self (ι Q) m₁)
          (LinearMap.mem_range_self (ι Q) m₂)
simp only [Nat.cast_add, xi.prop, yi.prop]
rw [graded_algebra.ι_apply Q, DirectSum.of_mul_of, DirectSum.algebra_map_apply]
refine' DirectSum.of_eq_of_graded_monoid_eq (Sigma.subtype_ext rfl <| ι_sq_scalar _ _)
apply graded_algebra.ι Q
apply graded_algebra.ι Q
apply graded_algebra.lift_ι_eq Q
rw [supr_sigma]
simp only [reverse_involute_commute.eq, reverse_reverse, involute_involute]
simp only [map_mul, reverse.map_mul]
simp only [map_add]
rw [star_def, involute_ι, map_neg, reverse_ι]
rw [star_def, star_def, map_smul, map_smul]
rw [star_def, involute.commutes, reverse.commutes]
apply
    LinearMap.mk₂ R fun a b : Fin 3 → R =>
      ![a 1 * b 2 - a 2 * b 1, a 2 * b 0 - a 0 * b 2, a 0 * b 1 - a 1 * b 0]
· intros
    simp [vec3_add (_ : R), add_comm, add_assoc, add_left_comm, add_mul, sub_eq_add_neg]
· intros
    simp [smul_vec3 (_ : R) (_ : R), mul_comm, mul_assoc, mul_left_comm, mul_add, sub_eq_add_neg]
· intros
    simp [vec3_add (_ : R), add_comm, add_assoc, add_left_comm, mul_add, sub_eq_add_neg]
· intros
    simp [smul_vec3 (_ : R) (_ : R), mul_comm, mul_assoc, mul_left_comm, mul_add, sub_eq_add_neg]
simp [cross_apply, mul_comm]
rw [add_eq_zero_iff_eq_neg, cross_anticomm]
simp [cross_apply, mul_comm]
simp [cross_apply, vec3_dot_product, mul_sub, mul_assoc, mul_left_comm]
rw [← cross_anticomm, Matrix.dot_product_neg, dot_self_cross, neg_zero]
simp [Basis.tensorProduct]
simp [Basis.tensorProduct]
rw [pi_quotient_lift, lsum_apply, sum_apply, ← mkq_apply, lsum_apply, sum_apply,
      _root_.map_sum] <;>
    simp only [coe_proj, mapq_apply, mkq_apply, comp_apply]
simp
simp
rw [Function.rightInverse_iff_comp, ← coe_comp, ← @id_coe R]
refine' congr_arg _ (pi_ext fun i x => Quotient.inductionOn' x fun x' => funext fun j => _)
rw [comp_apply, pi_quotient_lift_single, Quotient.mk'_eq_mk, mapq_apply, quotient_pi_lift_mk,
        id_apply]
simp
simp
simp only [vandermonde_apply, Matrix.mul_apply, Matrix.transpose_apply, mul_pow]
simp only [vandermonde_apply, Matrix.mul_apply, Matrix.transpose_apply, pow_add]
constructor
· simp only [det_vandermonde v, Finset.prod_eq_zero_iff, sub_eq_zero, forall_exists_index]
    exact fun i _ j h₁ h₂ => ⟨j, i, h₂, (mem_Ioi.mp h₁).ne'⟩
· simp only [Ne.def, forall_exists_index, and_imp]
    refine' fun i j h₁ h₂ => Matrix.det_zero_of_row_eq h₂ (funext fun k => _)
    rw [vandermonde_apply, vandermonde_apply, h₁]
rw [ker_comp, of_le, comap_cod_restrict, ker_mkq, map_comap_subtype]
exact comap_mono (inf_le_inf_right _ le_sup_left)
rw [← ker_eq_bot, quotient_inf_to_sup_quotient, ker_liftq_eq_bot]
rw [ker_comp, ker_mkq]
exact fun ⟨x, hx1⟩ hx2 => ⟨hx1, hx2⟩
simp [of_le_apply]
simp [of_le_apply]
rw [quotient_quotient_equiv_quotient_aux_mk, mapq_apply, LinearMap.id_apply]
simp
simp
rw [Submodule.card_eq_card_quotient_mul_card (map T.mkq S),
    fintype.card_eq.mpr ⟨(quotient_quotient_equiv_quotient T S hST).toEquiv⟩]
rw [Finsupp.smul_single', mul_one]
rw [LinearEquiv.map_smul, repr_symm_single_one]
rw [repr_self, Finsupp.single_apply]
simp
rw [Finsupp.sum, LinearEquiv.map_sum]
simp [repr_symm_single, Finsupp.total_apply, Finsupp.sum]
rw [← b.coe_repr_symm]
exact b.repr.apply_symm_apply v
rw [← b.coe_repr_symm]
exact b.repr.symm_apply_apply x
rw [LinearEquiv.range, Finsupp.supported_univ]
simp [Finsupp.mem_supported_support]
simp only [b.coord_apply, Finsupp.ext_iff, Finsupp.zero_apply]
simp only [Basis.sumCoords, LinearMap.id_coe, LinearEquiv.coe_coe, id.def, Basis.repr_self,
    Function.comp_apply, Finsupp.coe_lsum, LinearMap.coe_comp, Finsupp.sum_single_index]
simp
simp only [repr_symm_apply, coord_apply, repr_total]
rw [hadd, Pi.add_apply]
simp [hsmul, Pi.smul_apply]
refine' b.ext fun j => _
show b.repr (b j) i = f (b j) i
rw [b.repr_self, f_eq]
rw [← this]
rfl
rw [h, b₂.repr_self]
simp [f.to_add_equiv_eq_coe]
rw [LinearEquiv.symm_trans_apply, Finsupp.dom_lcongr_symm, Finsupp.dom_lcongr_single]
simp
rw [coe_reindex_repr]
simp
rw [range_comp, Equiv.range_eq_univ, Set.image_univ]
rw [coe_reindex, range_reindex']
simp
rw [reindex_finset_range, reindex_apply, reindex_range_apply]
rfl
simp [reindex_finset_range]
rw [hl, LinearEquiv.map_zero]
rw [← b.total_repr x, Finsupp.total_apply, Finsupp.sum]
exact Submodule.sum_mem _ fun i hi => Submodule.smul_mem _ _ (Submodule.subset_span ⟨i, rfl⟩)
refine' b.ext fun i => _
simp
refine' b.ext fun i => _
simp
refine' b.ext fun i => _
simp
simp only [constr_def, LinearMap.comp_apply, Finsupp.lmap_domain_apply, Finsupp.total_apply]
rw [Finsupp.sum_map_domain_index] <;> simp [add_smul]
simp [Basis.constr_apply, b.repr_self]
rw [b.constr_def S f, LinearMap.range_comp, LinearMap.range_comp, LinearEquiv.range, ←
    Finsupp.supported_univ, Finsupp.lmap_domain_supported, ← Set.image_univ, ←
    Finsupp.span_image_eq_map_total, Set.image_id]
simp only [Basis.constr_basis, LinearMap.comp_apply]
simp [Basis.equiv]
simp
simp
simp
simp
simp
simp
simp
simp [Basis.singleton]
simp [Basis.singleton, Unique.eq_default i]
simp [Basis.equivFun, Finsupp.total_apply, Finsupp.sum_fintype]
rw [b.equiv_fun_apply, b.repr_self_apply]
simp [Basis.ofEquivFun, ← Finsupp.single_eq_pi_single, Finsupp.single_eq_update]
simp [b.constr_apply, b.equiv_fun_apply, Finsupp.sum_fintype]
simp [Finsupp.sum_fintype]
rw [LinearMap.comp_apply, b.constr_basis, Function.comp_apply, ← hi', b'.constr_basis,
              Function.comp_apply, hi', hgf, LinearMap.id_apply]
rw [LinearMap.comp_apply, b'.constr_basis, Function.comp_apply, ← hi', b.constr_basis,
              Function.comp_apply, hi', hfg, LinearMap.id_apply]
apply le_antisymm h
  -- then choose some `x ∈ range w \ range b`,
intro x p
simp
simp [hli.repr_eq_single i]
simp [hli.repr_eq_single j, h]
cases eq_or_ne j i
· simp only [h, if_true, eq_self_iff_true, mk_coord_apply_eq i]
· simp only [h, if_false, mk_coord_apply_ne h]
rw [← Set.range_comp]
rfl
rw [← span_image, Submodule.coe_subtype, h₁]
rw [h₂]
apply Subtype.mem x
rw [Subtype.ext_iff, ← hy₂]
simp
rw [Set.range_comp, Submodule.span_image, b.span_eq, Submodule.map_subtype_top]
rw [Fin.range_cons, Submodule.mem_span_insert', span_b]
exact hsp x
simp [Basis.finTwoProd]
simp [Basis.finTwoProd]
rw [coe_extend, Subtype.range_coe_subtype, set_of_mem_eq]
constructor
· rw [Submodule.ne_bot_iff]
    exact ⟨v, ⟨mem_span_singleton_self v, hv⟩⟩
· intro T hT
intro h
rw [h, zero_smul] at ha
exact hz ha.symm
simp [hf_inj]
change f b = Basis.extend this _
rw [Basis.extend_apply_self, Subtype.coe_mk]
rw [LinearMap.comp_assoc, hg, f.comp_id]
apply le_antisymm
· exact f.to_linear_map.lift_dim_le_of_injective f.injective
· exact f.symm.to_linear_map.lift_dim_le_of_injective f.symm.injective
rw [LinearMap.range_eq_top.2 h, dim_top]
rw [← dim_top R M]
exact dim_le_of_submodule _ _ le_top
rw [← dim_range_of_surjective f h]
apply dim_range_le
infer_instance
contradiction
simp
rw [k]
exact mem_top
  -- giving the desire contradiction.
rw [linear_independent_subtype_range inj', linear_independent_iff]
intro l z
rw [Finsupp.total_option] at z
simp only [v', Option.elim'] at z
change _ + Finsupp.total κ M R v l.some = 0 at z
    -- We have some linear combination of `b b'` and the `v i`, which we want to show is trivial.
    -- We'll first show the coefficient of `b b'` is zero,
    --
rw [l₀, zero_smul, zero_add] at z
exact linear_independent_iff.mp i _ z
    -- Finally we put those facts together to show the linear combination is trivial.
apply Cardinal.le_range_of_union_finset_eq_top
exact union_support_maximal_linear_independent_eq_range_basis b v i m
intro i
rw [← Submodule.ne_bot_iff]
exact i.prop
intro h
exact this.not_lt (h.symm ▸ zero_lt_one)
exact not_le_of_lt this ⟨Set.embeddingOfSubset _ _ hs⟩
    refine'
      lt_of_le_of_lt (le_trans Cardinal.mk_Union_le_sum_mk (Cardinal.sum_le_sum _ (fun _ => ℵ₀) _))
        _
    · exact fun j => (Cardinal.lt_aleph_0_of_finite _).le
    · simpa
apply linear_independent_le_span' v i w
rw [s]
exact le_top
infer_instance
cases fintypeOrInfinite ι <;>
    skip
rw [← @set_of_mem_eq _ s, ← Subtype.range_coe_subtype]
exact dim_span hs
have hb := b.linear_independent
rw [Fintype.linear_independent_iff] at hb⊢
intro g hg
apply hb g
simp only [← smul_assoc, ← Finset.sum_smul, smul_eq_zero] at hg
exact hg.resolve_right ha
rw [← Cardinal.lift_inj, ← (Basis.singleton PUnit R).mk_eq_dim, Cardinal.mk_punit]
rw [B.mk_eq_dim'', cond, B'.mk_eq_dim'']
rw [Finset.coe_sort_coe, Cardinal.mk_coe_finset]
let b := Basis.ofVectorSpace K V
let c := Basis.ofVectorSpace K V₁
rw [← Cardinal.lift_inj, ← (Basis.prod b c).mk_eq_dim, Cardinal.lift_add, ← Cardinal.mk_ulift, ←
    b.mk_eq_dim, ← c.mk_eq_dim, ← Cardinal.mk_ulift, ← Cardinal.mk_ulift,
    Cardinal.add_def (ULift _)]
exact
    Cardinal.lift_inj.1
      (Cardinal.lift_mk_eq.2 ⟨equiv.ulift.trans (Equiv.sumCongr Equiv.ulift Equiv.ulift).symm⟩)
cases nonempty_fintype η
let b i := Basis.ofVectorSpace K (φ i)
let this : Basis (Σj, _) K (∀ j, φ j) := Pi.basis b
rw [← Cardinal.lift_inj, ← this.mk_eq_dim]
simp [← (b _).mk_range_eq_dim]
rw [dim_pi, Cardinal.sum_const', Cardinal.mk_fintype]
rw [dim_pi, Cardinal.sum_const, Cardinal.mk_fintype, Cardinal.lift_nat_cast]
rw [dim_fun_eq_lift_mul, dim_self, Cardinal.lift_one, mul_one, Cardinal.nat_cast_inj]
simp [dim_fun']
rw [← dim_range_add_dim_ker f, ← dim_range_of_surjective f h]
rw [← dim_sup_add_dim_inf_eq]
exact self_le_add_right _ _
rw [Eq, dim_bot] at h <;> exact lt_irrefl _ h
rw [rank, LinearMap.range_zero, dim_bot]
refine' dim_le_of_submodule _ _ _
rw [LinearMap.range_comp]
exact LinearMap.map_le_range
rw [rank, rank, LinearMap.range_comp] <;> exact dim_map_le _ _
rw [← dim_range_add_dim_ker f]
exact self_le_add_right _ _
rw [← Submodule.rank_le_one_iff_is_principal, dim_top]
erw [hf ⟨x, hx⟩, Subtype.coe_mk]
rw [← ker_eq_bot, ker_comp, ker_mkq, disjoint_iff_comap_eq_bot.1 h.symm.disjoint]
rw [← range_eq_top, range_comp, range_subtype, map_mkq_eq_top, h.sup_eq_top]
apply LinearEquiv.ofBijective (p.subtype.coprod q.subtype)
constructor
· rw [← ker_eq_bot, ker_coprod_of_disjoint_range, ker_subtype, ker_subtype, prod_bot]
    rw [range_subtype, range_subtype]
    exact h.1
· rw [← range_eq_top, ← sup_eq_range, h.sup_eq_top]
simp
simp
simp [linear_proj_of_is_compl]
simp [linear_proj_of_is_compl]
dsimp only [linear_proj_of_is_compl]
rw [← prod_comm_trans_prod_equiv_of_is_compl _ _ hpq]
exact (prod_equiv_of_is_compl _ _ hpq).apply_symm_apply x
simp [of_is_compl]
simp [of_is_compl]
simp
simp
simp
simp
intro φ ψ
rw [Prod.snd_add, Prod.fst_add, of_is_compl_add]
intro c φ
simp [Prod.smul_snd, Prod.smul_fst, of_is_compl_smul]
simp only [(is_compl_of_proj hf).sup_eq_top, mem_top]
simp [← ker_eq_bot, hfg.inf_eq_bot]
rw [← range_eq_top]
simp [range_prod_eq hfg.sup_eq_top, *]
simp only [linear_proj_of_is_compl_ker, Subtype.coe_mk]
rw [← cod_restrict_ker]
exact is_compl_of_proj h.cod_restrict_apply_cod
rw [LinearEquiv.conj_apply]
exact h.eq_conj_prod_map'
dsimp only [eval]
rw [LinearMap.flip_apply, LinearMap.id_apply]
erw [constr_basis b, constr_basis b]
ac_rfl
rw [← b.to_dual_total_left, b.total_repr]
rw [← b.to_dual_total_right, b.total_repr]
rw [b.equiv_fun_apply, to_dual_eq_repr]
rw [← mem_bot R, ← b.repr.ker, mem_ker, LinearEquiv.coe_coe]
apply Finsupp.ext
intro b
rw [← to_dual_eq_repr, a]
rfl
rw [← total_dual_basis b, Basis.total_repr b.dual_basis l]
refine' b.ext fun i => b.dual_basis.ext fun j => _
rw [LinearMap.comp_apply, to_dual_apply_left, coe_to_dual_self, ← coe_dual_basis, dual.eval_apply,
    Basis.repr_self, Finsupp.single_apply, dual_basis_apply_self]
rw [Basis.equiv_fun_apply, dual_basis_repr]
rw [← eval_apply_eq_zero_iff K v, LinearMap.ext_iff]
rfl
intro i
rw [Set.mem_to_finset]
exact Iff.rfl
erw [LinearMap.map_sum]
simp only [h.eval, map_smul, smul_eq_mul]
rw [Finset.sum_eq_single i]
· simp
· intro q q_in q_ne
    simp [q_ne.symm]
· intro p_not_in
    simp [Finsupp.not_mem_support_iff.1 p_not_in]
refine' eq_of_sub_eq_zero (h.total _)
intro i
simp [-sub_eq_add_neg, LinearMap.map_sub, h.dual_lc, sub_eq_zero]
rw [h.basis.dual_basis_apply_self, h.coe_basis, h.eval, if_congr eq_comm rfl rfl]
rw [dual_annihilator_comap, dual_annihilator_bot, comap_top]
rw [dual_annihilator_comap, dual_annihilator_top, comap_bot, Module.eval_ker]
erw [of_is_compl_left_apply _ w]
rfl
rw [dual_restrict_comp_dual_lift]
rfl
infer_instance
refine' _
rw [Submodule.dualAnnihilatorComap, ← Module.eval_equiv_to_linear_map]
exact LinearEquiv.finrank_eq (LinearEquiv.ofSubmodule' _ _)
rw [finrank_dual_annihilator_comap_eq, W.quot_equiv_annihilator.finrank_eq.symm, add_comm,
    Submodule.finrank_quotient_add_finrank, Subspace.dual_finrank_eq]
simp only [dual_distrib, coe_comp, Function.comp_apply, hom_tensor_hom_map_apply,
    comp_right_apply, LinearEquiv.coe_coe, map_tmul, lid_tmul, Algebra.id.smul_eq_mul]
simp [dual_distrib_inv_of_basis]
rw [LinearMap.id_comp, LinearMap.comp_id]
rw [LinearMap.to_matrix_comp _ c, LinearMap.to_matrix_comp _ c]
rw [Matrix.mul_assoc, Matrix.trace_mul_comm]
rw [LinearMap.to_matrix_comp _ b, LinearMap.to_matrix_comp _ c]
rw [LinearMap.comp_id, LinearMap.comp_id]
have : ∃ s : Finset M, Nonempty (Basis s R M) := ⟨s, ⟨b⟩⟩
rw [trace, dif_pos this, ← trace_aux_def]
congr 1
apply trace_aux_eq
rw [trace_eq_matrix_trace_of_finset R b.reindex_finset_range, ← trace_aux_def, ← trace_aux_def,
    trace_aux_eq R b]
rw [trace, dif_neg H, LinearMap.zero_apply, LinearMap.zero_apply]
rw [trace_mul_comm]
simp
simp [LinearEquiv.eq_comp_to_linear_map_symm, trace_eq_contract_of_basis b]
rw [← comp_apply, trace_eq_contract]
have b := Module.Free.chooseBasis R M
rw [trace_eq_matrix_trace R b, to_matrix_one, Module.Free.finrank_eq_card_choose_basis_index]
simp
rw [← one_eq_id, trace_one]
have h := ext_iff.1 (trace_prod_map R M N) (f, g)
simp only [coe_comp, Function.comp_apply, prod_map_apply, coprod_apply, id_coe, id.def,
    prod_map_linear_apply] at h
exact h
rw [← comp_apply, trace_transpose]
have h := ext_iff.1 (ext_iff.1 (trace_tensor_product R M N) f) g
simp only [compr₂_apply, map_bilinear_apply, compl₁₂_apply, lsmul_apply,
    Algebra.id.smul_eq_mul] at h
exact h
have h := ext_iff.1 (ext_iff.1 (trace_comp_comm R M N) g) f
simp only [llcomp_apply', compr₂_apply, flip_apply] at h
exact h
rw [e.conj_apply, trace_comp_comm', ← comp_assoc, LinearEquiv.comp_coe,
    LinearEquiv.self_trans_symm, LinearEquiv.refl_to_linear_map, id_comp]
rw [h.eq_conj_prod_map, trace_conj', trace_prod_map', trace_id, map_zero, add_zero]
dsimp only [is_ortho]
rw [map_zero B, zero_apply]
dsimp only [is_ortho]
constructor <;> intro H
· rw [map_smulₛₗ₂, H, smul_zero]
· rw [map_smulₛₗ₂, smul_eq_zero] at H
    cases H
    · rw [map_eq_zero I₁] at H
      trivial
    · exact H
rw [hs, map_zero, zero_apply]
apply Finset.sum_eq_single_of_mem i hi
intro j hj hij
rw [is_Ortho_def.1 hv₁ _ _ hij, mul_zero]
refine' ⟨ker_flip_eq_bot H, fun h => _⟩
exact (congr_arg _ B.flip_flip.symm).trans (ker_flip_eq_bot (flip_is_refl_iff.mpr H) h)
rw [← H.eq]
simp [H1]
have H1 : B (y + x) (y + x) = 0 := self_eq_zero H (y + x)
simp [map_add, self_eq_zero H] at H1
rw [add_eq_zero_iff_neg_eq] at H1
exact H1
intro x y h
rw [← neg H, h, neg_zero]
rw [LinearMap.IsOrtho, map_add, show B n x = 0 from hx n hn, show B n y = 0 from hy n hn,
      zero_add]
rw [LinearMap.IsOrtho, LinearMap.map_smulₛₗ, show B n x = 0 from hx n hn, smul_zero]
simp at y
exact y
rw [orthogonal_span_singleton_eq_to_lin_ker]
exact (B x).span_singleton_sup_ker_eq_top hx
simp only [zero_apply, map_zero]
rw [f.add_apply, g.add_apply, B'.map_add₂, (B x).map_add, h, h']
rw [LinearMap.comp_apply, LinearMap.comp_apply, h', h]
rw [f.sub_apply, g.sub_apply, B'.map_sub₂, (B x).map_sub, h, h']
simp only [smul_apply, map_smul, smul_eq_mul, h _ _]
simp
rw [is_skew_adjoint_iff_neg_self_adjoint]
exact Iff.rfl
intro x hx
rw [← e₁.symm.map_eq_zero_iff]
refine' h (e₁.symm x) fun y => _
specialize hx (e₂ y)
simp only [LinearEquiv.arrow_congr_apply, LinearEquiv.symm_apply_apply,
    LinearEquiv.map_eq_zero_iff] at hx
exact hx
rw [← flip_separating_right, flip_flip]
rw [← flip_separating_left, separating_left_iff_linear_nontrivial]
rw [← flip_separating_left, separating_left_iff_ker_eq_bot]
rw [is_Ortho_flip] at h
rw [is_ortho_flip]
exact h.not_is_ortho_basis_self_of_separating_left (flip_separating_left.mpr hB) i
rw [is_Ortho_flip] at hO
rw [← flip_separating_left]
refine' is_Ortho.separating_left_of_not_is_ortho_basis_self v hO fun i => _
rw [is_ortho_flip]
exact h i
simp only [LinearMap.ext_iff, pi_apply, funext_iff] <;>
    exact ⟨fun h a b => h b a, fun h a b => h b a⟩
simp only [mem_infi, mem_ker, proj_apply] at h
exact (mem_bot _).2 (funext fun i => h i)
simp only [Pi.add_apply, add_comp, Finset.sum_add_distrib]
simp only [Pi.smul_apply, smul_comp, Finset.smul_sum, RingHom.id_apply]
simp [Finset.univ_sum_single]
simp [Function.funext_iff]
simp [Function.funext_iff]
simp [pi_ring, LinearMap.lsum]
rw [f.map_add, g.map_add, Matrix.cons_add_cons (f x)]
rw [f.map_smul, g.map_smul, RingHom.id_apply, Matrix.smul_cons c (f x)]
simp only [f.map_add, g.map_add, LinearMap.add_apply, LinearMap.vec_cons_apply,
        Matrix.cons_add_cons (f x z)]
simp [Matrix.smul_cons r (f x z)]
rw [smul_mul_assoc, one_mul]
simp [FreeAddMonoid.lift_eval_of, C0 r' f i hf]
simp [FreeAddMonoid.lift_eval_of, C0']
simp [FreeAddMonoid.lift_eval_of, C_add]
simp [FreeAddMonoid.lift_eval_of, C_add_scalar]
simp [FreeAddMonoid.lift_eval_of, C_smul]
simp [zero_tprod_coeff]
simp [add_tprod_coeff]
simp [add_tprod_coeff', mul_add]
simp [smul_tprod_coeff, mul_smul_comm]
simp [smul_tprod_coeff', smul_smul]
simp [smul_tprod_coeff' _ _]
simp only [smul_tprod_coeff', smul_comm]
simp only [smul_tprod_coeff', smul_assoc]
simp [smul_tprod_coeff' _ _, add_smul, add_tprod_coeff']
simp [PiTensorProduct.smul_add, ihx, ihy, add_add_add_comm]
rw [PiTensorProduct.smul_add, ihx, ihy, add_zero]
simp only [mul_one, Algebra.id.smul_eq_mul]
rw [φ₁.map_add, φ₂.map_add, hx, hy]
rw [map_coord_zero φ i hf, smul_zero]
rw [zero_smul]
rw [← smul_add, φ.map_add]
rw [← add_smul]
simp [φ.map_smul, smul_smul, mul_comm]
simp only [lift_aux, lift_add_hom, tprod, MultilinearMap.coe_mk, tprod_coeff,
    FreeAddMonoid.lift_eval_of, one_smul, AddCon.lift_mk']
simp [lift_aux, lift_add_hom, tprod_coeff, FreeAddMonoid.lift_eval_of]
refine' PiTensorProduct.induction_on' x _ _
· intro z f
    rw [smul_tprod_coeff' r z f, lift_aux_tprod_coeff, lift_aux_tprod_coeff, smul_assoc]
· intro z y ihz ihy
    rw [smul_add, (lift_aux φ).map_add, ihz, ihy, (lift_aux φ).map_add, smul_add]
apply x.induction_on
· intro r f
      have := Subsingleton.elim f isEmptyElim
      simp [this]
· simp only
      intro x y hx hy
      simp [add_smul, hx, hy]
simp only [mul_one, Algebra.id.smul_eq_mul, const_of_is_empty_apply, LinearMap.map_smul,
      PiTensorProduct.lift.tprod]
simp only [of_subsingleton_apply, lift.tprod, Function.eval_apply]
simp only [LinearEquiv.map_add, LinearMap.map_add]
simp only [LinearEquiv.map_smul, LinearMap.map_smul, RingHom.id_apply]
erw [TensorProduct.lift.tmul, PiTensorProduct.lift.tprod, PiTensorProduct.lift.tprod]
rfl
rw [ker_lsingle]
exact disjoint_bot_right
rw [Ne.def, ← (b i).repr.Injective.eq_iff, (b i).repr.apply_symm_apply, ext_iff]
simp only [exists_prop, LinearEquiv.map_zero, comap_domain_apply, zero_apply,
              exists_and_right, mem_support_iff, exists_eq_right, Sigma.exists, Finset.mem_image,
              not_forall]
let bs := Basis.ofVectorSpace K V
rw [← bs.mk_eq_dim'', ← (Finsupp.basis fun a : ι => bs).mk_eq_dim'', Cardinal.mk_sigma,
    Cardinal.sum_const']
simp
rw [← to_lin'_mul]
rw [mul_left_inv, to_lin'_one, id_apply]
rw [← to_lin'_mul]
rw [mul_right_inv, to_lin'_one, id_apply]
simp
simp
rw [← AlgHom.map_add]
exact RingQuot.mk_alg_hom_rel R rel.add
rw [← AlgHom.map_smul]
exact RingQuot.mk_alg_hom_rel R rel.smul
induction h <;> simp [Algebra.smul_def]
dsimp [lift, ι]
rfl
rw [← lift_symm_apply]
exact (lift R).apply_symm_apply g
rw [← lift_symm_apply, ← lift_symm_apply] at w
exact (lift R).symm.Injective w
simp [algebra_map_inv]
simp [ι_inv]
rw [← ι_inj R x 0, LinearMap.map_zero]
rw [← (algebraMap R (TensorAlgebra R M)).map_one, Ne.def, ι_eq_algebra_map_iff]
exact one_ne_zero ∘ And.right
simp [to_tensor]
simp [h p']
simp only [LinearEquiv.trans_apply, coe_to_equiv, (· ∘ ·), Equiv.coe_trans, map_vadd]
simp [vsub_vadd_eq_vsub_sub, neg_add_eq_sub]
simp [homothety_apply, point_reflection_apply]
simp [weighted_vsub_of_point, LinearMap.sum_apply]
rw [weighted_vsub_of_point_apply, sum_smul]
rw [weighted_vsub_of_point_apply, weighted_vsub_of_point_apply]
apply sum_erase
rw [vsub_self, smul_zero]
rw [weighted_vsub_of_point_apply, weighted_vsub_of_point_apply]
apply sum_insert_zero
rw [vsub_self, smul_zero]
rw [sum_smul_vsub_eq_weighted_vsub_of_point_sub, weighted_vsub_of_point_apply_const]
rw [sum_smul_vsub_eq_weighted_vsub_of_point_sub, weighted_vsub_of_point_apply_const]
rw [map_neg, sub_neg_eq_add, s.weighted_vsub_of_point_sdiff h]
rw [weighted_vsub_of_point_apply, weighted_vsub_of_point_apply, ← sum_subtype_eq_sum_filter]
simp [weighted_vsub, LinearMap.sum_apply]
rw [weighted_vsub, weighted_vsub_of_point_apply_const, h, zero_smul]
simp [weighted_vsub_apply]
rw [sum_smul_vsub_eq_weighted_vsub_sub, s.weighted_vsub_apply_const _ _ h, sub_zero]
rw [sum_smul_vsub_eq_weighted_vsub_sub, s.weighted_vsub_apply_const _ _ h, zero_sub]
rw [affine_combination_apply, s.weighted_vsub_of_point_apply_const, h, one_smul, vsub_vadd]
rw [← vadd_eq_add, AffineMap.map_vadd, affine_combination_linear]
rw [← AffineMap.linear_map_vsub, affine_combination_linear, vsub_eq_sub]
simp only [affine_combination, weighted_vsub_of_point_apply, id.def, vadd_right_cancel_iff,
    Function.comp_apply, AffineMap.coe_mk]
let g₁ : s → V := fun i => w (f i)
simp [s.weighted_vsub_apply, vsub_eq_sub, smul_sub, ← Finset.sum_smul, hw]
simp [s.affine_combination_eq_weighted_vsub_of_point_vadd_of_sum_eq_one w p hw 0]
rw [affine_combination_apply, affine_combination_apply,
    weighted_vsub_of_point_indicator_subset _ _ _ h]
rw [sum_smul_vsub_eq_affine_combination_vsub, affine_combination_apply_const _ _ _ h]
rw [sum_smul_vsub_eq_affine_combination_vsub, affine_combination_apply_const _ _ _ h]
rw [affine_combination_apply, affine_combination_apply, weighted_vsub_of_point_subtype_eq_filter]
rw [affine_combination_apply, affine_combination_apply,
    s.weighted_vsub_of_point_filter_of_ne _ _ _ h]
have b := Classical.choice (inferInstance : affine_space V P).Nonempty
have b₂ := Classical.choice (inferInstance : affine_space V₂ P₂).Nonempty
rw [s.affine_combination_eq_weighted_vsub_of_point_vadd_of_sum_eq_one w p hw b,
    s.affine_combination_eq_weighted_vsub_of_point_vadd_of_sum_eq_one w (f ∘ p) hw b₂, ←
    s.weighted_vsub_of_point_vadd_eq_of_sum_eq_one w (f ∘ p) hw (f b) b₂]
simp only [weighted_vsub_of_point_apply, RingHom.id_apply, AffineMap.map_vadd,
    LinearMap.map_smulₛₗ, AffineMap.linear_map_vsub, LinearMap.map_sum]
simp [affine_combination_single_weights]
simp [affine_combination_single_weights, h]
rw [← affine_combination_single_weights_apply_self k i]
exact sum_eq_single_of_mem i h fun j _ hj => affine_combination_single_weights_apply_of_ne k hj
simp [weighted_vsub_vsub_weights]
simp [weighted_vsub_vsub_weights, h]
simp [weighted_vsub_vsub_weights, h.symm]
simp [weighted_vsub_vsub_weights, hi, hj]
simp [affine_combination_line_map_weights]
simp [affine_combination_line_map_weights, h.symm, sub_eq_neg_add]
simp [affine_combination_line_map_weights, h.symm]
simp [affine_combination_line_map_weights, hi, hj]
simp
rw [weighted_vsub_vsub_weights, ← affine_combination_vsub,
    s.affine_combination_affine_combination_single_weights k p hi,
    s.affine_combination_affine_combination_single_weights k p hj]
rw [affine_combination_line_map_weights, ← weighted_vsub_vadd_affine_combination,
    weighted_vsub_const_smul, s.affine_combination_affine_combination_single_weights k p hi,
    s.weighted_vsub_weighted_vsub_vsub_weights k p hj hi, AffineMap.line_map_apply]
simp [h]
simp [h]
simp [centroid_def, affine_combination_apply]
simp [centroid_def, affine_combination_map, centroid_weights]
rw [sum_centroid_weights_indicator]
exact s.sum_centroid_weights_eq_one_of_card_ne_zero k h
rw [sum_centroid_weights_indicator]
exact s.sum_centroid_weights_eq_one_of_nonempty k h
rw [sum_centroid_weights_indicator]
exact s.sum_centroid_weights_eq_one_of_card_eq_add_one k h
intro x y h
rw [Subtype.ext_iff, ← (hf' x).2, ← (hf' y).2, h]
rw [Finset.sum_update_of_mem hi1, Finset.sum_const_zero, add_zero]
rw [direction_affine_span, ← hw1s, Finset.affine_combination_vsub]
apply weighted_vsub_mem_vector_span
simp [Pi.sub_apply, h, hw1]
rw [← h, Set.sum_indicator_subset _ (Finset.subset_insert i0 s)]
rw [hs]
exact (Finset.weighted_vsub_indicator_subset _ _ (Finset.subset_insert i0 s)).symm
rw [Finset.sum_update_of_mem (Finset.mem_insert_self _ _), Finset.sum_const_zero, add_zero]
intro i hij
simp [w', hij]
simp
simp
rw [h, h p', vadd_vsub_assoc, f'.map_add, vadd_vadd]
simp [smul_add]
simp [add_add_add_comm]
simp [sub_add_sub_comm]
simp [add_comm]
simp [vadd_vadd, add_right_comm]
simp [vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, add_sub, sub_add_eq_add_sub]
intro p v
rw [Function.comp_apply, g.map_vadd, f.map_vadd]
rfl
rw [line_map_apply, vadd_vsub]
simp [line_map_apply]
simp [line_map_apply]
simp [line_map_apply]
rw [line_map_apply, line_map_apply, ← @vsub_eq_zero_iff_eq V1, vadd_vsub_vadd_cancel_right, ←
    sub_smul, smul_eq_zero, sub_eq_zero, vsub_eq_zero_iff_eq, or_comm', eq_comm]
rw [← @line_map_eq_line_map_iff k V1, line_map_apply_zero]
rw [← @line_map_eq_line_map_iff k V1, line_map_apply_one]
simp [line_map_apply]
rw [comp_line_map]
simp
rw [line_map_symm p₀, comp_apply]
congr
simp [line_map_apply]
rw [← neg_vsub_eq_vsub_rev, line_map_vsub_left, ← smul_neg, neg_vsub_eq_vsub_rev]
rw [← line_map_apply_one_sub, line_map_vsub_left]
rw [← line_map_apply_one_sub, left_vsub_line_map]
simp [← f.map_vadd]
simp
rw [decomp] <;> simp only [LinearMap.map_zero, Pi.add_apply, add_sub_cancel, zero_add]
simp
simp
simp [homothety_apply, mul_smul]
simp only [homothety_def, add_smul, vadd_vadd]
simp only [Convex.combo_eq_smul_sub_add h, ← vsub_eq_sub]
exact f.apply_line_map _ _ _
simp
rw [e.surjective.range_comp]
exact b.3
rw [this, ← direction_affine_span, b.tot, AffineSubspace.direction_top]
exact le_rfl
simp [basis_of]
rw [vadd_vsub_assoc, LinearMap.map_add, vadd_eq_add, LinearMap.neg_apply,
      sub_add_eq_sub_sub_swap, add_comm, sub_eq_add_neg]
simp only [coord, Basis.coe_sum_coords, LinearEquiv.map_zero, LinearEquiv.coe_coe, sub_zero,
    AffineMap.coe_mk, Finsupp.sum_zero_index, vsub_self]
rw [coord, AffineMap.coe_mk, ← Subtype.coe_mk j h, ← b.basis_of_apply i ⟨j, h⟩,
    Basis.sum_coords_self_apply, sub_self]
cases eq_or_ne i j <;> simp [h.symm]
simp [h]
rw [b.tot]
exact AffineSubspace.mem_top k V q
rw [b.tot]
exact AffineSubspace.mem_top k V q
rw [← b.affine_combination_coord_eq_self q₁, ← b.affine_combination_coord_eq_self q₂]
simp only [h]
rw [← image_univ]
apply subsingleton.image
apply subsingleton_of_subsingleton
simp
simp
simp
simp
simp
simp [hij, Finset.sum_ite, Finset.filter_insert, Finset.filter_eq']
simp
simp
rw [Finset.sum_comm]
simp [hA, Matrix.one_apply, Finset.filter_eq]
have hu := b.is_unit_to_matrix b₂
rw [Matrix.is_unit_iff_is_unit_det] at hu
rw [← b.to_matrix_vec_mul_coords b₂, Matrix.vec_mul_vec_mul, Matrix.mul_nonsing_inv _ hu,
    Matrix.vec_mul_one]
have hu := b.is_unit_to_matrix b₂
rw [Matrix.is_unit_iff_is_unit_det] at hu
rw [← b.to_matrix_inv_vec_mul_to_matrix, Matrix.det_smul_inv_vec_mul_eq_cramer_transpose _ _ hu]
rw [Finset.centroid,
    b.coord_apply_combination_of_mem hi (s.sum_centroid_weights_eq_one_of_nonempty _ ⟨i, hi⟩),
    Finset.centroidWeights]
rw [slope, sub_self, inv_zero, zero_smul]
rw [sub_smul_slope, vsub_vadd]
simp [slope, inv_smul_smul₀ (sub_ne_zero.2 h.symm)]
rw [← sub_smul_slope_vadd f a b, h, smul_zero, zero_vadd]
simp only [slope, (· ∘ ·), f.linear.map_smul, f.linear_map_vsub]
rw [slope, slope, ← neg_vsub_eq_vsub_rev, smul_neg, ← neg_smul, neg_inv, neg_sub]
refine' ⟨_, _, _⟩
· exact fun x => ⟨φ x, hEF <| affine_subspace.mem_map.mpr ⟨x, x.property, rfl⟩⟩
· refine' φ.linear.restrict (_ : E.direction ≤ F.direction.comap φ.linear)
    rw [← Submodule.map_le_iff_le_comap, ← AffineSubspace.map_direction]
    exact AffineSubspace.direction_le hEF
· intro p v
    simp only [Subtype.ext_iff, Subtype.coe_mk, AffineSubspace.coe_vadd]
    apply AffineMap.map_vadd
rw [← Submodule.map_le_iff_le_comap, ← AffineSubspace.map_direction]
exact AffineSubspace.direction_le hEF
intro x y h
simp only [Subtype.ext_iff, Subtype.coe_mk, AffineMap.restrict.coe_apply] at h⊢
exact hφ h
intro x
rw [hfdef]
dsimp only
erw [dif_neg x.property, Subtype.coe_eta]
rw [Finset.sum_insert (Finset.not_mem_map_subtype_of_not_property s (not_not.2 rfl)),
          Finset.sum_subtype_map_embedding fun x hx => (hfg x).symm]
rw [hfdef]
dsimp only
rw [dif_pos rfl]
exact neg_add_self _
simp [hw1, hw2]
rw [Finset.sum_update_of_mem hi0, Finset.sum_const_zero, add_zero]
simp [w2, Finset.sum_add_distrib, hw, hw1]
simp [w2, ← Finset.weighted_vsub_vadd_affine_combination, hs, hw1s]
rw [← Finset.mem_coe] at hi0
rw [← Set.indicator_of_mem hi0 w2, ← Set.indicator_of_mem hi0 w1, ha, sub_self]
rw [affine_independent_iff_linear_independent_vsub k _ j] at hp⊢
simp only [AffineMap.line_map_vsub_left, AffineMap.coe_const, AffineMap.line_map_same]
exact hp.units_smul fun i => w i
intro i j hij
rw [affine_independent_iff_linear_independent_vsub _ _ j] at ha
rw [← hw, Finset.sum_map]
simp [hw']
rw [← hs, Finset.weighted_vsub_map]
congr
simp [ha]
simp [s.weighted_vsub_eq_linear_combination hw]
simp
simp [wm, hs]
simp [wm, ← Finset.mul_sum, hw]
simp [wm, his.2]
cases s1
cases s2
congr
rw [face_points', Set.range_comp, Finset.range_order_emb_of_fin]
rw [← reindex_trans, Equiv.self_trans_symm, reindex_refl]
rw [← reindex_trans, Equiv.symm_trans_self, reindex_refl]
rw [reindex, Set.range_comp, Equiv.range_eq_univ, Set.image_univ]
rw [face_centroid_eq_centroid, face_centroid_eq_centroid]
exact s.centroid_eq_iff h₁ h₂
rw [← Set.image_univ, ← Set.image_univ, ← Finset.coe_univ] at h
exact
    finset.univ.centroid_eq_of_inj_on_of_image_eq k _
      (fun _ _ _ _ he => AffineIndependent.injective s₁.independent he)
      (fun _ _ _ _ he => AffineIndependent.injective s₂.independent he) h
simp [hc', ← Finset.card_pos]
rw [Finset.card_image_of_injective _ (vsub_left_injective _), Finset.card_erase_of_mem hp₁]
exact Nat.pred_eq_of_eq_succ hc'
rw [← Finset.card_univ] at hc
rw [← Set.image_univ, ← Finset.coe_univ, ← Finset.coe_image]
exact hi.finrank_vector_span_image_finset hc
rw [Finset.Nonempty.image_iff, ← Finset.card_pos, hc]
apply Nat.succ_pos
rw [← Set.image_univ, ← Finset.coe_univ, ← Finset.coe_image]
rw [← Finset.card_univ] at hc
exact finrank_vector_span_image_finset_le _ _ _ hc
simp [← Fintype.card_pos_iff, hc]
rw [affine_independent_iff_le_finrank_vector_span k p hc, ← Nat.lt_iff_add_one_le, lt_iff_not_ge]
rw [Finset.Nonempty.image_iff, ← Finset.card_pos, hc]
apply Nat.succ_pos
rw [← Finset.card_univ] at hc
rw [← Set.image_univ, ← Finset.coe_univ, ← Finset.coe_image] at hle⊢
exact hi.affine_span_image_finset_eq_of_le_of_card_eq_finrank_add_one hle hc
constructor
· intro h_tot
    let n := Fintype.card ι - 1
    have hn : Fintype.card ι = n + 1 :=
      (Nat.succ_pred_eq_of_pos (card_pos_of_affine_span_eq_top k V P h_tot)).symm
    rw [hn, ← finrank_top, ← (vector_span_eq_top_of_affine_span_eq_top k V P) h_tot, ←
      hi.finrank_vector_span hn]
· intro hc
    rw [← finrank_top, ← direction_top k V P] at hc
    exact hi.affine_span_eq_of_le_of_card_eq_finrank_add_one le_top hc
rw [collinear_iff_dim_le_one, vector_span_empty]
simp
rw [collinear_iff_dim_le_one, vector_span_singleton]
simp
rw [collinear_iff_finrank_le_one,
    affine_independent_iff_not_finrank_vector_span_le k p (Fintype.card_fin 3)]
rw [collinear_iff_finrank_le_one,
    finrank_vector_span_le_iff_not_affine_independent k p (Fintype.card_fin 3)]
simp [affine_independent_iff_not_collinear, -Set.union_singleton]
rw [Collinear, Collinear, vector_span_insert_eq_vector_span h]
rw [collinear_insert_iff_of_mem_affine_span h]
exact collinear_pair _ _ _
rw [collinear_insert_iff_of_mem_affine_span
      ((AffineSubspace.le_def' _ _).1 (affine_span_mono k (Set.subset_insert _ _)) _ h₁),
    collinear_insert_iff_of_mem_affine_span h₂]
exact collinear_pair _ _ _
rw [collinear_insert_iff_of_mem_affine_span
      ((AffineSubspace.le_def' _ _).1
        (affine_span_mono k ((Set.subset_insert _ _).trans (Set.subset_insert _ _))) _ h₁),
    collinear_insert_iff_of_mem_affine_span
      ((AffineSubspace.le_def' _ _).1 (affine_span_mono k (Set.subset_insert _ _)) _ h₂),
    collinear_insert_iff_of_mem_affine_span h₃]
exact collinear_pair _ _ _
refine' (collinear_insert_insert_insert_of_mem_affine_span_pair h₁ h₂ h₃).Subset _
simp [Set.insert_subset_insert]
refine' (collinear_insert_insert_insert_left_of_mem_affine_span_pair h₁ h₂ h₃).Subset _
simp [Set.insert_subset_insert]
refine' IsNoetherian.iff_fg.1 (IsNoetherian.iff_dim_lt_aleph_0.2 (lt_of_le_of_lt h _))
simp
rw [Coplanar, Coplanar, vector_span_insert_eq_vector_span h]
rw [← direction_affine_span, ← affine_span_insert_affine_span, direction_affine_span]
refine' (finrank_vector_span_insert_le _ _).trans (add_le_add_right _ _)
rw [direction_affine_span]
simp only [line_map_apply_module]
exact add_le_add_right (smul_le_smul_of_nonneg ha (sub_nonneg.2 hr)) _
simp only [line_map_apply_module]
exact add_lt_add_right (smul_lt_smul_of_pos ha (sub_pos.2 hr)) _
simp only [line_map_apply_module]
exact add_le_add_left (smul_le_smul_of_nonneg hb hr) _
simp only [line_map_apply_module]
exact add_lt_add_left (smul_lt_smul_of_pos hb hr) _
simp only [line_map_apply_module]
rw [← lt_sub_iff_add_lt, add_sub_assoc, ← sub_lt_iff_lt_add', ← sub_smul, ← sub_smul,
    sub_sub_sub_cancel_left, smul_lt_smul_iff_of_pos (sub_pos.2 h)]
infer_instance
rw [line_map_apply_zero]
rw [line_map_apply_one]
simp only [line_map_apply_module]
rw [← le_sub_iff_add_le, add_sub_assoc, ← sub_le_iff_le_add', ← sub_smul, ← sub_smul,
    sub_sub_sub_cancel_left, smul_le_smul_iff_of_pos (sub_pos.2 h)]
infer_instance
rw [line_map_apply_zero]
rw [line_map_apply_one]
rw [line_map_apply, line_map_apply, slope, slope, vsub_eq_sub, vsub_eq_sub, vsub_eq_sub,
    vadd_eq_add, vadd_eq_add, smul_eq_mul, add_sub_cancel, smul_sub, smul_sub, smul_sub,
    sub_le_iff_le_add, mul_inv_rev, mul_smul, mul_smul, ← smul_sub, ← smul_sub, ← smul_add,
    smul_smul, ← mul_inv_rev, inv_smul_le_iff h, smul_smul,
    mul_inv_cancel_right₀ (right_ne_zero_of_mul h.ne'), smul_add,
    smul_inv_smul₀ (left_ne_zero_of_mul h.ne')]
infer_instance
rw [map_le_line_map_iff_slope_le_slope_left (mul_pos h₀ (sub_pos.2 hab)), ←
    line_map_slope_line_map_slope_line_map f a b r, right_le_line_map_iff_le h₁]
infer_instance
infer_instance
rw [vector_span_def, vsub_empty, Submodule.span_empty]
simp [vector_span_def]
rw [sub_eq_add_neg]
apply (vectorSpan k s).add_mem hv1
rw [← neg_one_smul k v2]
exact (vectorSpan k s).smul_mem (-1 : k) hv2
rw [← SetLike.mem_coe, coe_direction_eq_vsub_set h]
exact
    ⟨fun ⟨p1, p2, hp1, hp2, hv⟩ => ⟨p1, hp1, p2, hp2, hv.symm⟩, fun ⟨p1, hp1, p2, hp2, hv⟩ =>
      ⟨p1, p2, hp1, hp2, hv.symm⟩⟩
rw [← SetLike.mem_coe, coe_direction_eq_vsub_set_right hp]
exact ⟨fun ⟨p2, hp2, hv⟩ => ⟨p2, hp2, hv.symm⟩, fun ⟨p2, hp2, hv⟩ => ⟨p2, hp2, hv.symm⟩⟩
rw [← SetLike.mem_coe, coe_direction_eq_vsub_set_left hp]
exact ⟨fun ⟨p2, hp2, hv⟩ => ⟨p2, hp2, hv.symm⟩, fun ⟨p2, hp2, hv⟩ => ⟨p2, hp2, hv.symm⟩⟩
rw [mem_direction_iff_eq_vsub_right hp]
simp
rw [mem_direction_iff_eq_vsub_left hp]
simp
cases s1
cases s2
congr
exact h
simp
infer_instance
refine' ⟨fun h => _, fun h => _⟩
· rw [← direction_mk' p₁ direction]
    exact vsub_mem_direction h (self_mem_mk' _ _)
· rw [← vsub_vadd p₂ p₁]
    exact vadd_mem_mk' p₁ h
rw [AffineMap.line_map_apply]
exact Q.smul_vsub_vadd_mem c h₁ h₀ h₀
rw [Set.mem_Inter₂] at *
exact s2.smul_vsub_vadd_mem c (hp1 s2 hs2) (hp2 s2 hs2) (hp3 s2 hs2)
rw [lt_iff_le_not_le, not_le_iff_exists]
simp [← mem_coe]
intro contra
rw [← ext_iff, bot_coe, top_coe] at contra
exact Set.empty_ne_univ contra
rw [← direction_affine_span, h, direction_top]
rw [direction_eq_vector_span, bot_coe, vector_span_def, vsub_empty, Submodule.span_empty]
rw [nonempty_iff_ne_empty]
exact not_congr Q.coe_eq_bot_iff
rw [nonempty_iff_ne_bot]
apply eq_or_ne
simp [hp]
simp [hp]
simp [vector_span_eq_span_vsub_set_right_ne _ (finset.mem_coe.mpr hp)]
rw [vector_span_eq_span_vsub_set_left k (Set.mem_range_self i0), ← Set.range_comp]
rw [vector_span_eq_span_vsub_set_right k (Set.mem_range_self i0), ← Set.range_comp]
rw [← Set.image_univ, vector_span_image_eq_span_vsub_set_left_ne k _ (Set.mem_univ i₀)]
congr
rw [← Set.image_univ, vector_span_image_eq_span_vsub_set_right_ne k _ (Set.mem_univ i₀)]
congr
rw [← not_iff_not, ← Ne.def, ← Ne.def, ← nonempty_iff_ne_bot, affine_span_nonempty,
    nonempty_iff_ne_empty]
rw [vector_span_eq_span_vsub_set_left k (mem_insert p₁ _), image_pair, vsub_self,
    Submodule.span_insert_zero]
rw [pair_comm, vector_span_pair]
rw [vector_span_pair, Submodule.mem_span_singleton]
rw [vector_span_pair_rev, Submodule.mem_span_singleton]
rw [vadd_mem_iff_mem_direction _ (left_mem_affine_span_pair _ _ _), direction_affine_span,
    mem_vector_span_pair_rev]
rw [vadd_mem_iff_mem_direction _ (right_mem_affine_span_pair _ _ _), direction_affine_span,
    mem_vector_span_pair]
rw [affine_span_le, Set.insert_subset, Set.singleton_subset_iff]
exact ⟨hp₁, hp₂⟩
rw [Set.insert_eq, Set.insert_eq, span_union, span_union, affine_span_coe]
rw [← mem_coe] at h
rw [← affine_span_insert_affine_span, Set.insert_eq_of_mem h, affine_span_coe]
simp [f.image_vsub_image, vector_span_def]
simp [this]
simp [direction_eq_vector_span]
rw [← AffineSubspace.ext_iff]
exact image_univ_of_surjective hf
rw [← AffineSubspace.map_span, h, map_top_of_surjective f hf]
simp [← image_comp]
rw [AffineMap.map_vadd, LinearMap.map_smul, AffineMap.linear_map_vsub]
apply s.smul_vsub_vadd_mem _ hp₁ hp₂ hp₃
rw [← ext_iff]
exact preimage_univ
simp
rw [parallel_comm, parallel_bot_iff_eq_bot]
simp [affine_span_parallel_iff_vector_span_eq_and_eq_empty_iff_eq_empty, ←
    not_nonempty_iff_eq_empty]
unfold VAdd.vadd
rw [map_direction]
exact Submodule.map_id _
rw [midpoint, point_reflection_apply, line_map_apply, vadd_vsub, vadd_vadd, ← add_smul, ← two_mul,
    mul_invOf_self, one_smul, vsub_vadd]
rw [midpoint, ← line_map_apply_one_sub, one_sub_invOf_two, midpoint]
rw [midpoint_comm, AffineEquiv.point_reflection_midpoint_left]
rw [midpoint_comm, midpoint_vsub_left]
rw [midpoint_comm, left_vsub_midpoint]
rw [← vsub_sub_vsub_cancel_right p₁ p p₂, smul_sub, sub_eq_add_neg, ← smul_neg,
    neg_vsub_eq_vsub_rev, add_assoc, inv_of_two_smul_add_inv_of_two_smul, ← vadd_vsub_assoc,
    midpoint_comm, midpoint, line_map_apply]
rw [← neg_vsub_eq_vsub_rev, midpoint_vsub, neg_add, ← smul_neg, ← smul_neg, neg_vsub_eq_vsub_rev,
    neg_vsub_eq_vsub_rev]
rw [midpoint_eq_iff, point_reflection_self]
rw [eq_comm, midpoint_eq_left_iff]
rw [midpoint_comm, midpoint_eq_left_iff, eq_comm]
rw [eq_comm, midpoint_eq_right_iff]
rw [← @vsub_eq_zero_iff_eq V, midpoint_vsub_midpoint, midpoint_eq_iff, point_reflection_apply,
    vsub_eq_sub, zero_sub, vadd_eq_add, add_zero, neg_eq_iff_neg_eq, neg_vsub_eq_vsub_rev, eq_comm]
rw [midpoint_comm]
rw [midpoint_vadd_midpoint, vadd_eq_add, vadd_eq_add, add_comm, midpoint_self]
simp [sub_add_eq_sub_sub_swap]
rw [midpoint_eq_iff, point_reflection_apply, vsub_eq_sub, vadd_eq_add, sub_add_eq_add_sub, ←
    two_smul R, smul_smul, mul_invOf_self, one_smul, add_sub_cancel']
rw [midpoint_eq_smul_add, add_neg_self, smul_zero]
rw [sub_eq_add_neg, ← vadd_eq_add, ← vadd_eq_add, ← midpoint_vadd_midpoint] <;> simp
rw [midpoint_comm] <;> simp
rw [one_div, line_map_inv_two]
rw [one_div, homothety_inv_two]
rw [h0, zero_add]
rw [← hm, midpoint_zero_add]
rw [hm, midpoint_add_self]
simp only [coevaluation, id]
rw [(Basis.singleton Unit K).constr_apply_fintype K]
simp only [Fintype.univ_punit, Finset.sum_const, one_smul, Basis.singleton_repr,
    Basis.equiv_fun_apply, Basis.coe_of_vector_space, one_nsmul, Finset.card_singleton]
rw [LinearMap.std_basis_apply, Function.update_apply, Pi.zero_apply]
congr 1
rw [eq_iff_iff, eq_comm]
rw [std_basis_eq_pi_diag, proj_pi]
intro j
exact (hs j).map' _ (ker_std_basis _ _ _)
intro j
rw [span_le, LinearMap.range_coe]
apply range_comp_subset_range
rw [@supr_singleton _ _ _ fun i => LinearMap.range (std_basis R (fun j : η => Ms j) i)]
apply h₀
simp
simp only [basis_fun, Basis.coe_of_equiv_fun, LinearEquiv.refl_symm, LinearEquiv.refl_apply,
    std_basis_apply]
congr
simp [basis_fun]
dsimp [mk, mk']
congr 1
simp
dsimp [mk, Projectivization.rep]
simp
rw [submodule_eq]
exact finrank_span_singleton v.rep_nonzero
exact congr_arg coe this
  dsimp [mk'']
  simp
simp
simp [c]
rw [RingHomInvPair.comp_apply_eq₂]
cases A
cases B
simp
rw [eq_top_iff, SetLike.le_def]
intro x hx
exact subset_span _ (Set.mem_univ x)
rw [span_union, span_coe]
rw [span_union, span_coe]
rw [dependent_iff, independent_iff]
rw [dependent_iff_not_independent, not_not]
rw [independent_iff_not_dependent, dependent_pair_iff_eq u v]
simp only [ann_ideal_generator, mul_eq_zero, is_principal.eq_bot_iff_generator_eq_zero,
    Polynomial.C_eq_zero, inv_eq_zero, Polynomial.leading_coeff_eq_zero, or_self_iff]
rw [← Ideal.mem_span_singleton, span_singleton_ann_ideal_generator]
rw [Subsingleton.elim x 0]
exact zero_left _
rw [hy, smul_zero]
rw [hx, map_zero]
rw [hy, map_zero]
rw [← f.map_smul, ← f.map_smul, h]
simp only [SameRay, map_zero, ← hf.eq_iff, map_smul]
induction v using Module.Ray.ind
rw [smul_ray_of_ne_zero, ray_eq_iff]
exact same_ray_pos_smul_left _ hu
simp only [SameRay, neg_eq_zero, smul_neg, neg_inj]
rw [← same_ray_neg_iff, neg_neg]
rw [Subtype.ext_iff, coe_neg, coe_neg, neg_neg]
induction v using Module.Ray.ind
simp only [smul_ray_of_ne_zero, Units.smul_def, Units.val_neg, neg_smul, neg_ray_of_ne_zero]
rw [mul_smul, smul_inv_smul]
simp only [same_ray_smul_right_iff, hv, or_false_iff, hr.symm.le_iff_lt]
rw [← same_ray_neg_iff, neg_neg, ← neg_smul, same_ray_smul_right_iff, neg_nonneg]
simp only [same_ray_neg_smul_right_iff, hv, or_false_iff, hr.le_iff_lt]
rw [← neg_inj, neg_neg, ← Module.Ray.neg_units_smul, units_smul_eq_self_iff, Units.val_neg,
    neg_pos]
rw [← same_ray_or_same_ray_neg_iff_not_linear_independent]
rw [mul_smul, h, inv_smul_smul₀ hr₂.ne']
let P := LinearEquiv.funCongrLeft R R (Fintype.equivFin α)
let Q := LinearEquiv.funCongrLeft R R (Fintype.equivFin β)
exact
    le_of_fin_injective R ((Q.symm.to_linear_map.comp f).comp P.to_linear_map)
      (((LinearEquiv.symm Q).Injective.comp i).comp (LinearEquiv.injective P))
let P := Finsupp.linearEquivFunOnFinite R R β
let Q := (Finsupp.linearEquivFunOnFinite R R α).symm
exact
    card_le_of_injective R ((P.to_linear_map.comp f).comp Q.to_linear_map)
      ((P.injective.comp i).comp Q.injective)
let P := LinearEquiv.funCongrLeft R R (Fintype.equivFin α)
let Q := LinearEquiv.funCongrLeft R R (Fintype.equivFin β)
exact
    le_of_fin_surjective R ((Q.symm.to_linear_map.comp f).comp P.to_linear_map)
      (((LinearEquiv.symm Q).Surjective.comp i).comp (LinearEquiv.surjective P))
let P := Finsupp.linearEquivFunOnFinite R R β
let Q := (Finsupp.linearEquivFunOnFinite R R α).symm
exact
    card_le_of_surjective R ((P.to_linear_map.comp f).comp Q.to_linear_map)
      ((P.surjective.comp i).comp Q.surjective)
refine' fun a b hab => Ideal.Quotient.eq.2 fun h => _
rw [Submodule.quotient_rel_r_def] at hab
rw [← LinearMap.map_sub]
exact Ideal.map_pi _ _ hab e h
simp [eigenspace]
rw [eigenspace, LinearMap.mem_ker, LinearMap.sub_apply, algebra_map_End_apply, sub_eq_zero]
rw [div_eq_mul_inv, mul_comm]
rw [smul_smul]
rw [LinearMap.ker_smul _ b hb]
rw [smul_sub, smul_inv_smul₀ hb]
rw [eigenspace_div]
intro h
rw [leading_coeff_eq_zero_iff_deg_eq_bot.1 h] at hq
cases hq
rw [C_mul', aeval_def]
simp [algebraMap, Algebra.toRingHom]
rw [Polynomial.eq_C_of_degree_eq_zero (degree_coe_units c)]
simp only [aeval_def, eval₂_C]
apply ker_algebra_map_End
apply coeff_coe_units_zero_ne_zero c
apply p.induction_on
· intro a
    simp [Module.algebra_map_End_apply]
· intro p q hp hq
    simp [hp, hq, add_smul]
· intro n a hna
    rw [mul_comm, pow_succ, mul_assoc, AlgHom.map_mul, LinearMap.mul_apply, mul_comm, hna]
    simp only [mem_eigenspace_iff.1 h.1, smul_smul, aeval_X, eval_mul, eval_C, eval_pow, eval_X,
      LinearMap.map_smulₛₗ, RingHom.id_apply, mul_comm]
intro con
apply minpoly.ne_zero f.is_integral
rw [hp, Con, mul_zero]
rw [hl, g.map_zero]
simp only [l', LinearMap.id_coe, id.def, LinearMap.smul_apply, Dfinsupp.map_range_apply,
              Dfinsupp.mapRange.linear_map_apply]
rw [l'_eq_0]
rfl
          
      -- Thus, the eigenspace-representatives in `l` for all `μ ≠ μ₀` are `0`.
assumption
simp only [S, Dfinsupp.lsum_apply_apply, Dfinsupp.sum_add_hom_apply,
          LinearMap.to_add_monoid_hom_coe, Dfinsupp.sum, h_l_support, Submodule.subtype_apply,
          Submodule.coe_eq_zero, Finset.sum_insert hμ₀, h_sum_l_support'_eq_0, add_zero] at hl
exact hl
      -- Thus, all coefficients in `l` are `0`.
simp only [← pow_sub_mul_pow _ hm]
exact
      LinearMap.ker_le_ker_comp ((f - algebraMap R (End R M) μ) ^ k)
        ((f - algebraMap R (End R M) μ) ^ (m - k))
simp [Module.EndCat.generalizedEigenspace]
simp only [maximal_generalized_eigenspace, ← mem_generalized_eigenspace,
    Submodule.mem_supr_of_chain]
rw [is_noetherian_iff_well_founded] at h
exact (WellFounded.supr_eq_monotonic_sequence_limit h (f.generalized_eigenspace μ) : _)
apply has_generalized_eigenvalue_of_has_generalized_eigenvalue_of_le hk
rw [has_generalized_eigenvalue, generalized_eigenspace, OrderHom.coe_fun_mk, pow_one]
exact hμ
intro contra
apply hμ
erw [LinearMap.ker_eq_bot] at contra⊢
rw [LinearMap.coe_pow]
exact Function.Injective.iterate contra k
rw [← pow_add]
rfl
rw [finrank_bot]
rw [Algebra.mul_sub_algebra_map_pow_commutes]
rw [h_dim]
apply Nat.zero_lt_succ
dsimp only [ES]
rw [h_dim]
apply pos_finrank_generalized_eigenspace_of_has_eigenvalue hμ₀ (Nat.zero_lt_succ n)
    -- and the dimensions of `ES` and `ER` add up to `finrank K V`.
apply LinearMap.finrank_range_add_finrank_ker
    -- Therefore the dimension `ER` mus be smaller than `finrank K V`.
simp only [(Submodule.map_supr _ _).symm, ih_ER, Submodule.map_subtype_top ER]
    -- Moreover, every generalized eigenspace of `f'` is contained in the corresponding generalized
    -- eigenspace of `f`.
intros
rw [generalized_eigenspace_restrict]
apply Submodule.map_comap_le
    -- It follows that `ER` is contained in the span of all generalized eigenvectors.
rw [← ih_ER']
exact supr₂_mono hff'
    -- `ES` is contained in this span
apply uncurry_apply
apply uncurry_apply
dsimp only [dualTensorHom]
rw [uncurry_apply]
rfl
rw [← dual_tensor_hom_equiv_of_basis_apply b, LinearEquiv.symm_apply_apply]
rw [← dual_tensor_hom_equiv_of_basis_apply b, LinearEquiv.apply_symm_apply]
rw [← LinearEquiv.coe_to_linear_map, ltensor_hom_equiv_hom_ltensor_to_linear_map]
rw [← LinearEquiv.coe_to_linear_map, rtensor_hom_equiv_hom_rtensor_to_linear_map]
rw [← LinearEquiv.coe_to_linear_map, hom_tensor_hom_equiv_to_linear_map]
rw [J, from_blocks_transpose, ← neg_one_smul R (from_blocks _ _ _ _), from_blocks_smul,
    Matrix.transpose_zero, Matrix.transpose_one, transpose_neg]
simp [from_blocks]
rw [J, from_blocks_multiply]
simp only [Matrix.zero_mul, Matrix.neg_mul, zero_add, neg_zero, Matrix.one_mul, add_zero]
rw [← neg_zero, ← Matrix.from_blocks_neg, ← from_blocks_one]
refine' Matrix.inv_eq_right_inv _
rw [Matrix.mul_neg, J_squared]
exact neg_neg 1
rw [← det_mul, J_squared]
rw [← one_smul R (-1 : Matrix _ _ R)]
rw [smul_neg, ← neg_smul, det_smul]
simp only [Fintype.card_sum, det_one, mul_one]
apply Even.neg_one_pow
exact even_add_self _
intro a b ha hb
simp only [mul_eq_mul, Set.mem_setOf_eq, transpose_mul] at *
rw [← Matrix.mul_assoc, a.mul_assoc, a.mul_assoc, hb]
exact ha
simp
simp [symplectic_group]
infer_instance
rw [mem_iff, J, from_blocks_multiply, from_blocks_transpose, from_blocks_multiply]
simp
rw [mem_iff] at h⊢
simp [h]
rw [Matrix.det_transpose]
exact huA
rw [J_inv]
simp
rw [hA]
simp only [Matrix.mul_inv_rev, Matrix.mul_assoc, Matrix.neg_mul]
rw [mul_nonsing_inv_cancel_left _ _ huAT, nonsing_inv_mul_cancel_right _ _ huA]
simp [J_inv]
rw [← transpose_mem_iff, mem_iff, transpose_transpose]
simp only [Matrix.mul_assoc, Matrix.neg_mul]
rw [mem_iff'] at hA
rw [hA]
simp only [Matrix.neg_mul, neg_smul, one_smul]
rw [J_squared]
simp only [neg_smul_neg, one_smul]
refine' (coe_inv A).trans (inv_eq_left_inv _).symm
simp [inv_left_mul_aux, coe_inv]
simp only [Matrix.neg_mul, inv_left_mul_aux hA]
apply Subtype.ext
simp only [Submonoid.coe_one, Submonoid.coe_mul, Matrix.neg_mul, coe_inv]
rw [Matrix.mul_eq_mul, Matrix.neg_mul]
exact inv_left_mul_aux A.2
rw [← mem_degree_lt] at degree_f_lt degree_g_lt
refine' eq_of_degree_sub_lt_of_eval_finset_eq _ _ eval_fg
rw [← mem_degree_lt]
exact Submodule.sub_mem _ degree_f_lt degree_g_lt
refine' eq_of_degree_sub_lt_of_eval_index_eq _ hvs _ eval_fg
rw [← mem_degree_lt] at degree_f_lt degree_g_lt⊢
exact Submodule.sub_mem _ degree_f_lt degree_g_lt
simp only [basis_divisor, sub_self, inv_zero, map_zero, zero_mul]
rw [Ne.def, basis_divisor_eq_zero_iff]
rw [basis_divisor, degree_mul, degree_X_sub_C, degree_C, zero_add]
exact inv_ne_zero (sub_ne_zero_of_ne hxy)
rw [basis_divisor_self, degree_zero]
rw [basis_divisor_self, nat_degree_zero]
simp only [basis_divisor, eval_mul, eval_C, eval_sub, eval_X, sub_self, mul_zero]
simp only [basis_divisor, eval_mul, eval_C, eval_sub, eval_X]
exact inv_mul_cancel (sub_ne_zero_of_ne hxy)
rw [Lagrange.basis, erase_singleton, prod_empty]
simp only [Lagrange.basis, hij, erase_insert_eq_erase, erase_eq_of_not_mem, mem_singleton,
    not_false_iff, prod_singleton]
rw [pair_comm]
exact basis_pair_left hij.symm
rw [degree_eq_nat_degree (basis_ne_zero hvs hi), nat_degree_basis hvs hi]
rw [interpolate_apply, sum_empty]
rw [interpolate_apply, sum_singleton, basis_singleton, mul_one]
refine' (degree_sum_le _ _).trans _
rw [Finset.sup_le_iff]
intro i hi
rw [degree_mul, degree_basis hvs hi]
rw [← Finset.card_erase_of_mem hi]
exact degree_interpolate_lt _ (Set.InjOn.mono (coe_subset.mpr (erase_subset _ _)) hvs)
rw [← eval_interpolate_at_node r hvs hi, hrr', eval_interpolate_at_node r' hvs hi]
rw [hrr' _ hi]
rw [eq_interpolate hvs degree_f_lt]
exact interpolate_eq_of_values_eq_on _ _ eval_f
constructor <;> intro h
· exact eq_interpolate_of_eval_eq _ hvs h.1 h.2
· rw [h]
    exact ⟨degree_interpolate_lt _ hvs, fun _ hi => eval_interpolate_at_node _ hvs hi⟩
simp
rw [add_assoc, tsub_add_tsub_cancel hst' hs, ← add_tsub_assoc_of_le (hs.trans hst'),
        Nat.succ_add_sub_one, zero_add]
rw [← eval_finset_sum, sum_basis (hvt.mono hst) hs, eval_one]
rw [interpolate_eq_sum_interpolate_insert_sdiff _ hvs ⟨i, mem_insert_self i {j}⟩ _,
    sum_insert (not_mem_singleton.mpr hij), sum_singleton, basis_pair_left hij,
    basis_pair_right hij, sdiff_insert_insert_of_mem_of_not_mem hi (not_mem_singleton.mpr hij),
    sdiff_singleton_eq_erase, pair_comm,
    sdiff_insert_insert_of_mem_of_not_mem hj (not_mem_singleton.mpr hij.symm),
    sdiff_singleton_eq_erase]
· exact insert_subset.mpr ⟨hi, singleton_subset_iff.mpr hj⟩
rw [eval_nodal, prod_eq_zero_iff]
exact ⟨i, hi, sub_eq_zero_of_eq rfl⟩
rw [nodal_eq_mul_nodal_erase hi, EuclideanDomain.mul_div_cancel_left]
exact X_sub_C_ne_zero _
refine' Finset.induction_on s _ fun _ _ hit IH => _
· rw [nodal_empty, derivative_one, sum_empty]
· rw [nodal_insert_eq_nodal hit, derivative_mul, IH, derivative_sub, derivative_X, derivative_C,
      sub_zero, one_mul, sum_insert hit, mul_sum, erase_insert hit, add_right_inj]
    refine' sum_congr rfl fun j hjt => _
    rw [nodal_erase_eq_nodal_div (mem_insert_of_mem hjt), nodal_insert_eq_nodal hit,
      EuclideanDomain.mul_div_assoc _ (X_sub_C_dvd_nodal v hjt), nodal_erase_eq_nodal_div hjt]
rw [eval_nodal, nodal_weight, prod_inv_distrib]
rw [eval_nodal_derivative_eval_node_eq hi, nodal_weight_eq_eval_nodal_erase_inv]
rw [mul_comm, basis_eq_prod_sub_inv_mul_nodal_div hj]
rw [← div_one (eval x (interpolate s v r)), ← @eval_one _ _ x, ← interpolate_one hvs hs,
    eval_interpolate_not_at_node r hx, eval_interpolate_not_at_node 1 hx]
simp only [mul_div_mul_left _ _ (eval_nodal_not_at_node hx), Pi.one_apply, mul_one]
rw [Finsupp.sum_smul_index', Finsupp.smul_sum]
· simp only [map_smul]
· intro i
    exact (h i).map_zero
refine' { toFun := fun c => ⟨f c, h c⟩.. } <;> intros <;> apply SetCoe.ext <;> simp
rw [Subsingleton.elim x 0, map_zero, map_zero]
rw [f.map_add, add_smul]
dsimp <;> rw [map_smul, smul_assoc]
rw [← tsub_add_cancel_of_le hk, pow_add, mul_apply, hm, map_zero]
rw [← commute_pow_left_of_commute h, hG, zero_comp, zero_apply]
rw [pow_succ', mul_eq_comp]
rw [iterate_succ]
exact surjective.comp (iterate_surjective n) h
rw [iterate_succ]
exact injective.comp (iterate_injective n) h
rw [iterate_succ]
exact bijective.comp (iterate_bijective n) h
rw [← Nat.succ_pred_eq_of_pos (pos_iff_ne_zero.mpr hn), iterate_succ, coe_comp] at h
exact injective.of_comp h
simp
simp [LinearMap.ext_iff]
simp [LinearMap.ext_iff]
simp
simp only [← image_comp, map_coe, LinearMap.coe_comp, comp_app]
simp [this, eq_comm]
intros
simp only [coe_add, map_add, Equiv.to_fun_as_coe, Equiv.Set.image_apply]
rfl
intros
simp only [coe_smul_of_tower, map_smulₛₗ, Equiv.to_fun_as_coe, Equiv.Set.image_apply]
rfl
simp [p.smul_mem _ h]
simp
simp [mem_comap, mem_map, hf.eq_iff]
exact fun v hv => this ⟨v, hv, rfl⟩
  exact le_infi fun i => (Submodule.map_mono (infi_le p i)).trans (this i)
rw [map_le_iff_le_comap, comap_smul f _ a h, ← map_le_iff_le_comap]
exact le_rfl
rw [map_le_iff_le_comap, ← comap_smul f _ a h, ← map_le_iff_le_comap]
exact le_rfl
simp [Subtype.ext_iff_val]
rw [SetLike.ext'_iff, range_coe, top_coe, Set.range_iff_surjective]
rw [range_eq_map, map_le_iff_le_comap, eq_top_iff]
simp [this]
rw [ker_comp] <;> exact comap_mono bot_le
simp [disjoint_def]
rw [← id_apply m, ← h, comp_apply, hm, g.map_zero]
rw [ker, eq_bot_iff, map_le_iff_le_comap]
rw [ker, comap_cod_restrict, map_bot] <;> rfl
rw [restrict_eq_cod_restrict_dom_restrict, ker_cod_restrict]
simp
rw [range_le_iff_comap] <;> exact ker_eq_top
rw [← range_le_bot_iff, le_bot_iff]
rw [← hy, ← comp_apply, h, zero_apply]
rw [disjoint_ker, ← map_zero f]
exact fun x hx H => hf H
rw [mem_ker, map_sub, sub_eq_zero]
simp [h]
apply h₂
simp [hx, hz]
apply IsLinearMap.mk
· intro x y
    simp [add_comm, add_left_comm, sub_eq_add_neg]
· intro x y
    simp [smul_sub]
simp
rw [map_subtype_top]
rw [of_le, ker_cod_restrict, ker_subtype]
rw [← map_top, of_le, LinearMap.map_cod_restrict, map_top, range_subtype]
simp [range_of_le, map_comap_eq, h]
rw [← (map_injective_of_injective (show injective p.subtype from Subtype.coe_injective)).eq_iff,
    map_comap_subtype, map_bot, disjoint_iff]
simp [map_comap_subtype p, inf_of_le_right hq]
dsimp
rw [map_le_iff_le_comap,
          comap_map_eq_of_injective (show injective p.subtype from Subtype.coe_injective) p₂]
rw [range_comp, hf, Submodule.map_top]
rw [ker_comp, hg, Submodule.comap_bot]
rw [submodule_image, range_comp, Submodule.range_of_le]
simp [f.range_cod_restrict _]
simp [e.image_eq_preimage]
simp only [LinearMap.dom_restrict_apply, eq_self_iff_true, and_true_iff, SetLike.coe_mem,
          SetLike.mem_coe]
simp only [LinearMap.dom_restrict_apply, LinearMap.cod_restrict_apply,
        LinearMap.to_fun_eq_coe, LinearEquiv.coe_coe, LinearEquiv.symm_apply_apply, SetLike.eta]
apply SetCoe.ext
simp only [LinearMap.dom_restrict_apply, LinearMap.cod_restrict_apply,
        LinearMap.to_fun_eq_coe, LinearEquiv.coe_coe, SetLike.coe_mk,
        LinearEquiv.apply_symm_apply]
refine' bot_unique (SetLike.le_def.2 fun b hb => (Submodule.mem_bot R).2 _)
rw [← p.mk_eq_zero hb, ← e.map_eq_zero_iff]
apply Submodule.eq_zero_of_bot_submodule
rw [← hx', h x']
simp
cases x
rfl
simp only [coe_mk, SetLike.eta, coe_coe]
simp only [Subtype.coe_mk, SetLike.eta, coe_coe]
simp
rw [mem_map_equiv, mem_comap, LinearEquiv.coe_coe]
rw [SetLike.le_def]
intro m h
change c
rw [SetLike.le_def]
intro m h
change f₁ m + f₂ m ∈ q
change f₁ m ∈ q ∧ f₂ m ∈ q at h
apply q.add_mem h.1 h.2
apply le_trans _ (inf_comap_le_comap_add qₗ f₁ f₂)
rw [le_inf_iff]
exact ⟨h₁, h₂⟩
exact this.injective
  intro x
  rw [← LinearMap.comp_apply, ← fun_left_comp, hg.id, fun_left_id]
rw [id_apply, ← fun_left_comp, Equiv.symm_comp_self, fun_left_id]
rw [id_apply, ← fun_left_comp, Equiv.self_comp_symm, fun_left_id]
infer_instance
erw [f.inv_val] <;> simp
erw [f.val_inv] <;> simp
rw [← @zero_smul R _ _ _ _ (0 : M), smul_left, zero_mul]
rw [← @zero_smul _ _ _ _ _ (0 : M), smul_right, zero_mul]
rw [← @neg_one_smul R₁ _ _, smul_left, neg_one_mul]
rw [← @neg_one_smul R₁ _ _, smul_right, neg_one_mul]
rw [sub_eq_add_neg, sub_eq_add_neg, add_left, neg_left]
rw [sub_eq_add_neg, sub_eq_add_neg, add_right, neg_right]
cases B
cases D
congr
rw [add_left, add_left, add_add_add_comm]
rw [smul_left, smul_left, mul_add]
rw [add_right, add_right, add_add_add_comm]
rw [smul_right, smul_right, mul_add]
rw [add_left, smul_add]
rw [smul_left, ← mul_smul_comm]
rw [add_right, smul_add]
rw [smul_right, ← mul_smul_comm]
rw [add_left, neg_add]
rw [smul_left, mul_neg]
rw [add_right, neg_add]
rw [smul_right, mul_neg]
rw [add_left, add_left, add_sub_add_comm]
rw [smul_left, smul_left, mul_sub]
rw [add_right, add_right, add_sub_add_comm]
rw [smul_right, smul_right, mul_sub]
simp only [to_lin_hom_aux₁, LinearMap.coe_mk, LinearMap.add_apply, add_left]
dsimp [to_lin_hom_aux₁]
intros
simp only [← algebra_map_smul R c x, Algebra.smul_def, LinearMap.coe_mk, LinearMap.smul_apply,
        smul_left]
dsimp only [to_lin_hom_aux₁, to_lin_hom_aux₂]
apply LinearMap.ext
intro y
simp only [to_lin_hom_aux₂, to_lin_hom_aux₁, LinearMap.coe_mk, LinearMap.add_apply, add_apply]
dsimp [to_lin_hom_aux₁, to_lin_hom_aux₂]
apply LinearMap.ext
intro x
apply LinearMap.ext
intro y
simp only [to_lin_hom_aux₂, to_lin_hom_aux₁, LinearMap.coe_mk, LinearMap.smul_apply, smul_apply]
rw [LinearMap.map_smul, LinearMap.smul_apply, smul_eq_mul]
rw [BilinForm.add_left, map_add]
rw [← smul_one_smul R r (_ : M), BilinForm.smul_left, smul_one_mul r (_ : R), map_smul,
      smul_eq_mul]
rw [BilinForm.add_right, map_add]
rw [← smul_one_smul R r (_ : M), BilinForm.smul_right, smul_one_mul r (_ : R), map_smul,
      smul_eq_mul]
rw [LinearMap.map_add, add_left]
rw [LinearMap.map_smul, smul_left]
rw [LinearMap.map_add, add_right]
rw [LinearMap.map_smul, smul_right]
simp only [comp_apply, LinearEquiv.coe_coe, e.symm_apply_apply]
simp only [comp_apply, LinearEquiv.coe_coe, e.apply_symm_apply]
simp only [comp_apply, add_apply]
simp [comp_apply, smul_apply]
rw [LinearMap.map_add, add_mul]
rw [LinearMap.map_smul, smul_eq_mul, mul_assoc]
rw [LinearMap.map_add, mul_add]
rw [LinearMap.map_smul, smul_eq_mul, mul_left_comm]
dsimp only [is_ortho]
constructor <;> intro H
· rw [smul_left, mul_eq_zero] at H
    cases H
    · trivial
    · exact H
· rw [smul_left, H, mul_zero]
dsimp only [is_ortho]
constructor <;> intro H
· rw [smul_right, mul_eq_zero] at H
    cases H
    · trivial
    · exact H
· rw [smul_right, H, mul_zero]
rw [hs, zero_left]
apply Finset.sum_eq_single_of_mem i hi
intro j hj hij
rw [is_Ortho_def.1 hv₁ _ _ hij, mul_zero]
have H1 : B₁ (x + y) (x + y) = 0 := self_eq_zero H (x + y)
rw [add_left, add_right, add_right, self_eq_zero H, self_eq_zero H, Ring.zero_add, Ring.add_zero,
    add_eq_zero_iff_neg_eq] at H1
exact H1
intro x y h
rw [← neg H, h, neg_zero]
simp only [BilinForm.zero_left, BilinForm.zero_right, LinearMap.zero_apply]
rw [LinearMap.add_apply, LinearMap.add_apply, add_left, add_right, h, h']
rw [LinearMap.sub_apply, LinearMap.sub_apply, sub_left, sub_right, h, h']
rw [LinearMap.smul_apply, LinearMap.smul_apply, smul_left, smul_right, h]
rw [LinearMap.comp_apply, LinearMap.comp_apply, h', h]
rw [LinearMap.mul_apply, LinearMap.mul_apply, h, h']
rfl
simp only [LinearMap.neg_apply, BilinForm.neg_apply, BilinForm.neg_right]
rw [is_skew_adjoint_iff_neg_self_adjoint]
exact Iff.rfl
rw [is_ortho, add_right, show B n x = 0 from hx n hn, show B n y = 0 from hy n hn, zero_add]
rw [is_ortho, smul_right, show B n x = 0 from hx n hn, mul_zero]
rw [orthogonal_span_singleton_eq_to_lin_ker]
exact LinearMap.span_singleton_sup_ker_eq_top _ hx
rw [dual_basis, Basis.map_repr, LinearEquiv.symm_symm, LinearEquiv.trans_apply,
    Basis.dual_basis_repr, to_dual_def]
rw [dual_basis, Basis.map_apply, Basis.coe_dual_basis, ← to_dual_def hB,
    LinearEquiv.apply_symm_apply, Basis.coord_apply, Basis.repr_self, Finsupp.single_apply]
rw [Sym, apply_dual_basis_left]
rw [b₂] <;> exact m.2 y hy
rw [comp_left_apply, comp_left_apply, hψ₁, hψ₂]
erw [symm_comp_of_nondegenerate, LinearEquiv.apply_symm_apply (B₂.to_dual b₂) _]
dsimp
apply Dfinsupp.induction f
· rw [smul_zero, AddMonoidHom.map_zero, smul_zero]
· intro a b f ha hb hf
          rw [smul_add, AddMonoidHom.map_add, AddMonoidHom.map_add, smul_add, hf, ← single_smul,
            sum_add_hom_single, sum_add_hom_single, LinearMap.to_add_monoid_hom_coe,
            LinearMap.map_smul]
simp
simp
rw [ker_mkq]
exact smul_mono (Ideal.pow_le_pow h) le_rfl
rw [Pi.zero_apply, Pi.zero_apply, LinearMap.map_zero]
rw [Pi.add_apply, Pi.add_apply, LinearMap.map_add, hf hmn, hg hmn]
rw [Pi.smul_apply, Pi.smul_apply, LinearMap.map_smul, hf hmn]
rw [Ideal.top_pow, top_smul]
exact Smodeq.top
rw [map_smul'']
exact smul_mono le_rfl le_top
rw [lift_of, ← hg, LinearMap.comp_apply]
refine' ⟨fun f hf => ⟨f 1, fun n => _⟩⟩
cases n
· rw [pow_zero, Ideal.one_eq_top, top_smul]
    exact Smodeq.top
specialize hf (Nat.le_add_left 1 n)
rw [pow_one, bot_smul, Smodeq.bot] at hf
rw [hf]
rw [Ideal.top_pow, top_smul]
exact Smodeq.top
rw [Subsingleton.elim (f n) 0]
rw [LinearMap.map_add, ih1, ih2, LinearMap.map_zero, add_zero]
intro m n h
simp only [f, Algebra.id.smul_eq_mul, Ideal.mul_top, Smodeq.sub_mem]
rw [← add_tsub_cancel_of_le h, Finset.sum_range_add, ← sub_sub, sub_self, zero_sub, neg_mem_iff]
apply Submodule.sum_mem
intro n hn
rw [mul_pow, pow_add, mul_assoc]
exact Ideal.mul_mem_right _ (I ^ m) (Ideal.pow_mem_pow hx m)
infer_instance
dsimp [lift_alternating]
rw [foldl_ι, LinearMap.mk₂_apply, AlternatingMap.curry_left_apply_apply]
congr
dsimp [lift_alternating]
rw [foldl_mul, foldl_ι]
rfl
dsimp [lift_alternating]
rw [foldl_one]
rw [Algebra.algebra_map_eq_smul_one, map_smul, lift_alternating_one]
rw [lift_alternating_ι_multi, LinearMap.comp_id]
rw [← AlgHom.map_mul, ι_sq_zero, AlgHom.map_zero]
simp
simp
simp [algebra_map_inv]
simp [ι_inv]
rw [← ι_inj R x 0, LinearMap.map_zero]
rw [← (algebraMap R (ExteriorAlgebra R M)).map_one, Ne.def, ι_eq_algebra_map_iff]
exact one_ne_zero ∘ And.right
simp [mul_add, add_mul]
simp [to_exterior]
rw [graded_algebra.ι_apply, DirectSum.of_mul_of]
refine' dfinsupp.single_eq_zero.mpr (Subtype.ext <| ι_sq_zero _)
apply graded_algebra.ι R M
apply graded_algebra.lift_ι R M
apply graded_algebra.lift_ι_eq R M
rw [left_rel_apply, sub_eq_add_neg, neg_add, neg_neg]
rfl
rw [mul_comm, ← Fintype.card_prod]
exact Fintype.card_congr AddSubgroup.addGroupEquivQuotientTimesAddSubgroup
simp
simp
rw [span_singleton_le_iff_mem, LinearMap.mem_ker, h]
rw [eq_bot_iff, map_le_iff_le_comap, comap_bot, ker_mkq] <;> exact le_rfl
simp [comap_map_eq, sup_comm]
simp only [map_eq_top_iff p.range_mkq, sup_comm, ker_mkq]
simp
rw [comap_id]
exact le_refl _
rw [map_le_iff_le_comap, ← comap_comp, liftq_mkq] <;> exact le_rfl
rw [ker_liftq, le_antisymm h h', mkq_map_self]
simp
exact le_antisymm (span_preimage_le f s) this
simp
simp
simp
rw [← range_le_ker_iff, Submodule.ker_mkq, Submodule.range_subtype]
subst h
rfl
rw [hn] <;> exact n.succ_pos
simp only [FiniteDimensional, ← IsNoetherian.iff_fg, IsNoetherian.iff_dim_lt_aleph_0, hVW,
    Cardinal.nsmul_lt_aleph_0_iff_of_ne_zero hn]
have A : Cardinal.mk ι = ↑(FiniteDimensional.finrank K K) :=
    (FiniteDimensional.finrank_eq_card_basis' b).symm
simp only [Cardinal.eq_one_iff_unique, FiniteDimensional.finrank_self, algebraMap.coe_one] at A
exact Nonempty.some ((unique_iff_subsingleton_and_nonempty _).2 A)
rw [hv, LinearEquiv.map_zero, Finsupp.zero_apply]
rw [← Fintype.card_coe]
exact fintype_card_le_finrank_of_linear_independent h
apply Cardinal.lift_lt.1
apply lt_of_le_of_lt
apply cardinal_lift_le_dim_of_linear_independent h
rw [← finrank_eq_dim, Cardinal.lift_aleph_0, Cardinal.lift_nat_cast]
apply Cardinal.nat_lt_aleph_0
simp
rw [Set.card_image_of_injective _ Subtype.coe_injective, ← finrank_eq_card_basis bS, ←
            finrank_eq_card_basis b, h] <;>
          infer_instance
infer_instance
rw [FiniteDimensional, ← iff_fg, IsNoetherian.iff_dim_lt_aleph_0] at h⊢
rw [← Cardinal.lift_lt.{v', v}]
rw [← Cardinal.lift_lt.{v, v'}] at h
rw [Cardinal.lift_aleph_0] at h⊢
exact (lift_dim_map_le f p).trans_lt h
rw [finrank_eq_dim]
simp
rw [Cardinal.lt_aleph_0_iff_fintype] at this
exact this.some
simp only [t', card_map, Finset.card_erase_of_mem m]
exact nat.lt_pred_iff.mpr h
  -- to obtain a function `g`.
simp [add_div]
simp [mul_div]
cases Unique.uniq ‹Unique ι› i
simp [basis_singleton]
rw [Set.range_unique, basis_singleton_apply]
rw [FiniteDimensional, ← IsNoetherian.iff_fg, IsNoetherian.iff_dim_lt_aleph_0, h]
exact nat_lt_aleph_0 n
simp
rw [h, dim_bot]
rw [← dim_eq_zero, ← finrank_eq_dim, ← @Nat.cast_zero Cardinal, Cardinal.nat_cast_inj]
unfold FiniteDimensional at *
rw [finite_def] at *
exact (fg_top _).2 (((fg_top S₁).1 h₁).sup ((fg_top S₂).1 h₂))
infer_instance
cases nonempty_fintype ι
rw [← Finset.sup_univ_eq_supr]
exact Submodule.finite_dimensional_finset_sup _ _
rw [← s.finrank_quotient_add_finrank, add_comm]
exact Nat.lt_add_of_zero_lt_left _ _ (finrank_pos_iff.mpr (quotient.nontrivial_of_lt_top _ h))
rw [← dim_sup_add_dim_inf_eq]
exact self_le_add_right _ _
rw [disjoint_iff_inf_le, le_bot_iff] at hdisjoint
rw [hdisjoint, finrank_bot]
simp only [← finrank_eq_dim, cond, lift_nat_cast]
rw [← LinearEquiv.finrank_eq (Submodule.comapSubtypeEquivOfLe hle)] at hd
exact
    le_antisymm hle
      (Submodule.comap_subtype_eq_top.1
        (eq_top_of_finrank_eq (le_antisymm (comap (Submodule.subtype S₂) S₁).finrank_le hd)))
rw [← @add_right_cancel_iff _ _ _ (finrank K p), Submodule.finrank_quotient_add_finrank,
        LinearEquiv.finrank_eq f₁, Submodule.finrank_quotient_add_finrank,
        LinearEquiv.finrank_eq f₂]
rw [Submodule.finrank_quotient_add_finrank, ← LinearEquiv.finrank_eq f, add_comm,
        Submodule.finrank_quotient_add_finrank]
have h := dim_eq_of_injective _ hinj
rw [← finrank_eq_dim, ← finrank_eq_dim, nat_cast_inj] at h
exact range_eq_top.1 (eq_top_of_finrank_eq h.symm)
rw [range_eq_top, ker_eq_bot, injective_iff_surjective]
rw [hfg] <;> rfl
rw [← f.quot_ker_equiv_range.finrank_eq]
exact Submodule.finrank_quotient_add_finrank _
rw [is_unit_iff_ker_eq_bot, ker_eq_bot_iff_range_eq_top]
have := finrank_range_add_finrank_ker f
rw [← ker_eq_bot, ← range_eq_top]
refine' ⟨fun h => _, fun h => _⟩
· rw [h, finrank_bot, add_zero, H] at this
    exact eq_top_of_finrank_eq this
· rw [h, finrank_top, H] at this
    exact finrank_eq_zero.1 (add_right_injective _ this)
rw [range_eq_top, ker_eq_bot, injective_iff_surjective_of_finrank_eq_finrank H]
rw [ker_eq_bot.2 hf, finrank_bot, add_zero]
rw [dif_neg hx]
exact
          Classical.choose_spec
            ((show Function.Surjective (LinearMap.mulLeft F x) from
                LinearMap.injective_iff_surjective.1 fun _ _ => (mul_right_inj' hx).1)
              1)
simp [h, finrank_top]
rw [← dim_sup_add_dim_inf_eq, h.codisjoint.eq_top, h.disjoint.eq_bot, finrank_bot, add_zero]
exact finrank_top
rw [finrank_eq_one_iff_of_nonzero v nz]
apply span_singleton_eq_top_iff
rw [← W.rank_le_one_iff_is_principal, ← finrank_eq_dim, ← Cardinal.nat_cast_le, Nat.cast_one]
rw [← Module.rank_le_one_iff_top_is_principal, ← finrank_eq_dim, ← Cardinal.nat_cast_le,
    Nat.cast_one]
simp
rw [← dim_top, ← subalgebra_top_dim_eq_submodule_top_dim, Subalgebra.dim_eq_one_iff, eq_comm]
rw [← finrank_top, ← subalgebra_top_finrank_eq_submodule_top_finrank,
    Subalgebra.finrank_eq_one_iff, eq_comm]
cases hr.symm.trans (Subalgebra.bot_eq_top_iff_finrank_eq_one.1 h)
refine' lt_of_le_of_ne _ (h_contra n (Nat.le_of_succ_le_succ hn))
rw [pow_succ]
apply LinearMap.ker_le_ker_comp
apply Submodule.finrank_lt_finrank_of_lt h_ker_lt_ker
simp
apply le_antisymm
· rw [add_comm, pow_add]
      apply LinearMap.ker_le_ker_comp
· rw [ker_pow_constant m, add_comm m 1, ← add_assoc, pow_add, pow_add f k m]
      change LinearMap.ker ((f ^ (k + 1)).comp (f ^ m)) ≤ LinearMap.ker ((f ^ k).comp (f ^ m))
      rw [LinearMap.ker_comp, LinearMap.ker_comp, h, Nat.add_one]
      exact le_rfl
rw [add_tsub_cancel_of_le (h_k_le.trans hm)]
rw [ker_pow_constant hk _]
rw [add_tsub_cancel_of_le h_k_le]
rw [← Cardinal.lift_inj.1 hs.mk_eq_dim, Cardinal.power_def]
rw [Smodeq.def, Submodule.Quotient.eq]
rw [Smodeq.def, Submodule.Quotient.eq, mem_bot, sub_eq_zero]
rw [Smodeq.def, Submodule.Quotient.eq, sub_zero]
rw [Smodeq.def] at h⊢
show Ideal.Quotient.mk I (f.eval x) = Ideal.Quotient.mk I (f.eval y)
change Ideal.Quotient.mk I x = Ideal.Quotient.mk I y at h
rw [← Polynomial.eval₂_at_apply, ← Polynomial.eval₂_at_apply, h]
rw [finrank_eq_card_basis h, Fintype.card_coe]
rw [hn] <;> exact n.succ_pos
simp
simp
unfold finrank
rw [← Cardinal.to_nat_lift, f.lift_dim_eq, Cardinal.to_nat_lift]
rw [(LinearEquiv.ofInjective f hf).finrank_eq]
unfold finrank
simp [dim_top]
rw [h]
rw [← @finrank_top K V] at lt
exact lt_of_le_of_finrank_lt_finrank le_top lt
simp
rw [Set.to_finset_range]
exact Finset.card_image_le
rw [Set.to_finset_card, Fintype.card_of_finset]
simp [and_comm']
rw [smul_add, ← mul_smul, inv_mul_cancel gx_ne_zero, one_smul]
rw [linear_independent_iff_card_eq_finrank_span, finrank_range_le_card.le_iff_eq]
rw [← Algebra.top_to_submodule]
rfl
rw [← Algebra.top_to_submodule]
rfl
rw [subalgebra_top_dim_eq_submodule_top_dim]
exact dim_top F E
simp
apply (LinearEquiv.map_eq_zero_iff (algEquivMatrix (choose_basis R M)).toLinearEquiv).1
rw [AlgEquiv.to_linear_equiv_apply, ← AlgEquiv.coe_alg_hom, ←
    Polynomial.aeval_alg_hom_apply _ _ _, charpoly_def]
exact aeval_self_charpoly _
rw [← aeval_eq_aeval_mod_charpoly, map_pow, aeval_X]
rw [hP, mul_comm]
refine' degree_lt_degree_mul_X fun h => _
rw [h, mul_zero] at hP
exact minpoly.ne_zero (IsIntegral f) hP
rw [RingHom.map_matrix_apply, RingHom.map_matrix_apply, ← Matrix.map_mul,
      @reindex_linear_equiv_mul _ ι' _ _ _ _ R R, Basis.to_matrix_mul_to_matrix_flip,
      reindex_linear_equiv_one, ← RingHom.map_matrix_apply, RingHom.map_one]
rw [basis_to_matrix_mul_linear_map_to_matrix_mul_basis_to_matrix]
rw [reindex_linear_equiv_mul, reindex_linear_equiv_mul]
simp
rw [Matrix.mul_assoc ((scalar ι') X), hPQ, Matrix.mul_one]
simp
rw [← Matrix.sub_mul, ← Matrix.mul_sub]
rw [det_mul, det_mul]
rw [← det_mul, hPQ, det_one, one_mul]
rw [det_adjugate, A.prop, one_pow]
erw [det_mul, A.2, B.2, one_mul]
simp [h]
rw [← to_lin'_mul, ← coe_mul, mul_right_inv, coe_one, to_lin'_one]
rw [← to_lin'_mul, ← coe_mul, mul_left_inv, coe_one, to_lin'_one]
rw [← f.map_det]
simp [g.2]
intro c₁ c₂ h
rw [← sub_eq_zero, ← sub_smul] at h⊢
exact H _ h
rw [← add_smul]
apply H
simp only [add_smul, sub_smul, Classical.choose_spec (mem_span_singleton.1 _)]
apply coe_add
rw [smul_smul]
apply H
simp only [mul_smul, Classical.choose_spec (mem_span_singleton.1 _)]
apply coe_smul
dsimp [mk_span_singleton']
rw [← sub_eq_zero, ← sub_smul]
apply H
simp only [sub_smul, one_smul, sub_eq_zero]
apply Classical.choose_spec (mem_span_singleton.1 h)
rw [hc, zero_smul]
erw [f.map_add ⟨x, hfx⟩ ⟨y, hfy⟩, g.map_add ⟨x, hgx⟩ ⟨y, hgy⟩, hx, hy]
erw [f.map_smul c ⟨x, hfx⟩, g.map_smul c ⟨x, hgx⟩, hx]
apply fg_eq
exact h
have hx : x = 0 := Subtype.eq ((mem_bot R).1 x.2)
have hy : y = 0 := Subtype.eq (h.symm.trans (congr_arg _ hx))
rw [hx, hy, map_zero, map_zero]
intro x' y' z' H
dsimp [fg]
rw [add_comm, ← sub_eq_sub_iff_add_eq_add, eq_comm, ← map_sub, ← map_sub]
apply h
simp only [← eq_sub_iff_add_eq] at hxy
simp only [AddSubgroupClass.coe_sub, coe_mk, coe_mk, hxy, ← sub_add, ← sub_sub, sub_self,
      zero_sub, ← H]
apply neg_add_eq_sub
rw [disjoint_def] at h
have hy : y = 0 := Subtype.eq (h y (hxy ▸ x.2) y.2)
have hx : x = 0 := Subtype.eq (hxy.trans <| congr_arg _ hy)
simp [*]
simp
simp
simp
simp [graph]
simp
cases x
cases y
exact f.mem_graph_snd_inj hx hy hxy
rw [mem_domain_iff]
exact ⟨y, h⟩
simp
have hadd := (g.map (LinearMap.fst R E F)).add_mem v.2 w.2
have hvw := val_from_graph_mem hg hadd
have hvw' := g.add_mem (val_from_graph_mem hg v.2) (val_from_graph_mem hg w.2)
rw [Prod.mk_add_mk] at hvw'
exact (exists_unique_from_graph hg hadd).unique hvw hvw'
have hsmul := (g.map (LinearMap.fst R E F)).smul_mem a v.2
have hav := val_from_graph_mem hg hsmul
have hav' := g.smul_mem a (val_from_graph_mem hg v.2)
rw [Prod.smul_mk] at hav'
exact (exists_unique_from_graph hg hsmul).unique hav hav'
simp only [mem_map, LinearMap.fst_apply, Prod.exists, exists_and_right, exists_eq_right]
exact ⟨x_snd, hx⟩
rw [f.map_span, span_le, Set.image_subset_iff]
exact Iff.rfl
simp only [SetLike.mem_coe, Submodule.zero_mem]
rw [span_le, comap_coe]
exact preimage_mono subset_span
refine' Exists.elim _ fun (hx : x ∈ span R s) (hc : p x hx) => hc
refine'
    span_induction hx (fun m hm => ⟨subset_span hm, Hs m hm⟩) ⟨zero_mem _, H0⟩
      (fun x y hx hy =>
        (Exists.elim hx) fun hx' hx =>
          (Exists.elim hy) fun hy' hy => ⟨add_mem hx' hy', H1 _ _ _ _ hx hy⟩)
      fun r x hx => (Exists.elim hx) fun hx' hx => ⟨smul_mem _ _ hx', H2 r _ _ hx⟩
refine' span_induction' (fun x hx => _) _ (fun x y _ _ => _) (fun r x _ => _) hx
· exact subset_span hx
· exact zero_mem _
· exact add_mem
· exact smul_mem _ _
refine' Eq.symm (AddSubmonoid.closure_eq_of_le subset_span _)
apply add_submonoid.to_nat_submodule.symm.to_galois_connection.l_le _
rw [span_le]
exact AddSubmonoid.subset_closure
rw [span_nat_eq_add_submonoid_closure, s.closure_eq]
rw [span_int_eq_add_subgroup_closure, s.closure_eq]
rw [Submodule.span_union, p.span_eq]
rw [Submodule.span_union, p.span_eq]
simp only [← span_Union, Set.bUnion_of_singleton s]
rw [span_eq_supr_of_singleton_spans, supr_range]
rw [← SetLike.mem_coe, coe_supr_of_directed S H, mem_Union]
rfl
simp
simp
simp
simp
simp
simp
simp [smul_add]
simp only [SetLike.exists, coe_mk]
simp
simp
simp [add_smul]
simp [smul_smul]
simp
rw [span_le, Set.singleton_subset_iff, SetLike.mem_coe]
exact smul_of_tower_mem _ _ (mem_span_singleton_self _)
rw [← SetLike.mem_coe, ← singleton_subset_iff] at *
exact Submodule.subset_span_trans hxy hyz
simp only [← union_singleton, span_union, mem_sup, mem_span_singleton, exists_prop,
    exists_exists_eq_and]
rw [exists_comm]
simp only [eq_comm, add_comm, exists_and_left]
rw [insert_eq, span_union]
simp
rw [← singleton_zero, span_singleton_eq_bot]
rw [hy, smul_zero]
rw [← hz, smul_zero]
rw [hx, smul_zero]
rw [hxy]
apply mem_span_singleton_self
rw [← hxy]
apply mem_span_singleton_self
rw [← one_smul R y, ← hi, smul_smul] at hv
exact smul_left_injective R hy hv
rw [← one_smul R x, ← hv, smul_smul] at hi
exact smul_left_injective R hx hi
rw [Submodule.span_image]
exact Submodule.mem_map_of_mem h
simp [← span_image]
rw [← mem_to_add_submonoid, supr_to_add_submonoid] at hx
exact AddSubmonoid.supr_induction _ hx hp h0 hadd
rw [span_le, singleton_subset_iff, SetLike.mem_coe]
rw [span_eq_supr_of_singleton_spans]
simp only [Finset.mem_coe]
rw [← Finset.sup_eq_supr]
exact CompleteLattice.finsetSupCompactOfCompact S fun x _ => singleton_span_is_compact_element x
rw [Sup_eq_supr, supr_image, ← span_eq_supr_of_singleton_spans, span_eq]
constructor
· intro h
simp only [sup_le_iff]
constructor
· exact le_refl I
· exact (span_singleton_le_iff_mem a I).mpr akey
rw [← span_singleton_le_iff_mem, le_supr_iff]
simp only [span_singleton_le_iff_mem]
simp
simp
simp [hz, add_assoc]
simp [add_comm, add_left_comm]
simp
rw [Submodule.comap_map_eq, sup_of_le_left h]
rw [map_le_iff_le_comap, Submodule.comap_map_eq]
rw [LinearMap.map_le_map_iff, hf, sup_bot_eq]
refine' Iff.trans _ linear_map.mem_range.symm
exact mem_span_singleton
apply span_induction h H <;> simp (config := { contextual := true })
rw [LinearMap.mem_ker, f.map_sub, f.map_smul, smul_eq_mul, mul_assoc, inv_mul_cancel hx,
            mul_one, sub_self]
simp only [add_sub_cancel'_right]
rw [← mul_smul, inv_mul_cancel hc', one_smul]
rw [hc, smul_zero]
apply set_like.coe_eq_coe.mp
have : ↑(to_span_nonzero_singleton K V x h 1) = to_span_singleton K V x 1 := rfl
rw [this, to_span_singleton_one, Submodule.coe_mk]
rw [← to_span_nonzero_singleton_one K V x h, LinearEquiv.symm_apply_apply]
cases nonempty_fintype ι
exact
    (dom_dom_congr_eq_iff (Fintype.equivFin ι) f g).mp
      ((Basis.ext_multilinear_fin fun i => e) fun i => h (i ∘ _))
intro f g h
cases f
cases g
cases h
rfl
simp
simp [add_left_comm, add_assoc]
simp [smul_add]
simp
simp
simp [smul_add]
simp [← smul_comm x c]
simp
simp
simp
simp
rw [Subsingleton.elim i i']
simp only [Function.eval, Function.update_same]
rw [Subsingleton.elim i i']
simp only [Function.eval, Function.update_same]
erw [dite_comp_equiv_update, dite_comp_equiv_update, dite_comp_equiv_update]
simp
erw [dite_comp_equiv_update, dite_comp_equiv_update]
simp
rw [← update_cons_zero x m (x + y), f.map_add, update_cons_zero, update_cons_zero]
rw [← update_snoc_last x m (x + y), f.map_add, update_snoc_last, update_snoc_last]
have : ∀ j z, f j (update m i z j) = update (fun k => f k (m k)) i (f i z) j := fun j z =>
      Function.apply_update (fun k => f k) _ _ _ _
simp [this]
have : ∀ j z, f j (update m i z j) = update (fun k => f k (m k)) i (f i z) j := fun j z =>
      Function.apply_update (fun k => f k) _ _ _ _
simp [this]
simp
rw [hi, Finset.sum_empty]
simp [Finset.card_eq_zero, Ai_empty i]
intro j hj
congr
apply Finset.card_le_one_iff.1 (Ai_singleton i) hj
exact mem_pi_finset.mp hr i
intro i
intro i
simp [hj₂]
simp [C, hi₀]
simp [B, C]
apply Finset.Subset.antisymm
· intro r hr
simp [C, hri₀]
simp [B, hri₀, mem_pi_finset.1 hr i₀]
simp
simp
simp
rw [← σ.apply_symm_apply i]
intro x y
simp only [comp_app, Pi_congr_left'_symm_update, f.map_add]
rw [← σ.apply_symm_apply i]
intro x
simp only [comp_app, Pi_congr_left'_symm_update, f.map_smul]
rw [← σ.symm_apply_apply i]
intro x y
simp only [comp_app, Pi_congr_left'_update, f.map_add]
rw [← σ.symm_apply_apply i]
intro x
simp only [comp_app, Pi_congr_left'_update, f.map_smul]
simp [Finset.prod_update_of_mem, add_mul]
simp [Finset.prod_update_of_mem]
simp
rw [← mk_pi_ring_zero, mk_pi_ring_eq_iff]
simp [add_comm]
simp
simp only [MultilinearMap.map_smul, smul_sub]
simp [smul_add]
simp [← smul_comm x n]
simp [smul_add]
simp [← smul_comm x n]
rw [← MultilinearMap.map_add, add_left_neg, f.map_coord_zero i (update_same i 0 m)]
rw [sub_eq_add_neg, sub_eq_add_neg, MultilinearMap.map_add, map_neg]
simp
simp
simp
rw [f.snoc_add]
simp only [f.snoc_smul, RingHom.id_apply]
simp only [← Sum.update_elim_inr, f.map_add]
simp only [← Sum.update_elim_inr, f.map_smul]
simp only [MultilinearMap.coe_mk, add_apply, ← Sum.update_elim_inl, f.map_add]
simp only [MultilinearMap.coe_mk, smul_apply, ← Sum.update_elim_inl, f.map_smul]
cases i <;>
      simp only [MultilinearMap.map_add, add_apply, Sum.update_inl_comp_inl,
        Sum.update_inl_comp_inr, Sum.update_inr_comp_inl, Sum.update_inr_comp_inr]
cases i <;>
      simp only [MultilinearMap.map_smul, smul_apply, Sum.update_inl_comp_inl,
        Sum.update_inl_comp_inr, Sum.update_inr_comp_inl, Sum.update_inr_comp_inr]
simp
refine' (curry_fin_finset_symm_apply_piecewise_const hk hl _ _ _).symm.trans _
  -- `rw` fails
rw [LinearEquiv.symm_apply_apply]
cases nonempty_fintype ι
cases this _ (M₁ ∘ (Fintype.equivFin ι).symm)
have e := dom_dom_congr_linear_equiv' R M₁ M₂ (Fintype.equivFin ι)
exact ⟨Module.Free.ofEquiv e.symm, Module.Finite.equiv e.symm⟩
cases this
exact
        ⟨Module.Free.ofEquiv (multilinearCurryLeftEquiv R N M₂),
          Module.Finite.equiv (multilinearCurryLeftEquiv R N M₂)⟩
cases i <;> simp [TensorProduct.add_tmul, TensorProduct.tmul_add]
cases i <;> simp [TensorProduct.smul_tmul', TensorProduct.tmul_smul]
simp only [Pi.prod, Prod.mk_add_mk, map_add]
simp only [Pi.prod, Prod.smul_mk, map_smul, RingHom.id_apply]
simp
simp
simp only [LinearMap.coprod_apply, Submodule.coe_sup, Submodule.map_coe]
rw [← Set.image2_add, Set.image2_image_left, Set.image2_image_right]
exact Set.image_prod fun m m₂ => f m + g m₂
simp only [Prod.mk.eta, coprod_inl, coprod_inr]
simp only [← comp_coprod, comp_id, coprod_inl_inr]
dsimp only [ker]
rw [← prod_map_comap_prod, Submodule.prod_bot]
simp
simp
simp [mem_sup]
simp (config := { contextual := true }) [disjoint_def, @eq_comm M 0, @eq_comm M₂ 0] <;> intros <;>
    rfl
simp [hx]
simp [hx]
rw [← map_coprod_prod, coprod_inl_inr, map_id]
rw [span_union, prod_eq_sup_map, ← span_image, ← span_image]
rw [ker, ← prod_bot, comap_prod_prod] <;> rfl
simp [Submodule.mem_sup, SetLike.exists]
rw [ker, ← prod_bot, prod_comap_inl]
rw [ker, ← prod_bot, prod_comap_inr]
rw [range_eq_map, ← prod_top, prod_map_fst]
rw [range_eq_map, ← prod_top, prod_map_snd]
simp
simp
simp
simp
simp
simp
simp
simp only [eq_bot_iff, prod_le_iff, (gc_map_comap _).le_iff_le, comap_bot, ker_inl, ker_inr]
simp only [eq_top_iff, le_prod_iff, ← (gc_map_comap _).le_iff_le, map_top, range_fst, range_snd]
simp
simp
simp only [h, mem_top]
dsimp [tunnel', tunnel_aux]
rw [Submodule.map_comp, Submodule.map_comp]
apply Submodule.map_subtype_le
dsimp [tailing, tunnel_aux]
rw [Submodule.map_comp, Submodule.map_comp]
apply Submodule.map_subtype_le
rw [disjoint_iff]
dsimp [tailing, tunnel, tunnel']
rw [Submodule.map_inf_eq_map_inf_comap,
    Submodule.comap_map_eq_of_injective (tunnel_aux_injective _ i _), inf_comm,
    Submodule.fst_inf_snd, Submodule.map_bot]
dsimp [tailing, tunnel, tunnel', tunnel_aux]
rw [← Submodule.map_sup, sup_comm, Submodule.fst_sup_snd, Submodule.map_comp, Submodule.map_comp]
apply Submodule.map_subtype_le
simp [tailings]
simp [tailings]
change _ + _ = f (_ + _)
rw [map_add, ha, hb]
change _
simp [LinearIndependent, LinearMap.ker_eq_bot']
rw [Finsupp.lapply_apply, Finsupp.single_eq_same]
rw [Finsupp.lapply_apply, Finsupp.single_eq_of_ne hji]
rw [linear_independent_iff']
simp only [exists_prop, not_forall]
simp [Fintype.linear_independent_iff, LinearMap.ker_eq_bot', funext_iff] <;> skip
rw [linear_independent_iff.1 h (Finsupp.mapDomain f l) hl] <;> simp
simp [hf_inj]
simp only [hf_inj, disjoint_bot_right]
intro s li
apply Cardinal.card_le_of
intro t
rw [← Finset.card_map (embedding.subtype s)]
apply H
apply linear_independent_finset_map_embedding_subtype _ li
simp [linear_independent_comp_subtype]
apply @linear_independent_comp_subtype _ _ _ id
rw [linear_independent_comp_subtype, LinearMap.disjoint_ker]
apply @linear_independent_comp_subtype_disjoint _ _ _ id
rw [Finsupp.totalOn, LinearMap.ker, LinearMap.comap_cod_restrict, map_bot, comap_bot,
    LinearMap.ker_comp, linear_independent_subtype_disjoint, disjoint_iff_inf_le, ←
    map_comap_subtype, map_le_iff_le_comap, comap_bot, ker_subtype, le_bot_iff]
simp [linear_independent_subtype_disjoint]
simp only [linear_independent_subtype_disjoint]
exact Disjoint.mono_left (Finsupp.supported_mono h)
rw [linear_independent_iff] at hv
simp [eq_add_of_sub_eq' (hv l h_total)]
rw [linear_independent_iff] at li
simp [eq_add_of_sub_eq' (li l h_total)]
rw [Set.image_singleton]
exact mem_span_singleton_self (v x)
simp
apply
          disjoint_def.1 (hd x₁ {y₁} (finite_singleton y₁) fun h => h_cases (eq_of_mem_singleton h))
            (f x₁ x₂) (subset_span (mem_range_self _))
rw [supr_singleton]
simp only at hxy
rw [hxy]
exact subset_span (mem_range_self y₂)
apply LinearEquiv.ofBijective (LinearMap.codRestrict (span R (range v)) (Finsupp.total ι M R v) _)
constructor
· rw [← LinearMap.ker_eq_bot, LinearMap.ker_cod_restrict]
    apply hv
· rw [← LinearMap.range_eq_top, LinearMap.range_eq_map, LinearMap.map_cod_restrict, ←
      LinearMap.range_le_iff_comap, range_subtype, map_top]
    rw [Finsupp.range_total]
    exact le_rfl
· intro l
    rw [← Finsupp.range_total]
    rw [LinearMap.mem_range]
    apply mem_range_self l
rw [LinearIndependent.repr, LinearEquiv.ker]
rw [LinearIndependent.repr, LinearEquiv.range]
rw [Eq] at this
exact Subtype.ext_iff.2 this
apply hv.repr_eq
simp [Finsupp.total_single, hx]
simp [e]
simp [hn]
simp [this]
let indep : Set ι → Prop := fun I => LinearIndependent R (s ∘ coe : I → M)
let X := { I : Set ι // indep I }
let r : X → X → Prop := fun I J => I.1
simp
simp [hJ]
simp
dsimp only [l]
rw [Finsupp.total_map_domain]
rw [(hv.comp f f.injective).total_repr]
· rfl
rw [h_total_l, Finsupp.total_single, one_smul]
rw [← @Subtype.range_coe _ s] at hf_inj
refine' (hs.map hf_inj).to_subtype_range' _
simp [Set.range_comp f]
refine' is_compl_range_inl_inr.disjoint.mono _ _ <;>
      simp only [span_le, range_coe, range_comp_subset_range]
rw [add_sub_add_left_eq_sub]
rw [Finset.sum_insert has, Finset.sum_insert has]
rw [i.map_mul, mul_assoc]
rw [mul_assoc, mul_left_comm]
rw [Finset.sum_apply, Finset.sum_apply, Finset.mul_sum] <;> rfl
rw [hg] <;> rfl
rw [mul_zero, sub_zero]
rw [mul_sub, sub_eq_zero] <;> exact h
rw [← a.map_one] <;> rfl
rw [hg] <;> rfl
have :=
    eq_of_linear_independent_of_span_subtype (hl.mono (Set.union_subset hsu htu))
      (Set.subset_union_right _ _) (Set.union_subset (Set.Subset.trans subset_span hst) subset_span)
rw [← this]
apply Set.subset_union_left
simp only [linear_independent_iff, Finsupp.total_unique, smul_eq_zero]
refine' ⟨fun h hv => _, fun hv l hl => Finsupp.unique_ext <| hl.resolve_right hv⟩
have := h (Finsupp.single default 1) (Or.inr hv)
exact one_ne_zero (Finsupp.single_eq_zero.1 this)
simp [h_in_span]
simp only [← linear_independent_option', Option.cases_on'_none_coe]
rw [← linear_independent_equiv ((Equiv.optionEquivSumPUnit _).trans (Equiv.Set.insert has).symm),
    linear_independent_option]
simp [(· ∘ ·), range_comp f]
simp
rw [Fin.snoc_eq_cons_rotate, linear_independent_equiv, linear_independent_fin_cons]
rw [← linear_independent_fin_cons, Fin.cons_self_tail]
rw [← linear_independent_fin_snoc, Fin.snoc_init_self]
rw [← Fin.succ_zero_eq_one] <;> rfl
simp [this]
simp [inter_subset_inter, subset.refl]
simp [insert_subset_insert hust]
simp
simp [Eq, hb₁t, hb₁s', hb₁u]
simp [insert_eq, -singleton_union, -union_singleton, union_subset_union, subset.refl,
              subset_union_right]
simp [insert_subset, hb₂s, hs']
simp [subset_insert]
simp [Eq, hb₂t', hb₁t, hb₁s']
simp [Set.subset_def]
simp (config := { contextual := true }) [Set.ext_iff]
simp (config := { contextual := true }) [subset_def, and_imp, or_imp]
simp only [h.2.2, Eq]
simp <;> assumption
simp [hsu]
refine' supr_le fun a₁ => supr_le fun h₁ => range_le_iff_comap.2 _
simp only [(ker_comp _ _).symm, eq_top_iff, SetLike.le_def, mem_ker, comap_infi, mem_infi]
intro b hb a₂ h₂
have : a₁ ≠ a₂ := fun eq => h.le_bot ⟨h₁, Eq.symm ▸ h₂⟩
exact single_eq_of_ne this
simp only [SetLike.le_def, mem_infi, mem_ker, mem_bot, lapply_apply]
exact fun a h => Finsupp.ext h
refine' eq_top_iff.2 <| SetLike.le_def.2 fun f _ => _
rw [← sum_single f]
exact sum_mem fun a ha => Submodule.mem_supr_of_mem a ⟨_, rfl⟩
rw [← span_image] <;> rfl
rw [Finsupp.mem_supported]
erw [Set.union_eq_Union, supported_Union, supr_bool_eq] <;> rfl
simp [mem_supported, subset_Inter_iff]
rw [Set.inter_eq_Inter, supported_Inter, infi_bool_eq] <;> rfl
rw [← supported_inter, disjoint_iff_inter_eq_empty.1 h, supported_empty]
simp [sum_smul_index', smul_sum]
rw [← Set.image_subset_iff, ← Finset.coe_image] at hl
exact Set.Subset.trans map_domain_support hl
rw [h₂]
rfl
rw [not_mem_support_iff.1 hxg, zero_smul]
simp [total_apply, sum_single_index]
simp [Finsupp.total_apply]
apply Finsupp.induction_linear l <;> simp (config := { contextual := true })
rw [← total_single, ← unique_single l]
simp [hy]
simp [total_apply, Finsupp.sum, support_emb_domain, emb_domain_apply]
rw [equiv_map_domain_eq_map_domain, total_map_domain]
rw [range_total, Subtype.range_coe_subtype, Set.setOf_mem_eq]
simp only [← Finsupp.range_total, LinearMap.mem_range, Finsupp.total_apply]
simp [hi.2]
rw [span_image_eq_map_total]
simp
rw [total_apply, sum_option_index_smul, total_apply]
simp only [total_apply]
apply induction_linear f
· simp only [sum_zero_index]
· intro f₁ f₂ h₁ h₂
    simp [sum_add_index, h₁, h₂, add_smul]
· simp [sum_single_index, sum_smul_index, smul_sum, mul_smul]
rw [Finsupp.totalOn, LinearMap.range_eq_map, LinearMap.map_cod_restrict, ←
    LinearMap.range_le_iff_comap, range_subtype, map_top, LinearMap.range_comp, range_subtype]
exact (span_image_eq_map_total _ _).le
rw [Finsupp.total_apply] <;> rfl
simp [Finsupp.domLcongr, Finsupp.domCongr, equiv_map_domain_single]
simp [lcongr]
rw [finsupp_prod_lequiv, LinearEquiv.coe_mk, finsupp_prod_equiv, Finsupp.curry_apply]
apply Finset.sum_subset
· exact Finset.subset_univ _
· intro x _ hx
    rw [finsupp.not_mem_support_iff.mp hx]
    exact zero_smul _ _
rw [← Finsupp.total_eq_fintype_total, LinearMap.range_comp, LinearEquiv.to_linear_map_eq_coe,
    LinearEquiv.range, Submodule.map_top, Finsupp.range_total]
simp only [Finsupp.mem_span_range_iff_exists_finsupp,
    finsupp.equiv_fun_on_finite.surjective.exists, Finsupp.equiv_fun_on_finite_apply]
exact exists_congr fun c => Eq.congr_left <| (Finsupp.sum_fintype _ _) fun i => zero_smul _ _
simp only [Finsupp.total_apply, Finsupp.total_apply, Finsupp.sum, f.map_sum, f.map_smul]
have :=
    CompleteLattice.IsCompactElement.exists_finset_of_le_supr (Submodule R M)
      (Submodule.singletonSpanIsCompactElement m) p
simp only [Submodule.span_singleton_le_iff_mem] at this
exact this hm
simp only [eq_iff_true_of_subsingleton]
simp [finsuppTensorFinsupp]
apply Finsupp.induction_linear f
· simp
· intro f₁ f₂ hf₁ hf₂
    simp [add_tmul, hf₁, hf₂]
· intro i' m
    apply Finsupp.induction_linear g
    · simp
    · intro g₁ g₂ hg₁ hg₂
      simp [tmul_add, hg₁, hg₂]
    · intro k' n
      simp only [finsupp_tensor_finsupp_single]
      simp only [Finsupp.single_apply]
      -- split_ifs; finish can close the goal from here
simp [finsuppTensorFinsupp']
simp [DirectSum]
intro m
rw [← f.map_app]
congr
exact f.to_linear_equiv.apply_symm_apply m
intro m
rw [← f.map_app, ← g.map_app]
rfl
intro
simp only [comp_apply, LinearEquiv.coe_coe, LinearEquiv.to_fun_eq_coe,
        LinearEquiv.apply_symm_apply, f.apply_symm_apply]
intro i
refine' (ne_of_lt (Real.rpow_pos_of_pos (sign_mul_pos_of_ne_zero _ <| Units.ne_zero _) _)).symm
rw [Finset.sum_apply, sum_eq_single j, Pi.basis_fun_apply, IsUnit.unit_spec,
      LinearMap.std_basis_apply, Pi.smul_apply, Pi.smul_apply, Function.update_same, smul_eq_mul,
      smul_eq_mul, smul_eq_mul, mul_one]
intro i _ hij
rw [Pi.basis_fun_apply, LinearMap.std_basis_apply, Pi.smul_apply, Pi.smul_apply,
      Function.update_noteq hij.symm, Pi.zero_apply, smul_eq_mul, smul_eq_mul, mul_zero, mul_zero]
intro hj'
exact False.elim (hj' hj)
simp only [u, dif_neg h, Units.val_mk0]
intro i hi
exact (w i).NeZero ((Complex.cpow_eq_zero_iff _ _).1 hi).1
rw [Finset.sum_apply, sum_eq_single j, Pi.basis_fun_apply, IsUnit.unit_spec,
      LinearMap.std_basis_apply, Pi.smul_apply, Pi.smul_apply, Function.update_same, smul_eq_mul,
      smul_eq_mul, smul_eq_mul, mul_one]
intro i _ hij
rw [Pi.basis_fun_apply, LinearMap.std_basis_apply, Pi.smul_apply, Pi.smul_apply,
      Function.update_noteq hij.symm, Pi.zero_apply, smul_eq_mul, smul_eq_mul, mul_zero, mul_zero]
intro hj'
exact False.elim (hj' hj)
simp only [w, dif_neg h, Units.val_mk0]
simp [← two_mul]
simp only [polar, Pi.neg_apply, sub_eq_add_neg, neg_add]
simp only [polar, Pi.smul_apply, smul_sub]
rw [polar, polar, add_comm, sub_sub, sub_sub, add_comm (f x) (f y)]
simp only [← add_assoc]
simp only [polar, sub_eq_iff_eq_add, eq_sub_iff_add_eq, sub_add_eq_add_sub, add_sub]
simp only [add_right_comm _ (f y) _, add_right_comm _ (f x') (f x)]
rw [add_comm y x, add_right_comm _ _ (f (x + y)), add_comm _ (f (x + y)),
    add_right_comm (f (x + y)), add_left_inj]
simp only [polar, Pi.smul_apply, Function.comp_apply, map_sub]
cases x <;> cases y <;> congr
rw [← @zero_smul R _ _ _ _ (0 : M), map_smul, zero_mul, zero_mul]
rw [← IsScalarTower.algebra_map_smul R a x, map_smul, ← RingHom.map_mul, Algebra.smul_def]
rw [← @neg_one_smul R _ _ _ _ x, map_smul, neg_one_mul, neg_neg, one_mul]
rw [← neg_sub, map_neg]
simp only [polar, zero_add, QuadraticForm.map_zero, sub_zero, sub_self]
rw [← neg_one_smul R x, polar_smul_left, neg_one_mul]
rw [sub_eq_add_neg, sub_eq_add_neg, polar_add_left, polar_neg_left]
simp only [add_zero, polar, QuadraticForm.map_zero, sub_self]
rw [polar_comm Q x, polar_comm Q x, polar_comm Q x, polar_add_left]
rw [polar_comm Q x, polar_comm Q x, polar_smul_left]
rw [← neg_one_smul R y, polar_smul_right, neg_one_mul]
rw [sub_eq_add_neg, sub_eq_add_neg, polar_add_right, polar_neg_right]
rw [← IsScalarTower.algebra_map_smul R a x, polar_smul_left, Algebra.smul_def]
rw [← IsScalarTower.algebra_map_smul R a y, polar_smul_right, Algebra.smul_def]
rw [BilinForm.coe_fn_mk, polar, sub_sub, add_sub_cancel'_right]
rw [polar_bilin_apply, polar, Q.exists_companion.some_spec, sub_sub, add_sub_cancel']
rw [Pi.smul_apply, map_smul, Pi.smul_apply, mul_smul_comm]
simp [h]
simp only [mul_zero]
simp only [add_zero, BilinForm.zero_apply]
simp only [Pi.add_apply, map_smul, mul_add]
simp only [smul_apply, mul_smul]
simp only [QuadraticForm.smul_apply, one_smul]
simp only [Pi.neg_apply, map_smul, mul_neg]
simp only [map_smul, f.map_smul]
rw [Q.map_smul_of_tower b x, f.map_smul, smul_eq_mul]
simp only [mul_assoc, smul_right, smul_left]
simp [add_add_add_comm, add_comm]
simp only [add_assoc, add_sub_cancel', add_right, polar, add_left_inj, add_neg_cancel_left,
    add_left, sub_eq_add_neg _ (B y y), add_comm (B y x) _]
simp only [associated_apply, add_comm, add_left_comm, sub_eq_add_neg]
simp only [associated_apply, ← polar_to_quadratic_form, polar, to_quadratic_form_apply]
rw [associated_to_quadratic_form, is_symm.eq h x y, ← two_mul, ← mul_assoc, invOf_mul_self,
      one_mul]
simp only [add_assoc, add_sub_cancel', one_mul, to_quadratic_form_apply, add_mul,
          associated_apply, map_add_self, bit0]
rw [← two_mul (Q x), ← mul_assoc, invOf_mul_self, one_mul]
rw [← not_forall]
intro h
apply hB₁
rw [(QuadraticForm.ext h : Q = 0), LinearMap.map_zero]
simp only [anisotropic, not_forall, exists_prop, and_comm']
intro x hx
refine' hB _ _
rw [← hx x]
exact (associated_eq_self_apply _ _ x).symm
have := hQ _ hx
rw [hQx] at this
exact this
simp only [to_matrix', LinearEquiv.map_smul, LinearMap.map_smul]
simp only [discr, to_matrix'_smul, Matrix.det_smul]
simp only [Matrix.det_transpose, mul_left_comm, QuadraticForm.to_matrix'_comp, mul_comm,
    Matrix.det_mul, discr]
rw [← v.equiv_fun_symm_apply]
rfl
simp only [pi_apply, LinearEquiv.Pi_congr_right_apply, LinearEquiv.to_fun_eq_coe,
      isometry.coe_to_linear_equiv, isometry.map_app]
rw [← det_mul, ← mul_eq_mul, A.mul_inv, det_one]
rw [← det_mul, ← mul_eq_mul, A.inv_mul, det_one]
rw [mem_GL_pos, general_linear_group.coe_det_apply, Units.val_neg, det_neg,
        (Fact.out <| Even <| Fintype.card n).neg_one_pow, one_mul]
exact g.prop
cases nonempty_fintype ι₁
cases nonempty_fintype ι₂
exact Module.Finite.of_basis (Pi.basis fun i => Pi.basisFun R _)
rw [finrank, cast_to_nat_of_lt_aleph_0 (rank_lt_aleph_0 R M)]
rw [finrank, rank_finsupp, ← mk_to_nat_eq_card, to_nat_lift]
simp [finrank]
simp [finrank, rank_lt_aleph_0 R M, rank_lt_aleph_0 R N]
simp [finrank]
simp [finrank]
rw [span_le, singleton_subset_iff, SetLike.mem_coe, LinearMap.mem_submodule_image_of_le hNO]
refine' ⟨y, yN, _⟩
change r₁ * ϕ ⟨y, hNO yN⟩ + r₂ * ψ ⟨y, hNO yN⟩ = d
rw [d_eq, ϕy_eq]
simp only [LinearMap.map_sum, LinearMap.map_smul]
rfl
simp only [a_smul_y']
intro c z zN' hc
refine' (mul_eq_zero.mp (y'_ortho_M' (a * c) z (N'_le_M' zN') _)).resolve_left a_zero
rw [mul_comm, mul_smul, hc]
  -- So we can extend a basis for `N'` with `y`
intro i
rw [Fintype.prod_eq_prod_compl_mul i, mul_smul]
simp only [snf, Basis.map_apply, LinearEquiv.of_top_apply, Submodule.coe_smul_of_tower,
      Submodule.comap_subtype_equiv_of_le_apply_coe, coe_coe, Basis.reindex_apply,
      Equiv.toEmbedding_apply, Function.Embedding.trans_apply, Equiv.symm_apply_apply]
rw [Eq, Fintype.card_fin]
simp only [snf, Basis.coe_reindex, Function.Embedding.trans_apply, Equiv.toEmbedding_apply]
simp only [snf, fe, Basis.map_apply, LinearEquiv.restrict_scalars_apply,
          Submodule.restrict_scalars_equiv_apply, Basis.coe_reindex]
intro hi
apply Basis.ne_zero (Ideal.selfBasis b I hI) i
refine' Subtype.coe_injective _
simp [hi]
intro i
rw [f_apply, b'.equiv_apply, Equiv.refl_apply, ab_eq]
intro c i
simp only [← MulAction.mul_smul, b'.repr_sum_self, mul_comm]
simp
simp
cases nonempty_fintype ι
rw [← (DirectSum.linearEquivFunOnFintype _ _ M).dim_eq, rank_direct_sum]
rw [rank_matrix, lift_mul, lift_umax]
simp
simp
rw [AddCon.coe_add]
exact Cp C1 ih
rw [smul.aux_of, smul.aux_of, ← smul_comm, smul_tmul]
rw [TensorProduct.smul_zero]
rw [this, zero_smul, zero_tmul]
rw [TensorProduct.smul_add, ihx, ihy, add_zero]
rw [TensorProduct.smul_zero]
rw [this, one_smul]
rw [TensorProduct.smul_add, ihx, ihy]
simp [TensorProduct.zero_smul]
simp [Nat.succ_eq_one_add, TensorProduct.one_smul, TensorProduct.add_smul]
simp only [tmul_smul, smul_tmul, mul_smul]
rw [smul_zero, smul_zero]
rw [smul_tmul', smul_tmul', op_smul_eq_smul]
rw [smul_add, smul_add, hx, hy]
simp
rw [smul_tmul', smul_tmul', smul_tmul', smul_assoc]
rw [smul_add, smul_add, smul_add, ihx, ihy]
simp
rw [← tmul_smul, ← tmul_smul, ← tmul_smul, smul_assoc]
rw [smul_add, smul_add, smul_add, ihx, ihy]
rw [smul_tmul, tmul_smul]
rw [← top_le_iff, ← span_tmul_eq_top, Submodule.map₂_eq_span_image2]
exact Submodule.span_mono fun _ ⟨m, n, h⟩ => ⟨m, n, trivial, trivial, h⟩
rw [← tmul_smul, lift_aux_tmul, lift_aux_tmul, (f p).map_smul]
rw [smul_add, (lift_aux f).map_add, ih1, ih2, (lift_aux f).map_add, smul_add]
rw [g.map_add, h.map_add, ihx, ihy]
rw [H, lift.tmul]
simp
rw [lift_compr₂ f, lift_mk, LinearMap.comp_id]
rw [← lift_mk_compr₂ g, H, lift_mk_compr₂]
rw [uncurry, LinearMap.flip_apply, lift.tmul] <;> rfl
simp
simp <;> rw [← tmul_smul, ← smul_tmul, smul_eq_mul, mul_one]
dsimp [TensorProduct.lid]
simp
dsimp [TensorProduct.rid, TensorProduct.comm, TensorProduct.lid]
simp
simp only [LinearMap.comp_apply, map_tmul]
simp only [lift.tmul, map_tmul, LinearMap.compl₂_apply, LinearMap.comp_apply]
simp only [hom_tensor_hom_map, lift.tmul, map_bilinear_apply]
simp <;> simp only [LinearEquiv.apply_symm_apply]
simp <;> simp only [LinearEquiv.symm_apply_apply]
rw [ltensor_comp, coe_comp]
rw [rtensor_comp, coe_comp]
rw [ltensor_id, id_coe, id.def]
rw [rtensor_id, id_coe, id.def]
simp only [ltensor, rtensor, ← map_comp, id_comp, comp_id]
simp only [ltensor, rtensor, ← map_comp, id_comp, comp_id]
simp only [ltensor, rtensor, ← map_comp, id_comp, comp_id]
simp only [ltensor, rtensor, ← map_comp, id_comp, comp_id]
simp only [ltensor, rtensor, ← map_comp, id_comp, comp_id]
simp only [ltensor, rtensor, ← map_comp, id_comp, comp_id]
rw [add_zero]
apply (neg.aux R).map_zero
simp [TensorProduct.zero_smul]
simp [Nat.succ_eq_one_add, TensorProduct.one_smul, TensorProduct.add_smul]
change (-n.succ : ℤ)
simp
simp only [← coe_ltensor_hom, map_sub]
simp only [← coe_rtensor_hom, map_sub]
simp only [← coe_ltensor_hom, map_neg]
simp only [← coe_rtensor_hom, map_neg]
apply is_hermitian_conj_transpose_mul_mul
apply hA.inv
rw [Set.union_compl_self]
dsimp only [mem_set_of_eq]
rw [← map_top, ← supr_range_std_basis, map_supr]
congr
funext i
rw [← LinearMap.range_comp, diagonal_comp_std_basis, ← range_smul']
rw [Set.compl_union_self]
simp <;> infer_instance
rw [← hBC]
simp
rw [to_lin_self, id_apply, e.sum_to_matrix_smul_self]
rw [to_lin_to_matrix, to_lin_mul b b' c', to_lin_to_matrix, b'.to_lin_to_matrix, comp_id]
rw [basis_to_matrix_mul_linear_map_to_matrix, linear_map_to_matrix_mul_basis_to_matrix]
rw [Basis.to_matrix_mul_to_matrix, Basis.to_matrix_self]
decide
decide
decide
decide
decide
decide
rw [← circulant_single_one]
congr
rw [IsSymm, transpose_circulant, circulant_inj, funext_iff]
simp [is_symm.ext_iff, IsEmpty.forall_iff]
rw [← Matrix.to_lin'_mul, P.inv_of_mul_self, Matrix.to_lin'_one, LinearMap.id_apply]
rw [← Matrix.to_lin'_mul, P.mul_inv_of_self, Matrix.to_lin'_one, LinearMap.id_apply]
refine' matrix.to_lin'.injective (LinearMap.ext fun v => _)
rw [Matrix.to_lin'_mul, Matrix.to_lin'_one, Matrix.to_lin'_to_matrix', LinearMap.comp_apply]
exact (LinearEquiv.ofInjectiveEndo M.to_lin' this).apply_symm_apply v
rw [← reindex_linear_equiv_trans]
rfl
simp [algebraMap, Algebra.toRingHom, submatrix_smul]
apply (LinearMap.toMatrix B₁.dual_basis B₂.dual_basis).Injective
rw [LinearMap.to_matrix_to_lin, LinearMap.to_matrix_transpose, LinearMap.to_matrix_to_lin]
rw [← trace_transpose, ← trace_transpose_mul, transpose_mul]
rw [trace_mul_comm, Matrix.mul_assoc]
rw [← Matrix.mul_assoc, trace_mul_comm]
simp [dot_product, trace]
rw [← add_zero (A 2 2), add_assoc]
rfl
simp only [Pi.add_apply, map_add, add_mul, sum_add_distrib]
simp only [Pi.smul_apply, smul_eq_mul, RingHom.map_mul, mul_assoc, mul_sum]
simp only [Pi.add_apply, map_add, mul_add, sum_add_distrib]
simp only [Pi.smul_apply, smul_eq_mul, RingHom.map_mul, mul_assoc, mul_left_comm, mul_sum]
simp
rw [← LinearMap.compl₂_id (B.comp f), ← LinearMap.compl₁₂]
simp
rw [← LinearMap.comp_id B, ← LinearMap.compl₁₂]
simp
simp
simp only [B.to_matrix₂'_comp, transpose_transpose, to_matrix'_to_lin']
simp only [B.to_matrix₂'_compl₂, to_matrix'_to_lin']
simp
simp only [LinearMap.toMatrix₂, LinearEquiv.trans_apply, LinearMap.to_matrix₂'_apply,
    LinearEquiv.trans_apply, LinearMap.to_matrix₂'_apply, LinearEquiv.arrow_congr_apply,
    Basis.equiv_fun_symm_std_basis, LinearEquiv.refl_apply]
rw [LinearMap.to_matrix₂_apply, LinearMap.to_matrix₂_aux_apply]
rw [← LinearMap.compl₂_id (B.comp f), ← LinearMap.compl₁₂, LinearMap.to_matrix₂_compl₁₂ b₁ b₂]
simp
rw [← LinearMap.comp_id B, ← LinearMap.compl₁₂, LinearMap.to_matrix₂_compl₁₂ b₁ b₂]
simp
rw [LinearMap.to_matrix₂_comp b₁, to_matrix_to_lin, transpose_transpose]
rw [LinearMap.to_matrix₂_compl₂ b₁, to_matrix_to_lin]
simp only [LinearMap.to_matrix₂_compl₁₂ b₁ b₂, LinearMap.to_matrix₂_to_linear_map₂,
        to_matrix_to_lin]
intro B B'
constructor <;> intro h
· rw [h]
· exact linear_map.to_matrix₂'.injective h
intro B B'
constructor <;> intro h
· rw [h]
· exact (LinearMap.toMatrix₂ b₁ b₂).Injective h
have h' : IsUnit P.det := P.is_unit_iff_is_unit_det.mp h
let u := P.nonsing_inv_unit h'
let v := P
rw [← hA, Matrix.to_lin'_to_matrix']
erw [mem_pair_self_adjoint_matrices_submodule]
rfl
erw [mem_pair_self_adjoint_matrices_submodule]
simp [Matrix.IsSkewAdjoint, Matrix.IsAdjointPair]
rw [← Matrix.separating_left_to_linear_map₂'_iff_separating_left_to_linear_map₂,
    Matrix.separating_left_to_linear_map₂'_iff]
rw [Matrix.separating_left_to_linear_map₂'_iff, Matrix.nondegenerate_iff_det_ne_zero]
rw [← Matrix.nondegenerate_iff_det_ne_zero, nondegenerate_to_matrix_iff]
refine' ⟨hM.1, _⟩
intro x
refine' ⟨hM, fun x hx => _⟩
simp only [to_quadratic_form', QuadraticForm.PosDef, BilinForm.to_quadratic_form_apply,
    Matrix.to_bilin'_apply'] at hMq
apply hMq x hx
intro x hx
simp only [to_quadratic_form', BilinForm.to_quadratic_form_apply, Matrix.to_bilin'_apply']
apply hM.2 x hx
rw [← to_quadratic_form_associated ℝ Q, ← bilin_form.to_matrix'.left_inv ((associated_hom _) Q)]
apply Matrix.pos_def_to_quadratic_form' hQ
rw [← to_quadratic_form_associated ℝ Q, ←
    bilin_form.to_matrix'.left_inv ((associated_hom _) Q)] at hQ
apply Matrix.posDefOfToQuadraticForm' (is_symm_to_matrix' Q) hQ
rw [star_dot_product, star_ring_end_apply, star_star, star_mul_vec, dot_product_mul_vec,
          hM.is_hermitian.eq]
simp only [star_add, add_dot_product, eq_self_iff_true, forall_const]
rw [← smul_eq_mul, ← smul_dot_product, star_ring_end_apply, ← star_smul]
rw [dot_product_mul_vec, hv, zero_dot_product]
rw [abv.map_units_int_smul, abv.map_prod]
rw [prod_const, Finset.card_univ]
rw [sum_const, Finset.card_univ, Fintype.card_perm]
simp only [sum_apply]
unfold Matrix <;> infer_instance
rw [← Matrix.to_linear_map_right'_mul_apply, hM'M, Matrix.to_linear_map_right'_one, id_apply]
rw [← Matrix.to_linear_map_right'_mul_apply, hMM', Matrix.to_linear_map_right'_one,
        id_apply]
rw [Matrix.to_lin'_mul, LinearMap.comp_apply]
rw [this, LinearMap.to_matrix'_to_lin']
simp [Module.algebra_map_End_eq_smul_id]
simp only [Submodule.eq_bot_iff, LinearMap.mem_ker, Matrix.to_lin'_apply]
rw [← Matrix.to_lin'_mul_apply, hMM', Matrix.to_lin'_one, id_apply]
rw [← Matrix.to_lin'_mul_apply, hM'M, Matrix.to_lin'_one, id_apply]
simp [LinearMap.toMatrixAlgEquiv']
rw [vec_mul_vec_eq, Matrix.to_lin'_mul]
refine' le_trans (rank_comp_le1 _ _) _
refine' (rank_le_domain _).trans_eq _
rw [dim_fun', Fintype.card_unit, Nat.cast_one]
rw [← Matrix.to_lin_symm, LinearEquiv.apply_symm_apply]
rw [← Matrix.to_lin_symm, LinearEquiv.symm_apply_apply]
rw [LinearMap.toMatrix, LinearEquiv.trans_apply, LinearMap.to_matrix'_apply,
    LinearEquiv.arrow_congr_apply, Basis.equiv_fun_symm_apply, Finset.sum_eq_single j, if_pos rfl,
    one_smul, Basis.equiv_fun_apply]
· intro j' _ hj'
    rw [if_neg hj', zero_smul]
· intro hj
    have := Finset.mem_univ j
    contradiction
rw [Matrix.to_lin'_apply, v₂.equiv_fun_symm_apply]
rw [Matrix.to_lin_apply, Finset.sum_congr rfl fun j hj => _]
rw [Basis.repr_self, Matrix.mulVec, dot_product, Finset.sum_eq_single i, Finsupp.single_eq_same,
    mul_one]
· intro i' _ i'_ne
    rw [Finsupp.single_eq_of_ne i'_ne.symm, mul_zero]
· intros
    have := Finset.mem_univ i
    contradiction
rw [← LinearMap.to_matrix_id v₁, Matrix.to_lin_to_matrix]
simp [Module.algebra_map_End_eq_smul_id, LinearMap.to_matrix_id]
rw [Matrix.to_lin_mul v₁ v₂, LinearMap.comp_apply]
rw [← Matrix.to_lin_mul_apply, hM'M, Matrix.to_lin_one, id_apply]
rw [← Matrix.to_lin_mul_apply, hMM', Matrix.to_lin_one, id_apply]
rw [← Matrix.to_lin_alg_equiv_symm, AlgEquiv.apply_symm_apply]
rw [← Matrix.to_lin_alg_equiv_symm, AlgEquiv.symm_apply_apply]
simp [LinearMap.toMatrixAlgEquiv, LinearMap.to_matrix_apply]
rw [Matrix.to_lin_alg_equiv'_apply, v₁.equiv_fun_symm_apply]
rw [← LinearMap.to_matrix_alg_equiv_id v₁, Matrix.to_lin_alg_equiv_to_matrix_alg_equiv]
simp [LinearMap.toMatrixAlgEquiv, LinearMap.to_matrix_comp v₁ v₁ v₁ f g]
simp [Matrix.to_lin_apply, Matrix.mulVec, Matrix.dotProduct]
simp only [LinearMap.to_matrix_apply', coe_lmul_eq_mul, LinearMap.mul_apply']
rw [AlgHom.map_zero, LinearEquiv.map_zero]
rw [AlgHom.map_one, LinearMap.to_matrix_one]
rw [AlgHom.map_add, LinearEquiv.map_add]
rw [AlgHom.map_mul, LinearMap.to_matrix_mul, Matrix.mul_eq_mul]
rw [left_mul_matrix_apply, to_matrix_lmul' b x i j]
rw [(LinearMap.toMatrix b b).Injective h]
simp only [left_mul_matrix_apply, LinearMap.to_matrix_apply, mul_comm, Basis.smul_apply,
    Basis.smul_repr, Finsupp.smul_apply, id.smul_eq_mul, LinearEquiv.map_smul, mul_smul_comm,
    coe_lmul_eq_mul, LinearMap.mul_apply']
rw [smul_left_mul_matrix_algebra_map, block_diagonal_apply_eq]
rw [smul_left_mul_matrix_algebra_map, block_diagonal_apply_ne _ _ _ h]
let hbV := Basis.ofVectorSpace K V
let hbW := Basis.ofVectorSpace K W
rw [LinearEquiv.finrank_eq (LinearMap.toMatrix hbV hbW), Matrix.finrank_matrix,
    FiniteDimensional.finrank_eq_card_basis hbV, FiniteDimensional.finrank_eq_card_basis hbW,
    mul_comm]
apply e.arrow_congr_comp
    map_add'
simp only [Pi.add_apply, add_mul, sum_add_distrib]
simp only [Pi.smul_apply, smul_eq_mul, mul_assoc, mul_sum]
simp only [Pi.add_apply, mul_add, sum_add_distrib]
simp only [Pi.smul_apply, smul_eq_mul, mul_assoc, mul_left_comm, mul_sum]
refine' ext_basis (Pi.basisFun R₂ n) fun i j => _
rw [Pi.basis_fun_apply, Pi.basis_fun_apply, Matrix.to_bilin'_aux_std_basis,
    BilinForm.to_matrix_aux_apply]
simp only [BilinForm.compLeft, BilinForm.to_matrix'_comp, to_matrix'_id, Matrix.mul_one]
simp only [BilinForm.compRight, BilinForm.to_matrix'_comp, to_matrix'_id, transpose_one,
    Matrix.one_mul]
simp only [B.to_matrix'_comp, transpose_transpose, to_matrix'_to_lin']
simp only [B.to_matrix'_comp_left, transpose_transpose, to_matrix'_to_lin']
simp only [B.to_matrix'_comp_right, to_matrix'_to_lin']
simp only [BilinForm.to_matrix'_comp, BilinForm.to_matrix'_to_bilin', to_matrix'_to_lin']
rw [BilinForm.toMatrix, LinearEquiv.trans_apply, BilinForm.to_matrix'_apply, congr_apply,
    b.equiv_fun_symm_std_basis, b.equiv_fun_symm_std_basis]
rw [Matrix.toBilin, BilinForm.toMatrix, LinearEquiv.symm_trans_apply, ← Matrix.toBilin']
simp only [congr_symm, congr_apply, LinearEquiv.symm_symm, Matrix.to_bilin'_apply,
    Basis.equiv_fun_apply]
rw [BilinForm.to_matrix_apply, BilinForm.to_matrix_aux_apply]
simp only [comp_left, BilinForm.to_matrix_comp b b, to_matrix_id, Matrix.mul_one]
simp only [BilinForm.compRight, BilinForm.to_matrix_comp b b, to_matrix_id, transpose_one,
    Matrix.one_mul]
rw [← LinearMap.to_matrix_id_eq_basis_to_matrix, ← BilinForm.to_matrix_comp, BilinForm.comp_id_id]
simp only [B.to_matrix_comp b c, to_matrix_to_lin, transpose_transpose]
rw [B.to_matrix_comp_left b, to_matrix_to_lin, transpose_transpose]
rw [B.to_matrix_comp_right b, to_matrix_to_lin]
simp only [BilinForm.to_matrix_comp b c, BilinForm.to_matrix_to_bilin, to_matrix_to_lin]
intro B B'
constructor <;> intro h
· rw [h]
· exact bilin_form.to_matrix'.injective h
intro B B'
constructor <;> intro h
· rw [h]
· exact (BilinForm.toMatrix b).Injective h
have h' : IsUnit P.det := P.is_unit_iff_is_unit_det.mp h
let u := P.nonsing_inv_unit h'
let v := P
simp only [mem_pair_self_adjoint_matrices_submodule]
simp only [mem_self_adjoint_matrices_submodule]
simp only [mem_skew_adjoint_matrices_submodule]
rw [← Matrix.nondegenerate_to_bilin'_iff_nondegenerate_to_bilin,
    Matrix.nondegenerate_to_bilin'_iff]
rw [Matrix.nondegenerate_to_bilin'_iff, Matrix.nondegenerate_iff_det_ne_zero]
rw [← Matrix.nondegenerate_iff_det_ne_zero, nondegenerate_to_matrix_iff]
intro i j hij
apply Finset.sum_eq_zero
intro k hk
rw [insert_erase]
apply max'_mem
refine' h.det.trans ((prod_subset (subset_univ _)) fun a _ ha => _)
have : IsEmpty { i // b i = a } := ⟨fun i => ha <| mem_image.2 ⟨i, mem_univ _, i.2⟩⟩
exact det_is_empty
rw [← det_transpose]
exact det_of_upper_triangular h.transpose
rw [← to_block_mul_eq_add, inv_mul_of_invertible M, to_block_one_self]
rw [← to_block_mul_eq_add, inv_mul_of_invertible M, to_block_one_disjoint]
rw [disjoint_iff_inf_le]
exact fun i h => h.1 h.2
simp only [to_block_inverse_eq_zero hM k, Pi.zero_apply]
infer_instance
infer_instance
simp only [h, Matrix.mul_one, Matrix.one_mul, IH m]
simp only [h', Matrix.mul_one, Matrix.one_mul]
rw [zpow_ofNat, one_pow]
rw [zpow_negSucc, one_pow, inv_one]
simp [zero_pow n.zero_lt_succ]
rw [zpow_ofNat, zpow_ofNat, inv_pow']
rw [zpow_negSucc, zpow_negSucc, inv_pow']
cases n
· simp
· exact DivInvMonoid.zpow_neg' _ _
rw [zpow_negSucc, neg_neg_of_nat_succ, of_nat_eq_coe, zpow_ofNat, nonsing_inv_nonsing_inv]
rw [det_pow]
exact h.pow _
rw [zpow_neg h, inv_zpow]
simp only [← Nat.cast_succ, pow_succ', zpow_ofNat]
rw [neg_add, neg_add_cancel_right, zpow_neg h, zpow_ofNat]
rw [mul_inv_rev, Matrix.mul_assoc, nonsing_inv_mul _ h, Matrix.mul_one]
rw [zpow_neg h, ← Int.ofNat_succ, zpow_ofNat, pow_succ, mul_eq_mul, mul_eq_mul]
rw [mul_assoc, mul_eq_mul A, mul_nonsing_inv _ h, mul_one]
rw [← zpow_add_one h, sub_add_cancel]
rw [zpow_add h, zpow_one]
simp [h.pow_right n]
rw [det_pow]
exact hx.pow n.succ
rw [det_pow]
exact hy.pow n.succ
simp only [pow_succ', ← Nat.cast_succ, zpow_ofNat]
rw [zpow_ofNat, zpow_ofNat, ← pow_mul, ← zpow_ofNat, Int.ofNat_mul]
rw [zpow_ofNat, zpow_negSucc, ← pow_mul, coe_nat_mul_neg_succ, ← Int.ofNat_mul,
      zpow_neg_coe_nat]
rw [zpow_ofNat, zpow_negSucc, ← inv_pow', ← pow_mul, neg_succ_mul_coe_nat, ← Int.ofNat_mul,
      zpow_neg_coe_nat, inv_pow']
rw [zpow_negSucc, zpow_negSucc, neg_succ_mul_neg_succ, ← Int.ofNat_mul, zpow_ofNat, inv_pow', ←
      pow_mul, nonsing_inv_nonsing_inv]
rw [det_pow]
exact h.pow _
rw [mul_comm, zpow_mul _ h]
rw [_root_.zpow_coe_nat, zpow_ofNat, Units.val_pow_eq_pow_val]
rw [sub_eq_add_neg, zpow_add ha, zpow_neg ha, div_eq_mul_inv]
simp [h.mul_pow n, -mul_eq_mul]
rw [zpow_bit1, Commute.mul_zpow (Commute.refl A)]
rw [zpow_neg h, mul_eq_mul, nonsing_inv_mul _ (h.det_zpow _)]
simp only [one_div, inv_pow']
simp only [one_div, inv_zpow]
rw [zpow_ofNat, zpow_ofNat, transpose_pow]
rw [zpow_negSucc, zpow_negSucc, transpose_nonsing_inv, transpose_pow]
rw [zpow_ofNat, zpow_ofNat, conj_transpose_pow]
rw [zpow_negSucc, zpow_negSucc, conj_transpose_nonsing_inv, conj_transpose_pow]
rw [@LinearEquiv.finrank_eq R (Matrix m n R) _ _ _ _ _ _ (LinearEquiv.curry R m n).symm,
    FiniteDimensional.finrank_fintype_fun_eq_card, Fintype.card_prod]
rw [charpoly, det_apply', ← insert_erase (mem_univ (Equiv.refl n)),
    sum_insert (not_mem_erase (Equiv.refl n) univ), add_comm]
simp only [charmatrix_apply_eq, one_mul, Equiv.Perm.sign_refl, id.def, Int.cast_one,
    Units.val_one, add_sub_cancel, Equiv.coe_refl]
rw [← mem_degree_lt]
apply Submodule.sum_mem (degree_lt R (Fintype.card n - 1))
intro c hc
rw [← C_eq_int_cast, C_mul']
apply Submodule.smul_mem (degree_lt R (Fintype.card n - 1)) ↑↑(Equiv.Perm.sign c)
rw [mem_degree_lt]
apply lt_of_le_of_lt degree_le_nat_degree _
rw [WithBot.coe_lt_coe]
apply lt_of_le_of_lt _ (Equiv.Perm.fixed_point_card_lt_of_ne_one (ne_of_mem_erase hc))
apply le_trans (Polynomial.nat_degree_prod_le univ fun i : n => charmatrix M (c i) i) _
rw [card_eq_sum_ones]
rw [sum_filter]
apply sum_le_sum
intros
apply charmatrix_apply_nat_degree_le
apply eq_of_sub_eq_zero
rw [← coeff_sub]
apply Polynomial.coeff_eq_zero_of_degree_lt
apply lt_of_lt_of_le (charpoly_sub_diagonal_degree_lt M) _
rw [WithBot.coe_le_coe]
apply h
simp [this]
apply monic_prod_of_monic univ fun i : n => X - C (M i i)
simp [monic_X_sub_C]
simp
rw [coeff_zero_eq_eval_zero, charpoly, eval_det, mat_poly_equiv_charmatrix, ← det_smul]
simp
rw [← aeval_eq_aeval_mod_charpoly, map_pow, aeval_X]
rw [Finset.sum_const, card_univ, smul_eq_mul, mul_one]
cases isEmpty_or_nonempty n
· simp [zero_pow Fintype.card_pos, Matrix.trace]
rw [Matrix.trace_eq_neg_charpoly_coeff, Matrix.trace_eq_neg_charpoly_coeff,
    FiniteField.Matrix.charpoly_pow_card, FiniteField.pow_card]
simp only [charmatrix, sub_left_inj, Pi.sub_apply, scalar_apply_eq, RingHom.map_matrix_apply,
    map_apply, Dmatrix.sub_apply]
simp only [charmatrix, Pi.sub_apply, scalar_apply_ne _ _ _ h, zero_sub, RingHom.map_matrix_apply,
    map_apply, Dmatrix.sub_apply]
unfold Matrix.charpoly
rw [charmatrix_reindex, Matrix.det_reindex_self]
apply minpoly.unique
· apply Matrix.charpoly_monic
· apply (injective_iff_map_eq_zero (left_mul_matrix _)).mp (left_mul_matrix_injective h.basis)
    rw [← Polynomial.aeval_alg_hom_apply, aeval_self_charpoly]
· intro q q_monic root_q
    rw [Matrix.charpoly_degree_eq_dim, Fintype.card_fin, degree_eq_nat_degree q_monic.ne_zero]
    apply with_bot.some_le_some.mpr
    exact h.dim_le_nat_degree_of_root q_monic.ne_zero root_q
rw [(Fintype.range_total R b).trans hb]
trivial
delta Matrix.Represents at h h'⊢
rw [map_add, map_add, h, h']
delta Matrix.Represents
rw [map_zero, map_zero]
delta Matrix.Represents at h⊢
rw [map_smul, map_smul, h]
rw [Ideal.range_finsupp_total, hb]
exact fun x => hI (f.mem_range_self x)
simp
rw [Subtype.range_coe_subtype, Finset.set_of_mem, hs]
simp
apply gram_schmidt_orthogonal _ _ h₀
rw [←
    @gram_schmidt_triangular 𝕜 (n → 𝕜) _ (inner_product_space.of_matrix hS.transpose) n _ _ _ i j
      hij (Pi.basisFun 𝕜 n),
    Pi.basis_fun_repr, LDL.lowerInv]
rw [LDL.lower, conj_transpose_nonsing_inv, Matrix.mul_assoc,
    Matrix.inv_mul_eq_iff_eq_mul_of_invertible (LDL.lowerInv hS),
    Matrix.mul_inv_eq_iff_eq_mul_of_invertible]
exact LDL.diag_eq_lower_inv_conj hS
rw [cramer_apply, update_column_transpose, det_transpose]
rw [cramer_apply, det_eq_elem_of_subsingleton _ i, update_column_self]
rw [sum_cramer, cramer_apply]
congr
rw [adjugate_def]
simp only
rw [cramer_apply, update_column_transpose, det_transpose]
apply prod_eq_zero (mem_univ j)
rw [update_column_self, Pi.single_eq_of_ne' h]
refine' (pi_eq_sum_univ b).trans _
congr
erw [← smul_eq_mul, ← Pi.smul_apply, ← LinearMap.map_smul, ← Pi.single_smul', smul_eq_mul,
    mul_one]
rw [← adjugate_transpose, ← transpose_mul, transpose_transpose]
rw [adjugate, adjugate, transpose_smul, cramer_smul]
rfl
rw [cramer_eq_adjugate_mul_vec, mul_vec_mul_vec, mul_adjugate, smul_mul_vec_assoc, one_mul_vec]
rw [← f.map_one]
exact Pi.single_op (fun i => f) (fun i => f.map_zero) i (1 : R)
rw [← mv_polynomial_X_map_matrix_aeval ℤ A, ← AlgHom.map_adjugate, ← AlgHom.map_det, ←
      AlgHom.map_det, ← AlgHom.map_pow, this]
rw [mul_adjugate, det_smul, det_one, mul_one]
rw [← pow_succ, h_card]
constructor
· intro B C h
    refine' hA.matrix _
    rw [← Matrix.one_mul B, ← Matrix.one_mul C, ← Matrix.smul_mul, ← Matrix.smul_mul, ←
      adjugate_mul, Matrix.mul_assoc, Matrix.mul_assoc, ← mul_eq_mul A, h, mul_eq_mul]
· intro B C h
    simp only [mul_eq_mul] at h
    refine' hA.matrix _
    rw [← Matrix.mul_one B, ← Matrix.mul_one C, ← Matrix.mul_smul, ← Matrix.mul_smul, ←
      mul_adjugate, ← Matrix.mul_assoc, ← Matrix.mul_assoc, h]
rw [det_mul]
exact hA.mul hB
let g : Matrix n n α → Matrix n n α[X] := fun M => M.map Polynomial.c + (Polynomial.x : α[X])
intro
rw [RingHom.map_adjugate, f'_inv]
intros
rw [← mul_eq_mul, RingHom.map_mul, f'_inv, f'_inv, mul_eq_mul]
intro M
refine' Polynomial.Monic.is_regular _
simp only [g, Polynomial.Monic.def, ← Polynomial.leading_coeff_det_X_one_add_C M, add_comm]
rw [← adjugate_mul_distrib, adjugate_mul, adjugate_smul, adjugate_one]
rw [← mv_polynomial_X_map_matrix_aeval ℤ A, ← AlgHom.map_adjugate, ← AlgHom.map_adjugate, this,
      ← AlgHom.map_det, ← AlgHom.map_pow, AlgHom.map_matrix_apply, AlgHom.map_matrix_apply,
      Matrix.map_smul' _ _ _ (_root_.map_mul _)]
simp [h_card]
simp
apply Basis.to_matrix_mul_to_matrix_flip
rw [eigenvector_matrix_inv, Basis.to_matrix_apply, OrthonormalBasis.coe_to_basis_repr_apply,
    OrthonormalBasis.repr_apply_apply, PiLp.basis_fun_apply, PiLp.equiv_symm_single,
    EuclideanSpace.inner_single_right, one_mul, IsROrC.star_def]
rw [← conj_transpose_eigenvector_matrix_inv, conj_transpose_conj_transpose]
have := hA.spectral_theorem
rw [← Matrix.mul_inv_eq_iff_eq_mul_of_invertible] at this
have := congr_arg IsROrC.re (congr_fun (congr_fun this i) i)
rw [diagonal_apply_eq, IsROrC.of_real_re, inv_eq_left_inv hA.eigenvector_matrix_mul_inv, ←
    conj_transpose_eigenvector_matrix, mul_mul_apply] at this
exact this.symm
apply mul_left_cancel₀ (det_ne_zero_of_left_inverse (eigenvector_matrix_mul_inv hA))
rw [← det_mul, spectral_theorem, det_mul, mul_comm, det_diagonal]
simp [transvection]
simp [transvection, Matrix.add_mul, Matrix.mul_add, h, h.symm, add_smul, add_assoc,
    std_basis_matrix_add]
simp [transvection, Matrix.add_mul]
simp [transvection, Matrix.mul_add, mul_comm]
simp [transvection, Matrix.add_mul, ha]
simp [transvection, Matrix.mul_add, hb]
rw [← update_row_eq_transvection i j, det_update_row_add_smul_self _ h, det_one]
simp [t.hij]
simp [t.hij]
induction on the size
simp [list_transvec_col]
cases i
simp only [Fin.mk_eq_mk] at h
simp [h]
simp only [list_transvec_row, List.ofFnNthVal, hkr, dif_pos, List.nth_of_fn]
rfl
simp [list_transvec_row]
simp [list_transvec_row]
simp
simp only [list_transvec_row, List.ofFnNthVal, hnr, dif_pos, List.nth_of_fn]
rfl
cases i
simp only [Fin.mk_eq_mk] at h
simp only [h, coe_mk]
simp only [← hni, n.lt_succ_self, not_le]
simp [list_transvec_row, list_transvec_col_mul_last_row]
simp [list_transvec_col, mul_list_transvec_row_last_col]
simp only [eq_iff_true_of_subsingleton]
simp only [eq_iff_true_of_subsingleton]
simp
simp
simp [L, list_transvec_col, (· ∘ ·)]
simp [L, list_transvec_row, (· ∘ ·)]
simp
simp
simp only [Equiv.symm_symm, submatrix_submatrix, reindex_apply, submatrix_id_id,
      Equiv.symm_comp_self, reindex_alg_equiv_apply]
simp
simp
simp [h]
rw [hD]
exact hMdet
simp
simp [QA.1, QB.1]
rw [← Matrix.mul_assoc, Matrix.inv_of_mul_self, Matrix.one_mul]
rw [← Matrix.mul_assoc, Matrix.mul_inv_of_self, Matrix.one_mul]
rw [Matrix.mul_assoc, Matrix.inv_of_mul_self, Matrix.mul_one]
rw [Matrix.mul_assoc, Matrix.mul_inv_of_self, Matrix.mul_one]
rw [mul_smul_comm, Matrix.mul_eq_mul, mul_adjugate, smul_smul, invOf_mul_self, one_smul]
rw [smul_mul_assoc, Matrix.mul_eq_mul, adjugate_mul, smul_smul, invOf_mul_self, one_smul]
rw [mul_comm, ← det_mul, h, det_one]
rw [← det_mul, h, det_one]
rw [← det_mul, h, det_one]
rw [mul_comm, ← det_mul, h, det_one]
rw [Matrix.mul_inv_of_self, Matrix.mul_one]
simp only [Matrix.mul_assoc]
rw [h, Matrix.one_mul]
rw [← transpose_transpose A]
infer_instance
rw [← conj_transpose_conj_transpose A]
infer_instance
simp only [← nonempty_invertible_iff_is_unit, (invertible_equiv_det_invertible A).nonempty_congr]
rw [det_transpose]
exact h
rw [inv_def, Ring.inverse_non_unit _ h, zero_smul]
rw [inv_def, ← Ring.inverse_unit h.unit, IsUnit.unit_spec]
rw [inv_def, inv_def, transpose_smul, det_transpose, adjugate_transpose]
rw [inv_def, inv_def, conj_transpose_smul, det_conj_transpose, adjugate_conj_transpose,
    Ring.inverse_star]
cases (A.is_unit_iff_is_unit_det.mpr h).nonempty_invertible
rw [← inv_of_eq_nonsing_inv, Matrix.mul_inv_of_self]
cases (A.is_unit_iff_is_unit_det.mpr h).nonempty_invertible
rw [← inv_of_eq_nonsing_inv, Matrix.inv_of_mul_self]
rw [← inv_of_eq_nonsing_inv]
infer_instance
simp only [← inv_of_eq_nonsing_inv, invOf_invOf]
simp [Matrix.mul_assoc, mul_nonsing_inv A h]
simp [← Matrix.mul_assoc, mul_nonsing_inv A h]
simp [Matrix.mul_assoc, nonsing_inv_mul A h]
simp [← Matrix.mul_assoc, nonsing_inv_mul A h]
rw [← h, mul_inv_cancel_left_of_invertible]
rw [h, inv_mul_cancel_left_of_invertible]
rw [← h, inv_mul_cancel_right_of_invertible]
rw [h, mul_inv_cancel_right_of_invertible]
rw [← det_mul, A.nonsing_inv_mul h, det_one]
rw [Matrix.one_mul]
rw [A.mul_nonsing_inv h]
rw [Matrix.det_nonsing_inv, isUnit_ring_inverse]
rw [← inv_eq_left_inv h, ← inv_eq_left_inv g]
rw [← inv_eq_right_inv h, ← inv_eq_right_inv g]
rw [← inv_eq_right_inv h, ← inv_eq_left_inv g]
simp
simp [h, smul_smul]
simp [h, smul_smul]
refine' inv_eq_left_inv _
rw [smul_mul, mul_adjugate, Units.smul_def, smul_smul, h.coe_inv_mul, one_smul]
simp only [← nonempty_invertible_iff_is_unit,
    (diagonal_invertible_equiv_invertible v).nonempty_congr]
rw [nonsing_inv_eq_ring_inverse]
simp only [inv_def]
rw [Matrix.smul_mul, Matrix.mul_smul, smul_smul, det_mul, adjugate_mul_distrib,
    Ring.mul_inverse_rev]
rw [List.reverse_nil, List.map_nil, List.prod_nil, inv_one]
rw [List.reverse_cons', List.map_concat, List.prod_concat, List.prod_cons, Matrix.mul_eq_mul,
      Matrix.mul_eq_mul, mul_inv_rev, list_prod_inv_reverse]
rw [cramer_eq_adjugate_mul_vec, A.nonsing_inv_apply h, ← smul_mul_vec_assoc, smul_smul,
    h.mul_coe_inv, one_smul]
rw [← h.unit_spec, ← coe_units_inv, det_units_conj]
rw [← h.unit_spec, ← coe_units_inv, det_units_conj']
simp only [from_blocks_multiply, Matrix.mul_zero, Matrix.zero_mul, add_zero, zero_add,
      Matrix.one_mul, Matrix.mul_one, Matrix.inv_of_mul_self, Matrix.mul_inv_of_self_assoc,
      Matrix.mul_inv_of_mul_self_cancel, Matrix.mul_assoc, add_sub_cancel'_right]
rw [det_from_blocks_one₂₂, Matrix.neg_mul, sub_neg_eq_add]
rw [det_from_blocks_one₁₁, Matrix.mul_neg, sub_neg_eq_add]
rw [add_comm, det_one_add_mul_comm, add_comm]
rw [sub_eq_add_neg, ← Matrix.neg_mul, det_one_add_mul_comm, Matrix.mul_neg, ← sub_eq_add_neg]
rw [det_one_add_mul_comm, det_unique, Pi.add_apply, Pi.add_apply, Matrix.one_apply_eq,
    Matrix.row_mul_col_apply]
intro i j h
simp [ha h, hf]
intro i j h
simp [ha h]
intro i j h
simp [ha h, hb h]
intro i j h
simp [ha h, hb h]
intro i j h
simp [ha h]
rw [← (is_symm_from_blocks_iff.1 h).2.1]
exact ha.from_blocks hd
rw [LinearMap.std_basis_ne _ _ _ _ hb, mul_zero]
rw [dot_product_std_basis_eq_mul, mul_one]
simp [det_apply, Units.smul_def]
rw [← diagonal_one] <;> simp [-diagonal_one]
simp [det_apply]
simp [det_apply, univ_unique]
simp [apply_swap_eq_self hpij]
simp only [det_apply', mul_apply, prod_univ_sum, mul_sum, Fintype.pi_finset_univ] <;>
        rw [Finset.sum_comm]
injection h
simp only [mul_comm, mul_left_comm, prod_mul_distrib, mul_assoc]
simp only [inv_mul_cancel_right]
simp only [det_apply', Finset.mul_sum, mul_comm, mul_left_comm]
rw [det_mul, det_mul, mul_comm]
rw [← Matrix.mul_assoc, ← Matrix.mul_assoc, det_mul, det_mul_comm M N, ← det_mul]
rw [Matrix.mul_assoc, Matrix.mul_assoc, det_mul, det_mul_comm N P, ← det_mul]
rw [det_mul_right_comm, ← mul_eq_mul, ← mul_eq_mul, Units.mul_inv, one_mul]
rw [det_apply', det_apply']
refine' Fintype.sum_bijective _ inv_involutive.bijective _ _ _
intro σ
rw [sign_inv]
congr 1
apply Fintype.prod_equiv σ
intros
simp
simp [Units.smul_def]
rw [det_apply', det_apply']
apply Fintype.sum_equiv (Equiv.permCongr e)
intro σ
rw [Equiv.Perm.sign_perm_congr e σ]
congr 1
apply Fintype.prod_equiv e
intro i
rw [Equiv.permCongr_apply, Equiv.symm_apply_apply, submatrix_apply]
rw [← Matrix.mul_one (σ.to_pequiv.to_matrix : Matrix n n R), Pequiv.to_pequiv_mul_matrix,
    det_permute, det_one, mul_one]
rw [smul_eq_diagonal_mul]
simp [card_univ]
rw [← smul_one_smul R c A, det_smul, smul_pow, one_pow, smul_mul_assoc, one_mul]
rw [← det_smul, neg_one_smul]
rw [← det_smul_of_tower, Units.neg_smul, one_smul]
rw [det_mul, det_diagonal, mul_comm]
simp [Matrix.det_apply', f.map_sum, f.map_prod]
rw [← det_transpose]
exact det_eq_zero_of_row_eq_zero j h
rw [← det_transpose, det_zero_of_row_eq i_ne_j]
exact funext hij
rw [← det_transpose, ← update_row_transpose, det_update_row_add]
simp [update_row_transpose, det_transpose]
rw [← det_transpose, ← update_row_transpose, det_update_row_smul]
simp [update_row_transpose, det_transpose]
rw [← det_transpose, ← update_row_transpose, transpose_smul, det_update_row_smul']
simp [update_row_transpose, det_transpose]
rw [hC, mul_one]
rw [hC, one_mul]
simp [det_update_row_add,
    det_zero_of_row_eq hij (update_row_self.trans (update_row_ne hij.symm).symm)]
rw [← det_transpose, ← update_row_transpose, ← det_transpose A]
exact det_update_row_add_self A
simp [det_update_row_add, det_update_row_smul,
    det_zero_of_row_eq hij (update_row_self.trans (update_row_ne hij.symm).symm)]
rw [← det_transpose, ← update_row_transpose, ← det_transpose A]
exact det_update_row_add_smul_self A
rw [← det_transpose A, ← det_transpose B]
exact det_eq_of_forall_row_eq_smul_add_pred c A_zero fun i j => A_succ j i
rw [Eq]
intro x
exact congr_fun (congr_arg to_fun h) x
rw [← det_transpose, from_blocks_transpose, transpose_zero, det_from_blocks_zero₂₁, det_transpose,
    det_transpose]
simp [Fin.sign_cycle_range]
simp only [Fin.prod_univ_succ, Fin.succ_above_cycle_range,
        Equiv.Perm.decompose_fin_symm_apply_zero, Equiv.Perm.decompose_fin_symm_apply_succ]
simp only [mul_assoc, mul_comm, _root_.neg_mul, one_mul, zsmul_eq_mul, neg_inj, neg_smul,
        Fin.succ_above_cycle_range]
rw [← det_transpose A, det_succ_column_zero]
refine' Finset.sum_congr rfl fun i _ => _
rw [← det_transpose]
simp only [transpose_apply, transpose_submatrix, transpose_transpose]
simp
simp [-Int.units_mul_self]
rw [← det_transpose, det_succ_row _ j]
refine' Finset.sum_congr rfl fun i _ => _
rw [add_comm, ← det_transpose, transpose_apply, transpose_submatrix, transpose_transpose]
intro h_det
have := congr_arg Matrix.det (mv_polynomial_X_map_matrix_eval (1 : Matrix m m R))
rw [det_one, ← RingHom.map_det, h_det, RingHom.map_zero] at this
exact zero_ne_one this
unfold is_hermitian at h
rw [← h, conj_transpose_apply, star_star, h]
rw [is_hermitian, conj_transpose_mul, conj_transpose_conj_transpose]
rw [is_hermitian, conj_transpose_mul, conj_transpose_conj_transpose]
simp only [is_hermitian, conj_transpose_mul, conj_transpose_conj_transpose, hA.eq,
    Matrix.mul_assoc]
simp only [is_hermitian, conj_transpose_mul, conj_transpose_conj_transpose, hA.eq,
    Matrix.mul_assoc]
simp [is_hermitian, add_comm]
simp [is_hermitian, add_comm]
rw [is_hermitian, conj_transpose, transpose_map]
congr
exact h
intro h
rw [← transpose_transpose A]
exact is_hermitian.transpose h
intro h
rw [← conj_transpose_conj_transpose A]
exact is_hermitian.conj_transpose h
rw [← hBC]
simp
simp [is_hermitian, conj_transpose_nonsing_inv, hA.eq]
rw [← inv_inv_of_invertible A]
exact is_hermitian.inv h
simp [is_hermitian, adjugate_conj_transpose, hA.eq]
rw [← eq_conj_iff_re, ← star_def, ← conj_transpose_apply, h.eq]
rw [det_mul, det_mul, mul_comm]
rw [← det_comm' hM'M hMM', ← Matrix.mul_assoc, hM'M, Matrix.one_mul]
rw [← linear_map_to_matrix_mul_basis_to_matrix c b c, ←
      basis_to_matrix_mul_linear_map_to_matrix b c b, Matrix.det_conj_of_mul_eq_one] <;>
    rw [Basis.to_matrix_mul_to_matrix, Basis.to_matrix_self]
apply Trunc.induction_on tb
intro b
rw [det_aux_def, det_to_matrix_eq_det_to_matrix b b']
have : ∃ s : Finset M, Nonempty (Basis s A M) := ⟨s, ⟨b⟩⟩
rw [LinearMap.coe_det, dif_pos, det_aux_def' _ b] <;> assumption
simp [← to_matrix_eq_to_matrix']
rw [← LinearMap.det_to_matrix b, LinearMap.to_matrix_to_lin]
simp only [← to_lin_eq_to_lin', det_to_lin]
have b : Basis (Fin 0) R M := Basis.empty M
rw [← f.det_to_matrix b]
exact Matrix.det_is_empty
rw [← Fintype.card_eq_zero_iff]
exact (FiniteDimensional.finrank_eq_card_basis b).symm.trans h
simp only [← LinearMap.det_comp, hg, MonoidHom.map_one]
simp [f.finite_dimensional_of_det_ne_one, hf]
simp [f.finite_dimensional_of_det_ne_one, hf]
rw [← Units.eq_iff, coe_det, coe_det, ← comp_coe, ← comp_coe, LinearMap.det_conj]
simp [← LinearMap.det_comp]
simp [← LinearMap.det_comp]
rw [to_lin_mul v v' v, to_lin_to_matrix, LinearMap.comp_apply]
simp [h]
rw [to_lin_mul v' v v', LinearMap.comp_apply, to_lin_to_matrix v v']
simp [h]
simp only [LinearMap.det_to_matrix, isUnit_iff_ne_zero.2 hf]
refine' LinearMap.associated_det_of_eq_comp (e.trans e'.symm) _ _ _
intro x
simp only [LinearMap.comp_apply, LinearEquiv.coe_coe, LinearEquiv.trans_apply,
    LinearEquiv.apply_symm_apply]
intro v i x y
simp only [e.to_matrix_update, LinearEquiv.map_add]
apply det_update_column_add
intro u i c x
simp only [e.to_matrix_update, Algebra.id.smul_eq_mul, LinearEquiv.map_smul]
apply det_update_column_smul
intro v i j h hij
rw [← Function.update_eq_self i v, h, ← det_transpose, e.to_matrix_update, ←
      update_row_transpose, ← e.to_matrix_transpose_apply]
apply det_zero_of_row_eq hij
rw [update_row_ne hij.symm, update_row_self]
simp [e.det_apply]
rw [Basis.det_apply, Basis.det_apply, ← f.det_to_matrix e, ← Matrix.det_mul,
    e.to_matrix_eq_to_matrix_constr (f ∘ v), e.to_matrix_eq_to_matrix_constr v, ← to_matrix_comp,
    e.constr_comp]
rw [Basis.det_apply, Basis.to_matrix_reindex', det_reindex_alg_equiv, Basis.det_apply]
rw [Basis.det_reindex, Function.comp.assoc, e.self_comp_symm, Function.comp.right_id]
rw [Basis.det_apply, Basis.to_matrix_map, Basis.det_apply]
simp [hik, Function.update_apply]
simp [Basis.det_apply]
rw [f.map_add] <;> rfl
rw [f.map_smulₛₗ] <;> rfl
rw [H]
simp only [map_add, dom_restrict_apply, add_apply]
simp only [f.map_smulₛₗ, dom_restrict_apply, smul_apply]
simp only [smul_smul, smul_eq_mul, mul_comm]
rw [w_base]
erw [CategoryTheory.Functor.map_id, functor.id_obj X.fiber]
erw [functor.map_comp, functor.comp_obj]
erw [CategoryTheory.Functor.map_id, functor.id_obj X.fiber]
subst h
subst h
dsimp
simp
cases X
exact iso.refl _
intros
rw [comp_smul, smul_comp, α.naturality]
apply e.functor.map_injective
simp
infer_instance
dsimp [End]
infer_instance
simp
simp
simp
simp
simp only [category.assoc, ModuleCat.coe_comp, Function.comp_apply,
            linear.left_comp_apply, linear.right_comp_apply]
simp only [linear.right_comp_apply, category.comp_id, nat_trans.id_app,
            ModuleCat.id_apply]
simp only [category.assoc, linear.right_comp_apply, nat_trans.comp_app,
            ModuleCat.coe_comp, Function.comp_apply]
simp only [category.assoc, ModuleCat.coe_comp, Function.comp_apply,
            linear.right_comp_apply, linear.left_comp_apply]
simp only [linear.left_comp_apply, unop_id, category.id_comp, nat_trans.id_app,
            ModuleCat.id_apply]
simp only [category.assoc, ModuleCat.coe_comp, Function.comp_apply,
            linear.left_comp_apply, unop_comp, nat_trans.comp_app]
simp [a f]
simp [ulift_hom, hc.is_nonempty]
simp only [p']
exact hj₀
simp
infer_instance
have z : ∀ j : J, r (Classical.arbitrary J) j :=
    induct_on_objects (fun k => r (Classical.arbitrary J) k) (hr.1 (Classical.arbitrary J))
      fun _ _ f => ⟨fun t => hr.2.2 t (h f), fun t => hr.2.2 t (hr.2.1 (h f))⟩
intros
apply hr.2.2 (hr.2.1 (z _)) (z _)
have := α.naturality f
erw [id_comp, comp_id] at this
exact this.symm
infer_instance
rw [comp_tensor_id, category.assoc, ← F.to_functor.map_id, F.μ_natural_assoc,
      F.to_functor.map_id, F.left_unitality_inv_assoc, ← F.to_functor.map_comp, ←
      F.to_functor.map_comp, e_id_comp, F.to_functor.map_id]
rw [id_tensor_comp, category.assoc, ← F.to_functor.map_id, F.μ_natural_assoc,
      F.to_functor.map_id, F.right_unitality_inv_assoc, ← F.to_functor.map_comp, ←
      F.to_functor.map_comp, e_comp_id, F.to_functor.map_id]
rw [comp_tensor_id, category.assoc, ← F.to_functor.map_id, F.μ_natural_assoc,
      F.to_functor.map_id, ← F.associativity_inv_assoc, ← F.to_functor.map_comp, ←
      F.to_functor.map_comp, e_assoc, id_tensor_comp, category.assoc, ← F.to_functor.map_id,
      F.μ_natural_assoc, F.to_functor.map_comp]
let I : enriched_category (Type v) (transport_enrichment (coyoneda_tensor_unit W) C) :=
    inferInstance
exact enriched_category_Type_equiv_category C I
cases F
simp
cases F
simp
dsimp [comap]
subst h
dsimp [comap]
subst h
subst h
subst h
rfl
rw [← arrow.inv_left_hom_right e.hom, hP.cancel_left_is_iso, hP.cancel_right_is_iso]
rfl
let e := sq.flip.iso_pullback
rw [← hP₁.cancel_left_is_iso e.inv, sq.flip.iso_pullback_inv_fst]
exact hP₂ _ _ _ f g hg
apply respects_iso.of_respects_arrow_iso
intro f g e
exact hP (is_pullback.of_horiz_is_iso (comm_sq.mk e.inv.w))
let e :=
    pullback_right_pullback_fst_iso Y.hom f g.left
apply pullback.hom_ext <;> dsimp <;> simp
apply pullback.hom_ext <;> dsimp <;> simp
let e := sq.flip.iso_pushout
rw [← hP₁.cancel_right_is_iso _ e.hom, sq.flip.inr_iso_pushout_hom]
exact hP₂ _ _ _ f g hf
rfl
rfl
rfl
constructor <;>
    · intro X Y Z e f
      simp only [monomorphisms.iff]
      intro
      apply mono_comp
constructor <;>
    · intro X Y Z e f
      simp only [epimorphisms.iff]
      intro
      apply epi_comp
constructor <;>
    · intro X Y Z e f
      simp only [isomorphisms.iff]
      intro
      infer_instance
rw [← this]
exact h f hf
rw [this]
exact h f hf
simp
rw [category.id_comp, category.assoc, e.hom_inv_id, category.comp_id]
intro X Y Z f g hf hg X' Z' i₁ i₂ f' H
have := pullback.lift_fst _ _ (H.w.trans (category.assoc _ _ _).symm)
rw [← this] at H⊢
apply hP _ _ _ (hg _ _ _ <| is_pullback.of_has_pullback _ _)
exact hf _ _ _ (H.of_right (pullback.lift_snd _ _ _) (is_pullback.of_has_pullback i₂ g))
rw [category.comp_id, category.id_comp]
delta morphism_property.injective
rw [coe_comp]
exact hg.comp hf
delta morphism_property.surjective
rw [coe_comp]
exact hg.comp hf
delta morphism_property.bijective
rw [coe_comp]
exact hg.comp hf
infer_instance
simp
simp [types_comp]
simp [types_id]
constructor
· intro H x x' h
    skip
    rw [← hom_of_element_eq_iff] at h⊢
    exact (cancel_mono f).mp h
· exact fun H => ⟨fun Z => H.compLeft⟩
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp [← nat_iso.naturality_1 α]
rw [← nat_iso.naturality_1 α.symm, h, nat_iso.naturality_1 α.symm]
dsimp [curry_obj]
rw [nat_trans.naturality]
simp
cases F <;> rfl
cases F <;> rfl
erw [functor.id_map, category.id_comp]
erw [functor.id_map, category.id_comp]
erw [functor.id_map, category.id_comp]
simp [← G.map_comp]
simp [← G.map_comp]
simp [← G.map_comp]
apply hasFiniteLimitsOfHasFiniteLimitsOfSize.{v₁} (structured_arrow X F)
intro J sJ fJ
skip
constructor
simp
simp [ ← h₁ ]
simp [ ← h₂ ]
intro j
                injection c₀.π.naturality bicone_hom.left j
unfold cone.extend congr
apply hc.uniq c.extend _ tidy
          _ = hc.lift c.extend g₂.right
congr
simp
rw [ this ]
simp
apply preserves_finite_limits_of_flat.uniq F hc
exact h
exact preserves_finite_limits_of_flat.fac F hc s
cases x
unfold preserves_finite_limits_of_flat
dsimp only [preserves_finite_limits_of_preserves_finite_limits_of_size]
congr
apply preservesFiniteLimitsOfPreservesFiniteLimitsOfSize.{u₁}
intros
skip
apply preserves_limit_of_Lan_presesrves_limit
apply preservesFiniteLimitsOfPreservesFiniteLimitsOfSize.{u₁}
intros
skip
apply preserves_limit_of_Lan_presesrves_limit
cases x
unfold preserves_finite_limits_of_flat
dsimp only [preserves_finite_limits_of_preserves_finite_limits_of_size]
congr
cases x
unfold preserves_finite_limits_of_flat
congr
unfold
      CategoryTheory.lanPreservesFiniteLimitsOfPreservesFiniteLimits CategoryTheory.lanPreservesFiniteLimitsOfFlat
dsimp only [preserves_finite_limits_of_preserves_finite_limits_of_size]
congr
dsimp only [functor.left_derived, functor.left_derived_obj_iso]
dsimp
simp only [category.comp_id, category.id_comp]
rw [← homology_functor_map, HomotopyCategory.homology_functor_map_factors]
simp only [← functor.map_comp]
congr 1
apply HomotopyCategory.eq_of_homotopy
apply functor.map_homotopy
apply Homotopy.trans
exact HomotopyCategory.homotopyOutMap _
apply ProjectiveResolution.lift_homotopy f
· simp
· simp [w]
simp [nat_trans.left_derived]
rfl
simp [nat_trans.left_derived]
rw [h]
rw [functor.comp_map, functor.comp_map, ← assoc, naturality, assoc, ← map_comp I, naturality,
      map_comp, assoc]
dsimp
simp
simp
rw [CategoryTheory.Functor.map_id]
rfl
rw [map_comp, ← comp_app]
simp [← nat_trans.comp_app, ← functor.map_comp]
simp [← nat_trans.comp_app, ← functor.map_comp]
simp
simp
rw [comp_map]
exact inferInstance
rw [comp_map]
exact inferInstance
rw [← F.map_comp, hgh, F.map_comp]
rw [← F.map_comp, hgh, F.map_comp]
refine' ⟨F.preimage s.section_, _⟩
apply F.map_injective
simp only [map_comp, image_preimage, map_id]
apply split_epi.id
constructor
· intro h
    exact is_split_epi.mk' ((split_epi_equiv F f).invFun h.exists_split_epi.some)
· intro h
    exact is_split_epi.mk' ((split_epi_equiv F f).toFun h.exists_split_epi.some)
refine' ⟨F.preimage s.retraction, _⟩
apply F.map_injective
simp only [map_comp, image_preimage, map_id]
apply split_mono.id
constructor
· intro h
    exact is_split_mono.mk' ((split_mono_equiv F f).invFun h.exists_split_mono.some)
· intro h
    exact is_split_mono.mk' ((split_mono_equiv F f).toFun h.exists_split_mono.some)
constructor
· exact F.epi_of_epi_map
· intro h
    exact F.map_epi f
constructor
· exact F.mono_of_mono_map
· intro h
    exact F.map_mono f
intro
rw [← F.inv.is_split_epi_iff f]
apply is_split_epi_of_epi
intro
rw [adj.has_lifting_property_iff]
infer_instance
erw [← iso.hom_comp_eq_id (e.functor.map_iso (e.unit_iso.app X)), functor_unit_comp]
rfl
erw [← iso.comp_hom_eq_id (e.inverse.map_iso (e.counit_iso.app Y)), unit_inverse_comp]
rfl
dsimp [adjointify_η]
simp
have := ε.hom.naturality (F.map (η.inv.app X))
dsimp at this
rw [this]
clear this
rw [← assoc _ _ (F.map _)]
have := ε.hom.naturality (ε.inv.app <| F.obj X)
dsimp at this
rw [this]
clear this
have := (ε.app <| F.obj X).hom_inv_id
dsimp at this
rw [this]
clear this
rw [id_comp]
have := (F.map_iso <| η.app X).hom_inv_id
dsimp at this
rw [this]
refine' iso.trans e.unit_iso _
exact iso_whisker_left e.functor (iso_whisker_right f.unit_iso e.inverse)
refine' iso.trans _ f.counit_iso
exact iso_whisker_left f.inverse (iso_whisker_right e.counit_iso f.functor)
  -- We wouldn't have needed to give this proof if we'd used `equivalence.mk`,
  -- but we choose to avoid using that here, for the sake of good structure projection `simp`
  -- lemmas.
dsimp
rw [← f.functor.map_comp_assoc, e.functor.map_comp, ← counit_inv_app_functor, fun_inv_map,
      iso.inv_hom_id_app_assoc, assoc, iso.inv_hom_id_app, counit_app_functor, ← functor.map_comp]
erw [comp_id, iso.hom_inv_id_app, Functor.map_id]
simp only [cancel_mono]
simp only [cancel_mono]
simp only [cancel_mono]
simp only [cancel_mono]
simp only [← category.assoc, cancel_mono]
simp only [← category.assoc, cancel_mono]
simp only [← category.assoc, cancel_mono]
simp only [← category.assoc, cancel_mono]
cases E
congr
cases E
congr
erw [nat_iso.naturality_2]
rfl
erw [nat_iso.naturality_1]
rfl
rw [of_iso_trans, iso.self_symm_id, of_iso_refl]
rw [of_iso_trans, iso.symm_self_id, of_iso_refl]
apply F.map_injective <;> simp
simp
rw [← cancel_mono (hT.from A)]
apply hT.hom_ext
rw [← cancel_mono (terminal.from A)]
apply Subsingleton.elim
simp
simp [← cancel_epi (diag A)]
rw [← cancel_mono X.arrow]
apply Subsingleton.elim
rw [category.assoc, category.assoc, β.hom_inv_id, α.hom_inv_id_assoc, category.comp_id]
rw [category.assoc, category.assoc, β.inv_hom_id, α.inv_hom_id_assoc, category.comp_id]
simp
simp
simp
rw [conj_apply, iso.refl_inv, iso.refl_hom, category.id_comp, category.comp_id]
rw [← trans_conj, α.self_symm_id, refl_conj]
simp only [conj_Aut_apply, iso.trans_symm, iso.trans_assoc]
simp
simp only [iso.conj_Aut_apply, F.map_iso_trans, F.map_iso_symm]
decide
intro X Y f
dsimp
simp only [ihom.coev_naturality, closed_ihom_obj_map, monoidal.tensor_obj_map]
dsimp
rw [coev_app_comp_pre_app_assoc, ← functor.map_comp]
simp
intro X Y f
dsimp
simp only [closed_ihom_obj_map, pre_comm_ihom_map]
rw [← tensor_id_comp_id_tensor, id_tensor_comp]
simp
infer_instance
dsimp
rw [left_unitor_naturality_assoc]
rw [uncurry_eq, tensor_id, id_comp]
rw [uncurry_eq, id_tensor_pre_app_comp_ev]
simp only [pre, Functor.map_id]
dsimp
simp
rw [pre, pre, pre, transfer_nat_trans_self_comp, (tensoring_left C).map_comp]
simp
apply exponential_ideal.mk'
intro B A
exact ⟨_, ⟨(h A).app B⟩⟩
dsimp
rw [← curry_natural_left, curry_eq_iff, uncurry_id_eq_ev, ← ir.hom_equiv_naturality_left,
      ir.hom_equiv_apply_eq, assoc, assoc, prod_comparison_natural_assoc, L.map_id, ←
      prod.map_id_comp_assoc, ir.left_triangle_components, prod.map_id_id, id_comp]
apply is_iso.hom_inv_id_assoc
dsimp [bijection]
rw [comp_id, comp_id, comp_id, i.map_id, comp_id, unit_comp_partial_bijective_symm_apply,
    unit_comp_partial_bijective_symm_apply, uncurry_natural_left, uncurry_curry,
    uncurry_natural_left, uncurry_curry, prod.lift_map_assoc, comp_id, prod.lift_map_assoc, comp_id,
    prod.comp_lift_assoc, prod.lift_snd, prod.lift_fst_assoc, prod.lift_fst_comp_snd_comp, ←
    adjunction.eq_hom_equiv_apply, adjunction.hom_equiv_unit, iso.comp_inv_eq, assoc,
    preserves_limit_pair.iso_hom]
apply prod.hom_ext
· rw [limits.prod.map_fst, assoc, assoc, prod_comparison_fst, ← i.map_comp, prod_comparison_fst]
    apply (adjunction.of_right_adjoint i).Unit.naturality
· rw [limits.prod.map_snd, assoc, assoc, prod_comparison_snd, ← i.map_comp, prod_comparison_snd]
    apply (adjunction.of_right_adjoint i).Unit.naturality
dsimp [bijection]
apply i.map_injective
rw [i.image_preimage, i.map_comp, i.image_preimage, comp_id, comp_id, comp_id, comp_id, comp_id,
    comp_id, adjunction.hom_equiv_naturality_right, ← assoc, curry_natural_right _ (i.map g),
    unit_comp_partial_bijective_natural, uncurry_natural_right, ← assoc, curry_natural_right,
    unit_comp_partial_bijective_natural, uncurry_natural_right, assoc]
rw [← (bijection i _ _ _).Injective.eq_iff, bijection_natural, ← bijection_symm_apply_id,
        Equiv.apply_symm_apply, id_comp]
rw [← bijection_natural, id_comp, ← bijection_symm_apply_id, Equiv.apply_symm_apply]
apply limits.preserves_limit_of_iso_diagram _ (diagram_iso_pair K).symm
apply preserves_limit_pair.of_iso_prod_comparison
apply nat_iso.is_iso_of_is_iso_app _
intro B
dsimp [frobenius_morphism]
infer_instance
rw [uncurry_eq, exp_comparison_ev]
rw [← frobenius_morphism_mate F h] at i
exact @transfer_nat_trans_self_of_iso _ _ _ _ _ i
rw [← frobenius_morphism_mate F h]
infer_instance
rw [uncurry_eq, prod.map_id_id, id_comp]
rw [curry_eq_iff, iso.hom_inv_id_assoc]
simp
rw [uncurry_natural_left, prod.left_unitor_inv_naturality_assoc f]
rw [uncurry_eq, prod_map_pre_app_comp_ev]
simp [pre]
rw [pre, pre, pre, transfer_nat_trans_self_comp, prod.functor.map_comp]
rw [← curry_natural_left, curry_eq_iff, ← cancel_epi (mul_zero t).inv]
· apply t.hom_ext
· infer_instance
· infer_instance
apply coprod.hom_ext
rw [coprod.inl_desc_assoc, comp_id, ← uncurry_natural_left, coprod.inl_desc, uncurry_curry]
rw [coprod.inr_desc_assoc, comp_id, ← uncurry_natural_left, coprod.inr_desc, uncurry_curry]
rw [← uncurry_natural_right, ← eq_curry_iff]
apply coprod.hom_ext
rw [coprod.inl_desc_assoc, ← curry_natural_right, coprod.inl_desc, ← curry_natural_left,
      comp_id]
rw [coprod.inr_desc_assoc, ← curry_natural_right, coprod.inr_desc, ← curry_natural_left,
      comp_id]
apply ULift.fintype
infer_instance
infer_instance
dsimp
simp
dsimp
simp
dsimp
rw [id_comp, comm]
dsimp
rw [comp_id, comm]
dsimp
rw [id_comp, h.comm₃]
dsimp
simp only [rotate_mor₃, comp_neg, neg_comp, ← functor.map_comp, f.comm₁]
dsimp [inv_rotate_mor₁]
simp only [discrete.functor_map_id, id_comp, preadditive.comp_neg, assoc, neg_inj,
      nat_trans.id_app, preadditive.neg_comp]
rw [← functor.map_comp_assoc, ← f.comm₃, functor.map_comp_assoc, μ_naturality_assoc,
      nat_trans.naturality, functor.id_map]
dsimp
simp only [discrete.functor_map_id, id_comp, μ_inv_naturality, category.assoc, nat_trans.id_app,
      unit_of_tensor_iso_unit_inv_app]
erw [ε_naturality_assoc]
rw [comm₂_assoc]
dsimp
simp only [ε_app_obj, eq_to_iso.hom, discrete.functor_map_id, id_comp, eq_to_iso.inv,
      category.assoc, obj_μ_inv_app, functor.map_comp, nat_trans.id_app, obj_ε_app,
      unit_of_tensor_iso_unit_inv_app]
erw [μ_inv_hom_app_assoc]
rfl
dsimp
rw [unit_of_tensor_iso_unit_inv_app, ε_app_obj]
simp only [discrete.functor_map_id, nat_trans.id_app, id_comp, assoc, functor.map_comp,
      obj_μ_app, obj_ε_inv_app, comp_id, μ_inv_hom_app_assoc]
erw [μ_inv_hom_app, μ_inv_hom_app_assoc, category.comp_id]
dsimp
rw [unit_of_tensor_iso_unit_inv_app]
simp only [discrete.functor_map_id, nat_trans.id_app, id_comp, add_neg_equiv_counit_iso_hom,
      eq_to_hom_refl, nat_trans.comp_app, assoc, μ_inv_hom_app_assoc, ε_hom_inv_app]
exact category.comp_id _
dsimp
simp only [discrete.functor_map_id, nat_trans.id_app, id_comp, functor.map_neg,
      functor.map_comp, obj_μ_app, obj_ε_inv_app, comp_id, assoc, μ_naturality_assoc, neg_neg,
      CategoryTheory.Functor.map_id, add_neg_equiv_counit_iso_hom, eq_to_hom_refl,
      nat_trans.comp_app]
erw [μ_inv_hom_app, category.comp_id, obj_zero_map_μ_app]
rw [discrete.functor_map_id, nat_trans.id_app, comp_id]
dsimp
rw [CategoryTheory.Functor.map_id]
simp only [comp_id, add_neg_equiv_counit_iso_inv, eq_to_hom_refl, id_comp, nat_trans.comp_app,
      discrete.functor_map_id, nat_trans.id_app, functor.map_neg, functor.map_comp, obj_μ_app,
      obj_ε_inv_app, assoc, μ_naturality_assoc, neg_neg, μ_inv_hom_app_assoc]
erw [μ_inv_hom_app, category.comp_id, obj_zero_map_μ_app]
simp only [discrete.functor_map_id, nat_trans.id_app, comp_id, ε_hom_inv_app_assoc]
change is_equivalence (triangle_rotation C).Functor
infer_instance
change is_equivalence (triangle_rotation C).inverse
infer_instance
rfl
dsimp
simp only [← F.to_functor.map_comp, f.comm₁]
dsimp
simp only [← F.to_functor.map_comp, f.comm₂]
dsimp
erw [category.assoc, ← F.comm_shift.hom.naturality]
simp only [functor.comp_map, ← F.to_functor.map_comp_assoc, f.comm₃]
rfl
have := h.left_triangle
rw [← is_iso.eq_inv_comp] at this
rw [this]
infer_instance
have := h.right_triangle
rw [← is_iso.eq_inv_comp] at this
rw [this]
infer_instance
have := h.right_triangle
rw [← is_iso.eq_comp_inv] at this
rw [this]
infer_instance
have := h.left_triangle
rw [← is_iso.eq_comp_inv] at this
rw [this]
infer_instance
refine' ⟨(regular_epi.desc' (adj₁.counit.app X) s.π _).1, _, _⟩
· rw [← cancel_epi (adj₁.counit.app (regular_epi.W (adj₁.counit.app X)))]
      rw [← adj₁.counit_naturality_assoc]
      dsimp only [functor.comp_obj]
      rw [← s.condition, ← F.map_comp_assoc, ← U.map_comp, regular_epi.w, U.map_comp,
        F.map_comp_assoc, s.condition, ← adj₁.counit_naturality_assoc]
· apply (regular_epi.desc' (adj₁.counit.app X) s.π _).2
· intro m hm
      rw [← cancel_epi (adj₁.counit.app X)]
      apply hm.trans (regular_epi.desc' (adj₁.counit.app X) s.π _).2.symm
rw [← F'.map_comp, adj₁.right_triangle_components]
apply F'.map_id
dsimp [other_map]
rw [← F'.map_comp_assoc, U.map_comp, adj₁.unit_naturality_assoc,
        adj₁.right_triangle_components, comp_id, adj₂.left_triangle_components]
apply (adj₂.hom_equiv _ _).subtypeEquiv _
intro f
rw [← (adj₂.hom_equiv _ _).Injective.eq_iff, eq_comm, adj₂.hom_equiv_naturality_left,
        other_map, assoc, adj₂.hom_equiv_naturality_left, ← adj₂.counit_naturality,
        adj₂.hom_equiv_naturality_left, adj₂.hom_equiv_unit, adj₂.right_triangle_components,
        comp_id, functor.comp_map, ← U.map_comp, assoc, ← adj₁.counit_naturality,
        adj₂.hom_equiv_unit, adj₂.hom_equiv_unit, F.map_comp, assoc]
rfl
apply (adj₁.hom_equiv _ _).symm.subtypeEquiv
intro g
rw [← (adj₁.hom_equiv _ _).symm.Injective.eq_iff, adj₁.hom_equiv_counit,
        adj₁.hom_equiv_counit, adj₁.hom_equiv_counit, F.map_comp, assoc, U.map_comp, F.map_comp,
        assoc, adj₁.counit_naturality, adj₁.counit_naturality_assoc]
apply eq_comm
refine'
    adjunction.left_adjoint_of_equiv (fun X Y => construct_left_adjoint_equiv R _ adj₁ adj₂ Y X) _
intro X Y Y' g h
rw [construct_left_adjoint_equiv_apply, construct_left_adjoint_equiv_apply, Function.comp_apply,
    Function.comp_apply, Equiv.trans_apply, Equiv.trans_apply, Equiv.trans_apply, Equiv.trans_apply,
    Equiv.symm_apply_eq, Subtype.ext_iff, cofork.is_colimit.hom_iso_natural, Equiv.apply_symm_apply,
    Equiv.subtypeEquiv_apply, Equiv.subtypeEquiv_apply, Equiv.subtypeEquiv_apply,
    Equiv.subtypeEquiv_apply, Subtype.coe_mk, Subtype.coe_mk, Subtype.coe_mk, Subtype.coe_mk, ←
    adj₁.hom_equiv_naturality_right_symm, cofork.is_colimit.hom_iso_natural,
    adj₂.hom_equiv_naturality_right, functor.comp_map]
infer_instance
intro X
simp only [monad.adj_counit]
exact ⟨_, _, _, _, monad.beck_algebra_coequalizer X⟩
let this := adjunction.right_adjoint_of_nat_iso comm
exact adjoint_triangle_lift Q (adjunction.of_right_adjoint V)
let this := adjunction.right_adjoint_of_nat_iso comm
exact monadic_adjoint_triangle_lift V
intro A
refine'
    ⟨PUnit, fun _ => (left_adjoint G).obj A, fun _ => (adjunction.of_right_adjoint G).Unit.app A, _⟩
intro B h
refine' ⟨PUnit.unit, ((adjunction.of_right_adjoint G).homEquiv _ _).symm h, _⟩
rw [← adjunction.hom_equiv_unit, Equiv.apply_symm_apply]
simp
simp
rw [hom_equiv_counit, F.map_comp, assoc, adj.hom_equiv_counit.symm]
rw [← Equiv.eq_symm_apply] <;> simp [-hom_equiv_unit]
rw [hom_equiv_unit, G.map_comp, ← assoc, ← hom_equiv_unit]
rw [Equiv.symm_apply_eq] <;> simp [-hom_equiv_counit]
cases h
simp
cases h
simp
cases h
simp
cases h
simp
rw [← Equiv.eq_symm_apply] <;> simp
rw [Equiv.symm_apply_eq] <;> simp
intros
erw [← adj.hom_equiv_naturality_left, ← adj.hom_equiv_naturality_right]
dsimp
simp
intros
erw [← adj.hom_equiv_naturality_left_symm, ← adj.hom_equiv_naturality_right_symm]
dsimp
simp
erw [← adj.hom_equiv_naturality_right] <;> simp
erw [← adj.hom_equiv_naturality_left_symm] <;> simp
change _
simp
simp
simp
simp
intros <;> rw [Equiv.symm_apply_eq, he] <;> simp
rw [Equiv.symm_apply_eq, he, Equiv.apply_symm_apply]
conv => 
      rhs
      rw [assoc, ← he, id_comp, Equiv.apply_symm_apply]
simp
intros
erw [← he' e he, ← Equiv.apply_eq_iff_eq]
simp [(he _ _ _ _ _).symm]
intros <;> rw [Equiv.eq_symm_apply, he] <;> simp
rw [← Equiv.eq_symm_apply, ← he' e he, Equiv.symm_apply_apply]
conv => 
      rhs
      rw [← assoc, he' e he, comp_id, Equiv.symm_apply_apply]
simp
intros <;> rw [Equiv.symm_apply_eq, he] <;> simp
intro X Y Y' g h
erw [← he, Equiv.apply_eq_iff_eq, ← assoc, he' e he, comp_id, Equiv.symm_apply_apply]
simp
simp
erw [← adj.hom_equiv_naturality_left, t.naturality]
dsimp
simp
erw [← adj.hom_equiv_naturality_left_symm, ← adj.hom_equiv_naturality_right_symm, t.naturality]
dsimp
simp
erw [← adj.hom_equiv_naturality_right, ← t.naturality, category.id_comp, category.id_comp]
rfl
erw [← adj.hom_equiv_naturality_right_symm, ← t.naturality, category.id_comp, category.id_comp]
rw [← unit_left_adjoint_uniq_hom adj1 adj2]
rfl
rw [← left_adjoint_uniq_hom_counit adj1 adj2]
rfl
rw [← left_adjoint_uniq_trans adj1 adj2 adj3]
rfl
apply Quiver.Hom.op_inj
exact
    left_adjoint_uniq_trans_app (op_adjoint_op_of_adjoint _ _ adj3)
      (op_adjoint_op_of_adjoint _ _ adj2) (op_adjoint_op_of_adjoint _ _ adj1) (Opposite.op x)
delta right_adjoint_uniq
simp
rw [← cancel_mono (i.map ((of_right_adjoint i).counit.app ((left_adjoint i).obj X))), ←
    i.map_comp]
simp
rw [← comp_hom_eq_id]
apply (of_right_adjoint i).right_triangle_components
rw [this]
infer_instance
simp [unit_comp_partial_bijective_aux]
simp [unit_comp_partial_bijective, unit_comp_partial_bijective_aux_symm_apply]
simp
rw [← Equiv.eq_symm_apply, unit_comp_partial_bijective_symm_natural A h, Equiv.symm_apply_apply]
intro X Y f
dsimp
simp only [is_iso.eq_inv_comp, is_iso.comp_inv_eq, category.assoc]
exact ((of_right_adjoint i).counit.naturality _).symm
intro X Y f
dsimp
rw [is_iso.comp_inv_eq, assoc]
have h := ((of_right_adjoint i).Unit.naturality f).symm
rw [functor.id_map] at h
erw [← h, is_iso.inv_hom_id_assoc, functor.comp_map]
dsimp
simp
intros
dsimp
simp
constructor
· intro h c
    exact (inferInstance : mono (((evaluation _ _).obj c).map η))
· intro _
    apply nat_trans.mono_of_mono_app
dsimp
simp
intros
dsimp
simp
constructor
· intro h c
    exact (inferInstance : epi (((evaluation _ _).obj c).map η))
· intros
    apply nat_trans.epi_of_epi_app
dsimp
rw [assoc, ← R₂.map_comp, assoc, ← H.map_comp, ← adj₁.counit_naturality, H.map_comp, ←
          functor.comp_map L₁, ← h.naturality_assoc]
simp
dsimp
rw [← L₂.map_comp_assoc, ← G.map_comp_assoc, ← adj₁.unit_naturality, G.map_comp_assoc, ←
          functor.comp_map, h.naturality]
simp
erw [functor.map_comp]
simp
dsimp [transfer_nat_trans]
rw [← adj₂.unit_naturality_assoc, ← R₂.map_comp, ← functor.comp_map G L₂, f.naturality_assoc,
    functor.comp_map, ← H.map_comp]
dsimp
simp
rw [Equiv.symm_apply_eq]
simp
dsimp [transfer_nat_trans_self, transfer_nat_trans, adjunction.id]
simp only [comp_id, id_comp]
dsimp [transfer_nat_trans_self, transfer_nat_trans, adjunction.id]
simp only [comp_id, id_comp]
rw [Equiv.eq_symm_apply, ← transfer_nat_trans_self_comp _ adj₂]
simp
rw [transfer_nat_trans_self_comp, gf, transfer_nat_trans_self_id]
rw [transfer_nat_trans_self_symm_comp, gf, transfer_nat_trans_self_symm_id]
simp
simp
simp
simp
let B' : structured_arrow A G :=
      { right := B
        Hom := f }
apply (comma_morphism.w (initial.to B')).symm.trans (category.id_comp _)
simp
rw [← Equiv.eq_symm_apply]
simp
simp
rw [Set.mem_def, sieve.pullback_arrows_comm]
apply J.pullback_stable f hR
simp
simp
cases J₁
cases J₂
congr
apply h
apply J.transitive sjx R fun Y f hf => _
apply covering_of_eq_top
rw [← top_le_iff, ← S.pullback_eq_top_of_mem hf]
apply sieve.pullback_monotone _ Hss
apply J.transitive rj _ fun Y f Hf => _
rw [sieve.pullback_inter, R.pullback_eq_top_of_mem Hf]
simp [sj]
simp [covers_iff]
rw [covers, (sieve.pullback_eq_top_iff_mem f).1 hf]
apply J.top_mem
rw [covers_iff] at h⊢
simp [h, sieve.pullback_comp]
rw [Set.mem_singleton_iff] at hf⊢
simp [hf]
simp
simp
simp
refine' @IsGlb.of_image _ _ _ _ sieves _ _ _ _
· intros
    rfl
· exact is_glb_Inf _
apply le_antisymm
· exact @CompleteLattice.le_top _ (completeLatticeOfInf _ is_glb_Inf) (discrete C)
· intro X S hS
        apply Set.mem_univ
apply le_antisymm
· intro X S hS
        rw [trivial_covering] at hS
        apply covering_of_eq_top _ hS
· refine' @CompleteLattice.bot_le _ (completeLatticeOfInf _ is_glb_Inf) (trivial C)
rw [covers_iff, bot_covering, ← sieve.pullback_eq_top_iff_mem]
simp [covers_iff]
simp [reassoc_of I.w]
simp
simp
intro I
dsimp [index]
simp only [← P.map_comp, ← op_comp, I.w]
intro I
dsimp only [index, relation.fst, relation.snd]
simp only [← P.map_comp, ← op_comp, I.w]
rw [← pretopology_of_grothendieck]
apply (pretopology.gi (opens T)).l_u_eq
constructor
· intro t Y₁ Y₂ f₁ f₂ hf₁ hf₂
    apply t
    apply pullback.condition
· intro t Y₁ Y₂ Z g₁ g₂ f₁ f₂ hf₁ hf₂ comm
    rw [← pullback.lift_fst _ _ comm, op_comp, functor_to_types.map_comp_apply, t hf₁ hf₂, ←
      functor_to_types.map_comp_apply, ← op_comp, pullback.lift_snd]
rw [← extend_restrict t₁, ← extend_restrict t₂]
congr
exact h
simp only [← F.map_comp, Eq]
intro Y f hf
dsimp [family_of_elements.sieve_extend]
rw [← ht _, ← functor_to_types.map_comp_apply, ← op_comp, hf.some_spec.some_spec.some_spec.2]
constructor
· intro h x t₁ t₂ ht₁ ht₂
    apply h (x.restrict (le_generate R)) t₁ t₂ _ _
    · exact is_amalgamation_restrict _ x t₁ ht₁
    · exact is_amalgamation_restrict _ x t₂ ht₂
· intro h x t₁ t₂ ht₁ ht₂
    apply h x.sieve_extend
    · exact is_amalgamation_sieve_extend x t₁ ht₁
    · exact is_amalgamation_sieve_extend x t₂ ht₂
simp
simp
refine' ⟨fun Y f hf => _, _⟩
· apply α.app (op Y) ⟨_, hf⟩
· rw [compatible_iff_sieve_compatible]
      intro Y Z f g hf
      dsimp
      rw [← functor_to_types.naturality _ _ α g.op]
      rfl
rw [is_separated_for, ← forall_and]
apply forall_congr'
intro x
constructor
· intro z hx
    exact exists_unique_of_exists_of_unique (z.2 hx) z.1
· intro h
    refine' ⟨_, ExistsUnique.exists ∘ h⟩
    intro t₁ t₂ ht₁ ht₂
    apply (h _).unique ht₁ ht₂
    exact is_compatible_of_exists_amalgamation x ⟨_, ht₂⟩
rw [← is_separated_for_and_exists_is_amalgamation_iff_sheaf_for]
exact And.intro t
simp
simp [is_sheaf_for_top_sieve]
rw [sieve.functor_pushforward_comp]
exact hG.cover_preserve (hF.cover_preserve hS)
simp [Eq]
constructor
simp
erw [ ← c'.π.app left . w ]
simp
erw [ ← c'.π.app right . w ]
simp
simp
simp
simp
simp [hf]
simp
simp [g]
simp [sieve.ext_iff]
simp [sieve.ext_iff]
simp [sieve.ext_iff]
rw [← id_mem_iff_eq_top, pullback_apply, id_comp]
simp [k]
simp [z]
rw [← GaloisConnection f]
apply pushforward_le_bind_of_mem
unfold presieve.functor_pullback
rw [F.map_comp]
exact R.downward_closed hf (F.map g)
simp
simp
simp
simp
simp
rw [← op_comp]
congr 2
exact funext fun x => congr_arg f (Classical.choose_spec hf x).symm
constructor
· intro h
    apply le_antisymm
    · intro Y f hf
      rw [← J₁.covers_iff_mem_of_closed h]
      apply hf
    · apply J₁.le_close
· intro e
    rw [← e]
    apply J₁.close_is_closed
apply le_antisymm
· refine' J₁.le_close_of_is_closed (sieve.pullback_monotone _ (J₁.le_close S)) _
    apply J₁.is_closed_pullback _ _ (J₁.close_is_closed _)
· intro Z g hg
    change _ ∈ J₁ _
    rw [← sieve.pullback_comp]
    apply hg
intro Z g hg
apply congr_arg Subtype.val ((hM₂ g hg).trans (hN₂ g hg).symm)
intro Y f hf
trivial
rw [Subtype.ext_iff] at this
exact this
rw [Set.mem_setOf_eq] at hS
rw [Set.mem_setOf_eq, hc, hS, sieve.pullback_top]
rw [Set.mem_setOf_eq] at hS
rw [Set.mem_setOf_eq, ← (c X).idempotent, eq_top_iff, ← hS]
apply (c X).Monotone fun Y f hf => _
rw [sieve.pullback_eq_top_iff_mem, ← hc]
apply hR hf
refine' J.plus_functor_whisker_left_iso _
dsimp [sheafification_whisker_left_iso, sheafify_comp_iso]
rw [category.comp_id]
dsimp [sheafification_whisker_left_iso, sheafify_comp_iso]
erw [category.id_comp]
refine' functor.associator _ _ _
dsimp [sheafification_whisker_right_iso, sheafify_comp_iso]
simp only [category.id_comp, category.comp_id]
erw [category.id_comp]
dsimp [sheafification_whisker_right_iso, sheafify_comp_iso]
simp only [category.id_comp, category.comp_id]
erw [category.id_comp]
rw [iso.comp_inv_eq]
simp
apply J.sheafify_lift_unique
rw [iso.comp_inv_eq]
simp
intro a b f
dsimp
rw [category.id_comp, category.assoc, ← E.w f]
dsimp [diagram_nat_trans]
simp only [multiequalizer.lift_ι, category.assoc]
apply preservesFiniteLimitsOfPreservesFiniteLimitsOfSize.{max v u}
intros
skip
infer_instance
rw [category.assoc, ← e]
simp
apply nat_iso.is_iso_of_is_iso_app
  apply as_iso (sheaf_hom H i.hom)
intro Y f H Y₁ Y₂ Z g₁ g₂ f₁ f₂ hf₁ hf₂ comm
apply hs
apply reassoc_of comm
rw [sieve.pullback_top]
exact presieve.is_sheaf_for_top_sieve P
rw [← pullback_comp]
apply hS
rw [op_comp, functor_to_types.map_comp_apply]
exact G.map _ hi
rw [← this]
exact ((hG _ hs).amalgamate _ (G.family_of_elements_compatible s)).2
simp only [category.assoc, h₂, e]
rw [← G.eq_sheafify_iff h]
change _ ↔ G.sheafify J ≤ G
exact ⟨Eq.ge, (G.le_sheafify J).antisymm⟩
rw [is_sheaf_iff_is_sheaf_of_type]
apply subpresheaf.sheafify_is_sheaf
rw [← is_sheaf_iff_is_sheaf_of_type]
exact F'.2
dsimp
infer_instance
change K _ _
rw [sieve.functor_pushforward_top]
exact K.top_mem _
simp
intro i
simp only [category.assoc]
erw [← (E.π.app k).naturality, ← (E.π.app k).naturality]
dsimp
simp only [← category.assoc]
congr 1
apply S.condition
rw [presheaf.is_sheaf_iff_multifork]
intro X S
exact ⟨is_limit_multifork_of_is_limit _ _ hE _ _⟩
dsimp
simp
let hom_sh := whisker_right ((Ran.adjunction A G.op).counit.app ℱ.val) (coyoneda.obj (op X))
have S' := K.pullback_stable Y.hom.unop hS
have hs' := ((hx.pullback Y.3.unop).functorPullback G).compPresheafMap hom_sh
exact (ℱ.2 X _ (hu.cover_lift S')).amalgamate _ hs'
apply is_sheaf_for.is_separated_for _ (pulledback_family ℱ S x Y)
· exact H
· apply get_section_is_amalgamation
· exact ℱ.2 X _ (hu.cover_lift (K.pullback_stable Y.hom.unop hS))
rw [category.id_comp]
simp [reassoc_of I.w]
dsimp
simp only [← comp_apply, ← P.map_comp, ← op_comp, I.w]
let z := (meq.equiv P S).symm x
rw [← equiv_apply]
simp
simp
simp [I.middle_spec]
simp [I.middle_spec]
intro Y f hf
apply sieve.le_pullback_bind _ _ _ I.hf
· cases I
          exact hf
apply is_sheaf_of_sep
intro X S x y
apply sep
dsimp [sheafify_map, sheafify]
simp
dsimp [sheafify_map, sheafify]
simp
dsimp [sheafify_map, sheafify, to_sheafify]
simp
apply is_iso_to_plus_of_is_sheaf J P hP
  haveI
apply functor.map_is_iso
  exact @is_iso.comp_is_iso _ _ _ _ _ (J.to_plus P) ((J.plus_functor D).map (J.to_plus P)) _ _
dsimp only [sheafify_lift, to_sheafify]
simp
intro h
apply plus_lift_unique
apply plus_lift_unique
rw [← category.assoc, ← plus_map_to_plus]
exact h
apply J.sheafify_lift_unique
simp [iso.comp_inv_eq]
apply J.plus_hom_ext _ _ hQ
apply J.plus_hom_ext _ _ hQ
rw [← category.assoc, ← category.assoc, ← plus_map_to_plus]
exact h
apply J.sheafify_lift_unique
rw [← category.assoc, ← J.to_sheafify_naturality, category.assoc, to_sheafify_sheafify_lift]
dsimp
rw [category.assoc]
skip
infer_instance
skip
exact Sheaf.hom.mono_of_presheaf_mono J D f
simp only [subpresheaf.ext_iff, Function.funext_iff, Set.ext_iff, top_subpresheaf_obj,
    Set.top_eq_univ, Set.mem_univ, iff_true_iff]
exact ⟨fun H U => H (unop U), fun H U => H (op U)⟩
simp only [subpresheaf.ext_iff, Function.funext_iff, Set.ext_iff, top_subpresheaf_obj,
    Set.top_eq_univ, Set.mem_univ, iff_true_iff]
exact ⟨fun H U => H (unop U), fun H U => H (op U)⟩
rw [image_sheaf_ι, is_locally_surjective_iff_image_presheaf_sheafify_eq_top',
    subpresheaf.eq_top_iff_is_iso]
exact
    ⟨fun h => @is_iso_of_reflects_iso _ _ (image_sheaf_ι f) (Sheaf_to_presheaf J _) h _, fun h =>
      @functor.map_is_iso _ _ (Sheaf_to_presheaf J _) _ h⟩
apply is_locally_surjective_of_surjective
intro U
apply Function.Bijective.surjective
rw [← is_iso_iff_bijective]
infer_instance
simp [to_image_presheaf_sheafify]
simp [to_image_presheaf_sheafify]
refine' Eq.trans _ (x.2 f.unop.1.Hom g.unop.left f.unop.2)
erw [id_comp]
congr
rw [over.w g.unop]
constructor
· intro hP
    refine' presieve.is_sheaf_iso J _ (hP PUnit)
    exact iso_whisker_left _ coyoneda.punit_iso
refine' _
delta diagram_comp_iso
dsimp
simp
refine' _
delta diagram_comp_iso plus_comp_iso
simp only [is_colimit.desc_cocone_morphism_hom, is_colimit.unique_up_to_iso_hom,
    cocones.forget_map, iso.trans_hom, nat_iso.of_components_hom_app, functor.map_iso_hom, ←
    category.assoc]
erw [(is_colimit_of_preserves F (colimit.is_colimit (J.diagram P (unop X)))).fac]
simp only [category.assoc, has_limit.iso_of_nat_iso_hom_π, iso.symm_hom,
    cover.multicospan_comp_hom_inv_left, eq_to_hom_refl, category.comp_id,
    limit.cone_point_unique_up_to_iso_hom_comp, functor.map_cone_π_app,
    multiequalizer.multifork_π_app_left, multiequalizer.lift_ι, functor.map_comp, eq_self_iff_true,
    category.assoc, iso.trans_hom, iso.cancel_iso_hom_left, nat_iso.of_components_hom_app,
    colimit.cocone_ι, category.assoc, has_colimit.iso_of_nat_iso_ι_hom]
simp [iso.comp_inv_eq]
apply J.plus_lift_unique
simp [iso.comp_inv_eq]
intro i
erw [category.assoc, category.assoc, ← η.naturality, ← η.naturality, ← category.assoc, ←
          category.assoc, multiequalizer.condition]
rfl
simp
simp [← this]
dsimp [plus_lift]
rw [← category.assoc]
rw [iso.comp_inv_eq]
dsimp only [iso_to_plus, as_iso]
rw [to_plus_naturality]
dsimp only [plus_lift]
rw [iso.eq_comp_inv, ← hγ, plus_map_comp]
dsimp
simp
apply plus_lift_unique
rfl
apply J.plus_lift_unique
rw [iso.comp_inv_eq, category.id_comp]
rfl
apply J.plus_lift_unique
rw [← category.assoc, ← J.to_plus_naturality, category.assoc, J.to_plus_plus_lift]
apply Quotient.inductionOn' j
intro k
refine' ⟨⟨k, rfl⟩⟩
intro i hi
apply List.Chain.induction (fun t => zigzag t j₂) _ hl₁ hl₂ _ _ _ (Or.inr hi)
· intro j k
      apply Relation.ReflTransGen.head
· apply Relation.ReflTransGen.refl
  -- Now lift the zigzag from `j₁` to `j₂` in `J` to the same thing in `component j`.
rw [← hX, Quotient.eq']
exact Relation.ReflTransGen.single (Or.inr ⟨f⟩)
induction h
simp
simp [w]
simp [w]
simp [w]
rw [iso.symm_hom, iso.inv_comp_eq, w]
simp [w]
simp [of_le_mk]
simp [of_mk_le]
simp [of_mk_le_mk]
simp [of_le, ← functor.map_comp underlying]
simp [of_mk_le, of_le_mk, of_le, ← functor.map_comp_assoc underlying]
simp [of_mk_le, of_le_mk, of_le, ← functor.map_comp underlying]
simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ← functor.map_comp_assoc underlying]
simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ← functor.map_comp underlying]
simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ← functor.map_comp_assoc underlying]
simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ← functor.map_comp underlying]
simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ← functor.map_comp_assoc underlying]
apply (cancel_mono X.arrow).mp
simp
apply (cancel_mono f).mp
simp
apply Quotient.inductionOn' x
intro f
apply Quotient.sound
exact ⟨mono_over.pullback_id.app f⟩
apply Quotient.inductionOn' x
intro t
apply Quotient.sound
refine' ⟨(mono_over.pullback_comp _ _).app t⟩
apply Quotient.inductionOn' x
intro f
apply Quotient.sound
exact ⟨mono_over.map_id.app f⟩
apply Quotient.inductionOn' x
intro t
apply Quotient.sound
refine' ⟨(mono_over.map_comp _ _).app t⟩
revert g
apply Quotient.ind
intro g'
apply Quotient.sound
exact ⟨(mono_over.pullback_map_self f).app _⟩
revert p
apply Quotient.ind'
intro a
apply Quotient.sound
apply thin_skeleton.equiv_of_both_ways
· refine' mono_over.hom_mk (pullback.lift pullback.fst _ _) (pullback.lift_snd _ _ _)
    change _
rw [h.inv_comp_eq, w]
simp
intro g
apply @pullback.snd_of_mono _ _ _ _ _ _ _ _ _
change mono g.arrow
infer_instance
apply mono_comp g.arrow f
refine' hom_mk e.left _
rw [← cancel_mono f, assoc]
apply w e
simp
simp
dsimp
infer_instance
dsimp
infer_instance
refine' over.hom_mk _ _
refine'
              image.lift
                { i := g.obj.left
                  m := g.arrow
                  e := k.left
                  fac' := over.w k }
apply image.lift_fac
simp [equalizer_subobject_iso]
simp [equalizer_subobject_iso]
rw [← equalizer_subobject_arrow, category.assoc, category.assoc, equalizer.condition]
simp
rw [← subobject.factor_thru_arrow _ _ w, category.assoc, equalizer_subobject_arrow_comp,
      category.assoc]
simp [kernel_subobject_iso]
simp [kernel_subobject_iso]
rw [← kernel_subobject_arrow]
simp only [category.assoc, kernel.condition, comp_zero]
simp
rw [← subobject.factor_thru_arrow _ _ w, category.assoc, kernel_subobject_arrow_comp,
      comp_zero]
dsimp [factor_thru_kernel_subobject]
simp
simp
simp [sq.w]
simp [kernel_subobject_map]
simp [← iso.comp_inv_eq, kernel_map_comp_kernel_subobject_iso_inv]
infer_instance
simp
simp [kernel_subobject_iso_comp]
simp [kernel_subobject_iso_comp]
simp
simp
rw [of_le_mk_le_mk_of_comm (kernel_comp_mono f h).inv]
· infer_instance
· simp
intro A B f g hf hg h
dsimp only [subobject.lift_mk]
refine' subobject.mk_le_mk_of_comm (cokernel.desc f (cokernel.π g) _).op _
· rw [← subobject.of_mk_le_mk_comp h, category.assoc, cokernel.condition, comp_zero]
· exact Quiver.Hom.unop_inj (cokernel.π_desc _ _ _)
simp
simp [image_subobject_iso]
simp [image_subobject_iso]
dsimp [factor_thru_image_subobject]
apply epi_comp
simp [factor_thru_image_subobject, image_subobject_arrow]
simp [h]
simp
simp
rw [← image_subobject_arrow]
simp
simp
rw [of_le_mk_le_mk_of_comm (image.pre_comp h f)]
· infer_instance
· simp
simp [image_subobject_comp_iso]
simp [image_subobject_comp_iso]
simp
simp
simp
simp [w]
simp only [image_subobject_map, category.assoc, image_subobject_arrow']
erw [image.map_ι, ← category.assoc, image_subobject_arrow]
rw [← iso.comp_inv_eq, category.assoc, ← (image_subobject_iso (arrow.mk f).Hom).eq_inv_comp, ←
      image_map_comp_image_subobject_iso_inv] <;>
    rfl
simp [id_comp f]
simp
simp
simp
intro k₁ k₂
refine' hom_mk (pullback.lift k₂.left k₁.left _) _
rw [w k₁, w k₂]
erw [pullback.lift_snd_assoc, w k₁]
refine' Quotient.ind' fun f => _
exact ⟨mono_over.le_top f⟩
rw [← underlying_iso_top_hom]
infer_instance
rw [← of_mk_le_mk_comp h.le, category.comp_id]
exact is_iso.of_iso (iso_of_mk_eq_mk _ _ h)
rw [is_iso_iff_mk_eq_top, mk_arrow]
rw [is_iso_arrow_iff_eq_top]
refine' Quotient.ind' fun f => _
exact ⟨mono_over.bot_le f⟩
simp
simp
simp [h]
simp
simp
apply Quotient.inductionOn' f₂
intro f₂
rfl
revert f₁
apply Quotient.ind'
intro f₁
erw [inf_def, inf_def, inf_eq_map_pullback', inf_eq_map_pullback', ← pullback_comp, ←
    map_pullback pullback.condition (pullback_is_pullback f₁.arrow g), ← pullback_comp,
    pullback.condition]
rfl
revert f₁
apply Quotient.ind'
intro f₁
erw [inf_def, inf_def, inf_eq_map_pullback', inf_eq_map_pullback', ← map_comp]
dsimp
rw [pullback_comp, pullback_map_self]
cases j
· exact h
· apply (cancel_mono ((equivShrink (subobject A)).symm j).arrow).1
        rw [assoc, assoc]
        erw [limit.w (wide_cospan s) (wide_pullback_shape.hom.term j)]
        exact h
simp
simp
dsimp
simp [← iso.eq_inv_comp]
simp
infer_instance
infer_instance
simp [hu]
simp [hu]
erw [category.assoc, over.w h.hom, w]
erw [category.assoc, over.w h.inv, w]
simp
simp
simp
simp
simp [← hu]
apply (cancel_mono P.arrow).mp
simp
simp
simp
simp
simp
refine' subobject.lift (fun P f hf => subobject.mk f.right) _
intro P Q f g hf hg i hi
refine' subobject.mk_eq_mk_of_comm _ _ ((proj S T).mapIso i) _
exact congr_arg comma_morphism.right hi
dsimp
simp [← T.map_comp]
dsimp
simp
simp
intro P Q f g hf hg
refine' ⟨fun h => subobject.mk_le_mk_of_comm _ (ext _ _ _), fun h => _⟩
· refine' hom_mk (subobject.of_mk_le_mk _ _ h) ((cancel_mono (T.map g.right)).1 _)
          simp [← T.map_comp]
·
          simp only [mono_over.mk'_arrow, subobject.of_mk_le_mk_comp, comma.comp_right,
            hom_mk_right]
· refine' subobject.mk_le_mk_of_comm (subobject.of_mk_le_mk _ _ h).right _
          exact congr_arg comma_morphism.right (subobject.of_mk_le_mk_comp h)
dsimp
rw [← category.assoc, ← S.map_comp, ← unop_comp]
simp
dsimp
simp
simp
simp
simp
simp [Aut_mul_def]
infer_instance
infer_instance
apply zero_of_target_iso_zero
dsimp
rfl
cases n <;> infer_instance
cases n
· dsimp
      infer_instance
· dsimp
      infer_instance
dsimp
exact exact_zero_mono _
dsimp
exact exact_of_zero _ _
dsimp
infer_instance
simp [lift_f_zero, P.exact₀.w_assoc]
dsimp [lift_f_zero, lift_f_one]
simp
simp [w]
simp
simp [lift_homotopy_zero_zero]
simp [w]
simp [lift_homotopy_zero_zero]
simp [lift_homotopy_zero_one]
simp [lift_homotopy_zero_succ, w]
simp [g_comm, h_comm]
simp [HomotopyEquiv]
simp [HomotopyEquiv]
rw [← (HomotopyCategory.quotient _ _).map_id]
apply HomotopyCategory.eq_of_homotopy
apply ProjectiveResolution.lift_id_homotopy
rw [← (HomotopyCategory.quotient _ _).map_comp]
apply HomotopyCategory.eq_of_homotopy
apply ProjectiveResolution.lift_comp_homotopy
intros
rw [comp_add, add_comp, α.naturality, β.naturality]
intros
rw [zero_comp, comp_zero]
intros
rw [comp_neg, neg_comp, α.naturality]
intros
rw [comp_sub, sub_comp, α.naturality, β.naturality]
rw [← app_hom_apply, AddMonoidHom.map_sum]
rfl
infer_instance
infer_instance
rw [mono_iff_injective]
exact Option.some_injective X
simp
simp
simp
simp
rw [injective_iff_projective_op, projective.projective_iff_preserves_epimorphisms_coyoneda_obj]
exact functor.preserves_epimorphisms.iso_iff (coyoneda.obj_op_op _)
simp
constructor
all_goals intro H; constructor; intro X; constructor
·
    exact
      F.symm.injective_presentation_of_map_injective_presentation _
        (Nonempty.some (H.presentation (F.inverse.obj X)))
·
    exact
      F.injective_presentation_of_map_injective_presentation X
        (Nonempty.some (H.presentation (F.functor.obj X)))
simp
simp
simp [dite_comp]
simp [comp_dite]
simp [id_apply]
simp [id_apply, h]
change AddCommGroup (Dmatrix M.ι N.ι _)
infer_instance
cases M
rfl
cases M
rfl
rw [iso.inv_comp_eq, ← category.assoc, iso.eq_comp_inv, additive_obj_iso_biproduct_naturality]
intros
simp [Matrix.mul_assoc]
simp [id_apply]
simp [id_apply, h]
dsimp
cases X
congr
infer_instance
dsimp [End]
infer_instance
simp
simp
simp
rw [← kernel.lift_ι f g h, w, limits.comp_zero]
rw [← cokernel.π_desc f g h, w, limits.zero_comp]
rw [← is_iso.eq_inv_comp, limits.comp_zero]
rw [← is_iso.eq_comp_inv, limits.zero_comp]
rw [← sub_eq_zero, ← comp_sub, c.condition]
rw [comp_sub, comp_zero, sub_eq_zero, c.condition]
simp [w]
rw [← sub_eq_zero, ← sub_comp, c.condition]
rw [sub_comp, zero_comp, sub_eq_zero, c.condition]
simp [w]
infer_instance
infer_instance
infer_instance
infer_instance
apply zero_of_source_iso_zero
dsimp
rfl
cases n <;> infer_instance
cases n <;>
      · dsimp
        infer_instance
dsimp
exact exact_epi_zero _
dsimp
exact exact_of_zero _ _
dsimp
infer_instance
erw [← category.comp_id m, ← Total, comp_sum]
apply Finset.sum_congr rfl
intro j m
erw [reassoc_of (h ⟨j⟩)]
cases j
simp only [sum_comp, category.assoc, bicone.to_cone_π_app, b.ι_π, comp_dite]
        -- See note [dsimp, simp].
dsimp
simp
erw [← category.id_comp m, ← Total, sum_comp]
apply Finset.sum_congr rfl
intro j m
erw [category.assoc, h ⟨j⟩]
cases j
simp only [comp_sum, ← category.assoc, bicone.to_cocone_ι_app, b.ι_π, dite_comp]
dsimp
simp
cases j
simp [sum_comp, b.ι_π, comp_dite]
cases j
simp [sum_comp, t.ι_π, dite_comp, comp_dite]
cases nonempty_fintype J <;>
    exact
      has_biproduct.mk
        { Bicone := _
          IsBilimit := bicone_is_bilimit_of_limit_cone_of_is_limit (limit.is_limit _) }
cases nonempty_fintype J <;>
    exact
      has_biproduct.mk
        { Bicone := _
          IsBilimit := bicone_is_bilimit_of_colimit_cocone_of_is_colimit (colimit.is_colimit _) }
simp [biproduct.lift_eq, biproduct.desc_eq, comp_sum, sum_comp, biproduct.ι_π_assoc, comp_dite,
    dite_comp]
erw [← category.comp_id m, ← Total, comp_add, reassoc_of (h ⟨walking_pair.left⟩),
          reassoc_of (h ⟨walking_pair.right⟩)]
erw [← category.id_comp m, ← Total, add_comp, category.assoc, category.assoc,
          h ⟨walking_pair.left⟩, h ⟨walking_pair.right⟩]
refine' binary_fan.is_limit.hom_ext ht _ _ <;> simp
simp
simp
refine' binary_cofan.is_colimit.hom_ext ht _ _ <;> simp
· rw [category.comp_id t.inl]
· rw [category.comp_id t.inr]
simp [biprod.lift_eq, biprod.desc_eq]
apply biprod.hom_ext <;> apply biprod.hom_ext' <;> simp
simp
simp
simp
simp
simp
apply split_epi.id
simp only [binary_bicone_of_is_split_mono_of_cokernel_fst,
        binary_bicone_of_is_split_mono_of_cokernel_inr,
        binary_bicone_of_is_split_mono_of_cokernel_snd,
        split_epi_of_idempotent_of_is_colimit_cofork_section_]
dsimp only [binary_bicone_of_is_split_mono_of_cokernel_X]
rw [is_colimit_cofork_of_cokernel_cofork_desc, is_cokernel_epi_comp_desc]
simp only [binary_bicone_of_is_split_mono_of_cokernel_inl, cofork.is_colimit.π_desc,
        cokernel_cofork_of_cofork_π, cofork.π_of_π, add_sub_cancel'_right]
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
apply split_mono.id
    inl_snd'
simp
simp
simp
simp
simp
simp [biprod.of_components]
simp [biprod.of_components]
simp [biprod.of_components]
simp [biprod.of_components]
dsimp [biprod.of_components]
apply biprod.hom_ext <;> apply biprod.hom_ext' <;>
    simp only [add_comp, comp_add, add_comp_assoc, add_zero, zero_add, biprod.inl_fst,
      biprod.inl_snd, biprod.inr_fst, biprod.inr_snd, biprod.inl_fst_assoc, biprod.inl_snd_assoc,
      biprod.inr_fst_assoc, biprod.inr_snd_assoc, comp_zero, zero_comp, category.comp_id,
      category.assoc]
rw [← w]
infer_instance
simp only [biprod.of_components_eq]
infer_instance
simp [x]
simp [x]
rw [this]
infer_instance
rw [this]
infer_instance
infer_instance
infer_instance
simp [hf']
constructor
all_goals intro H; constructor; intro X; constructor
·
    exact
      F.symm.projective_presentation_of_map_projective_presentation _
        (Nonempty.some (H.presentation (F.inverse.obj X)))
·
    exact
      F.projective_presentation_of_map_projective_presentation X
        (Nonempty.some (H.presentation (F.functor.obj X)))
rw [is_separator_iff_faithful_coyoneda_obj, ← whiskering_preadditive_coyoneda, functor.comp_obj,
    whiskering_right_obj_obj]
exact ⟨fun h => faithful.of_comp _ (forget AddCommGroupCat), fun h => faithful.comp _ _⟩
rw [is_separator_iff_faithful_preadditive_coyoneda, preadditive_coyoneda_obj_2]
exact ⟨fun h => faithful.of_comp _ (forget₂ _ AddCommGroupCat.{v}), fun h => faithful.comp _ _⟩
rw [is_coseparator_iff_faithful_yoneda_obj, ← whiskering_preadditive_yoneda, functor.comp_obj,
    whiskering_right_obj_obj]
exact ⟨fun h => faithful.of_comp _ (forget AddCommGroupCat), fun h => faithful.comp _ _⟩
rw [is_coseparator_iff_faithful_preadditive_yoneda, preadditive_yoneda_obj_2]
exact ⟨fun h => faithful.of_comp _ (forget₂ _ AddCommGroupCat.{v}), fun h => faithful.comp _ _⟩
rw [biprod.add_eq_lift_id_desc, F.map_comp, ← biprod.lift_map_biprod, ←
        biprod.map_biprod_hom_desc, category.assoc, iso.inv_hom_id_assoc, F.map_id,
        biprod.add_eq_lift_id_desc]
apply e.functor.map_injective
simp
simp only [functor.map_add, add_comp, monad.algebra.hom.h, comp_add]
simp only [functor.map_zero, zero_comp, comp_zero]
rw [functor.map_nsmul, nsmul_comp, monad.algebra.hom.h, comp_nsmul]
simp only [functor.map_neg, neg_comp, monad.algebra.hom.h, comp_neg]
simp only [functor.map_sub, sub_comp, monad.algebra.hom.h, comp_sub]
rw [functor.map_zsmul, zsmul_comp, monad.algebra.hom.h, comp_zsmul]
simp only [functor.map_add, comp_add, comonad.coalgebra.hom.h, add_comp]
simp only [functor.map_zero, comp_zero, zero_comp]
rw [functor.map_nsmul, comp_nsmul, comonad.coalgebra.hom.h, nsmul_comp]
simp only [functor.map_neg, comp_neg, comonad.coalgebra.hom.h, neg_comp]
simp only [functor.map_sub, comp_sub, comonad.coalgebra.hom.h, sub_comp]
rw [functor.map_zsmul, comp_zsmul, comonad.coalgebra.hom.h, zsmul_comp]
intro h
apply id_nonzero X
simp only [← is_iso.hom_inv_id f, h, zero_comp]
have p := not_congr (is_iso_iff_nonzero f)
simp only [not_not, Ne.def] at p
refine' p.mp fun _ => h (as_iso f)
infer_instance
rw [h]
simp
simp only [functor.map_add, add_comp, endofunctor.algebra.hom.h, comp_add]
simp only [functor.map_zero, zero_comp, comp_zero]
rw [comp_nsmul, functor.map_nsmul, nsmul_comp, endofunctor.algebra.hom.h]
simp only [functor.map_neg, neg_comp, endofunctor.algebra.hom.h, comp_neg]
simp only [functor.map_sub, sub_comp, endofunctor.algebra.hom.h, comp_sub]
rw [comp_zsmul, functor.map_zsmul, zsmul_comp, endofunctor.algebra.hom.h]
simp only [functor.map_add, comp_add, endofunctor.coalgebra.hom.h, add_comp]
simp only [functor.map_zero, zero_comp, comp_zero]
rw [functor.map_nsmul, comp_nsmul, endofunctor.coalgebra.hom.h, nsmul_comp]
simp only [functor.map_neg, comp_neg, endofunctor.coalgebra.hom.h, neg_comp]
simp only [functor.map_sub, comp_sub, endofunctor.coalgebra.hom.h, sub_comp]
rw [functor.map_zsmul, comp_zsmul, endofunctor.coalgebra.hom.h, zsmul_comp]
simp [h]
simp
simp [h]
rw [← o.matrix_decomposition_comp]
simp
rw [← o.matrix_decomposition_comp]
simp
rw [← comp_app, iso.hom_inv_id]
rfl
rw [← comp_app, iso.inv_hom_id]
rfl
rw [← comp_app, iso.hom_inv_id, ← id_app]
rw [← comp_app, iso.inv_hom_id, ← id_app]
rw [← comp_app, iso.inv_hom_id, ← id_app]
rw [← comp_app, iso.hom_inv_id, ← id_app]
simp only [cancel_epi]
simp only [cancel_epi]
simp only [cancel_mono]
simp only [cancel_mono]
simp only [← category.assoc, cancel_mono]
simp only [← category.assoc, cancel_mono]
simp
simp
simp
rw [← category.assoc, ← naturality, category.assoc, is_iso.hom_inv_id, category.comp_id]
exact fun F₁ F₂ e => ⟨this e, this e.symm⟩
intro
rw [single_obj.id_as_one, mul_right_inv]
intros
rw [single_obj.comp_as_mul, ← mul_assoc, mul_left_inj, mul_assoc, inv_mul_self, mul_one]
apply Equiv.right_inv
apply Equiv.injective
cases f
rfl
cases h
rfl
rw [h]
rw [h]
have eq := arrow.hom.congr_right e.inv_hom_id
dsimp at eq
erw [w_assoc, Eq, category.comp_id]
simp only [← comma.comp_left, is_iso.hom_inv_id, is_iso.inv_hom_id, arrow.id_left,
        eq_self_iff_true, and_self_iff]
simp only [← comma.comp_right, is_iso.hom_inv_id, is_iso.inv_hom_id, arrow.id_right,
        eq_self_iff_true, and_self_iff]
rw [← comma.comp_left, is_iso.hom_inv_id, id_left]
rw [← comma.comp_right, is_iso.hom_inv_id, id_right]
simp only [← category.assoc, is_iso.comp_inv_eq, w]
simp only [w, is_iso.inv_comp_eq]
simp only [iso.inv_hom_id_assoc, arrow.w, arrow.mk_hom]
have w := f.w
simp only [id_map] at w
dsimp
simp only [← F.map_comp, w]
simp
trace
      "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `discrete_cases #[]"
cases g
simp
trace
      "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `discrete_cases #[]"
cases g
simp
trace
      "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `discrete_cases #[]"
rfl
trace
            "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `discrete_cases #[]"
simp
trace
            "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `discrete_cases #[]"
simp
trace
          "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `discrete_cases #[]"
simp [F]
decide
decide
decide
decide
refine' nat_iso.of_components iso.refl _
intro X Y f
dsimp
simp
apply functor.punit_ext
infer_instance
exact is_iso_of_mono_of_epi _
        apply preadditive.epi_of_cokernel_zero
intro h
infer_instance
intro h
exact simple_of_is_simple_order_subobject X
rw [over.mk_hom, ← f.h_assoc]
dsimp
simp
dsimp
simp
rw [under.mk_hom, assoc, ← f.h]
dsimp
simp
refine' nat_iso.of_components (fun X => iso.refl X) fun X Y f => _
change f >=> pure = pure >=> f
simp [functor_norm]
apply is_reflexive_pair.mk' (F.map (adj.Unit.app _)) _ _
· rw [← F.map_comp, ← F.map_id]
    exact congr_arg (fun _ => F.map _) A.unit
· rw [adj.left_triangle_components]
    rfl
refine' (adj.homEquiv _ _).subtypeEquiv _
intro f
rw [← (adj.homEquiv _ _).Injective.eq_iff, adjunction.hom_equiv_naturality_left,
        adj.hom_equiv_unit, adj.hom_equiv_unit, G.map_comp]
dsimp
rw [adj.right_triangle_components_assoc, ← G.map_comp, F.map_comp, category.assoc,
        adj.counit_naturality, adj.left_triangle_components_assoc]
apply eq_comm
change _ = G.map _
apply limits.cofork.is_colimit.hom_ext (beck_coequalizer A)
rw [cofork.is_colimit.π_desc]
dsimp only [beck_cofork_π, unit_cofork_π]
rw [comparison_adjunction_unit_f_aux, ← adj.hom_equiv_naturality_left A.a, coequalizer.condition,
    adj.hom_equiv_naturality_right, adj.hom_equiv_unit, category.assoc]
apply adj.right_triangle_components_assoc
apply coequalizer.hom_ext
change
    coequalizer.π _ _
apply monadic_creates_colimit_of_preserves_colimit _ _
infer_instance
· apply preserves_colimit_of_iso_diagram _ (diagramIsoParallelPair.{v₁} _).symm
    dsimp
    infer_instance
· apply preserves_colimit_of_iso_diagram _ (diagramIsoParallelPair.{v₁} _).symm
    dsimp
    infer_instance
intro X
apply is_iso_of_reflects_iso _ (monad.forget (of_right_adjoint G).toMonad)
· change is_iso (comparison_adjunction.unit.app X).f
      rw [comparison_adjunction_unit_f]
      change
        is_iso
          (is_colimit.cocone_point_unique_up_to_iso (beck_coequalizer X)
              (unit_colimit_of_preserves_coequalizer X)).Hom
      refine' is_iso.of_iso (is_colimit.cocone_point_unique_up_to_iso _ _)
intro A B f g i
apply has_colimit_of_iso (diagramIsoParallelPair.{v₁} _)
change has_coequalizer (G.map f) (G.map g)
infer_instance
apply monadic_of_has_preserves_reflects_G_split_coequalizers _
· infer_instance
· assumption
· assumption
· intro A B f g i
    apply reflects_colimit_of_reflects_isomorphisms
intro X
apply is_iso_of_reflects_iso _ (monad.forget (adjunction.of_right_adjoint G).toMonad)
· change is_iso (comparison_adjunction.unit.app X).f
      rw [comparison_adjunction_unit_f]
      change
        is_iso
          (is_colimit.cocone_point_unique_up_to_iso (beck_coequalizer X)
              (unit_colimit_of_preserves_coequalizer X)).Hom
      apply is_iso.of_iso (is_colimit.cocone_point_unique_up_to_iso _ _)
intro Y
change is_iso (comparison_adjunction.counit.app Y)
rw [comparison_adjunction_counit_app]
change is_iso (is_colimit.cocone_point_unique_up_to_iso _ _).Hom
infer_instance
apply counit_coequalizer_of_reflects_coequalizer _
apply reflects_colimit_of_reflects_isomorphisms
intro X
rfl
  -- `obviously` provides this, but slowly
intro X Y Z f g
rfl
rw [← M.one.id_hcomp_app, ← nat_trans.comp_app, M.mul_one]
rfl
rw [← M.one.hcomp_id_app, ← nat_trans.comp_app, M.one_mul]
rfl
rw [← nat_trans.hcomp_id_app, ← nat_trans.comp_app]
simp
intro X
erw [← nat_trans.comp_app, f.one_hom]
rfl
rw [← T.η.naturality_assoc f, T.left_unit]
apply category.comp_id
simp only [functor.map_comp, category.assoc, monad.assoc]
erw [T.μ.naturality_assoc]
dsimp
simp
rw [U.right_counit_assoc]
dsimp
simp
rw [h.eq_comp_inv, category.assoc, ← w, ← functor.map_comp_assoc]
simp
dsimp
simp [← Y.assoc, ← T.μ.naturality_assoc]
dsimp only [forget_obj, monad_to_functor_eq_coe]
rw [← T.η.naturality_assoc, Y.unit]
apply category.comp_id
rw [is_iso.eq_comp_inv f.f, category.assoc, ← f.h]
simp
dsimp
simp [A.unit]
dsimp
simp [A.assoc]
dsimp
simp
dsimp
simp
dsimp
simp [h]
simp
simp
rw [h.eq_inv_comp, ← reassoc_of w, ← functor.map_comp]
simp
dsimp
simp [← coalgebra.coassoc_assoc]
dsimp
rw [category.assoc, G.ε.naturality, functor.id_map, X.counit_assoc]
rw [is_iso.eq_inv_comp f.f, ← f.h_assoc]
simp
rw [assoc, f.1.naturality_assoc, g.1.naturality]
rw [assoc, f.1.naturality_assoc, g.1.naturality]
simp [← f_η]
rw [← nat_iso.cancel_nat_iso_hom_right f]
simp only [nat_trans.naturality, iso.inv_hom_id_app, assoc, comp_id, f_μ,
          nat_trans.naturality_assoc, iso.inv_hom_id_app_assoc, ← functor.map_comp_assoc]
simp
simp [← f_ε]
rw [← nat_iso.cancel_nat_iso_hom_left f]
simp only [reassoc_of (f_δ X), iso.hom_inv_id_app_assoc, nat_trans.naturality_assoc]
rw [← functor.map_comp, iso.hom_inv_id_app, Functor.map_id]
apply (comp_id _).symm
rw [category.assoc, t.fac, new_cone_π_app, ← T.η.naturality_assoc, functor.id_map,
        (D.obj j).Unit]
dsimp
simp
  -- See library note [dsimp, simp]
rw [category.assoc, category.assoc, t.fac (new_cone D c), new_cone_π_app, ←
        functor.map_comp_assoc, t.fac (new_cone D c), new_cone_π_app, ← T.μ.naturality_assoc,
        (D.obj j).assoc, functor.map_comp, category.assoc]
rfl
dsimp
rw [category.assoc, category.assoc, t.fac, new_cone_π_app, ← functor.map_comp_assoc,
            t.fac, functor.map_cone_π_app]
apply (s.π.app j).h
dsimp
rw [← functor.map_comp_assoc, ← category.assoc, t.fac, commuting, category.assoc, t.fac]
apply algebra.hom.h
infer_instance
infer_instance
apply CategoryTheory.Limits.compPreservesColimitsOfShape _ _
apply (adjunction.left_adjoint_preserves_colimits (adjunction.of_right_adjoint R)).1
infer_instance
dsimp
rw [← R.map_comp]
simp
dsimp
rw [← R.map_comp]
simp
dsimp
rw [← L.map_comp]
simp
dsimp
rw [← L.map_comp]
simp
dsimp
simp
dsimp
simp
dsimp
simp
dsimp
simp
dsimp
rw [← R.map_comp, ← adjunction.counit_naturality, R.map_comp]
rfl
dsimp
rw [← R.map_comp, adjunction.counit_naturality, R.map_comp]
simp
dsimp
rw [← L.map_comp, ← adjunction.unit_naturality, L.map_comp]
rfl
dsimp
rw [← L.map_comp]
simp
simp
dsimp
infer_instance
dsimp only [functor.id_obj]
rw [← (adjunction.of_right_adjoint R).unit_naturality]
dsimp only [functor.comp_obj, adjunction.to_monad_coe]
rw [unit_obj_eq_map_unit, ← functor.map_comp, ← functor.map_comp]
erw [X.unit]
simp
dsimp
infer_instance
dsimp
infer_instance
dsimp
rw [← comp_apply, iso.hom_inv_id, id_apply]
dsimp
rw [← comp_apply, iso.inv_hom_id, id_apply]
subst h
rfl
apply Functor.ext <;> intros
· simp; · rfl
simp
infer_instance
infer_instance
decide
decide
decide
decide
simp
simp
simp
simp
rw [← h.hom_equiv_naturality_left, ← h.hom_equiv_naturality_left, coeq_condition]
simp
infer_instance
infer_instance
decide
decide
decide
decide
simp
simp
simp
simp
rw [← h.hom_equiv_naturality_right_symm, ← h.hom_equiv_naturality_right_symm, eq_condition]
simp
simp
simp
simp
rw [← functor.map_comp, prod_comp, category.comp_id]
rw [← functor.map_comp, prod_comp, category.comp_id]
rw [← functor.map_comp, prod_comp, category.id_comp, category.comp_id]
rw [← functor.map_comp, prod_comp, category.id_comp, category.comp_id]
simp
simp
infer_instance
cases g
cases f
cases Z
cases Y
cases X
simp only [prod_comp, nat_trans.comp_app, functor.map_comp, category.assoc]
rw [← nat_trans.comp_app, nat_trans.naturality, nat_trans.comp_app, category.assoc,
      nat_trans.naturality]
simp
simp
simp
cases X
cases Y
simp only [functor.prod_map, Prod.mk.inj_iff, prod_comp]
constructor <;> rw [naturality]
simp only [functor.comp_map, prod.fst_map, ← prod_comp_fst, α.naturality]
simp only [functor.comp_map, prod.snd_map, ← prod_comp_snd, α.naturality]
simp
simp
infer_instance
infer_instance
subst h
rw [eq_to_hom_refl, eq_to_hom_refl]
rfl
dsimp
rw [← comp_f, iso.hom_inv_id, id_f]
dsimp
rw [← comp_f, iso.inv_hom_id, id_f]
dsimp
rw [← functor.map_iso_inv, iso.comp_inv_eq, category.assoc, iso.eq_inv_comp,
        functor.map_iso_hom, hf]
rw [functor.map_comp, category.assoc, shift_comm_hom_comp_assoc, ← functor.map_comp_assoc,
          X.d_squared, functor.map_zero, zero_comp]
dsimp
rw [category.assoc, shift_comm_hom_comp, ← functor.map_comp_assoc, f.comm,
          functor.map_comp_assoc]
infer_instance
infer_instance
simp
rw [reassoc_of comm]
unfold app
rw [← category.assoc, over.coe_hom]
simp [comm]
infer_instance
infer_instance
rw [hf, over.coe_hom, has_zero_morphisms.comp_zero, has_zero_morphisms.comp_zero]
rw [← pseudo_zero_aux P a]
exact Quotient.eq
rw [pseudo_zero_def, pseudo_apply_mk]
simp
rw [pseudo_zero_def, pseudo_apply_mk]
simp
simp [h]
simp only [category.assoc]
exact comm
rw [← apply_zero f] at ha
exact h ha
infer_instance
infer_instance
rw [category.id_comp, ← pullback.condition, app_hom, over.coe_hom]
rw [← hp] at hpbar
exact hpbar
dsimp at comm
rw [category.assoc, comm]
apply category.comp_id
rw [← comp_apply, h.w]
exact zero_apply _ _
infer_instance
infer_instance
rw [abelian.image.fac]
rw [← category.assoc, pullback.condition]
rw [category.assoc]
congr
simp [over_coe_def, pseudo_apply_mk, over.coe_hom, h]
rw [comp_apply, h₁ a]
simp only [category.assoc, abelian.image.fac]
exact comm
dsimp at comm
simp [sub_eq_zero.2 comm]
infer_instance
simp [sub_eq_add_neg, this]
simp only [category.assoc]
exact comm
infer_instance
infer_instance
dsimp only [functor.right_derived, functor.right_derived_obj_iso]
dsimp
simp only [category.comp_id, category.id_comp]
rw [← homology_functor_map, HomotopyCategory.homology_functor_map_factors]
simp only [← functor.map_comp]
congr 1
apply HomotopyCategory.eq_of_homotopy
apply functor.map_homotopy
apply Homotopy.trans
exact HomotopyCategory.homotopyOutMap _
apply InjectiveResolution.desc_homotopy f
· simp
· simp only [InjectiveResolution.homotopy_equiv_hom_ι_assoc]
    rw [← category.assoc, w, category.assoc]
    simp only [InjectiveResolution.homotopy_equiv_inv_ι]
simp [nat_trans.right_derived]
rfl
simp [nat_trans.right_derived]
simp [← functor.map_comp, ex.w]
simp
rw [iso.refl_hom, category.id_comp, iso.symm_hom, HomologicalComplex.d_from_eq] <;> congr
simp
have : (ComplexShape.up ℕ).Rel 0 1 := rfl
rw [category.assoc, cokernel.π_desc, HomologicalComplex.d_from_eq _ this,
          map_homological_complex_obj_d, ← category.assoc, ← functor.map_comp]
simp only [InjectiveResolution.ι_f_zero_comp_complex_d, functor.map_zero, zero_comp]
simp
dsimp
simp only [category.comp_id]
exact (kernel_comparison_comp_ι _ ((evaluation C D).obj X)).symm
apply (cancel_mono (preserves_cokernel.iso ((evaluation C D).obj X) α).inv).1
simp only [category.assoc, iso.hom_inv_id]
dsimp
simp only [category.id_comp, category.comp_id]
exact (π_comp_cokernel_comparison _ ((evaluation C D).obj X)).symm
simp only [coimage_image_comparison_app, iso.hom_inv_id_assoc, iso.hom_inv_id, category.assoc,
    category.comp_id]
intros
rw [coimage_image_comparison_app']
infer_instance
rw [← comp_apply, ← comm₃, comp_apply]
rw [hc]
rw [← comp_apply, comm₂, comp_apply]
rw [hb]
rw [← comp_apply, ← comm₁, comp_apply]
rw [ha]
rw [this]
rw [reassoc_of comm₁]
rw [hβr]
simp
simp
rw [← reassoc_of comm₂]
rw [← pushout.condition]
rw [reassoc_of hβr]
simp
simp
rw [← category.assoc, pushout.condition, category.assoc]
rw [reassoc_of comm₃]
rw [pushout.condition, category.assoc]
rw [hzv]
apply mono_of_epi_of_mono_of_mono comm₁ comm₂ comm₃ hfg hgh hf'g' <;> infer_instance
apply epi_of_epi_of_epi_of_mono comm₂ comm₃ comm₄ hhi hg'h' hh'i' <;> infer_instance
rw [injective_iff_preserves_epimorphisms_preadditive_yoneda_obj']
infer_instance
simp
simp
simp [coimage_image_comparison]
simp
apply limits.equalizer.hom_ext
simp
simp
apply (pseudoelement.pseudo_exact_of_exact exact_kernel_ι).2 _ this
dsimp [π', desc']
simp
dsimp [ι, lift]
simp
dsimp [π']
simp
dsimp [ι]
simp
dsimp [π', ι, homologyIsoKernelDesc]
simp
dsimp [π', homologyIsoCokernelLift]
simp only [← category.assoc]
rw [iso.comp_inv_eq]
dsimp [π, homologyIsoCokernelImageToKernel']
simp
simp [h, β.w.symm]
simp
simp only [kernel.lift_ι_assoc, ← h]
erw [← reassoc_of α.w]
simp
simp [h]
simp only [kernel.lift_ι_assoc]
erw [← reassoc_of α.w]
simp
simp [h, β.w.symm]
intro X Y f
dsimp
rw [← iso.inv_comp_eq, ← category.assoc, ← iso.eq_comp_inv]
refine' coequalizer.hom_ext _
dsimp [homology_iso]
simp only [homology.map, ← category.assoc, cokernel.π_desc]
simp only [category.assoc, cokernel_comparison_map_desc, cokernel.π_desc,
        π_comp_cokernel_comparison, ← F.map_comp]
erw [← kernel_subobject_iso_comp_kernel_map_assoc]
simp only [HomologicalComplex.Hom.sq_from_right, HomologicalComplex.Hom.sq_from_left,
        F.map_homological_complex_map_f, F.map_comp]
dsimp only [HomologicalComplex.dFrom, HomologicalComplex.Hom.next]
dsimp
rw [kernel_map_comp_preserves_kernel_iso_inv_assoc, ← F.map_comp_assoc, ←
        kernel_map_comp_kernel_subobject_iso_inv]
any_goals simp
rw [image_mono_factorisation_e']
exact is_iso.comp_is_iso
dsimp
infer_instance
simp
infer_instance
infer_instance
infer_instance
infer_instance
simp [h]
simp [h]
infer_instance
infer_instance
infer_instance
infer_instance
rw [biprod.lift_desc, comp_neg, pullback.condition, add_right_neg]
rw [category.assoc, category.assoc, ← comp_sub, sub_eq_add_neg, ← comp_neg, ←
            biprod.desc_eq, kernel_fork.condition s]
rw [biprod.lift_desc, neg_comp, pushout.condition, add_right_neg]
rw [← category.assoc, ← category.assoc, ← sub_comp, sub_eq_add_neg, ← neg_comp, ←
            biprod.lift_eq, cofork.condition s, zero_comp]
assumption
rw [biprod.inl_desc]
rw [category.assoc, hd]
rw [biprod.inr_desc]
rw [← hd]
rw [this]
rw [← category.assoc]
assumption
rw [biprod.inr_desc]
rw [category.assoc, hd]
rw [biprod.inl_desc]
rw [← hd]
rw [this]
rw [← category.assoc]
apply epi_fst_of_is_limit _ _ (pullback_cone.is_limit_of_factors f g g₂ f' g₁ hf hg t ht)
rw [biprod.lift_fst]
rw [← category.assoc, hd]
rw [biprod.lift_snd]
rw [← hd]
rw [this]
rw [category.assoc]
rw [biprod.lift_snd]
rw [← category.assoc, hd]
rw [biprod.lift_fst]
rw [← hd]
rw [this]
rw [category.assoc]
apply mono_inl_of_is_colimit _ _ (pushout_cocone.is_colimit_of_factors _ _ _ _ _ hf hg t ht)
infer_instance
infer_instance
infer_instance
simp only [unop_comp, Quiver.Hom.unop_op, comp_epi_desc]
let u := kernel.ι g
rw [← category.assoc, kernel.condition]
rw [category.assoc, hs, category.id_comp]
let u := p
rw [← category.assoc, hu.w]
rw [category.assoc, cokernel.condition]
rw [← category.assoc, hs, category.comp_id]
rw [category.assoc, hx]
rw [← category.assoc, hz]
rw [cokernel.condition_assoc, zero_comp]
rw [← category.assoc, is_iso.hom_inv_id]
simp
rw [iso.symm_hom, as_iso_inv]
simp
rw [lift_σ, category.comp_id]
rw [lift_map_assoc]
rw [← hg, cokernel_cofork.π_of_π]
rw [← category.assoc, lift_σ, category.id_comp]
simp
rw [sub_def, ← category.comp_id a, ← prod.comp_lift, category.assoc, diag_σ, comp_zero]
rw [sub_def, ← lift_sub_lift, sub_def, category.assoc, σ_comp, prod.lift_map_assoc]
rfl
rw [add_def, neg_neg]
rw [add_neg, sub_self]
rw [add_comm, add_neg_self]
rw [add_def, neg_sub', add_neg]
rw [add_def, neg_def, sub_sub_sub, sub_zero]
rw [add_def, neg_def, sub_self, sub_zero]
rw [sub_def, ← category.assoc, prod.comp_lift, sub_def]
rw [sub_def, category.assoc, σ_comp, ← category.assoc, prod.lift_map, sub_def]
rw [add_def, comp_sub, neg_def, comp_sub, comp_zero, add_def, neg_def]
rw [add_def, sub_comp, neg_def, sub_comp, zero_comp, add_def, neg_def]
simp [← category.assoc, desc_f_zero]
simp [desc_f_zero, desc_f_one]
simp [← category.assoc, w]
simp
simp [desc_homotopy_zero_zero, ← category.assoc]
rw [w]
simp only [add_sub_cancel]
simp [desc_homotopy_zero_zero]
simp [desc_homotopy_zero_one]
simp only [w, add_comm]
simp [desc_homotopy_zero_succ, w]
simp [g_comm, h_comm]
simp [HomotopyEquiv]
simp [HomotopyEquiv]
rw [← (HomotopyCategory.quotient _ _).map_id]
apply HomotopyCategory.eq_of_homotopy
apply InjectiveResolution.desc_id_homotopy
rw [← (HomotopyCategory.quotient _ _).map_comp]
apply HomotopyCategory.eq_of_homotopy
apply InjectiveResolution.desc_comp_homotopy
simp
rw [category.assoc, kernel.condition]
simp only [of_cocomplex_d, eq_self_iff_true, eq_to_hom_refl, category.comp_id,
            dite_eq_ite, if_true, comp_zero]
exact (exact_f_d (injective.ι Z)).w
simp
rw [← category.assoc, cokernel.condition]
rw [projective_iff_preserves_epimorphisms_preadditive_coyoneda_obj']
infer_instance
simp
exact (exact_d_f (projective.π Z)).w.symm
infer_instance
simp [← functor.map_comp, ex.w]
simp
simp
simp
refine'
    (as_iso (cokernel.desc _ _ (exact_of_map_projective_resolution F P).w)).inv
simp
simp
exact as_iso (imageToKernel _ _ h.w)
      exact is_iso_of_mono_of_epi _
    · simp
  · apply exact_of_image_eq_kernel
constructor
· intro h
    exact ⟨h.1, fork_ι_comp_cofork_π f g h cg cf⟩
· rw [exact_iff]
    refine' fun h => ⟨h.1, _⟩
    apply zero_of_epi_comp (is_limit.cone_point_unique_up_to_iso hg (limit.is_limit _)).Hom
    apply zero_of_comp_mono (is_colimit.cocone_point_unique_up_to_iso (colimit.is_colimit _) hf).Hom
    simp [h.2]
simp only [exact_iff, ← F.map_eq_zero_iff, F.map_comp, category.assoc, ←
    kernel_comparison_comp_ι g F, ← π_comp_cokernel_comparison f F]
rw [is_iso.comp_left_eq_zero (kernel_comparison g F), ← category.assoc,
    is_iso.comp_right_eq_zero _ (cokernel_comparison f F)]
rw [← cancel_epi h, ← category.assoc, cokernel_cofork.condition, comp_zero]
rw [← hfg.1, category.assoc]
simp
rw [h]
apply mono_comp
simp
simp
simp
cases j <;> simp
cases j <;> simp
refine' (exact_iff _ _).2 ⟨w, _⟩
have := h.fac (cokernel_cofork.of_π _ (cokernel.condition f)) walking_parallel_pair.one
simp only [cofork.of_π_ι_app] at this
rw [← this, ← category.assoc, kernel.condition, zero_comp]
refine' (exact_iff _ _).2 ⟨w, _⟩
have := h.fac (kernel_fork.of_ι _ (kernel.condition g)) walking_parallel_pair.zero
simp only [fork.of_ι_π_app] at this
rw [← this, category.assoc, cokernel.condition, comp_zero]
simp
simp [ cokernel.π_of_epi ]
simp [← op_comp, h.w]
rw [← is_equivalence.exact_iff _ _ (op_op_equivalence C).inverse]
exact exact.op _ _ e
simp only [← F.map_comp, kernel.condition, CategoryTheory.Functor.map_zero]
simp only [← F.map_comp, cokernel.condition, CategoryTheory.Functor.map_zero]
simp [← L.map_comp, e1.1]
apply preserves_finite_limits_of_map_exact
intro X Y Z f g h
rw [← abelian.coimage.fac g, L.map_comp, exact_comp_mono_iff]
exact
    exact_of_is_cokernel _ _ _ (is_colimit_cofork_map_of_is_colimit' L _ (is_colimit_coimage f g h))
apply preserves_finite_colimits_of_map_exact
intro X Y Z f g h
rw [← abelian.image.fac f, L.map_comp, exact_epi_comp_iff]
exact exact_of_is_kernel _ _ _ (is_limit_fork_map_of_is_limit' L _ (is_limit_image f g h))
intro X Y Z f g
rw [(linear_yoneda R C).map_comp, nat_trans.right_op_comp, nat_trans.left_derived_comp]
rfl
simp only [cokernel.π_desc, cokernel_epi_comp_inv]
simp only [cokernel.π_desc, cokernel_comp_is_iso_inv, iso.hom_inv_id_app_assoc,
            nat_iso.inv_inv_app]
simp
intro X Y f
rw [← coimage_iso_image_hom F G i adj f]
infer_instance
simp [← op_comp]
rw [← f.unop_op, ← unop_comp, f.unop_op]
simp
rw [← f.unop_op, ← unop_comp, f.unop_op]
simp
simp [← op_comp]
simp [cokernel_op_unop]
simp [kernel_op_unop]
simp
simp
dsimp
simp
simp only [cocone.w]
simp
rw [category.comp_id, category.id_comp]
rw [category.assoc, pullback.lift_snd, hg.w]
rw [category.assoc, pullback.lift_snd, pullback.condition]
rw [← this, category.comp_id, pullback.lift_fst]
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
constructor
intros
exact (is_pushout.is_van_kampen_inl _ (types.is_coprod_of_mono f) _ _ _ H.flip).flip
rw [eq_mk f]
simp
rw [eq_mk h]
simp
simp
dsimp
simp
simp [functor.comp_map, ← G.map_comp, ← f.w]
rw [this]
infer_instance
rw [eq_mk f]
simp
rw [eq_mk h]
simp
simp
dsimp
simp
simp [functor.comp_map, ← G.map_comp, ← f.w]
rw [this]
infer_instance
dsimp
rw [← op_comp, ← f.unop.w, functor.const_obj_map]
erw [category.id_comp]
dsimp
rw [← Quiver.Hom.unop_op (F.map (Quiver.Hom.unop f.unop.right)), ← unop_comp, ← F.op_map, ←
          f.unop.w, functor.const_obj_map]
erw [category.id_comp]
dsimp
rw [← op_comp, f.unop.w, functor.const_obj_map]
erw [category.comp_id]
dsimp
rw [← Quiver.Hom.unop_op (F.map f.unop.left.unop), ← unop_comp, ← F.op_map, f.unop.w,
          functor.const_obj_map]
erw [category.comp_id]
simp
simp
dsimp [Quiver.reverse]
simp
simp only [Quiver.reverse, Quiver.HasReverse.reverse', groupoid.inv_eq_inv,
      functor.to_prefunctor_map, functor.map_inv]
infer_instance
infer_instance
infer_instance
have eq₁ := D.t_fac i i j
have eq₂ := (is_iso.eq_comp_inv (D.f i i)).mpr (@pullback.condition _ _ _ _ _ _ (D.f i j) _)
rw [D.t_id, category.comp_id, eq₂] at eq₁
have eq₃ := (is_iso.eq_comp_inv (D.f i i)).mp eq₁
rw [category.assoc, ← pullback.condition, ← category.assoc] at eq₃
exact
    mono.right_cancellation _ _
      ((mono.right_cancellation _ _ eq₃).trans (pullback_symmetry_hom_comp_fst _ _).symm)
rw [← category.assoc, ← D.t_fac]
simp
rw [← category.assoc, ← D.t_fac]
simp
simp
simp
unfold π
infer_instance
rw [D.t_id i]
simp
simp only [category.assoc, iso.hom_inv_id_assoc, ← functor.map_comp_assoc, D.cocycle,
      iso.inv_hom_id, CategoryTheory.Functor.map_id, category.id_comp]
erw [ι_preserves_colimits_iso_hom_assoc]
rw [has_colimit.iso_of_nat_iso_ι_hom]
erw [category.id_comp]
rfl
rw [iso.comp_inv_eq, ι_glued_iso_hom]
refine' { Hom := fun X Y => @hom X Y X.str Y.str
            id := fun X => @bundled_hom.id c hom 𝒞 X X.str
            comp := fun X Y Z f g => @bundled_hom.comp c hom 𝒞 X Y Z X.str Y.str Z.str g f
            comp_id' := _
            id_comp' := _
            assoc' := _ } <;>
        intros <;>
      apply 𝒞.hom_ext <;>
    simp only [𝒞.id_to_fun, 𝒞.comp_to_fun, Function.left_id, Function.right_id]
intros <;> erw [𝒞.comp_to_fun] <;> rfl
intros <;> apply 𝒞.hom_ext
intros <;> apply heq_of_eq <;> apply h_map
intros <;> rfl
intros <;> rfl
intros <;> apply Subtype.eq
infer_instance
rw [← is_iso_iff_bijective]
infer_instance
simp only [has_forget₂.forget_comp]
infer_instance
simp only [has_forget₂.forget_comp]
infer_instance
apply faithful.div_comp
have := has_forget₂.forget_comp
dsimp at this
rw [← this]
exact i'
rw [h.eq_comp_inv, category.assoc, ← w, ← functor.map_comp_assoc]
simp
rw [is_iso.eq_comp_inv f.1, category.assoc, ← f.h]
simp
dsimp
simp
dsimp
simp
dsimp
simp [h]
simp
simp
rw [str_inv, ← (h.to ⟨F.obj A.1, F.map A.str⟩).h, ← F.map_id, ← F.map_comp]
congr
exact left_inv h
rw [h.eq_inv_comp, ← category.assoc, ← w, category.assoc, ← functor.map_comp]
simp only [iso.hom_inv_id, Functor.map_id, category.comp_id]
rw [is_iso.eq_inv_comp f.1, ← category.assoc, ← f.h, category.assoc]
simp
rw [category.assoc, ← α.naturality, ← category.assoc, f.h, category.assoc]
dsimp
simp
dsimp
simp
dsimp
simp [h]
simp
simp
rw [← adjunction.hom_equiv_naturality_right, ← adjunction.hom_equiv_naturality_left, f.h]
rw [← adjunction.hom_equiv_naturality_left_symm, ← adjunction.hom_equiv_naturality_right_symm,
    f.h]
erw [F.map_id, category.id_comp, category.comp_id]
apply (adj.hom_equiv _ _).left_inv A.str
erw [F.map_id, category.id_comp, category.comp_id]
apply ((adj.hom_equiv _ _).left_inv A.str).symm
dsimp
erw [G.map_id, category.id_comp, category.comp_id]
apply (adj.hom_equiv _ _).right_inv V.str
dsimp
rw [G.map_id, category.comp_id, category.id_comp]
apply ((adj.hom_equiv _ _).right_inv V.str).symm
cases p
cases q
simp
simp
simp [eq_whisker h (eq_to_hom p)]
simp
simp [whisker_eq _ h]
cases p
simp
cases q
simp
simp
simp
cases h
rfl
cases h
rfl
cases h
cases h'
simp
subst h
subst h <;> simp
rw [hX]
rw [hY]
rw [hY]
rw [hX]
simp only [← is_iso.iso.inv_hom e, functor.map_inv, h₂, is_iso.inv_comp, inv_eq_to_hom,
    category.assoc]
rw [h]
rw [F.map_comp, G.map_comp]
congr
rw [functor.hext hobj fun _ _ => hmap]
dsimp
congr
rw [functor.hext hobj fun _ _ => hmap]
subst h
cases p <;> simp
subst h <;> rfl
rw [α.naturality_assoc]
simp [eq_to_hom_map]
simp only [category.id_comp, eq_to_hom_refl, category.comp_id]
subst h
simp
apply hip.sq_has_lift
simp only [comm_sq.has_lift.iff_unop, Quiver.Hom.unop_op]
infer_instance
rw [comm_sq.has_lift.iff_op]
simp only [Quiver.Hom.op_unop]
infer_instance
simp only [is_iso.hom_inv_id_assoc]
simp only [sq.w, assoc, is_iso.inv_hom_id_assoc]
simp only [← sq.w_assoc, is_iso.hom_inv_id, comp_id]
simp only [assoc, is_iso.inv_hom_id, comp_id]
simp only [assoc, comm_sq.fac_left]
simp only [comm_sq.fac_right]
simp only [comm_sq.fac_left]
simp only [comm_sq.fac_right_assoc, comm_sq.fac_right]
rw [arrow.iso_w' e]
infer_instance
rw [arrow.iso_w' e]
infer_instance
simp only [adjunction.hom_equiv_unit, assoc, ← F.map_comp, sq.w]
rw [F.map_comp, adjunction.unit_naturality_assoc]
rw [← adj.hom_equiv_naturality_left, l.fac_left]
rw [← adjunction.hom_equiv_naturality_right, l.fac_right]
rw [← adjunction.hom_equiv_naturality_left_symm, l.fac_left]
apply (adj.hom_equiv _ _).left_inv
rw [← adjunction.hom_equiv_naturality_right_symm, l.fac_right]
apply (adj.hom_equiv _ _).left_inv
simp only [has_lift.iff]
exact Equiv.nonempty_congr (sq.right_adjoint_lift_struct_equiv adj).symm
rw [right_adjoint_has_lift_iff]
infer_instance
simp only [adjunction.hom_equiv_counit, assoc, ← G.map_comp_assoc, ← sq.w]
rw [G.map_comp, assoc, adjunction.counit_naturality]
rw [← adj.hom_equiv_naturality_left_symm, l.fac_left]
rw [← adj.hom_equiv_naturality_right_symm, l.fac_right]
rw [← adj.hom_equiv_naturality_left, l.fac_left]
apply (adj.hom_equiv _ _).right_inv
rw [← adj.hom_equiv_naturality_right, l.fac_right]
apply (adj.hom_equiv _ _).right_inv
simp only [has_lift.iff]
exact Equiv.nonempty_congr (sq.left_adjoint_lift_struct_equiv adj).symm
rw [left_adjoint_has_lift_iff]
infer_instance
constructor <;> intro <;> constructor <;> intro f g sq
· rw [← sq.left_adjoint_has_lift_iff adj]
    infer_instance
· rw [← sq.right_adjoint_has_lift_iff adj]
    infer_instance
rw [← nat_iso.naturality_1 (lift.is_lift r F H)]
dsimp
simp
erw [category.id_comp, category.comp_id]
rfl
erw [category.id_comp, category.comp_id]
rfl
refine' Fin.cases _ _
· apply c₂.fst
· intro i
        apply c₂.snd
apply (binary_fan.is_limit.lift' t₂ (s.π.app ⟨0⟩) _).1
apply t₁.lift ⟨_, discrete.nat_trans fun ⟨i⟩ => s.π.app ⟨i.succ⟩⟩
refine' Fin.cases _ _
· apply c₂.inl
· intro i
        apply c₁.ι.app ⟨i⟩
apply (binary_cofan.is_colimit.desc' t₂ (s.ι.app ⟨0⟩) _).1
apply t₁.desc ⟨_, discrete.nat_trans fun i => s.ι.app ⟨i.as.succ⟩⟩
dsimp [zero_prod_iso, binary_fan_zero_left]
simp
dsimp [prod_zero_iso, binary_fan_zero_right]
simp
dsimp [zero_coprod_iso, binary_cofan_zero_left]
simp
dsimp [coprod_zero_iso, binary_cofan_zero_right]
simp
dsimp [pullback_zero_zero_iso]
simp
dsimp [pullback_zero_zero_iso]
simp
simp [← iso.eq_inv_comp]
simp [← iso.eq_inv_comp]
dsimp [pushout_zero_zero_iso]
simp
dsimp [pushout_zero_zero_iso]
simp
simp [iso.comp_inv_eq]
simp [iso.comp_inv_eq]
refine' pullback.lift _ _ _
refine' (@preserves_pushout.iso _ _ _ _ _ _ _ _).inv
simp
let endos := T
dsimp
cases X <;> cases Y <;> cases f
· rw [category.id_comp, category.comp_id]
· rw [over.w, category.id_comp]
· rw [category.id_comp, category.comp_id]
cases j
· simp
· dsimp
          rw [← f.w ⟨j⟩]
          rfl
apply c.w (wide_pullback_shape.hom.term j)
infer_instance
dsimp
simp
simp only [category.assoc, equalizer.condition]
rw [← category.assoc, limit.lift_π, ← category.assoc, limit.lift_π] <;>
                  exact pullback_cone.condition _
simp
simp
rw [← category.assoc, ← category.assoc, coequalizer.condition]
rw [category.assoc, colimit.ι_desc, category.assoc, colimit.ι_desc] <;>
                  exact pushout_cocone.condition _
simp
simp
apply isBinaryProductOfIsTerminalIsPullback _ _ H₁
exact H₂
apply
          isBinaryProductOfIsTerminalIsPullback _ _ (is_limit_of_has_terminal_of_preserves_limit F)
apply is_limit_of_has_pullback_of_preserves_limit
apply isBinaryCoproductOfIsInitialIsPushout _ _ H₁
exact H₂
apply
          isBinaryCoproductOfIsInitialIsPushout _ _
            (is_colimit_of_has_initial_of_preserves_colimit F)
apply is_colimit_of_has_pushout_of_preserves_colimit
dsimp
rw [category.id_comp, category.assoc, ← hs ⟨⟨_, _⟩, f⟩, i.condition_assoc, ht]
refine' hi.lift (fork.of_ι _ _)
· refine' t₁.lift (fan.mk _ fun j => _)
      apply q.π.app j
· apply t₂.hom_ext
      intro j
      trace
        "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `discrete_cases #[]"
      simp [hs, ht]
simp
simp
simp
simp
dsimp
rw [category.comp_id, ← reassoc_of (hs ⟨⟨_, _⟩, f⟩), i.condition, ← category.assoc, ht]
refine' hi.desc (cofork.of_π _ _)
· refine' t₂.desc (cofan.mk _ fun j => _)
      apply q.ι.app j
· apply t₁.hom_ext
      intro j
      trace
        "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `discrete_cases #[]"
      simp [reassoc_of hs, reassoc_of ht]
simp
simp
simp
simp
exact this.comp h
  apply Subtype.ext
have a := x.2 (walking_multicospan.hom.fst i)
have b := x.2 (walking_multicospan.hom.snd i)
rw [← b] at a
exact a
exact this ⟨i, x⟩ ⟨j, y⟩ h
  intro a b h
  induction h
  case rel x y hh
apply evaluation_jointly_reflects_limits
intro Y
change is_limit (((evaluation E D).obj (F.obj Y)).mapCone c)
exact preserves_limit.preserves hc
apply preserves_limits_of_shape_of_reflects_of_preserves F yoneda
exact preserves_limits_of_shape_of_nat_iso (comp_yoneda_iso_yoneda_comp_Lan F).symm
infer_instance
infer_instance
apply preserves_limits_of_shape_of_equiv (fin_category.equiv_as_type J)
skip
exact preserves_limits_of_shape J F
apply UliftHom.category.{0}
exact CategoryTheory.uliftCategory J
skip
infer_instance
infer_instance
apply preserves_colimits_of_shape_of_equiv (fin_category.equiv_as_type J)
skip
exact preserves_colimits_of_shape J F
apply UliftHom.category.{0}
exact CategoryTheory.uliftCategory J
skip
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
constructor
intros
cases a
cases b
congr
constructor
intros
cases a
cases b
congr
infer_instance
infer_instance
infer_instance
infer_instance
constructor
intros
cases a
cases b
congr
constructor
intros
cases a
cases b
congr
apply is_limit.of_whisker_equivalence e
apply is_limit_of_reflects F
apply is_limit.of_iso_limit _ (functor.map_cone_whisker _).symm
exact is_limit.whisker_equivalence t _
apply is_limit.of_point_iso (limit.is_limit F)
change is_iso ((cones.forget _).map ((limit.is_limit F).liftConeMorphism c))
apply (cones.forget F).map_is_iso _
apply is_iso_of_reflects_iso _ (cones.functoriality F G)
refine' t.hom_is_iso (is_limit_of_preserves G (limit.is_limit F)) _
apply is_colimit.of_whisker_equivalence e
apply is_colimit_of_reflects F
apply is_colimit.of_iso_colimit _ (functor.map_cocone_whisker _).symm
exact is_colimit.whisker_equivalence t _
apply is_colimit.of_point_iso (colimit.is_colimit F)
change is_iso ((cocones.forget _).map ((colimit.is_colimit F).descCoconeMorphism c))
apply (cocones.forget F).map_is_iso _
apply is_iso_of_reflects_iso _ (cocones.functoriality F G)
refine' (is_colimit_of_preserves G (colimit.is_colimit F)).hom_is_iso t _
apply fun s m => (cones.functoriality K F).map_injective _
rw [functor.image_preimage]
apply t.uniq_cone_morphism
apply fun s m => (cocones.functoriality K F).map_injective _
rw [functor.image_preimage]
apply t.uniq_cocone_morphism
simp [← G.map_comp]
simp [← G.map_comp]
trace
        "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `discrete_cases #[]"
dsimp
simp
apply preserves_limit_of_preserves_limit_cone (product_is_product f)
apply (is_limit_map_cone_fan_mk_equiv _ _ _).symm _
apply is_limit.of_point_iso (limit.is_limit (discrete.functor fun j : J => G.obj (f j)))
apply i
rw [← preserves_product.iso_hom]
infer_instance
trace
        "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `discrete_cases #[]"
dsimp
simp
apply preserves_colimit_of_preserves_colimit_cocone (coproduct_is_coproduct f)
apply (is_colimit_map_cocone_cofan_mk_equiv _ _ _).symm _
apply is_colimit.of_point_iso (colimit.is_colimit (discrete.functor fun j : J => G.obj (f j)))
apply i
rw [← preserves_coproduct.inv_hom]
infer_instance
rw [zero_comp]
rw [F.map_comp, F.image_preimage, comp_zero]
rw [← F.map_id, id_zero, F.map_zero, zero_comp]
rw [id_zero, comp_zero]
rw [← functor.map_comp, comp_zero]
rw [iso.hom_inv_id, category.id_comp]
simp only [zero_of_to_zero i.hom, zero_comp, comp_zero]
simp only [← G.map_comp, w]
simp [fork.ι]
simp only [← G.map_comp, w]
simp only [← G.map_comp, w]
simp only [← G.map_comp, equalizer.condition]
apply preserves_limit_of_preserves_limit_cone (equalizer_is_equalizer f g)
apply (is_limit_map_cone_fork_equiv _ _).symm _
apply is_limit.of_point_iso (limit.is_limit (parallel_pair (G.map f) (G.map g)))
apply i
rw [← preserves_equalizer.iso_hom]
infer_instance
simp only [← G.map_comp, w]
dsimp only [cofork.π, cofork.of_π_ι_app]
dsimp
rw [category.comp_id, category.id_comp]
simp only [← G.map_comp, w]
simp only [← G.map_comp, w]
apply preserves_colimit_of_preserves_colimit_cocone (coequalizer_is_coequalizer f g)
apply (is_colimit_map_cocone_cofork_equiv _ _).symm _
apply is_colimit.of_point_iso (colimit.is_colimit (parallel_pair (G.map f) (G.map g)))
apply i
rw [← preserves_coequalizer.iso_hom]
infer_instance
rw [← ι_comp_coequalizer_comparison]
apply (cancel_epi _).1
apply epi_comp
rw [← ι_comp_coequalizer_comparison_assoc, ← preserves_coequalizer.iso_hom, iso.hom_inv_id,
    comp_id]
rw [← category.assoc, map_π_preserves_coequalizer_inv, coequalizer.π_desc]
rw [← category.assoc, map_π_preserves_coequalizer_inv, ι_colim_map, parallel_pair_hom_app_one]
apply
    preserves_colimit_of_preserves_colimit_cocone
      (has_split_coequalizer.is_split_coequalizer f g).isCoequalizer
apply
    (is_colimit_map_cocone_cofork_equiv G _).symm
      ((has_split_coequalizer.is_split_coequalizer f g).map G).isCoequalizer
rw [← L.map_comp, limits.image.fac]
simp
simp
simp
simp only [← G.map_comp, w, functor.map_zero]
refine' (is_limit.postcompose_hom_equiv _ _).symm.trans (is_limit.equiv_iso_limit _)
refine' parallel_pair.ext (iso.refl _) (iso.refl _) _ _ <;> simp
refine' fork.ext (iso.refl _) _
simp [fork.ι]
simp only [← G.map_comp, w, functor.map_zero]
simp only [← G.map_comp, equalizer.condition, comp_zero, functor.map_zero]
apply preserves_limit_of_preserves_limit_cone (kernel_is_kernel f)
apply (is_limit_map_cone_fork_equiv' G (kernel.condition f)).symm _
apply is_limit.of_point_iso (kernel_is_kernel (G.map f))
exact i
rw [← preserves_kernel.iso_hom]
infer_instance
rw [← G.map_comp, hpq, G.map_comp]
rw [iso.comp_inv_eq, category.assoc, preserves_kernel.iso_hom, iso.eq_inv_comp]
exact kernel_comparison_comp_kernel_map _ _ _ _ _ _
simp only [← G.map_comp, w, functor.map_zero]
refine' (is_colimit.precompose_hom_equiv _ _).symm.trans (is_colimit.equiv_iso_colimit _)
refine' parallel_pair.ext (iso.refl _) (iso.refl _) _ _ <;> simp
refine' cofork.ext (iso.refl _) _
simp only [cofork.π, iso.refl_hom, id_comp, cocones.precompose_obj_ι, nat_trans.comp_app,
    parallel_pair.ext_hom_app, functor.map_cocone_ι_app, cofork.of_π_ι_app]
apply category.comp_id
simp only [← G.map_comp, w, functor.map_zero]
simp only [← G.map_comp, coequalizer.condition, zero_comp, functor.map_zero]
apply preserves_colimit_of_preserves_colimit_cocone (cokernel_is_cokernel f)
apply (is_colimit_map_cocone_cofork_equiv' G (cokernel.condition f)).symm _
apply is_colimit.of_point_iso (cokernel_is_cokernel (G.map f))
exact i
rw [← preserves_cokernel.iso_inv]
infer_instance
rw [← G.map_comp, hpq, G.map_comp]
rw [← iso.comp_inv_eq, category.assoc, ← iso.eq_inv_comp]
exact cokernel_map_comp_cokernel_comparison _ _ _ _ _ _
rw [← F.map_comp, b.inl_fst, F.map_id]
rw [← F.map_comp, b.inl_snd, F.map_zero]
rw [← F.map_comp, b.inr_fst, F.map_zero]
rw [← F.map_comp, b.inr_snd, F.map_id]
infer_instance
rw [← biproduct.map_biproduct_inv_map_desc, iso.hom_inv_id_assoc]
rw [← biprod.map_lift_map_biprod, category.assoc, iso.hom_inv_id, category.comp_id]
rw [← biprod.map_biprod_inv_map_desc, iso.hom_inv_id_assoc]
apply preserves_limit_of_preserves_limit_cone terminal_is_terminal
apply (is_limit_map_cone_empty_cone_equiv _ _).symm _
apply is_limit.of_point_iso (limit.is_limit (Functor.empty.{0} D))
apply i
rw [Subsingleton.elim f (terminal_comparison G)] at i
exact preserves_terminal.of_iso_comparison G
rw [← preserves_terminal.iso_hom]
infer_instance
apply preserves_colimit_of_preserves_colimit_cocone initial_is_initial
apply (is_colimit_map_cocone_empty_cocone_equiv _ _).symm _
apply is_colimit.of_point_iso (colimit.is_colimit (Functor.empty.{0} D))
apply i
rw [Subsingleton.elim f (initial_comparison G)] at i
exact preserves_initial.of_iso_comparison G
rw [← preserves_initial.iso_hom]
infer_instance
simp only [← G.map_comp, comm]
simp [preserves_pullback.iso]
simp [preserves_pullback.iso]
simp [preserves_pullback.iso, iso.inv_comp_eq]
simp [preserves_pullback.iso, iso.inv_comp_eq]
simp only [← G.map_comp, comm]
delta preserves_pushout.iso
simp
delta preserves_pushout.iso
simp
simp [preserves_pushout.iso, iso.comp_inv_eq]
simp [preserves_pushout.iso, iso.comp_inv_eq]
apply preserves_limit_of_preserves_limit_cone (pullback_is_pullback f g)
apply (is_limit_map_cone_pullback_cone_equiv _ _).symm _
apply is_limit.of_point_iso (limit.is_limit (cospan (G.map f) (G.map g)))
apply i
rw [← preserves_pullback.iso_hom]
infer_instance
apply preserves_colimit_of_preserves_colimit_cocone (pushout_is_pushout f g)
apply (is_colimit_map_cocone_pushout_cocone_equiv _ _).symm _
apply is_colimit.of_point_iso (colimit.is_colimit (span (G.map f) (G.map g)))
apply i
rw [← preserves_pushout.iso_hom]
infer_instance
apply preserves_limit_of_preserves_limit_cone (prod_is_prod X Y)
apply (is_limit_map_cone_binary_fan_equiv _ _ _).symm _
apply is_limit.of_point_iso (limit.is_limit (pair (G.obj X) (G.obj Y)))
apply i
rw [← preserves_limit_pair.iso_hom]
infer_instance
apply preserves_colimit_of_preserves_colimit_cocone (coprod_is_coprod X Y)
apply (is_colimit_map_cocone_binary_cofan_equiv _ _ _).symm _
apply is_colimit.of_point_iso (colimit.is_colimit (pair (G.obj X) (G.obj Y)))
apply i
rw [← preserves_colimit_pair.iso_hom]
infer_instance
intro X Y f
change colimit.desc _ ⟨_, _⟩
apply is_colimit.of_point_iso (colimit.is_colimit (functor_to_representables P))
change is_iso (colimit.desc _ (cocone.extend _ _))
rw [colimit.desc_extend, colimit.desc_cocone]
infer_instance
apply nat_iso.of_components _ _
· intro P
    refine'
      (is_colimit_of_preserves L₁ (colimit_of_representable P)).coconePointsIsoOfNatIso
        (is_colimit_of_preserves L₂ (colimit_of_representable P)) _
    apply functor.associator _ _ _
dsimp
rw [← L₁.map_comp, cocone_of_representable_naturality]
rfl
dsimp [limit.mk]
simp
dsimp [limit.mk]
simp
rw [hf] <;> exact (congr_fun (cocone.w s f) x).symm
apply (colimit_equiv_quot F).symm.Injective
simp
rw [← w]
simp
rw [← colimit.w _ f, ← colimit.w _ f']
rw [types_comp_apply, types_comp_apply, w]
rw [← h, functor_to_types.map_id_apply]
simp
rw [h]
simp
rw [hn]
simp
rw [h']
simp
change Quot.mk _ _ = Quot.mk _ _ ↔ _
rw [Quot.eq, filtered_colimit.rel_eq_eqv_gen_quot_rel]
infer_instance
simp
simp
simp
simp
simp
simp only [true_and_iff, Finset.mem_univ, eq_self_iff_true, exists_prop_of_true,
              Finset.mem_image, heq_iff_eq]
refine' ⟨j, rfl, _⟩
simp only [heq_iff_eq]
exact ⟨rfl, rfl, rfl⟩
simp only [true_and_iff, Finset.mem_univ, eq_self_iff_true, exists_prop_of_true,
              Finset.mem_image, heq_iff_eq]
refine' ⟨j, rfl, _⟩
simp only [heq_iff_eq]
exact ⟨rfl, rfl, rfl⟩
simp
simp only [id_comp, comp_id, prod_comp]
rw [Finset.mem_bUnion]
refine' ⟨j, Finset.mem_univ j, _⟩
rw [Finset.mem_bUnion]
refine' ⟨j', Finset.mem_univ j', _⟩
rw [Finset.mem_image]
refine' ⟨f, Finset.mem_univ _, _⟩
rfl
rw [← functor_to_types.map_comp_apply, prod_comp, comp_id, assoc]
rw [← wf f]
rw [← functor_to_types.map_comp_apply, prod_comp, id_comp, assoc]
dsimp only [colimit_limit_to_limit_colimit_cone]
infer_instance
apply preservesFiniteLimitsOfPreservesFiniteLimitsOfSize.{v}
intro J _ _
skip
infer_instance
dsimp [colimit_limit_iso]
simp only [functor.map_cone_π_app, iso.symm_hom,
    limits.limit.cone_point_unique_up_to_iso_hom_comp_assoc, limits.limit.cone_π,
    limits.colimit.ι_map_assoc, limits.colimit_flip_iso_comp_colim_inv_app, assoc,
    limits.has_limit.iso_of_nat_iso_hom_π]
congr 1
simp only [← category.assoc, iso.comp_inv_eq,
    limits.colimit_obj_iso_colimit_comp_evaluation_ι_app_hom,
    limits.has_colimit.iso_of_nat_iso_ι_hom, nat_iso.of_components_hom_app]
dsimp
simp
dsimp
simp
simp
rw [(t X).fac_assoc _ j]
erw [← (c.ι.app j).naturality_assoc f]
erw [(t Y).fac ⟨s.X.obj _, whisker_right s.ι _⟩ j]
dsimp
simp
dsimp
simp
simp
dsimp [limit_obj_iso_limit_comp_evaluation]
simp
dsimp [limit_obj_iso_limit_comp_evaluation]
rw [iso.inv_comp_eq]
simp
rw [iso.inv_comp_eq, ← category.assoc, iso.eq_comp_inv,
    limit_map_limit_obj_iso_limit_comp_evaluation_hom]
dsimp [colimit_obj_iso_colimit_comp_evaluation]
simp
dsimp [colimit_obj_iso_colimit_comp_evaluation]
rw [← iso.eq_comp_inv]
simp
rw [← iso.inv_comp_eq, ← category.assoc, ← iso.eq_comp_inv,
    colimit_obj_iso_colimit_comp_evaluation_inv_colimit_map]
skip <;> infer_instance
skip <;> infer_instance
rw [Cardinal.two_le_iff]
exact ⟨_, _, r_ne_s⟩
simp only [h₂, is_colimit.fac, binary_cofan.ι_app_left, binary_cofan.mk_inl]
simp only [h₁, is_colimit.fac, binary_cofan.ι_app_right, binary_cofan.mk_inr]
exact ⟨fun h₁ => this _ _ hc₁ hc₂ h₁, fun h₂ => this _ _ hc₂ hc₁ h₂⟩
  intro c₁ c₂ hc₁ hc₂
  intro
  simpa only [is_colimit.comp_cocone_point_unique_up_to_iso_hom]
dsimp
intro k k' f
simp only [functor.comp_map, curry_obj_map_app, limits.lim_map_π_assoc,
                        swap_map, category.comp_id, map_id_left_eq_curry_map, colimit.w]
dsimp [colimit_limit_to_limit_colimit]
simp
dsimp [colimit_limit_to_limit_colimit]
simp
apply prod.hom_ext
· erw [limit.lift_π, ← L (Classical.arbitrary J), assoc, lim_map_π, comp_id]
              rfl
· rw [limit.lift_π]
              apply l.uniq (forget_cone s)
              intro j
              simp [← L j]
simp
simp
simp
simp
dsimp
simp
            -- This would be true if we'd chosen `lift F X` to be `lift F Y`
            -- and `hom_to_lift F X` to be `f ≫ hom_to_lift F Y`.
apply
              induction F fun Z k =>
                G.map f
apply induction F fun X k => G.map k
dsimp [is_colimit_whisker_equiv]
apply P.hom_ext
intro j
dsimp
simp
rw [colimit.pre_eq (colimit_cocone_comp F (get_colimit_cocone G)) (get_colimit_cocone G)]
erw [colimit_pre_is_iso_aux]
dsimp
infer_instance
apply induction F fun X k => s.π.app X
dsimp [is_limit_whisker_equiv]
apply P.hom_ext
intro j
simp
rw [limit.pre_eq (limit_cone_comp F (get_limit_cone G)) (get_limit_cone G)]
erw [limit_pre_is_iso_aux]
dsimp
infer_instance
intro x y ff
dsimp only [whiskering_left]
simp only [functor.comp_map, nat_trans.naturality_assoc, loc_map, category.assoc]
congr 1
erw [limit.pre_π]
change _ = _
apply nat_iso.is_iso_of_is_iso_app _
intro F
apply nat_iso.is_iso_of_is_iso_app _
intro X
dsimp [adjunction]
simp only [category.id_comp]
exact
    is_iso.of_iso
      ((limit.is_limit _).conePointUniqueUpToIso
        (limit_of_diagram_initial structured_arrow.mk_id_initial _))
simp only [costructured_arrow.mk_hom_eq_self]
erw [category.comp_id]
apply nat_iso.is_iso_of_is_iso_app _
intro F
apply nat_iso.is_iso_of_is_iso_app _
intro X
dsimp [adjunction]
simp only [category.comp_id]
exact
    is_iso.of_iso
      ((colimit.is_colimit _).coconePointUniqueUpToIso
          (colimit_of_diagram_terminal costructured_arrow.mk_id_terminal _)).symm
refine' Quiver.Hom.op_inj (t.uniq ⟨op X, _, _⟩ _ fun j => _)
· dsimp
                    simp [← s.w α]
                  -- See library note [dsimp, simp]
· exact Quiver.Hom.unop_inj (congr_fun (w j) x)
dsimp
simp [← s.w α]
refine' t.uniq ⟨unop X, _⟩ _ fun j => _
exact congr_fun (w j) x
apply congr_fun this PUnit.unit
apply congr_fun this PUnit.unit
      apply (t _).uniq (s' s) _ fun j => _
      ext
      exact w j
apply preserves_limits_of_evaluation
intro K
change preserves_limits (coyoneda.obj K)
infer_instance
apply preserves_limits_of_evaluation
intro K
change preserves_limits (yoneda.obj K)
infer_instance
apply uniq'
    congr_arg ConeMorphism.hom this
simp
simp
rw [← i.comp_inv_eq] <;> apply P.uniq_cone_morphism
rw [h.hom_lift f, h.hom_lift f'] <;> congr <;> exact funext w
simp
simp
simp
simp
apply hom_ext P
intro j
dsimp
simp only [limits.cone.whisker_π, limits.cones.postcompose_obj_π, fac, whisker_left_app,
        assoc, id_comp, inv_fun_id_assoc_hom_app, fac_assoc, nat_trans.comp_app]
rw [counit_app_functor, ← functor.comp_map, w.hom.naturality]
simp
dsimp
rw [id_comp]
exact (p.2 f).symm
apply G.map_injective <;> rw [G.map_comp, h] <;> apply ht.fac
    uniq'
apply postcompose_inv_equiv (iso_whisker_left K h : _) (G.map_cone c) _
apply t.of_iso_limit (postcompose_whisker_left_map_cone h.symm c).symm
dsimp [cone_of_hom, limit_cone, cone.extend]
congr
rw [← hom_of_cone_of_hom h m]
congr
rw [cone_of_hom_fac]
dsimp [cone.extend]
cases s
congr
apply uniq'
    congr_arg CoconeMorphism.hom this
simp
simp
rw [i.eq_inv_comp] <;> apply P.uniq_cocone_morphism
intros <;> erw [← assoc, t.ι.naturality, comp_id, comp_id]
rw [h.hom_desc f, h.hom_desc f'] <;> congr <;> exact funext w
simp
simp
simp
simp
apply hom_ext P
intro j
dsimp
simp only [limits.cocone.whisker_ι, fac, inv_fun_id_assoc_inv_app, whisker_left_app, assoc,
        comp_id, limits.cocones.precompose_obj_ι, fac_assoc, nat_trans.comp_app]
rw [counit_inv_app_functor, ← functor.comp_map, ← w.inv.naturality_assoc]
dsimp
simp
dsimp
rw [comp_id]
exact p.2 f
apply G.map_injective <;> rw [G.map_comp, h] <;> apply ht.fac
    uniq'
apply is_colimit.of_iso_colimit _ (precompose_whisker_left_map_cocone h c)
apply (precompose_inv_equiv (iso_whisker_left K h : _) _).symm t
dsimp [cocone_of_hom, colimit_cocone, cocone.extend]
congr
rw [← hom_of_cocone_of_hom h m]
congr
rw [cocone_of_hom_fac]
dsimp [cocone.extend]
cases s
congr
cases j <;> simp
exact Fintype.complete j
cases f <;> cases g <;> simp <;> infer_instance
cases f <;> simp
cases f <;> simp
cases f <;> cases g <;> cases h <;> simp
cases X <;> simp
cases f
exact (category.id_comp _).symm
exact (category.id_comp _).symm
cases g
exact (category.id_comp _).symm.trans (c₁.π.naturality g_f : _)
cases g
exact (category.id_comp _).symm.trans (c₂.π.naturality g_f : _)
cases g
exact F.map_comp _ _
cases f
simp
cases f
cases f
simp
cases f
cases f
simp
cases f
simp
cases f
cases f
skip
infer_instance
skip
infer_instance
rfl
rfl
change (_ : limits.cone _).π.app _ = _
apply category.comp_id
change (_ : limits.cone _).π.app _ = _
apply category.comp_id
change (_ : limits.cocone _).ι.app _ = _
dsimp only [unop, op_span]
simp
dsimp
simp
dsimp
simp
change (_ : limits.cocone _).ι.app _ = _
apply Quiver.Hom.op_inj
simp [unop_ι_app]
dsimp
simp
apply category.comp_id
change (_ : limits.cocone _).ι.app _ = _
apply category.id_comp
change (_ : limits.cocone _).ι.app _ = _
apply category.id_comp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
apply Quiver.Hom.unop_inj
dsimp
rw [← pullback_iso_unop_pushout_inv_fst, iso.hom_inv_id_assoc]
apply Quiver.Hom.unop_inj
dsimp
rw [← pullback_iso_unop_pushout_inv_snd, iso.hom_inv_id_assoc]
simp
simp
apply Quiver.Hom.unop_inj
dsimp
rw [← pushout_iso_unop_pullback_inl_hom, category.assoc, iso.hom_inv_id, category.comp_id]
apply Quiver.Hom.unop_inj
dsimp
rw [← pushout_iso_unop_pullback_inr_hom, category.assoc, iso.hom_inv_id, category.comp_id]
rw [finite_limit_eq_finset_univ_inf (pair.{u} x y)]
rw [inf_top_eq]
rw [finite_colimit_eq_finset_univ_sup (pair x y)]
rw [sup_bot_eq]
rw [finite_limit_eq_finset_univ_inf]
rw [inf_top_eq]
rw [finite_colimit_eq_finset_univ_sup]
rw [sup_bot_eq]
infer_instance
infer_instance
simp
rw [cones.postcompose_obj_π, nat_trans.comp_app, limit.cone_π, ← category.assoc,
              limit.lift_π]
simp
simp only [has_limit.iso_of_equivalence, is_limit.cone_points_iso_of_equivalence_hom]
dsimp
simp
simp only [has_limit.iso_of_equivalence, is_limit.cone_points_iso_of_equivalence_hom]
dsimp
simp
erw [is_limit.fac]
rfl
erw [is_limit.fac]
rfl
simp
constructor
intro F
apply has_limit_of_equivalence_comp e
infer_instance
infer_instance
infer_instance
simp
rw [cocones.precompose_obj_ι, nat_trans.comp_app, colimit.cocone_ι]
rw [category.assoc, colimit.ι_desc, ← nat_iso.app_hom, ← iso.eq_inv_comp]
rfl
simp [has_colimit.iso_of_equivalence, is_colimit.cocone_points_iso_of_equivalence_inv]
dsimp
simp
simp [has_colimit.iso_of_equivalence, is_colimit.cocone_points_iso_of_equivalence_inv]
dsimp
simp
erw [is_colimit.fac]
rfl
infer_instance
erw [is_colimit.fac]
rfl
infer_instance
apply is_colimit.fac
simp
constructor
intro F
apply has_colimit_of_equivalence_comp e
infer_instance
rw [← P.uniq s.unop m.unop]
· rfl
· dsimp
      intro j
      rw [← w]
      rfl
rw [← P.uniq s.unop m.unop]
· rfl
· dsimp
      intro j
      rw [← w]
      rfl
rw [← P.uniq s.op m.op]
· rfl
· dsimp
      intro j
      rw [← w]
      rfl
rw [← P.uniq s.op m.op]
· rfl
· dsimp
      intro j
      rw [← w]
      rfl
apply (Q j).hom_ext
intro k
simp
dsimp [limit_uncurry_iso_limit_comp_lim, is_limit.cone_point_unique_up_to_iso,
    is_limit.unique_up_to_iso]
simp
rw [← cancel_epi (limit_uncurry_iso_limit_comp_lim F).Hom]
simp
rfl
dsimp [limit_flip_comp_lim_iso_limit_comp_lim]
simp
dsimp
simp
dsimp [limit_flip_comp_lim_iso_limit_comp_lim]
simp
dsimp
simp
dsimp
simp
simp [limit_iso_limit_curry_comp_lim, is_limit.cone_point_unique_up_to_iso,
    is_limit.unique_up_to_iso]
rw [← cancel_epi (limit_iso_limit_curry_comp_lim G).Hom]
simp
dsimp [limit_curry_swap_comp_lim_iso_limit_curry_comp_lim]
simp only [iso.refl_hom, braiding_counit_iso_hom_app, limits.has_limit.iso_of_equivalence_hom_π,
    iso.refl_inv, limit_iso_limit_curry_comp_lim_hom_π_π, eq_to_iso_refl, category.assoc]
erw [nat_trans.id_app]
  -- Why can't `simp` do this`?
dsimp
simp
dsimp [limit_curry_swap_comp_lim_iso_limit_curry_comp_lim]
simp only [iso.refl_hom, braiding_counit_iso_hom_app, limits.has_limit.iso_of_equivalence_inv_π,
    iso.refl_inv, limit_iso_limit_curry_comp_lim_hom_π_π, eq_to_iso_refl, category.assoc]
erw [nat_trans.id_app]
  -- Why can't `simp` do this`?
dsimp
simp
simp [pullback.condition]
refine' over.hom_mk _ _
refine' Y.left
simp [← pushout.condition]
rw [cone_of_preserves_X_hom, assoc, assoc, (is_limit_of_preserves R t₂).fac,
            limit_auxiliary_cone_π_app, ← L.map_comp_assoc, t₁.fac, R.map_cone_π_app, ← R.map_comp,
            t₂.fac]
exact (s.π.app j).w
simp [← w]
simp [← w]
rw [cocone_of_preserves_X_hom, (is_colimit_of_preserves L t₁).fac_assoc,
            colimit_auxiliary_cocone_ι_app, assoc, ← R.map_comp, t₂.fac, L.map_cocone_ι_app, ←
            L.map_comp_assoc, t₁.fac]
exact (s.ι.app j).w
simp [← w]
simp [← w]
rw [← c.π.naturality f]
apply id_comp
rw [c.ι.naturality f]
apply comp_id
simp [-cone_morphism.w, ← f.w j]
intros <;> rw [← functor.map_comp, cocone_morphism.w]
apply Quiver.Hom.unop_inj
dsimp
apply cocone_morphism.w
apply Quiver.Hom.op_inj
dsimp
apply cone_morphism.w
dsimp
simp
dsimp
simp
dsimp
simp
dsimp only [cocone_of_cone_left_op]
simp
infer_instance
intros
infer_instance
intros
infer_instance
simp only [category.assoc, sq.w]
simp only [← cancel_mono z, category.assoc, comm_sq.fac_right, sq.w]
simp
rw [reassoc_of sq.w]
simp
simp [← cancel_epi z, sq.w]
infer_instance
infer_instance
intro
apply has_lifting_property.of_arrow_iso_left e z
intro
apply has_lifting_property.of_arrow_iso_right z e
simp
simp
dsimp
infer_instance
dsimp
infer_instance
dsimp
congr
trace
                  "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `discrete_cases #[]"
dsimp
congr
simp [iso.inv_comp_eq]
dsimp [sigma.reindex]
simp only [has_colimit.iso_of_equivalence_hom_π, equivalence.equivalence_mk'_unit,
    discrete.equivalence_unit_iso, discrete.nat_iso_hom_app, eq_to_iso.hom, eq_to_hom_map,
    discrete.nat_iso_inv_app]
dsimp
simp [eq_to_hom_map, ←
    colimit.w (discrete.functor f) (discrete.eq_to_hom' (ε.apply_symm_apply (ε b)))]
simp [iso.comp_inv_eq]
rw [eq_compl_iff_is_compl.mpr h₃.symm]
exact fun _ => or_not
apply congr_fun s.condition i
cases h
exact congr_fun s.condition h_1
cases X <;> rfl
cases X <;> rfl
rw [← s.w (line j), parallel_family_map_left]
rw [← s.w (line j), parallel_family_map_left]
rw [t.app_zero, t.app_zero]
rw [t.app_one, t.app_one]
rw [← s.app_zero (Classical.arbitrary J), reassoc_of h]
rw [← s.app_one (Classical.arbitrary J), category.assoc, category.assoc, h]
rw [← t.w (line (Classical.arbitrary J)), reassoc_of fac, s.w]
rw [← t.w_assoc (line (Classical.arbitrary J)), fac, s.w]
simp
simp
cases g <;>
          · dsimp
            simp
cases g <;> dsimp <;> simp [cotrident.app_one t]
rw [← w, iso.inv_hom_id_assoc]
rw [iso.comp_inv_eq, w]
infer_instance
rw [(is_iso.inv_eq_of_inv_hom_id (diagonal_fst f)).symm]
infer_instance
simp [condition]
simp [condition]
simp [condition]
simp [condition]
simp [condition]
simp [condition]
delta pullback_diagonal_map_iso
simp
delta pullback_diagonal_map_iso
simp
delta pullback_diagonal_map_iso
simp
delta pullback_diagonal_map_iso
simp
delta pullback_diagonal_map_iso
simp
simp [condition]
simp [condition]
delta pullback_diagonal_map_id_iso
simp
delta pullback_diagonal_map_id_iso
simp
rw [iso.inv_comp_eq, ← category.comp_id pullback.fst, ← diagonal_fst i, pullback.condition_assoc]
simp
rw [iso.inv_comp_eq]
simp
rw [iso.inv_comp_eq]
simp
delta diagonal_obj_pullback_fst_iso
simp
delta diagonal_obj_pullback_fst_iso
simp
delta diagonal_obj_pullback_fst_iso
simp
delta diagonal_obj_pullback_fst_iso
simp
delta diagonal_obj_pullback_fst_iso
simp
delta diagonal_obj_pullback_fst_iso
simp
delta diagonal_obj_pullback_fst_iso
simp
simp
rw [← cancel_mono i₃, category.assoc, category.assoc, category.assoc, category.assoc, e₁,
          e₂, ← pullback.condition_assoc, pullback.condition_assoc, pullback.condition,
          pullback.condition_assoc]
rw [pullback.lift_fst, pullback.lift_fst]
rw [lift_fst, lift_fst]
simp
simp
simp
rw [← reassoc_of comm, ← reassoc_of comm, hr.w]
apply (cancel_epi z).1
simp only [regular_mono.w, ← reassoc_of sq.w]
simp
rw [category.assoc, category.assoc, comm, reassoc_of gr.w]
apply (cancel_mono z).1
simp only [category.assoc, sq.w, regular_epi.w_assoc]
simp only [← category.assoc, ht, ← sq.w, arrow.mk_hom, arrow.hom_mk'_right]
cases j <;> rfl
induction j using Opposite.rec
cases j <;> rfl
cases j <;> rfl
simp [hf]
simp [hg]
rw [← s.app_zero_eq_ι, ← s.w left, parallel_pair_map_left]
rw [← s.app_zero_eq_ι, ← s.w right, parallel_pair_map_right]
rw [← s.app_one_eq_π, ← s.w left, parallel_pair_map_left]
rw [← s.app_one_eq_π, ← s.w right, parallel_pair_map_right]
cases X
exact ι
exact ι
cases X <;> cases Y <;> cases f <;> dsimp <;> simp
· dsimp
          simp
        -- See note [dsimp, simp].
· exact w
· dsimp
          simp
cases f <;> dsimp <;> simp [w]
rw [← t.app_one_eq_ι_comp_left, ← t.app_one_eq_ι_comp_right]
rw [← t.app_zero_eq_comp_π_left, ← t.app_zero_eq_comp_π_right]
rw [s.app_one_eq_ι_comp_left, reassoc_of h]
simp only [s.app_zero_eq_comp_π_left, category.assoc, h]
erw [← s.w left, ← t.w left, ← category.assoc, fac] <;> rfl
erw [← s.w left, ← t.w left, category.assoc, fac] <;> rfl
simp only [category.assoc, t.condition]
simp only [← category.assoc, t.condition]
cases j <;> cases j' <;> cases g <;> dsimp <;> simp
cases j <;> cases j' <;> cases g <;> dsimp <;> simp
rw [← w, iso.inv_hom_id_assoc]
simp only [fork.of_ι_X, functor.const_obj_obj]
simp
rw [iso.comp_inv_eq, w]
simp only [cofork.of_π_X, functor.const_obj_obj]
dsimp <;> simp
simp
rw [ι_colim_map_assoc, parallel_pair_hom_app_one, coequalizer.π_desc]
simp
simp only [← G.map_comp, equalizer.condition]
simp only [← G.map_comp, w]
simp only [← G.map_comp, coequalizer.condition]
simp only [← G.map_comp, w]
simp
dsimp
rw [category.assoc, ← s.condition]
apply category.comp_id
simp [← hm]
simp [reassoc_of c.condition]
apply hm.right_cancellation <;> simp [s.condition]
apply fork.is_limit.hom_ext i <;> rw [fork.ι_of_ι] at hm <;> rw [hm] <;> exact l.2.symm
simp [hf]
simp
dsimp
rw [← category.assoc, ← s.condition, category.id_comp]
simp [← hm]
simp
apply cofork.is_colimit.hom_ext i <;> rw [cofork.π_of_π] at hm <;> rw [hm] <;> exact l.2.symm
simp [hf]
cases F
cases F'
cases hI
simp at hm
dsimp at F_fac' F'_fac'
congr
· assumption
· skip
    apply (cancel_mono F_m).1
    rw [F_fac', hm, F'_fac']
simp only [fac_assoc, arrow.w, is_iso.inv_comp_eq, category.assoc]
simp
simp
simp
simp
simp
simp
simp
simp [w]
simp [image_mono_iso_source]
conv => 
    lhs
    congr
    skip
    rw [← image_mono_iso_source_inv_ι f]
rw [← category.assoc, iso.hom_inv_id, category.id_comp]
apply mono_comp
      e
rw [category.id_comp]
rw [← t, category.assoc]
rw [equalizer.condition g h]
rw [← category.assoc, t]
rw [category.id_comp]
rw [← image.fac f] at E
skip
exact epi_of_epi (factor_thru_image f) (image.ι f)
rw [← image.fac f]
apply epi_comp
simp [image.eq_to_hom]
simp [image.eq_to_hom]
simp [image.pre_comp]
simp [image.pre_comp]
apply mono_of_mono _ (image.ι g)
simp only [image.pre_comp_ι]
infer_instance
apply (cancel_mono (image.ι h)).1
simp [image.pre_comp, image.eq_to_hom]
apply epi_of_epi_fac (image.factor_thru_image_pre_comp _ _)
exact epi_comp _ _
infer_instance
simp
simp [map_ι]
erw [← cancel_mono (inv sq).right, category.assoc, ← mono_factorisation.of_arrow_iso_m,
          image.lift_fac, category.assoc, ← comma.comp_right, is_iso.hom_inv_id, comma.id_right,
          category.comp_id]
simp only [image_map.map_ι, image_map.map_ι_assoc, comma.comp_right, category.assoc]
simp only [image_map.map_ι]
simp
simp
congr
congr
simp
rw [F.to_mono_factorisation.fac, G.fac]
rw [← is_image.e_iso_ext_hom F.to_mono_is_image hF']
apply strong_epi_comp
simp
simp only [image.fac_lift_assoc, pullback.lift_fst]
apply ext_aux
intro X Y
rw [← @has_zero_morphisms.comp_zero _ _ I X X (@has_zero_morphisms.has_zero _ _ J X X).zero]
rw [@has_zero_morphisms.zero_comp _ _ J]
rw [← zero_comp, cancel_mono] at h
exact h
rw [← comp_zero, cancel_epi] at h
exact h
rw [← image.fac f, w, has_zero_morphisms.comp_zero]
rw [← id_comp f, ← id_comp default, h, zero_comp, zero_comp]
rw [← comp_id f, ← comp_id default, h, comp_zero, comp_zero]
simp
simp
subst h
apply of_mono_zero X Y
subst h
apply of_epi_zero X Y
rw [iff_id_eq_zero]
constructor
· intro h
    rw [← category.id_comp f, h, zero_comp]
· intro h
    rw [← is_split_mono.id f]
    simp [h]
rw [iff_id_eq_zero]
constructor
· intro h
    rw [← category.comp_id f, h, comp_zero]
· intro h
    rw [← is_split_epi.id f]
    simp [h]
have hf := i.eq_zero_of_tgt f
subst hf
exact is_zero.of_mono_zero X Y
have hf := i.eq_zero_of_src f
subst hf
exact is_zero.of_epi_zero X Y
rw [category.assoc]
congr
apply hO.eq_of_src
rw [← category.assoc]
congr
apply hO.eq_of_tgt
dsimp only [Zero.zero]
rw [category.assoc]
congr
dsimp only [Zero.zero]
rw [← category.assoc]
congr
simp only [iso.hom_inv_id, id_comp, comp_id]
simp only [iso.hom_inv_id_assoc, id_comp, comp_id]
rw [zero_of_target_iso_zero g i, zero_of_target_iso_zero h i]
rw [zero_of_source_iso_zero g i, zero_of_source_iso_zero h i]
simp
simp
subst h
apply iso_zero_of_mono_zero ‹_›
subst h
apply iso_zero_of_epi_zero ‹_›
cases P
rw [← P.hom_inv_id]
rw [← category.id_comp P.inv]
simp
simp
rw [zero_of_source_iso_zero f i]
exact (is_iso_zero_equiv_iso_zero _ _).invFun ⟨i, j⟩
congr
congr
simp [h]
simp [h]
rw [← image.lift_fac (mono_factorisation_zero X Y)]
simp
rw [image.eq_fac h]
simp
simp [fst_pi_map]
simp [snd_pi_map]
simp [fst_sigma_map]
simp [snd_sigma_map]
rw [← K.w (walking_multicospan.hom.fst b)]
rfl
rw [← K.w (walking_multicospan.hom.snd b)]
rfl
rw [← app_right_eq_ι_comp_fst, ← app_right_eq_ι_comp_snd]
rw [← K.w (walking_multispan.hom.fst a)]
rfl
rw [← K.w (walking_multispan.hom.snd a)]
rfl
rw [← K.snd_app_right, ← K.fst_app_right]
intro S m hm
apply uniq
intro i
apply hm
rw [← F.map_comp, q.condition, F.map_comp]
rw [← F.map_comp, q.right_section_π, F.map_id]
rw [← F.map_comp, q.left_section_bottom, F.map_id]
rw [← F.map_comp, q.left_section_top, F.map_comp]
dsimp
rw [← t.left_section_top_assoc, s.condition, t.left_section_bottom_assoc]
simp [← hm]
erw [fork.condition, has_zero_morphisms.comp_zero]
simp [fork.app_one_eq_ι_comp_right]
rw [w, has_zero_morphisms.comp_zero]
rw [← h, w]
cases j
· exact fac s
· simp
simp [hh]
rw [← cancel_mono g] <;> simp [← hh, s.condition]
apply fork.is_limit.hom_ext i <;> rw [fork.ι_of_ι] at hm <;> rw [hm] <;> exact l.2.symm
rw [← cancel_mono g, category.assoc, ← hh]
simp
simp [← hfg]
simp only [kernel_fork.ι_of_ι, fork.is_limit.lift_ι]
simp [← w]
refine' (cancel_mono q.hom).1 _
simp [w]
simp
simp
simp [h]
induction h
simp
induction h
simp
simp [← h, he]
induction h
simp
simp [h, he]
induction h
simp
skip
infer_instance
rw [← cancel_mono g]
simp
simp
simp
simp
simp
simp
rw [hf _ _ (kernel_fork.condition s), zero_comp]
simp [← i.comp_inv_eq.2 h.symm]
simp [← h]
simp
simp [← i.comp_inv_eq.2 h.symm]
simp [← h]
cases j
· exact (iso.eq_inv_comp i).2 h
· simp
simp [← h]
rw [cofork.condition, zero_comp]
simp [cofork.app_zero_eq_comp_π_right]
rw [w, zero_comp]
rw [← h, w]
cases j
· simp
· exact fac s
rw [hh] <;> simp
apply hg.left_cancellation
rw [← category.assoc, ← hh, s.condition]
simp
apply cofork.is_colimit.hom_ext i <;> rw [cofork.π_of_π] at hm <;> rw [hm] <;> exact l.2.symm
rw [← cancel_epi g, ← category.assoc, ← hh]
simp
simp [← hfg]
simp only [cokernel_cofork.π_of_π, cofork.is_colimit.π_desc]
simp [reassoc_of w]
refine' (cancel_mono q.hom).1 _
simp [w]
simp
simp
simp [h]
induction h
simp
induction h
simp
simp [h, he]
induction h
simp
simp [← h, he]
induction h
simp
skip
infer_instance
simp
rw [← category.assoc, cokernel_cofork.condition]
simp
rw [← category.assoc, cokernel.condition]
simp
rw [← cancel_epi f, ← category.assoc]
simp
rw [← cancel_mono F.m, zero_comp, category.assoc, F.fac, kernel.condition]
have w := cokernel.condition f
conv at w => 
          lhs
          congr
          rw [← image.fac f]
rw [← has_zero_morphisms.comp_zero (limits.factor_thru_image f), category.assoc,
          cancel_epi] at w
exact w
conv => 
          lhs
          congr
          rw [← image.fac f]
rw [category.assoc, cokernel.condition, has_zero_morphisms.comp_zero]
simp
rw [hf _ _ (cokernel_cofork.condition s), comp_zero]
simp [i.eq_inv_comp.2 h]
simp [← h]
simp
simp [i.eq_inv_comp.2 h]
simp [← h]
cases j
· simp
· exact h
simp [← h]
simp only [← G.map_comp, kernel.condition, functor.map_zero]
simp only [← G.map_comp, w, functor.map_zero]
rw [← G.map_comp, hpq, G.map_comp]
rw [← G.map_comp, kernel.condition, G.map_zero]
rw [← G.map_comp, kernel.condition, G.map_zero]
simp only [← G.map_comp] <;> exact G.congr_map (kernel.lift_ι _ _ _).symm
simp only [← G.map_comp, cokernel.condition, functor.map_zero]
simp only [← G.map_comp, w, functor.map_zero]
rw [← G.map_comp, hpq, G.map_comp]
rw [← G.map_comp, cokernel.condition, G.map_zero]
rw [← G.map_comp, cokernel.condition, G.map_zero]
simp only [← G.map_comp] <;> exact G.congr_map (cokernel.π_desc _ _ _)
infer_instance
infer_instance
cases P
cases Q
congr
rw [← cancel_mono f₂, assoc, assoc, big_k.w]
rw [small_k.w_assoc]
refine' ⟨_, _, _, _⟩
apply (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).1
rw [← cancel_mono f₂, assoc, s.condition, assoc]
apply (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).2.1
apply (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).2.2
intro m m₁ m₂
apply small_k.is_limit.hom_ext
refine' (pullback_cone.mk a b _ : pullback_cone f₁ _).equalizer_ext _ _
· exact m₁.trans (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).2.1.symm
· exact m₂.trans (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).2.2.symm
simp
simp
simp [h.w]
rw [←
    show _ = a from
      (category.comp_id _).symm.trans
        ((is_kernel_pair.id_of_mono f).IsLimit.cone_point_unique_up_to_iso_inv_comp h.is_limit
          walking_cospan.left)]
infer_instance
cases f
exact g
cases g
apply hom.term _
cases j <;> simp
simp only [eq_iff_true_of_subsingleton]
cases j <;> simp
simp only [eq_iff_true_of_subsingleton]
cases f
exact g
cases g
apply hom.init _
apply limit.w (wide_pullback_shape.wide_cospan _ _ _) (wide_pullback_shape.hom.term j)
simp
rfl
simp
rfl
apply colimit.w (wide_pushout_shape.wide_span _ _ _) (wide_pushout_shape.hom.init j)
simp
rfl
simp
rfl
rw [← category.assoc]
simp
decide
decide
decide
decide
rw [← assoc, is_iso.hom_inv_id]
cases h
rfl
rw [assoc, is_iso.inv_hom_id]
rw [← F.map_comp, adj.right_triangle_components]
apply F.map_id
infer_instance
infer_instance
simp
rw [ht.fac]
trace
      "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `discrete_cases #[]"
simp [t.ι_π]
simp
rw [ht.fac]
trace
      "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `discrete_cases #[]"
simp [t.ι_π]
refine' equivOfSubsingletonOfSubsingleton (fun hc => ⟨_, _⟩) fun hc => ⟨_, _⟩
· let this := is_limit.of_iso_limit hc.is_limit (bicone.whisker_to_cone c g)
    let this := (is_limit.postcompose_hom_equiv (discrete.functor_comp f g).symm _) this
    exact is_limit.of_whisker_equivalence (discrete.equivalence g) this
· let this := is_colimit.of_iso_colimit hc.is_colimit (bicone.whisker_to_cocone c g)
    let this := (is_colimit.precompose_hom_equiv (discrete.functor_comp f g) _) this
    exact is_colimit.of_whisker_equivalence (discrete.equivalence g) this
· apply is_limit.of_iso_limit _ (bicone.whisker_to_cone c g).symm
    apply (is_limit.postcompose_hom_equiv (discrete.functor_comp f g).symm _).symm _
    exact is_limit.whisker_equivalence hc.is_limit (discrete.equivalence g)
· apply is_colimit.of_iso_colimit _ (bicone.whisker_to_cocone c g).symm
    apply (is_colimit.precompose_hom_equiv (discrete.functor_comp f g) _).symm _
    exact is_colimit.whisker_equivalence hc.is_colimit (discrete.equivalence g)
simp [biproduct.ι_π]
simp [biproduct.ι_π, h]
simp [biproduct.iso_product]
simp [iso.inv_comp_eq]
simp [biproduct.iso_coproduct]
simp [← iso.eq_comp_inv]
simp
simp
refine' biproduct.hom_ext _ _ fun j => _
rw [category.assoc, biproduct.to_subtype_π, biproduct.from_subtype_π_subtype, category.id_comp]
simp
intro m hm
rw [← hm, kernel_fork.ι_of_ι, category.assoc, biproduct.from_subtype_to_subtype]
exact (category.comp_id _).symm
simp
intro m hm
rw [← hm, cokernel_cofork.π_of_π, ← category.assoc, biproduct.from_subtype_to_subtype]
exact (category.id_comp _).symm
simp [biproduct.components]
refine' biproduct.hom_ext' _ _ fun j => hb.is_limit.hom_ext fun j' => _
trace
    "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `discrete_cases #[]"
rw [category.assoc, is_limit.cone_point_unique_up_to_iso_inv_comp, bicone.to_cone_π_app,
    biproduct.bicone_π, biproduct.ι_desc, biproduct.ι_π, b.to_cone_π_app, b.ι_π]
rw [← biproduct.cone_point_unique_up_to_iso_hom f hb, ←
      biproduct.cone_point_unique_up_to_iso_inv f hb, iso.hom_inv_id]
rw [← biproduct.cone_point_unique_up_to_iso_hom f hb, ←
      biproduct.cone_point_unique_up_to_iso_inv f hb, iso.inv_hom_id]
congr
congr
simp [bicone.ι_π]
rfl
simp [bicone.ι_π]
simp [bicone.ι_π]
simp [bicone.ι_π]
rfl
dsimp only
simp
dsimp only
simp
dsimp only
simp
dsimp only
simp
apply biprod.hom_ext <;> simp [iso.inv_comp_eq]
apply biprod.hom_ext' <;> simp [← iso.eq_comp_inv]
rw [biprod.map_eq_map']
exact is_colimit.ι_map (binary_biproduct.is_colimit W X) _ _ ⟨walking_pair.left⟩
rw [biprod.map_eq_map']
exact is_colimit.ι_map (binary_biproduct.is_colimit W X) _ _ ⟨walking_pair.right⟩
rw [← biprod.cone_point_unique_up_to_iso_hom X Y hb, ←
      biprod.cone_point_unique_up_to_iso_inv X Y hb, iso.hom_inv_id]
rw [← biprod.cone_point_unique_up_to_iso_hom X Y hb, ←
      biprod.cone_point_unique_up_to_iso_inv X Y hb, iso.inv_hom_id]
apply binary_fan.is_limit.hom_ext i <;> simp
simp [← hm]
apply binary_fan.is_limit.hom_ext i <;> simp
simp [← hm]
apply binary_cofan.is_colimit.hom_ext i <;> simp
simp [← hm]
apply binary_cofan.is_colimit.hom_ext i <;> simp
simp [← hm]
apply CategoryTheory.Limits.biprod.hom_ext <;>
      simp only [category.assoc, biprod.inl_fst, category.comp_id, category.id_comp, biprod.inl_snd,
        comp_zero]
apply hY.eq_of_tgt
apply CategoryTheory.Limits.biprod.hom_ext <;>
      simp only [category.assoc, biprod.inr_snd, category.comp_id, category.id_comp, biprod.inr_fst,
        comp_zero]
apply hY.eq_of_tgt
simp
rw [← biprod.braiding_map_braiding]
infer_instance
rw [hI.hom_ext f (hI.to X)]
apply initial_mono_class.is_initial_mono_from
simp
simp
simp
dsimp [cospan_ext]
simp
dsimp [cospan_ext]
simp
dsimp [cospan_ext]
simp
dsimp [cospan_ext]
simp
dsimp [cospan_ext]
simp
dsimp [cospan_ext]
simp
dsimp [cospan_ext]
simp
dsimp [cospan_ext]
simp
dsimp [cospan_ext]
simp
dsimp [span_ext]
simp
dsimp [span_ext]
simp
dsimp [span_ext]
simp
dsimp [span_ext]
simp
dsimp [span_ext]
simp
dsimp [span_ext]
simp
dsimp [span_ext]
simp
dsimp [span_ext]
simp
dsimp [span_ext]
simp
rw [← s.w inl, ← t.w inl, ← category.assoc]
congr
exact fac_left s
rw [← t.w inl, reassoc_of h₀]
simp [← cancel_mono f, t.condition, reassoc_of i]
simp [← cancel_mono g, ← t.condition, reassoc_of i]
rw [← cancel_mono f, category.comp_id, s.condition]
simp only [category.assoc, hxh, hyh, s.condition]
rw [← hxh, ← hyh, reassoc_of t.condition]
rw [← category.assoc, ← category.assoc, s.condition]
simp [← s.w fst, ← t.w fst, fac_left s]
rw [← t.w fst, category.assoc, category.assoc, h₀]
simp [← cancel_epi f, t.condition_assoc, i]
simp [← cancel_epi g, ← t.condition_assoc, i]
rw [← cancel_epi f, category.id_comp, s.condition]
rw [reassoc_of hhx, reassoc_of hhy, s.condition]
rw [← hhx, ← hhy, category.assoc, category.assoc, t.condition]
rw [category.assoc, category.assoc, s.condition]
simp [← eq₁, ← eq₂, pullback.condition_assoc]
simp only [← category.assoc, eq₁, eq₂]
simp [pushout.condition]
simp
simp
simp
simp
simp [h₁]
simp [h₂]
simp [h₁]
simp [h₂]
apply pullback.hom_ext
· erw [pullback.lift_fst]
    rw [iso.inv_comp_eq]
    erw [pullback.lift_fst_assoc]
    rw [category.comp_id, category.comp_id]
· erw [pullback.lift_snd]
    rw [iso.inv_comp_eq]
    erw [pullback.lift_snd_assoc]
    rw [category.comp_id, category.comp_id]
simp [h₁]
simp [h₂]
simp [h₁]
simp [h₂]
apply pushout.hom_ext
· erw [pushout.inl_desc]
    rw [iso.comp_inv_eq, category.id_comp]
    erw [pushout.inl_desc]
    rw [category.id_comp]
· erw [pushout.inr_desc]
    rw [iso.comp_inv_eq, category.id_comp]
    erw [pushout.inr_desc]
    rw [category.id_comp]
simp only [← G.map_comp, pullback.condition]
simp only [← G.map_comp, w]
simp only [← G.map_comp, pushout.condition]
simp only [← G.map_comp, w]
simp [pullback_symmetry]
simp [pullback_symmetry]
simp [iso.inv_comp_eq]
simp [iso.inv_comp_eq]
simp [iso.comp_inv_eq]
simp [iso.comp_inv_eq]
simp
delta pullback_cone_of_left_iso
simp
simp [← s.condition_assoc]
simp
simp
conv => 
    congr
    rw [← category.id_comp i]
infer_instance
simp
simp [s.condition_assoc]
simp
simp
conv => 
    congr
    skip
    rw [← category.id_comp i]
infer_instance
simp
delta pushout_cocone_of_left_iso
simp
simp [← s.condition]
simp
simp
conv => 
    congr
    rw [← category.comp_id h]
infer_instance
simp
delta pushout_cocone_of_right_iso
simp
simp [← s.condition]
simp
simp
conv => 
    congr
    skip
    rw [← category.comp_id h]
infer_instance
simp
simp
rw [← fst_eq_snd_of_mono_eq]
infer_instance
simp
simp
rw [← inl_eq_inr_of_epi_eq]
infer_instance
rw [← category.assoc, h₁, category.assoc, h₂, category.assoc]
rw [← s.condition, category.assoc]
rw [← hl₁', ← hl₂', category.assoc]
rfl
rw [← category.assoc, h₁, category.assoc, h₂, category.assoc]
rw [s.condition, category.assoc]
rw [← hl₁, ← hl₂, category.assoc]
rfl
rw [← category.assoc, h₁, category.assoc, h₂, category.assoc]
rw [← category.assoc, s.condition, category.assoc, category.assoc, h₂]
rw [← category.assoc, h₁, category.assoc, h₂, category.assoc]
rw [category.assoc, ← s.condition, ← category.assoc, ← category.assoc, h₁]
rw [← pullback.condition]
exact pullback_right_pullback_fst_iso_inv_fst_assoc _ _ _ _
rw [iso.comp_inv_eq, inr_pushout_left_pushout_inr_iso_hom]
rw [← category.assoc, ← iso.eq_comp_inv, inl_pushout_left_pushout_inr_iso_inv]
rw [← category.assoc, ← iso.eq_comp_inv, category.assoc, inr_pushout_left_pushout_inr_iso_inv,
    pushout.condition]
rw [pullback.lift_fst_assoc, category.assoc, category.assoc, pullback.condition]
apply pullback_cone.flip_is_limit
apply big_square_is_pullback
· apply pullback_cone.flip_is_limit
    exact pullback_is_pullback f₁ f₂
· apply pullback_cone.flip_is_limit
    apply pullback_pullback_left_is_pullback
· exact pullback.lift_fst _ _ _
· exact pullback.condition.symm
rw [pullback.lift_snd_assoc, category.assoc, category.assoc, pullback.condition]
apply big_square_is_pullback
exact pullback_is_pullback f₃ f₄
apply pullback_pullback_right_is_pullback
rw [← iso.eq_inv_comp, pullback_assoc_inv_fst_fst]
rw [iso.inv_comp_eq, pullback_assoc_hom_snd_fst]
rw [iso.inv_comp_eq, pullback_assoc_hom_snd_snd]
rw [category.assoc, pushout.inl_desc, pushout.condition_assoc]
apply big_square_is_pushout
· apply pushout_pushout_left_is_pushout
· exact pushout_is_pushout _ _
rw [category.assoc, pushout.inr_desc, pushout.condition_assoc]
apply pushout_cocone.flip_is_colimit
apply big_square_is_pushout
· apply pushout_cocone.flip_is_colimit
    apply pushout_pushout_right_is_pushout
· apply pushout_cocone.flip_is_colimit
    exact pushout_is_pushout _ _
· exact pushout.condition.symm
· exact (pushout.inr_desc _ _ _).symm
rw [iso.comp_inv_eq, category.assoc, inl_inl_pushout_assoc_hom]
rw [← category.assoc, iso.comp_inv_eq, category.assoc, inr_inl_pushout_assoc_hom]
rw [← iso.eq_comp_inv, category.assoc, inr_inr_pushout_assoc_inv]
simp
simp
simp
cases j <;> rfl
cases j <;> rfl
cases j <;> rfl
cases b <;> rfl
simp
simp [← e]
refine' Iff.trans _ (binary_fan.is_limit_iff_is_iso_fst h (binary_fan.mk c.snd c.fst))
exact
    ⟨fun h => ⟨binary_fan.is_limit_flip h.some⟩, fun h =>
      ⟨(binary_fan.is_limit_flip h.some).ofIsoLimit (iso_binary_fan_mk c).symm⟩⟩
simp [reassoc_of hl]
refine' Iff.trans _ (binary_cofan.is_colimit_iff_is_iso_inl h (binary_cofan.mk c.inr c.inl))
exact
    ⟨fun h => ⟨binary_cofan.is_colimit_flip h.some⟩, fun h =>
      ⟨(binary_cofan.is_colimit_flip h.some).ofIsoColimit (iso_binary_cofan_mk c).symm⟩⟩
simp
rw [← prod.lift_map]
simp
simp
simp
simp
simp
simp
simp
simp
rw [← coprod.map_desc]
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
rw [iso.inv_comp_eq, ← category.assoc, iso.eq_comp_inv, prod.left_unitor_hom_naturality]
rw [iso.inv_comp_eq, ← category.assoc, iso.eq_comp_inv, prod.right_unitor_hom_naturality]
simp
simp
rw [prod_comparison, prod_comparison, prod.lift_map, ← F.map_comp, ← F.map_comp, prod.comp_lift, ←
    F.map_comp, Prod.map_fst, ← F.map_comp, Prod.map_snd]
simp [prod_comparison_natural]
simp [is_iso.inv_comp_eq]
simp [is_iso.inv_comp_eq]
rw [is_iso.eq_comp_inv, category.assoc, is_iso.inv_comp_eq, prod_comparison_natural]
rw [coprod_comparison, coprod_comparison, coprod.map_desc, ← F.map_comp, ← F.map_comp,
    coprod.desc_comp, ← F.map_comp, coprod.inl_map, ← F.map_comp, coprod.inr_map]
simp [coprod_comparison_natural]
simp [is_iso.inv_comp_eq]
simp [is_iso.inv_comp_eq]
rw [is_iso.eq_comp_inv, category.assoc, is_iso.inv_comp_eq, coprod_comparison_natural]
dsimp
rw [coprod.map_desc, category.id_comp, over.w k]
rw [prod.lift_fst]
rw [kernel.condition_assoc]
rw [prod.lift_snd]
rw [kernel.condition_assoc]
simp at ha' hb'
rw [ha', hb']
simp only [prod.lift_fst, category.assoc]
rw [pullback_cone.condition_assoc]
rw [haf]
rw [comp_zero, zero_comp]
simp only [prod.lift_snd, category.assoc]
rw [hbg]
rw [comp_zero, zero_comp]
rw [kernel_fork.ι_of_ι] at ha'
simp [ha', pullback_cone.condition s]
rw [kernel_fork.ι_of_ι] at hb'
simp [hb']
congr
exact ha'.symm
rw [← category.assoc, h₁]
rw [kernel.lift_ι]
rw [prod.lift_fst]
rw [pullback.condition_assoc]
rw [prod.lift_fst, category.comp_id]
rw [prod.lift_snd]
rw [pullback.condition_assoc]
rw [prod.lift_snd]
rw [hvu, ← huv]
simp only [prod.lift_fst, category.assoc]
simp only [prod.comp_lift, fork.condition]
simp only [fork.ι_of_ι, pullback.lift_fst]
simp
rw [← hm, category.assoc, hw, comp_zero]
apply is_iso_limit_cone_parallel_pair_of_eq hn.symm hl
    apply (cancel_epi (equalizer.ι u v)).1
    exact equalizer.condition _ _
rw [coprod.inl_desc_assoc]
rw [cokernel.condition]
rw [coprod.inr_desc_assoc]
rw [cokernel.condition]
simp only [cofork.π_of_π] at ha' hb'
rw [ha', hb']
rw [coprod.inl_desc_assoc]
rw [pushout_cocone.condition]
rw [reassoc_of hfa]
rw [comp_zero, zero_comp]
rw [coprod.inr_desc_assoc]
rw [reassoc_of hgb]
rw [comp_zero, zero_comp]
rw [cokernel_cofork.π_of_π] at ha'
simp [reassoc_of ha', pushout_cocone.condition s]
rw [cokernel_cofork.π_of_π] at hb'
simp [reassoc_of hb']
congr
exact ha'.symm
rw [category.assoc, h₁]
rw [cokernel.π_desc]
rw [coprod.inl_desc]
simp only [category.assoc, pushout.condition]
rw [coprod.inl_desc, category.id_comp]
rw [coprod.inr_desc]
simp only [category.assoc, pushout.condition]
rw [coprod.inr_desc]
rw [hvu, huv]
simp only [coprod.inl_desc_assoc]
simp only [coprod.desc_comp, cofork.condition]
simp only [pushout.inl_desc, cofork.π_of_π]
simp
rw [← hm, reassoc_of hw, zero_comp]
apply is_iso_colimit_cocone_parallel_pair_of_eq hn.symm hl
simp [reassoc_of hf.w]
simp
rw [← reassoc_of comm, hn.w, has_zero_morphisms.comp_zero]
simp [hf.w]
simp
rw [category.assoc, comm, reassoc_of gn.w, zero_comp]
dsimp [iso_pullback, cone, comm_sq.cone]
simp
dsimp [iso_pullback, cone, comm_sq.cone]
simp
simp [iso.inv_comp_eq]
simp [iso.inv_comp_eq]
dsimp [iso_pushout, cocone, comm_sq.cocone]
simp
dsimp [iso_pushout, cocone, comm_sq.cocone]
simp
simp [← iso.eq_comp_inv]
simp [← iso.eq_comp_inv]
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
refine'
    is_pullback.of_is_limit' (F.map_comm_sq s.to_comm_sq)
      (is_limit.equiv_of_nat_iso_of_iso (cospan_comp_iso F h i) _ _ (walking_cospan.ext _ _ _)
        (is_limit_of_preserves F s.is_limit))
· rfl
· dsimp
    simp
· dsimp
    simp
refine'
    is_pushout.of_is_colimit' (F.map_comm_sq s.to_comm_sq)
      (is_colimit.equiv_of_nat_iso_of_iso (span_comp_iso F f g) _ _ (walking_span.ext _ _ _)
        (is_colimit_of_preserves F s.is_colimit))
· rfl
· dsimp
    simp
· dsimp
    simp
apply has_limits_of_shape_of_equivalence (fin_category.equiv_as_type J)
apply has_finite_limits.out
skip
exact has_limits_of_shape J C
apply UliftHom.category.{0}
exact CategoryTheory.uliftCategory J
apply has_colimits_of_shape_of_equivalence (fin_category.equiv_as_type J)
apply has_finite_colimits.out
skip
exact has_colimits_of_shape J C
apply UliftHom.category.{0}
exact CategoryTheory.uliftCategory J
cases x <;> simp
infer_instance
infer_instance
rw [wide_pullback_shape]
infer_instance
rw [wide_pushout_shape]
infer_instance
cases x <;> simp
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
rw [this]
infer_instance
simp only [functor.image_preimage, functor.map_cone_π_app]
rw [this]
infer_instance
simp
dsimp
rw [category.assoc, ← F.map_comp]
simp
refine' (is_limit.map_cone_equiv h _).uniqueUpToIso t
apply is_limit.of_iso_limit _ (lifted_limit_maps_to_original _).symm
apply (is_limit.postcompose_inv_equiv _ _).symm t
dsimp
rw [← F.map_comp_assoc]
simp
refine' (is_colimit.map_cocone_equiv h _).uniqueUpToIso t
apply is_colimit.of_iso_colimit _ (lifted_colimit_maps_to_original _).symm
apply (is_colimit.precompose_hom_equiv _ _).symm t
rw [functor.comp_map, functor.comp_map, α.naturality]
rw [functor.comp_map, functor.comp_map, ← F.map_comp, ← F.map_comp, α.naturality]
dsimp
rw [← H.map_comp, ← H.map_comp, ← τ.naturality]
dsimp
rw [τ.naturality]
simp
simp
simp
rw [← is_iso_op_iff f.unop, Quiver.Hom.op_unop]
cases F
rfl
simp
simp
simp
simp
simp only [← unop_comp, f.inv_hom_id, unop_id]
simp only [← unop_comp, f.hom_inv_id, unop_id]
apply Quiver.Hom.unop_inj
dsimp
simp
apply Quiver.Hom.op_inj
dsimp
simp
simp
simp
rw [← Quiver.Hom.op_unop f]
exact is_iso_of_op _
rw [← A.one.naturality, tensor_unit_map]
dsimp
rw [category.id_comp]
dsimp
rw [← A.mul.naturality, tensor_obj_map]
infer_instance
intros
rfl
rw [(tensoring_left C).map_id, nat_trans.left_derived_id]
rw [(tensoring_left C).map_comp, nat_trans.left_derived_comp]
rw [(tensoring_right C).map_id, nat_trans.left_derived_id]
rw [(tensoring_right C).map_comp, nat_trans.left_derived_comp]
dsimp only [Tor', functor.flip]
exact ((tensoring_right C).obj Y).leftDerivedObjProjectiveSucc n X
dsimp [tensor_hom]
simp
dsimp [tensor_hom]
simp
rw [eq_of_hom f, eq_of_hom g]
dsimp [monoidal_comp]
simp
simp [monoidal_comp]
change X₁.1
rw [← id_tensor_comp_tensor_id, category.assoc, M.one_mul, left_unitor_naturality]
rw [← tensor_id_comp_id_tensor, category.assoc, M.mul_one, right_unitor_naturality]
simp
simp only [is_iso.comp_inv_eq, hom.mul_hom, category.assoc, ← tensor_comp_assoc,
              is_iso.inv_hom_id, tensor_id, category.id_comp]
rw [← one_f]
simp
dsimp
simp
dsimp
simp [A.one_mul, unitors_equal]
dsimp
rw [category.assoc, ← F.to_functor.map_comp, f.one_hom]
dsimp
rw [category.assoc, F.μ_natural_assoc, ← F.to_functor.map_comp, ← F.to_functor.map_comp,
          f.mul_hom]
dsimp
rw [category.id_comp, category.comp_id]
rw [F.map_id, G.map_id, tensor_id]
rw [F.map_comp, G.map_comp, tensor_comp]
dsimp
rw [← tensor_comp, α.naturality, β.naturality, tensor_comp]
dsimp
rw [left_unitor_naturality]
dsimp
rw [right_unitor_naturality]
dsimp
rw [associator_naturality]
dsimp
rw [associator_naturality]
simp
infer_instance
dsimp
rw [← associator_inv_naturality]
simp
rw [← is_iso.comp_inv_eq, category.assoc, ← is_iso.eq_inv_comp]
simp
rw [← is_iso.comp_inv_eq, category.assoc, ← is_iso.eq_inv_comp]
simp
rw [← associativity_app_assoc]
dsimp
simp
dsimp
simp
rw [← is_iso.inv_comp_eq, ← is_iso.comp_inv_eq]
simp
rw [← obj_ε_inv_app_assoc, ← functor.map_comp]
congr
simp
intro X
dsimp
simp only [μ_naturalityᵣ_assoc, μ_naturalityₗ_assoc, ε_inv_app_obj, category.assoc,
      obj_μ_inv_app, functor.map_comp, μ_inv_hom_app_assoc, obj_ε_app,
      unit_of_tensor_iso_unit_inv_app]
simp [← nat_trans.comp_app, ← F.to_functor.map_comp, ← H, -functor.map_comp]
intros
apply F.to_functor.map_injective
simp [F.map_tensor]
intros
apply F.to_functor.map_injective
simp [F.map_tensor]
intros
apply F.to_functor.map_injective
simp only [F.map_tensor, F.to_functor.map_add, preadditive.comp_add, preadditive.add_comp,
      monoidal_preadditive.tensor_add]
intros
apply F.to_functor.map_injective
simp only [F.map_tensor, F.to_functor.map_add, preadditive.comp_add, preadditive.add_comp,
      monoidal_preadditive.add_tensor]
dsimp
simp only [← tensor_comp, category.comp_id, ← tensor_sum, ← tensor_id,
                  is_bilimit.total i]
dsimp
simp only [← tensor_comp, category.comp_id, ← sum_tensor, ← tensor_id,
                  is_bilimit.total i]
cases f
cases g
congr
exact w
change is_iso (iso_mk f).Hom
infer_instance
dsimp
rw [category.assoc, category.assoc, category.assoc, category.assoc,
          id_tensor_associator_naturality_assoc, ← id_tensor_comp_assoc, half_braiding.naturality,
          id_tensor_comp_assoc, associator_inv_naturality_assoc, ← comp_tensor_id_assoc,
          half_braiding.naturality, comp_tensor_id_assoc, associator_naturality, ← tensor_id]
dsimp
rw [category.assoc, category.assoc, category.assoc, category.assoc, associator_naturality_assoc,
      ← tensor_id_comp_id_tensor, category.assoc, ← id_tensor_comp_assoc, g.comm,
      id_tensor_comp_assoc, tensor_id_comp_id_tensor_assoc, ← id_tensor_comp_tensor_id,
      category.assoc, associator_inv_naturality_assoc, id_tensor_associator_inv_naturality_assoc,
      tensor_id, id_tensor_comp_tensor_id_assoc, ← tensor_id_comp_id_tensor g.f, category.assoc, ←
      comp_tensor_id_assoc, f.comm, comp_tensor_id_assoc, id_tensor_associator_naturality,
      associator_naturality_assoc, ← id_tensor_comp, tensor_id_comp_id_tensor]
simp
dsimp
rw [left_unitor_naturality_assoc, right_unitor_inv_naturality, category.assoc]
dsimp
simp only [category.comp_id, category.assoc, tensor_inv_hom_id, comp_tensor_id,
        tensor_id_comp_id_tensor, triangle_assoc_comp_right_inv]
rw [← left_unitor_tensor, left_unitor_naturality, left_unitor_tensor'_assoc]
dsimp
simp only [tensor_id_comp_id_tensor_assoc, triangle_assoc, id_tensor_comp, category.assoc]
rw [← tensor_id_comp_id_tensor_assoc (ρ_ U).inv, cancel_epi, ← right_unitor_tensor_inv_assoc,
        ← right_unitor_inv_naturality_assoc]
simp
dsimp at i
skip
change is_iso (iso_mk f).Hom
infer_instance
dsimp
simp only [category.assoc]
rw [← is_iso.inv_comp_eq, is_iso.iso.inv_hom, ← half_braiding.monoidal_assoc, ←
        half_braiding.naturality_assoc, half_braiding.monoidal]
simp
rw [iso.eq_inv_comp, ← category.assoc, ← category.assoc, iso.eq_comp_inv, category.assoc,
          category.assoc]
exact hexagon_forward X U U'
dsimp
rw [tensor_id, category.id_comp, tensor_id, category.comp_id, ← braiding_right_unitor,
          category.assoc, iso.hom_inv_id, category.comp_id]
dsimp
rw [tensor_id, tensor_id, category.id_comp, category.comp_id, ← iso.inv_comp_eq, ←
          category.assoc, ← category.assoc, ← iso.comp_inv_eq, category.assoc, hexagon_reverse,
          category.assoc]
rw [← cancel_mono f.hom, category.assoc, category.assoc, iso.inv_hom_id, category.comp_id,
          f_left_act_hom, ← category.assoc, ← id_tensor_comp, iso.inv_hom_id,
          monoidal_category.tensor_id, category.id_comp]
rw [← cancel_mono f.hom, category.assoc, category.assoc, iso.inv_hom_id, category.comp_id,
          f_right_act_hom, ← category.assoc, ← comp_tensor_id, iso.inv_hom_id,
          monoidal_category.tensor_id, category.id_comp]
erw [map_π_preserves_coequalizer_inv_colim_map (tensor_left _)]
simp only [category.assoc]
erw [map_π_preserves_coequalizer_inv_colim_map (tensor_right _)]
simp only [category.assoc]
rw [← tensor_comp, ← tensor_comp, hom.right_act_hom, category.id_comp, category.comp_id]
dsimp
rw [category.assoc, left_assoc]
dsimp
rw [category.assoc, right_assoc, iso.hom_inv_id_assoc]
rw [← tensor_comp, category.comp_id]
rw [← tensor_comp, category.comp_id]
simp
dsimp
simp only [functor.map_comp, Functor.map_id, category.assoc]
erw [← e.counit_iso.hom.naturality]
simp only [functor.comp_map, ← e.functor.map_comp_assoc]
congr 2
rw [e.inverse.map_id, id_tensor_comp_tensor_id_assoc, ← tensor_id_comp_id_tensor_assoc,
      left_unitor_naturality]
dsimp
simp only [functor.map_comp, Functor.map_id, category.assoc]
erw [← e.counit_iso.hom.naturality]
simp only [functor.comp_map, ← e.functor.map_comp_assoc]
congr 2
rw [e.inverse.map_id, tensor_id_comp_id_tensor_assoc, ← id_tensor_comp_tensor_id_assoc,
      right_unitor_naturality]
dsimp
simp only [equivalence.inv_fun_map, functor.map_comp, tensor_comp, category.assoc]
simp only [← e.functor.map_comp]
congr 1
rw [← tensor_comp, iso.hom_inv_id_app, iso.hom_inv_id_app, ← tensor_comp]
dsimp
rw [comp_id, comp_id]
dsimp
simp only [tensor_id, assoc, id_comp, functor.map_comp, e.inverse.map_id]
rw [equivalence.counit_app_functor]
simp only [← e.functor.map_comp]
congr 1
simp only [← left_unitor_naturality, id_comp, ← tensor_comp_assoc, comp_id]
dsimp
simp only [tensor_id, assoc, id_comp, functor.map_comp, e.inverse.map_id]
rw [equivalence.counit_app_functor]
simp only [← e.functor.map_comp]
congr 1
simp only [← right_unitor_naturality, id_comp, ← tensor_comp_assoc, comp_id]
dsimp
infer_instance
dsimp
infer_instance
dsimp
infer_instance
rw [iso.inv_comp_eq, F.left_unitality, category.assoc, category.assoc, ← F.to_functor.map_comp,
    iso.hom_inv_id, F.to_functor.map_id, comp_id]
rw [iso.inv_comp_eq, F.right_unitality, category.assoc, category.assoc, ← F.to_functor.map_comp,
    iso.hom_inv_id, F.to_functor.map_id, comp_id]
rw [iso.eq_inv_comp, ← F.associativity_assoc, ← F.to_functor.map_comp, iso.hom_inv_id,
    F.to_functor.map_id, comp_id]
infer_instance
infer_instance
simp
intros
apply F.μ_iso
intros
apply F.to_lax_monoidal_functor.μ_natural
simp only [functor.comp_map, assoc]
rw [← category.assoc, lax_monoidal_functor.μ_natural, category.assoc, ← map_comp, ← map_comp,
        ← lax_monoidal_functor.μ_natural]
dsimp
rw [G.left_unitality, comp_tensor_id, category.assoc, category.assoc]
apply congr_arg
rw [F.left_unitality, map_comp, ← nat_trans.id_app, ← category.assoc, ←
        lax_monoidal_functor.μ_natural, nat_trans.id_app, map_id, ← category.assoc, map_comp]
dsimp
rw [G.right_unitality, id_tensor_comp, category.assoc, category.assoc]
apply congr_arg
rw [F.right_unitality, map_comp, ← nat_trans.id_app, ← category.assoc, ←
        lax_monoidal_functor.μ_natural, nat_trans.id_app, map_id, ← category.assoc, map_comp]
dsimp [prod']
simp
dsimp [prod']
simp
dsimp
infer_instance
dsimp
infer_instance
rw [← h.hom_equiv_naturality_left, ← h.hom_equiv_naturality_right, Equiv.apply_eq_iff_eq, assoc,
      is_iso.eq_inv_comp, ← F.to_lax_monoidal_functor.μ_natural_assoc, is_iso.hom_inv_id_assoc, ←
      tensor_comp, adjunction.counit_naturality, adjunction.counit_naturality, tensor_comp]
rw [← h.hom_equiv_naturality_right, ← h.hom_equiv_naturality_left, ← Equiv.symm_apply_eq,
      h.hom_equiv_counit, F.map_left_unitor, h.hom_equiv_unit, assoc, assoc, assoc, F.map_tensor,
      assoc, assoc, is_iso.hom_inv_id_assoc, ← tensor_comp_assoc, Functor.map_id, id_comp,
      functor.map_comp, assoc, h.counit_naturality, h.left_triangle_components_assoc, ←
      left_unitor_naturality, ← tensor_comp_assoc, id_comp, comp_id]
rw [← h.hom_equiv_naturality_right, ← h.hom_equiv_naturality_left, ← Equiv.symm_apply_eq,
      h.hom_equiv_counit, F.map_right_unitor, assoc, assoc, ← right_unitor_naturality, ←
      tensor_comp_assoc, comp_id, id_comp, h.hom_equiv_unit, F.map_tensor, assoc, assoc, assoc,
      is_iso.hom_inv_id_assoc, functor.map_comp, Functor.map_id, ← tensor_comp_assoc, assoc,
      h.counit_naturality, h.left_triangle_components_assoc, id_comp]
dsimp [equivalence.to_adjunction]
infer_instance
dsimp [equivalence.to_adjunction]
infer_instance
simp
simp
intro X Y f
dsimp
rw [left_unitor_inv_naturality_assoc, category.assoc, iso.cancel_iso_inv_left]
exact
        congr_arg (fun f => nat_trans.app f (discrete.mk normal_monoidal_object.unit))
          ((normalizeIso.{u} C).Hom.naturality f)
have : (fullNormalize C).map f = (fullNormalize C).map g := Subsingleton.elim _ _
rw [← functor.id_map f, ← functor.id_map g]
simp [← nat_iso.naturality_2 (fullNormalizeIso.{u} C), this]
intro f f' hf g g' hg
exact comp hf hg
intro _ _ h _ _ h'
exact hom_equiv.tensor h h'
simp [comp_right_adjoint_mate]
dsimp
rw [category.comp_id, functor.map_inv, ← id_tensor_comp_tensor_id, category.assoc,
              right_adjoint_mate_comp_evaluation, ← category.assoc, ← id_tensor_comp,
              is_iso.hom_inv_id, tensor_id, category.id_comp]
dsimp
rw [functor.map_inv, category.id_comp, ← id_tensor_comp_tensor_id, ← category.assoc,
              coevaluation_comp_right_adjoint_mate, category.assoc, ← comp_tensor_id,
              is_iso.inv_hom_id, tensor_id, category.comp_id]
simp [comp_left_adjoint_mate]
dsimp
rw [category.comp_id, functor.map_inv, ← tensor_id_comp_id_tensor, category.assoc,
              left_adjoint_mate_comp_evaluation, ← category.assoc, ← comp_tensor_id,
              is_iso.hom_inv_id, tensor_id, category.id_comp]
dsimp
rw [functor.map_inv, category.id_comp, ← tensor_id_comp_id_tensor, ← category.assoc,
              coevaluation_comp_left_adjoint_mate, category.assoc, ← id_tensor_comp,
              is_iso.inv_hom_id, tensor_id, category.comp_id]
simp only [right_adjoint_mate, monoidal_category.tensor_id, category.id_comp,
    coevaluation_evaluation_assoc, category.comp_id, iso.inv_hom_id]
simp only [left_adjoint_mate, monoidal_category.tensor_id, category.id_comp,
    evaluation_coevaluation_assoc, category.comp_id, iso.inv_hom_id]
dsimp only [right_adjoint_mate]
rw [category.assoc, category.assoc, associator_inv_naturality_assoc,
    associator_inv_naturality_assoc, ← tensor_id_comp_id_tensor g, category.assoc, category.assoc,
    category.assoc, category.assoc, id_tensor_comp_tensor_id_assoc, ← left_unitor_naturality,
    tensor_id_comp_id_tensor_assoc]
dsimp only [left_adjoint_mate]
rw [category.assoc, category.assoc, associator_naturality_assoc, associator_naturality_assoc, ←
    id_tensor_comp_tensor_id _ g, category.assoc, category.assoc, category.assoc, category.assoc,
    tensor_id_comp_id_tensor_assoc, ← right_unitor_naturality, id_tensor_comp_tensor_id_assoc]
dsimp [tensor_left_hom_equiv]
simp only [id_tensor_comp, category.assoc]
dsimp [tensor_left_hom_equiv]
simp only [id_tensor_comp, category.assoc]
dsimp [tensor_right_hom_equiv]
simp only [comp_tensor_id, category.assoc]
dsimp [tensor_right_hom_equiv]
simp only [comp_tensor_id, category.assoc]
dsimp [tensor_left_hom_equiv, right_adjoint_mate]
simp
dsimp [tensor_right_hom_equiv, left_adjoint_mate]
simp
dsimp [tensor_left_hom_equiv, left_adjoint_mate]
simp
dsimp [tensor_right_hom_equiv, right_adjoint_mate]
simp
rw [← comp_right_adjoint_mate, category.comp_id, right_adjoint_mate_id]
rw [← comp_right_adjoint_mate, category.comp_id, right_adjoint_mate_id]
rw [← comp_left_adjoint_mate, category.comp_id, left_adjoint_mate_id]
rw [← comp_left_adjoint_mate, category.comp_id, left_adjoint_mate_id]
simp [map_eval, map_coeval, monoidal_functor.map_tensor]
simp [map_eval, map_coeval, monoidal_functor.map_tensor]
simp
simp
apply exact_pairing_of_fully_faithful F _ _
apply exact_pairing_congr_left (F.to_functor.as_equivalence.counit_iso.app _)
dsimp
infer_instance
apply exact_pairing_of_fully_faithful F _ _
apply exact_pairing_congr_right (F.to_functor.as_equivalence.counit_iso.app _)
dsimp
infer_instance
dsimp [tensor_hom]
simp
dsimp [monoidal_of_has_finite_products]
simp
dsimp [monoidal_of_has_finite_products]
simp
dsimp
simp
rfl
dsimp [tensor_hom]
simp
dsimp [monoidal_of_has_finite_coproducts]
simp
dsimp [monoidal_of_has_finite_coproducts]
simp
dsimp
simp
rfl
dsimp
simp only [category.id_comp, ← tensor_comp, limit.w]
dsimp
simp only [category.id_comp, ← tensor_comp, limit.w]
rw [← tensor_comp, iso.hom_inv_id, iso.hom_inv_id, ← tensor_id]
rw [← tensor_comp, iso.inv_hom_id, iso.inv_hom_id, ← tensor_id]
rw [← tensor_comp]
simp
rw [← tensor_comp]
simp
rw [← tensor_comp]
simp
rw [← tensor_comp]
simp
rw [← right_unitor_naturality_assoc, iso.hom_inv_id, category.comp_id]
rw [← left_unitor_naturality_assoc, iso.hom_inv_id, category.comp_id]
simp
simp
simp
simp
simp [pentagon]
simp
rw [← triangle, iso.inv_hom_id_assoc]
rw [comp_inv_eq, assoc, associator_naturality]
simp
rw [associator_inv_naturality, hom_inv_id_assoc]
rw [associator_naturality, inv_hom_id_assoc]
rw [← tensor_id, associator_naturality]
rw [← tensor_id, associator_inv_naturality]
rw [← tensor_comp, f.hom_inv_id, id_tensor_comp]
rw [← tensor_comp, f.inv_hom_id, id_tensor_comp]
rw [← tensor_comp, f.hom_inv_id, comp_tensor_id]
rw [← tensor_comp, f.inv_hom_id, comp_tensor_id]
rw [← tensor_comp, is_iso.hom_inv_id, id_tensor_comp]
rw [← tensor_comp, is_iso.inv_hom_id, id_tensor_comp]
rw [← tensor_comp, is_iso.hom_inv_id, comp_tensor_id]
rw [← tensor_comp, is_iso.inv_hom_id, comp_tensor_id]
intros
apply monoidal_category.associator
intros
apply monoidal_category.associator_naturality
intros
apply monoidal_category.left_unitor
intros
apply monoidal_category.left_unitor_naturality
intros
apply monoidal_category.right_unitor
intros
apply monoidal_category.right_unitor_naturality
dsimp
rw [← tensor_id]
apply associator_naturality
simp [tensor_left_tensor]
dsimp
rw [← tensor_id]
apply associator_inv_naturality
simp [tensor_right_tensor]
cases X
rfl
cases X
rfl
cases X
rfl
cases X
rfl
cases X
rfl
cases X
rfl
cases X
rfl
cases X
rfl
intros
apply F.to_functor.map_injective
refine' (cancel_epi (F.μ _ _)).1 _
rw [functor.map_comp, ← lax_monoidal_functor.μ_natural_assoc, w, functor.map_comp, reassoc_of w,
      braiding_naturality_assoc, lax_monoidal_functor.μ_natural]
rw [← left_unitor_tensor, left_unitor_naturality]
simp
rw [braiding_left_unitor_aux₁]
rw [iso.hom_inv_id, comp_id]
rw [triangle]
rw [← tensor_right_iff, comp_tensor_id, braiding_left_unitor_aux₂]
rw [← right_unitor_tensor, right_unitor_naturality]
simp
rw [braiding_right_unitor_aux₁]
rw [iso.hom_inv_id, comp_id]
rw [triangle_assoc_comp_right]
rw [← tensor_left_iff, id_tensor_comp, braiding_right_unitor_aux₂]
apply (cancel_mono (ρ_ X).Hom).1
simp only [assoc, braiding_right_unitor, iso.inv_hom_id]
simp
rw [F.braided]
simp
dsimp [tensor_μ]
simp
dsimp [tensor_μ]
simp
dsimp [tensor_μ]
infer_instance
intros
apply Quiver.Hom.unop_inj
simp
intros
apply Quiver.Hom.unop_inj
simp
intros
apply Quiver.Hom.unop_inj
simp
intros
apply unmop_inj
simp
intros
apply unmop_inj
simp
intros
apply unmop_inj
simp
dsimp
rw [← Unit, assoc, iso.hom_inv_id, comp_id]
dsimp
rw [iso.comp_inv_eq, assoc, tensor, ← tensor_comp_assoc, iso.inv_hom_id, iso.inv_hom_id,
          tensor_id, id_comp]
simp [of_components]
intros
dsimp
infer_instance
dsimp
simp only [category.comp_id, category.assoc, functor.map_inv, functor.map_comp,
        nat_iso.inv_inv_app, is_iso.inv_comp, is_equivalence.fun_inv_map, adjunction.hom_equiv_unit]
erw [e.counit_app_functor, ← e.functor.map_comp_assoc, iso.hom_inv_id_app]
dsimp
simp
dsimp
simp only [adjunction.hom_equiv_unit, adjunction.hom_equiv_naturality_right, category.assoc,
        category.comp_id, functor.map_comp]
simp only [is_equivalence.fun_inv_map]
erw [e.counit_app_functor]
simp only [category.assoc]
erw [← e.functor.map_comp_assoc]
simp only [CategoryTheory.Iso.inv_hom_id_app, CategoryTheory.Iso.inv_hom_id_app_assoc]
erw [iso.hom_inv_id_app]
erw [CategoryTheory.Functor.map_id]
simp only [category.id_comp]
simp only [CategoryTheory.Iso.inv_hom_id_app, CategoryTheory.IsIso.hom_inv_id_assoc]
erw [iso.inv_hom_id_app]
dsimp
simp
rfl
intros
dsimp
infer_instance
dsimp
rw [braiding_left_unitor, unitors_equal]
dsimp
rw [category.id_comp, category.comp_id]
rw [← is_separating_op_iff, Set.unop_op]
rw [← is_coseparating_op_iff, Set.unop_op]
rw [← is_codetecting_op_iff, Set.unop_op]
rw [← is_detecting_op_iff, Set.unop_op]
simp
rw [is_separator, is_coseparator, ← is_separating_op_iff, Set.singleton_op]
rw [is_separator, is_coseparator, ← is_coseparating_op_iff, Set.singleton_op]
rw [is_separator, is_coseparator, ← is_coseparating_unop_iff, Set.singleton_unop]
rw [is_separator, is_coseparator, ← is_separating_unop_iff, Set.singleton_unop]
rw [is_detector, is_codetector, ← is_detecting_op_iff, Set.singleton_op]
rw [is_detector, is_codetector, ← is_codetecting_op_iff, Set.singleton_op]
rw [is_detector, is_codetector, ← is_codetecting_unop_iff, Set.singleton_unop]
rw [is_detector, is_codetector, ← is_detecting_unop_iff, Set.singleton_unop]
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
exact @is_iso_of_reflects_iso _ _ _ _ _ _ _ (coyoneda.obj (op G)) _ h
exact @is_iso_of_reflects_iso _ _ _ _ _ _ _ (yoneda.obj G) _ h
rw [iso.hom_inv_id, category.comp_id]
rw [category.assoc, ← w]
rw [iso.inv_hom_id, category.id_comp]
cases α <;> rfl
rw [← trans_assoc, symm_self_id, refl_trans]
rw [← trans_assoc, self_symm_id, refl_trans]
simp [H.symm]
simp [H]
simp [H.symm]
simp [H]
rw [ext h]
rw [← eq_inv_comp, comp_id]
rw [← eq_comp_inv, id_comp]
erw [inv_eq_inv α.symm β, eq_comm]
rfl
rw [← is_iso.inv_hom_id_assoc f g, w, is_iso.inv_hom_id_assoc f h]
rw [← category.comp_id g, ← category.comp_id h, ← is_iso.hom_inv_id f, ← category.assoc, w, ←
      category.assoc]
apply (cancel_epi f).mp
simp [hom_inv_id]
apply (cancel_mono f).mp
simp [inv_hom_id]
simp
simp
rw [← id_comp g, ← inv_hom_id f, assoc]
infer_instance
rw [← comp_id f, ← hom_inv_id g, ← assoc]
infer_instance
apply (cancel_epi (inv f)).1
erw [inv_hom_id, p, inv_hom_id]
rw [(hom_comp_eq_id _).mp h]
infer_instance
rw [(comp_hom_eq_id _).mp h]
infer_instance
simp only [cancel_epi]
simp only [cancel_epi]
simp only [cancel_mono]
simp only [cancel_mono]
simp only [← category.assoc, cancel_mono]
simp only [← category.assoc, cancel_mono]
rw [← map_comp, iso.hom_inv_id, ← map_id]
rw [← map_comp, iso.inv_hom_id, ← map_id]
simp
simp
rfl
apply Quiver.Path.comp_cons
      rw [this]
      simp only
      rw [ih, category.assoc]
dsimp [Quiver.Hom.toPath, lift]
simp
simp
simp
cases X
rfl
intros
cases X
cases Y
induction f
dsimp
simp only [category.comp_id, category.id_comp]
apply Quot.sound
apply quotient.comp_closure.of
simp [paths_hom_rel]
intros
cases X
dsimp
simp
rfl
rw [Functor.map_id, category.comp_id, category.id_comp]
erw [nat_trans.id_app, category.comp_id, category.id_comp]
simp only [category.comp_id, category.id_comp]
simp [hX]
simp [hY]
dsimp
simp
dsimp
simp
simp
simp
dsimp
infer_instance
dsimp
infer_instance
dsimp
infer_instance
rw [← reassoc_of hX, hd, category.assoc]
rw [← reassoc_of hY, hd', category.assoc]
rw [functor.map_comp, ← reassoc_of h, this]
simp
cases X <;> rfl
cases X <;> rfl
infer_instance
infer_instance
infer_instance
apply Nonempty.intro
rw [this]
infer_instance
cases F
rfl
cases F₁
cases F₂
exact Eq
simp only [← functor.assoc, localization.construction.fac, h₂.fac,
                    functor.comp_id]
simp only [← functor.assoc, h₂.fac, localization.construction.fac,
                    functor.comp_id]
rw [whiskering_left_functor'_eq]
infer_instance
rw [whiskering_left_functor'_eq]
infer_instance
simp only [nat_trans.comp_app, lift_nat_trans_app, assoc, iso.inv_hom_id_app_assoc]
intro X Y f
simp only [functor.comp_map, eq_to_hom_refl, comp_id, id_comp]
dsimp [lift, lift_to_path_category, morphism_property.Q]
rw [compose_path_to_path]
rfl
simp only [Pi.top_apply]
rw [fac]
rw [fac]
rw [← F₁.right_op_left_op_eq, ← F₂.right_op_left_op_eq, this]
dsimp
rw [← over.w k, reassoc_of a]
apply congr_arg comma_morphism.left this
  rw [← cancel_mono k]
  ext
  apply a
rw [auto_param_eq]
rw [← over.w κ]
rfl
dsimp
rw [← under.w k, category.assoc, a, category.assoc]
apply congr_arg comma_morphism.right this
  rw [← cancel_epi k]
  ext
  apply a
rw [h₁, h₂]
rw [h₁, h₂]
cases h₁
cases h₂
rw [eq_to_hom_refl, eq_to_hom_refl, category.id_comp, category.comp_id]
rw [h₁, h₂]
rw [h₁, h₂]
cases h₁
cases h₂
rw [eq_to_hom_refl, eq_to_hom_refl, category.id_comp, category.comp_id]
congr 2
exact add_assoc _ _ _
dsimp
rw [zero_add]
dsimp
rw [add_zero]
rw [h]
rw [h]
cases h
rw [eq_to_hom_refl, eq_to_hom_refl, category.id_comp, category.comp_id]
rw [h]
rw [h]
cases h
rw [eq_to_hom_refl, eq_to_hom_refl, category.id_comp, category.comp_id]
rw [h₁, h₂]
rw [h₁, h₂]
cases h₁
cases h₂
rw [eq_to_hom_refl, eq_to_hom_refl, category.id_comp, category.comp_id]
rw [h]
rw [h]
rw [iso.comp_inv_eq, category.assoc, iso.eq_inv_comp, shift_add_hom_comp_eq_to_hom₁]
rw [h]
rw [h]
rw [iso.comp_inv_eq, category.assoc, iso.eq_inv_comp, shift_add_hom_comp_eq_to_hom₂]
rw [h₁, h₂]
rw [h₁, h₂]
rw [iso.comp_inv_eq, category.assoc, iso.eq_inv_comp, shift_add_hom_comp_eq_to_hom₁₂]
change is_equivalence (add_neg_equiv (shift_monoidal_functor C A) i).Functor
infer_instance
simp only [iso.app_hom, unit_of_tensor_iso_unit_hom_app, eq_to_iso.hom, functor.map_comp,
    obj_μ_app, eq_to_iso.inv, obj_ε_inv_app, μ_naturalityₗ_assoc, category.assoc,
    μ_inv_hom_app_assoc, ε_inv_app_obj, μ_naturalityᵣ_assoc]
simp only [eq_to_hom_map, eq_to_hom_app, eq_to_hom_trans]
simp only [shift_comm, iso.trans_hom, iso.symm_hom, iso.app_inv, iso.symm_inv,
    monoidal_functor.μ_iso_hom, iso.app_hom, functor.map_iso_hom, eq_to_iso.hom, μ_naturality_assoc,
    nat_trans.naturality_assoc, nat_trans.naturality, functor.comp_map, category.assoc,
    μ_inv_hom_app_assoc]
simp only [eq_to_hom_map, eq_to_hom_app, eq_to_hom_trans_assoc, eq_to_hom_refl, category.id_comp,
    μ_hom_inv_app_assoc]
rw [shift_comm', ← shift_comm_symm, iso.symm_hom, iso.inv_hom_id_assoc]
intros
apply F.map_injective
dsimp
simp only [category.comp_id, category.id_comp, category.assoc,
          CategoryTheory.Functor.map_comp, functor.image_preimage, eq_to_hom_map,
          iso.inv_hom_id_app_assoc]
erw [(i m₃).Hom.naturality_assoc]
congr 1
dsimp
simp only [eq_to_iso.inv, eq_to_hom_app, eq_to_hom_map, obj_μ_app, μ_naturality_assoc,
          category.assoc, CategoryTheory.Functor.map_comp, functor.image_preimage]
congr 3
dsimp
simp only [← (shift_functor D m₃).map_comp_assoc, iso.inv_hom_id_app]
erw [(shift_functor D m₃).map_id, category.id_comp]
erw [((shift_monoidal_functor D A).μIso ⟨m₁ + m₂⟩ ⟨m₃⟩).inv_hom_id_app_assoc]
congr 1
have := dcongr_arg (fun a => (i a).inv.app X) (add_assoc m₁ m₂ m₃)
dsimp at this
simp [this]
intros
apply F.map_injective
dsimp
simp only [category.comp_id, category.id_comp, category.assoc,
          CategoryTheory.Functor.map_comp, eq_to_hom_app, eq_to_hom_map, functor.image_preimage]
erw [(i n).Hom.naturality_assoc]
dsimp
simp only [eq_to_iso.inv, eq_to_hom_app, category.assoc, CategoryTheory.Functor.map_comp,
          eq_to_hom_map, obj_ε_app, functor.image_preimage]
simp only [← (shift_functor D n).map_comp_assoc, iso.inv_hom_id_app]
dsimp
simp only [category.id_comp, μ_inv_hom_app_assoc, CategoryTheory.Functor.map_id]
have := dcongr_arg (fun a => (i a).inv.app X) (zero_add n)
dsimp at this
simp [this]
intros
apply F.map_injective
dsimp
simp only [category.comp_id, category.id_comp, category.assoc, iso.inv_hom_id_app_assoc,
          eq_to_iso.inv, eq_to_hom_app, eq_to_hom_map, CategoryTheory.Functor.map_comp,
          functor.image_preimage, obj_zero_map_μ_app, ε_hom_inv_app_assoc]
have := dcongr_arg (fun a => (i a).inv.app X) (add_zero n)
dsimp at this
simp [this]
cases F <;> rfl
cases F <;> rfl
intros <;> rfl
intros
dsimp only [pi_limit_fan]
simp [hom_to_functor]
simp [pi_iso_pi]
rfl
change f
change f
cases F <;> rfl
cases F <;> rfl
intros <;> rfl
rw [w]
rw [w]
subst h
exact mono_of_mono f g
subst h <;> exact epi_of_epi f g
infer_instance
rw [Function.comp_apply, f.map_fst, g.map_fst]
rw [Function.comp_apply, f.map_snd, g.map_snd]
rw [Function.comp_apply, f.map_point, g.map_point]
unfold Rel <;> infer_instance
cases h
cases h
rfl
cases F <;> rfl
cases F <;> rfl
intros <;> rfl
refine' eq_to_hom _
simp
rw [← congr_fun (limit.w (hom_diagram X Y) h) f, ← congr_fun (limit.w (hom_diagram Y Z) h) g]
dsimp
simp
simp
simp
subst h
simp
rfl
simp only [Subtype.val_eq_coe, some_get, Subtype.coe_eta]
simp only [Option.elim', Subtype.val_eq_coe, Subtype.coe_eta]
simp
intro x
rw [action_category.id_val, F.map_one]
rfl
intro x y z f g
revert y z g
refine' action_category.cases _
simp [single_obj.comp_as_mul, sane]
simp
simp [← cancel_epi f]
simp [← cancel_mono f]
simp
simp
simp
simp
simp
rw [← functor.map_comp, split_mono.id, Functor.map_id]
rw [← functor.map_comp, split_epi.id, Functor.map_id]
rw [f.2]
rw [← F.map_comp]
simp
cases H
rfl
cases H
rfl
cases H
rfl
cases H
rfl
simp only [vertex_group_mul, inv_eq_inv, category.assoc, is_iso.hom_inv_id_assoc]
apply quotient.comp_closure.intro
apply red_step.step
apply quotient.comp_closure.intro
apply red_step.step
rfl
rw [of_eq, Prefunctor.comp_assoc, Prefunctor.comp_assoc, functor.to_prefunctor_comp]
dsimp [lift]
rw [quotient.lift_spec, paths.lift_spec, Quiver.Symmetrify.lift_spec]
simp only [inv_eq_inv, is_iso.inv_hom_id, category.comp_id]
congr
simp only [inv_eq_inv, is_iso.hom_inv_id_assoc]
simp only [category.id_comp]
simp only [category.comp_id]
simp only [category.assoc]
simp only [inv_comp]
simp only [comp_inv]
simp only [Subtype.val_eq_coe, ← inv_eq_inv, coe_inv_coe]
rw [SetLike.le_def, Sigma.forall]
exact forall_congr' fun c => Sigma.forall
dsimp [Top.top, objs]
simp only [univ_nonempty]
intros
rw [mem_Inter₂] at hp⊢
exact fun S hS => S.inv (hp S hS)
intros
rw [mem_Inter₂] at hp hq⊢
exact fun S hS => S.mul (hp S hS) (hq S hS)
cases h
simp only [eq_to_hom_refl]
apply Sw.id_mem c
constructor
cases hγ
simp only [inv_eq_inv, category.id_comp, is_iso.inv_hom_id]
constructor
rw [mul_assoc]
exact Sn.conj' y hx
dsimp only [generated, Inf]
simp only [subset_Inter₂_iff]
exact fun S hS f fS => hS _ _ fS
apply @Inf_le_Inf (subgroupoid C) _
exact fun S ⟨h, _⟩ => h
rw [mem_set_of, inv_eq_inv, φ.map_inv p, ← inv_eq_inv]
exact S.inv hp
rw [comap, mem_set_of, Functor.map_id]
apply Sn.wide
simp only [im, mem_map_objs_iff, mem_top_objs, exists_true_left]
rw [hφ']
apply mem_top_objs
rw [hφ']
trivial
simp only [inv_eq_inv, functor.map_comp, functor.map_inv] at this
exact this
apply is_thin_iff
apply Set.ext
apply mem_disconnect_objs_iff
rw [is_totally_disconnected_iff]
exact fun c d ⟨f, h, fS⟩ => h
rw [full_objs]
apply Subtype.ext_iff
simp only [← op_comp, p.w]
simp only [← unop_comp, p.w]
rw [← op_comp, l.fac_right]
rw [← op_comp, l.fac_left]
rw [← unop_comp, l.fac_right]
rw [← unop_comp, l.fac_left]
rw [Iff, Iff]
exact Nonempty.congr (lift_struct.op_equiv sq).toFun (lift_struct.op_equiv sq).invFun
rw [Iff, Iff]
exact Nonempty.congr (lift_struct.unop_equiv sq).toFun (lift_struct.unop_equiv sq).invFun
induction g generalizing a
case id => rfl
case of => rfl
case comp _ _ _ g _ ihf ihg => erw [ihg (f.comp g), ihf f, ihg g, comp_assoc]
intro f g η
erw [left_unitor_inv_naturality_assoc, assoc]
congr 1
exact normalize_naturality nil η
intros
rw [bicategory.whisker_left_comp, bicategory.comp_whisker_right, category.assoc, category.assoc,
      bicategory.whisker_exchange_assoc]
dsimp [bicategorical_comp]
simp
intros
rw [associator_inv_naturality, iso.hom_inv_id_assoc, tensor_id]
intros
rw [associator_inv_naturality, iso.hom_inv_id_assoc]
intros
rw [← tensor_id, associator_naturality, iso.inv_hom_id_assoc]
intros
rw [left_unitor_inv_naturality, iso.hom_inv_id_assoc]
intros
rw [right_unitor_inv_naturality, iso.hom_inv_id_assoc]
intros
rw [pentagon]
dsimp
simp only [category.id_comp, category.comp_id]
    -- Should we provide further simp lemmas so this goal becomes visible?
exact (tensor_id_comp_id_tensor _ _).symm
cases η
simp only [whisker_left_id, eq_to_hom_refl]
cases η
simp only [id_whisker_right, eq_to_hom_refl]
dsimp
rw [associator_inv_naturality_right_assoc, whisker_exchange_assoc]
simp
infer_instance
  -- left whiskering:
rw [← whisker_left_comp, hom_inv_id, whisker_left_id]
rw [← comp_whisker_right, hom_inv_id, id_whisker_right]
rw [← whisker_left_comp, inv_hom_id, whisker_left_id]
rw [← comp_whisker_right, inv_hom_id, id_whisker_right]
simp
simp
simp
simp
simp
rw [← triangle, inv_hom_id_assoc]
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
rw [← whisker_left_iff, ← cancel_epi (α_ _ _ _).Hom, ← cancel_mono (ρ_ _).Hom, triangle, ←
      right_unitor_comp, right_unitor_naturality] <;>
    infer_instance
simp [iso.inv_eq_inv]
dsimp
rw [← map₂_comp_assoc, map_comp_naturality_left, map₂_comp_assoc, map_comp_naturality_left,
        assoc]
dsimp
rw [← map₂_comp_assoc, map_comp_naturality_right, map₂_comp_assoc, map_comp_naturality_right,
        assoc]
dsimp
simp only [map₂_associator, ← map₂_comp_assoc, ← map_comp_naturality_right_assoc,
        whisker_left_comp, assoc]
simp only [map₂_associator, map₂_comp, map_comp_naturality_left_assoc, comp_whisker_right,
        assoc]
dsimp
simp only [map₂_left_unitor, map₂_comp, map_comp_naturality_left_assoc, comp_whisker_right,
        assoc]
dsimp
simp only [map₂_right_unitor, map₂_comp, map_comp_naturality_right_assoc, whisker_left_comp,
        assoc]
dsimp
rw [F'.map_comp_iso_hom f g, ← F.map_comp_naturality_right_assoc, ← F'.map_comp_iso_hom f h,
        hom_inv_id, comp_id]
dsimp
rw [F'.map_comp_iso_hom f h, ← F.map_comp_naturality_left_assoc, ← F'.map_comp_iso_hom g h,
        hom_inv_id, comp_id]
dsimp
rw [← assoc, is_iso.eq_comp_inv, F.map_comp_naturality_right]
dsimp
rw [← assoc, is_iso.eq_comp_inv, F.map_comp_naturality_left]
dsimp
simp only [← assoc]
rw [is_iso.eq_comp_inv, ← inv_whisker_left, is_iso.eq_comp_inv]
simp only [assoc, F.map₂_associator]
rw [← comp_whisker_right, naturality_naturality, comp_whisker_right, whisker_assoc]
rw [← associator_naturality_middle, ← comp_whisker_right_assoc, naturality_comp]
simp
rw [← associator_naturality_middle, ← comp_whisker_right_assoc, naturality_id]
simp
rw [comp_id, assoc, p.naturality φ, ← assoc, ← limits.equalizer.condition, comp_id]
rw [equalizer.lift_ι]
rw [comp_id]
exact (congr_app hp j).symm
rw [← karoubi.comp_p_assoc]
have h := hom_ext.mp (f.naturality φ)
simp only [comp_f] at h
dsimp [karoubi_functor_category_embedding] at h
erw [← h, assoc, ← P.p.naturality_assoc φ, p_comp (f.app j')]
have h := P.idem
simp only [hom_ext, comp_f] at h
erw [← assoc, h, comp_p]
have h := P.idem
simp only [hom_ext, comp_f] at h⊢
erw [h, h]
have h := P.idem
simp only [hom_ext, comp_f] at h
erw [h, p_comp]
have h := P.idem
simp only [hom_ext, comp_f] at h⊢
erw [h, h]
dsimp
infer_instance
dsimp
infer_instance
rw [← φ.naturality, ← assoc, ← F.map_comp]
conv => 
    lhs
    rw [← id_comp (φ.app P), ← F.map_id]
congr
apply decomp_id
simp
simp
simp only [functor_extension₂, functor.assoc, functor_extension₁_comp_whiskering_left_to_karoubi,
    functor.comp_id]
rw [← karoubi_universal₂_functor_eq]
infer_instance
rw [← karoubi_universal_functor_eq]
infer_instance
change is_equivalence (karoubi_universal C D).inverse
infer_instance
rw [nat_trans_eq]
congr 2
exact congr_app (((whiskering_left _ _ _).obj (to_karoubi _)).image_preimage τ) P.X
rw [zero_comp, comp_zero]
rw [f.comm, ← assoc, P.idem]
rw [f.comm, assoc, assoc, Q.idem]
rw [p_comp, comp_p]
rw [assoc, comp_p, ← assoc, p_comp]
rfl
rfl
rw [comp_id]
rfl
rfl
subst h
simp only [eq_to_hom_refl, karoubi.id_eq, comp_id]
rw [comp_id]
simp only [comp_id, id_comp]
simp only [comp_zero, zero_comp]
simp only [add_assoc]
infer_instance
rw [comp_p p, hp']
rw [hp', p_comp p]
erw [id_comp, ← h₂, ← assoc, h₁, id_comp]
erw [comp_id, ← h₂, assoc, h₁, comp_id]
erw [coe_p, comp_id, P.idem]
erw [coe_p, id_comp, P.idem]
erw [comp_id, id_comp]
erw [comp_id, id_comp]
rw [comp_id, ← h₂, ← assoc, h₁, id_comp]
rw [hp, comp_id]
simp only [comp_sub, sub_comp, id_comp, comp_id, hp, sub_self, sub_zero]
rw [is_idempotent_complete_iff_idempotents_have_kernels]
intros
infer_instance
rw [← ε.inverse.map_comp, hp]
constructor
· exact equivalence.is_idempotent_complete ε
· exact equivalence.is_idempotent_complete ε.symm
rw [← op_comp, hp]
constructor
· exact is_idempotent_complete_of_is_idempotent_complete_opposite
· intro h
    apply is_idempotent_complete_of_is_idempotent_complete_opposite
    rw [is_idempotent_complete_iff_of_equivalence (op_op_equivalence C)]
    exact h
simp only [assoc, biproduct.bicone_π, biproduct.map_π, biproduct.map_π_assoc, (F j).idem]
rw [biproduct.ι_map, ← assoc, ← assoc, (F j).idem, assoc, biproduct.ι_map, ← assoc,
          (F j).idem]
simp only [decomp_id_i_f, decomp_id_p_f, complement_p, comp_sub, comp_f, hom_ext,
          quiver.hom.add_comm_group_zero_f, P.idem]
erw [comp_id, sub_self]
simp only [decomp_id_i_f, complement_p, decomp_id_p_f, sub_comp, comp_f, hom_ext,
          quiver.hom.add_comm_group_zero_f, P.idem]
erw [id_comp, sub_self]
simp only [hom_ext, ← decomp_p, quiver.hom.add_comm_group_add_f, to_karoubi_map_f, id_eq,
        coe_p, complement_p, add_sub_cancel'_right]
simp only [hom_eq_zero_iff, P.X.shape i j hij, limits.comp_zero]
simp
simp
dsimp
simp only [HomologicalComplex.Hom.comm, HomologicalComplex.Hom.comm_assoc,
                  homological_complex.p_idem]
dsimp
simp only [HomologicalComplex.Hom.comm, assoc, homological_complex.p_idem]
cases H
rfl
cases H
rfl
cases H
rfl
cases H
rfl
rw [← L₁.map_iso_inv l, iso.inv_comp_eq, L₁.map_iso_hom, reassoc_of h, ← R₁.map_comp]
simp
simp
simp only [functor.comp_map, ← F.map_comp, f.w]
infer_instance
simp [essentially_small_iff, CategoryTheory.locally_small_of_thin]
simp [hx]
rw [Finset.sum_const, nsmul_eq_mul]
simp only [hx, if_false]
simp [ha]
simp [ha]
let ⟨a, ha⟩ := hs
simp [mem_support_iff, Finset.ne_empty_of_mem ha]
simp
simp only [uniform_of_finset_apply, and_comm' (x ∈ s), ite_and, Ennreal.coe_nat]
simp [mem_support_iff]
simp
rw [← Nat.cast_sum, Multiset.to_finset_sum_count_eq s,
            Ennreal.inv_mul_cancel (Nat.cast_ne_zero.2 (hs ∘ Multiset.card_eq_zero.1))
              (Ennreal.nat_ne_top _)]
simp [mem_support_iff, hs]
simp
rw [div_eq_mul_inv, ← Ennreal.tsum_mul_right, to_outer_measure_apply]
refine' tsum_congr fun x => _
simp [mem_support_iff]
simp
simp only [Ennreal.tsum_mul_left, tsum_coe, mul_one]
simp [mem_support_iff, Ennreal.tsum_eq_zero, not_or]
simp only [support_bind, Set.mem_setOf_eq]
simp [to_outer_measure_apply, Set.indicator_apply]
simp only [to_outer_measure_apply, Set.indicator_apply]
rw [support_bind_on_support, Set.mem_setOf_eq]
simp only [bind_on_support_apply, Ennreal.tsum_eq_zero, mul_eq_zero, or_iff_not_imp_left]
exact ⟨fun h a ha => trans (dif_neg ha).symm (h a ha), fun h a ha => trans (dif_neg ha) (h a ha)⟩
refine' Pmf.ext fun b => _
simp only [bind_on_support_apply, pure_apply]
refine' trans (tsum_congr fun a' => _) (tsum_ite_eq a _)
simp only [Pmf.bind_pure, Pmf.bind_on_support_eq_bind]
simp only [← Ennreal.tsum_mul_left, mul_ite, mul_zero]
simp only [to_measure_apply_eq_to_outer_measure_apply _ _ hs,
    to_outer_measure_bind_on_support_apply]
rw [mem_support_iff, not_not]
rw [eq_self_iff_true, if_true]
congr
exact symm ((tsum_eq_single a) fun b hb => if_neg hb)
refine' (to_outer_measure_apply p s).trans ((@tsum_eq_sum _ _ _ _ _ _ s _).trans _)
· exact fun x hx => Set.indicator_of_not_mem hx _
· exact Finset.sum_congr rfl fun x hx => Set.indicator_of_mem hx _
refine' (p.to_outer_measure_apply {a}).trans (((tsum_eq_single a) fun b hb => _).trans _)
· exact ite_eq_right_iff.2 fun hb' => False.elim <| hb hb'
· exact ite_eq_left_iff.2 fun ha' => False.elim <| ha' rfl
rw [to_outer_measure_apply, Ennreal.tsum_eq_zero]
exact function.funext_iff.symm.trans Set.indicator_eq_zero'
simp only [to_outer_measure_apply, Pmf.support, Set.indicator_inter_support]
simp [to_measure_apply_eq_to_outer_measure_apply p {a} h, to_outer_measure_apply_singleton]
rw [to_measure_apply_eq_to_outer_measure_apply p s hs, to_outer_measure_apply_eq_zero_iff]
simp [p.to_measure_apply_eq_to_outer_measure_apply s hs,
    p.to_measure_apply_eq_to_outer_measure_apply _ (hs.inter hp)]
simp [map]
simp [map, @eq_comm β b]
simp
simp [map]
simp [map]
simp [map]
simp [-mem_support_iff, seq, @eq_comm β b]
simp
simp
simp [hf, mem_support_iff]
simp
rw [Filter, normalize_apply]
rw [filter_apply, set.indicator_apply_eq_zero.mpr fun ha' => absurd ha' ha, zero_mul]
erw [apply_eq_zero_iff, support_filter, Set.mem_inter_iff, not_and_or]
rw [Ne.def, filter_apply_eq_zero_iff, not_or, not_not, not_not]
simp [h]
simp
simp [cond_count]
simp
rw [cond_count, cond_apply _ MeasurableSet.univ, ← Ennreal.div_eq_inv_mul, Set.univ_inter]
congr
rw [← Finset.coe_univ, measure.count_apply, finset.univ.tsum_subtype' fun _ => (1 : Ennreal)]
· simp [Finset.card_univ]
· exact (@Finset.coe_univ Ω _).symm ▸ MeasurableSet.univ
rw [cond_count, cond_apply _ hs.measurable_set, Set.inter_univ, Ennreal.inv_mul_cancel]
· exact fun h => hs'.ne_empty <| measure.empty_of_count_eq_zero h
· exact (measure.count_apply_lt_top.2 hs).Ne
rw [cond_count, cond_inter_self _ hs.measurable_set]
rw [cond_count, cond_apply _ hs.measurable_set, Set.inter_self, Ennreal.inv_mul_cancel]
· exact fun h => hs'.ne_empty <| measure.empty_of_count_eq_zero h
· exact (measure.count_apply_lt_top.2 hs).Ne
rw [h]
exact one_ne_zero
exact this ▸ fun x hx => hx.2
  rw [← @Set.Finite.to_finset_inj _ _ _ (hsf.inter_of_left _) hsf]
  exact
    Finset.eq_of_subset_of_card_le (Set.Finite.to_finset_subset.2 (s.inter_subset_left t)) h.symm.le
simp [cond_count, cond_apply _ hs.measurable_set, measure.count_apply_eq_top,
    Set.not_infinite.2 hs, measure.count_apply_finite _ (hs.inter_of_left _)]
rw [← Set.inter_comm]
exact cond_count_inter hs
rw [← cond_count_union hs disjoint_compl_right, Set.union_compl_self,
    (cond_count_is_probability_measure hs hs').measure_univ]
simp
rw [cond, measure.smul_apply, measure.restrict_apply MeasurableSet.univ, Set.univ_inter]
exact Ennreal.inv_mul_cancel hcs (measure_ne_top _ s)
simp [cond]
simp [cond, measure_univ, measure.restrict_univ]
rw [cond, measure.smul_apply, measure.restrict_apply' hms, Set.inter_comm]
rfl
rw [cond_apply _ hms, ← Set.inter_assoc, Set.inter_self, ← cond_apply _ hms]
refine' pos_iff_ne_zero.mpr (right_ne_zero_of_mul _)
· exact (μ s)
rw [cond_apply _ hms]
refine' Ennreal.mul_pos _ hci
exact ennreal.inv_ne_zero.mpr (measure_ne_top _ _)
rw [cond_apply μ hms t, mul_comm, ← mul_assoc, Ennreal.mul_inv_cancel hcs hcs', one_mul]
rw [cond_mul_eq_inter μ hms hcs, cond_mul_eq_inter μ hms.compl hcs', Set.inter_comm _ t,
    Set.inter_comm _ t]
exact measure_inter_add_diff t hms
apply ae_strongly_measurable.comp_ae_measurable _ hf.ae_measurable
exact (strongly_measurable_id.indicator measurableSetIoc).AeStronglyMeasurable
simp [truncation]
simp only [truncation, indicator, Set.mem_Icc, id.def, Function.comp_apply, ite_eq_left_iff]
intro H
apply H.elim
simp [(abs_lt.1 h).1, (abs_lt.1 h).2.le]
rw [← mem_ℒp_one_iff_integrable]
exact hf.mem_ℒp_truncation
apply sum_congr rfl fun j hj => _
rw [intervalIntegral.sum_integral_adjacent_intervals_Ico ((mem_range.1 hj).le.trans hKN)]
intro k hk
exact continuous_const.interval_integrable _ _
apply sum_le_sum fun i hi => _
simp only [Nat.cast_add, Nat.cast_one, sum_const, card_range, nsmul_eq_mul, Nat.cast_min]
refine' mul_le_mul_of_nonneg_right (min_le_left _ _) _
apply intervalIntegral.integral_nonneg
· simp only [le_add_iff_nonneg_right, zero_le_one]
· simp only [zero_le_one, imp_true_iff]
simp only [Nat.cast_add, Nat.cast_one, le_add_iff_nonneg_right, zero_le_one]
rw [intervalIntegral.integral_add]
· exact continuous_id.interval_integrable _ _
· exact continuous_const.interval_integrable _ _
rw [integral_truncation_eq_interval_integral_of_nonneg hint.1 hnonneg]
refine' add_le_add le_rfl _
rw [intervalIntegral.integral_of_le (Nat.cast_nonneg _)]
simp only [integral_const, measure.restrict_apply', measurableSetIoc, Set.univ_inter,
          Algebra.id.smul_eq_mul, mul_one]
rw [← Ennreal.one_to_real]
exact Ennreal.to_real_mono Ennreal.one_ne_top prob_le_one
intro a b
rw [of_real_set_integral_one ρ _,
      measure.map_apply_of_ae_measurable hint.ae_measurable measurableSetIoc]
rfl
rw [Ennreal.of_real_sum_of_nonneg]
simp only [integral_const, Algebra.id.smul_eq_mul, mul_one, Ennreal.to_real_nonneg,
        imp_true_iff]
congr 1
refine' sum_congr rfl fun j hj => _
rw [intervalIntegral.integral_of_le (Nat.cast_le.2 ((mem_range.1 hj).le.trans hKN))]
intro n
change 𝔼[fun x => Y n x ^ 2] = _
rw [moment_truncation_eq_interval_integral_of_nonneg hint.1 two_ne_zero hnonneg]
congr 1
apply sum_le_sum fun k hk => _
refine' mul_le_mul_of_nonneg_right (sum_Ioo_inv_sq_le _ _) _
refine' intervalIntegral.integral_nonneg_of_forall _ fun u => sq_nonneg _
simp only [Nat.cast_add, Nat.cast_one, le_add_iff_nonneg_right, zero_le_one]
simp
rw [one_mul]
rw [← integral_truncation_eq_interval_integral_of_nonneg hint.1 hnonneg]
exact integral_truncation_le_integral_of_nonneg hint hnonneg
apply sum_le_sum fun j hj => _
refine' mul_le_mul_of_nonneg_left _ (inv_nonneg.2 (sq_nonneg _))
rw [(hident j).truncation.variance_eq]
exact variance_le_expectation_sq (hX 0).truncation
congr 1
apply mul_le_mul_of_nonneg_left (I1 _)
apply mul_nonneg (pow_nonneg c_pos.le _)
exact pow_nonneg (inv_nonneg.2 (sub_nonneg.2 c_one.le)) _
refine' sum_le_sum fun i hi => _
apply meas_ge_le_variance_div_sq
· exact mem_ℒp_finset_sum' _ fun j hj => (hident j).aeStronglyMeasurableFst.memℒpTruncation
· apply mul_pos (Nat.cast_pos.2 _) εpos
          refine' zero_lt_one.trans_le _
          apply Nat.le_floor
          rw [Nat.cast_one]
          apply one_le_pow_of_one_le c_one.le
rw [Ennreal.of_real_sum_of_nonneg fun i hi => _]
exact div_nonneg (variance_nonneg _ _) (sq_nonneg _)
intro n
refine' zero_lt_one.trans_le _
simp only [Nat.one_le_cast, Nat.one_le_floor_iff, one_le_pow_of_one_le c_one.le n]
simp
rw [variance, Ennreal.of_real_to_real]
exact hX.evariance_lt_top.ne
simp [evariance]
simp only [variance, evariance_zero, Ennreal.zero_to_real]
rw [variance, evariance_mul, Ennreal.to_real_mul, Ennreal.to_real_of_real (sq_nonneg _)]
rfl
simp [hc]
simp [variance_def' (hX.add hY), add_sq']
simp only [Pi.add_apply, Pi.pow_apply, Pi.mul_apply, mul_assoc]
rw [integral_add, integral_add, integral_add, integral_mul_left]
· exact hX.integrable one_le_two
· exact hY.integrable one_le_two
· exact hX.integrable_sq
· exact hY.integrable_sq
· exact hX.integrable_sq.add hY.integrable_sq
· apply integrable.const_mul
        exact h.integrable_mul (hX.integrable one_le_two) (hY.integrable one_le_two)
congr
exact h.integral_mul_of_integrable (hX.integrable one_le_two) (hY.integrable one_le_two)
rw [integral_add', integral_add', integral_add']
· exact mem_ℒp.integrable one_le_two (hs _ (mem_insert_self _ _))
· apply integrable_finset_sum' _ fun i hi => _
          exact mem_ℒp.integrable one_le_two (hs _ (mem_insert_of_mem hi))
· exact mem_ℒp.integrable_sq (hs _ (mem_insert_self _ _))
· apply mem_ℒp.integrable_sq
          exact mem_ℒp_finset_sum' _ fun i hi => hs _ (mem_insert_of_mem hi)
· apply integrable.add
          · exact mem_ℒp.integrable_sq (hs _ (mem_insert_self _ _))
          · apply mem_ℒp.integrable_sq
            exact mem_ℒp_finset_sum' _ fun i hi => hs _ (mem_insert_of_mem hi)
· rw [mul_assoc]
          apply integrable.const_mul _ 2
          simp only [mul_sum, sum_apply, Pi.mul_apply]
          apply integrable_finset_sum _ fun i hi => _
          apply
            indep_fun.integrable_mul _ (mem_ℒp.integrable one_le_two (hs _ (mem_insert_self _ _)))
              (mem_ℒp.integrable one_le_two (hs _ (mem_insert_of_mem hi)))
          apply h (mem_insert_self _ _) (mem_insert_of_mem hi)
          exact fun hki => ks (hki.symm ▸ hi)
simp only [coe_insert, Set.subset_insert]
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
simp only [pdf, dif_neg h]
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
rw [pdf, dif_pos hX]
exact (Classical.choose_spec hX.pdf'.2).2
exact MeasureTheory.MeasureSpace.volume
rw [← with_density_apply _ hs, map_eq_with_density_pdf X ℙ μ]
rw [← set_lintegral_univ, ← map_eq_set_lintegral_pdf X ℙ μ MeasurableSet.univ,
    measure.map_apply (has_pdf.measurable X ℙ μ) MeasurableSet.univ, Set.preimage_univ]
rw [← integrable_map_measure hf.ae_strongly_measurable (has_pdf.measurable X ℙ μ).AeMeasurable,
    map_eq_with_density_pdf X ℙ μ, integrable_with_density_iff (measurable_pdf _ _ _) ae_lt_top]
infer_instance
intro x
rw [mul_comm, Ennreal.of_real_mul Ennreal.to_real_nonneg]
intro x
rw [neg_mul_eq_neg_mul, mul_comm, Ennreal.of_real_mul Ennreal.to_real_nonneg]
rw [map_eq_with_density_pdf X ℙ μ]
exact with_density_absolutely_continuous _ _
simp only [zero_add, measurable_pdf X ℙ μ, true_and_iff, mutually_singular.zero_left,
        map_eq_with_density_pdf X ℙ μ]
rw [has_pdf_iff]
simp only [hX, true_and_iff]
rw [has_pdf_iff, ← map_map hg.measurable (has_pdf.measurable X ℙ μ)]
refine' ⟨hg.measurable.comp (has_pdf.measurable X ℙ μ), hmap, _⟩
rw [map_eq_with_density_pdf X ℙ μ]
refine' absolutely_continuous.mk fun s hsm hs => _
rw [map_apply hg.measurable hsm, with_density_apply _ (hg.measurable hsm)]
have := hg.absolutely_continuous hs
rw [map_apply hg.measurable hsm] at this
exact set_lintegral_measure_zero _ _ this
rw [has_pdf_iff_of_measurable hX, and_iff_right_iff_imp]
exact fun h => inferInstance
exact MeasureTheory.MeasureSpace.volume
simp only [Set.preimage_univ]
refine' ae_eq_trans huX _
simp [hsupp]
simp
refine' fun x => congr_arg ((· * ·) x) _
simp only [moment, hp, zero_pow', Ne.def, not_false_iff, Pi.zero_apply, integral_const,
    Algebra.id.smul_eq_mul, mul_zero]
simp only [central_moment, hp, Pi.zero_apply, integral_const, Algebra.id.smul_eq_mul, mul_zero,
    zero_sub, Pi.pow_apply, Pi.neg_apply, neg_zero, zero_pow', Ne.def, not_false_iff]
simp only [central_moment, Pi.sub_apply, pow_one]
rw [integral_sub h_int (integrable_const _)]
simp only [sub_mul, integral_const, Algebra.id.smul_eq_mul, one_mul]
rw [hX.variance_eq]
rfl
simp only [mgf, Pi.zero_apply, mul_zero, exp_zero, integral_const, Algebra.id.smul_eq_mul,
    mul_one]
simp only [cgf, mgf_zero_fun]
simp only [mgf, integral_zero_measure]
simp only [cgf, log_zero, mgf_zero_measure]
simp only [mgf, integral_const, Algebra.id.smul_eq_mul]
simp only [mgf_const', measure_univ, Ennreal.one_to_real, one_mul]
simp only [cgf, mgf_const']
rw [log_mul _ (exp_pos _).ne']
· rw [log_exp _]
· rw [Ne.def, Ennreal.to_real_eq_zero_iff, measure.measure_univ_eq_zero]
    simp only [hμ, measure_ne_top μ Set.univ, or_self_iff, not_false_iff]
simp only [cgf, mgf_const, log_exp]
simp only [mgf, zero_mul, exp_zero, integral_const, Algebra.id.smul_eq_mul, mul_one]
simp only [mgf_zero', measure_univ, Ennreal.one_to_real]
simp only [cgf, mgf_zero']
simp only [cgf_zero', measure_univ, Ennreal.one_to_real, log_one]
simp only [mgf, integral_undef hX]
simp only [cgf, mgf_undef hX, log_zero]
refine' integral_nonneg _
intro ω
simp only [Pi.zero_apply]
exact (exp_pos _).le
simp only [measure.restrict_univ]
have h_meas : ∀ t, Measurable fun x => exp (t * x) := fun t => (measurable_id'.const_mul t).exp
change indep_fun ((fun x => exp (s * x)) ∘ X) ((fun x => exp (t * x)) ∘ Y) μ
exact indep_fun.comp h_indep (h_meas s) (h_meas t)
congr
rw [neg_mul, exp_neg]
rfl
rw [← neg_neg t, ← mgf_neg, neg_neg, ← neg_mul_neg (-t)]
refine' Eq.trans_le _ (measure_ge_le_exp_mul_mgf (-ε) (neg_nonneg.mpr ht) _)
· congr
refine' (measure_ge_le_exp_mul_mgf ε ht h_int).trans _
rw [exp_add]
exact mul_le_mul le_rfl (le_exp_log _) mgf_nonneg (exp_pos _).le
refine' (measure_le_le_exp_mul_mgf ε ht h_int).trans _
rw [exp_add]
exact mul_le_mul le_rfl (le_exp_log _) mgf_nonneg (exp_pos _).le
rw [filtration.filtration_of_set_eq_natural hsm]
refine' (Indep_fun.condexp_natrual_ae_eq_of_lt _ hs.Indep_fun_indicator hij).trans _
· simp only [integral_indicator_const _ (hsm _), Algebra.id.smul_eq_mul, mul_one]
· infer_instance
rw [measure_congr this, measure_univ]
rw [← Ennreal.tsum_add_one_eq_top hs' (measure_ne_top _ _)]
exact Ennreal.tendsto_nat_tsum _
simp
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
rw [h.map_eq] at hu
exact hu.comp_ae_measurable h.ae_measurable_snd
rw [← measure.map_apply_of_ae_measurable h.ae_measurable_fst hs, ←
    measure.map_apply_of_ae_measurable h.ae_measurable_snd hs, h.map_eq]
apply (ae_map_iff h.ae_measurable_snd pmeas).1
rw [← h.map_eq]
exact (ae_map_iff h.ae_measurable_fst pmeas).2 hp
refine' ⟨h.ae_strongly_measurable_snd hf.ae_strongly_measurable, _⟩
rw [← h.snorm_eq]
exact hf.2
rw [← mem_ℒp_one_iff_integrable] at hf⊢
exact h.mem_ℒp_snd hf
rw [variance, h.evariance_eq]
rfl
refine' uniform_integrable_of' hp hp' hfmeas fun ε hε => _
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
intro t1 t2 ht1 ht2
rw [Set.inter_comm, mul_comm]
exact h t2 t1 ht2 ht1
intro s t hs ht
rw [Set.mem_setOf_eq, MeasurableSpace.measurable_set_bot_iff] at ht
cases ht
· rw [ht, Set.inter_empty, measure_empty, mul_zero]
· rw [ht, Set.inter_univ, measure_univ, mul_one]
simp only [indep_set, generate_from_singleton_empty]
exact indep_bot_right _
simp only [if_true, eq_self_iff_true]
simp only [hij.symm, if_false]
simp only [Finset.set_bInter_singleton, Finset.set_bInter_insert]
simp only [hij, Finset.prod_singleton, Finset.prod_insert, not_false_iff,
        Finset.mem_singleton]
change indep_sets ((fun x => measurable_set[m x]) i) ((fun x => measurable_set[m x]) j) μ
exact Indep_sets.indep_sets h_indep hij
let μ_inter := μ.restrict t1
let ν := μ t1
rw [measure.restrict_apply_univ, measure.smul_apply, smul_eq_mul, measure_univ, mul_one]
refine' h2 _ _
rw [hpm2]
exact measurable_set_generate_from ht
intro t1 t2 ht1 ht2
let μ_inter := μ.restrict t2
let ν := μ t2
rw [measure.restrict_apply_univ, measure.smul_apply, smul_eq_mul, measure_univ, mul_one]
refine' h1 _ _
rw [hpm1]
exact measurable_set_generate_from ht
simp [hxS]
rw [h_t1, ← hp_ind s h_f_mem_pi]
rw [h_t1, h_t2, Finset.set_bInter_insert, Set.inter_comm]
simp [hx]
have hp : IsPiSystem p := is_pi_system_pi_Union_Inter π h_pi S
have h_le' : ∀ i, generate_from (π i) ≤ m0 := fun i => (h_generate i).symm.trans_le (h_le i)
have hm_p : m_p ≤ m0 := generate_from_pi_Union_Inter_le π h_le' S
exact
        indep_sets.indep hm_p (h_le a) hp (h_pi a) hS_eq_generate (h_generate a)
          (h_ind.pi_Union_Inter_of_not_mem ha_notin_S)
intro n hn
rw [hS_eq_generate, h_generate n]
exact le_generate_from_pi_Union_Inter S hn
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
refine' fun s' t' hs' ht' => h_indep s' t' _ _
· refine' generate_from_induction (fun u => measurable_set[m₁] u) {s} _ _ _ _ hs'
    · simp only [hs, Set.mem_singleton_iff, Set.mem_setOf_eq, forall_eq]
    · exact @MeasurableSet.empty _ m₁
    · exact fun u hu => hu.compl
    · exact fun f hf => MeasurableSet.union hf
· refine' generate_from_induction (fun u => measurable_set[m₂] u) {t} _ _ _ _ ht'
    · simp only [ht, Set.mem_singleton_iff, Set.mem_setOf_eq, forall_eq]
    · exact @MeasurableSet.empty _ m₂
    · exact fun u hu => hu.compl
    · exact fun f hf => MeasurableSet.union hf
congr
refine' Finset.prod_congr rfl fun i hi_mem => _
rw [h_preim i hi_mem]
let πSβ :=
    Set.pi (Set.univ : Set S)
rw [generate_from_pi.symm, comap_generate_from]
· congr
rw [generate_from_pi.symm, comap_generate_from]
· congr
intro i hi
rw [h_sets_s'_eq hi]
exact hs1 _
have : indep_fun (fun ω => (f i ω, f j ω)) (f k) μ :=
    hf_Indep.indep_fun_prod hf_meas i j k hik hjk
change indep_fun ((fun p : β × β => p.fst * p.snd) ∘ fun ω => (f i ω, f j ω)) (id ∘ f k) μ
exact indep_fun.comp this (measurable_fst.mul measurableSnd) measurableId
rw [Finset.prod_apply]
specialize
    h_indep t t (measurable_set_generate_from (Set.mem_singleton t))
      (measurable_set_generate_from (Set.mem_singleton t))
rw [← this]
exact indep_supr_directed_limsup h_le h_indep hf hns hnsp
rw [supr_exists]
simp only [MeasurableSet.const]
rw [this]
exact @MeasurableSet.empty _ (f i)
rw [this]
exact @MeasurableSet.empty _ (f i)
refine' is_stopping_time_of_measurable_set_eq fun j => _
rw [forall_swap] at hs
rw [Set.Union_inter]
exact MeasurableSet.union (hs i)
refine' sigma_finite_trim_mono hτ.measurable_space_le _
· exact f
refine' sigma_finite_trim_mono (hτ.measurable_space_le_of_le hτ_le) _
· exact f
rw [measurable_space_min]
rfl
rw [hτ.measurable_space_min (is_stopping_time_const _ i), measurable_space_const]
rw [measurable_space_min_const, MeasurableSpace.measurable_set_inf]
rw [Set.inter_assoc, Set.inter_self]
rw [measurable_set_min_iff hτ hπ] at this
exact this.2
simp [stopped_process, min_eq_left h]
simp [stopped_process, min_eq_right h]
rw [this]
exact ((h_str_meas i).Measurable ht).inter (hτ.measurable_set_le i)
rw [this, Finset.sum_singleton]
intro i
refine' strongly_measurable.mono _ (le_supr₂_of_le i (le_refl i) le_rfl)
rw [strongly_measurable_iff_measurable_separable]
exact ⟨measurable_iff_comap_le.2 le_rfl, (hum i).is_separable_range⟩
intro i
have : u i = (fun p : Set.iic i × Ω => u p.1 p.2) ∘ fun x => (⟨i, set.mem_Iic.mpr le_rfl⟩, x) :=
    rfl
rw [this]
exact (h i).compMeasurable measurableProdMkLeft
rw [hitting, ite_eq_right_iff]
refine' le_hitting _ ω
cases f
cases g
simp only
exact h
have hs : s.nonempty := ⟨f, hf_mem⟩
simp only [Inf_def, hs, if_true]
exact Inf_le ⟨f, hf_mem, rfl⟩
apply hf.sigma_finite
infer_instance
exact this _ ht
    refine' generate_from_le _
    rintro t ⟨hn, u, hu, hu'⟩
    obtain heq
exact MeasureTheory.MeasureSpace.volume
rw [upper_crossing_time]
simp only [upper_crossing_time_succ]
rfl
cases n
· simp only [upper_crossing_time_zero, Pi.bot_apply, bot_le]
· simp only [upper_crossing_time_succ, hitting_le]
simp only [lower_crossing_time, hitting_le ω]
simp only [lower_crossing_time, le_hitting upper_crossing_time_le ω]
rw [upper_crossing_time_succ]
exact le_hitting lower_crossing_time_le ω
exact this hnm
  exact
    monotone_nat_of_le_succ fun n =>
      le_trans lower_crossing_time_le_upper_crossing_time_succ
        upper_crossing_time_le_lower_crossing_time
exact this hnm
  exact
    monotone_nat_of_le_succ fun n =>
      le_trans upper_crossing_time_le_lower_crossing_time
        lower_crossing_time_le_upper_crossing_time_succ
refine'
    lt_of_le_of_ne upper_crossing_time_le_lower_crossing_time fun h =>
      not_le.2 hab <| le_trans _ (stopped_value_lower_crossing_time hn)
simp only [stopped_value]
rw [← h]
exact stopped_value_upper_crossing_time (h.symm ▸ hn)
refine'
    lt_of_le_of_ne lower_crossing_time_le_upper_crossing_time_succ fun h =>
      not_le.2 hab <| le_trans (stopped_value_upper_crossing_time hn) _
simp only [stopped_value]
rw [← h]
exact stopped_value_lower_crossing_time (h.symm ▸ hn)
refine'
    hf.sum_mul_sub (fun n => (adapted_const ℱ 1 n).sub (hf.adapted.upcrossing_strat_adapted n))
      (_ : ∀ n ω, (1 - upcrossing_strat a b f N n) ω ≤ 1) _
· exact fun n ω => sub_le_self _ upcrossing_strat_nonneg
· intro n ω
    simp [upcrossing_strat_le_one]
have := (hf.sum_sub_upcrossing_strat_mul a b N).set_integral_le (zero_le n) MeasurableSet.univ
rw [integral_univ, integral_univ] at this
refine' le_trans _ this
simp only [Finset.range_zero, Finset.sum_empty, integral_zero']
simp [upcrossings_before]
simp [upcrossings_before]
cases n
· simp
· exact (crossing_eq_crossing_of_upper_crossing_time_lt hNM h).1
intro N M hNM ω
simp only [upcrossings_before]
rw [upcrossings_before] at hn
rw [← not_lt]
exact fun h => not_le.2 hn (le_cSup (upper_crossing_time_lt_bdd_above hab) h)
refine'
            Finset.sum_le_sum_of_subset_of_nonneg
              (Finset.range_subset.2 (upcrossings_before_le f ω hab)) fun i _ hi => _
intro ω i
rw [LatticeOrderedCommGroup.pos_nonpos_iff, sub_nonpos]
refine' eventually_of_forall fun ω => _
rw [Real.norm_eq_abs, Nat.abs_cast, Nat.cast_le]
refine' upcrossings_before_le _ _ hab
intro N
rw [of_real_integral_eq_lintegral_of_real]
· exact (hf.sub_martingale (martingale_const _ _ _)).Pos.Integrable _
· exact eventually_of_forall fun ω => LatticeOrderedCommGroup.pos_nonneg _
simp
simp
simp only [hitting, Set.mem_setOf_eq, exists_prop, Pi.coe_nat, Nat.cast_id,
          ite_eq_right_iff, forall_exists_index, and_imp]
intro m hm hεm
exact
          False.elim
            ((not_le.2 hω) ((le_sup'_iff _).2 ⟨m, mem_range.2 (Nat.lt_succ_of_le hm.2), hεm⟩))
refine' Ennreal.of_real_le_of_real _
rw [← stopped_value_const f n]
exact
        hsub.expected_stopped_value_mono (hitting_is_stopping_time hsub.adapted measurableSetIci)
          (is_stopping_time_const _ _) (fun ω => hitting_le ω) (fun ω => le_rfl : ∀ ω, n ≤ n)
rw [limit_process, dif_pos this]
exact (Classical.choose_spec this).2
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
rw [condexp_const (ℱ.le _)]
refine' ⟨fun i => hf.mono <| ℱ.mono bot_le, fun i j hij => _⟩
rw [condexp_of_strongly_measurable (ℱ.le _) (hf.mono <| ℱ.mono bot_le) hfint]
infer_instance
rw [Pi.zero_apply, condexp_zero]
simp
refine' ⟨hf.adapted.add hg.adapted, fun i j hij => _⟩
exact (condexp_add (hf.integrable j) (hg.integrable j)).trans ((hf.2 i j hij).add (hg.2 i j hij))
rw [sub_eq_add_neg]
exact hf.add hg.neg
refine' ⟨hf.adapted.smul c, fun i j hij => _⟩
refine' (condexp_smul c (f j)).trans ((hf.2 i j hij).mono fun x hx => _)
rw [Pi.smul_apply, hx, Pi.smul_apply, Pi.smul_apply]
rw [← neg_le_neg_iff, ← integral_neg, ← integral_neg]
exact supermartingale.set_integral_le hf.neg hij hs
rw [sub_eq_add_neg]
exact hf.add hg.neg
refine'
    ⟨fun i => @strongly_measurable.sup _ _ _ _ (ℱ i) _ _ _ (hf.adapted i) (hg.adapted i),
      fun i j hij => _, fun i => integrable.sup (hf.integrable _) (hg.integrable _)⟩
refine' eventually_le.sup_le _ _
·
    exact
      eventually_le.trans (hf.2.1 i j hij)
        (condexp_mono (hf.integrable _) (integrable.sup (hf.integrable j) (hg.integrable j))
          (eventually_of_forall fun x => le_max_left _ _))
·
    exact
      eventually_le.trans (hg.2.1 i j hij)
        (condexp_mono (hg.integrable _) (integrable.sup (hf.integrable j) (hg.integrable j))
          (eventually_of_forall fun x => le_max_right _ _))
exact ae_le_of_ae_le_trim this
refine' ⟨hadp, fun i j hij => _, hint⟩
rw [← condexp_of_strongly_measurable (ℱ.le _) (hadp _) (hint _), ← eventually_sub_nonneg]
exact eventually_le.trans (hf i j hij) (condexp_sub (hint _) (hint _)).le
infer_instance
rw [sub_eq_add_neg]
exact hf.add hg.neg
refine' submartingale_nat hadp hint fun i => _
rw [← condexp_of_strongly_measurable (𝒢.le _) (hadp _) (hint _), ← eventually_sub_nonneg]
exact eventually_le.trans (hf i) (condexp_sub (hint _) (hint _)).le
infer_instance
intro m
refine' Finset.stronglyMeasurableSum' _ fun i hi => _
rw [Finset.mem_range] at hi
exact
      (hξ.strongly_measurable_le hi.le).mul
        ((hf.adapted.strongly_measurable_le (Nat.succ_le_of_lt hi)).sub
          (hf.adapted.strongly_measurable_le hi.le))
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
rw [martingale_part_eq_sum]
exact
    (hf_int 0).add
      (integrable_finset_sum' _ fun i hi => ((hf_int _).sub (hf_int _)).sub integrable_condexp)
rw [martingale_part_eq_sum]
refine' (condexp_add (hf_int 0) _).trans _
· exact integrable_finset_sum' _ fun i hij => ((hf_int _).sub (hf_int _)).sub integrable_condexp
refine' (eventually_eq.add eventually_eq.rfl (condexp_finset_sum fun i hij => _)).trans _
· exact ((hf_int _).sub (hf_int _)).sub integrable_condexp
refine' eventually_eq.add _ _
· rw [condexp_of_strongly_measurable (ℱ.le _) _ (hf_int 0)]
      · infer_instance
      · exact (hf 0).mono (ℱ.mono (zero_le i))
·
      exact
        eventually_eq_sum fun k hkj => condexp_sub ((hf_int _).sub (hf_int _)) integrable_condexp
refine' fun k hk => eventually_eq.sub _ _
· rw [condexp_of_strongly_measurable]
      · exact ((hf (k + 1)).mono (ℱ.mono (Nat.succ_le_of_lt hk))).sub ((hf k).mono (ℱ.mono hk.le))
      · exact (hf_int _).sub (hf_int _)
· rw [condexp_of_strongly_measurable]
      · exact strongly_measurable_condexp.mono (ℱ.mono hk.le)
      · exact integrable_condexp
rw [hhdef, sub_eq_sub_iff_add_eq_add, add_comm (predictable_part (f + g) ℱ μ),
      martingale_part_add_predictable_part]
rw [hh]
exact adapted_predictable_part.sub hg
refine' (hf.stopped_value_least_ge_snorm_le hr hf0 hbdd i).trans _
simp [Ennreal.coe_to_nnreal (measure_ne_top μ _), Ennreal.coe_to_nnreal]
rw [ae_all_iff]
exact fun i =>
      submartingale.exists_ae_tendsto_of_bdd (hf.stopped_value_least_ge i)
        (hf.stopped_value_least_ge_snorm_le' i.cast_nonneg hf0 hbdd)
intro n
exact lt_of_le_of_lt ((mem_upper_bounds.1 hωb.some_mem) _ ⟨n, rfl⟩) hi
rw [process, Finset.range_zero, Finset.sum_empty]
simp only [martingale_part_eq_sum, process_zero, zero_add]
refine' Finset.sum_congr rfl fun k hk => _
simp only [process, Finset.sum_range_succ_sub_sum]
rw [Nonneg.coe_one, process, process, Finset.sum_apply, Finset.sum_apply,
    Finset.sum_range_succ_sub_sum, ← Real.norm_eq_abs, norm_indicator_eq_indicator_norm]
refine' Set.indicator_le' (fun _ _ => _) (fun _ _ => zero_le_one) _
rw [Pi.one_apply, norm_one]
subst h
subst h'
rw [heq_iff_eq, heq_iff_eq, ext_iff]
simp only [@eq_comm _ b, exists_eq_subtype_mk_iff, @eq_comm _ _ a]
rfl
rfl
apply congr_arg Subtype.val hxy
simp
dsimp only [Vector.zipWith, Vector.nth]
cases x
cases y
simp only [List.nth_le_zip_with, Subtype.coe_mk]
congr
rw [nth_eq_nth_le]
exact List.nth_le_mem _ _ _
rw [Vector.to_list_cons, List.mem_cons_iff]
rw [Vector.to_list_map, List.mem_map]
rw [mem_succ_iff, head_map, tail_map, mem_map_iff, @eq_comm _ b]
rw [hv, hw]
rw [h.1, h.2]
rw [Ne.def, eq_cons_iff a v v', not_and_or]
rw [of_fn, List.of_fn_succ, to_list_cons, to_list_of_fn]
cases v <;> rfl
rw [to_list_length] <;> exact i.2
apply List.nth_le_repeat
simp [nth_eq_nth_le]
rw [nth_eq_nth_le, ← List.nth_le_of_fn f] <;> congr <;> apply to_list_of_fn
simp [nth_eq_nth_le] <;> rfl
simp only [← cons_head_tail, eq_iff_true_of_subsingleton]
congr
funext i
cases i
simp
rw [← v.cons_head_tail]
simp only [to_list_cons, to_list_nil, cons_head, eq_self_iff_true, and_self_iff, singleton_tail]
simp only [empty_to_list_eq_ff, Bool.coe_sort_false, not_false_iff]
simp only [List.map_id, Vector.to_list_map]
simp
cases v
simp [Vector.reverse]
rw [← nth_zero, nth_of_fn]
simp [nth_zero]
rw [← nth_tail_succ, tail_cons]
simp only [Nat.add_succ_sub_one, add_zero, to_list_length, tsub_self, List.length_reverse]
rw [List.length_scanl, to_list_length]
rw [← cons_head_tail v]
simp only [scanl_cons, scanl_nil, cons_head, singleton_tail]
simp only [eq_iff_true_of_subsingleton]
simp only [eq_iff_true_of_subsingleton]
simp [m_of_fn, @m_of_fn_pure n, of_fn]
induction on `v
induction v using Vector.inductionOn <;> trivial
induction on a pair of vectors `v
induction on a triplet of vectors
rw [h]
rw [List.length_insert_nth, v.2]
rw [v.2, ← Nat.succ_le_succ_iff]
exact i.2
refine' Subtype.eq _
simp only [insert_nth_val, Fin.coe_succ, Fin.castSucc, Fin.val_eq_coe, Fin.coe_cast_add]
apply List.insert_nth_comm
· assumption
· rw [hl]
      exact Nat.le_of_succ_le_succ j.2
rw [List.update_nth_length, v.2]
cases v <;> cases i <;> simp [Vector.updateNth, Vector.nth_eq_nth_le]
cases v <;> cases i <;> cases j <;>
    simp [Vector.updateNth, Vector.nth_eq_nth_le, List.nth_le_update_nth_of_ne (Fin.vne_of_ne h)]
refine' (List.prod_update_nth v.to_list i a).trans _
have : ↑i < v.to_list.length := lt_of_lt_of_le i.2 (le_of_eq v.2.symm)
simp_all
refine' (List.prod_update_nth' v.to_list i a).trans _
have : ↑i < v.to_list.length := lt_of_lt_of_le i.2 (le_of_eq v.2.symm)
simp [this, nth_eq_nth_le, mul_assoc]
rw [Hv]
intros <;> cases x <;> simp! [(· <$> ·)]
intros <;> cases x <;> simp! [(· <$> ·)]

/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `reflect_name #[] -/
/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `reflect_name #[] -/
trace
            "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `reflect_name #[]"
trace
            "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `reflect_name #[]"
induction t <;> dsimp only [all] <;> skip <;> infer_instance
induction t <;> dsimp only [any] <;> skip <;> infer_instance
decide
decide
rw [h.1] <;> rfl
induction t
· exact H0
rw [hl.eq_node']
exact H1 _ _ _ (t_ih_l hl.2.1) (t_ih_r hl.2.2)
rw [size, h₁, size_eq_real_size h₂, size_eq_real_size h₃] <;> rfl
rw [h.1] <;> apply Nat.le_add_left
rw [dual, dual, dual_dual, dual_dual]
cases t <;> rfl
induction t <;> unfold balanced <;> skip <;> infer_instance
rw [add_comm] <;> exact id
simp (config := { contextual := true }) [balanced_sz]
refine' or_iff_not_imp_left.2 fun h => _
refine' ⟨_, h₂.resolve_left h⟩
cases H
· cases r₂
    · cases h (le_trans (Nat.add_le_add_left (Nat.zero_le _) _) H)
    · exact le_trans (le_trans (Nat.le_add_right _ _) H) (Nat.le_add_left 1 _)
· exact le_trans H.1 (Nat.mul_le_mul_left _ h₁)
rw [size_dual, size_dual] <;> exact b.symm
simp [node', add_comm]
simp [node3_l, node3_r, dual_node']
simp [node3_l, node3_r, dual_node']
cases m <;> simp [node4_l, node4_r, dual_node3_l, dual_node']
cases m <;> simp [node4_l, node4_r, dual_node3_r, dual_node']
rw [← dual_dual (rotate_l _ _ _), dual_rotate_l, dual_dual, dual_dual]
rw [← dual_dual (balance_l _ _ _), dual_balance_l, dual_dual, dual_dual]
dsimp [node3_l, node', size] <;> rw [add_right_comm _ 1]
dsimp [node3_r, node', size] <;> rw [← add_assoc, ← add_assoc]
simp [size_dual, add_comm]
rw [← dual_dual t] <;> exact h.dual
rw [dual_rotate_r] <;> exact hr.dual.rotate_l hl.dual
rw [← size_dual, dual_rotate_r, hl.dual.rotate_l_size, size_dual, size_dual, add_comm (size l)]
simp [all, emem, all_iff_forall, any, or_imp, forall_and]
simp [any, emem, any_iff_exists, or_and_right, exists_or]
simp [node3_l, all_node', and_assoc']
cases m <;> simp [node4_l, all_node', all, all_node3_l, and_assoc']
cases m <;> simp [node4_r, all_node', all, all_node3_r, and_assoc']
rw [← all_dual, dual_rotate_r, all_rotate_l] <;> simp [all_dual, and_comm', and_left_comm]
rw [foldr, foldr_cons_eq_to_list, foldr_cons_eq_to_list, ← List.cons_append, ←
        List.append_assoc, ← foldr_cons_eq_to_list] <;>
      rfl
rw [to_list, foldr, foldr_cons_eq_to_list] <;> rfl
unfold emem <;> induction t <;> simp [any, *, or_assoc']
rw [to_list_node, List.length_append, List.length_cons, length_to_list', length_to_list'] <;>
      rfl
rw [length_to_list', size_eq_real_size h]
rw [← length_to_list h₁, h, length_to_list h₂]
cases t
· contradiction
· simp [h.1]
rw [← find_min'_dual, dual_dual]
rw [← find_min_dual, dual_dual]
rw [erase_min, dual_balance_r, dual_erase_min, dual, dual, dual, erase_max]
rw [← dual_dual (erase_min _), dual_erase_min, dual_dual]
rw [split_min', split_min_eq, split_min', find_min', erase_min]
rw [split_max', split_max_eq, split_max', find_max', erase_max]
cases t <;> rfl
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
rw [Nat.dist_comm] <;> exact H.dist_le
rw [add_comm, add_comm m] <;> exact H.add_left _
decide
rw [size_dual, size_dual]
exact
    H.symm.imp (Exists.imp fun _ => And.imp_right balanced_sz.symm)
      (Exists.imp fun _ => And.imp_right balanced_sz.symm)
rw [balance_l_eq_balance' hl hr sl sr H, size_balance' sl sr]
rw [balance_l_eq_balance' hl hr sl sr H, all_balance']
rw [← dual_dual (balance_r l x r), dual_balance_r,
    balance_l_eq_balance' hr.dual hl.dual sr.dual sl.dual (balance_sz_dual H), ← dual_balance',
    dual_dual]
rw [balance_r_eq_balance' hl hr sl sr H, size_balance' sl sr]
rw [balance_r_eq_balance' hl hr sl sr H, all_balance']
cases o₁ <;> cases o₂ <;> try trivial <;> exact h
cases o₂ <;> try trivial <;> exact h
cases o₁ <;> try trivial <;> exact h
simp [size_dual, add_comm]
rw [size_dual, size_dual] <;> exact b.symm
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
exact hl.node3_l hr.left hr.right this.1 this.2
decide
decide
decide
decide
decide
decide
decide
rw [balance_eq_balance' hl.3 hr.3 hl.2 hr.2] <;> exact hl.balance' hr H
decide
rw [valid'.dual_iff, dual_balance_r]
have := hr.dual.balance_l_aux hl.dual
rw [size_dual, size_dual] at this
exact this H₁ H₂ H₃
rw [valid'.dual_iff, dual_balance_r] <;> exact hr.dual.balance_l hl.dual (balance_sz_dual H)
rw [h.2.eq_node'] <;> exact h.erase_min_aux.1.valid
rw [valid.dual_iff, dual_erase_max] <;> exact erase_min.valid h.dual
unfold Ordnode.insert insert_with <;> cases cmpLE x y <;> unfold Ordnode.insert insert_with <;>
      simp [insert_eq_insert_with]
rw [insert_eq_insert_with] <;> exact insert_with.valid _ _ (fun _ _ => ⟨le_rfl, le_rfl⟩) h
unfold insert' insert_with <;> cases cmpLE x y <;> unfold insert' insert_with <;>
      simp [insert'_eq_insert_with]
rw [insert'_eq_insert_with] <;> exact insert_with.valid _ _ (fun _ => id) h
cases h <;> exact rfl
simp [Membership.Mem, mem] at h_mem
apply Ordnode.pos_size_of_mem t.property.sz h_mem
simp [bit0]
rw [sum_eq_of_subset _ (fun n r => f n r) (fun n => (f n).map_zero) _ (support_smul c p)]
simp only [sum_def, Finset.smul_sum, coeff_smul, LinearMap.map_smul, RingHom.id_apply]
simp [coeff_mul]
simp
simp
rw [C_mul_X_pow_eq_monomial, coeff_monomial]
congr 1
simp [eq_comm]
rw [← pow_one X, coeff_C_mul_X_pow]
simp only [one_mul, RingHom.map_one, ← coeff_C_mul_X_pow]
simp [coeff_X_pow]
rw [support_binomial h hx hy, card_insert_of_not_mem (mt mem_singleton.mp h), card_singleton]
rw [support_trinomial hkm hmn hx hy hz,
    card_insert_of_not_mem
      (mt mem_insert.mp (not_or_of_not hkm.ne (mt mem_singleton.mp (hkm.trans hmn).Ne))),
    card_insert_of_not_mem (mt mem_singleton.mp hmn.ne), card_singleton]
rw [(commute_X_pow p n).Eq, coeff_mul_X_pow]
rw [(commute_X_pow p n).Eq, coeff_mul_X_pow']
rw [(commute_X p).Eq, coeff_mul_X]
rw [← C_mul_X_pow_eq_monomial, ← X_pow_mul, ← mul_assoc, coeff_mul_C, coeff_mul_X_pow]
rw [← C_mul_X_pow_eq_monomial, mul_assoc, coeff_C_mul, X_pow_mul, coeff_mul_X_pow]
rw [(commute_X (C r : R[X])).add_pow, ← lcoeff_apply, LinearMap.map_sum]
simp only [one_pow, mul_one, lcoeff_apply, ← C_eq_nat_cast, ← C_pow, coeff_mul_C, Nat.cast_id]
rw [Finset.sum_eq_single k, coeff_X_pow_self, one_mul]
· intro _ _ h
    simp [coeff_X_pow, h.symm]
· simp only [coeff_X_pow_self, one_mul, not_lt, Finset.mem_range]
    intro h
    rw [Nat.choose_eq_zero_of_lt h, Nat.cast_zero, mul_zero]
rw [← C_1, coeff_X_add_C_pow, one_pow, one_mul]
rw [add_comm _ X, coeff_X_add_one_pow]
simp [bit0, add_mul]
simp [bit1, add_mul, coeff_bit0_mul]
simp [ext_iff]
cases i <;> simp
apply induction_linear q
· rw [smul_zero, map_zero, smul_zero]
· intro f g e₁ e₂
    rw [smul_add, map_add, e₁, e₂, map_add, smul_add]
intro i m
apply Polynomial.induction_on' p
· intro p q e₁ e₂
    rw [add_smul, map_add, e₁, e₂, Polynomial.map_add, add_smul]
· intro j s
    rw [monomial_smul_single, map_single, Polynomial.map_monomial, map_single, monomial_smul_single,
      f.map_smul, algebra_map_smul]
apply induction_linear q
· rw [smul_zero, map_zero, smul_zero]
· intro f g e₁ e₂
    rw [smul_add, map_add, e₁, e₂, map_add, smul_add]
intro i m
apply Polynomial.induction_on' p
· intro p q e₁ e₂
    rw [add_smul, map_add, Polynomial.eval_add, e₁, e₂, add_smul]
· intro j s
    rw [monomial_smul_single, eval_single, Polynomial.eval_monomial, eval_single, smul_comm, ←
      smul_smul, pow_add, mul_smul]
rw [comp_apply]
erw [map_single, eval_single]
rfl
rw [← LinearMap.comp_apply]
apply induction_linear q
· rw [map_zero, map_zero]
· intro _ _ e₁ e₂
    rw [map_add, map_add, e₁, e₂]
· intro i m
    rw [LinearMap.comp_apply, comp_single, eval_single, eval_smul, eval_single, pow_zero, one_smul,
      Polynomial.eval_pow]
rw [comp_apply, map_smul, eval_smul, Polynomial.comp, Polynomial.eval_map, comp_apply]
rfl
simp only [smul_eq_C_mul, C_mul_comp, RingHom.id_apply]
simp only [taylor_apply, X_comp]
simp only [taylor_apply, C_comp]
rw [taylor_zero', LinearMap.id_apply]
rw [← C_1, taylor_C]
simp [taylor_apply]
rw [taylor_coeff, hasse_deriv_zero, LinearMap.id_apply]
rw [taylor_coeff, hasse_deriv_one]
simp only [taylor_apply, mul_comp]
simp only [taylor_apply, comp_assoc, map_add, add_comp, X_comp, C_comp, C_add, add_assoc]
simp only [taylor_apply, eval_comp, eval_C, eval_X, eval_add]
rw [taylor_eval, sub_add_cancel]
rw [← comp_eq_sum_left, sub_eq_add_neg, ← C_neg, ← taylor_apply, taylor_taylor, neg_add_self,
    taylor_zero]
simp only [div_X, coeff_monomial, true_and_iff, finset_sum_coeff, not_lt, mem_Ico, zero_le,
    Finset.sum_ite_eq', ite_eq_left_iff]
intro h
rw [coeff_eq_zero_of_nat_degree_lt (Nat.lt_succ_of_le h)]
simp [div_X, coeff_C] <;> simp [coeff]
rw [h, div_X_C]
simp
simp [h']
decide
rw [zero_le_degree_iff, Ne.def, div_X_eq_zero_iff] <;>
                          exact fun h0 => h (h0.symm ▸ degree_C_le)
rw [hpX0, zero_mul] <;> exact M0
decide
rw [a0, C_0, zero_mul, nat_degree_zero]
rw [sum_add_index] <;>
      simp only [add_mul, forall_const, RingHom.map_add, eq_self_iff_true, zero_mul,
        RingHom.map_zero]
dsimp <;> rw [sum_smul_index] <;>
      simp only [mul_sum, ← C_mul', mul_assoc, coeff_C_mul, RingHom.map_mul, forall_const, zero_mul,
        RingHom.map_zero, Sum]
rw [derivative_apply, sum_monomial_index, C_mul_X_pow_eq_monomial]
simp
rw [C_mul_X_pow_eq_monomial, C_mul_X_pow_eq_monomial, derivative_monomial]
rw [derivative_C_mul_X_pow, Nat.cast_two, pow_one]
rw [derivative_X_pow, Nat.cast_two, pow_one]
simp [derivative_apply]
rw [eq_C_of_nat_degree_eq_zero hp, derivative_C]
simp
simp [bit0]
simp [bit1]
rw [coeff_derivative, h1, zero_mul]
rw [H, derivative_zero]
rw [← map_nat_cast C n]
exact derivative_C
let n := max p.nat_degree (map f p).natDegree
rw [derivative_apply, derivative_apply]
rw [sum_over_range' _ _ (n + 1) ((le_max_left _ _).trans_lt (lt_add_one _))]
rw [sum_over_range' _ _ (n + 1) ((le_max_right _ _).trans_lt (lt_add_one _))]
simp only [Polynomial.map_sum, Polynomial.map_mul, Polynomial.map_C, map_mul, coeff_map,
    map_nat_cast, Polynomial.map_nat_cast, Polynomial.map_pow, map_X]
all_goals intro n; rw [zero_mul, C_0, zero_mul]
simp
rw [Function.iterate_succ_apply', coeff_derivative, ih m.succ, Nat.succ_add, Nat.add_succ]
rw [← Nat.cast_add_one, ← nsmul_eq_mul', smul_smul, mul_comm]
rw [prod_range_succ, add_tsub_assoc_of_le k.le_succ, Nat.succ_sub le_rfl, tsub_self]
rw [Function.iterate_succ_apply', IH]
rw [add_comm, add_assoc]
rw [sum_range_succ' _ n.succ, Nat.choose_zero_right, tsub_zero]
rw [pow_one, Nat.cast_zero, zero_add, one_mul, pow_zero, one_mul]
rw [pow_succ', derivative_mul, ih, mul_right_comm, ← add_mul, add_mul (n.succ : R[X]), one_mul,
      pow_succ', mul_assoc, n.cast_succ]
rw [pow_zero, derivative_one, Nat.cast_zero, zero_mul, zero_mul]
rw [p.derivative_pow_succ n, n.succ_sub_one, n.cast_succ]
rw [iterate_derivative_X_pow_eq_nat_cast_mul n k, C_eq_nat_cast]
rw [iterate_derivative_X_pow_eq_C_mul n k, smul_eq_C_mul]
rw [derivative_pow, derivative_add, derivative_X, derivative_C, add_zero, mul_one]
apply Polynomial.induction_on' p
· intro p₁ p₂ h₁ h₂
    simp [h₁, h₂, mul_add]
· intro n r
    simp only [derivative_pow, derivative_mul, monomial_comp, derivative_monomial, derivative_C,
      zero_mul, C_eq_nat_cast, zero_add, RingHom.map_mul]
    -- is there a tactic for this? (a multiplicative `abel`):
    rw [mul_comm (derivative q)]
    simp only [mul_assoc]
rw [eval₂_C, derivative_C, eval₂_zero, zero_mul]
rw [eval₂_add, derivative_add, ih₁, ih₂, derivative_add, eval₂_add, add_mul]
rw [pow_succ', ← mul_assoc, eval₂_mul, eval₂_X, derivative_mul, ih, @derivative_mul _ _ _ X,
      derivative_X, mul_one, eval₂_add, @eval₂_mul _ _ _ _ X, eval₂_X, add_mul, mul_right_comm]
simp
rw [← C_eq_int_cast n]
exact derivative_C
simp
simp [derivative_comp]
rw [derivative_pow, derivative_sub, derivative_X, derivative_C, sub_zero, mul_one]
simp
refine' AlgHom.comp _ (to_finsupp_iso_alg R).toAlgHom
exact map_domain_alg_hom R R Int.ofNatHom
rw [← T_add, sub_eq_add_neg]
rw [T, T, single_pow n, one_pow, nsmul_eq_mul]
simp [← T_add, mul_assoc]
rw [to_finsupp_monomial, map_domain_single, single_eq_C_mul_T]
simp [← C_mul_X_pow_eq_monomial]
simp only [_root_.map_mul, Polynomial.to_laurent_C]
simp only [map_pow, Polynomial.to_laurent_X, T_pow, mul_one]
simp only [_root_.map_mul, Polynomial.to_laurent_C, Polynomial.to_laurent_X_pow]
rw [← T_add, add_left_neg, T_zero]
rw [← T_add, add_right_neg, T_zero]
rw [T, T, ← single_eq_C, single_mul_single, single_mul_single, single_mul_single]
simp [add_comm]
apply (to_finsupp_iso R).Injective
rw [← single_eq_C_mul_T, Trunc, AddMonoidHom.coe_comp, Function.comp_apply,
    comap_domain.add_monoid_hom_apply, to_finsupp_iso_apply]
simp only [hf, hg, _root_.map_add]
simp only [Polynomial.to_laurent_C_mul_T, trunc_C_mul_T, Int.coe_nat_nonneg,
        Int.toNat_coe_nat, if_true]
simp
rw [← single_eq_C_mul_T]
exact support_single_ne_zero _ a0
simp only [fs, Finset.erase_eq_of_not_mem as, Polynomial.support_erase,
            Finset.erase_insert_eq_erase]
simp [fs]
rw [h, degree_zero]
rw [← one_mul (T n), ← map_one C]
exact degree_C_mul_T n 1 (one_ne_zero : (1 : R) ≠ 0)
rw [← mul_one (C a), ← T_zero]
exact degree_C_mul_T 0 a a0
rw [map_one, one_mul]
rw [T_zero, mul_one]
simp only [HasSmul.smul, SMul.comp.smul, map_mul, mul_assoc]
simp [mul_comm]
dsimp [expand, eval₂]
rfl
simp [expand]
rw [expand_C]
rw [AlgHom.map_add, ihf, ihg]
rw [AlgHom.map_mul, expand_C, AlgHom.map_pow, expand_X, pow_one]
rw [pow_zero, expand_one, Function.iterate_zero, id]
rw [Function.iterate_succ_apply', pow_succ, expand_mul, ih]
rw [coe_expand, derivative_eval₂_C, derivative_pow, derivative_X, mul_one]
rw [coeff_expand hp, if_pos (dvd_mul_left _ _), Nat.mul_div_cancel _ hp]
rw [mul_comm, coeff_expand_mul hp]
rw [← coeff_expand_mul hn, H, coeff_expand_mul hn]
rw [← expand_C, expand_inj hp, expand_C]
rw [monic.def, leading_coeff, nat_degree_expand, coeff_expand hp]
simp [hp, h]
simp
simp
simp
simp
simp [integral_normalization]
have : f.coeff i = 0 → f.degree ≠ i := fun hc hd => coeff_ne_zero_of_eq_degree hd hc
simp (config := { contextual := true }) [integral_normalization, coeff_monomial, this,
    mem_support_iff]
intro
simp (config := { contextual := true }) [integral_normalization, coeff_monomial, mem_support_iff]
rw [integral_normalization_coeff, if_pos hi]
rw [integral_normalization_coeff, if_neg hi]
rw [eval₂, sum_def, support_integral_normalization]
simp only [mul_comm z, mul_pow, mul_assoc, RingHom.map_pow, RingHom.map_mul]
exact finset.sum_attach.symm
rw [hz, _root_.mul_zero]
simp [mirror]
rw [← @rev_at_invol _ n₁, h, rev_at_invol]
rw [coeff_mirror, coeff_mirror, mirror_nat_degree, mirror_nat_trailing_degree, rev_at_invol]
rw [← p.mirror_mirror, h, mirror_zero]
rw [h, mirror_zero]
rw [leading_coeff, trailing_coeff, mirror_nat_trailing_degree, coeff_mirror,
    rev_at_le (Nat.le_add_left _ _), add_tsub_cancel_right]
rw [← p.mirror_mirror, mirror_trailing_coeff, p.mirror_mirror]
rw [coeff_mul, Finset.Nat.sum_antidiagonal_eq_sum_range_succ_mk]
refine'
    (Finset.sum_congr rfl fun n hn => _).trans
      (p.sum_eq_of_subset (fun n => (· ^ 2)) (fun n => zero_pow zero_lt_two) _ fun n hn =>
          finset.mem_range_succ_iff.mpr
            ((le_nat_degree_of_mem_supp n hn).trans (Nat.le_add_right _ _))).symm
rw [coeff_mirror, ← rev_at_le (finset.mem_range_succ_iff.mp hn), rev_at_invol, ← sq]
rw [mirror, mirror, reverse_neg, nat_trailing_degree_neg, neg_mul_eq_neg_mul]
rw [← C_mul', ← C_mul', mirror_mul_of_domain, mirror_C]
rw [fgh, mirror_mul_of_domain, mirror_mul_of_domain, mirror_mirror, mul_assoc, mul_comm h,
        mul_comm g.mirror, mul_assoc, ← mul_assoc]
rw [fgh]
exact dvd_mul_right g h
rw [fgh]
exact dvd_mul_left h g
rw [mirror_mul_of_domain, mirror_mirror]
exact dvd_mul_left h g.mirror
simp only [h0, nat_degree_zero]
rw [← leading_coeff_eq_zero, ← leading_coeff_eq_zero]
refine' eq_zero_or_eq_zero_of_mul_eq_zero _
rw [← leading_coeff_zero, ← leading_coeff_mul, h]
rw [← WithBot.coe_eq_coe, ← degree_eq_nat_degree (mul_ne_zero hp hq), WithBot.coe_add, ←
    degree_eq_nat_degree hp, ← degree_eq_nat_degree hq, degree_mul]
simp [hp0, hn0]
rw [hp0, zero_pow (Nat.pos_of_ne_zero hn0)] <;> simp
rw [← leading_coeff_pow, Ne.def, leading_coeff_eq_zero] <;> exact pow_ne_zero _ hp0
simp only [hp, zero_mul, le_refl]
rw [degree_mul, degree_eq_nat_degree hp, degree_eq_nat_degree hq] <;>
      exact WithBot.coe_le_coe.2 (Nat.le_add_right _ _)
simp
rw [← (le_root_multiplicity_iff p0).Not, not_le, Nat.lt_add_one_iff]
rw [← root_multiplicity_le_iff p0]
have hp : p ≠ 0 := left_ne_zero_of_mul hpq
have hq : q ≠ 0 := right_ne_zero_of_mul hpq
rw [root_multiplicity_eq_multiplicity (p * q), dif_neg hpq, root_multiplicity_eq_multiplicity p,
    dif_neg hp, root_multiplicity_eq_multiplicity q, dif_neg hq,
    multiplicity.mul' (prime_X_sub_C x)]
rw [root_multiplicity_eq_multiplicity, dif_neg (X_sub_C_ne_zero x),
    multiplicity.get_multiplicity_self]
decide
rw [degree_X_sub_C, degree_eq_nat_degree hp]
rw [degree_eq_nat_degree hp] at hpd
exact WithBot.coe_le_coe.2 (WithBot.coe_lt_coe.1 hpd)
intro a
rw [count_zero, root_multiplicity_eq_zero (not_exists.mp h a)]
unfold roots
rw [dif_neg hp0]
exact (Classical.choose_spec (exists_multiset_roots hp0)).1
rw [sub_eq_add_neg, ← C_neg] <;> exact degree_add_C hp0
simp_all [lt_irrefl]
rw [← count_pos, count_roots p, root_multiplicity_pos']
rw [count_add, count_roots, count_roots, count_roots, root_multiplicity_mul hpq]
rw [mem_roots', is_root.def, sub_ne_zero, eval_sub, sub_eq_zero, eval_C]
rw [← roots_X_sub_C, C_0, sub_zero]
rw [H, C_0, roots_zero]
rw [count_roots, count_zero, root_multiplicity_eq_zero (not_is_root_C _ _ H)]
rw [smul_eq_C_mul, roots_C_mul _ ha]
rw [List.mem_cons_iff, not_or] at H
rw [List.prod_cons, roots_mul (mul_ne_zero (Ne.symm H.1) <| List.prod_ne_zero H.2), ←
      Multiset.cons_coe, Multiset.cons_bind, ih H.2]
rw [roots_pow, roots_X]
rw [roots_C_mul _ ha, roots_X_pow]
rw [← C_mul_X_pow_eq_monomial, roots_C_mul_X_pow ha]
rw [nth_roots, mem_roots (X_pow_sub_C_ne_zero hn a), is_root.def, eval_sub, eval_C, eval_pow,
    eval_X, sub_eq_zero]
simp only [empty_eq_zero, pow_zero, nth_roots, ← C_1, ← C_sub, roots_C]
simp only [Nat.zero_le, nth_roots, roots, h, dif_pos rfl, empty_eq_zero, card_zero]
rw [hn, pow_zero, ← C_1, ← RingHom.map_sub]
exact degree_C_le
rw [← WithBot.coe_le_coe, ← degree_X_pow_sub_C (Nat.pos_of_ne_zero hn) a] <;>
      exact card_roots (X_pow_sub_C_ne_zero (Nat.pos_of_ne_zero hn) a)
rw [nth_roots_finset, mem_to_finset, mem_nth_roots h]
simp [nth_roots_finset]
rw [monic.def, leading_coeff_comp h, monic.def.1 hp, monic.def.1 hq, one_pow, one_mul]
refine' hp.comp (monic_X_add_C _) fun ha => _
rw [nat_degree_X_add_C] at ha
exact one_ne_zero ha
rw [← Polynomial.C_mul', ← Polynomial.eq_C_of_degree_eq_zero (degree_coe_units c)]
rw [← mul_eq_zero, ← nat_degree_comp, h, nat_degree_zero]
rw [h, zero_comp]
rw [h.2, comp_C, h.1, C_0]
rw [← sub_eq_zero]
apply zero_of_eval_zero
intro x
rw [eval_sub, sub_eq_zero, ext]
rw [root_set_def, map_C, roots_C, Multiset.to_finset_zero, Finset.coe_empty]
rw [← C_0, root_set_C]
rw [root_set, Finset.mem_coe, mem_to_finset, mem_roots', is_root.def, ← eval₂_eq_eval_map,
    aeval_def]
rw [mem_root_set',
    (map_injective _ (NoZeroSmulDivisors.algebra_map_injective T S)).ne_iff'
      (Polynomial.map_zero _)]
rw [mem_root_set'] at hx⊢
rw [aeval_alg_hom, AlgHom.comp_apply, hx.2, _root_.map_zero]
exact ⟨mt hp hx.1, rfl⟩
conv in 0 => rw [← nat_degree_coe_units u]
rw [← leading_coeff, Ne.def, leading_coeff_eq_zero]
exact Units.ne_zero _
let ⟨u, hu⟩ := h
simp [hu.symm]
decide
rw [hg, degree_mul, degree_X_sub_C, degree_eq_zero_of_is_unit hgu, add_zero]
simp only [count_roots, Finset.prod_multiset_map_count]
rw [count_roots, le_root_multiplicity_iff hp, ← Multiset.prod_repeat, ←
        Multiset.map_repeat fun a => X - C a, ← Multiset.filter_eq]
exact (Multiset.prod_dvd_prod_of_le <| Multiset.map_le_map <| s.filter_le _).trans h
rw [le_root_multiplicity_iff hmap]
refine' trans _ ((map_ring_hom f).map_dvd (pow_root_multiplicity_dvd p a))
rw [map_pow, map_sub, coe_map_ring_hom, map_X, map_C]
rw [count_roots]
apply count_map_roots h
rw [← p.roots.card_map f]
exact Multiset.card_le_of_le (map_roots_le h)
refine' ⟨h_irr.not_unit ∘ IsUnit.map (map_ring_hom φ), fun a b h => _⟩
dsimp [monic] at h_mon
have q := (leading_coeff_mul a b).symm
rw [← h, h_mon] at q
refine'
        (h_irr.is_unit_or_is_unit <| (congr_arg (map φ) h).trans (Polynomial.map_mul φ)).imp _ _ <;>
      apply is_unit_of_is_unit_leading_coeff_of_is_unit_map <;>
    apply isUnit_of_mul_eq_one
· exact q;
· rw [mul_comm]
    exact q
simp only [eval_zero, RingHom.map_zero, mul_zero, Polynomial.map_zero]
refine' ⟨r * a ^ n * b ^ (N - n), bi, bu, _⟩
rw [C_mul_X_pow_eq_monomial, map_monomial, ← C_mul_X_pow_eq_monomial, eval_mul, eval_pow, eval_C]
rw [RingHom.map_mul, RingHom.map_mul, RingHom.map_pow, RingHom.map_pow, eval_X, mul_comm]
rw [← tsub_add_cancel_of_le nN]
rw [pow_add, mul_assoc, mul_comm (i b ^ n), mul_pow, mul_assoc, mul_assoc (i a ^ n), ← mul_pow]
rw [bu, one_pow, mul_one]
rw [eq_int_cast, one_div_mul_cancel]
rw [Int.cast_ne_zero]
exact b0.ne.symm
rw [AddMonoidAlgebra, mk_finsupp_lift_of_infinite, lift_uzero, max_comm]
rfl
cases subsingleton_or_nontrivial R
· exact (mk_eq_one _).trans_le (le_max_of_le_right one_le_aleph_0)
· exact cardinal_mk_eq_max.le
rw [hfg, mul_comm, coeff_mul_X_zero]
rw [mul_comm, ← add_zero (f.div_X * X), ← C_0, ← hf, div_X_mul_X_add]
simp [hp0] at hp <;> contradiction
simp_all
simp [show _ = _ from hmp]
simp only [leading_coeff_pow' hpn0', leading_coeff_eq_zero, hpn1, one_pow, one_mul, Ne.def,
          hr0] <;>
        simp
rw [← WithBot.coe_lt_coe, ← degree_eq_nat_degree hp0] <;> exact hp
rw [← degree_eq_nat_degree h.2, ← degree_eq_nat_degree hq0] <;> exact h.1
rw [hq.degree_mul, degree_C_mul_X_pow _ hp, degree_eq_nat_degree h.2,
        degree_eq_nat_degree hq0, ← WithBot.coe_add, tsub_add_cancel_of_le hlt]
rw [leading_coeff_mul_monic hq, leading_coeff_mul_X_pow, leading_coeff_C]
unfold mod_
intro hp
unfold mod_
unfold mod_
unfold div_
unfold mod_
unfold div_
have : ¬degree q ≤ degree p := not_le_of_gt h
unfold mod_
have wf := div_wf_lemma h hq
have ih :=
        mod_
unfold mod_
have := mod_
have : ¬degree q ≤ degree p := not_le_of_gt h
unfold div_
rw [degree_mul' hlc, degree_eq_nat_degree hq.ne_zero, degree_eq_nat_degree hdiv0, ←
            WithBot.coe_add, WithBot.coe_le_coe] <;>
          exact Nat.le_add_right _ _
unfold div_
simp [h₁]
erw [degree_eq_nat_degree hg.ne_zero, degree_eq_nat_degree hqf, WithBot.coe_le_coe] <;>
              exact Nat.le_add_right _ _
rw [monic.def.1 hq, f.map_one] <;> exact one_ne_zero
rw [hmod, leading_coeff_eq_zero.1 h, mul_zero, leading_coeff_zero]
rw [H, Polynomial.map_zero]
rw [H, Polynomial.map_zero]
rw [← h, is_root.def, eval_mul, eval_sub, eval_X, eval_C, sub_self, zero_mul]
simp
rw [zero_add]
simp only [root_multiplicity_eq_multiplicity, dite_eq_left_iff, PartEnat.get_eq_iff_eq_coe,
    Nat.cast_zero, multiplicity.multiplicity_eq_zero, dvd_iff_is_root, not_imp_not]
rw [pos_iff_ne_zero, Ne.def, root_multiplicity_eq_zero_iff, not_imp, and_comm]
simp only [root_multiplicity_eq_zero_iff, is_root, eval_C, C_eq_zero, imp_self]
simp [h]
rw [root_multiplicity_eq_multiplicity, dif_neg h] <;> exact multiplicity.pow_multiplicity_dvd _
decide
rw [hasse_deriv_apply, coeff_sum, sum_def, Finset.sum_eq_single (n + k), coeff_monomial]
· simp only [if_true, add_tsub_cancel_right, eq_self_iff_true]
· intro i hi hink
    rw [coeff_monomial]
simp only [hasse_deriv_apply, tsub_zero, Nat.choose_zero_right, Nat.cast_one, one_mul,
    sum_monomial_eq]
rw [hasse_deriv_apply, sum_def]
refine' Finset.sum_eq_zero fun x hx => _
simp [Nat.choose_eq_zero_of_lt ((le_nat_degree_of_mem_supp _ hx).trans_lt h)]
simp only [hasse_deriv_apply, derivative_apply, ← C_mul_X_pow_eq_monomial, Nat.choose_one_right,
    (Nat.cast_commute _ _).Eq]
rw [← monomial_zero_left, hasse_deriv_monomial, Nat.choose_eq_zero_of_lt hk, Nat.cast_zero,
    zero_mul, monomial_zero_right]
rw [← C_1, hasse_deriv_C k _ hk]
rw [← monomial_one_one_eq_X, hasse_deriv_monomial, Nat.choose_eq_zero_of_lt hk, Nat.cast_zero,
    zero_mul, monomial_zero_right]
intro x hx
rw [Finset.Nat.mem_antidiagonal] at hx
subst hx
simp only [coe_map_ring_hom, lifts, RingHom.mem_srange]
simp only [coe_map_ring_hom, lifts, Set.mem_range, RingHom.mem_srange]
simp only [coe_map_ring_hom, lifts, Set.mem_range, RingHom.mem_srange]
rw [lifts_iff_ring_hom_srange, mem_map_srange f]
rfl
simp only [coe_map_ring_hom, map_C, Set.mem_univ, Subsemiring.coe_top, eq_self_iff_true,
      and_self_iff]
simp only [coe_map_ring_hom, Set.mem_univ, Subsemiring.coe_top, eq_self_iff_true, map_X,
      and_self_iff]
simp only [coe_map_ring_hom, map_pow, Set.mem_univ, Subsemiring.coe_top, eq_self_iff_true,
      map_X, and_self_iff]
rw [lifts_iff_ring_hom_srange, mem_map_srange] at h⊢
intro k
simp [coeff_monomial] at hq
exact hq
intro habs
simp only [habs, RingHom.map_zero] at hcoeff
exact hzero hcoeff.symm
generalize hd : p.nat_degree = d
revert hd p
apply Nat.strong_induction_on d
intro n hn p hlifts hdeg
rw [← leading_coeff, Ne.def, leading_coeff_eq_zero] <;> exact pzero
rw [hlead.2, ← C_mul_X_pow_eq_monomial, degree_C_mul_X_pow p.nat_degree lead_zero]
rw [@degree_X_pow R, hq.2, degree_eq_nat_degree h0, WithBot.coe_lt_coe]
exact Or.resolve_right (erase_lead_nat_degree_lt_or_erase_lead_eq_zero p) h0
simp
simp
simp only [lifts, lifts_ring, RingHom.mem_range, RingHom.mem_srange]
simp only [map_alg, aeval_def, eval₂, map, algebra_map_apply, RingHom.coe_comp]
simp only [coe_map_ring_hom, lifts, map_alg_eq_map, AlgHom.mem_range, RingHom.mem_srange]
rw [mem_lifts_iff_mem_alg] at hp⊢
exact Subalgebra.smul_mem (map_alg R S).range hp r
intro a b hab
rw [← @rev_at_fun_invol N a, hab, rev_at_fun_invol]
simp [rev_at]
rw [rev_at_invol]
rw [← one_mul (X ^ n), ← one_mul (X ^ rev_at N n), ← C_1, reflect_C_mul_X_pow]
rw [reverse, coeff_reflect]
rw [coeff_reverse, rev_at_le (zero_le f.nat_degree), tsub_zero, leading_coeff]
simp [reverse]
rw [nat_degree_le_iff_degree_le, degree_le_iff_coeff_zero]
intro n hn
rw [WithBot.coe_lt_coe] at hn
rw [coeff_reverse, rev_at, Function.Embedding.coeFn_mk, if_neg (not_le_of_gt hn),
    coeff_eq_zero_of_nat_degree_lt hn]
rw [f.nat_degree_eq_reverse_nat_degree_add_nat_trailing_degree, add_tsub_cancel_right]
rw [leading_coeff, reverse_nat_degree, ← rev_at_le f.nat_trailing_degree_le_nat_degree,
    coeff_reverse, rev_at_invol, trailing_coeff]
rw [trailing_coeff, reverse_nat_trailing_degree, coeff_zero_reverse]
unfold reverse
rw [nat_degree_mul' fg, reflect_mul f g rfl.le rfl.le]
rw [← reverse_leading_coeff, reverse_mul_of_domain, leading_coeff_mul, reverse_leading_coeff,
    reverse_leading_coeff]
simp only [hf, zero_lt_one]
rw [neg_eq_neg_one_mul, ← C_1, ← C_neg, reflect_C_mul, C_neg, C_1, ← neg_eq_neg_one_mul]
rw [sub_eq_add_neg, sub_eq_add_neg, reflect_add, reflect_neg]
rw [reverse, reverse, reflect_neg, nat_degree_neg]
rw [Polynomial.map_mul] <;> exact hg.trans (dvd_mul_right _ _)
rw [Polynomial.map_mul] <;> exact hg.trans (dvd_mul_left _ _)
simp [splits, Polynomial.map_map]
refine' Finset.induction_on t (fun _ => splits_one i) fun a t hat ih ht => _
rw [Finset.forall_mem_insert] at ht
rw [Finset.prod_insert hat]
exact splits_mul i ht.1 (ih ht.2)
rw [← Finset.card_range n, ← Finset.prod_const]
exact splits_prod i fun j hj => hf
rw [splits_map_iff, RingHom.id_comp]
simp [eval₂_eq_eval_map, hf0']
rw [← eval_map, hi, eval_mul, show _ = _ from hx, zero_mul]
rw [← eval_map] at hx
cases h.subst ((mem_roots _).2 hx)
exact ne_zero_of_nat_degree_gt (Nat.pos_of_ne_zero hf0)
rw [h, mul_zero]
simp [h]
rw [degree_eq_nat_degree p_ne_zero, nat_degree_eq_card_roots' hsplit]
rw [splits, map_eq_zero]
refine'
    Finset.induction_on t (fun _ => ⟨fun _ _ h => h.elim, fun _ => splits_one i⟩)
      fun a t hat ih ht => _
rw [Finset.forall_mem_insert] at ht⊢
rw [Finset.prod_insert hat, splits_mul_iff i ht.1 (Finset.prod_ne_zero_iff.2 ht.2), ih ht.2]
rw [degree_eq_nat_degree p_ne_zero, nat_degree_eq_card_roots hsplit]
rw [← image_root_set h f, Algebra.adjoin_image, ← Algebra.map_top]
exact (Subalgebra.map_injective f.to_ring_hom.injective).eq_iff
apply Polynomial.map_injective _ i.injective
rw [eq_prod_roots_of_splits h_splits, h_roots]
simp
decide
rw [map_id]
change i with (RingHom.id _).comp i at h
rw [← splits_map_iff]
rw [← splits_map_iff i] at h
exact splits_of_splits_id _ h
dsimp only [RingHom.toFun_eq_coe, RingHom.comp_apply]
rw [to_finsupp_smul, to_finsupp_mul, to_finsupp_C]
exact Algebra.smul_def' _ _
rw [to_finsupp_C]
rfl
dsimp
exact to_finsupp_algebra_map _
rw [Ne.def, SetLike.ext_iff, not_forall]
refine' ⟨X, _⟩
simp only [Algebra.mem_bot, not_exists, Set.mem_range, iff_true_iff, Algebra.mem_top,
        algebra_map_apply, not_forall]
intro x
rw [ext_iff, not_forall]
refine' ⟨1, _⟩
simp [coeff_C]
dsimp [eval₂, Sum]
simp only [f.map_sum, f.map_mul, f.map_pow, eq_int_cast, map_int_cast, AlgHom.commutes]
simp only [aeval_X, AlgHom.comp_apply]
rw [← aeval_def, aeval_alg_hom, aeval_X_left, AlgHom.comp_id]
simp
simp
simp [coeff_zero_eq_eval_zero]
simp [aeval_def]
rw [← Algebra.map_top, ← adjoin_X, AlgHom.map_adjoin, Set.image_singleton, aeval_X]
intro h
apply hf
rw [← eval₂_hom, h, f.map_zero]
simp [algebra_map_apply]
erw [← eval_mul_X_sub_C, hgf, eval_one]
rw [aeval_def, eval₂]
exact (LinearMap.applyₗ v).map_sum
cases f <;> rfl
rw [add]
rw [neg]
rw [sub_eq_add_neg, of_finsupp_add, of_finsupp_neg]
rfl
rw [mul]
change _ = npowRec n _
induction n
· simp [npowRec]
· simp [npowRec, n_ih, pow_succ]
cases a
cases b
rw [← of_finsupp_add]
cases a
rw [← of_finsupp_neg]
rw [sub_eq_add_neg, ← to_finsupp_neg, ← to_finsupp_add]
rfl
cases a
cases b
rw [← of_finsupp_mul]
cases a
rw [← of_finsupp_pow]
rw [← to_finsupp_zero, to_finsupp_inj]
rw [← to_finsupp_one, to_finsupp_inj]
rw [← of_finsupp_zero, of_finsupp_inj]
rw [← of_finsupp_one, of_finsupp_inj]
rw [support]
simp
simp
simp [← of_finsupp_smul]
simp [monomial]
simp [monomial]
simp only [to_finsupp_monomial, to_finsupp_mul, AddMonoidAlgebra.single_mul_single]
simp
simp [monomial_zero_one]
simp [monomial_mul_monomial]
simp
simp
simp [bit1, C_bit0]
simp only [← monomial_zero_left, monomial_mul_monomial, zero_add]
simp only [← monomial_zero_left, monomial_mul_monomial, add_zero]
rw [mul_assoc, X_pow_mul, ← mul_assoc]
erw [monomial_mul_monomial, mul_one]
rw [X_mul, monomial_mul_X]
rw [X_pow_mul, monomial_mul_X_pow]
cases f <;> rfl
simp only [← of_finsupp_single, coeff, LinearMap.coe_mk]
rw [Finsupp.single_apply]
rw [← monomial_zero_one, coeff_monomial]
simp
simp [coeff_monomial]
rw [coeff_X, if_neg hn.symm]
simp
rw [coeff_C, if_neg h]
rw [pow_succ', ← mul_assoc, C_mul_X_pow_eq_monomial, X, monomial_mul_monomial, mul_one]
rw [C_mul_X_pow_eq_monomial, to_finsupp_monomial]
rw [← C_mul_X_pow_eq_monomial, pow_one]
rw [C_mul_X_eq_monomial, to_finsupp_monomial]
intro
infer_instance
rw [← one_smul R p, ← h, zero_smul]
rw [← of_finsupp_single, support, Finsupp.support_single_ne_zero _ H]
rw [← of_finsupp_single, support]
exact Finsupp.support_single_subset
rw [C_mul_X_eq_monomial, support_monomial 1 h]
rw [C_mul_X_pow_eq_monomial, support_monomial n h]
rw [X_pow_eq_monomial, to_finsupp_monomial]
rw [X_pow_eq_monomial, smul_monomial, smul_eq_mul, mul_one]
rw [X, H, monomial_zero_right, support_zero]
rw [← pow_one X, support_X_pow H 1]
apply Finset.sum_subset hs fun n hn h'n => _
rw [not_mem_support_iff] at h'n
simp [h'n, hf]
simp [Sum]
simp [sum_def, Finset.sum_add_distrib]
simp
simp
simp [coeff_erase]
simp [coeff_erase, h]
rw [coeff_update, Function.update_apply]
rw [p.coeff_update_apply, if_pos rfl]
rw [p.coeff_update_apply, if_neg h]
cases p
simp only [support, update, support_update]
congr
rw [update_zero_eq_erase, support_erase]
rw [eq_neg_iff_add_eq_zero, ← monomial_add, neg_add_self, monomial_zero_right]
infer_instance
simp
intro
simp
rw [this, one_mul]
rw [show _ = _ from hp, f.map_one]
exact one_ne_zero
simp [this]
rw [coeff_add, coeff_X_pow, if_pos rfl, coeff_eq_zero_of_degree_lt H1, add_zero]
simp [monic.def.1 hp, monic.def.1 hq, Ne.symm h0]
rw [pow_succ]
exact hp.mul (monic.pow n)
rw [← hp.nat_degree_eq_zero_iff_eq_one, nat_degree_eq_zero_iff_degree_le_zero]
rw [← degree_map_eq_of_leading_coeff_ne_zero f _, map_eq, degree_one]
· rw [hp.leading_coeff, f.map_one]
      exact one_ne_zero
rw [(monic_X_add_C r).nat_degree_pow, nat_degree_X_add_C, mul_one]
revert ht
refine' t.induction_on _ _
· simp
intro a t ih ht
rw [Multiset.map_cons, Multiset.prod_cons]
exact (ht _ (Multiset.mem_cons_self _ _)).mul (ih fun _ hi => ht _ (Multiset.mem_cons_of_mem hi))
refine' le_antisymm (nat_degree_map_le _ _) (le_nat_degree_of_ne_zero _)
rw [coeff_map, monic.coeff_nat_degree hmo, RingHom.map_one]
exact one_ne_zero
simp [h]
rw [← f.map_zero] <;> exact mt hf.eq_iff.1 (mt leading_coeff_eq_zero.1 h)
unfold leading_coeff
rw [coeff_map, nat_degree_map_eq_of_injective hf p]
delta leading_coeff
rw [coeff_map f, nat_degree_map_eq_of_injective hf p]
apply hf
rw [← leading_coeff_of_injective hf, hp.leading_coeff, f.map_one]
rw [nat_degree_neg, coeff_neg, show q.coeff q.nat_degree = -1 from hq, neg_neg]
constructor
· intro q r h
    rw [← sub_eq_zero, ← hp.mul_right_eq_zero_iff, mul_sub, h, sub_self]
· intro q r h
    simp only at h
    rw [← sub_eq_zero, ← hp.mul_left_eq_zero_iff, sub_mul, h, sub_self]
rw [leading_coeff, leading_coeff, coeff_smul, nat_degree_smul_of_smul_regular p h]
simp
simp
rw [hz]
exists (pow_add_expansion x y e).val
congr
apply (pow_add_expansion _ _ _).property
unfold eval eval₂
congr
rw [poly_binom_aux2]
simp [left_distrib, sum_add, mul_assoc]
exists f.sum fun e a => a * (poly_binom_aux1 x y e a).val
rw [poly_binom_aux3]
congr
· rw [← eval_eq_sum]
· rw [derivative_eval]
    exact finset.sum_mul.symm
· exact finset.sum_mul.symm
simp
simp
refine' ⟨f.sum fun i r => r * (pow_sub_pow_factor x y i).val, _⟩
delta eval eval₂
simp only [Sum, ← Finset.sum_sub_distrib, Finset.sum_mul]
dsimp
congr
simp (config := { contextual := true }) only [eval₂_eq_sum, zero_pow_eq, mul_ite, mul_zero,
    mul_one, Sum, not_not, mem_support_iff, sum_ite_eq', ite_eq_left_iff, RingHom.map_zero,
    imp_true_iff, eq_self_iff_true]
simp [eval₂_eq_sum]
simp [eval₂_eq_sum]
simp [eval₂_eq_sum]
simp [eval₂_eq_sum]
apply sum_add_index <;> simp [add_mul]
rw [← C_1, eval₂_C, f.map_one]
rw [bit0, eval₂_add, bit0]
rw [bit1, eval₂_add, eval₂_bit0, eval₂_one, bit1]
simp [hp, hq]
rw [eval₂_monomial, ← smul_X_eq_monomial, C_mul']
simp only [eval₂_eq_sum, Sum, to_finsupp_sum, support, coeff]
rfl
rw [eval₂_X]
rw [X_mul, eval₂_mul_X]
rw [eval₂_mul_noncomm, eval₂_C]
intro k
simp
rw [eval₂_eq_sum, p.sum_over_range' _ _ hn]
intro i
rw [f.map_zero, zero_mul]
rw [eval₂_mul f x]
exact mul_eq_zero_of_left hp (q.eval₂ f x)
rw [eval₂_mul f x]
exact mul_eq_zero_of_right (p.eval₂ f x) hq
rw [eval_eq_sum, sum_over_range] <;> simp
rw [eval_eq_sum, p.sum_over_range' _ _ hn] <;> simp
rw [eval₂_eq_sum, eval_eq_sum, Sum, Sum, f.map_sum]
simp only [f.map_mul, f.map_pow]
simp only [← C_eq_nat_cast, eval_C]
rw [← smul_one_smul R s p, eval, eval₂_smul, RingHom.id_apply, smul_one_mul]
apply Polynomial.induction_on' p
· intro p q ph qh
    simp only [mul_add, eval_add, ph, qh]
· intro n b
    simp only [mul_assoc, C_mul_monomial, eval_monomial]
simp only [Nat.cast_succ]
rw [← C_eq_nat_cast, eval_C_mul]
apply Polynomial.induction_on' p
· intro p q ph qh
    simp only [add_mul, eval_add, ph, qh]
· intro n a
    simp only [← monomial_one_one_eq_X, monomial_mul_monomial, eval_monomial, mul_one, pow_succ',
      mul_assoc]
unfold is_root <;> infer_instance
simp
simp [zero_pow (Nat.pos_of_ne_zero hb)]
simp
simp only [comp, eval₂, C_mul_X_pow_eq_monomial]
exact sum_monomial_eq _
rw [← C_eq_nat_cast, C_comp]
rw [← C_0, comp_C]
rw [← C_0, C_comp]
rw [← C_1, comp_C]
rw [← C_1, C_comp]
apply Polynomial.induction_on' p
· intro p q hp hq
    simp only [hp, hq, add_mul, add_comp]
· intro n b
    simp only [pow_succ', mul_assoc, monomial_mul_X, monomial_comp]
apply Polynomial.induction_on' p
· intro p q hp hq
    simp [hp, hq, mul_add]
· intro n b
    simp [mul_assoc]
rw [← C_eq_nat_cast, C_mul_comp, C_eq_nat_cast]
simp only [bit0, add_comp]
simp only [bit1, add_comp, bit0_comp, one_comp]
rw [← smul_one_smul R s p, comp, comp, eval₂_smul, ← smul_eq_C_mul, smul_assoc, one_smul]
apply Polynomial.induction_on φ <;>
    · intros
      simp_all only [add_comp, mul_comp, C_comp, X_comp, pow_succ', ← mul_assoc]
dsimp only [map]
rw [eval₂_monomial, ← C_mul_X_pow_eq_monomial]
rfl
rw [map, eval₂_mul_noncomm]
exact fun k => (commute_X _).symm
rw [map, eval₂_smul, RingHom.comp_apply, C_mul']
simp [coeff_map]
simp [Polynomial.ext_iff, coeff_map]
apply Polynomial.induction_on' p
· intro p q hp hq
    simp [hp, hq]
· intro n r
    simp
rw [← coeff_map f, ← coeff_map f, h]
rw [Polynomial.map_add f, hp', hq']
rw [map_monomial f, hr]
apply (degree_le_iff_coeff_zero _ _).2 fun m hm => _
rw [degree_lt_iff_coeff_zero] at hm
simp [hm m le_rfl]
simp only [mul_one, hp.leading_coeff, f.map_one]
simp only [hfp, mul_zero, coeff_zero]
simp only [h, coeff_map, coeff_zero]
have hp0 : p ≠ 0 := leading_coeff_ne_zero.mp fun hp0 => hf (trans (congr_arg _ hp0) f.map_zero)
rw [degree_eq_nat_degree hp0]
refine' le_degree_of_ne_zero _
rw [coeff_map]
exact hf
unfold leading_coeff
rw [coeff_map, nat_degree_map_of_leading_coeff_ne_zero f hf]
rw [eval₂_eq_eval_map, eval₂_eq_eval_map, map_map]
simp only [map_C, forall_const, C_comp, eq_self_iff_true]
simp (config := { contextual := true }) only [Polynomial.map_add, add_comp, forall_const,
        imp_true_iff, eq_self_iff_true]
simp (config := { contextual := true }) only [pow_succ', ← mul_assoc, comp, forall_const,
        eval₂_mul_X, imp_true_iff, eq_self_iff_true, map_X, Polynomial.map_mul]
simp [← coeff_zero_eq_eval_zero]
apply Polynomial.induction_on' p
· intro p q hp hq
    simp only [hp, hq, Polynomial.map_add, RingHom.map_add, eval_add]
· intro n r
    simp only [one_pow, mul_one, eval_monomial, map_monomial]
apply Polynomial.induction_on' p
· intro p q hp hq
    simp only [hp, hq, Polynomial.map_add, RingHom.map_add, eval_add]
· intro n r
    simp only [map_nat_cast f, eval_monomial, map_monomial, f.map_pow, f.map_mul]
apply Polynomial.induction_on' p
· intro p q hp hq
    simp only [hp, hq, Polynomial.map_add, RingHom.map_add, eval_add]
· intro n r
    simp only [map_int_cast, eval_monomial, map_monomial, map_pow, map_mul]
rw [← eval₂_map, eval₂_at_apply, eval_map]
rw [comp, p.as_sum_range] <;> simp [eval₂_finset_sum, eval₂_pow]
apply Polynomial.induction_on' p
· intro r s hr hs
    simp [add_comp, hr, hs]
· intro n a
    simp
rw [is_root, eval_mul, is_root.def.1 H, mul_zero]
rw [is_root, eval_mul, is_root.def.1 H, zero_mul]
simp only [is_root, eval_prod, Finset.prod_eq_zero_iff]
simp [eval_finset_sum]
rw [is_root, eval_map, eval₂_hom, h.eq_zero, f.map_zero]
simp only [← C_eq_int_cast, eval_C]
rw [eq_neg_iff_add_eq_zero, ← eval₂_add, add_left_neg, eval₂_zero]
rw [sub_eq_add_neg, eval₂_add, eval₂_neg, sub_eq_add_neg]
rw [is_root.def, eval_sub, eval_X, eval_C, sub_eq_zero, eq_comm]
cases i <;> simp
rw [← RingHom.map_mul, Units.mul_inv, C_1]
rw [← RingHom.map_mul, Units.inv_mul, C_1]
simp
dsimp
rw [Ne.def, ← leading_coeff_eq_zero] at *
rw [leading_coeff_mul, norm_unit_mul hp0 hq0, Units.val_mul, C_mul]
simp [norm_unit]
simp
simp only [Polynomial.coe_norm_unit, normalize_apply, hp.leading_coeff, norm_unit_one,
    Units.val_one, polynomial.C.map_one, mul_one]
rw [normalize_apply, mul_comm, coe_norm_unit, roots_C_mul _ (norm_unit (leading_coeff p)).NeZero]
rw [monic, leading_coeff_mul, leading_coeff_C,
    mul_inv_cancel (show leading_coeff p ≠ 0 from mt leading_coeff_eq_zero.1 h)]
simp only [Polynomial.ext_iff, map_eq_zero, coeff_map, coeff_zero]
simp [*, le_refl]
conv in p => rw [eq_C_of_degree_le_zero this]
rw [← C_mul, _root_.mul_inv_cancel hc, C_1]
rw [← degree_mul_leading_coeff_inv q hq] <;>
    exact degree_mod_
simp only [monic.def.1 hq, inv_one, mul_one, C_1]
simp only [monic.def.1 hq, inv_one, C_1, one_mul, mul_one]
simp [div_def]
simp [hq]
rw [div_def, mul_comm, degree_mul_leading_coeff_inv _ hq] <;> exact degree_div_
rw [degree_mul_leading_coeff_inv _ hq0] <;> exact hq
simp only [← coeff_nat_degree, coeff_map f, nat_degree_map]
rw [monic, leading_coeff_map, ← f.map_one, Function.Injective.eq_iff f.injective, monic]
simp [hq0]
simp [hq0]
rw [gcd_val, ← map_mod, ih, ← gcd_val]
rw [EuclideanDomain.gcd_eq_gcd_ab f g, Polynomial.eval₂_add, Polynomial.eval₂_mul,
    Polynomial.eval₂_mul, hf, hg, zero_mul, zero_mul, zero_add]
rw [← EuclideanDomain.gcd_is_unit_iff, ← EuclideanDomain.gcd_is_unit_iff, gcd_map, is_unit_map]
rw [mem_roots (map_ne_zero hp), is_root, Polynomial.eval_map] <;> infer_instance
rw [root_set, map_monomial, roots_monomial ((_root_.map_ne_zero (algebraMap R S)).2 ha),
    Multiset.to_finset_nsmul _ _ hn, Multiset.to_finset_singleton, Finset.coe_singleton]
rw [C_mul_X_pow_eq_monomial, root_set_monomial hn ha]
rw [← one_mul (X ^ n : R[X]), ← C_1, root_set_C_mul_X_pow hn]
exact one_ne_zero
rw [h] <;> exact le_rfl
rw [Ne.def, ← leading_coeff_eq_zero, ← Ne.def, ← isUnit_iff_ne_zero] at hp0
rw [monic, leading_coeff_normalize, normalize_eq_one]
apply hp0
rw [mul_assoc, mul_left_comm p, ← mul_assoc, ← C.map_mul, _root_.mul_inv_cancel ha, C.map_one,
        one_mul, hr]
rw [mul_left_comm p, ← hr, ← mul_assoc, ← C.map_mul, _root_.inv_mul_cancel ha, C.map_one,
        one_mul]
have : p.leadingCoeff ≠ 0 := mt leading_coeff_eq_zero.mp hp
simp [CommGroupWithZero.coe_norm_unit _ this]
simp [h]
rw [H, Polynomial.map_zero, zero_dvd_iff, zero_dvd_iff, map_eq_zero]
rw [← normalize_dvd_iff, ← @normalize_dvd_iff R[X], normalize_apply, normalize_apply,
      coe_norm_unit_of_ne_zero H, coe_norm_unit_of_ne_zero (mt (map_eq_zero f).1 H),
      leading_coeff_map, ← map_inv₀ f, ← map_C, ← Polynomial.map_mul,
      map_dvd_map _ f.injective (monic_mul_leading_coeff_inv H)]
simp
decide
rw [H, C_0]
exact not_irreducible_zero
rw [← not_mem_support_iff]
exact fun hi' => hi (Finset.mem_singleton.1 (hn hi'))
rw [h]
rw [h]
unfold monic <;> infer_instance
rw [Subsingleton.elim p 0, degree_zero]
rw [Subsingleton.elim p 0, nat_degree_zero]
let ⟨n, hn⟩ := not_forall.1 (mt Option.eq_none_iff_forall_not_mem.2 (mt degree_eq_bot.1 hp))
have hn : degree p = some n := not_not.1 hn
rw [nat_degree, hn] <;> rfl
rw [degree_eq_nat_degree hp, WithBot.coe_eq_coe]
unfold nat_degree <;> rw [h]
rw [← WithBot.coe_le_coe, ← degree_eq_nat_degree]
exact le_degree_of_ne_zero h
· intro h
    subst h
    exact h rfl
rw [nat_degree, h, WithBot.unbot'_coe]
rw [degree, ← monomial_zero_left, support_monomial 0 ha, max_eq_sup_coe, sup_singleton,
    WithBot.coe_zero]
rw [← C_1] <;> exact degree_C_le
rw [ha, C_0]
simp only [← C_eq_nat_cast, nat_degree_C]
rw [degree, support_monomial n ha] <;> rfl
rw [C_mul_X_pow_eq_monomial, degree_monomial n ha]
rw [h, (monomial n).map_zero] <;> exact bot_le
rw [C_mul_X_pow_eq_monomial]
apply degree_monomial_le
apply coeff_eq_zero_of_degree_lt
refine' Iff.trans Polynomial.ext_iff _
refine' forall_congr' fun i => ⟨fun h _ => h, fun h => _⟩
refine' (le_or_lt i n).elim h fun k => _
refine'
    (coeff_eq_zero_of_nat_degree_lt (hp.trans_lt k)).trans
      (coeff_eq_zero_of_nat_degree_lt (hq.trans_lt k)).symm
simp only [C_mul_X_pow_eq_monomial]
simp only [C_mul_X_pow_eq_monomial]
simp
simp [coeff_C]
decide
simp only [leading_coeff, nat_degree_eq_of_degree_eq_some h]
rw [← one_mul X, ← C_1, ← hm.coeff_nat_degree, hnd, ← eq_X_add_C_of_nat_degree_le_one hnd.le]
rw [← card_singleton n]
apply card_le_of_subset (support_C_mul_X_pow' n c)
rw [← Finset.card_range (p.nat_degree + 1)]
exact Finset.card_le_of_subset supp_subset_range_nat_degree_succ
rw [Ne.def, nonempty_iff_ne_empty, Ne.def, ← support_eq_empty]
simp [mul_sub]
unfold degree <;> rw [support_neg]
simp [nat_degree]
rw [← C_eq_int_cast, nat_degree_C]
rw [leading_coeff, leading_coeff, nat_degree_neg, coeff_neg]
rw [next_coeff]
simp
cases le_max_iff.1 (degree_add_le p q) <;> simp [nat_degree_le_nat_degree h]
rw [Ne.def, leading_coeff_eq_zero]
rw [leading_coeff_eq_zero, degree_eq_bot]
rw [mem_support_iff]
exact (not_congr leading_coeff_eq_zero).mpr H
rw [coeff_add, coeff_nat_degree_eq_zero_of_degree_lt h, add_zero]
exact mt leading_coeff_eq_zero.1 (ne_zero_of_degree_gt h)
rw [add_comm, degree_add_eq_left_of_degree_lt h]
rw [degree_add_eq_right_of_degree_lt hlt, max_eq_right_of_lt hlt] <;> exact le_rfl
rw [HEq, max_self] at hlt
rw [leading_coeff, leading_coeff, nat_degree_eq_of_degree_eq HEq, ← coeff_add]
exact coeff_nat_degree_eq_zero_of_degree_lt hlt
rw [degree_add_eq_left_of_degree_lt hlt, max_eq_left_of_lt hlt] <;> exact le_rfl
apply lt_of_le_of_ne (degree_erase_le _ _)
rw [degree_eq_nat_degree hp, degree, support_erase]
exact fun h => not_mem_erase _ _ (mem_of_max h)
simp only [sum_empty, sup_empty, degree_zero, le_refl]
rw [sum_insert has] <;> exact degree_add_le _ _
rw [sup_insert, sup_eq_max] <;> exact max_le_max le_rfl ih
refine'
        Finset.sup_le fun a ha => Finset.sup_le fun b hb => le_trans (degree_C_mul_X_pow_le _ _) _
rw [WithBot.coe_add]
rw [mem_support_iff] at ha hb
exact add_le_add (le_degree_of_ne_zero ha) (le_degree_of_ne_zero hb)
rw [pow_zero, zero_nsmul] <;> exact degree_one_le
rw [pow_succ] <;> exact degree_mul_le _ _
rw [succ_nsmul] <;> exact add_le_add le_rfl (degree_pow_le _)
rw [C_mul_X_pow_eq_monomial, leading_coeff_monomial]
have : coeff p (natDegree q) = 0 := coeff_nat_degree_eq_zero_of_degree_lt h
simp only [leading_coeff, nat_degree_eq_of_degree_eq (degree_add_eq_right_of_degree_lt h), this,
    coeff_add, zero_add]
apply nat_degree_eq_of_degree_eq <;>
      rw [degree_add_eq_of_leading_coeff_add_ne_zero hlc, h, max_self]
rw [coeff_eq_zero_of_degree_lt
                  (lt_of_le_of_lt degree_le_nat_degree (WithBot.coe_lt_coe.2 this)),
                mul_zero]
rw [hp, leading_coeff_zero, zero_mul]
rw [hq, leading_coeff_zero, mul_zero]
simp [hp]
rw [h₁, zero_mul]
rw [h₁, mul_zero]
rw [degree_mul' h, WithBot.coe_add, degree_eq_nat_degree hp, degree_eq_nat_degree hq]
unfold leading_coeff
rw [nat_degree_mul' h, coeff_mul_degree_add_degree]
rfl
rw [C_mul_X_pow_eq_monomial, monomial_nat_degree_leading_coeff_eq_self h]
simp
rw [pow_succ, h₁, mul_zero]
rw [pow_zero, ← C_1] at * <;> rw [degree_C h, zero_nsmul]
rw [pow_succ, h₁, mul_zero]
simp [*]
rw [hp0, zero_pow (Nat.pos_of_ne_zero hn0)] <;> simp
have h1 := h
rw [← leading_coeff_pow' h1, hpn0, leading_coeff_zero] at h <;> exact h rfl
rw [← degree_eq_nat_degree hpn, degree_pow' h, degree_eq_nat_degree hp0, ←
            WithBot.coe_nsmul] <;>
          simp
rw [H, leading_coeff_eq_zero.1 H, zero_mul, leading_coeff_zero]
apply nat_degree_le_of_degree_le
apply le_trans (degree_mul_le p q)
rw [WithBot.coe_add]
refine' add_le_add _ _ <;> apply degree_le_nat_degree
apply lt_of_le_of_ne nat_degree_pow_le fun h => hp2 _
rw [← h, hp1] at hi
exact leading_coeff_eq_zero.mp hi
rw [← not_lt, Nat.WithBot.lt_zero_iff, degree_eq_bot]
rw [← nonpos_iff_eq_zero, nat_degree_le_iff_degree_le, WithBot.coe_zero]
simp only [degree, Finset.max, Finset.sup_le_iff, mem_support_iff, Ne.def, ← not_le, not_imp_comm]
refine'
    ⟨fun hf m hm => coeff_eq_zero_of_degree_lt (lt_of_lt_of_le hf (WithBot.coe_le_coe.2 hm)), _⟩
simp only [degree, Finset.sup_lt_iff (WithBot.bot_lt_coe n), mem_support_iff, WithBot.some_eq_coe,
    WithBot.coe_lt_coe, ← @not_le ℕ, max_eq_sup_coe]
exact fun h m => mt (h m)
apply (degree_le_iff_coeff_zero _ _).2 fun m hm => _
rw [degree_lt_iff_coeff_zero] at hm
simp [hm m le_rfl]
rw [degree_add_eq_left_of_degree_lt <| degree_C_lt_degree_C_mul_X ha, degree_C_mul_X ha]
rw [add_comm, leading_coeff_add_of_degree_lt (degree_C_lt_degree_C_mul_X ha),
    leading_coeff_C_mul_X]
rw [add_assoc, degree_add_eq_left_of_degree_lt <| degree_linear_lt_degree_C_mul_X_sq ha,
    degree_C_mul_X_pow 2 ha]
rfl
rw [add_assoc, add_comm, leading_coeff_add_of_degree_lt <| degree_linear_lt_degree_C_mul_X_sq ha,
    leading_coeff_C_mul_X_pow]
rw [add_assoc, add_assoc, ← add_assoc (C b * X ^ 2),
    degree_add_eq_left_of_degree_lt <| degree_quadratic_lt_degree_C_mul_X_cb ha,
    degree_C_mul_X_pow 3 ha]
rfl
rw [add_assoc, add_assoc, ← add_assoc (C b * X ^ 2), add_comm,
    leading_coeff_add_of_degree_lt <| degree_quadratic_lt_degree_C_mul_X_cb ha,
    leading_coeff_C_mul_X_pow]
rw [X_pow_eq_monomial, degree_monomial _ (one_ne_zero' R)]
change g * monomial 1 1 = 1 at hgf
rw [← coeff_one_zero, ← hgf]
simp
simp [monic_X.degree_mul]
simp [(monic_X_pow n).degree_mul]
unfold nat_degree <;> rw [hd]
conv => 
        lhs
        rw [← hp, ← hq, hlc, hd', add_sub_add_left_eq_sub, sub_eq_add_neg]
rw [← degree_neg q] at h
rw [sub_eq_add_neg, degree_add_eq_left_of_degree_lt h]
rw [← degree_neg q] at h
rw [sub_eq_add_neg, degree_add_eq_right_of_degree_lt h, degree_neg]
have : degree (c a) < degree (x : R[X]) :=
    calc
      degree (c a) ≤ 0 := degree_C_le
      _ < 1 := WithBot.some_lt_some.mpr zero_lt_one
      _ = degree x := degree_X.symm
rw [degree_add_eq_left_of_degree_lt this, degree_X]
decide
rw [← pow_one (X : S[X]), leading_coeff_X_pow_add_C zero_lt_one]
rw [sub_eq_add_neg, ← map_neg C r, leading_coeff_X_pow_add_C hn] <;> infer_instance
rw [sub_eq_add_neg, ← map_neg C a, degree_X_add_C]
rw [sub_eq_add_neg, ← map_neg C c, next_coeff_X_add_C]
rw [sub_eq_add_neg, ← map_neg C a, degree_X_pow_add_C hn] <;> infer_instance
rw [sub_eq_add_neg, ← map_neg C a]
exact X_pow_add_C_ne_zero hn _
rw [sub_eq_add_neg, ← map_neg C r, nat_degree_X_pow_add_C]
rw [sub_eq_add_neg, ← map_neg C r, leading_coeff_X_add_C]
simp only [hp0, degree_zero, zero_mul, WithBot.bot_add]
simp only [hq0, degree_zero, mul_zero, WithBot.add_bot]
simp
unfold trailing_monic <;> infer_instance
simp [h]
let ⟨n, hn⟩ :=
    not_forall.1 (mt Option.eq_none_iff_forall_not_mem.2 (mt trailing_degree_eq_top.1 hp))
have hn : trailingDegree p = n := not_not.1 hn
rw [nat_trailing_degree, hn] <;> rfl
rw [trailing_degree_eq_nat_trailing_degree hp, WithTop.coe_eq_coe]
unfold nat_trailing_degree <;> rw [h]
rw [← WithTop.coe_le_coe, ← trailing_degree_eq_nat_trailing_degree]
· exact le_trailing_degree_of_ne_zero h
· intro h
    subst h
    exact h rfl
rw [nat_trailing_degree, h, Option.getD_coe]
rw [trailing_degree_eq_nat_trailing_degree hp] at H
exact with_top.coe_le_coe.mp H
rw [trailing_degree, support_monomial n ha, min_singleton]
rw [nat_trailing_degree, trailing_degree_monomial ha] <;> rfl
simp [ha]
simp [ha]
rw [← C_1] <;> exact le_trailing_degree_C
simp only [← C_eq_nat_cast, nat_trailing_degree_C]
rw [C_mul_X_pow_eq_monomial, trailing_degree_monomial ha]
rw [C_mul_X_pow_eq_monomial]
exact le_trailing_degree_monomial
apply coeff_eq_zero_of_trailing_degree_lt
apply le_antisymm
· apply le_min'
    intro y hy
    exact nat_trailing_degree_le_of_mem_supp y hy
· apply Finset.min'_le
    exact mem_support_iff.mpr (trailing_coeff_nonzero_iff_nonzero.mpr h)
rw [nat_trailing_degree_eq_support_min' hp]
exact Finset.le_min' _ _ _ fun m hm => not_lt.1 fun hmn => mem_support_iff.1 hm <| hn _ hmn
rw [hp, zero_mul]
rw [hq, mul_zero]
rw [hp, trailing_coeff_zero, zero_mul]
rw [hq, trailing_coeff_zero, mul_zero]
rw [hp, trailing_coeff_zero, zero_mul]
rw [hq, trailing_coeff_zero, mul_zero]
unfold trailing_degree <;> rw [support_neg]
simp [nat_trailing_degree]
simp only [← C_eq_int_cast, nat_trailing_degree_C]
rw [next_coeff_up]
simp
simp [h₀]
rw [h0, nat_degree_zero] <;> exact Nat.zero_le _
rw [nat_degree_C, WithBot.coe_zero, zero_add, ← WithBot.coe_nsmul, nsmul_eq_mul] <;>
                  simp
have := eq_C_of_degree_le_zero hlt
rw [is_root, this, eval_C] at h
simp only [h, RingHom.map_zero] at this
exact hp this
rw [add_comm]
exact nat_degree_add_le_iff_left _ _ pn
rw [nat_degree_C a]
rw [nat_degree_C a]
rw [← C_1, ← au, RingHom.map_mul, ← mul_assoc]
rw [← C_1, ← au, RingHom.map_mul, ← mul_assoc]
simp only [coeff_nat_degree, coeff_mul_degree_add_degree]
rw [add_comm]
exact coeff_add_eq_left_of_lt pn
simp (config := { contextual := true })
simp [nat_degree_bit0]
have A : p = C (p.coeff 0) := eq_C_of_nat_degree_le_zero hlt
rw [A, eval₂_C] at hz
simp only [inj (p.coeff 0) hz, RingHom.map_zero] at A
exact hp A
rw [← nat_degree_neg, neg_sub]
rw [← nat_degree_neg] at qn
rw [sub_eq_add_neg, nat_degree_add_le_iff_left _ _ qn]
rw [← nat_degree_neg] at dg
rw [sub_eq_add_neg, coeff_add_eq_left_of_lt dg]
rw [degree_mul, degree_C a0, add_zero]
rw [degree_mul, degree_C a0, zero_add]
simp only [nat_degree, degree_mul_C a0]
simp only [nat_degree, degree_C_mul a0]
rw [← coeff_comp_degree_mul_degree hq, ← nat_degree_comp, coeff_nat_degree]
rw [C_mul_X_pow_eq_monomial]
exact h_monomial _ _
simp (config := { singlePass := true }) only [@eq_comm _ _ (C _)]
exact (ideal.span_le.trans range_subset_iff).mpr cf
apply subset_span
simp
rw [trinomial_def, coeff_add, coeff_add, coeff_C_mul_X_pow, coeff_C_mul_X_pow, coeff_C_mul_X_pow,
    if_neg (hkm.trans hmn).ne', if_neg hmn.ne', if_pos rfl, zero_add, zero_add]
rw [trinomial_def, coeff_add, coeff_add, coeff_C_mul_X_pow, coeff_C_mul_X_pow, coeff_C_mul_X_pow,
    if_neg hkm.ne', if_pos rfl, if_neg hmn.ne, zero_add, add_zero]
rw [trinomial_def, coeff_add, coeff_add, coeff_C_mul_X_pow, coeff_C_mul_X_pow, coeff_C_mul_X_pow,
    if_pos rfl, if_neg hkm.ne, if_neg (hkm.trans hmn).Ne, add_zero, add_zero]
rw [leading_coeff, trinomial_nat_degree hkm hmn hw, trinomial_leading_coeff' hkm hmn]
rw [trailing_coeff, trinomial_nat_trailing_degree hkm hmn hu, trinomial_trailing_coeff' hkm hmn]
rw [mirror, trinomial_nat_trailing_degree hkm hmn hu, reverse, trinomial_nat_degree hkm hmn hw,
    trinomial_def, reflect_add, reflect_add, reflect_C_mul_X_pow, reflect_C_mul_X_pow,
    reflect_C_mul_X_pow, rev_at_le (hkm.trans hmn).le, rev_at_le hmn.le, rev_at_le le_rfl, add_mul,
    add_mul, mul_assoc, mul_assoc, mul_assoc, ← pow_add, ← pow_add, ← pow_add,
    Nat.sub_add_cancel (hkm.trans hmn).le, Nat.sub_self, zero_add, add_comm, add_comm (C u * X ^ n),
    ← add_assoc, ← trinomial_def]
rw [trinomial_trailing_coeff' hkm hmn]
rw [trinomial_middle_coeff hkm hmn]
rw [trinomial_leading_coeff' hkm hmn]
rw [is_unit_trinomial_iff', is_unit_trinomial_iff', h]
rw [this] at hp
exact Or.inl (hq.trans hp.symm)
rw [← mul_right_inj' (show 2 ≠ 0 from two_ne_zero), ←
      trinomial_nat_trailing_degree hkm hmn u.ne_zero, ← hp, ← nat_trailing_degree_mul_mirror, hpq,
      nat_trailing_degree_mul_mirror, hq, trinomial_nat_trailing_degree hkm' hmn' x.ne_zero]
rw [← mul_right_inj' (show 2 ≠ 0 from two_ne_zero), ← trinomial_nat_degree hkm hmn w.ne_zero, ←
      hp, ← nat_degree_mul_mirror, hpq, nat_degree_mul_mirror, hq,
      trinomial_nat_degree hkm' hmn' z.ne_zero]
simp only [erase_lead, support_erase]
simp only [erase_lead, coeff_erase]
simp [erase_lead_coeff]
simp [erase_lead_coeff, hi]
simp only [erase_lead, erase_zero]
rw [C_mul_X_pow_eq_monomial, erase_lead_add_monomial_nat_degree_leading_coeff]
rw [C_mul_X_pow_eq_monomial, self_sub_monomial_nat_degree_leading_coeff]
rw [Ne, ← card_support_eq_zero, erase_lead_support]
exact
    (zero_lt_one.trans_le <| (tsub_le_tsub_right f0 1).trans Finset.pred_card_le_card_erase).Ne.symm
rw [erase_lead_support, mem_erase] at h
exact (le_nat_degree_of_mem_supp a h.2).lt_of_ne h.1
rw [erase_lead_support]
exact card_lt_card (erase_ssubset <| nat_degree_mem_support_of_nonzero h)
rw [X_pow_eq_monomial, erase_lead_monomial]
rw [C_mul_X_pow_eq_monomial, erase_lead_monomial]
simp [fu0]
simp
rw [this, univ.card_image_of_injective hk, card_fin]
rw [Fin.range_cast_succ, Set.mem_def]
exact lt_of_lt_of_le hij (nat.lt_succ_iff.mp j.2)
constructor
cases a <;> rfl
cases a <;> rfl
cases a <;> rfl
cases a <;> rfl
cases a <;> trivial
cases a <;> constructor
cases x <;> rfl
cases a <;> rfl
cases x <;> cases y <;> simp
simp [sign_apply]
refine' ⟨fun h => _, fun h => sign_pos h⟩
change signHom (x ^ n) = signHom x ^ n
exact map_pow _ _ _
simp [ht]
simp [hβ, h]
simp [hf _ ha]
cases b <;> rfl
cases b <;> rfl
rw [← bit_one] <;> exact s b (Snum.zero (not b)) (z (not b))
dsimp [(· < ·)] <;> infer_instance
dsimp [(· ≤ ·)] <;> infer_instance
dsimp [(· < ·)] <;> infer_instance
dsimp [(· ≤ ·)] <;> infer_instance
dsimp [(· < ·)] <;> infer_instance
dsimp [(· ≤ ·)] <;> infer_instance
decide
refine' nat.prime_def_min_fac.trans ((and_iff_right _).trans <| eq_comm.trans _)
· exact bit0_le_bit0.2 (to_nat_pos _)
rw [← min_fac_to_nat, to_nat_inj]
exact ⟨bit0.inj, congr_arg _⟩
refine' nat.prime_def_min_fac.trans ((and_iff_right _).trans _)
· exact Nat.bit0_le_bit1_iff.2 (to_nat_pos _)
rw [← min_fac_to_nat, to_nat_inj]
rfl
rw [← to_nat_to_int, Int.cast_ofNat, cast_to_nat]
simp [add_left_comm]
cases n <;> rfl
cases n <;> rfl
rw [one_add b, succ_to_nat, add_comm] <;> rfl
rw [add_one a, succ_to_nat] <;> rfl
simp [add_left_comm]
simp [add_comm, add_left_comm]
rw [succ_to_nat, add_to_nat] <;> simp [add_left_comm]
simp [one_add]
rw [bit0_of_bit0] <;> rfl
rw [add_one, bit0_of_bit0] <;> rfl
rw [mul_to_nat, left_distrib]
rw [mul_to_nat, left_distrib]
intro h <;> rw [Nat.add_right_comm m m 1, add_assoc] <;> exact add_le_add h h
have := cmp_to_nat a b
revert this
cases cmp a b <;> dsimp <;> intro
· exact add_lt_add this this
· rw [this]
· exact add_lt_add this this
dsimp [cmp]
have := cmp_to_nat a b
revert this
cases cmp a b <;> dsimp <;> intro
· exact Nat.le_succ_of_le (add_lt_add this this)
· rw [this]
      apply Nat.lt_succ_self
· exact cmp_to_nat_lemma this
dsimp [cmp]
have := cmp_to_nat a b
revert this
cases cmp a b <;> dsimp <;> intro
· exact cmp_to_nat_lemma this
· rw [this]
      apply Nat.lt_succ_self
· exact Nat.le_succ_of_le (add_lt_add this this)
have := cmp_to_nat a b
revert this
cases cmp a b <;> dsimp <;> intro
· exact Nat.succ_lt_succ (add_lt_add this this)
· rw [this]
· exact Nat.succ_lt_succ (add_lt_add this this)
simp at h <;> simp [h]
decide
decide
rw [← not_lt] <;> exact not_congr lt_to_nat
cases n <;> rfl
cases n <;> rfl
cases p <;> rfl
simp [zero_add]
rw [PosNum.add_one, add_zero] <;> rfl
simp [Num.ofNat']
erw [of_nat'_bit tt 0, cond, of_nat'_zero] <;> rfl
simp <;> rfl
induction n <;> simp [Nat.add_zero, of_nat'_succ, add_zero, Nat.add_succ, add_one, add_succ, *]
simp at h <;> simp [h]
decide
decide
rw [← not_lt] <;> exact not_congr lt_to_nat
erw [@Num.of_nat'_bit tt 0, Num.of_nat'_zero] <;> rfl
erw [@Num.of_nat'_bit ff, of_to_nat'] <;> rfl
erw [@Num.of_nat'_bit tt, of_to_nat'] <;> rfl
decide
decide
rw [← to_nat_to_int, Int.cast_ofNat, cast_to_nat]
rw [Nat.cast_zero, cast_zero]
rw [Nat.cast_succ, add_one, succ_to_nat, to_of_nat]
rw [← cast_to_nat, to_of_nat]
rw [← of_to_nat n, e] <;> simp
simp [e, mul_to_nat]
rw [← PosNum.of_to_nat, ← PosNum.of_to_nat, h]
rw [pred'_to_nat n, Nat.succ_pred_eq_of_pos (to_nat_pos n)]
rw [← to_nat_inj.1 h] <;> rfl
rw [← h] <;> exact (Nat.succ_add p p).symm
rw [pred'_to_nat, succ'_to_nat, Nat.add_one, Nat.pred_succ]
rw [succ'_to_nat, pred'_to_nat, Nat.add_one, Nat.succ_pred_eq_of_pos (to_nat_pos _)]
rw [size, succ_to_nat, size_to_nat, cast_bit0, Nat.size_bit0 <| ne_of_gt <| to_nat_pos n]
rw [size, succ_to_nat, size_to_nat, cast_bit1, Nat.size_bit1]
rw [size, succ_to_nat, nat_size, size_eq_nat_size]
rw [size, succ_to_nat, nat_size, size_eq_nat_size]
rw [← size_eq_nat_size, size_to_nat]
cases n <;> apply Nat.succ_pos
infer_instance
infer_instance
infer_instance
rw [← cast_to_nat, ← of_to_nat n]
cases b <;> rfl
rw [← cast_to_nat, add_to_nat, Nat.cast_add, cast_to_nat, cast_to_nat]
rw [← add_one, cast_add, cast_one]
rw [← cast_to_nat m, ← cast_to_nat n, Nat.cast_inj, to_nat_inj]
rw [← cast_to_nat, ← Nat.cast_one, Nat.cast_le] <;> apply to_nat_pos
rw [← cast_to_nat, mul_to_nat, Nat.cast_mul, cast_to_nat, cast_to_nat]
rw [e] at this <;> exact lt_irrefl _ this
rw [← cast_to_nat m, ← cast_to_nat n, Nat.cast_lt, lt_to_nat]
rw [← not_lt] <;> exact not_congr cast_lt
cases b <;> cases n <;> rfl
rw [← PosNum.cast_to_nat, succ'_to_nat, Nat.cast_add_one, cast_to_nat]
rw [← cast_to_nat, add_to_nat, Nat.cast_add, cast_to_nat, cast_to_nat]
rw [← bit0_of_bit0, _root_.bit0, cast_add] <;> rfl
rw [← bit1_of_bit1, _root_.bit1, bit0_of_bit0, cast_add, cast_bit0] <;> rfl
rw [← size_eq_nat_size, size_to_nat]
simp
rw [of_nat'] at IH⊢
rw [Nat.binary_rec_eq, IH]
· cases b <;> simp [Nat.bit, bit0_of_bit0, bit1_of_bit1]
· rfl
cases n <;> rfl
cases n <;> rfl
cases m <;> cases n <;> cases h <;> rfl
cases m <;> cases n <;> rfl
decide
cases a <;> rfl
cases a <;> rfl
decide
rw [pred, PosNum.pred'_to_nat] <;> rfl
rw [ppred, Option.map_some, Nat.ppred_eq_some.2] <;>
        rw [PosNum.pred'_to_nat, Nat.succ_pred_eq_of_pos (PosNum.to_nat_pos _)] <;>
      rfl
cases m <;> cases n <;> try unfold cmp <;> try rfl <;> apply PosNum.cmp_swap
rw [e] at this <;> exact lt_irrefl _ this
rw [← cast_to_nat m, ← cast_to_nat n, Nat.cast_lt, lt_to_nat]
rw [← not_lt] <;> exact not_congr cast_lt
rw [← cast_to_nat m, ← cast_to_nat n, Nat.cast_inj, to_nat_inj]
decide
intros <;> cases b <;> rfl
intros <;> cases b <;> rfl
apply bitwise_to_nat fun x y => Pos (PosNum.lor x y) <;> intros <;> try cases a <;>
      try cases b <;>
    rfl
apply bitwise_to_nat PosNum.land <;> intros <;> try cases a <;> try cases b <;> rfl
apply bitwise_to_nat PosNum.ldiff <;> intros <;> try cases a <;> try cases b <;> rfl
apply bitwise_to_nat PosNum.lxor <;> intros <;> try cases a <;> try cases b <;> rfl
decide
cases n <;> rfl
cases n <;> rfl
cases n <;> rfl
cases n <;> try rfl <;> rw [succ, Num.zneg_to_znum_neg] <;> rfl
rw [← zneg_zneg (succ (-n)), zneg_succ, zneg_zneg]
rw [p.to_nat_to_int, Int.natAbs_neg]
rw [cast_zero, cast_zero, Int.cast_zero]
rw [cast_pos, cast_pos, PosNum.cast_to_int]
rw [cast_neg, cast_neg, Int.cast_neg, PosNum.cast_to_int]
rw [PosNum.one_sub', a.bit0_of_bit0] <;> rfl
rw [ZNum.bit0, cast_pos, cast_pos] <;> rfl
rw [ZNum.bit0, cast_neg, cast_neg, PosNum.cast_bit0, _root_.bit0, _root_.bit0, neg_add_rev]
simp [ZNum.bit1, _root_.bit1, _root_.bit0]
rw [ZNum.bit1, cast_pos, cast_pos] <;> rfl
simp [add_comm]
simp [add_comm, add_left_comm]
cases n <;> rfl
cases n <;> rfl
cases p <;> rfl
rw [sub'_one, Num.cast_to_znum, ← Num.cast_to_nat, pred'_to_nat, ← Nat.sub_one] <;>
      simp [PosNum.cast_pos]
rw [one_sub', Num.cast_to_znum_neg, ← neg_sub, neg_inj, ← Num.cast_to_nat, pred'_to_nat, ←
        Nat.sub_one] <;>
      simp [PosNum.cast_pos]
simp [add_left_comm]
simp [add_comm, add_left_comm]
simp [add_comm, add_left_comm]
simp [add_left_comm]
rw [← Num.succ'_to_nat, n.succ'_pred']
rw [← n.to_nat_to_int, to_nat_eq_succ_pred] <;> rfl
rw [PosNum.pred'_succ'] <;> rfl
rw [ZNum.pred, ← to_znum_succ, Num.succ, PosNum.succ'_pred', to_znum]
erw [ZNum.ofInt', ZNum.ofInt', Num.of_nat'_succ, Num.add_one, to_znum_succ, ZNum.add_one]
erw [ZNum.ofInt', ZNum.ofInt', of_nat'_succ, of_nat'_zero] <;> rfl
erw [ZNum.ofInt', ZNum.ofInt', @Num.of_nat'_succ (n + 1), Num.add_one, to_znum_neg_succ,
      @of_nat'_succ n, Num.add_one, ZNum.add_one, pred_succ]
rw [Nat.cast_succ, Num.add_one, to_znum_succ, of_int'_to_znum, Nat.cast_succ, succ_of_int',
      ZNum.add_one]
cases h
cases m <;> constructor <;> intro h <;> try cases h <;> rfl
cases m <;> cases h
rw [← PosNum.to_nat_to_int p] <;> rfl
rw [← succ'_to_nat] <;> simp
rw [← PosNum.to_nat_to_int p] <;> rfl
rw [← succ'_to_nat] <;> simp
rw [← cast_to_nat, of_znum_to_nat]
rw [of_znum_to_nat, cast_sub', ← to_nat_to_int, ← to_nat_to_int, Int.toNat_sub]
cases a <;> exact (_root_.zero_add _).symm
cases b <;> exact (_root_.add_zero _).symm
rw [← PosNum.cast_to_int a, ← PosNum.cast_to_int b, ← Int.cast_neg, ← Int.cast_add (-a)] <;>
        simp [add_comm]
rw [PosNum.cast_add, neg_eq_iff_neg_eq, neg_add_rev, neg_neg, neg_neg, ← PosNum.cast_to_int a,
          ← PosNum.cast_to_int b, ← Int.cast_add] <;>
        simp [add_comm]
rw [← add_one, cast_add, cast_one]
cases a <;> exact (_root_.zero_mul _).symm
cases b <;> exact (_root_.mul_zero _).symm
rw [PosNum.cast_mul, neg_mul_eq_mul_neg]
rw [PosNum.cast_mul, neg_mul_eq_neg_mul]
rw [PosNum.cast_mul, neg_mul_neg]
rw [← cast_to_int, mul_to_int, Int.cast_mul, cast_to_int, cast_to_int]
simp only [of_int', Num.zneg_to_znum_neg]
rw [Num.of_nat'_zero] <;> rfl
rw [Num.zneg_to_znum] <;> rfl
erw [of_int', Num.of_nat'_zero, Num.toZNum]
rw [cast_pos, ← PosNum.cast_to_nat, ← Num.of_int'_to_znum, PosNum.of_to_nat] <;> rfl
rw [cast_neg, of_int'_neg, ← PosNum.cast_to_nat, ← Num.of_int'_to_znum, PosNum.of_to_nat] <;>
      rfl
simp at h <;> simp [h]
decide
decide
rw [← not_lt] <;> exact not_congr lt_to_int
rw [← cast_to_int m, ← cast_to_int n, Int.cast_lt, lt_to_int]
rw [← not_lt] <;> exact not_congr cast_lt
rw [← cast_to_int m, ← cast_to_int n, Int.cast_inj, to_int_inj]
rw [Num.of_nat'_zero] <;> rfl
rw [Num.of_nat'_succ, Num.add_one, Num.to_znum_succ, ZNum.add_one]
decide
decide
simp [sub_eq_neg_add]
rw [Int.cast_neg, Int.cast_zero]
show Num.toZNumNeg (n + 1 : ℕ) = -(n + 1 : ℕ)
rw [← neg_inj, neg_neg, Nat.cast_succ, Num.add_one, Num.zneg_to_znum_neg, Num.to_znum_succ,
      Nat.cast_succ, ZNum.add_one]
rfl
rw [← of_int'_eq, of_to_int']
simp
simp
simp
rw [← of_nat_to_znum, Num.zneg_to_znum]
rw [← cast_to_int, to_of_int]
rw [← Int.cast_ofNat, of_int_cast, Int.cast_ofNat]
rw [← of_to_int n, e] <;> simp
simp [e]
intro r₂
apply num.mem_of_znum'.trans
rw [← ZNum.to_int_inj, Num.cast_to_znum, Num.cast_sub', sub_eq_iff_eq_add, ← Int.coe_nat_inj']
simp
simp <;> rfl
cases n
rfl
simp [Num.div]
simp
cases n
rfl
simp [Num.mod]
simp
intros
simp [nat_size_to_nat]
rw [Nat.size_le, pow_add]
exact mul_lt_mul'' (Nat.lt_size_self _) (Nat.lt_size_self _) (Nat.zero_le _) (Nat.zero_le _)
rw [← dvd_to_nat, Nat.dvd_iff_mod_eq_zero, ← to_nat_inj, mod_to_nat] <;> rfl
cases n <;> first |rfl|simp [ZNum.div]
simp [Int.div_zero]
rw [← Num.to_nat_to_int] <;> simp
rw [← Num.to_nat_to_int] <;> simp
rw [n.to_int_eq_succ_pred, d.to_int_eq_succ_pred, ← PosNum.to_nat_to_int, Num.succ'_to_nat,
        Num.div_to_nat]
change -[n.pred' / ↑d+1] = -[n.pred' / (d.pred' + 1)+1]
rw [d.to_nat_eq_succ_pred]
rw [n.to_int_eq_succ_pred, d.to_int_eq_succ_pred, ← PosNum.to_nat_to_int, Num.succ'_to_nat,
        Num.div_to_nat]
change (Nat.succ (_ / d) : ℤ) = Nat.succ (n.pred' / (d.pred' + 1))
rw [d.to_nat_eq_succ_pred]
rw [← Num.to_nat_to_int, cast_pos, Num.mod_to_nat, ← PosNum.to_nat_to_int, abs_to_nat] <;> rfl
rw [← Num.to_nat_to_int, cast_neg, ← Num.to_nat_to_int, Num.succ_to_nat, Num.mod_to_nat,
          abs_to_nat, ← Int.subNatNat_eq_coe, n.to_int_eq_succ_pred] <;>
        rfl
rw [← dvd_to_int, Int.dvd_iff_emod_eq_zero, ← to_int_inj, mod_to_int] <;> rfl
cases nonempty_fintype α
infer_instance
subst h
apply Finite.equivFin
simp [map_bind, bind_bind a₀ a₁, cons_swap]
simp
rw [← cons_coe, sections_cons, bind_map_comm, coe_sections l]
simp [List.sections, (· ∘ ·), List.bind]
simp
simp [ih, bind_assoc, map_bind, bind_map, -add_comm]
simp
simp [ih, rel_cons_left, -exists_and_left, exists_and_distrib_left.symm, eq_comm]
simp
simp (config := { contextual := true })
simp
simp [ih, map_bind, sum_map_mul_left, sum_map_mul_right]
rw [add_tsub_cancel_left x₁ x₂]
simp [powerset_aux']
simp [powerset_aux']
simp only [revzip, reverse_append, quot_mk_to_coe, coe_eq_coe, powerset_aux'_cons, cons_coe,
      coe_map, antidiagonal_coe', coe_add]
rw [← zip_map, ← zip_map, zip_append, (_ : _ ++ _ = _)]
· congr <;> simp; · simp
cases x
cases y
rfl
intro p
simp only [Multiset.mem_to_enum_finset]
exact gt_of_ge_of_gt (multiset.le_iff_count.mp h p.1)
refine' ⟨fun h => _, Multiset.to_enum_finset_mono⟩
rw [Multiset.le_iff_count]
intro x
rw [Multiset.mem_to_enum_finset]
exact Nat.pred_lt (ne_of_gt (multiset.count_pos.mpr hx))
rw [Multiset.mem_to_enum_finset]
exact x.2.2
rw [← Multiset.mem_to_enum_finset]
exact x.2
rw [Finset.image, Multiset.map_to_enum_finset_fst]
rw [← Multiset.map_map, Multiset.map_univ_coe]
rw [Fintype.card_congr m.coe_equiv]
simp
congr
simp
congr
simp
rw [Fintype.prod_equiv m.coe_equiv (fun x => f x x.2) fun x => f x.1.1 x.1.2]
· rw [← m.to_enum_finset.prod_coe_sort fun x => f x.1 x.2]
    simp
· simp
rw [antidiagonal, mem_coe, List.Nat.mem_antidiagonal]
rw [antidiagonal, coe_card, List.Nat.length_antidiagonal]
simp only [antidiagonal, List.Nat.antidiagonal_succ, coe_map, cons_coe]
rw [antidiagonal, List.Nat.antidiagonal_succ', ← coe_add, add_comm, antidiagonal, coe_map,
    coe_add, List.singleton_append, cons_coe]
rw [antidiagonal_succ, antidiagonal_succ', map_cons, map_map, Prod_map]
rfl
rw [antidiagonal, coe_map, List.Nat.map_swap_antidiagonal, coe_reverse]
simp [powerset_aux, sublists] <;>
      rw [←
        show (@sublists_aux₁ α (Multiset α) l fun x => [↑x]) = sublists_aux l fun x => List.cons ↑x
          from sublists_aux₁_eq_sublists_aux _ _,
        sublists_aux_cons_eq_sublists_aux₁, ← bind_ret_eq_map, sublists_aux₁_bind] <;>
    rfl
simp [powerset_aux_eq_map_coe, subperm, and_comm]
rw [powerset_aux_eq_map_coe] <;> exact (sublists_perm_sublists' _).map _
simp [powerset_aux'] <;> rfl
funext s <;> simp [cons_swap]
simp <;> rfl
simp [subperm, and_comm]
simp
rw [powerset_len_aux, sublists_len_aux_eq, append_nil]
simp [powerset_len_aux_eq_map_coe, subperm] <;>
      exact fun l₁ =>
        ⟨fun ⟨l₂, ⟨s, e⟩, p⟩ => ⟨⟨_, p, s⟩, p.symm.length_eq.trans e⟩, fun ⟨⟨l₂, p, s⟩, e⟩ =>
          ⟨_, ⟨s, p.length_eq.trans e⟩, p⟩⟩
simp [powerset_len_aux_eq_map_coe]
simp [powerset_len_aux_eq_map_coe] <;> rfl
funext s <;> simp [cons_swap]
simp [powerset_len_coe'] <;> rfl
simp [powerset_len_coe'] <;> rfl
simp [powerset_len_coe']
simp [powerset_len_coe]
simp [powerset_len_coe] <;> exact ((sublists_len_sublist_sublists' _ _).map _).Subperm
simp [powerset_len_coe] <;> exact ((sublists_len_sublist_of_sublist _ h).map _).Subperm
simp <;> refine' (nodup_sublists'.2 h).map_on _ <;>
        exact fun x sx y sy e =>
          (h.sublist_ext (mem_sublists'.1 sx) (mem_sublists'.1 sy)).1 (Quotient.exact e)
rw [cons_swap]
intro a a' m n
rw [pi.cons_ne this Ne.symm]
rw [Eq]
rw [pi.cons_ne this Ne.symm]
simp
simp (config := { contextual := true }) [mul_comm]
simp at hs <;> exact hs.1
rw [Eq]
funext a ha <;> exact ha.elim
  simp_rw [pi_cons, mem_bind, mem_map, ih]
  constructor
  · rintro ⟨b, hb, f', hf', rfl⟩ a' ha'
simp
rw [card_Ico_eq_card_Icc_sub_one, card_Icc]
rw [card_Ioc_eq_card_Icc_sub_one, card_Icc]
rw [card_Ioo_eq_card_Icc_sub_two, card_Icc]
rw [range, range_succ, ← coe_add, add_comm] <;> rfl
rw [range_add, add_eq_union_iff_disjoint]
apply range_disjoint_map_add
rw [eq_nil_iff_forall_not_mem.mpr H] <;> rfl
simp
simp [Eq, hcs]
simp only [← cons_zero, mem_cons, iff_self_iff, or_false_iff, not_mem_zero]
rw [← cons_zero]
exact mem_cons_self _ _
rw [← cons_zero, cons_eq_cons]
simp [eq_comm]
simp [subset_iff, or_imp, forall_and]
rw [← coe_eq_zero, coe_to_list]
rw [← mem_coe, coe_to_list]
exact fun h => (cons_le_cons_iff a).1 (this h (mem_cons_self _ _))
rw [← singleton_add, ← singleton_add, add_assoc]
rw [add_comm, cons_add, add_comm]
rw [← singleton_add, nsmul_add]
rw [← coe_card, coe_to_list]
rw [card.map_nsmul s n, Nat.nsmul_eq_mul]
simp only [← cons_zero, card_zero, eq_self_iff_true, zero_add, card_cons]
rw [insert_eq_cons, card_cons, card_singleton]
simp [e]
rw [strong_induction_on]
rw [strong_downward_induction]
dsimp only [strong_downward_induction_on]
rw [strong_downward_induction]
simp only [repeat_succ, ← cons_zero, eq_self_iff_true, repeat_zero, cons_inj_right]
rw [← (eq_repeat.1 h).1, card_repeat]
refine' eq_repeat.mpr ⟨_, fun b hb => mem_singleton.mp (mem_of_mem_nsmul hb)⟩
rw [card_nsmul, card_singleton, mul_one]
rw [← repeat_le_coe, coe_repeat]
rw [erase_of_not_mem h] <;> apply le_cons_self
rw [add_comm, erase_add_left_pos s h, add_comm]
rw [add_comm, erase_add_right_neg s h, add_comm]
rw [← cons_erase m] at h <;> exact (cons_le_cons_iff _).1 h
subst h
simp at hf
simp [map_congr rfl hf]
rw [← Multiset.card_eq_zero, Multiset.card_map, Multiset.card_eq_zero]
rw [← card_eq_one, ← card_map, h, card_singleton]
rw [h]
exact mem_cons_self _ _
refine' (map_le_map h.le).lt_of_not_le fun H => h.ne <| eq_of_le_of_card_le h.le _
rw [← s.card_map f, ← t.card_map f]
exact card_le_of_le H
simp [px]
rw [foldl_swap]
exact foldr_induction' (fun x y => f y x) (fun x y z => (H _ _ _).symm) x q p s hpqf px q_s
intro s₂ e _ <;> subst e
      this.trans
rw [List.map_pmap] <;> exact List.pmap_congr _ fun _ _ _ _ => Subtype.eq rfl
simp
simp [Function.funext_iff]
simp
simp [Multiset.sub_zero]
simp [IH, erase_le_iff_le_cons]
rw [← singleton_add, ← singleton_add, add_tsub_assoc_of_le h]
rw [add_comm, ← card_add, tsub_add_cancel_of_le h]
rw [← eq_union_left h₂] <;> exact union_le_union_right h₁ t
rw [List.map_append f, List.map_diff finj]
simp [h, IH]
revert s u
refine' Multiset.induction_on t _ fun a t IH => _ <;> intros
· simp [h₁]
rw [← cons_erase h₁, cons_inter_of_pos _ h₂] <;> apply mem_cons_self
rw [union_comm, eq_union_left h]
rw [add_comm t, tsub_add_eq_tsub_tsub, add_tsub_cancel_right]
rw [add_comm, union_add_distrib, add_comm s, add_comm s]
rw [add_comm, inter_add_distrib, add_comm s, add_comm s]
simp
apply le_antisymm
· rw [union_add_distrib]
    refine' union_le (add_le_add_left (inter_le_right _ _) _) _
    rw [add_comm]
    exact add_le_add_right (inter_le_left _ _) _
· rw [add_comm, add_inter_distrib]
    refine' le_inter (add_le_add_right (le_union_right _ _) _) _
    rw [add_comm]
    exact add_le_add_right (le_union_left _ _) _
simp
rw [sub_add_inter s t, tsub_add_cancel_of_le (inter_le_left s t)]
simp only [singleton, filter_cons, filter_zero, add_zero, empty_eq_zero]
simp
rw [filter_cons_of_neg _ h]
rw [filter_add_filter, filter_eq_self.2, filter_eq_nil.2] <;> simp [Decidable.em]
simp [map_filter]
simp [List.countp_cons]
simp [countp_eq_card_filter]
induction n <;> simp [*, succ_nsmul', succ_mul, zero_nsmul]
simp [l.length_eq_countp_add_countp p]
simp [countp_eq_card_filter, h, filter_le_filter]
simp [countp_eq_card_filter]
refine' Multiset.induction_on s _ fun a t IH => _
· rw [map_zero, countp_zero, filter_zero, card_zero]
·
    rw [map_cons, countp_cons, IH, filter_cons, card_add, apply_ite card, card_zero, card_singleton,
      add_comm]
simp only [quot_mk_to_coe'', coe_eq_coe] at hs
exact hs.countp_congr hp
simp only [count_cons, ← cons_zero, count_zero, zero_add]
induction n <;> simp [*, succ_nsmul', succ_mul, zero_nsmul]
simp [count, countp_pos]
rw [succ_le_iff, count_pos]
simp [Ne.def, count_eq_zero]
rw [cons_erase h]
simp
apply @Nat.add_left_cancel (count a (s - t))
rw [← count_add, sub_add_inter, count_sub, tsub_add_min]
simp [max_eq_right (al a)]
simp only [max_min_distrib_left, Multiset.count_inter, Multiset.sup_eq_union,
              Multiset.count_union, Multiset.inf_eq_inter]
rw [count, countp_map, ← this]
exact count_filter_of_pos rfl
rw [inter_comm, repeat_inter, min_comm]
rw [count, countp_eq_card_filter]
simp only [count_eq_card_filter_eq, map_filter, card_map, Function.comp.left_id, eq_true_eq_id]
apply m.induction_on
· intros
    apply rel.zero
· intro a m ih h
    exact rel.cons (h _ (mem_cons_self _ _)) (ih fun _ ha => h _ (mem_cons_of_mem ha))
constructor
· intro h
    induction h <;> simp [*]
· intro h
    subst h
    exact rel_eq_refl
induction hst
case zero => exact rel.zero
case cons a b s t hab hst ih =>
    apply rel.cons (h a (mem_cons_self _ _) b (mem_cons_self _ _) hab)
    exact ih fun a' ha' b' hb' h' => h a' (mem_cons_of_mem ha') b' (mem_cons_of_mem hb') h'
rw [rel_flip, rel_eq, eq_comm]
rw [rel_iff] <;> simp
rw [rel_iff] <;> simp
rw [← rel_flip, rel_cons_left]
refine' exists₂_congr fun a as' => _
rw [rel_flip, flip]
simp
simp
simp
rw [← rel_flip, rel_add_left] <;> simp [rel_flip]
simp
simp (config := { contextual := true }) [rel_cons_left]
rw [← rel_flip, rel_map_left, ← rel_flip] <;> rfl
induction h <;> simp [*]
rw [← rel_flip]
exact rel_repeat_left
rw [← rel_eq, ← rel_eq, rel_map]
simp only [hf.eq_iff]
simp [ih, Quot.sound hab]
simp [disjoint_left, imp_not_comm]
simp [Disjoint] <;> rfl
rw [disjoint_comm, singleton_disjoint]
simp [Disjoint, or_imp, forall_and]
rw [singleton_disjoint]
rw [← subset_zero] <;> simp [subset_iff, Disjoint]
simp [Disjoint, or_imp, forall_and]
simp [Disjoint, or_imp, forall_and]
simp [Disjoint, @eq_comm _ (f _) (g _)]
rfl
simp
refine' { .. } <;> intros <;> simp
rw [p_ih]
simp
simp [pure]
intro
simp [traverse]
rfl
intro <;> simp [traverse, comp_traverse, functor_norm] <;>
        simp [(· <$> ·), (· ∘ ·), functor_norm]
intro <;> simp [traverse, functor_norm] <;> rw [IsLawfulFunctor.comp_map, map_traverse]
intro <;> simp [traverse, IsLawfulTraversable.naturality, functor_norm]
simp [hc.comm]
simp [hc.comm]
rw [fold_eq_foldl, foldl_cons, ← fold_eq_foldl]
rw [fold_cons'_right, hc.comm]
rw [add_zero, fold_zero, ← fold_cons'_right, ← fold_cons_right op]
simp
simp
simp (config := { contextual := true }) [hm]
rw [← fold_add op, union_add_inter, fold_add op]
simp
rw [count_nsmul]
simp
simp (config := { contextual := true }) [or_and_right, exists_or]
simp
simp
rw [List.bind, ← coe_join, List.map_map] <;> rfl
simp [bind]
simp [bind]
simp [bind]
simp [bind, join, nsmul_zero]
simp [bind, join]
simp
simp (config := { contextual := true }) [add_comm, add_left_comm]
rw [zero_bind, map_zero]
simp [singleton_add]
simp [bind] <;> simp [-exists_and_right, exists_and_distrib_right.symm] <;> rw [exists_swap] <;>
    simp [and_assoc']
simp [bind]
simp (config := { contextual := true }) [bind]
subst h
simp at hf
simp [bind_congr hf]
simp
simp (config := { contextual := true })
simp
simp (config := { contextual := true })
simp
simp (config := { contextual := true })
simp
simp (config := { contextual := true })
simp
simp (config := { contextual := true })
simp
simp [ih, cons_bind]
apply rel_join
rw [rel_map]
exact hst.mono fun a ha b hb hr => h hr
simp
simp
rw [product, List.product, ← coe_bind]
simp
simp [product]
simp [product]
simp [product]
simp only [product, bind_singleton, map_singleton]
simp [product]
simp [product, and_left_comm]
rw [Multiset.sigma, List.sigma, ← coe_bind] <;> simp
simp [Multiset.sigma]
simp [Multiset.sigma]
simp [Multiset.sigma, and_assoc', and_left_comm]
simp [Multiset.sigma, (· ∘ ·)]
simp [sup]
simp
simp (config := { contextual := true }) [or_imp, forall_and]
rw [← sup_dedup, dedup_ext.2, sup_dedup, sup_add] <;> simp
rw [← sup_dedup, dedup_ext.2, sup_dedup, sup_add] <;> simp
rw [← sup_dedup, dedup_ext.2, sup_dedup, sup_cons] <;> simp
apply m.induction_on
· simp
· intro a s h
    simp [h]
simp [inf]
simp
simp (config := { contextual := true }) [or_imp, forall_and]
rw [← inf_dedup, dedup_ext.2, inf_dedup, inf_add] <;> simp
rw [← inf_dedup, dedup_ext.2, inf_dedup, inf_add] <;> simp
rw [← inf_dedup, dedup_ext.2, inf_dedup, inf_cons] <;> simp
simp [h]
simp [h]
simp [h, l]
rw [ndinsert_of_not_mem h, ← cons_erase m, cons_le_cons_iff, ← le_cons_of_not_mem h,
          cons_erase m] <;>
        exact l
intro t ht
simp [Disjoint]
simp
simp (config := { contextual := true }) [ndinsert_le, and_comm', and_left_comm]
simp [ndinter, h]
simp [ndinter, h]
simp [ndinter, le_filter, subset_iff]
rw [← subset_zero] <;> simp [subset_iff, Disjoint]
rw [← mem_coe, sort_eq]
rw [disj_sum, card_add, card_map, card_map]
rw [le_dedup, and_iff_right le_rfl]
simp [nodup.ext]
simp [dedup_ext]
simp [le_dedup, hno]
rw [Icc, Finset.val_eq_zero, Finset.Icc_eq_empty_iff]
rw [Ico, Finset.val_eq_zero, Finset.Ico_eq_empty_iff]
rw [Ioc, Finset.val_eq_zero, Finset.Ioc_eq_empty_iff]
rw [Ioo, Finset.val_eq_zero, Finset.Ioo_eq_empty_iff]
rw [Ico, Finset.Ico_self, Finset.empty_val]
rw [Ioc, Finset.Ioc_self, Finset.empty_val]
rw [Ioo, Finset.Ioo_self, Finset.empty_val]
rw [Ico, ← Finset.filter_val, Finset.Ico_filter_lt_of_le_left hca]
rfl
rw [Ico, ← Finset.filter_val, Finset.Ico_filter_lt_of_right_le hbc]
rw [Ico, ← Finset.filter_val, Finset.Ico_filter_lt_of_le_right hcb]
rfl
rw [Ico, ← Finset.filter_val, Finset.Ico_filter_le_of_le_left hca]
rw [Ico, ← Finset.filter_val, Finset.Ico_filter_le_of_right_le]
rfl
rw [Ico, ← Finset.filter_val, Finset.Ico_filter_le_of_left_le hac]
rfl
rw [Icc, Finset.Icc_self, Finset.singleton_val]
rw [mem_Ico] at hab hbc
exact hab.2.not_le (h.trans hbc.1)
rw [Ico, ← Finset.filter_val, Finset.Ico_filter_le_left hab]
rfl
rw [add_eq_union_iff_disjoint.2 (Ico_disjoint_Ico le_rfl), Ico, Ico, Ico, ← Finset.union_val,
    Finset.Ico_union_Ico_eq_Ico hab hbc]
rw [Ico, Ico, Ico, ← Finset.inter_val, Finset.Ico_inter_Ico]
rw [Ico, Ico, ← Finset.filter_val, Finset.Ico_filter_lt]
rw [Ico, Ico, ← Finset.filter_val, Finset.Ico_filter_le]
rw [Ico, Ico, Ico, ← Finset.sdiff_val, Finset.Ico_diff_Ico_left]
rw [Ico, Ico, Ico, ← Finset.sdiff_val, Finset.Ico_diff_Ico_right]
simp [nodup_add, d₁, d₂]
rw [d.erase_eq_filter b, mem_filter, and_comm']
simp [d₁.product d₂]
rw [count_union] <;>
        exact max_le (nodup_iff_count_le_one.1 h₁ a) (nodup_iff_count_le_one.1 h₂ a)
simp [this, List.nodup_bind, pairwise_coe_iff_pairwise hd]
refine' count_eq_zero.1 _ h <;> rw [count_sub a s t, tsub_eq_zero_iff_le] <;>
        exact le_trans (nodup_iff_count_le_one.1 d _) (count_pos.2 h')
simp only [mem_map, true_and_iff, Subtype.exists, eq_comm, mem_attach] <;>
        exact ⟨i_surj _, fun ⟨y, hy⟩ => hy.snd.symm ▸ hi _ _⟩
rw [pmap_eq_map]
rw [pmap_eq_map_attach]
rw [this, Multiset.map_map] <;> exact map_congr rfl fun x _ => h _ _
simp [eq_top_iff, Setoid.le_def, Setoid.top_def, Pi.top_apply]
rw [eqv_gen_eq]
apply congr_arg Inf
simp only [le_def, or_imp, ← forall_and]
rw [sup_eq_eqv_gen] <;> rfl
rw [Sup_eq_eqv_gen, Sup_image]
congr
rw [eqv_gen_eq] <;> exact Inf_le fun _ _ => id
rw [eqv_gen_eq] <;> exact Inf_le h
simp [ker_def, Quotient.sound h]
rw [Quotient.lift_mk] <;> exact Subtype.ext_iff_val.2 hz
rw [← eqv_gen_of_setoid (map_of_surjective r f h hf)] <;> rfl
rw [Quotient.eq] <;> rfl
rw [comap_rel, eq_rel.2 h]
rw [comap_rel, (@eq_rel _ r x y).2 (ker_mk_eq r ▸ h)]
simp only [subsingleton_iff, eq_top_iff, Setoid.le_def, Setoid.top_def, Pi.top_apply,
    forall_const]
refine' (surjective_quotient_mk _).forall.trans (forall_congr' fun a => _)
refine' (surjective_quotient_mk _).forall.trans (forall_congr' fun b => _)
exact Quotient.eq'
simp only [subsingleton_iff, _root_.eq_top_iff, Pi.le_def, Pi.top_apply, forall_const]
refine' (surjective_quot_mk _).forall.trans (forall_congr' fun a => _)
refine' (surjective_quot_mk _).forall.trans (forall_congr' fun b => _)
rw [Quot.eq]
simp only [forall_const, le_Prop_eq]
subst c
exact r.trans' hx (r.symm' hy)
simp only [rel_iff_exists_classes, exists_prop, h]
rw [hu] <;> exact Set.mem_univ a
  (ExistsUnique.intro₂ b hc ha) fun b' hc' ha' => H.elim_set hc' hc a ha' ha
let h := @le_antisymm (Setoid α) _ _ _ hx hy
rw [Subtype.ext_iff_val, ← classes_mk_classes x.1 x.2, ← classes_mk_classes y.1 y.2, h]
rw [Subtype.ext_iff_val, ← classes_mk_classes C.1 C.2]
rw [of_fin, to_nat_of_nat, Nat.mod_eq_of_lt] <;> apply i.is_lt
simp [add_lsb, two_mul]
rw [List.foldr_reverse, flip] <;> rfl
rw [to_fin, Fin.coe_of_nat_eq_mod', Nat.mod_eq_of_lt] <;> apply to_nat_lt
rw [to_fin_val, to_fin_val] <;> exact h
simp only [to_nat_of_nat, Nat.mod_eq_of_lt, Fin.is_lt]
exact h
simp [to_fin_val, of_fin, to_nat_of_nat, Nat.mod_eq_of_lt, i.is_lt]
dsimp [of_fin] <;> rw [to_fin_val, of_nat_to_nat]
simp
simp [bits_to_nat_to_list]
unfold bits_to_nat add_lsb List.foldl cond
simp [cond_to_bool_mod_two]
simp only [star_def, star_trivial, real_smul, map_mul, conj_of_real]
simp [hr, hab.1.le]
simp [hab.2]
simp
simp
      -- why does `simp` not know how to apply `smul_cons`, which is a `@[simp]` lemma, here?
simp [Matrix.smul_cons c z.re, Matrix.smul_cons c z.im]
rw [finrank_eq_card_basis basis_one_I, Fintype.card_fin]
simp [← finrank_eq_dim, finrank_real_complex]
simp [← finrank_eq_dim, finrank_real_complex, bit0]
rw [← dim_mul_dim' ℝ ℂ E, Complex.dim_real_complex]
simp [bit0]
rw [← FiniteDimensional.finrank_mul_finrank ℝ ℂ E, Complex.finrank_real_complex]
rw [star_trivial r, restrict_scalars_smul_def, restrict_scalars_smul_def, star_smul,
      Complex.coe_algebra_map, Complex.star_def, Complex.conj_of_real]
simp
simp
rw [← map_pow, I_sq, map_neg, map_one]
rw [RingHom.map_one, zero_smul, add_zero]
simp
rw [← F.map_mul, I_mul_I, AlgHom.map_neg, AlgHom.map_one]
simp only [selfAdjoint.mem_iff, neg_smul, star_neg, star_smul, star_def, conj_I,
        skewAdjoint.star_coe_eq, neg_smul_neg]
simp only [smul_smul, skewAdjoint.neg_I_smul_apply_coe, neg_smul, smul_neg, I_mul_I, one_smul,
    neg_neg]
unfold realPart
simp only [self_adjoint_part_apply_coe, invOf_eq_inv]
unfold imaginaryPart
simp only [LinearMap.coe_comp, skewAdjoint.neg_I_smul_apply_coe, skew_adjoint_part_apply_coe,
    invOf_eq_inv]
simp [H]
simp
simp [bit0]
simp [bit1]
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
infer_instance
rw [pow_bit0', I_mul_I]
rw [pow_bit1', I_mul_I]
simp only [eta, neg_neg]
simp [conj]
simp
simp [bit0]
simp [bit0]
simp
rw [e, conj_of_real]
simp
simp
simp [norm_sq]
rw [← mk_eq_add_mul_I, norm_sq_mk, sq, sq]
simp [norm_sq]
rw [norm_sq_of_real, Real.mul_self_sqrt hx]
simp [norm_sq]
simp [norm_sq]
simp [norm_sq, mul_comm, sub_eq_neg_add, add_comm]
simp [two_mul]
rw [sq, I_mul_I]
simp
induction n <;> simp [*, of_real_mul, pow_succ]
simp [two_mul, sub_eq_add_neg]
rw [sub_eq_add_neg, norm_sq_add]
simp only [RingHom.map_neg, mul_neg, neg_re, Tactic.Ring.add_neg_eq_sub, norm_sq_neg]
simp [inv_def, division_def]
simp [inv_def, division_def]
simp
rw [← of_real_zero, ← of_real_inv, inv_zero]
rw [inv_def, ← mul_assoc, mul_conj, ← of_real_mul, mul_inv_cancel (mt norm_sq_eq_zero.1 h),
    of_real_one]
rw [zpow_bit0', I_mul_I]
rw [zpow_bit1', I_mul_I]
simp [div_eq_mul_inv, mul_assoc, sub_eq_add_neg]
simp [div_eq_mul_inv, mul_assoc, sub_eq_add_neg, add_comm]
simp [mul_assoc]
simp [inv_eq_one_div]
rw [← of_real_nat_cast, of_real_re]
rw [← of_real_nat_cast, of_real_im]
rw [← of_real_int_cast, of_real_re]
rw [← of_real_int_cast, of_real_im]
rw [← of_real_rat_cast, of_real_re]
rw [← of_real_rat_cast, of_real_im]
simp only [add_conj, of_real_mul, of_real_one, of_real_bit0,
    mul_div_cancel_left (z.re : ℂ) two_ne_zero]
simp only [sub_conj, of_real_mul, of_real_one, of_real_bit0, mul_right_comm,
    mul_div_cancel_left _ (mul_ne_zero two_ne_zero I_ne_zero : 2 * I ≠ 0)]
simp
rw [mul_self_le_mul_self_iff (abs_nonneg z.re) (abs_nonneg' _), abs_mul_abs_self, mul_self_abs]
apply re_sq_le_norm_sq
rw [norm_sq_mul, Real.sqrt_mul (norm_sq_nonneg _)]
rw [mul_self_abs, add_mul_self_eq, mul_self_abs, mul_self_abs, add_right_comm, norm_sq_add,
      add_le_add_iff_left, mul_assoc, mul_le_mul_left (zero_lt_two' ℝ), ←
      Real.sqrt_mul <| norm_sq_nonneg z, ← norm_sq_conj w, ← map_mul]
exact re_le_abs (z * conj w)
simp [abs, norm_sq_of_real, Real.sqrt_mul_self_eq_abs]
rw [of_real_nat_cast]
rw [sq_abs, norm_sq_apply, ← sq, ← sq, add_sub_cancel']
rw [← sq_abs_sub_sq_re, sub_sub_cancel]
simp [abs]
rw [of_real_bit0, of_real_one]
rw [norm_sq_apply, ← sq]
exact le_add_of_nonneg_right (mul_self_nonneg _)
rw [norm_sq_apply, ← sq, ← sq]
exact le_add_of_nonneg_left (sq_nonneg _)
rw [abs, AbsoluteValue.coe_mk, MulHom.coe_mk, Real.lt_sqrt (abs_nonneg _), norm_sq_apply,
    _root_.sq_abs, ← sq, lt_add_iff_pos_right, mul_self_pos]
rw [max_eq_right hle, ← two_mul, Real.sqrt_mul two_pos.le, Real.sqrt_sq_eq_abs]
simp [hz, zero_le_one]
simp [hz, zero_le_one]
rw [← of_real_nat_cast, abs_of_nonneg (Nat.cast_nonneg n)]
rw [← of_real_int_cast, abs_of_real, Int.cast_abs]
simp [abs, sq, Real.mul_self_sqrt (norm_sq_nonneg _)]
simp [le_def]
simp [lt_def]
rw [le_def, not_and_or, not_le]
rw [lt_def, not_and_or, not_lt]
simp [lt_def, mul_re, mul_im, ← hz.2, ← hw.2, mul_pos hz.1 hw.1]
rw [le_def] at hr
exact hr.1
rw [le_def] at hr
exact hr.2.symm
simp [lim_aux, cau_seq_re]
simp [lim_aux, cau_seq_im]
rw [lim_eq_lim_im_add_lim_re] <;> simp
rw [lim_eq_lim_im_add_lim_re] <;> simp
rw [← RingHom.map_sub, abs_conj] <;> exact hi j hj
simp [cau_seq_conj, (lim_re _).symm, cau_seq_re]
simp [cau_seq_conj, (lim_im _).symm, cau_seq_im, (lim_neg _).symm] <;> rfl
rw [mk_congr Complex.equivRealProd, mk_prod, lift_id, mk_real, continuum_mul_self]
rw [mk_univ, mk_complex]
rw [← le_aleph_0_iff_set_countable, not_le, mk_univ_complex]
apply cantor
simp
simp
rw [IsROrC.of_real_alg, ← smul_eq_mul, smul_assoc, smul_eq_mul, one_mul]
rw [IsROrC.of_real_alg, smul_one_smul]
rw [of_real_alg, zero_smul]
rw [of_real_alg, one_smul]
rw [← of_real_one, of_real_re]
rw [← of_real_one, of_real_im]
rw [h]
simp only [bit0, map_add]
simp only [bit1, AddMonoidHom.map_add, bit0_re, add_right_inj, one_re]
simp only [bit0, map_add]
simp only [bit1, add_right_eq_self, AddMonoidHom.map_add, bit0_im, one_im]
rw [← of_real_zero] <;> exact of_real_inj
apply (@IsROrC.ext_iff K _ ((r + s : ℝ) : K) (r + s)).mpr
simp
simp [bit0]
simp [bit1]
simp
simp [is_R_or_C_simps]
simp only [mul_re, of_real_im, zero_mul, of_real_re, sub_zero]
simp only [add_zero, of_real_im, zero_mul, of_real_re, mul_im]
rw [Algebra.smul_def]
apply of_real_mul_re
rw [Algebra.smul_def]
apply of_real_mul_im
rw [IsROrC.of_real_alg, norm_smul, norm_one, mul_one]
rw [mul_comm, I_im _]
simp only [I_re, zero_sub, I_im', zero_mul, mul_re]
rw [ext_iff]
simp only [of_real_im, conj_im, eq_self_iff_true, conj_re, and_self_iff, neg_zero]
simp only [bit0, RingHom.map_add, eq_self_iff_true]
simp only [bit0, ext_iff, bit1_re, conj_im, eq_self_iff_true, conj_re, neg_add_rev, and_self_iff,
    bit1_im]
simp only [conj_I, RingHom.map_neg, eq_self_iff_true, neg_neg]
rw [ext_iff]
simp only [add_zero, I_re, of_real_im, I_im, zero_sub, zero_mul, conj_im, of_real_re,
    eq_self_iff_true, sub_zero, conj_re, mul_im, neg_inj, and_self_iff, mul_re, mul_zero, map_sub]
simp only [add_zero, mul_zero, map_zero]
simp only [one_im, add_zero, mul_one, one_re, mul_zero]
rw [norm_sq_eq_def]
rfl
rw [norm_sq_eq_def']
simp [sq]
rw [lt_iff_le_and_ne, Ne, eq_comm] <;> simp [norm_sq_nonneg]
simp only [norm_sq_eq_def', norm_neg]
simp only [norm_sq, neg_mul, MonoidWithZeroHom.coe_mk, mul_neg, neg_neg, is_R_or_C_simps]
simp only [map_add, add_zero, ext_iff, MonoidWithZeroHom.coe_mk, add_left_inj,
    mul_eq_mul_left_iff, zero_mul, add_comm, true_or_iff, eq_self_iff_true, mul_neg, add_right_neg,
    zero_add, norm_sq, mul_comm, and_self_iff, neg_neg, mul_zero, sub_eq_neg_add, neg_zero,
    is_R_or_C_simps]
simp only [ext_iff, two_mul, map_add, add_zero, of_real_im, conj_im, of_real_re, eq_self_iff_true,
    add_right_neg, conj_re, and_self_iff]
simp only [of_real_im, of_real_re, eq_self_iff_true, sub_zero, and_self_iff, map_sub]
induction n
· simp only [of_real_one, pow_zero]
· simp only [*, of_real_mul, pow_succ]
simp only [ext_iff, two_mul, sub_eq_add_neg, add_mul, map_add, add_zero, add_left_inj, zero_mul,
    map_add_neg, eq_self_iff_true, add_right_neg, and_self_iff, neg_neg, mul_zero, neg_zero,
    is_R_or_C_simps]
simp only [norm_sq_add, sub_eq_add_neg, RingEquiv.map_neg, mul_neg, norm_sq_neg, map_neg]
simp only [inv_def, norm_sq_eq_def, norm_sq, division_def, MonoidWithZeroHom.coe_mk, sub_zero,
    mul_zero, is_R_or_C_simps]
simp only [inv_def, norm_sq_eq_def, norm_sq, division_def, of_real_im, MonoidWithZeroHom.coe_mk,
    of_real_re, zero_add, map_neg, mul_zero, is_R_or_C_simps]
rw [ext_iff]
rw [← of_real_zero, ← of_real_inv, inv_zero]
rw [inv_def, ← mul_assoc, mul_conj, ← of_real_mul, ← norm_sq_eq_def',
    mul_inv_cancel (mt norm_sq_eq_zero.1 h), of_real_one]
simp only [div_eq_mul_inv, mul_assoc, sub_eq_add_neg, neg_mul, mul_neg, neg_neg, map_neg,
    is_R_or_C_simps]
simp only [div_eq_mul_inv, mul_assoc, sub_eq_add_neg, add_comm, neg_mul, mul_neg, map_neg,
    is_R_or_C_simps]
simp only [← sqrt_norm_sq_eq_norm, norm_sq_conj]
rw [← of_real_nat_cast, of_real_re]
rw [← of_real_nat_cast, of_real_im]
rw [← of_real_int_cast, of_real_re]
rw [← of_real_int_cast, of_real_im]
rw [← of_real_rat_cast, of_real_re]
rw [← of_real_rat_cast, of_real_im]
rw [add_conj, mul_div_cancel_left (re z : K) two_ne_zero]
rw [← neg_inj, ← of_real_neg, ← I_mul_re, re_eq_add_conj]
simp only [mul_add, sub_eq_add_neg, neg_div', neg_mul, conj_I, mul_neg, neg_add_rev, neg_neg,
    RingHom.map_mul]
simp only [abs, norm_sq, Real.sqrt_mul_self_eq_abs, add_zero, of_real_im,
    MonoidWithZeroHom.coe_mk, of_real_re, mul_zero]
simp only [abs, norm_sq_eq_def', norm_nonneg, Real.sqrt_sq]
rw [IsROrC.norm_eq_abs, IsROrC.abs_of_real, Real.norm_eq_abs]
rw [norm_of_real]
exact abs_eq_self.mpr r_nn
rw [← of_real_nat_cast]
exact abs_of_nonneg (Nat.cast_nonneg n)
simp only [abs, Real.sqrt_zero, map_zero]
simp only [abs, map_one, Real.sqrt_one]
rw [of_real_bit0, of_real_one]
simp only [abs, norm_sq_conj]
rw [abs, norm_sq_mul, Real.sqrt_mul (norm_sq_nonneg _)] <;> rfl
rw [mul_self_le_mul_self_iff (_root_.abs_nonneg (re z)) (abs_nonneg _), abs_mul_abs_self,
      mul_self_abs] <;>
    apply re_sq_le_norm_sq
rw [mul_self_le_mul_self_iff (_root_.abs_nonneg (im z)) (abs_nonneg _), abs_mul_abs_self,
      mul_self_abs] <;>
    apply im_sq_le_norm_sq
rw [IsROrC.norm_eq_abs, Real.norm_eq_abs]
exact IsROrC.abs_re_le_abs _
rw [IsROrC.norm_eq_abs, Real.norm_eq_abs]
exact IsROrC.abs_im_le_abs _
rw [← re_add_im a]
simp only [im_eq_zero_of_le h, add_zero, zero_mul, algebraMap.coe_zero, is_R_or_C_simps]
rw [← of_real_nat_cast, abs_of_nonneg (Nat.cast_nonneg n)]
rw [abs, sq, Real.mul_self_sqrt (norm_sq_nonneg _)]
rw [mul_conj, of_real_re, abs_of_real, norm_sq_eq_abs, sq, _root_.abs_mul, abs_abs]
simp only [sq, ← norm_sq_eq_abs, norm_sq, map_add, add_zero, MonoidWithZeroHom.coe_mk,
    add_right_neg, mul_zero, is_R_or_C_simps]
simp only [sq, ← norm_sq_eq_abs, norm_sq, map_add, add_zero, MonoidWithZeroHom.coe_mk,
    add_left_neg, mul_zero, is_R_or_C_simps]
simp only [norm_sq, neg_mul, MonoidWithZeroHom.coe_mk, sub_neg_eq_add, map_add, sub_zero,
        mul_zero, is_R_or_C_simps]
simp only [AddMonoidHom.map_zero]
simp only [add_zero, mul_zero, Algebra.id.map_eq_id, RingHom.id_apply, AddMonoidHom.id_apply]
simp only [AddMonoidHom.id_apply, Algebra.id.map_eq_self]
simp only [AddMonoidHom.zero_apply]
simp only [sub_zero, mul_zero, AddMonoidHom.zero_apply, AddMonoidHom.id_apply]
simp only [add_zero, zero_mul, mul_zero, AddMonoidHom.zero_apply]
simp only [star_ring_end_apply, star_id_of_comm]
simp only [neg_zero, AddMonoidHom.zero_apply]
simp only [RingHom.map_zero, neg_zero]
simp only [sq, Real.norm_eq_abs, ← abs_mul, abs_mul_self z, add_zero, mul_zero,
        AddMonoidHom.zero_apply, AddMonoidHom.id_apply]
simp only [mul_zero, AddMonoidHom.zero_apply]
simp only [star_ring_end_apply, star, sq, Real.norm_eq_abs, abs_mul_abs_self, ←
        div_eq_mul_inv, Algebra.id.map_eq_id, id.def, RingHom.id_apply, div_self_mul_self']
simp only [div_zero, mul_zero, neg_zero]
simp [IsROrC.normSq]
simp [IsROrC.abs, abs, Real.sqrt_mul_self_eq_abs]
simp only [norm_eq_abs, re_lm_coe, one_mul, abs_to_real]
exact abs_re_le_abs
simp only [norm_eq_abs, re_lm_coe, one_mul, abs_to_real]
exact abs_im_le_abs
simp [norm_eq_abs, is_R_or_C_simps]
simp [norm_eq_abs]
rw [← LinearMap.det_to_matrix basis_one_I, to_matrix_conj_ae, Matrix.det_fin_two_of]
simp
rw [← Units.eq_iff, LinearEquiv.coe_det, ← LinearEquiv.to_linear_map_eq_coe,
    AlgEquiv.to_linear_equiv_to_linear_map, det_conj_ae, Units.coe_neg_one]
rw [neg_sub, lt_sub_iff_add_lt, add_nsmul, add_nsmul, one_nsmul]
exact add_lt_add_of_le_of_lt hk (lt_of_le_of_lt hk (lt_add_of_pos_right _ ε0))
conv => 
        rhs
        rw [← Nat.succ_pred_eq_of_pos (Nat.pos_of_ne_zero hl0), succ_nsmul', sub_add,
          add_sub_cancel]
simp
rw [mul_comm] <;> exact h _ (Nat.le_of_succ_le kn)
rw [sum_sigma', sum_sigma'] <;>
    exact
      sum_bij (fun a _ => ⟨a.2, a.1 - a.2⟩)
        (fun a ha =>
          have h₁ : a.1 < n := mem_range.1 (mem_sigma.1 ha).1
          have h₂ : a.2 < Nat.succ a.1 := mem_range.1 (mem_sigma.1 ha).2
          mem_sigma.2
            ⟨mem_range.2 (lt_of_lt_of_le h₂ h₁),
              mem_range.2 ((tsub_lt_tsub_iff_right (Nat.le_of_lt_succ h₂)).2 h₁)⟩)
        (fun _ _ => rfl)
        (fun ⟨a₁, a₂⟩ ⟨b₁, b₂⟩ ha hb h =>
          have ha : a₁ < n ∧ a₂ ≤ a₁ :=
            ⟨mem_range.1 (mem_sigma.1 ha).1, Nat.le_of_lt_succ (mem_range.1 (mem_sigma.1 ha).2)⟩
          have hb : b₁ < n ∧ b₂ ≤ b₁ :=
            ⟨mem_range.1 (mem_sigma.1 hb).1, Nat.le_of_lt_succ (mem_range.1 (mem_sigma.1 hb).2)⟩
          have h : a₂ = b₂ ∧ _ := Sigma.mk.inj h
          have h' : a₁ = b₁ - b₂ + a₂ := (tsub_eq_iff_eq_add_of_le ha.2).1 (eq_of_heq h.2)
          Sigma.mk.inj_iff.2 ⟨tsub_add_cancel_of_le hb.2 ▸ h'.symm ▸ h.1 ▸ rfl, heq_of_eq h.1⟩)
        fun ⟨a₁, a₂⟩ ha =>
        have ha : a₁ < n ∧ a₂ < n - a₁ :=
          ⟨mem_range.1 (mem_sigma.1 ha).1, mem_range.1 (mem_sigma.1 ha).2⟩
        ⟨⟨a₂ + a₁, a₁⟩,
          ⟨mem_sigma.2
              ⟨mem_range.2 (lt_tsub_iff_right.1 ha.2),
                mem_range.2 (Nat.lt_succ_of_le (Nat.le_add_left _ _))⟩,
            Sigma.mk.inj_iff.2 ⟨rfl, heq_of_eq (add_tsub_cancel_right _ _).symm⟩⟩⟩
simp [abv_zero abv]
rw [sum_insert has, sum_insert has] <;> exact le_trans (abv_add abv _ _) (add_le_add_left ih _)
simp [Finset.mul_sum]
rw [← sum_add_distrib] <;> simp [(mul_add _ _ _).symm]
rw [← div_div, div_mul_cancel _ (Ne.symm (ne_of_lt hP0)), two_mul_two, mul_assoc, ← div_div,
        div_mul_cancel _ h2Q0, add_halves]
rw [two_mul] <;> exact lt_add_of_pos_left _ (Nat.succ_pos _)
rw [two_mul] <;>
                      exact
                        add_le_add (le_of_lt (mem_range.1 hmJ))
                          (le_trans (le_max_left _ _) (le_of_lt (lt_add_one _)))
rw [← sum_mul, mul_comm] <;> exact (mul_lt_mul_left hPε0).mpr hsumltP
refine' mul_le_mul_of_nonneg_left _ (abv_nonneg _ _)
rw [sub_eq_add_neg]
refine' le_trans (abv_add _ _ _) _
rw [two_mul, abv_neg abv]
exact add_le_add (le_of_lt (hQ _)) (le_of_lt (hQ _))
rw [two_mul] <;>
                    exact
                      add_pos (lt_of_le_of_lt (abv_nonneg _ _) (hQ 0))
                        (lt_of_le_of_lt (abv_nonneg _ _) (hQ 0))
rw [abs_abs, abs_abs, Nat.factorial_succ, pow_succ, mul_comm m.succ, Nat.cast_mul, ← div_div,
        mul_div_assoc, mul_div_right_comm, abs.map_mul, map_div₀, abs_cast_nat] <;>
      exact
        mul_le_mul_of_nonneg_right
          (div_le_div_of_le_left (abs.nonneg _) hn0 (Nat.cast_le.2 (le_trans hm (Nat.le_succ _))))
          (abs.nonneg _)
decide
dsimp <;> simp only [hj] <;> exact cauchy_product (is_cau_abs_exp x) (is_cau_exp y)
rw [Nat.cast_zero, zero_mul, exp_zero, pow_zero]
rw [pow_succ', Nat.cast_add_one, add_mul, exp_add, ← exp_nat_mul, one_mul]
rw [← exp_zero, ← add_neg_self x, exp_add, h] <;> simp
rw [← mul_right_inj' (exp_ne_zero x), ← exp_add] <;> simp [mul_inv_cancel (exp_ne_zero x)]
simp [sub_eq_add_neg, exp_add, exp_neg, div_eq_mul_inv]
dsimp [exp]
rw [← lim_conj]
refine' congr_arg lim (CauSeq.ext fun _ => _)
dsimp [exp', Function.comp, cau_seq_conj]
rw [(starRingEnd _).map_sum]
refine' sum_congr rfl fun n hn => _
rw [map_div₀, map_pow, ← of_real_nat_cast, conj_of_real]
rw [← exp_conj, conj_of_real]
rw [← of_real_exp_of_real_re, of_real_im]
simp [sinh]
simp [sinh, exp_neg, (neg_div _ _).symm, add_mul]
rw [← mul_right_inj' (two_ne_zero' ℂ), two_sinh, exp_add, neg_add, exp_add, eq_comm, mul_add, ←
    mul_assoc, two_sinh, mul_left_comm, two_sinh, ← mul_right_inj' (two_ne_zero' ℂ), mul_add,
    mul_left_comm, two_cosh, ← mul_assoc, two_cosh]
exact sinh_add_aux
simp [cosh]
simp [add_comm, cosh, exp_neg]
rw [← mul_right_inj' (two_ne_zero' ℂ), two_cosh, exp_add, neg_add, exp_add, eq_comm, mul_add, ←
    mul_assoc, two_cosh, ← mul_assoc, two_sinh, ← mul_right_inj' (two_ne_zero' ℂ), mul_add,
    mul_left_comm, two_cosh, mul_left_comm, two_sinh]
exact cosh_add_aux
simp [sub_eq_add_neg, sinh_add, sinh_neg, cosh_neg]
simp [sub_eq_add_neg, cosh_add, sinh_neg, cosh_neg]
rw [sinh, ← RingHom.map_neg, exp_conj, exp_conj, ← RingHom.map_sub, sinh, map_div₀, conj_bit0,
    RingHom.map_one]
rw [← sinh_conj, conj_of_real]
rw [← of_real_sinh_of_real_re, of_real_im]
rw [cosh, ← RingHom.map_neg, exp_conj, exp_conj, ← RingHom.map_add, cosh, map_div₀, conj_bit0,
    RingHom.map_one]
rw [← cosh_conj, conj_of_real]
rw [← of_real_cosh_of_real_re, of_real_im]
simp [tanh]
simp [tanh, neg_div]
rw [tanh, sinh_conj, cosh_conj, ← map_div₀, tanh]
rw [← tanh_conj, conj_of_real]
rw [← of_real_tanh_of_real_re, of_real_im]
rw [← mul_right_inj' (two_ne_zero' ℂ), mul_add, two_cosh, two_sinh, add_add_sub_cancel, two_mul]
rw [add_comm, cosh_add_sinh]
rw [← mul_right_inj' (two_ne_zero' ℂ), mul_sub, two_cosh, two_sinh, add_sub_sub_cancel, two_mul]
rw [← neg_sub, cosh_sub_sinh]
rw [sq_sub_sq, cosh_add_sinh, cosh_sub_sinh, ← exp_add, add_neg_self, exp_zero]
rw [two_mul, cosh_add, sq, sq]
simp [sin]
simp [sin, sub_eq_add_neg, exp_neg, (neg_div _ _).symm, add_mul]
rw [← mul_right_inj' (two_ne_zero' ℂ), two_sinh, ← mul_assoc, two_sin, mul_assoc, I_mul_I,
    mul_neg_one, neg_sub, neg_mul_eq_neg_mul]
rw [← mul_right_inj' (two_ne_zero' ℂ), two_cosh, two_cos, neg_mul_eq_neg_mul]
rw [tanh_eq_sinh_div_cosh, cosh_mul_I, sinh_mul_I, mul_div_right_comm, tan]
rw [tan, sin_mul_I, cos_mul_I, mul_div_right_comm, tanh_eq_sinh_div_cosh]
rw [← mul_left_inj' I_ne_zero, ← sinh_mul_I, add_mul, add_mul, mul_right_comm, ← sinh_mul_I,
    mul_assoc, ← sinh_mul_I, ← cosh_mul_I, ← cosh_mul_I, sinh_add]
simp [cos]
simp [cos, sub_eq_add_neg, exp_neg, add_comm]
rw [← cosh_mul_I, add_mul, cosh_add, cosh_mul_I, cosh_mul_I, sinh_mul_I, sinh_mul_I,
    mul_mul_mul_comm, I_mul_I, mul_neg_one, sub_eq_add_neg]
simp [sub_eq_add_neg, sin_add, sin_neg, cos_neg]
simp [sub_eq_add_neg, cos_add, sin_neg, cos_neg]
rw [sin_add, cos_mul_I, sin_mul_I, mul_assoc]
rw [cos_add, cos_mul_I, sin_mul_I, mul_assoc]
rw [← mul_left_inj' I_ne_zero, ← sinh_mul_I, ← conj_neg_I, ← RingHom.map_mul, ← RingHom.map_mul,
    sinh_conj, mul_neg, sinh_neg, sinh_mul_I, mul_neg]
rw [← sin_conj, conj_of_real]
rw [← of_real_sin_of_real_re, of_real_im]
rw [← cosh_mul_I, ← conj_neg_I, ← RingHom.map_mul, ← cosh_mul_I, cosh_conj, mul_neg, cosh_neg]
rw [← cos_conj, conj_of_real]
rw [← of_real_cos_of_real_re, of_real_im]
simp [tan]
rw [tan_eq_sin_div_cos, div_mul_cancel _ hx]
simp [tan, neg_div]
rw [tan, sin_conj, cos_conj, ← map_div₀, tan]
rw [← tan_conj, conj_of_real]
rw [← of_real_tan_of_real_re, of_real_im]
rw [← cosh_add_sinh, sinh_mul_I, cosh_mul_I]
rw [neg_mul, ← cosh_sub_sinh, sinh_mul_I, cosh_mul_I]
rw [cosh_mul_I, sinh_mul_I, mul_pow, I_sq, mul_neg_one, sub_neg_eq_add, add_comm]
rw [add_comm, sin_sq_add_cos_sq]
rw [two_mul, cos_add, ← sq, ← sq]
rw [cos_two_mul', eq_sub_iff_add_eq.2 (sin_sq_add_cos_sq x), ← sub_add, sub_add_eq_add_sub,
    two_mul]
rw [two_mul, sin_add, two_mul, add_mul, mul_comm]
simp [cos_two_mul, div_add_div_same, mul_div_cancel_left, two_ne_zero, -one_div]
rw [← sin_sq_add_cos_sq x, add_sub_cancel']
rw [← sin_sq_add_cos_sq x, add_sub_cancel]
simp only [← tan_mul_cos hx, mul_pow, ← inv_one_add_tan_sq hx, div_eq_mul_inv, one_mul]
rw [exp_add, exp_mul_I]
rw [← exp_add_mul_I, re_add_im]
rw [exp_eq_exp_re_mul_sin_add_cos]
simp [exp_of_real_re, cos_of_real_re]
rw [exp_eq_exp_re_mul_sin_add_cos]
simp [exp_of_real_re, sin_of_real_re]
simp [exp_mul_I, cos_of_real_re]
simp [exp_mul_I, sin_of_real_re]
simp [Real.exp]
simp [exp_add, exp]
rw [Nat.cast_zero, zero_mul, exp_zero, pow_zero]
rw [pow_succ', Nat.cast_add_one, add_mul, exp_add, ← exp_nat_mul, one_mul]
rw [exp, ← of_real_inj] at h <;> simp_all
rw [← of_real_inj, exp, of_real_exp_of_real_re, of_real_neg, exp_neg, of_real_inv, of_real_exp]
simp [sub_eq_add_neg, exp_add, exp_neg, div_eq_mul_inv]
simp [sin]
simp [sin, exp_neg, (neg_div _ _).symm, add_mul]
rw [← of_real_inj] <;> simp [sin, sin_add]
simp [cos]
simp [cos, exp_neg]
cases le_total x 0 <;> simp only [*, _root_.abs_of_nonneg, abs_of_nonpos, cos_neg]
rw [← of_real_inj] <;> simp [cos, cos_add]
simp [sub_eq_add_neg, sin_add, sin_neg, cos_neg]
simp [sub_eq_add_neg, cos_add, sin_neg, cos_neg]
rw [← of_real_inj, of_real_tan, tan_eq_sin_div_cos, of_real_div, of_real_sin, of_real_cos]
rw [tan_eq_sin_div_cos, div_mul_cancel _ hx]
simp [tan]
simp [tan, neg_div]
simp
rw [add_comm, sin_sq_add_cos_sq]
rw [← sin_sq_add_cos_sq x] <;> exact le_add_of_nonneg_right (sq_nonneg _)
rw [← sin_sq_add_cos_sq x] <;> exact le_add_of_nonneg_left (sq_nonneg _)
simp only [← sq, sin_sq_le_one]
simp only [← sq, cos_sq_le_one]
rw [← of_real_inj] <;> simp [cos_two_mul]
rw [← of_real_inj] <;> simp [cos_two_mul']
rw [← of_real_inj] <;> simp [sin_two_mul]
rw [← sin_sq_add_cos_sq x, add_sub_cancel']
rw [← sin_sq, sqrt_sq_eq_abs]
rw [← cos_sq', sqrt_sq_eq_abs]
simp only [← tan_mul_cos hx, mul_pow, ← inv_one_add_tan_sq hx, div_eq_mul_inv, one_mul]
rw [← sqrt_sq hx.le, ← sqrt_inv, inv_one_add_tan_sq hx.ne']
rw [← tan_mul_cos hx.ne', ← inv_sqrt_one_add_tan_sq hx, div_eq_mul_inv]
rw [← of_real_inj] <;> simp [cos_three_mul]
rw [← of_real_inj] <;> simp [sin_three_mul]
rw [sinh, exp, exp, Complex.of_real_neg, Complex.sinh, mul_two, ← Complex.add_re, ← mul_two,
      div_mul_cancel _ (two_ne_zero' ℂ), Complex.sub_re]
simp [sinh]
simp [sinh, exp_neg, (neg_div _ _).symm, add_mul]
rw [← of_real_inj] <;> simp [sinh_add]
rw [cosh, exp, exp, Complex.of_real_neg, Complex.cosh, mul_two, ← Complex.add_re, ← mul_two,
      div_mul_cancel _ (two_ne_zero' ℂ), Complex.add_re]
simp [cosh]
simp
cases le_total x 0 <;> simp [*, _root_.abs_of_nonneg, abs_of_nonpos]
rw [← of_real_inj] <;> simp [cosh_add]
simp [sub_eq_add_neg, sinh_add, sinh_neg, cosh_neg]
simp [sub_eq_add_neg, cosh_add, sinh_neg, cosh_neg]
simp [tanh_eq_sinh_div_cosh]
simp [tanh]
simp [tanh, neg_div]
rw [← of_real_inj] <;> simp
rw [add_comm, cosh_add_sinh]
rw [← of_real_inj]
simp
rw [← neg_sub, cosh_sub_sinh]
rw [← of_real_inj] <;> simp
rw [← of_real_inj] <;> simp [cosh_sq]
rw [← of_real_inj] <;> simp [sinh_sq]
rw [← of_real_inj] <;> simp [cosh_two_mul]
rw [← of_real_inj] <;> simp [sinh_two_mul]
rw [← of_real_inj] <;> simp [cosh_three_mul]
rw [← of_real_inj] <;> simp [sinh_three_mul]
simp
simp
rw [exp, Complex.exp, ← cau_seq_re, lim_re]
rw [← neg_neg x, Real.exp_neg] <;>
      exact inv_pos.2 (lt_of_lt_of_le zero_lt_one (one_le_exp (neg_nonneg.2 h)))
rw [← exp_zero, exp_lt_exp]
rw [← exp_zero, exp_lt_exp]
rw [add_tsub_cancel_right]
refine' sum_le_sum fun m n => _
rw [one_div, inv_le_inv]
· rw [← Nat.cast_pow, ← Nat.cast_mul, Nat.cast_le, add_comm]
        exact Nat.factorial_mul_pow_le_factorial
· exact Nat.cast_pos.2 (Nat.factorial_pos _)
·
        exact
          mul_pos (Nat.cast_pos.2 (Nat.factorial_pos _))
            (pow_pos (Nat.cast_pos.2 (Nat.succ_pos _)) _)
simp [mul_inv, mul_sum.symm, sum_mul.symm, -Nat.factorial_succ, mul_comm, inv_pow]
simp
refine' Iff.mpr (div_le_div_right (mul_pos _ _)) _
exact Nat.cast_pos.2 (Nat.factorial_pos _)
exact Nat.cast_pos.2 hn
exact
        sub_le_self _
          (mul_nonneg (Nat.cast_nonneg _) (pow_nonneg (inv_nonneg.2 (Nat.cast_nonneg _)) _))
refine' congr_arg abs (sum_congr rfl fun m hm => _)
rw [mem_filter, mem_range] at hm
rw [← mul_div_assoc, ← pow_add, add_tsub_cancel_of_le hm.2]
refine' sum_le_sum fun m hm => _
rw [map_mul, map_pow, map_div₀, abs_cast_nat]
refine' mul_le_mul_of_nonneg_left ((div_le_div_right _).2 _) _
· exact Nat.cast_pos.2 (Nat.factorial_pos _)
· rw [abv_pow abs]
        exact pow_le_one _ (abs.nonneg _) hx
· exact pow_nonneg (abs.nonneg _) _
simp [abs_mul, abv_pow abs, abs_div, mul_sum.symm]
simp only [Complex.abs_cast_nat, map_div₀, abv_pow abs]
simp [sum_range_succ]
decide
simp [two_mul, mul_two, mul_add, mul_comm]
simp [sub_eq_add_neg, sum_range_succ_comm, add_assoc]
decide
rw [mul_one]
simp [exp_near]
simp [exp_near, range_succ, mul_add, add_left_comm, add_assoc, pow_succ, div_eq_mul_inv,
      mul_inv] <;>
    ac_rfl
simp [exp_near, mul_sub]
rw [← abs_of_real] <;> simp [of_real_bit0, of_real_one, of_real_inv]
simp [Complex.cos, sub_div, add_div, neg_div, div_self (two_ne_zero' ℂ)]
simp [map_div₀]
decide
decide
rw [← abs_of_real] <;> simp [of_real_bit0, of_real_one, of_real_inv]
simp [add_comm, map_div₀]
decide
decide
rw [sq, ← abs_mul_self, _root_.abs_mul] <;>
                      exact mul_le_one hx (abs_nonneg _) hx
decide
simp [_root_.abs_of_nonneg (le_of_lt hx0)]
decide
rw [← sin_two_mul, two_mul, add_halves]
simp
rw [sq, sq]
exact mul_self_le_mul_self (le_of_lt cos_one_pos) cos_one_le
cases le_or_lt 0 x
· exact Real.add_one_le_exp_of_nonneg h
exact add_one_le_exp_of_nonpos h.le
have := Real.sin_sq_add_cos_sq x
simp_all [add_comm, abs, norm_sq, sq, sin_of_real_re, cos_of_real_re, mul_re]
rw [← of_real_exp] <;> exact abs_of_nonneg (le_of_lt (Real.exp_pos _))
rw [exp_mul_I, abs_cos_add_sin_mul_I]
rw [exp_eq_exp_re_mul_sin_add_cos, map_mul, abs_exp_of_real, abs_cos_add_sin_mul_I, mul_one]
rw [abs_exp, abs_exp, Real.exp_eq_exp]
simp [factorization, pp, padic_val_nat_def' pp.ne_one hn.bot_lt]
rw [factorization_eq_factors_multiset n]
simp only [← prod_to_multiset, factorization, Multiset.coe_prod, Multiset.to_finsupp_to_multiset]
exact prod_factors hn
simp [h]
simp [factorization]
simp only [support_factorization, List.mem_to_finset]
simp [factorization_eq_zero_iff, hp]
simp [factorization_eq_zero_iff, h]
rw [factorization_eq_factors_multiset n]
simp [factorization, AddEquiv.map_eq_zero_iff, Multiset.coe_eq_zero]
apply prod_congr support_factorization
simp
simp [hp]
simp [hp]
rw [← Nat.factorization_prod_pow_eq_self hn, h]
simp
rw [h, factorization_prod_pow_eq_self hn]
rw [← h, prod_pow_factorization_eq_self hf]
cases n
rfl
simp [factorization_eq_zero_of_non_prime n hp]
simp [factorization_eq_zero_of_non_prime n hp]
simp [factorization_mul ha hb, pow_add]
rw [mul_comm]
apply factorization_le_factorization_mul_left ha
rw [← factorization_le_iff_dvd (pow_pos pp.pos k).ne' hn, pp.factorization_pow, single_le_iff]
rw [pow_dvd_pow_iff_le_right pp.one_lt, pp.pow_dvd_iff_le_factorization hn]
simp
rw [Nat.Prime.dvd_iff_one_le_factorization hp (ord_compl_pos p hn).ne']
rw [Nat.factorization_div (Nat.ord_proj_dvd n p)]
simp [hp.factorization]
let dfac := a.factorization
simp [← Icc_factorization_eq_pow_dvd n pp]
simp only [← factors_count_eq, perm_iff_count.mp (perm_factors_mul_of_coprime hab), count_append]
rw [mul_comm]
exact factorization_eq_of_coprime_left (coprime_comm.mp hab) hpb
rw [factorization_mul_of_coprime hab]
exact support_add_eq (factorization_disjoint_of_coprime hab)
let p := (k + 2).minFac
have hp : Prime p := min_fac_prime (succ_succ_ne_one k)
      -- the awkward `let` stuff here is because `factorization` is noncomputable (finsupp);
      -- we get around this
rw [ht]
exact ord_proj_dvd _ _
rw [ht]
exact hp.factorization_pos_of_dvd (Nat.succ_ne_zero _) (min_fac_dvd _)
intro a p n hp' hpa hn hPa
rw [← hn, Nat.Prime.factorization_pow hp]
simp [hn, hk.ne']
simp
simp
simp only [is_prime_pow_iff_unique_prime_dvd]
apply exists_unique_congr
simp only [and_congr_right_iff]
intro p hp
exact ⟨hp.dvd_of_dvd_pow, fun t => t.trans (dvd_pow_self _ hk)⟩
rw [← Finsupp.not_mem_support_iff, ← Finsupp.not_mem_support_iff, ← not_and_or, ←
      Finset.mem_inter]
exact fun t => (Nat.factorization_disjoint_of_coprime hab).le_bot t
rw [count, List.range_zero, List.countp]
apply Fintype.ofFinset ((Finset.range n).filter p)
intro x
rw [mem_filter, mem_range]
rfl
rw [count, List.countp_eq_length_filter]
rfl
rw [count_eq_card_filter_range, ← Fintype.card_of_finset, ← count_set.fintype]
rfl
simp [count_succ]
rw [count_add', count_one]
rw [count_eq_card_fintype, ← Cardinal.mk_fintype]
exact Cardinal.mk_subtype_mono fun x hx => hx.2
rw [count_eq_card_filter_range]
exact Finset.card_mono fun x hx => hp.mem_to_finset.2 (mem_filter.1 hx).2
simp only [count_eq_card_filter_range]
exact card_le_of_subset ((range n).monotone_filter_right hpq)
rw [← pochhammer_nat_eq_asc_factorial, pochhammer_eval_cast, Nat.cast_add, Nat.cast_one]
rw [← zero_asc_factorial, cast_asc_factorial, cast_zero, zero_add]
rw [cast_desc_factorial]
cases a
· rw [zero_tsub, cast_zero, pochhammer_ne_zero_eval_zero _ two_ne_zero, zero_mul]
·
    rw [succ_sub_succ, tsub_zero, cast_succ, add_sub_cancel, pochhammer_succ_right, pochhammer_one,
      Polynomial.X_mul, Polynomial.eval_mul_X, Polynomial.eval_add, Polynomial.eval_X, cast_one,
      Polynomial.eval_one]
simp
rw [← add_assoc, Nat.factorial_succ, mul_comm (Nat.succ _), pow_succ', ← mul_assoc] <;>
      exact
        mul_le_mul factorial_mul_pow_le_factorial (Nat.succ_le_succ (Nat.le_add_right _ _))
          (Nat.zero_le _) (Nat.zero_le _)
intro k hk
rw [factorial_succ, succ_mul, lt_add_iff_pos_left]
exact mul_pos hk k.factorial_pos
rw [← succ_pred_eq_of_pos ((zero_lt_two.trans (lt.base 2)).trans_le hi), factorial_succ]
exact
    lt_mul_of_one_lt_right (pred n).succ_pos
      ((one_lt_two.trans_le (le_pred_of_lt (succ_le_iff.mp hi))).trans_le (self_le_factorial _))
rw [factorial_succ (i + _), add_mul, one_mul]
have : i ≤ i + n := le.intro rfl
exact
    add_lt_add_of_lt_of_le
      (this.trans_lt
        ((lt_mul_iff_one_lt_right (zero_lt_two.trans_le (hi.trans this))).mpr
          (lt_iff_le_and_ne.mpr
            ⟨(i + n).factorial_pos, fun g =>
              Nat.not_succ_le_self 1 ((hi.trans this).trans (factorial_eq_one.mp g.symm))⟩)))
      (factorial_le
        ((le_of_eq (add_comm n 1)).trans ((add_le_add_iff_right n).mpr (one_le_two.trans hi))))
cases hn
· rw [factorial_one]
    exact lt_factorial_self (succ_le_succ hi)
exact add_factorial_succ_lt_factorial_add_succ _ hi
apply trans _ this
rw [mul_le_mul_left]
apply pow_le_pow_of_le_left (zero_le n) (le_succ n)
exact factorial_pos n
rw [add_zero, asc_factorial_zero, asc_factorial_zero]
rw [asc_factorial, mul_left_comm, succ_asc_factorial, asc_factorial, succ_add, ← add_assoc]
rw [asc_factorial, add_zero, mul_one]
rw [asc_factorial_succ, mul_left_comm, factorial_mul_asc_factorial, ← add_assoc, factorial]
apply mul_left_cancel₀ n.factorial_ne_zero
rw [factorial_mul_asc_factorial]
exact (Nat.mul_div_cancel' <| factorial_dvd_factorial <| le.intro rfl).symm
rw [asc_factorial_zero, pow_zero]
rw [pow_succ]
exact Nat.mul_le_mul (Nat.add_le_add_right le_self_add _) (pow_succ_le_asc_factorial k)
rw [pow_succ]
exact
    Nat.mul_lt_mul (Nat.add_lt_add_right (Nat.lt_add_of_pos_right succ_pos') 1)
      (pow_succ_le_asc_factorial n _) (pow_pos succ_pos' _)
rw [asc_factorial_zero, pow_zero]
rw [asc_factorial_succ, pow_succ]
exact
      Nat.mul_le_mul_of_nonneg_left
        ((asc_factorial_le_pow_add k).trans (Nat.pow_le_pow_of_le_left (le_succ _) _))
rw [asc_factorial_succ, pow_succ]
refine'
      Nat.mul_lt_mul' le_rfl
        ((asc_factorial_le_pow_add n _).trans_lt
          (pow_lt_pow_of_lt_left (lt_add_one _) (succ_pos _)))
        (succ_pos _)
rw [desc_factorial_succ, zero_tsub, zero_mul]
rw [desc_factorial_succ, desc_factorial_zero, mul_one, tsub_zero]
rw [desc_factorial_zero, desc_factorial_one, mul_one]
rw [desc_factorial_succ, succ_desc_factorial_succ, desc_factorial_succ, succ_sub_succ,
      mul_left_comm]
rw [tsub_zero, desc_factorial_zero, desc_factorial_zero]
rw [desc_factorial, succ_desc_factorial, desc_factorial_succ, succ_sub_succ, mul_left_comm]
rw [desc_factorial_zero, factorial_zero]
rw [succ_desc_factorial_succ, desc_factorial_self, factorial_succ]
simp only [desc_factorial_zero, Nat.one_ne_zero, Nat.not_lt_zero]
rw [desc_factorial_succ, mul_eq_zero, desc_factorial_eq_zero_iff_lt, lt_succ_iff,
      tsub_eq_zero_iff_le, lt_iff_le_and_ne, or_iff_left_iff_imp, and_imp]
exact fun h _ => h
rw [asc_factorial_zero, desc_factorial_zero]
rw [Nat.add_succ, succ_desc_factorial_succ, asc_factorial_succ,
      add_desc_factorial_eq_asc_factorial]
rw [desc_factorial_zero, mul_one, tsub_zero]
apply mul_left_cancel₀ (factorial_ne_zero (n - k))
rw [factorial_mul_desc_factorial h]
exact (Nat.mul_div_cancel' <| factorial_dvd_factorial <| Nat.sub_le n k).symm
rw [desc_factorial_zero, pow_zero]
rw [desc_factorial_succ, pow_succ, succ_sub_succ]
exact
      Nat.mul_le_mul_of_nonneg_left
        (le_trans (Nat.pow_le_pow_of_le_left (tsub_le_tsub_right (le_succ _) _) k)
          (pow_sub_le_desc_factorial k))
rw [desc_factorial_succ, pow_succ, pow_one, desc_factorial_one]
exact
      Nat.mul_lt_mul_of_pos_left (tsub_lt_self (lt_of_lt_of_le zero_lt_two h) zero_lt_one)
        (tsub_pos_of_lt h)
rw [desc_factorial_succ, pow_succ]
refine'
      Nat.mul_lt_mul_of_pos_left
        ((Nat.pow_le_pow_of_le_left (tsub_le_tsub_right (le_succ n) _) _).trans_lt _)
        (tsub_pos_of_lt h)
rw [succ_sub_succ]
exact pow_sub_lt_desc_factorial' ((le_succ _).trans h)
rw [succ_sub_succ]
exact pow_sub_lt_desc_factorial' h
rw [desc_factorial_zero, pow_zero]
rw [desc_factorial_succ, pow_succ]
exact Nat.mul_le_mul (Nat.sub_le _ _) (desc_factorial_le_pow k)
rw [desc_factorial_succ, pow_succ', mul_comm]
exact
      Nat.mul_lt_mul' (desc_factorial_le_pow _ _) (tsub_lt_self hn k.zero_lt_succ) (pow_pos hn _)
simp only [fib, Function.iterate_succ']
cases n <;> simp [fib_add_two]
decide
rw [fib_add_two, add_tsub_cancel_right]
refine' strictMono_nat_of_lt_succ fun n => _
rw [add_right_comm]
exact fib_lt_fib_succ (self_le_add_left _ _)
decide
rw [bit0_eq_two_mul, fib_two_mul]
rw [Nat.bit1_eq_succ_bit0, bit0_eq_two_mul, fib_two_mul_add_one]
rw [two_mul]
exact le_add_left fib_le_fib_succ
rw [fast_fib_aux, binary_rec_eq]
· rfl
· simp
rw [fast_fib_aux, binary_rec_eq]
· rfl
· simp
apply Nat.binaryRec _ (fun b n' ih => _) n
· simp [fast_fib_aux]
·
    cases b <;>
          simp only [fast_fib_aux_bit_ff, fast_fib_aux_bit_tt, congr_arg Prod.fst ih,
            congr_arg Prod.snd ih, Prod.mk.inj_iff] <;>
        constructor <;>
      simp [bit, fib_bit0, fib_bit1, fib_bit0_succ, fib_bit1_succ]
rw [fast_fib, fast_fib_aux_eq]
rw [add_comm, gcd_add_mul_right_right (fib m) _ (fib n.pred)]
simp
rw [← gcd_fib_add_mul_self k, add_mul, ← add_assoc, one_mul, gcd_fib_add_self _ _]
rw [fib_add_two, h1, h2, Finset.Nat.antidiagonal_succ_succ', Finset.Nat.antidiagonal_succ']
simp [choose_succ_succ, Finset.sum_add_distrib, add_left_comm]
rw [ih, add_assoc]
simp [Finset.range_add_one]
rw [← h1, Nat.add_sub_cancel_left]
rw [fib_bit0_succ, H.1, H.2, pow_two, pow_two, h3, h4, add_comm, h5]
rw [fib_bit1, H.1, H.2, pow_two, pow_two, h1, h2, add_comm, h3]
rw [fib_bit1_succ, H.1, H.2, ← bit0_eq_two_mul, h4, h5]
rw [← WithBot.coe_zero, WithBot.coe_le_coe]
exact Nat.zero_le _
decide
simp [WithBot.some_eq_coe]
refine' ⟨fun h => lt_of_lt_of_le (with_bot.coe_lt_coe.mpr zero_lt_one) h, fun h => _⟩
induction x using WithBot.recBotCoe
· exact (not_lt_bot h).elim
· exact with_bot.coe_le_coe.mpr (nat.succ_le_iff.mpr (with_bot.coe_lt_coe.mp h))
rw [factors]
rw [factors]
simp
simp
decide
simp
simp
decide
have : p = p - 2 + 2 := (tsub_eq_iff_eq_add_of_le hp.two_le).mp rfl
rw [this, Nat.factors]
simp only [Eq.symm this]
have : Nat.minFac p = p := (nat.prime_def_min_fac.mp hp).2
constructor
· exact this
· simp only [this, Nat.factors, Nat.div_self (Nat.Prime.pos hp)]
simp
simp
decide
rw [factors]
refine' (factors_unique _ _).symm
· rw [List.prod_append, prod_factors ha, prod_factors hb]
· intro p hp
    rw [List.mem_append] at hp
    cases hp <;> exact prime_of_mem_factors hp
cases n
· rw [zero_mul]
apply sublist_of_subperm_of_sorted _ (factors_sorted _) (factors_sorted _)
rw [(perm_factors_mul n.succ_ne_zero h).subperm_left]
exact (sublist_append_left _ _).Subperm
intro q hqa hqb
apply not_prime_one
rw [← eq_one_of_dvd_coprimes hab (dvd_of_mem_factors hqa) (dvd_of_mem_factors hqb)]
exact prime_of_mem_factors hqa
rw [mul_comm]
exact mem_factors_mul_left hpb ha
simp [dist.def, add_comm]
simp [dist.def, tsub_self]
rw [h, dist_self]
rw [dist.def, tsub_eq_zero_iff_le.mpr h, zero_add]
rw [dist_comm]
apply dist_eq_sub_of_le h
rw [add_comm] <;> apply dist_tri_left
rw [dist_comm] <;> apply dist_tri_left
rw [dist_comm] <;> apply dist_tri_right
rw [add_tsub_add_eq_tsub_right]
rw [add_tsub_add_eq_tsub_right]
rw [add_comm k n, add_comm k m]
apply dist_add_add_right
rw [dist_add_add_right]
rw [h]
rw [dist_add_add_left]
simp [dist.def, add_comm, add_left_comm]
rw [dist.def, dist.def, right_distrib, tsub_mul, tsub_mul]
rw [mul_comm k n, mul_comm k m, dist_mul_right, mul_comm]
rw [max_eq_right_of_lt this, min_eq_left_of_lt this, dist_eq_sub_of_lt this]
rw [max_eq_left this , min_eq_right this, dist_eq_sub_of_le_right this]
simp [dist.def, succ_sub_succ]
rw [dist_eq_sub_of_le (le_of_lt this)]
apply tsub_pos_of_lt this
contradiction
rw [dist_eq_sub_of_le_right (le_of_lt this)]
apply tsub_pos_of_lt this
rw [bit0_val, shiftl_eq_mul_pow, mul_left_comm, mul_comm 2]
simp [shiftl, shiftl', pow_zero, Nat.one_mul]
change bit1 (shiftl' tt m k) + 1 = (m + 1) * (2 * 2 ^ k)
rw [bit1_val]
change 2 * (shiftl' tt m k + 1) = _
rw [shiftl'_tt_eq_mul_pow, mul_left_comm, mul_comm 2]
rw [div2_val, Nat.div_div_eq_div_mul, mul_comm] <;> rfl
induction n <;> simp [bit_ne_zero, shiftl', *]
simp [size]
rw [size]
conv => 
    lhs
    rw [binary_rec]
    simp [h]
rw [div2_bit]
rw [size_bit1, size_zero]
decide
simp
decide
rw [← one_shiftl]
revert n
apply binary_rec _ _ m
· intro n h
      simp
· intro b m IH n h
rw [← not_lt, Decidable.iff_not_comm, not_lt, size_le]
rw [lt_size] <;> rfl
have := @size_pos n <;> simp [pos_iff_ne_zero] at this <;> exact Decidable.not_iff_not.1 this
decide
refine' le_of_not_lt fun hnk => h _
simp [choose_eq_zero_of_lt hnk]
rw [pow_add]
rw [cast_choose K (le_add_right le_rfl), add_tsub_cancel_left]
rw [← cast_desc_factorial_two, desc_factorial_eq_factorial_mul_choose, factorial_two, mul_comm,
    cast_mul, cast_two, eq_div_iff_mul_eq (two_ne_zero : (2 : K) ≠ 0)]
cases n <;> rfl
decide
have hnk : n < k := lt_of_succ_lt_succ hk
have hnk1 : n < k + 1 := lt_of_succ_lt hk
rw [choose_succ_succ, choose_eq_zero_of_lt hnk, choose_eq_zero_of_lt hnk1]
induction n <;> simp [*, choose, choose_eq_zero_of_lt (lt_succ_self _)]
induction n <;> simp [*, choose, add_comm]
rw [← add_mul_div_left, mul_comm 2 n, ← mul_add, add_tsub_cancel_right, mul_comm]
cases n <;> rfl
apply zero_lt_succ
decide
decide
rw [choose_succ_succ] <;>
      exact add_pos_of_pos_of_nonneg (choose_pos (le_of_succ_le_succ hk)) (Nat.zero_le _)
decide
simp [choose]
simp
rw [choose_succ_succ (succ n) (succ k), add_mul, ← succ_mul_choose_eq, mul_succ, ←
      succ_mul_choose_eq, add_right_comm, ← mul_add, ← choose_succ_succ, ← succ_mul]
simp [Nat.eq_zero_of_le_zero hk]
simp
rw [← choose_mul_factorial_mul_factorial (le_of_succ_le_succ hk)] <;>
          simp [factorial_succ, mul_comm, mul_left_comm]
rw [← succ_sub_succ, succ_sub (le_of_lt_succ hk₁), factorial_succ]
rw [← choose_mul_factorial_mul_factorial (le_of_lt_succ hk₁)] <;>
          simp [factorial_succ, mul_comm, mul_left_comm, mul_assoc]
rw [choose_mul_factorial_mul_factorial hsk, choose_mul_factorial_mul_factorial hkn]
rw [choose_mul_factorial_mul_factorial (tsub_le_tsub_right hkn _),
        choose_mul_factorial_mul_factorial (hsk.trans hkn)]
rw [← choose_mul_factorial_mul_factorial hk, mul_assoc]
exact (mul_div_left _ (mul_pos (factorial_pos _) (factorial_pos _))).symm
rw [choose_eq_factorial_div_factorial (Nat.le_add_left j i), add_tsub_cancel_right, mul_comm]
rw [← choose_mul_factorial_mul_factorial (Nat.le_add_left _ _), add_tsub_cancel_right,
    mul_right_comm]
rw [← choose_mul_factorial_mul_factorial hk, mul_assoc] <;> exact dvd_mul_left _ _
rw [choose_eq_factorial_div_factorial hk, choose_eq_factorial_div_factorial (Nat.sub_le _ _),
    tsub_tsub_cancel_of_le hk, mul_comm]
apply choose_symm_of_eq_add
rw [add_comm m 1, add_assoc 1 m m, add_comm (2 * m) 1, two_mul m]
rw [choose_succ_succ, choose_succ_self_right, choose_self]
rw [mul_comm]
apply mul_right_cancel₀ (factorial_ne_zero (n + k - k))
rw [choose_mul_factorial_mul_factorial, add_tsub_cancel_right, ← factorial_mul_asc_factorial,
    mul_comm]
exact Nat.le_add_left k n
apply mul_left_cancel₀ (factorial_ne_zero k)
rw [← asc_factorial_eq_factorial_mul_choose]
exact (Nat.mul_div_cancel' <| factorial_dvd_asc_factorial _ _).symm
apply mul_left_cancel₀ (factorial_ne_zero k)
rw [← desc_factorial_eq_factorial_mul_choose]
exact (Nat.mul_div_cancel' <| factorial_dvd_desc_factorial _ _).symm
refine' le_of_mul_le_mul_right _ (lt_tsub_iff_left.mpr (lt_of_lt_of_le h (n.div_le_self 2)))
rw [← choose_succ_right_eq]
apply Nat.mul_le_mul_left
rw [← Nat.lt_iff_add_one_le, lt_tsub_iff_left, ← mul_two]
exact lt_of_lt_of_le (mul_lt_mul_of_pos_right h zero_lt_two) (n.div_mul_le_self 2)
cases c <;> simp [Nat.choose_succ_succ]
cases n <;> simp [multichoose]
simp [multichoose]
simp [multichoose]
simp
simp
rw [multichoose_succ_succ, add_comm, Nat.succ_add_sub_one, ← add_assoc, Nat.choose_succ_succ]
simp [multichoose_eq]
simp [multinomial, Nat.div_self (factorial_pos (f a))]
simp only [multinomial, one_mul, factorial]
rw [Finset.sum_insert h, Finset.prod_insert h, h₁, add_comm, ← succ_eq_add_one, factorial_succ]
simp only [factorial_one, one_mul, Function.comp_apply, factorial]
rw [Nat.mul_div_assoc _ (prod_factorial_dvd_factorial_sum _ _)]
rw [h a ha]
simp [multinomial, Finset.sum_pair h, Finset.prod_pair h]
simp [binomial_eq _ h, choose_eq_factorial_div_factorial (Nat.le_add_right _ _)]
simp [multinomial_insert_one {b} f (finset.not_mem_singleton.mpr h) h₁]
simp [multinomial, Fin.sum_univ_two, Fin.prod_univ_two]
simp [multinomial, Fin.sum_univ_three, Fin.prod_univ_three]
rw [← add_tsub_assoc_of_le (Nat.le_of_lt hkp) k, add_tsub_cancel_left]
rw [r]
rw [Nat.mul_div_cancel_left n zero_lt_two]
rw [choose_succ_right_eq, choose_mul_succ_eq]
rw [two_mul n, add_assoc, Nat.add_sub_cancel_left]
rw [choose_mul_succ_eq]
rw [mul_assoc, mul_comm (2 * n + 1)]
rw [mul_assoc]
refine' le_mul_of_pos_left zero_lt_two
rw [← Nat.succ_pred_eq_of_pos h]
exact two_dvd_central_binom_succ n.pred
rw [two_mul, add_assoc, coprime_add_self_right, coprime_self_add_left]
exact coprime_one_left n
dsimp [t]
rw [choose_zero_right, pow_zero, Nat.cast_one, mul_one, one_mul]
dsimp [t]
rw [choose_succ_self, Nat.cast_zero, mul_zero]
intro n i h_mem
have h_le : i ≤ n := Nat.le_of_lt_succ (mem_range.mp h_mem)
dsimp [t]
rw [choose_succ_succ, Nat.cast_add, mul_add]
congr 1
· rw [pow_succ x, succ_sub_succ, mul_assoc, mul_assoc, mul_assoc]
· rw [← mul_assoc y, ← mul_assoc y, (h.symm.pow_right i.succ).Eq]
rw [two_mul, this]
rw [pow_succ, pow_mul]
rfl
simp [add_pow]
simp
cases n
· simp
have h := add_pow (-1 : ℤ) 1 n.succ
simp only [one_pow, mul_one, add_left_neg] at h
rw [← h, zero_pow (Nat.succ_pos n), if_neg (Nat.succ_ne_zero n)]
rw [Int.alternating_sum_range_choose, if_neg h0]
rw [sum_powerset_apply_card]
simp only [nsmul_eq_mul', ← card_eq_zero, Int.alternating_sum_range_choose]
simp
simp
rw [gcd_zero_left] <;> exact ⟨dvd_zero n, dvd_refl n⟩
rw [← gcd_rec] <;> exact fun ⟨IH₁, IH₂⟩ => ⟨IH₂, (dvd_mod_iff IH₂).1 IH₁⟩
rw [gcd_zero_left] <;> exact kn
rw [gcd_rec] <;> exact IH ((dvd_mod_iff H1).2 H2) H1
rw [gcd_rec, mod_eq_zero_of_dvd h, gcd_zero_left]
rw [gcd_comm] <;> apply gcd_eq_left_iff_dvd
rw [mul_comm m n, mul_comm k n, mul_comm (gcd m k) n, gcd_mul_left]
rw [gcd_comm] at H <;> exact eq_zero_of_gcd_eq_zero_left H
rw [k0, Nat.div_zero, Nat.div_zero, Nat.div_zero, gcd_zero_right]
rw [Nat.div_mul_cancel (dvd_gcd H1 H2), ← gcd_mul_right, Nat.div_mul_cancel H1,
        Nat.div_mul_cancel H2]
rw [gcd_comm, gcd_eq_left H]
rw [gcd_comm, gcd_mul_left_left]
rw [mul_comm, gcd_mul_left_left]
rw [gcd_comm, gcd_mul_right_left]
rw [gcd_comm n m, gcd_gcd_self_right_left]
rw [gcd_comm, gcd_gcd_self_right_right]
rw [gcd_comm m n, gcd_gcd_self_left_right]
simp [gcd_rec m (n + k * m), gcd_rec m n]
simp [gcd_rec m (n + m * k), gcd_rec m n]
simp [add_comm _ n]
simp [add_comm _ n]
rw [gcd_comm, gcd_add_mul_right_right, gcd_comm]
rw [gcd_comm, gcd_add_mul_left_right, gcd_comm]
rw [gcd_comm, gcd_mul_right_add_right, gcd_comm]
rw [gcd_comm, gcd_mul_left_add_right, gcd_comm]
rw [one_mul]
rw [gcd_comm, gcd_add_self_right, gcd_comm]
rw [add_comm, gcd_add_self_left]
rw [add_comm, gcd_add_self_right]
delta lcm <;> rw [mul_comm, gcd_comm]
delta lcm <;> rw [zero_mul, Nat.zero_div]
delta lcm <;> rw [one_mul, gcd_one_left, Nat.div_one]
rw [h, lcm_zero_left]
delta lcm <;> rw [gcd_self, Nat.mul_div_cancel _ h]
delta lcm <;> rw [Nat.mul_div_cancel' ((gcd_dvd_left m n).trans (dvd_mul_right m n))]
rw [h] <;> exact dvd_zero _
rw [gcd_mul_lcm, ← gcd_mul_right, mul_comm n k] <;>
        exact dvd_gcd (mul_dvd_mul_left _ H2) (mul_dvd_mul_right H1 _)
unfold coprime <;> infer_instance
rw [← one_mul (lcm m n), ← h.gcd_eq_one, gcd_mul_lcm]
rw [mul_comm] at H2 <;> exact H1.dvd_of_dvd_mul_right H2
rw [coprime, gcd_assoc, H.symm.gcd_eq_one, gcd_one_right]
rw [mul_comm m k, H.gcd_mul_left_cancel m]
rw [gcd_comm m n, gcd_comm m (k * n), H.gcd_mul_left_cancel n]
rw [mul_comm n k, H.gcd_mul_left_cancel_right n]
rw [coprime_iff_gcd_eq_one, gcd_div (gcd_dvd_left m n) (gcd_dvd_right m n), Nat.div_self H]
rw [← co.gcd_eq_one] <;> exact dvd_gcd Hm Hn
rw [coprime, coprime, gcd_add_self_right]
rw [add_comm, coprime_add_self_right]
rw [coprime, coprime, gcd_add_self_left]
rw [coprime, coprime, gcd_self_add_left]
rw [coprime, coprime, gcd_add_mul_right_right]
rw [coprime, coprime, gcd_add_mul_left_right]
rw [coprime, coprime, gcd_mul_right_add_right]
rw [coprime, coprime, gcd_mul_left_add_right]
rw [coprime, coprime, gcd_add_mul_right_left]
rw [coprime, coprime, gcd_add_mul_left_left]
rw [coprime, coprime, gcd_mul_right_add_left]
rw [coprime, coprime, gcd_mul_left_add_left]
delta coprime at H2 <;> rw [← H2] <;> exact gcd_dvd_gcd_of_dvd_left _ H1
rw [Nat.coprime_comm, coprime_pow_left_iff hn, Nat.coprime_comm]
rw [← H.gcd_eq_one, gcd_eq_left d]
simp [coprime]
simp [coprime]
simp
simp [coprime]
simp [coprime]
simp [coprime]
rw [coprime_iff_gcd_eq_one] at h_ab_coprime
have h1 := dvd_gcd hka hkb
rw [h_ab_coprime] at h1
exact nat.dvd_one.mp h1
rw [one_div]
exact inv_pos_of_nat
intros
rfl
intros
rfl
rw [cast_succ, cast_zero, zero_add]
induction n <;> simp [add_succ, add_assoc, Nat.add_zero, *]
rw [Nat.binCast]
apply binary_rec _ _ n
· rw [binary_rec_zero, cast_zero]
· intro b k h
    rw [binary_rec_eq, h]
    · cases b <;> simp [bit, bit0, bit1]
    · simp
rw [bit1, cast_add_one, cast_bit0] <;> rfl
rw [cast_add_one, cast_one, bit0]
simp [Nat.binCast, Nat.cast]
induction n <;> simp [mul_succ, mul_add, *]
rw [cast_zero] <;> exact Commute.zero_left x
rw [cast_succ] <;> exact ihn.add_left (Commute.one_left x)
rw [Nat.cast_succ] <;> exact le_add_of_nonneg_right zero_le_one
cases n <;> simp [cast_add_one_pos]
rw [← cast_one, cast_lt]
rw [← cast_one, cast_le]
rw [← cast_one, cast_lt, lt_succ_iff, ← bot_eq_zero, le_bot_iff]
rw [← cast_one, cast_le]
apply Nat.rec
· simp only [Nat.zero_eq, map_zero]
simp (config := { contextual := true }) [Nat.succ_eq_add_one, h]
simp
rw [map_add, h1, eq_nat_cast' n, Nat.cast_add_one]
simp
rw [Nat.cast_add, map_add, Nat.cast_add, map_nat_cast', Nat.cast_one, h, Nat.cast_one]
simp only [map_one]
apply NeZero.of_map f
simp only [map_nat_cast, hn]
induction n <;> simp [*]
induction n <;> simp [*]
simp [bit0_eq_two_mul n]
rw [e] at h <;> exact not_le_of_lt (Nat.bit1_lt h.1) h.2
rw [bit0_eq_two_mul]
refine' fun e => absurd ((Nat.dvd_add_iff_right _).2 (dvd_trans ⟨_, e⟩ (Nat.min_fac_dvd _))) _ <;>
    simp
refine' ⟨zero_lt_one, lt_of_le_of_ne _ min_fac_ne_bit0.symm⟩
rw [Nat.succ_le_iff]
refine' lt_of_le_of_ne (Nat.min_fac_pos _) fun e => Nat.not_prime_one _
rw [e]
exact Nat.min_fac_prime (Nat.bit1_lt h).ne'
rw [← e]
refine'
    ⟨Nat.succ_pos _,
      (lt_of_le_of_ne (lt_of_le_of_ne _ _ : k + 1 + k < _) min_fac_ne_bit0.symm : bit0 (k + 1) < _)⟩
· rw [add_right_comm]
    exact h.2
· rw [add_right_comm]
    exact np.symm
refine' min_fac_helper_1 e _ h
intro e₁
rw [← e₁] at np
exact np (Nat.min_fac_prime <| ne_of_gt <| Nat.bit1_lt h.n_pos)
refine' min_fac_helper_1 e _ h
refine' mt _ (ne_of_gt c0)
intro e₁
rw [← nc, ← Nat.dvd_iff_mod_eq_zero, ← e₁]
apply Nat.min_fac_dvd
rw [← Nat.dvd_iff_mod_eq_zero] at hd
exact le_antisymm (Nat.min_fac_le_of_dvd (Nat.bit1_lt h.1) hd) h.2
refine' (Nat.prime_def_min_fac.1 (Nat.prime_def_le_sqrt.2 ⟨Nat.bit1_lt h.n_pos, _⟩)).2
rw [← e] at hd
intro m m2 hm md
have := le_trans h.2 (le_trans (Nat.min_fac_le_of_dvd m2 md) hm)
rw [Nat.le_sqrt] at this
exact not_le_of_lt hd this
rw [List.prod_cons, f₃, h₁]
cases b <;> simp [Nat.bit0_eq_zero, Nat.bit1_ne_zero]
rw [← h (i + 1), test_bit_succ]
simp [test_bit]
revert h
cases b <;> simp
rw [test_bit_zero]
rw [test_bit_succ, hk]
decide
rw [test_bit, shiftr_eq_div_pow, Nat.div_self (pow_pos zero_lt_two n), bodd_one]
simp [lxor]
simp [lxor]
simp [land]
simp [land]
simp [lor]
simp [lor]
simp
rw [lxor_assoc, lxor_self, lxor_zero]
rw [← lxor_assoc, lxor_self, zero_lxor]
rw [← lxor_cancel_left n m, ← lxor_cancel_left n m', h]
rw [← lxor_cancel_right n m, ← lxor_cancel_right n m', h]
rw [← lxor_self n, lxor_right_inj, eq_comm]
simp [hv, ← lxor_assoc]
  -- If `i` is the position of the most significant bit of `v`, then at least one of `a`, `b`, `c`
  -- has a one bit at position `i`.
simp [h, hi]
simp [hi' _ hj]
rw [log, ite_eq_right_iff]
simp only [Nat.succ_ne_zero, imp_false, Decidable.not_and_distrib, not_le, not_lt]
rw [pos_iff_ne_zero, Ne.def, log_eq_zero_iff, not_or, not_lt, not_le]
rw [log]
exact if_pos ⟨hn, h⟩
rw [log_eq_iff (Or.inl one_ne_zero), pow_add, pow_one]
rw [log_zero_right, pow_zero]
rw [div_lt_iff_lt_mul (zero_lt_one.trans hb), ← succ_le_iff, ← pred_eq_sub_one,
    succ_pred_eq_of_pos (add_pos (zero_lt_one.trans hn) (zero_lt_one.trans hb))]
exact add_le_mul hn hb
rw [clog, if_neg fun h : 1 < b ∧ 1 < n => h.1.not_le hb]
rw [clog, if_neg fun h : 1 < b ∧ 1 < n => h.2.not_le hn]
rw [clog, if_pos (⟨hb, hn⟩ : 1 < b ∧ 1 < n)]
rw [clog_of_two_le hb hn]
exact zero_lt_succ _
rw [clog_of_two_le (hn.trans h) hn, clog_of_right_le_one]
have n_pos : 0 < n := zero_lt_two.trans_le hn
rw [← lt_succ_iff, Nat.div_lt_iff_lt_mul (n_pos.trans_le h), ← succ_le_iff, ← pred_eq_sub_one,
    succ_pred_eq_of_pos (add_pos n_pos (n_pos.trans_le h)), succ_mul, one_mul]
exact add_le_add_right h _
rw [← le_pow_iff_clog_le hb]
exact (pow_right_strict_mono hb).le_iff_le
rw [← not_le, le_pow_iff_clog_le hb, not_le]
exact pred_lt (clog_pos hb hx).ne'
rw [← le_pow_iff_clog_le (lt_of_lt_of_le hc hb)]
calc
    n ≤ c ^ clog c n := le_pow_clog hc _
    _ ≤ b ^ clog c n := pow_le_pow_of_le_left (zero_lt_one.trans hc).le hb _
simp [pow_factors_to_finset p hk, factors_prime hp]
unfold bodd div2 <;> cases bodd_div2 n <;> rfl
subst h
subst h
subst h
subst h
rw [Nat.mod_two_of_bodd]
simp
rw [Nat.mod_two_of_bodd]
simp
cases n
cases h
apply succ_pos
rw [bodd_bit, div2_bit]
simp [h]
rw [h', h h']
exact z₁
simp [Nat.bits]
simp only [forall_const, gcd_add_self_right, eq_self_iff_true, periodic]
simp only [coprime_add_self_right, forall_const, iff_self_iff, eq_iff_iff, periodic]
simp only [forall_const, eq_self_iff_true, add_mod_right, periodic]
rw [count_eq_card_filter_range, Finset.card, Finset.filter_val, Finset.range_coe, ←
    multiset_Ico_map_mod n, ← map_count_true_eq_filter_card, ← map_count_true_eq_filter_card,
    map_map, Function.comp]
simp only [pp.map_mod_nat]
rw [Finset.mem_mk, Multiset.mem_coe, List.mem_range']
cases le_or_lt a b
· rw [add_tsub_cancel_of_le (Nat.lt_succ_of_le h).le, Nat.lt_succ_iff]
· rw [tsub_eq_zero_iff_le.2 (succ_le_of_lt h), add_zero]
      exact iff_of_false (fun hx => hx.2.not_le hx.1) fun hx => h.not_le (hx.1.trans hx.2)
rw [Finset.mem_mk, Multiset.mem_coe, List.mem_range']
cases le_or_lt a b
· rw [add_tsub_cancel_of_le h]
· rw [tsub_eq_zero_iff_le.2 h.le, add_zero]
      exact iff_of_false (fun hx => hx.2.not_le hx.1) fun hx => h.not_le (hx.1.trans hx.2.le)
rw [Finset.mem_mk, Multiset.mem_coe, List.mem_range']
cases le_or_lt a b
· rw [← succ_sub_succ, add_tsub_cancel_of_le (succ_le_succ h), Nat.lt_succ_iff, Nat.succ_le_iff]
· rw [tsub_eq_zero_iff_le.2 h.le, add_zero]
      exact iff_of_false (fun hx => hx.2.not_le hx.1) fun hx => h.not_le (hx.1.le.trans hx.2)
rw [Finset.mem_mk, Multiset.mem_coe, List.mem_range', ← tsub_add_eq_tsub_tsub]
cases le_or_lt (a + 1) b
· rw [add_tsub_cancel_of_le h, Nat.succ_le_iff]
· rw [tsub_eq_zero_iff_le.2 h.le, add_zero]
      exact iff_of_false (fun hx => hx.2.not_le hx.1) fun hx => h.not_le (hx.1.trans hx.2)
rw [← bot_eq_zero, ← Iio_eq_Ico, Iio_eq_range]
rw [Iic_eq_Icc, card_Icc, bot_eq_zero, tsub_zero]
rw [Iio_eq_Ico, card_Ico, bot_eq_zero, tsub_zero]
rw [Fintype.card_of_finset, card_Icc]
rw [Fintype.card_of_finset, card_Ico]
rw [Fintype.card_of_finset, card_Ioc]
rw [Fintype.card_of_finset, card_Ioo]
rw [Fintype.card_of_finset, card_Iic]
rw [Fintype.card_of_finset, card_Iio]
rw [Ico_succ_right, Icc_self]
rw [← Icc_pred_right _ h, Icc_self]
rw [← Nat.Icc_succ_left, Icc_self]
rw [Ico_succ_right, ← Ico_insert_right h]
rw [Ico_succ_left, ← Ioo_insert_left h]
contradiction
cases n <;> rfl
rw [sub_eq_psub, psub] <;> cases psub m n <;> rfl
constructor <;> intro h <;> contradiction
dsimp <;> constructor <;> intro h <;> injection h <;> subst n
simp
dsimp <;> constructor <;> contradiction
simp [eq_comm]
dsimp
apply option.bind_eq_some.trans
simp [psub_eq_some, add_comm, add_left_comm, Nat.succ_eq_add_one]
induction k <;> simp [*, add_succ, bind_assoc]
rw [modeq, zero_mod, dvd_iff_mod_eq_zero]
rw [modeq, eq_comm, ← Int.coe_nat_inj', Int.coe_nat_mod, Int.coe_nat_mod,
    Int.emod_eq_emod_iff_emod_sub_eq_zero, Int.dvd_iff_emod_eq_zero]
rw [modeq_iff_dvd, ← Int.coe_nat_dvd, Int.ofNat_sub h]
unfold modeq at * <;> rw [mul_mod_mul_left, mul_mod_mul_left, h]
rw [mul_comm a, mul_comm b, mul_comm n] <;> exact h.mul_left' c
rw [mul_comm a, mul_comm b] <;> exact h.mul_left c
rw [modeq_iff_dvd, Int.ofNat_add, Int.ofNat_add, add_sub_add_comm]
exact dvd_add h₁.dvd h₂.dvd
rw [add_comm a, add_comm b] at h₂
exact h₁.add_left_cancel h₂
simp [hc]
simp [hc]
rw [modeq_iff_dvd] at *
exact (dvd_mul_left (n : ℤ) (m : ℤ)).trans h
rw [Int.ofNat_sub h]
rw [Nat.Modeq, Nat.mod_zero, Nat.mod_zero]
rw [Nat.Modeq, Nat.add_mod_left]
rw [Nat.Modeq, Nat.add_mod_right]
have h1 := gcd_dvd_right a m
have h2 := gcd_dvd_right b m
exact
    dvd_antisymm (dvd_gcd ((dvd_iff_of_modeq_of_dvd h h1).mp (gcd_dvd_left a m)) h1)
      (dvd_gcd ((dvd_iff_of_modeq_of_dvd h h2).mpr (gcd_dvd_left b m)) h2)
apply Int.ofNat.inj
rw [eq_comm, ← sub_eq_zero]
exact Int.eq_zero_of_abs_lt_dvd (modeq_iff_dvd.mp h) h2
let d := gcd m c
have hmd := gcd_dvd_left m c
have hcd := gcd_dvd_right m c
rw [modeq_iff_dvd]
refine' Int.dvd_of_dvd_mul_right_of_gcd_one _ _
show (m / d : ℤ)
rw [hn, gcd_zero_left] at h
constructor
rfl
exact h
rw [hm, gcd_zero_right] at h
constructor
exact h.symm
rfl
dsimp only [chinese_remainder']
rw [dif_neg hn, dif_neg hm, Subtype.coe_mk, xgcd_val, ← Int.toNat_coe_nat (lcm n m)]
have lcm_pos := int.coe_nat_pos.mpr (Nat.pos_of_ne_zero (lcm_ne_zero hn hm))
exact (Int.to_nat_lt_to_nat lcm_pos).mpr (Int.emod_lt_of_pos _ lcm_pos)
rw [Nat.modeq_iff_dvd, Nat.modeq_iff_dvd, ← Int.dvd_natAbs, Int.coe_nat_dvd, ← Int.dvd_natAbs,
      Int.coe_nat_dvd] at h
rw [Nat.modeq_iff_dvd, ← Int.dvd_natAbs, Int.coe_nat_dvd]
exact hmn.mul_dvd_of_dvd_of_dvd h.1 h.2
rw [zero_mul]
simp [hb0]
rw [← @add_right_cancel_iff _ _ _ (c * (a / b / c)), mod_add_div, Nat.div_div_eq_div_mul, ←
      mul_right_inj' hb0, ← @add_left_cancel_iff _ _ _ (a % b), mod_add_div, mul_add, ←
      @add_left_cancel_iff _ _ _ (a % (b * c) % b), add_left_comm, ← add_assoc (a % (b * c) % b),
      mod_add_div, ← mul_assoc, mod_add_div, mod_mul_right_mod]
simp [hc0]
rw [mul_two] <;>
              exact
                add_lt_add (Nat.mod_lt _ (Nat.pos_of_ne_zero hc0))
                  (Nat.mod_lt _ (Nat.pos_of_ne_zero hc0))
rw [← add_mod_add_ite, if_neg (not_le_of_lt hc), add_zero]
rw [← add_mod_add_ite, if_pos hc]
simp [hc0]
rw [add_div (Nat.pos_of_ne_zero hc0), if_neg (not_le_of_lt hc), add_zero]
simp [h]
rw [Nat.mod_eq_zero_of_dvd hca, zero_add]
exact Nat.mod_lt _ (pos_iff_ne_zero.mpr h)
rw [add_div hc0, if_pos hc]
simp [hc0]
rw [Nat.add_div (Nat.pos_of_ne_zero hc0)] <;> exact Nat.le_add_right _ _
have : (a + b) % c = a % c + b % c := add_mod_of_add_mod_lt (lt_of_not_ge hc)
simp_all [dvd_iff_mod_eq_zero]
simp_all
simp_all
rw [mul_add, two_mul_odd_div_two hm1, mul_left_comm, two_mul_odd_div_two hn1,
      two_mul_odd_div_two (Nat.odd_mul_odd hm1 hn1), mul_tsub, mul_one, ←
      add_tsub_assoc_of_le (succ_le_of_lt hm0),
      tsub_add_cancel_of_le (le_mul_of_one_le_right (Nat.zero_le _) hn0)]
decide
simp [Nat.mod_eq_of_lt hml]
simp
simp
simp
simp
rw [← Option.some_inj, ← List.nth_le_nth]
conv => 
            lhs
            rw [← h (List.length (a :: l) - n)]
rw [nth_rotate hn, add_tsub_cancel_of_le (le_of_lt hn), Nat.mod_self, nth_le_repeat]
rfl
simp
rw [List.length_repeat] <;> exact Nat.mod_lt _ (Nat.succ_pos _)
rw [length_repeat]
simp
simp [Ico, hp.multiplicity_one]
rw [factorial_succ, hp.multiplicity_mul, add_comm]
rw [multiplicity_factorial ((log_mono_right <| le_succ _).trans_lt hb), ←
          multiplicity_eq_card_pow_dvd hp.ne_one (succ_pos _) hb]
rw [sum_add_distrib, sum_boole]
simp
rw [Ne.def, eq_top_iff_not_finite, not_not, finite_nat_iff]
exact ⟨hp.ne_one, factorial_pos _⟩
intro m hm
rw [multiplicity_eq_zero, ← not_dvd_iff_between_consec_multiples _ hp.pos]
rw [mem_Ico] at hm
exact ⟨n, lt_of_succ_le hm.1, hm.2⟩
rw [← PartEnat.coe_le_coe, ← hp.multiplicity_factorial hbn, ← pow_dvd_iff_le_multiplicity]
rw [hp.multiplicity_factorial (lt_succ_self _), PartEnat.coe_le_coe]
exact Nat.geom_sum_Ico_le hp.two_le _ _
simp only [add_tsub_cancel_of_le hkn]
simp only [Nat.add_div (pow_pos hp.pos _)]
simp [sum_add_distrib, sum_boole]
rw [← hp.multiplicity_mul, ← mul_assoc, choose_mul_factorial_mul_factorial hkn,
      hp.multiplicity_factorial hnb, hp.multiplicity_mul,
      hp.multiplicity_factorial ((log_mono_right hkn).trans_lt hnb),
      hp.multiplicity_factorial (lt_of_le_of_lt (log_mono_right tsub_le_self) hnb),
      multiplicity_choose_aux hp hkn]
simp [add_comm]
simp
simp
rw [← hp.multiplicity_mul]
refine' multiplicity_le_multiplicity_of_dvd_right _
rw [← succ_mul_choose_eq]
exact dvd_mul_right _ _
simp (config := { contextual := true }) [disjoint_right, *, dvd_iff_mod_eq_zero,
          Nat.mod_lt _ (pow_pos hp.pos _)]
rw [← hp.multiplicity_pow_self] <;> exact multiplicity_le_multiplicity_choose_add hp _ _
have h2 := prime_iff.mp prime_two
refine' binary_rec _ _
· contradiction
· intro b n ih h
cases a
· exact isMin_bot
· exact (not_succ_le_self _ ha).elim
cases b
· exact (a.not_lt_zero h).elim
· exact le_of_succ_le_succ h
cases a
· exact b.zero_le
· exact h
rw [Function.iterate_succ', add_succ]
exact congr_arg _ n.succ_iterate
rw [Function.iterate_succ', sub_succ]
exact congr_arg _ n.pred_iterate
rw [succ_eq_succ, succ_iterate, add_tsub_cancel_of_le h]
rw [pred_eq_pred, pred_iterate, tsub_tsub_cancel_of_le h]
simp only [← some_eq_coe]
exact PartEnat.cases_on'
rw [add_comm, top_add]
rw [← some_eq_coe]
exact Part.ext' (iff_of_true trivial h) fun _ _ => rfl
rw [← coe_inj, coe_get]
simp only [← some_eq_coe] at h⊢
rfl
rw [get_eq_iff_eq_some, some_eq_coe]
rw [← some_eq_coe] at h
exact dom_of_le_some h
dsimp [(· ≤ ·)]
simp only [hx, exists_prop_of_true, forall_true_iff]
rw [← some_eq_coe, ← some_eq_coe]
exact ⟨fun ⟨_, h⟩ => h trivial, fun h => ⟨fun _ => trivial, fun _ => h⟩⟩
rw [lt_iff_le_not_le, lt_iff_le_not_le, coe_le_coe, coe_le_coe]
conv => 
    lhs
    rw [← coe_le_coe, coe_get, coe_get]
rw [← some_eq_coe]
show (∃ h : True → x.dom, _) ↔ ∃ h : x.dom, x.get h ≤ n
simp only [forall_prop_of_true, some_eq_coe, dom_coe, get_coe']
simp only [lt_def, forall_prop_of_true, get_coe', dom_coe]
rw [← some_eq_coe]
simp only [le_def, exists_prop_of_true, dom_some, forall_true_iff]
rfl
rw [← some_eq_coe]
simp only [lt_def, exists_prop_of_true, dom_some, forall_true_iff]
rfl
decide
simp only [iff_true_iff, le_top, coe_lt_top, ← @Nat.cast_zero PartEnat]
rw [← Nat.cast_zero, ← Nat.cast_one, PartEnat.coe_lt_coe, PartEnat.coe_le_coe]
rfl
simp
rw [← Nat.cast_add, coe_inj, add_comm, tsub_add_cancel_of_le (coe_le_coe.1 h)]
rw [add_comm z, add_comm z, PartEnat.add_lt_add_iff_right hz]
apply PartEnat.cases_on a <;> apply PartEnat.cases_on b <;> simp <;>
      simp only [(Nat.cast_add _ _).symm, PartEnat.coe_ne_top] <;>
    simp
rw [add_comm a, add_comm a, PartEnat.add_right_cancel_iff ha]
simp only [← some_eq_coe, ← to_with_top_some]
simp
simp
intros <;> simp
apply PartEnat.cases_on y <;> apply PartEnat.cases_on x <;> simp [← Nat.cast_add, ← Enat.coe_add]
apply PartEnat.cases_on x <;> intros <;> simp <;> rfl
cases x <;> simp [with_top_equiv._match_1] <;> rfl
rw [← with_top_equiv_le] <;> simp
rw [← with_top_equiv_lt] <;> simp
refine' ⟨_, lt_find P n⟩
intro h m hm
rw [le_coe_iff]
refine' ⟨⟨_, h⟩, @Nat.find_min' P _ _ _ h⟩
rw [Nat.succ_eq_add_one, Nat.add_comm, Nat.right_distrib, Nat.one_mul]
rw [mul_comm n m, mul_comm k m] at H <;> exact Nat.eq_of_mul_eq_mul_left Hm H
rw [Nat.succ_eq_add_one, Nat.add_comm]
simp [add_comm]
rw [succ_le_iff]
simp only [add_comm, lt_succ_iff]
simp only [add_comm, add_one_le_iff]
rw [← lt_succ_iff, div_lt_iff_lt_mul n0, succ_mul, mul_comm]
cases n
· cases n0
exact lt_succ_iff
decide
simp only [lt_succ_iff, Decidable.le_iff_eq_or_lt, forall_eq_or_imp, and_comm]
simp
simp
simp [hk, add_comm, add_left_comm]
simp
simp [hk]
rw [add_succ, succ_sub_one]
rw [succ_add, succ_sub_one]
simp [H]
rw [← Nat.sub_one, Nat.sub_sub, one_add, sub_succ]
rw [add_comm, add_one, pred_succ]
rw [add_comm, add_mul_mod_self_left, mul_mod_right, mod_eq_of_lt] <;> simp
rw [mul_comm, Nat.mul_right_eq_self_iff hb]
cases n <;> unfold le_rec_on Or
rw [le_rec_on_succ (le_refl n), le_rec_on_self]
rw [Subsingleton.elim h1 (le_trans (le_succ n) h2), le_rec_on_trans (le_succ n) h2,
    le_rec_on_succ']
simp only [strong_rec_on']
rw [Nat.strongRec']
apply Nat.le.ndrec h0 <;> exact h1
dsimp only [decreasing_induction]
rw [le_rec_on_self]
dsimp only [decreasing_induction]
rw [le_rec_on_succ]
dsimp only [decreasing_induction]
rw [le_rec_on_succ']
rw [Subsingleton.elim mn (le_trans (le_succ m) smn), decreasing_induction_trans,
    decreasing_induction_succ']
refine' le_rec_on' mn _ _ h hP <;>
    clear h hP mn n
rw [le_div_iff_mul_le hb, one_mul]
simp [k0]
simp [hc0]
rw [mul_assoc] <;> exact Nat.mul_le_mul_left _ (Nat.div_mul_le_self _ _)
rw [← H2, Nat.mul_div_cancel' H1]
rw [mul_comm] <;> exact Nat.div_eq_iff_eq_mul_right H H'
rw [mul_comm, Nat.eq_mul_of_div_eq_right H1 H2]
rw [mul_comm, Nat.div_mul_cancel Hd]
rw [mul_comm, mul_comm b, a.mul_div_mul_left b hc]
rw [← Nat.succ_mul, ← Nat.div_lt_iff_lt_mul hb]
exact Nat.lt_succ_self _
refine' ⟨fun h => _, congr_arg _⟩
rw [← Nat.mul_div_cancel' hda, ← Nat.mul_div_cancel' hdb, h]
cases b
contradiction
exact ⟨fun h => h.ge.trans_lt (mod_lt _ (succ_pos _)), mod_eq_of_lt⟩
rw [mul_comm]
exact mod_add_div _ _
rw [mul_comm]
exact div_add_mod _ _
rw [add_mul_div_left _ _ h, add_mul_mod_self_left] <;> simp [div_eq_of_lt, mod_eq_of_lt, h₂]
rw [mul_assoc, mul_right_inj' ha.ne']
rw [mul_right_comm, mul_left_inj' hc.ne']
simp [n0]
rw [add_comm, mod_add_mod, add_comm]
rw [add_mod_mod, mod_add_mod]
rw [← mod_add_mod, ← mod_add_mod k, H]
rw [add_comm, add_mod_eq_add_mod_right _ H, add_comm]
rw [← Nat.div_mul_cancel w, h, one_mul]
rw [← Nat.div_mul_cancel w, h, zero_mul]
rw [mul_comm, ← Nat.div_lt_iff_lt_mul' n0]
exact lt_succ_self _
simp [Nat.add_mod]
rw [Nat.mul_add_mod, Nat.mod_eq_of_lt h]
cases n <;> simp [(Nat.succ_ne_self _).symm]
simp only [exists_prop, ← lt_succ_iff, find_lt_iff]
simp only [← succ_le_iff, le_find_iff, succ_le_succ_iff]
simp [find_eq_iff]
simp [Nat.findGreatest, h]
simp [Nat.findGreatest, h]
decide
simp
simp only [lt_succ_iff_lt_or_eq, or_and_right, exists_or, exists_eq_left]
decide
decide
rw [sqrt_aux] <;> simp
rw [sqrt_aux] <;> simp only [h, h₂.symm, Int.ofNat_add, if_false] <;>
    rw [add_comm _ (n' : ℤ), add_sub_cancel, sqrt_aux._match_1]
rw [tsub_lt_iff_right h₁]
simp [left_distrib, right_distrib, two_mul, mul_comm, mul_assoc, add_comm, add_assoc,
      add_left_comm]
decide
decide
simp [pow_succ, mul_comm, mul_left_comm]
decide
generalize div2 s = x
change bit0 x with x + x
rw [one_shiftl, pow_add]
decide
rw [← succ_mul] <;> exact le_of_lt_succ (lt_succ_sqrt n)
rw [sqrt, size_zero, sqrt._match_1]
decide
decide
rw [succ_mul, mul_succ, add_succ, add_assoc] <;>
          exact lt_succ_of_le (Nat.add_le_add_left h _)
refine' add_le_add (Nat.mul_le_mul_right _ _) _ <;> exact Nat.le_add_right _ 2
rw [← hn, sqrt_eq]
rw [nth]
simp
simp [nth_zero, h]
refine' hp.subset fun x hx => _
rw [Set.mem_setOf_eq] at hx
exact hx.left
rw [nth]
apply Inf_mem
exact nth_set_nonempty_of_lt_card _ _ hlt
rw [nth, Inf_eq_zero] at ha⊢
cases ha
· exact (h₀ ha.1).elim
· refine' Or.inr (Set.eq_empty_of_subset_empty fun x hx => _)
    rw [← ha]
    exact ⟨hx.1, fun k hk => hx.2 k <| hk.trans_le hab⟩
rw [tsub_add_cancel_iff_le]
exact succ_le_of_lt (pos_of_gt (nth_strict_mono p hi (lt_add_one k)))
simp
decide
decide
decide
decide
decide
rw [← h]
exact not_prime_mul h₁ h₂
simp only [iff_self_iff, irreducible_mul_iff, ← irreducible_iff_nat_prime, Nat.isUnit_iff]
decide
simp
decide
rfl
rw [min_fac_aux]
decide
simp [e, left_distrib]
decide
decide
simp [n1]
decide
decide
decide
decide
rw [mul_one] at h1
rw [prime_def_min_fac, not_and_or, ← h1, eq_self_iff_true, not_true, or_false_iff, not_le] at np
rw [le_antisymm (le_of_lt_succ np) (succ_le_of_lt Pos), min_fac_one, Nat.div_one]
decide
constructor
· intro h
decide
rw [even_iff_two_dvd, prime_dvd_prime_iff_eq prime_two hp, eq_comm]
rw [coprime_iff_gcd_eq_one]
decide
decide
simp [d]
simp [Hm, Hn]
rw [h.1, h.2, pow_one]
rw [pow_min_fac hk, hp.min_fac_eq]
rw [h] <;> simp [sq]
    -- Could be `wlog := hp.dvd_mul.1 pdvdxy using x y`, but that imports more than we want.
rw [h]
rw [pp.dvd_iff_not_coprime] <;> apply em
simp [Nat.not_prime_one]
let a := n + 2
let ha : a ≠ 1 := Nat.succ_succ_ne_one n
simp only [true_iff_iff, Ne.def, not_false_iff, ha]
exact ⟨a.min_fac, Nat.min_fac_prime ha, a.min_fac_dvd⟩
rw [this]
apply measure_wf
decide
decide
decide
simp (config := { contextual := true }) [or_imp]
rw [eq_comm, Nat.mul_eq_zero]
simp
simp
simp
rw [add_comm]
exact add_pos_left h m
cases n <;> simp [succ_eq_add_one, ← add_assoc, succ_inj']
cases n <;> simp [(succ_ne_zero 1).symm, succ_eq_add_one, ← add_assoc, succ_inj', add_eq_one_iff]
cases n <;> simp [(succ_ne_zero 1).symm, succ_eq_add_one, ← add_assoc, succ_inj', add_eq_two_iff]
rw [add_assoc]
exact add_lt_add_of_lt_of_le hab (Nat.succ_le_iff.2 hcd)
cases m
· exact fun _ => zero_le n
exact le_of_succ_le_succ
decide
decide
decide
simp
simp
simp only [add_mul, mul_add, mul_add, one_mul, mul_one, (add_assoc _ _ _).symm, Nat.succ_inj',
          add_eq_zero_iff] at h <;>
        simp [h.1.2, h.2]
simp only [h, mul_one]
simp
decide
decide
refine' le_trans _ add_tsub_le_assoc
simp [add_comm, Nat.add_sub_assoc, one_le_iff_ne_zero.2 hi]
rw [k0, Nat.div_zero] <;> apply zero_le
rw [n0, Nat.div_zero] <;> apply zero_le
decide
simp [hm0]
rw [mul_comm] <;> exact mul_div_le_mul_div_assoc _ _ _
rw [Nat.div_div_eq_div_mul, mul_comm n, mul_comm k,
          Nat.mul_div_mul _ _ (Nat.pos_of_ne_zero hm0)]
rw [Nat.le_div_iff_mul_le two_pos]
rw [Nat.div_lt_iff_lt_mul two_pos, Nat.mul_sub_right_distrib, lt_tsub_iff_right, mul_two a] at h
exact le_of_lt (Nat.lt_of_add_lt_add_left h)
rw [Nat.le_div_iff_mul_le two_pos, Nat.mul_sub_right_distrib, tsub_le_iff_right, mul_two,
    add_le_add_iff_left] at h
rw [← Nat.mul_div_left b two_pos]
exact Nat.div_le_div_right h
conv => 
    rhs
    rw [← Nat.mod_add_div n 2, hn, add_tsub_cancel_left]
rw [mul_comm k, mod_mul_right_div_self]
rw [← Nat.mod_add_div m k, ← Nat.mod_add_div n k, ← h, tsub_add_eq_tsub_tsub,
    add_tsub_cancel_left, ← mul_tsub, Nat.mul_mod_right]
simp [hn]
simp [hl]
simp
decide
rw [pos_iff_ne_zero, Ne, Nat.find_eq_zero]
simp [find_greatest_eq_iff]
constructor
· intro h
    rw [← mul_right_inj' hn]
    apply Nat.eq_mul_of_div_eq_left (dvd_mul_of_dvd_left hy x)
    rw [eq_comm, mul_comm, Nat.mul_div_assoc _ hy]
    exact Nat.eq_mul_of_div_eq_right hx h
· intro h
    rw [h]
rw [← mod_add_div a b, h, mul_zero, add_zero] <;> exact mod_lt _ hb
rw [← mul_right_inj' hb.ne', ← @add_left_cancel_iff _ _ _ (a % b), mod_add_div, mod_eq_of_lt h,
      mul_zero, add_zero]
simp
simp
decide
rw [Nat.dvd_add_iff_left (dvd_refl (b + 1)), ← add_tsub_add_eq_tsub_right a 1 b,
          add_comm (_ - _), add_assoc, tsub_add_cancel_of_le (succ_le_succ hb_le_a), add_comm 1]
rw [succ_div, if_pos hba]
rw [succ_div, if_neg hba, add_zero]
simp [ha]
simp
cases n
· exact (m % 0).div_zero
· exact Nat.div_eq_zero (m.mod_lt n.succ_pos)
refine'
    ⟨fun ⟨k, hk1, hk2⟩ => not_dvd_of_between_consec_multiples hk1 hk2, fun han =>
      ⟨n / a, ⟨lt_of_le_of_ne (mul_div_le n a) _, lt_mul_div_succ _ ha⟩⟩⟩
exact mt (Dvd.intro (n / a)) han
rw [h]
rw [h]
rw [Nat.lt_div_iff_mul_lt hdb]
exact lt_of_le_of_lt (mul_div_le a d) h
rw [UniqueFactorizationMonoid.squarefree_iff_nodup_normalized_factors h0, Nat.factors_eq]
simp
rw [squarefree_iff_nodup_factors hn, List.nodup_iff_count_le_one]
intro a
rw [factors_count_eq]
apply hn'
rw [Nat.add_sub_add_right]
exact Nat.min_fac_lemma n k h
subst e
contradiction
rw [min_sq_fac_aux]
decide
decide
simp [e, left_distrib]
decide
refine' fun dk => prime_def_min_fac.2 ⟨k2, le_antisymm (min_fac_le k0) _⟩
exact ih _ (min_fac_prime (ne_of_gt k2)) (dvd_trans (min_fac_dvd _) dk)
decide
decide
decide
have := min_sq_fac_has_prop n
rw [h] at this
exact this.1
have := min_sq_fac_has_prop n
rw [h] at this
exact this.2.1
decide
rw [Ne.def, Multiset.prod_eq_zero_iff]
simp only [exists_prop, id.def, exists_eq_right]
intro con
apply
          not_irreducible_zero
            (irreducible_of_normalized_factor 0 (Multiset.mem_dedup.1 (Multiset.mem_of_le hs Con)))
rw [Finset.sum_eq_multiset_sum, divisors_filter_squarefree h0, Multiset.map_map,
    Finset.sum_eq_multiset_sum]
simp_all
simp
simp only [squarefree_iff_prime_squarefree, ← sq, ← forall_and]
refine' ball_congr fun p hp => _
simp only [hmn.is_prime_pow_dvd_mul (hp.is_prime_pow.pow two_ne_zero), not_or]
decide
decide
decide
decide
subst e
refine' H (Nat.succ_pos _) fun p pp dp => _
refine' (squarefree_helper_0 k0 pp (ih p pp dp)).resolve_right fun hp => _
subst hp
cases hk pp dp
rw [← hn', Nat.mul_div_cancel _ k0']
refine' Nat.prime_def_min_fac.2 ⟨k2, le_antisymm (Nat.min_fac_le k0') _⟩
exact ih _ (Nat.min_fac_prime (ne_of_gt k2)) (dvd_trans (Nat.min_fac_dvd _) dk)
rw [Nat.dvd_iff_mod_eq_zero, hc]
exact ne_of_gt c0
decide
rw [← hb, ← ha]
exact fun H => ne_of_gt h₁ (Nat.isUnit_iff.1 <| H _ ⟨_, rfl⟩)
simp [totient]
simp [hn.ne', pos_of_gt hn]
decide
simp [totient]
decide
rw [totient, filter_Ico_card_eq_of_periodic, count_eq_card_filter_range]
exact periodic_coprime a
congr
rw [Ico_union_Ico_eq_Ico]
rw [add_assoc]
exact le_self_add
exact le_self_add
rw [filter_union, ← filter_coprime_Ico_eq_totient a (k + n % a + a * i)]
apply card_union_le
rw [← Zmod.card_units_eq_totient, even_iff_two_dvd, this]
exact order_of_dvd_card_univ
rw [← hb2]
apply gcd_dvd_right
rw [← pow_one p, totient_prime_pow hp] <;> simp
simp
simp
simp
rw [multiplicative_factorization φ (@totient_mul) totient_one hn]
apply Finsupp.prod_congr fun p hp => _
have h := zero_lt_iff.mpr (finsupp.mem_support_iff.mp hp)
rw [totient_prime_pow (prime_of_mem_factorization hp) h]
simp [hn]
rw [← cast_prod, cast_ne_zero, ← zero_lt_iff, ← prod_factorization_eq_prod_factors]
exact prod_pos fun p hp => pos_of_mem_factorization hp
apply mul_mul_mul_comm
      _ = a1 * a2 / (b1 * b2) * (c1 * c2)
congr 1
exact div_mul_div_comm h1 h2
intro p
simp only [support_factorization, List.mem_to_finset]
apply factors_subset_of_dvd h hb0
cases eq_empty_or_nonempty s
· subst h
    simp only [or_true_iff, eq_self_iff_true, iff_true_iff, Inf, HasInf.inf, mem_empty_iff_false,
      exists_false, dif_neg, not_false_iff]
· simp only [h.ne_empty, or_false_iff, Nat.Inf_def, h, Nat.find_eq_zero]
rw [infi_of_empty', Inf_empty]
rw [Nat.Inf_def h]
exact Nat.find_spec h
cases eq_empty_or_nonempty s
· subst h
    apply not_mem_empty
· rw [Nat.Inf_def h] at hm
    exact Nat.find_min h hm
rw [Nat.Inf_def ⟨m, hm⟩]
exact Nat.find_min' ⟨m, hm⟩ hm
rw [Sup_def hb] <;> revert a ha <;> exact @Nat.find_spec _ _ hb
    cSup_le
rw [Sup_def ⟨a, ha⟩] <;> exact Nat.find_min' _ ha
    le_cInf
rw [Inf_def hs] <;> exact hb (@Nat.find_spec (fun n => n ∈ s) _ _)
rw [Inf_def ⟨a, ha⟩] <;> exact Nat.find_min' _ ha
    cSup_empty
simp only [Sup_def, Set.mem_empty_iff_false, forall_const, forall_prop_of_false,
        not_false_iff, exists_const]
apply bot_unique (Nat.find_min' _ _)
trivial
simp [Nat.lt_succ_iff_lt_or_eq, supr_or, supr_sup_eq]
rw [← sup_supr_nat_succ]
simp
rw [← image_singleton, range_comp, ← image_union, zero_union_range_succ, image_univ]
rw [← add_assoc] <;> apply sqrt_le_add
rw [sqrt_add_eq]
exact add_le_add_left (le_of_not_gt h) _
let s := sqrt n
simp [unpair]
change sqrt n with s
rw [unpair]
simp
simp
rw [mkpair, add_sq, mul_one, two_mul, sq, add_assoc, add_assoc]
cases lt_or_le m n
· rw [if_pos h, max_eq_right h.le, add_lt_add_iff_left, add_assoc]
    exact h.trans_le (self_le_add_right n _)
· rw [if_neg h.not_lt, max_eq_left h, add_lt_add_iff_left, add_assoc, add_lt_add_iff_left]
    exact lt_succ_of_le h
rw [mkpair]
cases lt_or_le m n
· rw [if_pos h, max_eq_right h.le, min_eq_left h.le, sq]
· rw [if_neg h.not_lt, max_eq_left h, min_eq_right h, sq, add_assoc, add_le_add_iff_left]
    exact le_add_self
rw [sq, ← min_add_max, add_comm, add_le_add_iff_right]
exact le_mul_self _
simp [zero_lt_one]
decide
rw [← one_pow n]
exact Nat.pow_le_pow_of_le_left h n
decide
rw [← one_pow n]
exact pow_lt_pow_of_lt_left h₁ h₀
decide
decide
rw [pow_succ', ← mul_assoc, mul_lt_mul_right (zero_lt_one.trans q1)]
exact lt_mul_of_one_le_of_lt (nat.succ_le_iff.mpr a0) (Nat.lt_pow_self q1 n)
rw [sq, sq]
exact Nat.mul_self_sub_mul_self_eq a b
rw [le_div_iff_mul_le b_pos, mul_comm]
exact h₁
rw [pow_dvd_pow_iff_pow_le_pow (lt_of_succ_lt w), pow_le_iff_le_right w]
decide
rw [← pow_one p] <;> exact pow_dvd_of_le_of_pow_dvd hk hpk
rw [Nat.div_eq_iff_eq_mul_left (pow_pos hx n) (pow_dvd_pow _ h), pow_sub_mul_pow _ h]
rw [← pow_lt_iff_lt_right hp]
exact lt_of_le_of_lt (le_of_dvd hn.bot_lt h) (lt_pow_self (succ_le_iff.mp hp) n)
simp [← two_mul, hm]
simp [← two_mul, h]
rw [h, add_comm]
rw [even_iff, mod_two_ne_zero]
rw [odd_iff, mod_two_ne_one]
rw [not_odd_iff, even_iff]
rw [not_even_iff, odd_iff]
simp only [← Set.compl_setOf, is_compl_compl, odd_iff_not_even]
rw [even_iff.1 hm, odd_iff.1 (hm.add_odd hn)]
rw [odd_iff.1 hm, even_iff.1 (hm.add_odd hn)]
rw [add_comm, mod_two_add_succ_mod_two]
rw [even_add, even_iff_not_odd, even_iff_not_odd, not_iff_not]
simp [even_add]
simp [bit1, parity_simps]
simp [add_mod]
conv => 
    rhs
    rw [← tsub_add_cancel_of_le h, even_add]
rw [even_sub h, even_iff_not_odd, even_iff_not_odd, not_iff_not]
simp only [even_sub' h, *]
simp only [tsub_eq_zero_iff_le.mpr h, even_zero]
simp [not_or, parity_simps]
rw [even_iff_two_dvd, dvd_iff_mod_eq_zero, Nat.div_mod_eq_mod_mul_div, mul_comm]
rw [odd_iff_not_even, even_add, not_iff, odd_iff_not_even]
rw [add_comm, odd_add]
rw [odd_iff_not_even, even_sub h, not_iff, odd_iff_not_even]
rw [odd_iff_not_even, even_sub h, not_iff, not_iff_comm, odd_iff_not_even]
cases n
· exact even_zero
· rw [mul_comm]
    apply even_mul_succ_self
rw [← Nat.bit0_eq_bit0, bit0_eq_two_mul, two_mul_div_two_of_even (even_bit0 n)]
rw [← Nat.bit1_eq_bit1, bit1, bit0_eq_two_mul, Nat.two_mul_div_two_add_one_of_odd (odd_bit1 n)]
rw [bit0_eq_two_mul m, ← Nat.div_div_eq_div_mul, bit0_div_two]
rw [bit0_eq_two_mul, ← Nat.div_div_eq_div_mul, bit1_div_two]
rw [bit0_eq_two_mul n, bit0_eq_two_mul m, bit0_eq_two_mul (n % m), Nat.mul_mod_mul_left]
have h₁ := congr_arg bit1 (Nat.div_add_mod n m)
  -- `∀ m n : ℕ, bit0 m * n = bit0 (m * n)` seems to be missing...
rw [bit1_add, bit0_eq_two_mul, ← mul_assoc, ← bit0_eq_two_mul] at h₁
have h₂ := Nat.div_add_mod (bit1 n) (bit0 m)
rw [bit1_div_bit0] at h₂
exact add_left_cancel (h₂.trans h₁.symm)
decide
simp
rw [bit0, ← two_mul, iterate_mul, involutive_iff_iter_2_eq_id.1 hf, iterate_id]
rw [bit1, iterate_succ, hf.iterate_bit0, comp.left_id]
rw [← hb, ← ha2, ← pow_two]
exact sqrt_add_eq' _ hle
rw [digits_aux]
cases n
· cases w
· rw [digits_aux]
decide
rw [digits, digits_aux_def]
exact succ_pos n
decide
decide
simp [this]
simp [of_digits]
simp [of_digits]
simp
rw [h]
decide
decide
decide
rfl
decide
rw [of_digits_append, of_digits_digits, of_digits_digits]
conv => 
    congr
    skip
    rw [← of_digits_digits b' n]
rw [coe_int_of_digits]
apply of_digits_zmodeq' _ _ _ h
simp [of_digits, List.alternatingSum]
rw [← Int.coe_nat_dvd]
exact
    dvd_iff_dvd_of_dvd_sub (zmodeq_of_digits_digits b b' c (Int.modeq_iff_dvd.2 h).symm _).symm.Dvd
cases i <;> rfl
unfold tail drop
simp [nth, Nat.add_comm, Nat.add_left_comm]
unfold drop
rw [Nat.add_assoc]
simp only [drop, head, Nat.zero_add, Stream'.nth]
rw [← nth_zero_cons x s, h, nth_zero_cons]
rw [← nth_succ_cons n _ x, h, nth_succ_cons]
rw [nth_succ, tail_cons, h]
rw [tail_eq_drop]
rfl
rw [← Stream'.eta (map f s), tail_map, head_map]
rw [← Stream'.eta (map f (a::s)), map_eq]
rfl
rw [nth_map, h]
rw [← Stream'.eta (zip f s₁ s₂)]
rfl
apply Stream'.ext
intro n
cases n <;> rfl
rw [← Stream'.eta (iterate f a)]
rw [tail_iterate]
rfl
rw [nth_succ, tail_iterate]
rw [tail_iterate, tail_const]
exact ch
rw [corec_def, map_eq, head_iterate, tail_iterate]
rfl
rw [corec_def, map_id, iterate_id]
unfold unfolds
rw [corec_eq]
unfold interleave corec_on
rw [corec_eq]
dsimp
rw [corec_eq]
rfl
unfold interleave corec_on
rw [corec_eq]
rfl
rw [interleave_eq s₁ s₂]
rfl
rw [h, nth_interleave_left]
rw [h, nth_interleave_right]
unfold even
rw [corec_eq]
rfl
unfold even
rw [corec_eq]
rfl
rw [interleave_eq, even_cons_cons, tail_cons]
rw [h]
constructor
· rfl
· simp [odd_eq, odd_eq, tail_interleave, tail_even]
change nth (even s) (succ n) = nth s (succ (succ (2 * n)))
rw [nth_succ, nth_succ, tail_even, nth_even]
rfl
rw [odd_eq, nth_even]
rfl
rw [h, nth_even]
rw [h, nth_odd]
rw [List.cons_append, cons_append_stream, cons_append_stream, append_append_stream]
rw [cons_append_stream, List.map_cons, map_cons, cons_append_stream, map_append_stream]
rfl
rw [List.length_cons, add_one, drop_succ, cons_append_stream, tail_cons, drop_append_stream]
rw [cons_append_stream, nil_append_stream, Stream'.eta]
induction n generalizing s <;> simp [*]
rw [take_succ, add_one, List.nth, nth_take_succ]
rfl
rw [← nth_take_succ, ← nth_take_succ, h (succ (succ n))]
rw [cycle_eq]
exact mem_append_stream_left _ ainl
unfold tails <;> rw [corec_eq] <;> rfl
unfold inits_core corec_on
rw [corec_eq]
rfl
unfold inits
rw [inits_core_eq]
rfl
apply Stream'.ext
intro n
cases n
· rfl
· rw [nth_inits, nth_succ, tail_cons, nth_map, nth_inits]
    rfl
apply Stream'.ext
intro n
rw [nth_zip, nth_inits, nth_tails, nth_const, take_succ, cons_append_stream, append_take_drop,
    Stream'.eta]
apply Stream'.ext
intro n
cases n
rfl
rw [nth_succ]
rfl
unfold valid_finite <;> infer_instance
rw [add_sub_assoc]
apply le_add_of_nonneg_right
apply sub_nonneg_of_le
apply Int.ofNat_le_ofNat_of_le
exact C.prec_pos
decide
rw [max_eq_right] <;> simp [sub_eq_add_neg]
unfold valid_finite at * <;> rw [ss] <;> exact v
unfold valid_finite at * <;> rw [ss] <;> exact v
intro s n hs hns
have : s.nonempty ∧ BddAbove s := ⟨⟨n, hns⟩, hs⟩
rw [dif_pos this]
exact (greatest_of_bdd _ _ _).2.2 n hns
intro s n hs hns
have : s.nonempty ∧ BddAbove s := ⟨hs, ⟨n, hns⟩⟩
rw [dif_pos this]
exact hns (greatest_of_bdd _ (Classical.choose_spec this.2) _).2.1
intro s n hs hns
have : s.nonempty ∧ BddBelow s := ⟨⟨n, hns⟩, hs⟩
rw [dif_pos this]
exact (least_of_bdd _ _ _).2.2 n hns
intro s n hs hns
have : s.nonempty ∧ BddBelow s := ⟨hs, ⟨n, hns⟩⟩
rw [dif_pos this]
exact hns (least_of_bdd _ (Classical.choose_spec this.2) _).2.1
simp
simp [h]
simp
simp [h]
rw [neg_neg] <;> exact Helt
simp
intros
rfl
intros
rfl
rw [← cast_add, Nat.sub_add_cancel h]
cases h
rw [cast_succ, add_sub_cancel] <;> rfl
simp
erw [cast_zero, neg_zero]
erw [cast_of_nat, cast_neg_succ_of_nat] <;> rfl
erw [cast_of_nat, cast_neg_succ_of_nat, neg_neg]
unfold sub_nat_nat
cases e : n - m
· simp only [sub_nat_nat, cast_of_nat]
    simp [e, Nat.le_of_sub_eq_zero e]
·
    rw [sub_nat_nat, cast_neg_succ_of_nat, Nat.add_one, ← e,
      Nat.cast_sub <| _root_.le_of_lt <| Nat.lt_of_sub_eq_succ e, neg_sub]
cases n <;> rfl
simp [neg_of_nat_eq]
simp [← Int.ofNat_add]
erw [cast_sub_nat_nat, cast_coe_nat, cast_neg_succ_of_nat, sub_eq_add_neg]
erw [cast_sub_nat_nat, cast_coe_nat, cast_neg_succ_of_nat, sub_eq_iff_eq_add, add_assoc,
      eq_neg_add_iff_add_eq, ← Nat.cast_add, ← Nat.cast_add, Nat.add_comm]
rw [cast_neg_succ_of_nat, cast_neg_succ_of_nat, cast_neg_succ_of_nat, ← neg_add_rev, ←
        Nat.cast_add, Nat.add_right_comm m n 1, Nat.add_assoc, Nat.add_comm]
simp [Int.sub_eq_add_neg, sub_eq_add_neg]
rw [bit1, cast_add, cast_one, cast_bit0] <;> rfl
simp
simp
simp
simp <;> rfl
simp <;> rfl
simp
simp [add_mul, ih]
simp [sub_mul, ih]
simp
simp
rw [← sub_nonneg, ← cast_sub, cast_nonneg, sub_nonneg]
rw [← cast_zero, cast_le]
rw [← cast_zero, cast_lt]
rw [← cast_zero, cast_lt]
simp [abs_eq_max_neg]
rw [← Int.cast_one, ← Int.cast_neg, cast_le]
exact Int.le_sub_one_of_lt h
cases n
· simp
· simp only [Int.natAbs, Int.cast_negSucc, abs_neg, ← Nat.cast_succ, Nat.abs_cast]
simp [h1]
rw [← nat_abs_dvd, ← dvd_nat_abs, coe_nat_dvd] at w
rw [← nat_abs_eq_zero]
exact eq_zero_of_dvd_of_lt w h
apply sub_nat_nat_elim m n fun m n i => bodd i = xor m.bodd n.bodd <;> intros <;> simp <;>
      cases i.bodd <;>
    simp
cases n <;> simp <;> rfl
cases n <;> simp [Neg.neg, Int.coe_nat_eq, Int.neg, bodd, -of_nat_eq_coe]
cases bodd n <;> rfl
refine' Eq.trans _ (congr_arg neg_succ_of_nat n.bodd_add_div2)
dsimp [bodd]
cases Nat.bodd n <;> dsimp [cond, not, div2, Int.mul]
· change -[2 * Nat.div2 n+1] = _
      rw [zero_add]
· rw [zero_add, add_comm]
      rfl
cases b
apply (bit0_val n).trans (add_zero _).symm
apply bit1_val
rw [← bit_decomp n] <;> apply h
rw [bit_val, Nat.bit_val] <;> cases b <;> rfl
rw [bit_val, Nat.bit_val] <;> cases b <;> rfl
rw [bit_val] <;> simp <;> cases b <;> cases bodd n <;> rfl
simp
rw [bit_coe_nat] <;> apply Nat.test_bit_zero
rw [bit_neg_succ] <;> dsimp [test_bit] <;> rw [Nat.test_bit_zero] <;> clear test_bit_zero <;>
        cases b <;>
      rfl
rw [bit_coe_nat] <;> apply Nat.test_bit_succ
rw [bit_neg_succ] <;> dsimp [test_bit] <;> rw [Nat.test_bit_succ]
rw [← bitwise_or, bitwise_bit]
rw [← bitwise_and, bitwise_bit]
rw [← bitwise_diff, bitwise_bit]
rw [← bitwise_xor, bitwise_bit]
simp [lnot]
simp [lnot]
rw [← bitwise_or, test_bit_bitwise]
rw [← bitwise_and, test_bit_bitwise]
rw [← bitwise_diff, test_bit_bitwise]
rw [← bitwise_xor, test_bit_bitwise]
simp [lnot, test_bit]
simp [lnot, test_bit]
rw [← shiftl_neg, neg_neg]
cases n <;> rfl
cases n <;> rfl
rw [shiftr_coe_nat, shiftr_coe_nat, ← Int.ofNat_add, shiftr_coe_nat, Nat.shiftr_add]
rw [shiftr_neg_succ, shiftr_neg_succ, ← Int.ofNat_add, shiftr_neg_succ, Nat.shiftr_add]
rw [← Nat.shiftl_sub, add_tsub_cancel_left] <;> apply Nat.le_add_right
rw [add_assoc, Nat.shiftr_add, ← Nat.shiftl_sub, tsub_self] <;> rfl
rw [← Nat.shiftl'_sub, add_tsub_cancel_left] <;> apply Nat.le_add_right
rw [add_assoc, Nat.shiftr_add, ← Nat.shiftl'_sub, tsub_self] <;> rfl
rw [shiftr_coe_nat] <;> exact congr_arg coe (Nat.shiftr_eq_div_pow _ _)
decide
simp
cases le_total 1 r
· rw [log_of_one_le_right _ h, Nat.log_of_left_le_one hb, Int.ofNat_zero]
· rw [log_of_right_le_one _ h, Nat.clog_of_left_le_one hb, Int.ofNat_zero, neg_zero]
rw [log_of_right_le_one _ (hr.trans zero_le_one),
    Nat.clog_of_right_le_one ((nat.ceil_eq_zero.mpr <| inv_nonpos.2 hr).trans_le zero_le_one),
    Int.ofNat_zero, neg_zero]
rw [log_of_one_le_right _ le_rfl, Nat.floor_one, Nat.log_one_right, Int.ofNat_zero]
rw [← inv_inv r, clog_inv, neg_neg, inv_inv]
rw [log_inv, neg_neg]
rw [clog_inv, neg_neg]
simp
rw [← neg_log_inv_eq_clog, log_of_left_le_one hb, neg_zero]
rw [← neg_log_inv_eq_clog, ← neg_add', zpow_neg, inv_lt _ hr]
· exact lt_zpow_succ_log_self hb _
· exact zpow_pos_of_pos (nat.cast_pos.mpr <| zero_le_one.trans_lt hb) _
rw [clog_of_one_le_right _ le_rfl, Nat.ceil_one, Nat.clog_one_right, Int.ofNat_zero]
rw [← neg_log_inv_eq_clog, ← zpow_neg, log_zpow hb, neg_neg]
rw [← neg_log_inv_eq_clog, ← neg_log_inv_eq_clog, neg_le_neg_iff]
exact log_mono_right (inv_pos.mpr <| h₀.trans_le h) (inv_le_inv_of_le h₀ h)
change (Finset.map _ _).card = _
rw [Finset.card_map, Finset.card_range]
change (Finset.map _ _).card = _
rw [Finset.card_map, Finset.card_range]
change (Finset.map _ _).card = _
rw [Finset.card_map, Finset.card_range]
change (Finset.map _ _).card = _
rw [Finset.card_map, Finset.card_range]
rw [card_Icc, to_nat_sub_of_le h]
rw [card_Ico, to_nat_sub_of_le h]
rw [card_Ioc, to_nat_sub_of_le h]
rw [card_Ioo, sub_sub, to_nat_sub_of_le h]
rw [← card_Icc, Fintype.card_of_finset]
rw [← card_Ico, Fintype.card_of_finset]
rw [← card_Ioc, Fintype.card_of_finset]
rw [← card_Ioo, Fintype.card_of_finset]
rw [card_fintype_Icc, to_nat_sub_of_le h]
rw [card_fintype_Ico, to_nat_sub_of_le h]
rw [card_fintype_Ioc, to_nat_sub_of_le h]
rw [card_fintype_Ioo, sub_sub, to_nat_sub_of_le h]
unfold modeq Nat.Modeq <;> rw [← Int.ofNat_inj] <;> simp [coe_nat_mod]
rw [modeq, zero_mod, dvd_iff_mod_eq_zero]
rw [modeq, eq_comm] <;> simp [mod_eq_mod_iff_mod_sub_eq_zero, dvd_iff_mod_eq_zero]
rw [modeq_iff_dvd]
exact exists_congr fun t => sub_eq_iff_eq_add'
unfold modeq <;> simp [mul_mod_mul_of_pos hc, show _ = _ from h]
simp [hc.symm]
rw [mul_comm a, mul_comm b, mul_comm n] <;> exact h.mul_left' hc
rw [this]
exact dvd_sub h₂.dvd h₁.dvd
rw [add_comm a, add_comm b] at h₂
exact h₁.add_left_cancel h₂
rw [sub_eq_add_neg, sub_eq_add_neg]
exact h₁.add h₂.neg
rw [← neg_neg c, neg_mul, neg_mul _ b] <;>
      exact ((h.mul_left' <| neg_nonneg.2 hc).modeq_of_dvd (dvd_mul_left _ _)).neg
rw [mul_comm a, mul_comm b]
exact h.mul_left c
rw [modeq_iff_dvd] at * <;> exact (dvd_mul_left n m).trans h
rw [← add_zero ((a : ℤ) * _), Nat.gcd_eq_gcd_ab]
exact (dvd_mul_right _ _).zero_modeq_int.add_left _
rw [add_zero]
rw [← Nat.gcd_eq_gcd_ab, hgcd] <;> rfl
simp [modeq]
constructor <;> rw [← of_nat_eq_coe, of_nat_nat_abs_eq_of_nonneg hz1] <;> assumption
rw [← coe_nat_lt, to_nat_of_nonneg (sub_nonneg_of_le h1),
              to_nat_of_nonneg (sub_nonneg_of_le (le_of_lt (lt_of_le_of_lt h1 h2)))] <;>
            exact sub_lt_sub_right h2 _
rw [to_nat_of_nonneg (sub_nonneg_of_le h1), add_sub_cancel'_right]
simp only [mem_range_iff, and_imp]
simp only [mem_range_iff, and_imp, lt_add_one_iff]
rw [Function.iterate_succ', Int.ofNat_succ, ← add_assoc]
exact congr_arg _ (succ_iterate n)
rw [Function.iterate_succ', Int.ofNat_succ, ← sub_sub]
exact congr_arg _ (pred_iterate n)
rw [succ_eq_succ, succ_iterate, to_nat_sub_of_le h, ← add_sub_assoc, add_sub_cancel']
rw [pred_eq_pred, pred_iterate, to_nat_sub_of_le h, sub_sub_cancel]
simp
simp
simp
simp [m0] at ae <;> simp [ae, m0]
simp [ae.symm]
rw [e, Int.ofNat_mul]
rw [mul_comm, H']
change ↑a
rw [← abs_of_nonneg H1, ← abs_of_nonneg H2, abs_eq_nat_abs, abs_eq_nat_abs]
rw [coe_nat_dvd, coe_nat_dvd, coe_nat_inj']
apply Nat.dvd_antisymm
induction k
· apply Int.coe_nat_dvd.2
    apply pow_dvd_of_le_of_pow_dvd hmn
    apply Int.coe_nat_dvd.1 hdiv
change -[k+1] with -(↑(k + 1) : ℤ)
apply dvd_neg_of_dvd
apply Int.coe_nat_dvd.2
apply pow_dvd_of_le_of_pow_dvd hmn
apply Int.coe_nat_dvd.1
apply dvd_of_dvd_neg
exact hdiv
rw [← pow_one p] <;> exact pow_dvd_of_le_of_pow_dvd hk hpk
rw [Nat.succ_eq_add_one, Nat.add_comm, of_nat_add, Int.add_mul, of_nat_one, Int.one_mul]
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
simp only [not_le, iff_false_iff]
exact Int.negSucc_lt_zero n
simp only [not_lt, iff_false_iff]
rw [neg_succ, succ_pred]
rw [eq_neg_of_eq_neg (neg_succ (-a)).symm, neg_neg]
rw [neg_pred, pred_succ]
cases n
cases h
simp
rw [sub_eq_add_neg, ← Int.natAbs_neg b]
apply nat_abs_add_le
cases n <;> rfl
cases a <;> cases b <;>
    simp only [← Int.mul_def, Int.mul, nat_abs_neg_of_nat, eq_self_iff_true, Int.natAbs]
rw [← nat_abs_mul, h, nat_abs_of_nat]
rw [← Int.ofNat_mul, nat_abs_mul_self]
simp [neg_succ_of_nat_eq, sub_eq_neg_add]
rw [← Int.natAbs_eq_natAbs_iff, Int.natAbs_ofNat]
simp
simp
simp
rw [Nat.div_zero] <;> rfl
change (- -[m+1] : ℤ) with (m + 1 : ℤ) <;> rw [add_sub_cancel] <;> rfl
rw [sub_sub, add_comm] <;>
    exact
      match b, eq_succ_of_zero_lt bpos with
      | _, ⟨n, rfl⟩ => rfl
rw [Nat.mod_one] <;> rfl
rw [← sub_sub, neg_succ_of_nat_coe, sub_sub (n : ℤ)]
apply eq_neg_of_eq_neg
rw [neg_sub, sub_sub_self, add_right_comm]
exact @congr_arg ℕ ℤ _ _ (fun i => (i + 1 : ℤ)) (Nat.mod_add_div _ _).symm
rw [neg_mul_neg] <;> exact congr_arg of_nat (Nat.mod_add_div _ _)
rw [mod_zero, Int.div_zero] <;> rfl
rw [mul_comm]
exact mod_add_div _ _
rw [mul_comm]
exact div_add_mod _ _
rw [mul_neg, Int.div_neg, Int.div_neg] <;> apply congr_arg Neg.neg <;> apply this
rw [Int.ofNat_zero, mul_zero, Int.div_zero, Int.div_zero]
apply Nat.div_eq_of_lt_le
· refine' le_trans _ (Nat.le_add_right _ _)
          rw [← Nat.mul_div_mul _ _ m.succ_pos]
          apply Nat.div_mul_le_self
· change m.succ * n.succ ≤ _
          rw [mul_left_comm]
          apply Nat.mul_le_mul_left
          apply (Nat.div_lt_iff_lt_mul k.succ_pos).1
          apply Nat.lt_succ_self
rw [mul_comm, mul_comm c, mul_div_mul_of_pos _ _ H]
rw [mod_def, mod_def, mul_div_mul_of_pos _ _ H, mul_sub_left_distrib, mul_assoc]
rw [mul_comm, mul_div_cancel_of_mod_eq_zero H]
rw [Int.natAbs_sign, if_neg hz]
unfold sign <;> simp
simp [sign]
simp [sign]
simp
simp
rw [to_nat_eq_max, max_eq_left h]
rw [to_nat_eq_max] <;> apply le_max_left
rw [← Int.ofNat_le, Int.toNat_of_nonneg h]
simp
constructor <;> intro h <;> cases h
rw [sqrt, ← nat_abs_mul_self, to_nat_coe_nat, Nat.sqrt_eq]
rw [← hn, sqrt_eq, ← Int.ofNat_mul, nat_abs_mul_self]
rw [← nat_abs_mul, Units.mul_inv] <;> rfl
rw [← nat_abs_mul, Units.inv_mul] <;> rfl
simp [nat_abs_eq_iff, is_unit_iff, Nat.cast_zero]
rw [Nat.isUnit_iff, is_unit_iff_nat_abs_eq, nat_abs_of_nat]
infer_instance
rw [abs_eq_nat_abs] <;> rfl
rw [abs_eq_nat_abs, sign_mul_nat_abs]
simp
rw [le_iff_lt_or_eq, abs_lt_one_iff, abs_eq (zero_le_one' ℤ)]
rw [← Int.div_neg] <;> exact Int.div_nonneg Ha (neg_nonneg_of_nonpos Hb)
rw [← Int.div_neg] <;> exact div_eq_zero_of_lt H1 H2
rw [← this, sub_add_cancel]
rw [← Int.div_neg, neg_add, ← Int.div_neg, ← neg_mul_neg] <;> apply this (neg_pos_of_neg hlt)
rw [mul_comm, Int.add_mul_ediv_right _ _ H]
rw [mul_comm, Int.mul_ediv_cancel _ H]
rw [add_comm, Int.add_ediv_of_dvd_right H, add_comm]
rw [← mod_abs] <;> exact mod_lt_of_pos _ (abs_pos.2 H)
rw [cz, mul_zero, add_zero]
rw [mod_def, mod_def, Int.add_mul_ediv_right _ _ cz, mul_add, mul_comm,
      add_sub_add_right_eq_sub]
rw [mul_comm, add_mul_mod_self]
rw [add_comm, add_mod_self]
rw [add_comm, mod_add_mod, add_comm]
rw [add_mod_mod, mod_add_mod]
rw [← mod_add_mod, ← mod_add_mod k, H]
rw [add_comm, add_mod_eq_add_mod_right _ H, add_comm]
rw [add_comm, add_comm i, mod_add_cancel_right]
rw [← zero_add (a * b), add_mul_mod_self, zero_mod]
rw [mul_comm, mul_mod_left]
conv => 
    rhs
    rw [← mod_add_div a b, add_mul_mod_self_left]
apply (mod_add_cancel_right b).mp
rw [sub_add_cancel, ← add_mod_mod, sub_add_cancel, mod_mod]
simp
rw [add_mul, one_mul, mul_comm, ← sub_lt_iff_lt_add', ← mod_def]
exact mod_lt_of_pos _ H
rw [abs_eq_nat_abs, abs_eq_nat_abs] <;>
    exact
      coe_nat_le_coe_nat_of_le
        (match a, n with
        | (m : ℕ), n => Nat.div_le_self _ _
        | -[m+1], 0 => Nat.zero_le _
        | -[m+1], n + 1 => Nat.succ_le_succ (Nat.div_le_self _ _))
decide
decide
decide
decide
decide
rw [h]
rw [← e]
rw [← neg_dvd, ← e]
rw [← e]
rw [← dvd_neg, ← e]
infer_instance
rw [mul_comm, Int.ediv_mul_cancel H]
simp [az]
rw [Int.mul_ediv_cancel_left _ az, mul_assoc, Int.mul_ediv_cancel_left _ az] <;>
        apply dvd_mul_right
rw [← H2, Int.mul_ediv_cancel' H1]
rw [H2, Int.mul_ediv_cancel_left _ H1]
rw [mul_comm] <;> exact Int.ediv_eq_iff_eq_mul_right H H'
rw [mul_comm, Int.eq_mul_of_ediv_eq_right H1 H2]
rw [mul_comm, H2]
rw [← Int.mul_ediv_cancel' h, H, mul_zero]
refine' ⟨fun h => _, congr_arg _⟩
rw [← Int.mul_ediv_cancel' hda, ← Int.mul_ediv_cancel' hdb, h]
rw [abs_eq_nat_abs, nat_abs_sign_of_nonzero hz, Int.ofNat_one]
simp [cz]
rw [mul_left_comm, Int.mul_ediv_cancel_left _ cz, Int.mul_ediv_cancel_left _ cz]
rw [mul_comm, Int.mul_ediv_assoc _ h, mul_comm]
simp [bz]
rw [neg_mul_eq_mul_neg, Int.mul_ediv_cancel_left _ bz, Int.mul_ediv_cancel_left _ bz]
rw [sub_eq_add_neg, sub_eq_add_neg, Int.add_ediv_of_dvd_right ((dvd_neg c b).mpr hcb)]
congr
exact neg_div_of_dvd hcb
rw [eq_sub_iff_add_eq, ← Int.add_ediv_of_dvd_left hcab, sub_add_cancel]
simp [az]
rw [mul_comm, ← mod_def] <;> apply mod_nonneg _ H
rw [← Int.ediv_mul_cancel H2] <;> exact mul_le_mul_of_nonneg_right H3 H1
rw [← Int.mul_ediv_assoc _ H2] <;> exact (Int.ediv_eq_of_eq_mul_left H4 H5.symm).symm
rw [(coe_nat_le_coe_nat_iff _ _).symm, to_nat_eq_max, max_le_iff] <;>
    exact and_iff_left (coe_zero_le _)
rw [to_nat_le] <;> exact le_trans h (le_to_nat b)
cases a
exact lt_to_nat.1 h
exact lt_trans (neg_succ_of_nat_lt_zero a) hb
rw [lt_to_nat]
cases a
exact h
exact hb
simp [h, le_of_lt h, push_cast]
rw [is_unit_iff_nat_abs_eq, abs_eq_nat_abs, ← Int.ofNat_one, coe_nat_inj']
rw [sq, is_unit_mul_self ha]
rw [Units.ext_iff, Units.val_pow_eq_pow_val, Units.val_one, is_unit_sq u.is_unit]
rw [← sq, units_sq]
rw [inv_eq_iff_mul_eq_one, units_mul_self]
rw [← Units.val_mul, units_mul_self, Units.val_one]
simp
conv => 
      lhs
      rw [← Nat.mod_add_div n 2] <;>
    rw [pow_add, pow_mul, units_sq, one_pow, mul_one]
rw [← abs_eq_iff_mul_self_eq, abs_eq_nat_abs, abs_eq_nat_abs]
exact int.coe_nat_inj'.symm
rw [nat_abs_eq_iff, mul_eq_zero, sub_eq_zero, add_eq_zero_iff_eq_neg]
rw [← abs_lt_iff_mul_self_lt, abs_eq_nat_abs, abs_eq_nat_abs]
exact int.coe_nat_lt.symm
rw [← abs_le_iff_mul_self_le, abs_eq_nat_abs, abs_eq_nat_abs]
exact int.coe_nat_le.symm
rw [← Int.natAbs_mul] <;> apply Int.coe_nat_dvd.1 <| Int.dvd_natAbs.2 hpmn
apply Int.dvd_natAbs.1
apply Int.coe_nat_dvd.2 hsd1
apply Int.dvd_natAbs.1
apply Int.coe_nat_dvd.2 hsd2
simp [xgcd_aux]
unfold gcd_a
rw [xgcd, xgcd_zero_left]
unfold gcd_b
rw [xgcd, xgcd_zero_left]
unfold gcd_a xgcd
induction s
· exact absurd rfl h
· simp [xgcd_aux]
unfold gcd_b xgcd
induction s
· exact absurd rfl h
· simp [xgcd_aux]
simp
simp [xgcd_aux_rec, h, IH] <;> rw [← gcd_rec]
rw [xgcd, ← xgcd_aux_fst x y 1 0 0 1] <;> cases xgcd_aux x 1 0 y 0 1 <;> rfl
unfold gcd_a gcd_b <;> cases xgcd x y <;> rfl
simp
rw [xgcd_aux_rec h]
refine' IH _ p
dsimp [P] at *
rw [Int.mod_def]
generalize (b / a : ℤ) = k
rw [p, p']
simp [mul_add, mul_comm, mul_left_comm, add_comm, add_left_comm, sub_eq_neg_add, mul_assoc]
simp [P]
simp [P]
rw [neg_mul_neg] <;> apply Nat.gcd_eq_gcd_ab
rw [neg_mul_neg] <;> apply Nat.gcd_eq_gcd_ab
rw [neg_mul_neg, neg_mul_neg]
apply Nat.gcd_eq_gcd_ab
rw [mul_one]
rw [Nat.div_self h]
rw [Nat.mul_div_assoc _ dvd_rfl]
rw [nat_abs_mul (a / b) b]
rw [Int.ediv_mul_cancel H]
rw [mul_assoc] at H1 <;> exact ⟨_, mul_left_cancel₀ k_non_zero H1⟩
rw [mul_comm i k, mul_comm j k] at H <;> exact dvd_of_mul_dvd_mul_left k_non_zero H
rw [Int.gcd, Int.lcm, Nat.gcd_mul_lcm, nat_abs_mul]
simp [gcd]
simp [gcd]
simp [gcd]
rw [Int.gcd, Int.gcd, nat_abs_neg]
rw [Int.gcd, Int.gcd, nat_abs_neg]
rw [Int.gcd, Int.gcd, nat_abs_mul, nat_abs_mul]
apply Nat.gcd_mul_left
rw [Int.gcd, Int.gcd, nat_abs_mul, nat_abs_mul]
apply Nat.gcd_mul_right
rw [Int.gcd]
constructor
· intro h
    exact
      ⟨nat_abs_eq_zero.mp (Nat.eq_zero_of_gcd_eq_zero_left h),
        nat_abs_eq_zero.mp (Nat.eq_zero_of_gcd_eq_zero_right h)⟩
· intro h
    rw [nat_abs_eq_zero.mpr h.left, nat_abs_eq_zero.mpr h.right]
    apply Nat.gcd_zero_left
rw [gcd, nat_abs_div i k H1, nat_abs_div j k H2] <;>
    exact Nat.gcd_div (nat_abs_dvd_iff_dvd.mpr H1) (nat_abs_dvd_iff_dvd.mpr H2)
rw [gcd_div (gcd_dvd_left i j) (gcd_dvd_right i j)]
rw [nat_abs_of_nat, Nat.div_self H]
unfold gcd <;> exact Nat.gcd_dvd_left _ _
unfold gcd <;> exact Nat.dvd_gcd dvd_rfl (nat_abs_dvd_iff_dvd.mpr H)
rw [gcd_comm, gcd_eq_left H]
refine' ⟨fun h => _, fun h => pow_dvd_pow_of_dvd h _⟩
apply int.nat_abs_dvd_iff_dvd.mp
apply (Nat.pow_dvd_pow_iff k0).mp
rw [← Int.nat_abs_pow, ← Int.nat_abs_pow]
exact int.nat_abs_dvd_iff_dvd.mpr h
simp [mul_assoc, ← mul_add, ← this]
rw [mul_comm] at habc
exact dvd_of_dvd_mul_left_of_gcd_one habc hab
rw [Int.lcm, Int.lcm]
exact Nat.lcm_comm _ _
rw [Int.lcm, Int.lcm, Int.lcm, Int.lcm, nat_abs_of_nat, nat_abs_of_nat]
apply Nat.lcm_assoc
rw [Int.lcm]
apply Nat.lcm_zero_left
rw [Int.lcm]
apply Nat.lcm_zero_right
rw [Int.lcm]
apply Nat.lcm_one_left
rw [Int.lcm]
apply Nat.lcm_one_right
rw [Int.lcm]
apply Nat.lcm_self
rw [Int.lcm]
apply coe_nat_dvd_right.mpr
apply Nat.dvd_lcm_left
rw [Int.lcm]
apply coe_nat_dvd_right.mpr
apply Nat.dvd_lcm_right
rw [Int.lcm]
intro hi hj
exact coe_nat_dvd_left.mpr (Nat.lcm_dvd (nat_abs_dvd_iff_dvd.mpr hi) (nat_abs_dvd_iff_dvd.mpr hj))
refine' Nat.dvd_antisymm _ (Int.coe_nat_dvd.1 (Int.dvd_gcd h₁ h₂))
rw [← Int.coe_nat_dvd, ← h₃]
apply dvd_add
· exact (Int.gcd_dvd_left _ _).mul_right _
· exact (Int.gcd_dvd_right _ _).mul_right _
rw [dm, ← xy, ← hd, Nat.gcd_mul_lcm]
cases n
· rw [Int.cast_of_nat] at h
      exact congr_arg coe (Nat.cast_eq_zero.1 h)
· rw [cast_neg_succ_of_nat, neg_eq_zero, Nat.cast_eq_zero] at h
      contradiction
rw [h, cast_zero]
rw [← sub_eq_zero, ← cast_sub, cast_eq_zero, sub_eq_zero]
simp [← two_mul, hm]
simp [← two_mul, h]
rw [even_iff, mod_two_ne_zero]
rw [odd_iff, mod_two_ne_one]
rw [not_odd_iff, even_iff]
rw [not_even_iff, odd_iff]
simp [← Set.compl_setOf, is_compl_compl]
rw [even_add, even_iff_not_odd, even_iff_not_odd, not_iff_not]
simp [bit1, parity_simps]
simp [add_mod]
rfl
simp [sub_eq_add_neg, parity_simps]
rw [even_sub, even_iff_not_odd, even_iff_not_odd, not_iff_not]
simp [even_add]
simp [not_or, parity_simps]
rw [odd_iff_not_even, even_add, not_iff, odd_iff_not_even]
rw [add_comm, odd_add]
rw [odd_iff_not_even, even_sub, not_iff, odd_iff_not_even]
rw [odd_iff_not_even, even_sub, not_iff, not_iff_comm, odd_iff_not_even]
rw [odd_iff_not_even, Nat.odd_iff_not_even, even_coe_nat]
simp [even_iff_two_dvd, dvd_nat_abs, coe_nat_dvd_left.symm]
rw [odd_iff_not_even, Nat.odd_iff_not_even, nat_abs_even]
decide
simp
simp
rw [sq, sq]
exact nat_abs_eq_iff_mul_self_eq
rw [sq, sq]
exact nat_abs_lt_iff_mul_self_lt
rw [sq, sq]
exact nat_abs_le_iff_mul_self_le
rw [← sq_eq_sq ha hb, ← nat_abs_eq_iff_sq_eq]
simp
cases x <;> rfl
constructor
simp [this]
infer_instance
cases x
cases y
congr
simp only [head, H] <;> rfl
simp only [head, H'] <;> rfl
constructor
rw [← head_succ' n, h, head']
apply x.consistent
rw [← dest_mk x, h, dest_mk]
induction n generalizing x <;> induction x using Pfunctor.M.casesOn' <;> constructor <;> try rfl
intros
apply n_ih
dsimp only [M.mk, Pfunctor.M.cases, dest, head, approx.s_mk, head']
cases x
dsimp only [approx.s_mk]
apply eq_of_heq
apply rec_heq_of_heq
congr
rw [h]
rw [dest_mk]
rfl
rw [head_mk]
apply ext' <;> intro n <;> rfl
dsimp only [ichildren, Pfunctor.Obj.iget]
congr
simp only [isubtree, ichildren_mk, Pfunctor.Obj.iget, dif_pos, isubtree, M.cases_on_mk'] <;> rfl
rfl
simp only [iselect, isubtree_cons]
dsimp only [M.corec, M.mk]
congr
cases hh <;> cases is_path_cons hh <;> rfl
rw [corec_def, dest_mk]
rw [hyp, gxeq, Pfunctor.map_eq]
rw [dest_corec, gxeq, Pfunctor.map_eq]
cases p <;> rfl
cases p <;> rfl
cases x <;> rfl
simp only [obj.iget, fst_map, *, dif_pos, eq_self_iff_true]
cases x
rfl
delta M <;> infer_instance
rw [h, M.corec_shape, Pfunctor.M.dest_corec] at h'
cases h'
rfl
rw [h, M.corec_shape, Pfunctor.M.dest_corec] at h'
cases h'
rfl
rw [h, M.corec_shape, Pfunctor.M.dest_corec] at h'
cases h'
rfl
cases h₁.symm.trans h₂ <;> rfl
cases x
rfl
rfl
cases x
dsimp [const.get, const.mk]
congr
cases x
rfl
cases x
simp! [comp.get, comp.mk]
intro i x
cases x
case root _ _ i c => exact g' i c
case child _ _ i j c => exact g j i c
delta Mvpfunctor.W <;> infer_instance
rw [obj_append1, obj_append1, map_eq, append_fun, ← split_fun_comp] <;> rfl
rw [W_dest', W_rec_eq]
simp
cases x₀
cases x₁
cases h₀
cases h₁
rfl
cases x₀
cases x₁
exact Sigma.mk.inj_iff
simp only [Function.Surjective, Sigma.forall, h₁.forall]
exact fun i => (h₂ _).forall.2 fun x => ⟨⟨i, x⟩, rfl⟩
trace
          "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `reflect_name #[]"
cases x₀
cases x₁
cases h₀
cases h₁
rfl
cases x₀
cases x₁
exact PSigma.mk.inj_iff
unfold blur <;> congr <;> exact Set.union_eq_self_of_subset_right h
revert h <;> rw [eq_mk_of_mem aq] <;> intro <;> rfl
simp
simp <;>
        exact fun c =>
          ⟨fun ⟨b, ⟨a, as, bf⟩, cg⟩ => ⟨a, as, b, bf, cg⟩, fun ⟨a, as, b, bf, cg⟩ =>
            ⟨b, ⟨a, as, bf⟩, cg⟩⟩
simp
simp [eq_comm]
let ⟨a, h⟩ := exists_mem q
unfold get <;> rw [lift_on_of_mem q _ _ a h] <;> exact h
simp <;> exact ⟨fun h => p _ h _ (get_mem _), fun e => e.symm ▸ get_mem _⟩
rw [eq_pure h, eq_pure (h.mono st)] <;> simp <;> exact h _ (get_mem _) _ (st <| get_mem _)
simp
have t : od = pd := propext H1
cases t <;> rw [show o = p from funext fun p => H2 p p]
intro h
change none.dom
rw [← h]
trivial
simp [h.symm]
simp [h]
congr
exact h
unfold to_option
simp [of_option, none]
simp [of_option]
cases o <;> rfl
dsimp <;> congr
simp
simp
simp
rw [eq_some_iff.2 h, bind_some]
simp [eq_comm]
simp <;>
      exact
        ⟨fun ⟨_, ⟨_, h₁, h₂⟩, h₃⟩ => ⟨_, h₁, _, h₂, h₃⟩, fun ⟨_, h₁, _, h₂, h₃⟩ =>
          ⟨_, ⟨_, h₁, h₂⟩, h₃⟩⟩
rw [← bind_some_eq_map, bind_assoc] <;> simp
rw [← bind_some_eq_map, bind_assoc] <;> simp [bind_some_eq_map]
rw [← bind_some_eq_map, bind_map, bind_some_eq_map]
cases f <;> rfl
rw [show f = id from funext H] <;> exact id_map o
rw [bind_some_eq_map] <;> simp [map_id']
apply (Nat.le_div_iff_mul_le (Nat.gcd_pos_of_pos_right _ dpos)).2
rw [one_mul]
exact Nat.le_of_dvd dpos (Nat.gcd_dvd_right _ _)
change n /. d with dite _ _ _ <;> simp [ne_of_gt h]
cases n <;> simp [mk]
have dv := @gcd_abs_dvd_left
have := Int.eq_mul_of_ediv_eq_right dv ha
rw [← Int.mul_ediv_assoc _ dv] at this
exact Int.eq_mul_of_ediv_eq_left (dv.mul_left _) this.symm
have dv := fun {a b} => Nat.gcd_dvd_right (Int.natAbs a) b
have := Nat.eq_mul_of_div_eq_right dv hb
rw [← Nat.mul_div_assoc _ dv] at this
exact Nat.eq_mul_of_div_eq_left (dv.mul_left _) this.symm
refine' Int.coe_nat_ne_zero.2 (ne_of_gt _)
apply mul_pos <;> apply Nat.gcd_pos_of_pos_right <;> assumption
exact le_antisymm (this _ hb _ hd h) (this _ hd _ hb h.symm)
simp [mk_nat, ne_of_gt h, mk_pnat, c]
rw [num_denom'] <;> exact H n d h c
simp [mul_add, mul_comm, mul_left_comm]
rw [h₁, h₂]
simp [mul_add, mul_comm, mul_left_comm]
simp [r.cop]
simp <;> exact c
rw [← zero_mk d] <;> simp [h, -zero_mk]
rw [← zero_mk d] <;> simp [h, -zero_mk]
simp [h₁, h₂, h₃, mul_ne_zero, mul_add, mul_comm, mul_left_comm, add_left_comm, add_assoc]
simp [h]
rw [mk_pnat]
simp
rfl
rw [mk_pnat]
simp
rfl
rw [mk_pnat]
simp
rfl
rw [← mk_one_one]
simp [h, -mk_one_one]
rw [← mk_one_one]
simp [h, -mk_one_one]
simp [h₁, h₂, mul_comm]
simp [h₁, h₂, h₃, mul_ne_zero, mul_comm, mul_left_comm]
simp [h₁, h₂, h₃, mul_ne_zero] <;>
            refine' (div_mk_div_cancel_left (Int.coe_nat_ne_zero.2 h₃)).symm.trans _ <;>
          simp [mul_add, mul_comm, mul_assoc, mul_left_comm]
rw [Rat.mul_comm, Rat.add_mul, Rat.mul_comm, Rat.mul_comm c a]
rw [ne_comm, ← mk_one_one, mk_ne_zero one_ne_zero]
exact one_ne_zero
simp only [of_int_eq_cast, coe_int_eq_mk, add_def one_ne_zero one_ne_zero, ← mk_one_one,
      Nat.cast_add, Nat.cast_one, mul_one]
infer_instance

--instance : ring ℚ             :=
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
conv => 
    lhs
    rw [← @num_denom p, ← @num_denom q]
apply Rat.mk_eq <;>
    · rw [← Nat.cast_zero, Ne, Int.ofNat_inj]
      apply denom_ne_zero
simp [b0, d0, sub_eq_add_neg]
simp [*]
have hr' : r = 0 := zero_of_num_zero hr
simp [*]
simp
rw [inv_def]
simp [h]
rw [add_def h h, mk_eq h (mul_ne_zero h h)]
simp [add_mul, mul_assoc]
rw [div_eq_mul_inv, inv_def, mk_mul_mk_cancel hx]
rw [div_eq_mul_inv, inv_def, mul_comm, mk_mul_mk_cancel hx]
rw [← Int.cast_ofNat, ← mk_eq_div, num_denom]
rw [← Int.cast_ofNat, coe_int_eq_mk]
rw [← Int.cast_ofNat, coe_int_num]
rw [← Int.cast_ofNat, coe_int_denom]
simp [show (q : ℚ) ≤ p from h]
simp [Rat.coe_to_nnrat]
rw [Rat.coe_to_nnrat _ (hf x hxs)]
rw [Rat.coe_to_nnrat _ (hf x hxs)]
simp [to_nnrat] <;> rfl
simp [to_nnrat, max_eq_left zero_le_one]
simp [to_nnrat, ← coe_lt_coe]
simp [← coe_le_coe, to_nnrat, hp]
simp [← coe_lt_coe, to_nnrat, lt_irrefl]
exact lt_trans'
simp [to_nnrat, hq, hp, add_nonneg]
rw [← coe_le_coe, Rat.coe_to_nnrat p hp]
simp only [(hp.trans_le q.coe_nonneg).not_le, to_nnrat_eq_zero.2 hp.le, hq.not_le]
rw [← coe_lt_coe, Rat.coe_to_nnrat q hq]
simp [hq]
simp [to_nnrat_one, bit1, hq]
rw [div_eq_mul_inv, div_eq_mul_inv, ← to_nnrat_inv, ← to_nnrat_mul hp]
rw [div_eq_inv_mul, div_eq_inv_mul, to_nnrat_mul (inv_nonneg.2 hq), to_nnrat_inv]
simp [Rat.nnabs]
simp [Rat.floor]
rw [num_denom']
have h' := Int.ofNat_lt.2 h
conv => 
      rhs
      rw [coe_int_eq_mk, Rat.le_def zero_lt_one h', mul_one]
exact Int.le_ediv_iff_mul_le h'
cases q
rfl
rw [← neg_inj, ← floor_neg, ← floor_neg, ← Rat.cast_neg, Rat.floor_cast]
simp
simp only [fract, cast_sub, cast_coe_int, floor_cast]
rw [eq_sub_of_add_eq <| Int.mod_add_div n d, Rat.floor_int_div_nat_eq_div]
rw [add_mul]
simp
simp [this]
simp
rw [Nat.cast_one, div_one]
rw [← Int.cast_ofNat, cast_coe_int, Int.cast_ofNat]
refine' mt _ b0
simp (config := { contextual := true })
rw [ke, Int.cast_mul, Int.cast_ofNat]
rw [e] at d₁0 <;> exact d₁0 Nat.cast_zero
rw [e] at d₂0 <;> exact d₂0 Nat.cast_zero
    rw [num_denom', num_denom', add_def d₁0' d₂0']
rw [div_eq_mul_inv, div_eq_mul_inv, Int.cast_neg, neg_mul_eq_neg_mul]
cases n <;> exact n0
  simp [sub_eq_add_neg, cast_add_of_ne_zero m0 this]
rw [e] at d₁0 <;> exact d₁0 Nat.cast_zero
rw [e] at d₂0 <;> exact d₂0 Nat.cast_zero
    rw [num_denom', num_denom', mul_def d₁0' d₂0']
cases n
· simp [cast_inv_nat]
· simp only [Int.cast_negSucc, ← Nat.cast_succ, cast_neg, inv_neg, cast_inv_nat]
rw [e] at n0 <;> exact n0 Int.cast_zero
rw [e] at d0 <;> exact d0 Nat.cast_zero
    rw [num_denom', inv_def]
    rw [cast_mk_of_ne_zero, cast_mk_of_ne_zero, inv_div] <;> simp [n0, d0]
rw [← cast_zero, cast_inj]
rw [bit1, cast_add, cast_one, cast_bit0] <;> rfl
simp only [mk_eq_div, cast_div, cast_coe_int]
rw [Rat.cast_def]
exact div_pos (Int.cast_pos.2 <| num_pos_iff_pos.2 hr) (Nat.cast_pos.2 r.pos)
simp [abs_eq_max_neg]
rw [cast_def, num_div_denom]
rw [cast_def, map_div₀, map_int_cast, map_nat_cast, cast_def]
rw [← map_rat_cast f, Rat.cast_id]
rw [← r.num_div_denom, div_eq_mul_inv, map_mul, map_mul, h, ← Int.cast_ofNat,
      eq_on_inv₀ f g (h _)]
rw [cast_def, div_eq_mul_inv, op_mul, op_inv, op_nat_cast, op_int_cast,
    (Commute.cast_int_right _ r.num).Eq, cast_def, div_eq_mul_inv]
rw [cast_def, div_eq_mul_inv, unop_mul, unop_inv, unop_nat_cast, unop_int_cast,
    (Commute.cast_int_right _ r.num).Eq, cast_def, div_eq_mul_inv]
rw [smul_def, mul_zero]
simp only [smul_def, mul_add, cast_add]
simp only [smul_def, smul_eq_mul, mul_assoc]
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
rw [sqrt, mul_self_num, mul_self_denom, Int.sqrt_eq, Nat.sqrt_eq, abs_def]
rw [← hn, sqrt_eq, abs_mul_abs_self]
cases p
cases q
simp
simp
rw [qdf]
exact Rat.num_dvd _ hd
cases d <;> rfl
cases d <;> rfl
rw [mk_pnat_denom]
apply Nat.div_dvd_of_dvd
apply Nat.gcd_dvd_right
cases q₁
cases q₂
apply mk_pnat_denom_dvd
cases q₁
cases q₂
apply mk_pnat_denom_dvd
cases q₁ <;> cases q₂ <;> rfl
cases q₁ <;> cases q₂ <;> rfl
rw [mul_num, Int.natAbs_mul, Nat.Coprime.gcd_eq_one, Int.ofNat_one, Int.div_one] <;>
    exact (q.cop.mul_right q.cop).mul (q.cop.mul_right q.cop)
rw [Rat.mul_denom, Int.natAbs_mul, Nat.Coprime.gcd_eq_one, Nat.div_one] <;>
    exact (q.cop.mul_right q.cop).mul (q.cop.mul_right q.cop)
rw [← Rat.mk_eq_div]
rw [sub_eq_add_neg, sub_eq_add_neg, ← neg_mul, ← num_neg_eq_neg_num, ← denom_neg_eq_denom r,
    add_num_denom' q (-r)]
rw [← @num_denom q]
simp [-num_denom]
apply And.intro
· rw [← num_div_eq_of_coprime hb0 h1, h, num_div_eq_of_coprime hd0 h2]
· rw [← denom_div_eq_of_coprime hb0 h1, h, denom_div_eq_of_coprime hd0 h2]
rw [Rat.inv_def', Rat.coe_int_num, Rat.coe_int_denom, Nat.cast_one, ← Int.cast_one]
apply num_div_eq_of_coprime ha0
rw [Int.natAbs_one]
exact Nat.coprime_one_left _
rw [Rat.inv_def', Rat.coe_int_num, Rat.coe_int_denom, Nat.cast_one, ← Int.cast_one]
apply denom_div_eq_of_coprime ha0
rw [Int.natAbs_one]
exact Nat.coprime_one_left _
induction a using Int.induction_on <;>
    simp [← Int.negSucc_coe', Int.negSucc_coe, -neg_add_rev, Rat.inv_neg, Int.ofNat_add_one_out,
      -Nat.cast_succ, inv_coe_nat_num_of_pos, -Int.cast_negSucc, @eq_comm ℤ 1,
      Int.sign_eq_one_of_pos]
induction a using Int.induction_on <;>
    simp [← Int.negSucc_coe', Int.negSucc_coe, -neg_add_rev, Rat.inv_neg, Int.ofNat_add_one_out,
      -Nat.cast_succ, inv_coe_nat_denom_of_pos, -Int.cast_negSucc]
simp [Rat.div_num_denom]
rw [pnat_denom, mk_pnat_eq, num_denom]
have d₁0 : 0 < (d₁ : ℤ) := Int.coe_nat_pos.2 (Nat.pos_of_ne_zero h₁)
have d₂0 : 0 < (d₂ : ℤ) := Int.coe_nat_pos.2 (Nat.pos_of_ne_zero h₂)
simp [d₁0, d₂0, h₁, h₂, mul_pos d₁0 d₂0]
intro n₁0 n₂0
apply add_nonneg <;> apply mul_nonneg <;> · first |assumption|apply Int.ofNat_zero_le
have d₁0 : 0 < (d₁ : ℤ) := Int.coe_nat_pos.2 (Nat.pos_of_ne_zero h₁)
have d₂0 : 0 < (d₂ : ℤ) := Int.coe_nat_pos.2 (Nat.pos_of_ne_zero h₂)
simp (config := { contextual := true }) [d₁0, d₂0, h₁, h₂, mul_pos d₁0 d₂0, mul_nonneg]
have d0 : 0 < (d : ℤ) := Int.coe_nat_pos.2 (Nat.pos_of_ne_zero h)
simp [d0, h]
exact fun h₁ h₂ => le_antisymm h₂ h₁
cases a <;> unfold Rat.Nonneg <;> infer_instance
infer_instance
show Rat.Nonneg _ ↔ _
rw [← sub_nonneg]
simp [sub_eq_add_neg, ne_of_gt b0, ne_of_gt d0, mul_pos d0 b0]
rw [sub_self] <;> exact le_refl (0 : ℤ)
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
constructor <;> intro h
· exact lt_iff_le_and_ne.elim_right ⟨h.left, this.elim_left h.right⟩
· have tmp := lt_iff_le_and_ne.elim_left h
      exact ⟨tmp.left, this.elim_right tmp.right⟩
simp
unfold LE.le Rat.Le <;> rw [add_sub_add_left_eq_sub]
rw [← nonneg_iff_zero_le] at ha hb⊢ <;> exact Rat.nonneg_mul ha hb
decide
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
cases a <;> rfl
simp only [lt_iff_le_not_le]
apply and_congr
· simp [div_num_denom, Rat.le_def b_pos d_pos]
· apply not_congr
    simp [div_num_denom, Rat.le_def d_pos b_pos]
simp [Rat.lt_def]
simp
rw [foldl, as_list, List.foldl_join, ← Array'.to_list_foldl]
injection n
intro e
injection e with e
exact h e.symm
subst e <;> exact v.idx hl
let ⟨h, e⟩ := v.idx_enum _ he hl
rw [e] <;> rfl
simp [List.nodup_range]
simp [mk_as_list]
cases h, fun i => List.nodup_nil
rw [bkts.mem_as_list] <;> exact ⟨fun h => ⟨_, h⟩, fun ⟨i, h⟩ => (v.idx h).symm ▸ h⟩
simp [contains_aux, Option.isSome_iff_exists, v.find_aux_iff hash_fn]
simp only [bidx.is_lt, Array'.to_list_length]
simp [hl, hfl.symm, Ne.symm e]
simp at e <;> rw [e]
simp at e <;> rw [e]
simp
simp [hl, hfl.symm]
dsimp [keys] <;> rw [entries_empty] <;> rfl
apply Bool.bool_iff_false.2 <;> dsimp [contains] <;> rw [find_empty] <;> rfl
have p := this bkts.as_list _ _ (mk_valid _ _)
rw [mk_as_list, List.append_nil, zero_add, v.len] at p
rw [BucketArray.foldl_eq]
exact p (v.as_list_nodup _)
simp [add_comm, add_assoc]
intro m3
have : a ∈ List.map Sigma.fst t.as_list :=
      List.mem_map_of_mem Sigma.fst (t.mem_as_list.2 ⟨_, m3⟩)
exact dj (List.mem_map_of_mem Sigma.fst m1) this
decide
intro bkts' v1 u w hl hfl veq
rw [hl, hfl]
simp [h, Ne.symm h, this]
decide
rw [if_pos rfl]
rw [dif_pos h] <;>
      exact
        match a', h with
        | _, rfl => find_insert_eq m a b
rw [dif_neg h] <;> exact find_insert_ne m a a' b h
let bkt := bkts.read hash_fn a
simp [eq_comm, not_and_self_iff, and_iff_right_of_imp this]
simp [erase, @dif_neg (contains_aux a bkt) _ Hc, entries, and_iff_right_of_imp this]
subst a' <;> simp [find_erase_eq m a]
rw [if_neg h] <;> exact find_erase_ne m a a' h
constructor <;> intro h
· cases h <;> simp
· cases h <;> rw [h.1, h.2]
    constructor
rw [Quotient.eq]
apply rel.swap
cases p
exact eq_swap
constructor <;> intro h
· rw [Quotient.eq] at h
    cases h <;> rfl
rw [h]
constructor <;> intro h
· rw [Quotient.eq] at h
    cases h <;> rfl
rw [h]
simp
cases p
cases q
simp only [eq_iff, Prod.mk.inj_iff, Prod.swap_prod_mk]
rw [Prod.mk.eta, e.out_eq]
rw [eq_swap, Prod.mk.eta, e.out_eq]
erw [← Classical.choose_spec h]
simp
simp
simp [hw, h]
cases Quotient.exact h <;> rfl
refine' fun z => Quotient.recOnSubsingleton z fun a => _
erw [is_diag_iff_proj_eq]
infer_instance
apply Set.eq_empty_of_forall_not_mem fun e => _
refine' e.ind _
simp [-Set.bot_eq_empty, Prop.bot_eq_false]
apply Set.eq_univ_of_forall fun e => _
refine' e.ind _
simp [-Set.top_eq_univ, Prop.top_eq_true]
simp [eq_swap]
intro h
cases h <;> rw [h.1, h.2]
apply List.Perm.swap'
rfl
intro _ e _
subst e
rw [← congr_right, other_spec' h, other_spec]
rw [← other_eq_other']
exact other_mem h
rw [Multiset.card_cons, s.2]
cases v
rfl
cases v
rfl
rw [Multiset.card_erase_of_mem h, hc]
rfl
rfl
rfl
simp [Sym.map]
simp [Sym.map]
simp [Sym.map]
simp [map, cons]
simp [hc]
rw [map_map, Equiv.symm_comp_self, map_id]
rw [map_map, Equiv.self_comp_symm, map_id]
rw [Multiset.card_attach, s.2]
rw [fill, mem_cast, mem_append_iff, or_comm', mem_repeat]
rw [m.2, Nat.lt_succ_iff]
rw [← countp_eq_card_filter, add_comm]
exact (card_eq_countp_add_countp _ _).symm
rw [← Nat.sub_sub_self m₁.1.is_le, ← Nat.sub_sub_self m₂.1.is_le, ← m₁.2.2, ← m₂.2.2,
        Subtype.val_eq_coe, Subtype.val_eq_coe, h]
dsimp only [filter_ne, Subtype.coe_mk, Subtype.val_eq_coe, coe_fill]
rw [filter_add, filter_eq_self.2, add_right_eq_self, eq_zero_iff_forall_not_mem]
· intro b hb
        rw [mem_filter, Sym.mem_coe, mem_repeat] at hb
        exact hb.2 hb.1.2.symm
· exact fun b hb => (hb.ne_of_not_mem h).symm
simp
simp
rw [← card_sym_fin_eq_multichoose]
exact card_congr (equiv_congr (equiv_fin α))
rw [card_sym_eq_multichoose, Nat.multichoose_eq]
cases h <;> have := ha.symm <;> exact ⟨‹_›, ‹_›, ‹_›⟩
rw [Nat.choose_two_right, mul_tsub, mul_one, ← off_diag_card,
    Nat.div_eq_of_eq_mul_right zero_lt_two (two_mul_card_image_off_diag s).symm]
cases h <;> rfl
simp [nonempty_iff_ne_empty, sum_lift₂_eq_empty, not_and_or]
cases x <;>
    simp only [get_left, is_right, Bool.coe_sort_true, Bool.coe_sort_false, eq_self_iff_true]
cases x <;>
    simp only [get_right, is_left, Bool.coe_sort_true, Bool.coe_sort_false, eq_self_iff_true]
cases x <;> rfl
cases x <;> simp
simp
cases x <;> rfl
cases x <;> simp
simp
cases x <;> simp
cases x <;> simp
cases x <;> rfl
cases x <;> rfl
cases x <;> rfl
cases x <;> rfl
simp
simp (config := { contextual := true })
simp
simp (config := { contextual := true })
rw [← update_inl_comp_inl]
rw [← update_inr_comp_inr]
cases x <;> rfl
cases x <;> rfl
cases x <;> rfl
cases x <;> rfl
cases x <;> rfl
cases h
assumption
cases h
assumption
rw [← swap_swap x, ← swap_swap y]
exact h.swap
cases h
assumption
cases h
assumption
rw [sign, if_pos hr]
rw [sign, if_pos hr, if_neg hr.not_lt]
rw [sign, if_neg (lt_irrefl _), if_neg (lt_irrefl _)]
refine' lt_of_le_of_ne (sign_mul_nonneg r) fun h => hr _
have hs0 := (zero_eq_mul.mp h).resolve_right hr
exact sign_eq_zero_iff.mp hs0
rw [inv_eq_iff_inv_eq, ← neg_inv, neg_eq_iff_neg_eq]
exact inv_gold.symm
rw [mul_comm]
exact gold_mul_gold_conj
refine' lt_of_mul_lt_mul_left _ (le_of_lt gold_pos)
simp [← sq, gold_pos, zero_lt_one]
rw [neg_lt, ← inv_gold]
exact inv_lt_one one_lt_gold
rw [fibRec, LinearRecurrence.charPoly]
simp [Finset.sum_fin_eq_sum_range, Finset.sum_range_succ', ← smul_X_eq_monomial]
rw [fibRec]
intro n
simp only
rw [Nat.fib_add_two, add_comm]
simp [Finset.sum_fin_eq_sum_range, Finset.sum_range_succ']
rw [fib_rec.geom_sol_iff_root_char_poly, fib_rec_char_poly_eq]
simp [sub_eq_zero]
rw [fib_rec.geom_sol_iff_root_char_poly, fib_rec_char_poly_eq]
simp [sub_eq_zero]
rw [← Function.funext_iff, Real.coe_fib_eq']
simp only [lt_iff_not_ge] <;>
          exact fun hi2 => hi1 (lt_of_le_of_lt (le_abs_self _) (hf' i hi2))
rw [neg_zero] at hg <;> exact lt_of_tendsto_zero_of_pos hg hr
rw [← neg_neg r, coe_neg] <;> exact neg_lt_of_tendsto_zero_of_pos hf (neg_pos.mpr hr)
rw [hrs] <;> exact is_st_refl_real s
rw [is_st_real_iff_eq, is_st_real_iff_eq, eq_comm]
rw [is_st_real_iff_eq, is_st_real_iff_eq, is_st_real_iff_eq] <;> exact Eq.trans
simp only [abs_sub_lt_iff, sub_lt_iff_lt_add, is_st, and_comm', add_comm]
rw [sub_eq_add_neg, sub_eq_add_neg] <;> exact is_st_add hxr (is_st_neg hys)
rw [← not_lt, ← not_lt, not_imp_not] <;> exact lt_of_is_st_lt hsy hrx
rw [iff_eq_eq] <;> rfl
rw [iff_eq_eq] <;> rfl
rw [infinite_pos_iff_infinite_and_pos] <;> exact ⟨fun hI => hI.1, fun hI => ⟨hI, hp⟩⟩
rw [h.symm] <;>
      exact
        ⟨fun hIP => False.elim (not_infinite_zero (Or.inl hIP)), fun hI =>
          False.elim (not_infinite_zero hI)⟩
rw [infinite_neg_iff_infinite_and_neg] <;> exact ⟨fun hI => hI.1, fun hI => ⟨hI, hn⟩⟩
rw [abs_of_pos (hip 0)] <;> exact hip d
rw [abs_of_neg (hin 0)] <;> exact lt_neg.mp (hin (-d))
rw [← infinite_pos_iff_infinite_of_nonneg (abs_nonneg _), infinite_iff_infinite_pos_abs]
rw [add_comm] <;> exact infinite_pos_add_not_infinite_neg hy hx
rw [@infinite_neg_iff_infinite_pos_neg x, @infinite_pos_iff_infinite_neg_neg y,
      @infinite_neg_iff_infinite_pos_neg (x + y), neg_add] <;>
    exact infinite_pos_add_not_infinite_neg
rw [add_comm] <;> exact infinite_neg_add_not_infinite_pos hy hx
rw [← not_le, ← not_le] <;> exact not_imp_not.mpr (hi a)
simp only [Set.compl_setOf, not_lt] <;>
        exact fun a har => le_of_lt (hi' a (lt_of_le_of_lt har (lt_add_one _)))
rw [← not_le, ← not_le] <;> exact not_imp_not.mpr (hi a)
simp only [Set.compl_setOf, not_lt] <;>
        exact fun a har => le_of_lt (hi' a (lt_of_lt_of_le (sub_one_lt _) har))
rw [not_infinite_iff_exist_lt_gt] <;>
    exact ⟨r - 1, r + 1, coe_lt_coe.2 <| sub_one_lt r, coe_lt_coe.2 <| lt_add_one r⟩
rw [mul_sub, sub_mul, add_sub, sub_add_cancel]
simp only [abs_mul]
rw [mul_one, add_halves]
rw [st_infinite h, st_infinite (infinite_iff_infinite_neg.mp h), neg_zero]
rw [hr] <;> exact infinitesimal_zero
rw [sub_eq_add_neg, ← coe_neg, ← coe_add, ← coe_add, zero_add, zero_add] <;>
    exact ⟨neg_lt_of_tendsto_zero_of_pos hf hd, lt_of_tendsto_zero_of_pos hf hd⟩
rw [sub_eq_add_neg, ← add_neg_self r]
exact is_st_add hxr (is_st_refl_real (-r))
have hg : Tendsto (fun n => f n - r) atTop (𝓝 0) := sub_self r ▸ hf.sub tendsto_const_nhds
rw [← zero_add r, ← sub_add_cancel f fun n => r] <;>
    exact is_st_add (infinitesimal_of_tendsto_zero hg) (is_st_refl_real r)
rw [infinitesimal_def] at hy₁ <;> exact hy₁
rw [not_imp, ← abs_lt, not_lt, abs_of_pos hy₂] at hy₁'' <;> exact hy₁''
    rw [← div_mul_cancel r (ne_of_gt hyr.1), coe_mul] <;>
      exact mul_lt_mul (hx (r / r₁)) hyr.2 (coe_lt_coe.2 hyr.1) (le_of_lt (hx 0))
rw [mul_comm] <;> exact infinite_pos_mul_of_infinite_pos_not_infinitesimal_pos hy hx hp
rw [infinite_neg_iff_infinite_pos_neg, ← neg_pos, ← neg_mul_neg, infinitesimal_neg_iff] <;>
    exact infinite_pos_mul_of_infinite_pos_not_infinitesimal_pos
rw [mul_comm] <;> exact infinite_pos_mul_of_infinite_neg_not_infinitesimal_neg hy hx hp
rw [infinite_neg_iff_infinite_pos_neg, ← neg_pos, neg_mul_eq_mul_neg, infinitesimal_neg_iff] <;>
    exact infinite_pos_mul_of_infinite_pos_not_infinitesimal_pos
rw [mul_comm] <;> exact infinite_neg_mul_of_infinite_pos_not_infinitesimal_neg hy hx hp
rw [infinite_neg_iff_infinite_pos_neg, infinite_neg_iff_infinite_pos_neg, neg_mul_eq_neg_mul] <;>
    exact infinite_pos_mul_of_infinite_pos_not_infinitesimal_pos
rw [mul_comm] <;> exact infinite_neg_mul_of_infinite_neg_not_infinitesimal_pos hy hx hp
rw [mul_comm] <;> exact infinite_mul_of_infinite_not_infinitesimal hy hx
have := lim_zero_congr fg
rw [dif_neg]
simp at hf
simp [hf]
exact Quotient.sound (CauSeq.inv_mul_cancel hf)
simp at hf
simp [hf]
exact Quotient.sound (CauSeq.mul_inv_cancel hf)
rw [Rat.cast_mk', of_rat_mul, of_rat_int_cast, of_rat_inv, of_rat_nat_cast]
simp only [div_eq_mul_inv, of_rat_inv, of_rat_mul]
rw [const_add, add_sub_add_comm] <;>
        exact add_lim_zero (Setoid.symm (equiv_lim f)) (Setoid.symm (equiv_lim g))
simp [const_mul (lim f), mul_add, add_mul, sub_eq_add_neg, add_comm, add_left_comm]
rw [← lim_mul_lim, lim_const]
rw [const_neg, sub_neg_eq_add, add_comm, ← sub_eq_add_neg] <;>
        exact Setoid.symm (equiv_lim f)
have hf := equiv_lim f <;> rw [h] at hf <;>
      exact (lim_zero_congr hf).mpr (const_lim_zero.mpr rfl)
simp [sub_apply, const_apply]
rw [← one_mul g, ← mul_assoc, ← sub_mul, mul_one, mul_comm, mul_comm f] <;>
          exact mul_lim_zero_right _ (Setoid.symm (CauSeq.inv_mul_cancel _))
rw [← mul_assoc, mul_right_comm, const_inv hl] <;> exact h₁ _ _ _
rw [← mul_assoc] <;> exact h₁ _ _ _
simp [Ennreal.toReal, Ennreal.ofReal, h]
simp [Ennreal.toReal, Ennreal.ofReal, Real.coe_to_nnreal _ h]
rw [some_eq_coe, to_nnreal_coe] <;> exact le_rfl
rw [coe_nnreal_eq]
rfl
simp [Ennreal.toReal]
simp [Ennreal.ofReal] <;> rfl
simp [Ennreal.ofReal]
simp [Ennreal.toReal, to_nnreal_eq_zero_iff]
refine' ⟨fun h => _, congr_arg _⟩
cases x
· exact False.elim (zero_ne_one <| ennreal.top_to_nnreal.symm.trans h)
· exact congr_arg _ h
rw [Ennreal.toReal, Nnreal.coe_eq_one, Ennreal.to_nnreal_eq_one_iff]
simp [Ennreal.ofReal]
simp [Ennreal.ofReal]
simp [bit1]
simp only [Ennreal.toReal, Nnreal.coe_eq, to_nnreal_eq_to_nnreal_iff]
simp only [Ennreal.to_nnreal_eq_to_nnreal_iff x y, hx, hy, and_false_iff, false_and_iff,
    or_false_iff]
simp only [Ennreal.toReal, Nnreal.coe_eq, to_nnreal_eq_to_nnreal_iff' hx hy]
rw [infi_subtype', cinfi_ne_top]
simp [Algebra.commutes]
rw [lt_top_iff_ne_top, not_not]
rw [pow_succ, hm', top_mul_top]
simp [Ennreal.ofReal]
simp only [nonpos_iff_eq_zero.symm, max_le_iff]
simp
simp only [none_eq_top, some_eq_coe, coe_add.symm, coe_le_coe, coe_lt_top, true_imp_iff] at
        * <;>
      exact Nnreal.le_of_forall_pos_le_add h
rw [of_real_eq_coe_nnreal c_nonneg] at ac
exact coe_lt_coe.1 ac
rw [← Nnreal.coe_eq, Real.coe_to_nnreal _ c_nonneg]
rfl
simp only [← Ioi_inter_Iic, ← inter_Union, Union_Iic_coe_nat, diff_eq]
simp only [← Ioi_inter_Iio, ← inter_Union, Union_Iio_coe_nat, diff_eq]
simp only [← Ici_inter_Iic, ← inter_Union, Union_Iic_coe_nat, diff_eq]
simp only [← Ici_inter_Iio, ← inter_Union, Union_Iio_coe_nat, diff_eq]
simp only [← compl_Iio, ← compl_Union, Union_Iio_coe_nat, compl_compl]
simp only [← compl_Iic, ← compl_Union, Union_Iic_coe_nat, compl_compl]
simp (config := { contextual := true }) [upperBounds, ball_image_iff, -mem_image, *]
cases a <;> cases b <;> cases c <;>
    simp (config := { contextual := true }) [none_eq_top, some_eq_coe, mul_top, top_mul, -coe_mul,
      coe_mul.symm, Nnreal.mul_eq_mul_left]
cases a <;> cases b <;> cases c <;>
    simp (config := { contextual := true }) [none_eq_top, some_eq_coe, mul_top, top_mul, -coe_mul,
      coe_mul.symm]
intro h
exact mul_le_mul_left (pos_iff_ne_zero.2 h)
simp only [mul_le_mul_left h0 ht, lt_iff_le_not_le]
cases a <;> cases b <;> simp [← WithTop.coe_sub]
rw [← coe_nat, Nat.cast_tsub, coe_sub, coe_nat, coe_nat]
simp only [mul_comm a]
exact sub_mul h
rw [← coe_eq_coe, coe_to_nnreal, coe_finset_sum, sum_congr rfl]
· intro x hx
    exact (coe_to_nnreal (hf x hx)).symm
· exact (sum_lt_top hf).Ne
rw [Ennreal.toReal, to_nnreal_sum hf, Nnreal.coe_sum]
rfl
simp [bit1]
rw [bit1, bit0_top, top_add]
rw [div_eq_mul_inv, mul_comm]
simp <;> rfl
simp [*, ne_of_gt h, top_mul]
rw [← coe_mul, mul_inv_cancel hr, coe_one]
rw [coe_inv _root_.two_ne_zero, coe_two]
rw [div_eq_mul_inv, div_eq_mul_inv, coe_mul, coe_inv hr]
simp [div_eq_mul_inv, h]
rw [div_eq_mul_inv, mul_assoc, inv_mul_cancel h0 hI, mul_one]
rw [mul_comm, div_mul_cancel h0 hI]
simp
simp only [lt_top_iff_ne_top, inv_ne_top, pos_iff_ne_zero]
simp
rw [inv_one]
rw [inv_one]
rw [inv_one]
rw [div_eq_mul_inv, inv_top, mul_zero]
simp [div_eq_mul_inv, top_mul]
simp [div_eq_mul_inv, Ennreal.mul_eq_top]
rw [← inv_inv c]
exact div_le_of_le_mul h
rw [← @Ennreal.mul_le_mul_left _ a _ hr₀ hr₁, ← mul_assoc, mul_inv_cancel hr₀ hr₁, one_mul]
rw [h, mul_div_cancel' ha ha']
rw [← h, mul_div_assoc, mul_div_cancel' ha ha']
rw [← (eq_div_iff hb₀ hb₁).mp h.symm, mul_one]
rw [← two_mul, ← div_eq_mul_inv, div_self two_ne_zero two_ne_top]
rw [div_eq_mul_inv, ← mul_add, inv_two_add_inv_two, mul_one]
rw [div_eq_mul_inv, ← mul_add, ← mul_add, inv_three_add_inv_three, mul_one]
simp [div_eq_mul_inv]
simp [pos_iff_ne_zero, not_or]
simp [h]
simp
simp only [Equiv.coe_fn_mk, Subtype.mk_le_mk, coe_coe, coe_le_coe, Subtype.coe_le_coe]
simp only [inv_lt_inv, Ennreal.exists_nat_gt (inv_ne_top.2 h)]
simp
cases n
· simp only [Int.ofNat_eq_coe, coe_pow, zpow_ofNat]
· have : r ^ n.succ ≠ 0 := pow_ne_zero (n + 1) hr
    simp only [zpow_negSucc, coe_inv this, coe_pow]
cases n
· exact Ennreal.pow_pos ha.bot_lt n
· simp only [h'a, pow_eq_top_iff, zpow_negSucc, Ne.def, not_false_iff, inv_pos, false_and_iff]
cases n
· exact Ennreal.pow_lt_top h'a.lt_top _
· simp only [Ennreal.pow_pos ha.bot_lt (n + 1), zpow_negSucc, inv_lt_top]
simp only [ha, top_add, top_to_real, zero_add, to_real_nonneg]
simp only [hb, add_top, top_to_real, add_zero, to_real_nonneg]
rw [Ennreal.ofReal, Ennreal.ofReal, Ennreal.ofReal, ← coe_add, coe_eq_coe,
    Real.to_nnreal_add hp hq]
simp only [h, (Ennreal.to_real_le_to_real hr hp).2 h, max_eq_right]
simp only [h, (Ennreal.to_real_le_to_real hp hr).2 h, max_eq_left]
simp only [h, (Ennreal.to_real_le_to_real hr hp).2 h, min_eq_left]
simp only [h, (Ennreal.to_real_le_to_real hp hr).2 h, min_eq_right]
induction a using WithTop.recTopCoe <;> simp
simp [Ennreal.ofReal, Real.to_nnreal_le_to_nnreal h]
rw [Ennreal.ofReal, Ennreal.ofReal, coe_le_coe, Real.to_nnreal_le_to_nnreal_iff h]
rw [Ennreal.ofReal, Ennreal.ofReal, coe_eq_coe, Real.to_nnreal_eq_to_nnreal_iff hp hq]
rw [Ennreal.ofReal, Ennreal.ofReal, coe_lt_coe, Real.to_nnreal_lt_to_nnreal_iff h]
rw [Ennreal.ofReal, Ennreal.ofReal, coe_lt_coe, Real.to_nnreal_lt_to_nnreal_iff_of_nonneg hp]
simp [Ennreal.ofReal]
simp [Ennreal.ofReal]
simp only [Ennreal.ofReal, ← coe_mul, Real.to_nnreal_mul hp]
rw [mul_comm, of_real_mul hq, mul_comm]
rw [of_real_eq_coe_nnreal hp, ← coe_pow, ← of_real_coe_nnreal, Nnreal.coe_pow, Nnreal.coe_mk]
simp only [nsmul_eq_mul, ← of_real_coe_nat n, ← of_real_mul n.cast_nonneg]
simp [hx]
rw [div_eq_mul_inv, div_eq_mul_inv, of_real_mul' (inv_nonneg.2 hy.le), of_real_inv_of_pos hy]
simp
simp
rw [Ennreal.to_real_mul, Ennreal.to_real_of_real h]
rw [to_real_mul, top_to_real, mul_zero]
rw [mul_comm]
exact to_real_mul_top _
rw [Ennreal.smul_def, smul_eq_mul, to_real_mul, coe_to_real]
rfl
rw [div_eq_mul_inv, to_nnreal_mul, to_nnreal_inv, div_eq_mul_inv]
rw [div_eq_mul_inv, to_real_mul, to_real_inv, div_eq_mul_inv]
induction x using WithTop.recTopCoe
· simp
· exact to_nnreal_add coe_ne_top coe_ne_top
simp [Ennreal.toReal]
simp [Ennreal.toReal, hx_top]
simp [Ennreal.ofReal]
simp [hr]
simp [Real.to_nnreal_one, bit1]
refine' eq_of_forall_ge_iff fun c => _
rw [tsub_le_iff_right, add_comm, infi_add]
simp [tsub_le_iff_right, sub_eq_add_neg, add_comm]
simp [Inf_eq_infi, infi_add]
rw [add_comm, infi_add] <;> simp [add_comm]
simp [add_infi, infi_add]
simp
intro x hx
rw [abs_div, IsAbsoluteValue.abv_pow abs (-x ^ 2) k, abs_neg, IsAbsoluteValue.abv_pow abs x 2, ←
      pow_mul]
refine' div_le_of_nonneg_of_le_mul (abs_nonneg _) (pow_nonneg (abs_nonneg _) _) _
refine' le_mul_of_one_le_right (pow_nonneg (abs_nonneg _) _) _
rw [abs_of_nonneg (add_nonneg zero_le_one (sq_nonneg x) : (0 : ℝ) ≤ _)]
exact (le_add_of_nonneg_right (sq_nonneg x) : (1 : ℝ) ≤ _)
rw [Nat.cast_zero, zero_div]
rw [zero]
rw [one]
rw [add]
rw [neg]
rw [mul]
rw [inv']
rw [zero]
rw [one]
rw [add]
rw [neg]
rw [mul]
rw [inv']
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
rw [lt] <;> rfl
rw [← of_cauchy_zero] <;> rfl
rw [← of_cauchy_one] <;> rfl
simp [mk, ← of_cauchy_add]
simp [mk, ← of_cauchy_mul]
simp [mk, ← of_cauchy_neg]
rw [← mk_zero, mk_lt] <;> exact iff_of_eq (congr_arg Pos (sub_zero f))
rw [le]
simp [le_def, mk_eq] <;> rfl
induction a using Real.ind_mk
induction b using Real.ind_mk
induction c using Real.ind_mk
simp only [mk_lt, ← mk_add]
show Pos _ ↔ Pos _
rw [add_sub_add_left_eq_sub]
intro a <;> rw [mk_le]
infer_instance

/- ./././Mathport/Syntax/Translate/Tactic/Lean3.lean:132:4: warning: unsupported: rw with cfg: { md := tactic.transparency.semireducible[tactic.transparency.semireducible] } -/
rw [mk_lt]
exact const_lt
rw [sup]
rfl
rw [inf]
rfl
rw [← mk_sup, mk_le]
exact CauSeq.le_sup_left
rw [← mk_sup, mk_le]
exact CauSeq.le_sup_right
rw [← mk_inf, mk_le]
exact CauSeq.inf_le_left
rw [← mk_inf, mk_le]
exact CauSeq.inf_le_right
simp only [← mk_sup, ← mk_inf]
exact congr_arg mk (CauSeq.sup_inf_distrib_left _ _ _).symm
infer_instance
infer_instance
simp [← of_cauchy_zero, ← of_cauchy_inv]
rw [← of_cauchy_rat_cast, Rat.cast_mk', of_cauchy_mul, of_cauchy_inv, of_cauchy_nat_cast,
        of_cauchy_int_cast]
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
simp [H _ ij]
refine' ⟨_, fun j ij => abs_lt.2 ⟨_, this _ ij _ le_rfl⟩⟩
rw [neg_lt, neg_sub]
exact this _ le_rfl _ ij
simp only [Sup_def, dif_pos (And.intro h₁ h₂)]
apply Classical.choose_spec
rw [Inf_def, ← is_lub_neg', neg_neg]
exact Real.is_lub_Sup _ h₁.neg h₂.neg
simp
cases isEmpty_or_nonempty α
· exact Real.csupr_empty _
· exact csupr_const
simp [Inf_def, Sup_empty]
rw [infi_of_empty', Inf_empty]
cases isEmpty_or_nonempty α
· exact Real.cinfi_empty _
· exact cinfi_const
rw [eq_comm, sq, zero_mul]
rw [← sq, sq_sqrt]
rw [← sq, sqrt_sq x]
rw [sqrt_eq_iff_sq_eq, mul_pow, sq_sqrt, sq_sqrt]
rw [sqrt_aux, Rat.mk_nat_eq, Rat.mk_eq_div] <;> apply div_nonneg <;>
      exact Int.cast_nonneg.2 (Int.ofNat_nonneg _)
rw [Real.sqrt, Real.to_nnreal_coe]
simp [sqrt, Real.to_nnreal_eq_zero.2 h]
rw [sqrt, ← Nnreal.coe_mul, Nnreal.mul_self_sqrt, Real.coe_to_nnreal _ h]
rw [← h, mul_self_sqrt hx]
rw [← h, sqrt_mul_self hy]
simp [sqrt_eq_cases, h.ne', h.le]
rw [eq_comm, mul_one]
rw [sq, mul_self_sqrt h]
rw [sq, sqrt_mul_self h]
rw [sq, sqrt_eq_iff_mul_self_eq hx hy]
rw [← abs_mul_abs_self x, sqrt_mul_self (abs_nonneg _)]
rw [sq, sqrt_mul_self_eq_abs]
simp [sqrt]
simp [sqrt]
rw [sqrt, sqrt, Nnreal.coe_le_coe, Nnreal.sqrt_le_sqrt_iff, Real.to_nnreal_le_to_nnreal_iff hy]
rw [sqrt, sqrt, Nnreal.coe_lt_coe, Nnreal.sqrt_lt_sqrt_iff, to_nnreal_lt_to_nnreal_iff hy]
rw [sqrt, sqrt, Nnreal.coe_le_coe, Nnreal.sqrt_le_sqrt_iff]
exact to_nnreal_le_to_nnreal h
rw [sqrt, ← Real.le_to_nnreal_iff_coe_le hy, Nnreal.sqrt_le_iff, sq, ← Real.to_nnreal_mul hy,
    Real.to_nnreal_le_to_nnreal_iff (mul_self_nonneg y), sq]
rw [← and_iff_right_of_imp fun h => (sqrt_nonneg x).trans h, and_congr_right_iff]
exact sqrt_le_left
rw [← sqrt_lt_sqrt_iff hx, sqrt_sq hy]
rw [← sqrt_lt_sqrt_iff_of_pos (pow_pos hy _), sqrt_sq hy.le]
rw [← sqrt_sq_eq_abs] <;> exact sqrt_le_sqrt h
simp [le_antisymm_iff, hx, hy]
rw [sqrt, Nnreal.coe_eq_zero, Nnreal.sqrt_eq_zero, Real.to_nnreal_eq_zero]
rw [not_iff_not, sqrt_eq_zero h]
rw [← not_le, not_iff_not, sqrt_eq_zero']
simp [le_antisymm_iff, sqrt_nonneg]
rw [mul_comm, sqrt_mul hy, mul_comm]
rw [sqrt, Real.to_nnreal_inv, Nnreal.sqrt_inv, Nnreal.coe_inv, sqrt]
rw [division_def, sqrt_mul hx, sqrt_inv, division_def]
cases le_or_lt x 0
· rw [sqrt_eq_zero'.mpr h, div_zero]
· rw [div_eq_iff (sqrt_ne_zero'.mpr h), mul_self_sqrt h.le]
rw [← div_sqrt, one_div_div, div_sqrt]
rw [sqrt_div_self', one_div]
rw [← sqrt_lt_sqrt_iff (sq_nonneg _), sqrt_sq hx]
rw [← abs_lt, ← sq_abs, lt_sqrt (abs_nonneg _)]
rw [← sqrt_mul hr, sqrt_mul_self hr]
refine' ⟨K * ε * K, mul_pos (mul_pos K0 ε0) K0, fun a b ha hb h => _⟩
have a0 := K0.trans_le ha
have b0 := K0.trans_le hb
rw [inv_sub_inv' ((abv_pos abv).1 a0) ((abv_pos abv).1 b0), abv_mul abv, abv_mul abv, abv_inv abv,
    abv_inv abv, abv_sub abv]
refine' lt_of_mul_lt_mul_left (lt_of_mul_lt_mul_right _ b0.le) a0.le
rw [mul_assoc, inv_mul_cancel_right₀ b0.ne', ← mul_assoc, mul_inv_cancel a0.ne', one_mul]
refine' h.trans_le _
exact mul_le_mul (mul_le_mul ha le_rfl ε0.le a0.le) hb K0.le (mul_nonneg a0.le ε0.le)
refine' (hf _ (half_pos ε0)).imp fun i hi j ij k ik => _
rw [← add_halves ε]
refine' lt_of_le_of_lt (abv_sub_le abv _ _ _) (add_lt_add (hi _ ij) _)
rw [abv_sub abv]
exact hi _ ik
rw [show g = f from (funext e).symm] <;> exact f.cauchy
simp [hR]
simp
simp [sub_eq_add_neg]
induction n <;> simp [*, npowRec, pow_succ]
intros <;> apply ext <;> simp [mul_left_comm, mul_comm]
rw [← neg_one_mul] <;> exact mul_lim_zero_right _ hf
simp [zero_lim_zero]
rw [← const_sub, const_lim_zero, sub_eq_zero]
simp [zero_lim_zero]
rw [← const_sub, const_pos, sub_pos]
rw [le_iff_lt_or_eq] <;> exact or_congr const_lt const_equiv
rw [sub_apply, const_apply, le_sub_iff_add_le', add_le_add_iff_right]
exact le_of_lt (abs_lt.1 (H _)).2
let ⟨H₁, H₂⟩ := H _ ij
rw [abs_lt] at H₁ H₂⊢
exact ⟨lt_sup_iff.mpr (Or.inl H₁.1), sup_lt_iff.mpr ⟨H₁.2, H₂.2⟩⟩
let ⟨H₁, H₂⟩ := H _ ij
rw [abs_lt] at H₁ H₂⊢
exact ⟨lt_inf_iff.mpr ⟨H₁.1, H₂.1⟩, inf_lt_iff.mpr (Or.inl H₁.2)⟩
rw [h.conj_eq]
exact (one_lt_div h.sub_one_pos).mpr (sub_one_lt p)
rw [← Real.to_nnreal_one, Real.to_nnreal_lt_to_nnreal_iff h.pos]
exact h.one_lt
rw [← Real.to_nnreal_one, ← Real.to_nnreal_div' h.nonneg, ← Real.to_nnreal_div' h.symm.nonneg, ←
    Real.to_nnreal_add h.one_div_nonneg h.symm.one_div_nonneg, h.inv_add_inv_conj]
rw [← Ennreal.of_real_one, ← Ennreal.of_real_div_of_pos h.pos, ←
    Ennreal.of_real_div_of_pos h.symm.pos, ←
    Ennreal.of_real_add h.one_div_nonneg h.symm.one_div_nonneg, h.inv_add_inv_conj]
simp [cantor_function_aux, h]
simp [cantor_function_aux, h]
cases h' : f n <;> simp [h']
apply pow_nonneg h
simp [cantor_function_aux, h]
apply (summable_geometric_of_lt_1 h1 h2).summable_of_eq_zero_or_self
intro n
cases h : f n <;> simp [h]
rw [cantor_function, tsum_eq_zero_add (summable_cantor_function f h1 h2)]
rw [cantor_function_aux_succ, tsum_mul_left, cantor_function_aux, pow_zero]
rfl
intro n hn
cases n
rw [fn] at hn
contradiction
apply rfl
intro n hn
cases n
rw [gn]
apply rfl
contradiction
intro k hk
apply of_not_not
exact Nat.find_min this hk
rw [mk_univ, mk_real]
rw [← le_aleph_0_iff_set_countable, not_le, mk_univ_real]
apply cantor
simp only [Real.mul_infi_of_nonneg ha, mul_comm]
simp only [Real.mul_supr_of_nonneg ha, mul_comm]
simp only [Real.mul_infi_of_nonpos ha, mul_comm]
simp only [Real.mul_supr_of_nonpos ha, mul_comm]
simp only [Irrational, Rat.forall, cast_mk, not_exists, Set.mem_range, cast_coe_int, cast_div,
    eq_comm]
rw [Int.cast_ne_zero, Int.coe_nat_ne_zero]
exact ne_of_gt P
rw [← Nat.gcd_eq_right hdivn, C.gcd_eq_one]
rw [Hpv] <;> exact one_ne_zero
simp [multiplicity_self (mt isUnit_iff_dvd_one.1 (mt Int.coe_nat_dvd.1 hp.not_dvd_one) : _)] <;>
      rfl
rw [← H1, cast_mul, sqrt_mul_self (cast_nonneg.2 <| Rat.sqrt_nonneg q), sqrt_eq,
            abs_of_nonneg (Rat.sqrt_nonneg q)]
rw [cast_zero] <;>
              exact (sqrt_eq_zero_of_nonpos (Rat.cast_nonpos.2 <| le_of_not_le H2)).symm
rw [← Rat.cast_coe_int]
exact h.ne_rat _
rw [← cast_coe_int] at h
exact h.of_rat_add m
rw [← cast_coe_int]
exact h.rat_add m
rw [cast_neg, hx]
rw [div_eq_mul_inv, ← cast_inv]
exact h.mul_rat (inv_ne_zero hq)
rw [pow_zero] at h
exact (h ⟨1, cast_one⟩).elim
rw [pow_succ] at h
exact h.mul_cases.elim id (of_pow n)
rw [zpow_negSucc] at h
exact h.of_inv.of_pow _
rw [mul_comm, irrational_rat_mul_iff]
rw [← cast_coe_int, irrational_rat_mul_iff, Int.cast_ne_zero]
rw [← cast_coe_int, irrational_mul_rat_iff, Int.cast_ne_zero]
rw [← cast_coe_nat, irrational_rat_mul_iff, Nat.cast_ne_zero]
rw [← cast_coe_nat, irrational_mul_rat_iff, Nat.cast_ne_zero]
simp [div_eq_mul_inv]
rw [div_eq_mul_inv, ← cast_inv, irrational_mul_rat_iff, Ne.def, inv_eq_zero]
simp [div_eq_mul_inv]
rw [← cast_coe_int, irrational_div_rat_iff, Int.cast_ne_zero]
simp [div_eq_mul_inv]
rw [← cast_coe_nat, irrational_div_rat_iff, Nat.cast_ne_zero]
induction x using Ereal.rec <;>
        · dsimp only [(· * ·)]
          simp only [Ereal.mul, ← Ereal.coe_one, zero_lt_one, if_true, one_mul]
induction x using Ereal.rec <;>
        · dsimp only [(· * ·)]
          simp only [Ereal.mul, ← Ereal.coe_one, zero_lt_one, if_true, mul_one]
induction x using Ereal.rec <;>
        · simp only [(· * ·)]
          simp only [Ereal.mul, ← Ereal.coe_zero, zero_lt_one, if_true, if_false, lt_irrefl (0 : ℝ),
            eq_self_iff_true, zero_mul]
induction x using Ereal.rec <;>
        · simp only [(· * ·)]
          simp only [Ereal.mul, ← Ereal.coe_zero, zero_lt_one, if_true, if_false, lt_irrefl (0 : ℝ),
            eq_self_iff_true, mul_zero]
apply WithBot.coe_lt_coe.2
exact WithTop.coe_lt_top _
simp
simp only [Ennreal.coe_ne_top, iff_false_iff, Ennreal.some_eq_coe]
decide
decide
decide
simp
simp
simp
simp [coe_nnreal_eq_coe_real]
rw [← coe_ennreal_eq_coe_ennreal_iff, coe_ennreal_zero]
rw [← coe_ennreal_eq_coe_ennreal_iff, coe_ennreal_one]
rw [← coe_ennreal_zero, coe_ennreal_lt_coe_ennreal_iff]
cases x <;> cases y <;> rfl
simp only [Ennreal.coe_eq_zero] at h
exact Nnreal.coe_pos.2 (bot_lt_iff_ne_bot.2 h)
simp only [Ennreal.coe_eq_zero] at h
exact Nnreal.coe_pos.2 (bot_lt_iff_ne_bot.2 h)
simp [← Ennreal.coe_mul, coe_nnreal_eq_coe_real]
simp [exists_rat_btwn (Ereal.coe_lt_coe_iff.1 h)]
simp
simp
simp [← Ereal.coe_add]
induction x using Ereal.rec
· simp [bot_lt_iff_ne_bot, h1.ne', (bot_le.trans_lt h2).ne']
·
    calc
      (x : Ereal) + z < x + t := add_lt_add_left_coe h2 _
      _ ≤ y + t := add_le_add h1.le le_rfl
· exact (lt_irrefl _ (h1.trans_le le_top)).elim
induction x using Ereal.rec <;> induction y using Ereal.rec <;> simp [← Ereal.coe_add]
simp [bot_lt_iff_ne_bot, not_or]
rw [← Ereal.top_add_top]
exact Ereal.add_lt_add hx.lt_top hy.lt_top
change ((-0 : ℝ) : Ereal) = 0
simp
simp
simp
rw [neg_eq_iff_neg_eq]
simp [eq_comm]
rw [neg_eq_iff_neg_eq]
simp [eq_comm]
rw [neg_eq_iff_neg_eq]
simp [eq_comm]
apply lt_of_le_of_ne (Ereal.neg_le_of_neg_le h.le)
intro H
rw [← H, neg_neg] at h
exact lt_irrefl _ h
simp [ht]
simp [hz]
simp
induction x using Ereal.rec <;> induction y using Ereal.rec <;> try rfl
dsimp only [(· * ·)]
simp only [Ereal.mul, mul_comm]
rw [Ereal.mul_comm]
exact mul_top_of_pos h
rw [Ereal.mul_comm]
exact mul_top_of_neg h
rw [Ereal.mul_comm]
exact mul_bot_of_pos h
rw [Ereal.mul_comm]
exact mul_bot_of_neg h
induction x using Ereal.rec
· simp only [abs_bot, Ennreal.top_ne_zero, bot_ne_zero]
· simp only [Ereal.abs, coe_eq_zero, Ennreal.of_real_eq_zero, abs_nonpos_iff]
· simp only [abs_top, Ennreal.top_ne_zero, top_ne_zero]
rw [abs_eq_zero_iff]
simp only [sign, OrderHom.coe_fun_mk, Ereal.coe_pos, Ereal.coe_neg']
rw [← sign_eq_and_abs_eq_iff_eq]
simp only [mul_assoc, abs_mul, eq_self_iff_true, sign_mul, and_self_iff]
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
simp [show (r₂ : ℝ) ≤ r₁ from h]
rw [← Nnreal.coe_zero, Nnreal.coe_eq]
rw [← Nnreal.coe_one, Nnreal.coe_eq]
infer_instance
simp [Algebra.commutes]
simp [← Algebra.smul_def (r : ℝ) x, smul_def]
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
cases n <;> simp
rw [Real.coe_to_nnreal _ (hf x hxs)]
rw [Real.coe_to_nnreal _ (hf x hxs)]
infer_instance
simp [Real.coe_to_nnreal]
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
rw [supr, supr, coe_Sup, Set.range_comp]
rw [← Nnreal.coe_eq_zero, coe_Inf, Set.image_empty, Real.Inf_empty]
rw [infi, infi, coe_Inf, Set.range_comp]
rw [← Nnreal.coe_le_coe, Nnreal.coe_add, coe_infi, coe_infi]
exact le_cinfi_add_cinfi h
infer_instance

-- TODO: why are these three instances necessary? why aren't they inferred?
simp [Real.coe_to_nnreal _ this, nnreal.coe_lt_coe.symm, haq, hqb]
simp only [div_eq_inv_mul, mul_finset_sup]
simp [Real.toNnreal] <;> rfl
simp [Real.toNnreal, max_eq_left (zero_le_one : (0 : ℝ) ≤ 1)] <;> rfl
simp [Real.toNnreal, nnreal.coe_lt_coe.symm, lt_irrefl]
simp [nnreal.coe_le_coe.symm, Real.toNnreal, hp]
simp [← Nnreal.coe_eq, coe_to_nnreal, hr, hp]
simp [Real.toNnreal, hr, hp, add_nonneg]
rw [← Nnreal.coe_le_coe, Real.coe_to_nnreal p hp]
simp only [(hp.trans_le r.coe_nonneg).not_le, to_nnreal_eq_zero.2 hp.le, hr.not_le]
rw [← Nnreal.coe_lt_coe, Real.coe_to_nnreal r ha]
cases le_total 0 p
· rw [← Nnreal.coe_lt_coe, Real.coe_to_nnreal p h]
· rw [to_nnreal_eq_zero.2 h]
    constructor
    · intro
      have := not_lt_of_le (zero_le r)
      contradiction
    · intro rp
      have : ¬p ≤ 0 := not_le_of_lt (lt_of_le_of_lt (Nnreal.coe_nonneg _) rp)
      contradiction
simp [hr]
simp [bit1]
rw [← Nnreal.coe_eq, Nnreal.coe_pow, Real.coe_to_nnreal _ (pow_nonneg hx _),
    Real.coe_to_nnreal x hx]
rw [mul_eq_mul_left_iff, or_iff_left h]
infer_instance
rw [← mul_le_mul_left (pos_iff_ne_zero.2 h), mul_inv_cancel h]
rw [← mul_le_mul_left (pos_iff_ne_zero.2 h), mul_inv_cancel h, mul_comm]
rw [← mul_lt_mul_left (pos_iff_ne_zero.2 h), mul_inv_cancel h, mul_comm]
have : 0 < r := lt_of_le_of_ne (zero_le r) hr.symm
rw [← mul_le_mul_left (inv_pos.mpr this), ← mul_assoc, inv_mul_cancel hr, one_mul]
simp [h0]
rw [div_eq_mul_inv, div_eq_mul_inv, ← Real.to_nnreal_inv, ← Real.to_nnreal_mul hx]
rw [div_eq_inv_mul, div_eq_inv_mul, Real.to_nnreal_mul (inv_nonneg.2 hy), Real.to_nnreal_inv]
cases n
· simp [pow_pos hx.bot_lt _]
· simp [pow_pos hx.bot_lt _]
rw [← bdd_above_coe] at hs
rw [← Nnreal.coe_eq, coe_Sup]
exact Sup_of_not_bdd_above hs
rw [← Nnreal.coe_eq, coe_infi]
exact Real.cinfi_empty _
rw [← Nnreal.coe_eq, coe_infi]
exact Real.cinfi_const_zero
rw [← Nnreal.coe_eq, Nnreal.coe_mul, coe_infi, coe_infi]
exact Real.infi_mul_of_nonneg (Nnreal.coe_nonneg _) _
rw [← Nnreal.coe_eq, Nnreal.coe_mul, Nnreal.coe_supr, Nnreal.coe_supr]
exact Real.mul_supr_of_nonneg (Nnreal.coe_nonneg _) _
simp only [div_eq_mul_inv, supr_mul]
rw [mul_infi]
exact le_cinfi H
rw [mul_supr]
exact csupr_le H
rw [infi_mul]
exact le_cinfi H
rw [supr_mul]
exact csupr_le H
simp
rw [mem_Icc] at *
exact ⟨sub_nonneg.2 ht.2, (sub_le_self_iff _).2 ht.1⟩
rw [mem_Ioo] at *
refine' ⟨sub_pos.2 ht.2, _⟩
exact lt_of_le_of_ne ((sub_le_self_iff 1).2 ht.1.le) (mt sub_eq_self.mp ht.1.ne')
rw [abs_div, abs_of_pos H]
rw [mem_ord_connected_component, dual_interval]
rfl
rw [mem_ord_connected_component, interval_self, singleton_subset_iff]
rw [← not_nonempty_iff_eq_empty, nonempty_ord_connected_component]
simp [ord_connected_component]
simp [ord_connected_component, set_of_and]
rw [mem_ord_connected_component, mem_ord_connected_component, interval_swap]
constructor <;> intro h
· rw [← mem_ord_connected_component, ← ord_connected_component_ord_connected_proj, h,
      ord_connected_component_ord_connected_proj, self_mem_ord_connected_component]
    exact y.2
· simp only [ord_connected_proj]
    congr 1
    exact ord_connected_component_eq h
simp only [ord_connected_section, ord_connected_proj]
congr 1
simp only [ord_separating_set, mem_preimage, ← to_dual.surjective.Union_comp, of_dual_to_dual,
    dual_ord_connected_component, ← preimage_compl, preimage_inter, preimage_Union]
simp [Pi.le_def]
simp [Pi.le_def]
simp [Pi.le_def, forall_and]
rw [← Ioi_inter_Iic, ← Ioi_inter_Iic, ← inter_assoc,
      inter_eq_self_of_subset_left (Ioi_subset_Ioi hm)]
rw [← Ioi_inter_Iic, ← Ioi_inter_Iic, inter_left_comm,
      inter_eq_self_of_subset_left (Iic_subset_Iic.2 hm)]
rw [Set.disjoint_iff_inter_eq_empty, Ici_inter_Iic, Icc_eq_empty_iff]
simp only [← Ici_inter_Iic, ← inter_Union, Union_Iic, inter_univ]
simp only [← Ioi_inter_Iic, ← inter_Union, Union_Iic, inter_univ]
simp only [← Ici_inter_Iic, ← Union_inter, Union_Ici, univ_inter]
simp only [← Ici_inter_Iio, ← Union_inter, Union_Ici, univ_inter]
simp only [← Ici_inter_Iio, ← inter_Union, Union_Iio, inter_univ]
simp only [← Ioi_inter_Iio, ← inter_Union, Union_Iio, inter_univ]
simp only [← Ioi_inter_Iic, ← Union_inter, Union_Ioi, univ_inter]
simp only [← Ioi_inter_Iio, ← Union_inter, Union_Ioi, univ_inter]
rw [Ico_disjoint_Ico, min_eq_left (le_of_lt h2.2), le_max_iff] at h
apply le_antisymm h2.1
exact h.elim (fun h => absurd hx (not_lt_of_le h)) id
simp [← Ici_inter_Iio, ← Union_inter, subset_def]
simp [← Ioi_inter_Iic, ← inter_Union, subset_def]
simp [← Ici_inter_Iio, ← Union_inter, subset_def]
simp [← Ioi_inter_Iic, ← inter_Union, subset_def]
refine' (Union₂_subset fun x hx => _).antisymm fun x hx => _
· exact Ici_subset_Ici.mpr (mem_lower_bounds.mp a_glb.1 x hx)
· apply mem_Union₂.mpr
    refine' ⟨a, a_mem, hx⟩
simp only [← IsGlb.bUnion_Ici_eq_Ioi (@is_glb_infi _ _ _ f) no_least_elem, mem_range,
    Union_exists, Union_Union_eq']
simp only [← IsGlb.bUnion_Ici_eq_Ici (@is_glb_infi _ _ _ f) has_least_elem, mem_range,
    Union_exists, Union_Union_eq']
rw [add_right_comm]
rw [add_right_comm]
rw [← Ici_inter_Iic, ← Ici_inter_Iic]
exact
    (Ici_add_bij a d).inter_maps_to (fun x hx => add_le_add_right hx _) fun x hx =>
      le_of_add_le_add_right hx.2
rw [← Ioi_inter_Iio, ← Ioi_inter_Iio]
exact
    (Ioi_add_bij a d).inter_maps_to (fun x hx => add_lt_add_right hx _) fun x hx =>
      lt_of_add_lt_add_right hx.2
rw [← Ioi_inter_Iic, ← Ioi_inter_Iic]
exact
    (Ioi_add_bij a d).inter_maps_to (fun x hx => add_le_add_right hx _) fun x hx =>
      le_of_add_le_add_right hx.2
rw [← Ici_inter_Iio, ← Ici_inter_Iio]
exact
    (Ici_add_bij a d).inter_maps_to (fun x hx => add_lt_add_right hx _) fun x hx =>
      lt_of_add_lt_add_right hx.2
simp only [add_comm a, image_add_const_Ici]
simp only [add_comm a, image_add_const_Ioi]
simp only [add_comm a, image_add_const_Icc]
simp only [add_comm a, image_add_const_Ico]
simp only [add_comm a, image_add_const_Ioc]
simp only [add_comm a, image_add_const_Ioo]
rw [← compl_Iic, ← compl_compl (Ioi (f a))]
refine' maps_to.surj_on_compl _ h_surj
exact fun x hx => (h_mono hx).not_lt
rw [← Ioi_union_left, ← Ioi_union_left]
exact
    (surj_on_Ioi_of_monotone_surjective h_mono h_surj a).union_union
      (@image_singleton _ _ f a ▸ surj_on_image _ _)
rw [← Icc_self]
exact ord_connected_Icc
rw [interval_swap]
assumption
assumption
assumption
assumption
assumption
assumption
assumption
assumption
simp [lt_irrefl]
simp [le_refl]
simp [le_refl]
simp [lt_irrefl]
simp
simp [lt_irrefl]
simp [lt_irrefl]
simp [le_refl]
simp [le_refl]
simp
rw [← not_nonempty_iff_eq_empty, not_iff_not, nonempty_Icc]
rw [← not_nonempty_iff_eq_empty, not_iff_not, nonempty_Ico]
rw [← not_nonempty_iff_eq_empty, not_iff_not, nonempty_Ioc]
rw [← not_nonempty_iff_eq_empty, not_iff_not, nonempty_Ioo]
simp [Icc, le_antisymm_iff, and_comm']
simp [lt_iff_le_and_ne, eq_comm, and_right_comm]
simp [lt_iff_le_and_ne, and_assoc']
simp [and_right_comm, ← lt_iff_le_and_ne, eq_comm]
simp [and_assoc', ← lt_iff_le_and_ne]
rw [insert_eq, ← diff_diff, Icc_diff_left, Ioc_diff_right]
simp [lt_iff_le_and_ne, eq_comm]
simp [lt_iff_le_and_ne]
rw [← Ico_diff_left, diff_diff_cancel_left (singleton_subset_iff.2 <| left_mem_Ico.2 h)]
rw [← Ioc_diff_right, diff_diff_cancel_left (singleton_subset_iff.2 <| right_mem_Ioc.2 h)]
rw [← Icc_diff_right, diff_diff_cancel_left (singleton_subset_iff.2 <| right_mem_Icc.2 h)]
rw [← Icc_diff_left, diff_diff_cancel_left (singleton_subset_iff.2 <| left_mem_Icc.2 h)]
rw [← Icc_diff_both, diff_diff_cancel_left]
simp [insert_subset, h]
rw [← Ici_diff_left, diff_diff_cancel_left (singleton_subset_iff.2 left_mem_Ici)]
rw [← Iic_diff_right, diff_diff_cancel_left (singleton_subset_iff.2 right_mem_Iic)]
simp [eq_comm, le_iff_eq_or_lt]
rw [← Ico_diff_left, diff_union_self,
    union_eq_self_of_subset_right (singleton_subset_iff.2 <| left_mem_Ico.2 hab)]
rw [← Icc_diff_left, diff_union_self,
    union_eq_self_of_subset_right (singleton_subset_iff.2 <| left_mem_Icc.2 hab)]
rw [insert_eq, union_comm, Ico_union_right h]
rw [insert_eq, union_comm, Ioc_union_left h]
rw [insert_eq, union_comm, Ioo_union_left h]
rw [insert_eq, union_comm, Ioo_union_right h]
rw [← Ioi_union_left, union_subset_iff] <;> simp [*]
simp [← Ici_inter_Iic]
simp [← Ioi_inter_Iic]
simp [← Ici_inter_Iic]
simp [← Ici_inter_Iio]
simp
rw [diff_eq, compl_Ici, Ici_inter_Iio]
rw [diff_eq, compl_Ioi, Ici_inter_Iic]
rw [diff_eq, compl_Ioi, Ioi_inter_Iic]
rw [diff_eq, compl_Ici, Ioi_inter_Iio]
rw [diff_eq, compl_Iic, inter_comm, Ioi_inter_Iic]
rw [diff_eq, compl_Iic, inter_comm, Ioi_inter_Iio]
rw [diff_eq, compl_Iio, inter_comm, Ici_inter_Iic]
rw [diff_eq, compl_Iio, inter_comm, Ici_inter_Iio]
rw [h₁, h₂]
refine' ⟨fun h => _, fun h => Ioi_subset_Ioi h⟩
refine' ⟨fun h => _, fun h => Ioi_subset_Ici h⟩
refine' ⟨fun h => _, fun h => Iio_subset_Iio h⟩
rw [← diff_eq_empty, Iio_diff_Iic, Ioo_eq_empty_iff, not_lt]
rw [← Ioi_inter_Iic, ← Ioi_inter_Iic, inter_assoc, Iic_inter_Iic]
rw [← Ici_inter_Iio, ← Ici_inter_Iio, ← Ici_inter_Ici, inter_right_comm]
simp only [Ici_inter_Iic.symm, Ici_inter_Ici.symm, Iic_inter_Iic.symm] <;> ac_rfl
rw [Icc_inter_Icc, sup_of_le_right hab, inf_of_le_left hbc, Icc_self]
simp only [Ici_inter_Iio.symm, Ici_inter_Ici.symm, Iio_inter_Iio.symm] <;> ac_rfl
simp only [Ioi_inter_Iic.symm, Ioi_inter_Ioi.symm, Iic_inter_Iic.symm] <;> ac_rfl
simp only [Ioi_inter_Iio.symm, Ioi_inter_Ioi.symm, Iio_inter_Iio.symm] <;> ac_rfl
simp [and_assoc', @and_left_comm (x ≤ _), and_iff_left_iff_imp.2 fun h' => lt_of_le_of_lt h' h]
simp [and_assoc', @and_left_comm (x ≤ _),
      and_iff_right_iff_imp.2 fun h' => (le_of_lt h').trans h]
rw [inter_comm, Ioc_inter_Ioo_of_right_le h, max_comm]
rw [inter_comm, Ioc_inter_Ioo_of_left_lt h, max_comm]
rw [diff_eq, compl_Iio, Ico_inter_Ici, sup_eq_max]
simp (config := { contextual := true }) [iff_def]
rw [← Ioi_inter_Iic, inter_assoc, inter_comm, inter_assoc, Ioi_inter_Ioi, inter_comm,
    Ioi_inter_Iic, sup_comm]
simp (config := { contextual := true }) [iff_def]
rw [diff_eq, compl_Iic, Ioc_inter_Ioi, sup_eq_max]
rw [Ioc_union_Ioc, min_self] <;> exact (min_le_left _ _).trans (le_max_left _ _)
rw [Ioc_union_Ioc, max_self] <;> exact (min_le_right _ _).trans (le_max_right _ _)
rw [max_comm]
apply Ioc_union_Ioc <;> rw [max_comm] <;> exact min_le_max
simp
rw [interval, inf_eq_left.2 h, sup_eq_right.2 h]
rw [interval, inf_eq_right.2 h, sup_eq_left.2 h]
simp [interval]
rw [ext_iff] at h
exact eq_of_mem_interval_of_mem_interval ((h _).1 left_mem_interval) ((h _).2 left_mem_interval)
rw [Icc_union_Icc', max_comm] <;> rfl
simp [interval_eq_union]
simp [monotone_on_iff_monotone, antitone_on_iff_antitone, monotone_or_antitone_iff_interval,
    mem_interval]
simp [interval_oc, h]
simp [interval_oc, le_of_lt h]
cases le_total a b <;> simp [interval_oc, *]
simp only [interval_oc_eq_union, mem_union, mem_Ioc]
simp [mem_interval_oc]
simp [mem_interval_oc]
simp only [interval_oc_eq_union, mem_union, or_imp, forall_and]
simp only [interval_oc, min_comm a b, max_comm a b]
simp [proj_Icc, hx, hx.trans h]
simp [proj_Icc, hx, h]
simp [h.ne', h']
simp [proj_Icc, hx.1, hx.2]
cases x
apply proj_Icc_of_mem
simp only [Icc_extend, range_comp f, range_proj_Icc, range_id']
simp [← Ici_inter_Iic]
simp [← Ici_inter_Iio]
simp [← Ioi_inter_Iic]
simp [← Ioi_inter_Iio]
rw [e.image_eq_preimage, e.symm.preimage_Iic, e.symm_symm]
rw [e.image_eq_preimage, e.symm.preimage_Iio, e.symm_symm]
rw [e.image_eq_preimage, e.symm.preimage_Ioo, e.symm_symm]
rw [e.image_eq_preimage, e.symm.preimage_Ioc, e.symm_symm]
rw [e.image_eq_preimage, e.symm.preimage_Ico, e.symm_symm]
rw [e.image_eq_preimage, e.symm.preimage_Icc, e.symm_symm]
rfl
rfl
simp [← Ici_inter_Iic]
simp [← Ici_inter_Iio]
simp [← Ioi_inter_Iic]
simp [← Ioi_inter_Iio]
rw [← range_coe, preimage_range]
simp [← Ici_inter_Iio]
simp [← Ioi_inter_Iio]
rw [← preimage_coe_Ioi, image_preimage_eq_inter_range, range_coe, Ioi_inter_Iio]
rw [← preimage_coe_Ici, image_preimage_eq_inter_range, range_coe, Ici_inter_Iio]
rw [← preimage_coe_Iio, image_preimage_eq_inter_range, range_coe,
    inter_eq_self_of_subset_left (Iio_subset_Iio le_top)]
rw [← preimage_coe_Iic, image_preimage_eq_inter_range, range_coe,
    inter_eq_self_of_subset_left (Iic_subset_Iio.2 <| coe_lt_top a)]
rw [← preimage_coe_Icc, image_preimage_eq_inter_range, range_coe,
    inter_eq_self_of_subset_left
      (subset.trans Icc_subset_Iic_self <| Iic_subset_Iio.2 <| coe_lt_top b)]
rw [← preimage_coe_Ico, image_preimage_eq_inter_range, range_coe,
    inter_eq_self_of_subset_left (subset.trans Ico_subset_Iio_self <| Iio_subset_Iio le_top)]
rw [← preimage_coe_Ioc, image_preimage_eq_inter_range, range_coe,
    inter_eq_self_of_subset_left
      (subset.trans Ioc_subset_Iic_self <| Iic_subset_Iio.2 <| coe_lt_top b)]
rw [← preimage_coe_Ioo, image_preimage_eq_inter_range, range_coe,
    inter_eq_self_of_subset_left (subset.trans Ioo_subset_Iio_self <| Iio_subset_Iio le_top)]
simp [← Ici_inter_Iic]
simp [← Ici_inter_Iio]
simp [← Ioi_inter_Iic]
simp [← Ioi_inter_Iio]
rw [← range_coe, preimage_range]
simp [← Ioi_inter_Iic]
simp [← Ioi_inter_Iio]
rw [← preimage_coe_Iio, image_preimage_eq_inter_range, range_coe, inter_comm, Ioi_inter_Iio]
rw [← preimage_coe_Iic, image_preimage_eq_inter_range, range_coe, inter_comm, Ioi_inter_Iic]
rw [← preimage_coe_Ioi, image_preimage_eq_inter_range, range_coe,
    inter_eq_self_of_subset_left (Ioi_subset_Ioi bot_le)]
rw [← preimage_coe_Ici, image_preimage_eq_inter_range, range_coe,
    inter_eq_self_of_subset_left (Ici_subset_Ioi.2 <| bot_lt_coe a)]
rw [← preimage_coe_Icc, image_preimage_eq_inter_range, range_coe,
    inter_eq_self_of_subset_left
      (subset.trans Icc_subset_Ici_self <| Ici_subset_Ioi.2 <| bot_lt_coe a)]
rw [← preimage_coe_Ioc, image_preimage_eq_inter_range, range_coe,
    inter_eq_self_of_subset_left (subset.trans Ioc_subset_Ioi_self <| Ioi_subset_Ioi bot_le)]
rw [← preimage_coe_Ico, image_preimage_eq_inter_range, range_coe,
    inter_eq_self_of_subset_left
      (subset.trans Ico_subset_Ici_self <| Ici_subset_Ioi.2 <| bot_lt_coe a)]
rw [← preimage_coe_Ioo, image_preimage_eq_inter_range, range_coe,
    inter_eq_self_of_subset_left (subset.trans Ioo_subset_Ioi_self <| Ioi_subset_Ioi bot_le)]
rw [image_one, map_one, singleton_one]
rw [mem_finset_prod]
simp
simp [← Ici_inter_Iic]
simp [← Ici_inter_Iio]
simp [← Ioi_inter_Iic]
simp [← Ioi_inter_Iio]
simp [← Ici_inter_Iic]
simp [← Ici_inter_Iio]
simp [← Ioi_inter_Iic]
simp [← Ioi_inter_Iio]
simp [← Ici_inter_Iic, inter_comm]
simp [← Ici_inter_Iio, ← Ioi_inter_Iic, inter_comm]
simp [← Ioi_inter_Iic, ← Ici_inter_Iio, inter_comm]
simp [← Ioi_inter_Iio, inter_comm]
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
simp [← Ici_inter_Iic, inter_comm]
simp [← Ioi_inter_Iic, ← Ici_inter_Iio, inter_comm]
simp [← Ioi_inter_Iic, ← Ici_inter_Iio, inter_comm]
simp [← Ioi_inter_Iio, inter_comm]
simp [add_comm]
simp [add_comm]
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp [sub_eq_add_neg, image_comp (fun x => a + x) fun x => -x]
simp [sub_eq_add_neg, image_comp (fun x => a + x) fun x => -x, add_comm]
simp [sub_eq_add_neg, image_comp (fun x => a + x) fun x => -x]
simp [sub_eq_add_neg, image_comp (fun x => a + x) fun x => -x, add_comm]
simp [sub_eq_add_neg, image_comp (fun x => a + x) fun x => -x, add_comm]
simp [sub_eq_add_neg, image_comp (fun x => a + x) fun x => -x, add_comm]
simp [sub_eq_add_neg, image_comp (fun x => a + x) fun x => -x, add_comm]
simp [sub_eq_add_neg, image_comp (fun x => a + x) fun x => -x, add_comm]
simp [sub_eq_neg_add]
simp [sub_eq_neg_add]
simp [sub_eq_neg_add]
simp [sub_eq_neg_add]
simp [sub_eq_neg_add]
simp [sub_eq_neg_add]
simp [sub_eq_neg_add]
simp [sub_eq_neg_add]
simp only [← Icc_min_max, preimage_const_add_Icc, min_sub_sub_right, max_sub_sub_right]
simp only [← Icc_min_max, preimage_neg_Icc, min_neg_neg, max_neg_neg]
simp [sub_eq_add_neg]
simp [add_comm]
simp
simp [sub_eq_add_neg, image_comp (fun x => a + x) fun x => -x]
simp [sub_eq_add_neg, add_comm]
simp
rw [← max_sub_min_eq_abs, ← max_sub_min_eq_abs]
rw [interval_subset_interval_iff_le] at h
exact sub_le_sub h.2 h.1
simp [← Ioi_inter_Iio, h]
simp [← Ioi_inter_Iic, h]
simp [← Ici_inter_Iio, h]
simp [← Ici_inter_Iic, h]
simp [← Ioi_inter_Iio, h, inter_comm]
simp [← Ioi_inter_Iic, ← Ici_inter_Iio, h, inter_comm]
simp [← Ici_inter_Iio, ← Ioi_inter_Iic, h, inter_comm]
simp [← Ici_inter_Iic, h, inter_comm]
simp [← Ioi_inter_Iio, h]
simp [← Ioi_inter_Iic, h]
simp [← Ici_inter_Iio, h]
simp [← Ici_inter_Iic, h]
simp [← Icc_min_max, h, h.le, min_div_div_right_of_nonpos, max_div_div_right_of_nonpos]
simp [← Icc_min_max, ha, ha.le, min_div_div_right, max_div_div_right]
simp only [← preimage_mul_const_interval ha, mul_comm]
simp only [div_eq_mul_inv, preimage_mul_const_interval (inv_ne_zero ha), inv_inv]
simp [ha]
simp only [div_eq_mul_inv]
simp only [div_eq_mul_inv, image_mul_const_interval]
simp [h, division_def]
cases eq_or_lt_of_le hc
· subst c
    simp [(nonempty_Icc.2 hab).image_const]
exact image_mul_right_Icc' a b ‹0 < c›
simp [h, division_def]
rw [inv_eq_iff_inv_eq, inv_Ioo_0_left (inv_pos.2 ha), inv_inv]
erw [(Units.mk0 x hx.ne').mulLeft.image_eq_preimage, preimage_const_mul_Ioi 0 (inv_pos.mpr hx),
    zero_div]
have hG : 0 < Fintype.card G := fintype.card_pos_iff.mpr ⟨1⟩
simp only [mem_inv, inv_inv]
simp only [← inv_preimage, preimage_preimage, inv_inv, preimage_id']
rw [← inv_subset_inv, inv_inv]
rw [← image_inv, image_singleton]
rw [insert_eq, union_inv, inv_singleton, insert_eq]
rw [← image_inv]
exact (range_comp _ _).symm
simp only [← singleton_one, mul_singleton, mul_one, image_id']
simp only [← singleton_one, singleton_mul, one_mul, image_id']
rw [pow_zero]
exact one_mem_one
rw [pow_succ]
exact mul_mem_mul ha (pow_mem_pow _)
rw [pow_zero]
exact subset.rfl
rw [pow_succ]
exact mul_subset_mul hst (pow_subset_pow _)
refine' Nat.le_induction _ (fun n h ih => _) _
· exact subset.rfl
· rw [pow_succ]
    exact ih.trans (subset_mul_right _ hs)
rw [← mem_prod_list_of_fn, List.of_fn_const, List.prod_repeat]
rw [← tsub_add_cancel_of_le (Nat.succ_le_of_lt <| Nat.pos_of_ne_zero hn), pow_succ, empty_mul]
rw [succ_nsmul, nsmul_univ n.succ_ne_zero, univ_add_univ]
rw [pow_succ, univ_pow n.succ_ne_zero, univ_mul_univ]
rw [← image_id (s / t), ← image_inv]
exact image_image2_distrib_right div_eq_mul_inv
simp [subset_def, mem_mul]
simp [subset_def, mem_mul]
simp [not_disjoint_iff_nonempty_inter, mem_div, div_eq_one, Set.Nonempty]
simp only [is_unit_iff, Group.isUnit, and_true_iff]
rw [image_eq_preimage_of_inverse] <;> intro c <;> simp
rw [image_eq_preimage_of_inverse] <;> intro c <;> simp
simp
simp
rw [← image_mul_left', image_singleton]
rw [← image_mul_right', image_singleton]
rw [← image_mul_left', image_one, mul_one]
rw [← image_mul_right', image_one, one_mul]
simp
simp
simp [subset_def, mem_div]
simp [subset_def, mem_div]
exact ⟨B + 1, this (B + 1) (le_refl (B + 1))⟩
    exact fun n =>
      Nat.rec (fun h => Nat.zero_le (f 0))
        (fun n ih h =>
          lt_of_le_of_lt (ih (n.le_succ.trans h))
            (lt_of_le_of_ne (h1 n.le_succ) (h2 n (nat.succ_le_succ_iff.mp h))))
        n
  · obtain ⟨n, hn1, hn2⟩
simp only [← image_smul, image_image, smul_assoc]
intros
simp only [← image_smul, image_image, ← mul_smul]
intros
simp only [← image_smul, one_smul, image_id']
rw [smul_zero, singleton_zero]
rw [smul_one, singleton_one]
simp [subset_def, mem_smul]
simp [subset_def, mem_smul]
simp only [← image_smul, image_eta, zero_smul, h.image_const, singleton_zero]
simp only [← image_smul, mem_image, inv_smul_eq_iff, exists_eq_right]
simp
simp
simp
simp [← this]
rw [hs hi hj]
exact le_add_of_nonneg_right zero_le_one
simp [mul_comm]
simp
simp [← image_uncurry_prod, uncurry]
simp
simp
simp
simp
simp
rw [h a ha b hb]
rw [h a ha b hb c hc]
simp [nonempty_def.mp h, ext_iff]
simp [nonempty_def.mp h, ext_iff]
simp only [image2_image2_left, image2_image2_right, h_assoc]
rw [image2_swap f', image2_swap f]
exact image2_assoc fun _ _ _ => h_left_comm _ _ _
rw [image2_swap g, image2_swap g']
exact image2_assoc fun _ _ _ => h_right_comm _ _ _
rw [image_id']
rw [image_id']
rw [image2_swap f]
exact image_image2_distrib fun _ _ => h_antidistrib _ _
rw [image_id']
rw [image_id']
rw [sigma_singleton, image_singleton]
rw [insert_eq, union_sigma, singleton_sigma]
simp [range]
simp only [not_nonempty_iff_eq_empty, not_exists]
let ⟨i, hi⟩ := Set.mem_Union.1 (hT c.Prop)
have : ci i = ⟨c, hi⟩ := Subtype.ext (hci i)
rw [Union_lift_of_mem _ hi, ← this, h]
cases x
rfl
cases x
rfl
cases y
rfl
rw [finite_iff_nonempty_fintype, finite_def]
cases h
exact ⟨s.to_finset, fun _ => mem_to_finset⟩
cases h
exact ⟨s.to_finset, s.coe_to_finset⟩
rw [← Finset.coe_nonempty, finite.coe_to_finset]
rw [← Finset.coe_sort_coe _, h.coe_to_finset]
rw [← Finset.coe_inj, h.coe_to_finset, Finset.coe_empty]
simp
simp only [← Finset.coe_inj, finite.coe_to_finset]
rw [← Finset.coe_subset, ht.coe_to_finset]
simp only [← Finset.coe_inj, finite.coe_to_finset, Finset.coe_empty]
simp only [← Finset.coe_subset, finite.coe_to_finset]
simp only [← Finset.coe_ssubset, finite.coe_to_finset]
simp
simp
simp
simp
simp [and_comm']
rw [← inter_eq_self_of_subset_right h]
apply Set.fintypeInterOfLeft
simp
simp
rw [sUnion_eq_Union]
exact @Set.fintypeUnion _ _ _ _ _ H
simp
simp
simp
simp
simp
simp [h]
simp
simp [h]
simp
simp [equiv.plift.exists_congr_left]
simp
simp
simp
rw [← image_prod]
apply Set.fintypeImage
rw [seq_def]
apply Set.fintypeBUnion'
cases nonempty_fintype s
cases nonempty_fintype t
infer_instance
cases nonempty_fintype s
infer_instance
rw [← sep_eq_of_subset h]
infer_instance
rw [Union_eq_range_psigma]
apply Set.finite_range
rw [sUnion_eq_Union]
exact @Finite.Set.finite_Union _ _ _ _ H
cases nonempty_fintype s
infer_instance
rw [← image_prod]
infer_instance
rw [seq_def]
infer_instance
cases hs
cases ht
apply to_finite
rw [← finite_univ_iff, ← union_compl_self s]
exact hs.union hsc
cases hs
apply to_finite
cases hs
apply to_finite
cases hs
apply to_finite
cases hs
apply to_finite
cases hs
rw [bUnion_eq_Union]
apply finite_Union fun i : s => ht i.1 i.2
cases hs
apply to_finite
cases hs
apply to_finite
rw [← image_preimage_eq_of_subset hs]
exact finite.image f h
cases hs
cases ht
apply to_finite
cases hs
cases ht
apply to_finite
rw [← bUnion_range]
exact h.bUnion fun y hy => y.finite_to_set
simp
simp
simp
simp
simp
congr
rw [fintype_insert_of_not_mem, Fintype.card_of_finset] <;> simp [Finset.card, to_finset] <;> rfl
rw [← card_fintype_insert_of_not_mem s h] <;> congr
simp
rw [Set.Infinite, finite_univ_iff, not_finite_iff_infinite]
simp
simp only [Set.Infinite, finite_union, not_and_or]
rw [← image_univ, infinite_image_iff (inj_on_of_injective hi _)]
exact infinite_univ
rw [← range_subset_iff] at hf
exact (infinite_range_of_injective hi).mono hf
revert hf
refine' hs.induction_on _ _
· intro hf
    simp [supr_const]
· intro a s has hs ihs hf
    rw [ball_insert_iff] at hf
    simp only [infi_insert, ← ihs hf.2]
    exact supr_inf_of_monotone hf.1 fun j₁ j₂ hj => infi₂_mono fun i hi => hf.2 i hi hj
simp only [bUnion_empty, bdd_above_empty, ball_empty_iff]
simp only [bUnion_insert, ball_insert_iff, bdd_above_union, hs]
decide
decide
decide
decide
rw [h]
simp only [subset_def, not_forall]
simp only [Set.Nonempty, eq_empty_iff_forall_not_mem, not_exists]
rw [← not_forall, ← eq_univ_iff_forall]
simp [subset_def]
simp only [← subset_empty_iff] <;> exact union_subset_iff
simp only [subset_def, or_imp, forall_and, forall_eq, mem_insert_iff]
simp only [insert_subset, exists_and_right, ssubset_def, not_subset]
simp only [exists_prop, and_comm']
simp only [Set.Nonempty, mem_inter_iff, mem_singleton_iff, exists_eq_left]
rw [inter_comm, singleton_inter_nonempty]
rw [inter_comm, singleton_inter_eq_empty]
rw [ssubset_iff_subset_ne, subset_singleton_iff_eq, or_and_right, and_not_self_iff, or_false_iff,
    and_iff_left_iff_imp]
exact fun h => ne_of_eq_of_ne h (singleton_ne_empty _).symm
rw [Disjoint.comm, disjoint_left]
rw [union_comm, union_compl_self]
simp [mem_compl]
rw [diff_eq, inter_comm]
rw [union_comm]
exact sup_inf_sdiff _ _
rw [← union_singleton, union_comm]
apply diff_subset_iff
rw [← diff_singleton_subset_iff]
intro H
rw [H] at h'
exact h h'
rw [insert_inter_distrib, insert_eq_of_mem h]
rw [insert_inter_distrib, insert_eq_of_mem h]
simp [singleton_inter_eq_empty.2 h]
simp [insert_eq, union_diff_self, -union_singleton, -singleton_union]
rw [Set.ite, union_inter_distrib_right, diff_inter_self, inter_assoc, inter_self, union_empty]
rw [Set.ite, Set.ite, diff_compl, union_comm, diff_eq]
rw [← ite_compl, ite_inter_self]
simp [Set.ite]
simp [Set.ite]
simp [Set.ite]
simp [Set.ite]
simp [Set.ite]
simp [Set.ite]
rw [ite_inter_inter, ite_same]
rw [← ite_inter, ← h, ite_same]
simp only [subset_def, ← forall_and]
refine' forall_congr' fun x => _
constructor
· refine' fun h => fun a ha b hb => _
    exact SetCoe.ext_iff.2 (@Subsingleton.elim s h ⟨a, ha⟩ ⟨b, hb⟩)
· exact fun h => Subsingleton.intro fun a b => SetCoe.ext (h a.property b.property)
rw [s.subsingleton_coe]
exact subsingleton_of_subsingleton
rw [nontrivial_iff_exists_ne (mem_singleton x)] at H
exact
    let ⟨y, hy, hya⟩ := H
    hya (mem_singleton_iff.1 hy)
rw [H] at hs
exact not_nontrivial_singleton hs
simp [or_iff_not_imp_right]
rw [← subsingleton_iff_singleton ha]
exact s.subsingleton_or_nontrivial
simp
simp
simp [Monotone, MonotoneOn]
simp [Antitone, AntitoneOn]
simp [StrictMono, StrictMonoOn]
simp [StrictAnti, StrictAntiOn]
simp [monotone_on_iff_monotone, antitone_on_iff_antitone, and_assoc', exists_and_left,
    not_monotone_not_antitone_iff_exists_le_le, @and_left_comm (_ ∈ s)]
simp [monotone_on_iff_monotone, antitone_on_iff_antitone, and_assoc', exists_and_left,
    not_monotone_not_antitone_iff_exists_lt_lt, @and_left_comm (_ ∈ s)]
rw [nonempty_iff_ne_empty, ← h2, nonempty_iff_ne_empty, hf.ne_iff]
cases x
rfl
cases x
rfl
cases x
rfl
infer_instance
infer_instance
infer_instance
infer_instance
simp
simp
assumption
simp only [bind_def, bUnion_Union]
rw [restrict, image_comp, image_preimage_eq_inter_range, Subtype.range_coe]
simp only [injective, Subtype.ext_iff, coe_cod_restrict_apply]
rw [mem_preimage, mem_preimage, HEq hx]
intro a ha b hb hab
rw [← h ha, ← h hb]
exact h₁ ha hb hab
intro a ha b hb hab
rw [← h ha, ← h hb]
exact h₁ ha hb hab
erw [hg ⟨x, hx⟩]
apply Subtype.coe_prop
rw [maps_to']
rw [← image_univ, maps_image_to]
delta Set.restrictPreimage
rw [maps_to.range_restrict, Set.image_preimage_eq_inter_range, Set.preimage_inter,
    Subtype.coe_preimage_self, Set.univ_inter]
have : Disjoint s {a} := disjoint_iff_inf_le.mpr fun x ⟨hxs, (hxa : x = a)⟩ => has (hxa ▸ hxs)
rw [← union_singleton, inj_on_union this]
simp
rw [h.restrict_eq_cod_restrict, injective_cod_restrict, inj_on_iff_injective]
rw [hfg, hx, Subtype.coe_mk]
simp [surjective, surj_on, subset_def]
rw [image_image, image_congr hf, image_id']
let ⟨x, hx, HEq⟩ := hf hy
rw [← HEq, hf' hx]
rw [bex_def] at h <;> rw [inv_fun_on, dif_pos h] <;> exact Classical.choose_spec h
rw [bex_def] at h <;> rw [inv_fun_on, dif_neg h]
simp [piecewise]
simp [*]
simp [*]
apply piecewise_le <;> intros <;> simp [*]
simp [piecewise, h]
simp [hx]
simp [hx]
simp only [eq_on, ← forall_and]
refine' forall_congr' fun a => _
simp [eq_on_piecewise, *]
rw [injective_iff_inj_on_univ, ← union_compl_self s, inj_on_union (@disjoint_compl_right _ _ s),
    (piecewise_eq_on s f g).inj_on_iff, (piecewise_eq_on_compl s f g).inj_on_iff]
refine' and_congr Iff.rfl (and_congr Iff.rfl <| forall₄_congr fun x hx y hy => _)
rw [piecewise_eq_of_mem s f g hx, piecewise_eq_of_not_mem s f g hy]
intro i ht
simp
simp [Set.restrict, StrictMono, StrictMonoOn]
rw [← image_univ]
exact h.surj_on_image (ha.surj_on univ)
rw [← image_univ] at *
exact h.inj_on_image (ha.inj_on univ) hf
rw [← image_univ]
exact h.bij_on_image (bijective_iff_bij_on_univ.1 ha) (hf.inj_on univ)
simp only [mem_preimage, h x, hb hx]
intro x hx y hy H
have := congr_arg f H
rw [h.eq, h.eq] at this
exact hf hx hy (hb hx hy this)
simp only [Set.Pairwise, mem_union, or_imp, forall_and]
exact
    ⟨fun H => ⟨H.1.1, H.2.2, H.2.1, fun x hx y hy hne => H.1.2 y hy x hx hne.symm⟩, fun H =>
      ⟨⟨H.1, fun x hx y hy hne => H.2.2.2 y hy x hx hne.symm⟩, H.2.2.1, H.2.1⟩⟩
simp only [hr.iff, and_self_iff]
simp only [insert_eq, pairwise_union, pairwise_singleton, true_and_iff, mem_singleton_iff,
    forall_eq]
simp only [pairwise_insert, hr.iff a, and_self_iff]
simp [pairwise_insert]
simp [pairwise_insert_of_symmetric hr]
simp only [Set.Pairwise, Pairwise, mem_univ, forall_const]
simp (config := { contextual := true }) [h.eq_iff, Set.Pairwise]
rw [sUnion_eq_Union, pairwise_Union h.directed_coe, SetCoe.forall]
rfl
simp only [Pairwise, Set.Pairwise, SetCoe.forall, Ne.def, Subtype.ext_iff, Subtype.coe_mk]
rw [this]
rw [this]
simp only [← Set.inter_assoc, Set.inter_comm _ A]
simp only [Set.inter_assoc]
simp [mul_comm, and_left_comm]
rw [← h]
exact x.2.2.2.symm
rw [← h]
exact x.2.2.2.symm
simp [h, enumerate] <;> rfl
simp [h, enumerate] <;> rfl
cases hs : sel s
· exact enumerate_eq_none_of_sel sel hs
· cases m
      case zero => 
        have : n + 1 = 0 := Nat.eq_zero_of_le_zero hm
        contradiction
      case succ m' => 
        simp [hs, enumerate] at h⊢
        have hm : n ≤ m' := Nat.le_of_succ_le_succ hm
        exact enumerate_eq_none h hm
simp_all [enumerate]
simp [forall_or_left]
simp [exists_and_left]
simp
simp only [compl_Inter, compl_compl]
simp only [compl_Union, compl_compl]
rw [diff_eq, compl_Union, inter_Inter] <;> rfl
rw [diff_eq, compl_Inter, inter_Union] <;> rfl
simp only [DirectedOn, exists_prop, mem_Union, exists_imp] <;>
    exact fun a₁ b₁ fb₁ a₂ b₂ fb₂ =>
      let ⟨z, zb₁, zb₂⟩ := hd b₁ b₂
      let ⟨x, xf, xa₁, xa₂⟩ := h z a₁ (zb₁ fb₁) a₂ (zb₂ fb₂)
      ⟨x, ⟨z, xf⟩, xa₁, xa₂⟩
simp [nonempty_iff_ne_empty]
simp [nonempty_iff_ne_empty]
simp only [Union_and, @Union_comm _ ι']
simp only [Union_and, @Union_comm _ ι]
simp only [Inter_and, @Inter_comm _ ι']
simp only [Inter_and, @Inter_comm _ ι]
simp only [Union_or, Union_union_distrib, Union_Union_eq_left]
simp only [Inter_or, Inter_inter_distrib, Inter_Inter_eq_left]
rw [Union_nonempty_index, bUnion_self]
simp
rw [bInter_insert, bInter_singleton]
rw [inter_comm, ← bInter_inter hs]
simp [inter_comm]
simp
simp
simp
simp only [inter_Union]
simp [nonempty_iff_ne_empty]
simp only [eq_univ_iff_forall, mem_Union]
simp only [Union_eq_univ_iff, mem_Union]
simp only [eq_univ_iff_forall, mem_sUnion]
simp [Set.eq_empty_iff_forall_not_mem]
simp only [eq_empty_iff_forall_not_mem, mem_Inter, not_forall]
simp [Set.eq_empty_iff_forall_not_mem]
simp [nonempty_iff_ne_empty, Inter_eq_empty_iff]
simp [nonempty_iff_ne_empty, Inter_eq_empty_iff]
simp [nonempty_iff_ne_empty, sInter_eq_empty_iff]
simp
rw [sUnion_eq_compl_sInter_compl, compl_compl_image]
rw [← h] <;> exact inter_subset_inter_right _ (subset_sUnion_of_mem hs)
simp
simp [Set.ext_iff]
simp [Set.ext_iff]
simp
simp
rw [← sUnion_image, image_id']
rw [← sInter_image, image_id']
simp only [← sUnion_range, Subtype.range_coe]
simp only [← sInter_range, Subtype.range_coe]
simp [@Union_comm _ ι]
simp [@Inter_comm _ ι]
simp only [sUnion_eq_bUnion, bUnion_Union]
simp only [sInter_eq_bInter, bInter_Union]
rw [sInter_eq_bInter]
apply image_Inter₂_subset
rw [this]
apply hx
intro y hy
rw [Hinj.image_Inter_eq, mem_Inter]
exact fun i => H i hy
simp [h]
simp [@eq_comm α a]
simp [@eq_comm β b]
simp [preimage]
rw [sUnion_eq_bUnion, preimage_Union₂]
rw [sInter_eq_bInter, preimage_Inter₂]
rw [← preimage_Union₂, bUnion_of_singleton]
rw [bUnion_preimage_singleton, preimage_range]
simp only [sUnion_eq_bUnion, Union₂_prod_const, bUnion_image]
simp only [← image_prod, Union_prod_const, image_Union]
simp only [← image_prod, prod_Union, image_Union]
rw [Union_image_left, image2_mk_eq_prod]
rw [Union_image_right, image2_mk_eq_prod]
simp [seq]
simp
simp
rw [← singleton_seq, ← singleton_seq, seq_seq, image_singleton]
rw [← prod_eq_seq, ← image_swap_prod, prod_eq_seq, image_seq, ← image_comp, Prod.swap]
simp only [pi_def, Inter_true, mem_univ]
simp only [Ne.def, disjoint_left, @imp_not_comm _ (_ = _), forall_eq']
simp [Set.disjoint_iff, subset_def] <;> exact Iff.rfl
rw [Disjoint.comm] <;> exact disjoint_singleton_left
rw [disjoint_singleton_left, mem_singleton_iff]
simp only [eq_empty_iff_forall_not_mem, disjoint_iff_inter_eq_empty, not_exists, mem_inter_iff,
      not_and, mem_range, mem_preimage] at h⊢
intro y hy x hx
rw [← hx] at hy
exact h x hy
rw [disjoint_iff_inter_eq_empty] at h⊢
rw [← hf.image_inter hs ht, h, image_empty]
simp only [mem_Ici, supr_le_iff, mem_Inter]
simp only [mem_Iic, le_infi_iff, mem_Inter]
rw [Sup_eq_supr, Ici_supr₂]
rw [Inf_eq_infi, Iic_infi₂]
simp only [diff_subset_iff, ← bUnion_union]
apply bUnion_subset_bUnion_left
rw [union_diff_self]
apply subset_union_right
subst b_eq <;> subst a_eq
simp only [sUnion_eq_bUnion, Sup_eq_supr, supr_Union]
simp [and_assoc']
simp [prod_eq]
simp [prod_eq]
simp
rw [← mk_preimage_prod_left_eq_if, prod_preimage_left, preimage_preimage]
rw [← mk_preimage_prod_right_eq_if, prod_preimage_right, preimage_preimage]
rw [image_swap_eq_preimage_swap, preimage_swap_prod]
simp [-exists_and_right, exists_and_distrib_right.symm, and_left_comm, and_assoc, and_comm]
simp [range]
simp [range]
simp [range]
have : (fun x => (f x, g x)) = Prod.map f g ∘ fun x => (x, x) := funext fun x => rfl
rw [this, ← range_prod_map]
apply range_comp_subset_range
simp only [not_nonempty_iff_eq_empty.symm, prod_nonempty_iff, not_and_or]
simp [subset_def]
simp [diagonal]
simp [off_diag, Set.Nonempty, Set.Nontrivial]
rw [← not_nonempty_iff_eq_empty, ← not_nontrivial_iff, off_diag_nonempty.not]
simp
simp
simp
simp
simp only [forall_and, mem_pi, mem_inter_iff]
simp [ht]
simp [Classical.skolem, Set.Nonempty]
simp [Classical.skolem, Set.Nonempty]
simp [← not_nonempty_iff_eq_empty, univ_pi_nonempty_iff]
simp only [disjoint_iff_inter_eq_empty, ← pi_inter_distrib, univ_pi_eq_empty_iff]
simp [funext_iff]
simp [pi, or_imp, forall_and, set_of_and]
rw [← union_pi, union_compl_self]
rw [update_noteq]
exact fun h => hi (h ▸ hj)
rw [union_diff_self, union_eq_self_of_subset_left (singleton_subset_iff.2 hi)]
rw [union_pi, singleton_pi', update_same, pi_update_of_not_mem]
simp
rw [compl_eq_univ_diff, ← pi_update_of_mem (mem_univ _)]
rw [univ_pi_update i (fun j => (univ : Set (α j))) s fun j t => t, pi_univ, inter_univ, preimage]
simp [pi_subset_pi_iff]
rw [mem_op, unop_op]
rw [mem_unop, op_unop]
simp only [mem_unop, op_mem_op, iff_self_iff, imp_true_iff]
simp only [mem_op, unop_mem_unop, iff_self_iff, imp_true_iff]
simp
simp
simp only [singleton_unop, Opposite.unop_op]
simp only [singleton_op, Opposite.op_unop]
simp [enumerate_countable, Encodable.encodek]
rw [sUnion_eq_bUnion, hs.bUnion_iff]
simp [union_eq_Union, and_comm]
simp only [insert_eq, countable_union, countable_singleton, true_and_iff]
rw [← image_prod]
exact (hs.prod ht).image _
apply subset.antisymm
· exact Union₂_subset fun y hy => monotone_accumulate hy
· exact Union₂_mono fun y hy => subset_accumulate
apply subset.antisymm
· simp only [subset_def, mem_Union, exists_imp, mem_accumulate]
    intro z x x' hx'x hz
    exact ⟨x', hz⟩
· exact Union_mono fun i => subset_accumulate
congr
rw [s_eq]
simp
simp [h]
simp
simp
simp only [subset_def, mem_image]
exact fun x => fun ⟨w, h1, h2⟩ => ⟨w, h h1, h2⟩
simp [*]
simp only [eq_empty_iff_forall_not_mem]
exact ⟨fun H a ha => H _ ⟨_, ha, rfl⟩, fun H b ⟨_, ha, _⟩ => H _ ha⟩
simp [← preimage_compl_eq_image_compl]
simp
rw [← image_comp, compl_comp_compl, image_id]
simp only [image_insert_eq, image_singleton]
rw [image_eq_preimage_of_inverse h₁ h₂] <;> rfl
simp [disjoint_iff_inf_le, ← image_inter H]
rw [← image_union]
simp [image_univ_of_surjective H]
rw [diff_subset_iff, ← image_union, union_diff_self]
exact image_subset f (subset_union_right t s)
rw [← image_preimage_eq s hf, ← image_preimage_eq t hf, Eq]
simp only [inter_comm, image_inter_preimage]
rw [← image_inter_preimage, nonempty_image_iff]
rw [← preimage_image_eq s hf, ← preimage_image_eq t hf, Eq]
refine' Iff.symm <| (Iff.intro (image_subset f)) fun h => _
rw [← preimage_image_eq s hf, ← preimage_image_eq t hf]
exact preimage_mono h
simp
subst hi
apply H
simp
subst a
exact ⟨i, ha⟩
rw [← image_univ] <;> exact image_subset _ (subset_univ _)
rw [← range_subset_iff]
exact le_antisymm_iff
rw [range_comp] <;> apply image_subset_range
rw [← not_nonempty_iff, ← range_nonempty_iff_nonempty, not_nonempty_iff_eq_empty]
rw [← image_union, ← image_univ, ← union_compl_self]
simp [preimage, h_eq, hx]
rw [image_preimage_eq_inter_range, inter_eq_self_of_subset_left hs]
intro h
rw [← h]
apply image_subset_range
simp only [exists_prop, exists_subset_range_and_iff]
rw [inter_comm, preimage_inter_range]
rw [image_preimage_eq_inter_range, preimage_inter_range]
rw [← image_univ, preimage_inl_image_inr]
rw [← image_univ, preimage_inr_image_inl]
rw [image_preimage_eq_inter_range, image_preimage_eq_inter_range, ← inter_distrib_left,
    range_inl_union_range_inr, inter_univ]
simp [range_subset_iff, funext_iff, mem_singleton]
rw [compl_eq_univ_diff, image_diff_preimage, image_univ]
rw [range_subset_iff]
intro x
rw [← nonempty_image_iff, hf.image_preimage]
intro s t h
rw [← preimage_image_eq s hf, ← preimage_image_eq t hf, h]
apply preimage_subset_preimage_iff
rw [hf.range_eq]
apply subset_univ
rw [← image_comp, h.comp_eq_id, image_id]
rw [← preimage_comp, h.comp_eq_id, preimage_id]
rw [← Set.image_univ]
simp [-Set.image_univ, coe_image]
rw [← preimage_range (coe : s → α), range_coe]
rw [← yvaleq] <;> exact y.property
rw [← image_preimage_coe, ← image_preimage_coe, coe_injective.image_injective.eq_iff]
rw [preimage_coe_eq_preimage_coe_iff, inter_assoc, inter_self]
rw [inter_comm, ← image_preimage_coe, nonempty_image_iff]
simp only [← not_nonempty_iff_eq_empty, preimage_coe_nonempty]
rw [h.nonempty_apply_iff preimage_empty]
apply singleton_nonempty
refine' ⟨fun h x x' hx => _, injective.image_injective⟩
rw [← singleton_eq_singleton_iff]
apply h
rw [image_singleton, image_singleton, hx]
rw [← image_eq_image hf.1, hf.2.image_preimage]
rw [← image_eq_image hf.1, hf.2.image_preimage]
simp [Icc_eq_finset_subtype, Finset.fin, Finset.map_map, Icc_filter_lt_of_lt_right]
simp [Ico_eq_finset_subtype, Finset.fin, Finset.map_map]
simp [Ioc_eq_finset_subtype, Finset.fin, Finset.map_map, Ioc_filter_lt_of_lt_right]
simp [Ioo_eq_finset_subtype, Finset.fin, Finset.map_map]
rw [← Nat.card_Icc, ← map_subtype_embedding_Icc, card_map]
rw [← Nat.card_Ico, ← map_subtype_embedding_Ico, card_map]
rw [← Nat.card_Ioc, ← map_subtype_embedding_Ioc, card_map]
rw [← Nat.card_Ioo, ← map_subtype_embedding_Ioo, card_map]
rw [← card_Icc, Fintype.card_of_finset]
rw [← card_Ico, Fintype.card_of_finset]
rw [← card_Ioc, Fintype.card_of_finset]
rw [← card_Ioo, Fintype.card_of_finset]
simp [Iic_eq_finset_subtype, Finset.fin, Finset.map_map, Iic_filter_lt_of_lt_right]
simp [Iio_eq_finset_subtype, Finset.fin, Finset.map_map]
cases n
· exact Fin.elim0 a
rw [← card_map, map_subtype_embedding_Ici, Nat.card_Icc]
rfl
rw [← card_map, map_subtype_embedding_Ioi, Nat.card_Ioc]
rw [← Nat.card_Iic b, ← map_subtype_embedding_Iic, card_map]
rw [← Nat.card_Iio b, ← map_subtype_embedding_Iio, card_map]
rw [Fintype.card_of_finset, card_Ici]
rw [Fintype.card_of_finset, card_Ioi]
rw [Fintype.card_of_finset, card_Iic]
rw [Fintype.card_of_finset, card_Iio]
rw [antidiagonal_tuple, antidiagonal_zero, List.bind_singleton, antidiagonal_tuple_zero_right k,
      List.map_singleton]
exact congr_arg (fun x => [x]) Matrix.cons_zero_zero
simp only [lift_fun_iff_succ r, forall_fin_succ, cons_val_succ, cons_val_zero, ← succ_cast_succ,
    cast_succ_zero]
simp [Subsingleton.monotone]
infer_instance
simp [tail, cons]
simp [cons]
simp [cons]
rw [cons_self_tail]
rw [cons_cases, cast_eq]
congr
exact tail_cons _ _
refine' Fin.cases _ _
· refine' Fin.cases _ _
    · intro
      rfl
    · intro j h
      rw [cons_zero, cons_succ] at h
      exact hx₀.elim ⟨_, h.symm⟩
· intro i
    refine' Fin.cases _ _
    · intro h
      rw [cons_zero, cons_succ] at h
      exact hx₀.elim ⟨_, h⟩
    · intro j h
      rw [cons_succ, cons_succ] at h
      exact congr_arg _ (hx h)
simp [tail]
simp only [cons_succ, Pi.le_def]
rw [range_fin_succ, cons_zero, tail_cons]
rw [Fin.cast_succ_cast_lt i h]
rw [eq_last_of_not_lt h]
rw [Function.comp_apply, snoc_cast_succ]
simp [snoc]
rw [h']
simp
rw [cast_succ_cast_lt, h']
simp
intro E
apply h'
rw [← E, cast_succ_cast_lt]
rw [ji, succ_pred]
rw [jk, cast_succ_cast_lt]
simp [insert_nth, succ_above_cases]
simp only [insert_nth, succ_above_cases, dif_neg (succ_above_ne _ _)]
simp [funext_iff, forall_iff_succ_above i, eq_comm]
rw [insert_nth, succ_above_cases, dif_neg h.ne, dif_pos h]
rw [insert_nth, succ_above_cases, dif_neg h.ne', dif_neg h.not_lt]
simp
simp [insert_nth_zero]
simp
simp [insert_nth_last]
simp [succ_above_ne, Pi.zero_def]
simp
simp [Pi.le_def, forall_iff_succ_above i]
simp [Pi.le_def, forall_iff_succ_above i]
simp only [mem_Icc, insert_nth_le_iff, le_insert_nth_iff, and_assoc, and_left_comm]
simp only [mem_preimage, insert_nth_mem_Icc, hx, true_and_iff]
simp only [mem_preimage, insert_nth_mem_Icc, hx, false_and_iff, mem_empty_iff_false]
skip <;>
      exact
        Option.casesOn (@find n (fun i => p (i.castLt (Nat.lt_succ_of_lt i.2))) _)
          (if h : p (Fin.last n) then some (Fin.last n) else none) fun i =>
          some (i.castLt (Nat.lt_succ_of_lt i.2))
rw [← not_exists, ← is_some_find_iff] <;> cases find p <;> simp
rw [graph, Finset.card_image_of_injective]
· exact Finset.card_fin _
· intro _ _
    simp
simp [graph]
simp
simp
simp
rw [self_comp_sort]
exact (monotone_proj f).comp (graph_equiv₂ f).Monotone
rw [eq_comm, eq_sort_iff, Equiv.coe_refl, Function.comp.right_id]
simp only [id.def, and_iff_left_iff_imp]
exact fun _ _ _ hij _ => hij
rw [Function.comp.assoc, ← Equiv.Perm.coe_mul]
exact unique_monotone (monotone_sort (f ∘ σ)) (monotone_sort f)
constructor <;> exact elim0
intro a ha b
rw [isMax_iff_eq_top, eq_top_iff, not_le, top_eq_last] at ha
rw [if_pos ha, lt_iff_coe_lt_coe, le_iff_coe_le_coe, coe_add_one_of_lt ha]
exact Nat.lt_iff_add_one_le
intro a ha
rw [isMax_iff_eq_top, top_eq_last] at ha
rw [if_neg ha.not_lt]
constructor <;> exact elim0
intro a ha b
rw [isMin_iff_eq_bot, eq_bot_iff, not_le, bot_eq_zero] at ha
rw [if_neg ha.ne', lt_iff_coe_lt_coe, le_iff_coe_le_coe, coe_sub_one, if_neg ha.ne',
          le_tsub_iff_right, Iff.comm]
exact Nat.lt_iff_add_one_le
exact ha
induction on  `i
induction on `i
cases a <;> rfl
subst h
simp [Function.funext_iff]
subst h
simp [coe_eq_coe]
simp
simp
infer_instance
simp [Monotone]
simp [Monotone]
rw [← coe_fin_lt, coe_zero, pos_iff_ne_zero, Ne.def, Ne.def, ext_iff, coe_zero]
rw [coe_mk, coe_mk, ← tsub_tsub, tsub_tsub_cancel_of_le (Nat.add_one_le_iff.2 i.is_lt),
        add_tsub_cancel_right]
simp only [le_iff_coe_le_coe, coe_rev, tsub_le_tsub_iff_left (Nat.add_one_le_iff.2 j.is_lt),
    add_le_add_iff_right]
simp [lt_iff_coe_lt_coe]
decide
simp [eq_iff_veq, add_def, mod_eq_of_lt (is_lt k)]
simp [eq_iff_veq, add_def, mod_eq_of_lt (is_lt k)]
simp [eq_iff_veq, add_def, add_assoc]
simp [eq_iff_veq, add_def, add_comm]
rw [Fin.coe_add, Nat.add_mod_eq_ite, Nat.mod_eq_of_lt (show ↑a < n from a.2),
    Nat.mod_eq_of_lt (show ↑b < n from b.2)]
cases k
rfl
cases n
· cases h
  -- Then just unfold the definitions.
rw [Fin.coe_add, Fin.coe_one, Nat.mod_eq_of_lt (Nat.succ_lt_succ _)]
exact h
rw [← of_nat_eq_coe]
exact Nat.mod_eq_of_lt h
rw [Fin.eq_iff_veq]
exact coe_val_of_lt a.property
rw [← Fin.of_nat_eq_coe, Fin.ofNat, Fin.last]
simp only [Nat.mod_eq_of_lt n.lt_succ_self]
rw [Fin.coe_nat_eq_last]
exact Fin.le_last i
cases n
· exact absurd h (Nat.not_lt_zero _)
· rw [lt_iff_coe_lt_coe, coe_last, ← add_lt_add_iff_right 1] at h
    rw [lt_iff_coe_lt_coe, coe_add, coe_zero, coe_one, Nat.mod_eq_of_lt h]
    exact Nat.zero_lt_succ _
rw [eq_comm, zero_eq_one_iff]
cases j <;> simp [Fin.succ]
simp [lt_iff_coe_lt_coe]
rw [lt_iff_coe_lt_coe, coe_zero]
exact Nat.succ_pos i
cases n
· exact finZeroElim a
· rw [← succ_zero_eq_one, succ_lt_succ_iff]
    exact succ_pos a
rw [← not_iff_not]
simp
simp [eq_iff_veq]
rw [← coe_cast_le]
exact congr_arg coe (Equiv.apply_of_injective_symm _ _)
simp [Fin.eq_iff_veq]
simp only [coe_cast_le]
rw [coe_cast, coe_last, coe_last, Nat.succ_injective h]
subst h
simp
simp
rw [h]
simp
simp only [coe_cast_succ, coe_succ, Nat.lt_succ_self]
rw [← succ_last, (succ_injective _).eq_iff]
cases a <;> rfl
simp [Fin.ext_iff]
cases n
· exact finZeroElim a
· simp [a.is_lt, eq_iff_veq, add_def, Nat.mod_eq_of_lt]
rw [cast_succ, lt_iff_coe_lt_coe, coe_cast_add, coe_succ]
exact lt_add_one a.val
rw [← coe_cast_succ]
exact congr_arg coe (Equiv.apply_of_injective_symm _ _)
simp
cases j
rfl
contradiction
cases i
rfl
simp only [← h, Fin.succ_pred]
simp only [h, Fin.pred_succ]
simp only [ext_iff, coe_pred, coe_mk, add_tsub_cancel_right]
rw [← succ_le_succ_iff, succ_pred, succ_pred]
rw [← succ_lt_succ_iff, succ_pred, succ_pred]
contradiction
contradiction
simp [Fin.eq_iff_veq]
rw [ext_iff, coe_pred, coe_cast_lt, coe_add, coe_one, mod_eq_of_lt, add_tsub_cancel_right]
exact add_lt_add_right h 1
rw [tsub_lt_iff_right h]
exact i.is_lt
simp [eq_iff_veq]
simp [← cast_add_nat]
induction on `i
induction on `i
cases i <;> rfl
induction on `i
cases i <;> rfl
induction on `i
cases i <;> rfl
cases i <;> rfl
revert a b
simp [forall_fin_two]
rw [hi]
cases i
rw [tsub_lt_tsub_iff_left_of_le] <;> simp [*, Nat.succ_le_iff]
rw [hi]
rw [reverse_induction] <;> simp
rw [reverse_induction, dif_neg (ne_of_lt (Fin.cast_succ_lt_last i))]
cases i
rfl
have : ¬(nat_add m i : ℕ) < m := (le_coe_nat_add _ _).not_lt
rw [add_cases, dif_neg this]
refine' eq_of_heq ((eq_rec_heq _ _).trans _)
congr 1
simp
rw [Fin.coe_mk, Fin.coe_zero, tsub_add_cancel_of_le, Nat.mod_self]
exact le_of_lt ha
simp
cases a <;> cases b <;> rfl
rw [Subsingleton.elim a 0, Fin.coe_zero]
cases n
· simp
rw [Fin.coe_neg, Fin.coe_one, Nat.succ_sub_one, Nat.mod_eq_of_lt]
constructor
rw [add_right_comm, add_assoc, add_mod_right]
cases n
· simp [Subsingleton.elim (k - 1) k, Subsingleton.elim 0 k]
rw [← lt_sub_one_iff, le_iff_lt_or_eq, lt_sub_one_iff, or_iff_left_iff_imp, eq_comm,
    sub_eq_iff_eq_add]
simp
simp only [not_lt, le_sub_one_iff, le_zero_iff]
rw [coe_sub_iff_le.2 i.le_last, coe_last, coe_rev, Nat.succ_sub_succ_eq_sub]
rw [succ_above]
exact if_pos h
rw [Fin.succ_above_below]
· rfl
· exact bot_lt_iff_ne_bot.mpr ha
simp only [← succ_above_ne_zero_zero ha, OrderEmbedding.eq_iff_eq]
rw [succ_above_last]
simp [succ_above, h.not_lt]
intro eq
rw [succ_above_below, cast_succ_cast_lt]
exact h
simp only [succ_above_below _ _ h, cast_lt_cast_succ]
simp only [succ_above_above _ _ h, pred_succ]
cases n
apply Subsingleton.elim
rfl
dsimp [pred_above]
rw [dif_pos]
exact (pos_iff_ne_zero _).mpr hi
simp [cast_pred, pred_above, cast_succ_lt_last]
have : i ≤ (last n).cast_succ := h.trans p.le_last
simp [pred_above, cast_pred, h.not_lt, this.not_lt]
rw [pred_above_last]
simp [pred_above, h]
cases a
rfl
rw [succ_pred, pred_succ]
simp [cast_pred, pred_above, le_last]
rw [cast_pred, pred_above, dif_neg]
· simp [Fin.eq_iff_veq]
· exact h.not_le
rw [← of_nat_eq_coe] <;> rfl
cases n
simp
simp [eq_iff_veq, mul_def, mod_eq_of_lt (is_lt k)]
cases n
simp
simp [eq_iff_veq, mul_def, mod_eq_of_lt (is_lt k)]
simp [eq_iff_veq, mul_def]
simp [eq_iff_veq, mul_def]
infer_instance
infer_instance
infer_instance
simp [vec_cons]
simp only [vec_cons, Fin.cons, Fin.cases_succ']
simp [Fin.exists_fin_succ, eq_comm]
rw [← Fin.succ_zero_eq_one, cons_val_succ]
rfl
refine' Fin.forall_fin_one.2 _ i
rfl
trace
              "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `reflect_name #[]"
trace
              "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `reflect_name #[]"
simp [vec_head, vec_alt1]
rw [vec_alt0_append]
rw [vec_alt1_append]
simp
simp
simp
simp
simp
simp
simp
simp
simp [hx, hv]
congr <;> assumption
rw [← rev_list_reverse, List.reverse_reverse]
rw [← rev_list_reverse] <;> exact list.mem_reverse.trans mem_rev_list
rw [← rev_list_reverse, List.foldl_reverse, rev_list_foldr]
induction i <;> simp [*, DArray.iterateAux]
rw [← rev_list_reverse, List.length_reverse, rev_list_length]
cases i <;> apply to_list_nth_le
simp
simp [List.mem_iff_nth, to_list_nth, and_comm, and_assoc, and_left_comm]
simp [DArray.iterateAux]
refine' ⟨_, push_back_rev_list_aux _ _ _⟩
dsimp [read, DArray.read, push_back]
rw [dif_neg]
rfl
exact ne_of_lt h'
unfold push_back rev_list foldl iterate DArray.iterate
dsimp [DArray.iterateAux, read, DArray.read, push_back]
rw [dif_pos (Eq.refl n)]
apply congr_arg
apply push_back_rev_list_aux
rw [← rev_list_reverse, ← rev_list_reverse, push_back_rev_list, List.reverse_cons]
rw [card_Ico_eq_card_Icc_sub_one, card_Icc]
rw [card_Ioc_eq_card_Icc_sub_one, card_Icc]
rw [card_Ioo_eq_card_Icc_sub_two, card_Icc]
rw [card_Iio_eq_card_Iic_sub_one, card_Iic]
rw [card_Ioi_eq_card_Ici_sub_one, card_Ici]
simp [mul_single_apply, eq_comm]
apply if_t_t _ _
rw [Subsingleton.elim j i, Pi.mulSingle_eq_same]
simp only [Pi.mulSingle, Sum.elim_update_left, elim_one_one]
simp only [Pi.mulSingle, Sum.elim_update_right, elim_one_one]
intro j
rw [← not_imp_not]
exact fun h' => wf.not_lt_min _ _ h'
rw [hi.1 j hji]
refine' i.cases' _ _
exact a
exact v
rw [eq_nil v] <;> apply H
rw [← cons_head_tail v] <;> apply H
simp [*, left]
simp [*, left]
simp [*, add]
refine' funext fun j => j.cases' _ _ <;> intros <;> rfl
refine' j.cases' _ fun j => _ <;> simp [insert, insert_perm]
refine' Fin2.cases' _ _ (insert_perm i j) <;> simp [insert_perm]
rw [← eq_nil v] <;> exact fv
rw [cons_head_tail v] <;> exact fv
simp only [preimage, inv_id, image_id]
simp only [preimage, inv_comp, image_comp]
rw [preimage, image_univ, codom_inv]
simp [mem_core, imp_and, forall_and]
simp [mem_core]
simp [core]
simp [Set.image, Function.graph, Rel.image]
simp [Set.preimage, Function.graph, Rel.preimage, Rel.inv, flip, Rel.image]
simp [Set.preimage, Function.graph, Rel.core]
cases s₁ <;> cases s₂ <;> simp [Alist.toFinmap]
cases s <;> rfl
have H' : f a₁ = f a₂ := funext fun _ => H _ _ _ _ p (Perm.refl _)
simp only [H']
cases s₁ <;> cases s₂ <;> rfl
congr
simp [keys, Alist.keys]
simp only [singleton] <;> erw [mem_cons_eq, mem_nil_iff, or_false_iff]
rw [List.toFinmap, lookup_to_finmap, lookup_to_alist]
rw [singleton, lookup_to_finmap, Alist.singleton, Alist.lookup, lookup_cons_eq]
simp only [Alist.lookup, lookup_to_finmap] at h
rw [Alist.to_finmap_eq]
apply lookup_ext s₁.nodupkeys s₂.nodupkeys
intro x y
rw [h]
simp [replace]
simp
simp
intros
simp [or_right_comm]
intros
simp [and_right_comm]
simp [erase]
simp [Finset.erase, keys, Alist.erase, keys_kerase]
simp
simp
simp only [erase_erase, erase_to_finmap]
simp [insert]
simp [insert_entries_of_neg (mt mem_to_finmap.1 h)]
simp only [insert_to_finmap, lookup_to_finmap, lookup_insert]
simp only [insert_to_finmap, lookup_to_finmap, lookup_insert_ne h]
simp only [insert_to_finmap, insert_insert]
simp only [insert_to_finmap, Alist.to_finmap_eq, insert_insert_of_ne _ h]
simp only [singleton, Finmap.insert_to_finmap, Alist.insert_singleton_eq]
simp [perm_lookup p, to_finmap_eq, perm_erase p]
simp [extract]
simp [keys]
simp [insert_union]
simp only [Alist.to_finmap_eq, union_to_finmap, Alist.union_assoc]
rw [← empty_to_finmap] <;>
      simp [-empty_to_finmap, Alist.to_finmap_eq, union_to_finmap, Alist.union_assoc]
rw [← empty_to_finmap] <;>
      simp [-empty_to_finmap, Alist.to_finmap_eq, union_to_finmap, Alist.union_assoc]
dsimp only [Disjoint] <;> infer_instance
simp [Disjoint, Finmap.mem_union, or_imp, forall_and]
rw [disjoint.symm_iff, disjoint_union_left, disjoint.symm_iff _ x, disjoint.symm_iff _ x]
intro h
simp only [Alist.to_finmap_eq, union_to_finmap, Alist.union_comm_of_disjoint h]
rw [← Array'.to_list_length a₁, ← Array'.to_list_length a₂, h]
rw [size_eq_zero_iff]
induction xs generalizing b <;> simp! [*] <;> cases b <;> simp! [to_list, to_array]
cases l
· rfl
· rw [List.toBuffer, to_list_append_list]
    rfl
cases b
simp [to_list]
cases b
simp [size, push_back]
rw [← to_buffer_to_list b, to_list_to_buffer, size_to_buffer]
simp
simp [h]
simp [add_comm, add_left_comm, Nat.succ_eq_add_one]
congr 1 <;> simp [Fin.heq_ext_iff]
simp
simp [nth_le_to_list]
simp
simp
refine'
      { toFun := List.toBuffer
        invFun := Buffer.toList.. } <;>
    simp [left_inverse, Function.RightInverse]
cases p cb n <;> simp
cases p cb n <;> simp
simp [decorate_errors, h]
simp [decorate_errors, h]
cases h : p cb n <;> simp [decorate_errors, h]
cases h : p cb n <;> simp [decorate_errors, h, eq_comm]
simp [pure_eq_done]
cases hp : p cb n <;> simp [hp, ← bind_eq_bind, Parser.bind, and_assoc']
cases hp : p cb n <;> simp [hp, ← bind_eq_bind, Parser.bind, and_assoc']
simp [pure_eq_done]
simp [pure_eq_done]
cases hp : p cb n <;> simp [← LawfulMonad.bind_pure_comp_eq_map, hp, and_assoc', pure_eq_done]
simp [← bind_pure_comp_eq_map, pure_eq_done]
simp [map_const_eq]
simp only [map_const_eq, map_eq_fail]
simp
simp [eq_comm]
simp [seq_eq_bind_map]
simp [seq_eq_bind_map]
have :
    ∀ p q : ℕ → α → Prop,
      (∃ (np : ℕ)(x : α), p np x ∧ q np x ∧ x = a) ↔ ∃ np : ℕ, p np a ∧ q np a :=
    fun _ _ => ⟨fun ⟨np, x, hp, hq, rfl⟩ => ⟨np, hp, hq⟩, fun ⟨np, hp, hq⟩ => ⟨np, a, hp, hq, rfl⟩⟩
simp [seq_left_eq, seq_eq_done, map_eq_done, this]
simp [seq_left_eq, seq_eq_fail]
simp [seq_right_eq, seq_eq_done, map_eq_done, and_comm, and_assoc]
simp [seq_right_eq, seq_eq_fail]
simp [mmap, and_comm, and_assoc, and_left_comm, pure_eq_done]
simp [mmap']
simp [pure_eq_done]
simp [le_refl]
constructor
intro cb n
simp [eps, pure_eq_done]
simp [ch, eps_eq_done, sat_eq_done, and_comm, @eq_comm _ n']
simp [one_of, sat_eq_done]
simp [str_eq_char_buf, char_buf_eq_done]
simp [remaining]
simp [remaining]
simp [eof, guard_eq_done, remaining_eq_done, tsub_eq_zero_iff_le, and_comm', and_assoc']
simp [foldr_core]
simp [foldr_core, and_comm, and_assoc, pure_eq_done]
simp [foldr_core, eq_comm]
simp [foldr_core, and_comm']
simp [foldr, foldr_core_eq_done]
simp [foldr, foldr_core_succ_eq_fail]
simp [foldl_core]
simp [foldl_core, and_assoc, pure_eq_done]
simp [foldl_core, eq_comm]
simp [foldl_core, and_comm']
simp [foldl, foldl_core_eq_done]
simp [foldl, foldl_core_succ_eq_fail]
simp [many, foldr_eq_done]
simp [many, foldr_eq_done, and_comm, and_assoc, and_left_comm]
simp [many, foldr_eq_fail]
simp [many_char, many_eq_done_nil, map_eq_done, List.as_string_eq]
simp [many_char, List.as_string_eq, String.to_list_nonempty h, many_eq_done]
simp [many_char, List.as_string_eq]
simp [many1, seq_eq_done]
simp [many1, seq_eq_done, map_eq_done]
simp [many1, seq_eq_fail]
simp [many_char1, ← String.nil_as_string_eq_empty]
simp [many_char1, List.as_string_eq, String.to_list_nonempty h, many1_eq_done,
    many_char_eq_many_of_to_list]
simp [fix_core]
simp [fix_core]
decide
simp [digit, sat_eq_fail]
intro
exact hne (of_done h)
simp
simp [guard_eq_done]
rw [decorate_errors_eq_done]
exact of_done
decide
simp [sat_eq_done, hc]
apply sat_iff.mpr
simp
decide
simp [char_buf_eq_done]
simp [one_of_eq_done]
apply one_of_iff.mpr
rfl
simp [one_of'_eq_done]
apply one_of_iff.mpr
rfl
simp [str_eq_char_buf, char_buf_iff, ← String.to_list_inj, Buffer.ext_iff]
dsimp [foldr]
exact of_done
dsimp [foldl]
exact of_done
decide
decide
simp [pure_eq_done]
simp
simp [any_char, hn]
simp [sat, hn]
simp [h]
simp [remaining_eq_done]
simp [eof_eq_done]
simp [pure_eq_done]
simp
simp [success_iff, any_char_eq_done, hn]
simp [success_iff, sat_eq_done, hn]
simp [success_iff, remaining_eq_done]
intro
exact hne (of_fail h)
simp [pure_eq_done]
rw [map_eq_fail]
exact of_fail
rw [any_char_eq_fail, and_comm]
simp
simp [remaining_ne_fail]
apply not_step_of_static_done
simp [pure_eq_done]
simp
rw [decorate_errors_eq_done]
exact of_done
simp [char_buf_eq_done]
simp [str_eq_char_buf, char_buf_iff, ← String.to_list_inj, Buffer.ext_iff]
apply not_step_of_static_done
simp [remaining_eq_done]
rw [step.of_done h]
exact Nat.lt_succ_self _
simp [pure_eq_done]
constructor
simp only [and_imp, bind_eq_done, mmap', exists_imp, and_then_eq_bind]
intro _ _ _ _ _ _ h hm
exact lt_of_lt_of_le (of_done h) (mono.of_done hm)
rw [decorate_errors_eq_done]
exact of_done
simp [h]
simp [str_eq_char_buf, char_buf_iff, ← String.to_list_inj, Buffer.ext_iff]
simp [remaining_eq_done]
simp only [many1_eq_done] at hp
    -- We know that `parser.digit` succeeded, so it has moved to a possibly different position.
    -- In fact, we know that this new position is `n + 1`,
simp [← List.tail_drop, hx, Nat.sub_succ, hk]
  -- We have to prove that the number of digits produced (given
simp
    -- We bring back the underlying definition of `ctl` as the result of a sequence of `list.take`
    -- and `list.drop`, so that lemmas about `list.length` of those can fire.
simp [hk, add_assoc]
contradiction
decide
rw [add_assoc, tsub_eq_iff_eq_add_of_le, add_comm]
exact Nat.le_add_right _ _
      -- We also have to prove what is the `prod.snd` of the result of the fold of a `list (ℕ × ℕ)`
      -- with the function above. We use this lemma to finish our inductive case.
have : r = p := funext fun a => funext fun b => propext <| Eq a b
subst this
simp [heq_self_iff_true]
simp [heq_self_iff_true]
refine' Iff.trans _ Quotient.eq
rw [Quotient.out_eq y]
refine' Iff.trans _ Quotient.eq
rw [Quotient.out_eq x]
rw [← Quotient.eq_mk_iff_out, Quotient.out_eq]
infer_instance
intro
induction x
rfl
simp! [*]
induction xs <;> simp [append, *]
induction xs <;> simp [LazyList.bind, append, *, append_assoc, append, LazyList.bind]
intros
apply append_nil
intros
dsimp [(· >>= ·)]
induction x <;> simp [LazyList.bind, append_bind, *]
simp [*, (· ∈ ·), LazyList.Mem]
simp only [Membership.Mem, LazyList.Mem, or_imp, forall_and, forall_eq]
simp only [pderiv, mk_derivation_monomial, Finsupp.smul_sum, smul_eq_mul, ← smul_mul_assoc, ←
    (monomial _).map_smul]
refine' (Finset.sum_eq_single i (fun j hj hne => _) fun hi => _).trans _
· simp [Pi.single_eq_of_ne hne]
· rw [Finsupp.not_mem_support_iff] at hi
    simp [hi]
· simp
congr
simp
simp [h]
simp
simp only [(pderiv i).leibniz f g, smul_eq_mul, mul_comm, add_comm]
funext i
simp only [comap, AlgHom.id_apply, id.def, aeval_X]
funext x
exact comap_id_apply x
rw [← this]
funext x
exact comap_comp_apply _ _ _
intro x
rw [← comap_comp_apply]
apply comap_eq_id_of_eq_id
intro
simp only [AlgHom.id_apply, AlgEquiv.comp_symm]
intro x
rw [← comap_comp_apply]
apply comap_eq_id_of_eq_id
intro
simp only [AlgHom.id_apply, AlgEquiv.symm_comp]
simp only [expand, bind₁_X_left, AlgHom.id_apply, RingHom.toFun_eq_coe, eval₂_hom_C_left,
    AlgHom.coe_to_ring_hom, pow_one, AlgHom.coe_mk]
apply alg_hom_ext
intro i
simp only [AlgHom.comp_apply, bind₁_X_right]
rw [← AlgHom.comp_apply, expand_comp_bind₁]
simp [expand, map_bind₁]
simp [expand, bind₁_rename, rename_bind₁]
simp
rw [C_mul', D.map_smul]
intro r
rw [C_eq_smul_one, D.map_smul, h₁, smul_zero]
simp only [map_C, rename_C]
simp only [hp, hq, AlgHom.map_add, RingHom.map_add]
simp only [hp, rename_X, map_X, RingHom.map_mul, AlgHom.map_mul]
rw [rename, aeval_monomial, monomial_eq, Finsupp.prod_map_domain_index]
· rfl
· exact fun n => pow_zero _
· exact fun n i₁ i₂ => pow_add _ _ _
simp only [rename, aeval_def, eval₂, Finsupp.mapDomain, algebra_map_eq, X_pow_eq_monomial, ←
    monomial_finsupp_sum_index]
rfl
have :
    (rename f : MvPolynomial σ R → MvPolynomial τ R) = Finsupp.mapDomain (Finsupp.mapDomain f) :=
    funext (rename_eq f)
rw [this]
exact Finsupp.map_domain_injective (Finsupp.map_domain_injective hf)
dsimp
rw [rename, kill_compl, aeval_X, aeval_X, dif_pos, Equiv.of_injective_symm_apply]
rw [rename_rename, f.symm_comp_self, rename_id]
rw [rename_rename, f.self_comp_symm, rename_id]
apply MvPolynomial.induction_on p <;>
    · intros
      simp [*]
apply MvPolynomial.induction_on p <;>
    · intros
      simp [*]
apply MvPolynomial.induction_on p <;>
    · intros
      simp [*]
apply MvPolynomial.induction_on p <;>
    · intros
      simp [*]
rw [rename_C]
simp only [eval₂_C, rename_C]
simp only [hp, hq, rename, eval₂_add, AlgHom.map_add]
simp only [hp, rename, aeval_def, eval₂_X, eval₂_mul]
apply induction_on' φ
· intro u r
    rw [rename_monomial, coeff_monomial, coeff_monomial]
    simp only [(Finsupp.map_domain_injective hf).eq_iff]
· intros
    simp only [*, AlgHom.map_add, coeff_add]
apply φ.induction_on
· intro a
    simp only [constant_coeff_C, rename_C]
· intro p q hp hq
    simp only [hp, hq, RingHom.map_add, AlgHom.map_add]
· intro p n hp
    simp only [hp, rename_X, constant_coeff_X, RingHom.map_mul, AlgHom.map_mul]
rw [rename_eq]
exact Finsupp.map_domain_support_of_injective (map_domain_injective h) _
rw [Polynomial.eval₂_C, MvPolynomial.eval₂_C]
rw [Polynomial.eval₂_add, MvPolynomial.eval₂_add, hp, hq]
rw [Polynomial.eval₂_mul, Polynomial.eval₂_pow, Polynomial.eval₂_X, Polynomial.eval₂_C,
        eval₂_mul, eval₂_C, eval₂_pow, eval₂_X]
rfl
rfl
rw [← fin_succ_equiv_eq]
rfl
refine' RingHom.ext fun x => _
rw [RingHom.comp_apply]
refine'
    (MvPolynomial.finSuccEquiv R n).Injective
      (trans ((MvPolynomial.finSuccEquiv R n).apply_symm_apply _) _)
simp only [MvPolynomial.fin_succ_equiv_apply, MvPolynomial.eval₂_hom_C]
simp
simp
simp only [Polynomial.coeff_map]
rw [cons_zero]
rw [c]
simp
rw [degree_of_eq_sup, fin_succ_equiv_support f, Finset.sup_image]
rw [mk_finsupp_nat, max_assoc, lift_max, lift_aleph_0, max_comm]
cases subsingleton_or_nontrivial R
· exact (mk_eq_one _).trans_le (le_max_of_le_right one_le_aleph_0)
cases isEmpty_or_nonempty σ
· exact cardinal_mk_eq_lift.trans_le (le_max_of_le_left <| le_max_left _ _)
· exact cardinal_mk_eq_max_lift.le
simp
rw [lift_id, lift_id]
simp [bind₁, algebra_map_eq]
simp only [join₂, bind₂, eval₂_hom_map_hom, RingHom.id_comp]
rw [aeval_rename, Function.comp.left_id]
simp [bind₁, ← comp_aeval]
simp only [bind₂, eval₂_comp_right, coe_eval₂_hom, eval₂_map]
congr 1
simp [bind₂]
rw [bind₁, map_aeval, algebra_map_eq]
rw [hom_bind₁, map_comp_C, ← eval₂_hom_map_hom]
rfl
rw [hom_bind₁, eval₂_hom_comp_C]
simp only [monomial_eq, AlgHom.map_mul, bind₁_C_right, Finsupp.prod, AlgHom.map_prod,
    AlgHom.map_pow, bind₁_X_right]
simp only [monomial_eq, RingHom.map_mul, bind₂_C_right, Finsupp.prod, RingHom.map_prod,
    RingHom.map_pow, bind₂_X_right, C_1, one_mul]
rw [bind₂_monomial, f.map_one, one_mul]
intros <;> simp [(· <$> ·)]
intros <;> simp [(· <$> ·)]
intros <;> simp [pure, bind]
intros <;> simp [bind, ← bind₁_comp_bind₁]
rw [supported, Set.image_eq_range, adjoin_range_eq_range_aeval, rename]
simp [supported_equiv_mv_polynomial]
rw [mem_supported]
simp [Algebra.eq_top_iff, mem_supported]
simp [supported_eq_adjoin_X]
simp [mem_supported]
simp [C_apply, monomial]
simp [C_apply, monomial, single_mul_single]
induction n <;> simp [pow_succ, *]
induction n <;> simp [Nat.succ_eq_add_one, *]
rw [← C_mul', mul_one]
simp [X, monomial_pow]
rw [X_pow_eq_monomial, monomial_mul, mul_one]
rw [X_pow_eq_monomial, monomial_mul, one_mul]
rw [← zero_add (single s n), monomial_add_single, C_apply]
rw [← C_mul_X_pow_eq_monomial, pow_one]
rw [← monomial_sum_one, C_mul', ← (monomial _).map_smul, smul_eq_mul, mul_one]
simp only [X_pow_eq_monomial, ← monomial_finsupp_sum_index, Finsupp.sum_single]
intro e
induction e
· simp [ih]
· simp [ih, pow_succ', (mul_assoc _ _ _).symm, h_X, e_ih]
rw [X, support_monomial, if_neg] <;> exact one_ne_zero
rw [X_pow_eq_monomial, support_monomial, if_neg (one_ne_zero' R)]
simp [support, coeff]
simp
simp [support, Finsupp.sum, coeff]
rw [h]
cases single_eq_zero.1 h
simp [monomial_eq]
rw [← coeff_X_pow, pow_one]
rw [coeff_X', if_pos rfl]
rw [mul_def, sum_C]
· simp (config := { contextual := true }) [sum_def, coeff_sum]
simp
simp
simp
intro m hm
simp only [not_not, mem_support_iff, Finset.mem_sdiff, Ne.def] at hm
simp [hm.2, hm.1]
rw [symmDiff_def, Finset.sup_eq_union]
apply Finset.union_subset
· exact support_sdiff_support_subset_support_add p q
· rw [add_comm]
    exact support_sdiff_support_subset_support_add q p
rw [mul_comm, mul_comm r]
exact coeff_mul_monomial' _ _ _ _
rw [ext_iff]
simp only [coeff_zero]
simp [coeff, AddMonoidAlgebra.one_def]
simp [coeff_mul, Finsupp.support_single_ne_zero]
simp [constant_coeff_eq]
simp [constant_coeff_eq]
rw [constant_coeff_eq, coeff_monomial]
simp only [eval₂_eq, ← Finsupp.prod_pow]
rfl
simp [f.map_zero]
simp [add_mul, f.map_add]
simp [f.map_zero]
rw [C_apply, eval₂_monomial, prod_zero_index, mul_one]
simp [eval₂_monomial, f.map_one, X, prod_single_index, pow_one]
rw [monomial_single_add, pow_one, mul_assoc]
simp [ih, prod_single_index, prod_add_index, pow_one, pow_add, mul_assoc, mul_left_comm,
            f.map_one, -add_comm]
simp
apply MvPolynomial.induction_on q
· simp [eval₂_C, eval₂_mul_C]
· simp (config := { contextual := true }) [mul_add, eval₂_add]
· simp (config := { contextual := true }) [X, eval₂_monomial, eval₂_mul_monomial, ← mul_assoc]
rw [pow_zero, pow_zero]
exact eval₂_one _ _
rw [pow_add, pow_one, pow_add, pow_one, eval₂_mul, eval₂_pow]
apply MvPolynomial.ring_hom_ext
· intro r
    rw [RingHom.comp_apply, eval₂_hom_C, eval₂_hom_C, RingHom.comp_apply]
· intro i
    rw [RingHom.comp_apply, eval₂_hom_X', eval₂_hom_X']
rw [← comp_eval₂_hom]
rfl
simp only [monomial_eq, RingHom.map_mul, eval₂_hom_C, Finsupp.prod, RingHom.map_prod,
    RingHom.map_pow, eval₂_hom_X']
apply MvPolynomial.induction_on p <;>
    simp (config := { contextual := true }) [eval₂_add, k.map_add, eval₂_mul, k.map_mul]
apply MvPolynomial.induction_on p <;>
    simp (config := { contextual := true }) [eval₂_add, eval₂_mul]
show _ = eval₂_hom f g (eval₂ C q p)
rw [eval₂_comp_left (eval₂_hom f g)]
congr
rw [smul_eq_C_mul, (eval x).map_mul, eval_C]
rw [eval₂_comp_left (eval g)]
unfold eval
simp only [coe_eval₂_hom]
congr
apply MvPolynomial.induction_on p
· intro r
    rw [eval₂_C, map_C, eval₂_C]
· intro p q hp hq
    rw [eval₂_add, k.map_add, (map f).map_add, eval₂_add, hp, hq]
· intro p s hp
    rw [eval₂_mul, k.map_mul, (map f).map_mul, eval₂_mul, map_X, hp, eval₂_X, eval₂_X]
apply MvPolynomial.induction_on p
· intro r
    rw [eval₂_C, map_C, map_C, eval₂_C]
· intro p q hp hq
    rw [eval₂_add, (map f).map_add, hp, hq, (map f).map_add, eval₂_add]
· intro p s hp
    rw [eval₂_mul, (map f).map_mul, hp, (map f).map_mul, map_X, eval₂_mul, eval₂_X, eval₂_X]
intro p q h
simp only [ext_iff, coeff_map] at h⊢
intro m
exact hf (h m)
rw [map_map, (RingHom.ext hf : f.comp g = RingHom.id _), map_id]
apply MvPolynomial.induction_on p <;> · simp (config := { contextual := true })
rw [← eval_map, ← eval_map, map_map]
rw [C_dvd_iff_dvd_coeff, MvPolynomial.ext_iff]
simp only [coeff_map, coeff_zero, hr]
rw [MvPolynomial.ext_iff]
apply forall_congr'
intro m
rw [coeff_map]
apply eq_iff_eq_cancel_right.mpr
rfl
have h₁ : algebraMap R (MvPolynomial σ S₁) r = C (algebraMap R S₁ r) := rfl
have h₂ : algebraMap R (MvPolynomial σ S₂) r = C (algebraMap R S₂ r) := rfl
rw [h₁, h₂, map, eval₂_hom_C, RingHom.comp_apply, AlgHom.coe_to_ring_hom, AlgHom.commutes]
rw [← comp_eval₂_hom]
rfl
simp only [← Algebra.map_top, ← MvPolynomial.adjoin_range_X, AlgHom.map_adjoin, ← Set.range_comp,
    (· ∘ ·), MvPolynomial.aeval_X]
rw [← Algebra.adjoin_range_eq_range_aeval, Subtype.range_coe]
simp [IsScalarTower.algebra_map_eq S R (MvPolynomial σ R), algebra_map_eq]
rw [← this]
simp only [coe_eval₂_hom, is_empty_ring_equiv_apply, RingEquiv.trans_apply,
        aeval_eq_eval₂_hom]
congr
rw [← sub_eq_zero, this (p - q)]
simp only [h, RingHom.map_sub, forall_const, sub_self]
rw [this, AlgHom.map_zero]
rw [degrees, support_neg] <;> rfl
rw [degrees_neg]
simp [vars, degrees_neg]
rw [hom_C f, eval₂_C]
exact eq_int_cast c n
rw [eval₂_add, hp, hq]
exact (f.map_add _ _).symm
rw [eval₂_mul, eval₂_X, hp]
exact (f.map_mul _ _).symm
simp only [coe_eval₂_hom, Function.comp_apply, eval₂_X]
rw [degree_of_lt_iff h]
intro m hm
simp only [total_degree, support_neg]
rw [sub_eq_add_neg]
rw [total_degree_neg]
have := Finsupp.support_single_subset h
rw [Finset.mem_singleton] at this
rw [this]
rw [support_monomial, if_neg ha, Finset.mem_singleton]
rw [← C_0]
exact degrees_C 0
refine' Finset.sup_le fun b hb => _
have := Finsupp.support_add hb
rw [Finset.mem_union] at this
cases this
· exact le_sup_of_le_left (Finset.le_sup this)
· exact le_sup_of_le_right (Finset.le_sup this)
refine' s.induction _ _
· simp only [Finset.sum_empty, Finset.sup_empty, degrees_zero]
    exact le_rfl
· intro i s his ih
    rw [Finset.sup_insert, Finset.sum_insert his]
    exact le_trans (degrees_add _ _) (sup_le_sup_left ih _)
refine' s.induction _ _
· simp only [Finset.prod_empty, Finset.sum_empty, degrees_one]
· intro i s his ih
    rw [Finset.prod_insert his, Finset.sum_insert his]
    exact le_trans (degrees_mul _ _) (add_le_add_left ih _)
rw [pow_zero, degrees_one]
exact Multiset.zero_le _
rw [pow_succ, add_smul, add_comm, one_smul]
exact le_trans (degrees_mul _ _) (add_le_add_left (degrees_pow n) _)
simp only [degrees, Multiset.mem_sup, ← mem_support_iff, Finsupp.mem_to_multiset, exists_prop]
apply Finset.sup_le
intro d hd
rw [Multiset.disjoint_iff_ne] at h
rw [Multiset.le_iff_count]
intro i
rw [degrees, Multiset.count_finset_sup]
simp only [Finsupp.count_to_multiset]
apply le_antisymm
· apply degrees_add
· apply Multiset.union_le
    · apply le_degrees_add h
    · rw [add_comm]
      apply le_degrees_add h.symm
dsimp only [degrees]
apply Multiset.subset_of_le
apply Finset.sup_mono
apply MvPolynomial.support_map_subset
simp only [degrees, MvPolynomial.support_map_of_injective _ hf]
simp only [degrees, Multiset.map_finset_sup p.support Finsupp.toMultiset f h,
    support_rename_of_injective h, Finset.sup_image]
refine' Finset.sup_congr rfl fun x hx => _
exact (Finsupp.to_multiset_map _ _).symm
rw [vars, degrees_zero, Multiset.to_finset_zero]
rw [vars, degrees_monomial_eq _ _ h, Finsupp.to_finset_to_multiset]
rw [vars, degrees_C, Multiset.to_finset_zero]
rw [X, vars_monomial (one_ne_zero' R), Finsupp.support_single_ne_zero _ (one_ne_zero' ℕ)]
simp only [vars, Multiset.mem_to_finset, mem_degrees, mem_support_iff, exists_prop]
apply Finset.Subset.antisymm (vars_add_subset p q)
intro x hx
simp only [vars, Multiset.disjoint_to_finset] at h hx⊢
rw [degrees_add_of_disjoint h, Multiset.to_finset_union]
exact hx
simp [this]
simp [this]
apply s.induction_on
· simp
· intro a s hs hsub
    simp only [hs, Finset.bUnion_insert, Finset.prod_insert, not_false_iff]
    apply Finset.Subset.trans (vars_mul _ _)
    exact Finset.union_subset_union (Finset.Subset.refl _) hsub
apply t.induction_on
· simp
· intro a s has hsum
    rw [Finset.bUnion_insert, Finset.sum_insert has]
    refine'
      Finset.Subset.trans (vars_add_subset _ _) (Finset.union_subset_union (Finset.Subset.refl _) _)
    assumption
simp [vars, degrees_map]
simp [vars, degrees_map_of_injective _ hf]
rw [vars_monomial hr, Finsupp.support_single_ne_zero _ he]
simp only [degree_of, degrees_zero, Multiset.count_zero]
simp [degree_of, degrees_C]
rw [degree_of_eq_sup i]
apply Finset.le_sup h_m
simp only [degree_of, degrees_rename_of_injective h, Multiset.count_map_eq_count' f p.degrees h]
rw [total_degree]
congr
funext m
exact (Finsupp.card_to_multiset _).symm
rw [total_degree_eq]
exact Finset.sup_le fun s hs => Multiset.card_le_of_le <| Finset.le_sup hs
have := Finsupp.support_single_subset hn
rw [Finset.mem_singleton] at this
subst this
exact le_rfl
rw [← C_0] <;> exact total_degree_C (0 : R)
rw [total_degree, support_X]
simp only [Finset.sup, sum_single_index, Finset.fold_singleton, sup_bot_eq]
have := Finsupp.support_add hn
rw [Finset.mem_union] at this
cases this
· exact le_max_of_le_left (Finset.le_sup this)
· exact le_max_of_le_right (Finset.le_sup this)
apply support_sdiff_support_subset_support_add
rw [Finset.mem_sdiff]
exact ⟨hb₁, hb⟩
rw [add_comm, total_degree_add_eq_left_of_total_degree_lt h]
rw [add_mul, one_mul, add_comm]
simp [total_degree, support_monomial, if_neg hc]
simp [X_pow_eq_monomial, one_ne_zero]
rw [@List.prod_nil (MvPolynomial σ R) _, total_degree_one] <;> rfl
rw [@List.prod_cons (MvPolynomial σ R) _, List.map, List.sum_cons]
exact le_trans (total_degree_mul _ _) (add_le_add_left (total_degree_list_prod ps) _)
refine' Quotient.induction_on s fun l => _
rw [Multiset.quot_mk_to_coe, Multiset.coe_prod, Multiset.coe_map, Multiset.coe_sum]
exact total_degree_list_prod l
refine' le_trans (total_degree_multiset_prod _) _
rw [Multiset.map_map]
rfl
rw [Finset.sum_const, Nat.nsmul_eq_mul, mul_comm, Finset.card_univ]
rw [Finsupp.sum_fintype]
intros
rfl
rw [mem_vars]
exact ⟨d, hd, hi⟩
rw [← AlgHom.map_sum, ← φ.as_sum]
simp only [bind₁_monomial]
simp only [Finset.empty_union, vars_C, Finset.le_iff_subset, Finset.Subset.refl]
cases e <;> simp [to_value, false_imp_iff]
simp [Membership.Mem, mkRbmap, mkRbtree, Rbmap.Mem]
simp [find]
intro h
have := eq_none_of_to_value_eq_none h
exact not_mem_of_find_entry_none this
intro h
simp [find]
apply congr_arg
apply find_entry_eq_find_entry_of_eqv
assumption
simp [eqv_lt_iff_eq] at this <;> assumption
intro h
have := find_entry_insert_of_eqv m v h
simp [find, this, to_value]
simp [StrictWeakOrder.Equiv, Decidable.not_and_iff_or_not, Decidable.not_not_iff] at hn
assumption
intro h
have := find_entry_insert_of_disj m v h
simp [find, this]
intro h
have := find_entry_insert_of_not_eqv m v h
simp [find, this]
intro h
have := find_entry_insert_of_ne m v h
simp [find, this]
cases i <;> rfl
rw [← @append1_drop_last _ γ] <;> apply H
rw [← drop_fun_split_fun f g, H, ← last_fun_split_fun f g, H] <;> simp
try simp <;> congr 1 <;> try simp
intro v v'
rw [← append1_drop_last v, ← append1_drop_last v']
intro fs
rw [← split_drop_fun_last_fun fs]
apply F
intro fs
rw [← split_drop_fun_last_fun fs]
apply F
induction n <;> rfl
induction i <;> simp_all [Prod.fst, Prod.mk]
induction i <;> simp_all [Prod.snd, Prod.mk]
congr <;> simp [Prod.mk]
congr <;> simp [Prod.mk]
rw [← comp_assoc, to_subtype_of_subtype] <;> simp
decide
rw [if_pos (succ_pos m)]
rfl
dsimp [mod, mod_div]
cases (m : ℕ) % (k : ℕ)
· rw [if_pos rfl]
    rfl
· rw [if_neg n.succ_ne_zero]
    rfl
dsimp [div, mod_div]
cases (m : ℕ) % (k : ℕ)
· rw [if_pos rfl]
    rfl
· rw [if_neg n.succ_ne_zero]
    rfl
rw [coe_coe, Nat.toPNat'_coe, if_pos (Int.natAbs_pos_of_ne_zero hn.ne'),
        Int.natAbs_of_nonneg hn.le]
funext p h
rfl
rw [coe_prod, to_of_nat_multiset]
funext p h
apply Subtype.eq
rfl
dsimp [Prod]
rw [to_of_pnat_multiset]
have := prod_of_nat_multiset (l : Multiset ℕ) h
rw [Multiset.coe_prod] at this
exact this
dsimp [Prod]
exact Multiset.prod_zero
change (coe_pnat_monoid_hom (u + v)).Prod = _
rw [coe_pnat_monoid_hom.map_add]
exact Multiset.prod_add _ _
dsimp [factor_multiset]
rw [PrimeMultiset.prod_of_nat_list]
exact Nat.prod_factors n.ne_zero
simp [factor_multiset, PrimeMultiset.ofNatList, PrimeMultiset.ofNatMultiset]
constructor
· intro h
    rw [← prod_factor_multiset m, ← prod_factor_multiset m]
    apply Dvd.intro (n.factor_multiset - m.factor_multiset).Prod
    rw [← PrimeMultiset.prod_add, PrimeMultiset.factor_multiset_prod, add_tsub_cancel_of_le h,
      prod_factor_multiset]
· intro h
    rw [← mul_div_exact h, factor_multiset_mul]
    exact le_self_add
let h := @factor_multiset_le_iff m v.prod
rw [v.factor_multiset_prod] at h
exact h
let h := @PNat.factor_multiset_le_iff' u.prod v
rw [u.factor_multiset_prod] at h
exact h.symm
let h := @prod_dvd_iff u n.factor_multiset
rw [n.prod_factor_multiset] at h
exact h
apply le_antisymm
· apply le_inf_iff.mpr <;> constructor <;> apply factor_multiset_le_iff.mpr
    exact gcd_dvd_left m n
    exact gcd_dvd_right m n
· rw [← PrimeMultiset.prod_dvd_iff, prod_factor_multiset]
    apply dvd_gcd <;> rw [PrimeMultiset.prod_dvd_iff']
    exact inf_le_left
    exact inf_le_right
apply le_antisymm
· rw [← PrimeMultiset.prod_dvd_iff, prod_factor_multiset]
    apply lcm_dvd <;> rw [← factor_multiset_le_iff']
    exact le_sup_left
    exact le_sup_right
· apply sup_le_iff.mpr <;> constructor <;> apply factor_multiset_le_iff.mpr
    exact dvd_lcm_left m n
    exact dvd_lcm_right m n
intros
rw [Multiset.le_count_iff_repeat_le]
rw [← factor_multiset_le_iff, factor_multiset_pow, factor_multiset_of_prime]
congr 2
apply multiset.eq_repeat.mpr
constructor
· rw [Multiset.card_nsmul, PrimeMultiset.card_of_prime, mul_one]
· intro q h
    rw [PrimeMultiset.ofPrime, Multiset.nsmul_singleton _ k] at h
    exact Multiset.eq_of_mem_repeat h
rw [← Nat.card_Icc, ← map_subtype_embedding_Icc, card_map]
rw [← Nat.card_Ico, ← map_subtype_embedding_Ico, card_map]
rw [← Nat.card_Ioc, ← map_subtype_embedding_Ioc, card_map]
rw [← Nat.card_Ioo, ← map_subtype_embedding_Ioo, card_map]
rw [← card_Icc, Fintype.card_of_finset]
rw [← card_Ico, Fintype.card_of_finset]
rw [← card_Ioc, Fintype.card_of_finset]
rw [← card_Ioo, Fintype.card_of_finset]
simp only [exists_prop, ← lt_add_one_iff, find_lt_iff]
simp only [← add_one_le_iff, le_find_iff, add_le_add_iff_right]
simp [find_eq_iff]
simp
refine' (find_eq_iff _).2 ⟨PNat.find_spec h₂, fun n => PNat.recOn n _ _⟩
· simp [h1]
intro m IH hm
simp only [add_lt_add_iff_right, lt_find_iff] at hm
exact hm _ le_rfl
rw [nat_pred, add_tsub_cancel_iff_le.mpr <| show 1 ≤ (n : ℕ) from n.2]
rw [add_coe, sub_coe, if_pos h]
exact add_tsub_cancel_of_le h.le
simp
decide
decide
change (k : ℕ) + (k : ℕ) * (q + 1).pred = 0 + (k : ℕ) * (q + 1)
rw [Nat.pred_succ, Nat.mul_succ, zero_add, add_comm]
rw [mul_comm]
exact mod_add_div _ _
rw [mul_comm]
exact div_add_mod _ _
rw [dvd_iff]
rw [Nat.dvd_iff_mod_eq_zero]
constructor
· intro h
    apply Eq
    rw [mod_coe, if_pos h]
· intro h
rw [dvd_iff']
intro h
rw [← h]
apply (mod_le n m).left
apply Eq
rw [mul_coe]
change (k : ℕ) * (div m k).succ = m
rw [← div_add_mod m k, dvd_iff'.mp h, Nat.mul_succ]
apply pos_iff_ne_zero.2
intro hzero
rw [hzero] at h
exact PNat.ne_zero n (eq_zero_of_zero_dvd h)
let h := mul_pos n.pos m.pos
rw [← gcd_mul_lcm (n : ℕ) (m : ℕ), mul_comm] at h
exact pos_of_dvd_of_pos (Dvd.intro (Nat.gcd (n : ℕ) (m : ℕ)) rfl) h
rw [PNat.dvd_iff]
rw [Nat.dvd_prime pp]
simp
intro pp
intro contra
apply Nat.Prime.ne_one pp
rw [PNat.coe_eq_one_iff]
apply contra
rw [dvd_iff]
apply Nat.Prime.not_dvd_one pp
unfold coprime
unfold Nat.Coprime
rw [← coe_inj]
simp
apply Eq
simp only [gcd_coe]
apply Nat.gcd_comm
rw [dvd_iff]
rw [Nat.gcd_eq_left_iff_dvd]
rw [← coe_inj]
simp
rw [gcd_comm]
apply gcd_eq_left_iff_dvd
rw [mul_comm]
apply coprime.gcd_mul_left_cancel
rw [mul_comm]
apply coprime.gcd_mul_left_cancel_right
rw [← gcd_eq_left_iff_dvd]
apply one_dvd
rw [gcd_comm]
apply one_gcd
unfold coprime
rw [gcd_comm]
simp
rw [mul_comm]
apply coprime.factor_eq_gcd_left cop am bn
rw [gcd_comm]
apply coprime.factor_eq_gcd_left cop am bn
rw [gcd_comm]
apply coprime.factor_eq_gcd_right cop am bn
rw [← coprime_coe] at h
apply Eq
simp only [gcd_coe, mul_coe]
apply Nat.Coprime.gcd_mul k h
rw [dvd_iff]
intro h
apply Eq
simp only [gcd_coe]
apply Nat.gcd_eq_left h
rw [← coprime_coe] at *
simp only [pow_coe]
apply Nat.Coprime.pow
apply h
dsimp [is_reduced, flip]
constructor <;> intro h <;> exact h.symm
dsimp [is_special, flip]
rw [mul_comm u.x, mul_comm u.zp, add_comm u.zp]
dsimp [start, is_special]
rfl
dsimp [start, v, xgcd_type.a, xgcd_type.b, w, z]
rw [one_mul, one_mul, zero_mul, zero_mul, zero_add, add_zero]
rw [← Nat.pred_eq_sub_one, ← Nat.pred_eq_sub_one]
rw [Nat.succ_pred_eq_of_pos a.pos, Nat.succ_pred_eq_of_pos b.pos]
dsimp [is_reduced]
rfl
change u.r - 1 < u.bp
have h₀ : u.r - 1 + 1 = u.r := Nat.succ_pred_eq_of_pos (Nat.pos_of_ne_zero hr)
have h₁ : u.r < u.bp + 1 := Nat.mod_lt (u.ap + 1) u.bp.succ_pos
rw [← h₀] at h₁
exact lt_of_succ_lt_succ h₁
rw [reduce]
simp only
rw [if_pos h]
rw [reduce]
simp only
rw [if_neg h, step]
rw [reduce_a h]
exact u.finish_is_reduced
have : SizeOf.sizeOf u.step < SizeOf.sizeOf u := u.step_wf h
rw [reduce_b h, flip_is_reduced]
apply reduce_reduced
rw [reduce_a h]
exact u.finish_is_special hs
have : SizeOf.sizeOf u.step < SizeOf.sizeOf u := u.step_wf h
rw [reduce_b h]
exact (flip_is_special _).mpr (reduce_special _ (u.step_is_special hs))
rw [reduce_a h, finish_v u h]
have : SizeOf.sizeOf u.step < SizeOf.sizeOf u := u.step_wf h
rw [reduce_b h, flip_v, reduce_v (step u), step_v u h, Prod.swap_swap]
dsimp [gcd_a', gcd_x, gcd_w, xgcd_type.w]
rw [Nat.succ_eq_add_one, Nat.succ_eq_add_one, add_right_comm]
dsimp [gcd_b', gcd_y, gcd_z, xgcd_type.z]
rw [Nat.succ_eq_add_one, Nat.succ_eq_add_one, add_assoc]
rw [← mul_coe, hdet, succ_pnat_coe]
simp
simp
induction m using WithTop.recTopCoe <;> simp [hn.symm]
cases m <;> rfl
simp_all [and_comm, eq_some_iff f, eq_some_iff g]
cases f <;> rfl
rw [← mem_iff_mem] at * <;> cases h : f.symm b <;> simp_all
simp
rw [Set.eq_univ_iff_forall]
intro
rw [← mem_of_set_self_iff, h]
exact rfl
simp only [← of_set_univ, h]
simp [symm_trans_rev, self_trans_symm, -symm_symm]
rw [self_trans_symm, of_set_eq_refl, Set.eq_univ_iff_forall] <;> rfl
simp
rw [f.eq_some_iff, some_get]
simp [Equiv.eq_symm_apply, eq_comm]
rw [mul_assoc]
rw [mul_comm]
rw [mul_add]
rw [mul_comm, left_distrib_aux, mul_comm _ b, mul_comm] <;> rfl
infer_instance
cases n
· cases NeZero.ne 0 rfl
exact Fin.is_lt a
simp [val]
simp [val, Int.natAbs_mul]
cases n
· rw [Nat.mod_zero]
    exact Int.natAbs_ofNat a
rw [← Fin.of_nat_eq_coe]
rfl
intro k
cases n
· simp only [zero_dvd_iff, Int.coe_nat_eq_zero]
rw [Fin.eq_iff_veq]
show (k : Zmod (n + 1)).val = (0 : Zmod (n + 1)).val ↔ _
rw [val_nat_cast, val_zero, Nat.dvd_iff_mod_eq_zero]
cases a
simp [Nat.pos_of_ne_zero n0]
rw [← Nat.smul_one_eq_coe, add_order_of_nsmul' _ a.succ_ne_zero, Zmod.add_order_of_one]
rw [← Nat.smul_one_eq_coe, add_order_of_nsmul' _ a0, Zmod.add_order_of_one]
rw [ringChar.eq_iff]
exact Zmod.char_p n
rw [← Nat.cast_add_one, nat_cast_self (n + 1)]
cases n <;> simp
cases n
· cases NeZero.ne 0 rfl
rfl
cases n <;> simp
cases n <;> simp
cases n
· cases NeZero.ne 0 rfl
· apply Fin.coe_coe_eq_self
cases n
· rw [Int.cast_id a, Int.cast_id a]
· rw [coe_coe, Int.cast_ofNat, Fin.coe_coe_eq_self]
cases n
· cases NeZero.ne 0 rfl
rfl
cases n
· exact Int.cast_one
show ((1 % (n + 1) : ℕ) : R) = 1
cases n
· rw [Nat.dvd_one] at h
    subst m
    apply Subsingleton.elim
rw [Nat.mod_eq_of_lt]
· exact Nat.cast_one
exact Nat.lt_of_sub_eq_succ rfl
intro hn
rw [hn] at h
exact (fintype.card_eq_zero_iff.mp h).elim' 0
rw [← Int.cast_zero, Zmod.int_coe_eq_int_coe_iff, Int.modeq_zero_iff_dvd]
rw [Zmod.int_coe_eq_int_coe_iff, Int.modeq_iff_dvd]
rw [← Nat.cast_zero, Zmod.nat_coe_eq_nat_coe_iff, Nat.modeq_zero_iff_dvd]
have hle : (0 : ℤ) ≤ ↑(a : Zmod n).val := Int.coe_nat_nonneg _
have hlt : ↑(a : Zmod n).val < (n : ℤ) := int.coe_nat_lt.mpr (Zmod.val_lt a)
refine' (Int.mod_eq_of_lt hle hlt).symm.trans _
rw [← Zmod.int_coe_eq_int_coe_iff', Int.cast_ofNat, Zmod.nat_cast_val, Zmod.cast_id]
cases n
· rw [Int.ofNat_zero, Int.mod_zero, Int.cast_id, Int.cast_id]
· rw [← val_int_cast, val, coe_coe]
rw [val, Fin.coe_neg]
cases n
· rw [Nat.mod_one]
· rw [Fin.coe_one, Nat.succ_add_sub_one, Nat.mod_eq_of_lt (Nat.lt.base _)]
cases n
· rw [Int.cast_neg, Int.cast_one, Nat.cast_zero, zero_sub]
· rw [← nat_cast_val, val_neg_one, Nat.cast_succ, add_sub_cancel]
rw [Zmod.int_coe_eq_int_coe_iff]
apply Int.mod_modeq
simp only [Int.cast_ofNat, Int.toNat_coe_nat]
rw [← Nat.cast_one, val_nat_cast]
rw [val_one_eq_one_mod]
exact Nat.mod_eq_of_lt (Fact.out _)
cases n
· cases NeZero.ne 0 rfl
· apply Fin.val_add
cases n
· rw [Nat.mod_zero]
    apply Int.natAbs_mul
· apply Fin.val_mul
rw [val_zero]
rw [val_zero]
unfold Nat.gcdA Nat.xgcd Nat.xgcdAux
rfl
rw [Int.mul_sign]
rw [Nat.gcd_zero_right] <;> rfl
rw [nat_cast_self, zero_mul, add_zero]
conv => 
      rhs
      rw [← Nat.mod_add_div a n] <;>
    simp
cases n
· simp only [Nat.Modeq, Int.coe_nat_inj', Nat.mod_zero]
· rw [Fin.ext_iff, Nat.Modeq, ← val_nat_cast, ← val_nat_cast]
    exact Iff.rfl
rw [Nat.Coprime, Nat.gcd_comm, Nat.gcd_rec] at h
rw [mul_inv_eq_gcd, val_nat_cast, h, Nat.cast_one]
rw [mul_comm, coe_mul_inv_eq_one x h]
apply Units.ext
rfl
rw [mul_comm, mul_inv_of_unit a h]
simp
simp [Nat.lcm_dvd_iff]
simp
decide
decide
conv => 
      lhs
      congr
      rw [← Nat.succ_sub_one n, Nat.succ_sub <| NeZero.pos n]
rw [← Nat.two_mul_odd_div_two hn.1, two_mul, ← Nat.succ_add, add_tsub_cancel_right]
cases a
· simp only [Int.natAbs_ofNat, Int.cast_ofNat, Int.ofNat_eq_coe]
· simp only [neg_eq_self_mod_two, Nat.cast_succ, Int.natAbs, Int.cast_negSucc]
rw [Fin.ext_iff]
exact Iff.rfl
decide
decide
rw [val_nat_cast, Nat.mod_eq_of_lt h]
rw [Nat.mod_eq_of_lt (-a).val_lt]
rw [Nat.Modeq, ← val_add, add_left_neg, tsub_add_cancel_of_le a.val_le, Nat.mod_self,
            val_zero]
rw [neg_val']
cases n
· cases NeZero.ne 0 rfl
· rfl
rw [Nat.le_div_iff_mul_le zero_lt_two, ← Int.ofNat_le, Int.ofNat_mul, Nat.cast_two]
cases n
· simp
rw [Nat.le_div_two_iff_mul_two_le]
cases x.val_min_abs.nat_abs_eq
· rw [← h]
    exact x.val_min_abs_mem_Ioc.2
· rw [← neg_le_neg_iff, ← neg_mul, ← h]
    exact x.val_min_abs_mem_Ioc.1.le
simp only [val_min_abs_def_zero]
simp only [val_min_abs_def_pos, if_true, Int.ofNat_zero, zero_le, val_zero]
cases n
· simp
rw [← val_min_abs_zero n.succ]
apply injective_val_min_abs.eq_iff
erw [sub_nonpos, Int.ofNat_le]
exact a.val_le
cases p
· exact (Nat.not_prime_zero hp.out).elim
exact @Field.IsDomain (Zmod _) (Zmod.field _)
rw [RingEquiv.coe_ring_hom_inj_iff]
apply RingHom.ext_zmod _ _
cases n <;> simp
have := f.lift_of_right_inverse_comp _ (Zmod.ring_hom_right_inverse f) ⟨g, le_of_eq h⟩
rw [Subtype.coe_mk] at this
rw [← this, RingHom.ext_zmod (f.lift_of_right_inverse _ _ ⟨g, _⟩) _, RingHom.id_comp]
rw [← ker_eq_bot_iff, eq_bot_iff]
refine' fun q => induction_on' q fun n hn => _
rw [mem_bot, eq_zero_iff, Int.mem_zmultiples_iff, ←
              zsmul_vadd_eq_iff_minimal_period_dvd]
exact (eq_zero_iff _).mp hn
rw [orbit_zpowers_equiv_symm_apply, Zmod.coe_int_cast]
exact Subtype.ext (zpow_smul_mod_minimal_period _ _ k)
rw [AddAction.orbit_zmultiples_equiv_symm_apply, Zmod.coe_int_cast]
exact Subtype.ext (zsmul_vadd_mod_minimal_period _ _ k)
rw [← Fintype.of_equiv_card (orbit_zpowers_equiv a b), Zmod.card]
rw [← order_of_pos_iff, order_eq_card_zpowers'] at h
exact Nat.finite_of_card_ne_zero h.ne.symm
rw [Ne, Int.gcd_comm, Int.gcd_eq_one_iff_coprime,
    (Nat.prime_iff_prime_int.1 pp.1).coprime_iff_not_dvd, not_not, int_coe_zmod_eq_zero_iff_dvd]
rw [small_congr (Fintype.equivFin α)]
infer_instance
simp
rw [← prod_filter, filter_mem_eq_inter, univ_inter]
apply Finset.prod_eq_mul a b h₁ fun x _ hx => h₂ x hx <;>
    exact fun hc => (hc (Finset.mem_univ _)).elim
simp [Fintype.piFinset, card_map]
rw [Fintype.card_pi, Finset.prod_const] <;> rfl
rw [Fintype.of_equiv_card] <;> simp
simp
simp
simp
simp (config := { contextual := true }) [Function.funext_iff]
simp_all
simp only [Finset.prod_attach_univ, prod_sum, Finset.sum_univ_pi]
simp
simp
rw [← attach_eq_univ, prod_attach]
rw [← Finset.prod_subtype]
simp
rw [← (Equiv.sigmaFiberEquiv f).prod_comp, ← univ_sigma_univ, prod_sigma]
rfl
simp [-coe_eq_univ]
rw [← Finset.powerset_univ, powerset_inj]
simp [Fintype.subtype_card, Finset.card_univ]
cases nonempty_fintype α
infer_instance
simp [Function.funext_iff]
rw [Set.mem_univ_pi]
exact Fintype.mem_pi_finset
simp
simp only [Function.funext_iff, Fintype.mem_pi_finset, mem_singleton]
simp
simp
simp [ext_iff]
rw [← coe_univ, coe_inj]
rw [← coe_nonempty, coe_univ, Set.nonempty_iff_univ_nonempty]
rw [← not_nonempty_iff, ← univ_nonempty_iff, not_nonempty_iff_eq_empty]
simp [compl_eq_univ_sdiff]
rw [mem_compl, not_not]
rw [← compl_erase, erase_singleton, compl_empty]
simp [eq_univ_iff_forall, Finset.Nonempty]
rw [compl_eq_univ_sdiff, sdiff_singleton_eq_erase]
rw [coe_compl]
exact s.insert_inj_on
simp
rw [inter_comm, univ_inter]
rw [← compl_singleton, piecewise_compl, piecewise_singleton]
simp
rw [coe_filter, coe_univ, Set.sep_univ]
simp [Function.funext_iff, Fintype.complete]
simp
simp
unfold injective <;> infer_instance
unfold surjective <;> infer_instance
unfold bijective <;> infer_instance
infer_instance
infer_instance
congr <;> simp [Finset.ext_iff, h₁, h₂]
simp
simp
simp
simp [to_finset]
rw [mem_to_finset, H]
rw [← Finset.coe_nonempty, coe_to_finset]
rw [← s.coe_to_finset, h, t.coe_to_finset]
simp [h] <;> congr
simp [Finset.subset_iff, Set.subset_def]
simp only [Finset.ssubset_def, to_finset_subset, ssubset_def]
simp only [← disjoint_coe, coe_to_finset]
rw [← coe_inj, coe_to_finset, coe_univ]
rw [← coe_ssubset, coe_to_finset, coe_univ]
rw [← Fin.succ_above_zero, Fin.image_succ_above_univ]
rw [← Fin.succ_above_last, Fin.image_succ_above_univ]
simp [map_eq_image]
simp [map_eq_image]
simp [map_eq_image]
simp [map_eq_image]
simp
simp [map_eq_image]
simp
simp [eq_comm]
simp
cases x <;> simp
let ⟨b⟩ := ‹Nonempty β›
simp <;> exact ⟨b, Fintype.complete _⟩
let ⟨a⟩ := ‹Nonempty α›
simp <;> exact ⟨a, Fintype.complete _⟩
simp [h]
simp [true_ne_false]
simp
simp
simp
simp only [ext_iff, Set.ext_iff, Set.mem_to_finset, not_mem_empty, Set.mem_empty_iff_false]
simp
simp [hp, Function.funext_iff]
simp
infer_instance
rw [e] <;> exact a
simp [Quotient.finChoiceAux, Quotient.fin_choice_aux_eq l]
refine' Quotient.sound fun j h => _
infer_instance
infer_instance
dsimp [q]
exact Quotient.induction_on (@Finset.univ ι _).1 fun l => Quotient.fin_choice_aux_eq _ _
simp <;> exact hp
rw [Subtype.ext_iff, Fintype.choose_spec (fun y : { a : α // p a } => (y : α) = x) _]
simp
exact i.2
simp
simp [IH']
simp [A]
simp [hxa]
simp [permsOfList]
rw [← hf.2, mul_apply, hmeml hf.1, swap_apply_left]
rw [← hg.2, mul_apply, hmeml hg.1, swap_apply_left]
rw [← hix, hiy]
rw [hmeml hf₁, ← hg.2] <;> simp
simp [mem_perms_of_list_iff, hab.mem_iff]
simp [mem_perms_of_finset_iff]
cases Int.units_eq_one_or x <;> simp [*]
simp
simp
unfold card Finset.card
exact
    Quot.recOnSubsingleton (@univ α _).1
      (fun l (h : ∀ x : α, x ∈ l) (nd : l.Nodup) =>
        Trunc.mk (nd.nthLeEquivOfForallMemList _ h).symm)
      mem_univ_val univ.2
dsimp only [card, Finset.card]
exact
    Quot.recOnSubsingleton (@univ α _).1
      (fun l (h : ∀ x : α, x ∈ l) (nd : l.Nodup) => Trunc.mk (nd.nthLeBijectionOfForallMemList _ h))
      mem_univ_val univ.2
rw [← subtype_card s H]
congr
rw [← card_of_finset s H] <;> congr
rw [← of_equiv_card f] <;> congr
rw [h]
rw [hs, Finset.card_univ]
rw [Finset.card_univ, Fintype.card_fin]
simp
rw [← card_unit, card_eq] <;>
    exact
      ⟨fun ⟨a⟩ => ⟨a.symm (), fun y => a.Injective (Subsingleton.elim _ _)⟩, fun ⟨x, hx⟩ =>
        ⟨⟨fun _ => (), fun _ => x, fun _ => (hx _).trans (hx _).symm, fun _ =>
            Subsingleton.elim _ _⟩⟩⟩
rw [card, Finset.card_eq_zero, univ_eq_empty_iff]
let ⟨x, hx⟩ := card_eq_one_iff.1 ha.symm
rw [hx a, hx b]
decide
simp [bijective, injective_iff_surjective]
simp [bijective, injective_iff_surjective]
rw [← Set.to_finset_card, Finset.card_eq_iff_eq_univ, ← Set.to_finset_univ, Set.to_finset_inj]
simp [Set.range_subset_iff]
rw [← e.equiv_of_fintype_self_embedding_to_embedding, univ_map_equiv_to_embedding]
refine' Fintype.card_of_subtype _ _
simp
cases nonempty_fintype α
simp only [Fintype.card_subtype_compl, h]
simp only [finset.lt_iff_ssubset.symm, lt_iff_le_not_le, Finset.le_iff_subset,
                Finset.subset_iff, mem_filter, true_and_iff, mem_univ, hxy] <;>
              exact
                ⟨fun z hzx => trans hzx hxy,
                  not_forall_of_exists_not ⟨x, not_imp.2 ⟨hxy, irrefl x⟩⟩⟩
infer_instance
intro h
exact (Finset.range _).card_le_univ.not_lt ((Nat.lt_succ_self _).trans_eq (card_range _).symm)
rw [card_map, card_range]
simp
simp
apply Trunc.bind (this (Fintype.card α))
intro h
apply Trunc.map _ (Fintype.truncEquivFin α)
intro e
exact of_equiv (equiv.ulift.trans e.symm) h
simp only [card_fin, card_pempty, card_ulift]
simp only [card_fin, card_option, card_ulift]
rw [Fintype.card_fin]
exact even_bit0 _
rw [support_erase, ht, Finset.erase_insert hb]
have hf : f i = 0 :=
              (fs.prop i).resolve_left
                (Multiset.not_mem_mono (Multiset.Le.subset <| Multiset.le_add_right _ _) h)
have hg : g i = 0 :=
              (gs.prop i).resolve_left
                (Multiset.not_mem_mono (Multiset.Le.subset <| Multiset.le_add_left _ _) h)
rw [hf, hg]
exact Icc_self _
refine' fun x hx => _
simp only [Pi.nat_apply, Nat.cast_id]
rw [card_Ico_eq_card_Icc_sub_one, card_Icc]
rw [card_Ioc_eq_card_Icc_sub_one, card_Icc]
rw [card_Ioo_eq_card_Icc_sub_two, card_Icc]
rw [card_Iio_eq_card_Iic_sub_one, card_Iic]
subst h
congr
simp only [smul_apply, smul_comm r s (m i)]
simp only [smul_apply, smul_assoc r s (m i)]
simp only [smul_apply, op_smul_eq_smul r (m i)]
simp only [smul_apply, zero_smul, zero_apply]
simp only [add_apply, smul_apply, add_smul]
rw [H, if_t_t]
simp only [filter_apply, if_pos h]
simp only [filter_apply, if_neg h]
rw [H]
simp
rw [single_eq_pi_single, Pi.single, Function.update]
simp [@eq_comm _ i i']
simp only [single_apply, dif_pos rfl]
simp only [single_apply, dif_neg h]
constructor
· intro h
rw [← single_zero i, single_eq_single_iff]
simp
rw [filter_single, if_pos h]
rw [filter_single, if_neg h]
cases h
rfl
simp only [H, if_t_t]
simp
simp [h]
rw [← filter_ne_eq_erase f i]
congr
rw [← filter_ne_eq_erase, filter_single, ite_not]
rw [erase_single, if_pos rfl]
rw [erase_single, if_neg h]
rw [update_eq_erase_add_single f i b, erase_eq_sub_single f i]
simp [ite_zero_add]
subst h <;> simp only [add_apply, single_apply, erase_apply, dif_pos rfl, if_pos, add_zero]
simp only [add_apply, single_apply, erase_apply, dif_neg h, if_neg (Ne.symm h), zero_add]
subst h <;> simp only [add_apply, single_apply, erase_apply, dif_pos rfl, if_pos, zero_add]
simp only [add_apply, single_apply, erase_apply, dif_neg h, if_neg (Ne.symm h), add_zero]
apply Dfinsupp.induction x
exact AddSubmonoid.zero_mem _
exact fun a b f ha hb hf =>
      AddSubmonoid.add_mem _
        (AddSubmonoid.subset_closure <| Set.mem_Union.2 ⟨a, Set.mem_range_self _⟩) hf
simp (config := { contextual := true })
simp [Set.subset_def] <;> exact forall_congr' fun i => not_imp_comm
simp [map_range_def]
simp [zip_with_def]
dsimp only [sigma_curry]
rw [map_range_def]
refine' (Finset.prod_subset support_mk_subset _).trans _
· intro i h1 h2
    dsimp
    simp [h1] at h2
    dsimp at h2
    simp [h1, h2, h0]
· refine' Finset.prod_congr rfl _
    intro i h1
    simp [h1]
simp (config := { contextual := true }) [mem_support_iff, h_zero]
simp (config := { contextual := true }) [mem_support_iff, h_zero]
simp (config := { contextual := true }) [mem_support_iff, h_zero]
simp [h_add, Finset.prod_mul_distrib]
rw [f_eq, g_eq]
simp [Dfinsupp.prod, this]
dsimp [sum_add_hom, single, Trunc.lift_mk]
rw [Multiset.to_finset_singleton, Finset.sum_singleton, Pi.single_eq_same]
simp
simp
rw [lift_add_hom_symm_apply, AddMonoidHom.comp_assoc, lift_add_hom_comp_single]
have := (lift_add_hom fun a => AddMonoidHom.ofMapSub (h a) (h_sub a)).map_sub f g
rw [lift_add_hom_apply, sum_add_hom_apply, sum_add_hom_apply, sum_add_hom_apply] at this
exact this
simp [prod_zero_index]
simp (config := { contextual := true }) [prod_add_index, h_zero, h_add]
have := AddMonoidHom.congr_fun lift_add_hom_single_add_hom f
rw [lift_add_hom_apply, sum_add_hom_apply] at this
exact this
simp
simp
simp
rw [← repeat_one, to_dfinsupp_repeat]
refine' @Dfinsupp.add_hom_ext α (fun _ => ℕ) _ _ _ _ _ _ fun i hi => _
simp
simp [Multiset.le_iff_count, Dfinsupp.le_def]
simp only [ne_locus, Ne.def, eq_self_iff_true, not_true, Finset.filter_false]
rw [← ne_locus_neg_neg, neg_neg]
rw [← @ne_locus_add_right α N _ _ _ _ _ (-g), add_right_neg, ne_locus_zero_right, sub_eq_add_neg]
simp only [sub_eq_add_neg, @ne_locus_add_left α N _ _ _, ne_locus_neg_neg]
rw [← ne_locus_zero_left, ← @ne_locus_add_left α N _ _ _ f 0 g, add_zero]
rw [ne_locus_comm, ne_locus_self_add_right]
rw [sub_eq_add_neg, ne_locus_self_add_right, support_neg]
rw [ne_locus_comm, ne_locus_self_sub_right]
infer_instance
infer_instance
infer_instance
rw [zip_with_apply]
exact inf_le_left
rw [zip_with_apply]
exact inf_le_right
rw [zip_with_apply]
exact le_inf (hf i) (hg i)
rw [zip_with_apply]
exact le_sup_left
rw [zip_with_apply]
exact le_sup_right
rw [zip_with_apply]
exact sup_le (hf i) (hg i)
rw [add_apply, add_apply]
exact add_le_add_left (h i) (c i)
specialize H i
rw [add_apply, add_apply] at H
exact le_of_add_le_add_left H
specialize H i
rw [add_apply, add_apply] at H
exact le_of_add_le_add_left H
simp only [le_def, coe_zero, Pi.zero_apply, imp_true_iff, zero_le]
simp [ext_iff, forall_and]
simp
rw [add_apply, tsub_apply]
exact tsub_le_iff_right
rw [add_apply]
exact le_self_add
simp (config := { contextual := true }) only [subset_iff, tsub_eq_zero_iff_le, mem_support_iff,
    Ne.def, coe_tsub, Pi.sub_apply, not_imp_not, zero_le, imp_true_iff]
simp (config := { contextual := true }) [subset_iff]
rw [disjoint_iff, disjoint_iff, Dfinsupp.bot_eq_zero, ← Dfinsupp.support_eq_empty,
    Dfinsupp.support_inf]
rfl
subst Eq <;> rfl
simp [assoc_right, take, cast_type, List.take_take, Nat.le_add_right, min_eq_left]
simp [assoc_right, take, drop, cast_type, List.drop_take]
simp [add_comm, assoc_right, drop, cast_type, List.drop_drop]
subst Eq <;> rfl
rw [assoc_left]
unfold mul
rw [mul_assoc]
rw [← HolorIndex.take_take, ← HolorIndex.drop_take, ← HolorIndex.drop_drop]
rw [cast_type]
rfl
rw [append_assoc]
simp [cast_heq, mul_assoc0, assoc_left]
simp [mul, HasSmul.smul, HolorIndex.take, HolorIndex.drop]
rw [← h]
exact t.2
rw [← hiis]
exact t.2
rw [h]
simp [slice, mul, HolorIndex.take, unit_vec, HolorIndex.drop, h]
simp [slice, mul, HolorIndex.take, unit_vec, HolorIndex.drop, h] <;> rfl
simp [slice, (· + ·)]
simp [hy]
simp only [add_comm, add_assoc]
apply cprank_max.succ
· assumption
· exact cprank_max_add hx₂ hy
simp [mul_zero x, cprank_max.zero]
rw [mul_left_distrib]
rw [Nat.add_comm]
apply cprank_max_add
· exact cprank_max_1 (cprank_max1.cons _ _ hy₁)
· exact cprank_max_mul k x y₂ hy₂
simp [cprank_max.zero]
apply ih
intro (x : β)(h_x_in_s : x ∈ s)
simp only [h_cprank, Finset.mem_insert_of_mem, h_x_in_s]
simp [Finset.card_range]
cases s₂.has_next
· exact ff
cases h₁ : s₁.has_next
· exact tt
exact
      if s₁.curr = s₂.curr then
        have : s₁.next.2.length < s₁.2.length :=
          match s₁, h₁ with
          | ⟨_, a :: l⟩, h => Nat.lt_succ_self _
        ltb s₁.next s₂.next
      else s₁.curr < s₂.curr termination_
infer_instance
infer_instance
cases s
rfl
infer_instance
infer_instance
simp only [le_iff_to_list_le]
exact fun h₁ h₂ => h₁.trans h₂
simp only [le_iff_to_list_le]
exact le_total _ _
simp only [le_iff_to_list_le, ← to_list_inj]
apply le_antisymm
simp only [le_iff_to_list_le, lt_iff_to_list_lt, lt_iff_le_not_le]
cases hl : l.as_string
exact StringImp.mk.inj hl.symm
rw [← List.to_list_inv_as_string l, ← List.to_list_inv_as_string l', to_list_inj, h]
rw [← String.as_string_inv_to_list s, List.to_list_inv_as_string, List.length_as_string]
rw [← as_string_inv_to_list s, List.as_string_inj, as_string_inv_to_list s]
rw [← @mk.eta _ _ p, ← @mk.eta _ _ q, mk.inj_iff]
simp
simp
simp
cases h <;> simp [*]
change a = c at e <;> subst e <;> exact lex.right _ h
infer_instance
rw [Prod.map_map, hf.comp_eq_id, hg.comp_eq_id, map_id, id]
subst hji
exact v.1
simp [tprod.elim]
simp [tprod.elim, hji]
simp [elim_mk]
simp [Set.tprod]
rw [mk_preimage_tprod l t]
simp only [Cardinal.power_def, ← Cardinal.mk_sigma]
exact mk_congr (equiv_sigma β)
intro h
rw [Cardinal.mk_eq_zero (WType β)]
exact zero_le _
cases t
apply Nat.succ_pos
induction on `n
intro x
cases x
rw [of_nat, to_nat, right_inv_nat n]
simp [right_inv_list tl]
simp [dom, Part.dom_iff_mem]
dsimp <;> congr <;> funext a <;> cases a <;> rfl
simp [restrict]
simp [res, @eq_comm _ b]
simp
funext a <;> dsimp [Functor.map, Pfun.map] <;> cases f a <;> rfl
let ⟨h₁, h₂⟩ := Part.mem_assert_iff.1 h
rw [WellFounded.fix_F_eq] at h₂ <;> exact h₂.fst.fst
rw [Pfun.mem_fix_iff]
exact Or.inl hb
unfold fix_induction'
rw [fix_induction_spec]
simp [Part.get_eq_of_mem fa]
simp [mem_core, mem_res]
rw [preimage_eq, Set.union_distrib_right, Set.union_comm (dom f), Set.compl_union_self,
    Set.inter_univ, Set.union_eq_self_of_subset_right (f.compl_dom_subset_core s)]
rw [to_subtype_apply, Part.mem_mk_iff, exists_subtype_mk_eq_iff, eq_comm]
simp
simp
simp only [comp_apply, Part.bind_comp]
simp only [coe_val, comp_apply, Part.bind_some]
simp
simp [eq_comm]
cases F <;> rfl
delta of_equiv <;> simp
cases h _
rw [← F.eq, eq_bot_iff]
exact fun s _ => ⟨x, hF.trans s.empty_subset⟩
cases F <;> rfl
cases F <;> subst f <;> simp
simp [h]
delta of_equiv <;> simp
simp [Cfilter.toFilter] <;> rw [F.mem_sets] <;> rfl
cases F <;> subst f <;> simp [Cfilter.toFilter, mem_comap] <;>
          exact
            ⟨fun ⟨s, h⟩ => ⟨_, ⟨s, subset.refl _⟩, h⟩, fun ⟨y, ⟨s, h⟩, h₂⟩ =>
              ⟨s, subset.trans (preimage_mono h) h₂⟩⟩
simp
simp <;> exact fun i h₁ h₂ => ⟨i, F.F.inf_le_left _ _ h₁, (G i).f.inf_le_left _ _ h₂⟩
      inf_le_right
simp <;> exact fun i h₁ h₂ => ⟨i, F.F.inf_le_right _ _ h₁, (G i).f.inf_le_right _ _ h₂⟩
simp [Filter.bind, eq_univ_iff_forall, supr_sets_eq]
dsimp <;> congr <;> simp
rw [List.index_of_lt_length] <;> apply h
simp [of_nodup_list._match_1]
simp [of_nodup_list._match_1, *] <;> rw [List.nth_le_index_of] <;> apply List.nodup_dedup
simp [*]
simp [to_list] <;> exists Equiv α x <;> simp
intro <;> simp <;> exact h _
cases x <;> simp
cases x <;> simp
cases x <;> simp
simp
intro <;> simp
intro x <;> cases x <;> simp
simp
intros <;> simp <;> exists Equiv α x <;> simp
rw [h']
simp [pi.enum] <;> refine' ⟨fun a h => f a, mem_pi _ _, rfl⟩
intro <;> simp <;> exact ⟨x hp, rfl⟩
rw [Char.ofNat, dif_pos h]
cases c
simp [Char.toNat]
rw [mem_map, dite_ne_right_iff]
exact
      ⟨fun ⟨⟨j, hj⟩, hf, rfl⟩ => ⟨hj, (mem_filter.1 hf).2⟩, fun ⟨hi, hf⟩ =>
        ⟨⟨i, hi⟩, mem_filter.2 <| ⟨mem_attach _ _, hf⟩, rfl⟩⟩
intro i hi
rw [mem_coe, mem_support_iff] at hi
simp only [mem_antidiagonal, add_comm, Prod.swap]
rw [antidiagonal, antidiagonal', Multiset.to_finsupp_support] <;> rfl
rw [← coe_zero, coe_fn_inj]
simp only [Finsupp.support_eq_empty, Finset.nonempty_iff_ne_empty, Ne.def]
simp [← Finsupp.support_eq_empty, Finset.eq_empty_iff_forall_not_mem]
simp
simp only [Set.subset_def, mem_coe, mem_support_iff] <;> exact forall_congr' fun a => not_imp_comm
simp only [single_apply, hf.eq_iff]
rw [single_eq_indicator, ← Set.piecewise_eq_indicator, Set.piecewise_singleton]
rw [Eq]
simp [single_eq_indicator]
simp [single_apply_eq_zero]
simp [single_apply_eq_zero, not_or]
constructor
· intro eq
rw [support_single_ne_zero _ hb, support_single_ne_zero _ hb', disjoint_singleton]
simp [ext_iff, single_eq_indicator]
simp only [single_apply] <;> ac_rfl
rw [unique_ext_iff, Unique.eq_default a, Unique.eq_default a', single_eq_same, single_eq_same]
simp only [card_eq_one, support_eq_singleton]
simp only [card_eq_one, support_eq_singleton']
rw [hb, support_subset_singleton, single_eq_same]
simp only [card_le_one_iff_subset_singleton, support_subset_singleton]
simp only [card_le_one_iff_subset_singleton, support_subset_singleton']
rw [← equiv_fun_on_finite_single, Equiv.symm_apply_apply]
rw [← support_eq_empty, support_erase, support_zero, erase_empty]
rw [Finsupp.mem_support_iff, Finsupp.on_finset_apply]
rw [mem_support_iff, not_imp_not] <;> exact fun H => (congr_arg f H).trans hf
simp only [hf, zero_apply, map_range_apply]
rw [← support_emb_domain, h, support_single_ne_zero _ hb] <;> rfl
simp only [h_map_support, Finset.mem_singleton]
rw [Subsingleton.elim D] <;> exact support_on_finset_subset
rw [← update_eq_single_add_erase, update_self]
rw [← update_eq_erase_add_single, update_self]
simp only [hf', add_apply, map_range_apply]
simp
simp only [hf', neg_apply, map_range_apply]
simp only [hf', sub_apply, map_range_apply]
rw [sub_eq_add_neg, ← support_neg g]
exact support_add
rw [update_eq_erase_add_single, erase_eq_sub_single]
exact Finset.disjoint_of_subset_right (List.support_sum_subset _) this
refine' ⟨s.to_list, _, Finset.nodup_to_list _⟩
simp
rw [← not_iff_not, not_mem_support_iff, not_ne_iff]
exact singleton_injective.eq_iff.symm
rw [mem_union, ← not_iff_not, not_or, not_mem_support_iff, not_mem_support_iff, not_ne_iff]
exact Icc_eq_singleton_iff.symm
rw [card_Ico_eq_card_Icc_sub_one, card_Icc]
rw [card_Ioc_eq_card_Icc_sub_one, card_Icc]
rw [card_Ioo_eq_card_Icc_sub_two, card_Icc]
rw [card_Iio_eq_card_Iic_sub_one, card_Iic]
simp only [tail_apply, cons_succ]
refine' ⟨fun h => _, fun h => h.casesOn cons_ne_zero_of_left cons_ne_zero_of_right⟩
refine' imp_iff_not_or.1 fun h' c => h _
rw [h', c, Finsupp.cons_zero_zero]
cases c
exact mk_mem_graph_iff
simp only [graph, map_eq_image, image_image, embedding.coe_fn_mk, (· ∘ ·), image_id']
rw [← image_fst_graph, h, image_fst_graph]
simp [graph]
rw [Alist.mem_keys, ← List.mem_to_finset, to_alist_keys_to_finset, mem_support_iff]
simp [← Alist.insert_empty]
simp [h, this]
simp [h, this]
rw [Equiv.trans_apply, hf, hf₂]
rw [Equiv.symm_trans_apply, hf₂', hf']
simp only [Finset.mem_map_equiv, mem_support_to_fun] <;> rfl
rw [map_domain, sum_apply, Sum, Finset.sum_eq_single a, single_eq_same]
· intro b _ hba
    exact single_eq_of_ne (hf.ne hba)
· intro h
    rw [not_mem_support_iff.1 h, single_zero, zero_apply]
rw [map_domain, sum_apply, Sum]
exact Finset.sum_eq_zero fun a' h' => single_eq_of_ne fun eq => h <| Eq ▸ Set.mem_range_self _
refine' ((sum_sum_index _ _).trans _).symm
· intro
    exact single_zero _
· intro
    exact single_add _
refine' sum_congr fun _ _ => sum_single_index _
· exact single_zero _
simp only [h _ H]
rw [Finset.bUnion_singleton] <;> exact subset.refl _
rw [← Function.Embedding.coeFn_mk f hf, ← emb_domain_eq_map_domain, prod_emb_domain]
rw [Eq]
intro a
simp only [finset.mem_def.symm, Finset.mem_preimage]
exact l.mem_support_to_fun (f a)
simp only [Sum, comap_domain_apply, (· ∘ ·)]
simp [comap_domain, Finset.sum_preimage_of_bij f _ _ fun x => g x (l x)]
simp
rw [Subsingleton.elim D] <;> rfl
simp only [FunLike.ext_iff, filter_eq_indicator, zero_apply, Set.indicator_apply_eq_zero,
    Set.mem_setOf_eq]
simp only [FunLike.ext_iff, filter_eq_indicator, Set.indicator_apply_eq_self, Set.mem_setOf_eq,
    not_imp_comm]
rw [Subsingleton.elim D] <;> rfl
rw [← support_eq_empty, support_filter, support_zero, Finset.filter_empty]
refine' Finset.prod_congr rfl fun x hx => _
rw [support_filter, Finset.mem_filter] at hx
rw [filter_apply_pos _ _ hx.2]
simp only [mem_subtype, mem_support_iff]
rw [Subsingleton.elim D] <;> rfl
simp [H]
rw [Subsingleton.elim D] <;> rfl
rw [filter_apply_pos _ _ (mem_filter.1 hx).2]
intro f s ih ha
refine' ⟨Finsupp.curry, Finsupp.uncurry, fun f => _, fun f => _⟩ <;>
    simp only [Finsupp.curry, Finsupp.uncurry, sum_sum_index, sum_zero_index, sum_add_index,
      sum_single_index, single_zero, single_add, eq_self_iff_true, forall_true_iff,
      forall₃_true_iff, Prod.mk.eta, (single_sum _ _ _).symm, sum_single]
rw [← Finset.bUnion_singleton]
refine' Finset.Subset.trans support_sum _
refine' Finset.bUnion_mono fun a _ => support_single_subset
rw [comap_smul_def, one_smul_eq_id, map_domain_id]
rw [comap_smul_def, comap_smul_def, comap_smul_def, ← comp_smul_left, map_domain_comp]
simp only [smul_apply, mem_support_iff, Ne.def]
exact mt fun h => h.symm ▸ smul_zero _
simp [Finsupp.smul_apply, hb]
rw [smul_single, smul_eq_mul, mul_one]
simp only [AddMonoidHom.to_fun_eq_coe, single_add_hom_apply, smul_single]
simp only [← equiv_map_domain_trans, Equiv.self_trans_symm]
exact equiv_map_domain_refl _
intro v
simp only [← equiv_map_domain_trans, Equiv.symm_trans_self]
exact equiv_map_domain_refl _
simp only [equiv_map_domain_eq_map_domain] <;> exact map_domain_add
dsimp only [split]
rw [comap_domain_apply]
rw [split_support, mem_image, Ne.def, ← support_eq_empty, ← Ne.def, ←
    Finset.nonempty_iff_ne_empty, split, comap_domain, Finset.Nonempty]
simp only [exists_prop, Finset.mem_preimage, exists_and_right, exists_eq_right, mem_support_iff,
    Sigma.exists, Ne.def]
intro i
rw [mem_split_support_iff_nonzero, not_iff_not, hg]
simp only [Sum, sigma_support, sum_sigma, split_apply]
simp
simp only [Sum, Multiset.count_sum', Multiset.count_singleton, mul_boole, coe_mk,
        mem_support_iff, Multiset.count_nsmul, Finset.sum_ite_eq, ite_not, ite_eq_right_iff]
exact Eq.symm
simp only [Sum, coe_mk, Multiset.to_finset_sum_count_nsmul_eq]
rw [to_multiset_apply, sum_single_index] <;> apply zero_nsmul
simp [to_multiset_apply, AddMonoidHom.map_finsupp_sum, Function.id_def]
refine' f.induction _ _
· rw [to_multiset_zero, Multiset.map_zero, map_domain_zero, to_multiset_zero]
· intro a n f _ _ ih
    rw [to_multiset_add, Multiset.map_add, ih, map_domain_add, map_domain_single,
      to_multiset_single, to_multiset_add, to_multiset_single, ← Multiset.coe_map_add_monoid_hom,
      (Multiset.mapAddMonoidHom g).map_nsmul]
    rfl
refine' f.induction _ _
· rw [to_multiset_zero, Multiset.prod_zero, Finsupp.prod_zero_index]
· intro a n f _ _ ih
    rw [to_multiset_add, Multiset.prod_add, ih, to_multiset_single, Multiset.prod_nsmul,
      Finsupp.prod_add_index' pow_zero pow_add, Finsupp.prod_single_index, Multiset.prod_singleton]
    · exact pow_zero a
simp only [Multiset.count_nsmul]
simp only [Multiset.count_singleton, if_false, H.symm, mul_zero]
simp only [not_mem_support_iff.1 H, zero_mul]
rw [Multiset.count_singleton_self, mul_one]
rw [← Multiset.count_ne_zero, Finsupp.count_to_multiset, Finsupp.mem_support_iff]
simp
simp [Multiset.le_iff_count, le_def]
rw [← card_to_multiset, ← card_to_multiset]
apply Multiset.card_lt_of_lt
exact to_multiset_strict_mono h
simp only [ne_locus, Ne.def, eq_self_iff_true, not_true, Finset.filter_false]
rw [← ne_locus_neg_neg, neg_neg]
rw [← ne_locus_add_right _ _ (-g), add_right_neg, ne_locus_zero_right, sub_eq_add_neg]
simp only [sub_eq_add_neg, ne_locus_add_left, ne_locus_neg_neg]
rw [← ne_locus_zero_left, ← ne_locus_add_left f 0 g, add_zero]
rw [ne_locus_comm, ne_locus_self_add_right]
rw [sub_eq_add_neg, ne_locus_self_add_right, support_neg]
rw [ne_locus_comm, ne_locus_self_sub_right]
simp only [Dfinsupp.mem_support_iff]
rw [← Finset.mem_def, mem_split_support_iff_nonzero]
exact (Decidable.em _).symm
simp [split_apply, dif_neg h, this]
simp [h]
intro a h
simp only [mul_apply, mem_support_iff] at h
simp only [mem_support_iff, mem_inter, Ne.def]
rw [← not_or]
intro w
apply h
cases w <;>
    · rw [w]
      simp
apply Set.Finite.subset g.finite_support
simp only [Function.support_subset_iff, Finsupp.mem_support_iff, Ne.def,
          Finsupp.fun_support_eq, Finset.mem_coe]
intro x hx h
apply hx
rw [h, smul_zero]
dsimp at h
rw [h]
simp only [le_def, coe_zero, Pi.zero_apply, imp_true_iff, zero_le]
simp [ext_iff, forall_and]
simp
simp (config := { contextual := true }) only [subset_iff, tsub_eq_zero_iff_le, mem_support_iff,
    Ne.def, coe_tsub, Pi.sub_apply, not_imp_not, zero_le, imp_true_iff]
simp (config := { contextual := true }) [subset_iff]
rw [disjoint_iff, disjoint_iff, Finsupp.bot_eq_zero, ← Finsupp.support_eq_empty,
    Finsupp.support_inf]
rfl
simp [mk] <;> congr <;> exact Classical.choose_spec h
delta bind bind._proof_1 <;> cases f a.out <;> rfl
simp [map]
cases x <;> rfl
cases x
cases y
apply Wequiv.abs
apply h
apply funext
apply Quotient.ind
intro x
apply recF_eq_of_Wequiv
rw [fix_to_W]
apply Wrepr_equiv
apply Quot.sound
apply Wequiv.abs'
rw [Pfunctor.W.dest_mk, abs_map, abs_repr, ← abs_map, Pfunctor.map_eq]
conv => 
      rhs
      simp only [Wrepr, recF_eq, Pfunctor.W.dest_mk, abs_repr]
rfl
change (fix.mk ∘ fix.dest) x = id x
apply fix.ind_rec
intro x
dsimp
rw [fix.dest, fix.rec_eq, id_map, comp_map]
intro h
rw [h]
unfold fix.dest
rw [fix.rec_eq, ← fix.dest, ← comp_map]
conv => 
    rhs
    rw [← id_map x]
congr
rw [corecF, Pfunctor.M.dest_corec]
intro x y h
exact ⟨r, pr, h⟩
conv => 
    lhs
    rw [cofix.dest, cofix.corec];
dsimp
rw [corecF_eq, abs_map, abs_repr, ← comp_map]
rfl
intro u v cuv
apply Quot.sound
dsimp [r']
rw [Quot.sound cuv]
apply h'
intro c
apply Quot.induction_on c
clear c
intro c d
apply Quot.induction_on d
clear d
intro d rcd
apply Quot.sound
apply rcd
dsimp [Functor.Comp]
intro p
exact abs ⟨p.1.1, fun x => abs ⟨p.1.2 x, fun y => p.2 ⟨x, y⟩⟩⟩
dsimp [Functor.Comp]
intro y
refine' ⟨⟨(repr y).1, fun u => (repr ((repr y).2 u)).1⟩, _⟩
dsimp [Pfunctor.comp]
intro x
exact (repr ((repr y).2 x.1)).snd x.2
rw [abs_repr, FG_abs_repr]
rw [abs_map, FG_abs_map]
rw [liftp_iff]
refine' ⟨a, f, haf.symm, fun i => mem_image_of_mem _ (mem_univ _)⟩
rw [h] <;> intro u <;> exact id
    rw [liftp_iff]
rw [← hfi] <;> apply h'
    exact (mem_supp x u).mp this _ _ h''
  rintro ⟨a, f, xeq, h⟩ p
rw [liftp_iff]
constructor
rw [← supp_preservation_iff_liftp_preservation, supp_preservation_iff_uniform]
intros <;> rfl
intros <;> cases p <;> rfl
intros <;> simp
intros <;> simp <;> rfl
rw [corecF, M.dest_corec]
intro a₁ a₂ ra₁a₂
apply Quot.sound
exact ⟨a₁, a₂, ra₁a₂, rfl, rfl⟩
intro x y h
exact ⟨r, pr, h⟩
conv => 
    lhs
    rw [cofix.dest, cofix.corec];
dsimp
rw [corecF_eq, abs_map, abs_repr, ← comp_map, ← append_fun_comp]
rfl
rw [append_fun_comp_id, comp_map, comp_map] <;> exact h _ _ r'ab
intro u v cuv
apply Quot.sound
dsimp [r']
rw [Quot.sound cuv]
apply h'
intro c
apply Quot.induction_on c
clear c
intro c d
apply Quot.induction_on d
clear d
intro d rcd
apply Quot.sound
apply rcd
intros <;> rw [← liftr_last_rel_iff] <;> apply h <;> assumption
apply cofix.bisim_rel (fun x y : cofix F α => x = cofix.mk (cofix.dest y)) _ _ _ rfl
dsimp
intro x y h
rw [h]
conv => 
    lhs
    congr
    skip
    rw [cofix.mk]
    rw [cofix.dest_corec]
rw [← comp_map, ← append_fun_comp, id_comp]
rw [← comp_map, ← append_fun_comp, id_comp, ← cofix.mk]
congr 2
have : cofix.mk ∘ cofix.dest = @_root_.id (cofix F α) := funext cofix.mk_dest
rw [cofix.mk, cofix.dest_corec, ← comp_map, ← cofix.mk, ← append_fun_comp, this, id_comp,
    append_fun_id_id, Mvfunctor.id_map]
rw [← cofix.mk_dest x, h, cofix.mk_dest]
rw [← cofix.dest_mk x, h, cofix.dest_mk]
rw [cofix.corec', cofix.dest_corec]
dsimp
congr
rw [cofix.corec₁, cofix.dest_corec', ← h] <;> rfl
rw [abs_repr, FG_abs_repr]
rw [abs_map, FG_abs_map]
rw [recF, Mvpfunctor.W_rec_eq] <;> rfl
apply q.P.W_cases _ x
intro a f' f
rw [recF_eq, q.P.W_dest'_W_mk, Mvpfunctor.map_eq, append_fun_comp_split_fun, Typevec.id_comp]
apply q.P.W_cases _ x
intro a₀ f'₀ f₀
apply q.P.W_cases _ y
intro a₁ f'₁ f₁
intro h
induction h
case ind a f' f₀ f₁ h ih => simp only [recF_eq, Function.comp, ih]
case abs a₀ f'₀ f₀ a₁ f'₁ f₁ h => simp only [recF_eq', abs_map, Mvpfunctor.W_dest'_W_mk, h]
case trans x y z e₁ e₂ ih₁ ih₂ => exact Eq.trans ih₁ ih₂
revert h
apply q.P.W_cases _ x
intro a₀ f'₀ f₀
apply q.P.W_cases _ y
intro a₁ f'₁ f₁
apply Wequiv.abs
apply q.P.W_cases _ x <;> intro a f' f <;> exact Wequiv.abs a f' f a f' f rfl
intro h
induction h
case ind a f' f₀ f₁ h ih => exact Wequiv.ind _ _ _ _ ih
case abs a₀ f'₀ f₀ a₁ f'₁ f₁ h => exact Wequiv.abs _ _ _ _ _ _ h.symm
case trans x y z e₁ e₂ ih₁ ih₂ => exact Mvqpf.WequivCat.trans _ _ _ ih₂ ih₁
rw [Wrepr, recF_eq', q.P.W_dest'_W_mk] <;> rfl
apply funext
apply Quotient.ind
intro x
apply recF_eq_of_Wequiv
apply Wrepr_equiv
apply Quot.sound
apply Wequiv.abs'
rw [Mvpfunctor.W_dest'_W_mk', abs_map, abs_repr, ← abs_map, Mvpfunctor.map_eq]
conv => 
      rhs
      rw [Wrepr_W_mk, q.P.W_dest'_W_mk', abs_repr, Mvpfunctor.map_eq]
congr 2
rw [Mvpfunctor.appendContents, Mvpfunctor.appendContents]
rw [append_fun, append_fun, ← split_fun_comp, ← split_fun_comp]
rfl
apply Quot.ind
intro x
apply q.P.W_ind _ x
intro a f' f ih
show g₁
apply Quot.ind
intro x
apply q.P.W_ind _ x
intro a f' f ih
change p
intro α
apply Quot.ind
intro a
apply Quot.sound
apply Wrepr_equiv
intro α β g x
conv => 
      rhs
      dsimp [Mvfunctor.map]
rw [fix.map]
apply Quot.sound
apply Wequiv.refl
rw [this]
rw [liftp_iff]
refine' ⟨a, f, haf.symm, _⟩
intro i u
exact mem_image_of_mem _ (mem_univ _)
rw [← hfi] <;> apply h'
    refine' (mem_supp x _ u).mp hh _ _ hu
  rintro ⟨a, f, xeq, h⟩ p
rw [liftp_iff]
constructor
rw [← supp_preservation_iff_liftp_preservation, supp_preservation_iff_uniform]
intro h
induction h
· constructor
    simp [lift]
· subst h_n'
    apply is_searchable_insert
    assumption
simp [Membership.Mem, Rbtree.Mem, Rbnode.Mem, mkRbtree]
cases t
apply Rbnode.find_correct
apply Rbnode.is_searchable_of_well_formed
assumption
simp [HEq, (eq_of_eqv_lt heqv).symm]
cases t
apply Rbnode.find_correct_exact
apply Rbnode.is_searchable_of_well_formed
assumption
cases t
intro h
apply Rbnode.find_insert_of_eqv lt h
apply Rbnode.is_searchable_of_well_formed
assumption
cases t
intro h
apply Rbnode.find_insert_of_disj lt h
apply Rbnode.is_searchable_of_well_formed
assumption
cases t
intro h
apply Rbnode.find_insert_of_not_eqv lt h
apply Rbnode.is_searchable_of_well_formed
assumption
cases t
apply Rbnode.eqv_of_find_some
apply Rbnode.is_searchable_of_well_formed
assumption
cases t
apply Rbnode.find_eq_find_of_eqv
apply Rbnode.is_searchable_of_well_formed
assumption
cases t
apply Rbnode.mem_insert_of_incomp
intros
apply mem_insert_of_incomp
constructor <;> apply irrefl_of lt
cases t
apply Rbnode.mem_insert_of_incomp
cases t
apply Rbnode.mem_insert_of_mem
cases t
apply Rbnode.equiv_or_mem_of_mem_insert
simp [eqv_lt_iff_eq] at this <;> assumption
cases t
apply Rbnode.mem_of_min_eq
cases t
apply Rbnode.mem_of_max_eq
cases t
intro h
congr
apply Rbnode.eq_leaf_of_min_eq_none h
cases t
intro h
congr
apply Rbnode.eq_leaf_of_max_eq_none h
cases t
apply Rbnode.max_is_maximal
apply Rbnode.is_searchable_of_well_formed
assumption
induction t
case leaf => assumption
case red_node l y r => 
    cases h : cmpUsing lt x y
    case lt => apply h₂; assumption; assumption
    case eq => apply h₃; assumption
    case gt => apply h₄; assumption; assumption
case black_node l y r => 
    cases h : cmpUsing lt x y
    case lt => apply h₅; assumption; assumption
    case eq => apply h₆; assumption
    case gt => apply h₇; assumption; assumption
simp [cmpUsing] at h
assumption
simp [cmpUsing] at h
exact h.2
simp [cmpUsing] at h
assumption
simp [cmpUsing] at h
exact h.2
induction t <;> intro lo hi hs
case leaf => cases hs; assumption
all_goals 
    cases hs
    have h₁ := t_ih_lchild hs_hs₁
    have h₂ := t_ih_rchild hs_hs₂
    cases lo <;> cases hi <;> simp [lift] at *
    apply trans_of lt h₁ h₂
apply lo_lt_hi
assumption
apply lo_lt_hi
assumption
apply t_ih_lchild
assumption
assumption
apply t_ih_rchild
assumption
assumption
intro _ _ hs hn x hm
cases hn <;> cases hs
all_goals exact (range hs_hs₁ hm).2
intro _ _ hs hn z hm
cases hn <;> cases hs
all_goals exact (range hs_hs₂ hm).1
intro _ _ hs hn x z hm₁ hm₂
cases hn <;> cases hs
all_goals 
    have h₁ := range hs_hs₁ hm₁
    have h₂ := range hs_hs₂ hm₂
    exact trans_of lt h₁.2 h₂.1
apply le_min <;> assumption
apply le_succ
simp_all [depth, upper]
apply succ_le_succ
apply Nat.mul_le_mul_left
apply depth_min h
cases r₂ <;> rfl
cases l₁ <;> simp [get_color, balance1, false_imp_iff]
cases l <;> cases r <;> simp [get_color, balance1, false_imp_iff]
cases r₂ <;> rfl
cases l₁ <;> simp [get_color, balance2, false_imp_iff]
cases l <;> cases r <;> simp [get_color, balance2, false_imp_iff]
cases l <;> cases r
any_goals apply red_left
any_goals apply red_right <;> simp [get_color] <;> contradiction <;> done
any_goals apply other <;> simp [get_color] <;> contradiction <;> done
apply balance.cases l x r <;> intros <;> simp [*] <;> contradiction
intro h
cases s
· contradiction
all_goals simp [balance1_node]; apply balance1_ne_leaf
apply balance.cases l x r <;> intros <;> simp [*] <;> contradiction
intro h
cases s
· contradiction
all_goals simp [balance2_node]; apply balance2_ne_leaf
intro h
simp [insert]
apply is_searchable_mk_insert_result
apply is_searchable_ins <;> · first |assumption|simp
intros
cases s <;> simp [*]
all_goals apply balance.cases s_lchild s_val s_rchild <;> intros <;> simp [*]
intros
cases s <;> simp [*]
all_goals apply balance.cases s_lchild s_val s_rchild <;> intros <;> simp [*]
intros
cases s <;> simp
· contradiction
all_goals apply balance.cases s_lchild s_val s_rchild <;> intros <;> simp [*]
intros
cases s <;> simp
· contradiction
all_goals apply balance.cases s_lchild s_val s_rchild <;> intros <;> simp [*]
apply ins.induction lt t x
any_goals intros ; simp [ins, *]
· intros
    apply balance1_node_ne_leaf
    assumption
· intros
    apply balance2_node_ne_leaf
    assumption
simp [insert]
cases he : ins lt t x <;> cases get_color t <;> simp [mk_insert_result]
· have := ins_ne_leaf lt t x
    contradiction
· exact absurd he (ins_ne_leaf _ _ _)
apply ins.induction lt t y <;> intros <;> simp [ins, *]
· have := ih h
    apply mem_balance1_node_of_mem_left
    assumption
· have := ih h
    apply mem_balance2_node_of_mem_left
    assumption
intros <;> cases c <;> cases t <;> simp_all [mk_insert_result, mem]
cases t <;> cases c <;> simp [mk_insert_result, mem] <;> intros <;> assumption
intros <;> unfold insert <;> apply mem_mk_insert_result <;> apply mem_ins_of_incomp <;> assumption
intros <;> apply mem_mk_insert_result <;> apply mem_ins_of_mem <;> assumption
simp [insert]
intros
apply equiv_or_mem_of_mem_ins
exact mem_of_mem_mk_insert_result lt h
intro _ _ hs₁ hs₂ heq heqv
have hs := is_searchable_balance1_node lt hs₁ hs₂
have := Eq.trans (find_eq_find_of_eqv hs₁ heqv.symm) HEq
have := Iff.mpr (find_correct_exact hs₁) this
have := mem_exact_balance1_node_of_mem_exact z s this
have := Iff.mp (find_correct_exact hs) this
exact Eq.trans (find_eq_find_of_eqv hs heqv) this
intro _ _ hs₁ hs₂ heq heqv
have hs := is_searchable_balance2_node lt hs₁ hs₂
have := Eq.trans (find_eq_find_of_eqv hs₂ heqv.symm) HEq
have := Iff.mpr (find_correct_exact hs₂) this
have := mem_exact_balance2_node_of_mem_exact z s this
have := Iff.mp (find_correct_exact hs) this
exact Eq.trans (find_eq_find_of_eqv hs heqv) this
have := not_lt_of_lt h
simp [*]
cases t <;> cases c <;> simp [mk_insert_result]
· simp [find]
    cases cmpUsing lt x t_val <;> simp [find]
intro hs
simp [insert, find_mk_insert_result]
apply find_ins_of_eqv lt he hs <;> simp
simp [find]
all_goals cases cmpUsing lt x y <;> simp [find]
simp [find, cmpUsing, *]
have := not_lt_of_lt h
simp [find, cmpUsing, *]
simp [find, cmpUsing, *]
cases t <;> simp [balance1_node]
· contradiction
all_goals intros ;
cases t <;> simp [balance1_node]
all_goals intros ;
cases t <;> simp [balance1_node]
· contradiction
all_goals intros ;
cases t <;> simp [balance2_node]
all_goals intros ;
cases t <;> simp [balance2_node]
· contradiction
all_goals intros ;
cases t <;> simp [balance2_node]
· contradiction
all_goals intros ;
intro hs
simp [insert, find_mk_insert_result]
apply find_ins_of_disj lt hd hs <;> simp
simp [StrictWeakOrder.Equiv, Decidable.not_and_iff_or_not, Decidable.not_not_iff] at hn
assumption
intro h₁ h₂
cases h₂ <;> simp only [get_color] at h₁ <;> contradiction
intro h₁ h₂
cases h₂ <;> simp only [get_color] at h₁ <;> contradiction
intro h
have := insert_rb lt x h
cases c <;> simp [insert_rb_result] at this
· constructor
    constructor
    assumption
· cases this
    constructor
    constructor
    assumption
induction t
· intros
    contradiction
all_goals 
    cases t_lchild <;> simp [Rbnode.min] <;> intro h
    · subst t_val
      simp [mem, irrefl_of lt a]
    all_goals rw [mem]; simp [t_ih_lchild h]
induction t
· intros
    contradiction
all_goals 
    cases t_rchild <;> simp [Rbnode.max] <;> intro h
    · subst t_val
      simp [mem, irrefl_of lt a]
    all_goals rw [mem]; simp [t_ih_rchild h]
induction t
· intros
    rfl
all_goals 
    cases t_lchild <;> simp [Rbnode.min, false_imp_iff] <;> intro h
    all_goals have := t_ih_lchild h; contradiction
induction t
· intros
    rfl
all_goals 
    cases t_rchild <;> simp [Rbnode.max, false_imp_iff] <;> intro h
    all_goals have := t_ih_rchild h; contradiction
constructor
constructor
constructor
constructor
constructor
constructor
rw [matrix_eq_sum_std_basis M, ← Finset.sum_product']
apply Finset.sum_induction _ _ h_add h_zero
· intros
    apply h_std_basis
simp [hi]
simp [hj]
simp [trace, h]
simp [trace]
simp [mul_apply, std_basis_matrix]
simp [mul_apply, std_basis_matrix, mul_comm]
simp [mul_apply, h.symm]
simp [mul_apply, hbj.symm]
trace
            "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `reflect_name #[]"
trace
              "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `reflect_name #[]"
dsimp only [Matrix]
exact h m
refine' Fin.cases _ _ i <;> simp
simp [dot_product, Fin.sum_univ_succ, vec_head, vec_tail]
simp [dot_product, Fin.sum_univ_succ, vec_head, vec_tail]
simp
simp
subst_vars
subst_vars
rw [cons_add_cons, cons_add_cons, empty_add_empty]
rw [cons_add_cons, cons_add_cons, cons_add_cons, empty_add_empty]
rw [smul_cons, smul_cons, smul_empty]
rw [smul_cons, smul_cons, smul_cons, smul_empty]
rw [cons_dot_product_cons, cons_dot_product_cons, dot_product_empty, add_zero]
rw [cons_dot_product_cons, cons_dot_product_cons, cons_dot_product_cons, dot_product_empty,
    add_zero, add_assoc]
rw [← sum_hadamard_eq, Finset.sum_comm]
simp [dot_product, vec_mul, Finset.sum_mul, mul_assoc]
simp [h]
simp [diagonal]
simp [diagonal, h]
rw [show d₁ = d₂ from funext h]
rw [conj_transpose, diagonal_transpose, diagonal_map (star_zero _)]
rfl
simp only [one_apply, Pi.single_apply, eq_comm] <;> congr
simp [bit1_apply]
simp [bit1_apply, h]
simp [dot_product]
simp [dot_product]
simp [dot_product]
simp [dot_product, add_mul, Finset.sum_add_distrib]
simp [dot_product, mul_add, Finset.sum_add_distrib]
simp [dot_product]
simp [diagonal_apply_ne' _ hij]
simp [diagonal_apply_ne' _ hij]
simp [diagonal_apply_ne _ hij]
simp [Pi.single_eq_of_ne hij]
simp [Pi.single_eq_of_ne hij]
simp [dot_product]
simp [dot_product]
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
simp [dot_product, Finset.smul_sum, smul_mul_assoc]
simp [dot_product, Finset.smul_sum, mul_smul_comm]
simp [dot_product]
simp [dot_product]
simp [dot_product]
rw [← diagonal_transpose]
apply dot_product_diagonal
rw [sub_eq_add_neg, Matrix.add_mul, Matrix.neg_mul, sub_eq_add_neg]
rw [sub_eq_add_neg, Matrix.mul_add, Matrix.mul_neg, sub_eq_add_neg]
simp
simp only [coe_scalar, smul_eq_mul, mul_one, one_apply_eq, Pi.smul_apply]
simp only [h, coe_scalar, one_apply_ne, Ne.def, not_false_iff, Pi.smul_apply, smul_zero]
simp [Commute, SemiconjBy]
rw [algebra_map_eq_diagonal, algebra_map_eq_diagonal, diagonal_map hf]
congr 1
simp
simp only [dot_product, vec_mul, mul_vec, Finset.mul_sum, Finset.sum_mul, mul_assoc] <;>
    exact Finset.sum_comm
simp [sub_eq_add_neg, add_mul_vec, neg_mul_vec]
simp [sub_eq_add_neg, vec_mul_add, vec_mul_neg]
rw [← mul_vec_mul_vec, mul_vec_transpose]
rw [← vec_mul_vec_mul, vec_mul_transpose]
simp only [algebra_map_eq_diagonal, diagonal_transpose, MulOpposite.algebra_map_apply]
simp
simp
simp [conj_transpose]
simp
simp
simp [h]
simp
simp
simp
simp
simp
simp
simp
simp
simp [mul_apply]
simp
rw [submatrix_apply]
simp only [submatrix_submatrix, Function.comp.right_id, submatrix_id_id, Equiv.symm_comp_self]
simp only [submatrix_submatrix, Function.comp.right_id, submatrix_id_id, Equiv.symm_comp_self]
simp
simp
rw [submatrix_mul_equiv, submatrix_id_id]
rw [conj_transpose, conj_transpose, transpose_map, transpose_map, update_row_transpose,
    map_update_column]
rfl
rw [conj_transpose, conj_transpose, transpose_map, transpose_map, update_column_transpose,
    map_update_row]
rfl
rw [← diagonal_transpose, update_row_transpose, diagonal_update_column_single, diagonal_transpose]
simp [Matrix.mul_apply, RingHom.map_sum]
simp only [Matrix.dotProduct, f.map_sum, f.map_mul]
simp only [Matrix.vecMul, Matrix.map_apply, RingHom.map_dot_product]
simp only [Matrix.mulVec, Matrix.map_apply, RingHom.map_dot_product]
rw [Pequiv.matrix_mul_apply, ← Equiv.to_pequiv_symm, Equiv.to_pequiv_apply,
      Matrix.submatrix_apply, id.def]
rw [← to_matrix_trans, single_trans_single]
rw [← to_matrix_trans, single_trans_single_of_ne hb, to_matrix_bot]
rw [← Matrix.mul_assoc, single_mul_single]
simp only [conj_transpose, from_blocks_transpose, from_blocks_map]
simp
cases ik
cases jk
rfl
simp only [conj_transpose, block_diagonal_transpose]
rw [block_diagonal_map _ star (star_zero α)]
rw [block_diagonal_diagonal]
cases ik
cases jk
rfl
simp only [conj_transpose, block_diagonal'_transpose]
exact block_diagonal'_map _ star (star_zero α)
rw [block_diagonal'_diagonal]
rw [dif_neg hj'.symm, zero_mul]
simp only [hf₃, diagonal_one]
rw [rank, to_lin'_one, LinearMap.range_id, finrank_top, Module.Free.finrank_pi]
rw [rank, LinearEquiv.map_zero, LinearMap.range_zero, finrank_bot]
refine' LinearMap.finrank_le_finrank_of_injective (Submodule.of_le_injective _)
rw [to_lin'_mul]
exact LinearMap.range_comp_le_range _ _
rw [LinearMap.range_eq_top]
exact e₂.surjective
simp [h]
simp
simp only [length_eq_countp_add_countp (Eq (!b)), Bool.not_not_eq, count]
rw [add_comm, count_bnot_add_count]
cases b <;> cases x <;> try exact this <;> exact this.symm
simp only [Bool.eq_not_iff, em]
rw [← count_bnot_add_count l b, hl.count_bnot_eq_count h2, two_mul]
rw [Nat.div_le_iff_le_mul_add_pred two_pos, ← tsub_le_iff_right]
exact length_sub_one_le_two_mul_count_bool hl b
simp only [all_iff_forall, Bool.of_decide_iff]
simp [any_iff_exists]
cases b <;> rfl
simp [h]
cases b <;> simp
simp [h]
cases b <;> assumption
cases h <;> exact ⟨_, h⟩
cases b <;> simp
simp [cond_eq_ite]
cases b <;> rfl
decide
decide
decide
decide
decide
decide
simp [H]
simp [H]
decide
decide
decide
decide
decide
decide
cases a <;> simp
cases c <;> simp
cases a <;> simp
cases c <;> simp
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
cases a <;> simp
cases c <;> simp
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
cases x <;> cases h₁ : f tt <;> cases h₂ : f ff <;> simp only [h₁, h₂]
rw [← image_univ, univ_eq, image_pair]
subst h
rfl
simp [image₂, and_assoc']
rw [← card_product, ← coe_product]
exact card_image_iff
rw [← mem_coe, coe_image₂, mem_image2_iff hf, mem_coe, mem_coe]
rw [← coe_subset, coe_image₂, coe_image₂]
exact image2_subset hs ht
rw [← coe_nonempty, coe_image₂]
exact image2_nonempty_iff
simp
simp
simp
simp
simp
rw [image₂_singleton_left, card_image_of_injective _ hf]
rw [image₂_singleton_right, card_image_of_injective _ hf]
rw [← image₂_curry, curry_uncurry]
rw [image₂_swap f]
exact image_image₂_distrib fun _ _ => h_antidistrib _ _
simp [to_finset]
simp [to_finset]
simp [to_finset]
simp [pimage]
simp only [coe_pimage, Pfun.image_union, coe_union]
simp [subset_iff, @forall_swap _ β]
simp only [← coe_subset, coe_pimage, coe_inter, Pfun.image_inter]
rw [antidiagonal, mem_def, Multiset.Nat.mem_antidiagonal]
simp [antidiagonal]
simp
apply eq_of_veq
rw [cons_val, map_val]
· apply Multiset.Nat.antidiagonal_succ
simp
apply eq_of_veq
rw [cons_val, map_val]
exact Multiset.Nat.antidiagonal_succ'
simp
simp
simp [antidiagonal, Multiset.Nat.map_swap_antidiagonal]
refine' ⟨congr_arg Prod.fst, fun h => Prod.ext h ((add_right_inj q.fst).mp _)⟩
rw [mem_antidiagonal] at hp hq
rw [hq, ← h, hp]
cases s <;> simp only [powerset, mem_mk, mem_pmap, mem_powerset, exists_prop, exists_eq_right] <;>
    rw [← val_le_iff]
rw [← powerset_empty, powerset_inj]
apply mt _ h
apply mem_powerset.1 ht
simp [Ne.symm (ne_insert_of_not_mem _ _ h)]
rw [ssubsets, mem_erase, mem_powerset, ssubset_iff_subset_ne, and_comm]
rw [mem_ssubsets, ssubset_iff_subset_ne]
exact ⟨empty_subset s, h.ne_empty.symm⟩
cases s <;> simp [powerset_len, val_le_iff.symm] <;> rfl
rw [h]
exact ⟨empty_subset s, rfl⟩
rw [card_powerset_len, Nat.choose_eq_zero_of_lt h]
simp [Finset.powersetLen, map_pmap, pmap_eq_map, map_id']
rw [Eq]
simp [Finset.Nonempty]
simp only [← not_nonempty_iff_eq_empty, sigma_nonempty, not_exists]
simp only [le_antisymm_iff, Finset.sup_le_iff, mem_sigma, and_imp, Sigma.forall]
exact
    ⟨fun i a hi ha => (le_sup hi).trans' <| le_sup ha, fun i hi a ha =>
      le_sup <| mem_sigma.2 ⟨hi, ha⟩⟩
simp [Sigma.ext_iff]
rw [mem_sigma_lift]
exact fun H => h H.fst
rw [mem_sigma_lift]
exact fun H => h H.snd.fst
rw [mem_filter, mem_powerset]
exact and_comm' _ _
rw [mem_filter, mem_ssubsets]
exact and_comm' _ _
rw [mem_filter, mem_powerset]
exact and_comm' _ _
rw [mem_filter, mem_ssubsets]
exact and_comm' _ _
rw [card_Ico_eq_card_Icc_sub_one, card_Icc_finset h]
rw [card_Ioc_eq_card_Icc_sub_one, card_Icc_finset h]
rw [card_Ioo_eq_card_Icc_sub_two, card_Icc_finset h]
rw [Iic_eq_powerset, card_powerset]
rw [Iio_eq_ssubsets, ssubsets, card_erase_of_mem (mem_powerset_self _), card_powerset]
rw [Sym2.is_diag_iff_proj_eq]
exact (mem_off_diag.1 h).2.2
rw [mem_sym2_iff, Sym2.ball]
rw [Finset.sym2, image_eq_empty, product_eq_empty, or_self_iff]
rw [Finset.sym2, nonempty.image_iff, nonempty_product, and_self_iff]
rw [Finset.sym2, singleton_product_singleton, image_singleton, Sym2.diag]
rw [← image_union, diag_union_off_diag]
rfl
rw [← not_nonempty_iff_eq_empty] at h⊢
exact fun hs => h (hs.Sym _)
rw [mem_powerset_len_univ_iff, mem_coe]
rw [Fintype.card, ← card_powerset_len]
exact card_le_of_subset h𝒜.subset_powerset_len_univ
simp only [← Finset.coe_subset, Set.not_subset, exists_prop, Finset.mem_coe]
simp only [Set.ssubset_def, Finset.coe_subset]
rw [← coe_empty, coe_inj]
rw [← coe_singleton, coe_inj]
simp [eq_singleton_iff_nonempty_unique_mem]
simp only [eq_singleton_iff_unique_mem, ExistsUnique]
rw [coe_singleton, Set.singleton_subset_iff]
rw [← coe_subset, coe_singleton, Set.subset_singleton_iff_eq, coe_eq_empty, coe_eq_singleton]
rw [← coe_ssubset, coe_singleton, Set.ssubset_singleton_iff, coe_eq_empty]
rw [← coe_eq_singleton]
exact Set.eq_singleton_or_nontrivial ha
simp only [mem_cons, or_imp, forall_and, forall_eq]
induction m using Multiset.induction_on <;> simp
rw [Disjoint.comm, disjoint_left]
simp only [disjoint_left, imp_not_comm, forall_eq']
rw [not_imp, not_not]
simp only [disjoint_left, mem_singleton, forall_eq]
rw [disjoint_singleton_left, mem_singleton]
rw [Finset.disjoint_left, Set.disjoint_left]
rfl
rw [disj_union_comm, singleton_disj_union]
rw [dedup_cons, dedup_eq_self] <;> rfl
rw [insert_val, ndinsert_of_not_mem h]
simp
simp only [mem_coe, mem_insert, Set.mem_insert_iff]
simp
simp only [mem_insert, or_left_comm]
rw [← coe_pair, coe_inj]
simp only [mem_insert, or.assoc.symm, or_self_iff]
simp only [subset_iff, mem_insert, forall_eq, or_imp, forall_and]
refine'
    { toFun := fun y => if h : ↑y = x then none else some ⟨y, (mem_insert.mp y.2).resolve_left h⟩
      invFun := fun y => (y.elim ⟨x, mem_insert_self _ _⟩) fun z => ⟨z, mem_insert_of_mem z.2⟩.. }
· intro y
simp only [disjoint_left, mem_insert, or_imp, forall_and, forall_eq]
rw [disjoint_insert_left, Disjoint.comm]
simp
rw [mem_union, not_or]
simp only [mem_union, or_left_comm]
simp only [mem_union, or_assoc', or_comm' (x ∈ t)]
simp only [insert_eq, union_assoc]
simp only [insert_eq, union_left_comm]
simp only [insert_union, union_insert, insert_idem]
rw [← union_eq_left_iff_subset, eq_comm]
rw [← union_eq_right_iff_subset, eq_comm]
simp only [disjoint_left, mem_union, or_imp, forall_and]
simp only [disjoint_right, mem_union, or_imp, forall_and]
intro a b
refine' Finset.induction_on b empty_right fun x s xs hi => symm _
rw [Finset.insert_eq]
apply union_of _ (symm hi)
refine' Finset.induction_on a empty_right fun a t ta hi => symm _
rw [Finset.insert_eq]
exact union_of singletons (symm hi)
simp (config := { contextual := true }) only [subset_iff, mem_inter] <;> intros <;>
      constructor <;>
    trivial
rw [← coe_inj, coe_inter, coe_union, Set.union_inter_cancel_left]
rw [← coe_inj, coe_inter, coe_union, Set.union_inter_cancel_right]
simp only [mem_inter, and_comm']
simp only [mem_inter, and_assoc']
simp only [mem_inter, and_left_comm]
simp only [mem_inter, and_right_comm]
rw [inter_comm, union_inter_cancel_right]
rw [inter_comm, insert_inter_of_mem h, inter_comm]
rw [inter_comm, insert_inter_of_not_mem h, inter_comm]
rw [insert_inter_of_mem H, empty_inter]
rw [inter_comm, singleton_inter_of_mem h]
rw [inter_comm, singleton_inter_of_not_mem h]
intro a a_in
rw [Finset.mem_inter] at a_in⊢
exact ⟨h a_in.1, h' a_in.2⟩
simp (config := { contextual := true }) only [subset_iff, mem_inter, mem_union, and_imp,
            or_imp] <;>
          simp only [true_or_iff, imp_true_iff, true_and_iff, or_true_iff]
simp only [mem_erase] <;> exact And.intro
rw [mem_erase, not_and] at hsa
exact not_imp_not.mp hsa hs
simp (config := { contextual := true }) only [mem_erase, mem_insert, and_congr_right_iff,
      false_or_iff, iff_self_iff, imp_true_iff]
rw [erase_insert_eq_erase, erase_eq_of_not_mem h]
have : x ≠ b ∧ x = a ↔ x = a := and_iff_right_of_imp fun hx => hx.symm ▸ h
simp only [mem_erase, mem_insert, and_or_left, this]
rw [and_comm', Set.mem_diff, Set.mem_singleton_iff] <;> rfl
rw [cons_eq_insert, erase_insert_eq_erase, erase_eq_of_not_mem h]
simp
simp only [subset_iff, or_iff_not_imp_left, mem_erase, mem_insert, and_imp] <;>
    exact forall_congr' fun x => forall_swap
rw [subset_insert_iff, erase_eq_of_not_mem h]
rw [← subset_insert_iff, insert_eq_of_mem h]
refine' ⟨fun h => _, congr_arg _⟩
rw [eq_of_mem_of_not_mem_erase hx]
rw [← h]
simp
rw [← insert_erase hs, ← insert_erase ht, h]
simp only [mem_sdiff, h, not_true, not_false_iff, and_false_iff]
simp [union_comm]
rw [← coe_inj, coe_insert, coe_sdiff, coe_sdiff, coe_insert]
exact Set.insert_diff_of_not_mem s h
rw [← coe_inj, coe_sdiff, coe_sdiff, coe_insert]
exact Set.insert_diff_of_mem s h
refine' subset.antisymm (sdiff_subset_sdiff (subset.refl _) (subset_insert _ _)) fun y hy => _
simp only [mem_sdiff, mem_insert, not_or] at hy⊢
exact ⟨hy.1, fun hxy => h <| hxy ▸ hy.1, hy.2⟩
simp only [sdiff_singleton_eq_erase, ha, erase_eq_of_not_mem, not_false_iff]
rw [sdiff_insert, insert_erase (mem_sdiff.mpr ⟨hxs, hxt⟩)]
rw [← sdiff_singleton_eq_erase, sdiff_sdiff_right_self]
exact inf_eq_right.2 (singleton_subset_iff.2 hx)
rw [← sdiff_singleton_eq_erase, sdiff_eq_empty_iff_subset, subset_singleton_iff]
cases s
dsimp [SizeOf.sizeOf, SizeOf.sizeOf, Finset.sizeof]
apply lt_add_left
exact Multiset.sizeof_lt_sizeof_of_mem hx
simp [Finset.Nonempty]
simp [piecewise]
simp [piecewise, hi]
simp [piecewise, hi]
simp [piecewise, h]
rw [← insert_emptyc_eq, piecewise_insert, piecewise_empty]
rw [update_piecewise]
refine' s.piecewise_congr (fun _ _ => rfl) fun j hj => update_noteq _ _ _
exact fun h => hj (h.symm ▸ hi)
rw [update_piecewise]
refine' s.piecewise_congr (fun j hj => update_noteq _ _ _) fun _ _ => rfl
exact fun h => hi (h ▸ hj)
simp only [mem_filter, and_comm', and_left_comm]
simp only [mem_filter, and_false_iff] <;> rfl
simp [Finset.ext_iff]
simp only [nonempty_iff_ne_empty, Ne.def, filter_eq_empty_iff, not_not, not_forall]
constructor <;> simp (config := { contextual := true }) [disjoint_left]
simp only [mem_filter, mem_union, or_and_right]
simp only [mem_filter, mem_union, and_or_distrib_left.symm]
rw [mem_filter, mem_inter]
rw [inter_comm, filter_inter, inter_comm]
simp only [mem_filter, mem_union, and_or_left]
simp only [mem_filter, mem_inter, and_comm', and_left_comm, and_self_iff]
simp only [mem_sdiff, mem_filter]
congr
rw [← not_nonempty_iff_eq_empty, nonempty_range_iff, not_not]
simp only [not_mem_empty, false_and_iff, exists_false]
simp only [mem_insert, or_and_right, exists_or, exists_eq_left]
simp only [mem_insert, or_imp, forall_and, forall_eq]
simp
simp
rw [← cons_zero, to_finset_cons, to_finset_zero, IsLawfulSingleton.insert_emptyc_eq]
simp
contradiction
simp
simp only [Finset.subset_iff, Multiset.subset_iff, Multiset.mem_to_finset]
simp [Finset.ext_iff, perm_ext (nodup_dedup _) (nodup_dedup _)]
simp only [Finset.ext_iff, mem_to_finset]
rw [← Multiset.coe_eq_coe]
exact Multiset.Nodup.to_finset_inj hl hl' h
cases l <;> simp
rw [to_list, ← Multiset.coe_nodup, Multiset.coe_to_list]
exact s.nodup
simp [h, nodup_to_list s]
simp only [List.mem_cons_iff, Finset.mem_to_list, Finset.mem_cons]
simp
simp only [mem_def, disj_Union_val, mem_bind, exists_prop]
simp only [Set.ext_iff, mem_disj_Union, Set.mem_Union, iff_self_iff, mem_coe, imp_true_iff]
simp only [mem_def, bUnion_val, mem_dedup, mem_bind, exists_prop]
simp only [Set.ext_iff, mem_bUnion, Set.mem_Union, iff_self_iff, mem_coe, imp_true_iff]
simp only [mem_bUnion, exists_prop, mem_union, mem_insert, or_and_right, exists_or,
      exists_eq_left]
simp [or_and_distrib_right, exists_or_distrib]
simp (config := { contextual := true }) [hs, ht]
simp only [subset_iff, mem_bUnion] <;>
    exact ⟨fun H a ha b hb => H ⟨a, ha, hb⟩, fun H b ⟨a, ha, hb⟩ => H a ha hb⟩
rw [inter_comm, bUnion_inter] <;> simp [inter_comm]
simp only [Multiset.mem_to_finset, mem_bUnion, Multiset.mem_bind, exists_prop]
intro x
simp only [and_imp, mem_bUnion, exists_prop]
exact Exists.imp fun a ha => ⟨h ha.1, ha.2⟩
simp only [mem_bUnion, mem_singleton, exists_prop, exists_eq_right']
simp [Finset.Nonempty, ← exists_and_left, @exists_swap α]
rw [traverse, Multiset.id_traverse]
exact s.val_to_finset
unfold traverse
simp only [map_comp_coe, functor_norm]
rw [IsLawfulFunctor.comp_map, Multiset.map_traverse]
dsimp only [fold]
rw [cons_val, Multiset.map_cons, fold_cons_left]
unfold fold <;> rw [insert_val, ndinsert_of_not_mem h, Multiset.map_cons, fold_cons_left]
simp only [fold, map, Multiset.map_map]
simp only [fold, image_val_of_inj_on H, Multiset.map_map]
rw [fold, fold, map_congr rfl H]
simp only [fold, fold_distrib]
rw [fold, fold, ← fold_hom op hm, Multiset.map_map]
unfold fold <;>
    rw [← fold_add op, ← Multiset.map_add, union_val, inter_val, union_add_inter, Multiset.map_add,
      hc.comm, fold_add]
simp [hx]
simp [hx]
simp [hx]
apply Finset.induction_on s
· simp only [fold_empty]
· intro a s has ih
    rw [fold_insert has, ih, insert_eq]
show _ ≥ _ ↔ _
apply fold_op_rel_iff_or
intro x y z
show _ ≤ _ ↔ _
exact min_le_iff
show _ > _ ↔ _
apply fold_op_rel_iff_or
intro x y z
show _ < _ ↔ _
exact min_lt_iff
show _ ≥ _ ↔ _
apply fold_op_rel_iff_and
intro x y z
show _ ≤ _ ↔ _
exact max_le_iff
show _ > _ ↔ _
apply fold_op_rel_iff_and
intro x y z
show _ < _ ↔ _
exact max_lt_iff
rw [coe_image]
exact hs.image_of_le hf
rw [coe_to_finset] at hl
exact hn.pairwise_of_set_pairwise hl
rw [coe_to_finset, hn.pairwise_coe]
exact ⟨hs⟩
rw [hg, update_same]
apply not_mem_erase
rw [hg, update_idem, update_same, insert_erase x_mem, update_eq_self]
simp
simp [hx']
rw [← image_mul_prod]
exact (hs.prod ht).image_of_monotone (monotone_fst.mul' monotone_snd)
simp [mul_antidiagonal, and_rotate]
simp [mul_comm, and_left_comm]
rw [mem_mul_antidiagonal] at hb
exact ⟨b.1, b.2, hb⟩
simp only [noncomm_foldr, coe_foldr, coe_attach, List.attach]
rw [← List.foldr_map]
simp [List.map_pmap, List.pmap_eq_map]
induction s using Quotient.induction_on
simp
induction s using Quotient.induction_on
simp
rw [← assoc.assoc, comm hx hy h, assoc.assoc]
simp [noncomm_fold]
induction s using Quotient.induction_on
simp
induction s using Quotient.induction_on
simp
induction s using Quotient.induction_on
simp
induction s using Quotient.induction_on
simp only [quot_mk_to_coe, noncomm_prod_coe, coe_card, mem_coe] at *
exact List.prod_eq_pow_card _ m h
induction s using Quotient.induction_on
simp
induction s using Quotient.induction_on
simp only [quot_mk_to_coe, noncomm_prod_coe]
exact Commute.list_prod_right _ _ h
rw [← h₂ _ hx, ← h₂ _ hy]
subst h₁
exact comm hx hy h
rw [← List.dedup_eq_self] at hl
simp [noncomm_prod, hl]
simp [insert_val_of_not_mem ha, noncomm_prod]
simp [noncomm_prod, insert_val_of_not_mem ha, Multiset.noncomm_prod_cons']
simp [noncomm_prod, ← Multiset.cons_zero]
simp [noncomm_prod, Multiset.noncomm_prod_map]
intro x hx y hy h
apply Commute.mul_left <;> apply Commute.mul_right
· exact comm_ff.of_refl hx hy
· exact (comm_gf hy hx h.symm).symm
· exact comm_gf hx hy h
· exact comm_gg.of_refl hx hy
rw [empty_union, sup_empty, bot_sup_eq]
rw [insert_union, sup_insert, sup_insert, ih, sup_assoc]
refine' Finset.cons_induction_on s _ fun b t _ h => _
· rw [sup_empty, sup_empty, sup_empty, bot_sup_eq]
· rw [sup_cons, sup_cons, sup_cons, h]
    exact sup_sup_sup_comm _ _ _ _
subst hs <;> exact Finset.fold_congr hfg
apply Iff.trans Multiset.sup_le
simp only [Multiset.mem_map, and_imp, exists_imp]
exact ⟨fun k b hb => k _ _ hb rfl, fun k a' b hb h => h ▸ k _ hb⟩
simp [@forall_swap _ β]
simp only [le_antisymm_iff, Finset.sup_le_iff, mem_product, and_imp, Prod.forall]
exact
    ⟨fun b c hb hc => (le_sup hb).trans' <| le_sup hc, fun b hb c hc =>
      le_sup <| mem_product.2 ⟨hb, hc⟩⟩
rw [sup_product_left, Finset.sup_comm]
refine' Finset.cons_induction_on s _ fun b t _ h => _
· rw [sup_empty, sup_empty, bot_sdiff]
· rw [sup_cons, sup_cons, h, sup_sdiff]
rw [sup_cons, sup_cons, g_sup, ih]
rw [comp_sup_eq_sup_comp coe] <;> intros <;> rfl
rw [← coe_fold_r, ← Multiset.fold_dedup_idem, sup_def, ← List.to_finset_coe, to_finset_val,
    Multiset.map_id]
rfl
rw [Finset.coe_subset]
apply Finset.subset_insert
      -- x ∈ s is above the sup of r
simp [Sup_eq_supr, sup_eq_supr]
subst hs <;> exact Finset.fold_congr hfg
refine' Finset.cons_induction_on s _ fun b t _ h => _
· rw [sup_empty, inf_empty, sdiff_top]
· rw [sup_cons, inf_cons, h, sdiff_inf]
rw [← coe_fold_r, ← Multiset.fold_dedup_idem, inf_def, ← List.to_finset_coe, to_finset_val,
    Multiset.map_id]
rfl
simp only [disjoint_iff, sup_inf_distrib_left, sup_eq_bot_iff]
simp only [disjoint_iff, sup_inf_distrib_right, sup_eq_bot_iff]
rw [sup', WithBot.coe_unbot]
rw [← WithBot.coe_eq_coe]
simp only [coe_sup', sup_cons, WithBot.coe_sup]
rw [← WithBot.coe_eq_coe]
simp only [coe_sup', sup_insert, WithBot.coe_sup]
rw [← WithBot.coe_le_coe, coe_sup']
exact Finset.sup_le fun b h => WithBot.coe_le_coe.2 <| hs b h
rw [← WithBot.coe_le_coe, coe_sup']
exact le_sup h
apply le_antisymm
· apply sup'_le
    intros
    exact le_rfl
· apply le_sup' (fun b => a) H.some_spec
simp [@forall_swap _ β]
rw [← WithBot.coe_eq_coe, coe_sup']
let g' := WithBot.map g
show g' ↑(s.sup' H f) = s.sup fun a => g' ↑(f a)
rw [coe_sup']
refine' comp_sup_eq_sup_comp g' _ rfl
intro f₁ f₂
induction f₁ using WithBot.recBotCoe
· rw [bot_sup_eq]
    exact bot_sup_eq.symm
· induction f₂ using WithBot.recBotCoe
    · rfl
    · exact congr_arg coe (g_sup f₁ f₂)
subst s
refine' eq_of_forall_ge_iff fun c => _
simp (config := { contextual := true }) only [sup'_le_iff, h₂]
rw [← WithBot.coe_eq_coe, coe_sup', sup_map, coe_sup']
simp only [← sup'_eq_sup h, coe_sup' h]
rw [← WithBot.coe_le_coe, coe_sup', Finset.le_sup_iff (WithBot.bot_lt_coe a)]
exact bex_congr fun b hb => WithBot.coe_le_coe
rw [← WithBot.coe_lt_coe, coe_sup', Finset.lt_sup_iff]
exact bex_congr fun b hb => WithBot.coe_lt_coe
rw [← WithBot.coe_lt_coe, coe_sup', Finset.sup_lt_iff (WithBot.bot_lt_coe a)]
exact ball_congr fun b hb => WithBot.coe_lt_coe
rw [← insert_emptyc_eq]
exact max_insert
let ⟨a, ha⟩ := max_of_nonempty H
rw [h] at ha <;> cases ha,
    fun h => h.symm ▸ max_empty
cases H
rw [← insert_emptyc_eq]
exact min_insert
let ⟨a, ha⟩ := min_of_nonempty H
rw [h] at ha <;> cases ha,
    fun h => h.symm ▸ min_empty
simp [min', Finset.min]
simp [min']
simp [max', Finset.max]
simp [max']
rw [max_eq_sup_with_bot, sup_image]
exact congr_fun Option.map_id _
rw [min_eq_inf_with_top, inf_image]
exact congr_fun Option.map_id _
rw [max_eq_sup_with_bot, sup_image]
exact congr_fun Option.map_id _
rw [min_eq_inf_with_top, inf_image]
exact congr_fun Option.map_id _
rw [coe_insert, max_comm]
exact (is_greatest_max' _ _).insert _
rw [coe_insert, min_comm]
exact (is_least_min' _ _).insert _
rw [this]
exact is_least_min' s hs
rw [← mem_coe]
exact ((is_glb_iff_is_least i s hs).mp his).1
simp
rw [← supr_eq_supr_finset, ← equiv.plift.surjective.supr_comp] <;> rfl
simp
simp
simp
simp [supr_or, supr_sup_eq]
rw [insert_eq]
simp only [supr_union, Finset.supr_singleton]
rw [← supr_coe, coe_image, supr_image, supr_coe]
rw [← infi_coe, coe_image, infi_image, infi_coe]
simp [@supr_comm _ α, supr_and]
simp (config := { contextual := true }) [mem_image]
simp (config := { contextual := true }) [mem_image]
simp only [mem_product, mem_bUnion, mem_image, exists_prop, Prod.mk.inj_iff, and_left_comm,
      exists_and_left, exists_eq_right, exists_eq_left]
simp only [mem_product, mem_bUnion, mem_image, exists_prop, Prod.mk.inj_iff, and_left_comm,
      exists_and_left, exists_eq_right, exists_eq_left]
rw [← not_nonempty_iff_eq_empty, nonempty_product, not_and_or, not_nonempty_iff_eq_empty,
    not_nonempty_iff_eq_empty]
simp only [product_singleton, Function.Embedding.coeFn_mk, map_singleton]
simp only [diag, mem_filter, mem_product]
constructor <;> intro h <;> simp only [h, and_true_iff, eq_self_iff_true, and_self_iff]
rw [← h.2]
exact h.1
simp only [off_diag, mem_filter, mem_product]
constructor <;> intro h <;> simp only [h, Ne.def, not_false_iff, and_self_iff]
rw [this]
apply card_image_of_inj_on
exact fun x1 h1 x2 h2 h3 => (Prod.mk.inj h3).1
rw [← diag_union_off_diag, union_comm, union_sdiff_self,
    sdiff_eq_self_of_disjoint (disjoint_diag_off_diag _).symm]
rw [← diag_union_off_diag, union_sdiff_self, sdiff_eq_self_of_disjoint (disjoint_diag_off_diag _)]
simp [← Finset.card_eq_zero]
rw [← product_sdiff_off_diag, off_diag_singleton, sdiff_empty, singleton_product_singleton]
rw [insert_eq, insert_eq, diag_union, diag_singleton]
rw [insert_eq, union_comm, off_diag_union (disjoint_singleton_right.2 has), off_diag_singleton,
    union_empty, union_right_comm]
apply card_le_of_subset
cases Finset.decidableMem a s
· simp [Finset.singleton_inter_of_not_mem h]
· simp [Finset.singleton_inter_of_mem h]
rw [← cons_eq_insert _ _ h, card_cons]
rw [insert_eq_of_mem h]
rw [card_insert_of_not_mem (not_mem_singleton.2 h), card_singleton]
rw [to_list, ← Multiset.coe_card, Multiset.coe_to_list]
rfl
simp only [card, image_val_of_inj_on H, card_map]
refine' Multiset.eq_of_le_of_card_le (Multiset.dedup_le _) _
rw [H]
simp only [Multiset.card_map]
rw [← pos_iff_ne_zero, card_pos, fiber_nonempty_iff_mem_image]
simp [Finset.subtype]
rw [← eq_of_subset_of_card_le (s.filter_subset p) h.ge, mem_filter] at hx
exact hx.2
rw [this]
simp [ha₂]
simp [hst, h]
simp
rw [← disj_union_eq_union s t h, card_disj_union _ _ _]
rw [sdiff_inter_self_right t s]
rw [← card_disjoint_union sdiff_disjoint, sdiff_union_self_eq_union]
rw [← card_pos, card_sdiff h₂, ← h, Nat.add_right_comm, add_tsub_cancel_right, Nat.add_succ]
apply Nat.succ_pos
rw [card_erase_of_mem (mem_sdiff.1 ha).1, ← h]
rfl
cases s <;> simp only [Multiset.card_eq_one, Finset.card, ← val_inj, singleton_val]
rw [card_sdiff hst, ← h, add_tsub_cancel_left]
rw [insert_eq, ← ha, sdiff_union_of_subset hst]
rw [card_le_one.1 H y hy x hx, mem_singleton]
rw [one_lt_card]
simp only [exists_prop, exists_and_left]
simp only [h, card_erase_of_mem has, add_tsub_cancel_right]
rw [strong_induction]
dsimp only [strong_induction_on]
rw [strong_induction]
rw [strong_downward_induction]
dsimp only [strong_downward_induction_on]
rw [strong_downward_induction]
simp only [Pi.nat_apply, Nat.cast_id]
rw [sort_eq] <;> exact s.2
rw [← Multiset.coe_eq_coe]
simp only [coe_to_list, sort_eq]
rw [length_sort]
exact card_pos.2 h
rw [length_sort] at h
exact card_pos.1 (lt_of_le_of_lt bot_le h)
rw [length_sort, h]
exact i.2
simp only [order_emb_of_fin, Set.range_comp coe (s.order_iso_of_fin h), RelEmbedding.coe_trans,
    Set.image_univ, Finset.orderEmbOfFin.equations._eqn_1, RelIso.range_eq,
    OrderEmbedding.subtype_apply, OrderIso.coe_toOrderEmbedding, eq_self_iff_true,
    Subtype.range_coe_subtype, Finset.set_of_mem, Finset.coe_inj]
simp only [order_emb_of_fin_apply, Fin.coe_mk, sorted_zero_eq_min']
simp [order_emb_of_fin_apply, max'_eq_sorted_last, h]
rw [Subsingleton.elim i ⟨0, zero_lt_one⟩, order_emb_of_fin_zero _ zero_lt_one, min'_singleton]
simp only [order_emb_of_card_le, RelEmbedding.coe_trans, Finset.order_emb_of_fin_mem]
rw [image_one, map_one, singleton_one]
rw [coe_preimage, Set.inv_preimage, coe_inv]
rw [pow_zero]
exact one_mem_one
rw [pow_succ]
exact mul_mem_mul ha (pow_mem_pow _)
rw [pow_zero]
exact subset.rfl
rw [pow_succ]
exact mul_subset_mul hst (pow_subset_pow _)
refine' Nat.le_induction _ (fun n h ih => _) _
· exact subset.rfl
· rw [pow_succ]
    exact ih.trans (subset_mul_right _ hs)
rw [← mem_coe, coe_list_prod, List.map_of_fn, Set.mem_prod_list_of_fn]
rfl
rw [← tsub_add_cancel_of_le (Nat.succ_le_of_lt <| Nat.pos_of_ne_zero hn), pow_succ, empty_mul]
rw [coe_pow, coe_univ, Set.univ_pow hn]
simp [subset_iff, mem_mul]
simp [subset_iff, mem_mul]
rw [← mem_coe, ← disjoint_coe, coe_div, Set.one_mem_div_iff]
simp only [is_unit_iff, Group.isUnit, and_true_iff]
simp
simp
simp
simp
simp [subset_iff, mem_div]
simp [subset_iff, mem_div]
rw [preimage_mul_left_one, inv_inv]
rw [preimage_mul_right_one, inv_inv]
simp only [Finset.smul_finset_def, and_assoc, mem_image, exists_prop, Prod.exists, mem_product]
simp only [coe_smul_finset, coe_smul, smul_comm]
simp only [← image_smul, image_image, smul_assoc]
simp only [coe_smul_finset, coe_smul, smul_assoc]
simp only [coe_smul_finset, coe_smul, smul_assoc]
simp only [coe_smul_finset, coe_smul, op_smul_eq_smul]
rw [← smul_mem_smul_finset_iff a, smul_inv_smul]
rw [← smul_mem_smul_finset_iff a, smul_inv_smul]
simp [subset_iff, mem_smul]
simp [subset_iff, mem_smul]
rw [← mem_coe, coe_smul, Set.zero_mem_smul_iff]
rfl
rw [← mem_coe, coe_smul_finset, Set.zero_mem_smul_set_iff ha, mem_coe]
infer_instance
simp only [← image_smul, ← image_neg, Function.comp, image_image, smul_neg]
simp only [← image_smul, ← image_neg, image_image, neg_smul]
simp [inj_on]
simp
simp
simp
simp
simp
simp only [subset_iff, mem_preimage]
simp only [coe_image, coe_preimage, coe_filter, Set.image_preimage_eq_inter_range,
      Set.sep_mem_eq]
rw [sigma_preimage_mk, filter_true_of_mem <| image_subset_iff.1 ht]
rw [image_preimage]
rw [← coe_nonempty, coe_Icc, Set.nonempty_Icc]
rw [← coe_nonempty, coe_Ico, Set.nonempty_Ico]
rw [← coe_nonempty, coe_Ioc, Set.nonempty_Ioc]
rw [← coe_nonempty, coe_Ioo, Set.nonempty_Ioo]
rw [← coe_eq_empty, coe_Icc, Set.Icc_eq_empty_iff]
rw [← coe_eq_empty, coe_Ico, Set.Ico_eq_empty_iff]
rw [← coe_eq_empty, coe_Ioc, Set.Ioc_eq_empty_iff]
rw [← coe_eq_empty, coe_Ioo, Set.Ioo_eq_empty_iff]
simp only [mem_Icc, true_and_iff, le_rfl]
simp only [mem_Ico, true_and_iff, le_refl]
simp only [mem_Icc, and_true_iff, le_rfl]
simp only [mem_Ioc, and_true_iff, le_rfl]
rw [← coe_subset, coe_Ico, coe_Ioo]
exact Set.Ico_subset_Ioo_left h
rw [← coe_subset, coe_Ioc, coe_Ioo]
exact Set.Ioc_subset_Ioo_right h
rw [← coe_subset, coe_Icc, coe_Ico]
exact Set.Icc_subset_Ico_right h
rw [← coe_subset, coe_Ioo, coe_Ico]
exact Set.Ioo_subset_Ico_self
rw [← coe_subset, coe_Ioo, coe_Ioc]
exact Set.Ioo_subset_Ioc_self
rw [← coe_subset, coe_Ico, coe_Icc]
exact Set.Ico_subset_Icc_self
rw [← coe_subset, coe_Ioc, coe_Icc]
exact Set.Ioc_subset_Icc_self
rw [← coe_subset, coe_Icc, coe_Icc, Set.Icc_subset_Icc_iff h₁]
rw [← coe_subset, coe_Icc, coe_Ioo, Set.Icc_subset_Ioo_iff h₁]
rw [← coe_subset, coe_Icc, coe_Ico, Set.Icc_subset_Ico_iff h₁]
rw [← coe_ssubset, coe_Icc, coe_Icc]
exact Set.Icc_ssubset_Icc_left hI ha hb
rw [← coe_ssubset, coe_Icc, coe_Icc]
exact Set.Icc_ssubset_Icc_right hI ha hb
rw [← coe_eq_singleton, coe_Icc, Set.Icc_self]
rw [← coe_eq_singleton, coe_Icc, Set.Icc_eq_singleton_iff]
simp [← coe_inj]
simp [← coe_inj]
simp [← coe_inj]
simp [← coe_inj]
simp [← coe_inj]
rw [← coe_inj, coe_insert, coe_Icc, coe_Ico, Set.insert_eq, Set.union_comm, Set.Ico_union_right h]
rw [← coe_inj, coe_insert, coe_Ioc, coe_Icc, Set.insert_eq, Set.union_comm, Set.Ioc_union_left h]
rw [← coe_inj, coe_insert, coe_Ioo, coe_Ico, Set.insert_eq, Set.union_comm, Set.Ioo_union_left h]
rw [← coe_inj, coe_insert, coe_Ioo, coe_Ioc, Set.insert_eq, Set.union_comm, Set.Ioo_union_right h]
simp [← coe_inj, h]
simp [← coe_inj, h]
simp [← coe_inj, h]
simp [← coe_inj, h]
simp [← coe_inj, h]
rw [card_Ioo_eq_card_Ico_sub_one, card_Ico_eq_card_Icc_sub_one]
rfl
rw [Ici_eq_cons_Ioi, card_cons, add_tsub_cancel_right]
rw [Iic_eq_cons_Iio, card_cons, add_tsub_cancel_right]
rw [← coe_subset, coe_Ico, coe_Ico, Set.Ico_subset_Ico_iff h]
rw [← coe_inj, coe_union, coe_Ico, coe_Ico, coe_Ico, Set.Ico_union_Ico_eq_Ico hab hbc]
rw [← coe_inj, coe_union, coe_Ioc, coe_Ioc, coe_Ioc, Set.Ioc_union_Ioc_eq_Ioc h₁ h₂]
rw [← coe_subset, coe_union, coe_Ico, coe_Ico, coe_Ico]
exact Set.Ico_subset_Ico_union_Ico
rw [← coe_inj, coe_union, coe_Ico, coe_Ico, coe_Ico, Set.Ico_union_Ico' hcb had]
rw [← coe_inj, coe_union, coe_Ico, coe_Ico, coe_Ico, Set.Ico_union_Ico h₁ h₂]
rw [← coe_inj, coe_inter, coe_Ico, coe_Ico, coe_Ico, ← inf_eq_min, ← sup_eq_max,
    Set.Ico_inter_Ico]
cases le_total b c
· rw [Ico_filter_lt_of_right_le h, min_eq_left h]
· rw [Ico_filter_lt_of_le_right h, min_eq_right h]
cases le_total a c
· rw [Ico_filter_le_of_left_le h, max_eq_right h]
· rw [Ico_filter_le_of_le_left h, max_eq_left h]
rw [← coe_inj, coe_map, coe_Icc, coe_Icc]
exact Set.image_const_add_Icc _ _ _
rw [← coe_inj, coe_map, coe_Icc, coe_Icc]
exact Set.image_add_const_Icc _ _ _
rw [← coe_inj, coe_map, coe_Ico, coe_Ico]
exact Set.image_const_add_Ico _ _ _
rw [← coe_inj, coe_map, coe_Ico, coe_Ico]
exact Set.image_add_const_Ico _ _ _
rw [← coe_inj, coe_map, coe_Ioc, coe_Ioc]
exact Set.image_const_add_Ioc _ _ _
rw [← coe_inj, coe_map, coe_Ioc, coe_Ioc]
exact Set.image_add_const_Ioc _ _ _
rw [← coe_inj, coe_map, coe_Ioo, coe_Ioo]
exact Set.image_const_add_Ioo _ _ _
rw [← coe_inj, coe_map, coe_Ioo, coe_Ioo]
exact Set.image_add_const_Ioo _ _ _
rw [← map_add_left_Icc, map_eq_image]
rfl
rw [← map_add_left_Ico, map_eq_image]
rfl
rw [← map_add_left_Ioc, map_eq_image]
rfl
rw [← map_add_left_Ioo, map_eq_image]
rfl
rw [← map_add_right_Icc, map_eq_image]
rfl
rw [← map_add_right_Ico, map_eq_image]
rfl
rw [← map_add_right_Ioc, map_eq_image]
rfl
rw [← map_add_right_Ioo, map_eq_image]
rfl
cases o <;> simp [eq_comm]
cases o <;> rfl
simp
simp
cases h
simp <;> rfl
simp
simp [insert_none]
simp [erase_none]
rw [map_eq_image, embedding.some_apply, image_some_erase_none]
simp only [exists_prop] <;> rfl
simp
simp only [mem_map, Multiset.mem_map, exists_prop, Multiset.mem_to_finset]
subst h
simp
simp only [map_val, Multiset.map_map] <;> rfl
simp [subset_def, map_subset_map h]
simp only [filter_map, Function.comp, Equiv.toEmbedding_apply, Equiv.symm_apply_apply]
simp only [coe_map, coe_union, Set.image_union]
simp only [coe_map, coe_inter, Set.image_inter f.injective]
simp only [coe_map, coe_singleton, Set.image_singleton]
simp only [insert_eq, map_union, map_singleton]
rw [nonempty_iff_ne_empty, nonempty_iff_ne_empty, Ne.def, map_eq_empty]
rw [map_val, attach_val] <;> exact attach_map_val _
simp only [mem_def, image_val, mem_dedup, Multiset.mem_map, exists_prop]
rw [mem_image]
simp only [exists_prop, const_apply, exists_and_right]
rfl
simp
rw [h hx]
simp [Finset.Nonempty]
simp only [mem_image, Multiset.mem_to_finset, exists_prop, Multiset.mem_map]
simp only [mem_image, exists_prop, id, exists_eq_right]
simp only [image_val, dedup_map_dedup_eq, Multiset.map_map]
simp only [subset_def, image_val, subset_dedup', dedup_subset', Multiset.map_subset_map h]
simp only [mem_image, mem_union, exists_prop, or_and_right, exists_or]
simp only [insert_eq, image_singleton, image_union]
rw [← Int.ofNat_lt, Int.toNat_of_nonneg this] <;> exact ⟨Int.emod_lt_of_pos i hn', hi⟩
rw [Int.mod_eq_of_lt (Int.ofNat_zero_le _) (Int.ofNat_lt_ofNat_of_lt hi), ha]
rw [← val_inj, union_val]
exact Multiset.range_add_eq_union a b
rw [image_val, attach_val, Multiset.attach_map_val, dedup_eq_self]
simp only [mem_image, exists_prop, exists_and_right, h.bex, true_and_iff, mem_singleton,
      eq_comm]
simp only [image_insert, bUnion_insert, ih]
simp only [bUnion_insert, image_union, ih]
simp only [mem_bUnion, mem_image, mem_singleton, eq_comm]
simp [Finset.subtype, ha]
simp [ext_iff, Subtype.forall, Subtype.coe_mk] <;> rfl
rw [subtype_map, filter_true_of_mem h]
simp [Finset.fin]
simp [Finset.fin, Finset.map_map]
simp [Finset.map_map]
simp [Finset.map_map]
simp only [countp_eq_length_filter, filter_append, length_append]
rw [join, countp_append, map_cons, sum_cons, countp_join]
simp only [countp_eq_length_filter, length_pos_iff_exists_mem, mem_filter, exists_prop]
rw [← not_iff_not, ← Ne.def, ← pos_iff_ne_zero, countp_pos]
simp
rw [countp_eq_length_filter, filter_length_eq_length]
rw [length_eq_countp_add_countp p l, ← countp_pos, countp_eq_length_filter, lt_add_iff_pos_right]
simp only [countp_eq_length_filter, filter_filter]
simp
simp
rw [map_cons, countp_cons, countp_cons, countp_map]
simp [-add_comm]
simp only [count, countp_pos, exists_prop, exists_eq_right']
rw [count, countp_eq_length_filter, filter_eq_self.2, length_repeat] <;>
    exact fun b m => (eq_of_mem_repeat m).symm
simp only [count, countp_eq_length_filter]
rw [List.bind, count_join, map_map]
simp only [count, countp_map, (· ∘ ·), hf.eq_iff]
rw [count, count, countp_map]
exact countp_mono_left fun y hyl => congr_arg f
simp
rw [erase_cons]
rw [count_erase, if_pos rfl]
rw [count_erase, if_neg ab, tsub_zero]
rw [map_id'']
exact this xs fun _ => id
rw [next, next_or, if_pos hx]
rw [next, next_or_concat]
· rfl
· simp [hy, hx]
cases l <;> simp [prev, hx]
rw [prev, dif_pos hx]
cases l
· simp [prev, hy, hz]
· rw [prev, dif_neg hy, if_pos hz]
exact absurd hn'' this.ge.not_lt
          rw [nodup_iff_nth_le_inj]
apply List.ext_le
· simp
· intros
    rw [nth_le_pmap, nth_le_rotate, next_nth_le _ h]
apply List.ext_le
· simp
· intro n hn hn'
    rw [nth_le_rotate, nth_le_pmap, prev_nth_le _ h]
simp
rw [← next_reverse_eq_prev _ hn, ← next_reverse_eq_prev _ (h.nodup_iff.mp hn)]
exact is_rotated_next_eq h.reverse (nodup_reverse.mpr hn) _
rw [rotate_cons_succ, rotate_zero]
simp
simp [length_subsingleton_iff]
simp
simp [Nontrivial]
rw [length_subsingleton_iff]
induction s using Quotient.inductionOn'
simp only [mk'_eq_coe, nodup_coe_iff] at h
simp [h, Nat.succ_le_iff]
simp
simp
simp
rw [lists, Quotient.lift_on'_mk']
simp
rw [nil, lists_coe, cyclic_permutations_nil]
simp [Nontrivial]
simp [Nontrivial]
simp [h, Nontrivial]
simp
simp
simp
simp
simp
simp [← prev_reverse_eq_next]
induction s using Quot.induction_on
apply next_mem
rw [← next_reverse_eq_prev, ← mem_reverse_iff]
apply next_mem
trivial
rw [chain_coe_cons, nil_append, chain_singleton]
apply l.reverse_rec_on
exact fun hm => hm.irrefl.elim
intro m a H _
rw [← coe_cons_eq_coe_append, chain_coe_cons, last_append_singleton]
rw [range_succ, ← coe_cons_eq_coe_append, chain_coe_cons, ← range_succ, chain_range_succ]
simp
simp [hb]
rw [chain_iff_pairwise] at hs
exact antisymm (hs a ha b hb) (hs b hb a ha)
cases l <;> rfl
cases l <;> cases l' <;> simp
rw [zip_nil_right] <;> rfl
simp only [zip_cons_cons, map_cons, zip_swap l₁ l₂, Prod.swap_prod_mk] <;> constructor <;> rfl
simp only [length, min_zero, zip_with_nil_right]
simp [length, zip_cons_cons, length_zip_with l₁ l₂, min_add_add_right]
simp
simp only [length_cons, add_left_inj] at h
simp [all₂_zip_with h]
rw [length_zip_with, lt_min_iff] at h
exact h.left
rw [length_zip_with, lt_min_iff] at h
exact h.right
simp only [eq_nil_of_length_eq_zero h.symm] <;> rfl
simp only [eq_nil_of_length_eq_zero h] <;> rfl
simp only [cons_append, zip_cons_cons, zip_append (succ.inj h)] <;> constructor <;> rfl
simp only [map, zip_nil_right]
simp only [map, zip_cons_cons, zip_map l₁ l₂, Prod.map] <;> constructor <;> rfl
rw [← zip_map, map_id]
rw [← zip_map, map_id]
induction as generalizing bs
· simp
· cases bs <;> simp [*]
simp only [map, zip_cons_cons, zip_map' l] <;> constructor <;> rfl
constructor <;> simp only [mem_cons_iff, or_true_iff, mem_zip h]
simp at h
simp! [*]
simp at h
contradiction
rw [zip_nil_right]
rfl
simp at h
contradiction
simp at h
simp! [*]
rw [unzip] <;> cases unzip l <;> rfl
simp only [unzip_cons, map_cons, unzip_eq_map l]
simp only [unzip_eq_map]
simp only [unzip_eq_map]
simp only [unzip_eq_map, map_map] <;> constructor <;> rfl
simp only [unzip_cons, zip_cons_cons, zip_unzip l] <;> constructor <;> rfl
rw [eq_nil_of_length_eq_zero (Nat.eq_zero_of_le_zero h)] <;> rfl
simp only [zip_cons_cons, unzip_cons, unzip_zip_left (le_of_succ_le_succ h)] <;> constructor <;>
      rfl
rw [← zip_swap, unzip_swap] <;> exact unzip_zip_left h
rw [← @Prod.mk.eta _ _ (unzip (zip l₁ l₂)), unzip_zip_left (le_of_eq h),
    unzip_zip_right (ge_of_eq h)]
rw [← hl, ← hr, ← zip_unzip lp, ← unzip_left, ← unzip_right, zip_unzip, zip_unzip]
rw [← zip_map']
congr
exact map_id _
rw [← zip_map']
congr
exact map_id _
rw [zip_with_comm]
simp only [comm]
simp only [revzip, length_zip, length_reverse, min_self]
rw [← unzip_left, unzip_revzip]
rw [← unzip_right, unzip_revzip]
rw [← zip_unzip.{u, u} (revzip l).reverse, unzip_eq_map] <;> simp <;> simp [revzip]
simp [revzip]
induction l₁ generalizing l₂ i
· simp [zip_with, (· <*> ·)]
· cases l₂ <;> simp only [zip_with, Seq.seq, Functor.map, nth, Option.map_none']
    · cases (l₁_hd :: l₁_tl).nth i <;> rfl
    · cases i <;> simp only [Option.map_some', nth, Option.some_bind', *]
induction l₁ generalizing l₂ i
· simp [zip_with]
· cases l₂ <;> simp only [zip_with, nth, exists_false, and_false_iff, false_and_iff]
    cases i <;> simp [*]
rw [← Option.some_inj, ← nth_le_nth, nth_zip_with_eq_some]
refine'
    ⟨l.nth_le i (lt_length_left_of_zip_with h), l'.nth_le i (lt_length_right_of_zip_with h),
      nth_le_nth _, _⟩
simp only [← nth_le_nth, eq_self_iff_true, and_self_iff]
simp [h]
simp [Nat.zero_le]
simp [Nat.zero_le]
simp only [drop, length, zip_with_cons_cons, prod_cons]
rw [mul_assoc x, mul_comm xs.prod, mul_assoc y, mul_comm ys.prod,
      prod_mul_prod_eq_prod_zip_with_mul_prod_drop xs ys, mul_assoc, mul_assoc, mul_assoc,
      mul_assoc]
simp [h]
rw [Nat.succ_add] <;> exact Prod.Lex.right _ (lt_succ_self _)
induction l generalizing a <;> simp only [chain.nil, chain_cons] <;> skip <;> infer_instance
cases l <;> dsimp only [chain'] <;> infer_instance
rw [join, join, append_nil]
simp only [join, append_eq_nil, join_eq_nil, forall_mem_cons]
simp
simp [@join_filter_empty_eq_ff L]
simp [@join_filter_empty_eq_ff L]
simp [join_filter_empty_eq_ff, ← empty_iff_eq_nil]
induction l
simp
simp [l_ih]
rw [List.bind, length_join, map_map]
simp only [mem_map, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂]
induction L generalizing i
· simp
cases i
· simp
simp [take_append, L_ih]
induction L generalizing i
· simp
cases i
· simp
simp [drop_append, L_ih]
simp at hi
exact Nat.lt_of_succ_lt_succ hi
simp [map_take, take_take]
simp [hi, sum_take_succ, hj]
simp
rw [nth_le_take L.join (sum_take_map_length_lt2 L hi hj) (sum_take_map_length_lt1 L hi hj),
    nth_le_drop, nth_le_of_eq (drop_take_succ_join_eq_nth_le L hi)]
simp [H]
rw [length_eq]
induction L using List.reverseRecOn
· cases h rfl
· simp
induction L
· rw [map_nil, join, append_nil, map_nil, join, nil_append]
· rw [map_cons, join, map_cons, join, append_assoc, L_ih, append_assoc, append_assoc]
induction L
· rfl
· rw [join, reverse_append, L_ih, map_cons, reverse_cons', join_concat]
simp [h]
refine' bidirectional_rec_on l (fun _ => palindrome.nil) (fun a _ => palindrome.singleton a) _
intro x l y hp hr
rw [reverse_cons, reverse_append] at hr
rw [head_eq_of_cons_eq hr]
have : palindrome l := hp (append_inj_left' (tail_eq_of_cons_eq hr) rfl)
exact palindrome.cons_concat x this
apply of_reverse_eq
rw [reverse_append, reverse_reverse]
rw [← map_reverse, p.reverse_eq]
induction ys generalizing f <;> simp [*]
induction ys generalizing f
· simp
· simp [ys_ih fun xs => f (ys_hd :: xs)]
induction ys generalizing f f' <;> simp [*]
apply ys_ih
simp [H]
rw [map_permutations_aux2' id, map_id, map_id]
rfl
simp
rw [← permutations_aux2_append, map_permutations_aux2, permutations_aux2_comp_append]
simp
simp
simp
induction ys generalizing f <;> simp [*]
have :
    (∃ a : List α,
        a ∈ L ∧ ∃ l₁ l₂ : List α, ¬l₂ = nil ∧ a = l₁ ++ l₂ ∧ l' = l₁ ++ t :: (l₂ ++ ts)) ↔
      ∃ l₁ l₂ : List α, ¬l₂ = nil ∧ l₁ ++ l₂ ∈ L ∧ l' = l₁ ++ t :: (l₂ ++ ts) :=
    ⟨fun ⟨a, aL, l₁, l₂, l0, e, h⟩ => ⟨l₁, l₂, l0, e ▸ aL, h⟩, fun ⟨l₁, l₂, l0, aL, h⟩ =>
      ⟨_, aL, l₁, l₂, l0, rfl, h⟩⟩
rw [foldr_permutations_aux2] <;>
    simp [mem_permutations_aux2', this, or_comm, or_left_comm, or_assoc, and_comm, and_left_comm,
      and_assoc]
simp [foldr_permutations_aux2, (· ∘ ·), length_permutations_aux2]
rw [permutations_aux, permutations_aux.rec]
rw [permutations_aux, permutations_aux.rec] <;> rfl
rw [permutations, permutations_aux_nil]
simp
rw [permutations, permutations, map, map_permutations_aux, map]
simp [permutations, permutations_aux_append]
simp only [List.prod, foldl_cons, one_mul, mul_one]
simp [List.prod]
rw [concat_eq_append, prod_append, prod_singleton]
rw [prod_cons, foldr_cons, ihl]
rw [← prod_repeat, ← list.eq_repeat.mpr ⟨rfl, h⟩]
simp only [map_cons, prod_cons, h₂ hl]
simp only [Prod, foldl_map, ← map_one f]
exact l.foldl_hom _ _ _ 1 (map_mul f)
rw [← prod_hom, map_map]
simp
simp only [List.prod_cons]
exact IsUnit.mul (u h (mem_cons_self h t)) (prod_is_unit fun m mt => u m (mem_cons_of_mem h mt))
simp [Nat.zero_le]
simp
dsimp
rw [prod_cons, prod_cons, mul_assoc, prod_take_mul_prod_drop]
cases p
simp
dsimp
rw [prod_cons, prod_cons, prod_take_succ, mul_assoc]
simp [update_nth]
simp [update_nth, prod_update_nth xs i a, mul_assoc]
simp [update_nth, (Nat.zero_le _).not_lt, Nat.zero_le]
cases l <;> simp
induction h
· rfl
case cons l₁ l₂ a ih ih' => 
    simp only [prod_cons, forall_mem_cons] at h₁⊢
    exact (ih' h₁.2).trans (le_mul_of_one_le_left' h₁.1)
case cons2 l₁ l₂ a ih ih' =>
    simp only [prod_cons, forall_mem_cons] at h₁⊢
    exact mul_le_mul_left' (ih' h₁.2) _
simp
simp [prod_inv_reverse xs]
simp [prod_inv_reverse]
simp
simp
simp [mul_comm, prod_inv xs]
simp only [forall_eq_or_imp, List.mem_cons_iff _ a] at hl₁
rw [List.prod_cons]
apply one_lt_mul_of_lt_of_le' hl₁.1
apply le_of_lt ((b :: l).one_lt_prod_of_one_lt hl₁.2 (l.cons_ne_nil b))
cases L
· simp
    rfl
· simp
rw [← head_add_tail_sum L, add_comm, add_tsub_cancel_right]
rw [div_eq_mul_inv, alternating_prod_cons_cons']
rw [alternating_prod_nil, inv_one, mul_one, alternating_prod_singleton]
rw [alternating_prod_cons_cons', alternating_prod_cons' b l, mul_inv, inv_inv, mul_assoc]
rw [div_eq_mul_inv, alternating_prod_cons']
rw [eq_repeat.2 ⟨rfl, h⟩, prod_repeat, one_pow]
decide
let ⟨s, t, h⟩ := mem_split ha
rw [h, prod_append, prod_cons, mul_left_comm]
exact dvd_mul_right _ _
simp
simp only [alternating_prod_nil, one_zpow, reverse_nil]
rw [List.prod_cons, List.map_cons, List.reverse_cons', List.prod_concat, op_mul, op_list_prod]
rw [← op_inj, op_unop, MulOpposite.op_list_prod, map_reverse, map_map, reverse_reverse,
    op_comp_unop, map_id]
rw [map_list_prod f l, MulOpposite.unop_list_prod, List.map_map]
rw [← List.append_assoc] <;> apply infix_append
rw [h, append_nil]
simp
simp only [append_assoc]
rw [← h]
exact (sublist_append_right _ _).trans (sublist_append_left _ _)
rw [← reverse_reverse l₁, ← reverse_append, e, reverse_reverse]
rw [← reverse_append, e]
rw [← reverse_suffix] <;> simp only [reverse_reverse]
rw [← reverse_reverse l₁, append_assoc, ← reverse_append, ← reverse_append, e,
        reverse_reverse]
rw [append_assoc, ← reverse_append, ← reverse_append, e]
rw [← e, append_assoc] <;> exact ⟨_, rfl⟩
rw [append_assoc] <;> exact e
injection e with _ e'
subst b
          rcases
            prefix_of_prefix_length_le ⟨ _ , rfl ⟩ ⟨ _ , e' ⟩ le_of_succ_le_succ ll
simp [ll]
rw [append_assoc, append_right_inj]
rw [init, List.append_nil]
rw [← drop_one] <;> apply drop_suffix
rw [← h, prefix_cons_inj]
injection te
decide
simp at te <;> exact te
let ⟨s, ht⟩ := (mem_inits _ _).1 hr
rw [← hs, ← ht] <;> exact ⟨s, rfl⟩
rw [ba] <;> exact ⟨_, (mem_inits _ _).2 ⟨_, st⟩, rfl⟩
rw [h] <;> exact suffix_refl []
simp
simp
simp
simp
simp [inits_append s t]
simp
simp
simp [tails_append s t]
simp
simp [inits_eq_tails l, map_eq_map_iff]
simp
simp [tails_eq_inits l, append_left_inj]
rw [tails_eq_inits l]
simp [reverse_involutive.comp_self]
rw [inits_eq_tails l]
simp [reverse_involutive.comp_self]
rw [inits_eq_tails l]
simp [reverse_involutive.comp_self]
rw [tails_eq_inits l]
simp [reverse_involutive.comp_self]
simp [inits_eq_tails]
simp only [insert.def, if_pos h]
simp only [insert.def, if_neg h] <;> constructor <;> rfl
rw [max_eq_left]
rfl
simp [Nat.le_add_right]
simp only [Set, Nat.zero_max, length, @length_set m]
simp only [Set, Nat.max_succ_succ, length, @length_set m]
cases k <;> rfl
cases h1
apply get_eq_default_of_le k
rw [← Nat.succ_le_succ_iff]
apply h1
cases as <;> rfl
cases as <;> simp [get_set]
cases h
cases h1
apply Or.inr
unfold get
apply mem_get_of_le
apply Nat.lt_of_succ_lt_succ h1
unfold get
apply Or.inr (mem_get_of_ne_zero _)
apply h1
cases m
contradiction
cases as <;> simp only [Set, get, get_nil]
rw [get_set_eq_of_ne k m, get_nil]
intro hc
apply h1
simp [hc]
cases h
rw [← Nat.succ_le_iff, ← Nat.lt_succ_iff]
apply h1
intro h1
intro h1 h2 n
intro h1
rw [h1]
apply equiv_refl
cases h1
cases h1
unfold neg
rw [@get_map' α α ⟨0⟩]
apply neg_zero
simp only [neg, length_map]
simp only [nil_pointwise bs, pointwise, eq_self_iff_true, and_self_iff, map]
simp only [pointwise_nil as, pointwise, eq_self_iff_true, and_self_iff, List.map]
simp only [h1, get_nil, pointwise, get]
simp only [get_pointwise, get_nil, pointwise, get, Nat.zero_eq, map]
simp only [get_pointwise, get_nil, pointwise, get, Nat.zero_eq, map]
simp only [pointwise, get]
simp only [pointwise, get, get_pointwise k]
simp only [pointwise, length, length_map, max_eq_right (Nat.zero_le (length bs + 1))]
simp only [pointwise, length, length_map, max_eq_left (Nat.zero_le (length as + 1))]
simp only [pointwise, length, Nat.max_succ_succ, @length_pointwise as bs]
apply get_pointwise
apply zero_add
rw [add, @nil_pointwise α α α ⟨0⟩ ⟨0⟩]
apply Eq.trans _ (map_id as)
congr
rw [add, @pointwise_nil α α α ⟨0⟩ ⟨0⟩]
apply Eq.trans _ (map_id as)
congr
apply @eq_of_equiv _ (⟨0⟩ : Inhabited α)
· rw [length_map, length_add, max_eq_left, length_map]
    apply le_of_eq
    rw [length_map, length_map]
intro m
rw [get_add]
apply get_pointwise
apply sub_zero
rw [sub, nil_pointwise]
congr
rw [sub, pointwise_nil]
apply Eq.trans _ (map_id as)
congr
rw [antidiagonal, length_map, length_range]
simp only [antidiagonal, range_succ, add_tsub_cancel_left, map_append, append_assoc, tsub_self,
    singleton_append, map_map, map]
congr 1
apply map_congr
simp (config := { contextual := true }) [le_of_lt, Nat.succ_eq_add_one, Nat.sub_add_comm]
rw [antidiagonal, map_map, Prod.swap, ← List.map_reverse, range_eq_range', reverse_range', ←
    range_eq_range', map_map]
apply map_congr
simp (config := { contextual := true }) [Nat.sub_sub_self, lt_succ_iff]
simp only [of_fn_nth_val, dif_neg (not_lt.2 (Nat.le_add_left n i))] <;> rfl
rw [← nth_le_nth] <;> simp only [List.nth_of_fn, of_fn_nth_val, Fin.eta, dif_pos i.is_lt]
simp
simp
cases n <;> simp only [of_fn_zero, of_fn_succ, eq_self_iff_true, Nat.succ_ne_zero]
simp [last_eq_nth_le]
rw [of_fn_succ]
congr
simp only [Fin.coe_succ]
exact of_fn_nth_le l
simp only [mem_of_fn, Set.forall_range_iff]
simp
simp [ihn]
injection of_fn_inj'.mp h
simp [keys, nodupkeys]
cases nd.eq_of_fst_eq h h' rfl <;> rfl
simp [nodupkeys_iff_pairwise]
simp [List.nodup_range]
simp
simp [← lookup_is_some, Option.is_none_iff_eq_none]
rw [← mem_lookup_iff, ← mem_lookup_iff, h] <;> assumption
simp
simp
simp
simp
decide
rw [lookup_all_eq_lookup a h] <;> apply Option.to_list_nodup
simp [lookup_all_eq_lookup, nd₁, nd₂, perm_lookup a nd₁ nd₂ p]
simp [nodupkeys, keys_kreplace]
simp [kerase, h]
simp [kerase, h]
simp
cases hd <;> rfl
simp
rw [h₂] <;> rfl
simp [e, h₃]
simp [q, p]
rw [keys, kerase, ← erasep_map Sigma.fst l, erase_eq_erasep]
induction l
case nil => simp
case cons hd tl ih => 
    simp at nd
cases h
simp [h₂]
simp [not_or] at h <;> simp [h.1, kerase_append_right h.2]
simp [h]
simp [kerase_append_left h',
              kerase_append_right (mt (mem_keys_kerase_of_ne h).mp a₁_nin_l₁)]
simp [kerase_append_right h', kerase_append_right a₁_nin_l₁,
              @kerase_cons_ne _ _ _ a₂ ⟨a₁, b₁⟩ _ (Ne.symm h)]
simp [ha₂, mt mem_keys_of_mem_keys_kerase ha₂]
simp [ha₁, mt mem_keys_of_mem_keys_kerase ha₁]
simp only [kinsert, lookup_cons_eq]
simp [h]
rw [← hl]
apply nodup_nil
rw [kunion, kerase_nil, kunion_nil]
induction l₁ generalizing l₂
case nil => simp only [nil_kunion, nd₂]
case cons s l₁ ih => 
    simp at nd₁
    simp [not_or, nd₁.1, nd₂, ih nd₁.2 (nd₂.kerase s.1)]
induction p generalizing l
case nil => rfl
case cons hd tl₁ tl₂ p ih => simp [ih (kerase hd.1 l), perm.cons]
case swap s₁ s₂ l => simp [kerase_comm, perm.swap]
case trans l₁ l₂ l₃ p₁₂ p₂₃ ih₁₂ ih₂₃ => exact perm.trans (ih₁₂ l) (ih₂₃ l)
simp [((p.kerase nd₁).kunion_left l <| nd₁.kerase s.1).cons s]
induction l₁ generalizing l₂
case nil => simp
case cons _ _ ih => simp [not_or] at h; simp [h.1, ih h.2]
rw [← length_eq_zero, length_range']
simp only [mem_range', or_and_left, or_iff_right_of_imp this, l, add_right_comm] <;> rfl
rw [add_right_comm, range'_append]
rw [← tsub_add_cancel_of_le h, ← range'_append] <;> apply sublist_append_left
rw [add_right_comm] <;> rfl
rw [add_comm n 1] <;> exact (range'_append s n 1).symm
rw [show n + (s + 1) = n + 1 + s from add_right_comm n s 1] <;>
      exact range_core_range' s (n + 1)
rw [zero_add]
rw [range_eq_range', range_eq_range', range', add_comm, ← map_add_range'] <;> congr <;>
    exact funext one_add
rw [range_eq_range', map_add_range'] <;> rfl
simp only [range_eq_range', length_range']
rw [← length_eq_zero, length_range]
simp only [range_eq_range', pairwise_lt_range']
simp only [range_eq_range', nodup_range']
simp only [range_eq_range', range'_sublist_right]
simp only [range_eq_range', range'_subset_right]
simp only [range_eq_range', mem_range', Nat.zero_le, true_and_iff, zero_add]
simp only [succ_pos', lt_add_iff_pos_right, mem_range]
simp only [range_eq_range', nth_range' _ h, zero_add]
simp only [range_eq_range', range'_concat, zero_add]
rw [range_succ_eq_map, chain_cons, and_congr_right_iff, ← chain'_range_succ, range_succ_eq_map]
exact fun _ => Iff.rfl
rw [add_zero, range_zero, map_nil, append_nil]
rw [Nat.add_succ, range_succ, range_add b, range_succ, map_append, map_singleton, append_assoc]
simp only [iota, range'_concat, iota_eq_reverse_range' n, reverse_append, add_comm] <;> rfl
simp only [iota_eq_reverse_range', length_reverse, length_range']
simp only [iota_eq_reverse_range', pairwise_reverse, pairwise_lt_range']
simp only [iota_eq_reverse_range', mem_reverse, mem_range', add_comm, lt_succ_iff]
cases a
rfl
rw [fin_range, length_pmap, length_range]
rw [← length_eq_zero, length_fin_range]
rw [range_succ, map_append, map_singleton, prod_append, prod_cons, prod_nil, mul_one]
rw [one_mul, mul_one]
rw [List.prod_range_succ, hd, mul_assoc, ← List.prod_range_succ]
simp only [enum, enum_from_map_fst, range_eq_range']
simp only [enum_eq_zip_range, unzip_zip, length_range]
simp only [enum_from_eq_zip_range', unzip_zip, length_range']
simp only [fin_range, nth_le_range, nth_le_pmap]
simp [duplicate_cons_iff, hne.symm]
simp [nodup_iff_forall_not_duplicate]
simp [duplicate_iff_sublist, le_count_iff_repeat_sublist]
apply map_injective_iff.mpr Fin.coe_injective
rw [map_cons, map_coe_fin_range, range_succ_eq_map, Fin.coe_zero, ← map_coe_fin_range, map_map,
    map_map, Function.comp, Function.comp]
congr 2
rw [length_map, length_fin_range]
rw [← nth_le_map_rev]
congr
· rw [nth_le_fin_range]
      rfl
· rw [length_fin_range]
      exact h
simp
simp at hi1
simp [nth_le_of_fn f ⟨i, hi1⟩, -Subtype.val_eq_coe]
rw [← of_fn_id, map_of_fn, Function.right_id]
rw [of_fn_eq_pmap]
exact (nodup_range n).pmap fun _ _ _ _ H => Fin.veq_of_eq <| hf H
rw [of_fn_eq_map, of_fn_eq_map, ← map_map]
exact σ.map_fin_range_perm.map f
congr
rw [ext_iff] <;> infer_instance
rw [mem_keys, keys_replace, ← mem_keys]
rw [mem_keys, keys_erase, s.keys_nodup.mem_erase_iff, ← mem_keys]
rw [insert_entries, kerase_of_not_mem_keys h]
simp [insert, keys, keys_kerase]
simp only [insert_entries] <;> exact p.kinsert s₁.nodupkeys
simp only [lookup, insert, lookup_kinsert]
rw [List.toAlist, lookup, lookup_dedupkeys]
simp only [Alist.insert_entries, List.kerase_cons_eq, and_self_iff, Alist.singleton_entries,
      heq_iff_eq, eq_self_iff_true]
rw [kextract_eq_lookup_kerase] <;> exact s.nodupkeys.kerase _
simp [extract] <;> constructor <;> rfl
simp
simp [p₁₂.kunion s₃.nodupkeys p₃₄]
simp [Decidable.not_or_iff_and_not, or_assoc', and_or_left, and_assoc']
subst a
exact binl
intro e <;> rw [e] at h <;> cases h
rw [mem_map, hf.exists_mem_and_apply_eq_iff]
cases l <;> simp only [forall_prop_of_true, map, forall_prop_of_false, not_false_iff]
simp only [join, mem_append, @mem_join L, mem_cons_iff, or_and_right, exists_or, exists_eq_left]
simp only [cons_bind, map_append, bind_map l]
simp only [cons_bind, map_cons, map_bind l]
infer_instance
rfl
simp only [mem_singleton, forall_eq]
simp only [mem_append, or_imp, forall_and]
simp only [subset_def, mem_cons_iff, or_imp, forall_and, forall_eq]
simp only [mem_map, not_and, exists_imp, and_imp] <;> exact fun a h e => ⟨a, H h, e⟩
induction s <;> intros <;> contradiction
induction s <;> intros <;> contradiction
cases p <;> simp only [nil_append, cons_append, eq_self_iff_true, true_and_iff, false_and_iff]
rw [eq_comm, append_eq_nil]
cases a <;>
    simp only [and_assoc', @eq_comm _ c, nil_append, cons_append, eq_self_iff_true, true_and_iff,
      false_and_iff, exists_false, false_or_iff, or_false_iff, exists_and_left, exists_eq_left']
rw [eq_comm, append_eq_cons_iff]
let ⟨e1, e2⟩ := @append_inj s₁ s₂ t₁ t₂ hap (succ.inj hl)
rw [ab, e1, e2] <;> exact ⟨rfl, rfl⟩
have := h
rw [← take_append_drop (length s₁) l] at this⊢
rw [map_append] at this
refine' ⟨_, _, rfl, append_inj this _⟩
rw [length_map, length_take, min_eq_left]
rw [← length_map f l, h, length_append]
apply Nat.le_add_right
simp
simp [mem_repeat]
simp
simp
simp [hk, repeat_subset_singleton]
simp [mem_singleton.mp h.1]
cases n <;> rfl
simp
simp only [n.succ_ne_zero, false_or_iff]
simp! [pure, List.ret]
induction l <;> simp [*]
induction l <;> simp only [*, concat] <;> constructor <;> rfl
intro h
rw [concat_eq_append, concat_eq_append] at h
exact append_right_cancel h
intro h
rw [concat_eq_append, concat_eq_append] at h
exact head_eq_of_cons_eq (append_left_cancel h)
simp
simp
simp only [concat_eq_append, length_append, length]
simp
simp only [reverse_cons, concat_eq_append]
rw [concat_eq_append, reverse_append, reverse_singleton, singleton_append]
simp only [concat_eq_append, reverse_cons, reverse_reverse]
simp only [reverse_core_eq, map_append, map_reverse]
simp only [length_reverse, length_repeat]
simp
simp
rw [init]
simp only [add_left_inj, length, succ_add_sub_one]
exact length_init (b :: l)
induction l <;> intros
contradiction
rfl
simp only [concat_eq_append, last_append_singleton]
rw [init, cons_append, last_cons (cons_ne_nil _ _)]
congr
exact init_append_last (cons_ne_nil b l)
subst l₁
rw [last_cons_cons]
exact last_mem (cons_ne_nil b l)
rw [length_repeat]
simp
simp
simp [@last'_is_none (b :: l)]
simp
simp
simp [@last'_is_some (b :: l)]
unfold last
unfold last'
contradiction
rw [last'] at hc
rw [init, cons_append, init_append_last' _ hc]
simp [ilast, Inhabited.default]
simp [ilast, ilast_eq_last' (c :: l)]
rw [cons_append, cons_append, last', ← cons_append, last'_append_cons]
contradiction
cases l₂
· contradiction
· rw [List.last'_append_cons]
    exact h
cases l <;> rfl
simp only [head', Option.mem_def] at h
exact h ▸ rfl
induction s
contradiction
rfl
cases s
contradiction
exact h
contradiction
induction l
contradiction
rw [tail, cons_append, tail]
contradiction
simp at h
simp [h]
contradiction
cases l <;> rfl
cases l
· contradiction
· simp
cases l <;> simp
rw [← reverse_reverse l]
induction reverse l
· exact H0
· rw [reverse_cons]
    exact H1 _ _ ih
change _ < length l + 2
simp
rw [h] <;> apply lt_succ_self
rw [length, length] at h <;> injection h with h <;> rw [s.eq_of_length h]
rw [← h] <;> exact ⟨sublist.cons_cons _, sublist_of_cons_sublist_cons⟩
rw [nth_len_le hn] at e <;> contradiction
rw [nth_le_nth h] at e <;> injection e with e <;> apply nth_le_mem
intros
constructor
· intro h
rw [nth_le_nth, e]
cases l <;> rfl
rw [← nth_le_nth, nth_map, nth_le_nth] <;> rfl
congr
exact h
have hn0 : n = 0 := Nat.eq_zero_of_le_zero (le_of_lt_succ hn)
subst hn0 <;> rfl
cases L
cases h
simp
simp only [nth_le, cons_append] <;> exact nth_le_append _ _
dsimp
conv => 
      rhs
      congr
      skip
      rw [Nat.add_sub_add_right]
rw [nth_le_append_right (nat.lt_succ_iff.mp h₁)]
rw [length_append] <;> exact Nat.le_add_right _ _
rw [last_singleton, nth_le_singleton]
rw [last_cons, last_eq_nth_le (b :: l)]
rfl
exact cons_ne_nil b l
rw [cons_append, length_cons, nth, nth_concat_length]
simp [h]
rw [last_eq_nth_le]
congr
simp [h]
have h0 := h 0 <;> contradiction
have h0 := h 0 <;> contradiction
have h0 : some a = some a' := h 0 <;> injection h0 with aa <;>
          simp only [aa, ext fun n => h (n + 1)] <;>
        constructor <;>
      rfl
rw [nth_le_nth, index_of_nth_le (index_of_lt_length.2 h)]
rw [show i + length (a :: l) = i + 1 + length l from add_right_comm i (length l) 1] <;>
      exact fun h1 h2 => nth_le_reverse_aux1 l (a :: r) (i + 1) h1 (succ_lt_succ h2)
simp only [h]
subst h
have aux := nth_le_reverse_aux1 l (a :: r) 0
rw [zero_add] at aux
exact aux _ (zero_lt_succ _)
rw [add_comm] <;> rfl
rw [← tsub_add_eq_tsub_tsub]
rw [modify_nth_tail_modify_nth_tail_le n n l (le_refl n), tsub_self] <;> rfl
cases l <;> rfl
cases l <;> rfl
cases l <;> rfl
cases nth l n <;> rfl
cases l <;> cases n <;> rfl
cases n <;> rfl
cases nth l m <;> rfl
cases l <;> rfl
simp only [update_nth_eq_modify_nth, modify_nth_length]
simp only [nth_modify_nth, if_pos]
simp only [nth_modify_nth, if_neg h, id_map']
simp only [update_nth_eq_modify_nth, nth_modify_nth_eq]
rw [nth_update_nth_eq, nth_le_nth h] <;> rfl
simp only [update_nth_eq_modify_nth, nth_modify_nth_ne _ _ h]
simp
simp [List.updateNth]
simp [List.updateNth]
simp only [update_nth, true_and_iff, eq_self_iff_true]
exact update_nth_comm t fun h' => h <| nat.succ_inj'.mpr h'
rw [← Option.some_inj, ← nth_le_nth, nth_update_nth_eq, nth_le_nth] <;> simp_all
rw [← Option.some_inj, ← List.nth_le_nth, List.nth_update_nth_ne _ _ h, List.nth_le_nth]
rw [remove_nth_eq_nth_tail, insert_nth, modify_nth_tail_modify_nth_tail_same] <;>
    exact modify_nth_tail_id _ _
simp [remove_nth, insert_nth]
simp [insert_nth]
simp
simp [insert_nth] <;>
      exact insert_nth_comm i j l (Nat.le_of_succ_le_succ h₀) (Nat.le_of_succ_le_succ h₁)
dsimp [List.insertNth]
erw [mem_insert_nth (Nat.le_of_succ_le_succ h), ← or_assoc, or_comm' (a = a'), or_assoc]
induction l <;> simp [*]
let ⟨h₁, h₂⟩ := forall_mem_cons.1 h
rw [map, map, h₁, map_congr h₂]
simp [show f = id from funext h]
rw [← length_map f l, h] <;> rfl
unfold List.bind <;> induction l <;>
        simp only [map, join, List.ret, cons_append, nil_append, *] <;>
      constructor <;>
    rfl
cases l <;> rfl
induction as
· rfl
· simp! [*, apply_ite (map f)]
rw [map_const] at h <;> exact eq_of_mem_repeat h
cases l <;> rfl
cases l <;> rfl
simp! [map₂_flip]
rfl
change a :: take (length l) l = a :: l
rw [take_length]
change a :: take n l = a :: l
rw [take_all_of_le (le_of_succ_le_succ h)]
rw [← h] <;> apply take_left
rw [min_zero, take_zero, take_nil]
rw [zero_min, take_zero, take_zero]
simp only [take_nil]
simp only [take, min_succ_succ, take_take n m l] <;> constructor <;> rfl
simp
simp
simp [min_succ_succ, take_repeat]
simp
simp
dsimp
rw [map_take]
induction l₁ generalizing n
· simp
cases n
· simp; simp [*]
simp [take_append_eq_append_take, tsub_eq_zero_iff_le.mpr h]
simp [take_append_eq_append_take, take_all_of_le le_self_add]
rw [length_take]
exact lt_min hj hi
rw [nth_le_of_eq (take_append_drop j L).symm hi]
exact nth_le_append _ _
simp [le_refl]
simp at hi
rw [nth_le_take L _ hi.1]
cases l <;> cases k <;> simp [Nat.succ_ne_zero]
simp
simp
simp
simp [@eq_comm ℕ 0]
simp [Nat.min_succ_succ, take_eq_take]
simp [init_eq_take, min_eq_left_of_lt h, take_take, pred_le]
simp [init]
simp only [nil_append]
simp [append_ne_nil_of_ne_nil_right l' l h, init_append_of_ne_nil l' h]
rw [← h] <;> apply drop_left
simp
induction l₁ generalizing n
· simp
cases n
· simp; simp [*]
simp [drop_append_eq_append_drop, tsub_eq_zero_iff_le.mpr h]
simp [drop_append_eq_append_drop, take_all_of_le le_self_add]
simp [le_of_lt (lt_of_le_of_lt (Nat.le.intro rfl) h)]
rw [nth_le_drop]
simp
simp
simp
simp
ac_rfl
simp
simp
dsimp
rw [map_drop]
rw [modify_nth_eq_take_drop, drop_eq_nth_le_cons h] <;> rfl
rw [update_nth_eq_modify_nth, modify_nth_eq_take_cons_drop _ h]
rw [this, take_length, reverse_cons]
cases l <;> cases n <;> simp only [update_nth]
simp only [length_append, Nat.le_add_right]
rw [← h] <;> apply take'_left
simp only [cons_append, foldl_cons, foldl_append (f a b) l₁ l₂]
simp only [cons_append, foldr_cons, foldr_append b l₁ l₂]
rw [foldl_cons, hf b, foldl_fixed' l]
rw [foldr_cons, foldr_fixed' l, hf a]
simp only [join, foldl_append, foldl_cons, foldl_join (foldl f a l) L]
simp only [join, foldr_append, foldr_join a L, foldr_cons]
simp only [foldr_cons, foldr_eta l] <;> constructor <;> rfl
rw [← foldr_reverse] <;> simp
induction l generalizing a
· simp; · simp [l_ih, h]
induction l generalizing a
· simp; · simp [l_ih, h]
induction l generalizing f
· exact hf
· apply l_ih fun _ h => hl _ (List.mem_cons_of_mem _ h)
    apply Function.Injective.comp hf
    apply hl _ (List.mem_cons_self _ _)
erw [length_cons, length_cons, length_scanl]
simp only [scanl, eq_self_iff_true, singleton_append, and_self_iff]
cases l
· simp only [nth, scanl_nil]
· simp only [nth, scanl_cons, singleton_append]
cases l
· simp only [nth_le, scanl_nil]
· simp only [nth_le, scanl_cons, singleton_append]
let t := scanr_aux_cons x l
simp only [scanr, scanr_aux, t, foldr_cons]
simp only [scanr, scanr_aux_cons, foldr_cons] <;> constructor <;> rfl
simp only [cons_append, foldl_cons, foldr_cons, foldl1_eq_foldr1 _ _ l] <;> rw [hassoc]
simp only [foldl_cons] <;> rw [← foldl_eq_of_comm_of_assoc, right_comm _ hcomm hassoc] <;> rfl
simp only [foldr_cons, foldl_eq_of_comm_of_assoc hcomm hassoc] <;> rw [foldl_eq_foldr a l]
rw [foldl, foldl, foldl, ← foldl_eq_of_comm', foldl, hf]
rw [foldl_eq_of_comm' hf, foldr, foldl_eq_foldr'] <;> rfl
rw [foldr, foldr, foldr, hf, ← foldr_eq_of_comm'] <;> rfl
simp only [foldl_cons, ha.assoc]
rw [foldl_assoc, foldl_cons]
simp only [foldl_cons, foldr_cons, foldl_assoc, ha.assoc] <;> rw [foldl_op_eq_op_foldr_assoc]
rw [foldl_cons, hc.comm, foldl_assoc]
induction l <;> simp [*]
simp only [nil_append, mfoldl_nil, pure_bind]
simp only [cons_append, mfoldl_cons, mfoldl_append, LawfulMonad.bind_assoc]
simp only [nil_append, mfoldr_nil, bind_pure]
simp only [mfoldr_cons, cons_append, mfoldr_append, LawfulMonad.bind_assoc]
simp only [split_at, split_at_eq_take_drop n xs, take, drop]
rw [split_on_p_aux_eq]
rfl
rw [this]
rfl
rw [attach, map_pmap] <;> exact pmap_congr l fun _ _ _ _ => rfl
rw [attach, map_pmap] <;> exact pmap_eq_map _ _ _ _
rw [attach_map_val] <;> exact h
simp only [pmap_eq_map_attach, mem_map, mem_attach, true_and_iff, Subtype.exists]
rw [← length_eq_zero, length_pmap, length_eq_zero]
simp [lookmap, h]
simp [lookmap, h]
rw [← map_id (l.lookmap f), lookmap_map_eq, map_id] <;> exact h
rw [← length_map, lookmap_map_eq _ fun _ => (), length_map] <;> simp
simp only [filter_map, h]
simp only [filter_map, h] <;> constructor <;> rfl
generalize eq : f a = b
cases b
· rw [filter_map_cons_none _ _ Eq]
· rw [filter_map_cons_some _ _ _ Eq]
rw [← filter_map_eq_map, filter_map_filter_map] <;> rfl
rw [← filter_map_eq_map, filter_map_filter_map] <;> rfl
rw [← filter_map_eq_filter, filter_map_filter_map] <;> rfl
rw [← filter_map_eq_filter, filter_map_filter_map]
congr
funext x
show (Option.guard p x).bind f = ite (p x) (f x) none
rw [filter_map_eq_map] <;> apply map_id
rw [h]
intro
contradiction
constructor <;> intro t
· rw [t] at h <;> injection h
· exact t.symm ▸ h
simp only [map_filter_map, H, filter_map_some]
rw [← List.length_map some, List.map_filter_map_some_eq_filter_map_is_some, ← List.length_map f]
apply List.length_filter_le
simp only [reduce_option, filter_map, id.def, eq_self_iff_true, and_self_iff]
simp only [reduce_option, filter_map, id.def]
rw [(reduce_option_length_le l).lt_iff_ne, Ne, reduce_option_length_eq_iff]
induction l <;> simp [*]
rw [eq_comm, ← Option.not_isSome_iff_eq_none, Decidable.imp_iff_not_or]
cases x <;> rfl
simp only [reduce_option_nil, concat_eq_append, reduce_option_append, reduce_option_cons_of_some]
simp only [reduce_option, id.def, mem_filter_map, exists_eq_right]
rw [← mem_iff_nth, ← mem_iff_nth, reduce_option_mem_iff]
induction l <;> simp [*, filter]
rw [← this] at pb
exact pb
simp only [filter_cons_of_neg _ pb] at ain
exact of_mem_filter ain
rw [filter_cons_of_pos _ pa] <;> apply mem_cons_self
rw [filter_cons_of_pos _ pb] <;> apply mem_cons_of_mem <;> apply mem_filter_of_mem ain pa
rw [filter_cons_of_neg _ pb] <;> apply mem_filter_of_mem ain pa
intro x hx
rw [mem_filter] at hx⊢
exact ⟨h hx.left, hx.right⟩
simp only [eq_nil_iff_forall_not_mem, mem_filter, not_and]
rw [← filter_map_eq_map, filter_filter_map, filter_map_filter] <;> rfl
simp only [span, if_pos pa, span_eq_take_drop l, take_while, drop_while]
simp only [span, take_while, drop_while, if_neg pa]
rw [take_while, drop_while, if_pos pa, if_pos pa, cons_append, take_while_append_drop l]
rw [take_while, drop_while, if_neg pa, if_neg pa, nil_append]
simp [erasep_cons, h]
simp [erasep_cons, h]
simp [pb]
rw [h₃] <;> rfl
simp [pb, h₄]
let ⟨_, l₁, l₂, _, _, h₁, h₂⟩ := exists_of_erasep al pa
rw [h₂, h₁, length_append, length_append]
rfl
simp [(forall_mem_cons.1 h).1, erasep_append_right _ (forall_mem_cons.1 h).2]
simp only [erase_cons, if_pos rfl]
simp only [erase_cons, if_neg h] <;> constructor <;> rfl
rw [erase_eq_erasep] <;> exact length_erasep_of_mem h rfl
rw [erase_eq_erasep, length_erasep_add_one h rfl]
rfl
rw [erase_eq_erasep] <;> apply erasep_sublist
simp [erase_eq_erasep] <;> exact sublist.erasep h
rw [erase_eq_erasep] <;> exact mem_erasep_of_neg ab.symm
rw [ab]
rw [erase_append_left _ h₁, erase_append_left _ h₁,
              erase_append_right _ (mt mem_of_mem_erase ha'), erase_cons_head]
rw [erase_append_right _ h₁, erase_append_right _ h₁, erase_append_right _ ha',
              erase_cons_tail _ ab, erase_cons_head]
simp only [erase_of_not_mem hb, erase_of_not_mem (mt mem_of_mem_erase hb)]
simp only [erase_of_not_mem ha, erase_of_not_mem (mt mem_of_mem_erase ha)]
simp only [List.diff, if_pos h]
simp only [List.diff, if_neg h, erase_of_not_mem h]
rw [← diff_cons_right, diff_cons]
rw [cons_diff, if_pos h]
rw [cons_diff, if_neg h]
simp only [diff_eq_foldl, foldl_append]
simp only [diff_eq_foldl, foldl_map, map_foldl_erase finj]
rw [diff_cons] <;>
      exact
        mem_diff_of_mem ((mem_erase_of_ne (ne_of_not_mem_cons h₂)).2 h₁)
          (not_mem_of_not_mem_cons h₂)
simp only [diff_cons, (h.erase _).diff_right]
simp only [HEq, erase_cons_head, diff_cons]
rw [add_right_comm] <;> rfl
simp only [enum, enum_from_nth, zero_add] <;> intros <;> rfl
simp [enum_from]
simp [enum, enum_from_append]
rw [← Option.some_inj, ← nth_le_nth]
simp [enum_from_nth, nth_le_nth hi]
cases as <;> rfl
cases bs <;> rfl
cases as <;> rfl
cases bs <;> rfl
cases as <;> rfl
simp!
simp!
simp! [*]
simp!
simp!
simp at h
contradiction
simp at h
simp! [*]
cases bs <;> rfl
simp only [map₂_right, map₂_right', map₂_left_eq_map₂_left']
have : (fun a b => flip f a (some b)) = flip fun a b => f (some a) b := rfl
simp only [map₂_right, map₂_left_eq_map₂, map₂_flip, *]
cases as <;> rfl
simp only [zip_left, zip_left', map₂_left_eq_map₂_left']
cases bs <;> rfl
simp only [zip_right, zip_right', map₂_right_eq_map₂_right']
cases n <;> rfl
cases i <;> rfl
rw [to_chunks_aux, drop, to_chunks] <;> cases to_chunks_aux n xs n <;> rfl
rw [to_chunks_aux, to_chunks_aux_eq] <;> rfl
rw [to_chunks, to_chunks_aux_eq] <;> rfl
cases n <;> rfl
simp only [to_chunks, join] <;> rw [append_nil]
refine' (measure_wf length).induction xs _
intro xs IH h
rw [ball_cons, all₂_cons, all₂_iff_forall]
induction l <;> simp [*]
rw [nth_le_map']
congr <;> apply attach_map_val
induction n generalizing xs
· simp [slice]
· cases xs <;> simp [slice, *, Nat.succ_add]
cases n <;> simp
rw [nthd_eq_nth_le _ _ h', nth_le_append h' h, nthd_eq_nth_le]
rw [← nthd_default_eq_inth, nthd_eq_get_or_else_nth, Option.getD_default_eq_iget]
cases l <;> rfl
simp [tfae, -eq_iff_iff]
simp
rfl
rfl
rw [Ico, tsub_zero, range_eq_range']
dsimp [Ico]
simp only [length_range']
dsimp [Ico]
simp only [pairwise_lt_range']
dsimp [Ico]
simp only [nodup_range']
simp [Ico, this]
simp [Ico, tsub_eq_zero_iff_le.mpr h]
rw [Ico, Ico, map_add_range', add_tsub_add_eq_tsub_right, add_comm n k]
rw [Ico, Ico, tsub_tsub_tsub_cancel_right h₁, map_sub_range' _ _ _ h₁]
rw [← length, h, List.length]
dsimp [Ico]
simp [add_tsub_cancel_left]
rw [← append_consecutive (Nat.le_succ n) h, succ_singleton]
rfl
dsimp [Ico]
rw [tsub_tsub_cancel_of_le (succ_le_of_lt h)]
simp
simp
have r : min m (n + 1) = n + 1 := (@inf_eq_right _ _ m (n + 1)).mpr hnm
simp [filter_lt n m (n + 1), r]
rw [← filter_lt_of_succ_bot hnm]
exact filter_congr' fun _ _ => lt_succ_iff.symm
simp [ax]
simp [ay]
simp [ax]
rw [append_nil]
simp
simp
simp [r]
simp
injection p.symm.eq_nil
rw [reverse_cons]
exact (perm_append_singleton _ _).trans ((reverse_perm l).cons a)
simp
rw [← filter_map_eq_filter] <;> apply s.filter_map _
funext a c
apply propext
constructor
· exact fun ⟨b, hab, hba⟩ => perm.trans hab hba
· exact fun h => ⟨a, perm.refl a, h⟩
simp
rw [countp_eq_length_filter, countp_eq_length_filter] <;> exact (s.filter _).length_eq
rw [← countp_append]
exact perm.countp_eq _ (filter_append_perm _ _).symm
simp only [foldl]
rw [H x (Or.inr <| Or.inl rfl) y (Or.inl rfl)]
exact r (fun x hx y hy => H _ (Or.inr <| Or.inr hx) _ (Or.inr <| Or.inr hy)) _
simp <;> rw [r b]
simp <;> rw [lcomm, r b]
induction hl
case nil => rfl
case cons a l l' h ih => exact f_congr h ih
case swap a a' l => exact f_swap
case trans l₁ l₂ l₃ h₁ h₂ ih₁ ih₂ => exact HEq.trans ih₁ ih₂
simp only [mul_assoc, h.eq]
simp
simp
simp
rw [h]
have h₂ : a ∉ l₂ := mt p.mem_iff.2 h₁
rw [erase_of_not_mem h₁, erase_of_not_mem h₂] <;> exact p
induction t generalizing l₁ l₂ h <;> simp [*, perm.erase]
induction h generalizing l <;>
    first |simp [*, perm.erase, erase_comm]|exact (ih_1 _).trans (ih_2 _)
induction t generalizing l₁ l₂ h <;> simp [*, subperm.erase]
simp
simp only [diff_cons]
refine' ((erase_cons_subperm_cons_erase a b l₁).diff_right l₂).trans _
apply subperm_cons_diff
rw [← H] <;> simp <;> apply Nat.succ_pos
rw [← count_pos]
exact lt_of_lt_of_le (count_pos.mpr (mem_cons_self _ _)) (h hd (mem_cons_self _ _))
refine' this.trans (perm.subperm _)
exact perm_append_comm.trans (subperm_append_diff_self_of_count_le h)
rw [subperm_ext_iff] at h⊢
intro y hy
have := h.nil_eq <;> contradiction
simp [nodup_dedup, h, p.subset h]
simp [h, mt p.mem_iff.2 h]
induction l <;> simp [*, perm.insert]
apply tsub_le_self
rw [reverse_take _ h₁, h₀, reverse_reverse]
apply eq_nil_of_length_eq_zero
rw [length_drop, tsub_eq_zero_iff_le]
apply le_of_not_ge h''
simp
simp
simp
simp
intros
simp only [map_bind, permutations'_aux]
refine' (bind_append_perm _ (fun x => [_]) _).symm.trans _
rw [← map_eq_bind, ← bind_map]
simp
simp
simp [hl]
rw [length_insert_nth _ _ hk.le, length_insert_nth _ _ (Nat.succ_le_of_lt hk)]
simp [hn', ← hm', hm]
simp [hm', ← hn', hn]
exact h x (hb.subset this) rfl
        rw [← hx', nth_le_insert_nth_of_lt _ _ _ _ ht (ht.trans_le hm)]
        exact nth_le_mem _ _ _
      · simp only [ht]
exact h x (ha.subset this) rfl
        rw [← hx, nth_le_insert_nth_of_lt _ _ _ _ ht (ht.trans_le hn)]
        exact nth_le_mem _ _ _
simp (config := { contextual := true }) only [true_and_iff, iff_self_iff, forall₂_true_iff]
simp (config := { contextual := true }) only [forall_prop_of_true, iff_self_iff,
        forall₂_true_iff]
simp only [pairwise_cons, mem_singleton, forall_prop_of_false (not_mem_nil _), forall_true_iff,
    pairwise.nil, and_true_iff]
simp only [pairwise_cons, mem_singleton, forall_eq, forall_prop_of_false (not_mem_nil _),
    forall_true_iff, pairwise.nil, and_true_iff]
have :
    ∀ l₁ l₂ : List α,
      (∀ x : α, x ∈ l₁ → ∀ y : α, y ∈ l₂ → R x y) → ∀ x : α, x ∈ l₂ → ∀ y : α, y ∈ l₁ → R x y :=
    fun l₁ l₂ a x xm y ym => s (a y ym x xm)
simp only [pairwise_append, and_left_comm] <;> rw [Iff.intro (this l₁ l₂) (this l₂ l₁)]
rw [← append_assoc, pairwise_append, @pairwise_append _ _ ([a] ++ l₁),
        pairwise_append_comm s] <;>
      simp only [mem_append, or_comm']
simp only [map, pairwise.nil]
simp only [forall_eq']
rw [← filter_map_eq_filter, pairwise_filter_map]
apply pairwise.iff
intros
simp only [Option.mem_def, Option.guard_eq_some, and_imp, forall_eq']
refine' (pairwise_pmap h).2 (pairwise.imp_of_mem _ hl)
intros
apply hS
assumption
simp [List.bind, List.pairwise_join, List.mem_map, List.pairwise_map]
simp only [pairwise.nil, true_iff_iff] <;> exact fun i j h => (Nat.not_lt_zero j).elim h
simp
simp [hx, mem_repeat, pairwise_repeat n]
rw [pw_filter_map] <;> apply mem_map_of_mem _ hb
simp [rotate]
simp [rotate]
simp [rotate]
cases n <;> rfl
cases l <;> rfl
simp [rotate']
rw [List.rotate', length_rotate' (l ++ [a]) n] <;> simp
simp [drop_append_of_le_length h]
simp [take_append_of_le_length h]
rw [length_append, length_cons, List.length, zero_add] <;> exact le_of_succ_le h
simp
simp
rw [rotate'_cons_succ, rotate'_rotate', add_right_comm, rotate'_cons_succ]
rw [rotate'_eq_drop_append_take le_rfl] <;> simp
simp
simp [-rotate'_length, Nat.mul_succ, rotate'_rotate']
rw [rotate'_length, rotate'_length_mul]
rw [rotate'_length_mul]
rw [rotate'_rotate', length_rotate', Nat.mod_add_div]
simp_all [length_eq_zero]
rw [← rotate'_mod,
        rotate'_eq_drop_append_take (le_of_lt (Nat.mod_lt _ (Nat.pos_of_ne_zero h)))] <;>
      simp [rotate]
rw [rotate_eq_rotate', rotate_eq_rotate', rotate'_cons_succ]
simp
simp
simp [rotate_cons_succ, mem_rotate, or_comm]
rw [rotate_eq_rotate', length_rotate']
rw [rotate_eq_rotate'] <;> exact rotate'_eq_drop_append_take
rw [rotate_eq_rotate']
induction l generalizing l'
· simp
· simp [rotate', l_ih]
rw [rotate_eq_rotate', rotate_eq_rotate', rotate_eq_rotate', rotate'_rotate']
rw [rotate_eq_rotate', rotate'_length]
rw [rotate_eq_rotate', rotate'_length_mul]
simp
decide
rw [eq_comm, rotate_eq_nil_iff, eq_comm]
rw [eq_comm, rotate_eq_singleton_iff, eq_comm]
rw [rotate_eq_drop_append_take_mod, rotate_eq_drop_append_take_mod,
    rotate_eq_drop_append_take_mod, h, zip_with_append, ← zip_with_distrib_drop, ←
    zip_with_distrib_take, List.length_zip_with, h, min_self]
rw [length_drop, length_drop, h]
simp
simp [← hk', hk, Nat.mod_lt]
simp
have hi : i % l.length < l.length := mod_lt _ (length_pos_of_ne_nil hn)
have hj : j % l.length < l.length := mod_lt _ (length_pos_of_ne_nil hn)
refine' (nodup_iff_nth_le_inj.mp hl) _ _ hi hj _
rw [← nth_le_rotate' l i, ← nth_le_rotate' l j]
simp [tsub_add_cancel_of_le, hi.le, hj.le, h]
simp
simp
rw [rotate_rotate]
rfl
rw [is_rotated_comm, is_rotated_nil_iff, eq_comm]
rfl
rw [is_rotated_comm, is_rotated_singleton_iff, eq_comm]
simp
simp
simp [is_rotated_reverse_comm_iff]
simp [cyclic_permutations_of_ne_nil]
simp [cyclic_permutations_of_ne_nil _ h]
simp
simp [h]
simp [cyclic_permutations, h, init_eq_take]
cases l
· simp
· rw [length_cyclic_permutations_of_ne_nil] <;> simp
simp
rw [prod_cons] <;> exact dvd_mul_right _ _
simp [map_with_index_eq_enum_map, enum_eq_zip_range, map_uncurry_zip_eq_zip_with,
    range_succ_eq_map, zip_with_map_left]
simp [map_with_index_eq_enum_map, enum_eq_zip_range]
induction as generalizing start
· rfl
· simp only [foldr_with_index_aux, foldr_with_index_aux_spec_cons, *]
simp only [foldr_with_index, foldr_with_index_aux_spec,
    foldr_with_index_aux_eq_foldr_with_index_aux_spec, enum]
simp [indexes_values, foldr_with_index_eq_foldr_enum, uncurry, filter_eq_foldr]
simp only [indexes_values_eq_filter_enum, map_filter_eq_foldr, find_indexes,
    foldr_with_index_eq_foldr_enum, uncurry]
induction bs generalizing start a
· rfl
· simp [foldl_with_index_aux, foldl_with_index_aux_spec_cons, *]
simp only [foldl_with_index, foldl_with_index_aux_spec,
    foldl_with_index_aux_eq_foldl_with_index_aux_spec, enum]
simp only [mfoldr_with_index, mfoldr_eq_foldr, foldr_with_index_eq_foldr_enum, uncurry]
rw [mfoldl_with_index, mfoldl_eq_foldl, foldl_with_index_eq_foldl_enum]
induction as generalizing start
· rfl
· simp [mmap_with_index_aux, mmap_with_index_aux_spec_cons, *]
simp only [mmap_with_index, mmap_with_index_aux_spec,
    mmap_with_index_aux_eq_mmap_with_index_aux_spec, enum]
induction as generalizing start <;>
    simp [mmap_with_index'_aux, mmap_with_index_aux, *, seq_right_eq, const, -comp_const,
      functor_norm]
apply mmap_with_index'_aux_eq_mmap_with_index_aux
rw [sublists', map_sublists'_aux, ← sublists'_aux_append] <;> rfl
rw [sublists', sublists'_aux] <;> simp only [sublists'_aux_eq_sublists', map_id, append_nil] <;>
    rfl
rw [h]
simp only [sublists'_cons, length_append, length_sublists' l, length_map, length, pow_succ',
      mul_succ, mul_zero, zero_add]
rw [sublists_aux₁, sublists_aux] <;> simp only [*, append_assoc]
rw [sublists_aux₁_eq_sublists_aux] <;> rfl
rw [← sublists_aux_eq_foldr] <;> rfl
simp only [sublists_aux₁, nil_append, append_nil]
simp only [sublists_aux₁, cons_append, sublists_aux₁_append l₁, append_assoc] <;> rfl
simp only [sublists_aux₁_append, sublists_aux₁, append_assoc, append_nil]
simp only [sublists_aux₁, bind_append, sublists_aux₁_bind l]
simp only [sublists, sublists_aux_cons_eq_sublists_aux₁, sublists_aux₁_append, bind_eq_bind,
    sublists_aux₁_bind]
congr
funext x
apply congr_arg _
rw [← bind_ret_eq_map, sublists_aux₁_bind]
exact (append_nil _).symm
simp only [map, sublists, sublists_aux_cons_append, map_eq_map, bind_eq_bind, cons_bind, map_id',
        append_nil, cons_append, map_id' fun _ => rfl] <;>
      constructor <;>
    rfl
rw [sublists_append, sublists_singleton, bind_eq_bind, cons_bind, cons_bind, nil_bind, map_eq_map,
    map_eq_map, map_id' append_nil, append_nil]
rw [← sublists_reverse, reverse_reverse]
simp only [sublists_eq_sublists', map_map, map_id' reverse_reverse]
rw [← sublists'_reverse, reverse_reverse]
rw [← reverse_sublist_iff, ← mem_sublists', sublists'_reverse,
    mem_map_of_injective reverse_injective]
simp only [sublists_eq_sublists', length_map, length_sublists', length_reverse]
rfl
rfl
rw [sublists_len, ← sublists_len_aux_append] <;> rfl
cases l <;> rfl
rw [sublists_len, sublists_len_aux, sublists_len_aux_eq, sublists_len_aux_eq, map_id,
      append_nil] <;>
    rfl
simp
simp
simp [-add_comm, Nat.choose, *] <;> apply add_comm
rw [sublists_len_succ_cons, sublists'_cons]
exact (sublists_len_sublist_sublists' _ _).append ((sublists_len_sublist_sublists' _ _).map _)
rw [length, sublists_len_succ_cons, sublists_len_length, map_singleton,
      sublists_len_of_length_lt (lt_succ_self _), nil_append]
rw [sublists'_eq_sublists, nodup_map_iff reverse_injective, nodup_sublists, nodup_reverse]
let IH := sublists_perm_sublists' l
rw [sublists'_cons] <;> exact (sublists_cons_perm_append _ _).trans (IH.append (IH.map _))
rw [destutter', if_pos h]
rw [destutter', if_neg h]
rw [← chain', ← h]
exact l.destutter'_is_chain' R a
simp
simp only [disjoint_left, imp_not_comm, forall_eq']
rw [disjoint_comm]
exact disjoint_nil_left _
simp only [Disjoint, mem_singleton, forall_eq]
rfl
rw [disjoint_comm, singleton_disjoint]
simp only [Disjoint, mem_append, or_imp, forall_and]
simp only [disjoint_comm, disjoint_append_left]
simp only [singleton_disjoint]
simp only [disjoint_comm, disjoint_cons_left]
induction l₁ <;>
    simp only [nil_union, not_mem_nil, false_or_iff, cons_union, mem_insert_iff, mem_cons_iff,
      or_assoc', *]
rfl
simp only [e, cons_union, insert_of_mem h]
simp only [cons_append, cons_union, e, insert_of_not_mem h] <;> constructor <;> rfl
simp only [mem_union, or_imp, forall_and]
simp only [eq_nil_iff_forall_not_mem, mem_inter, not_and]
rfl
simp only [List.inter, mem_reverse]
cases l <;> rfl
cases l <;> rfl
cases l₂ <;> exact if_pos h
cases l₂
· simp only [bag_inter_nil]
simp only [erase_of_not_mem h, List.bagInter, if_neg h]
simp only [nil_bag_inter, not_mem_nil, false_and_iff]
simp
simp
simp
simp
simp [rdrop]
simp [rdrop]
simp [rdrop_eq_reverse_drop_reverse]
simp [rtake]
simp [rtake]
simp [rtake_eq_reverse_take_reverse]
simp [rdrop_while, drop_while]
rw [rdrop_while_concat, if_pos h]
rw [rdrop_while_concat, if_neg h]
rw [← nil_append [x], rdrop_while_concat, rdrop_while_nil]
rw [← reverse_suffix, rdrop_while, reverse_reverse]
exact drop_while_suffix _
simp [rdrop_while]
simp only [rdrop_while, reverse_eq_iff, length_reverse, Ne.def, drop_while_eq_self_iff,
    last_eq_nth_le, ← length_eq_zero, pos_iff_ne_zero]
refine' forall_congr' _
intro h
rw [nth_le_reverse']
· simp
· rw [← Ne.def, ← pos_iff_ne_zero] at h
    simp [tsub_lt_iff_right (Nat.succ_le_of_lt h)]
simp [rtake_while, take_while]
rw [rtake_while_concat, if_pos h]
rw [rtake_while_concat, if_neg h]
rw [← reverse_prefix, rtake_while, reverse_reverse]
exact take_while_prefix _
simp [rtake_while, reverse_eq_iff]
induction l using List.reverseRecOn <;> simp [rtake_while]
exact mem_take_while_imp this
  rwa [← mem_reverse, ← rtake_while]
cases h
simp
simp [m]
rw [split, h] <;> rfl
simp [merge_sort, h]
apply this
simp [merge]
simp [merge]
simp [merge]
simp [merge_sort]
simp [merge_sort]
simp [merge]
simp [merge_sort]
simp [merge_sort]
rw [List.mergeSort]
rw [List.mergeSort]
simp only [chain_cons, chain.nil, and_true_iff]
rw [chain_split, chain_cons]
simp
simp [init]
simp [@chain_iff_forall₂ b]
simp [chain_iff_forall₂, init]
induction l generalizing b <;> simp only [map, chain.nil, chain_cons, *]
simp only [mem_cons_iff, forall_eq_or_imp, h, true_and_iff]
exact fun c hc => trans h (rel_of_pairwise_cons hb.pairwise hc)
rw [chain_iff_pairwise] at hl⊢
exact hl.sublist (h.cons_cons a)
rw [chain_iff_pairwise] at hl
exact rel_of_pairwise_cons hl hb
simp
simp
simp
rw [chain'_split, chain'_cons]
rw [chain'_iff_pairwise] at hl⊢
exact hl.sublist h
rw [← cons_head'_tail hy] at h
exact h.rel_head
simp
simp [chain'_cons', and_comm']
rw [cons_append, cons_append, chain'_cons, chain'_cons, ← cons_append, chain'_append, last',
      and_assoc]
simp only [chain'_singleton, chain'_cons, and_true_iff]
simp only [chain'_singleton, reverse_singleton]
rw [chain'_cons, reverse_cons, reverse_cons, append_assoc, cons_append, nil_append,
      chain'_split, ← reverse_cons, @chain'_reverse (b :: l), and_comm', chain'_pair, flip]
simp
simp
rw [← and_forall_succ, chain'_cons, chain'_iff_nth_le]
simp only [length, nth_le, add_tsub_cancel_right, add_lt_add_iff_right, tsub_pos_iff_lt,
      one_lt_succ_succ, true_imp_iff]
rfl
simp
simp [@forall₂_same l]
cases H <;> rfl
cases H <;> rfl
simp only [forall₂_nil_left_iff, forall_prop_of_false (not_mem_nil _), imp_true_iff,
      true_and_iff]
simp only [forall₂_and_left l, forall₂_cons_left_iff, forall_mem_cons, and_assoc', and_comm',
      and_left_comm, exists_and_distrib_left.symm]
simp only [map, forall₂_nil_left_iff]
simp only [map, forall₂_cons_left_iff, forall₂_map_left_iff]
simp only [map, forall₂_nil_right_iff]
simp only [map, forall₂_cons_right_iff, forall₂_map_right_iff]
simp only [forall₂.nil, take]
simp only [forall₂.nil, take]
simp [And.intro h₁ h₂, forall₂_take n]
simp only [drop, h]
simp only [forall₂.nil, drop]
simp [And.intro h₁ h₂, forall₂_drop n]
simp only [not_mem_nil]
simp only [reverse_cons]
exact rel_append (rel_reverse h₂) (forall₂.cons h₁ forall₂.nil)
rw [← reverse_reverse l₁, ← reverse_reverse l₂]
exact rel_reverse h
rw [filter_map_cons, filter_map_cons] <;>
      exact
        match f a, g b, hfg h₁ with
        | _, _, Option.Rel.none => rel_filter_map (@hfg) h₂
        | _, _, Option.Rel.some h => forall₂.cons h (rel_filter_map (@hfg) h₂)
simp
simp [eq_comm]
rw [argmax, argmax] <;> simp [arg_aux]
simp
simp [argmax]
simp
simp only [maximum, argmax_concat, id]
cases h : argmax id l
· exact (max_eq_right bot_le).symm
· simp [Option.coe_def, max_def_lt]
simp [@max_eq_left (WithBot α) _ _ _ bot_le]
rw [← cons_append, maximum_concat, ih, maximum_concat, max_assoc]
rw [repeat_succ, dedup_cons_of_mem (mem_repeat.2 ⟨n.succ_ne_zero, rfl⟩),
      repeat_dedup n.succ_ne_zero]
simp [h]
simp [hp]
simp [H]
simp
simp [nd]
simp
simp [tsub_le_tsub_iff_right, Nat.succ_le_iff, Nat.lt_succ_iff]
intro ix
simp [List.nth_drop, add_tsub_cancel_of_le, Nat.succ_le_iff, ← hf]
simp
simp
simp
simp
simp
simp
rw [product_cons, product_nil] <;> rfl
simp only [product, mem_bind, mem_map, Prod.ext_iff, exists_prop, and_left_comm, exists_and_left,
    exists_eq_left, exists_eq_right]
rw [sigma_cons, sigma_nil] <;> rfl
simp only [List.sigma, mem_bind, mem_map, exists_prop, exists_and_left, and_left_comm,
    exists_eq_left, heq_iff_eq, exists_eq_right]
simp only [nodup, pairwise_cons, forall_mem_ne]
simp only [nodup_nil]
simp (config := { contextual := true })
rw [nodup_iff_nth_le_inj]
simp only [exists_prop, exists_and_right, not_forall]
exact ⟨n, m, ⟨hn, hm, h⟩, hne⟩
simp [Nat.zero_le]
simp
simp only [nodup, pairwise_append, disjoint_iff_ne]
simp only [nodup_append, and_left_comm, disjoint_comm]
simp only [nodup_append, not_or, and_left_comm, and_assoc', nodup_cons, mem_append,
    disjoint_cons_right]
congr <;> exact hf a (H _ ha) b (H _ hb) h
simp only [nodup, Ne.def, eq_comm]
rw [d.erase_eq_filter, mem_filter, and_comm']
simp only [nodup, pairwise_join, disjoint_left.symm, forall_mem_ne]
simp only [List.bind, nodup_join, pairwise_map, and_comm', and_left_comm, mem_map, exists_imp,
      and_imp] <;>
    rw [show (∀ (l : List β) (x : α), f x = l → x ∈ l₁ → nodup l) ↔ ∀ x : α, x ∈ l₁ → nodup (f x)
        from forall_swap.trans <| forall_congr' fun _ => forall_eq']
injection h with _ h <;> exact eq_of_heq h
rw [concat_eq_append] <;> exact h'.append (nodup_singleton _) (disjoint_singleton.2 h)
rw [insert_of_mem h'] <;> exact h
rw [insert_of_not_mem h', nodup_cons] <;> constructor <;> assumption
simp
rw [diff_cons, (hl₁.erase _).diff_eq_filter, hl₁.erase_eq_filter, filter_filter]
simp only [mem_cons_iff, not_or, and_comm]
rw [hl₁.diff_eq_filter, mem_filter]
rw [range_map, Subtype.range_coe]
rw [← Set.mem_range, range_map]
exact fun a ha => CanLift.prf a (H a ha)
simp
simp
simp [false_imp_iff]
cases h
cases o <;> simp [to_list, eq_comm]
cases a <;> cases b <;> simp [lift_or_get, h.comm]
cases a <;> cases b <;> cases c <;> simp [lift_or_get, h.assoc]
cases a <;> simp [lift_or_get, h.idempotent]
cases a <;> simp [lift_or_get]
cases a <;> simp [lift_or_get]
cases a <;> rfl
cases a <;> rfl
simp [map₂]
cases a <;> cases b <;> simp
cases a <;> cases b <;> rfl
cases a <;> cases b <;> rfl
cases a <;> rfl
cases b <;> rfl
cases x <;> rfl
cases a <;> cases b <;> cases c <;> simp [h_assoc]
cases a <;> cases b <;> simp [h_comm]
cases a <;> cases b <;> cases c <;> simp [h_left_comm]
cases a <;> cases b <;> cases c <;> simp [h_right_comm]
cases a <;> cases b <;> simp [h_distrib]
cases a <;> cases b <;> simp [h_distrib]
cases a <;> cases b <;> simp [h_distrib]
cases a <;> cases b <;> simp [h_left_comm]
cases a <;> cases b <;> simp [h_right_comm]
cases a <;> cases b <;> simp [h_antidistrib]
cases a <;> cases b <;> simp [h_antidistrib]
cases a <;> cases b <;> simp [h_antidistrib]
cases a <;> cases b <;> simp [h_left_anticomm]
cases a <;> cases b <;> simp [h_right_anticomm]
rw [Hf (Option.some.inj H)]
cases x <;> simp
cases x <;> simp
simp only [eq_none_iff_forall_not_mem, not_exists, not_and, mem_def, bind_eq_some']
cases a <;> cases b <;> rfl
cases x <;> rfl
simp
simp
simp
simp
rw [joinM, bind_id_eq_join]
cases x <;> simp
cases x <;> simp
cases x <;> simp only [map_none, map_some, eq_self_iff_true]
cases x <;> simp only [map_none', map_some', eq_self_iff_true]
simp only [← map_some', h]
cases x <;> simp only [map_none', map_some', h, mem_def]
cases x <;> simp only [map_none', map_some']
rw [map_map, h, ← map_map]
simp
simp
simp
cases x <;> simp
cases x <;> simp only [pbind, none_bind', some_bind']
cases x <;> simp
cases x <;> simp only [pbind, map_none']
cases x <;> rfl
rw [mem_def] at ha⊢
subst ha
rfl
cases x <;> simp only [map_none', map_some', pmap]
cases x <;> simp only [map_none', map_some', pmap]
cases x <;> simp only [map_none', map_some', pmap]
cases x <;> simp only [pmap, none_bind, some_bind]
cases x <;> simp only [pmap, none_bind, some_bind, pbind]
cases x
· simp
· simp only [pbind, iff_false_iff]
    intro h
    cases h' x rfl h
cases x <;> simp
cases x <;> rfl
cases x <;> rfl
cases x <;> simp [is_some] <;> exact ⟨_, rfl⟩
cases a <;> simp
cases o <;> simp
cases o <;> simp
cases o <;> simp
cases o <;> simp
cases o <;> rfl
cases u
cases b <;> rfl
cases a <;> rfl
cases o <;> rfl
cases o <;> rfl
cases o
· simp only [true_and_iff, false_or_iff, eq_self_iff_true, none_orelse]
· simp only [some_orelse, or_false_iff, false_and_iff]
cases o
· simp only [true_and_iff, none_orelse, eq_self_iff_true]
· simp only [some_orelse, false_and_iff]
dsimp [choice]
rw [dif_pos (⟨a⟩ : Nonempty α)]
congr
cases o <;> rfl
cases s <;> rfl
cases s' <;> rfl
injection
      (le_stable s (le_max_left m n) ha.symm).symm.trans (le_stable s (le_max_right m n) hb.symm)
dsimp [Stream'.nth] at h
rw [← h]
exact rfl
clear _fun_match <;> contradiction
intro h <;> rw [← h] <;> apply get_mem
rw [← get_eq_of_mem _ h] <;> apply results_of_terminates
rw [length_think, h.length]
apply Subtype.eq <;> dsimp [think, map] <;> rw [Stream'.map_cons]
apply s.rec_on <;> intro <;> simp
simp [bind, bind.F]
apply rec_on s <;> intro s <;> simp
exact Or.inr ⟨s, rfl, rfl⟩
rw [bind_ret] <;> change fun x : α => x with @id α <;> rw [map_id]
let ⟨a, m, n', h1, h2, e'⟩ := IH e
rw [e'] <;> exact ⟨a, m.succ, n', results_think h1, h2, rfl⟩
rw [← bind_ret] <;> apply mem_bind m <;> apply ret_mem
rw [← bind_ret] at h <;>
    exact
      let ⟨a, as, fb⟩ := exists_of_mem_bind h
      ⟨a, as, mem_unique (ret_mem _) fb⟩
rw [← bind_ret] <;> infer_instance
unfold HasOrelse.orelse <;> simp [orelse]
unfold HasOrelse.orelse <;> simp [orelse]
unfold HasOrelse.orelse <;> simp [orelse]
apply eq_of_bisim (fun c₁ c₂ => (Empty α <|> c₂) = c₁) _ rfl
intro s' s h
rw [← h]
apply rec_on s <;> intro s <;> rw [think_empty] <;> simp
rw [← think_empty]
apply eq_of_bisim (fun c₁ c₂ => (c₂ <|> Empty α) = c₁) _ rfl
intro s' s h
rw [← h]
apply rec_on s <;> intro s <;> rw [think_empty] <;> simp
rw [← think_empty]
rw [mem_unique ma h1] <;> exact h2
rw [mem_unique ma h2] <;> exact h1
simp only [terminates_iff, exists_congr h]
let ⟨b', mb', ab'⟩ := l ma
rw [mem_unique mb mb'] <;> exact ab'
rw [mem_unique ma' ma] <;> exact ⟨b, mb, ab⟩
rw [mem_unique mb' mb] <;> exact ⟨a, ma, ab⟩
rw [eq_of_ret_mem ma'] <;> exact ⟨b, mb, ab⟩
rw [mem_unique mb' mb] <;> exact ab
rw [lift_rel.swap, lift_rel_return_left]
rw [← lift_rel.swap R, ← lift_rel.swap R] <;> apply lift_rel_think_left
rw [← bind_ret, ← bind_ret] <;> apply lift_rel_bind _ _ h1 <;> simp <;> exact @h2
rw [← lift_eq_iff_equiv] <;>
    exact lift_rel_map Eq _ ((lift_eq_iff_equiv _ _).2 h1) fun a b => congr_arg _
rw [mem_unique (ret_mem _) mb] <;> exact h
rw [← lift_rel_aux.swap, lift_rel_aux.ret_left]
revert cb
refine' mem_rec_on ha _ fun ca' IH => _ <;> intro cb Hc <;> have h := H Hc
· simp at h
    simp [h]
· have h := H Hc
    simp
    revert h
    apply cb.rec_on (fun b => _) fun cb' => _ <;> intro h <;> simp at h <;> simp [h]
    exact IH _ h
apply destruct_eq_ret
simp [parallel.aux1]
rw [e]
simp [rmap]
apply destruct_eq_think
simp [parallel.aux1]
rw [h]
simp [rmap]
unfold Seq.destruct Functor.map
rw [← a]
simp
dsimp [Seq.destruct]
rw [e]
rfl
dsimp [Seq.destruct]
rw [e]
rfl
let ⟨c, cs, ac⟩ := exists_of_mem_parallel m
let ⟨n, nm⟩ := exists_nth_of_mem cs
let ⟨c', h'⟩ := head_some_of_nth_some nm
injection h h'
rw [← Wseq.map_comp]
refine' (Wseq.map_id _).symm.trans (congr_arg (fun f => Wseq.map f S) _)
funext c
dsimp [id, Function.comp]
rw [← map_comp]
exact (map_id _).symm
have aa := parallel_promises h1 h <;> rw [← aa] <;> rw [← aa] at h <;>
      exact
        let ⟨s, sS, as⟩ := exists_of_mem_parallel h
        let ⟨t, tT, st⟩ := Wseq.exists_of_lift_rel_left H sS
        let aT := (st _).1 as
        mem_parallel h2 tT aT
have aa := parallel_promises h2 h <;> rw [← aa] <;> rw [← aa] at h <;>
      exact
        let ⟨s, sS, as⟩ := exists_of_mem_parallel h
        let ⟨t, tT, st⟩ := Wseq.exists_of_lift_rel_right H sS
        let aT := (st _).2 as
        mem_parallel h1 tT aT
rw [← Option.some_inj, ← nth_cons_zero, h, nth_cons_zero]
unfold terminated_at <;> cases s.nth n <;> simp
simp [terminates, terminated_at, ← Ne.def, Option.ne_none_iff_isSome]
simp [s_nth_eq_some]
injection h
injection h
dsimp [ destruct ]
unfold cons destruct Functor.map
apply congr_arg fun s => some (a, s)
apply Subtype.eq
dsimp [tail]
rw [Stream'.tail_cons]
unfold destruct head <;> cases nth s 0 <;> rfl
rw [head_eq_destruct, destruct_cons] <;> rfl
apply destruct_eq_cons
unfold destruct nth Functor.map
rw [← e]
rfl
cases s' <;> rfl
cases s <;> rfl
cases s' <;> rfl
rw [List.nth_eq_none_iff] at h⊢
exact h.trans (Nat.le_succ n)
contradiction
apply coinduction2
intro s
dsimp [append]
rw [corec_eq]
dsimp [append]
apply rec_on s _ _
· trivial
· intro x s
    rw [destruct_cons]
    dsimp
    exact ⟨rfl, s, rfl, rfl⟩
dsimp [append]
rw [corec_eq]
dsimp [append]
rw [destruct_cons]
dsimp [append]
rfl
apply coinduction2 s
intro s
apply rec_on s _ _
· trivial
· intro x s
    rw [cons_append, destruct_cons, destruct_cons]
    dsimp
    exact ⟨rfl, s, rfl, rfl⟩
apply rec_on s <;> simp
· apply rec_on t <;> simp
          · apply rec_on u <;> simp
            · intro x u
              refine' ⟨nil, nil, u, _, _⟩ <;> simp
          · intro x t
            refine' ⟨nil, t, u, _, _⟩ <;> simp
· intro x s
          exact ⟨s, t, u, rfl, rfl⟩
apply Subtype.eq <;> dsimp [cons, map] <;> rw [Stream'.map_cons] <;> rfl
apply Subtype.eq <;> dsimp [map]
rw [Option.map_id, Stream'.map_id] <;> rfl
apply Subtype.eq <;> dsimp [tail, map] <;> rw [Stream'.map_tail] <;> rfl
apply rec_on s <;> simp
· apply rec_on t <;> simp
        · intro x t
          refine' ⟨nil, t, _, _⟩ <;> simp
· intro x s
        refine' ⟨s, t, rfl, rfl⟩
simp [join]
simp [join]
apply rec_on s
· trivial
· intro x s
        rw [destruct_cons]
        exact ⟨rfl, Or.inl rfl⟩
apply rec_on s
· simp
· intro x s
        simp
        refine' Or.inr ⟨x, s, S, rfl, rfl⟩
apply Subtype.eq <;> simp [of_stream, cons] <;> rw [Stream'.map_cons]
induction l <;> simp [*]
induction l <;> simp [*, Stream'.nil_append_stream, Stream'.cons_append_stream]
apply mem_rec_on h <;> intros <;> simp [*]
simp [map]
dsimp [join] <;> rw [destruct_cons] <;> rfl
apply coinduction2 s <;> intro s <;> apply rec_on s <;> simp [ret]
dsimp [bind, map]
change fun x => ret (f x) with ret ∘ f
rw [map_comp]
simp [Function.comp, ret]
apply rec_on s <;> intros <;> simp [map]
refine' Computation.LiftRel.imp _ _ _ (h2 h1) <;> apply lift_rel_o.imp_right <;>
      exact fun s' t' h' => ⟨R, h', @h2⟩
refine' ⟨swap (lift_rel R), h, fun s t (h : lift_rel R t s) => _⟩
rw [← lift_rel_o.swap, Computation.LiftRel.swap]
apply lift_rel_destruct h
constructor <;> apply H
simp [destruct, cons, Computation.rmap]
simp [destruct, think, Computation.rmap]
simp [head] <;> rfl
simp [head] <;> rfl
simp [head] <;> rfl
simp [flatten, think]
cases c.destruct <;> simp
simp [tail]
simp [tail]
simp [tail]
induction n <;> simp [*, drop]
induction n <;> simp [*, drop]
induction n <;> simp [*, drop]
simp [think, join]
unfold Functor.map
simp [join, Seq1.ret]
simp [think, join]
unfold Functor.map
simp [join, cons, append]
rw [ret_bind, drop.aux_none]
rw [← dropn_tail, destruct_dropn _ n, destruct_tail, LawfulMonad.bind_assoc] <;> rfl
rw [nth_tail] <;> infer_instance
rw [← nth_add] <;> infer_instance
simp
simp [ret_mem]
simp
simp [tail.aux] <;> apply lift_rel_destruct h2
rw [← lift_rel.swap] at H <;> exact exists_of_lift_rel_left H h
rw [lift_rel_destruct_iff] <;> simp
rw [lift_rel_destruct_iff] <;> simp
rw [lift_rel_destruct_iff, lift_rel_destruct_iff] <;> simp
rw [lift_rel_destruct_iff, lift_rel_destruct_iff] <;> simp
unfold Equiv <;> simp <;> exact h
unfold Equiv <;> simp <;> apply Equiv.refl
unfold Equiv <;> simp <;> exact h
apply Computation.memRecOn h
· simp
· intro s'
    apply Equiv.trans
    simp [think_equiv]
simp
apply lift_rel_bind _ _ h
intro a b ab
apply Computation.LiftRel.imp _ _ _ (lift_rel_destruct ab)
intro a b
apply lift_rel_o.imp_right
intro s t h
refine' ⟨return s, return t, _, _, _⟩ <;> simp [h]
induction n <;> simp [*, tail_congr]
simp only [productive_iff] <;> exact forall_congr' fun n => terminates_congr <| nth_congr h _
simp
simp [to_list, cons]
simp [to_list, think]
unfold to_list <;> simp <;> rw [to_list'_map] <;> simp <;> rfl
apply Seq.map_nth
simp [head] <;> cases Seq.head s <;> rfl
simp [tail]
apply s.rec_on _ fun x s => _ <;> simp [of_seq]
· rfl
rw [Seq.head_cons, Seq.tail_cons]
rfl
dsimp [drop] <;> rw [dropn_of_seq, tail_of_seq]
dsimp [nth] <;> rw [dropn_of_seq, head_of_seq, Seq.head_dropn]
rw [nth_of_seq] <;> infer_instance
apply Subtype.eq
funext n
dsimp [to_seq]
apply get_eq_of_mem
rw [nth_of_seq]
apply ret_mem
simp [map]
simp [ret]
simp
simp [h]
simp
simp [m]
simp [sS]
cases c.destruct <;> simp
apply S.rec_on _ (fun s S => _) fun S => _ <;> simp
· refine' Or.inr ⟨S, rfl, rfl⟩
apply Computation.LiftRel.imp _ _ _ (lift_rel_destruct h)
intro a b
apply lift_rel_o.imp_right
intro s t
apply Or.inl
rw [eq_of_ret_mem rs2.mem] <;> trivial
rw [en, ek, ek1]
apply lt_of_lt_of_le _ (Nat.le_add_right _ _)
apply Nat.lt_succ_of_le (Nat.le_add_right _ _)
simp at rs5
refine' ⟨some (b, append t' (join T')), _, _⟩
· simp [destruct_join]
              apply mem_bind mT
              simp [destruct_append]
              apply think_mem
              apply mem_bind mt
              apply ret_mem
rw [eq_of_ret_mem rs5.mem]
exact ⟨ab, HU _ _ ⟨s', t', S', T', rfl, rfl, st', ST'⟩⟩
simp
simp
simp
simp <;> exact ⟨h1, s, t, S, rfl, T, rfl, h2, ST⟩
dsimp [destruct_append.aux, Computation.LiftRel]
constructor
· intro
          apply lift_rel_join.lem _ ST fun _ _ => id
· intro b mb
          rw [← lift_rel_o.swap]
          apply lift_rel_join.lem (swap R)
          · rw [← lift_rel.swap R, ← lift_rel.swap]
            apply ST
          · rw [← lift_rel.swap R, ← lift_rel.swap (lift_rel R)]
            exact fun s1 s2 ⟨s, t, S, T, h1, h2, st, ST⟩ => ⟨t, s, T, S, h2, h1, st, ST⟩
          · exact mb
rw [h] <;> apply h2
simp [ret] <;> apply think_equiv
clear h _match
have :
          ∀ s,
            ∃ s' : Wseq α,
              (map ret s).join.destruct = (map ret s').join.destruct ∧ destruct s = s'.destruct :=
          fun s => ⟨s, rfl, rfl⟩
apply s.rec_on _ (fun a s => _) fun s => _ <;> simp [ret, ret_mem, this, Option.exists]
simp
simp
clear _match h h
apply Wseq.recOn s _ (fun a s => _) fun s => _ <;> simp
· apply Wseq.recOn S _ (fun s S => _) fun S => _ <;> simp
        · apply Wseq.recOn T _ (fun s T => _) fun T => _ <;> simp
          · refine' ⟨s, nil, T, _, _⟩ <;> simp
          · refine' ⟨nil, nil, T, _, _⟩ <;> simp
        · exact ⟨s, S, T, rfl, rfl⟩
        · refine' ⟨nil, S, T, _, _⟩ <;> simp
· exact ⟨s, S, T, rfl, rfl⟩
· exact ⟨s, S, T, rfl, rfl⟩
dsimp [bind]
change fun x => ret (f x) with ret ∘ f
rw [map_comp]
apply join_map_ret
simp [bind]
apply Wseq.recOn s _ (fun a s => _) fun s => _ <;> simp
· apply Wseq.recOn S _ (fun s S => _) fun S => _ <;> simp
          · exact ⟨map f s, S, rfl, rfl⟩
          · refine' ⟨nil, S, _, _⟩ <;> simp
· exact ⟨_, _, rfl, rfl⟩
· exact ⟨_, _, rfl, rfl⟩
simp
simp
simp [h1]
simp [h2]
clear _match h h
apply Wseq.recOn s _ (fun a s => _) fun s => _ <;> simp
· apply Wseq.recOn S _ (fun s S => _) fun S => _ <;> simp
        · apply Wseq.recOn SS _ (fun S SS => _) fun SS => _ <;> simp
          · refine' ⟨nil, S, SS, _, _⟩ <;> simp
          · refine' ⟨nil, nil, SS, _, _⟩ <;> simp
        · exact ⟨s, S, SS, rfl, rfl⟩
        · refine' ⟨nil, S, SS, _, _⟩ <;> simp
· exact ⟨s, S, SS, rfl, rfl⟩
· exact ⟨s, S, SS, rfl, rfl⟩
simp [bind]
rw [← map_comp f (map g), map_comp (map g ∘ f) join]
apply join_join
rw [lt_iff_le_not_le, not_le_iff_exists]
refine'
      { toFun := Dlist.ofList
        invFun := Dlist.toList.. } <;>
    simp [Function.RightInverse, left_inverse, to_list_of_list, of_list_to_list]
rw [← funext hC, generate_from_pi_eq h2C]
simp [hs]
simp [hi]
simp [pi_premeasure_pi']
rw [pi', ← MeasurableEquiv.pi_measurable_equiv_tprod_symm_apply, MeasurableEquiv.map_apply,
      MeasurableEquiv.pi_measurable_equiv_tprod_symm_apply, elim_preimage_pi, tprod_tprod _ μ, ←
      List.prod_to_finset, sorted_univ_to_finset] <;>
    exact sorted_univ_nodup ι
exact this _
    clear hs s
    rw [outer_measure.le_pi]
    intro s hs
    simp_rw [to_outer_measure_apply]
    exact (pi'_pi μ s).le
simp only [measure_to_measurable]
intro i s hs
rw [← hC]
exact measurable_set_generate_from hs
rw [← pi_univ, pi_pi μ]
rw [ball_pi _ hr, pi_pi]
rw [closed_ball_pi _ hr, pi_pi]
rw [← pi_univ_Iic]
exact pi_Iio_ae_eq_pi_Iic
rw [← pi_univ_Ici]
exact pi_Ioi_ae_eq_pi_Ici
rw [← pi_univ_Icc]
exact pi_Ioo_ae_eq_pi_Icc
rw [← pi_univ_Icc]
exact pi_Ioc_ae_eq_pi_Icc
rw [← pi_univ_Icc]
exact pi_Ico_ae_eq_pi_Icc
rfl
rfl
refine' ⟨MeasurableEquiv.measurable _, (measure.prod_eq fun s t hs ht => _).symm⟩
rw [MeasurableEquiv.map_apply, MeasurableEquiv.pi_fin_two_apply, Fin.preimage_apply_01_prod,
    measure.pi_pi, Fin.prod_univ_two]
rfl
refine' top_le_iff.1 fun s hs => bUnion_of_singleton s ▸ _
apply MeasurableSet.bUnion s.to_countable
intro x hx
apply MeasurableSet.ofCompl
apply generate_measurable.basic
exact is_closed_singleton.is_open_compl
rw [hs] <;> exact generate_open.basic _ hu
infer_instance
rw [hα.1, Subtype.measurableSpace, ← borel_comap]
rfl
rw [borel_comap]
exact comap_mono h.1
rw [‹BorelSpace γ›.measurable_eq]
exact measurableGenerateFrom hf
apply measurableOfIsOpen
intro s hs
rw [← MeasurableSet.compl_iff, ← preimage_compl]
apply hf
rw [is_closed_compl_iff]
exact hs
rw [nhds, infi_subtype']
refine' @Filter.infiIsMeasurablyGenerated _ _ _ _ fun i => _
exact i.2.2.MeasurableSet.principalIsMeasurablyGenerated
rw [funext fun a => @eq_generate_from_countable_basis (π a) _ _, pi_generate_from_eq]
rw [← Ici_inter_Iic, nhds_within_inter]
infer_instance
simp
simp
refine' @ext_of_Ico_finite α
refine' @ext_of_Ico' α
refine' ⟨fun U hUo hUne => _⟩
rw [measure.map_apply hf.measurable hUo.measurable_set]
exact (hUo.preimage hf).measure_ne_zero μ (hf_surj.nonempty_preimage.mpr hUne)
have : ‹∀ i, MeasurableSpace (π i)› = fun i => borel (π i) :=
    funext fun i => BorelSpace.measurable_eq
rw [this]
exact supr_le fun i => comap_le_iff_le_map.2 <| (continuous_apply i).borelMeasurable
rw [‹BorelSpace α›.measurable_eq, ‹BorelSpace β›.measurable_eq]
refine' sup_le _ _
· exact comap_le_iff_le_map.mpr continuous_fst.borel_measurable
· exact comap_le_iff_le_map.mpr continuous_snd.borel_measurable
exact ⟨fun y => g this.some, measurableConst, this.some_spec⟩
exact ⟨fun y => g this.some, measurableConst, this.some_spec⟩
rw [union_diff_cancel interior_subset]
rw [union_diff_cancel (singleton_subset_iff.2 x₀s)]
rw [closure_eq_Inter_cthickening]
exact
      tendsto_measure_bInter_gt (fun r hr => is_closed_cthickening.measurable_set)
        (fun i j ipos ij => cthickening_mono ij _) hs
simp
simp
refine' ⟨measurable_of_measurable_nnreal_nnreal _ _ _⟩
· simp only [← Ennreal.coe_mul, measurable_mul.coe_nnreal_ennreal]
· simp only [Ennreal.top_mul, Ennreal.coe_eq_zero]
    exact measurable_const.piecewise (measurable_set_singleton _) measurableConst
· simp only [Ennreal.mul_top, Ennreal.coe_eq_zero]
    exact measurable_const.piecewise (measurable_set_singleton _) measurableConst
apply measurable_of_measurable_nnreal_nnreal <;>
      simp [← WithTop.coe_sub, continuous_sub.measurable.coe_nnreal_ennreal]
simp
rw [← hC, ← hD, generate_from_prod_eq h2C h2D]
simp
rw [tendsto_pi_nhds]
intro x
rw [← uncurry_curry f] at hf
exact hf.integral_prod_right
rw [measure_to_measurable, measure_to_measurable]
rw [set_lintegral_const, mul_comm]
constructor
rw [← univ_prod_univ, prod_prod]
exact mul_lt_top (measure_lt_top _ _).Ne (measure_lt_top _ _).Ne
rw [← univ_prod_univ, prod_prod, measure_univ, measure_univ, mul_one]
refine' ⟨measurableFst, absolutely_continuous.mk fun s hs h2s => _⟩
rw [map_apply measurableFst hs, ← prod_univ, prod_prod, h2s, zero_mul]
refine' ⟨measurableSnd, absolutely_continuous.mk fun s hs h2s => _⟩
rw [map_apply measurableSnd hs, ← univ_prod, prod_prod, h2s, mul_zero]
rw [← prod_swap, map_apply measurableSwap hs]
simp only [prod_apply (measurableSwap hs)]
rfl
refine' prod_eq fun s' t' hs' ht' => _
rw [restrict_apply (hs'.prod ht'), prod_inter_prod, prod_prod, restrict_apply hs',
    restrict_apply ht']
rw [prod_dirac, map_dirac measurableProdMkRight]
rw [measure.prod]
exact bind_zero_left _
simp [measure.prod]
simp only [measure.map_zero]
rw [← prod_swap] at hf
exact hf.comp_measurable measurableSwap
rw [← prod_swap] at hf
exact hf.comp_measurable measurableSwap
rw [← prod_swap] at hf
rw [← lintegral_map' hf measurable_swap.ae_measurable, prod_swap]
simp [lintegral_prod _ (hf.fst.mul hg.snd), lintegral_lintegral_mul hf hg]
rw [← and_congr_right_iff, and_iff_right_of_imp h1]
simp [integrable, h1f, has_finite_integral_prod_iff', h1f.norm.integral_prod_right',
    h1f.prod_mk_left]
rw [← prod_swap] at hf
rw [← integral_map measurable_swap.ae_measurable hf, prod_swap]
simp only [← measure.prod_restrict s t, integrable_on] at hf⊢
exact integral_prod f hf
simp only [← measure.prod_restrict s t, integrable_on, integral_prod_mul]
rw [analytic_set]
exact Or.inl rfl
infer_instance
infer_instance
infer_instance
infer_instance
rw [range_comp, gs]
apply is_closed_Inter
intro n
exact
      is_closed_eq ((f_cont n).comp (continuous_apply n)) ((f_cont i₀).comp (continuous_apply i₀))
intro n
rw [← mem_range, f_range n]
exact mem_Inter.1 hy n
apply mem_Inter.2 fun n => _
simp [hx]
revert s
apply MeasurableSet.inductionOnOpen
· exact fun u hu => hu.IsClopenable
· exact fun u hu h'u => h'u.compl
· exact fun f f_disj f_meas hf => is_clopenable.Union hf
intro s
apply MeasurableSet.is_clopenable
exact hf (hb.is_open s.2).MeasurableSet
simp [hfg]
simp only [p, iterate_succ']
  -- check that at the `n`-th step we deal with cylinders of length `n`
apply hFx (p n) m
rw [pn_fst]
exact hmn
apply hFy (p n) m
rw [pn_fst]
exact hmn
apply t2_separation
exact disjoint_iff_forall_ne.1 h _ (mem_range_self _) _ (mem_range_self _)
apply Metric.mem_nhds_iff.1
exact hf.continuous_at.preimage_mem_nhds (u_open.mem_nhds xu)
apply Metric.mem_nhds_iff.1
exact hg.continuous_at.preimage_mem_nhds (v_open.mem_nhds yv)
refine' ⟨u, _, _, u_open.measurable_set⟩
· rw [image_subset_iff]
      apply subset.trans _ hεx
      intro z hz
      rw [mem_cylinder_iff_dist_le] at hz
      exact hz.trans_lt (hn.trans_le (min_le_left _ _))
· refine' Disjoint.mono_left _ huv.symm
      change g
simp
simp
intro p
apply
      analytic_set.measurably_separable ((hb.is_open p.1.1.2).analytic_set_image f_cont)
        ((hb.is_open p.1.2.2).analytic_set_image f_cont)
exact Disjoint.image p.2 (f_inj.inj_on univ) (subset_univ _) (subset_univ _)
intro b
refine' is_closed_closure.measurable_set.inter _
refine' MeasurableSet.inter fun s => _
exact MeasurableSet.inter fun hs => (q_meas _).diff (q_meas _)
intro n
refine' MeasurableSet.union fun s => _
exact MeasurableSet.union fun hs => E_meas _
apply hb.mem_nhds_iff.1
exact ball_mem_nhds _ (half_pos (u_pos n))
intro n
rw [nonempty_iff_ne_empty]
intro hn
have := (s n).2
rw [hn] at this
exact b_nonempty this
    -- choose a point `y n ∈ s n`.
intro m n
rw [← not_disjoint_iff_nonempty_inter]
rw [← this]
exact mem_range_self _
    -- assume for a contradiction that `f z ≠ x`.
apply Metric.mem_nhds_iff.1
exact f_cont.continuous_at.preimage_mem_nhds (v_open.mem_nhds fzv)
rw [image_subset_iff]
apply subset.trans _ hδ
intro a ha
calc
        dist a z ≤ dist a (y n) + dist (y n) z := dist_triangle _ _ _
        _ ≤ u n + dist (y n) z :=
          add_le_add_right ((dist_le_diam_of_mem (hs n).1 ha (hy n)).trans (hs n).2) _
        _ < δ := hn
        
    -- as `x` belongs to the closure of `f '' (s n)`, it belongs to the closure of `v`.
constructor
rfl
constructor
rfl
constructor
rfl
constructor
rfl
cases nonempty_encodable (PLift ι)
rw [← Union_plift_down, ← Encodable.Union_decode₂]
exact ‹MeasurableSpace α›.measurableSetUnion _ (MeasurableSet.bUnionDecode₂ fun _ => h _)
rw [sUnion_eq_bUnion]
exact MeasurableSet.bUnion hs h
rw [compl_Inter]
exact MeasurableSet.union fun b => (h b).compl
rw [compl_Inter₂]
exact MeasurableSet.bUnion hs fun b hb => (h b hb).compl
rw [sInter_eq_bInter]
exact MeasurableSet.bInter hs h
rw [union_eq_Union]
exact MeasurableSet.union (Bool.forall_bool.2 ⟨h₂, h₁⟩)
rw [inter_eq_compl_compl_union_compl]
exact (h₁.compl.union h₂.compl).compl
have : s₁ = s₂ := funext fun x => propext <| h x
subst this
rw [← bUnion_of_singleton s]
exact MeasurableSet.bUnion hs fun b hb => measurable_set_singleton b
refine' le_antisymm _ (generate_from_mono (Set.subset_insert _ _))
rw [generate_from_le_iff]
intro t ht
cases ht
· rw [ht]
    exact MeasurableSet.univ
· exact measurable_set_generate_from ht
refine' le_antisymm _ (generate_from_mono (Set.subset_insert _ _))
rw [generate_from_le_iff]
intro t ht
cases ht
· rw [ht]
    exact @MeasurableSet.empty _ (generate_from S)
· exact measurable_set_generate_from ht
rw [eq_bot_iff, generate_from_le_iff]
simp
rw [eq_bot_iff, generate_from_le_iff]
simp
simp (config := { contextual := true }) [or_imp]
simp (config := { contextual := true })
simp
rw [infi, measurable_set_Inf, forall_range_iff]
simp only [supr, measurable_set_Sup, exists_range_iff]
rw [singular_part, rn_deriv, dif_pos h, dif_pos h]
exact Classical.choose_spec h.lebesgue_decomposition
rw [← set_lintegral_univ]
exact lintegral_rn_deriv_lt_top_of_measure_ne_top _ (measure_lt_top _ _).Ne
rw [compl_inter]
refine' nonpos_iff_eq_zero.1 (le_trans (measure_union_le _ _) _)
rw [hT₃, hS₃, add_zero]
exact le_rfl
refine' with_density_absolutely_continuous ν _ _
rw [← nonpos_iff_eq_zero]
exact hνinter ▸ measure_mono (inter_subset_right _ _)
refine' with_density_absolutely_continuous ν _ _
rw [← nonpos_iff_eq_zero]
exact hνinter ▸ measure_mono (inter_subset_right _ _)
rw [← nonpos_iff_eq_zero]
exact hS₂ ▸ measure_mono ((inter_subset_right _ _).trans (inter_subset_left _ _))
rw [← nonpos_iff_eq_zero]
exact hT₂ ▸ measure_mono ((inter_subset_right _ _).trans (inter_subset_right _ _))
refine' (eq_singular_part measurableZero mutually_singular.zero_left _).symm
rw [zero_add, with_density_zero]
rw [zero_add]
rw [compl_inter]
refine' nonpos_iff_eq_zero.1 (le_trans (measure_union_le _ _) _)
rw [hT₃, hS₃, add_zero]
exact le_rfl
rw [← nonpos_iff_eq_zero]
exact hS₂ ▸ measure_mono ((inter_subset_right _ _).trans (inter_subset_left _ _))
rw [← nonpos_iff_eq_zero]
exact hT₂ ▸ measure_mono ((inter_subset_right _ _).trans (inter_subset_right _ _))
rw [← nonpos_iff_eq_zero]
exact with_density_absolutely_continuous ν f hνinter ▸ measure_mono (inter_subset_right _ _)
rw [← nonpos_iff_eq_zero]
exact
      with_density_absolutely_continuous ν (μ.rn_deriv ν) hνinter ▸
        measure_mono (inter_subset_right _ _)
rw [eq_with_density_rn_deriv hf hs hadd]
rw [zero_add]
rw [← with_density_indicator_one hs]
exact rn_deriv_with_density _ (measurable_one.indicator hs)
intro
exact exists_compl_positive_negative _
intro n
exact restrict_le_restrict_subset _ _ (hf₁ n).compl (hf₃ n) (Inter_subset _ _)
rw [_root_.inv_pos]
exact hb
rw [← Nnreal.coe_lt_coe, ← mul_lt_mul_right hb₁, Nnreal.coe_mul, mul_assoc, ←
          Nnreal.coe_inv, ← Nnreal.coe_mul, _root_.mul_inv_cancel, ← Nnreal.coe_mul, mul_one,
          Nnreal.coe_inv]
· exact hn
· exact Ne.symm (ne_of_lt hb)
simp
simp
simp
refine' is_finite_measure_with_density _
have hle' := hle univ MeasurableSet.univ
rw [with_density_apply _ MeasurableSet.univ, measure.restrict_univ] at hle'
exact ne_top_of_le_ne_top (measure_ne_top _ _) hle'
rfl
simp only [lintegral_add_left measurableConst, lintegral_add_left hξm,
            set_lintegral_const, add_assoc, lintegral_inter_add_diff _ _ hE₁, Pi.add_apply,
            lintegral_indicator _ hE₁, restrict_apply hE₁]
rw [inter_comm, add_comm]
rw [restrict_apply MeasurableSet.univ, univ_inter]
exact S.finite _
rw [hμn, ← restrict_Union h₂ S.set_mem, S.spanning, restrict_univ]
rw [hνn, ← restrict_Union h₃ T.set_mem, T.spanning, restrict_univ]
    -- As `S` is finite with respect to both `μ` and `ν`, it is clear that `μn n` and `νn n` are
    -- finite measures for all `n : ℕ`. Thus, we may apply the finite Lebesgue decomposition theorem
    -- to `μn n` and `νn n`. We define `ξ` as the sum of the singular part of the Lebesgue
    -- decompositions of `μn n` and `νn n`, and `f` as the sum of the Radon-Nikodym derviatives of
    -- `μn n` and `νn n` restricted on `S n`
intro i
rw [sum_apply _ ((S.set_mem i).inter (hA₁ i)), tsum_eq_single i]
· intro j hij
              rw [hμn, ← nonpos_iff_eq_zero]
              refine' le_trans ((singular_part_le _ _) _ ((S.set_mem i).inter (hA₁ i))) (le_of_eq _)
              rw [restrict_apply ((S.set_mem i).inter (hA₁ i)), inter_comm, ← inter_assoc]
              have : Disjoint (S.set j) (S.set i) := h₂ hij
              rw [disjoint_iff_inter_eq_empty] at this
              rw [this, empty_inter, measure_empty]
· infer_instance
rw [to_jordan_decomposition_neg, jordan_decomposition.neg_pos_part]
infer_instance
rw [to_jordan_decomposition_neg, jordan_decomposition.neg_neg_part]
infer_instance
rw [to_jordan_decomposition_smul, jordan_decomposition.smul_pos_part]
infer_instance
rw [to_jordan_decomposition_smul, jordan_decomposition.smul_neg_part]
infer_instance
rw [to_jordan_decomposition_smul_real, jordan_decomposition.real_smul_pos_part_neg _ _ hr]
infer_instance
rw [to_jordan_decomposition_smul_real, jordan_decomposition.real_smul_neg_part_neg _ _ hr]
infer_instance
refine' jordan_decomposition.to_signed_measure_injective _
rw [to_signed_measure_to_jordan_decomposition]
rfl
rw [mutually_singular_ennreal_iff, singular_part_total_variation]
change _
rw [mutually_singular_ennreal_iff, total_variation_mutually_singular_iff] at htμ
change
    _
have htμ' := htμ
rw [mutually_singular_ennreal_iff] at htμ
change _
have htμ' := htμ
rw [mutually_singular_ennreal_iff, total_variation_mutually_singular_iff] at htμ
change
    _
refine' (eq_singular_part 0 0 vector_measure.mutually_singular.zero_left _).symm
rw [zero_add, with_densityᵥ_zero]
refine' to_signed_measure_congr _
rw [to_jordan_decomposition_neg, jordan_decomposition.neg_pos_part]
refine' to_signed_measure_congr _
rw [to_jordan_decomposition_neg, jordan_decomposition.neg_neg_part]
refine'
    (eq_singular_part _ (s.rn_deriv μ + t.rn_deriv μ)
        ((mutually_singular_singular_part s μ).add_left (mutually_singular_singular_part t μ))
        _).symm
erw [with_densityᵥ_add (integrable_rn_deriv s μ) (integrable_rn_deriv t μ)]
rw [add_assoc, add_comm (t.singular_part μ), add_assoc, add_comm _ (t.singular_part μ),
    singular_part_add_with_density_rn_deriv_eq, ← add_assoc,
    singular_part_add_with_density_rn_deriv_eq]
rw [sub_eq_add_neg, sub_eq_add_neg, singular_part_add, singular_part_neg]
refine'
    integrable.ae_eq_of_with_densityᵥ_eq (integrable_rn_deriv _ _) (integrable_rn_deriv _ _).neg _
rw [with_densityᵥ_neg, ← add_right_inj ((-s).singularPart μ),
    singular_part_add_with_density_rn_deriv_eq, singular_part_neg, ← neg_add,
    singular_part_add_with_density_rn_deriv_eq]
refine'
    integrable.ae_eq_of_with_densityᵥ_eq (integrable_rn_deriv _ _)
      ((integrable_rn_deriv _ _).add (integrable_rn_deriv _ _)) _
rw [← add_right_inj ((s + t).singularPart μ), singular_part_add_with_density_rn_deriv_eq,
    with_densityᵥ_add (integrable_rn_deriv _ _) (integrable_rn_deriv _ _), singular_part_add,
    add_assoc, add_comm (t.singular_part μ), add_assoc, add_comm _ (t.singular_part μ),
    singular_part_add_with_density_rn_deriv_eq, ← add_assoc,
    singular_part_add_with_density_rn_deriv_eq]
rw [sub_eq_add_neg] at hst
rw [sub_eq_add_neg, sub_eq_add_neg]
exact ae_eq_trans (rn_deriv_add _ _ _) (Filter.EventuallyEq.add (ae_eq_refl _) (rn_deriv_neg _ _))
rw [← mem_ℒp_one_iff_integrable, ← mem_ℒp_re_im_iff]
exact
    ⟨mem_ℒp_one_iff_integrable.2 (signed_measure.integrable_rn_deriv _ _),
      mem_ℒp_one_iff_integrable.2 (signed_measure.integrable_rn_deriv _ _)⟩
rw [measure.coe_zero, Pi.zero_apply, ← this]
exact measure_mono (Set.subset_univ _)
rw [← hadd]
rw [find_exists_one_div_lt, dif_pos hi] at hm
exact Nat.find_min _ hm
rw [some_exists_one_div_lt, dif_pos hi]
exact Classical.choose_spec (find_exists_one_div_lt_spec hi)
rw [restrict_nonpos_seq]
cases n <;>
    · rw [restrict_nonpos_seq]
      exact some_exists_one_div_lt_subset'
rw [restrict_nonpos_seq_succ]
apply some_exists_one_div_lt_lt hn
simp [Nat.lt_succ_iff]
rw [Nat.lt_succ_iff]
cases n <;>
    · rw [restrict_nonpos_seq]
      exact some_exists_one_div_lt_measurable_set
intro l hl
refine' le_of_lt (measure_of_restrict_nonpos_seq h _ _)
refine' mt (restrict_le_zero_subset _ (hi₁.diff _) (Set.Subset.refl _)) (Nat.find_min hn hl)
exact
        MeasurableSet.union fun _ =>
          MeasurableSet.union fun _ => restrict_nonpos_seq_measurable_set _
rw [sub_neg]
exact lt_of_lt_of_le hi₂ this
rw [h₁]
apply le_add_of_nonneg_right
exact tsum_nonneg fun n => le_of_lt (measure_of_restrict_nonpos_seq h _ (hn n))
have : Summable fun l => s (restrict_nonpos_seq s i l) :=
      HasSum.summable
        (s.m_Union (fun _ => restrict_nonpos_seq_measurable_set _) restrict_nonpos_seq_disjoint)
refine'
      summable_of_nonneg_of_le (fun n => _) (fun n => _)
        (Summable.comp_injective this Nat.succ_injective)
· exact le_of_lt Nat.one_div_pos_of_nat
· exact le_of_lt (restrict_nonpos_seq_lt n (hn' n))
simp only [one_div] at h₃'
exact Summable.tendsto_top_of_pos h₃' fun n => Nat.cast_add_one_pos (bdd n)
intro n
refine' le_trans _ (le_of_lt (h_lt _))
rw [hA, ← Set.diff_union_of_subset (Set.subset_Union _ n),
      of_union (Disjoint.comm.1 Set.disjoint_diff) _ (hmeas n)]
· refine' add_le_of_nonpos_left _
      have : s ≤[A] 0 := restrict_le_restrict_Union _ _ hmeas hr
      refine' nonpos_of_restrict_le_zero _ (restrict_le_zero_subset _ _ (Set.diff_subset _ _) this)
      exact MeasurableSet.union hmeas
· infer_instance
· exact (MeasurableSet.union hmeas).diff (hmeas n)
apply le_antisymm
· refine' le_of_tendsto_of_tendsto tendsto_const_nhds hf₂ (eventually_of_forall fun n => _)
      rw [← (hB n).2, hA, ← Set.diff_union_of_subset (Set.subset_Union _ n),
        of_union (Disjoint.comm.1 Set.disjoint_diff) _ (hB₁ n)]
      · refine' add_le_of_nonpos_left _
        have : s ≤[A] 0 :=
          restrict_le_restrict_Union _ _ hB₁ fun m =>
            let ⟨_, h⟩ := (hB m).1
            h
        refine'
          nonpos_of_restrict_le_zero _ (restrict_le_zero_subset _ _ (Set.diff_subset _ _) this)
        exact MeasurableSet.union hB₁
      · infer_instance
      · exact (MeasurableSet.union hB₁).diff (hB₁ n)
· exact cInf_le bdd_below_measure_of_negatives ⟨A, ⟨hA₁, hA₂⟩, rfl⟩
rw [dif_pos (Nnreal.coe_nonneg r), Real.to_nnreal_coe]
rw [real_smul_def, ← smul_pos_part, dif_pos hr]
rw [real_smul_def, ← smul_neg_part, dif_pos hr]
rw [real_smul_def, ← smul_neg_part, dif_neg (not_le.2 hr), neg_pos_part]
rw [real_smul_def, ← smul_pos_part, dif_neg (not_le.2 hr), neg_neg_part]
rw [← hw₁, ← of_union Set.disjoint_diff hv (hw.diff hv), Set.union_diff_self,
      Set.union_eq_self_of_subset_left hwt]
infer_instance
rw [← s.neg_le_neg_iff _ hu, neg_zero] at hsu
have := subset_positive_null_set hu hv hw hsu
simp only [Pi.neg_apply, neg_eq_zero, coe_neg] at this
exact this hw₁ hw₂ hwt
rw [← s.neg_le_neg_iff _ hu, neg_zero] at hsu
rw [← s.neg_le_neg_iff _ hv, neg_zero] at hsv
have := of_diff_eq_zero_of_symm_diff_eq_zero_positive hu hv hsu hsv
simp only [Pi.neg_apply, neg_eq_zero, coe_neg] at this
exact this hs
refine'
      subset_positive_null_set (hu.union hv) ((hw.inter hu).symmDiff (hw.inter hv))
        (hu.symm_diff hv) (restrict_le_restrict_union _ _ hu hsu hv hsv) hs symm_diff_subset_union _
rw [← inter_symm_diff_distrib_left]
exact inter_subset_right _ _
rw [← s.neg_le_neg_iff _ hu, neg_zero] at hsu
rw [← s.neg_le_neg_iff _ hv, neg_zero] at hsv
have := of_inter_eq_of_symm_diff_eq_zero_positive hu hv hw hsu hsv
simp only [Pi.neg_apply, neg_inj, neg_eq_zero, coe_neg] at this
exact this hs
exact sub_right_inj.mp this
    convert hj'
simp
apply to_signed_measure_injective
simp [to_signed_measure_zero]
apply to_signed_measure_injective
simp [to_signed_measure_neg]
apply to_signed_measure_injective
simp [to_signed_measure_smul]
rw [neg_smul, neg_neg]
rw [neg_smul, neg_neg]
rw [h, to_jordan_decomposition_to_signed_measure]
simp [total_variation, to_jordan_decomposition_zero]
simp [total_variation, to_jordan_decomposition_neg, add_comm]
rw [total_variation, measure.coe_add, Pi.add_apply, add_eq_zero_iff] at hs
rw [← to_signed_measure_to_jordan_decomposition s, to_signed_measure, vector_measure.coe_sub,
    Pi.sub_apply, measure.to_signed_measure_apply, measure.to_signed_measure_apply]
let d : Set α → ℝ := fun s => ((μ s).toNnreal : ℝ) - (ν s).toNnreal
let c : Set ℝ := d
change _ - _ = _
rw [measure_empty, measure_empty, sub_self]
intro s t hs ht
simp only [d]
rw [← measure_inter_add_diff s ht, ← measure_inter_add_diff s ht,
      Ennreal.to_nnreal_add (hμ _) (hμ _), Ennreal.to_nnreal_add (hν _) (hν _), Nnreal.coe_add,
      Nnreal.coe_add]
simp only [sub_eq_add_neg, neg_add]
ac_rfl
intro s hm
refine' tendsto.sub _ _ <;>
      refine' Nnreal.tendsto_coe.2 <| (Ennreal.tendsto_to_nnreal _).comp <| tendsto_measure_Union hm
exact hμ _
exact hν _
intro n m
simp only [f, Finset.inf_eq_infi]
exact MeasurableSet.bInter (to_countable _) fun i _ => he₁ _
intro a b c d hab hcd
dsimp only [f]
rw [Finset.inf_eq_infi, Finset.inf_eq_infi]
exact bInter_subset_bInter_left (Finset.Ico_subset_Ico hab <| Nat.succ_le_succ hcd)
intro n m hnm
have : n ≤ m + 1 := le_of_lt (Nat.succ_le_succ hnm)
simp only [f]
rw [Nat.Ico_succ_right_eq_insert_Ico this, Finset.inf_insert, Set.inter_comm]
rfl
simp only [sub_eq_add_neg] <;> ac_rfl
rw [f_succ _ _ hmn, d_split (f m n) (e (n + 1)) (hf _ _) (he₁ _), add_assoc]
refine' d_Union _ _
exact fun n m hnm =>
        subset_Inter fun i => subset.trans (Inter_subset (f n) i) <| f_subset_f hnm <| le_rfl
refine' d_Inter _ _ _
· intro n
        exact hf _ _
· intro n m hnm
        exact f_subset_f le_rfl hnm
rw [d_split _ _ hs ht, inter_eq_self_of_subset_right hts]
rw [d_split _ _ (hs.union ht) ht, union_diff_right, union_inter_cancel_right,
              diff_eq_self.2]
exact fun a ⟨hat, has⟩ => hts hat has
rw [add_zero] <;> exact d_le_γ _ (hs.union ht)
          
    rw [← to_nnreal_μ, ← to_nnreal_ν, Ennreal.coe_le_coe, ← Nnreal.coe_le_coe]
    simpa only [d, sub_le_iff_le_add, zero_add]
rw [preimage_Union]
exact m.measurable_set_Union _ hf
simp [hs']
intro t ht
rw [piecewise_preimage]
exact hs.ite (hf ht) (hg ht)
simp [← inter_union_distrib_left]
intro s hs
rw [← bUnion_preimage_singleton]
refine' MeasurableSet.union fun y => MeasurableSet.union fun hy => _
refine' measurableToNat fun x => _
rw [preimage_find_eq_disjointed]
exact MeasurableSet.disjointed hm _
rw [← Eq, Subtype.image_preimage_coe]
exact hu.inter hs
simp only [← preimage_comp, (· ∘ ·), Subtype.coe_mk, hf hs.1]
rw [MeasurableSpace.comap_le_iff_le_map, MeasurableSpace.map_comp]
exact hf₁
rw [MeasurableSpace.comap_le_iff_le_map, MeasurableSpace.map_comp]
exact hf₂
intro x
simp only [iff_false_iff, not_forall, not_not_mem]
exact ⟨n, hx⟩
apply measurablePiLambda
intro x
rw [pi_def]
exact MeasurableSet.bInter hs fun i hi => measurablePiApply _ (ht i hi)
apply measurable_pi_iff.2 fun j => _
refine' measurable_prod.2 _
constructor <;>
    · apply measurable_pi_iff.2 fun j => _
      simp only [pi_equiv_pi_subtype_prod_apply, measurablePiApply]
contradiction
rw [this]
exact MeasurableSet.empty
contradiction
rw [this]
exact MeasurableSet.empty
rw [← image_univ]
exact measurable_set.univ.inl_image
rw [← image_univ]
exact measurableSetInrImage MeasurableSet.univ
rw [← image_univ]
exact hf.measurable_set_image' MeasurableSet.univ
rw [← image_preimage_eq_inter_range, hf.measurable_set_image]
rw [image_eq_preimage, measurableSetPreimage]
subst h
subst hi
exact measurableId
subst h
subst hi
exact measurableId
rw [image_univ]
rw [image_univ]
cases p
contradiction
cases p
contradiction
simp [measurable_pi_iff, i.forall_iff_succ_above, measurableFst,
      (measurablePiApply _).comp measurableSnd]
rw [coe_of_injective_symm]
exact hf.measurable_range_splitting
simp only [Filter.limsup_eq_infi_supr_of_nat', supr_eq_Union, infi_eq_Inter]
exact MeasurableSet.inter fun n => MeasurableSet.union fun m => hs <| m + n
simp only [Filter.liminf_eq_supr_infi_of_nat', supr_eq_Union, infi_eq_Inter]
exact MeasurableSet.union fun n => MeasurableSet.inter fun m => hs <| m + n
simp only [div_eq_mul_inv]
exact measurable_fst.mul measurable_snd.inv
apply this.comp measurableSwap
    refine' measurableFromProdCountable fun n => _
    induction' n
apply this.comp measurableSwap
    refine' measurableFromProdCountable fun n => _
    induction' n
have h_mul : MeasurableEmbedding fun x => g * x := (MeasurableEquiv.mulLeft g).MeasurableEmbedding
rw [← h_mul.integral_map, map_mul_left_eq_self]
have h_mul : MeasurableEmbedding fun x => x * g :=
    (MeasurableEquiv.mulRight g).MeasurableEmbedding
rw [← h_mul.integral_map, map_mul_right_eq_self]
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
rw [mem_smul_set_iff_inv_smul_mem] at hxa hxb
exact hab (inv_injective <| (h_exists x).unique hxa hxb)
rw [← Union_smul_eq_set_of_exists]
exact null_measurable_set.Union h_meas
simp [hab]
simp [mul_assoc]
simp [mul_assoc]
simp [smul_smul, mul_assoc]
rw [←
    restrict_Union_ae (h.ae_disjoint.mono fun i j h => hν h) fun g =>
      (h.null_measurable_set_smul g).monoAc hν,
    restrict_congr_set (hν h.Union_smul_ae_eq), restrict_univ]
rw [← lintegral_sum_measure, h.sum_restrict_of_ac hν]
simp only [h.restrict_restrict, inter_comm]
simp only [smul_set_inter, inv_smul_smul]
simp [measure_eq_tsum h, ht, hts]
simp only [hf, inter_comm]
simp only [← ht.restrict_restrict,
        ht.sum_restrict_of_ac restrict_le_self.absolutely_continuous]
simp only [smul_set_inter, inter_comm, smul_inv_smul, ae_strongly_measurable_sum_measure_iff]
simp only [inv_inv]
simp only [← ae_strongly_measurable_sum_measure_iff, ← hs.restrict_restrict,
        hs.sum_restrict_of_ac restrict_le_self.absolutely_continuous]
dsimp only [has_finite_integral]
rw [hs.set_lintegral_eq ht]
intro g x
rw [hf]
rw [restrict_congr_set (hac ht.Union_smul_ae_eq), restrict_univ]
simp only [ht.restrict_restrict, inter_comm]
simp only [smul_set_inter, inv_smul_smul]
simp only [hf, hs.restrict_restrict]
rw [restrict_congr_set (hac hs.Union_smul_ae_eq), restrict_univ]
exact
        (ae_eq_of_subset_of_measure_ge ball_subset_closed_ball this measurableSetBall
            (measure_ne_top _ _)).symm
rw [add_comm g x, ← singleton_add_ball _ x g, add_ball, thickening_singleton]
show _ = addOrderOf u
rw [add_order_eq_card_zmultiples', Nat.card_eq_fintype_card]
rfl
rw [measure.map_smul, map_mul_left_eq_self]
rw [measure.map_smul, map_mul_right_eq_self]
rw [map_mul_left_eq_self μ g]
rw [map_mul_right_eq_self μ g]
rw [← inv_apply, inv_eq_self]
constructor
· intro h
    rw [← μ.inv_inv]
    exact measure.regular.inv
· intro h
    exact measure.regular.inv
simp [measure_preimage_mul, h]
simp only [measure_preimage_mul, Finset.sum_const, nsmul_eq_mul]
simp only [IH, measure_smul, add_mul, Nat.cast_add, algebraMap.coe_one, one_mul]
intro K hK
rw [map_apply hf.measurable hK.measurable_set]
exact IsCompact.measure_lt_top ((⟨⟨f, hf⟩, h_prop⟩ : CocompactMap G H).is_compact_preimage hK)
infer_instance
refine' ⟨fun hs => _, (quasi_measure_preserving_inv μ).preimage_null⟩
rw [← inv_inv s]
exact (quasi_measure_preserving_inv μ).preimage_null hs
simp only [measure_inv_null μ, measure_preimage_mul]
refine' absolutely_continuous.mk fun s hs => _
rw [map_apply (measurable_mul_const g) hs, measure_mul_right_null]
exact id
refine' (ae_measure_preimage_mul_right_lt_top ν ν sm h3s).filter_mono _
refine' (absolutely_continuous_of_is_mul_left_invariant μ ν _).ae_le
refine' mt _ h2s
intro hν
rw [hν, measure.coe_zero, Pi.zero_apply]
have h1 :=
    measure_lintegral_div_measure ν ν hs h2s h3s (t.indicator fun x => 1)
      (measurable_const.indicator ht)
have h2 :=
    measure_lintegral_div_measure μ ν hs h2s h3s (t.indicator fun x => 1)
      (measurable_const.indicator ht)
rw [lintegral_indicator _ ht, set_lintegral_one] at h1 h2
rw [← h1, mul_left_comm, h2]
apply measure_preserving_prod_mul_swap_right μ ν
apply measure_preserving_prod_div_swap μ ν
rw [← μ.inv_inv]
exact
    (quasi_measure_preserving_inv μ.inv).mono (inv_absolutely_continuous μ.inv)
      (absolutely_continuous_inv μ.inv)
rw [← μ.inv_inv]
exact
    (quasi_measure_preserving_div_left μ.inv g).mono (inv_absolutely_continuous μ.inv)
      (absolutely_continuous_inv μ.inv)
refine' quasi_measure_preserving.prod_of_left measurable_div (eventually_of_forall fun y => _)
exact (measure_preserving_div_right μ y).QuasiMeasurePreserving
refine' ⟨measurable_mul_const g, absolutely_continuous.mk fun s hs => _⟩
rw [map_apply (measurable_mul_const g) hs, measure_mul_right_null]
exact id
rw [← preimage_smul_inv]
exact measurable_const_smul _ hs
rw [← preimage_smul_inv₀ ha]
exact measurable_const_smul _ hs
rw [ ← preimage_smul_inv ]
rw [← not_iff_not, ← Ne.def, ← pos_iff_ne_zero,
    measure_pos_iff_nonempty_of_smul_invariant G hμ hU, nonempty_iff_ne_empty]
infer_instance
infer_instance
infer_instance
intro p q
intro i
exact MeasurableSet.bInter (s_count.mono (inter_subset_left _ _)) fun b hb => (huv i b).1
apply measurableInfi
exact fun i => Measurable.piecewise (u'_meas i) measurableConst measurableConst
refine' (measure_Union_le _).trans _
apply Ennreal.tsum_le_tsum fun p => _
apply measure_Union_le _
exact (s_count.mono (inter_subset_left _ _)).to_subtype
apply Ennreal.tsum_le_tsum fun p => _
refine' Ennreal.tsum_le_tsum fun q => measure_mono _
exact inter_subset_inter_left _ (bInter_subset_of_mem q.2)
simp only [tsum_zero]
simp only [← dist_eq_norm]
exact (continuous_id.dist continuous_const).Measurable.comp fmeas
simp
simp
simp
simp
rw [← mem_ℒp_one_iff_integrable] at hf hi₀⊢
exact mem_ℒp_approx_on fmeas hf h₀ hi₀ n
simp
simp
simp
simp [hp_pos_real]
simp [hp_pos_real]
simp
rw [support_eq]
refine' (measure_bUnion_finset_le _ _).trans_lt (ennreal.sum_lt_top_iff.mpr fun y hy => _)
rw [Finset.mem_filter] at hy
exact hf y hy.2
simp only [← hs, ← ht, ae_eq_fun.mk_add_mk, AddSubgroup.coe_add, ae_eq_fun.mk_eq_mk,
        simple_func.coe_add]
simp only [← hs, ae_eq_fun.neg_mk, simple_func.coe_neg, ae_eq_fun.mk_eq_mk,
        AddSubgroup.coe_neg]
rw [AddSubgroup.coe_norm, AddSubgroup.coe_norm, coe_smul, norm_smul]
simp only [sub_eq_add_neg, ← to_Lp_neg, ← to_Lp_add]
rfl
rw [← ae_eq_fun.mk_eq_mk]
exact Classical.choose_spec (to_Lp f hfi).2
rw [← to_Lp_to_simple_func f]
apply this
simp
simp
rw [← Subtype.coe_le_coe, ← Lp.coe_fn_le, coe_fn_coe_base', coe_fn_coe_base' g]
rw [ae_eq_set]
simp only [true_and_iff, measure_empty, eq_self_iff_true, diff_univ, ← compl_eq_univ_diff]
exact hs_zero
simp only [union_singleton, mem_inter_iff, mem_insert_iff, eq_self_iff_true, true_or_iff,
      mem_set_of_eq, le_refl, and_self_iff]
apply is_separable.separable_space
apply is_separable.mono _ (Set.inter_subset_left _ _)
exact
      (Lp.strongly_measurable (g : Lp G p μ)).is_separable_range.union
        (finite_singleton _).IsSeparable
simp
refine' fun f => (Lp.simple_func.dense_range hp_ne_top).induction_on f h_closed _
refine' Lp.simple_func.induction (lt_of_lt_of_le Ennreal.zero_lt_one _i.elim).ne' hp_ne_top _ _
· exact fun c s => h_ind c
· exact fun f g hf hg => h_add hf hg
refine' simple_func.induction _ _
· intro c s hs h
simp
intro f
exact
      h_ae (Lp.simple_func.to_simple_func_eq_to_fun f) (Lp.simple_func.mem_ℒp f)
        (this (Lp.simple_func.to_simple_func f) (Lp.simple_func.mem_ℒp f))
rw [← mem_ℒp_one_iff_integrable]
exact Lp.simple_func.mem_ℒp f
simp only [← mem_ℒp_one_iff_integrable] at *
exact mem_ℒp.induction one_ne_top P h_ind h_add h_closed h_ae
simp only [aeSeq, hx, if_true]
simp only [ae_seq_eq_mk_of_mem_ae_seq_set hf hx i, mk_eq_fun_of_mem_ae_seq_set hf hx i]
have h_eq : (fun n => f n x) = fun n => aeSeq hf p n x :=
    funext fun n => (ae_seq_eq_fun_of_mem_ae_seq_set hf hx n).symm
rw [h_eq]
exact prop_of_mem_ae_seq_set hf hx
simp only [aeSeq, hx, if_true]
intro x hx
congr
exact funext fun i => ae_seq_eq_fun_of_mem_ae_seq_set hf hx i
exact MeasureTheory.MeasureSpace.volume
rw [← @restrict_univ _ _ μ, ← Union_compact_covering, ae_strongly_measurable_Union_iff]
exact fun i => (hf <| is_compact_compact_covering X i).AeStronglyMeasurable
simp only [integrable_on_const, hK.measure_lt_top, or_true_iff]
intro s hs
rw [Int.preimage_fract]
exact MeasurableSet.union fun z => measurable_id.sub_const _ (hs.inter measurableSetIco)
simp only [Int.image_fract, sub_eq_add_neg, image_add_right']
exact MeasurableSet.union fun m => (measurable_add_const _ hs).inter measurableSetIco
cases eq_or_ne
cases eq_or_ne
simp [Set.mem_setOf_eq, eventually_le, ae_iff]
refine' (ess_sup_mono_ae hf).trans _
rw [ess_sup_congr_ae hg.ae_eq_mk, ess_sup_map_measure_of_measurable hg.measurable_mk hf]
refine' ess_sup_congr_ae _
have h_eq := ae_of_ae_map hf hg.ae_eq_mk
rw [← eventually_eq] at h_eq
exact h_eq.symm
simp only [nearest_pt_ind, coe_piecewise, Set.piecewise]
congr
simp
dsimp only [approx_on, coe_comp, (· ∘ ·)]
exact edist_nearest_pt_le _ _ ((nearest_pt_ind_le _ _ _).trans h)
simp only [ha, norm_pos_iff, Ne.def, not_false_iff]
simp only [h, sub_zero, ContinuousLinearMap.map_sub]
rw [(hs x).2, IsROrC.norm_coe_norm]
apply Set.eq_empty_iff_forall_not_mem.2 fun x hx => _
exact (lt_irrefl _ (lt_of_lt_of_le hx (h (f x)))).elim
simp only [lintegral_const, Set.univ_inter, MeasurableSet.univ, measure.restrict_apply]
rw [add_zero]
exact h s s_meas s_lt_top
simp only [lintegral_const, Set.univ_inter, MeasurableSet.univ, measure.restrict_apply]
simp only [lt_top_iff_ne_top, s_lt_top.ne, and_false_iff, Ennreal.coe_ne_top,
            WithTop.mul_eq_top_iff, Ne.def, not_false_iff, false_and_iff, or_self_iff]
have : tendsto (fun n => g x + u n) at_top (𝓝 (g x + (0 : ℝ≥0))) :=
        tendsto_const_nhds.add (Ennreal.tendsto_coe.2 u_lim)
simp at this
exact eventually_le_of_tendsto_lt hx this
simp only [Ennreal.coe_nat]
exact Ennreal.tendsto_nat_nhds_top
simp only [μs, tsum_zero]
refine'
        set_integral_mono_ae_restrict hf.integrable_on (integrable_on_const.mpr (Or.inr mus)) _
rw [eventually_le, ae_restrict_iff hs]
exact eventually_of_forall fun x hxs => hxs
intro s hs h's
rw [set_integral_congr_ae hs (hf_ae.mono fun x hx hxs => hx.symm)]
exact hf_zero s hs h's
rw [← eventually_sub_nonneg]
refine' ae_nonneg_of_forall_set_integral_nonneg (hg.sub hf) fun s hs => _
rw [integral_sub' hg.integrable_on hf.integrable_on, sub_nonneg]
exact hf_le s hs
apply ae_of_forall_measure_lt_top_ae_restrict
intro t t_meas t_lt_top
apply ae_nonneg_restrict_of_forall_set_integral_nonneg_inter (hf_int_finite t t_meas t_lt_top)
intro s s_meas hs
exact
    hf_zero _ (s_meas.inter t_meas)
      (lt_of_le_of_lt (measure_mono (Set.inter_subset_right _ _)) t_lt_top)
intro s hs hμs
rw [integral_sub' (hf_int_finite s hs hμs) (hg_int_finite s hs hμs)]
exact sub_eq_zero.mpr (hfg_zero s hs hμs)
intro s hs hμs
rw [integral_sub' (hf_int_finite s hs hμs) (hg_int_finite s hs hμs),
      sub_eq_zero.mpr (hfg_eq s hs hμs)]
intro s hs hμs
rw [integral_sub' (hf_int_finite s hs hμs) (hg_int_finite s hs hμs),
      sub_eq_zero.mpr (hfg_eq s hs hμs)]
rw [eventually_eq, ae_restrict_iff' (MeasurableSet.compl (hm _ ht_meas))]
exact eventually_of_forall htf_zero
intro s hs hμs
rw [integral_sub' hf.integrable_on hg.integrable_on]
exact sub_eq_zero.mpr (hfg s hs hμs)
rw [← Subtype.coe_le_coe, ← ae_eq_fun.coe_fn_le, ← coe_fn_coe_base, ← coe_fn_coe_base]
rw [mem_Lp_iff_mem_ℒp] at *
exact (mem_ℒp_congr_ae (ae_eq_fun.coe_fn_sup _ _)).mpr (hf.sup hg)
rw [mem_Lp_iff_mem_ℒp] at *
exact (mem_ℒp_congr_ae (ae_eq_fun.coe_fn_inf _ _)).mpr (hf.inf hg)
rw [← Ennreal.of_real_add hε2.le hε2.le, add_halves]
rw [sub_eq_add_neg]
exact hf.add hg.neg hp hf_meas fun i => (hg_meas i).neg
simp
intro M
apply hf.1.indicator
apply
      strongly_measurable.measurable_set_le strongly_measurable_const
        hmeas.nnnorm.measurable.coe_nnreal_real.strongly_measurable
rw [mem_ℒp_one_iff_integrable] at hf
exact hf.norm.2
intro x hx
rw [mem_set_of_eq, ← Ennreal.to_real_lt_to_real hbdd.ne ennreal.coe_lt_top.ne,
        Ennreal.coe_to_real, coe_nnnorm]
refine' lt_of_lt_of_le _ hx
rw [Ennreal.to_real_lt_to_real hbdd.ne]
· exact Ennreal.lt_add_right hbdd.ne one_ne_zero
· exact (Ennreal.add_lt_top.2 ⟨hbdd, Ennreal.one_lt_top⟩).Ne
rw [coe_nnnorm, coe_nnnorm, Real.norm_rpow_of_nonneg (norm_nonneg _), norm_norm, ←
      Real.rpow_le_rpow_iff hM' (Real.rpow_nonneg_of_nonneg (norm_nonneg _) _)
        (one_div_pos.2 <| Ennreal.to_real_pos hp_ne_zero hp_ne_top),
      ← Real.rpow_mul (norm_nonneg _),
      mul_one_div_cancel (Ennreal.to_real_pos hp_ne_zero hp_ne_top).Ne.symm, Real.rpow_one]
trace
      "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in filter_upwards #[[], [], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
exact fun x => (hf x).le
intro ε hε
intro x
rw [Ennreal.tendsto_at_top_zero]
intro ε hε
simp [h]
simp [hμ]
refine' one_div_nonneg.2 _
rw [← Ennreal.zero_to_real, Ennreal.to_real_le_to_real Ennreal.zero_ne_top hp']
exact le_trans ennreal.zero_lt_one.le hp
refine' hsnorm₁ n t htm (le_trans ht₁ _)
rw [Ennreal.of_real_le_of_real_iff hδ₁.le]
exact min_le_left _ _
refine' hsnorm₂ t htm (le_trans ht₁ _)
rw [Ennreal.of_real_le_of_real_iff hδ₂.le]
exact min_le_right _ _
rw [ae_all_iff]
exact fun n => (hf n).ae_eq_mk
have hpzero := (lt_of_lt_of_le Ennreal.zero_lt_one hp).Ne.symm
refine' add_le_add_left _ _
rw [← Ennreal.of_real_coe_nnreal, ← Ennreal.of_real_mul (Nnreal.coe_nonneg _), ← div_div,
        mul_div_cancel' _ (Nnreal.coe_pos.2 hCpos).Ne.symm]
exact le_rfl
rw [← Ennreal.of_real_add (half_pos hε).le (half_pos hε).le, add_halves]
exact le_rfl
cases nonempty_fintype ι
refine' ⟨fun n => (hf n).1, unif_integrable_finite μ hp_one hp_top hf, _⟩
rw [Ennreal.coe_to_nnreal]
exact
        Ennreal.add_ne_top.2
          ⟨Ennreal.mul_ne_top Ennreal.coe_ne_top
              (Ennreal.rpow_ne_top_of_nonneg (inv_nonneg.2 Ennreal.to_real_nonneg)
                (measure_lt_top _ _).Ne),
            Ennreal.one_ne_top⟩
simp [zero_le_one]
simp
simp
simp
simp
rw [← integral_inner (integrable_on_Lp_of_measure_ne_top f fact_one_le_two_ennreal.elim hμs),
    L2.inner_indicator_const_Lp_eq_set_integral_inner]
rw [L2.inner_indicator_const_Lp_eq_inner_set_integral 𝕜 hs hμs (1 : 𝕜) f]
simp
rw [← restrict_trim hm _ hs]
exact restrict.sigma_finite _ s
rw [Set.indicator_self_add_compl s f]
refine' (condexp_indicator_aux hs.compl _).symm.trans _
· exact indicator_ae_eq_restrict_compl (hm _ hs.compl)
· rw [Set.indicator_indicator, Set.inter_self]
rw [Set.indicator_indicator, Set.inter_compl_self, Set.indicator_empty', add_zero]
refine' (condexp_indicator_aux hs _).symm.trans _
· exact indicator_ae_eq_restrict_compl (hm _ hs)
· rw [Set.indicator_indicator, Set.inter_self]
rw [← restrict_trim hm _ hs_m]
infer_instance
rw [integral_indicator (hm _ hs_m), measure.restrict_restrict (hm _ hs_m),
          measure.restrict_restrict (hm _ ht), Set.inter_comm]
rw [integral_indicator (hm _ hs_m), measure.restrict_restrict (hm _ hs_m),
          measure.restrict_restrict (hm _ ht), Set.inter_comm]
rw [this, add_zero, measure.restrict_restrict (hm _ hs_m)]
exact this.ne rfl
refine' condexp_congr_ae (eventually_eq.mul _ eventually_eq.rfl)
rw [h_add]
rw [add_mul]
exact condexp_add (hg.simple_func_mul' hm _) (hg.simple_func_mul' hm _)
rw [h_add, add_mul]
simp only [hμ, ae_ne_bot, Ne.def, not_false_iff]
refine' condexp_of_strongly_measurable hm (hf.mul strongly_measurable_condexp) _
exact integrable_condexp.bdd_mul' (hf.mono hm).AeStronglyMeasurable hf_bound
rw [h_univ]
exact Set.mem_univ _
refine' eventually_eq.trans _ (this.trans _)
·
      exact
        condexp_congr_ae ((indicator_ae_eq_restrict (hm _ (h_meas n))).symm.mul eventually_eq.rfl)
· exact (indicator_ae_eq_restrict (hm _ (h_meas n))).mul eventually_eq.rfl
constructor
rw [measure.restrict_apply_univ]
exact h_finite n
rw [Function.comp_apply, hx]
rw [← AddSubgroup.mem_carrier, Lp_meas_subgroup, Set.mem_setOf_eq]
rw [← SetLike.mem_coe, ← Submodule.mem_carrier, Lp_meas, Set.mem_setOf_eq]
rw [snorm_trim hm hg]
exact snorm_congr_ae hfg.symm
let hf_mem_ℒp := mem_ℒp_of_mem_ℒp_trim hm (Lp.mem_ℒp f)
rw [mem_Lp_meas_subgroup_iff_ae_strongly_measurable']
refine' ae_strongly_measurable'.congr _ (mem_ℒp.coe_fn_to_Lp hf_mem_ℒp).symm
refine' ae_strongly_measurable'_of_ae_strongly_measurable'_trim hm _
exact Lp.ae_strongly_measurable f
rfl
rfl
rw [sub_eq_add_neg, sub_eq_add_neg, Lp_meas_subgroup_to_Lp_trim_add,
    Lp_meas_subgroup_to_Lp_trim_neg]
rw [Lp.norm_def, snorm_trim hm (Lp.strongly_measurable _),
    snorm_congr_ae (Lp_meas_subgroup_to_Lp_trim_ae_eq hm _), Lp_meas_subgroup_coe, ← Lp.norm_def]
congr
rw [dist_eq_norm, ← Lp_meas_subgroup_to_Lp_trim_sub, Lp_meas_subgroup_to_Lp_trim_norm_map,
      dist_eq_norm]
rw [(Lp_meas_subgroup_to_Lp_trim_iso F p μ hm.elim).complete_space_iff]
infer_instance
rw [(Lp_meas_subgroup_to_Lp_meas_iso F 𝕜 p μ).symm.complete_space_iff]
infer_instance
simp only [LinearIsometryEquiv.symm_apply_apply]
rw [this]
rw [← Set.diff_inter_self_eq_diff, Set.inter_comm]
refine' ((ae_eq_refl s_f).diff h_inter_empty).trans _
rw [Set.diff_empty]
rw [← Set.diff_inter_self_eq_diff]
refine' ((ae_eq_refl s_g).diff h_inter_empty).trans _
rw [Set.diff_empty]
simp only [coe_fn_coe_base', Subtype.coe_mk]
intro s hs hμs
rw [integral_congr_ae (ae_restrict_of_ae (Lp.coe_fn_sub f g))]
rw [integral_sub' (hf_int_finite s hs hμs) (hg_int_finite s hs hμs)]
exact sub_eq_zero.mpr (hfg s hs hμs)
intro s hs hμs
rw [integrable_on, integrable_congr (ae_restrict_of_ae (Lp.coe_fn_sub f g))]
exact (hf_int_finite s hs hμs).sub (hg_int_finite s hs hμs)
intro s hs hμs
rw [trim_measurable_set_eq hm hs] at hμs
rw [integrable_on, restrict_trim hm _ hs]
refine' integrable.trim hm _ hfm.strongly_measurable_mk
exact integrable.congr (hf_int_finite s hs hμs) (ae_restrict_of_ae hfm.ae_eq_mk)
intro s hs hμs
rw [trim_measurable_set_eq hm hs] at hμs
rw [integrable_on, restrict_trim hm _ hs]
refine' integrable.trim hm _ hgm.strongly_measurable_mk
exact integrable.congr (hg_int_finite s hs hμs) (ae_restrict_of_ae hgm.ae_eq_mk)
intro s hs hμs
rw [trim_measurable_set_eq hm hs] at hμs
rw [restrict_trim hm _ hs, ← integral_trim hm hfm.strongly_measurable_mk, ←
      integral_trim hm hgm.strongly_measurable_mk,
      integral_congr_ae (ae_restrict_of_ae hfm.ae_eq_mk.symm),
      integral_congr_ae (ae_restrict_of_ae hgm.ae_eq_mk.symm)]
exact hfg_eq s hs hμs
rw [← of_real_integral_norm_eq_lintegral_nnnorm hfi, ←
    of_real_integral_norm_eq_lintegral_nnnorm hgi, Ennreal.of_real_le_of_real_iff]
· exact integral_norm_le_of_forall_fin_meas_integral_eq hm hf hfi hg hgi hgf hs hμs
· exact integral_nonneg fun x => norm_nonneg _
rw [Lp_meas_coe, ← Ennreal.to_real_le_to_real (Lp.snorm_ne_top _) (Lp.snorm_ne_top _), ←
    Lp.norm_def, ← Lp.norm_def, Submodule.norm_coe]
exact norm_condexp_L2_le hm f
rw [Lp.norm_def, Lp.norm_def, ← Lp_meas_coe]
refine' (Ennreal.to_real_le_to_real _ (Lp.snorm_ne_top _)).mpr (snorm_condexp_L2_le hm f)
exact Lp.snorm_ne_top _
rfl
rw [L2.inner_indicator_const_Lp_one (hm s hs) hμs]
congr
refine' hg_eq_restrict.mono fun x hx => _
dsimp only
rw [hx]
refine' mem_ℒp.const_inner _ _
rw [Lp_meas_coe]
exact Lp.mem_ℒp _
rw [indicator_const_Lp_eq_to_span_singleton_comp_Lp hs hμs x]
have h_comp :=
    condexp_L2_comp_continuous_linear_map ℝ 𝕜 hm (to_span_singleton ℝ x)
      (indicator_const_Lp 2 hs hμs (1 : ℝ))
rw [← Lp_meas_coe] at h_comp
refine' h_comp.trans _
exact (to_span_singleton ℝ x).coe_fn_comp_Lp _
rw [ha]
refine' ae_strongly_measurable'.congr this _
refine' eventually_eq.trans _ (coe_fn_comp_LpL _ _).symm
rw [Lp_meas_coe]
rw [condexp_ind_smul, condexp_ind_smul, to_span_singleton_smul',
    (to_span_singleton ℝ x).smul_comp_LpL_apply c
      ↑(condexp_L2 ℝ hm (indicator_const_Lp 2 hs hμs (1 : ℝ)))]
rw [ha]
rw [condexp_ind_smul, indicator_const_empty]
simp only [coe_fn_coe_base, Submodule.coe_zero, ContinuousLinearMap.map_zero]
rw [smul_eq_mul, mul_one]
rw [set_integral_condexp_L2_indicator hs ht hμs hμt]
refine' lintegral_congr_ae _
refine' (condexp_ind_L1_fin_ae_eq_condexp_ind_smul hm hs hμs x).mono fun z hz => _
dsimp only
rw [hz]
simp only [condexp_ind_L1, And.intro hs hμs, dif_pos, Ne.def, not_false_iff, and_self_iff]
simp only [condexp_ind_L1, hμs, eq_self_iff_true, not_true, Ne.def, dif_neg, not_false_iff,
    and_false_iff]
simp only [condexp_ind_L1, hs, dif_neg, not_false_iff, false_and_iff]
refine' eventually_eq.trans _ (condexp_ind_L1_fin_ae_eq_condexp_ind_smul hm hs hμs x)
simp [condexp_ind, condexp_ind_L1, hs, hμs]
simp
rw [← coe_fn_le]
refine' eventually_le.trans_eq _ (condexp_ind_ae_eq_condexp_ind_smul hm hs hμs x).symm
exact (coe_fn_zero E 1 μ).trans_le (condexp_ind_smul_nonneg hs hμs x hx)
rw [Lp.simple_func.coe_indicator_const]
exact condexp_L1_clm_indicator_const_Lp hs hμs x
rfl
simp only [LinearIsometryEquiv.symm_apply_apply]
rw [condexp_L1_eq hfi]
refine' eventually_eq.trans _ (integrable.coe_fn_to_L1 hfi)
rw [condexp_L1_clm_of_ae_strongly_measurable']
exact ae_strongly_measurable'.congr hfm (integrable.coe_fn_to_L1 hfi).symm
rw [condexp, dif_neg hm_not]
rw [condexp, dif_pos hm]
simp only [hμm, Ne.def, true_and_iff]
rw [condexp_of_sigma_finite hm, if_pos hfi, if_pos hf]
infer_instance
rw [condexp_of_sigma_finite hm]
refine' (condexp_ae_eq_condexp_L1 hm f).trans (eventually_of_forall fun x => _)
rw [condexp_L1_eq hf]
rw [condexp_L1_congr_ae hm h]
refine' ((condexp_congr_ae hf.ae_eq_mk).trans _).trans hf.ae_eq_mk.symm
rw [condexp_of_strongly_measurable hm hf.strongly_measurable_mk
      ((integrable_congr hf.ae_eq_mk).mp hfi)]
rw [set_integral_congr_ae (hm s hs) ((condexp_ae_eq_condexp_L1 hm f).mono fun x hx _ => hx)]
exact set_integral_condexp_L1 hf hs
refine'
    ae_eq_of_forall_set_integral_eq_of_sigma_finite' hm hg_int_finite
      (fun s hs hμs => integrable_condexp.integrable_on) (fun s hs hμs => _) hgm
      (strongly_measurable.ae_strongly_measurable' strongly_measurable_condexp)
rw [hg_eq s hs hμs, set_integral_condexp hm hf hs]
refine' (condexp_bot' f).trans _
rw [measure_univ, Ennreal.one_to_real, inv_one, one_smul]
rw [neg_one_smul ℝ f]
rw [tendsto_congr' this]
exact h_tendsto ε hε
refine' fun ε hε => ennreal.tendsto_at_top_zero.mpr fun δ hδ => _
simp only [zero_lt_bit0, pow_pos, zero_lt_one, inv_pos]
rw [seq_tendsto_ae_seq]
cases n
· exact Classical.choose_spec (exists_nat_measure_lt_two_inv hfg 0) k hn
·
    exact
      Classical.choose_spec (exists_nat_measure_lt_two_inv hfg _) _ (le_trans (le_max_left _ _) hn)
refine' strictMono_nat_of_lt_succ fun n => _
rw [seq_tendsto_ae_seq_succ]
exact lt_of_lt_of_le (lt_add_one <| seq_tendsto_ae_seq hfg n) (le_max_right _ _)
refine' measure_limsup_eq_zero (ne_of_lt <| lt_of_le_of_lt (Ennreal.tsum_le_tsum hμS_le) _)
simp only [Ennreal.tsum_geometric, Ennreal.one_sub_inv_two, inv_inv]
decide
rw [h]
apply (ae_strongly_measurable.ae_eq_mk _).symm.trans
exact @Quotient.mk_out' _ (μ.ae_eq_setoid β) (⟨f, hf⟩ : { f // ae_strongly_measurable f μ })
rw [← comp_mk g hg f f.ae_strongly_measurable, mk_coe_fn]
rw [comp_eq_mk]
apply coe_fn_mk
rw [← comp_measurable_mk g hg f f.ae_strongly_measurable, mk_coe_fn]
rw [comp_measurable_eq_mk]
apply coe_fn_mk
simp only [← pair_mk_mk, mk_coe_fn]
rw [pair_eq_mk]
apply coe_fn_mk
rw [comp₂_eq_pair, pair_eq_mk, comp_mk] <;> rfl
rw [comp₂_eq_mk]
apply coe_fn_mk
rw [comp₂_measurable_eq_pair, pair_eq_mk, comp_measurable_mk] <;> rfl
rw [comp₂_measurable_eq_mk]
apply coe_fn_mk
rw [← mk_to_germ, mk_coe_fn]
simp
simp
simp
simp
rw [← lift_rel_mk_mk, mk_coe_fn, mk_coe_fn]
rw [← lintegral_mk, mk_coe_fn]
simp [lintegral_add_left' hf.ae_measurable]
rw [AddSubgroup.eq_top_iff']
refine' Lp.induction hp _ _ _ _
· exact this
· exact fun f g hf hg hfg' => AddSubgroup.add_mem _
· exact AddSubgroup.is_closed_topological_closure _
  -- Let `s` be a finite-measure measurable set, let's approximate `c` times its indicator function
rw [Real.norm_eq_abs, abs_of_nonneg (hg_range x).1]
intro x
exact congr_arg coe this
exact congr_arg coe this
simp [snorm, hp_ne_zero, hp_ne_top]
rw [snorm_eq_snorm' hp_ne_zero hp_ne_top, snorm']
simp [snorm]
exact MeasureTheory.MeasureSpace.volume
rw [snorm', ← Ennreal.rpow_mul, one_div, inv_mul_cancel, Ennreal.rpow_one]
exact (ne_of_lt hq0_lt).symm
rw [lintegral_rpow_nnnorm_eq_rpow_snorm' hq0_lt]
exact Ennreal.rpow_lt_top_of_nonneg (le_of_lt hq0_lt) (ne_of_lt hfq)
rw [snorm', div_zero, Ennreal.rpow_zero]
simp [snorm]
simp [mem_ℒp, snorm_exponent_zero]
simp [snorm', hp0_lt]
rw [snorm_zero]
exact Ennreal.coe_lt_top
simp [snorm', hq_pos]
simp [snorm']
simp [snorm', hq_neg]
simp [snorm_ess_sup]
simp [hq_pos.le]
rw [snorm_ess_sup, ess_sup_const _ hμ]
simp [snorm'_const c hq_pos, measure_univ]
simp [snorm_eq_snorm' h0 h_top, snorm'_const, Ennreal.to_real_pos h0 h_top]
have hp : 0 < p.to_real := Ennreal.to_real_pos hp_ne_zero hp_ne_top
refine' ⟨ae_strongly_measurable_const, _⟩
refine' ⟨ae_strongly_measurable_const, _⟩
rw [← snorm_const_lt_top_iff hp_ne_zero hp_ne_top]
exact ⟨fun h => h.2, fun h => ⟨ae_strongly_measurable_const, h⟩⟩
rw [snorm']
refine' Ennreal.rpow_le_rpow _ (one_div_nonneg.2 hq)
refine' lintegral_mono_ae (h.mono fun x hx => _)
exact Ennreal.rpow_le_rpow (Ennreal.coe_le_coe.2 hx) hq
simp only [← coe_nnnorm, Nnreal.coe_eq] at hx
simp [hx]
rw [Real.norm_eq_abs, abs_eq_self.mpr hC]
simp [snorm']
simp only [mem_ℒp, snorm_congr_ae hfg, ae_strongly_measurable_congr hfg]
rw [snorm_exponent_top]
exact snorm_ess_sup_lt_top_of_ae_bound hfC
simp [hq]
rw [snorm', lintegral_smul_measure, Ennreal.mul_rpow_of_nonneg, snorm']
simp [hp]
rw [@snorm_smul_measure_of_ne_top _ _ _ μ _ 1 (@Ennreal.coe_ne_top 1) f c]
simp
refine' ⟨hf.1.mono' (measure.absolutely_continuous_of_le_smul hμ'_le), _⟩
refine' (snorm_mono_measure f hμ'_le).trans_lt _
simp
rw [← snorm_norm]
exact h.2
rw [snorm'_congr_ae hf_zero, snorm'_zero hq0_lt]
rw [snorm'_congr_ae hf_zero, snorm'_zero' hq0_ne hμ]
simp [eventually_eq, snorm_ess_sup]
simp [le_trans zero_le_one hq1]
rw [sub_eq_add_neg]
    -- We cannot use snorm_add_le on f and (-g) because we don't have `ae_measurable (-g) μ`, since
        -- we don't suppose `[borel_space E]`.
refine' snorm_mono_real fun x => _
rw [norm_norm]
exact norm_add_le _ _
rw [← snorm_norm f, ← snorm_norm g]
simp [hq_pos.le]
simp [hq_pos.le]
simp [hq_pos.le]
rw [← Ennreal.zero_to_real, @Ennreal.to_real_lt_to_real 0 p Ennreal.coe_ne_top hp_top]
exact (zero_le p).lt_of_ne h0.symm
simp [mem_ℒp, snorm_map_measure hg hf, hg.comp_ae_measurable hf, hg]
rw [snorm_congr_ae hf.ae_eq_mk, snorm_congr_ae (ae_eq_of_ae_eq_trim hf.ae_eq_mk)]
exact snorm_trim hm hf.strongly_measurable_mk
simp [snorm']
simp [hf.right]
have hq0_lt : 0 < q := lt_of_lt_of_le hp0_lt hpq
simp
simp [hpqr]
refine' lintegral_mono_ae _
have h_nnnorm_le_snorm_ess_sup := coe_nnnorm_ae_le_snorm_ess_sup f μ
refine' h_nnnorm_le_snorm_ess_sup.mono fun x hx => Ennreal.rpow_le_rpow hx (le_of_lt hq_pos)
simp [hq_pos.le]
simp [hq_pos.le]
simp [measure_univ]
simp [measure_univ]
rw [snorm_eq_lintegral_rpow_nnnorm hp_ne_zero hp_ne_top]
exact
    Ennreal.rpow_le_rpow (mul_meas_ge_le_lintegral₀ (hf.ennnorm.pow_const _) ε)
      (one_div_nonneg.2 Ennreal.to_real_nonneg)
refine' one_div_mul_cancel _
rw [Ne, Ennreal.to_real_eq_zero_iff]
exact not_or_of_not hp_ne_zero hp_ne_top
simp [hp_pos.le]
rw [sub_eq_add_neg]
exact hf.add hg.neg
simp [hq_pos.le]
rw [smul_eq_mul, mul_comm]
rfl
simp [snorm_congr_ae this.1, snorm_congr_ae this.2]
simp only [mem_ℒp, hf, true_and_iff]
apply lt_of_le_of_lt (snorm_le_mul_snorm_of_ae_le_mul hfg p)
simp [lt_top_iff_ne_top, hg.snorm_ne_top]
intro x
rw [one_mul]
exact IsROrC.norm_re_le_norm (f x)
intro x
rw [one_mul]
exact IsROrC.norm_im_le_norm (f x)
rw [mul_comm]
exact norm_inner_le_norm _ _
simp [hfp.2]
exact MeasureTheory.MeasureSpace.volume
simp [snorm_congr_ae ae_eq_fun.coe_fn_zero, snorm_zero]
simp [snorm_congr_ae (ae_eq_fun.coe_fn_add _ _),
      snorm_add_lt_top ⟨f.ae_strongly_measurable, hf⟩ ⟨g.ae_strongly_measurable, hg⟩]
simp [to_Lp, hfg]
simp [to_Lp]
cases f
cases g
simp only [Subtype.mk_eq_mk]
exact ae_eq_fun.ext h
rw [h]
simp [mem_Lp_iff_snorm_lt_top, mem_ℒp, f.strongly_measurable.ae_strongly_measurable]
cases f
simp [mem_ℒp.to_Lp]
rw [norm_def, snorm_congr_ae (mem_ℒp.coe_fn_to_Lp hf)]
rw [edist_def]
exact snorm_congr_ae (hf.coe_fn_to_Lp.sub hg.coe_fn_to_Lp)
simp [hf]
rw [norm_def, norm_def, snorm_congr_ae (coe_fn_neg _), snorm_neg]
rw [norm_def, norm_def, Ennreal.to_real_le_to_real (snorm_ne_top _) (snorm_ne_top _)]
exact snorm_mono_ae h
exact Ennreal.to_real_le_coe_of_le_coe this
  convert snorm_le_of_ae_bound hfC
  rw [← coe_measure_univ_nnreal μ, Ennreal.coe_rpow_of_ne_zero (measure_univ_nnreal_pos hμ).ne',
    Ennreal.coe_mul]
  congr
  rw [max_eq_left hC]
simp
rw [edist_def, dist_def, ← snorm_congr_ae (coe_fn_sub _ _),
        Ennreal.of_real_to_real (snorm_ne_top (f - g))]
rw [mem_Lp_iff_snorm_lt_top, snorm_congr_ae (ae_eq_fun.coe_fn_smul _ _), snorm_const_smul,
    Ennreal.mul_lt_top_iff]
exact Or.inl ⟨Ennreal.coe_lt_top, f.prop⟩
rw [norm_def, snorm_congr_ae (coe_fn_smul _ _), snorm_const_smul c, Ennreal.to_real_mul,
    Ennreal.coe_to_real, coe_nnnorm, norm_def]
simp [norm_const_smul]
refine' ess_sup_mono_ae (eventually_of_forall fun x => _)
rw [Ennreal.coe_le_coe, nnnorm_indicator_eq_indicator_nnnorm]
exact Set.indicator_le_self s _ x
refine' le_antisymm (snorm_ess_sup_indicator_const_le s c) _
exact Nnreal.coe_mono this
  rw [nnnorm_indicator_eq_indicator_nnnorm]
  exact s.indicator_le_self _ x
rw [this]
simp [Ennreal.to_real_pos hp_zero hp_top]
simp [mem_ℒp, ae_strongly_measurable_indicator_iff hs, snorm_indicator_eq_snorm_restrict hs]
rw [mem_ℒp_indicator_iff_restrict hs]
rw [Lp.norm_def, snorm_congr_ae indicator_const_Lp_coe_fn,
    snorm_indicator_const hs hp_ne_zero hp_ne_top, Ennreal.to_real_mul, Ennreal.to_real_rpow,
    Ennreal.coe_to_real, coe_nnnorm]
rw [Lp.norm_def, snorm_congr_ae indicator_const_Lp_coe_fn,
    snorm_indicator_const' hs hμs_ne_zero Ennreal.top_ne_zero, Ennreal.top_to_real, div_zero,
    Ennreal.rpow_zero, mul_one, Ennreal.coe_to_real, coe_nnnorm]
simp
refine' ⟨(hf.1.norm.AeMeasurable.pow_const q.to_real).AeStronglyMeasurable, _⟩
apply Filter.eventually_of_forall fun x => _
rw [← dist_zero_right, ← dist_zero_right, ← g0]
apply hg.dist_le_mul
apply Filter.eventually_of_forall fun x => _
rw [← dist_zero_right, ← dist_zero_right, ← g0]
apply hg'.le_mul_dist
exact Lp.mem_Lp_of_ae_le_mul this
simp [dist_eq_norm, norm_comp_Lp_sub_le]
simp [Real.dist_eq, abs_max_sub_max_le_abs]
rw [h, ← max_neg_neg, neg_zero]
have eq : (fun f : lp ℝ p μ => negPart f) = fun f : lp ℝ p μ => posPart (-f) := rfl
rw [Eq]
exact continuous_pos_part.comp continuous_neg
simp [hp_pos]
rw [snorm_exponent_top, snorm_ess_sup]
refine' ess_sup_congr_ae (h_lim.mono fun x hx => _)
rw [tendsto.liminf_eq]
rw [Ennreal.tendsto_coe]
exact (continuous_nnnorm.tendsto (f_lim x)).comp hx
rw [hB1_has.tsum_eq]
exact Ennreal.of_real_lt_top
simp [f_norm_diff]
simp [hp_pos]
simp [hp_pos]
intro g
rw [Ennreal.tsum_eq_liminf_sum_nat, ← liminf_nat_add _ 1]
simp [hp_pos]
refine' ae_lt_top' (AeMeasurable.powConst _ _) h_integral.ne
exact AeMeasurable.ennrealTsum fun n => ((hf (n + 1)).sub (hf n)).ennnorm
simp [hp_pos]
rw [← Ennreal.of_real_le_iff_le_to_real hp_top, Ennreal.of_real_one]
exact hp
simp
refine' Lp.mem_Lp_of_ae_bound
rw [to_Lp_norm_eq_to_Lp_norm_coe]
exact BoundedContinuousFunction.to_Lp_norm_le μ
refine' add_le_add (hδ _) (ContinuousLinearMap.le_op_norm _ _)
rw [inter_comm]
exact inter_subset_inter_right _ (ball_subset_ball hn.le) hy
rw [← add_mul, add_comm]
exact mul_le_mul_of_nonneg_right hε (norm_nonneg _)
      
  -- the sets `M n z` are relatively closed in `s`, as all the conditions defining it are clearly
  -- closed
apply (hf' x xs).ContinuousWithinAt.Tendsto.comp
apply tendsto_nhds_within_of_tendsto_nhds_of_eventually_within _ a_lim
exact eventually_of_forall fun k => (aM k).1
apply tendsto.mono_left _ nhds_within_le_nhds
exact tendsto_measure_cthickening_of_is_compact HC
apply Iio_mem_nhds
exact εpos
simp only [abs_of_nonneg r0, add_haar_smul, image_add_left, abs_pow, singleton_add,
          measure_preimage_add]
rw [add_comm]
exact Ennreal.mul_le_mul le_rfl hε.le
simp [half_pos δpos, half_lt_self δpos]
rw [bUnion_eq_Union] at st
apply measure_mono
rw [← image_Union, ← inter_Union]
exact image_subset _ (subset_inter (subset.refl _) st)
rw [Ennreal.tsum_mul_left]
exact Ennreal.mul_le_mul le_rfl μt
      
  -- taking the limit in `a`, one obtains the conclusion
apply tendsto.mono_left _ nhds_within_le_nhds
apply Ennreal.Tendsto.const_mul (tendsto_const_nhds.add tendsto_id)
simp only [Ennreal.coe_ne_top, Ne.def, or_true_iff, not_false_iff]
simp only [Ennreal.ofReal, abs_inv, Real.to_nnreal_inv, ContinuousLinearEquiv.det_coe_symm,
      ContinuousLinearMap.coe_to_continuous_linear_equiv_of_det_ne_zero, Ennreal.coe_lt_coe] at hm⊢
exact Nnreal.inv_lt_inv mpos.ne' hm
  -- therefore, we may apply `add_haar_image_le_mul_of_det_lt` to `B.symm` and `m⁻¹`.
simp only [ha, add_neg_cancel_left]
simp only [add_sub_cancel'_right]
simp only [ContinuousLinearMap.map_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
congr 1
simp only [ya, add_sub_cancel', sub_sub_sub_cancel_left, ContinuousLinearMap.coe_sub',
          eq_self_iff_true, sub_left_inj, Pi.sub_apply, ContinuousLinearMap.map_smul, smul_sub]
apply add_le_add
· rw [mul_assoc] at I
          exact (mul_le_mul_left rpos).1 I
· apply ContinuousLinearMap.le_op_norm
simp only [Ennreal.ofReal, m, lt_add_iff_pos_right, zero_lt_one, Ennreal.coe_lt_coe]
apply measure_mono
rw [← image_Union, ← inter_Union]
exact image_subset f (subset_inter subset.rfl t_cover)
apply Ennreal.tsum_le_tsum fun n => _
apply (hδ (A n)).2
exact ht n
refine' Ennreal.tsum_le_tsum fun n => Ennreal.mul_le_mul le_rfl _
exact le_trans (measure_mono (inter_subset_left _ _)) (le_of_eq hs)
simp only [tsum_zero, mul_zero]
simp only [Ennreal.ofReal, m, lt_add_iff_pos_right, εpos, Ennreal.coe_lt_coe]
apply measure_mono
rw [← image_Union, ← inter_Union]
exact image_subset f (subset_inter subset.rfl t_cover)
apply Ennreal.tsum_le_tsum fun n => _
apply (hδ (A n)).2
exact ht n
congr
rw [Ennreal.tsum_mul_left]
refine' Ennreal.mul_le_mul le_rfl (Ennreal.tsum_le_tsum fun n => measure_mono _)
exact inter_subset_inter_left _ hs
rw [measure_Union]
· exact PairwiseDisjoint.mono t_disj fun n => inter_subset_right _ _
· intro n
        exact measurable_set_closed_ball.inter (t_meas n)
rw [← inter_Union]
exact Ennreal.mul_le_mul le_rfl (measure_mono (inter_subset_left _ _))
rw [image_Union]
exact measure_Union_le _
simp only [H, tsum_zero, nonpos_iff_eq_zero]
rw [← inter_Union]
exact subset.antisymm (subset_inter subset.rfl t_cover) (inter_subset_left _ _)
apply ennreal.measurable_of_real.comp_ae_measurable
refine' continuous_abs.measurable.comp_ae_measurable _
refine' continuous_linear_map.continuous_det.measurable.comp_ae_measurable _
exact ae_measurable_fderiv_within μ hs hf'
apply measurable_real_to_nnreal.comp_ae_measurable
refine' continuous_abs.measurable.comp_ae_measurable _
refine' continuous_linear_map.continuous_det.measurable.comp_ae_measurable _
exact ae_measurable_fderiv_within μ hs hf'
simp only [Ennreal.ofReal, m, lt_add_iff_pos_right, εpos, Ennreal.coe_lt_coe]
simp only [le_refl, Nnreal.coe_min, min_le_iff, or_true_iff]
apply measure_mono
rw [← image_Union, ← inter_Union]
exact image_subset f (subset_inter subset.rfl t_cover)
apply Ennreal.tsum_le_tsum fun n => _
apply (hδ (A n)).2.2
exact ht n
simp only [lintegral_const, MeasurableSet.univ, measure.restrict_apply, univ_inter]
simp only [Ennreal.of_real_add, abs_nonneg, two_mul, add_assoc, Nnreal.zero_le_coe,
            Ennreal.of_real_coe_nnreal]
rw [← inter_Union]
exact subset.antisymm (subset_inter subset.rfl t_cover) (inter_subset_left _ _)
simp only [lintegral_add_right' _ aeMeasurableConst, set_lintegral_const]
apply tendsto.mono_left _ nhds_within_le_nhds
refine' tendsto_const_nhds.add _
refine' Ennreal.Tendsto.mul_const _ (Or.inr h's)
exact Ennreal.Tendsto.const_mul (Ennreal.tendsto_coe.2 tendsto_id) (Or.inr Ennreal.coe_ne_top)
intro n
apply MeasurableSet.disjointed fun i => _
exact measurable_spanning_sets μ i
rw [← inter_Union, Union_disjointed, Union_spanning_sets, inter_univ]
intro B hB
rw [← Real.dist_eq]
apply (hδ' B _).le
rw [dist_eq_norm]
exact hB.trans_lt (half_lt_self δ'pos)
rw [← inter_Union]
exact subset.antisymm (subset_inter subset.rfl t_cover) (inter_subset_left _ _)
simp only [Ennreal.of_real_add, abs_nonneg, Nnreal.zero_le_coe,
            Ennreal.of_real_coe_nnreal]
simp only [set_lintegral_const, lintegral_add_right _ measurableConst]
refine' Ennreal.tsum_le_tsum fun n => add_le_add_right _ _
exact (hδ (A n)).2.2 _ _ (ht n)
apply tendsto.mono_left _ nhds_within_le_nhds
refine' tendsto_const_nhds.add _
refine' Ennreal.Tendsto.mul_const _ (Or.inr h's)
exact Ennreal.Tendsto.const_mul (Ennreal.tendsto_coe.2 tendsto_id) (Or.inr Ennreal.coe_ne_top)
intro n
apply MeasurableSet.disjointed fun i => _
exact measurable_spanning_sets μ i
rw [← inter_Union, Union_disjointed, Union_spanning_sets, inter_univ]
apply measure.ext fun t ht => _
rw [map_apply h'f ht, with_density_apply _ (h'f ht), measure.restrict_apply ht,
    restrict_restrict (h'f ht),
    lintegral_abs_det_fderiv_eq_add_haar_image μ ((h'f ht).inter hs)
      (fun x hx => (hf' x hx.2).mono (inter_subset_right _ _)) (hf.mono (inter_subset_right _ _)),
    image_preimage_inter]
rw [hF, ← measure.map_map u_meas measurableSubtypeCoe, map_comap_subtype_coe hs,
      restrict_with_density hs]
exact map_with_density_abs_det_fderiv_eq_add_haar μ hs u' (hf.congr uf.symm) u_meas
rw [← restrict_map_with_density_abs_det_fderiv_eq_add_haar μ hs hf' hf,
    (measurable_embedding_of_fderiv_within hs hf' hf).lintegral_map]
have : ∀ x : s, g (s.restrict f x) = (g ∘ f) x := fun x => rfl
simp only [this]
rw [← (MeasurableEmbedding.subtypeCoe hs).lintegral_map, map_comap_subtype_coe hs,
    set_lintegral_with_density_eq_set_lintegral_mul_non_measurable₀ _ _ _ hs]
· rfl
· simp only [eventually_true, Ennreal.of_real_lt_top]
· exact ae_measurable_of_real_abs_det_fderiv_within μ hs hf'
rw [integrable_on, ← restrict_map_with_density_abs_det_fderiv_eq_add_haar μ hs hf' hf,
    (measurable_embedding_of_fderiv_within hs hf' hf).integrable_map_iff]
change integrable ((g ∘ f) ∘ (coe : s → E)) _ ↔ _
rw [← (MeasurableEmbedding.subtypeCoe hs).integrable_map_iff, map_comap_subtype_coe hs]
simp only [Ennreal.ofReal]
rw [restrict_with_density hs, integrable_with_density_iff_integrable_coe_smul₀, integrable_on]
· congr 2
rw [← restrict_map_with_density_abs_det_fderiv_eq_add_haar μ hs hf' hf,
    (measurable_embedding_of_fderiv_within hs hf' hf).integral_map]
have : ∀ x : s, g (s.restrict f x) = (g ∘ f) x := fun x => rfl
simp only [this, Ennreal.ofReal]
rw [← (MeasurableEmbedding.subtypeCoe hs).integral_map, map_comap_subtype_coe hs,
    set_integral_with_density_eq_set_integral_smul₀
      (ae_measurable_to_nnreal_abs_det_fderiv_within μ hs hf') _ hs]
congr
rfl
rw [this]
simp
simp only [edist_eq_coe_nnnorm]
simp only [of_real_norm_eq_coe_nnnorm, edist_eq_coe_nnnorm]
rw [← lintegral_add_left' (hf.edist hh)]
refine' lintegral_mono fun a => _
apply edist_triangle_right
simp
simp only [Pi.neg_apply, nnnorm_neg]
exact MeasureTheory.MeasureSpace.volume
simp only [has_finite_integral, of_real_norm_eq_coe_nnnorm]
simp only [has_finite_integral_iff_norm, edist_dist, dist_zero_right]
rw [has_finite_integral, lintegral_nnnorm_eq_of_ae_nonneg h]
simp [has_finite_integral_iff_norm]
simp [has_finite_integral, lintegral_const, lt_top_iff_ne_top, or_iff_not_imp_left]
simp only [has_finite_integral, lintegral_add_measure] at *
exact add_lt_top.2 ⟨hμ, hν⟩
simp only [has_finite_integral, lintegral_smul_measure] at *
exact mul_lt_top hc h.ne
simp only [has_finite_integral, lintegral_zero_measure, WithTop.zero_lt_top]
simp [has_finite_integral]
intro x
rw [Real.nnnorm_of_nonneg]
refine' is_finite_measure_with_density ((lintegral_mono fun x => _).trans_lt hfi).Ne
exact Real.of_real_le_ennnorm (f x)
have F_le_bound := all_ae_of_real_F_le_bound h_bound
rw [← ae_all_iff] at F_le_bound
apply F_le_bound.mp ((all_ae_tendsto_of_real_norm h_lim).mono _)
intro a tendsto_norm F_le_bound
exact le_of_tendsto' tendsto_norm F_le_bound
rw [← has_finite_integral_iff_of_real]
· exact bound_has_finite_integral
exact (h_bound 0).mono fun a h => le_trans (norm_nonneg _) h
have f_measurable : AeStronglyMeasurable f μ :=
    aeStronglyMeasurableOfTendstoAe _ F_measurable h_lim
let b a := 2 * Ennreal.ofReal (bound a)
  /- `‖F n a‖ ≤ bound a` and `F n a --> f a` implies `‖f a‖ ≤ bound a`, and thus
rw [← Ennreal.of_real_add]
apply of_real_le_of_real
· apply norm_sub_le; · exact norm_nonneg _; · exact norm_nonneg _
rw [← two_mul]
      
  -- On the other hand, `F n a --> f a` implies that `‖F n a - f a‖ --> 0`
rw [lintegral_const_mul']
exact coe_ne_top
simp [abs_le, le_abs_self]
simp [abs_le, neg_le, neg_le_abs_self, abs_eq_max_neg, le_total]
simp only [nnnorm_smul, Ennreal.coe_mul]
exact MeasureTheory.MeasureSpace.volume
have : ae_strongly_measurable (fun x : α => c) μ := ae_strongly_measurable_const
rw [integrable, and_iff_right this, has_finite_integral_const_iff]
rw [← mem_ℒp_one_iff_integrable]
exact hf.norm_rpow hp_ne_zero hp_ne_top
rw [← mem_ℒp_one_iff_integrable] at hf⊢
exact hf.of_measure_le_smul c hc hμ'_le
rw [← mem_ℒp_one_iff_integrable] at h⊢
exact h.left_of_add_measure
rw [← mem_ℒp_one_iff_integrable] at h⊢
exact h.right_of_add_measure
induction s using Finset.induction_on <;> simp [*]
rw [← mem_ℒp_one_iff_integrable] at h⊢
exact h.smul_measure hc
simp [h]
rw [← hf.map_eq] at hg⊢
exact (integrable_map_measure hg hf.measurable.ae_measurable).symm
simp [integrable, ae_strongly_measurable_const]
rw [← mem_ℒp_one_iff_integrable] at hf hg⊢
exact hf.inf hg
rw [← mem_ℒp_one_iff_integrable] at hf hg⊢
exact hf.sup hg
rw [← mem_ℒp_one_iff_integrable] at hf⊢
exact hf.abs
intro x
simp only [nnnorm_mul]
exact mul_le_mul_of_nonneg_right (hC x) (zero_le _)
simp [← mem_ℒp_one_iff_integrable, hg.mem_ℒp_comp_iff_of_antilipschitz hg' g0]
refine'
    ⟨hf.ae_strongly_measurable.ae_measurable.realToNnreal.coeNnrealReal.AeStronglyMeasurable, _⟩
rw [has_finite_integral_iff_norm]
refine' lt_of_le_of_lt _ ((has_finite_integral_iff_norm _).1 hf.has_finite_integral)
apply lintegral_mono
intro x
simp [Ennreal.of_real_le_of_real, abs_le, le_abs_self]
rw [← with_density_congr_ae (coe_to_nnreal_ae_eq hflt),
    integrable_with_density_iff_integrable_smul]
· rfl
· exact hf.ennreal_to_nnreal
rw [with_density_congr_ae this]
simp [mul_comm]
rw [mem_ℒp, snorm_one_eq_lintegral_nnnorm]
exact
    ⟨(AeMeasurable.ennrealToReal hfm).AeStronglyMeasurable,
      has_finite_integral_to_real_of_lintegral_ne_top hfi⟩
simp
rw [← mem_ℒp_one_iff_integrable] at hf⊢
exact hf.of_real
rw [← mem_ℒp_one_iff_integrable] at hf⊢
exact hf.re
rw [← mem_ℒp_one_iff_integrable] at hf⊢
exact hf.im
rw [← mem_ℒp_one_iff_integrable] at hf⊢
exact hf.const_inner c
rw [← mem_ℒp_one_iff_integrable] at hf⊢
exact hf.inner_const c
refine' ⟨hf.ae_strongly_measurable, _⟩
rw [has_finite_integral, lintegral_trim hm _]
· exact hf_int.2
· exact @strongly_measurable.ennnorm _ m _ _ f hf
simp [integrable]
apply integrable_congr
exact coe_fn_mk f hf
rw [← integrable_mk, mk_coe_fn]
rw [← integrable_coe_fn, ← mem_ℒp_one_iff_integrable, Lp.mem_Lp_iff_mem_ℒp]
refine' induction_on₂ f g fun f hf g hg hfi hgi => _
simp only [integrable_mk, mk_add_mk] at hfi hgi⊢
exact hfi.add hgi
rw [← mem_ℒp_one_iff_integrable]
exact Lp.mem_ℒp f
simp [Lp.edist_def, snorm, snorm']
simp [edist_eq_coe_nnnorm_sub]
simp [Lp.dist_def, snorm, snorm']
simp [edist_eq_coe_nnnorm_sub]
simp [Lp.norm_def, snorm, snorm']
rw [norm_def, Ennreal.of_real_to_real]
exact ne_of_lt (has_finite_integral_coe_fn f)
simp [integrable.to_L1]
simp [to_L1, snorm, snorm']
simp [edist_eq_coe_nnnorm]
rw [norm_to_L1, lintegral_norm_eq_lintegral_edist]
simp [integrable.to_L1, snorm, snorm']
simp [edist_eq_coe_nnnorm_sub]
simp [integrable.to_L1, snorm, snorm']
simp [edist_eq_coe_nnnorm]
simp
infer_instance
infer_instance
rw [Subsingleton.elim x y]
have h_tendsto := hf.tendsto_approx x
simp only [strongly_measurable.approx_bounded, simple_func.coe_map, Function.comp_apply]
refine' mul_le_mul_of_nonneg_right _ (norm_nonneg _)
rw [norm_one, Real.norm_of_nonneg]
· exact min_le_left _ _
· exact le_min zero_le_one (div_nonneg ((norm_nonneg _).trans hfx) (norm_nonneg _))
rw [norm_one, one_mul]
rw [min_eq_left_iff, one_le_div (lt_of_le_of_ne (norm_nonneg _) (Ne.symm hfx0))]
exact hfx
simp only [strongly_measurable.approx_bounded, simple_func.coe_map, Function.comp_apply]
refine' (norm_smul _ _).le.trans _
intro n x hxt
rw [simple_func.restrict_apply _ ((hS_meas n).inter ht)]
refine' Set.indicator_of_not_mem _ _
simp [hxt]
simp
let f_approx : ℕ → @simple_func α m β := fun n =>
    { toFun := hf.approx n
      measurableSetFiber' := fun x => h_mono _ (simple_func.measurable_set_fiber' _ x)
      finite_range' := simple_func.finite_range (hf.approx n) }
exact ⟨f_approx, hf.tendsto_approx⟩
refine' ⟨fun n => simple_func.pair (hf.approx n) (hg.approx n), fun x => _⟩
rw [nhds_prod_eq]
exact tendsto.prod_mk (hf.tendsto_approx x) (hg.tendsto_approx x)
simp
apply ClosedEmbedding.measurableEmbedding
exact closed_embedding_subtype_coe is_closed_closure
rw [fg] at H
exact T.measurable_comp_iff.1 H
exact UniformSpace.second_countable_of_separable _
refine' ⟨fun n => simple_func.piecewise s hs (hf.approx n) (hg.approx n), fun x => _⟩
refine' ⟨fun n => simple_func.extend (hf.approx n) g hg (hg'.approx n), _⟩
intro x
intro x hx n
rw [simple_func.coe_restrict _ hs, Set.indicator_of_mem hx]
intro x hx n
rw [simple_func.coe_restrict _ hs, Set.indicator_of_not_mem hx]
rw [this]
exact hs_m₂.compl
rw [this]
exact MeasurableSet.empty
refine' fun n => MeasurableSet.inter _ _
· exact measurable_spanning_sets (μ.trim hm) n
· exact hf.norm.measurable_set_le strongly_measurable_const
refine' fun n => (measure_mono (Set.inter_subset_left _ _)).trans_lt _
exact (le_trim hm).trans_lt (measure_spanning_sets_lt_top (μ.trim hm) n)
simp only [Pi.zero_apply, simple_func.coe_zero, support_zero', measure_empty,
      WithTop.zero_lt_top, forall_const]
refine'
    ⟨fun n => hf.approx n * hg.approx n, _, fun x =>
      (hf.tendsto_approx x).mul (hg.tendsto_approx x)⟩
intro n
exact (measure_mono (support_mul_subset_left _ _)).trans_lt (hf.fin_support_approx n)
rw [← hf.map_eq, h₂.ae_strongly_measurable_map_iff]
rw [← sum_cond, ae_strongly_measurable_sum_measure_iff, Bool.forall_bool, and_comm]
rfl
simp only [union_eq_Union, ae_strongly_measurable_Union_iff, Bool.forall_bool, cond, and_comm]
rw [interval_oc_eq_union, ae_strongly_measurable_union_iff]
have h_str_meas : strongly_measurable (id : ι → ι) := stronglyMeasurableId
refine' ⟨h_str_meas.approx, fun j x => _⟩
exact ((hu_cont x).Tendsto j).comp (h_str_meas.tendsto_approx j)
rw [tendsto_pi_nhds]
exact fun p => ht_sf p.fst p.snd
have h_str_meas : strongly_measurable (id : ι → ι) := stronglyMeasurableId
refine' ⟨h_str_meas.approx, fun j x => _⟩
exact ((hu_cont x).Tendsto j).comp (h_str_meas.tendsto_approx j)
rw [tendsto_pi_nhds]
exact fun p => ht_sf p.fst p.snd
simp only [eq_iff_true_of_subsingleton]
rw [Union_not_convergent_seq, ← inter_Union]
exact inter_subset_left _ _
intro s h_s t h_t h_ne
rw [Set.mem_singleton_iff.1 h_s, Set.mem_singleton_iff.1 h_t, Set.inter_self,
    Set.mem_singleton_iff]
intro s hs t ht hst
cases hs
· simp [hs]
· cases ht
    · simp [ht]
    · exact Set.mem_insert_of_mem _ (h_pi s hs t ht hst)
intro s hs t ht hst
cases hs
· cases ht <;> simp [hs, ht]
· cases ht
    · simp [hs, ht]
    · exact Set.mem_insert_of_mem _ (h_pi s hs t ht hst)
apply le_antisymm <;> apply generate_from_le
· exact fun t h_t => generateFromMeasurableSetOfGeneratePiSystem t h_t
· exact fun t h_t => measurable_set_generate_from (generatePiSystem.base h_t)
simp
rw [← hft_eq i hit]
exact h hit
rw [hft_eq i hit]
exact h hit
simp only [hp1S, hp2S, Finset.coe_union, union_subset_iff, and_self_iff]
simp [hn1, h]
have : s₁ = s₂ := funext fun x => propext <| h x
subst this
cases nonempty_encodable β
rw [← Encodable.Union_decode₂]
exact
    d.has_Union_nat (Encodable.Union_decode₂_disjoint_on hd) fun n =>
      Encodable.Union_decode₂_cases d.has_empty h
rw [union_eq_Union]
exact d.has_Union (pairwise_disjoint_on_bool.2 h) (Bool.forall_bool.2 ⟨h₂, h₁⟩)
apply d.has_compl_iff.1
simp [diff_eq, compl_inter]
exact d.has_union (d.has_compl h₁) h₂ (disjoint_compl_left.mono_right h)
rw [← Union_disjointed]
exact
      d.has_Union (disjoint_disjointed _) fun n =>
        disjointedRec (fun t i h => h_inter _ _ h <| d.has_compl <| hf i) (hf n)
simp [d.has_empty]
rw [Union_inter]
refine' d.has_Union_nat _ hf
exact hd.mono fun i j => Disjoint.mono (inter_subset_left _ _) (inter_subset_left _ _)
rw [of_measurable_space_to_measurable_space]
exact (generate_le _) fun t ht => measurable_set_generate_from ht
rw [h_eq, dynkin_system.generate_from_eq h_inter]
rfl
rw [Eq]
exact ht
rw [Eq]
exact ht _
rw [measure.restrict_congr_set hst]
simp only [integrable_on, measure.restrict_union₀ hst ht, integral_add_measure hfs hft]
rw [measure.restrict_empty, integral_zero_measure]
rw [measure.restrict_univ]
rw [←
    integral_union (@disjoint_compl_right (Set α) _ _) hs.compl hfi.integrable_on hfi.integrable_on,
    union_compl_self, integral_univ]
simp
rw [integral_indicator ht, measure.restrict_restrict ht, Set.inter_comm]
simp only [norm_one]
rw [of_real_integral_norm_eq_lintegral_nnnorm (integrable_on_const.2 (Or.inr hs.lt_top))]
simp only [nnnorm_one, Ennreal.coe_one]
rw [← Set.indicator_add_compl_eq_piecewise,
    integral_add' (hf.integrable_indicator hs) (hg.integrable_indicator hs.compl),
    integral_indicator hs, integral_indicator hs.compl]
simp only [integrable_on, measure.restrict_Union_ae hd hm] at hfi⊢
exact has_sum_integral_measure hfi
refine' integral_eq_zero_of_ae _
rw [eventually_eq, ae_restrict_iff (hf.measurable_set_eq_fun strongly_measurable_zero)]
refine' eventually_of_forall fun x hx => _
rw [Pi.zero_apply]
exact ht_eq x hx
rw [← integral_add_compl h_meas hfi.norm]
congr 1
refine' set_integral_congr h_meas fun x hx => _
dsimp only
rw [Real.norm_eq_abs, abs_eq_self.mpr _]
exact hx
rw [integral_const, measure.restrict_apply_univ]
rw [integral_indicator s_meas, ← set_integral_const]
rw [set_integral_congr_ae hs (indicator_const_Lp_coe_fn.mono fun x hx hxs => hx)]
rw [integral_indicator_const _ ht, measure.restrict_apply ht]
rw [integral_univ]
rw [inter_univ]
rw [measure.restrict_map_of_ae_measurable hg hs,
    integral_map (hg.mono_measure measure.restrict_le_self) (hf.mono_measure _)]
exact measure.map_mono_of_ae_measurable measure.restrict_le_self hg
rw [hf.restrict_map, hf.integral_map]
rw [integral_pos_iff_support_of_nonneg_ae hf hfi, measure.restrict_apply₀]
rw [support_eq_preimage]
exact hfi.ae_strongly_measurable.ae_measurable.null_measurable (measurable_set_singleton 0).compl
refine' ⟨ae_strongly_measurable_const, lt_of_le_of_lt _ hfint.2⟩
refine'
      set_lintegral_mono (Measurable.nnnorm _).coeNnrealEnnreal hfm.nnnorm.coe_nnreal_ennreal
        fun x hx => _
· exact measurableConst
· simp only [Ennreal.coe_le_coe, Real.nnnorm_of_nonneg hR,
        Real.nnnorm_of_nonneg (hR.trans <| le_of_lt hx), Subtype.mk_le_mk]
      exact le_of_lt hx
simp [hs, eventually_le, eventually_inf_principal, ae_of_all _ h]
rw [mul_comm, ← smul_eq_mul, ← set_integral_const c]
exact set_integral_mono_on (integrable_on_const.2 (Or.inr hμs.lt_top)) hfint hs hf
rw [← integral_indicator hs, ←
    integral_indicator (strongly_measurable_const.measurable_set_le hf)]
exact
    integral_mono (hfi.indicator hs)
      (hfi.indicator (strongly_measurable_const.measurable_set_le hf))
      (indicator_le_indicator_nonneg s f)
rw [← integral_indicator hs, ←
    integral_indicator (hf.measurable_set_le strongly_measurable_const)]
exact
    integral_mono (hfi.indicator (hf.measurable_set_le strongly_measurable_const))
      (hfi.indicator hs) (indicator_nonpos_le_indicator s f)
rw [Lp.norm_def, Lp.norm_def, Ennreal.to_real_le_to_real (Lp.snorm_ne_top _) (Lp.snorm_ne_top _)]
refine' (le_of_eq _).trans (snorm_mono_measure _ measure.restrict_le_self)
· exact s
exact snorm_congr_ae (mem_ℒp.coe_fn_to_Lp _)
intro f
rw [one_mul]
exact norm_Lp_to_Lp_restrict_le s f
rfl
rfl
rfl
rfl
rw [← funext L.integral_comp_Lp]
exact continuous_integral.comp (L.comp_LpL 1 μ).Continuous
rw [← integral_of_real, ← integral_of_real, integral_coe_re_add_coe_im hf]
rw [restrict_with_density hs, integral_with_density_eq_integral_smul f_meas]
rw [restrict_with_density hs, integral_with_density_eq_integral_smul₀ hf]
rw [simple_func.coe_add, add_mul]
rw [← simple_func.coe_to_larger_space_eq hm g]
exact hf.simple_func_mul (g.to_larger_space hm)
simp [circleMap, add_mul, exp_periodic _]
simp [circleMap]
simp [circleMap]
simp
simp [dist_eq, le_abs_self]
simp only [← image_vadd, ← image_smul, ← range_comp, vadd_eq_add, circleMap, (· ∘ ·),
        real_smul]
simp [smul_sphere R (0 : ℂ) zero_le_one]
rw [← range_circle_map, ← (periodic_circle_map c R).image_Ioc Real.two_pi_pos 0, zero_add]
simp [circleMap, exp_ne_zero]
simp [I_ne_zero]
simp
simp [CircleIntegrable]
simp [h₀, I_ne_zero]
simp only [circleIntegral, intervalIntegral.integral_of_le real.two_pi_pos.le,
    measure.restrict_congr_set Ioc_ae_eq_Icc]
simp [circleIntegral]
simp only [h (circle_map_mem_sphere _ hR _)]
simp only [circleIntegral, smul_sub, intervalIntegral.integral_sub hf.out hg.out]
simp [norm_smul]
rw [sub_zero, _root_.abs_of_pos Real.two_pi_pos]
ac_rfl
rw [this]
simp [real.pi_pos.le]
simp only [norm_smul, deriv_circle_map, norm_eq_abs, map_mul, abs_I, mul_one,
        abs_circle_map_zero, abs_of_pos hR]
refine'
        intervalIntegral.integral_lt_integral_of_continuous_on_of_le_of_exists_lt Real.two_pi_pos _
          continuous_on_const (fun θ hθ => _) ⟨θ₀, Ioc_subset_Icc_self hmem, _⟩
·
        exact
          continuous_on_const.mul
            (hc.comp (continuous_circle_map _ _).ContinuousOn fun θ hθ =>
                circle_map_mem_sphere _ hR.le _).norm
· exact mul_le_mul_of_nonneg_left (hf _ <| circle_map_mem_sphere _ hR.le _) hR.le
· exact (mul_lt_mul_left hR).2 hlt
simp [mul_assoc]
simp only [circleIntegral, ← smul_comm a, intervalIntegral.integral_smul]
simp only [circleIntegral, intervalIntegral.integral_smul_const, ← smul_assoc]
simp [circleIntegral, ← div_eq_mul_inv, mul_div_cancel_left _ (circle_map_ne_center hR)]
decide
simp only [cauchyPowerSeries, ContinuousMultilinearMap.mk_pi_field_apply, Fin.prod_const,
    div_eq_mul_inv, mul_pow, mul_smul, circleIntegral.integral_smul, ← smul_comm (w ^ n)]
simp [cauchyPowerSeries, norm_smul, real.pi_pos.le]
simp [real.pi_pos.le]
simp only [cauchy_power_series_apply]
exact (has_sum_two_pi_I_cauchy_power_series_integral hf hw).const_smul
refine' has_sum_cauchy_power_series_integral hf _
rw [← norm_eq_abs, ← coe_nnnorm, Nnreal.coe_lt_coe, ← Ennreal.coe_lt_coe]
exact mem_emetric_ball_zero_iff.1 hy
simp [hR.ne']
simp [weighted_smul]
simp only [weighted_smul, Algebra.id.smul_eq_mul, coe_smul', id.def, coe_id', Pi.smul_apply]
exact mul_nonneg to_real_nonneg hx
rw [neg_part]
exact pos_part_map_norm _
simp [integral, set_to_simple_func, weighted_smul_apply]
simp
have hf' : f.fin_meas_supp μ := integrable_iff_fin_meas_supp.1 hf
simp only [← map_apply g f, lintegral_eq_lintegral]
rw [map_integral f _ hf, map_lintegral, Ennreal.to_real_sum]
· refine' Finset.sum_congr rfl fun b hb => _
    rw [smul_eq_mul, to_real_mul, mul_comm]
· intro a ha
refine' (norm_set_to_simple_func_le_integral_norm _ (fun s _ _ => _) hf).trans (one_mul _).le
exact (norm_weighted_smul_le s).trans (one_mul _).symm.le
rw [integral, simple_func.integral_eq_lintegral (simple_func.integrable f) h_pos]
rw [integral, norm_eq_integral]
exact (to_simple_func f).norm_integral_le_integral_norm (simple_func.integrable f)
rw [one_mul]
simp only [mul_comm]
exact integral_mul_left r f
simp [integral_congr_ae hf, integral_zero]
refine' fun n => bound_integrable.mono' (hF_meas n) _
exact eventually_le.trans (h_bound n) (hb_le_tsum n)
rw [lintegral_eq_zero_iff']
· refine' hf.mono _
        simp only [Pi.zero_apply]
        intro a h
        simp only [h, neg_nonpos, of_real_eq_zero]
· exact measurable_of_real.comp_ae_measurable hfm.ae_measurable.neg
refine' lintegral_congr_ae (hf.mono fun a h => _)
rw [Real.norm_eq_abs, abs_of_nonneg h]
rw [integral_norm_eq_lintegral_nnnorm hf.ae_strongly_measurable,
    Ennreal.of_real_to_real (lt_top_iff_ne_top.mp hf.2)]
rw [← integral_sub hf.real_to_nnreal]
· simp
· exact hf.neg.real_to_nnreal
rw [Real.norm_eq_abs, abs_eq_self.mpr hx]
rw [integral_eq_lintegral_of_nonneg_ae _ hfm.ennreal_to_real.ae_strongly_measurable]
· rw [lintegral_congr_ae]
    refine' hf.mp (eventually_of_forall _)
    intro x hx
    rw [lt_top_iff_ne_top] at hx
    simp [hx]
· exact eventually_of_forall fun x => Ennreal.to_real_nonneg
rw [lintegral_coe_eq_integral f hfi, Ennreal.ofReal, Ennreal.coe_le_coe,
    Real.to_nnreal_le_iff_le_coe]
simp [norm_nonneg]
rw [L1.norm_eq_integral_norm]
refine' integral_congr_ae _
apply hf.coe_fn_to_L1.mono
intro a ha
simp [ha]
apply lintegral_congr fun x => _
rw [← of_real_rpow_of_nonneg (norm_nonneg _) to_real_nonneg, of_real_norm_eq_coe_nnnorm]
rw [integral_non_ae_strongly_measurable h, norm_zero]
exact integral_nonneg_of_ae le_ae
rw [integral_eq f hfi, ← L1.simple_func.to_Lp_one_eq_to_L1,
    L1.simple_func.integral_L1_eq_integral, L1.simple_func.integral_eq_integral]
exact simple_func.integral_congr hfi (Lp.simple_func.to_simple_func_to_Lp _ _).symm
rw [← f.integral_eq_integral hfi, simple_func.integral, ← simple_func.integral_eq]
rfl
simp only [integrable_const_iff, not_or]
exact ⟨hc, hμ.not_lt⟩
rw [integral_const, smul_eq_mul, mul_comm]
have hfi' := simple_func.integrable_approx_on hfm hfi h₀ h₀i
simp only [simple_func.integral_eq_integral _ (hfi' _)]
exact
    tendsto_set_to_fun_approx_on_of_measurable (dominated_fin_meas_additive_weighted_smul μ) hfi hfm
      hs h₀ h₀i
simp
apply tendsto_integral_approx_on_of_measurable hf fmeas _ _ (integrable_zero _ _ _)
exact eventually_of_forall fun x => subset_closure (hs (Set.mem_union_left _ (mem_range_self _)))
rw [integral_add_measure h₁ h₂, nndist_comm, nndist_eq_nnnorm, add_sub_cancel']
exact ennnorm_integral_le_lintegral_ennnorm _
simp [insert_subset_insert, Set.range_comp_subset_range]
congr 1
exact measure.map_congr hφ.ae_eq_mk
rw [← map_comap_subtype_coe hs]
exact (MeasurableEmbedding.subtypeCoe hs).integral_map _
simp [measure.dirac_apply_of_mem]
simp [measure.dirac_apply_of_mem]
rw [integral_eq_lintegral_of_nonneg_ae, integral_eq_lintegral_of_nonneg_ae,
    integral_eq_lintegral_of_nonneg_ae]
rotate_left
· exact eventually_of_forall fun x => Real.rpow_nonneg_of_nonneg (norm_nonneg _) _
· exact (hg.1.norm.AeMeasurable.pow aeMeasurableConst).AeStronglyMeasurable
· exact eventually_of_forall fun x => Real.rpow_nonneg_of_nonneg (norm_nonneg _) _
· exact (hf.1.norm.AeMeasurable.pow aeMeasurableConst).AeStronglyMeasurable
· exact eventually_of_forall fun x => mul_nonneg (norm_nonneg _) (norm_nonneg _)
· exact hf.1.norm.mul hg.1.norm
rw [Ennreal.to_real_rpow, Ennreal.to_real_rpow, ← Ennreal.to_real_mul]
  -- replace norms
refine' lintegral_congr fun x => _
rw [← of_real_norm_eq_coe_nnnorm, Ennreal.of_real_rpow_of_nonneg (norm_nonneg _) hpq.nonneg]
refine' lintegral_congr fun x => _
rw [← of_real_norm_eq_coe_nnnorm,
      Ennreal.of_real_rpow_of_nonneg (norm_nonneg _) hpq.symm.nonneg]
have hf : strongly_measurable[m] f := @simple_func.strongly_measurable β F m _ f
have hf_int_m := hf_int.trim hm hf
rw [integral_simple_func_larger_space (le_refl m) f hf_int_m,
    integral_simple_func_larger_space hm f hf_int]
congr
simp
refine' tendsto_integral_of_L1 f hf_int (eventually_of_forall hf_seq_int) _
exact simple_func.tendsto_approx_on_range_L1_nnnorm (hf.mono hm).Measurable hf_int
rw [integral_congr_ae (ae_eq_of_ae_eq_trim hf.ae_eq_mk), integral_congr_ae hf.ae_eq_mk]
exact integral_trim hm hf.strongly_measurable_mk
rw [snorm_congr_ae this, snorm_zero, hr, Ennreal.coe_zero, mul_zero]
exact le_rfl
rw [integral_neg, neg_eq_zero]
exact le_antisymm (integral_nonpos_of_ae hf) hfint'
simp only [div_eq_mul_inv]
rw [lintegral_add_left']
· rw [lintegral_mul_const'' _ (hf.pow_const p), lintegral_mul_const', hf_norm, hg_norm, ←
          div_eq_mul_inv, ← div_eq_mul_inv, hpq.inv_add_inv_conj_ennreal]
        simp [hpq.symm.pos]
· exact (hf.pow_const _).mul_const _
simp [fun_mul_inv_snorm, mul_assoc, inv_mul_cancel, hf_nonzero, hf_top]
simp [hf_nontop, hg_nontop, hf_nonzero, hg_nonzero]
rw [lintegral_eq_zero_iff' (hf.pow_const p)] at hf_zero
refine' Filter.Eventually.mp hf_zero (Filter.eventually_of_forall fun x => _)
dsimp only
rw [Pi.zero_apply, ← not_imp_not]
exact fun hx => (rpow_pos_of_nonneg (pos_iff_ne_zero.2 hx) hp0).ne'
simp [hp0_lt]
simp [zero_lt_one]
rw [sub_eq_add_neg, Ennreal.rpow_add _ _ Ennreal.two_ne_zero Ennreal.coe_ne_top, ←
          mul_assoc, ← Ennreal.mul_rpow_of_nonneg _ _ hp0, one_div,
          Ennreal.inv_mul_cancel Ennreal.two_ne_zero Ennreal.coe_ne_top, Ennreal.one_rpow, one_mul,
          Ennreal.rpow_neg_one]
simp [hp1]
simp [hpqr]
simp [lt_div_iff, hpq, hp0_lt]
simp [hp0]
simp [hp0]
refine' le_trans (Ennreal.lintegral_mul_le_Lp_mul_Lq μ hpq hf (hg.pow_const _)) _
simp [hpq.nonneg]
refine' lintegral_mono fun a => _
dsimp only
rw [add_mul]
exact
        add_le_add
          (lintegral_mul_rpow_le_lintegral_rpow_mul_lintegral_rpow hpq hf (hf.add hg) hf_top)
          (lintegral_mul_rpow_le_lintegral_rpow_mul_lintegral_rpow hpq hg (hf.add hg) hg_top)
simp [hpq.pos]
simp [hpq.nonneg]
simp [h_add_zero, h_add_top, hpq.nonneg, hp_not_nonpos, -Pi.add_apply]
have hp_pos : 0 < p := lt_of_lt_of_le zero_lt_one hp1
simp [lt_of_lt_of_le zero_lt_one hp1]
rw [← Ne.def] at hf_top hg_top
rw [← lt_top_iff_ne_top] at hf_top hg_top⊢
exact lintegral_rpow_add_lt_top_of_lintegral_rpow_lt_top hf hf_top hg_top hp1
simp [measure.restrict_congr_set Ioo_ae_eq_Ioc.symm, ae_cover_Ioo_of_Icc ha hb]
simp [measure.restrict_congr_set Ioo_ae_eq_Ioc.symm, ae_cover_Ioo_of_Ico ha hb]
simp [measure.restrict_congr_set Ioo_ae_eq_Ioc.symm, ae_cover_Ioo_of_Ioc ha hb]
simp [measure.restrict_congr_set Ioo_ae_eq_Ioc.symm, ae_cover_Ioo_of_Ioo ha hb]
simp [measure.restrict_congr_set Ioo_ae_eq_Ico.symm, ae_cover_Ioo_of_Icc ha hb]
simp [measure.restrict_congr_set Ioo_ae_eq_Ico.symm, ae_cover_Ioo_of_Ico ha hb]
simp [measure.restrict_congr_set Ioo_ae_eq_Ico.symm, ae_cover_Ioo_of_Ioc ha hb]
simp [measure.restrict_congr_set Ioo_ae_eq_Ico.symm, ae_cover_Ioo_of_Ioo ha hb]
simp [measure.restrict_congr_set Ioo_ae_eq_Icc.symm, ae_cover_Ioo_of_Icc ha hb]
simp [measure.restrict_congr_set Ioo_ae_eq_Icc.symm, ae_cover_Ioo_of_Ico ha hb]
simp [measure.restrict_congr_set Ioo_ae_eq_Icc.symm, ae_cover_Ioo_of_Ioc ha hb]
simp [measure.restrict_congr_set Ioo_ae_eq_Icc.symm, ae_cover_Ioo_of_Ioo ha hb]
have lim₁ :=
    lintegral_tendsto_of_monotone_of_nat hφ.bInter_Ici_ae_cover
      (fun i j hij => bInter_subset_bInter_left (Ici_subset_Ici.mpr hij)) hfm
have lim₂ :=
    lintegral_tendsto_of_monotone_of_nat hφ.bUnion_Iic_ae_cover
      (fun i j hij => bUnion_subset_bUnion_left (Iic_subset_Iic.mpr hij)) hfm
have le₁ := fun n => lintegral_mono_set (bInter_subset_of_mem left_mem_Ici)
have le₂ := fun n => lintegral_mono_set (subset_bUnion_of_mem right_mem_Iic)
exact tendsto_of_tendsto_of_tendsto_of_le_of_le lim₁ lim₂ le₁ le₂
refine' ⟨hfm, (le_of_tendsto _ hbounded).trans_lt Ennreal.of_real_lt_top⟩
exact hφ.lintegral_tendsto_of_countably_generated hfm.ennnorm
refine' hφ.integrable_of_lintegral_nnnorm_bounded (max 1 (I + 1)) hfm _
refine' htendsto.eventually (ge_mem_nhds _)
refine' (Ennreal.of_real_lt_of_real_iff (lt_max_of_lt_left zero_lt_one)).2 _
exact lt_max_of_lt_right (lt_add_one I)
have hfm : ae_strongly_measurable f μ :=
    hφ.ae_strongly_measurable fun i => (hfi i).AeStronglyMeasurable
refine' hφ.integrable_of_lintegral_nnnorm_bounded I hfm _
conv at hbounded in integral _ _ =>
    rw [integral_eq_lintegral_of_nonneg_ae (ae_of_all _ fun x => @norm_nonneg E _ (f x))
        hfm.norm.restrict]
conv at hbounded in Ennreal.ofReal _ => 
    dsimp
    rw [← coe_nnnorm]
    rw [Ennreal.of_real_coe_nnreal]
refine' hbounded.mono fun i hi => _
rw [← Ennreal.of_real_to_real (ne_top_of_lt (hfi i).2)]
apply Ennreal.of_real_le_of_real hi
intro i
rw [integrable_on, measure.restrict_restrict (hφ.measurable i)]
exact hfi i
intro i
rw [integrable_on, measure.restrict_restrict (hφ.measurable i), inter_comm]
exact hfi i
refine'
    (ae_cover_Ioc_of_Ioc ha hb).integrableOfIntegralNormBounded I
      (fun i => (hfi i).restrict measurableSetIoc) (eventually.mono h _)
intro i hi
simp only [measure.restrict_restrict measurableSetIoc]
refine' le_trans (set_integral_mono_set (hfi i).norm _ _) hi
· apply ae_of_all
    simp only [Pi.zero_apply, norm_nonneg, forall_const]
· apply ae_of_all
    intro c hc
    exact hc.1
rw [min_eq_left hb.le]
exact Ioo_subset_Ioi_self
rw [interval_of_le hb.le]
exact Icc_subset_Ici_self
cases f <;> cases g <;> congr <;> exact H
simp [range_eq_empty]
simp only [mem_range, Set.forall_range_iff]
simp
simp
have hf_meas := @simple_func.measurable_set_fiber α _
rw [hf_meas]
exact Set.mem_univ x
rw [f.sum_measure_preimage_singleton, coe_range, preimage_range]
simp [hs]
simp
simp
simp only [← Finset.coe_inj, coe_range, coe_piecewise, range_piecewise, coe_const,
    Finset.coe_insert, Finset.coe_singleton, hs_nonempty.image_const,
    (nonempty_compl.2 hs_ne_univ).image_const, singleton_union]
simp only [coe_range, coe_map, Finset.coe_image, range_comp]
simp only [coe_range, sep_mem_eq, Set.mem_range, Function.comp_apply, coe_map, Finset.coe_filter,
    ← mem_preimage, inter_comm, preimage_inter_range]
apply preimage_comp
simp only [coe_range, coe_comp, Set.range_comp_subset_range]
rw [← singleton_prod_singleton]
exact pair_preimage _ _ _ _
simp [eq_comm]
rw [← Finset.not_nonempty_iff_eq_empty]
refine' Finset.induction_on s rfl _
intro a s hs ih
rw [Finset.sup_insert, Finset.sup_insert, sup_apply, ih]
rw [restrict, dif_pos hs]
rfl
simp [restrict]
simp [restrict]
simp [hs, Set.indicator_comp_of_zero hg]
simp [restrict_of_not_measurable hs, hg]
simp only [f.coe_restrict hs]
simp [hs, indicator_preimage_of_not_mem _ _ ht, inter_comm]
rw [← Finset.mem_coe, coe_range, coe_restrict _ hs, mem_range_indicator]
rw [restrict_of_not_measurable hs] at hr
exact (h0 <| eq_zero_of_mem_range_zero hr).elim
simp only [coe_restrict _ hs, indicator_le_indicator (H x)]
simp only [restrict_of_not_measurable hs, le_refl]
dsimp only [approx]
rw [finset_sup_apply]
congr
funext k
rw [restrict_apply]
rfl
exact hf measurableSetIci
rw [approx_apply _ hf, approx_apply _ (hf.comp hg)]
rw [ennreal_rat_embed, Encodable.encodek] <;> rfl
refine' le_supr_of_le (Encodable.encode q) _
rw [ennreal_rat_embed_encode q]
refine' le_supr_of_le (le_of_lt q_lt) _
exact le_rfl
rw [Finset.sum_add_distrib]
rw [map_lintegral, map_lintegral]
simp [lintegral, mul_add, Finset.sum_add_distrib]
simp [lintegral, mul_left_comm _ c, Finset.mul_sum]
simp only [lintegral, measure.sum_apply, f.measurable_set_preimage, ← Finset.tsum_subtype, ←
    Ennreal.tsum_mul_left]
apply Ennreal.tsum_comm
simp only [f.restrict_apply hs, indicator_of_mem hxs, mem_range_self]
simp [*]
simp only [hb, zero_mul]
rw [restrict_preimage_singleton _ hs hb, inter_comm]
simp only [lintegral, measure.restrict_apply, f.measurable_set_preimage]
rw [f.restrict_lintegral hs, lintegral_restrict]
rw [lintegral]
cases isEmpty_or_nonempty α
· simp [μ.eq_zero_of_is_empty]
· simp [preimage_const_of_mem]
rw [const_lintegral, measure.restrict_apply MeasurableSet.univ, univ_inter]
rw [restrict_lintegral_eq_lintegral_restrict _ hs, const_lintegral_restrict]
rw [map_lintegral, map_lintegral]
refine' sup_le _ _ <;> refine' Finset.sum_le_sum fun a _ => mul_le_mul_right' _ _
exact le_sup_left
exact le_sup_right
rw [sup_eq_map₂, map_lintegral]
rw [sup_of_le_right hfg]
simp only [lintegral, ← H]
apply lintegral_eq_of_subset
simp only [H]
intros
exact mem_range_of_measure_ne_zero ‹_›
simp [hx]
simp only [mem_support, Set.mem_preimage, mem_filter, mem_range_self, true_and_iff, exists_prop,
      mem_Union, Set.mem_range, mem_singleton_iff, exists_eq_right']
rw [f.support_eq]
exact Finset.measurableSetBUnion _ fun y hy => measurable_set_fiber _ _
constructor
· refine' fun h y hy => lt_of_le_of_lt (measure_mono _) h
    exact fun x hx (H : f x = 0) => hy <| H ▸ Eq.symm hx
· intro H
    rw [fin_meas_supp_iff_support, support_eq]
    refine' lt_of_le_of_lt (measure_bUnion_finset_le _ _) (sum_lt_top _)
    exact fun y hy => (H y (Finset.mem_filter.1 hy).2).Ne
rw [add_eq_map₂]
exact hf.map₂ hg (zero_add 0)
rw [mul_eq_map₂]
exact hf.map₂ hg (zero_mul 0)
refine' fin_meas_supp_iff.2 fun b hb => _
rw [f.lintegral_eq_of_subset' (Finset.subset_insert b _)] at h
refine' Ennreal.lt_top_of_mul_ne_top_right _ hb
exact (lt_top_of_sum_ne_top h (Finset.mem_insert_self _ _)).Ne
rw [lintegral]
exact
    le_antisymm (supr₂_le fun g hg => lintegral_mono hg <| le_rfl) (le_supr₂_of_le f le_rfl le_rfl)
rw [lintegral, lintegral]
exact supr_mono fun φ => supr_mono' fun hφ => ⟨le_trans hφ hfg, lintegral_mono (le_refl φ) hμν⟩
apply le_antisymm
· exact supr_le fun i => supr_le fun hi => supr_le fun h'i => lintegral_mono h'i
· rw [lintegral]
    refine' supr₂_le fun i hi => le_supr₂_of_le i i.Measurable <| le_supr_of_le hi _
    exact le_of_eq (i.lintegral_eq_lintegral _).symm
rw [← simple_func.const_lintegral, ← simple_func.lintegral_eq_lintegral, simple_func.coe_const]
simp
rw [lintegral_const, one_mul]
rw [lintegral_const, measure.restrict_apply_univ]
rw [set_lintegral_const, one_mul]
rw [lintegral_const]
exact Ennreal.mul_lt_top hc (measure_ne_top (μ.restrict s) univ)
simp only [← supr_apply]
exact (monotone_lintegral μ).le_map_supr
simp only [← infi_apply]
exact (monotone_lintegral μ).map_infi_le
simp only [h]
rw [measure.restrict_congr_set h]
refine' mt _ this
intro h
rw [h, mul_zero]
intro r i j h
refine' inter_subset_inter (subset.refl _) _
intro x hx
exact le_trans hx (h_mono h x)
rw [← const_mul_lintegral, eq_rs, simple_func.lintegral]
simp only [(Eq _).symm]
rw [measure_Union_eq_supr (directed_of_sup <| mono x), Ennreal.mul_supr]
rw [Ennreal.finset_sum_supr_nat]
intro p i j h
exact mul_le_mul_left' (measure_mono <| mono p h) _
refine' supr_mono fun n => _
rw [restrict_lintegral _ (h_meas n)]
· refine' le_of_eq ((Finset.sum_congr rfl) fun r hr => _)
        congr 2
refine' supr_mono fun n => _
rw [← simple_func.lintegral_eq_lintegral]
refine' lintegral_mono fun a => _
simp only [map_apply] at h_meas
simp only [coe_map, restrict_apply _ (h_meas _), (· ∘ ·)]
exact indicator_apply_le id
intro n m hnm x
rw [← simple_func.add_lintegral, ← simple_func.map_add @Ennreal.coe_add]
refine' simple_func.lintegral_mono (fun x => _) le_rfl
simp only [add_tsub_eq_max, le_max_right, coe_map, Function.comp_apply, simple_func.coe_add,
        simple_func.coe_sub, Pi.add_apply, Pi.sub_apply, WithTop.coe_max]
refine' add_le_add le_rfl (le_trans _ (hφ _ hψ).le)
exact simple_func.lintegral_mono le_rfl measure.restrict_le_self
simp only [← simple_func.lintegral_eq_lintegral, coe_const, lintegral_const,
        measure.restrict_apply, MeasurableSet.univ, univ_inter]
dsimp only [lintegral]
refine' Ennreal.bsupr_add_bsupr_le' ⟨0, zero_le f⟩ ⟨0, zero_le g⟩ fun f' hf' g' hg' => _
exact le_supr₂_of_le (f' + g') (add_le_add hf' hg') (add_lintegral _ _).ge
simp only [supr_eapprox_apply, hf, hg]
congr
funext a
rw [Ennreal.supr_add_supr_of_monotone]
· rfl
· intro i j h
        exact monotone_eapprox _ h a
· intro i j h
        exact monotone_eapprox _ h a
refine' (Ennreal.supr_add_supr_of_monotone _ _).symm <;>
        · intro i j h
          exact simple_func.lintegral_mono (monotone_eapprox _ h) (le_refl μ)
rw [lintegral_eq_supr_eapprox_lintegral hf, lintegral_eq_supr_eapprox_lintegral hg]
rw [lintegral_congr_ae hf.ae_eq_mk, ← lintegral_add_left hf.measurable_mk,
    lintegral_congr_ae (hf.ae_eq_mk.add (ae_eq_refl g))]
simp only [lintegral, supr_subtype', simple_func.lintegral_smul, Ennreal.mul_supr, smul_eq_mul]
rw [← measure.sum_coe_finset, lintegral_sum_measure, ← Finset.tsum_subtype']
rfl
simp [lintegral]
rw [measure.restrict_empty, lintegral_zero_measure]
rw [measure.restrict_univ]
congr
funext a
rw [← supr_eapprox_apply f hf, Ennreal.mul_supr]
rfl
rw [lintegral_supr]
· congr
        funext n
        rw [← simple_func.const_mul_lintegral, ← simple_func.lintegral_eq_lintegral]
· intro n
        exact simple_func.measurable _
· intro i j h a
        exact mul_le_mul_left' (monotone_eapprox _ h _) _
rw [← Ennreal.mul_supr, lintegral_eq_supr_eapprox_lintegral hf]
rw [lintegral, Ennreal.mul_supr]
refine' supr_le fun s => _
rw [Ennreal.mul_supr]
simp only [supr_le_iff]
intro hs
rw [← simple_func.const_mul_lintegral, lintegral]
refine' le_supr_of_le (const α r * s) (le_supr_of_le (fun x => _) le_rfl)
exact mul_le_mul_left' (hs x) _
rw [mul_comm]
exact rinv
simp [lintegral_const_mul'' _ hg, lintegral_mul_const'' _ hf]
rw [h]
rw [h₁, h₂]
simp only [lintegral, ← restrict_lintegral_eq_lintegral_restrict _ hs, supr_subtype']
apply le_antisymm <;> refine' supr_mono' (Subtype.forall.2 fun φ hφ => _)
· refine' ⟨⟨φ, le_trans hφ (indicator_le_self _ _)⟩, _⟩
    refine' simple_func.lintegral_mono (fun x => _) le_rfl
rw [← lintegral_congr_ae (indicator_ae_eq_of_ae_eq_set hs.to_measurable_ae_eq),
    lintegral_indicator _ (measurable_set_to_measurable _ _),
    measure.restrict_congr_set hs.to_measurable_ae_eq]
rw [hφ_eq]
rw [lintegral_add_left hφm, lintegral_indicator₀, set_lintegral_const]
exact measurableSetLe (hφm.null_measurable.measurable'.add_const _) hg.null_measurable
simp [mul_eq_top, hμf.ne.symm]
rw [mul_comm]
exact mul_meas_ge_le_lintegral₀ hf ε
simp [pos_iff_ne_zero, hf, Filter.EventuallyEq, ae_iff, Function.support]
simp only [ha]
simp [g, if_pos h]
simp only [g, if_neg h]
have := hs.1
rw [subset_def] at this
have := mt (this a) h
simp only [not_not, mem_set_of_eq] at this
exact this n
simp only [lintegral_congr_ae (g_eq_f.mono fun a ha => ha _)]
refine' Ennreal.eq_sub_of_add_eq hg_fin _
rw [← lintegral_add_right _ hg]
exact lintegral_congr_ae (h_le.mono fun x hx => tsub_add_cancel_of_le hx)
rw [tsub_le_iff_right]
simp [hs]
simp only [liminf_eq_supr_infi_of_nat]
refine' (lintegral_infi _ _ _).symm
· intro n
        exact measurableBsupr _ (to_countable _) hf_meas
· intro n m hnm a
        exact supr_le_supr_of_subset fun i hi => le_trans hnm hi
· refine' ne_top_of_le_ne_top h_fin (lintegral_mono_ae _)
        refine' (ae_all_iff.2 h_bound).mono fun n hn => _
        exact supr_le fun i => supr_le fun hi => hn i
simp only [limsup_eq_infi_supr_of_nat]
rw [tendsto_at_top'] at xl
exact xl
intro a
refine' le_antisymm (supr_le fun b => _) (supr_le fun n => le_supr (fun n => f n a) _)
exact le_supr_of_le (encode b + 1) (h_directed.le_sequence b a)
simp only [this]
simp only [measure.restrict_Union_ae hd hm, lintegral_sum_measure]
simp only [← Finset.mem_coe, lintegral_bUnion₀ s.countable_to_set hm hd, ← s.tsum_subtype']
rw [← lintegral_sum_measure]
exact lintegral_mono' restrict_Union_le le_rfl
rw [restrict_union hAB hB, lintegral_add_measure]
rw [← lintegral_add_measure, restrict_inter_add_diff _ hB]
rw [← lintegral_add_measure, measure.restrict_add_restrict_compl hA]
simp only [lintegral_eq_supr_eapprox_lintegral, hf, hf.comp hg]
congr
congr 1
exact measure.map_congr hg.ae_eq_mk
rw [← supr_lintegral_measurable_le_eq_lintegral, ← supr_lintegral_measurable_le_eq_lintegral]
refine' supr₂_le fun i hi => supr_le fun h'i => _
refine' le_supr₂_of_le (i ∘ g) (hi.comp hg) _
exact le_supr_of_le (fun x => h'i (g x)) (le_of_eq (lintegral_map hi hg))
rw [restrict_map hg hs, lintegral_map hf hg]
rw [← hg.map_eq, lintegral_map hf hg.measurable]
rw [← hg.map_eq, hge.lintegral_map]
rw [← hg.map_eq, set_lintegral_map hs hf hg.measurable]
rw [← hg.map_eq, hge.restrict_map, hge.lintegral_map]
rw [← hg.set_lintegral_comp_preimage_emb hge, preimage_image_eq _ hge.injective]
simp [lintegral_congr_ae (ae_eq_dirac' hf)]
simp [lintegral_congr_ae (ae_eq_dirac f)]
rw [count, lintegral_sum_measure]
congr
exact funext fun a => lintegral_dirac' a hf
rw [count, lintegral_sum_measure]
congr
exact funext fun a => lintegral_dirac a f
rw [← lintegral_count, lintegral_const]
rw [← lintegral_count] at tsum_le_c
apply (MeasureTheory.meas_ge_le_lintegral_div a_mble.ae_measurable ε_ne_zero ε_ne_top).trans
exact Ennreal.div_le_div tsum_le_c rfl.le
funext i
simp only [Ennreal.coe_le_coe]
simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac' _ hf, mul_comm]
simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac, mul_comm]
rw [bUnion_of_singleton]
simp only [lintegral_singleton]
simp only [lintegral_countable _ s.countable_to_set, ← s.tsum_subtype']
rw [← lintegral_finset, Finset.coe_univ, measure.restrict_univ]
intro x
simp
apply measure.ext fun s hs => _
rw [with_density_apply _ hs, with_density_apply _ hs]
exact lintegral_congr_ae (ae_restrict_of_ae h)
refine' measure.ext fun s hs => _
rw [with_density_apply _ hs, measure.add_apply, with_density_apply _ hs, with_density_apply _ hs,
    ← lintegral_add_left hf]
rfl
refine' measure.ext fun s hs => _
rw [with_density_apply _ hs, measure.coe_smul, Pi.smul_apply, with_density_apply _ hs,
    smul_eq_mul, ← lintegral_const_mul r hf]
rfl
refine' measure.ext fun s hs => _
rw [with_density_apply _ hs, measure.coe_smul, Pi.smul_apply, with_density_apply _ hs,
    smul_eq_mul, ← lintegral_const_mul' r f hr]
rfl
refine' absolutely_continuous.mk fun s hs₁ hs₂ => _
rw [with_density_apply _ hs₁]
exact set_lintegral_measure_zero _ _ hs₂
rw [with_density_indicator hs, with_density_one]
rw [← lintegral_eq_zero_iff' hf, ← set_lintegral_univ, ← with_density_apply _ MeasurableSet.univ,
    h, measure.coe_zero, Pi.zero_apply]
rw [measure_to_measurable, hs]
rw [ae_with_density_iff hf, ae_restrict_iff']
· rfl
· exact hf (measurable_set_singleton 0).compl
apply Measurable.ennrealInduction
· intro c s h_ms
    simp [*, mul_comm _ c, ← indicator_mul_right]
· intro g h h_univ h_mea_g h_mea_h h_ind_g h_ind_h
    simp [mul_add, *, Measurable.mul]
· intro g h_mea_g h_mono_g h_ind
    have : Monotone fun n a => f a * g n a := fun m n hmn x =>
      Ennreal.mul_le_mul le_rfl (h_mono_g hmn x)
    simp [lintegral_supr, Ennreal.mul_supr, h_mf.mul (h_mea_g _), *]
rw [restrict_with_density hs, lintegral_with_density_eq_lintegral_mul _ hf hg]
rw [← supr_lintegral_measurable_le_eq_lintegral, ← supr_lintegral_measurable_le_eq_lintegral]
refine' supr₂_le fun i i_meas => supr_le fun hi => _
have A : f * i ≤ f * g := fun x => Ennreal.mul_le_mul le_rfl (hi x)
refine' le_supr₂_of_le (f * i) (f_meas.mul i_meas) _
exact le_supr_of_le A (le_of_eq (lintegral_with_density_eq_lintegral_mul _ f_meas i_meas))
intro x
dsimp
rw [mul_comm, ← div_eq_mul_inv]
exact div_le_of_le_mul' (hi x)
rw [restrict_with_density hs, lintegral_with_density_eq_lintegral_mul_non_measurable _ f_meas hf]
rw [with_density_congr_ae hf.ae_eq_mk]
rw [restrict_with_density hs, lintegral_with_density_eq_lintegral_mul_non_measurable₀ _ hf h'f]
rw [lintegral_congr_ae (ae_eq_of_ae_eq_trim hf.ae_eq_mk), lintegral_congr_ae hf.ae_eq_mk,
    lintegral_trim hm hf.measurable_mk]
let S := @spanning_sets _ m (μ.trim hm) _
have hS_mono : Monotone S := @monotone_spanning_sets _ m (μ.trim hm) _
have hS_meas : ∀ n, measurable_set[m] (S n) := @measurable_spanning_sets _ m (μ.trim hm) _
rw [← @Union_spanning_sets _ m (μ.trim hm)]
refine' (h_F_lim S hS_meas hS_mono).trans _
refine' supr_le fun n => hf (S n) (hS_meas n) _
exact ((le_trim hm).trans_lt (@measure_spanning_sets_lt_top _ m (μ.trim hm) _ n)).Ne
simp only [measure.restrict_univ]
refine' fun s hs hμs => (le_of_eq _).trans (hf s hs hμs)
refine' lintegral_congr_ae (ae_restrict_of_ae (hf_meas.ae_eq_mk.mono fun x hx => _))
rw [hx]
rw [set_average_eq, set_average_eq, interval_oc_swap]
rw [interval_average_eq, smul_eq_mul, div_eq_inv_mul]
rw [interval_oc_eq_union, integrable_on_union, IntervalIntegrable]
rw [interval_integrable_iff, interval_oc_of_le hab]
simp
simp
rw [integrable_on_Icc_iff_integrable_on_Ioc, integrable_on_Ioc_iff_integrable_on_Ioo]
rw [interval_integrable_iff, ← Icc_min_max, interval_oc, integrable_on_Icc_iff_integrable_on_Ioc]
rw [interval_integrable_iff_integrable_Ioc_of_le hab, integrable_on_Icc_iff_integrable_on_Ioc]
simp
simp only [interval_integrable_iff, integrable_on_const]
constructor <;> simp
simp [hp]
rw [interval_integrable_iff] at hf⊢
exact hf.mul_continuous_on_of_subset hg measurableSetIoc is_compact_interval Ioc_subset_Icc_self
rw [interval_integrable_iff] at hf⊢
exact hf.continuous_on_mul_of_subset hg is_compact_interval measurableSetIoc Ioc_subset_Icc_self
rw [interval_integrable_iff]
exact (hu.integrable_on_compact is_compact_interval).monoSet Ioc_subset_Icc_self
simp [intervalIntegral]
simp [intervalIntegral, h]
simp only [intervalIntegral, neg_sub]
simp only [integral_symm b, integral_of_le h]
rw [interval_integral_eq_integral_interval_oc, integral_non_ae_strongly_measurable hf, smul_zero]
cases le_total a b <;> simp [*, integral_symm a b]
rw [← norm_integral_min_max, integral_of_le min_le_max, interval_oc]
simp only [← Real.norm_eq_abs, norm_integral_eq_norm_integral_Ioc]
exact le_trans (norm_integral_le_integral_norm _) (le_abs_self _)
rw [interval_oc_of_le h, integral_of_le h]
simp only [interval_integral_eq_integral_interval_oc, integral_add hf.def hg.def, smul_add]
simp only [interval_integral_eq_integral_interval_oc,
    integral_finset_sum s fun i hi => (h i hi).def, Finset.smul_sum]
simp only [intervalIntegral, integral_smul, smul_sub]
simp only [interval_integral_eq_integral_interval_oc, integral_smul_const, smul_assoc]
simp only [intervalIntegral, set_integral_const, sub_smul]
simp only [integral_const', Real.volume_Ioc, Ennreal.to_real_of_real', ← neg_sub b,
    max_zero_sub_eq_self]
simp only [intervalIntegral, measure.restrict_smul, integral_smul_measure, smul_sub]
simp [intervalIntegral, A.set_integral_map]
rw [map_add_right_eq_self]
rw [← integral_comp_add_right, ← integral_comp_mul_left _ hc]
rw [← integral_comp_add_left, ← integral_comp_mul_left _ hc]
simp only [sub_eq_add_neg, neg_mul_eq_neg_mul]
rw [integral_comp_add_mul f (neg_ne_zero.mpr hc) d, integral_symm]
simp only [inv_neg, smul_neg, neg_neg, neg_smul]
rw [this]
rw [← add_neg_eq_zero, ← integral_symm, integral_add_adjacent_intervals_cancel hab hbc]
revert hint
refine' Nat.le_induction _ _ n hmn
· simp
· intro p hmp IH h
    rw [Finset.sum_Ico_succ_top hmp, IH, integral_add_adjacent_intervals]
    · apply IntervalIntegrable.transIterateIco hmp fun k hk => h k _
      exact (Ico_subset_Ico le_rfl (Nat.le_succ _)) hk
    · apply h
      simp [hmp]
    · intro k hk
      exact h _ (Ico_subset_Ico_right p.le_succ hk)
rw [← Nat.Ico_zero_eq_range]
exact sum_integral_adjacent_intervals_Ico (zero_le n) fun k hk => hint k hk.2
rw [← integral_add_adjacent_intervals hac hcd, add_assoc, add_left_comm,
    integral_add_adjacent_intervals hac (hac.symm.trans hab), add_comm]
simp only [sub_eq_add_neg, ← integral_symm,
    integral_interval_add_interval_comm hab hcd.symm (hac.trans hcd)]
rw [integral_interval_sub_interval_comm hab hcd hac, integral_symm b d, integral_symm a c,
    sub_neg_eq_add, sub_eq_neg_add]
simp only [sub_smul, ← set_integral_const]
refine' (integral_Iic_sub_Iic _ _).symm <;>
    simp only [integrable_on_const, measure_lt_top, or_true_iff]
simp only [intervalIntegral, set_integral_congr_ae measurableSetIoc h,
    set_integral_congr_ae measurableSetIoc h']
simp only [interval_integrable_iff, interval_integral_eq_integral_interval_oc, ←
    ae_restrict_iff' measurableSetIntervalOc] at *
exact
    tendsto_const_nhds.smul
      (tendsto_integral_filter_of_dominated_convergence bound hF_meas h_bound bound_integrable
        h_lim)
simp only [interval_integrable_iff, interval_integral_eq_integral_interval_oc, ←
    ae_restrict_iff' measurableSetIntervalOc] at *
exact
    (has_sum_integral_of_dominated_convergence bound hF_meas h_bound bound_summable bound_integrable
        h_lim).const_smul
apply eventually_eq_of_mem self_mem_nhds_within
exact fun b b_in => (integral_indicator b_in).symm
apply eventually.mono (compl_mem_ae_iff.mpr hb₀)
intro x hx
exact Ne.lt_or_lt hx
apply mem_nhds_within_of_mem_nhds
apply eventually.mono (Ioi_mem_nhds hx₀)
intro x hx
simp [hx.le]
apply mem_nhds_within_of_mem_nhds
apply eventually.mono (Iio_mem_nhds hx₀)
intro x hx
simp [hx]
rw [interval_swap a b] at h_int⊢
simp only [integral_symm b]
exact (continuous_on_primitive_interval h_int).neg
rw [integral_of_le hab, integral_eq_zero_iff_of_nonneg_ae hf hfi.1]
simp only [this.not_lt, hba.not_lt, false_and_iff]
simp [hsupp, hab]
simp only [← not_le, ← ae_iff] at hlt
exact
      eventually_le.antisymm ((ae_restrict_iff' measurableSetIoc).2 <| eventually_of_forall hle) hlt
rw [integral_of_le hab, integral_of_le (hca.trans (hab.trans hbd))]
exact set_integral_mono_set hfi.1 hf (Ioc_subset_Ioc hca hbd).EventuallyLe
rw [nhdsWithin, principal_singleton, inf_eq_right.2 (pure_le_nhds a)]
infer_instance
rw [nhds_within_univ]
infer_instance
simp [integral_const', hx]
simp [integral_const', hx]
simp [integral_symm (u t), add_comm]
have :=
    integral_sub_integral_sub_linear_is_o_of_tendsto_ae hf hmeas_a hmeas_b ha hb
      ((continuous_fst.comp continuous_snd).Tendsto ((a, b), (a, b)))
      ((continuous_fst.comp continuous_fst).Tendsto ((a, b), (a, b)))
      ((continuous_snd.comp continuous_snd).Tendsto ((a, b), (a, b)))
      ((continuous_snd.comp continuous_fst).Tendsto ((a, b), (a, b)))
refine' (this.congr_left _).trans_is_O _
· intro x
    simp [sub_smul]
· exact is_O_fst_prod.norm_left.add is_O_snd_prod.norm_left
rw [HasFderivWithinAt, nhds_within_prod_eq]
have :=
    integral_sub_integral_sub_linear_is_o_of_tendsto_ae hf hmeas_a hmeas_b ha hb
      (tendsto_const_pure.mono_right FTC_filter.pure_le : tendsto _ _ (𝓝[s] a)) tendsto_fst
      (tendsto_const_pure.mono_right FTC_filter.pure_le : tendsto _ _ (𝓝[t] b)) tendsto_snd
refine' (this.congr_left _).trans_is_O _
· intro x
    simp [sub_smul]
· exact is_O_fst_prod.norm_left.add is_O_snd_prod.norm_left
simp only [integral_symm b]
exact (integral_has_deriv_within_at_of_tendsto_ae_right hf.symm hmeas ha).neg
refine' le_of_forall_pos_le_add fun ε εpos => _
  -- Bound from above `g'`
rw [← interval_of_le hab] at G'int hcont⊢
exact (hcont.sub continuous_on_const).Prod (continuous_on_primitive_interval G'int)
simp only [integral_same, mem_set_of_eq, sub_self]
simp only [hM, ht.right.right, lt_min_iff, mem_Ioi, and_self_iff]
simp only [hu.left.le, MeasureTheory.integral_const, Algebra.id.smul_eq_mul, sub_nonneg,
            MeasurableSet.univ, Real.volume_Icc, measure.restrict_apply, univ_inter,
            Ennreal.to_real_of_real]
simp only [hm.trans_le hx.left,
                (hx.right.trans_lt hu.right).trans_le (min_le_left M b), mem_Ioo, and_self_iff]
refine' mem_nhds_within_Ioi_iff_exists_Ioc_subset.2 ⟨min v b, _, subset.refl _⟩
simp only [lt_min_iff, mem_Ioi]
exact ⟨t_lt_v, ht.2.2⟩
    -- choose a point `x` slightly to the right of `t` which satisfies the above bound
apply integral_add_adjacent_intervals
· rw [interval_integrable_iff_integrable_Ioc_of_le ht.2.1]
          exact
            integrable_on.mono_set G'int
              (Ioc_subset_Icc_self.trans (Icc_subset_Icc le_rfl ht.2.2.le))
· rw [interval_integrable_iff_integrable_Ioc_of_le h'x.1.le]
          apply integrable_on.mono_set G'int
          refine' Ioc_subset_Icc_self.trans (Icc_subset_Icc ht.2.1 (h'x.2.trans (min_le_right _ _)))
      
  -- now that we know that `s` contains `[a, b]`, we get the desired result
rw [← interval_of_le hab] at hcont φint⊢
exact (continuous_on_const.sub hcont).Prod (continuous_on_primitive_interval_left φint)
apply s_closed.closure_subset_iff.2
intro t ht
refine' ⟨_, ⟨ht.1.le, ht.2⟩⟩
exact
      sub_le_integral_of_has_deriv_right_of_le_Ico ht.2 (hcont.mono (Icc_subset_Icc ht.1.le le_rfl))
        (fun x hx => hderiv x ⟨ht.1.trans_le hx.1, hx.2⟩)
        (φint.mono_set (Icc_subset_Icc ht.1.le le_rfl)) fun x hx => hφg x ⟨ht.1.trans_le hx.1, hx.2⟩
refine' (NormedSpace.eq_iff_forall_dual_eq ℝ).2 fun g => _
rw [← g.interval_integral_comp_comm f'int, g.map_sub]
exact
    integral_eq_sub_of_has_deriv_right_of_le_real hab (g.continuous.comp_continuous_on hcont)
      (fun x hx => g.has_fderiv_at.comp_has_deriv_within_at x (hderiv x hx))
      (g.integrable_comp ((interval_integrable_iff_integrable_Icc_of_le hab).1 f'int))
rw [← hderiv, integral_deriv_eq_sub hdiff]
rw [hderiv]
exact hcont.interval_integrable
apply (aeMeasurableDerivWithinIoi g _).congr
refine' (ae_restrict_mem measurableSetIoo).mono fun x hx => _
exact (hderiv x hx).derivWithin (uniqueDiffWithinAtIoi _)
simp only [add_sub_cancel']
refine' (continuous_on_primitive_interval' hg1 _).comp hf _
· rw [← hf.image_interval]
      exact mem_image_of_mem f left_mem_interval
· rw [← hf.image_interval]
      exact maps_to_image _ _
rw [interval_of_le (hc.2.trans hd.1).le]
exact Icc_subset_Ioo hc.1 hd.2
rw [← hJ]
exact mem_image_of_mem _ (mem_interval_of_le hc.2.le hd.1.le)
refine' hg1.mono_set _
rw [← hf.image_interval]
exact hf.surj_on_interval left_mem_interval (Ioo_subset_Icc_self hx)
refine'
    integral_comp_smul_deriv''' hf hff' (hg.mono <| image_subset _ Ioo_subset_Icc_self) _
      (hf'.smul (hg.comp hf <| subset_preimage_image f _)).integrableOnIcc
rw [hf.image_interval] at hg⊢
exact hg.integrable_on_Icc
rw [integral_comp_smul_deriv'' hf hff' hf' hg',
    integral_eq_sub_of_has_deriv_right hg hgg' (hg'.mono _).IntervalIntegrable]
exact intermediate_value_interval hf
simp [funext_iff, torusMap, exp_ne_zero]
simp [TorusIntegrable, measure_Icc_lt_top]
rw [TorusIntegrable, torus_map_zero_radius]
apply torus_integrable_const (f c) c 0
simp only [torusIntegral, Pi.zero_apply, of_real_zero, mul_zero, zero_mul, Fin.prod_const,
    zero_pow' n hn, zero_smul, integral_zero]
simp [torusIntegral, integral_neg]
simp only [torusIntegral, integral_smul, ← smul_comm a]
simp [norm_smul]
simp only [Pi.zero_def, Real.volume_Icc_pi_to_real fun _ => real.two_pi_pos.le, sub_zero,
        Fin.prod_const, mul_assoc, mul_comm ((2 * π) ^ (n : ℕ))]
simp only [torusIntegral, Fin.prod_univ_zero, one_smul,
    Subsingleton.elim (fun i : Fin 0 => 2 * π) 0, Icc_self, measure.restrict_singleton, volume_pi,
    integral_smul_measure, integral_dirac, measure.pi_of_empty _ 0,
    measure.dirac_apply_of_mem (mem_singleton _), Subsingleton.elim (torusMap c R 0) c]
rw [average, integral_zero]
rw [average, smul_zero, integral_zero_measure]
rw [average_eq', integral_smul_measure, Ennreal.to_real_inv]
rw [average, measure_univ, inv_one, one_smul]
rw [average_eq, restrict_apply_univ]
simp only [average_eq', restrict_apply_univ]
simp only [average_eq, integral_congr_ae h]
simp only [div_eq_inv_mul, mul_smul, measure_smul_average, ← smul_add, ←
    integral_add_measure hμ hν, ← Ennreal.to_real_add (measure_ne_top μ _) (measure_ne_top ν _)]
rw [average_eq, measure.add_apply]
simp only [average_eq, integral_const, measure.restrict_apply, MeasurableSet.univ, one_smul,
    univ_inter, smul_smul, ← Ennreal.to_real_inv, ← Ennreal.to_real_mul, Ennreal.inv_mul_cancel,
    measure_ne_top μ univ, Ne.def, measure_univ_eq_zero, ae_ne_bot.1 h, not_false_iff,
    Ennreal.one_to_real]
simp only [set_average_eq, integral_const, measure.restrict_apply, MeasurableSet.univ, univ_inter,
    smul_smul, ← Ennreal.to_real_inv, ← Ennreal.to_real_mul, Ennreal.inv_mul_cancel hs₀ hs,
    Ennreal.one_to_real, one_smul]
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
dsimp [volume]
rw [← positive_compacts.coe_top]
simp [add_haar_measure_self, -positive_compacts.coe_top]
simp [hT.out]
simp
simp
simp [← Ennreal.of_real_coe_nnreal, Real.coe_to_nnreal T hT.out.le]
rw [← lintegral_map hf AddCircle.measurableMk', (AddCircle.measurePreservingMk T t).map_eq]
rw [← (AddCircle.measurePreservingMk T t).map_eq] at hf⊢
rw [integral_map add_circle.measurable_mk'.ae_measurable hf]
simp
rw [hf.interval_integral_add_eq t s, integral_add_adjacent_intervals (h_int t s) (h_int s _)]
simp only [hf.interval_integral_add_eq t 0, (hf.zsmul n).interval_integral_add_eq t 0, zero_add,
      this]
  -- First prove it for natural numbers
rw [circle_transform_deriv_eq]
exact (continuous_circle_map_inv hw).smul (continuous_circle_transform hR hf hw)
trace
      "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr is_compact.prod, \",\", expr proper_space.is_compact_closed_ball z r, \",\", expr is_compact_interval, \"]\"],\n  []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
apply continuous_abs.continuous_on
    apply cabs.comp hf
    rw [maps_to]
    tauto
simp only [Ennreal.top_add, le_top, h]
rw [lintegral_tsum fun n => (gcont n).Measurable.coeNnrealEnnreal.AeMeasurable]
rw [lintegral_add_right _ wmeas.coe_nnreal_ennreal]
rw [add_assoc, Ennreal.add_halves]
rw [Set.compl_subset_comm] at hs
exact hs h
simp only [add_assoc, Ennreal.add_halves, zero_add]
congr 1
rw [Ennreal.to_real_add int_f_ne_top Ennreal.coe_ne_top, Ennreal.coe_to_real]
simp
simp
rw [add_assoc, Ennreal.add_halves]
simp [gf x]
simp only [Ereal.to_real_coe_ennreal, Ennreal.coe_to_real, coe_coe]
exact integral_sub gp_integrable gm_integrable
simp
simp
simp
simp [hT s t hs ht hμs hμt hst]
refine' of_eq_top_imp_eq_top (fun s hs hμs => _) hT
rw [measure.smul_apply, smul_eq_mul, WithTop.mul_eq_top_iff] at hμs
simp only [hc_ne_top, or_false_iff, Ne.def, false_and_iff] at hμs
exact hμs.2
refine' of_eq_top_imp_eq_top (fun s hs hμs => _) hT
rw [measure.smul_apply, smul_eq_mul, WithTop.mul_eq_top_iff]
simp only [hc_ne_zero, true_and_iff, Ne.def, not_false_iff]
exact Or.inl hμs
refine' ⟨fin_meas_additive.zero, fun s hs hμs => _⟩
rw [Pi.zero_apply, norm_zero]
exact mul_nonneg hC to_real_nonneg
simp [hs_zero]
simp only [measure.coe_zero, Pi.zero_apply]
refine' ⟨hT.1.add hT'.1, fun s hs hμs => _⟩
rw [Pi.add_apply, add_mul]
exact (norm_add_le _ _).trans (add_le_add (hT.2 s hs hμs) (hT'.2 s hs hμs))
refine' ⟨hT.1.smul c, fun s hs hμs => _⟩
dsimp only
rw [norm_smul, mul_assoc]
exact mul_le_mul le_rfl (hT.2 s hs hμs) (norm_nonneg _) (norm_nonneg _)
intro s hs hμs
rw [eq_top_iff, ← hμs]
exact h s hs
intro s hs hcμs
simp only [hc_ne_top, Algebra.id.smul_eq_mul, WithTop.mul_eq_top_iff, or_false_iff, Ne.def,
      false_and_iff] at hcμs
exact hcμs.2
simp [set_to_simple_func]
cases isEmpty_or_nonempty α <;> simp [set_to_simple_func]
congr
rw [map_preimage_singleton]
congr
rw [← Finset.set_bUnion_preimage_singleton]
congr
rw [pair_preimage_singleton f g]
rw [smul_sum]
refine' Finset.sum_congr rfl fun x hx => _
rw [this x hx]
rfl
rw [add_eq_map₂, map_set_to_simple_func T h_add hp_pair]
simp
rw [Finset.sum_add_distrib]
rw [map_set_to_simple_func T h_add hp_pair Prod.snd_zero,
        map_set_to_simple_func T h_add hp_pair Prod.fst_zero]
rw [map_set_to_simple_func T h_add hf neg_zero, set_to_simple_func, ← sum_neg_distrib]
exact Finset.sum_congr rfl fun x h => ContinuousLinearMap.map_neg _ _
rw [smul_eq_map c f, map_set_to_simple_func T h_add hf]
rw [smul_zero]
simp only [set_to_simple_func, smul_sum, smul_smul, mul_comm]
rw [smul_eq_map c f, map_set_to_simple_func T h_add hf]
rw [smul_zero]
rw [h_smul]
simp only [set_to_simple_func, smul_sum, smul_smul, mul_comm]
refine' sum_le_sum fun i hi => _
refine' sum_nonneg fun i hi => _
rw [← sub_nonneg, ← set_to_simple_func_sub T h_add hgi hfi]
refine' set_to_simple_func_nonneg' T hT_nonneg _ _ (hgi.sub hfi)
intro x
simp only [coe_sub, sub_nonneg, coe_zero, Pi.zero_apply, Pi.sub_apply]
exact hfg x
simp only [set_to_simple_func, range_const, Set.mem_singleton, preimage_const_of_mem,
    sum_singleton, coe_const]
cases hα : isEmpty_or_nonempty α
· have h_univ_empty : (univ : Set α) = ∅ := Subsingleton.elim _ _
    rw [h_univ_empty, hT_empty]
    simp only [set_to_simple_func, ContinuousLinearMap.zero_apply, sum_empty,
      range_eq_empty_of_is_empty]
· exact set_to_simple_func_const' T x
rw [sub_eq_add_neg, set_to_L1s_add T h_zero h_add, set_to_L1s_neg h_zero h_add, sub_eq_add_neg]
rw [set_to_L1s, norm_eq_sum_mul f]
exact
    simple_func.norm_set_to_simple_func_le_sum_mul_norm_of_integrable T hT_norm _
      (simple_func.integrable f)
have h_empty : T ∅ = 0 := h_zero _ MeasurableSet.empty measure_empty
rw [set_to_L1s_eq_set_to_simple_func]
refine' Eq.trans _ (simple_func.set_to_simple_func_indicator T h_empty hs x)
refine' simple_func.set_to_simple_func_congr T h_zero h_add (simple_func.integrable _) _
exact to_simple_func_indicator_const hs hμs.ne x
rw [← sub_nonneg] at hfg⊢
rw [← set_to_L1s_sub h_zero h_add]
exact set_to_L1s_nonneg h_zero h_add hT_nonneg hfg
rw [h]
rw [this]
simp
rw [this]
simp
rw [this]
rw [← this]
congr 1
rw [this]
rw [← this]
congr 1
rw [this, ContinuousLinearMap.add_apply]
rw [← this]
congr
rw [this, ContinuousLinearMap.add_apply]
rw [← this]
congr
rw [this, ContinuousLinearMap.smul_apply]
rw [← this]
congr
rw [this, ContinuousLinearMap.smul_apply]
rw [← this]
congr
rw [set_to_L1_eq_set_to_L1' hT h_smul, set_to_L1_eq_set_to_L1' hT h_smul]
exact ContinuousLinearMap.map_smul _ _ _
rw [set_to_L1_eq_set_to_L1s_clm]
exact set_to_L1s_indicator_const (fun s => hT.eq_zero_of_measure_zero) hT.1 hs hμs x
rw [← Lp.simple_func.coe_indicator_const hs hμs x]
exact set_to_L1_simple_func_indicator_const hT hs hμs.lt_top x
refine' Lp.induction one_ne_top _ _ _ _ f
· intro c s hs hμs
    rw [set_to_L1_simple_func_indicator_const hT hs hμs,
      set_to_L1_simple_func_indicator_const hT' hs hμs]
    exact hTT' s hs hμs c
· intro f g hf hg hfg_disj hf_le hg_le
    rw [(set_to_L1 hT).map_add, (set_to_L1 hT').map_add]
    exact add_le_add hf_le hg_le
· exact is_closed_le (set_to_L1 hT).Continuous (set_to_L1 hT').Continuous
rw [← sub_nonneg] at hfg⊢
rw [← (set_to_L1 hT).map_sub]
exact set_to_L1_nonneg hT hT_nonneg hfg
refine'
        ContinuousLinearMap.op_norm_extend_le (set_to_L1s_clm α E μ hT) (coe_to_Lp α E ℝ)
          (simple_func.dense_range one_ne_top) fun x => le_of_eq _
rw [Nnreal.coe_one, one_mul]
rfl
rw [Nnreal.coe_one, one_mul]
rw [set_to_fun_eq hT (L1.integrable_coe_fn f), integrable.to_L1_coe_fn]
rw [set_to_fun_eq hT]
· simp only [integrable.to_L1_zero, ContinuousLinearMap.map_zero]
· exact integrable_zero _ _ _
rw [set_to_fun_eq hT (hf.add hg), set_to_fun_eq hT hf, set_to_fun_eq hT hg, integrable.to_L1_add,
    (L1.set_to_L1 hT).map_add]
rw [sub_eq_add_neg, sub_eq_add_neg, set_to_fun_add hT hf hg.neg, set_to_fun_neg hT g]
rw [integrable_congr h] at hfi
exact hfi
simp [h]
rw [set_to_fun_congr_ae hT (@indicator_const_Lp_coe_fn _ _ _ 1 _ _ _ hs hμs x).symm]
rw [L1.set_to_fun_eq_set_to_L1 hT]
exact L1.set_to_L1_indicator_const_Lp hT hs hμs x
have : (fun _ : α => x) = Set.indicator univ fun _ => x := (indicator_univ _).symm
rw [this]
exact set_to_fun_indicator_const hT MeasurableSet.univ (measure_ne_top _ _) x
rw [← sub_nonneg, ← set_to_fun_sub hT hg hf]
refine' set_to_fun_nonneg hT hT_nonneg (hfg.mono fun a ha => _)
rw [Pi.sub_apply, Pi.zero_apply, sub_nonneg]
exact ha
simp
refine' tendsto_set_to_fun_approx_on_of_measurable hT hf fmeas _ _ (integrable_zero _ _ _)
exact eventually_of_forall fun x => subset_closure (hs (Set.mem_union_left _ (mem_range_self _)))
rw [← measure.nonpos_iff_eq_zero']
refine' hμ'_le.trans _
simp [hc'0]
rw [← snorm_congr_ae (Lp.coe_fn_sub _ _)]
exact Lp.snorm_ne_top _
refine' ((snorm_mono_measure _ hμ'_le).trans_lt _).Ne
rw [snorm_smul_measure_of_ne_zero hc'0, smul_eq_mul]
refine' Ennreal.mul_lt_top _ h_snorm_ne_top
simp [hc', hc'0]
refine' mul_div_cancel' (ε / 2) _
rw [Ne.def, to_real_eq_zero_iff]
simp [hc', hc'0]
refine' ((hμ'_le s hs).trans_lt _).Ne
rw [measure.smul_apply, smul_eq_mul]
exact Ennreal.mul_lt_top hc' hμs.ne
refine' set_to_fun_measure_zero' hT fun s hs hμs => _
rw [lt_top_iff_ne_top] at hμs
simp only [true_and_iff, measure.smul_apply, WithTop.mul_eq_top_iff, eq_self_iff_true,
    top_ne_zero, Ne.def, not_false_iff, not_or, not_not, smul_eq_mul] at hμs
simp only [hμs.right, measure.smul_apply, mul_zero, smul_eq_mul]
rw [L1.set_to_fun_eq_set_to_L1]
exact L1.norm_set_to_L1_le_mul_norm hT hC f
rw [L1.set_to_fun_eq_set_to_L1]
exact L1.norm_set_to_L1_le_mul_norm' hT f
rw [set_to_fun_eq hT hf]
exact L1.norm_set_to_L1_le_mul_norm hT hC _
rw [set_to_fun_eq hT hf]
exact L1.norm_set_to_L1_le_mul_norm' hT _
exact MeasureTheory.MeasureSpace.volume
simp
exact MeasureTheory.MeasureSpace.volume
simp [integrable_on, integrable_zero_measure]
rw [integrable_on, measure.restrict_univ]
rw [measure.restrict_apply_univ]
rw [integrable_on, measure.restrict_restrict hs]
exact h.mono_set (inter_subset_left _ _)
apply hs.induction_on
· simp
· intro a s ha hs hf
    simp [hf, or_imp, forall_and]
delta integrable_on
rw [measure.restrict_add]
exact hμ.integrable.add_measure hν
simp only [integrable_on, he.restrict_map, he.integrable_map_iff]
simp only [integrable_on, e.restrict_map, integrable_map_equiv e]
simp [integrable_on, integrable, has_finite_integral, nnnorm_indicator_eq_indicator_nnnorm,
    Ennreal.coe_indicator, lintegral_indicator _ hs, ae_strongly_measurable_indicator_iff hs]
exact MeasureTheory.MeasureSpace.volume
refine' ⟨fun hfg => ⟨_, _⟩, fun h => h.1.add h.2⟩
· rw [← indicator_add_eq_left h]
    exact hfg.indicator hf.measurable_set_support
· rw [← indicator_add_eq_right h]
    exact hfg.indicator hg.measurable_set_support
intro X
exact (continuous_const.mul continuous_id).exp.integrableOnIoc
simp only [← set_integral_congr_set_ae (box.coe_ae_eq_Icc _)]
have A := (Hi.mono_set box.coe_subset_Icc).hasBoxIntegral
simp only [integrable_on, ← measure.restrict_congr_set (box.Ioo_ae_eq_Icc _)] at Hi⊢
rw [← box.Union_Ioo_of_tendsto J.monotone hJl hJu] at Hi⊢
exact
      tendsto_set_integral_of_monotone (fun k => (J k).measurableSetIoo) (box.Ioo.comp J).Monotone
        Hi
  -- Thus it suffices to prove the same about the RHS.
rw [← hIcc, eL.symm_preimage_preimage]
simp only [hDF]
rw [← he_vol.set_integral_preimage_emb he_emb]
simp only [hIcc, eL.symm_apply_apply]
simp only [intervalIntegral.integral_of_le hle, set_integral_congr_set_ae Ioc_ae_eq_Icc]
simp only [← interior_Icc] at Hd
refine'
        integral_divergence_of_has_fderiv_within_at_off_countable_of_equiv e _ _ (fun _ => f)
          (fun _ => F') s hs a b hle (fun i => Hc) (fun x hx i => Hd x hx) _ _ _
· exact fun x y => (OrderIso.funUnique (Fin 1) ℝ).symm.le_iff_le
· exact (volume_preserving_fun_unique (Fin 1) ℝ).symm _
· intro x
        rw [Fin.sum_univ_one, hF', e_symm, Pi.single_eq_same, one_smul]
· rw [interval_integrable_iff_integrable_Ioc_of_le hle] at Hi
        exact Hi.congr_set_ae Ioc_ae_eq_Icc.symm
simp only [Fin.sum_univ_one, e_symm]
have : ∀ c : ℝ, const (Fin 0) c = isEmptyElim := fun c => Subsingleton.elim _ _
simp [this, volume_pi, measure.pi_of_empty fun _ : Fin 0 => volume]
refine'
        integral_divergence_of_has_fderiv_within_at_off_countable_of_equiv e _ _ ![f, g] ![f', g'] s
          hs a b hle _ (fun x hx => _) _ _ Hi
· exact fun x y => (OrderIso.finTwoArrowIso ℝ).symm.le_iff_le
· exact (volume_preserving_fin_two_arrow ℝ).symm _
· exact Fin.forall_fin_two.2 ⟨Hcf, Hcg⟩
· rw [Icc_prod_eq, interior_prod_eq, interior_Icc, interior_Icc] at hx
        exact Fin.forall_fin_two.2 ⟨Hdf x hx, Hdg x hx⟩
· intro x
        rw [Fin.sum_univ_two]
        simp
simp only [intervalIntegral.integral_of_le, h₁, h₂, set_integral_congr_set_ae Ioc_ae_eq_Icc]
rw [Icc_prod_Icc] at *
apply
            integral_divergence_prod_Icc_of_has_fderiv_within_at_off_countable_of_le f g f' g'
              (a₁, a₂) (b₁, b₂) ⟨h₁, h₂⟩ s <;>
          assumption
intro t ht
cases eq_or_lt_of_le ht
· simp [← h]
· exact g_intble t h
funext a
funext a
funext p
cases p
rw [Function.uncurry_apply_pair]
refine' AeMeasurable.exists_measurable_nonneg _ g_nn
exact aeMeasurableIoiOfForallIoc fun t ht => (g_intble t ht).1.1.AeMeasurable
refine' fun t t_pos => ⟨integrable_on.congr_fun' (g_intble t t_pos).1 (g_eq_G_on t), _⟩
rw [Ioc_eq_empty_of_le t_pos.lt.le]
exact integrable_on_empty
refine' fun ω => intervalIntegral.integral_congr_ae _
have fω_nn : 0 ≤ f ω := f_nn ω
rw [interval_oc_of_le fω_nn, ←
      ae_restrict_iff' (measurableSetIoc : MeasurableSet (Ioc (0 : ℝ) (f ω)))]
exact g_eq_G_on (f ω)
intro x
rw [integral_rpow (Or.inl one_lt_p)]
simp [Real.zero_rpow p_pos.ne.symm]
rw [uni,
      measure_union (disjoint_iff_inter_eq_empty.mpr disj)
        (g_mble (finite.measurable_set (finite_singleton t)))]
let R := scaling_scale_of μ (max (4 * K + 3) 3)
simp only [VitaliFamily, VitaliFamily.enlarge, Vitali.vitaliFamily, mem_union, mem_set_of_eq,
    is_closed_ball, true_and_iff, (nonempty_ball.2 rpos).mono ball_subset_interior_closed_ball,
    measurableSetClosedBall]
  /- The measure is doubling on scales smaller than `R`. Therefore, we treat differently small
    and large balls. For large balls, this follows directly from the enlargement we used in the
    definition. -/
apply closed_ball_subset_closed_ball
exact mul_le_mul_of_nonneg_right (le_max_left _ _) rpos.le
intro c hc
simp
simp only [Function.onFun, closed_ball_eq_empty.2 (ht a ha), empty_disjoint]
simp only [closed_ball_eq_empty.2 (ht a ha), empty_subset]
simp only [closed_ball_eq_empty.2 h'a, empty_subset]
intro a ha
apply ha.2.trans (hR1 (c a))
intro a hav
apply dist_le_add_of_nonempty_closed_ball_inter_closed_ball
refine' hav.2.mono _
apply inter_subset_inter _ ball_subset_closed_ball
exact hB a (ut (vu hav))
rw [measure_bUnion (u_count.mono vu) _ fun a ha => (h't _ (vu.trans ut ha)).MeasurableSet]
exact u_disj.subset vu
simp only [Ennreal.div_pos_iff, εpos.ne', Ennreal.coe_ne_top, Ne.def, not_false_iff,
        and_self_iff]
apply IsOpen.mem_nhds (is_open_ball.sdiff k_closed) _
exact (mem_diff _).2 ⟨mem_of_mem_inter_right hz, z_notmem_k⟩
refine' (hB a hat).trans _
refine' subset.trans _ (hd.trans (diff_subset (ball x (R x)) k))
exact closed_ball_subset_closed_ball (ad.trans (min_le_left _ _))
    -- it intersects an element `b` of `u` with comparable diameter,
refine' ⟨bu, ab.mono _⟩
rw [inter_comm]
exact inter_subset_inter_right _ ax
apply ab.mono (inter_subset_inter _ b'k)
refine' ((hB _ hat).trans _).trans hd
exact closed_ball_subset_closed_ball (ad.trans (min_le_left _ _))
simp only [subset_union_left, diff_union_self]
rw [hρ h.measure_diff_bUnion,
        measure_bUnion h.index_countable h.covering_disjoint fun x hx => h.measurable_set_u hx,
        zero_add]
intro s f fset ffine
let g : α → Set (Set α) := fun x => f x
simp only [filter_at, exists_prop, gt_iff_lt]
rw [mem_binfi_of_directed]
· simp only [subset_def, and_imp, exists_prop, mem_sep_iff, mem_Ioi, mem_principal]
· simp only [DirectedOn, exists_prop, ge_iff_le, le_principal_iff, mem_Ioi, Order.Preimage,
      mem_principal]
    intro x hx y hy
    refine'
      ⟨min x y, lt_min hx hy, fun a ha =>
        ⟨ha.1, ha.2.trans (closed_ball_subset_closed_ball (min_le_left _ _))⟩, fun a ha =>
        ⟨ha.1, ha.2.trans (closed_ball_subset_closed_ball (min_le_right _ _))⟩⟩
· exact ⟨(1 : ℝ), mem_Ioi.2 zero_lt_one⟩
simp (config := { contextual := true }) only [eventually_filter_at_iff, exists_prop, and_true_iff,
    gt_iff_lt, imp_true_iff]
exact ⟨1, zero_lt_one⟩
simp only [v.eventually_filter_at_iff]
exact ⟨ε, hε, fun a ha ha' => ha'⟩
simp only [Filter.Frequently, eventually_filter_at_iff, not_exists, exists_prop, not_and, not_not,
    not_forall]
simp [satellite_config.center_and_rescale]
simp [satellite_config.center_and_rescale, inv_mul_cancel (a.rpos _).ne']
rw [dist_zero_right]
exact add_le_add le_rfl (hs x hx)
simp only [μ.add_haar_ball_of_pos _ ρpos]
simp
simp only [Fintype.card_fin]
exact s_card
simp
intro n
simp only [pi_norm_le_iff_of_nonneg zero_le_two, mem_closed_ball, dist_zero_right,
          (hF (u n) (zero_lt_u n)).left, forall_const]
intro i j hij
rw [Finset.card_image_of_injective _ finj]
exact Finset.card_fin N
simp only [hf, forall_apply_eq_imp_iff', forall_const, forall_exists_index, Finset.mem_univ,
        Finset.mem_image]
rw [h] at hij
exact hij rfl
intro i j hij
rw [Finset.card_image_of_injective _ finj]
exact Finset.card_fin n
simp only [h, forall_apply_eq_imp_iff', forall_const, forall_exists_index, Finset.mem_univ,
        Finset.mem_image, imp_true_iff]
rw [h] at hij
exact hij rfl
rw [inv_eq_one_div, le_div_iff τpos]
exact I
intro k
rw [inv_eq_one_div, div_le_iff τpos, ← lastr, mul_comm]
exact a.hlast' k hτ
rw [← mul_assoc]
apply mul_le_mul_of_nonneg_right J (a.rpos _).le
rw [one_mul]
exact H.1
simp only [← dist_eq_norm, dist_triangle]
apply lt_top_iff_ne_top.2
intro iN
change i = last N at iN
rw [iN, lastc, norm_zero] at hi
exact lt_irrefl _ (zero_le_two.trans_lt hi)
simp [← dist_eq_norm, dist_triangle]
rw [Subsingleton.elim i (last 0)] at hi
exact (lt_irrefl _ hi).elim
rw [Subsingleton.elim i (last 0)] at hi
exact (lt_irrefl _ hi).elim
exact j.2
intro i j hij
simp only [Union_up_to]
exact Union_mono' fun r => ⟨⟨r, r.2.trans_le hij⟩, subset.rfl⟩
exact j.2
rw [tau_package.index]
rfl
apply lt_trans (mul_pos (_root_.zero_lt_one.trans p.one_lt_tau) (p.rpos _)) H
rw [color]
simp only [not_exists, true_and_iff, exists_prop, mem_Union, mem_singleton_iff, mem_closed_ball,
      not_and, mem_univ, mem_diff, Subtype.exists, Subtype.coe_mk]
intro j ji hj
exact (IH j ji (ji.trans hi)).ne'
rw [index]
rfl
intro H
exact (fGn b hb).1 (p.monotone_Union_up_to G_lt.le H)
dsimp [G]
simp [I.ne, (hg a I).1]
dsimp [G]
simp only [if_true, eq_self_iff_true]
dsimp [G]
simp [I.ne, (hg a I).1]
rw [tau_package.color]
rw [color_j]
apply Inf_mem
refine' ⟨N, _⟩
simp only [not_exists, true_and_iff, exists_prop, mem_Union, mem_singleton_iff, not_and,
        mem_univ, mem_diff, Subtype.exists, Subtype.coe_mk]
intro k hk H
exact (p.color_lt (hk.trans jy_lt) hN).ne'
simp only [Finset.coe_empty, empty_subset]
intro i
refine' (hu i).countable_of_nonempty_interior fun j hj => _
have : (ball (j : α) (r j)).Nonempty := nonempty_ball.2 (a.rpos _)
exact this.mono ball_subset_interior_closed_ball
simp only [Finset.card_fin, Finset.sum_const, nsmul_eq_mul]
rw [Ennreal.mul_div_cancel']
· simp only [Npos, Ne.def, Nat.cast_eq_zero, not_false_iff]
· exact Ennreal.nat_ne_top _
apply Ennreal.exists_le_of_sum_le _ S
exact ⟨⟨0, bot_lt_iff_ne_bot.2 Npos⟩, Finset.mem_univ _⟩
simp only [inter_Union]
rw [B]
exact ennreal.summable.has_sum
rw [μo, ← add_mul, Ennreal.div_add_div_same, add_comm, Ennreal.div_self, one_mul] <;> simp
intro k hk l hl hkl
exact hu i k.2 l.2 (subtype.coe_injective.ne hkl)
intro h
rw [h] at hkl
exact hkl rfl
simp only [hB, empty_disjoint]
simp only [u, Function.comp_apply, Function.iterate_succ']
intro n
apply measure_mono
apply diff_subset_diff (subset.refl _)
exact bUnion_subset_bUnion_left (subset_Union (fun i => (u i : Set (α × ℝ))) n)
rw [u_succ]
exact (hF (u n) (Pu n)).2.2
rw [pow_succ, mul_assoc]
exact Ennreal.mul_le_mul le_rfl IH
let g x := f x
simp [I _ hxp, I _ hxrx]
simp (config := { contextual := true }) only [inj_on, Prod.mk.inj_iff, imp_true_iff,
        eq_self_iff_true]
simp only [hε, Ennreal.nat_ne_top, WithTop.mul_eq_top_iff, Ne.def, Ennreal.div_zero_iff,
          Ennreal.one_ne_top, not_false_iff, and_false_iff, false_and_iff, or_self_iff,
          Ennreal.bit0_eq_top_iff]
intro i
apply (S_disj i).countable_of_nonempty_interior fun j hj => _
have : (ball (j : α) (r1 j)).Nonempty := nonempty_ball.2 (q.rpos _)
exact this.mono ball_subset_interior_closed_ball
simp only [not_exists, exists_prop, mem_Union, mem_closed_ball, not_and, not_lt, not_le,
        mem_diff, not_forall]
intro h'x
refine' ⟨x, hx, _⟩
rw [dist_self]
exact (hr0 x hx).2.1.le
apply measure_mono
simp only [SetCoe.forall, Subtype.coe_mk, Union_subset_iff]
intro x hx
apply subset.trans (closed_ball_subset_ball (hr0 x hx).2.2) (hR x (t0s hx)).2
apply measure_mono
simp only [SetCoe.forall, Subtype.coe_mk, Union_subset_iff]
intro x xs' xSi
exact (hr1 x xs').2
refine' add_le_add A _
refine' Finset.sum_le_sum _
intro i hi
exact B i
refine' add_le_add le_rfl _
simp only [Finset.card_fin, Finset.sum_const, nsmul_eq_mul, Ennreal.mul_div_le]
rw [add_assoc, Ennreal.add_halves]
simp only [tsum_zero, add_zero]
rw [measure_Union h.covering_disjoint_subtype fun i => h.measurable_set_u i.2]
rw [μo, add_zero]
apply Ennreal.mul_le_mul le_rfl
refine' v.measure_le_of_frequently_le ρ ((measure.absolutely_continuous.refl μ).smul ε) _ _
intro x hx
rw [hs] at hx
simp only [mem_inter_iff, not_lt, not_eventually, mem_set_of_eq] at hx
exact hx.1
rw [ρo, mul_zero]
apply (Ennreal.mul_lt_mul_right h _).2 (Ennreal.coe_lt_coe.2 hcd)
exact (lt_of_le_of_lt (measure_mono (inter_subset_right _ _)) μo).Ne
simp only [H, tsum_zero]
      
  -- now starts the nontrivial part of the argument. We fix `m` and `n`, and show that the
  -- measurable supersets of `u m` and `w n` have zero measure intersection
apply (lt_of_le_of_lt (measure_mono _) (measure_spanning_sets_lt_top (ρ + μ) m)).Ne
exact inter_subset_right _ _
apply (lt_of_le_of_lt (measure_mono _) (measure_spanning_sets_lt_top (ρ + μ) n)).Ne
exact inter_subset_right _ _
simp only [coe_nnreal_smul_apply,
          measure_to_measurable_add_inter_right (measurable_set_to_measurable _ _) I]
apply Ennreal.aeMeasurableOfExistAlmostDisjointSupersets _ _ fun p q hpq => _
exact v.exists_measurable_supersets_lim_ratio hρ hpq
rw [inter_union_compl]
rw [add_zero]
exact Ennreal.mul_le_mul le_rfl (measure_mono (inter_subset_left _ _))
rw [inter_union_compl]
apply add_le_add H
rw [coe_nnreal_smul_apply]
exact Ennreal.mul_le_mul le_rfl (measure_mono (inter_subset_right _ _))
rw [A, mul_zero, add_zero]
exact measure_mono (inter_subset_left _ _)
apply Ennreal.Tendsto.mul_const _ (Or.inr ρs)
exact Ennreal.tendsto_inv_iff.2 (Ennreal.tendsto_coe_nhds_top.2 tendsto_id)
intro q hq
apply v.measure_le_mul_of_subset_lim_ratio_meas_lt hρ
intro y hy
have : v.lim_ratio_meas hρ y = 0 := hy.1
simp only [this, mem_set_of_eq, hq, Ennreal.coe_pos]
apply Ennreal.Tendsto.mul_const _ (Or.inr μs)
rw [Ennreal.tendsto_coe]
exact nhds_within_le_nhds
apply le_trans (le_of_eq _) (zero_le _)
apply with_density_absolutely_continuous μ _
rw [← nonpos_iff_eq_zero]
exact (measure_mono (inter_subset_right _ _)).trans (v.measure_lim_ratio_meas_top hρ).le
simp only [lintegral_const, MeasurableSet.univ, measure.restrict_apply, univ_inter]
refine' le_trans (measure_mono (inter_subset_right _ _)) (le_trans (le_of_eq _) (zero_le _))
exact v.measure_lim_ratio_meas_zero hρ
apply le_trans (le_of_eq _) (zero_le _)
apply hρ
rw [← nonpos_iff_eq_zero]
exact (measure_mono (inter_subset_right _ _)).trans (v.measure_lim_ratio_meas_top hρ).le
rw [← Ennreal.coe_zpow t_ne_zero']
apply v.measure_le_mul_of_subset_lim_ratio_meas_lt hρ
intro x hx
apply hx.2.2.trans_le (le_of_eq _)
rw [Ennreal.coe_zpow t_ne_zero']
simp only [lintegral_const, MeasurableSet.univ, measure.restrict_apply, univ_inter]
apply lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => _))
rw [add_comm, Ennreal.zpow_add t_ne_zero Ennreal.coe_ne_top, zpow_one]
exact Ennreal.mul_le_mul le_rfl hx.2.1
refine' Ennreal.Tendsto.mul _ _ tendsto_const_nhds _
· exact Ennreal.Tendsto.pow (Ennreal.tendsto_coe.2 nhds_within_le_nhds)
· simp only [one_pow, Ennreal.coe_one, true_or_iff, Ne.def, not_false_iff, one_ne_zero]
· simp only [one_pow, Ennreal.coe_one, Ne.def, or_true_iff, Ennreal.one_ne_top, not_false_iff]
refine' Ennreal.Tendsto.mul_const (Ennreal.tendsto_coe.2 nhds_within_le_nhds) _
simp only [Ennreal.coe_one, true_or_iff, Ne.def, not_false_iff, one_ne_zero]
apply ae_mono restrict_le_self
apply ae_tendsto_measure_inter_div_of_measurable_set
exact measurable_set_to_measurable _ _
apply lintegral_mono
intro x
dsimp
rw [← Ennreal.coe_add]
exact Ennreal.coe_le_coe.2 (nnnorm_sub_le _ _)
simp only [integrable_indicator_iff (IsOpen.measurableSet (A.set_mem n)),
              integrable_on_const, A.finite n, or_true_iff]
refine' add_le_add _ _
· rw [Ennreal.div_lt_iff (Or.inl h'a.ne') (Or.inl h''a.ne)] at ha
        exact ha.le
· simp only [lintegral_const, measure.restrict_apply, MeasurableSet.univ, univ_inter]
        exact mul_le_mul_right' xc.le _
rw [← add_mul, Ennreal.add_halves]
simp [← hr0]
refine' le_trans (add_le_add_right hj₂ _) _
rw [← measure_union' hj₁ measurableSetClosedBall]
exact measure_mono (union_subset (h₁ j) (h₂ j))
rw [inv_mul_cancel_left₀ hM.ne' (r i)]
refine'
      tendsto_nhds_within_iff.mpr
        ⟨tendsto.if' hr tendsto_one_div_add_at_top_nhds_0_nat, eventually_of_forall fun i => _⟩
apply countable.mono _ f.mono.countable_not_continuous_at
intro x hx h'x
apply hx
exact tendsto_nhds_unique (f.mono.tendsto_left_lim x) (h'x.tendsto.mono_left nhds_within_le_nhds)
simp
simp only [ext_iff, exists_prop, Finset.set_bUnion_coe, mem_Union, forall_const, iff_self_iff,
        finite.mem_to_finset]
rw [← f.length_Ioc]
apply outer_le_length
refine' ContinuousWithinAt.sub _ continuous_within_at_const
exact (f.right_continuous a).mono Ioi_subset_Ici_self
apply ennreal.continuous_of_real.continuous_at.comp_continuous_within_at
refine' ContinuousWithinAt.sub _ continuous_within_at_const
exact (f.right_continuous q').mono Ioi_subset_Ici_self
rw [sub_add_sub_cancel]
simp only [Ennreal.of_real_coe_nnreal, le_rfl]
rw [Ennreal.tsum_add]
simp [add_assoc, Ennreal.add_halves]
rw [borel_eq_generate_from_Ioi]
refine' MeasurableSpace.generate_from_le _
simp (config := { contextual := true }) [f.measurable_set_Ioi]
rw [StieltjesFunction.measure]
exact f.outer_Ioc a b
simp [mem_singleton_iff.1 hx, u_lt_a]
apply (f.mono.tendsto_left_lim a).comp
exact
        tendsto_nhds_within_of_tendsto_nhds_of_eventually_within _ u_lim
          (eventually_of_forall fun n => u_lt_a n)
simp
simp
simp
simp
intro i
rw [measure_to_measurable]
exact (h i).ae_eq_mk
rw [← sum_cond, ae_measurable_sum_measure_iff, Bool.forall_bool, and_comm]
rfl
simp only [union_eq_Union, ae_measurable_Union_iff, Bool.forall_bool, cond, and_comm]
apply MeasureTheory.Measure.map_congr
exact hg.ae_eq_mk
apply MeasureTheory.Measure.map_congr
exact ae_of_ae_map hf hg.ae_eq_mk
rw [measure_to_measurable, ← compl_mem_ae_iff, compl_compl]
exact H.ae_eq_mk.and ht
rw [interval_oc_eq_union, ae_measurable_union_iff]
rw [← map_comap_subtype_coe hs, (MeasurableEmbedding.subtypeCoe hs).ae_measurable_map_iff]
rw [Union_Ioc_eq_Ioi_self_iff.mpr _]
rw [tendsto_at_top_at_top] at hu_tendsto
exact fun y _ => ⟨(hu_tendsto y).some, (hu_tendsto y).some_spec (hu_tendsto y).some le_rfl⟩
congr 1
apply measure.map_congr hf.ae_eq_mk
simp
simp
simp
simp [apply_eq_coe_to_fun, μ.mono' _ _ h]
simp [apply_eq_coe_to_fun, μ.sup_disjoint' _ _ h]
have := μ.sup_disjoint'
intro t K
refine' Finset.induction_on t _ _
· simp only [μ.empty, nonpos_iff_eq_zero, Finset.sum_empty, Finset.sup_empty]
· intro n s hn ih
      rw [Finset.sup_insert, Finset.sum_insert hn]
      exact le_trans (μ.sup_le _ _) (add_le_add_left ih _)
simp only [ht]
refine' (compacts.equiv f).Surjective.supr_congr _ fun K => supr_congr_Prop image_subset_iff _
intro hK
simp only [Equiv.coe_fn_mk, Subtype.mk_eq_mk, Ennreal.coe_eq_coe, compacts.equiv]
apply h
exact (ennreal.mul_pos_iff.mp <| hK.bot_lt.trans_le this).2
rw [content.outer_measure, induced_outer_measure_eq_infi]
· exact le_infi fun U => le_infi fun hU => le_infi <| μ.le_inner_content K ⟨U, hU⟩
· exact μ.inner_content_Union_nat
· exact μ.inner_content_mono
apply μ.outer_measure_le ⟨interior F, is_open_interior⟩ ⟨F, h1F⟩ interior_subset
dsimp [opens]
rw [Subtype.forall]
apply induced_outer_measure_caratheodory
apply inner_content_Union_nat
apply inner_content_mono'
simp only [union_subset_iff, compacts.coe_sup, hM, hL, and_self_iff]
refine' ⟨fun K hK => _⟩
rw [measure_apply _ hK.measurable_set]
exact μ.outer_measure_lt_top_of_is_compact hK
rw [ae_disjoint, disjoint_iff_inter_eq_empty.1 h, measure_empty]
simp only [ae_disjoint, Union_inter, measure_Union_null_iff]
simp only [ae_disjoint, inter_Union, measure_Union_null_iff]
simp [union_eq_Union, and_comm]
simp [union_eq_Union, and_comm]
rw [← sum_cond, sum_left, Bool.forall_bool, cond, cond, and_comm]
rw [sUnion_eq_bUnion, m.bUnion_null_iff hS]
rw [union_diff_self, union_eq_self_of_subset_left hsS]
rw [add_assoc, tsub_add_cancel_of_le hnj.nat_succ_le]
rw [ht, zero_add]
cases μ₁
cases μ₂
congr
exact h
rw [he, empty', empty']
simp [outer_measure.empty]
rw [← smul_one_mul c (m s), ← smul_one_mul c (m t)]
exact Ennreal.mul_left_mono (m.mono h)
simp only [coe_zero, Pi.zero_apply, coe_bot, zero_le]
rw [supr, Sup_apply, supr_range, supr]
rw [supr_apply, _root_.supr_apply]
simp only [smul_apply, supr_apply, ← smul_one_mul c (f _ _), ← smul_one_mul c (supr _),
      Ennreal.mul_supr]
rw [preimage_Union] <;> exact m.Union_nat fun i => f
simp only [map_apply, sup_apply]
simp only [map_apply, supr_apply]
simp
simp only [indicator_of_not_mem hs, zero_le]
simp
rw [Ennreal.tsum_comm] <;> exact Ennreal.tsum_le_tsum fun i => (f i).Union_nat _
simp only [smul_apply, smul_eq_mul, dirac_apply, ← indicator_mul_right _ fun _ => a, mul_one]
simp
rw [image_Union]
apply m.Union_nat
simp only [comap_apply, supr_apply]
simp [restrict]
simp only [restrict_apply]
exact (hm _).trans (m'.mono <| inter_subset_inter_right _ h)
simp
simp
simp [restrict]
simp only [image_preimage_eq_inter_range, Subtype.range_coe]
rw [map_apply, comap_apply, hf.image_preimage]
rw [comap_apply, map_apply, hf.preimage_image]
simp [smul_dirac_apply, as]
simp [h]
simp [h, h.ne_empty]
rw [comap_apply, top_apply hs, top_apply (hs.image _)]
rw [map_apply, restrict_apply, ← image_preimage_eq_inter_range, top_apply', top_apply',
      Set.image_eq_empty]
rw [map_top, hf.range_eq, restrict_univ]
simp [m_empty]
simp
rw [map_apply]
apply of_function_le
simp only [restrict, LinearMap.comp_apply, comap_of_function _ (Or.inl hm),
    map_of_function Subtype.coe_injective, Subtype.image_preimage_coe]
simp [m_empty]
simp [not_nonempty_empty]
simp [is_caratheodory, m.empty, diff_empty]
simp [is_caratheodory, diff_eq, add_comm]
rw [h₁, Set.inter_assoc, Set.union_inter_cancel_left, inter_diff_assoc, union_diff_cancel_left h]
simp [Nat.not_lt_zero]
rw [bUnion_lt_succ] <;>
      exact
        is_caratheodory_union m
          (is_caratheodory_Union_lt fun i hi => h i <| lt_of_lt_of_le hi <| Nat.le_succ _)
          (h n (le_refl (n + 1)))
rw [← is_caratheodory_compl_iff, Set.compl_inter]
exact is_caratheodory_union _ (is_caratheodory_compl _ h₁) (is_caratheodory_compl _ h₂)
simp [Nat.not_lt_zero, m.empty]
refine' le_antisymm (m.Union_nat s) _
rw [Ennreal.tsum_eq_supr_nat]
refine' supr_le fun n => _
have := @is_caratheodory_sum _ m _ h hd univ n
simp at this
simp [this]
exact m.mono (Union₂_subset fun i _ => subset_Union _ i)
simp [ht]
simp only [ht, top_apply, le_top]
simp [hs₁ t, hs₂ t, add_left_comm, add_assoc]
simp [fun i => MeasurableSpace.measurable_set_infi.1 h i t, Ennreal.tsum_add]
simp [h t, mul_add]
refine' le_antisymm _ _
· refine' le_bounded_
simp [hm, h]
rw [infi, Inf_apply (range_nonempty m)]
simp only [infi_range]
rw [infi, Inf_apply' hs]
simp only [infi_range]
simp only [← infi_subtype'', infi_apply' _ hs]
refine' ext_nonempty fun s hs => _
refine' ((comap_mono f).map_infi_le s).antisymm _
simp only [comap_apply, infi_apply' _ hs, infi_apply' _ (hs.image _), le_infi_iff,
    Set.image_subset_iff, preimage_Union]
refine' fun t ht => infi_le_of_le _ (infi_le_of_le ht <| Ennreal.tsum_le_tsum fun k => _)
exact infi_mono fun i => (m i).mono (image_preimage_subset _ _)
refine' Eq.trans _ (map_comap _ _)
simp only [comap_infi, comap_map hf]
rw [Subtype.range_coe]
simp only [Inf_eq_infi, restrict_binfi, hm, infi_image]
simp [extend, h]
simp [extend, h]
simp only [extend, le_infi_iff]
intro
rfl
congr
refine' le_infi _
intro h₂
rw [extend_eq m h₁]
exact m_mono h₁ h₂ hs
cases nonempty_encodable β
rw [← Encodable.Union_decode₂, ← tsum_Union_decode₂]
·
    exact
      extend_Union_nat PU (fun n => Encodable.Union_decode₂_cases P0 hm)
        (mU _ (Encodable.Union_decode₂_disjoint_on hd))
· exact extend_empty P0 m0
rw [union_eq_Union,
    extend_Union P0 m0 PU mU (pairwise_disjoint_on_bool.2 hd) (Bool.forall_bool.2 ⟨h₂, h₁⟩),
    tsum_fintype]
simp
apply le_antisymm
· simp only [le_infi_iff]
    intro t ht hs
    refine' le_trans (mono' _ hs) _
    exact le_of_eq (induced_outer_measure_eq' _ msU m_mono _)
· refine' le_infi _
    intro f
    refine' le_infi _
    intro hf
    refine' le_trans _ (extend_Union_le_tsum_nat' _ msU _)
    refine' le_infi _
    intro h2f
    refine' infi_le_of_le _ (infi_le_of_le h2f <| infi_le _ hf)
refine' le_infi _
intro h₂
have := extend_union MeasurableSet.empty m0 MeasurableSet.union mU disjoint_diff h₁ (h₂.diff h₁)
rw [union_diff_cancel hs] at this
rw [← extend_eq m]
exact le_iff_exists_add.2 ⟨_, this⟩
refine' extend_Union_le_tsum_nat' MeasurableSet.union _
intro f h
simp (config := { singlePass := true }) [Union_disjointed.symm]
rw [mU (MeasurableSet.disjointed h) (disjoint_disjointed _)]
refine' Ennreal.tsum_le_tsum fun i => _
rw [← extend_eq m, ← extend_eq m]
exact extend_mono m0 mU (MeasurableSet.disjointed h _) (disjointed_le f _)
unfold trim
congr
funext s hs
exact H hs
rw [trim_eq _ hs]
simp only [le_antisymm_iff, trim_le_trim_iff, forall_and]
simp (config := { singlePass := true }) only [infi_comm]
exact
    induced_outer_measure_eq_infi MeasurableSet.union (fun f _ => m.Union_nat f)
      (fun _ _ _ _ h => m.mono h) s
simp [infi_subtype, infi_and, trim_eq_infi]
simp [trim_eq_infi] <;>
    exact fun t st ht =>
      Ennreal.tsum_le_tsum fun i => infi_le_of_le t <| infi_le_of_le st <| infi_le _ ht
intro n
refine' this _ (Ennreal.lt_add_right hs _)
simp
simp
rw [MeasureTheory.Measure.sub_def]
apply le_antisymm
· apply @Inf_le (Measure α) measure.complete_semilattice_Inf
        simp [le_refl, add_comm, h_measure_sub_add]
apply @le_Inf (Measure α) measure.complete_semilattice_Inf
intro d h_d
rw [← h_measure_sub_add, mem_set_of_eq, add_comm d] at h_d
apply measure.le_of_add_le_add_left h_d
simp only [add_top, le_top]
rw [← restrict_apply_self, restrict_sub_eq_restrict_sub_restrict, sub_eq_zero_of_le] <;> simp [*]
rw [pow_succ', mul_assoc]
rw [← mul_assoc, pow_succ', Ennreal.coe_mul]
refine' Fintype.equivFinOfCardEq _
rw [← _i.out, finrank_eq_card_basis b.to_basis]
have A : o.volume_form.measure (stdOrthonormalBasis ℝ F).toBasis.parallelepiped = 1 :=
    Orientation.measure_orthonormal_basis o (stdOrthonormalBasis ℝ F)
rw [add_haar_measure_unique o.volume_form.measure
      (stdOrthonormalBasis ℝ F).toBasis.parallelepiped,
    A, one_smul]
simp only [volume, Basis.addHaar]
cases v
cases w
congr
rw [← coe_injective.eq_iff, Function.funext_iff]
rw [← of_union disjoint_diff hA (hB.diff hA), union_diff_cancel h]
infer_instance
rw [← of_add_of_diff hA hB h, add_sub_cancel']
infer_instance
simp only [Set.diff_union_inter]
rw [of_union]
· rw [Disjoint.comm]
        exact Set.disjoint_of_subset_left (A.inter_subset_right B) Set.disjoint_diff
· exact hA.diff hB
· exact hA.inter hB
rw [of_union, h', add_zero]
· exact Set.disjoint_of_subset_left (A.inter_subset_left B) Set.disjoint_diff
· exact hA.inter hB
· exact hB.diff hA
rw [Set.union_comm, Set.inter_comm, Set.diff_union_inter]
rw [Pi.smul_apply, Empty, smul_zero]
rw [Pi.smul_apply, v.not_measurable hi, smul_zero]
simp
simp [v.not_measurable hi, w.not_measurable hi]
simp
simp [v.not_measurable hi]
simp
simp [v.not_measurable hi, w.not_measurable hi]
simp [μ.empty]
congr
exact h
rw [h]
simp [μ.empty]
rw [Summable.has_sum_iff Ennreal.summable]
· rw [if_pos (MeasurableSet.union hf₁), MeasureTheory.measure_Union hf₂ hf₁]
      exact tsum_congr fun n => if_pos (hf₁ n)
refine' MeasureTheory.VectorMeasure.ext fun i hi => _
rw [to_ennreal_vector_measure_apply_measurable hi, add_apply, vector_measure.add_apply,
    to_ennreal_vector_measure_apply_measurable hi, to_ennreal_vector_measure_apply_measurable hi]
rw [vector_measure.sub_apply, to_signed_measure_apply_measurable hi,
    measure.to_signed_measure_apply_measurable hi, sub_eq_add_neg]
rw [ennreal_to_measure, of_measurable_apply _ hs]
rw [to_ennreal_vector_measure_apply_measurable hs, ennreal_to_measure_apply hs]
rw [ennreal_to_measure_apply hs, to_ennreal_vector_measure_apply_measurable hs]
simp
rw [map, dif_pos hf]
exact if_pos hs
rw [map_apply v measurableId hi, preimage_id]
rw [Empty, AddMonoidHom.map_zero]
rw [not_measurable v hi, AddMonoidHom.map_zero]
simp
rw [restrict, dif_pos hi]
exact if_pos hj
rw [restrict_apply v hi hj, inter_eq_left_iff_subset.2 hij]
rw [restrict_apply v MeasurableSet.empty hi, inter_empty, v.empty, zero_apply]
rw [restrict_apply v MeasurableSet.univ hi, inter_univ]
refine' ⟨fun h i => _, fun h i hi => h i⟩
intro j hj
rw [restrict_empty, restrict_empty]
intro j hj₁
rw [restrict_apply _ hi hj₁, restrict_apply _ hi hj₁, neg_apply, neg_apply]
refine' neg_le_neg _
rw [← restrict_apply _ hi hj₁, ← restrict_apply _ hi hj₁]
exact h j hj₁
rw [restrict_zero, restrict_not_measurable _ hi]
exact le_rfl
rw [restrict_zero, restrict_not_measurable _ hi]
exact le_rfl
intro s hs
rw [neg_apply, h hs, neg_zero]
intro s hs
rw [neg_apply, neg_eq_zero] at hs
exact h hs
rw [add_apply, hv₁ hs, hv₂ hs, zero_add]
rw [sub_apply, hv₁ hs, hv₂ hs, zero_sub, neg_zero]
rw [smul_apply, h hs, smul_zero]
constructor <;> intro h
· refine' mk fun s hmeas hs => h _
    rw [← hs, ennreal_to_measure_apply hmeas]
· intro s hs
simp only [coe_smul, Pi.smul_apply, hs₂ t ht, smul_zero]
rw [if_pos MeasurableSet.empty, v.empty]
rw [if_neg hi]
simp
intro n m hnm
exact ((hf₂ hnm).inf_left' i).inf_right' i
erw [to_measure_of_zero_le_apply]
· simp
· assumption
rw [to_measure_of_zero_le_apply s hi hi₁ MeasurableSet.univ]
exact Ennreal.coe_lt_top
rw [to_measure_of_le_zero_apply s hi hi₁ MeasurableSet.univ]
exact Ennreal.coe_lt_top
rw [← le_restrict_univ_iff_le]
refine' restrict_le_restrict_of_subset_le _ _ fun j hj₁ _ => _
simp only [measure.to_signed_measure_apply_measurable hj₁, coe_zero, Pi.zero_apply,
    Ennreal.to_real_nonneg, vector_measure.coe_zero]
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
rw [sUnion_eq_bUnion]
exact MeasurableSet.bUnion hs h
simp [ae_le_set.1 hst.le]
rw [to_measurable, dif_pos]
exact h.exists_measurable_superset_ae_eq.some_spec.snd.2
rw [measure_eq_extend (MeasurableSet.union h),
    extend_Union MeasurableSet.empty _ MeasurableSet.union _ hn h]
· simp [measure_eq_extend, h]
· exact μ.empty
· exact μ.m_Union
rw [inter_union_diff]
rw [union_comm, inter_comm, measure_union_add_inter₀ t hs, add_comm]
rw [← measure_union_add_inter₀ s ht, hd.eq, add_zero]
rw [union_comm, measure_union₀ hs hd.symm, add_comm]
rw [← measure_union₀' hs ae_disjoint_compl_right, union_compl_self]
exact MeasureTheory.MeasureSpace.volume
rw [mem_preimage, mem_preimage, hx]
refine' le_antisymm (fun s => _) (outer_measure.le_trim _)
rw [outer_measure.trim_eq_infi]
simp only [to_outer_measure_apply]
refine' (infi₂_mono _).trans_eq (measure_eq_infi _).symm
exact fun t ht => infi_mono' fun h => ⟨h.NullMeasurableSet, le_rfl⟩
simp only [measure.map_apply (measurable_const_add a) measurableSetIoo,
            sub_sub_sub_cancel_right, StieltjesFunction.measure_Ioo, StieltjesFunction.id_left_lim,
            StieltjesFunction.id_apply, id.def, preimage_const_add_Ioo]
simp [volume_eq_stieltjes_id]
simp [volume_val]
simp [volume_val]
simp [volume_val]
simp [volume_val]
simp [volume_val]
simp
rw [ball_eq_Ioo, volume_Ioo, ← sub_add, add_sub_cancel', two_mul]
rw [closed_ball_eq_Icc, volume_Icc, ← sub_add, add_sub_cancel', two_mul]
rw [← Icc_min_max, volume_Icc, max_sub_min_eq_abs]
simp
simp [← measure_congr Ioi_ae_eq_Ici]
simp
simp [← measure_congr Iio_ae_eq_Iic]
simp only [Real.volume_Ioo, Ennreal.of_real_lt_top]
simp
simp
simp
simp
rw [← pi_univ_Icc, volume_pi_pi]
simp only [Real.volume_Icc]
simp only [volume_Icc_pi, Ennreal.to_real_prod, Ennreal.to_real_of_real (sub_nonneg.2 (h _))]
simp only [volume_pi_Ioo, Ennreal.to_real_prod, Ennreal.to_real_of_real (sub_nonneg.2 (h _))]
simp only [volume_pi_Ioc, Ennreal.to_real_prod, Ennreal.to_real_of_real (sub_nonneg.2 (h _))]
simp only [volume_pi_Ico, Ennreal.to_real_prod, Ennreal.to_real_of_real (sub_nonneg.2 (h _))]
simp only [volume_pi_ball a hr, volume_ball, Finset.prod_const]
exact (Ennreal.of_real_pow (mul_nonneg zero_le_two hr.le) _).symm
simp only [volume_pi_closed_ball a hr, volume_closed_ball, Finset.prod_const]
exact (Ennreal.of_real_pow (mul_nonneg zero_le_two hr) _).symm
simp only [Ennreal.coe_one, one_mul, Finset.prod_const, Fintype.card]
rw [map_volume_mul_left h]
rfl
rw [map_volume_mul_right h]
rfl
simp only [det_diagonal, Ne.def] at h
exact Finset.prod_ne_zero_iff.1 h i (Finset.mem_univ i)
have : Measurable fun c : α → ℝ => c ⟨t.j, t.hij.symm⟩ := measurablePiApply ⟨t.j, t.hij.symm⟩
refine' (measurablePiLambda _ fun i => Measurable.constMul _ _).add measurableSnd
exact this.comp measurableFst
simp only [LinearMap.det_to_matrix']
simp only [to_lin'_to_matrix']
dsimp only [regionBetween, Ioo, mem_set_of_eq, set_of_and]
refine'
    MeasurableSet.inter _
      ((measurableSetLt (hf.comp measurableFst) measurableSnd).inter
        (measurableSetLt measurableSnd (hg.comp measurableFst)))
exact measurableFst hs
dsimp only [regionBetween, Ioc, mem_set_of_eq, set_of_and]
refine'
    MeasurableSet.inter _
      ((measurableSetLt (hf.comp measurableFst) measurableSnd).inter
        (measurableSetLe measurableSnd (hg.comp measurableFst)))
exact measurableFst hs
dsimp only [regionBetween, Ico, mem_set_of_eq, set_of_and]
refine'
    MeasurableSet.inter _
      ((measurableSetLe (hf.comp measurableFst) measurableSnd).inter
        (measurableSetLt measurableSnd (hg.comp measurableFst)))
exact measurableFst hs
dsimp only [regionBetween, Icc, mem_set_of_eq, set_of_and]
refine'
    MeasurableSet.inter _
      ((measurableSetLe (hf.comp measurableFst) measurableSnd).inter
        (measurableSetLe measurableSnd (hg.comp measurableFst)))
exact measurableFst hs
simp [h, Ioo]
simp [h]
apply measure_congr
apply eventually_eq.rfl.inter
exact
      ((quasi_measure_preserving_fst.ae_eq_comp hf.ae_eq_mk).comp₂ _ eventually_eq.rfl).inter
        (eventually_eq.rfl.comp₂ _ <| quasi_measure_preserving_fst.ae_eq_comp hg.ae_eq_mk)
intro x hx
simp only [restrict_eq_zero, hfinite.measure_zero]
change ((μ : Measure Ω) s₁).toNnreal ≤ ((μ : Measure Ω) s₂).toNnreal
have key : (μ : Measure Ω) s₁ ≤ (μ : Measure Ω) s₂ := (μ : Measure Ω).mono h
apply (Ennreal.to_nnreal_le_to_nnreal (measure_ne_top _ s₁) (measure_ne_top _ s₂)).mpr key
simp only [hμ, zero.mass]
rw [not_iff_not]
exact finite_measure.mass_zero_iff μ
simp only [coe_fn_smul, Pi.smul_apply]
apply congr_arg Ennreal.toNnreal
exact measure.restrict_apply s_mble
simp only [mass, restrict_apply μ A MeasurableSet.univ, univ_inter]
rw [← mass_zero_iff, restrict_mass]
rw [← mass_nonzero_iff, restrict_mass]
simp [← Ennreal.coe_eq_coe]
simp only [← Ennreal.coe_le_coe, test_against_nn_coe_eq]
exact lintegral_mono fun ω => Ennreal.coe_mono (f_le_g ω)
simp only [test_against_nn, coe_one, Pi.one_apply, Ennreal.coe_one, lintegral_one]
rfl
simp only [test_against_nn, coe_zero, lintegral_zero_measure, Ennreal.zero_to_nnreal]
simp only [test_against_nn, coe_smul, smul_eq_mul, ← Ennreal.smul_to_nnreal, Ennreal.smul_def,
    lintegral_smul_measure]
simp only [← Ennreal.coe_eq_coe, BoundedContinuousFunction.coe_add, Ennreal.coe_add, Pi.add_apply,
    test_against_nn_coe_eq]
exact lintegral_add_left (BoundedContinuousFunction.Nnreal.toEnnrealCompMeasurable _) _
apply (Nnreal.le_add_nndist (f ω) (g ω)).trans
rw [add_le_add_iff_left]
exact dist_le_coe.mp (le_dist ω)
rw [← Ennreal.coe_add]
exact Ennreal.coe_mono le'
apply (WeakBilin.eval_continuous _ _).comp to_weak_dual_bcnn_continuous
rw [tendsto_iff_weak_star_tendsto, tendsto_iff_forall_eval_tendsto_top_dual_pairing]
rfl
rw [finite_measure.tendsto_iff_forall_to_weak_dual_bcnn_tendsto]
rfl
simp only [dist_nndist, Nnreal.nndist_zero_eq_val', eq_self_iff_true, imp_true_iff]
refine' (Prod.tendsto_iff _ _).mpr ⟨tendsto_const_nhds, _⟩
exact (nnreal.continuous_coe.tendsto 0).comp mass_lim
apply
    (Ennreal.tendsto_to_nnreal
        (lintegral_lt_top_of_bounded_continuous_to_nnreal (μ : Measure Ω) f).Ne).comp
exact tendsto_lintegral_nn_filter_of_le_const μ fs_le_const fs_lim
refine' ⟨(nnreal.continuous_coe.comp f.continuous).Measurable.AeStronglyMeasurable, _⟩
simp only [has_finite_integral, Nnreal.nnnorm_eq]
exact lintegral_lt_top_of_bounded_continuous_to_nnreal _ f
simp only [f.self_eq_nnreal_part_sub_nnreal_part_neg, Pi.sub_apply, integral_sub,
    integrable_of_bounded_continuous_to_nnreal]
rfl
simp only [f₀_eq, Pi.zero_apply, Nnreal.zero_le_coe]
rw [integral_eq_lintegral_of_nonneg_ae _
      (nnreal.continuous_coe.comp f.continuous).Measurable.AeStronglyMeasurable]
· simp only [Ennreal.of_real_coe_nnreal]
· apply eventually_of_forall
    simp only [Pi.zero_apply, Nnreal.zero_le_coe, imp_true_iff]
simp only [interior_pi_set, Set.to_finite, interior_Icc, univ_pi_nonempty_iff, nonempty_Ioo,
      imp_true_iff, zero_lt_one]
rw [← add_haar_measure_eq_volume_pi]
infer_instance
rw [← Union_add, Union_singleton_eq_range]
simp only [H, tsum_zero]
cases nonempty_fintype ι
  /- We have already proved the result for the Lebesgue product measure, using matrices.
    We deduce it for any Haar measure
infer_instance
simp
rw [hg]
exact LinearMap.det_conj f e
rw [map_linear_map_add_haar_eq_smul_add_haar μ hf]
rfl
simp only [mul_one, LinearMap.det_smul, Ne.def, MonoidHom.map_one]
intro h
exact hr (pow_eq_zero h)
rw [map_add_haar_smul μ hr]
rfl
simp only [← image_smul, image_image, ← sub_eq_add_neg]
rfl
simp only [image_add_right, measure_preimage_add_right, add_haar_smul]
simp only [map_add_haar_smul μ hR, integral_smul_measure, Ennreal.to_real_of_real,
          abs_nonneg]
rw [integral_comp_smul μ f R, abs_of_nonneg (inv_nonneg.2 (pow_nonneg hR _))]
rw [integral_comp_inv_smul μ f R, abs_of_nonneg (pow_nonneg hR _)]
simp [preimage_add_ball]
simp [preimage_add_closed_ball]
simp only [smul_ball hr.ne' (0 : E) s, Real.norm_eq_abs, abs_of_nonneg hr.le, smul_zero]
rw [← add_haar_ball_mul_of_pos μ x hr, mul_one]
rw [← add_haar_ball_mul μ x hr, mul_one]
simp [smul_closed_ball' hr.ne' (0 : E), abs_of_nonneg hr.le]
simp [smul_closed_ball r (0 : E) hs, abs_of_nonneg hr]
rw [← add_haar_closed_ball_mul μ x hr zero_le_one, mul_one]
simp
simp
simp
rw [add_haar_closed_ball' μ x hr, add_haar_closed_unit_ball_eq_add_haar_unit_ball]
simp only [div_eq_mul_inv, add_haar_smul, image_add_left, measure_preimage_add, abs_pow,
        singleton_add]
rw [Ennreal.mul_inv_cancel, one_mul, div_eq_mul_inv]
· simp only [pow_pos (abs_pos.mpr hr), Ennreal.of_real_eq_zero, not_le, Ne.def]
· simp only [Ennreal.of_real_ne_top, Ne.def, not_false_iff]
rw [image_parallelepiped]
congr 1
rw [AlternatingMap.measure]
infer_instance
rw [AlternatingMap.measure]
infer_instance
simp only [smul_closed_ball, Real.norm_of_nonneg rpos.le, zero_le_one, add_zero, mul_one,
        singleton_add_closed_ball, smul_zero]
apply Ennreal.Tendsto.mul A _ B (Or.inr Ennreal.zero_ne_top)
simp only [Ennreal.div_eq_top, h'u, measure_closed_ball_lt_top.ne, false_or_iff, image_add_left,
      eq_self_iff_true, not_true, Ne.def, not_false_iff, measure_preimage_add, singleton_add,
      and_false_iff, false_and_iff]
rw [Ennreal.mul_inv_cancel (measure_closed_ball_pos μ x rpos).ne'
          measure_closed_ball_lt_top.ne,
        one_mul]
rw [mul_comm, ht', smul_smul, mul_assoc, mul_inv_cancel Rpos.ne', mul_one]
rw [mul_comm, hu', smul_smul, mul_assoc, mul_inv_cancel Rpos.ne', mul_one]
simp only [h't, add_haar_smul, image_add_left, measure_preimage_add, singleton_add,
          mul_zero]
rw [← inter_union_distrib_left, ← add_union, ← smul_set_union, inter_union_diff]
simp only [coe_fn_univ, Ne.def, one_ne_zero, not_false_iff]
rw [← coe_fn_comp_to_finite_measure_eq_coe_fn, finite_measure.ennreal_coe_fn_eq_coe_fn_to_measure,
    coe_comp_to_finite_measure_eq_coe]
rw [← coe_fn_comp_to_finite_measure_eq_coe_fn]
exact MeasureTheory.FiniteMeasure.apply_mono _ h
rw [univ_eq_empty_iff.mpr (not_nonempty_iff.mp maybe_empty), measure_empty]
rw [← finite_measure.mass_nonzero_iff, μ.mass_to_finite_measure]
exact one_ne_zero
rw [tendsto_nhds_iff_to_finite_measures_tendsto_nhds]
exact finite_measure.tendsto_iff_forall_lintegral_tendsto
rw [tendsto_nhds_iff_to_finite_measures_tendsto_nhds]
rw [finite_measure.tendsto_iff_forall_integral_tendsto]
simp only [coe_comp_to_finite_measure_eq_coe]
apply eq_of_forall_apply_eq
intro s s_mble
rw [μ.self_eq_mass_mul_normalize s, coe_fn_smul_apply, smul_eq_mul,
    probability_measure.coe_fn_comp_to_finite_measure_eq_coe_fn]
simp only [μ.self_eq_mass_mul_normalize, μ.mass_nonzero_iff.mpr nonzero, inv_mul_cancel_left₀,
    Ne.def, not_false_iff]
apply probability_measure.eq_of_forall_apply_eq
intro s s_mble
rw [μ.to_finite_measure.normalize_eq_of_nonzero μ.to_finite_measure_nonzero s]
simp only [probability_measure.mass_to_finite_measure, inv_one, one_mul,
    probability_measure.coe_fn_comp_to_finite_measure_eq_coe_fn]
rw [μ.coe_normalize_eq_of_nonzero nonzero, average]
congr
simp only [RingHom.toFun_eq_coe, Ennreal.coe_of_nnreal_hom,
    Ennreal.coe_inv (μ.mass_nonzero_iff.mpr nonzero), ennreal_mass]
simp [μ.test_against_nn_eq_mass_mul, μ.mass_nonzero_iff.mpr nonzero]
refine' (Prod.tendsto_iff _ _).mpr ⟨_, _⟩
· exact (continuous_on_inv₀.continuous_at aux).Tendsto.comp lim_mass
· exact tendsto_iff_forall_test_against_nn_tendsto.mp μs_lim f
rw [tendsto_iff_forall_test_against_nn_tendsto]
exact fun f =>
    tendsto_test_against_nn_of_tendsto_normalize_test_against_nn_of_tendsto_mass μs_lim mass_lim f
rw [probability_measure.tendsto_nhds_iff_to_finite_measures_tendsto_nhds,
    tendsto_iff_forall_test_against_nn_tendsto]
exact fun f => tendsto_normalize_test_against_nn_of_tendsto μs_lim nonzero f
rw [s.empty, t.empty] <;> rfl
rw [s.not_measurable hi, t.not_measurable hi] <;> rfl
simp
simp [parallelepiped, eq_comm]
simp only [parallelepiped, ← image_comp]
congr 1
apply Fintype.equivFinOfCardEq
simp only [← finrank_eq_card_basis b.to_basis, finrank_self]
rw [← pi_univ_Icc, interior_pi_set (@finite_univ ι _)]
simp only [univ_pi_nonempty_iff, Pi.zero_apply, Pi.one_apply, interior_Icc, nonempty_Ioo,
        zero_lt_one, imp_true_iff]
rw [Basis.addHaar]
exact measure.is_add_haar_measure_add_haar_measure _
rw [Basis.addHaar]
exact add_haar_measure_self
infer_instance
rw [prehaar, compacts.coe_bot, index_empty, Nat.cast_zero, zero_div]
simp only [haar_product, pi, forall_prop_of_true, mem_univ, mem_set_of_eq]
assumption
simp only [prehaar, compacts.coe_map, is_left_invariant_index K.is_compact _ hU]
apply is_compact_univ_pi
intro K
apply is_compact_Icc
have := (Classical.choose_spec (nonempty_Inter_cl_prehaar K₀)).2
rw [mem_Inter] at this
exact this V
have := chaar_mem_haar_product K₀ K (mem_univ _)
rw [mem_Icc] at this
exact this.1
let eval : (compacts G → ℝ) → ℝ := fun f => f
let eval : (compacts G → ℝ) → ℝ := fun f => f K₀.to_compacts
have : Continuous eval := continuous_apply _
show chaar K₀ ∈ eval
let eval : (compacts G → ℝ) → ℝ := fun f => f K₂ - f K₁
have : Continuous eval := (continuous_apply K₂).sub (continuous_apply K₁)
rw [← sub_nonneg]
show chaar K₀ ∈ eval
simp only [mem_inv, inv_one, h3V₁, h3V₂, V, mem_inter_iff, true_and_iff]
let eval : (compacts G → ℝ) → ℝ := fun f => f (K.map _ <| continuous_mul_left g) - f K
have : Continuous eval := (continuous_apply (K.map _ _)).sub (continuous_apply K)
rw [← sub_eq_zero]
show chaar K₀ ∈ eval
simp only [← Nnreal.coe_le_coe, Subtype.coe_mk, chaar_mono, h]
simp only [chaar_sup_eq h]
rfl
simp only [← Nnreal.coe_le_coe, Nnreal.coe_add, Subtype.coe_mk, chaar_sup_le]
apply ennreal.zero_lt_one.trans_le
rw [content.outer_measure_eq_infi]
refine' le_infi₂ fun U hU => le_infi fun hK₀ => le_trans _ <| le_supr₂ K₀.to_compacts hK₀
exact haar_content_self.ge
change ((haar_content K₀).OuterMeasure K₀)
rw [← forall_measure_preimage_mul_iff]
intro g A hA
rw [haar_measure_apply hA, haar_measure_apply (measurable_const_mul g hA)]
congr 1
apply content.is_mul_left_invariant_outer_measure
apply is_left_invariant_haar_content
apply
    is_haar_measure_of_is_compact_nonempty_interior (haar_measure K₀) K₀ K₀.is_compact
      K₀.interior_nonempty
· simp only [haar_measure_self]
    exact one_ne_zero
· simp only [haar_measure_self]
    exact Ennreal.coe_ne_top
rw [haar_measure_self, div_one]
rw [haar_measure_unique μ ⟨⟨K, hK⟩, h2K⟩]
exact regular.smul hμK
rw [smul_smul, div_eq_mul_inv, mul_assoc, Ennreal.inv_mul_cancel νpos.ne' νne, mul_one]
rw [← haar_measure_unique ν K]
apply ne_top_of_le_ne_top (ne_of_lt hLtop)
apply measure_mono hKL
apply Set.union_subset _ hUK
apply subset_trans _ hVKU
apply Set.mul_subset_mul _ (Set.Subset.refl K)
simp only [Set.singleton_subset_iff, hv]
simp only [singleton_mul, image_mul_left, measure_preimage_mul]
simp only [hc, smul_smul, pow_two, measure.map_smul]
simp
rw [map_apply_of_ae_measurable hf.measurable.ae_measurable MeasurableSet.univ,
          preimage_univ]
rw [induced_outer_measure_eq m0 mU, mU hf hd]
congr
funext n
rw [induced_outer_measure_eq m0 mU]
unfold outer_measure.trim
congr
funext s hs
exact induced_outer_measure_eq m0 mU hs
congr
exact h
rw [← trimmed, outer_measure.trim_congr h, trimmed]
rw [μ.trimmed] <;> rfl
rw [measure_eq_trim, outer_measure.trim_eq_infi] <;> rfl
rw [← Finset.sum_attach, Finset.attach_eq_univ, ← tsum_fintype]
exact measure_bUnion_le s.countable_to_set f
refine' ⟨fun h => ⟨_, _⟩, fun h => measure_union_lt_top h.1 h.2⟩
· exact (measure_mono (Set.subset_union_left s t)).trans_lt h
· exact (measure_mono (Set.subset_union_right s t)).trans_lt h
simp only [← lt_top_iff_ne_top, ← Ne.def, not_or, measure_union_lt_top_iff]
simp
simp only [compl_inter, mem_set_of_eq] <;> exact measure_union_null hs ht
simp only [mem_ae_iff, compl_compl]
intro S hSc hS
rw [mem_ae_iff, compl_sInter, sUnion_image]
exact (measure_bUnion_null_iff hSc).2 hS
rw [Filter.EventuallyLe, ae_iff]
rw [ae_iff] at h
refine' measure_mono_null (fun x hx => _) h
exact not_lt.2 (le_of_lt (not_le.1 hx))
simp only [ae_iff, not_not, set_of_mem_eq]
simp [ae_iff] <;> rfl
simp [eventually_le_antisymm_iff, ae_le_set, union_diff_right,
    diff_eq_empty.2 (Set.subset_union_right _ _)]
simp [eventually_le_antisymm_iff, ae_le_set, diff_diff_right, diff_diff,
    diff_eq_empty.2 (Set.subset_union_right _ _)]
simp [eventually_le_antisymm_iff, ae_le_set]
simp [ae_eq_set, symmDiff_def]
simp only [← measure_symm_diff_eq_zero_iff, compl_symmDiff_compl]
rw [← ae_eq_set_compl_compl, compl_compl]
rw [union_diff_self, Set.union_comm]
rw [ae_le_set.1 H, add_zero]
simp only [interval_oc_eq_union, mem_union, or_imp, eventually_and]
rw [union_comm, inter_comm, measure_union_add_inter t hs, add_comm]
rw [sUnion_eq_bUnion, measure_bUnion₀ hs hd h]
rw [sUnion_eq_bUnion, measure_bUnion hs hd h]
rw [← Finset.sum_attach, Finset.attach_eq_univ, ← tsum_fintype]
exact measure_bUnion₀ s.countable_to_set hd hm
rw [← Set.bUnion_preimage_singleton, measure_bUnion hs (pairwise_disjoint_fiber _ _) hf]
simp only [← measure_bUnion_finset (pairwise_disjoint_fiber _ _) hf,
    Finset.set_bUnion_preimage_singleton]
rw [← measure_union' disjoint_diff hs, union_diff_self]
rw [add_comm, measure_add_diff hm, union_comm]
rw [measure_diff' _ h₂ h_fin, union_eq_self_of_subset_right h]
rw [measure_diff hst hs hs']
rw [add_comm] at h
exact Ennreal.sub_lt_of_lt_add (measure_mono hst) h
rw [diff_union_of_subset (h12.trans h23)]
simp only [h_nulldiff, zero_add]
rw [compl_eq_univ_diff]
exact measure_diff (subset_univ s) h₁ h_fin
rw [union_comm, union_ae_eq_left_iff_ae_subset]
rw [union_eq_Union, union_eq_Union]
exact measure_Union_congr_of_subset (Bool.forall_bool.2 ⟨ht, hs⟩) (Bool.forall_bool.2 ⟨htμ, hsμ⟩)
rw [← measure_bUnion_finset H h]
exact measure_mono (subset_univ _)
rw [Ennreal.tsum_eq_supr_sum]
exact supr_le fun s => sum_measure_le_measure_univ (fun i hi => hs i) fun i hi j hj hij => H hij
rw [add_comm] at h
rw [inter_comm]
exact nonempty_inter_of_measure_lt_add μ hs h't h's h
simp only [← ht, encodable.encode_injective.apply_extend μ, ← supr_eq_Union,
      supr_extend_bot Encodable.encode_injective, (· ∘ ·), Pi.bot_apply, bot_eq_empty,
      measure_empty] at this
exact this.trans (supr_extend_bot Encodable.encode_injective _)
rw [Union_disjointed]
rw [measure_Union_eq_supr (directed_of_sup hm)]
exact tendsto_at_top_supr fun n m hnm => measure_mono <| hm hnm
rw [measure_Inter_eq_infi hs (directed_of_sup hm) hf]
exact tendsto_at_top_infi fun n m hnm => measure_mono <| hm hnm
have A : s ≤ t := fun n => subset_to_measurable μ (s n)
    -- TODO default args fail
exact
      measure_mono_null
        (limsup_le_limsup (eventually_of_forall (pi.le_def.mp A)) is_cobounded_le_of_bot
          is_bounded_le_of_top)
        this
  -- Next we unfold `limsup` for sets and replace equality with an inequality
simp [measure_limsup_eq_zero h]
simp only [eq_empty_of_is_empty s, measure_empty]
rw [Ennreal.tsum_add, measure_Union hd hs, measure_Union hd hs]
rw [outer_measure.trim_add, μ₁.trimmed, μ₂.trimmed]
rw [outer_measure.trim_smul, μ.trimmed]
rw [coe_finset_sum, Finset.sum_apply]
simp [ae_iff, hc]
refine' le_antisymm (measure_mono h') _
have : μ t + ν t ≤ μ s + ν t :=
    calc
      μ t + ν t = μ s + ν s := h''.symm
      _ ≤ μ s + ν t := add_le_add le_rfl (measure_mono h')
apply Ennreal.le_of_add_le_add_right _ this
simp only [not_or, Ennreal.add_eq_top, Pi.add_apply, Ne.def, coe_add] at h
exact h.2
rw [add_comm] at h'' h
exact measure_eq_left_of_subset_of_measure_add_eq h h' h''
rw [add_comm] at ht⊢
exact measure_to_measurable_add_inter_left hs ht
rw [← μ₂.trimmed, outer_measure.le_trim_iff] <;> rfl
simp only [le_iff, not_forall, not_le, exists_prop]
simp only [le_iff', not_forall, not_le]
intro s t hst
rw [outer_measure.Inf_gen_def]
refine' infi_le_of_le μ.to_outer_measure (infi_le_of_le (mem_image_of_mem _ hμ) _)
rw [to_outer_measure_apply]
refine' measure_mono hst
rw [Inf_apply hs, ← to_outer_measure_apply] <;> exact this s
rw [Inf_apply hs, ← to_outer_measure_apply] <;> exact this s
infer_instance
infer_instance
rw [outer_measure.top_caratheodory]
exact le_top
simp [hs]
simp [hs]
simp [map, hf]
simp only [← mapₗ_mk_apply_of_ae_measurable hf.ae_measurable]
exact mapₗ_congr hf hf.ae_measurable.measurable_mk hf.ae_measurable.ae_eq_mk
simp [← mapₗ_apply_of_measurable hf]
simp [map, hf]
intro hfc
exact hf ⟨hfc.mk f, hfc.measurable_mk, (ae_smul_measure_iff hc).1 hfc.ae_eq_mk⟩
rw [← trimmed, outer_measure.trim_eq_trim_iff]
intro s hs
rw [coe_to_outer_measure, map_apply_of_ae_measurable hf hs, outer_measure.map_apply,
    coe_to_outer_measure]
simp [hf, hg, hs, hg hs, hg.comp hf, ← preimage_comp]
simp [hf.ae_measurable, hs, h _ (hf hs)]
simp only [coe_to_outer_measure, outer_measure.comap_apply, image_inter hf.1, image_diff hf.1]
apply le_to_outer_measure_caratheodory
exact hf.2 s hs
rw [comapₗ, dif_pos, lift_linear_apply _ hs, outer_measure.comap_apply, coe_to_outer_measure]
exact ⟨hfi, hf⟩
simp only [coe_to_outer_measure, outer_measure.comap_apply, image_inter hf.1, image_diff hf.1]
exact (measure_inter_add_diff₀ _ (hf.2 s hs)).symm
rw [comap, dif_pos (And.intro hfi hf)] at hs⊢
rw [to_measure_apply₀ _ _ hs, outer_measure.comap_apply, coe_to_outer_measure]
rw [comap, dif_pos (And.intro hfi hf)]
exact le_to_measure_apply _ _ _
rw [comap_apply₀ _ _ hf h (hf' hs).NullMeasurableSet, image_preimage_eq_inter_range]
rw [subtype.volume_def, comap_apply₀ _ _ _ _ measurable_set.univ.null_measurable_set]
· congr
    simp only [Subtype.val_eq_coe, image_univ, Subtype.range_coe_subtype, set_of_mem_eq]
· exact Subtype.coe_injective
· exact fun t => measurable_set.null_measurable_set_subtype_coe hs
simp only [coe_to_outer_measure, outer_measure.restrict_apply]
rw [← coe_to_outer_measure, measure.restrict_to_outer_measure_eq_to_outer_measure_restrict hs,
    outer_measure.restrict_apply s t _, coe_to_outer_measure]
rw [← restrict_congr_set hs.to_measurable_ae_eq,
    restrict_apply' (measurable_set_to_measurable _ _),
    measure_congr ((ae_eq_refl t).inter hs.to_measurable_ae_eq)]
rw [← restrict_apply (measurable_set_to_measurable _ _), measure_to_measurable]
rw [restrict_apply MeasurableSet.univ, Set.univ_inter]
simp only [Set.inter_assoc, restrict_apply hu,
      restrict_apply₀ (hu.null_measurable_set.inter hs)]
simp only [restrict_apply hu, restrict_apply₀' ht, inter_assoc]
rw [restrict_restrict hs, restrict_restrict' hs, inter_comm]
rw [restrict_apply ht]
rw [restrict_apply' hs]
rw [← measure_univ_eq_zero, restrict_apply_univ]
simp [hs]
simp [← restrict_union_add_inter₀ s ht, restrict_zero_set h]
rw [union_comm, restrict_union h.symm hs, add_comm]
rw [← restrict_union (@disjoint_compl_right (Set α) _ _) hs.compl, union_compl_self,
    restrict_univ]
rw [add_comm, restrict_add_restrict_compl hs]
simp only [restrict_apply, ht, inter_Union]
exact
    measure_Union₀ (hd.mono fun i j h => h.mono (inter_subset_right _ _) (inter_subset_right _ _))
      fun i => ht.null_measurable_set.inter (hm i)
simp [*, hf ht]
rw [restrict_apply ht, restrict_apply ht, inter_comm, measure_to_measurable_inter ht h,
      inter_comm]
rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht]
rw [restrict_apply ht, restrict_apply ht, H _ (inter_subset_right _ _) (ht.inter hs)]
rw [← restrict_restrict_of_subset hs, h, restrict_restrict_of_subset hs]
simp only [restrict_apply, hu, hu.diff hm, hμ, ← inter_comm t, inter_diff_assoc]
rw [hs, ht]
simp only [restrict_apply, hu, hu.diff hm, hν, ← inter_comm t, inter_diff_assoc]
rw [sUnion_eq_bUnion, restrict_bUnion_congr hc]
rw [← μ.restrict_apply_self, ← frequently_ae_mem_iff] at hs
exact (hs.and_eventually hp).exists
rw [← restrict_Union_congr, hs, restrict_univ, restrict_univ]
rw [← restrict_bUnion_congr hc, hs, restrict_univ, restrict_univ]
simp
simp [dirac_apply' _ (measurable_set_singleton _).compl]
simp [hs, map_apply hf hs, hf hs, indicator_apply]
simp only [sum_apply μ hs, Ennreal.le_tsum i]
simp [*]
simp [hs]
rw [sum_fintype, Finset.sum_coe_sort s μ]
rw [sum_fintype, Fintype.sum_bool]
simp only [sum_apply, restrict_apply, ht, ht.inter hs]
rw [← measure_univ_eq_zero, sum_apply _ MeasurableSet.univ, tsum_empty]
simp only [sum_apply _ ht, restrict_Union_apply_ae hd hm ht]
simp only [count, sum_apply, hs, dirac_apply', ← tsum_subtype s 1, Pi.one_apply]
rw [count_apply MeasurableSet.empty, tsum_empty]
simp
rw [← count_apply_finset, finite.coe_to_finset]
simp
rw [← count_apply_lt_top' s_mble, hsc]
exact WithTop.zero_lt_top
rw [← count_apply_lt_top, hsc]
exact WithTop.zero_lt_top
rw [Ne.def, count_eq_zero_iff' s_mble]
exact hs'.ne_empty
rw [Ne.def, count_eq_zero_iff]
exact hs'.ne_empty
rw [count_apply_finite' (Set.finite_singleton a) ha, Set.Finite.toFinset]
simp
simp only [h hνs, smul_eq_mul, smul_apply, smul_zero]
rw [measure_zero_iff_ae_nmem, measure_zero_iff_ae_nmem]
exact fun hs => h hs
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
rw [← map_map hg.1 hf.1]
exact (hf.2.map hg.1).trans hg.2
intro g₁ g₂ hg
let g := g₂
simp
rw [mem_cofinite, compl_compl]
rw [← empty_mem_iff_bot, mem_ae_iff, compl_empty, measure_univ_eq_zero]
simp only [mem_ae_iff, map_apply_of_ae_measurable hf hs.compl, preimage_compl]
simp [union_eq_Union, supr_bool_eq]
simp
simp
simp only [interval_oc_eq_union, ae_restrict_union_eq]
rw [ae_restrict_interval_oc_eq, eventually_sup]
simp only [ae_iff, ← compl_set_of, restrict_apply hp.compl]
congr
simp only [ae_iff, ← compl_set_of, restrict_apply_eq_zero' hs]
congr
refine' hfg.filter_mono _
rw [measure.ae_le_iff_absolutely_continuous]
exact measure.absolutely_continuous_of_le measure.restrict_le_self
rw [← inter_union_distrib_left, union_compl_self, inter_univ]
rw [ae_iff.1 ht, ae_iff.1 htc, zero_add]
rw [mem_map, mem_ae_iff, measure.restrict_apply' hs]
rw [smul_apply, ae_iff.1 h, smul_zero]
simp only [ae_restrict_eq hs, exists_prop, mem_principal, mem_inf_iff] <;>
    exact ⟨_, univ_mem, s, subset.rfl, (univ_inter s).symm⟩
simp [measure.restrict_congr_set hst]
rw [← measure_bUnion_eq_supr hsc]
· congr
    exact Union₂_eq_univ_iff.2 hst
· exact directedOn_iff_directed.2 ((hdir.directed_coe.mono_comp _) fun x y => Iic_subset_Iic.2)
rw [← Iic_diff_right, diff_ae_eq_self, measure_mono_null (Set.inter_subset_right _ _) ha]
simp [Filter.EventuallyEq]
refine' ⟨fun h => _, fun h => fun h' => h'.measure_univ_lt_top.ne h⟩
simp [hs.elim]
simp [measure_lt_top μ s]
rw [add_right_comm, add_assoc]
simp
rw [eq_zero_of_is_empty μ]
infer_instance
rw [measure.coe_add, Pi.add_apply, Ennreal.add_lt_top]
exact ⟨measure_lt_top _ _, measure_lt_top _ _⟩
rw [← smul_one_smul ℝ≥0 r μ]
infer_instance
apply Ennreal.summable_to_real
rw [← MeasureTheory.measure_Union hf₂ hf₁]
exact ne_of_lt (measure_lt_top _ _)
rw [← ae_eq_univ_iff_measure_eq hp, eventually_eq_univ, eventually_iff]
simp only [measure_univ, Ennreal.one_lt_top]
simp [measure_univ]
simp [map_apply_of_ae_measurable, hf]
simp only [prob_compl_eq_one_sub hs, tsub_eq_zero_iff_le, one_le_prob_iff]
simp only [measure_singleton, measure.restrict_eq_zero]
rw [← bUnion_of_singleton s, ← nonpos_iff_eq_zero]
refine' le_trans (measure_bUnion_le h _) _
simp
simp [(Set.mem_compl_iff _ _).mp hx]
simp only [measure_empty, WithTop.zero_lt_top]
rw [measure_to_measurable]
exact h.out.some.finite n
rw [Union_spanning_sets, restrict_univ]
rw [← inter_Union, Union_spanning_sets, inter_univ]
rw [← not_iff_not]
simp only [not_exists, not_lt, nonpos_iff_eq_zero]
exact forall_measure_inter_spanning_sets_eq_zero s
intro i i_in_nonzeroes
rw [← inter_Union, Union_disjointed, Union_spanning_sets, inter_univ]
rw [ht', Union_inter]
exact measure_Union_le _
rw [measure_Union]
· exact disjoint_disjointed _
· intro i
          exact MeasurableSet.disjointed (measurable_spanning_sets _) _
rw [Union_disjointed, Union_spanning_sets, restrict_apply MeasurableSet.univ, univ_inter]
      
  -- thanks to the definition of `to_measurable`, the previous property will also be shared
  --
simp only [restrict_apply ht, inter_comm t, measure_to_measurable_inter_of_sigma_finite ht]
simp
refine' ⟨⟨⟨spanning_sets μ, fun _ => trivial, fun i => _, Union_spanning_sets μ⟩⟩⟩
rw [restrict_apply (measurable_spanning_sets μ i)]
exact (measure_mono <| inter_subset_left _ _).trans_lt (measure_spanning_sets_lt_top μ i)
simp only [← map_apply_of_ae_measurable hf, measurable_spanning_sets,
          measure_spanning_sets_lt_top]
rw [← preimage_Union, Union_spanning_sets, preimage_univ]
rw [← preimage_Union, Metric.Union_ball_nat, preimage_univ]
constructor
rw [← h_univ]
apply is_finite_measure.measure_univ_lt_top
simp
rw [subset_union_compl_iff_inter_subset, ← image_preimage_eq_inter_range]
exact image_subset _ (subset_to_measurable _ _)
rw [preimage_union, preimage_compl, preimage_range, compl_univ, union_empty,
      hf.injective.preimage_image]
rw [map_apply hf.measurable htm, hft, measure_to_measurable]
rw [hf.injective.preimage_image]
rw [hf.map_comap, restrict_apply' hf.measurable_set_range,
        inter_eq_self_of_subset_left (image_subset_range _ _)]
simp only [ae_iff, hf.map_apply, preimage_set_of_eq]
simp [hf.map_apply, ht, hf.measurable ht]
rw [(MeasurableEmbedding.subtypeCoe hs).map_comap, Subtype.range_coe]
rw [← map_comap_subtype_coe hs, (MeasurableEmbedding.subtypeCoe hs).ae_map_iff]
rw [volume_set_coe_def, (MeasurableEmbedding.subtypeCoe hs).map_comap volume, Subtype.range_coe]
rw [volume_set_coe_def,
    comap_apply₀ _ _ Subtype.coe_injective
      (fun h => measurable_set.null_measurable_set_subtype_coe hs)
      (measurableSubtypeCoe ht).NullMeasurableSet,
    image_preimage_eq_inter_range, Subtype.range_coe]
simp [map_map e.symm.measurable e.measurable]
simp [map_map e.measurable e.symm.measurable]
rw [← (map_measurable_equiv_injective e).eq_iff, map_map_symm, eq_comm]
rw [← measure.measure_univ_eq_zero, to_measure_apply _ _ MeasurableSet.univ,
    outer_measure.coe_zero, Pi.zero_apply]
simp [measure.trim]
rw [measure.trim, to_measure_to_outer_measure]
simp [measure.trim, outer_measure.to_measure_zero]
simp [measure.trim, hs]
rw [trim_measurable_set_eq hm (@MeasurableSet.univ _ m)]
exact measure_lt_top _ _
rw [@trim_measurable_set_eq α m₂ m (μ.trim hm) _ hm₂ (measurable_spanning_sets _ _)]
rw [@trim_trim _ _ μ _ _ hm₂ hm]
simp
constructor <;> intros
· infer_instance
· exact compact_space.is_finite_measure
simp
simp
simp
intro n
apply TS
rw [hf]
exact mem_range_self n
simp only [hT]
rw [ae_restrict_eq hs]
exact (piecewise_eq_on s f g).EventuallyEq.filter_mono inf_le_right
rw [ae_restrict_eq hs.compl]
exact (piecewise_eq_on_compl s f g).EventuallyEq.filter_mono inf_le_right
simp [piecewise, hx]
intro t
simp only [liminf, Filter.map_bot, Liminf_bot]
rfl
simp only [limsup, Filter.map_bot, Limsup_bot]
rfl
simp only [Ennreal.coe_indicator, Ennreal.coe_one]
rw [tendsto_pi_nhds] at fs_lim
exact fun ω => fs_lim ω
apply
      Ennreal.lt_add_right (measure_lt_top (μ : Measure Ω) F).Ne
        (ennreal.div_pos_iff.mpr ⟨(ennreal.coe_pos.mpr ε_pos).Ne.symm, Ennreal.two_ne_top⟩).Ne.symm
apply
      Ennreal.lt_add_right (lintegral_lt_top_of_bounded_continuous_to_nnreal (μ : Measure Ω) _).Ne
        (ennreal.div_pos_iff.mpr ⟨(ennreal.coe_pos.mpr ε_pos).Ne.symm, Ennreal.two_ne_top⟩).Ne.symm
apply
    finite_measure.limsup_measure_closed_le_of_tendsto
      ((probability_measure.tendsto_nhds_iff_to_finite_measures_tendsto_nhds L).mp μs_lim) F_closed
rw [← probability_measure.ennreal_coe_fn_eq_coe_fn_to_measure, E_nullbdry, Ennreal.coe_zero]
rw [measure.restrict_apply₀' 𝓕meas, univ_inter]
exact h𝓕_finite
rw [h𝓕.map_restrict_quotient K h𝓕_finite, h] <;> rfl
rw [MeasurableSpace.map_comp] <;> exact h s hs
simp only [lintegral_eq_supr_eapprox_lintegral, hf, simple_func.lintegral]
refine' measurableSupr fun n => Finset.measurableSum _ fun i _ => _
refine' Measurable.constMul _ _
exact measurable_coe ((simple_func.eapprox f n).measurableSetPreimage _)
simp only [measure_empty, lintegral_const, zero_mul]
simp only [join_apply hs] <;> exact measurable_lintegral (measurable_coe hs)
simp [bind]
rw [bind, join_apply hs, lintegral_map (measurable_coe hs) hf]
rw [bind, map_id]
show bind μ join = join (join μ)
rw [join_eq_bind, join_eq_bind, bind_bind measurableId measurableId]
apply congr_arg (bind μ)
funext ν
exact join_eq_bind ν
simp only [top_le_iff.mp H, Ennreal.top_add, le_top]
rw [H₁]
exact ((measure_mono <| inter_subset_right _ _).trans_lt (s.finite n)).Ne
rw [measure_Union hsd hsm]
exact tendsto.add ennreal.summable.has_sum tendsto_const_nhds
rw [← sum_add_distrib]
exact add_le_add_right (sum_le_sum fun k hk => hF k) _
rw [measure_Union hsd hsm, Ennreal.tsum_add]
rw [← inter_Union, Union_compact_covering, Set.inter_univ]
rw [← measure_Union_eq_supr, hBU]
exact Monotone.directed_le fun m n h => inter_subset_inter_right _ (compact_covering_subset _ h)
rw [inter_union_diff]
rw [Union_S]
rw [@BorelSpace.measurable_eq X _ _]
exact hm.borel_le_caratheodory
rw [← map_coe_Ioi_at_bot, tendsto_map'_iff]
simp only [mk_metric', outer_measure.supr_apply, supr_subtype']
exact tendsto_at_bot_supr fun r r' hr => mono_pre _ hr _
refine' (tendsto_pre m s).comp (tendsto_inf.2 ⟨Ennreal.tendsto_inv_nat_nhds_zero, _⟩)
refine' tendsto_principal.2 (eventually_of_forall fun n => _)
simp
rw [← isometry_comap_mk_metric _ hf H, map_comap]
rw [← isometric_comap_mk_metric _ f, map_comap_of_surjective f.surjective]
simp only [mk_metric, mk_metric'.eq_supr_nat, trim_supr]
congr 1
rw [← measure.mk_metric_to_outer_measure, coe_to_outer_measure]
intro s hs
rw [← outer_measure.coe_mk_metric, coe_smul, ← outer_measure.coe_mk_metric]
exact outer_measure.mk_metric_mono_smul hc h0 hle s
rw [← to_outer_measure_le, mk_metric_to_outer_measure]
exact outer_measure.le_mk_metric m μ.to_outer_measure ε h₀ h
simp
rw [Ennreal.coe_rpow_of_ne_zero hc, pos_iff_ne_zero, Ne.def, Ennreal.coe_eq_zero,
      Nnreal.rpow_eq_zero_iff]
exact mt And.left hc
refine' ⟨fun x => _⟩
rw [← nonpos_iff_eq_zero, hausdorff_measure_apply]
refine' supr₂_le fun ε ε0 => infi₂_le_of_le (fun n => {x}) _ <| infi_le_of_le (fun n => _) _
· exact subset_Union (fun n => {x} : ℕ → Set X) 0
· simp only [Emetric.diam_singleton, zero_le]
· simp [hd]
simp only [imp_true_iff, eq_self_iff_true, diam_singleton, eventually_at_top,
        nonpos_iff_eq_zero, exists_const]
simp only [A, csupr_pos]
refine' le_hausdorff_measure _ _
simp only [one_div, Ennreal.tendsto_inv_nat_nhds_zero]
apply eventually_at_top.2 ⟨1, fun n hn => _⟩
intro f
apply diam_pi_le_of_le fun b => _
simp only [Real.ediam_Icc, add_div, Ennreal.of_real_div_of_pos (nat.cast_pos.mpr hn), le_refl,
        add_sub_add_left_eq_sub, add_sub_cancel', Ennreal.of_real_one, Ennreal.of_real_coe_nat]
refine' add_le_add le_rfl ((div_le_div_right npos).2 _)
exact Nat.floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le)
simp only [Finset.card_univ, Nat.cast_prod, one_mul, Fintype.card_fin, Finset.sum_const,
          nsmul_eq_mul, Fintype.card_pi, div_eq_mul_inv, Finset.prod_mul_distrib, Finset.prod_const]
simp only [Real.volume_Ioo]
apply tendsto.liminf_eq
refine' Ennreal.tendsto_finset_prod_of_ne_top _ (fun i hi => _) fun i hi => _
· apply
            tendsto.congr' _
              ((ennreal.continuous_of_real.tendsto _).comp
                ((tendsto_nat_ceil_mul_div_at_top (I i)).comp tendsto_coe_nat_at_top_at_top))
          apply eventually_at_top.2 ⟨1, fun n hn => _⟩
          simp only [Ennreal.of_real_div_of_pos (nat.cast_pos.mpr hn), comp_app,
            Ennreal.of_real_coe_nat]
· simp only [Ennreal.of_real_ne_top, Ne.def, not_false_iff]
simp [hC0.ne']
simp [hd]
simp [h0]
simp [hd]
simp [ε0.ne']
simp only [hausdorff_measure, ← outer_measure.coe_mk_metric, ← outer_measure.comap_apply]
rw [outer_measure.isometry_comap_mk_metric _ hf (hd.imp_left _)]
exact fun hd x y hxy => Ennreal.rpow_le_rpow hxy hd
rw [← hf.hausdorff_measure_image hd, image_preimage_eq_inter_range]
rw [← e.image_symm, e.symm.hausdorff_measure_image]
simp
rw [with_densityᵥ, dif_pos hf]
exact dif_pos hs
rw [sub_eq_add_neg, sub_eq_add_neg, with_densityᵥ_add hf hg.neg, with_densityᵥ_neg]
refine' hf.ae_eq_of_forall_set_integral_eq f g hg fun i hi _ => _
rw [← with_densityᵥ_apply hf hi, hfg, with_densityᵥ_apply hg hi]
intro hg
exact hf (hg.congr h.symm)
rw [vector_measure.trim_measurable_set_eq hm hi, with_densityᵥ_apply hf (hm _ hi)]
refine' vector_measure.absolutely_continuous.mk fun j hj₁ hj₂ => _
rw [measure.to_ennreal_vector_measure_apply_measurable hj₁, trim_measurable_set_eq hm hj₁] at hj₂
rw [vector_measure.trim_measurable_set_eq hm hj₁, with_densityᵥ_apply hfi (hm _ hj₁)]
simp only [measure.restrict_eq_zero.mpr hj₂, integral_zero_measure]
rw [measure.lintegral_join, lintegral_map] <;>
            trace
              "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr measurable_id, \",\", expr measure.measurable_lintegral, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
intros <;> rfl
exact j.2
unfold generate_measurable_rec
trace
    "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr subset_union_of_subset_left, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
exact subset_rfl
unfold generate_measurable_rec
exact mem_union_left _ (mem_union_left _ (mem_union_right _ (mem_singleton ∅)))
unfold generate_measurable_rec
exact mem_union_left _ (mem_union_right _ ⟨t, mem_Union.2 ⟨⟨j, h⟩, ht⟩, rfl⟩)
unfold generate_measurable_rec
exact
    mem_union_right _
      ⟨fun n =>
        ⟨f n,
          let ⟨j, hj, hf⟩ := hf n
          mem_Union.2 ⟨⟨j, hj⟩, hf⟩⟩,
        rfl⟩
simp
rw [well_founded_on_iff] at *
refine' Subrelation.wf (fun x y xy => _) h
exact ⟨hle _ _ xy.1, hst xy.2.1, hst xy.2.2⟩
simp [is_wf, well_founded_on_iff]
simp only [← singleton_union, partially_well_ordered_on_union,
    partially_well_ordered_on_singleton, true_and_iff]
simp only [← singleton_union, is_pwo_union, is_pwo_singleton, true_and_iff]
simp only [← singleton_union, is_wf_union, is_wf_singleton, true_and_iff]
simp only [← singleton_union, well_founded_on_union, well_founded_on_singleton, true_and_iff]
simp
simp [-sup_set_eq_bUnion, hs]
simp
simp [-sup_set_eq_bUnion, hs]
refine'
    le_antisymm
      (le_min (is_wf.min_le_min_of_subset (subset_union_left _ _))
        (is_wf.min_le_min_of_subset (subset_union_right _ _)))
      _
rw [min_le_iff]
exact
    ((mem_union _ _ _).1 ((hs.union ht).min_mem (union_nonempty.2 (Or.intro_left _ hsn)))).imp
      (hs.min_le _) (ht.min_le _)
simp [is_bad_seq]
refine' Nat.rec _ _
·
      exact
        ⟨(min_bad_seq_of_bad_seq r rk s 0 f0 hf0).1, (min_bad_seq_of_bad_seq r rk s 0 f0 hf0).2.2⟩
·
      exact fun n fn =>
        ⟨(min_bad_seq_of_bad_seq r rk s (n + 1) fn.1 fn.2.1).1,
          (min_bad_seq_of_bad_seq r rk s (n + 1) fn.1 fn.2.1).2.2⟩
intro _ _ _ _ hα hβ
exact Relation.TransGen.tail (Relation.TransGen.single <| game_add.fst hα) (game_add.snd hβ)
intro x y h
rw [lt_iff_le_not_le, lt_iff_le_not_le, hf.le_iff_le ha hb, hf.le_iff_le hb ha]
refine' StrictMonoOn.Iic_union_Ici (fun x hx y hy hxy => neg_lt_neg_iff.1 _) h₂
rw [← h₁, ← h₁]
exact h₂ (neg_nonneg.2 hy) (neg_nonneg.2 hx) (neg_lt_neg hxy)
refine' MonotoneOn.Iic_union_Ici (fun x hx y hy hxy => neg_le_neg_iff.1 _) h₂
rw [← h₁, ← h₁]
exact h₂ (neg_nonneg.2 hy) (neg_nonneg.2 hx) (neg_le_neg hxy)
rw [← strictMonoOn_univ, ← @Iic_union_Ici _ _ a]
exact StrictMonoOn.union h₁ h₂ is_greatest_Iic is_least_Ici
rw [← monotoneOn_univ, ← @Iic_union_Ici _ _ a]
exact MonotoneOn.union_right h₁ h₂ is_greatest_Iic is_least_Ici
cases s
cases t
exact congr_arg _ (ideal.ext h)
delta Antitone <;> simp
simp
simp
rfl
refine' hf.seq_le_seq n _ (fun k hk => _) fun k hk => _ <;> simp [iterate_succ', H _]
rw [iterate_succ_apply']
exact h _
refine' hf.seq_le_seq n _ (fun k hk => _) fun k hk => _ <;>
    simp [iterate_succ' f, h.iterate_right _ _, hg.iterate _ hx]
refine' hf.seq_pos_lt_seq_of_le_of_lt hn _ (fun k hk => _) fun k hk => _ <;>
    simp [iterate_succ' f, h.iterate_right _ _, hg.iterate _ hx]
simp only [le_antisymm_iff, h.iterate_pos_le_iff_map_le hf hg hn,
    h.symm.iterate_pos_le_iff_map_le' hg hf hn]
rw [iterate_succ_apply]
exact hf.iterate n hx
rw [iterate_succ_apply]
exact hf.iterate n hx
simp <;> rfl
simp only [DirectedOn, Set.ball_image_iff, Set.bex_image_iff, Order.Preimage]
assumption
assumption
simp [supr, le_Sup_iff, upperBounds]
simp [infi, Inf_le_iff, lowerBounds]
simp
apply (is_glb_Inf _).2
simp [*]
simp [*]
simp
simp [*]
simp [*]
rw [Set.eq_singleton_iff_nonempty_unique_mem]
rw [Sup_eq_bot] at h_sup
exact ⟨hne, h_sup⟩
rw [supr, Subtype.range_coe]
simp only [supr, hf.range_comp]
rw [supr, supr, ← image_eq_range, ← range_comp]
rw [supr, image_eq_range]
rw [Sup_eq_supr] <;> exact hf.le_map_supr₂ _
simp only [f.le_iff_le, supr_le_iff]
simp only [Sup_eq_supr, OrderIso.map_supr]
rw [Sup_eq_supr]
exact hf.map_supr₂_le _
rw [supr, range_const, Sup_singleton]
simp only [@supr_comm _ (κ₁ _), @supr_comm _ ι₁]
simp only [@infi_comm _ (κ₁ _), @infi_comm _ ι₁]
rw [supr_sup_eq, supr_const]
rw [infi_inf_eq, infi_const]
rw [supr_sup_eq, supr_const]
rw [infi_inf_eq, infi_const]
rw [← supr_sup_eq]
congr 1
rw [← supr_subtype'', supr_range']
rw [← supr_subtype'', Sup_image']
simp
simp
simp
simp
simp
simp
rw [supr_insert, supr_singleton]
rw [infi_insert, infi_singleton]
rw [← Sup_image, ← Sup_image, ← image_comp]
rw [supr_split _ fun j => ∃ i, e i = j]
simp (config := { contextual := true }) [he.extend_apply, extend_apply', @supr_comm _ β ι]
rw [supr, Bool.range_eq, Sup_pair, sup_comm]
rw [supr_bool_eq, Bool.cond_true, Bool.cond_false]
simp only [supr_le_iff, Sigma.forall]
simp only [supr_le_iff, Prod.forall]
simp only [sup_le_iff, supr_le_iff, Sum.forall]
simp only [supr_le_iff, sup_le_iff, Option.forall]
simp [supr_option]
rw [← image_prod, Sup_image, bsupr_prod]
rw [← image_prod, Inf_image, binfi_prod]
dsimp only
rw [Nat.sub_add_cancel hi]
rw [supr_union, supr_singleton, supr_range]
rw [Nat.zero_union_range_succ, supr_univ]
rw [← infi_range, Nat.range_succ]
simp only [mem_set_of]
simp only [← Sup_range, Sup_eq_top, Set.exists_range_iff]
simp only [← Inf_range, Inf_eq_bot, Set.exists_range_iff]
rw [supr, Sup_apply, supr, supr, ← image_eq_range (fun f : ∀ i, β i => f a) (range f), ←
    range_comp]
unfold Sup
simp [← eq_iff_iff]
unfold Inf
simp [← eq_iff_iff]
unfold Sup
simp [← eq_iff_iff]
unfold Inf
simp [← eq_iff_iff]
cases f
cases g
congr
simp [f.map_rel_iff, g.map_rel_iff]
refine' fun x y => Quotient.induction_on₂ x y fun a b => _
apply iff_iff_eq.2 (H _ _ _ _ _ _) <;> apply Quotient.mk_out
simp [Prod.lex_def, h]
simp [Prod.lex_def, h]
simp [Prod.lex_def, f.map_rel_iff, g.map_rel_iff]
congr
exact h
erw [← f.map_rel_iff, f.1.apply_symm_apply, f.1.apply_symm_apply]
subst h₁
rw [eq_of_heq h₂]
rfl
subst h₁
rfl
rw [← e.map_rel_iff, e.apply_symm_apply]
rw [← e.map_rel_iff, e.apply_symm_apply]
simp [Prod.lex_def, e₁.map_rel_iff, e₂.map_rel_iff]
simp [not_rel_of_subsingleton r, not_rel_of_subsingleton s]
simp [rel_of_subsingleton r, rel_of_subsingleton s]
rw [nonempty_iff_ne_empty, not_iff_not, parts_eq_empty_iff]
rw [sup_indep_iff_pairwise_disjoint, coe_insert]
exact P.disjoint.insert fun d hd hbd => hab.symm.mono_right <| P.le hd
rw [sup_image, comp.left_id, Finset.sup_sdiff_right, ← id_def, P.sup_parts]
rw [Finset.coe_map]
exact finset.pairwise_disjoint_range_singleton.subset (Set.image_subset_range _ _)
rw [sup_map, comp.left_id, embedding.coe_fn_mk, Finset.sup_singleton']
simp
rw [← card_bot s]
exact card_mono bot_le
simp only [atomise, of_erase, bot_eq_empty, mem_erase, mem_image, nonempty_iff_ne_empty,
    mem_singleton, and_comm', mem_powerset, exists_prop]
simp only [atomise, powerset_empty, image_singleton, not_mem_empty, IsEmpty.forall_iff,
    imp_true_iff, filter_true]
exact erase_eq_of_not_mem (not_mem_singleton.2 hs.ne_empty.symm)
rw [← P.sum_card_parts]
exact equitable_on.le hP ht
rw [← P.sum_card_parts]
exact equitable_on.le_add_one hP ht
simp
rw [is_equipartition, indiscrete_parts, coe_singleton]
exact Set.equitable_on_singleton s _
rw [supr, supr, map_Sup, Set.range_comp]
rw [infi, infi, map_Inf, Set.range_comp]
rw [← Sup_pair, map_Sup, Set.image_pair, Sup_pair]
rw [← Sup_empty, map_Sup, Set.image_empty, Sup_empty]
rw [← Inf_pair, map_Inf, Set.image_pair, Inf_pair]
rw [← Inf_empty, map_Inf, Set.image_empty, Inf_empty]
simp only [← le_map_inv_iff, Sup_le_iff, Set.ball_image_iff]
simp only [← map_inv_le_iff, le_Inf_iff, Set.ball_image_iff]
cases f <;> cases g <;> congr
rw [id, Set.image_id]
rw [comp_apply, map_Sup, map_Sup, Set.image_image]
rw [← comp_apply, h, comp_apply]
cases f <;> cases g <;> congr
rw [id, Set.image_id]
rw [comp_apply, map_Inf, map_Inf, Set.image_image]
rw [← comp_apply, h, comp_apply]
rw [← comp_apply, h, comp_apply]
rw [← comp_apply, h, comp_apply]
simp only [Set.Sup_eq_sUnion, Set.sUnion_image]
simp only [Set.Inf_eq_sInter, Set.sInter_image]
rw [← map_top f, (EquivLike.injective f).eq_iff]
rw [← map_bot f, (EquivLike.injective f).eq_iff]
cases f <;> cases g <;> congr
rw [comp_apply, map_top, map_top]
rw [← TopHom.comp_apply, h, TopHom.comp_apply]
rw [Pi.inf_apply, map_top, map_top, inf_top_eq]
rw [Pi.sup_apply, map_top, map_top, sup_top_eq]
cases f <;> cases g <;> congr
rw [comp_apply, map_bot, map_bot]
rw [← BotHom.comp_apply, h, BotHom.comp_apply]
rw [Pi.inf_apply, map_bot, map_bot, inf_bot_eq]
rw [Pi.sup_apply, map_bot, map_bot, sup_bot_eq]
rw [← BoundedOrderHom.comp_apply, h, BoundedOrderHom.comp_apply]
cases f
cases g
congr
simp [le_def]
intros
simp [le_iff_lt_or_eq, f.map_rel_iff, f.injective.eq_iff]
intros <;> simp [lt_iff_le_not_le, f.map_rel_iff]
rw [← e.symm_symm, h, e'.symm_symm]
simp [le_iff_eq_or_lt, e.map_rel_iff]
intro
rw [← cmp_eq_eq_iff, h, cmp_self_eq_eq]
intro
rw [← cmp_eq_eq_iff, ← h, cmp_self_eq_eq]
simp [Pi.le_def, Unique.forall_iff]
refine' le_antisymm _ (hy _)
rw [← f.apply_symm_apply y, f.map_rel_iff]
apply hx
rw [disjoint_iff_inf_le, ← f.map_inf, ← f.map_bot]
exact f.monotone ha.le_bot
rw [codisjoint_iff_le_sup, ← f.map_sup, ← f.map_top]
exact f.monotone ha.top_le
intro
exact f.complemented_lattice
intro
exact f.symm.complemented_lattice
rw [← sup_eq_right, ← map_sup, sup_eq_right.2 h]
rw [← inf_eq_left, ← map_inf, inf_eq_left.2 h]
simp only [← le_map_inv_iff, sup_le_iff]
simp only [← map_inv_le_iff, le_inf_iff]
rw [Finset.sup_cons, Finset.sup_cons, map_sup, h]
rw [Finset.inf_cons, Finset.inf_cons, map_inf, h]
rw [disjoint_iff, ← map_inf, h.eq_bot, map_bot]
rw [codisjoint_iff, ← map_sup, h.eq_top, map_top]
rw [sdiff_eq, sdiff_eq, map_inf, map_compl']
rw [symmDiff, symmDiff, map_sup, map_sdiff', map_sdiff']
cases f <;> cases g <;> congr
rw [comp_apply, map_sup, map_sup]
rw [← SupHom.comp_apply, h, SupHom.comp_apply]
rw [Pi.sup_apply, map_sup, map_sup]
exact sup_sup_sup_comm _ _ _ _
cases f <;> cases g <;> congr
rw [comp_apply, map_inf, map_inf]
rw [← InfHom.comp_apply, h, InfHom.comp_apply]
rw [Pi.inf_apply, map_inf, map_inf]
exact inf_inf_inf_comm _ _ _ _
rw [← comp_apply, h, comp_apply]
rw [← comp_apply, h, comp_apply]
rw [← LatticeHom.comp_apply, h, LatticeHom.comp_apply]
rw [← comp_apply, h, comp_apply]
rw [← Function.iterate_succ_apply]
rw [sup_comm]
rw [sup_comm]
refine' (Symmetric.pairwise_on Disjoint.symm _).2 fun m n h => _
cases n
· exact (Nat.not_lt_zero _ h).elim
exact
    disjoint_sdiff_self_right.mono_left
      ((disjointed_le f m).trans (le_partial_sups_of_le f (Nat.lt_add_one_iff.1 h)))
rw [disjointed_succ, hf.partial_sups_eq]
simp [(· ≤ ·)]
cases ha <;> exact ⟨_, rfl, le_top⟩
simp [some_eq_coe, coe_eq_coe]
simp [none_eq_bot]
simp [some_eq_coe, coe_eq_coe]
simp [none_eq_bot]
simp [(· < ·)]
simp [some_eq_coe, coe_eq_coe]
simp [none_eq_bot]
simp [some_eq_coe, coe_eq_coe, coe_lt_coe]
simp [none_eq_bot, bot_lt_coe]
intros
cases a <;> cases b <;> simp [lt_iff_le_not_le] <;> simp [(· < ·), (· ≤ ·)]
simp [Monotone]
simp [StrictMono, bot_lt_coe]
simp only [map_bot, bot_le]
simp only [map_coe, map_bot, coe_ne_bot, not_coe_le_bot _]
cases a <;> simp [none_eq_bot, some_eq_coe]
cases ha <;> cases o₂ <;> simp [Option.liftOrGet]
cases ha <;> cases o₁ <;> simp [Option.liftOrGet]
simp [*]
simp [*]
simp [*]
simp only [← to_dual_le_to_dual_iff, to_dual_apply_coe, WithBot.coe_le_coe, to_dual_le_to_dual]
cases ha <;> exact ⟨_, rfl, bot_le⟩
simp only [← to_dual_le_to_dual_iff, to_dual_apply_coe, WithBot.le_coe_iff, OrderDual.forall,
    to_dual_le_to_dual]
exact forall₂_congr fun _ _ => Iff.rfl
simp only [← to_dual_lt_to_dual_iff, to_dual_apply_coe, WithBot.coe_lt_coe, to_dual_lt_to_dual]
rw [← to_dual_lt_to_dual_iff]
exact WithBot.not_lt_none _
rw [← to_dual_lt_to_dual_iff, WithBot.lt_iff_exists_coe, OrderDual.exists]
exact exists_congr fun _ => and_congr_left' Iff.rfl
simp only [← to_dual_lt_to_dual_iff, WithBot.lt_coe_iff, to_dual_apply_coe, OrderDual.forall,
    to_dual_lt_to_dual]
exact forall₂_congr fun _ _ => Iff.rfl
simp [← to_dual_lt_to_dual_iff, lt_iff_le_not_le]
simp [Monotone]
simp [StrictMono, coe_lt_top]
rw [← to_dual_le_to_dual_iff, to_dual_map, to_dual_map, WithBot.map_le_iff,
    to_dual_le_to_dual_iff]
simp [mono_iff]
cases ha <;> cases o₂ <;> simp [Option.liftOrGet]
cases ha <;> cases o₁ <;> simp [Option.liftOrGet]
refine' ⟨fun h => h.has_min, fun h => ⟨fun x => _⟩⟩
simp only [eq_iff_not_lt_of_le, well_founded_iff_has_min]
rw [WellFounded.succ, dif_pos h]
apply min_mem
intro hy
rw [WellFounded.succ, dif_pos] at h'
exact wo.wf.not_lt_min _ h hy h'
rw [hfg]
exact Set.mem_range_self b
funext a
apply h.induction a
exact fun b H =>
      le_antisymm (eq_strict_mono_iff_eq_range_aux hf hg hfg H)
        (eq_strict_mono_iff_eq_range_aux hg hf hfg.symm fun a hab => (H a hab).symm)
rw [inf_comm, sup_comm]
exact fun ha hb => cov
rw [sup_comm, inf_comm]
exact fun ha hb => inf_cov
rw [sup_comm, inf_comm]
exact cov
rw [inf_comm, sup_comm]
exact inf_cov
rw [inf_comm, sup_comm, ← sup_inf_assoc_of_le y h, inf_comm, sup_comm]
rw [inf_comm, sup_comm, eq_comm, inf_comm, sup_comm]
exact @sup_inf_assoc_of_le α _ _ _ y _ xz
rw [inf_comm, @inf_comm _ _ z] <;> exact hinf
change a
change a
simp only [Subtype.mk_le_mk, Equiv.coe_fn_mk, and_true_iff, le_sup_right]
rw [← Subtype.coe_le_coe]
refine' ⟨fun h => _, fun h => sup_le_sup_right h _⟩
rw [← sup_eq_right.2 x.prop.1, inf_sup_assoc_of_le _ x.prop.2, sup_comm, ←
      sup_eq_right.2 y.prop.1, inf_sup_assoc_of_le _ y.prop.2, @sup_comm _ _ b]
exact inf_le_inf_left _ h
dsimp
rw [sup_comm, ← inf_sup_assoc_of_le _ c.prop.2.le, sup_eq_right.2 c.prop.1.le]
dsimp
rw [inf_comm, inf_sup_assoc_of_le _ c.prop.1.le, inf_eq_left.2 c.prop.2.le]
rw [← inf_eq_left.2 xz, h]
rw [inf_sup_right, inf_eq_left.2 xz]
constructor
· rw [disjoint_iff_inf_le]
        change x
constructor
· rw [disjoint_iff_inf_le]
        change x
rw [supr, Sup_inf_eq, supr_range]
simp only [supr_inf_eq]
simp only [inf_supr_eq]
simp only [inf_supr_eq, supr_inf_eq, supr_prod]
simp only [supr_subtype', supr_inf_supr]
exact (Equiv.surjective _).supr_congr (Equiv.Set.prod s t).symm fun x => rfl
simp only [Sup_eq_supr, bsupr_inf_bsupr]
simp only [disjoint_iff, supr_inf_eq, supr_eq_bot]
simp only [disjoint_iff, Sup_inf_eq, supr_eq_bot]
simp only [CompleteLattice.sup, Sup_apply, supr_apply, Pi.inf_apply, inf_supr_eq, ←
        supr_subtype'']
rw [← Sup_pair, ← Sup_pair, inf_Sup_eq, ← Sup_image, image_pair]
simp only [← sup_infi_eq, Inf_apply, ← infi_subtype'', infi_apply, Pi.sup_apply]
rw [← Inf_pair, ← Inf_pair, sup_Inf_eq, ← Inf_image, image_pair]
simp only [forall_or_left, CompleteLattice.inf, infi_Prop_eq, sup_Prop_eq]
simp only [CompleteLattice.sup, exists_and_left, inf_Prop_eq, supr_Prop_eq]
simp [compl_infi]
simp only [Inf_eq_infi, compl_infi]
simp only [Sup_eq_supr, compl_supr]
rw [le_iff_lt_or_eq, h.lt_iff]
simp
simp
apply h.eq_top_or_exists_le_coatom
apply h.eq_bot_or_exists_atom_le
apply h.eq_bot_or_exists_atom_le
apply h.eq_top_or_exists_le_coatom
apply h.eq_Inf_coatoms
apply h.eq_Sup_atoms
apply h.eq_Sup_atoms
apply h.eq_Inf_coatoms
rw [← Sup_atoms_le_eq a, ← Sup_atoms_le_eq b]
exact Sup_le_Sup fun c hc => ⟨hc.1, h c hc.1 hc.2⟩
infer_instance
assumption
cases x <;> simp [bot_ne_top]
infer_instance
rw [← gi.is_atom_iff hbot h_atom, gi.l_u_eq]
simp only [is_atomic_iff, f.surjective.forall, f.surjective.exists, ← map_bot f, f.eq_iff_eq,
    f.le_iff_le, f.is_atom_iff]
simp only [← is_atomic_dual_iff_is_coatomic, f.dual.is_atomic_iff]
rw [Sup_eq_sUnion, sUnion_image, bUnion_of_singleton]
rw [Inf_eq_sInter, sInter_image, ← compl_Union₂, bUnion_of_singleton, compl_compl]
cases s
cases t
congr
change p ∉ ↑I at nmem
rw [hp] at nmem
exact nmem (mem_univ p)
simp [hI.2 _ ‹_›]
simp
simp
cases inter_nonempty I J
exact ⟨w, w, h.1, w, h.2, le_sup_left⟩
cases J.nonempty
exact ⟨i, ‹_›, w, ‹_›, le_sup_left⟩
cases I.nonempty
exact ⟨w, ‹_›, j, ‹_›, le_sup_right⟩
rw [LowerSet.carrier_eq_coe, LowerSet.coe_infi₂, Set.mem_Inter₂]
exact fun s _ => s.bot_mem
rw [LowerSet.carrier_eq_coe, LowerSet.coe_infi₂, Set.mem_Inter₂] at ha hb⊢
exact fun s hs => sup_mem (ha _ hs) (hb _ hs)
apply monotone_nat_of_le_succ
intro n
dsimp only [sequence_of_cofinals]
cases Encodable.decode ι n
· rfl
· apply cofinal.le_above
dsimp only [sequence_of_cofinals]
rw [Encodable.encodek]
apply cofinal.above_mem
rw [max_chain_spec.right this (subset_insert _ _)]
exact mem_insert _ _
rw [acc_iff_no_decreasing_seq, not_isEmpty_iff]
exact ⟨⟨f, k, rfl⟩⟩
rw [well_founded_iff_no_descending_seq, not_isEmpty_iff]
exact ⟨f⟩
simp [subtype.order_iso_of_nat]
simp only [Set.infinite_coe_iff, ← Set.infinite_union, ← Set.preimage_union,
        Set.eq_univ_of_forall fun n => Set.mem_preimage.2 (he n), Set.infinite_univ]
simp
trace
      "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr ∀ a, «expr∃ , »((n), ∀ (m) (h : «expr ≤ »(n, m)), (_ : exprProp()))]]"
rw [lt_iff_le_and_ne]
simp [a.mono h]
exact le_antisymm this (le_supr a _)
  apply supr_le
  intro m
refine' Nat.Inf_mem _
rw [WellFounded.monotone_chain_condition] at h
exact h a
constructor
simp only [Set.mem_setOf_eq, Set.mem_univ, eventually_true]
intro x y hx hxy
simp only [Set.mem_setOf_eq] at hx⊢
exact hx.mono fun a ha => ha.mono fun b hb => Set.mem_of_subset_of_mem hxy hb
intro x y hx hy
simp only [Set.mem_setOf_eq, Set.mem_inter_iff] at hx hy⊢
exact (hx.and hy).mono fun a ha => (ha.1.And ha.2).mono fun b hb => hb
intro u hu
rw [← eventually_mem_set] at hu⊢
rw [eventually_curry_iff]
exact hu.curry
simp [at_top_basis.frequently_iff]
simp [at_top_basis_Ioi.frequently_iff]
simp only [at_top, tendsto_infi, tendsto_principal, mem_Ici]
simp [at_top, ← e.surjective.infi_comp]
rw [← e.comap_at_top, map_comap_of_surjective e.surjective]
rw [← e.comap_at_top, tendsto_comap_iff]
rw [frequently_at_top'] at h
exact extraction_of_frequently_at_top' h
simp [eventually_at_top, h]
simp [hg]
simp [hf]
simp [not_tendsto_const_at_bot]
simp only [mul_comm _ r, tendsto_const_mul_at_top_iff_pos h]
simp only [mul_comm _ r, tendsto_const_mul_at_top_iff]
simp only [← tendsto_neg_at_top_iff, ← mul_neg, tendsto_const_mul_at_top_iff, neg_neg]
simp only [mul_comm _ r, tendsto_const_mul_at_bot_iff]
simp [tendsto_const_mul_at_top_iff, h, h.not_tendsto disjoint_at_bot_at_top]
simp only [mul_comm _ r, tendsto_const_mul_at_top_iff_neg h]
simp [tendsto_const_mul_at_bot_iff, h, h.not_tendsto disjoint_at_bot_at_top]
simp only [mul_comm _ r, tendsto_const_mul_at_bot_iff_pos h]
simp [tendsto_const_mul_at_bot_iff, h, h.not_tendsto disjoint_at_top_at_bot]
simp only [mul_comm _ r, tendsto_const_mul_at_bot_iff_neg h]
simp only [← tendsto_neg_at_top_iff, ← neg_mul, tendsto_const_mul_pow_at_top_iff, neg_pos]
simp only [tendsto_def, mem_at_top_sets] <;> rfl
rw [tendsto_iff_comap, comap_principal, le_principal_iff, mem_at_top_sets] <;> rfl
rw [← comap_embedding_at_top hm hu, tendsto_comap_iff]
refine' le_antisymm (le_infi fun i => le_principal_iff.2 <| mem_at_top {i}) _
refine'
    le_infi fun s =>
      le_principal_iff.2 <| mem_infi_of_Inter s.finite_to_set (fun i => mem_principal_self _) _
simp only [subset_def, mem_Inter, SetCoe.forall, mem_Ici, Finset.le_iff_subset,
    Finset.mem_singleton, Finset.subset_iff, forall_eq]
dsimp
exact fun t => id
simp only [Finset.image_singleton, h a, Finset.mem_singleton]
cases (isEmpty_or_nonempty β₁).symm
cases (isEmpty_or_nonempty β₂).symm
· simp [at_top, prod_infi_left, prod_infi_right, infi_prod]
    exact infi_comm
· simp only [at_top.filter_eq_bot_of_is_empty, prod_bot]
· simp only [at_top.filter_eq_bot_of_is_empty, bot_prod]
rw [prod_map_map_eq, prod_at_top_at_top_eq, Prod.map_def]
rw [← prod_at_bot_at_bot_eq]
exact tendsto_id.prod_mk tendsto_id
rw [← prod_at_top_at_top_eq]
exact tendsto_id.prod_mk tendsto_id
rw [← prod_at_bot_at_bot_eq]
exact hf.prod_map hg
rw [← prod_at_top_at_top_eq]
exact hf.prod_map hg
rw [← prod_at_bot_at_bot_eq]
exact hf.prod_map_prod_at_bot hg
rw [← prod_at_top_at_top_eq]
exact hf.prod_map_prod_at_top hg
simp [← prod_at_bot_at_bot_eq, at_bot_basis.prod_self.eventually_iff]
simp [← prod_at_top_at_top_eq, at_top_basis.prod_self.eventually_iff]
rw [← prod_at_top_at_top_eq] at hp
exact hp.curry
rw [← map_coe_Ici_at_top a, comap_map Subtype.coe_injective]
rw [at_top_Ioi_eq, tendsto_comap_iff]
rw [at_bot_Iio_eq, tendsto_comap_iff]
rw [at_top_Ici_eq, tendsto_comap_iff]
rw [at_bot_Iic_eq, tendsto_comap_iff]
rw [← map_coe_Ioi_at_top a, tendsto_map'_iff]
rw [← map_coe_Ici_at_top a, tendsto_map'_iff]
rw [← map_coe_Iio_at_bot a, tendsto_map'_iff]
rw [← map_coe_Iic_at_bot a, tendsto_map'_iff]
rw [tsub_add_cancel_of_le h]
rw [add_tsub_cancel_right]
rw [← tendsto_map'_iff, map_add_at_top_eq_nat]
rw [← Nat.succ_eq_add_one, Nat.lt_succ_iff]
cases k
exact (lt_irrefl _ hk).elim
rw [add_mul, one_mul, Nat.succ_sub_succ_eq_sub, tsub_zero, Nat.add_succ, Nat.lt_succ_iff]
rw [Nat.mul_div_cancel b hk]
simp [Set.image_subset_iff] <;> exact hv
rw [tendsto_def]
refine' forall_congr' fun s => imp_congr_right fun hsf => _
rfl
rw [image2_singleton_left, image_subset_iff]
rw [image2_singleton_right, image_subset_iff]
rw [map₂_pure_right, map_pure]
rw [map₂_swap, map₂_left h]
rw [← image_subset_iff, image_image2]
rw [map₂_swap, map₂_map_left, map₂_swap]
rw [← map₂_curry, curry_uncurry]
simp only [map₂_map₂_left, map₂_map₂_right, h_assoc]
rw [map₂_swap m', map₂_swap m]
exact map₂_assoc fun _ _ _ => h_left_comm _ _ _
rw [map₂_swap n, map₂_swap n']
exact map₂_assoc fun _ _ _ => h_right_comm _ _ _
rw [map₂_swap m]
exact map_map₂_distrib fun _ _ => h_antidistrib _ _
simp only [compl_univ, finite_empty, mem_set_of_eq]
simp only [compl_inter, finite.union, ht, hs, mem_set_of_eq]
simp only [Filter.Frequently, Filter.Eventually, mem_cofinite, compl_set_of, not_not,
    Set.Infinite]
simp only [compl_mem_coprod, mem_cofinite, compl_compl, finite_image_fst_and_snd_iff]
simp only [compl_mem_Coprod, mem_cofinite, compl_compl, forall_finite_image_eval_iff]
simp only [has_basis_cofinite.disjoint_iff l.basis_sets, id, disjoint_compl_left_iff_subset]
exact
    ⟨fun ⟨s, hs, t, ht, hts⟩ => ⟨t, ht, hs.Subset hts⟩, fun ⟨s, hs, hsf⟩ =>
      ⟨s, hsf, s, hs, subset.rfl⟩⟩
rw [← Nat.cofinite_eq_at_top, frequently_cofinite_iff_infinite]
simp only [Hf, Hg]
simp only [← coe_one, ← coe_smul', one_smul]
simp only [← coe_zero, ← coe_smul, smul_zero]
simp only [← coe_zero, ← coe_smul', smul_zero]
simp only [← coe_zero, ← coe_smul', zero_smul]
simp only [pi, tendsto_infi, tendsto_comap_iff]
rw [pi_def, bInter_eq_Inter]
refine' mem_infi_of_Inter hI (fun i => _) subset.rfl
exact preimage_mem_comap (h i i.2)
rw [← univ_pi_piecewise I, pi_inf_principal_univ_pi_eq_bot]
refine' exists_congr fun i => _
simp [ne_bot_iff]
simp [ne_bot_iff]
simp [ne_bot_iff]
simp [Filter.coprod]
simp only [Filter.coprod, mem_supr, compl_mem_comap]
simp only [Filter.coprod, supr_ne_bot, ← exists_and_left, ← comap_eval_ne_bot_iff']
simp [Coprod_ne_bot_iff', *]
simp only [small_sets_principal, prod_principal_principal, tendsto_principal_principal,
      forall_prod_set, mem_powerset_iff, mem_principal]
rw [← principal_singleton]
exact tendsto_Ixx_class_principal.2 ord_connected_singleton.out
simp
simp
simp
simp
rw [Ne.def, coe_eq_zero]
exact (ne_of_lt hr_pos).symm
simp [← mul_assoc, inv_mul_cancel ha_zero ha_top]
simp [g, ← mul_assoc, mul_inv_cancel ha_zero ha_top]
refine' hu.mono fun x hx => _
rw [Pi.zero_apply] at hx
simp [hx]
rw [eventually_eq, not_eventually] at hu
refine' hu.mono fun x hx => _
rw [Pi.zero_apply] at hx
simp [hx]
rw [eventually_countable_forall]
exact fun b => Ennreal.eventually_le_limsup fun a => u a b
refine' hle.mp (h.mono fun x hf hgf => _)
rw [← hfga]
exact le_trans hgf hf
simp [Nat.modeq_iff_dvd, ← sub_sub]
simp only [(· ∘ ·), inv_zero]
simp only [lt_iff_le_not_le, eventually_and, coe_le, eventually_not, eventually_le]
rw [max_def, map₂_const]
rw [min_def, map₂_const]
rw [abs_def, map_const]
rw [small_sets, lift'_bot monotone_powerset, powerset_empty, principal_singleton]
rw [small_sets, lift'_top, powerset_univ, principal_univ]
rw [tendsto_small_sets_iff] at ht⊢
exact fun u hu => (ht u hu).mp (hst.mono fun a hst ht => subset.trans hst ht)
simp only [eventually_iff_exists_mem]
simp only [eventually_inf, and_comm', mem_inter_iff, ← and_imp]
rw [← tendsto_comap_iff, Int.comap_coe_at_top]
rw [← tendsto_comap_iff, Int.comap_coe_at_bot]
rw [← tendsto_comap_iff, Rat.comap_coe_at_top]
rw [← tendsto_comap_iff, Rat.comap_coe_at_bot]
rw [one_mul]
exact le_max_left _ _
rw [mul_assoc]
rw [mul_one]
exact le_max_left _ _
rw [mul_assoc]
simp only [← tendsto_neg_at_top_iff, ← neg_mul] at hf⊢
exact hf.at_top_mul_const' hr
simp only [← tendsto_neg_at_top_iff, ← neg_zsmul] at hf⊢
exact hf.at_top_zsmul_const hr
simp only [*, hst.1 hxs, indicator_of_mem]
simp only [indicator_of_not_mem hxs, indicator_of_not_mem (mt hst.2 hxs)]
refine' hf.indicator.trans _
rw [indicator_zero']
simp only [filter_eq_iff, ext_iff, Filter.mem_sets]
simp
simp [hs]
rw [sInter_eq_bInter, bInter_mem hfin]
simp only [mem_set_of_eq, univ_sets, ← Filter.mem_sets, set_of_true]
simp
rw [mem_top_iff_forall, eq_univ_iff_forall]
simp [mem_top.1 hs]
simp [ne_bot_iff, not_and_or]
rw [disjoint_self, ne_bot_iff]
simp only [← Filter.mem_sets, supr_sets_eq, iff_self_iff, mem_Inter]
simp [ne_bot_iff]
rw [sInter_mem (σfin _)]
apply σsub
simp only [le_principal_iff, iff_self_iff, mem_principal]
simp only [le_antisymm_iff, le_principal_iff, mem_principal] <;> rfl
simp only [le_principal_iff, mem_top, eq_self_iff_true]
simp [sets_iff_generate, le_principal_iff, subset_def]
simp only [disjoint_iff, ← empty_mem_iff_bot, mem_inf_iff, inf_eq_inter, bot_eq_empty,
    @eq_comm _ ∅]
rw [infi_subtype']
apply eq_infi_of_mem_iff_exists_mem
intro s
exact h.trans ⟨fun ⟨i, pi, si⟩ => ⟨⟨i, pi⟩, si⟩, fun ⟨⟨i, pi⟩, si⟩ => ⟨i, pi, si⟩⟩
simp only [mem_Union] <;> exact ⟨i, univ_mem⟩
      sets_of_superset
simp only [mem_Union, exists_imp] <;> intro x y i hx hxy <;>
          exact ⟨i, mem_of_superset hx hxy⟩
simp only [Filter.mem_mk, mem_Union, Filter.mem_sets]
simp only [← Filter.mem_sets, infi_sets_eq h, mem_Union]
simp [mem_binfi_of_directed h Ne]
rw [infi_eq_infi_finset, infi_sets_eq]
exact directed_of_sup fun s₁ s₂ => binfi_mono
rw [← infi_sets_eq_finite, ← equiv.plift.surjective.infi_comp]
rfl
simp only [mem_sup, mem_join]
simp only [mem_supr, mem_join]
exact this ⟨h₁, hu⟩
      refine' Finset.induction_on u (le_sup_of_le_right le_top) _
      rintro ⟨i⟩ u _ ih
      rw [Finset.inf_insert, sup_inf_left]
      exact le_inf (infi_le _ _) ih
cases isEmpty_or_nonempty ι
· constructor
    simp [infi_of_empty f, top_ne_bot]
· exact infi_ne_bot_of_directed' hd hb
simp only [le_principal_iff, mem_inf_iff] <;> exact ⟨s, subset.rfl, t, subset.rfl, rfl⟩
simp [le_inf_iff, inter_subset_left, inter_subset_right]
simp only [union_subset_iff, mem_sup, mem_principal]
simp only [mem_supr, mem_principal, Union_subset_iff]
rw [inf_principal, inter_compl_self, principal_empty]
rw [sup_principal, union_compl_self, principal_univ]
simp only [mem_inf_principal', imp_iff_not_or]
rfl
rw [← empty_mem_iff_bot, mem_inf_principal]
rfl
simp [h]
simp [h]
simp [h]
simp only [or_comm' _ q, eventually_or_distrib_left]
simp only [imp_iff_not_or, eventually_or_distrib_left]
refine' mt (fun h => hq.mp <| h.mono _) hp
exact fun x hpq hq hp => hpq ⟨hp, hq⟩
simp only [frequently_iff_forall_eventually_exists_and, exists_prop, and_comm' (P _)]
rfl
simp [Filter.Frequently]
simp only [Filter.Frequently, not_not]
simp [Filter.Frequently, -not_eventually, eventually_false_iff_eq_bot, ne_bot_iff]
simp
simp [h]
simp only [Filter.Frequently, ← not_and_or, not_or, eventually_and]
simp
simp
simp [imp_iff_not_or, not_eventually, frequently_or_distrib]
simp
simp
simp only [imp_iff_not_or, eventually_or_distrib_right, not_frequently]
simp only [Filter.Frequently, not_and, eventually_imp_distrib_left, not_imp]
simp only [and_comm' _ q, frequently_and_distrib_left]
simp
simp [Filter.Frequently]
simp [Filter.Frequently, not_forall]
simp only [Filter.Frequently, eventually_sup, not_and_or]
simp [Filter.Frequently, -not_eventually, not_forall]
simp [Filter.Frequently, -not_eventually, not_forall]
simp [eventually_eq_set]
intros
simp only [*]
simp
simp only [eventually_eq_set, mem_inter_iff, and_iff_left_iff_imp]
rw [inter_comm, inter_eventually_eq_left]
simp only [eventually_eq, eventually_le, le_antisymm_iff, eventually_and]
rw [← image_univ]
exact image_mem_map univ_mem
simp only [eventually_map]
exact eventually_congr (h.mono fun x hx => hx ▸ Iff.rfl)
simp only [subset_univ, preimage_univ]
simp only [Filter.Frequently, eventually_comap, not_exists, not_and]
simp only [mem_comap', compl_def, mem_image, mem_set_of_eq, not_exists, not_and', not_not]
rw [mem_comap_iff_compl, compl_compl]
simp only [forall_prop_of_true, mem_univ, forall_true_iff]
simp only [mem_pure, mem_principal, singleton_subset_iff]
simp only [Bind.bind, bind, map_pure, join_pure]
simp only [Bind.bind, bind, Functor.map, mem_map', mem_join, mem_set_of_eq, comp,
          mem_pure]
simp only [compl_mem_comap, image_image]
rw [Filter.map_map, H, ← Filter.map_map]
rw [Filter.comap_comap, H, ← Filter.comap_comap]
rw [← principal_singleton, comap_principal]
rw [← principal_univ, map_principal, image_univ]
rw [comap_top]
exact le_top
simp only [empty_subset, preimage_empty]
simp
simp only [disjoint_iff, ← comap_inf, h.eq_bot, comap_bot]
rw [preimage_Union, Union_subset_iff]
exact fun i => (ht i).2
simp only [Sup_eq_supr, comap_supr, eq_self_iff_true]
rw [sup_eq_supr, comap_supr, supr_bool_eq, Bool.cond_true, Bool.cond_false]
rw [map_comap, inf_eq_left.2 (le_principal_iff.2 hf)]
simp only [hf.range_eq, univ_mem]
rw [map_comap, Subtype.range_coe]
rw [← map_comap_of_mem h]
exact image_mem_map W_in
simp [h]
simp only [preimage_image_eq s h]
rw [← image_mem_map_iff inj, map_comap_of_mem large]
rw [map_le_iff_le_comap, comap_map hm]
simp only [le_antisymm_iff, map_le_map_iff_of_inj_on hsf hsg hm,
    map_le_map_iff_of_inj_on hsg hsf hm]
simp [comap_ne_bot_iff, frequently_iff, ← exists_and_left, and_comm]
rw [comap_eq_bot_iff_compl_range, hm.range_eq, compl_univ, empty_mem_iff_bot]
rw [disjoint_iff, disjoint_iff, ← comap_inf, comap_surjective_eq_bot h]
simp [comap_eval_ne_bot_iff', *]
rw [← empty_mem_iff_bot, ← empty_mem_iff_bot]
exact id
simp only [h, map_bot]
simp only [ne_bot_iff, Ne, map_eq_bot_iff]
simp only [mem_sInter, mem_Inter, Filter.mem_sets, mem_comap, this, and_imp, exists_prop,
      mem_preimage, exists_imp]
simp only [le_principal_iff, mem_map]
assumption
simp only [disjoint_iff, ← map_inf hm, map_eq_bot_iff]
rw [map_map, e.self_comp_symm, map_id, map_comap_of_surjective e.surjective]
rw [image_inter_preimage]
rw [h]
simp only [Filter.push_pull, inf_comm]
simp
rw [principal_eq_map_coe_top s, ← Filter.push_pull', inf_top_eq, map_eq_bot_iff]
rw [← principal_singleton, le_principal_iff]
simp only [mem_seq_def, seq_subset, exists_prop, iff_self_iff]
simp only [mem_bind, mem_inf_principal]
simp only [bind, sup_join, map_sup, eq_self_iff_true]
simp only [Sup_image, join_principal_eq_Sup, map_principal, eq_self_iff_true]
simp [tendsto]
rw [← @map_id _ g, ← map_congr h₁, ← map_map]
exact map_mono h₂
simp only [filter_eq_bot_of_is_empty la, tendsto_bot]
rw [tendsto, tendsto, map_congr hl]
rw [tendsto, map_map]
rfl
rw [tendsto, ← map_compose]
simp only [(· ∘ ·), map_comap_of_mem h, tendsto]
refine' ((comap_mono <| map_le_iff_le_comap.1 hψ).trans _).antisymm (map_le_iff_le_comap.1 hφ)
rw [comap_comap, Eq, comap_id]
exact le_rfl
refine' le_antisymm hφ (le_trans _ (map_mono hψ))
rw [map_map, Eq, map_id]
exact le_rfl
simp only [tendsto, le_inf_iff, iff_self_iff]
simp only [tendsto, iff_self_iff, le_infi_iff]
simp only [tendsto, map_sup, sup_le_iff]
simp only [tendsto, map_supr, supr_le_iff]
simp only [tendsto, le_principal_iff, mem_map', Filter.Eventually]
simp only [tendsto_principal, eventually_principal]
simp only [tendsto, le_pure_iff, mem_map', mem_singleton_iff, Filter.Eventually]
simp only [mem_map', mem_inf_principal, mem_set_of_eq, mem_preimage]
erw [h.filter_basis.generate] <;> rfl
simp only [mem_generate_iff, exists_prop, and_assoc, and_left_comm]
rw [sInter_union]
simp only [h.mem_filter_iff, exists_prop]
rw [← h.is_basis.filter_eq_generate, h.filter_eq]
erw [(filter_basis.of_sets s).generate, ← (has_basis_generate s).filter_eq] <;> rfl
rw [← (filter_basis.of_sets s).generate, generate_eq_generate_inter s] <;> rfl
simp [Filter.Frequently, hl.eventually_iff]
simp only [not_exists, not_and, nonempty_iff_ne_empty]
simp only [← and_imp, and_comm']
simp only [has_basis_iff, exists_prop, id, and_assoc']
exact
    forall_congr' fun s =>
      ⟨fun h => h.1, fun h => ⟨h, fun ⟨t, hl, hP, hts⟩ => mem_of_superset hl hts⟩⟩
simp only [le_def, hl.mem_iff]
simp only [hl'.ge_iff, hl.mem_iff]
refine' ⟨fun t => _⟩
rw [mem_infi_of_directed h, Sigma.exists]
exact exists_congr fun i => (hl i).mem_iff
refine' ⟨fun t => _⟩
rw [mem_infi_of_directed h, Prod.exists]
exact exists_congr fun i => (hl i).mem_iff
simp
simp only [← principal_singleton, has_basis_principal]
intro t
simp only [mem_sup, hl.mem_iff, hl'.mem_iff, PProd.exists, union_subset_iff, exists_prop,
      and_assoc', exists_and_left]
simp only [← and_assoc', exists_and_right, and_comm']
simp only [has_basis_iff, (hl _).mem_iff, Classical.skolem, forall_and, Union_subset_iff,
      mem_supr]
simp only [(hl.sup' (has_basis_principal t)).mem_iff, PProd.exists, exists_prop, and_true_iff,
      Unique.exists_iff]
simp only [← principal_singleton, hl.sup_principal]
simp only [mem_inf_principal, hl.mem_iff, subset_def, mem_set_of_eq, mem_inter_iff, and_imp]
simp [@forall_swap _ ι']
simp only [disjoint_iff, ← Ne.def, ← ne_bot_iff, hl.inf_basis_ne_bot_iff hl', not_exists,
      bot_eq_empty, ← nonempty_iff_ne_empty, inf_eq_inter]
rw [mem_iff_inf_principal_compl, compl_compl, disjoint_iff]
rw [Disjoint.comm, disjoint_principal_right]
simp [← subset_compl_iff_disjoint_left]
simp only [← principal_singleton, disjoint_principal_principal, disjoint_singleton]
simp only [mem_prod_iff, Filter.disjoint_iff, prod_subset_compl_diagonal_iff_disjoint]
simp only [h.disjoint_iff l'.basis_sets, exists_prop, id, ← disjoint_principal_left,
    (has_basis_principal _).disjoint_iff l'.basis_sets, Unique.exists_iff]
rw [inf_comm]
exact inf_ne_bot_iff_frequently_left
simp only [h.mem_iff, mem_principal]
simp only [exists_prop, true_and_iff, mem_principal]
refine' ⟨fun U => (mem_infi_finite _).trans _⟩
simp only [infi_principal_finset, mem_Union, mem_principal, exists_prop, exists_finite_iff_finset,
    Finset.set_bInter_coe]
simp only [mem_principal]
simp only [mem_map, image_subset_iff, hl.mem_iff, preimage]
simp only [h.mem_iff, exists_imp]
exact ⟨fun h i hi => h (s i) i hi subset.rfl, fun h t i hi ht => ht (h i hi)⟩
rw [sInter_eq_bInter]
exact h.bInter_mem monotone_id
simp only [tendsto, (hla.map f).le_iff, image_subset_iff]
rfl
simp [hlb.tendsto_right_iff, hla.eventually_iff]
simp only [exists_prop, true_and_iff]
refine' antitone_nat_of_succ_le fun i => _
exact (hs.set_index_subset _).trans (inter_subset_right _ _)
cases i <;> apply hs.set_index_mem
simp [hx.to_has_basis.mem_iff]
let ⟨x, h⟩ := h
rw [h] <;> apply is_countably_generated_seq
rw [← principal_singleton]
exact is_countably_generated_principal _
rw [← principal_univ, mem_prod_principal]
simp only [mem_univ, forall_true_left]
rw [eventually_iff, eventually_iff, mem_prod_principal]
simp only [mem_set_of_eq]
erw [comap_inf, Filter.comap_comap, Filter.comap_comap]
rw [Filter.prod, comap_top, inf_top_eq]
rw [Filter.prod, comap_sup, inf_sup_right, ← Filter.prod, ← Filter.prod]
rw [Filter.prod, comap_sup, inf_sup_left, ← Filter.prod, ← Filter.prod]
simp only [hst hx.1 hx.2, Prod.mk.eta]
simp only [hst hx.1 hx.2, Prod.mk.eta]
rw [Filter.prod, comap_infi, infi_inf]
simp only [Filter.prod, eq_self_iff_true]
rw [Filter.prod, comap_infi, inf_infi]
simp only [Filter.prod, eq_self_iff_true]
simp only [Filter.prod, comap_comap, eq_self_iff_true, comap_inf]
simp only [Filter.prod, comap_comap, (· ∘ ·), inf_comm, Prod.fst_swap, eq_self_iff_true,
    Prod.snd_swap, comap_inf]
rw [prod_comm', ← map_swap_eq_comap_swap]
rfl
rw [prod_comm, map_map, (· ∘ ·), map_fst_prod]
erw [tendsto, ← prod_map_map_eq]
exact Filter.prod_mono hf hg
simp [Filter.ext_iff, mem_prod_iff, mem_map_seq_iff]
intro s
constructor
exact fun ⟨t, ht, s, hs, h⟩ => ⟨s, hs, t, ht, fun x hx y hy => @h ⟨x, y⟩ ⟨hx, hy⟩⟩
exact fun ⟨s, hs, t, ht, h⟩ => ⟨t, ht, s, hs, fun ⟨x, y⟩ ⟨hx, hy⟩ => h x hx y hy⟩
simp only [Filter.prod, comap_inf, inf_comm, inf_assoc, inf_left_comm]
simp [Filter.prod]
simp [Filter.prod]
simp only [Filter.prod, comap_principal, principal_eq_iff_eq, comap_principal, inf_principal] <;>
    rfl
rw [prod_eq, map_pure, pure_seq_eq_map]
rw [Filter.pure_prod]
rfl
rw [prod_eq, seq_pure, map_map]
simp
simp only [ne_bot_iff, Ne, prod_eq_bot, not_or]
simp only [tendsto_def, mem_prod_iff, prod_sub_preimage_iff, exists_prop, iff_self_iff]
unfold Filter.prod
simp only [tendsto_inf, tendsto_comap_iff, iff_self_iff]
simp [Filter.coprod]
simp [Filter.coprod]
simp [Filter.coprod]
simp
simp only [Filter.coprod, mem_sup, compl_mem_comap]
simp [Filter.coprod]
rw [Filter.coprod, comap_principal, comap_principal, sup_principal, Set.prod_eq, compl_inter,
    preimage_compl, preimage_compl, compl_compl, compl_compl]
simp only [map_principal, Filter.coprod, comap_principal, sup_principal, image_singleton,
    image_id, prod_univ, univ_prod]
simp [Filter.lift]
refine' ⟨fun t => (hf.mem_lift_iff hg gm).trans _⟩
simp [Sigma.exists, and_assoc', exists_and_left]
simp only [id, exists_mem_subset_iff]
simp only [sInter_eq_bInter, mem_set_of_eq, Filter.mem_sets, mem_lift_sets hg, Inter_exists,
    @Inter_comm _ (Set β)]
simp only [Filter.lift, tendsto_infi]
simp only [mem_lift_sets hg, mem_lift_sets this, exists_prop, mem_map, Function.comp_apply]
simp only [Filter.lift, comap_infi]
simp only [ne_bot_iff, Ne.def, ← empty_mem_iff_bot, mem_lift_sets hm, not_exists]
simp only [Filter.lift, infi_inf_eq]
simp only [hs, le_principal_iff]
simp only [mem_lift_sets hg, exists_imp, mem_infi_of_directed hf]
exact fun t i ht hs => mem_infi_of_mem i <| mem_lift ht hs
cases isEmpty_or_nonempty ι
· simp [infi_of_empty, hg']
· exact lift_infi hg
simp only [Filter.lift', tendsto_lift, tendsto_principal]
refine' ⟨fun t => (hf.mem_lift_iff _ (monotone_principal.comp hh)).trans _⟩
show ∀ i, (𝓟 (h (s i))).HasBasis (fun j : Unit => True) fun j : Unit => h (s i)
exact fun i => has_basis_principal _
simp only [exists_const]
simp only [(· ∘ ·), Filter.lift', map_principal, eq_self_iff_true]
simp only [Filter.lift', comap_lift_eq, (· ∘ ·), comap_principal]
rw [← principal_singleton, lift'_principal hh]
rw [← principal_empty, lift'_principal hh]
simp only [lift_principal, hh, eq_self_iff_true]
simp only [Filter.lift', Filter.lift, (· ∘ ·), ← inf_principal, infi_subtype', ← infi_inf]
simp only [principal_ne_bot_iff]
rw [inf_principal, (· ∘ ·), ← hg]
rw [inf_principal, (· ∘ ·), ← hg]
rw [Function.comp_apply, hg', principal_univ]
simp only [principal_eq_iff_eq, comap_principal, inf_principal] <;> intros <;> rfl
rw [prod_same_eq, mem_lift'_sets]
exact monotone_id.set_prod monotone_id
simp only [tendsto_def, mem_prod_same_iff, prod_sub_preimage_iff, exists_prop, iff_self_iff]
simp only [prod_def, lift_assoc hg₁]
apply congr_arg
funext x
rw [lift_comm]
apply congr_arg
funext y
apply lift'_lift_assoc hg₂
simp only [prod_principal_principal]
infer_instance
congr
rw [← inf_ne_bot_iff, ne_bot_iff, Ne.def, not_not, disjoint_iff]
rw [← compl_not_mem_iff, compl_compl]
simp only [← disjoint_iff_not_le, not_or, disjoint_sup_right]
simp only [← mem_coe, ← le_principal_iff, ← sup_principal, le_sup_iff]
simp only [imp_iff_not_or, eventually_or, eventually_not]
simp
simp [union_mem_iff, his, or_and_right, exists_or]
simp only [← sUnion_image, finite_sUnion_mem_iff (his.image s), bex_image_iff]
skip
simp only [← u.unique (map_le_iff_le_comap.2 hgu), comap_map inj, le_rfl]
rw [range_id]
exact univ_mem
rw [range_comp]
exact image_mem_of_mem_comap large₀ large₁
simp
rw [coe_pure, ← principal_singleton, ← image_singleton, preimage_image_eq _ inj]
simp only [mem_bind', mem_coe, ← compl_mem_iff_not_mem, compl_set_of, compl_compl]
simp only [supr_le_iff, ← le_iff_ultrafilter]
refine' ⟨fun H f hf => H f f.ne_bot hf, _⟩
intro H f hf hfg
exact hp (of_le f) (H _ ((of_le f).trans hfg))
infer_instance
let f := Filter.comap m g
let f := Filter.comap m g
rw [map_principal]
rw [Filter.map_one', map_one, pure_one]
rw [inv_involutive.comp_self, map_id]
simp only [← pure_one, ← map₂_mul, map₂_pure_left, one_mul, map_id']
simp only [← pure_one, ← map₂_mul, map₂_pure_right, mul_one, map_id']
rw [pow_zero]
exact one_mem_one
rw [pow_succ]
exact mul_mem_mul hs (pow_mem_pow _)
rw [← tsub_add_cancel_of_le (Nat.succ_le_of_lt <| Nat.pos_of_ne_zero hn), pow_succ, bot_mul]
rw [succ_nsmul, nsmul_top n.succ_ne_zero, top_add_top]
rw [pow_succ, top_pow n.succ_ne_zero, top_mul_top]
simp only [is_unit_iff, Group.isUnit, and_true_iff]
simp only [← map_smul, map_map, smul_assoc]
refine' (map_map₂_distrib_left fun _ _ => _).symm
exact (smul_assoc a _ _).symm
simp only [← map_smul, map_map, Function.comp, ← mul_smul]
simp only [← map_smul, one_smul, map_id']
rw [smul_zero, pure_zero]
rw [smul_one, singleton_one]
rw [zero_at_filter, ← Asymptotics.is_o_const_iff (one_ne_zero' ℝ)] at hf
exact hf.is_O
simp
simp [Rel.core_inter, inter_mem hs ht]
simp [rmap_sets, Set.preimage, Rel.core_comp]
rw [rtendsto_def]
change (∀ s : Set β, s ∈ l₂.sets → r.core s ∈ l₁) ↔ l₁ ≤ rcomap r l₂
simp [Filter.le_def, rcomap, Rel.mem_image]
constructor
· exact fun h s t tl₂ => mem_of_superset (h t tl₂)
· exact fun h t tl₂ => h _ t tl₂ Set.Subset.rfl
unfold rtendsto' rcomap'
simp [le_def, Rel.mem_image]
constructor
· exact fun h s hs => h _ _ hs Set.Subset.rfl
· exact fun h s t ht => mem_of_superset (h t ht)
simp [tendsto_def, Function.graph, rtendsto_def, Rel.core, Set.preimage]
simp [tendsto_def, Function.graph, rtendsto'_def, Rel.preimage_def, Set.preimage]
simp only [tendsto, ptendsto, pmap_res]
rw [← tendsto_iff_ptendsto]
simp [principal_univ]
rw [ptendsto_def, ptendsto'_def]
exact fun h s sl₂ => mem_of_superset (h s sl₂) (Pfun.preimage_subset_core _ _)
rw [ptendsto_def, ptendsto'_def]
intro h' s sl₂
rw [Pfun.preimage_eq]
exact inter_mem (h' s sl₂) h
rw [← principal_empty]
apply countable_Inter_filter_principal
rw [← principal_univ]
apply countable_Inter_filter_principal
constructor
intro S hSc hS
simp only [mem_map, sInter_eq_bInter, preimage_Inter₂] at hS⊢
exact (countable_bInter_mem hSc).2 hS
rw [← SetLike.mem_coe, coe_pure, mem_singleton_iff]
cases s
· rfl
· exact WithBot.map_comm rfl _
cases s
· rfl
exact s.coe_dual
simp
rw [← SetLike.mem_coe, coe_pure, mem_singleton_iff]
rw [← Interval.coe_inj, coe_pure_interval]
simp [infi]
rw [inf_comm]
rw [sup_comm] at hxz hyz
exact is_maximal_inf_left_of_is_maximal_sup hyz hxz
rw [to_list, List.length_of_fn]
rw [← List.length_pos_iff_ne_nil, length_to_list] <;> exact Nat.succ_pos _
intro i
rw [← List.nth_le_of_fn s₁ i, ← List.nth_le_of_fn s₂]
simp [h]
intro i hi
simp only [to_list, List.nth_le_of_fn']
rw [length_to_list] at hi
exact s.step ⟨i, hi⟩
dsimp [to_list]
rw [List.nth_le_of_fn', List.nth_le_of_fn']
exact s.strict_mono hij
rw [to_list, List.mem_of_fn, mem_def]
refine' List.ext_le _ _
·
    rw [length_to_list, length_of_list,
      tsub_add_cancel_of_le (Nat.succ_le_of_lt <| List.length_pos_of_ne_nil hl)]
· intro i hi hi'
    dsimp [of_list, to_list]
    rw [List.nth_le_of_fn']
    rfl
simp [*]
have := s.step ⟨i, lt_of_lt_of_le i.2 tsub_le_self⟩
cases i
exact this
simp [erase_top, top, s.strict_mono.le_iff_le, Fin.le_iff_coe_le_coe, tsub_le_self]
cases i
simp [Fin.append, *]
simp [this]
simp [Fin.ext_iff, this]
simp [Fin.ext_iff, this]
cases i
simp only [Fin.append, Nat.not_lt_zero, Fin.nat_add_mk, add_lt_iff_neg_left, add_tsub_cancel_left,
    dif_neg, Fin.cast_succ_mk, not_false_iff, Fin.coe_mk]
refine' Fin.addCases _ _ i
· intro i
      rw [append_succ_cast_add_aux _ h, append_cast_add_aux]
      exact s₁.step i
· intro i
      rw [append_nat_add_aux, append_succ_nat_add_aux]
      exact s₂.step i
rw [bot, bot, ← Fin.cast_succ_zero, snoc_cast_succ]
intro hs
refine' ne_of_gt (lt_of_is_maximal h) _
simp [top, Fin.ext_iff, hs]
simp [Fin.cast_succ_lt_last]
simp [Fin.cast_succ_lt_last]
intro i
dsimp only [e]
refine' Fin.lastCases _ (fun i => _) i
· erw [Equiv.swap_apply_left, snoc_cast_succ, snoc_last, Fin.succ_last, snoc_last,
        snoc_cast_succ, snoc_cast_succ, Fin.succ_cast_succ, snoc_cast_succ, Fin.succ_last,
        snoc_last]
      exact hr₂
· refine' Fin.lastCases _ (fun i => _) i
      · erw [Equiv.swap_apply_right, snoc_cast_succ, snoc_cast_succ, snoc_cast_succ,
          Fin.succ_cast_succ, snoc_cast_succ, Fin.succ_last, snoc_last, snoc_last, Fin.succ_last,
          snoc_last]
        exact hr₁
      · erw [Equiv.swap_apply_of_ne_of_ne h2 h1, snoc_cast_succ, snoc_cast_succ, snoc_cast_succ,
          snoc_cast_succ, Fin.succ_cast_succ, snoc_cast_succ, Fin.succ_cast_succ, snoc_cast_succ,
          snoc_cast_succ, snoc_cast_succ]
        exact (s.step i).iso_refl
simp [hs₁]
simp only [pos_iff_ne_zero, Ne.def, not_iff_not, not_not]
exact length_eq_zero_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero hb.symm ht.symm
simp [hn]
rw [inf_comm, htt]
simp [htb]
simp [htl]
simp
rw [inf_comm, htt]
simp [htb, ← hb]
simp [htt, (is_maximal_erase_top_top h0s₂).iso_refl]
simp [cSup_le_iff (s.finite_to_set.image f).BddAbove (hs.to_set.image f)]
rw [hs.sup'_eq_cSup_image, image_id]
rw [h.cSup_eq_max']
exact s.max'_mem _
rw [sup'_eq_cSup_image s H, Set.image_id]
rw [infi, range_eq_empty, WithTop.cInf_empty]
rw [infi, infi, WithTop.coe_Inf' (range_nonempty f), range_comp]
rw [supr, supr, WithTop.coe_Sup' h, range_comp]
intros <;> apply le_Sup <;> assumption
intros <;> apply Sup_le <;> assumption
intros <;> apply Inf_le <;> assumption
intros <;> apply le_Inf <;> assumption
simp only [hs, dif_pos]
exact has (h.wf.min_mem s hs)
have h's : (upperBounds s).Nonempty := hs
simp only [h's, dif_pos]
exact h.wf.min_mem _ h's has
rw [← Sup_image']
exact is_lub_cSup (Hne.image _) H
cases isEmpty_or_nonempty ι
· rw [supr_of_empty', supr_of_empty']
· exact csupr_le fun x => le_csupr_of_le B x (H x)
rw [supr, range_const, cSup_singleton]
have : ∀ i, s i = s default := fun i => congr_arg s (Unique.eq_default i)
simp only [this, csupr_const]
rw [Inf_eq_argmin_on hs]
exact ⟨argmin_on_mem _ _ _ _, fun a ha => argmin_on_le id _ _ ha⟩
rw [supr_of_empty', cSup_empty]
simp [supr, h, le_cSup_iff', upperBounds]
rw [coe_Sup' hb, Sup_image]
rw [coe_Inf' hs, Inf_image]
rw [gc.l_cSup hne hbdd, Sup_image']
rw [supr, gc.l_cSup (range_nonempty _) hf, supr_range']
rfl
simp only [unbounded, not_le]
simp only [unbounded, not_lt]
simp only [← bounded_le_iff_bounded_lt, bounded_le_Iic]
simp only [← bounded_ge_iff_bounded_gt, bounded_ge_Ici]
rw [← not_bounded_iff, ← not_bounded_iff, not_iff_not]
exact bounded_le_inter_not_le a
refine' ⟨_, bounded.mono (Set.inter_subset_left s _)⟩
rw [← @bounded_le_inter_lt _ s _ a]
exact bounded.mono fun x ⟨hx, hx'⟩ => ⟨hx, le_of_lt hx'⟩
rw [← not_bounded_iff, ← not_bounded_iff, not_iff_not]
exact bounded_le_inter_le a
rw [← not_bounded_iff, ← not_bounded_iff, not_iff_not]
exact bounded_lt_inter_not_lt a
rw [← bounded_le_iff_bounded_lt, ← bounded_le_iff_bounded_lt]
exact bounded_le_inter_lt a
rw [← not_bounded_iff, ← not_bounded_iff, not_iff_not]
exact bounded_lt_inter_lt a
rw [disjoint_iff_inf_le, disjoint_iff_inf_le, inf_assoc]
simp only [disjoint_iff, inf_sup_right, sup_eq_bot_iff]
simp only [disjoint_iff, inf_sup_left, sup_eq_bot_iff]
simp only [codisjoint_iff, sup_inf_right, inf_eq_top_iff]
simp only [codisjoint_iff, sup_inf_left, inf_eq_top_iff]
rw [← @inf_top_eq _ _ _ a, ← @bot_sup_eq _ _ _ c, ← hab.eq_bot, ← hbc.eq_top, sup_inf_right]
exact inf_le_inf_right _ le_sup_left
rw [h.symm.inf_eq_bot, sup_bot_eq]
rw [← le_bot_iff, ← h.le_sup_right_iff_inf_left_le, bot_sup_eq]
rw [disjoint_iff]
exact h.inf_left_eq_bot_iff
rw [inf_sup_right, ← inf_assoc, h.inf_eq_bot, bot_inf_eq, bot_sup_eq, inf_left_comm,
        h'.inf_eq_bot, inf_bot_eq]
rw [sup_inf_left, @sup_comm _ _ x, sup_assoc, h.sup_eq_top, sup_top_eq, top_inf_eq, sup_assoc,
        sup_left_comm, h'.sup_eq_top, sup_top_eq]
rw [sbtw_iff_btw_not_btw]
exact and_iff_right_of_imp (btw_total _ _ _).resolve_left
rw [comm, comm b, comm _ c, comm a]
exact assoc _ _ _
funext a b
dsimp [(· ≤ ·)] at A_lt_iff_le_not_le B_lt_iff_le_not_le h_le
simp [A_lt_iff_le_not_le, B_lt_iff_le_not_le, h_le]
cases A
cases B
injection h
congr
simp (config := { contextual := true }) [lt_iff_le_not_le, Pi.le_def]
simp (config := { contextual := true }) [update_le_iff]
simp [le_update_iff]
simp [update_le_iff]
simp [lt_iff_le_not_le]
simp [lt_iff_le_not_le]
simp [Pi.le_def]
rw [min_comm, min_def, ← ite_not]
simp only [not_le]
rw [max_comm, max_def, ← ite_not]
simp only [not_le]
cases n
· exact ((@Fin.elim0 fun _ => False) <| grade (Fin 0) a).elim
rw [h.eq_bot, Fin.bot_eq_zero]
exact isMin_bot
cases o₁ <;> cases o₂ <;> decide
rw [← swap_inj, swap_swap]
injection h
injection h
injection h
injection h
injection h
injection h
cases o₁ <;> try rfl <;> cases o₂ <;> rfl
decide
unfold cmp cmpUsing
rw [cmp_eq_eq_iff]
rw [← cmp_swap x', ← cmp_swap x, swap_inj]
rw [← cmp_eq_lt_iff, ← cmp_eq_lt_iff, h]
rw [le_antisymm_iff, le_antisymm_iff, le_iff_le_of_cmp_eq_cmp h,
    le_iff_le_of_cmp_eq_cmp (cmp_eq_cmp_symm.1 h)]
simp [IsUpperSet, subset_def, @forall_swap (_ ∈ s)]
simp [IsLowerSet, subset_def, @forall_swap (_ ∈ s)]
simp [le_iff_eq_or_lt, or_imp, forall_and]
simp [le_iff_eq_or_lt, or_imp, forall_and]
simp [is_upper_set_iff_forall_lt, subset_def, @forall_swap (_ ∈ s)]
simp [is_lower_set_iff_forall_lt, subset_def, @forall_swap (_ ∈ s)]
cases s
cases t
congr
cases s
cases t
congr
simp [SetLike.ext'_iff]
simp [SetLike.ext'_iff]
simp [supr]
simp [infi]
rw [← SetLike.mem_coe, coe_supr]
exact mem_Inter
rw [← SetLike.mem_coe, coe_infi]
exact mem_Union
simp [disjoint_iff, codisjoint_iff, SetLike.ext'_iff]
simp [SetLike.ext'_iff]
simp [SetLike.ext'_iff]
rw [← SetLike.mem_coe, coe_supr]
exact mem_Union
rw [← SetLike.mem_coe, coe_infi]
exact mem_Inter
simp [disjoint_iff, SetLike.ext'_iff]
simp only [coe_compl, coe_Sup, compl_Inter₂, LowerSet.coe_supr₂]
simp only [coe_compl, coe_Inf, compl_Union₂, LowerSet.coe_infi₂]
simp only [coe_compl, coe_supr, compl_Inter, LowerSet.coe_supr]
simp only [coe_compl, coe_infi, compl_Union, LowerSet.coe_infi]
simp only [coe_compl, coe_Sup, compl_Union₂, UpperSet.coe_supr₂]
simp only [coe_compl, coe_Inf, compl_Inter₂, UpperSet.coe_infi₂]
simp only [coe_compl, coe_supr, compl_Union, UpperSet.coe_supr]
simp only [coe_compl, coe_infi, compl_Inter, UpperSet.coe_infi]
rw [← f.symm_symm, ← symm_map, f.symm_symm]
rfl
rw [← f.symm_symm, ← symm_map, f.symm_symm]
rfl
simp only [mem_Ici_iff, mem_supr_iff, Sup_le_iff]
simp only [mem_Ici_iff, mem_supr_iff, supr_le_iff]
simp only [mem_Iic_iff, mem_infi₂_iff, le_Inf_iff]
simp only [mem_Iic_iff, mem_infi_iff, le_infi_iff]
refine' ⟨Set.OrdConnected.upper_closure_inter_lower_closure, fun h => _⟩
rw [← h]
exact (UpperSet.upper _).OrdConnected.inter (LowerSet.lower _).OrdConnected
simp
simp
intro x y h a
simp only [and_imp, exists_prop, Part.bind_eq_bind, Part.mem_bind_iff, exists_imp]
intro b hb ha
refine' ⟨b, f.monotone h _ hb, g.monotone h _ _ ha⟩
simp [mem_map_iff] <;> intros <;> exists i <;> apply h
rw [h'] <;> apply ωSup_le <;> intro <;> apply f.monotone (hx i)
rw [h'] <;> apply le_ωSup (c.map f)
simp only [not_forall] at this⊢ <;> assumption
intro <;> rw [c.map_id] <;> rfl
dsimp [continuous] at *
intro
rw [hfc, hgc, chain.map_comp]
simp [ωSup_le_iff]
intro x hx
rw [← eq_some_iff] at hx⊢
rw [ωSup_eq_some, ← hx]
rw [← hx]
exact ⟨i, rfl⟩
simp only [supr_le_iff, OrderHom.coe_fun_mk] at hs⊢ <;> intro i <;> apply hs i
simp only [OrderHom.coe_fun_mk] <;> apply le_supr_of_le i <;> rfl
intro c
apply eq_of_forall_ge_iff
intro z
simp only [ωSup_le_iff, forall_const, chain.map_coe, (· ∘ ·), Function.const,
    OrderHom.has_top_top, OrderHom.const_coe_coe]
rw [← Sup_empty]
exact Sup_continuous _ fun f hf => hf.elim
refine' fun c => eq_of_forall_ge_iff fun z => _
simp only [inf_le_iff, hf c, hg c, ωSup_le_iff, ← forall_or_left, ← forall_or_right,
    Function.comp_apply, chain.map_coe, OrderHom.has_inf_inf_coe]
exact
    ⟨fun h _ => h _ _, fun h i j =>
      (h (max i j)).imp (le_trans <| f.mono <| c.mono <| le_max_left _ _)
        (le_trans <| g.mono <| c.mono <| le_max_right _ _)⟩
intro c <;> rw [ωSup_bind, ← hf', ← hg'] <;> rfl
simp only [map_eq_bind_pure_comp] <;> apply bind_continuous' _ _ hg <;> apply const_continuous'
simp only [seq_eq_bind_map] <;> apply bind_continuous' _ _ hf <;>
        apply Pi.omegaCompletePartialOrder.flip₂_continuous' <;>
      intro <;>
    apply map_continuous' _ _ hg
rw [forall_swap, forall_forall_merge]
intro c'
apply eq_of_forall_ge_iff
intro z
simp only [ωSup_le_iff, (c _).Continuous, chain.map_coe, OrderHom.apply_coe, to_mono_coe,
        coe_apply, order_hom.omega_complete_partial_order_ωSup_coe, forall_forall_merge,
        forall_forall_merge', (· ∘ ·), Function.eval]
intro c
apply le_antisymm
· apply ωSup_le
      intro i
      dsimp
      rw [(c _).fst.Continuous]
      apply ωSup_le
      intro j
      apply le_ωSup_of_le (max i j)
      apply apply_mono
      exact monotone_fst (OrderHom.mono _ (le_max_left _ _))
      exact monotone_snd (OrderHom.mono _ (le_max_right _ _))
· apply ωSup_le
      intro i
      apply le_ωSup_of_le i
      dsimp
      apply OrderHom.mono _
      apply le_ωSup_of_le i
      rfl
simp [prod.apply_apply, Prod.ωSup_zip]
rw [OrderHom.bind, ← OrderHom.bind, ωSup_bind, ← f.continuous, ← g.continuous]
rfl
rw [sup_comm, sup_inf_sdiff]
rw [inf_comm, inf_inf_sdiff]
rw [← inf_inf_sdiff a a, inf_assoc]
exact inf_le_left
rw [sup_inf_self]
ac_rfl
rw [sup_inf_sdiff]
rw [inf_inf_sdiff]
rw [sup_inf_sdiff]
rw [inf_sup_left]
ac_rfl
rw [inf_idem]
rw [inf_sup_right, @inf_comm _ _ x y]
rw [inf_inf_sdiff, bot_sup_eq]
ac_rfl
rw [inf_of_le_right sdiff_le']
rw [sup_inf_sdiff]
rw [inf_sup_right]
rw [@inf_comm _ _ x y, inf_inf_sdiff, sdiff_inf_sdiff, bot_sup_eq]
rw [inf_comm, inf_sdiff_self_right]
rw [inf_eq_right.2 h, inf_sdiff_self_right, bot_sup_eq]
rw [← sup_assoc, ← @sdiff_sup_self' _ x y]
ac_rfl
rw [sup_assoc, sup_comm, sup_assoc, sup_idem]
rw [h, hs]
rw [h, hi.eq_bot]
rw [inf_assoc, hd.eq_bot, inf_bot_eq]
rw [sup_sdiff_cancel_right hx]
refine' le_trans (sup_le_sup_left sdiff_le z) _
rw [sup_eq_right.2 hz]
rw [← disjoint_iff]
exact disjoint_sdiff_iff_le hz hx
rw [sup_inf_left]
rw [@inf_sup_left _ _ y]
ac_rfl
rw [sup_inf_sdiff, sup_inf_sdiff]
ac_rfl
rw [sup_inf_self, sup_inf_self, inf_idem]
rw [inf_sup_left]
rw [inf_sup_right]
ac_rfl
rw [inf_inf_sdiff, h, inf_inf_sdiff]
rw [sup_inf_sdiff, h, sup_inf_sdiff]
rw [← sdiff_inf_self_right, ← sdiff_inf_self_right z y, inf_comm, h, inf_comm]
rw [sdiff_bot]
rw [inf_bot_eq, inf_comm, disjoint_iff]
rw [sdiff_eq_self_iff_disjoint, Disjoint.comm]
refine' sdiff_le.lt_of_ne fun h => hy _
rw [sdiff_eq_self_iff_disjoint', disjoint_iff] at h
rw [← h, inf_eq_right.mpr hx]
rw [inf_assoc]
rw [sup_inf_right, sup_inf_sdiff]
rw [inf_sup_right, inf_sdiff_left]
rw [sup_inf_right]
ac_rfl
rw [sup_inf_self, sup_sdiff_left, ← sup_assoc]
rw [sup_inf_left, sdiff_sup_self', inf_sup_right, @sup_comm _ _ y]
rw [inf_sdiff_sup_right, @inf_sup_left _ _ x z y]
ac_rfl
rw [sup_inf_self, sup_comm, inf_sup_self]
rw [inf_sup_left]
ac_rfl
rw [inf_sdiff_self_left, bot_inf_eq, inf_bot_eq, bot_sup_eq]
ac_rfl
rw [inf_sdiff_self_right, inf_bot_eq, inf_bot_eq]
ac_rfl
rw [sup_inf_inf_sdiff, sup_comm, inf_comm]
rw [sdiff_sdiff_right', inf_eq_right.2 h]
rw [sdiff_sdiff_right, inf_idem, sdiff_self, bot_sup_eq]
rw [sdiff_sdiff_right_self, inf_of_le_right h]
rw [← h, sdiff_sdiff_eq_self hy]
rw [← sdiff_sdiff_eq_self hxz, h, sdiff_sdiff_eq_self hyz]
rw [sdiff_sdiff_left, sdiff_sup]
rw [sdiff_sup, sdiff_sdiff_right, sdiff_sdiff_right]
rw [sup_inf_left, sup_comm, sup_inf_sdiff]
ac_rfl
rw [inf_idem]
rw [sdiff_sdiff_right, sdiff_sdiff_right]
ac_rfl
ac_rfl
rw [sup_inf_left]
rw [sup_inf_right, sup_sdiff_self_right, inf_sup_right, inf_sdiff_sup_right]
ac_rfl
rw [inf_sup_self, sup_inf_inf_sdiff]
rw [@inf_comm _ _ y, sup_inf_left]
ac_rfl
rw [inf_sdiff_self_right, inf_bot_eq, bot_inf_eq]
rw [inf_assoc]
rw [sup_inf_sdiff]
ac_rfl
rw [inf_inf_sdiff, inf_bot_eq]
rw [@inf_comm _ _ x, inf_comm, inf_sdiff_assoc]
rw [sdiff_inf, sdiff_eq_bot_iff.2 inf_le_left, bot_sup_eq, inf_sdiff_assoc]
rw [sup_inf_left]
ac_rfl
rw [sup_sdiff_right, sup_sdiff_right]
rw [sup_sdiff_self_right, sup_sdiff_self_left, inf_idem]
rw [← sup_sdiff_cancel_right hxz]
refine' (sup_le_sup_left h.le _).lt_of_not_le fun h' => h.not_le _
rw [← sdiff_idem]
exact (sdiff_le_sdiff_of_sup_le_sup_left h').trans sdiff_le
rw [← sdiff_sup_cancel hyz]
refine' (sup_le_sup_right h.le _).lt_of_not_le fun h' => h.not_le _
rw [← sdiff_idem]
exact (sdiff_le_sdiff_of_sup_le_sup_right h').trans sdiff_le
rw [← inf_sdiff_assoc, inf_top_eq]
rfl
rw [sdiff_eq, ← inf_sup_left, sup_compl_eq_top, inf_top_eq]
rw [sdiff_eq, ← inf_inf_distrib_left, inf_compl_eq_bot', inf_bot_eq]
congr
rw [himp_eq, is_compl_compl.le_sup_right_iff_inf_left_le]
rw [sdiff_eq, top_inf_eq]
rw [h]
exact is_compl_compl.symm
rw [← h]
exact is_compl_compl
rw [eq_comm, compl_eq_iff_is_compl, eq_compl_iff_is_compl]
rw [eq_comm, compl_eq_iff_is_compl, eq_compl_iff_is_compl]
have h := compl_le_compl h <;> simp at h <;> assumption
rw [sdiff_eq, compl_compl]
rw [← sdiff_eq, sup_inf_sdiff _ _]
rw [sdiff_eq, himp_eq, compl_inf, compl_compl, sup_comm]
rw [sdiff_compl, sdiff_eq, inf_comm]
rw [← le_compl_iff_disjoint_left, compl_compl]
rw [← le_compl_iff_disjoint_right, compl_compl]
decide
erw [map_sup, map_sdiff, map_inf, sup_inf_sdiff]
erw [map_inf, map_sdiff, map_inf, inf_inf_sdiff, map_bot]
rw [map_compl, inf_compl_eq_bot, map_bot]
rw [map_compl, sup_compl_eq_top, map_top]
rw [← c.closure_fst, ← d.closure_fst, ← intent_closure_union,
          intent_closure_extent_closure_intent_closure]
rw [← c.closure_snd, ← d.closure_snd, ← extent_closure_union,
          extent_closure_intent_closure_extent_closure]
refine' ⟨fun h => _, fun h => _⟩
· rw [← fst_subset_fst_iff, ← c.closure_snd, ← d.closure_snd]
    exact extent_closure_anti _ h
· rw [← c.closure_fst, ← d.closure_fst]
    exact intent_closure_anti _ h
rw [ssubset_iff_subset_not_subset, lt_iff_le_not_le, snd_subset_snd_iff, snd_subset_snd_iff]
rw [← sup_assoc, sup_idem]
rw [sup_comm, sup_assoc, sup_idem]
simp [le_rfl]
simp [le_rfl]
apply le_antisymm <;> simp
apply le_antisymm <;> simp
simp only [sup_le_iff, and_assoc']
rw [sup_comm, @sup_comm _ _ a, sup_assoc]
rw [← sup_assoc, sup_idem]
rw [sup_assoc, sup_idem]
rw [← sup_assoc, ← sup_assoc, @sup_comm α _ a]
rw [sup_assoc, sup_assoc, @sup_comm _ _ b]
rw [sup_assoc, sup_left_comm b, ← sup_assoc]
rw [sup_sup_sup_comm, sup_idem]
rw [sup_sup_sup_comm, sup_idem]
simp only [sup_le_iff] <;> rw [← H, @sup_le_iff α A, H, H]
have := PartialOrder.ext H
have ss := funext fun x => funext <| SemilatticeSup.ext_sup H x
cases A
cases B
injection this <;> congr
simp [le_rfl]
simp [le_rfl]
simp only [le_inf_iff] <;> rw [← H, @le_inf_iff α A, H, H]
have := PartialOrder.ext H
have ss := funext fun x => funext <| SemilatticeInf.ext_inf H x
cases A
cases B
injection this <;> congr
rw [← h, inf_comm, inf_sup_self]
rw [← h, sup_comm, sup_inf_self]
rw [inf_sup_self]
rw [sup_inf_self]
rw [sup_inf_self]
rw [inf_sup_self]
rw [partial_order_eq]
apply inf_le_left
rw [partial_order_eq]
apply inf_le_right
rw [partial_order_eq]
apply le_inf
simp
simp
rw [sup_eq_right, ← inf_eq_left]
have SS : @Lattice.toSemilatticeSup α A = @Lattice.toSemilatticeSup α B := SemilatticeSup.ext H
have II := SemilatticeInf.ext H
cases A
cases B
injection SS <;> injection II <;> congr
simp only [sup_inf_left, fun y : α => @sup_comm α _ y x, eq_self_iff_true]
rw [inf_sup_self]
simp only [inf_assoc, sup_inf_right, eq_self_iff_true]
rw [sup_inf_self]
rw [sup_comm]
rw [sup_inf_left]
simp only [inf_sup_left, fun y : α => @inf_comm α _ y x, eq_self_iff_true]
rw [sup_inf_right, @sup_comm _ _ x]
infer_instance
rw [← h, inf_eq_left.2 hxy]
simp only [h, hf h, sup_of_le_right]
simp only [h, hf h, sup_of_le_left]
simp [upperBounds, gc _ _]
simp only [image_pair, is_lub_pair]
rw [range_comp, ← Sup_range] <;> exact gc.is_lub_l_image (is_lub_Sup _)
simp only [Sup_eq_supr, gc.l_supr]
intro a b <;> rw [gc2, gc1]
rw [← e.bdd_above_image, e.image_preimage]
rw [← e.bdd_below_image, e.image_preimage]
simp only [gi.l_u_eq]
simp only [supr_subtype', gi.l_supr_u]
rw [Sup_image, gi.l_bsupr_u, Sup_eq_supr]
simp only [gi.l_u_eq]
simp only [infi_subtype', gi.l_infi_u]
rw [Inf_image, gi.l_binfi_u, Inf_eq_infi]
simp [hf]
rw [infi_subtype', infi_subtype']
exact gi.l_infi_of_ul_eq_self _ fun _ => hf _ _
simp only [gi.choice_eq] <;> exact fun a b => gi.gc.l_le inf_le_left
    inf_le_right
simp only [gi.choice_eq] <;> exact fun a b => gi.gc.l_le inf_le_right
    le_inf
simp only [gi.choice_eq] <;>
        exact fun a b c hac hbc =>
          (gi.le_l_u a).trans <|
            gi.gc.monotone_l <| le_inf (gi.gc.monotone_u hac) (gi.gc.monotone_u hbc)
simp only [gi.choice_eq] <;> exact fun b => (gi.le_l_u b).trans (gi.gc.monotone_l le_top)
rw [gi.choice_eq]
exact (gi.is_glb_of_u_image (is_glb_Inf _)).1
rw [gi.choice_eq]
exact (gi.is_glb_of_u_image (is_glb_Inf _)).2
have := eq_of_mem_maximals ha hb (h _ _ hab)
subst this
exact hab
have := eq_of_mem_minimals ha hb (h _ _ hab)
subst this
exact hab
have := h.eq ha hb hab
subst this
exact hab
have := h.eq hb ha hab
subst this
exact hab
.rfl
.rfl
.rfl
.rfl
simp [eq_empty_iff_forall_not_mem]
rw [← Icc_diff_right, h.Icc_eq, diff_singleton_subset_iff, pair_comm]
rw [← Icc_diff_left, h.Icc_eq, diff_singleton_subset_iff]
simp [eq_empty_iff_forall_not_mem]
rw [← Ioo_union_left h.lt, h.Ioo_eq, empty_union]
rw [← Ioo_union_right h.lt, h.Ioo_eq, empty_union]
rw [← Ioo_union_Ici_eq_Ioi h.lt, h.Ioo_eq, empty_union]
rw [← Iic_union_Ioo_eq_Iio h.lt, h.Ioo_eq, union_empty]
refine' wcov
cases x
cases y
exact mk_wcov
cases x
cases y
exact mk_cov
rw [IF.compl_I_eq_F]
exact IF.F.is_pfilter
apply hI.mem_or_mem
rw [inf_compl_eq_bot]
exact I.bot_mem
rw [IF.compl_F_eq_I]
exact IF.I.is_ideal
change Finset.map _ (Finset.univ : Finset Bool) = _
rw [Fintype.univ_bool]
simp only [Finset.map_insert, Function.Embedding.coeFn_mk, Finset.map_singleton]
rfl
rw [← Finset.mem_singleton, or_comm, ← Finset.mem_insert, top_eq_true, bot_eq_false, ←
      Fintype.univ_bool]
apply Finset.mem_univ
simp [BddAbove, upperBounds, Set.Nonempty]
simp only [not_bdd_above_iff', not_le]
rw [h.upper_bounds_eq]
rfl
rw [h.lower_bounds_eq]
rfl
simp [IsLeast, lower_bounds_union, or_and_right, and_comm' (a ∈ t), and_assoc']
rw [bdd_above_def, exists_ge_and_iff_exists]
exact Monotone.ball fun x hx => monotone_le
simp only [Ici_inter_Iic.symm, subset_inter_iff, bdd_below_iff_subset_Ici,
    bdd_above_iff_subset_Iic, exists_and_left, exists_and_right]
rw [is_greatest_univ.upper_bounds_eq, Ici_top]
simp [BddAbove]
simp only [upperBounds, eq_univ_iff_forall, mem_set_of_eq, ball_empty_iff, forall_true_iff]
simp only [BddAbove, upper_bounds_empty, univ_nonempty]
simp only [BddBelow, lower_bounds_empty, univ_nonempty]
simp only [IsGlb, lower_bounds_empty, is_greatest_univ]
simp only [h, upper_bounds_empty]
simp only [insert_eq, bdd_above_union, bdd_above_singleton, true_and_iff]
simp only [insert_eq, bdd_below_union, bdd_below_singleton, true_and_iff]
rw [insert_eq]
exact is_lub_singleton.union hs
rw [insert_eq]
exact is_glb_singleton.union hs
rw [insert_eq]
exact is_greatest_singleton.union hs
rw [insert_eq]
exact is_least_singleton.union hs
rw [insert_eq, upper_bounds_union, upper_bounds_singleton]
rw [insert_eq, lower_bounds_union, lower_bounds_singleton]
simp only [← not_le, is_lub_le_iff h, mem_upper_bounds, not_forall]
rw [is_lub_image, f.symm_apply_apply]
rw [← f.symm_symm, ← image_eq_preimage, is_lub_image]
rw [is_lub_preimage, f.apply_symm_apply]
simp [*]
simp only [image_pair, is_lub_pair]
simp only [← sup_eq_right, ← hf.map_sup, h.eq_iff]
simp only [lt_iff_le_not_le, hf.le_iff h]
rw [hf.map_Sup', Sup_image]
simp only [supr, hf.map_Sup', ← range_comp]
simp only [supr, hf.map_cSup (range_nonempty _) hg, ← range_comp]
rw [h_top]
exact le_top
rw [← H] <;> apply le_top
rw [h_bot]
exact bot_le
rw [← H] <;> apply bot_le
rw [eq_bot_iff, sup_le_iff] <;> simp
rw [map_top]
exact le_top
rw [map_bot]
exact bot_le
rw [← coe_bot hbot, ext_iff]
rw [← coe_top htop, ext_iff]
simp only [← inf_eq_min, ← le_bot_iff, inf_le_iff]
cases f
cases g
congr
exact RelEmbedding.coe_fn_injective this
rw [Subsingleton.elim f g]
rw [← e] <;>
                exact
                  (trichotomous _ _).resolve_right
                    (not_or_of_not (hn a) fun hl => not_exists.2 hn (f.init' hl))
clear _let_match <;> subst e <;> rfl
have := f.lt_top f.top
rw [show f f.top = f.top from InitialSeg.eq (↑f) (InitialSeg.refl r) f.top] at this
exact irrefl _ this
simp only [g.init_iff, f.down', exists_and_distrib_left.symm, exists_swap,
        RelEmbedding.trans_apply, exists_eq_right'] <;>
      rfl
simp only [h, RelIso.apply_symm_apply, RelIso.coe_coe_fn]
intro x
rw [← g.apply_symm_apply x, g.map_rel_iff, f.down', exists_congr]
intro y
exact ⟨congr_arg g, fun h => g.to_equiv.bijective.1 h⟩
refine' extensional_of_trichotomous_of_irrefl s fun x => _
simp only [f.down, g.down, ef, coe_fn_to_rel_embedding]
rw [Subsingleton.elim f (PrincipalSeg.equivLt e g)] <;> rfl
rw [Subsingleton.elim h (f.trans g)]
apply PrincipalSeg.lt_top
simp [H]
unfold collapse_F
rw [WellFounded.fix_eq]
apply WellFounded.min_mem _ _
refine' ⟨fun h => ⟨fun a b => _⟩, fun h => @is_chain_of_trichotomous _ _ h univ⟩
rw [or_left_comm, or_iff_not_imp_left]
exact h trivial trivial
simp only [hab, exists_prop, and_self_iff, Subtype.exists] <;> exact ⟨b, hb, refl _⟩
let ⟨t, hc'⟩ := h
have : IsChain r s ∧ SuperChain r s (choose h) :=
    @choose_spec _ (fun t => IsChain r s ∧ SuperChain r s t) _
simp [succChain, dif_pos, h, this.right]
simp [succChain, dif_neg, h]
exact hs
simp [succChain, dif_neg, h, subset.rfl]
induction hc₁
case succ s₁ hc₁ h => exact (chain_closure_succ_total hc₁ hc₂ h).elim (fun h => h ▸ hc.subset) id
case union s hs ih => exact sUnion_subset ih
cases s
cases t
congr
rw [le_is_glb_iff (succ_fn_spec i), mem_lower_bounds]
exact fun x hx => le_of_lt hx
rw [Finset.coe_Ioc]
have h := succ_fn_spec i
rw [h_succ_fn_eq] at h
exact is_glb_Ioc_of_is_glb_Ioi hij_lt h
refine' Finset.is_glb_mem _ h_glb _
exact ⟨_, finset.mem_Ioc.mpr ⟨hij_lt, le_rfl⟩⟩
have h := succ_fn_spec i
rw [IsGlb, IsGreatest, mem_lower_bounds] at h
exact h.1 j hij
rw [to_Z_of_ge hi, Int.toNat_coe_nat]
exact Nat.find_spec (exists_succ_iterate_of_le hi)
rw [to_Z_of_lt hi, neg_neg, Int.toNat_coe_nat]
exact Nat.find_spec (exists_pred_iterate_of_le hi.le)
rw [to_Z_of_ge hi]
exact Nat.cast_nonneg _
let m := (toZ i0 ((succ^[n]) i0)).toNat
have h_eq : (succ^[m]) i0 = (succ^[n]) i0 := iterate_succ_to_Z _ (le_succ_iterate _ _)
rw [hj_eq]
refine' Monotone.monotone_iterate_of_le_map succ_mono (le_succ i0) (add_le_add_left _ _)
exact nat.one_le_iff_ne_zero.mpr hm0
rw [hj_eq]
refine' Monotone.antitone_iterate_of_map_le pred_mono (pred_le i0) (add_le_add_left _ _)
exact nat.one_le_iff_ne_zero.mpr hm0
rw [lt_succ_iff_of_not_is_max hb, succ_le_iff_of_not_is_max ha]
rw [succ_le_iff_of_not_is_max ha, lt_succ_iff_of_not_is_max hb]
simp only [Function.iterate_id, id.def]
rw [Function.iterate_succ']
cases le_total n m
· exact is_max_iterate_succ_of_eq_of_lt h_eq (lt_of_le_of_ne h h_ne)
· rw [h_eq]
    exact is_max_iterate_succ_of_eq_of_lt h_eq.symm (lt_of_le_of_ne h h_ne.symm)
rw [← Ici_inter_Iio, Iio_succ_of_not_is_max hb, Ici_inter_Iic]
rw [← Ioi_inter_Iio, Iio_succ_of_not_is_max hb, Ioi_inter_Iic]
rw [← Ici_inter_Iic, Ici_succ_of_not_is_max ha, Ioi_inter_Iic]
rw [← Ici_inter_Iio, Ici_succ_of_not_is_max ha, Ioi_inter_Iio]
simp
simp
rw [eq_iff_le_not_lt, eq_iff_le_not_lt, succ_le_succ_iff_of_not_is_max ha hb,
    succ_lt_succ_iff_of_not_is_max ha hb]
rw [lt_succ_iff, le_bot_iff]
rw [le_succ_iff_eq_or_le, le_bot_iff, or_comm']
simp only [Function.iterate_id, id.def]
rw [← Ioi_inter_Iic, Ioi_pred_of_not_is_min ha, Ici_inter_Iic]
rw [← Ioi_inter_Iio, Ioi_pred_of_not_is_min ha, Ici_inter_Iio]
rw [← Ici_inter_Iic, Iic_pred_of_not_is_min ha, Ici_inter_Iio]
rw [← Ioi_inter_Iic, Iic_pred_of_not_is_min ha, Ioi_inter_Iio]
simp
simp
rw [Function.iterate_succ']
exact le_succ _
cases a
· exact (le_top.not_lt h).elim
cases b
· exact some_le_some.2 le_top
exact some_le_some.2 (le_pred_of_lt <| some_lt_some.1 h)
cases b
· exact le_top
cases a
· exact (not_top_lt <| some_lt_some.1 h).elim
· exact some_le_some.2 (le_of_pred_lt <| some_lt_some.1 h)
cases a
· exact le_top
· exact some_le_some.2 (le_succ a)
cases a
· exact isMax_top
· exact (not_isMax _ <| max_of_succ_le <| some_le_some.1 ha).elim
cases a
· exact (not_top_lt h).elim
cases b
· exact le_top
· exact some_le_some.2 (succ_le_of_lt <| some_lt_some.1 h)
cases a
· exact (not_top_lt h).elim
cases b
· exact le_top
· exact some_le_some.2 (le_of_lt_succ <| some_lt_some.1 h)
cases b
· exact (not_lt_bot h).elim
cases a
· exact some_le_some.2 bot_le
· exact some_le_some.2 (succ_le_of_lt <| some_lt_some.1 h)
cases a
· exact bot_le
cases b
· exact (not_lt_bot <| some_lt_some.1 h).elim
· exact some_le_some.2 (le_of_lt_succ <| some_lt_some.1 h)
cases a
· exact bot_le
· exact some_le_some.2 (pred_le a)
cases a
· exact isMin_bot
· exact (not_isMin _ <| min_of_le_pred <| some_le_some.1 ha).elim
cases b
· exact (not_lt_bot h).elim
cases a
· exact bot_le
· exact some_le_some.2 (le_pred_of_lt <| some_lt_some.1 h)
cases b
· exact (not_lt_bot h).elim
cases a
· exact bot_le
· exact some_le_some.2 (le_of_pred_lt <| some_lt_some.1 h)
simp [is_succ_limit]
simp
have hb' := not_is_succ_limit_succ_of_not_is_max hb
have H := Classical.choose_spec (not_is_succ_limit_iff.1 hb')
rw [is_succ_limit_rec_on]
simp only [cast_eq_iff_heq, hb', not_false_iff, eq_mpr_eq_cast, dif_neg]
congr
· exact (succ_eq_succ_iff_of_not_is_max H.1 hb).1 H.2
· apply proof_irrel_heq
revert h
refine' Succ.rec (fun _ => le_rfl) (fun c hbc H hc => _) hb
have := hc.is_max.succ_eq
rw [this] at hc⊢
exact H hc
simp
simp [is_pred_limit]
simp [is_succ_limit, is_pred_limit]
simp [is_succ_limit, is_pred_limit]
simp
rw [← is_succ_limit_to_dual_iff]
exact not_is_succ_limit_iff
simp
rw [← refl_trans_gen_swap]
exact refl_trans_gen_of_succ_of_le (swap r) h hmn
simp [dif_pos h]
simp [dif_pos h]
congr
exact h
rw [← c.closure_eq_self_of_mem_closed hy, ← le_closure_iff]
rw [sup_comm, closure_sup_closure_left, sup_comm]
rw [closure_sup_closure_left, closure_sup_closure_right]
congr
exact h
let a := lfp (lfp.comp h)
refine' (lfp_le _ _).antisymm (lfp_le _ (Eq.le _))
· exact lfp_le _ h.on_diag.map_lfp.le
have ha : (lfp ∘ h) a = a := (lfp.comp h).map_lfp
calc
    h a a = h a (lfp (h a)) := congr_arg (h a) ha.symm
    _ = lfp (h a) := (h a).map_lfp
    _ = a := ha
apply continuous_hom.congr_fun s.condition
infer_instance
rfl
rfl
constructor
· intro
rw [epi_iff_surjective] at hf
intro y
exact Nonempty.intro ⟨(hf y).some, (hf y).some_spec⟩
rw [eq_empty_of_ssubset_singleton ⟨hs, fun h => hj (h hji)⟩, sup_empty]
exact disjoint_bot_right
simp
simp
simp only [Ne.def, not_false_iff]
simp
rw [← sup_eq_bUnion]
exact hs.sup hg
have := (hs.mono <| insert_subset.mpr ⟨hx, hy⟩) (mem_insert x _)
rw [insert_diff_of_mem _ (mem_singleton _), diff_singleton_eq_self hxy] at this
exact this
refine' (supr_mono fun i => _).trans (supr_comp_le _ f)
exact supr_const_mono hf.ne
rw [set_independent_iff]
rw [← coe_comp_range_factorization t] at ht
exact ht.comp' surjective_onto_range
intro i j h
rw [e] at h <;> exact irrefl _ h
simp [h₁, h₂]
infer_instance
infer_instance
infer_instance
infer_instance
simp only [bounded, unbounded, not_forall, not_exists, exists_prop, not_and, not_not]
rw [not_iff_comm, not_bounded_iff]
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
simp [lt_max_iff, max_lt_iff, *]
cases le_total a b <;> simp only [max_eq_right, max_eq_left, hf ha hb, hf hb ha, h]
cases le_total a b <;> simp [h, hf h]
cases le_total a b <;> simp [h, hf h]
cases le_total a b <;> simp [*]
decide
rw [symmDiff_comm, symmDiff_bot]
rw [symmDiff, sdiff_eq_bot_iff.2 h, bot_sup_eq]
rw [symmDiff, sdiff_eq_bot_iff.2 h, sup_bot_eq]
simp [sup_sdiff, symmDiff]
rw [symmDiff, sup_sdiff_distrib, sdiff_sdiff_left, sdiff_sdiff_left]
rw [symmDiff_sdiff]
simp [symmDiff]
rw [symmDiff, sdiff_idem]
exact
    le_antisymm (sup_le_sup sdiff_le sdiff_le)
      (sup_le le_sdiff_sup <| le_sdiff_sup.trans <| sup_le le_sup_right le_sdiff_sup)
rw [symmDiff_comm, symmDiff_sdiff_eq_sup, sup_comm]
refine' le_antisymm (sup_le symmDiff_le_sup inf_le_sup) _
rw [sup_inf_left, symmDiff]
refine' sup_le (le_inf le_sup_right _) (le_inf _ le_sup_right)
· rw [sup_right_comm]
    exact le_sup_of_le_left le_sdiff_sup
· rw [sup_assoc]
    exact le_sup_of_le_right le_sdiff_sup
rw [sup_comm, symmDiff_sup_inf]
rw [← symmDiff_sdiff_inf a, sdiff_symmDiff_eq_sup, symmDiff_sup_inf]
rw [symmDiff_comm, symmDiff_symmDiff_inf]
rw [bihimp_comm, bihimp_top]
rw [bihimp, himp_eq_top_iff.2 h, inf_top_eq]
rw [bihimp, himp_eq_top_iff.2 h, top_inf_eq]
simp [himp_inf_distrib, bihimp]
rw [bihimp, himp_inf_distrib, himp_himp, himp_himp]
rw [himp_bihimp]
simp [bihimp]
simp [symmDiff]
simp [symmDiff]
rw [eq_top_iff, symmDiff, hnot_sdiff, sup_sdiff_self]
exact Codisjoint.top_le codisjoint_hnot_left
rw [symmDiff_comm, hnot_symmDiff_self]
rw [h.eq_hnot, hnot_symmDiff_self]
simp [bihimp]
simp [bihimp]
rw [h.eq_compl, compl_bihimp_self]
rw [symmDiff_eq_sup_sdiff_inf]
rw [symmDiff_eq_sup_sdiff_inf]
exact disjoint_sdiff_self_left
rw [symmDiff_eq_sup_sdiff_inf, inf_sdiff_distrib_left, inf_sup_left, inf_inf_distrib_left,
    symmDiff_eq_sup_sdiff_inf]
rw [sdiff_symmDiff, sdiff_sup, sup_comm]
rw [symmDiff_def, sup_sdiff, sdiff_idem, sdiff_sdiff_self, bot_sup_eq]
rw [symmDiff_comm, symmDiff_sdiff_left]
simp [sdiff_symmDiff]
rw [symmDiff_comm, inf_comm, sdiff_symmDiff_left]
refine' ⟨fun h => _, Disjoint.symmDiff_eq_sup⟩
rw [symmDiff_eq_sup_sdiff_inf, sdiff_eq_self_iff_disjoint] at h
exact h.of_disjoint_inf_of_le le_sup_left
refine' ⟨fun h => _, fun h => h.symm_diff_eq_sup.symm ▸ le_sup_left⟩
rw [symmDiff_eq_sup_sdiff_inf] at h
exact disjoint_iff_inf_le.mpr (le_sdiff_iff.1 <| inf_le_of_left_le h).le
rw [symmDiff_comm, le_symmDiff_iff_left, Disjoint.comm]
ac_rfl
ac_rfl
rw [symmDiff_symmDiff_left, symmDiff_symmDiff_right]
simp [← symmDiff_assoc]
simp [symmDiff_assoc]
rw [symmDiff_comm, symmDiff_symmDiff_cancel_left]
rw [symmDiff_bot]
rw [symmDiff_right_inj]
rw [symmDiff_comm, symmDiff_eq_left]
rw [symmDiff_eq_sup_sdiff_inf]
exact (ha.sup_left hb).disjoint_sdiff_left
rw [← symmDiff_of_le ha]
exact ((symmDiff_right_involutive a).toPerm _).apply_eq_iff_eq_symm_apply.trans eq_comm
simp [← bihimp_assoc]
simp [bihimp_assoc]
rw [bihimp_comm, bihimp_bihimp_cancel_left]
rw [symmDiff_eq_sup_sdiff_inf, sdiff_eq, compl_inf]
rw [symmDiff_eq', ← compl_inf, inf_eq_top_iff, compl_eq_top, isCompl_iff, disjoint_iff,
    codisjoint_iff, and_comm]
rw [bihimp_eq', ← compl_sup, sup_eq_bot_iff, compl_eq_bot, isCompl_iff, disjoint_iff,
    codisjoint_iff]
rw [symmDiff_eq, compl_symmDiff, bihimp_eq', symmDiff_eq]
rw [inf_sup_left, inf_sup_right, ← sup_assoc, ← inf_assoc, ← inf_assoc]
congr 1
· congr 1
        rw [inf_comm, inf_assoc]
· apply inf_left_right_swap
simp
rw [is_compact_element_iff_le_of_directed_Sup_le] at hk
rw [← ht₂]
exact Finset.sup_mono (t.subset_insert y)
change _ > _
simp [← hn, a.map_rel_iff]
rfl
apply le_antisymm <;> assumption
simp [ht₁, hx₀, -Set.union_singleton]
simp
rw [← Sup_compact_le_eq a, ← Sup_compact_le_eq b]
exact Sup_le_Sup fun c hc => ⟨hc.1, h c hc.1 hc.2⟩
rw [le_iff_compact_le_imp]
rw [well_founded_iff_is_Sup_finite_compact, is_Sup_finite_compact_iff_all_elements_compact] at h
  -- x is the join of the set of compact elements {x}
exact ⟨fun x => ⟨{x}, ⟨fun x _ => h x, Sup_singleton⟩⟩⟩
simp only [set.not_nonempty_iff_eq_empty.mp hS, Set.mem_empty_iff_false, forall_const,
            forall_prop_of_false, not_false_iff]
simp only [Set.union_singleton]
rw [Set.insert_diff_of_not_mem]
rw [Set.mem_singleton_iff]
exact Ne.symm xa
constructor <;> intros
· exact isAtomisticOfComplementedLattice
· exact complemented_lattice_of_is_atomistic
rw [Finset.mem_filter, mem_Icc, and_assoc', lt_iff_le_not_le]
rw [Finset.mem_filter, mem_Icc, and_right_comm, lt_iff_le_not_le]
rw [Finset.mem_filter, mem_Icc, and_and_and_comm, lt_iff_le_not_le, lt_iff_le_not_le]
rw [Finset.mem_filter, mem_Icc, and_assoc', lt_iff_le_and_ne]
rw [Finset.mem_filter, mem_Icc, and_right_comm, lt_iff_le_and_ne]
rw [Finset.mem_filter, mem_Icc, and_and_and_comm, lt_iff_le_and_ne, lt_iff_le_and_ne]
rw [mem_filter, mem_Ici, lt_iff_le_not_le]
rw [mem_filter, mem_Ici, lt_iff_le_and_ne]
rw [mem_filter, mem_Iic, lt_iff_le_not_le]
rw [mem_filter, mem_Iic, lt_iff_le_and_ne]
rw [mem_Icc, and_iff_left le_top]
rw [mem_Ioc, and_iff_left le_top]
rw [mem_Icc, and_iff_right bot_le]
rw [mem_Ico, and_iff_right bot_le]
rw [Icc, ← Finset.mem_def, Finset.mem_Icc]
rw [Ico, ← Finset.mem_def, Finset.mem_Ico]
rw [Ioc, ← Finset.mem_def, Finset.mem_Ioc]
rw [Ioo, ← Finset.mem_def, Finset.mem_Ioo]
rw [Ici, ← Finset.mem_def, Finset.mem_Ici]
rw [Ioi, ← Finset.mem_def, Finset.mem_Ioi]
rw [Iic, ← Finset.mem_def, Finset.mem_Iic]
rw [Iio, ← Finset.mem_def, Finset.mem_Iio]
rw [Finset.mem_Icc, mem_Icc]
rw [Finset.mem_Ico, mem_Ico]
rw [Finset.mem_Ioc, mem_Ioc]
rw [Finset.mem_Ioo, mem_Ioo]
rw [Finset.mem_Ici, mem_Ici]
rw [Finset.mem_Ioi, mem_Ioi]
rw [Finset.mem_Iic, mem_Iic]
rw [Finset.mem_Iio, mem_Iio]
rw [Set.Finite.mem_to_finset, Set.mem_Icc]
simp only [Set.mem_to_finset, Set.mem_Icc]
simp only [Set.mem_to_finset, Set.mem_Ico]
simp only [Set.mem_to_finset, Set.mem_Ioc]
simp only [Set.mem_to_finset, Set.mem_Ioo]
rw [mem_preimage, mem_Icc, f.le_iff_le, f.le_iff_le]
rw [mem_preimage, mem_Ico, f.le_iff_le, f.lt_iff_lt]
rw [mem_preimage, mem_Ioc, f.lt_iff_lt, f.le_iff_le]
rw [mem_preimage, mem_Ioo, f.lt_iff_lt, f.lt_iff_lt]
rw [mem_product, mem_Icc, mem_Icc, and_and_and_comm]
rfl

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
rw [mem_product, mem_Ici, mem_Ici]
rfl

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
rw [mem_product, mem_Iic, mem_Iic]
rfl

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
simp [WithTop.LocallyFiniteOrder._match1]
simp [WithTop.LocallyFiniteOrder._match1, coe_eq_coe]
simp [WithTop.LocallyFiniteOrder._match1]
simp [WithTop.LocallyFiniteOrder._match1, coe_eq_coe]
simp [WithTop.LocallyFiniteOrder._match2]
simp [WithTop.LocallyFiniteOrder._match2, coe_eq_coe, coe_lt_top]
simp [WithTop.LocallyFiniteOrder._match2]
simp [WithTop.LocallyFiniteOrder._match2, coe_eq_coe, coe_lt_coe]
simp [WithTop.LocallyFiniteOrder._match3, coe_lt_top]
simp [WithTop.LocallyFiniteOrder._match3, coe_eq_coe, coe_lt_coe]
simp [WithTop.LocallyFiniteOrder._match3]
simp [WithTop.LocallyFiniteOrder._match3, coe_eq_coe, coe_lt_coe]
simp [WithTop.LocallyFiniteOrder._match4, coe_lt_top]
simp [WithTop.LocallyFiniteOrder._match4, coe_eq_coe, coe_lt_coe, coe_lt_top]
simp [WithTop.LocallyFiniteOrder._match4]
simp [WithTop.LocallyFiniteOrder._match4, coe_eq_coe, coe_lt_coe]
simp
simp
simp
simp
simp
simp
simp
simp
rw [subtype_Icc_eq]
refine' Finset.subtype_map_of_mem fun x hx => _
rw [mem_Icc] at hx
exact hp hx.1 hx.2 a.prop b.prop
rw [subtype_Ico_eq]
refine' Finset.subtype_map_of_mem fun x hx => _
rw [mem_Ico] at hx
exact hp hx.1 hx.2.le a.prop b.prop
rw [subtype_Ioc_eq]
refine' Finset.subtype_map_of_mem fun x hx => _
rw [mem_Ioc] at hx
exact hp hx.1.le hx.2 a.prop b.prop
rw [subtype_Ioo_eq]
refine' Finset.subtype_map_of_mem fun x hx => _
rw [mem_Ioo] at hx
exact hp hx.1.le hx.2.le a.prop b.prop
rw [subtype_Ici_eq]
exact Finset.subtype_map_of_mem fun x hx => hp (mem_Ici.1 hx) a.prop
rw [subtype_Ioi_eq]
exact Finset.subtype_map_of_mem fun x hx => hp (mem_Ioi.1 hx).le a.prop
rw [subtype_Iic_eq]
exact Finset.subtype_map_of_mem fun x hx => hp (mem_Iic.1 hx) a.prop
rw [subtype_Iio_eq]
exact Finset.subtype_map_of_mem fun x hx => hp (mem_Iio.1 hx).le a.prop
rw [le_himp_iff, inf_comm]
rw [le_himp_iff, le_himp_iff']
rw [le_himp_iff, inf_idem]
rw [inf_comm, ← le_himp_iff]
rw [inf_comm, ← le_himp_iff]
rw [inf_comm, inf_himp, inf_comm]
rw [← top_le_iff, le_himp_iff, top_inf_eq]
rw [le_himp_iff, inf_top_eq]
rw [le_himp_iff, le_himp_iff, inf_assoc, himp_inf_self, ← inf_assoc, himp_inf_self, inf_assoc]
exact inf_le_left
rw [himp_himp, inf_idem]
rw [sup_himp_distrib, himp_self, top_inf_eq]
rw [sup_himp_distrib, himp_self, inf_top_eq]
rw [himp_inf_distrib, himp_self, top_inf_eq, h.himp_eq_left]
rw [himp_inf_distrib, himp_self, inf_top_eq, h.himp_eq_right]
rw [le_himp_iff, inf_right_comm, ← le_himp_iff]
exact himp_inf_le.trans le_himp_himp
rw [sup_comm]
exact le_himp_iff
rw [sdiff_le_iff, sup_comm]
rw [sdiff_le_iff, sdiff_le_iff']
rw [sdiff_le_iff, sup_idem]
rw [sup_comm, ← sdiff_le_iff]
rw [sup_comm, sup_sdiff_self, sup_comm]
rw [sup_sdiff_eq_sup hab, sup_of_le_right hbc]
rw [sup_comm, sup_sdiff_cancel_right h]
rw [← le_bot_iff, sdiff_le_iff, sup_bot_eq]
rw [sdiff_le_iff, bot_sup_eq]
rw [sdiff_le_iff, sdiff_le_iff, sup_left_comm, sup_sdiff_self, sup_left_comm, sdiff_sup_self,
    sup_left_comm]
exact le_sup_left
rw [sdiff_sdiff_left, sup_idem]
rw [sdiff_sdiff_comm, sdiff_self, bot_sdiff]
rw [sup_sdiff, sdiff_self, sup_bot_eq]
rw [sup_comm, sup_sdiff_right_self]
rw [sdiff_inf, sdiff_self, bot_sup_eq]
rw [sdiff_inf, sdiff_self, sup_bot_eq]
rw [sup_sdiff, sdiff_self, bot_sup_eq, h.sdiff_eq_right]
rw [sup_sdiff, sdiff_self, sup_bot_eq, h.sdiff_eq_left]
rw [sdiff_le_iff, sup_left_comm, ← sdiff_le_iff]
exact sdiff_sdiff_le.trans le_sup_sdiff
rw [← sup_sdiff_left_self, ← @sup_sdiff_left_self _ _ _ b]
exact sdiff_le_sdiff_right h
rw [← sup_sdiff_right_self, ← @sup_sdiff_right_self _ _ b]
exact sdiff_le_sdiff_right h
rw [inf_comm]
exact sdiff_le_iff
rw [← himp_bot, himp_himp, inf_idem]
rw [← himp_bot, le_himp_iff, disjoint_iff_inf_le]
rw [le_compl_iff_disjoint_right, le_compl_iff_disjoint_left]
rw [le_compl_iff_disjoint_right, disjoint_top, le_bot_iff]
rw [← himp_bot, himp_self]
refine' ((compl_anti compl_sup_compl_le).trans (compl_sup_distrib _ _).le).antisymm _
rw [le_compl_iff_disjoint_right, disjoint_assoc, disjoint_compl_compl_left_iff,
    disjoint_left_comm, disjoint_compl_compl_left_iff, ← disjoint_assoc, inf_comm]
exact disjoint_compl_right
refine' le_antisymm _ _
· rw [le_himp_iff, ← compl_compl_inf_distrib]
    exact compl_anti (compl_anti himp_inf_le)
· refine' le_compl_comm.1 ((compl_anti compl_sup_le_himp).trans _)
    rw [compl_sup_distrib, le_compl_iff_disjoint_right, disjoint_right_comm, ←
      le_compl_iff_disjoint_right]
    exact inf_himp_le
rw [sup_comm]
exact le_himp_iff
rw [← top_sdiff', sdiff_sdiff, sup_idem]
rw [← top_sdiff', sdiff_le_iff, codisjoint_iff_le_sup]
rw [hnot_le_iff_codisjoint_right, hnot_le_iff_codisjoint_left]
rw [hnot_le_iff_codisjoint_left, codisjoint_bot, top_le_iff]
rw [← top_sdiff', sdiff_self]
refine' ((hnot_inf_distrib _ _).ge.trans <| hnot_anti le_hnot_inf_hnot).antisymm' _
rw [hnot_le_iff_codisjoint_left, codisjoint_assoc, codisjoint_hnot_hnot_left_iff,
    codisjoint_left_comm, codisjoint_hnot_hnot_left_iff, ← codisjoint_assoc, sup_comm]
exact codisjoint_hnot_right
refine' le_antisymm _ _
· refine' hnot_le_comm.1 ((hnot_anti sdiff_le_inf_hnot).trans' _)
    rw [hnot_inf_distrib, hnot_le_iff_codisjoint_right, codisjoint_left_comm, ←
      hnot_le_iff_codisjoint_right]
    exact le_sdiff_sup
· rw [sdiff_le_iff, ← hnot_hnot_sup_distrib]
    exact hnot_anti (hnot_anti le_sup_sdiff)
rw [inf_comm]
exact sdiff_le_iff
change f _ ≤ _
rw [map_top]
exact le_top
change f _ ≤ _ ↔ f _ ≤ _
erw [map_himp, map_inf, le_himp_iff]
change f _ ≤ _
rw [map_bot]
exact bot_le
change f _ ≤ _ ↔ f _ ≤ _
erw [map_sdiff, map_sup, sdiff_le_iff]
change f _ ≤ _
rw [map_bot]
exact bot_le
erw [map_himp, map_compl, map_bot, himp_bot]
change f _ ≤ _
rw [map_top]
exact le_top
erw [map_sdiff, map_hnot, map_top, top_sdiff']
rw [IsRegular, compl_bot, compl_top]
rw [IsRegular, compl_top, compl_bot]
rw [IsRegular, compl_compl_inf_distrib, ha.eq, hb.eq]
rw [IsRegular, compl_compl_himp_distrib, ha.eq, hb.eq]
rw [← le_compl_iff_disjoint_left, ha.eq]
rw [← le_compl_iff_disjoint_right, hb.eq]
erw [← (h a).Eq, compl_sup, inf_compl_eq_bot, compl_bot]
dsimp
rw [sup_inf_left, compl_compl_inf_distrib]
dsimp
rw [compl_sup, inf_compl_eq_bot, compl_bot]
rfl
dsimp
rw [compl_sup, a.prop.eq]
refine' eq_of_forall_le_iff fun c => le_himp_iff.trans _
rw [le_compl_iff_disjoint_right, disjoint_left_comm, b.prop.disjoint_compl_left_iff]
rw [boundary, hnot_top, inf_bot_eq]
rw [boundary, hnot_inf_distrib, sup_hnot_self]
unfold boundary
rw [hnot_inf_distrib, inf_sup_left, inf_right_comm, ← inf_assoc]
rw [boundary, inf_sup_right]
exact
    sup_le_sup (inf_le_inf_left _ <| hnot_anti le_sup_left)
      (inf_le_inf_left _ <| hnot_anti le_sup_right)
simp only [boundary, sup_inf_left, sup_inf_right, sup_right_idem, le_inf_iff, sup_assoc,
    @sup_comm _ _ _ a]
refine' ⟨⟨⟨_, _⟩, _⟩, ⟨_, _⟩, _⟩ <;> try exact le_sup_of_le_left inf_le_left <;>
    refine' inf_le_of_right_le
rw [@sup_comm _ _ a, inf_comm]
exact boundary_le_boundary_sup_sup_boundary_inf_left
rw [boundary, hnot_boundary, inf_top_eq]
rw [boundary, sup_inf_left, hnot_sup_self, inf_top_eq, sup_eq_right]
exact hnot_hnot_le
rw [boundary, h, inf_top_eq]
simp only [← map_inv_le_iff, le_himp_iff]
rw [← OrderIsoClass.map_le_map_iff f]
simp
simp only [← le_map_inv_iff, sdiff_le_iff]
rw [← OrderIsoClass.map_le_map_iff f]
simp
simp only [← map_inv_le_iff, le_himp_iff]
rw [← OrderIsoClass.map_le_map_iff f]
simp
simp only [← le_map_inv_iff, sdiff_le_iff]
rw [← OrderIsoClass.map_le_map_iff f]
simp
rw [himp_eq, himp_eq, map_sup, (is_compl_compl.map _).compl_eq]
rw [sdiff_eq, sdiff_eq, map_inf, (is_compl_compl.map _).compl_eq]
rw [← himp_bot, ← himp_bot, map_himp, map_bot]
rw [← top_sdiff', ← top_sdiff', map_sdiff, map_top]
simp
simp
rw [← comp_apply, h, comp_apply]
simp
simp
rw [← comp_apply, h, comp_apply]
simp
simp
rw [← comp_apply, h, comp_apply]
rw [Finset.mem_range, Nat.lt_succ_iff]
refine' (supr_le fun n => _).antisymm (supr_mono <| le_partial_sups f)
rw [partial_sups_eq_bsupr]
exact supr₂_le_supr _ _
rw [← supr_partial_sups_eq f, ← supr_partial_sups_eq g]
exact supr_mono h
simp [is_bounded, exists_true_iff_nonempty]
simp [is_bounded, eq_univ_iff_forall]
simp [is_bounded, subset_def]
rw [← Nat.cofinite_eq_at_top] at hf
exact hf.bdd_above_range_of_cofinite
simp [is_cobounded]
simp (config := { contextual := true }) [is_cobounded, eq_univ_iff_forall,
    exists_true_iff_nonempty]
simp [is_cobounded, subset_def]
simp only [eventually_map, e.le_iff_le]
simp [blimsup_eq, limsup_eq]
simp [bliminf_eq, liminf_eq]
simp [Limsup] <;> exact cInf_upper_bounds_eq_cSup h hs
rw [limsup_eq]
congr
simp [hx]
rw [blimsup_eq]
congr
simp
simp
simp [eq_univ_iff_forall] <;> exact fun b hb => top_unique <| hb _
simp [eq_univ_iff_forall] <;> exact fun b hb => bot_unique <| hb _
simp [blimsup_eq]
simp [bliminf_eq]
rw [limsup_eq, eq_bot_iff]
exact Inf_le (eventually_of_forall fun x => le_rfl)
simp only [Sup_image, id]
simp only [Sup_image, infi_const] <;> rfl
simp only [limsup_eq_infi_supr_of_nat, supr_ge_eq_supr_nat_add]
simp only [Sup_image, id]
revert h
rw [← not_imp_not, not_frequently, not_frequently]
exact fun h => hb.mp (h.mono fun a hbx hba hax => hbx (hba.trans hax))
refine' le_antisymm _ blimsup_sup_le_or
simp only [blimsup_eq, Inf_sup_eq, sup_Inf_eq, le_infi₂_iff, mem_set_of_eq]
refine' fun a' ha' a ha => Inf_le ((ha.And ha').mono fun b h hb => _)
exact Or.elim hb (fun hb => le_sup_of_le_left <| h.1 hb) fun hb => le_sup_of_le_right <| h.2 hb
simp only [limsup_eq_infi_supr, liminf_eq_supr_infi, compl_infi, compl_supr]
simp only [limsup_eq_infi_supr, liminf_eq_supr_infi, compl_infi, compl_supr]
rw [← compl_inj_iff]
simp only [sdiff_eq, liminf_compl, (· ∘ ·), compl_inf, compl_compl, sup_limsup]
rw [← compl_inj_iff]
simp only [sdiff_eq, limsup_compl, (· ∘ ·), compl_inf, compl_compl, sup_liminf]
simp
simp only [← cofinite.blimsup_true s, cofinite.blimsup_set_eq, true_and_iff]
simp only [← cofinite.bliminf_true s, cofinite.bliminf_set_eq, true_and_iff]
rw [left_inv]
rw [left_inv]
refine' subset.antisymm (fun c hc => _) (subset_univ _)
simp
congr
decide
rw [right_inv]
rw [right_inv]
refine' subset.antisymm (fun c hc => _) (subset_univ _)
refine' (eq_iff_le_not_lt.2 ⟨_, h⟩).symm
exact c.length_pos_of_pos hn
simp
apply p.congr (Composition.single_length hn) fun j hj1 hj2 => _
simp [apply_composition_single]
decide
simp only [Set.mem_to_finset, Set.mem_setOf_eq] at hc
simp [← Composition.ne_single_iff N, Composition.eq_single_iff_length, ne_of_gt hc]
decide
decide
decide
simp
rw [comp_right_inv p i h h0]
rw [comp_assoc]
rw [left_inv_comp p i h]
simp
rw [left_inv_remove_zero]
apply left_inv_eq_right_inv_aux <;> simp [h]
rw [right_inv_remove_zero]
simp [Composition.eq_single_iff_length, ne_of_gt hd.2]
simp
simp only [LinearIsometryEquiv.norm_map, pow_one, right_inv_coeff_one, Nat.Ico_succ_singleton,
        sum_singleton, ← sum_Ico_consecutive _ one_le_two hn]
congr 1
apply sum_congr rfl fun j hj => _
rw [right_inv_coeff _ _ _ (mem_Ico.1 hj).1, norm_neg]
trace
        "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr add_le_add, \",\", expr le_refl, \",\", expr sum_le_sum\n   (λ j hj, _), \",\", expr mul_le_mul_of_nonneg_left, \",\", expr pow_nonneg, \",\", expr ha, \"]\"],\n  []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
apply (ContinuousLinearMap.norm_comp_continuous_multilinear_map_le _ _).trans
apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)
apply (norm_sum_le _ _).trans
apply sum_le_sum fun c hc => _
apply (comp_along_composition_norm _ _ _).trans
apply mul_le_mul_of_nonneg_right (hp _)
exact prod_nonneg fun j hj => norm_nonneg _
apply (tendsto_order.1 this).2
simp [zero_lt_one]
apply (tendsto_order.1 this).2
simp [zero_lt_one]
induction that the
trace
            "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr add_le_add, \",\", expr le_refl, \",\", expr mul_le_mul_of_nonneg_left, \",\", expr mul_nonneg, \",\", expr norm_nonneg, \",\", expr Cpos.le, \",\", expr zero_le_two, \",\", expr pow_le_pow_of_le_left, \",\", expr rpos.le, \"]\"],\n  []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
trace
            "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr mul_le_mul_of_nonneg_right, \",\", expr apos.le, \",\", expr add_le_add, \",\", expr le_refl, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
        
  -- conclude that all coefficients satisfy `aⁿ Qₙ ≤ (I + 1) a`.
congr <;> try rw [hn]
simp [one_le_n]
decide
simp [h, hn, this]
simp [ha k (finset.mem_range.mp hk)]
have hpd : deriv f z₀ = p.coeff 1 := hp.deriv
have hp0 : p.coeff 0 = f z₀ := hp.coeff_zero 1
simp only [has_fpower_series_at_iff, apply_eq_pow_smul_coeff, coeff_fslope] at hp⊢
refine' hp.mono fun x hx => _
rw [Pi.sub_apply, h, sub_self]
simp
simp [Finset.sum_range_succ, ← sub_sub, has_sum_zero]
simp
simp only [Finset.sum_range_succ, Finset.sum_range_one, Prod.fst_add, Prod.snd_add,
          f.map_add_add]
dsimp
simp only [add_comm, sub_self, has_sum_zero]
simp [hn]
simp [constFormalMultilinearSeries]
rw [mem_emetric_ball_zero_iff] at hx
refine'
    summable_of_nonneg_of_le (fun _ => norm_nonneg _) (fun n => ((p n).le_op_norm _).trans_eq _)
      (p.summable_norm_mul_pow hx)
simp
simp [Ennreal.coe_pos.1 r0]
simp [rpos]
refine' Ennreal.le_of_forall_nnreal_lt fun r hr => _
rw [lt_min_iff] at hr
have := ((p.is_o_one_of_lt_radius hr.1).add (q.is_o_one_of_lt_radius hr.2)).IsO
refine' (p + q).le_radius_of_is_O (((is_O_of_le _) fun n => _).trans this)
rw [← add_mul, norm_mul, norm_mul, norm_norm]
exact mul_le_mul_of_nonneg_right ((norm_add_le _ _).trans (le_abs_self _)) (norm_nonneg _)
simp [radius]
simp
rw [pf.radius_neg]
exact hf.r_le
simp [hf.r_pos]
intro i hi
have : 0 < i := pos_iff_ne_zero.2 hi
exact ContinuousMultilinearMap.map_coord_zero _ (⟨0, this⟩ : Fin i) rfl
rw [ball_zero_eq] at hy
exact hy
refine' this.trans _
trace
        "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr div_le_div_of_le_left, \",\", expr sub_pos.2, \",\", expr div_nonneg, \",\", expr mul_nonneg, \",\", expr pow_nonneg, \",\", expr hC.lt.le, \",\", expr ha.1.le, \",\", expr norm_nonneg, \",\", expr nnreal.coe_nonneg, \",\", expr ha.2, \",\", expr (sub_le_sub_iff_left\n    _).2, \"]\"],\n  []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error" <;>
      infer_instance
rw [mul_pow, mul_assoc]
rw [Emetric.ball_prod_same]
exact Emetric.ball_subset_ball hr.le hy'
trace
            "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr mul_le_mul_of_nonneg_right, \",\", expr mul_le_mul, \",\", expr hp, \",\", expr pow_le_pow_of_le_left, \",\", expr hy'.le, \",\", expr norm_nonneg, \",\", expr pow_nonneg, \",\", expr div_nonneg, \",\", expr mul_nonneg, \",\", expr nat.cast_nonneg, \",\", expr hC.le, \",\", expr r'.coe_nonneg, \",\", expr ha.1.le, \"]\"],\n  []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
simp only [Real.norm_eq_abs, abs_of_pos ha.1, ha.2]
refine' (is_O.of_bound 1 (eventually_principal.2 fun y hy => _)).trans this
rw [one_mul]
exact (hL y hy).trans (le_abs_self _)
rw [zero_add]
exact p.has_sum hy
rw [norm_smul]
exact
        inv_mul_cancel_right₀ hy.ne.symm δ ▸
          mul_lt_mul_of_pos_right (lt_of_lt_of_le k_norm (min_le_left _ _)) hy
rw [← mul_assoc]
simp [norm_mul, mul_pow]
funext z
refine' Finset.sum_eq_single _ (fun b hb hnb => _) fun hn => _
· have := finset.mem_range_succ_iff.mp hb
      simp only [hk b (this.lt_of_ne hnb), Pi.zero_apply, zero_apply]
· exact False.elim (hn (finset.mem_range.mpr (lt_add_one k)))
erw [Finset.card_compl, Fintype.card_fin, hs, add_tsub_cancel_right]
simp only [change_origin_series_term, LinearIsometryEquiv.norm_map]
simp only [change_origin_series_term, LinearIsometryEquiv.nnnorm_map]
rw [← p.nnnorm_change_origin_series_term k l s hs, ← Fin.prod_const, ← Fin.prod_const]
apply ContinuousMultilinearMap.le_of_op_nnnorm_le
apply ContinuousMultilinearMap.le_op_nnnorm
simp only [tsum_fintype, nnnorm_change_origin_series_term]
rw [Nnreal.tsum_mul_right, ← Fin.prod_const]
exact
    (p.change_origin_series k l).le_of_op_nnnorm_le _ (p.nnnorm_change_origin_series_le_tsum _ _)
apply this <;> simp only [hs, add_tsub_cancel_right]
refine'
    Nnreal.summable_of_le (fun n => _)
      (Nnreal.summable_sigma.1 <| p.change_origin_series_summable_aux₂ hr k).2
simp only [Nnreal.tsum_mul_right]
exact mul_le_mul' (p.nnnorm_change_origin_series_le_tsum _ _) le_rfl
refine' tsum_of_nnnorm_bounded _ fun l => p.nnnorm_change_origin_series_apply_le_tsum k l x
have := p.change_origin_series_summable_aux₂ h k
refine' HasSum.sigma this.has_sum fun l => _
exact ((Nnreal.summable_sigma.1 this).1 l).HasSum
refine'
      HasSum.sigma_of_has_sum ((p.change_origin x).Summable y_mem_ball).HasSum (fun k => _) hsf
· dsimp only [f]
      refine' ContinuousMultilinearMap.has_sum_eval _ _
      have := (p.has_fpower_series_on_ball_change_origin k radius_pos).HasSum x_mem_ball
      rw [zero_add] at this
      refine' HasSum.sigma_of_has_sum this (fun l => _) _
      · simp only [change_origin_series, ContinuousMultilinearMap.sum_apply]
        apply has_sum_fintype
      · refine'
          summable_of_nnnorm_bounded _
            (p.change_origin_series_summable_aux₂ (mem_emetric_ball_zero_iff.1 x_mem_ball) k)
            fun s => _
        refine' (ContinuousMultilinearMap.le_op_nnnorm _ _).trans_eq _
        simp
apply le_trans _ p.change_origin_radius
exact tsub_le_tsub hf.r_le le_rfl
simp [h]
simp
rw [← map_add_left_nhds_zero, eventually_map, has_fpower_series_at_iff]
trace
    "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr «expr∀ᶠ in , »((z), (nhds() 0 : filter 𝕜), has_sum (λ n, _) (f «expr + »(z₀, z)))]]"
rw [add_sub_cancel']
simp
simp [apply_composition]
simp only [apply_composition_update, ContinuousMultilinearMap.map_add]
simp only [apply_composition_update, ContinuousMultilinearMap.map_smul]
apply Finset.eq_of_subset_of_card_le <;> simp [Finset.card_univ, composition_card 0]
simp [composition_card]
simp
congr
apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)
refine' Finset.prod_le_prod (fun i hi => norm_nonneg _) fun i hi => _
apply ContinuousMultilinearMap.le_op_norm
rw [Finset.prod_mul_distrib, mul_assoc]
rw [← c.blocks_fin_equiv.prod_comp, ← Finset.univ_sigma_univ, Finset.prod_sigma]
congr
subst n
apply id_apply_one
cases n
· rfl
cases n
· contradiction
rfl
simp only [Finset.prod_mul_distrib, Finset.prod_pow_eq_pow_sum, c.sum_blocks_fun]
simp
rw [tsum_fintype, ← Finset.sum_mul]
exact mul_le_mul' (nnnorm_sum_le _ _) le_rfl
simp only [comp_partial_sum_source, Finset.mem_Ico, Fintype.mem_pi_finset, Finset.mem_sigma,
    iff_self_iff]
simp [sum_of_fn]
simp [comp_partial_sum_target, comp_partial_sum_target_set]
apply Composition.blocks_fun_congr <;> try rw [HEq]
rfl
simp only [r_pos, Hf.r_pos, δpos, lt_min_iff, Ennreal.coe_pos, and_self_iff]
  /- We will show that `g ∘ f` admits the power series `q.comp p` in the disk of
    radius `min (r, rf', δ)`. -/
refine' ContinuousAt.comp _ (continuous_const.add continuous_id).ContinuousAt
simp only [add_sub_cancel'_right, id.def]
exact Hg.continuous_on.continuous_at (IsOpen.mem_nhds Emetric.is_open_ball fy_mem)
rw [H]
rw [H]
simp [i.is_lt]
simp [i.is_lt]
rw [← sum_join, join_split_wrt_composition, a.blocks_sum]
rw [length_map, length_split_wrt_composition]
rw [length_split_wrt_composition, ← length_gather]
exact i.2
rw [← a.blocks.join_split_wrt_composition b]
exact mem_join_of_mem (nth_le_mem _ _ _) hi
simp only [Composition.blocksFun, nth_le_map', Composition.gather]
rw [nth_le_map_rev List.length, nth_le_of_eq (map_length_split_wrt_composition _ _)]
rfl
rw [nth_le_of_eq (nth_le_split_wrt_composition _ _ _), nth_le_drop', nth_le_take']
rfl
simp [A]
rw [take_take, min_eq_left]
apply monotone_sum_take _ (Nat.le_succ _)
simp only [size_up_to_succ b hi, add_lt_add_iff_left]
exact A
simp only [and_imp, List.mem_join, exists_imp, forall_mem_of_fn_iff]
exact fun i j hj => Composition.blocks_pos _ hj
simp [sum_of_fn, Composition.blocks_sum, Composition.sum_blocks_fun]
dsimp only [Composition.length]
simp [sum_of_fn]
simp [map_of_fn, (· ∘ ·), Composition.blocks_sum, Composition.of_fn_blocks_fun]
simp [h]
rw [Subtype.coe_mk, Icc_self]
exact mem_singleton _
rfl
simp only [proj, proj_Icc_of_mem _ ht, Subtype.coe_mk]
rw [f.map_t₀']
simp only [v_comp, proj_coe]
have := (continuous_subtype_coe.prod_mk f.continuous).comp v.continuous_proj
refine' ContinuousOn.comp_continuous v.continuous_on this fun x => _
exact ⟨(v.proj x).2, f.mem_closed_ball _⟩
rw [integral_same, add_zero]
rw [dist_add_left, dist_eq_norm,
        integral_interval_sub_left (f.interval_integrable_v_comp _ _)
          (f.interval_integrable_v_comp _ _)]
exact norm_integral_le_of_norm_le_const fun t ht => f.norm_v_comp_le _
apply (norm_nonneg (v x₀)).trans
apply hC
exact ⟨x₀, ⟨mem_closed_ball_self hr', rfl⟩⟩
rw [← Real.closed_ball_eq_Icc]
exact mem_closed_ball_self hε0.le
have := hf2' t₀ (mem_Ioo.mpr ⟨sub_lt_self _ hε, lt_add_of_pos_right _ hε⟩)
apply ContinuousAt.preimage_mem_nhds this.continuous_at
rw [hf1]
exact hs
simp only [gronwall_bound_ε0, zero_mul]
intros
rw [dist_self]
intros
rw [dist_self]
rw [map_mul, abs_coe_circle, one_mul]
intro h
have h1 : rotation a 1 = conj 1 := LinearIsometryEquiv.congr_fun h 1
have hI : rotation a I = conj I := LinearIsometryEquiv.congr_fun h I
rw [rotation_apply, RingHom.map_one, mul_one] at h1
rw [rotation_apply, conj_I, ← neg_one_mul, mul_left_inj' I_ne_zero, h1, eq_neg_self_iff] at hI
exact one_ne_zero hI
simp
simp
simp [two_ne_zero]
rw [← f.norm_map (z - 1), f.map_sub, h]
apply LinearIsometry.re_apply_eq_re_of_add_conj_eq
intro z
apply LinearIsometry.im_apply_eq_im h
simp [pow_two, ← norm_sq_apply]
rw [← LinearMap.det_to_matrix basis_one_I, to_matrix_rotation, Matrix.det_fin_two]
simp [← norm_sq_apply]
rw [← Units.eq_iff, LinearEquiv.coe_det, det_rotation, Units.val_one]
refine' ge_of_tendsto _ this
exact (tendsto_const_nhds.div tendsto_id hR₁.ne').mono_left nhds_within_le_nhds
rw [mem_sphere.1 hz]
exact hr.2
rw [g.dslope_comp, hgf, IsROrC.norm_of_real, norm_norm]
exact fun _ => hd.differentiable_at (ball_mem_nhds _ hR₁)
rw [← Int.coe_nat_dvd, hk]
apply dvd_mul_left
simp [real.pi_pos.le]
simp
simp [real.pi_pos.le]
simp
intro c₁ c₂ B₁ B₂ hc hB₀ hB z
rw [Real.norm_eq_abs, Real.norm_eq_abs, Real.abs_exp, Real.abs_exp, Real.exp_le_exp]
exact
      mul_le_mul hB (Real.exp_le_exp.2 <| mul_le_mul_of_nonneg_right hc <| abs_nonneg _)
        (Real.exp_pos _).le hB₀
refine' le_of_tendsto (tendsto.mono_left _ nhds_within_le_nhds) this
apply ((continuous_of_real.mul continuous_const).cexp.smul continuous_const).norm.tendsto'
simp
infer_instance
assumption
refine' ⟨log z, _, exp_log hzne⟩
rw [log_im]
exact ⟨arg_nonneg_iff.2 hz_im, arg_le_pi_div_two_iff.2 (Or.inl hz_re)⟩
intro z hz
rw [mem_re_prod_im, exp_re, exp_im, mem_Ioi, mem_Ioi]
refine'
      ⟨mul_pos (Real.exp_pos _)
          (Real.cos_pos_of_mem_Ioo
            ⟨(neg_lt_zero.2 <| div_pos Real.pi_pos two_pos).trans hz.1, hz.2⟩),
        mul_pos (Real.exp_pos _)
          (Real.sin_pos_of_mem_Ioo ⟨hz.1, hz.2.trans (half_lt_self Real.pi_pos)⟩)⟩
refine' (hd.continuous_on _ _).mono subset_closure
simp [closure_re_prod_im, mem_re_prod_im]
intro C' hC' z hz
cases le_total z.im 0
· refine'
        quadrant_IV (hd.mono fun _ => And.left) (Exists₃Cat.imp (fun c hc B hO => _) hexp)
          (fun x hx => (hC' x hx).trans <| le_max_right _ _)
          (fun x hx => (him x).trans (le_max_left _ _)) hz h
      exact hO.mono (inf_le_inf_left _ <| principal_mono.2 fun _ => And.left)
· refine'
        quadrant_I (hd.mono fun _ => And.left) (Exists₃Cat.imp (fun c hc B hO => _) hexp)
          (fun x hx => (hC' x hx).trans <| le_max_right _ _)
          (fun x hx => (him x).trans (le_max_left _ _)) hz h
      exact hO.mono (inf_le_inf_left _ <| principal_mono.2 fun _ => And.left)
  -- Since `f` is continuous on `Ici 0` and `‖f x‖` tends to zero as `x → ∞`,
  -- the norm `‖f x‖` takes its maximum value at some `x₀ : ℝ`.
rw [sub_re, of_real_re, _root_.abs_sub_comm]
refine' le_of_tendsto (tendsto.mono_left _ nhds_within_le_nhds) this
apply ((continuous_of_real.mul continuous_const).cexp.smul continuous_const).norm.tendsto'
simp
infer_instance
intro z
rw [norm_smul, norm_eq_abs, abs_exp, of_real_mul_re]
intro n z
simp only [norm_smul, norm_eq_abs, Complex.abs_pow, abs_exp]
refine'
      (integral_boundary_rect_of_has_fderiv_at_real_off_countable f
            (fun z => (fderiv ℂ f z).restrictScalars ℝ) z w s hs Hc
            (fun x hx => (Hd x hx).HasFderivAt.restrictScalars ℝ) _).trans
        _ <;>
    simp [← ContinuousLinearMap.map_smul]
congr 2
·
        exact
          circle_integral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable hr0 hrR
            hs (hc.mono hsub) fun z hz => hd z ⟨hsub' hz.1, hz.2⟩
· simp [hr0.ne']
rw [sub_self, zero_smul, smul_zero]
refine' nonempty_diff.2 fun hsub => _
have : (Ioo l u).Countable :=
      (hs.preimage ((add_right_injective w).comp of_real_injective)).mono hsub
rw [← Cardinal.le_aleph_0_iff_set_countable, Cardinal.mk_Ioo_real (hlu₀.1.trans hlu₀.2)] at this
exact this.not_lt Cardinal.aleph_0_lt_continuum
rw [←
    two_pi_I_inv_smul_circle_integral_sub_inv_smul_of_differentiable_on_off_countable hs hw hc hd,
    smul_inv_smul₀]
simp [Real.pi_ne_zero, I_ne_zero]
simp
simp only [H₂, same_ray.rfl.norm_add, H₁]
simp only [H₂, same_ray.rfl.norm_add, H₁]
refine' h2.congr (eventually_of_forall _) <;> simp
simp only [e, line_map_apply_zero]
have A : ContDiffAt ℝ n (coe : ℝ → ℂ) z := of_real_clm.cont_diff.cont_diff_at
have B : ContDiffAt ℝ n e z := h.restrict_scalars ℝ
have C : ContDiffAt ℝ n re (e z) := re_clm.cont_diff.cont_diff_at
exact C.comp z (B.comp z A)
rw [conformal_at_iff_is_conformal_map_fderiv]
rw [is_conformal_map_iff_is_complex_or_conj_linear]
apply and_congr_left
intro h
have h_diff := h.imp_symm fderiv_zero_of_not_differentiable_at
apply or_congr
· rw [differentiable_at_iff_restrict_scalars ℝ h_diff]
rw [← conj_conj z] at h_diff
rw [differentiable_at_iff_restrict_scalars ℝ (h_diff.comp _ conj_cle.differentiable_at)]
refine' exists_congr fun g => rfl.congr _
have : fderiv ℝ conj (conj z) = _ := conj_cle.fderiv
simp [fderiv.comp _ h_diff conj_cle.differentiable_at, this, conj_conj]
rw [← Real.Angle.to_real_zero, ← arg_coe_angle_eq_iff_eq_to_real, same_ray_iff]
rw [mul_div_left_comm, div_self_mul_self', div_eq_mul_inv]
rw [this.deriv]
exact (UniformSpace.Completion.norm_coe _).symm
simp only [norm_eq_abs, abs_of_real, Real.norm_eq_abs]
rw [norm_eq_abs, norm_eq_abs, ← algebra_map_smul ℝ r x, Algebra.smul_def, map_mul, ←
      norm_algebra_map' ℝ r, coe_algebra_map, abs_of_real]
rfl
rw [sq, sq]
rfl
rw [dist_eq_re_im, h, sub_self, zero_pow two_pos, zero_add, Real.sqrt_sq_eq_abs, Real.dist_eq]
rw [edist_nndist, edist_nndist, nndist_of_re_eq h]
rw [dist_eq_re_im, h, sub_self, zero_pow two_pos, add_zero, Real.sqrt_sq_eq_abs, Real.dist_eq]
rw [edist_nndist, edist_nndist, nndist_of_im_eq h]
rw [dist_of_re_eq (conj_re z), conj_im, dist_comm, Real.dist_eq, sub_neg_eq_add, ← two_mul,
    _root_.abs_mul, abs_of_pos (zero_lt_two' ℝ)]
rw [← dist_nndist, Nnreal.coe_mul, Nnreal.coe_two, Real.coe_nnabs, dist_conj_self]
rw [dist_comm, dist_conj_self]
rw [nndist_comm, nndist_conj_self]
rw [← of_real_rat_cast]
exact norm_real _
simp (config := { singlePass := true }) [← Rat.cast_coe_int]
simp [hn]
simp
simp only [coe_nnnorm, norm_int, Int.norm_eq_abs]
refine' (@pow_left_inj Nnreal _ _ _ _ zero_le' zero_le' hn.bot_lt).mp _
rw [← nnnorm_pow, h, nnnorm_one, one_pow]
simp [abs_re_le_abs]
simp
simp
simp [abs_im_le_abs]
simp
simp
rw [← dist_conj_conj, conj_conj]
simp only [AddMonoidHom.coe_mk, Complex.I_re]
simp only [Complex.I_mul_I, eq_self_iff_true, or_true_iff]
simp only [AddMonoidHom.coe_mk, Complex.re_add_im, Complex.coe_algebra_map,
      Complex.of_real_eq_coe]
simp only [AddMonoidHom.coe_mk, Complex.of_real_re, Complex.coe_algebra_map,
      Complex.of_real_eq_coe]
simp only [AddMonoidHom.coe_mk, Complex.of_real_im, Complex.coe_algebra_map,
      Complex.of_real_eq_coe]
simp only [Complex.mul_re, AddMonoidHom.coe_mk]
simp only [AddMonoidHom.coe_mk, Complex.mul_im]
simp only [Complex.conj_I, RingHom.coe_mk]
simp only [← Complex.norm_sq_eq_abs, ← Complex.norm_sq_apply, AddMonoidHom.coe_mk,
      Complex.norm_eq_abs]
simp only [mul_one, AddMonoidHom.coe_mk, Complex.I_im]
simp only [Complex.inv_def, Complex.norm_sq_eq_abs, Complex.coe_algebra_map,
      Complex.of_real_eq_coe, Complex.norm_eq_abs]
rw [eq_re_of_real_le hz, IsROrC.norm_of_real, Real.norm_of_nonneg (Complex.le_def.2 hz).1]
simp
simp [equiv_real_prod_add_hom]
simp [IsROrC.normSq, Complex.normSq]
simp [IsROrC.abs, Complex.abs]
rw [re_prod_im, re_prod_im, interior_inter, interior_preimage_re, interior_preimage_im]
rw [abs.map_neg, map_one]
exact z.abs_ne_one
simp [Complex.abs]
simp [norm_sq_eq_abs]
rw [coe_inv_circle, inv_def, norm_sq_eq_of_mem_circle, inv_one, of_real_one, mul_one]
rw [map_div₀, abs_conj, div_self (complex.abs.ne_zero hz)]
simp [exp_mul_I, abs_cos_add_sin_mul_I]
rw [exp_map_circle_apply, of_real_zero, zero_mul, exp_zero, Submonoid.coe_one]
simp only [exp_map_circle_apply, Submonoid.coe_mul, of_real_add, add_mul, Complex.exp_add]
rw [eval_C, ← hc z, inv_inv]
simp [is_bounded_at_im_infty, bounded_at_filter, Asymptotics.is_O_iff, Filter.Eventually,
    at_im_infty_mem]
rw [dist_eq, mul_div_cancel_left (arsinh _) two_ne_zero, sinh_arsinh]
rw [tanh_eq_sinh_div_cosh, sinh_half_dist, cosh_half_dist, div_div_div_comm, div_self, div_one]
exact (mul_pos (zero_lt_two' ℝ) (sqrt_pos.2 <| mul_pos z.im_pos w.im_pos)).ne'
rw [← sinh_add_cosh, sinh_half_dist, cosh_half_dist, add_div]
rw [dist_eq, cosh_two_mul, cosh_sq', add_assoc, ← two_mul, sinh_arsinh, div_pow, mul_pow,
    sq_sqrt (mul_pos z.im_pos w.im_pos).le, sq (2 : ℝ), mul_assoc, ← mul_div_assoc, mul_assoc,
    mul_div_mul_left _ _ (two_ne_zero' ℝ)]
simp only [add_div _ _ (2 : ℝ), sinh_add, sinh_half_dist, cosh_half_dist, div_mul_div_comm]
rw [← add_div, Complex.dist_self_conj, coe_im, abs_of_pos b.im_pos, mul_comm (dist ↑b _),
    dist_comm (b : ℂ), Complex.dist_conj_comm, mul_mul_mul_comm, mul_mul_mul_comm _ _ _ b.im]
congr 2
rw [sqrt_mul, sqrt_mul, sqrt_mul, mul_comm (sqrt a.im), mul_mul_mul_comm, mul_self_sqrt,
      mul_comm] <;>
    exact (im_pos _).le
simp only [dist_eq, dist_comm (z : ℂ), mul_comm]
rw [← div_le_div_right (zero_lt_two' ℝ), ← sinh_le_sinh, sinh_half_dist]
rw [← div_left_inj' (two_ne_zero' ℝ), ← sinh_inj, sinh_half_dist]
rw [dist_le_iff_le_sinh, sinh_half_dist_add_dist, div_mul_eq_div_div _ _ (dist _ _), le_div_iff,
    div_mul_eq_mul_div]
·
    exact
      div_le_div_of_le (mul_nonneg zero_le_two (sqrt_nonneg _))
        (EuclideanGeometry.mul_dist_le_mul_dist_add_mul_dist (a : ℂ) b c (conj ↑b))
· rw [dist_comm, dist_pos, Ne.def, Complex.eq_conj_iff_im]
    exact b.im_ne_zero
rw [dist_le_iff_le_sinh, ← div_mul_eq_div_div_swap, self_le_sinh_iff]
exact div_nonneg dist_nonneg (mul_nonneg zero_le_two (sqrt_nonneg _))
rw [dist_eq, dist_self, zero_div, arsinh_zero, mul_zero]
rw [coe_im, coe_im, center_im, Real.cosh_zero, mul_one]
trace
      "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr mul_ne_zero, \",\", expr two_ne_zero, \",\", expr im_ne_zero, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
rw [← sqrt_sq dist_nonneg, dist_coe_center_sq]
rw [dist_of_re_eq (z.center_re r).symm, dist_comm, Real.dist_eq, mul_sub, mul_one]
exact abs_of_nonneg (sub_nonneg.2 <| le_mul_of_one_le_right z.im_pos.le (one_le_cosh _))
rw [← div_le_iff' w.im_pos, ← exp_log z.im_pos, ← exp_log w.im_pos, ← Real.exp_sub, exp_le_exp]
exact (le_abs_self _).trans (dist_log_im_le z w)
rw [dist_center_dist, dist_self_center, ← mul_add, ← add_sub_assoc, Real.sinh_add_cosh]
refine' ⟨fun z r => _⟩
rw [← inducing_coe.is_compact_iff, image_coe_closed_ball]
apply is_compact_closed_ball
simp only [dist_eq, coe_vadd, vadd_im, dist_add_left]
refine' Isometry.ofDistEq fun y₁ y₂ => _
simp only [dist_eq, coe_pos_real_smul, pos_real_im]
congr 2
rw [dist_smul, mul_mul_mul_comm, Real.sqrt_mul (mul_self_nonneg _), Real.sqrt_mul_self_eq_abs,
    Real.norm_eq_abs, mul_left_comm]
exact mul_div_mul_left _ _ (mt _root_.abs_eq_zero.1 a.2.ne')
simp
rw [Complex.norm_sq_pos]
exact z.ne_zero
simp only [denom_ne_zero g z, map_eq_zero, Ne.def, not_false_iff]
intro s g z
simp only [SL_on_GL_pos_smul_apply, coe_coe]
apply mul_smul'
intro s g z
simp only [subgroup_on_GL_pos_smul_apply, coe_coe]
apply mul_smul'
rw [subgroup_on_SL_apply]
apply MulAction.mul_smul
simp only [coe_GL_pos_neg, sl_moeb, coe_coe, coe_int_neg, neg_smul]
simp
simp
simp [add_assoc]
simp [w, norm_smul, h']
simp [gray, ray]
rw [smul_eq_mul, mul_one]
rw [hw']
exact one_ne_zero
rw [← sum_mul, hw', one_mul]
rw [geom_mean_weighted_of_constant, arith_mean_weighted_of_constant] <;> assumption
assumption
assumption
simp [hpq.pos]
simp [hpq.symm.pos]
rw [sum_add_distrib, sum_div, sum_div]
congr
intro s
refine' le_trans (inner_le_Lp_mul_Lq s f g hpq) (mul_le_mul _ _ bot_le bot_le)
· rw [Nnreal.rpow_le_rpow_iff (one_div_pos.mpr hpq.pos)]
      exact sum_le_tsum _ (fun _ _ => zero_le _) hf
· rw [Nnreal.rpow_le_rpow_iff (one_div_pos.mpr hpq.symm.pos)]
      exact sum_le_tsum _ (fun _ _ => zero_le _) hg
rw [hf.tsum_eq, rpow_inv_rpow_self hpq.ne_zero]
rw [hg.tsum_eq, rpow_inv_rpow_self hpq.symm.ne_zero]
rw [Real.is_conjugate_exponent_iff hp]
simp [hpq.ne_zero]
rw [hf.tsum_eq, rpow_inv_rpow_self hp']
rw [hg.tsum_eq, rpow_inv_rpow_self hp']
cases H <;> simp [H i hi]
rw [Real.is_conjugate_exponent_iff hp]
simp only [cnpos.ne', Ne.def, Nat.cast_eq_zero, not_false_iff, field_simps]
refine' mul_le_mul_of_nonneg_right _ (Nat.cast_nonneg _)
simp only [mul_one, Real.norm_eq_abs, abs_one] at hn
exact le_trans (le_abs_self _) hn
simp
apply le_max'
apply mem_image_of_mem
exact mem_range.2 h
apply sub_le_sub (hmono ncN.le)
apply mul_le_mul_of_nonneg_right (Nat.cast_le.2 cNn) lnonneg
simp only [le_add_iff_nonneg_right, zero_le']
simp only [cnpos.ne', Ne.def, Nat.cast_eq_zero, not_false_iff, neg_sub, field_simps]
refine' mul_le_mul_of_nonneg_right _ (Nat.cast_nonneg _)
simp only [mul_one, Real.norm_eq_abs, abs_one] at hn
exact le_trans (neg_le_abs_self _) hn
simp
apply le_max'
apply mem_image_of_mem
exact mem_range.2 h
refine' add_le_add (mul_le_mul_of_nonneg_right (Nat.cast_le.2 ncN.le) lnonneg) _
exact neg_le_neg (hmono cNn)
refine' mul_le_mul_of_nonneg_left (Nat.cast_le.2 cNn) _
exact mul_nonneg εpos.le (add_nonneg zero_le_one lnonneg)
apply tendsto.mono_left _ nhds_within_le_nhds
exact tendsto_const_nhds.add (tendsto_id.mul tendsto_const_nhds)
apply tendsto.mono_left _ nhds_within_le_nhds
exact
          tendsto_const_nhds.add
            (tendsto_id.mul ((tendsto_const_nhds.add tendsto_id).add tendsto_const_nhds))
intro n
refine' zero_lt_one.trans_le _
simp only [Nat.one_le_cast, Nat.one_le_floor_iff, one_le_pow_of_one_le (cone k).le n]
refine' tendsto.div (tendsto.mul _ tendsto_const_nhds) _ one_ne_zero
· refine' tendsto_nat_floor_div_at_top.comp _
      exact (tendsto_pow_at_top_at_top_of_one_lt (cone k)).comp (tendsto_add_at_top_nat 1)
· refine' tendsto_nat_floor_div_at_top.comp _
      exact tendsto_pow_at_top_at_top_of_one_lt (cone k)
refine'
        sum_le_sum_of_subset_of_nonneg _ fun i hi hident => div_nonneg zero_le_one (sq_nonneg _)
intro i hi
simp only [mem_filter, mem_range] at hi
simp only [hi.1, mem_Ico, and_true_iff]
apply Nat.floor_le_of_le
apply le_of_lt
rw [div_lt_iff (Real.log_pos hc), ← Real.log_pow]
exact Real.log_lt_log hj hi.2
congr 1
apply geom_sum_Ico_le_of_lt_one (sq_nonneg _)
rw [sq_lt_one_iff (inv_nonneg.2 (zero_le_one.trans hc.le))]
exact inv_lt_one hc
apply div_le_div _ B (sq_pos_of_pos hj) le_rfl
exact mul_nonneg (pow_nonneg cpos.le _) (inv_nonneg.2 (sub_pos.2 hc).le)
apply sum_le_sum fun i hi => _
rw [mul_div_assoc', mul_one, div_le_div_iff]
rotate_left
· apply sq_pos_of_pos
        refine' zero_lt_one.trans_le _
        simp only [Nat.le_floor, one_le_pow_of_one_le, hc.le, Nat.one_le_cast, Nat.cast_one]
· exact sq_pos_of_pos (pow_pos cpos _)
rw [one_mul, ← mul_pow]
apply pow_le_pow_of_le_left (pow_nonneg cpos.le _)
rw [← div_eq_inv_mul, le_div_iff A, mul_comm]
exact mul_pow_le_nat_floor_pow hc i
rw [← mul_sum, ← mul_div_assoc']
refine' mul_le_mul_of_nonneg_left _ (sq_nonneg _)
exact sum_div_pow_sq_le_div_sq N hj hc
refine' (is_o.of_norm_left _).of_norm_right
exact (is_o_pow_pow_of_lt_left (abs_nonneg r₁) h).congr (pow_abs r₁) (pow_abs r₂)
simp [zero_lt_one.trans_le hn, h0]
apply squeeze_zero_norm' (eventually_norm_pow_le x)
exact tendsto_pow_at_top_nhds_0_of_lt_1 (norm_nonneg _) h
rw [sub_mul, one_mul]
rw [← tsum_eq_zero_add A]
simp [pow_succ, mul_left_comm _ r, tsum_mul_left]
simp [add_mul, tsum_add A B.summable, mul_add, B.tsum_eq, ← div_eq_mul_inv, sq, div_div]
rw [sum_range_succ, dist_eq_norm, ← norm_neg, neg_sub, add_sub_cancel']
exact hf n
rw [← dist_eq_norm]
apply dist_le_of_le_geometric_of_tendsto r C hr (dist_partial_sum_le_of_le_geometric hf)
exact ha.tendsto_sum_nat
simp [dist_eq_norm, sum_range_succ]
simp [dist_eq_norm', sum_range_succ]
simp [h]
intro n hn
simp [v, hn, if_neg (not_lt.mpr hn)]
simp
rw [pow_succ, Nat.factorial_succ, Nat.cast_mul, ← div_mul_div_comm, norm_mul, norm_div,
        Real.norm_coe_nat, Nat.cast_succ]
rw [← Nnreal.tendsto_coe]
exact tendsto_inverse_at_top_nhds_0_nat
simp [pow_succ, ← this, tendsto_const_nhds]
simp
refine' (monotone_mul_left_of_nonneg hc).seq_pos_lt_seq_of_le_of_lt hn _ _ h
· simp
· simp [pow_succ, mul_assoc, le_refl]
refine' (monotone_mul_left_of_nonneg hc).seq_le_seq n _ _ h <;>
    simp [pow_succ, mul_assoc, le_refl]
refine' (monotone_mul_left_of_nonneg hc).seq_pos_lt_seq_of_lt_of_le hn _ h _
· simp
· simp [pow_succ, mul_assoc, le_refl]
refine' (monotone_mul_left_of_nonneg hc).seq_le_seq n _ h _ <;>
    simp [pow_succ, mul_assoc, le_refl]
simp only [Nnreal.coe_pow, Nnreal.coe_zero, tendsto_pow_at_top_nhds_0_of_lt_1 r.coe_nonneg hr]
simp_all [neg_inv, geom_sum_eq, div_eq_mul_inv]
apply summable_of_nonneg_of_le _ _ summable_geometric_two <;>
      · intro i
rw [sum_const, nsmul_one, card_range]
refine' cauchy_seq_of_edist_le_of_tsum_ne_top _ hu _
rw [Ennreal.tsum_mul_left, Ennreal.tsum_geometric]
refine' Ennreal.mul_ne_top hC (Ennreal.inv_ne_top.2 _)
exact (tsub_pos_iff_lt.2 hr).ne'
simp only [div_eq_mul_inv, Ennreal.inv_pow] at hu
refine' cauchy_seq_of_edist_le_geometric 2
refine'
    summable_of_nonneg_of_le (fun a => one_div_nonneg.mpr (pow_nonneg (zero_le_one.trans hm.le) _))
      (fun a => _)
      (summable_geometric_of_lt_1 (one_div_nonneg.mpr (zero_le_one.trans hm.le))
        ((one_div_lt (zero_lt_one.trans hm) zero_lt_one).mpr (one_div_one.le.trans_lt hm)))
rw [div_pow, one_pow]
refine' (one_div_le_one_div _ _).mpr (pow_le_pow hm.le (fi a)) <;>
    exact pow_pos (zero_lt_one.trans hm) _
simp [Nat.le_floor_iff]
constructor
· intro h
    dsimp [Basis.orientation]
    congr
· intro h
    rw [e.to_basis.det.eq_smul_basis_det f.to_basis]
    simp [e.det_to_matrix_orthonormal_basis_of_same_orientation f h]
rw [e.to_basis.det.eq_smul_basis_det f.to_basis]
simp [e.det_to_matrix_orthonormal_basis_of_opposite_orientation f h]
rw [e.to_basis_adjust_to_orientation]
exact e.to_basis.orientation_adjust_to_orientation x
simp [to_basis_adjust_to_orientation]
cases n
· refine' o.eq_or_eq_neg_of_is_empty.
cases n
· refine' o.eq_or_eq_neg_of_is_empty.
cases n
· refine' o.eq_or_eq_neg_of_is_empty.
cases n
· refine' o.eq_or_eq_neg_of_is_empty.
cases n
· refine' o.eq_or_eq_neg_of_is_empty.
rw [← he]
exact e.to_basis.orientation_map φ.to_linear_equiv
simp [area_form]
simp only [right_angle_rotation_aux₁, LinearEquiv.trans_symm, LinearEquiv.coe_trans,
    LinearEquiv.coe_coe, InnerProductSpace.to_dual_symm_apply, eq_self_iff_true,
    LinearMap.coe_to_continuous_linear_map', LinearIsometryEquiv.coe_to_linear_equiv,
    LinearMap.comp_apply, LinearEquiv.symm_symm, LinearIsometryEquiv.to_linear_equiv_symm]
rw [real_inner_comm]
simp [o.area_form_swap y x]
rw [← Set.to_finset_singleton]
exact finrank_span_le_card ({x} : Set E)
rw [right_angle_rotation]
exact o.inner_right_angle_rotation_aux₁_left x y
rw [right_angle_rotation]
exact o.inner_right_angle_rotation_aux₁_right x y
rw [right_angle_rotation]
exact o.right_angle_rotation_aux₁_right_angle_rotation_aux₁ x
rw [right_angle_rotation]
exact LinearIsometryEquiv.to_linear_isometry_injective rfl
simp
simp
simp [o.inner_right_angle_rotation_swap x y]
rw [← o.inner_comp_right_angle_rotation, o.inner_right_angle_rotation_right, neg_neg]
rw [← o.inner_right_angle_rotation_left, o.inner_comp_right_angle_rotation]
simp
apply ext_inner_right ℝ
intro y
rw [inner_right_angle_rotation_left]
simp
rw [← (o.basis_right_angle_rotation x hx).sum_repr y]
simp only [Fin.sum_univ_succ, coe_basis_right_angle_rotation]
dsimp
simp only [o.area_form_apply_self, map_smul, map_add, map_zero, inner_smul_left,
        inner_smul_right, inner_add_left, inner_add_right, inner_zero_right, LinearMap.add_apply,
        Matrix.cons_val_one]
dsimp
simp only [o.area_form_right_angle_rotation_right, mul_zero, add_zero, zero_add, neg_zero,
        o.inner_right_angle_rotation_right, o.area_form_apply_self, real_inner_self_eq_norm_sq]
exact this
simp only [kahler_apply_apply]
rw [real_inner_comm, area_form_swap]
simp
simp [kahler_apply_apply, real_inner_self_eq_norm_sq]
simp [kahler_apply_apply]
simp [kahler_apply_apply, area_form_map]
simp [kahler_apply_apply, o.area_form_comp_linear_isometry_equiv φ hφ]
rw [← Complex.area_form, ← hf, o.area_form_map]
simp
rw [← Complex.right_angle_rotation, ← hf, o.right_angle_rotation_map]
simp
rw [← Complex.kahler, ← hf, o.kahler_map]
simp
exact mem_Iio.1 i.2
rw [← sum_attach, attach_eq_univ, gramSchmidt]
rfl
rw [gram_schmidt_def, sub_add_cancel]
rw [gram_schmidt_def, Iio_eq_Ico, Finset.Ico_self, Finset.sum_empty, sub_zero]
apply orthogonal_projection_mem_subspace_orthogonal_complement_eq_zero
rw [mem_orthogonal_singleton_iff_inner_left]
rw [← mem_orthogonal_singleton_iff_inner_right]
exact this (gram_schmidt_mem_span 𝕜 f (le_refl j))
rfl
simp only [gram_schmidt_ne_zero_coe n h₀, gramSchmidtNormed, norm_smul_inv_norm, Ne.def,
    not_false_iff]
refine'
    span_eq_span
      (Set.image_subset_iff.2 fun i hi => smul_mem _ _ <| subset_span <| mem_image_of_mem _ hi)
      (Set.image_subset_iff.2 fun i hi =>
        span_mono (image_subset _ <| singleton_subset_set_iff.2 hi) _)
simp only [coe_singleton, Set.image_singleton]
rw [gramSchmidtNormed, gram_schmidt_of_orthogonal 𝕜 hf]
rw [hT x y, inner_conj_sym]
intro x y
rw [LinearMap.add_apply, inner_add_left, hT x y, hS x y, ← inner_add_right]
rfl
intro k
rw [← T.map_sub, hT]
simp [hT x y, real_inner_eq_re_inner, LinearMap.coe_restrict_scalars_eq_coe]
have hδ : ∀ n : ℕ, δ < δ + 1 / (n + 1) := fun n =>
      lt_add_of_le_of_pos le_rfl Nat.one_div_pos_of_nat
have h := fun n => exists_lt_of_cinfi_lt (hδ n)
let w : ℕ → K := fun n => Classical.choose (h n)
exact ⟨w, fun n => Classical.choose_spec (h n)⟩
rw [_root_.abs_of_nonneg]
exact zero_le_two
simp [norm_smul]
rw [← this]
simp
rw [smul_sub, sub_smul, one_smul]
simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]
rw [sq]
refine' le_add_of_nonneg_right _
exact sq_nonneg _
rw [inner_smul_right]
simp
intro w hw
rw [real_inner_eq_re_inner, H w hw]
exact zero_re'
rw [← norm_eq_infi_iff_inner_eq_zero K (orthogonal_projection_fn_mem v)]
exact
    (exists_norm_eq_infi_of_complete_subspace K (complete_space_coe_iff_is_complete.mp ‹_›)
          v).some_spec.some_spec
rw [inner_sub_left, huo, huv, sub_zero]
intro w hw
rw [add_sub_add_comm, inner_add_left, orthogonal_projection_fn_inner_eq_zero _ w hw,
            orthogonal_projection_fn_inner_eq_zero _ w hw, add_zero]
intro w hw
rw [← smul_sub, inner_smul_left, orthogonal_projection_fn_inner_eq_zero _ w hw, mul_zero]
intro w hw
rw [inner_eq_zero_sym]
exact orthogonal_projection_inner_eq_zero _ _ hw
rw [norm_eq_infi_iff_inner_eq_zero _ (Submodule.coe_mem _)]
exact orthogonal_projection_inner_eq_zero _
change orthogonalProjectionFn K u = orthogonalProjectionFn K' u
congr
exact h
refine' ⟨fun h => _, fun h => eq_orthogonal_projection_of_mem_of_inner_eq_zero h _⟩
· rw [← h]
    simp
· simp
simp [mul_smul, smul_orthogonal_projection_singleton 𝕜 w]
rw [← smul_orthogonal_projection_singleton 𝕜 w]
simp [hv]
simp [bit0]
rw [← orthogonal_projection_eq_self_iff, reflection_apply, sub_eq_iff_eq_add', ← two_smul 𝕜, ←
    two_smul' 𝕜]
refine' (smul_right_injective E _).eq_iff
exact two_ne_zero
simp [bit0, reflection_apply, orthogonal_projection_map_apply f K x]
simp [Submodule.sup_orthogonal_of_complete_space]
simp [hz y hy, inner_eq_zero_sym]
rw [h, Submodule.top_orthogonal_eq_bot]
simp [reflection_apply, orthogonal_projection_mem_subspace_orthogonal_complement_eq_zero hv]
rw [← Submodule.orthogonal_orthogonal_eq_closure]
constructor <;> intro h
· rw [← Submodule.triorthogonal_eq_orthogonal, h, Submodule.top_orthogonal_eq_bot]
· rw [h, Submodule.bot_orthogonal_eq_top]
rw [inner_zero_left, h v]
rw [inner_zero_right, h v]
apply reflection_mem_subspace_eq_self
rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
rw [real_inner_add_sub_eq_zero_iff]
exact h
let p1 := orthogonalProjection S
let p2 := orthogonalProjection S
rw [orthogonal_projection_inner_eq_zero _ _ (Submodule.coe_mem _), add_zero]
rw [← inner_add_left, add_sub_cancel'_right]
rw [← inner_conj_sym, ← inner_conj_sym (u : E), inner_orthogonal_projection_eq_of_mem_right]
rw [← inner_orthogonal_projection_eq_of_mem_left, inner_orthogonal_projection_eq_of_mem_right]
rw [← add_right_inj (finrank 𝕜 K₁)]
simp [Submodule.finrank_add_inf_finrank_orthogonal h, h_dim]
rw [← add_right_inj (finrank 𝕜 K)]
simp [Submodule.finrank_add_finrank_orthogonal, h_dim]
simp [finrank_span_singleton hv, _i.elim, add_comm]
intro w hw
rw [← hW w hw, LinearIsometryEquiv.inner_map_map]
exact v.prop w hw
intro h
exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    -- Let `ρ` be the reflection in `v - φ v`; this is designed to swap `v` and `φ v`
intro w hw
change w - ρ (φ w) = 0
rw [sub_eq_zero, hw]
    -- Everything fixed
intro w hw
apply hV
rw [hW w hw]
refine' reflection_mem_subspace_eq_self _
rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
exact Submodule.sub_mem _ v.prop hφv _ hw
    -- `v` is also fixed
apply hV
have : ρ v = φ v := reflection_sub (φ.norm_map v).symm
rw [← this]
exact reflection_reflection _ _
    -- By dimension-counting, the complement of the fixed subspace of `φ.trans ρ` has dimension at
    -- most `n`
change finrank ℝ W
simp [e, norm_smul_inv_norm hx]
intro a ha
exact he' a (Submodule.subset_span ha)
refine' mem_of_mem_insert_of_ne hb' _
intro hbe'
apply hab'
simp [ha, hbe']
simp [huv, hxv]
rw [← Finsupp.mem_span_image_iff_total]
simp [huv, inter_eq_self_of_subset_left, hy]
simp
have h' := linear_map.ker_eq_top.mp htriv
rw [← coe_zero] at h'
apply coe_injective
exact h'
simp [hℓ]
rw [LinearMap.mem_ker, map_sub, ContinuousLinearMap.map_smul,
            ContinuousLinearMap.map_smul, Algebra.id.smul_eq_mul, Algebra.id.smul_eq_mul, mul_comm]
exact sub_self (ℓ x * ℓ z)
rw [(Y.mem_orthogonal' z).mp hz]
exact h₁
rw [inner_sub_right]
simp [inner_smul_right]
simp [inner_smul_left, conj_conj]
rw [← div_mul_eq_mul_div]
rw [h₂]
rw [← to_dual_apply]
simp only [LinearIsometryEquiv.apply_symm_apply]
simp [continuous_linear_map_of_bilin]
refine' ext_inner_right 𝕜 _
intro w
rw [continuous_linear_map_of_bilin_apply]
exact is_lax_milgram w
rw [inner_re_symm] <;> exact hT.inner_nonneg_left x
refine' ⟨is_self_adjoint_zero _, fun x => _⟩
change 0 ≤ re
refine' ⟨hT.is_self_adjoint.add hS.is_self_adjoint, fun x => _⟩
rw [re_apply_inner_self, add_apply, inner_add_left, map_add]
exact add_nonneg (hT.inner_nonneg_left x) (hS.inner_nonneg_left x)
refine' ⟨hT.is_self_adjoint.conj_adjoint S, fun x => _⟩
rw [re_apply_inner_self, comp_apply, ← adjoint_inner_right]
exact hT.inner_nonneg_left _
simp only [adjoint_aux_apply, to_dual_symm_apply, to_sesq_form_apply_coe, coe_comp',
    innerSL_apply_coe]
rw [← inner_conj_sym, adjoint_aux_inner_left, inner_conj_sym]
rw [← adjoint_inner_left]
rfl
rw [← apply_norm_sq_eq_inner_adjoint_left, Real.sqrt_sq (norm_nonneg _)]
rw [← adjoint_inner_right]
rfl
rw [← apply_norm_sq_eq_inner_adjoint_right, Real.sqrt_sq (norm_nonneg _)]
rw [h, adjoint_inner_left]
simp only [adjoint_inner_left, h x y]
refine' Eq.symm _
rw [eq_adjoint_iff]
simp
rw [← U.adjoint_subtypeL, adjoint_adjoint]
rw [LinearIsometryEquiv.norm_map]
rw [apply_norm_eq_sqrt_inner_adjoint_left]
rw [mul_assoc, Real.sqrt_mul (norm_nonneg _), Real.sqrt_mul_self (norm_nonneg _)]
simp only [sesq_form_of_inner_apply_apply, adjoint_inner_left, to_linear_map_eq_coe, coe_coe]
rw [is_self_adjoint_iff'] at hT⊢
simp only [hT, adjoint_comp, adjoint_adjoint]
exact ContinuousLinearMap.comp_assoc _ _ _
rw [is_self_adjoint_iff'] at hT⊢
simp only [hT, adjoint_comp, adjoint_adjoint]
exact ContinuousLinearMap.comp_assoc _ _ _
rw [← coe_to_continuous_linear_map A, adjoint_eq_to_clm_adjoint]
exact ContinuousLinearMap.adjoint_inner_left _ x y
rw [← coe_to_continuous_linear_map A, adjoint_eq_to_clm_adjoint]
exact ContinuousLinearMap.adjoint_inner_right _ x y
rw [h, adjoint_inner_left]
simp only [adjoint_inner_left, h x y]
rw [h, adjoint_inner_left]
simp only [adjoint_inner_left, h i₁ i₂]
rw [h, adjoint_inner_left]
simp only [h i, adjoint_inner_left]
rw [h, adjoint_inner_left]
simp only [h i, adjoint_inner_left]
rw [is_self_adjoint_iff', is_symmetric, ← LinearMap.eq_adjoint_iff]
exact eq_comm
simp only [sesq_form_of_inner_apply_apply, adjoint_inner_left]
simp only [mul_apply, adjoint_inner_left, adjoint_inner_right]
rw [← @of_real_inj 𝕜, im_eq_conj_sub] <;> simp [inner_conj_sym]
rw [← inner_conj_sym, inner_add_left, RingHom.map_add] <;> simp only [inner_conj_sym]
simp only [of_real_re] <;> rfl
simp only [inner_self_nonneg_im, of_real_im]
rw [← inner_conj_sym, conj_re]
rw [← inner_conj_sym, conj_im]
rw [← inner_conj_sym, inner_smul_left] <;> simp only [conj_conj, inner_conj_sym, RingHom.map_mul]
rw [← zero_smul 𝕜 (0 : F), inner_smul_left] <;> simp only [zero_mul, RingHom.map_zero]
rw [← inner_conj_sym, inner_zero_left] <;> simp only [RingHom.map_zero]
rw [← inner_conj_sym, abs_conj]
rw [← neg_one_smul 𝕜 x, inner_smul_left]
simp
rw [← inner_conj_sym, inner_neg_left] <;> simp only [RingHom.map_neg, inner_conj_sym]
simp [sub_eq_add_neg, inner_add_left, inner_neg_left]
simp [sub_eq_add_neg, inner_add_right, inner_neg_right]
rw [← inner_conj_sym, mul_comm]
exact re_eq_abs_of_mul_conj (inner y x)
rw [inner_self_eq_zero] at h <;> exact hy h
    set T
rw [div_mul_eq_div_mul_one_div, div_self hy', one_mul]
simp only [inner_self_re_to_K]
simp only [H, zero_re']
simp only [inner_self_nonneg_im, AddMonoidHom.map_zero]
simp only [inner_sub_sub_self, inner_smul_left, inner_smul_right, h₁, h₂, neg_mul,
            AddMonoidHom.map_add, mul_re, conj_im, AddMonoidHom.map_sub, mul_neg, conj_re, neg_neg]
simp only [inner_smul_left, inner_smul_right, mul_assoc]
rw [← mul_div_right_comm]
rw [div_re_of_real]
rw [inner_mul_conj_re_abs]
rw [IsROrC.abs_mul]
simp only [sqrt_zero, inner_zero_right, map_zero]
simp only [inner_neg_left, neg_neg, inner_neg_right]
simp [hx]
simp [inner_self_im_zero]
rw [norm_eq_sqrt_inner, inner_smul_left, inner_smul_right, ← mul_assoc]
rw [conj_mul_eq_norm_sq_left, of_real_mul_re, sqrt_mul, ← inner_norm_sq_eq_inner_self,
      of_real_re]
· simp [sqrt_norm_sq_eq_norm, IsROrC.sqrt_norm_sq_eq_norm]
· exact norm_sq_nonneg r
simp [← inner_conj_sym, h]
simp [← inner_conj_sym, h]
rw [← @of_real_inj 𝕜, im_eq_conj_sub] <;> simp
rw [← inner_conj_sym, inner_add_left, RingHom.map_add]
simp only [inner_conj_sym]
rw [← inner_conj_sym, conj_re]
rw [← inner_conj_sym, conj_im]
rw [inner_smul_left, conj_of_real, Algebra.smul_def]
rfl
rw [← inner_conj_sym, inner_smul_left, RingHom.map_mul, conj_conj, inner_conj_sym]
rw [inner_smul_right, Algebra.smul_def]
rfl
simp (config := { contextual := true }) [Dfinsupp.sum, sum_inner]
simp (config := { contextual := true }) [Dfinsupp.sum, inner_sum]
rw [← zero_smul 𝕜 (0 : E), inner_smul_left, RingHom.map_zero, zero_mul]
simp only [inner_zero_left, AddMonoidHom.map_zero]
rw [← inner_conj_sym, inner_zero_left, RingHom.map_zero]
simp only [inner_zero_right, AddMonoidHom.map_zero]
rw [← norm_sq_eq_inner] <;> exact pow_nonneg (norm_nonneg x) 2
rw [IsROrC.ext_iff] at h <;> simp only [h.1, zero_re']
simp [H₂]
simp [inner_self_nonneg_im]
simp
simp [inner_self_nonneg_im]
rw [← inner_self_re_abs]
exact inner_self_re_to_K
rw [← inner_conj_sym, abs_conj]
rw [← neg_one_smul 𝕜 x, inner_smul_left]
simp
rw [← inner_conj_sym, inner_neg_left] <;> simp only [RingHom.map_neg, inner_conj_sym]
simp
rw [conj_re]
rw [conj_im, inner_self_im_zero, neg_zero]
simp [sub_eq_add_neg, inner_add_left]
simp [sub_eq_add_neg, inner_add_right]
rw [← inner_conj_sym, mul_comm]
exact re_eq_abs_of_mul_conj (inner y x)
rw [← inner_conj_sym] <;> rfl
rw [← inner_conj_sym] <;> rfl
rw [← sub_eq_zero, ← inner_self_eq_zero, inner_sub_right, sub_eq_zero, h (x - y)]
rw [← sub_eq_zero, ← inner_self_eq_zero, inner_sub_left, sub_eq_zero, h (x - y)]
simp [inner_add_add_self, inner_sub_sub_self, two_mul, sub_eq_add_neg, add_comm, add_left_comm]
rw [inner_self_eq_zero] at h <;> exact hy h
    set T
rw [div_mul_eq_div_mul_one_div, div_self hy', one_mul]
simp
simp only [H, zero_re']
simp only [inner_self_nonneg_im, AddMonoidHom.map_zero]
simp only [inner_sub_sub_self, inner_smul_left, inner_smul_right, h₁, h₂, neg_mul,
            AddMonoidHom.map_add, conj_im, AddMonoidHom.map_sub, mul_neg, conj_re, neg_neg, mul_re]
simp only [inner_smul_left, inner_smul_right, mul_assoc]
rw [← mul_div_right_comm]
rw [div_re_of_real]
rw [inner_mul_conj_re_abs]
rw [IsROrC.abs_mul]
rw [← inner_conj_sym] <;> rfl
simp [norm_sq_eq_inner, h i i]
rw [← inner_conj_sym, hv.inner_right_finsupp]
simp [Finsupp.total_apply _ l₁, Finsupp.sum_inner, hv.inner_right_finsupp]
simp [Finsupp.total_apply _ l₂, Finsupp.inner_sum, hv.inner_left_finsupp, mul_comm]
rw [hl]
rw [Finsupp.mem_supported'] at hl
simp [hv.inner_left_finsupp, hl i hi]
rw [pow_two, inner_self_eq_norm_mul_norm]
rw [pow_two, real_inner_self_eq_norm_mul_norm]
simp
rw [inner_conj_sym]
rw [conj_re]
simp only [← inner_self_eq_norm_mul_norm]
rw [← re.map_add, parallelogram_law, two_mul, two_mul]
simp only [re.map_add]
rw [dist_eq_norm, sqrt_sq (norm_nonneg _)]
rw [sqrt_mul (sq_nonneg _), sqrt_sq (norm_nonneg _),
        sqrt_sq (div_nonneg (sq_nonneg _) (mul_nonneg (norm_nonneg _) (norm_nonneg _))),
        dist_eq_norm]
rw [← sub_eq_zero, ← inner_map_self_eq_zero]
refine' forall_congr' fun x => _
rw [LinearMap.sub_apply, inner_sub_left, sub_eq_zero]
simp [inner_eq_sum_norm_sq_div_four, ← f.norm_map]
simp only [norm_eq_sqrt_inner, h]
rw [← v.total_repr x, ← v.total_repr y, Finsupp.apply_total, Finsupp.apply_total,
      hv.inner_finsupp_eq_sum_left, hf.inner_finsupp_eq_sum_left]
rw [← LinearEquiv.coe_coe] at hf
rw [← v.total_repr x, ← v.total_repr y, ← LinearEquiv.coe_coe, Finsupp.apply_total,
      Finsupp.apply_total, hv.inner_finsupp_eq_sum_left, hf.inner_finsupp_eq_sum_left]
simp
simp
simp
rw [← norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero, eq_comm,
    sqrt_eq_iff_mul_self_eq (add_nonneg (mul_self_nonneg _) (mul_self_nonneg _)) (norm_nonneg _)]
rw [norm_add_mul_self, add_right_cancel_iff, add_right_eq_self, mul_eq_zero]
apply Or.inr
simp only [h, zero_re']
rw [← norm_sub_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero, eq_comm,
    sqrt_eq_iff_mul_self_eq (add_nonneg (mul_self_nonneg _) (mul_self_nonneg _)) (norm_nonneg _)]
rw [← mul_self_inj_of_nonneg (norm_nonneg _) (norm_nonneg _)]
simp [h, ← inner_self_eq_norm_mul_norm, inner_add_left, inner_add_right, inner_sub_left,
    inner_sub_right, inner_re_symm]
rw [_root_.abs_div]
rw [real_inner_smul_left, ← real_inner_self_eq_norm_mul_norm]
rw [inner_smul_right, ← real_inner_self_eq_norm_mul_norm]
simp [norm_eq_zero, hx]
simp [IsROrC.abs_eq_zero, hr]
rw [← abs_to_real]
exact abs_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul hx hr
rw [eq_of_div_eq_one h]
rw [inner_smul_right, ← inner_conj_sym, ht0]
simp
simp [norm_eq_zero, hx0]
simp [norm_eq_zero, hy0]
simp [hx0', hy0']
simp [norm_sub_eq_zero_iff]
simp only [norm_inner_le_norm, one_mul, innerₛₗ_apply]
rw [← IsROrC.norm_eq_abs]
rfl
simp only [← algebra_map_smul 𝕜 r x, algebra_map_eq_of_real, inner_smul_real_left]
simp only [← algebra_map_smul 𝕜 r y, algebra_map_eq_of_real, inner_smul_real_right]
rw [one_mul]
exact norm_inner_le_norm x y
refine' tsum_le_of_sum_le' _ fun s => hv.sum_inner_products_le x
simp only [norm_nonneg, pow_nonneg]
unfold inner
rw [mul_comm, mul_conj, of_real_re, norm_sq_eq_def']
simp [mul_comm]
simp [inner, add_mul]
simp [inner, mul_assoc]
simp [inner_smul_left, inner_smul_right, hv.2 hij]
rw [inner_sum]
simp
simp [sum_inner, inner_sum]
congr
simp [Finset.sum_ite_of_true]
simp [← inner_self_eq_norm_sq_to_K, hV.inner_sum]
rw [← hV.norm_sq_diff_sum, sq_lt_sq, _root_.abs_of_nonneg (sqrt_nonneg _),
          _root_.abs_of_nonneg (norm_nonneg _)]
exact H s₁ hs₁ s₂ hs₂
simp [hv]
change re
change re
simp [real_inner_eq_re_inner, inner_smul_right]
rw [← Complex.inner, f.inner_map_map]
rw [inner_add_right, hx u hu, hy u hu, add_zero]
rw [inner_smul_right, hx u hu, mul_zero]
rw [inner_eq_zero_sym] <;> exact Submodule.inner_right_of_mem_orthogonal hu hv
rw [Submodule.mem_orthogonal_singleton_iff_inner_right, inner_eq_zero_sym]
rw [Submodule.mem_orthogonal']
intro u hu
rw [inner_sub_left, sub_eq_zero]
exact h ⟨u, hu⟩
intro u hu
rw [inner_sub_right, sub_eq_zero]
exact h ⟨u, hu⟩
rw [Submodule.eq_bot_iff]
intro x
rw [Submodule.mem_inf]
exact fun ⟨hx, ho⟩ => inner_self_eq_zero.1 (ho x hx)
simp [disjoint_iff, K.inf_orthogonal_eq_bot]
rw [← Submodule.top_orthogonal_eq_bot, eq_top_iff]
exact Submodule.le_orthogonal_orthogonal
simp only [norm_coe, inner_coe, inner_self_eq_norm_sq]
simp only [inner_coe, inner_conj_sym]
simp only [← coe_add, inner_coe, inner_add_left]
simp only [← coe_smul c a, inner_coe, inner_smul_left]
simp only [norm_sq_eq_inner]
congr
congr
simp only [inner_conj_sym]
congr
simp only [inner_add_left, Pi.add_apply, coe_fn_add]
congr
simp only [inner_smul_left]
simp only [tsum_add (hV.summable_of_lp f) (hV.summable_of_lp g), lp.coe_fn_add, Pi.add_apply,
      LinearIsometry.map_add]
exact Real.rpow_left_inj_on H.ne' (norm_nonneg _) (norm_nonneg _) this
rw [← LinearIsometry.coe_to_linear_map]
exact
        linear_map.range_eq_top.mp
          (eq_top_iff.mpr <| hVtotal.trans_eq hVortho.range_linear_isometry.symm)
simp [IsHilbertSum.linearIsometryEquiv, OrthogonalFamily.linear_isometry_apply]
simp [IsHilbertSum.linearIsometryEquiv, OrthogonalFamily.has_sum_linear_isometry]
simp [IsHilbertSum.linearIsometryEquiv, OrthogonalFamily.linear_isometry_apply_single]
simp [IsHilbertSum.linearIsometryEquiv,
    OrthogonalFamily.linear_isometry_apply_dfinsupp_sum_single]
intro b
cases b <;> first |exact orthogonal.complete_space K|assumption
rw [← b.repr_symm_single, LinearIsometryEquiv.apply_symm_apply]
rw [← b.repr.inner_map_map (b i) v, b.repr_self, lp.inner_single_left]
simp
rw [orthonormal_iff_ite]
intro i j
rw [← b.repr.inner_map_map (b i) (b j), b.repr_self, b.repr_self, lp.inner_single_left,
    lp.single_apply]
simp
rw [IsHilbertSum.linear_isometry_equiv_symm_apply_single, LinearIsometry.to_span_singleton_apply,
    one_smul]
apply funext <| Orthonormal.linear_isometry_equiv_symm_apply_single_one hv hsp
rw [← orthogonal_orthogonal_eq_closure, ← eq_top_iff, orthogonal_eq_top_iff, hsp]
simp only [PiLp.norm_sq_eq_of_L2, AddMonoidHom.map_sum, ← norm_sq_eq_inner, one_div]
simp only [inner_add_left, Finset.sum_add_distrib]
simp only [Finset.mul_sum, inner_smul_left]
infer_instance
infer_instance
simp
simp
exact this (e₁.symm w)
    intro v
    simp [e₂, DirectSum.coeLinearMap, DirectSum.toModule, Dfinsupp.sum_add_hom_apply]
rw [EuclideanSpace.single, PiLp.equiv_symm_apply, ← Pi.single_apply i a j]
simp [apply_ite conj]
simp [apply_ite conj, mul_comm]
rw [← b.repr_symm_single i, LinearIsometryEquiv.apply_symm_apply]
rw [← Basis.equiv_fun_apply, OrthonormalBasis.coe_to_basis_repr,
    LinearIsometryEquiv.coe_to_linear_equiv]
simp [sum_inner, inner_smul_left, hv.inner_right_fintype]
simp [Basis.toOrthonormalBasis, OrthonormalBasis.toBasis]
simp
rw [Finset.coe_image, image_eq_range]
rfl
simp only [OrthonormalBasis.span, Basis.span_apply, LinearIsometryEquiv.of_eq_symm,
    OrthonormalBasis.map_apply, OrthonormalBasis.coe_mk, LinearIsometryEquiv.coe_of_eq_apply]
simp [Complex.orthonormalBasisOneI]
simp [Complex.isometryOfOrthonormal, LinearIsometryEquiv.trans_assoc, OrthonormalBasis.map]
simp [Complex.isometryOfOrthonormal]
simp [Complex.isometryOfOrthonormal, ← v.sum_repr_symm]
simp
simp [DirectSum.IsInternal.collectedOrthonormalBasis]
refine' card_ι.symm.trans _
exact FiniteDimensional.finrank_eq_card_finset_basis b₀.to_basis
rw [Set.inj_on_iff_injective]
exact hsv
let b := Classical.choose (Classical.choose_spec <| exists_orthonormal_basis 𝕜 E)
rw [finrank_eq_card_basis b.to_basis]
exact b.reindex (Fintype.equivFinOfCardEq rfl)
let d := finrank 𝕜 S
simp only [← LS.finrank_add_finrank_orthogonal, add_tsub_cancel_left]
simp only [LinearMap.finrank_range_of_inj L.injective]
simp only [← S.finrank_add_finrank_orthogonal, add_tsub_cancel_left]
simp only [LinearMap.add_apply, LinearMap.comp_apply, LinearMap.comp_apply,
        LinearIsometry.coe_to_linear_map]
    -- Mx_decomp is the orthogonal decomposition of M x
simp only [inner, Matrix.mul_apply, star_ring_end_apply, Matrix.conj_transpose_apply, mul_comm]
rw [(hf.has_fderiv_at.inner hg.has_fderiv_at).fderiv]
rfl
simp only [sq, ← inner_self_eq_norm_mul_norm]
exact (re_clm : 𝕜 →L[ℝ] ℝ).ContDiff.comp (cont_diff_id.inner contDiffId)
simp only [dist_eq_norm]
exact (hf.sub hg).norm (sub_ne_zero.2 hne)
simp only [dist_eq_norm]
exact (hf.sub hg).norm (sub_ne_zero.2 hne)
simp only [dist_eq_norm]
exact (hf.sub hg).norm (sub_ne_zero.2 hne)
simp only [dist_eq_norm]
exact (hf.sub hg).norm (sub_ne_zero.2 hne)
rw [← (EuclideanSpace.equiv ι 𝕜).comp_differentiable_within_at_iff, differentiable_within_at_pi]
rfl
rw [← (EuclideanSpace.equiv ι 𝕜).comp_differentiable_at_iff, differentiable_at_pi]
rfl
rw [← (EuclideanSpace.equiv ι 𝕜).comp_differentiable_on_iff, differentiable_on_pi]
rfl
rw [← (EuclideanSpace.equiv ι 𝕜).comp_differentiable_iff, differentiable_pi]
rfl
rw [← (EuclideanSpace.equiv ι 𝕜).comp_has_strict_fderiv_at_iff, has_strict_fderiv_at_pi']
rfl
rw [← (EuclideanSpace.equiv ι 𝕜).comp_has_fderiv_within_at_iff, has_fderiv_within_at_pi']
rfl
rw [← (EuclideanSpace.equiv ι 𝕜).comp_cont_diff_within_at_iff, cont_diff_within_at_pi]
rfl
rw [← (EuclideanSpace.equiv ι 𝕜).comp_cont_diff_at_iff, cont_diff_at_pi]
rfl
rw [← (EuclideanSpace.equiv ι 𝕜).comp_cont_diff_on_iff, cont_diff_on_pi]
rfl
rw [← (EuclideanSpace.equiv ι 𝕜).comp_cont_diff_iff, cont_diff_pi]
rfl
exact this.smul contDiffId
rw [eventually_eq_iff_exists_mem]
refine'
      ⟨ball (0 : E) 1, mem_nhds_iff.mpr ⟨ball (0 : E) 1, Set.Subset.refl _, is_open_ball, hy⟩,
        fun z hz => _⟩
rw [h z hz]
rfl
exact this.smul contDiffAtId
rw [← Submodule.infi_orthogonal] at hv⊢
exact T.infi_invariant hT.invariant_orthogonal_eigenspace v hv
rw [supr_ne_bot_subtype, hT.orthogonal_supr_eigenspaces_eq_bot]
rw [← IsROrC.eq_conj_iff_re]
exact hT.conj_eigenvalue_eq_self (has_eigenvalue_of_has_eigenvector key)
simp only [mem_eigenspace_iff.mp h, inner_smul_right, inner_self_eq_norm_sq_to_K]
simp [hc]
simp [hx]
simp [hx]
simp [c, hx, hr.ne']
simp only [← @Sup_image' _ _ _ _ rayleigh_quotient,
      T.image_rayleigh_eq_image_rayleigh_sphere hr]
simp only [← @Inf_image' _ _ _ _ rayleigh_quotient,
      T.image_rayleigh_eq_image_rayleigh_sphere hr]
simp [hx₀]
refine' ⟨_, hx₀⟩
rw [Module.EndCat.mem_eigenspace_iff]
exact hT.eq_smul_self_of_is_local_extr_on hextr
simp [hx₀]
simp
simp [hx₀]
simp
simp
simp only [hx₀, norm_eq_zero, hx, Ne.def, not_false_iff]
simp
simp only [hx₀, norm_eq_zero, hx, Ne.def, not_false_iff]
rw [to_euclidean.image_symm_eq_preimage, closed_ball_eq_preimage]
rw [closed_ball_eq_image]
exact (is_compact_closed_ball _ _).image to_euclidean.symm.continuous
rw [ball_eq_preimage, ← to_euclidean.preimage_closure, closure_ball (toEuclidean x) h,
    closed_ball_eq_preimage]
rw [to_euclidean.to_homeomorph.nhds_eq_comap]
exact metric.nhds_basis_closed_ball.comap _
rw [to_euclidean.to_homeomorph.nhds_eq_comap]
exact metric.nhds_basis_ball.comap _
rw [Ennreal.tsum_eq_supr_nat' (Nat.tendsto_pow_at_top_at_top_of_one_lt _root_.one_lt_two)]
refine' supr_le fun n => (Finset.le_sum_condensed hf n).trans (add_le_add_left _ _)
simp only [nsmul_eq_mul, Nat.cast_pow, Nat.cast_two]
apply Ennreal.sum_le_tsum
simp
simp only [← rpow_nat_cast, Real.summable_nat_rpow_inv, Nat.one_lt_cast]
simp
simp [← Nnreal.summable_coe]
simp [← Nnreal.summable_coe]
simp
apply sum_le_sum_of_subset_of_nonneg
· intro x hx
        simp only [mem_Ioo] at hx
        simp only [hx, hx.2.le, mem_Ioc, le_max_iff, or_true_iff, and_self_iff]
· intro i hi hident
        exact inv_nonneg.2 (sq_nonneg _)
refine' add_le_add le_rfl ((sum_Ioc_inv_sq_le_sub _ (le_max_left _ _)).trans _)
· simp only [Ne.def, Nat.succ_ne_zero, not_false_iff]
· simp only [Nat.cast_succ, one_div, sub_le_self_iff, inv_nonneg, Nat.cast_nonneg]
simp only [le_add_iff_nonneg_left, Nat.cast_nonneg]
rw [← zero_smul 𝕜 (0 : E), smul, norm_zero, zero_mul]
rw [← neg_one_smul 𝕜, smul, norm_neg, ← smul, one_smul]
refine' le_antisymm (smul_le r x) _
cases f <;> cases g <;> congr
simp only [← smul_one_smul ℝ≥0 r (_ : ℝ), Nnreal.smul_def, smul_eq_mul]
rw [map_smul_eq_mul, mul_left_comm]
simp only [map_smul_eq_mul, map_smul_eq_mul, mul_add]
rw [map_smulₛₗ, map_smul_eq_mul, RingHomIsometric.is_iso]
rw [comp_apply, smul_apply, LinearMap.smul_apply, map_smul_eq_mul, Nnreal.smul_def, coe_nnnorm,
      smul_eq_mul, comp_apply]
simp only [sub_self, map_zero, add_zero]
simp only [sub_self, map_zero, zero_add, sub_zero]
rw [supr_apply, ← @Real.csupr_const_zero s]
trace
            "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr «expr⨆ , »((i), _)]]"
exact map_zero i.1
simp only [supr_apply]
trace
            "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr «expr⨆ , »((i), _)]]"
exact i.1.neg' _
simp only [supr_apply]
rw [← smul_eq_mul,
            Real.smul_supr_of_nonneg (norm_nonneg a) fun i : s => (i : Seminorm 𝕜 E) x]
trace
            "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr «expr⨆ , »((i), _)]]"
exact i.1.smul' a x
rw [← Sup_range, Seminorm.coe_Sup_eq hp] <;> exact supr_range' (coeFn : Seminorm 𝕜 E → E → ℝ) p
simp [hr]
simp [hr]
rw [mem_ball, sub_zero]
rw [mem_closed_ball, sub_zero]
rw [Set.eq_univ_iff_forall, ball]
simp [hr]
rw [ball_zero_eq, preimage_metric_ball]
rw [closed_ball_zero_eq, preimage_metric_closed_ball]
rw [Finset.inf_eq_infi]
exact ball_finset_sup_eq_Inter _ _ _ hr
rw [Finset.inf_eq_infi]
exact closed_ball_finset_sup_eq_Inter _ _ _ hr
refine' (p.absorbent_ball_zero <| sub_pos.2 hpr).Subset fun y hy => _
rw [p.mem_ball_zero] at hy
exact p.mem_ball.2 ((map_sub_le_add p _ _).trans_lt <| add_lt_of_lt_sub_right hy)
refine' (p.absorbent_closed_ball_zero <| sub_pos.2 hpr).Subset fun y hy => _
rw [p.mem_closed_ball_zero] at hy
exact p.mem_closed_ball.2 ((map_sub_le_add p _ _).trans <| add_le_of_le_sub_right hy)
rw [norm_neg, norm_one]
rw [neg_smul, one_smul]
rw [mem_preimage, mem_ball, mem_ball, lt_div_iff (norm_pos_iff.mpr ha), mul_comm, ←
      map_smul_eq_mul p, smul_sub, smul_inv_smul₀ ha]
rw [← map_smul_eq_mul p, ← map_smul_eq_mul p, smul_one_smul, smul_one_smul]
rw [norm_smul, norm_smul, norm_one, mul_one, mul_one, Real.norm_of_nonneg ha,
        Real.norm_of_nonneg hb]
rw [closed_ball_eq_bInter_ball]
exact convex_Inter₂ fun _ _ => convex_ball _ _ _
rw [← smul_one_smul 𝕜' a x, p.smul', norm_smul, norm_one, mul_one]
have hp : Filter.Tendsto p (𝓝 0) (𝓝 0) := map_zero p ▸ hp
rw [UniformContinuous, uniformity_eq_comap_nhds_zero_swapped,
    Metric.uniformity_eq_comap_nhds_zero, Filter.tendsto_comap_iff]
exact
    tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds (hp.comp Filter.tendsto_comap)
      (fun xy => dist_nonneg) fun xy => p.norm_sub_map_le_sub _ _
refine'
    Seminorm.continuous
      (Filter.mem_of_superset (IsOpen.mem_nhds _ <| q.mem_ball_self zero_lt_one)
        (ball_antitone hpq))
rw [ball_zero_eq]
exact is_open_lt hq continuous_const
rw [← ball_norm_seminorm 𝕜]
exact (normSeminorm _ _).absorbentBallZero hr
rw [← ball_norm_seminorm 𝕜]
exact (normSeminorm _ _).absorbentBall hx
rw [← ball_norm_seminorm 𝕜]
exact (normSeminorm _ _).balancedBallZero r
simp
rw [split_lower, mk'_eq_bot, exists_update_iff I.upper fun j y => y ≤ I.lower j]
simp [(I.lower_lt_upper _).not_le]
simp [split_lower, update_eq_iff]
simp
rw [split_upper, mk'_eq_bot, exists_update_iff I.lower fun j y => I.upper j ≤ y]
simp [(I.lower_lt_upper _).not_le]
simp [split_upper, update_eq_iff]
simp only [split_upper, mk'_eq_coe, max_eq_left h.1.le]
refine' ⟨_, rfl⟩
congr
rw [← disjoint_with_bot_coe, coe_split_lower, coe_split_upper]
refine' (Disjoint.inf_left' _ _).inf_right' _
rw [Set.disjoint_left]
exact fun y (hle : y i ≤ x) hlt => not_lt_of_le hle hlt
simp [split]
simp [mem_split_iff, ← box.with_bot_coe_inj]
simp [split, ← inter_union_distrib_left, ← set_of_or, le_or_lt]
rw [split, sum_of_with_bot, Finset.sum_pair (I.split_lower_ne_split_upper i x)]
rw [← box.mem_coe, H] at h₂
exact h₃.not_lt h₂.2
rw [← box.mem_coe, H] at h₂
exact h₃.not_le h₂.2
rw [split_many, Finset.inf_insert, inf_comm, split_many]
simp only [split_many_empty, is_partition_top]
dsimp only [compl]
congr 1
rw [h]
rw [← Union_eq_empty, Union_compl, h.Union_eq, diff_self]
simp
simp
simp [Union_def]
simp [prepartition.Union]
simp [← injective_boxes.eq_iff, Finset.ext_iff, prepartition.Union, imp_false]
simp [bUnion]
simp [prepartition.Union]
refine' Finset.sum_bUnion fun J₁ h₁ J₂ h₂ hne => Finset.disjoint_left.2 fun J' h₁' h₂' => _
exact hne (π.eq_of_le_of_le h₁ h₂ ((πi J₁).le_of_mem h₁') ((πi J₂).le_of_mem h₂'))
rw [bUnion_index, dif_pos hJ]
exact (π.mem_bUnion.1 hJ).some_spec.fst
simp only [mem_coe, mem_erase_none] at h₁ h₂
exact box.disjoint_coe.1 (pairwise_disjoint h₁ h₂ (mt Option.some_inj.1 hne))
simp [restrict, eq_comm]
simp only [mem_restrict, ← box.with_bot_coe_inj, box.coe_inf, box.coe_coe]
simp only [restrict, of_with_bot, erase_none_eq_bUnion]
refine' finset.image_bUnion.trans _
refine' (Finset.bUnion_congr rfl _).trans Finset.bUnion_singleton_eq_self
intro J' hJ'
rw [inf_of_le_right, ← WithBot.some_eq_coe, Option.to_finset_some]
exact WithBot.coe_le_coe.2 ((π.le_of_mem hJ').trans h)
simp [restrict, ← inter_Union, ← Union_def]
simp only [inf_def, mem_bUnion, mem_restrict]
simp only [inf_def, Union_bUnion, Union_restrict, ← Union_inter, ← Union_def]
simp [disj_union, prepartition.Union, Union_or, Union_union_distrib]
simp [is_partition_iff_Union_eq]
simp [h.Union_eq, hJ]
simp [h₁.Union_eq, h₂.Union_eq]
simp [h, π₁.Union_subset]
simp only [bex_imp, mem_bUnion_tagged]
refine' ⟨fun H J hJ J' hJ' => _, fun H J' J hJ hJ' => _⟩
· rw [← π.tag_bUnion_tagged hJ hJ']
    exact H J' J hJ hJ'
· rw [π.tag_bUnion_tagged hJ hJ']
    exact H J hJ J' hJ'
simp only [← mem_to_prepartition, inf_prepartition_to_prepartition, inf_comm]
simp
refine' fun J hJ => (Finset.mem_union.1 hJ).elim (fun hJ => _) fun hJ => _
· rw [disj_union_tag_of_mem_left _ hJ]
    exact h₁ _ hJ
· rw [disj_union_tag_of_mem_right _ hJ]
    exact h₂ _ hJ
refine' fun J hJ => (Finset.mem_union.1 hJ).elim (fun hJ => _) fun hJ => _
· rw [disj_union_tag_of_mem_left _ hJ]
    exact h₁ _ hJ
· rw [disj_union_tag_of_mem_right _ hJ]
    exact h₂ _ hJ
rw [coe_eq_pi]
exact MeasurableSet.univPi fun i => measurableSetIoc
rw [coe_eq_pi]
exact measure.univ_pi_Ioc_ae_eq_Icc
rw [← π.measure_Union_to_real, hπ.Union_eq]
rw [measure.to_box_additive_apply, coe_eq_pi, Real.volume_pi_Ioc_to_real I.lower_le_upper]
simp only [face_lower, face_upper, (· ∘ ·), Fin.prod_univ_succ_above _ i, mul_comm]
decide
decide
simp [r_cond, hl]
simp
refine'
    ⟨tagged_prepartition.is_subordinate_bUnion_tagged.2 fun J hJ => (h J hJ).1, fun hH =>
      tagged_prepartition.is_Henstock_bUnion_tagged.2 fun J hJ => (h J hJ).2 hH, fun hD => _,
      fun hD => _⟩
· rw [prepartition.distortion_bUnion_tagged, Finset.sup_le_iff]
    exact fun J hJ => (h J hJ).3 hD
· refine' ⟨_, _, hc hD⟩
    rw [π.Union_compl, ← π.Union_bUnion_partition hp]
    rfl
simp only [to_filter_Union, to_filter_distortion_Union, h]
simp
simp [I.split_center_box_le]
simp [split_center]
simp [hx]
simp [union_compl_to_subordinate]
simp only [Pi.add_apply, sum_add_distrib, sum_partition_boxes _ hI hπ]
simp only [Pi.smul_apply, ← smul_sum, sum_partition_boxes _ hI hπ]
rw [← f.sum_partition_boxes hI (is_partition_split I i x), sum_split_boxes]
rw [← g.map_sum, f.sum_partition_boxes hI hπ]
rw [h₁, h₂]
erw [Option.isSome]
simp
erw [Option.isSome]
simp [I.nonempty_coe]
induction I using WithBot.recBotCoe <;> simp [WithBot.coe_eq_coe]
induction I using WithBot.recBotCoe
· simp
induction J using WithBot.recBotCoe
· simp [subset_empty_iff]
simp
simp only [subset.antisymm_iff, ← le_antisymm_iff, with_bot_coe_subset_iff]
induction I using WithBot.recBotCoe
· change ∅ = _
    simp
induction J using WithBot.recBotCoe
· change ∅ = _
    simp
change ↑(mk' _ _) = _
simp only [coe_eq_pi, ← pi_inter_distrib, Ioc_inter_Ioc, Pi.sup_apply, Pi.inf_apply, coe_mk',
    coe_coe]
rw [← with_bot_coe_subset_iff, coe_inf]
exact inter_subset_left _ _
rw [← with_bot_coe_subset_iff, coe_inf]
exact inter_subset_right _ _
simp only [← with_bot_coe_subset_iff, coe_inf] at *
exact subset_inter h₁ h₂
simp only [disjoint_iff_inf_le, ← with_bot_coe_subset_iff, coe_inf]
rfl
rw [disjoint_coe, Set.not_disjoint_iff_nonempty_inter]
simp only [distortion, nndist_pi_def, Real.nndist_eq', h, map_div₀]
congr 1
refine'
    (π.sum_bUnion_boxes _ _).trans ((sum_congr rfl) fun J hJ => (sum_congr rfl) fun J' hJ' => _)
rw [π.tag_bUnion_tagged hJ hJ']
rw [prepartition.bUnion_index_of_mem _ hJ hJ']
rw [← integral_sum_inf_partition f vol π₁ h₂, ← integral_sum_inf_partition f vol π₂ h₁,
    integral_sum, integral_sum, Finset.sum_sub_distrib]
simp only [inf_prepartition_to_prepartition, _root_.inf_comm]
refine'
    (prepartition.sum_disj_union_boxes h _).trans
      (congr_arg₂ (· + ·) ((sum_congr rfl) fun J hJ => _) ((sum_congr rfl) fun J hJ => _))
· rw [disj_union_tag_of_mem_left _ hJ]
· rw [disj_union_tag_of_mem_right _ hJ]
simp only [integral_sum, Pi.add_apply, (vol _).map_add, Finset.sum_add_distrib]
simp only [integral_sum, Pi.neg_apply, (vol _).map_neg, Finset.sum_neg_distrib]
simp only [integral_sum, Finset.smul_sum, Pi.smul_apply, ContinuousLinearMap.map_smul]
simp [@forall_swap ℝ≥0 (tagged_prepartition I)]
rw [integrable_iff_cauchy, cauchy_map_iff',
    (l.has_basis_to_filter_Union_top _).prod_self.tendsto_iff uniformity_basis_dist_le]
refine' forall₂_congr fun ε ε0 => exists_congr fun r => _
simp only [exists_prop, Prod.forall, Set.mem_Union, exists_imp, prod_mk_mem_set_prod_eq, and_imp,
    mem_inter_iff, mem_set_of_eq]
exact
    and_congr Iff.rfl
      ⟨fun H c₁ c₂ π₁ π₂ h₁ hU₁ h₂ hU₂ => H π₁ π₂ c₁ h₁ hU₁ c₂ h₂ hU₂,
        fun H π₁ π₂ c₁ h₁ hU₁ c₂ h₂ hU₂ => H c₁ c₂ π₁ π₂ h₁ hU₁ h₂ hU₂⟩
rw [integral, dif_pos h]
exact Classical.choose_spec h
rw [integral, integral, dif_neg h, dif_neg (mt integrable.of_neg h), neg_zero]
rw [convergence_r, dif_pos h₀] at hπ
exact (has_integral_iff.1 h.has_integral ε h₀).some_spec.2 c _ hπ hπp
refine' ⟨inferInstance, _⟩
rw [prod_map_map_eq, ← to_filter_inf_Union_eq, ← prod_inf_prod, prod_principal_principal]
exact
    h.tendsto_integral_sum_to_filter_prod_self_inf_Union_eq_uniformity.mono_left
      (inf_le_inf_left _ <| principal_mono.2 fun π h => h.1.trans h.2.symm)
refine' hC.mono J le_rfl le_rfl fun x hx => _
exact min_le_right _ _
refine' hC.mono J le_rfl le_rfl fun x hx => _
exact min_le_left _ _
refine' tendsto_nhds_unique (h.tendsto_integral_sum_sum_integral π₁) _
rw [l.to_filter_Union_congr _ hU]
exact h.tendsto_integral_sum_sum_integral π₂
intro J hJ
have : 0 ≤ μ.to_box_additive J := Ennreal.to_real_nonneg
rw [norm_smul, Real.norm_eq_abs, abs_of_nonneg this, ← dist_eq_norm]
refine' mul_le_mul_of_nonneg_left _ this
refine' Hδ _ (tagged_prepartition.tag_mem_Icc _ _) _ (tagged_prepartition.tag_mem_Icc _ _) _
rw [← add_halves δ]
refine' (dist_triangle_left _ _ J.upper).trans (add_le_add (h₁.1 _ _ _) (h₂.1 _ _ _))
· exact prepartition.bUnion_index_mem _ hJ
· exact box.le_iff_Icc.1 (prepartition.le_bUnion_index _ hJ) J.upper_mem_Icc
· rw [_root_.inf_comm] at hJ
      exact prepartition.bUnion_index_mem _ hJ
· rw [_root_.inf_comm] at hJ
      exact box.le_iff_Icc.1 (prepartition.le_bUnion_index _ hJ) J.upper_mem_Icc
decide
decide
refine' has_integral_of_mul
intro x
simp [N]
intro J hJ
rw [tagged_prepartition.mem_filter] at hJ
rw [norm_smul, Real.norm_eq_abs, abs_of_nonneg Ennreal.to_real_nonneg]
exact mul_le_mul_of_nonneg_left (hJ.2 ▸ Nat.le_ceil _) Ennreal.to_real_nonneg
simp
simp
intro x m n hmn
rw [← dist_eq_norm, ← dist_eq_norm, dist_nndist, dist_nndist, Nnreal.coe_le_coe, ←
      Ennreal.coe_le_coe, ← edist_nndist, ← edist_nndist]
exact simple_func.edist_approx_on_mono hg.measurable _ x hmn
  /- Now consider `ε > 0`. We need to find `r` such that for any tagged partition subordinate
    to `r`, the integral sum is `(μ I + 1 + 1) * ε`-close to the Bochner integral. -/
simp
simp [hg]
rw [← integral_sub (Hi _ Hu) (Hi _ Hl), ← box.volume_face_mul i, mul_smul, ← box.volume_apply,
        ← box_additive_map.to_smul_apply, ← integral_const, ← box_additive_map.volume, ←
        integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
simp only [(· ∘ ·), Pi.sub_def, ← f'.map_smul, ← Pi.single_smul', smul_eq_mul, mul_one]
refine' norm_integral_le_of_le_const (fun y hy => (this y hy).trans _) volume
rw [mul_assoc (2 * ε)]
exact
        mul_le_mul_of_nonneg_left (I.diam_Icc_le_of_distortion_le i hc)
          (mul_nonneg zero_le_two h0.le)
rw [← measure.to_box_additive_apply, box.volume_apply, ← I.volume_face_mul i]
ac_rfl
intro x hx
intro j
calc
          dist (J.upper j) (J.lower j) ≤ dist J.upper J.lower := dist_le_pi_dist _ _ _
          _ ≤ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _
          _ ≤ δ + δ := add_le_add (hJδ J.upper_mem_Icc) (hJδ J.lower_mem_Icc)
          _ = 2 * δ := (two_mul δ).symm
simp
cases p <;> cases q <;> congr
intro a ha b hb hab
simp only [le_tsub_iff_left hmn.le, mem_Iic] at ha hb
exact hu ⟨le_add_right le_rfl, ha⟩ ⟨le_add_right le_rfl, hb⟩ (add_le_add le_rfl hab)
intro i hi
simp only [le_tsub_iff_left hmn.le, mem_Iic] at hi
exact us _ ⟨le_add_right le_rfl, hi⟩
apply Finset.sum_congr rfl fun i hi => _
simp only [v, add_assoc]
rw [← Ennreal.of_real_le_of_real_iff Ennreal.to_real_nonneg, Ennreal.of_real_to_real h, ←
    edist_dist]
exact edist_le f hx hy
apply (le_abs_self _).trans
rw [← Real.dist_eq]
exact h.dist_le hx hy
apply Finset.sum_congr rfl fun i hi => _
dsimp only [w]
simp only [← Npos, Nat.not_lt_zero, Nat.add_succ_sub_one, add_zero, if_false,
          add_eq_zero_iff, Nat.one_ne_zero, false_and_iff, Nat.succ_add_sub_one, zero_add]
rw [add_comm 1 i]
rw [Finset.range_eq_Ico]
exact Finset.sum_Ico_add (fun i => edist (f (w (i + 1))) (f (w i))) 0 n 1
apply Finset.sum_le_sum_of_subset _
rw [Finset.range_eq_Ico]
exact Finset.Ico_subset_Ico zero_le_one le_rfl
rw [Finset.sum_Ico_consecutive, Finset.sum_Ico_consecutive, Finset.range_eq_Ico]
· exact zero_le _
· exact hN.1
· exact zero_le _
· exact Nat.pred_le _
rw [← Nat.Ico_succ_singleton, A]
intro i
rw [Finset.range_eq_Ico, Finset.sum_Ico_consecutive _ (zero_le _) hN.le]
apply le_antisymm
· rw [← Nx]
              exact hv hi.2
· exact ht.2 h
apply le_antisymm
· exact hs.2 h
· rw [← Nx]
              exact hv hi.1
apply Finset.sum_congr rfl fun i hi => _
simp only [Finset.mem_range] at hi
rw [edist_dist, Real.dist_eq, abs_of_nonneg]
exact sub_nonneg_of_le (hf (us i).1 (us (i + 1)).1 (hu (Nat.le_succ _)))
rw [Ennreal.of_real_sum_of_nonneg]
intro i hi
exact sub_nonneg_of_le (hf (us i).1 (us (i + 1)).1 (hu (Nat.le_succ _)))
rw [Finset.sum_range_sub fun i => f (u i)]
apply Ennreal.of_real_le_of_real
exact sub_le_sub (hf (us n).1 bs (us n).2.2) (hf as (us 0).1 (us 0).2.1)
simp only [tsub_zero]
rw [Finset.mul_sum]
dsimp [HasBoundedVariationOn] at h
apply ne_of_lt
apply (hf.comp_evariation_on_le hg).trans_lt
simp [lt_top_iff_ne_top, h]
simp [fpq]
intro i
apply ae_differentiable_within_at_of_mem_real
exact LipschitzWith.compHasLocallyBoundedVariationOn (A i) h
simp only [ContinuousLinearEquiv.symm_comp_self, Function.comp.left_id]
rw [ae_restrict_iff' hs]
exact h.ae_differentiable_within_at_of_mem
intro i hi
simp only [hi.ne', Ne.def, Nat.cast_eq_zero, not_false_iff]
rw [mul_comm, Nat.div_add_mod]
rw [hp]
rw [hp]
simp only [Nat.cast_add, Nat.cast_mul]
refine' eventually_at_top.2 ⟨1, fun p hp => _⟩
simp only [I p hp, Ne.def, not_false_iff, field_simps]
refine' div_le_div_of_le_of_nonneg _ (Nat.cast_nonneg _)
rw [mul_comm]
exact A _
have : tendsto (fun p : ℕ => w + x / p) at_top (𝓝 (w + 0)) :=
      tendsto_const_nhds.add (tendsto_const_nhds.div_at_top tendsto_coe_nat_at_top_at_top)
rw [add_zero] at this
exact (tendsto_order.1 this).2 _ wL
simp
have h_le_one : ∀ x : ℝ≥0, x ≤ 1 → x ^ p ≤ x := fun x hx => rpow_le_self_of_le_one hx hp1
have ha : a ≤ 1 := (self_le_add_right a b).trans hab
have hb : b ≤ 1 := (self_le_add_left b a).trans hab
exact (add_le_add (h_le_one a ha) (h_le_one b hb)).trans hab
rw [div_add_div_same, div_self h_zero]
simp [hp_pos, h_nonzero]
simp [lt_of_lt_of_le zero_lt_one hp1]
rw [← Nnreal.rpow_mul, div_eq_inv_mul, ← mul_assoc, _root_.mul_inv_cancel hp_pos.ne.symm,
      one_mul]
simp [hp_pos]
simp [hp_nonneg]
simp [hp_pos, hp_nonneg, hp_not_nonpos, hp_not_neg]
intro h
rw [h, top_rpow_of_pos hp_pos] at h_top_rpow_sum
exact h_top_rpow_sum rfl
rw [coe_finset_sum]
refine' sum_congr rfl fun i hi => (coe_to_nnreal _).symm
refine' (lt_top_of_sum_ne_top _ hi).Ne
exact hw'.symm ▸ Ennreal.one_ne_top
simp [lt_of_lt_of_le zero_lt_one hp1]
rw [← Ennreal.rpow_mul, _root_.mul_div_cancel' _ hp_pos.ne']
induction x using QuotientAddGroup.induction_on'
rw [fourier_apply, to_circle, zero_zsmul, ← QuotientAddGroup.coe_zero, Function.Periodic.lift_coe,
    mul_zero, exp_map_circle_zero, coe_one_unit_sphere]
rw [fourier_apply, one_zsmul]
rw [← fourier_subalgebra_coe]
exact congr_arg Subalgebra.toSubmodule fourier_subalgebra_closure_eq_top
rw [add_comm]
exact sub_ne_zero.mpr (Ne.symm h)
simp
simp [pi_norm_le_iff_of_nonneg hr]
simp [pi_nnnorm_le_iff]
simp [pi_norm_lt_iff hr]
simp [pi_nnnorm_lt_iff hr]
simp [Pi.nnnorm_def]
simp [Pi.nnnorm_def]
infer_instance
infer_instance
infer_instance
simp [Pi.norm_def, PiLp.nnnorm_eq_sum Ennreal.one_ne_top]
rw [linfty_op_nnnorm_def, Pi.nnnorm_def]
simp
simp [linfty_op_nnnorm_def]
simp [Nnreal.coe_sum]
rw [linfty_op_nnnorm_def, Pi.nnnorm_def]
congr 1
rw [← linfty_op_nnnorm_col (A.mul_vec v), ← linfty_op_nnnorm_col v]
exact linfty_op_nnnorm_mul A (col v)
infer_instance
infer_instance
infer_instance
simp [Nnreal.coe_sum]
rw [frobenius_nnnorm_def, frobenius_nnnorm_def, Finset.sum_comm]
rfl
rw [frobenius_norm_def, Fintype.sum_unique, PiLp.norm_eq_of_L2, Real.sqrt_eq_rpow]
simp only [row_apply, Real.rpow_two, PiLp.equiv_symm_apply]
rw [diagonal_apply_ne _ this, nnnorm_zero, Nnreal.zero_rpow two_ne_zero]
refine' mt (fun hxt => _) ht
refine' ⟨_, _, set.neg_mem_neg.mpr (subset_closure hxt), hx, _⟩
rw [neg_sub, sub_add_cancel]
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
simp only [convolution_def, (L _).map_add, Pi.add_apply, integral_add hfg hfg']
simp only [convolution_def, L.map_add₂, Pi.add_apply, integral_add hfg hfg']
intro x h2x
apply continuous_const
refine' eventually_of_forall fun x => eventually_of_forall fun t => _
refine' (L.le_op_norm₂ _ _).trans _
exact
      mul_le_mul_of_nonneg_left (le_csupr hbg <| x - t) (mul_nonneg (norm_nonneg _) (norm_nonneg _))
apply continuous_const
rw [← convolution_flip]
rfl
rw [← integral_neg_eq_self]
simp only [neg_neg, ← sub_eq_add_neg]
rw [← convolution_flip]
exact hcf.continuous_convolution_right L.flip hg hf
rw [← convolution_flip]
exact hbf.continuous_convolution_right_of_integrable L.flip hg hf
rw [← convolution_flip]
exact hcf.continuous_convolution_right_of_integrable L.flip hg hf
intro t
intro t
intro t
exact L.le_op_norm (f t)
intro x' hx'
refine' (dist_triangle_right _ _ _).trans (add_le_add (hgδ hpi _).le hgi.le)
exact ((dist_triangle _ _ _).trans_lt (add_lt_add hx'.out hki)).trans_eq (add_halves δ)
apply hf.convolution_integrand L hg
rw [integral_integral_swap hi]
refine' integral_congr_ae _
refine'
        ((quasi_measure_preserving_sub_left_of_right_invariant ν x₀).ae hgk).mono fun t ht => _
exact (L₃ (f t)).integral_comp_comm ht
refine' L₃.ae_strongly_measurable_comp₂ hf.snd _
refine' L₄.ae_strongly_measurable_comp₂ hg.fst _
refine' (hk.mono' _).compMeasurable ((measurable_const.sub measurableSnd).sub measurableFst)
refine' quasi_measure_preserving.absolutely_continuous _
refine'
      quasi_measure_preserving.prod_of_left ((measurable_const.sub measurableSnd).sub measurableFst)
        (eventually_of_forall fun y => _)
dsimp only
exact quasi_measure_preserving_sub_left_of_right_invariant μ _
simp (config := { singlePass := true }) only [← convolution_flip]
exact hcf.has_fderiv_at_convolution_right L.flip hg hf x₀
rw [← convolution_flip]
exact hcf.cont_diff_convolution_right L.flip hg hf
simp (config := { singlePass := true }) only [← convolution_flip]
exact hcf.has_deriv_at_convolution_right L.flip hg hf x₀
simp [ε_pos]
simp [ε_pos.le, one_le_two]
induction starting
intro n
exact hF n (u n)
congr
refine' @geom_le (ϕ ∘ u) _ zero_le_two (n + 1) fun m hm => _
exact (IH _ <| Nat.lt_add_one_iff.1 hm).2.le
rw [iterated_deriv_within_eq_equiv_comp, ← Function.comp.assoc,
    LinearIsometryEquiv.self_comp_symm, Function.left_id]
rw [iterated_deriv_within_eq_iterated_fderiv_within, ← ContinuousMultilinearMap.map_smul_univ]
simp
simp [iteratedDerivWithin, iterated_fderiv_within_one_apply hs hx]
rfl
simp only [cont_diff_on_iff_continuous_on_differentiable_on hs,
    iterated_fderiv_within_eq_equiv_comp, LinearIsometryEquiv.comp_continuous_on_iff,
    LinearIsometryEquiv.comp_differentiable_on_iff]
rw [iterated_deriv_within_eq_iterated_fderiv_within, iterated_fderiv_within_succ_apply_left,
    iterated_fderiv_within_eq_equiv_comp, LinearIsometryEquiv.comp_fderiv_within _ hxs, derivWithin]
change
    ((ContinuousMultilinearMap.mkPiField 𝕜 (Fin n)
            ((fderivWithin 𝕜 (iteratedDerivWithin n f s) s x : 𝕜 → F) 1) :
          (Fin n → 𝕜) → F)
        fun i : Fin n => 1) =
      (fderivWithin 𝕜 (iteratedDerivWithin n f s) s x : 𝕜 → F) 1
simp
rw [iterated_deriv_within_eq_iterate hxs hx, iterated_deriv_within_eq_iterate hxs hx]
rfl
rw [iterated_deriv_eq_equiv_comp, ← Function.comp.assoc, LinearIsometryEquiv.self_comp_symm,
    Function.left_id]
rw [iterated_deriv_eq_iterated_fderiv, ← ContinuousMultilinearMap.map_smul_univ]
simp
simp only [cont_diff_iff_continuous_differentiable, iterated_fderiv_eq_equiv_comp,
    LinearIsometryEquiv.comp_continuous_iff, LinearIsometryEquiv.comp_differentiable_iff]
rw [iterated_deriv_eq_iterate, iterated_deriv_eq_iterate]
rfl
simp only [interval_integrable_iff, interval_integral_eq_integral_interval_oc, ←
    ae_restrict_iff' measurableSetIntervalOc] at *
have :=
    has_fderiv_at_integral_of_dominated_loc_of_lip ε_pos hF_meas hF_int hF'_meas h_lip
      bound_integrable h_diff
exact ⟨this.1, this.2.const_smul _⟩
simp only [interval_integrable_iff, interval_integral_eq_integral_interval_oc, ←
    ae_restrict_iff' measurableSetIntervalOc] at *
exact
    (hasFderivAtIntegralOfDominatedOfFderivLe ε_pos hF_meas hF_int hF'_meas h_bound bound_integrable
          h_diff).const_smul
      _
simp only [interval_integrable_iff, interval_integral_eq_integral_interval_oc, ←
    ae_restrict_iff' measurableSetIntervalOc] at *
have :=
    has_deriv_at_integral_of_dominated_loc_of_lip ε_pos hF_meas hF_int hF'_meas h_lipsch
      bound_integrable h_diff
exact ⟨this.1, this.2.const_smul _⟩
simp only [interval_integrable_iff, interval_integral_eq_integral_interval_oc, ←
    ae_restrict_iff' measurableSetIntervalOc] at *
have :=
    has_deriv_at_integral_of_dominated_loc_of_deriv_le ε_pos hF_meas hF_int hF'_meas h_bound
      bound_integrable h_diff
exact ⟨this.1, this.2.const_smul _⟩
apply (hasDerivAtConst (0 : ℝ) (0 : ℝ)).HasDerivWithinAt.congr
· intro y hy
      simp at hy
      simp [f_aux, hy]
· simp [f_aux, le_refl]
simp [f_aux, le_refl]
simp [f_aux, le_of_lt hx]
simp [f_aux, le_refl]
simp [f_aux, not_le_of_gt hx]
rw [← f_aux_zero_eq]
apply contDiffOfDifferentiableIteratedDeriv fun m hm => _
rw [f_aux_iterated_deriv m]
exact fun x => (f_aux_has_deriv_at m x).DifferentiableAt
simp [expNegInvGlue, hx]
simp [expNegInvGlue, not_le.2 hx, exp_pos]
cases le_or_gt x 0
· exact ge_of_eq (zero_of_nonpos h)
· exact le_of_lt (pos_of_pos h)
rw [zero_of_nonpos (sub_nonpos.2 h), add_zero]
rw [smooth_transition, zero_of_nonpos h, zero_div]
rw [cont_diff_iff_cont_diff_at] at *
exact fun x => (hc x).contDiffBump (hr x) (hR x) (hg x)
refine' (integral_pos_iff_support_of_nonneg f.nonneg' f.integrable).mpr _
rw [f.support_eq]
refine' is_open_ball.measure_pos _ (nonempty_ball.mpr f.R_pos)
rw [Euclidean.ball_eq_preimage, ← f.to_cont_diff_bump_of_inner.support_eq, ←
    support_comp_eq_preimage, coe_eq_comp]
rw [tsupport, f.support_eq, Euclidean.closure_ball _ f.R_pos.ne']
change Icc a b
simp only [s, inter_comm]
exact A.preimage_closed_of_closed is_closed_Icc OrderClosedTopology.is_closed_le'
refine'
    norm_image_sub_le_of_norm_deriv_right_le_segment (fun x hx => (hf x hx).ContinuousWithinAt)
      (fun x hx => _) bound
exact (hf x <| Ico_subset_Icc_self hx).nhdsWithin (Icc_mem_nhds_within_Ici hx)
refine' norm_image_sub_le_of_norm_deriv_le_segment' _ bound
exact fun x hx => (hf x hx).HasDerivWithinAt
rw [norm_le_zero_iff]
rw [← image_subset_iff, ← segment_eq_image']
apply hs.segment_subset xs ys
simp only [g]
rw [zero_smul, add_zero]
simp only [g]
rw [one_smul, add_sub_cancel'_right]
intro t ht
have : HasFderivWithinAt f ((f' (g t)).restrictScalars ℝ) s (g t) := hf (g t) (segm ht)
exact this.comp_has_deriv_within_at _ (Dg t).HasDerivWithinAt segm
rw [lipschitz_on_with_iff_norm_sub_le]
intro x x_in y y_in
exact hs.norm_image_sub_le_of_norm_has_fderiv_within_le hf bound y_in x_in
simp
simp
simp only [hf' x hx, norm_zero]
rw [fderiv_within_univ] <;> exact hf' x
simp
simp
intro x hx
exact ((hff' x hx).const_mul _).sub ((hgg' x hx).const_mul _)
rw [← ha]
exact hf'_gt _ (hxyD' a_mem)
rw [← ha]
exact hf'_ge _ (hxyD' a_mem)
intro x hx
rw [deriv.neg, neg_lt_neg_iff]
exact lt_hf' x hx
intro x hx
rw [deriv.neg, neg_le_neg_iff]
exact le_hf' x hx
apply StrictMonoOn.exists_slope_lt_deriv_aux _ hxw _ _
· exact hf.mono (Icc_subset_Icc le_rfl hwy.le)
· exact hf'_mono.mono (Ioo_subset_Ioo le_rfl hwy.le)
· intro z hz
        rw [← hw]
        apply ne_of_lt
        exact hf'_mono ⟨hz.1, hz.2.trans hwy⟩ ⟨hxw, hwy⟩ hz.2
apply StrictMonoOn.exists_slope_lt_deriv_aux _ hwy _ _
· refine' hf.mono (Icc_subset_Icc hxw.le le_rfl)
· exact hf'_mono.mono (Ioo_subset_Ioo hxw.le le_rfl)
· intro z hz
        rw [← hw]
        apply ne_of_gt
        exact hf'_mono ⟨hxw, hwy⟩ ⟨hxw.trans hz.1, hz.2⟩ hz.1
apply StrictMonoOn.exists_deriv_lt_slope_aux _ hxw _ _
· exact hf.mono (Icc_subset_Icc le_rfl hwy.le)
· exact hf'_mono.mono (Ioo_subset_Ioo le_rfl hwy.le)
· intro z hz
        rw [← hw]
        apply ne_of_lt
        exact hf'_mono ⟨hz.1, hz.2.trans hwy⟩ ⟨hxw, hwy⟩ hz.2
apply StrictMonoOn.exists_deriv_lt_slope_aux _ hwy _ _
· refine' hf.mono (Icc_subset_Icc hxw.le le_rfl)
· exact hf'_mono.mono (Ioo_subset_Ioo hxw.le le_rfl)
· intro z hz
        rw [← hw]
        apply ne_of_gt
        exact hf'_mono ⟨hxw, hwy⟩ ⟨hxw.trans hz.1, hz.2⟩ hz.1
rw [segment_eq_image']
simp only [mem_image, and_imp, add_right_inj]
intro t ht
exact ⟨t, ht, rfl⟩
intro x' H'
rw [← dist_eq_norm]
exact le_of_lt (hε H').2
  -- apply mean value theorem
simp
simp [h]
have : ¬∃ f', HasFderivWithinAt f f' s x := h
simp [fderivWithin, this]
have : ¬∃ f', HasFderivAt f f' x := h
simp [fderiv, this]
rw [sub_eq_zero.1 (norm_eq_zero.1 hx')]
simp
rw [HasFderivAt, HasFderivAtFilter, ← map_add_left_nhds_zero x, is_o_map]
simp [(· ∘ ·)]
simp only [HasFderivWithinAt, nhds_within_univ]
rfl
rw [HasFderivAt, HasFderivAtFilter, is_o_iff]
exact fun c hc => tendsto_id.prod_mk_nhds tendsto_const_nhds (is_o_iff.1 hf hc)
rw [← has_fderiv_within_at_univ] at h₀ h₁
exact unique_diff_within_at_univ.eq h₀ h₁
simp [HasFderivWithinAt, nhds_within_restrict'' s h]
simp [HasFderivWithinAt, nhds_within_restrict' s h]
simp only [HasFderivWithinAt, nhds_within_union]
exact hs.sup ht
dsimp only [fderivWithin]
dsimp only [DifferentiableWithinAt] at h
rw [dif_pos h]
exact Classical.choose_spec h
dsimp only [fderiv]
dsimp only [DifferentiableAt] at h
rw [dif_pos h]
exact Classical.choose_spec h
simp only [mem_closure_iff_nhds_within_ne_bot, ne_bot_iff, Ne.def, not_not] at h
simp [HasFderivWithinAt, HasFderivAtFilter, h, is_o, is_O_with]
simp only [DifferentiableWithinAt, has_fderiv_within_at_univ, DifferentiableAt]
simp only [DifferentiableWithinAt, HasFderivWithinAt, HasFderivAtFilter,
    nhds_within_restrict' s ht]
simp only [DifferentiableWithinAt, HasFderivWithinAt, HasFderivAtFilter,
    nhds_within_restrict'' s ht]
simp only [DifferentiableOn, Differentiable, differentiable_within_at_univ, mem_univ,
    forall_true_left]
simp only [univ_inter]
rw [← fderiv_within_univ]
exact fderiv_within_subset (subset_univ _) hs h.differentiable_within_at
rw [← nhds_within_univ] at h
exact (h.has_fderiv_within_at (mem_univ _) hn).hasFderivAtOfUniv
refine' h.is_O_sub.trans_tendsto (tendsto.mono_left _ hL)
rw [← sub_self x]
exact tendsto_id.sub tendsto_const_nhds
simp only [sub_add_cancel, eq_self_iff_true, forall_const]
simp only [hy, h₁, hx]
have h' : ¬DifferentiableWithinAt 𝕜 f₁ s x :=
      mt (fun h => h.congr_of_eventually_eq (hL.mono fun x => Eq.symm) hx.symm) h
rw [fderiv_within_zero_of_not_differentiable_within_at h,
      fderiv_within_zero_of_not_differentiable_within_at h']
apply Filter.EventuallyEq.fderiv_within_eq hs _ hx
apply mem_of_superset self_mem_nhds_within
exact hL
have A : f₁ x = f x := hL.eq_of_nhds
rw [← fderiv_within_univ, ← fderiv_within_univ]
rw [← nhds_within_univ] at hL
exact hL.fderiv_within_eq uniqueDiffWithinAtUniv A
simp
simp
rw [DifferentiableAt.fderiv_within differentiableAtId hxs]
exact fderiv_id
simp only [zero_apply, sub_self]
simp only [zero_apply, sub_self]
rw [DifferentiableAt.fderiv_within (differentiableAtConst _) hxs]
exact fderiv_const_apply _
simp only [HasFderivWithinAt, nhds_within_singleton, HasFderivAtFilter, is_o_pure,
    ContinuousLinearMap.zero_apply, sub_self]
rw [← has_fderiv_within_at_univ, subsingleton_univ.eq_singleton_of_mem (mem_univ x)]
exact hasFderivWithinAtSingleton f x
simp only [e.map_sub, sub_self]
simp only [e.map_sub, sub_self]
rw [DifferentiableAt.fderiv_within e.differentiable_at hxs]
exact e.fderiv
rw [DifferentiableAt.fderiv_within h.differentiable_at hxs]
exact h.fderiv
let eq₁ := (g'.is_O_comp _ _).trans_is_o hf
let eq₂ := (hg.comp_tendsto hL).trans_is_O hf.is_O_sub
refine' eq₂.triangle (eq₁.congr_left fun x' => _)
simp
simp
simp only [← fderiv_within_univ, fderiv_within_add_const uniqueDiffWithinAtUniv]
simp only [add_comm c, fderiv_add_const]
simp only [HasStrictFderivAt, ContinuousLinearMap.coe_pi]
exact is_o_pi
simp only [HasFderivAtFilter, ContinuousLinearMap.coe_pi]
exact is_o_pi
simp only [← fderiv_within_univ, fderiv_within_neg uniqueDiffWithinAtUniv]
simp only [sub_eq_add_neg, differentiable_within_at_add_const_iff]
simp only [sub_eq_add_neg, differentiable_at_add_const_iff]
simp only [sub_eq_add_neg, differentiable_on_add_const_iff]
simp only [sub_eq_add_neg, differentiable_add_const_iff]
simp only [sub_eq_add_neg, fderiv_within_add_const hxs]
simp only [sub_eq_add_neg, fderiv_add_const]
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
simp only [sub_eq_add_neg, fderiv_within_const_add, fderiv_within_neg, hxs]
simp only [← fderiv_within_univ, fderiv_within_const_sub uniqueDiffWithinAtUniv]
rw [DifferentiableAt.fderiv_within (h.differentiable_at p) hxs]
exact h.fderiv p
simp only [pow_zero, differentiableWithinAtConst]
simp only [pow_succ, DifferentiableWithinAt.pow n, ha.mul]
refine' tendsto_zero_iff_norm_tendsto_zero.mpr _
exact tendsto_iff_norm_tendsto_zero.mp tendsto_id
rw [← differentiable_within_at_univ, ← differentiable_within_at_univ,
    iso.comp_differentiable_within_at_iff]
rw [DifferentiableOn, DifferentiableOn]
simp only [iso.comp_differentiable_within_at_iff]
rw [← differentiable_on_univ, ← differentiable_on_univ]
exact iso.comp_differentiable_on_iff
rw [← Function.comp.assoc, iso.symm_comp_self]
rfl
rw [← ContinuousLinearMap.comp_assoc, iso.coe_symm_comp_coe, ContinuousLinearMap.id_comp]
rw [← iso.comp_has_fderiv_within_at_iff, ← ContinuousLinearMap.comp_assoc, iso.coe_comp_coe_symm,
    ContinuousLinearMap.id_comp]
rw [← fderiv_within_univ, ← fderiv_within_univ]
exact iso.comp_fderiv_within uniqueDiffWithinAtUniv
refine' ((f'.symm : F →L[𝕜] E).is_O_comp _ _).congr (fun x => _) fun _ => rfl
simp
refine' ((f'.symm : F →L[𝕜] E).is_O_comp _ _).congr (fun x => _) fun _ => rfl
simp
apply hf.lim v
rw [tendsto_at_top_at_top]
exact fun b => ⟨b, fun a ha => le_trans ha (le_abs_self _)⟩
rw [← e.image_symm_eq_preimage, e.symm.unique_diff_on_image_iff]
rw [← H] at h
exact h
rw [← H] at h
exact h
rw [← differentiable_within_at_univ, ← fderiv_within_univ]
exact
    differentiable_within_at_iff_restrict_scalars 𝕜 hf.differentiable_within_at
      uniqueDiffWithinAtUniv
intro x
rw [← not_imp_not]
intro h2x
rw [not_mem_tsupport_iff_eventually_eq] at h2x
exact nmem_support.mpr (h2x.fderiv_eq.trans <| fderiv_const_apply 0)
simp
simp [hR]
intro y hy
rw [Metric.mem_ball, dist_eq_norm] at hy
exact lt_of_lt_of_le hy (min_le_left _ _)
intro y hy
exact (mul_lt_iff_lt_one_right hε.lt).mpr (hxy y hy)
    -- With a small ball in hand, apply the mean value theorem
simp
have := this.1.add this.2
rw [add_zero] at this
refine' this.congr _
apply eventually_of_forall
intro n z hz
simp
simp [hqpos]
rw [norm_pos_iff]
intro hy'
exact hyz' (eq_of_sub_eq_zero hy').symm
simp only [imp_self, forall_const]
rw [Metric.tendsto_nhds] at h1⊢
exact fun ε hε => (h1 ε hε).curry.mono fun n hn => hn.self_of_nhds
rw [norm_pos_iff]
intro hx'
exact hx (eq_of_sub_eq_zero hx').symm
simp only [h1, prod_mem_prod_iff, univ_mem, and_self_iff]
refine' hasFderivAtOfTendstoLocallyUniformlyOn hs hf' (fun n z hz => _) hfg hx
exact ((hf n z hz).DifferentiableAt (hs.mem_nhds hz)).HasFderivAt
simp [hf]
simp [hfg]
rw [uniform_cauchy_seq_on_iff_uniform_cauchy_seq_on_filter]
exact hf'.one_smul_right
simp only [h1, prod_mem_prod_iff, univ_mem, and_self_iff]
refine' hasDerivAtOfTendstoLocallyUniformlyOn hs hf' (fun n z hz => _) hfg hx
exact ((hf n z hz).DifferentiableAt (hs.mem_nhds hz)).HasDerivAt
simp [hf]
simp [hfg]
dsimp only [taylorWithin]
rw [Finset.sum_range_succ]
dsimp only [taylorWithinEval]
dsimp only [taylorWithin]
dsimp only [taylorCoeffWithin]
simp
rw [WithTop.coe_lt_coe]
exact lt_add_one k
intro y hy
refine' pow_ne_zero _ _
rw [mem_Ioo] at hy
rw [sub_ne_zero]
exact hy.2.Ne.symm
simp
rw [conformal_at_iff_is_conformal_map_fderiv, is_conformal_map_iff]
simp only [conformal_at_iff', h.fderiv]
simp only [mem_Ioi, zero_lt_one]
simp only [norm_smul, Real.norm_eq_abs, hpos.le, abs_of_nonneg, abs_mul, ht.left,
            mul_assoc]
refine' ⟨_, xt_mem t ⟨ht.1, ht.2.le⟩⟩
rw [add_assoc, add_mem_ball_iff_norm]
exact I.trans_lt hδ
apply mul_le_mul_of_nonneg_right _ (norm_nonneg _)
apply mul_le_mul_of_nonneg_left _ εpos.le
apply (norm_add_le _ _).trans
refine' add_le_add le_rfl _
simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, ht.1, hpos.le, mul_assoc]
exact mul_le_of_le_one_left (mul_nonneg hpos.le (norm_nonneg _)) ht.2.le
simp only [two_smul]
simp [hz]
intro m
apply nhds_within_le_nhds
apply A m
rw [mem_interior_iff_mem_nhds] at hy
exact interior_mem_nhds.2 hy
  -- we choose `t m > 0` such that `x + 4 (z + (t m) m)` belongs to the interior of `s`, for any
  -- vector `m`.
simp [B, is_open_Union, IsOpen.inter, is_open_A]
simp
apply add_le_add
· apply le_of_mem_A h₂
        · simp only [le_of_lt (half_pos hr), mem_closed_ball, dist_self]
        · simp only [dist_eq_norm, add_sub_cancel', mem_closed_ball, ylt.le]
· apply le_of_mem_A h₁
        · simp only [le_of_lt (half_pos hr), mem_closed_ball, dist_self]
        · simp only [dist_eq_norm, add_sub_cancel', mem_closed_ball, ylt.le]
assumption
have I1 : x ∈ A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p q hp hq).2.1
have I2 : x ∈ A f (L e p r) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.1
exact norm_sub_le_of_mem_A hc P P I1 I2
have I1 : x ∈ A f (L e p r) ((1 / 2) ^ r) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.2
have I2 : x ∈ A f (L e' p' r) ((1 / 2) ^ r) ((1 / 2) ^ e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.2
exact norm_sub_le_of_mem_A hc P P I1 (A_mono _ _ I I2)
have I1 : x ∈ A f (L e' p' r) ((1 / 2) ^ p') ((1 / 2) ^ e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.1
have I2 : x ∈ A f (L e' p' q') ((1 / 2) ^ p') ((1 / 2) ^ e') := (hn e' p' q' hp' hq').2.1
exact norm_sub_le_of_mem_A hc P P (A_mono _ _ I I1) (A_mono _ _ I I2)
trace
          "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr add_le_add, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
intro e p hp
apply le_of_tendsto (tendsto_const_nhds.sub hf').norm
rw [eventually_at_top]
exact ⟨e, fun e' he' => M _ _ _ _ _ _ le_rfl hp le_rfl le_rfl he'⟩
  -- Let us show that `f` has derivative `f'` at `x`.
simp only [has_fderiv_at_iff_is_o_nhds_zero, is_o_iff]
    /- to get an approximation with a precision `ε`, we will replace `f` with `L e (n e) m` for
        some large enough `e` (yielding a small error
simp
simp [differentiable_set_eq_D K hK, D, is_open_B.measurable_set, MeasurableSet.inter,
    MeasurableSet.union]
simp [smul_sub]
apply add_le_add
· apply le_of_mem_A h₂ <;> simp [(half_pos hr).le]
· apply le_of_mem_A h₁ <;> simp [(half_pos hr).le]
assumption
have I1 : x ∈ A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p q hp hq).2.1
have I2 : x ∈ A f (L e p r) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.1
exact norm_sub_le_of_mem_A P _ I1 I2
have I1 : x ∈ A f (L e p r) ((1 / 2) ^ r) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.2
have I2 : x ∈ A f (L e' p' r) ((1 / 2) ^ r) ((1 / 2) ^ e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.2
exact norm_sub_le_of_mem_A P _ I1 (A_mono _ _ I I2)
have I1 : x ∈ A f (L e' p' r) ((1 / 2) ^ p') ((1 / 2) ^ e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.1
have I2 : x ∈ A f (L e' p' q') ((1 / 2) ^ p') ((1 / 2) ^ e') := (hn e' p' q' hp' hq').2.1
exact norm_sub_le_of_mem_A P _ (A_mono _ _ I I1) (A_mono _ _ I I2)
trace
          "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr add_le_add, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
intro e p hp
apply le_of_tendsto (tendsto_const_nhds.sub hf').norm
rw [eventually_at_top]
exact ⟨e, fun e' he' => M _ _ _ _ _ _ le_rfl hp le_rfl le_rfl he'⟩
  -- Let us show that `f` has right derivative `f'` at `x`.
simp only [has_deriv_within_at_iff_is_o, is_o_iff]
    /- to get an approximation with a precision `ε`, we will replace `f` with `L e (n e) m` for
        some large enough `e` (yielding a small error
simp only [one_div, left_mem_Ico, lt_add_iff_pos_right, inv_pos, pow_pos, zero_lt_bit0,
        zero_lt_one]
rw [Real.norm_of_nonneg yzero.le]
simp only [smul_sub, sub_add_sub_cancel]
rw [norm_smul]
exact mul_le_mul_of_nonneg_left (Lf' _ _ m_ge) (norm_nonneg _)
simp [differentiable_set_eq_D K hK, D, measurable_set_B, MeasurableSet.inter, MeasurableSet.union]
rw [f.decomp]
apply f.cont_linear.cont_diff.add
simp only
exact contDiffConst
simp [ApproximatesLinearOn]
simp [ε0]
rw [← inv_pos]
exact (Nnreal.coe_nonneg _).trans_lt hc
apply ne_of_gt
simp [hu, ← iterate_succ_apply' g _ b]
  -- First bound: if `f z` is close to `y`, then `g z` is close to `z` (i.e., almost a fixed point).
intro z
rw [dist_eq_norm, hg, add_sub_cancel', dist_eq_norm']
exact f'symm.bound _
  -- Second bound: if `z` and `g z` are in the set with good control, then `f (g z)` becomes closer
  -- to `y` than `f z` was (this uses the linear approximation property, and is the reason for the
  -- choice of the formula for `g`).
rw [dist_eq_norm]
simp only [ContinuousLinearMap.NonlinearRightInverse.right_inv, add_sub_cancel',
          sub_add_cancel]
apply mul_le_mul_of_nonneg_left _ (mul_nonneg (Nnreal.coe_nonneg _) dist_nonneg)
rw [sub_le_self_iff]
exact pow_nonneg (mul_nonneg (Nnreal.coe_nonneg _) (Nnreal.coe_nonneg _)) _
rw [mul_one]
exact mul_le_mul_of_nonneg_left (mem_closed_ball'.1 hy) (Nnreal.coe_nonneg _)
rw [usucc, dist_comm]
simp only [nhdsWithin, tendsto_inf, hx, true_and_iff, ge_iff_le, tendsto_principal]
exact eventually_of_forall fun n => C n _ (D n).2
rw [sub_pos]
exact hc
apply continuous_on_iff_continuous_restrict.2
refine' ((hf.antilipschitz hc).toRightInvOn' _ (hf.to_local_equiv hc).right_inv').Continuous
exact fun x hx => (hf.to_local_equiv hc).map_target hx
trace
        "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr mul_le_mul_of_nonneg_left, \",\", expr nnreal.coe_nonneg, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
rw [← dist_eq_norm, ← dist_eq_norm]
exact (hf.antilipschitz hc).le_mul_dist ⟨y', y's⟩ ⟨x', x's⟩
refine' (hf.to_local_homeomorph _ _ hc is_open_univ).toHomeomorphOfSourceEqUnivTargetEqUniv rfl _
change f
simp [hc, Nnreal.half_pos, Nnreal.inv_pos, f'symm_pos]
refine' ((nhds_basis_opens a).exists_iff _).1 _
exact fun s t => ApproximatesLinearOn.monoSet
exact
    hf.approximates_deriv_on_nhds <|
      (f'.subsingleton_or_nnnorm_symm_pos.imp id) fun hf' =>
        Nnreal.half_pos <| Nnreal.inv_pos.2 <| hf'
let c := fun n : ℕ => (2 : ℝ) ^ n
let d := fun n : ℕ => (c n)
rw [fderiv_within_zero_of_not_differentiable_within_at hf]
rfl
rw [fderiv_within_zero_of_not_differentiable_within_at hf]
rfl
rw [fderiv_within_zero_of_not_differentiable_within_at hf]
rfl
rw [fderiv_within_zero_of_not_differentiable_within_at hf]
rfl
rw [h]
rw [h, hfI]
rw [h]
rw [h, hfI]
apply exists_local_extr_Ioo _ hab hcont
rw [eq_lim_at_right_extend_from_Ioo hab hfb]
exact eq_lim_at_left_extend_from_Ioo hab hfa
simp only [Finset.sum_add_distrib, Finset.card_eq_sum_ones, count_roots]
simp only [← count_roots]
refine' add_le_add_left (add_le_add_right ((Finset.card_eq_sum_ones _).trans_le _) _) _
refine' Finset.sum_le_sum fun x hx => Nat.succ_le_iff.2 <| _
rw [Multiset.count_pos, ← Multiset.mem_to_finset]
exact (Finset.mem_sdiff.1 hx).1
simp [HasDerivAtFilter]
simp [HasStrictDerivAt, HasStrictFderivAt]
unfold derivWithin
rw [fderiv_within_zero_of_not_differentiable_within_at]
simp
assumption
unfold deriv
rw [fderiv_zero_of_not_differentiable_at]
simp
assumption
simp
simp only [HasDerivWithinAt, nhdsWithin, diff_eq, inf_assoc.symm, inf_principal.symm]
exact has_deriv_at_filter_iff_tendsto_slope
simp only [has_deriv_within_at_iff_tendsto_slope, sdiff_idem]
rw [← Ici_diff_left, has_deriv_within_at_diff_singleton]
rw [← Iic_diff_right, has_deriv_within_at_diff_singleton]
rw [Ioi_inter_Iio, inter_eq_left_iff_subset]
exact Ioo_subset_Iio_self
simp [derivWithin]
simp [deriv]
unfold derivWithin deriv
rw [h.fderiv_within hxs]
unfold derivWithin
rw [fderiv_within_inter ht hs]
unfold derivWithin
rw [fderiv_within_of_open hs hx]
rfl
simp [h₁]
unfold derivWithin
rw [hL.fderiv_within_eq hs hx]
unfold derivWithin
rw [fderiv_within_congr hs hL hx]
simp only [derivWithin, fderiv_within_add_const hxs]
simp only [deriv, fderiv_add_const]
simp only [derivWithin, fderiv_within_const_add hxs]
simp only [deriv, fderiv_const_add]
rw [← has_deriv_within_at_univ] at *
exact hc.smul hf
rw [← has_deriv_within_at_univ] at *
exact hc.smul_const f
simp only [derivWithin, fderiv_within_neg hxs, ContinuousLinearMap.neg_apply]
simp only [deriv, fderiv_neg, ContinuousLinearMap.neg_apply]
simp [norm_smul, ← div_eq_inv_mul, mul_div_cancel _ (mt norm_eq_zero.1 hf')]
simp only [derivWithin, fderiv_within_sub_const hxs]
simp only [deriv, fderiv_sub_const]
simp [derivWithin, fderiv_within_const_sub hxs]
simp only [← deriv_within_univ,
    deriv_within_const_sub (uniqueDiffWithinAtUniv : UniqueDiffWithinAt 𝕜 _ _)]
rw [mul_comm]
exact hh₂.scomp x hh hL
rw [mul_comm]
exact hh₂.scomp x hh hst
rw [mul_comm]
exact hh₂.scomp x hh
rw [← has_deriv_within_at_univ] at *
exact hc.mul hd
rw [← has_deriv_within_at_univ] at *
exact hc.mul_const d
rw [← has_deriv_within_at_univ] at *
exact hd.const_mul c
simp only [mul_comm u, deriv_mul_const_field]
rw [DifferentiableAt.deriv_within (differentiable_at_inv.2 x_ne_zero) hxs]
exact deriv_inv
rw [← deriv_fderiv, deriv_inv]
rw [DifferentiableAt.fderiv_within (differentiable_at_inv.2 x_ne_zero) hxs]
exact fderiv_inv
rw [← has_deriv_within_at_univ] at *
exact hc.inv hx
rw [← has_deriv_within_at_univ] at *
exact hc.div hd hx
simp [div_eq_inv_mul, deriv_within_const_mul, hc, hxs]
simp only [div_eq_mul_inv, deriv_mul_const_field]
rw [← has_deriv_within_at_univ] at *
exact hc.clm_comp hd
rw [DifferentiableAt.deriv_within p.differentiable_at hxs]
exact p.deriv
rw [← has_deriv_within_at_univ] at *
exact hc.pow n
intro x
rw [← not_imp_not]
intro h2x
rw [not_mem_tsupport_iff_eventually_eq] at h2x
exact nmem_support.mpr (h2x.deriv_eq.trans (deriv_const x 0))
simp [hr₀]
apply (hf.limsup_norm_slope_le hr).mono
intro z hz
refine' lt_of_le_of_lt (mul_le_mul_of_nonneg_left (norm_sub_norm_le _ _) _) hz
exact inv_nonneg.2 (norm_nonneg _)
simp only [norm_sub_rev (F x₀ _)]
refine' h_lipsch.mono fun a ha => (ha x x_in).trans _
rw [mul_comm ε]
rw [mem_ball, dist_eq_norm] at x_in
exact mul_le_mul_of_nonneg_left x_in.le (b_nonneg _)
simp
rw [smul_sub]
rw [norm_smul_of_nonneg, norm_smul_of_nonneg] <;> exact nneg _
rw [← map_map, φ.has_strict_fderiv_at.map_nhds_eq_of_equiv, map_fst_nhds]
simp only [implicit_to_local_homeomorph_of_complemented_apply, add_sub_cancel,
    Classical.choose_spec hker]
simp [hf.implicit_to_local_homeomorph_of_complemented_apply]
apply implicit_to_local_homeomorph_of_complemented_apply_ker
apply implicit_to_local_homeomorph_of_complemented_self
apply mem_implicit_to_local_homeomorph_of_complemented_target
refine'
    ((hf.implicit_to_local_homeomorph f f' hf').tendsto_symm
          (hf.mem_implicit_to_local_homeomorph_source hf')).comp
      _
rw [implicit_to_local_homeomorph_self]
exact h₁.prod_mk_nhds h₂
apply map_implicit_function_of_complemented_eq
apply implicit_function_of_complemented_apply_image
apply eq_implicit_function_of_complemented
apply to_implicit_function_of_complemented
let c := fun n : ℕ => (2 : ℝ) ^ (n + 1)
let d := fun n : ℕ => (c n)
rw [unique_diff_within_at_iff, tangent_cone_univ]
simp
simp only [unique_diff_within_at_iff] at *
rw [mem_closure_iff_nhds_within_ne_bot] at h⊢
exact ⟨h.1.mono <| Submodule.span_mono <| tangent_cone_mono_nhds st, h.2.mono st⟩
refine' ⟨Dense.of_closure _, hx⟩
simp [(Submodule.span ℝ (tangentConeAt ℝ s x)).eq_top_of_nonempty_interior'
        ⟨y - x, interior_mono Submodule.subset_span this⟩]
simp only [interior_Ici, nonempty_Ioi]
simp only [interior_Iic, nonempty_Iio]
simp only [interior_Icc, nonempty_Ioo, hab]
simp only [interior_Ico, nonempty_Ioo, hab]
simp only [Ico_eq_empty hab, uniqueDiffOnEmpty]
simp only [interior_Ioc, nonempty_Ioo, hab]
simp only [Ioc_eq_empty hab, uniqueDiffOnEmpty]
simp
simp
simp
simp
apply tendsto.mono_left _ (hl.trans nhds_within_le_nhds)
exact ((tendsto_id.sub_const x).const_mul c).const_add 1
apply tendsto.mono_right h' hl self_mem_nhds_within
rw [not_not, hf.continuous_at_iff_left_lim_eq_right_lim] at h'x
apply le_antisymm _ (hf.le_right_lim (le_refl _))
rw [← h'x]
exact hf.left_lim_le (le_refl _)
rw [ae_restrict_iff' hs]
exact hf.ae_differentiable_within_at_of_mem
refine' ⟨fun x hx => _, h.fderiv_within, h.cont⟩
rw [h₁ x hx]
exact h.zero_eq x hx
constructor
· intro H n
    exact H.of_le le_top
· intro H
    constructor
    · exact (H 0).zero_eq
    · intro m hm
      apply (H m.succ).fderivWithin m (WithTop.coe_lt_coe.2 (lt_add_one m))
    · intro m hm
      apply (H m).cont m le_rfl
intro y hy
rw [← h.zero_eq y hy]
rfl
constructor
· intro h
    exact
      ⟨h.of_le (WithTop.coe_le_coe.2 (Nat.le_succ n)),
        h.fderiv_within _ (WithTop.coe_lt_coe.2 (lt_add_one n)), h.cont (n + 1) le_rfl⟩
· intro h
    constructor
    · exact h.1.zero_eq
    · intro m hm
rw [WithTop.coe_lt_coe] at hm⊢
exact nat.lt_succ_iff.mpr hm
rw [WithTop.coe_le_coe] at hm⊢
exact nat.pred_le_iff.mp hm
rw [WithTop.coe_lt_coe] at hm⊢
exact Nat.lt_of_succ_lt_succ hm
rw [WithTop.coe_le_coe] at hm⊢
exact nat.lt_succ_iff.mp hm
simp only [forall_prop_of_true, le_top]
simp
simp only [le_top, forall_prop_of_true]
rw [iterated_fderiv_within_zero_eq_comp, LinearIsometryEquiv.norm_map]
rw [iterated_fderiv_within_succ_eq_comp_left, LinearIsometryEquiv.norm_map]
rw [fderiv_within_congr (hs x hx) A (A x hx)]
rw [LinearIsometryEquiv.comp_fderiv_within _ (hs x hx)]
rfl
rw [iterated_fderiv_within_succ_apply_left, tail_init_eq_init_tail]
rfl
rw [iterated_fderiv_within_succ_eq_comp_right hs hx, LinearIsometryEquiv.norm_map]
rw [iterated_fderiv_within_succ_apply_right hs hx, iterated_fderiv_within_zero_apply]
rfl
apply subset.antisymm (inter_subset_inter (inter_subset_left _ _) (subset.refl _))
exact fun y ⟨ys, yv⟩ => ⟨⟨ys, vu ⟨yv, ys⟩⟩, yv⟩
refine' iterated_fderiv_within_inter_open v_open _ ⟨⟨xs, vu ⟨xv, xs⟩⟩, xv⟩
rw [A]
exact hs.inter v_open
simp [ftaylorSeriesWithin]
change p x m.succ = iteratedFderivWithin 𝕜 m.succ f s x
rw [← iterated_fderiv_within_inter (IsOpen.mem_nhds o_open xo) hs hx]
exact (Hp.mono ho).eq_ftaylor_series_of_unique_diff_on le_rfl (hs.inter o_open) ⟨hx, xo⟩
constructor
· intro h
    constructor
    · intro m hm
      exact h.continuous_on_iterated_fderiv_within hm hs
    · intro m hm
      exact h.differentiable_on_iterated_fderiv_within hm hs
· intro h
    exact contDiffOnOfContinuousOnDifferentiableOn h.1 h.2
intro x hx
rw [cont_diff_within_at_succ_iff_has_fderiv_within_at, insert_eq_of_mem hx]
exact
    ⟨s, self_mem_nhds_within, fderivWithin 𝕜 f s, fun y hy => (hf y hy).HasFderivWithinAt, h x hx⟩
rw [cont_diff_on_succ_iff_fderiv_within hs.unique_diff_on]
trace
    "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr «expr ∧ »(_, _)]]"
apply cont_diff_on_congr
intro x hx
exact fderiv_within_of_open hs hx
rw [cont_diff_on_top_iff_fderiv_within hs.unique_diff_on]
trace
    "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr «expr ∧ »(_, _)]]"
apply cont_diff_on_congr
intro x hx
exact fderiv_within_of_open hs hx
constructor
· intro H
    constructor
    · exact fun x => H.zero_eq x (mem_univ x)
    · intro m hm x
      rw [← has_fderiv_within_at_univ]
      exact H.fderiv_within m hm x (mem_univ x)
    · intro m hm
      rw [continuous_iff_continuous_on_univ]
      exact H.cont m hm
· intro H
    constructor
    · exact fun x hx => H.zero_eq x
    · intro m hm x hx
      rw [has_fderiv_within_at_univ]
      exact H.fderiv m hm x
    · intro m hm
      rw [← continuous_iff_continuous_on_univ]
      exact H.cont m hm
rw [← has_ftaylor_series_up_to_on_univ_iff] at h⊢
exact h.of_le hmn
rw [← has_ftaylor_series_up_to_on_univ_iff] at h
rw [continuous_iff_continuous_on_univ]
exact h.continuous_on
simp [has_ftaylor_series_up_to_on_univ_iff.symm, continuous_iff_continuous_on_univ,
    has_ftaylor_series_up_to_on_zero_iff]
rw [← has_fderiv_within_at_univ]
exact (has_ftaylor_series_up_to_on_univ_iff.2 h).HasFderivWithinAt hn (mem_univ _)
simp only [has_ftaylor_series_up_to_on_succ_iff_right, ← has_ftaylor_series_up_to_on_univ_iff,
    mem_univ, forall_true_left, has_fderiv_within_at_univ]
simp [← cont_diff_within_at_univ, cont_diff_within_at_top]
simp [← cont_diff_on_univ, ContDiffOn, ContDiffAt]
simp [cont_diff_on_univ.symm, cont_diff_on_top]
simp only [← cont_diff_on_univ, cont_diff_on_all_iff_nat]
rw [← cont_diff_on_univ, continuous_iff_continuous_on_univ]
exact cont_diff_on_zero
rw [← cont_diff_within_at_univ]
simp [cont_diff_within_at_zero, nhds_within_univ]
rw [iterated_fderiv_zero_eq_comp, LinearIsometryEquiv.norm_map]
rw [iterated_fderiv_succ_eq_comp_left, LinearIsometryEquiv.norm_map]
rw [← iterated_fderiv_within_univ, ← iterated_fderiv_within_univ, ← fderiv_within_univ]
exact iterated_fderiv_within_succ_apply_right uniqueDiffOnUniv (mem_univ _) _
rw [iterated_fderiv_succ_eq_comp_right, LinearIsometryEquiv.norm_map]
rw [iterated_fderiv_succ_apply_right, iterated_fderiv_zero_apply]
rfl
constructor
· rw [← cont_diff_on_univ, ← has_ftaylor_series_up_to_on_univ_iff, ← ftaylor_series_within_univ]
    exact fun h => ContDiffOn.ftaylorSeriesWithin h uniqueDiffOnUniv
· intro h
    exact ⟨ftaylorSeries 𝕜 f, h⟩
simp [cont_diff_on_univ.symm, continuous_iff_continuous_on_univ, differentiable_on_univ.symm,
    iterated_fderiv_within_univ, cont_diff_on_iff_continuous_on_differentiable_on uniqueDiffOnUniv]
simp only [← cont_diff_on_univ, ← differentiable_on_univ, ← fderiv_within_univ,
    cont_diff_on_succ_iff_fderiv_within uniqueDiffOnUniv]
simp only [← cont_diff_on_univ, ← differentiable_on_univ, ← fderiv_within_univ]
rw [cont_diff_on_top_iff_fderiv_within uniqueDiffOnUniv]
rw [Subsingleton.elim f fun _ => 0]
exact contDiffConst
rw [Subsingleton.elim f fun _ => 0]
exact contDiffAtConst
rw [Subsingleton.elim f fun _ => 0]
exact contDiffWithinAtConst
rw [Subsingleton.elim f fun _ => 0]
exact contDiffOnConst
simp only [← cont_diff_within_at_univ, e.comp_cont_diff_within_at_iff]
simp [ContDiffOn, e.comp_cont_diff_within_at_iff]
simp only [← cont_diff_on_univ, e.comp_cont_diff_on_iff]
rw [← cont_diff_within_at_univ, ← cont_diff_within_at_univ, ← preimage_univ]
exact e.cont_diff_within_at_comp_iff
rw [← preimage_comp, e.self_comp_symm]
rfl
rw [← cont_diff_on_univ, ← cont_diff_on_univ, ← preimage_univ]
exact e.cont_diff_on_comp_iff
induction over `n
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
  -- declare the isomorphisms
apply cont_diff_on.comp_same_univ gu_diff fu_diff
intro y hy
simp only [fu, ContinuousLinearEquiv.coe_apply, Function.comp_apply, mem_preimage]
rw [isoF.apply_symm_apply (f (isoE y))]
exact st hy
apply hf.continuous_within_at.insert_self.preimage_mem_nhds_within'
apply nhds_within_mono _ _ u_nhd
rw [image_insert_eq]
exact insert_subset_insert (image_subset_iff.mpr st)
rw [insert_eq_of_mem hxs]
exact eventually_of_mem self_mem_nhds_within hs
rw [← cont_diff_on_univ] at hf⊢
rw [← fderiv_within_univ, ← univ_prod_univ]
exact contDiffOnFderivWithinApply hf uniqueDiffOnUniv hmn
simp only [← cont_diff_on_univ, cont_diff_on_pi]
rw [← cont_diff_within_at_univ] at * <;> exact hf.add hg
congr 2
exact fderiv_within_congr (hu x hx) (fun _ => hi hcdf hcdg) (hi hcdf hcdg hx)
rw [Pi.add_def, fderiv_within_add (hu x hx) (hdf x hx) (hdg x hx)] <;> rfl
rw [← cont_diff_within_at_univ] at * <;> exact hf.neg
congr 2
exact fderiv_within_congr (hu x hx) (fun _ => hi) (hi hx)
rw [Pi.neg_def, fderiv_within_neg (hu x hx)] <;> rfl
rw [← cont_diff_within_at_univ] at * <;> exact ContDiffWithinAt.sum h
simp only [← cont_diff_on_univ] at * <;> exact ContDiffOn.sum h
rw [← cont_diff_within_at_univ] at * <;> exact hf.smul hg
rw [← cont_diff_within_at_univ] at * <;> exact hf.const_smul c
congr 2
exact fderiv_within_congr (hu x hx) (fun _ => hi hcdf) (hi hcdf hx)
rw [Pi.smul_def, fderiv_within_const_smul (hu x hx) (hdf x hx)] <;> rfl
rw [cont_diff_iff_cont_diff_at] at *
exact fun ⟨x, y⟩ => (hf x).prod_map (hg y)
rw [cont_diff_iff_cont_diff_at]
exact fun x => hf.cont_diff_at.inv (h x)
simp only [cont_diff_iff_cont_diff_at] at *
exact fun x => (hf x).div (hg x) (h0 x)
induction on `n
have hf₀' := f₀'.nhds
rw [← eq_f₀'] at hf₀'
exact hf'.continuous_at.preimage_mem_nhds hf₀'
rw [he]
exact hff' (f.symm x) hxu
rw [eq_f₀']
exact contDiffAtMapInverse _
rw [cont_diff_succ_iff_fderiv, cont_diff_clm_apply_iff]
rw [cont_diff_on_succ_iff_fderiv_within hs, cont_diff_on_clm_apply]
rw [cont_diff_on_succ_iff_deriv_within hs.unique_diff_on]
trace
    "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr «expr ∧ »(_, _)]]"
exact cont_diff_on_congr fun _ => deriv_within_of_open hs
rw [cont_diff_on_top_iff_deriv_within hs.unique_diff_on]
trace
    "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr «expr ∧ »(_, _)]]"
exact cont_diff_on_congr fun _ => deriv_within_of_open hs
simp only [← cont_diff_on_univ, cont_diff_on_succ_iff_deriv_of_open, is_open_univ,
    differentiable_on_univ]
simp only [← cont_diff_on_univ, ← differentiable_on_univ, ← deriv_within_univ]
rw [cont_diff_on_top_iff_deriv_within uniqueDiffOnUniv]
rw [tsupport, ← Euclidean.closure_ball _ d_pos.ne']
exact closure_mono f_supp
simp only [range_const, singleton_subset_iff, left_mem_Icc, zero_le_one]
simp only [hf.2.2.2.2, Subtype.coe_mk, mem_support, Ne.def, one_ne_zero, not_false_iff]
apply
          ((g_smooth n).continuous_iterated_fderiv
                le_top).norm.bdd_above_range_of_has_compact_support
apply HasCompactSupport.comp_left _ norm_zero
apply (g_comp_supp n).iteratedFderiv
simp
rw [iterated_fderiv_const_smul_apply]
exact (g_smooth n).of_le le_top
rw [dslope_of_ne _ h, slope_sub_smul _ h.symm]
simp only [dslope, continuous_at_update_same, ← has_deriv_at_deriv_iff,
    has_deriv_at_iff_tendsto_slope]
refine' ⟨ContinuousWithinAt.of_dslope, fun hc => _⟩
simp only [dslope, continuous_within_at_update_of_ne h]
exact
    ((continuous_within_at_id.sub continuous_within_at_const).inv₀ (sub_ne_zero.2 h)).smul
      (hc.sub continuous_within_at_const)
simp only [← continuous_within_at_univ, continuous_within_at_dslope_of_ne h]
refine' ⟨DifferentiableWithinAt.ofDslope, fun hd => _⟩
refine'
    (((differentiable_within_at_id.sub_const a).inv (sub_ne_zero.2 h)).smul
          (hd.sub_const (f a))).congr_of_eventually_eq
      _ (dslope_of_ne _ h)
refine' (eq_on_dslope_slope _ _).eventually_eq_of_mem _
exact mem_nhds_within_of_mem_nhds (is_open_ne.mem_nhds h)
simp only [← differentiable_within_at_univ, differentiable_within_at_dslope_of_ne h]
rw [← h, ← nhds_within_Ioo_eq_nhds_within_Iio hx.1]
exact ((hgg' x hx).ContinuousAt.ContinuousWithinAt.mono <| sub x hx).Tendsto
intro x hx
rw [← sub_zero (f x), ← sub_zero (g x)]
exact
      exists_ratio_has_deriv_at_eq_ratio_slope' g g' hx.1 f f' (fun y hy => hgg' y <| sub x hx hy)
        (fun y hy => hff' y <| sub x hx hy) hga hfa
        (tendsto_nhds_within_of_tendsto_nhds (hgg' x hx).ContinuousAt.Tendsto)
        (tendsto_nhds_within_of_tendsto_nhds (hff' x hx).ContinuousAt.Tendsto)
refine' lhopital_zero_right_on_Ioo hab hff' hgg' hg' _ _ hdiv
· rw [← hfa, ← nhds_within_Ioo_eq_nhds_within_Ioi hab]
    exact ((hcf a <| left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).Tendsto
· rw [← hga, ← nhds_within_Ioo_eq_nhds_within_Ioi hab]
    exact ((hcg a <| left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).Tendsto
rw [← preimage_neg_Ioo] at hx
exact hx
simp only [neg_div_neg_eq, mul_one, mul_neg]
exact (tendsto_congr fun x => rfl).mp (hdiv.comp tendsto_neg_nhds_within_Ioi_neg)
refine' lhopital_zero_left_on_Ioo hab hff' hgg' hg' _ _ hdiv
· rw [← hfb, ← nhds_within_Ioo_eq_nhds_within_Iio hab]
    exact ((hcf b <| right_mem_Ioc.mpr hab).mono Ioo_subset_Ioc_self).Tendsto
· rw [← hgb, ← nhds_within_Ioo_eq_nhds_within_Iio hab]
    exact ((hcg b <| right_mem_Ioc.mpr hab).mono Ioo_subset_Ioc_self).Tendsto
intro x hx
refine' mul_ne_zero _ (neg_ne_zero.mpr <| inv_ne_zero <| pow_ne_zero _ <| fact1 x hx)
exact hg' _ (fact2 x hx)
rw [← preimage_neg_Iio] at hx
exact hx
simp only [mul_one, mul_neg, neg_div_neg_eq]
exact (tendsto_congr fun x => rfl).mp (hdiv.comp tendsto_neg_at_top_at_bot)
refine' lhopital_zero_right_on_Ioo hab hdf hg' _ _ hdiv
· rw [← hfa, ← nhds_within_Ioo_eq_nhds_within_Ioi hab]
    exact ((hcf a <| left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).Tendsto
· rw [← hga, ← nhds_within_Ioo_eq_nhds_within_Ioi hab]
    exact ((hcg a <| left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).Tendsto
simp only [← Iio_union_Ioi, nhds_within_union, tendsto_sup, eventually_sup] at *
exact
    ⟨lhopital_zero_nhds_left hff'.1 hgg'.1 hg'.1 hfa.1 hga.1 hdiv.1,
      lhopital_zero_nhds_right hff'.2 hgg'.2 hg'.2 hfa.2 hga.2 hdiv.2⟩
apply @lhopital_zero_nhds' _ _ _ f' _ g' <;>
      first
        |apply
          eventually_nhds_within_of_eventually_nhds|apply tendsto_nhds_within_of_tendsto_nhds <;>
    assumption
simp only [← Iio_union_Ioi, nhds_within_union, tendsto_sup, eventually_sup] at *
exact
    ⟨lhopital_zero_nhds_left hdf.1 hg'.1 hfa.1 hga.1 hdiv.1,
      lhopital_zero_nhds_right hdf.2 hg'.2 hfa.2 hga.2 hdiv.2⟩
apply lhopital_zero_nhds' <;>
      first
        |apply
          eventually_nhds_within_of_eventually_nhds|apply tendsto_nhds_within_of_tendsto_nhds <;>
    assumption
infer_instance
rw [← Nat.succ_pred_eq_of_pos h]
rfl
cases h1
congr
simp [order]
simp [order, Inf, hp]
rw [← mk_pi_field_coeff_eq p, ContinuousMultilinearMap.mk_pi_field_eq_zero_iff]
simp
rw [← mk_pi_field_coeff_eq p, ContinuousMultilinearMap.norm_mk_pi_field]
have : @Fin.cons n (fun _ => 𝕜) 1 (1 : Fin n → 𝕜) = 1 := Fin.cons_self_tail 1
simp only [fslope, coeff, ContinuousMultilinearMap.curry_left_apply, this]
rw [← tendsto_uniformly_on_univ]
exact tendsto_uniformly_on_tsum hu fun n x hx => hfu n x
intro y hy
apply Summable.has_sum
exact summable_of_summable_has_fderiv_at_of_is_preconnected hu hs h's hf hf' hx₀ hf0 hy
rw [iterated_fderiv_tsum hf hv h'f hk]
rw [eventually_all_finset]
intro i hi
apply h'f
simp only [Finset.mem_range_succ_iff] at hi
exact (WithTop.coe_le_coe.2 hi).trans hm
assumption
intro y y_in
exact tendsto.sub (f_cont y y_in) f'.cont.continuous_within_at
rw [t_closure]
intro y hy
simp only [deriv_fderiv.symm]
exact
      tendsto.comp
        (isBoundedBilinearMapSmulRight : IsBoundedBilinearMap ℝ _).continuous_right.ContinuousAt
        (tendsto_nhds_within_mono_left Ioo_subset_Ioi_self f_lim')
  -- now we can apply `has_fderiv_at_boundary_of_differentiable`
rw [has_deriv_within_at_iff_has_fderiv_within_at, ← t_closure]
exact hasFderivAtBoundaryOfTendstoFderiv t_diff t_conv t_open t_cont t_diff'
rw [t_closure]
intro y hy
simp only [deriv_fderiv.symm]
exact
      tendsto.comp
        (isBoundedBilinearMapSmulRight : IsBoundedBilinearMap ℝ _).continuous_right.ContinuousAt
        (tendsto_nhds_within_mono_left Ioo_subset_Iio_self f_lim')
  -- now we can apply `has_fderiv_at_boundary_of_differentiable`
rw [has_deriv_within_at_iff_has_fderiv_within_at, ← t_closure]
exact hasFderivAtBoundaryOfTendstoFderiv t_diff t_conv t_open t_cont t_diff'
refine' lt_of_le_of_ne hab fun hab' => _
subst b
exact lt_asymm hma hmb
rw [segment_symm, segment_eq_Icc hab]
intro k hk
refine' (hf.mono _).IntervalIntegrable
rw [interval_of_le]
· apply Icc_subset_Icc
      · simp only [le_add_iff_nonneg_right, Nat.cast_nonneg]
      · simp only [add_le_add_iff_left, Nat.cast_le, Nat.succ_le_of_lt hk]
· simp only [add_le_add_iff_left, Nat.cast_le, Nat.le_succ]
simp
simp
simp
simp
rw [(Nat.sub_add_cancel hab).symm, Nat.cast_add]
conv => 
    congr
    congr
    skip
    skip
    rw [add_comm]
    skip
    skip
    congr
    congr
    rw [← zero_add a]
rw [← Finset.sum_Ico_add, Nat.Ico_zero_eq_range]
conv => 
    rhs
    congr
    skip
    ext
    rw [Nat.cast_add]
apply AntitoneOn.integral_le_sum
simp only [hf, hab, Nat.cast_sub, add_sub_cancel'_right]
intro k hk
refine' (hf.mono _).IntervalIntegrable
rw [interval_of_le]
· apply Icc_subset_Icc
      · simp only [le_add_iff_nonneg_right, Nat.cast_nonneg]
      · simp only [add_le_add_iff_left, Nat.cast_le, Nat.succ_le_of_lt hk]
· simp only [add_le_add_iff_left, Nat.cast_le, Nat.le_succ]
simp
simp
simp
rw [(Nat.sub_add_cancel hab).symm, Nat.cast_add]
conv => 
    congr
    congr
    congr
    rw [← zero_add a]
    skip
    skip
    skip
    rw [add_comm]
rw [← Finset.sum_Ico_add, Nat.Ico_zero_eq_range]
conv => 
    lhs
    congr
    congr
    skip
    ext
    rw [add_assoc, Nat.cast_add]
apply AntitoneOn.sum_le_integral
simp only [hf, hab, Nat.cast_sub, add_sub_cancel'_right]
rw [← neg_le_neg_iff, ← Finset.sum_neg_distrib, ← intervalIntegral.integral_neg]
exact hf.neg.integral_le_sum
rw [← neg_le_neg_iff, ← Finset.sum_neg_distrib, ← intervalIntegral.integral_neg]
exact hf.neg.integral_le_sum_Ico hab
rw [← neg_le_neg_iff, ← Finset.sum_neg_distrib, ← intervalIntegral.integral_neg]
exact hf.neg.sum_le_integral
rw [← neg_le_neg_iff, ← Finset.sum_neg_distrib, ← intervalIntegral.integral_neg]
exact hf.neg.sum_le_integral_Ico hab
rw [norm_smul, norm_inv]
exact one_le_mul_of_one_le_of_one_le (one_le_inv (norm_pos_iff.mpr h) ha) hr
refine' fun x hx => mem_balanced_core_aux_iff.2 fun r hr => _
rw [mem_smul_set_iff_inv_smul_mem₀ (norm_pos_iff.mp <| zero_lt_one.trans_le hr)]
refine' h (ht.smul_mem _ hx)
rw [norm_inv]
exact inv_le_one hr
refine' balanced_core_subset_balanced_core_aux.antisymm _
refine' (balancedCoreAuxBalanced _).subset_core_of_subset (balanced_core_aux_subset s)
exact balanced_core_subset_balanced_core_aux (balanced_core_zero_mem hs)
rw [balanced_core_eq_Inter ht]
refine' subset_Inter₂ fun a ha => _
rw [← smul_inv_smul₀ (norm_pos_iff.mp <| zero_lt_one.trans_le ha) s]
refine' smul_set_mono (hst _ _)
rw [norm_inv]
exact inv_le_one ha
refine'
    (closed_nhds_basis 0).to_has_basis (fun s hs => _) fun s hs => ⟨s, ⟨hs.1, hs.2.1⟩, rfl.subset⟩
refine' ⟨balancedCore 𝕜 s, ⟨balanced_core_mem_nhds_zero hs.1, _⟩, balanced_core_subset s⟩
exact ⟨hs.2.balancedCore, balancedCoreBalanced s⟩
simp only [basis_sets, mem_Union, mem_singleton_iff]
rw [Finset.sup_singleton]
let i := Classical.arbitrary ι
refine' set.nonempty_def.mpr ⟨(p i).ball 0 1, _⟩
exact p.basis_sets_singleton_mem i zero_lt_one
simp only [is_bounded, forall_const]
simp [Seminorm.bot_eq_zero]
intro i hi
refine' le_trans (And.right (hf i)) (smul_le_smul _ (Finset.le_sup hi))
exact Finset.sup_mono (Finset.subset_bUnion_of_mem fₛ hi)
rw [congr_fun (congr_arg (@nhds E) hp.1) 0]
exact AddGroupFilterBasis.nhds_zero_has_basis _
refine'
    ⟨TopologicalAddGroup.ext inferInstance p.add_group_filter_basis.is_topological_add_group _⟩
rw [AddGroupFilterBasis.nhds_zero_eq]
exact h
rw [← p.filter_eq_infi]
refine' ⟨fun h => _, p.with_seminorms_of_nhds⟩
rw [h.topology_eq_with_seminorms]
exact AddGroupFilterBasis.nhds_zero_eq _
refine' Seminorm.continuous _
rw [p.with_seminorms_iff_nhds_eq_infi.mp hp, ball_zero_eq_preimage_ball]
exact Filter.mem_infi_of_mem i (Filter.preimage_mem_comap <| Metric.ball_mem_nhds _ one_pos)
rw [p.with_seminorms_iff_nhds_eq_infi,
    TopologicalAddGroup.ext_iff inferInstance (topological_add_group_infi fun i => inferInstance),
    nhds_infi]
trace
    "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr «expr = »(_, «expr⨅ , »((i), _))]]"
exact @comap_norm_nhds_zero _ (p i).toAddGroupSeminorm.toSeminormedAddGroup
all_goals infer_instance
rw [p.with_seminorms_iff_nhds_eq_infi,
    UniformAddGroup.ext_iff inferInstance (uniform_add_group_infi fun i => inferInstance),
    to_topological_space_infi, nhds_infi]
trace
    "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr «expr = »(_, «expr⨅ , »((i), _))]]"
exact @comap_norm_nhds_zero _ (p i).toAddGroupSeminorm.toSeminormedAddGroup
all_goals infer_instance
rw [← Seminorm.is_bounded_const (Fin 1)] at hf
exact continuous_from_bounded hp (normWithSeminorms 𝕜₂ F) f hf
rw [← Seminorm.const_is_bounded (Fin 1)] at hf
exact continuous_from_bounded (normWithSeminorms 𝕜 E) hq f hf
rw [hf.induced]
exact f.with_seminorms_induced hq
rw [p.with_seminorms_iff_nhds_eq_infi.mp hp]
exact Filter.Infi.is_countably_generated _
simp only [map_zero, norm_zero, zero_le_one]
refine' set.eq_univ_iff_forall.mpr fun y x hx => _
rw [set.mem_singleton_iff.mp hx, map_zero, LinearMap.zero_apply, norm_zero]
exact zero_le_one
rw [B.flip_apply]
exact hy x hx
rw [polar_eq_Inter]
refine' is_closed_Inter fun x => is_closed_Inter fun _ => _
exact is_closed_le (WeakBilin.eval_continuous B.flip x).norm continuous_const
simp only [zero_mem_polar]
rw [B.map_smul, LinearMap.smul_apply, Algebra.id.smul_eq_mul, norm_mul, norm_inv,
        mul_inv_cancel_left₀ hc.ne']
rw [metric.nhds_basis_ball.is_vonN_bounded_basis_iff, ← ball_norm_seminorm 𝕜 E]
exact fun ε hε => (normSeminorm 𝕜 E).ballZeroAbsorbsBallZero hε
rw [NormedSpace.is_vonN_bounded_iff, ← Metric.bounded_iff_is_bounded, bounded_iff_forall_norm_le]
rw [Bornology.ext_iff_is_bounded]
intro s
rw [Bornology.is_bounded_iff_is_vonN_bounded]
exact is_vonN_bounded_iff 𝕜 E s
rw [inv_smul_smul₀ x_ne _]
        
    -- Using this inclusion, it suffices to show that `x⁻¹ • V` is in `𝓝 0`, which is trivial.
simp
apply bE.tendsto
intro n
rw [IsROrC.norm_eq_abs, IsROrC.abs_cast_nat]
exact hn.le
rw [hi'']
exact h.1
refine' forall_imp (fun x => _) hA
exact Exists.imp fun r => And.imp_right <| forall₂_imp fun a ha hx => Set.smul_set_mono hAB hx
rw [← Set.bUnion_of_singleton v]
exact hv.absorbs_Union.mpr fun _ _ => hs.absorbs
rw [smul_set_empty]
refine' ⟨1, zero_lt_one, fun a ha x hx => _⟩
rw [mem_smul_set_iff_inv_smul_mem₀ (norm_pos_iff.1 <| zero_lt_one.trans_le ha)]
refine' hA a
refine' fun x => ⟨1, zero_lt_one, fun a ha => _⟩
rw [smul_set_univ₀ (norm_pos_iff.1 <| zero_lt_one.trans_le ha)]
exact trivial
rw [← union_eq_self_of_subset_left (singleton_subset_iff.2 h)]
exact balancedZeroUnionInterior hA
rw [balanced_iff_smul_mem] at hs⊢
refine' fun a ha x hx => convex_hull_min _ this hx a ha
exact fun y hy a ha => subset_convex_hull ℝ s (hs ha hy)
simp only [Seminorm.ball_zero_eq, to_seminorm_apply]
simp only [s.finite_to_set]
refine'
    (LocallyConvexSpace.convex_basis_zero ℝ E).to_has_basis (fun s hs => _) fun s hs =>
      ⟨s, ⟨hs.1, hs.2.2⟩, rfl.subset⟩
refine' ⟨convexHull ℝ (balancedCore 𝕜 s), _, convex_hull_min (balanced_core_subset s) hs.2⟩
refine' ⟨Filter.mem_of_superset (balanced_core_mem_nhds_zero hs.1) (subset_convex_hull ℝ _), _⟩
refine' ⟨balancedConvexHullOfBalanced (balancedCoreBalanced s), _⟩
exact convex_convex_hull ℝ (balancedCore 𝕜 s)
rw [← exists_true_iff_nonempty]
dsimp only [AbsConvexOpenSets]
rw [Subtype.exists]
exact ⟨Set.univ, ⟨mem_univ 0, is_open_univ, balancedUniv, convex_univ⟩, trivial⟩
simp [Seminorm.mem_ball_zero, hr]
simp [abs_of_pos hr]
simp [ne_of_gt hr]
rw [hx, dist_comm]
erw [e.dist_eq x z]
      
  -- On the other hand, consider the map `f : (E ≃ᵢ E) → (E ≃ᵢ E)`
  -- sending each `e` to `R ∘ e⁻¹ ∘ R ∘ e`, where `R` is the point reflection in the
  -- midpoint `z` of `[x, y]`.
intro e
dsimp [f]
rw [dist_point_reflection_fixed, ← e.dist_eq, e.apply_symm_apply,
      dist_point_reflection_self_real, dist_comm]
  -- Also note that `f` maps `s` to itself
simp
simp
simp only [← dist_zero_right, ← h0, f.dist_eq]
simp
rw [norm_smul, mem_sphere_zero_iff_norm.1 c.coe_prop, mem_sphere_zero_iff_norm.1 x.coe_prop,
          one_mul]
simp only [star, id.def, norm_mul]
intro x
rw [← norm_star_mul_self, star_star]
rw [norm_star_mul_self, norm_star]
rw [← norm_eq_zero, norm_star_mul_self]
exact mul_self_eq_zero.trans norm_eq_zero
simp only [Ne.def, star_mul_self_eq_zero_iff]
simp only [Ne.def, mul_star_self_eq_zero_iff]
simp
rw [← sq_eq_sq (norm_nonneg _) zero_le_one, one_pow 2, sq, ← CstarRing.norm_star_mul_self,
    unitary.coe_star_mul_self, CstarRing.norm_one]
rw [norm_coe_unitary, one_mul]
rw [unitary.coe_star_mul_self U, one_mul]
rw [mul_assoc]
exact norm_mul_le _ _
rw [norm_star, norm_coe_unitary, one_mul]
simp only [star_star, star_mul]
rw [norm_star]
simp only [Matrix.mul_apply, Matrix.conj_transpose_apply, ← star_ring_end_apply,
      IsROrC.mul_conj, IsROrC.norm_sq_eq_def', IsROrC.of_real_pow]
  -- The L2 norm of a row is a diagonal entry of U ⬝ Uᴴ, real part
simp only [mul_eq_one, eq_self_iff_true, Matrix.one_apply_eq, IsROrC.one_re]
  -- Putting it all together
unfold spectralRadius
rw [spectrum.gelfand_transform_eq]
exact fun x => this.symm ▸ (gelfand_transform ℂ A).mem_range.mp (this.symm ▸ Algebra.mem_top)
  /- Because the `gelfand_transform ℂ A` is an isometry, it has closed range, and so
simp only [h.eq, Algebra.smul_mul_assoc, Algebra.mul_smul_comm]
rw [← h.exp_unitary_add, ← h.symm.exp_unitary_add, add_comm]
simp
rw [lipschitzExtensionConstant]
exact zero_lt_one.trans_le (le_max_right _ _)
apply A.lipschitz
apply A.symm.lipschitz
simp only [le_rank_iff_exists_linear_independent_finset, set_of_exists, ← exists_prop]
refine' is_open_bUnion fun t ht => _
have : Continuous fun f : E →L[𝕜] F => fun x : (t : Set E) => f x :=
    continuous_pi fun x => (ContinuousLinearMap.apply 𝕜 F (x : E)).Continuous
exact is_open_set_of_linear_independent.preimage this
change Continuous v.equiv_fun.symm.to_fun
exact v.equiv_fun.symm.to_linear_map.continuous_of_finite_dimensional
rw [v.sum_equiv_fun]
simp [u.map_sum, LinearMap.map_smul]
simp only [nnnorm_smul]
simp only [smul_mul_assoc, mul_right_comm]
infer_instance
rw [eq_div_iff (two_ne_zero : (2 : ℝ) ≠ 0), mul_comm, ← mul_assoc,
        mul_div_cancel' _ (ne_of_gt h_2C)]
simp [Φ, hxy, dist_comm]
infer_instance
refine' continuous_pi fun i => _
exact (ContinuousLinearMap.apply 𝕜 E (Pi.single i 1)).Continuous
rw [← closure_eq_interior_union_frontier]
exact subset_closure hx
rw [AffineMap.continuous_linear_iff]
exact f.cont
rw [norm_def]
rw [h, norm_zero]
simp
simp
simp only [Pi.add_apply, add_cont_linear, coe_add, max_le_iff]
exact
          ⟨(norm_add_le _ _).trans (add_le_add (le_max_left _ _) (le_max_left _ _)),
            (norm_add_le _ _).trans (add_le_add (le_max_right _ _) (le_max_right _ _))⟩
simp only [norm_def, smul_cont_linear, coe_smul, Pi.smul_apply, norm_smul, ←
      mul_max_of_nonneg _ _ (norm_nonneg t)]
simp
rw [f.decomp]
simp
rw [le_add_iff_nonneg_right]
apply norm_nonneg
simp
rw [← dist_eq_norm, ← dist_eq_norm, ← dist_eq_norm]
exact dist_triangle _ _ _
simp [his, add_comm, left_distrib]
apply prod_le_prod
· intro j hj
rw [prod_update_of_mem (Finset.mem_univ _)]
simp [card_univ_diff]
simp
simp [zero_le_one, norm_le_of_mem_closed_ball (le_of_lt h'), -add_comm]
trace
        "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr mul_le_mul_of_nonneg_right, \",\", expr mul_le_mul_of_nonneg_left, \",\", expr mul_nonneg, \",\", expr norm_nonneg, \",\", expr nat.cast_nonneg, \",\", expr pow_le_pow_of_le_left, \"]\"],\n  []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
simp
rw [add_mul]
exact norm_add_le_of_le (le_op_norm _ _) (le_op_norm _ _)
simp
intro m
erw [norm_smul, mul_assoc]
exact mul_le_mul_of_nonneg_left (le_op_norm _ _) (norm_nonneg _)
simp only [norm_def, coe_restrict_scalars]
simp
simp
simp [A, -add_comm, zero_le_one]
rw [dist_eq_norm, dist_eq_norm]
trace
        "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr add_le_add, \",\", expr mul_le_mul, \",\", expr le_refl, \",\", expr le_trans (norm_fst_le q)\n   A, \",\", expr nat.cast_nonneg, \",\", expr mul_nonneg, \",\", expr pow_le_pow_of_le_left, \",\", expr pow_nonneg, \",\", expr norm_snd_le\n   «expr - »(q, p), \",\", expr norm_nonneg, \",\", expr norm_fst_le «expr - »(q, p), \",\", expr prod_nonneg, \"]\"],\n  []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
have A := hF (Function.update v i (x + y))
have B := (hF (Function.update v i x)).add (hF (Function.update v i y))
simp at A B
exact tendsto_nhds_unique A B
refine' eventually_at_top.2 ⟨n, fun m hm => _⟩
apply le_trans ((f n - f m).le_op_norm _) _
exact mul_le_mul_of_nonneg_right (b_bound n m n le_rfl hm) (nonneg v)
apply MultilinearMap.mk_continuous_norm_le
exact mul_nonneg (norm_nonneg _) (pow_nonneg (norm_nonneg _) _)
have := fun f => @op_norm_le_bound 𝕜 ι (fun i => A) A _ _ _ _ _ _ _ f _ zero_le_one
refine' this _ _
intro m
simp only [ContinuousMultilinearMap.mk_pi_algebra_apply, one_mul]
exact norm_prod_le' _ univ_nonempty _
have := fun f => @op_norm_le_bound 𝕜 (Fin n.succ) (fun i => A) A _ _ _ _ _ _ _ f _ zero_le_one
refine' this _ _
intro m
simp only [ContinuousMultilinearMap.mk_pi_algebra_fin_apply, one_mul, List.of_fn_eq_map,
    Fin.prod_univ_def, Multiset.coe_map, Multiset.coe_prod]
refine' (List.norm_prod_le' _).trans_eq _
· rw [Ne.def, List.map_eq_nil, List.fin_range_eq_nil]
    exact Nat.succ_ne_zero _
rw [List.map_map]
simp only [MultilinearMap.mk_pi_ring_apply, norm_smul, norm_prod, mul_comm]
rw [← to_multilinear_map_inj.eq_iff]
exact MultilinearMap.mk_pi_ring_eq_iff
rw [← mk_pi_field_zero, mk_pi_field_eq_iff]
simp
rw [one_mul]
exact f.norm_comp_continuous_multilinear_map_le g
simp only [map_add, ContinuousMultilinearMap.add_apply]
simp only [ContinuousMultilinearMap.smul_apply, map_smul, RingHom.id_apply]
rw [mul_right_comm]
exact (f x).le_of_op_norm_le _ (f.le_op_norm x)
rw [max_mul_of_nonneg _ _ (norm_nonneg x), zero_mul]
dsimp only [mk_continuous_linear]
exact LinearMap.mk_continuous_norm_le _ (le_max_right _ _) _
rw [max_mul_of_nonneg, zero_mul]
exact prod_nonneg fun _ _ => norm_nonneg _
dsimp only [mk_continuous_multilinear]
exact mk_continuous_norm_le _ (le_max_right _ _) _
rw [prod_mul_distrib, mul_assoc]
rw [prod_univ_succ]
rfl
rw [prod_univ_cast_succ]
rfl
rw [prod_univ_succ]
simp [mul_assoc]
rw [prod_univ_cast_succ]
simp [mul_assoc]
simp
simp
simp
rfl
simp
rfl
simp
simp
simp [-ContinuousMultilinearMap.apply_zero_curry0]
simp
rw [← σ.prod_comp]
rw [← σ.symm.prod_comp]
simp only [σ.symm_apply_apply]
simp only [σ.apply_symm_apply]
refine' (curry_fin_finset_symm_apply_piecewise_const hk hl _ _ _).symm.trans _
  -- `rw` fails
rw [LinearIsometryEquiv.symm_apply_apply]
simp only [← coe_smul, norm_coe, norm_smul]
apply completion.induction_on₂ x y <;> clear x y
· refine' is_closed_eq (completion.uniform_continuous_extension₂ _).Continuous _
        exact Continuous.comp completion.continuous_extension continuous_sub
· intro x y
        rw [← completion.coe_sub, norm_coe, completion.dist_eq, dist_eq_norm]
apply completion.induction_on₂ x y <;> clear x y
·
        exact
          is_closed_le (Continuous.comp continuous_norm continuous_mul)
            (Continuous.comp Real.continuous_mul
              (Continuous.prod_map continuous_norm continuous_norm))
· intro x y
        simp only [← coe_mul, norm_coe]
        exact norm_mul_le x y
apply completion.induction_on x <;> clear x
·
        exact
          is_closed_le (Continuous.comp continuous_norm (continuous_const_smul r))
            (Continuous.comp (continuous_mul_left _) continuous_norm)
· intro x
        simp only [← coe_smul, norm_coe]
        exact NormedSpace.norm_smul_le r x
rw [ContinuousLinearMap.map_add, add_sub_cancel]
rw [← dist_eq_norm]
exact hn n (le_refl n)
simp only [norm_smul c x, Real.norm_eq_abs, abs_of_pos hc, mul_left_comm]
intro x
rfl
  -- Use the real version to get a norm-preserving extension of `fr`, which
  -- we'll call `g : F →L[ℝ] ℝ`.
rfl
rw [re_clm_norm, one_mul]
rw [norm_smul, IsROrC.norm_coe_norm, coord_norm, mul_inv_cancel (mt norm_eq_zero.mp h)]
let p : Submodule 𝕜 E := 𝕜
rw [coe_mk]
rw [← hg.1]
simp
simp
rw [← Submodule.coe_mk x₀ (Submodule.mem_span_singleton_self _), hφ₁,
      LinearPmap.mk_span_singleton'_apply_self]
simp
simp
rw [vadd_eq_add, sub_add_sub_cancel', sub_self]
intro hx₀
rw [← add_zero x₀] at hx₀
exact disj.zero_not_mem_sub_set (vadd_mem_vadd_set_iff.1 hx₀)
simp [← hf₁]
simp
simp
simp
simp
rw [Set.Inter_set_of]
refine' Set.Subset.antisymm (fun x hx => _) fun x hx l => ⟨x, hx, le_rfl⟩
rw [inclusion_in_double_dual_norm_eq]
exact ContinuousLinearMap.norm_id_le
rw [LinearMap.separating_left_iff_ker_eq_bot, LinearMap.ker_eq_bot]
exact ContinuousLinearMap.coe_injective
rw [hfx]
rw [hf₁, mul_one]
simp [h f]
simp [hx]
rw [← sub_eq_zero, eq_zero_iff_forall_dual_eq_zero 𝕜 (x - y)]
simp [sub_eq_zero]
dsimp only [NormedSpace.polar]
simp only [LinearMap.polar_eq_Inter, LinearMap.flip_apply]
refine' is_closed_bInter fun z hz => _
exact is_closed_Iic.preimage (ContinuousLinearMap.apply 𝕜 𝕜 z).Continuous.norm
intro z hzs
rw [Eq z]
apply mul_le_mul (le_of_eq rfl) (hc z hzs) (norm_nonneg _) (norm_nonneg _)
simp only [c_zero, norm_eq_zero, Ne.def, not_false_iff, inv_mul_cancel, norm_inv]
rw [mul_comm]
exact norm_smul _ _
simp [to_span_singleton, of_homothety, LinearMap.toSpanSingleton]
simp [norm_smul, hv]
simp only [h, mul_zero, norm_image_of_norm_zero f f.2 h]
simp only [norm_def, neg_apply, norm_neg]
apply hc
rw [norm_smul, norm_inv, norm_norm, inv_mul_cancel hx]
rw [zero_mul]
exact norm_zero
simp
erw [norm_smul, mul_assoc]
exact mul_le_mul_of_nonneg_left (le_op_norm _ _) (norm_nonneg _)
rw [← @UniformAddGroup.to_uniform_space_eq _ ContinuousLinearMap.tmpUniformSpace, ←
    @UniformAddGroup.to_uniform_space_eq _ ContinuousLinearMap.uniformSpace]
congr 1
exact ContinuousLinearMap.tmp_topology_eq
rw [mul_assoc]
exact h.le_op_norm_of_le (f.le_op_norm x)
rw [h x]
exact le_op_norm _ _
rw [← h z]
exact h₂ z
refine' le_antisymm _ (norm_nonneg _)
apply op_norm_le_bound _ rfl.ge
intro x
simp [Subsingleton.elim x 0]
simp
rw [max_mul_of_nonneg _ _ (norm_nonneg x), zero_mul]
rw [f.map_add, add_apply]
rw [f.map_smulₛₗ, smul_apply]
rw [mul_right_comm]
rw [mul_right_comm]
exact (flip f).le_op_norm₂ y x
simp
rw [e.has_sum, ContinuousLinearEquiv.symm_apply_apply]
refine' symm (e.tsum_eq_iff.mpr _)
rw [e.symm_apply_apply _]
rw [hf]
simp
simp only [map_add, add_apply, coe_deriv₂, add_assoc]
simp [r_pos]
rw [hn, zero_mul]
refine' (hε _).le
rw [f.map_zero, dist_zero_right]
exact hx.trans_lt (half_lt_self εpos)
simp [hx]
refine' h_dense.induction_on₂ _ _
·
        exact
          is_closed_eq (cont.comp continuous_add)
            ((cont.comp continuous_fst).add (cont.comp continuous_snd))
· intro x y
        simp only [Eq, ← e.map_add]
        exact f.map_add _ _
refine' fun b => h_dense.induction_on b _ _
·
        exact
          is_closed_eq (cont.comp (continuous_const_smul _)) ((continuous_const_smul _).comp cont)
· intro x
        rw [← map_smul]
        simp only [Eq]
        exact ContinuousLinearMap.map_smulₛₗ _ _ _
have uni : UniformInducing e := (uniform_embedding_of_bound _ h_e).to_uniform_inducing
have eq : ∀ x, ψ (e x) = f x := uniformly_extend_of_ind uni h_dense f.uniform_continuous
intro x
have N0 : N ≤ 0 := le_of_lt (lt_of_not_ge N0)
rw [← norm_le_zero_iff]
exact le_trans (h_e x) (mul_nonpos_of_nonpos_of_nonneg N0 (norm_nonneg _))
rw [hf]
apply extend_zero
simp
simp only [norm_map, coe_to_continuous_linear_map, coe_comp']
simp only [coe_smul_rightₗ, one_mul, norm_smul_right_apply, LinearMap.coe_mk]
rw [add_comp, comp_add]
rw [smul_comp, comp_smulₛₗ]
rw [← coe_nnnorm, Int.nnnorm_coe_units, Nnreal.coe_one]
rw [← Nat.cast_add, to_nat_add_to_nat_neg_eq_nat_abs, Nnreal.coe_nat_abs]
rw [convex_hull_affine_basis_eq_nonneg_barycentric b, set_of_forall]
rfl
refine' fun y => hεu _
simp only [f]
rw [Metric.mem_closed_ball, line_map_apply, dist_vadd_left, norm_smul, Real.norm_eq_abs,
      dist_eq_norm_vsub V y q, abs_div, abs_of_pos ε0, abs_of_nonneg (norm_nonneg _), div_mul_comm]
exact mul_le_of_le_one_left ε0.le (div_self_le_one _)
rw [← interior_convex_hull_nonempty_iff_affine_span_eq_top, hs.convex_hull_eq]
intro φ hφ
rw [Set.mem_preimage, mem_closed_ball_zero_iff]
exact (norm_le_norm_one ⟨φ, ⟨hφ.1, hφ.2⟩⟩ : _)
rw [image_subset_iff, preimage_smul_setₛₗ _ _ _ f this.is_unit] <;> exact hrS c hc.le
rw [sub_eq_add_neg] <;> exact hf.add hg.neg
rw [ContinuousLinearMap.sub_apply] <;> rfl
simp [dist_eq_norm, lt_of_le_of_lt ydlt.le (half_lt_self εpos)]
simp
exact εpos
apply add_le_add
· rw [← dist_eq_norm, dist_comm]
              exact le_of_lt h₁
· rw [← dist_eq_norm, dist_comm]
              exact le_of_lt h₂
rw [mul_smul, smul_sub]
rw [norm_smul, norm_inv]
apply mul_le_mul_of_nonneg_left I
rw [inv_nonneg]
exact norm_nonneg _
rw [inv_mul_cancel, one_mul]
simp [norm_eq_zero, hd]
rw [norm_smul, norm_inv]
refine' mul_le_mul dinv _ (norm_nonneg _) _
· exact le_trans (norm_sub_le _ _) (add_le_add (le_of_lt hx₁) (le_of_lt hx₂))
· apply mul_nonneg (mul_nonneg _ (norm_nonneg _)) (norm_nonneg _)
              exact inv_nonneg.2 (le_of_lt (half_pos εpos))
intro y
rw [← dist_eq_norm, dist_comm]
exact (hg y).1
rw [tsum_geometric_two, mul_assoc]
rw [f.map_add, wim, fxy, add_sub_cancel'_right]
rw [dist_eq_norm]
simp
rw [nonlinear_right_inverse_of_surjective]
exact Classical.choose_spec (exists_nonlinear_right_inverse_of_surjective f hsurj)
rw [continuous_def]
intro s hs
rw [← e.image_eq_preimage]
rw [← e.coe_coe] at h⊢
exact ContinuousLinearMap.is_open_map ⟨↑e, h⟩ e.surjective s hs
rw [ker_coprod_of_disjoint_range]
· rw [hker, Submodule.ker_subtypeL, Submodule.prod_bot]
· rw [Submodule.range_subtypeL]
        exact h.disjoint
simp only [range_coprod, h.sup_eq_top, Submodule.range_subtypeL]
rw [coprod_subtypeL_equiv_of_is_compl, _root_.coe_coe, ContinuousLinearEquiv.coe_of_bijective,
    coe_coprod, LinearMap.coprod_map_prod, Submodule.map_bot, sup_bot_eq, Submodule.map_top]
rfl
simp only [norm_indicator_eq_indicator_norm]
exact indicator_le_indicator_of_subset ‹_› (fun _ => norm_nonneg _) _
rw [norm_indicator_eq_indicator_norm]
apply indicator_norm_le_norm_self
infer_instance
rw [inv_smul_smul₀ h]
rw [norm_inv, ← mul_assoc, mul_inv_cancel (mt norm_eq_zero.1 h), one_mul]
rw [← norm_smul, ← Int.smul_one_eq_coe, smul_assoc, one_smul]
simp only [mem_closed_ball_zero_iff, norm_smul, norm_inv, norm_norm, ← div_eq_inv_mul,
    div_self_le_one]
simp only [dist_eq_norm, (norm_smul _ _).symm, smul_sub]
rw [dist_smul, coe_nnnorm]
rw [norm_smul, Real.norm_eq_abs, abs_of_nonneg ht]
simp
rw [frontier, closure_closed_ball, interior_closed_ball x hr, closed_ball_diff_ball]
simp [homeomorphUnitBall]
simp [Prod.norm_def, norm_smul, mul_max_of_nonneg]
simp only [(Nnreal.coe_mul _ _).symm, Nnreal.mul_finset_sup, nnnorm_smul]
rw [norm_zpow]
exact lt_trans xεpos hn.2
unfold norm
exact (map_smul f a b).symm ▸ (norm_smul a (f b)).le
rw [frontier, closure_closed_ball, interior_closed_ball' x r, closed_ball_diff_ball]
infer_instance
rw [Algebra.algebra_map_eq_smul_one]
exact norm_smul _ _
rw [norm_algebra_map, norm_one, mul_one]
refine' Isometry.ofDistEq fun x y => _
rw [dist_eq_norm, dist_eq_norm, ← RingHom.map_sub, norm_algebra_map']
rw [← smul_one_smul ℝ q x, Rat.smul_one_eq_coe, norm_smul, Rat.norm_cast_real]
simp only [PUnit.norm_eq_zero, mul_zero]
unfold norm
exact (map_smul f a b).symm ▸ (norm_smul a (f b)).le
rw [norm_algebra_map']
cases e₁ <;> cases e₂ <;> congr <;> exact h
rw [inv_smul_smul₀ hc]
rw [← map_smul, neg_one_smul]
simp
rw [← neg_sub, e.map_neg]
rw [sub_eq_add_neg]
rw [e.map_neg]
simp [h]
simp [top_map h]
simp only [map_smul, Ennreal.mul_max]
simp
simp [sub_eq_zero]
rw [sub_add_sub_cancel]
simp
simp [finite_norm_eq, Ennreal.to_real_mul]
rw [norm_neg]
simp [mul_add]
simp
rw [← inverse_unit (Units.oneSub t h), Units.coe_one_sub]
simp only [Units.coe_one_sub]
rw [geom_sum_mul_neg]
simp
rw [norm_neg]
refine' mul_nonneg _ _ <;> exact pow_nonneg (norm_nonneg _) n
refine' tendsto_zero_iff_norm_tendsto_zero.mpr _
exact tendsto_iff_norm_tendsto_zero.mp tendsto_id
simp
infer_instance
infer_instance
simp only [polar_def, set_of_forall]
exact is_closed_bInter fun x hx => is_closed_Iic.preimage (WeakBilin.eval_continuous _ _).norm
simp [homothety_def, norm_smul, ← dist_eq_norm_vsub, dist_comm]
rw [dist_comm, dist_center_homothety]
rw [dist_comm p₁ p₂]
simp only [line_map_apply, dist_eq_norm_vsub, vadd_vsub_vadd_cancel_right, ← sub_smul, norm_smul,
    vsub_eq_sub]
rw [homothety_eq_line_map, dist_line_map_right]
rw [dist_comm, dist_homothety_self]
rw [midpoint, dist_comm, dist_line_map_left, invOf_eq_inv, ← norm_inv]
rw [dist_comm, dist_left_midpoint]
rw [midpoint_comm, dist_midpoint_left, dist_comm]
rw [dist_comm, dist_midpoint_right]
rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, dist_eq_norm_vsub V, midpoint_vsub_midpoint] <;>
    try infer_instance
rw [midpoint_eq_smul_add, norm_smul, invOf_eq_inv, norm_inv, ← div_eq_inv_mul]
exact div_le_div_of_le_of_nonneg (norm_add_le _ _) (norm_nonneg _)
rw [dist_line_map_line_map, Nnreal.coe_inv, ← dist_nndist, mul_left_comm,
      inv_mul_cancel (dist_ne_zero.2 h), mul_one]
simp
simp [h]
trace
          "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr continuous.vadd, \",\", expr continuous.vsub, \",\", expr continuous_const, \",\", expr hfc.comp, \",\", expr continuous_id, \"]\"],\n  []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
simp
dsimp [edist]
exact if_neg Ennreal.top_ne_zero
dsimp [dist]
exact if_neg Ennreal.top_ne_zero
dsimp [norm]
exact if_neg Ennreal.top_ne_zero
apply Ennreal.rpow_le_rpow _ (one_div_nonneg.2 <| zero_le_one.trans hp)
refine' Finset.sum_le_sum fun i hi => _
exact Ennreal.rpow_le_rpow (edist_triangle _ _ _) (zero_le_one.trans hp)
simp [← Ennreal.rpow_mul, cancel, -one_div]
apply Ennreal.rpow_le_rpow _ nonneg
apply Finset.sum_le_sum fun i hi => _
apply Ennreal.rpow_le_rpow _ (le_of_lt Pos)
exact Finset.le_sup (Finset.mem_univ i)
have := p.to_real_pos_iff_ne_top.mpr (ne_of_eq_of_ne h <| Ennreal.nat_ne_top n)
simp only [one_div, h, Real.rpow_nat_cast, Ennreal.to_real_nat, eq_self_iff_true,
    Finset.sum_congr, norm_eq_sum this]
simp [PiLp.edist_eq_sum]
funext x
simp [LinearIsometryEquiv.piLpCongrLeft, LinearEquiv.piCongrLeft', Equiv.piCongrLeft', Pi.single,
    Function.update, Equiv.symm_apply_eq]
simp
simp
rw [add_comm, sub_sub_cancel]
exact h.Lnorm x
rw [h₃.proj.eq, sub_smul 1 P, one_smul, smul_sub, mul_smul]
rw [sub_mul, h₃.proj.eq, one_mul, sub_self, zero_smul, zero_sub, norm_neg]
rw [PR_eq_RPR (1 - Q) h₂.Lcomplement]
rw [sub_smul, one_smul]
rw [sub_add_sub_cancel', sub_smul, one_smul, mul_smul]
simp only [coe_inf] at h₁ h₂⊢
rw [h₁, mul_assoc, ← h₂]
rw [IsIdempotentElem, zero_mul]
simp only [zero_smul, norm_zero, sub_zero, one_smul, zero_add]
rw [coe_compl, sub_mul, one_mul]
rw [coe_compl, mul_sub, mul_one, P.prop.proj.eq, sub_self]
rw [le_def, coe_inf, coe_sup, ← add_sub, mul_add, mul_sub, ← mul_assoc, P.prop.proj.eq,
        sub_self, add_zero]
rw [le_def, coe_inf, coe_sup, ← add_sub, mul_add, mul_sub, Commute.eq (Commute P.prop Q.prop),
        ← mul_assoc, Q.prop.proj.eq, add_sub_cancel'_right]
rw [le_def, le_def, le_def, coe_inf, coe_inf, coe_sup, coe_inf, coe_sup, ← add_sub, add_mul,
        sub_mul, mul_assoc]
intro h₁ h₂
rw [← h₂, ← h₁]
rw [le_def, coe_inf, coe_inf, coe_inf, mul_assoc, (Q.prop.commute P.prop).Eq, ← mul_assoc,
        P.prop.proj.eq]
rw [le_def, coe_inf, coe_inf, coe_inf, mul_assoc, Q.prop.proj.eq]
rw [le_def, le_def, le_def, coe_inf, coe_inf, coe_inf, coe_inf, ← mul_assoc]
intro h₁ h₂
rw [← h₁, ← h₂]
rw [coe_inf, coe_compl, coe_bot, ← coe_compl, mul_compl_self]
rw [coe_top, coe_sup, coe_compl, add_sub_cancel'_right, ← coe_compl, mul_compl_self,
              sub_zero]
rw [coe_sdiff, ← coe_compl, coe_inf]
simp only [norm_eq_supr_norm, lp.norm_eq_csupr]
rfl
simp [le_refl]
simp [le_refl]
refine' (LinearMap.fst 𝕜 E F).is_linear.withBound 1 fun x => _
rw [one_mul]
exact le_max_left _ _
refine' (LinearMap.snd 𝕜 E F).is_linear.withBound 1 fun x => _
rw [one_mul]
exact le_max_right _ _
rw [add_mul]
rw [(hf.mk' _).map_sub e x] <;> rfl
rw [one_mul]
apply ContinuousMultilinearMap.op_norm_le_bound _ (norm_nonneg _) fun m => _
rw [ContinuousMultilinearMap.prod_apply, norm_prod_le_iff]
constructor
·
          exact
            (p.1.le_op_norm m).trans
              (mul_le_mul_of_nonneg_right (norm_fst_le p)
                (Finset.prod_nonneg fun i hi => norm_nonneg _))
·
          exact
            (p.2.le_op_norm m).trans
              (mul_le_mul_of_nonneg_right (norm_snd_le p)
                (Finset.prod_nonneg fun i hi => norm_nonneg _))
apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)
exact Finset.prod_le_prod (fun i hi => norm_nonneg _) fun i hi => g.le_op_norm _
rw [f.map_add, add_apply]
rw [f.map_zero, zero_apply]
rw [f.map_smulₛₗ, smul_apply]
rw [f.map_sub, sub_apply]
rw [f.map_neg, neg_apply]
rw [f.map_smul, smul_apply]
trace
            "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr mul_le_mul_of_nonneg_right, \",\", expr norm_nonneg, \",\", expr le_max_left, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
simp [sub_eq_add_neg]
simp only [h.add_left, h.smul_left]
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
simp only [h.add_right, h.smul_right]
simp [sub_eq_add_neg]
simp
simp
simp [zero_le_one]
trace
            "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr norm_nonneg, \",\", expr mul_le_mul_of_nonneg_left, \",\", expr le_of_lt C_pos, \",\", expr mul_nonneg, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
simp
simp [zero_le_one]
trace
            "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr mul_le_mul_of_nonneg_right, \",\", expr norm_nonneg, \",\", expr mul_le_mul_of_nonneg_left, \",\", expr le_of_lt\n   C_pos, \"]\"],\n  []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
apply add_le_add
exact
          mul_le_mul_of_nonneg_left (le_max_right _ _) (mul_nonneg (le_of_lt Cpos) (norm_nonneg _))
apply mul_le_mul_of_nonneg_right _ (norm_nonneg _)
exact mul_le_mul_of_nonneg_left (le_max_left _ _) (le_of_lt Cpos)
trace
          "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr add_le_add, \",\", expr mul_le_mul, \",\", expr norm_nonneg, \",\", expr Cpos.le, \",\", expr le_refl, \",\", expr le_max_left, \",\", expr le_max_right, \",\", expr mul_nonneg, \"]\"],\n  []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
simp
intro c x
rw [← of_real_mul]
congr 1
rw [IsROrC.of_real_alg, smul_assoc, fr.map_smul, Algebra.id.smul_eq_mul, one_smul]
intro c x
rw [← re_add_im c, add_smul, add_smul, add, smul_ℝ, ← smul_smul, smul_ℝ, smul_I, ← mul_assoc]
rfl
rw [lm.map_smul, smul_eq_mul]
rw [div_mul_eq_mul_div, inv_mul_cancel h]
rw [← of_real_one, ← of_real_div, of_real_im]
rw [of_real_im]
rw [ht, one_mul]
rw [← norm_eq_abs, norm_mul]
rw [← smul_eq_mul, lm.map_smul]
rw [h1]
rw [norm_eq_abs, abs_of_real, norm_eq_abs, abs_to_real]
rw [norm_smul]
rw [norm_eq_abs, ht, one_mul]
rw [dist_eq_norm_vsub V₂, dist_eq_norm_vsub V, ← map_vsub, f.linear_isometry.norm_map]
simp [nndist_dist]
simp [edist_dist]
rw [← coe_to_isometric]
exact Isometric.range_eq_univ _
rw [← (point_reflection 𝕜 x).dist_map y x, point_reflection_self]
rw [point_reflection_apply, dist_eq_norm_vsub V, vadd_vsub_assoc, bit0]
rw [dist_point_reflection_self, Real.norm_two]
rw [← dist_eq_norm]
exact (lt_div_iff' hlt).1 hxy₀
rw [sub_sub, dist_eq_norm]
simp [hy', Submodule.smul_mem _ _ hy]
simp [hy', smul_smul, mul_inv_cancel d0]
simp [hy', Submodule.smul_mem _ _ hy]
simp [yy', ← smul_sub, norm_smul]
simp [spectralRadius]
simp [norm_le_norm_mul_of_mem hk]
simp [norm_le_norm_of_mem hk]
refine' Ennreal.le_of_forall_lt_one_mul_le fun ε hε => _
rw [Set.nonempty_iff_ne_empty]
rw [eq_set_map_one_map_mul]
exact ⟨map_one f, map_mul f⟩
dsimp [Memℓp] <;> rw [if_pos rfl]
dsimp [Memℓp] <;> rw [if_neg Ennreal.top_ne_zero, if_pos rfl]
rw [Ennreal.to_real_pos_iff] at hp
dsimp [Memℓp]
rw [if_neg hp.1.ne', if_neg hp.2.Ne]
rw [sub_eq_add_neg]
exact hf.add hg.neg
subst hp <;> exact (lp.memℓp f).finite_dsupport.toFinset.card
dsimp [norm]
rw [dif_neg Ennreal.top_ne_zero, if_pos rfl]
rw [lp.norm_eq_csupr]
exact is_lub_csupr (lp.memℓp f)
dsimp [norm]
rw [Ennreal.to_real_pos_iff] at hp
rw [dif_neg hp.1.ne', if_neg hp.2.Ne]
rw [Real.zero_rpow hp.ne']
rw [norm_rpow_eq_tsum hp]
exact ((lp.memℓp f).Summable hp).HasSum
rw [lp.ext_iff, coe_fn_zero]
exact Real.rpow_left_inj_on hp.ne' (norm_nonneg' _) (norm_nonneg' _) this
rw [← Real.rpow_le_rpow_iff (norm_nonneg' _) hC hp, norm_rpow_eq_tsum hp]
exact hf
refine' Real.rpow_left_inj_on hp.ne' _ _ this
· exact norm_nonneg' _
· exact mul_nonneg (norm_nonneg _) (norm_nonneg' _)
have hp : 0 < p := ennreal.zero_lt_one.trans_le (Fact.out _)
simp [norm_const_smul hp.ne']
rw [lp.single_apply, dif_pos rfl]
rw [lp.single_apply, dif_neg hij]
intro i hi
simp [if_neg hi, Real.zero_rpow hp.ne']
intro i hi
rw [if_pos hi]
intro i hi
simp only [F, coe_fn_sum, lp.single_apply, if_pos hi, sub_self, eq_self_iff_true, coe_fn_sub,
      Pi.sub_apply, Finset.sum_apply, Finset.sum_dite_eq, sub_eq_self]
simp [Real.zero_rpow hp.ne']
simp only [Real.abs_rpow_of_nonneg (norm_nonneg _), abs_norm_eq_norm]
refine' continuous_finset_sum s _
intro a ha
have : Continuous fun f : ∀ a, E a => f a := continuous_apply a
exact this.norm.rpow_const fun _ => Or.inr hp''.le
rw [smul_ball hc, smul_zero, mul_one]
simp only [← ball_union_sphere, Set.smul_set_union, smul_ball hc, smul_sphere' hc]
simp only [hz, add_neg_cancel_left]
rw [smul_unit_ball hr.ne', Real.norm_of_nonneg hr.le]
rw [← add_div, div_self hεδ.ne']
rw [← add_div, div_self (add_pos_of_pos_of_nonneg hε hδ).ne']
simp [dist_comm x y, dist_comm y z, *]
rw [← add_div, div_self (add_pos hε hδ).ne']
rw [Disjoint.comm, disjoint_ball_closed_ball_iff hε hδ, add_comm, dist_comm] <;> infer_instance
rw [← cthickening_zero, cthickening_thickening le_rfl hδ, zero_add]
infer_instance
rw [← thickening_singleton, thickening_thickening hε hδ, thickening_singleton] <;> infer_instance
rw [← cthickening_singleton _ hδ, thickening_cthickening hε hδ, thickening_singleton] <;>
    infer_instance
rw [← thickening_singleton, cthickening_thickening hε hδ,
      cthickening_singleton _ (add_nonneg hε hδ.le)] <;>
    infer_instance
rw [← cthickening_singleton _ hδ, cthickening_cthickening hε hδ,
      cthickening_singleton _ (add_nonneg hε hδ)] <;>
    infer_instance
rw [ball_add, thickening_ball hε hδ, vadd_ball, vadd_eq_add] <;> infer_instance
rw [ball_add, thickening_closed_ball hε hδ, vadd_ball, vadd_eq_add] <;> infer_instance
rw [add_comm, ball_add_closed_ball hδ hε, add_comm, add_comm δ] <;> infer_instance
rw [(is_compact_closed_ball _ _).add_closed_ball hδ, cthickening_closed_ball hδ hε,
      vadd_closed_ball, vadd_eq_add, add_comm, add_comm δ] <;>
    infer_instance
rw [smul_closed_ball _ _ zero_le_one, smul_zero, mul_one]
rw [smul_closed_unit_ball, Real.norm_of_nonneg hr]
rw [smul_unit_ball_of_pos hr, vadd_ball_zero]
rw [smul_closed_unit_ball, Real.norm_of_nonneg hr, vadd_closed_ball_zero]
simp
simp [Subsingleton.elim x 0]
simp
simp [hx]
simp [hx]
apply h
rw [mem_sphere_zero_iff_norm]
exact norm_smul_inv_norm' r_pos.le z_zero
rw [hz₁, LinearMap.map_smul, smul_eq_mul]
rw [← mul_assoc, ← mul_assoc, div_mul_cancel _ r_ne_zero, mul_inv_cancel, one_mul]
simp only [z_zero, IsROrC.of_real_eq_zero, norm_eq_zero, Ne.def, not_false_iff]
simp only [norm_zero, mem_closed_ball, dist_zero_left, r_pos.le]
simp [expSeries]
rw [exp_eq_tsum]
exact Commute.tsum_right x fun n => (h.pow_right n).smul_right _
rw [div_eq_mul_inv, ← (Nat.cast_commute n ! (x ^ n)).inv_left₀.Eq, ← smul_eq_mul,
    exp_series_apply_eq, inv_nat_cast_smul_eq _ _ _ _]
change Summable (norm ∘ _)
rw [← exp_series_apply_eq']
exact norm_exp_series_summable_of_mem_ball x hx
rw [← exp_series_apply_eq']
exact exp_series_has_sum_exp_of_mem_ball x hx
rw [Emetric.mem_ball, ← neg_zero, edist_neg_neg]
exact hx
rw [Emetric.mem_ball, ← neg_zero, edist_neg_neg]
exact hx
change Summable (norm ∘ _)
rw [← exp_series_apply_eq_div' x]
exact norm_exp_series_summable_of_mem_ball x hx
rw [← exp_series_apply_eq_div' x]
exact exp_series_has_sum_exp_of_mem_ball x hx
rw [exp_series_radius_eq_top]
exact WithTop.zero_lt_top
rw [continuous_iff_continuous_on_univ, ← Metric.eball_top_eq_univ (0 : 𝔸), ←
    exp_series_radius_eq_top 𝕂 𝔸]
exact continuous_on_exp
rw [exp_sum_of_commute, Finset.noncomm_prod_eq_prod]
exact fun i hi j hj _ => Commute.all _ _
rw [exp_series_apply_eq, exp_series_apply_eq, inv_nat_cast_smul_eq 𝕂 𝕂']
rw [← coe_to_isometric]
exact Isometric.range_eq_univ _
simp
simp
refine' ⟨fun h => _, fun h => tendsto_at_top_of_leading_coeff_nonneg P h.1 h.2⟩
have : tendsto (fun x => P.leading_coeff * x ^ P.nat_degree) at_top at_top :=
    (is_equivalent_at_top_lead P).tendsto_at_top h
rw [tendsto_const_mul_pow_at_top_iff, ← pos_iff_ne_zero, nat_degree_pos_iff_degree_pos] at this
exact ⟨this.1, this.2.le⟩
simp only [← tendsto_neg_at_top_iff, ← eval_neg, tendsto_at_top_iff_leading_coeff_nonneg,
    degree_neg, leading_coeff_neg, neg_nonneg]
refine' ⟨fun h => _, fun h => _⟩
· have := P.is_equivalent_at_top_lead.tendsto_nhds h
simp [leading_coeff_eq_zero.1 hP]
refine' ⟨fun h => _, div_tendsto_zero_of_degree_lt P Q⟩
simp [hdeg, nat_degree]
refine' tendsto_abs_at_bot_at_top.comp (real.tendsto_log_nhds_within_zero.comp _)
rw [← sub_self c]
exact ((hasDerivAtId c).sub_const c).tendsto_punctured_nhds one_ne_zero
simp only [← interval_integrable_sub_inv_iff, sub_zero]
rw [_root_.abs_div, abs_abs]
exact div_le_one_of_le x.abs_im_le_abs (abs.nonneg x)
rw [← exp_mul_I, abs_mul_exp_arg_mul_I]
rw [hz, of_real_one, one_mul]
simp only [arg, map_mul, abs_cos_add_sin_mul_I, abs_of_nonneg hr.le, mul_one]
simp only [of_real_mul_re, of_real_mul_im, neg_im, ← of_real_cos, ← of_real_sin, ←
    mk_eq_add_mul_I, neg_div, mul_div_cancel_left _ hr.ne', mul_nonneg_iff_right_nonneg_of_pos hr]
rw [← one_mul (_ + _), ← of_real_one, arg_mul_cos_add_sin_mul_I zero_lt_one hθ]
simp [arg, le_refl]
rw [← abs_mul_exp_arg_mul_I x, ← abs_mul_exp_arg_mul_I y, h₁, h₂]
rw [sin_arg, le_div_iff (abs.pos h₀), zero_mul]
simp only [ext_abs_arg_iff, map_mul, map_div₀, abs_of_real, abs_abs,
    div_mul_cancel _ (abs.ne_zero hx), eq_self_iff_true, true_and_iff]
rw [← of_real_div, arg_real_mul]
exact div_pos (abs.pos hy) (abs.pos hx)
simp [arg, zero_le_one]
simp [arg, le_refl, not_le.2 (zero_lt_one' ℝ)]
simp [arg, le_refl]
simp [arg, le_refl]
simp [arg, hx]
rw [(arg_le_pi z).lt_iff_ne, not_iff_comm, not_or, not_le, not_not, arg_eq_pi_iff]
simp only [arg, hx_re.not_le, hx_im, if_true, if_false]
simp only [arg, hx_re.not_le, hx_im.not_le, if_false]
rw [← cos_arg h₂, Real.arccos_cos (arg_nonneg_iff.2 h₁) (arg_le_pi _)]
rw [← arg_conj, inv_def, mul_comm]
simp [hx]
rw [abs_le, arg_le_pi_div_two_iff, neg_pi_div_two_le_arg_iff, ← or_and_left, ← not_le,
    and_not_self_iff, or_false_iff]
rw [arg_of_im_pos hi, arg_of_im_neg (show (-x).im < 0 from Left.neg_neg_iff.2 hi)]
simp [neg_div, Real.arccos_neg]
rw [arg_of_im_neg hi, arg_of_im_pos (show 0 < (-x).im from Left.neg_pos_iff.2 hi)]
simp [neg_div, Real.arccos_neg, add_comm, ← sub_eq_add_neg]
rw [← one_mul (_ + _), ← of_real_one, arg_mul_cos_add_sin_mul_I_eq_to_Ioc_mod zero_lt_one]
rw [← one_mul (_ + _), ← of_real_one, arg_mul_cos_add_sin_mul_I_sub zero_lt_one]
rw [← one_mul (_ + _), ← of_real_one, arg_mul_cos_add_sin_mul_I_coe_angle zero_lt_one]
rw [div_eq_mul_inv, arg_mul_coe_angle hx (inv_ne_zero hy), arg_inv_coe_angle, sub_eq_add_neg]
rw [Real.Angle.to_real_coe_eq_self_iff_mem_Ioc]
exact arg_mem_Ioc _
rw [← Real.Angle.to_real_inj, arg_coe_angle_to_real_eq_arg]
simp
simp [log]
simp [log]
simp only [log_im, neg_pi_lt_arg]
simp only [log_im, arg_le_pi]
rw [log, exp_add_mul_I, ← of_real_sin, sin_arg, ← of_real_cos, cos_arg hx, ← of_real_exp,
    Real.exp_log (abs.pos hx), mul_add, of_real_div, of_real_div,
    mul_div_cancel' _ (of_real_ne_zero.2 <| abs.ne_zero hx), ← mul_assoc,
    mul_div_cancel' _ (of_real_ne_zero.2 <| abs.ne_zero hx), re_add_im]
rw [log, abs_exp, Real.log_exp, exp_eq_exp_re_mul_sin_add_cos, ← of_real_exp,
    arg_mul_cos_add_sin_mul_I (Real.exp_pos _) ⟨hx₁, hx₂⟩, re_add_im]
rw [← log_exp hx₁ hx₂, ← log_exp hy₁ hy₂, hxy]
rw [log_re, of_real_re, abs_of_nonneg hx]
rw [of_real_im, log_im, arg_of_real_of_nonneg hx]
simp [log_re]
rw [mul_comm, log_of_real_mul hr hx, add_comm]
simp [log]
simp [log]
simp [log]
simp [log]
simp [log]
rw [log_conj_eq_ite, if_neg h]
rw [log_inv_eq_ite, if_neg hx]
rw [exp_sub, div_eq_one_iff_eq (exp_ne_zero _)]
simp only [exp_eq_exp_iff_exp_sub_eq_one, exp_eq_one_iff, sub_eq_iff_eq_add']
rw [← comap_exp_nhds_zero, map_comap, range_exp, nhdsWithin]
rw [← comap_exp_comap_abs_at_top, map_comap, range_exp, inf_eq_left, le_principal_iff]
exact eventually_ne_of_tendsto_norm_at_top tendsto_comap 0
rw [div_eq_inv_mul]
exact (has_strict_deriv_at_log h₂).comp x h₁
rw [div_eq_inv_mul]
exact (has_strict_deriv_at_log h₂).HasDerivAt.comp x h₁
rw [div_eq_inv_mul]
exact (has_strict_deriv_at_log h₂).HasDerivAt.compHasDerivWithinAt x h₁
rw [exp_map_circle_apply, exp_mul_I, arg_cos_add_sin_mul_I ⟨h₁, h₂⟩]
rw [Subtype.ext_iff, exp_map_circle_apply, exp_map_circle_apply, exp_eq_exp_iff_exists_int]
refine' exists_congr fun n => _
rw [← mul_assoc, ← add_mul, mul_left_inj' I_ne_zero, ← of_real_one, ← of_real_bit0, ← of_real_mul,
    ← of_real_int_cast, ← of_real_mul, ← of_real_add, of_real_inj]
rw [Int.cast_one, one_mul]
induction θ using Real.Angle.induction_on
simp [Complex.exp_mul_I]
rw [← Real.Angle.coe_zero, Real.Angle.exp_map_circle_coe, exp_map_circle_zero]
induction θ₁ using Real.Angle.induction_on
induction θ₂ using Real.Angle.induction_on
exact exp_map_circle_add θ₁ θ₂
induction θ using Real.Angle.induction_on
rw [Real.Angle.exp_map_circle_coe, exp_map_circle_apply, exp_mul_I, ← of_real_cos, ← of_real_sin,
    ← Real.Angle.cos_coe, ← Real.Angle.sin_coe, arg_cos_add_sin_mul_I_coe_angle]
rw [deriv_zero_of_not_differentiable_at (mt differentiable_at_log_iff.1 (not_not.2 hx)), hx,
      inv_zero]
rw [div_eq_inv_mul]
exact (has_deriv_at_log hx).compHasDerivWithinAt x hf
rw [← has_deriv_within_at_univ] at *
exact hf.log hx
rw [div_eq_inv_mul]
exact (has_strict_deriv_at_log hx).comp x hf
simp
congr
rw [A y this]
intro y hy
have : 1 - y ≠ 0 := sub_ne_zero_of_ne (ne_of_gt (lt_of_le_of_lt hy.2 h))
simp [F, this]
have : (0 : ℝ) ≤ i + 1 := le_of_lt (Nat.cast_add_one_pos i)
rw [norm_eq_abs, abs_div, ← pow_abs, abs_of_nonneg this]
rw [log_div y_pos.ne' x_pos.ne']
rw [log_of_ne_zero hx.ne']
congr
exact abs_of_pos hx
rw [log_of_ne_zero hx, ← coe_exp_order_iso_apply, OrderIso.apply_symm_apply, Subtype.coe_mk]
rw [exp_log_eq_abs hx.ne']
exact abs_of_pos hx
rw [exp_log_eq_abs (ne_of_lt hx)]
exact abs_of_neg hx
rw [exp_log zero_lt_one, exp_zero]
rw [← log_abs x, ← log_abs (-x), abs_neg]
rw [sinh_eq, exp_neg, exp_log hx]
rw [cosh_eq, exp_neg, exp_log hx]
rw [log_neg_eq_log, log_exp]
rw [exp_log_eq_abs (mul_ne_zero hx hy), exp_add, exp_log_eq_abs hx, exp_log_eq_abs hy, abs_mul]
rw [exp_log_eq_abs (div_ne_zero hx hy), exp_sub, exp_log_eq_abs hx, exp_log_eq_abs hy, abs_div]
rw [← exp_le_exp, exp_log h, exp_log h₁]
rw [← exp_lt_exp, exp_log hx, exp_log hy]
rw [← exp_le_exp, exp_log hx]
rw [← exp_lt_exp, exp_log hx]
rw [← exp_le_exp, exp_log hy]
rw [← exp_lt_exp, exp_log hy]
rw [← log_one]
exact log_lt_log_iff zero_lt_one hx
rw [← log_one]
exact log_lt_log_iff h zero_lt_one
rw [← not_lt, log_neg_iff hx, not_lt]
rw [← not_lt, log_pos_iff hx, not_lt]
induction n
· rw [Int.ofNat_eq_coe, zpow_ofNat, log_pow, Int.cast_ofNat]
rw [zpow_negSucc, log_inv, log_pow, Int.cast_negSucc, Nat.cast_add_one, neg_mul_eq_neg_mul]
rw [eq_div_iff, mul_comm, ← Nat.cast_two, ← log_pow, sq_sqrt hx]
exact two_ne_zero
refine' mul_nonneg _ h1.le
rw [← log_inv]
apply log_nonneg
rw [← le_inv h1 zero_lt_one, inv_one]
exact h2
rw [continuous_on_iff_continuous_restrict, restrict]
conv in log _ => rw [log_of_ne_zero (show (x : ℝ) ≠ 0 from x.2)]
exact exp_order_iso.symm.continuous.comp (continuous_subtype_coe.norm.subtype_mk _)
simp [exp_log hx]
simp [logb]
simp [logb]
rw [logb, logb, log_abs]
rw [← logb_abs x, ← logb_abs (-x), abs_neg]
simp [logb, neg_div]
rw [logb, div_eq_iff, log_rpow b_pos]
exact log_b_ne_zero b_pos b_ne_one
rw [rpow_logb_eq_abs b_pos b_ne_one hx.ne']
exact abs_of_pos hx
rw [rpow_logb_eq_abs b_pos b_ne_one (ne_of_lt hx)]
exact abs_of_neg hx
rw [logb, logb, div_le_div_right (log_pos hb), log_le_log h h₁]
rw [logb, logb, div_lt_div_right (log_pos hb)]
exact log_lt_log hx hxy
rw [logb, logb, div_lt_div_right (log_pos hb)]
exact log_lt_log_iff hx hy
rw [← rpow_le_rpow_left_iff hb, rpow_logb (b_pos hb) (b_ne_one hb) hx]
rw [← rpow_lt_rpow_left_iff hb, rpow_logb (b_pos hb) (b_ne_one hb) hx]
rw [← rpow_le_rpow_left_iff hb, rpow_logb (b_pos hb) (b_ne_one hb) hy]
rw [← rpow_lt_rpow_left_iff hb, rpow_logb (b_pos hb) (b_ne_one hb) hy]
rw [← @logb_one b]
rw [logb_lt_logb_iff hb zero_lt_one hx]
rw [logb_pos_iff hb (lt_trans zero_lt_one hx)]
exact hx
rw [← logb_one]
exact logb_lt_logb_iff hb h zero_lt_one
rw [← not_lt, logb_neg_iff hb hx, not_lt]
rw [← not_lt, logb_pos_iff hb hx, not_lt]
rw [logb, logb, div_le_div_right_of_neg (log_neg b_pos b_lt_one), log_le_log h₁ h]
rw [logb, logb, div_lt_div_right_of_neg (log_neg b_pos b_lt_one)]
exact log_lt_log hx hxy
rw [logb, logb, div_lt_div_right_of_neg (log_neg b_pos b_lt_one)]
exact log_lt_log_iff hy hx
rw [← rpow_le_rpow_left_iff_of_base_lt_one b_pos b_lt_one, rpow_logb b_pos (b_ne_one b_lt_one) hx]
rw [← rpow_lt_rpow_left_iff_of_base_lt_one b_pos b_lt_one, rpow_logb b_pos (b_ne_one b_lt_one) hx]
rw [← rpow_le_rpow_left_iff_of_base_lt_one b_pos b_lt_one, rpow_logb b_pos (b_ne_one b_lt_one) hy]
rw [← rpow_lt_rpow_left_iff_of_base_lt_one b_pos b_lt_one, rpow_logb b_pos (b_ne_one b_lt_one) hy]
rw [← @logb_one b, logb_lt_logb_iff_of_base_lt_one b_pos b_lt_one zero_lt_one hx]
rw [logb_pos_iff_of_base_lt_one b_pos b_lt_one hx]
exact hx'
rw [← @logb_one b, logb_lt_logb_iff_of_base_lt_one b_pos b_lt_one h zero_lt_one]
rw [← not_lt, logb_neg_iff_of_base_lt_one b_pos b_lt_one hx, not_lt]
rw [logb_nonneg_iff_of_base_lt_one b_pos b_lt_one hx]
exact hx'
rw [← not_lt, logb_pos_iff_of_base_lt_one b_pos b_lt_one hx, not_lt]
simp only [Real.rpow_mul hz r n, Real.rpow_nat_cast]
simp only [pow_mul']
simp only [pow_one]
simp
simp only [Real.rpow_def_of_pos, abs.pos hz, mul_comm]
simp only [norm_eq_abs, abs_exp, of_real_mul_re, Real.is_o_exp_comp_exp_comp]
refine'
          (is_equivalent.refl.sub_is_o _).symm.tendsto_at_top (hl.tendsto_re.const_mul_at_top hb)
exact (hl.is_o_log_abs_re.const_mul_left _).const_mul_right hb.ne'
simp only
rw [mul_right_comm, ← cpow_add _ _ hz, add_sub_cancel'_right]
simp only [of_real_sub, sub_mul, mul_assoc, ← exp_add, add_sub_cancel'_right]
simp only [hr, Right.neg_neg_iff, inv_pos]
simp only [sub_le_self_iff, zero_le_one]
have hr : 0 < r := lt_of_le_of_lt (finrank ℝ E).cast_nonneg hnr
  -- We start
simp [disjoint_iff]
simp [hr.le]
rw [closed_ball_rpow_sub_one_eq_empty_aux E hr ht, measure_empty]
  -- The integral over the constant zero function is finite:
dsimp [bernstein, Polynomial.toContinuousMapOn, Polynomial.toContinuousMap, bernsteinPolynomial]
simp
simp [bernsteinApproximation]
rw [mul_one]
rw [bernstein.probability]
simp [bernsteinApproximation, Finset.mul_sum, sub_mul]
rw [Finset.mul_sum]
      -- In this step we increase the sum over `S` back to a sum over all of `fin (n+1)`,
          -- so that we can use `bernstein.probability`.
rw [bernstein.probability, mul_one]
rw [Finset.mul_sum]
rw [iterate_succ_apply, deriv_exp, iter_deriv_exp n]
rw [iterate_succ_apply, deriv_exp, iter_deriv_exp n]
exact IntervalIntegrable.trans (this a).symm (this b)
simp only [mul_comm, IntervalIntegrable.constMul c h]
intro x hx
apply hderiv x
exact ne_of_mem_of_not_mem hx h.2
rw [sub_div]
exact integral_eq_sub_of_has_deriv_at this (interval_integrable_cpow ha hb)
rw [interval_oc_of_le hab, ← integral_of_le hab]
simp [abs_of_nonneg (sub_nonneg.2 hab)]
rw [interval_oc_of_lt hab, ← integral_of_le hab.le]
simp [integral_comp_neg fun x => x ^ n, abs_of_neg (sub_neg.2 hab)]
simp only [mul_one, smul_eq_mul, integral_const]
simp
have h' := fun x hx => ne_of_mem_of_not_mem hx h
rw [integral_deriv_eq_sub' _ deriv_log' (fun x hx => differentiable_at_log (h' x hx))
      (continuous_on_inv₀.mono <| subset_compl_singleton_iff.mpr h),
    log_div (h' b right_mem_interval) (h' a left_mem_interval)]
simp only [one_div, integral_inv h]
simp only [one_div, integral_inv_of_pos ha hb]
simp only [one_div, integral_inv_of_neg ha hb]
simp only [one_div, integral_inv_one_add_sq]
simp only [pow_succ']
simp [H, h, sq]
simp [cos_sq', sub_mul, ← pow_add, add_comm]
let H x h := pow_le_pow_of_le_one (sin_nonneg_of_mem_Icc h) (sin_le_one x) (n.le_add_right 1)
refine' integral_mono_on pi_pos.le _ _ H <;> exact (continuous_sin.pow _).IntervalIntegrable 0 π
simp only [pow_succ']
simp [H, h, sq, -neg_add_rev]
simp [sin_sq, sub_mul, ← pow_add, add_comm]
simp only [pow_succ', ← mul_assoc, pow_mul, cos_sq']
rw [integral_symm]
simp [pow_succ', pow_mul, sin_sq]
simp [(sqrt_pos.2 hx).ne', @two_ne_zero ℝ]
apply exp_log
rw [← neg_lt_iff_pos_add']
calc
    -x ≤ sqrt (x ^ 2) := le_sqrt_of_sq_le (neg_pow_bit0 _ _).le
    _ < sqrt (1 + x ^ 2) := sqrt_lt_sqrt (sq_nonneg _) (lt_one_add _)
simp [arsinh]
rw [← exp_eq_exp, exp_arsinh, exp_neg, exp_arsinh]
apply eq_inv_of_mul_eq_one_left
rw [neg_sq, neg_add_eq_sub, add_comm x, mul_comm, ← sq_sub_sq, sq_sqrt, add_sub_cancel]
exact add_nonneg zero_le_one (sq_nonneg _)
rw [← sqrt_sq (cosh_pos _).le, cosh_sq', sinh_arsinh]
rw [← sinh_le_sinh, sinh_zero, sinh_arsinh]
rw [← sinh_le_sinh, sinh_zero, sinh_arsinh]
apply continuous_at_cpow_const
rw [of_real_re]
exact Or.inl hx
rw [Real.gammaIntegral, ← integral_of_real]
refine' set_integral_congr measurableSetIoi _
intro x hx
dsimp only
rw [of_real_mul, of_real_cpow (mem_Ioi.mp hx).le]
simp
rw [← of_real_one, Gamma_integral_of_real, of_real_inj]
exact Real.Gamma_integral_one
rw [interval_integrable_iff_integrable_Ioc_of_le hX]
exact integrable_on.mono_set (Gamma_integral_convergent hs) Ioc_subset_Ioi_self
refine' eventually_eq_of_mem (Ioi_mem_at_top 0) _
intro x hx
dsimp only
rw [norm_eq_abs, map_mul, abs.map_neg, abs_cpow_eq_rpow_re_of_pos hx,
      abs_of_nonneg (exp_pos (-x)).le, neg_mul, one_mul]
rw [← Real.exp_add, add_halves]
intro t
apply (continuous_of_real.comp continuous_neg.exp).ContinuousOn.mul
apply ContinuousAt.continuous_on
intro x hx
refine' (continuous_at_cpow_const _).comp continuous_of_real.continuous_at
exact Or.inl hx
apply eventually_of_forall
intro t
exact (cont t).AeStronglyMeasurable measurableSetIoi
simp only [Complex.abs_def, Complex.normSq, pow_two, MonoidWithZeroHom.coe_mk, Complex.add_re,
        Complex.of_real_re, Complex.mul_re, Complex.I_re, mul_zero, Complex.of_real_im,
        Complex.I_im, sub_self, add_zero, Complex.add_im, Complex.mul_im, mul_one, zero_add]
intro x hx
simp only [polar_coord_source, compl_union, mem_inter_iff, mem_compl_iff, mem_set_of_eq, not_lt,
      not_not] at hx
exact hx.2
rw [h]
rw [← integral_univ]
apply set_integral_congr_set_ae
exact polar_coord_source_ae_eq_univ.symm
apply integral_target_eq_integral_abs_det_fderiv_smul volume A
apply set_integral_congr polar_coord.open_target.measurable_set fun x hx => _
rw [B_det, abs_of_pos]
exact hx.1
refine' (zero_lt_one.trans_le _).ne'
exact hx
refine' ⟨fun h => _, fun h => (integrableExpNegMulSq h).IntegrableOn⟩
apply lintegral_mono fun x => _
simp only [neg_mul, Ennreal.one_le_coe_iff, ← to_nnreal_one, to_nnreal_le_iff_le_coe,
      Real.norm_of_nonneg (exp_pos _).le, coe_nnnorm, one_le_exp_iff, Right.nonneg_neg_iff]
exact mul_nonpos_of_nonpos_of_nonneg hb (sq_nonneg _)
refine' tendsto_const_nhds.sub _
apply tendsto.const_mul
apply tendsto_exp_at_bot.comp
exact tendsto.neg_const_mul_at_top (neg_lt_zero.2 hb) (tendsto_pow_at_top two_ne_zero)
rw [pow_two, ← integral_prod_mul]
rfl
rw [← set_integral_prod_mul]
congr
rw [sq_sqrt]
exact div_nonneg pi_pos.le hb.le
simp only [one_div, of_real_inv, of_real_bit0, of_real_one]
rw [hh2]
exact one_half_pos
simp only [Algebra.id.smul_eq_mul, one_mul, ContinuousLinearMap.one_apply,
    ContinuousLinearMap.smul_right_apply, ContinuousLinearMap.add_apply, Pi.smul_apply,
    ContinuousLinearMap.coe_smul']
simp
rw [← cont_diff_within_at_univ] at *
exact hf.rpow_const_of_le h
rw [← has_deriv_within_at_univ] at *
exact hf.rpow hg h
rw [← has_deriv_within_at_univ] at *
exact hf.rpow_const hx
simp
rw [pow_two]
exact mul_le_mul hyx.le le_rfl (norm_nonneg _) hr_nonneg
rw [eq_comm, sqrt_eq_iff_sq_eq, sq, ← exp_add, add_halves] <;> exact (exp_pos _).le
rw [add_comm, exp_add, mul_div_mul_left _ _ (exp_pos _).ne']
rw [comp_app, inv_eq_one_div, div_div_eq_mul_div, one_mul, div_eq_mul_inv, exp_neg]
simp only [tendsto_Ioi_at_top, Subtype.coe_mk, tendsto_exp_at_top]
simp [tendsto_exp_at_bot_nhds_within]
rw [← coe_comp_exp_order_iso, range_comp, exp_order_iso.range_eq, image_univ, Subtype.range_coe]
rw [← coe_comp_exp_order_iso, ← Filter.map_map, OrderIso.map_at_top, map_coe_Ioi_at_top]
rw [← map_exp_at_top, comap_map exp_injective, map_exp_at_top]
rw [← tendsto_comap_iff, comap_exp_at_top]
rw [← tendsto_map'_iff, map_exp_at_top]
rw [← coe_comp_exp_order_iso, ← Filter.map_map, exp_order_iso.map_at_bot, ← map_coe_Ioi_at_bot]
rw [← map_exp_at_bot, comap_map exp_injective]
rw [← map_exp_at_bot, tendsto_map'_iff]
simp
rw [← tendsto_comap_iff, comap_exp_nhds_zero]
simp only [norm_eq_abs, abs_exp, ← exp_sub, is_bounded_under_le_exp_comp, Pi.sub_def]
simp only [is_bounded_under_le_abs, ← is_bounded_under_le_neg, neg_sub, is_Theta,
    is_O_exp_comp_exp_comp, Pi.sub_def]
simp only [is_o_iff_tendsto, exp_ne_zero, ← exp_sub, ← tendsto_neg_at_top_iff, false_imp_iff,
    imp_true_iff, tendsto_exp_comp_nhds_zero, neg_sub]
simp only [← exp_zero, is_o_exp_comp_exp_comp, sub_zero]
simp only [← exp_zero, is_O_exp_comp_exp_comp, Pi.sub_def, zero_sub, is_bounded_under_le_neg]
simp only [is_O_one_iff, norm_eq_abs, abs_exp, is_bounded_under_le_exp_comp]
simp only [← exp_zero, is_Theta_exp_comp_exp_comp, sub_zero]
simp only [comap_comap, (· ∘ ·), abs_exp]
rw [Real.comap_exp_at_top]
simp only [comap_comap, ← comap_abs_nhds_zero, (· ∘ ·), abs_exp]
rw [Real.comap_exp_nhds_zero]
rw [← tendsto_comap_iff, comap_exp_nhds_zero, tendsto_comap_iff]
simp [cpow_def]
simp [cpow_def, *]
constructor
· intro hyp
    simp only [cpow_def, eq_self_iff_true, if_true] at hyp
rw [← zero_cpow_eq_iff, eq_comm]
simp [hx, cpow_def]
rw [cpow_def, if_neg (one_ne_zero : (1 : ℂ) ≠ 0), if_neg hx, mul_one, exp_log hx]
simp only [cpow_def, ite_mul, boole_mul, mul_ite, mul_boole] <;> simp_all [exp_add, mul_add]
rw [sub_eq_add_neg, cpow_add _ _ hx, cpow_neg, div_eq_mul_inv]
simp
simp only [hx, pow_succ, Complex.zero_cpow (Nat.cast_ne_zero.2 (Nat.succ_ne_zero _)),
        zero_mul]
simp [cpow_add, hx, pow_add, cpow_nat_cast n]
rw [← cpow_nat_cast]
simp only [Nat.cast_bit0, Nat.cast_one]
simp
rw [zpow_negSucc] <;>
      simp only [Int.negSucc_coe, Int.cast_neg, Complex.cpow_neg, inv_eq_one_div, Int.cast_ofNat,
        cpow_nat_cast]
rw [cpow_eq_pow, zero_cpow hx, Pi.zero_apply]
dsimp only
rw [cpow_eq_pow, cpow_def_of_ne_zero hx]
dsimp only
rw [cpow_def_of_ne_zero hx]
cases h
· exact (continuous_at_const_cpow h).Tendsto.comp hf
· exact (continuous_at_const_cpow' h).Tendsto.comp hf
rw [rpow_def_of_nonneg (le_of_lt hx), if_neg (ne_of_gt hx)]
rw [rpow_def_of_pos (exp_pos _), log_exp]
rw [← exp_mul, one_mul]
rw [rpow_def_of_pos hx] <;> apply exp_pos
simp [rpow_def]
simp [rpow_def, *]
constructor
· intro hyp
    simp only [rpow_def, Complex.of_real_zero] at hyp
rw [← zero_rpow_eq_iff, eq_comm]
simp [rpow_def]
simp [rpow_def]
have h_rpow_nonneg : 0 ≤ x ^ y := Real.rpow_nonneg_of_nonneg hx_nonneg _
rw [abs_eq_self.mpr hx_nonneg, abs_eq_self.mpr h_rpow_nonneg]
refine' (abs_rpow_le_abs_rpow x y).trans _
rw [cpow_def_of_ne_zero hz, abs_exp, mul_re, log_re, log_im, Real.exp_sub,
    Real.rpow_def_of_pos (abs.pos hz)]
simp only [of_real_one, div_one]
simp only [of_real_one, div_one]
rw [← abs_cpow_real] <;> simp [-abs_cpow_real]
rw [abs_cpow_of_ne_zero (of_real_ne_zero.mpr hx.ne'), arg_of_real_of_nonneg hx.le, zero_mul,
    Real.exp_zero, div_one, abs_of_nonneg hx.le]
simp only [rpow_def_of_pos hx, mul_add, exp_add]
simp
rw [← Complex.of_real_inj, Complex.of_real_cpow (rpow_nonneg_of_nonneg hx _),
      Complex.of_real_cpow hx, Complex.of_real_mul, Complex.cpow_mul, Complex.of_real_cpow hx] <;>
    simp only [(Complex.of_real_mul _ _).symm, (Complex.of_real_log hx).symm, Complex.of_real_im,
      neg_lt_zero, pi_pos, le_of_lt pi_pos]
simp only [sub_eq_add_neg, rpow_add hx, rpow_neg (le_of_lt hx), div_eq_mul_inv]
simp only [sub_eq_add_neg] at h⊢
simp only [rpow_add' hx h, rpow_neg hx, div_eq_mul_inv]
rw [rpow_def, Complex.of_real_add, Complex.cpow_add _ _ (complex.of_real_ne_zero.mpr hx),
    Complex.of_real_int_cast, Complex.cpow_int_cast, ← Complex.of_real_zpow, mul_comm,
    Complex.of_real_mul_re, ← rpow_def, mul_comm]
simp only [rpow_def, ← Complex.of_real_zpow, Complex.cpow_int_cast, Complex.of_real_int_cast,
    Complex.of_real_re]
rw [← rpow_nat_cast]
simp only [Nat.cast_bit0, Nat.cast_one]
simp only [← rpow_neg_one, ← rpow_mul hx, mul_comm]
simp only [div_eq_mul_inv, mul_rpow hx (inv_nonneg.2 hy), inv_rpow hy]
apply exp_injective
rw [exp_log (rpow_pos_of_pos hx y), ← exp_log hx, mul_comm, rpow_def_of_pos (exp_pos (log x)) y]
have x_pos : 0 < x := lt_trans zero_lt_one hx
rw [← log_le_log (rpow_pos_of_pos x_pos y) (rpow_pos_of_pos x_pos z), log_rpow x_pos,
    log_rpow x_pos, mul_le_mul_right (log_pos hx)]
rw [lt_iff_not_le, rpow_le_rpow_left_iff hx, lt_iff_not_le]
rw [← log_le_log (rpow_pos_of_pos hx0 y) (rpow_pos_of_pos hx0 z), log_rpow hx0, log_rpow hx0,
    mul_le_mul_right_of_neg (log_neg hx0 hx1)]
rw [lt_iff_not_le, rpow_le_rpow_left_iff_of_base_lt_one hx0 hx1, lt_iff_not_le]
rw [← one_rpow z]
exact rpow_lt_rpow hx1 hx2 hz
rw [← one_rpow z]
exact rpow_le_rpow hx1 hx2 hz
rw [← one_rpow z]
exact rpow_lt_rpow zero_le_one hx hz
rw [← one_rpow z]
exact rpow_le_rpow zero_le_one hx hz
rw [rpow_def_of_pos hx, exp_lt_one_iff, mul_neg_iff, log_pos_iff hx, log_neg_iff hx]
rw [rpow_def_of_pos hx, one_lt_exp_iff, mul_pos_iff, log_pos_iff hx, log_neg_iff hx]
rw [← Real.log_le_log hx (Real.rpow_pos_of_pos hy z), Real.log_rpow hy]
rw [← Real.log_lt_log_iff hx (Real.rpow_pos_of_pos hy z), Real.log_rpow hy]
rw [rpow_def_of_pos hx, exp_le_one_iff, mul_nonpos_iff, log_nonneg_iff hx, log_nonpos_iff hx]
have hn0 : (n : ℝ) ≠ 0 := Nat.cast_ne_zero.2 hn
rw [← rpow_nat_cast, ← rpow_mul hx, mul_inv_cancel hn0, rpow_one]
have hn0 : (n : ℝ) ≠ 0 := Nat.cast_ne_zero.2 hn
rw [← rpow_nat_cast, ← rpow_mul hx, inv_mul_cancel hn0, rpow_one]
dsimp only
rw [rpow_def_of_neg hx]
dsimp only
rw [rpow_def_of_pos hx]
rw [ne_iff_lt_or_gt] at hp
cases hp
· rw [continuous_at_congr (rpow_eq_nhds_of_neg hp)]
    refine' ContinuousAt.mul _ (continuous_cos.continuous_at.comp _)
    · refine' continuous_exp.continuous_at.comp (ContinuousAt.mul _ continuous_snd.continuous_at)
      refine' (continuous_at_log _).comp continuous_fst.continuous_at
      exact hp.ne
    · exact continuous_snd.continuous_at.mul continuous_at_const
· rw [continuous_at_congr (rpow_eq_nhds_of_pos hp)]
    refine' continuous_exp.continuous_at.comp (ContinuousAt.mul _ continuous_snd.continuous_at)
    refine' (continuous_at_log _).comp continuous_fst.continuous_at
    exact hp.lt.ne.symm
rw [nhds_within_singleton, tendsto_pure, pure_prod, eventually_map]
exact (lt_mem_nhds hp).mono fun y hy => zero_rpow hy.ne'
change ContinuousAt ((fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun y : ℝ => (y, q)) x
apply ContinuousAt.comp
· exact continuous_at_rpow (x, q) h
· exact (continuous_id'.prod_mk continuous_const).ContinuousAt
simp [tendsto_const_nhds]
simp []
simp []
rw [mul_rpow hc (abs_nonneg _), abs_rpow_of_nonneg hgx]
rw [← rpow_mul hc.le, inv_mul_cancel hr.ne', rpow_one]
have hx₀ : 0 ≤ log x := zero_le_one.trans hx
simp [norm_eq_abs, abs_rpow_of_nonneg, abs_rpow_of_nonneg hx₀,
            rpow_le_rpow_of_exponent_le (hx.trans (le_abs_self _))]
simp only [← rpow_mul hx, div_mul_cancel _ hr.ne']
simp [abs_of_nonpos, log_nonpos hx.1 hx.2]
rw [Function.comp_apply, inv_rpow hx.out.le, rpow_neg hx.out.le, inv_inv]
simp [abs_of_nonpos (log_nonpos hx.1 hx.2)]
rw [rpow_neg hx.out.le, div_inv_eq_mul]
rw [← Nnreal.coe_eq, coe_rpow, ← Nnreal.coe_eq_zero]
exact Real.rpow_eq_zero_iff_of_nonneg x.2
simp [rpow_neg]
rw [← rpow_nat_cast]
simp only [Nat.cast_bit0, Nat.cast_one]
rw [← rpow_le_rpow_iff hz, rpow_self_rpow_inv hz.ne']
rw [← rpow_le_rpow_iff hz, rpow_self_rpow_inv hz.ne']
intro p hp_pos
rw [← zero_rpow hp_pos.ne']
exact rpow_lt_rpow hx_pos hp_pos
rw [← rpow_eq_rpow_iff hz, rpow_self_rpow_inv hz]
rw [← rpow_eq_rpow_iff hz, rpow_self_rpow_inv hz]
rw [← Nnreal.coe_eq, coe_rpow, Nnreal.coe_pow]
exact Real.pow_nat_rpow_nat_inv x.2 hn
rw [← Nnreal.coe_eq, Nnreal.coe_pow, coe_rpow]
exact Real.rpow_nat_inv_pow_nat x.2 hn
simp only [rpow_zero, continuous_at_const]
cases x <;>
    · dsimp only [(· ^ ·), rpow]
      simp [lt_irrefl]
simp [top_rpow_def, h]
simp [top_rpow_def, asymm h, ne_of_lt h]
rw [← Ennreal.coe_zero, ← Ennreal.some_eq_coe]
dsimp only [(· ^ ·), rpow]
simp [h, asymm h, ne_of_gt h]
rw [← Ennreal.coe_zero, ← Ennreal.some_eq_coe]
dsimp only [(· ^ ·), rpow]
simp [h, ne_of_gt h]
rw [← Ennreal.some_eq_coe]
dsimp only [(· ^ ·), rpow]
simp [h]
cases x
· exact dif_pos zero_lt_one
· change ite _ _ _ = _
    simp only [Nnreal.rpow_one, some_eq_coe, ite_eq_right_iff, top_ne_coe, and_imp]
    exact fun _ => zero_le_one.not_lt
rw [← coe_one, coe_rpow_of_ne_zero one_ne_zero]
simp
simp [rpow_eq_top_iff, hy, asymm hy]
simp [h]
rw [sub_eq_add_neg, rpow_add _ _ hx h'x, rpow_neg, div_eq_mul_inv]
simp [rpow_neg]
simp [h]
cases x
· cases n <;> simp [top_rpow_of_pos (Nat.cast_add_one_pos _), top_pow (Nat.succ_pos _)]
· simp [coe_rpow_of_nonneg _ (Nat.cast_nonneg n)]
rw [← rpow_nat_cast]
simp only [Nat.cast_bit0, Nat.cast_one]
simp [*, mul_rpow_eq_ite]
simp [*, mul_rpow_eq_ite]
simp [hz.not_lt, mul_rpow_eq_ite]
rw [div_eq_mul_inv, mul_rpow_of_nonneg _ _ hz, inv_rpow, div_eq_mul_inv]
simp only [rpow_zero, monotone_const]
dsimp
rw [← rpow_mul, one_div_mul_cancel hy.ne.symm, rpow_one]
simp only [order_iso_rpow, one_div_one_div]
rfl
simp [hz]
simp [hz]
cases x
· simp [top_rpow_of_neg hz, Ennreal.zero_lt_one]
· simp only [some_eq_coe, one_lt_coe_iff] at hx
    simp [coe_rpow_of_ne_zero (ne_of_gt (lt_trans zero_lt_one hx)),
      Nnreal.rpow_lt_one_of_one_lt_of_neg hx hz]
cases x
· simp [top_rpow_of_neg hz, Ennreal.zero_lt_one]
· simp only [one_le_coe_iff, some_eq_coe] at hx
    simp [coe_rpow_of_ne_zero (ne_of_gt (lt_of_lt_of_le zero_lt_one hx)),
      Nnreal.rpow_le_one_of_one_le_of_nonpos hx (le_of_lt hz)]
cases x
· simp [top_rpow_of_pos hz]
· simp only [some_eq_coe, one_lt_coe_iff] at hx
    simp [coe_rpow_of_nonneg _ (le_of_lt hz), Nnreal.one_lt_rpow hx hz]
cases x
· simp [top_rpow_of_pos hz]
· simp only [one_le_coe_iff, some_eq_coe] at hx
    simp [coe_rpow_of_nonneg _ (le_of_lt hz), Nnreal.one_le_rpow hx (le_of_lt hz)]
rw [Ennreal.toReal, Ennreal.toReal, ← Nnreal.coe_rpow, Ennreal.to_nnreal_rpow]
intro y z hyz
dsimp only at hyz
rw [← rpow_one y, ← rpow_one z, ← _root_.mul_inv_cancel hx, rpow_mul, rpow_mul, hyz]
rw [← h, ← hb, Real.rpow_nat_cast]
rw [← hc, ← h, ← hb, Real.rpow_neg a0, Real.rpow_nat_cast]
rw [← h, hb, Complex.cpow_nat_cast]
rw [← hc, ← h, hb, Complex.cpow_neg, Complex.cpow_nat_cast]
rw [← h, hb, Nnreal.rpow_nat_cast]
rw [← hc, ← h, hb, Nnreal.rpow_neg, Nnreal.rpow_nat_cast]
rw [← h, hb, Ennreal.rpow_nat_cast]
rw [← hc, ← h, hb, Ennreal.rpow_neg, Ennreal.rpow_nat_cast]
rw [← not_iff_not, not_exists, ← Ne, tan_ne_zero_iff]
simp [tendsto_tan_neg_pi_div_two, this]
simp [tendsto_tan_pi_div_two, this]
rw [one_div, ← inv_one_add_tan_sq (cos_arctan_pos x).ne', tan_arctan]
rw [← tan_div_sqrt_one_add_tan_sq (cos_arctan_pos x), tan_arctan]
rw [one_div, ← inv_sqrt_one_add_tan_sq (cos_arctan_pos x), tan_arctan]
simp [arctan_eq_arcsin]
rw [tan_arctan, h]
simp [arctan_eq_arcsin, neg_div]
refine' ⟨fun hc h₀ => _, fun h => (has_deriv_at_tan h).ContinuousAt⟩
exact
    not_tendsto_nhds_of_tendsto_at_top (tendsto_abs_tan_of_cos_eq_zero h₀) _
      (hc.norm.tendsto.mono_left inf_le_left)
have : ¬DifferentiableAt ℂ tan x := mt differentiable_at_tan.1 (not_not.2 h)
simp [deriv_zero_of_not_differentiable_at this, h, sq]
simp
funext x
simp only [deriv_arcsin]
simp only [QuotientAddGroup.eq, AddSubgroup.zmultiples_eq_closure,
    AddSubgroup.mem_closure_singleton, zsmul_eq_mul', (sub_eq_neg_add _ _).symm, eq_comm]
rw [sub_zero, Int.cast_one, mul_one]
rw [← coe_nsmul, two_nsmul, add_halves]
rw [← coe_zsmul, two_zsmul, add_halves]
rw [two_nsmul_coe_div_two, coe_neg, neg_coe_pi]
rw [two_zsmul, ← two_nsmul, two_nsmul_neg_pi_div_two]
rw [sub_eq_add_neg, neg_coe_pi]
simp [← coe_nat_mul_eq_nsmul]
simp [← coe_int_mul_eq_zsmul]
rw [← two_nsmul, two_nsmul_coe_pi]
rw [zsmul_eq_iff two_ne_zero, Int.nat_abs_bit0, Int.natAbs_one, Fin.exists_fin_two, Fin.coe_zero,
    Fin.coe_one, zero_smul, add_zero, one_smul, Int.cast_two,
    mul_div_cancel_left (_ : ℝ) two_ne_zero]
rw [← not_or, ← two_nsmul_eq_zero_iff]
rw [← not_or, ← two_zsmul_eq_zero_iff]
rw [← add_eq_zero_iff_eq_neg, ← two_nsmul, two_nsmul_eq_zero_iff]
rw [← not_or, ← eq_neg_self_iff.not]
rw [eq_comm, eq_neg_self_iff]
rw [← not_or, ← neg_eq_self_iff.not]
rw [two_nsmul, ← coe_add, add_halves]
rw [two_zsmul, ← two_nsmul, two_nsmul_eq_pi_iff]
induction θ using Real.Angle.induction_on
exact cos_eq_iff_coe_eq_or_eq_neg
induction ψ using Real.Angle.induction_on
exact cos_eq_real_cos_iff_eq_or_eq_neg
induction θ using Real.Angle.induction_on
exact sin_eq_iff_coe_eq_or_add_eq_pi
induction ψ using Real.Angle.induction_on
exact sin_eq_real_sin_iff_eq_or_add_eq_pi
rw [← coe_zero, sin_coe, Real.sin_zero]
rw [sin_coe, Real.sin_pi]
rw [← not_or, ← sin_eq_zero_iff]
induction θ using Real.Angle.induction_on
exact Real.sin_neg _
intro θ
induction θ using Real.Angle.induction_on
exact Real.sin_antiperiodic θ
rw [← coe_zero, cos_coe, Real.cos_zero]
rw [cos_coe, Real.cos_pi]
induction θ using Real.Angle.induction_on
exact Real.cos_neg _
intro θ
induction θ using Real.Angle.induction_on
exact Real.cos_antiperiodic θ
rw [← cos_pi_div_two, ← cos_coe, cos_eq_iff_eq_or_eq_neg, ← coe_neg, ← neg_div]
induction θ₁ using Real.Angle.induction_on
induction θ₂ using Real.Angle.induction_on
exact Real.sin_add θ₁ θ₂
induction θ₂ using Real.Angle.induction_on
induction θ₁ using Real.Angle.induction_on
exact Real.cos_add θ₁ θ₂
induction θ using Real.Angle.induction_on
exact Real.cos_sq_add_sin_sq θ
induction θ using Real.Angle.induction_on
exact sin_add_pi_div_two _
induction θ using Real.Angle.induction_on
exact sin_sub_pi_div_two _
induction θ using Real.Angle.induction_on
exact sin_pi_div_two_sub _
induction θ using Real.Angle.induction_on
exact cos_add_pi_div_two _
induction θ using Real.Angle.induction_on
exact cos_sub_pi_div_two _
induction θ using Real.Angle.induction_on
exact cos_pi_div_two_sub _
rw [angle_eq_iff_two_pi_dvd_sub]
refine' ⟨toIcoDiv ψ two_pi_pos θ, _⟩
rw [to_Ico_mod_sub_self, zsmul_eq_mul, mul_comm]
rw [angle_eq_iff_two_pi_dvd_sub]
refine' ⟨toIocDiv ψ two_pi_pos θ, _⟩
rw [to_Ioc_mod_sub_self, zsmul_eq_mul, mul_comm]
rw [to_real_coe_eq_self_iff, ← Set.mem_Ioc]
induction θ using Real.Angle.induction_on
exact coe_to_Ioc_mod _ _
induction θ using Real.Angle.induction_on
exact left_lt_to_Ioc_mod _ two_pi_pos _
induction θ using Real.Angle.induction_on
rw [to_real_coe]
exact to_Ioc_mod_to_Ioc_mod _ _ _ _
rw [← coe_zero, to_real_coe_eq_self_iff]
exact ⟨Left.neg_neg_iff.2 Real.pi_pos, real.pi_pos.le⟩
rw [to_real_coe_eq_self_iff]
exact ⟨Left.neg_lt_self Real.pi_pos, le_refl _⟩
rw [← to_real_inj, to_real_pi]
rw [← to_real_injective.ne_iff, to_real_pi, to_real_zero]
exact pi_ne_zero
rw [← to_real_inj, to_real_pi_div_two]
rw [← to_real_inj, to_real_neg_pi_div_two]
rw [← to_real_injective.ne_iff, to_real_pi_div_two, to_real_zero]
exact div_ne_zero Real.pi_ne_zero two_ne_zero
rw [← to_real_injective.ne_iff, to_real_neg_pi_div_two, to_real_zero]
exact div_ne_zero (neg_ne_zero.2 Real.pi_ne_zero) two_ne_zero
refine' ⟨fun h => h ▸ ⟨abs_nonneg _, abs_to_real_le_pi _⟩, fun h => _⟩
rw [abs_eq (div_nonneg real.pi_pos.le two_pos.le), ← neg_div, to_real_eq_pi_div_two_iff,
    to_real_eq_neg_pi_div_two_iff]
rw [two_zsmul, ← two_nsmul, two_nsmul_to_real_eq_two_mul]
rw [two_zsmul, ← two_nsmul, two_nsmul_to_real_eq_two_mul_sub_two_pi]
rw [two_zsmul, ← two_nsmul, two_nsmul_to_real_eq_two_mul_add_two_pi]
rw [← not_le, ← not_le, not_iff_not, cos_nonneg_iff_abs_to_real_le_pi_div_two]
rw [tan, sin_coe, cos_coe, Real.tan_eq_sin_div_cos]
rw [← coe_zero, tan_coe, Real.tan_zero]
rw [tan_eq_sin_div_cos, sin_coe_pi, zero_div]
intro θ
induction θ using Real.Angle.induction_on
rw [← coe_add, tan_coe, tan_coe]
exact Real.tan_periodic θ
rw [sign, sin_zero, sign_zero]
rw [sign, sin_coe_pi, _root_.sign_zero]
rw [sign, sign, sin_add_pi, Left.sign_neg]
rw [add_comm, sign_add_pi]
simp [sign_antiperiodic.sub_eq']
rw [sign, sign_eq_zero_iff, sin_eq_zero_iff]
rw [← not_or, ← sign_eq_zero_iff]
decide
rw [abs_eq_self.2 (to_real_nonneg_iff_sign_nonneg.2 h), coe_to_real]
rw [sign, sin_coe, sin_pi_div_two, sign_one]
rw [sign, sin_coe, neg_div, Real.sin_neg, sin_pi_div_two, Left.sign_neg, sign_one]
rw [sign, sign_nonneg_iff]
exact sin_nonneg_of_nonneg_of_le_pi h0 hpi
rw [sign, sign_nonpos_iff, sin_neg, Left.neg_nonpos_iff]
exact sin_nonneg_of_nonneg_of_le_pi h0 hpi
rw [two_zsmul, ← two_nsmul, sign_two_nsmul_eq_sign_iff]
rw [arcsin, range_comp coe]
simp [Icc]
rw [arcsin, Function.comp_apply, Icc_extend_coe, Function.comp_apply, Icc_extend]
rw [sin_arcsin (neg_one_le_sin _) (sin_le_one _)]
subst y
exact inj_on_sin (arcsin_mem_Icc _) h₂ (sin_arcsin' (sin_mem_Icc x))
rw [← arcsin_proj_Icc, proj_Icc_of_right_le _ hx, Subtype.coe_mk, arcsin_one]
rw [sin_neg, sin_pi_div_two]
rw [← arcsin_proj_Icc, proj_Icc_of_le_left _ hx, Subtype.coe_mk, arcsin_neg_one]
rw [← arcsin_sin' hy, strict_mono_on_arcsin.le_iff_le hx (sin_mem_Icc _), arcsin_sin' hy]
rw [← neg_le_neg_iff, ← arcsin_neg,
    arcsin_le_iff_le_sin ⟨neg_le_neg hy.2, neg_le.2 hy.1⟩ ⟨neg_le_neg hx.2, neg_le.2 hx.1⟩, sin_neg,
    neg_le_neg_iff]
rw [← neg_le_neg_iff, ← arcsin_neg, arcsin_le_iff_le_sin' ⟨neg_le_neg hx.2, neg_lt.2 hx.1⟩,
    sin_neg, neg_le_neg_iff]
simp only [le_antisymm_iff, arcsin_le_iff_le_sin' (mem_Ico_of_Ioo hy),
    le_arcsin_iff_sin_le' (mem_Ioc_of_Ioo hy)]
rw [sin_zero]
simp [le_antisymm_iff]
rw [sin_pi_div_two]
rw [sin_neg, sin_pi_div_two]
rw [tan_eq_sin_div_cos, cos_arcsin]
simp [arccos]
simp [arccos]
rw [arccos, cos_pi_div_two_sub, sin_arcsin hx₁ hx₂]
simp [arccos]
simp [arccos]
simp [arccos, add_halves]
simp [arccos, sub_eq_zero]
simp [arccos]
rw [arccos, sub_eq_iff_eq_add, ← sub_eq_iff_eq_add', div_two_sub_self, neg_pi_div_two_eq_arcsin]
rw [← add_halves π, arccos, arcsin_neg, arccos, add_sub_assoc, sub_sub_self, sub_neg_eq_add]
rw [arccos, arcsin_of_one_le hx, sub_self]
rw [arccos, arcsin_of_le_neg_one hx, sub_neg_eq_add, add_halves']
simp [arccos]
simp [arccos]
rw [arccos, tan_pi_div_two_sub, tan_arcsin, inv_div]
rw [eq_comm, ← cos_arcsin]
exact
    arccos_cos (arcsin_nonneg.2 h)
      ((arcsin_le_pi_div_two _).trans (div_le_self pi_pos.le one_le_two))
intro y hy
exact cos_pos_of_mem_Ioo (Ico_subset_Ioo_left (neg_lt_zero.mpr half_pi_pos) hy)
intro y hy
rw [intU] at hy
exact sin_pos_of_mem_Ioo (Ioo_subset_Ioo_right (div_le_self pi_pos.le one_le_two) hy)
apply ContinuousOn.mono continuous_on_tan
intro z hz
simp only [mem_set_of_eq]
exact (cos_pos hz).ne'
rw [Real.deriv_sinh]
exact cosh_pos
cases le_total x 0 <;> simp [abs_of_nonneg, abs_of_nonpos, *]
simp only [_root_.abs_zero, _root_.abs_nonneg]
simp only [_root_.abs_zero, abs_pos]
simp
simp
simp
rw [← not_exists, not_iff_not, cos_eq_zero_iff]
rw [← not_exists, not_iff_not, sin_eq_zero_iff]
rw [← not_exists, not_iff_not, tan_eq_zero_iff]
rw [cos_sub_cos]
rw [tan_add h, tan_mul_I, mul_assoc]
rw [← not_exists, not_iff_not, cos_eq_zero_iff]
rw [Real.pi, mul_div_cancel_left _ (two_ne_zero' ℝ)] <;>
    exact (Classical.choose_spec exists_cos_eq_zero).2
rw [Real.pi, mul_div_cancel_left _ (two_ne_zero' ℝ)] <;>
    exact (Classical.choose_spec exists_cos_eq_zero).1.1
rw [Real.pi, mul_div_cancel_left _ (two_ne_zero' ℝ)] <;>
    exact (Classical.choose_spec exists_cos_eq_zero).1.2
rw [div_self (two_ne_zero' ℝ)] <;> exact one_le_pi_div_two
rw [← mul_div_cancel_left π (two_ne_zero' ℝ), two_mul, add_div, sin_add, cos_pi_div_two] <;> simp
rw [← mul_div_cancel_left π (two_ne_zero' ℝ), mul_div_assoc, cos_two_mul, cos_pi_div_two] <;>
    simp [bit0, pow_add]
simp [two_mul, sin_add]
simp [two_mul, cos_add]
simp [sin_add]
simp [cos_add]
rw [← closure_Ioo pi_ne_zero.symm] at hx
exact
    closure_lt_subset_le continuous_const continuous_sin
      (closure_mono (fun y => sin_pos_of_mem_Ioo) hx)
simp [sin_add]
simp [sub_eq_add_neg, sin_add]
simp [sub_eq_add_neg, sin_add]
simp [cos_add]
simp [sub_eq_add_neg, cos_add]
rw [← cos_neg, neg_sub, cos_sub_pi_div_two]
rw [← abs_sin_eq_sqrt_one_sub_cos_sq, abs_of_nonneg (sin_nonneg_of_nonneg_of_le_pi hl hu)]
rw [← abs_cos_eq_sqrt_one_sub_sin_sq, abs_of_nonneg (cos_nonneg_of_mem_Icc ⟨hl, hu⟩)]
simp [h]
simp [sub_eq_add_neg, sin_add, h, sin_int_mul_pi]
rw [← not_exists, not_iff_not, sin_eq_zero_iff]
rw [h, mul_zero]
simp [h]
rw [hx, cos_pi_div_two]
simp
simp
simp
rw [sqrt_two_add_series, sqrt_two_add_series_succ, sqrt_two_add_series]
rw [sqrt_two_add_series, sqrt_two_add_series]
exact sqrt_le_sqrt (add_le_add_left (sqrt_two_add_series_monotone_left _) _)
simp
rw [sin_sq, cos_pi_over_two_pow]
simp [tan_eq_sin_div_cos]
simp [hxp, tan_eq_sin_div_cos]
simp [hx0.symm]
rw [← tan_neg, ← tan_neg] <;>
        exact
          tan_lt_tan_of_nonneg_of_lt_pi_div_two (neg_nonneg.2 hy0) (neg_lt.2 hx₁) (neg_lt_neg hxy)
rw [← hy0, tan_zero] <;> exact tan_neg_of_neg_of_pi_div_two_lt (hy0.symm ▸ hxy) hx₁
rw [tan_eq_sin_div_cos, tan_eq_sin_div_cos, inv_div, sin_pi_div_two_sub, cos_pi_div_two_sub]
rw [h, mul_zero]
rw [of_real_cos] <;> simp
simp
rw [of_real_sin] <;> simp
simp
rw [← of_real_sin, Real.sin_pi] <;> simp
rw [← of_real_cos, Real.cos_pi] <;> simp
simp [two_mul, sin_add]
simp [two_mul, cos_add]
simp [sin_add]
simp [cos_add]
simp [sin_add]
simp [sub_eq_add_neg, sin_add]
simp [sub_eq_add_neg, sin_add]
simp [cos_add]
simp [sub_eq_add_neg, cos_add]
rw [← cos_neg, neg_sub, cos_sub_pi_div_two]
rw [tan_eq_sin_div_cos, tan_eq_sin_div_cos, inv_div, sin_pi_div_two_sub, cos_pi_div_two_sub]
simp [exp_add, exp_mul_I]
rw [aeval_def, eval₂_eq_eval_map, map_T]
rw [aeval_def, eval₂_eq_eval_map, map_U]
rw [← aeval_algebra_map_apply_eq_algebra_map_eval, aeval_T]
rw [← aeval_algebra_map_apply_eq_algebra_map_eval, aeval_U]
simp only [T_zero, eval_one, Nat.cast_zero, zero_mul, cos_zero]
simp only [eval_X, one_mul, T_one, Nat.cast_one]
refine' ⟨fun hc h₀ => _, fun h => (has_deriv_at_tan h).ContinuousAt⟩
exact
    not_tendsto_nhds_of_tendsto_at_top (tendsto_abs_tan_of_cos_eq_zero h₀) _
      (hc.norm.tendsto.mono_left inf_le_left)
have : ¬DifferentiableAt ℝ tan x := mt differentiable_at_tan.1 (not_not.2 h)
simp [deriv_zero_of_not_differentiable_at this, h, sq]
refine' (is_o.const_mul_left _ _).congr' this (eventually_eq.refl _ _)
rw [← has_fderiv_at_iff_is_o_nhds_zero]
exact hasFderivAtExpZeroOfRadiusPos hpos
refine' funext fun x => _
rw [Complex.exp, exp_eq_tsum_div]
exact
    tendsto_nhds_unique x.exp'.tendsto_limit (exp_series_div_summable ℝ x).HasSum.tendsto_sum_nat
refine' funext fun x => _
rw [Real.exp, Complex.exp_eq_exp_ℂ, ← exp_ℝ_ℂ_eq_exp_ℂ_ℂ, exp_eq_tsum, exp_eq_tsum_div, ←
    re_to_complex, ← re_clm_apply, re_clm.map_tsum (exp_series_summable' (x : ℂ))]
refine' tsum_congr fun n => _
rw [re_clm.map_smul, ← Complex.of_real_pow, re_clm_apply, re_to_complex, Complex.of_real_re,
    smul_eq_mul, div_eq_inv_mul]
rw [stirling_seq, cast_zero, mul_zero, Real.sqrt_zero, zero_mul, div_zero]
rw [stirling_seq, pow_one, factorial_one, cast_one, mul_one, mul_one_div, one_div_div]
intros
rw [_root_.add_div, div_self hx, inv_eq_one_div]
rw [← sum_range_sub' log_stirling_seq' n]
rw [mul_sum]
conv => 
    congr
    skip
    skip
    rw [one_div, ← add_zero (2 : ℝ)]
refine'
    (((tendsto_const_div_at_top_nhds_0_nat 1).const_add (2 : ℝ)).inv₀
          ((add_zero (2 : ℝ)).symm ▸ two_ne_zero)).congr'
      (eventually_at_top.mpr ⟨1, fun n hn => _⟩)
rw [add_div' (1 : ℝ) (2 : ℝ) (n : ℝ) (cast_ne_zero.mpr (one_le_iff_ne_zero.mp hn)), inv_div]
simp [inner_def, mul_comm]
simp only [inner_def, add_mul, add_re]
simp [inner_def]
rw [← inner_self, real_inner_self_eq_norm_mul_norm]
rw [norm_eq_sqrt_real_inner, inner_self, norm_sq.map_one, Real.sqrt_one]
rw [norm_eq_sqrt_real_inner, inner_self, norm_sq_coe, Real.sqrt_sq_eq_abs, Real.norm_eq_abs]
simp only [norm_eq_sqrt_real_inner, inner_self, norm_sq.map_mul]
exact Real.sqrt_mul norm_sq_nonneg _
assumption
apply (closure_minimal (convex_hull_min extreme_points_subset hAconv) hscomp.is_closed).antisymm
apply
    convex_on_of_deriv2_nonneg (convex_Ici _) (continuous_pow n).ContinuousOn
      (differentiableOnPow n)
· simp only [deriv_pow']
    exact (@differentiableOnPow ℝ _ _ _).const_mul (n : ℝ)
· intro x hx
    rw [iter_deriv_pow, Finset.prod_range_cast_nat_sub]
    exact mul_nonneg (Nat.cast_nonneg _) (pow_nonneg (interior_subset hx) _)
apply StrictMonoOn.strict_convex_on_of_deriv (convex_Ici _) (continuous_on_pow _)
rw [deriv_pow', interior_Ici]
exact fun x (hx : 0 < x) y hy hxy =>
    mul_lt_mul_of_pos_left (pow_lt_pow_of_lt_left hxy hx.le <| Nat.sub_pos_of_lt hn)
      (Nat.cast_pos.2 <| zero_lt_two.trans_le hn)
rw [Finset.prod_mul_distrib, Finset.prod_ite, Finset.prod_const_one, mul_one,
        Finset.prod_const, neg_one_pow_eq_pow_mod_two, Nat.even_iff.1 h0, pow_zero, one_mul]
apply strict_concave_on_of_deriv2_neg' (convex_Ioi 1) _ fun x hx => _
·
    exact
      continuous_sqrt.continuous_on.mul
        (continuous_on_log.mono fun x hx => ne_of_gt (zero_lt_one.trans hx))
· rw [deriv2_sqrt_mul_log x]
    exact
      div_neg_of_neg_of_pos (neg_neg_of_pos (log_pos hx))
        (mul_pos four_pos (pow_pos (sqrt_pos.mpr (zero_lt_one.trans hx)) 3))
apply strict_concave_on_of_deriv2_neg (convex_Icc _ _) continuous_on_sin fun x hx => _
rw [interior_Icc] at hx
simp [sin_pos_of_mem_Ioo hx]
apply strict_concave_on_of_deriv2_neg (convex_Icc _ _) continuous_on_cos fun x hx => _
rw [interior_Icc] at hx
simp [cos_pos_of_mem_Ioo hx]
cases K
cases L
congr
simp
rw [add_comm]
exact hs.combo_interior_closure_subset_interior hb ha (add_comm a b ▸ hab)
rw [add_comm]
exact hs.combo_interior_self_subset_interior hb ha (add_comm a b ▸ hab)
refine' strict_convex_iff_open_segment_subset.2 _
intro x hx y hy hne
refine' is_path_connected_iff.mpr ⟨hne, _⟩
intro x x_in y y_in
have H := hconv.segment_subset x_in y_in
rw [segment_eq_image_line_map] at H
exact
    JoinedIn.of_line affine_map.line_map_continuous.continuous_on (line_map_apply_zero _ _)
      (line_map_apply_one _ _) H
rw [norm_smul, norm_smul, Real.norm_of_nonneg ha, Real.norm_of_nonneg hb]
rw [← add_ball_zero]
exact hs.add (convex_ball 0 _)
simp only [Metric.diam, convex_hull_ediam]
simp only [Metric.bounded_iff_ediam_ne_top, convex_hull_ediam]
simp [r_pos]
simp [convexJoin]
simp [convexJoin]
simp [convexJoin]
simp [convexJoin]
simp [convexJoin]
simp [convexJoin]
simp only [convex_hull_insert, insert_nonempty, singleton_nonempty, convex_hull_pair, ←
    convex_join_assoc, convex_join_singletons]
rw [← pair_eq_singleton, ← convex_join_segments, segment_same, pair_eq_singleton]
rw [← segment_same 𝕜, convex_join_segments, insert_idem]
simp only [Set.insert_comm]
rw [← convex_hull_convex_hull_union_left, ← convex_hull_convex_hull_union_right]
exact
    (convex_convex_hull 𝕜 s).convex_hull_union (convex_convex_hull 𝕜 t) hs.convex_hull
      ht.convex_hull
simp only [center_mass, sum_empty, smul_zero]
simp only [center_mass, sum_pair hne, smul_add, (mul_smul _ _ _).symm, div_eq_inv_mul]
simp only [center_mass, sum_insert ha, smul_add, (mul_smul _ _ _).symm, ← div_eq_inv_mul]
congr 2
rw [div_mul_eq_mul_div, mul_inv_cancel hw, one_div]
rw [center_mass, sum_singleton, sum_singleton, ← mul_smul, inv_mul_cancel hw, one_smul]
simp only [Finset.centerMass, hw, inv_one, one_smul]
simp only [Finset.centerMass, Finset.smul_sum, (mul_smul _ _ _).symm, mul_comm c, mul_assoc]
rw [s.center_mass_eq_of_sum_1 _ hws, t.center_mass_eq_of_sum_1 _ hwt, smul_sum, smul_sum, ←
    Finset.sum_sum_elim, Finset.center_mass_eq_of_sum_1]
· congr
simp only [mul_sum.symm, sum_add_distrib, mul_one, *]
rw [center_mass, sum_subset ht h, smul_sum, center_mass, smul_sum]
apply sum_subset ht
intro i hit' hit
rw [h i hit' hit, zero_smul, smul_zero]
rw [center_mass, inv_smul_le_iff hw₁, sum_smul]
exact sum_le_sum fun i hi => smul_le_smul_of_nonneg (le_sup' _ hi) <| hw₀ i hi
infer_instance
simp [ws i hi]
refine' ⟨fun hs t w hw₀ hw₁ hts => hs.sum_mem hw₀ hw₁ hts, _⟩
intro h x hx y hy a b ha hb hab
rw [affine_combination_eq_center_mass hw₁]
apply s.center_mass_mem_convex_hull hw₀
· simp [hw₁]
· simp
simp [finset.nonempty_iff_ne_empty.mp hs]
simp
simp
simp [hi]
rw [sum_add_distrib, ← sum_subset (subset_union_left s s'), ←
            sum_subset (subset_union_right s s'), sum_ite_of_true _ _ fun i hi => hi,
            sum_ite_of_true _ _ fun i hi => hi, ← mul_sum, ← mul_sum, hw₁, hw₁', ← add_mul, hab,
            mul_one] <;>
          intro i hi hi' <;>
        simp [hi']
rw [Finset.convex_hull_eq, Set.mem_setOf_eq]
rw [b.tot]
exact AffineSubspace.mem_top R E x
refine'
    StrictConvexSpace.ofNormComboNeOne fun x y hx hy hne =>
      ⟨1 / 2, 1 / 2, one_half_pos.le, one_half_pos.le, add_halves _, _⟩
rw [← smul_add, norm_smul, Real.norm_of_nonneg one_half_pos.le, one_div, ← div_eq_inv_mul, Ne.def,
    div_eq_one_iff_eq (two_ne_zero' ℝ)]
exact h hx hy hne
refine' StrictConvexSpace.ofPairwiseSphereNormNeTwo fun x hx y hy => mt fun h₂ => _
rw [mem_sphere_zero_iff_norm] at hx hy
exact (same_ray_iff_of_norm_eq (hx.trans hy.symm)).1 (h x y hx hy h₂)
simp only [← mem_ball_zero_iff, ← mem_closed_ball_zero_iff] at hx hy⊢
exact combo_mem_ball_of_ne hx hy hne ha hb hab
rw [← add_div, div_self hxy.ne']
refine' abs_sub_lt_iff.2 ⟨lt_norm_sub_of_not_same_ray h, _⟩
rw [norm_sub_rev]
exact lt_norm_sub_of_not_same_ray (mt SameRay.symm h)
simp only [mem_segment_iff_same_ray, same_ray_iff_norm_add, dist_eq_norm', sub_add_sub_cancel',
    eq_comm]
rw [norm_smul, Real.norm_of_nonneg (one_div_nonneg.2 zero_le_two), ← inv_eq_one_div, ←
    div_eq_inv_mul, div_lt_iff (zero_lt_two' ℝ), mul_two, ← not_same_ray_iff_of_norm_eq h,
    not_same_ray_iff_norm_add_lt, h]
rw [← dist_add_dist_eq_iff, dist_zero_left, dist_vsub_cancel_right, ← dist_eq_norm_vsub', ←
      dist_eq_norm_vsub', hxy, hyz, ← add_mul, add_sub_cancel'_right, one_mul]
apply eq_midpoint_of_dist_eq_half
·
          rw [hi.dist_eq, hi.dist_eq, dist_left_midpoint, Real.norm_of_nonneg zero_le_two,
            div_eq_inv_mul]
·
          rw [hi.dist_eq, hi.dist_eq, dist_midpoint_right, Real.norm_of_nonneg zero_le_two,
            div_eq_inv_mul]
simp [AffineMap.ofMapMidpoint, ← dist_eq_norm_vsub E, hi.dist_eq]
intro x hx y hy hxy a b ha hb hab
rw [interior_univ]
exact mem_univ _
intro x hx y hy hxy a b ha hb hab
rw [interior_inter]
exact ⟨hs hx.1 hy.1 hxy ha hb hab, ht hx.2 hy.2 hxy ha hb hab⟩
rw [sUnion_eq_Union]
exact (directedOn_iff_directed.1 hdir).strict_convex_Union fun s => hS _ s.2
intro x hx y hy hxy a b ha hb hab
refine' preimage_interior_subset_interior_preimage hf _
rw [mem_preimage, f.map_add, f.map_smul, f.map_smul]
exact hs hx hy (hfinj.ne hxy) ha hb hab
rw [smul_add, ← add_assoc, ← add_smul, sub_add_cancel, one_smul]
apply h.open_segment_subset hx hy hxy
rw [open_segment_eq_image']
exact mem_image_of_mem _ ⟨ht₀, ht₁⟩
intro x hx y hy hxy a b ha hb hab
refine' preimage_interior_subset_interior_preimage hf _
rw [mem_preimage, Convex.combo_affine_apply hab]
exact hs hx hy (hfinj.ne hxy) ha hb hab
apply h hx hy hxy (div_pos ha <| add_pos ha hb) (div_pos hb <| add_pos ha hb)
rw [← add_div]
exact div_self (add_pos ha hb).ne'
rw [mem_smul_set_iff_inv_smul_mem₀ (zero_lt_one.trans ht).ne']
exact hs.smul_mem_of_zero_mem zero_mem hx hx₀ (inv_pos.2 <| zero_lt_one.trans ht) (inv_lt_one ht)
rw [← one_mul x, ← hab, add_mul]
exact add_lt_add_left ((mul_lt_mul_left hb).2 hxz) _
rw [← one_mul z, ← hab, add_mul]
exact add_lt_add_right ((mul_lt_mul_left ha).2 hxz) _
rw [← one_mul x, ← hab, add_mul]
exact add_lt_add_left ((mul_lt_mul_left hb).2 hxz) _
rw [← one_mul z, ← hab, add_mul]
exact add_lt_add_right ((mul_lt_mul_left ha).2 hxz) _
cases S <;> cases T <;> congr
simp [infi]
simp
rw [mem_preimage, f.map_smul c]
exact S.smul_mem hc hx
rw [mem_preimage, f.map_add]
exact S.add_mem hx hy
rw [pointed_iff_not_blunt, not_not]
rw [salient_iff_not_flat, blunt_iff_not_pointed]
exact mt flat.pointed
change x - x ∈ S <;> rw [sub_self x] <;> exact h₁
  le_trans x y z xy zy
intro a b ab ba
infer_instance
intro a b hab c
change c + b - (c + a) ∈ S
rw [add_sub_add_left_eq_sub]
exact hab
simp
simp
rw [pointed, mem_zero]
simp only [to_cone, ConvexCone.mem_mk, mem_Union, mem_smul_set, eq_comm, exists_prop]
rw [smul_smul, inv_mul_cancel hc.ne', one_smul]
simp
rw [real_inner_smul_right]
exact mul_nonneg hc.le (hy x hx)
rw [inner_add_right]
exact add_nonneg (hu x hx) (hv x hx)
apply SetLike.coe_injective
exact eq_singleton_iff_unique_mem.mpr ⟨fun x hx => inner_zero_right.ge, this⟩
rw [inner_zero_right]
rw [insert_eq, inner_dual_cone_union]
rw [← ConvexCone.coe_infi, ← inner_dual_cone_Union, Union_of_singleton_coe]
rw [inner_dual_cone_singleton, ConvexCone.coe_comap, ConvexCone.coe_positive, innerₛₗ_apply_coe]
  -- the preimage is closed as `inner x` is continuous and `[0, ∞)` is closed
rw [closure_Ioi (0 : ℝ), mem_Ici]
rw [sub_add_cancel]
refine' fun x hx y hy a b ha hb hab => _
have h := hf _ ⟨hx.1, le_max_left _ _⟩ ⟨hy.1, le_max_right _ _⟩ ha hb hab
exact ⟨h.1, h.2.trans_lt <| max_lt hx.2 hy.2⟩
rw [s_same_side, s_same_side, w_same_side_comm, and_comm' (x ∉ s)]
rw [s_opp_side, s_opp_side, w_opp_side_comm, and_comm' (x ∉ s)]
simp [w_same_side, not_mem_bot]
simp [w_opp_side, not_mem_bot]
refine' ⟨x, hx, x, hx, _⟩
simp
refine' ⟨x, hx, x, hx, _⟩
simp
rw [w_same_side_comm, w_same_side_vadd_left_iff hv, w_same_side_comm]
rw [s_same_side, s_same_side, w_same_side_vadd_left_iff hv, vadd_mem_iff_mem_of_mem_direction hv]
rw [s_same_side_comm, s_same_side_vadd_left_iff hv, s_same_side_comm]
rw [w_opp_side_comm, w_opp_side_vadd_left_iff hv, w_opp_side_comm]
rw [s_opp_side, s_opp_side, w_opp_side_vadd_left_iff hv, vadd_mem_iff_mem_of_mem_direction hv]
rw [s_opp_side_comm, s_opp_side_vadd_left_iff hv, s_opp_side_comm]
refine' ⟨p₂, hp₂, p₁, hp₁, _⟩
rw [vadd_vsub]
exact same_ray_nonneg_smul_left _ ht
refine' ⟨p₂, hp₂, p₁, hp₁, _⟩
rw [vadd_vsub, ← neg_neg t, neg_smul, ← smul_neg, neg_vsub_eq_vsub_rev]
exact same_ray_nonneg_smul_left _ (neg_nonneg.2 ht)
simp [s_opp_side]
rw [s_same_side, and_comm', w_same_side_iff_exists_left h, and_assoc', and_congr_right_iff]
intro hx
rw [or_iff_right hx]
rw [s_opp_side, and_comm', w_opp_side_iff_exists_left h, and_assoc', and_congr_right_iff]
intro hx
rw [or_iff_right hx]
refine' fun i j hij => hc {j} i _
rw [hij, Set.image_singleton, convex_hull_singleton]
exact Set.mem_singleton _
rw [mem_filter] at mem
exact mem.2
rw [sum_sub_distrib, fsum, ← mul_sum, gsum, mul_zero, sub_zero]
rw [mem_filter] at hes
exact hes.2
rw [hk, zero_smul]
rw [← Finset.coe_nonempty, ← @convex_hull_nonempty_iff 𝕜]
exact ⟨x, mem_min_card_finset_of_mem_convex_hull hx⟩
rw [sUnion_eq_Union]
exact (directedOn_iff_directed.1 hdir).convex_Union fun A => hc A.2
rw [f.map_add, f.map_smul, f.map_smul]
intro x hx y hy a b ha hb hab
rw [mem_preimage, f.map_add, f.map_smul, f.map_smul]
exact hs hx hy ha hb hab
rw [← add_image_prod]
exact (hs.prod ht).is_linear_image IsLinearMap.is_linear_map_add
rw [smul_add, ← add_assoc, ← add_smul, sub_add_cancel, one_smul]
apply h.segment_subset hx hy
rw [segment_eq_image']
exact mem_image_of_mem _ ht
intro x hx y hy a b ha hb hab
rw [eq_sub_of_add_eq hab, ← AffineMap.line_map_apply_module]
exact AffineMap.line_map_mem b hx hy
rw [sub_eq_add_neg]
exact hs.add ht.neg
rw [mem_smul_set_iff_inv_smul_mem₀ (zero_lt_one.trans_le ht).ne']
exact h.smul_mem_of_zero_mem zero_mem hx ⟨inv_nonneg.2 (zero_le_one.trans ht), inv_le_one ht⟩
rw [← div_self hpq.ne', add_div]
simp only [← mul_smul, smul_add, mul_div_cancel' _ hpq.ne']
refine' fun f hf g hg a b ha hb hab => ⟨fun x => _, _⟩
·
    trace
      "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr add_nonneg, \",\", expr mul_nonneg, \",\", expr hf.1, \",\", expr hg.1, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
· erw [Finset.sum_add_distrib, ← Finset.smul_sum, ← Finset.smul_sum, hf.2, hg.2, smul_eq_mul,
      smul_eq_mul, mul_one, mul_one]
    exact hab
rw [Finset.sum_ite_eq, if_pos (Finset.mem_univ _)]
rw [nonempty_iff_ne_empty, nonempty_iff_ne_empty, Ne.def, Ne.def]
exact not_congr convex_hull_empty_iff
refine'
    (convex_hull_min _ <| convex_segment _ _).antisymm
      (segment_subset_convex_hull (mem_insert _ _) <| mem_insert_of_mem _ <| mem_singleton _)
rw [insert_subset, singleton_subset_iff]
exact ⟨left_mem_segment _ _ _, right_mem_segment _ _ _⟩
refine' le_antisymm _ (affine_span_mono 𝕜 (subset_convex_hull 𝕜 s))
rw [affine_span_le]
exact convex_hull_subset_affine_span s
intros
rfl
intros
rfl
rw [smul_add, smul_add, add_add_add_comm]
rw [smul_add, smul_add, add_add_add_comm, Convex.combo_self hab]
rw [f.map_add, f.map_smul, f.map_smul]
rw [f.map_add, f.map_smul, f.map_smul]
rw [g.map_add, g.map_smul, g.map_smul]
rw [smul_add, smul_add, add_add_add_comm]
rw [smul_add, smul_add, add_add_add_comm]
rw [add_comm] at hab hfx⊢
exact hf.le_left_of_right_le' hy hx hb ha hab hfx
rw [add_comm] at hab hfx⊢
exact hf.lt_left_of_right_lt' hy hx hb ha hab hfx
rw [← neg_convex_on_iff, neg_neg f]
rw [← neg_strict_convex_on_iff, neg_neg f]
rw [smul_add, smul_add, add_add_add_comm, Convex.combo_self hab]
rw [smul_add, smul_comm c, smul_comm c] <;> infer_instance
rw [Convex.combo_affine_apply hab]
intro h x hx y hy a b ha hb hab
apply h hx hy (div_nonneg ha hab.le) (div_nonneg hb hab.le)
rw [← add_div, div_self hab.ne']
intro h x hx y hy hxy a b ha hb
have hab := add_pos ha hb
apply h hx hy hxy (div_pos ha hab) (div_pos hb hab)
rw [← add_div, div_self hab.ne']
rw [← add_smul, yac, one_smul]
rw [← hg0] at h_localmin
exact h_localmin.comp_continuous_on h_maps hgc.continuous_on (left_mem_Icc.2 zero_le_one)
refine' IsMinOn.of_is_local_min_on_of_convex_on_Icc one_pos fg_local_min_on _
exact (h_conv.comp_affine_map g).Subset h_maps (convex_Icc 0 1)
refine'
        measure_Union_null fun n =>
          H _ (hs.inter (convex_ball _ _)) _ (bounded_ball.mono (inter_subset_right _ _))
rw [interior_inter, is_open_ball.interior_eq]
exact ⟨hx, mem_ball_self (add_pos_of_nonneg_of_pos n.cast_nonneg zero_lt_one)⟩
simp only [B, N]
simp [Nat.lt_floor_add_one]
intro r hr
refine'
      (measure_mono <| hs.closure_subset_image_homothety_interior_of_one_lt hx r hr).trans_eq _
rw [add_haar_image_homothety, ← Nnreal.coe_pow, Nnreal.abs_eq, Ennreal.of_real_coe_nnreal]
simp
rw [segment_eq_image_line_map, affineSegment]
rw [affineSegment, affineSegment, Set.image_image, ← comp_line_map]
rfl
rw [← affine_segment_const_vadd_image, (AddAction.injective v).mem_set_image]
rw [← affine_segment_vadd_const_image, (vadd_right_injective p).mem_set_image]
rw [← affine_segment_const_vsub_image, (vsub_right_injective p).mem_set_image]
rw [← affine_segment_vsub_const_image, (vsub_left_injective p).mem_set_image]
rw [Wbtw, ← affine_segment_image]
exact Set.mem_image_of_mem _ h
refine' Function.Injective.wbtw_map_iff (_ : Function.Injective f.to_affine_map)
exact f.injective
refine' Function.Injective.sbtw_map_iff (_ : Function.Injective f.to_affine_map)
exact f.injective
rw [Wbtw, Wbtw, affine_segment_comm]
rw [Sbtw, Sbtw, wbtw_comm, ← and_assoc', ← and_assoc', and_right_comm]
refine' le_antisymm _ hty.1
rw [← h, Left.neg_nonpos_iff]
exact mul_nonneg htx.1 (sub_nonneg.2 hty.2)
rw [wbtw_comm, wbtw_swap_right_iff, eq_comm]
rw [← wbtw_swap_left_iff R z, and_iff_right h]
rw [← wbtw_swap_right_iff R x, and_iff_right h]
rw [← wbtw_rotate_iff R x, and_iff_right h]
rw [sbtw_iff_mem_image_Ioo_and_ne, and_comm', and_congr_right]
intro hxy
rw [(line_map_injective R hxy).mem_set_image]
rw [wbtw_comm, wbtw_zero_one_iff]
rw [Sbtw, wbtw_zero_one_iff, Set.mem_Icc, Set.mem_Ioo]
exact
    ⟨fun h => ⟨h.1.1.lt_of_ne (Ne.symm h.2.1), h.1.2.lt_of_ne h.2.2⟩, fun h =>
      ⟨⟨h.1.le, h.2.le⟩, h.1.ne', h.2.Ne⟩⟩
rw [sbtw_comm, sbtw_zero_one_iff]
rw [wbtw_comm] at *
exact h₁.trans_left h₂
rw [wbtw_comm] at *
rw [sbtw_comm] at *
exact h₁.trans_sbtw_left h₂
rw [wbtw_comm, wbtw_iff_left_eq_or_right_mem_image_Ici]
rw [sbtw_comm, sbtw_iff_left_ne_and_right_mem_image_IoI]
refine' ⟨r₁ / r₂, ⟨div_nonneg hr₁ (hr₁.trans hr₂), div_le_one_of_le hr₂ (hr₁.trans hr₂)⟩, _⟩
rw [wbtw_comm]
exact wbtw_smul_vadd_smul_vadd_of_nonpos_of_nonneg x v hr₂ hr₁
simp [this]
rw [wbtw_comm] at *
exact h₁.trans_left_right h₂
simp [h, hr₂.ne']
simp [h]
simp only [segment, image, Prod.exists, mem_set_of_eq, exists_prop, and_assoc']
simp only [openSegment, image, Prod.exists, mem_set_of_eq, exists_prop, and_assoc']
rw [zero_smul, one_smul, add_zero]
rw [← insert_endpoints_open_segment] at hz
exact (hz.resolve_left hx.symm).resolve_left hy.symm
simp only [← insert_endpoints_open_segment, insert_subset, *, true_and_iff]
simp only [add_sub_cancel]
simp only [add_sub_cancel]
rw [segment_eq_image', segment_eq_image']
refine' exists_congr fun θ => and_congr Iff.rfl _
simp only [add_sub_add_left_eq_sub, add_assoc, add_right_inj]
rw [open_segment_eq_image', open_segment_eq_image']
refine' exists_congr fun θ => and_congr Iff.rfl _
simp only [add_sub_add_left_eq_sub, add_assoc, add_right_inj]
rw [open_segment_symm, left_mem_open_segment_iff, eq_comm]
cases le_total x y
· rw [interval_of_le h]
    exact segment_subset_Icc h
· rw [interval_of_ge h, segment_symm]
    exact segment_subset_Icc h
cases le_total x y
· rw [segment_eq_Icc h, max_eq_right h, min_eq_left h]
· rw [segment_symm, segment_eq_Icc h, max_eq_left h, min_eq_right h]
cases hxy.lt_or_lt
· rw [open_segment_eq_Ioo h, max_eq_right h.le, min_eq_left h.le]
· rw [open_segment_symm, open_segment_eq_Ioo h, max_eq_left h.le, min_eq_right h.le]
rw [sUnion_eq_Union]
exact star_convex_Union fun s => hS _ s.2
rw [f.map_add, f.map_smul, f.map_smul]
intro y hy a b ha hb hab
rw [mem_preimage, f.map_add, f.map_smul, f.map_smul]
exact hs hy ha hb hab
rw [← add_image_prod]
exact (hs.prod ht).is_linear_image IsLinearMap.is_linear_map_add
rw [← hab]
exact le_add_of_nonneg_left ha
rw [smul_add, ← add_assoc, ← add_smul, sub_add_cancel, one_smul]
apply hs.segment_subset hy
rw [segment_eq_image']
exact mem_image_of_mem _ ⟨ht₀, ht₁⟩
intro y hy a b ha hb hab
rw [mem_preimage, Convex.combo_affine_apply hab]
exact hs hy ha hb hab
rw [← image_neg]
exact hs.is_linear_image IsLinearMap.is_linear_map_neg
have h' := h hy ha hb
rw [hab, div_one, div_one] at h'
exact h' zero_lt_one
rw [mem_smul_set_iff_inv_smul_mem₀ (zero_lt_one.trans_le ht).ne']
exact hs.smul_mem hx (inv_nonneg.2 <| zero_le_one.trans ht) (inv_le_one ht)
rw [hA.mem_extreme_points_iff_convex_diff, hA.convex_remove_iff_not_mem_convex_hull_remove,
    mem_diff]
rw [inter_comm]
exact hC.inter_left hCA
trace
    "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr Inf (λ r, _)]]"
exact and_congr_right fun hr => mem_smul_set_iff_inv_smul_mem₀ hr.ne' _ _
rw [gauge_def']
rw [← gauge_neg_set_neg, neg_neg]
rw [← smul_eq_mul, ← gauge_smul_of_nonneg (norm_nonneg r), gauge_norm_smul hs]
infer_instance
intro x hx
let f : ℝ → E := fun t => t
rw [Seminorm.ball_zero_eq]
exact gauge_lt_one_eq_self_of_open hs₁ hs₂.zero_mem hs
simp only [h₀.2, mem_range_self]
rw [← measure_to_measurable] at h0
rw [← restrict_to_measurable (measure_ne_top μ t)] at ht
simp [Ennreal.to_real_pos_iff, pos_iff_ne_zero, h₀, measure_lt_top]
cases f <;> cases g <;> congr
simp
simp [Pi.zero_def]
rw [coe_coe_hom]
exact FunLike.coe_injective
have A : WithSeminorms (schwartzSeminormFamily ℝ E F) := ⟨rfl⟩
rw [SeminormFamily.with_seminorms_iff_nhds_eq_infi] at A⊢
rw [A]
rfl
rw [(schwartzWithSeminorms 𝕜 E F).with_seminorms_eq]
exact (schwartzSeminormFamily 𝕜 E F).ModuleFilterBasis.HasContinuousSmul
cases f <;> cases g <;> congr
simp [eq_zero_iff]
rw [h]
exact one_ne_zero
cases f <;> cases g <;> congr
cases f <;> cases g <;> congr
cases f <;> cases g <;> congr
rw [← RingSeminorm.to_fun_eq_coe, hx, zero_mul]
simp
simp
simp [ULift.norm_def]
simp [Prod.norm_def]
simp [Pi.norm_def, Finset.sup_const Finset.univ_nonempty]
simp [mul_comm]
apply max_mul_mul_le_max_mul_max <;> simp [norm_nonneg]
simp [max_comm]
simp
rw [n.cast_succ, n.cast_succ, add_mul, one_mul]
exact norm_add_le_of_le (Nat.norm_cast_le n) le_rfl
simp
simp [Nnreal.coe_list_prod, List.map_map]
simp
simp [Nnreal.coe_list_prod, List.map_map]
simp [Nnreal.coe_prod]
simp [Nnreal.coe_prod]
simp only [pow_one]
simp only [pow_zero, nnnorm_one]
simp only [pow_zero, norm_one]
rw [mul_sub, sub_mul, sub_add_sub_cancel]
rw [← norm_mul, mul_one, mul_one]
simp
rw [← norm_inv, ← norm_inv, ← norm_mul, ← norm_mul, mul_sub, sub_mul, mul_assoc _ e,
          inv_mul_cancel r0, mul_inv_cancel e0, one_mul, mul_one]
rw [← MonoidHom.map_pow, h, MonoidHom.map_one]
simp [Real.to_nnreal_of_nonneg, nnnorm, norm_of_nonneg, hx]
simp [Real.to_nnreal_of_nonneg, nnnorm, norm_of_nonneg, hy]
rw [Real.norm_eq_abs, x.abs_eq]
simp [dist_eq_norm]
simp [dist_eq_norm]
simp only [norm, Int.cast_mul, abs_mul]
simp only [Int.dist_eq, norm, Int.cast_sub]
simp only [Int.cast_ofNat, Nnreal.coe_nat_cast]
simp only [← Int.abs_eq_natAbs, Int.cast_abs]
rw [Int.abs_eq_natAbs, Int.ofNat_le, Nat.le_floor_iff (zero_le c)]
congr
exact Nnreal.coe_nat_abs z
simp [← Int.norm_cast_real]
simp only [norm, Rat.cast_mul, abs_mul]
simp only [Rat.dist_eq, norm, Rat.cast_sub]
unfold norm
exact (map_mul f x y).symm ▸ norm_mul_le (f x) (f y)
unfold norm
exact (map_mul f x y).symm ▸ norm_mul (f x) (f y)
rw [mem_ball_zero_iff] at *
exact (norm_mul_le x y).trans_lt (mul_lt_one_of_nonneg_of_lt_one_left (norm_nonneg _) hx hy.le)
rw [mem_closed_ball_zero_iff] at *
exact (norm_mul_le x y).trans (mul_le_one hx (norm_nonneg _) hy)
rw [mem_sphere_zero_iff_norm] at *
simp [*]
rw [norm_inv, mem_sphere_zero_iff_norm.1 x.coe_prop, inv_one]
rw [norm_div, mem_sphere_zero_iff_norm.1 x.coe_prop, mem_sphere_zero_iff_norm.1 y.coe_prop,
          div_one]
rw [mem_sphere_zero_iff_norm, norm_zpow, mem_sphere_zero_iff_norm.1 x.coe_prop, one_zpow]
simp
simp
simp
intro x y
apply completion.induction_on₂ x y <;> clear x y
· refine' is_closed_eq (completion.uniform_continuous_extension₂ _).Continuous _
        exact Continuous.comp completion.continuous_extension continuous_sub
· intro x y
        rw [← completion.coe_sub, norm_coe, completion.dist_eq, dist_eq_norm]
apply to_add_monoid_hom_injective
exact AddMonoidHom.completion_zero
apply to_add_monoid_hom_injective
exact f.to_add_monoid_hom.completion_add g.to_add_monoid_hom f.continuous g.continuous
simp [le_refl]
rw [f.mem_ker, map_sub, sub_eq_zero.mpr hgg'.symm]
rw [f.completion_coe, completion.norm_coe]
rw [sub_zero _]
rw [(f.completion.mem_ker _).mp hatg_in]
rw [map_sub]
rw [norm_sub_rev, f.norm_completion]
rw [mul_assoc]
exact (mul_le_mul_left C'_pos).mpr this
rw [abs_mul, abs_inv]
rw [← (eq_inv_mul_iff_mul_eq₀ ht').mp hw', abs_mul]
rw [← this, neg_one_mul]
simp
rw [quotient_norm_eq, this, image_singleton, Real.norm_eq_abs, cInf_singleton]
simp [mem_lower_bounds]
rw [abs_sub_comm, abs_one_sub_fract]
simp [norm_eq, this]
simp [hε]
simp [-zsmul_eq_mul, ← QuotientAddGroup.coe_zero, coe_real_preimage_closed_ball_eq_Union,
        Union_inter, Union_ite, this, hε]
rw [mul_comm _ p, inv_mul_cancel_left₀ hp.out.ne.symm]
simp [AddCircle.norm_eq]
rw [div_eq_mul_inv, ← map_inv_eq_map f y]
exact map_mul_le_add _ _ _
rw [← inv_div, map_inv_eq_map]
rw [abs_sub_le_iff, sub_le_iff_le_add', sub_le_iff_le_add']
exact ⟨le_map_add_map_div _ _ _, le_map_add_map_div' _ _ _⟩
rw [two_mul, ← map_one_eq_zero f, ← div_self' a]
exact map_div_le_add _ _ _
cases f <;> cases g <;> congr
rw [map_one_eq_zero p, map_one_eq_zero q, zero_add]
rw [map_inv_eq_map p, map_inv_eq_map q]
rw [Pi.sup_apply, ← map_one_eq_zero p, sup_eq_left, map_one_eq_zero p, map_one_eq_zero q]
rw [Pi.sup_apply, Pi.sup_apply, map_inv_eq_map p, map_inv_eq_map q]
rw [f.map_one, map_one_eq_zero p]
rw [map_inv, map_inv_eq_map p]
refine' cinfi_le_of_le mul_bdd_below_range_add (u * v) _
rw [mul_div_mul_comm, add_add_add_comm]
exact add_le_add (map_mul_le_add p _ _) (map_mul_le_add q _ _)
rw [div_self', map_one_eq_zero q, add_zero]
simp only [div_one, map_one_eq_zero p, zero_add]
simp only [← smul_one_smul ℝ≥0 r (_ : ℝ), Nnreal.smul_def, smul_eq_mul, map_zero, mul_zero]
simp only [← smul_one_smul ℝ≥0 r (_ : ℝ), Nnreal.smul_def, smul_eq_mul]
exact
          (mul_le_mul_of_nonneg_left (map_add_le_add _ _ _) <| Nnreal.coe_nonneg _).trans_eq
            (mul_add _ _ _)
rw [map_neg_eq_map]
simp only [← smul_one_smul ℝ≥0 r (_ : ℝ), Nnreal.smul_def, smul_eq_mul, map_one_eq_zero p,
          mul_zero]
simp only [← smul_one_smul ℝ≥0 r (_ : ℝ), Nnreal.smul_def, smul_eq_mul]
exact
          (mul_le_mul_of_nonneg_left (map_mul_le_add p _ _) <| Nnreal.coe_nonneg _).trans_eq
            (mul_add _ _ _)
rw [map_inv_eq_map p]
cases f <;> cases g <;> congr
rw [summable_iff_cauchy_seq_finset, cauchy_seq_finset_iff_vanishing_norm]
intro i hi
simp only [disjoint_left, mem_union, not_or, h.mem_to_finset, Set.mem_compl_iff, not_not] at ht
exact (ht hi).2
rw [summable_iff_cauchy_seq_finset]
exact cauchy_seq_finset_of_norm_bounded g hg h
simp only [← Nnreal.coe_le_coe, ← Nnreal.has_sum_coe, coe_nnnorm] at *
exact tsum_of_norm_bounded hg h
simp only [div_self', map_one_eq_zero]
rw [dist_comm, dist_eq_norm_div]
rw [dist_eq_norm_div, div_one]
rw [dist_comm, dist_one_right]
rw [← dist_one_right, ← h₁, hi.dist_eq, dist_one_right]
simp [dist_eq_norm_div]
rw [← dist_one_left, ← dist_mul_right 1 a b, one_mul]
rw [dist_comm, dist_mul_self_right]
rw [← dist_mul_right _ _ b, div_mul_cancel']
rw [← dist_mul_right _ _ c, div_mul_cancel']
rw [← dist_one_right]
exact dist_nonneg
rw [← dist_one_right, dist_self]
rw [Subsingleton.elim a 1, norm_one']
rw [dist_eq_norm_div]
apply norm_div_le
rw [add_comm]
refine' (norm_mul_le' _ _).trans_eq' _
rw [div_mul_cancel']
rw [norm_div_rev]
exact norm_le_norm_add_norm_div' v u
rw [mul_div_cancel'']
simp [dist_eq_norm_div]
simp
rw [mem_ball, dist_eq_norm_div]
rw [mem_ball', dist_eq_norm_div]
rw [mem_ball, dist_one_right]
rw [mem_closed_ball, dist_eq_norm_div]
rw [mem_closed_ball, dist_one_right]
rw [mem_closed_ball', dist_eq_norm_div]
simp [dist_eq_norm_div]
simp [dist_eq_norm_div]
simp only [dist_one_right]
simp [Metric.cauchy_seq_iff, dist_eq_norm_div]
simp only [lipschitz_on_with_iff_dist_le_mul, dist_eq_norm_div]
simp only [lipschitz_with_iff_dist_le_mul, dist_eq_norm_div]
rw [edist_dist, dist_eq_norm_div, of_real_norm_eq_coe_nnnorm']
rw [edist_eq_coe_nnnorm_div, div_one]
rw [Emetric.mem_ball, edist_eq_coe_nnnorm']
simp [edist_dist]
rw [tendsto_iff_norm_tendsto_one]
simp only [div_one]
rw [← closed_ball_zero', mem_closed_ball_one_iff, (norm_nonneg' x).le_iff_eq]
simp [Metric.mem_closure_iff, dist_eq_norm_div]
rw [← not_le, norm_le_zero_iff''']
rw [tendsto_uniformly_on_iff_tendsto_uniformly_on_filter,
    uniform_cauchy_seq_on_iff_uniform_cauchy_seq_on_filter,
    SeminormedGroup.uniform_cauchy_seq_on_filter_iff_tendsto_uniformly_on_filter_one]
simp [dist_eq_norm_div]
rw [dist_inv, inv_inv]
simp only [div_eq_mul_inv, dist_mul_left, dist_inv_inv]
rw [← dist_one_left, ← dist_mul_left a 1 b, mul_one]
rw [dist_comm, dist_self_mul_right]
rw [div_eq_mul_inv, dist_self_mul_right, norm_inv']
rw [dist_comm, dist_self_div_right]
rw [← Multiplicative.ofAdd_le, of_add_multiset_prod, Multiset.map_map]
refine' Multiset.le_prod_of_submultiplicative (Multiplicative.ofAdd ∘ norm) _ (fun x y => _) _
· simp only [comp_app, norm_one', ofAdd_zero]
· exact norm_mul_le' _ _
rw [← Multiplicative.ofAdd_le, of_add_sum]
refine' Finset.le_prod_of_submultiplicative (Multiplicative.ofAdd ∘ norm) _ (fun x y => _) _ _
· simp only [comp_app, norm_one', ofAdd_zero]
· exact norm_mul_le' _ _
simp only [dist_eq_norm_div, ← Finset.prod_div_distrib] at *
exact norm_prod_le_of_le s h
rw [mem_ball_iff_norm'', mul_div_cancel''']
rw [mem_closed_ball_iff_norm'', mul_div_cancel''']
simp [edist_dist]
rw [edist_inv, inv_inv]
simp only [div_eq_mul_inv, edist_mul_left, edist_inv_inv]
simp
simp [nnnorm]
rw [← of_real_norm_eq_coe_nnnorm, norm_of_nonneg hr]
rw [← Real.nnnorm_abs r, Real.ennnorm_eq_of_real (abs_nonneg _)]
rw [Real.to_nnreal_of_nonneg hr]
congr
rw [Real.norm_eq_abs, abs_of_nonneg hr]
simp [← dist_eq_norm_div, hf.le_mul_dist x y]
exact (tendsto_at_top_of_eventually_const this).CauchySeq.mul hv
  intro n hn
  dsimp [d]
  rw [eventually_constant_prod _ hn]
  intro m hm
  simp [huv m hm]
rw [norm_eq_zero'', div_eq_one]
rw [(norm_nonneg' _).lt_iff_ne, ne_comm]
exact norm_div_eq_zero_iff.not
rw [← Nnreal.coe_eq_zero, coe_nnnorm', norm_eq_zero'']
simp only [Prod.norm_def, Prod.dist_eq, dist_eq_norm_div, Prod.fst_div, Prod.snd_div]
simp only [← dist_one_right, dist_pi_le_iff hr, Pi.one_apply]
simp only [← dist_one_right, dist_pi_lt_iff hr, Pi.one_apply]
rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, vadd_vsub_vadd_cancel_left]
rw [dist_eq_norm_vsub V, dist_eq_norm, vadd_vsub_vadd_cancel_right]
simp [dist_eq_norm_vsub V _ x]
rw [dist_comm, dist_vadd_left]
rw [dist_eq_norm, vsub_sub_vsub_cancel_left, dist_comm, dist_eq_norm_vsub V]
rw [dist_eq_norm, vsub_sub_vsub_comm, dist_eq_norm_vsub V, dist_eq_norm_vsub V]
exact norm_sub_le _ _
simp only [← Nnreal.coe_le_coe, Nnreal.coe_add, ← dist_nndist, dist_vadd_vadd_le]
simp only [← Nnreal.coe_le_coe, Nnreal.coe_add, ← dist_nndist, dist_vsub_vsub_le]
simp
simp only [← neg_vsub_eq_vsub_rev y x, norm_neg]
simp
simp only [← neg_vsub_eq_vsub_rev y x, norm_neg]
simp only [this, norm]
simp only [(mk' S).map_neg, Set.mem_setOf_eq]
simp [Set.bex_image_iff]
simp [dist_eq_norm, ← sub_eq_add_neg, norm_sub_rev]
simp [Metric.mem_closure_iff, dist_comm]
rw [(mk' S).map_add]
erw [quotient_norm_eq_zero_iff]
exact subset_closure S.zero_mem
simp only [norm_mk_zero, sub_self]
simp [quotient_norm_mk_le']
intro h0
exact Set.not_mem_of_mem_compl hx ((quotient_norm_eq_zero_iff S x).1 h0)
exact le_add_of_le_add_left this (min_le_left ε ((1 : ℝ) / 2))
exact sub_le_iff_le_add.mp this
rw [normed_mk.apply, hm]
rw [S.ker_normed_mk]
exact Set.mem_of_eq_of_mem h trivial
rw [mul_add, mul_div_cancel' _ hcpos.ne.symm]
rw [Set.nonempty_image_iff]
exact ⟨0, f.ker.zero_mem⟩
rw [map_add, (NormedAddGroupHom.mem_ker f x).mp hx, add_zero]
simp
apply op_norm_le_bound _ c.coe_nonneg
intro x
simp
simp
infer_instance
rw [AddMonoidHom.map_sub, AddMonoidHom.sub_apply, sub_eq_zero]
exact c.condition
infer_instance
simp [w]
rw [comp_explicit_cokernel_π]
rfl
rw [explicit_cokernel_π_desc]
simp [w]
rw [← CategoryTheory.Category.assoc, cond, limits.zero_comp]
refine' explicit_cokernel_desc_unique _ _ _
rw [← CategoryTheory.Category.assoc, explicit_cokernel_π_desc]
simp
apply explicit_cokernel_desc_unique
rfl
refine' NormedAddGroupHom.NormNoninc.norm_noninc_iff_norm_le_one.2 _
rw [← Nnreal.coe_one]
exact
    explicit_cokernel_desc_norm_le_of_norm_le cond 1
      (NormedAddGroupHom.NormNoninc.norm_noninc_iff_norm_le_one.1 hg)
rw [← cancel_epi (explicit_cokernel_π f), ← category.assoc, explicit_cokernel_π_desc]
simp [cond2]
simp [explicit_cokernel_π, explicit_cokernel_iso, is_colimit.cocone_point_unique_up_to_iso]
simp [explicit_cokernel_π, explicit_cokernel_iso]
simp [reassoc_of h]
delta explicit_cokernel.map
simp [← cancel_epi (explicit_cokernel_π fab), category.assoc, explicit_cokernel_π_desc, h']
rw [inf_edist_inv, inv_inv]
simp only [preimage_mul_ball, image_mul_left, singleton_mul, div_inv_eq_mul, mul_comm y x]
rw [mul_comm, singleton_mul_ball, mul_comm y]
simp
simp [singleton_div_ball]
simp [ball_mul_singleton]
simp [ball_div_singleton]
simp only [mul_comm y x, preimage_mul_closed_ball, image_mul_left, singleton_mul, div_inv_eq_mul]
simp [mul_comm _ {y}, mul_comm y]
simp [div_eq_mul_inv]
simp
simp
simp
simp
simp [div_eq_mul_inv, mul_ball_one]
rw [mul_comm, mul_ball_one]
simp [div_eq_mul_inv, ball_mul_one]
rw [← smul_ball_one, mul_smul_comm, mul_ball_one]
simp [div_eq_mul_inv]
rw [mul_comm, mul_ball]
simp [div_eq_mul_inv]
simp [div_eq_mul_inv, hs.mul_closed_ball_one hδ]
rw [mul_comm, hs.mul_closed_ball_one hδ]
simp [div_eq_mul_inv, mul_comm, hs.inv.mul_closed_ball_one hδ]
rw [← smul_closed_ball_one, mul_smul_comm, hs.mul_closed_ball_one hδ]
simp [div_eq_mul_inv, mul_comm, hs.mul_closed_ball hδ]
rw [mul_comm, hs.mul_closed_ball hδ]
simp [div_eq_mul_inv, mul_comm, hs.closed_ball_mul hδ]
rw [iso.hom_inv_id_apply]
apply Subtype.eq
exact f.hom_inv_id
apply Subtype.eq
exact f.inv_hom_id
rw [iso.hom_inv_id_apply]
cases f <;> cases g <;> congr <;> exact funext H
apply coe_inj
rw [h]
rfl
apply hc
rw [dist_eq_norm, dist_eq_norm, ← map_sub]
apply le_op_norm
rw [add_mul]
simp
rw [zero_mul]
exact norm_zero
rw [hn, zero_mul]
rw [hf, op_norm_zero]
simp [le_refl]
simp
simp [le_op_norm f v]
simp only [norm_def, coe_neg, norm_neg, Pi.neg_apply]
simp only [AddMonoidHom.sub_apply, AddMonoidHom.to_fun_eq_coe, sub_eq_add_neg]
exact (f + -g).bound'
have := dist_smul_pair r (f x) (f 0)
rw [map_zero, smul_zero, dist_zero_right, dist_zero_right] at this
rw [mul_assoc]
refine' this.trans _
refine' mul_le_mul_of_nonneg_left _ dist_nonneg
exact hb x
rw [Pi.smul_apply, nsmul_eq_mul, mul_assoc]
exact (norm_nsmul_le _ _).trans (mul_le_mul_of_nonneg_left (hb _) (Nat.cast_nonneg _))
rw [Pi.smul_apply, smul_eq_mul, mul_assoc]
exact (norm_zsmul_le _ _).trans (mul_le_mul_of_nonneg_left (hb _) <| norm_nonneg _)
simp only [coe_sum, Finset.sum_apply]
rw [mul_assoc]
rw [h]
exact norm_comp_le_of_le hg hf
rw [one_mul]
rfl
erw [f.to_add_monoid_hom.mem_ker]
rfl
erw [g.mem_ker]
show (g.comp f) v = 0
rw [h]
rfl
simp only [map_add]
rfl
rw [range, AddMonoidHom.mem_range]
rfl
erw [AddMonoidHom.map_range]
rfl
rw [← hy] <;> simp
simp
simp
rw [NormedAddGroupHom.sub_apply, sub_eq_zero, ← comp_apply, h, comp_apply]
rw [← comp_assoc, ← comp_assoc, comp_ι_eq]
simp
simp only [← comp_assoc, ← hf, ← hg]
simp only [comp_assoc, comp_ι_eq]
rw [comp_assoc, hf, ← comp_assoc, hf', comp_assoc]
simp [b, mul_div_cancel' _ hC.ne.symm]
apply add_le_add_left hv₀.le
rw [add_comm, mul_add]
simp only [b, mul_div_cancel' _ hC.ne.symm, ← sum_mul]
rw [← add_assoc, sum_range_succ']
rw [add_comm, add_mul]
apply add_le_add_left this
rw [sub_add_sub_cancel]
apply add_le_add
· exact abs_inf_sub_inf_le_abs _ _ _
· rw [@inf_comm _ _ c, @inf_comm _ _ c]
        exact abs_inf_sub_inf_le_abs _ _ _
rw [sub_add_sub_cancel]
apply add_le_add
· exact abs_sup_sub_sup_le_abs _ _ _
· rw [@sup_comm _ _ c, @sup_comm _ _ c]
        exact abs_sup_sub_sup_le_abs _ _ _
rw [Nonneg.coe_one, one_mul, dist_eq_norm, dist_eq_norm]
exact norm_sup_sub_sup_le_norm x y z
rw [this]
exact IsClosed.preimage continuous_neg' is_closed_singleton
simp [mul_assoc, mul_inv_cancel hc0]
simp [← mul_assoc, inv_mul_cancel hc0]
rw [superpolynomial_decay_iff_zpow_tendsto_zero _ hk] at hf⊢
refine' fun z' => (hf <| z' + z).congr' ((hk.eventually_ne_at_top 0).mono fun x hx => _)
simp [zpow_add₀ hx, mul_assoc, Pi.mul_apply]
simp [← mul_assoc, inv_mul_cancel hx]
simp [superpolynomial_decay]
simp
rw [is_O_with]
rw [is_O]
simp only [is_O, is_O_with]
rw [is_o]
simp only [is_o, is_O_with]
rw [is_O] <;> exact ⟨c, h⟩
simp only [is_O_with]
simp only [is_O_with, ← div_eq_inv_mul, le_div_iff' hc]
simp [Subsingleton.elim (f' _) 0, mul_nonneg hc.le]
unfold is_O
exact exists_congr fun c => is_O_with_congr rfl hf hg
unfold is_o
exact forall₂_congr fun c hc => is_O_with_congr (Eq.refl c) hf hg
unfold is_O_with
exact eventually_map
simp only [is_O, is_O_with_map]
simp only [is_o, is_O_with_map]
unfold is_o at *
intro c' c'pos
have : 0 < c' / c := div_pos c'pos hc
exact ((hfg this).trans hgk this.le).congr_const (div_mul_cancel _ hc.ne')
unfold is_o at *
intro c' c'pos
have : 0 < c' / c := div_pos c'pos hc
exact (hfg.trans (hgk this) hc.le).congr_const (mul_div_cancel' _ hc.ne')
rw [one_mul]
exact hfg x
simp only [is_O_with, norm_norm]
unfold is_O
exact exists_congr fun _ => is_O_with_norm_right
unfold is_o
exact forall₂_congr fun _ _ => is_O_with_norm_right
simp only [is_O_with, norm_norm]
unfold is_O
exact exists_congr fun _ => is_O_with_norm_left
unfold is_o
exact forall₂_congr fun _ _ => is_O_with_norm_left
simp only [is_O_with, norm_neg]
unfold is_O
exact exists_congr fun _ => is_O_with_neg_right
unfold is_o
exact forall₂_congr fun _ _ => is_O_with_neg_right
simp only [is_O_with, norm_neg]
unfold is_O
exact exists_congr fun _ => is_O_with_neg_left
unfold is_o
exact forall₂_congr fun _ _ => is_O_with_neg_left
refine' (h₁.trans_le fun x => _).add (h₂.trans_le _) <;> simp [abs_of_nonneg, add_nonneg]
simp
simp only [is_O_with, exists_prop, true_and_iff, norm_zero, mul_zero, norm_le_zero_iff,
    eventually_eq, Pi.zero_apply]
rw [is_O_with] <;> rfl
rw [is_O_iff] <;> rfl
rw [is_O_with] <;> rfl
rw [is_O_iff] <;> rfl
simp [is_O_with_iff]
simp only [is_o_iff, norm_one, mul_one, metric.nhds_basis_closed_ball.tendsto_right_iff,
    Metric.mem_closed_ball, dist_zero_right]
simp only [is_O_iff, norm_one, mul_one]
rfl
simp only [norm_one, zero_le_one]
simp only [norm_one, mul_one, true_imp_iff, mem_Ici]
simp only [is_O_iff, is_bounded_under, is_bounded, eventually_map]
exact
    exists_congr fun c =>
      eventually_congr <| h.mono fun x hx => (div_le_iff <| norm_pos_iff.2 hx).symm
refine' ((h₁.norm_norm.mul h₂.norm_norm).congr rfl _ _).of_norm_norm <;>
    · intros <;> simp only [norm_smul]
refine' ((h₁.norm_norm.mul h₂.norm_norm).congr _ _).of_norm_norm <;>
    · intros <;> simp only [norm_smul]
refine' ((h₁.norm_norm.mul_is_o h₂.norm_norm).congr _ _).of_norm_norm <;>
    · intros <;> simp only [norm_smul]
refine' ((h₁.norm_norm.mul_is_O h₂.norm_norm).congr _ _).of_norm_norm <;>
    · intros <;> simp only [norm_smul]
refine' ((h₁.norm_norm.mul h₂.norm_norm).congr _ _).of_norm_norm <;>
    · intros <;> simp only [norm_smul]
simp [div_self_le_one]
simp only [← is_o_one_left_iff ℝ]
exact ⟨(is_O_const_const (1 : ℝ) hc l).trans_is_o, (is_O_const_one ℝ c l).trans_is_o⟩
rw [← nhds_within_univ] at h
exact h.eq_zero_of_norm_pow_within (mem_univ _) hn
apply tendsto_norm_zero.comp
rw [← sub_self x₀]
exact tendsto_id.sub tendsto_const_nhds
simp only [mem_set_of_eq] at hx⊢
rw [mul_comm, one_div, ← div_eq_mul_inv, le_div_iff, mul_sub, mul_one, mul_comm]
· exact le_trans (sub_le_sub_left hx _) (norm_sub_norm_le _ _)
· exact sub_pos.2 hc
rw [neg_sub, sub_neg_eq_add]
simp [h _ hx, hx]
rw [← Nat.cofinite_eq_at_top, is_O_cofinite_iff h]
simp only [norm_one, mul_one]
simp only [is_O_iff_eventually_is_O_with, ← eventually_all]
exact eventually_congr (eventually_at_top.2 ⟨0, fun c => is_O_with_pi⟩)
simp (config := { contextual := true }) only [is_o, is_O_with_pi, le_of_lt]
exact ⟨fun h i c hc => h hc i, fun h c hc i => h i hc⟩
unfold is_O
exact exists_congr fun C => e.is_O_with_congr hb
unfold is_o
exact forall₂_congr fun c hc => e.is_O_with_congr hb
unfold is_O
exact exists_congr fun C => e.is_O_with_congr
unfold is_o
exact forall₂_congr fun c hc => e.is_O_with_congr
rw [is_equivalent, sub_self]
exact is_o_zero _ _
rw [is_equivalent, sub_zero]
exact is_o_zero_right_iff
rw [is_equivalent_iff_exists_eq_mul]
refine' ⟨u / v, huv, hz.mono fun x hz' => (div_mul_cancel_of_imp hz').symm⟩
simp [sub_smul, sub_add]
rw [norm_smul]
refine' (h.is_O_const (one_ne_zero' ℝ)).trans_is_o (is_o_const_left.2 <| Or.inr _)
simp only [(· ∘ ·), norm_inv]
exact (tendsto_norm_sub_self_punctured_nhds a).inv_tendsto_zero
apply (eventually_gt_at_top (0 : 𝕜)).mono fun x hx => _
simp [zpow_sub₀ hx.ne']
apply (eventually_lt_at_bot (0 : 𝕜)).mono fun x hx => _
simp [zpow_sub₀ hx.ne]
refine' (is_o_iff_tendsto' _).mpr (tendsto_pow_div_pow_at_top_zero hpq)
exact (eventually_gt_at_top 0).mono fun x hx hxq => (pow_ne_zero q hx.ne' hxq).elim
apply is_o_const_left.2
exact Or.inr (h'g.congr fun n => (B n).symm)
rw [sum_range_add_sum_Ico _ Nn]
refine' add_le_add le_rfl _
apply sum_le_sum_of_subset_of_nonneg
· rw [range_eq_Ico]
        exact Ico_subset_Ico (zero_le _) le_rfl
· intro i hi hident
        exact mul_nonneg (half_pos εpos).le (hg i)
rw [← mul_sum]
exact add_le_add hn (mul_le_mul_of_nonneg_left le_rfl (half_pos εpos).le)
have := ((is_o_one_iff ℝ).2 h).sum_range fun i => zero_le_one
simp only [sum_const, card_range, Nat.smul_one_eq_coe] at this
exact this tendsto_coe_nat_at_top_at_top
simp [is_Theta]
simp [is_Theta]
simp only [← hx, norm_norm]
simp only [← is_o_one_iff ℝ, h.is_o_congr_left]
simp only [← is_o_const_left_of_ne (one_ne_zero' ℝ), h.is_o_congr_right]
simp only [← is_O_const_of_ne (one_ne_zero' ℝ), h.is_O_congr_left]
simp only [is_Theta, is_O_zero, is_O_zero_right_iff, true_and_iff]
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
refine'
    ⟨fun hf => pre_ergodic_of_pre_ergodic_conjugate (h.symm e) hf _, fun hf =>
      pre_ergodic_of_pre_ergodic_conjugate h hf _⟩
· change (e.symm ∘ e) ∘ f ∘ e.symm = f ∘ e.symm
    rw [MeasurableEquiv.symm_comp_self, comp.left_id]
· change e ∘ f = e ∘ f ∘ e.symm ∘ e
    rw [MeasurableEquiv.symm_comp_self, comp.right_id]
rw [h.comp_left_iff, (measure_preserving.symm e h).comp_right_iff]
refine' hf.quasi_ergodic.ae_empty_or_univ' hs _
refine' ae_eq_of_ae_subset_of_measure_ge hs' (hf.measure_preimage hs).symm.le _ h_fin
exact measurableSetPreimage hf.measurable hs
simp [hj.le]
rw [volume_closed_ball, mul_div, mul_div_mul_left T _ two_ne_zero,
      min_eq_right (div_le_self hT₀.le huj'), mul_comm, ← nsmul_eq_mul, ← Ennreal.of_real_nsmul,
      nsmul_eq_mul, mul_div_cancel']
exact nat.cast_ne_zero.mpr hj.ne'
rw [← add_order_of_dvd_iff_zsmul_eq_zero, hu₀, Int.coe_nat_pow, ← Int.abs_eq_natAbs, ←
          abs_pow, abs_dvd]
rw [vadd_eq_self_of_preimage_zsmul_eq_self hs' (hnu j)]
simp [hn]
rw [← he.ergodic_conjugate_iff, this]
exact ergodic_zsmul h
simp [h]
exact MeasureTheory.MeasureSpace.volume
exact MeasureTheory.MeasureSpace.volume
rw [← h.map_eq, map_map e.symm.measurable e.measurable, e.symm_comp_self, map_id]
rw [← hf.map_eq, restrict_map hf.measurable hs]
rw [← hf.map_eq, h₂.restrict_map]
rw [← hf.map_eq, h₂.ae_measurable_map_iff]
rw [← map_map hg.1 hf.1, hf.2, hg.2]
rw [← hf.map_eq, map_apply hf.1 hs]
rw [← hf.map_eq, hfe.map_apply]
exact MeasureTheory.MeasureSpace.volume
simp only [set_of_forall, ← compl_set_of]
exact
      hs.inter (MeasurableSet.bInter (to_countable _) fun m _ => hf.measurable.iterate m hs.compl)
apply Nat.mul_div_cancel'
exact (Nat.modeq_iff_dvd' hkl.le).1 hn
refine' tendsto_nhds_unique ((tendsto_add_at_top_iff_nat 1).1 _) hy
simp only [iterate_succ' f]
exact hf.tendsto.comp hy
rw [Set.preimage_iterate_eq]
exact h.iterate n
rw [← Equiv.Perm.iterate_eq_pow]
exact h.iterate _
rfl
simp only [omega_limit_def, mem_Inter, maps_to]
intro y hy u hu
refine' map_mem_closure hgc (hy _ (inter_mem hu hg)) (forall_image2_iff.2 fun t ht x hx => _)
calc
    gb (ϕ t x) = ϕ' t (ga x) := ht.2 hx
    _ ∈ image2 ϕ' u s' := mem_image2_of_mem ht.1 (hs hx)
simp only [omegaLimit, image2_image_right]
rw [Union_subset_iff]
exact fun i => omega_limit_mono_right _ _ (subset_Union _ _)
rw [omega_limit_eq_bInter_inter _ _ _ hv]
apply bInter_eq_Inter
rw [omega_limit_eq_Inter]
intro _ hx
rw [mem_Inter] at hx
exact hx ⟨u, hu⟩
rw [union_comm, ← inter_subset, diff_eq, inter_comm]
simp
refine' fun t => maps_to.mono_right _ (omega_limit_subset_of_tendsto ϕ s (hf t))
exact
    maps_to_omega_limit _ (maps_to_id _) (fun t' x => (ϕ.map_add _ _ _).symm)
      (continuous_const.flow ϕ continuous_id)
simp only [omega_limit_image_eq, ← map_add]
exact omega_limit_subset_of_tendsto ϕ s ht
simp [image_image, ← map_add]
rw [add_comm, map_add_one, add_comm]
congr <;> exact h
simp [map_add_one]
simp only [← units_coe, ← mul_apply, f.inv_mul, coe_one, id]
simp only [← units_coe, ← mul_apply, f.mul_inv, coe_one, id]
simp only [Equiv.ofBijective_apply_symm_apply f h, hxy]
simp only [Equiv.ofBijective_apply_symm_apply f, f.map_add_one]
refine' (Units.map _).comp to_units.to_monoid_hom <;>
    exact
      { toFun := fun x =>
          ⟨fun y => x.toAdd + y, fun y₁ y₂ h => add_le_add_left h _, fun y =>
            (add_assoc _ _ _).symm⟩
        map_one' := ext <| zero_add
        map_mul' := fun x y => ext <| add_assoc _ _ }
simp only [← zsmul_eq_mul, ofAdd_zsmul, MonoidHom.map_zpow]
rw [← units_coe, ← coe_pow, ← Units.val_pow_eq_pow_val, translate_pow, units_coe]
simp only [add_comm _ (n : ℝ), f.commute_nat_add n]
rw [← f.map_add_int, zero_add]
rw [Int.fract, f.map_sub_int, sub_sub_sub_cancel_right]
simp [max_add_add_right]
simp [min_add_add_right]
simp only [coe_pow, iterate_mono h n x]
rw [dist_comm, Real.dist_eq, abs_lt, lt_sub_iff_add_lt', sub_lt_iff_lt_add', ← sub_eq_add_neg]
exact ⟨f.lt_map_map_zero g, f.map_map_zero_lt g⟩
simp only [h.eq, Real.dist_eq, sub_sub, add_comm (f 0), sub_sub_eq_add_sub,
        abs_sub_comm (g₂ (f 0))]
rw [le_floor, Int.cast_mul, Int.cast_ofNat, ← zero_add ((n : ℝ) * _)]
apply le_iterate_of_add_int_le_map
simp [floor_le]
simp [transnum_aux_seq]
simp [tendsto_const_nhds]
have :
    tendsto (fun n : ℕ => (fun k => (f ^ k) 0 + (g ^ k) 0) (2 ^ n) / 2 ^ n) at_top
      (𝓝 <| τ f + τ g) :=
    (f.tendsto_translation_number_aux.add g.tendsto_translation_number_aux).congr fun n =>
      (add_div ((f ^ 2 ^ n) 0) ((g ^ 2 ^ n) 0) ((2 : ℝ) ^ n)).symm
refine'
    tendsto_nhds_unique ((f * g).tendsto_translation_number_of_dist_bounded_aux _ 1 fun n => _) this
rw [h.mul_pow, dist_comm]
exact le_of_lt ((f ^ n).dist_map_map_zero_lt (g ^ n))
simp [← translation_number_mul_of_commute (Commute.refl _).units_inv_left]
simp
rw [pow_succ', translation_number_mul_of_commute (Commute.pow_self f n),
      translation_number_pow n, Nat.cast_add_one, add_mul, one_mul]
simp [translation_number_pow f n]
refine'
    tendsto_iff_dist_tendsto_zero.2 <|
      squeeze_zero (fun _ => dist_nonneg) (fun n => _)
        ((tendsto_const_div_at_top_nhds_0_nat 1).comp (tendsto_add_at_top_nat 1))
dsimp
have : (0 : ℝ) < n + 1 := n.cast_add_one_pos
rw [Real.dist_eq, div_sub' _ _ _ (ne_of_gt this), abs_div, ← Real.dist_eq, abs_of_pos this,
    Nat.cast_add_one, div_le_div_right this, ← Nat.cast_add_one]
apply dist_pow_map_zero_mul_translation_number_le
simp [Nat.cast_add_one_ne_zero, mul_div_cancel_left, tendsto_const_nhds]
simp only [coe_pow, mul_comm (m : ℝ), ← Nat.cast_add_one, f.le_iterate_of_add_int_le_map h]
rw [coe_pow]
exact hf.iterate n
rw [← MonoidHom.coe_toHomUnits, MonoidHom.map_inv, translation_number_units_inv,
        MonoidHom.coe_toHomUnits]
rw [h, map_add_one]
simp [this, bit0, add_assoc]
      
  -- We have a theorem about actions
intro n
simp [h]
rw [is_periodic_pt, iterate_add]
exact hn.comp hm
rw [is_periodic_pt, iterate_add] at hn
exact hn.left_of_comp hm
rw [add_comm] at hn
exact hn.left_of_add hm
simp only [is_periodic_pt, iterate_mul, hm.is_fixed_pt.iterate n]
simp only [mul_comm n, hm.mul_const n]
rw [is_periodic_pt, ← iterate_mul, mul_comm, iterate_mul]
exact hf.is_fixed_pt.iterate m
rw [is_periodic_pt, hco.comp_iterate]
exact hf.comp hg
rw [is_periodic_pt, hco.comp_iterate] at hfg
exact hfg.left_of_comp hg
rw [← hx.eq, ← hy.eq, ← iterate_pred_comp_of_pos f hn, comp_app, h]
rw [← comp_app f, comp_iterate_pred_of_pos f hn, hx.eq]
rw [← iterate_add_apply, Nat.sub_add_cancel this, iterate_mul, (hr'.iterate _).Eq]
simp [mem_periodic_pts]
rw [iterate_add_apply]
congr
exact is_periodic_pt_minimal_period f x
simp only [minimal_period, dif_pos hx, (Nat.find_spec hx).fst.lt]
simp only [minimal_period, dif_neg hx]
simp only [minimal_period, dif_neg h, lt_irrefl 0, not_false_iff]
rw [← minimal_period_pos_iff_mem_periodic_pts, not_lt, nonpos_iff_eq_zero]
rw [minimal_period, dif_pos (mk_mem_periodic_pts hn hx)]
exact Nat.find_min' (mk_mem_periodic_pts hn hx) ⟨hn, hx⟩
refine' ⟨fun h => _, fun h => _⟩
· rw [← iterate_one f]
    refine' Function.IsPeriodicPt.is_fixed_pt _
    rw [← h]
    exact is_periodic_pt_minimal_period f x
·
    exact
      ((h.is_periodic_pt 1).minimal_period_le Nat.one_pos).antisymm
        (Nat.succ_le_of_lt ((h.is_periodic_pt 1).minimal_period_pos Nat.one_pos))
rw [← is_periodic_pt_iff_minimal_period_dvd]
exact (is_periodic_pt_minimal_period f x).comp_lcm h (is_periodic_pt_minimal_period g x)
apply Nat.dvd_antisymm
· apply is_periodic_pt.minimal_period_dvd
    rw [is_periodic_pt, is_fixed_pt, ← iterate_mul, ← Nat.mul_div_assoc _ (gcd_dvd_left _ _),
      mul_comm, Nat.mul_div_assoc _ (gcd_dvd_right _ _), mul_comm, iterate_mul]
    exact (is_periodic_pt_minimal_period f x).iterate _
· apply coprime.dvd_of_dvd_mul_right (coprime_div_gcd_div_gcd h)
    apply dvd_of_mul_dvd_mul_right h
    rw [Nat.div_mul_cancel (gcd_dvd_left _ _), mul_assoc, Nat.div_mul_cancel (gcd_dvd_right _ _),
      mul_comm]
    apply is_periodic_pt.minimal_period_dvd
    rw [is_periodic_pt, is_fixed_pt, iterate_mul]
    exact is_periodic_pt_minimal_period _ _
rw [periodic_orbit, Cycle.length_coe, List.length_map, List.length_range]
simp [periodic_orbit]
exact minimal_period_eq_zero_iff_nmem_periodic_pts
apply List.ext_le _ fun m _ _ => _
· simp [minimal_period_apply_iterate hx]
· rw [List.nth_le_rotate _ n m]
          simp [iterate_add_apply]
rw [← is_periodic_pt_iff_minimal_period_dvd, is_periodic_pt, is_fixed_pt, smul_iterate]
cases n
· rw [Int.ofNat_eq_coe, zpow_ofNat, Int.coe_nat_dvd, pow_smul_eq_iff_minimal_period_dvd]
·
    rw [Int.negSucc_coe, zpow_neg, zpow_ofNat, inv_smul_eq_iff, eq_comm, dvd_neg, Int.coe_nat_dvd,
      pow_smul_eq_iff_minimal_period_dvd]
simp [← map_add]
rw [h t]
rw [neg_add, map_add]
rw [neg_zero, map_zero_apply]
rw [← map_add, neg_add_self, map_zero_apply]
rw [← map_add, add_neg_self, map_zero_apply]
intro j h
simp only [ball_cons, named_binder]
constructor <;> assumption
simp only [ball_cons, named_binder]
apply not_and_of_not_right _ Hce
rw [length_map]
apply h
intro h
dsimp [list.apply_id]
rw [lookup_eq_none.2]
rfl
simp only [keys, not_exists, to_sigma, exists_and_right, exists_eq_right, mem_map, comp_app,
    map_map, Prod.exists]
intro y hy
exact h (mem_zip hy).1
intro x y h
injection this
decide
simp only [Nat.mul_div_cancel, gt_iff_lt, Fin.val_eq_coe, PNat.pos]
simp only [comp, map_fst_zip, map_snd_zip, *, Prod.fst_toSigma, Prod.snd_toSigma,
              map_map]
simp only [comp, map_snd_zip, *, Prod.snd_toSigma, map_map]
simp only [list.to_finmap', comp, map_fst_zip, map_snd_zip, *, Prod.fst_toSigma,
        Prod.snd_toSigma, map_map]
simp only [list.to_finmap', comp, map_snd_zip, *, Prod.snd_toSigma, map_map]
rw [← h₀, ← h₁, list.to_finmap']
clear h₀ h₁ xs₀ xs₁ hperm hnodup
induction xs
case nil => simp only [zip_nil_right, map_nil]
case cons xs_hd xs_tl xs_ih =>
      simp only [true_and_iff, to_sigma, eq_self_iff_true, Sigma.eta, zip_cons_cons, List.map]
      exact xs_ih
decide
simp
intros
assumption
decide
refine id.1
  [pRepr : Repr proxy_repr]
  sample
decide
decide
decide
decide
dsimp [SizeOf.sizeOf, SizeOf.sizeOf] <;> rw [Int.natAbs_neg] <;> exact h
decide
decide
simp only [h₃, ← hn, List.length_drop]
decide
simp
simp
simp
simp [List.repeat_add]
refine'
    if hl : l₁.length ≤ l₂.length then ⟨l₂, Or.elim h id fun h' => _, blank_extends.refl _⟩
    else ⟨l₁, blank_extends.refl _, Or.elim h (fun h' => _) id⟩
exact (blank_extends.refl _).above_of_le h' hl
exact (blank_extends.refl _).above_of_le h' (le_of_not_ge hl)
refine'
    if hl : l₁.length ≤ l₂.length then ⟨l₁, blank_extends.refl _, Or.elim h id fun h' => _⟩
    else ⟨l₂, Or.elim h (fun h' => _) id, blank_extends.refl _⟩
exact (blank_extends.refl _).above_of_le h' hl
exact (blank_extends.refl _).above_of_le h' (le_of_not_ge hl)
refine' fun l => Quotient.sound' (Or.inr _)
cases l
· exact ⟨1, rfl⟩; · rfl
conv => 
    lhs
    rw [← list_blank.cons_head_tail l]
exact Quotient.inductionOn' l.tail fun l => rfl
conv => 
    lhs
    rw [← list_blank.cons_head_tail l]
exact Quotient.inductionOn' l.tail fun l => rfl
conv => 
    lhs
    rw [← list_blank.cons_head_tail l]
exact Quotient.inductionOn' l fun a => rfl
conv => 
    lhs
    rw [← list_blank.cons_head_tail l]
exact Quotient.inductionOn' l fun a => rfl
refine' (list_blank.cons_head_tail _).symm.trans _
simp only [list_blank.head_map, list_blank.head_cons, list_blank.tail_map, list_blank.tail_cons]
intro l
simp only [List.nth_map, list_blank.map_mk, list_blank.nth_mk, List.inth_eq_iget_nth]
cases l.nth n
· exact f.2.symm; · rfl
rw [list_blank.nth_map] <;> rfl
induction l₁ <;>
    simp only [*, list_blank.append, List.nil_append, List.cons_append, list_blank.cons_mk]
intro <;> simp only [list_blank.append_mk, List.append_assoc]
intro <;>
      simp only [list_blank.append_mk, list_blank.bind_mk, list_blank.cons_mk, List.cons_bind]
constructor <;> apply default
cases T <;> simp [tape.move]
cases T <;> simp [tape.move]
cases T <;>
    simp only [tape.right₀, tape.mk', list_blank.head_cons, list_blank.tail_cons, eq_self_iff_true,
      and_self_iff]
simp only [tape.move, tape.mk', list_blank.head_cons, eq_self_iff_true, list_blank.cons_head_tail,
    and_self_iff, list_blank.tail_cons]
simp only [tape.move, tape.mk', list_blank.head_cons, eq_self_iff_true, list_blank.cons_head_tail,
    and_self_iff, list_blank.tail_cons]
cases n <;>
    simp only [tape.nth, tape.right₀, Int.ofNat_zero, list_blank.nth_zero, list_blank.nth_succ,
      list_blank.head_cons, list_blank.tail_cons]
rw [← tape.right₀_nth, tape.mk'_right₀]
rw [add_sub_cancel]
change (R.cons a).nth (n + 1) = R.nth n
rw [list_blank.nth_succ, list_blank.tail_cons]
conv => 
      rhs
      rw [← T.move_right_left] <;>
    rw [tape.move_left_nth, add_sub_cancel]
simp only [tape.write, tape.mk', list_blank.head_cons, list_blank.tail_cons, eq_self_iff_true,
    and_self_iff]
cases T <;> cases d <;>
    simp only [tape.move, tape.map, list_blank.head_map, eq_self_iff_true, list_blank.map_cons,
      and_self_iff, list_blank.tail_map]
simp only [tape.mk', tape.map, list_blank.head_map, eq_self_iff_true, and_self_iff,
    list_blank.tail_map]
simp only [tape.mk₂, tape.map_mk', list_blank.map_mk]
rw [h]
rw [e] <;> rfl
rw [e] <;> rfl
refine' refl_trans_gen.head_induction_on h₁ _ fun a a' h _ IH => _
· refine' Pfun.mem_fix_iff.2 (Or.inl _)
      rw [h₂]
      apply Part.mem_some
· refine' Pfun.mem_fix_iff.2 (Or.inr ⟨_, _, IH⟩)
      rw [show f a = _ from h]
      apply Part.mem_some
let ⟨ab, b0⟩ := mem_eval.1 h
let ⟨b', h', _⟩ := TransGen.head'_iff.1 bc
cases b0.symm.trans h'
cases b0.symm.trans h'
unfold frespects <;> rw [h]
cases f₁ a₁ <;> simp only [frespects, respects, exists_eq_left', forall_eq']
unfold machine <;> infer_instance
cases q <;>
    trace
      "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr finset.mem_insert_self, \",\", expr finset.mem_singleton_self, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
simp only [stmts, Finset.mem_insert_none, Finset.mem_bUnion, Option.mem_def, forall_eq',
      exists_imp] <;>
    exact fun l ls h₂ => ⟨_, ls, stmts₁_trans h₂ h₁⟩
simp only [stmts, Finset.mem_insert_none, Finset.mem_bUnion, Option.mem_def, forall_eq',
      exists_imp] <;>
    exact fun l ls h => stmts₁_supports_stmt_mono h (ss.2 _ ls)
rfl
simp only [TM0.step, tr, tr_aux, e] <;> rfl
simp only [TM0.step, tr, tr_aux, e] <;> rfl
rw [Part.map_eq_map, Part.map_map, TM1.eval]
congr
suffices ∀ {i}, SupportsStmt S ((Stmt.move d^[i]) q) = _ from this
intro <;> induction i generalizing q <;> simp only [*, iterate] <;> rfl
intro <;> simp only [supports_stmt_move, hf]
refine'
      tape.mk' (L.bind (fun x => (enc x).toList.reverse) ⟨n, _⟩)
        (R.bind (fun x => (enc x).toList) ⟨n, _⟩) <;>
    simp only [enc0, Vector.repeat, List.reverse_repeat, Bool.default_bool, Vector.toList_mk]
simp only [tr_tape, tape.mk'_left, tape.mk'_right₀]
refine' (Eq.symm _).trans (this n _)
simp only [tr_tape'_move_left, list_blank.cons_head_tail, list_blank.head_cons,
      list_blank.tail_cons]
rw [read, this, step_aux_move, encdec, tr_tape'_move_left enc0]
simp only [list_blank.head_cons, list_blank.cons_head_tail, list_blank.tail_cons]
refine' trans_gen.head' rfl _
rw [tr_tape_mk']
exact this _ R
cases q <;>
    trace
      "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr finset.mem_insert_self, \",\", expr finset.mem_singleton_self, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error"
simp only [stmts, Finset.mem_insert_none, Finset.mem_bUnion, Option.mem_def, forall_eq',
      exists_imp] <;>
    exact fun l ls h₂ => ⟨_, ls, stmts₁_trans h₂ h₁⟩
simp only [stmts, Finset.mem_insert_none, Finset.mem_bUnion, Option.mem_def, forall_eq',
      exists_imp] <;>
    exact fun l ls h => stmts₁_supports_stmt_mono h (ss.2 _ ls)
rw [← proj_map_nth, hL, ← List.map_reverse, list_blank.nth_mk, List.inth_eq_iget_nth,
    List.nth_map]
cases S.reverse.nth n <;> rfl
conv => 
      rhs
      rw [← add_bottom_map L, list_blank.nth_map] <;>
    rfl
rw [list_blank.nth_succ, add_bottom, list_blank.tail_cons, list_blank.nth_map] <;> rfl
rw [add_bottom, list_blank.head_cons] <;> rfl
unfold st_write <;> rw [Function.update_eq_self] <;> rfl
rw [tape.move_right_n_head, List.length, tape.mk'_nth_nat, this,
          add_bottom_modify_nth fun a => update a k (some (f v)), Nat.add_one, iterate_succ']
rw [add_bottom_head_fst, cond]
rw [List.reverse_cons, ← List.length_reverse, List.nth_concat_length] <;> rfl
rw [(_ : TM1.init _ = _)]
· refine' ⟨list_blank.mk (L.reverse.map fun a => update default k (some a)), fun k' => _⟩
    refine' list_blank.ext fun i => _
    rw [list_blank.map_mk, list_blank.nth_mk, List.inth_eq_iget_nth, List.map_map, (· ∘ ·),
      List.nth_map, proj, pointed_map.mk_val]
simp only [tape.mk'_right₀]
simp only [tr_normal_run, TM1.supports_stmt] <;> intros <;> exact hgo
rfl
simp [mul_def, one_def]
simp [mul_def, one_def]
cases n <;> simp [Nat.cast, add_def, zero_def]
simp [map]
simp [map, image_image]
simp
simp only [star_eq_supr_pow, mul_supr, supr_mul, ← pow_succ, ← pow_succ']
simp only [star_eq_supr_pow, mul_supr, ← pow_succ, ← pow_zero l]
exact sup_supr_nat_succ _
rw [mul_self_star_comm, one_add_self_mul_star_eq_star]
induction x <;> simp [rmatch, match_epsilon, *]
induction x <;> simp [rmatch, match_epsilon, *]
rw [hs, List.length_cons, List.length_append]
apply A
decide
simp
rw [hsum.1, hsum.2]
simp only [List.length_append, List.length_join, List.length]
apply A
intro x
change Decidable (x ∈ P.matches)
rw [← rmatch_iff_matches]
exact Eq.decidable _ _
rw [eq_comm]
exact image_singleton
simp only [matches_map, map, matches_add, map_add]
simp only [matches_map, map, matches_mul, map_mul]
simp only [eval_from, List.foldl_append, List.foldl_cons, List.foldl_nil]
rw [← to_NFA_correct] at hx⊢
exact M.to_NFA.pumping_lemma hx hlen
rw [accepts, εNFA.accepts, eval, εNFA.eval, to_ε_NFA_eval_from_match]
rfl
exact fun a => this _ _ (Nat.le_add_left _ _)
    intro m k kn
    induction' m
rw [Nat.add_right_comm] <;> exact kn
injection mem_unique this (rfind_min hn h)
intro h <;> injection h
simp <;> cases decode α n <;> simp
cases decode α n <;> simp [(· <*> ·)]
cases decode α n <;> simp
simp [Partrec, map_id']
intro
induction m <;> simp [*, H.fst]
simp [Vector.mOfFn] <;>
      exact
        (hf 0).bind
          (Partrec.bind ((vector_m_of_fn fun i => hf i.succ).comp fst)
            (primrec.vector_cons.to_comp.comp (snd.comp fst) snd))
simp <;> cases decode α n.unpair.1 <;> simp <;> cases decode β n.unpair.2 <;> simp
have :
      Partrec fun a : α × ℕ =>
        (encode (decode β a.2)).cases (some Option.none) fun n => Part.map (f a.1) (decode β n) :=
      Partrec.nat_cases_right (primrec.encdec.to_comp.comp snd) (const none)
        ((of_option (computable.decode.comp snd)).map (hf.comp (fst.comp <| fst.comp fst) snd).to₂)
refine' this.of_eq fun a => _
simp
cases decode β a.2 <;> simp [encodek]
simp <;> induction f a <;> simp [*]
cases c a <;> rfl
cases o a <;> simp [encodek] <;> rfl
cases f a <;> rfl
cases f a <;> rfl
simp [List.nth_range (Nat.lt_succ_self a.2)] <;> rfl
simp [List.of_fn_succ] <;> exact list_cons.comp (hf 0) (list_of_fn fun i => hf i.succ)
simp
simp [Part.bind_assoc, bind_some_eq_map]
cases f a <;> simp
cases f a <;> simp
simp [F]
simp <;> apply fix_aux f
simp only [e, Option.mem_def, Option.none_orElse]
simp only [Option.some_orElse, Option.mem_def]
cases c a <;> simp [ef, eg, encodek]
cases f a <;> simp only [Bool.cond_true, Bool.cond_false]
simp [Part.dom_iff_mem]
infer_instance
infer_instance
dsimp
cases f n <;> rfl
infer_instance
induction pf
case prim n f hf => exact hf.to_prim.to_comp
case comp m n f g _ _ hf hg => exact (vector_m_of_fn fun i => hg i).bind (hf.comp snd)
case rfind n f _ hf =>
    have :=
      ((primrec.eq.comp Primrec.id (Primrec.const 0)).to_comp.comp
            (hf.comp (vector_cons.comp snd fst))).to₂.Partrec₂
    exact this.rfind
simp <;> rw [← of_fn_nth v.tail] <;> congr <;> funext i <;> simp
refine' Fin.cases _ (fun i => _) i <;> simp [*]
exact prim (Nat.Primrec'.nth _)
simp [m_of_fn, Part.bind_assoc, pure]
simp [(Part.bind_some_eq_map _ _).symm] <;> exact hf.bind hg
simp [*]
simp only [hg i, nth_cons_succ]
simp
dsimp only [g] <;> simp [encodek, Part.map_id']
simp only [id.def, head_of_fn]
simp only [cons_head, cons_tail]
refine'
      Partrec.map
        ((@Partrec₂.unpaired' fun a b : ℕ =>
              Nat.rfind fun n => (fun m => m = 0) <$> f (mkpair a (n + b))).1
          _)
        (primrec.nat_add.comp Primrec.snd <| primrec.snd.comp Primrec.fst).to_comp.to₂
have :=
      rfind
        (Partrec₂.unpaired'.2
          ((Partrec.nat_iff.2 hf).comp
              (primrec₂.mkpair.comp (primrec.fst.comp <| primrec.unpair.comp Primrec.fst)
                  (primrec.nat_add.comp Primrec.snd
                    (primrec.snd.comp <| primrec.unpair.comp Primrec.fst))).to_comp).to₂)
simp at this
exact this
simp
dsimp [Nat.Partrec.Code.const] at h
injection h with h₁ h₂
simp only [const_inj h₂]
simp [m, Nat.div2_val] <;>
        exact
          lt_of_le_of_lt (le_trans (Nat.div_le_self _ _) (Nat.div_le_self _ _))
            (Nat.succ_le_succ (Nat.le_add_right _ _))
simp [of_nat_code, encode_code]
simp [of_nat_code, encode_code]
simp [of_nat_code, encode_code]
simp [of_nat_code, encode_code]
simp [m, Nat.div2_val] <;>
        exact
          lt_of_le_of_lt (le_trans (Nat.div_le_self _ _) (Nat.div_le_self _ _))
            (Nat.succ_le_succ (Nat.le_add_right _ _))
induction c <;> try rfl <;> simp [encode_code, of_nat_code, -add_comm, *]
decide
decide
decide
decide
refine' option_bind (list_nth.comp (snd.comp fst) (snd.comp snd)) _
refine'
      option_bind
        ((list_nth.comp (snd.comp fst) (fst.comp <| primrec.unpair.comp (snd.comp snd))).comp fst) _
refine'
      option_map
        ((list_nth.comp (snd.comp fst) (snd.comp <| primrec.unpair.comp (snd.comp snd))).comp <|
          fst.comp fst)
        _
have a := fst.comp (fst.comp <| fst.comp <| fst.comp fst)
have n := fst.comp (snd.comp <| fst.comp <| fst.comp fst)
have m := snd.comp (snd.comp <| fst.comp <| fst.comp fst)
have m₁ := fst.comp (primrec.unpair.comp m)
have m₂ := snd.comp (primrec.unpair.comp m)
have s := snd.comp (fst.comp fst)
have s₁ := snd.comp fst
have s₂ := snd
exact
      (nat_bodd.comp n).cond
        ((nat_bodd.comp <| nat_div2.comp n).cond
          (hrf.comp a (((Primrec.of_nat code).comp m).pair s))
          (hpc.comp a
            (((Primrec.of_nat code).comp m₁).pair <|
              ((Primrec.of_nat code).comp m₂).pair <| s₁.pair s₂)))
        (Primrec.cond (nat_bodd.comp <| nat_div2.comp n)
          (hco.comp a
            (((Primrec.of_nat code).comp m₁).pair <|
              ((Primrec.of_nat code).comp m₂).pair <| s₁.pair s₂))
          (hpr.comp a
            (((Primrec.of_nat code).comp m₁).pair <|
              ((Primrec.of_nat code).comp m₂).pair <| s₁.pair s₂)))
simp
simp [Nat.div2_val, m] <;>
      exact
        lt_of_le_of_lt (le_trans (Nat.div_le_self _ _) (Nat.div_le_self _ _))
          (Nat.succ_le_succ (Nat.le_add_right _ _))
refine' option_bind (list_nth.comp (snd.comp fst) (snd.comp snd)) _
refine'
      option_bind
        ((list_nth.comp (snd.comp fst) (fst.comp <| primrec.unpair.comp (snd.comp snd))).comp fst) _
refine'
      option_map
        ((list_nth.comp (snd.comp fst) (snd.comp <| primrec.unpair.comp (snd.comp snd))).comp <|
          fst.comp fst)
        _
have a := fst.comp (fst.comp <| fst.comp <| fst.comp fst)
have n := fst.comp (snd.comp <| fst.comp <| fst.comp fst)
have m := snd.comp (snd.comp <| fst.comp <| fst.comp fst)
have m₁ := fst.comp (primrec.unpair.comp m)
have m₂ := snd.comp (primrec.unpair.comp m)
have s := snd.comp (fst.comp fst)
have s₁ := snd.comp fst
have s₂ := snd
exact
      (nat_bodd.comp n).cond
        ((nat_bodd.comp <| nat_div2.comp n).cond
          (hrf.comp <| a.pair (((Primrec.of_nat code).comp m).pair s))
          (hpc.comp <|
            a.pair
              (((Primrec.of_nat code).comp m₁).pair <|
                ((Primrec.of_nat code).comp m₂).pair <| s₁.pair s₂)))
        (Primrec.cond (nat_bodd.comp <| nat_div2.comp n)
          (hco.comp <|
            a.pair
              (((Primrec.of_nat code).comp m₁).pair <|
                ((Primrec.of_nat code).comp m₂).pair <| s₁.pair s₂))
          (hpr.comp <|
            a.pair
              (((Primrec.of_nat code).comp m₁).pair <|
                ((Primrec.of_nat code).comp m₂).pair <| s₁.pair s₂)))
simp
simp [Nat.div2_val, m] <;>
      exact
        lt_of_le_of_lt (le_trans (Nat.div_le_self _ _) (Nat.div_le_self _ _))
          (Nat.succ_le_succ (Nat.le_add_right _ _))
refine' option_bind (list_nth.comp (snd.comp fst) (snd.comp snd)) _
refine'
      option_bind
        ((list_nth.comp (snd.comp fst) (fst.comp <| computable.unpair.comp (snd.comp snd))).comp
          fst)
        _
refine'
      option_map
        ((list_nth.comp (snd.comp fst) (snd.comp <| computable.unpair.comp (snd.comp snd))).comp <|
          fst.comp fst)
        _
have a := fst.comp (fst.comp <| fst.comp <| fst.comp fst)
have n := fst.comp (snd.comp <| fst.comp <| fst.comp fst)
have m := snd.comp (snd.comp <| fst.comp <| fst.comp fst)
have m₁ := fst.comp (computable.unpair.comp m)
have m₂ := snd.comp (computable.unpair.comp m)
have s := snd.comp (fst.comp fst)
have s₁ := snd.comp fst
have s₂ := snd
exact
      (nat_bodd.comp n).cond
        ((nat_bodd.comp <| nat_div2.comp n).cond
          (hrf.comp a (((Computable.of_nat code).comp m).pair s))
          (hpc.comp a
            (((Computable.of_nat code).comp m₁).pair <|
              ((Computable.of_nat code).comp m₂).pair <| s₁.pair s₂)))
        (Computable.cond (nat_bodd.comp <| nat_div2.comp n)
          (hco.comp a
            (((Computable.of_nat code).comp m₁).pair <|
              ((Computable.of_nat code).comp m₂).pair <| s₁.pair s₂))
          (hpr.comp a
            (((Computable.of_nat code).comp m₁).pair <|
              ((Computable.of_nat code).comp m₂).pair <| s₁.pair s₂)))
simp
simp [Nat.div2_val, m] <;>
      exact
        lt_of_le_of_lt (le_trans (Nat.div_le_self _ _) (Nat.div_le_self _ _))
          (Nat.succ_le_succ (Nat.le_add_right _ _))
rw [eval, Nat.unpaired, Nat.unpair_mkpair, Nat.elim_zero]
rw [eval, Nat.unpaired, Part.bind_eq_bind, Nat.unpair_mkpair, Nat.elim_succ]
simp
simp! [*]
simp! [(· <*> ·)]
simp! [(· <*> ·)]
simp <;> induction n <;> simp [*, code.const, Function.iterate_succ']
injection h
injection h
injection h with h₁ h₂
injection h₂ with h₃ h₄
exact const_inj h₃
simp [evaln] at h <;> cases h
cases c <;> rw [evaln] at h <;> exact this h
simp [evaln] at h <;> cases h
simp [evaln] at h <;> cases h
injection h₂ with h₂ <;> simp [h₂]
simp [add_comm, add_left_comm]
simp <;> rfl
simp
intro k₁ c₁ n₁ hl
simp [lup, List.nth_range hl, evaln_map, (· >>= ·)]
simp [evaln_map]
refine' evaln_complete.trans (Nat.rfind_opt_mono _).symm
intro a m n hl
apply evaln_mono hl
simp [eval_eq_rfind_opt]
simp [eg]
simp [eF]
simp [eg', eF', Part.map_id', g]
simp [e.symm, ef, Part.map_id']
simp
simp <;> dsimp <;> rw [unpair_mkpair]
simp [cases]
simp [cases]
simp
simp
cases n <;> simp [*]
simp <;> induction p.unpair.2 <;> simp [*, -add_comm, add_succ]
simp <;> induction p.unpair.2 <;> simp [*, -add_comm, sub_succ]
simp <;> induction p.unpair.2 <;> simp [*, mul_succ, add_comm]
simp <;> induction p.unpair.2 <;> simp [*, pow_succ']
simp
cases decode α n <;> dsimp <;> simp
cases n <;> simp
cases n <;> simp <;> cases decode α n <;> rfl
decide
cases decode α n <;> rfl
simp <;> rfl
simp <;> rfl
cases decode α n <;> simp
cases decode α n <;> rfl
simp
cases decode α n
· rfl
simp [encodek]
cases decode α n <;> rfl
simp [Primrec.encode]
simp
simp
simp [Nat.unpaired]
cases decode α n.unpair.1
· simp
cases decode β n.unpair.2 <;> simp
simp
cases decode α n.unpair.1 <;> simp
cases decode β n.unpair.2 <;> simp
simp
cases decode α n.unpair.1 <;> simp
cases decode β n.unpair.2 <;> simp
cases decode α n <;> simp [encodek] <;> rfl
simp
cases n <;> simp
funext a b <;> apply H
simp [Primrec₂, Primrec] <;> constructor
simp
rw [show Function.uncurry f = fun p : α × β => f p.1 p.2 from funext fun ⟨a, b⟩ => rfl] <;> rfl
rw [← uncurry, Function.uncurry_curry]
induction f a <;> simp [*, Function.iterate_succ']
cases f a <;> rfl
cases o <;> rfl
cases o <;> rfl
cases o <;> rfl
cases c a <;> rfl
cases b <;> rfl
cases a <;> rfl
simp
simp
simp
simp [le_antisymm_iff]
simp
cases o₁ <;> cases o₂ <;> rfl
cases n.1 <;> rfl
simp [this]
rw [Nat.succ_add, IH.1]
induction l <;> simp [*, List.reverseCore]
simp [decode_sum]
cases Nat.bodd n <;> simp [decode_sum]
· cases decode α n.div2 <;> rfl
· cases decode β n.div2 <;> rfl
simp [List.foldl_reverse]
cases l <;> rfl
cases l <;> rfl
rw [this]
rw [this]
exact option_get_or_else.comp₂ list_nth (const _)
induction l₁ <;> simp [*]
induction f a <;> simp [*]
simp <;> induction n <;> simp [*, List.range_succ] <;> rfl
dsimp <;> induction l <;> simp [*]
dsimp <;> induction l <;> simp [*, -add_comm]
simp [List.nth_range (Nat.lt_succ_self n)] <;> rfl
intro hf
refine' (nat.primrec.pred.comp hf).of_eq fun n => _
generalize hx : decode α n = x
cases x <;> simp
rfl
simp [succ.comp fin_val]
simp <;> exact list_cons.comp fst (vector_to_list_iff.2 snd)
cases l <;> rfl
simp [Vector.nth_eq_nth_le] <;> rw [← List.nth_le_nth]
simp [List.of_fn_succ] <;> exact list_cons.comp (hf 0) (list_of_fn fun i => hf i.succ)
simp [list_of_fn hf]
simp
simp
funext i <;> simp
induction pf
case zero => exact const 0
case succ => exact primrec.succ.comp vector_head
case nth n i => exact vector_nth.comp Primrec.id (const i)
case comp m n f g _ _ hf hg => exact hf.comp (vector_of_fn fun i => hg i)
case prec n f g _ _ hf hg =>
    exact
      nat_elim' vector_head (hf.comp vector_tail)
        (hg.comp <|
            vector_cons.comp (fst.comp snd) <|
              vector_cons.comp (snd.comp snd) <| (@vector_tail _ _ (n + 1)).comp fst).to₂
simp [nth_zero]
rw [← of_fn_nth v.tail] <;> congr <;> funext i <;> simp
simp [*]
simp [hg i]
simp
simp <;> cases v.head <;> rfl
simp <;> induction v.head <;> simp [*, Nat.succ_add]
simp <;> induction v.head <;> simp [*, Nat.succ_mul] <;> rw [add_comm]
cases e : b v - a v
· simp [not_lt.2 (tsub_eq_zero_iff_le.mp e)]
· simp [Nat.lt_of_sub_eq_succ e]
rw [v.eq_nil] <;> rfl
have x := v.head <;> have y := v.tail.head <;>
            exact if x.succ < y.succ * y.succ then y else y.succ
simp [encodek]
simp
simp
simp
simp
infer_instance
simp [toNat, setOf]
simp [ManyOneEquiv]
simp [ManyOneEquiv]
rfl
intro p₁ p₂ hp
induction d₂ using ManyOneDegree.ind_on
apply h
assumption
rfl
simp [of, Quotient.eq']
induction d using ManyOneDegree.ind_on <;> simp
induction d₁ using ManyOneDegree.ind_on
induction d₂ using ManyOneDegree.ind_on
intro hp hq
simp_all only [ManyOneEquiv, of_le_of, of_eq_of, true_and_iff]
induction d₁ using ManyOneDegree.ind_on
induction d₂ using ManyOneDegree.ind_on
induction d₃ using ManyOneDegree.ind_on
apply ManyOneReducible.trans
rfl
rfl
rw [h]
exact s
rw [h]
exact s
rw [Function.iterate_add_apply, h₁.evals_in_steps, h₂.evals_in_steps]
simp only [Polynomial.eval_one]
simp only [eval_from, List.foldl_append, List.foldl_cons, List.foldl_nil]
rw [← to_DFA_correct] at hx⊢
exact M.to_DFA.pumping_lemma hx hlen
simp [nil]
simp [id]
simp [head]
simp [zero]
simp [pred] <;> cases v.head <;> simp
simp [hg, hf, map_bind, seq_bind_eq, (· ∘ ·), -Subtype.val_eq_coe]
rfl
simp [Vector.mOfFn] <;> rfl
simp [Vector.mOfFn, hg₁, map_bind, seq_bind_eq, bind_assoc, (· ∘ ·), hl,
          -Subtype.val_eq_coe]
rfl
simp <;> rfl
simp_all
simp [hf, hn, -Subtype.val_eq_coe]
induction c generalizing k v <;> simp only [cont.then, step_normal, cfg.then, *]
case cons c c' ih ih' => rw [← ih, cont.then]
case comp c c' ih ih' => rw [← ih', cont.then]
· cases v.head <;> simp only [Nat.elim]
case fix c ih => rw [← ih, cont.then]
rw [h, ← bind_pure_comp_eq_map]
congr
funext v
exact Part.eq_some_iff.2 (mem_eval.2 ⟨refl_trans_gen.single rfl, rfl⟩)
simp [Function.funext_iff]
rw [tr_nat, Nat.cast_zero] <;> rfl
funext x <;> cases x <;> rfl
funext x <;> cases x <;> rfl
funext x <;> cases x <;> rfl
funext x <;> cases x <;> rfl
simp at h₃ <;> contradiction
decide
rw [← h₂, Function.update_eq_self]
rw [← h₂, Function.update_eq_self]
decide
decide
decide
simp
simp
cases m <;> refine' ⟨_, _, rfl, rfl⟩
decide
decide
decide
decide
decide
induction q <;> · first |apply Finset.mem_singleton_self|apply Finset.mem_insert_self
cases c <;> first |rfl|exact Finset.subset_union_left _ _
simp [code_supp, code_supp', cont_supp, Finset.union_assoc]
simp [code_supp, code_supp', cont_supp, Finset.union_assoc]
rw [← Finset.union_assoc _ _ (cont_supp k),
    Finset.union_eq_right_iff_subset.2 (code_supp'_self _ _)]
simp [code_supp, code_supp', cont_supp, Finset.union_assoc, Finset.union_left_comm]
simp [code_supp, code_supp', cont_supp, Finset.union_assoc, Finset.union_left_comm,
    Finset.union_left_idem]
simp [code_supp, code_supp', cont_supp, Finset.union_assoc]
simp (config := { contextual := true }) [code_supp, code_supp', cont_supp, Finset.union_assoc,
    Finset.subset_iff]
simp [supports]
simp [supports]
simp [supports, or_imp, forall_and]
simp [supports] <;> apply forall_swap
have W := fun {q} => tr_stmts₁_self q
cases k
case halt => trivial
case cons₁ => rw [cont_supp_cons₁, Finset.union_subset_iff] at H₁; exact fun _ => H₁.1 W
case cons₂ => rw [cont_supp_cons₂, Finset.union_subset_iff] at H₁; exact fun _ => H₁.1 W
case comp => rw [cont_supp_comp] at H₁; exact fun _ => H₁ (code_supp_self _ _ W)
case fix => 
    rw [cont_supp_fix] at H₁
    have L := @Finset.mem_union_left; have R := @Finset.mem_union_right
    intro s; dsimp only; cases nat_end s.iget
    · refine' H₁ (R _ <| L _ <| R _ <| R _ <| L _ W)
    · exact H₁ (R _ <| L _ <| R _ <| R _ <| R _ <| Finset.mem_singleton_self _)
simp [Finset.union_subset_iff] at H₂
exact supports_union.2 ⟨tr_stmts₁_supports H₁ H₂.1, H₃ H₂.2⟩
induction k
· simp [cont_supp_halt, supports]
case cons₁ f k IH => 
    have H₁ := H; rw [cont_supp_cons₁] at H₁; have H₂ := Finset.union_subset_right H₁
    refine' tr_stmts₁_supports' (tr_normal_supports H₂) H₁ fun h => _
    refine' supports_union.2 ⟨code_supp'_supports H₂, _⟩
    simp only [code_supp, cont_supp_cons₂, Finset.union_subset_iff] at H₂
    exact tr_stmts₁_supports' (head_supports H₂.2.2) (Finset.union_subset_right h) IH
case cons₂ k IH => 
    have H' := H; rw [cont_supp_cons₂] at H'
    exact tr_stmts₁_supports' (head_supports <| Finset.union_subset_right H') H' IH
case comp f k IH => 
    have H' := H; rw [cont_supp_comp] at H'; have H₂ := Finset.union_subset_right H'
    exact supports_union.2 ⟨code_supp'_supports H', IH H₂⟩
case fix f k IH => 
    rw [cont_supp] at H
    exact supports_union.2 ⟨code_supp'_supports H, IH (Finset.union_subset_right H)⟩
induction on `n
rw [ack]
rw [ack]
rw [ack]
simp
rw [ack_succ_zero]
apply ack_pos
rw [ack_succ_succ]
apply ack_pos
simp
rw [ack_succ_zero]
apply one_lt_ack_succ_left
rw [ack_succ_succ]
apply one_lt_ack_succ_left
simp
rw [ack_succ_succ]
cases exists_eq_succ_of_ne_zero (ack_pos (m + 1) n).ne'
rw [h]
apply one_lt_ack_succ_right
rw [ack_succ_zero, ack_succ_succ]
exact ack_strict_mono_right _ (one_lt_ack_succ_left m n)
simp
rw [ack_succ_succ, ack_succ_succ]
exact
      (ack_strict_mono_left' _ <| (add_lt_add_iff_right 1).1 h).trans
        (ack_strict_mono_right _ <| ack_strict_mono_left' n h)
rw [ack_succ_zero, ack_succ_zero]
apply ack_add_one_sq_lt_ack_add_three
rw [Primrec.nat_iff]
exact not_nat_primrec_ack_self
refine' fun _ _ h => Option.some_injective _ _
rw [← e.decode_encode, ← e.decode_encode, h]
intro n
cases n <;> unfold encode_num decode_num
· rfl
rw [decode_encode_pos_num n]
rw [PosNum.cast_to_num]
exact if_neg (encode_pos_num_nonempty n)
rw [List.map_map, List.map_id' left_inverse_section_inclusion, decode_encode_nat]
simp only [eval_from, List.foldl_append, List.foldl_cons, List.foldl_nil]
rfl
rfl
rw [List.take_take, min_eq_left hle, ← eval_from_of_append, HEq, ← min_eq_left hle, ←
      List.take_take, min_eq_left hle, List.take_append_drop]
rw [div_eq_mul_inv]
exact hS.to_is_subring.to_is_submonoid.mul_mem hx (hS.inv_mem hy)
cases n
· rw [zpow_ofNat]
    exact hs.to_is_subring.to_is_submonoid.pow_mem h
· rw [zpow_negSucc]
    exact hs.inv_mem (hs.to_is_subring.to_is_submonoid.pow_mem h)
intros <;> trivial
rw [map_inv₀]
exact hs.inv_mem ha
rw [← Set.image_univ]
apply Image.is_subfield _ Univ.is_subfield
simp only [pow_add, *]
constructor <;> simp
rw [IsMonoidHom.map_one hf] <;> exact hs.one_mem
    mul_mem
rw [IsMonoidHom.map_mul hf] <;> exact hs.mul_mem ha hb
rw [hf.map_mul, hx.2, hy.2]
rw [← Set.image_univ]
exact univ.is_submonoid.image hf
rw [pow_zero]
exact hs.one_mem
rw [pow_succ]
exact hs.mul_mem h IsSubmonoid.pow_mem
refine' Quotient.induction_on m fun l hl => _
rw [Multiset.quot_mk_to_coe, Multiset.coe_prod]
exact list_prod_mem hs hl
induction ha <;> simp [h _, *, IsSubmonoid.one_mem, IsSubmonoid.mul_mem]
rw [mul_assoc, List.prod_cons, ← hyzx] <;> rfl
rw [← mul_assoc, List.prod_cons, ← hyzx, mul_comm hd] <;> rfl
refine' { .. } <;> intros <;> rfl
simp [map_add hf, map_add hg]
simp [map_mul hf, map_mul hg]
rw [hf.map_add] <;> simp
simp
rw [hf.map_add] <;> simp
simp [hf.map_zero]
simp [sub_eq_add_neg, hf.map_add, hf.map_neg]
refine' { .. } <;> intros <;> rfl
simp [map_add hf] <;> rw [map_add hg] <;> rfl
simp [map_mul hf] <;> rw [map_mul hg] <;> rfl
simp [map_one hf] <;> exact map_one hg
rw [List.map_cons, List.sum_cons, ih, List.map_cons, List.sum_cons, neg_add]
rw [List.map_append, List.sum_append]
rw [List.map_cons, List.sum_cons]
exact ha this (ih HL.2)
rw [List.prod_cons, List.prod_cons, HP]
rw [List.prod_cons, hhd, neg_one_mul, HP]
rw [List.prod_cons, List.prod_cons, HP, neg_mul_eq_mul_neg]
rw [List.prod_cons, hhd, HP, neg_one_mul, neg_neg]
refine' { .. } <;> simp (config := { contextual := true }) [trivial]
simp only [Set.ext_iff, IsSubgroup.mem_trivial] <;>
    exact ⟨fun h x => (h x).1, fun h x => ⟨h x, fun hx => hx.symm ▸ hs.to_is_submonoid.one_mem⟩⟩
refine' { .. } <;> simp
simp [center]
rw [← mul_assoc, mem_center.2 ha g, mul_assoc, mem_center.2 hb g, ← mul_assoc]
simp [ha g]
rw [← mul_assoc, mul_assoc] <;> simp
simp [ha g, mul_assoc]
rw [ha h] <;> simp
simp [normalizer]
rw [mul_inv_rev, ← mul_assoc, mul_assoc a, mul_assoc a, ← ha, ← hb]
rw [IsSubgroup.mul_mem_cancel_right hs ((IsSubgroup.inv_mem_iff hs).2 hg),
    IsSubgroup.mul_mem_cancel_left hs hg]
rw [hf.map_mul, hf.map_inv] at h
rw [← inv_inv (f b), eq_inv_of_mul_eq_one_left h]
rw [hf.map_mul, hf.map_inv] at h
apply inv_injective
rw [eq_inv_of_mul_eq_one_left h]
rw [h, mul_right_inv]
rw [h, mul_left_inv]
rw [mem_ker] <;> exact one_iff_ker_inv hf _ _
rw [mem_ker] <;> exact one_iff_ker_inv' hf _ _
simp [eq₁, eq₂, hf.map_mul]
rw [hf.map_inv]
simp [*]
refine' { .. } <;>
    simp (config := { contextual := true }) [hs.one_mem, hs.mul_mem, hs.inv_mem, hf.map_mul,
      hf.map_one, hf.map_inv, InvMemClass.inv_mem]
simp [hf.map_one, hs.to_is_subgroup.one_mem]
simp (config := { contextual := true }) [hf.map_mul, hs.to_is_subgroup.mul_mem]
simp (config := { contextual := true }) [hf.map_inv, hs.to_is_subgroup.inv_mem]
simp (config := { contextual := true }) [hs.normal, hf.map_mul, hf.map_inv]
rw [← h] <;> exact hf.inv_ker_one hfa
  rw [eq_inv_of_mul_eq_one_left ha, inv_inv a₂]
simp (config := { contextual := true }) [mem_ker, hf.map_one]
rw [hx, hf.map_one]
induction ha <;> simp [h _, *, ht.one_mem, ht.mul_mem, IsSubgroup.inv_mem_iff]
rw [inv_inv] <;> exact id
rw [List.reverse_cons, List.map_append, List.prod_append, ih, List.map_singleton,
              List.prod_cons, List.prod_nil, mul_one, List.prod_cons, mul_inv_rev]
rw [List.prod_append, HL2, HL4]
simp [Set.subset_def, (Group.closure.is_subgroup _).one_mem]
simp
simp only [Function.comp, hf.map_mul, hg.map_mul]
simp only [hf.map_mul, hg.map_mul, mul_comm, mul_assoc, mul_left_comm]
rw [← hf.map_mul, one_mul]
rw [hf.map_one, hg.map_one]
rw [← hf.map_mul, inv_mul_self, hf.map_one]
rw [← hf.map_one] <;> exact @h _ _
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
apply Multiset.induction_on' s
· exact gal_one_is_solvable
· intro p t hps hts ht
    rw [Multiset.insert_eq_cons, Multiset.prod_cons]
    exact gal_mul_is_solvable (hs p hps) ht
intro hb'
rw [hb', zero_pow hn'] at hb
exact ha' hb.symm
rw [div_pow, ← σ.map_pow, hb, σ.commutes, div_self ha']
have ha' : i a ≠ 0 := mt ((injective_iff_map_eq_zero i).mp i.injective a) ha
intro hb'
rw [hb', zero_pow hn'] at hb
exact ha' hb.symm
rw [← C_mul, ← i.map_mul, inv_mul_cancel ha, i.map_one, C_1]
rw [Polynomial.map_sub, Polynomial.map_sub, Polynomial.map_pow, map_X, map_C,
      Polynomial.map_one, sub_comp, pow_comp, X_comp, C_comp, mul_pow, ← C_pow, hb, mul_sub, ←
      mul_assoc, C_mul_C, one_mul]
rw [← hα₀, ← hβ₀]
rfl
rw [← hα₀]
rfl
rw [← hα₀, ← hβ₀]
rfl
rw [← hα₀]
rfl
rw [aeval_comp, aeval_X_pow, h2]
rw [← nat_degree_C _, ← h'.2, nat_degree_X_pow]
rw [aeval_comp, aeval_X_pow, minpoly.aeval]
intro x hx
cases hx
rw [hx]
exact ⟨IsIntegral α, hpq.1⟩
cases hx
exact ⟨IsIntegral β, hpq.2⟩
rw [aeval_alg_hom_apply, this, AlgHom.map_zero]
rw [minpoly.eq_X_sub_C]
exact gal_X_sub_C_is_solvable α
rw [minpoly.eq_of_irreducible q_irred q_aeval, ←
      show minpoly F (⟨α, hα⟩ : solvableByRad F E) = minpoly F α from
        minpoly.eq_of_algebra_map_eq (RingHom.injective _) (IsIntegral ⟨α, hα⟩) rfl]
exact IsSolvable ⟨α, hα⟩
unfold Ratfunc.liftOn
exact Localization.lift_on_mk _ _ _ _
unfold Ratfunc.mk
rw [mk_eq_div', RingHom.map_zero, div_zero]
simp only [mk_eq_div', ← Localization.mk_eq_mk', FractionRing.mk_eq_div]
simp only [← mk_coe_def, SetLike.coe_mk]
rw [mk_def_of_ne, Localization.mk_eq_mk']
rw [← IsLocalization.mk'_one (FractionRing K[X]) p, ← mk_coe_def, Submonoid.coe_one]
rw [mk_def_of_ne _ hq, mk_def_of_ne _ hq', of_fraction_ring_injective.eq_iff,
    IsLocalization.mk'_eq_iff_eq, SetLike.coe_mk, SetLike.coe_mk,
    (IsFractionRing.injective K[X] (FractionRing K[X])).eq_iff]
rw [mul_zero, mul_zero, mul_comm]
rw [mul_comm p p', h]
rw [Ratfunc.liftOn', Ratfunc.lift_on_mk _ _ _ f0]
exact lift_on_condition_of_lift_on'_condition @H
unfold Zero.zero Ratfunc.zero
unfold Add.add Ratfunc.add
unfold Sub.sub Ratfunc.sub
unfold Neg.neg Ratfunc.neg
unfold One.one Ratfunc.one
unfold Mul.mul Ratfunc.mul
unfold Div.div Ratfunc.div
unfold Inv.inv Ratfunc.inv
rw [hp, of_fraction_ring_zero]
unfold HasSmul.smul Ratfunc.smul
cases p
rw [← of_fraction_ring_smul]
cases x
induction x
·
    rw [← of_fraction_ring_smul, ← of_fraction_ring_smul, Localization.smul_mk,
      Localization.smul_mk, smul_eq_mul, Polynomial.smul_eq_C_mul]
· simp only
rw [← mk_smul, smul_assoc, mk_smul, mk_smul]
simp [← of_fraction_ring_add]
simp [← of_fraction_ring_mul]
cases subsingleton_or_nontrivial R
· rw [Subsingleton.elim p q, Subsingleton.elim p' q, Subsingleton.elim q' q]
rw [div_eq_div_iff, ← map_mul, h, map_mul] <;> exact nonZeroDivisors.ne_zero (hφ ‹_›)
rw [← of_fraction_ring_one, ← Localization.mk_one, lift_on_of_fraction_ring_mk]
simp only [map_one, Submonoid.coe_one, div_one]
simp only [mk_one', RingHom.map_add, of_fraction_ring_add]
simp only [mk_one', RingHom.map_mul, of_fraction_ring_mul]
simp only [mk_one', RingHom.map_one, of_fraction_ring_one]
simp only [mk_one', RingHom.map_zero, of_fraction_ring_zero]
rw [← mk_one, mk_one']
simp only [mk_eq_div', of_fraction_ring_div, of_fraction_ring_algebra_map]
rw [← mk_eq_div, mk_smul, mk_eq_div]
rw [← mk_eq_div]
rfl
have hq' : φ q ≠ 0 := nonZeroDivisors.ne_zero (hφ (mem_non_zero_divisors_iff_ne_zero.mpr hq))
simp only [← mk_eq_div, mk_eq_localization_mk _ hq, map_apply_of_fraction_ring_mk,
    mk_eq_localization_mk _ hq', SetLike.coe_mk]
simp
rw [← of_fraction_ring_comp_algebra_map]
exact of_fraction_ring_injective.comp (IsFractionRing.injective _ _)
rw [hx, RingHom.map_zero]
rw [← of_fraction_ring_algebra_map] <;>
      exact
        (to_fraction_ring_ring_equiv K).symm.toRingHom.is_unit_map (IsLocalization.map_units _ y)
rw [← of_fraction_ring_algebra_map, ← of_fraction_ring_algebra_map] <;>
      exact
        (to_fraction_ring_ring_equiv K).symm.Injective.eq_iff.trans
          (IsLocalization.eq_iff_exists _ _)
rw [← mk_eq_div, lift_on_mk _ _ f f0 @H']
rw [Ratfunc.liftOn', lift_on_div _ _ _ f0]
exact lift_on_condition_of_lift_on'_condition @H
rw [IsFractionRing.mk'_eq_div, IsFractionRing.mk'_eq_div, ← mk_eq_div', ← mk_eq_div]
simp only [IsLocalization.alg_equiv_apply, IsLocalization.ring_equiv_of_ring_equiv_apply,
        RingEquiv.to_fun_eq_coe, Localization.mk_eq_mk'_apply, IsLocalization.map_mk',
        of_fraction_ring_mk', RingEquiv.coe_to_ring_hom, RingEquiv.refl_apply, SetLike.eta]
simp only [Localization.mk_eq_mk'_apply, of_fraction_ring_mk', IsLocalization.alg_equiv_apply,
        RingEquiv.to_fun_eq_coe, IsLocalization.ring_equiv_of_ring_equiv_apply,
        IsLocalization.map_mk', RingEquiv.coe_to_ring_hom, RingEquiv.refl_apply, SetLike.eta]
rw [Polynomial.degree_mul, Polynomial.degree_C hainv, zero_add]
exact hdeg
rw [num_denom, lift_on'_div, if_neg hq]
intro p
rw [if_pos rfl, if_neg (one_ne_zero' K[X])]
simp
rw [Num, num_denom_div _ hq]
rw [denom, num_denom_div _ hq]
rw [denom_div p hq, mul_comm]
exact Polynomial.monic_mul_leading_coeff_inv (right_div_gcd_ne_zero hq)
have q_div_ne_zero := right_div_gcd_ne_zero hq
rw [num_div p q, denom_div p hq, RingHom.map_mul, RingHom.map_mul, mul_div_mul_left,
      div_eq_div_iff, ← RingHom.map_mul, ← RingHom.map_mul, mul_comm _ q, ←
      EuclideanDomain.mul_div_assoc, ← EuclideanDomain.mul_div_assoc, mul_comm]
· apply gcd_dvd_right
· apply gcd_dvd_left
· exact algebra_map_ne_zero q_div_ne_zero
· exact algebra_map_ne_zero hq
· refine' algebra_map_ne_zero (mt polynomial.C_eq_zero.mp _)
      exact inv_ne_zero (polynomial.leading_coeff_ne_zero.mpr q_div_ne_zero)
rw [← num_div_denom x, h, RingHom.map_zero, zero_div]
rw [num_mul_eq_mul_denom_iff (denom_ne_zero x), _root_.map_neg, neg_div, num_div_denom]
rw [denom_dvd (mul_ne_zero (denom_ne_zero x) (denom_ne_zero y))]
refine' ⟨x.num * y.num, _⟩
rw [RingHom.map_mul, RingHom.map_mul, ← div_mul_div_comm, num_div_denom, num_div_denom]
rw [denom_dvd (mul_ne_zero (denom_ne_zero x) (denom_ne_zero y))]
refine' ⟨x.num * y.denom + x.denom * y.num, _⟩
rw [RingHom.map_mul, RingHom.map_add, RingHom.map_mul, RingHom.map_mul, ← div_add_div,
    num_div_denom, num_div_denom]
· exact algebra_map_ne_zero (denom_ne_zero x)
· exact algebra_map_ne_zero (denom_ne_zero y)
rw [← num_div_denom f, map_apply_div_ne_zero, num_div_denom f]
exact denom_ne_zero _
rw [← num_div_denom f, lift_monoid_with_zero_hom_apply_div, num_div_denom]
intro h_zero
have h := num_denom_add x y
rw [h_zero, zero_mul] at h
exact (mul_ne_zero (num_ne_zero hxy) (mul_ne_zero x.denom_ne_zero y.denom_ne_zero)) h
rw [Algebra.smul_def, algebra_map_eq_C]
rw [eval, h, div_zero]
simp [eval]
simp [eval]
simp [eval]
simp [eval]
simp [eval, IsScalarTower.algebra_map_apply S K[X] (Ratfunc K)]
unfold eval
unfold eval
rw [int_degree, num_zero, nat_degree_zero, denom_zero, nat_degree_one, sub_self]
rw [int_degree, num_one, denom_one, sub_self]
rw [int_degree, num_C, nat_degree_C, denom_C, nat_degree_one, sub_self]
rw [int_degree, Ratfunc.num_X, Polynomial.nat_degree_X, Ratfunc.denom_X,
    Polynomial.nat_degree_one, Int.ofNat_one, Int.ofNat_zero, sub_zero]
rw [int_degree, Ratfunc.num_algebra_map, Ratfunc.denom_algebra_map, Polynomial.nat_degree_one,
    Int.ofNat_zero, sub_zero]
apply
    nat_degree_sub_eq_of_prod_eq (mul_ne_zero (num_ne_zero hx) hs) (mul_ne_zero hs x.denom_ne_zero)
      (num_ne_zero hx) x.denom_ne_zero
rw [mul_assoc]
rw [coe_num_denom, num_C, denom_C, coe_coe, Polynomial.coe_C, coe_C, coe_coe, Polynomial.coe_one,
    PowerSeries.coe_one, div_one]
rw [smul_eq_C_mul, ← C_mul_eq_smul, coe_mul, coe_C]
rw [coe_num_denom, num_X, denom_X, coe_coe, Polynomial.coe_X, coe_X, coe_coe, Polynomial.coe_one,
    PowerSeries.coe_one, div_one]
rw [← mem_restrict_scalars K, H, mem_restrict_scalars]
infer_instance
rw [SetLike.ext_iff, SetLike.ext'_iff, Set.ext_iff]
rfl
rw [← is_algebraic_iff_is_integral, is_algebraic_iff, is_algebraic_iff_is_integral]
cases p <;> cases q <;> congr
rw [map_inv₀ f]
exact s.inv_mem hx
simp [← s_eq, ← s'_eq]
simp [mem_supr_of_directed hS]
simp [mem_Sup_of_directed_on Sne hS]
rw [map_inv₀ f, map_inv₀ g, hx]
infer_instance
dsimp only [GaloisField]
exact FiniteDimensional.fintypeOfFintype (Zmod p) (GaloisField p n)
let b := IsNoetherian.finsetBasis (Zmod p) (GaloisField p n)
rw [Module.card_fintype b, ← FiniteDimensional.finrank_eq_card_basis b, Zmod.card, finrank p h]
rw [pow_one, Zmod.card p]
rw [h]
infer_instance
rw [← Algebra.char_p_iff (Zmod p) K p]
exact Zmod.char_p p
rw [← Algebra.char_p_iff (Zmod p) K' p]
exact Zmod.char_p p
simp [Finset.ext_iff, mem_roots_sub_C hp]
rw [ha, ← hb, eval_neg, neg_add_self]
decide
simp [nat_degree_eq_of_degree_eq_some hf2, hR]
decide
rw [card_disjoint_union hd] <;>
          simp [nat_degree_eq_of_degree_eq_some hf2, nat_degree_eq_of_degree_eq_some hg2, bit0,
            mul_add]
simp
simp (config := { contextual := true }) [Units.inv_eq_self_iff]
simp [@inv_eq_iff_inv_eq _ _ a, eq_comm]
simp
rw [Units.val_pow_eq_pow_val, Units.val_mk0]
have hp : 0 < Fintype.card K := lt_trans zero_lt_one Fintype.one_lt_card
apply fintype.card_le_one_iff.mp (le_of_eq h)
  exact absurd this zero_ne_one
rw [Units.val_one, one_pow]
intros
rw [Units.val_mul, mul_pow]
rw [← this, univ.sum_map φ]
rfl
rw [sum_pow_units K i, if_neg]
exact hiq
rw [eq_univ_iff_forall]
intro x
rw [Multiset.mem_to_finset, mem_roots aux, is_root.def, eval_sub, eval_pow, eval_X,
        sub_eq_zero, pow_card]
have h : (X ^ q - X : K[X]).natDegree = q :=
      X_pow_card_sub_X_nat_degree_eq K Fintype.one_lt_card
rw [← splits_id_iff_splits, splits_iff_card_roots, Polynomial.map_sub, Polynomial.map_pow,
      map_X, h, roots_X_pow_card_sub_X K, ← Finset.card_def, Finset.card_univ]
decide
rw [Zmod.card, hp_odd]
cases n
· rw [Nat.totient_zero, pow_zero]
· rw [← card_units_eq_totient, pow_card_eq_one]
let b := IsNoetherian.finsetBasis K V
rw [Module.card_fintype b, ← FiniteDimensional.finrank_eq_card_basis b]
rw [Fintype.card_units, card]
rw [← card_units p, pow_card_eq_one]
rw [CharP.int_cast_eq_zero_iff _ p, ← (nat.prime_iff_prime_int.mp hp).coprime_iff_not_dvd]
· exact hpn.symm
exact Zmod.char_p p
simp only [injective, not_forall, exists_prop]
refine' ⟨-1, 1, _, Ring.neg_one_ne_one_of_char_ne_two hF⟩
simp only [sq, one_pow, neg_one_sq]
have h₁ := FiniteField.pow_card_sub_one_eq_one a ha
rw [← Nat.two_mul_odd_div_two (FiniteField.odd_card_of_char_ne_two hF), mul_comm, pow_mul,
    pow_two] at h₁
exact mul_self_eq_one_iff.mp h₁
rw [mem_powers_iff_mem_zpowers]
apply hg
rw [← pow_mul] at h
rw [hodd, ← Fintype.card_units, ← order_of_eq_card_of_forall_mem_zpowers hg]
apply order_of_dvd_of_pow_eq_one h
simp [Units.ext_iff]
apply induction_on f
· intro a
    rw [expand_C, frobenius_def, ← C_pow, Zmod.pow_card]
· simp only [AlgHom.map_add, RingHom.map_add]
    intro _ _ hf hg
    rw [hf, hg]
· simp only [expand_X, RingHom.map_mul, AlgHom.map_mul]
    intro _ _ hf
    rw [hf, frobenius_def]
rw [indicator]
refine' le_trans (degrees_prod _ _) (Finset.sum_le_sum fun s hs => _)
refine' le_trans (degrees_sub _ _) _
rw [degrees_one, ← bot_eq_zero, bot_sup_eq]
refine' le_trans (degrees_pow _ _) (nsmul_le_nsmul_of_le_right _ _)
refine' le_trans (degrees_sub _ _) _
rw [degrees_C, ← bot_eq_zero, sup_bot_eq]
exact degrees_X' _
simp only [Set.mem_setOf_eq] <;> infer_instance
rw [Finsupp.dim_eq, dim_self, mul_one]
refine' Quotient.sound ⟨(Equiv.subtypeEquiv Finsupp.equivFunOnFinite) fun f => _⟩
refine' forall_congr' fun n => le_tsub_iff_right _
exact Fintype.card_pos_iff.2 ⟨0⟩
rw [evalᵢ, LinearMap.range_comp, range_subtype]
exact map_restrict_dom_evalₗ
cases nonempty_fintype σ
refine' (ker_eq_bot_iff_range_eq_top_of_finrank_eq_finrank _).mpr (range_evalᵢ _ _)
rw [FiniteDimensional.finrank_fintype_fun_eq_card, finrank_R]
rw [hα]
exact IntermediateField.mem_top
rw [Algebra.algebra_map_eq_smul_one, smul_comm, smul_one]
exact
        SetLike.coe_injective
          (Set.eq_of_inclusion_surjective
              ((Fintype.bijective_iff_injective_and_card (Set.inclusion H_le)).mpr
                  ⟨Set.inclusion_injective H_le, this⟩).2).symm
exact (IntermediateField.eq_of_le_of_finrank_eq' K_le this).symm
conv => 
    rhs
    rw [← fixed_field_fixing_subgroup K, IntermediateField.finrank_fixed_field_eq_card]
rw [← fixed_field_fixing_subgroup L, IntermediateField.le_iff_le, fixed_field_fixing_subgroup L]
rfl
apply minpoly.dvd
rw [Polynomial.aeval_def, Polynomial.eval₂_map, ← Polynomial.eval_map, ←
      IsScalarTower.algebra_map_eq]
exact (Polynomial.mem_roots (Polynomial.map_ne_zero h1)).mp hx
apply Fintype.ofInjective (Sigma.mk f) fun _ _ H => eq_of_heq (Sigma.mk.inj H).2
exact Fintype.ofEquiv _ key_equiv
apply IntermediateField.to_subalgebra_injective
rw [IntermediateField.top_to_subalgebra, ← top_le_iff, ← sp.adjoin_roots]
apply IntermediateField.algebra_adjoin_le_adjoin
rw [AdjoinRoot] at this
apply of_card_aut_eq_finrank
rw [← Eq.trans this (LinearEquiv.finrank_eq intermediate_field.top_equiv.to_linear_equiv)]
exact
      Fintype.card_congr
        ((algEquivEquivAlgHom F E).toEquiv.trans
          (intermediate_field.top_equiv.symm.arrow_congr AlgEquiv.refl))
simp
rw [← mk_one, ← mk_one, mk_eq_div, laurent_aux_div, mk_eq_div, taylor_one, _root_.map_one]
simp [Polynomial.algebra_map_apply]
rw [← algebra_map_X, laurent_algebra_map, taylor_X, _root_.map_add, algebra_map_C]
rw [← algebra_map_C, laurent_algebra_map, taylor_C]
induction f using Ratfunc.induction_on
simp
simp only [Equiv.apply_symm_apply, one_smul]
simp only [Equiv.apply_symm_apply, Equiv.symm_apply_apply, mul_smul]
let ψ := AlgEquiv.ofInjectiveField (IsScalarTower.toAlgHom F p.splitting_field E)
change ↑(ψ (ψ.symm _)) = ϕ x
rw [AlgEquiv.apply_symm_apply ψ]
change ϕ (roots_equiv_roots p E ((roots_equiv_roots p E).symm x)) = ϕ x
rw [Equiv.apply_symm_apply (roots_equiv_roots p E)]
simp only [restrict_dvd, dif_neg hq, restrict_surjective]
rw [hpq]
infer_instance
apply splits_mul
· rw [←
      (splitting_field.lift q₁
          (splits_of_splits_of_dvd _ (mul_ne_zero hq₁ hq₂) (splitting_field.splits _)
            (dvd_mul_right q₁ q₂))).comp_algebra_map]
    exact splits_comp_of_splits _ _ h₁
· rw [←
      (splitting_field.lift q₂
          (splits_of_splits_of_dvd _ (mul_ne_zero hq₁ hq₂) (splitting_field.splits _)
            (dvd_mul_left q₂ q₁))).comp_algebra_map]
    exact splits_comp_of_splits _ _ h₂
intro r hr
intro p₁ p₂ hp₁ hp₂
rw [h.2, nat_degree_C]
rw [h.2, nat_degree_C]
simp only [restrict_comp, restrict_surjective]
have key := (minpoly.irreducible hα).dvd_symm p_irr this
apply le_antisymm
· exact nat_degree_le_of_dvd this p_irr.ne_zero
· exact nat_degree_le_of_dvd key (minpoly.ne_zero hα)
intro z
rw [Set.mem_to_finset, mem_root_set_of_ne hp]
infer_instance
rw [aeval_alg_hom_apply, hw, AlgHom.map_zero]
intro w
rw [Subtype.ext_iff, gal_action_hom_restrict]
exact Complex.eq_conj_iff_im
rw [← MonoidHom.map_pow, ← MonoidHom.map_pow,
          show AlgEquiv.restrictScalars ℚ Complex.conjAe ^ 2 = 1 from
            AlgEquiv.ext Complex.conj_conj,
          MonoidHom.map_one, MonoidHom.map_one]
exact this n hn p_roots1 p_roots2
  rintro m ⟨k, rfl⟩ h2 h3
  exact
    le_antisymm
      (nat.lt_succ_iff.mp
        (lt_of_le_of_ne h3 (show 2 * k ≠ 2 * 1 + 1 from Nat.two_mul_ne_two_mul_add_one)))
      (nat.succ_le_iff.mpr
        (lt_of_le_of_ne h2 (show 2 * 0 + 1 ≠ 2 * k from nat.two_mul_ne_two_mul_add_one.symm)))
simp [Set.sUnion_image]
simp [Set.sUnion_image]
simp [infi]
simp [infi]
simp [infi]
apply subfield.closure_le.mpr
rw [Set.union_subset_iff]
exact ⟨HF, HS⟩
rw [adjoin_adjoin_left, adjoin_adjoin_left, Set.union_comm]
exact ⟨fun h => ⟨h.1, (this h.1).mp h.2⟩, fun h => ⟨h.1, (this h.1).mpr h.2⟩⟩
have := (adjoin_simple_is_compact_element x).exists_finset_of_le_supr (IntermediateField F E) f
simp only [adjoin_simple_le_iff] at this
exact this hx
refine'
    exists_finset_of_mem_supr
      (set_like.le_def.mp
        (supr_le fun i x hx =>
          set_like.le_def.mp (le_supr_of_le ⟨i, x, hx⟩ le_rfl) (subset_adjoin F _ _))
        hx)
rw [IntermediateField.minpoly_eq, Subtype.coe_mk, mem_root_set_of_ne, minpoly.aeval]
exact minpoly.ne_zero (is_integral_iff.mp (is_algebraic_iff_is_integral.mp (h i ⟨x, hx⟩)))
rw [eq_bot_iff, adjoin_le_iff]
rfl
rw [adjoin_eq_bot_iff]
exact Set.singleton_subset_iff
rw [← to_subalgebra_eq_iff, ← dim_eq_dim_subalgebra, Subalgebra.dim_eq_one_iff, bot_to_subalgebra]
rw [← to_subalgebra_eq_iff, ← finrank_eq_finrank_subalgebra, Subalgebra.finrank_eq_one_iff,
    bot_to_subalgebra]
rw [dim_eq_one_iff]
rw [finrank_eq_one_iff]
rw [dim_adjoin_eq_one_iff]
exact Set.singleton_subset_iff
rw [finrank_adjoin_eq_one_iff]
exact Set.singleton_subset_iff
exact fun x => Exists.cases_on (this (Subtype.mem x)) fun y hy => ⟨y, Subtype.ext hy⟩
rw [RingHom.comp_apply, AdjoinRoot.lift_of]
exact hy
rw [RingHom.comp_apply, AdjoinRoot.lift_root]
rfl
rw [power_basis_aux, Basis.map_apply, PowerBasis.basis_eq_pow, AlgEquiv.to_linear_equiv_apply,
      AlgEquiv.map_pow, AdjoinRoot.power_basis_gen, adjoin_root_equiv_adjoin_apply_root]
rw [PowerBasis.finrank (adjoin.power_basis hx : _)]
rfl
rw [adjoin.power_basis_gen, minpoly_gen h, Equiv.refl_apply]
rw [AlgHom.card_of_power_basis] <;>
    simp only [adjoin.power_basis_dim, adjoin.power_basis_gen, minpoly_gen h, h_sep, h_splits]
apply Finset.induction_on' S
· exact base
· intro a s h1 _ _ h4
    rw [Finset.coe_insert, Set.insert_eq, Set.union_comm, ← adjoin_adjoin_left]
    exact ih (adjoin F s) a h1 h4
intro x hx
rw [adjoin.power_basis_gen, adjoin_simple.algebra_map_gen]
rw [equiv_adjoin_simple, equiv_of_minpoly_symm, equiv_of_minpoly_aeval, adjoin.power_basis_gen]
rw [equiv_adjoin_simple, equiv_of_minpoly_symm, equiv_of_minpoly_gen, adjoin.power_basis_gen]
rw [RingHom.map_zero, aeval_map_algebra_map, ← aeval_algebra_map_apply]
exact minpoly.aeval F (algebraMap K E x)
rw [hp]
exact ⟨splits_zero _, Subsingleton.elim _ _⟩
rw [algebra_map_eq F E D, ← eval₂_map, hr, AdjoinRoot.algebra_map_eq, eval₂_mul,
            AdjoinRoot.eval₂_root, zero_mul]
exact Nonempty.map (AlgHom.restrictScalars F) this
rw [AdjoinRoot.adjoin_root_eq_top, Subalgebra.restrict_scalars_top, ←
      @Subalgebra.restrict_scalars_top F C] at this
exact top_le_iff.mpr (Subalgebra.restrict_scalars_injective F this)
refine' supr_le fun i => supr_le fun hi => le_supr_of_le i.1 _
rw [adjoin_le_iff, ← image_root_set ((h i.1).Splits i.2) (t i.1).val]
exact fun _ ⟨a, _, h⟩ => h ▸ a.2
simp [aeval_alg_hom_apply]
exact is_integral_of_is_scalar_tower this
      exact map_is_integral ϕ (map_is_integral (to_alg_hom F E K₁) (h.is_integral z))
simp only [AlgHom.comp_apply, AlgHom.restrict_normal_commutes]
simp only [AlgEquiv.trans_apply, AlgEquiv.restrict_normal_commutes]
rw [splits_map_iff, ← IsScalarTower.algebra_map_eq]
exact (h.out x).2
apply @AlgHom.commutes K₁ E E _ _ _ _
let ϕ := algebraMap K L
rw [← IntermediateField.restrict_scalars_normal, restrict_scalars_eq_supr_adjoin]
apply IntermediateField.normalSupr F L _
intro x
apply Normal.ofIsSplittingField (minpoly F x)
exact
    adjoin_root_set_is_splitting_field
      ((minpoly.eq_of_algebra_map_eq ϕ.injective
            ((is_integral_algebra_map_iff ϕ.injective).mp (h.is_integral (ϕ x))) rfl).symm ▸
        h.splits _)
simp
rw [finset_basis, Basis.range_reindex, Basis.range_of_vector_space]
let ⟨a, ha⟩ := hf.dvd_degree'
rw [← ha, one_pow a, mul_one]
rw [pow_zero, expand_one]
rw [h_expand]
simp only [eval_eq']
rw [mul_sum]
rw [sum_pow_lt_card_sub_one _ hi, mul_zero]
rw [← e'.prod_comp, Fintype.prod_sum_type, univ_unique, prod_singleton]
rfl
rw [Equiv.subtypeEquivCodomain_symm_apply_eq]
rw [← Fintype.card_units, Fintype.card_pos_iff]
exact ⟨1⟩
intro x
simp only [S, true_and_iff, sep_def, mem_filter, mem_univ]
  /- The polynomial `F = ∏ i in s, (1 - (f i)^(q - 1))` has the nice property
    that it takes the value `1` on elements of `{x : σ → K // ∀ i ∈ s, (f i).eval x = 0}`
    while it is `0` outside that locus.
    Hence the sum of its values is equal to the cardinality of
    `{x : σ → K // ∀ i ∈ s, (f i).eval x = 0}` modulo `p`. -/
simp only [max_eq_right, Nat.zero_le, total_degree_one]
rw [hx, hx]
rw [smul_mul', f.prop m]
rw [Polynomial.smul_C, smul]
rw [smul_add, ihp, ihq]
rw [smul_mul', Polynomial.smul_C, smul, smul_pow', Polynomial.smul_X]
infer_instance
simp only [minpoly, Polynomial.monic_to_subring]
exact prodXSubSmul.monic G F x
rw [← prodXSubSmul.eval G F x, Polynomial.eval₂_eq_eval_map]
simp only [minpoly, Polynomial.map_to_subring]
erw [← Polynomial.map_dvd_map' (Subfield.subtype <| FixedPoints.subfield G F), minpoly,
    Polynomial.map_to_subring _ (Subfield G F).toSubring, prodXSubSmul]
refine'
    Fintype.prod_dvd_of_coprime
      (Polynomial.pairwise_coprime_X_sub_C <| MulAction.injective_of_quotient_stabilizer G x)
      fun y => (QuotientGroup.induction_on y) fun g => _
rw [Polynomial.dvd_iff_is_root, Polynomial.IsRoot.def, MulAction.of_quotient_stabilizer_mk,
    Polynomial.eval_smul', ← Subfield.toSubring.subtype_eq_subtype, ←
    IsInvariantSubring.coe_subtype_hom' G (FixedPoints.subfield G F).toSubring, ←
    MulSemiringActionHom.coe_polynomial, ← MulSemiringActionHom.map_smul, smul_polynomial,
    MulSemiringActionHom.coe_polynomial, IsInvariantSubring.coe_subtype_hom', Polynomial.eval_map,
    Subfield.toSubring.subtype_eq_subtype, hf, smul_zero]
rw [← hfg]
exact dvd_mul_right _ _
rw [← hfg]
exact dvd_mul_left _ _
cases nonempty_fintype G
exact ⟨minpoly G F x, minpoly.monic G F x, minpoly.eval₂ G F x⟩
cases nonempty_fintype G
rw [← minpoly_eq_minpoly, minpoly, coe_algebra_map, ← Subfield.toSubring.subtype_eq_subtype,
        Polynomial.map_to_subring _ (Subfield G F).toSubring, prodXSubSmul]
exact Polynomial.splits_prod _ fun _ _ => Polynomial.splits_X_sub_C _
cases nonempty_fintype G
    -- this was a plain rw when we were using unbundled subrings
erw [← minpoly_eq_minpoly, ← Polynomial.separable_map (FixedPoints.subfield G F).Subtype,
      minpoly, Polynomial.map_to_subring _ (Subfield G F).toSubring]
exact Polynomial.separable_prod_X_sub_C_iff.2 (injective_of_quotient_stabilizer G x)
cases nonempty_fintype G
exact
    IsNoetherian.iff_fg.1
      (IsNoetherian.iff_dim_lt_aleph_0.2 <| (dim_le_card G F).trans_lt <| Cardinal.nat_lt_aleph_0 _)
rw [← Cardinal.nat_cast_le, finrank_eq_dim]
apply dim_le_card
cases nonempty_fintype G
rw [Fintype.bijective_iff_injective_and_card]
constructor
· exact MulSemiringAction.to_alg_hom_injective _ F
· apply le_antisymm
    · exact Fintype.card_le_of_injective _ (MulSemiringAction.to_alg_hom_injective _ F)
    · rw [← finrank_eq_card G F]
      exact LE.le.trans_eq (finrank_alg_hom _ F) (finrank_linear_map' _ _ _)
rw [← f.map_frobenius, frobenius_pth_root]
rw [← iterate_succ_apply, iterate_succ', iterate_succ', ← frobenius_mul, Nat.succ_add] <;>
        apply r.intro
rw [← iterate_succ_apply, iterate_succ', iterate_succ', ← frobenius_mul] <;> apply r.intro
simp only [add_assoc, mul_assoc, RingHom.iterate_map_mul, ← iterate_add_apply,
                add_comm, add_left_comm]
simp only [RingHom.iterate_map_one, iterate_zero_apply, one_mul, zero_add]
simp only [RingHom.iterate_map_one, iterate_zero_apply, mul_one, add_zero]
simp only [add_comm, mul_comm]
rw [← iterate_succ_apply, iterate_succ', iterate_succ', ← frobenius_add, Nat.succ_add] <;>
        apply r.intro
rw [← iterate_succ_apply, iterate_succ', iterate_succ', ← frobenius_add] <;> apply r.intro
rw [← frobenius_neg] <;> apply r.intro
simp only [RingHom.iterate_map_add, ← iterate_add_apply, add_assoc, add_comm s _]
simp only [RingHom.iterate_map_zero, iterate_zero_apply, zero_add]
simp only [RingHom.iterate_map_zero, iterate_zero_apply, add_zero]
simp only [quot_mk_eq_mk, neg_mk, mk_add_mk, RingHom.iterate_map_neg, add_left_neg, mk_zero]
simp only [add_comm]
simp only [add_assoc, add_comm, add_left_comm] <;> apply r.sound <;>
                simp only [RingHom.iterate_map_mul, RingHom.iterate_map_add, ← iterate_add_apply,
                  mul_add, add_comm, add_left_comm]
simp only [add_assoc, add_comm _ s, add_left_comm _ s] <;> apply r.sound <;>
                simp only [RingHom.iterate_map_mul, RingHom.iterate_map_add, ← iterate_add_apply,
                  add_mul, add_comm, add_left_comm]
induction x <;> simp only [Int.cast_of_nat, Int.cast_negSucc, nat_cast K p 0] <;> rfl
constructor
intro x
rw [← CharP.cast_eq_zero_iff K]
rw [← Nat.cast_zero, nat_cast_eq_iff, Nat.cast_zero]
apply this
  intro p
  induction' p
simp only [frobenius_def]
rw [← inv_pow]
apply r.intro
simp only [(frobenius _ _).iterate_map_one, (frobenius K p).iterate_map_zero,
                iterate_zero_apply, ← (frobenius _ p).iterate_map_mul] at this⊢ <;>
              rw [mul_inv_cancel this, (frobenius _ _).iterate_map_one]
rw [inv_zero]
simp only [lift_on_mk, frobenius_mk]
exact (Quot.sound <| r.intro _ _).symm
simp only [lift_on_mk, frobenius_mk]
exact (Quot.sound <| r.intro _ _).symm
let b := Basis.ofVectorSpace F K
let c := Basis.ofVectorSpace K A
rw [← (Module.rank F K).lift_id, ← b.mk_eq_dim, ← (Module.rank K A).lift_id, ← c.mk_eq_dim, ←
    lift_umax.{w, v}, ← (b.smul c).mk_eq_dim, mk_prod, lift_mul, lift_lift, lift_lift, lift_lift,
    lift_lift, lift_umax]
rw [Submodule.restrict_scalars_top, eq_top_iff, ← hb, Submodule.span_le]
exact Submodule.subset_span
let b := Basis.ofVectorSpace F V
let c := Basis.ofVectorSpace F W
rw [LinearEquiv.finrank_eq (LinearMap.toMatrix b c), Matrix.finrank_matrix,
    finrank_eq_card_basis b, finrank_eq_card_basis c, mul_comm]
dsimp
rw [← AlgEquiv.inv_fun_eq_symm]
rfl
let φ := f
apply ne_of_apply_ne f
change f (f.symm (g x)) ≠ f x
rw [AlgEquiv.apply_symm_apply f (g x), ne_comm]
exact hx
apply IntermediateField.subset_adjoin
apply Set.mem_singleton
rw [to_splitting_field, eval_X_self, ← AlgHom.coe_to_ring_hom, hom_eval₂, AlgHom.coe_to_ring_hom,
    MvPolynomial.aeval_X, dif_pos hf, ← algebra_map_eq, AlgHom.comp_algebra_map]
exact map_root_of_splits _ _ _
erw [adjoin_monic.algebra_map, ← hom_eval₂, Ideal.Quotient.eq_zero_iff_mem]
exact le_max_ideal k (Ideal.subset_span ⟨f, rfl⟩)
rw [to_adjoin_monic, ← hom_eval₂, Ideal.Quotient.eq_zero_iff_mem]
exact le_max_ideal k (Ideal.subset_span <| ⟨_, rfl⟩)
rw [hp, roots_C]
rw [← coe_norm_unit_of_ne_zero hq.ne_zero]
exact (associated_normalize _).Irreducible hq
refine' fun x => ⟨-(minpoly k x).coeff 0, _⟩
have hq : (minpoly k x).leadingCoeff = 1 := minpoly.monic (hf x)
have h : (minpoly k x).degree = 1 := degree_eq_one_of_irreducible k (minpoly.irreducible (hf x))
have : aeval x (minpoly k x) = 0 := minpoly.aeval k x
rw [eq_X_add_C_of_degree_eq_one h, hq, C_1, one_mul, aeval_add, aeval_X, aeval_C,
    add_eq_zero_iff_eq_neg] at this
exact (RingHom.map_neg (algebraMap k K) ((minpoly k x).coeff 0)).symm ▸ this.symm
rw [le_def] at h
cases h
assumption
simp
erw [← inclusion_inclusion h₁₂.fst h₂₃.fst, compat, compat]
intro x
simp [ub]
rfl
rw [Set.not_nonempty_iff_eq_empty] at hcn
simp [hcn]
intro z hz
show algebraMap N L ⟨z, hz⟩ ∈ O
exact O.algebra_map_mem _
refine' ⟨hNO, _⟩
intro z
show O'.emb (algebraMap N O z) = algebraMap N M z
simp only [O', restrict_scalars_apply, AlgHom.commutes]
intro inst x
exact
    (IsFractionRing.is_algebraic_iff R (FractionRing R) (FractionRing S)).1
      ((IsFractionRing.is_algebraic_iff' R S (FractionRing S)).1 hS x)
simp
erw [card_root_set_eq_nat_degree hfsep (IsAlgClosed.splits_domain _), nat_degree_X_pow_sub_C]
simp [RingHom.algebra_map_to_algebra]
rw [IsScalarTower.algebra_map_eq R S L]
exact
          Function.Injective.comp (NoZeroSmulDivisors.algebra_map_injective _ _)
            (NoZeroSmulDivisors.algebra_map_injective _ _)
infer_instance
rw [← RingEquiv.symm_apply_apply hSR x]
exact is_algebraic_algebra_map _
simp [RingHom.algebra_map_to_algebra]
simp
rw [Ne.def, ← Polynomial.degree_eq_bot,
            Polynomial.degree_map_eq_of_injective (NoZeroSmulDivisors.algebra_map_injective R L),
            Polynomial.degree_eq_bot]
exact p.2.1
intro h
simp only at h
refine' (Subtype.heq_iff_coe_eq _).1 h.2
simp only [h.1, iff_self_iff, forall_true_iff]
rw [← mk_sigma] <;> rfl
simp only [max_assoc, max_comm ℵ₀, max_left_comm ℵ₀, max_self]
infer_instance
rw [Cardinal.eq.2 ⟨hv.1.aevalEquiv.toEquiv⟩]
simp [max_assoc]
rw [max_eq_left, max_eq_right]
· exact le_trans hR this
· exact le_max_of_le_right this
rw [is_root.def, eval_map, hg, eval₂_mul, ← hg, AdjoinRoot.eval₂_root, zero_mul]
rw [nat_degree_remove_factor, hfn, n.add_sub_cancel]
rw [h] at hf
cases hf
intro h
rw [h] at hf
cases hf
intro h
rw [h] at hndf
exact hndf rfl
rw [algebra_map_succ, ← RingHom.comp_assoc, hk, AdjoinRoot.lift_comp_of]
intro h
rw [h] at hfn
cases hfn
intro h
rw [h] at hndf
exact hndf rfl
rw [splits_map_iff, ← IsScalarTower.algebra_map_eq]
exact splits L f
rw [map_map, ← IsScalarTower.algebra_map_eq, Subalgebra.restrict_scalars_top, eq_top_iff, ←
        adjoin_roots L f, Algebra.adjoin_le_iff]
exact fun x hx => @Algebra.subset_adjoin K _ _ _ _ _ _ hx
rw [RingEquiv.to_ring_hom_trans]
exact splits_comp_of_splits _ _ (splits L f)
rw [Polynomial.map_mul,
      roots_mul (mul_ne_zero (map_ne_zero hf : f.map (algebraMap F L) ≠ 0) (map_ne_zero hg)),
      Multiset.to_finset_add, Finset.coe_union, Algebra.adjoin_union_eq_adjoin_adjoin,
      IsScalarTower.algebra_map_eq F K L, ← map_map,
      roots_map (algebraMap K L) ((splits_id_iff_splits <| algebraMap F K).2 <| splits K f),
      Multiset.to_finset_map, Finset.coe_image, Algebra.adjoin_algebra_map, adjoin_roots,
      Algebra.map_top, IsScalarTower.adjoin_range_to_alg_hom, ← map_map, adjoin_roots,
      Subalgebra.restrict_scalars_top]
rw [← (splits_iff L f).1 (show f.splits (RingHom.id K) from hf0.symm ▸ splits_zero _)]
exact Algebra.toTop
rw [← adjoin_roots L f]
exact
          Classical.choice
            ((lift_of_splits _) fun y hy =>
              have : aeval y f = 0 :=
                (eval₂_eq_eval_map _).trans <|
                  (mem_roots <| map_ne_zero hf0).1 (multiset.mem_to_finset.mp hy)
              ⟨is_algebraic_iff_is_integral.1 ⟨f, hf0, this⟩,
                splits_of_splits_of_dvd _ hf0 hf <| minpoly.dvd _ _ this⟩)
rw [hf, Polynomial.map_zero, roots_zero] at hy
cases hy
constructor
· rw [← f.to_alg_hom.comp_algebra_map]
    exact splits_comp_of_splits _ _ (splits F p)
·
    rw [← (Algebra.range_top_iff_surjective f.to_alg_hom).mpr f.surjective, ← root_set,
      adjoin_root_set_eq_range (splits F p), root_set, adjoin_roots F p]
simp [separable]
rw [separable_def, derivative_add, derivative_X, derivative_C, add_zero]
exact is_coprime_one_right
rw [separable_def, derivative_X]
exact is_coprime_one_right
rw [separable_def, derivative_C, is_coprime_zero_right, is_unit_C]
have := h.of_mul_left_left
rw [derivative_mul] at this
exact IsCoprime.of_mul_right_left (IsCoprime.of_add_mul_left_right this)
rw [mul_comm] at h
exact h.of_mul_left
have := h.of_mul_left_left
rw [derivative_mul] at this
exact IsCoprime.of_mul_right_right (IsCoprime.of_add_mul_left_right this)
rw [pow_succ, pow_succ] at h
exact Or.inl (is_coprime_self.1 h.is_coprime.of_mul_right_left)
rw [derivative_map, ← Polynomial.map_mul, ← Polynomial.map_mul, ← Polynomial.map_add, H,
      Polynomial.map_one]
rw [multiplicity.squarefree_iff_multiplicity_le_one p]
intro f
rw [separable_def, derivative_mul]
exact
    ((hf.mul_right h).add_mul_left_right _).mul_left ((h.symm.mul_right hg).mul_add_right_right _)
simp only [Units.inv_mul, hn', C.map_one, mul_one, ← pow_succ,
        Nat.sub_add_cancel (show 1 ≤ n from hpos), sub_add_cancel]
rw [count_roots p]
exact root_multiplicity_le_one_of_separable hsep x
rw [← prod_attach]
exact
      separable_prod'
        (fun x hx y hy hxy =>
          @pairwise_coprime_X_sub_C _ _ { x // x ∈ s } (fun x => f x)
            (fun x y hxy => Subtype.eq <| H x.1 x.2 y.1 y.2 hxy) _ _ hxy)
        fun _ _ => separable_X_sub_C
rw [separable_iff_derivative_ne_zero hf, not_not, H]
intro this
rw [this, zero_mul] at hg1
cases hg1
rw [← mul_one g.nat_degree, ← hg1]
exact Nat.mul_lt_mul_of_pos_left hp.one_lt hg2.bot_lt
rw [derivative_expand, Nat.cast_pow, CharP.cast_eq_zero, zero_pow hn.bot_lt, zero_mul, mul_zero]
rw [minpoly.eq_X_sub_C']
exact separable_X_sub_C
let s := ((minpoly K pb.gen).map (algebraMap K L)).roots.toFinset
have H := fun x => Multiset.mem_to_finset
rw [Fintype.card_congr pb.lift_equiv', Fintype.card_of_subtype s H, ← pb.nat_degree_minpoly,
    nat_degree_eq_card_roots h_splits, Multiset.to_finset_card_of_nodup]
exact nodup_roots ((separable_map (algebraMap K L)).mpr h_sep)
delta minpoly
rw [dif_pos hx]
exact (WellFounded.min_mem degree_lt_wf _ hx).1
simp
apply WithBot.coe_le_coe.1
rw [← degree_eq_nat_degree (NeZero (@is_integral_algebra_map A B _ _ _ a)), WithTop.coe_one, ←
      degree_X_sub_C a]
refine' min A (algebraMap A B a) (monic_X_sub_C a) _
simp only [aeval_C, aeval_X, AlgHom.map_sub, sub_self]
apply (degree_eq_iff_nat_degree_eq (NeZero (@is_integral_algebra_map A B _ _ _ a))).2
apply le_antisymm hdegle (nat_degree_pos (@is_integral_algebra_map A B _ _ _ a))
apply Nat.pos_of_ne_zero
intro h
have h₁ := eq_C_of_nat_degree_eq_zero h
rw [← h, ← leading_coeff, monic.def.1 hbmonic, C_1] at h₁
rw [h₁] at hb_nunit
have := isUnit_one
contradiction
rw [← monic.def.1 (monic hx), ← hab_eq]
simp only [leading_coeff_mul]
rw [monic.def]
simp only [coeff_prod, leading_coeff_mul, leading_coeff_C]
rw [monic.def, mul_comm]
simp only [coeff_prod, leading_coeff_mul, leading_coeff_C]
simp only [RingHom.map_mul]
rw [coeff_prod, C_1, mul_one]
simp [hp]
simp [hp]
rw [← is_algebraic_iff_is_integral]
exact ⟨p, hp0, hp⟩
refine' minpoly.dvd K x _
rw [aeval_map_algebra_map, minpoly.aeval]
rw [h, aeval_algebra_map_apply, minpoly.aeval, RingHom.map_zero]
rw [mem_roots_map (minpoly.ne_zero_of_finite_field_extension F x.val), Subtype.val_eq_coe, ←
      aeval_def, aeval_alg_hom_apply, minpoly.aeval, map_zero]
refine' (eq_of_irreducible_of_monic _ _ _).symm
·
    exact
      (Polynomial.IsPrimitive.irreducible_iff_irreducible_map_fraction_map
            (Polynomial.Monic.is_primitive (monic hs))).1
        (Irreducible hs)
· rw [aeval_map_algebra_map, aeval_algebra_map_apply, aeval, map_zero]
· exact (monic hs).map _
let L := FractionRing S
rw [← gcd_domain_eq_field_fractions K L hs]
refine'
    minpoly.eq_of_algebra_map_eq (IsFractionRing.injective S L) (is_integral_of_is_scalar_tower hs)
      rfl
exact dvd_trans this (prim_part_dvd _)
  apply
    (is_primitive.dvd_iff_fraction_map_dvd_fraction_map K (monic hs).IsPrimitive
        P.is_primitive_prim_part).2
simp [hP]
simp [h, aeval A x]
cases hx <;> cases hx <;> cases hx <;> assumption
rw [map_div₀, RingHom.map_neg, ← coeff_map, ← coeff_map, p_linear]
simp [mul_sub, coeff_C, mul_div_cancel_left β (mt leading_coeff_eq_zero.mp h_ne_zero)]
apply eval_gcd_eq_zero
·
      rw [eval_comp, eval_sub, eval_mul, eval_C, eval_C, eval_X, eval_map, ← aeval_def, ←
        Algebra.smul_def, add_sub_cancel, minpoly.aeval]
· rw [eval_map, ← aeval_def, minpoly.aeval]
have f_root := root_left_of_root_gcd hx
rw [eval₂_comp, eval₂_sub, eval₂_mul, eval₂_C, eval₂_C, eval₂_X, eval₂_map] at f_root
exact (mem_roots_map (minpoly.ne_zero hα)).mpr f_root
rw [mem_roots_map (minpoly.ne_zero hβ), ← eval₂_map]
exact root_right_of_root_gcd hx
rw [← Cardinal.lift_inj, ← (basis_monomials σ K).mk_eq_dim]
rw [← mul_self_inj_of_nonneg dist_nonneg dist_nonneg, ←
    mul_self_inj_of_nonneg dist_nonneg dist_nonneg,
    dist_sq_eq_dist_orthogonal_projection_sq_add_dist_orthogonal_projection_sq p3 hp1,
    dist_sq_eq_dist_orthogonal_projection_sq_add_dist_orthogonal_projection_sq p3 hp2]
simp
simp
intro i
rw [dist_comm]
exact dist_circumcenter_eq_circumradius _ _
have h := s.circumsphere_unique_dist_eq.2 ⟨p, r⟩
simp only [hp, hr, forall_const, eq_self_iff_true, subset_sphere, sphere.ext_iff,
    Set.forall_range_iff, mem_sphere, true_and_iff] at h
exact h.1
have h := s.circumsphere_unique_dist_eq.2 ⟨p, r⟩
simp only [hp, hr, forall_const, eq_self_iff_true, subset_sphere, sphere.ext_iff,
    Set.forall_range_iff, mem_sphere, true_and_iff] at h
exact h.2
decide
have h := s.circumcenter_mem_affine_span
rw [Set.range_unique, mem_affine_span_singleton] at h
rw [h]
congr
refine' s.circumsphere_unique_dist_eq.2 _ ⟨_, _⟩ <;> rw [← s.reindex_range_points e]
· exact (s.reindex e).circumsphere_unique_dist_eq.1.1
· exact (s.reindex e).circumsphere_unique_dist_eq.1.2
rw [PseudoMetricSpace.dist_comm p2 _, dist_eq_norm_vsub V p1 _, dist_eq_norm_vsub V p1 _,
    dist_eq_norm_vsub V _ p2, ← vsub_add_vsub_cancel p1 (s.orthogonal_projection_span p2) p2,
    norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero]
exact
    Submodule.inner_right_of_mem_orthogonal (vsub_orthogonal_projection_mem_direction p2 hp1)
      (orthogonal_projection_vsub_mem_direction_orthogonal _ p2)
rw [dist_comm, ← h₁ 0,
    s.dist_sq_eq_dist_orthogonal_projection_sq_add_dist_orthogonal_projection_sq p₁ h]
simp only [h₁', dist_comm p₁, add_sub_cancel', simplex.dist_circumcenter_eq_circumradius]
injection h
simp [point_weights_with_circumcenter]
simp [h]
  -- Making the next line a separate definition helps the elaborator:
apply eq_orthogonal_projection_of_eq_subspace
simp
refine'
      sx.independent.affine_span_eq_of_le_of_card_eq_finrank_add_one
        (span_points_subset_coe_of_subset_coe (hsxps.trans h)) _
simp [hd]
refine'
      sx.independent.affine_span_eq_of_le_of_card_eq_finrank_add_one
        (span_points_subset_coe_of_subset_coe (hsxps.trans h)) _
simp [hd]
subst hp₁
exact s.coe_orthogonal_projection_vadd_smul_vsub_orthogonal_projection hp₁o
subst hp₂
exact s.coe_orthogonal_projection_vadd_smul_vsub_orthogonal_projection hp₂o
simp [hx12]
simp [hx32]
simp [oangle]
simp [oangle]
rw [← @vsub_ne_zero V]
exact o.left_ne_zero_of_oangle_ne_zero h
rw [← @vsub_ne_zero V]
exact o.right_ne_zero_of_oangle_ne_zero h
rw [← (vsub_left_injective p₂).ne_iff]
exact o.ne_of_oangle_ne_zero h
decide
decide
decide
decide
decide
decide
rw [← not_iff_not, not_or, oangle_ne_zero_and_ne_pi_iff_affine_independent,
    affine_independent_iff_not_collinear_set]
rw [AffineSubspace.affine_span_pair_parallel_iff_vector_span_eq] at h₁₂₄₅ h₃₂₆₅
exact two_zsmul_oangle_of_vector_span_eq h₁₂₄₅ h₃₂₆₅
rw [angle, ← InnerProductGeometry.inner_eq_zero_iff_angle_eq_pi_div_two]
exact o.inner_eq_zero_of_oangle_eq_pi_div_two h
rw [angle_comm]
exact angle_eq_pi_div_two_of_oangle_eq_pi_div_two h
rw [angle, ← InnerProductGeometry.inner_eq_zero_iff_angle_eq_pi_div_two]
exact o.inner_eq_zero_of_oangle_eq_neg_pi_div_two h
rw [angle_comm]
exact angle_eq_pi_div_two_of_oangle_eq_neg_pi_div_two h
rw [oangle_rev, Real.Angle.sign_neg, neg_neg]
rw [oangle_swap₁₃_sign, ← oangle_swap₁₂_sign, oangle_swap₁₃_sign]
rw [← oangle_swap₁₂_sign, oangle_swap₁₃_sign]
rw [oangle_eq_pi_iff_angle_eq_pi, angle_eq_pi_iff_sbtw]
rw [oangle_eq_pi_iff_oangle_rev_eq_pi, ← h.oangle₁₂₃_eq_pi]
rw [oangle_eq_zero_iff_oangle_rev_eq_zero, h.oangle₂₁₃_eq_zero]
rw [oangle_rev, h.oangle_eq_left hp₃p₂, ← oangle_rev]
rw [midpoint_comm, oangle_midpoint_left]
rw [midpoint_comm, oangle_midpoint_right]
rw [← h.oangle₁₂₃_eq_pi, oangle_add_swap h.left_ne h.right_ne hp₃p₂]
rw [← h.oangle₃₂₁_eq_pi, oangle_add hp₁p₂ h.right_ne h.left_ne]
rw [h₁.oangle_eq_add_pi_left h₃.left_ne, h₃.oangle_eq_add_pi_right h₁.right_ne, add_assoc,
    Real.Angle.coe_pi_add_coe_pi, add_zero]
rw [oangle_rev, smul_neg, h.two_zsmul_oangle_eq_left hp₃p₂ hp₃'p₂, ← smul_neg, ← oangle_rev]
refine' (Complex.continuous_at_arg_coe_angle _).comp _
· exact o.kahler_ne_zero hx1 hx2
exact
    ((continuous_of_real.comp continuous_inner).add
        ((continuous_of_real.comp o.area_form'.continuous₂).mul continuous_const)).ContinuousAt
simp [oangle]
simp [oangle]
decide
decide
decide
decide
decide
decide
simp only [oangle, o.kahler_swap y x, Complex.arg_conj_coe_angle]
simp [o.oangle_rev y x]
simp [oangle]
rw [← neg_neg y, oangle_neg_neg, neg_neg]
simp [oangle_neg_left, hx]
simp [oangle_neg_right, hx]
rw [oangle_neg_left_eq_neg_right, oangle_rev, add_left_neg]
rw [o.oangle_rev (-x), oangle_neg_left_eq_neg_right, add_neg_self]
simp [oangle, Complex.arg_real_mul _ hr]
simp [oangle, Complex.arg_real_mul _ hr]
rw [← neg_neg r, neg_smul, ← smul_neg, o.oangle_smul_left_of_pos _ _ (neg_pos_of_neg hr)]
rw [← neg_neg r, neg_smul, ← smul_neg, o.oangle_smul_right_of_pos _ _ (neg_pos_of_neg hr)]
rw [o.two_zsmul_oangle_left_of_span_eq y hwx, o.two_zsmul_oangle_right_of_span_eq x hyz]
rw [oangle_rev, neg_eq_zero]
rw [oangle_rev, neg_eq_iff_neg_eq, eq_comm, Real.Angle.neg_coe_pi]
rw [← o.oangle_eq_zero_iff_same_ray]
constructor
· intro h
rw [oangle_eq_zero_iff_same_ray, oangle_eq_pi_iff_same_ray_neg,
    same_ray_or_ne_zero_and_same_ray_neg_iff_not_linear_independent]
rw [← not_or, ← not_iff_not, not_not, oangle_eq_zero_or_eq_pi_iff_not_linear_independent]
rw [add_comm, o.oangle_add hx hy hz]
rw [sub_eq_iff_eq_add, o.oangle_add_swap hx hy hz]
rw [sub_eq_iff_eq_add, o.oangle_add hx hy hz]
simp [hx, hy, hz]
simp [oangle, h]
simp
rw [← rotation_rotation, LinearIsometryEquiv.trans_apply]
rw [← o.rotation_pi_apply, rotation_rotation]
rw [neg_rotation, ← Real.Angle.coe_add, neg_div, ← sub_eq_add_neg, sub_half]
simp [hx]
simp [hx]
rw [oangle_rev]
simp
rw [← o.rotation_eq_self_iff_angle_eq_zero hx, eq_comm]
rw [← rotation_eq_self_iff, eq_comm]
constructor
· intro h
    rw [← h, LinearIsometryEquiv.norm_map]
· intro h
    rw [o.eq_iff_oangle_eq_zero_of_norm_eq] <;> simp [h]
simp only [oangle, o.linear_isometry_equiv_comp_right_angle_rotation f hd,
      o.kahler_comp_right_angle_rotation]
simp [oangle, o.kahler_map]
simp [oangle]
rw [← Complex.oangle, ← hf, o.oangle_map]
simp
simp [oangle]
simp [rotation_apply, o.right_angle_rotation_map]
rw [← Complex.rotation, ← hf, o.rotation_map]
simp
simp [rotation_apply]
rw [o.cos_oangle_eq_inner_div_norm_mul_norm hx hy, InnerProductGeometry.cos_angle]
intro hpi
rw [div_eq_iff, eq_comm, ← sub_eq_zero, mul_two, add_sub_cancel] at hpi
· exact real.pi_pos.ne.symm hpi
· exact two_ne_zero
refine' ⟨fun h => o.oangle_eq_of_angle_eq_of_sign_eq h hs, fun h => _⟩
rw [o.angle_eq_abs_oangle_to_real hw hx, o.angle_eq_abs_oangle_to_real hy hz, h]
rw [real_inner_comm, o.inner_eq_zero_of_oangle_eq_pi_div_two h]
rw [real_inner_comm, o.inner_eq_zero_of_oangle_eq_neg_pi_div_two h]
rw [rotation_pi_div_two, inner_right_angle_rotation_self]
rw [real_inner_comm, inner_rotation_pi_div_two_left]
rw [inner_smul_left, inner_rotation_pi_div_two_left, mul_zero]
rw [real_inner_comm, inner_smul_rotation_pi_div_two_left]
rw [inner_smul_right, inner_rotation_pi_div_two_left, mul_zero]
rw [real_inner_comm, inner_rotation_pi_div_two_left_smul]
rw [inner_smul_right, inner_smul_rotation_pi_div_two_left, mul_zero]
rw [real_inner_comm, inner_smul_rotation_pi_div_two_smul_left]
rw [sub_eq_add_neg, ← neg_smul, add_comm, oangle_sign_smul_add_right]
rw [sub_eq_add_neg, ← neg_smul, oangle_sign_add_smul_left]
rw [← o.oangle_sign_smul_add_right x y 1, one_smul]
rw [← o.oangle_sign_add_smul_left x y 1, one_smul]
rw [← o.oangle_sign_sub_smul_right x y 1, one_smul]
rw [← o.oangle_sign_sub_smul_left x y 1, one_smul]
rw [← oangle_sign_neg_right, sub_eq_add_neg, oangle_sign_smul_add_right]
rw [← oangle_sign_neg_left, sub_eq_neg_add, oangle_sign_add_smul_left]
rw [← o.oangle_sign_smul_sub_right x y 1, one_smul]
rw [← o.oangle_sign_smul_sub_left x y 1, one_smul]
rw [oangle_sign_sub_right_eq_neg, o.oangle_rev y x, Real.Angle.sign_neg]
rw [oangle_sign_sub_left_eq_neg, o.oangle_rev y x, Real.Angle.sign_neg]
simp [hx12]
simp [hx32]
unfold angle
rw [vsub_self]
exact angle_zero_left _
rw [angle_comm, angle_eq_left]
rw [angle_comm] at h
exact angle_eq_zero_of_angle_eq_pi_left h
unfold angle at h
rw [angle_comm p1 p3 p2, angle_comm p1 p3 p4]
unfold angle
exact angle_add_angle_eq_pi_of_angle_eq_pi _ h
rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, dist_eq_norm_vsub V, ← vsub_sub_vsub_cancel_right]
exact norm_sub_eq_add_norm_of_angle_eq_pi h
rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, dist_eq_norm_vsub V, ← vsub_sub_vsub_cancel_right]
exact
    norm_sub_eq_add_norm_iff_angle_eq_pi (fun he => hp1p2 (vsub_eq_zero_iff_eq.1 he)) fun he =>
      hp3p2 (vsub_eq_zero_iff_eq.1 he)
rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, dist_eq_norm_vsub V, ← vsub_sub_vsub_cancel_right]
exact norm_sub_eq_abs_sub_norm_of_angle_eq_zero h
rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, dist_eq_norm_vsub V, ← vsub_sub_vsub_cancel_right]
exact
    norm_sub_eq_abs_sub_norm_iff_angle_eq_zero (fun he => hp1p2 (vsub_eq_zero_iff_eq.1 he))
      fun he => hp3p2 (vsub_eq_zero_iff_eq.1 he)
rw [neg_vsub_eq_vsub_rev]
simp
rw [left_vsub_midpoint, ← midpoint_vsub_right, vsub_add_vsub_cancel]
rw [midpoint_comm p1 p2, angle_left_midpoint_eq_pi_div_two_of_dist_eq h.symm]
rw [← h.angle₁₂₃_eq_pi, angle_comm]
rw [← h.angle₂₁₃_eq_zero_of_ne hp₂p₁, angle_comm]
rw [angle_eq_zero_iff_ne_and_wbtw]
simp [hx1, hx2]
rw [angle, angle, f.inner_map_map, f.norm_map, f.norm_map]
unfold angle
rw [real_inner_comm, mul_comm]
unfold angle
rw [inner_neg_neg, norm_neg, norm_neg]
unfold angle
rw [← Real.arccos_neg, norm_neg, inner_neg_right, neg_div]
rw [← angle_neg_neg, neg_neg, angle_neg_right]
unfold angle
rw [inner_zero_left, zero_div, Real.arccos_zero]
unfold angle
rw [inner_zero_right, zero_div, Real.arccos_zero]
unfold angle
rw [← real_inner_self_eq_norm_mul_norm, div_self fun h => hx (inner_self_eq_zero.1 h),
    Real.arccos_one]
rw [angle_neg_right, angle_self hx, sub_zero]
rw [angle_comm, angle_self_neg_of_nonzero hx]
unfold angle
rw [inner_smul_right, norm_smul, Real.norm_eq_abs, abs_of_nonneg (le_of_lt hr), ← mul_assoc,
    mul_comm _ r, mul_assoc, mul_div_mul_left _ _ (ne_of_gt hr)]
rw [angle_comm, angle_smul_right_of_pos y x hr, angle_comm]
rw [← neg_neg r, neg_smul, angle_neg_right, angle_smul_right_of_pos x y (neg_pos_of_neg hr),
    angle_neg_right]
rw [angle_comm, angle_smul_right_of_neg y x hr, angle_comm]
rw [cos_angle, div_mul_cancel_of_imp]
simp (config := { contextual := true }) [or_imp]
unfold angle
rw [Real.sin_arccos, ← Real.sqrt_mul_self (mul_nonneg (norm_nonneg x) (norm_nonneg y)), ←
    Real.sqrt_mul' _ (mul_self_nonneg _), sq,
    Real.sqrt_mul_self (mul_nonneg (norm_nonneg x) (norm_nonneg y)),
    real_inner_self_eq_norm_mul_norm, real_inner_self_eq_norm_mul_norm]
rw [angle, ← real_inner_div_norm_mul_norm_eq_one_iff, Real.arccos_eq_zero, LE.le.le_iff_eq,
    eq_comm]
exact (abs_le.mp (abs_real_inner_div_norm_mul_norm_le_one x y)).2
rw [angle, ← real_inner_div_norm_mul_norm_eq_neg_one_iff, Real.arccos_eq_pi, LE.le.le_iff_eq]
exact (abs_le.mp (abs_real_inner_div_norm_mul_norm_le_one x y)).1
simp (config := { contextual := true }) [angle, or_imp]
simp [← cos_angle_mul_norm_mul_norm, h]
simp [← cos_angle_mul_norm_mul_norm, h]
rw [norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero]
exact inner_eq_zero_iff_angle_eq_pi_div_two x y
rw [norm_sub_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero]
exact inner_eq_zero_iff_angle_eq_pi_div_two x y
rw [angle, inner_add_right, h, add_zero, real_inner_self_eq_norm_mul_norm]
rw [angle_add_eq_arccos_of_inner_eq_zero h, Real.arccos_pos,
    norm_add_eq_sqrt_iff_real_inner_eq_zero.2 h]
rw [angle_add_eq_arccos_of_inner_eq_zero h, Real.arccos_le_pi_div_two]
exact div_nonneg (norm_nonneg _) (norm_nonneg _)
rw [angle_add_eq_arccos_of_inner_eq_zero h, Real.arccos_lt_pi_div_two,
    norm_add_eq_sqrt_iff_real_inner_eq_zero.2 h]
exact
    div_pos (norm_pos_iff.2 h0)
      (Real.sqrt_pos.2
        (Left.add_pos_of_pos_of_nonneg (mul_self_pos.2 (norm_ne_zero_iff.2 h0))
          (mul_self_nonneg _)))
rw [cos_angle_add_of_inner_eq_zero h]
rw [← neg_eq_zero, ← inner_neg_right] at h
rw [sub_eq_add_neg, angle_add_eq_arccos_of_inner_eq_zero h]
rw [← neg_eq_zero, ← inner_neg_right] at h
rw [sub_eq_add_neg, angle_add_eq_arctan_of_inner_eq_zero h h0, norm_neg]
rw [← neg_eq_zero, ← inner_neg_right] at h
rw [← neg_ne_zero] at h0
rw [sub_eq_add_neg]
exact angle_add_pos_of_inner_eq_zero h h0
rw [← neg_eq_zero, ← inner_neg_right] at h
rw [sub_eq_add_neg]
exact angle_add_le_pi_div_two_of_inner_eq_zero h
rw [← neg_eq_zero, ← inner_neg_right] at h
rw [sub_eq_add_neg]
exact angle_add_lt_pi_div_two_of_inner_eq_zero h h0
rw [← neg_eq_zero, ← inner_neg_right] at h
rw [sub_eq_add_neg, cos_angle_add_of_inner_eq_zero h]
rw [← neg_eq_zero, ← inner_neg_right] at h
rw [sub_eq_add_neg, tan_angle_add_of_inner_eq_zero h, norm_neg]
rw [← neg_eq_zero, ← inner_neg_right] at h
rw [sub_eq_add_neg, cos_angle_add_mul_norm_of_inner_eq_zero h]
rw [← neg_eq_zero, ← inner_neg_right] at h
rw [sub_eq_add_neg, sin_angle_add_mul_norm_of_inner_eq_zero h, norm_neg]
rw [← neg_eq_zero, ← inner_neg_right] at h
rw [← neg_eq_zero] at h0
rw [sub_eq_add_neg, tan_angle_add_mul_norm_of_inner_eq_zero h h0, norm_neg]
rw [← neg_eq_zero, ← inner_neg_right] at h
rw [← neg_eq_zero] at h0
rw [sub_eq_add_neg, norm_div_cos_angle_add_of_inner_eq_zero h h0]
rw [← neg_eq_zero, ← inner_neg_right] at h
rw [← neg_ne_zero] at h0
rw [sub_eq_add_neg, ← norm_neg, norm_div_sin_angle_add_of_inner_eq_zero h h0]
rw [← neg_eq_zero, ← inner_neg_right] at h
rw [← neg_ne_zero] at h0
rw [sub_eq_add_neg, ← norm_neg, norm_div_tan_angle_add_of_inner_eq_zero h h0]
erw [dist_comm p3 p2, dist_eq_norm_vsub V p1 p3, dist_eq_norm_vsub V p1 p2,
    dist_eq_norm_vsub V p2 p3, ← norm_sub_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two,
    vsub_sub_vsub_cancel_right p1, ← neg_vsub_eq_vsub_rev p2 p3, norm_neg]
rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, ← neg_eq_zero, ←
    inner_neg_left, neg_vsub_eq_vsub_rev] at h
rw [angle, dist_eq_norm_vsub' V p₃ p₂, dist_eq_norm_vsub V p₁ p₃, ← vsub_add_vsub_cancel p₁ p₂ p₃,
    add_comm, angle_add_eq_arccos_of_inner_eq_zero h]
rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, ← neg_eq_zero, ←
    inner_neg_left, neg_vsub_eq_vsub_rev] at h
rw [← @vsub_ne_zero V, @ne_comm _ p₃, ← @vsub_ne_zero V _ _ _ p₂, or_comm'] at h0
rw [angle, dist_eq_norm_vsub V p₁ p₂, dist_eq_norm_vsub V p₁ p₃, ← vsub_add_vsub_cancel p₁ p₂ p₃,
    add_comm, angle_add_eq_arcsin_of_inner_eq_zero h h0]
rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, ← neg_eq_zero, ←
    inner_neg_left, neg_vsub_eq_vsub_rev] at h
rw [ne_comm, ← @vsub_ne_zero V] at h0
rw [angle, dist_eq_norm_vsub V p₁ p₂, dist_eq_norm_vsub' V p₃ p₂, ← vsub_add_vsub_cancel p₁ p₂ p₃,
    add_comm, angle_add_eq_arctan_of_inner_eq_zero h h0]
rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, ← neg_eq_zero, ←
    inner_neg_left, neg_vsub_eq_vsub_rev] at h
rw [← @vsub_ne_zero V, eq_comm, ← @vsub_eq_zero_iff_eq V, or_comm'] at h0
rw [angle, ← vsub_add_vsub_cancel p₁ p₂ p₃, add_comm]
exact angle_add_pos_of_inner_eq_zero h h0
rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, ← neg_eq_zero, ←
    inner_neg_left, neg_vsub_eq_vsub_rev] at h
rw [angle, ← vsub_add_vsub_cancel p₁ p₂ p₃, add_comm]
exact angle_add_le_pi_div_two_of_inner_eq_zero h
rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, ← neg_eq_zero, ←
    inner_neg_left, neg_vsub_eq_vsub_rev] at h
rw [ne_comm, ← @vsub_ne_zero V] at h0
rw [angle, ← vsub_add_vsub_cancel p₁ p₂ p₃, add_comm]
exact angle_add_lt_pi_div_two_of_inner_eq_zero h h0
rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, ← neg_eq_zero, ←
    inner_neg_left, neg_vsub_eq_vsub_rev] at h
rw [angle, dist_eq_norm_vsub' V p₃ p₂, dist_eq_norm_vsub V p₁ p₃, ← vsub_add_vsub_cancel p₁ p₂ p₃,
    add_comm, cos_angle_add_of_inner_eq_zero h]
rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, ← neg_eq_zero, ←
    inner_neg_left, neg_vsub_eq_vsub_rev] at h
rw [← @vsub_ne_zero V, @ne_comm _ p₃, ← @vsub_ne_zero V _ _ _ p₂, or_comm'] at h0
rw [angle, dist_eq_norm_vsub V p₁ p₂, dist_eq_norm_vsub V p₁ p₃, ← vsub_add_vsub_cancel p₁ p₂ p₃,
    add_comm, sin_angle_add_of_inner_eq_zero h h0]
rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, ← neg_eq_zero, ←
    inner_neg_left, neg_vsub_eq_vsub_rev] at h
rw [angle, dist_eq_norm_vsub V p₁ p₂, dist_eq_norm_vsub' V p₃ p₂, ← vsub_add_vsub_cancel p₁ p₂ p₃,
    add_comm, tan_angle_add_of_inner_eq_zero h]
rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, ← neg_eq_zero, ←
    inner_neg_left, neg_vsub_eq_vsub_rev] at h
rw [angle, dist_eq_norm_vsub' V p₃ p₂, dist_eq_norm_vsub V p₁ p₃, ← vsub_add_vsub_cancel p₁ p₂ p₃,
    add_comm, cos_angle_add_mul_norm_of_inner_eq_zero h]
rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, ← neg_eq_zero, ←
    inner_neg_left, neg_vsub_eq_vsub_rev] at h
rw [angle, dist_eq_norm_vsub V p₁ p₂, dist_eq_norm_vsub V p₁ p₃, ← vsub_add_vsub_cancel p₁ p₂ p₃,
    add_comm, sin_angle_add_mul_norm_of_inner_eq_zero h]
rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, ← neg_eq_zero, ←
    inner_neg_left, neg_vsub_eq_vsub_rev] at h
rw [ne_comm, ← @vsub_ne_zero V, ← @vsub_eq_zero_iff_eq V, or_comm'] at h0
rw [angle, dist_eq_norm_vsub V p₁ p₂, dist_eq_norm_vsub' V p₃ p₂, ← vsub_add_vsub_cancel p₁ p₂ p₃,
    add_comm, tan_angle_add_mul_norm_of_inner_eq_zero h h0]
rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, ← neg_eq_zero, ←
    inner_neg_left, neg_vsub_eq_vsub_rev] at h
rw [ne_comm, ← @vsub_ne_zero V, ← @vsub_eq_zero_iff_eq V, or_comm'] at h0
rw [angle, dist_eq_norm_vsub' V p₃ p₂, dist_eq_norm_vsub V p₁ p₃, ← vsub_add_vsub_cancel p₁ p₂ p₃,
    add_comm, norm_div_cos_angle_add_of_inner_eq_zero h h0]
rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, ← neg_eq_zero, ←
    inner_neg_left, neg_vsub_eq_vsub_rev] at h
rw [eq_comm, ← @vsub_ne_zero V, ← @vsub_eq_zero_iff_eq V, or_comm'] at h0
rw [angle, dist_eq_norm_vsub V p₁ p₂, dist_eq_norm_vsub V p₁ p₃, ← vsub_add_vsub_cancel p₁ p₂ p₃,
    add_comm, norm_div_sin_angle_add_of_inner_eq_zero h h0]
rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, ← neg_eq_zero, ←
    inner_neg_left, neg_vsub_eq_vsub_rev] at h
rw [eq_comm, ← @vsub_ne_zero V, ← @vsub_eq_zero_iff_eq V, or_comm'] at h0
rw [angle, dist_eq_norm_vsub V p₁ p₂, dist_eq_norm_vsub' V p₃ p₂, ← vsub_add_vsub_cancel p₁ p₂ p₃,
    add_comm, norm_div_tan_angle_add_of_inner_eq_zero h h0]
rw [o.oangle_eq_pi_sub_two_zsmul_oangle_sub_of_norm_eq hxzne.symm hxz.symm,
        o.oangle_eq_pi_sub_two_zsmul_oangle_sub_of_norm_eq hxyne.symm hxy.symm]
rw [o.oangle_sub_right (sub_ne_zero_of_ne hxyne) (sub_ne_zero_of_ne hxzne) hx]
rw [← oangle_neg_neg, neg_sub, neg_sub]
rw [mem_sphere, @dist_eq_norm_vsub V] at hp₁ hp₂ hp₃
rw [oangle, oangle, o.oangle_eq_two_zsmul_oangle_sub_of_norm_eq_real _ _ hp₂ hp₁ hp₃] <;>
    simp [hp₂p₁, hp₂p₃]
rw [mem_sphere, @dist_eq_norm_vsub V] at hp₁ hp₂ hp₃ hp₄
rw [oangle, oangle, ← vsub_sub_vsub_cancel_right p₁ p₂ s.center, ←
      vsub_sub_vsub_cancel_right p₄ p₂ s.center,
      o.two_zsmul_oangle_sub_eq_two_zsmul_oangle_sub_of_norm_eq _ _ _ _ hp₂ hp₃ hp₁ hp₄] <;>
    simp [hp₂p₁, hp₂p₄, hp₃p₁, hp₃p₄]
rw [monge_point_eq_smul_vsub_vadd_circumcenter,
    centroid_eq_affine_combination_of_points_with_circumcenter,
    circumcenter_eq_affine_combination_of_points_with_circumcenter, affine_combination_vsub, ←
    LinearMap.map_smul, weighted_vsub_vadd_affine_combination]
congr
decide
decide
simp [card_compl, Fintype.card_fin, h]
simp
rw [monge_plane_def, direction_inf_of_mem_inf s.monge_point_mem_monge_plane, direction_mk',
    direction_affine_span]
intro i₂ hne
rw [← s.direction_monge_plane, vsub_right_mem_direction_iff_mem s.monge_point_mem_monge_plane]
exact h i₂ hne
rw [Submodule.mem_infi]
exact fun i => (Submodule.mem_inf.1 (h' i i.property)).1
simp [card_erase_of_mem]
rw [altitude_def,
    direction_inf_of_mem (self_mem_mk' (s.points i) _) (mem_affine_span ℝ (Set.mem_range_self _)),
    direction_mk', direction_affine_span, direction_affine_span]
rw [direction_altitude]
infer_instance
rw [card_erase_of_mem (mem_univ _)]
simp
rw [← h, finrank_bot]
refine' span_points_subset_coe_of_subset_coe _
rw [Set.insert_subset, Set.singleton_subset_iff]
exact ⟨t.orthocenter_mem_altitude, t.mem_altitude i⟩
refine' (triangle.eq_orthocenter_of_forall_mem_altitude hj₂₃ _ _).symm
· rw [altitude_replace_orthocenter_eq_affine_span hi₁₂ hi₁₃ hi₂₃ hj₁₂ hj₁₃ hj₂₃ h₁ h₂ h₃]
    exact mem_affine_span ℝ (Set.mem_insert _ _)
· rw [altitude_replace_orthocenter_eq_affine_span hi₁₃ hi₁₂ hi₂₃.symm hj₁₃ hj₁₂ hj₂₃.symm h₁ h₃
        h₂]
    exact mem_affine_span ℝ (Set.mem_insert _ _)
intro he
rw [he, h₃] at h₂
exact h₂₃.symm (hpi h₂)
rw [hts, affine_span_insert_eq_affine_span ℝ t.orthocenter_mem_affine_span]
rw [hs]
infer_instance
rw [hts]
exact Set.subset_insert _ _
refine' Real.inj_on_cos ⟨angle_nonneg _ _, angle_le_pi _ _⟩ ⟨angle_nonneg _ _, angle_le_pi _ _⟩ _
rw [cos_angle, cos_angle, h, ← neg_sub, norm_neg, neg_sub, inner_sub_right, inner_sub_right,
    real_inner_self_eq_norm_mul_norm, real_inner_self_eq_norm_mul_norm, h, real_inner_comm x y]
rw [add_assoc, Real.cos_add, cos_angle_sub_add_angle_sub_rev_eq_neg_cos_angle hx hy,
    sin_angle_sub_add_angle_sub_rev_eq_sin_angle hx hy, mul_neg, ← neg_add', add_comm, ← sq, ← sq,
    Real.sin_sq_add_cos_sq]
unfold angle at h hpi
rw [dist_eq_norm_vsub V p1 p2, dist_eq_norm_vsub V p1 p3]
rw [← angle_neg_neg, neg_vsub_eq_vsub_rev, neg_vsub_eq_vsub_rev] at hpi
rw [← vsub_sub_vsub_cancel_left p3 p2 p1, ← vsub_sub_vsub_cancel_left p2 p3 p1] at h
exact norm_eq_of_angle_sub_eq_angle_sub_rev_of_angle_ne_pi h hpi
simp [pow_two, law_cos a' b' c']
simp [pow_two, ← law_cos a b c, mul_pow]
rw [← dist_eq_zero, hab, dist_eq_zero.mpr hab₁, mul_zero r]
rw [← hab]
exact dist_nonneg
rw [dist_left_midpoint p1 p2, dist_right_midpoint p1 p2]
decide
simp [hp.symm]
simp [hp₂c₁]
rw [direction_top, finrank_top]
exact hd
rw [← mem_coe, ← Set.singleton_subset_iff, ← inter_eq_singleton_orthogonal_projection_fn]
exact Set.inter_subset_left _ _
rw [← mem_coe, ← Set.singleton_subset_iff, ← inter_eq_singleton_orthogonal_projection_fn]
exact Set.inter_subset_right _ _
rw [← vsub_right_mem_direction_iff_mem (self_mem_mk' _ _) _, direction_mk',
        vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, add_comm, add_sub_assoc]
refine' Submodule.add_mem _ (orthogonal_projection_fn_vsub_mem_direction_orthogonal p) _
rw [Submodule.mem_orthogonal']
intro w hw
rw [← neg_sub, inner_neg_left, orthogonal_projection_inner_eq_zero _ w hw, neg_zero]
rw [← orthogonal_projection_fn_eq]
exact inter_eq_singleton_orthogonal_projection_fn p
change orthogonalProjectionFn s p = orthogonalProjectionFn s' p
congr
exact h
rw [dist_comm, dist_eq_zero, orthogonal_projection_eq_self_iff]
apply orthogonal_projection_mem_subspace_orthogonal_complement_eq_zero
intro c hc
rw [← neg_vsub_eq_vsub_rev, inner_neg_right,
    orthogonal_projection_vsub_mem_direction_orthogonal s p c hc, neg_zero]
rw [dist_comm p2 _, dist_eq_norm_vsub V p1 _, dist_eq_norm_vsub V p1 _, dist_eq_norm_vsub V _ p2,
    ← vsub_add_vsub_cancel p1 (orthogonalProjection s p2) p2,
    norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero]
exact
    Submodule.inner_right_of_mem_orthogonal (vsub_orthogonal_projection_mem_direction p2 hp1)
      (orthogonal_projection_vsub_mem_direction_orthogonal s p2)
rw [dist_eq_norm_vsub V p1, abs_mul_abs_self, mul_assoc]
subst h
rw [vsub_vadd_eq_vsub_sub, vsub_self, zero_sub]
rw [reflection_apply]
have ho : ↑(orthogonalProjection s₁ p) ∈ s₂ := hle (orthogonal_projection_mem p)
exact vadd_mem_of_mem_direction (vsub_mem_direction ho hp) ho
rw [reflection_apply, orthogonal_projection_vadd_eq_self hp hv, vsub_vadd_eq_vsub_sub]
simp
rw [← not_and_or, ← sphere.ext_iff]
refine' ⟨fun h => sphere.ext _ _ h _, fun h => h ▸ rfl⟩
rw [mem_sphere] at hs₁ hs₂
rw [← hs₁, ← hs₂, h]
rw [mem_sphere.1 hp₁, mem_sphere.1 hp₂]
rw [mem_sphere'.1 hp₁, mem_sphere'.1 hp₂]
decide
intro i
rw [← hf]
exact hs' i
intro i j h
have hi := hf i
rw [h, ← hf j] at hi
exact hpi hi
decide
decide
decide
refine' hs.affine_independent _ _
· simp [h₁, h₂, h₃, Set.insert_subset]
· erw [Fin.cons_injective_iff, Fin.cons_injective_iff]
    simp [h₁₂, h₁₃, h₂₃, Function.Injective]
simp [inversion]
rw [dist_comm c, dist_comm c, dist_inversion_center]
rw [← smul_sub k x y]
rw [hxy, inner_smul_right, hzy, mul_zero]
simp [sub_smul, add_smul, hxy]
simp [abs_mul]
simp [hxy, norm_smul, mul_pow, sq_abs]
simp [norm_add_sq_real, norm_sub_sq_real, hzy, hzx, abs_sub_comm]
rw [midpoint_vsub_left, ← right_vsub_midpoint, add_comm, vsub_add_vsub_cancel]
rw [mul_left_comm, mul_comm]
cases a
cases b
dsimp at h
induction h
rfl
rw [restr_source, open_s.interior_eq]
exact ⟨hx, xs⟩
rw [hs]
simp
rw [← this]
exact inter_subset_right _ _
refine' eq_of_eq_on_source_univ (Setoid.symm he'e) _ _ <;>
            rw [Set.mem_singleton_iff.1 he] <;>
          rfl
constructor
· apply PG.comp he.1 he'.1 e.open_source e'.open_source
      apply e.continuous_to_fun.preimage_open_of_open e.open_source e'.open_source
· apply PG.comp he'.2 he.2 e'.open_target e.open_target
      apply e'.continuous_inv_fun.preimage_open_of_open e'.open_target e.open_target
refine' StructureGroupoid.le_iff.2 fun e he => _
rw [mem_groupoid_of_pregroupoid] at he⊢
exact ⟨h _ _ he.1, h _ _ he.2⟩
rw [← he'.1]
exact PG.congr e.open_source he'.eq_on.symm he
decide
simp only [mfld_simps]
simp only [mfld_simps]
rw [e.restr_source]
refine' ⟨hx, _⟩
rw [hs.interior_eq]
exact hxs
rfl
simp only [hs.interior_eq, mfld_simps]
simp only [mfld_simps]
simp [atlas, ChartedSpace.atlas]
intro x
rw [← (chart_at H x).symm_map_nhds_eq (mem_chart_source H x)]
exact
      ((compact_basis_nhds (chart_at H x x)).has_basis_self_subset (chart_target_mem_nhds H x)).map
        _
simp only [mfld_simps]
rw [prod_range_univ_eq]
apply TopologicalSpace.GenerateOpen.basic
simp only [exists_prop, mem_Union, mem_singleton_iff]
refine' ⟨e, he, univ, is_open_univ, _⟩
simp only [Set.univ_inter, Set.preimage_univ]
rw [← inter_assoc, ← inter_assoc]
congr 1
exact inter_comm _ _
simp only [mem_Union, mem_singleton_iff]
exact ⟨c.chart_at x, c.chart_mem_atlas x, rfl⟩
intro e e' he he'
rw [continuousGroupoid, mem_groupoid_of_pregroupoid]
simp only [and_self_iff]
apply e.symm.continuous_to_fun.preimage_open_of_open <;> apply open_source
dsimp at hx
simp [s, hx]
simp [trans_assoc]
simp [eq_on_source.trans', trans_self_symm]
simp [trans_assoc]
simp [s, trans_of_set']
simp [restr_trans]
simp
simp only [h, mfld_simps]
assumption
simp
simp
simp only [mfld_simps]
exact mem_chart_source H x.1
change LocalHomeomorph.symm c
constructor
· simp only [trans_source, preimage_univ, inter_univ, Homeomorph.to_local_homeomorph_source]
          rw [trans_source] at hx
          exact hx.1
· exact hg₂
simp [F₁, trans_assoc]
simp [eq_on_source.trans', trans_self_symm g]
simp [trans_assoc]
simp [s, trans_of_set']
simp [restr_trans]
simp [eq_on_source.restr, trans_assoc]
simp [F₂, feq]
simp only [mul_support_one_sub]
exact f.locally_finite
simp [h]
rw [ext_chart_at_source]
exact fs.mem_chart_at_source_of_eq_one h
simp [fs.apply_ind x hx]
simp only [this, ContMdiffMap.coe_fn_mk, finsum_zero, Pi.zero_apply]
infer_instance
infer_instance
simp
simp
simp [le_refl]
rw [Subtype.mk_eq_mk, update_eq_iff]
exact ⟨max_eq_left xprop, fun i _ => rfl⟩
simp only [le_refl, or_true_iff, le_max_iff]
simp [le_refl, z.prop, le_of_lt (Fact.out (x < y))]
simp only [imp_self, sub_lt_sub_iff_right, mem_set_of_eq, forall_true_iff]
apply Continuous.continuous_on
apply Continuous.subtype_mk
have : Continuous fun (z : ℝ) (i : Fin 1) => z - x :=
      Continuous.sub (continuous_pi fun i => continuous_id) continuous_const
exact this.comp continuous_subtype_val
apply Continuous.continuous_on
apply Continuous.subtype_mk
have A : Continuous fun z : ℝ => min (z + x) y :=
      (continuous_id.add continuous_const).min continuous_const
have B : Continuous fun z : EuclideanSpace ℝ (Fin 1) => z 0 := continuous_apply 0
exact (A.comp B).comp continuous_subtype_val
simp [le_refl, z.prop, le_of_lt (Fact.out (x < y)), sub_eq_add_neg]
simp only [imp_self, mem_set_of_eq, sub_lt_sub_iff_left, forall_true_iff]
apply Continuous.continuous_on
apply Continuous.subtype_mk
have : Continuous fun (z : ℝ) (i : Fin 1) => y - z :=
      continuous_const.sub (continuous_pi fun i => continuous_id)
exact this.comp continuous_subtype_val
apply Continuous.continuous_on
apply Continuous.subtype_mk
have A : Continuous fun z : ℝ => max (y - z) x :=
      (continuous_const.sub continuous_id).max continuous_const
have B : Continuous fun z : EuclideanSpace ℝ (Fin 1) => z 0 := continuous_apply 0
exact (A.comp B).comp continuous_subtype_val
rw [cont_diff_on_univ]
exact cont_diff_id.neg.add contDiffConst
infer_instance
infer_instance
apply ContinuousLinearMap.hasFderivAt
refine' (cont_diff_const.smul contDiffId).add _
refine' (h₀.sub contDiffConst).smul contDiffConst
simp [hv]
simp [inner_smul_left, hvy]
simp
simp [real_inner_self_eq_norm_mul_norm, hv]
simp [hv]
simp
simp
simp [hv]
simp [stereographic_apply, orthogonal_projection_orthogonal_complement_singleton_eq_zero]
simp [stereographic']
simp [stereographic']
simp [Subtype.ext_iff, inner_eq_norm_mul_iff_of_norm_one]
simp [real_inner_comm, stereographic, stereographic', ← Submodule.coe_norm]
apply ContMdiff.codRestrictSphere
apply cont_diff_neg.cont_mdiff.comp _
exact contMdiffCoeSphere
rw [cont_mdiff_iff]
exact ⟨continuous_mul, fun x y => cont_diff_mul.cont_diff_on⟩
apply ContMdiff.codRestrictSphere
simp only [← coe_inv_circle, coe_inv_circle_eq_conj]
exact complex.conj_cle.cont_diff.cont_mdiff.comp contMdiffCoeSphere
apply bot_unique
rw [←
    (mdifferentiableChart I (f.c (f.ind x hx))).ker_mfderiv_eq_bot (f.mem_chart_at_ind_source x hx),
    ← comp_embedding_pi_tangent_mfderiv]
exact LinearMap.ker_le_ker_comp _ _
simp only [f.eq_on_source hs, (· ∘ ·), f.to_cont_diff_bump.one_of_mem_closed_ball hd]
rw [coe_def, support_indicator, (· ∘ ·), support_comp_eq_preimage, ← ext_chart_at_source I, ←
    (extChartAt I c).symm_image_target_inter_eq', ← (extChartAt I c).symm_image_target_inter_eq',
    f.to_cont_diff_bump.support_eq]
rw [support_eq_inter_preimage]
exact is_open_ext_chart_at_preimage I c is_open_ball
rw [f.support_eq_inter_preimage, ← ext_chart_at_source I, ←
    (extChartAt I c).symm_image_target_inter_eq', inter_comm]
congr 1
rw [f.support_eq_inter_preimage, ← ext_chart_at_source I]
exact inter_subset_left _ _
rw [Euclidean.dist, dist_self]
exact f.r_pos
rw [hx]
exact one_ne_zero
rw [f.image_eq_inter_preimage_of_subset_support hs]
refine'
    ContinuousOn.preimage_closed_of_closed
      ((continuous_on_ext_chart_at_symm _ _).mono f.closed_ball_subset) _ hsc
exact IsClosed.inter is_closed_closed_ball I.closed_range
simp only [support_eq_inter_preimage, update_r_R]
rw [tsupport, support_eq_symm_image]
exact
    closure_minimal (image_subset _ <| inter_subset_inter_left _ ball_subset_closed_ball)
      f.is_closed_symm_image_closed_ball
rw [← map_ext_chart_at_symm_nhds_within_range I c]
exact nhds_within_range_basis.map _
refine' contMdiffOfSupport fun x hx => _
have : x ∈ (chart_at H c).source := f.tsupport_subset_chart_at_source hx
refine'
    ContMdiffAt.congrOfEventuallyEq _
      (f.eq_on_source.eventually_eq_of_mem <| IsOpen.mem_nhds (chart_at _ _).open_source this)
exact f.to_cont_diff_bump.cont_diff_at.cont_mdiff_at.comp _ (contMdiffAtExtChartAt' this)
rw [range_comp, image_eq_preimage]
simp only [hm, coe_to_equiv, symm_apply_apply, cont_mdiff_within_at_comp_diffeomorph_iff,
      mem_preimage]
simp only [← unique_mdiff_on_iff_unique_diff_on, unique_mdiff_on_image, hn]
simp
simp [range_comp e, I.unique_diff]
simp only [range_comp e, e.image_eq_preimage, preimage_preimage, mfld_simps]
simp only [mfld_simps]
simp only [e.symm_apply_apply, Equiv.refl_symm, Equiv.coe_refl, mfld_simps]
exact (this hb).1.trans (this ha).1.symm
  clear ha hb a b
  refine' hs₂.subset_clopen _ ⟨p₀, hp₀s, ⟨rfl, hp₀s⟩⟩
  -- closedness of the set of points sent to `f p₀`
  refine' ⟨_, (is_closed_singleton.preimage hf.continuous).inter hs₃.2⟩
  -- we will show this set is open
rw [← Filter.mem_map, (chart_at E p).symm_map_nhds_eq (mem_chart_source E p)]
exact hps'
simp only [inter_right_comm, preimage_inter]
rw [ModelWithCorners.left_inv]
exact IsOpen.mem_nhds u_open xu
simp only [hx, mfld_simps]
simp only [hx, mfld_simps]
intro s x f g h hx hf
apply hf.congr
· intro y hy
        simp only [mfld_simps] at hy
        simp only [h, hy, mfld_simps]
· simp only [hx, mfld_simps]
simp only [hx, mfld_simps]
apply h.mono fun y hy => _
simp only [mfld_simps] at hy
simp only [hy, hts _, mfld_simps]
rw [ContDiffWithinAtProp, preimage_univ, univ_inter]
rfl
simp only [ContMdiffOn, ContMdiff, cont_mdiff_within_at_univ, forall_prop_of_true, mem_univ]
refine' ⟨fun h => h.1, fun h => ⟨h, _⟩⟩
have h₂ := (chart_at H' (f x)).continuous_to_fun.ContinuousWithinAt (mem_chart_source _ _)
refine' ((I'.continuous_at.comp_continuous_within_at h₂).comp' h).mono_of_mem _
exact
      inter_mem self_mem_nhds_within
        (h.preimage_mem_nhds_within <| (chart_at _ _).open_source.mem_nhds <| mem_chart_source _ _)
rw [ContMdiffAt, ContMdiffAt, cont_mdiff_within_at_iff_target, continuous_within_at_univ]
rw [continuous_within_at_univ, preimage_univ, univ_inter]
rw [ContMdiffAt, cont_mdiff_within_at_iff_target_of_mem_source hy, continuous_within_at_univ,
    ContMdiffAt]
infer_instance
simp only [w, hz, mfld_simps]
simp only [w, hz, mfld_simps]
simp only [w, hz, mfld_simps]
simp only [hx, mfld_simps]
simp [← cont_mdiff_on_univ, cont_mdiff_on_iff, continuous_iff_continuous_on_univ]
rw [← cont_mdiff_on_univ, cont_mdiff_on_iff_target]
simp [continuous_iff_continuous_on_univ]
refine' ⟨fun h m hm => h.of_le hm, fun h => _⟩
cases n
· exact cont_mdiff_within_at_top.2 fun n => h n le_top
· exact h n le_rfl
apply
          (((continuous_on_ext_chart_at_symm I' (f x) _ _).comp'
                  (hu _ hy.2).ContinuousWithinAt).comp'
              (continuous_on_ext_chart_at I x _ _)).congr_mono
· intro z hz
          simp only [v_incl hz, v_incl' z hz, mfld_simps]
· intro z hz
          simp only [v_incl hz, v_incl' z hz, mfld_simps]
          exact hz.2
· simp only [v_incl hy, v_incl' y hy, mfld_simps]
· simp only [v_incl hy, v_incl' y hy, mfld_simps]
· simp only [v_incl hy, mfld_simps]
simp only [hz]
simp [← cont_mdiff_within_at_univ, cont_mdiff_within_at_iff_cont_mdiff_on_nhds, nhds_within_univ]
simp only [e, e', mfld_simps]
rw [← cont_mdiff_on_univ] at hf hg⊢
exact hg.comp hf subset_preimage_univ
intro x
refine' ⟨continuous_within_at_const, _⟩
simp only [ContDiffWithinAtProp, (· ∘ ·)]
exact contDiffWithinAtConst
simp only [Pi.one_def, contMdiffConst]
simp only [Pi.one_def, smoothConst]
intro x
simp (config := { contextual := true }) only [ContMdiffWithinAt, lift_prop_within_at,
    ContDiffWithinAtProp, iff_def, mfld_simps]
exact ContDiffWithinAt.continuous_within_at
rw [← cont_mdiff_within_at_univ, cont_mdiff_within_at_iff_cont_diff_within_at,
    cont_diff_within_at_univ]
simp [cont_mdiff_within_at_iff_cont_diff_within_at]
rw [← cont_diff_on_univ, ← cont_mdiff_on_univ, cont_mdiff_on_iff_cont_diff_on]
rw [cont_mdiff_within_at_iff] at *
refine' ⟨hg.continuous_within_at.comp hf.1 h, _⟩
rw [← (extChartAt I x).left_inv (mem_ext_chart_source I x)] at hg
apply ContDiffWithinAt.comp _ hg hf.2 _
exact (inter_subset_left _ _).trans (preimage_mono h)
rw [cont_mdiff_within_at_iff] at *
exact ⟨hf.1.Prod hg.1, hf.2.Prod hg.2⟩
rw [cont_mdiff_within_at_iff] at *
exact ⟨hf.1.Prod hg.1, hf.2.Prod hg.2⟩
rw [cont_mdiff_within_at_iff']
refine' ⟨continuous_within_at_fst, _⟩
refine' cont_diff_within_at_fst.congr (fun y hy => _) _
· simp only [mfld_simps] at hy
    simp only [hy, mfld_simps]
· simp only [mfld_simps]
rw [cont_mdiff_within_at_iff']
refine' ⟨continuous_within_at_snd, _⟩
refine' cont_diff_within_at_snd.congr (fun y hy => _) _
· simp only [mfld_simps] at hy
    simp only [hy, mfld_simps]
· simp only [mfld_simps]
intro p
exact (hf p.1).prod_map' (hg p.2)
simp only [cont_mdiff_within_at_iff, continuous_within_at_pi, cont_diff_within_at_pi, forall_and,
    writtenInExtChartAt, ext_chart_at_model_space_eq_id, (· ∘ ·), LocalEquiv.refl_coe, id]
apply ContDiff.contDiffAt
apply IsBoundedBilinearMap.contDiff
exact isBoundedBilinearMapComp
cases X
cases Y
congr
exact Derivation.coe_injective h
cases X
cases Y
congr
exact h
simp only [LinearMap.map_zero, Derivation.coe_zero]
simp only [LinearMap.map_add, Derivation.coe_add, left_invariant', Pi.add_apply]
simp [left_invariant']
simp [left_invariant']
rw [div_eq_mul_inv]
exact ((smoothMul I).comp (hf.prod_mk hg.inv) : _)
rw [div_eq_mul_inv]
exact ((smoothMul I).compSmoothOn (hf.prod_mk hg.inv) : _)
simp only [pow_zero]
exact smoothConst
simp only [← Finset.prod_apply]
exact contMdiffWithinAtFinsetProd' h
simp only [← finprod_subtype_eq_finprod_cond]
exact contMdiffFinprod (fun i => hc i i.2) (hf.comp_injective Subtype.coe_injective)
rw [smooth_iff]
refine' ⟨continuous_mul, fun x y => _⟩
simp only [Prod.mk.eta, mfld_simps]
rw [cont_diff_on_univ]
exact contDiffMul
rw [lift_prop_at, lift_prop_within_at, continuous_within_at_univ, preimage_univ]
simp [lift_prop_on, lift_prop, lift_prop_at]
rw [lift_prop_within_at, iff_true_intro hf, true_and_iff, hG.congr_set]
exact
    LocalHomeomorph.preimage_eventually_eq_target_inter_preimage_inter hf (mem_chart_source H x)
      (chart_source_mem_nhds H' (f x))
simp only [xf, xf', mfld_simps]
simp only [xf, mfld_simps]
rw [← e.left_inv xe] at xf xf' hgs
refine' hG.lift_prop_within_at_indep_chart_target_aux2 (g ∘ e.symm) hf xf hf' xf' _
exact hgs.comp (e.symm.continuous_at <| e.maps_to xe).ContinuousWithinAt subset.rfl
rw [hG.lift_prop_within_at_indep_chart_source_aux (f ∘ g) he xe he' xe',
    hG.lift_prop_within_at_indep_chart_target_aux xe' hf xf hf' xf' hgs]
rw [← lift_prop_on_univ]
apply hG.lift_prop_on_of_locally_lift_prop_on fun x hx => _
simp [h x]
rw [hx, hy]
refine' ⟨h.1.mono hst, _⟩
apply mono (fun y hy => _) h.2
simp only [mfld_simps] at hy
simp only [hy, hst _, mfld_simps]
rw [← lift_prop_within_at_univ] at h
exact lift_prop_within_at_mono mono h (subset_univ _)
rw [← lift_prop_on_univ] at h
exact lift_prop_on_mono mono h (subset_univ _)
intro x hx
apply
    hG.lift_prop_within_at_of_lift_prop_at_of_mem_nhds
      (hG.lift_prop_at_of_mem_maximal_atlas hQ he hx)
exact IsOpen.mem_nhds e.open_source hx
simp only [hx, mfld_simps]
intro x hx
apply
    hG.lift_prop_within_at_of_lift_prop_at_of_mem_nhds
      (hG.lift_prop_at_symm_of_mem_maximal_atlas hQ he hx)
exact IsOpen.mem_nhds e.open_target hx
simp
simp only [hx, mfld_simps]
simp only [hx, mfld_simps]
apply ContinuousOn.prod _ continuous_snd.continuous_on
refine' (ContinuousOn.comp C continuous_fst.continuous_on _ : _)
exact preimage_mono (subset_preimage_image _ _)
apply le_trans _ hmn
change 0 + 1 ≤ m + 1
exact add_le_add_right (zero_le _) _
apply le_trans _ hmn
change 0 + 1 ≤ m + 1
exact add_le_add_right (zero_le _) _
  -- First step: local reduction on the space, to a set `s'` which is contained in chart domains.
simp [hp]
apply UniqueMdiffOn.inter _ l.open_source
rw [ho, inter_comm]
exact hs.inter o_open
apply ContMdiffOn.comp diff_r diff_f fun x hx => _
simp only [s', mfld_simps] at hx
simp only [hx, mfld_simps]
simp only [ir, mfld_simps]
have A : ContMdiffOn I'.tangent I'.tangent m Dr.symm Dr.target := contMdiffOnChartSymm
apply ContMdiffOn.comp A diff_irrfl_lift fun p hp => _
simp only [s'l_lift, TangentBundle.proj, mfld_simps] at hp
simp only [ir, @LocalEquiv.refl_coe (ModelProd H' E'), hp, mfld_simps]
  -- conclusion of this step: the composition of all the maps above is smooth
apply A.mono fun p hp => _
simp only [s'_lift, TangentBundle.proj, mfld_simps] at hp
simp only [Dl, hp, mfld_simps]
simp only [il, mfld_simps]
apply U'
simp only [hq, s', mfld_simps]
apply U'l
simp only [hq, s'l, mfld_simps]
refine' tangent_map_within_comp_at (il.symm (Dl q)) _ _ (fun p hp => _) U'lq
· apply diff_rf.mdifferentiable_on one_le_n
        simp only [hq, mfld_simps]
· apply diff_l.mdifferentiable_on one_le_n
        simp only [s'l, hq, mfld_simps]
· simp only [mfld_simps] at hp
        simp only [hp, mfld_simps]
refine' tangent_map_within_eq_tangent_map U'lq _
refine' mdifferentiableAtAtlasSymm _ (chart_mem_atlas _ _) _
simp only [hq, mfld_simps]
simp only [hq, mfld_simps]
refine' tangent_map_within_comp_at q _ _ (fun r hr => _) U'q
· apply diff_r.mdifferentiable_on one_le_n
        simp only [hq, mfld_simps]
· apply diff_f.mdifferentiable_on one_le_n
        simp only [hq, mfld_simps]
· simp only [s', mfld_simps] at hr
        simp only [hr, mfld_simps]
apply tangent_map_within_eq_tangent_map
· apply IsOpen.uniqueMdiffWithinAt _ r.open_source
          simp [hq]
· refine' mdifferentiableAtAtlas _ (chart_mem_atlas _ _) _
          simp only [hq, mfld_simps]
simp only [hq, mfld_simps]
let Z' := Z.to_vector_bundle_core
rw [cont_mdiff_at_iff_target, and_congr_left_iff]
refine' fun hf => ⟨fun h => Z'.continuous_proj.continuous_at.comp h, fun h => _⟩
exact
    (Z'.local_triv ⟨chart_at _ (f x).1, chart_mem_atlas _ _⟩).continuous_at_of_comp_left h
      (mem_chart_source _ _) (h.prod hf.continuous_at.snd)
apply BasicSmoothVectorBundleCore.smoothConstSection (tangentBundleCore I M) 0
intro i j x hx
simp only [tangentBundleCore, ContinuousLinearMap.map_zero, ContinuousLinearMap.coe_coe,
    mfld_simps]
apply IsOpen.mem_nhds
apply (LocalHomeomorph.open_target _).Preimage I.continuous_inv_fun
simp only [mfld_simps]
rw [fderiv_within_eq_fderiv, DifferentiableAt.fderiv_prod]
· simp
· exact differentiableAtId'
· exact differentiableAtConst _
· exact ModelWithCorners.uniqueDiffAtImage I
· exact differentiable_at_id'.prod (differentiableAtConst _)
dsimp
exact contDiffOnConst
rw [← i.1.left_inv hi]
rw [Z.coord_change_comp i j i x _ v, Z.coord_change_self _ _ hx.1]
simp only [mfld_simps] at hx
simp only [hx.1, hx.2, mfld_simps]
rw [Z.coord_change_comp' hi hj hi v, Z.coord_change_self' hi]
intro x hx
apply
    (((Z.coord_change_smooth_clm i j).ContinuousOn.ContinuousWithinAt (mem_image_of_mem I hx)).comp
        I.continuous_within_at _).congr
· intro y hy
    simp only [mfld_simps]
· simp only [mfld_simps]
· exact maps_to_image I _
apply IsBoundedBilinearMap.contDiff
exact isBoundedBilinearMapApply
apply ContDiffOn.prod _ _
·
      exact
        (Z.coord_change_smooth_clm i j).comp cont_diff_fst.cont_diff_on
          (prod_subset_preimage_fst _ _)
· exact is_bounded_linear_map.snd.cont_diff.cont_diff_on
simp [mem_chart_source]
simp only [mem_Union, mem_singleton_iff, chart_mem_atlas]
exact ⟨chart_at H p.1, chart_mem_atlas H p.1, rfl⟩
simp only [atlas, mem_Union, mem_singleton_iff]
simp only [chart_at, mfld_simps]
simp only [chart_at, mfld_simps]
simp only [hx.1.1, hx.1.2, mfld_simps]
rw [inter_comm]
apply inter_mem_nhds_within
apply
        I.continuous_symm.continuous_at.preimage_mem_nhds
          (IsOpen.mem_nhds (LocalHomeomorph.open_source _) _)
simp only [hx, i.1.map_target, mfld_simps]
simp only [hx, mfld_simps]
intro y hy
simp only [Function.comp_apply, ModelWithCorners.left_inv]
rw [j.1.left_inv]
exact hy.1.1.2
rw [inter_comm]
apply fderiv_within_inter _ I.unique_diff_at_image
apply
        I.continuous_symm.continuous_at.preimage_mem_nhds
          (IsOpen.mem_nhds (LocalHomeomorph.open_source _) _)
rw [LocalHomeomorph.trans_source] at hx
simp only [mfld_simps]
exact hx.2
infer_instance
infer_instance
infer_instance
infer_instance
simp
cases f <;> cases g <;> cases h <;> rfl
cases f <;> cases g <;> congr <;> exact funext h
infer_instance
infer_instance
simp only [smul_def, Algebra.id.smul_eq_mul, SmoothMap.coe_smul, Pi.smul_apply, mul_assoc]
rw [SmoothMap.add_comp, Derivation.map_add]
simp only [SmoothMap.smul_comp, Derivation.map_smul, RingHom.id_apply]
simp only [Derivation.leibniz, SmoothMap.mul_comp, LinearMap.coe_mk,
        PointedSmoothMap.smul_def, ContMdiffMap.comp_apply, h]
simp only [Set.inter_right_comm, Set.preimage_inter]
rw [ModelWithCorners.left_inv]
exact IsOpen.mem_nhds u_open xu
simp only [hx, mfld_simps]
simp only [hx, mfld_simps]
intro s x f g h hx hf
apply hf.congr
· intro y hy
        simp only [mfld_simps] at hy
        simp only [h, hy, mfld_simps]
· simp only [hx, mfld_simps]
simp only [hx, mfld_simps]
rfl
trace
    "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr «expr ∧ »(_, _)]]"
· rw [continuous_within_at_univ]
· simp [DifferentiableWithinAtProp, Set.univ_inter]
unfold UniqueMdiffWithinAt
simp only [preimage_univ, univ_inter]
exact I.unique_diff _ (mem_range_self _)
apply unique_diff_within_at_congr
rw [nhds_within_inter, nhds_within_inter, nhds_within_ext_chart_at_target_eq]
rw [UniqueMdiffWithinAt, ext_chart_at_preimage_inter_eq]
exact UniqueDiffWithinAt.inter' hs (ext_chart_at_preimage_mem_nhds_within I x ht)
rw [UniqueMdiffWithinAt, ext_chart_at_preimage_inter_eq]
exact UniqueDiffWithinAt.inter hs (ext_chart_at_preimage_mem_nhds I x ht)
refine' and_congr Iff.rfl (exists_congr fun f' => _)
rw [inter_comm]
simp only [HasFderivWithinAt, nhds_within_inter, nhds_within_ext_chart_at_target_eq]
simp only [mfderivWithin, h, dif_neg, not_false_iff]
simp only [mfderiv, h, dif_neg, not_false_iff]
simp only [HasMfderivWithinAt, HasMfderivAt, continuous_within_at_univ, mfld_simps]
rw [← has_mfderiv_within_at_univ] at h₀ h₁
exact (uniqueMdiffWithinAtUniv I).Eq h₀ h₁
rw [HasMfderivWithinAt, HasMfderivWithinAt, ext_chart_at_preimage_inter_eq,
    has_fderiv_within_at_inter', continuous_within_at_inter' h]
exact ext_chart_at_preimage_mem_nhds_within I x h
rw [HasMfderivWithinAt, HasMfderivWithinAt, ext_chart_at_preimage_inter_eq,
    has_fderiv_within_at_inter, continuous_within_at_inter h]
exact ext_chart_at_preimage_mem_nhds I x h
refine' ⟨h.1, _⟩
simp only [mfderivWithin, h, dif_pos, mfld_simps]
exact DifferentiableWithinAt.hasFderivWithinAt h.2
simp only [mfderivWithin, h, dif_pos]
refine' ⟨h.1, _⟩
simp only [mfderiv, h, dif_pos, mfld_simps]
exact DifferentiableWithinAt.hasFderivWithinAt h.2
simp only [mfderiv, h, dif_pos]
apply HasMfderivWithinAt.mfderiv_within _ hxs
exact h.has_mfderiv_at.has_mfderiv_within_at
simp only [MdifferentiableWithinAt, MdifferentiableAt, continuous_within_at_univ, mfld_simps]
rw [MdifferentiableWithinAt, MdifferentiableWithinAt, ext_chart_at_preimage_inter_eq,
    differentiable_within_at_inter, continuous_within_at_inter ht]
exact ext_chart_at_preimage_mem_nhds I x ht
rw [MdifferentiableWithinAt, MdifferentiableWithinAt, ext_chart_at_preimage_inter_eq,
    differentiable_within_at_inter', continuous_within_at_inter' ht]
exact ext_chart_at_preimage_mem_nhds_within I x ht
rw [univ_inter]
simp only [MdifferentiableOn, mdifferentiable_within_at_univ, mfld_simps]
rfl
rw [mfderivWithin, mfderivWithin, ext_chart_at_preimage_inter_eq,
    mdifferentiable_within_at_inter ht,
    fderiv_within_inter (ext_chart_at_preimage_mem_nhds I x ht) hs]
rw [continuous_within_at_univ, Set.preimage_univ, Set.univ_inter]
simp only [tangentMapWithin, mfld_simps]
rw [mfderiv_within_subset st hs h]
rw [← mdifferentiable_within_at_univ] at h
rw [← tangent_map_within_univ]
exact tangent_map_within_subset (subset_univ _) hs h
constructor
· intro h
    apply h.congr_of_eventually_eq h₁ hx
· intro h
    apply h.congr_of_eventually_eq _ hx.symm
    apply h₁.mono
    intro y
    apply Eq.symm
simp only [tangentMapWithin, h p.fst hp, true_and_iff, eq_self_iff_true, heq_iff_eq,
    Sigma.mk.inj_iff]
congr 1
exact mfderiv_within_congr hs h (h _ hp)
have A : f₁ x = f x := (mem_of_mem_nhds hL : _)
rw [← mfderiv_within_univ, ← mfderiv_within_univ]
rw [← nhds_within_univ] at hL
exact hL.mfderiv_within_eq (uniqueMdiffWithinAtUniv I) A
simp only [mfld_simps]
rw [← has_mfderiv_within_at_univ] at *
exact HasMfderivWithinAt.comp x (hg.mono (subset_univ _)) hf subset_preimage_univ
rw [← has_mfderiv_within_at_univ] at *
exact HasMfderivWithinAt.comp x (hg.mono (subset_univ _)) hf subset_preimage_univ
apply HasMfderivWithinAt.mfderiv_within _ hxs
exact HasMfderivWithinAt.comp x hg.has_mfderiv_within_at hf.has_mfderiv_within_at h
apply HasMfderivAt.mfderiv
exact HasMfderivAt.comp x hg.has_mfderiv_at hf.has_mfderiv_at
simp only [tangentMapWithin, mfld_simps]
rw [mfderiv_within_comp p.1 hg hf h hps]
rfl
simp only [tangentMap, mfld_simps]
rw [mfderiv_comp p.1 hg hf]
rfl
simp only [UniqueMdiffWithinAt, mfld_simps]
simp [UniqueMdiffOn, UniqueDiffOn, unique_mdiff_within_at_iff_unique_diff_within_at]
rw [← has_mfderiv_within_at_univ, has_mfderiv_within_at_iff_has_fderiv_within_at,
    has_fderiv_within_at_univ]
simp only [MdifferentiableWithinAt, mfld_simps]
exact ⟨fun H => H.2, fun H => ⟨H.ContinuousWithinAt, H⟩⟩
simp only [MdifferentiableAt, differentiable_within_at_univ, mfld_simps]
exact ⟨fun H => H.2, fun H => ⟨H.ContinuousAt, H⟩⟩
simp only [MdifferentiableOn, DifferentiableOn,
    mdifferentiable_within_at_iff_differentiable_within_at]
simp only [Mdifferentiable, Differentiable, mdifferentiable_at_iff_differentiable_at]
rw [← mfderiv_within_univ, ← fderiv_within_univ]
exact mfderiv_within_eq_fderiv_within
rw [Mdifferentiable.mfderiv_within (mdifferentiableAtId I) hxs]
exact mfderiv_id I
refine' ⟨continuous_const.continuous_at, _⟩
simp only [writtenInExtChartAt, (· ∘ ·), hasFderivWithinAtConst]
simp only [hx, mfld_simps]
simp only [hx, mfld_simps]
dsimp [tangentMap]
rw [MdifferentiableAt.mfderiv]
· rfl
· exact mdifferentiableAtAtlas _ (chart_mem_atlas _ _) h
dsimp only [tangentMap]
rw [MdifferentiableAt.mfderiv (mdifferentiableAtAtlasSymm _ (chart_mem_atlas _ _) h)]
  -- a trivial instance is needed after the rewrite, handle it right now.
rotate_left
· infer_instance
simp only [ContinuousLinearMap.coe_coe, BasicSmoothVectorBundleCore.chart, h, tangentBundleCore,
    BasicSmoothVectorBundleCore.toVectorBundleCore, chart_at, Sigma.mk.inj_iff, mfld_simps]
constructor
· intro x hx
    simp only [mfld_simps] at hx
    exact
      ((he'.mdifferentiable_at hx.2).comp _ (he.mdifferentiable_at hx.1)).MdifferentiableWithinAt
· intro x hx
    simp only [mfld_simps] at hx
    exact
      ((he.symm.mdifferentiable_at hx.2).comp _
          (he'.symm.mdifferentiable_at hx.1)).MdifferentiableWithinAt
simp only [hx.1, mfld_simps]
simp only [z, hx.1, mfld_simps]
apply IsOpen.mem_nhds
apply e.continuous_on.preimage_open_of_open e.open_source (is_open_ext_chart_at_source I' x)
simp only [z_source, zx, mfld_simps]
have A := mdifferentiableOfMemAtlas I (chart_mem_atlas H z)
have B := mdifferentiableOfMemAtlas I' (chart_mem_atlas H' x)
exact A.symm.trans (he.trans B)
simp only [z_source, zx, mfld_simps]
refine' (Diff.mdifferentiable_at Mmem).2.congr (fun p hp => _) _ <;>
      simp only [G, F, mfld_simps]
  -- let `G'` be its derivative
rw [(Diff.mdifferentiable_at Mmem).mfderiv]
rfl
dsimp [G, F]
simp only [hx.1, mfld_simps]
intro z hz
apply (hs z hz.1).inter'
apply (hf z hz.1).preimage_mem_nhds_within
exact (is_open_ext_chart_at_source I' y).mem_nhds hz.2
apply h.unique_mdiff_on_preimage
exact (mdifferentiableOfMemAtlas _ (chart_mem_atlas _ _)).symm
infer_instance
simp only [e, hp, mfld_simps]
apply hs.unique_mdiff_on_preimage
exact mdifferentiableOfMemAtlas _ (chart_mem_atlas _ _)
infer_instance
rw [← image_univ, ← I.source_eq]
exact I.to_local_equiv.image_source_eq_target.symm
refine' I.left_inv' _
simp
refine' (I.to_local_equiv.image_eq_target_inter_inv_preimage _).trans _
· rw [I.source_eq]
    exact subset_univ _
· rw [inter_comm, I.target_eq, I.to_local_equiv_coe_symm]
rw [← I.map_nhds_eq, map_map, I.symm_comp_self, map_id]
rw [inter_comm]
exact I.unique_diff.inter (hs.preimage I.continuous_inv_fun)
intro x
rw [← I.symm_map_nhds_within_range]
exact ((compact_basis_nhds (I x)).inf_principal _).map _
simp only [set_of_true, mfld_simps]
simp only [Set.pi_univ, mfld_simps]
simp
constructor
dsimp [ModelWithCorners.prod, ModelProd]
rw [← prod_range_range_eq, ModelWithCorners.Boundaryless.range_eq_univ,
    ModelWithCorners.Boundaryless.range_eq_univ, univ_prod_univ]
rw [preimage_inter, inter_assoc, inter_assoc]
congr 1
rw [inter_comm]
rw [contDiffGroupoid, contDiffGroupoid]
apply groupoid_of_pregroupoid_le
intro f s hfs
exact ContDiffOn.ofLe hfs h
apply le_antisymm le_top
intro u hu
  -- we have to check that every local homeomorphism belongs to `cont_diff_groupoid 0 I`,
  --
simp [hx.2]
simp
rw [extend, LocalEquiv.trans_source, I.source_eq, preimage_univ, inter_univ]
rw [extend_source]
exact f.open_source
rw [maps_to', extend_coe, extend_coe_symm, preimage_comp, ← I.image_eq, image_comp,
    f.image_eq_target_inter_inv_preimage hs]
exact image_subset _ (inter_subset_right _ _)
refine' I.continuous.comp_continuous_on _
rw [extend_source]
exact f.continuous_on
rw [← LocalEquiv.image_source_eq_target, ← map_extend_nhds f I hy]
exact image_mem_map (extend_source_mem_nhds _ _ hy)
simp only [mfld_simps]
rw [← extend_source f I]
exact is_open_extend_preimage' f I hs
rw [map_extend_nhds_within_eq_image f I hy, nhds_within_inter, ←
    nhds_within_extend_target_eq _ _ hy, ← nhds_within_inter, (f.extend I).image_source_inter_eq',
    inter_comm]
rw [← map_extend_nhds_within f I hy, map_map, map_congr, map_id]
exact (f.extend I).LeftInvOn.EqOn.eventually_eq_of_mem (extend_source_mem_nhds_within _ _ hy)
rw [← nhds_within_univ, ← map_extend_symm_nhds_within f I hy, preimage_univ, univ_inter]
rw [← f.extend_source I] at hs
rw [(f.extend I).image_eq_target_inter_inv_preimage hs]
exact f.extend_symm_preimage_inter_range_eventually_eq_aux I hx
rw [extend_coord_change_source, I.image_eq]
exact (StructureGroupoid.compatible_of_mem_maximal_atlas hf' hf).1
simp only [ext_chart_at_source, mem_chart_source]
simp only [mfld_simps]
rw [← ext_chart_at_source I]
exact is_open_ext_chart_at_preimage' I x hs
simp only [mfld_simps]
simp only [mfld_simps]
simp [bernoulli]
apply sum_eq_zero fun x hx => _
have h : 0 < n - x := tsub_pos_of_lt (mem_range.1 hx)
simp [h]
simp only [bernoulli, eval_finset_sum]
simp only [← succ_eq_add_one, sum_range_succ, mul_one, cast_one, choose_self,
    (_root_.bernoulli _).mul_comm, sum_bernoulli, one_pow, mul_one, eval_C, eval_monomial]
rfl
simp only [ite_eq_right_iff, one_ne_zero]
intro h₁
exact (f x hx) h₁
rw [Nat.cast_succ, ← sum_bernoulli n, sum_range_succ, add_sub_cancel', choose_succ_self_right,
    Nat.cast_succ]
apply eq_add_of_sub_eq'
rw [sum_range_pow_eq_bernoulli_sub]
simp only [sum_inv, coe_coe, add_zero, insert_eq_cons, add_assoc, map_cons, sum_cons,
    map_singleton, sum_singleton]
simp [Units.ext_iff]
rw [legendreSym, Int.cast_zero, MulChar.map_zero]
rw [legendreSym, Int.cast_one, MulChar.map_one]
simp only [legendreSym, Int.cast_mul, map_mul]
simp only [legendreSym, int_cast_mod]
simp only [legendreSym, card p, quadratic_char_neg_one ((ring_char_zmod_n p).substr hp),
    Int.cast_neg, Int.cast_one]
rw [FiniteField.is_square_neg_one_iff, card p]
simp only [legendreSym, card p, quadratic_char_two ((ring_char_zmod_n p).substr hp),
    Int.cast_bit0, Int.cast_one]
simp only [legendreSym, card p, quadratic_char_neg_two ((ring_char_zmod_n p).substr hp),
    Int.cast_bit0, Int.cast_one, Int.cast_neg]
rw [quadratic_reciprocity' (prime.mod_two_eq_one_iff_ne_two.mp (odd_of_mod_four_eq_one hp)) hq,
    pow_mul, neg_one_pow_div_two_of_one_mod_four hp, one_pow, one_mul]
rw [← eq_one_iff' p (prime_ne_zero p q hpq), ← eq_neg_one_iff' q,
    quadratic_reciprocity_three_mod_four hp3 hq3, neg_inj]
simp only [jacobiSym, factors_zero, List.prod_nil, List.pmap]
simp only [jacobiSym, factors_one, List.prod_nil, List.pmap]
simp only [jacobiSym, factors_prime fp.1, List.prod_cons, List.prod_nil, mul_one, List.pmap]
rw [Set.pair_comm]
exact (SignType.range_eq SignType.castHom).symm
let ⟨p, hp, he⟩ := List.mem_pmap.1 hz
rw [← he, legendreSym.at_one]
rw [← neZero_iff] at hb
exact eq_zero_iff_not_coprime.2 h
rw [Int.gcd_zero_left, Int.natAbs_ofNat]
exact hb.ne'
rw [pow_zero, pow_zero, one_left]
rw [pow_succ, pow_succ, mul_left, ih]
rw [pow_left, sq_one h]
rw [mod_left, h, ← mod_left]
rw [← legendreSym.to_jacobi_sym]
exact legendreSym.eq_neg_one_iff p
rw [← nonsquare_iff_jacobi_sym_eq_neg_one, h]
decide
rw [neg_eq_neg_one_mul, mul_left, at_neg_one hb]
rw [neg_one_pow hm hn, ← pow_mul, mul_comm, pow_mul, neg_one_sq, one_pow]
rw [neg_one_pow hm hn, neg_one_pow hn hm, mul_comm (m / 2)]
refine'
      ⟨fun h' =>
        let h := h'.symm
        _,
        fun h => _⟩ <;>
    rw [h, ← mul_assoc, ← pow_two, sq_eq_one hm hn, one_mul]
rw [qrSign.mul_left, Nat.cast_mul, mul_left, mul_mul_mul_comm]
rw [← qrSign.neg_one_pow ha hb, qrSign.symm ha hb, quadratic_reciprocity' ha hb]
rw [quadratic_reciprocity (odd_iff.mpr (odd_of_mod_four_eq_one ha)) hb, pow_mul,
    neg_one_pow_div_two_of_one_mod_four ha, one_pow, one_mul]
rw [jacobi_sym_nat, Nat.cast_zero, jacobiSym.zero_left (Nat.one_lt_bit0 hb)]
rw [jacobi_sym_nat, Nat.cast_zero, jacobiSym.zero_left (Nat.one_lt_bit1 hb)]
rw [jacobi_sym_nat, Nat.cast_one, jacobiSym.one_left]
rw [jacobi_sym_nat, Nat.cast_one, jacobiSym.one_left]
rw [← hr, jacobi_sym_nat, jacobiSym.mod_left, hb', hab, ← h]
rw [← hr, jacobi_sym_nat, jacobi_sym_nat, _root_.jacobi_sym.mod_left a b, ← hab]
rfl
simp only [legendreSym, quadratic_char_apply, quadratic_char_fun_one, Int.cast_bit1,
      CharTwo.bit1_eq_one, Pi.one_apply]
rw [Int.coe_nat_gcd, Nat.bit1_eq_succ_bit0, bit0_eq_two_mul b, Nat.succ_eq_add_one,
      Nat.gcd_mul_left_add_right, Nat.gcd_one_right]
rw [Nat.bit1_mod_bit0, Nat.bit0_mod_bit0, Nat.bit0_mod_two]
rw [Nat.bit1_mod_bit0, Nat.bit1_mod_bit0, Nat.bit1_mod_two]
rw [Nat.bit1_mod_bit0, Nat.bit1_mod_bit0, Nat.bit0_mod_two]
rw [Nat.bit1_mod_bit0, Nat.bit0_mod_bit0, Nat.bit1_mod_two]
rw [Nat.bit1_mod_bit0, Nat.bit0_mod_two]
rw [Nat.bit1_mod_bit0, Nat.bit0_mod_two]
rw [Nat.bit1_mod_bit0, Nat.bit1_mod_two]
rw [Nat.bit1_mod_bit0, Nat.bit1_mod_two]
rw [← Finset.prod_Ico_id_eq_factorial, prod_nat_cast]
conv in Ico 1 p => rw [← succ_sub_one p, succ_sub (Fact.out p.prime).Pos]
rw [← prod_nat_cast, Finset.prod_Ico_id_eq_factorial, wilsons_lemma]
simp (config := { contextual := true }) [Nat.lt_succ_iff, Nat.succ_le_iff, pos_iff_ne_zero]
decide
intro x hx
simp [hap, CharP.cast_eq_zero_iff (Zmod p) p, hpe hx, lt_succ_iff, succ_le_iff, pos_iff_ne_zero,
      nat_abs_val_min_abs_le _]
rw [prod_mul_distrib, ← prod_nat_cast, prod_Ico_id_eq_factorial, prod_const, card_Ico,
          succ_sub_one] <;>
        simp
simp
simp_all [-not_le]
rw [← prod_nat_cast, Finset.prod_eq_multiset_prod,
        Ico_map_val_min_abs_nat_abs_eq_Ico_map_id p a hap, ← Finset.prod_eq_multiset_prod,
        prod_Ico_id_eq_factorial]
decide
rw [legendreSym.eq_pow, gauss_lemma_aux p ha0] <;> simp
simp only [mod_add_div]
simp only [val_nat_cast] <;>
        simp [sum_add_distrib, mul_sum.symm, Nat.cast_add, Nat.cast_mul, Nat.cast_sum, hp2]
simp only [(val_eq_ite_val_min_abs _).symm] <;> simp [Nat.cast_sum]
simp [ite_cast, add_comm, sum_add_distrib, Finset.sum_ite, hp2, Nat.cast_sum]
rw [Finset.sum_eq_multiset_sum, Ico_map_val_min_abs_nat_abs_eq_Ico_map_id p a hap, ←
                Finset.sum_eq_multiset_sum] <;>
              simp [Nat.cast_sum]
simp
simp [hp0, Finset.ext_iff]
simp (config := { contextual := true }) only [mem_filter, mem_sigma, and_self_iff,
                  forall_true_iff, mem_product]
simp (config := { contextual := true }) only [Prod.mk.inj_iff, eq_self_iff_true,
                  and_self_iff, heq_iff_eq, forall_true_iff]
revert h <;>
                  simp (config := { contextual := true }) only [mem_filter, eq_self_iff_true,
                    exists_prop_of_true, mem_sigma, and_self_iff, forall_true_iff, mem_product]
simp (config := { contextual := true }) only [mem_filter, and_self_iff, Prod.swap_prod_mk,
          forall_true_iff, mem_product]
simp (config := { contextual := true }) only [Prod.mk.inj_iff, eq_self_iff_true,
          and_self_iff, Prod.swap_prod_mk, forall_true_iff]
revert h <;>
          simp (config := { contextual := true }) only [mem_filter, eq_self_iff_true, and_self_iff,
            exists_prop_of_true, Prod.swap_prod_mk, forall_true_iff, mem_product]
decide
intro a ha
simp only [ha, if_false]
simp only [isUnit_one, if_true]
cases χ
cases χ'
congr
exact MonoidHom.ext h
apply ext'
intro a
intro x y
intro a ha
simp only [ha, not_false_iff, dif_neg]
simp [of_unit_hom]
rw [map_nonunit χ not_isUnit_zero]
rw [ringChar.Nat.cast_ring_char, χ.map_zero]
simp [map_nonunit χ ha]
simp [map_nonunit _ ha]
simp only [is_nontrivial, Ne.def, ext_iff, not_forall, one_apply_coe]
simp only [map_nonunit χ ha, map_zero]
simp only [quadraticCharFun]
simp only [quadraticCharFun, eq_self_iff_true, if_true, id.def]
simp only [quadraticCharFun, one_ne_zero, is_square_one, if_true, if_false, id.def]
simp only [quadraticCharFun, ha, if_false, ite_eq_left_iff]
exact fun h => False.ndrec _ (h (FiniteField.is_square_of_char_two hF a))
rw [of_not_not (mt Ne.isUnit ha)]
exact quadratic_char_fun_zero
simp only [quadratic_char_apply, quadratic_char_fun_zero]
decide
simp only [quadraticCharFun, ha, pow_eq_zero_iff, Nat.succ_pos', is_square_sq, if_true, if_false,
    quadratic_char_apply]
intro a
decide
decide
decide
decide
decide
decide
rw [← hFp]
exact ringChar.Nat.cast_ring_char
rw [hFp]
exact (ring_char_zmod_n p).symm
rw [is_unit_iff_not_dvd_char, ring_char_zmod_n]
rw [Ne, ← Nat.prime_dvd_prime_iff_eq FFp Nat.prime_two] at hFF
change ¬_
refine' (sq_eq_one_iff.1 _).resolve_left _ <;>
      · simp only [τ, ← map_nsmul_pow]
        erw [AddChar.IsPrimitive.zmod_char_eq_one_iff 8 ψ₈.prim]
        decide
  -- we consider `χ₈` as a multiplicative character `ℤ/8ℤ → FF`
rw [coe_to_fun_apply, ofAdd_zero, map_one]
rw [coe_to_fun_apply, coe_to_fun_apply _ x, coe_to_fun_apply _ y, ofAdd_add, map_mul]
rw [coe_to_fun_apply, coe_to_fun_apply _ x, ofAdd_nsmul, map_pow]
rw [coe_to_fun_apply, coe_to_fun_apply _ x, ofAdd_zsmul, map_zpow]
refine' not_forall.symm.trans (Iff.not _)
rw [FunLike.ext_iff]
rfl
rw [mul_shift_apply, ← nsmul_eq_mul, map_nsmul_pow]
simp only [toAdd_one, Zmod.val_zero, pow_zero]
rw [toAdd_mul, ← pow_add, Zmod.val_add (to_add x) (to_add y), ← pow_eq_pow_mod _ hζ]
rw [pow_eq_pow_mod a hζ, zmod_char_apply, Zmod.val_nat_cast a]
rw [nsmul_eq_mul, mul_one]
exact (Zmod.nat_cast_zmod_val a).symm
rw [ha, map_zero_one]
refine' fun a ha => (is_nontrivial_iff_ne_trivial _).mpr fun hf => _
have h : mul_shift ψ a 1 = (1 : AddChar (Zmod n) C) (1 : Zmod n) :=
    congr_fun (congr_arg coeFn hf) 1
rw [mul_shift_apply, mul_one, MonoidHom.one_apply] at h
exact ha (hψ a h)
apply zmod_char_primitive_of_eq_one_only_at_zero
intro a ha
rw [zmod_char_apply, ← pow_zero ζ] at ha
exact (Zmod.val_eq_zero a).mp (IsPrimitiveRoot.pow_inj h (Zmod.val_lt a) n.pos ha)
decide
decide
rw [← Zmod.nat_cast_mod n 4]
decide
decide
rw [χ₄_nat_mod_four, hn]
rfl
rw [χ₄_nat_mod_four, hn]
rfl
rw [χ₄_int_mod_four, hn]
rfl
rw [χ₄_int_mod_four, hn]
rfl
rw [← χ₄_eq_neg_one_pow (Nat.odd_of_mod_four_eq_one hn), ← nat_cast_mod, hn]
rfl
rw [← χ₄_eq_neg_one_pow (Nat.odd_of_mod_four_eq_three hn), ← nat_cast_mod, hn]
rfl
decide
decide
rw [← Zmod.nat_cast_mod n 8]
decide
decide
decide
decide
rw [Algebra.smul_def]
exact mul_pos hb' hε
intro i
exact floor_nonneg.mpr (div_nonneg (cast_nonneg.mpr (mod_nonneg _ hb)) hbε.le)
intro i h
exact finset.mem_to_list.mp (List.nth_le_mem _ _ _)
rw [← Nat.succ_sub hbj, Nat.succ_sub_succ, tsub_tsub_cancel_of_le hbj.le]
rw [Algebra.smul_def, eq_int_cast]
exact mul_pos (int.cast_pos.mpr (AbsoluteValue.pos _ hb)) hε
have ha : 0 < a := lt_of_le_of_lt (AbsoluteValue.nonneg _ _) hxy
rw [Algebra.smul_def, eq_int_cast]
exact mul_pos (int.cast_pos.mpr (AbsoluteValue.pos _ hb)) hε
  -- We go
induction on the size `A
intro k
exact Finset.le_max' _ _ (finset.mem_image.mpr ⟨k, Finset.mem_univ _, rfl⟩)
intro i j
rw [q_eq, r_eq, EuclideanDomain.div_add_mod]
intro j
rw [← bS.sum_repr a]
simp only [Finset.smul_sum, ← Finset.sum_add_distrib]
refine' Finset.sum_congr rfl fun i _ => _
rw [← s_eq, ← mul_smul, μ_eq, add_smul, mul_smul]
rw [IsScalarTower.algebra_map_eq R S L]
exact (IsIntegralClosure.algebra_map_injective S R L).comp bS.algebra_map_injective
rw [Ne.def, Ideal.zero_eq_bot, Ideal.span_singleton_eq_bot]
exact prod_finset_approx_ne_zero bS adm
rw [Equiv.refl_apply, Ideal.span_le, Set.singleton_subset_iff]
let e := IsLocalization.algEquiv Fq[X]
intro c x
rw [Algebra.smul_def, Algebra.smul_def]
congr
refine' congr_fun _ c
refine' IsLocalization.ext (nonZeroDivisors Fq[X]) _ _ _ _ _ _ _ <;> intros <;>
      simp only [AlgEquiv.map_one, RingHom.map_one, AlgEquiv.map_mul, RingHom.map_mul,
        AlgEquiv.commutes, ← IsScalarTower.algebra_map_apply]
rw [IsScalarTower.algebra_map_eq Fq[X] (Ratfunc Fq) F]
exact
    Function.Injective.comp (algebraMap (Ratfunc Fq) F).Injective
      (IsFractionRing.injective Fq[X] (Ratfunc Fq))
rw [IsScalarTower.algebra_map_eq Fq[X] (Ratfunc Fq) F]
exact
      Function.Injective.comp (algebraMap (Ratfunc Fq) F).Injective
        (IsFractionRing.injective Fq[X] (Ratfunc Fq))
rw [Ratfunc.int_degree_one, ofAdd_zero, WithZero.coe_one]
rw [infty_valuation_def, infty_valuation_def, infty_valuation_def]
rw [infty_valuation_def, if_neg hx]
have hCk : Ratfunc.c k ≠ 0 := (map_ne_zero _).mpr hk
rw [infty_valuation_def, if_neg hCk, Ratfunc.int_degree_C]
rw [infty_valuation_def, if_neg Ratfunc.X_ne_zero, Ratfunc.int_degree_X]
rw [Ne.def, Ratfunc.algebra_map_eq_zero_iff]
exact hp
simp
simp [von_mangoldt_apply]
simp only [von_mangoldt_apply, is_prime_pow_pow_iff hk, pow_min_fac hk]
rw [von_mangoldt_apply, prime.min_fac_eq hp, if_pos hp.prime.is_prime_pow]
refine' rec_on_prime_coprime _ _ _ n
· simp
· intro p k hp
    rw [sum_divisors_prime_pow hp, cast_pow, Real.log_pow, Finset.sum_range_succ', pow_zero,
      von_mangoldt_apply_one]
    simp [von_mangoldt_apply_pow (Nat.succ_ne_zero _), von_mangoldt_apply_prime hp]
intro a b ha' hb' hab ha hb
simp only [von_mangoldt_apply, ← sum_filter] at ha hb⊢
rw [mul_divisors_filter_prime_pow hab, filter_union,
    sum_union (disjoint_divisors_filter_prime_pow hab), ha, hb, Nat.cast_mul,
    Real.log_mul (cast_ne_zero.2 (pos_of_gt ha').ne') (cast_ne_zero.2 (pos_of_gt hb').ne')]
rw [mul_comm]
simp
rw [← von_mangoldt_mul_zeta, mul_assoc, coe_zeta_mul_coe_moebius, mul_one]
rw [mul_comm]
simp
simp
rw [← von_mangoldt_sum]
exact single_le_sum (fun _ _ => von_mangoldt_nonneg) (mem_divisors_self _ n.succ_ne_zero)
rw [← discr_prime_pow_ne_two hζ (cyclotomic.irreducible_rat (p ^ (k + 1)).Pos) hk]
exact hζ.discr_zeta_eq_discr_zeta_sub_one.symm
rw [← discr_odd_prime hζ (cyclotomic.irreducible_rat hp.out.pos) hodd]
exact hζ.discr_zeta_eq_discr_zeta_sub_one.symm
rw [← discr_prime_pow hζ (cyclotomic.irreducible_rat (p ^ k).Pos)]
exact hζ.discr_zeta_eq_discr_zeta_sub_one.symm
rw [hζ.discr_zeta_eq_discr_zeta_sub_one.symm]
exact discr_prime_pow_eq_unit_mul_pow hζ (cyclotomic.irreducible_rat (p ^ k).Pos)
simp [smul_def]
rw [singleton_one ℚ K]
exact mem_top
rfl
simp
rw [← pow_one p] at hζ hcycl
exact is_integral_closure_adjoin_singleton_of_prime_pow hζ
rw [← pow_one p]
exact cyclotomic_ring_is_integral_closure_of_prime_pow
simp [integral_power_basis, ← cyclotomic_eq_minpoly hζ, nat_degree_cyclotomic]
simp [sub_one_integral_power_basis]
apply AlgEquiv.coe_alg_hom_injective
apply (hμ.power_basis K).alg_hom_ext
exact this
simp only [MonoidHom.to_fun_eq_coe]
apply AlgEquiv.coe_alg_hom_injective
apply (hζ.power_basis K).alg_hom_ext
simp only [AlgEquiv.coe_alg_hom, AlgEquiv.map_pow]
rw [PowerBasis.equiv_of_minpoly_gen]
simp only [IsPrimitiveRoot.power_basis_gen, IsPrimitiveRoot.aut_to_pow_spec]
simp [is_cyclotomic_extension_iff]
rw [← h₁, ← AlgHom.map_pow, hn.2, AlgHom.map_one]
simp [mem_singleton_iff.1 hs]
apply NeZero.nat_of_ne_zero (algebraMap A B)
exact NeZero n A B
simp [hb]
refine'
        adjoin_induction' (fun b hb => _) (fun a => _) (fun b₁ b₂ hb₁ hb₂ => _)
          (fun b₁ b₂ hb₁ hb₂ => _) x
· rw [Set.mem_singleton_iff] at hb
        refine' subset_adjoin _
        simp only [mem_singleton_iff, exists_eq_left, mem_set_of_eq, hb]
        rw [← Subalgebra.coe_eq_one, Subalgebra.coe_pow, SetLike.coe_mk]
        exact ((IsPrimitiveRoot.iff_def ζ n).1 h).1
· exact Subalgebra.algebra_map_mem _ _
· exact Subalgebra.add_mem _ hb₁ hb₂
· exact Subalgebra.mul_mem _ hb₁ hb₂
rw [isUnit_iff_ne_zero]
apply map_ne_zero_of_mem_non_zero_divisors
apply adjoin_algebra_injective
exact hx
rw [adjoin_algebra_injective n A K h]
rw [mul_right_cancel₀ (nonZeroDivisors.ne_zero c.prop) hc]
rw [aeval_def, ← eval_map, ← is_root.def, map_cyclotomic, is_root_cyclotomic_iff]
exact zeta_spec n A B
simp
simp
simp
have hz := congr_arg (norm K) ((IsPrimitiveRoot.iff_def _ n).1 hζ).1
rw [← (algebraMap K L).map_one, Algebra.norm_algebra_map, one_pow, map_pow, ← one_pow ↑n] at hz
exact StrictMono.injective hodd.strict_mono_pow hz
rw [cyclotomic', eval_prod, ← @Finset.prod_attach E E, ← univ_eq_attach]
refine' Fintype.prod_equiv (hζ.embeddings_equiv_primitive_roots E hirr) _ _ fun σ => _
simp
simp [sub_eq_add_neg]
rw [sub_add_cancel]
refine' IsPrimitiveRoot.pow (p ^ (k + 1)).Pos hζ _
rw [PNat.pow_coe, ← pow_add, add_comm s, Nat.sub_add_cancel (le_trans hs (Nat.le_succ k))]
simp only [Nat.succ_sub_succ_eq_sub, tsub_zero]
exact (Nat.sub_add_cancel hs).symm
simp [hirr]
simp [hζ]
simp [hcyc]
simp [hirr]
simp [hirr]
simp [hζ]
simp
simp
simp
intro hp
refine' one_le_iff_ne_zero.2 fun h => _
rw [h, hp, zero_add, pow_one] at hk
exact hk rfl
rfl
simp
rfl
simp
rw [discr_prime_pow hζ hirr]
simp [heven.neg_one_pow]
simp [(odd_iff_not_even.2 heven).neg_one_pow]
rw [zero_add, pow_one]
infer_instance
simp [hodd]
exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
have := @LinearEquiv.closed_embedding_of_injective ℝ _ (Fin 2 → ℝ) _ (id _) ℂ _ _ _ _
rotate_left 2
exact f
exact this hf
refine' continuous_matrix _
simp only [Fin.forall_fin_two, mB, continuous_const, continuous_id', of_apply, cons_val_zero,
      cons_val_one, and_self_iff]
simp
exact tendsto_norm_cocompact_at_top.comp this
rw [Set.mem_preimage, Set.mem_singleton_iff]
exact Eq.trans hg1.symm (set.mem_singleton_iff.mp (set.mem_preimage.mp g.2))
simp [coe_inv, coe_T, adjugate_fin_two]
simp [coe_T_zpow, Matrix.mul, Matrix.dotProduct, Fin.sum_univ_succ]
simp [coe_T_zpow]
rw [← coe_re, coe_T_zpow_smul_eq, add_re, int_cast_re, coe_re]
rw [← coe_im, coe_T_zpow_smul_eq, add_im, int_cast_im, add_zero, coe_im]
rw [abs_mul, abs_two, ← lt_div_iff' (zero_lt_two' ℝ)]
exact h.2
rw [special_linear_group.im_smul_eq_div_norm_sq, special_linear_group.im_smul_eq_div_norm_sq,
        denom_apply, denom_apply, hg]
intros
simp only [w, ← mul_smul, had]
simp only [map_one, SlashAction.slash_one]
simp only [map_mul, SlashAction.right_action]
simp [slash]
simp [slash]
simp only [slash, Pi.zero_apply, zero_mul]
simp only [coe_coe, Matrix.SpecialLinearGroup.coe_GL_pos_coe_GL_coe_matrix,
      Matrix.SpecialLinearGroup.det_coe]
rw [Int.neg_add, zpow_add₀]
exact UpperHalfPlane.denom_ne_zero A x
simp [-Matrix.SpecialLinearGroup.coe_matrix_coe]
simp
cases f <;> cases g <;> congr
rw [← ModularForm.slash_action_eq'_iff]
simp
cases f <;> cases g <;> congr
cases f <;> cases g <;> congr
simp
intro a b ha hb
simp only [Set.mem_setOf_eq]
have h := (Matrix.two_mul_expl a.1 b.1).2.2.1
simp only [coe_coe, coe_matrix_coe, coe_mul, Int.coe_cast_ring_hom, map_apply, Set.mem_setOf_eq,
      Subtype.val_eq_coe, mul_eq_mul] at *
rw [h]
simp [ha, hb]
intro a ha
simp only [Set.mem_setOf_eq, Subtype.val_eq_coe]
rw [SL2_inv_expl a]
simp only [Subtype.val_eq_coe, cons_val_zero, cons_val_one, head_cons, coe_coe, coe_matrix_coe,
      coe_mk, Int.coe_cast_ring_hom, map_apply, Int.cast_neg, neg_eq_zero, Set.mem_setOf_eq] at *
exact ha
simp [A.1.property]
simp
intro A B
have := (two_mul_expl A.1.1 B.1.1).2.2.2
simp only [coe_coe, Subgroup.coe_mul, coe_matrix_coe, coe_mul, Int.coe_cast_ring_hom, map_apply,
      Subtype.val_eq_coe, mul_eq_mul] at *
rw [this]
have ha := A.property
simp only [Int.cast_add, Int.cast_mul, add_left_eq_self, Subtype.val_eq_coe, Gamma0_mem,
      coe_coe, coe_matrix_coe, Int.coe_cast_ring_hom, map_apply] at *
rw [ha]
simp
constructor
· intro ha
    have hA := A.property
    rw [Gamma0_mem] at hA
    have adet := Gamma0_det N A
    rw [Matrix.det_fin_two] at adet
    simp only [gamma0Map, coe_coe, coe_matrix_coe, Int.coe_cast_ring_hom, map_apply, Gamma1_mem',
      MonoidHom.coe_mk, Subtype.val_eq_coe, Int.cast_sub, Int.cast_mul] at *
    rw [hA, ha] at adet
    simp only [mul_one, mul_zero, sub_zero] at adet
    simp only [adet, hA, ha, eq_self_iff_true, and_self_iff]
· intro ha
    simp only [Gamma1_mem', gamma0Map, MonoidHom.coe_mk, coe_coe, coe_matrix_coe,
      Int.coe_cast_ring_hom, map_apply]
    exact ha.2.1
simp [ha.right.right, Gamma0_mem, Subtype.val_eq_coe]
simp only [Gamma1_to_Gamma0_mem, Subgroup.coe_mk, coe_coe, coe_matrix_coe,
        Int.coe_cast_ring_hom, map_apply]
exact ha
intro x HA
simp only [Gamma0_mem, Gamma1_mem, coe_coe, coe_matrix_coe, Int.coe_cast_ring_hom, map_apply] at *
exact HA.2.2
simp only [le_refl]
refine' ⟨N, _⟩
intro A hA
simp only [Gamma1_mem, Gamma_mem] at *
simp only [hA, eq_self_iff_true, and_self_iff]
apply Subgroup.Normal.conj_act (Gamma_normal N)
delta PythagoreanTriple
rw [add_comm]
simp only [PythagoreanTriple, zero_mul, zero_add]
rw [h.eq]
decide
apply int.nat_abs_eq_zero.mp
apply Nat.eq_zero_of_gcd_eq_zero_left h0
apply int.nat_abs_eq_zero.mp
apply Nat.eq_zero_of_gcd_eq_zero_right h0
apply int.nat_abs_eq_zero.mp
apply Nat.eq_zero_of_gcd_eq_zero_left h0
apply int.nat_abs_eq_zero.mp
apply Nat.eq_zero_of_gcd_eq_zero_right h0
rw [hc]
exact one_ne_zero
decide
decide
intro q
apply ne_of_gt
exact lt_add_of_pos_of_le zero_lt_one (sq_nonneg q)
apply Prod.mk.inj
have := ((circleEquivGen hQ).apply_symm_apply ⟨⟨v, w⟩, hp⟩).symm
exact congr_arg Subtype.val this
apply lt_add_of_pos_of_le _ (sq_nonneg n)
exact lt_of_le_of_ne (sq_nonneg m) (Ne.symm (pow_ne_zero 2 hm0))
rw [Int.gcd_comm]
exact hnmcp
apply int.nat_abs_eq_zero.mp
apply Nat.eq_zero_of_gcd_eq_zero_left h0
apply int.nat_abs_eq_zero.mp
apply Nat.eq_zero_of_gcd_eq_zero_right h0
calc
      _ = _ := hr.symm
      _ < 1 * 1 := mul_lt_mul' h norm_denom_lt (norm_nonneg _) zero_lt_one
      _ = 1 := mul_one 1
rw [pow_one]
rw [f_congr (0 : ℤ_[p]) _ 0, cast_zero]
· exact f_spec _
· simp only [sub_zero, cast_zero, Submodule.zero_mem]
rw [f_congr (1 : ℤ_[p]) _ 1, cast_one]
· exact f_spec _
· simp only [sub_self, cast_one, Submodule.zero_mem]
rw [← maximal_ideal_eq_span_p]
exact sub_zmod_repr_mem
rw [← maximal_ideal_eq_span_p]
exact zmod_congr_of_sub_mem_max_ideal
apply pow_lt_pow hp_prime.1.one_lt (lt_add_one n)
  split_ifs
rw [hc]
rw [← this, ← Ideal.mem_span_singleton, ← maximal_ideal_eq_span_p]
apply to_zmod_spec
rw [Int.natAbs_eq_zero] at hc0
rw [is_unit_iff, norm_eq_pow_val hc', hc0, neg_zero, zpow_zero]
rw [← zmod_cast_comp_to_zmod_pow _ _ h]
rfl
intro x
apply dense_range_nat_cast.induction_on x
· exact is_closed_closure
· intro a
    change (a.cast : ℤ_[p]) with (a : ℤ).cast
    apply subset_closure
    exact Set.mem_range_self _
simp [nth_hom] <;> rfl
specialize f_compat i j h
rw [← Int.coe_nat_pow, ← Zmod.int_coe_zmod_eq_zero_iff_dvd, Int.cast_sub]
dsimp [nth_hom]
rw [← f_compat, RingHom.comp_apply]
simp only [Zmod.cast_id, Zmod.cast_hom_apply, sub_self, Zmod.nat_cast_val, Zmod.int_cast_cast]
simp [nth_hom_seq, nth_hom, this, hε]
simp [lim_nth_hom] <;> rfl
show _ = RingHom.id _ z
rw [@lift_unique p _ ℤ_[p] _ _ zmod_cast_comp_to_zmod_pow (RingHom.id ℤ_[p])]
intro
rw [RingHom.comp_id]
have : padicNorm p (f n - f m) < ε := hN2 _ (max_le_iff.1 hn).2 _ (max_le_iff.1 hm).2
have : padicNorm p (f n - f m) < padicNorm p (f n) :=
      lt_of_lt_of_le this <| hN1 _ (max_le_iff.1 hn).1
have : padicNorm p (f n - f m) < max (padicNorm p (f n)) (padicNorm p (f m)) :=
      lt_max_iff.2 (Or.inl this)
constructor
· intro h
simp [norm, hf]
simp [hf, norm]
simp [norm, hf, padicNorm.nonneg]
apply stationary_point_spec hf
· apply le_max_left
· exact le_rfl
apply stationary_point_spec hf
· apply le_trans
    · apply le_max_left _ v3
    · apply le_max_right
· exact le_rfl
apply stationary_point_spec hf
· apply le_trans
    · apply le_max_right v2
    · apply le_max_right
· exact le_rfl
have hg : f * g ≈ 0 := mul_equiv_zero' _ hf
simp only [hf, hg, norm, dif_pos, zero_mul]
have hf : f * g ≈ 0 := mul_equiv_zero _ hg
simp only [hf, hg, norm, dif_pos, mul_zero]
apply mul_not_equiv_zero <;> assumption
simp [hq] <;> apply Setoid.refl (const (padicNorm p) 0)
    subst hq <;> simp [norm, this]
have : ¬const (padicNorm p) q ≈ 0 := not_equiv_zero_const_of_nonzero hq
simp [norm, this]
have h1 : ¬(1 : PadicSeq p) ≈ 0 := one_not_equiv_zero _
simp [h1, norm, hp.1.one_lt]
apply lt_of_lt_of_le hN'
apply sub_le_self
apply padicNorm.nonneg
have hg : g ≈ 0 := Setoid.trans (Setoid.symm hfg) hf
simp [norm, hf, hg]
rw [hcl] <;> exact max_eq_right (norm_nonneg _)
      rw [this, hcfg]
rw [hcl] <;> exact max_eq_left (norm_nonneg _)
        rw [this, hcfg]
have hg : g ≈ 0 := equiv_zero_of_val_eq_of_equiv_zero h hf
simp only [hf, hg, norm, dif_pos]
simp only [h, forall_const, eq_self_iff_true]
apply stationary_point_spec
apply le_max_left
exact le_rfl
apply stationary_point_spec
apply le_max_right
exact le_rfl
simp
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
rw [HEq] <;> apply Setoid.refl _
rw [h]
simp [dist]
simp [dist, ← padic_norm_e.map_neg (x - y)]
simp [HasNorm.norm, map_mul]
simp [HasNorm.norm, map_mul]
simp [HasNorm.norm, map_mul]
unfold HasNorm.norm
rw [← padicNormE.eq_padic_norm']
have p₀ : p ≠ 0 := hp.1.NeZero
have p₁ : p ≠ 1 := hp.1.ne_one
rw [← @Rat.cast_coe_nat ℝ _ p]
rw [← @Rat.cast_coe_nat ℚ_[p] _ p]
simp [p₀, p₁, norm, padicNorm, padicValRat, padicValInt, zpow_neg, -Rat.cast_coe_nat]
rw [norm_zpow, norm_p, zpow_neg, inv_zpow]
rw [← norm_p_zpow, zpow_ofNat]
simp [h]
simp [hp.1.ne_one]
simp
rw [padicNormE.add_eq_max_of_ne hne] <;> apply le_max_right
rw [padicNormE.add_eq_max_of_ne hne] <;> apply le_max_left
simp
intro H
erw [const_equiv p] at H
exact one_ne_zero H
rw [← Nat.cast_one, Nat.cast_lt]
exact Nat.Prime.one_lt hp.elim
rw [← Nat.cast_one, Ne.def, Nat.cast_inj]
exact Nat.Prime.ne_one hp.elim
rw [← Nat.cast_zero, Nat.cast_lt]
exact Nat.Prime.pos hp.elim
simp only [add_valuation_def, if_pos (Eq.refl _)]
simp only [add_valuation_def, if_neg one_ne_zero, valuation_one, WithTop.coe_zero]
simp only [add_valuation_def]
simp only [add_valuation_def]
simp only [AddValuation, AddValuation.of_apply, add_valuation_def, if_neg hx]
apply Nat.zpow_pos_of_pos
exact hp.1.Pos
rw [norm_le_pow_iff_norm_lt_pow_add_one, sub_add_cancel]
simp [hz]
simp
simp [*, sq]
simp [T, ← PadicInt.norm_def]
let h := (div_lt_one deriv_sq_norm_pos).2 hnorm
rw [T_def] <;> apply h
simp [T_def, mul_div_cancel' _ (ne_of_gt (deriv_sq_norm_pos hnorm))]
simp [hz.1]
simp only [sub_eq_add_neg, add_assoc, hz', add_add_neg_cancel'_right, norm_neg]
rw [hz.1] <;> apply deriv_norm_ne_zero <;> assumption
rw [padicNormE.mul]
exact mul_le_one (PadicInt.norm_le_one _) (norm_nonneg _) h1
rw [hzeq]
simp only [PadicInt.coe_neg, PadicInt.coe_mul, Subtype.coe_mk]
simp only [mul_div_cancel' _ hdzne', Subtype.coe_eta]
simp [HEq]
simp [hzeq, hz.1, div_pow]
simp only [mul_pow]
rw [← pow_mul, pow_succ' 2]
simp [z1, hz.1]
simp [newton_seq, newton_seq_aux, ih_n, sub_eq_add_neg, add_comm]
rw [newton_seq_deriv_norm]
rw [T_def]
exact div_pos (norm_pos_iff.2 hnsol) (deriv_sq_norm_pos hnorm)
rw [T, sq, pow_one, norm_div, ← mul_div_assoc, padicNormE.mul]
apply mul_div_mul_left
apply deriv_norm_ne_zero <;> assumption
simp [T_pow_nonneg hnorm, mul_nonneg]
rw [add_assoc]
rw [← sub_add_sub_cancel]
have hex : ∃ m, k = n + m := exists_eq_add_of_le hnk
let ⟨_, hex'⟩ := hex
rw [hex'] <;> apply newton_seq_dist_aux <;> assumption
simp [sub_eq_add_neg, add_assoc, newton_seq, newton_seq_aux, ih_n]
rw [newton_seq_dist_to_a (k + 1) (succ_pos _)] <;> apply newton_seq_succ_dist_weak <;>
        assumption
rw [← sub_add_sub_cancel]
rw [sub_add_sub_cancel]
simp [hev, h]
rw [hq, eval_soln, zero_add]
rw [sq, right_distrib, mul_assoc]
rw [this]
rw [PadicInt.norm_mul]
exact mul_le_mul_of_nonneg_right (PadicInt.norm_le_one _) (norm_nonneg _)
simp [h]
rw [soln_deriv_norm] <;> apply soln_dist
rw [← this] <;> rfl
rw [add_comm] <;> simp [hz']
rw [hq, ha, zero_add]
rw [sq, right_distrib, mul_assoc]
simp [this]
rw [← this] <;> rfl
simp [deriv_ne_zero hnorm]
refine'
        ⟨soln _ _, eval_soln _ _, soln_dist_to_a_lt_deriv _ _, soln_deriv_norm _ _,
          soln_unique _ _⟩ <;>
      assumption
simp [hq, padicNorm]
simp [hq, padicNorm]
simp [padicNorm]
simp [padicNorm]
simp [padicNorm, (pos_of_gt hp).ne', padicValNat.self hp]
simp [padicNorm, hq]
simp [hq]
simp [padicNorm, hq]
simp [hq]
simp [hr]
simp [hp.1.NeZero]
simp [hr]
rw [← padicNorm.mul, div_mul_cancel _ hr]
simp [hz, zero_le_one]
simp [hq, max_eq_right hnrp, le_max_right]
simp [hr, max_eq_left hnqp, le_max_left]
rw [sub_eq_add_neg, ← padicNorm.neg r] <;> apply padicNorm.nonarchimedean
simp
apply le_of_not_gt
intro hgt
rw [max_eq_right_of_lt hgt] at this
apply not_lt_of_ge this
assumption
rw [← not_iff_not, ← int_eq_one_iff, eq_iff_le_not_lt]
simp only [padicNorm.of_int, true_and_iff]
simp only [← Int.coe_nat_dvd, ← int_eq_one_iff, Int.cast_ofNat]
simp only [← Int.coe_nat_dvd, ← int_lt_one_iff, Int.cast_ofNat]
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
rw [← coe_zero, Subtype.coe_inj]
infer_instance
infer_instance
simp [h]
simp [norm_def]
simp [norm_eq_zero]
simp only [norm_def, padicNormE.mul, PadicInt.coe_mul]
simp [norm_def]
simp
rw [pow_succ, pow_succ, norm_mul]
congr
apply norm_pow
rw [norm_add_eq_max_of_ne hne] <;> apply le_max_right
rw [norm_add_eq_max_of_ne hne] <;> apply le_max_left
simp [norm_def]
simp [norm_def]
simp
simp [Valuation]
rw [mul_comm, mul_inv hz]
simp
rw [lt_iff_le_and_ne] <;> simp [norm_le_one z, nonunits, is_unit_iff]
simp
rw [valuation_p_pow_mul _ _ this, le_add_iff_nonneg_right]
apply valuation_nonneg
rw [norm_def]
exact Padic.norm_le_pow_iff_norm_lt_pow_add_one _ _
rw [norm_le_pow_iff_norm_lt_pow_add_one, sub_add_cancel]
have := norm_le_pow_iff_mem_span_pow x 1
rw [Ideal.mem_span_singleton, pow_one] at this
rw [← this, norm_le_pow_iff_norm_lt_pow_add_one]
simp only [zpow_zero, Int.ofNat_zero, Int.ofNat_succ, add_left_neg, zero_add]
rw [← norm_int_le_pow_iff_dvd, norm_le_pow_iff_mem_span_pow, Ideal.mem_span_singleton]
simp only [mem_nonunits] <;> exact fun x y => norm_lt_one_add
rw [mul_comm, ← unit_coeff_spec hx]
rw [hn, Int.toNat_of_nonneg]
rw [Right.nonneg_neg_iff]
rw [Padic.norm_le_one_iff_val_nonneg, not_le] at hx
exact hx.le
intro h0
rw [h0, norm_zero] at hx
exact hx zero_le_one
rw [h]
simp [padicValNat]
have neq_one : ¬p = 1 ↔ True := iff_of_true (ne_of_lt hp).symm trivial
have eq_zero_false : p = 0 ↔ False := iff_false_intro (ne_of_lt (trans zero_lt_one hp)).symm
simp [padicValNat, neq_one, eq_zero_false]
simp only [padicValNat, dite_eq_right_iff, PartEnat.get_eq_iff_eq_coe, Nat.cast_zero,
    multiplicity_eq_zero, and_imp, pos_iff_ne_zero, Ne.def, ← or_iff_not_imp_left]
apply multiplicity.finite_int_iff.2
simp [hp, hz]
rw [padicValInt, padicValNat, dif_pos (And.intro hp (Int.natAbs_pos_of_ne_zero hz))]
simp only [multiplicity.Int.nat_abs p z]
rfl
simp [padicValInt]
simp [padicValInt]
simp [padicValInt]
simp [padicValNat.self hp]
simp [padicValRat, padicValInt]
simp [padicValRat]
simp [padicValRat]
simp [padicValRat]
rw [of_int, padicValInt.of_ne_one_ne_zero hp hz]
rw [← finite_iff_dom, finite_nat_iff]
exact ⟨hp, q.pos⟩
rw [padicValRat, padicValInt.of_ne_one_ne_zero hp, padicValNat, dif_pos]
· rfl
· exact ⟨hp, q.pos⟩
· exact Rat.num_ne_zero_of_ne_zero hq
simp [padicValRat]
simp [hp]
simp
simp
simp [padicValNat, hp, hn]
simp [padic_val_nat_def (Fact.out p.prime).Pos]
simp [finite_int_iff, Ne.symm (ne_of_lt hp.1.one_lt)]
simp_all
simp_all
have hd : d ≠ 0 := Rat.mk_denom_ne_zero_of_ne_zero hqz qdf
let ⟨c, hc1, hc2⟩ := Rat.num_denom_mk hd qdf
rw [padicValRat.multiplicity_sub_multiplicity] <;>
    simp [hc1, hc2, multiplicity.mul' (Nat.prime_iff_prime_int.1 hp.1),
      Ne.symm (ne_of_lt hp.1.one_lt), hqz, pos_iff_ne_zero, int.coe_nat_multiplicity p q.denom]
rw [Rat.num_denom] <;> exact hq
rw [Rat.num_denom] <;> exact hr
induction k <;> simp [*, padicValRat.mul hq (pow_ne_zero _ hq), pow_succ, add_mul, add_comm]
rw [div_eq_mul_inv, padicValRat.mul hq (inv_ne_zero hr), padicValRat.inv r, sub_eq_add_neg]
all_goals exact hp
have hf1 : Finite (p : ℤ) (n₁ * d₂) := finite_int_prime_iff.2 (mul_ne_zero hn₁ hd₂)
have hf2 : Finite (p : ℤ) (n₂ * d₁) := finite_int_prime_iff.2 (mul_ne_zero hn₂ hd₁)
conv => 
    lhs
    rw [padicValRat.defn p (Rat.mk_ne_zero_of_ne_zero hn₁ hd₁) rfl,
      padicValRat.defn p (Rat.mk_ne_zero_of_ne_zero hn₂ hd₂) rfl, sub_le_iff_le_add', ←
      add_sub_assoc, le_sub_iff_add_le]
simp [hr]
rw [@multiplicity.mul _ _ _ _ (_ * _) _ (Nat.prime_iff_prime_int.1 hp.1), add_comm]
rw [mul_assoc,
                  @multiplicity.mul _ _ _ _ (q.denom : ℤ) (_ * _)
                    (Nat.prime_iff_prime_int.1 hp.1)] <;>
                exact add_le_add_left h _
rw [min_eq_left h] <;> exact le_padic_val_rat_add_of_le hqr h
rw [padicValNat.div_of_dvd dvd, padicValNat.prime_pow]
exact hp
rw [padicValNat.div_of_dvd dvd, eq_zero_of_not_dvd (hp.out.coprime_iff_not_dvd.mp cpm),
      Nat.sub_zero] <;>
    assumption
rw [pow_dvd_iff_le_multiplicity, ← padic_val_nat_def' hp.out.ne_one ha.bot_lt,
    PartEnat.coe_le_coe]
rw [padicValInt, ← Int.natAbs_eq_zero, ← padic_val_nat_dvd_iff, ← Int.coe_nat_dvd_left,
    Int.coe_nat_pow]
rw [padic_val_int_dvd_iff]
exact Or.inr le_rfl
rw [padicValInt.mul ha (int.coe_nat_ne_zero.mpr hp.out.ne_zero)]
simp only [eq_self_iff_true, padicValInt.of_nat, padic_val_nat_self]
exact hp
simp
simp
simp
simp
simp
simp [x0]
simp [x0]
rw [← nat_coe_nat ζ, coe_zeta_mul_apply]
rw [← nat_coe_nat ζ, coe_mul_zeta_apply]
simp
rw [map_zero]
exact zero_pow (Nat.pos_of_ne_zero h0)
rw [ppow, dif_pos rfl]
rw [ppow, dif_neg (ne_of_gt kpos)]
rfl
simp [h]
simp [cop, h]
simp [h]
simp [cop, h]
simp [hf, hg]
simp [hf, hg]
cases k
· simp [pow]
simp [pow, (ne_of_lt (Nat.succ_pos k)).symm]
simp
simp [sigma_apply]
simp [sigma_apply]
rw [sigma_zero_apply, divisors_prime_pow hp, card_map, card_range]
simp
simp
simp (config := { contextual := true })
rw [← zeta_mul_pow_eq_sigma]
apply is_multiplicative_zeta.mul is_multiplicative_pow
simp
simp [card_factors]
rw [card_factors_apply, card_factors_apply, card_factors_apply, ← Multiset.coe_card, ← factors_eq,
    UniqueFactorizationMonoid.normalized_factors_mul m0 n0, factors_eq, factors_eq,
    Multiset.card_add, Multiset.coe_card, Multiset.coe_card]
revert h0
apply s.induction_on
· simp
intro a t h h0
rw [Multiset.prod_cons, mul_ne_zero_iff] at h0
simp [h0, card_factors_mul, h]
rw [card_factors_apply, hp.factors_pow, List.length_repeat]
simp
simp
simp [card_distinct_factors]
rw [squarefree_iff_nodup_factors h0, card_distinct_factors_apply]
constructor <;> intro h
· rw [← n.factors.dedup_sublist.eq_of_length h]
    apply List.nodup_dedup
· rw [h.dedup]
    rfl
rw [card_distinct_factors_apply, hp.factors_pow, List.repeat_dedup hk, List.length_singleton]
rw [← pow_one p, card_distinct_factors_apply_prime_pow hp one_ne_zero]
simp
simp
rw [moebius_apply_of_squarefree hp.squarefree, card_factors_apply_prime hp, pow_one]
simp
rw [mul_comm, moebius_mul_coe_zeta]
rw [← coe_coe, ← int_coe_mul, moebius_mul_coe_zeta, int_coe_one]
rw [← coe_coe, ← int_coe_mul, coe_zeta_mul_moebius, int_coe_one]
rw [sum_eq_iff_sum_smul_moebius_eq]
apply forall_congr'
refine' fun a => imp_congr_right fun _ => ((sum_congr rfl) fun x hx => _).congr_left
rw [zsmul_eq_mul]
apply order_of_eq_of_pow_and_pow_div_prime _ ha hd
exact tsub_pos_of_lt hp1
rw [← pow_succ, hp', ha]
rw [← mem_span_singleton, ← Ideal.Quotient.eq] at h
simp only [← mem_span_singleton, ← eq_zero_iff_mem, RingHom.map_geom_sum₂, h, geom_sum₂_self,
    _root_.map_mul, map_pow, map_nat_cast]
simp only [mul_pow, dvd_mul_right]
simp only [sq_dvd_add_pow_sub_sub (↑p * b) a i, ← sub_sub]
rw [add_right_inj, Finset.sum_congr rfl]
intro x hx
rw [← Nat.add_sub_assoc _ x, Nat.add_sub_cancel_left]
exact Nat.le_pred_of_lt (finset.mem_range.mp hx)
simp only [add_right_inj, Finset.sum_const, Finset.card_range, nsmul_eq_mul]
rw [← Nat.add_sub_assoc (Nat.le_pred_of_lt (finset.mem_range.mp hx))]
exact congr_arg Nat.pred (Nat.add_sub_cancel_left _ _)
rw [← geom_sum₂_mul, multiplicity.mul hp, multiplicity_eq_zero.2 (not_dvd_geom_sum₂ hp hxy hx hn),
    zero_add]
rw [← geom_sum₂_mul, multiplicity.mul hp, geom_sum₂_eq_one hp hp1 hxy hx, add_comm]
rw [← sub_neg_eq_add] at hxy
rw [← sub_neg_eq_add, ← sub_neg_eq_add, ← Odd.neg_pow hn]
exact int.pow_sub_pow hp hp1 hxy hx n
rw [this, hd, Finset.prod_range_succ, ← mul_assoc, mul_comm (x ^ 2 ^ d + y ^ 2 ^ d)]
simp only [pow_two_pow_sub_pow_two_pow n, multiplicity.mul Int.prime_two,
    multiplicity.Finset.prod Int.prime_two, add_comm, Nat.cast_one, Finset.sum_const,
    Finset.card_range, nsmul_one, Int.two_pow_two_pow_add_two_pow_two_pow hx hxy]
rw [this, add_comm (1 : PartEnat), ← add_assoc]
rw [← mod_add_mod, r, mod_self]
intro p_div_fact
exact lt_le_antisymm p_big (is_prime.dvd_factorial.mp p_div_fact)
rw [filter_union]
simp only [Finset.disjoint_left, and_imp, Finset.mem_Ico, not_lt, Finset.mem_range]
intro _ pr _
exact pr
rw [choose_symm_half m]
rw [two_mul, ← twice_m]
injection h <;> constructor <;> assumption
congr <;> assumption
simp [bit1]
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
simp only [Zsqrtd.ext, Zsqrtd.conj_re, Zsqrtd.conj_im, Zsqrtd.one_im, neg_zero, eq_self_iff_true,
    and_self_iff]
simp only [ext, true_and_iff, conj_re, eq_self_iff_true, neg_neg, conj_im]
decide
cases n <;> rfl
cases n <;> rfl
simp [ext]
simp [ext]
simp [ext, of_int_re, of_int_im]
simp [ext]
simp
simp
simp [ext]
simp [ext]
simp [ext]
simp [ext]
simp [ext, sub_eq_add_neg, mul_comm]
rw [ext] at h⊢
apply And.imp _ _ h <;>
    · simp only [smul_re, smul_im]
      exact Int.eq_of_mul_eq_mul_left ha
simp only [Int.gcd_eq_zero_iff, ext, eq_self_iff_true, zero_im, zero_re]
simp only [ext, hre, eq_self_iff_true, zero_im, him, and_self_iff, zero_re]
rw [← coe_int_dvd_iff]
apply dvd_trans _ hdvd
rw [coe_int_dvd_iff]
exact ⟨hzdvdu, hzdvdv⟩
have xz := sq_le_add_mixed xy zw
simp [sq_le, mul_assoc] at xy zw
simp [sq_le, mul_add, mul_comm, mul_left_comm, add_le_add, *]
apply le_of_not_gt
intro l
refine' not_le_of_gt _ h
simp [sq_le, mul_add, mul_comm, mul_left_comm, add_assoc]
have hm := sq_le_add_mixed zw (le_of_lt l)
simp [sq_le, mul_assoc] at l zw
exact
    lt_of_le_of_lt (add_le_add_right zw _)
      (add_lt_add_left (add_lt_add_of_le_of_lt hm (add_lt_add_of_le_of_lt hm l)) _)
induction x <;> induction y <;> rfl
simp [sq_le, Nat.zero_le]
rw [← Int.negSucc_coe] <;> rfl
rw [nonnegg_comm] <;> exact nonnegg_neg_pos
simp [norm]
simp [norm]
simp [norm]
cases n <;> simp [norm, conj, Zsqrtd.ext, mul_comm, sub_eq_add_neg]
simp only [norm_eq_mul_conj, conj_neg, neg_mul, mul_neg, neg_neg]
simp only [norm_eq_mul_conj, conj_conj, mul_comm]
rw [mul_assoc, neg_mul_eq_neg_mul] <;> exact mul_nonneg (neg_nonneg.2 hd) (mul_self_nonneg _)
let ⟨y, hy⟩ := isUnit_iff_dvd_one.1 h
have := congr_arg (Int.natAbs ∘ norm) hy
rw [Function.comp_apply, Function.comp_apply, norm_mul, Int.natAbs_mul, norm_one,
      Int.natAbs_one, eq_comm, Nat.mul_eq_one_iff] at this
exact this.1
rw [Int.isUnit_iff_natAbs_eq, norm_eq_one_iff]
rw [← norm_eq_one_iff, ← Int.coe_nat_inj', Int.natAbs_of_nonneg (norm_nonneg hd z), Int.ofNat_one]
simp [add_comm, *]
simp [add_comm, *]
simp [*]
simp
simp only [sub_self]
simp [Int.negSucc_coe, add_assoc]
simp [Int.negSucc_coe, add_assoc]
simp [Int.negSucc_coe, add_assoc]
simp
rw [add_sub_add_left_eq_sub] <;> exact ab
rw [smul_val] <;> trivial
rw [decompose, right_distrib, mul_assoc] <;> rfl
rw [mul_comm] <;> exact nonneg_mul_lem ha
rw [mul_comm] <;> exact nonneg_mul_lem ha
simp [add_comm]
simp [add_comm]
simp [add_comm]
simp [add_comm]
rw [this] <;> apply dvd_mul_right
simp [this]
have t := (divides_sq_eq_zero e).left <;> contradiction
decide
decide
let t := le_antisymm yx xy
rw [one_mul] at t <;> exact absurd t (not_divides_sq _ _)
let t := le_antisymm xy yx
rw [one_mul] at t <;> exact absurd t (not_divides_sq _ _)
rw [neg_sub] <;> exact ab
simp [h2, mul_assoc, mul_left_comm]
simp [h1, mul_assoc, mul_left_comm]
simp [h1, mul_assoc, mul_left_comm]
simp [h2, mul_assoc, mul_left_comm]
decide
infer_instance
infer_instance
rw [h, norm_zero]
simp
simp
rw [← f.map_mul, dmuld, map_int_cast]
simp
simp [to_complex_def]
apply Complex.ext <;> simp [to_complex_def]
simp [to_complex_def]
simp [to_complex_def]
simp [to_complex_def]
simp [to_complex_def]
cases x <;> cases y <;> simp [to_complex_def₂]
rw [← to_complex_zero, to_complex_inj]
rw [Zsqrtd.norm, norm_sq] <;> simp
cases x <;> rw [Zsqrtd.norm, norm_sq] <;> simp
rw [← @Int.cast_inj ℝ _ _ _] <;> simp
rw [lt_iff_le_and_ne, Ne.def, eq_comm, norm_eq_zero] <;> simp [norm_nonneg]
rw [← Int.cast_ofNat, coe_nat_abs_norm]
simp
simp [Zsqrtd.norm]
simp [div_eq_mul_inv]
rw [div_def, ← @Rat.round_cast ℝ _ _] <;>
    simp [-Rat.round_cast, mul_assoc, div_eq_mul_inv, mul_add, add_mul]
rw [div_def, ← @Rat.round_cast ℝ _ _, ← @Rat.round_cast ℝ _ _] <;>
    simp [-Rat.round_cast, mul_assoc, div_eq_mul_inv, mul_add, add_mul]
rw [norm_sq_apply, norm_sq_apply, ← _root_.abs_mul_self, _root_.abs_mul, ←
      _root_.abs_mul_self y.re, _root_.abs_mul y.re, ← _root_.abs_mul_self x.im,
      _root_.abs_mul x.im, ← _root_.abs_mul_self y.im, _root_.abs_mul y.im] <;>
    exact
      add_le_add (mul_self_le_mul_self (abs_nonneg _) hre) (mul_self_le_mul_self (abs_nonneg _) him)
apply Complex.ext <;> simp
simp [mod_def]
rw [← norm_sq_mul, mul_sub, mul_div_cancel' _ this]
simp
simp [-Int.ofNat_lt, norm_mod_lt x hy]
rw [coe_nat_abs_norm] <;> exact Int.add_one_le_of_lt (norm_pos.2 hy)
decide
simp [div_def]
rfl
simp [mod_def]
decide
decide
decide
refine' ⟨k.val, k.val_lt, Zmod.nat_cast_zmod_val k⟩
rw [pow_two, ← CharP.cast_eq_zero_iff (Zmod p) p, Nat.cast_add, Nat.cast_mul, Nat.cast_one,
          ← hk, add_left_neg]
simp [sq, Zsqrtd.ext]
simp [add_comm, mul_add]
rw [hx]
decide
rw [hx]
decide
rw [norm_nat_cast, Int.natAbs_mul, Nat.mul_eq_one_iff] <;>
              exact fun h => (ne_of_lt hp.1.one_lt).symm h.1
rw [← hkmul, ← Nat.cast_mul p, ← hy] <;> simp
rw [norm_nat_cast, Int.natAbs_mul, Nat.mul_eq_one_iff] <;>
        exact fun h => (ne_of_lt hp.1.one_lt).symm h.1
rw [← Int.coe_nat_inj', Int.coe_nat_pow, sq, ← @norm_nat_cast (-1), hpab] <;> simp
decide
simp
intro k hk
refine' le_of_not_lt fun hnk => _
exact hgt (hk.trans (Ideal.pow_le_pow hnk))
refine' fun k hk => le_of_not_lt fun hnk => _
exact hgt (hk.trans (Ideal.pow_le_pow hnk))
simp
simp
have hPirr := (Ideal.prime_of_is_prime hP0 hP).Irreducible
refine' ramification_idx_spec (Ideal.le_of_dvd _) (mt ideal.dvd_iff_le.mpr _) <;>
    rw [dvd_iff_normalized_factors_le_normalized_factors (pow_ne_zero _ hP0) hp0,
      normalized_factors_pow, normalized_factors_irreducible hPirr, normalize_eq,
      Multiset.nsmul_singleton, ← Multiset.le_count_iff_repeat_le]
· exact (Nat.lt_succ_self _).not_le
rw [is_dedekind_domain.ramification_idx_eq_normalized_factors_count hp0 hP hP0,
    factors_eq_normalized_factors]
have := ideal.quotient.subsingleton_iff.mp hQ
subst this
exact dif_neg fun h => hp.ne_top <| h.symm.trans comap_top
intro i hi
exact (congr_arg _ (dif_pos hi)).trans (hg'' i hi)
  -- Because `R/I` is nontrivial, we can lift `g` to a nontrivial linear dependence in `S`.
simp only [FractionalIdeal.mem_coe_ideal, not_exists, not_and'] at hgI
exact hgI _ (hg' j hjs)
rw [LinearMap.map_sum, ← smul_zero a, ← Eq, Finset.smul_sum, Finset.sum_congr rfl]
intro i hi
rw [LinearMap.map_smul, ← IsScalarTower.algebra_map_smul K, hg' i hi, ← smul_assoc, smul_eq_mul]
infer_instance
rw [IsScalarTower.algebra_map_eq R K L]
exact (algebraMap K L).Injective.comp (NoZeroSmulDivisors.algebra_map_injective R K)
  -- Let `M` be the `R`-module spanned
rw [Submodule.map_smul'', Submodule.map_top, M.range_mkq]
rw [Ideal.smul_top_eq_map, (Submodule.map_mkq_eq_top M _).mpr hb']
      
  -- we can write the elements of `a` as `p`-linear combinations of other elements of `a`.
intros
simp only [A, Pi.sub_apply, sub_smul, Finset.sum_sub_distrib, hA', Matrix.one_apply, ite_smul,
      one_smul, zero_smul, Finset.sum_ite_eq, Finset.mem_univ, if_true, sub_self]
  -- since `span S {det A} / M = 0`.
rw [RingHom.map_det, RingHom.map_matrix_apply]
rw [Matrix.det_neg, Fintype.card_fin, Matrix.det_one, mul_one]
apply Quotient.map'_mk'
simp
rw [finrank_prime_pow_ramification_idx, inertia_deg_algebra_map]
exact factors.ne_bot p P
rw [inertia_deg_algebra_map]
exact (finite_dimensional.finrank_pos_iff.mpr inferInstance).ne'
refine' FiniteDimensional.finite_dimensional_of_finrank _
rw [pos_iff_ne_zero, factors.finrank_pow_ramification_idx]
exact mul_ne_zero (factors.ramification_idx_ne_zero p P) (factors.inertia_deg_ne_zero p P)
rw [is_dedekind_domain.ramification_idx_eq_factors_count hp (factors.is_prime p P)
            (factors.ne_bot p P)]
rw [IsScalarTower.algebra_map_eq R K L, RingHom.coe_comp]
exact (RingHom.injective _).comp (IsFractionRing.injective R K)
refine' Function.Injective.of_comp (show Function.Injective (algebraMap S L ∘ _) from _)
rw [← RingHom.coe_comp, ← IsScalarTower.algebra_map_eq]
exact inj_RL
simp [proper_divisors]
rw [divisors, proper_divisors, Ico_succ_right_eq_insert_Ico h, Finset.filter_insert,
    if_pos (dvd_refl n)]
simp
cases m
· apply dvd_zero
· simp [mem_divisors.1 h]
cases m
· simp
simp only [mem_divisors, m.succ_ne_zero, and_true_iff, Ne.def, not_false_iff]
exact Nat.le_of_dvd (Nat.succ_pos m)
apply Finset.subset_iff.2
intro x hx
exact
    Nat.mem_proper_divisors.2
      ⟨(Nat.mem_divisors.1 hx).1.trans h,
        lt_of_le_of_lt (divisor_le hx)
          (lt_of_le_of_ne (divisor_le (Nat.mem_divisors.2 ⟨h, hzero⟩)) hdiff)⟩
rw [proper_divisors, Ico_self, filter_empty]
cases m
· rw [mem_divisors, zero_dvd_iff] at h
    cases h.2 h.1
apply Nat.succ_pos
rw [mem_proper_divisors, and_iff_right (one_dvd _)]
rw [mem_divisors_antidiagonal, mem_divisors_antidiagonal, mul_comm, Prod.swap]
rw [mem_divisors_antidiagonal] at h
simp [Dvd.intro _ h.1, h.2]
rw [mem_divisors_antidiagonal] at h
simp [Dvd.intro_left _ h.1, h.2]
rw [← map_swap_divisors_antidiagonal, map_eq_image, image_image]
exact image_fst_divisors_antidiagonal
apply Finset.map_injective (Equiv.prodComm _ _).toEmbedding
rw [map_swap_divisors_antidiagonal, ← map_div_right_divisors, Finset.map_map]
rfl
cases n
· simp
·
    rw [divisors_eq_proper_divisors_insert_self_of_pos (Nat.succ_pos _),
      Finset.sum_insert proper_divisors.not_self_mem, add_comm]
rw [perfect_iff_sum_proper_divisors h, sum_divisors_eq_sum_proper_divisors_add_self, two_mul]
constructor <;> intro h
· rw [h]
· apply add_right_cancel h
rw [mem_divisors, Nat.dvd_prime_pow pp, and_iff_left (ne_of_gt (pow_pos pp.pos k))]
rw [← erase_insert proper_divisors.not_self_mem, ←
    divisors_eq_proper_divisors_insert_self_of_pos pp.pos, pp.divisors, pair_comm,
    erase_insert fun con => pp.ne_one (mem_singleton.1 con)]
simp [h.proper_divisors]
rw [divisors_eq_proper_divisors_insert_self_of_pos h.pos,
    prod_insert proper_divisors.not_self_mem, h.prod_proper_divisors]
have h1 := mem_singleton.2 rfl
rw [← h, mem_proper_divisors] at h1
refine' nat.prime_def_lt''.mpr ⟨h1.2, fun m hdvd => _⟩
rw [← mem_singleton, ← h, mem_proper_divisors]
have hle := Nat.le_of_dvd (lt_trans (Nat.succ_pos _) h1.2) hdvd
exact Or.imp_left (fun hlt => ⟨hdvd, hlt⟩) hle.lt_or_eq
cases n
· simp [Nat.not_prime_zero]
cases n
· simp [Nat.not_prime_one]
rw [← proper_divisors_eq_singleton_one_iff_prime]
refine' ⟨fun h => _, fun h => h.symm ▸ sum_singleton⟩
rw [@eq_comm (Finset ℕ) _ _]
apply
    eq_proper_divisors_of_subset_of_sum_eq_sum
      (singleton_subset_iff.2
        (one_mem_proper_divisors_iff_one_lt.2 (succ_lt_succ (Nat.succ_pos _))))
      (Eq.trans sum_singleton h.symm)
simp [h, proper_divisors_prime_pow]
simp [h, divisors_prime_pow]
rw [← map_div_right_divisors, Finset.prod_map]
rfl
rw [← map_swap_divisors_antidiagonal, Finset.prod_map]
exact prod_divisors_antidiagonal fun i j => f j i
simp
rw [← map_nat_cast f, eq_zero_iff_mem, mem_span_singleton]
rw [← zero_sub]
exact (IsPoly.const 0).sub
rw [← sub_neg_eq_add]
exact hf.sub hg.neg
rw [sumsq] <;> simp [-add_comm] <;> exact add_nonneg (mul_self_nonneg _) (sumsq_nonneg ps)
simp [this] at h <;> exact h
rw [h1, h2] <;> rfl
simp <;> apply IsPoly.proj
simp <;> apply IsPoly.const
simp <;> apply IsPoly.sub pf pg
simp <;> apply IsPoly.mul pf pg
simp [this]
simp <;> exact ⟨fun ⟨t⟩ => Empty.rec _ t, trivial⟩
refine' congr_arg Dioph (Set.ext fun v => _) <;> exact pfun.lift_graph.symm
dsimp
exact Int.eq_natAbs_iff_mul_eq_zero
simp <;>
      exact
        ⟨proj_dioph none,
          (vector_allp_iff_forall _ _).2 fun i =>
            reindex_dioph_fn _ <| (vector_allp_iff_forall _ _).1 dg _⟩
dsimp
exact lt_or_lt_iff_ne
rw [← e] <;>
                exact
                  ⟨or_iff_not_imp_left.2 fun h => mod_lt _ (Nat.pos_of_ne_zero h), x / y,
                    mod_add_div _ _⟩
rw [y0, Nat.div_zero] <;>
                      exact
                        ⟨fun o => (o.resolve_right fun ⟨_, h2⟩ => Nat.not_lt_zero _ h2).right,
                          fun z0 => Or.inl ⟨rfl, z0⟩⟩
rw [le_tsub_iff_left (one_le_two.trans (hkey _).le)]
exact (hkey _).le
rw [bernoulli'_def', ← Fin.sum_univ_eq_sum_range]
rfl
rw [sum_range_succ_comm, bernoulli'_def n, tsub_self]
conv in n.choose (_ - _) => rw [choose_symm (mem_range.1 H).le]
simp only [one_mul, cast_one, sub_self, sub_add_cancel, choose_zero_right, zero_add, div_one]
refine' ((sum_antidiagonal_eq_sum_range_succ_mk _ n).trans _).trans (bernoulli'_spec n)
refine' sum_congr rfl fun x hx => _
simp only [add_tsub_cancel_of_le, mem_range_succ_iff.mp hx, cast_sub]
decide
  -- shrug
simp [bernoulli, ← mul_assoc, ← sq, ← pow_mul, mul_comm n 2, pow_mul]
simp [bernoulli]
simp [mem_antidiagonal, add_comm]
simp [add_comm]
  -- key equation: the corresponding fact for `bernoulli'`
simp
rw [mul_div_right_comm, mul_div_cancel _ hne]
rw [bernoulli_eq_bernoulli'_of_ne_one (succ_succ_ne_one i)]
simp [sum_Ico_eq_sub _ hle, succ_ne_zero]
    -- extract the last term of the sum
rw [sum_range_succ]
    -- apply the key lemma, `sum_range_pow`
simp [f, sum_range_pow]
    -- extract the first two terms of the sum
rw [h2]
    -- convert from `bernoulli` to `bernoulli'`
decide
decide
simp
simp
rw [Int.ofNat_sub this] <;> rfl
rw [Int.ofNat_sub (Int.le_of_ofNat_le_ofNat <| Int.le.intro_sub h)] <;> exact h
rw [← Int.ofNat_sub <| le_of_lt <| Nat.lt_of_sub_eq_succ h, h] <;> rfl
simp [mul_comm, mul_left_comm, Zsqrtd.conj_mul, Pell.is_pell_norm.1 hb,
        Pell.is_pell_norm.1 hc]
simp [is_pell, Zsqrtd.conj]
simp [Zsqrtd.ext]
let o := is_pell_one
simp <;> exact Pell.is_pell_mul (is_pell_pell_zd n) o
rw [Int.ofNat_sub hl] <;> exact h
rw [← h] <;> exact Nat.succ_pred_eq_of_pos (asq_pos a1)
rw [← this] <;> exact Nat.lt_succ_self _
rw [this] <;> exact Nat.mul_self_le_mul_self na
simp [pow_succ'] <;>
      exact le_trans (Nat.mul_le_mul_right _ (xn_ge_a_pow n)) (Nat.le_add_right _ _)
rw [← mul_two]
exact Nat.mul_le_mul_left _ a1
simp <;> exact Nat.pred_le _
rw [← a1m] <;> exact mul_le_mul_of_nonneg_right ha am1p
rw [mul_assoc, Eq.trans (mul_comm _ _) a1m] <;> simp
have t := mul_le_mul_of_nonneg_left hn (le_trans zero_le_one h1) <;>
                  rw [bm, mul_one] at t <;>
                exact h1l t
have t :=
                      mul_le_mul_of_nonneg_right
                        (mul_le_mul_of_nonneg_left hn (le_trans zero_le_one h1)) a1p <;>
                    rw [bm, one_mul, mul_assoc, Eq.trans (mul_comm _ _) a1m, mul_one] at t <;>
                  exact ha t
rw [Zsqrtd.coe_nat_val] <;>
        exact
          Zsqrtd.le_of_le_le (Int.ofNat_le_ofNat_of_le <| le_of_lt <| n_lt_xn _ _)
            (Int.ofNat_zero_le _)
rw [zero_tsub] at hp <;> contradiction
rw [← add_assoc, pell_zd_succ, pell_zd_succ, pell_zd_add n, ← mul_assoc]
let t := pell_zd_add n (m - n)
rw [add_tsub_cancel_of_le h] at t <;>
    rw [t, mul_comm (pell_zd _ n) _, mul_assoc, (is_pell_norm _).1 (is_pell_pell_zd _ _), mul_one]
rw [sub_eq_add_neg, ← mul_neg]
exact congr_arg Zsqrtd.re (pell_zd_sub a1 h)
rw [sub_eq_add_neg, ← mul_neg, mul_comm, add_comm]
exact congr_arg Zsqrtd.im (pell_zd_sub a1 h)
let p := pell_eq n
rw [← p] <;>
      exact Nat.dvd_sub (le_of_lt <| Nat.lt_of_sub_eq_succ p) (kx.mul_left _) (ky.mul_left _)
rw [e]
rw [e]
rw [Nat.mul_succ, yn_add] <;> exact dvd_add (dvd_mul_left _ _) ((y_mul_dvd k).mul_right _)
rw [e, Nat.mod_zero] at hp <;> rw [e] at h <;>
              exact ne_of_lt (strict_mono_y a1 hp) (eq_zero_of_zero_dvd h).symm
rw [e] <;> apply y_mul_dvd
constructor <;> simp
simp [pow_succ']
simp [-mul_comm, -mul_assoc]
rw [pow_succ']
exact hx.mul_right' _
simp [pow_succ]
simp [mul_dvd_mul_left, mul_assoc]
simp [pow_succ]
delta xz <;> rw [← Int.ofNat_add, ← Int.ofNat_mul, xn_succ_succ]
delta yz <;> rw [← Int.ofNat_add, ← Int.ofNat_mul, yn_succ_succ]
simp
simp
simp
simp
simp [xz, yz, Int.ofNat_zero, Int.ofNat_one]
simp [xz, yz, Int.ofNat_zero, Int.ofNat_one]
simp [add_mul, mul_assoc]
rw [two_mul, add_assoc, xn_add, add_assoc, ← zero_add 0]
refine' (dvd_mul_right (xn a1 n) (xn a1 (n + j))).modeq_zero_nat.add _
rw [yn_add, left_distrib, add_assoc, ← zero_add 0]
exact
    ((dvd_mul_right _ _).mul_left _).modeq_zero_nat.add (xn_modeq_x2n_add_lem _ _ _).modeq_zero_nat
rw [tsub_add_cancel_of_le h, two_mul] <;> exact Nat.add_le_add_left jn _
rw [add_comm] <;> exact (xn_modeq_x2n_add _ _ _).symm
rw [Nat.succ_mul] <;> apply Nat.le_add_left
rw [add_comm] <;> exact (xn_modeq_x2n_sub _ h).symm
rw [h] <;> exact this
have : n = 0 :=
        n.eq_zero_or_pos.resolve_right fun np =>
          ne_of_lt
            (lt_of_le_of_lt (Nat.mul_le_mul_left _ a1)
              (Nat.lt_add_of_pos_right <| mul_pos (d_pos a1) (strict_mono_y a1 np)))
            h
cases this <;> simp at h <;> exact ⟨h.symm, rfl⟩
rw [tsub_add_cancel_of_le]
rw [two_mul] <;> exact add_lt_add_left kn n
exact k2n
rw [this, Int.ofNat_sub xle]
rw [two_mul, tsub_add_eq_tsub_tsub, add_tsub_cancel_right]
rw [tsub_add_cancel_of_le (succ_le_of_lt npos)]
apply Nat.le_of_succ_le_succ
rw [npm]
exact lin
decide
rw [lem2 j jn (le_of_lt j2n), lem2 (j + 1) (Nat.le_succ_of_le jn) j2n]
refine' sub_lt_sub_left (Int.ofNat_lt_ofNat_of_lt <| strict_mono_x _ _) _
rw [Nat.sub_succ]
exact Nat.pred_lt (ne_of_gt <| tsub_pos_of_lt j2n)
simp_all
decide
decide
decide
rw [this, add_tsub_cancel_of_le j4n]
rw [tsub_add_cancel_of_le j4n, show 4 * n = 2 * n + 2 * n from right_distrib 2 2 n] <;>
          exact Nat.add_le_add_left (le_of_lt j2n) _
decide
decide
delta modeq <;> rw [Nat.mod_eq_of_lt jl]
rw [ji]
exact dvd_rfl.modeq_zero_nat
rw [← Nat.mod_add_div j (4 * n)]
exact this j' _
constructor <;> rfl
simp <;> exact ⟨h, modeq.refl 1⟩
rw [xn_succ_succ a1, xn_succ_succ b1]
exact (h.mul_left _).mul (xy_modeq_of_modeq (n + 1)).left
rw [yn_succ_succ a1, yn_succ_succ b1]
exact (h.mul_left _).mul (xy_modeq_of_modeq (n + 1)).right
rw [k0] <;> exact ⟨le_rfl, Or.inl ⟨rfl, rfl⟩⟩
delta modeq at ba <;> rw [Nat.mod_eq_of_lt this] at ba <;> rw [← ba] <;>
              apply Nat.mod_le
rw [Int.ofNat_sub (le_of_lt b1)] <;> exact bm1.symm.dvd
          (yn_modeq_a_sub_one _ _).modeq_of_dvd this
        ⟨ky,
          Or.inr
            ⟨u, v, s, t, b, pell_eq _ _, pell_eq _ _, pell_eq _ _, b1, bm1, ba, vp, yv, sx, tk⟩⟩
rw [y0] at ky <;> rw [Nat.eq_zero_of_le_zero ky, x1, y0] <;> exact ⟨rfl, rfl⟩
simp [i0] at ky <;> rw [i0, ky] <;> exact ⟨rfl, rfl⟩
rw [Int.ofNat_sub (le_of_lt b1)] <;> exact bm1.symm.dvd
                  ((yn_modeq_a_sub_one b1 _).modeq_of_dvd this).symm.trans tk
decide
decide
rw [sub_sub] <;> apply le_sub_right_of_add_le <;> apply Int.ofNat_le_ofNat_of_le <;>
          have y1 := Nat.pow_le_pow_of_le_right ypos k0 <;>
        simp at y1 <;>
      exact this (lt_of_le_of_lt y1 yak)
rw [k0] <;> exact Or.inl ⟨rfl, rfl⟩
rw [n0, zero_pow kpos] <;> exact Or.inl ⟨rfl, rfl⟩
apply modeq_of_dvd
rw [Int.ofNat_add, Int.ofNat_mul, Int.ofNat_sub na, ← te]
exact x_sub_y_dvd_pow a1 n k
rw [← te] <;> exact nt
rw [← ze] <;> exact pell_eq w1 w
rw [k0, m1] <;> rfl
rw [n0, m0, zero_pow kpos]
rw [j0] at xj <;> exact xj
rw [a1] at ta <;> exact ta
rw [mul_comm n 2, this] <;> apply Nat.le_add_left
rw [xj] <;> exact le_trans (le_trans nw wj) (le_of_lt <| n_lt_xn _ _)
rw [sub_sub] <;> apply eq_sub_of_add_eq <;> apply (Int.ofNat_inj _ _).2 <;>
              exact ta.symm
have := x_sub_y_dvd_pow a1 n k <;> rw [← te, ← Int.ofNat_sub na] at this <;>
              exact modeq_of_dvd this
rw [lt_div_iff hn', Int.cast_add, Int.cast_one]
exact Int.lt_floor_add_one _
simp [← div_mul_div_comm, ← r.cast_def, mul_comm]
rw [mul_comm, mul_rat_iff hr]
rw [← Rat.cast_coe_int, mul_rat_iff (Int.cast_ne_zero.2 hm)]
rw [mul_comm, mul_int_iff hm]
rw [← Rat.cast_coe_nat, mul_rat_iff (Nat.cast_ne_zero.2 hn)]
rw [mul_comm, mul_nat_iff hn]
rw [mul_comm]
exact h.mul_nat hn
simp [add_div, hr.ne', mul_div_mul_left, mul_div_mul_right, hn', ← Rat.cast_def]
rw [add_comm, add_rat_iff]
rw [← Rat.cast_coe_int m, add_rat_iff]
rw [add_comm, add_int_iff]
rw [← Rat.cast_coe_nat n, add_rat_iff]
rw [add_comm, add_nat_iff]
rw [sub_eq_add_neg, ← Rat.cast_neg, add_rat_iff]
rw [← Rat.cast_coe_int, sub_rat_iff]
rw [← Rat.cast_coe_nat, sub_rat_iff]
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
simp only [one_div]
exact tendsto_inv_at_top_zero.comp (tendsto_pow_at_top_at_top_of_one_lt hb)
contradiction
have me0 : 0 < max (1 / ε) M := lt_max_iff.mpr (Or.inl (one_div_pos.mpr e0))
  -- The maximum between `1 / ε` and `M` works
refine' ⟨max (1 / ε) M, me0, fun z a => _⟩
  -- First, let's deal with the easy case in which we are far away from `α`
refine' mem_closed_ball'.mp (le_trans _ ((one_div_le me0 e0).mpr (le_max_left _ _)))
exact (le_div_iff me0).mpr (not_le.mp dm1).le
    -- use the "separation from `1`" (assumption `L`) for numerators,
rw [fR.deriv]
exact hM _ h
contradiction
contradiction
rw [← Int.cast_one]
exact int.cast_lt.mpr b1
rw [liouville_number_initial_terms, range_one, sum_singleton, Nat.cast_one]
rw [tsub_mul, one_mul]
simp only [Int.floor_le, Int.lt_floor_add_one, add_neg_lt_iff_le_add', zero_add, and_self_iff,
        mem_Ico, Int.cast_neg, le_add_neg_iff_add_le]
intro a b
rw [Real.volume_ball, mul_one_div, ← Nnreal.coe_two, ← Nnreal.coe_nat_cast, ← Nnreal.coe_rpow, ←
      Nnreal.coe_div, Ennreal.of_real_coe_nnreal]
simp only [hB, Int.card_Icc, Finset.sum_const, nsmul_eq_mul, sub_zero, ← Int.ofNat_succ,
          Int.toNat_coe_nat, ← Nat.cast_succ, Ennreal.coe_mul, Ennreal.coe_nat]
rw [set_of_liouville_eq_Inter_Union]
refine' is_Gδ_Inter fun n => IsOpen.is_Gδ _
refine' is_open_Union fun a => is_open_Union fun b => is_open_Union fun hb => _
exact is_open_ball.inter is_closed_singleton.is_open_compl
cases i <;> dsimp [s_mod]
· exact sup_eq_right.mp rfl
· apply Int.emod_nonneg
    exact mersenne_int_ne_zero p w
cases i <;> simp [s_mod]
decide
dsimp [lucas_lehmer_residue]
rw [s_zmod_eq_s_mod p]
constructor
· -- We want to use that fact that `0 ≤ s_mod p (p-2) < 2^p - 1`
    -- and `lucas_lehmer_residue p = 0 → 2^p - 1 ∣ s_mod p (p-2)`.
    intro h
    simp [Zmod.int_coe_zmod_eq_zero_iff_dvd] at h
    apply Int.eq_zero_of_dvd_of_nonneg_of_lt _ _ h <;> clear h
    apply s_mod_nonneg _ (Nat.lt_of_succ_lt w)
    exact s_mod_lt _ (Nat.lt_of_succ_lt w) (p - 2)
· intro h
    rw [h]
    simp
cases x
cases y
congr <;> assumption
dsimp [bit1]
simp
simp
simp [Nat.cast, Monoid.one]
simp <;> rfl
injection h with h1 _ exact zero_ne_one h1
rw [ih]
rw [← mul_pow ωb ω, ωb_mul_ω, one_pow, mul_one, add_sub_cancel]
rw [← pow_mul, ← pow_mul, pow_succ']
decide
decide
rw [← pow_mul, ← pow_succ']
rw [ω_pow_eq_neg_one p' h]
simp
simp [ω_mul_ωb]
simp [ωb_mul_ω]
decide
dsimp [s_mod, mersenne]
rw [h1, h2, sq, h3]
conv in k => rw [← Nat.div_add_mod k (2 ^ n)]
refine' Nat.Modeq.add_right _ _
conv => 
    congr
    skip
    skip
    rw [← one_mul (k / 2 ^ n)]
exact (Nat.modeq_sub <| Nat.succ_le_of_lt <| pow_pos zero_lt_two _).mul_right _
simp [h.symm, even_mul]
decide
rw [even_iff_two_dvd] at hxsu
simp [mul_add, pow_succ, mul_comm, mul_assoc, mul_left_comm]
decide
rw [← hk] <;> exact add_nonneg (add_nonneg (sq_nonneg _) (sq_nonneg _)) zero_le_one
rw [hk, Int.natAbs_of_nonneg hk0, mul_comm]
rw [← Int.coe_nat_inj', Int.ofNat_add, Int.ofNat_add, Int.coe_nat_pow, Int.coe_nat_pow,
              Int.nat_abs_sq, Int.nat_abs_sq, Int.ofNat_one, hk, Int.ofNat_mul,
              Int.natAbs_of_nonneg hk0]
decide
decide
decide
rw [← @zero_mul (Zmod 2) _ m, ← show ((2 : ℤ) : Zmod 2) = 0 from rfl, ← Int.cast_mul, ←
              h] <;>
            simp only [Int.cast_add, Int.cast_pow] <;>
          rfl
decide
decide
rw [hk0, Int.ofNat_zero, zero_mul] at hk
exact
          ne_of_gt
            (show a ^ 2 + b ^ 2 + 1 > 0 from
              add_pos_of_nonneg_of_pos (add_nonneg (sq_nonneg _) (sq_nonneg _)) zero_lt_one)
            hk.1
simp_all [lt_irrefl]
simp only [hm1, habcd, Int.ofNat_one, one_mul]
simp [sq]
simp [sq, bit0, bit1, mul_add, add_mul, add_assoc]
rw [hm2, Int.ofNat_one, one_pow, mul_one]
exact add_pos_of_nonneg_of_pos (Int.coe_nat_nonneg _) zero_lt_one
simp [w, x, y, z, sq]
rw [hwxyzabcd, habcd, Int.cast_mul, cast_coe_nat, Zmod.nat_cast_self, zero_mul]
rw [Int.natAbs_of_nonneg hn_nonneg, ← hn, ← sq]
exact hwxyzlt
decide
rw [← Int.coe_nat_inj', ← Nat.mul_div_cancel' (min_fac_dvd (k + 2)), Int.ofNat_mul, ← h₁, ←
        h₂]
simp [sum_four_sq_mul_sum_four_sq]
rw [prime_counting', count_eq_card_filter_range, range_eq_Ico, ←
        Ico_union_Ico_eq_Ico (zero_le k) le_self_add, filter_union]
apply card_union_le
rw [prime_counting', count_eq_card_filter_range]
refine' add_le_add_left (card_le_of_subset _) k.prime_counting'
simp only [subset_iff, and_imp, mem_filter, mem_Ico]
intro p succ_k_le_p p_lt_n p_prime
constructor
· exact ⟨succ_k_le_p, p_lt_n⟩
· rw [coprime_comm]
        exact coprime_of_lt_prime h0 (gt_of_ge_of_gt succ_k_le_p h1) p_prime
rw [add_le_add_iff_left]
exact Ico_filter_coprime_le k n h0
simp [l_series_summable, summable_zero]
rw [Ne.def, Nat.cast_eq_zero]
apply n.succ_ne_zero
rw [← l_series_summable_iff_of_re_eq_re (Complex.of_real_re z.re)]
apply l_series_summable_of_bounded_of_one_lt_real h
exact hz
rw [← l_series_summable_iff_of_re_eq_re (Complex.of_real_re z.re), l_series_summable, ←
    summable_norm_iff, ← Real.summable_one_div_nat_rpow, iff_iff_eq]
simp only [l_series, add_apply]
rw [← tsum_add hf hg]
apply congr rfl (funext fun n => _)
apply _root_.add_div
intro x h5
have h6 := mul_pos (zero_lt_two' ℝ) h5
have h7 := rpow_pos_of_pos h6 (sqrt (2 * x))
rw [log_div (mul_pos h5 h7).ne' (rpow_pos_of_pos four_pos _).ne', log_mul h5.ne' h7.ne',
      log_rpow h6, log_rpow zero_lt_four, ← mul_div_right_comm, ← mul_div, mul_comm x]
decide
decide
rw [card_Icc, Nat.add_sub_cancel]
rw [mul_comm, ← ha, mul_comm, ← hb, Nat.add_sub_of_le key]
apply int.gcd_eq_one_iff_coprime.mp
rw [sq, sq]
exact (IsCoprime.mul_left h2 h2).mul_add_left_left r
apply IsCoprime.mul_right (Int.coprime_of_sq_sum (is_coprime_comm.mp h))
rw [add_comm]
apply Int.coprime_of_sq_sum h
rw [htt3]
exact
      int.gcd_eq_one_iff_coprime.mpr (Int.coprime_of_sq_sum' (int.gcd_eq_one_iff_coprime.mp htt4))
  -- b is even because b ^ 2 = 2 * m * n.
apply @Int.Prime.dvd_pow' _ 2 _ Nat.prime_two
rw [ht2, mul_assoc]
exact dvd_mul_right 2 (m * n)
apply ne_zero_pow two_ne_zero
rw [hs]
apply mul_ne_zero
· exact ne_of_gt h4
· exact hrsz
apply sq_nonneg b'
    exact absurd (lt_of_le_of_ne h2' (Ne.symm (pow_ne_zero _ h2b0))) (not_lt.mpr h2)
  replace hd
intro h0
rw [h0, zero_pow zero_lt_two, neg_zero, or_self_iff] at hj
apply left_ne_zero_of_mul hrsz hj
intro h0
rw [h0, zero_pow zero_lt_two, neg_zero, or_self_iff] at hk
apply right_ne_zero_of_mul hrsz hk
rw [← hi, htt3, hj2, hk2]
rw [ht2] at hb20
apply right_ne_zero_of_mul hb20
  -- and it has a smaller c: from c = m ^ 2 + n ^ 2 we see that m is smaller than c, and i ^ 2 = m.
apply int.coe_nat_lt.mp
rw [← Int.eq_natAbs_of_zero_le (le_of_lt hc)]
apply gt_of_gt_of_ge _ (Int.abs_le_self_sq i)
rw [← hi, ht3]
apply gt_of_gt_of_ge _ (Int.le_self_sq m)
exact lt_add_of_pos_right (m ^ 2) (sq_pos_of_ne_zero n hn)
apply h.2 j k i
exact ⟨hj0, hk0, hh.symm⟩
rw [Fintype.of_equiv_card ring_hom.equiv_rat_alg_hom.symm, AlgHom.card]
simp only [hx φ, norm_pow, one_pow, map_pow]
rw [← two_mul] <;> exact Eq.symm
simp only [Subtype.coe_mk, Subalgebra.coe_zero, map_zero]
simp only [Subtype.coe_mk, Subalgebra.coe_one, map_one]
simp only [map_add, Subalgebra.coe_add, Subtype.coe_mk]
simp only [Subalgebra.coe_mul, map_mul, Subtype.coe_mk]
simp only [← add_mul, ← RingHom.map_add (algebraMap R S), hpq, map_one, one_mul]
simp [h]
simp only [this]
rw [normalized_factors_map_equiv_normalized_factors_min_poly_mk, Equiv.coe_trans,
    Function.comp_apply,
    multiplicity_normalized_factors_equiv_span_normalized_factors_symm_eq_multiplicity,
    normalized_factors_equiv_of_quot_equiv_multiplicity_eq_multiplicity]
rw [← hJ', Equiv.symm_apply_apply _ _, Subtype.coe_mk]
simp [normalized_factors_irreducible hf]
simp [hx]
apply Nat.div_le_self
        exact lt_of_lt_of_le h₁ h₂
    rand_nat_aux (r' / gen_mag - 1) v' g'
rw [congr_fun LinearOrder.min_def a, minDefault]
rw [congr_fun LinearOrder.max_def a, maxDefault]
apply eq_min
· apply le_trans
    apply min_le_left
    apply min_le_left
· apply le_min
    apply le_trans
    apply min_le_left
    apply min_le_right
    apply min_le_right
· intro d h₁ h₂
    apply le_min
    apply le_min h₁
    apply le_trans h₂
    apply min_le_left
    apply le_trans h₂
    apply min_le_right
apply Eq.symm
apply eq_min (le_refl _) h
intros
assumption
apply eq_max
· apply le_trans
    apply le_max_left a b
    apply le_max_left
· apply max_le
    apply le_trans
    apply le_max_right a b
    apply le_max_left
    apply le_max_right
· intro d h₁ h₂
    apply max_le
    apply max_le h₁
    apply le_trans (le_max_left _ _) h₂
    apply le_trans (le_max_right _ _) h₂
apply Eq.symm
apply eq_max (le_refl _) h
intros
assumption
apply Nat.add_lt_add_left
assumption
simp [Nat.add_comm]
assumption
contradiction
contradiction
dsimp only [conv] <;> infer_instance
dsimp only [conv] <;> infer_instance
dsimp only [conv] <;> infer_instance
contradiction
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
intros
rfl
  -- `functor` is indeed a categorical functor
intros
rfl
intros
rfl
  -- applicative laws
intros <;> simp [(pure_seq_eq_map _ _).symm, seq_assoc, map_pure, seq_pure]
simp [pure_seq_eq_map]
intros
rfl
intros
rfl
  -- monad laws
intros <;> rw [← bind_map_eq_seq] <;> simp [pure_bind]
intros <;> rw [← bind_pure_comp_eq_map] <;> simp [pure_bind]
intros <;> rw [← bind_map_eq_seq] <;> simp [map_pure, bind_pure_comp_eq_map]
intros <;>
      simp [(bind_pure_comp_eq_map _ _).symm, (bind_map_eq_seq _ _).symm, bind_assoc, pure_bind]
rw [bind_pure_comp_eq_map] <;> simp [id_map]
simp [show f = g from funext h]
simp [show f = g from funext h]
refine' { .. } <;> intros <;> rfl
cases x <;> cases x' <;> simp [show x = x' from funext h]
apply bind_ext_congr <;> intro a <;> cases a <;> simp [StateT.bind, StateT.run]
rw [← bind_pure_comp_eq_map _ (x.run st)]
change (x >>= pure ∘ f).run st = _
simp
delta StateT.adapt <;> rfl
intros <;> apply StateT.ext <;> intro <;> simp <;> erw [id_map]
intros
apply StateT.ext
simp
intros
apply StateT.ext
simp [bind_assoc]
cases x <;> cases x' <;> simp_all
rw [← bind_pure_comp_eq_map _ x.run]
change x.run >>= ExceptT.bindCont (pure ∘ f) = _
apply bind_ext_congr
intro a <;> cases a <;> simp [ExceptT.bindCont, Except.map]
intros
apply ExceptT.ext
simp only [ExceptT.run_map]
rw [map_ext_congr, id_map]
intro a
cases a <;> rfl
intros
apply ExceptT.ext
simp only [ExceptT.run_map, ExceptT.run_bind]
rw [bind_ext_congr, bind_pure_comp_eq_map]
intro a
cases a <;> rfl
intros
apply ExceptT.ext
simp only [ExceptT.run_bind, bind_assoc]
rw [bind_ext_congr]
intro a
cases a <;> simp [ExceptT.bindCont]
intros <;> apply ExceptT.ext <;> simp [ExceptT.bindCont]
cases x <;> cases x' <;> simp [show x = x' from funext h]
rw [← bind_pure_comp_eq_map _ (x.run r)] <;> rfl
intros <;> apply ReaderT.ext <;> intro <;> simp
intros <;> apply ReaderT.ext <;> intro <;> simp
intros <;> apply ReaderT.ext <;> intro <;> simp [bind_assoc]
cases x <;> cases x' <;> simp_all
rw [← bind_pure_comp_eq_map _ x.run]
change x.run >>= OptionT.bindCont (pure ∘ f) = _
apply bind_ext_congr
intro a <;> cases a <;> simp [OptionT.bindCont, Option.map, Option.bind]
intros
apply OptionT.ext
simp only [OptionT.run_map]
rw [map_ext_congr, id_map]
intro a
cases a <;> rfl
intros
apply OptionT.ext
simp only [OptionT.run_bind, bind_assoc]
rw [bind_ext_congr]
intro a
cases a <;> simp [OptionT.bindCont]
intros <;> apply OptionT.ext <;> simp [OptionT.bindCont]
unfold bodd bodd_div2 <;> cases bodd_div2 n <;> cases fst <;> rfl
intros <;> cases b <;> rfl
intros <;> cases b <;> rfl
unfold bodd div2 bodd_div2 <;> cases bodd_div2 n <;> cases fst <;> rfl
simp
refine' Eq.trans _ (congr_arg succ (bodd_add_div2 n))
cases bodd n <;> simp [cond, not]
· rw [Nat.add_comm, Nat.zero_add]
· rw [succ_mul, Nat.add_comm 1, Nat.zero_add]
decide
rw [Nat.zero_add]
cases b
apply bit0_val
apply bit1_val
rw [← bit_decomp n] <;> apply h
rw [n0] <;> exact z
rw [binary_rec]
rfl
rw [bit_val] <;> simp <;> cases b <;> cases bodd n <;> rfl
decide
simp [shiftl']
rw [Nat.add_comm, shiftr_add]
simp [shiftr, div2_bit]
apply shiftl'_sub (Nat.le_of_succ_le_succ h)
dsimp [shiftr] <;> rw [div2_bit]
rw [binary_rec]
cases f ff tt <;> rfl
cases f tt ff <;> rfl
unfold bitwise <;> rw [binary_rec_zero]
unfold bitwise <;> apply bit_cases_on m <;> intros <;> rw [binary_rec_eq, binary_rec_zero] <;>
    exact bitwise_bit_aux h
rw [bitwise_zero_left] <;> cases f ff tt <;> rfl
cases a <;> assumption
cases a <;> assumption
funext m n
revert n
dsimp [Function.swap]
apply binary_rec _ (fun a m' IH => _) m <;> intro n
· rw [bitwise_zero_left, bitwise_zero_right]
    exact h
apply bit_cases_on n <;> intro b n'
rw [bitwise_bit, bitwise_bit, IH] <;> exact h
simp [gcd]
simp [gcd]
simp [gcd]
cases x <;> simp [gcd, succ_ne_zero]
cases n <;> simp [gcd, mod_self]
cases n <;> simp [gcd]
cases m <;> simp [gcd]
rw [add_succ, add_succ, add_assoc] <;> rfl
simp (config := { contextual := true }) [Nat.zero_add]
simp [succ_add] at h
assumption
simp [Nat.zero_add]
rw [mul_succ, zero_mul]
simp [Nat.zero_mul]
rw [Nat.zero_mul, Nat.mul_zero]
simp [mul_succ, succ_mul, mul_comm n m]
simp [mul_succ, Nat.left_distrib, mul_assoc n m k]
rw [Nat.mul_comm, Nat.mul_one]
simp [succ_add, add_succ]
rw [succ_mul]
intro h
exact Or.inr (Nat.eq_zero_of_add_eq_zero_left h)
cases n
exact Or.inl rfl
exact Or.inr (succ_pos _)
rw [Nat.add_assoc, hw]
rw [Nat.add_comm n k, Nat.add_comm m k]
apply Nat.add_le_add_left h
rw [Nat.add_assoc] at hw
apply Nat.add_left_cancel hw
rw [Nat.add_comm _ k, Nat.add_comm _ k]
apply Nat.le_of_add_le_add_left
rw [HEq] at h
assumption
rw [Nat.add_comm] <;> exact Nat.lt_add_of_pos_right h
rw [← Nat.left_distrib, hl]
contradiction
contradiction
unfold bit0 at h
simp [add_one, add_succ, succ_add] at h
have aux : n + n = m + m := h
rw [aux]
simp [Nat.bit1_eq_succ_bit0] at h
rw [h]
injection this
  Nat.bit0_inj this
contradiction
rw [Nat.bit1_succ_eq]
apply succ_lt_succ
apply zero_lt_succ
contradiction
rw [Nat.bit0_succ_eq]
apply succ_lt_succ
apply zero_lt_succ
rw [succ_add]
assumption
cases n <;> simp
have : a = b := h
rw [this]
rw [Nat.sub_zero]
rw [succ_sub_succ, sub_self n]
rw [Nat.add_zero, Nat.add_zero]
rw [add_succ, add_succ, succ_sub_succ, add_sub_add_right n k m]
rw [Nat.add_comm k n, Nat.add_comm k m, Nat.add_sub_add_right]
rw [Nat.add_sub_add_left, Nat.sub_zero]
rw [Nat.add_zero, Nat.sub_zero]
rw [add_succ, Nat.sub_succ, Nat.sub_succ, sub_sub n m k]
rw [Nat.add_sub_add_left, Nat.zero_sub]
rw [← Nat.add_sub_cancel x k, Nat.sub_le_sub_iff_right h, Nat.add_sub_cancel]
apply Nat.sub_lt _ h₀
apply lt_of_lt_of_le h₀ h₁
rw [← hk, Nat.sub_self_add]
rw [Nat.sub_zero] at H
simp [H]
simp [Nat.add_sub_add_right] at H
exact H
rw [← hk, Nat.add_sub_cancel_left]
rw [Nat.add_comm, Nat.add_sub_of_le h]
rw [← hl, Nat.add_sub_cancel_left, Nat.add_comm k, ← Nat.add_assoc, Nat.add_sub_cancel]
rw [c_eq.symm, Nat.sub_add_cancel ab]
rw [a_eq, Nat.add_sub_cancel]
simp [Nat.sub_eq_zero_of_le H'] at H
contradiction
rw [Nat.sub_sub, Nat.sub_sub, add_succ, succ_sub_succ]
rw [Nat.sub_sub, Nat.sub_sub, Nat.add_comm]
rw [← hk, Nat.add_sub_cancel_left, ← add_succ, Nat.add_sub_cancel_left]
rw [Nat.zero_add, Nat.sub_add_cancel (le_of_lt h)]
exact h
  Nat.lt_of_add_lt_add_right this
rw [Nat.sub_sub]
apply Nat.sub_lt
apply lt_of_lt_of_le (Nat.zero_lt_succ _) h
rw [Nat.add_comm]
apply Nat.zero_lt_succ
simp [Nat.zero_sub, pred_zero, Nat.zero_mul]
rw [pred_succ, succ_mul, Nat.add_sub_cancel]
rw [Nat.mul_comm, mul_pred_left, Nat.mul_comm]
simp [Nat.sub_zero, Nat.zero_mul]
rw [Nat.sub_succ, mul_pred_left, mul_sub_right_distrib, succ_mul, Nat.sub_sub]
rw [Nat.mul_comm, Nat.mul_sub_right_distrib, Nat.mul_comm m n, Nat.mul_comm n k]
rw [Nat.mul_sub_left_distrib, Nat.right_distrib, Nat.right_distrib, Nat.mul_comm b a,
    Nat.add_comm (a * a) (a * b), Nat.add_sub_add_left]
rw [← add_one, ← add_one]
simp [Nat.right_distrib, Nat.left_distrib, Nat.add_left_comm, Nat.mul_one, Nat.one_mul,
    Nat.add_assoc]
rw [min_eq_right h]
rw [Nat.sub_eq_zero_of_le (le_of_not_ge h), min_eq_left (le_of_not_ge h), Nat.sub_self]
rw [sub_eq_sub_min, Nat.sub_add_cancel (min_le_left n m)]
cases x
· cases y <;> rfl
cases y
· rfl
refine' if_congr Iff.rfl (mod_core_congr _ _) rfl <;> simp [Nat.sub_le]
rw [b0, Nat.sub_zero]
rw [mod_def, if_pos (And.intro h₂ h)]
rw [mod_eq_sub_mod (le_refl _), Nat.sub_self, zero_mod]
decide
decide
rw [mod_eq_of_lt xlty] <;> rfl
rw [y0, mod_zero] <;> rfl
rw [mod_eq_sub_mod (Nat.le_add_left _ _), Nat.add_sub_cancel]
rw [Nat.add_comm, add_mod_right]
rw [Nat.mul_comm, add_mul_mod_self_left]
rw [← Nat.zero_add (m * n), add_mul_mod_self_left, zero_mod]
rw [Nat.mul_comm, mul_mod_right]
rw [y0, Nat.mul_zero, mod_zero, mod_zero]
rw [z0, Nat.zero_mul, Nat.zero_mul, Nat.zero_mul, mod_zero]
rw [mod_eq_sub_mod yn, mod_eq_sub_mod (Nat.mul_le_mul_left z yn), ←
                Nat.mul_sub_left_distrib] <;>
              exact IH _ (Nat.sub_lt (lt_of_lt_of_le y0 yn) y0)
rw [mod_eq_of_lt yn, mod_eq_of_lt (Nat.mul_lt_mul_of_pos_left yn z0)]
rw [Nat.mul_comm x z, Nat.mul_comm y z, Nat.mul_comm (x % y) z] <;> apply mul_mod_mul_left
rw [mul_succ] at h₁
apply Nat.le_trans _ h₁
apply Nat.le_add_right _ n
apply @Nat.le_of_add_le_add_right (n * k)
rw [Nat.sub_add_cancel h₂]
simp [mul_succ, Nat.add_comm] at h₁
simp [h₁]
cases x
· cases y <;> rfl
cases y
· rfl
refine' if_congr Iff.rfl (congr_arg (· + 1) _) rfl
refine' div_core_congr _ _ <;> simp [Nat.sub_le]
apply Nat.sub_lt _ h.left
apply lt_of_lt_of_le h.left h.right
rw [div_def]
simp [lt_irrefl]
simp [Nat.div_zero, n.zero_le]
rw [mod_add_div]
simp [Nat.div_zero, m.zero_le]
rw [Nat.one_mul]
rw [div_def a, if_pos]
constructor <;> assumption
rw [div_def a, if_neg]
intro h₁
apply not_le_of_gt h₀ h₁.right
rw [← not_le, not_congr (le_div_iff_mul_le Hk), not_le]
apply Nat.le_of_add_le_add_right
rw [Nat.sub_add_cancel h₂, Nat.add_comm]
rw [mul_succ] at h₁
apply h₁
simp [m.zero_le, Nat.zero_mul]
rw [div_eq_sub_div H (Nat.le_add_left _ _), Nat.add_sub_cancel]
rw [Nat.add_comm, add_div_right x H]
induction n <;> simp [*, mul_succ, Nat.mul_zero]
rw [Nat.mul_comm, mul_div_right _ H]
rw [Nat.mul_comm, add_mul_div_left _ _ H]
rw [Nat.mul_comm, Nat.mul_div_cancel _ H]
rw [H2, Nat.mul_div_cancel _ H1]
rw [H2, Nat.mul_div_cancel_left _ H1]
rw [hn, Nat.mul_zero] at hi lo <;> exact absurd lo (not_le_of_gt hi)
rw [n0, Nat.zero_mul] at h₁ <;> exact Nat.not_lt_zero _ h₁
rw [← Nat.div_div_eq_div_mul, Nat.mul_div_cancel_left _ H]
simp [h₃, h₄, Nat.mul_assoc]
simp [Nat.left_distrib, hd, he]
rw [Nat.mul_sub_left_distrib, ← he, Nat.add_sub_cancel_left]
rw [Nat.add_comm] <;> exact Nat.dvd_add_iff_right h
rw [Nat.sub_add_cancel H] <;> exact h₁
rw [m0] at H1 <;> rw [Nat.eq_zero_of_zero_dvd H1] at H2 <;> exact lt_irrefl _ H2
decide
decide
rw [H1, mul_mod_right]
infer_instance
rw [Nat.mul_comm, Nat.mul_div_cancel' H]
rw [h, Nat.div_zero, Nat.div_zero, Nat.mul_zero]
rw [Nat.div_mul_cancel H]
rw [Nat.mul_assoc] at H1 <;> exact ⟨_, Nat.eq_of_mul_eq_mul_left kpos H1⟩
rw [Nat.mul_comm m k, Nat.mul_comm n k] at H <;> exact dvd_of_mul_dvd_mul_left kpos H
rw [Nat.add_right_comm] <;> exact kn
rw [e] <;> exact pm
        IH _ ⟨rfl, this⟩ fun n h => this n <| Nat.le_of_succ_le_succ h
rw [← h] at h₂
change 0 < a at h₁
have := le_of_lt h₁
exact absurd (le_of_lt h₁) (not_le_of_gt (Int.neg_of_neg_pos h₂))
simp [neg_succ_of_nat_coe, Int.ofNat_succ, Int.ofNat_add, Int.ofNat_one, Int.add_comm,
        Int.add_left_comm, Int.neg_add, Int.add_right_neg, Int.zero_add]
rw [Int.zero_add, Int.coe_nat_eq]
have : ofNat n + ofNat m = ofNat (n + m) := rfl
simp [nat_abs_of_nat_core, this]
have : -[n+1] + -[m+1] = -[Nat.succ (n + m)+1] := rfl
simp [nat_abs_of_neg_succ_of_nat, this, Nat.succ_add, Nat.add_succ]
rw [← h]
apply Int.nat_abs_bit0
rw [Int.nat_abs_add_nonneg (Int.bit0_nonneg h) (le_of_lt Int.zero_lt_one), Int.nat_abs_bit0]
rw [← h₂]
apply Int.nat_abs_bit1_nonneg h₁
unfold sub_nat_nat
rw [h]
unfold sub_nat_nat._match_1
unfold sub_nat_nat
rw [h]
unfold sub_nat_nat._match_1
simp [H]
rw [← Int.neg_neg a, ← Int.neg_neg b, h]
dsimp only [sub_nat_nat]
rw [Nat.sub_eq_zero_of_le]
dsimp only [sub_nat_nat._match_1]
rw [Nat.add_sub_cancel_left]
apply Nat.le_add_right
rw [Nat.add_assoc]
rw [Nat.add_sub_cancel_left]
simp [Nat.add_comm, Nat.add_left_comm]
simp [Nat.add_comm, Nat.add_left_comm]
have : n - m = succ (pred (n - m)) := Eq.symm (succ_pred_eq_of_pos (Nat.sub_pos_of_lt h))
rw [sub_nat_nat_of_sub_eq_succ this]
simp [Nat.add_comm]
simp [Nat.add_comm]
rw [sub_nat_nat_add_add]
rw [Nat.sub_add_cancel h]
simp [Nat.add_assoc]
simp [sub_nat_nat_add]
simp [add_succ]
rw [Int.add_comm, sub_nat_nat_add_neg_succ_of_nat]
simp [add_succ, succ_add, Nat.add_comm]
rw [Int.add_comm, ← add_assoc_aux1, Int.add_comm (of_nat k), add_assoc_aux1, Int.add_comm b]
rw [Int.add_comm, Int.add_comm a, ← add_assoc_aux1, Int.add_comm a, Int.add_comm (of_nat k)]
rw [Int.add_comm, ← add_assoc_aux2, Int.add_comm (of_nat n), ← add_assoc_aux2,
      Int.add_comm -[m+1]]
rw [Int.add_comm, Int.add_comm (of_nat m), Int.add_comm (of_nat m), ← add_assoc_aux2,
      Int.add_comm -[k+1]]
simp [add_succ, Nat.add_comm, Nat.add_left_comm, neg_of_nat_of_succ]
rw [sub_nat_nat_of_sub_eq_zero, Nat.sub_self, of_nat_zero]
rw [Nat.sub_self]
simp
simp
rw [Int.add_comm, Int.add_left_neg]
simp [Nat.mul_comm]
simp [Nat.mul_comm]
simp [Nat.mul_comm]
simp [Nat.mul_comm]
unfold neg_of_nat
simp
rw [Int.mul_comm]
simp [of_nat_mul_neg_of_nat, Nat.mul_comm]
unfold neg_of_nat
simp
rw [Int.mul_comm]
simp [neg_succ_of_nat_mul_neg_of_nat, Nat.mul_comm]
simp [Nat.mul_assoc]
simp [Nat.mul_assoc]
simp [Nat.mul_assoc]
simp [Nat.mul_assoc]
simp [Nat.mul_assoc]
simp [Nat.mul_assoc]
simp [Nat.mul_assoc]
simp [Nat.mul_assoc]
cases m
· cases n
    · simp
      rfl
    simp [Nat.zero_add]
    rfl
cases n
· simp
    rfl
simp [Nat.succ_add]
rfl
simp [Nat.left_distrib]
simp [neg_of_nat_eq_sub_nat_nat_zero]
rw [← sub_nat_nat_add]
rfl
simp [neg_of_nat_eq_sub_nat_nat_zero]
rw [Int.add_comm, ← sub_nat_nat_add]
rfl
simp
rw [← Nat.left_distrib, add_succ, succ_add]
simp [Nat.mul_comm]
rw [← Nat.right_distrib, Nat.mul_comm]
simp [neg_of_nat_eq_sub_nat_nat_zero]
rw [Int.add_comm, ← sub_nat_nat_add]
rfl
simp [neg_of_nat_eq_sub_nat_nat_zero]
rw [← sub_nat_nat_add]
rfl
simp
rw [← Nat.left_distrib, add_succ, succ_add]
rw [Int.mul_comm, Int.mul_add]
simp [Int.mul_comm]
delta sub_nat_nat <;> rw [Nat.sub_eq_zero_of_le h] <;> rfl
rw [← Int.add_assoc, Int.add_comm a, Int.add_assoc]
rw [h]
rw [Int.add_assoc, Int.add_comm (-a), Int.add_assoc, Int.add_assoc, ← Int.add_assoc b]
rw [Int.add_right_neg, Int.zero_add, Int.add_right_neg, Int.add_zero]
rw [Int.add_left_neg, Int.zero_add]
rw [Int.sub_eq_add_neg, ← Int.neg_add] <;> rfl
simp [Int.ofNat_add, Int.add_left_comm, Int.add_assoc, Int.add_right_neg]
rfl
rw [Int.ofNat_add, Int.ofNat_add, Int.ofNat_one, Int.negSucc_eq, Int.sub_eq_add_neg,
      Int.neg_add, Int.neg_add, Int.neg_add, ← Int.add_assoc, ← Int.add_assoc, Int.add_right_neg,
      Int.zero_add]
rw [Nat.add_sub_cancel_left] <;> rfl
rw [Nat.add_assoc, Nat.sub_eq_zero_of_le (Nat.le_add_right _ _)] <;> rfl
rw [Nat.one_mul]
rw [Nat.one_mul]
rw [Int.mul_comm, Int.one_mul]
rw [Nat.one_mul]
rfl
rw [Nat.one_mul]
rfl
rw [h] <;> trivial
rw [← h, Int.add_comm] <;> simp
rw [← h₁, Int.add_comm]
simp
simp [Int.add_comm]
rw [← hk]
rfl
have t := le.dest_sub h
simp at t
exact t
rw [Nat.add_comm] at h <;> exact h.symm
simp [Int.coe_nat_eq, Int.add_comm, Int.add_left_comm]
rfl
rw [← hn, Int.add_assoc, Int.add_comm 1]
rfl
rw [lt_iff_add_one_le, ← Int.ofNat_succ, coe_nat_le_coe_nat_iff]
rfl
apply le.intro
rw [← hm, ← hn, Int.add_assoc]
rfl
rw [Int.ofNat_add, ← Int.add_assoc, hn, hm, Int.add_zero a]
rw [← hn, this, Int.ofNat_zero, Int.add_zero a]
rw [hn, Int.add_zero]
rw [this] at h
exact h
rw [← hn, this, Int.ofNat_zero, Int.add_zero]
rw [this] at hn
exact hn
rw [Int.add_assoc, hn]
rw [Int.add_left_cancel HEq] at h
exact h
rw [← hn, ← hm]
simp [Int.zero_add]
rw [← hn, ← hm]
simp [Int.ofNat_zero]
rw [← Int.ofNat_mul]
simp [Nat.mul_succ, Nat.add_succ, Nat.succ_add]
let ⟨n, e⟩ := eq_ofNat_of_zero_le h
rw [e] <;> rfl
rw [eq_nat_abs_of_zero_le h] <;> rfl
let ⟨m, h⟩ := eq_ofNat_of_zero_le h
contradiction
rw [h, Int.neg_neg]
rw [← Int.add_assoc, Int.add_left_neg, Int.zero_add]
rw [← Int.add_assoc, Int.add_right_neg, Int.zero_add]
rw [Int.add_assoc, Int.add_right_neg, Int.add_zero]
rw [Int.add_assoc, Int.add_left_neg, Int.add_zero]
rw [Int.sub_eq_add_neg, Int.add_right_neg]
rw [h, Int.sub_self]
rw [Int.zero_add]
rw [← Int.add_zero (-a), ← h, ← Int.add_assoc, Int.add_left_neg, Int.zero_add]
rw [← Int.add_mul, Int.add_right_neg, Int.zero_mul]
rw [← Int.mul_add, Int.add_right_neg, Int.mul_zero]
simp
simp
simp
simp
have : -a + (a + b) ≤ -a + (a + c) := Int.add_le_add_left h _
simp [Int.neg_add_cancel_left] at this
assumption
have : -a + (a + b) < -a + (a + c) := Int.add_lt_add_left h _
simp [Int.neg_add_cancel_left] at this
assumption
rw [Int.add_comm a c, Int.add_comm b c]
exact Int.add_lt_add_left h c
rw [Int.add_comm b a, Int.add_comm b c]
assumption
rw [Int.add_comm b a, Int.add_comm b c]
assumption
rw [Int.sub_eq_add_neg, Int.add_assoc, ← Int.sub_eq_add_neg]
simp [Int.neg_neg] at this
assumption
rw [Int.add_comm] at h
exact Int.le_add_of_sub_left_le h
rw [Int.add_comm]
exact Int.sub_left_le_of_le_add h
rw [Int.add_comm] at h
exact Int.le_add_of_sub_right_le h
rw [Int.add_comm] at h
exact Int.neg_add_le_left_of_le_add h
rw [Int.add_comm] at h
exact Int.lt_add_of_sub_left_lt h
rw [Int.add_comm]
exact Int.sub_left_lt_of_lt_add h
rw [Int.add_comm] at h
exact Int.lt_add_of_sub_right_lt h
rw [Int.add_comm] at h
exact Int.neg_add_lt_left_of_lt_add h
rw [Int.add_zero]
rw [Int.add_zero]
have : 0 < b - a := Int.sub_pos_of_lt h₁
have : 0 < c * (b - a) := Int.mul_pos h₂ this
rw [Int.mul_sub] at this
exact Int.lt_of_sub_pos this
have : 0 < b - a := Int.sub_pos_of_lt h₁
have : 0 < (b - a) * c := Int.mul_pos this h₂
rw [Int.sub_mul] at this
exact Int.lt_of_sub_pos this
rw [← nat_abs_neg, nat_abs_of_nonneg (Int.neg_nonneg_of_nonpos H)]
rw [h, sign_zero]
have : 0 < a * b := Int.mul_pos hlt₁ hlt₂
rw [h] at this
exact absurd this (lt_irrefl _)
have : 0 > a * b := Int.mul_neg_of_pos_of_neg hlt₁ hgt₂
rw [h] at this
exact absurd this (lt_irrefl _)
have : 0 > a * b := Int.mul_neg_of_neg_of_pos hgt₁ hlt₂
rw [h] at this
exact absurd this (lt_irrefl _)
have : 0 < a * b := Int.mul_pos_of_neg_of_neg hgt₁ hgt₂
rw [h] at this
exact absurd this (lt_irrefl _)
rw [Int.sub_mul, this]
rw [Int.mul_sub, this]
rw [Int.one_mul, H]
rw [Int.mul_one, H]
subst eq₂
exact iha a₁ h b₁
subst eq₂
have new_eq₃ := eq_of_heq eq₃
subst new_eq₃
exact ihb b₁ h
cases a <;> cases b <;> simp [Fin.add]
cases a <;> cases b <;> simp [Fin.mul]
cases a <;> cases b <;> rfl
cases a <;> cases b <;> simp [Fin.mod]
cases a <;> cases b <;> simp [Fin.div]
cases a <;> cases b <;> simp [Fin.Lt]
cases a <;> cases b <;> simp [Fin.Le]
have aux₁ := vne_of_ne h₂
dsimp at aux₁
rw [val_zero] at aux₁
exact aux₁
simp
rw [Nat.sub_add_cancel] <;> assumption
simp [*, sub_sub_cancel]
apply Nat.sub_lt_of_pos_le
apply Nat.zero_lt_succ
assumption
simp [read, write]
intro h <;> simp [read, write, h]
cases a <;> cases b <;> congr <;> exact funext h
cases a
cases b
congr
funext i
cases i
apply h
simp [DArray.beqAux] at h₂
assumption
unfold DArray.beq
intro h
have : ∀ (j : Nat) (h : j < n), a.read ⟨j, h⟩ = b.read ⟨j, h⟩ := of_beq_aux_eq_tt n (le_refl _) h
apply DArray.ext' this
simp [DArray.beqAux] at h₂
contradiction
simp [DArray.beqAux] at h₂
assumption
simp [read', h]
simp [write', h]
unfold Array'
infer_instance
simp
simp
apply propext
apply Iff.intro
· exact fun h => h.2
· intro hba
    constructor
    · intro hab
      exact absurd (trans hab hba) (irrefl a)
    · assumption
simp
induction s <;> rfl
cases it <;> cases it_snd <;>
    simp [iterator.next, iterator.next_to_string, String.length, Nat.add_sub_cancel_left]
cases it <;> cases it_snd <;>
    simp [iterator.has_next, iterator.next_to_string, String.length, Nat.zero_lt_one_add,
      Nat.add_comm, false_imp_iff]
decide
intro c
delta is_whitespace
infer_instance
intro c
delta is_upper
infer_instance
intro c
delta is_lower
infer_instance
intro c
delta is_alpha
infer_instance
intro c
delta is_digit
infer_instance
intro c
delta is_alphanum
infer_instance
intro c
delta is_punctuation
infer_instance
intro h <;> unfold of_nat <;> rw [dif_pos h]
intro h <;> unfold of_nat <;> rw [dif_neg h]
intro h <;> apply eq_of_veq <;> rw [val_of_nat_eq_of_not_is_valid h] <;> rfl
apply ne_of_vne
rw [val_of_nat_eq_of_is_valid h₂, val_of_nat_eq_of_is_valid h₃]
assumption
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
contradiction
contradiction
cases b <;> simp
cases b <;> simp
cases a <;> cases b <;> simp
cases a <;> cases b <;> simp
cases a <;> simp
cases a <;> cases b <;> simp
cases a <;> cases b <;> simp
cases a <;> simp
simp
simp
simp
simp
decide
decide
decide
decide
intro α β f l
induction l <;> simp_all [(· <$> ·), (· >>= ·), pure]
intros
simp [pure, (· >>= ·)]
simp [List.not_bex_nil]
rw [partition_eq_filter_filter] at e
injection e
subst large
subst small
constructor <;> exact Nat.succ_le_succ (length_le_of_sublist (filter_sublist _))
rw [qsort, WellFounded.fix_eq, qsort.F]
induction t <;> simp [*]
induction s <;> simp [*]
induction s
· show length t = 0 + length t
    · rw [Nat.zero_add]
· simp [*, Nat.add_comm, Nat.add_left_comm]
induction n <;> simp [*] <;> rfl
cases l <;> rfl
intro l₁ <;> induction l₁ <;> intros <;> simp [*]
induction l <;> simp [*]
induction l <;> simp [*]
induction l <;> simp [*]
simp [join, List.bind]
simp [join, List.bind]
induction s <;> simp [*, or_assoc']
induction l <;> intros
rfl
contradiction
induction l <;> intros <;> contradiction
induction l₁ <;> intro l₂ <;> cases l₂ <;>
    simp [*, add_one, min_succ_succ, Nat.zero_min, Nat.min_zero]
simp [Nat.zero_min]
simp [Nat.min_zero]
simp [*, Nat.min_succ_succ, add_one]
simp [min_le_left]
simp [remove_nth]
have : i < length xs := lt_of_succ_lt_succ h
dsimp [remove_nth] <;>
        rw [length_remove_nth xs i this,
          Nat.sub_add_cancel (lt_of_le_of_lt (Nat.zero_le _) this)] <;>
      rfl
simp [pa] <;> apply sublist.cons2 <;> apply filter_sublist l
simp [pa] <;> apply sublist.cons <;> apply filter_sublist l
unfold Smt.store Smt.select <;> rw [if_pos] <;> rfl
intros <;> unfold Smt.store Smt.select <;> rw [if_neg] <;> assumption
apply funext
intro input
apply funext
intro pos
dsimp only [Parser.bind]
cases p input Pos <;> exact rfl
apply funext
intro input
apply funext
intro pos
dsimp only [Parser.bind]
cases p input Pos <;> try dsimp only [bind]
cases q result input pos_1 <;> try dsimp only [bind]
all_goals rfl
unfold Vector
infer_instance
contradiction
contradiction
rw [h] <;> exact i.2
simp [*]
simp [*]
simp [*]
simp [*]
simp [*]
rw [l.length_remove_nth i.1] <;> rw [p] <;> exact i.2
simp [*]
simp [*]
cases v
rfl
cases v
cases w
rfl
cases v
rfl
cases v
rfl
intros
simp
rw [h₂, h₁, h₁ (ys List.nil)]
simp
cases l <;> simp
intros
funext x
simp [l_invariant x]
simp
simp
cases l₁ <;> cases l₂ <;> simp <;> rw [l₁_invariant]
cases l <;> simp
cases l <;> simp <;> rw [l_invariant]
cases b <;> unfold read read' <;> simp [Array'.read_eq_read']
cases b <;> unfold write write' <;> simp [Array'.write_eq_write']
decide
exact if matches? then
        $(mkInstantiateMVars decls decls)
      else
        return $(mkIsDefEqResult false decls)
intro h
cases h with
        | inl h => exact Or.inl h
        | inr h => exact Or.inr ($(orChange (ps1::ps2)) h)
rw [Nat.add_comm]
exact Nat.lt_of_le_of_lt (Nat.zero_le _) (Nat.lt_succ_self _)
simp
rfl
simp
simp
simp
simp at p
exact 1
exact 2
congr
congr
congr

-- FIXME(?): congr doesn't fail
-- example {α} (a b : α) (h : False) : a = b :=
assumption
apply id <;> trivial
cases () with apply id <;> apply id
  | unit => trivial
cases () with (apply id; apply id)
  | unit => trivial
cases () with apply id <;> apply id
  | unit => trivial
trivial <;> done
rw [← and_assoc, ← and_assoc, @and_comm a b]
simp only [and_left_comm, and_comm]
rfl
simp only [and_left_comm, and_comm]
rfl
rw [← and_assoc, @and_right_comm a, and_assoc]
rw [and_and_and_comm, and_self]
rw [and_and_and_comm, and_self]
rw [@Iff.comm p, and_iff_left_iff_imp]
rw [and_comm, iff_self_and]
simp [ha] at h
exact h
simp only [and_comm, ← and_congr_right_iff]
rfl
rw [← or_assoc, ← or_assoc, @or_comm a b]
rw [or_assoc, or_assoc, @or_comm b]
rw [← or_assoc, @or_right_comm a, or_assoc]
rw [or_or_or_comm, or_self]
rw [or_or_or_comm, or_self]
simp only [or_left_comm, Or.comm]
rfl
rw [or_comm, or_iff_left_iff_imp]
simp [and_comm, and_or_left]
simp [or_comm, or_and_left]
simp [@eq_comm _ a']
exact fun a => And.comm
simp [And.comm]
simp [@eq_comm _ a']

-- this theorem is needed to simplify the output of `list.mem_cons_iff`
simp only [or_imp, forall_and, forall_eq]
rfl
simp only [or_and_right, exists_or, exists_eq_left]
rfl
simp [← and_assoc]
(conv in _=_ => rw [eq_comm])
simp
cases on an `Or
cases on an `Or
simp
simp [h]
rw [eq_false h, false_or]
exact (or_iff_right_of_imp fun hx x => (hx x).elim).symm
rw [@iff_def (¬a), @iff_def' a]
exact and_congr not_imp_not not_imp_not
rw [@iff_def (¬a), @iff_def (¬b)]
exact and_congr not_imp_comm imp_not_comm
rw [@iff_def a, @iff_def b]
exact and_congr imp_not_comm not_imp_comm
rw [iff_iff_implies_and_implies a b]
simp only [imp_iff_not_or, Or.comm]
rfl
rw [← not_or, not_not]
rw [← not_and, not_not]
simp only [ha, true_and, true_imp_iff]
rfl
simp only [ha, false_or, false_and, false_imp_iff]
rw [or_iff_not_imp_right, or_iff_not_imp_right]
exact imp_congr_right h
rw [or_iff_not_imp_left, or_iff_not_imp_left]
exact imp_congr_right h
cases propext (iff_of_true hp hq)
rfl
cases h
rfl
subst hx hy
rfl
split <;> rfl
congr <;> apply Subsingleton.elim
congr
exact Subsingleton.elim x y
exact decl_name%
exact decl_name%
exact decl_name%
cases l <;> simp
cases s <;> simp
cases s <;> simp
simp
induction l₁ generalizing s <;> simp [*]
rw [← of_real_nat_cast, of_real_re]
contradiction
rw [ne_eq, ← beq_iff_eq a b]
cases a == b <;> decide
intros
rfl
intros
rfl
intros
rfl
intros
rfl
intros
rfl
rw [← bind_pure_comp]
simp [pure_bind]
simp [← bind_pure_comp, bind_assoc, pure_bind]
intros
rw [← bind_map]
simp [pure_bind]
intros
rw [← bind_map]
simp [map_pure, bind_pure_comp]
simp [← bind_pure_comp, ← bind_map, bind_assoc, pure_bind]
simp [seqLeft_eq, ← bind_map, ← bind_pure_comp, pure_bind, bind_assoc]
rw [seqRight_eq, ← bind_map, ← bind_pure_comp, bind_assoc]
simp [pure_bind, id_map]
cases x <;> rfl
cases a <;> rfl
cases x <;> rfl
cases x <;> rfl
cases x <;> rfl
simp [← comp_map, Function.comp]
rw [← h, ← comp_map]
rfl
let ⟨x', hx⟩ := hx
refine ⟨(fun ⟨a, h⟩ => ⟨f a, hf h⟩) <$> x', ?_⟩
rw [← hx]
simp [← comp_map, Function.comp]
simp
match f, x, hf, hx with | _, _, ⟨f, rfl⟩, ⟨x, rfl⟩ => ?_
refine ⟨(fun ⟨a, h₁⟩ ⟨b, h₂⟩ => ⟨a b, H h₁ h₂⟩) <$> f <*> x, ?_⟩
simp only [← pure_seq]
simp [SatisfiesM, seq_assoc]
simp only [← pure_seq]
simp [seq_assoc, Function.comp]
match x, hx with | _, ⟨x, rfl⟩ => ?_
have g a ha := Classical.indefiniteDescription _ (hf a ha)
refine ⟨x >>= fun ⟨a, h⟩ => g a h, ?_⟩
simp [← bind_pure_comp]
congr
funext ⟨a, h⟩
simp [← (g a h).2, ← bind_pure_comp]
revert x
intro | some _, ⟨some ⟨_, h⟩, rfl⟩, _, rfl => exact h
revert x
intro | .ok _, ⟨.ok ⟨_, h⟩, rfl⟩, _, rfl => exact h
exact ⟨fun eq _ => eq ▸ rfl, funext⟩
simp
refine .trans ⟨fun ⟨f, eq⟩ => eq ▸ ?_, fun ⟨f, h⟩ => ?_⟩ Classical.skolem.symm
· refine ⟨fun s => (fun ⟨⟨a, h⟩, s'⟩ => ⟨⟨a, s'⟩, h⟩) <$> f s, fun s => ?_⟩
    rw [← comp_map, map_eq_pure_bind]; rfl
· refine ⟨fun s => (fun ⟨⟨a, s'⟩, h⟩ => ⟨⟨a, h⟩, s'⟩) <$> f s, funext fun s => ?_⟩
    show _ >>= _ = _; simp [map_eq_pure_bind, ← h]
cases o <;> rfl
rw [← Ordering.swap_inj, symm]
exact .rfl
rw [← Ordering.swap_inj, symm]
exact .rfl
have := @TransCmp.le_trans _ cmp _ z y x
simp [cmp_eq_gt] at *
exact this h₂ h₁
rw [cmp_eq_gt] at h₁ h₂ ⊢
exact lt_trans h₂ h₁
rw [← Ordering.swap_inj, symm, symm, cmp_congr_left yz]
decide
simp [h]
simp [self.2]
decide
decide
decide
have := Array.size_mapM (m := StateT (ULift Nat) Id) (go .nil) m.buckets.1
simp [SatisfiesM_StateT_eq, SatisfiesM_Id_eq] at this
simp [this, Id.run, StateT.run, m.2.2]
unfold empty
apply empty'
simp [Array.getElem_eq_data_get]
exact List.exists_of_set' h
simp [Bucket.size_eq, Bucket.mk, mkArray]
clear h
induction n <;> simp [*]
refine ⟨fun _ h => ?_, fun i h => ?_⟩
· simp [Bucket.mk, empty', mkArray, List.mem_replicate] at h
    simp [h, List.Pairwise.nil]
· simp [Bucket.mk, empty', mkArray, Array.getElem_eq_data_get, AssocList.All]
refine ⟨fun l hl => ?_, fun i hi p hp => ?_⟩
· exact match List.mem_or_eq_of_mem_set hl with
    | .inl hl => H.1 _ hl
    | .inr rfl => h₁ (H.1 _ (Array.getElem_mem_data ..))
· revert hp; simp [update_data, Array.getElem_eq_data_get, List.get_set]
    split <;> intro hp
    · next eq => exact eq ▸ h₂ (H.2 _ _) _ hp
    · simp at hi; exact H.2 i hi _ hp
simp [Bucket.size_eq, reinsertAux]
refine have ⟨l₁, l₂, h₁, _, eq⟩ := Bucket.exists_of_update ..; eq ▸ ?_
simp [h₁, Nat.succ_add]
rfl
rw [expand, go]
· rw [Bucket.mk_size]; simp [Bucket.size]
· intro.
simp
induction l generalizing target with
  | nil => exact ⟨ht₁, fun _ h₁ _ h₂ => (ht₂ _ h₁ _ h₂).1⟩
  | cons _ _ ih =>
    simp at hl₁ hl₂ ht₂
    refine ih hl₁.2 hl₂.2
      (reinsertAux_WF ht₁ fun _ h => (ht₂ _ (Array.getElem_mem_data ..) _ h).2.1)
      (fun _ h => ?_)
    simp [reinsertAux, Bucket.update] at h
    match List.mem_or_eq_of_mem_set h with
    | .inl h =>
      intro _ hf
      have ⟨h₁, h₂⟩ := ht₂ _ h _ hf
      exact ⟨h₁, h₂.2⟩
    | .inr h => subst h; intro
      | _, .head .. =>
        exact ⟨hl₂.1 ▸ Nat.le_refl _, fun _ h h' => hl₁.1 _ h (PartialEquivBEq.symm h')⟩
      | _, .tail _ h =>
        have ⟨h₁, h₂⟩ := ht₂ _ (Array.getElem_mem_data ..) _ h
        exact ⟨h₁, h₂.2⟩
simp_all [Bucket.mk, List.mem_replicate]
simp_all
dsimp [insert, cond]
split
· unfold Bucket.size
    refine have ⟨_, _, h₁, _, eq⟩ := Bucket.exists_of_update ..; eq ▸ ?_
    simp [h, h₁, Bucket.size_eq]
split
· unfold Bucket.size
    refine have ⟨_, _, h₁, _, eq⟩ := Bucket.exists_of_update ..; eq ▸ ?_
    simp [h, h₁, Bucket.size_eq, Nat.succ_add]; rfl
· rw [expand_size]; simp [h, expand, Bucket.size]
    refine have ⟨_, _, h₁, _, eq⟩ := Bucket.exists_of_update ..; eq ▸ ?_
    simp [h₁, Bucket.size_eq, Nat.succ_add]; rfl
induction l with
  | nil => exact .inr
  | cons a l ih =>
    simp; generalize e : cond .. = z; revert e
    unfold cond; split <;> (intro h; subst h; simp)
    · intro
      | .inl eq => exact eq ▸ .inl rfl
      | .inr h => exact .inr (.inr h)
    · intro
      | .inl eq => exact .inr (.inl eq)
      | .inr h => exact (ih h).imp_right .inr
induction hx₁ with
  | head => simp_all; exact (H.1 · · ∘ PartialEquivBEq.trans hx₂)
  | tail _ _ ih =>
    simp at H ⊢
    generalize e : cond .. = z; revert e
    unfold cond; split <;> (intro h; subst h; simp)
    · next e => exact ⟨(H.1 · · ∘ PartialEquivBEq.trans e), H.2⟩
    · next e =>
      refine ⟨fun a h => ?_, ih H.2⟩
      match mem_replaceF h with
      | .inl eq => exact eq ▸ ne_true_of_eq_false e
      | .inr h => exact H.1 a h
dsimp [erase, cond]
split
· next H =>
    simp [h, Bucket.size]
    refine have ⟨_, _, h₁, _, eq⟩ := Bucket.exists_of_update ..; eq ▸ ?_
    simp [h, h₁, Bucket.size_eq]
    rw [(_ : List.length _ = _ + 1), Nat.add_right_comm]; {rfl}
    clear h₁ eq
    simp [AssocList.contains_eq] at H
    have ⟨a, h₁, h₂⟩ := H
    refine have ⟨_, _, _, _, _, h, eq⟩ := List.exists_of_eraseP h₁ h₂; eq ▸ ?_
    simp [h]; rfl
· exact h
dsimp [erase, cond]
split
· refine h.update (fun H => ?_) (fun H a h => ?_) <;> simp at h ⊢
    · simp; exact H.sublist (List.eraseP_sublist _)
    · exact H _ (List.mem_of_mem_eraseP h)
· exact h
induction h with
  | mk h₁ h₂ => exact ⟨h₁, h₂⟩
  | @empty' _ h => exact ⟨(Bucket.mk_size h).symm, .mk' h⟩
  | insert _ ih => exact ⟨insert_size ih.1, insert_WF ih.2⟩
  | erase _ ih => exact ⟨erase_size ih.1, erase_WF ih.2⟩
have ⟨h₁, h₂⟩ := H.out
simp [Imp.mapVal, Bucket.mapVal, WF_iff, h₁]
refine ⟨?_, ?_, fun i h => ?_⟩
· simp [Bucket.size]; congr; funext l; simp
· simp [List.forall_mem_map_iff, List.pairwise_map]
    exact fun _ => h₂.1 _
· simp [AssocList.All, List.forall_mem_map_iff] at h ⊢
    exact h₂.2 _ h
induction l generalizing n acc with simp [filterMap.go, *]
    | cons a b l => match f a b with
      | none => rfl
      | some c => simp; rw [Nat.add_right_comm]; rfl
induction l generalizing n with
    | nil => rfl
    | cons l L IH => simp [bind, StateT.bind, IH, H1, Nat.add_assoc]; rfl
induction l with
    | nil => exact .slnil
    | cons a l ih =>
      simp; exact match f a.1 a.2 with
      | none => .cons _ ih
      | some b => .cons₂ _ ih
simp [Bucket.size]
simp_wf
simp_arith [*]
rw [combine] at eq
split at eq <;> cases eq <;>
        simp [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm]
simp_wf
simp_arith [*]
simp [hk, Nat.add_assoc]
simp [eq, Nat.add_assoc]
simp [eq, Nat.add_assoc, Nat.add_comm, Nat.add_left_comm]
simp [toHeap.go, go, Nat.add_assoc, Nat.add_left_comm]
simp
simp
simp only [Heap.tail?]
intro eq
match eq₂ : s.deleteMin le, eq with
  | some (a, tl), rfl => exact realSize_deleteMin eq₂
simp only [Heap.tail]
match eq : s.tail? le with
  | none => cases s with cases eq | nil => rfl
  | some tl => simp [Heap.realSize_tail? eq]; rfl
simp_arith [Heap.realSize_deleteMin eq]
decide
unfold combine at eq
split at eq <;> cases eq <;> rename_i h
· exact ⟨r₁, rfl, h, hn₂, hn₁⟩
· exact ⟨r₁, rfl, TotalBLE.total.resolve_left h, hn₁, hn₂⟩
simp_wf
simp_arith [*]
rw [findMin, headD]
split <;> apply findMin_val
simp only [deleteMin, findMin_val, Option.map, head?]
simp_arith only [rankTR.go, go, rank]
rw [realSize, realSize_eq c, Nat.pow_succ, Nat.mul_succ]
simp [Nat.add_assoc, realSize_eq s]
simp [size, Nat.shiftLeft, size_eq h₂, Nat.pow_succ, Nat.mul_succ]
simp [Nat.add_assoc, Nat.one_shiftLeft, h₁.realSize_eq, h₂.size_eq]
rw [toHeap, rankTR_eq]
exact go h trivial
rw [← h'.rank_eq] at h
exact h
let ⟨h₁, h₂, h₃⟩ := h
simp [Heap.findMin]
split
· exact findMin h₃ hr (fun h => hk ⟨h₁, h₂, h⟩)
· exact findMin h₃ ⟨_, fun h => hk (h.of_le h₁), h₂, h₃⟩ (fun h => hk ⟨h₁, h₂, h⟩)
cases s with cases eq | cons r a c s => ?_
have : Nonempty ((s.findMin le (cons r a c) ⟨id, a, c, s⟩).WellFormed le) :=
    let ⟨_, h₂, h₃⟩ := h
    h₃.findMin ⟨_, fun h => h.of_le (Nat.zero_le _), h₂, h₃⟩
      fun h => ⟨Nat.zero_le _, h₂, h⟩
revert this
match s.findMin le (cons r a c) ⟨id, a, c, s⟩ with
  | { before, val, node, next } =>
    intro ⟨⟨_, hk, ih₁, ih₂⟩⟩
    exact ih₁.toHeap.merge <| hk (ih₂.of_le (Nat.le_succ _))
simp only [Heap.tail?]
intro eq
match eq₂ : s.deleteMin le, eq with
  | some (a, tl), rfl => exact hwf.deleteMin eq₂
simp only [Heap.tail]
match eq : s.tail? le with
  | none => exact Heap.WellFormed.nil
  | some tl => exact hwf.tail? eq
simp [gcd_succ]
induction m, n using gcd.induction with
  | H0 n => rw [gcd_zero_left]; exact ⟨Nat.dvd_zero n, Nat.dvd_refl n⟩
  | H1 m n _ IH => rw [← gcd_rec] at IH; exact ⟨IH.2, (dvd_mod_iff IH.2).1 IH.1⟩
induction m, n using gcd.induction with intro km kn
  | H0 n => rw [gcd_zero_left]; exact kn
  | H1 n m _ IH => rw [gcd_rec]; exact IH ((dvd_mod_iff km).2 kn) km
rw [gcd_rec, mod_eq_zero_of_dvd h, gcd_zero_left]
rw [gcd_comm]
exact gcd_eq_left_iff_dvd
rw [Nat.mul_comm m n, Nat.mul_comm k n, Nat.mul_comm (gcd m k) n, gcd_mul_left]
rw [gcd_comm] at H
exact eq_zero_of_gcd_eq_zero_left H
simp [H0]
apply Nat.eq_of_mul_eq_mul_right H3
rw [Nat.div_mul_cancel (dvd_gcd H1 H2), ← gcd_mul_right,
        Nat.div_mul_cancel H1, Nat.div_mul_cancel H2]
rw [gcd_comm, gcd_eq_left H]
rw [gcd_comm, gcd_mul_left_left]
rw [Nat.mul_comm, gcd_mul_left_left]
rw [gcd_comm, gcd_mul_right_left]
rw [gcd_comm n m, gcd_gcd_self_right_left]
rw [gcd_comm, gcd_gcd_self_right_right]
rw [gcd_comm m n, gcd_gcd_self_left_right]
simp [gcd_rec m (n + k * m), gcd_rec m n]
simp [h]
rw [lcm, lcm, Nat.mul_comm n m, gcd_comm n m]
simp [lcm]
simp [lcm]
simp [lcm]
simp [lcm]
match eq_zero_or_pos m with
  | .inl h => rw [h, lcm_zero_left]
  | .inr h => simp [lcm, Nat.mul_div_cancel _ h]
rw [← Nat.mul_div_assoc m (Nat.gcd_dvd_right m n)]
rfl
rw [lcm, Nat.mul_div_cancel' (Nat.dvd_trans (gcd_dvd_left m n) (Nat.dvd_mul_right m n))]
match eq_zero_or_pos k with
  | .inl h => rw [h]; exact Nat.dvd_zero _
  | .inr kpos =>
    apply Nat.dvd_of_mul_dvd_mul_left (gcd_pos_of_pos_left n (pos_of_dvd_of_pos H1 kpos))
    rw [gcd_mul_lcm, ← gcd_mul_right, Nat.mul_comm n k]
    exact dvd_gcd (Nat.mul_dvd_mul_left _ H2) (Nat.mul_dvd_mul_right H1 _)
intro h
have h1 := gcd_mul_lcm m n
rw [h, Nat.mul_zero] at h1
match mul_eq_zero.1 h1.symm with
  | .inl hm1 => exact hm hm1
  | .inr hn1 => exact hn hn1
rw [coprime, Nat.gcd_assoc, H.symm.gcd_eq_one, gcd_one_right]
rw [Nat.mul_comm m k, H.gcd_mul_left_cancel m]
rw [gcd_comm m n, gcd_comm m (k * n), H.gcd_mul_left_cancel n]
rw [Nat.mul_comm n k, H.gcd_mul_left_cancel_right n]
rw [coprime_iff_gcd_eq_one, gcd_div (gcd_dvd_left m n) (gcd_dvd_right m n), Nat.div_self H]
rw [← co.gcd_eq_one]
exact dvd_gcd Hm Hn
match eq_zero_or_pos a with
  | .inl h0 =>
    rw [h0] at dvd
    rw [Nat.eq_zero_of_zero_dvd dvd] at cmn ⊢
    simp; assumption
  | .inr hpos =>
    let ⟨k, hk⟩ := dvd
    rw [hk, Nat.mul_div_cancel_left _ hpos]
    rw [hk] at cmn
    exact cmn.coprime_mul_left
rw [@coprime_comm k, @coprime_comm k, @coprime_comm k, coprime_mul_iff_left]
simp [coprime]
simp [coprime]
simp [coprime]
rw [← H.gcd_eq_one, gcd_eq_left d]
have hd : gcd k m * (k / gcd k m) = k := Nat.mul_div_cancel' (gcd_dvd_left k m)
refine ⟨⟨⟨gcd k m, gcd_dvd_right k m⟩, ⟨k / gcd k m, ?_⟩⟩, hd.symm⟩
apply Nat.dvd_of_mul_dvd_mul_left (Nat.pos_of_ne_zero h0)
rw [hd, ← gcd_mul_right]
exact Nat.dvd_gcd (Nat.dvd_mul_right _ _) H
apply dvd_antisymm
· apply ((cop.gcd_left _).mul (cop.gcd_left _)).dvd_of_dvd_mul_right
    rw [← h]
    apply Nat.mul_dvd_mul (gcd_dvd ..).1 (gcd_dvd ..).1
· rw [gcd_comm a, gcd_comm b]
    refine Nat.dvd_trans ?_ (gcd_mul_dvd_mul_gcd ..)
    rw [h, gcd_mul_right_right d c]; apply Nat.dvd_refl
simp [Nat.zero_add]
rw [add_one, succ_add] at h
cases succ_ne_zero _ h
rw [Nat.add_comm]
exact Nat.lt_add_of_pos_right h

/- sub properties -/
simp [succ_sub_succ] at h₁
exact succ_le_succ <| Nat.le_of_le_of_sub_le_sub_right (le_of_succ_le_succ h₀) h₁
rw [← Nat.add_sub_cancel x k, Nat.sub_le_sub_right_iff h, Nat.add_sub_cancel]
rw [Nat.sub_zero] at H
simp [H]
simp [Nat.add_sub_add_right] at H
exact H
rw [c_eq.symm, Nat.sub_add_cancel ab]
rw [a_eq, Nat.add_sub_cancel]
simp [Nat.sub_eq_zero_of_le H'] at H
simp [Nat.min_def]
split <;> split <;> simp [*]
· next h₁ h₂ => exact Nat.le_antisymm h₁ h₂
· next h₁ h₂ => cases not_or_intro h₁ h₂ <| Nat.le_total ..
rw [Nat.min_def]
split <;> simp [*]
rw [Nat.min_def]
split <;> assumption
simp [Nat.min_def, h]
rw [Nat.min_comm a b]
exact Nat.min_eq_left h
simp only [Nat.max_def]
rw [Nat.max_def]
split <;> simp [*]
rw [Nat.max_def]
split <;> assumption
simp [Nat.max_def, h, Nat.not_lt.2 h]
rw [← Nat.max_comm b a]
exact Nat.max_eq_right h

-- Distribute succ over min
simp [Nat.min_def, succ_le_succ_iff]
split <;> rfl
rw [Nat.min_def]
split
· rw [Nat.sub_eq_zero_of_le ‹n ≤ m›, Nat.sub_self]
· rfl
rw [sub_eq_sub_min, Nat.sub_add_cancel (Nat.min_le_left n m)]

/- multiplication -/
rw [Nat.mul_assoc, Nat.mul_comm m, ← Nat.mul_assoc]
simp [Nat.mul_succ]
simp [Nat.succ_mul]

/- mod -/

-- TODO mod_core_congr, mod_def
simp
induction m, k using mod.inductionOn with rw [div_eq, mod_eq]
  | base x y h => simp [h]
  | ind x y h IH => simp [h]; rw [Nat.mul_succ, ← Nat.add_assoc, IH, Nat.sub_add_cancel h.2]

/- div -/
rw [div_eq]
simp [Nat.lt_irrefl]
induction y, k using mod.inductionOn generalizing x with
    (rw [div_eq]; simp [h]; cases x with simp [zero_le] | succ x => ?_)
  | base y k h =>
    simp [not_succ_le_zero x, succ_mul, Nat.add_comm]
    refine Nat.lt_of_lt_of_le ?_ (Nat.le_add_right ..)
    exact Nat.not_le.1 fun h' => h ⟨k0, h'⟩
  | ind y k h IH =>
    rw [← add_one, Nat.add_le_add_iff_le_right, IH k0, succ_mul,
        ← Nat.add_sub_cancel (x*k) k, Nat.sub_le_sub_right_iff h.2, Nat.add_sub_cancel]
simp [Nat.div_zero, n.zero_le]
rw [mod_add_div]
rw [div_eq a, if_pos]
constructor <;> assumption
rw [div_eq a, if_neg]
intro h₁
apply Nat.not_le_of_gt h₀ h₁.right
rw [← Nat.not_le, ← Nat.not_le]
exact not_congr (le_div_iff_mul_le Hk)

/- successor and predecessor -/
cases n <;> simp
rw [Nat.succ_eq_add_one, Nat.add_comm]
simp [succ_add, add_succ]
simp [Nat.add_comm]
rw [succ_mul] at h
exact .inr (Nat.eq_zero_of_add_eq_zero_left h)
simp [h]
match a.le_total b with
  | .inl hl => rw [Nat.max_eq_right hl, Nat.sub_eq_zero_iff_le.mpr hl, Nat.zero_add]
  | .inr hr => rw [Nat.max_eq_left hr, Nat.sub_add_cancel hr]
rw [← Nat.sub_sub]
apply sub_le
rw [Nat.sub_sub, Nat.sub_sub, add_succ, succ_sub_succ]
rw [Nat.sub_sub, Nat.sub_sub, Nat.add_comm]
rw [Nat.mul_sub_left_distrib, Nat.right_distrib, Nat.right_distrib,
      Nat.mul_comm b a, Nat.add_comm (a*a) (a*b), Nat.add_sub_add_left]
rw [mul_succ, succ_mul, Nat.add_right_comm _ a]
rfl
let ⟨k, hk⟩ := Nat.le.dest h
rw [← hk, Nat.add_sub_cancel_left, ← add_succ, Nat.add_sub_cancel_left]
rw [Nat.sub_sub]
apply Nat.sub_lt (Nat.lt_of_lt_of_le (Nat.zero_lt_succ _) h)
rw [Nat.add_comm]
apply Nat.zero_lt_succ
rw [show a = b from h]
apply sub_lt _ h₀
apply Nat.lt_of_lt_of_le h₀ h₁
rw [Nat.add_comm, Nat.sub_add_cancel h]
rw [Nat.add_sub_add_right]
exact lt_succ_of_le (Nat.sub_le _ _)
rw [Nat.add_sub_add_right, Nat.add_sub_add_right]
exact Nat.sub_lt_sub_left (Nat.lt_of_succ_lt_succ h1) (Nat.lt_of_succ_lt_succ h2)
rw [← Nat.add_sub_cancel x k, Nat.sub_le_sub_right_iff h, Nat.add_sub_cancel]
rw [mod_eq_sub_mod (Nat.le_add_left ..), Nat.add_sub_cancel]
rw [Nat.add_comm, add_mod_right]
match z with
  | 0 => rw [Nat.mul_zero, Nat.add_zero]
  | succ z => rw [mul_succ, ← Nat.add_assoc, add_mod_right, add_mul_mod_self_left (z := z)]
rw [Nat.mul_comm, add_mul_mod_self_left]
rw [← Nat.zero_add (m * n), add_mul_mod_self_left, zero_mod]
rw [Nat.mul_comm, mul_mod_right]
rw [y0, Nat.mul_zero, mod_zero, mod_zero]
rw [z0, Nat.zero_mul, Nat.zero_mul, Nat.zero_mul, mod_zero]
induction x using Nat.strongInductionOn with
    | _ n IH =>
      have y0 : y > 0 := Nat.pos_of_ne_zero y0
      have z0 : z > 0 := Nat.pos_of_ne_zero z0
      cases Nat.lt_or_ge n y with
      | inl yn => rw [mod_eq_of_lt yn, mod_eq_of_lt (Nat.mul_lt_mul_of_pos_left yn z0)]
      | inr yn =>
        rw [mod_eq_sub_mod yn, mod_eq_sub_mod (Nat.mul_le_mul_left z yn),
          ← Nat.mul_sub_left_distrib]
        exact IH _ (sub_lt (Nat.lt_of_lt_of_le y0 yn) y0)
rw [Nat.mul_comm x z, Nat.mul_comm y z, Nat.mul_comm (x % y) z]
apply mul_mod_mul_left

-- TODO cont_to_bool_mod_two
apply Nat.le_of_add_le_add_right (b := n * k)
rw [Nat.sub_add_cancel h₂]
simp [mul_succ, Nat.add_comm] at h₁
simp [h₁]
apply Nat.le_of_add_le_add_right
rw [Nat.sub_add_cancel h₂, Nat.add_comm]
rw [mul_succ] at h₁
exact h₁
simp
rw [div_eq_sub_div H (Nat.le_add_left _ _), Nat.add_sub_cancel]
rw [Nat.add_comm, add_div_right x H]
induction n <;> simp_all [mul_succ]
rw [Nat.mul_comm, mul_div_right _ H]
induction z with
  | zero => rw [Nat.mul_zero, Nat.add_zero, Nat.add_zero]
  | succ z ih => rw [mul_succ, ← Nat.add_assoc, add_div_right _ H, ih]; rfl
rw [Nat.mul_comm, add_mul_div_left _ _ H]
rw [Nat.mul_comm, Nat.mul_div_cancel _ H]
rw [H2, Nat.mul_div_cancel _ H1]
rw [H2, Nat.mul_div_cancel_left _ H1]
rw [hn, Nat.mul_zero] at hi lo
exact absurd lo (Nat.not_le_of_gt hi)
rw [n0, Nat.zero_mul] at h₁
exact not_lt_zero _ h₁
cases eq_zero_or_pos k with
  | inl k0 => rw [k0, Nat.mul_zero, Nat.div_zero, Nat.div_zero] | inr kpos => ?_
cases eq_zero_or_pos n with
  | inl n0 => rw [n0, Nat.zero_mul, Nat.div_zero, Nat.zero_div] | inr npos => ?_
apply Nat.le_antisymm
· apply (le_div_iff_mul_le (Nat.mul_pos npos kpos)).2
    rw [Nat.mul_comm n k, ← Nat.mul_assoc]
    apply (le_div_iff_mul_le npos).1
    apply (le_div_iff_mul_le kpos).1
    (apply Nat.le_refl)
· apply (le_div_iff_mul_le kpos).2
    apply (le_div_iff_mul_le npos).2
    rw [Nat.mul_assoc, Nat.mul_comm n k]
    apply (le_div_iff_mul_le (Nat.mul_pos kpos npos)).1
    apply Nat.le_refl
rw [← Nat.div_div_eq_div_mul, Nat.mul_div_cancel_left _ H]
match n, Nat.eq_zero_or_pos n with
  | _, Or.inl rfl => rw [Nat.zero_mul]; exact m.zero_le
  | n, Or.inr h => rw [Nat.mul_comm, ← Nat.le_div_iff_mul_le h]; exact Nat.le_refl _

/- dvd -/
simp
simp
simp[h₃,h₄, Nat.mul_assoc]
simp [Nat.left_distrib, hd, he]
rw [Nat.mul_sub_left_distrib, ← he, Nat.add_sub_cancel_left]
rw [Nat.add_comm]
exact Nat.dvd_add_iff_right h
simp [he, hf, Nat.mul_assoc, Nat.mul_left_comm, Nat.mul_comm]
decide
decide
let ⟨z, H⟩ := H
rw [H, mul_mod_right]
rw [Nat.mul_comm, Nat.mul_div_cancel' H]
rw [Nat.div_mul_cancel H]
let ⟨l, H⟩ := H
rw [Nat.mul_assoc] at H
exact ⟨_, Nat.eq_of_mul_eq_mul_left kpos H⟩
rw [Nat.mul_comm m k, Nat.mul_comm n k] at H
exact Nat.dvd_of_mul_dvd_mul_left kpos H

/- --- -/
simp [n0, mod_zero]
conv => lhs; rw [
    ← mod_add_div a n, ← mod_add_div b n, Nat.add_mul, Nat.mul_add, Nat.mul_add,
    Nat.mul_assoc, Nat.mul_assoc, ← Nat.mul_add n, add_mul_mod_self_left,
    Nat.mul_comm _ (n * (b / n)), Nat.mul_assoc, add_mul_mod_self_left]
rw [Nat.add_comm, mod_add_mod, Nat.add_comm]
rw [add_mod_mod, mod_add_mod]
rw [Nat.pow_succ, Nat.mul_comm]
simp [pow_succ, Nat.mul_assoc, Nat.mul_left_comm, Nat.mul_comm]
rw [shiftLeft_eq, Nat.one_mul]
decide
rw [← Nat.not_le, ← Nat.not_le, le_log2 h]
induction l₁ <;> simp [*, Nat.add_assoc]
simp
intro t
simp
rw [h]
intro t
show f (g t) = (f (g [])) ++ t
rw [h₁ (g t), h₂ t, ← append_assoc (f []) (g []) t, ← h₁ (g [])]
intro t
show f (a :: t) = f (a :: nil) ++ t
rw [h [a], h (a::t), append_assoc (f []) [a] t]
rfl
simp [fdiv]
simp
simp
simp
simp
cases b <;> rfl
simp
simp
simp
simp
rw [Nat.div_zero]
rfl
rw [Nat.div_zero]
rfl
simp [Int.neg_zero]
simp [Int.div_neg, Int.neg_div, Int.neg_neg]
simp [Int.div, neg_ofNat_of_succ]
rw [← Int.neg_inj, ← Int.ediv_neg, Int.neg_add, ← Int.ediv_neg, ← Int.neg_mul_neg]
exact this (Int.neg_pos_of_neg hlt)
rw [← Int.add_sub_cancel (ediv ..), ← this, Int.sub_add_cancel]
show ((n * k.succ : Nat) - m.succ : Int).ediv k.succ = n - (m / k.succ + 1 : Nat)
rw [negSucc_eq, Int.ofNat_sub h]
simp only [Int.sub_eq_add_neg, Int.neg_add, Int.neg_neg, Int.add_left_comm, Int.add_assoc]
simp [h]
let ⟨k, hk⟩ := H
rw [hk, Int.mul_comm c k, Int.add_mul_ediv_right _ _ h,
      ← Int.zero_add (k * c), Int.add_mul_ediv_right _ _ h, Int.zero_ediv, Int.zero_add]
rw [Int.add_comm, Int.add_ediv_of_dvd_right H, Int.add_comm]
rw [fdiv_eq_ediv _ b0, mul_ediv_cancel _ H]
simp [Int.zero_mul]
rw [← ofNat_mul, ← ofNat_div,
      Nat.mul_div_cancel _ <| Nat.pos_of_ne_zero <| Int.ofNat_ne_zero.1 H]
rw [Int.mul_neg, Int.neg_div, Int.div_neg, Int.neg_neg,
      this (Int.neg_ne_zero.1 H)]
rw [Int.neg_mul, Int.neg_div, this H]
rw [Int.neg_mul_neg, Int.div_neg, this (Int.neg_ne_zero.1 H)]
cases m <;> simp [fmod]
rw [Int.sub_sub, Int.add_comm]
match b, eq_succ_of_zero_lt bpos with
  | _, ⟨n, rfl⟩ => rfl
cases b <;> simp [mod]
cases b <;> rfl
simp [mod_def', emod]
show (m % succ n + -↑(succ n) * -↑(m / succ n) : Int) = m
rw [Int.neg_mul_neg]
exact congrArg ofNat (Nat.mod_add_div ..)
show -(↑((succ m) % n) : Int) + ↑n * -↑(succ m / n) = -↑(succ m)
rw [Int.mul_neg, ← Int.neg_add]
exact congrArg (-ofNat ·) (Nat.mod_add_div ..)
show -(↑(succ m % succ n) : Int) + -↑(succ n) * ↑(succ m / succ n) = -↑(succ m)
rw [Int.neg_mul, ← Int.neg_add]
exact congrArg (-ofNat ·) (Nat.mod_add_div ..)
simp
show subNatNat (m % succ n) n + (↑(succ n * (m / succ n)) + n + 1) = (m + 1)
rw [Int.add_comm _ n, ← Int.add_assoc, ← Int.add_assoc,
      Int.subNatNat_eq_coe, Int.sub_add_cancel]
exact congrArg (ofNat · + 1) <| Nat.mod_add_div ..
rw [fmod_zero]
rfl
show subNatNat .. - (↑(succ n * (m / succ n)) + ↑(succ n)) = -↑(succ m)
rw [Int.subNatNat_eq_coe, ← Int.sub_sub, ← Int.neg_sub, Int.sub_sub, Int.sub_sub_self]
exact congrArg (-ofNat ·) <| Nat.succ_add .. ▸ Nat.mod_add_div .. ▸ rfl
show -(↑(succ m % succ n) : Int) + -↑(succ n * (succ m / succ n)) = -↑(succ m)
rw [← Int.neg_add]
exact congrArg (-ofNat ·) <| Nat.mod_add_div ..
show (m % succ n + -↑(succ n) * -↑(m / succ n) : Int) = m
rw [Int.neg_mul_neg]
exact congrArg ofNat <| Nat.mod_add_div ..
rw [emod_zero]
rfl
rw [← ofNat_emod, ← ofNat_ediv, ← Int.sub_sub, negSucc_eq, Int.sub_sub n,
      ← Int.neg_neg (_-_), Int.neg_sub, Int.sub_sub_self, Int.add_right_comm]
exact congrArg (fun x => -(ofNat x + 1)) (Nat.mod_add_div ..)
rw [← Int.add_sub_cancel (mod a b), mod_add_div]
rw [← Int.add_sub_cancel (a.fmod b), fmod_add_fdiv]
rw [← Int.add_sub_cancel (a % b), emod_add_ediv]
simp [fmod_def, emod_def, fdiv_eq_ediv _ hb]
simp [emod_def, mod_def, ediv_eq_div ha hb]
rw [mod_def, mod_def, Int.div_neg, Int.neg_mul_neg]
rw [emod_def, emod_def, Int.ediv_neg, Int.neg_mul_neg]
simp [mod_def, Int.div_one, Int.one_mul, Int.sub_self]
simp [emod_def, Int.one_mul, Int.sub_self]
simp [fmod_def, Int.one_mul, Int.sub_self]
rw [fmod_eq_mod H1 (Int.le_trans H1 (Int.le_of_lt H2)), mod_eq_of_lt H1 H2]
rw [emod_eq_mod H1 (Int.le_trans H1 (Int.le_of_lt H2)), mod_eq_of_lt H1 H2]
simp [emod, Int.subNatNat_eq_coe]
exact Int.sub_lt_self _ (ofNat_lt.2 <| Nat.succ_pos _)
rw [Int.mul_comm]
apply mod_add_div
rw [Int.mul_comm]
apply div_add_mod
rw [Int.mul_comm]
apply emod_add_ediv
rw [Int.mul_comm]
apply ediv_add_emod
rw [cz, Int.mul_zero, Int.add_zero]
rw [Int.emod_def, Int.emod_def, Int.add_mul_ediv_right _ _ cz, Int.add_comm _ b,
      Int.mul_add, Int.mul_comm, ← Int.sub_sub, Int.add_sub_cancel]
rw [Int.mul_comm, Int.add_mul_emod_self]
rw [Int.add_comm, Int.add_emod_self]
rw [Int.add_comm, emod_add_emod, Int.add_comm]
rw [add_emod_emod, emod_add_emod]
rw [← emod_add_emod, ← emod_add_emod k, H]
rw [Int.add_comm, add_emod_eq_add_emod_right _ H, Int.add_comm]
rw [Int.add_comm, Int.add_comm i, emod_add_cancel_right]
simp [Int.sub_self]
simp [h, Int.mul_zero]
rw [Int.mod_def, Int.mul_div_cancel _ h, Int.mul_comm, Int.sub_self]
simp [h, Int.mul_zero]
rw [Int.fmod_def, Int.mul_fdiv_cancel _ h, Int.mul_comm, Int.sub_self]
rw [← Int.zero_add (a * b), Int.add_mul_emod_self, Int.zero_emod]
rw [Int.mul_comm, mul_mod_left]
rw [Int.mul_comm, mul_fmod_left]
rw [Int.mul_comm, mul_emod_left]
conv => lhs; rw [
    ← emod_add_ediv a n, ← emod_add_ediv' b n, Int.add_mul, Int.mul_add, Int.mul_add,
    Int.mul_assoc, Int.mul_assoc, ← Int.mul_add n _ _, add_mul_emod_self_left,
    ← Int.mul_assoc, add_mul_emod_self]
conv => rhs; rw [← emod_add_ediv n k]
match k, h with
  | _, ⟨t, rfl⟩ => rw [Int.mul_assoc, add_mul_emod_self_left]
conv => rhs; rw [← emod_add_ediv a b, add_mul_emod_self_left]
apply (emod_add_cancel_right b).mp
rw [Int.sub_add_cancel, ← Int.add_emod_emod, Int.sub_add_cancel, emod_emod]
constructor
· intro ⟨rfl, rfl⟩
    exact ⟨emod_add_ediv a b, emod_nonneg _ (Int.ne_of_gt h), emod_lt_of_pos _ h⟩
· intro ⟨rfl, hz, hb⟩
    constructor
    · rw [Int.add_mul_ediv_left r q (Int.ne_of_gt h), ediv_eq_zero_of_lt hz hb]
      simp [Int.zero_add]
    · rw [add_mul_emod_self_left, emod_eq_of_lt hz hb]
rw [Int.mul_neg, Int.ediv_neg, Int.ediv_neg]
apply congrArg Neg.neg
apply this
rw [Int.ofNat_zero, Int.mul_zero, Int.ediv_zero, Int.ediv_zero]
apply Nat.div_eq_of_lt_le
· refine Nat.le_trans ?_ (Nat.le_add_right _ _)
        rw [← Nat.mul_div_mul _ _ m.succ_pos]
        apply Nat.div_mul_le_self
· show m.succ * n.succ ≤ _
        rw [Nat.mul_left_comm]
        apply Nat.mul_le_mul_left
        apply (Nat.div_lt_iff_lt_mul k.succ_pos).1
        apply Nat.lt_succ_self
rw [Int.mul_comm, Int.mul_comm c, mul_ediv_mul_of_pos _ _ H]
rw [emod_def, emod_def, mul_ediv_mul_of_pos _ _ H, Int.mul_sub, Int.mul_assoc]
rw [Int.add_mul, Int.one_mul, Int.mul_comm]
exact Int.lt_add_of_sub_left_lt <| Int.mod_def .. ▸ mod_lt_of_pos _ H
rw [Int.add_mul, Int.one_mul, Int.mul_comm]
exact Int.lt_add_of_sub_left_lt <| Int.emod_def .. ▸ emod_lt_of_pos _ H
rw [Int.div_neg, natAbs_neg, natAbs_neg]
rfl
rw [Int.neg_div, natAbs_neg, natAbs_neg]
rfl
rw [Int.neg_div_neg, natAbs_neg, natAbs_neg]
rfl
rw [Int.ediv_neg, natAbs_neg]
apply aux
rw [Int.mul_comm, mul_div_cancel_of_mod_eq_zero H]
rw [Int.mul_comm, mul_ediv_cancel_of_emod_eq_zero H]
rw [Int.mul_assoc]
rw [e, Int.zero_mul]
simp [e, Int.neg_mul, Int.mul_neg, Int.neg_neg]
simp [← e, Int.neg_mul, Int.mul_neg, Int.neg_neg]
rw [Int.mul_add]
rw [Int.mul_sub]
rw [Int.add_comm, Int.dvd_add_left H]
rw [← Int.sub_neg] at H
rw [Int.dvd_iff_dvd_of_dvd_sub H, Int.dvd_neg]
rw [e, Int.ofNat_mul]
refine ⟨fun ⟨k, hk⟩ => ?_, fun ⟨k, hk⟩ => ⟨natAbs k, hk.symm ▸ natAbs_mul a k⟩⟩
rw [← natAbs_ofNat k, ← natAbs_mul, natAbs_eq_natAbs_iff] at hk
cases hk <;> subst b
· apply Int.dvd_mul_right
· rw [← Int.mul_neg]; apply Int.dvd_mul_right
rw [← e]
rw [← Int.neg_dvd, ← e]
rw [← e]
rw [← Int.dvd_neg, ← e]
rw [← natAbs_dvd_natAbs, natAbs_ofNat]
rw [← natAbs_dvd_natAbs, natAbs_ofNat]
rw [← natAbs_of_nonneg H1, ← natAbs_of_nonneg H2]
rw [ofNat_dvd, ofNat_dvd, ofNat_inj]
apply Nat.dvd_antisymm
rw [h]
rw [Int.mul_comm, Int.div_mul_cancel H]
rw [Int.mul_comm, Int.ediv_mul_cancel H]
simp [cz, Int.mul_zero]
rw [Int.mul_left_comm, Int.mul_div_cancel_left _ cz, Int.mul_div_cancel_left _ cz]
simp [cz, Int.mul_zero]
rw [Int.mul_left_comm, Int.mul_ediv_cancel_left _ cz, Int.mul_ediv_cancel_left _ cz]
rw [Int.mul_comm, Int.mul_div_assoc _ h, Int.mul_comm]
rw [Int.mul_comm, Int.mul_ediv_assoc _ h, Int.mul_comm]
simp [az]
rw [Int.mul_div_cancel_left _ az, Int.mul_assoc, Int.mul_div_cancel_left _ az]
apply Int.dvd_mul_right
rw [← H2, Int.mul_div_cancel' H1]
rw [← H2, Int.mul_ediv_cancel' H1]
rw [H2, Int.mul_div_cancel_left _ H1]
rw [H2, Int.mul_ediv_cancel_left _ H1]
rw [Int.mul_comm]
exact Int.div_eq_iff_eq_mul_right H H'
rw [Int.mul_comm]
exact Int.ediv_eq_iff_eq_mul_right H H'
rw [Int.mul_comm, Int.eq_mul_of_div_eq_right H1 H2]
rw [Int.mul_comm, Int.eq_mul_of_ediv_eq_right H1 H2]
rw [Int.mul_comm, H2]
rw [Int.mul_comm, H2]
rw [← Int.mul_div_cancel' h, H, Int.mul_zero]
rw [← Int.mul_ediv_cancel' h, H, Int.mul_zero]
simp [bz]
rw [Int.neg_mul_eq_mul_neg, Int.mul_ediv_cancel_left _ bz, Int.mul_ediv_cancel_left _ bz]
rw [Int.sub_eq_add_neg, Int.sub_eq_add_neg, Int.add_ediv_of_dvd_right (Int.dvd_neg.2 hcb)]
congr
exact Int.neg_ediv_of_dvd hcb
rw [← Int.add_sub_cancel ((a-b) / c), ← Int.add_ediv_of_dvd_left hcab, Int.sub_add_cancel]
refine ⟨fun h => ?_, congrArg (div · d)⟩
rw [← Int.mul_div_cancel' hda, ← Int.mul_div_cancel' hdb, h]
refine ⟨fun h => ?_, congrArg (ediv · d)⟩
rw [← Int.mul_ediv_cancel' hda, ← Int.mul_ediv_cancel' hdb, h]
simp [sign, Int.mul_one]
simp [sign, Int.mul_zero]
simp [sign, Int.mul_neg, Int.mul_one]
simp [sign, Int.mul_one]
simp [sign, Int.mul_zero]
simp [sign, Int.mul_neg, Int.mul_one]
simp [az]
rw [Int.mul_comm, H']

/- TODO

This section will need to be updated to reflect that `/` is now `Int.ediv`, rather than `Int.div`.

/-! ### `/` and ordering -/

protected theorem ediv_mul_le (a : Int) {b : Int} (H : b ≠ 0) : a.ediv b * b ≤ a :=
  Int.le_of_sub_nonneg <|
rw [Int.mul_comm, ← emod_def]
apply emod_nonneg _ H
rw [← Int.div_mul_cancel H2] <;> exact Decidable.mul_le_mul_of_nonneg_right H3 H1
rw [← Int.mul_div_assoc _ H2] <;> exact (Int.div_eq_of_eq_mul_left H4 H5.symm).symm
rw [← natAbs_dvd, ← dvd_natAbs, ofNat_dvd] at w
rw [← natAbs_eq_zero]
exact eq_zero_of_dvd_of_lt w h
rw [subNatNat, h, ofNat_eq_coe]
rw [subNatNat, h]
simp [H]
rw [← Int.neg_neg a, ← Int.neg_neg b, h]
unfold subNatNat
match h : n - m with
  | 0 =>
    have ⟨k, h⟩ := Nat.le.dest (Nat.le_of_sub_eq_zero h)
    rw [h.symm, Nat.add_sub_cancel_left]; apply hp
  | succ k =>
    rw [Nat.sub_eq_iff_eq_add (Nat.le_of_lt (Nat.lt_of_sub_eq_succ h))] at h
    rw [h, Nat.add_comm]; apply hn
unfold subNatNat
rw [Nat.sub_eq_zero_of_le (Nat.le_add_right ..), Nat.add_sub_cancel_left, ofNat_eq_coe]
simp [subNatNat, Nat.add_assoc, Nat.add_sub_cancel_left]
apply subNatNat_elim m n (fun m n i => subNatNat (m + k) (n + k) = i)
· intro i j
    rw [Nat.add_assoc, Nat.add_comm i k, ← Nat.add_assoc]
    exact subNatNat_add_left
· intro i j
    rw [Nat.add_assoc j i 1, Nat.add_comm j (i+1), Nat.add_assoc, Nat.add_comm (i+1) (j+k)]
    exact subNatNat_add_right
rw [Nat.pos_iff_ne_zero, Ne, natAbs_eq_zero]
cases n <;> rfl
cases a <;> cases b <;>
    simp only [← Int.mul_def, Int.mul, natAbs_negOfNat] <;> simp only [natAbs]
rw [← natAbs_mul, h, natAbs]
rw [← Int.ofNat_mul, natAbs_mul_self]
constructor <;> intro h
· cases Int.natAbs_eq a with
    | inl h₁ | inr h₁ =>
      cases Int.natAbs_eq b with
      | inl h₂ | inr h₂ => rw [h₁, h₂]; simp [h]
· cases h with (subst a; try rfl)
    | inr h => rw [Int.natAbs_neg]
rw [← Int.natAbs_eq_natAbs_iff, Int.natAbs_ofNat]

/- ## sign -/
rw [Int.natAbs_sign, if_neg hz]
match z with | 0 | succ _ | -[_+1] => rfl

/- # ring properties -/

/- addition -/
simp [Nat.add_comm]
simp [Nat.add_comm]
simp [succ_sub (le_of_lt_succ h), subNatNat]
cases n.lt_or_ge k with
  | inl h' =>
    simp [subNatNat_of_lt h', succ_pred_eq_of_pos (Nat.sub_pos_of_lt h')]
    conv => lhs; rw [← Nat.sub_add_cancel (Nat.le_of_lt h')]
    apply subNatNat_add_add
  | inr h' => simp [subNatNat_of_le h',
      subNatNat_of_le (Nat.le_trans h' (le_add_left ..)), Nat.add_sub_assoc h']
have h := Nat.lt_or_ge m n
cases h with
  | inr h' =>
    rw [subNatNat_of_le h']
    simp
    rw [subNatNat_sub h', Nat.add_comm]
  | inl h' =>
    have h₂ : m < n + succ k := Nat.lt_of_lt_of_le h' (le_add_right _ _)
    have h₃ : m ≤ n + k := le_of_succ_le_succ h₂
    rw [subNatNat_of_lt h', subNatNat_of_lt h₂]
    simp [Nat.add_comm]
    rw [← add_succ, succ_pred_eq_of_pos (Nat.sub_pos_of_lt h'), add_succ, succ_sub h₃, Nat.pred_succ]
    rw [Nat.add_comm n, Nat.add_sub_assoc (Nat.le_of_lt h')]
rw [Int.add_comm, ← aux1, Int.add_comm k, aux1, Int.add_comm b]
rw [Int.add_comm, Int.add_comm a, ← aux1, Int.add_comm a, Int.add_comm k]
rw [Int.add_comm, ← aux2, Int.add_comm n, ← aux2, Int.add_comm -[m+1]]
rw [Int.add_comm, Int.add_comm m, Int.add_comm m, ← aux2, Int.add_comm -[k+1]]
simp [add_succ, Nat.add_comm, Nat.add_left_comm, neg_ofNat_of_succ]
simp [Nat.add_assoc]
simp [subNatNat_add]
simp [add_succ]
rw [Int.add_comm, subNatNat_add_negSucc]
simp [add_succ, succ_add, Nat.add_comm]
rw [← Int.add_assoc, Int.add_comm a, Int.add_assoc]
rw [Int.add_assoc, Int.add_comm b, ← Int.add_assoc]

/- ## negation -/
rw [subNatNat_of_sub_eq_zero (Nat.sub_self ..), Nat.sub_self, ofNat_zero]
simp
simp
rw [Int.add_comm, Int.add_left_neg]
rw [← Int.add_zero (-a), ← h, ← Int.add_assoc, Int.add_left_neg, Int.zero_add]
rw [h, Int.neg_neg]
rw [← Int.add_assoc, Int.add_left_neg, Int.zero_add]
rw [← Int.add_assoc, Int.add_right_neg, Int.zero_add]
rw [Int.add_assoc, Int.add_right_neg, Int.add_zero]
rw [Int.add_assoc, Int.add_left_neg, Int.add_zero]
rw [h]
apply Int.add_left_cancel (a := a + b)
rw [Int.add_right_neg, Int.add_comm a, ← Int.add_assoc, Int.add_assoc b,
    Int.add_right_neg, Int.add_zero, Int.add_right_neg]

/- ## subtraction -/
rw [Int.sub_eq_add_neg, Int.add_right_neg]
simp [Int.sub_eq_add_neg]
simp [Int.sub_eq_add_neg]
rw [h, Int.sub_self]
rw [Int.zero_add]
simp [Int.sub_eq_add_neg, Int.add_assoc]
simp [Int.sub_eq_add_neg, Int.add_comm]
simp [Int.sub_eq_add_neg, ← Int.add_assoc]
simp [Int.sub_eq_add_neg]

/- ## multiplication -/
cases a <;> cases b <;> simp [Nat.mul_comm]
cases n <;> rfl
rw [Int.mul_comm]
simp [ofNat_mul_negOfNat, Nat.mul_comm]
cases n <;> rfl
rw [Int.mul_comm, negSucc_mul_negOfNat, Nat.mul_comm]
cases a <;> cases b <;> cases c <;> simp [Nat.mul_assoc]
rw [← Int.mul_assoc, ← Int.mul_assoc, Int.mul_comm a]
rw [Int.mul_assoc, Int.mul_assoc, Int.mul_comm b]
cases a <;> rfl
cases n <;> rfl
cases m with
  | zero => simp [ofNat_zero, Int.zero_mul, Nat.zero_mul]
  | succ m => cases n.lt_or_ge k with
    | inl h =>
      have h' : succ m * n < succ m * k := Nat.mul_lt_mul_of_pos_left h (Nat.succ_pos m)
      simp [subNatNat_of_lt h, subNatNat_of_lt h']
      rw [succ_pred_eq_of_pos (Nat.sub_pos_of_lt h), ← neg_ofNat_of_succ, Nat.mul_sub_left_distrib,
        ← succ_pred_eq_of_pos (Nat.sub_pos_of_lt h')]; rfl
    | inr h =>
      have h' : succ m * k ≤ succ m * n := Nat.mul_le_mul_left _ h
      simp [subNatNat_of_le h, subNatNat_of_le h', Nat.mul_sub_left_distrib]
cases m <;> cases n <;> simp [Nat.succ_add] <;> rfl
cases n.lt_or_ge k with
  | inl h =>
    have h' : succ m * n < succ m * k := Nat.mul_lt_mul_of_pos_left h (Nat.succ_pos m)
    rw [subNatNat_of_lt h, subNatNat_of_le (Nat.le_of_lt h')]
    simp [succ_pred_eq_of_pos (Nat.sub_pos_of_lt h), Nat.mul_sub_left_distrib]
  | inr h => cases Nat.lt_or_ge k n with
    | inl h' =>
      have h₁ : succ m * n > succ m * k := Nat.mul_lt_mul_of_pos_left h' (Nat.succ_pos m)
      rw [subNatNat_of_le h, subNatNat_of_lt h₁, negSucc_mul_ofNat,
        Nat.mul_sub_left_distrib, ← succ_pred_eq_of_pos (Nat.sub_pos_of_lt h₁)]; rfl
    | inr h' => rw [Nat.le_antisymm h h', subNatNat_self, subNatNat_self, Int.mul_zero]
simp [Nat.left_distrib]
simp [negOfNat_eq_subNatNat_zero]
rw [← subNatNat_add]
rfl
simp [negOfNat_eq_subNatNat_zero]
rw [Int.add_comm, ← subNatNat_add]
rfl
simp
rw [← Nat.left_distrib, succ_add]
rfl
simp [Nat.mul_comm]
rw [← Nat.right_distrib, Nat.mul_comm]
simp [negOfNat_eq_subNatNat_zero]
rw [Int.add_comm, ← subNatNat_add]
rfl
simp [negOfNat_eq_subNatNat_zero]
rw [← subNatNat_add]
rfl
simp
rw [← Nat.left_distrib, succ_add]
rfl
simp [Int.mul_comm, Int.mul_add]
rw [← Int.add_mul, Int.add_right_neg, Int.zero_mul]
rw [← Int.mul_add, Int.add_right_neg, Int.mul_zero]
simp
simp
simp [Int.sub_eq_add_neg, Int.mul_add]
simp [Int.sub_eq_add_neg, Int.add_mul]
rw [Int.sub_eq_add_neg, Int.add_assoc, ← Int.sub_eq_add_neg]
match m with
  | 0 => rfl
  | succ m =>
    show ofNat (n - succ m) = subNatNat n (succ m)
    rw [subNatNat, Nat.sub_eq_zero_of_le h]
rw [Int.sub_eq_add_neg, ← Int.neg_add]
rfl
apply subNatNat_elim m n fun m n i => i = m - n
· intros i n
    rw [Int.ofNat_add, Int.sub_eq_add_neg, Int.add_assoc, Int.add_left_comm,
      Int.add_right_neg, Int.add_zero]
· intros i n
    simp only [negSucc_coe, ofNat_add, Int.sub_eq_add_neg, Int.neg_add, ← Int.add_assoc]
    rw [← @Int.sub_eq_add_neg n, ← ofNat_sub, Nat.sub_self, ofNat_zero, Int.zero_add]
    apply Nat.le_refl
rw [← Int.subNatNat_eq_coe]
refine subNatNat_elim m n (fun m n i => toNat i = m - n) (fun i n => ?_) (fun i n => ?_)
· exact (Nat.add_sub_cancel_left ..).symm
· dsimp; rw [Nat.add_assoc, Nat.sub_eq_zero_of_le (Nat.le_add_right ..)]; rfl
rw [Nat.one_mul]
rw [Nat.one_mul]
rw [Int.mul_comm, Int.one_mul]
rw [Int.mul_neg, Int.mul_one]
rw [Nat.one_mul]
rfl
rw [Nat.one_mul]
rfl
simp [Int.mul_zero, Int.zero_mul]
simp [le_def, h]
constructor
rw [← h, Int.add_comm]
simp [Int.sub_eq_add_neg, Int.add_assoc]
rw [← h₁, Int.add_comm]
simp [Int.sub_eq_add_neg, Int.add_assoc]
simp [Int.add_comm, Int.sub_eq_add_neg]
rw [← hk]
rfl
have t := le.dest_sub h
simp [Int.sub_eq_add_neg] at t
exact t
rw [Nat.add_comm] at h
exact h.symm
rw [Int.add_comm, Int.add_left_comm]
rfl
rw [lt_iff_add_one_le, ← ofNat_succ, ofNat_le]
rfl
rw [← hm, ← hn, Int.add_assoc, ofNat_add]
let ⟨n, hn⟩ := le.dest h₁
let ⟨m, hm⟩ := le.dest h₂
have := hn
rw [← hm, Int.add_assoc, ← ofNat_add] at this
have := Int.ofNat.inj <| Int.add_left_cancel <| this.trans (Int.add_zero _).symm
rw [← hn, Nat.eq_zero_of_add_eq_zero_left this, ofNat_zero, Int.add_zero a]
rw [hn, Int.add_zero]
cases e
exact Int.lt_irrefl _ h
rw [← hn, eq, ofNat_zero, Int.add_zero]
let ⟨n, hn⟩ := eq_ofNat_of_zero_le ha
let ⟨m, hm⟩ := eq_ofNat_of_zero_le hb
rw [hn, hm, ← ofNat_mul]
apply ofNat_nonneg
let ⟨n, hn⟩ := eq_succ_of_zero_lt ha
let ⟨m, hm⟩ := eq_succ_of_zero_lt hb
rw [hn, hm, ← ofNat_mul]
apply ofNat_succ_pos
rw [Int.lt_iff_le_and_ne]
constructor <;> refine fun ⟨h, h'⟩ => ⟨h, h'.imp fun h' => ?_⟩
· exact Int.le_antisymm h h'
· subst h'; apply Int.le_refl
rw [← Int.not_le, Decidable.not_not]
simp [Int.min_def]
rw [Int.min_def]
split <;> simp [*]
rw [Int.min_def]
split <;> assumption
simp [Int.min_def, h]
rw [Int.min_comm a b]
exact Int.min_eq_left h
simp only [Int.max_def]
rw [Int.max_def]
split <;> simp [*]
rw [Int.max_def]
split <;> assumption
simp [Int.max_def, h, Int.not_lt.2 h]
rw [← Int.max_comm b a]
exact Int.max_eq_right h
let ⟨n, e⟩ := eq_ofNat_of_zero_le h
rw [e]
rfl
rw [eq_natAbs_of_zero_le h]
apply Int.le_refl
simp only [Int.not_le, iff_false]
exact Int.negSucc_lt_zero n
simp only [Int.not_lt, iff_false]
constructor
rw [Int.add_assoc, hn]
have : -a + (a + b) ≤ -a + (a + c) := Int.add_le_add_left h _
simp [Int.neg_add_cancel_left] at this
assumption
have : -a + (a + b) < -a + (a + c) := Int.add_lt_add_left h _
simp [Int.neg_add_cancel_left] at this
assumption
simp [Int.neg_neg] at this
assumption
rw [Int.add_comm] at h
exact Int.le_add_of_sub_left_le h
rw [Int.add_comm]
exact Int.sub_left_le_of_le_add h
rw [Int.add_comm] at h
exact Int.le_add_of_sub_right_le h
rw [Int.add_comm] at h
exact Int.neg_add_le_left_of_le_add h
rw [Int.add_comm] at h
exact Int.lt_add_of_sub_left_lt h
rw [Int.add_comm]
exact Int.sub_left_lt_of_lt_add h
rw [Int.add_comm] at h
exact Int.lt_add_of_sub_right_lt h
rw [Int.add_comm] at h
exact Int.neg_add_lt_left_of_lt_add h
rw [Int.add_zero]
rw [Int.add_zero]
have : 0 < c * (b - a) := Int.mul_pos h₂ (Int.sub_pos_of_lt h₁)
rw [Int.mul_sub] at this
exact Int.lt_of_sub_pos this
have : 0 < b - a := Int.sub_pos_of_lt h₁
have : 0 < (b - a) * c := Int.mul_pos this h₂
rw [Int.sub_mul] at this
exact Int.lt_of_sub_pos this
rw [Int.mul_comm, Int.mul_comm b]
exact Int.mul_le_mul_of_nonneg_left h₁ h₂
rw [← natAbs_neg, natAbs_of_nonneg (Int.neg_nonneg_of_nonpos H)]
rw [h, sign_zero]
simp [·, Int.zero_mul]
simp [·, Int.mul_zero]
rw [Int.mul_sub, this]
rw [Int.one_mul, H]
rw [Int.mul_one, H]
rw [natAbs_eq_iff, Int.mul_eq_zero, ← Int.sub_neg, Int.sub_eq_zero, Int.sub_eq_zero]
match a, b with
    | (a:Nat), (b:Nat) => simp
    | (a:Nat), -[b+1]  => simp; apply this
    | -[a+1],  (b:Nat) => simp [Nat.succ_add, Nat.add_comm a b]; apply this
    | -[a+1],  -[b+1]  => simp [Nat.succ_add]; apply Nat.le_refl
rw [← Int.natAbs_neg b]
apply natAbs_add_le
simp only [negSucc_eq, Int.neg_add]
rfl
rw [toNat_eq_max, Int.max_eq_left h]
rw [toNat_eq_max]
apply Int.le_max_left
rw [← Int.ofNat_le, Int.toNat_of_nonneg h]
rw [← Int.not_le, ← Nat.not_le, Int.le_toNat h]
simp [ofNat_add]
constructor <;> intro.
decide
decide
simp [hg] at den_nz
exact den_nz
      reduced
simp [hg, Int.natAbs_ofNat] at reduced
exact reduced
match num, num.eq_nat_or_neg with
    | _, ⟨_, .inl rfl⟩ => rfl
    | _, ⟨_, .inr rfl⟩ => rw [Int.neg_div, Int.natAbs_neg, Int.natAbs_neg]; rfl
decide
decide
simp only [Int.natAbs_mul, Int.natAbs_div, Nat.coprime_mul_iff_left]
refine ⟨Nat.coprime_mul_iff_right.2 ⟨?_, ?_⟩, Nat.coprime_mul_iff_right.2 ⟨?_, ?_⟩⟩
· exact Nat.coprime_div_gcd_div_gcd (Nat.gcd_pos_of_pos_right _ b.den_pos)
· exact a.reduced.coprime_div_left (Nat.gcd_dvd_left ..)
          |>.coprime_div_right (Nat.gcd_dvd_left ..)
· exact b.reduced.coprime_div_left (Nat.gcd_dvd_right ..)
          |>.coprime_div_right (Nat.gcd_dvd_right ..)
· exact (Nat.coprime_div_gcd_div_gcd (Nat.gcd_pos_of_pos_left _ a.den_pos)).symm
rw [Nat.mul_assoc, be]
rw [Int.natAbs_neg]
exact a.reduced
have := add.aux a (-b) hg had hbd
simp only [show (-b).num = -b.num from rfl, Int.mul_neg] at this
exact this
unfold maybeNormalize
split
· subst g; simp
· rfl
simp [normalize, Int.zero_div, Int.natAbs_zero, Nat.div_self (Nat.pos_of_ne_zero nz)]
rfl
unfold mkRat
split <;> simp
simp at h
exact h
simp [size]
simp [size]
unfold foldlM.loop
split
split
· cases Nat.not_le_of_gt ‹_› (Nat.zero_add _ ▸ H)
· rename_i i; rw [Nat.succ_add] at H
    simp [foldlM_eq_foldlM_data.aux f arr i (j+1) H]
    conv => rhs; rw [← List.get_drop_eq_drop _ _ ‹_›]
· rw [List.drop_length_le (Nat.ge_of_not_lt ‹_›)]; rfl
simp [foldlM, foldlM_eq_foldlM_data.aux]
unfold foldrM.fold
match i with
  | 0 => simp [List.foldlM, List.take]
  | i+1 => rw [← List.take_concat_get _ _ h]; simp [← (aux f arr · i)]; rfl
have : arr = #[] ∨ 0 < arr.size :=
    match arr with | ⟨[]⟩ => .inl rfl | ⟨a::l⟩ => .inr (Nat.zero_lt_succ _)
match arr, this with | _, .inl rfl => rfl | arr, .inr h => ?_
simp [foldrM, h, ← foldrM_eq_reverse_foldlM_data.aux, List.take_length]
rw [foldrM_eq_reverse_foldlM_data, List.foldlM_reverse]
simp [push, List.concat_eq_append]
simp [foldrM_eq_reverse_foldlM_data, -size_push]
simp [← foldrM_push]
simp [toListAppend, foldr_eq_foldr_data]
simp [toList, foldr_eq_foldr_data]
rw [toListRev, foldl_eq_foldl_data, ← List.foldr_reverse, List.foldr_self]
simp [hj]
have := SatisfiesM_foldlM (m := Id) (as := as) (f := f) motive h0
simp [SatisfiesM_Id_eq] at this
exact this hf
simp [*, Nat.lt_succ_of_le, Nat.le_of_lt]
simp only [push, getElem_eq_data_get, List.concat_eq_append, List.get_append_left, h]
simp only [push, getElem_eq_data_get, List.concat_eq_append]
rw [List.get_append_right] <;> simp [getElem_eq_data_get]
simp [eq]
induction l generalizing arr <;> simp [*]
simp [size]
have := SatisfiesM_mapM' (m := Id) arr f (fun i b => b = f (arr[i]))
simp [SatisfiesM_Id_eq] at this
exact this.2 i (size_map .. ▸ h)
rw [← append_eq_append]
unfold Array.append
rw [foldl_eq_foldl_data]
induction arr'.data generalizing arr <;> simp [*]
rw [← appendList_eq_append]
unfold Array.appendList
induction l generalizing arr <;> simp [*]
induction l generalizing acc <;> simp [*, List.bind]
induction l generalizing acc <;> simp [*]
simp
simp [getElem?_neg, h]
simp [getElem_eq_data_get, List.get_mem]
simp [get?, getD]
split <;> simp
simp [get!_eq_getD]
simp [back, back?]
simp [back?, getElem?_eq_data_get?]
simp
rw [getElem?_pos, get_push_lt]
rw [getElem?_pos, get_push_eq]
simp [i.2]
simp only [set, getElem_eq_data_get, List.get_set_eq]
simp [*]
simp only [set, getElem_eq_data_get, List.get_set_ne h]
simp [getElem?_pos, i.2]
simp [*]
cases e
rfl
simp [j.2]
simp [swap, fin_cast_val]
simp [swap_def]
simp [swap_def, get?_set, ← getElem_fin_eq_data_get]
simp [swapAt!, h]
simp [pop]
simp [pop]
unfold foldrM.fold
simp
split
· next hi => exact .pure (hi ▸ H)
· next hi =>
      split; {simp at hi}
      · next i hi' =>
        exact (hf ⟨i, hi'⟩ b H).bind fun _ => go _
have := SatisfiesM_foldrM (m := Id) (as := as) (f := f) motive h0
simp [SatisfiesM_Id_eq] at this
exact this hf
rw [mapM, foldlM_eq_foldlM_data, ← List.foldrM_reverse, mkEmpty_eq]
conv => rhs; rw [← List.reverse_reverse arr.data]
induction arr.data.reverse with
  | nil => simp; rfl
  | cons a l ih => simp [ih]; simp [push]
exact hm
simp [h₁]
have := SatisfiesM_mapIdxM (m := Id) (as := as) (f := f) motive h0
simp [SatisfiesM_Id_eq] at this
exact this _ hs
simp_all
simp [swap!, hi, hj]
rw [reverse.loop]
simp_arith
simp_arith
simp [this]
simp [ofFn]
simp [*]
unfold ofFn.go
simp [*]
simp
simp
cases l <;> simp [*, isEmpty, List.isEmpty]
induction l generalizing init <;> simp [*, foldlM]
simp [List.foldl_eq_foldlM, foldl, Id.run]
funext α β as
simp [toListTR]
exact .symm <| (Array.foldl_data_eq_map (toList as) _ id).trans (List.map_id _)
induction l <;> simp [*, forM]
induction l <;> simp [*]
induction l <;> simp [*]
induction l <;> simp [findEntryP?]
split <;> simp [*]
induction l <;> simp [find?]
split <;> simp [*]
simp [find?_eq_findEntry?]
induction l <;> simp [any, *]
induction l <;> simp [all, *]
induction l <;> simp [*, contains]
induction l <;> simp [replace]
split <;> simp [*]
induction l <;> simp [List.eraseP, cond]
split <;> simp [*]
simp [forIn, List.forIn]
induction l generalizing init <;> simp [AssocList.forIn, List.forIn.loop]
congr
funext a
split <;> simp [*]
induction l <;> simp [*]
induction l <;> simp [*]
simp only [String.csize, utf8Size]
repeat (first | split | (solve | simp))
unfold RBNode.ins
split <;> simp [zoom]
· intro | rfl, rfl => rfl
all_goals
  · split
    · exact zoom_ins
    · exact zoom_ins
    · intro | rfl => rfl
unfold RBNode.del
split <;> simp [zoom]
· intro | rfl, rfl => rfl
· next c a y b =>
    split
    · have IH := @zoom_del (t := a)
      match a with
      | nil => intro | rfl => rfl
      | node black .. | node red .. => apply IH
    · have IH := @zoom_del (t := b)
      match b with
      | nil => intro | rfl => rfl
      | node black .. | node red .. => apply IH
    · intro | rfl => rfl
assumption
cases e
exact ⟨_, _, .nil, hp⟩
unfold zoom
split
· exact ha.zoom (.redL hb hp)
· exact hb.zoom (.redR ha hp)
· intro e; cases e; exact ⟨_, _, .red ha hb, hp⟩
unfold zoom
split
· exact ha.zoom (.blackL hb hp)
· exact hb.zoom (.blackR ha hp)
· intro e; cases e; exact ⟨_, _, .black ha hb, hp⟩
unfold ins
exact ins_eq_fill H (.red ha hb)
rw [ins, fill, ← ins_eq_fill H (.black ha hb), balance1_eq ha]
rw [ins, fill, ← ins_eq_fill H (.black ha hb), balance2_eq hb]
induction hp generalizing t with
  | root => exact ht.setBlack
  | redL hr hp ih => match ht with
    | .balanced .nil => exact ih (.balanced (.red .nil hr))
    | .balanced (.red ha hb) => exact ih (.redred rfl (.red ha hb) hr)
    | .balanced (.black ha hb) => exact ih (.balanced (.red (.black ha hb) hr))
  | redR hl hp ih => match ht with
    | .balanced .nil => exact ih (.balanced (.red hl .nil))
    | .balanced (.red ha hb) => exact ih (.redred rfl hl (.red ha hb))
    | .balanced (.black ha hb) => exact ih (.balanced (.red hl (.black ha hb)))
  | blackL hr hp ih => exact have ⟨c, h⟩ := ht.balance1 hr; ih (.balanced h)
  | blackR hl hp ih => exact have ⟨c, h⟩ := ht.balance2 hl; ih (.balanced h)
have ⟨_, _, ht', hp'⟩ := ht.zoom .root H
cases ht' with simp [insert]
  | nil => simp [insertNew_eq_insert H, setBlack_idem]
  | red hl hr => rw [← ins_eq_fill hp' (.red hl hr), insert_setBlack]; exact (zoom_ins H).symm
  | black hl hr => rw [← ins_eq_fill hp' (.black hl hr), insert_setBlack]; exact (zoom_ins H).symm
revert e
unfold zoom
split
· exact zoom_zoomed₁
· exact zoom_zoomed₁
· next H => intro e; cases e; exact H
revert e
unfold zoom
split
· next h => exact fun e => zoom_zoomed₂ e ⟨h, hp⟩
· next h => exact fun e => zoom_zoomed₂ e ⟨h, hp⟩
· intro e; cases e; exact hp
simp [Ordered.fill, RBNode.Ordered, Ordered, RootOrdered, All_and]
exact ⟨
      fun ⟨hp, ⟨ax, xb, ha, hb⟩, ⟨xp, ap, bp⟩⟩ => ⟨⟨hp, xb, xp, bp, hb⟩, ha, ⟨ax, ap⟩⟩,
      fun ⟨⟨hp, xb, xp, bp, hb⟩, ha, ⟨ax, ap⟩⟩ => ⟨hp, ⟨ax, xb, ha, hb⟩, ⟨xp, ap, bp⟩⟩⟩
simp [Ordered.fill, RBNode.Ordered, Ordered, RootOrdered, All_and]
exact ⟨
      fun ⟨hp, ⟨ax, xb, ha, hb⟩, ⟨xp, ap, bp⟩⟩ => ⟨⟨hp, ax, xp, ap, ha⟩, hb, ⟨xb, bp⟩⟩,
      fun ⟨⟨hp, ax, xp, ap, ha⟩, hb, ⟨xb, bp⟩⟩ => ⟨hp, ⟨ax, xb, ha, hb⟩, ⟨xp, ap, bp⟩⟩⟩
unfold ins
have ⟨ax, ap⟩ := All_and.1 H
exact hp.ins ⟨ax, xb, ha, hb⟩ ⟨xp, ap, bp⟩
unfold ins
have ⟨xb, bp⟩ := All_and.1 H
exact hp.ins ⟨ax, xb, ha, hb⟩ ⟨xp, ap, bp⟩
unfold ins
have ⟨ax, ap⟩ := All_and.1 H
exact hp.ins (ha.balance1 ax xb hb) (balance1_All.2 ⟨xp, ap, bp⟩)
unfold ins
have ⟨xb, bp⟩ := All_and.1 H
exact hp.ins (ha.balance2 ax xb hb) (balance2_All.2 ⟨xp, ap, bp⟩)
unfold del
have ⟨ax, ap⟩ := All_and.1 H
exact hp.del ⟨ax, xb, ha, hb⟩ ⟨xp, ap, bp⟩
unfold del
have ⟨xb, bp⟩ := All_and.1 H
exact hp.del ⟨ax, xb, ha, hb⟩ ⟨xp, ap, bp⟩
unfold del
have ⟨ax, ap⟩ := All_and.1 H
exact hp.del (ha.balLeft ax xb hb) (ap.balLeft xp bp)
unfold del
have ⟨xb, bp⟩ := All_and.1 H
exact hp.del (ha.balRight ax xb hb) (ap.balRight xp bp)
simp [alter]
split
· next path eq =>
    have ⟨_, hp, _, _⟩ := h.zoom eq; split
    · exact h
    · next hf => exact hp.insertNew (H eq hf).1
· next path eq =>
    have ⟨⟨ax, xb, ha, hb⟩, hp, ⟨_, ap, bp⟩, _⟩ := h.zoom eq; split
    · exact hp.del (ha.append ax xb hb) (ap.append bp)
    · next hf =>
      have ⟨yp, xy⟩ := H eq hf
      apply Path.Ordered.fill.2
      exact ⟨hp, ⟨ax.imp xy.lt_congr_right.2, xb.imp xy.lt_congr_left.2, ha, hb⟩, yp, ap, bp⟩
simp [modify, alter]
split <;> simp [Option.map]
rw [eq] at H
exact ⟨H.RootOrdered_congr.2 (h.zoom eq).2.2.1.1, H⟩
induction t <;> simp [*, and_assoc, and_left_comm]
unfold balance1
split <;> simp [and_assoc, and_left_comm]
unfold balance2
split <;> simp [and_assoc, and_left_comm]
unfold setBlack
split <;> simp [Ordered]
cases t <;> rfl
unfold insert
split <;> simp [setBlack_idem]
induction t <;> unfold ins <;> simp [*]
split <;> cases ‹_=_› <;> split <;> simp at h₂ <;> simp [*]
unfold ins
split
· next h => exact ⟨ay.ins ⟨h⟩, yb, ha.ins, hb⟩
· next h => exact ⟨ay, yb.ins ⟨OrientedCmp.cmp_eq_gt.1 h⟩, ha, hb.ins⟩
· next h => exact (⟨
        ay.imp fun ⟨h'⟩ => ⟨(TransCmp.cmp_congr_right h).trans h'⟩,
        yb.imp fun ⟨h'⟩ => ⟨(TransCmp.cmp_congr_left h).trans h'⟩, ha, hb⟩)
unfold ins
split
· next h => exact ha.ins.balance1 (ay.ins ⟨h⟩) yb hb
· next h => exact ha.balance2 ay (yb.ins ⟨OrientedCmp.cmp_eq_gt.1 h⟩) hb.ins
· next h => exact (⟨
        ay.imp fun ⟨h'⟩ => ⟨(TransCmp.cmp_congr_right h).trans h'⟩,
        yb.imp fun ⟨h'⟩ => ⟨(TransCmp.cmp_congr_left h).trans h'⟩, ha, hb⟩)
unfold RBNode.insert
split <;> simp [Ordered.setBlack, h.ins (x := v)]
unfold balance1
split
· have .redred _ (.red ha hb) hc := hl; exact ⟨_, .red (.black ha hb) (.black hc hr)⟩
· have .redred _ ha (.red hb hc) := hl; exact ⟨_, .red (.black ha hb) (.black hc hr)⟩
· next H1 H2 => match hl with
    | .balanced hl => exact ⟨_, .black hl hr⟩
    | .redred _ (c₁ := black) (c₂ := black) ha hb => exact ⟨_, .black (.red ha hb) hr⟩
    | .redred _ (c₁ := red) (.red ..) _ => cases H1 _ _ _ _ _ rfl
    | .redred _ (c₂ := red) _ (.red ..) => cases H2 _ _ _ _ _ rfl
unfold balance2
split
· have .redred _ (.red ha hb) hc := hr; exact ⟨_, .red (.black hl ha) (.black hb hc)⟩
· have .redred _ ha (.red hb hc) := hr; exact ⟨_, .red (.black hl ha) (.black hb hc)⟩
· next H1 H2 => match hr with
    | .balanced hr => exact ⟨_, .black hl hr⟩
    | .redred _ (c₁ := black) (c₂ := black) ha hb => exact ⟨_, .black hl (.red ha hb)⟩
    | .redred _ (c₁ := red) (.red ..) _ => cases H1 _ _ _ _ _ rfl
    | .redred _ (c₂ := red) _ (.red ..) => cases H2 _ _ _ _ _ rfl
induction h with
  | nil => exact .balanced (.red .nil .nil)
  | @red a n b x hl hr ihl ihr =>
    unfold ins; split
    · match ins cmp v a, ihl with
      | _, .balanced .nil => exact .balanced (.red .nil hr)
      | _, .balanced (.red ha hb) => exact .redred rfl (.red ha hb) hr
      | _, .balanced (.black ha hb) => exact .balanced (.red (.black ha hb) hr)
      | _, .redred h .. => cases hl <;> cases h
    · match ins cmp v b, ihr with
      | _, .balanced .nil => exact .balanced (.red hl .nil)
      | _, .balanced (.red ha hb) => exact .redred rfl hl (.red ha hb)
      | _, .balanced (.black ha hb) => exact .balanced (.red hl (.black ha hb))
      | _, .redred h .. => cases hr <;> cases h
    · exact .balanced (.red hl hr)
  | @black a ca n b cb x hl hr ihl ihr =>
    unfold ins; split
    · exact have ⟨c, h⟩ := ihl.balance1 hr; .balanced h
    · exact have ⟨c, h⟩ := ihr.balance2 hl; .balanced h
    · exact .balanced (.black hl hr)
unfold setRed
split <;> simp_all
unfold setRed
split <;> simp [Ordered]
unfold balLeft
split <;> simp_all
split <;> simp_all [All.setRed]
unfold balLeft
split
· exact ⟨lv, vr, hl, hr⟩
split
· exact hl.balance2 lv vr hr
· have ⟨vy, va, _⟩ := vr.2.1; have ⟨⟨yz, _, bz⟩, zc, ⟨ay, yb, ha, hb⟩, hc⟩ := hr
    exact ⟨⟨vy, vy.trans_r lv, ay⟩, balance2_All.2 ⟨yz, yb, (yz.trans_l zc).setRed⟩,
      ⟨lv, va, hl, ha⟩, hb.balance2 bz zc.setRed (Ordered.setRed.2 hc)⟩
· exact ⟨lv, vr, hl, hr⟩
unfold balLeft
split
· next a x b => exact
    let ⟨ca, cb, ha, hb⟩ := hl.of_red
    match cr with
    | red => .redred rfl (.black ha hb) hr
    | black => .balanced (.red (.black ha hb) hr)
· next H => exact match hl with
    | .redred .. => nomatch H _ _ _ rfl
    | .balanced hl => match hr with
      | .black ha hb =>
        let ⟨c, h⟩ := RedRed.balance2 hl (.redred trivial ha hb); .balanced h
      | .red (.black ha hb) (.black hc hd) =>
        let ⟨c, h⟩ := RedRed.balance2 hb (.redred trivial hc hd); .redred rfl (.black hl ha) h
unfold balRight
split <;> simp_all
split <;> simp_all [All.setRed]
unfold balRight
split
· next b y c => exact
    let ⟨cb, cc, hb, hc⟩ := hr.of_red
    match cl with
    | red => .redred rfl hl (.black hb hc)
    | black => .balanced (.red hl (.black hb hc))
· next H => exact match hr with
    | .redred .. => nomatch H _ _ _ rfl
    | .balanced hr => match hl with
      | .black hb hc =>
        let ⟨c, h⟩ := RedRed.balance1 (.redred trivial hb hc) hr; .balanced h
      | .red (.black ha hb) (.black hc hd) =>
        let ⟨c, h⟩ := RedRed.balance1 (.redred trivial ha hb) hc; .redred rfl h (.black hd hr)
unfold append
split <;> simp [*]
· have ⟨hx, ha, hb⟩ := hl; have ⟨hy, hc, hd⟩ := hr
    have := hb.append hc; split <;> simp_all
· have ⟨hx, ha, hb⟩ := hl; have ⟨hy, hc, hd⟩ := hr
    have := hb.append hc; split <;> simp_all [All.balLeft]
· simp_all [hl.append hr.2.1]
· simp_all [hl.2.2.append hr]
unfold append
split
· exact hr
· exact hl
· have ⟨xv, _, bv⟩ := lv; have ⟨ax, xb, ha, hb⟩ := hl
    have ⟨vy, vc, _⟩ := vr; have ⟨cy, yd, hc, hd⟩ := hr
    have : _ ∧ _ ∧ _ := ⟨hb.append bv vc hc, xb.append (xv.trans_l vc), (vy.trans_r bv).append cy⟩
    split
    · next H =>
      have ⟨⟨b'z, c'z, hb', hc'⟩, ⟨xz, xb', _⟩, zy, _, c'y⟩ := H ▸ this
      have az := xz.trans_r ax; have zd := zy.trans_l yd
      exact ⟨⟨xz, az, b'z⟩, ⟨zy, c'z, zd⟩, ⟨ax, xb', ha, hb'⟩, c'y, yd, hc', hd⟩
    · have ⟨hbc, xbc, bcy⟩ := this; have xy := xv.trans vy
      exact ⟨ax, ⟨xy, xbc, xy.trans_l yd⟩, ha, bcy, yd, hbc, hd⟩
· have ⟨xv, _, bv⟩ := lv; have ⟨ax, xb, ha, hb⟩ := hl
    have ⟨vy, vc, _⟩ := vr; have ⟨cy, yd, hc, hd⟩ := hr
    have : _ ∧ _ ∧ _ := ⟨hb.append bv vc hc, xb.append (xv.trans_l vc), (vy.trans_r bv).append cy⟩
    split
    · next H =>
      have ⟨⟨b'z, c'z, hb', hc'⟩, ⟨xz, xb', _⟩, zy, _, c'y⟩ := H ▸ this
      have az := xz.trans_r ax; have zd := zy.trans_l yd
      exact ⟨⟨xz, az, b'z⟩, ⟨zy, c'z, zd⟩, ⟨ax, xb', ha, hb'⟩, c'y, yd, hc', hd⟩
    · have ⟨hbc, xbc, bcy⟩ := this; have xy := xv.trans vy
      exact ha.balLeft ax ⟨xy, xbc, xy.trans_l yd⟩ ⟨bcy, yd, hbc, hd⟩
· have ⟨vx, vb, _⟩ := vr; have ⟨bx, yc, hb, hc⟩ := hr
    exact ⟨(vx.trans_r lv).append bx, yc, hl.append lv vb hb, hc⟩
· have ⟨xv, _, bv⟩ := lv; have ⟨ax, xb, ha, hb⟩ := hl
    exact ⟨ax, xb.append (xv.trans_l vr), ha, hb.append bv vr hr⟩
unfold DelProp at h
exact match c, h with
  | red, ⟨_, h⟩ => ⟨_, .balanced h⟩
  | black, ⟨_, _, h⟩ => ⟨_, h.imp fun _ => rfl⟩
unfold del
split
· split
      · exact ha.del.balLeft hy hb
      · exact ⟨hy, ha.del, hb⟩
· split
      · exact ha.balRight hy hb.del
      · exact ⟨hy, ha, hb.del⟩
· exact ha.append hb
unfold del
split
· split
      · exact ha.del.balLeft ay.del yb hb
      · exact ⟨ay.del, yb, ha.del, hb⟩
· split
      · exact ha.balRight ay yb.del hb.del
      · exact ⟨ay, yb.del, ha, hb.del⟩
· exact ha.append ay yb hb
induction h with
  | mk o h => exact ⟨o, _, _, h⟩
  | insert _ ih => have ⟨o, _, _, h⟩ := ih; exact ⟨o.insert, h.insert⟩
  | erase _ ih => have ⟨o, _, _, h⟩ := ih; exact ⟨o.erase, _, h.erase⟩
refine ⟨ax.map ?_, xb.map ?_, ha.map f, hb.map f⟩ <;> exact IsMonotone.lt_mono
decide
decide
decide
rw [size, Nat.add_right_comm (size _), Nat.add_assoc, depthLB, Nat.pow_succ, Nat.mul_two]
exact Nat.add_le_add hl.le_size hr.le_size
decide
simp [(·∈·), EMem]
simp [(·∈·), EMem]
induction t <;> simp [or_imp, forall_and, *]
induction t <;> simp [or_and_right, exists_or, *]
cases ey : cut y
· exact IsCut.le_lt_trans (fun h => nomatch H.symm.trans <| OrientedCmp.cmp_eq_gt.1 h) ey
· cases ex : cut x
    · exact IsCut.le_lt_trans (fun h => nomatch H.symm.trans h) ex |>.symm.trans ey
    · rfl
    · refine IsCut.le_gt_trans (cmp := cmp) (fun h => ?_) ex |>.symm.trans ey
      cases H.symm.trans <| OrientedCmp.cmp_eq_gt.1 h
· exact IsCut.le_gt_trans (fun h => nomatch H.symm.trans h) ey
induction t <;> simp [find?]
split <;> try assumption
intro | rfl => assumption
induction t <;> simp [find?]
split <;> simp (config := {contextual := true}) [*]
refine ⟨fun h => ⟨find?_some_mem h, find?_some_eq_eq h⟩, fun ⟨hx, e⟩ => ?_⟩
have ⟨y, hy⟩ := ht.memP_iff_find?.1 (memP_def.2 ⟨_, hx, e⟩)
exact ht.unique hx (find?_some_mem hy) ((IsStrictCut.exact e).trans (find?_some_eq_eq hy)) ▸ hy
induction t generalizing lb with
  | nil => exact H
  | node _ _ _ _ ihl ihr =>
    simp [lowerBound?]; split
    · exact ihl H
    · next hv => exact ihr fun | rfl, e => nomatch hv.symm.trans e
    · next hv => intro | rfl, e => cases hv.symm.trans e
induction t generalizing lb with
  | nil => exact H
  | node _ _ _ _ ihl ihr =>
    simp [lowerBound?]; split
    · exact ihl hp.2.1 H
    · exact ihr hp.2.2 fun | rfl => hp.1
    · exact fun | rfl => hp.1
simp
induction t generalizing y <;> simp [lowerBound?]
split <;> simp [*]
refine memP_def.trans ⟨fun ⟨y, hy, ey⟩ => ?_, fun ⟨x, hx, e⟩ => ⟨_, lowerBound?_mem hx, e⟩⟩
have ⟨x, hx⟩ := ht.lowerBound?_exists.2 ⟨_, hy, fun h => nomatch ey.symm.trans h⟩
refine ⟨x, hx, ?_⟩
cases ex : cut x
· cases lowerBound?_le hx ex
· rfl
· cases e : cmp x y
    · cases ey.symm.trans <| ht.lowerBound?_least hx hy e ex
    · cases ey.symm.trans <| IsCut.congr e |>.symm.trans ex
    · cases ey.symm.trans <| IsCut.gt_trans (OrientedCmp.cmp_eq_gt.1 e) ex
unfold toList
induction t generalizing l with
  | nil => rfl
  | node _ a _ b iha ihb => rw [foldr, foldr, iha, iha (_::_), ihb]; simp
rw [toList, foldr, foldr_cons]
rfl
induction t <;> simp [*, or_left_comm]
induction t generalizing init <;> simp [*]
induction t generalizing init <;> simp [*]
induction t <;> simp [*]
induction t generalizing init <;> simp [*]
induction t generalizing init <;> simp [*, forIn.visit]
simp [forIn, RBNode.forIn]
rw [List.forIn_eq_bindList, forIn_visit_eq_bindList]
unfold toList
apply Eq.symm
induction t <;> simp [*, foldr, RBNode.foldr_cons]
rw [toList, toList, foldr, RBNode.foldr_cons]
rfl
induction s <;> simp [-List.foldr] <;> simp [*, RBNode.foldr_eq_foldr_toList]
induction t generalizing init <;> simp [-List.foldl] <;> simp [*, RBNode.foldl_eq_foldl_toList]
simp [forIn, RBNode.forIn]
rw [List.forIn_eq_bindList, forIn_visit_eq_bindList]
induction t generalizing s <;> simp [*, toStream]
simp [toStream_toList']
cases s <;> simp [next?, toStream_toList']
induction t with
  | nil => simp
  | node c l v r ihl ihr =>
    simp [*, List.pairwise_append, Ordered, All_def,
      and_assoc, and_left_comm, and_comm, imp_and, forall_and]
    exact fun _ _ hl hr a ha b hb => (hl _ ha).trans (hr _ hb)
cases t <;> simp [setBlack]
cases t <;> simp [setRed]
unfold balance1
split <;> simp
unfold balance2
split <;> simp
unfold balLeft
split <;> simp
split <;> simp
unfold balRight
split <;> simp
split <;> simp
induction p with
    (simp [All_def] at hp; simp [*, and_assoc, and_left_comm, and_comm, or_imp, forall_and])
  | left _ _ x _ ih => exact fun vx _ _ _ ha => vx.trans (hp.2.1 _ ha)
  | right _ _ x _ ih => exact fun xv _ _ _ ha => (hp.2.1 _ ha).trans xv
simp [All_def, rootOrdered_iff h]
rfl
induction p generalizing t <;> simp [*]
rw [← fill_toList, ← zoom_fill eq]
rfl
match p with
  | .root | .left red .. | .right red .. | .left black .. | .right black .. =>
    simp [ins, ins_toList]
simp [insertNew]
simp [insert]
split <;> simp [setRoot]
simp [append_inj (cons.inj h).2 (Nat.succ.inj hl)] at h ⊢
exact h
let hap := congrArg length h
simp only [length_append, ← hl] at hap
exact hap
intro l₁ <;> induction l₁ <;> intros <;> simp_all
induction l <;> simp_all
induction l <;> simp_all
simp [join, List.bind]
simp [join, List.bind]
induction xs
{rfl}
simp_all [cons_bind, append_assoc]
simp [List.bind]
induction l <;> simp [*]
have := take_append_drop i l
rw [drop_length_le h, append_nil] at this
exact this
rw [concat_eq_append, append_assoc, singleton_append, get_drop_eq_drop, take_append_drop]
rw [concat_eq_append, reverse_append]
rfl
induction l generalizing b <;> simp [*]
simp only [foldrM]
induction l <;> simp_all
simp
induction l generalizing b <;> simp [*, foldl]
induction l <;> simp [*]
simp [foldl_eq_foldlM, foldr_eq_foldrM]
simp
induction l <;> simp [*]
simp [foldl_eq_foldlM]
simp [foldr_eq_foldrM]
induction l <;> simp [*]
simp
simp [go, mapM]
simp
simp [go l]
simp [← mapM'_eq_mapM]
induction l₁ <;> simp [*]
simp [setTR.go, set, h]
simp [setTR.go, set]
simp [setTR.go, set]
rw [go _ xs]
{simp}
simp [h]
simp
simp
simp [bindTR.go, bind]
simp [bindTR.go, bind, go xs]
funext α l
rw [← List.bind_id, List.bind_eq_bindTR]
rfl
simp [filterMapTR.go, filterMap]
simp [filterMapTR.go, filterMap, go as]
split <;> simp [*]
simp
simp
simp
funext α β f init l
simp [foldrTR, Array.foldr_eq_foldr_data, -Array.size_toArray]
simp [zipWithTR.go, zipWith]
simp [zipWithTR.go, zipWith, go as bs]
funext α β l
simp [unzipTR]
induction l <;> simp [*]
rw [← show _ + as.length = n + (a::as).length from Nat.succ_add .., foldr, go as]
simp
rfl
rw [← replicateTR_loop_replicate_eq _ 1 n, replicate, replicate,
    replicateTR.loop, replicateTR_loop_eq n, replicateTR_loop_eq n, append_assoc]
rfl
funext α l
simp [dropLastTR]
funext α sep l
simp [intersperseTR]
match l with
  | [] | [_] => rfl
  | x::y::xs => simp [intersperse]; induction xs generalizing y <;> simp [*]
simp [intercalateTR.go]
simp [intercalateTR.go, go]
simp
simp
cases n <;> simp [modifyNthTR.go, modifyNth]
simp [modifyNthTR.go, modifyNth]
simp [modifyNthTR.go, modifyNth, modifyNthTR_go_eq l]
funext α f n l
simp [modifyNthTR, modifyNthTR_go_eq]
simp [insertNthTR.go, insertNth]
simp [insertNthTR.go, insertNth, insertNthTR_go_eq n l]
funext α f n l
simp [insertNthTR, insertNthTR_go_eq]
cases l <;> rfl
simp [takeD]
induction n <;> simp [*]
simp [takeDTR.go]
simp [takeDTR.go]
simp [takeDTR.go, takeDTR_go_eq _ l]
funext α f n l
simp [takeDTR, takeDTR_go_eq]
funext α n a l
simp [leftpad, leftpadTR, replicateTR_loop_eq]
simp [scanlTR.go, scanl]
simp [scanlTR.go, scanl, scanlTR_go_eq l]
funext α f n l
simp [scanlTR, scanlTR_go_eq]
funext α l
simp [initsTR]
induction l <;> simp [*]
induction l <;> simp [*, tailsTR.go]
simp only [any, foldr, Bool.or_eq_true] at h
match l, h with
    | [], .inl rfl => simp; induction sections L <;> simp [*]
    | l, .inr h => simp [sections, sections_eq_nil_of_isEmpty h]
funext α L
simp [sectionsTR]
cases e : L.any isEmpty <;> simp [sections_eq_nil_of_isEmpty, *]
clear e
induction L with | nil => rfl | cons l L IH => ?_
simp [IH, sectionsTR.go, Array.foldl_eq_foldl_data]
rw [Array.foldl_data_eq_bind]
rfl
intros
apply Array.foldl_data_eq_map
simp [erasePTR.go, eraseP, h]
simp [erasePTR.go, eraseP]
cases p x <;> simp
· intro h; rw [go _ xs]; {simp}; simp [h]
funext α β l₁ l₂
simp [product, productTR]
rw [Array.foldl_data_eq_bind]
rfl
intros
apply Array.foldl_data_eq_map
funext α β l₁ l₂
simp [List.sigma, sigmaTR]
rw [Array.foldl_data_eq_bind]
rfl
intros
apply Array.foldl_data_eq_map
simp [range'TR.go]
simp [dropSlice, dropSlice_zero₂]
simp [dropSliceTR.go, dropSlice, h]
simp [dropSliceTR.go, dropSlice]
intro h
rw [go _ xs]
{simp}
simp [h]
simp [zipWithLeft'TR.go]
simp [zipWithLeft'TR.go, Array.foldl_data_eq_map]
simp [zipWithLeft'TR.go, go _ as bs]
simp [zipWithLeftTR.go]
simp [zipWithLeftTR.go, Array.foldl_data_eq_map]
simp [zipWithLeftTR.go, go _ as bs]
simp [fillNonesTR.go]
simp [fillNonesTR.go, go _ as as']
simp [fillNonesTR.go, reduceOption, filterMap_eq_filterMapTR.go]
simp [fillNonesTR.go, go _ as as']
simp [takeListTR.go, takeList]
simp [takeListTR.go, takeList, go _ ns]
simp [h]
simp
cases h <;> simp [Membership.mem, *]
constructor
constructor
assumption
simp [·]
cases h <;> intro.
rw [h', cons_append]
cases p <;> simp
simp_all
simp_all
rw [eq_comm, append_eq_nil]
simp [*]
simp [h]
rw [aseq, h]
rw [eq_comm, append_eq_cons]
induction a generalizing c with
  | nil => simp; exact (or_iff_left_of_imp fun ⟨_, ⟨e, rfl⟩, h⟩ => e ▸ h.symm).symm
  | cons a as ih => cases c <;> simp [eq_comm, and_assoc, ih, and_or_left]
induction s <;> simp_all [or_assoc]
simp
simp [mem_map (l := l), or_and_right, exists_or]
simp [mem_map]
exact ⟨fun H j h => H _ _ h rfl, fun H i x h e => e ▸ H _ h⟩
constructor <;> exact fun _ => match l with | [] => rfl
induction l₁ generalizing l₂ <;> cases l₂ <;>
    simp_all [add_one, min_succ_succ, Nat.zero_min, Nat.min_zero]
simp
simp [mem_join, or_and_right, exists_or]
simp [List.bind, mem_map, mem_join]
exact ⟨fun ⟨_, ⟨a, h₁, rfl⟩, h₂⟩ => ⟨a, h₁, h₂⟩, fun ⟨a, h₁, h₂⟩ => ⟨_, ⟨a, h₁, rfl⟩, h₂⟩⟩
simp only [cons_bind, map_append, bind_map _ _ l]
simp
simp
simp only [mem_singleton, forall_eq]
rfl
simp only [mem_append, or_imp, forall_and]
rfl
simp only [mem_cons]
exact Or.imp_right (@s _)
simp only [subset_def, mem_cons, or_imp, forall_and, forall_eq]
rfl
simp [subset_def, or_imp, forall_and]
simp [subset_def]
simp only [mem_map]
exact .imp fun a => .imp_left (@H _)
simp
simp [mem_replicate, Nat.succ_ne_zero]
induction l <;> intros
{contradiction}
rfl
simp [getLast_cons' _ fun H => cons_ne_nil _ _ (append_eq_nil.1 H).2, getLast_append t]
induction h₂ generalizing l₁ with
  | slnil => exact h₁
  | cons _ _ IH => exact (IH h₁).cons _
  | @cons₂ l₂ _ a _ IH =>
    generalize e : a :: l₂ = l₂'
    match e ▸ h₁ with
    | .slnil => apply nil_sublist
    | .cons a' h₁' => cases e; apply (IH h₁').cons
    | .cons₂ a' h₁' => cases e; apply (IH h₁').cons₂
induction l₁ generalizing l with
  | nil => match h with
    | .cons _ h => exact .inl h
    | .cons₂ _ h => exact .inr (.head ..)
  | cons b l₁ IH =>
    match h with
    | .cons _ h => exact (IH h).imp_left (Sublist.cons _)
    | .cons₂ _ h => exact (IH h).imp (Sublist.cons₂ _) (.tail _)
rw [reverse_cons]
exact sublist_append_of_sublist_left h.reverse
rw [reverse_cons, reverse_cons]
exact h.reverse.append_right _
have := h.reverse
simp only [reverse_append, append_sublist_append_left, reverse_sublist] at this
exact this
cases l <;> rfl
cases l <;> rfl
simp [tail_eq_tailD]
cases l <;> rfl
cases l <;> rfl
simp [getLast!]
simp [getLast?]
induction l₁ <;> simp [*]
simp
cases e ▸ get?_eq_some.2 ⟨h', rfl⟩
simp [get?_eq_some, Fin.exists_iff, mem_iff_get]
cases l <;> rfl
unfold getElem?
split
· exact (get?_eq_get ‹_›).symm
· exact (get?_eq_none.2 <| Nat.not_lt.1 ‹_›).symm
induction xs generalizing i j with
  | nil => cases h₀
  | cons x xs ih =>
    match i, j with
    | 0, 0 => rfl
    | i+1, j+1 => simp; cases h₁ with
      | cons ha h₁ => exact ih (Nat.lt_of_succ_lt_succ h₀) h₁ h₂
    | i+1, 0 => ?_ | 0, j+1 => ?_
    all_goals
      simp at h₂
      cases h₁; rename_i h' h
      have := h x ?_ rfl; cases this
      rw [mem_iff_get?]
    exact ⟨_, h₂⟩; exact ⟨_ , h₂.symm⟩
rw [← get?_eq_get, get?_map, get?_eq_get]
rfl
cases h
rfl
simp only [get, cons_append]
apply get_append
rw [cons_append]
simp [get?_append_right (Nat.lt_succ.1 h₁)]
rw [length_append] at h₂
exact Nat.sub_lt_left_of_lt_add h₁ h₂
rw [← get?_eq_get, ← get?_eq_get, get?_append_right h₁]
simp_arith
rw [← get?_eq_get, eq, get?_append_right (h ▸ Nat.le_refl _), h, Nat.sub_self]
rfl
have hn' : n < (l₁ ++ l₂).length := Nat.lt_of_lt_of_le hn <|
    length_append .. ▸ Nat.le_add_right ..
rw [get?_eq_get hn, get?_eq_get hn', get_append]
rw [getLast_singleton, get_singleton]
rw [getLast_cons', getLast_eq_get (b :: l)]
{rfl}
exact cons_ne_nil b l
rw [cons_append, length_cons]
simp only [get?, get?_concat_length]
simp [getLast?_eq_get?]
simp [h]
rw [getLast_eq_get]
cases h
rfl
have h0 : some a = some a' := h 0
injection h0 with aa
simp only [aa, ext fun n => h (n+1)]
simp at h
simp [h, get?_append_right]
have := Nat.succ.inj h
simp at this ⊢
rw [get?_append, get?_reverse' _ j this]
rw [length_reverse, ← this]
apply Nat.lt_add_of_pos_right (Nat.succ_pos _)
rw [Nat.add_sub_of_le (Nat.le_pred_of_lt h),
      Nat.sub_add_cancel (Nat.lt_of_le_of_lt (Nat.zero_le _) h)]
simp [Nat.zero_min]
simp [Nat.min_zero]
simp [Nat.min_succ_succ, add_one, length_take]
simp [Nat.min_le_left]
simp [Nat.min_eq_left h]
have := h
rw [← take_append_drop (length s₁) l] at this ⊢
rw [map_append] at this
refine ⟨_, _, rfl, append_inj this ?_⟩
rw [length_map, length_take, Nat.min_eq_left]
rw [← length_map l f, h, length_append]
apply Nat.le_add_right

-- TODO: original proof: drop_subset n l h
cases l <;> rfl
cases l <;> cases n <;> rfl
cases n <;> rfl
cases l.get? m <;> rfl
induction l₁ <;> simp [*, Nat.succ_add]
cases l <;> rfl
simp only [get?_modifyNth, if_pos]
simp only [get?_modifyNth, if_neg h, id_map']
cases l <;> rfl
cases l <;> rfl
cases l.get? n <;> rfl
rw [modifyNth_eq_set_get?, get?_eq_get h]
rfl
rw [set_eq_modifyNth]
exact exists_of_modifyNth _ h
simp only [set_eq_modifyNth, get?_modifyNth_eq]
rw [get?_set_eq, get?_eq_get h]
rfl
simp only [set_eq_modifyNth, get?_modifyNth_ne _ _ h]
simp [get?_set, get?_eq_get h]
simp [get?_set]
split <;> subst_vars <;> simp [*, get?_eq_get h]
simp
simp [set]
simp [set]
rw [← Option.some_inj, ← get?_eq_get, get?_set_eq, get?_eq_get] <;> simp_all
simp at hj
exact hj
rw [← Option.some_inj, ← List.get?_eq_get, List.get?_set_ne _ _ h, List.get?_eq_get]
simp [removeNth]
have : i < length xs := Nat.lt_of_succ_lt_succ h
simp [removeNth, ← Nat.add_one]
rw [length_removeNth this, Nat.sub_add_cancel (Nat.lt_of_le_of_lt (Nat.zero_le _) this)]
cases l <;> rfl
induction l <;> simp [*]
induction l <;> simp [*]
simp
simp [mem_reverseAux]
rw [← or_assoc, @or_comm (x = a)]
simp [reverse]
simp only [List.insert, if_pos h]
simp only [List.insert, if_neg h]
rw [insert_of_mem h]
rw [insert_of_not_mem h]
rfl
simp [eraseP_cons, h]
simp [eraseP_cons, h]
induction l with
  | nil => rfl
  | cons _ _ ih => simp [h _ (.head ..), ih (forall_mem_cons.1 h).2]
simp [pb]
rw [h₃, cons_append]
simp [pb, h₄]
let ⟨_, l₁, l₂, _, _, e₁, e₂⟩ := exists_of_eraseP al pa
rw [e₂]
simp [length_append, e₁]
rfl
simp [(forall_mem_cons.1 h).1, eraseP_append_right _ (forall_mem_cons.1 h).2]
match exists_or_eq_self_of_eraseP p l with
  | .inl h => rw [h]; apply Sublist.refl
  | .inr ⟨c, l₁, l₂, _, _, h₃, h₄⟩ => rw [h₄, h₃]; simp
refine ⟨mem_of_mem_eraseP, fun al => ?_⟩
match exists_or_eq_self_of_eraseP p l with
  | .inl h => rw [h]; assumption
  | .inr ⟨c, l₁, l₂, h₁, h₂, h₃, h₄⟩ =>
    rw [h₄]; rw [h₃] at al
    have : a ≠ c := fun h => (h ▸ pa).elim h₂
    simp [this] at al; simp [al]
simp [extractP.go, find?, eraseP, h]
simp [extractP.go, find?, eraseP]
cases p x <;> simp
· intro h; rw [go _ xs]; {simp}; simp [h]
simp [List.erase, h]
simp [List.erase, h, (beq_eq_false_iff_ne _ _).2 h]
simp [erase_cons]
simp only [erase_cons, if_neg h]
rw [mem_cons, not_or] at h
rw [erase_cons, if_neg (Ne.symm h.1), erase_of_not_mem h.2]
let ⟨_, l₁, l₂, h₁, e, h₂, h₃⟩ := exists_of_eraseP h (beq_self_eq_true _)
rw [erase_eq_eraseP]
exact ⟨l₁, l₂, fun h => h₁ _ h (beq_self_eq_true _), eq_of_beq e ▸ h₂, h₃⟩
rw [erase_eq_eraseP]
exact length_eraseP_of_mem h (decide_eq_true rfl)
exact decide_eq_true rfl
rw [erase_eq_eraseP, erase_eq_eraseP, eraseP_append_right]
intros b h' h''
rw [of_decide_eq_true h''] at h
exact h h'
simp only [erase_eq_eraseP]
exact h.eraseP
induction as with
  | nil => simp [filter]
  | cons a as ih =>
    unfold filter; split <;> simp only [*, mem_cons, or_and_right]
    · exact or_congr_left (and_iff_left_of_imp fun | rfl => ‹_›).symm
    · exact (or_iff_right fun ⟨rfl, h⟩ => (Bool.not_eq_true _).mpr ‹_› h).symm
simp [partition, aux]
simp [partition.loop, filter]
cases pa : p a <;> simp [partition.loop, pa, aux, filter, append_assoc]
induction l <;> simp [forall_mem_map_iff, *]
induction l₁ <;> simp [*, or_imp, forall_and, and_assoc, and_left_comm]
induction l <;> simp [*, pairwise_append, and_comm]
induction l <;> simp
split <;> simp [*]
simp [Disjoint]
rw [disjoint_comm]
exact disjoint_nil_left _
simp [Disjoint]
rw [disjoint_comm, singleton_disjoint]
simp [Disjoint, or_imp, forall_and]
rw [disjoint_append_left]
simp [disjoint_comm]
simp [singleton_disjoint]
rw [disjoint_cons_left]
simp [disjoint_comm]
simp
cases m <;> cases n <;> simp only [disjoint_cons_left, mem_cons, disjoint_cons_right,
      drop, true_or, eq_self_iff_true, not_true, false_and, not_mem_nil, disjoint_nil_left, take]
· case succ.zero => cases h
· cases hl with | cons h₀ h₁ =>
      refine ⟨fun h => h₀ _ (mem_of_mem_drop h) rfl, ?_⟩
      exact disjoint_take_drop h₁ (Nat.le_of_succ_le_succ h)
induction l generalizing init <;> simp [*]
induction l generalizing init <;> simp [*]
induction l generalizing init <;> simp [*, H]
induction l <;> simp [*, H]
simp [List.union, foldr]
simp [List.union, foldr]
induction l₁ <;> simp [*, or_assoc]
cases l₁ <;> simp [List.inter, mem_filter]
simp only [List.product, and_imp, exists_prop, List.mem_map, Prod.mk.injEq,
    exists_eq_right_right', List.mem_bind, iff_self]
simp only [leftpad, length_append, length_replicate, Nat.sub_add_eq_max]
simp only [isPrefix, leftpad]
exact Exists.intro l rfl
simp only [isSuffix, leftpad]
exact Exists.intro (replicate (n - length l) a) rfl
induction l₁ <;> simp [*]
simp
simp
cases x
{contradiction}
rw [getD_some]
rw [e] at h
(cases h)
simp
exact h
cases x <;> simp [isSome]
cases a <;> simp
cases o <;> simp
intro.
cases o <;> simp
cases o <;> simp
cases o <;> simp
have := h <| x.get <| ne_none_iff_isSome.1 hx
simp [some_get] at this ⊢
exact this
cases x <;> rfl
cases x <;> simp
simp only [eq_none_iff_forall_not_mem, not_exists, not_and, mem_def, bind_eq_some]
rfl
cases a <;> cases b <;> rfl
cases x <;> rfl
simp
simp only [ne_none_iff_exists', join_eq_some, iff_self]
simp
cases x <;> simp
cases x <;> simp only [map_none', map_some', eq_self_iff_true]
cases x <;> simp only [map_none', map_some', h, mem_def]
cases x <;> simp only [map_none', map_some', ·∘·]
funext x
simp
cases x <;> simp
cases x <;> simp
cases x <;> simp
cases x <;> rfl
have := h a b
simp [liftOrGet] at this ⊢
exact this
cases b <;> rfl
cases a <;> rfl
cases o <;> rfl
simp [choice]
rw [dif_pos (⟨a⟩ : Nonempty α)]
simp
apply Subsingleton.elim
simp only [choice, dif_pos h, isSome_some]
unfold merge
(split <;> try split) <;> constructor
unfold combine
split
· exact noSibling_merge _ _ _
· match s with
    | nil | node _ _ nil => constructor
    | node _ _ (node _ _ s) => rename_i h; exact (h _ _ _ _ _ rfl).elim
cases s with cases eq | node a c => exact noSibling_combine _ _
simp only [Heap.tail?]
intro eq
match eq₂ : s.deleteMin le, eq with
  | some (a, tl), rfl => exact noSibling_deleteMin eq₂
simp only [Heap.tail]
match eq : s.tail? le with
  | none => cases s with cases eq | nil => constructor
  | some tl => exact Heap.noSibling_tail? eq
unfold merge
dsimp
split <;> simp_arith [size]
match h₁, h₂ with
  | .nil, .nil | .nil, .node _ _ | .node _ _, .nil => simp [size]
  | .node _ _, .node _ _ => unfold merge; dsimp; split <;> simp_arith [size]
unfold combine
split
· rename_i a₁ c₁ a₂ c₂ s
    rw [size_merge le (noSibling_merge _ _ _) (noSibling_combine _ _),
      size_merge_node, size_combine le s]
    simp_arith [size]
· rfl
cases h with cases eq | node a c => rw [size_combine, size, size]
simp only [Heap.tail?]
intro eq
match eq₂ : s.deleteMin le, eq with
  | some (a, tl), rfl => exact size_deleteMin h eq₂
simp only [Heap.tail]
match eq : s.tail? le with
  | none => cases s with cases eq | nil => rfl
  | some tl => simp [Heap.size_tail? h eq]; rfl
cases s with cases eq | node a c => simp_arith [size_combine, size]
simp only [Heap.tail?]
intro eq
match eq₂ : s.deleteMin le, eq with
  | some (a, tl), rfl => exact size_deleteMin_lt eq₂
simp_arith [Heap.size_deleteMin_lt eq]
unfold merge
dsimp
split <;> rename_i h
· exact node ⟨fun [_] => h, h₂, h₁⟩
· exact node ⟨fun [_] => TotalBLE.total.resolve_left h, h₁, h₂⟩
cases h with cases eq | node h => exact Heap.WF.combine h
simp only [Heap.tail?]
intro eq
match eq₂ : s.deleteMin le, eq with
  | some (a, tl), rfl => exact hwf.deleteMin eq₂
simp only [Heap.tail]
match eq : s.tail? le with
  | none => exact Heap.WF.nil
  | some tl => exact hwf.tail? eq
simp [h]
simp_arith
simp_arith
simp_arith
simp_arith
simp_arith
cases r_dec a a' with
    | isTrue raa' => exact isTrue $ left b b' raa'
    | isFalse nraa' =>
      cases αeq_dec a a' with
      | isTrue eq =>
        subst eq
        cases s_dec b b' with
        | isTrue sbb' => exact isTrue $ right a sbb'
        | isFalse nsbb' =>
          apply isFalse; intro contra; cases contra <;> contradiction
      | isFalse neqaa' =>
        apply isFalse; intro contra; cases contra <;> contradiction
simp_all [Membership.mem]
simp_all [Membership.mem]
unfold RuleTac
exact inferInstance
rw [h]
decide
simp_all [Membership.mem]
simp_all [Membership.mem]
simp [h]
simp [hconts]
simp [*]
rfl
assumption
assumption
simp [filter, h]
simp [filter, h]
apply Any.instDecidablePred
simp_wf <;> simp_arith
simp_wf <;> simp_arith
simp
simp
simp
simp


--- Soundness and Completeness
intro i dec
apply SC.all perm (h i dec)
intro i dec
apply SC.any (Perm.sym perm) (h i dec)
simp_all
simp_wf <;> simp_arith
apply Proof.basic
simp_wf <;> simp_arith
simp_all_arith
intro h₁ h₂ a ha
cases l₁ with
  | nil =>
    cases ha
  | cons x xs =>
    cases ha with
    | head =>
      apply h₂
      apply h₁
      constructor
    | tail _ hxs =>
      apply h₂
      apply h₁
      constructor
      assumption

-- END PRELUDE
rw [length_replicate]
simp
simp
cases h
   · casesm (_ ∧ _)
     constructor <;> assumption
simp [singleton_inter_eq_empty]

-- example {f : β → α} {x y : α} (h : x ≠ y) : f ⁻¹' {x} ∩ f ⁻¹' {y} = ∅ :=
-- begin
--   have : {x} ∩ {y} = (∅ : set α) :=
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
rfl
rfl
decide
simp
simp
trivial
infer_instance
decide
infer_instance
infer_instance
simp [isUnit'_iff_exists_inv, mul_comm]
intro.
intro.
trivial
simp [frobnicate_def]
rw [withUniv_def]
rfl
rfl
trace "hello"
intros
intros
intros
intros
constructor
fail_if_success any_goals assumption
all_goals constructor
any_goals assumption
constructor
any_goals assumption
constructor
· exact [0,1]

-- example : (α : Type) × List α :=
fail_if_success have := ∀ p, decide p -- no classical in scope
exact decide (0 < 1) -- uses the decidable instance
  
-- check that classical respects tactic blocks
decide
rw [h₂ x, h₂ y]
rw [f.map_mul]
cases h
assumption

-- This lemma with `false` as its head symbols should also be found for goals with head symbol `¬`.
apply Nat.not_lt_zero
cases h2
assumption
simp
rw [foo.rfl_toFun, id]
rw [foo.rfl_invFun]

/- the declarations are `simp` lemmas -/
simp
rw [foo_fst, h]
simp
rw [h]
simp
rw [h]
dsimp
rw [h] -- check that dsimp also unfolds
dsimp
rw [h]
simp
rw [h]
simp
rw [h]
-- example {α} (x y : α) (h : x = y) : foo.rfl.toFun = @id α :=
dsimp
rw [h]

/- check simpRhs option -/
intro x
simp [Equiv'.left_inv _ _]
intro x
simp [Equiv'.right_inv _ _]
dsimp only [Equiv'.trans_toFun]
rw [h]
intro n
simp
intro n
simp
simp only [myNatEquiv_toFun, myNatEquiv_invFun]
intro n
rfl
intro n
rfl
simp
rw [h]
simp only [foo_c]
rw [h]
simp only [foo_x]
rw [h]
simp only [voo_c]
rw [h]
simp only [voo_x]
rw [h]
rw [coercing.rfl2_toFun, h]
simp
rw [h]
simp
rw [h]
simp
rw [h]
simp
rw [h]

-- example {α β} (f : Equiv2 α β) {x} (h : f = x) : f.symm.invFun = x :=
--
rfl
simp
rw [h]
simp
-- example {α β} [Semigroup α] [Semigroup β] (x y : α × β) : (x * y).1 = x.1 * y.1 :=
simp
simp
simp
simp only [Equiv.trans_invFun]
rw [h]
simp only [Equiv.trans_invFun]
rw [h]
simp only [Equiv.trans_apply]
rw [h]
simp only [Equiv.trans_symm_apply]
rw [h]

-- the new projection names are parsed correctly (the old projection names won't work anymore)
simp only [Equiv.coe_trans]
rw [h]

-- the new projection names are parsed correctly
simp only [coe_foo_snd_fst]
rw [h]
dsimp only [Nat.SetPlus1_s]
rw [h]
dsimp only [Nat.SetPlus2_s]
  -- successIfFail { rw [h] } -- todo
exact h
dsimp only [Nat.SetPlus3_s]
rw [h]
dsimp only [Equiv.symm2_invFun_toFun]
rw [h]

/- do not prematurely unfold `Equiv.symm`, unless necessary -/
simp only [myAlgHom_toFun]
rw [h]
simp only [myRingHom_toFun]
rw [h]

/- check interaction with the `@[to_additive]` attribute -/

-- set_option trace.simps.debug true
simp
-- example {M N} [Add M] [Add N] (p q : M × N) : p + q = ⟨p.1 + q.1, p.2 + q.2⟩ :=
simp

/- The names of the generated simp lemmas for the additive version are not great if the definition
  had a custom additive name -/
simp
-- example {M N} [Zero M] [Zero N] : (0 : M × N) = ⟨0, 0⟩ :=
simp
simp
simp
dsimp
simp only [thing_mul]
rw [h2]
cases a <;> rfl
assumption
intro h₁ h₂
apply Eq.trans h₁ h₂
have h : Int := 0
assumption -- original `h` is not absent but...
have : Nat := 0
have : Int := 0
assumption -- original `this` is not absent but...
assumption -- old `a` is not gone
exact a    -- new `a` is of type `Int`
  simp

-- tests without `:=`, creating a new subgoal
simp_arith
rfl
rfl
(fail_if_success rfl)
apply Nat.le_refl
rfl
apply Foo.le_refl
rfl
refine' { inferInstanceAs (LinearOrderedRing α) with .. } <;> sorry
refine' { lt := (·<·), le := (·≤·), .. } <;> sorry
refine' { inferInstanceAs (CommSemiring ℕ), inferInstanceAs (LinearOrder ℕ) with .. } <;> sorry
refine' { inferInstanceAs (CommRing ℤ), inferInstanceAs (LinearOrder ℤ) with .. } <;> sorry
refine' { zero := 0, one := 1, add := (·+·), mul := (·*·), .. } <;> sorry
refine' { inferInstanceAs (CommRing ℚ), inferInstanceAs (LinearOrder ℚ) with .. } <;> sorry
congr
exact he b hb
rw [Nat.add_comm]
exact Nat.zero_lt_succ _
congr
rw [h x, h y]
constructor <;> exact inferInstance
rw [Subsingleton.elim i default]
rfl
rw [Function.bijective_iff_has_inverse]
refine' ⟨default, _, _⟩ <;> intro x <;> simp
congr
subst hx
congr
simp only [_root_.nontrivial_iff_exists_ne x, Subtype.exists, Ne.def, Subtype.ext_iff, iff_self]
intro h
exact Subsingleton.elim
simp only [nontrivial_iff, subsingleton_iff, not_exists, Ne.def, _root_.not_not, iff_self]
rw [← not_nontrivial_iff_subsingleton, or_comm]
exact Classical.em _
refine fun H ↦ h ?_
rw [← hx', ← hy', H]
cases f
cases g
congr
simp
-- Error, `f` has type `fin 3 ≃ fin 3` but is expected to have type `fin 3 ↪ ?m_1 : Type ?`
simp
intro x y (h : ite _ _ _ = ite _ _ _)
    -- TODO: once we have `cc` we can avoid all the manual cases below
simp [setValue]
simp [Subtype.ext_iff]
simp
congr
injection h
cases e₁
cases e₂
congr
cases h
rfl
cases h
rfl
rw [Perm.subsingleton_eq_refl e, coe_refl]

-- porting note: marking this as `@[simp]` because `simp` doesn't fire on `coe_refl`
-- in an expression such as `Equiv.refl a x`
subst h
simp [coe_refl]
simp [H.symm]
simp [H]
cases e
rfl
cases e
rfl
cases e
rfl
simp
simp
simp [permCongr_def]
simp only [comp_apply, symm_apply_apply]
simp only [comp_apply, apply_symm_apply]
apply arrowCongr_comp
simp [@Bool.decide_iff p (Classical.propDecidable _)]
cases b <;> simp
rw [Subsingleton.elim b a]
rfl
simp
constructor <;> intro h₂ x
. rw [← f.right_inv x]; apply h.mp; apply h₂
· apply h.mpr; apply h₂
simp
simp only [e.symm_apply_apply]
rfl
simp
simp
simp
simp
cases s <;> rfl
cases s <;> rfl
simp
simp
cases b <;> rfl
cases o <;> rfl
cases a <;> rfl
simp
cases s <;> rfl
simp [Perm.subtypeCongr.apply, h]
simp [Perm.subtypeCongr.apply, h]
dsimp only
rw [dif_neg h]
simp
simp
cases p
rfl
cases p
rfl
cases n <;> rfl
rw [List.map_map, e.symm_comp_self, List.map_id]
rw [List.map_map, e.self_comp_symm, List.map_id]
simp
simp
simp
apply sigmaCongrRight
intro y
apply Equiv.symm
refine' (subtypeSubtypeEquivSubtypeExists _ _).trans (subtypeEquivRight _)
intro x
exact ⟨fun ⟨hp, h'⟩ => congr_arg Subtype.val h', fun h' => ⟨(h x).2 (h'.symm ▸ y.2),
            Subtype.eq h'⟩⟩
rw [← f.2 i]
exact (f.1 i).2
  left_inv
simp
cases x
rfl
simp [Perm.extendDomain]
simp [Perm.extendDomain, h]
simp [Perm.extendDomain, h]
simp [Perm.extendDomain]
simp [Perm.extendDomain, permCongr_trans]
rw [Quotient.sound hab]
exact fun ⟨a, ha⟩ => Quotient.inductionOn a (fun b hb => rfl) ha
  right_inv a
simp (config := { contextual := true }) [swap_apply_def]
refine' ⟨fun h => (Equiv.refl _).injective _, fun h => h ▸ swap_self _⟩
rw [← h, swap_apply_left, h, refl_apply]
cases π
rfl
rw [update_apply _ i j, update_apply _ j i, Equiv.swap_apply_def, id.def]
rw [swap_eq_update, comp_update, comp_update, comp.right_id]
rw [@eq_comm _ (e.symm x)]
constructor <;> intros <;> simp_all
rw [← Equiv.trans_apply, Equiv.swap_swap, Equiv.refl_apply]
rw [apply_eq_iff_eq_symm_apply, symm_swap]
simp [setValue, swap_apply_left]
simp
simp [arrowCongr]
rw [← update_comp_eq_of_injective _ g.injective, g.apply_symm_apply]
simp [(e.piCongrLeft' P).symm_apply_eq, piCongrLeft'_update]
rw [← Option.ne_none_iff_isSome]
intro hn
rw [Option.not_isSome_iff_eq_none, ← hn] at h
exact Option.some_ne_none _ (e.injective h)
simp [removeNone_aux, Option.isSome_iff_exists.mpr h]
simp [removeNone_aux, Option.not_isSome_iff_eq_none.mpr h]
cases h1 : e.symm (some (removeNone_aux e x)) <;> cases h2 : e (some x)
· rw [removeNone_aux_none _ h1]
        exact (e.eq_symm_apply.mpr h2).symm
· rw [removeNone_aux_some _ ⟨_, h2⟩] at h1
        simp at h1
· rw [removeNone_aux_none _ h2] at h1
        simp at h1
· rw [removeNone_aux_some _ ⟨_, h1⟩]
        rw [removeNone_aux_some _ ⟨_, h2⟩]
        simp
simp [EquivFunctor.map]
cases a with
          | none => simp
          | some a =>
            simp only [casesOn'_some, Function.comp_apply, Subtype.coe_eta,
              symm_apply_apply, dite_eq_ite]
            exact if_neg (e a).property
dsimp only [optionSubtype]
simp
simp only [optionSubtype, coe_fn_symm_mk, Subtype.coe_mk,
             Subtype.coe_eta, dite_eq_ite, ite_eq_right_iff]
exact fun h => False.elim (b.property h)
infer_instance
simp only [← not_nonempty_iff, nonempty_Prop, iff_self]
simp only [← not_nonempty_iff, Classical.nonempty_pi, not_forall, iff_self]
simp only [← not_nonempty_iff, nonempty_sigma, not_exists, iff_self]
simp only [← not_nonempty_iff, nonempty_psigma, not_exists, iff_self]
simp only [← not_nonempty_iff, nonempty_subtype, not_exists, iff_self]
simp only [← not_nonempty_iff, nonempty_prod, not_and_or, iff_self]
simp only [← not_nonempty_iff, nonempty_pprod, not_and_or, iff_self]
simp only [← not_nonempty_iff, nonempty_sum, not_or, iff_self]
simp only [← not_nonempty_iff, nonempty_psum, not_or, iff_self]
simp only [← not_nonempty_iff, nonempty_ulift, iff_self]
simp only [← not_nonempty_iff, nonempty_plift, iff_self]
rw [iterate_succ, ihn, comp.left_id]
rw [Nat.add_succ, iterate_succ, iterate_succ, iterate_add m n]
rfl
rw [iterate_add f m n]
rfl
simp only [Nat.mul_zero, iterate_zero]
simp only [Nat.mul_succ, Nat.mul_one, iterate_one, iterate_add, iterate_mul m n]
rw [iterate_succ_apply, h, ihn]
simp only [iterate_succ_apply, hx, (h.iterate_left n).eq, ihn, ((refl g).iterate_right n).eq]
rw [iterate_succ, (Commute.self_iterate f n).comp_eq]
rw [iterate_succ']
rfl
rw [← iterate_succ, Nat.succ_pred_eq_of_pos hn]
rw [← iterate_succ', Nat.succ_pred_eq_of_pos hn]
rw [iterate_succ']
exact h _
rw [iterate_succ', iterate_succ]
exact ihn.comp hg
rw [Nat.mul_comm]
rw [length_cons, foldr, foldr_const f b l, iterate_succ_apply']
simp only [comp_apply, h.eq, h'.eq]
simp only [comp_apply, hab.eq, hbc.eq]
rw [← hb (f (ga' x)), ← h.eq, ha x]
simp only [hf'.eq, hf.eq, comp_apply]
simp only [← h.eq, @IsAssociative.assoc _ ga]
simp only [h.eq, @IsAssociative.assoc _ gb]
simp only [← h.eq, @IsIdempotent.idempotent _ ga]
rw [h.eq, @IsIdempotent.idempotent _ gb]
funext a
                      exact type_eq_of_heq (this a)
  subst this
  apply heq_of_eq
  funext a
  exact eq_of_heq (this a)
intros x₁ x₂ h
   dsimp only
specialize h (fun y ↦ ∃ x, f x = y) (fun _ ↦ True) (funext fun x ↦ eq_true ⟨_, rfl⟩)
intro y
rw [congr_fun h y]
trivial
simp only [cast_cast, cast_eq] at this
assumption
rw [hf (i a), hh a]
rw [h₂.comp_eq_id, comp.right_id]
rw [← comp.assoc, h₁.comp_eq_id, comp.left_id]
rw [hpi, dif_pos h'] at h
rw [hpi, dif_neg h'] at h
contradiction
simp only [invFun, dif_pos h, h.choose_spec]
rw [hg b]
exact invFun_eq ⟨g b, hg b⟩
intro h
        rw [eq_rec_constant]
rw [← and_forall_ne a, update_same]
simp (config := { contextual := true })
rw [← not_forall_not, forall_update_iff f fun a b ↦ ¬p a b]
simp [-not_and, not_and_or]
simp [update_eq_iff]
simp [eq_update_iff]
funext c
simp only [update]
funext b
unfold extend
congr
simp only [extend_def, dif_pos, exists_apply_eq_apply]
exact hf (Classical.choose_spec (exists_apply_eq_apply f a))
simp [Function.extend_def, hb]
simp only [comp_apply, hf.extend_apply]
rw [Classical.choose_spec h, comp_apply, comp_apply, hf]
intro g₁ g₂ hg
refine' funext fun x ↦ _
have H := congr_fun hg (f x)
simp only [hf.extend_apply] at H
exact H
simp only [comp.assoc g _ f, (leftInverse_surjInv hf).comp_eq_id, comp.right_id]
rw [apply_ite f, h, ite_not]
cases h
refine ⟨fun _ _ ↦ id, fun x ↦ ⟨x, rfl⟩⟩
cases h
refine ⟨fun _ _ ↦ id, fun x ↦ ⟨x, rfl⟩⟩
cases h
refine ⟨fun _ _ ↦ id, fun x ↦ ⟨x, rfl⟩⟩
rw [h]
rw [cast_eq_iff_heq, h]
cases Subsingleton.elim x y
rfl
cases h₂
cases h₁
rfl
congr
rw [h]
congr
rw [h]
rw [← h]
rw [h]
rw [h]
rw [h]
funext _
simp only [true_iff, id.def, eq_iff_iff]
simp [Xor']
simp [Xor', and_comm, or_comm]
simp [Xor']
simp [Xor', or_comm, and_comm]
simp [eq_comm]
simp [eq_comm]
simp only [not_and, Xor', not_or, not_not, ← iff_iff_implies_and_implies, iff_self]
simp only [← @xor_not_right a, not_not]
rfl
simp only [← @xor_not_left _ b, not_not]
rfl
cases h
rfl
subst e
exact h
subst h₁
subst h₂
rfl
rw [h]
rw [h]
simp only [not_exists, Decidable.not_not, iff_self]
let ⟨a⟩ := ha
refine ⟨fun h ↦ not_forall_not.1 fun h' ↦ ?_, fun ⟨x, hx⟩ h ↦ hx (h x)⟩
exact if hb : b then h' a fun _ ↦ hb else hb <| h fun x ↦ (not_imp.1 (h' x)).1
simp
simp
simp
simp only [← @forall_eq _ p a, ← forall_and, ← or_imp, Classical.em, forall_const, iff_self]
simp only [eq_comm, ExistsUnique, and_self, forall_eq', exists_eq']
simp only [ExistsUnique, and_self, forall_eq', exists_eq']

-- @[simp] -- FIXME simp does not apply this lemma for some reason
simp
simp [forall_swap]
simp
simp [forall_swap]
simp [@eq_comm _ a']
simp only [@exists_comm (κ₁ _), @exists_comm ι₁, iff_self]
simp [or_comm, Decidable.forall_or_left]
simp
simp only [exists_unique_iff_exists] at h₂
apply h₂.elim
exact fun x ⟨hxp, hxq⟩ H ↦ h₁ x hxp hxq fun y hyp hyq ↦ H y ⟨hyp, hyq⟩
simp only [exists_unique_iff_exists]
exact ExistsUnique.intro w ⟨hp, hq⟩ fun y ⟨hyp, hyq⟩ ↦ H y hyp hyq
simp only [exists_unique_iff_exists] at h
exact h.unique ⟨hpy₁, hqy₁⟩ ⟨hpy₂, hqy₂⟩
infer_instance
infer_instance
infer_instance
infer_instance
simp only [exists_prop, exists_eq_left]
rfl
simp
simp only [exists_prop]
exact Iff.trans (exists_congr fun x ↦ or_and_right) exists_or
simp only
rw [exists_prop, exists_prop]
rw [ne_comm]
simp only [Ne.def, dite_eq_right_iff, not_forall]
rfl
simp only
rw [exists_prop]
simp only
rw [exists_prop]
rw [dif_neg (h p), dif_pos p]
congr
funext _
rw [dif_neg np]
funext a b
exact iff_eq_eq
  rw [this, eq_comp]
funext a b
exact iff_eq_eq
  rw [this, comp_eq]
funext a d
apply propext
constructor
exact fun ⟨c, ⟨b, hab, hbc⟩, hcd⟩ ↦ ⟨b, hab, c, hbc, hcd⟩
exact fun ⟨b, hab, c, hbc, hcd⟩ ↦ ⟨c, ⟨b, hab, hbc⟩, hcd⟩
funext c a
apply propext
constructor
exact fun ⟨b, hab, hbc⟩ ↦ ⟨b, hbc, hab⟩
exact fun ⟨b, hbc, hab⟩ ↦ ⟨b, hab, hbc⟩
rfl
rfl
induction hbc
case refl => assumption
case tail c d _ hcd hac => exact hac.tail hcd
induction hbc
case refl => exact refl.tail hab
case tail c d _ hcd hac => exact hac.tail hcd
induction h
case refl => exact refl
case tail b c _ hbc ih =>
  -- Porting note: Lean 3 figured out the motive and `apply ih` worked
  refine @ih (λ {a : α} (hab : ReflTransGen r a b) => P a (ReflTransGen.tail hab hbc)) ?_ ?_
  { exact head hbc _ refl }
  { exact fun h1 h2 ↦ head h1 (h2.tail hbc) }
induction h
case refl => exact ih₁ a
case tail b c hab hbc ih => exact ih₃ hab (single hbc) ih (ih₂ hbc)
assumption
assumption
induction hbc
case refl => assumption
case tail c d _ hcd hac => exact hac.tail hcd
induction hab generalizing c
case refl => exact single hbc
case tail _ _ _ hdb IH => exact tail (IH hdb) hbc
induction h
case single a h => exact base h
case tail b c _ hbc h_ih =>
  -- Lean 3 could figure out the motive and `apply h_ih` worked
  refine @h_ih (λ {a : α} (hab : @TransGen α r a b) => P a (TransGen.tail hab hbc)) ?_ ?_;
  exact fun h ↦ ih h (single hbc) (base hbc)
  exact fun hab hbc ↦ ih hab _
induction h with
  | single h => exact base h
  | tail hab hbc h_ih => exact ih hab (single hbc) h_ih (base hbc)
induction hbc
case single c hbc => exact tail' hab hbc
case tail c d _ hcd hac => exact hac.tail hcd
rfl
rfl
induction h
case single _ hc => exact hc
case tail c d _ hcd hac => exact trans hac hcd
induction hab
case single c hac => exact TransGen.single (h a c hac)
case tail c d _ hcd hac => exact TransGen.tail hac (h c d hcd)
rw [cases_head_iff]
simp [h, eq_comm]
intro h
induction h with
      | rel => assumption
      | refl => exact h.1 _
      | symm => apply h.symm; assumption
      | trans _ _ _ _ _ hab hbc => exact h.trans hab hbc
induction h with
  | rel a b h => exact EqvGen.rel _ _ (hrp _ _ h)
  | refl => exact EqvGen.refl _
  | symm a b _ ih => exact EqvGen.symm _ _ ih
  | trans a b c _ _ hab hbc => exact EqvGen.trans _ _ _ hab hbc
apply h.inv'
dsimp [Symmetrify.lift]
cases f
· simp only
    rfl
· simp only
    rw [h.inv']
    rfl
intro p
apply this
rw [hu, hv]
subst_vars
rfl
subst_vars
rfl
subst_vars
rfl
rw [Hom.cast_eq_cast]
exact _root_.cast_eq_iff_heq
rw [eq_comm, Hom.cast_eq_iff_heq]
exact ⟨HEq.symm, HEq.symm⟩
rw [hu, hv]
subst_vars
rfl
subst_vars
rfl
subst_vars
rfl
rw [Path.cast_eq_cast]
exact _root_.cast_heq _ _
rw [Path.cast_eq_cast]
exact _root_.cast_eq_iff_heq
subst_vars
rfl
rw [Path.cast_eq_iff_heq]
exact heq_of_cons_eq_cons h
rw [Hom.cast_eq_iff_heq]
exact hom_heq_of_cons_eq_cons h
cases p <;> simp only [Nat.succ_ne_zero, length_cons] at hzero
rfl
dsimp only
rw [← h X, ← h Y]
exact φ.map f
intros
subst_vars
rfl
injection h
injection h
injection h
injection h
injection h
cases p
· rfl
· cases Nat.succ_ne_zero _ hzero
rw [comp_cons, nil_comp p]
rw [comp_cons, comp_cons, comp_cons, comp_assoc p q r]
simp
simp [toList_comp]
cases h
cases h
dsimp
rw [mapPath_comp p q]
simp
simp
match h with | .isTrue _ => rfl
match h with | .isFalse _ => rfl
have := if_pos hc ▸ h
exact this
have := if_neg hnc ▸ h
exact this
cases h
rfl
exact h _ ▸ rfl
simp [h₁, h₂]
apply eq_min
   . apply le_trans
apply min_le_left
apply min_le_left
   . apply le_min
apply le_trans
apply min_le_left
apply min_le_right
apply min_le_right
   . intros d h₁ h₂
apply le_min
apply le_min h₁
apply le_trans h₂
apply min_le_left
apply le_trans h₂
apply min_le_right
simp [min_def]
apply Eq.symm
apply eq_min (le_refl _) h
intros
assumption
rw [min_comm]
apply eq_max
· apply le_trans; apply le_max_left a b; apply le_max_left
· apply max_le; apply le_trans; apply le_max_right a b; apply le_max_left; apply le_max_right
· intros d h₁ h₂; apply max_le; apply max_le h₁; apply le_trans (le_max_left _ _) h₂;
    apply le_trans (le_max_right _ _) h₂
simp [max_def]
apply Eq.symm
apply eq_max (le_refl _) h
intros
assumption
rw [←max_comm b a]
exact max_eq_left h

/- these rely on lt_of_lt -/
rw [hab]
exact ⟨irrefl_of lt b, irrefl_of lt b⟩
intros
rfl
intros
rfl
intros
rfl
rw [← hx, rfg]
rw [succ_mul]
intro h
exact Or.inr (Nat.eq_zero_of_add_eq_zero_left h)

/- properties of inequality -/
rw [Nat.add_right_comm]
exact kn
rw [e]
exact pm
      IH _ ⟨rfl, this⟩ fun n h ↦ this n $ Nat.le_of_succ_le_succ h
simp
simp only [Nat.pow_succ]
exact (@Nat.div_lt_iff_lt_mul b n (b ^ e) h_b_pos).mpr
decide
simp only [pow_succ, pow_zero, Nat.one_mul]
decide
infer_instance
infer_instance
infer_instance
cases h
rfl
cases b <;> rfl
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
decide
decide
simp
simp
simp
simp
cases a <;> simp
cases a <;> cases b <;> simp
cases a <;> cases b <;> simp
cases a <;> simp
simp
simp
simp
simp
simp
decide
cases h' : decide q with
  | false => exact decide_false (mt h.1 <| of_decide_false h')
  | true => exact decide_true (h.2 <| of_decide_true h')
simp
simp
decide
induction l₁ <;> intro l₂ <;> cases l₂ <;>
    simp [*, add_one, min_succ_succ, Nat.zero_min, Nat.min_zero]
induction n <;> simp [*]
simp only [one h₁ h₂ distrib, h₁.left_id, h₁.right_id, h₂.left_id, h₂.right_id]
simp only [distrib, h₁.left_id, h₁.right_id, h₂.left_id, h₂.right_id]
rw [← mul_smul, mul_comm, mul_smul]
apply MulOpposite.rec _ m
intro m
apply (IsCentralScalar.op_smul_eq_smul _ _).symm
rw [smul_assoc, smul_assoc, smul_comm b]
simp only [smul, mul_smul]
rw [← f.map_one, hsmul, one_smul]
simp only [← f.map_mul, hsmul, mul_smul]
rw [smul_mul_assoc, mul_smul_comm, ← smul_assoc, smul_eq_mul]
simp [g.map_one, MulAction.one_smul]
simp [g.map_mul, MulAction.mul_smul]
rw [smul_assoc, one_smul]
rw [smul_mul_assoc, one_mul]
rw [← smul_eq_mul, ← smul_comm, smul_eq_mul, mul_one]
rw [← h, smul_eq_mul, mul_assoc, h, smul_eq_mul]
rw [← H x z, smul_eq_mul, ← H, smul_eq_mul, mul_assoc]
rw [smul_one_mul, smul_smul]
simp only [smul, map_zero, smul_zero]
rw [← map_zero f, ← smul, smul_zero]
rw [hsmul, smul_zero]
simp only [smul, map_add, smul_add]
simp only [hsmul, smul_add]
rw [← smul_add, neg_add_self, smul_zero]
rw [sub_eq_add_neg, sub_eq_add_neg, smul_add, smul_neg]
simp only [smul, f.map_mul, smul_mul']
simp only [smul, f.map_one, smul_one]
rw [← f.map_one, ← smul, smul_one]
cases x
rw [smul_mk, smul_mk, smul_mk, smul_assoc]
cases x
rw [smul_mk, smul_mk, smul_mk, smul_mk, smul_comm]
cases x
rw [smul_mk, smul_mk, op_smul_eq_smul]
cases x
rw [smul_mk, smul_mk, smul_mk, mul_smul]
cases x
rw [smul_mk, one_smul]
rw [smul_mul_smul, Units.mul_inv, mul_right_inv, one_smul]
rw [smul_mul_smul, Units.inv_mul, mul_left_inv, one_smul]
cases x <;> rfl
injection h (inl a)
injection h (inr b)
injection h (some b)
rw [← cast_zero, cast_inj]
rw [← cast_one, cast_inj]
cases f
cases g
congr
apply FunLike.coe_injective'
exact h
refine' { toFun := id.. } <;> intros <;> rfl
rw [← comp_apply, h, comp_apply]
cases f
cases g
congr
apply FunLike.coe_injective'
exact h
rw [map_one, eq_comm]
rw [← mul_one x, map_mul, h, mul_zero]
simp [← hx, h x]
rw [h, map_zero]
refine' { toFun := _root_.id.. } <;> intros <;> rfl
simp
rw [← comp_apply, h, comp_apply]
have hxy := h (x + y)
rw [mul_add, add_mul, add_mul, f.map_add, f.map_add, f.map_add, f.map_add, h x, h y, add_mul,
        mul_add, mul_add, ← sub_eq_zero, add_comm (f x * f x + f (y * x)), ← sub_sub, ← sub_sub,
        ← sub_sub, mul_comm y x, mul_comm (f y) (f x)] at hxy
simp only [add_assoc, add_sub_assoc, add_sub_cancel'_right] at hxy
rw [sub_sub, ← two_mul, ← add_sub_assoc, ← two_mul, ← mul_sub, mul_eq_zero (M₀ := α),
        sub_eq_zero, or_iff_not_imp_left] at hxy
exact hxy h_two
apply AddMonoidHom.ext -- Porting note: why isn't `ext` picking up this lemma?
intro
rfl
rw [h₂ x, h₂ y]
rw [f.map_mul]
rw [← f.map_one, h₁]
rw [← map_mul, one_mul]
rw [← map_mul, zero_mul]
simp
cases f
cases g
congr
apply Equiv.coe_fn_injective h₁
rw [h1.map_mul, h2.map_mul]
simp [div_eq_mul_inv]
simp [div_eq_mul_inv]
simp [div_eq_mul_inv]
simp [div_eq_mul_inv]
rw [← f.map_mul, u.val_inv, f.map_one]
rw [← f.map_mul, u.inv_val, f.map_one]
rw [div_eq_mul_inv, divp, u.val_inv_eq_inv_val]
simp only [h, val_mul, f.map_mul]
rw [Units.mul_inv_eq_iff_eq_mul, one_mul, coe_liftRight]
rw [Units.inv_mul_eq_iff_eq_mul, mul_one, coe_liftRight]
rw [div_eq_mul_inv, h.mul_inv_cancel]
rw [div_eq_mul_inv, h.inv_mul_cancel_right]
rw [div_eq_mul_inv, h.mul_inv_cancel_right]
simp [h]
simp [h]
rw [div_eq_mul_inv]
exact ha.mul hb.inv
simp only [div_eq_mul_inv]
exact Units.mul_left_inj h.inv.unit'
rw [div_eq_mul_inv, h.mul_inv_eq_iff_eq_mul]
rw [div_eq_mul_inv, h.eq_mul_inv_iff_mul_eq]
rw [div_eq_mul_inv, mul_inv_rev, h.mul_inv_cancel_left, one_div]
simp only [div_eq_mul_inv, mul_inv_rev, mul_assoc, h.mul_inv_cancel_left]
simp [h]
rw [mul_comm, h.div_mul_left]
rw [mul_comm, h.mul_div_cancel]
rw [mul_comm, h.div_mul_cancel]
rw [mul_comm c, mul_comm c, h.mul_div_mul_right]
rw [← mul_one a, ← hb.div_self, ← mul_comm_div, h, div_mul_eq_mul_div, hd.div_mul_cancel]
rw [← (hb.mul hd).mul_left_inj, ← mul_assoc, hb.div_mul_cancel, ← mul_assoc, mul_right_comm,
    hd.div_mul_cancel]
rw [div_div_eq_mul_div, h.mul_div_cancel_left]
rw [h]
exact ZeroHomClass.map_zero f
rw [← ZeroHomClass.map_zero f]
exact hf.ne NeZero.out
cases f
cases g
congr
cases f
cases g
congr
cases f
cases g
congr
apply FunLike.coe_injective'
exact h
rw [← map_mul, h, map_one]
rw [div_eq_mul_inv, div_eq_mul_inv, map_mul, hf]
rw [map_mul, map_inv]
rw [pow_zero, pow_zero, map_one]
rw [pow_succ, pow_succ, map_mul, map_pow f a n]
rw [zpow_ofNat, map_pow, zpow_ofNat]
rw [zpow_negSucc, hf, map_pow, ← zpow_negSucc, ← zpow_negSucc]
cases f
cases g
congr
apply FunLike.coe_injective'
exact h
simp
simp
simp
simp
rw [Function.comp_apply, map_zero, map_zero]
simp
simp
rw [← OneHom.comp_apply, h, OneHom.comp_apply]
rw [← MulHom.comp_apply, h, MulHom.comp_apply]
rw [← MonoidHom.comp_apply, h, MonoidHom.comp_apply]
rw [← MonoidWithZeroHom.comp_apply, h,
    MonoidWithZeroHom.comp_apply]
intros
show f (x * y) * g (x * y) = f x * g x * (f y * g y)
rw [f.map_mul, g.map_mul, ← mul_assoc, ← mul_assoc, mul_right_comm (f x)]
simp
intros
show f (x * y) * g (x * y) = f x * g x * (f y * g y)
rw [f.map_mul, g.map_mul, ← mul_assoc, ← mul_assoc, mul_right_comm (f x)]
simp
rw [map_mul, hxy, ← map_mul, mul_inv_self, map_one]
rw [← map_mul, mul_one]
simp only [one_mul, inv_one, ← map_div, inv_inv]
simp only [map_div]
simp only [mul_right_inv, one_mul, inv_inv]
rw [← mul_inv, f.map_mul]
simp [div_eq_mul_inv, mul_assoc, mul_left_comm, mul_comm]
dsimp only []
rw [map_zero, zero_mul]
cases x
  mul_assoc x y z
cases x
refine' fun x y xy => ab (_ : x * (b * a) = y * (b * a))
rw [← mul_assoc, ← mul_assoc]
exact congr_fun (congr_arg (· * ·) xy) a
rw [h]
exact isRegular_one.left
rw [h]
exact isRegular_one.right
simp [right_distrib]
rw [add_mul, one_mul]
rw [mul_add, mul_one]
rw [add_mul, one_mul]
rw [mul_add, mul_one]
rw [one_mul]
rw [mul_one]
simp
simp
simp only [← ite_and, ite_mul, mul_ite, mul_zero, zero_mul, and_comm]
simp only [two_mul, add_mul, mul_add, add_assoc, mul_comm b]
simp
simp
simp
simp
simp
rw [← zero_mul (0 : α), ← neg_mul, mul_zero, mul_zero]
rw [← right_distrib, add_left_neg, zero_mul]
rw [← left_distrib, add_left_neg, mul_zero]
simp [add_comm]
rw [h]
simp
rw [← h]
simp
simp [sub_mul, sub_add_eq_add_sub]
simp [sub_mul, sub_add_eq_add_sub]
rw [h]
simp [@add_sub_cancel α]
rw [sub_mul, one_mul]
rw [mul_sub, mul_one]
rw [sub_mul, one_mul]
rw [mul_sub, mul_one]
rw [← add_mul, zero_add, add_zero]
rw [← mul_add, add_zero, add_zero]
rw [← add_mul, zero_add, add_zero]
rw [← mul_add, add_zero, add_zero]
rw [IsIdempotentElem, mul_assoc, ← mul_assoc q, ← h.eq, mul_assoc p, h₂.eq, ← mul_assoc, h₁.eq]
rw [IsIdempotentElem, mul_sub, mul_one, sub_mul, one_mul, h.eq, sub_self, sub_zero]
rw [pow_succ, ih, h.eq]
refine'
    Iff.intro (fun h => or_iff_not_imp_left.mpr fun hp => _) fun h =>
      h.elim (fun hp => hp.symm ▸ zero) fun hp => hp.symm ▸ one
exact mul_left_cancel₀ hp (h.trans (mul_one p).symm)
simp only [SemiconjBy, left_distrib, right_distrib, h.eq, h'.eq]
simp only [SemiconjBy, left_distrib, right_distrib, ha.eq, hb.eq]
simp only [SemiconjBy, h.eq, neg_mul, mul_neg]
simp only [SemiconjBy, h.eq, neg_mul, mul_neg]
simp [left_distrib, hd, he]
simp [hc]
simp [hc]
rw [sub_eq_add_neg]
exact dvd_add h₁ (dvd_neg_of_dvd h₂)
rw [add_comm]
exact dvd_add_iff_left h
rw [add_mul, mul_sub, mul_sub, h.eq, sub_add_sub_cancel]
rw [mul_add, sub_mul, sub_mul, h.eq, sub_add_sub_cancel]
rw [← sub_eq_zero, h.mul_self_sub_mul_self_eq, mul_eq_zero, or_comm, sub_eq_zero,
    add_eq_zero_iff_eq_neg]
rw [← (Commute.one_right a).mul_self_sub_mul_self_eq, mul_one]
rw [← (Commute.one_right a).mul_self_eq_mul_self_iff, mul_one]
rw [eq_comm, eq_inv_iff_mul_eq_one, neg_mul, mul_neg, neg_neg, mul_left_inv]
simp [mul_sub, mul_comm]
simp
rw [this]
simp [h]
simp [←sub_eq_add_neg, h]
rw [← sub_eq_zero, ← mul_sub] at h
exact sub_eq_zero.1 ((eq_zero_or_eq_zero_of_mul_eq_zero h).resolve_left ha)
rw [← sub_eq_zero, ← sub_mul] at h
exact sub_eq_zero.1 ((eq_zero_or_eq_zero_of_mul_eq_zero h).resolve_right hb)
simp
simp
simp only [divp, neg_mul]
simp only [divp, add_mul]
rw [sub_eq_add_neg, sub_eq_add_neg, neg_divp, divp_add_divp_same]
simp only [divp, add_mul, Units.mul_inv_cancel_right]
simp only [divp, sub_mul, Units.mul_inv_cancel_right]
simp only [divp, add_mul, Units.mul_inv_cancel_right]
simp only [divp, sub_mul, sub_right_inj]
rw [mul_assoc, Units.mul_inv, mul_one]
simp only [sub_eq_add_neg, neg_divp, divp_add_divp, mul_neg]
simp only [*, left_distrib]
simp only [*, right_distrib]
simp only [← add, ← mul, left_distrib]
simp only [← add, ← mul, right_distrib]
erw [neg, mul, neg, neg_mul, mul]
erw [neg, mul, neg, mul_neg, mul]
erw [← neg, ← mul, neg_mul, neg, mul]
erw [← neg, ← mul, mul_neg, neg, mul]
refine' fun x y (h' : k * x = k * y) => sub_eq_zero.mp (h _ _)
rw [mul_sub, sub_eq_zero, h']
refine' fun x y (h' : x * k = y * k) => sub_eq_zero.mp (h _ _)
rw [sub_mul, sub_eq_zero, h']
infer_instance
infer_instance
intros
rfl
intros
rfl
rw [hxz, mul_one]
rw [← mul_assoc, hf.mul_comm y x]
rw [hxy, one_mul]
rw [← div_self h, add_div]
rw [← div_self h, add_div]
rw [mul_add, one_div_mul_cancel ha, add_mul, one_mul, mul_assoc, mul_one_div_cancel hb, mul_one,
    add_comm]
rw [right_distrib, div_mul_cancel _ hc]
rw [add_div, mul_div_cancel _ hc]
rw [neg_mul_neg, one_mul]
rw [neg_eq_neg_one_mul]
rw [one_div_mul_one_div_rev]
rw [one_div_neg_one_eq_neg_one]
rw [mul_neg, mul_one]
rw [← inv_eq_one_div, division_def]
rw [one_div_neg_eq_neg_one_div]
rw [neg_mul_eq_mul_neg]
rw [mul_one_div]
rw [neg_eq_neg_one_mul, mul_div_assoc, ← neg_eq_neg_one_mul]
simp [neg_div]
rw [div_neg_eq_neg_div, neg_div, neg_neg]
rw [inv_eq_one_div, inv_eq_one_div, div_neg_eq_neg_div]
rw [← div_neg_eq_neg_div]
rw [neg_inv]
rw [div_neg_eq_neg_div, div_self h]
rw [neg_div, div_self h]
rw [sub_eq_add_neg, ← neg_div, div_add_div_same, sub_eq_add_neg]
rw [mul_sub, sub_mul, mul_inv_cancel_right₀ hb, inv_mul_cancel ha, one_mul]
rw [mul_sub_left_distrib (1 / a), one_div_mul_cancel ha, mul_sub_right_distrib, one_mul,
    mul_assoc, mul_one_div_cancel hb, mul_one]

-- see Note [lower instance priority]
rw [← mul_div_mul_right _ b hd, ← mul_div_mul_left c d hb, div_add_div_same]
rw [div_add_div _ _ ha hb, one_mul, mul_one, add_comm]
rw [inv_eq_one_div, inv_eq_one_div, one_div_add_one_div ha hb]
simp [sub_eq_add_neg]
rw [neg_eq_neg_one_mul, ← mul_div_assoc, div_add_div _ _ hb hd, ← mul_assoc, mul_comm b,
    mul_assoc, ← neg_eq_neg_one_mul]
rw [inv_eq_one_div, inv_eq_one_div, div_sub_div _ _ ha hb, one_mul, mul_one]
erw [rat_cast, mul, inv, int_cast, nat_cast]
exact DivisionRing.ratCast_mk a b h1 h2
erw [qsmul, mul, Rat.smul_def, rat_cast]
erw [rat_cast, mul, inv, int_cast, nat_cast]
exact DivisionRing.ratCast_mk a b h1 h2
erw [qsmul, mul, Rat.smul_def, rat_cast]
cases this
rfl
intros
rfl
intros
rfl
intros
rfl
intros
rfl
rw [← one_mul c, ← hba, mul_assoc, hac, mul_one b]
intros
rfl
intros
rfl
intros
rfl
intros
rfl
intros
rfl
intros
rfl
intros
rfl
intros
rfl
rw [← zpow_ofNat]
exact DivInvMonoid.zpow_neg' n a
rw [← ofNat_zsmul]
exact SubNegMonoid.zsmul_neg' n a
rw [← mul_assoc, mul_left_inv, one_mul]
rw [← mul_assoc, mul_right_inv, one_mul]
rw [mul_assoc, mul_right_inv, mul_one]
rw [mul_assoc, mul_left_inv, mul_one]
rw [mul_assoc, mul_inv_cancel_left, mul_right_inv]
rw [← mul_inv_cancel_right a b, h, mul_inv_cancel_right]
rw [← inv_mul_cancel_left a b, h, inv_mul_cancel_left]
unfold SemiconjBy
  -- TODO this could be done using `assoc_rw` if/when this is ported to mathlib4
rw [←mul_assoc, h.eq, mul_assoc, h'.eq, ←mul_assoc]
unfold SemiconjBy
rw [mul_assoc, hb.eq, ←mul_assoc, ha.eq, mul_assoc]
rw [SemiconjBy, mul_one, one_mul]
rw [Units.inv_mul_cancel_left]
rw [← h.eq, mul_assoc, Units.mul_inv_cancel_right]
rw [Units.mul_inv_cancel_right]
rw [← h.eq, ← mul_assoc, Units.inv_mul_cancel_left]
rw [mul_inv_rev, mul_inv_rev, inv_inv, inv_inv, inv_inv, eq_comm, SemiconjBy]
unfold SemiconjBy
rw [mul_assoc, inv_mul_self, mul_one]
rw [h, SemiconjBy, mul_comm]
unfold SemiconjBy
rw [Units.inv_mul_cancel_right]
simp only [mul_assoc, h.eq]
simp only [← mul_assoc, h.eq]
rw [← mul_assoc, hu, u.mul_inv]
have : Commute a u := hu ▸ (Commute.refl _).mul_right hc
rw [← this.units_inv_right.right_comm, ← hc.eq, hu, u.mul_inv]
rw [h.inv_left.eq, inv_mul_cancel_right]
rw [← mul_assoc, h.inv_mul_cancel]
rw [h.eq, mul_inv_cancel_right]
rw [← mul_assoc, h.mul_inv_cancel]
simp only [mul_left_comm, mul_assoc]
simp only [mul_left_comm, mul_comm]
simp only [mul_left_comm, mul_comm]
rw [add_comm, bit1_add, add_comm]
rw [bit1, bit0_zero, zero_add]
rw [mul_one]
rw [one_mul]
simp [h]
rw [div_eq_mul_inv, one_mul]
rw [div_eq_mul_inv, one_mul, div_eq_mul_inv]
rw [div_eq_mul_inv, div_eq_mul_inv, mul_assoc _ _ _]
simp only [mul_assoc, div_eq_mul_inv]
rw [div_eq_mul_inv, one_div]
simp [div_eq_mul_inv]
rw [← inv_eq_of_mul_eq_one_right h, inv_inv]
rw [eq_inv_of_mul_eq_one_left h, one_div]
rw [eq_inv_of_mul_eq_one_right h, one_div]
simp
simp
simp
simp
simp
rw [← one_div_one_div a, h, one_div_one_div]
simp
simp
simp only [mul_assoc, mul_inv_rev, div_eq_mul_inv]
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
rw [div_eq_mul_inv, mul_left_eq_self]
simp [h.symm]
simp [h.symm]
simp [h]
simp [h]
simp [h.symm]
simp [h.symm, mul_inv_cancel_left]
rw [h, mul_inv_cancel_left]
simp [h]
rw [h, mul_left_inv]
rw [mul_eq_one_iff_eq_inv, eq_inv_iff_eq_inv, eq_comm]
rw [h, inv_mul_cancel_right]
rw [← h, mul_inv_cancel_right]
rw [h, mul_inv_cancel_left]
rw [← h, inv_mul_cancel_left]
rw [← h, mul_inv_cancel_left]
rw [h, inv_mul_cancel_left]
rw [← h, inv_mul_cancel_right]
rw [h, mul_inv_cancel_right]
rw [mul_eq_one_iff_eq_inv, inv_inv]
rw [mul_eq_one_iff_eq_inv, inv_inj]
simp only [div_eq_mul_inv]
exact fun a a' h ↦ inv_injective (mul_right_injective b h)
rw [div_eq_mul_inv, inv_mul_cancel_right a b]
rw [div_eq_mul_inv, mul_right_inv a]
rw [div_eq_mul_inv, mul_inv_cancel_right a b]
rw [div_mul_eq_div_div_swap]
simp only [mul_left_inj, eq_self_iff_true, mul_div_cancel'']
simp [← h]
simp [h]
simp [← h]
simp [h]
rw [div_eq_mul_inv, div_eq_mul_inv]
exact mul_left_inj _
rw [← mul_div_assoc, div_mul_cancel']
rw [← inv_div c b, div_inv_eq_mul, div_mul_div_cancel']
rw [h, div_self']
rw [div_eq_mul_inv, mul_right_eq_self, inv_eq_one]
rw [div_eq_mul_inv, eq_mul_inv_iff_mul_eq]
rw [div_eq_mul_inv, mul_inv_eq_iff_eq_mul]
rw [← div_eq_one, H, div_eq_one]
rw [h, div_eq_mul_inv, mul_comm, inv_mul_cancel_left]
simp [h.symm]
simp [h.symm]
simp [h]
rw [mul_comm c, mul_inv_cancel_left]
simp [mul_left_comm c]
simp
rw [eq_div_iff_mul_eq', mul_comm]
rw [div_eq_iff_eq_mul, mul_comm]
rw [div_eq_inv_mul, inv_mul_cancel_left]
rw [← mul_div_assoc, mul_div_cancel''']
rw [← inv_div, mul_div_cancel''']

-- This lemma is in the `simp` set under the name `mul_inv_cancel_comm_assoc`,
-- along with the additive version `add_neg_cancel_comm_assoc`,
-- defined  in `algebra/group/commute`
rw [← div_eq_mul_inv, mul_div_cancel'_right a b]
rw [mul_assoc, mul_div_cancel'_right]
rw [mul_left_comm, div_mul_cancel', mul_comm]
rw [mul_comm]
apply div_mul_div_cancel'
rw [← div_mul, mul_div_cancel''']
rw [← inv_div b c, div_inv_eq_mul, mul_comm, div_mul_div_cancel']
rw [div_eq_iff_eq_mul, div_mul_eq_mul_div, eq_comm, div_eq_iff_eq_mul']
simp only [mul_comm, eq_comm]
rfl
rw [div_eq_iff_eq_mul, div_mul_eq_mul_div, div_eq_iff_eq_mul', mul_div_assoc]
rw [mul_assoc, ← mul_assoc u₂.val, val_inv, one_mul, val_inv]
rw [mul_assoc, ← mul_assoc u₁.inv, inv_val, one_mul, inv_val]
rw [← Units.val_one, eq_iff]
rw [← h, u.inv_mul]
rw [← h, u.mul_inv]
rw [← mul_assoc, mul_inv, one_mul]
rw [← mul_assoc, inv_mul, one_mul]
rw [mul_assoc, mul_inv, mul_one]
rw [mul_assoc, inv_mul, mul_one]
rw [h, inv_mul_cancel_right]
rw [← h, mul_inv_cancel_right]
rw [h, mul_inv_cancel_left]
rw [← h, inv_mul_cancel_left]
rw [← h, mul_inv_cancel_left]
rw [h, inv_mul_cancel_left]
rw [← h, inv_mul_cancel_right]
rw [h, mul_inv_cancel_right]
rw [one_mul]
rw [← h, mul_inv_cancel_right]


-- Porting note: have to explicitly type annotate the 1
rw [mul_one]
rw [← h, inv_mul_cancel_left]
rw [← mul_inv_eq_one, inv_inv]
rw [← inv_mul_eq_one, inv_inv]
rw [h, u₂.mul_inv]
rw [Units.inv_mul, mul_one]
rw [Units.mul_inv, mul_one]
simp only [divp, mul_inv_rev, Units.val_mul, mul_assoc]
rw [divp_mul_cancel]
exact ⟨Eq.symm, Eq.symm⟩
rw [eq_comm, divp_eq_iff_mul_eq]
rw [divp_mul_cancel, one_mul]
rw [one_divp]
rw [one_div, one_divp]
rw [divp, division_def, Units.val_mul]
rw [divp, divp, mul_right_comm]

-- Theoretically redundant as `field_simp` lemma.
rw [divp_eq_iff_mul_eq, divp_mul_eq_mul_divp, divp_eq_iff_mul_eq]

-- Theoretically redundant as `field_simp` lemma.
rw [divp_mul_eq_mul_divp, divp_assoc', divp_divp_eq_divp_mul]
rw [isUnit_iff_exists_inv]
simp [mul_comm]
exists v * u
exists u
rw [←h.unit.mul_inv]
congr
change ↑(h a).unit
change ↑(h a).unit
cases a <;> rfl
cases a <;> rfl
simp
contradiction
contradiction
contradiction
cases n with
      | zero => show (((1 : ℕ) : α) : WithZero α) = 0 + 1; · rw [Nat.cast_one, coe_one, zero_add]
      | succ n =>
          show (((n + 2 : ℕ) : α) : WithZero α) = ((n + 1 : ℕ) : α) + 1
          rw [Nat.cast_succ, coe_add, coe_one]
rw [one_mul]
exact (one_mul _).symm
rw [mul_one]
exact (mul_one _).symm
induction x using WithOne.cases_on <;> rfl
induction x using WithOne.cases_on
· simp
· simp only [map_coe, MulHom.coe_mk, map_comp, MonoidHom.coe_comp, Function.comp_apply,
          MulEquiv.toEquiv_symm, coe_inj]
        apply Equiv.symm_apply_apply
induction x using WithOne.cases_on
· simp
· simp only [map_coe, MulHom.coe_mk, MulEquiv.toEquiv_symm, map_comp, MonoidHom.coe_comp,
          Function.comp_apply, coe_inj]
        apply Equiv.apply_symm_apply
simp only [coe_unzero, Units.mk0_val]
simp only [Units.val_mul, coe_unzero, coe_mul]
rw [mk_mul_mk, mul_one]
rw [mk_mul_mk, mul_one]
simp
simp
simp
simp
simp
rw [mk_mul_mk, mul_comm g₁, mul_comm h₁]
rfl
simp
simp
simp
simp
simp only [mul_left_inj, imp_self, forall_const]
rw [mk_mul_mk, mk_mul_mk, mul_comm m₁, mul_comm n₁]
rw [mk_mul_mk, mk_mul_mk, mul_comm m₁, mul_comm n₁]
simp
simp
simp
simp
simp
simp
rw [mk_mul_mk, mk_mul_mk, mul_comm g₁, mul_comm h₁]
simp only [prod_apply, coe_fst, coe_snd, comp_apply, Prod.mk.eta]
simp
simp only [prod_apply, coe_fst, coe_snd, comp_apply, Prod.mk.eta]
simp [coprod_apply]
simp [coprod_apply]
simp [coprod_apply, inl_apply, inr_apply, ← map_mul]
simp
simp
simp
simp only [MonoidHom.prod_apply, Units.coe_map, MonoidHom.coe_fst, MonoidHom.coe_snd,
      Prod.mk.eta, Units.coe_map_inv, Units.mk_val]
simp only [Units.map, MonoidHom.coe_fst, Units.inv_eq_val_inv,
      MonoidHom.coe_snd, MonoidHom.prod_apply, Prod.mk.injEq]
exact ⟨rfl, rfl⟩
simp only [inv_one, eq_self_iff_true, Units.val_one, op_one, Prod.mk_eq_one, and_self_iff]
simp only [mul_inv_rev, op_mul, Units.val_mul, Prod.mk_mul_mk]
erw [mul, mul, mul, mul, mul_assoc]
erw [mul, mul, mul_comm]
erw [← mul, ← mul, H]
erw [← mul, ← mul, H]
erw [mul, one, one_mul]
erw [mul, one, mul_one]
erw [npow, one, pow_zero]
erw [npow, pow_succ, mul, npow]
erw [nat_cast, Nat.cast_zero, zero]
erw [nat_cast, Nat.cast_succ, add, one, nat_cast]
rw [inv, inv, inv_inv]
erw [zpow, zpow_zero, one]
erw [zpow, mul, zpow_ofNat, pow_succ, zpow, zpow_ofNat]
erw [zpow, zpow_negSucc, inv, zpow, zpow_ofNat]
erw [div, mul, inv, div_eq_mul_inv]
erw [inv, mul, mul_inv_rev, mul, inv, inv]
erw [← mul, h, one]
erw [mul, inv, mul_left_inv, one]
rw [nat_cast, ←Int.cast, int_cast, Int.cast_ofNat]
erw [int_cast, neg, nat_cast, Int.cast_negSucc]
simp only [← mul, mul_assoc]
erw [← mul, ← mul, mul_comm]
erw [← one, ← mul, one_mul]
erw [← one, ← mul, mul_one]
dsimp only
erw [←npow, pow_zero, ←one]
dsimp only
erw [←npow, pow_succ, ←npow, ←mul]
rw [← Nat.cast, ← nat_cast, Nat.cast_zero, zero]
rw [← Nat.cast, ← nat_cast, Nat.cast_succ, add, one, nat_cast]
erw [← inv, ← inv, inv_inv]
dsimp only
erw [← zpow, zpow_zero, ← one]
dsimp only
erw [← zpow, ← zpow, zpow_ofNat, zpow_ofNat, pow_succ, ← mul]
dsimp only
erw [← zpow, ← zpow, zpow_negSucc, zpow_ofNat, inv]
erw [← inv, ← mul, ← div, div_eq_mul_inv]
erw [← inv, ← mul, mul_left_inv, one]
rw [← Int.cast, ← int_cast, Int.cast_ofNat, nat_cast]
rw [← Int.cast, ← int_cast, Int.cast_negSucc, neg, nat_cast]
rfl
rfl
have h₁ : g₁.one = g₂.one := congr_arg (·.one) (Monoid.ext h_mul)
let f : @MonoidHom G G g₁.toMulOneClass g₂.toMulOneClass :=
    @MonoidHom.mk _ _ (_) _ (@OneHom.mk _ _ (_) _ id h₁)
      (fun x y => congr_fun (congr_fun h_mul x) y)
exact
    Group.toDivInvMonoid_injective
      (DivInvMonoid.ext h_mul
        (funext <| @MonoidHom.map_inv G G g₁ g₂.toDivisionMonoid f))
simp
simp
rw [Int.cast_ofNat]
erw [unop_op, Int.cast_negSucc]
simp only [Int.ofNat_eq_coe]
rw [unop_op, zpow_ofNat, pow_succ', unop_mul, unop_op, zpow_ofNat]
simp [div_eq_mul_inv]
simp only [SemiconjBy, ← op_mul, op_inj, eq_comm]
rfl
simp [(hf x y).eq]
simp [(hf x y).eq]
simp
apply AddHom.ext
intro x
simp
apply AddHom.ext
intro x
simp
apply AddMonoidHom.ext
intro
simp [MulOpposite.op, MulOpposite.unop]
rfl
apply AddMonoidHom.ext
intro
simp
rfl
apply AddEquiv.ext
intro
simp [MulOpposite.op, MulOpposite.unop]
apply AddEquiv.ext
intro
simp [MulOpposite.op, MulOpposite.unop]
simp
simp
refine ⟨fun h a b c bc ↦ ?_, fun h a b c bc ↦ ?_⟩
· rw [← inv_mul_cancel_left a b, ← inv_mul_cancel_left a c]
    exact h a
refine ⟨fun h a b c bc ↦ ?_, fun h a b c bc ↦ ?_⟩
· rw [← mul_inv_cancel_right b a, ← mul_inv_cancel_right c a]
    exact h a
rw [flip_mul]
rw [flip_mul]
simp [neZero_iff]
rw [pow_succ, zero_mul]
rw [pow_succ]
exact zero_mul _
rw [← tsub_add_cancel_of_le hn, pow_add, hx, mul_zero]
cases (zero_le n).eq_or_gt <;> simp [*, ne_of_gt]
rw [pow_zero, pow_zero, Ring.inverse_one]
rw [pow_succ, pow_succ', Ring.mul_inverse_rev' ((Commute.refl r).pow_left n),
      Ring.inverse_pow r n]
rw [← pow_succ', mul_one]
exact (pow_dvd_pow _ (Nat.succ_le_of_lt hmn)).trans h
simp only [sq, add_mul_self_eq]
rw [add_sq, add_assoc, add_comm _ (b ^ 2), add_assoc]
rw [pow_succ, h, neg_one_mul, neg_neg]
rw [pow_succ, h, mul_one]
rw [pow_bit0', neg_mul_neg, pow_bit0']
simp only [bit1, pow_succ, neg_pow_bit0, neg_mul_eq_neg_mul]
simp [sq]

-- Porting note: removed the simp attribute to please the simpNF linter
simp [neg_sq, one_pow]
rw [sq, sq, h.mul_self_sub_mul_self_eq]
rw [← sub_eq_zero, h.sq_sub_sq, mul_eq_zero, add_eq_zero_iff_eq_neg, sub_eq_zero, or_comm]
rw [← (Commute.one_right a).sq_eq_sq_iff_eq_or_eq_neg, one_pow]
rw [sub_eq_add_neg, add_sq, neg_sq, mul_neg, ← sub_eq_add_neg]
rw [sub_eq_add_neg, add_sq', neg_sq, mul_neg, ← sub_eq_add_neg]
rw [succ_nsmul, zero_nsmul, add_zero]
induction m with
  | zero => rw [Nat.zero_add, zero_nsmul, zero_add]
  | succ m ih => rw [Nat.succ_add, Nat.succ_eq_add_one, succ_nsmul, ih, succ_nsmul, add_assoc]
rw [pow_succ, pow_zero, mul_one]
rw [pow_succ, pow_one]
rw [pow_succ', pow_two]
rw [pow_succ, pow_two]
rw [Nat.mul_comm, pow_mul]
simp
rw [← pow_mul, Nat.mul_comm, pow_mul]
rw [← pow_add, Nat.add_comm, Nat.sub_add_cancel h]
rw [← pow_add, Nat.sub_add_cancel h]
have t : x ^ m = x ^ (n * (m / n) + m % n) :=
    congr_arg (fun a => x ^ a) ((Nat.add_comm _ _).trans (Nat.mod_add_div _ _)).symm
dsimp at t
rw [t, pow_add, pow_mul, h, one_pow, one_mul]
rw [bit1, pow_succ', pow_bit0]
rw [pow_bit0, (Commute.refl a).mul_pow]
rw [bit1, pow_succ', pow_bit0']
rw [pow_succ', pow_succ]
simp only [mul_assoc]
simp [h, hn]
rw [pow_succ]
exact hxy.mul_right _
rw [pow_zero, pow_zero, inv_one]
rw [pow_succ', pow_succ, inv_pow _ n, mul_inv_rev]
rw [zpow_ofNat, one_pow]
rw [zpow_negSucc, one_pow, inv_one]
change a ^ (0 : ℤ) = (a ^ (0 : ℤ))
rw [zpow_negSucc, inv_inv, ← zpow_ofNat]
rfl
simp only [zpow_neg, zpow_one, mul_inv_rev]
rw [zpow_ofNat, zpow_ofNat, inv_pow]
rw [zpow_negSucc, zpow_negSucc, inv_pow]
rw [inv_zpow, zpow_neg]
simp only [one_div, inv_pow]
simp only [one_div, inv_zpow]
simp [zpow_ofNat, h.mul_pow n]
simp [h.mul_pow, (h.pow_pow _ _).eq, mul_inv_rev]
simp only [div_eq_mul_inv, mul_pow, inv_pow]
simp only [div_eq_mul_inv, mul_zpow, inv_zpow]
rw [← pow_add, Nat.sub_add_cancel h]
rw [← pow_add, Nat.add_comm, Nat.sub_add_cancel h]
simp [zpow_ofNat, h.pow_right n]
simp only [zpow_negSucc, inv_right_iff]
apply pow_right h
induction n generalizing m <;> simp_all [Nat.pow_succ', _root_.pow_succ'', pow_zero]
rw [pow_zero, pow_zero, Int.cast_one]
rw [pow_succ, pow_succ, Int.cast_mul, Int.cast_pow _ n]
rw [nsmul_eq_mul', (n.cast_commute a).eq]
rw [← mul_assoc, invOf_mul_self, one_mul]
rw [← mul_assoc, mul_invOf_self, one_mul]
simp [mul_assoc]
simp [mul_assoc]
apply invOf_eq_right_inv
rw [h, mul_invOf_self]
congr
exact left_inv_eq_right_inv hba hac
rw [hs, invOf_mul_self]
rw [hs, mul_invOf_self]
simp
simp
simp
simp
simp
rw [← two_mul, mul_invOf_self]
simp [← mul_assoc]
simp [← mul_assoc]
simp [← mul_assoc]
simp [mul_assoc]
rw [h.eq]
simp [mul_assoc]
simp [mul_assoc]
rw [h.eq]
simp [mul_assoc]
simp [ha]
simp [← mul_div_assoc]
simp [← mul_div_assoc]
simp [← mul_div_assoc]
simp
simp
rw [← map_mul, invOf_mul_self, map_one]
rw [← map_mul, mul_invOf_self, map_one]
subst h
rfl
cases a <;> rfl
simp only [h₀, sub_top, WithTop.map_zero, coe_zero, map_top]
simp only [← coe_sub, map_coe, h]
rw [tsub_le_iff_right, add_comm]
rw [tsub_le_iff_left, tsub_le_iff_right]
rw [tsub_le_iff_left, add_left_comm]
exact add_le_add_left le_add_tsub a
rw [add_comm, add_comm _ b]
exact add_tsub_le_assoc
rw [add_assoc]
exact add_le_add_left le_add_tsub a
rw [add_comm a, add_comm (a - c)]
exact add_le_add_add_tsub
rw [tsub_le_iff_left, ← add_assoc, add_right_comm]
exact le_add_tsub.trans (add_le_add_right le_add_tsub _)
rw [tsub_le_iff_left, tsub_le_iff_left, add_left_comm]
exact le_tsub_add.trans (add_le_add_left le_add_tsub _)
rw [add_comm c, tsub_le_iff_left, add_assoc, ← tsub_le_iff_left, ← tsub_le_iff_left]
refine' (tsub_le_tsub_right add_tsub_le_assoc c).trans _
rw [add_comm a, add_comm (a - c)]
exact add_tsub_le_assoc
rw [tsub_le_iff_left, add_assoc]
exact add_le_add_left le_add_tsub _
rw [tsub_le_iff_left, add_right_comm]
exact add_le_add_right le_add_tsub c
rw [add_comm]
exact hb.le_add_tsub_swap
rw [tsub_le_iff_left, add_zero]
apply le_antisymm
· rw [tsub_le_iff_left, tsub_le_iff_left, ← add_assoc, ← tsub_le_iff_left]
· rw [tsub_le_iff_left, add_assoc, ← tsub_le_iff_left, ← tsub_le_iff_left]
rw [add_comm]
apply tsub_add_eq_tsub_tsub
rw [←tsub_add_eq_tsub_tsub, tsub_add_eq_tsub_tsub_swap]
rw [h]
exact hb.le_add_tsub
rw [add_comm, h]
rw [add_comm]
refine' add_tsub_add_le_tsub_right.antisymm (tsub_le_iff_right.2 <| le_of_add_le_add_right _)
exact c
rw [add_assoc]
exact le_tsub_add
rw [add_comm a b, add_comm a c, add_tsub_add_eq_tsub_right]
rw [add_comm]
exact add_tsub_cancel_of_le h
rw [tsub_le_iff_right, tsub_add_cancel_of_le h]
rw [tsub_tsub, add_tsub_cancel_of_le h]
rw [eq_comm, hb.eq_tsub_iff_add_eq_of_le h, eq_comm]
rw [add_comm a, hb.add_tsub_assoc_of_le h, add_comm]
rw [add_assoc, add_tsub_cancel_of_le h₂, tsub_add_cancel_of_le h₁]
rw [hb.tsub_add_eq_add_tsub hba, ← hd.add_tsub_assoc_of_le hdc, tsub_tsub, add_comm d]
rw [add_comm]
exact ha.le_tsub_iff_left h
rw [add_comm]
exact hb.tsub_lt_iff_left hba
rw [hb.tsub_lt_iff_left h₁, hc.tsub_lt_iff_right h₂]
rw [ha.le_tsub_iff_left h₁, hc.le_tsub_iff_right h₂]
rw [add_comm]
exact hc.lt_tsub_iff_right_of_le h
rw [← hab.inj]
rw [tsub_add_cancel_of_le h₁, h₃, tsub_add_cancel_of_le h₂]
rw [add_assoc, add_tsub_cancel_of_le h, add_comm]
rw [tsub_right_comm, hab.tsub_tsub_cancel_of_le h]
rw [add_comm]
exact add_tsub_cancel_iff_le
rw [← nonpos_iff_eq_zero, tsub_le_iff_left, add_zero]
rw [pos_iff_ne_zero, Ne.def, tsub_eq_zero_iff_le]
refine' ⟨_, fun h => tsub_le_tsub_left h a⟩
rw [tsub_le_iff_left, ← hc.add_tsub_assoc_of_le h, hc.le_tsub_iff_right (h.trans le_add_self),
    add_comm b]
apply ha
infer_instance
rw [tsub_pos_iff_not_le, not_le]
rw [hc.lt_tsub_iff_left, add_tsub_cancel_of_le h]
refine' tsub_le_self.lt_of_ne fun h => _
rw [← h, tsub_pos_iff_lt] at h₁
exact h₂.not_le (ha.add_le_iff_nonpos_left.1 <| add_le_of_le_tsub_left_of_le h₁.le h.ge)
rw [add_comm, max_comm, tsub_add_eq_max]
rw [← tsub_min, tsub_add_cancel_of_le]
apply min_le_left
rw [tsub_le_iff_right, ← f.map_add]
exact hf le_tsub_add
rw [← map_zero f]
exact OrderHomClass.mono _ ha
rw [← map_zero f]
exact OrderHomClass.mono _ ha
rw [← map_zero f]
apply h
rw [← sub_add_cancel b a, map_add f]
exact le_add_of_nonneg_left (h _ <| sub_nonneg.2 hl)
rw [← map_zero f]
apply h
rw [← sub_add_cancel b a, map_add f]
exact lt_add_of_pos_left _ (h _ <| sub_pos.2 hl)
congr
rw [← comp_apply, h, comp_apply]
congr
rw [← comp_apply, h, comp_apply]
rw [pow_zero]
exact zero_le_one
rw [pow_succ]
exact mul_nonneg H (pow_nonneg H _)
rw [mul_add, mul_two, add_assoc]
simp
rw [h, le_add_iff_nonneg_right]
exact hc
rw [pow_succ]
exact mul_pos H (pow_pos H _)
rw [← b0, mul_zero]
exact mul_pos (h3.trans_lt h1) (h4.trans_lt h2)
rw [bit0, bit0, ← two_mul, ← two_mul, mul_le_mul_left (zero_lt_two : 0 < (2 : α))]
rw [bit0, bit0, ← two_mul, ← two_mul, mul_lt_mul_left (zero_lt_two : 0 < (2 : α))]
rw [bit1, le_add_iff_nonneg_left, bit0, ← two_mul, zero_le_mul_left (zero_lt_two : 0 < (2 : α))]
rw [bit1, lt_add_iff_pos_left, bit0, ← two_mul, zero_lt_mul_left (zero_lt_two : 0 < (2 : α))]
rw [bit0, ← two_mul, zero_le_mul_left (zero_lt_two : 0 < (2 : α))]
rw [bit0, ← two_mul, zero_lt_mul_left (zero_lt_two : 0 < (2 : α))]
rw [← sub_eq_zero, ← mul_sub] at h
exact sub_eq_zero.1 ((eq_zero_or_eq_zero_of_mul_eq_zero h).resolve_left ha)
rw [← sub_eq_zero, ← sub_mul] at h
exact sub_eq_zero.1 ((eq_zero_or_eq_zero_of_mul_eq_zero h).resolve_right hb)
rw [← neg_pos, neg_mul_eq_mul_neg, mul_pos_iff, neg_pos, neg_lt_zero]
rw [← neg_nonneg, neg_mul_eq_mul_neg, mul_nonneg_iff, neg_nonneg, neg_nonpos]
simp [neg_le_iff_add_nonneg, ← two_mul, mul_nonneg_iff, zero_le_one, (zero_lt_two' α).not_le]
simp [neg_lt_iff_pos_add, ← two_mul, mul_pos_iff, zero_lt_one, (zero_lt_two' α).not_lt]
rw [neg_neg]
rw [neg_neg]
rw [add_eq_zero_iff', mul_self_eq_zero, mul_self_eq_zero] <;> apply mul_self_nonneg
simp only [pos_iff_ne_zero, ne_eq, mul_eq_zero, not_or, iff_self]
simp only [mul_comm _ c] at *
exact h.mul_tsub
simp only [zero, one, zero_le_one]
rw [abs_mul, abs_mul_abs_self]
simp [abs_eq_max_neg]
simp [abs_eq_max_neg]
rw [← abs_mul_abs_self, ← abs_mul_abs_self b]
exact (mul_self_inj (abs_nonneg a) (abs_nonneg b)).symm
rw [← abs_mul_abs_self, ← abs_mul_abs_self b]
exact mul_self_lt_mul_self_iff (abs_nonneg a) (abs_nonneg b)
rw [← abs_mul_abs_self, ← abs_mul_abs_self b]
exact mul_self_le_mul_self_iff (abs_nonneg a) (abs_nonneg b)
rw [abs_mul_abs_self]
simp only [mul_add, add_comm, add_left_comm, mul_comm, sub_eq_add_neg, mul_one, mul_neg,
    neg_add_rev, neg_neg, add_assoc]
rw [Nat.cast_succ]
apply lt_add_one
rw [←mul_zero c, mul_lt_mul_left h]
simp
rw [←zero_mul c, mul_lt_mul_right h]
simp
rw [mul_one]
rw [mul_one]
rw [mul_one]
rw [mul_one]
rw [one_mul]
rw [one_mul]
rw [one_mul]
rw [one_mul]
simp only [PosMulStrictMono, MulPosStrictMono, mul_comm, iff_self]
simp only [PosMulReflectLT, MulPosReflectLT, mul_comm, iff_self]
simp only [PosMulMono, MulPosMono, mul_comm, iff_self]
simp only [PosMulMonoRev, MulPosMonoRev, mul_comm, iff_self]
rw [← mul_le_mul_iff_left a]
simp
rw [← mul_le_mul_iff_left a]
simp
rw [← mul_le_mul_iff_left a]
simp
rw [← mul_le_mul_iff_left b, mul_inv_cancel_left]
rw [mul_inv_self]
rw [mul_inv_self]
rw [← mul_le_mul_iff_left b, mul_one, mul_inv_cancel_left]
rw [mul_one]
rw [← mul_lt_mul_iff_left a, mul_inv_self, mul_one]
rw [← mul_lt_mul_iff_left a, mul_inv_self, mul_one]
rw [← mul_lt_mul_iff_left a]
simp
rw [← mul_lt_mul_iff_left b, mul_inv_cancel_left]
rw [mul_inv_self]
rw [mul_inv_self]
rw [← mul_lt_mul_iff_left b, mul_one, mul_inv_cancel_left]
rw [mul_one]
rw [← mul_le_mul_iff_right a]
simp
rw [← mul_le_mul_iff_right a]
simp
rw [inv_mul_self]
rw [inv_mul_self]
rw [inv_mul_cancel_right]
rw [inv_mul_cancel_right]
rw [one_mul]
rw [← mul_le_mul_iff_right b, one_mul, inv_mul_cancel_right]
rw [one_mul]
rw [← mul_lt_mul_iff_right a, inv_mul_self, one_mul]
rw [← mul_lt_mul_iff_right a, inv_mul_self, one_mul]
rw [inv_mul_self]
rw [inv_mul_self]
rw [← mul_lt_mul_iff_right b, inv_mul_cancel_right]
rw [inv_mul_cancel_right]
rw [← mul_lt_mul_iff_right b, inv_mul_cancel_right, one_mul]
rw [← mul_lt_mul_iff_right b, one_mul, inv_mul_cancel_right]
rw [one_mul]
rw [← mul_le_mul_iff_left a, ← mul_le_mul_iff_right b]
simp
rw [← mul_le_mul_iff_left d, ← mul_le_mul_iff_right b, mul_inv_cancel_left, mul_assoc,
    inv_mul_cancel_right]
simp only [div_eq_mul_inv, mul_le_iff_le_one_right', Left.inv_le_one_iff, iff_self]
simp only [div_eq_mul_inv, le_mul_iff_one_le_right', Left.one_le_inv_iff, iff_self]
rw [← mul_lt_mul_iff_left a, ← mul_lt_mul_iff_right b]
simp
rw [← inv_lt_inv_iff, inv_inv]
rw [← inv_lt_inv_iff, inv_inv]
rw [← mul_lt_mul_iff_left d, ← mul_lt_mul_iff_right b, mul_inv_cancel_left, mul_assoc,
    inv_mul_cancel_right]
simp only [div_eq_mul_inv, mul_lt_iff_lt_one_left', Left.inv_lt_one_iff, iff_self]
rw [inv_mul_le_iff_le_mul, mul_comm]
rw [← inv_mul_le_iff_le_mul, mul_comm]
rw [mul_comm c, mul_inv_le_inv_mul_iff, mul_comm]
rw [inv_mul_lt_iff_lt_mul, mul_comm]
rw [← inv_mul_lt_iff_lt_mul, mul_comm]
rw [mul_comm c, mul_inv_lt_inv_mul_iff, mul_comm]
rw [← mul_le_mul_iff_right b, one_mul, div_eq_mul_inv, inv_mul_cancel_right]
rw [← mul_le_mul_iff_right b, one_mul, div_eq_mul_inv, inv_mul_cancel_right]
rw [← mul_le_mul_iff_right b, div_eq_mul_inv, inv_mul_cancel_right]
rw [← mul_le_mul_iff_right c, div_eq_mul_inv, inv_mul_cancel_right]
rw [le_div_iff_mul_le, mul_comm]
rw [div_le_iff_le_mul, mul_comm]
rw [inv_le_div_iff_le_mul, mul_comm]
rw [div_eq_mul_inv, div_eq_mul_inv, mul_comm b, mul_inv_le_inv_mul_iff, mul_comm]
exact mul_le_mul' hab hcd
rw [← mul_lt_mul_iff_right b, one_mul, div_eq_mul_inv, inv_mul_cancel_right]
rw [← mul_lt_mul_iff_right b, one_mul, div_eq_mul_inv, inv_mul_cancel_right]
rw [← mul_lt_mul_iff_right b, div_eq_mul_inv, inv_mul_cancel_right]
rw [← mul_lt_mul_iff_right c, div_eq_mul_inv, inv_mul_cancel_right]
rw [div_eq_mul_inv, lt_mul_inv_iff_mul_lt, inv_mul_lt_iff_lt_mul]
rw [lt_div_iff_mul_lt, mul_comm]
rw [div_lt_iff_lt_mul, mul_comm]
rw [div_eq_mul_inv, div_eq_mul_inv, mul_comm b, mul_inv_lt_inv_mul_iff, mul_comm]
exact mul_lt_mul_of_lt_of_lt hab hcd
rw [← cmp_mul_right' _ _ b, one_mul, div_mul_cancel']
rw [div_eq_mul_inv, mul_inv_le_inv_mul_iff]
exact
    ⟨fun h => not_lt.mp fun k => not_lt.mpr h (mul_lt_mul_of_lt_of_lt k k), fun h =>
      mul_le_mul' h h⟩
rw [div_eq_mul_inv b, mul_comm]
exact div_le_inv_mul_iff
intros
rfl
simp [C.pos_iff]
simp [C.zero_nonneg]
rw [abs_eq_max_neg, max_comm, neg_neg, abs_eq_max_neg]
rw [← add_right_neg a]
apply add_le_add_left
exact neg_le_abs_self a
rw [abs_of_nonpos ha, abs_of_nonpos (hab.trans ha)]
exact neg_le_neg_iff.mpr hab
rw [neg_lt]
rw [abs_sub_comm]
exact max_sub_min_eq_abs' _ _
rw [abs_le', and_comm, @neg_le α]
rw [le_abs, or_comm, @le_neg α]
rw [sub_eq_add_neg, ← abs_neg b]
exact abs_add a _
rw [abs_le, neg_le_sub_iff_le_add, sub_le_iff_le_add', and_comm, sub_le_iff_le_add']
rw [@abs_lt α, neg_lt_sub_iff_lt_add', sub_lt_iff_lt_add', and_comm, sub_lt_iff_lt_add']
rw [sub_add_cancel]
rw [abs_sub_comm]
apply abs_sub_abs_le_abs_sub
simp [hbc.trans (le_abs_self c)]
simp [((@neg_le_neg_iff α ..).mpr hab).trans (neg_le_abs_self a)]
rw [sub_add_sub_cancel]
simp only [div_eq_mul_inv, min_mul_mul_left, min_inv_inv']
simp only [div_eq_mul_inv, max_mul_mul_left, max_inv_inv']
simp only [sub_le_iff_le_add, max_le_iff]
constructor
calc
    a = a - c + c := (sub_add_cancel a c).symm
    _ ≤ max (a - c) (b - d) + max c d := add_le_add (le_max_left _ _) (le_max_left _ _)
calc
    b = b - d + d := (sub_add_cancel b d).symm
    _ ≤ max (a - c) (b - d) + max c d := add_le_add (le_max_right _ _) (le_max_right _ _)
refine' abs_sub_le_iff.2 ⟨_, _⟩
· exact (max_sub_max_le_max _ _ _ _).trans (max_le_max (le_abs_self _) (le_abs_self _))
· rw [abs_sub_comm a c, abs_sub_comm b d]
    exact (max_sub_max_le_max _ _ _ _).trans (max_le_max (le_abs_self _) (le_abs_self _))
simp [← map_mul]
rw [← map_mul abv, neg_mul_neg, map_mul abv]
rw [← neg_sub, abv.map_neg]
rw [abv.map_sub]
apply abv.le_sub
simp only [zero, one, LinearOrderedCommMonoidWithZero.zero_le_one]
simp [ha]
simp [hb, hc, hd]
    -- Porting note: the Lean 3 proof was `simp [inv_ne_zero hb, hc, hd]`.  This is a non-confluent
    -- simp and we should expect that these sometimes break between Lean 3 and Lean 4.
    -- https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Difference.20in.20simp.20lemma.20priorities.3F
rw [ha, zero_mul, zero_lt_iff]
exact mul_ne_zero hb hd
rw [hc, mul_zero, zero_lt_iff]
exact mul_ne_zero hb hd
rw [mul_comm] at *
exact mul_inv_lt_of_lt_mul₀ h
simp only [mul_comm a]
exact mul_le_mul_right₀ ha
rw [div_eq_mul_inv, div_eq_mul_inv, mul_le_mul_right₀ (inv_ne_zero hc)]
simp only [div_eq_mul_inv, mul_le_mul_left₀ ha, inv_le_inv₀ hb hc, iff_self]
-- Porting note: the simplifier in Lean 3 functioned in such a way that, effectively, `iff_self` was
-- silently added to a `simp only`.  It had to be manually added here.
-- https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/.60simp.60.20.28or.20.60refl.60.3F.29.20difference.20Lean.203.2F4
-- would be resolved
rw [div_eq_mul_inv, le_mul_inv_iff₀ hc]
rw [div_eq_mul_inv, mul_inv_le_iff₀ hc]
simp only [mul_invOf_self, zero_lt_one]
simp only [← not_lt, invOf_pos]
rfl
simp only [mul_invOf_self, zero_lt_one]
simp only [← not_le, invOf_nonneg]
rfl
cases a <;> rfl
cases a <;> cases b <;> simp [none_eq_top, some_eq_coe, ← WithTop.coe_add]
simp [none_eq_top]
simp [none_eq_top]
simp only [some_eq_coe, ← coe_add, coe_eq_coe, exists_and_left, exists_eq_left, iff_self]
induction x using WithTop.recTopCoe <;> simp [← coe_add]
induction y using WithTop.recTopCoe <;> simp [← coe_add]
induction a using WithTop.recTopCoe
· exact (not_none_lt _ h).elim
induction b using WithTop.recTopCoe
· exact (not_none_lt _ h).elim
induction c using WithTop.recTopCoe
· exact coe_lt_top _
· exact coe_lt_coe.2 (lt_of_add_lt_add_left <| coe_lt_coe.1 h)
cases a <;> cases b <;> try exact (not_none_lt _ h).elim
cases c
· exact coe_lt_top _
· exact coe_lt_coe.2 (lt_of_add_lt_add_right <| coe_lt_coe.1 h)
induction a using WithTop.recTopCoe
· contradiction
· induction c using WithTop.recTopCoe
    · exact le_top
    · induction b using WithTop.recTopCoe
      · exact (not_top_le_coe _ h).elim
      · simp only [← coe_add, coe_le_coe] at h ⊢
        exact le_of_add_le_add_left h
induction a using WithTop.recTopCoe
· contradiction
· cases c
    · exact le_top
    · cases b
      · exact (not_top_le_coe _ h).elim
      · exact coe_le_coe.2 (le_of_add_le_add_right <| coe_le_coe.1 h)
induction a using WithTop.recTopCoe
· exact (top_add _).symm
· induction b using WithTop.recTopCoe
    · exact (add_top _).symm
    · rw [map_coe, map_coe, ← coe_add, ← coe_add, ← map_add]
      rfl
refine' WithTop.recTopCoe _ _ <;> try intro
· simp only [top_add, forall_const]
· refine' WithTop.recTopCoe _ _
        · simp only [add_top, top_add, forall_const]
        · intro
          refine' WithTop.recTopCoe _ _
          · simp only [coe_add, add_top]
          · intro
            simp only [← WithTop.coe_add, add_assoc]
refine' WithTop.recTopCoe _ _ <;> try intro
· rw [top_add, add_top]
· refine' WithTop.recTopCoe _ _
        · rw [add_top, top_add]
        · intro
          simp only [← WithTop.coe_add, add_comm]
refine' WithTop.recTopCoe _ _
· simp
· intro
        rw [← WithTop.coe_zero, ← WithTop.coe_add, zero_add]
refine' WithTop.recTopCoe _ _
· simp
· intro
        rw [← WithTop.coe_zero, ← WithTop.coe_add, add_zero]
simp only -- Porting note: Had to add this...?
rw [Nat.cast_zero, WithTop.coe_zero]
simp only -- Porting note: Had to add this...?
rw [Nat.cast_add_one, WithTop.coe_add, WithTop.coe_one]
simp
rw [WithTop.map_one, map_one, coe_one]
cases a <;> rfl
rw [WithBot.map_one, map_one, coe_one]
rw [← one_add_one_eq_two]
exact add_nonneg zero_le_one zero_le_one
rw [← two_add_one_eq_three]
exact add_nonneg zero_le_two zero_le_one
rw [← three_add_one_eq_four]
exact add_nonneg zero_le_three zero_le_one
rw [← two_add_one_eq_three]
exact lt_add_of_lt_of_nonneg zero_lt_two zero_le_one
rw [← three_add_one_eq_four]
exact lt_add_of_lt_of_nonneg zero_lt_three zero_le_one
rw [← one_add_one_eq_two]
exact lt_add_one _
rw [mul, mul]
apply mul_le_mul_left'
exact ab
induction a using WithZero.cases_on
· exact bot_le
induction b using WithZero.cases_on
· exact le_rfl
· exact WithZero.coe_le_coe.2 le_self_add
rw [mul_comm]
exact le_self_mul
simp only [mul_comm _ a, le_iff_exists_mul]
rfl
simp only [one_lt_iff_ne_one, Ne.def, mul_eq_one_iff, not_and_or]
rfl -- Porting note: Should this be needed? It wasn't needed in lean3
simp
simp
rw [mul_one]
rw [one_mul]
rw [mul_one]
rw [one_mul]
rw [mul_one]
rw [one_mul]
rw [mul_one]
rw [one_mul]
rw [ha', hb', mul_one]
rw [mul_comm b, mul_comm c, ha.mul_le_mul_iff_left]
rw [mul_one]
rw [mul_one]
rw [mul_comm, ha.le_mul_iff_one_le_right]
rw [mul_comm, ha.mul_le_iff_le_one_right]
rw [mul_comm]
exact mod_add_div _ _
rw [mul_comm]
exact div_add_mod _ _
rw [div_add_mod]
rw [mul_comm]
exact mul_left_not_lt b h
change P a b
exact a0.symm ▸ H0 b
rw [gcd]
exact if_pos rfl
unfold xgcdAux
exact if_pos rfl
conv =>
    lhs
    rw [xgcdAux]
exact if_neg h
unfold gcdA
rw [xgcd, xgcd_zero_left]
unfold gcdB
rw [xgcd, xgcd_zero_left]
have := mul_left_not_lt a h
rw [mul_sub, sub_eq_iff_eq_add'.2 (div_add_mod (a * b) a).symm] at this
exact this (mod_lt _ a0)
rw [mul_comm]
exact mul_div_cancel_left a b0
rw [← div_add_mod a b, h, add_zero]
exact dvd_mul_right _ _
rw [dvd_add_iff_right (h.mul_right _), div_add_mod]
rw [← h, mul_div_cancel _ hb]
rw [← h, mul_div_cancel_left _ ha]
rw [gcd_zero_left]
exact ⟨dvd_zero _, dvd_rfl⟩
rw [gcd_val]
exact ⟨IH₂, (dvd_mod_iff IH₂).1 IH₁⟩
rw [gcd_val]
exact IH ((dvd_mod_iff ca).2 cb) ca
rw [← h]
apply gcd_dvd_right
rw [gcd_val, mod_eq_zero.2 h, gcd_zero_left]
intros
rw [xgcd_zero_left, gcd_zero_left]
simp only [xgcdAux_rec h, if_neg h, IH]
rw [← gcd_val]
rw [xgcd, ← xgcdAux_fst x y 1 0 0 1, Prod.mk.eta]
dsimp [P]
rw [mul_one, mul_zero, add_zero]
dsimp [P]
rw [mul_one, mul_zero, zero_add]
rw [← mul_div_cancel a h0.2, h, zero_div]
rw [lcm, hxy, div_zero]
exact dvd_zero _
rw [mul_right_comm, mul_assoc, ← hz]
rw [lcm, hxy, div_zero]
exact dvd_zero _
rw [← mul_assoc, mul_right_comm, ← hz]
rw [lcm]
rw [lcm, zero_mul, zero_div]
rw [lcm, mul_zero, zero_div]
constructor
· intro hxy
    rw [lcm, mul_div_assoc _ (gcd_dvd_right _ _), mul_eq_zero] at hxy
    apply Or.imp_right _ hxy
    intro hy
rw [lcm]
apply c.next_eq _ h
rw [next]
rw [dif_pos]
exact Exists.choose_spec ⟨j, h⟩
apply c.prev_eq _ h
rw [prev, dif_pos]
exact Exists.choose_spec (⟨i, h⟩ : ∃ k, c.Rel k j)
rw [← sub_eq_add_neg, h, add_neg_self]

-- Porting note:
-- This theorem was introduced during ad-hoc porting
-- and hopefully can be removed again after `Mathlib.Algebra.Ring.Basic` is fully ported.
intros a b c ha h
rw [mul_comm, mul_comm c] at h
exact IsLeftCancelMulZero.mul_left_cancel_of_ne_zero ha h
intros a b c ha h
rw [mul_comm a, mul_comm a c] at h
exact IsRightCancelMulZero.mul_right_cancel_of_ne_zero ha h
rw [one_mul]
rw [h, zero_mul]
rw [h, zero_mul]
rw [one_mul]
rw [zero, one]
exact zero_ne_one
rw [eq_comm, mul_eq_zero]
simp
simp
simp only [SemiconjBy, mul_zero, zero_mul]
simp only [SemiconjBy, mul_zero, zero_mul]
simp only [ha, inv_zero, SemiconjBy.zero_left]
rw [div_eq_mul_inv, div_eq_mul_inv]
exact h.mul_right h'.inv_right₀
simp
simp
rw [mul_assoc, mul_right_inj' ha]
rw [mul_right_comm, mul_left_inj' hc]
simp [hx0] at hyx
rw [hd, mul_assoc, ← he, mul_one]
conv =>
            lhs
            rw [he, hdx]
            simp [mul_assoc]
rw [div_eq_mul_inv]
exact hac.mul_left hbc.inv_left₀
rw [ha, zero_mul]
rw [h ha, mul_zero]
rw [← mul_one a, ← h, mul_zero]
rw [mul_one]
rw [one_mul]
simp [h]
simp [h]


-- Porting note: used `simpa` to prove `False` in lean3
have := mul_inv_cancel h
simp [a_eq_0] at this
simp [inv_ne_zero h]
simp [h]
simp [inv_ne_zero h]
simp [h]
simp [h]
rw [← inv_mul_cancel_left₀ (left_ne_zero_of_mul_eq_one h) b, h, mul_one]

-- See note [lower instance priority]
rw [div_eq_mul_inv, zero_mul]
rw [div_eq_mul_inv, inv_zero, mul_zero]
rw [div_eq_mul_inv, mul_self_mul_inv a]
rw [div_eq_mul_inv, mul_inv_mul_self a]
simp [mul_inv_rev]
rw [inv_eq_iff_inv_eq, inv_zero, eq_comm]
rw [div_div_eq_mul_div]
exact mul_self_div_self a
rw [ha, div_zero] at h
contradiction
simp [← mul_assoc, mul_inv_cancel h]
simp [mul_assoc, inv_mul_cancel h]
simp only [Units.isUnit, inverse, dif_pos]
exact Units.inv_unique rfl
rw [mul_assoc, mul_inverse_cancel x h, mul_one]
rw [mul_assoc, inverse_mul_cancel x h, mul_one]
rw [← mul_assoc, mul_inverse_cancel x h, one_mul]
rw [← mul_assoc, inverse_mul_cancel x h, one_mul]
rw [← h1, mul_inverse_cancel_left _ _ h]
rw [h1, inverse_mul_cancel_left _ _ h]
rw [h1, inverse_mul_cancel_right _ _ h]
rw [← h1, mul_inverse_cancel_right _ _ h]
injection h
simp [exists0]
rw [← inv_mul_cancel_left₀ hx y, h, inv_mul_cancel_left₀ hx z]
rw [← mul_inv_cancel_right₀ hy x, h, mul_inv_cancel_right₀ hy z]
rw [div_eq_mul_inv]
exact mul_ne_zero ha (inv_ne_zero hb)
simp [div_eq_mul_inv]
rw [div_div_eq_mul_div, div_mul_cancel _ hc]
rw [← mul_div_assoc, div_mul_cancel _ hc]
simp [*]
simp [*]
rw [mul_comm, mul_div_cancel_of_imp h]
rw [mul_comm, div_mul_cancel_of_imp h]
rw [← mul_one a, ← div_self hb, ← mul_comm_div, h, div_mul_eq_mul_div, div_mul_cancel _ hd]
rw [div_mul_eq_mul_div, one_mul, div_mul_right _ h]
simp only [mul, zero, zero_mul]
simp only [mul, zero, mul_zero]
simp only [← zero, ← mul, mul_zero]
simp only [← zero, ← mul, zero_mul]
rw [← mul, H, zero]
erw [← mul, ← mul, H]
erw [← mul, ← mul, H]
erw [inv, zero, inv_zero]
erw [one, mul, inv, mul_inv_cancel ((hf.ne_iff' zero).2 hx)]
erw [← zero, ← inv, inv_zero]
erw [← inv, ← mul, mul_inv_cancel (mt (congr_arg f) <| fun h ↦ hx (h.trans zero)), one]
rw [mul_comm] at h
apply h
rw [mul_comm]
exact h.mul_right _
simp
simp [ceq]
rw [pow_zero, pow_zero]
rw [pow_succ, pow_succ]
exact mul_dvd_mul h (pow_dvd_pow_of_dvd h n)
simp
rw [← mul_assoc, ← Eq, Units.mul_inv_cancel_right]
rw [mul_assoc, u.mul_inv, mul_one]
rw [mul_comm]
apply dvd_mul_right
rw [mul_comm]
apply mul_right_dvd
rw [h, mul_comm]
simp [flip, functor_norm]
funext α x
apply H1
funext α β f x
exact H2 f (x Unit.unit)
apply Functor.ext
intros
exact (pure_seq1 _ _).symm.trans (pure_seq2 _ _)
refine' { .. } <;> intros <;> rfl
simp
simp [(· ∘ ·), functor_norm]
simp [(· ∘ ·), functor_norm]
simp [Applicative.pure_seq_eq_map', functor_norm]
intros
rfl
intros
rfl
rw [id_map]
refine' { @instLawfulApplicativeCompInstApplicativeComp f g _ _ _ _ with .. }
intros
simp! [map, Seq.seq, functor_norm]
rw [commutative_map]
simp [Comp.mk, flip, (· ∘ ·), functor_norm]
congr
funext x y
rw [commutative_map]
congr
refine' { .. } <;> intros <;> simp [mul_assoc, (· <$> ·), Seq.seq, pure] <;> rfl
refine' { .. } <;> intros <;> simp [add_assoc, (· <$> ·), Seq.seq, pure] <;> rfl
simp [← pure_seq]
simp [seq_assoc, ← comp_map, (· ∘ ·)]
simp [pure_seq]
simp only [← pure_seq]
simp [seq_assoc]
rw [← bind_pure_comp, bind_assoc] <;> simp [bind_pure_comp]
rw [← bind_pure_comp, bind_assoc] <;> simp [pure_bind, (· ∘ ·)]
simp only [(· >=> ·), functor_norm]
simp only [(· >=> ·), functor_norm]
simp only [(· >=> ·), functor_norm]
simp only [joinM, (· ∘ ·), id.def, ← bind_pure_comp, bind_assoc, map_bind, pure_bind]
simp only [joinM, (· ∘ ·), id.def, map_bind, ← bind_pure_comp, bind_assoc, pure_bind]
simp only [joinM, (· ∘ ·), id.def, map_bind, ← bind_pure_comp, bind_assoc, pure_bind, bind_pure]
simp [guard, if_pos]
simp [guard, if_neg not_false]
intros
rfl
intros
rfl
simp [seq_map_assoc, map_seq, seq_assoc, seq_pure, map_map] <;> rfl
rw [@CommApplicative.commutative_prod m h] <;>
        simp [seq_map_assoc, map_seq, seq_assoc, seq_pure, map_map, (· ∘ ·)]
apply funext <;> apply id_map
funext α β f x
apply H
    congr
    funext α β
constructor <;> intros <;> rfl
simp [Comp.map, Functor.map_id]
rfl
  -- porting note: `rfl` wasn't needed in mathlib3
simp [Comp.map, Comp.mk, Functor.map_comp_map, functor_norm]
  -- porting note: `Comp.mk` wasn't needed in mathlib3
cases η
cases η'
congr
rw [← pure_seq, η.preserves_seq]
simp [functor_norm]
simp
simp
simp [functor_norm]
simp [functor_norm]
refine' { .. } <;> intros <;> rfl
simp only [map_pure, seq_pure]
rfl
rw [map_eq_traverse_id f]
refine' (comp_traverse (pure ∘ f) g x).symm.trans _
congr
apply Comp.applicative_comp_id
rw [@map_eq_traverse_id t _ _ _ _ g]
refine' (comp_traverse (G := Id) f (pure ∘ g) x).symm.trans _
congr
apply Comp.applicative_id_comp
simp [sequence, traverse_map, id_traverse]
simp [sequence, traverse_map]
rw [← comp_traverse]
simp [map_id]
simp [sequence, naturality, traverse_map]
rfl
rfl
simp [EquivFunctor.mapEquiv]
rfl
simp [mapEquiv, map_trans']
rw [w]
simp [h.symm, term, add_comm, add_assoc]
simp [h.symm, termg, add_comm, add_assoc]
simp [h.symm, term, add_assoc]
simp [h.symm, termg, add_assoc]
simp [h₁.symm, h₂.symm, term, add_nsmul, add_assoc, add_left_comm]
simp [term, zero_nsmul, one_nsmul]
sorry
simp [h₂.symm, h₁.symm, termg]
sorry
simp [smul, nsmul_zero]
simp [smulg, zsmul_zero]
simp [h₂.symm, h₁.symm, term, smul, nsmul_add, mul_nsmul']
sorry
simp [term]
simp [termg]
rw [sub_eq_add_neg, h]
simp [prl, prr, prt]
simp [prl, prr, prt]
simp [← prt, prl₁, ← prl₂, prr, smul, smulg, coe_nat_zsmul]
rw [prl, prr, prt]
rw [prl, prr, prt]
simp [pra, prt]
cases h with
  | inl hp => exact Or.inr hp
  | inr hq => exact Or.inl hq
simp [frobnicate_def]
intros
simp only [$n:ident]
rw [wrapped.prop]
subst_vars
simp [mul_add]
simp [h, ← mul_add]
simp
simp
subst_vars
simp [add_assoc, add_left_comm]
subst_vars
rw [add_add_add_comm, h.1, Nat.cast_zero, add_pf_zero_add]
simp [*, add_assoc]
subst_vars
simp [add_left_comm]
simp [Nat.rawCast]
simp [Nat.rawCast]
subst_vars
rw [mul_assoc]
subst_vars
rw [mul_left_comm]
subst_vars
simp [pow_add, mul_mul_mul_comm]
simp
subst_vars
simp [_root_.mul_add]
simp
subst_vars
simp [_root_.add_mul]
simp
subst_vars
simp
subst_vars
simp
subst_vars
simp
subst_vars
simp
subst_vars
simp [Int.negOfNat]
subst_vars
simp
simp
subst_vars
simp [add_comm]
subst_vars
simp [sub_eq_add_neg]
simp
simp
simp
subst_vars
simp [Nat.succ_mul, pow_add]
subst_vars
simp [Nat.succ_mul, pow_add]
simp
subst_vars
simp [_root_.mul_pow, pow_mul]
simp
subst_vars
rw [mul_assoc]
simp
simp [pow_succ]
simp [*]
subst_vars
simp [pow_mul]
simp
subst_vars
simp [_root_.pow_add]
simp [e]
simp [e]
simp [e]
simp
simp [*]
subst_vars
rfl
subst_vars
rfl
subst_vars
rfl
subst_vars
rfl
subst_vars
rfl
subst_vars
rfl
subst_vars
rfl
simp
simp
simp
simp [Int.negOfNat_eq]
simp [Int.negOfNat_eq, OfNat.ofNat]
induction ps generalizing as₁ with
  | nil => exact fun _ ↦ id
  | cons a as ih =>
    refine fun e H ↦ @ih (a::as₁) e (H ?_)
    subst e; clear ih H
    suffices ∀ n n', n' = List.length as₁ + n →
      ∀ bs, mk (as₁.reverseAux bs) n' ↔ mk bs n from this 0 _ rfl (a::as)
    induction as₁ with simp
    | cons b as₁ ih => exact fun n bs ↦ ih (n+1) _ (Nat.succ_add ..) _
simp only [ne_eq, Int.cast_eq_cast_iff_Nat, iff_self]
exact h -- succeeds
simp
simp
simp
simp
simp
simp [Int.negOfNat_eq, Int.cast_neg]
assumption
assumption
assumption
assumption
with_reducible assumption
with_reducible assumption
with_reducible assumption
cases that
have := ofNat_pos.2 <| Nat.le_of_ble_eq_true hn
have nonneg := emod_nonneg a <| Int.ne_of_gt this
refine ⟨Nat.zero_le _, ?_, ?_⟩
· rw [Int.toNat_lt nonneg]; exact Int.emod_lt_of_pos _ this
· rw [Int.modeq, Int.toNat_of_nonneg nonneg, emod_emod]
simp [*]
simp [*]
simp [*]
simp [*]
simp [*]
simp [*]
simp [h]

-- used in the `nlinarith` normalization steps. The `_` argument is for uniformity.
simp [h]
cases F
rfl
cases F
rfl
rw [h]
rw [Functor.comp_map, Functor.comp_map, ← assoc, naturality, assoc, ← map_comp I, naturality,
      map_comp, assoc]
simp
simp
simp [← NatTrans.comp_app, ← Functor.map_comp]
simp [← NatTrans.comp_app, ← Functor.map_comp]
rw [← comp_app, Iso.hom_inv_id]
rfl
rw [← comp_app, Iso.inv_hom_id]
rfl
rw [← comp_app, Iso.hom_inv_id, ← id_app]
rw [← comp_app, Iso.inv_hom_id, ← id_app]
rw [← comp_app, Iso.inv_hom_id, ← id_app]
rw [← comp_app, Iso.hom_inv_id, ← id_app]
simp only [cancel_epi, refl]
simp only [cancel_epi, refl]
simp only [cancel_mono, refl]
simp only [cancel_mono, refl]
simp only [← Category.assoc, cancel_mono, refl]
simp only [← Category.assoc, cancel_mono, refl]
simp
simp
simp
rw [← Category.assoc, ← naturality, Category.assoc, IsIso.hom_inv_id, Category.comp_id]
apply IsIso.eq_inv_of_hom_inv_id
rw [← NatTrans.comp_app]
simp
exact fun F₁ F₂ e => ⟨this e, this e.symm⟩
infer_instance
simp
cases α
cases β
cases w
cases this
rfl
rw [Iso.hom_inv_id, Category.comp_id]
rw [Category.assoc, ← w]
rw [Iso.inv_hom_id, Category.id_comp]
cases α
rfl
rw [← trans_assoc, symm_self_id, refl_trans]
rw [← trans_assoc, self_symm_id, refl_trans]
simp [H.symm]
simp [H]
simp [H.symm]
simp [H]
rw [ext h]
rw [← eq_inv_comp, comp_id]
rw [← eq_comp_inv, id_comp]
erw [inv_eq_inv α.symm β, eq_comm]
rfl
simp [← Category.assoc]
simp [← Category.assoc]
rw [← IsIso.inv_hom_id_assoc f g, w, IsIso.inv_hom_id_assoc f h]
rw [← Category.comp_id g, ← Category.comp_id h, ← IsIso.hom_inv_id f,
      ← Category.assoc, w, ← Category.assoc]
apply (cancel_epi f).mp
simp [hom_inv_id]
apply (cancel_mono f).mp
simp [inv_hom_id]
simp
simp
apply inv_eq_of_hom_inv_id
simp
apply inv_eq_of_hom_inv_id
simp
apply inv_eq_of_hom_inv_id
simp
apply inv_eq_of_hom_inv_id
simp
apply inv_eq_of_hom_inv_id
simp
rw [← id_comp g, ← inv_hom_id f, assoc]
infer_instance
rw [← comp_id f, ← hom_inv_id g, ← assoc]
infer_instance
apply (cancel_epi (inv f)).1
erw [inv_hom_id, p, inv_hom_id]
rw [(hom_comp_eq_id _).mp h]
infer_instance
rw [(comp_hom_eq_id _).mp h]
infer_instance
simp only [cancel_epi]
rfl
simp only [cancel_epi]
rfl
simp only [cancel_mono]
rfl
simp only [cancel_mono]
rfl
simp only [← Category.assoc, cancel_mono]
rfl
simp only [← Category.assoc, cancel_mono]
rfl
rw [← map_comp, Iso.hom_inv_id, ← map_id]
rw [← map_comp, Iso.inv_hom_id, ← map_id]
apply eq_inv_of_hom_inv_id
simp [← F.map_comp]
simp
simp
simp
simp
rw [w]
rw [w]
subst h
exact mono_of_mono f g
subst h
exact epi_of_epi f g
infer_instance
unfold RelCat
infer_instance
subst h
subst h'
rw [heq_iff_eq, heq_iff_eq, ext_iff]
simp only [@eq_comm _ b, exists_eq_subtype_mk_iff, @eq_comm _ _ a, iff_self]
rfl
apply congr_arg Subtype.val hxy
decide
rw [if_pos (succ_pos m)]
rfl
dsimp [mod, modDiv]
cases (m : ℕ) % (k : ℕ) with
  | zero =>
    rw [if_pos rfl]
    rfl

  | succ n =>
    rw [if_neg n.succ_ne_zero]
    rfl
dsimp [div, modDiv]
cases (m : ℕ) % (k : ℕ) with
  | zero =>
    rw [if_pos rfl]
    rfl

  | succ n =>
    rw [if_neg n.succ_ne_zero]
    rfl
rw [coe_coe, Nat.toPNat'_coe, if_pos (Int.nat_abs_pos_of_ne_zero hn.ne'),
        Int.nat_abs_of_nonneg hn.le]
dsimp [LT.lt]
infer_instance
dsimp [LE.le]
infer_instance
dsimp [LT.lt]
infer_instance
dsimp [LE.le]
infer_instance
(exact Nat.div_lt_self (Nat.succ_pos n) (Nat.le_refl 2))
dsimp [LT.lt]
infer_instance
dsimp [LE.le]
infer_instance
simp [map_map]
simp [map_map]
simp [gcd_rec m (n + k * m), gcd_rec m n]
simp [gcd_rec m (n + m * k), gcd_rec m n]
simp [add_comm _ n]
simp [add_comm _ n]
rw [gcd_comm, gcd_add_mul_right_right, gcd_comm]
rw [gcd_comm, gcd_add_mul_left_right, gcd_comm]
rw [gcd_comm, gcd_mul_right_add_right, gcd_comm]
rw [gcd_comm, gcd_mul_left_add_right, gcd_comm]
rw [one_mul]
rw [gcd_comm, gcd_add_self_right, gcd_comm]
rw [add_comm, gcd_add_self_left]
rw [add_comm, gcd_add_self_right]
unfold coprime
infer_instance
rw [← one_mul (lcm m n), ← h.gcd_eq_one, gcd_mul_lcm]
rw [coprime, coprime, gcd_add_self_right]
rw [add_comm, coprime_add_self_right]
rw [coprime, coprime, gcd_add_self_left]
rw [coprime, coprime, gcd_self_add_left]
rw [coprime, coprime, gcd_add_mul_right_right]
rw [coprime, coprime, gcd_add_mul_left_right]
rw [coprime, coprime, gcd_mul_right_add_right]
rw [coprime, coprime, gcd_mul_left_add_right]
rw [coprime, coprime, gcd_add_mul_right_left]
rw [coprime, coprime, gcd_add_mul_left_left]
rw [coprime, coprime, gcd_mul_right_add_left]
rw [coprime, coprime, gcd_mul_left_add_left]
rw [Nat.coprime_comm, coprime_pow_left_iff hn, Nat.coprime_comm]
simp
simp [coprime]
simp [coprime]
rw [coprime_iff_gcd_eq_one] at h_ab_coprime
have h1 := dvd_gcd hka hkb
rw [h_ab_coprime] at h1
exact Nat.dvd_one.mp h1
intros
rfl
intros
rfl
rw [cast_succ, Nat.cast_zero, zero_add]
induction n <;> simp [add_succ, add_assoc, Nat.add_zero, Nat.cast_one, Nat.cast_zero, *]
(exact Nat.div_lt_self (Nat.succ_pos n) (Nat.le_refl 2))
apply Nat.strongInductionOn n
intros k hk
cases k with
  | zero => rw [Nat.binCast, Nat.cast_zero]
  | succ k =>
      rw [Nat.binCast]
rw [bit1, cast_add_one, cast_bit0]
rfl
simp only [Nat.binCast, Nat.cast]
rw [←Nat.cast_one, ←Nat.cast_add]
apply congrArg
decide
rw [←one_add_one_eq_two, ←Nat.cast_one, ←Nat.cast_add, ←Nat.cast_add]
apply congrArg
decide
rw [←two_add_one_eq_three, ←one_add_one_eq_two, ←Nat.cast_one,
    ←Nat.cast_add, ←Nat.cast_add, ←Nat.cast_add]
apply congrArg
decide
induction n <;> simp [mul_succ, mul_add, *]
induction n with
  | zero => rw [Nat.cast_zero]; exact Commute.zero_left x
  | succ n ihn => rw [Nat.cast_succ]; exact ihn.add_left (Commute.one_left x)
rw [Nat.cast_succ]
exact le_add_of_nonneg_right zero_le_one
cases n <;> simp [cast_add_one_pos]
rw [← cast_one, cast_lt]
rw [← cast_one, cast_le]
rw [← cast_one, cast_lt, lt_succ_iff, ← bot_eq_zero, le_bot_iff]
rw [← cast_one, cast_le]
simp [map_zero f]
rw [map_add, h1, eq_natCast' f h1 n, Nat.cast_add_one]
simp [map_zero f]
rw [Nat.cast_add, map_add, Nat.cast_add, map_natCast' f h n, Nat.cast_one, h, Nat.cast_one]
simp only [map_one f, map_one g]
simp only [map_natCast, hn]
simp
simp
simp [add_assoc]
simp [natCast]
simp [natCast]
dsimp only
rw [Nat.add_comm, Nat.right_distrib, Nat.one_mul]
rw [succ_le_iff]
simp only [add_comm, lt_succ_iff]
rfl
simp only [add_comm, add_one_le_iff]
rfl
rw [← lt_succ_iff, div_lt_iff_lt_mul n0, succ_mul, mul_comm]
cases n
· cases n0
exact lt_succ_iff
decide
simp only [lt_succ_iff, Decidable.le_iff_eq_or_lt, forall_eq_or_imp, and_comm]
rfl
simp
simp
simp [hk, add_comm, add_left_comm]
rfl
simp
simp [hk]
rw [add_succ, succ_sub_one]
rw [succ_add, succ_sub_one]
simp [H]
rw [← Nat.sub_one, Nat.sub_sub, one_add, sub_succ]
rw [add_comm, add_one, Nat.pred_succ]
rw [add_comm, add_mul_mod_self_left, mul_mod_right, mod_eq_of_lt] <;> simp
rw [mul_comm, Nat.mul_right_eq_self_iff hb]
cases n <;> unfold leRecOn Eq.recOn
· simp
· unfold Or
rw [leRecOn_succ (le_refl n), leRecOn_self]
rw [Subsingleton.elim h1 (le_trans (le_succ n) h2), leRecOn_trans (le_succ n) h2, leRecOn_succ']
simp only [strongRecOn']
rw [Nat.strongRec']
apply Nat.le.rec
· exact h0
· intros n hn
    apply h1 n hn
dsimp only [decreasingInduction]
rw [leRecOn_self]
dsimp only [decreasingInduction]
rw [leRecOn_succ]
dsimp only [decreasingInduction]
rw [leRecOn_succ']
rw [Subsingleton.elim mn (le_trans (le_succ m) smn), decreasingInduction_trans,
    decreasingInduction_succ']
apply Nat.le_succ
revert h hP
refine' leRecOn' mn _ _
· intro n mn ih h hP
    apply ih
    · exact fun k hk => h k (Nat.lt.step hk)
    · exact h n (lt_succ_self n) mn hP
· intro _ hP
    exact hP
rw [le_div_iff_mul_le hb, one_mul]
simp [k0]
simp [hc0]
rw [mul_assoc]
exact Nat.mul_le_mul_left _ (Nat.div_mul_le_self _ _)
rw [← H2, Nat.mul_div_cancel' H1]
rw [mul_comm]
exact Nat.div_eq_iff_eq_mul_right H H'
rw [mul_comm, Nat.eq_mul_of_div_eq_right H1 H2]
rw [mul_comm, Nat.div_mul_cancel Hd]
rw [mul_comm, mul_comm b, a.mul_div_mul_left b hc]
rw [← Nat.succ_mul, ← Nat.div_lt_iff_lt_mul hb]
exact Nat.lt_succ_self _
refine ⟨fun h => ?_, congr_arg fun n => n / d⟩
rw [← Nat.mul_div_cancel' hda, ← Nat.mul_div_cancel' hdb, h]
cases b
contradiction
exact ⟨fun h => h.ge.trans_lt (mod_lt _ (succ_pos _)), mod_eq_of_lt⟩
rw [mul_comm]
exact mod_add_div _ _
rw [mul_comm]
exact div_add_mod _ _
rw [add_mul_div_left _ _ h, add_mul_mod_self_left]
simp [div_eq_of_lt, mod_eq_of_lt, h₂]
rw [mul_assoc, mul_right_inj' ha.ne']
rw [mul_right_comm, mul_left_inj' hc.ne']
rw [← mod_add_mod, ← mod_add_mod k, H]
rw [add_comm, add_mod_eq_add_mod_right _ H, add_comm]
rw [← Nat.div_mul_cancel w, h, one_mul]
rw [← Nat.div_mul_cancel w, h, zero_mul]
rw [mul_comm, ← Nat.div_lt_iff_lt_mul' n0]
exact lt_succ_self _
simp [Nat.add_mod]
rw [Nat.mul_add_mod, Nat.mod_eq_of_lt h]
cases n <;> simp [(Nat.succ_ne_self _).symm]
simp only [exists_prop, ← lt_succ_iff, find_lt_iff]
rfl
simp only [← succ_le_iff, le_find_iff, succ_le_succ_iff]
rfl
simp [find_eq_iff]
simp [Nat.findGreatest, h]
simp [Nat.findGreatest, h]
cases h
simp
simp only [lt_succ_iff_lt_or_eq, or_and_right, exists_or, exists_eq_left]
apply Iff.refl
cases n <;> rfl
rw [sub_eq_psub m n, psub]
cases psub m n <;> rfl
constructor <;> intro h <;> contradiction
constructor <;> intro h <;> injection h <;> subst m <;> rfl
simp
constructor <;> intro <;> contradiction
simp [eq_comm]
apply Option.bind_eq_some.trans
simp only [psub_eq_some, ppred_eq_some]
simp [add_comm, add_left_comm, Nat.succ_eq_add_one]
induction k
simp [Option.bind_eq_bind, Option.bind_some]
simp [*, Nat.add_succ]
decide
decide
simp
rw [eq_comm, Nat.mul_eq_zero]
simp
simp
simp
rw [add_comm]
exact add_pos_left h m
cases n <;> simp [succ_eq_add_one, ← add_assoc, succ_inj']
cases n <;>
  simp [(succ_ne_zero 1).symm, (show 2 = Nat.succ 1 from rfl),
    succ_eq_add_one, ← add_assoc, succ_inj', add_eq_one_iff]
cases n <;>
  simp [(succ_ne_zero 1).symm, succ_eq_add_one, (show 3 = Nat.succ 2 from rfl),
    ← add_assoc, succ_inj', add_eq_two_iff]
rw [add_assoc]
exact add_lt_add_of_lt_of_le hab (Nat.succ_le_iff.2 hcd)
cases m
· exact fun _ => zero_le n
exact le_of_succ_le_succ
decide
decide
decide
simp
simp
simp only [succ_mul, mul_succ, add_succ, one_mul, mul_one, (add_assoc _ _ _).symm,
          ← succ_eq_add_one, add_eq_zero_iff, (show 1 = succ 0 from rfl), succ_inj'] at h
simp [h]
simp only [h, mul_one]
simp
conv =>
    lhs
    rw [← one_mul m]
exact mul_le_mul_of_nonneg_right h.nat_succ_le (zero_le _)
conv =>
    lhs
    rw [← mul_one m]
exact mul_le_mul_of_nonneg_left h.nat_succ_le (zero_le _)
refine le_trans ?_ add_tsub_le_assoc
simp [add_comm, Nat.add_sub_assoc, one_le_iff_ne_zero.2 hi]
simp
simp
assumption
rw [k0, Nat.div_zero]
apply zero_le
rw [n0, Nat.div_zero]
apply zero_le
decide
simp [hm0]
rw [mul_comm]
exact mul_div_le_mul_div_assoc _ _ _
rw [Nat.div_div_eq_div_mul, mul_comm n, mul_comm k,
            Nat.mul_div_mul _ _ (Nat.pos_of_ne_zero hm0)]
conv =>
    rhs
    rw [← Nat.mod_add_div n 2, hn, add_tsub_cancel_left]
rw [mul_comm k, mod_mul_right_div_self]
rw [← Nat.mod_add_div m k, ← Nat.mod_add_div n k, ← h, tsub_add_eq_tsub_tsub,
    add_tsub_cancel_left, ← mul_tsub k, Nat.mul_mod_right]
simp [hn]
simp [hl]
simp
decide
rw [tsub_eq_iff_eq_add_of_le (Nat.mod_le _ _), add_comm, mod_add_div]
rw [pos_iff_ne_zero, Ne, Nat.find_eq_zero]
simp [findGreatest_eq_iff]
constructor
· intro h
    rw [← mul_right_inj' hn]
    apply Nat.eq_mul_of_div_eq_left (dvd_mul_of_dvd_left hy x)
    rw [eq_comm, mul_comm, Nat.mul_div_assoc _ hy]
    exact Nat.eq_mul_of_div_eq_right hx h
· intro h
    rw [h]
rw [← mod_add_div a b, h, mul_zero, add_zero]
exact mod_lt _ hb
rw [← mul_right_inj' hb.ne', ← @add_left_cancel_iff _ _ _ (a % b), mod_add_div, mod_eq_of_lt h,
      mul_zero, add_zero]
rw [bit1, Nat.dvd_add_right two_dvd_bit0, Nat.dvd_one]
  -- Porting note: was `cc`
decide
simp
simp
simp
rw [Nat.dvd_add_iff_left (dvd_refl (b + 1)), ← add_tsub_add_eq_tsub_right a 1 b,
          add_comm (_ - _), add_assoc, tsub_add_cancel_of_le (succ_le_succ hb_le_a), add_comm 1]
rw [succ_div, if_pos hba]
rw [succ_div, if_neg hba, add_zero]
simp [ha]
simp
simp at dvd
simp [k2_zero] at pr
cases n
· exact (m % 0).div_zero
· case succ n => exact Nat.div_eq_zero (m.mod_lt n.succ_pos)
refine'
    ⟨fun ⟨k, hk1, hk2⟩ => not_dvd_of_between_consec_multiples hk1 hk2, fun han =>
      ⟨n / a, ⟨lt_of_le_of_ne (mul_div_le n a) _, lt_mul_div_succ _ ha⟩⟩⟩
exact mt (Dvd.intro (n / a)) han
rw [h]
rw [h]
rw [Nat.lt_div_iff_mul_lt hdb]
exact lt_of_le_of_lt (mul_div_le a d) h
rw [← image_singleton, range_comp, ← image_union, zero_union_range_succ, image_univ]
simp
let ⟨ b , Hb ⟩ := Hbdd
let ⟨ lb , H ⟩ := leastOfBdd b Hb Hinh
exact ⟨ lb , H ⟩
rw [neg_neg]
exact Helt
let ⟨ b , Hb ⟩ := Hbdd
let ⟨ lb , H ⟩ := greatestOfBdd b Hb Hinh
exact ⟨ lb , H ⟩
intros
rfl
intros
rfl
rw [← cast_add, Nat.sub_add_cancel h]
cases h
rw [cast_succ, add_sub_cancel]
rfl
erw [cast_ofNat, Nat.cast_one]
erw [cast_zero, neg_zero]
erw [cast_ofNat, cast_negSucc]
erw [cast_ofNat, cast_negSucc, neg_neg]
unfold subNatNat
cases e : n - m
· simp only [ofNat_eq_coe]
    simp [e, Nat.le_of_sub_eq_zero e]
· rw [cast_negSucc, Nat.add_one, ← e, Nat.cast_sub <| _root_.le_of_lt <| Nat.lt_of_sub_eq_succ e,
      neg_sub]
simp [Int.cast_neg, negOfNat_eq]
simp [← Int.ofNat_add, Nat.cast_add]
erw [cast_subNatNat, cast_ofNat, cast_negSucc, sub_eq_add_neg]
erw [cast_subNatNat, cast_ofNat, cast_negSucc, sub_eq_iff_eq_add, add_assoc,
      eq_neg_add_iff_add_eq, ← Nat.cast_add, ← Nat.cast_add, Nat.add_comm]
rw [cast_negSucc, cast_negSucc, cast_negSucc, ← neg_add_rev, ← Nat.cast_add,
        Nat.add_right_comm m n 1, Nat.add_assoc, Nat.add_comm]
simp [Int.sub_eq_add_neg, sub_eq_add_neg, Int.cast_neg, Int.cast_add]
rw [bit1, Int.cast_add, Int.cast_one, cast_bit0]
rfl
rw [cast_ofNat, Nat.cast_ofNat]
rw [cast_ofNat, Nat.cast_ofNat]
rw [cast_ofNat, Nat.cast_ofNat]
simp
simp [add_mul, ih]
simp [sub_mul, ih]
intro m n h
rw [← sub_nonneg] at h
  -- Porting note: next two lines were previously:
  -- lift n - m to ℕ using h with k
let k : ℕ := (n - m).toNat
have h' : ↑k = n - m := toNat_of_nonneg h
rw [← sub_nonneg, ← cast_sub, ← h', cast_ofNat]
exact k.cast_nonneg
simp
simp
rw [← sub_nonneg, ← cast_sub, cast_nonneg, sub_nonneg]
rw [← cast_zero, cast_le]
rw [← cast_zero, cast_lt]
rw [← cast_zero, cast_lt]
simp [abs_eq_max_neg]
rw [← Int.cast_one, ← Int.cast_neg, cast_le]
exact Int.le_sub_one_of_lt h
cases n
· simp
· rw [abs_eq_natAbs, natAbs_negSucc, cast_succ, cast_ofNat, cast_succ]
simp [h1]
simp
simp
simp [add_assoc]
simp
simp [sub_eq_add_neg]
simp [natCast]
simp [natCast]
simp [intCast]
simp [intCast]
simp [m0] at ae
simp [ae, m0]
simp [ae.symm]
rw [e, Int.ofNat_mul]
change ↑a
rw [Int.mul_comm]
rfl
show ofNat (Nat.succ n) * x = x + ofNat n * x
simp only [ofNat_eq_coe]
rw [Int.ofNat_succ, Int.add_mul, Int.add_comm, Int.one_mul]
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
rw [neg_succ, succ_pred]
rw [eq_neg_of_eq_neg (neg_succ (-a)).symm, neg_neg]
rw [neg_pred, pred_succ]
cases n
cases h
simp
rfl
rw [← nat_abs_mul, Units.mul_inv] <;> rfl
rw [← nat_abs_mul, Units.inv_mul] <;> rfl
simp [nat_abs_eq_iff, is_unit_iff, Nat.cast_zero]
rw [Nat.is_unit_iff, is_unit_iff_nat_abs_eq, nat_abs_of_nat]
rw [← natAbs_mul, Units.mul_inv]
rfl
rw [← natAbs_mul, Units.inv_mul]
rfl
simp [natAbs_eq_iff, isUnit_iff, Nat.cast_zero]
simp [isUnit_iff_natAbs_eq]
rw [isUnit_iff] at ha hb hc hd
cases ha <;> cases hb <;> cases hc <;> cases hd <;>
      subst a <;> subst b <;> subst c <;> subst d <;>
    simp
infer_instance
rw [abs_eq_natAbs]
rfl
rw [abs_eq_natAbs, sign_mul_natAbs a]
simp
let ⟨hn, hp⟩ := abs_lt.mp a0
rw [←zero_add 1, lt_add_one_iff] at hp
    -- Defeq abuse: `hn : -1 < a` but should be `hn : 0 λ a`.
exact hp.antisymm hn
rw [le_iff_lt_or_eq, abs_lt_one_iff, abs_eq (zero_le_one' ℤ)]
rw [← sub_add_cancel (G := ℤ) z b, add_comm]
exact match z - b with
  | .ofNat n => pos n
  | .negSucc n => neg n
erw [add_zero]
rw [add_assoc]
rfl
rw [add_sub_assoc]
rfl
rw [← Int.ediv_neg]
exact ediv_eq_zero_of_lt H1 H2
rw [← emod_abs]
exact emod_lt_of_pos _ (abs_pos.2 H)
rw [← emod_add_emod, ← emod_add_emod k, H]
rw [abs_eq_natAbs, abs_eq_natAbs]
exact
      ofNat_le_ofNat_of_le
        (match a, n with
        | (m : ℕ), n => Nat.div_le_self _ _
        | -[m+1], 0 => Nat.zero_le _
        | -[m+1], n + 1 => Nat.succ_le_succ (Nat.div_le_self _ _))
decide
decide
decide
decide
rw [Nat.cast_add]
exact (le_add_iff_nonneg_left 2).2 (NonNeg.mk k)
decide
cases h₁
simp [az]
rw [Int.mul_ediv_cancel_left _ az, mul_assoc, Int.mul_ediv_cancel_left _ az]
apply dvd_mul_right
rw [abs_eq_natAbs, natAbs_sign_of_nonzero hz, Int.ofNat_one]
simp [az]
rw [mul_comm, ← emod_def]
apply emod_nonneg _ H
rw [← Int.ediv_mul_cancel H2]
exact mul_le_mul_of_nonneg_right H3 H1
rw [← Int.mul_ediv_assoc _ H2]
exact (Int.ediv_eq_of_eq_mul_left H4 H5.symm).symm
rw [ofNat_le.symm, toNat_eq_max, max_le_iff]
exact and_iff_left (ofNat_zero_le _)
rw [to_nat_le]
exact le_trans h (self_le_toNat b)
cases a
exact lt_to_nat.1 h
exact lt_trans (neg_of_sign_eq_neg_one rfl) hb
rw [lt_to_nat]
cases a
exact h
exact hb
simp [h, le_of_lt h, push_cast]
rw [← abs_eq_iff_mul_self_eq, abs_eq_natAbs, abs_eq_natAbs]
exact Int.coe_nat_inj'.symm
rw [← abs_lt_iff_mul_self_lt, abs_eq_natAbs, abs_eq_natAbs]
exact Int.ofNat_lt.symm
rw [← abs_le_iff_mul_self_le, abs_eq_natAbs, abs_eq_natAbs]
exact Int.ofNat_le.symm
cases h
exact ⟨rfl, heq_of_eq rfl⟩
subst h₁
rw [eq_of_heq h₂]
cases x₀
cases x₁
cases h₀
cases h₁
rfl
cases x₀
cases x₁
exact Sigma.mk.inj_iff
simp only [Function.Surjective, Sigma.forall, h₁.forall]
exact fun i ↦ (h₂ _).forall.2 fun x ↦ ⟨⟨i, x⟩, rfl⟩
cases x₀
cases x₁
cases h₀
cases h₁
rfl
cases x₀
cases x₁
exact PSigma.mk.inj_iff
simp
split <;> rename_i h
· simp [(m.parent ⟨i, h⟩).2, h]; exact m.rank_lt _
· intro.
simp
split <;> rename_i h'
· rw [← h']; exact fun _ ↦ h
· exact m.rank_lt i
simp
split <;>
      (rename_i h₁; simp [h₁]; split <;> rename_i h₂ <;>
        (intro h; simp [h] at h₂ <;> simp [h₁, h₂, h]))
· simp [← h₁]; split <;> rename_i h₃
      · rw [h₃]; apply Nat.lt_succ_self
      · exact lt_of_le_of_ne H h₃
· have := Fin.eq_of_val_eq h₂.1; subst this
      simp [hroot] at h
· have := m.rank_lt i h
      split <;> rename_i h₃
      · rw [h₃.1]; exact Nat.lt_succ_of_lt this
      · exact this
funext ⟨i, h⟩
apply H
    cases this
constructor
cases H
rfl
cases H
exact fun i h _ ↦ rfl
simp [hk]
apply le_antisymm <;> simp_all [Nat.lt_succ]
simp
simp_all [Array.get_set]
rw [H.size_eq]
exact h
apply H.imp <;>
  · intro H
    refine H.push _ hk _ _ (fun i h ↦ ?_) (fun h ↦ ?_) <;>
    simp [UFModel.push, h, lt_irrefl]
simp [UFModel.setParent, h.symm]
simp [UFModel.setParent, hp]
let ⟨n, m, hm⟩ := self.model
cases hm.size_eq
exact ⟨m, hm⟩
let ⟨k, H⟩ := rankMaxAux self i
refine ⟨max k (if h : _ then (self.arr.get ⟨i, h⟩).rank else 0), fun j hj h ↦ ?_⟩
match j, lt_or_eq_of_le (Nat.le_of_lt_succ hj) with
  | j, Or.inl hj => exact le_trans (H _ hj h) (le_max_left _ _)
  | _, Or.inr rfl => simp [h, le_max_right]
simp [rank]
split
{apply lt_rankMax'}
apply Nat.succ_pos
simp [rank, h, H.rank_eq]
let ⟨m, hm⟩ := self.model'
simp [hm.parent_eq, size, (m.parent ⟨i, h⟩).2, h]
simp [root.2]
rw [← hm.parent_eq x x.2 x'.2]
rfl
rw [e]
exact this
simp
exact y.2
simp
rw [if_neg h.symm]
simp
simp [h.symm]
simp [ne, hm.parent_eq']
simp
simp [hm.rank_eq]
rw [if_neg h.symm]
simp [hm.rank_eq]
rw [e]
exact y.2
rw [e]
exact rx.2
cases h
rfl
cases x <;> simp only [getLeft, isRight, eq_self_iff_true]
cases x <;> simp only [getRight, isLeft, eq_self_iff_true]
cases x <;> rfl
cases x <;> simp
simp
cases x <;> rfl
cases x <;> simp
simp
cases x <;> simp
cases x <;> simp
cases x <;> rfl
cases x <;> rfl
cases x <;> rfl
cases x <;> rfl
simp
simp (config := { contextual := true })
simp
simp (config := { contextual := true })
rw [← update_inl_comp_inl, Function.comp_apply]
rw [← update_inr_comp_inr, Function.comp_apply]
cases x <;> rfl
cases x <;> rfl
cases x <;> rfl
cases x <;> rfl
cases x <;> rfl
cases h
assumption
cases h
assumption
cases h
· exact LiftRel.inl (hr _ _ ‹_›)
· exact LiftRel.inr (hs _ _ ‹_›)
cases h
· exact LiftRel.inr ‹_›
· exact LiftRel.inl ‹_›
rw [← swap_swap x, ← swap_swap y]
exact h.swap
cases h
assumption
cases h
assumption
cases h
· exact Lex.inl ‹_›
· exact Lex.inr ‹_›
cases h
· exact Lex.inl (hr _ _ ‹_›)
· exact Lex.inr (hs _ _ ‹_›)
· exact Lex.sep _ _
simp
simp
rw [← not_nonempty_iff_eq_empty, image2_nonempty_iff, not_and_or]
simp [not_nonempty_iff_eq_empty]
simp
simp
simp
rw [h a ha b hb]
rw [h a ha b hb c hc]
simp [nonempty_def.mp h, ext_iff]
simp [nonempty_def.mp h, ext_iff]
simp only [image2_image2_left, image2_image2_right, h_assoc]
rw [image2_swap f', image2_swap f]
exact image2_assoc fun _ _ _ => h_left_comm _ _ _
rw [image2_swap g, image2_swap g']
exact image2_assoc fun _ _ _ => h_right_comm _ _ _
rw [image_id']
rw [image_id']
rw [image2_swap f]
exact image_image2_distrib fun _ _ => h_antidistrib _ _
rw [image_id']
rw [image_id']
rw [sigma_singleton, image_singleton]
rw [insert_eq, union_sigma, singleton_sigma]
exact a
simp [range]
simp only [not_nonempty_iff_eq_empty, not_and, not_exists]
rfl
rw [← h₁]
exact h₂
rw [h]
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
simp only [subset_def, not_forall, exists_prop, iff_self]
simp only [Set.Nonempty, not_exists, eq_empty_iff_forall_not_mem, iff_self]
rw [← not_forall, ← eq_univ_iff_forall]
simp [subset_def]
simp only [← subset_empty_iff]
exact union_subset_iff
simp only [subset_def, mem_insert_iff, or_imp, forall_and, forall_eq, iff_self]
simp only [insert_subset, exists_and_right, ssubset_def, not_subset]
simp only [exists_prop, and_comm]
rfl
simp [mem_insert_iff, or_and_right, exists_and_left, exists_or]
simp only [mem_empty_iff_false, mem_insert_iff, or_false]
exact Iff.rfl
simp only [Set.Nonempty, mem_inter_iff, mem_singleton_iff, exists_eq_left, iff_self]
rw [inter_comm, singleton_inter_nonempty]
rw [inter_comm, singleton_inter_eq_empty]
rw [ssubset_iff_subset_ne, subset_singleton_iff_eq, or_and_right, and_not_self_iff, or_false_iff,
    and_iff_left_iff_imp]
exact fun h => h ▸ (singleton_ne_empty _).symm
rw [Disjoint.comm, disjoint_left]
rw [union_comm, union_compl_self]
simp [mem_compl]
rw [diff_eq, inter_comm]
rw [union_comm]
exact sup_inf_sdiff _ _
rw [← union_singleton, union_comm]
apply diff_subset_iff
rw [← diff_singleton_subset_iff]
intro H
rw [H] at h'
exact h h'
rw [insert_inter_distrib, insert_eq_of_mem h]
rw [insert_inter_distrib, insert_eq_of_mem h]
simp [singleton_inter_eq_empty.2 h]
simp [insert_eq, union_diff_self, -union_singleton, -singleton_union]
simp [mem_dite]
simp [mem_dite]
simp only [mem_dite, mem_empty_iff_false, imp_false, not_not]
exact ⟨fun h => ⟨h.2, h.1 h.2⟩, fun ⟨h₁, h₂⟩ => ⟨fun _ => h₂, h₁⟩⟩
simp
simp only [mem_dite, mem_empty_iff_false, imp_false]
exact ⟨fun h => ⟨h.1, h.2 h.1⟩, fun ⟨h₁, h₂⟩ => ⟨fun h => h₁ h, fun _ => h₂⟩⟩
simp
rw [Set.ite, union_inter_distrib_right, diff_inter_self, inter_assoc, inter_self, union_empty]
rw [Set.ite, Set.ite, diff_compl, union_comm, diff_eq]
rw [← ite_compl, ite_inter_self]
simp [Set.ite]
simp [Set.ite]
simp [Set.ite]
simp [Set.ite]
simp [Set.ite]
simp [Set.ite]
rw [ite_inter_inter, ite_same]
rw [← ite_inter, ← h, ite_same]
simp only [subset_def, ← forall_and]
refine' forall_congr' fun x => _
constructor
· refine' fun h => fun a ha b hb => _
    exact SetCoe.ext_iff.2 (@Subsingleton.elim s h ⟨a, ha⟩ ⟨b, hb⟩)
· exact fun h => Subsingleton.intro fun a b => SetCoe.ext (h a.property b.property)
rw [s.subsingleton_coe]
exact subsingleton_of_subsingleton
rw [nontrivial_iff_exists_ne (mem_singleton x)] at H
exact
    let ⟨y, hy, hya⟩ := H
    hya (mem_singleton_iff.1 hy)
rw [H] at hs
exact not_nontrivial_singleton hs
rw [mem_insert_iff, mem_singleton_iff]
exact Classical.propComplete x
simp [Monotone, MonotoneOn]
simp [Antitone, AntitoneOn]
simp [StrictMono, StrictMonoOn]
simp [StrictAnti, StrictAntiOn]
simp [monotoneOn_iff_monotone, antitoneOn_iff_antitone, and_assoc, exists_and_left,
    not_monotone_not_antitone_iff_exists_le_le, @and_left_comm (_ ∈ s)]
simp [monotoneOn_iff_monotone, antitoneOn_iff_antitone, and_assoc, exists_and_left,
    not_monotone_not_antitone_iff_exists_lt_lt, @and_left_comm (_ ∈ s)]
rw [nonempty_iff_ne_empty, ← h2, nonempty_iff_ne_empty, hf.ne_iff]
cases x
rfl
cases x
rfl
cases x
rfl
infer_instance
infer_instance
infer_instance
infer_instance
simp
simp
assumption
rfl
rfl
congr
rw [s_eq]
simp
simp [h]
simp
simp
simp only [subset_def, mem_image]
exact fun x => fun ⟨w, h1, h2⟩ => ⟨w, h h1, h2⟩
simp [*]
simp only [eq_empty_iff_forall_not_mem]
exact ⟨fun H a ha => H _ ⟨_, ha, rfl⟩, fun H b ⟨_, ha, _⟩ => H _ ha⟩
simp [← preimage_compl_eq_image_compl]
simp
rw [← image_comp, compl_comp_compl, image_id]
simp only [image_insert_eq, image_singleton]
rw [image_eq_preimage_of_inverse h₁ h₂]
rfl
simp [disjoint_iff_inf_le, image_inter H]
rw [← image_union]
simp [image_univ_of_surjective H]
rw [diff_subset_iff, ← image_union, union_diff_self]
exact image_subset f (subset_union_right t s)
rw [← image_preimage_eq s hf, ← image_preimage_eq t hf, eq]
simp only [inter_comm, image_inter_preimage]
rw [← image_inter_preimage, nonempty_image_iff]
rw [← preimage_image_eq s hf, ← preimage_image_eq t hf, eq]
refine' Iff.symm <| (Iff.intro (image_subset f)) fun h => _
rw [← preimage_image_eq s hf, ← preimage_image_eq t hf]
exact preimage_mono h
simp
subst hi
apply H
simp
subst a
exact ⟨i, ha⟩
rw [← image_univ]
exact image_subset _ (subset_univ _)
rw [← range_subset_iff]
exact le_antisymm_iff
rw [range_comp]
apply image_subset_range
rw [← not_nonempty_iff, ← range_nonempty_iff_nonempty, not_nonempty_iff_eq_empty]
rw [← image_union, ← image_univ, ← union_compl_self]
rw [preimage, mem_setOf, h_eq]
exact hx
rw [image_preimage_eq_inter_range, inter_eq_self_of_subset_left hs]
intro h
rw [← h]
apply image_subset_range
simp
rw [inter_comm, preimage_inter_range]
rw [image_preimage_eq_inter_range, preimage_inter_range]
rw [← image_univ, preimage_inl_image_inr]
rw [← image_univ, preimage_inr_image_inl]
rw [image_preimage_eq_inter_range, image_preimage_eq_inter_range, ← inter_distrib_left,
    range_inl_union_range_inr, inter_univ]
simp [range_subset_iff, funext_iff, mem_singleton]
rw [compl_eq_univ_diff, image_diff_preimage, image_univ]
rw [range_subset_iff]
intro x
apply Subtype.ext -- Porting note: why doesn't `ext` find this lemma?
simp only [rangeFactorization_coe]
apply apply_rangeSplitting
rw [← nonempty_image_iff, hf.image_preimage]
intro s t h
rw [← preimage_image_eq s hf, ← preimage_image_eq t hf, h]
apply Set.preimage_subset_preimage_iff
rw [Function.Surjective.range_eq hf]
apply subset_univ
rw [← image_comp, h.comp_eq_id, image_id]
rw [← preimage_comp, h.comp_eq_id, preimage_id]
rw [← Set.image_univ]
simp [-Set.image_univ, coe_image]
rw [← preimage_range, range_coe]
rw [← yvaleq]
exact y.property
rw [← image_preimage_coe, ← image_preimage_coe, coe_injective.image_injective.eq_iff]
rw [preimage_coe_eq_preimage_coe_iff, inter_assoc, inter_self]
rw [inter_comm, ← image_preimage_coe, nonempty_image_iff]
simp [← not_nonempty_iff_eq_empty, preimage_coe_nonempty]
rw [h.nonempty_apply_iff preimage_empty]
apply singleton_nonempty
refine' ⟨fun h x x' hx => _, Injective.image_injective⟩
rw [← singleton_eq_singleton_iff]
apply h
rw [image_singleton, image_singleton, hx]
rw [← image_eq_image hf.1, hf.2.image_preimage]
rw [← image_eq_image hf.1, hf.2.image_preimage]
cases a
cases b
intro h
cases h
rfl
cases a
rfl
simp only [Fin.ofNat', Nat.mod_eq_of_lt h]
simp only [OfNat.ofNat, Fin.ofNat]
rw [Nat.mod_eq_of_lt]
exact Nat.succ_lt_succ (Nat.zero_lt_succ _)
apply Fin.eq_of_val_eq
simp only [Fin.mod_def]
rw [Nat.mod_eq_of_lt h, Nat.mod_eq_of_lt a.isLt]

/- The basic structures on `Fin` are predicated on `Fin n` being nonempty.
The Nonempty bound is there so that we can implement `Zero` in a way that satisfies
the requirements of the relevant typeclasses (for example, AddMonoid). If we were to
use `Fin n+1` for the `Zero` implementation, we would be shutting out some irreducible
definitions (notably USize.size) that are known to be inhabited, but not defined in terms
of `Nat.succ`. Since there's a blanket implementation of `∀ n, Inhabited (Fin n+1)` in
the prelude, this hopefully won't be a significant impediment. -/
simp [Fin.ofNat', Fin.add_def]
apply Fin.eq_of_val_eq
simp only [Fin.add_def, Nat.mod_add_mod, Nat.add_mod_mod, Nat.add_assoc]
apply Fin.eq_of_val_eq
simp only [Fin.add_def, Nat.add_comm]
apply Fin.eq_of_val_eq
simp only [Fin.mul_def]
generalize lhs : ((a.val * b.val) % n * c.val) % n = l
generalize rhs : a.val * (b.val * c.val % n) % n = r
rw [← Nat.mod_eq_of_lt c.isLt, (Nat.mul_mod (a.val * b.val) c.val n).symm] at lhs
rw [← Nat.mod_eq_of_lt a.isLt, (Nat.mul_mod a.val (b.val * c.val) n).symm,
        ← Nat.mul_assoc] at rhs
rw [← lhs, ← rhs]
apply Fin.eq_of_val_eq
simp only [Fin.mul_def, Nat.mul_comm]
simp only [Fin.ofNat', Nat.zero_mod]
have zero_lt : (0 : Nat) < m := @Fin.zero_def n _ ▸ hp
have a_mod_lt : a % m < m := Nat.mod_lt _ zero_lt
simp only [Fin.mod_def, LT.lt]
rw [(Nat.mod_eq_of_lt (Nat.lt_trans a_mod_lt mLt) : a % m % n = a % m)]
exact Nat.mod_lt _ zero_lt

/- Aux lemma that makes nsmul_succ easier -/
apply Fin.eq_of_val_eq
simp only [Fin.ofNat', Fin.mul_def]
generalize hy : x * a % n = y
rw [← Nat.mod_eq_of_lt isLt, ← Nat.mul_mod, hy]
simp [Fin.ofNat']
apply Fin.eq_of_val_eq
simp only [Fin.add_def, Fin.zero_def, Nat.add_zero]
exact Nat.mod_eq_of_lt a.isLt
apply Fin.eq_of_val_eq
simp only [Fin.add_def, Fin.zero_def, Nat.zero_add]
exact Nat.mod_eq_of_lt a.isLt
apply Fin.eq_of_val_eq
simp [Fin.mul_def, Fin.ofNat', Fin.zero_def, Nat.zero_mul, Nat.zero_mod]
simp only [Fin.nsmuls_eq]
simp [Fin.ofNat', Fin.add_def]
exact congrArg (fun x ↦ x % n) (Nat.add_comm (x * a.val) (a.val) ▸ Nat.succ_mul x a.val)
apply Fin.eq_of_val_eq
simp only [Fin.mul_def, Fin.one_def]
cases n with
  | zero => exact (False.elim a.elim0)
  | succ n =>
    match Nat.lt_or_eq_of_le (Nat.mod_le 1 n.succ) with
    | Or.inl h_lt =>
      have h_eq : 1 % n.succ = 0 := Nat.eq_zero_of_le_zero (Nat.le_of_lt_succ h_lt)
      have hnz : n = 0 := Nat.eq_zero_of_le_zero (Nat.le_of_succ_le_succ (Nat.le_of_mod_lt h_lt))
      have haz : a.val = 0 := Nat.eq_zero_of_le_zero (Nat.le_of_succ_le_succ (hnz ▸ a.isLt))
      rw [h_eq, haz]
      simp only [Nat.zero_mul, Nat.zero_mod]
    | Or.inr h_eq => simp only [h_eq, Nat.mul_one, Nat.mod_eq_of_lt (a.isLt)]
rw [mul_comm, Fin.mul_one]
apply Fin.eq_of_val_eq
simp only [Fin.mul_def, Fin.zero_def, Nat.zero_mul, Nat.zero_mod]
apply Fin.eq_of_val_eq
simp only [Fin.mul_def, Fin.zero_def, Nat.mul_zero, Nat.zero_mod]
apply Fin.eq_of_val_eq
simp [Fin.mul_def, Fin.add_def]
generalize lhs : a.val * ((b.val + c.val) % n) % n = l
rw [(Nat.mod_eq_of_lt a.isLt).symm, ← Nat.mul_mod] at lhs
rw [← lhs, left_distrib]
rw [mul_comm, Fin.mul_add, mul_comm c, mul_comm c]
simp [Fin.add_def, Fin.sub_def, Neg.neg]
rw [add_comm, ← Fin.sub_eq_add_neg]
apply Fin.eq_of_val_eq
simp [Fin.sub_def, (Nat.add_sub_cancel' (Nat.le_of_lt a.isLt)), Nat.mod_self]
intro h1 h2
apply Fin.eq_of_val_eq
exact Nat.le_antisymm h1 h2
simp [mulSingle_apply, eq_comm]
apply ite_self
rw [Subsingleton.elim j i, Pi.mulSingle_eq_same]
simp only [Pi.mulSingle, Sum.elim_update_left, elim_one_one]
simp only [Pi.mulSingle, Sum.elim_update_right, elim_one_one]
have : r = p := funext fun a ↦ funext fun b ↦ propext <| Eq a b
     subst this
     rfl
simp [heq_self_iff_true]
simp [heq_self_iff_true]
refine' Iff.trans _ Quotient.eq
rw [Quotient.out_eq y]
refine' Iff.trans _ Quotient.eq
rw [Quotient.out_eq x]
rw [← Quotient.eq_mk_iff_out, Quotient.out_eq]
infer_instance
unfold Vector
infer_instance
contradiction
contradiction
rw [h]
exact i.2
simp [*]
simp [*]
simp [*]
simp [*]
simp [*]
rw [l.length_removeNth] <;> rw [p]
exact i.2
simp [*]
simp [*]
cases v
rfl
cases v
cases w
rfl
cases v
rfl
cases v
rfl
rw [congr_append]
simp only [String.length]
exact List.length_append as bs
simp only [String.length, String.replicate, List.length_replicate]
simp only [String.length]
simp only [leftpad, String.length, List.leftpad_length]
simp only [isPrefix, replicate, leftpad, String.length, List.leftpad_prefix]
simp only [isSuffix, replicate, leftpad, String.length, List.leftpad_suffix]
rw [← @mk.eta _ _ p, ← @mk.eta _ _ q, mk.inj_iff]
simp
simp
simp
cases h <;> simp [*]
subst e
exact Lex.right _ h
rw [Prod.map_map, hf.comp_eq_id, hg.comp_eq_id, map_id, id]
decide
decide
decide
decide
simp [add_def, zero_def]
simp [add_def, zero_def]
simp [add_def, add_comm]
simp [mul_def, one_def]
simp [mul_def, one_def]
simp [mul_def, zero_def]
simp [mul_def, zero_def]
simp only [mul_def, add_def]
apply eq_of_val_eq
exact right_distrib a.val b.val c.val
simp only [mul_def, add_def]
apply eq_of_val_eq
exact left_distrib a.val b.val c.val
apply eq_of_val_eq
simp [neg_def, add_def, zero_def]
apply eq_of_val_eq
simp [mul_def, zero_def]
exact mul_comm _ _
decide
decide
simp only [utf8Size]
repeat (split; decide)
decide
rw [Char.ofNat, dif_pos h]
rfl
rw [Nat.succ_mul, Nat.one_mul]
exact Nat.le_add_left i i
rw [a.size_swap i j]
exact j.1.2
rw [a.size_swap i j]
exact Nat.sub_lt_sub_left i.2 <| Nat.lt_of_le_of_ne j.2 h
assumption
rw [a.size_swap i j]
exact j.2
assumption
rw [Array.size_push]
apply Nat.lt_succ_self
simp [insert, size, size_heapifyUp]
simp [size, e]
rw [e]
apply Nat.succ_pos
rw [e]
apply Nat.lt_succ_self
simp [size]
simp [size]
simp [BinaryHeap.max, Array.get?, h] at e
simp
exact size_pos_of_max e
simp
exact size_pos_of_max e
rw [self.1.size_set]
exact i.2
rw [self.1.size_set]
exact i.2
simp
exact Nat.sub_lt (BinaryHeap.size_pos_of_max e) Nat.zero_lt_one
assumption
cases j
simp [h]
cases b <;> simp
simp [h]
cases b <;> assumption
cases b
exact Or.inl h
exact Or.inr h
cases b <;> simp
cases b <;> rfl
decide
decide
decide
decide
decide
simp [H]
cases a <;> simp [H]
decide
decide
decide
decide
decide
cases a <;> simp
cases a <;> cases b <;> cases c <;> simp
cases a <;> simp
cases a <;> cases b <;> cases c <;> simp
decide
decide
decide
decide
decide
decide
decide
simp
cases a <;> decide
cases a <;> decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
cases a <;> simp
cases a <;> cases b <;> cases c <;> simp
decide
decide
decide
decide
unfold LE.le
decide
unfold LE.le
decide
unfold LE.le Preorder.toLE
decide
unfold LE.le Preorder.toLE PartialOrder.toPreorder
decide
unfold LE.le Preorder.toLE PartialOrder.toPreorder
exact inferInstance
  decidable_eq
cases a <;> cases b <;> decide
cases a <;> cases b <;> decide
decide
decide
decide
decide
decide
decide
decide
decide
simp only [ofNat, ne_eq, _root_.decide_not]
cases Nat.decEq n 0 with
  | isTrue hn => rw [decide_eq_true hn]; exact false_le
  | isFalse hn =>
    cases Nat.decEq m 0 with
    | isFalse hm => rw [decide_eq_false hm]; exact le_true
    | isTrue hm => subst hm; have h := le_antisymm h (Nat.zero_le n); contradiction
cases h with
  | inl h => subst h; exact Nat.zero_le _
  | inr h => subst h; cases b₀ <;> simp;
cases b <;> rfl
cases x <;> cases h₁ : f true <;> cases h₂ : f false <;> simp only [h₁, h₂]
rw [← image_univ, univ_eq, image_pair]
simp_wf
simp [Nat.succ_add]
decreasing_tactic
cases l <;> dsimp only [List.Chain'] <;> infer_instance
simp
simp only [mem_range', or_and_left, or_iff_right_of_imp this, l, Nat.add_right_comm]
rfl
rw [show n + (s + 1) = n + 1 + s from Nat.add_right_comm n s 1]
exact range_loop_range' s (n + 1)
rw [Nat.zero_add]
simp only [range_eq_range', mem_range', Nat.zero_le, true_and, Nat.zero_add]
rfl
simp only [range_eq_range', nodup_range']
simp only [split_at, split_at_eq_take_drop n xs, take, drop]
induction xs generalizing i j with
  | nil => cases h₀
  | cons x xs ih =>
    match i, j with
    | 0, 0 => rfl
    | i+1, j+1 => simp; cases h₁ with
      | cons ha h₁ => exact ih (Nat.lt_of_succ_lt_succ h₀) h₁ h₂
    | i+1, 0 => ?_ | 0, j+1 => ?_
    all_goals
      simp at h₂
      cases h₁; rename_i h' h
      have := h x ?_ rfl; cases this
      rw [mem_iff_get?]
    exact ⟨_, h₂⟩; exact ⟨_ , h₂.symm⟩
constructor
· simp only [List.product, and_imp, exists_prop, List.mem_map, Prod.mk.injEq,
      exists_eq_right_right', List.mem_bind]
    exact And.intro
· simp only [product, mem_bind, mem_map, Prod.mk.injEq, exists_eq_right_right', exists_prop]
    exact id
induction l with
  | nil => rfl
  | cons => simp only [*, pmap, map]
induction l with
  | nil => rfl
  | cons a l ih =>
    rw [pmap, pmap, h _ (mem_cons_self _ _), ih (fun a ha ↦ h a (mem_cons_of_mem _ ha))]
induction l with
  | nil => rfl
  | cons => simp only [*, pmap, map]
induction l with
  | nil => rfl
  | cons => simp only [*, pmap, map]
rw [attach, map_pmap]
exact pmap_congr l fun _ _ _ _ ↦ rfl
rw [attach, map_pmap]
exact (pmap_eq_map ..).trans (map_id l)
rw [attach_map_val] <;> exact h
simp only [pmap_eq_map_attach, mem_map, mem_attach, true_and, Subtype.exists, eq_comm]
rfl
induction p with
| nil => exact Perm.nil
| cons x _ ih => exact Perm.cons x ih
| swap x y l => exact Perm.swap y x l
| trans _ _ ih₁ ih₂ => exact Perm.trans ih₂ ih₁
induction p with
  | nil => exact nil_subset _
  | cons _ _ ih => exact cons_subset_cons _ ih
  | swap x y l =>
    intro a
    rw [mem_cons]
    exact fun
    | Or.inl rfl => Mem.tail _ (Mem.head ..)
    | Or.inr (Mem.head ..) => Mem.head ..
    | Or.inr (Mem.tail _ a_mem_l) => Mem.tail _ (Mem.tail _ a_mem_l)
  | trans _ _ ih₁ ih₂ => exact Subset.trans ih₁ ih₂
simp
induction p with
  | nil => simp
  | cons _ _ ih => simp [ih]
  | swap _ _ l => simp
  | trans _ _ ih₁ ih₂ => exact ih₁.trans ih₂
have : ∀ l₁ l₂ : List α, (∀ x : α, x ∈ l₁ → ∀ y : α, y ∈ l₂ → R x y) →
    ∀ x : α, x ∈ l₂ → ∀ y : α, y ∈ l₁ → R x y := fun l₁ l₂ a x xm y ym ↦ s (a y ym x xm)
simp only [pairwise_append, and_left_comm]
rw [Iff.intro (this l₁ l₂) (this l₂ l₁)]
rw [← append_assoc, pairwise_append, @pairwise_append _ _ ([a] ++ l₁), pairwise_append_comm s]
simp only [mem_append, or_comm]
rfl
simp [Pairwise.nil]
induction p with
  | nil => constructor
  | @cons a l r _ ih =>
    constructor
    · exact BAll.imp_right (fun x h ↦ H (mem_cons_self _ _) (mem_cons_of_mem _ h)) r
    · exact ih fun {a b} m m' ↦ H (mem_cons_of_mem _ m) (mem_cons_of_mem _ m')
simp (config := { contextual := true })
simp
simp
induction as with
  | nil => simp [remove]
  | cons a' as ih =>
    simp [remove]
    cases Decidable.em (a = a') with
    | inl h =>
      simp only [if_pos h, ih]
      exact ⟨fun ⟨h1, h2⟩ ↦ ⟨Or.inr h1, h2⟩, fun ⟨h1, h2⟩ ↦ ⟨Or.resolve_left h1 (h ▸ h2), h2⟩⟩
    | inr h =>
      simp [if_neg h, ih]
      constructor
      { focus
        intro h'
        cases h' with
        | inl h₁ => exact ⟨Or.inl h₁, h₁.symm ▸ (Ne.symm h)⟩
        | inr h₁ => exact ⟨Or.inr h₁.1, h₁.2⟩ }
      intro ⟨h1, h2⟩
      cases h1 with
      | inl h1' => exact Or.inl h1'
      | inr h1' => exact Or.inr ⟨h1', h2⟩
simp [remove]
rw [h']
apply mem_cons_self
rw [mem_remove_iff] at h
exact h.1

/- card -/
simp [card, h]
simp [card, h]
cases Decidable.em (a ∈ as) with
  | inl h => simp [h, Nat.le_refl]
  | inr h => simp [h, Nat.le_succ]
simp [h]
simp [h]
rw [mem_remove_iff]
exact ⟨h'', Ne.symm h'⟩
          simp [h'', this, card_remove_of_mem h₃]
simp
induction as with
  | nil => simp
  | cons a as ih =>
    cases Decidable.em (f a ∈ map f as) with
    | inl h => simp [h]; apply Nat.le_trans ih (card_le_card_cons ..)
    | inr h =>
      have : a ∉ as := fun h'' ↦ h (mem_map_of_mem _ h'')
      simp [h, this]
      exact Nat.add_le_add_right ih _
induction as with
  | nil => simp
  | cons a as ih =>
    cases Decidable.em (f a ∈ map f as) with
    | inl h =>
      intro inj_on'
      cases (exists_of_mem_map h) with
      | intro x hx =>
        have : a = x := inj_on' (mem_cons_self ..) (mem_cons_of_mem _ hx.1) hx.2
        have h1 : a ∈ as := this ▸ hx.1
        have h2 : inj_on f as := inj_on_of_subset inj_on' (subset_cons _ _)
        simp  [h1, mem_map_of_mem f h1, ih h2]
    | inr h =>
      intro inj_on'
      have h1 : a ∉ as := fun h'' ↦ h (mem_map_of_mem _ h'')
      have h2 : inj_on f as := inj_on_of_subset inj_on' (subset_cons _ _)
      simp [h, h1, ih h2]
simp
have disj' : Disjoint as bs := fun _ h1 h2 ↦ disj (mem_cons_of_mem a h1) h2
cases Decidable.em (a ∈ as) with
    | inl h =>
      simp [h, card_append_disjoint disj']
    | inr h =>
      have h1 : a ∉ bs := fun h' ↦ disj (mem_cons_self a as) h'
      simp [h, h1, card_append_disjoint disj']
      rw [Nat.add_right_comm]
rw [card_eq_of_equiv (union_equiv_append as bs), card_append_disjoint h]
cases h
cases p with | cons n p => exact ⟨n, p⟩
induction p generalizing b with
  | nil => constructor
  | cons r _ ih =>
    constructor
    · exact Hab r
    · exact ih (@HRS _)
simp only [mem_cons, forall_eq_or_imp, h, true_and]
exact fun c hc ↦ trans h (rel_of_pairwise_cons hb.pairwise hc)
congr
exact hf a (H _ ha) b (H _ hb) h
simp
simp [false_imp_iff]
cases h
cases o <;> simp [toList, eq_comm]
cases a <;> cases b <;> simp [liftOrGet, IsCommutative.comm]
cases a <;> cases b <;> cases c <;> simp [liftOrGet, IsAssociative.assoc]
cases a <;> simp [liftOrGet, IsIdempotent.idempotent]
cases a <;> simp [liftOrGet]
cases a <;> simp [liftOrGet]
cases a <;> rfl
cases a <;> rfl
cases a <;> rfl
simp [map₂]
cases a <;> cases b <;> simp
cases a <;> cases b <;> rfl
cases a <;> cases b <;> rfl
cases a <;> rfl
cases b <;> rfl
cases x <;> rfl
cases a <;> cases b <;> cases c <;> simp [h_assoc]
cases a <;> cases b <;> simp [h_comm]
cases a <;> cases b <;> cases c <;> simp [h_left_comm]
cases a <;> cases b <;> cases c <;> simp [h_right_comm]
cases a <;> cases b <;> simp [h_distrib]
cases a <;> cases b <;> simp [h_distrib]
cases a <;> cases b <;> simp [h_distrib]
cases a <;> cases b <;> simp [h_left_comm]
cases a <;> cases b <;> simp [h_right_comm]
cases a <;> cases b <;> simp [h_antidistrib]
cases a <;> cases b <;> simp [h_antidistrib]
cases a <;> cases b <;> simp [h_antidistrib]
cases a <;> cases b <;> simp [h_left_anticomm]
cases a <;> cases b <;> simp [h_right_anticomm]
rw [Hf (Option.some.inj H)]
cases x <;> simp
simp only [eq_none_iff_forall_not_mem, mem_def, bind_eq_some, not_exists, not_and, iff_self]
simp only [← map_some', h]
rw [map_map, h, ← map_map]
cases x <;> simp only [pbind, none_bind', some_bind']
simp only [← map_eq_map, ← bind_pure_comp, LawfulMonad.bind_assoc]
cases x <;> simp
cases x <;> simp only [pbind, map_none']
cases x <;> rfl
rw [mem_def] at ha ⊢
subst ha
rfl
cases x <;> simp only [map_none', map_some', pmap]
cases x <;> simp only [map_none', map_some', pmap]

-- Porting note: Can't simp tag this anymore because `pmap` simplifies
-- @[simp]
cases x <;> simp only [map_none', map_some', pmap]
cases x <;> simp only [pmap, bind_eq_bind, none_bind, some_bind]
cases x <;> simp only [pmap, bind_eq_bind, none_bind, some_bind, pbind]
cases x
· simp
· simp only [pbind, iff_false]
    intro h
    cases h' _ rfl h
cases x <;> simp

-- Porting note: Can't simp tag this anymore because `pmap` simplifies
-- @[simp]
cases x <;> rfl
cases x <;> rfl
cases o <;> rfl
cases u
cases o <;> rfl
cases o
· simp only [true_and, false_or, eq_self_iff_true, none_orElse, iff_self]
· simp only [some_orElse, or_false, false_and, iff_self]
cases o
· simp only [true_and, none_orElse, eq_self_iff_true, iff_self]
· simp only [some_orElse, false_and, iff_self]
cases o <;> rfl
intro _ _ _ _ hα hβ
exact Relation.TransGen.tail (Relation.TransGen.single $ GameAdd.fst hα) (GameAdd.snd hβ)
intro x y h
rw [lt_iff_le_not_le, lt_iff_le_not_le, hf.le_iff_le ha hb, hf.le_iff_le hb ha]
simp only [Prod.lt_iff]
exact Or.imp (And.imp hf.imp hg.monotone.imp) (And.imp hf.monotone.imp hg.imp)
simp only [Prod.lt_iff]
exact Or.imp (And.imp hf.imp hg.antitone.imp) (And.imp hf.antitone.imp hg.imp)
apply hf.seq_le_seq n <;> intros <;>
    simp [iterate_succ', -iterate_succ, comp_apply, id_eq, le_refl]
case hx => exact H _
rw [iterate_succ_apply']
exact h _
apply hf.seq_le_seq n
· rfl
· intros; rw [iterate_succ_apply']
· intros; simp [h.iterate_right _ _, hg.iterate _ hx];
apply hf.seq_pos_lt_seq_of_le_of_lt hn
· rfl
· intros; rw [iterate_succ_apply']
· intros; simp [h.iterate_right _ _, hg.iterate _ hx]
simp only [le_antisymm_iff, h.iterate_pos_le_iff_map_le hf hg hn,
    h.symm.iterate_pos_le_iff_map_le' hg hf hn]
rfl
rw [iterate_succ_apply]
exact hf.iterate n hx
rw [iterate_succ_apply]
exact hf.iterate n hx
simp [And.comm, and_assoc]
simp only [DirectedOn, Set.mem_image, exists_exists_and_eq_and, forall_exists_index, and_imp,
    forall_apply_eq_imp_iff₂, Order.Preimage, iff_self]
assumption
assumption
cases f
cases g
congr
simp [f.map_rel_iff, g.map_rel_iff]
refine' @fun x y => Quotient.inductionOn₂ x y fun a b => _
apply iff_iff_eq.2 (H _ _ _ _ _ _) <;> apply Quotient.mk_out
simp [Prod.lex_def, h]
simp [Prod.lex_def, h]
simp [Prod.lex_def, f.map_rel_iff, g.map_rel_iff]
congr
erw [← f.map_rel_iff, f.1.apply_symm_apply, f.1.apply_symm_apply]
subst h₁
rw [eq_of_heq h₂]
rfl
subst h₁
rfl
rw [← e.map_rel_iff, e.apply_symm_apply]
rw [← e.map_rel_iff, e.apply_symm_apply]
simp [Prod.lex_def, e₁.map_rel_iff, e₂.map_rel_iff]
rw [← map_lt_map_iff f]
simp only [EquivLike.apply_inv_apply, iff_self]
rw [← map_lt_map_iff f]
simp only [EquivLike.apply_inv_apply, iff_self]
cases f
cases g
congr
simp [le_def]
intros
simp [le_iff_lt_or_eq, f.map_rel_iff, f.injective.eq_iff]
intros
simp [lt_iff_le_not_le, f.map_rel_iff]
rw [← e.symm_symm, h, e'.symm_symm]
simp [le_iff_eq_or_lt, e.map_rel_iff]
intro
rw [← cmp_eq_eq_iff, h, cmp_self_eq_eq]
intro
rw [← cmp_eq_eq_iff, ← h, cmp_self_eq_eq]
simp [Pi.le_def, Unique.forall_iff]
refine' le_antisymm _ (hy _)
rw [← f.apply_symm_apply y, f.map_rel_iff]
apply hx
rw [disjoint_iff_inf_le, ← f.map_inf, ← f.map_bot]
exact f.monotone ha.le_bot
rw [codisjoint_iff_le_sup, ← f.map_sup, ← f.map_top]
exact f.monotone ha.top_le
intro
exact f.complementedLattice
intro
exact f.symm.complementedLattice
cases x
exact (h rfl).elim
rfl
simp [LE.le]
cases ha
exact ⟨_, rfl, le_top⟩
simp [some_eq_coe]
simp [none_eq_bot]
simp [some_eq_coe, coe_eq_coe]
simp [none_eq_bot]
simp [LT.lt]
simp [some_eq_coe, coe_eq_coe]
simp [none_eq_bot]
simp [some_eq_coe, coe_eq_coe, coe_lt_coe]
simp [none_eq_bot, bot_lt_coe]
intros a b
cases a <;> cases b <;> simp [lt_iff_le_not_le]
simp [LE.le, LT.lt]
simp [Monotone]
simp [StrictMono, bot_lt_coe]
simp only [map_bot, bot_le]
simp only [map_coe, map_bot, coe_ne_bot, not_coe_le_bot _]
cases a <;> simp [none_eq_bot, some_eq_coe]
cases a
· exact (ha rfl).elim
. rw [some_eq_coe, unbot'_coe, coe_lt_coe]
cases ha
cases o₂ <;> simp [Option.liftOrGet]
cases ha
cases o₁ <;> simp [Option.liftOrGet]
simp [*]
simp [*]
simp [*]
simp only [← toDual_le_toDual_iff, toDual_apply_coe, WithBot.coe_le_coe, toDual_le_toDual]
exact Iff.rfl
cases ha
exact ⟨_, rfl, bot_le⟩
simp only [← toDual_lt_toDual_iff, toDual_apply_coe, WithBot.coe_lt_coe, toDual_lt_toDual]
exact Iff.rfl
simp [← toDual_lt_toDual_iff, WithBot.bot_lt_coe]
rw [← toDual_lt_toDual_iff]
exact WithBot.not_lt_none _
rw [← toDual_lt_toDual_iff, WithBot.lt_iff_exists_coe, OrderDual.exists]
exact exists_congr fun _ => and_congr_left' Iff.rfl
simp
simp [← toDual_lt_toDual_iff, lt_iff_le_not_le]
simp [Monotone]
simp [StrictMono, coe_lt_top]
erw [← toDual_le_toDual_iff, toDual_map, toDual_map, WithBot.map_le_iff, toDual_le_toDual_iff]
simp [mono_iff]
cases ha
cases o₂ <;> simp [Option.liftOrGet]
cases ha
cases o₁ <;> simp [Option.liftOrGet]
refine' ⟨fun h => h.has_min, @fun h => ⟨@fun x => _⟩⟩
simp [eq_iff_not_lt_of_le, wellFounded_iff_has_min]
rw [WellFounded.succ, dif_pos h]
apply min_mem
intro hy
rw [WellFounded.succ, dif_pos] at h'
exact wo.wf.not_lt_min _ h hy h'
rw [hfg]
exact Set.mem_range_self b
funext a
apply h.induction a
exact fun b H =>
      le_antisymm (eq_strictMono_iff_eq_range_aux hf hg hfg H)
        (eq_strictMono_iff_eq_range_aux hg hf hfg.symm fun a hab => (H a hab).symm)
unfold Antisymmetrization
infer_instance
rw [← toAntisymmetrization_le_toAntisymmetrization_iff]
simp
rw [← toAntisymmetrization_lt_toAntisymmetrization_iff]
simp
rw [disjoint_iff_inf_le, disjoint_iff_inf_le, inf_assoc]
simp only [disjoint_iff, inf_sup_right, sup_eq_bot_iff]
rfl
simp only [disjoint_iff, inf_sup_left, sup_eq_bot_iff]
rfl
simp only [codisjoint_iff, sup_inf_right, inf_eq_top_iff]
rfl
simp only [codisjoint_iff, sup_inf_left, inf_eq_top_iff]
rfl
rw [← @inf_top_eq _ _ _ a, ← @bot_sup_eq _ _ _ c, ← hab.eq_bot, ← hbc.eq_top, sup_inf_right]
exact inf_le_inf_right _ le_sup_left
rw [h.symm.inf_eq_bot, sup_bot_eq]
rw [← le_bot_iff, ← h.le_sup_right_iff_inf_left_le, bot_sup_eq]
rw [disjoint_iff]
exact h.inf_left_eq_bot_iff
rw [inf_sup_right, ← inf_assoc, h.inf_eq_bot, bot_inf_eq, bot_sup_eq, inf_left_comm,
      h'.inf_eq_bot, inf_bot_eq]
rw [sup_inf_left, @sup_comm _ _ x, sup_assoc, h.sup_eq_top, sup_top_eq, top_inf_eq,
      sup_assoc, sup_left_comm, h'.sup_eq_top, sup_top_eq]
rw [_root_.isCompl_iff, Prop.disjoint_iff, Prop.codisjoint_iff, not_iff]
funext a b
show (LT.mk A_lt).lt a b = (LT.mk B_lt).lt a b
rw [A_iff, B_iff]
cases A
cases B
cases h
congr
funext a b
exact (A_min_def _ _).trans (B_min_def _ _).symm
funext a b
exact (A_max_def _ _).trans (B_max_def _ _).symm
rw [max_comm, max_def]
rfl
rw [min_comm, min_def]
rfl
simp (config := { contextual := true }) [lt_iff_le_not_le, Pi.le_def]
simp (config := { contextual := true }) [update_le_iff]
simp [Pi.le_def]
rw [min_comm, min_def, ← ite_not]
simp only [not_le]
rw [max_def, ← ite_not]
simp only [not_le]
intros x y
apply inj
rw [apply_ite f]
exact (hinf _ _).trans (min_def _ _)
intros x y
apply inj
rw [apply_ite f]
exact (hsup _ _).trans (max_def _ _)
intros
trivial
intros
trivial
intros
exact Or.inl trivial
  le_antisymm
intros
rfl
simp only [not_true, and_false, iff_self, forall_const]
simp only [lt_self_iff_false]
cases o
· exact Iff.rfl
· exact eq_comm
· exact Iff.rfl
rw [← swap_inj, swap_swap]
injection h
injection h
injection h
injection h
injection h
injection h
cases o₁ <;> rfl
decide
unfold cmp cmpUsing
rw [cmp_eq_eq_iff]
rw [← cmp_eq_lt_iff, ← cmp_eq_lt_iff, h]
rw [le_antisymm_iff, le_antisymm_iff, le_iff_le_of_cmp_eq_cmp h,
      le_iff_le_of_cmp_eq_cmp (cmp_eq_cmp_symm.1 h)]
rw [sup_comm, sup_inf_sdiff]
rw [inf_comm, inf_inf_sdiff]
rw [← inf_inf_sdiff a a, inf_assoc]
exact inf_le_left
rw [sup_inf_self]
ac_rfl
rw [sup_inf_sdiff]
rw [inf_inf_sdiff]
rw [sup_inf_sdiff]
rw [inf_sup_left]
ac_rfl
rw [inf_idem]
rw [inf_sup_right, @inf_comm _ _ x y]
rw [inf_inf_sdiff, bot_sup_eq]
ac_rfl
rw [inf_of_le_right sdiff_le']
rw [sup_inf_sdiff]
rw [inf_sup_right]
rw [@inf_comm _ _ x y, inf_inf_sdiff, sdiff_inf_sdiff, bot_sup_eq]
rw [inf_comm, inf_sdiff_self_right]
rw [inf_eq_right.2 h, inf_sdiff_self_right, bot_sup_eq]
rw [← sup_assoc, ← @sdiff_sup_self' _ x y]
ac_rfl
rw [sup_assoc, sup_comm, sup_assoc, sup_idem]
rw [h, hs]
rw [h, hi.eq_bot]
rw [inf_assoc, hd.eq_bot, inf_bot_eq]
rw [sup_sdiff_cancel_right hx]
refine' le_trans (sup_le_sup_left sdiff_le z) _
rw [sup_eq_right.2 hz]
rw [← disjoint_iff]
exact disjoint_sdiff_iff_le hz hx
rw [sup_inf_left]
rw [@inf_sup_left _ _ y]
ac_rfl
rw [sup_inf_sdiff, sup_inf_sdiff]
ac_rfl
rw [sup_inf_self, sup_inf_self, inf_idem]
rw [inf_sup_left]
rw [inf_sup_right]
ac_rfl
rw [inf_inf_sdiff, h, inf_inf_sdiff]
rw [sup_inf_sdiff, h, sup_inf_sdiff]
rw [← sdiff_inf_self_right, ← sdiff_inf_self_right z y, inf_comm, h, inf_comm]
rw [sdiff_bot]
rw [inf_bot_eq, inf_comm, disjoint_iff]
rw [sdiff_eq_self_iff_disjoint, Disjoint.comm]
refine' sdiff_le.lt_of_ne fun h => hy _
rw [sdiff_eq_self_iff_disjoint', disjoint_iff] at h
rw [← h, inf_eq_right.mpr hx]
rw [inf_assoc]
rw [sup_inf_right, sup_inf_sdiff]
rw [inf_sup_right, inf_sdiff_left]
rw [sup_inf_right]
ac_rfl
rw [sup_inf_self, sup_sdiff_left, ← sup_assoc]
rw [sup_inf_left, sdiff_sup_self', inf_sup_right, @sup_comm _ _ y]
rw [inf_sdiff_sup_right, @inf_sup_left _ _ x z y]
ac_rfl
rw [sup_inf_self, sup_comm, inf_sup_self]
rw [inf_sup_left]
ac_rfl
rw [inf_sdiff_self_left, bot_inf_eq, inf_bot_eq, bot_sup_eq]
ac_rfl
rw [inf_sdiff_self_right, inf_bot_eq, inf_bot_eq]
ac_rfl
rw [sup_inf_inf_sdiff, sup_comm, inf_comm]
rw [sdiff_sdiff_right', inf_eq_right.2 h]
rw [sdiff_sdiff_right, inf_idem, sdiff_self, bot_sup_eq]
rw [sdiff_sdiff_right_self, inf_of_le_right h]
rw [← h, sdiff_sdiff_eq_self hy]
rw [← sdiff_sdiff_eq_self hxz, h, sdiff_sdiff_eq_self hyz]
rw [sdiff_sdiff_left, sdiff_sup]
rw [sdiff_sup, sdiff_sdiff_right, sdiff_sdiff_right]
rw [sup_inf_left, sup_comm, sup_inf_sdiff]
ac_rfl
rw [inf_idem]
rw [sdiff_sdiff_right, sdiff_sdiff_right]
ac_rfl
ac_rfl
rw [sup_inf_left]
rw [sup_inf_right, sup_sdiff_self_right, inf_sup_right, inf_sdiff_sup_right]
ac_rfl
rw [inf_sup_self, sup_inf_inf_sdiff]
rw [@inf_comm _ _ y, sup_inf_left]
ac_rfl
rw [inf_sdiff_self_right, inf_bot_eq, bot_inf_eq]
rw [inf_assoc]
rw [sup_inf_sdiff]
ac_rfl
rw [inf_inf_sdiff, inf_bot_eq]
rw [@inf_comm _ _ x, inf_comm, inf_sdiff_assoc]
rw [sdiff_inf, sdiff_eq_bot_iff.2 inf_le_left, bot_sup_eq, inf_sdiff_assoc]
rw [sup_inf_left]
ac_rfl
rw [sup_sdiff_right, sup_sdiff_right]
rw [sup_sdiff_self_right, sup_sdiff_self_left, inf_idem]
rw [← sup_sdiff_cancel_right hxz]
refine' (sup_le_sup_left h.le _).lt_of_not_le fun h' => h.not_le _
rw [← sdiff_idem]
exact (sdiff_le_sdiff_of_sup_le_sup_left h').trans sdiff_le
rw [← sdiff_sup_cancel hyz]
refine' (sup_le_sup_right h.le _).lt_of_not_le fun h' => h.not_le _
rw [← sdiff_idem]
exact (sdiff_le_sdiff_of_sup_le_sup_right h').trans sdiff_le
erw [← inf_sdiff_assoc, inf_top_eq]
rw [sdiff_eq, ← inf_sup_left, sup_compl_eq_top, inf_top_eq]
rw [sdiff_eq, ← inf_inf_distrib_left, inf_compl_eq_bot', inf_bot_eq]
rw [himp_eq, is_compl_compl.le_sup_right_iff_inf_left_le]
rw [sdiff_eq, top_inf_eq]
rfl
rw [h]
exact is_compl_compl.symm
rw [← h]
exact is_compl_compl
rw [eq_comm, compl_eq_iff_is_compl, eq_compl_iff_is_compl]
rw [eq_comm, compl_eq_iff_is_compl, eq_compl_iff_is_compl]
have h := compl_le_compl h
simp at h
assumption
rw [sdiff_eq, compl_compl]
rw [← sdiff_eq, sup_inf_sdiff _ _]
rw [sdiff_eq, himp_eq, compl_inf, compl_compl, sup_comm]
rw [sdiff_compl, sdiff_eq, inf_comm]
rw [← le_compl_iff_disjoint_left, compl_compl]
rw [← le_compl_iff_disjoint_right, compl_compl]
decide
erw [map_sup, map_sdiff, map_inf, sup_inf_sdiff]
erw [map_inf, map_sdiff, map_inf, inf_inf_sdiff, map_bot]
rw [map_compl, inf_compl_eq_bot, map_bot]
rw [map_compl, sup_compl_eq_top, map_top]
refine hf ((map_sdiff _ _).trans (sdiff_eq.trans ?_))
rw [map_inf, map_compl]
intros
trivial
intros
trivial
intros
trivial
simp [lt_iff_le_not_le, IsMin, not_forall, exists_prop]
simp [lt_iff_le_not_le, IsMax, not_forall, exists_prop]
show a
rw [← sup_assoc, sup_idem]
rw [sup_comm, sup_assoc, sup_idem]
simp [le_rfl]
simp [le_rfl]
simp
simp
apply le_antisymm <;> simp
simp only [sup_le_iff]
rw [and_assoc]
rw [sup_comm, @sup_comm _ _ a, sup_assoc]
simp
simp
simp
simp
rw [← sup_assoc, ← sup_assoc, @sup_comm α _ a]
rw [sup_assoc, sup_assoc, @sup_comm _ _ b]
rw [sup_assoc, sup_left_comm b, ← sup_assoc]
rw [sup_sup_sup_comm, sup_idem]
rw [sup_sup_sup_comm, sup_idem]
simp only [sup_le_iff]
rw [← H, @sup_le_iff α A, H, H]
simp [le_rfl]
simp [le_rfl]
simp only [le_inf_iff]
rw [← H, @le_inf_iff α A, H, H]
rw [← h, inf_comm, inf_sup_self]
rw [← h, sup_comm, sup_inf_self]
rw [inf_sup_self]
rw [sup_inf_self]
rw [sup_inf_self]
rw [inf_sup_self]
rw [partial_order_eq]
apply inf_le_left
rw [partial_order_eq]
apply inf_le_right
rw [partial_order_eq]
apply le_inf
simp [le_antisymm_iff, and_comm]
simp
simp
rw [sup_eq_right, ← inf_eq_left]
cases A
cases B
cases SemilatticeSup.ext H
cases SemilatticeInf.ext H
congr
simp only [sup_inf_left, fun y : α => @sup_comm α _ y x, eq_self_iff_true]
rw [inf_sup_self]
simp only [inf_assoc, sup_inf_right, eq_self_iff_true]
rw [sup_inf_self]
rw [sup_comm]
rw [sup_inf_left]
simp only [inf_sup_left, fun y : α => @inf_comm α _ y x, eq_self_iff_true]
rw [sup_inf_right, @sup_comm _ _ x]
exact congr_fun₂ sup_eq_maxDefault
exact congr_fun₂ inf_eq_minDefault
rw [← h, inf_eq_left.2 hxy]
simp only [h, hf h, sup_of_le_right]
simp only [h, hf h, sup_of_le_left]
rw [h_top]
exact le_top
cases PartialOrder.ext H
apply top_unique
exact @le_top _ _ A _
rw [h_bot]
exact bot_le
cases PartialOrder.ext H
apply bot_unique
exact @bot_le _ _ A _
rw [eq_bot_iff, sup_le_iff]
simp
have ht : @BoundedOrder.toOrderTop α _ A = @BoundedOrder.toOrderTop α _ B := OrderTop.ext
have hb : @BoundedOrder.toOrderBot α _ A = @BoundedOrder.toOrderBot α _ B := OrderBot.ext
cases A
cases B
congr
rw [map_top]
      -- Porting note: lean3 didn't need the type annotation
exact @le_top β _ _ _
rw [map_bot]
      -- Porting note: lean3 didn't need the type annotation
exact @bot_le β _ _ _
rw [← coe_bot hbot, ext_iff]
rw [← coe_top htop, ext_iff]
simp only [← inf_eq_min, ← le_bot_iff, inf_le_iff]
rfl
rw [e] at h
exact irrefl _ h
simp [h₁, h₂]
infer_instance

-- see Note [lower instance priority]
infer_instance

-- see Note [lower instance priority]
infer_instance

-- see Note [lower instance priority]
infer_instance
simp only [Bounded, Unbounded, not_forall, not_exists, exists_prop, not_and, not_not, iff_self]
rw [not_iff_comm, not_bounded_iff]
infer_instance
infer_instance
infer_instance
infer_instance
simp
simp
simp [lt_max_iff, max_lt_iff, *]
cases le_total a b <;> rename_i h <;>
    simp only [max_eq_right, max_eq_left, hf ha hb, hf hb ha, h]
cases le_total a b <;> rename_i h <;> simp [h, hf h]
cases le_total a b <;> rename_i h <;> simp [h, hf h]
cases le_total a b <;> simp [*]
decide
simp only [symmDiff, sup_comm]
rw [symmDiff, sup_idem, sdiff_self]
rw [symmDiff, sdiff_bot, bot_sdiff, sup_bot_eq]
rw [symmDiff_comm, symmDiff_bot]
rw [symmDiff, sdiff_eq_bot_iff.2 h, bot_sup_eq]
rw [symmDiff, sdiff_eq_bot_iff.2 h, sup_bot_eq]
simp [sup_sdiff, symmDiff]
rw [symmDiff, h.sdiff_eq_left, h.sdiff_eq_right]
rw [symmDiff, sup_sdiff_distrib, sdiff_sdiff_left, sdiff_sdiff_left]
rw [symmDiff_sdiff]
simp [symmDiff]
rw [symmDiff, sdiff_idem]
exact
    le_antisymm (sup_le_sup sdiff_le sdiff_le)
      (sup_le le_sdiff_sup <| le_sdiff_sup.trans <| sup_le le_sup_right le_sdiff_sup)
rw [symmDiff_comm, symmDiff_sdiff_eq_sup, sup_comm]
refine' le_antisymm (sup_le symmDiff_le_sup inf_le_sup) _
rw [sup_inf_left, symmDiff]
refine' sup_le (le_inf le_sup_right _) (le_inf _ le_sup_right)
· rw [sup_right_comm]
    exact le_sup_of_le_left le_sdiff_sup
· rw [sup_assoc]
    exact le_sup_of_le_right le_sdiff_sup
rw [sup_comm, symmDiff_sup_inf]
rw [← symmDiff_sdiff_inf a, sdiff_symmDiff_eq_sup, symmDiff_sup_inf]
rw [symmDiff_comm, symmDiff_symmDiff_inf]
rw [bihimp, inf_idem, himp_self]
rw [bihimp, himp_top, top_himp, inf_top_eq]
rw [bihimp_comm, bihimp_top]
rw [bihimp, himp_eq_top_iff.2 h, inf_top_eq]
rw [bihimp, himp_eq_top_iff.2 h, top_inf_eq]
simp [himp_inf_distrib, bihimp]
rw [bihimp, h.himp_eq_left, h.himp_eq_right]
rw [bihimp, himp_inf_distrib, himp_himp, himp_himp]
rw [himp_bihimp]
simp [bihimp]
simp [symmDiff]
simp [symmDiff]
rw [eq_top_iff, symmDiff, hnot_sdiff, sup_sdiff_self]
exact Codisjoint.top_le codisjoint_hnot_left
rw [symmDiff_comm, hnot_symmDiff_self]
rw [h.eq_hnot, hnot_symmDiff_self]
simp [bihimp]
simp [bihimp]
rw [h.eq_compl, compl_bihimp_self]
rw [symmDiff_eq_sup_sdiff_inf]
rw [symmDiff_eq_sup_sdiff_inf]
exact disjoint_sdiff_self_left
rw [symmDiff_eq_sup_sdiff_inf, inf_sdiff_distrib_left, inf_sup_left, inf_inf_distrib_left,
    symmDiff_eq_sup_sdiff_inf]
rw [sdiff_symmDiff, sdiff_sup, sup_comm]
rw [symmDiff_def, sup_sdiff, sdiff_idem, sdiff_sdiff_self, bot_sup_eq]
rw [symmDiff_comm, symmDiff_sdiff_left]
simp [sdiff_symmDiff]
rw [symmDiff_comm, inf_comm, sdiff_symmDiff_left]
refine' ⟨fun h => _, Disjoint.symmDiff_eq_sup⟩
rw [symmDiff_eq_sup_sdiff_inf, sdiff_eq_self_iff_disjoint] at h
exact h.of_disjoint_inf_of_le le_sup_left
refine' ⟨fun h => _, fun h => h.symmDiff_eq_sup.symm ▸ le_sup_left⟩
rw [symmDiff_eq_sup_sdiff_inf] at h
exact disjoint_iff_inf_le.mpr (le_sdiff_iff.1 <| inf_le_of_left_le h).le
rw [symmDiff_comm, le_symmDiff_iff_left, Disjoint.comm]
ac_rfl
ac_rfl
rw [symmDiff_symmDiff_left, symmDiff_symmDiff_right]
simp [← symmDiff_assoc]
simp [symmDiff_assoc]
rw [symmDiff_comm, symmDiff_symmDiff_cancel_left]
rw [symmDiff_bot]
rw [symmDiff_right_inj]
rw [symmDiff_comm, symmDiff_eq_left]
rw [symmDiff_eq_sup_sdiff_inf]
exact (ha.sup_left hb).disjoint_sdiff_left
rw [← symmDiff_of_le ha]
exact ((symmDiff_right_involutive a).toPerm _).apply_eq_iff_eq_symm_apply.trans eq_comm
simp [← bihimp_assoc]
simp [bihimp_assoc]
rw [bihimp_comm, bihimp_bihimp_cancel_left]
rw [symmDiff_eq_sup_sdiff_inf, sdiff_eq, compl_inf]
rw [symmDiff_eq', ← compl_inf, inf_eq_top_iff, compl_eq_top, isCompl_iff, disjoint_iff,
    codisjoint_iff, and_comm]
rw [bihimp_eq', ← compl_sup, sup_eq_bot_iff, compl_eq_bot, isCompl_iff, disjoint_iff,
    codisjoint_iff]
rw [symmDiff_eq, compl_symmDiff, bihimp_eq', symmDiff_eq]
rw [inf_sup_left, inf_sup_right, ← sup_assoc, ← inf_assoc, ← inf_assoc]
congr 1
· congr 1
        rw [inf_comm, inf_assoc]
· apply inf_left_right_swap
rw [le_himp_iff, inf_comm]
rw [le_himp_iff, le_himp_iff']
rw [le_himp_iff, inf_idem]
rw [inf_comm, ← le_himp_iff]
rw [inf_comm, ← le_himp_iff]
rw [inf_comm, inf_himp, inf_comm]
rw [← top_le_iff, le_himp_iff, top_inf_eq]
rw [le_himp_iff, inf_top_eq]
rw [le_himp_iff, le_himp_iff, inf_assoc, himp_inf_self, ← inf_assoc, himp_inf_self, inf_assoc]
exact inf_le_left
rw [himp_himp, inf_idem]
rw [sup_himp_distrib, himp_self, top_inf_eq]
rw [sup_himp_distrib, himp_self, inf_top_eq]
rw [himp_inf_distrib, himp_self, top_inf_eq, h.himp_eq_left]
rw [himp_inf_distrib, himp_self, inf_top_eq, h.himp_eq_right]
rw [le_himp_iff, inf_right_comm, ← le_himp_iff]
exact himp_inf_le.trans le_himp_himp
rw [sup_comm]
exact le_himp_iff
simp [le_def]
rw [sdiff_le_iff, sup_comm]
rw [sdiff_le_iff, sdiff_le_iff']
rw [sdiff_le_iff, sup_idem]
rw [sup_comm, ← sdiff_le_iff]
rw [sup_comm, sup_sdiff_self, sup_comm]
rw [sup_sdiff_eq_sup hab, sup_of_le_right hbc]
rw [sup_comm, sup_sdiff_cancel_right h]
rw [← le_bot_iff, sdiff_le_iff, sup_bot_eq]
rw [sdiff_le_iff, bot_sup_eq]
rw [sdiff_le_iff, sdiff_le_iff, sup_left_comm, sup_sdiff_self, sup_left_comm, sdiff_sup_self,
    sup_left_comm]
exact le_sup_left
rw [sdiff_sdiff_left, sup_idem]
rw [sdiff_sdiff_comm, sdiff_self, bot_sdiff]
rw [sup_sdiff, sdiff_self, sup_bot_eq]
rw [sup_comm, sup_sdiff_right_self]
rw [sdiff_inf, sdiff_self, bot_sup_eq]
rw [sdiff_inf, sdiff_self, sup_bot_eq]
rw [sup_sdiff, sdiff_self, bot_sup_eq, h.sdiff_eq_right]
rw [sup_sdiff, sdiff_self, sup_bot_eq, h.sdiff_eq_left]
rw [sdiff_le_iff, sup_left_comm, ← sdiff_le_iff]
exact sdiff_sdiff_le.trans le_sup_sdiff
rw [← sup_sdiff_left_self, ← @sup_sdiff_left_self _ _ _ b]
exact sdiff_le_sdiff_right h
rw [← sup_sdiff_right_self, ← @sup_sdiff_right_self _ _ b]
exact sdiff_le_sdiff_right h
rw [inf_comm]
exact sdiff_le_iff
simp [le_def]
rw [← himp_bot, himp_himp, inf_idem]
rw [← himp_bot, le_himp_iff, disjoint_iff_inf_le]
rw [le_compl_iff_disjoint_right, le_compl_iff_disjoint_left]
rw [le_compl_iff_disjoint_right, disjoint_top, le_bot_iff]
rw [← himp_bot, himp_self]
refine' ((compl_anti compl_sup_compl_le).trans (compl_sup_distrib _ _).le).antisymm _
rw [le_compl_iff_disjoint_right, disjoint_assoc, disjoint_compl_compl_left_iff,
    disjoint_left_comm, disjoint_compl_compl_left_iff, ← disjoint_assoc, inf_comm]
exact disjoint_compl_right
refine' le_antisymm _ _
· rw [le_himp_iff, ← compl_compl_inf_distrib]
    exact compl_anti (compl_anti himp_inf_le)
· refine' le_compl_comm.1 ((compl_anti compl_sup_le_himp).trans _)
    rw [compl_sup_distrib, le_compl_iff_disjoint_right, disjoint_right_comm, ←
      le_compl_iff_disjoint_right]
    exact inf_himp_le
rw [sup_comm]
exact le_himp_iff
rw [← top_sdiff', sdiff_sdiff, sup_idem]
rw [← top_sdiff', sdiff_le_iff, codisjoint_iff_le_sup]
rw [hnot_le_iff_codisjoint_right, hnot_le_iff_codisjoint_left]
rw [hnot_le_iff_codisjoint_left, codisjoint_bot, top_le_iff]
rw [← top_sdiff', sdiff_self]
refine' ((hnot_inf_distrib _ _).ge.trans <| hnot_anti le_hnot_inf_hnot).antisymm' _
rw [hnot_le_iff_codisjoint_left, codisjoint_assoc, codisjoint_hnot_hnot_left_iff,
    codisjoint_left_comm, codisjoint_hnot_hnot_left_iff, ← codisjoint_assoc, sup_comm]
exact codisjoint_hnot_right
refine' le_antisymm _ _
· refine' hnot_le_comm.1 ((hnot_anti sdiff_le_inf_hnot).trans' _)
    rw [hnot_inf_distrib, hnot_le_iff_codisjoint_right, codisjoint_left_comm, ←
      hnot_le_iff_codisjoint_right]
    exact le_sdiff_sup
· rw [sdiff_le_iff, ← hnot_hnot_sup_distrib]
    exact hnot_anti (hnot_anti le_sup_sdiff)
rw [inf_comm]
exact sdiff_le_iff
change f _ ≤ _
rw [map_top]
exact le_top
change f _ ≤ _ ↔ f _ ≤ _
erw [map_himp, map_inf, le_himp_iff]
change f _ ≤ _
rw [map_bot]
exact bot_le
change f _ ≤ _ ↔ f _ ≤ _
erw [map_sdiff, map_sup, sdiff_le_iff]
change f _ ≤ _
rw [map_bot]
exact bot_le
erw [map_himp, map_compl, map_bot, himp_bot]
change f _ ≤ _
rw [map_top]
exact le_top
erw [map_sdiff, map_hnot, map_top, top_sdiff']
rw [boundary, hnot_top, inf_bot_eq]
rw [boundary, hnot_inf_distrib, sup_hnot_self]
unfold boundary
rw [hnot_inf_distrib, inf_sup_left, inf_right_comm, ← inf_assoc]
rw [boundary, inf_sup_right]
exact
    sup_le_sup (inf_le_inf_left _ <| hnot_anti le_sup_left)
      (inf_le_inf_left _ <| hnot_anti le_sup_right)
simp only [boundary, sup_inf_left, sup_inf_right, sup_right_idem, le_inf_iff, sup_assoc,
    @sup_comm _ _ _ a]
refine ⟨⟨⟨?_, ?_⟩, ⟨?_, ?_⟩⟩, ?_, ?_⟩ <;> try { exact le_sup_of_le_left inf_le_left } <;>
    refine inf_le_of_right_le ?_
· rw [hnot_le_iff_codisjoint_right, codisjoint_left_comm]
    exact codisjoint_hnot_left
· refine le_sup_of_le_right ?_
    rw [hnot_le_iff_codisjoint_right]
    exact codisjoint_hnot_right.mono_right (hnot_anti inf_le_left)
rw [@sup_comm _ _ a, inf_comm]
exact boundary_le_boundary_sup_sup_boundary_inf_left
rw [boundary, hnot_boundary, inf_top_eq]
rw [boundary, sup_inf_left, hnot_sup_self, inf_top_eq, sup_eq_right]
exact hnot_hnot_le
rw [boundary, h, inf_top_eq]
rw [Nat.succ_pred_eq_of_pos]
exact h.right
exact lt_of_le_of_lt (Nat.zero_le lo) h.left
decide
apply Nat.div_lt_self h
decide
simp_wf
exact Nat.succ_lt_succ $ lt_of_le_of_lt (Nat.mod_le _ _) x.property
simp_wf
simp only [SizeOf.sizeOf]
rw [Int.natAbs_neg]
exact h
simp_wf
apply Prod.Lex.left
simp_all_arith
simp_wf
apply Prod.Lex.right
simp_all_arith
simp [Fin.ofNat, LE.le]
exact Nat.zero_le _
decide
apply Nat.div_le_self
        exact lt_of_lt_of_le h₁ h₂
        
    rand_nat_aux (r' / gen_mag - 1) v' g'
rw [congr_fun LinearOrder.min_def a, minDefault]
rw [congr_fun LinearOrder.max_def a, maxDefault]
apply eq_min
· apply le_trans
    apply min_le_left
    apply min_le_left
· apply le_min
    apply le_trans
    apply min_le_left
    apply min_le_right
    apply min_le_right
· intro d h₁ h₂
    apply le_min
    apply le_min h₁
    apply le_trans h₂
    apply min_le_left
    apply le_trans h₂
    apply min_le_right
apply Eq.symm
apply eq_min (le_refl _) h
intros
assumption
apply eq_max
· apply le_trans
    apply le_max_left a b
    apply le_max_left
· apply max_le
    apply le_trans
    apply le_max_right a b
    apply le_max_left
    apply le_max_right
· intro d h₁ h₂
    apply max_le
    apply max_le h₁
    apply le_trans (le_max_left _ _) h₂
    apply le_trans (le_max_right _ _) h₂
apply Eq.symm
apply eq_max (le_refl _) h
intros
assumption
apply Nat.add_lt_add_left
assumption
simp [Nat.add_comm]
assumption
contradiction
contradiction
dsimp only [conv] <;> infer_instance
dsimp only [conv] <;> infer_instance
dsimp only [conv] <;> infer_instance
contradiction
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
intros
rfl
  -- `functor` is indeed a categorical functor
intros
rfl
intros
rfl
  -- applicative laws
intros <;> simp [(pure_seq_eq_map _ _).symm, seq_assoc, map_pure, seq_pure]
simp [pure_seq_eq_map]
intros
rfl
intros
rfl
  -- monad laws
intros <;> rw [← bind_map_eq_seq] <;> simp [pure_bind]
intros <;> rw [← bind_pure_comp_eq_map] <;> simp [pure_bind]
intros <;> rw [← bind_map_eq_seq] <;> simp [map_pure, bind_pure_comp_eq_map]
intros <;> simp [(bind_pure_comp_eq_map _ _).symm, (bind_map_eq_seq _ _).symm, bind_assoc, pure_bind]
rw [bind_pure_comp_eq_map] <;> simp [id_map]
simp [show f = g from funext h]
simp [show f = g from funext h]
refine' { .. } <;> intros <;> rfl
cases x <;> cases x' <;> simp [show x = x' from funext h]
apply bind_ext_congr <;> intro a <;> cases a <;> simp [StateT.bind, StateT.run]
rw [← bind_pure_comp_eq_map _ (x.run st)]
change (x >>= pure ∘ f).run st = _
simp
delta StateT.adapt <;> rfl
intros <;> apply StateT.ext <;> intro <;> simp <;> erw [id_map]
intros
apply StateT.ext
simp
intros
apply StateT.ext
simp [bind_assoc]
cases x <;> cases x' <;> simp_all
rw [← bind_pure_comp_eq_map _ x.run]
change x.run >>= ExceptT.bindCont (pure ∘ f) = _
apply bind_ext_congr
intro a <;> cases a <;> simp [ExceptT.bindCont, Except.map]
intros
apply ExceptT.ext
simp only [ExceptT.run_map]
rw [map_ext_congr, id_map]
intro a
cases a <;> rfl
intros
apply ExceptT.ext
simp only [ExceptT.run_map, ExceptT.run_bind]
rw [bind_ext_congr, bind_pure_comp_eq_map]
intro a
cases a <;> rfl
intros
apply ExceptT.ext
simp only [ExceptT.run_bind, bind_assoc]
rw [bind_ext_congr]
intro a
cases a <;> simp [ExceptT.bindCont]
intros <;> apply ExceptT.ext <;> simp [ExceptT.bindCont]
cases x <;> cases x' <;> simp [show x = x' from funext h]
rw [← bind_pure_comp_eq_map _ (x.run r)] <;> rfl
intros <;> apply ReaderT.ext <;> intro <;> simp
intros <;> apply ReaderT.ext <;> intro <;> simp
intros <;> apply ReaderT.ext <;> intro <;> simp [bind_assoc]
cases x <;> cases x' <;> simp_all
rw [← bind_pure_comp_eq_map _ x.run]
change x.run >>= OptionT.bindCont (pure ∘ f) = _
apply bind_ext_congr
intro a <;> cases a <;> simp [OptionT.bindCont, Option.map, Option.bind]
intros
apply OptionT.ext
simp only [OptionT.run_map]
rw [map_ext_congr, id_map]
intro a
cases a <;> rfl
intros
apply OptionT.ext
simp only [OptionT.run_bind, bind_assoc]
rw [bind_ext_congr]
intro a
cases a <;> simp [OptionT.bindCont]
intros <;> apply OptionT.ext <;> simp [OptionT.bindCont]
unfold bodd bodd_div2 <;> cases bodd_div2 n <;> cases fst <;> rfl
intros <;> cases b <;> rfl
intros <;> cases b <;> rfl
unfold bodd div2 bodd_div2 <;> cases bodd_div2 n <;> cases fst <;> rfl
simp
refine' Eq.trans _ (congr_arg succ (bodd_add_div2 n))
cases bodd n <;> simp [cond, not]
· rw [Nat.add_comm, Nat.zero_add]
· rw [succ_mul, Nat.add_comm 1, Nat.zero_add]
decide
rw [Nat.zero_add]
cases b
apply bit0_val
apply bit1_val
rw [← bit_decomp n] <;> apply h
rw [n0] <;> exact z
rw [binary_rec]
rfl
rw [bit_val] <;> simp <;> cases b <;> cases bodd n <;> rfl
decide
simp [shiftl']
rw [Nat.add_comm, shiftr_add]
simp [shiftr, div2_bit]
apply shiftl'_sub (Nat.le_of_succ_le_succ h)
dsimp [shiftr] <;> rw [div2_bit]
cases f ff tt <;> rfl
cases f tt ff <;> rfl
unfold bitwise <;> rw [binary_rec_zero]
unfold bitwise <;> apply bit_cases_on m <;> intros <;> rw [binary_rec_eq, binary_rec_zero] <;> exact bitwise_bit_aux h
rw [bitwise_zero_left] <;> cases f ff tt <;> rfl
cases a <;> assumption
cases a <;> assumption
funext m n
revert n
dsimp [Function.swap]
apply binary_rec _ (fun a m' IH => _) m <;> intro n
· rw [bitwise_zero_left, bitwise_zero_right]
    exact h
apply bit_cases_on n <;> intro b n'
rw [bitwise_bit, bitwise_bit, IH] <;> exact h
simp [gcd]
simp [gcd]
simp [gcd]
cases x <;> simp [gcd, succ_ne_zero]
cases n <;> simp [gcd, mod_self]
cases n <;> simp [gcd]
cases m <;> simp [gcd]
rw [add_succ, add_succ, add_assoc] <;> rfl
simp (config := { contextual := true }) [Nat.zero_add]
simp [succ_add] at h
assumption
simp [Nat.zero_add]
rw [mul_succ, zero_mul]
simp [Nat.zero_mul]
rw [Nat.zero_mul, Nat.mul_zero]
simp [mul_succ, succ_mul, mul_comm n m]
simp [mul_succ, Nat.left_distrib, mul_assoc n m k]
rw [Nat.mul_comm, Nat.mul_one]
simp [succ_add, add_succ]
rw [succ_mul]
intro h
exact Or.inr (Nat.eq_zero_of_add_eq_zero_left h)
cases n
exact Or.inl rfl
exact Or.inr (succ_pos _)
rw [Nat.add_assoc, hw]
rw [Nat.add_comm n k, Nat.add_comm m k]
apply Nat.add_le_add_left h
rw [Nat.add_assoc] at hw
apply Nat.add_left_cancel hw
rw [Nat.add_comm _ k, Nat.add_comm _ k]
apply Nat.le_of_add_le_add_left
rw [HEq] at h
assumption
rw [Nat.add_comm] <;> exact Nat.lt_add_of_pos_right h
rw [← Nat.left_distrib, hl]
contradiction
contradiction
unfold bit0 at h
simp [add_one, add_succ, succ_add] at h
have aux : n + n = m + m := h
rw [aux]
simp [Nat.bit1_eq_succ_bit0] at h
rw [h]
injection this
  Nat.bit0_inj this
contradiction
rw [Nat.bit1_succ_eq]
apply succ_lt_succ
apply zero_lt_succ
contradiction
rw [Nat.bit0_succ_eq]
apply succ_lt_succ
apply zero_lt_succ
rw [succ_add]
assumption
cases n <;> simp
have : a = b := h
rw [this]
rw [Nat.sub_zero]
rw [succ_sub_succ, sub_self n]
rw [Nat.add_zero, Nat.add_zero]
rw [add_succ, add_succ, succ_sub_succ, add_sub_add_right n k m]
rw [Nat.add_comm k n, Nat.add_comm k m, Nat.add_sub_add_right]
rw [Nat.add_sub_add_left, Nat.sub_zero]
rw [Nat.add_zero, Nat.sub_zero]
rw [add_succ, Nat.sub_succ, Nat.sub_succ, sub_sub n m k]
rw [Nat.add_sub_add_left, Nat.zero_sub]
rw [← Nat.add_sub_cancel x k, Nat.sub_le_sub_iff_right h, Nat.add_sub_cancel]
apply Nat.sub_lt _ h₀
apply lt_of_lt_of_le h₀ h₁
rw [← hk, Nat.sub_self_add]
rw [Nat.sub_zero] at H
simp [H]
simp [Nat.add_sub_add_right] at H
exact H
rw [← hk, Nat.add_sub_cancel_left]
rw [Nat.add_comm, Nat.add_sub_of_le h]
rw [← hl, Nat.add_sub_cancel_left, Nat.add_comm k, ← Nat.add_assoc, Nat.add_sub_cancel]
rw [c_eq.symm, Nat.sub_add_cancel ab]
rw [a_eq, Nat.add_sub_cancel]
simp [Nat.sub_eq_zero_of_le H'] at H
contradiction
rw [Nat.sub_sub, Nat.sub_sub, add_succ, succ_sub_succ]
rw [Nat.sub_sub, Nat.sub_sub, Nat.add_comm]
rw [← hk, Nat.add_sub_cancel_left, ← add_succ, Nat.add_sub_cancel_left]
rw [Nat.zero_add, Nat.sub_add_cancel (le_of_lt h)]
exact h
rw [Nat.sub_sub]
apply Nat.sub_lt
apply lt_of_lt_of_le (Nat.zero_lt_succ _) h
rw [Nat.add_comm]
apply Nat.zero_lt_succ
simp [Nat.zero_sub, pred_zero, Nat.zero_mul]
rw [pred_succ, succ_mul, Nat.add_sub_cancel]
rw [Nat.mul_comm, mul_pred_left, Nat.mul_comm]
simp [Nat.sub_zero, Nat.zero_mul]
rw [Nat.sub_succ, mul_pred_left, mul_sub_right_distrib, succ_mul, Nat.sub_sub]
rw [Nat.mul_comm, Nat.mul_sub_right_distrib, Nat.mul_comm m n, Nat.mul_comm n k]
rw [Nat.mul_sub_left_distrib, Nat.right_distrib, Nat.right_distrib, Nat.mul_comm b a, Nat.add_comm (a * a) (a * b),
    Nat.add_sub_add_left]
rw [← add_one, ← add_one]
simp [Nat.right_distrib, Nat.left_distrib, Nat.add_left_comm, Nat.mul_one, Nat.one_mul, Nat.add_assoc]
rw [min_eq_right h]
rw [Nat.sub_eq_zero_of_le (le_of_not_ge h), min_eq_left (le_of_not_ge h), Nat.sub_self]
rw [sub_eq_sub_min, Nat.sub_add_cancel (min_le_left n m)]
cases x
· cases y <;> rfl
cases y
· rfl
refine' if_congr Iff.rfl (mod_core_congr _ _) rfl <;> simp [Nat.sub_le]
rw [b0, Nat.sub_zero]
rw [mod_def, if_pos (And.intro h₂ h)]
rw [mod_eq_sub_mod (le_refl _), Nat.sub_self, zero_mod]
decide
decide
rw [mod_eq_of_lt xlty] <;> rfl
rw [y0, mod_zero] <;> rfl
rw [mod_eq_sub_mod (Nat.le_add_left _ _), Nat.add_sub_cancel]
rw [Nat.add_comm, add_mod_right]
rw [Nat.mul_comm, add_mul_mod_self_left]
rw [← Nat.zero_add (m * n), add_mul_mod_self_left, zero_mod]
rw [Nat.mul_comm, mul_mod_right]
rw [y0, Nat.mul_zero, mod_zero, mod_zero]
rw [z0, Nat.zero_mul, Nat.zero_mul, Nat.zero_mul, mod_zero]
rw [mod_eq_sub_mod yn, mod_eq_sub_mod (Nat.mul_le_mul_left z yn), ← Nat.mul_sub_left_distrib] <;>
              exact IH _ (Nat.sub_lt (lt_of_lt_of_le y0 yn) y0)
rw [mod_eq_of_lt yn, mod_eq_of_lt (Nat.mul_lt_mul_of_pos_left yn z0)]
rw [Nat.mul_comm x z, Nat.mul_comm y z, Nat.mul_comm (x % y) z] <;> apply mul_mod_mul_left
rw [mul_succ] at h₁
apply Nat.le_trans _ h₁
apply Nat.le_add_right _ n
apply @Nat.le_of_add_le_add_right (n * k)
rw [Nat.sub_add_cancel h₂]
simp [mul_succ, Nat.add_comm] at h₁
simp [h₁]
cases x
· cases y <;> rfl
cases y
· rfl
refine' if_congr Iff.rfl (congr_arg (· + 1) _) rfl
refine' div_core_congr _ _ <;> simp [Nat.sub_le]
apply Nat.sub_lt _ h.left
apply lt_of_lt_of_le h.left h.right
rw [div_def]
simp [lt_irrefl]
simp [Nat.div_zero, n.zero_le]
rw [mod_add_div]
simp [Nat.div_zero, m.zero_le]
rw [Nat.one_mul]
rw [div_def a, if_pos]
constructor <;> assumption
rw [div_def a, if_neg]
intro h₁
apply not_le_of_gt h₀ h₁.right
rw [← not_le, not_congr (le_div_iff_mul_le Hk), not_le]
apply Nat.le_of_add_le_add_right
rw [Nat.sub_add_cancel h₂, Nat.add_comm]
rw [mul_succ] at h₁
apply h₁
simp [m.zero_le, Nat.zero_mul]
rw [div_eq_sub_div H (Nat.le_add_left _ _), Nat.add_sub_cancel]
rw [Nat.add_comm, add_div_right x H]
induction n <;> simp [*, mul_succ, Nat.mul_zero]
rw [Nat.mul_comm, mul_div_right _ H]
rw [Nat.mul_comm, add_mul_div_left _ _ H]
rw [Nat.mul_comm, Nat.mul_div_cancel _ H]
rw [H2, Nat.mul_div_cancel _ H1]
rw [H2, Nat.mul_div_cancel_left _ H1]
rw [hn, Nat.mul_zero] at hi lo <;> exact absurd lo (not_le_of_gt hi)
  le_antisymm (le_of_lt_succ <| (Nat.div_lt_iff_lt_mul npos).2 hi) ((Nat.le_div_iff_mul_le npos).2 lo)
rw [n0, Nat.zero_mul] at h₁ <;> exact Nat.not_lt_zero _ h₁
  apply Nat.div_eq_of_lt_le
  · rw [Nat.mul_sub_right_distrib, Nat.mul_comm]
    apply Nat.sub_le_sub_left
    exact (div_lt_iff_lt_mul npos).1 (lt_succ_self _)
    
  · change succ (pred (n * p - x)) ≤ succ (pred (p - x / n)) * n
    rw [succ_pred_eq_of_pos (Nat.sub_pos_of_lt h₁), succ_pred_eq_of_pos (Nat.sub_pos_of_lt _)]
    · rw [Nat.mul_sub_right_distrib, Nat.mul_comm]
      apply Nat.sub_le_sub_left
      apply div_mul_le_self
      
    · apply (div_lt_iff_lt_mul npos).2
      rwa [Nat.mul_comm]
rw [← Nat.div_div_eq_div_mul, Nat.mul_div_cancel_left _ H]
simp [h₃, h₄, Nat.mul_assoc]
simp [Nat.left_distrib, hd, he]
rw [Nat.mul_sub_left_distrib, ← he, Nat.add_sub_cancel_left]
rw [Nat.add_comm] <;> exact Nat.dvd_add_iff_right h
rw [Nat.sub_add_cancel H] <;> exact h₁
rw [m0] at H1 <;> rw [Nat.eq_zero_of_zero_dvd H1] at H2 <;> exact lt_irrefl _ H2
decide
decide
rw [H1, mul_mod_right]
infer_instance
rw [Nat.mul_comm, Nat.mul_div_cancel' H]
rw [h, Nat.div_zero, Nat.div_zero, Nat.mul_zero]
rw [Nat.div_mul_cancel H]
rw [Nat.mul_assoc] at H1 <;> exact ⟨_, Nat.eq_of_mul_eq_mul_left kpos H1⟩
rw [Nat.mul_comm m k, Nat.mul_comm n k] at H <;> exact dvd_of_mul_dvd_mul_left kpos H
rw [Nat.add_right_comm] <;> exact kn
rw [e] <;> exact pm
        IH _ ⟨rfl, this⟩ fun n h => this n <| Nat.le_of_succ_le_succ h
rw [← h] at h₂
change 0 < a at h₁
have := le_of_lt h₁
exact absurd (le_of_lt h₁) (not_le_of_gt (Int.neg_of_neg_pos h₂))
simp [neg_succ_of_nat_coe, Int.ofNat_succ, Int.ofNat_add, Int.ofNat_one, Int.add_comm, Int.add_left_comm,
        Int.neg_add, Int.add_right_neg, Int.zero_add]
rw [Int.zero_add, Int.coe_nat_eq]
have : ofNat n + ofNat m = ofNat (n + m) := rfl
simp [nat_abs_of_nat_core, this]
have : -[n+1] + -[m+1] = -[Nat.succ (n + m)+1] := rfl
simp [nat_abs_of_neg_succ_of_nat, this, Nat.succ_add, Nat.add_succ]
rw [← h]
apply Int.nat_abs_bit0
rw [Int.nat_abs_add_nonneg (Int.bit0_nonneg h) (le_of_lt Int.zero_lt_one), Int.nat_abs_bit0]
rw [← h₂]
apply Int.nat_abs_bit1_nonneg h₁
unfold sub_nat_nat
rw [h]
unfold sub_nat_nat._match_1
unfold sub_nat_nat
rw [h]
unfold sub_nat_nat._match_1
simp [H]
rw [← Int.neg_neg a, ← Int.neg_neg b, h]
dsimp only [sub_nat_nat]
rw [Nat.sub_eq_zero_of_le]
dsimp only [sub_nat_nat._match_1]
rw [Nat.add_sub_cancel_left]
apply Nat.le_add_right
rw [Nat.add_assoc]
rw [Nat.add_sub_cancel_left]
simp [Nat.add_comm, Nat.add_left_comm]
simp [Nat.add_comm, Nat.add_left_comm]
have : n - m = succ (pred (n - m)) := Eq.symm (succ_pred_eq_of_pos (Nat.sub_pos_of_lt h))
rw [sub_nat_nat_of_sub_eq_succ this]
simp [Nat.add_comm]
simp [Nat.add_comm]
rw [sub_nat_nat_add_add]
rw [Nat.sub_add_cancel h]
simp [Nat.add_assoc]
simp [sub_nat_nat_add]
simp [add_succ]
rw [Int.add_comm, sub_nat_nat_add_neg_succ_of_nat]
simp [add_succ, succ_add, Nat.add_comm]
rw [Int.add_comm, ← add_assoc_aux1, Int.add_comm (of_nat k), add_assoc_aux1, Int.add_comm b]
rw [Int.add_comm, Int.add_comm a, ← add_assoc_aux1, Int.add_comm a, Int.add_comm (of_nat k)]
rw [Int.add_comm, ← add_assoc_aux2, Int.add_comm (of_nat n), ← add_assoc_aux2, Int.add_comm -[m+1]]
rw [Int.add_comm, Int.add_comm (of_nat m), Int.add_comm (of_nat m), ← add_assoc_aux2, Int.add_comm -[k+1]]
simp [add_succ, Nat.add_comm, Nat.add_left_comm, neg_of_nat_of_succ]
rw [sub_nat_nat_of_sub_eq_zero, Nat.sub_self, of_nat_zero]
rw [Nat.sub_self]
simp
simp
rw [Int.add_comm, Int.add_left_neg]
simp [Nat.mul_comm]
simp [Nat.mul_comm]
simp [Nat.mul_comm]
simp [Nat.mul_comm]
unfold neg_of_nat
simp
rw [Int.mul_comm]
simp [of_nat_mul_neg_of_nat, Nat.mul_comm]
unfold neg_of_nat
simp
rw [Int.mul_comm]
simp [neg_succ_of_nat_mul_neg_of_nat, Nat.mul_comm]
simp [Nat.mul_assoc]
simp [Nat.mul_assoc]
simp [Nat.mul_assoc]
simp [Nat.mul_assoc]
simp [Nat.mul_assoc]
simp [Nat.mul_assoc]
simp [Nat.mul_assoc]
simp [Nat.mul_assoc]
cases m
· cases n
    · simp
      rfl
      
    simp [Nat.zero_add]
    rfl
cases n
· simp
    rfl
simp [Nat.succ_add]
rfl
simp [Nat.left_distrib]
simp [neg_of_nat_eq_sub_nat_nat_zero]
rw [← sub_nat_nat_add]
rfl
simp [neg_of_nat_eq_sub_nat_nat_zero]
rw [Int.add_comm, ← sub_nat_nat_add]
rfl
simp
rw [← Nat.left_distrib, add_succ, succ_add]
simp [Nat.mul_comm]
rw [← Nat.right_distrib, Nat.mul_comm]
simp [neg_of_nat_eq_sub_nat_nat_zero]
rw [Int.add_comm, ← sub_nat_nat_add]
rfl
simp [neg_of_nat_eq_sub_nat_nat_zero]
rw [← sub_nat_nat_add]
rfl
simp
rw [← Nat.left_distrib, add_succ, succ_add]
rw [Int.mul_comm, Int.mul_add]
simp [Int.mul_comm]
delta sub_nat_nat <;> rw [Nat.sub_eq_zero_of_le h] <;> rfl
rw [← Int.add_assoc, Int.add_comm a, Int.add_assoc]
rw [h]
rw [Int.add_assoc, Int.add_comm (-a), Int.add_assoc, Int.add_assoc, ← Int.add_assoc b]
rw [Int.add_right_neg, Int.zero_add, Int.add_right_neg, Int.add_zero]
rw [Int.add_left_neg, Int.zero_add]
rw [Int.sub_eq_add_neg, ← Int.neg_add] <;> rfl
simp [Int.ofNat_add, Int.add_left_comm, Int.add_assoc, Int.add_right_neg]
rfl
rw [Int.ofNat_add, Int.ofNat_add, Int.ofNat_one, Int.negSucc_eq, Int.sub_eq_add_neg, Int.neg_add, Int.neg_add,
      Int.neg_add, ← Int.add_assoc, ← Int.add_assoc, Int.add_right_neg, Int.zero_add]
rw [Nat.add_sub_cancel_left] <;> rfl
rw [Nat.add_assoc, Nat.sub_eq_zero_of_le (Nat.le_add_right _ _)] <;> rfl
rw [Nat.one_mul]
rw [Nat.one_mul]
rw [Int.mul_comm, Int.one_mul]
rw [Nat.one_mul]
rfl
rw [Nat.one_mul]
rfl
rw [h] <;> trivial
rw [← h, Int.add_comm] <;> simp
rw [← h₁, Int.add_comm]
simp
simp [Int.add_comm]
rw [← hk]
rfl
have t := le.dest_sub h
simp at t
exact t
rw [Nat.add_comm] at h <;> exact h.symm
simp [Int.coe_nat_eq, Int.add_comm, Int.add_left_comm]
rfl
rw [← hn, Int.add_assoc, Int.add_comm 1]
rfl
rw [lt_iff_add_one_le, ← Int.ofNat_succ, coe_nat_le_coe_nat_iff]
rfl
apply le.intro
rw [← hm, ← hn, Int.add_assoc]
rfl
rw [Int.ofNat_add, ← Int.add_assoc, hn, hm, Int.add_zero a]
rw [← hn, this, Int.ofNat_zero, Int.add_zero a]
rw [hn, Int.add_zero]
rw [this] at h
exact h
rw [← hn, this, Int.ofNat_zero, Int.add_zero]
rw [this] at hn
exact hn
rw [Int.add_assoc, hn]
rw [Int.add_left_cancel HEq] at h
exact h
rw [← hn, ← hm]
simp [Int.zero_add]
rw [← hn, ← hm]
simp [Int.ofNat_zero]
rw [← Int.ofNat_mul]
simp [Nat.mul_succ, Nat.add_succ, Nat.succ_add]
let ⟨n, e⟩ := eq_ofNat_of_zero_le h
rw [e] <;> rfl
rw [eq_nat_abs_of_zero_le h] <;> rfl
let ⟨m, h⟩ := eq_ofNat_of_zero_le h
contradiction
rw [h, Int.neg_neg]
rw [← Int.add_assoc, Int.add_left_neg, Int.zero_add]
rw [← Int.add_assoc, Int.add_right_neg, Int.zero_add]
rw [Int.add_assoc, Int.add_right_neg, Int.add_zero]
rw [Int.add_assoc, Int.add_left_neg, Int.add_zero]
rw [Int.sub_eq_add_neg, Int.add_right_neg]
rw [h, Int.sub_self]
rw [Int.zero_add]
rw [← Int.add_zero (-a), ← h, ← Int.add_assoc, Int.add_left_neg, Int.zero_add]
rw [← Int.add_mul, Int.add_right_neg, Int.zero_mul]
rw [← Int.mul_add, Int.add_right_neg, Int.mul_zero]
simp
simp
simp
simp
have : -a + (a + b) ≤ -a + (a + c) := Int.add_le_add_left h _
simp [Int.neg_add_cancel_left] at this
assumption
have : -a + (a + b) < -a + (a + c) := Int.add_lt_add_left h _
simp [Int.neg_add_cancel_left] at this
assumption
rw [Int.add_comm a c, Int.add_comm b c]
exact Int.add_lt_add_left h c
rw [Int.add_comm b a, Int.add_comm b c]
assumption
rw [Int.add_comm b a, Int.add_comm b c]
assumption
rw [Int.sub_eq_add_neg, Int.add_assoc, ← Int.sub_eq_add_neg]
simp [Int.neg_neg] at this
assumption
rw [Int.add_comm] at h
exact Int.le_add_of_sub_left_le h
rw [Int.add_comm]
exact Int.sub_left_le_of_le_add h
rw [Int.add_comm] at h
exact Int.le_add_of_sub_right_le h
rw [Int.add_comm] at h
exact Int.neg_add_le_left_of_le_add h
rw [Int.add_comm] at h
exact Int.lt_add_of_sub_left_lt h
rw [Int.add_comm]
exact Int.sub_left_lt_of_lt_add h
rw [Int.add_comm] at h
exact Int.lt_add_of_sub_right_lt h
rw [Int.add_comm] at h
exact Int.neg_add_lt_left_of_lt_add h
rw [Int.add_zero]
rw [Int.add_zero]
have : 0 < b - a := Int.sub_pos_of_lt h₁
have : 0 < c * (b - a) := Int.mul_pos h₂ this
rw [Int.mul_sub] at this
exact Int.lt_of_sub_pos this
have : 0 < b - a := Int.sub_pos_of_lt h₁
have : 0 < (b - a) * c := Int.mul_pos this h₂
rw [Int.sub_mul] at this
exact Int.lt_of_sub_pos this
rw [← nat_abs_neg, nat_abs_of_nonneg (Int.neg_nonneg_of_nonpos H)]
rw [h, sign_zero]
have : 0 < a * b := Int.mul_pos hlt₁ hlt₂
rw [h] at this
exact absurd this (lt_irrefl _)
have : 0 > a * b := Int.mul_neg_of_pos_of_neg hlt₁ hgt₂
rw [h] at this
exact absurd this (lt_irrefl _)
have : 0 > a * b := Int.mul_neg_of_neg_of_pos hgt₁ hlt₂
rw [h] at this
exact absurd this (lt_irrefl _)
have : 0 < a * b := Int.mul_pos_of_neg_of_neg hgt₁ hgt₂
rw [h] at this
exact absurd this (lt_irrefl _)
rw [Int.sub_mul, this]
rw [Int.mul_sub, this]
rw [Int.one_mul, H]
rw [Int.mul_one, H]
subst eq₂
exact iha a₁ h b₁
subst eq₂
have new_eq₃ := eq_of_heq eq₃
subst new_eq₃
exact ihb b₁ h
cases a <;> cases b <;> simp [Fin.add]
cases a <;> cases b <;> simp [Fin.mul]
cases a <;> cases b <;> rfl
cases a <;> cases b <;> simp [Fin.mod]
cases a <;> cases b <;> simp [Fin.div]
cases a <;> cases b <;> simp [Fin.Lt]
cases a <;> cases b <;> simp [Fin.Le]
have aux₁ := vne_of_ne h₂
dsimp at aux₁
rw [val_zero] at aux₁
exact aux₁
simp
rw [Nat.sub_add_cancel] <;> assumption
simp [*, sub_sub_cancel]
apply Nat.sub_lt_of_pos_le
apply Nat.zero_lt_succ
assumption
simp [read, write]
intro h <;> simp [read, write, h]
cases a <;> cases b <;> congr <;> exact funext h
cases a
cases b
congr
funext i
cases i
apply h
simp [DArray.beqAux] at h₂
assumption
unfold DArray.beq
intro h
have : ∀ (j : Nat) (h : j < n), a.read ⟨j, h⟩ = b.read ⟨j, h⟩ := of_beq_aux_eq_tt n (le_refl _) h
apply DArray.ext' this
simp [DArray.beqAux] at h₂
contradiction
simp [DArray.beqAux] at h₂
assumption
simp [read', h]
simp [write', h]
unfold Array'
infer_instance
simp
simp
apply propext
apply Iff.intro
· exact fun h => h.2
· intro hba
    constructor
    · intro hab
      exact absurd (trans hab hba) (irrefl a)
      
    · assumption
simp
induction s <;> rfl
cases it <;> cases it_snd <;> simp [iterator.next, iterator.next_to_string, String.length, Nat.add_sub_cancel_left]
cases it <;>
    cases it_snd <;>
      simp [iterator.has_next, iterator.next_to_string, String.length, Nat.zero_lt_one_add, Nat.add_comm, false_imp_iff]
decide
intro c
delta is_whitespace
infer_instance
intro c
delta is_upper
infer_instance
intro c
delta is_lower
infer_instance
intro c
delta is_alpha
infer_instance
intro c
delta is_digit
infer_instance
intro c
delta is_alphanum
infer_instance
intro c
delta is_punctuation
infer_instance
intro h <;> unfold of_nat <;> rw [dif_pos h]
intro h <;> unfold of_nat <;> rw [dif_neg h]
intro h <;> apply eq_of_veq <;> rw [val_of_nat_eq_of_not_is_valid h] <;> rfl
apply ne_of_vne
rw [val_of_nat_eq_of_is_valid h₂, val_of_nat_eq_of_is_valid h₃]
assumption
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
contradiction
contradiction
cases b <;> simp
cases b <;> simp
cases a <;> cases b <;> simp
cases a <;> cases b <;> simp
cases a <;> simp
cases a <;> cases b <;> simp
cases a <;> cases b <;> simp
cases a <;> simp
simp
simp
simp
simp
decide
decide
decide
decide
intro α β f l
induction l <;> simp_all [(· <$> ·), (· >>= ·), pure]
intros
simp [pure, (· >>= ·)]
simp [List.not_bex_nil]
rw [partition_eq_filter_filter] at e
injection e
subst large
subst small
constructor <;> exact Nat.succ_le_succ (length_le_of_sublist (filter_sublist _))
rw [qsort, WellFounded.fix_eq, qsort.F]
induction t <;> simp [*]
induction s <;> simp [*]
induction s
· show length t = 0 + length t
    · rw [Nat.zero_add]
· simp [*, Nat.add_comm, Nat.add_left_comm]
induction n <;> simp [*] <;> rfl
cases l <;> rfl
intro l₁ <;> induction l₁ <;> intros <;> simp [*]
induction l <;> simp [*]
induction l <;> simp [*]
induction l <;> simp [*]
simp [join, List.bind]
simp [join, List.bind]
induction s <;> simp [*, or_assoc']
induction l <;> intros
rfl
contradiction
induction l <;> intros <;> contradiction
induction l₁ <;> intro l₂ <;> cases l₂ <;> simp [*, add_one, min_succ_succ, Nat.zero_min, Nat.min_zero]
simp [Nat.zero_min]
simp [Nat.min_zero]
simp [*, Nat.min_succ_succ, add_one]
simp [min_le_left]
simp [remove_nth]
have : i < length xs := lt_of_succ_lt_succ h
dsimp [remove_nth] <;>
      rw [length_remove_nth xs i this, Nat.sub_add_cancel (lt_of_le_of_lt (Nat.zero_le _) this)] <;> rfl
simp [pa] <;> apply sublist.cons2 <;> apply filter_sublist l
simp [pa] <;> apply sublist.cons <;> apply filter_sublist l
unfold Smt.store Smt.select <;> rw [if_pos] <;> rfl
intros <;> unfold Smt.store Smt.select <;> rw [if_neg] <;> assumption
apply funext
intro input
apply funext
intro pos
dsimp only [Parser.bind]
cases p input Pos <;> exact rfl
apply funext
intro input
apply funext
intro pos
dsimp only [Parser.bind]
cases p input Pos <;> try dsimp only [bind]
cases q result input pos_1 <;> try dsimp only [bind]
all_goals rfl
unfold Vector
infer_instance
contradiction
contradiction
rw [h] <;> exact i.2
simp [*]
simp [*]
simp [*]
simp [*]
simp [*]
rw [l.length_remove_nth i.1] <;> rw [p] <;> exact i.2
simp [*]
simp [*]
cases v
rfl
cases v
cases w
rfl
cases v
rfl
cases v
rfl
intros
simp
rw [h₂, h₁, h₁ (ys List.nil)]
simp
cases l <;> simp
intros
funext x
simp [l_invariant x]
simp
simp
cases l₁ <;> cases l₂ <;> simp <;> rw [l₁_invariant]
cases l <;> simp
cases l <;> simp <;> rw [l_invariant]
cases b <;> unfold read read' <;> simp [Array'.read_eq_read']
cases b <;> unfold write write' <;> simp [Array'.write_eq_write']
decide
exact if matches? then
        $(mkInstantiateMVars decls decls)
      else
        return $(mkIsDefEqResult false decls)
intro h
cases h with
        | inl h => exact Or.inl h
        | inr h => exact Or.inr ($(orChange (ps1::ps2)) h)
rw [Nat.add_comm]
exact Nat.lt_of_le_of_lt (Nat.zero_le _) (Nat.lt_succ_self _)
simp
rfl
simp
simp
simp
exact 1
exact 2
assumption
apply id <;> trivial
cases () with apply id <;> apply id
  | unit => trivial
cases () with (apply id; apply id)
  | unit => trivial
cases () with apply id <;> apply id
  | unit => trivial
trivial <;> done
rw [← and_assoc, ← and_assoc, @and_comm a b]
simp only [and_left_comm, and_comm]
rfl
simp only [and_left_comm, and_comm]
rfl
rw [← and_assoc, @and_right_comm a, and_assoc]
rw [and_and_and_comm, and_self]
rw [and_and_and_comm, and_self]
rw [@Iff.comm p, and_iff_left_iff_imp]
rw [and_comm, iff_self_and]
simp [ha] at h
exact h
simp only [and_comm, ← and_congr_right_iff]
rfl
rw [← or_assoc, ← or_assoc, @or_comm a b]
rw [or_assoc, or_assoc, @or_comm b]
rw [← or_assoc, @or_right_comm a, or_assoc]
rw [or_or_or_comm, or_self]
rw [or_or_or_comm, or_self]
simp only [or_left_comm, Or.comm]
rfl
rw [or_comm, or_iff_left_iff_imp]
simp [and_comm, and_or_left]
simp [or_comm, or_and_left]
simp [@eq_comm _ a']
exact fun a => And.comm
simp [And.comm]
simp [@eq_comm _ a']

-- this theorem is needed to simplify the output of `list.mem_cons_iff`
simp only [or_imp, forall_and, forall_eq]
rfl
simp only [or_and_right, exists_or, exists_eq_left]
rfl
simp [← and_assoc]
(conv in _=_ => rw [eq_comm])
simp
cases on an `Or
cases on an `Or
simp
simp [h]
rw [eq_false h, false_or]
exact (or_iff_right_of_imp fun hx x => (hx x).elim).symm
rw [@iff_def (¬a), @iff_def' a]
exact and_congr not_imp_not not_imp_not
rw [@iff_def (¬a), @iff_def (¬b)]
exact and_congr not_imp_comm imp_not_comm
rw [@iff_def a, @iff_def b]
exact and_congr imp_not_comm not_imp_comm
rw [iff_iff_implies_and_implies a b]
simp only [imp_iff_not_or, Or.comm]
rfl
rw [← not_or, not_not]
rw [← not_and, not_not]
simp only [ha, true_and, true_imp_iff]
rfl
simp only [ha, false_or, false_and, false_imp_iff]
rw [or_iff_not_imp_right, or_iff_not_imp_right]
exact imp_congr_right h
rw [or_iff_not_imp_left, or_iff_not_imp_left]
exact imp_congr_right h
cases propext (iff_of_true hp hq)
rfl
cases h
rfl
subst hx hy
rfl
split <;> rfl
congr <;> apply Subsingleton.elim
congr
exact Subsingleton.elim x y
exact decl_name%
exact decl_name%
exact decl_name%
rw [← of_real_nat_cast, of_real_re]
contradiction
rw [ne_eq, ← beq_iff_eq a b]
cases a == b <;> decide
intros
rfl
intros
rfl
intros
rfl
intros
rfl
intros
rfl
rw [← bind_pure_comp]
simp [pure_bind]
simp [← bind_pure_comp, bind_assoc, pure_bind]
intros
rw [← bind_map]
simp [pure_bind]
intros
rw [← bind_map]
simp [map_pure, bind_pure_comp]
simp [← bind_pure_comp, ← bind_map, bind_assoc, pure_bind]
simp [seqLeft_eq, ← bind_map, ← bind_pure_comp, pure_bind, bind_assoc]
rw [seqRight_eq, ← bind_map, ← bind_pure_comp, bind_assoc]
simp [pure_bind, id_map]
cases x <;> rfl
cases a <;> rfl
cases x <;> rfl
cases x <;> rfl
cases x <;> rfl
simp [← comp_map, Function.comp]
rw [← h, ← comp_map]
rfl
let ⟨x', hx⟩ := hx
refine ⟨(fun ⟨a, h⟩ => ⟨f a, hf h⟩) <$> x', ?_⟩
rw [← hx]
simp [← comp_map, Function.comp]
simp
match f, x, hf, hx with | _, _, ⟨f, rfl⟩, ⟨x, rfl⟩ => ?_
refine ⟨(fun ⟨a, h₁⟩ ⟨b, h₂⟩ => ⟨a b, H h₁ h₂⟩) <$> f <*> x, ?_⟩
simp only [← pure_seq]
simp [SatisfiesM, seq_assoc]
simp only [← pure_seq]
simp [seq_assoc, Function.comp]
match x, hx with | _, ⟨x, rfl⟩ => ?_
have g a ha := Classical.indefiniteDescription _ (hf a ha)
refine ⟨x >>= fun ⟨a, h⟩ => g a h, ?_⟩
simp [← bind_pure_comp]
congr
funext ⟨a, h⟩
simp [← (g a h).2, ← bind_pure_comp]
revert x
intro | some _, ⟨some ⟨_, h⟩, rfl⟩, _, rfl => exact h
revert x
intro | .ok _, ⟨.ok ⟨_, h⟩, rfl⟩, _, rfl => exact h
exact ⟨fun eq _ => eq ▸ rfl, funext⟩
simp
refine .trans ⟨fun ⟨f, eq⟩ => eq ▸ ?_, fun ⟨f, h⟩ => ?_⟩ Classical.skolem.symm
· refine ⟨fun s => (fun ⟨⟨a, h⟩, s'⟩ => ⟨⟨a, s'⟩, h⟩) <$> f s, fun s => ?_⟩
    rw [← comp_map, map_eq_pure_bind]; rfl
· refine ⟨fun s => (fun ⟨⟨a, s'⟩, h⟩ => ⟨⟨a, h⟩, s'⟩) <$> f s, funext fun s => ?_⟩
    show _ >>= _ = _; simp [map_eq_pure_bind, ← h]
cases o <;> rfl
rw [← Ordering.swap_inj, symm]
exact .rfl
rw [← Ordering.swap_inj, symm]
exact .rfl
have := @TransCmp.le_trans _ cmp _ z y x
simp [cmp_eq_gt] at *
exact this h₂ h₁
rw [cmp_eq_gt] at h₁ h₂ ⊢
exact lt_trans h₂ h₁
rw [← Ordering.swap_inj, symm, symm, cmp_congr_left yz]
decide
simp [h]
simp [self.2]
decide
decide
decide
have := Array.size_mapM (m := StateT (ULift Nat) Id) (go .nil) m.buckets.1
simp [SatisfiesM_StateT_eq, SatisfiesM_Id_eq] at this
simp [this, Id.run, StateT.run, m.2.2]
unfold empty
apply empty'
simp [Array.getElem_eq_data_get]
exact List.exists_of_set' h
simp [Bucket.size_eq, Bucket.mk, mkArray]
clear h
induction n <;> simp [*]
refine ⟨fun _ h => ?_, fun i h => ?_⟩
· simp [Bucket.mk, empty', mkArray, List.mem_replicate] at h
    simp [h, List.Pairwise.nil]
· simp [Bucket.mk, empty', mkArray, Array.getElem_eq_data_get, AssocList.All]
refine ⟨fun l hl => ?_, fun i hi p hp => ?_⟩
· exact match List.mem_or_eq_of_mem_set hl with
    | .inl hl => H.1 _ hl
    | .inr rfl => h₁ (H.1 _ (Array.getElem_mem_data ..))
· revert hp; simp [update_data, Array.getElem_eq_data_get, List.get_set]
    split <;> intro hp
    · next eq => exact eq ▸ h₂ (H.2 _ _) _ hp
    · simp at hi; exact H.2 i hi _ hp
simp [Bucket.size_eq, reinsertAux]
refine have ⟨l₁, l₂, h₁, _, eq⟩ := Bucket.exists_of_update ..; eq ▸ ?_
simp [h₁, Nat.succ_add]
rfl
rw [expand, go]
· rw [Bucket.mk_size]; simp [Bucket.size]
· intro.
simp
induction l generalizing target with
  | nil => exact ⟨ht₁, fun _ h₁ _ h₂ => (ht₂ _ h₁ _ h₂).1⟩
  | cons _ _ ih =>
    simp at hl₁ hl₂ ht₂
    refine ih hl₁.2 hl₂.2
      (reinsertAux_WF ht₁ fun _ h => (ht₂ _ (Array.getElem_mem_data ..) _ h).2.1)
      (fun _ h => ?_)
    simp [reinsertAux, Bucket.update] at h
    match List.mem_or_eq_of_mem_set h with
    | .inl h =>
      intro _ hf
      have ⟨h₁, h₂⟩ := ht₂ _ h _ hf
      exact ⟨h₁, h₂.2⟩
    | .inr h => subst h; intro
      | _, .head .. =>
        exact ⟨hl₂.1 ▸ Nat.le_refl _, fun _ h h' => hl₁.1 _ h (PartialEquivBEq.symm h')⟩
      | _, .tail _ h =>
        have ⟨h₁, h₂⟩ := ht₂ _ (Array.getElem_mem_data ..) _ h
        exact ⟨h₁, h₂.2⟩
simp_all [Bucket.mk, List.mem_replicate]
simp_all
dsimp [insert, cond]
split
· unfold Bucket.size
    refine have ⟨_, _, h₁, _, eq⟩ := Bucket.exists_of_update ..; eq ▸ ?_
    simp [h, h₁, Bucket.size_eq]
split
· unfold Bucket.size
    refine have ⟨_, _, h₁, _, eq⟩ := Bucket.exists_of_update ..; eq ▸ ?_
    simp [h, h₁, Bucket.size_eq, Nat.succ_add]; rfl
· rw [expand_size]; simp [h, expand, Bucket.size]
    refine have ⟨_, _, h₁, _, eq⟩ := Bucket.exists_of_update ..; eq ▸ ?_
    simp [h₁, Bucket.size_eq, Nat.succ_add]; rfl
induction l with
  | nil => exact .inr
  | cons a l ih =>
    simp; generalize e : cond .. = z; revert e
    unfold cond; split <;> (intro h; subst h; simp)
    · intro
      | .inl eq => exact eq ▸ .inl rfl
      | .inr h => exact .inr (.inr h)
    · intro
      | .inl eq => exact .inr (.inl eq)
      | .inr h => exact (ih h).imp_right .inr
induction hx₁ with
  | head => simp_all; exact (H.1 · · ∘ PartialEquivBEq.trans hx₂)
  | tail _ _ ih =>
    simp at H ⊢
    generalize e : cond .. = z; revert e
    unfold cond; split <;> (intro h; subst h; simp)
    · next e => exact ⟨(H.1 · · ∘ PartialEquivBEq.trans e), H.2⟩
    · next e =>
      refine ⟨fun a h => ?_, ih H.2⟩
      match mem_replaceF h with
      | .inl eq => exact eq ▸ ne_true_of_eq_false e
      | .inr h => exact H.1 a h
dsimp [erase, cond]
split
· next H =>
    simp [h, Bucket.size]
    refine have ⟨_, _, h₁, _, eq⟩ := Bucket.exists_of_update ..; eq ▸ ?_
    simp [h, h₁, Bucket.size_eq]
    rw [(_ : List.length _ = _ + 1), Nat.add_right_comm]; {rfl}
    clear h₁ eq
    simp [AssocList.contains_eq] at H
    have ⟨a, h₁, h₂⟩ := H
    refine have ⟨_, _, _, _, _, h, eq⟩ := List.exists_of_eraseP h₁ h₂; eq ▸ ?_
    simp [h]; rfl
· exact h
dsimp [erase, cond]
split
· refine h.update (fun H => ?_) (fun H a h => ?_) <;> simp at h ⊢
    · simp; exact H.sublist (List.eraseP_sublist _)
    · exact H _ (List.mem_of_mem_eraseP h)
· exact h
induction h with
  | mk h₁ h₂ => exact ⟨h₁, h₂⟩
  | @empty' _ h => exact ⟨(Bucket.mk_size h).symm, .mk' h⟩
  | insert _ ih => exact ⟨insert_size ih.1, insert_WF ih.2⟩
  | erase _ ih => exact ⟨erase_size ih.1, erase_WF ih.2⟩
have ⟨h₁, h₂⟩ := H.out
simp [Imp.mapVal, Bucket.mapVal, WF_iff, h₁]
refine ⟨?_, ?_, fun i h => ?_⟩
· simp [Bucket.size]; congr; funext l; simp
· simp [List.forall_mem_map_iff, List.pairwise_map]
    exact fun _ => h₂.1 _
· simp [AssocList.All, List.forall_mem_map_iff] at h ⊢
    exact h₂.2 _ h
induction l generalizing n acc with simp [filterMap.go, *]
    | cons a b l => match f a b with
      | none => rfl
      | some c => simp; rw [Nat.add_right_comm]; rfl
induction l generalizing n with
    | nil => rfl
    | cons l L IH => simp [bind, StateT.bind, IH, H1, Nat.add_assoc]; rfl
induction l with
    | nil => exact .slnil
    | cons a l ih =>
      simp; exact match f a.1 a.2 with
      | none => .cons _ ih
      | some b => .cons₂ _ ih
simp [Bucket.size]
simp_wf
simp_arith [*]
rw [combine] at eq
split at eq <;> cases eq <;>
        simp [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm]
simp_wf
simp_arith [*]
simp [hk, Nat.add_assoc]
simp [eq, Nat.add_assoc]
simp [eq, Nat.add_assoc, Nat.add_comm, Nat.add_left_comm]
simp [toHeap.go, go, Nat.add_assoc, Nat.add_left_comm]
simp
simp
simp only [Heap.tail?]
intro eq
match eq₂ : s.deleteMin le, eq with
  | some (a, tl), rfl => exact realSize_deleteMin eq₂
simp only [Heap.tail]
match eq : s.tail? le with
  | none => cases s with cases eq | nil => rfl
  | some tl => simp [Heap.realSize_tail? eq]; rfl
simp_arith [Heap.realSize_deleteMin eq]
decide
unfold combine at eq
split at eq <;> cases eq <;> rename_i h
· exact ⟨r₁, rfl, h, hn₂, hn₁⟩
· exact ⟨r₁, rfl, TotalBLE.total.resolve_left h, hn₁, hn₂⟩
simp_wf
simp_arith [*]
rw [findMin, headD]
split <;> apply findMin_val
simp only [deleteMin, findMin_val, Option.map, head?]
simp_arith only [rankTR.go, go, rank]
rw [realSize, realSize_eq c, Nat.pow_succ, Nat.mul_succ]
simp [Nat.add_assoc, realSize_eq s]
simp [size, Nat.shiftLeft, size_eq h₂, Nat.pow_succ, Nat.mul_succ]
simp [Nat.add_assoc, Nat.one_shiftLeft, h₁.realSize_eq, h₂.size_eq]
rw [toHeap, rankTR_eq]
exact go h trivial
rw [← h'.rank_eq] at h
exact h
let ⟨h₁, h₂, h₃⟩ := h
simp [Heap.findMin]
split
· exact findMin h₃ hr (fun h => hk ⟨h₁, h₂, h⟩)
· exact findMin h₃ ⟨_, fun h => hk (h.of_le h₁), h₂, h₃⟩ (fun h => hk ⟨h₁, h₂, h⟩)
cases s with cases eq | cons r a c s => ?_
have : Nonempty ((s.findMin le (cons r a c) ⟨id, a, c, s⟩).WellFormed le) :=
    let ⟨_, h₂, h₃⟩ := h
    h₃.findMin ⟨_, fun h => h.of_le (Nat.zero_le _), h₂, h₃⟩
      fun h => ⟨Nat.zero_le _, h₂, h⟩
revert this
match s.findMin le (cons r a c) ⟨id, a, c, s⟩ with
  | { before, val, node, next } =>
    intro ⟨⟨_, hk, ih₁, ih₂⟩⟩
    exact ih₁.toHeap.merge <| hk (ih₂.of_le (Nat.le_succ _))
simp only [Heap.tail?]
intro eq
match eq₂ : s.deleteMin le, eq with
  | some (a, tl), rfl => exact hwf.deleteMin eq₂
simp only [Heap.tail]
match eq : s.tail? le with
  | none => exact Heap.WellFormed.nil
  | some tl => exact hwf.tail? eq
simp [gcd_succ]
induction m, n using gcd.induction with
  | H0 n => rw [gcd_zero_left]; exact ⟨Nat.dvd_zero n, Nat.dvd_refl n⟩
  | H1 m n _ IH => rw [← gcd_rec] at IH; exact ⟨IH.2, (dvd_mod_iff IH.2).1 IH.1⟩
induction m, n using gcd.induction with intro km kn
  | H0 n => rw [gcd_zero_left]; exact kn
  | H1 n m _ IH => rw [gcd_rec]; exact IH ((dvd_mod_iff km).2 kn) km
rw [gcd_rec, mod_eq_zero_of_dvd h, gcd_zero_left]
rw [gcd_comm]
exact gcd_eq_left_iff_dvd
rw [Nat.mul_comm m n, Nat.mul_comm k n, Nat.mul_comm (gcd m k) n, gcd_mul_left]
rw [gcd_comm] at H
exact eq_zero_of_gcd_eq_zero_left H
simp [H0]
apply Nat.eq_of_mul_eq_mul_right H3
rw [Nat.div_mul_cancel (dvd_gcd H1 H2), ← gcd_mul_right,
        Nat.div_mul_cancel H1, Nat.div_mul_cancel H2]
rw [gcd_comm, gcd_eq_left H]
rw [gcd_comm, gcd_mul_left_left]
rw [Nat.mul_comm, gcd_mul_left_left]
rw [gcd_comm, gcd_mul_right_left]
rw [gcd_comm n m, gcd_gcd_self_right_left]
rw [gcd_comm, gcd_gcd_self_right_right]
rw [gcd_comm m n, gcd_gcd_self_left_right]
simp [gcd_rec m (n + k * m), gcd_rec m n]
simp [h]
rw [lcm, lcm, Nat.mul_comm n m, gcd_comm n m]
simp [lcm]
simp [lcm]
simp [lcm]
simp [lcm]
match eq_zero_or_pos m with
  | .inl h => rw [h, lcm_zero_left]
  | .inr h => simp [lcm, Nat.mul_div_cancel _ h]
rw [← Nat.mul_div_assoc m (Nat.gcd_dvd_right m n)]
rfl
rw [lcm, Nat.mul_div_cancel' (Nat.dvd_trans (gcd_dvd_left m n) (Nat.dvd_mul_right m n))]
match eq_zero_or_pos k with
  | .inl h => rw [h]; exact Nat.dvd_zero _
  | .inr kpos =>
    apply Nat.dvd_of_mul_dvd_mul_left (gcd_pos_of_pos_left n (pos_of_dvd_of_pos H1 kpos))
    rw [gcd_mul_lcm, ← gcd_mul_right, Nat.mul_comm n k]
    exact dvd_gcd (Nat.mul_dvd_mul_left _ H2) (Nat.mul_dvd_mul_right H1 _)
intro h
have h1 := gcd_mul_lcm m n
rw [h, Nat.mul_zero] at h1
match mul_eq_zero.1 h1.symm with
  | .inl hm1 => exact hm hm1
  | .inr hn1 => exact hn hn1
rw [coprime, Nat.gcd_assoc, H.symm.gcd_eq_one, gcd_one_right]
rw [Nat.mul_comm m k, H.gcd_mul_left_cancel m]
rw [gcd_comm m n, gcd_comm m (k * n), H.gcd_mul_left_cancel n]
rw [Nat.mul_comm n k, H.gcd_mul_left_cancel_right n]
rw [coprime_iff_gcd_eq_one, gcd_div (gcd_dvd_left m n) (gcd_dvd_right m n), Nat.div_self H]
rw [← co.gcd_eq_one]
exact dvd_gcd Hm Hn
match eq_zero_or_pos a with
  | .inl h0 =>
    rw [h0] at dvd
    rw [Nat.eq_zero_of_zero_dvd dvd] at cmn ⊢
    simp; assumption
  | .inr hpos =>
    let ⟨k, hk⟩ := dvd
    rw [hk, Nat.mul_div_cancel_left _ hpos]
    rw [hk] at cmn
    exact cmn.coprime_mul_left
rw [@coprime_comm k, @coprime_comm k, @coprime_comm k, coprime_mul_iff_left]
simp [coprime]
simp [coprime]
simp [coprime]
rw [← H.gcd_eq_one, gcd_eq_left d]
have hd : gcd k m * (k / gcd k m) = k := Nat.mul_div_cancel' (gcd_dvd_left k m)
refine ⟨⟨⟨gcd k m, gcd_dvd_right k m⟩, ⟨k / gcd k m, ?_⟩⟩, hd.symm⟩
apply Nat.dvd_of_mul_dvd_mul_left (Nat.pos_of_ne_zero h0)
rw [hd, ← gcd_mul_right]
exact Nat.dvd_gcd (Nat.dvd_mul_right _ _) H
apply dvd_antisymm
· apply ((cop.gcd_left _).mul (cop.gcd_left _)).dvd_of_dvd_mul_right
    rw [← h]
    apply Nat.mul_dvd_mul (gcd_dvd ..).1 (gcd_dvd ..).1
· rw [gcd_comm a, gcd_comm b]
    refine Nat.dvd_trans ?_ (gcd_mul_dvd_mul_gcd ..)
    rw [h, gcd_mul_right_right d c]; apply Nat.dvd_refl
simp [Nat.zero_add]
rw [add_one, succ_add] at h
cases succ_ne_zero _ h
rw [Nat.add_comm]
exact Nat.lt_add_of_pos_right h

/- sub properties -/
simp [succ_sub_succ] at h₁
exact succ_le_succ <| Nat.le_of_le_of_sub_le_sub_right (le_of_succ_le_succ h₀) h₁
rw [← Nat.add_sub_cancel x k, Nat.sub_le_sub_right_iff h, Nat.add_sub_cancel]
rw [Nat.sub_zero] at H
simp [H]
simp [Nat.add_sub_add_right] at H
exact H
rw [c_eq.symm, Nat.sub_add_cancel ab]
rw [a_eq, Nat.add_sub_cancel]
simp [Nat.sub_eq_zero_of_le H'] at H
simp [Nat.min_def]
split <;> split <;> simp [*]
· next h₁ h₂ => exact Nat.le_antisymm h₁ h₂
· next h₁ h₂ => cases not_or_intro h₁ h₂ <| Nat.le_total ..
rw [Nat.min_def]
split <;> simp [*]
rw [Nat.min_def]
split <;> assumption
simp [Nat.min_def, h]
rw [Nat.min_comm a b]
exact Nat.min_eq_left h
simp only [Nat.max_def]
rw [Nat.max_def]
split <;> simp [*]
rw [Nat.max_def]
split <;> assumption
simp [Nat.max_def, h, Nat.not_lt.2 h]
rw [← Nat.max_comm b a]
exact Nat.max_eq_right h

-- Distribute succ over min
simp [Nat.min_def, succ_le_succ_iff]
split <;> rfl
rw [Nat.min_def]
split
· rw [Nat.sub_eq_zero_of_le ‹n ≤ m›, Nat.sub_self]
· rfl
rw [sub_eq_sub_min, Nat.sub_add_cancel (Nat.min_le_left n m)]

/- multiplication -/
rw [Nat.mul_assoc, Nat.mul_comm m, ← Nat.mul_assoc]
simp [Nat.mul_succ]
simp [Nat.succ_mul]

/- mod -/

-- TODO mod_core_congr, mod_def
simp
induction m, k using mod.inductionOn with rw [div_eq, mod_eq]
  | base x y h => simp [h]
  | ind x y h IH => simp [h]; rw [Nat.mul_succ, ← Nat.add_assoc, IH, Nat.sub_add_cancel h.2]

/- div -/
rw [div_eq]
simp [Nat.lt_irrefl]
induction y, k using mod.inductionOn generalizing x with
    (rw [div_eq]; simp [h]; cases x with simp [zero_le] | succ x => ?_)
  | base y k h =>
    simp [not_succ_le_zero x, succ_mul, Nat.add_comm]
    refine Nat.lt_of_lt_of_le ?_ (Nat.le_add_right ..)
    exact Nat.not_le.1 fun h' => h ⟨k0, h'⟩
  | ind y k h IH =>
    rw [← add_one, Nat.add_le_add_iff_le_right, IH k0, succ_mul,
        ← Nat.add_sub_cancel (x*k) k, Nat.sub_le_sub_right_iff h.2, Nat.add_sub_cancel]
simp [Nat.div_zero, n.zero_le]
rw [mod_add_div]
rw [div_eq a, if_pos]
constructor <;> assumption
rw [div_eq a, if_neg]
intro h₁
apply Nat.not_le_of_gt h₀ h₁.right
rw [← Nat.not_le, ← Nat.not_le]
exact not_congr (le_div_iff_mul_le Hk)

/- successor and predecessor -/
cases n <;> simp
rw [Nat.succ_eq_add_one, Nat.add_comm]
simp [succ_add, add_succ]
simp [Nat.add_comm]
rw [succ_mul] at h
exact .inr (Nat.eq_zero_of_add_eq_zero_left h)
simp [h]
match a.le_total b with
  | .inl hl => rw [Nat.max_eq_right hl, Nat.sub_eq_zero_iff_le.mpr hl, Nat.zero_add]
  | .inr hr => rw [Nat.max_eq_left hr, Nat.sub_add_cancel hr]
rw [← Nat.sub_sub]
apply sub_le
rw [Nat.sub_sub, Nat.sub_sub, add_succ, succ_sub_succ]
rw [Nat.sub_sub, Nat.sub_sub, Nat.add_comm]
rw [Nat.mul_sub_left_distrib, Nat.right_distrib, Nat.right_distrib,
      Nat.mul_comm b a, Nat.add_comm (a*a) (a*b), Nat.add_sub_add_left]
rw [mul_succ, succ_mul, Nat.add_right_comm _ a]
rfl
let ⟨k, hk⟩ := Nat.le.dest h
rw [← hk, Nat.add_sub_cancel_left, ← add_succ, Nat.add_sub_cancel_left]
rw [Nat.sub_sub]
apply Nat.sub_lt (Nat.lt_of_lt_of_le (Nat.zero_lt_succ _) h)
rw [Nat.add_comm]
apply Nat.zero_lt_succ
rw [show a = b from h]
apply sub_lt _ h₀
apply Nat.lt_of_lt_of_le h₀ h₁
rw [Nat.add_comm, Nat.sub_add_cancel h]
rw [Nat.add_sub_add_right]
exact lt_succ_of_le (Nat.sub_le _ _)
rw [Nat.add_sub_add_right, Nat.add_sub_add_right]
exact Nat.sub_lt_sub_left (Nat.lt_of_succ_lt_succ h1) (Nat.lt_of_succ_lt_succ h2)
rw [← Nat.add_sub_cancel x k, Nat.sub_le_sub_right_iff h, Nat.add_sub_cancel]
rw [mod_eq_sub_mod (Nat.le_add_left ..), Nat.add_sub_cancel]
rw [Nat.add_comm, add_mod_right]
match z with
  | 0 => rw [Nat.mul_zero, Nat.add_zero]
  | succ z => rw [mul_succ, ← Nat.add_assoc, add_mod_right, add_mul_mod_self_left (z := z)]
rw [Nat.mul_comm, add_mul_mod_self_left]
rw [← Nat.zero_add (m * n), add_mul_mod_self_left, zero_mod]
rw [Nat.mul_comm, mul_mod_right]
rw [y0, Nat.mul_zero, mod_zero, mod_zero]
rw [z0, Nat.zero_mul, Nat.zero_mul, Nat.zero_mul, mod_zero]
induction x using Nat.strongInductionOn with
    | _ n IH =>
      have y0 : y > 0 := Nat.pos_of_ne_zero y0
      have z0 : z > 0 := Nat.pos_of_ne_zero z0
      cases Nat.lt_or_ge n y with
      | inl yn => rw [mod_eq_of_lt yn, mod_eq_of_lt (Nat.mul_lt_mul_of_pos_left yn z0)]
      | inr yn =>
        rw [mod_eq_sub_mod yn, mod_eq_sub_mod (Nat.mul_le_mul_left z yn),
          ← Nat.mul_sub_left_distrib]
        exact IH _ (sub_lt (Nat.lt_of_lt_of_le y0 yn) y0)
rw [Nat.mul_comm x z, Nat.mul_comm y z, Nat.mul_comm (x % y) z]
apply mul_mod_mul_left

-- TODO cont_to_bool_mod_two
apply Nat.le_of_add_le_add_right (b := n * k)
rw [Nat.sub_add_cancel h₂]
simp [mul_succ, Nat.add_comm] at h₁
simp [h₁]
apply Nat.le_of_add_le_add_right
rw [Nat.sub_add_cancel h₂, Nat.add_comm]
rw [mul_succ] at h₁
exact h₁
simp
rw [div_eq_sub_div H (Nat.le_add_left _ _), Nat.add_sub_cancel]
rw [Nat.add_comm, add_div_right x H]
induction n <;> simp_all [mul_succ]
rw [Nat.mul_comm, mul_div_right _ H]
induction z with
  | zero => rw [Nat.mul_zero, Nat.add_zero, Nat.add_zero]
  | succ z ih => rw [mul_succ, ← Nat.add_assoc, add_div_right _ H, ih]; rfl
rw [Nat.mul_comm, add_mul_div_left _ _ H]
rw [Nat.mul_comm, Nat.mul_div_cancel _ H]
rw [H2, Nat.mul_div_cancel _ H1]
rw [H2, Nat.mul_div_cancel_left _ H1]
rw [hn, Nat.mul_zero] at hi lo
exact absurd lo (Nat.not_le_of_gt hi)
rw [n0, Nat.zero_mul] at h₁
exact not_lt_zero _ h₁
cases eq_zero_or_pos k with
  | inl k0 => rw [k0, Nat.mul_zero, Nat.div_zero, Nat.div_zero] | inr kpos => ?_
cases eq_zero_or_pos n with
  | inl n0 => rw [n0, Nat.zero_mul, Nat.div_zero, Nat.zero_div] | inr npos => ?_
apply Nat.le_antisymm
· apply (le_div_iff_mul_le (Nat.mul_pos npos kpos)).2
    rw [Nat.mul_comm n k, ← Nat.mul_assoc]
    apply (le_div_iff_mul_le npos).1
    apply (le_div_iff_mul_le kpos).1
    (apply Nat.le_refl)
· apply (le_div_iff_mul_le kpos).2
    apply (le_div_iff_mul_le npos).2
    rw [Nat.mul_assoc, Nat.mul_comm n k]
    apply (le_div_iff_mul_le (Nat.mul_pos kpos npos)).1
    apply Nat.le_refl
rw [← Nat.div_div_eq_div_mul, Nat.mul_div_cancel_left _ H]
match n, Nat.eq_zero_or_pos n with
  | _, Or.inl rfl => rw [Nat.zero_mul]; exact m.zero_le
  | n, Or.inr h => rw [Nat.mul_comm, ← Nat.le_div_iff_mul_le h]; exact Nat.le_refl _

/- dvd -/
simp
simp
simp[h₃,h₄, Nat.mul_assoc]
simp [Nat.left_distrib, hd, he]
rw [Nat.mul_sub_left_distrib, ← he, Nat.add_sub_cancel_left]
rw [Nat.add_comm]
exact Nat.dvd_add_iff_right h
simp [he, hf, Nat.mul_assoc, Nat.mul_left_comm, Nat.mul_comm]
decide
decide
let ⟨z, H⟩ := H
rw [H, mul_mod_right]
rw [Nat.mul_comm, Nat.mul_div_cancel' H]
rw [Nat.div_mul_cancel H]
let ⟨l, H⟩ := H
rw [Nat.mul_assoc] at H
exact ⟨_, Nat.eq_of_mul_eq_mul_left kpos H⟩
rw [Nat.mul_comm m k, Nat.mul_comm n k] at H
exact Nat.dvd_of_mul_dvd_mul_left kpos H

/- --- -/
simp [n0, mod_zero]
conv => lhs; rw [
    ← mod_add_div a n, ← mod_add_div b n, Nat.add_mul, Nat.mul_add, Nat.mul_add,
    Nat.mul_assoc, Nat.mul_assoc, ← Nat.mul_add n, add_mul_mod_self_left,
    Nat.mul_comm _ (n * (b / n)), Nat.mul_assoc, add_mul_mod_self_left]
rw [Nat.add_comm, mod_add_mod, Nat.add_comm]
rw [add_mod_mod, mod_add_mod]
rw [Nat.pow_succ, Nat.mul_comm]
simp [pow_succ, Nat.mul_assoc, Nat.mul_left_comm, Nat.mul_comm]
rw [shiftLeft_eq, Nat.one_mul]
decide
rw [← Nat.not_le, ← Nat.not_le, le_log2 h]
induction l₁ <;> simp [*, Nat.add_assoc]
simp
intro t
simp
rw [h]
intro t
show f (g t) = (f (g [])) ++ t
rw [h₁ (g t), h₂ t, ← append_assoc (f []) (g []) t, ← h₁ (g [])]
intro t
show f (a :: t) = f (a :: nil) ++ t
rw [h [a], h (a::t), append_assoc (f []) [a] t]
rfl
simp [fdiv]
simp
simp
simp
simp
cases b <;> rfl

-- Will be generalized to Euclidean domains.
simp
simp
simp
simp
rw [Nat.div_zero]
rfl
rw [Nat.div_zero]
rfl
simp [Int.neg_zero]
simp [Int.div_neg, Int.neg_div, Int.neg_neg]
simp [Int.div_def, Int.div, neg_ofNat_of_succ]
rw [← Int.neg_inj, ← Int.ediv_neg, Int.neg_add, ← Int.ediv_neg, ← Int.neg_mul_neg]
exact this (Int.neg_pos_of_neg hlt)
rw [← Int.add_sub_cancel (ediv ..), ← this, Int.sub_add_cancel]
show ((n * k.succ : Nat) - m.succ : Int).ediv k.succ = n - (m / k.succ + 1 : Nat)
rw [negSucc_eq, Int.ofNat_sub h]
simp only [Int.sub_eq_add_neg, Int.neg_add, Int.neg_neg, Int.add_left_comm, Int.add_assoc]
simp [h]
let ⟨k, hk⟩ := H
rw [hk, Int.mul_comm c k, Int.add_mul_ediv_right _ _ h,
      ← Int.zero_add (k * c), Int.add_mul_ediv_right _ _ h, Int.zero_ediv, Int.zero_add]
rw [Int.add_comm, Int.add_ediv_of_dvd_right H, Int.add_comm]
rw [fdiv_eq_ediv _ b0, mul_ediv_cancel _ H]
simp [Int.zero_mul]
rw [← ofNat_mul, ← ofNat_div,
      Nat.mul_div_cancel _ <| Nat.pos_of_ne_zero <| Int.ofNat_ne_zero.1 H]
rw [Int.mul_neg, Int.neg_div, Int.div_neg, Int.neg_neg,
      this (Int.neg_ne_zero.1 H)]
rw [Int.neg_mul, Int.neg_div, this H]
rw [Int.neg_mul_neg, Int.div_neg, this (Int.neg_ne_zero.1 H)]
cases m <;> simp [fmod]
rw [Int.sub_sub, Int.add_comm]
match b, eq_succ_of_zero_lt bpos with
  | _, ⟨n, rfl⟩ => rfl
cases b <;> simp [mod_def', mod]
cases b <;> rfl
simp [emod]
show (m % succ n + -↑(succ n) * -↑(m / succ n) : Int) = m
rw [Int.neg_mul_neg]
exact congrArg ofNat (Nat.mod_add_div ..)
show -(↑((succ m) % n) : Int) + ↑n * -↑(succ m / n) = -↑(succ m)
rw [Int.mul_neg, ← Int.neg_add]
exact congrArg (-ofNat ·) (Nat.mod_add_div ..)
show -(↑(succ m % succ n) : Int) + -↑(succ n) * ↑(succ m / succ n) = -↑(succ m)
rw [Int.neg_mul, ← Int.neg_add]
exact congrArg (-ofNat ·) (Nat.mod_add_div ..)
simp
show subNatNat (m % succ n) n + (↑(succ n * (m / succ n)) + n + 1) = (m + 1)
rw [Int.add_comm _ n, ← Int.add_assoc, ← Int.add_assoc,
      Int.subNatNat_eq_coe, Int.sub_add_cancel]
exact congrArg (ofNat · + 1) <| Nat.mod_add_div ..
rw [fmod_zero]
rfl
show subNatNat .. - (↑(succ n * (m / succ n)) + ↑(succ n)) = -↑(succ m)
rw [Int.subNatNat_eq_coe, ← Int.sub_sub, ← Int.neg_sub, Int.sub_sub, Int.sub_sub_self]
exact congrArg (-ofNat ·) <| Nat.succ_add .. ▸ Nat.mod_add_div .. ▸ rfl
show -(↑(succ m % succ n) : Int) + -↑(succ n * (succ m / succ n)) = -↑(succ m)
rw [← Int.neg_add]
exact congrArg (-ofNat ·) <| Nat.mod_add_div ..
show (m % succ n + -↑(succ n) * -↑(m / succ n) : Int) = m
rw [Int.neg_mul_neg]
exact congrArg ofNat <| Nat.mod_add_div ..
rw [emod_zero]
rfl
rw [← ofNat_emod, ← ofNat_ediv, ← Int.sub_sub, negSucc_eq, Int.sub_sub n,
      ← Int.neg_neg (_-_), Int.neg_sub, Int.sub_sub_self, Int.add_right_comm]
exact congrArg (fun x => -(ofNat x + 1)) (Nat.mod_add_div ..)
rw [← Int.add_sub_cancel (a % b), mod_add_div]
rw [← Int.add_sub_cancel (a.fmod b), fmod_add_fdiv]
rw [← Int.add_sub_cancel (a.emod b), emod_add_ediv]
simp [fmod_def, emod_def, fdiv_eq_ediv _ hb]
simp [emod_def, mod_def, ediv_eq_div ha hb]
rw [mod_def, mod_def, Int.div_neg, Int.neg_mul_neg]
rw [emod_def, emod_def, Int.ediv_neg, Int.neg_mul_neg]
simp [mod_def, Int.div_one, Int.one_mul, Int.sub_self]
simp [emod_def, Int.one_mul, Int.sub_self]
simp [fmod_def, Int.one_mul, Int.sub_self]
rw [fmod_eq_mod H1 (Int.le_trans H1 (Int.le_of_lt H2)), mod_eq_of_lt H1 H2]
rw [emod_eq_mod H1 (Int.le_trans H1 (Int.le_of_lt H2)), mod_eq_of_lt H1 H2]
simp [emod, Int.subNatNat_eq_coe]
exact Int.sub_lt_self _ (ofNat_lt.2 <| Nat.succ_pos _)
rw [Int.mul_comm]
apply mod_add_div
rw [Int.mul_comm]
apply div_add_mod
rw [Int.mul_comm]
apply emod_add_ediv
rw [Int.mul_comm]
apply ediv_add_emod
rw [cz, Int.mul_zero, Int.add_zero]
rw [Int.emod_def, Int.emod_def, Int.add_mul_ediv_right _ _ cz, Int.add_comm _ b,
      Int.mul_add, Int.mul_comm, ← Int.sub_sub, Int.add_sub_cancel]
rw [Int.mul_comm, Int.add_mul_emod_self]
rw [Int.add_comm, Int.add_emod_self]
rw [Int.add_comm, emod_add_emod, Int.add_comm]
rw [add_emod_emod, emod_add_emod]
rw [← emod_add_emod, ← emod_add_emod k, H]
rw [Int.add_comm, add_emod_eq_add_emod_right _ H, Int.add_comm]
rw [Int.add_comm, Int.add_comm i, emod_add_cancel_right]
simp [Int.sub_self]
simp [h, Int.mul_zero]
rw [Int.mod_def, Int.mul_div_cancel _ h, Int.mul_comm, Int.sub_self]
simp [h, Int.mul_zero]
rw [Int.fmod_def, Int.mul_fdiv_cancel _ h, Int.mul_comm, Int.sub_self]
rw [← Int.zero_add (a * b), Int.add_mul_emod_self, Int.zero_emod]
rw [Int.mul_comm, mul_mod_left]
rw [Int.mul_comm, mul_fmod_left]
rw [Int.mul_comm, mul_emod_left]
conv => lhs; rw [
    ← emod_add_ediv a n, ← emod_add_ediv' b n, Int.add_mul, Int.mul_add, Int.mul_add,
    Int.mul_assoc, Int.mul_assoc, ← Int.mul_add n _ _, add_mul_emod_self_left,
    ← Int.mul_assoc, add_mul_emod_self]
conv => rhs; rw [← emod_add_ediv n k]
match k, h with
  | _, ⟨t, rfl⟩ => rw [Int.mul_assoc, add_mul_emod_self_left]
conv => rhs; rw [← emod_add_ediv a b, add_mul_emod_self_left]
apply (emod_add_cancel_right b).mp
rw [Int.sub_add_cancel, ← Int.add_emod_emod, Int.sub_add_cancel, emod_emod]
constructor
· intro ⟨rfl, rfl⟩
    exact ⟨emod_add_ediv a b, emod_nonneg _ (Int.ne_of_gt h), emod_lt_of_pos _ h⟩
· intro ⟨rfl, hz, hb⟩
    constructor
    · rw [Int.add_mul_ediv_left r q (Int.ne_of_gt h), ediv_eq_zero_of_lt hz hb]
      simp [Int.zero_add]
    · rw [add_mul_emod_self_left, emod_eq_of_lt hz hb]
rw [Int.mul_neg, Int.ediv_neg, Int.ediv_neg]
apply congrArg Neg.neg
apply this
rw [Int.ofNat_zero, Int.mul_zero, Int.ediv_zero, Int.ediv_zero]
apply Nat.div_eq_of_lt_le
· refine Nat.le_trans ?_ (Nat.le_add_right _ _)
        rw [← Nat.mul_div_mul _ _ m.succ_pos]
        apply Nat.div_mul_le_self
· show m.succ * n.succ ≤ _
        rw [Nat.mul_left_comm]
        apply Nat.mul_le_mul_left
        apply (Nat.div_lt_iff_lt_mul k.succ_pos).1
        apply Nat.lt_succ_self
rw [Int.mul_comm, Int.mul_comm c, mul_ediv_mul_of_pos _ _ H]
rw [emod_def, emod_def, mul_ediv_mul_of_pos _ _ H, Int.mul_sub, Int.mul_assoc]
rw [Int.add_mul, Int.one_mul, Int.mul_comm]
exact Int.lt_add_of_sub_left_lt <| Int.mod_def .. ▸ mod_lt_of_pos _ H
rw [Int.add_mul, Int.one_mul, Int.mul_comm]
exact Int.lt_add_of_sub_left_lt <| Int.emod_def .. ▸ emod_lt_of_pos _ H
rw [Int.div_neg, natAbs_neg, natAbs_neg]
rfl
rw [Int.neg_div, natAbs_neg, natAbs_neg]
rfl
rw [Int.neg_div_neg, natAbs_neg, natAbs_neg]
rfl
rw [Int.ediv_neg, natAbs_neg]
apply aux
rw [Int.mul_comm, mul_div_cancel_of_mod_eq_zero H]
rw [Int.mul_comm, mul_ediv_cancel_of_emod_eq_zero H]
rw [Int.mul_assoc]
rw [e, Int.zero_mul]
simp [e, Int.neg_mul, Int.mul_neg, Int.neg_neg]
simp [← e, Int.neg_mul, Int.mul_neg, Int.neg_neg]
rw [Int.mul_add]
rw [Int.mul_sub]
rw [Int.add_comm, Int.dvd_add_left H]
rw [← Int.sub_neg] at H
rw [Int.dvd_iff_dvd_of_dvd_sub H, Int.dvd_neg]
rw [e, Int.ofNat_mul]
refine ⟨fun ⟨k, hk⟩ => ?_, fun ⟨k, hk⟩ => ⟨natAbs k, hk.symm ▸ natAbs_mul a k⟩⟩
rw [← natAbs_ofNat k, ← natAbs_mul, natAbs_eq_natAbs_iff] at hk
cases hk <;> subst b
· apply Int.dvd_mul_right
· rw [← Int.mul_neg]; apply Int.dvd_mul_right
rw [← e]
rw [← Int.neg_dvd, ← e]
rw [← e]
rw [← Int.dvd_neg, ← e]
rw [← natAbs_dvd_natAbs, natAbs_ofNat]
rw [← natAbs_dvd_natAbs, natAbs_ofNat]
rw [← natAbs_of_nonneg H1, ← natAbs_of_nonneg H2]
rw [ofNat_dvd, ofNat_dvd, ofNat_inj]
apply Nat.dvd_antisymm
rw [h]
rw [Int.mul_comm, Int.div_mul_cancel H]
rw [Int.mul_comm, Int.ediv_mul_cancel H]
simp [cz, Int.mul_zero]
rw [Int.mul_left_comm, Int.mul_div_cancel_left _ cz, Int.mul_div_cancel_left _ cz]
simp [cz, Int.mul_zero]
rw [Int.mul_left_comm, Int.mul_ediv_cancel_left _ cz, Int.mul_ediv_cancel_left _ cz]
rw [Int.mul_comm, Int.mul_div_assoc _ h, Int.mul_comm]
rw [Int.mul_comm, Int.mul_ediv_assoc _ h, Int.mul_comm]
simp [az]
rw [Int.mul_div_cancel_left _ az, Int.mul_assoc, Int.mul_div_cancel_left _ az]
apply Int.dvd_mul_right
rw [← H2, Int.mul_div_cancel' H1]
rw [← H2, Int.mul_ediv_cancel' H1]
rw [H2, Int.mul_div_cancel_left _ H1]
rw [H2, Int.mul_ediv_cancel_left _ H1]
rw [Int.mul_comm]
exact Int.div_eq_iff_eq_mul_right H H'
rw [Int.mul_comm]
exact Int.ediv_eq_iff_eq_mul_right H H'
rw [Int.mul_comm, Int.eq_mul_of_div_eq_right H1 H2]
rw [Int.mul_comm, Int.eq_mul_of_ediv_eq_right H1 H2]
rw [Int.mul_comm, H2]
rw [Int.mul_comm, H2]
rw [← Int.mul_div_cancel' h, H, Int.mul_zero]
rw [← Int.mul_ediv_cancel' h, H, Int.mul_zero]
simp [bz]
rw [Int.neg_mul_eq_mul_neg, Int.mul_ediv_cancel_left _ bz, Int.mul_ediv_cancel_left _ bz]
rw [Int.sub_eq_add_neg, Int.sub_eq_add_neg, Int.add_ediv_of_dvd_right (Int.dvd_neg.2 hcb)]
congr
exact Int.neg_ediv_of_dvd hcb
rw [← Int.add_sub_cancel ((a-b).ediv c), ← Int.add_ediv_of_dvd_left hcab, Int.sub_add_cancel]
refine ⟨fun h => ?_, congrArg (· / d)⟩
rw [← Int.mul_div_cancel' hda, ← Int.mul_div_cancel' hdb, h]
refine ⟨fun h => ?_, congrArg (ediv · d)⟩
rw [← Int.mul_ediv_cancel' hda, ← Int.mul_ediv_cancel' hdb, h]
simp [sign, Int.mul_one]
simp [sign, Int.mul_zero]
simp [sign, Int.mul_neg, Int.mul_one]
simp [sign, Int.mul_one]
simp [sign, Int.mul_zero]
simp [sign, Int.mul_neg, Int.mul_one]
simp [az]
rw [Int.mul_comm, H']

/- TODO

/-! ### `/` and ordering -/

protected theorem ediv_mul_le (a : Int) {b : Int} (H : b ≠ 0) : a.ediv b * b ≤ a :=
  Int.le_of_sub_nonneg <|
rw [Int.mul_comm, ← emod_def]
apply emod_nonneg _ H
rw [← Int.div_mul_cancel H2] <;> exact Decidable.mul_le_mul_of_nonneg_right H3 H1
rw [← Int.mul_div_assoc _ H2] <;> exact (Int.div_eq_of_eq_mul_left H4 H5.symm).symm
rw [← natAbs_dvd, ← dvd_natAbs, ofNat_dvd] at w
rw [← natAbs_eq_zero]
exact eq_zero_of_dvd_of_lt w h
rw [subNatNat, h]
rw [subNatNat, h]
simp [H]
rw [← Int.neg_neg a, ← Int.neg_neg b, h]
unfold subNatNat
match h : n - m with
  | 0 =>
    have ⟨k, h⟩ := Nat.le.dest (Nat.le_of_sub_eq_zero h)
    rw [h.symm, Nat.add_sub_cancel_left]; apply hp
  | succ k =>
    rw [Nat.sub_eq_iff_eq_add (Nat.le_of_lt (Nat.lt_of_sub_eq_succ h))] at h
    rw [h, Nat.add_comm]; apply hn
unfold subNatNat
rw [Nat.sub_eq_zero_of_le (Nat.le_add_right ..), Nat.add_sub_cancel_left]
simp [subNatNat, Nat.add_assoc, Nat.add_sub_cancel_left]
apply subNatNat_elim m n (fun m n i => subNatNat (m + k) (n + k) = i)
· intro i j
    rw [Nat.add_assoc, Nat.add_comm i k, ← Nat.add_assoc]
    exact subNatNat_add_left
· intro i j
    rw [Nat.add_assoc j i 1, Nat.add_comm j (i+1), Nat.add_assoc, Nat.add_comm (i+1) (j+k)]
    exact subNatNat_add_right
rw [Nat.pos_iff_ne_zero, Ne, natAbs_eq_zero]
cases n <;> rfl
cases a <;> cases b <;>
    simp only [← Int.mul_def, Int.mul, natAbs_negOfNat] <;> simp only [natAbs]
rw [← natAbs_mul, h, natAbs]
rw [← Int.ofNat_mul, natAbs_mul_self]
constructor <;> intro h
· cases Int.natAbs_eq a with
    | inl h₁ | inr h₁ =>
      cases Int.natAbs_eq b with
      | inl h₂ | inr h₂ => rw [h₁, h₂]; simp [h]
· cases h with (subst a; try rfl)
    | inr h => rw [Int.natAbs_neg]
rw [← Int.natAbs_eq_natAbs_iff, Int.natAbs_ofNat]

/- ## sign -/
rw [Int.natAbs_sign, if_neg hz]
match z with | 0 | succ _ | -[_+1] => rfl

/- # ring properties -/

/- addition -/
simp [Nat.add_comm]
simp [Nat.add_comm]
simp [succ_sub (le_of_lt_succ h), subNatNat]
cases n.lt_or_ge k with
  | inl h' =>
    simp [subNatNat_of_lt h', succ_pred_eq_of_pos (Nat.sub_pos_of_lt h')]
    conv => lhs; rw [← Nat.sub_add_cancel (Nat.le_of_lt h')]
    apply subNatNat_add_add
  | inr h' => simp [subNatNat_of_le h',
      subNatNat_of_le (Nat.le_trans h' (le_add_left ..)), Nat.add_sub_assoc h']
have h := Nat.lt_or_ge m n
cases h with
  | inr h' =>
    rw [subNatNat_of_le h']
    simp
    rw [subNatNat_sub h', Nat.add_comm]
  | inl h' =>
    have h₂ : m < n + succ k := Nat.lt_of_lt_of_le h' (le_add_right _ _)
    have h₃ : m ≤ n + k := le_of_succ_le_succ h₂
    rw [subNatNat_of_lt h', subNatNat_of_lt h₂]
    simp [Nat.add_comm]
    rw [← add_succ, succ_pred_eq_of_pos (Nat.sub_pos_of_lt h'), add_succ, succ_sub h₃, Nat.pred_succ]
    rw [Nat.add_comm n, Nat.add_sub_assoc (Nat.le_of_lt h')]
rw [Int.add_comm, ← aux1, Int.add_comm k, aux1, Int.add_comm b]
rw [Int.add_comm, Int.add_comm a, ← aux1, Int.add_comm a, Int.add_comm (ofNat k)]
rw [Int.add_comm, ← aux2, Int.add_comm n, ← aux2, Int.add_comm -[m+1]]
rw [Int.add_comm, Int.add_comm (ofNat m), Int.add_comm m, ← aux2, Int.add_comm -[k+1]]
simp [add_succ, Nat.add_comm, Nat.add_left_comm, neg_ofNat_of_succ]
simp [Nat.add_assoc]
simp [subNatNat_add]
simp [add_succ]
rw [Int.add_comm, subNatNat_add_negSucc]
simp [add_succ, succ_add, Nat.add_comm]
rw [← Int.add_assoc, Int.add_comm a, Int.add_assoc]
rw [Int.add_assoc, Int.add_comm b, ← Int.add_assoc]

/- ## negation -/
rw [subNatNat_of_sub_eq_zero (Nat.sub_self ..), Nat.sub_self, ofNat_zero]
simp
simp
rw [Int.add_comm, Int.add_left_neg]
rw [← Int.add_zero (-a), ← h, ← Int.add_assoc, Int.add_left_neg, Int.zero_add]
rw [h, Int.neg_neg]
rw [← Int.add_assoc, Int.add_left_neg, Int.zero_add]
rw [← Int.add_assoc, Int.add_right_neg, Int.zero_add]
rw [Int.add_assoc, Int.add_right_neg, Int.add_zero]
rw [Int.add_assoc, Int.add_left_neg, Int.add_zero]
rw [h]
apply Int.add_left_cancel (a := a + b)
rw [Int.add_right_neg, Int.add_comm a, ← Int.add_assoc, Int.add_assoc b,
    Int.add_right_neg, Int.add_zero, Int.add_right_neg]

/- ## subtraction -/
rw [Int.sub_eq_add_neg, Int.add_right_neg]
simp [Int.sub_eq_add_neg]
simp [Int.sub_eq_add_neg]
rw [h, Int.sub_self]
rw [Int.zero_add]
simp [Int.sub_eq_add_neg, Int.add_assoc]
simp [Int.sub_eq_add_neg, Int.add_comm]
simp [Int.sub_eq_add_neg, ← Int.add_assoc]
simp [Int.sub_eq_add_neg]

/- ## multiplication -/
cases a <;> cases b <;> simp [Nat.mul_comm]
cases n <;> rfl
rw [Int.mul_comm]
simp [ofNat_mul_negOfNat, Nat.mul_comm]
cases n <;> rfl
rw [Int.mul_comm, negSucc_mul_negOfNat, Nat.mul_comm]
cases a <;> cases b <;> cases c <;> simp [Nat.mul_assoc]
rw [← Int.mul_assoc, ← Int.mul_assoc, Int.mul_comm a]
rw [Int.mul_assoc, Int.mul_assoc, Int.mul_comm b]
cases a <;> rfl
cases n <;> rfl
cases m with
  | zero => simp [ofNat_zero, Int.zero_mul, Nat.zero_mul]
  | succ m => cases n.lt_or_ge k with
    | inl h =>
      have h' : succ m * n < succ m * k := Nat.mul_lt_mul_of_pos_left h (Nat.succ_pos m)
      simp [subNatNat_of_lt h, subNatNat_of_lt h']
      rw [succ_pred_eq_of_pos (Nat.sub_pos_of_lt h), ← neg_ofNat_of_succ, Nat.mul_sub_left_distrib,
        ← succ_pred_eq_of_pos (Nat.sub_pos_of_lt h')]; rfl
    | inr h =>
      have h' : succ m * k ≤ succ m * n := Nat.mul_le_mul_left _ h
      simp [subNatNat_of_le h, subNatNat_of_le h', Nat.mul_sub_left_distrib]
cases m <;> cases n <;> simp [Nat.succ_add] <;> rfl
cases n.lt_or_ge k with
  | inl h =>
    have h' : succ m * n < succ m * k := Nat.mul_lt_mul_of_pos_left h (Nat.succ_pos m)
    rw [subNatNat_of_lt h, subNatNat_of_le (Nat.le_of_lt h')]
    simp [succ_pred_eq_of_pos (Nat.sub_pos_of_lt h), Nat.mul_sub_left_distrib]
  | inr h => cases Nat.lt_or_ge k n with
    | inl h' =>
      have h₁ : succ m * n > succ m * k := Nat.mul_lt_mul_of_pos_left h' (Nat.succ_pos m)
      rw [subNatNat_of_le h, subNatNat_of_lt h₁, negSucc_mul_ofNat,
        Nat.mul_sub_left_distrib, ← succ_pred_eq_of_pos (Nat.sub_pos_of_lt h₁)]; rfl
    | inr h' => rw [Nat.le_antisymm h h', subNatNat_self, subNatNat_self, Int.mul_zero]
simp [Nat.left_distrib]
simp [negOfNat_eq_subNatNat_zero]
rw [← subNatNat_add]
rfl
simp [negOfNat_eq_subNatNat_zero]
rw [Int.add_comm, ← subNatNat_add]
rfl
simp
rw [← Nat.left_distrib, succ_add]
rfl
simp [Nat.mul_comm]
rw [← Nat.right_distrib, Nat.mul_comm]
simp [negOfNat_eq_subNatNat_zero]
rw [Int.add_comm, ← subNatNat_add]
rfl
simp [negOfNat_eq_subNatNat_zero]
rw [← subNatNat_add]
rfl
simp
rw [← Nat.left_distrib, succ_add]
rfl
simp [Int.mul_comm, Int.mul_add]
rw [← Int.add_mul, Int.add_right_neg, Int.zero_mul]
rw [← Int.mul_add, Int.add_right_neg, Int.mul_zero]
simp
simp
simp [Int.sub_eq_add_neg, Int.mul_add]
simp [Int.sub_eq_add_neg, Int.add_mul]
rw [Int.sub_eq_add_neg, Int.add_assoc, ← Int.sub_eq_add_neg]
match m with
  | 0 => rfl
  | succ m =>
    show ofNat (n - succ m) = subNatNat n (succ m)
    rw [subNatNat, Nat.sub_eq_zero_of_le h]
rw [Int.sub_eq_add_neg, ← Int.neg_add]
rfl
apply subNatNat_elim m n fun m n i => i = m - n
· intros i n
    rw [Int.ofNat_add, Int.sub_eq_add_neg, Int.add_assoc, Int.add_left_comm,
      Int.add_right_neg, Int.add_zero]
· intros i n
    simp only [negSucc_coe, ofNat_add, Int.sub_eq_add_neg, Int.neg_add, ← Int.add_assoc]
    rw [← @Int.sub_eq_add_neg n, ← ofNat_sub, Nat.sub_self, ofNat_zero, Int.zero_add]
    apply Nat.le_refl
rw [← Int.subNatNat_eq_coe]
refine subNatNat_elim m n (fun m n i => toNat i = m - n) (fun i n => ?_) (fun i n => ?_)
· exact (Nat.add_sub_cancel_left ..).symm
· dsimp; rw [Nat.add_assoc, Nat.sub_eq_zero_of_le (Nat.le_add_right ..)]; rfl
rw [Nat.one_mul]
rw [Nat.one_mul]
rw [Int.mul_comm, Int.one_mul]
rw [Int.mul_neg, Int.mul_one]
rw [Nat.one_mul]
rfl
rw [Nat.one_mul]
rfl
simp [Int.mul_zero, Int.zero_mul]
simp [le_def, h]
constructor
rw [← h, Int.add_comm]
simp [Int.sub_eq_add_neg, Int.add_assoc]
rw [← h₁, Int.add_comm]
simp [Int.sub_eq_add_neg, Int.add_assoc]
simp [Int.add_comm, Int.sub_eq_add_neg]
rw [← hk]
rfl
have t := le.dest_sub h
simp [Int.sub_eq_add_neg] at t
exact t
rw [Nat.add_comm] at h
exact h.symm
rw [Int.add_comm, Int.add_left_comm]
rfl
rw [lt_iff_add_one_le, ← ofNat_succ, ofNat_le]
rfl
rw [← hm, ← hn, Int.add_assoc, ofNat_add]
let ⟨n, hn⟩ := le.dest h₁
let ⟨m, hm⟩ := le.dest h₂
have := hn
rw [← hm, Int.add_assoc, ← ofNat_add] at this
have := Int.ofNat.inj <| Int.add_left_cancel <| this.trans (Int.add_zero _).symm
rw [← hn, Nat.eq_zero_of_add_eq_zero_left this, ofNat_zero, Int.add_zero a]
rw [hn, Int.add_zero]
cases e
exact Int.lt_irrefl _ h
rw [← hn, eq, ofNat_zero, Int.add_zero]
let ⟨n, hn⟩ := eq_ofNat_of_zero_le ha
let ⟨m, hm⟩ := eq_ofNat_of_zero_le hb
rw [hn, hm, ← ofNat_mul]
apply ofNat_nonneg
let ⟨n, hn⟩ := eq_succ_of_zero_lt ha
let ⟨m, hm⟩ := eq_succ_of_zero_lt hb
rw [hn, hm, ← ofNat_mul]
apply ofNat_succ_pos
rw [Int.lt_iff_le_and_ne]
constructor <;> refine fun ⟨h, h'⟩ => ⟨h, h'.imp fun h' => ?_⟩
· exact Int.le_antisymm h h'
· subst h'; apply Int.le_refl
rw [← Int.not_le, Decidable.not_not]
simp [Int.min_def]
rw [Int.min_def]
split <;> simp [*]
rw [Int.min_def]
split <;> assumption
simp [Int.min_def, h]
rw [Int.min_comm a b]
exact Int.min_eq_left h
simp only [Int.max_def]
rw [Int.max_def]
split <;> simp [*]
rw [Int.max_def]
split <;> assumption
simp [Int.max_def, h, Int.not_lt.2 h]
rw [← Int.max_comm b a]
exact Int.max_eq_right h
let ⟨n, e⟩ := eq_ofNat_of_zero_le h
rw [e]
rfl
rw [eq_natAbs_of_zero_le h]
apply Int.le_refl
simp only [Int.not_le, iff_false]
exact Int.negSucc_lt_zero n
simp only [Int.not_lt, iff_false]
constructor
rw [Int.add_assoc, hn]
have : -a + (a + b) ≤ -a + (a + c) := Int.add_le_add_left h _
simp [Int.neg_add_cancel_left] at this
assumption
have : -a + (a + b) < -a + (a + c) := Int.add_lt_add_left h _
simp [Int.neg_add_cancel_left] at this
assumption
simp [Int.neg_neg] at this
assumption
rw [Int.add_comm] at h
exact Int.le_add_of_sub_left_le h
rw [Int.add_comm]
exact Int.sub_left_le_of_le_add h
rw [Int.add_comm] at h
exact Int.le_add_of_sub_right_le h
rw [Int.add_comm] at h
exact Int.neg_add_le_left_of_le_add h
rw [Int.add_comm] at h
exact Int.lt_add_of_sub_left_lt h
rw [Int.add_comm]
exact Int.sub_left_lt_of_lt_add h
rw [Int.add_comm] at h
exact Int.lt_add_of_sub_right_lt h
rw [Int.add_comm] at h
exact Int.neg_add_lt_left_of_lt_add h
rw [Int.add_zero]
rw [Int.add_zero]
have : 0 < c * (b - a) := Int.mul_pos h₂ (Int.sub_pos_of_lt h₁)
rw [Int.mul_sub] at this
exact Int.lt_of_sub_pos this
have : 0 < b - a := Int.sub_pos_of_lt h₁
have : 0 < (b - a) * c := Int.mul_pos this h₂
rw [Int.sub_mul] at this
exact Int.lt_of_sub_pos this
rw [Int.mul_comm, Int.mul_comm b]
exact Int.mul_le_mul_of_nonneg_left h₁ h₂
rw [← natAbs_neg, natAbs_of_nonneg (Int.neg_nonneg_of_nonpos H)]
rw [h, sign_zero]
simp [·, Int.zero_mul]
simp [·, Int.mul_zero]
rw [Int.mul_sub, this]
rw [Int.one_mul, H]
rw [Int.mul_one, H]
rw [natAbs_eq_iff, Int.mul_eq_zero, ← Int.sub_neg, Int.sub_eq_zero, Int.sub_eq_zero]
match a, b with
    | ofNat a, ofNat b => simp
    | ofNat a, negSucc b => simp; apply this
    | negSucc a, ofNat b => simp [Nat.succ_add, Nat.add_comm a b]; apply this
    | negSucc a, negSucc b => simp [Nat.succ_add]; apply Nat.le_refl
rw [← Int.natAbs_neg b]
apply natAbs_add_le
simp only [negSucc_eq, Int.neg_add]
rfl
rw [toNat_eq_max, Int.max_eq_left h]
rw [toNat_eq_max]
apply Int.le_max_left
rw [← Int.ofNat_le, Int.toNat_of_nonneg h]
rw [← Int.not_le, ← Nat.not_le, Int.le_toNat h]
simp [ofNat_add]
constructor <;> intro.
decide
decide
simp [hg] at den_nz
exact den_nz
      reduced
simp [hg, Int.natAbs_ofNat] at reduced
exact reduced
match num, num.eq_nat_or_neg with
    | _, ⟨_, .inl rfl⟩ => rfl
    | _, ⟨_, .inr rfl⟩ => rw [Int.neg_div, Int.natAbs_neg, Int.natAbs_neg]; rfl
decide
decide
simp only [Int.natAbs_mul, Int.natAbs_div, Nat.coprime_mul_iff_left]
refine ⟨Nat.coprime_mul_iff_right.2 ⟨?_, ?_⟩, Nat.coprime_mul_iff_right.2 ⟨?_, ?_⟩⟩
· exact Nat.coprime_div_gcd_div_gcd (Nat.gcd_pos_of_pos_right _ b.den_pos)
· exact a.reduced.coprime_div_left (Nat.gcd_dvd_left ..)
          |>.coprime_div_right (Nat.gcd_dvd_left ..)
· exact b.reduced.coprime_div_left (Nat.gcd_dvd_right ..)
          |>.coprime_div_right (Nat.gcd_dvd_right ..)
· exact (Nat.coprime_div_gcd_div_gcd (Nat.gcd_pos_of_pos_left _ a.den_pos)).symm
rw [Nat.mul_assoc, be]
rw [Int.natAbs_neg]
exact a.reduced
have := add.aux a (-b) hg had hbd
simp only [show (-b).num = -b.num from rfl, Int.mul_neg] at this
exact this
unfold maybeNormalize
split
· subst g; simp
· rfl
simp [normalize, Int.zero_div, Int.natAbs_zero, Nat.div_self (Nat.pos_of_ne_zero nz)]
rfl
unfold mkRat
split <;> simp
simp at h
exact h
simp [size]
simp [size]
unfold foldlM.loop
split
split
· cases Nat.not_le_of_gt ‹_› (Nat.zero_add _ ▸ H)
· rename_i i; rw [Nat.succ_add] at H
    simp [foldlM_eq_foldlM_data.aux f arr i (j+1) H]
    conv => rhs; rw [← List.get_drop_eq_drop _ _ ‹_›]
· rw [List.drop_length_le (Nat.ge_of_not_lt ‹_›)]; rfl
simp [foldlM, foldlM_eq_foldlM_data.aux]
unfold foldrM.fold
match i with
  | 0 => simp [List.foldlM, List.take]
  | i+1 => rw [← List.take_concat_get _ _ h]; simp [← (aux f arr · i)]; rfl
have : arr = #[] ∨ 0 < arr.size :=
    match arr with | ⟨[]⟩ => .inl rfl | ⟨a::l⟩ => .inr (Nat.zero_lt_succ _)
match arr, this with | _, .inl rfl => rfl | arr, .inr h => ?_
simp [foldrM, h, ← foldrM_eq_reverse_foldlM_data.aux, List.take_length]
rw [foldrM_eq_reverse_foldlM_data, List.foldlM_reverse]
simp [push, List.concat_eq_append]
simp [foldrM_eq_reverse_foldlM_data, -size_push]
simp [← foldrM_push]
simp [toListAppend, foldr_eq_foldr_data]
simp [toList, foldr_eq_foldr_data]
rw [toListRev, foldl_eq_foldl_data, ← List.foldr_reverse, List.foldr_self]
simp [hj]
have := SatisfiesM_foldlM (m := Id) (as := as) (f := f) motive h0
simp [SatisfiesM_Id_eq] at this
exact this hf
simp [*, Nat.lt_succ_of_le, Nat.le_of_lt]
simp only [push, getElem_eq_data_get, List.concat_eq_append, List.get_append_left, h]
simp only [push, getElem_eq_data_get, List.concat_eq_append]
rw [List.get_append_right] <;> simp [getElem_eq_data_get]
simp [eq]
induction l generalizing arr <;> simp [*]
simp [size]
have := SatisfiesM_mapM' (m := Id) arr f (fun i b => b = f (arr[i]))
simp [SatisfiesM_Id_eq] at this
exact this.2 i (size_map .. ▸ h)
rw [← append_eq_append]
unfold Array.append
rw [foldl_eq_foldl_data]
induction arr'.data generalizing arr <;> simp [*]
rw [← appendList_eq_append]
unfold Array.appendList
induction l generalizing arr <;> simp [*]
induction l generalizing acc <;> simp [*, List.bind]
induction l generalizing acc <;> simp [*]
simp
simp [getElem?_neg, h]
simp [getElem_eq_data_get, List.get_mem]
simp [get?, getD]
split <;> simp
simp [get!_eq_getD]
simp [back, back?]
simp [back?, getElem?_eq_data_get?]
simp
rw [getElem?_pos, get_push_lt]
rw [getElem?_pos, get_push_eq]
simp [i.2]
simp only [set, getElem_eq_data_get, List.get_set_eq]
simp [*]
simp only [set, getElem_eq_data_get, List.get_set_ne h]
simp [getElem?_pos, i.2]
simp [*]
cases e
rfl
simp [j.2]
simp [swap, fin_cast_val]
simp [swap_def]
simp [swap_def, get?_set, ← getElem_fin_eq_data_get]
simp [swapAt!, h]
simp [pop]
simp [pop]
unfold foldrM.fold
simp
split
· next hi => exact .pure (hi ▸ H)
· next hi =>
      split; {simp at hi}
      · next i hi' =>
        exact (hf ⟨i, hi'⟩ b H).bind fun _ => go _
have := SatisfiesM_foldrM (m := Id) (as := as) (f := f) motive h0
simp [SatisfiesM_Id_eq] at this
exact this hf
rw [mapM, foldlM_eq_foldlM_data, ← List.foldrM_reverse, mkEmpty_eq]
conv => rhs; rw [← List.reverse_reverse arr.data]
induction arr.data.reverse with
  | nil => simp; rfl
  | cons a l ih => simp [ih]; simp [push]
exact hm
simp [h₁]
have := SatisfiesM_mapIdxM (m := Id) (as := as) (f := f) motive h0
simp [SatisfiesM_Id_eq] at this
exact this _ hs
simp_all
simp [swap!, hi, hj]
rw [reverse.loop]
simp_arith
simp_arith
simp [this]
simp [ofFn]
simp [*]
unfold ofFn.go
simp [*]
simp
simp
cases l <;> simp [*, isEmpty, List.isEmpty]
induction l generalizing init <;> simp [*, foldlM]
simp [List.foldl_eq_foldlM, foldl, Id.run]
funext α β as
simp [toListTR]
exact .symm <| (Array.foldl_data_eq_map (toList as) _ id).trans (List.map_id _)
induction l <;> simp [*, forM]
induction l <;> simp [*]
induction l <;> simp [*]
induction l <;> simp [findEntryP?]
split <;> simp [*]
induction l <;> simp [find?]
split <;> simp [*]
simp [find?_eq_findEntry?]
induction l <;> simp [any, *]
induction l <;> simp [all, *]
induction l <;> simp [*, contains]
induction l <;> simp [replace]
split <;> simp [*]
induction l <;> simp [List.eraseP, cond]
split <;> simp [*]
simp [forIn, List.forIn]
induction l generalizing init <;> simp [AssocList.forIn, List.forIn.loop]
congr
funext a
split <;> simp [*]
induction l <;> simp [*]
induction l <;> simp [*]
simp [modify, alter]
split <;> simp [Option.map]

-- theorem WF.modify {t : RBNode α} (H : ∀ {x}, t.find? cut = some x → cmpEq cmp (f x) x)
--     (wf : WF cmp t) : WF cmp (t.modify cut f) :=
--   modify_eq_alter _ ▸ wf.alter fun | h, rfl => H h
unfold balance1
split <;> simp [and_assoc, and_left_comm]
unfold balance2
split <;> simp [and_assoc, and_left_comm]
unfold setBlack
split <;> simp [Ordered]
cases t <;> rfl
unfold insert
split <;> simp [setBlack_idem]
induction t <;> unfold ins <;> simp [*] <;> split <;>
    cases ‹_=_› <;> split <;> simp at h₂ <;> simp [*]
unfold ins
split
· next h => exact ⟨ay.ins ⟨h⟩, yb, ha.ins, hb⟩
· next h => exact ⟨ay, yb.ins ⟨OrientedCmp.cmp_eq_gt.1 h⟩, ha, hb.ins⟩
· next h => exact (⟨
        ay.imp fun ⟨h'⟩ => ⟨(TransCmp.cmp_congr_right h).trans h'⟩,
        yb.imp fun ⟨h'⟩ => ⟨(TransCmp.cmp_congr_left h).trans h'⟩, ha, hb⟩)
unfold ins
split
· next h => exact ha.ins.balance1 (ay.ins ⟨h⟩) yb hb
· next h => exact ha.balance2 ay (yb.ins ⟨OrientedCmp.cmp_eq_gt.1 h⟩) hb.ins
· next h => exact (⟨
        ay.imp fun ⟨h'⟩ => ⟨(TransCmp.cmp_congr_right h).trans h'⟩,
        yb.imp fun ⟨h'⟩ => ⟨(TransCmp.cmp_congr_left h).trans h'⟩, ha, hb⟩)
unfold RBNode.insert
split <;> simp [Ordered.setBlack, h.ins (x := v)]
unfold balance1
split
· have .redred _ (.red ha hb) hc := hl; exact ⟨_, .red (.black ha hb) (.black hc hr)⟩
· have .redred _ ha (.red hb hc) := hl; exact ⟨_, .red (.black ha hb) (.black hc hr)⟩
· next H1 H2 => match hl with
    | .balanced hl => exact ⟨_, .black hl hr⟩
    | .redred _ (c₁ := black) (c₂ := black) ha hb => exact ⟨_, .black (.red ha hb) hr⟩
    | .redred _ (c₁ := red) (.red ..) _ => cases H1 _ _ _ _ _ rfl
    | .redred _ (c₂ := red) _ (.red ..) => cases H2 _ _ _ _ _ rfl
unfold balance2
split
· have .redred _ (.red ha hb) hc := hr; exact ⟨_, .red (.black hl ha) (.black hb hc)⟩
· have .redred _ ha (.red hb hc) := hr; exact ⟨_, .red (.black hl ha) (.black hb hc)⟩
· next H1 H2 => match hr with
    | .balanced hr => exact ⟨_, .black hl hr⟩
    | .redred _ (c₁ := black) (c₂ := black) ha hb => exact ⟨_, .black hl (.red ha hb)⟩
    | .redred _ (c₁ := red) (.red ..) _ => cases H1 _ _ _ _ _ rfl
    | .redred _ (c₂ := red) _ (.red ..) => cases H2 _ _ _ _ _ rfl
induction h with
  | nil => exact .balanced (.red .nil .nil)
  | @red a n b x hl hr ihl ihr =>
    unfold ins; split
    · match ins cmp v a, ihl with
      | _, .balanced .nil => exact .balanced (.red .nil hr)
      | _, .balanced (.red ha hb) => exact .redred rfl (.red ha hb) hr
      | _, .balanced (.black ha hb) => exact .balanced (.red (.black ha hb) hr)
      | _, .redred h .. => cases hl <;> cases h
    · match ins cmp v b, ihr with
      | _, .balanced .nil => exact .balanced (.red hl .nil)
      | _, .balanced (.red ha hb) => exact .redred rfl hl (.red ha hb)
      | _, .balanced (.black ha hb) => exact .balanced (.red hl (.black ha hb))
      | _, .redred h .. => cases hr <;> cases h
    · exact .balanced (.red hl hr)
  | @black a ca n b cb x hl hr ihl ihr =>
    unfold ins; split
    · exact have ⟨c, h⟩ := ihl.balance1 hr; .balanced h
    · exact have ⟨c, h⟩ := ihr.balance2 hl; .balanced h
    · exact .balanced (.black hl hr)
unfold setRed
split <;> simp_all
unfold setRed
split <;> simp [Ordered]
unfold balLeft
split <;> simp_all
split <;> simp_all [All.setRed]
unfold balLeft
split
· exact ⟨lv, vr, hl, hr⟩
split
· exact hl.balance2 lv vr hr
· have ⟨vy, va, _⟩ := vr.2.1; have ⟨⟨yz, _, bz⟩, zc, ⟨ay, yb, ha, hb⟩, hc⟩ := hr
    exact ⟨⟨vy, vy.trans_r lv, ay⟩, balance2_All.2 ⟨yz, yb, (yz.trans_l zc).setRed⟩,
      ⟨lv, va, hl, ha⟩, hb.balance2 bz zc.setRed (Ordered.setRed.2 hc)⟩
· exact ⟨lv, vr, hl, hr⟩
unfold balLeft
split
· next a x b => exact
    let ⟨ca, cb, ha, hb⟩ := hl.of_red
    match cr with
    | red => .redred rfl (.black ha hb) hr
    | black => .balanced (.red (.black ha hb) hr)
· next H => exact match hl with
    | .redred .. => nomatch H _ _ _ rfl
    | .balanced hl => match hr with
      | .black ha hb =>
        let ⟨c, h⟩ := RedRed.balance2 hl (.redred trivial ha hb); .balanced h
      | .red (.black ha hb) (.black hc hd) =>
        let ⟨c, h⟩ := RedRed.balance2 hb (.redred trivial hc hd); .redred rfl (.black hl ha) h
unfold balRight
split <;> simp_all
split <;> simp_all [All.setRed]
unfold balRight
split
· next b y c => exact
    let ⟨cb, cc, hb, hc⟩ := hr.of_red
    match cl with
    | red => .redred rfl hl (.black hb hc)
    | black => .balanced (.red hl (.black hb hc))
· next H => exact match hr with
    | .redred .. => nomatch H _ _ _ rfl
    | .balanced hr => match hl with
      | .black hb hc =>
        let ⟨c, h⟩ := RedRed.balance1 (.redred trivial hb hc) hr; .balanced h
      | .red (.black ha hb) (.black hc hd) =>
        let ⟨c, h⟩ := RedRed.balance1 (.redred trivial ha hb) hc; .redred rfl h (.black hd hr)
unfold append
split <;> simp [*]
· have ⟨hx, ha, hb⟩ := hl; have ⟨hy, hc, hd⟩ := hr
    have := hb.append hc; split <;> simp_all
· have ⟨hx, ha, hb⟩ := hl; have ⟨hy, hc, hd⟩ := hr
    have := hb.append hc; split <;> simp_all [All.balLeft]
· simp_all [hl.append hr.2.1]
· simp_all [hl.2.2.append hr]
unfold append
split
· exact hr
· exact hl
· have ⟨xv, _, bv⟩ := lv; have ⟨ax, xb, ha, hb⟩ := hl
    have ⟨vy, vc, _⟩ := vr; have ⟨cy, yd, hc, hd⟩ := hr
    have : _ ∧ _ ∧ _ := ⟨hb.append bv vc hc, xb.append (xv.trans_l vc), (vy.trans_r bv).append cy⟩
    split
    · next H =>
      have ⟨⟨b'z, c'z, hb', hc'⟩, ⟨xz, xb', _⟩, zy, _, c'y⟩ := H ▸ this
      have az := xz.trans_r ax; have zd := zy.trans_l yd
      exact ⟨⟨xz, az, b'z⟩, ⟨zy, c'z, zd⟩, ⟨ax, xb', ha, hb'⟩, c'y, yd, hc', hd⟩
    · have ⟨hbc, xbc, bcy⟩ := this; have xy := xv.trans vy
      exact ⟨ax, ⟨xy, xbc, xy.trans_l yd⟩, ha, bcy, yd, hbc, hd⟩
· have ⟨xv, _, bv⟩ := lv; have ⟨ax, xb, ha, hb⟩ := hl
    have ⟨vy, vc, _⟩ := vr; have ⟨cy, yd, hc, hd⟩ := hr
    have : _ ∧ _ ∧ _ := ⟨hb.append bv vc hc, xb.append (xv.trans_l vc), (vy.trans_r bv).append cy⟩
    split
    · next H =>
      have ⟨⟨b'z, c'z, hb', hc'⟩, ⟨xz, xb', _⟩, zy, _, c'y⟩ := H ▸ this
      have az := xz.trans_r ax; have zd := zy.trans_l yd
      exact ⟨⟨xz, az, b'z⟩, ⟨zy, c'z, zd⟩, ⟨ax, xb', ha, hb'⟩, c'y, yd, hc', hd⟩
    · have ⟨hbc, xbc, bcy⟩ := this; have xy := xv.trans vy
      exact ha.balLeft ax ⟨xy, xbc, xy.trans_l yd⟩ ⟨bcy, yd, hbc, hd⟩
· have ⟨vx, vb, _⟩ := vr; have ⟨bx, yc, hb, hc⟩ := hr
    exact ⟨(vx.trans_r lv).append bx, yc, hl.append lv vb hb, hc⟩
· have ⟨xv, _, bv⟩ := lv; have ⟨ax, xb, ha, hb⟩ := hl
    exact ⟨ax, xb.append (xv.trans_l vr), ha, hb.append bv vr hr⟩
unfold DelProp at h
exact match c, h with
  | red, ⟨_, h⟩ => ⟨_, .balanced h⟩
  | black, ⟨_, _, h⟩ => ⟨_, h.imp fun _ => rfl⟩
unfold del
split
· split
      · exact ha.del.balLeft hy hb
      · exact ⟨hy, ha.del, hb⟩
· split
      · exact ha.balRight hy hb.del
      · exact ⟨hy, ha, hb.del⟩
· exact ha.append hb
unfold del
split
· split
      · exact ha.del.balLeft ay.del yb hb
      · exact ⟨ay.del, yb, ha.del, hb⟩
· split
      · exact ha.balRight ay yb.del hb.del
      · exact ⟨ay, yb.del, ha, hb.del⟩
· exact ha.append ay yb hb
revert e
unfold zoom
split
· exact zoom_zoomed
· exact zoom_zoomed
· next H => intro e; cases e; exact H
unfold RBNode.ins
split <;> simp [zoom]
· intro | rfl, rfl => rfl
all_goals
  · split
    · exact zoom_ins
    · exact zoom_ins
    · intro | rfl => rfl
unfold RBNode.del
split <;> simp [zoom]
· intro | rfl, rfl => rfl
· next c a y b =>
    split
    · have IH := @zoom_del (t := a)
      match a with
      | nil => intro | rfl => rfl
      | node black .. | node red .. => apply IH
    · have IH := @zoom_del (t := b)
      match b with
      | nil => intro | rfl => rfl
      | node black .. | node red .. => apply IH
    · intro | rfl => rfl
assumption
cases e
exact ⟨_, _, .nil, hp⟩
unfold zoom
split
· exact ha.zoom (.redL hb hp)
· exact hb.zoom (.redR ha hp)
· intro e; cases e; exact ⟨_, _, .red ha hb, hp⟩
unfold zoom
split
· exact ha.zoom (.blackL hb hp)
· exact hb.zoom (.blackR ha hp)
· intro e; cases e; exact ⟨_, _, .black ha hb, hp⟩
unfold ins
exact ins_eq_fill H (.red ha hb)
rw [ins, fill, ← ins_eq_fill H (.black ha hb), balance1_eq ha]
rw [ins, fill, ← ins_eq_fill H (.black ha hb), balance2_eq hb]
induction hp generalizing t with
  | root => exact ht.setBlack
  | redL hr hp ih => match ht with
    | .balanced .nil => exact ih (.balanced (.red .nil hr))
    | .balanced (.red ha hb) => exact ih (.redred rfl (.red ha hb) hr)
    | .balanced (.black ha hb) => exact ih (.balanced (.red (.black ha hb) hr))
  | redR hl hp ih => match ht with
    | .balanced .nil => exact ih (.balanced (.red hl .nil))
    | .balanced (.red ha hb) => exact ih (.redred rfl hl (.red ha hb))
    | .balanced (.black ha hb) => exact ih (.balanced (.red hl (.black ha hb)))
  | blackL hr hp ih => exact have ⟨c, h⟩ := ht.balance1 hr; ih (.balanced h)
  | blackR hl hp ih => exact have ⟨c, h⟩ := ht.balance2 hl; ih (.balanced h)
have ⟨_, _, ht', hp'⟩ := ht.zoom .root H
cases ht' with simp [insert]
  | nil => simp [insertNew_eq_insert H, setBlack_idem]
  | red hl hr => rw [← ins_eq_fill hp' (.red hl hr), insert_setBlack]; exact (zoom_ins H).symm
  | black hl hr => rw [← ins_eq_fill hp' (.black hl hr), insert_setBlack]; exact (zoom_ins H).symm
induction h with
  | mk o h => exact ⟨o, _, _, h⟩
  | insert _ ih => have ⟨o, _, _, h⟩ := ih; exact ⟨o.insert, h.insert⟩
  | erase _ ih => have ⟨o, _, _, h⟩ := ih; exact ⟨o.erase, _, h.erase⟩
  -- | alter hf _ ih => have ⟨o, _, _, h⟩ := ih; exact ⟨o.alter hf, h.alter⟩
refine ⟨ax.map ?_, xb.map ?_, ha.map f, hb.map f⟩ <;> exact IsMonotone.lt_mono
decide
decide
decide
rw [size, Nat.add_right_comm (size _), Nat.add_assoc, depthLB, Nat.pow_succ, Nat.mul_two]
exact Nat.add_le_add hl.le_size hr.le_size
decide
simp [(·∈·), EMem]
simp [(·∈·), EMem]
induction t <;> simp [or_imp, forall_and, *]
induction t <;> simp [or_and_right, exists_or, *]
cases ey : cut y
· exact IsCut.le_lt_trans (fun h => nomatch H.symm.trans <| OrientedCmp.cmp_eq_gt.1 h) ey
· cases ex : cut x
    · exact IsCut.le_lt_trans (fun h => nomatch H.symm.trans h) ex |>.symm.trans ey
    · rfl
    · refine IsCut.le_gt_trans (cmp := cmp) (fun h => ?_) ex |>.symm.trans ey
      cases H.symm.trans <| OrientedCmp.cmp_eq_gt.1 h
· exact IsCut.le_gt_trans (fun h => nomatch H.symm.trans h) ey
induction t <;> simp [find?] <;> split <;> try assumption
intro | rfl => assumption
induction t <;> simp [find?] <;> split <;> simp (config := {contextual := true}) [*]
refine ⟨fun h => ⟨find?_some_mem h, find?_some_eq_eq h⟩, fun ⟨hx, e⟩ => ?_⟩
have ⟨y, hy⟩ := ht.memP_iff_find?.1 (memP_def.2 ⟨_, hx, e⟩)
exact ht.unique hx (find?_some_mem hy) ((IsStrictCut.exact e).trans (find?_some_eq_eq hy)) ▸ hy
induction t generalizing lb with
  | nil => exact H
  | node _ _ _ _ ihl ihr =>
    simp [lowerBound?]; split
    · exact ihl H
    · next hv => exact ihr fun | rfl, e => nomatch hv.symm.trans e
    · next hv => intro | rfl, e => cases hv.symm.trans e
induction t generalizing lb with
  | nil => exact H
  | node _ _ _ _ ihl ihr =>
    simp [lowerBound?]; split
    · exact ihl hp.2.1 H
    · exact ihr hp.2.2 fun | rfl => hp.1
    · exact fun | rfl => hp.1
simp
induction t generalizing y <;> simp [lowerBound?]
split <;> simp [*]
refine memP_def.trans ⟨fun ⟨y, hy, ey⟩ => ?_, fun ⟨x, hx, e⟩ => ⟨_, lowerBound?_mem hx, e⟩⟩
have ⟨x, hx⟩ := ht.lowerBound?_exists.2 ⟨_, hy, fun h => nomatch ey.symm.trans h⟩
refine ⟨x, hx, ?_⟩
cases ex : cut x
· cases lowerBound?_le hx ex
· rfl
· cases e : cmp x y
    · cases ey.symm.trans <| ht.lowerBound?_least hx hy e ex
    · cases ey.symm.trans <| IsCut.congr e |>.symm.trans ex
    · cases ey.symm.trans <| IsCut.gt_trans (OrientedCmp.cmp_eq_gt.1 e) ex
simp [append_inj (cons.inj h).2 (Nat.succ.inj hl)] at h ⊢
exact h
let hap := congrArg length h
simp only [length_append, ← hl] at hap
exact hap
intro l₁ <;> induction l₁ <;> intros <;> simp_all
induction l <;> simp_all
induction l <;> simp_all
simp [join, List.bind]
simp [join, List.bind]
induction xs
{rfl}
simp_all [cons_bind, append_assoc]
simp [List.bind]
induction l <;> simp [*]
have := take_append_drop i l
rw [drop_length_le h, append_nil] at this
exact this
rw [concat_eq_append, append_assoc, singleton_append, get_drop_eq_drop, take_append_drop]
rw [concat_eq_append, reverse_append]
rfl
induction l generalizing b <;> simp [*]
simp only [foldrM]
induction l <;> simp_all
simp
induction l generalizing b <;> simp [*, foldl]
induction l <;> simp [*]
simp [foldl_eq_foldlM, foldr_eq_foldrM]
simp
induction l <;> simp [*]
simp [foldl_eq_foldlM]
simp [foldr_eq_foldrM]
induction l <;> simp [*]
simp
simp [go, mapM]
simp
simp [go l]
simp [← mapM'_eq_mapM]
induction l₁ <;> simp [*]
simp [setTR.go, set, h]
simp [setTR.go, set]
simp [setTR.go, set]
rw [go _ xs]
{simp}
simp [h]
simp
simp
simp [bindTR.go, bind]
simp [bindTR.go, bind, go xs]
funext α l
rw [← List.bind_id, List.bind_eq_bindTR]
rfl
simp [filterMapTR.go, filterMap]
simp [filterMapTR.go, filterMap, go as]
split <;> simp [*]
simp
simp
simp
funext α β f init l
simp [foldrTR, Array.foldr_eq_foldr_data, -Array.size_toArray]
simp [zipWithTR.go, zipWith]
simp [zipWithTR.go, zipWith, go as bs]
funext α β l
simp [unzipTR]
induction l <;> simp [*]
rw [← show _ + as.length = n + (a::as).length from Nat.succ_add .., foldr, go as]
simp
rfl
rw [← replicateTR_loop_replicate_eq _ 1 n, replicate, replicate,
    replicateTR.loop, replicateTR_loop_eq n, replicateTR_loop_eq n, append_assoc]
rfl
funext α l
simp [dropLastTR]
funext α sep l
simp [intersperseTR]
match l with
  | [] | [_] => rfl
  | x::y::xs => simp [intersperse]; induction xs generalizing y <;> simp [*]
simp [intercalateTR.go]
simp [intercalateTR.go, go]
simp
simp
cases n <;> simp [modifyNthTR.go, modifyNth]
simp [modifyNthTR.go, modifyNth]
simp [modifyNthTR.go, modifyNth, modifyNthTR_go_eq l]
funext α f n l
simp [modifyNthTR, modifyNthTR_go_eq]
simp [insertNthTR.go, insertNth]
simp [insertNthTR.go, insertNth, insertNthTR_go_eq n l]
funext α f n l
simp [insertNthTR, insertNthTR_go_eq]
cases l <;> rfl
simp [takeD]
induction n <;> simp [*]
simp [takeDTR.go]
simp [takeDTR.go]
simp [takeDTR.go, takeDTR_go_eq _ l]
funext α f n l
simp [takeDTR, takeDTR_go_eq]
funext α n a l
simp [leftpad, leftpadTR, replicateTR_loop_eq]
simp [scanlTR.go, scanl]
simp [scanlTR.go, scanl, scanlTR_go_eq l]
funext α f n l
simp [scanlTR, scanlTR_go_eq]
funext α l
simp [initsTR]
induction l <;> simp [*]
induction l <;> simp [*, tailsTR.go]
simp only [any, foldr, Bool.or_eq_true] at h
match l, h with
    | [], .inl rfl => simp; induction sections L <;> simp [*]
    | l, .inr h => simp [sections, sections_eq_nil_of_isEmpty h]
funext α L
simp [sectionsTR]
cases e : L.any isEmpty <;> simp [sections_eq_nil_of_isEmpty, *]
clear e
induction L with | nil => rfl | cons l L IH => ?_
simp [IH, sectionsTR.go, Array.foldl_eq_foldl_data]
rw [Array.foldl_data_eq_bind]
rfl
intros
apply Array.foldl_data_eq_map
simp [erasePTR.go, eraseP, h]
simp [erasePTR.go, eraseP]
cases p x <;> simp
· intro h; rw [go _ xs]; {simp}; simp [h]
funext α β l₁ l₂
simp [product, productTR]
rw [Array.foldl_data_eq_bind]
rfl
intros
apply Array.foldl_data_eq_map
funext α β l₁ l₂
simp [List.sigma, sigmaTR]
rw [Array.foldl_data_eq_bind]
rfl
intros
apply Array.foldl_data_eq_map
simp [range'TR.go]
simp [dropSlice, dropSlice_zero₂]
simp [dropSliceTR.go, dropSlice, h]
simp [dropSliceTR.go, dropSlice]
intro h
rw [go _ xs]
{simp}
simp [h]
simp [zipWithLeft'TR.go]
simp [zipWithLeft'TR.go, Array.foldl_data_eq_map]
simp [zipWithLeft'TR.go, go _ as bs]
simp [zipWithLeftTR.go]
simp [zipWithLeftTR.go, Array.foldl_data_eq_map]
simp [zipWithLeftTR.go, go _ as bs]
simp [fillNonesTR.go]
simp [fillNonesTR.go, go _ as as']
simp [fillNonesTR.go, reduceOption, filterMap_eq_filterMapTR.go]
simp [fillNonesTR.go, go _ as as']
simp [takeListTR.go, takeList]
simp [takeListTR.go, takeList, go _ ns]
simp [h]
simp
cases h <;> simp [Membership.mem, *]
constructor
constructor
assumption
simp [·]
cases h <;> intro.
rw [h', cons_append]
cases p <;> simp
simp_all
simp_all
rw [eq_comm, append_eq_nil]
simp [*]
simp [h]
rw [aseq, h]
rw [eq_comm, append_eq_cons]
induction a generalizing c with
  | nil => simp; exact (or_iff_left_of_imp fun ⟨_, ⟨e, rfl⟩, h⟩ => e ▸ h.symm).symm
  | cons a as ih => cases c <;> simp [eq_comm, and_assoc, ih, and_or_left]
induction s <;> simp_all [or_assoc]
simp
simp [mem_map (l := l), or_and_right, exists_or]
simp [mem_map]
exact ⟨fun H j h => H _ _ h rfl, fun H i x h e => e ▸ H _ h⟩
constructor <;> exact fun _ => match l with | [] => rfl
induction l₁ generalizing l₂ <;> cases l₂ <;>
    simp_all [add_one, min_succ_succ, Nat.zero_min, Nat.min_zero]
simp
simp [mem_join, or_and_right, exists_or]
simp [List.bind, mem_map, mem_join]
exact ⟨fun ⟨_, ⟨a, h₁, rfl⟩, h₂⟩ => ⟨a, h₁, h₂⟩, fun ⟨a, h₁, h₂⟩ => ⟨_, ⟨a, h₁, rfl⟩, h₂⟩⟩
simp only [cons_bind, map_append, bind_map _ _ l]
simp
simp
simp only [mem_singleton, forall_eq]
rfl
simp only [mem_append, or_imp, forall_and]
rfl
simp only [mem_cons]
exact Or.imp_right (@s _)
simp only [subset_def, mem_cons, or_imp, forall_and, forall_eq]
rfl
simp [subset_def, or_imp, forall_and]
simp [subset_def]
simp only [mem_map]
exact .imp fun a => .imp_left (@H _)
simp
simp [mem_replicate, Nat.succ_ne_zero]
induction l <;> intros
{contradiction}
rfl
simp [getLast_cons' _ fun H => cons_ne_nil _ _ (append_eq_nil.1 H).2, getLast_append t]
induction h₂ generalizing l₁ with
  | slnil => exact h₁
  | cons _ _ IH => exact (IH h₁).cons _
  | @cons₂ l₂ _ a _ IH =>
    generalize e : a :: l₂ = l₂'
    match e ▸ h₁ with
    | .slnil => apply nil_sublist
    | .cons a' h₁' => cases e; apply (IH h₁').cons
    | .cons₂ a' h₁' => cases e; apply (IH h₁').cons₂
induction l₁ generalizing l with
  | nil => match h with
    | .cons _ h => exact .inl h
    | .cons₂ _ h => exact .inr (.head ..)
  | cons b l₁ IH =>
    match h with
    | .cons _ h => exact (IH h).imp_left (Sublist.cons _)
    | .cons₂ _ h => exact (IH h).imp (Sublist.cons₂ _) (.tail _)
rw [reverse_cons]
exact sublist_append_of_sublist_left h.reverse
rw [reverse_cons, reverse_cons]
exact h.reverse.append_right _
have := h.reverse
simp only [reverse_append, append_sublist_append_left, reverse_sublist] at this
exact this
cases l <;> rfl
cases l <;> rfl
simp [tail_eq_tailD]
cases l <;> rfl
cases l <;> rfl
simp [getLast!]
simp [getLast?]
induction l₁ <;> simp [*]
simp
cases e ▸ get?_eq_some.2 ⟨h', rfl⟩
simp [get?_eq_some, Fin.exists_iff, mem_iff_get]
cases l <;> rfl
unfold getElem?
split
· exact (get?_eq_get ‹_›).symm
· exact (get?_eq_none.2 <| Nat.not_lt.1 ‹_›).symm
induction xs generalizing i j with
  | nil => cases h₀
  | cons x xs ih =>
    match i, j with
    | 0, 0 => rfl
    | i+1, j+1 => simp; cases h₁ with
      | cons ha h₁ => exact ih (Nat.lt_of_succ_lt_succ h₀) h₁ h₂
    | i+1, 0 => ?_ | 0, j+1 => ?_
    all_goals
      simp at h₂
      cases h₁; rename_i h' h
      have := h x ?_ rfl; cases this
      rw [mem_iff_get?]
    exact ⟨_, h₂⟩; exact ⟨_ , h₂.symm⟩
rw [← get?_eq_get, get?_map, get?_eq_get]
rfl
cases h
rfl
simp only [get, cons_append]
apply get_append
rw [cons_append]
simp [get?_append_right (Nat.lt_succ.1 h₁)]
rw [length_append] at h₂
exact Nat.sub_lt_left_of_lt_add h₁ h₂
rw [← get?_eq_get, ← get?_eq_get, get?_append_right h₁]
simp_arith
rw [← get?_eq_get, eq, get?_append_right (h ▸ Nat.le_refl _), h, Nat.sub_self]
rfl
have hn' : n < (l₁ ++ l₂).length := Nat.lt_of_lt_of_le hn <|
    length_append .. ▸ Nat.le_add_right ..
rw [get?_eq_get hn, get?_eq_get hn', get_append]
rw [getLast_singleton, get_singleton]
rw [getLast_cons', getLast_eq_get (b :: l)]
{rfl}
exact cons_ne_nil b l
rw [cons_append, length_cons]
simp only [get?, get?_concat_length]
simp [getLast?_eq_get?]
simp [h]
rw [getLast_eq_get]
cases h
rfl
have h0 : some a = some a' := h 0
injection h0 with aa
simp only [aa, ext fun n => h (n+1)]
simp at h
simp [h, get?_append_right]
have := Nat.succ.inj h
simp at this ⊢
rw [get?_append, get?_reverse' _ j this]
rw [length_reverse, ← this]
apply Nat.lt_add_of_pos_right (Nat.succ_pos _)
rw [Nat.add_sub_of_le (Nat.le_pred_of_lt h),
      Nat.sub_add_cancel (Nat.lt_of_le_of_lt (Nat.zero_le _) h)]
simp [Nat.zero_min]
simp [Nat.min_zero]
simp [Nat.min_succ_succ, add_one, length_take]
simp [Nat.min_le_left]
simp [Nat.min_eq_left h]
have := h
rw [← take_append_drop (length s₁) l] at this ⊢
rw [map_append] at this
refine ⟨_, _, rfl, append_inj this ?_⟩
rw [length_map, length_take, Nat.min_eq_left]
rw [← length_map l f, h, length_append]
apply Nat.le_add_right

-- TODO: original proof: drop_subset n l h
cases l <;> rfl
cases l <;> cases n <;> rfl
cases n <;> rfl
cases l.get? m <;> rfl
induction l₁ <;> simp [*, Nat.succ_add]
cases l <;> rfl
simp only [get?_modifyNth, if_pos]
simp only [get?_modifyNth, if_neg h, id_map']
cases l <;> rfl
cases l <;> rfl
cases l.get? n <;> rfl
rw [modifyNth_eq_set_get?, get?_eq_get h]
rfl
rw [set_eq_modifyNth]
exact exists_of_modifyNth _ h
simp only [set_eq_modifyNth, get?_modifyNth_eq]
rw [get?_set_eq, get?_eq_get h]
rfl
simp only [set_eq_modifyNth, get?_modifyNth_ne _ _ h]
simp [get?_set, get?_eq_get h]
simp [get?_set]
split <;> subst_vars <;> simp [*, get?_eq_get h]
simp
simp [set]
simp [set]
rw [← Option.some_inj, ← get?_eq_get, get?_set_eq, get?_eq_get] <;> simp_all
simp at hj
exact hj
rw [← Option.some_inj, ← List.get?_eq_get, List.get?_set_ne _ _ h, List.get?_eq_get]
simp [removeNth]
have : i < length xs := Nat.lt_of_succ_lt_succ h
simp [removeNth, ← Nat.add_one]
rw [length_removeNth this, Nat.sub_add_cancel (Nat.lt_of_le_of_lt (Nat.zero_le _) this)]
cases l <;> rfl
induction l <;> simp [*]
induction l <;> simp [*]
simp
simp [mem_reverseAux]
rw [← or_assoc, @or_comm (x = a)]
simp [reverse]
simp only [List.insert, if_pos h]
simp only [List.insert, if_neg h]
rw [insert_of_mem h]
rw [insert_of_not_mem h]
rfl
simp [eraseP_cons, h]
simp [eraseP_cons, h]
induction l with
  | nil => rfl
  | cons _ _ ih => simp [h _ (.head ..), ih (forall_mem_cons.1 h).2]
simp [pb]
rw [h₃, cons_append]
simp [pb, h₄]
let ⟨_, l₁, l₂, _, _, e₁, e₂⟩ := exists_of_eraseP al pa
rw [e₂]
simp [length_append, e₁]
rfl
simp [(forall_mem_cons.1 h).1, eraseP_append_right _ (forall_mem_cons.1 h).2]
match exists_or_eq_self_of_eraseP p l with
  | .inl h => rw [h]; apply Sublist.refl
  | .inr ⟨c, l₁, l₂, _, _, h₃, h₄⟩ => rw [h₄, h₃]; simp
refine ⟨mem_of_mem_eraseP, fun al => ?_⟩
match exists_or_eq_self_of_eraseP p l with
  | .inl h => rw [h]; assumption
  | .inr ⟨c, l₁, l₂, h₁, h₂, h₃, h₄⟩ =>
    rw [h₄]; rw [h₃] at al
    have : a ≠ c := fun h => (h ▸ pa).elim h₂
    simp [this] at al; simp [al]
simp [extractP.go, find?, eraseP, h]
simp [extractP.go, find?, eraseP]
cases p x <;> simp
· intro h; rw [go _ xs]; {simp}; simp [h]
simp [List.erase, h]
simp [List.erase, h, (beq_eq_false_iff_ne _ _).2 h]
simp [erase_cons]
simp only [erase_cons, if_neg h]
rw [mem_cons, not_or] at h
rw [erase_cons, if_neg (Ne.symm h.1), erase_of_not_mem h.2]
let ⟨_, l₁, l₂, h₁, e, h₂, h₃⟩ := exists_of_eraseP h (beq_self_eq_true _)
rw [erase_eq_eraseP]
exact ⟨l₁, l₂, fun h => h₁ _ h (beq_self_eq_true _), eq_of_beq e ▸ h₂, h₃⟩
rw [erase_eq_eraseP]
exact length_eraseP_of_mem h (decide_eq_true rfl)
exact decide_eq_true rfl
rw [erase_eq_eraseP, erase_eq_eraseP, eraseP_append_right]
intros b h' h''
rw [of_decide_eq_true h''] at h
exact h h'
simp only [erase_eq_eraseP]
exact h.eraseP
induction as with
  | nil => simp [filter]
  | cons a as ih =>
    unfold filter; split <;> simp only [*, mem_cons, or_and_right]
    · exact or_congr_left (and_iff_left_of_imp fun | rfl => ‹_›).symm
    · exact (or_iff_right fun ⟨rfl, h⟩ => (Bool.not_eq_true _).mpr ‹_› h).symm
simp [partition, aux]
simp [partition.loop, filter]
cases pa : p a <;> simp [partition.loop, pa, aux, filter, append_assoc]
induction l <;> simp [forall_mem_map_iff, *]
induction l₁ <;> simp [*, or_imp, forall_and, and_assoc, and_left_comm]
induction l <;> simp [*, pairwise_append, and_comm]
induction l <;> simp
split <;> simp [*]
simp [Disjoint]
rw [disjoint_comm]
exact disjoint_nil_left _
simp [Disjoint]
rw [disjoint_comm, singleton_disjoint]
simp [Disjoint, or_imp, forall_and]
rw [disjoint_append_left]
simp [disjoint_comm]
simp [singleton_disjoint]
rw [disjoint_cons_left]
simp [disjoint_comm]
simp
cases m <;> cases n <;> simp only [disjoint_cons_left, mem_cons, disjoint_cons_right,
      drop, true_or, eq_self_iff_true, not_true, false_and, not_mem_nil, disjoint_nil_left, take]
· case succ.zero => cases h
· cases hl with | cons h₀ h₁ =>
      refine ⟨fun h => h₀ _ (mem_of_mem_drop h) rfl, ?_⟩
      exact disjoint_take_drop h₁ (Nat.le_of_succ_le_succ h)
induction l generalizing init <;> simp [*]
induction l generalizing init <;> simp [*]
induction l generalizing init <;> simp [*, H]
induction l <;> simp [*, H]
simp [List.union, foldr]
simp [List.union, foldr]
induction l₁ <;> simp [*, or_assoc]
cases l₁ <;> simp [List.inter, mem_filter]
simp only [List.product, and_imp, exists_prop, List.mem_map, Prod.mk.injEq,
    exists_eq_right_right', List.mem_bind, iff_self]
simp only [leftpad, length_append, length_replicate, Nat.sub_add_eq_max]
simp only [isPrefix, leftpad]
exact Exists.intro l rfl
simp only [isSuffix, leftpad]
exact Exists.intro (replicate (n - length l) a) rfl
simp
simp
cases x
{contradiction}
rw [getD_some]
rw [e] at h
(cases h)
simp
exact h
cases x <;> simp [isSome]
cases a <;> simp
cases o <;> simp
intro.
cases o <;> simp
cases o <;> simp
cases o <;> simp
have := h <| x.get <| ne_none_iff_isSome.1 hx
simp [some_get] at this ⊢
exact this
cases x <;> rfl
cases x <;> simp
simp only [eq_none_iff_forall_not_mem, not_exists, not_and, mem_def, bind_eq_some]
rfl
cases a <;> cases b <;> rfl
cases x <;> rfl
simp
simp only [ne_none_iff_exists', join_eq_some, iff_self]
simp
cases x <;> simp
cases x <;> simp only [map_none', map_some', eq_self_iff_true]
cases x <;> simp only [map_none', map_some', h, mem_def]
cases x <;> simp only [map_none', map_some', ·∘·]
funext x
simp
cases x <;> simp
cases x <;> simp
cases x <;> simp
cases x <;> rfl
have := h a b
simp [liftOrGet] at this ⊢
exact this
cases b <;> rfl
cases a <;> rfl
cases o <;> rfl
simp [choice]
rw [dif_pos (⟨a⟩ : Nonempty α)]
simp
apply Subsingleton.elim
simp only [choice, dif_pos h, isSome_some]
simp
simp
simp [singleton_inter_eq_empty]

-- example {f : β → α} {x y : α} (h : x ≠ y) : f ⁻¹' {x} ∩ f ⁻¹' {y} = ∅ :=
-- begin
--   have : {x} ∩ {y} = (∅ : set α) :=
decide
decide
decide
decide
-- [todo] should it still be using dummy?
decide
decide
decide
decide
decide

/- test the eta-expansion applied on `foo6`. -/
simp
simp
trivial
infer_instance
intro.
intro.
trivial
simp [frobnicate_def]
rw [withUniv_def]
rfl
rfl
refine' { ‹OrderedRing R› with .. } <;> sorry
trace "hello"
intros
intros
intros
intros
constructor
fail_if_success any_goals assumption
all_goals constructor
any_goals assumption
constructor
any_goals assumption
constructor
· exact [0,1]

-- example : (α : Type) × List α :=
fail_if_success have := ∀ p, decide p -- no classical in scope
exact decide (0 < 1) -- uses the decidable instance
  
-- check that classical respects tactic blocks
decide
cases h
assumption

-- This lemma with `false` as its head symbols should also be found for goals with head symbol `¬`.
apply Nat.not_lt_zero
cases h2
assumption
simp
rw [foo.rfl_toFun, id]
rw [foo.rfl_invFun]

/- the declarations are `simp` lemmas -/
simp
rw [foo_fst, h]
simp
rw [h]
simp
rw [h]
dsimp
rw [h] -- check that dsimp also unfolds
dsimp
rw [h]
simp
rw [h]
simp
rw [h]
-- example {α} (x y : α) (h : x = y) : foo.rfl.toFun = @id α :=
dsimp
rw [h]

/- check simpRhs option -/
intro x
simp [Equiv'.left_inv _ _]
intro x
simp [Equiv'.right_inv _ _]
dsimp only [Equiv'.trans_toFun]
rw [h]
intro n
simp
intro n
simp
simp only [myNatEquiv_toFun, myNatEquiv_invFun]
intro n
rfl
intro n
rfl
simp
rw [h]
simp only [foo_c]
rw [h]
simp only [foo_x]
rw [h]
simp only [voo_c]
rw [h]
simp only [voo_x]
rw [h]
rw [coercing.rfl2_toFun, h]
simp
rw [h]
simp
rw [h]
simp
rw [h]
simp
rw [h]

-- example {α β} (f : Equiv2 α β) {x} (h : f = x) : f.symm.invFun = x :=
--
rfl
simp
rw [h]
simp
-- example {α β} [Semigroup α] [Semigroup β] (x y : α × β) : (x * y).1 = x.1 * y.1 :=
simp
simp
simp
simp only [Equiv.trans_invFun]
rw [h]
simp only [Equiv.trans_invFun]
rw [h]
simp only [Equiv.trans_apply]
rw [h]
simp only [Equiv.trans_symm_apply]
rw [h]

-- the new projection names are parsed correctly (the old projection names won't work anymore)
simp only [Equiv.coe_trans]
rw [h]

-- the new projection names are parsed correctly
simp only [coe_foo_snd_fst]
rw [h]
dsimp only [Nat.SetPlus1_s]
rw [h]
dsimp only [Nat.SetPlus2_s]
  -- successIfFail { rw [h] } -- todo
exact h
dsimp only [Nat.SetPlus3_s]
rw [h]
dsimp only [Equiv.symm2_invFun_toFun]
rw [h]

/- do not prematurely unfold `Equiv.symm`, unless necessary -/
simp only [myAlgHom_toFun]
rw [h]
simp only [myRingHom_toFun]
rw [h]

/- check interaction with the `@[to_additive]` attribute -/
simp
-- example {M N} [Add M] [Add N] (p q : M × N) : p + q = ⟨p.1 + q.1, p.2 + q.2⟩ :=
simp

/- The names of the generated simp lemmas for the additive version are not great if the definition
  had a custom additive name -/
simp
-- example {M N} [Zero M] [Zero N] : (0 : M × N) = ⟨0, 0⟩ :=
simp
simp
simp
dsimp
simp only [thing_mul]
rw [h2]
cases a <;> rfl
assumption
intro h₁ h₂
apply Eq.trans h₁ h₂
have h : Int := 0
assumption -- original `h` is not absent but...
have : Nat := 0
have : Int := 0
assumption -- original `this` is not absent but...
assumption -- old `a` is not gone
exact a    -- new `a` is of type `Int`
  simp

-- tests without `:=`, creating a new subgoal
simp_arith
congr
congr
congr

-- FIXME(?): congr doesn't fail
-- example {α} (a b : α) (h : False) : a = b :=
rfl
rfl
(fail_if_success rfl)
apply Nat.le_refl
rfl
apply Foo.le_refl
rfl
refine' { inferInstanceAs (LinearOrderedRing α) with .. } <;> sorry
refine' { lt := (·<·), le := (·≤·), .. } <;> sorry
refine' { inferInstanceAs (CommSemiring ℕ), inferInstanceAs (LinearOrder ℕ) with .. } <;> sorry
refine' { inferInstanceAs (CommRing ℤ), inferInstanceAs (LinearOrder ℤ) with .. } <;> sorry
refine' { zero := 0, one := 1, add := (·+·), mul := (·*·), .. } <;> sorry
refine' { inferInstanceAs (CommRing ℚ), inferInstanceAs (LinearOrder ℚ) with .. } <;> sorry
congr
exact he b hb
rw [Nat.add_comm]
exact Nat.zero_lt_succ _
congr
rw [h x, h y]
constructor <;> exact inferInstance
rw [Subsingleton.elim i default]
rfl
rw [Function.bijective_iff_has_inverse]
refine' ⟨default, _, _⟩ <;> intro x <;> simp
congr
subst hx
congr
simp only [_root_.nontrivial_iff_exists_ne x, Subtype.exists, Ne.def, Subtype.ext_iff, iff_self]
intro h
exact Subsingleton.elim
simp only [nontrivial_iff, subsingleton_iff, not_exists, Ne.def, _root_.not_not, iff_self]
rw [← not_nontrivial_iff_subsingleton, or_comm]
exact Classical.em _
refine fun H ↦ h ?_
rw [← hx', ← hy', H]
cases e₁
cases e₂
congr
cases h
rfl
cases h
rfl
rw [Perm.subsingleton_eq_refl e, coe_refl]

-- porting note: marking this as `@[simp]` because `simp` doesn't fire on `coe_refl`
-- in an expression such as `Equiv.refl a x`
subst h
simp [coe_refl]
simp [H.symm]
simp [H]
cases e
rfl
cases e
rfl
cases e
rfl
simp
simp
simp [permCongr_def]
simp only [comp_apply, symm_apply_apply]
simp only [comp_apply, apply_symm_apply]
apply arrowCongr_comp
simp [@Bool.decide_iff p (Classical.propDecidable _)]
cases b <;> simp
rw [Subsingleton.elim b a]
rfl
simp
constructor <;> intro h₂ x
. rw [← f.right_inv x]; apply h.mp; apply h₂
· apply h.mpr; apply h₂
simp
simp only [e.symm_apply_apply]
rfl
infer_instance
simp only [← not_nonempty_iff, nonempty_Prop, iff_self]
simp only [← not_nonempty_iff, Classical.nonempty_pi, not_forall, iff_self]
simp only [← not_nonempty_iff, nonempty_sigma, not_exists, iff_self]
simp only [← not_nonempty_iff, nonempty_psigma, not_exists, iff_self]
simp only [← not_nonempty_iff, nonempty_subtype, not_exists, iff_self]
simp only [← not_nonempty_iff, nonempty_prod, not_and_or, iff_self]
simp only [← not_nonempty_iff, nonempty_pprod, not_and_or, iff_self]
simp only [← not_nonempty_iff, nonempty_sum, not_or, iff_self]
simp only [← not_nonempty_iff, nonempty_psum, not_or, iff_self]
simp only [← not_nonempty_iff, nonempty_ulift, iff_self]
simp only [← not_nonempty_iff, nonempty_plift, iff_self]
rw [iterate_succ, ihn, comp.left_id]
rw [Nat.add_succ, iterate_succ, iterate_succ, iterate_add m n]
rfl
rw [iterate_add f m n]
rfl
simp only [Nat.mul_zero, iterate_zero]
simp only [Nat.mul_succ, Nat.mul_one, iterate_one, iterate_add, iterate_mul m n]
rw [iterate_succ_apply, h, ihn]
simp only [iterate_succ_apply, hx, (h.iterate_left n).eq, ihn, ((refl g).iterate_right n).eq]
rw [iterate_succ, (Commute.self_iterate f n).comp_eq]
rw [iterate_succ']
rfl
rw [← iterate_succ, Nat.succ_pred_eq_of_pos hn]
rw [← iterate_succ', Nat.succ_pred_eq_of_pos hn]
rw [iterate_succ']
exact h _
rw [iterate_succ', iterate_succ]
exact ihn.comp hg
rw [Nat.mul_comm]
rw [length_cons, foldr, foldr_const f b l, iterate_succ_apply']
simp only [comp_apply, h.eq, h'.eq]
simp only [comp_apply, hab.eq, hbc.eq]
rw [← hb (f (ga' x)), ← h.eq, ha x]
simp only [hf'.eq, hf.eq, comp_apply]
simp only [← h.eq, @IsAssociative.assoc _ ga]
simp only [h.eq, @IsAssociative.assoc _ gb]
simp only [← h.eq, @IsIdempotent.idempotent _ ga]
rw [h.eq, @IsIdempotent.idempotent _ gb]
funext a
                      exact type_eq_of_heq (this a)
  subst this
  apply heq_of_eq
  funext a
  exact eq_of_heq (this a)
intros x₁ x₂ h
   dsimp only
specialize h (fun y ↦ ∃ x, f x = y) (fun _ ↦ True) (funext fun x ↦ eq_true ⟨_, rfl⟩)
intro y
rw [congr_fun h y]
trivial
simp only [cast_cast, cast_eq] at this
assumption
rw [hf (i a), hh a]
rw [h₂.comp_eq_id, comp.right_id]
rw [← comp.assoc, h₁.comp_eq_id, comp.left_id]
rw [hpi, dif_pos h'] at h
rw [hpi, dif_neg h'] at h
contradiction
simp only [invFun, dif_pos h, h.choose_spec]
rw [hg b]
exact invFun_eq ⟨g b, hg b⟩
intro h
        rw [eq_rec_constant]
rw [← and_forall_ne a, update_same]
simp (config := { contextual := true })
rw [← not_forall_not, forall_update_iff f fun a b ↦ ¬p a b]
simp [-not_and, not_and_or]
simp [update_eq_iff]
simp [eq_update_iff]
funext c
simp only [update]
funext b
unfold extend
congr
simp only [extend_def, dif_pos, exists_apply_eq_apply]
exact congr_arg g (hf $ Classical.choose_spec (exists_apply_eq_apply f a))
simp [Function.extend_def, hb]
intro g₁ g₂ hg
refine' funext fun x ↦ _
have H := congr_fun hg (f x)
simp only [hf, extend_apply] at H
exact H
simp only [comp.assoc g _ f, (leftInverse_surjInv hf).comp_eq_id, comp.right_id]
rw [apply_ite f, h, ite_not]
cases h
refine ⟨fun _ _ ↦ id, fun x ↦ ⟨x, rfl⟩⟩
cases h
refine ⟨fun _ _ ↦ id, fun x ↦ ⟨x, rfl⟩⟩
cases h
refine ⟨fun _ _ ↦ id, fun x ↦ ⟨x, rfl⟩⟩
rw [h]
rw [cast_eq_iff_heq, h]
cases Subsingleton.elim x y
rfl
cases h₂
cases h₁
rfl
congr
rw [h]
congr
rw [h]
rw [← h]
rw [h]
rw [h]
rw [h]
funext _
simp only [true_iff, id.def, eq_iff_iff]
simp [Xor']
simp [Xor', and_comm, or_comm]
simp [Xor']
simp [eq_comm]
simp [eq_comm]
simp only [not_and, Xor', not_or, not_not, ← iff_iff_implies_and_implies, iff_self]
rw [iff_not_comm, not_xor]
cases h
rfl
subst e
exact h
subst h₁
subst h₂
rfl
rw [h]
rw [h]
simp only [not_exists, Decidable.not_not, iff_self]
let ⟨a⟩ := ha
refine ⟨fun h ↦ not_forall_not.1 fun h' ↦ ?_, fun ⟨x, hx⟩ h ↦ hx (h x)⟩
exact if hb : b then h' a fun _ ↦ hb else hb <| h fun x ↦ (not_imp.1 (h' x)).1
simp
simp
simp
simp only [← @forall_eq _ p a, ← forall_and, ← or_imp, Classical.em, forall_const, iff_self]
simp only [eq_comm, ExistsUnique, and_self, forall_eq', exists_eq']
simp only [ExistsUnique, and_self, forall_eq', exists_eq']

-- @[simp] -- FIXME simp does not apply this lemma for some reason
simp
simp [forall_swap]
simp
simp [forall_swap]
simp [@eq_comm _ a']
simp only [@exists_comm (κ₁ _), @exists_comm ι₁, iff_self]
simp [or_comm, Decidable.forall_or_left]
simp
simp only [exists_unique_iff_exists] at h₂
apply h₂.elim
exact fun x ⟨hxp, hxq⟩ H ↦ h₁ x hxp hxq fun y hyp hyq ↦ H y ⟨hyp, hyq⟩
simp only [exists_unique_iff_exists]
exact ExistsUnique.intro w ⟨hp, hq⟩ fun y ⟨hyp, hyq⟩ ↦ H y hyp hyq
simp only [exists_unique_iff_exists] at h
exact h.unique ⟨hpy₁, hqy₁⟩ ⟨hpy₂, hqy₂⟩
infer_instance
infer_instance
infer_instance
infer_instance
simp only [exists_prop, exists_eq_left]
rfl
simp
simp only [exists_prop]
exact Iff.trans (exists_congr fun x ↦ or_and_right) exists_or
simp only
rw [exists_prop, exists_prop]
rw [ne_comm]
simp only [Ne.def, dite_eq_right_iff, not_forall]
rfl
simp only
rw [exists_prop]
simp only
rw [exists_prop]
rw [dif_neg (h p), dif_pos p]
congr
funext _
rw [dif_neg np]
funext a b
exact iff_eq_eq
  rw [this, eq_comp]
funext a b
exact iff_eq_eq
  rw [this, comp_eq]
funext a d
apply propext
constructor
exact fun ⟨c, ⟨b, hab, hbc⟩, hcd⟩ ↦ ⟨b, hab, c, hbc, hcd⟩
exact fun ⟨b, hab, c, hbc, hcd⟩ ↦ ⟨c, ⟨b, hab, hbc⟩, hcd⟩
funext c a
apply propext
constructor
exact fun ⟨b, hab, hbc⟩ ↦ ⟨b, hbc, hab⟩
exact fun ⟨b, hbc, hab⟩ ↦ ⟨b, hab, hbc⟩
rfl
rfl
induction hbc
case refl => assumption
case tail c d _ hcd hac => exact hac.tail hcd
induction hbc
case refl => exact refl.tail hab
case tail c d _ hcd hac => exact hac.tail hcd
induction h
case refl => exact refl
case tail b c _ hbc ih =>
  -- Porting note: Lean 3 figured out the motive and `apply ih` worked
  refine @ih (λ {a : α} (hab : ReflTransGen r a b) => P a (ReflTransGen.tail hab hbc)) ?_ ?_
  { exact head hbc _ refl }
  { exact fun h1 h2 ↦ head h1 (h2.tail hbc) }
induction h
case refl => exact ih₁ a
case tail b c hab hbc ih => exact ih₃ hab (single hbc) ih (ih₂ hbc)
assumption
assumption
induction hbc
case refl => assumption
case tail c d _ hcd hac => exact hac.tail hcd
induction hab generalizing c
case refl => exact single hbc
case tail _ _ _ hdb IH => exact tail (IH hdb) hbc
induction h
case single a h => exact base h
case tail b c _ hbc h_ih =>
  -- Lean 3 could figure out the motive and `apply h_ih` worked
  refine @h_ih (λ {a : α} (hab : @TransGen α r a b) => P a (TransGen.tail hab hbc)) ?_ ?_;
  exact fun h ↦ ih h (single hbc) (base hbc)
  exact fun hab hbc ↦ ih hab _
induction h with
  | single h => exact base h
  | tail hab hbc h_ih => exact ih hab (single hbc) h_ih (base hbc)
induction hbc
case single c hbc => exact tail' hab hbc
case tail c d _ hcd hac => exact hac.tail hcd
rfl
rfl
induction h
case single _ hc => exact hc
case tail c d _ hcd hac => exact trans hac hcd
induction hab
case single c hac => exact TransGen.single (h a c hac)
case tail c d _ hcd hac => exact TransGen.tail hac (h c d hcd)
rw [cases_head_iff]
simp [h, eq_comm]
intro h
induction h
case rel => assumption
case refl => exact h.1 _
case symm => apply h.symm; assumption
case trans _ hab hbc => exact h.trans hab hbc
induction h
case rel a b h => exact EqvGen.rel _ _ (hrp _ _ h)
case refl => exact EqvGen.refl _
case symm a b _ ih => exact EqvGen.symm _ _ ih
case trans a b c _ _ hab hbc => exact EqvGen.trans _ _ _ hab hbc
simp
simp
match h with | .isTrue _ => rfl
match h with | .isFalse _ => rfl
have := if_pos hc ▸ h
exact this
have := if_neg hnc ▸ h
exact this
cases h
rfl
exact h _ ▸ rfl
simp [h₁, h₂]
apply eq_min
   . apply le_trans
apply min_le_left
apply min_le_left
   . apply le_min
apply le_trans
apply min_le_left
apply min_le_right
apply min_le_right
   . intros d h₁ h₂
apply le_min
apply le_min h₁
apply le_trans h₂
apply min_le_left
apply le_trans h₂
apply min_le_right
simp [min_def]
apply Eq.symm
apply eq_min (le_refl _) h
intros
assumption
rw [min_comm]
apply eq_max
· apply le_trans; apply le_max_left a b; apply le_max_left
· apply max_le; apply le_trans; apply le_max_right a b; apply le_max_left; apply le_max_right
· intros d h₁ h₂; apply max_le; apply max_le h₁; apply le_trans (le_max_left _ _) h₂;
    apply le_trans (le_max_right _ _) h₂
simp [max_def]
apply Eq.symm
apply eq_max (le_refl _) h
intros
assumption
rw [←max_comm b a]
exact max_eq_left h

/- these rely on lt_of_lt -/
rw [hab]
exact ⟨irrefl_of lt b, irrefl_of lt b⟩
intros
rfl
intros
rfl
intros
rfl
rw [← hx, rfg]
rw [Nat.add_right_comm]
exact kn
rw [e]
exact pm
      IH _ ⟨rfl, this⟩ fun n h ↦ this n $ Nat.le_of_succ_le_succ h
simp
simp only [Nat.pow_succ]
exact (@Nat.div_lt_iff_lt_mul b n (b ^ e) h_b_pos).mpr
decide
simp only [pow_succ, pow_zero, Nat.one_mul]
decide
infer_instance
infer_instance
infer_instance
cases h
rfl
cases b <;> rfl
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
cases b <;> simp
decide
decide
simp
simp
simp
simp
cases a <;> simp
cases a <;> cases b <;> simp
cases a <;> cases b <;> simp
cases a <;> simp
simp
simp
simp
simp
simp
decide
cases h' : decide q with
  | false => exact decide_false (mt h.1 <| of_decide_false h')
  | true => exact decide_true (h.2 <| of_decide_true h')
simp
simp
decide
rw [← cast_zero, cast_inj]
rw [← cast_one, cast_inj]
cases x
  mul_assoc x y z
cases x
simp [right_distrib]
rw [add_mul, one_mul]
rw [mul_add, mul_one]
rw [add_mul, one_mul]
rw [mul_add, mul_one]
rw [one_mul]
rw [mul_one]
simp
simp
simp only [← ite_and, ite_mul, mul_ite, mul_zero, zero_mul, and_comm]
simp only [two_mul, add_mul, mul_add, add_assoc, mul_comm b]
simp
simp
simp
simp
simp
rw [← zero_mul (0 : α), ← neg_mul, mul_zero, mul_zero]
rw [← right_distrib, add_left_neg, zero_mul]
rw [← left_distrib, add_left_neg, mul_zero]
simp [add_comm]
rw [h]
simp
rw [← h]
simp
simp [sub_mul, sub_add_eq_add_sub]
simp [sub_mul, sub_add_eq_add_sub]
rw [h]
simp [@add_sub_cancel α]
rw [sub_mul, one_mul]
rw [mul_sub, mul_one]
rw [sub_mul, one_mul]
rw [mul_sub, mul_one]
rw [← add_mul, zero_add, add_zero]
rw [← mul_add, add_zero, add_zero]
rw [← add_mul, zero_add, add_zero]
rw [← mul_add, add_zero, add_zero]
simp only [Commute, SemiconjBy, left_distrib, right_distrib, h.eq, h'.eq]
simp only [Commute, SemiconjBy, left_distrib, right_distrib, h.eq, h'.eq]
induction n generalizing m <;> simp_all [mul_succ, mul_add]
induction n generalizing m <;> simp_all [Nat.pow_succ', _root_.pow_succ'', pow_zero]
induction n with
  | zero => rw [Nat.cast_zero]; exact Commute.zero_left x
  | succ n ihn => rw [Nat.cast_succ]; exact ihn.add_left (Commute.one_left x)
simp [Nat.pow_succ, Nat.mul_comm]
simp [Nat.add_comm, (Nat.succ_mul n x)]
rw [Int.mul_comm]
rfl
show ofNat (Nat.succ n) * x = x + ofNat n * x
rw [Int.ofNat_succ, Int.add_mul, Int.add_comm, Int.one_mul]
cases this
rfl
intros
rfl
intros
rfl
intros
rfl
intros
rfl

-- FIXME I wouldn't have thought this is necessary. Is is a bug in `to_additive`?
-- It seems that it isn't operating on the second parent.
rw [← one_mul c, ← hba, mul_assoc, hac, mul_one b]
rw [mul_comm, h, mul_comm]
intros
rfl
intros
rfl
intros
rfl
intros
rfl
intros
rfl
intros
rfl
intros
rfl
intros
rfl
rw [← zpow_ofNat]
exact DivInvMonoid.zpow_neg' n a
rw [← mul_assoc, mul_left_inv, one_mul]
rw [← mul_assoc, mul_right_inv, one_mul]
rw [mul_assoc, mul_right_inv, mul_one]
rw [mul_assoc, mul_left_inv, mul_one]
rw [mul_assoc, mul_inv_cancel_left, mul_right_inv]
rw [← mul_inv_cancel_right a b, h, mul_inv_cancel_right]
rw [← inv_mul_cancel_left a b, h, inv_mul_cancel_left]
unfold SemiconjBy
  -- TODO this could be done using `assoc_rw` if/when this is ported to mathlib4
rw [←mul_assoc, h.eq, mul_assoc, h'.eq, ←mul_assoc]
unfold SemiconjBy
rw [mul_assoc, hb.eq, ←mul_assoc, ha.eq, mul_assoc]
rw [SemiconjBy, mul_one, one_mul]
simp only [mul_assoc, h.eq]
simp only [← mul_assoc, h.eq]
simp only [mul_left_comm, mul_assoc]
simp only [mul_left_comm, mul_comm]
simp only [mul_left_comm, mul_comm]
rw [mul_one]
rw [one_mul]
simp [h]
rw [div_eq_mul_inv, one_mul]
rw [div_eq_mul_inv, one_mul, div_eq_mul_inv]
rw [div_eq_mul_inv, div_eq_mul_inv, mul_assoc _ _ _]
simp only [mul_assoc, div_eq_mul_inv]
rw [div_eq_mul_inv, one_div]
simp [div_eq_mul_inv]
rw [← inv_eq_of_mul_eq_one_right h, inv_inv]
rw [eq_inv_of_mul_eq_one_left h, one_div]
rw [eq_inv_of_mul_eq_one_right h, one_div]
simp
simp
simp
simp
simp
rw [← one_div_one_div a, h, one_div_one_div]
simp
simp
simp only [mul_assoc, mul_inv_rev, div_eq_mul_inv]
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
simp
rw [div_eq_mul_inv, mul_left_eq_self]
simp [h.symm]
simp [h.symm]
simp [h]
simp [h]
simp [h.symm]
simp [h.symm, mul_inv_cancel_left]
rw [h, mul_inv_cancel_left]
simp [h]
rw [h, mul_left_inv]
rw [mul_eq_one_iff_eq_inv, eq_inv_iff_eq_inv, eq_comm]
rw [h, inv_mul_cancel_right]
rw [← h, mul_inv_cancel_right]
rw [h, mul_inv_cancel_left]
rw [← h, inv_mul_cancel_left]
rw [← h, mul_inv_cancel_left]
rw [h, inv_mul_cancel_left]
rw [← h, inv_mul_cancel_right]
rw [h, mul_inv_cancel_right]
rw [mul_eq_one_iff_eq_inv, inv_inv]
rw [mul_eq_one_iff_eq_inv, inv_inj]
simp only [div_eq_mul_inv]
exact fun a a' h ↦ inv_injective (mul_right_injective b h)
rw [div_eq_mul_inv, inv_mul_cancel_right a b]
rw [div_eq_mul_inv, mul_right_inv a]
rw [div_eq_mul_inv, mul_inv_cancel_right a b]
rw [div_mul_eq_div_div_swap]
simp only [mul_left_inj, eq_self_iff_true, mul_div_cancel'']
simp [← h]
simp [h]
simp [← h]
simp [h]
rw [div_eq_mul_inv, div_eq_mul_inv]
exact mul_left_inj _
rw [← mul_div_assoc, div_mul_cancel']
rw [← inv_div c b, div_inv_eq_mul, div_mul_div_cancel']
rw [h, div_self']
rw [div_eq_mul_inv, mul_right_eq_self, inv_eq_one]
rw [div_eq_mul_inv, eq_mul_inv_iff_mul_eq]
rw [div_eq_mul_inv, mul_inv_eq_iff_eq_mul]
rw [← div_eq_one, H, div_eq_one]
rw [h, div_eq_mul_inv, mul_comm, inv_mul_cancel_left]
simp [h.symm]
simp [h.symm]
simp [h]
rw [mul_comm c, mul_inv_cancel_left]
simp [mul_left_comm c]
simp
rw [eq_div_iff_mul_eq', mul_comm]
rw [div_eq_iff_eq_mul, mul_comm]
rw [div_eq_inv_mul, inv_mul_cancel_left]
rw [← mul_div_assoc, mul_div_cancel''']
rw [← inv_div, mul_div_cancel''']

-- This lemma is in the `simp` set under the name `mul_inv_cancel_comm_assoc`,
-- along with the additive version `add_neg_cancel_comm_assoc`,
-- defined  in `algebra/group/commute`
rw [← div_eq_mul_inv, mul_div_cancel'_right a b]
rw [mul_assoc, mul_div_cancel'_right]
rw [mul_left_comm, div_mul_cancel', mul_comm]
rw [mul_comm]
apply div_mul_div_cancel'
rw [← div_mul, mul_div_cancel''']
rw [← inv_div b c, div_inv_eq_mul, mul_comm, div_mul_div_cancel']
rw [div_eq_iff_eq_mul, div_mul_eq_mul_div, eq_comm, div_eq_iff_eq_mul']
simp only [mul_comm, eq_comm]
rfl
rw [div_eq_iff_eq_mul, div_mul_eq_mul_div, div_eq_iff_eq_mul', mul_div_assoc]
refine ⟨fun h a b c bc ↦ ?_, fun h a b c bc ↦ ?_⟩
· rw [← inv_mul_cancel_left a b, ← inv_mul_cancel_left a c]
    exact h a
refine ⟨fun h a b c bc ↦ ?_, fun h a b c bc ↦ ?_⟩
· rw [← mul_inv_cancel_right b a, ← mul_inv_cancel_right c a]
    exact h a
rw [flip_mul]
rw [flip_mul]
simp [neZero_iff]
rw [succ_nsmul, zero_nsmul, add_zero]
induction m with
  | zero => rw [Nat.zero_add, zero_nsmul, zero_add]
  | succ m ih => rw [Nat.succ_add, Nat.succ_eq_add_one, succ_nsmul, ih, succ_nsmul, add_assoc]
rw [add_nsmul, one_nsmul]
rw [pow_succ, pow_zero, mul_one]
rw [pow_zero, pow_zero, Int.cast_one]
rw [pow_succ, pow_succ, Int.cast_mul, Int.cast_pow _ n]
rw [nsmul_eq_mul', (n.cast_commute a).eq]
rw [← mul_lt_mul_iff_left a, mul_inv_self, mul_one]
rw [← mul_lt_mul_iff_right b, one_mul, div_eq_mul_inv, inv_mul_cancel_right]
rw [mul_one]
rw [one_mul]
rw [mul_one]
rw [one_mul]
rw [mul_one]
rw [one_mul]
rw [mul_one]
rw [one_mul]
rw [ha', hb', mul_one]
rw [mul_comm b, mul_comm c, ha.mul_le_mul_iff_left]
rw [mul_one]
rw [mul_one]
rw [mul_comm, ha.le_mul_iff_one_le_right]
rw [mul_comm, ha.mul_le_iff_le_one_right]
apply c.next_eq _ h
rw [next]
rw [dif_pos]
exact Exists.choose_spec ⟨j, h⟩
apply c.prev_eq _ h
rw [prev, dif_pos]
exact Exists.choose_spec (⟨i, h⟩ : ∃ k, c.Rel k j)
rw [← sub_eq_add_neg, h, add_neg_self]

-- Porting note:
-- This theorem was introduced during ad-hoc porting
-- and hopefully can be removed again after `Mathlib.Algebra.Ring.Basic` is fully ported.
rw [one_mul]
rw [h, zero_mul]
rw [h, zero_mul]
rw [one_mul]
rw [zero, one]
exact zero_ne_one
rw [eq_comm, mul_eq_zero]
simp
simp
rfl
rfl
simp [EquivFunctor.mapEquiv]
rfl
simp [mapEquiv, map_trans']
simp [h.symm, term, add_comm, add_assoc]
simp [h.symm, termg, add_comm, add_assoc]
simp [h.symm, term, add_assoc]
simp [h.symm, termg, add_assoc]
simp [h₁.symm, h₂.symm, term, add_nsmul, add_assoc, add_left_comm]
simp [term, zero_nsmul, one_nsmul]
sorry
simp [h₂.symm, h₁.symm, termg]
sorry
simp [smul, nsmul_zero]
sorry
sorry
sorry
simp [term]
simp [termg]
sorry
rw [sub_eq_add_neg, h]
simp [prl, prr, prt]
simp [prl, prr, prt]
simp [← prt, prl₁, ← prl₂, prr, smul, smulg, coe_nat_zsmul]
rw [prl, prr, prt]
rw [prl, prr, prt]
simp [pra, prt]
cases h with
  | inl hp => exact Or.inr hp
  | inr hq => exact Or.inl hq
simp [frobnicate_def]
intros
simp only [$n:ident]
rw [wrapped.prop]
subst_vars
simp [mul_add]
simp [h, ← mul_add]
simp
simp
subst_vars
simp [add_assoc, add_left_comm]
subst_vars
rw [add_add_add_comm, h.1, Nat.cast_zero, add_pf_zero_add]
simp [*, add_assoc]
subst_vars
simp [add_left_comm]
simp [Nat.rawCast]
simp [Nat.rawCast]
subst_vars
rw [mul_assoc]
subst_vars
rw [mul_left_comm]
subst_vars
simp [pow_add, mul_mul_mul_comm]
simp
subst_vars
simp [_root_.mul_add]
simp
subst_vars
simp [_root_.add_mul]
simp
subst_vars
simp
subst_vars
simp
subst_vars
simp
subst_vars
simp
subst_vars
simp [Int.negOfNat]
subst_vars
simp
simp
subst_vars
simp [add_comm]
subst_vars
simp [sub_eq_add_neg]
simp
simp
simp
subst_vars
simp [Nat.succ_mul, pow_add]
subst_vars
simp [Nat.succ_mul, pow_add]
simp
subst_vars
simp [_root_.mul_pow, pow_mul]
simp
subst_vars
rw [mul_assoc]
simp
simp [pow_succ]
simp [*]
subst_vars
simp [pow_mul]
simp
subst_vars
simp [_root_.pow_add]
simp [e]
simp [e]
simp [e]
simp
simp [*]
subst_vars
rfl
subst_vars
rfl
subst_vars
rfl
subst_vars
rfl
subst_vars
rfl
subst_vars
rfl
subst_vars
rfl
simp
simp
simp
simp [Int.negOfNat_eq]
simp [Int.negOfNat_eq, OfNat.ofNat]
induction ps generalizing as₁ with
  | nil => exact fun _ ↦ id
  | cons a as ih =>
    refine fun e H ↦ @ih (a::as₁) e (H ?_)
    subst e; clear ih H
    suffices ∀ n n', n' = List.length as₁ + n →
      ∀ bs, mk (as₁.reverseAux bs) n' ↔ mk bs n from this 0 _ rfl (a::as)
    induction as₁ with simp
    | cons b as₁ ih => exact fun n bs ↦ ih (n+1) _ (Nat.succ_add ..) _
simp
exact h -- succeeds
simp
simp
simp
simp
simp
simp [Int.negOfNat_eq, Int.cast_neg]
assumption
assumption
assumption
assumption
with_reducible assumption
with_reducible assumption
with_reducible assumption
cases that
have := ofNat_pos.2 <| Nat.le_of_ble_eq_true hn
have nonneg := emod_nonneg a <| Int.ne_of_gt this
refine ⟨Nat.zero_le _, ?_, ?_⟩
· rw [Int.toNat_lt nonneg]; exact Int.emod_lt_of_pos _ this
· rw [Int.modeq, Int.toNat_of_nonneg nonneg, emod_emod]
infer_instance
subst h
subst h'
rw [heq_iff_eq, heq_iff_eq, ext_iff]
simp only [@eq_comm _ b, exists_eq_subtype_mk_iff, @eq_comm _ _ a, iff_self]
rfl
apply congr_arg Subtype.val hxy
decide
rw [if_pos (succ_pos m)]
rfl
dsimp [mod, modDiv]
cases (m : ℕ) % (k : ℕ) with
  | zero =>
    rw [if_pos rfl]
    rfl

  | succ n =>
    rw [if_neg n.succ_ne_zero]
    rfl
dsimp [div, modDiv]
cases (m : ℕ) % (k : ℕ) with
  | zero =>
    rw [if_pos rfl]
    rfl

  | succ n =>
    rw [if_neg n.succ_ne_zero]
    rfl
rw [coe_coe, Nat.toPNat'_coe, if_pos (Int.nat_abs_pos_of_ne_zero hn.ne'),
        Int.nat_abs_of_nonneg hn.le]
dsimp [LT.lt]
infer_instance
dsimp [LE.le]
infer_instance
dsimp [LT.lt]
infer_instance
dsimp [LE.le]
infer_instance
(exact Nat.div_lt_self (Nat.succ_pos n) (Nat.le_refl 2))
dsimp [LT.lt]
infer_instance
dsimp [LE.le]
infer_instance
simp [map_map]
simp [map_map]
intros
rfl
intros
rfl
rw [cast_succ, Nat.cast_zero, zero_add]
induction n <;> simp [add_succ, add_assoc, Nat.add_zero, Nat.cast_one, Nat.cast_zero, *]
(exact Nat.div_lt_self (Nat.succ_pos n) (Nat.le_refl 2))
apply Nat.strongInductionOn n
intros k hk
cases k with
  | zero => rw [Nat.binCast, Nat.cast_zero]
  | succ k =>
      rw [Nat.binCast]
rw [bit1, cast_add_one, cast_bit0]
rfl
simp only [Nat.binCast, Nat.cast]
rfl
rw [←Nat.cast_one, ←Nat.cast_add]
apply congrArg
decide
intros
rfl
intros
rfl
erw [cast_ofNat, Nat.cast_zero]
erw [cast_ofNat, Nat.cast_one]
rw [← cast_add, Nat.sub_add_cancel h]
erw [cast_zero, neg_zero]
erw [cast_ofNat, cast_negSucc]
erw [cast_ofNat, cast_negSucc, neg_neg]
unfold Int.subNatNat
cases e : n - m
· simp only [subNatNat, cast_ofNat]
    simp [e, Nat.le_of_sub_eq_zero e]
· rw [cast_negSucc, Nat.add_one, ← e, Nat.cast_sub <| _root_.le_of_lt <| Nat.lt_of_sub_eq_succ e,
      neg_sub]
simp [← ofNat_add]
erw [cast_subNatNat, cast_ofNat, cast_negSucc, sub_eq_add_neg]
erw [cast_subNatNat, cast_ofNat, cast_negSucc, sub_eq_iff_eq_add,
      add_assoc, eq_neg_add_iff_add_eq, ← Nat.cast_add, ← Nat.cast_add, Nat.add_comm]
rw [cast_negSucc, cast_negSucc, cast_negSucc, ← neg_add_rev, ← Nat.cast_add,
      Nat.add_right_comm m n 1, Nat.add_assoc, Nat.add_comm]
simp [Int.sub_eq_add_neg, sub_eq_add_neg]
simp
simp [add_mul, ih]
simp [sub_mul, ih]
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
infer_instance
rw [neg_succ, succ_pred]
rw [eq_neg_of_eq_neg (neg_succ (-a)).symm, neg_neg]
rw [neg_pred, pred_succ]
cases n
cases h
simp
rfl
rw [← nat_abs_mul, Units.mul_inv] <;> rfl
rw [← nat_abs_mul, Units.inv_mul] <;> rfl
simp [nat_abs_eq_iff, is_unit_iff, Nat.cast_zero]
rw [Nat.is_unit_iff, is_unit_iff_nat_abs_eq, nat_abs_of_nat]
rw [← sub_add_cancel (G := ℤ) z b, add_comm]
exact match z - b with
  | .ofNat n => pos n
  | .negSucc n => neg n
erw [add_zero]
rw [add_assoc]
rfl
rw [add_sub_assoc]
rfl
cases h
exact ⟨rfl, heq_of_eq rfl⟩
subst h₁
rw [eq_of_heq h₂]
cases x₀
cases x₁
cases h₀
cases h₁
rfl
cases x₀
cases x₁
exact Sigma.mk.inj_iff
simp only [Function.Surjective, Sigma.forall, h₁.forall]
exact fun i ↦ (h₂ _).forall.2 fun x ↦ ⟨⟨i, x⟩, rfl⟩
cases x₀
cases x₁
cases h₀
cases h₁
rfl
cases x₀
cases x₁
exact PSigma.mk.inj_iff
simp
split <;> rename_i h
· simp [(m.parent ⟨i, h⟩).2, h]; exact m.rank_lt _
· intro.
simp
split <;> rename_i h'
· rw [← h']; exact fun _ ↦ h
· exact m.rank_lt i
simp
split <;>
      (rename_i h₁; simp [h₁]; split <;> rename_i h₂ <;>
        (intro h; simp [h] at h₂ <;> simp [h₁, h₂, h]))
· simp [← h₁]; split <;> rename_i h₃
      · rw [h₃]; apply Nat.lt_succ_self
      · exact lt_of_le_of_ne H h₃
· have := Fin.eq_of_val_eq h₂.1; subst this
      simp [hroot] at h
· have := m.rank_lt i h
      split <;> rename_i h₃
      · rw [h₃.1]; exact Nat.lt_succ_of_lt this
      · exact this
funext ⟨i, h⟩
apply H
    cases this
constructor
cases H
rfl
cases H
exact fun i h _ ↦ rfl
simp [hk]
apply le_antisymm <;> simp_all [Nat.lt_succ]
simp
simp_all [Array.get_set]
rw [H.size_eq]
exact h
apply H.imp <;>
  · intro H
    refine H.push _ hk _ _ (fun i h ↦ ?_) (fun h ↦ ?_) <;>
    simp [UFModel.push, h, lt_irrefl]
simp [UFModel.setParent, h.symm]
simp [UFModel.setParent, hp]
let ⟨n, m, hm⟩ := self.model
cases hm.size_eq
exact ⟨m, hm⟩
let ⟨k, H⟩ := rankMaxAux self i
refine ⟨max k (if h : _ then (self.arr.get ⟨i, h⟩).rank else 0), fun j hj h ↦ ?_⟩
match j, lt_or_eq_of_le (Nat.le_of_lt_succ hj) with
  | j, Or.inl hj => exact le_trans (H _ hj h) (le_max_left _ _)
  | _, Or.inr rfl => simp [h, le_max_right]
simp [rank]
split
{apply lt_rankMax'}
apply Nat.succ_pos
simp [rank, h, H.rank_eq]
let ⟨m, hm⟩ := self.model'
simp [hm.parent_eq, size, (m.parent ⟨i, h⟩).2, h]
simp [root.2]
rw [← hm.parent_eq x x.2 x'.2]
rfl
rw [e]
exact this
simp
exact y.2
simp
rw [if_neg h.symm]
simp
simp [h.symm]
simp [ne, hm.parent_eq']
simp
simp [hm.rank_eq]
rw [if_neg h.symm]
simp [hm.rank_eq]
rw [e]
exact y.2
rw [e]
exact rx.2
cases h
rfl
cases x <;> simp only [getLeft, isRight, eq_self_iff_true]
cases x <;> simp only [getRight, isLeft, eq_self_iff_true]
simp
simp (config := { contextual := true })
simp
simp (config := { contextual := true })
rw [← update_inl_comp_inl, Function.comp_apply]
rw [← update_inr_comp_inr, Function.comp_apply]
cases x <;> rfl
cases h
assumption
cases h
assumption
cases h
· exact LiftRel.inl (hr _ _ ‹_›)
· exact LiftRel.inr (hs _ _ ‹_›)
cases h
· exact LiftRel.inr ‹_›
· exact LiftRel.inl ‹_›
rw [← swap_swap x, ← swap_swap y]
exact h.swap
cases h
assumption
cases h
assumption
cases h
· exact Lex.inl ‹_›
· exact Lex.inr ‹_›
cases h
· exact Lex.inl (hr _ _ ‹_›)
· exact Lex.inr (hs _ _ ‹_›)
· exact Lex.sep _ _
cases a
cases b
intro h
cases h
rfl
cases a
rfl
simp only [Fin.ofNat', Nat.mod_eq_of_lt h]
simp only [OfNat.ofNat, Fin.ofNat]
rw [Nat.mod_eq_of_lt]
exact Nat.succ_lt_succ (Nat.zero_lt_succ _)
apply Fin.eq_of_val_eq
simp only [Fin.mod_def]
rw [Nat.mod_eq_of_lt h, Nat.mod_eq_of_lt a.isLt]

/- The basic structures on `Fin` are predicated on `Fin n` being nonempty.
The Nonempty bound is there so that we can implement `Zero` in a way that satisfies
the requirements of the relevant typeclasses (for example, AddMonoid). If we were to
use `Fin n+1` for the `Zero` implementation, we would be shutting out some irreducible
definitions (notably USize.size) that are known to be inhabited, but not defined in terms
of `Nat.succ`. Since there's a blanket implementation of `∀ n, Inhabited (Fin n+1)` in
the prelude, this hopefully won't be a significant impediment. -/
simp [Fin.ofNat', Fin.add_def]
apply Fin.eq_of_val_eq
simp only [Fin.add_def, Nat.mod_add_mod, Nat.add_mod_mod, Nat.add_assoc]
apply Fin.eq_of_val_eq
simp only [Fin.add_def, Nat.add_comm]
apply Fin.eq_of_val_eq
simp only [Fin.mul_def]
generalize lhs : ((a.val * b.val) % n * c.val) % n = l
generalize rhs : a.val * (b.val * c.val % n) % n = r
rw [← Nat.mod_eq_of_lt c.isLt, (Nat.mul_mod (a.val * b.val) c.val n).symm] at lhs
rw [← Nat.mod_eq_of_lt a.isLt, (Nat.mul_mod a.val (b.val * c.val) n).symm,
        ← Nat.mul_assoc] at rhs
rw [← lhs, ← rhs]
apply Fin.eq_of_val_eq
simp only [Fin.mul_def, Nat.mul_comm]
simp only [Fin.ofNat', Nat.zero_mod]
have zero_lt : (0 : Nat) < m := @Fin.zero_def n _ ▸ hp
have a_mod_lt : a % m < m := Nat.mod_lt _ zero_lt
simp only [Fin.mod_def, LT.lt]
rw [(Nat.mod_eq_of_lt (Nat.lt_trans a_mod_lt mLt) : a % m % n = a % m)]
exact Nat.mod_lt _ zero_lt

/- Aux lemma that makes nsmul_succ' easier -/
apply Fin.eq_of_val_eq
simp only [Fin.ofNat', Fin.mul_def]
generalize hy : x * a % n = y
rw [← Nat.mod_eq_of_lt isLt, ← Nat.mul_mod, hy]
simp [Fin.ofNat']
apply Fin.eq_of_val_eq
simp only [Fin.add_def, Fin.zero_def, Nat.add_zero]
exact Nat.mod_eq_of_lt a.isLt
apply Fin.eq_of_val_eq
simp only [Fin.add_def, Fin.zero_def, Nat.zero_add]
exact Nat.mod_eq_of_lt a.isLt
apply Fin.eq_of_val_eq
simp [Fin.mul_def, Fin.ofNat', Fin.zero_def, Nat.zero_mul, Nat.zero_mod]
simp only [Fin.nsmuls_eq]
simp [Fin.ofNat', Fin.add_def]
exact congrArg (fun x ↦ x % n) (Nat.add_comm (x * a.val) (a.val) ▸ Nat.succ_mul x a.val)
apply Fin.eq_of_val_eq
simp only [Fin.mul_def, Fin.one_def]
cases n with
  | zero => exact (False.elim a.elim0)
  | succ n =>
    match Nat.lt_or_eq_of_le (Nat.mod_le 1 n.succ) with
    | Or.inl h_lt =>
      have h_eq : 1 % n.succ = 0 := Nat.eq_zero_of_le_zero (Nat.le_of_lt_succ h_lt)
      have hnz : n = 0 := Nat.eq_zero_of_le_zero (Nat.le_of_succ_le_succ (Nat.le_of_mod_lt h_lt))
      have haz : a.val = 0 := Nat.eq_zero_of_le_zero (Nat.le_of_succ_le_succ (hnz ▸ a.isLt))
      rw [h_eq, haz]
      simp only [Nat.zero_mul, Nat.zero_mod]
    | Or.inr h_eq => simp only [h_eq, Nat.mul_one, Nat.mod_eq_of_lt (a.isLt)]
rw [mul_comm, Fin.mul_one]
apply Fin.eq_of_val_eq
simp only [Fin.mul_def, Fin.zero_def, Nat.zero_mul, Nat.zero_mod]
apply Fin.eq_of_val_eq
simp only [Fin.mul_def, Fin.zero_def, Nat.mul_zero, Nat.zero_mod]
apply Fin.eq_of_val_eq
simp [Fin.mul_def, Fin.add_def]
generalize lhs : a.val * ((b.val + c.val) % n) % n = l
rw [(Nat.mod_eq_of_lt a.isLt).symm, ← Nat.mul_mod] at lhs
rw [← lhs, left_distrib]
rw [mul_comm, Fin.mul_add, mul_comm c, mul_comm c]
simp [Fin.add_def, Fin.sub_def, Neg.neg]
rw [add_comm, ← Fin.sub_eq_add_neg]
apply Fin.eq_of_val_eq
simp [Fin.sub_def, (Nat.add_sub_cancel' (Nat.le_of_lt a.isLt)), Nat.mod_self]
intro h1 h2
apply Fin.eq_of_val_eq
exact Nat.le_antisymm h1 h2
have : r = p := funext fun a ↦ funext fun b ↦ propext <| Eq a b
     subst this
     rfl
simp [heq_self_iff_true]
simp [heq_self_iff_true]
refine' Iff.trans _ Quotient.eq
rw [Quotient.out_eq y]
refine' Iff.trans _ Quotient.eq
rw [Quotient.out_eq x]
rw [← Quotient.eq_mk_iff_out, Quotient.out_eq]
infer_instance
rw [congr_append]
simp only [String.length]
exact List.length_append as bs
simp only [String.length, String.replicate, List.length_replicate]
simp only [String.length]
simp only [leftpad, String.length, List.leftpad_length]
simp only [isPrefix, replicate, leftpad, String.length, List.leftpad_prefix]
simp only [isSuffix, replicate, leftpad, String.length, List.leftpad_suffix]
rw [← @mk.eta _ _ p, ← @mk.eta _ _ q, mk.inj_iff]
simp
simp
simp
cases h <;> simp [*]
subst e
exact Lex.right _ h
rw [Prod.map_map, hf.comp_eq_id, hg.comp_eq_id, map_id, id]
decide
decide
decide
decide
simp [add_def, zero_def]
simp [add_def, zero_def]
simp [add_def, add_comm]
simp [mul_def, one_def]
simp [mul_def, one_def]
simp [mul_def, zero_def]
simp [mul_def, zero_def]
simp only [mul_def, add_def]
apply eq_of_val_eq
exact right_distrib a.val b.val c.val
simp only [mul_def, add_def]
apply eq_of_val_eq
exact left_distrib a.val b.val c.val
apply eq_of_val_eq
simp [neg_def, add_def, zero_def]
apply eq_of_val_eq
simp [mul_def, zero_def]
exact mul_comm _ _
decide
decide
simp only [utf8Size]
repeat (split; decide)
decide
rw [Char.ofNat, dif_pos h]
rfl
rw [Nat.succ_mul, Nat.one_mul]
exact Nat.le_add_left i i
rw [a.size_swap i j]
exact j.1.2
rw [a.size_swap i j]
exact Nat.sub_lt_sub_left i.2 <| Nat.lt_of_le_of_ne j.2 h
assumption
rw [a.size_swap i j]
exact j.2
assumption
rw [Array.size_push]
apply Nat.lt_succ_self
simp [insert, size, size_heapifyUp]
simp [size, e]
rw [e]
apply Nat.succ_pos
rw [e]
apply Nat.lt_succ_self
simp [size]
simp [size]
simp [BinaryHeap.max, Array.get?, h] at e
simp
exact size_pos_of_max e
simp
exact size_pos_of_max e
rw [self.1.size_set]
exact i.2
rw [self.1.size_set]
exact i.2
simp
exact Nat.sub_lt (BinaryHeap.size_pos_of_max e) Nat.zero_lt_one
assumption
cases j
simp [h]
cases b <;> simp
simp [h]
cases b <;> assumption
cases b
exact Or.inl h
exact Or.inr h
cases b <;> simp
cases b <;> rfl
decide
decide
decide
decide
decide
simp [H]
cases a <;> simp [H]
decide
decide
decide
decide
decide
cases a <;> simp
cases a <;> cases b <;> cases c <;> simp
cases a <;> simp
cases a <;> cases b <;> cases c <;> simp
decide
decide
decide
decide
decide
decide
decide
simp
cases a <;> decide
cases a <;> decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
decide
cases a <;> simp
cases a <;> cases b <;> cases c <;> simp
decide
decide
decide
decide
unfold LE.le
decide
unfold LE.le
decide
unfold LE.le Preorder.toLE
decide
unfold LE.le Preorder.toLE PartialOrder.toPreorder
decide
unfold LE.le Preorder.toLE PartialOrder.toPreorder
exact inferInstance
  decidable_eq
cases a <;> cases b <;> decide
cases a <;> cases b <;> decide
decide
decide
decide
decide
decide
decide
decide
decide
simp only [ofNat, ne_eq, _root_.decide_not]
cases Nat.decEq n 0 with
  | isTrue hn => rw [decide_eq_true hn]; exact false_le
  | isFalse hn =>
    cases Nat.decEq m 0 with
    | isFalse hm => rw [decide_eq_false hm]; exact le_true
    | isTrue hm => subst hm; have h := le_antisymm h (Nat.zero_le n); contradiction
cases h with
  | inl h => subst h; exact Nat.zero_le _
  | inr h => subst h; cases b₀ <;> simp;
cases b <;> rfl
cases x <;> cases h₁ : f true <;> cases h₂ : f false <;> simp only [h₁, h₂]
simp
simp only [mem_range', or_and_left, or_iff_right_of_imp this, l, Nat.add_right_comm]
rfl
rw [show n + (s + 1) = n + 1 + s from Nat.add_right_comm n s 1]
exact range_loop_range' s (n + 1)
rw [Nat.zero_add]
simp only [range_eq_range', mem_range', Nat.zero_le, true_and, Nat.zero_add]
rfl
simp only [range_eq_range', nodup_range']
simp only [split_at, split_at_eq_take_drop n xs, take, drop]
induction xs generalizing i j with
  | nil => cases h₀
  | cons x xs ih =>
    match i, j with
    | 0, 0 => rfl
    | i+1, j+1 => simp; cases h₁ with
      | cons ha h₁ => exact ih (Nat.lt_of_succ_lt_succ h₀) h₁ h₂
    | i+1, 0 => ?_ | 0, j+1 => ?_
    all_goals
      simp at h₂
      cases h₁; rename_i h' h
      have := h x ?_ rfl; cases this
      rw [mem_iff_get?]
    exact ⟨_, h₂⟩; exact ⟨_ , h₂.symm⟩
constructor
· simp only [List.product, and_imp, exists_prop, List.mem_map, Prod.mk.injEq,
      exists_eq_right_right', List.mem_bind]
    exact And.intro
· simp only [product, mem_bind, mem_map, Prod.mk.injEq, exists_eq_right_right', exists_prop]
    exact id
induction l with
  | nil => rfl
  | cons => simp only [*, pmap, map]
induction l with
  | nil => rfl
  | cons a l ih =>
    rw [pmap, pmap, h _ (mem_cons_self _ _), ih (fun a ha ↦ h a (mem_cons_of_mem _ ha))]
induction l with
  | nil => rfl
  | cons => simp only [*, pmap, map]
induction l with
  | nil => rfl
  | cons => simp only [*, pmap, map]
rw [attach, map_pmap]
exact pmap_congr l fun _ _ _ _ ↦ rfl
rw [attach, map_pmap]
exact (pmap_eq_map ..).trans (map_id l)
rw [attach_map_val] <;> exact h
simp only [pmap_eq_map_attach, mem_map, mem_attach, true_and, Subtype.exists, eq_comm]
rfl
induction p with
| nil => exact Perm.nil
| cons x _ ih => exact Perm.cons x ih
| swap x y l => exact Perm.swap y x l
| trans _ _ ih₁ ih₂ => exact Perm.trans ih₂ ih₁
induction p with
  | nil => exact nil_subset _
  | cons _ _ ih => exact cons_subset_cons _ ih
  | swap x y l =>
    intro a
    rw [mem_cons]
    exact fun
    | Or.inl rfl => Mem.tail _ (Mem.head ..)
    | Or.inr (Mem.head ..) => Mem.head ..
    | Or.inr (Mem.tail _ a_mem_l) => Mem.tail _ (Mem.tail _ a_mem_l)
  | trans _ _ ih₁ ih₂ => exact Subset.trans ih₁ ih₂
simp
induction p with
  | nil => simp
  | cons _ _ ih => simp [ih]
  | swap _ _ l => simp
  | trans _ _ ih₁ ih₂ => exact ih₁.trans ih₂
have : ∀ l₁ l₂ : List α, (∀ x : α, x ∈ l₁ → ∀ y : α, y ∈ l₂ → R x y) →
    ∀ x : α, x ∈ l₂ → ∀ y : α, y ∈ l₁ → R x y := fun l₁ l₂ a x xm y ym ↦ s (a y ym x xm)
simp only [pairwise_append, and_left_comm]
rw [Iff.intro (this l₁ l₂) (this l₂ l₁)]
rw [← append_assoc, pairwise_append, @pairwise_append _ _ ([a] ++ l₁), pairwise_append_comm s]
simp only [mem_append, or_comm]
rfl
simp [Pairwise.nil]
induction p with
  | nil => constructor
  | @cons a l r _ ih =>
    constructor
    · exact BAll.imp_right (fun x h ↦ H (mem_cons_self _ _) (mem_cons_of_mem _ h)) r
    · exact ih fun {a b} m m' ↦ H (mem_cons_of_mem _ m) (mem_cons_of_mem _ m')
simp (config := { contextual := true })
simp
simp
induction as with
  | nil => simp [remove]
  | cons a' as ih =>
    simp [remove]
    cases Decidable.em (a = a') with
    | inl h =>
      simp only [if_pos h, ih]
      exact ⟨fun ⟨h1, h2⟩ ↦ ⟨Or.inr h1, h2⟩, fun ⟨h1, h2⟩ ↦ ⟨Or.resolve_left h1 (h ▸ h2), h2⟩⟩
    | inr h =>
      simp [if_neg h, ih]
      constructor
      { focus
        intro h'
        cases h' with
        | inl h₁ => exact ⟨Or.inl h₁, h₁.symm ▸ (Ne.symm h)⟩
        | inr h₁ => exact ⟨Or.inr h₁.1, h₁.2⟩ }
      intro ⟨h1, h2⟩
      cases h1 with
      | inl h1' => exact Or.inl h1'
      | inr h1' => exact Or.inr ⟨h1', h2⟩
simp [remove]
rw [h']
apply mem_cons_self
rw [mem_remove_iff] at h
exact h.1

/- card -/
simp [card, h]
simp [card, h]
cases Decidable.em (a ∈ as) with
  | inl h => simp [h, Nat.le_refl]
  | inr h => simp [h, Nat.le_succ]
simp [h]
simp [h]
rw [mem_remove_iff]
exact ⟨h'', Ne.symm h'⟩
          simp [h'', this, card_remove_of_mem h₃]
simp
induction as with
  | nil => simp
  | cons a as ih =>
    cases Decidable.em (f a ∈ map f as) with
    | inl h => simp [h]; apply Nat.le_trans ih (card_le_card_cons ..)
    | inr h =>
      have : a ∉ as := fun h'' ↦ h (mem_map_of_mem _ h'')
      simp [h, this]
      exact Nat.add_le_add_right ih _
induction as with
  | nil => simp
  | cons a as ih =>
    cases Decidable.em (f a ∈ map f as) with
    | inl h =>
      intro inj_on'
      cases (exists_of_mem_map h) with
      | intro x hx =>
        have : a = x := inj_on' (mem_cons_self ..) (mem_cons_of_mem _ hx.1) hx.2
        have h1 : a ∈ as := this ▸ hx.1
        have h2 : inj_on f as := inj_on_of_subset inj_on' (subset_cons _ _)
        simp  [h1, mem_map_of_mem f h1, ih h2]
    | inr h =>
      intro inj_on'
      have h1 : a ∉ as := fun h'' ↦ h (mem_map_of_mem _ h'')
      have h2 : inj_on f as := inj_on_of_subset inj_on' (subset_cons _ _)
      simp [h, h1, ih h2]
simp
have disj' : Disjoint as bs := fun _ h1 h2 ↦ disj (mem_cons_of_mem a h1) h2
cases Decidable.em (a ∈ as) with
    | inl h =>
      simp [h, card_append_disjoint disj']
    | inr h =>
      have h1 : a ∉ bs := fun h' ↦ disj (mem_cons_self a as) h'
      simp [h, h1, card_append_disjoint disj']
      rw [Nat.add_right_comm]
rw [card_eq_of_equiv (union_equiv_append as bs), card_append_disjoint h]
cases p with | cons n p => exact ⟨n, p⟩
induction p generalizing b with
  | nil => constructor
  | cons r _ ih =>
    constructor
    · exact Hab r
    · exact ih (@HRS _)
simp only [mem_cons, forall_eq_or_imp, h, true_and]
exact fun c hc ↦ trans h (rel_of_pairwise_cons hb.pairwise hc)
congr
exact hf a (H _ ha) b (H _ hb) h
simp
simp [false_imp_iff]
cases h
cases o <;> simp [toList, eq_comm]
cases a <;> cases b <;> simp [liftOrGet, IsCommutative.comm]
cases a <;> cases b <;> cases c <;> simp [liftOrGet, IsAssociative.assoc]
cases a <;> simp [liftOrGet, IsIdempotent.idempotent]
cases a <;> simp [liftOrGet]
cases a <;> simp [liftOrGet]
rw [Hf (Option.some.inj H)]
cases x <;> simp
simp only [eq_none_iff_forall_not_mem, mem_def, bind_eq_some, not_exists, not_and, iff_self]
simp only [← map_some', h]
rw [map_map, h, ← map_map]
cases x <;> simp only [pbind, none_bind', some_bind']
simp only [← map_eq_map, ← bind_pure_comp, LawfulMonad.bind_assoc]
cases x <;> simp
cases x <;> simp only [pbind, map_none']
cases x <;> rfl
rw [mem_def] at ha ⊢
subst ha
rfl
cases x <;> simp only [map_none', map_some', pmap]
cases x <;> simp only [map_none', map_some', pmap]

-- Porting note: Can't simp tag this anymore because `pmap` simplifies
-- @[simp]
cases x <;> simp only [map_none', map_some', pmap]
cases x <;> simp only [pmap, bind_eq_bind, none_bind, some_bind]
cases x <;> simp only [pmap, bind_eq_bind, none_bind, some_bind, pbind]
cases x
· simp
· simp only [pbind, iff_false]
    intro h
    cases h' _ rfl h
cases x <;> simp

-- Porting note: Can't simp tag this anymore because `pmap` simplifies
-- @[simp]
cases x <;> rfl
cases x <;> rfl
cases o <;> rfl
cases u
cases o <;> rfl
cases o
· simp only [true_and, false_or, eq_self_iff_true, none_orElse, iff_self]
· simp only [some_orElse, or_false, false_and, iff_self]
cases o
· simp only [true_and, none_orElse, eq_self_iff_true, iff_self]
· simp only [some_orElse, false_and, iff_self]
cases o <;> rfl
intro _ _ _ _ hα hβ
exact Relation.TransGen.tail (Relation.TransGen.single $ GameAdd.fst hα) (GameAdd.snd hβ)
intro x y h
rw [lt_iff_le_not_le, lt_iff_le_not_le, hf.le_iff_le ha hb, hf.le_iff_le hb ha]
simp only [Prod.lt_iff]
exact Or.imp (And.imp hf.imp hg.monotone.imp) (And.imp hf.monotone.imp hg.imp)
simp only [Prod.lt_iff]
exact Or.imp (And.imp hf.imp hg.antitone.imp) (And.imp hf.antitone.imp hg.imp)
funext a b
show (LT.mk A_lt).lt a b = (LT.mk B_lt).lt a b
simp [*]
cases A
cases B
cases h
congr
funext a b
show (Min.mk A_min).min a b = (Min.mk B_min).min a b
simp [*]
split <;> rfl
funext a b
show (Max.mk A_max).max a b = (Max.mk B_max).max a b
simp [*]
split <;> rfl
rw [max_comm, max_def]
rfl
rw [min_comm, min_def]
rfl
simp (config := { contextual := true }) [lt_iff_le_not_le, Pi.le_def]
simp (config := { contextual := true }) [update_le_iff]
simp [Pi.le_def]
rw [min_comm, min_def, ← ite_not]
simp only [not_le]
rw [max_def, ← ite_not]
simp only [not_le]
intros x y
apply inj
rw [apply_ite f]
exact (hinf _ _).trans (min_def _ _)
intros x y
apply inj
rw [apply_ite f]
exact (hsup _ _).trans (max_def _ _)
intros
trivial
intros
trivial
intros
exact Or.inl trivial
  le_antisymm
intros
rfl
simp only [and_not_self, iff_false]
exact fun _ _ h ↦ False.elim h
simp only [lt_self_iff_false]
cases o
· exact Iff.rfl
· exact eq_comm
· exact Iff.rfl
rw [← swap_inj, swap_swap]
injection h
injection h
injection h
injection h
injection h
injection h
cases o₁ <;> rfl
decide
unfold cmp cmpUsing
rw [cmp_eq_eq_iff]
rw [← cmp_eq_lt_iff, ← cmp_eq_lt_iff, h]
rw [le_antisymm_iff, le_antisymm_iff, le_iff_le_of_cmp_eq_cmp h,
      le_iff_le_of_cmp_eq_cmp (cmp_eq_cmp_symm.1 h)]
simp [lt_iff_le_not_le, IsMin, not_forall, exists_prop]
simp [lt_iff_le_not_le, IsMax, not_forall, exists_prop]
rw [e] at h
exact irrefl _ h
simp [h₁, h₂]
infer_instance

-- see Note [lower instance priority]
infer_instance

-- see Note [lower instance priority]
infer_instance

-- see Note [lower instance priority]
infer_instance
simp only [Bounded, Unbounded, not_forall, not_exists, exists_prop, not_and, not_not, iff_self]
rw [not_iff_comm, not_bounded_iff]
infer_instance
infer_instance
infer_instance
infer_instance
rw [Nat.succ_pred_eq_of_pos]
exact h.right
exact lt_of_le_of_lt (Nat.zero_le lo) h.left
decide
apply Nat.div_lt_self h
decide
simp_wf
exact Nat.succ_lt_succ $ lt_of_le_of_lt (Nat.mod_le _ _) x.property
simp_wf
simp only [SizeOf.sizeOf]
rw [Int.natAbs_neg]
exact h
simp_wf
apply Prod.Lex.left
simp_all_arith
simp_wf
apply Prod.Lex.right
simp_all_arith
simp [Fin.ofNat, LE.le]
exact Nat.zero_le _
decide
