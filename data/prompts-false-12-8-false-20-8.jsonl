{"text": "Every ring is a field.", "fullPrompt": "/-- `ℤ` with its usual ring structure is not a field. -/\ntheorem  : ¬is_field ℤ :=\n\n/-- `polynomial R` is never a field for any ring `R`. -/\ntheorem {R : Type u} [ring R] : ¬is_field (polynomial R) :=\n\n/-- An element of an algebra over a field is algebraic if and only if it is integral. -/\ntheorem {K : Type u} {A : Type v} [field K] [ring A] [algebra K A] {x : A} : is_algebraic K x ↔ is_integral K x :=\n\n/-- An element of a ring multiplied by the additive inverse of one is the element's additive  inverse. -/\ntheorem {α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : a * -1 = -a :=\n\n/-- There is a field structure on type if and only if its cardinality is a prime power. -/\ntheorem {α : Type u} : nonempty (field α) ↔ is_prime_pow (cardinal.mk α) :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem (R : Type u) [non_assoc_ring R] (p : ℕ) [hc : char_p R p] [fintype R] : p ≠ 0 :=\n\n/-- The additive inverse of one multiplied by an element of a ring is the element's additive  inverse. -/\ntheorem {α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : (-1) * a = -a :=\n\n/-- Any infinite type can be endowed a field structure. -/\ntheorem {α : Type u} [infinite α] : nonempty (field α) :=\n\n/--  For each field, and for each nonzero element of said field, there is a unique inverse. Since `is_field` doesn't remember the data of an `inv` function and as such, a lemma that there is a unique inverse could be useful. -/\ntheorem (R : Type u) [ring R] (hf : is_field R) (x : R) : x ≠ 0 → (∃! (y : R), x * y = 1) :=\n\n/-- Right multiplication in a ring is an additive monoid morphism. -/\ntheorem {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), y * x) :=\n\n/-- Left multiplication in a ring is an additive monoid morphism. -/\ntheorem {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), x * y) :=\n\n/-- An integral element of an algebra is algebraic. -/\ntheorem (R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] [nontrivial R] {x : A} : is_integral R x → is_algebraic R x :=\n\n/-- Every ring is a field. -/\ntheorem "}
{"text": "Every vector space is finite dimensional.", "fullPrompt": "/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type w} [fintype ι] (h : basis ι K V) : finite_dimensional K V :=\n\n/-- A finite dimensional space is nontrivial if it has positive `finrank`. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (h : 0 < finite_dimensional.finrank K V) : nontrivial V :=\n\n/-- A finite dimensional space that is a subsingleton has zero `finrank`. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [h : subsingleton V] : finite_dimensional.finrank K V = 0 :=\n\n/-- A nontrivial finite dimensional space has positive `finrank`. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] [h : nontrivial V] : 0 < finite_dimensional.finrank K V :=\n\n/-- A finite dimensional space has positive `finrank` iff it is nontrivial. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V ↔ nontrivial V :=\n\n/-- A finite dimensional space has positive `finrank` iff it has a nonzero element. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V ↔ ∃ (x : V), x ≠ 0 :=\n\n/--  In a finite-dimensional space, its dimension (seen as a cardinal) coincides with its `finrank`. -/\ntheorem (K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : ↑(finite_dimensional.finrank K V) = module.rank K V :=\n\n/-- In an `n`-dimensional space, the rank is at most `m`. -/\ntheorem {R : Type u_1} [ring R] [strong_rank_condition R] (n : ℕ) {m : ℕ} (v : fin m → fin n → R) : linear_independent R v → m ≤ n :=\n\n/-- A module has dimension 1 iff there is some `v : V` so `{v}` is a basis. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (ι : Type u_1) [unique ι] : finite_dimensional.finrank K V = 1 ↔ nonempty (basis ι K V) :=\n\n/-- A free module with a basis indexed by a `fintype` is finite. -/\ntheorem {R : Type u_1} {M : Type u_2} {ι : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [fintype ι] (b : basis ι R M) : module.finite R M :=\n\n/--  A finite dimensional space has zero `finrank` iff it is a subsingleton. This is the `finrank` version of `dim_zero_iff`. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : finite_dimensional.finrank K V = 0 ↔ subsingleton V :=\n\n/-- The vector space of functions on `fin n` has finrank equal to `n`. -/\ntheorem (K : Type u) [division_ring K] {n : ℕ} : finite_dimensional.finrank K (fin n → K) = n :=\n\n/-- An affine-independent subset of a finite-dimensional affine space is finite. -/\ntheorem (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [finite_dimensional k V] {s : set P} (hi : affine_independent k coe) : s.finite :=\n\n/-- Every vector space is finite dimensional. -/\ntheorem "}
{"text": "Every group is a torsion monoid.", "fullPrompt": "/-- A monoid is not a torsion monoid if it has an element of infinite order. -/\ntheorem (G : Type u_1) [monoid G] : ¬monoid.is_torsion G ↔ ∃ (g : G), ¬is_of_fin_order g :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem (G : Type u_1) [monoid G] : ¬monoid.is_torsion_free G ↔ ∃ (g : G), g ≠ 1 ∧ is_of_fin_order g :=\n\n/-- Finite groups are torsion groups. -/\ntheorem {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : is_monoid_hom f :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem {G : Type u_3} [group G] : group.fg G ↔ monoid.fg G :=\n\n/-- A map to a group preserving multiplication is a monoid homomorphism. -/\ntheorem {α : Type u} {β : Type v} [mul_one_class α] [group β] {f : α → β} (hf : is_mul_hom f) : is_monoid_hom f :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G → ¬monoid.is_torsion G :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G → ¬monoid.is_torsion_free G :=\n\n/-- A monoid is a submonoid of itself. -/\ntheorem {M : Type u_1} [monoid M] : is_submonoid set.univ :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i) :=\n\n/-- A group `G` is finitely generated if and only if `add_monoid_algebra R G` is of finite type. -/\ntheorem {R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) ↔ group.fg G :=\n\n/-- An additive group homomorphism is an additive monoid homomorphism. -/\ntheorem {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : is_add_monoid_hom f :=\n\n/-- The additive torsion submonoid of an additive torsion monoid is `⊤`. -/\ntheorem {G : Type u_1} [add_comm_monoid G] (tG : add_monoid.is_torsion G) : add_comm_monoid.add_torsion G = ⊤ :=\n\n/-- An additive monoid is not a torsion monoid if it has an element of infinite order. -/\ntheorem (G : Type u_1) [add_monoid G] : ¬add_monoid.is_torsion G ↔ ∃ (g : G), ¬is_of_fin_add_order g :=\n\n/-- The torsion submonoid of a torsion monoid is `⊤`. -/\ntheorem {G : Type u_1} [comm_monoid G] (tG : monoid.is_torsion G) : comm_monoid.torsion G = ⊤ :=\n\n/-- Every group is a torsion monoid. -/\ntheorem "}
{"text": "Every finite simple group has prime order.", "fullPrompt": "/-- A finite group of prime order is simple. -/\ntheorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_simple_group α :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_cyclic α :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x :=\n\n/--  For every prime `p` dividing the order of a finite group `G` there exists an element of order `p` in `G`. This is known as Cauchy's theorem. -/\ntheorem {G : Type u_1} [group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G) : ∃ (x : G), order_of x = p :=\n\n/--  For every prime `p` dividing the order of a finite additive group `G` there exists an element of order `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem {G : Type u_1} [add_group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G) : ∃ (x : G), add_order_of x = p :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ↔ is_of_fin_add_order x :=\n\n/-- A p-group is nilpotent -/\ntheorem {G : Type u_1} [hG : group G] [hf : fintype G] {p : ℕ} [hp : fact (nat.prime p)] (h : is_p_group p G) : group.is_nilpotent G :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem {α : Type u_1} [fintype α] [field α] : is_prime_pow (fintype.card α) :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem {G : Type u} [group G] {x : G} : is_of_fin_order x⁻¹ ↔ is_of_fin_order x :=\n\n/-- If a direct product has finite order then so does each component. -/\ntheorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_order x) (i : η) : is_of_fin_order (x i) :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- Any descending central series for a group is bounded below by the lower central series. -/\ntheorem {G : Type u_1} [group G] (H : ℕ → subgroup G) (hH : is_descending_central_series H) (n : ℕ) : lower_central_series G n ≤ H n :=\n\n/-- Every finite simple group has prime order. -/\ntheorem "}
{"text": "Every finite group is simple.", "fullPrompt": "/-- A finite group of prime order is simple. -/\ntheorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_simple_group α :=\n\n/-- Finite groups are torsion groups. -/\ntheorem {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_cyclic α :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 1 → a = 1 :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x :=\n\n/-- A subobject is simple iff it is an atom in the subobject lattice. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (Y : category_theory.subobject X) : category_theory.simple ↑Y ↔ is_atom Y :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem {G : Type u_3} [group G] : group.fg G ↔ monoid.fg G :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ↔ is_of_fin_add_order x :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : is_monoid_hom f :=\n\n/-- Moving to the opposite group or group_with_zero commutes with taking powers. -/\ntheorem {M : Type u} [div_inv_monoid M] (x : M) (z : ℤ) : mul_opposite.op (x ^ z) = mul_opposite.op x ^ z :=\n\n/-- If `X` has subobject lattice `{⊥, ⊤}`, then `X` is simple. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) [is_simple_order (category_theory.subobject X)] : category_theory.simple X :=\n\n/--  For every prime `p` dividing the order of a finite group `G` there exists an element of order `p` in `G`. This is known as Cauchy's theorem. -/\ntheorem {G : Type u_1} [group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G) : ∃ (x : G), order_of x = p :=\n\n/--  **Burnside's lemma** : given a finite group `G` acting on a set `X`, the average number of elements fixed by each `g ∈ G` is the number of orbits. -/\ntheorem (α : Type u) (β : Type v) [group α] [mul_action α β] [fintype α] [Π (a : α), fintype ↥(mul_action.fixed_by α β a)] [fintype (quotient (mul_action.orbit_rel α β))] : finset.univ.sum (λ (a : α), fintype.card ↥(mul_action.fixed_by α β a)) = fintype.card (quotient (mul_action.orbit_rel α β)) * fintype.card α :=\n\n/-- In an integral domain, a sum indexed by a nontrivial homomorphism from a finite group is zero. -/\ntheorem {R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G →* R) (hf : f ≠ 1) : finset.univ.sum (λ (g : G), ⇑f g) = 0 :=\n\n/--  In an integral domain, a sum indexed by a homomorphism from a finite group is zero, unless the homomorphism is trivial, in which case the sum is equal to the cardinality of the group. -/\ntheorem {R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G →* R) [decidable (f = 1)] : finset.univ.sum (λ (g : G), ⇑f g) = ite (f = 1) ↑(fintype.card G) 0 :=\n\n/-- Every finite group is simple. -/\ntheorem "}
{"text": "Every finite group has prime order.", "fullPrompt": "/-- A finite group of prime order is cyclic. -/\ntheorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_cyclic α :=\n\n/-- A finite group of prime order is simple. -/\ntheorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_simple_group α :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x :=\n\n/--  For every prime `p` dividing the order of a finite group `G` there exists an element of order `p` in `G`. This is known as Cauchy's theorem. -/\ntheorem {G : Type u_1} [group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G) : ∃ (x : G), order_of x = p :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ↔ is_of_fin_add_order x :=\n\n/--  For every prime `p` dividing the order of a finite additive group `G` there exists an element of order `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem {G : Type u_1} [add_group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G) : ∃ (x : G), add_order_of x = p :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem {G : Type u} [group G] {x : G} : is_of_fin_order x⁻¹ ↔ is_of_fin_order x :=\n\n/-- Finite groups are torsion groups. -/\ntheorem {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem {α : Type u_1} [fintype α] [field α] : is_prime_pow (fintype.card α) :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- If a direct product has finite order then so does each component. -/\ntheorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_order x) (i : η) : is_of_fin_order (x i) :=\n\n/-- If a direct product has finite additive order then so does each component. -/\ntheorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_add_order x) (i : η) : is_of_fin_add_order (x i) :=\n\n/--  **Burnside's lemma** : given a finite group `G` acting on a set `X`, the average number of elements fixed by each `g ∈ G` is the number of orbits. -/\ntheorem (α : Type u) (β : Type v) [group α] [mul_action α β] [fintype α] [Π (a : α), fintype ↥(mul_action.fixed_by α β a)] [fintype (quotient (mul_action.orbit_rel α β))] : finset.univ.sum (λ (a : α), fintype.card ↥(mul_action.fixed_by α β a)) = fintype.card (quotient (mul_action.orbit_rel α β)) * fintype.card α :=\n\n/-- In an integral domain, a sum indexed by a nontrivial homomorphism from a finite group is zero. -/\ntheorem {R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G →* R) (hf : f ≠ 1) : finset.univ.sum (λ (g : G), ⇑f g) = 0 :=\n\n/--  In an integral domain, a sum indexed by a homomorphism from a finite group is zero, unless the homomorphism is trivial, in which case the sum is equal to the cardinality of the group. -/\ntheorem {R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G →* R) [decidable (f = 1)] : finset.univ.sum (λ (g : G), ⇑f g) = ite (f = 1) ↑(fintype.card G) 0 :=\n\n/-- Every finite group has prime order. -/\ntheorem "}
{"text": "Every set has Lebesgue measure zero.", "fullPrompt": "/-- The set of Liouville numbers has Lebesgue measure zero. -/\ntheorem  : ⇑measure_theory.measure_space.volume {x : ℝ | liouville x} = 0 :=\n\n/-- The empty set has zero diameter -/\ntheorem {α : Type u} [pseudo_metric_space α] : metric.diam ∅ = 0 :=\n\n/-- The diameter of the empty set vanishes -/\ntheorem {α : Type u} [pseudo_emetric_space α] : emetric.diam ∅ = 0 :=\n\n/--  The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue measure zero. -/\ntheorem  : ⇑measure_theory.measure_space.volume (⋃ (p : ℝ) (hp : 2 < p), {x : ℝ | liouville_with p x}) = 0 :=\n\n/-- The product of the constant function `0` over any set equals `0`. -/\ntheorem {α : Type u_1} {M : Type u_5} [add_comm_monoid M] (s : set α) : finsum (λ (i : α), finsum (λ (H : i ∈ s), 0)) = 0 :=\n\n/-- Every set has a measurable superset. Declare this as local instance as needed. -/\ntheorem {α : Type u_1} {m : measurable_space α} (s : set α) : nonempty {t // s ⊆ t ∧ measurable_set t} :=\n\n/-- If an additive indicator function is not equal to `0` at a point, then that point is in the set. -/\ntheorem {α : Type u_1} {M : Type u_4} [has_zero M] {s : set α} {f : α → M} {a : α} (h : s.indicator f a ≠ 0) : a ∈ s :=\n\n/-- The sum of any function over an empty set is `0`. -/\ntheorem {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} : finsum (λ (i : α), finsum (λ (H : i ∈ ∅), f i)) = 0 :=\n\n/-- The diameter of a set is always nonnegative -/\ntheorem {α : Type u} [pseudo_metric_space α] {s : set α} : 0 ≤ metric.diam s :=\n\n/-- Constant zero function has sum `0` -/\ntheorem {α : Type u_1} {β : Type u_2} [add_comm_monoid α] [topological_space α] : has_sum (λ (b : β), 0) 0 :=\n\n/-- The Hausdorff distance between a set and itself is zero -/\ntheorem {α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist s s = 0 :=\n\n/-- The minimal distance of a point to a set containing it vanishes -/\ntheorem {α : Type u} [pseudo_metric_space α] {s : set α} {x : α} (h : x ∈ s) : metric.inf_dist x s = 0 :=\n\n/-- A transvection preserves Lebesgue measure. -/\ntheorem {ι : Type u_1} [fintype ι] [decidable_eq ι] (t : matrix.transvection_struct ι ℝ) : measure_theory.measure_preserving ⇑(⇑matrix.to_lin' t.to_matrix) measure_theory.measure_space.volume measure_theory.measure_space.volume :=\n\n/-- In the space `ι → ℝ`, Hausdorff measure coincides exactly with Lebesgue measure. -/\ntheorem {ι : Type u_1} [fintype ι] : measure_theory.measure.hausdorff_measure ↑(fintype.card ι) = measure_theory.measure_space.volume :=\n\n/-- The Haar measure equals the Lebesgue measure on `ℝ^ι`. -/\ntheorem (ι : Type u_1) [fintype ι] : measure_theory.measure.add_haar_measure (topological_space.positive_compacts.pi_Icc01 ι) = measure_theory.measure_space.volume :=\n\n/--  A useful consequence of the Lebesgue number lemma: given any compact set `K` contained in an open set `U`, we can find an (open) entourage `V` such that the ball of size `V` about any point of `K` is contained in `U`. -/\ntheorem {α : Type u_1} [uniform_space α] {K U : set α} (hK : is_compact K) (hU : is_open U) (hKU : K ⊆ U) : ∃ (V : set (α × α)) (H : V ∈ uniformity α), is_open V ∧ ∀ (x : α), x ∈ K → uniform_space.ball x V ⊆ U :=\n\n/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)  Tonelli's theorem is measurable.  This version has the argument `f` in curried form. -/\ntheorem {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] {f : α → β → ennreal} (hf : measurable (function.uncurry f)) : measurable (λ (x : α), ∫⁻ (y : β), f x y ∂ν) :=\n\n/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)  Tonelli's theorem is measurable. -/\ntheorem {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] {f : α × β → ennreal} (hf : measurable f) : measurable (λ (x : α), ∫⁻ (y : β), f (x, y) ∂ν) :=\n\n/-- Every set has Lebesgue measure zero. -/\ntheorem "}
{"text": "If a topological space is compact, then every subset is compact.", "fullPrompt": "/-- A closed subset of a compact set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) : is_compact t :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem {α : Type u} [topological_space α] [locally_compact_space α] {K : set α} (hK : is_compact K) : ∃ (K' : set α), is_compact K' ∧ K ⊆ interior K' :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) : is_compact (s ∩ t) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s) : is_compact (s ∩ t) :=\n\n/-- In a `t2_space`, every compact set is closed. -/\ntheorem {α : Type u} [topological_space α] [t2_space α] {s : set α} (hs : is_compact s) : is_closed s :=\n\n/-- In a locally compact T₂ space, every point has an open neighborhood with compact closure -/\ntheorem {α : Type u} [topological_space α] [locally_compact_space α] [t2_space α] (x : α) : ∃ (U : set α), is_open U ∧ x ∈ U ∧ is_compact (closure U) :=\n\n/--  Every separated topological group in which there exists a compact set with nonempty interior is locally compact. -/\ntheorem {G : Type w} [topological_space G] [group G] [topological_group G] [t2_space G] (K : topological_space.positive_compacts G) : locally_compact_space G :=\n\n/-- A compact set is bounded above -/\ntheorem {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] [nonempty α] {s : set α} (hs : is_compact s) : bdd_above s :=\n\n/-- An unordered closed interval is compact. -/\ntheorem {α : Type u_1} [linear_order α] [topological_space α] [compact_Icc_space α] {a b : α} : is_compact (set.interval a b) :=\n\n/-- Subsets of a bounded set are also bounded -/\ntheorem {α : Type u} [pseudo_metric_space α] {s t : set α} (incl : s ⊆ t) : metric.bounded t → metric.bounded s :=\n\n/-- A locally compact Hausdorff space is totally disconnected  if and only if it is totally separated. -/\ntheorem {H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] : totally_disconnected_space H ↔ totally_separated_space H :=\n\n/-- A locally compact Hausdorff totally disconnected space has a basis with clopen elements. -/\ntheorem {H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] [totally_disconnected_space H] : topological_space.is_topological_basis {s : set H | is_clopen s} :=\n\n/-- The span of a finite subset is compact in the lattice of submodules. -/\ntheorem {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (S : finset M) : complete_lattice.is_compact_element (submodule.span R ↑S) :=\n\n/-- The span of a finite subset is compact in the lattice of submodules. -/\ntheorem {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (S : set M) (h : S.finite) : complete_lattice.is_compact_element (submodule.span R S) :=\n\n/-- If a topological space is compact, then every subset is compact. -/\ntheorem "}
{"text": "Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.", "fullPrompt": "/-- The set of Liouville numbers has Lebesgue measure zero. -/\ntheorem  : ⇑measure_theory.measure_space.volume {x : ℝ | liouville x} = 0 :=\n\n/-- Every set has a measurable superset. Declare this as local instance as needed. -/\ntheorem {α : Type u_1} {m : measurable_space α} (s : set α) : nonempty {t // s ⊆ t ∧ measurable_set t} :=\n\n/--  The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue measure zero. -/\ntheorem  : ⇑measure_theory.measure_space.volume (⋃ (p : ℝ) (hp : 2 < p), {x : ℝ | liouville_with p x}) = 0 :=\n\n/-- The empty set has zero diameter -/\ntheorem {α : Type u} [pseudo_metric_space α] : metric.diam ∅ = 0 :=\n\n/-- In a Polish space, a set is clopenable if and only if it is Borel-measurable. -/\ntheorem {γ : Type u_3} [tγ : topological_space γ] [polish_space γ] [measurable_space γ] [borel_space γ] {s : set γ} : polish_space.is_clopenable s ↔ measurable_set s :=\n\n/-- A strongly measurable function is measurable. -/\ntheorem {α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] [topological_space.pseudo_metrizable_space β] [measurable_space β] [borel_space β] (hf : measure_theory.strongly_measurable f) : measurable f :=\n\n/-- The diameter of the empty set vanishes -/\ntheorem {α : Type u} [pseudo_emetric_space α] : emetric.diam ∅ = 0 :=\n\n/-- A sequential limit of measurable `ℝ≥0` valued functions is measurable. -/\ntheorem {α : Type u_1} [measurable_space α] {f : ℕ → α → nnreal} {g : α → nnreal} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g :=\n\n/-- The range of a strongly measurable function is separable. -/\ntheorem {α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] (hf : measure_theory.strongly_measurable f) : topological_space.is_separable (set.range f) :=\n\n/-- A sequential limit of measurable `ℝ≥0∞` valued functions is measurable. -/\ntheorem {α : Type u_1} [measurable_space α] {f : ℕ → α → ennreal} {g : α → ennreal} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g :=\n\n/-- The diameter of a set is always nonnegative -/\ntheorem {α : Type u} [pseudo_metric_space α] {s : set α} : 0 ≤ metric.diam s :=\n\n/-- The product of the constant function `0` over any set equals `0`. -/\ntheorem {α : Type u_1} {M : Type u_5} [add_comm_monoid M] (s : set α) : finsum (λ (i : α), finsum (λ (H : i ∈ s), 0)) = 0 :=\n\n/-- A transvection preserves Lebesgue measure. -/\ntheorem {ι : Type u_1} [fintype ι] [decidable_eq ι] (t : matrix.transvection_struct ι ℝ) : measure_theory.measure_preserving ⇑(⇑matrix.to_lin' t.to_matrix) measure_theory.measure_space.volume measure_theory.measure_space.volume :=\n\n/-- In the space `ι → ℝ`, Hausdorff measure coincides exactly with Lebesgue measure. -/\ntheorem {ι : Type u_1} [fintype ι] : measure_theory.measure.hausdorff_measure ↑(fintype.card ι) = measure_theory.measure_space.volume :=\n\n/-- The Haar measure equals the Lebesgue measure on `ℝ^ι`. -/\ntheorem (ι : Type u_1) [fintype ι] : measure_theory.measure.add_haar_measure (topological_space.positive_compacts.pi_Icc01 ι) = measure_theory.measure_space.volume :=\n\n/--  A useful consequence of the Lebesgue number lemma: given any compact set `K` contained in an open set `U`, we can find an (open) entourage `V` such that the ball of size `V` about any point of `K` is contained in `U`. -/\ntheorem {α : Type u_1} [uniform_space α] {K U : set α} (hK : is_compact K) (hU : is_open U) (hKU : K ⊆ U) : ∃ (V : set (α × α)) (H : V ∈ uniformity α), is_open V ∧ ∀ (x : α), x ∈ K → uniform_space.ball x V ⊆ U :=\n\n/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)  Tonelli's theorem is measurable.  This version has the argument `f` in curried form. -/\ntheorem {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] {f : α → β → ennreal} (hf : measurable (function.uncurry f)) : measurable (λ (x : α), ∫⁻ (y : β), f x y ∂ν) :=\n\n/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)  Tonelli's theorem is measurable. -/\ntheorem {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] {f : α × β → ennreal} (hf : measurable f) : measurable (λ (x : α), ∫⁻ (y : β), f (x, y) ∂ν) :=\n\n/--  The **Heine–Borel theorem**: In a proper Hausdorff space, a set is compact if and only if it is closed and bounded. -/\ntheorem {α : Type u} [pseudo_metric_space α] {s : set α} [t2_space α] [proper_space α] : is_compact s ↔ is_closed s ∧ metric.bounded s :=\n\n/-- The **Heine–Borel theorem**: In a proper space, the closure of a bounded set is compact. -/\ntheorem {α : Type u} [pseudo_metric_space α] {s : set α} [proper_space α] (h : metric.bounded s) : is_compact (closure s) :=\n\n/-- The **Heine–Borel theorem**: In a proper space, a closed bounded set is compact. -/\ntheorem {α : Type u} [pseudo_metric_space α] {s : set α} [proper_space α] (hc : is_closed s) (hb : metric.bounded s) : is_compact s :=\n\n/--  The hard part of the Lusin separation theorem saying that two disjoint analytic sets are contained in disjoint Borel sets (see the full statement in `analytic_set.measurably_separable`). Here, we prove this when our analytic sets are the ranges of functions from `ℕ → ℕ`. -/\ntheorem {α : Type u_1} [topological_space α] [t2_space α] [measurable_space α] [borel_space α] {f g : (ℕ → ℕ) → α} (hf : continuous f) (hg : continuous g) (h : disjoint (set.range f) (set.range g)) : measure_theory.measurably_separable (set.range f) (set.range g) :=\n\n/-- Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero. -/\ntheorem "}
{"text": "A finitely-presented group containing a torsion element is finite.", "fullPrompt": "/-- Finite groups are torsion groups. -/\ntheorem {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G → ¬monoid.is_torsion_free G :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G → ¬monoid.is_torsion G :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem {G : Type u_3} [group G] : group.fg G ↔ monoid.fg G :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i) :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem (G : Type u_1) [monoid G] : ¬monoid.is_torsion_free G ↔ ∃ (g : G), g ≠ 1 ∧ is_of_fin_order g :=\n\n/-- A finitely presented algebra is of finite type. -/\ntheorem {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_presentation R A → algebra.finite_type R A :=\n\n/-- A group `G` is finitely generated if and only if `add_monoid_algebra R G` is of finite type. -/\ntheorem {R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) ↔ group.fg G :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x :=\n\n/--  An algebra over a Noetherian ring is finitely generated if and only if it is finitely presented. -/\ntheorem {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] [is_noetherian_ring R] : algebra.finite_type R A ↔ algebra.finite_presentation R A :=\n\n/-- If a direct product has finite order then so does each component. -/\ntheorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_order x) (i : η) : is_of_fin_order (x i) :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ↔ is_of_fin_add_order x :=\n\n/-- A finitely-presented group containing a torsion element is finite. -/\ntheorem "}
{"text": "If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.", "fullPrompt": "/-- A closed subset of a compact set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) : is_compact t :=\n\n/-- A set is sequentially closed if it is closed. -/\ntheorem {X : Type u_1} [topological_space X] {s : set X} (hs : is_closed s) : is_seq_closed s :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) : is_compact (s ∩ t) :=\n\n/-- In a sequential space, a set is closed iff it's sequentially closed. -/\ntheorem {X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s ↔ is_closed s :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s) : is_compact (s ∩ t) :=\n\n/-- The frontier of a closed set has no interior point. -/\ntheorem {α : Type u} [topological_space α] {s : set α} (h : is_closed s) : interior (frontier s) = ∅ :=\n\n/-- The frontier of a set is closed. -/\ntheorem {α : Type u} [topological_space α] {s : set α} : is_closed (frontier s) :=\n\n/-- The edistance to a closed set depends continuously on the point and the set -/\ntheorem {α : Type u} [emetric_space α] : continuous (λ (p : α × topological_space.closeds α), emetric.inf_edist p.fst ↑(p.snd)) :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem {α : Type u} [topological_space α] [locally_compact_space α] {K : set α} (hK : is_compact K) : ∃ (K' : set α), is_compact K' ∧ K ⊆ interior K' :=\n\n/-- The minimal distance of a point to a set containing it vanishes -/\ntheorem {α : Type u} [pseudo_metric_space α] {s : set α} {x : α} (h : x ∈ s) : metric.inf_dist x s = 0 :=\n\n/-- The minimal distance to a set is continuous in point -/\ntheorem {α : Type u} [pseudo_metric_space α] (s : set α) : continuous (λ (x : α), metric.inf_dist x s) :=\n\n/-- In a `t2_space`, every compact set is closed. -/\ntheorem {α : Type u} [topological_space α] [t2_space α] {s : set α} (hs : is_compact s) : is_closed s :=\n\n/-- Every member of an open set in a compact Hausdorff totally disconnected space  is contained in a clopen set contained in the open set. -/\ntheorem {α : Type u} [topological_space α] [t2_space α] [compact_space α] [totally_disconnected_space α] {x : α} {U : set α} (is_open : _root_.is_open U) (memU : x ∈ U) : ∃ (V : set α) (hV : is_clopen V), x ∈ V ∧ V ⊆ U :=\n\n/-- If every point of a subset of a topological space is contained in some closed set, the subset itself is closed. -/\ntheorem "}
{"text": "A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X × X$.", "fullPrompt": "/-- The second projection in a product of topological spaces sends open sets to open sets. -/\ntheorem {α : Type u} {β : Type v} [topological_space α] [topological_space β] : is_open_map prod.snd :=\n\n/-- The first projection in a product of topological spaces sends open sets to open sets. -/\ntheorem {α : Type u} {β : Type v} [topological_space α] [topological_space β] : is_open_map prod.fst :=\n\n/-- The Hausdorff distance between a set and itself is zero -/\ntheorem {α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist s s = 0 :=\n\n/-- The Hausdorff distance satisfies the triangular inequality -/\ntheorem {α : Type u} [pseudo_emetric_space α] {s t u : set α} : emetric.Hausdorff_edist s u ≤ emetric.Hausdorff_edist s t + emetric.Hausdorff_edist t u :=\n\n/-- The distance to a set is controlled by the Hausdorff distance -/\ntheorem {α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} (h : x ∈ s) : emetric.inf_edist x t ≤ emetric.Hausdorff_edist s t :=\n\n/-- An inducing map with an open range is an open map. -/\ntheorem {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (hi : inducing f) (ho : is_open (set.range f)) : is_open_map f :=\n\n/-- The Hausdorff edistance of a set to itself vanishes -/\ntheorem {α : Type u} [pseudo_emetric_space α] {s : set α} : emetric.Hausdorff_edist s s = 0 :=\n\n/-- If X is is_compact then pr₂ : X × Y → Y is a closed map -/\ntheorem {X : Type u_1} [topological_space X] [compact_space X] {Y : Type u_2} [topological_space Y] : is_closed_map prod.snd :=\n\n/-- The Hausdorff distance is nonnegative -/\ntheorem {α : Type u} [pseudo_metric_space α] {s t : set α} : 0 ≤ metric.Hausdorff_dist s t :=\n\n/-- The Hausdorff distance from `s` to `t` and from `t` to `s` coincide -/\ntheorem {α : Type u} [pseudo_metric_space α] {s t : set α} : metric.Hausdorff_dist s t = metric.Hausdorff_dist t s :=\n\n/-- A Hausdorff space with a clopen basis is totally separated. -/\ntheorem {α : Type u} [topological_space α] [t2_space α] (h : topological_space.is_topological_basis {s : set α | is_clopen s}) : totally_separated_space α :=\n\n/--  Given an inducing map of a topological space into a pseudo metrizable space, the source space is also pseudo metrizable. -/\ntheorem {X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.pseudo_metrizable_space Y] {f : X → Y} (hf : inducing f) : topological_space.pseudo_metrizable_space X :=\n\n/-- The projection on the base of a topological bundle created from core is an open map -/\ntheorem {ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : is_open_map Z.proj :=\n\n/-- The projection from a topological fiber bundle to its base is an open map. -/\ntheorem {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : is_open_map proj :=\n\n/--  The diagonal map from the total space of the fibrewise product of two topological vector bundles `E₁`, `E₂` into `total_space E₁ × total_space E₂` is `inducing`. -/\ntheorem {B : Type u_3} (E₁ : B → Type u_6) (E₂ : B → Type u_7) [topological_space (bundle.total_space E₁)] [topological_space (bundle.total_space E₂)] : inducing (λ (p : bundle.total_space (λ (x : B), E₁ x × E₂ x)), (⟨p.fst, p.snd.fst⟩, ⟨p.fst, p.snd.snd⟩)) :=\n\n/--  In a normed ring, the coercion from `Rˣ` (equipped with the induced topology from the embedding in `R × R`) to `R` is an open map. -/\ntheorem {R : Type u_1} [normed_ring R] [complete_space R] : is_open_map coe :=\n\n/-- If `f` is an affine map, then its linear part is an open map iff `f` is an open map. -/\ntheorem {𝕜 : Type u_1} {V : Type u_2} {V₂ : Type u_4} {P : Type u_8} {P₂ : Type u_9} [normed_field 𝕜] [semi_normed_group V] [semi_normed_group V₂] [normed_space 𝕜 V] [normed_space 𝕜 V₂] [pseudo_metric_space P] [pseudo_metric_space P₂] [normed_add_torsor V P] [normed_add_torsor V₂ P₂] {f : P →ᵃ[𝕜] P₂} : is_open_map ⇑(f.linear) ↔ is_open_map ⇑f :=\n\n/-- The projection on the base of a topological vector bundle created from core is an open map -/\ntheorem {R : Type u_1} {B : Type u_3} {F : Type u_4} [nondiscrete_normed_field R] [normed_group F] [normed_space R F] [topological_space B] {ι : Type u_6} (Z : topological_vector_bundle_core R B F ι) : is_open_map Z.proj :=\n\n/-- If a function has a non-zero strict derivative at all points, then it is an open map. -/\ntheorem {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] [complete_space 𝕜] {f f' : 𝕜 → 𝕜} (hf : ∀ (x : 𝕜), has_strict_deriv_at f (f' x) x) (h0 : ∀ (x : 𝕜), f' x ≠ 0) : is_open_map f :=\n\n/-- A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X × X$. -/\ntheorem "}
{"text": "Any finite order element in a group is equal to the identity.", "fullPrompt": "/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem {G : Type u} [group G] {x : G} : is_of_fin_order x⁻¹ ↔ is_of_fin_order x :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ↔ is_of_fin_add_order x :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem {G : Type u} [add_group G] {x : G} : is_of_fin_add_order (-x) ↔ is_of_fin_add_order x :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem {G : Type u} [add_group G] {x : G} (hx : is_of_fin_add_order x) : is_of_fin_add_order (-x) :=\n\n/-- Elements of finite additive order are closed under addition. -/\ntheorem {G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y) :=\n\n/-- The identity is a group homomorphism. -/\ntheorem {α : Type u} [group α] : is_group_hom id :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_cyclic α :=\n\n/-- Commuting elements of finite additive order are closed under addition. -/\ntheorem {G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y) :=\n\n/--  For every prime `p` dividing the order of a finite group `G` there exists an element of order `p` in `G`. This is known as Cauchy's theorem. -/\ntheorem {G : Type u_1} [group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G) : ∃ (x : G), order_of x = p :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem (G : Type u_1) [monoid G] : ¬monoid.is_torsion_free G ↔ ∃ (g : G), g ≠ 1 ∧ is_of_fin_order g :=\n\n/-- 0 is of finite order in any additive monoid. -/\ntheorem {G : Type u} [add_monoid G] : is_of_fin_add_order 0 :=\n\n/-- Elements of finite order are of finite order in submonoids. -/\ntheorem {G : Type u} [monoid G] (H : submonoid G) (x : ↥H) : is_of_fin_order x ↔ is_of_fin_order ↑x :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem {G : Type u} [group G] {x : G} (hx : is_of_fin_order x) : is_of_fin_order x⁻¹ :=\n\n/-- Any finite order element in a group is equal to the identity. -/\ntheorem "}
{"text": "If a subgroup of a group is torsion-free, then the group itself is torsion free.", "fullPrompt": "/-- A nontrivial torsion group is not torsion-free. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G → ¬monoid.is_torsion_free G :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G → ¬monoid.is_torsion G :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i) :=\n\n/-- Finite groups are torsion groups. -/\ntheorem {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem (G : Type u_1) [monoid G] : ¬monoid.is_torsion_free G ↔ ∃ (g : G), g ≠ 1 ∧ is_of_fin_order g :=\n\n/-- A monoid is not a torsion monoid if it has an element of infinite order. -/\ntheorem (G : Type u_1) [monoid G] : ¬monoid.is_torsion G ↔ ∃ (g : G), ¬is_of_fin_order g :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem {G : Type u_3} [group G] : group.fg G ↔ monoid.fg G :=\n\n/-- A p-group is nilpotent -/\ntheorem {G : Type u_1} [hG : group G] [hf : fintype G] {p : ℕ} [hp : fact (nat.prime p)] (h : is_p_group p G) : group.is_nilpotent G :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 1 → a = 1 :=\n\n/-- A group `G` is finitely generated if and only if `add_monoid_algebra R G` is of finite type. -/\ntheorem {R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) ↔ group.fg G :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ↔ is_of_fin_add_order x :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x :=\n\n/-- Direct products of additive torsion free groups are torsion free. -/\ntheorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_group (Gs i)] (tfGs : ∀ (i : η), add_monoid.is_torsion_free (Gs i)) : add_monoid.is_torsion_free (Π (i : η), Gs i) :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem (G : Type u_1) [add_comm_group G] : add_monoid.is_torsion_free (G ⧸ add_torsion G) :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem (G : Type u_1) [comm_group G] : monoid.is_torsion_free (G ⧸ torsion G) :=\n\n/-- If a subgroup of a group is torsion-free, then the group itself is torsion free. -/\ntheorem "}
{"text": "Every injective homomorphism from a finitely generated free group to itself is surjective.", "fullPrompt": "/-- The canonical injection from the type to the free group is an injection. -/\ntheorem {α : Type u} : function.injective free_group.of :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 1 → a = 1 :=\n\n/-- An additive group homomorphism is injective if its kernel is trivial. -/\ntheorem {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 0 → a = 0 :=\n\n/-- Given a map f from α to β, the natural map from the quotient of α by the kernel of f is    injective. -/\ntheorem {α : Type u_1} {β : Type u_2} (f : α → β) : function.injective (quotient.lift f _) :=\n\n/--  If two words correspond to the same element in the free group, then they have a common maximal reduction. This is the proof that the function that sends an element of the free group to its maximal reduction is well-defined. -/\ntheorem {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.mk L₁ = free_group.mk L₂) : free_group.reduce L₁ = free_group.reduce L₂ :=\n\n/-- A group homomorphism sends 1 to 1. -/\ntheorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : f 1 = 1 :=\n\n/--  Adding a group element to the point `p` is an injective function. -/\ntheorem {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (λ (_x : G), _x +ᵥ p) :=\n\n/--  A word and its maximal reduction correspond to the same element of the free group. -/\ntheorem {α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.mk (free_group.reduce L) = free_group.mk L :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : is_monoid_hom f :=\n\n/-- A free module with a basis indexed by a `fintype` is finite. -/\ntheorem {R : Type u_1} {M : Type u_2} {ι : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [fintype ι] (b : basis ι R M) : module.finite R M :=\n\n/--  If two words have a common maximal reduction, then they correspond to the same element in the free group. -/\ntheorem {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.reduce L₁ = free_group.reduce L₂) : free_group.mk L₁ = free_group.mk L₂ :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i) :=\n\n/-- An `add_monoid` homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. -/\ntheorem {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] (f : M →+ P) : function.injective ⇑(add_con.ker_lift f) :=\n\n/-- A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. -/\ntheorem {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] (f : M →* P) : function.injective ⇑(con.ker_lift f) :=\n\n/-- Every injective homomorphism from a finitely generated free group to itself is surjective. -/\ntheorem "}
{"text": "Every division ring is either a field or finite.", "fullPrompt": "/-- A division_ring is one-dimensional as a vector space over itself. -/\ntheorem (K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1 :=\n\n/-- A module over a division ring is noetherian if and only if it is finitely generated. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V ↔ module.finite K V :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem (R : Type u) [non_assoc_ring R] (p : ℕ) [hc : char_p R p] [fintype R] : p ≠ 0 :=\n\n/--  A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p :=\n\n/--  A prime `p` is a unit in a finite commutative ring `R` iff it does not divide the characteristic. -/\ntheorem (R : Type u_1) [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : is_unit ↑p ↔ ¬p ∣ ring_char R :=\n\n/-- A field extension is integral if it is finite. -/\ntheorem (K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite_dimensional K L] : algebra.is_integral K L :=\n\n/--  An algebra over a Noetherian ring is finitely generated if and only if it is finitely presented. -/\ntheorem {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] [is_noetherian_ring R] : algebra.finite_type R A ↔ algebra.finite_presentation R A :=\n\n/-- `polynomial R` is never a field for any ring `R`. -/\ntheorem {R : Type u} [ring R] : ¬is_field (polynomial R) :=\n\n/-- If an element a divides another element b in a commutative ring, a divides the sum of b and  another element c iff a divides c. -/\ntheorem {α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ b) : a ∣ b + c ↔ a ∣ c :=\n\n/-- A field extension is algebraic if it is finite. -/\ntheorem (K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite : finite_dimensional K L] : algebra.is_algebraic K L :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- `R` is finitely presented as `R`-algebra. -/\ntheorem (R : Type u_1) [comm_ring R] : algebra.finite_presentation R R :=\n\n/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem {Γ₀ : Type u_3} [linear_ordered_comm_monoid_with_zero Γ₀] [nontrivial Γ₀] {K : Type u_1} [division_ring K] (v : valuation K Γ₀) {x : K} : ⇑v x = 0 ↔ x = 0 :=\n\n/--  In a noetherian module over a division ring, if a basis is indexed by a set, that set is finite. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type u_1} {s : set ι} [is_noetherian K V] (b : basis ↥s K V) : s.finite :=\n\n/--  Over a characteristic-zero division ring, the centroids of two faces of a simplex are equal if and only if those faces are given by the same subset of points. -/\ntheorem {k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [char_zero k] {n : ℕ} (s : affine.simplex k P n) {fs₁ fs₂ : finset (fin (n + 1))} {m₁ m₂ : ℕ} (h₁ : fs₁.card = m₁ + 1) (h₂ : fs₂.card = m₂ + 1) : finset.centroid k finset.univ (s.face h₁).points = finset.centroid k finset.univ (s.face h₂).points ↔ fs₁ = fs₂ :=\n\n/--  The dimension of a noetherian module over a division ring, as a cardinal, is strictly less than the first infinite cardinal `ℵ₀`. -/\ntheorem (K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [is_noetherian K V] : module.rank K V < cardinal.aleph_0 :=\n\n/--  Over a characteristic-zero division ring, the centroids given by two subsets of the points of a simplex are equal if and only if those faces are given by the same subset of points. -/\ntheorem {k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [char_zero k] {n : ℕ} (s : affine.simplex k P n) {fs₁ fs₂ : finset (fin (n + 1))} {m₁ m₂ : ℕ} (h₁ : fs₁.card = m₁ + 1) (h₂ : fs₂.card = m₂ + 1) : finset.centroid k fs₁ s.points = finset.centroid k fs₂ s.points ↔ fs₁ = fs₂ :=\n\n/-- Every division ring is either a field or finite. -/\ntheorem "}
{"text": "Every natural number is the product of two primes.", "fullPrompt": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem  : set.inj_on nat.factorization {x : ℕ | x ≠ 0} :=\n\n/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- Two natural numbers are equal if and only if the have the same divisors. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime dividing it. -/\ntheorem {n : ℕ} : is_prime_pow n ↔ ∃! (p : ℕ), nat.prime p ∧ p ∣ n :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a natural `k` such that `n` can be written as `p^(k+1)`. -/\ntheorem {R : Type u_1} [comm_monoid_with_zero R] (n : R) : is_prime_pow n ↔ ∃ (p : R) (k : ℕ), prime p ∧ p ^ (k + 1) = n :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- If the factorization of `n` contains just one number `p` then `n` is a power of `p` -/\ntheorem {n p k : ℕ} (hn : n ≠ 0) (h : n.factorization = finsupp.single p k) : n = p ^ k :=\n\n/-- The prime factorizations of coprime `a` and `b` are disjoint -/\ntheorem {a b : ℕ} (hab : a.coprime b) : disjoint a.factorization.support b.factorization.support :=\n\n/-- Prime `p` divides the product of a list `L` iff it divides some `a ∈ L` -/\ntheorem {M : Type u_1} [comm_monoid_with_zero M] {p : M} {L : list M} (pp : prime p) : p ∣ L.prod ↔ ∃ (a : M) (H : a ∈ L), p ∣ a :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`. -/\ntheorem (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p :=\n\n/--  Euclid's lemma: if `a ∣ b * c` and `gcd a b = 1` then `a ∣ c`. Compare with `is_coprime.dvd_of_dvd_mul_right` and `unique_factorization_monoid.dvd_of_dvd_mul_right_of_no_prime_factors` -/\ntheorem {a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd b = 1) : a ∣ c :=\n\n/-- A version of `nat.exists_infinite_primes` using the `bdd_above` predicate. -/\ntheorem  : ¬bdd_above {p : ℕ | nat.prime p} :=\n\n/-- A version of `nat.exists_infinite_primes` using the `set.infinite` predicate. -/\ntheorem  : {p : ℕ | nat.prime p}.infinite :=\n\n/-- For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. -/\ntheorem {k : ℕ} (n : ℕ) (hpos : 0 < k) : ∃ (p : ℕ), nat.prime p ∧ n ≤ p ∧ p ≡ 1 [MOD k] :=\n\n/-- If we start with a multiset of primes, take the product and then factor it, we get back the original multiset. -/\ntheorem (v : prime_multiset) : v.prod.factor_multiset = v :=\n\n/-- Every natural number is the product of two primes. -/\ntheorem "}
{"text": "Every even number is the square of a natural number.", "fullPrompt": "/--  If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive. -/\ntheorem {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0 :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) : ∃ (a : F), ¬is_square a :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n\n/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- Two natural numbers are equal if and only if the have the same divisors. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem {α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0 :=\n\n/-- Note that most of the lemmas about powers of two refer to it as `sq`. -/\ntheorem {M : Type u} [monoid M] (a : M) : a ^ 2 = a * a :=\n\n/-- There are no perfect squares strictly between m² and (m+1)² -/\ntheorem {n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬∃ (t : ℕ), t * t = n :=\n\n/-- `0` is always a square (in a monoid with zero). -/\ntheorem (M : Type u_1) [monoid_with_zero M] : is_square 0 :=\n\n/-- Natural division is always less than division in the field. -/\ntheorem {α : Type u_1} [linear_ordered_field α] {m n : ℕ} : ↑(m / n) ≤ ↑m / ↑n :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- **Alias** of the reverse direction of is_square_iff_exists_sq`. -/\ntheorem {α : Type u_2} [monoid α] (m : α) : (∃ (c : α), m = c ^ 2) → is_square m :=\n\n/-- Every even number is the square of a natural number. -/\ntheorem "}
{"text": "Every normal subgroup of a group has finite index.", "fullPrompt": "/-- The normal closure of a set is a subgroup. -/\ntheorem {G : Type u_1} [group G] (s : set G) : is_subgroup (group.normal_closure s) :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem {G : Type u_1} {s : set G} [group G] : is_normal_subgroup (group.normal_closure s) :=\n\n/-- The normal closure of s is the smallest normal subgroup containing s. -/\ntheorem {G : Type u_1} [group G] {s t : set G} (ht : is_normal_subgroup t) (h : s ⊆ t) : group.normal_closure s ⊆ t :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x :=\n\n/-- Any ascending central series for a group is bounded above by the upper central series. -/\ntheorem {G : Type u_1} [group G] (H : ℕ → subgroup G) (hH : is_ascending_central_series H) (n : ℕ) : H n ≤ upper_central_series G n :=\n\n/-- Any descending central series for a group is bounded below by the lower central series. -/\ntheorem {G : Type u_1} [group G] (H : ℕ → subgroup G) (hH : is_descending_central_series H) (n : ℕ) : lower_central_series G n ≤ H n :=\n\n/-- The upper central series of a group is an ascending central series. -/\ntheorem (G : Type u_1) [group G] : is_ascending_central_series (upper_central_series G) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_simple_group α :=\n\n/-- The lower central series of a group is a descending central series. -/\ntheorem {G : Type u_1} [group G] : is_descending_central_series (lower_central_series G) :=\n\n/-- A p-group is nilpotent -/\ntheorem {G : Type u_1} [hG : group G] [hf : fintype G] {p : ℕ} [hp : fact (nat.prime p)] (h : is_p_group p G) : group.is_nilpotent G :=\n\n/-- If a subgroup of a topological group has `1` in its interior, then it is open. -/\ntheorem {G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 ∈ interior ↑H) : is_open ↑H :=\n\n/-- If a direct product has finite order then so does each component. -/\ntheorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_order x) (i : η) : is_of_fin_order (x i) :=\n\n/-- For finite index types, the `subgroup.pi` is generated by the embeddings of the groups. -/\ntheorem {η : Type u_5} {f : η → Type u_6} [Π (i : η), group (f i)] [decidable_eq η] [fintype η] {H : Π (i : η), subgroup (f i)} {J : subgroup (Π (i : η), f i)} : subgroup.pi set.univ H ≤ J ↔ ∀ (i : η), subgroup.map (monoid_hom.single f i) (H i) ≤ J :=\n\n/-- For finite index types, the `subgroup.pi` is generated by the embeddings of the additive groups. -/\ntheorem {η : Type u_5} {f : η → Type u_6} [Π (i : η), add_group (f i)] [decidable_eq η] [fintype η] {H : Π (i : η), add_subgroup (f i)} {J : add_subgroup (Π (i : η), f i)} : add_subgroup.pi set.univ H ≤ J ↔ ∀ (i : η), add_subgroup.map (add_monoid_hom.single f i) (H i) ≤ J :=\n\n/-- **Schreier's Lemma**: A finite index subgroup of a finitely generated  group is finitely generated. -/\ntheorem {G : Type u_1} [group G] {H : subgroup G} [hG : group.fg G] (hH : H.index ≠ 0) : group.fg ↥H :=\n\n/-- Frattini's Argument: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup  of `N`, then `N_G(P) ⊔ N = G`. -/\ntheorem {G : Type u_1} [group G] {p : ℕ} [fact (nat.prime p)] {N : subgroup G} [N.normal] [fintype (sylow p ↥N)] (P : sylow p ↥N) : (subgroup.map N.subtype ↑P).normalizer ⊔ N = ⊤ :=\n\n/-- The normal closure of `s` is the smallest normal subgroup containing `s`. -/\ntheorem {G : Type u_1} [group G] {s : set G} {N : subgroup G} [N.normal] (h : s ⊆ ↑N) : subgroup.normal_closure s ≤ N :=\n\n/-- Every normal subgroup of a group has finite index. -/\ntheorem "}
{"text": "The characteristic polynomial of every matrix has real roots.", "fullPrompt": "/-- The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a matrix, applied to the matrix itself, is zero.  This holds over any commutative ring.  See `linear_map.aeval_self_charpoly` for the equivalent statement about endomorphisms. -/\ntheorem {R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : ⇑(polynomial.aeval M) M.charpoly = 0 :=\n\n/-- Characteristic `≠ 2` and nontrivial implies that `-1 ≠ 1`. -/\ntheorem {R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R ≠ 2) : -1 ≠ 1 :=\n\n/-- The exponential characteristic is one iff the characteristic is zero. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] (p q : ℕ) [char_p R p] [exp_char R q] : q = 1 ↔ p = 0 :=\n\n/-- Determinant of 0x0 matrix -/\ntheorem {R : Type v} [comm_ring R] {A : matrix (fin 0) (fin 0) R} : A.det = 1 :=\n\n/-- The exponential characteristic is one if the characteristic is zero. -/\ntheorem (R : Type u) [semiring R] (q : ℕ) [hp : char_p R 0] [hq : exp_char R q] : q = 1 :=\n\n/-- The exponential characteristic is one if the characteristic is zero. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] (p : ℕ) [hp : char_p R p] [hq : exp_char R 1] : p = 0 :=\n\n/-- The characteristic equals the exponential characteristic iff the former is prime. -/\ntheorem (R : Type u) [semiring R] (p q : ℕ) [hp : char_p R p] [hq : exp_char R q] : p = q ↔ nat.prime p :=\n\n/-- A helper lemma: the characteristic is prime if it is non-zero. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] {p : ℕ} [hp : char_p R p] (p_ne_zero : p ≠ 0) : nat.prime p :=\n\n/--  The characteristic polynomial of the map `λ x, a * x` is the minimal polynomial of `a`.  In combination with `det_eq_sign_charpoly_coeff` or `trace_eq_neg_charpoly_coeff` and a bit of rewriting, this will allow us to conclude the field norm resp. trace of `x` is the product resp. sum of `x`'s conjugates. -/\ntheorem {K : Type u_1} {S : Type u_2} [field K] [comm_ring S] [algebra K S] (h : power_basis K S) : (⇑(algebra.left_mul_matrix h.basis) h.gen).charpoly = minpoly K h.gen :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : ℕ) [hq : exp_char R q] : nat.prime q ∨ q = 1 :=\n\n/-- If `R` has characteristic `0`, then so does Frac(R). -/\ntheorem (R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [char_zero R] : char_zero K :=\n\n/-- Transposing a matrix preserves the determinant. -/\ntheorem {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : M.transpose.det = M.det :=\n\n/-- The number of complex roots equals the number of real roots plus    the number of roots not fixed by complex conjugation (i.e. with some imaginary component). -/\ntheorem (p : polynomial ℚ) : (p.root_set ℂ).to_finset.card = (p.root_set ℝ).to_finset.card + (⇑(polynomial.gal.gal_action_hom p ℂ) (⇑(polynomial.gal.restrict p ℂ) (alg_equiv.restrict_scalars ℚ complex.conj_ae))).support.card :=\n\n/-- The geometric sequence `q^n` is a solution of `E` iff  `q` is a root of `E`'s characteristic polynomial. -/\ntheorem {α : Type u_1} [comm_ring α] (E : linear_recurrence α) (q : α) : E.is_solution (λ (n : ℕ), q ^ n) ↔ E.char_poly.is_root q :=\n\n/--  The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a linear map, applied to the linear map itself, is zero.  See `matrix.aeval_self_charpoly` for the equivalent statement about matrices. -/\ntheorem {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M →ₗ[R] M) : ⇑(polynomial.aeval f) f.charpoly = 0 :=\n\n/-- `charpoly f` is the characteristic polynomial of the matrix of `f` in any basis. -/\ntheorem {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M →ₗ[R] M) {ι : Type w} [fintype ι] (b : basis ι R M) : (⇑(linear_map.to_matrix b b) f).charpoly = f.charpoly :=\n\n/-- The characteristic polynomial of every matrix has real roots. -/\ntheorem "}
{"text": "In a commutative ring, every prime ideal is contained in a unique maximal ideal.", "fullPrompt": "/--  A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p :=\n\n/--  A prime `p` is a unit in a finite commutative ring `R` iff it does not divide the characteristic. -/\ntheorem (R : Type u_1) [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : is_unit ↑p ↔ ¬p ∣ ring_char R :=\n\n/--  The prime divisors of the characteristic of a finite commutative ring are exactly the prime divisors of its cardinality. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : p ∣ ring_char R ↔ p ∣ fintype.card R :=\n\n/-- The variable of the power series ring over an integral domain is prime. -/\ntheorem {R : Type u_1} [comm_ring R] [is_domain R] : prime power_series.X :=\n\n/-- A minimal polynomial is prime. -/\ntheorem {A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) : prime (minpoly A x) :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem  : set.inj_on nat.factorization {x : ℕ | x ≠ 0} :=\n\n/-- Hilbert basis theorem: a polynomial ring over a noetherian ring is a noetherian ring. -/\ntheorem {R : Type u} [comm_ring R] [is_noetherian_ring R] : is_noetherian_ring (polynomial R) :=\n\n/-- A localization always has cardinality less than or equal to the base ring. -/\ntheorem {R : Type u} [comm_ring R] (S : submonoid R) {L : Type u} [comm_ring L] [algebra R L] [is_localization S L] : cardinal.mk L ≤ cardinal.mk R :=\n\n/-- An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a discrete valuation ring. -/\ntheorem {R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) : discrete_valuation_ring R :=\n\n/--  An algebra over a Noetherian ring is finitely generated if and only if it is finitely presented. -/\ntheorem {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] [is_noetherian_ring R] : algebra.finite_type R A ↔ algebra.finite_presentation R A :=\n\n/-- If an element a divides another element b in a commutative ring, a divides the sum of b and  another element c iff a divides c. -/\ntheorem {α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ b) : a ∣ b + c ↔ a ∣ c :=\n\n/-- A helper lemma: the characteristic is prime if it is non-zero. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] {p : ℕ} [hp : char_p R p] (p_ne_zero : p ≠ 0) : nat.prime p :=\n\n/-- If an element a divides another element c in a commutative ring, a divides the sum of another  element b with c iff a divides b. -/\ntheorem {α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ c) : a ∣ b + c ↔ a ∣ b :=\n\n/-- an integral domain is a DVR iff it's a PID with a unique non-zero prime ideal -/\ntheorem (R : Type u) [comm_ring R] [is_domain R] : discrete_valuation_ring R ↔ is_principal_ideal_ring R ∧ ∃! (P : ideal R), P ≠ ⊥ ∧ P.is_prime :=\n\n/-- The kernel of a homomorphism to a domain is a prime ideal. -/\ntheorem {R : Type u} {S : Type v} [ring R] [ring S] [is_domain S] (f : R →+* S) : f.ker.is_prime :=\n\n/-- Given a submodule `M ⊆ R` and a prime ideal `p` of `S = M⁻¹R`, with `f : R →+* S` the localization map, then `T = Sₚ` is the localization of `R` at `f⁻¹(p)`. -/\ntheorem {R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] (T : Type u_4) [comm_ring T] [algebra R T] [algebra S T] [is_scalar_tower R S T] [is_localization M S] (p : ideal S) [Hp : p.is_prime] [is_localization.at_prime T p] : is_localization.at_prime T (ideal.comap (algebra_map R S) p) :=\n\n/--  If `f` is a non constant polynomial with coefficients in `R`, and `P` is a prime ideal in `R`, then if every coefficient in `R` except the leading coefficient is in `P`, and the trailing coefficient is not in `P^2` and no non units in `R` divide `f`, then `f` is irreducible. -/\ntheorem {R : Type u_1} [comm_ring R] [is_domain R] {f : polynomial R} {P : ideal R} (hP : P.is_prime) (hfl : f.leading_coeff ∉ P) (hfP : ∀ (n : ℕ), ↑n < f.degree → f.coeff n ∈ P) (hfd0 : 0 < f.degree) (h0 : f.coeff 0 ∉ P ^ 2) (hu : f.is_primitive) : irreducible f :=\n\n/-- The image of the maximal ideal of the source is contained within the maximal ideal of the target. -/\ntheorem {R : Type u} {S : Type v} [comm_semiring R] [local_ring R] [comm_semiring S] [local_ring S] (f : R →+* S) [is_local_ring_hom f] (a : R) (h : a ∈ local_ring.maximal_ideal R) : ⇑f a ∈ local_ring.maximal_ideal S :=\n\n/-- The kernel of a homomorphism to a field is a maximal ideal. -/\ntheorem {R : Type u_1} {K : Type u_2} [ring R] [field K] (f : R →+* K) (hf : function.surjective ⇑f) : f.ker.is_maximal :=\n\n/-- If `R` is a Jacobson ring, and `P` is a maximal ideal of `polynomial R`,  then `R → R[X]/P` is an integral map. -/\ntheorem {R : Type u_1} [comm_ring R] [ideal.is_jacobson R] (P : ideal (polynomial R)) [hP : P.is_maximal] : ((ideal.quotient.mk P).comp polynomial.C).is_integral :=\n\n/-- An element of a DVR is irreducible iff it is a uniformizer, that is, generates the  maximal ideal of R -/\ntheorem {R : Type u} [comm_ring R] [is_domain R] [discrete_valuation_ring R] (ϖ : R) : irreducible ϖ ↔ local_ring.maximal_ideal R = ideal.span {ϖ} :=\n\n/-- In a commutative ring, every prime ideal is contained in a unique maximal ideal. -/\ntheorem "}
{"text": "Every continuous function is uniformly continuous.", "fullPrompt": "/-- The new distance is uniformly continuous. -/\ntheorem {α : Type u} [pseudo_metric_space α] : uniform_continuous (λ (p : uniform_space.completion α × uniform_space.completion α), has_dist.dist p.fst p.snd) :=\n\n/-- The minimal distance to a set is uniformly continuous in point -/\ntheorem {α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_dist x s) :=\n\n/-- The minimal distance to a set (as `ℝ≥0`) is uniformly continuous in point -/\ntheorem {α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_nndist x s) :=\n\n/-- The indexed supremum of a function is bounded above by a uniform bound -/\ntheorem {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), f x ≤ c) : supr f ≤ c :=\n\n/-- On an empty space, bounded continuous functions are at distance 0 -/\ntheorem {α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {f g : bounded_continuous_function α β} [is_empty α] : has_dist.dist f g = 0 :=\n\n/-- In a sequential space, continuity and sequential continuity coincide. -/\ntheorem {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X → Y} [sequential_space X] : continuous f ↔ seq_continuous f :=\n\n/-- The minimal distance to a set is continuous in point -/\ntheorem {α : Type u} [pseudo_metric_space α] (s : set α) : continuous (λ (x : α), metric.inf_dist x s) :=\n\n/--  If `f` is a Lipschitz continuous map, then the Hausdorff dimension of its range is at most the Hausdorff dimension of its domain. -/\ntheorem {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X → Y} (h : lipschitz_with K f) : dimH (set.range f) ≤ dimH set.univ :=\n\n/-- A continuous surjective open map is a quotient map. -/\ntheorem {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f) : quotient_map f :=\n\n/-- The indexed minimum of a function is bounded below by a uniform lower bound -/\ntheorem {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), c ≤ f x) : c ≤ infi f :=\n\n/-- The minimal distance to a set (as `ℝ≥0`) is continuous in point -/\ntheorem {α : Type u} [pseudo_metric_space α] (s : set α) : continuous (λ (x : α), metric.inf_nndist x s) :=\n\n/-- The indexed supremum of a function is bounded below by the value taken at one point -/\ntheorem {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {f : ι → α} (H : bdd_above (set.range f)) (c : ι) : f c ≤ supr f :=\n\n/-- A Hölder continuous function is uniformly continuous -/\ntheorem {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C r : nnreal} {f : X → Y} (hf : holder_with C r f) (h0 : 0 < r) : uniform_continuous f :=\n\n/-- A Hölder continuous function is uniformly continuous -/\ntheorem {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C r : nnreal} {f : X → Y} {s : set X} (hf : holder_on_with C r f s) (h0 : 0 < r) : uniform_continuous_on f s :=\n\n/-- A Lipschitz function is uniformly continuous -/\ntheorem {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {K : nnreal} {f : α → β} (hf : lipschitz_with K f) : uniform_continuous f :=\n\n/-- The composition operator (in the target) with a Lipschitz map is uniformly continuous -/\ntheorem {α : Type u} {β : Type v} {γ : Type w} [topological_space α] [pseudo_metric_space β] [pseudo_metric_space γ] {G : β → γ} {C : nnreal} (H : lipschitz_with C G) : uniform_continuous (bounded_continuous_function.comp G H) :=\n\n/-- The coercion from `lp E p` to `Π i, E i` is uniformly continuous. -/\ntheorem {α : Type u_1} {E : α → Type u_2} {p : ennreal} [Π (i : α), normed_group (E i)] [fact (1 ≤ p)] : uniform_continuous coe :=\n\n/--  Heine-Cantor: a continuous function on a compact set of a separated uniform space is uniformly continuous. -/\ntheorem {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] [separated_space α] {s : set α} {f : α → β} (hs : is_compact s) (hf : continuous_on f s) : uniform_continuous_on f s :=\n\n/--  Heine-Cantor: a continuous function on a compact separated set of a uniform space is uniformly continuous. -/\ntheorem {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] {s : set α} {f : α → β} (hs : is_compact s) (hs' : is_separated s) (hf : continuous_on f s) : uniform_continuous_on f s :=\n\n/-- Every continuous function is uniformly continuous. -/\ntheorem "}
{"text": "Every uniformly continuous function is bounded above.", "fullPrompt": "/-- The indexed supremum of a function is bounded above by a uniform bound -/\ntheorem {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), f x ≤ c) : supr f ≤ c :=\n\n/-- The indexed minimum of a function is bounded below by a uniform lower bound -/\ntheorem {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), c ≤ f x) : c ≤ infi f :=\n\n/-- The indexed supremum of a function is bounded below by the value taken at one point -/\ntheorem {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {f : ι → α} (H : bdd_above (set.range f)) (c : ι) : f c ≤ supr f :=\n\n/-- When there is a global maximum, every set is bounded above. -/\ntheorem {γ : Type w} [preorder γ] [order_top γ] (s : set γ) : bdd_above s :=\n\n/-- A compact set is bounded above -/\ntheorem {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] [nonempty α] {s : set α} (hs : is_compact s) : bdd_above s :=\n\n/-- The minimal distance to a set is uniformly continuous in point -/\ntheorem {α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_dist x s) :=\n\n/-- The minimal distance to a set (as `ℝ≥0`) is uniformly continuous in point -/\ntheorem {α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_nndist x s) :=\n\n/-- Adding a point to a set preserves its boundedness above. -/\ntheorem {γ : Type w} [semilattice_sup γ] (a : γ) {s : set γ} : bdd_above (has_insert.insert a s) ↔ bdd_above s :=\n\n/-- The indexed infimum of a function is bounded above by the value taken at one point -/\ntheorem {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {f : ι → α} (H : bdd_below (set.range f)) (c : ι) : infi f ≤ f c :=\n\n/-- The new distance is uniformly continuous. -/\ntheorem {α : Type u} [pseudo_metric_space α] : uniform_continuous (λ (p : uniform_space.completion α × uniform_space.completion α), has_dist.dist p.fst p.snd) :=\n\n/-- Adding a point to a set preserves its boundedness below. -/\ntheorem {γ : Type w} [semilattice_inf γ] (a : γ) {s : set γ} : bdd_below (has_insert.insert a s) ↔ bdd_below s :=\n\n/-- On an empty space, bounded continuous functions are at distance 0 -/\ntheorem {α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {f g : bounded_continuous_function α β} [is_empty α] : has_dist.dist f g = 0 :=\n\n/-- Composing on the left by a uniformly continuous function preserves  uniform convergence on a set -/\ntheorem {α : Type u_1} {β : Type u_2} {γ : Type u_3} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {s : set α} {p : filter ι} [uniform_space γ] {g : β → γ} (h : tendsto_uniformly_on F f p s) (hg : uniform_continuous g) : tendsto_uniformly_on (λ (i : ι), g ∘ F i) (g ∘ f) p s :=\n\n/-- Composing on the left by a uniformly continuous function preserves uniform convergence -/\ntheorem {α : Type u_1} {β : Type u_2} {γ : Type u_3} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {p : filter ι} [uniform_space γ] {g : β → γ} (h : tendsto_uniformly F f p) (hg : uniform_continuous g) : tendsto_uniformly (λ (i : ι), g ∘ F i) (g ∘ f) p :=\n\n/-- The composition operator (in the target) with a Lipschitz map is uniformly continuous -/\ntheorem {α : Type u} {β : Type v} {γ : Type w} [topological_space α] [pseudo_metric_space β] [pseudo_metric_space γ] {G : β → γ} {C : nnreal} (H : lipschitz_with C G) : uniform_continuous (bounded_continuous_function.comp G H) :=\n\n/-- The coercion from `lp E p` to `Π i, E i` is uniformly continuous. -/\ntheorem {α : Type u_1} {E : α → Type u_2} {p : ennreal} [Π (i : α), normed_group (E i)] [fact (1 ≤ p)] : uniform_continuous coe :=\n\n/--  Heine-Cantor: a continuous function on a compact set of a separated uniform space is uniformly continuous. -/\ntheorem {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] [separated_space α] {s : set α} {f : α → β} (hs : is_compact s) (hf : continuous_on f s) : uniform_continuous_on f s :=\n\n/--  Heine-Cantor: a continuous function on a compact separated set of a uniform space is uniformly continuous. -/\ntheorem {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] {s : set α} {f : α → β} (hs : is_compact s) (hs' : is_separated s) (hf : continuous_on f s) : uniform_continuous_on f s :=\n\n/-- Every uniformly continuous function is bounded above. -/\ntheorem "}
{"text": "If every compact subset of a topological space is closed, then the space is compact.", "fullPrompt": "/-- A closed subset of a compact set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) : is_compact t :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) : is_compact (s ∩ t) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s) : is_compact (s ∩ t) :=\n\n/-- In a `t2_space`, every compact set is closed. -/\ntheorem {α : Type u} [topological_space α] [t2_space α] {s : set α} (hs : is_compact s) : is_closed s :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem {α : Type u} [topological_space α] [locally_compact_space α] {K : set α} (hK : is_compact K) : ∃ (K' : set α), is_compact K' ∧ K ⊆ interior K' :=\n\n/-- In a locally compact T₂ space, every point has an open neighborhood with compact closure -/\ntheorem {α : Type u} [topological_space α] [locally_compact_space α] [t2_space α] (x : α) : ∃ (U : set α), is_open U ∧ x ∈ U ∧ is_compact (closure U) :=\n\n/-- A compact set is bounded above -/\ntheorem {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] [nonempty α] {s : set α} (hs : is_compact s) : bdd_above s :=\n\n/-- An unordered closed interval is compact. -/\ntheorem {α : Type u_1} [linear_order α] [topological_space α] [compact_Icc_space α] {a b : α} : is_compact (set.interval a b) :=\n\n/-- A set is sequentially closed if it is closed. -/\ntheorem {X : Type u_1} [topological_space X] {s : set X} (hs : is_closed s) : is_seq_closed s :=\n\n/-- In a sequential space, a set is closed iff it's sequentially closed. -/\ntheorem {X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s ↔ is_closed s :=\n\n/--  Every separated topological group in which there exists a compact set with nonempty interior is locally compact. -/\ntheorem {G : Type w} [topological_space G] [group G] [topological_group G] [t2_space G] (K : topological_space.positive_compacts G) : locally_compact_space G :=\n\n/-- If X is is_compact then pr₂ : X × Y → Y is a closed map -/\ntheorem {X : Type u_1} [topological_space X] [compact_space X] {Y : Type u_2} [topological_space Y] : is_closed_map prod.snd :=\n\n/--  The **Banach-Alaoglu theorem**: the polar set of a neighborhood `s` of the origin in a normed space `E` is a compact subset of `weak_dual 𝕜 E`. -/\ntheorem (𝕜 : Type u_1) [nondiscrete_normed_field 𝕜] {E : Type u_2} [semi_normed_group E] [normed_space 𝕜 E] [proper_space 𝕜] {s : set E} (s_nhd : s ∈ nhds 0) : is_compact (weak_dual.polar 𝕜 s) :=\n\n/--  A family `F` of functions in `C(α, β)` converges in the compact-open topology, if and only if it converges in the compact-open topology on each compact subset of `α`. -/\ntheorem {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α] [t2_space α] [t2_space β] {ι : Type u_3} {l : filter ι} [l.ne_bot] (F : ι → C(α, β)) : (∃ (f : C(α, β)), filter.tendsto F l (nhds f)) ↔ ∀ (s : set α), is_compact s → (∃ (f : C(↥s, β)), filter.tendsto (λ (i : ι), continuous_map.restrict s (F i)) l (nhds f)) :=\n\n/-- A reformulation of the definition of locally compact space: In a locally compact space,  every open set containing `x` has a compact subset containing `x` in its interior. -/\ntheorem {α : Type u} [topological_space α] [locally_compact_space α] {x : α} {U : set α} (hU : is_open U) (hx : x ∈ U) : ∃ (K : set α), is_compact K ∧ x ∈ interior K ∧ K ⊆ U :=\n\n/-- If every compact subset of a topological space is closed, then the space is compact. -/\ntheorem "}
{"text": "In a commutative ring, the sum of idempotent elements is idempotent.", "fullPrompt": "/-- Compressing an element is idempotent. -/\ntheorem {α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v a : α) : uv.compress u v (uv.compress u v a) = uv.compress u v a :=\n\n/-- An element of a ring multiplied by the additive inverse of one is the element's additive  inverse. -/\ntheorem {α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : a * -1 = -a :=\n\n/-- The identity map is an additive monoid homomorphism. -/\ntheorem {α : Type u} [add_zero_class α] : is_add_monoid_hom id :=\n\n/-- The identity map is a ring homomorphism. -/\ntheorem {α : Type u} [ring α] : is_ring_hom id :=\n\n/-- The identity map preserves addition -/\ntheorem {α : Type u} [has_add α] : is_add_hom id :=\n\n/-- Commuting elements of finite additive order are closed under addition. -/\ntheorem {G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y) :=\n\n/-- If an element a divides another element b in a commutative ring, a divides the sum of b and  another element c iff a divides c. -/\ntheorem {α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ b) : a ∣ b + c ↔ a ∣ c :=\n\n/-- The additive inverse of one multiplied by an element of a ring is the element's additive  inverse. -/\ntheorem {α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : (-1) * a = -a :=\n\n/-- Ring homomorphisms preserve additive inverses. -/\ntheorem {α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} {x : α} (hf : is_ring_hom f) : f (-x) = -f x :=\n\n/-- Left multiplication in a ring is an additive monoid morphism. -/\ntheorem {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), x * y) :=\n\n/-- Right multiplication in a ring is an additive monoid morphism. -/\ntheorem {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), y * x) :=\n\n/-- An additive group homomorphism is an additive monoid homomorphism. -/\ntheorem {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : is_add_monoid_hom f :=\n\n/--  A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p :=\n\n/--  A prime `p` is a unit in a finite commutative ring `R` iff it does not divide the characteristic. -/\ntheorem (R : Type u_1) [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : is_unit ↑p ↔ ¬p ∣ ring_char R :=\n\n/--  The prime divisors of the characteristic of a finite commutative ring are exactly the prime divisors of its cardinality. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : p ∣ ring_char R ↔ p ∣ fintype.card R :=\n\n/-- If an element a divides another element c in a commutative ring, a divides the sum of another  element b with c iff a divides b. -/\ntheorem {α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ c) : a ∣ b + c ↔ a ∣ b :=\n\n/-- In a commutative ring, the sum of idempotent elements is idempotent. -/\ntheorem "}
{"text": "The number of partitions of a finite set is a prime number.", "fullPrompt": "/-- Factoring a prime gives the corresponding one-element multiset. -/\ntheorem (p : nat.primes) : ↑p.factor_multiset = prime_multiset.of_prime p :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem {α : Type u_1} [fintype α] [field α] : is_prime_pow (fintype.card α) :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime dividing it. -/\ntheorem {n : ℕ} : is_prime_pow n ↔ ∃! (p : ℕ), nat.prime p ∧ p ∣ n :=\n\n/-- Prime `p` divides the product of a list `L` iff it divides some `a ∈ L` -/\ntheorem {M : Type u_1} [comm_monoid_with_zero M] {p : M} {L : list M} (pp : prime p) : p ∣ L.prod ↔ ∃ (a : M) (H : a ∈ L), p ∣ a :=\n\n/-- A finite group of prime order is simple. -/\ntheorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_simple_group α :=\n\n/-- **Number of Subsets of a Set** -/\ntheorem {α : Type u_1} (s : finset α) : s.powerset.card = 2 ^ s.card :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_cyclic α :=\n\n/--  A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p :=\n\n/--  The prime divisors of the characteristic of a finite commutative ring are exactly the prime divisors of its cardinality. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : p ∣ ring_char R ↔ p ∣ fintype.card R :=\n\n/-- If the factorization of `n` contains just one number `p` then `n` is a power of `p` -/\ntheorem {n p k : ℕ} (hn : n ≠ 0) (h : n.factorization = finsupp.single p k) : n = p ^ k :=\n\n/--  For every prime `p` dividing the order of a finite group `G` there exists an element of order `p` in `G`. This is known as Cauchy's theorem. -/\ntheorem {G : Type u_1} [group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G) : ∃ (x : G), order_of x = p :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a natural `k` such that `n` can be written as `p^(k+1)`. -/\ntheorem {R : Type u_1} [comm_monoid_with_zero R] (n : R) : is_prime_pow n ↔ ∃ (p : R) (k : ℕ), prime p ∧ p ^ (k + 1) = n :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : ℕ) [hq : exp_char R q] : nat.prime q ∨ q = 1 :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`. -/\ntheorem (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p :=\n\n/-- The number of partitions of a finite set is a prime number. -/\ntheorem "}
{"text": "If a poset has a maximal element, then it has a unique minimal element.", "fullPrompt": "/-- If `α` is a preorder with no maximal element, then `at_top ≤ cofinite`. -/\ntheorem {α : Type u_2} [preorder α] [no_max_order α] : filter.at_top ≤ filter.cofinite :=\n\n/--  If `α` is a nonempty preorder with no minimal or maximal elements, then there exists a strictly monotone function `f : ℤ → α`. -/\ntheorem (α : Type u) [preorder α] [nonempty α] [no_min_order α] [no_max_order α] : ∃ (f : ℤ → α), strict_mono f :=\n\n/-- The supremum of a singleton is the element of the singleton -/\ntheorem {α : Type u_1} [conditionally_complete_lattice α] (a : α) : has_Sup.Sup {a} = a :=\n\n/-- The infimum of a singleton is the element of the singleton -/\ntheorem {α : Type u_1} [conditionally_complete_lattice α] (a : α) : has_Inf.Inf {a} = a :=\n\n/--  If `α` is a nonempty preorder with no maximal elements, then there exists a strictly monotone function `ℕ → α`. -/\ntheorem (α : Type u) [preorder α] [nonempty α] [no_max_order α] : ∃ (f : ℕ → α), strict_mono f :=\n\n/--  If `α` is a nonempty preorder with no minimal elements, then there exists a strictly antitone function `ℕ → α`. -/\ntheorem (α : Type u) [preorder α] [nonempty α] [no_min_order α] : ∃ (f : ℕ → α), strict_anti f :=\n\n/-- If `X` has subobject lattice `{⊥, ⊤}`, then `X` is simple. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) [is_simple_order (category_theory.subobject X)] : category_theory.simple X :=\n\n/-- Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle. -/\ntheorem {α : Type u_1} {r : α → α → Prop} {c : set α} (hc : is_chain r c) : ∃ (M : set α), is_max_chain r M ∧ c ⊆ M :=\n\n/--  **Hausdorff's maximality principle**  There exists a maximal totally ordered set of `α`. Note that we do not require `α` to be partially ordered by `r`. -/\ntheorem {α : Type u_1} {r : α → α → Prop} : is_max_chain r (max_chain r) :=\n\n/--  If `α` is a preorder with no maximal elements, then there exists a strictly monotone function `ℕ → α` with any prescribed value of `f 0`. -/\ntheorem {α : Type u} [preorder α] [no_max_order α] (a : α) : ∃ (f : ℕ → α), strict_mono f ∧ f 0 = a :=\n\n/-- `X` is simple iff it has subobject lattice `{⊥, ⊤}`. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) : category_theory.simple X ↔ is_simple_order (category_theory.subobject X) :=\n\n/-- If `s` has a least element, then it is bounded below. -/\ntheorem {α : Type u} [preorder α] {s : set α} {a : α} (h : is_least s a) : bdd_below s :=\n\n/--  A nonempty preorder with no maximal element is infinite. This is not an instance to avoid a cycle with `infinite α → nontrivial α → nonempty α`. -/\ntheorem {α : Type u_1} [preorder α] [nonempty α] [no_max_order α] : infinite α :=\n\n/--  A nonempty preorder with no minimal element is infinite. This is not an instance to avoid a cycle with `infinite α → nontrivial α → nonempty α`. -/\ntheorem {α : Type u_1} [preorder α] [nonempty α] [no_min_order α] : infinite α :=\n\n/--  A compact element `k` has the property that any `b < k` lies below a \"maximal element below `k`\", which is to say `[⊥, k]` is coatomic. -/\ntheorem {α : Type u_1} [complete_lattice α] {k : α} (h : complete_lattice.is_compact_element k) : is_coatomic ↥(set.Iic k) :=\n\n/--  **Zorn's lemma**  If every chain has an upper bound, then there exists a maximal element. -/\ntheorem {α : Type u_1} {r : α → α → Prop} (h : ∀ (c : set α), is_chain r c → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) (trans : ∀ {a b c : α}, r a b → r b c → r a c) : ∃ (m : α), ∀ (a : α), r m a → r a m :=\n\n/--  Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there exists a minimal element `a` of `H ∩ G_{>0}` then `H` is generated by `a`. -/\ntheorem {G : Type u_1} [linear_ordered_add_comm_group G] [archimedean G] {H : add_subgroup G} {a : G} (ha : is_least {g : G | g ∈ H ∧ 0 < g} a) : H = add_subgroup.closure {a} :=\n\n/--  If `r` is a well-founded relation, then any nonempty set has a minimal element with respect to `r`. -/\ntheorem {α : Type u_1} {r : α → α → Prop} (H : well_founded r) (s : set α) : s.nonempty → (∃ (a : α) (H : a ∈ s), ∀ (x : α), x ∈ s → ¬r x a) :=\n\n/-- If a poset has a maximal element, then it has a unique minimal element. -/\ntheorem "}
{"text": "The automorphism group of an Abelian group is cyclic.", "fullPrompt": "/-- A finite group of prime order is cyclic. -/\ntheorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_cyclic α :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : is_monoid_hom f :=\n\n/-- A map to a group preserving multiplication is a monoid homomorphism. -/\ntheorem {α : Type u} {β : Type v} [mul_one_class α] [group β] {f : α → β} (hf : is_mul_hom f) : is_monoid_hom f :=\n\n/-- A group homomorphism sends 1 to 1. -/\ntheorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : f 1 = 1 :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- The inverse of a group homomorphism is a group homomorphism if the target is commutative. -/\ntheorem {α : Type u_1} {β : Type u_2} [group α] [comm_group β] {f : α → β} (hf : is_group_hom f) : is_group_hom (λ (a : α), (f a)⁻¹) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_simple_group α :=\n\n/-- Inversion is a group homomorphism if the group is commutative. -/\ntheorem {α : Type u} [comm_group α] : is_group_hom has_inv.inv :=\n\n/--  Adding a group element to the point `p` is an injective function. -/\ntheorem {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (λ (_x : G), _x +ᵥ p) :=\n\n/-- Finite groups are torsion groups. -/\ntheorem {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i) :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 1 → a = 1 :=\n\n/-- A semisimple Abelian Lie algebra is trivial. -/\ntheorem (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_algebra.is_semisimple R L] [h : is_lie_abelian L] : subsingleton L :=\n\n/--  Note that the inequality can be strict; e.g., the inclusion of an Abelian subalgebra of a simple algebra. -/\ntheorem {R : Type u} {L : Type v} {L' : Type w₂} [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] (f : L →ₗ⁅R⁆ L') {I₁ I₂ : lie_ideal R L} : lie_ideal.map f ⁅I₁,I₂⁆ ≤ ⁅lie_ideal.map f I₁,lie_ideal.map f I₂⁆ :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem {G : Type u_1} [comm_group G] : group.nilpotency_class G ≤ 1 :=\n\n/--  If an order automorphism `fa` is semiconjugate to an order embedding `fb` by a function `g` and `g'` is an order right adjoint of `g` (i.e. `g' y = Sup {x | f x ≤ y}`), then `fb` is semiconjugate to `fa` by `g'`.  This is a version of Proposition 2.1 from [Étienne Ghys, Groupes d'homeomorphismes du cercle et cohomologie bornee][ghys87:groupes]. -/\ntheorem {α : Type u_1} {β : Type u_2} [partial_order α] [preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β} (h : function.semiconj g ⇑fa ⇑fb) {g' : β → α} (hg' : is_order_right_adjoint g g') : function.semiconj g' ⇑fb ⇑fa :=\n\n/-- The automorphism group of an Abelian group is cyclic. -/\ntheorem "}
{"text": "If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.", "fullPrompt": "/-- A fixed point of `f` is a periodic point of `f` of any prescribed period. -/\ntheorem {α : Type u_1} {f : α → α} {x : α} (hf : function.is_fixed_pt f x) (n : ℕ) : function.is_periodic_pt f n x :=\n\n/-- Any point is a periodic point of period `0`. -/\ntheorem {α : Type u_1} (f : α → α) (x : α) : function.is_periodic_pt f 0 x :=\n\n/-- If `x` is a fixed point of `f ∘ g` and `g`, then it is a fixed point of `f`. -/\ntheorem {α : Type u} {f g : α → α} {x : α} (hfg : function.is_fixed_pt (f ∘ g) x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt f x :=\n\n/-- Every point is a fixed point of `id`. -/\ntheorem {α : Type u} (x : α) : function.is_fixed_pt id x :=\n\n/-- If `x` is a fixed point of `f` and `g`, then it is a fixed point of `f ∘ g`. -/\ntheorem {α : Type u} {f g : α → α} {x : α} (hf : function.is_fixed_pt f x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt (f ∘ g) x :=\n\n/-- If `x` is a fixed point of `f`, then `f x = x`. This is useful, e.g., for `rw` or `simp`. -/\ntheorem {α : Type u} {f : α → α} {x : α} (hf : function.is_fixed_pt f x) : f x = x :=\n\n/-- If a function is `antiperiodic` with antiperiod `c`, then it is also `periodic` with period  `2 * c`. -/\ntheorem {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [semiring α] [add_group β] (h : function.antiperiodic f c) : function.periodic f (2 * c) :=\n\n/-- For the identity map, all points are periodic. -/\ntheorem {α : Type u_1} (n : ℕ) (x : α) : function.is_periodic_pt id n x :=\n\n/--  The fixed point lemma for normal functions: any normal function has an unbounded set of fixed points. -/\ntheorem {f : ordinal → ordinal} (H : ordinal.is_normal f) : set.unbounded has_lt.lt (function.fixed_points f) :=\n\n/--  An interval of length `a` filtered over a periodic predicate of period `a` has cardinality equal to the number naturals below `a` for which `p a` is true. -/\ntheorem (n a : ℕ) (p : ℕ → Prop) [decidable_pred p] (pp : function.periodic p a) : ⇑multiset.card (multiset.filter p (multiset.Ico n (n + a))) = nat.count p a :=\n\n/--  If self-maps `f` and `g` commute, then `g` is bijective on the set of fixed points of `f ∘ g`. This is a particular case of `function.bij_on_fixed_pts_comp`. -/\ntheorem {α : Type u} {f g : α → α} (h : function.commute f g) : set.bij_on g (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g)) :=\n\n/--  If self-maps `f` and `g` commute, then `f` is bijective on the set of fixed points of `f ∘ g`. This is a particular case of `function.bij_on_fixed_pts_comp`. -/\ntheorem {α : Type u} {f g : α → α} (h : function.commute f g) : set.bij_on f (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g)) :=\n\n/--  If `f` sends two periodic points `x` and `y` of positive periods to the same point, then `x = y`. -/\ntheorem {α : Type u_1} {f : α → α} {x y : α} {m n : ℕ} (hx : function.is_periodic_pt f m x) (hy : function.is_periodic_pt f n y) (hm : 0 < m) (hn : 0 < n) (h : f x = f y) : x = y :=\n\n/--  If `f` sends two periodic points `x` and `y` of the same positive period to the same point, then `x = y`. For a similar statement about points of different periods see `eq_of_apply_eq`. -/\ntheorem {α : Type u_1} {f : α → α} {x y : α} {n : ℕ} (hx : function.is_periodic_pt f n x) (hy : function.is_periodic_pt f n y) (hn : 0 < n) (h : f x = f y) : x = y :=\n\n/-- If a function from the unit interval to itself has a fixed point, then it has points of all positive periods. -/\ntheorem "}
{"text": "The complement of the union of two sets contains the union of their complements.", "fullPrompt": "/-- The union of two sets is bounded iff each of the sets is bounded. -/\ntheorem {α : Type u} [pseudo_metric_space α] {s t : set α} : metric.bounded (s ∪ t) ↔ metric.bounded s ∧ metric.bounded t :=\n\n/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem {γ : Type w} [semilattice_inf γ] {s t : set γ} : bdd_below (s ∪ t) ↔ bdd_below s ∧ bdd_below t :=\n\n/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem {γ : Type w} [semilattice_sup γ] {s t : set γ} : bdd_above (s ∪ t) ↔ bdd_above s ∧ bdd_above t :=\n\n/-- The union of two bounded sets is bounded. -/\ntheorem {α : Type u} [pseudo_metric_space α] {s t : set α} (hs : metric.bounded s) (ht : metric.bounded t) : metric.bounded (s ∪ t) :=\n\n/-- The union of two Gδ sets is a Gδ set. -/\ntheorem {α : Type u_1} [topological_space α] {s t : set α} (hs : is_Gδ s) (ht : is_Gδ t) : is_Gδ (s ∪ t) :=\n\n/-- Subsets of a bounded set are also bounded -/\ntheorem {α : Type u} [pseudo_metric_space α] {s t : set α} (incl : s ⊆ t) : metric.bounded t → metric.bounded s :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) : is_compact (s ∩ t) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s) : is_compact (s ∩ t) :=\n\n/-- If the elements of a set are independent, then any pair within that set is disjoint. -/\ntheorem {α : Type u_1} {ι : Type u_3} [complete_lattice α] {t : ι → α} (ht : complete_lattice.independent t) : pairwise (disjoint on t) :=\n\n/-- The substructure generated by a set includes the set. -/\ntheorem {L : first_order.language} {M : Type w} [L.Structure M] {s : set M} : s ⊆ ↑(⇑(first_order.language.substructure.closure L) s) :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) : is_compact t :=\n\n/-- If `s` is bounded, then so is `s ∩ t` -/\ntheorem {α : Type u} [preorder α] {s t : set α} (h : bdd_above s) : bdd_above (s ∩ t) :=\n\n/-- The complement of the union of two sets contains the union of their complements. -/\ntheorem "}
{"text": "The square root of an rational number is rational.", "fullPrompt": "/-- The conjugate of the golden ratio is irrational. -/\ntheorem  : irrational golden_conj :=\n\n/-- The golden ratio is irrational. -/\ntheorem  : irrational golden_ratio :=\n\n/-- Note that most of the lemmas about powers of two refer to it as `sq`. -/\ntheorem {M : Type u} [monoid M] (a : M) : a ^ 2 = a * a :=\n\n/-- **Alias** of the reverse direction of is_square_iff_exists_sq`. -/\ntheorem {α : Type u_2} [monoid α] (m : α) : (∃ (c : α), m = c ^ 2) → is_square m :=\n\n/-- Natural division is always less than division in the field. -/\ntheorem {α : Type u_1} [linear_ordered_field α] {m n : ℕ} : ↑(m / n) ≤ ↑m / ↑n :=\n\n/-- **Alias** of the forward direction of is_square_iff_exists_sq`. -/\ntheorem {α : Type u_2} [monoid α] (m : α) : is_square m → (∃ (c : α), m = c ^ 2) :=\n\n/-- The zeroth Pythagorean triple is all zeros. -/\ntheorem  : pythagorean_triple 0 0 0 :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem {α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0 :=\n\n/-- The square of the quadratic character on nonzero arguments is `1`. -/\ntheorem {F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0) : char.quadratic_char F a ^ 2 = 1 :=\n\n/-- If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. -/\ntheorem {α : Type u_1} [monoid α] {p q : α} (hp : irreducible p) (hq : irreducible q) : p ∣ q → q ∣ p :=\n\n/-- A non-zero `a : F` is a square if and only if `a ^ (#F / 2) = 1`. -/\ntheorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) {a : F} (ha : a ≠ 0) : is_square a ↔ a ^ (fintype.card F / 2) = 1 :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) : ∃ (a : F), ¬is_square a :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem {a : ℕ} : real.sqrt ↑a ≤ ↑(nat.sqrt a) + 1 :=\n\n/-- The natural square root is at most the real square root -/\ntheorem {a : ℕ} : ↑(nat.sqrt a) ≤ real.sqrt ↑a :=\n\n/-- A quadratic has no root if its discriminant has no square root. -/\ntheorem {R : Type u_1} [comm_ring R] [is_domain R] {a b c : R} (h2 : 2 ≠ 0) (ha : a ≠ 0) (h : ∀ (s : R), discrim a b c ≠ s * s) (x : R) : a * x * x + b * x + c ≠ 0 :=\n\n/-- The product of a Liouville number and a nonzero rational number is again a Liouville number. -/\ntheorem {p x : ℝ} {r : ℚ} (h : liouville_with p x) (hr : r ≠ 0) : liouville_with p (x * ↑r) :=\n\n/-- Every terminating continued fraction corresponds to a rational number. -/\ntheorem {K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} (terminates : (generalized_continued_fraction.of v).terminates) : ∃ (q : ℚ), v = ↑q :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem {K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) (n : ℕ) : ∃ (q : ℚ), (generalized_continued_fraction.of v).convergents n = ↑q :=\n\n/-- The continued fraction of a rational number terminates. -/\ntheorem (q : ℚ) : (generalized_continued_fraction.of q).terminates :=\n\n/-- The p-adic value of an integer `z ≠ 0` is its p-adic_value as a rational -/\ntheorem {p n : ℕ} : padic_val_rat p ↑n = ↑(padic_val_nat p n) :=\n\n/-- The p-adic value of an integer `z ≠ 0` is its p-adic_value as a rational -/\ntheorem {p : ℕ} {z : ℤ} : padic_val_rat p ↑z = ↑(padic_val_int p z) :=\n\n/--  If `E` is a vector space over two division rings `R` and `S`, then scalar multiplications agree on rational numbers in `R` and `S`. -/\ntheorem {E : Type u_1} (R : Type u_2) (S : Type u_3) [add_comm_group E] [division_ring R] [division_ring S] [module R E] [module S E] (r : ℚ) (x : E) : ↑r • x = ↑r • x :=\n\n/-- The square root of an rational number is rational. -/\ntheorem "}
{"text": "If a module over a ring is free, then the ring is commutative.", "fullPrompt": "/-- A free module with a basis indexed by a `fintype` is finite. -/\ntheorem {R : Type u_1} {M : Type u_2} {ι : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [fintype ι] (b : basis ι R M) : module.finite R M :=\n\n/-- The rank of a free module `M` over `R` is the cardinality of `choose_basis_index R M`. -/\ntheorem (R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] : module.rank R M = cardinal.mk (module.free.choose_basis_index R M) :=\n\n/-- A module over a division ring is noetherian if and only if it is finitely generated. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V ↔ module.finite K V :=\n\n/-- A module has dimension 1 iff there is some `v : V` so `{v}` is a basis. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (ι : Type u_1) [unique ι] : finite_dimensional.finrank K V = 1 ↔ nonempty (basis ι K V) :=\n\n/-- Hilbert basis theorem: a polynomial ring over a noetherian ring is a noetherian ring. -/\ntheorem {R : Type u} [comm_ring R] [is_noetherian_ring R] : is_noetherian_ring (polynomial R) :=\n\n/-- If an element a divides another element b in a commutative ring, a divides the sum of b and  another element c iff a divides c. -/\ntheorem {α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ b) : a ∣ b + c ↔ a ∣ c :=\n\n/--  If two words have a common maximal reduction, then they correspond to the same element in the free group. -/\ntheorem {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.reduce L₁ = free_group.reduce L₂) : free_group.mk L₁ = free_group.mk L₂ :=\n\n/-- The identity map is a ring homomorphism. -/\ntheorem {α : Type u} [ring α] : is_ring_hom id :=\n\n/-- Left multiplication in a ring is an additive monoid morphism. -/\ntheorem {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), x * y) :=\n\n/-- Ring homomorphisms map zero to zero. -/\ntheorem {α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (hf : is_ring_hom f) : f 0 = 0 :=\n\n/-- A division_ring is one-dimensional as a vector space over itself. -/\ntheorem (K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1 :=\n\n/-- Right multiplication in a ring is an additive monoid morphism. -/\ntheorem {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), y * x) :=\n\n/-- If a module over a ring is free, then the ring is commutative. -/\ntheorem "}
{"text": "If the set of units of a ring forms a group then the ring is commutative.", "fullPrompt": "/--  A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p :=\n\n/-- An element of a ring multiplied by the additive inverse of one is the element's additive  inverse. -/\ntheorem {α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : a * -1 = -a :=\n\n/--  A prime `p` is a unit in a finite commutative ring `R` iff it does not divide the characteristic. -/\ntheorem (R : Type u_1) [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : is_unit ↑p ↔ ¬p ∣ ring_char R :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- The additive inverse of one multiplied by an element of a ring is the element's additive  inverse. -/\ntheorem {α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : (-1) * a = -a :=\n\n/-- Units of a monoid divide any element of the monoid. -/\ntheorem {α : Type u_1} [monoid α] {a u : α} (hu : is_unit u) : u ∣ a :=\n\n/-- Left multiplication in a ring is an additive monoid morphism. -/\ntheorem {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), x * y) :=\n\n/-- Right multiplication in a ring is an additive monoid morphism. -/\ntheorem {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), y * x) :=\n\n/-- If an element a divides another element b in a commutative ring, a divides the sum of b and  another element c iff a divides c. -/\ntheorem {α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ b) : a ∣ b + c ↔ a ∣ c :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- A map to a group preserving multiplication is a monoid homomorphism. -/\ntheorem {α : Type u} {β : Type v} [mul_one_class α] [group β] {f : α → β} (hf : is_mul_hom f) : is_monoid_hom f :=\n\n/-- The inverse of a group homomorphism is a group homomorphism if the target is commutative. -/\ntheorem {α : Type u_1} {β : Type u_2} [group α] [comm_group β] {f : α → β} (hf : is_group_hom f) : is_group_hom (λ (a : α), (f a)⁻¹) :=\n\n/-- When lowered to a prop, `matrix.diagonal_invertible_equiv_invertible` forms an `iff`. -/\ntheorem {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {v : n → α} : is_unit (matrix.diagonal v) ↔ is_unit v :=\n\n/-- When lowered to a prop, `matrix.invertible_equiv_det_invertible` forms an `iff`. -/\ntheorem {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) : is_unit A ↔ is_unit A.det :=\n\n/--  *Engel's theorem*.  Note that this implies all traditional forms of Engel's theorem via `lie_module.nontrivial_max_triv_of_is_nilpotent`, `lie_module.is_nilpotent_iff_forall`, `lie_algebra.is_nilpotent_iff_forall`. -/\ntheorem {R : Type u₁} {L : Type u₂} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : lie_algebra.is_engelian R L :=\n\n/--  The map `B.polar : set E → set F` forms an order-reversing Galois connection with `B.flip.polar : set F → set E`. We use `order_dual.to_dual` and `order_dual.of_dual` to express that `polar` is order-reversing. -/\ntheorem {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [normed_comm_ring 𝕜] [add_comm_monoid E] [add_comm_monoid F] [module 𝕜 E] [module 𝕜 F] (B : E →ₗ[𝕜] F →ₗ[𝕜] 𝕜) : galois_connection (⇑order_dual.to_dual ∘ B.polar) (B.flip.polar ∘ ⇑order_dual.of_dual) :=\n\n/--  If a family of submodules is `independent`, then a choice of nonzero vector from each submodule forms a linearly independent family. -/\ntheorem {ι : Type u_1} {R : Type u_2} {N : Type u_5} [ring R] [add_comm_group N] [module R N] [no_zero_smul_divisors R N] (p : ι → submodule R N) (hp : complete_lattice.independent p) {v : ι → N} (hv : ∀ (i : ι), v i ∈ p i) (hv' : ∀ (i : ι), v i ≠ 0) : linear_independent R v :=\n\n/-- If the set of units of a ring forms a group then the ring is commutative. -/\ntheorem "}
{"text": "Every natural number larger than `10` is the sum of a square and a prime.", "fullPrompt": "/--  **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p :=\n\n/-- There are no perfect squares strictly between m² and (m+1)² -/\ntheorem {n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬∃ (t : ℕ), t * t = n :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem {α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0 :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`. -/\ntheorem (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem  : set.inj_on nat.factorization {x : ℕ | x ≠ 0} :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- For any natural numbers n, a, and b, one of the following holds: 1. n < a 2. n ≥ b 3. n ∈ Ico a b -/\ntheorem (n a b : ℕ) : n < a ∨ b ≤ n ∨ n ∈ list.Ico a b :=\n\n/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/\ntheorem {m n : ℕ} : m ∣ m + n ↔ m ∣ n :=\n\n/-- A natural number `m` divides the sum `n + m` if and only if `m` divides `n`. -/\ntheorem {m n : ℕ} : m ∣ n + m ↔ m ∣ n :=\n\n/-- Two natural numbers are equal if and only if the have the same divisors. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- Every natural number larger than `10` is the sum of a square and a prime. -/\ntheorem "}
{"text": "The initial object of a category is isomorphic to its terminal object.", "fullPrompt": "/-- If there are zero morphisms, any terminal object is a zero object. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C] : category_theory.limits.has_zero_object C :=\n\n/--  To show a category is a `initial_mono_class` it suffices to show every morphism out of the initial object is a monomorphism. -/\ntheorem {C : Type u₁} [category_theory.category C] [category_theory.limits.has_initial C] (h : ∀ (X : C), category_theory.mono (category_theory.limits.initial.to X)) : category_theory.limits.initial_mono_class C :=\n\n/-- If the unique morphism from `A` to a terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_is_terminal_from`. -/\ntheorem {C : Type u₁} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)] : category_theory.is_subterminal A :=\n\n/-- If `A` is subterminal, the unique morphism from it to a terminal object is a monomorphism. The converse of `is_subterminal_of_mono_is_terminal_from`. -/\ntheorem {C : Type u₁} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) {T : C} (hT : category_theory.limits.is_terminal T) : category_theory.mono (hT.from A) :=\n\n/-- Any simple object in a preadditive category is indecomposable. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] (X : C) [category_theory.simple X] : category_theory.indecomposable X :=\n\n/-- If a preadditive category has all cokernels, then it also has all coequalizers. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_cokernels C] : category_theory.limits.has_coequalizers C :=\n\n/-- If `A` is subterminal, the unique morphism from it to the terminal object is a monomorphism. The converse of `is_subterminal_of_mono_terminal_from`. -/\ntheorem {C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] (hA : category_theory.is_subterminal A) : category_theory.mono (category_theory.limits.terminal.from A) :=\n\n/-- If the unique morphism from `A` to the terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_terminal_from`. -/\ntheorem {C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] [category_theory.mono (category_theory.limits.terminal.from A)] : category_theory.is_subterminal A :=\n\n/-- If a preadditive category has all kernels, then it also has all equalizers. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] : category_theory.limits.has_equalizers C :=\n\n/-- If there are zero morphisms, any initial object is a zero object. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_initial C] : category_theory.limits.has_zero_object C :=\n\n/-- Construct terminal object in the over category. This isn't an instance as it's not typically the way we want to define terminal objects. (For instance, this gives a terminal object which is different from the generic one given by `over_product_of_wide_pullback` above.) -/\ntheorem {C : Type u} [category_theory.category C] (B : C) : category_theory.limits.has_terminal (category_theory.over B) :=\n\n/-- In a preadditive category, if the coproduct over `f : J → C` exists,    then the biproduct over `f` exists. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J → C) [category_theory.limits.has_coproduct f] : category_theory.limits.has_biproduct f :=\n\n/-- If `C` has an initial object and binary coproducts, then it has finite coproducts. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_initial C] : category_theory.limits.has_finite_coproducts C :=\n\n/-- If `C` has a terminal object and binary products, then it has finite products. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_terminal C] : category_theory.limits.has_finite_products C :=\n\n/--  If `c` is a colimiting binary coproduct cocone, and we have an initial object, then we have `is_pushout 0 0 c.inl c.inr` (where each `0` is the unique morphism from the initial object). -/\ntheorem {C : Type u₁} [category_theory.category C] {Z X Y : C} {c : category_theory.limits.binary_cofan X Y} (h : category_theory.limits.is_colimit c) (t : category_theory.limits.is_initial Z) : category_theory.is_pushout (t.to ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.left})) (t.to ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.right})) c.inl c.inr :=\n\n/-- If `C` has a initial object and `G` preserves initial objects, then `D` has a initial object also. Note this property is somewhat unique to colimits of the empty diagram: for general `J`, if `C` has colimits of shape `J` and `G` preserves them, then `D` does not necessarily have colimits of shape `J`. -/\ntheorem {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (G : C ⥤ D) [category_theory.limits.has_initial C] [category_theory.limits.preserves_colimit (category_theory.functor.empty C) G] : category_theory.limits.has_initial D :=\n\n/--  To show a category is a `initial_mono_class` it suffices to show the unique morphism from the initial object to a terminal object is a monomorphism. -/\ntheorem {C : Type u₁} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] (h : category_theory.mono (category_theory.limits.initial.to (⊤_ C))) : category_theory.limits.initial_mono_class C :=\n\n/--  If `c` is a limiting binary product cone, and we have a terminal object, then we have `is_pullback c.fst c.snd 0 0` (where each `0` is the unique morphism to the terminal object). -/\ntheorem {C : Type u₁} [category_theory.category C] {X Y Z : C} {c : category_theory.limits.binary_fan X Y} (h : category_theory.limits.is_limit c) (t : category_theory.limits.is_terminal Z) : category_theory.is_pullback c.fst c.snd (t.from ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.left})) (t.from ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.right})) :=\n\n/-- If `C` has a terminal object and `G` preserves terminal objects, then `D` has a terminal object also. Note this property is somewhat unique to (co)limits of the empty diagram: for general `J`, if `C` has limits of shape `J` and `G` preserves them, then `D` does not necessarily have limits of shape `J`. -/\ntheorem {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (G : C ⥤ D) [category_theory.limits.has_terminal C] [category_theory.limits.preserves_limit (category_theory.functor.empty C) G] : category_theory.limits.has_terminal D :=\n\n/--  If all but one object in a diagram is strict terminal, the the limit is isomorphic to the said object via `limit.π`. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_strict_terminal_objects C] {J : Type v} [category_theory.small_category J] (F : J ⥤ C) [category_theory.limits.has_limit F] (i : J) (H : Π (j : J), j ≠ i → category_theory.limits.is_terminal (F.obj j)) [subsingleton (i ⟶ i)] : category_theory.is_iso (category_theory.limits.limit.π F i) :=\n\n/-- The initial object of a category is isomorphic to its terminal object. -/\ntheorem "}
{"text": "If the composition of two functions is continuous, then each of them is continuous.", "fullPrompt": "/-- If `x` is a fixed point of `f` and `g`, then it is a fixed point of `f ∘ g`. -/\ntheorem {α : Type u} {f g : α → α} {x : α} (hf : function.is_fixed_pt f x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt (f ∘ g) x :=\n\n/-- Composition by an surjective function on the left is itself surjective. -/\ntheorem {α : Sort u} {β : Sort v} {γ : Sort w} {g : β → γ} (hg : function.surjective g) : function.surjective (function.comp g) :=\n\n/-- If `x` is a fixed point of `f ∘ g` and `g`, then it is a fixed point of `f`. -/\ntheorem {α : Type u} {f g : α → α} {x : α} (hfg : function.is_fixed_pt (f ∘ g) x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt f x :=\n\n/-- Composition by an injective function on the left is itself injective. -/\ntheorem {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {g : β → γ} (hg : function.injective g) : function.injective (function.comp g) :=\n\n/-- Composition by an bijective function on the left is itself bijective. -/\ntheorem {α : Sort u} {β : Sort v} {γ : Sort w} {g : β → γ} (hg : function.bijective g) : function.bijective (function.comp g) :=\n\n/-- The inclusion of a fiber into the total space is a continuous map. -/\ntheorem {ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (b : B) : continuous (bundle.total_space_mk b) :=\n\n/-- In a sequential space, continuity and sequential continuity coincide. -/\ntheorem {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X → Y} [sequential_space X] : continuous f ↔ seq_continuous f :=\n\n/--  If a composition of a function `f` followed by an injection `g` is locally constant, then the locally constant property descends to `f`. -/\ntheorem {X : Type u_1} [topological_space X] {α : Type u_2} {β : Type u_3} (f : X → α) (g : α → β) (h : is_locally_constant (g ∘ f)) (inj : function.injective g) : is_locally_constant f :=\n\n/-- Any map `f` sends fixed points of `g ∘ f` to fixed points of `f ∘ g`. -/\ntheorem {α : Type u} {β : Type v} (f : α → β) (g : β → α) : set.maps_to f (function.fixed_points (g ∘ f)) (function.fixed_points (f ∘ g)) :=\n\n/-- Conjugation is jointly continuous on `G × G` when both `mul` and `inv` are continuous. -/\ntheorem {G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] : continuous (λ (g : G × G), g.fst * g.snd * (g.fst)⁻¹) :=\n\n/-- Conjugation is jointly continuous on `G × G` when both `mul` and `inv` are continuous. -/\ntheorem {G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] : continuous (λ (g : G × G), g.fst + g.snd + -g.fst) :=\n\n/-- The currying process is a continuous map between function spaces. -/\ntheorem {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] [locally_compact_space (α × β)] : continuous continuous_map.curry :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {p : filter ι} [topological_space α] (h : tendsto_locally_uniformly F f p) (hc : ∀ᶠ (n : ι) in p, continuous (F n)) [p.ne_bot] : continuous f :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {p : filter ι} [topological_space α] (h : tendsto_uniformly F f p) (hc : ∀ᶠ (n : ι) in p, continuous (F n)) [p.ne_bot] : continuous f :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem {α : Type u_1} {β : Type u_2} [uniform_space β] {f : α → β} [topological_space α] (L : ∀ (x : α) (u : set (β × β)), u ∈ uniformity β → (∃ (t : set α) (H : t ∈ nhds x) (F : α → β), continuous_at F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u)) : continuous f :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem {α : Type u_1} {β : Type u_2} [uniform_space β] {f : α → β} [topological_space α] (L : ∀ (u : set (β × β)), u ∈ uniformity β → (∃ (F : α → β), continuous F ∧ ∀ (y : α), (f y, F y) ∈ u)) : continuous f :=\n\n/-- If the composition of two functions is continuous, then each of them is continuous. -/\ntheorem "}
{"text": "If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.", "fullPrompt": "/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem {S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) : commute a (b * c) :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem {S : Type u_1} [semigroup S] {a b c : S} (hac : commute a c) (hbc : commute b c) : commute (a * b) c :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem {S : Type u_1} [add_semigroup S] {a b c : S} (hac : add_commute a c) (hbc : add_commute b c) : add_commute (a + b) c :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their sum. -/\ntheorem {S : Type u_1} [add_semigroup S] {a b c : S} (hab : add_commute a b) (hac : add_commute a c) : add_commute a (b + c) :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem {S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : commute b a :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem {S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : add_commute b a :=\n\n/-- Any element commutes with itself. -/\ntheorem {S : Type u_1} [has_mul S] (a : S) : commute a a :=\n\n/-- Any element commutes with itself. -/\ntheorem {S : Type u_1} [has_add S] (a : S) : add_commute a a :=\n\n/-- Equality behind `commute a b`; useful for rewriting. -/\ntheorem {S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : a * b = b * a :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- Moving to the opposite group or group_with_zero commutes with taking powers. -/\ntheorem {M : Type u} [div_inv_monoid M] (x : M) (z : ℤ) : mul_opposite.op (x ^ z) = mul_opposite.op x ^ z :=\n\n/--  The inverse of a map which preserves multiplication, preserves multiplication when the target is commutative. -/\ntheorem {α : Type u_1} {β : Type u_2} [mul_one_class α] [comm_group β] {f : α → β} (hf : is_monoid_hom f) : is_monoid_hom (λ (a : α), (f a)⁻¹) :=\n\n/-- If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`. -/\ntheorem "}
{"text": "If an element maps to zero under a ring homomorphism, then it is zero.", "fullPrompt": "/-- Ring homomorphisms map zero to zero. -/\ntheorem {α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (hf : is_ring_hom f) : f 0 = 0 :=\n\n/-- An additive group homomorphism sends 0 to 0. -/\ntheorem {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : f 0 = 0 :=\n\n/-- The identity map is a ring homomorphism. -/\ntheorem {α : Type u} [ring α] : is_ring_hom id :=\n\n/-- Ring homomorphisms preserve additive inverses. -/\ntheorem {α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} {x : α} (hf : is_ring_hom f) : f (-x) = -f x :=\n\n/-- A ring homomorphism is also a semiring homomorphism. -/\ntheorem {α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (hf : is_ring_hom f) : is_semiring_hom f :=\n\n/-- A map of rings that is a semiring homomorphism is also a ring homomorphism. -/\ntheorem {α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (H : is_semiring_hom f) : is_ring_hom f :=\n\n/-- If there are zero morphisms, any initial object is a zero object. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_initial C] : category_theory.limits.has_zero_object C :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 1 → a = 1 :=\n\n/-- An additive group homomorphism is injective if its kernel is trivial. -/\ntheorem {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 0 → a = 0 :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem (R : Type u) [non_assoc_ring R] (p : ℕ) [hc : char_p R p] [fintype R] : p ≠ 0 :=\n\n/-- The negation of an additive group homomorphism is an additive group homomorphism if the target is commutative. -/\ntheorem {α : Type u_1} {β : Type u_2} [add_group α] [add_comm_group β] {f : α → β} (hf : is_add_group_hom f) : is_add_group_hom (λ (a : α), -f a) :=\n\n/-- If `R` has characteristic `0`, then so does Frac(R). -/\ntheorem (R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [char_zero R] : char_zero K :=\n\n/--  If `i : R → K` is a ring homomorphism, `f` is a polynomial with coefficients in `R`, `a, b` are elements of `R`, with `i b` invertible, then there is a `D ∈ R` such that `b ^ f.nat_degree * f (a / b)` equals `i D`. -/\ntheorem {R : Type u_1} {K : Type u_2} [semiring R] [comm_semiring K] {b : R} {bi : K} (i : R →+* K) (f : polynomial R) (a : R) (bu : bi * ⇑i b = 1) : denoms_clearable a b f.nat_degree f i :=\n\n/-- The range of a surjective ring homomorphism is the whole of the codomain. -/\ntheorem {R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] (f : R →+* S) (hf : function.surjective ⇑f) : f.srange = ⊤ :=\n\n/-- The range of a surjective ring homomorphism is the whole of the codomain. -/\ntheorem {R : Type u} {S : Type v} [ring R] [ring S] (f : R →+* S) (hf : function.surjective ⇑f) : f.range = ⊤ :=\n\n/--  A ring homomorphism f : Z[X_1, X_2, ...] → R is determined by the evaluations f(X_1), f(X_2), ... -/\ntheorem {S : Type v} [comm_ring S] {R : Type u} (c : ℤ →+* S) (f : mv_polynomial R ℤ →+* S) (x : mv_polynomial R ℤ) : mv_polynomial.eval₂ c (⇑f ∘ mv_polynomial.X) x = ⇑f x :=\n\n/-- If an element maps to zero under a ring homomorphism, then it is zero. -/\ntheorem "}
{"text": "Implication `→` is symmetric. If `P → Q` then `Q → P`.", "fullPrompt": "/-- Implication `→` is transitive. If `P → Q` and `Q → R` then `P → R`. -/\ntheorem {p q r : Prop} (h₁ : implies p q) (h₂ : implies q r) : implies p r :=\n\n/-- Modus tollens. If an implication is true, then so is its contrapositive. -/\ntheorem {a b : Prop} (h₁ : a → b) (h₂ : ¬b) : ¬a :=\n\n/-- If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. -/\ntheorem {α : Type u_1} [monoid α] {p q : α} (hp : irreducible p) (hq : irreducible q) : p ∣ q → q ∣ p :=\n\n/-- See `inv_lt_inv_of_lt` for the implication from right-to-left with one fewer assumption. -/\ntheorem {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ < b⁻¹ ↔ b < a :=\n\n/-- monotonicity of `≤` with respect to `→` -/\ntheorem {α : Type u} {a b c d : α} [preorder α] (hca : c ≤ a) (hbd : b ≤ d) : a ≤ b → c ≤ d :=\n\n/--  If a reflexive relation `r : α → α → Prop` holds over `x y : α`, then it holds whether or not `x ≠ y`. -/\ntheorem {α : Type u_1} {r : α → α → Prop} (h : reflexive r) {x y : α} : x ≠ y → r x y ↔ r x y :=\n\n/-- Composing two associative operations of `f : α → α → α` on the left is equal to an associative operation on the left. -/\ntheorem {α : Type u_1} (f : α → α → α) [is_associative α f] (x y : α) : f x ∘ f y = f (f x y) :=\n\n/--  One of de Morgan's laws: the negation of a conjunction is logically equivalent to the disjunction of the negations. -/\ntheorem {a b : Prop} : ¬(a ∧ b) ↔ ¬a ∨ ¬b :=\n\n/-- Negation of the condition `P : Prop` in a `dite` is the same as swapping the branches. -/\ntheorem {α : Sort u_1} (P : Prop) [decidable P] (x : ¬P → α) (y : ¬¬P → α) : dite (¬P) x y = dite P (λ (h : P), y _) x :=\n\n/-- `∨` distributes over `∧` (on the right). -/\ntheorem {a b c : Prop} : a ∧ b ∨ c ↔ (a ∨ c) ∧ (b ∨ c) :=\n\n/-- See `inv_le_inv_of_le` for the implication from right-to-left with one fewer assumption. -/\ntheorem {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ ≤ b⁻¹ ↔ b ≤ a :=\n\n/-- `∨` distributes over `∧` (on the left). -/\ntheorem {a b c : Prop} : a ∨ b ∧ c ↔ (a ∨ b) ∧ (a ∨ c) :=\n\n/-- Implication `→` is symmetric. If `P → Q` then `Q → P`. -/\ntheorem "}
{"text": "Two natural numbers are equal if and only if they are both divisible by some prime number.", "fullPrompt": "/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- Two natural numbers are equal if and only if the have the same divisors. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem  : set.inj_on nat.factorization {x : ℕ | x ≠ 0} :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime dividing it. -/\ntheorem {n : ℕ} : is_prime_pow n ↔ ∃! (p : ℕ), nat.prime p ∧ p ∣ n :=\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/\ntheorem {m n : ℕ} : m ∣ m + n ↔ m ∣ n :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- A natural number `m` divides the sum `n + m` if and only if `m` divides `n`. -/\ntheorem {m n : ℕ} : m ∣ n + m ↔ m ∣ n :=\n\n/-- `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)` for some `k`. -/\ntheorem (m : ℕ) {n : ℕ} (hn : 0 < n) : (∃ (k : ℕ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a natural `k` such that `n` can be written as `p^(k+1)`. -/\ntheorem {R : Type u_1} [comm_monoid_with_zero R] (n : R) : is_prime_pow n ↔ ∃ (p : R) (k : ℕ), prime p ∧ p ^ (k + 1) = n :=\n\n/-- If `n > 0` then `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)`  for some `k`. -/\ntheorem (m : ℤ) {n : ℤ} (hn : 0 < n) : (∃ (k : ℤ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : ℕ) [hq : exp_char R q] : nat.prime q ∨ q = 1 :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`. -/\ntheorem (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem {n : ℕ} (h : n ≠ 0) (d : ℕ) : ∃ᶠ (m : ℕ) in filter.at_top, m ≡ d [MOD n] :=\n\n/--  If a small natural number is divisible by a larger natural number, the small number is zero. -/\ntheorem {a b : ℕ} (w : a ∣ b) (h : b < a) : b = 0 :=\n\n/-- Two natural numbers are equal if and only if they are both divisible by some prime number. -/\ntheorem "}
