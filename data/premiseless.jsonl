{"typeGroup": "∀ (p : Prop) [h : Decidable p] {h₁ : (a : p) → Sort u_1} {h₂ : (a : ¬ p) → Sort u_1} (h₃ : p) , h₁ h₃ = Decidable.recOn h h₂ h₁", "type": "∀ (p : Prop) [h : Decidable p] {h₁ : (a : p) → Sort u_1} {h₂ : (a : ¬ p) → Sort u_1} (h₃ : p) , h₁ h₃ = Decidable.recOn h h₂ h₁", "terms": [{"value": "p", "isProp": true, "context": ["(p : Prop)", "[h : Decidable (p : Prop)]", "{h₁ : (a : p) → Sort u_1}", "{h₂ : (a : ¬ (p : Prop)) → Sort u_1}", "(h₃ : p)"]}], "namedLemmas": [], "name": "Decidable.recOn_true.proof_1", "lemmas": [{"prop": "∀ (h : p) , h₁ h₃ = h₁ h₃", "context": ["(p : Prop)", "[h : Decidable (p : Prop)]", "{h₁ : (a : p) → Sort u_1}", "{h₂ : (a : ¬ (p : Prop)) → Sort u_1}", "(h₃ : p)"]}], "ids": [], "context": []}
{"typeGroup": "∀ {R : Type u_1} {A : Type u_2} [inst : CommRing R] [inst_1 : Ring A] [inst_2 : IsDomain A] [inst_3 : Algebra R A] (S : Subalgebra R A) , IsDomain {x : A // x ∈ Subalgebra.toSubring S}", "type": "∀ {R : Type u_1} {A : Type u_2} [inst : CommRing R] [inst_1 : Ring A] [inst_2 : IsDomain A] [inst_3 : Algebra R A] (S : Subalgebra R A) , IsDomain {x : A // x ∈ Subalgebra.toSubring S}", "terms": [{"value": "{x : A // x ∈ Subalgebra.toSubring S}", "isProp": false, "context": ["{R : Type u_1}", "{A : Type u_2}", "[CommRing R]", "[Ring A]", "[IsDomain A]", "[Algebra R A]", "(S : Subalgebra R A)"]}, {"value": "IsDomain {x : A // x ∈ Subalgebra.toSubring S}", "isProp": true, "context": ["{R : Type u_1}", "{A : Type u_2}", "[CommRing R]", "[Ring A]", "[IsDomain A]", "[Algebra R A]", "(S : Subalgebra R A)"]}], "namedLemmas": [], "name": "Subalgebra.isDomain.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ (p : Prop) (x : p ⊓ p ᶜ) , ⊥", "type": "∀ (p : Prop) (x : p ⊓ p ᶜ) , ⊥", "terms": [{"value": "p", "isProp": true, "context": ["(p : Prop)", "(x : (p : Prop) ⊓ ((p : Prop) ᶜ : Prop))"]}], "namedLemmas": [], "name": "Prop.booleanAlgebra.proof_1", "lemmas": [{"prop": "∀ (Hp : p) (Hpc : p ᶜ) , False", "context": ["(p : Prop)", "(x : (p : Prop) ⊓ ((p : Prop) ᶜ : Prop))"]}], "ids": [], "context": []}
{"typeGroup": "∀ (x : Set Prop) (a : Prop) (h : a ∈ x) (p : infₛ x) , a", "type": "∀ (x : Set Prop) (a : Prop) (h : a ∈ x) (p : infₛ x) , a", "terms": [{"value": "a", "isProp": true, "context": ["(x : Set Prop)", "(a : Prop)", "(h : (a : Prop) ∈ x)", "(p : infₛ x)"]}], "namedLemmas": [], "name": "Prop.completeLattice.proof_3", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ {a : Prop} (H : ∀ (b : Prop) (a_1 : ∀ (a : a) , b) , a) , a", "type": "∀ {a : Prop} (H : ∀ (b : Prop) (a_1 : ∀ (a : a) , b) , a) , a", "terms": [{"value": "a", "isProp": true, "context": ["{a : Prop}", "(H : ∀ (b : Prop) (a_1 : ∀ (a : a) , b) , a)"]}], "namedLemmas": [], "name": "peirce'", "lemmas": [{"prop": "∀ (a_1 : a) , a", "context": ["{a : Prop}", "(H : ∀ (b : Prop) (a_1 : ∀ (a : a) , b) , a)"]}], "ids": [], "context": []}
{"typeGroup": "∀ {a : Prop} {b : Prop} [inst : Decidable a] (h : ∀ (a : a) , b) , b ∨ ¬ a", "type": "∀ {a : Prop} {b : Prop} [inst : Decidable a] (h : ∀ (a : a) , b) , b ∨ ¬ a", "terms": [{"value": "a", "isProp": true, "context": ["{a : Prop}", "{b : Prop}", "[Decidable (a : Prop)]", "(h : ∀ (a : a) , b)"]}], "namedLemmas": [], "name": "Decidable.or_not_of_imp", "lemmas": [{"prop": "∀ (h : b) , b ∨ ¬ a", "context": ["{a : Prop}", "{b : Prop}", "[Decidable (a : Prop)]", "(h : ∀ (a : a) , b)"]}, {"prop": "∀ (a_1 : a) , b ∨ ¬ a", "context": ["{a : Prop}", "{b : Prop}", "[Decidable (a : Prop)]", "(h : ∀ (a : a) , b)"]}, {"prop": "∀ (h : ¬ a) , b ∨ ¬ a", "context": ["{a : Prop}", "{b : Prop}", "[Decidable (a : Prop)]", "(h : ∀ (a : a) , b)"]}], "ids": [], "context": []}
{"typeGroup": "∀ {G : Type u_1} [inst : Group G] {α : Type u_2} [inst_1 : MulAction G α] [inst_2 : FaithfulSMul G α] (S : Subgroup G) , FaithfulSMul {x : G // x ∈ Subgroup.toSubmonoid S} α", "type": "∀ {G : Type u_1} [inst : Group G] {α : Type u_2} [inst_1 : MulAction G α] [inst_2 : FaithfulSMul G α] (S : Subgroup G) , FaithfulSMul {x : G // x ∈ Subgroup.toSubmonoid S} α", "terms": [{"value": "{x : G // x ∈ Subgroup.toSubmonoid S}", "isProp": false, "context": ["{G : Type u_1}", "[Group G]", "{α : Type u_2}", "[MulAction G α]", "[FaithfulSMul G α]", "(S : Subgroup G)"]}, {"value": "FaithfulSMul {x : G // x ∈ Subgroup.toSubmonoid S} α", "isProp": true, "context": ["{G : Type u_1}", "[Group G]", "{α : Type u_2}", "[MulAction G α]", "[FaithfulSMul G α]", "(S : Subgroup G)"]}], "namedLemmas": [], "name": "Subgroup.instFaithfulSMulSubtypeMemSubgroupInstMembershipInstSetLikeSubgroupSmulToMulOneClassToMonoidToDivInvMonoidToSMulToSubmonoid.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "OrderedSub WithTop NNReal", "type": "OrderedSub WithTop NNReal", "terms": [{"value": "WithTop NNReal", "isProp": false, "context": []}, {"value": "OrderedSub WithTop NNReal", "isProp": true, "context": []}], "namedLemmas": [], "name": "ENNReal.instOrderedSubENNRealToLEToPreorderToPartialOrderToCompleteSemilatticeInfToCompleteLatticeInstCompleteLinearOrderENNRealToAddToDistribToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToOrderedSemiringToOrderedCommSemiringInstCanonicallyOrderedCommSemiringENNRealInstSubENNReal.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ {var : String} {β : (a : Prop) → Prop} (h : SlimCheck.NamedBinder var ∀ (p : Prop) , β p) (b : Bool) , β b = true", "type": "∀ {var : String} {β : (a : Prop) → Prop} (h : SlimCheck.NamedBinder var ∀ (p : Prop) , β p) (b : Bool) , β b = true", "terms": [{"value": "b = true", "isProp": true, "context": ["{var : String}", "{β : (a : Prop) → Prop}", "(h : SlimCheck.NamedBinder var (∀ (p : Prop) , β (p : Prop) : Prop))", "(b : Bool)"]}], "namedLemmas": [], "name": "SlimCheck.Testable.propVarTestable.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ (a₀ : Type u_1) (a₁ : Type u_1) (a₂ : Type u_1) {n : ℕ} , IsEmpty PEmpty", "type": "∀ (a₀ : Type u_1) (a₁ : Type u_1) (a₂ : Type u_1) {n : ℕ} , IsEmpty PEmpty", "terms": [{"value": "IsEmpty PEmpty", "isProp": true, "context": ["(a₀ : Type u_1)", "(a₁ : Type u_1)", "(a₂ : Type u_1)", "{n : ℕ}"]}], "namedLemmas": [], "name": "FirstOrder.Sequence₂.instIsEmptySequence₂HAddNatInstHAddInstAddNatOfNat.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ {G : Type u_1} [inst : Group G] {α : Type u_2} {β : Type u_3} [inst_1 : SMul α β] [inst_2 : MulAction G α] [inst_3 : MulAction G β] [inst_4 : IsScalarTower G α β] (S : Subgroup G) , IsScalarTower {x : G // x ∈ Subgroup.toSubmonoid S} α β", "type": "∀ {G : Type u_1} [inst : Group G] {α : Type u_2} {β : Type u_3} [inst_1 : SMul α β] [inst_2 : MulAction G α] [inst_3 : MulAction G β] [inst_4 : IsScalarTower G α β] (S : Subgroup G) , IsScalarTower {x : G // x ∈ Subgroup.toSubmonoid S} α β", "terms": [{"value": "{x : G // x ∈ Subgroup.toSubmonoid S}", "isProp": false, "context": ["{G : Type u_1}", "[Group G]", "{α : Type u_2}", "{β : Type u_3}", "[SMul α β]", "[MulAction G α]", "[MulAction G β]", "[IsScalarTower G α β]", "(S : Subgroup G)"]}, {"value": "IsScalarTower {x : G // x ∈ Subgroup.toSubmonoid S} α β", "isProp": true, "context": ["{G : Type u_1}", "[Group G]", "{α : Type u_2}", "{β : Type u_3}", "[SMul α β]", "[MulAction G α]", "[MulAction G β]", "[IsScalarTower G α β]", "(S : Subgroup G)"]}], "namedLemmas": [], "name": "Subgroup.instIsScalarTowerSubtypeMemSubgroupInstMembershipInstSetLikeSubgroupSmulToMulOneClassToMonoidToDivInvMonoidToSMulToSubmonoidSmulToSMul.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ (p : Prop) , p ∨ p = p", "type": "∀ (p : Prop) , p ∨ p = p", "terms": [{"value": "p", "isProp": true, "context": ["(p : Prop)", "(x : (p : Prop) ∨ (p : Prop))"]}], "namedLemmas": [], "name": "or_self", "lemmas": [{"prop": "∀ (h : p) , p", "context": ["(p : Prop)", "(x : (p : Prop) ∨ (p : Prop))"]}, {"prop": "∀ (h : p) , p", "context": ["(p : Prop)", "(x : (p : Prop) ∨ (p : Prop))"]}, {"prop": "∀ (x : p ∨ p) , p", "context": ["(p : Prop)"]}, {"prop": "∀ (h : p) , p ∨ p", "context": ["(p : Prop)"]}, {"prop": "p ∨ p ↔ p", "context": ["(p : Prop)"]}], "ids": [], "context": []}
{"typeGroup": "∀ {R : Type u_1} [inst : Ring R] {α : Type u_2} {β : Type u_3} [inst_1 : SMul α β] [inst_2 : SMul R β] [inst_3 : SMulCommClass α R β] (S : Subring R) , SMulCommClass α {x : R // x ∈ Subring.toSubsemiring S} β", "type": "∀ {R : Type u_1} [inst : Ring R] {α : Type u_2} {β : Type u_3} [inst_1 : SMul α β] [inst_2 : SMul R β] [inst_3 : SMulCommClass α R β] (S : Subring R) , SMulCommClass α {x : R // x ∈ Subring.toSubsemiring S} β", "terms": [{"value": "{x : R // x ∈ Subring.toSubsemiring S}", "isProp": false, "context": ["{R : Type u_1}", "[Ring R]", "{α : Type u_2}", "{β : Type u_3}", "[SMul α β]", "[SMul R β]", "[SMulCommClass α R β]", "(S : Subring R)"]}, {"value": "SMulCommClass α {x : R // x ∈ Subring.toSubsemiring S} β", "isProp": true, "context": ["{R : Type u_1}", "[Ring R]", "{α : Type u_2}", "{β : Type u_3}", "[SMul α β]", "[SMul R β]", "[SMulCommClass α R β]", "(S : Subring R)"]}], "namedLemmas": [], "name": "Subring.smulCommClass_right.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ {α : Type u} [inst : SizeOf α] (Dom : Prop) (get : (a : Dom) → α) , sizeOf {Dom := Dom , get := get} = 1 + sizeOf Dom", "type": "∀ {α : Type u} [inst : SizeOf α] (Dom : Prop) (get : (a : Dom) → α) , sizeOf {Dom := Dom , get := get} = 1 + sizeOf Dom", "terms": [{"value": "Dom", "isProp": true, "context": ["{α : Type u}", "[SizeOf α]", "(Dom : Prop)", "(get : (a : Dom) → α)"]}], "namedLemmas": [], "name": "Part.mk.sizeOf_spec", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ (p : Prop) [h : Decidable p] {h₁ : (a : p) → Sort u_1} {h₂ : (a : ¬ p) → Sort u_1} (h₃ : ¬ p) , h₂ h₃ = Decidable.recOn h h₂ h₁", "type": "∀ (p : Prop) [h : Decidable p] {h₁ : (a : p) → Sort u_1} {h₂ : (a : ¬ p) → Sort u_1} (h₃ : ¬ p) , h₂ h₃ = Decidable.recOn h h₂ h₁", "terms": [{"value": "p", "isProp": true, "context": ["(p : Prop)", "[h : Decidable (p : Prop)]", "{h₁ : (a : p) → Sort u_1}", "{h₂ : (a : ¬ (p : Prop)) → Sort u_1}", "(h₃ : ¬ (p : Prop))"]}], "namedLemmas": [], "name": "Decidable.recOn_false.proof_1", "lemmas": [{"prop": "∀ (h : ¬ p) , h₂ h₃ = h₂ h₃", "context": ["(p : Prop)", "[h : Decidable (p : Prop)]", "{h₁ : (a : p) → Sort u_1}", "{h₂ : (a : ¬ (p : Prop)) → Sort u_1}", "(h₃ : ¬ (p : Prop))"]}], "ids": [], "context": []}
{"typeGroup": "∀ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.EnoughProjectives C] [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] {X : C} {Y : C} (f : X ⟶ Y) [inst_3 : CategoryTheory.Limits.HasKernel f] , CategoryTheory.Projective CategoryTheory.Projective.over CategoryTheory.Limits.kernel f", "type": "∀ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.EnoughProjectives C] [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] {X : C} {Y : C} (f : X ⟶ Y) [inst_3 : CategoryTheory.Limits.HasKernel f] , CategoryTheory.Projective CategoryTheory.Projective.over CategoryTheory.Limits.kernel f", "terms": [{"value": "CategoryTheory.Limits.kernel f", "isProp": false, "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "[CategoryTheory.EnoughProjectives C]", "[CategoryTheory.Limits.HasZeroMorphisms C]", "{X : C}", "{Y : C}", "(f : X ⟶ Y)", "[CategoryTheory.Limits.HasKernel f]"]}, {"value": "CategoryTheory.Projective.over CategoryTheory.Limits.kernel f", "isProp": false, "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "[CategoryTheory.EnoughProjectives C]", "[CategoryTheory.Limits.HasZeroMorphisms C]", "{X : C}", "{Y : C}", "(f : X ⟶ Y)", "[CategoryTheory.Limits.HasKernel f]"]}, {"value": "CategoryTheory.Projective CategoryTheory.Projective.over CategoryTheory.Limits.kernel f", "isProp": true, "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "[CategoryTheory.EnoughProjectives C]", "[CategoryTheory.Limits.HasZeroMorphisms C]", "{X : C}", "{Y : C}", "(f : X ⟶ Y)", "[CategoryTheory.Limits.HasKernel f]"]}], "namedLemmas": [], "name": "CategoryTheory.Projective.instProjectiveSyzygies.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace β] [inst_1 : Ring α] [inst_2 : AddCommGroup β] [inst_3 : Module α β] [inst_4 : TopologicalAddGroup β] (S : Submodule α β) , TopologicalAddGroup {x : β // x ∈ Submodule.toAddSubgroup S}", "type": "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace β] [inst_1 : Ring α] [inst_2 : AddCommGroup β] [inst_3 : Module α β] [inst_4 : TopologicalAddGroup β] (S : Submodule α β) , TopologicalAddGroup {x : β // x ∈ Submodule.toAddSubgroup S}", "terms": [{"value": "{x : β // x ∈ Submodule.toAddSubgroup S}", "isProp": false, "context": ["{α : Type u_1}", "{β : Type u_2}", "[TopologicalSpace β]", "[Ring α]", "[AddCommGroup β]", "[Module α β]", "[TopologicalAddGroup β]", "(S : Submodule α β)"]}, {"value": "TopologicalAddGroup {x : β // x ∈ Submodule.toAddSubgroup S}", "isProp": true, "context": ["{α : Type u_1}", "{β : Type u_2}", "[TopologicalSpace β]", "[Ring α]", "[AddCommGroup β]", "[Module α β]", "[TopologicalAddGroup β]", "(S : Submodule α β)"]}], "namedLemmas": [], "name": "Submodule.topologicalAddGroup.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "DenselyOrdered WithTop NNReal", "type": "DenselyOrdered WithTop NNReal", "terms": [{"value": "WithTop NNReal", "isProp": false, "context": []}, {"value": "DenselyOrdered WithTop NNReal", "isProp": true, "context": []}], "namedLemmas": [], "name": "ENNReal.instDenselyOrderedENNRealToLTToPreorderToPartialOrderToCompleteSemilatticeInfToCompleteLatticeInstCompleteLinearOrderENNReal.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ (d : ℕ) (h : d ≠ 0) (w : Nat.coprime Int.natAbs 0 d) , Rat.mk' 0 d = 0", "type": "∀ (d : ℕ) (h : d ≠ 0) (w : Nat.coprime Int.natAbs 0 d) , Rat.mk' 0 d = 0", "terms": [{"value": "den ≠ 0", "isProp": true, "context": ["(d : ℕ)", "(h : d ≠ 0)", "(w : Nat.coprime Int.natAbs 0 d)", "(num : ℤ)", "(num_1 : ℤ)", "(e_num : num = num_1)", "(num_2 : ℤ)", "(e_num : num = num_2)"]}, {"value": "Int.natAbs num", "isProp": false, "context": ["(d : ℕ)", "(h : d ≠ 0)", "(w : Nat.coprime Int.natAbs 0 d)", "(num : ℤ)", "(num_1 : ℤ)", "(e_num : num = num_1)", "(num_2 : ℤ)", "(e_num : num = num_2)"]}, {"value": "Nat.coprime Int.natAbs num den", "isProp": true, "context": ["(d : ℕ)", "(h : d ≠ 0)", "(w : Nat.coprime Int.natAbs 0 d)", "(num : ℤ)", "(num_1 : ℤ)", "(e_num : num = num_1)", "(num_2 : ℤ)", "(e_num : num = num_2)"]}, {"value": "den ≠ 0", "isProp": true, "context": ["(d : ℕ)", "(h : d ≠ 0)", "(w : Nat.coprime Int.natAbs 0 d)", "(num : ℤ)", "(num_1 : ℤ)", "(e_num : num = num_1)", "(den : ℕ)", "(den_1 : ℕ)", "(e_den : den = den_1)", "(den_2 : ℕ)", "(e_den : den = den_2)"]}, {"value": "Int.natAbs num", "isProp": false, "context": ["(d : ℕ)", "(h : d ≠ 0)", "(w : Nat.coprime Int.natAbs 0 d)", "(num : ℤ)", "(num_1 : ℤ)", "(e_num : num = num_1)", "(den : ℕ)", "(den_1 : ℕ)", "(e_den : den = den_1)", "(den_2 : ℕ)", "(e_den : den = den_2)"]}, {"value": "Nat.coprime Int.natAbs num den", "isProp": true, "context": ["(d : ℕ)", "(h : d ≠ 0)", "(w : Nat.coprime Int.natAbs 0 d)", "(num : ℤ)", "(num_1 : ℤ)", "(e_num : num = num_1)", "(den : ℕ)", "(den_1 : ℕ)", "(e_den : den = den_1)", "(den_2 : ℕ)", "(e_den : den = den_2)"]}, {"value": "Rat.num 0", "isProp": false, "context": ["(d : ℕ)", "(h : d ≠ 0)", "(w : Nat.coprime Int.natAbs 0 d)"]}, {"value": "Rat.den 0", "isProp": false, "context": ["(d : ℕ)", "(h : d ≠ 0)", "(w : Nat.coprime Int.natAbs 0 d)"]}], "namedLemmas": [], "name": "Rat.zero_mk", "lemmas": [{"prop": "∀ (den_nz : autoParam den ≠ 0 _auto._@.Std.Data.Rat.Basic._hyg.4) (reduced : autoParam Nat.coprime Int.natAbs num den _auto._@.Std.Data.Rat.Basic._hyg.33) , Rat.mk' num den = Rat.mk' num den", "context": ["(d : ℕ)", "(h : d ≠ 0)", "(w : Nat.coprime Int.natAbs 0 d)", "(num : ℤ)", "(num_1 : ℤ)", "(e_num : num = num_1)", "(den : ℕ)", "(den_1 : ℕ)", "(e_den : den = den_1)"]}, {"prop": "∀ (den : ℕ) (den_1 : ℕ) (e_den : den = den_1) (den_nz : autoParam den ≠ 0 _auto._@.Std.Data.Rat.Basic._hyg.4) (reduced : autoParam Nat.coprime Int.natAbs num den _auto._@.Std.Data.Rat.Basic._hyg.33) , Rat.mk' num den = Rat.mk' num den_1", "context": ["(d : ℕ)", "(h : d ≠ 0)", "(w : Nat.coprime Int.natAbs 0 d)", "(num : ℤ)", "(num_1 : ℤ)", "(e_num : num = num_1)"]}, {"prop": "∀ (num : ℤ) (num_1 : ℤ) (e_num : num = num_1) (den : ℕ) (den_1 : ℕ) (e_den : den = den_1) (den_nz : autoParam den ≠ 0 _auto._@.Std.Data.Rat.Basic._hyg.4) (reduced : autoParam Nat.coprime Int.natAbs num den _auto._@.Std.Data.Rat.Basic._hyg.33) , Rat.mk' num den = Rat.mk' num_1 den_1", "context": ["(d : ℕ)", "(h : d ≠ 0)", "(w : Nat.coprime Int.natAbs 0 d)"]}, {"prop": "∀ {α : Type} (x : ℕ) [self : OfNat α x] , OfNat.ofNat x = OfNat.ofNat x", "context": ["(d : ℕ)", "(h : d ≠ 0)", "(w : Nat.coprime Int.natAbs 0 d)"]}, {"prop": "0 = 0", "context": ["(d : ℕ)", "(h : d ≠ 0)", "(w : Nat.coprime Int.natAbs 0 d)"]}], "ids": [], "context": []}
{"typeGroup": "∀ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : NoZeroDivisors A] [inst_3 : Algebra R A] (S : Subalgebra R A) , NoZeroDivisors {x : A // x ∈ Subalgebra.toSubsemiring S}", "type": "∀ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : NoZeroDivisors A] [inst_3 : Algebra R A] (S : Subalgebra R A) , NoZeroDivisors {x : A // x ∈ Subalgebra.toSubsemiring S}", "terms": [{"value": "{x : A // x ∈ Subalgebra.toSubsemiring S}", "isProp": false, "context": ["{R : Type u_1}", "{A : Type u_2}", "[CommSemiring R]", "[Semiring A]", "[NoZeroDivisors A]", "[Algebra R A]", "(S : Subalgebra R A)"]}, {"value": "NoZeroDivisors {x : A // x ∈ Subalgebra.toSubsemiring S}", "isProp": true, "context": ["{R : Type u_1}", "{A : Type u_2}", "[CommSemiring R]", "[Semiring A]", "[NoZeroDivisors A]", "[Algebra R A]", "(S : Subalgebra R A)"]}], "namedLemmas": [], "name": "Subalgebra.noZeroDivisors.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ {X : Type u_1} [inst : Infinite X] , Infinite Option X", "type": "∀ {X : Type u_1} [inst : Infinite X] , Infinite Option X", "terms": [{"value": "Option X", "isProp": false, "context": ["{X : Type u_1}", "[Infinite X]"]}, {"value": "Infinite Option X", "isProp": true, "context": ["{X : Type u_1}", "[Infinite X]"]}], "namedLemmas": [], "name": "Alexandroff.infinite.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ {α : Type u_1} {n : ℕ} , IsEmpty FirstOrder.Language.Functions FirstOrder.Language.constantsOn α n + 1", "type": "∀ {α : Type u_1} {n : ℕ} , IsEmpty FirstOrder.Language.Functions FirstOrder.Language.constantsOn α n + 1", "terms": [{"value": "IsEmpty PEmpty", "isProp": true, "context": ["{α : Type u_1}", "{n : ℕ}"]}, {"value": "IsEmpty PEmpty", "isProp": true, "context": ["{α : Type u_1}", "{n : ℕ}", "(n : ℕ)"]}, {"value": "IsEmpty PEmpty", "isProp": true, "context": ["{α : Type u_1}", "{n : ℕ}", "(n : ℕ)", "(x : ℕ)"]}], "namedLemmas": [], "name": "FirstOrder.Language.isEmpty_functions_constantsOn_succ.proof_1", "lemmas": [{"prop": "IsEmpty PEmpty", "context": ["{α : Type u_1}", "{n : ℕ}"]}, {"prop": "IsEmpty PEmpty", "context": ["{α : Type u_1}", "{n : ℕ}", "(n : ℕ)"]}, {"prop": "∀ (x : ℕ) , IsEmpty PEmpty", "context": ["{α : Type u_1}", "{n : ℕ}", "(n : ℕ)"]}, {"prop": "∀ (n : ℕ) , IsEmpty FirstOrder.Language.Functions FirstOrder.Language.constantsOn α Nat.succ n + 1", "context": ["{α : Type u_1}", "{n : ℕ}"]}], "ids": [], "context": []}
{"typeGroup": "∀ {R : Type u_1} [inst : Ring R] {α : Type u_2} {β : Type u_3} [inst_1 : SMul R β] [inst_2 : SMul α β] [inst_3 : SMulCommClass R α β] (S : Subring R) , SMulCommClass {x : R // x ∈ Subring.toSubsemiring S} α β", "type": "∀ {R : Type u_1} [inst : Ring R] {α : Type u_2} {β : Type u_3} [inst_1 : SMul R β] [inst_2 : SMul α β] [inst_3 : SMulCommClass R α β] (S : Subring R) , SMulCommClass {x : R // x ∈ Subring.toSubsemiring S} α β", "terms": [{"value": "{x : R // x ∈ Subring.toSubsemiring S}", "isProp": false, "context": ["{R : Type u_1}", "[Ring R]", "{α : Type u_2}", "{β : Type u_3}", "[SMul R β]", "[SMul α β]", "[SMulCommClass R α β]", "(S : Subring R)"]}, {"value": "SMulCommClass {x : R // x ∈ Subring.toSubsemiring S} α β", "isProp": true, "context": ["{R : Type u_1}", "[Ring R]", "{α : Type u_2}", "{β : Type u_3}", "[SMul R β]", "[SMul α β]", "[SMulCommClass R α β]", "(S : Subring R)"]}], "namedLemmas": [], "name": "Subring.smulCommClass_left.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ (x : Set Prop) (x_1 : Prop) (h : ∀ (b : Prop) (a : b ∈ x) , x_1 ≤ b) (p : x_1) (b : Prop) (hb : b ∈ x) , b", "type": "∀ (x : Set Prop) (x_1 : Prop) (h : ∀ (b : Prop) (a : b ∈ x) , x_1 ≤ b) (p : x_1) (b : Prop) (hb : b ∈ x) , b", "terms": [{"value": "b", "isProp": true, "context": ["(x : Set Prop)", "(x_1 : Prop)", "(h : ∀ (b : Prop) (a : (b : Prop) ∈ x) , (x_1 : Prop) ≤ (b : Prop))", "(p : x_1)", "(b : Prop)", "(hb : (b : Prop) ∈ x)"]}], "namedLemmas": [], "name": "Prop.completeLattice.proof_4", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ (p : Prop) (q : Prop) [d₁ : Decidable p] [d₂ : Decidable q] , ¬ p ∧ q ↔ ¬ p ∨ ¬ q", "type": "∀ (p : Prop) (q : Prop) [d₁ : Decidable p] [d₂ : Decidable q] , ¬ p ∧ q ↔ ¬ p ∨ ¬ q", "terms": [{"value": "p", "isProp": true, "context": ["(p : Prop)", "(q : Prop)", "[d₁ : Decidable (p : Prop)]", "[d₂ : Decidable (q : Prop)]", "(h : ¬ ((p : Prop) ∧ (q : Prop) : Prop))"]}, {"value": "q", "isProp": true, "context": ["(p : Prop)", "(q : Prop)", "[d₁ : Decidable (p : Prop)]", "[d₂ : Decidable (q : Prop)]", "(h : ¬ ((p : Prop) ∧ (q : Prop) : Prop))"]}, {"value": "p", "isProp": true, "context": ["(p : Prop)", "(q : Prop)", "[d₁ : Decidable (p : Prop)]", "[d₂ : Decidable (q : Prop)]", "(h : (¬ (p : Prop) : Prop) ∨ (¬ (q : Prop) : Prop))", "(x : (p : Prop) ∧ (q : Prop))", "(hp : p)", "(hq : q)"]}, {"value": "q", "isProp": true, "context": ["(p : Prop)", "(q : Prop)", "[d₁ : Decidable (p : Prop)]", "[d₂ : Decidable (q : Prop)]", "(h : (¬ (p : Prop) : Prop) ∨ (¬ (q : Prop) : Prop))", "(x : (p : Prop) ∧ (q : Prop))", "(hp : p)", "(hq : q)"]}], "namedLemmas": [], "name": "Decidable.not_and_iff_or_not", "lemmas": [{"prop": "p ∧ q", "context": ["(p : Prop)", "(q : Prop)", "[d₁ : Decidable (p : Prop)]", "[d₂ : Decidable (q : Prop)]", "(h : ¬ ((p : Prop) ∧ (q : Prop) : Prop))", "(h₁ : p)", "(h₂ : q)"]}, {"prop": "∀ (h₁ : p) (h₂ : q) , ¬ p ∨ ¬ q", "context": ["(p : Prop)", "(q : Prop)", "[d₁ : Decidable (p : Prop)]", "[d₂ : Decidable (q : Prop)]", "(h : ¬ ((p : Prop) ∧ (q : Prop) : Prop))"]}, {"prop": "∀ (x : Decidable p) (h₂ : ¬ q) , ¬ p ∨ ¬ q", "context": ["(p : Prop)", "(q : Prop)", "[d₁ : Decidable (p : Prop)]", "[d₂ : Decidable (q : Prop)]", "(h : ¬ ((p : Prop) ∧ (q : Prop) : Prop))"]}, {"prop": "∀ (h₁ : ¬ p) (x : Decidable q) , ¬ p ∨ ¬ q", "context": ["(p : Prop)", "(q : Prop)", "[d₁ : Decidable (p : Prop)]", "[d₂ : Decidable (q : Prop)]", "(h : ¬ ((p : Prop) ∧ (q : Prop) : Prop))"]}, {"prop": "∀ (h : ¬ p ∧ q) , ¬ p ∨ ¬ q", "context": ["(p : Prop)", "(q : Prop)", "[d₁ : Decidable (p : Prop)]", "[d₂ : Decidable (q : Prop)]"]}, {"prop": "∀ (h : ¬ p) , False", "context": ["(p : Prop)", "(q : Prop)", "[d₁ : Decidable (p : Prop)]", "[d₂ : Decidable (q : Prop)]", "(h : (¬ (p : Prop) : Prop) ∨ (¬ (q : Prop) : Prop))", "(x : (p : Prop) ∧ (q : Prop))", "(hp : p)", "(hq : q)"]}, {"prop": "∀ (h : ¬ q) , False", "context": ["(p : Prop)", "(q : Prop)", "[d₁ : Decidable (p : Prop)]", "[d₂ : Decidable (q : Prop)]", "(h : (¬ (p : Prop) : Prop) ∨ (¬ (q : Prop) : Prop))", "(x : (p : Prop) ∧ (q : Prop))", "(hp : p)", "(hq : q)"]}, {"prop": "∀ (hp : p) (hq : q) , False", "context": ["(p : Prop)", "(q : Prop)", "[d₁ : Decidable (p : Prop)]", "[d₂ : Decidable (q : Prop)]", "(h : (¬ (p : Prop) : Prop) ∨ (¬ (q : Prop) : Prop))", "(x : (p : Prop) ∧ (q : Prop))"]}, {"prop": "∀ (h : ¬ p ∨ ¬ q) (x : p ∧ q) , False", "context": ["(p : Prop)", "(q : Prop)", "[d₁ : Decidable (p : Prop)]", "[d₂ : Decidable (q : Prop)]"]}], "ids": [], "context": []}
{"typeGroup": "∀ {α : Type u_1} [inst : MetricSpace α] {s : TopologicalSpace.Opens α} , T0Space {x : α // x ∈ s}", "type": "∀ {α : Type u_1} [inst : MetricSpace α] {s : TopologicalSpace.Opens α} , T0Space {x : α // x ∈ s}", "terms": [{"value": "{x : α // x ∈ s}", "isProp": false, "context": ["{α : Type u_1}", "[MetricSpace α]", "{s : TopologicalSpace.Opens α}"]}, {"value": "T0Space {x : α // x ∈ s}", "isProp": true, "context": ["{α : Type u_1}", "[MetricSpace α]", "{s : TopologicalSpace.Opens α}"]}], "namedLemmas": [], "name": "TopologicalSpace.Opens.CompleteCopy.instT0SpaceCompleteCopyInstTopologicalSpaceCompleteCopy.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "Nontrivial ℤ", "type": "Nontrivial ℤ", "terms": [{"value": "ℤ", "isProp": false, "context": []}, {"value": "Nontrivial ℤ", "isProp": true, "context": []}], "namedLemmas": [], "name": "Int.euclideanDomain.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] {α : Type u_3} {β : Type u_4} [inst_3 : SMul α β] [inst_4 : SMul A α] [inst_5 : SMul A β] [inst_6 : IsScalarTower A α β] (S : Subalgebra R A) , IsScalarTower {x : A // x ∈ Subalgebra.toSubsemiring S} α β", "type": "∀ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] {α : Type u_3} {β : Type u_4} [inst_3 : SMul α β] [inst_4 : SMul A α] [inst_5 : SMul A β] [inst_6 : IsScalarTower A α β] (S : Subalgebra R A) , IsScalarTower {x : A // x ∈ Subalgebra.toSubsemiring S} α β", "terms": [{"value": "{x : A // x ∈ Subalgebra.toSubsemiring S}", "isProp": false, "context": ["{R : Type u_1}", "{A : Type u_2}", "[CommSemiring R]", "[Semiring A]", "[Algebra R A]", "{α : Type u_3}", "{β : Type u_4}", "[SMul α β]", "[SMul A α]", "[SMul A β]", "[IsScalarTower A α β]", "(S : Subalgebra R A)"]}, {"value": "IsScalarTower {x : A // x ∈ Subalgebra.toSubsemiring S} α β", "isProp": true, "context": ["{R : Type u_1}", "{A : Type u_2}", "[CommSemiring R]", "[Semiring A]", "[Algebra R A]", "{α : Type u_3}", "{β : Type u_4}", "[SMul α β]", "[SMul A α]", "[SMul A β]", "[IsScalarTower A α β]", "(S : Subalgebra R A)"]}], "namedLemmas": [], "name": "Subalgebra.isScalarTower_left.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "CharZero WithTop NNReal", "type": "CharZero WithTop NNReal", "terms": [{"value": "WithTop NNReal", "isProp": false, "context": []}, {"value": "CharZero WithTop NNReal", "isProp": true, "context": []}], "namedLemmas": [], "name": "ENNReal.instCharZeroENNRealToAddMonoidWithOneInstENNRealAddCommMonoidWithOne.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] {α : Type u_3} [inst_3 : SMul A α] [inst_4 : FaithfulSMul A α] (S : Subalgebra R A) , FaithfulSMul {x : A // x ∈ Subalgebra.toSubsemiring S} α", "type": "∀ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] {α : Type u_3} [inst_3 : SMul A α] [inst_4 : FaithfulSMul A α] (S : Subalgebra R A) , FaithfulSMul {x : A // x ∈ Subalgebra.toSubsemiring S} α", "terms": [{"value": "{x : A // x ∈ Subalgebra.toSubsemiring S}", "isProp": false, "context": ["{R : Type u_1}", "{A : Type u_2}", "[CommSemiring R]", "[Semiring A]", "[Algebra R A]", "{α : Type u_3}", "[SMul A α]", "[FaithfulSMul A α]", "(S : Subalgebra R A)"]}, {"value": "FaithfulSMul {x : A // x ∈ Subalgebra.toSubsemiring S} α", "isProp": true, "context": ["{R : Type u_1}", "{A : Type u_2}", "[CommSemiring R]", "[Semiring A]", "[Algebra R A]", "{α : Type u_3}", "[SMul A α]", "[FaithfulSMul A α]", "(S : Subalgebra R A)"]}], "namedLemmas": [], "name": "Subalgebra.instFaithfulSMulSubtypeMemSubalgebraInstMembershipInstSetLikeSubalgebraInstSMulSubtypeMemSubalgebraInstMembershipInstSetLikeSubalgebra.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ (x : Set Prop) (x_1 : Prop) (h : ∀ (b : Prop) (a : b ∈ x) , b ≤ x_1) (x : supₛ x) , x_1", "type": "∀ (x : Set Prop) (x_1 : Prop) (h : ∀ (b : Prop) (a : b ∈ x) , b ≤ x_1) (x : supₛ x) , x_1", "terms": [{"value": "b", "isProp": true, "context": ["(x : Set Prop)", "(x_1 : Prop)", "(h : ∀ (b : Prop) (a : (b : Prop) ∈ x) , (b : Prop) ≤ (x_1 : Prop))", "(x_2 : supₛ x)", "(b : Prop)", "(h' : (b : Prop) ∈ x)", "(p : b)"]}], "namedLemmas": [], "name": "Prop.completeLattice.proof_2", "lemmas": [{"prop": "∀ (b : Prop) (h' : b ∈ x) (p : b) , x_1", "context": ["(x : Set Prop)", "(x_1 : Prop)", "(h : ∀ (b : Prop) (a : (b : Prop) ∈ x) , (b : Prop) ≤ (x_1 : Prop))", "(x_2 : supₛ x)"]}], "ids": [], "context": []}
{"typeGroup": "DenselyOrdered WithBot WithTop ℝ", "type": "DenselyOrdered WithBot WithTop ℝ", "terms": [{"value": "ℝ", "isProp": false, "context": []}, {"value": "WithTop ℝ", "isProp": false, "context": []}, {"value": "WithBot WithTop ℝ", "isProp": false, "context": []}, {"value": "DenselyOrdered WithBot WithTop ℝ", "isProp": true, "context": []}], "namedLemmas": [], "name": "instDenselyOrderedERealToLTToPreorderInstERealPartialOrder.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ (x : Set Prop) (a : Prop) (h : a ∈ x) (p : a) , ∃ (a : Prop) , a ∈ x ∧ a", "type": "∀ (x : Set Prop) (a : Prop) (h : a ∈ x) (p : a) , ∃ (a : Prop) , a ∈ x ∧ a", "terms": [{"value": "a", "isProp": true, "context": ["(x : Set Prop)", "(a : Prop)", "(h : (a : Prop) ∈ x)", "(p : a)"]}], "namedLemmas": [], "name": "Prop.completeLattice.proof_1", "lemmas": [{"prop": "a ∈ x ∧ a", "context": ["(x : Set Prop)", "(a : Prop)", "(h : (a : Prop) ∈ x)", "(p : a)"]}], "ids": [], "context": []}
{"typeGroup": "∀ {m : (a : Type) → Type} {ω : Type} {σ : Type} [inst : Monad m] [inst_1 : LawfulMonad m] , LawfulMonad ReaderT ST.Ref ω σ m", "type": "∀ {m : (a : Type) → Type} {ω : Type} {σ : Type} [inst : Monad m] [inst_1 : LawfulMonad m] , LawfulMonad ReaderT ST.Ref ω σ m", "terms": [{"value": "ST.Ref ω σ", "isProp": false, "context": ["{m : (a : Type) → Type}", "{ω : Type}", "{σ : Type}", "[Monad m]", "[LawfulMonad m]"]}, {"value": "ReaderT ST.Ref ω σ m", "isProp": false, "context": ["{m : (a : Type) → Type}", "{ω : Type}", "{σ : Type}", "[Monad m]", "[LawfulMonad m]"]}, {"value": "LawfulMonad ReaderT ST.Ref ω σ m", "isProp": true, "context": ["{m : (a : Type) → Type}", "{ω : Type}", "{σ : Type}", "[Monad m]", "[LawfulMonad m]"]}], "namedLemmas": [], "name": "instLawfulMonadStateRefT'InstMonadStateRefT'.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ {c : Type u_1} {f₁ : Type u_1} {f₂ : Type u_1} {r₁ : Type u_2} {r₂ : Type u_2} [h1 : IsEmpty r₁] [h2 : IsEmpty r₂] , FirstOrder.Language.IsAlgebraic FirstOrder.Language.mk₂ c f₁ f₂ r₁ r₂", "type": "∀ {c : Type u_1} {f₁ : Type u_1} {f₂ : Type u_1} {r₁ : Type u_2} {r₂ : Type u_2} [h1 : IsEmpty r₁] [h2 : IsEmpty r₂] , FirstOrder.Language.IsAlgebraic FirstOrder.Language.mk₂ c f₁ f₂ r₁ r₂", "terms": [{"value": "IsEmpty PEmpty", "isProp": true, "context": ["{c : Type u_1}", "{f₁ : Type u_1}", "{f₂ : Type u_1}", "{r₁ : Type u_2}", "{r₂ : Type u_2}", "[h1 : IsEmpty r₁]", "[h2 : IsEmpty r₂]", "(n : ℕ)"]}, {"value": "IsEmpty PEmpty", "isProp": true, "context": ["{c : Type u_1}", "{f₁ : Type u_1}", "{f₂ : Type u_1}", "{r₁ : Type u_2}", "{r₂ : Type u_2}", "[h1 : IsEmpty r₁]", "[h2 : IsEmpty r₂]", "(n : ℕ)", "(n : ℕ)", "(n : ℕ)", "(x : ℕ)"]}], "namedLemmas": [], "name": "FirstOrder.Language.isAlgebraic_mk₂.proof_1", "lemmas": [{"prop": "IsEmpty PEmpty", "context": ["{c : Type u_1}", "{f₁ : Type u_1}", "{f₂ : Type u_1}", "{r₁ : Type u_2}", "{r₂ : Type u_2}", "[h1 : IsEmpty r₁]", "[h2 : IsEmpty r₂]", "(n : ℕ)"]}, {"prop": "∀ (x : ℕ) , IsEmpty PEmpty", "context": ["{c : Type u_1}", "{f₁ : Type u_1}", "{f₂ : Type u_1}", "{r₁ : Type u_2}", "{r₂ : Type u_2}", "[h1 : IsEmpty r₁]", "[h2 : IsEmpty r₂]", "(n : ℕ)", "(n : ℕ)", "(n : ℕ)"]}, {"prop": "∀ (n : ℕ) , IsEmpty FirstOrder.Language.Relations FirstOrder.Language.mk₂ c f₁ f₂ r₁ r₂ Nat.succ Nat.succ n", "context": ["{c : Type u_1}", "{f₁ : Type u_1}", "{f₂ : Type u_1}", "{r₁ : Type u_2}", "{r₂ : Type u_2}", "[h1 : IsEmpty r₁]", "[h2 : IsEmpty r₂]", "(n : ℕ)", "(n : ℕ)"]}, {"prop": "∀ (n : ℕ) , IsEmpty FirstOrder.Language.Relations FirstOrder.Language.mk₂ c f₁ f₂ r₁ r₂ Nat.succ n", "context": ["{c : Type u_1}", "{f₁ : Type u_1}", "{f₂ : Type u_1}", "{r₁ : Type u_2}", "{r₂ : Type u_2}", "[h1 : IsEmpty r₁]", "[h2 : IsEmpty r₂]", "(n : ℕ)"]}, {"prop": "∀ (n : ℕ) , IsEmpty FirstOrder.Language.Relations FirstOrder.Language.mk₂ c f₁ f₂ r₁ r₂ n", "context": ["{c : Type u_1}", "{f₁ : Type u_1}", "{f₂ : Type u_1}", "{r₁ : Type u_2}", "{r₂ : Type u_2}", "[h1 : IsEmpty r₁]", "[h2 : IsEmpty r₂]"]}], "ids": [], "context": []}
{"typeGroup": "IsWellOrder PEmpty EmptyRelation", "type": "IsWellOrder PEmpty EmptyRelation", "terms": [{"value": "IsWellOrder PEmpty EmptyRelation", "isProp": true, "context": []}], "namedLemmas": [], "name": "WellOrder.inhabited.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ {R' : Type u_1} {R : Type u_2} {A : Type u_3} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (S : Subalgebra R A) [inst_3 : Semiring R'] [inst_4 : SMul R' R] [inst_5 : Module R' A] [inst_6 : IsScalarTower R' R A] , IsScalarTower R' R {x : A // x ∈ ↑ Subalgebra.toSubmodule S}", "type": "∀ {R' : Type u_1} {R : Type u_2} {A : Type u_3} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (S : Subalgebra R A) [inst_3 : Semiring R'] [inst_4 : SMul R' R] [inst_5 : Module R' A] [inst_6 : IsScalarTower R' R A] , IsScalarTower R' R {x : A // x ∈ ↑ Subalgebra.toSubmodule S}", "terms": [{"value": "{x : A // x ∈ ↑ Subalgebra.toSubmodule S}", "isProp": false, "context": ["{R' : Type u_1}", "{R : Type u_2}", "{A : Type u_3}", "[CommSemiring R]", "[Semiring A]", "[Algebra R A]", "(S : Subalgebra R A)", "[Semiring R']", "[SMul R' R]", "[Module R' A]", "[IsScalarTower R' R A]"]}, {"value": "IsScalarTower R' R {x : A // x ∈ ↑ Subalgebra.toSubmodule S}", "isProp": true, "context": ["{R' : Type u_1}", "{R : Type u_2}", "{A : Type u_3}", "[CommSemiring R]", "[Semiring A]", "[Algebra R A]", "(S : Subalgebra R A)", "[Semiring R']", "[SMul R' R]", "[Module R' A]", "[IsScalarTower R' R A]"]}], "namedLemmas": [], "name": "Subalgebra.instIsScalarTowerSubtypeMemSubalgebraInstMembershipInstSetLikeSubalgebraToSMulZeroToZeroToMonoidWithZeroToZeroMemClassToAddZeroClassToAddMonoidToAddMonoidWithOneToAddCommMonoidWithOneToNonAssocSemiringToAddSubmonoidClassSubsemiringClassToSMulZeroClassToZeroToCommMonoidWithZeroToSMulWithZeroToMonoidWithZeroToSemiringToMulActionWithZeroToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSubsemiringInstModuleSubtypeMemSubalgebraInstMembershipInstSetLikeSubalgebraToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToNonAssocSemiringToSubsemiringToSMulToSMulZeroClassToZeroToMonoidWithZeroToSMulWithZeroToMulActionWithZeroModule'.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "CharZero WithTop ℕ", "type": "CharZero WithTop ℕ", "terms": [{"value": "ℕ", "isProp": false, "context": []}, {"value": "WithTop ℕ", "isProp": false, "context": []}, {"value": "CharZero WithTop ℕ", "isProp": true, "context": []}], "namedLemmas": [], "name": "ENat.instCharZeroENatToAddMonoidWithOneToAddCommMonoidWithOneToNonAssocSemiringToSemiringToOrderedSemiringToOrderedCommSemiringInstENatCanonicallyOrderedCommSemiring.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ {c : Type u_1} {f₁ : Type u_1} {f₂ : Type u_1} {r₁ : Type u_2} {r₂ : Type u_2} [h0 : IsEmpty c] [h1 : IsEmpty f₁] [h2 : IsEmpty f₂] , FirstOrder.Language.IsRelational FirstOrder.Language.mk₂ c f₁ f₂ r₁ r₂", "type": "∀ {c : Type u_1} {f₁ : Type u_1} {f₂ : Type u_1} {r₁ : Type u_2} {r₂ : Type u_2} [h0 : IsEmpty c] [h1 : IsEmpty f₁] [h2 : IsEmpty f₂] , FirstOrder.Language.IsRelational FirstOrder.Language.mk₂ c f₁ f₂ r₁ r₂", "terms": [{"value": "IsEmpty PEmpty", "isProp": true, "context": ["{c : Type u_1}", "{f₁ : Type u_1}", "{f₂ : Type u_1}", "{r₁ : Type u_2}", "{r₂ : Type u_2}", "[h0 : IsEmpty c]", "[h1 : IsEmpty f₁]", "[h2 : IsEmpty f₂]", "(n : ℕ)", "(n : ℕ)", "(n : ℕ)", "(x : ℕ)"]}], "namedLemmas": [], "name": "FirstOrder.Language.isRelational_mk₂.proof_1", "lemmas": [{"prop": "∀ (x : ℕ) , IsEmpty PEmpty", "context": ["{c : Type u_1}", "{f₁ : Type u_1}", "{f₂ : Type u_1}", "{r₁ : Type u_2}", "{r₂ : Type u_2}", "[h0 : IsEmpty c]", "[h1 : IsEmpty f₁]", "[h2 : IsEmpty f₂]", "(n : ℕ)", "(n : ℕ)", "(n : ℕ)"]}, {"prop": "∀ (n : ℕ) , IsEmpty FirstOrder.Language.Functions FirstOrder.Language.mk₂ c f₁ f₂ r₁ r₂ Nat.succ Nat.succ n", "context": ["{c : Type u_1}", "{f₁ : Type u_1}", "{f₂ : Type u_1}", "{r₁ : Type u_2}", "{r₂ : Type u_2}", "[h0 : IsEmpty c]", "[h1 : IsEmpty f₁]", "[h2 : IsEmpty f₂]", "(n : ℕ)", "(n : ℕ)"]}, {"prop": "∀ (n : ℕ) , IsEmpty FirstOrder.Language.Functions FirstOrder.Language.mk₂ c f₁ f₂ r₁ r₂ Nat.succ n", "context": ["{c : Type u_1}", "{f₁ : Type u_1}", "{f₂ : Type u_1}", "{r₁ : Type u_2}", "{r₂ : Type u_2}", "[h0 : IsEmpty c]", "[h1 : IsEmpty f₁]", "[h2 : IsEmpty f₂]", "(n : ℕ)"]}, {"prop": "∀ (n : ℕ) , IsEmpty FirstOrder.Language.Functions FirstOrder.Language.mk₂ c f₁ f₂ r₁ r₂ n", "context": ["{c : Type u_1}", "{f₁ : Type u_1}", "{f₂ : Type u_1}", "{r₁ : Type u_2}", "{r₂ : Type u_2}", "[h0 : IsEmpty c]", "[h1 : IsEmpty f₁]", "[h2 : IsEmpty f₂]"]}], "ids": [], "context": []}
{"typeGroup": "∀ (p : Prop) , p ∨ False = p", "type": "∀ (p : Prop) , p ∨ False = p", "terms": [{"value": "p", "isProp": true, "context": ["(p : Prop)", "(x : (p : Prop) ∨ (False : Prop))"]}], "namedLemmas": [], "name": "or_false", "lemmas": [{"prop": "∀ (h : p) , p", "context": ["(p : Prop)", "(x : (p : Prop) ∨ (False : Prop))"]}, {"prop": "∀ (x : p ∨ False) , p", "context": ["(p : Prop)"]}, {"prop": "∀ (h : p) , p ∨ False", "context": ["(p : Prop)"]}, {"prop": "p ∨ False ↔ p", "context": ["(p : Prop)"]}], "ids": [], "context": []}
{"typeGroup": "WellFoundedLT WithTop ℕ", "type": "WellFoundedLT WithTop ℕ", "terms": [{"value": "ℕ", "isProp": false, "context": []}, {"value": "WithTop ℕ", "isProp": false, "context": []}, {"value": "WellFoundedLT WithTop ℕ", "isProp": true, "context": []}], "namedLemmas": [], "name": "ENat.instWellFoundedLTENatToLTToPreorderToPartialOrderToOrderedSemiringToOrderedCommSemiringInstENatCanonicallyOrderedCommSemiring.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ {α : Type u_1} {m : Type u_2} {n : Type u_3} {R : Type u_4} [inst : TopologicalSpace R] [inst_1 : TopologicalSpace α] [inst_2 : SMul α R] [inst_3 : ContinuousSMul α R] , ContinuousSMul α (a : m) → (a : n) → R", "type": "∀ {α : Type u_1} {m : Type u_2} {n : Type u_3} {R : Type u_4} [inst : TopologicalSpace R] [inst_1 : TopologicalSpace α] [inst_2 : SMul α R] [inst_3 : ContinuousSMul α R] , ContinuousSMul α (a : m) → (a : n) → R", "terms": [{"value": "(a : m) → (a : n) → R", "isProp": false, "context": ["{α : Type u_1}", "{m : Type u_2}", "{n : Type u_3}", "{R : Type u_4}", "[TopologicalSpace R]", "[TopologicalSpace α]", "[SMul α R]", "[ContinuousSMul α R]"]}, {"value": "ContinuousSMul α (a : m) → (a : n) → R", "isProp": true, "context": ["{α : Type u_1}", "{m : Type u_2}", "{n : Type u_3}", "{R : Type u_4}", "[TopologicalSpace R]", "[TopologicalSpace α]", "[SMul α R]", "[ContinuousSMul α R]"]}], "namedLemmas": [], "name": "instContinuousSMulMatrixSmulInstTopologicalSpaceMatrix.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ {R : Type u_1} [inst : Ring R] {α : Type u_2} {β : Type u_3} [inst_1 : SMul α β] [inst_2 : SMul R α] [inst_3 : SMul R β] [inst_4 : IsScalarTower R α β] (S : Subring R) , IsScalarTower {x : R // x ∈ Subring.toSubsemiring S} α β", "type": "∀ {R : Type u_1} [inst : Ring R] {α : Type u_2} {β : Type u_3} [inst_1 : SMul α β] [inst_2 : SMul R α] [inst_3 : SMul R β] [inst_4 : IsScalarTower R α β] (S : Subring R) , IsScalarTower {x : R // x ∈ Subring.toSubsemiring S} α β", "terms": [{"value": "{x : R // x ∈ Subring.toSubsemiring S}", "isProp": false, "context": ["{R : Type u_1}", "[Ring R]", "{α : Type u_2}", "{β : Type u_3}", "[SMul α β]", "[SMul R α]", "[SMul R β]", "[IsScalarTower R α β]", "(S : Subring R)"]}, {"value": "IsScalarTower {x : R // x ∈ Subring.toSubsemiring S} α β", "isProp": true, "context": ["{R : Type u_1}", "[Ring R]", "{α : Type u_2}", "{β : Type u_3}", "[SMul α β]", "[SMul R α]", "[SMul R β]", "[IsScalarTower R α β]", "(S : Subring R)"]}], "namedLemmas": [], "name": "Subring.instIsScalarTowerSubtypeMemSubringInstMembershipInstSetLikeSubringInstSMulSubtypeMemSubringInstMembershipInstSetLikeSubringInstSMulSubtypeMemSubringInstMembershipInstSetLikeSubring.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "TopologicalSpace.SecondCountableTopology ↑ setOf fun (x : ℝ) ↦ 0 ≤ x", "type": "TopologicalSpace.SecondCountableTopology ↑ setOf fun (x : ℝ) ↦ 0 ≤ x", "terms": [{"value": "↑ setOf fun (x : ℝ) ↦ 0 ≤ x", "isProp": false, "context": []}, {"value": "TopologicalSpace.SecondCountableTopology ↑ setOf fun (x : ℝ) ↦ 0 ≤ x", "isProp": true, "context": []}], "namedLemmas": [], "name": "NNReal.instSecondCountableTopologyNNRealInstTopologicalSpaceNNReal.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "OrderedSub WithTop ℕ", "type": "OrderedSub WithTop ℕ", "terms": [{"value": "ℕ", "isProp": false, "context": []}, {"value": "WithTop ℕ", "isProp": false, "context": []}, {"value": "OrderedSub WithTop ℕ", "isProp": true, "context": []}], "namedLemmas": [], "name": "ENat.instOrderedSubENatToLEToPreorderToPartialOrderToOrderedSemiringToOrderedCommSemiringInstENatCanonicallyOrderedCommSemiringToAddToDistribToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringInstENatSub.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ {α : Type u_1} {m : Type u_2} {n : Type u_3} {R : Type u_4} [inst : TopologicalSpace R] [inst_1 : SMul α R] [inst_2 : ContinuousConstSMul α R] , ContinuousConstSMul α (a : m) → (a : n) → R", "type": "∀ {α : Type u_1} {m : Type u_2} {n : Type u_3} {R : Type u_4} [inst : TopologicalSpace R] [inst_1 : SMul α R] [inst_2 : ContinuousConstSMul α R] , ContinuousConstSMul α (a : m) → (a : n) → R", "terms": [{"value": "(a : m) → (a : n) → R", "isProp": false, "context": ["{α : Type u_1}", "{m : Type u_2}", "{n : Type u_3}", "{R : Type u_4}", "[TopologicalSpace R]", "[SMul α R]", "[ContinuousConstSMul α R]"]}, {"value": "ContinuousConstSMul α (a : m) → (a : n) → R", "isProp": true, "context": ["{α : Type u_1}", "{m : Type u_2}", "{n : Type u_3}", "{R : Type u_4}", "[TopologicalSpace R]", "[SMul α R]", "[ContinuousConstSMul α R]"]}], "namedLemmas": [], "name": "instContinuousConstSMulMatrixInstTopologicalSpaceMatrixSmul.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ {R : Type u_1} [inst : Ring R] {α : Type u_2} [inst_1 : SMul R α] [inst_2 : FaithfulSMul R α] (S : Subring R) , FaithfulSMul {x : R // x ∈ Subring.toSubsemiring S} α", "type": "∀ {R : Type u_1} [inst : Ring R] {α : Type u_2} [inst_1 : SMul R α] [inst_2 : FaithfulSMul R α] (S : Subring R) , FaithfulSMul {x : R // x ∈ Subring.toSubsemiring S} α", "terms": [{"value": "{x : R // x ∈ Subring.toSubsemiring S}", "isProp": false, "context": ["{R : Type u_1}", "[Ring R]", "{α : Type u_2}", "[SMul R α]", "[FaithfulSMul R α]", "(S : Subring R)"]}, {"value": "FaithfulSMul {x : R // x ∈ Subring.toSubsemiring S} α", "isProp": true, "context": ["{R : Type u_1}", "[Ring R]", "{α : Type u_2}", "[SMul R α]", "[FaithfulSMul R α]", "(S : Subring R)"]}], "namedLemmas": [], "name": "Subring.instFaithfulSMulSubtypeMemSubringInstMembershipInstSetLikeSubringInstSMulSubtypeMemSubringInstMembershipInstSetLikeSubring.proof_1", "lemmas": [], "ids": [], "context": []}
{"typeGroup": "∀ (p : Prop) , False ∨ p = p", "type": "∀ (p : Prop) , False ∨ p = p", "terms": [{"value": "p", "isProp": true, "context": ["(p : Prop)", "(x : (False : Prop) ∨ (p : Prop))"]}], "namedLemmas": [], "name": "false_or", "lemmas": [{"prop": "∀ (h : p) , p", "context": ["(p : Prop)", "(x : (False : Prop) ∨ (p : Prop))"]}, {"prop": "∀ (x : False ∨ p) , p", "context": ["(p : Prop)"]}, {"prop": "∀ (h : p) , False ∨ p", "context": ["(p : Prop)"]}, {"prop": "False ∨ p ↔ p", "context": ["(p : Prop)"]}], "ids": [], "context": []}
