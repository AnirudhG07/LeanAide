[
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "compact_if_all_proper_compact",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"If every proper closed set of a topological space is compact, then the space itself is compact.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If every proper closed set of a topological space is compact, then the space itself is compact.",
      "codex_time": 4.624296213994967,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem topological_space_compact_of_closed_compact (X : Type*)  [TopologicalSpace X] (h : ∀ S : Set X, IsClosed S → proper S → IsCompact S) :  IsCompact X ",
      "theorem topological_space_compact_of_closed_compact (X : Type*)  [TopologicalSpace X] (h : ∀ S : Setₓ X, IsClosed S → proper S → IsCompact S) :  IsCompact X ",
      "theorem every_proper_closed_set_compact_imply_space_compact (X : Type*) [TopologicalSpace X]  (hX : ∀ (Y : Set X), Y ≠ ∅ → IsClosed Y → IsCompact Y):  IsCompact X ",
      "theorem every_proper_closed_set_compact_imply_space_compact (X : Type*) [TopologicalSpace X]  (hX : ∀ (Y : Setₓ X), Y ≠ ∅ → IsClosed Y → IsCompact Y):  IsCompact X ",
      "theorem compact_of_every_proper_closed_is_compact (X : Type*) [TopologicalSpace X] [CompactSpace X] :  (∀ C : Set X, IsClosed C ∧ C ≠ X → IsCompact C) → IsCompact X ",
      "theorem compact_of_every_proper_closed_is_compact (X : Type*) [TopologicalSpace X] [CompactSpace X] :  (∀ C : Setₓ X, IsClosed C ∧ C ≠ X → IsCompact C) → IsCompact X ",
      "theorem compact_of_compact_proper_closed (X : Type*) [TopologicalSpace X]  (hX : ∀ (K : Set X),  IsClosed K ∧ K ≠ X → IsCompact K) : IsCompact X ",
      "theorem compact_of_compact_proper_closed (X : Type*) [TopologicalSpace X]  (hX : ∀ (K : Setₓ X),  IsClosed K ∧ K ≠ X → IsCompact K) : IsCompact X ",
      "theorem Compactness_of_nonempty_clopen_space (X : Type u) [t : TopologicalSpace X]  (P : Set X) (hP : IsClosed P) (hP_compl : IsClosed (HasCompl P)) :  IsCompact P ",
      "theorem Compactness_of_nonempty_clopen_space (X : Type u) [t : TopologicalSpace X]  (P : Setₓ X) (hP : IsClosed P) (hP_compl : IsClosed (HasCompl P)) :  IsCompact P "
    ],
    "answer": "theorem compact_if_all_proper_compact {α : Type _} [TopologicalSpace α] : (∀ (s : Set α), (s ≠ Set.univ) → IsCompact s) → CompactSpace α "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "compact_if_all_proper_compact",
      "main_prompt": "If every proper closed set of a topological space is compact, then the space itself is compact.",
      "prompt": "Natural language version: \"A closed subset of a compact set is a compact set.\" Translate the natural language version to a Lean mathlib version:\n theorem compact_of_is_closed_subset{α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) :\nis_compact t := \n\nNatural language version: \"A set `s` is compact if for every open cover of `s`, there exists a finite subcover.\" Translate the natural language version to a Lean mathlib version:\n theorem is_compact_of_finite_subcover{α : Type u} [topological_space α] {s : set α} (h : ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)) :\nis_compact s := \n\nNatural language version: \"The intersection of a compact set and a closed set is a compact set.\" Translate the natural language version to a Lean mathlib version:\n theorem is_compact.inter_right{α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) :\nis_compact (s ∩ t) := \n\nNatural language version: \"The intersection of a closed set and a compact set is a compact set.\" Translate the natural language version to a Lean mathlib version:\n theorem is_compact.inter_left{α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s) :\nis_compact (s ∩ t) := \n\nNatural language version: \"If every proper closed set of a topological space is compact, then the space itself is compact.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.782024621963501,
          "doc_string": "A closed subset of a compact set is a compact set.",
          "statement": "theorem compact_of_is_closed_subset {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) : is_compact t"
        },
        {
          "sim_score": 0.6621682643890381,
          "doc_string": "A set `s` is compact if for every open cover of `s`, there exists a finite subcover.",
          "statement": "theorem is_compact_of_finite_subcover {α : Type u} [topological_space α] {s : set α} (h : ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)) : is_compact s"
        },
        {
          "sim_score": 0.651668906211853,
          "doc_string": "The intersection of a compact set and a closed set is a compact set.",
          "statement": "theorem is_compact.inter_right {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) : is_compact (s ∩ t)"
        },
        {
          "sim_score": 0.6444039344787598,
          "doc_string": "The intersection of a closed set and a compact set is a compact set.",
          "statement": "theorem is_compact.inter_left {α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s) : is_compact (s ∩ t)"
        }
      ],
      "codex_time": 4.50850175798405,
      "search_time": 2.0355896779801697,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem is_closed.compact_iff_all_closed_subsets_are_compact{α : Type u} [TopologicalSpace α] (hα : ∀ (s : Set α) [IsClosed s], IsCompact s) : IsCompact α ↔ (∀ (s : Set α), IsClosed s → IsCompact s) ",
      "theorem is_closed.compact_iff_all_closed_subsets_are_compact{α : Type u} [TopologicalSpace α] (hα : ∀ (s : Setₓ α) [IsClosed s], IsCompact s) : IsCompact α ↔ (∀ (s : Setₓ α), IsClosed s → IsCompact s) ",
      "theorem is_compact.subset_closed{α : Type u} [TopologicalSpace α] (h : ∀ t : Set α, IsClosed t → IsCompact t → t ≠ Set.Univ → ∃ (p : α), p ∉ t) : IsCompact Set.Univ ",
      "theorem is_compact.subset_closed{α : Type u} [TopologicalSpace α] (h : ∀ t : Setₓ α, IsClosed t → IsCompact t → t ≠ Setₓ.Univ → ∃ (p : α), p ∉ t) : IsCompact Setₓ.Univ ",
      "theorem compact_of_closed_proper{α : Type u} [TopologicalSpace α] (h : ∀ s : Set α, IsClosed s → IsCompact s) (h₂ : ¬ IsClosed univ) : IsCompact univ ",
      "theorem compact_of_closed_proper{α : Type u} [TopologicalSpace α] (h : ∀ s : Setₓ α, IsClosed s → IsCompact s) (h₂ : ¬ IsClosed univ) : IsCompact univ ",
      "theorem is_compact.topological_space_epsilon{α : Type u} [TopologicalSpace α] (h : ∀ (s : Set α) (h : IsClosed s) (h0 : s ∉ {∅, univ}), IsCompact s) : IsCompact univ ",
      "theorem is_compact.topological_space_epsilon{α : Type u} [TopologicalSpace α] (h : ∀ (s : Setₓ α) (h : IsClosed s) (h0 : s ∉ {∅, univ}), IsCompact s) : IsCompact univ ",
      "theorem is_compact_of_forall_closed_subset_prop{α : Type u} [TopologicalSpace α] (h : ∀ {s : Set α}, IsClosed s → s ≠ univ → ∃ (t : Set α), IsClosed t ∧ IsCompact t ∧ s ⊆ t) : IsCompact univ ",
      "theorem is_compact_of_forall_closed_subset_prop{α : Type u} [TopologicalSpace α] (h : ∀ {s : Setₓ α}, IsClosed s → s ≠ univ → ∃ (t : Setₓ α), IsClosed t ∧ IsCompact t ∧ s ⊆ t) : IsCompact univ "
    ],
    "answer": "theorem compact_if_all_proper_compact {α : Type _} [TopologicalSpace α] : (∀ (s : Set α), (s ≠ Set.univ) → IsCompact s) → CompactSpace α "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "compact_if_all_proper_compact",
      "main_prompt": "If every proper closed set of a topological space is compact, then the space itself is compact.",
      "prompt": "Natural language version: \"If every proper closed set of a topological space is compact, then the space itself is compact.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 12.655504310998367,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem compact_of_closed_compact { X : Top } ( H : ∀ C, C ⊂ X → IsClosed C → IsCompact C ) : IsCompact X ",
      "theorem is_compact_of_closed_of_compact (X : Type) [TopologicalSpace X]    {Y : Set X} (HY : Y ⊆ X) (hY : is_closedY) (hYc : IsCompact Y) : IsCompact X ",
      "theorem is_compact_of_closed_of_compact (X : Type) [TopologicalSpace X]    {Y : Setₓ X} (HY : Y ⊆ X) (hY : is_closedY) (hYc : IsCompact Y) : IsCompact X ",
      "theorem every_proper_closed_is_compact_implies_compact [… → IsCompact]:    (Π A: Set α, IsClosed A → proper A) → IsCompact α end  -- move the underscore in the next line to the beginning -- of the line and press `cmd+enter` to make a new line after it.  -- Let's apply the theorem `compact_iff_ultrafilter_le_nhds` (lemma 3.4 in the notes) -- about ultrafilters and convergent filters in topological spaces.  --import append_unique  --def lt_set (n : ℕ) :",
      "theorem every_proper_closed_is_compact_implies_compact [… → IsCompact]:    (Π A: Setₓ α, IsClosed A → proper A) → IsCompact α end  -- move the underscore in the next line to the beginning -- of the line and press `cmd+enter` to make a new line after it.  -- Let's apply the theorem `compact_iff_ultrafilter_le_nhds` (lemma 3.4 in the notes) -- about ultrafilters and convergent filters in topological spaces.  --import append_unique  --def lt_set (n : ℕ) :",
      "theorem if_every_closed_subset_compact_then_compact :   ∀(ts : TopologicalSpace), (∀(c : Set ts.is_open), c ≠ ∅ → ∃s : finite_set (Set ts.is_open), s ⊆ c ∧ fintype.is_open_set ts.is_open (fset.sUnion s)) → IsCompact ts.is_open ",
      "theorem if_every_closed_subset_compact_then_compact :   ∀(ts : TopologicalSpace), (∀(c : Setₓ ts.is_open), c ≠ ∅ → ∃s : finite_set (Setₓ ts.is_open), s ⊆ c ∧ fintype.is_open_set ts.is_open (fset.sUnion s)) → IsCompact ts.is_open ",
      "theorem compact_if_proper_closed_is_compact { α : Type * } [ TopologicalSpace α ] : CompactSpace α ↔ ∀ s : Set α , CompactSpace s → IsClosed s → IsCompact s ",
      "theorem compact_if_proper_closed_is_compact { α : Type * } [ TopologicalSpace α ] : CompactSpace α ↔ ∀ s : Setₓ α , CompactSpace s → IsClosed s → IsCompact s "
    ],
    "answer": "theorem compact_if_all_proper_compact {α : Type _} [TopologicalSpace α] : (∀ (s : Set α), (s ≠ Set.univ) → IsCompact s) → CompactSpace α "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "fermat_two_square",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every prime that is one greater than a multiple of four can be expressed as the sum of two squares.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every prime that is one greater than a multiple of four can be expressed as the sum of two squares.",
      "codex_time": 8.657882266008528,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem sum_squares_prime_four_n_plus_one (p : ℕ) (h₁ : Prime p) (h₂ : p = 4 * n + 1):  ∃ a b : ℕ, a^2 + b^2 = p ",
      "theorem four_spans_primes (p : ℕ) (hp : Prime p) (hp_one_plus_multiple_of_four : p = 1 + 4*(↑n:ℕ)) :  ∃ j k : ℕ, j*j + k*k = p ",
      "theorem sum_of_two_squares :  ∀ (p : ℕ) (h : Prime p) (hp4 : p - 1 ∣ 4), ∃ x y : ℕ, p = x^2 + y^2 ",
      "theorem fermat_two_square (p : ℕ) (hp_odd : 1 + p % 4 = 0) (hp_prime : Prime p) :  ∃ a b : ℕ, a ^ 2 + b ^ 2 = p ",
      "theorem sum_of_squares (p : ℕ) (hp : Prime p) : p = 4*k + 1 → ∃ a b : ℕ, a^2 + b^2 = p ∧ a ≠ 0 "
    ],
    "answer": "theorem fermat_two_square : ∀ p : ℕ, Prime p → (p % 4 = 1) → ∃ a b : ℕ, a ^ 2 + b ^ 2 = p "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "fermat_two_square",
      "main_prompt": "Every prime that is one greater than a multiple of four can be expressed as the sum of two squares.",
      "prompt": "Natural language version: \" **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.prime.sq_add_sq{p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) :\n∃ (a b : ℕ), a ^ 2 + b ^ 2 = p := \n\nNatural language version: \"**Four squares theorem**\" Translate the natural language version to a Lean mathlib version:\n theorem nat.sum_four_squares(n : ℕ) :\n∃ (a b c d : ℕ), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n := \n\nNatural language version: \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.prime.mod_two_eq_one_iff_ne_two{p : ℕ} [fact (nat.prime p)] :\np % 2 = 1 ↔ p ≠ 2 := \n\nNatural language version: \"The square of the smallest prime factor of a composite number `n` is at most `n`.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.min_fac_sq_le_self{n : ℕ} (w : 0 < n) (h : ¬nat.prime n) :\nn.min_fac ^ 2 ≤ n := \n\nNatural language version: \"Every prime that is one greater than a multiple of four can be expressed as the sum of two squares.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6522289514541626,
          "doc_string": " **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**.",
          "statement": "theorem nat.prime.sq_add_sq {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p"
        },
        {
          "sim_score": 0.5913749933242798,
          "doc_string": "**Four squares theorem**",
          "statement": "theorem nat.sum_four_squares (n : ℕ) : ∃ (a b c d : ℕ), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"
        },
        {
          "sim_score": 0.49175825715065,
          "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.",
          "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2"
        },
        {
          "sim_score": 0.48426979780197144,
          "doc_string": "The square of the smallest prime factor of a composite number `n` is at most `n`.",
          "statement": "theorem nat.min_fac_sq_le_self {n : ℕ} (w : 0 < n) (h : ¬nat.prime n) : n.min_fac ^ 2 ≤ n"
        }
      ],
      "codex_time": 8.808033049979713,
      "search_time": 1.5988156869716477,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem nat.prime.sum_two_squares{p : ℕ} [Fact (Nat.Prime p)] (h : p % 4 = 3) : ∃ (x y : ℕ), p = x ^ 2 + y ^ 2 ",
      "theorem nat.prime.eq_four_mod_four_add_one{p : ℕ} [Fact (Nat.Prime p)] : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p ↔ p % 4 = 1 ",
      "theorem nat.prime.four_mul_add_one_sq_add_sq(p : ℕ) [Fact (Nat.Prime p)] (hp : p = 4 * k + 1) (k : ℕ) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p ",
      "theorem nat.prime.sq_add_sq_iff{p : ℕ} [Fact (Nat.Prime p)] : p % 4 = 1 ↔ ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p ",
      "theorem nat.prime.sq_add_sq_mod_four{p : ℕ} [Fact (Nat.Prime p)] (h : p % 4 = 3) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p "
    ],
    "answer": "theorem fermat_two_square : ∀ p : ℕ, Prime p → (p % 4 = 1) → ∃ a b : ℕ, a ^ 2 + b ^ 2 = p "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "fermat_two_square",
      "main_prompt": "Every prime that is one greater than a multiple of four can be expressed as the sum of two squares.",
      "prompt": "Natural language version: \"Every prime that is one greater than a multiple of four can be expressed as the sum of two squares.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 8.218504471005872,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem sum_of_squares_four : ∀ n : ℕ, Prime n → n = 1 [mod 4] → ∃ a b : ℕ, n = a^2 + b^2 ",
      "theorem four_plus_prime_is_two_squares (n : ℕ) (h : Prime (4*n + 1)) : ∃ x y : ℕ, 4*n + 1 = x^2 + y^2 ",
      "theorem sum_squares_prime { p : ℕ } ( h : p % 4 = 1 ) ( hp : Prime p ): ∃ a b : ℕ , ( a * a + b * b = p ) ",
      "theorem prime_two_squares (n : ℕ) (h : Prime (n)) (a : ∃ m : ℕ, Dvd m n ∧ ¬ (Dvd m 4)) :    ∃ (x y : ℕ), n = x*x + y*y ",
      "theorem sum_of_squares_four (n : ℕ) :     ∃ a b : ℕ, a*a + b*b = n ∧ Nat.Prime n ∧ 1 + 4 * (n / 4) = n "
    ],
    "answer": "theorem fermat_two_square : ∀ p : ℕ, Prime p → (p % 4 = 1) → ∃ a b : ℕ, a ^ 2 + b ^ 2 = p "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "unit_line_in_or_out_of_euclidean_plane_subset",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"For every subset of the Euclidean plane, there is a line segment of unit length whose endpoints are either both inside the subset or both outside it.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "For every subset of the Euclidean plane, there is a line segment of unit length whose endpoints are either both inside the subset or both outside it.",
      "codex_time": 12.38955167599488,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem line_segment_inside_or_outside_plane_set (s : Set (real_euclidean_space 2)) :  ∃ (x0 y0 : real_euclidean_space 2), ((x0, y0) ∈ s ∧ (y0, x0) ∈ s) ∨  ((x0, y0) ∉ s ∧ (y0, x0) ∉ s) ∧  ∥y0 - x0∥ = 1 ",
      "theorem line_segment_inside_or_outside_plane_set (s : Setₓ (real_euclidean_space 2)) :  ∃ (x0 y0 : real_euclidean_space 2), ((x0, y0) ∈ s ∧ (y0, x0) ∈ s) ∨  ((x0, y0) ∉ s ∧ (y0, x0) ∉ s) ∧  ∥y0 - x0∥ = 1 ",
      "theorem line_segment_in_subset (A : Set ℝ^2) :  ∃ p q : point ℝ^2, 1 = dist p q ∧ (p ∈ A ↔ q ∈ A) ",
      "theorem line_segment_in_subset (A : Setₓ ℝ^2) :  ∃ p q : point ℝ^2, 1 = dist p q ∧ (p ∈ A ↔ q ∈ A) ",
      "theorem exists_segment_of_unit_length (U : Set ℝ^2) : ∃ p q : ℝ^2, ∥p - q∥ = 1 ∧ (p ∈ U ↔ q ∈ U) ",
      "theorem exists_segment_of_unit_length (U : Setₓ ℝ^2) : ∃ p q : ℝ^2, ∥p - q∥ = 1 ∧ (p ∈ U ↔ q ∈ U) ",
      "theorem unit_line_segment_inside_or_outside_value_set {X : Type*} [MetricSpace X] (s x : Set X) :  ∃ p q : X, (p ∈ s ↔ q ∈ s) ∧ p ≠ q ∧ dist p q = 1 ",
      "theorem unit_line_segment_inside_or_outside_value_set {X : Type*} [MetricSpace X] (s x : Setₓ X) :  ∃ p q : X, (p ∈ s ↔ q ∈ s) ∧ p ≠ q ∧ dist p q = 1 ",
      "theorem segment_in_subset_or_segment_out (s : Set (euclidean_plane 2)) :  ∃ (x y : EuclideanSpace 2 ℝ) (h : dist x y = 1), x ∈ s ↔ y ∈ s ",
      "theorem segment_in_subset_or_segment_out (s : Setₓ (euclidean_plane 2)) :  ∃ (x y : EuclideanSpace 2 ℝ) (h : dist x y = 1), x ∈ s ↔ y ∈ s "
    ],
    "answer": "theorem unit_line_in_or_out_of_euclidean_plane_subset : ∀ (S : Set $ EuclideanSpace ℝ (Finₓ 2)), ∃ (x y : EuclideanSpace ℝ (Finₓ 2)), (∥x - y∥ = (1 : ℝ)) → (x ∈ S ∧ y ∈ S) ∨ (x ∉ S ∧ y ∉ S) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "unit_line_in_or_out_of_euclidean_plane_subset",
      "main_prompt": "For every subset of the Euclidean plane, there is a line segment of unit length whose endpoints are either both inside the subset or both outside it.",
      "prompt": "Natural language version: \"If `x ∈ s` and `y ∈ interior s`, then the segment `(x, y]` is included in `interior s`.\" Translate the natural language version to a Lean mathlib version:\n theorem convex.add_smul_sub_mem_interior{E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) {x y : E} (hx : x ∈ s) (hy : y ∈ interior s) {t : 𝕜} (ht : t ∈ set.Ioc 0 1) :\nx + t • (y - x) ∈ interior s := \n\nNatural language version: \" If `x ≠ y` belong to the same closed ball, then the open segment with endpoints `x` and `y` is included in the corresponding open ball.\" Translate the natural language version to a Lean mathlib version:\n theorem open_segment_subset_ball_of_ne{E : Type u_2} [normed_group E] [normed_space ℝ E] [strict_convex_space ℝ E] {x y z : E} {r : ℝ} (hx : x ∈ metric.closed_ball z r) (hy : y ∈ metric.closed_ball z r) (hne : x ≠ y) :\nopen_segment ℝ x y ⊆ metric.ball z r := \n\nNatural language version: \" If a subset of a real vector space contains a segment, then the direction of this segment belongs to the tangent cone at its endpoints.\" Translate the natural language version to a Lean mathlib version:\n theorem mem_tangent_cone_of_segment_subset{G : Type u_4} [normed_group G] [normed_space ℝ G] {s : set G} {x y : G} (h : segment ℝ x y ⊆ s) :\ny - x ∈ tangent_cone_at ℝ s x := \n\nNatural language version: \"If `x ∈ closure s` and `y ∈ interior s`, then the segment `(x, y]` is included in `interior s`.\" Translate the natural language version to a Lean mathlib version:\n theorem convex.add_smul_sub_mem_interior'{E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) {x y : E} (hx : x ∈ closure s) (hy : y ∈ interior s) {t : 𝕜} (ht : t ∈ set.Ioc 0 1) :\nx + t • (y - x) ∈ interior s := \n\nNatural language version: \"For every subset of the Euclidean plane, there is a line segment of unit length whose endpoints are either both inside the subset or both outside it.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5471247434616089,
          "doc_string": "If `x ∈ s` and `y ∈ interior s`, then the segment `(x, y]` is included in `interior s`.",
          "statement": "theorem convex.add_smul_sub_mem_interior {E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) {x y : E} (hx : x ∈ s) (hy : y ∈ interior s) {t : 𝕜} (ht : t ∈ set.Ioc 0 1) : x + t • (y - x) ∈ interior s"
        },
        {
          "sim_score": 0.5154375433921814,
          "doc_string": " If `x ≠ y` belong to the same closed ball, then the open segment with endpoints `x` and `y` is included in the corresponding open ball.",
          "statement": "theorem open_segment_subset_ball_of_ne {E : Type u_2} [normed_group E] [normed_space ℝ E] [strict_convex_space ℝ E] {x y z : E} {r : ℝ} (hx : x ∈ metric.closed_ball z r) (hy : y ∈ metric.closed_ball z r) (hne : x ≠ y) : open_segment ℝ x y ⊆ metric.ball z r"
        },
        {
          "sim_score": 0.5063760280609131,
          "doc_string": " If a subset of a real vector space contains a segment, then the direction of this segment belongs to the tangent cone at its endpoints.",
          "statement": "theorem mem_tangent_cone_of_segment_subset {G : Type u_4} [normed_group G] [normed_space ℝ G] {s : set G} {x y : G} (h : segment ℝ x y ⊆ s) : y - x ∈ tangent_cone_at ℝ s x"
        },
        {
          "sim_score": 0.5046789050102234,
          "doc_string": "If `x ∈ closure s` and `y ∈ interior s`, then the segment `(x, y]` is included in `interior s`.",
          "statement": "theorem convex.add_smul_sub_mem_interior' {E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) {x y : E} (hx : x ∈ closure s) (hy : y ∈ interior s) {t : 𝕜} (ht : t ∈ set.Ioc 0 1) : x + t • (y - x) ∈ interior s"
        }
      ],
      "codex_time": 9.36085066999658,
      "search_time": 1.5133282099850476,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem segment_subset_of_exists_mem₂{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] (e₁ e₂ : E) {s₁ s₂ : Set E} (h₁ : e₁ ∈ s₁) (h₂ : e₂ ∈ s₂) (h : s₁ ∩ s₂ = ∅) :  ∃(r : ℝ), ∃(e : E × E), Segment r e₁ e₂ ⊆",
      "theorem segment_subset_of_exists_mem₂{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] (e₁ e₂ : E) {s₁ s₂ : Setₓ E} (h₁ : e₁ ∈ s₁) (h₂ : e₂ ∈ s₂) (h : s₁ ∩ s₂ = ∅) :  ∃(r : ℝ), ∃(e : E × E), Segment r e₁ e₂ ⊆",
      "theorem euclidean_plane.alternatives_mem_closure_of_mem_interior {s : Set ℝ^2} {x y : ℝ^2} (h1 : x ∈ Interior s) (h2 : y ∈ Interior s) (h3 : x ≠ y) :   x ∈ Closure s ↔ y ∈ Closure s ",
      "theorem euclidean_plane.alternatives_mem_closure_of_mem_interior {s : Setₓ ℝ^2} {x y : ℝ^2} (h1 : x ∈ Interior s) (h2 : y ∈ Interior s) (h3 : x ≠ y) :   x ∈ Closure s ↔ y ∈ Closure s ",
      "theorem is_o_plane.segment_of_mem_set_ne{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [AddCommGroup E] [is_o_plane E] {s : Set E} (hs : is_o_plane s) {x : E} (hx : x ∈ s) {y : E} (hy : y ∈ s) (h : dis (x - y) = 1) (hne : x ≠ y) : Segment ℝ x y ⊆ s ",
      "theorem is_o_plane.segment_of_mem_set_ne{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [AddCommGroupₓₓ E] [is_o_plane E] {s : Set E} (hs : is_o_plane s) {x : E} (hx : x ∈ s) {y : E} (hy : y ∈ s) (h : dis (x - y) = 1) (hne : x ≠ y) : Segment ℝ x y ⊆ s ",
      "theorem is_o_plane.segment_of_mem_set_ne{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [AddCommGroup E] [is_o_plane E] {s : Setₓ E} (hs : is_o_plane s) {x : E} (hx : x ∈ s) {y : E} (hy : y ∈ s) (h : dis (x - y) = 1) (hne : x ≠ y) : Segment ℝ x y ⊆ s ",
      "theorem is_o_plane.segment_of_mem_set_ne{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [AddCommGroupₓₓ E] [is_o_plane E] {s : Setₓ E} (hs : is_o_plane s) {x : E} (hx : x ∈ s) {y : E} (hy : y ∈ s) (h : dis (x - y) = 1) (hne : x ≠ y) : Segment ℝ x y ⊆ s ",
      "theorem is_o_plane.segment_of_mem_set_ne{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [AddCommGroupₓ E] [is_o_plane E] {s : Set E} (hs : is_o_plane s) {x : E} (hx : x ∈ s) {y : E} (hy : y ∈ s) (h : dis (x - y) = 1) (hne : x ≠ y) : Segment ℝ x y ⊆ s ",
      "theorem is_o_plane.segment_of_mem_set_ne{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [AddCommGroupₓ E] [is_o_plane E] {s : Setₓ E} (hs : is_o_plane s) {x : E} (hx : x ∈ s) {y : E} (hy : y ∈ s) (h : dis (x - y) = 1) (hne : x ≠ y) : Segment ℝ x y ⊆ s ",
      "theorem borsuk_ulam_closed_unit_interval{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [EuclideanSpace E] {s : Set E} {x y : E} : ∃ z z' : E, x ∈ z ∧ z' ∈ y ∧ dist ℝ z z' = 1 ∧ (z ∈ s ↔ z' ∈ s) ",
      "theorem borsuk_ulam_closed_unit_interval{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [EuclideanSpace E] {s : Setₓ E} {x y : E} : ∃ z z' : E, x ∈ z ∧ z' ∈ y ∧ dist ℝ z z' = 1 ∧ (z ∈ s ↔ z' ∈ s) ",
      "theorem segment_subset_of_subset_compl{E : Type u_2} [EuclideanSpace E] [NormedGroup E] [NormedSpace ℝ E] {s : Set E} {x y : E} (hs : s ⊆ Set.Univ \\ s) (h : ∀ z ∈ Segment ℝ x y, z ∈ s) : set.distance_between x y = (7 * set.length x y) / 6 ",
      "theorem segment_subset_of_subset_compl{E : Type u_2} [EuclideanSpace E] [NormedGroup E] [NormedSpace ℝ E] {s : Setₓ E} {x y : E} (hs : s ⊆ Setₓ.Univ \\ s) (h : ∀ z ∈ Segment ℝ x y, z ∈ s) : set.distance_between x y = (7 * set.length x y) / 6 "
    ],
    "answer": "theorem unit_line_in_or_out_of_euclidean_plane_subset : ∀ (S : Set $ EuclideanSpace ℝ (Finₓ 2)), ∃ (x y : EuclideanSpace ℝ (Finₓ 2)), (∥x - y∥ = (1 : ℝ)) → (x ∈ S ∧ y ∈ S) ∨ (x ∉ S ∧ y ∉ S) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "unit_line_in_or_out_of_euclidean_plane_subset",
      "main_prompt": "For every subset of the Euclidean plane, there is a line segment of unit length whose endpoints are either both inside the subset or both outside it.",
      "prompt": "Natural language version: \"For every subset of the Euclidean plane, there is a line segment of unit length whose endpoints are either both inside the subset or both outside it.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 6.245040854992112,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem davis_marderhausen_stnc (X : Set ℝ^2): ∃ s : line, ∀ (x y : point), x = klein y  ∧ y = klein x ↔ s inc2 x ∧ s inc2 y .  ---- notation x `=s` y ",
      "theorem davis_marderhausen_stnc (X : Setₓ ℝ^2): ∃ s : line, ∀ (x y : point), x = klein y  ∧ y = klein x ↔ s inc2 x ∧ s inc2 y .  ---- notation x `=s` y ",
      "theorem dirichlet: (Set α) → {p : α × α // p.1 ≠ p.2} ",
      "theorem dirichlet: (Setₓ α) → {p : α × α // p.1 ≠ p.2} ",
      "theorem euclid_transform : ∀ s : Set ℝ × ℝ, (∃ (x y : ℝ×ℝ), (y ∈ s → dist x.1 y.1 = 1 ∧ dist x.2 y.2 = 1) ∧ ((x ∈ s ∧ y ∈ s) ∨ (¬ x ∈ s ∧ ¬ y ∈ s)))  ",
      "theorem euclid_transform : ∀ s : Setₓ ℝ × ℝ, (∃ (x y : ℝ×ℝ), (y ∈ s → dist x.1 y.1 = 1 ∧ dist x.2 y.2 = 1) ∧ ((x ∈ s ∧ y ∈ s) ∨ (¬ x ∈ s ∧ ¬ y ∈ s)))  ",
      "theorem plane_set_has_unit_segment : ∀ (T : Set ℝ), ¬ Empty T → ∃ (t : Π (A : Set ℝ), (A × A → Set ℝ )) , ∀ (a b x y : ℝ) , A → ¬ (Empty A) → ∃ (t : Π (A : Set ℝ), (A × A → Set ? ) ) , ∀ (a b x y : ℝ) , (∀ (a b : ℝ) , a ∈ T → b ∈ T → ∃ (p : ℝ × ℝ) , p",
      "theorem plane_set_has_unit_segment : ∀ (T : Setₓ ℝ), ¬ Empty T → ∃ (t : Π (A : Setₓ ℝ), (A × A → Setₓ ℝ )) , ∀ (a b x y : ℝ) , A → ¬ (Empty A) → ∃ (t : Π (A : Setₓ ℝ), (A × A → Setₓ ? ) ) , ∀ (a b x y : ℝ) , (∀ (a b : ℝ) , a ∈ T → b ∈ T → ∃ (p : ℝ × ℝ) , p",
      "theorem form_5 : ∀ (A ⊆ ℝ²), ∃ (u v : ℝ²), ∥u - v∥ = 1 ∧     u ∈ A ↔ v ∈ A "
    ],
    "answer": "theorem unit_line_in_or_out_of_euclidean_plane_subset : ∀ (S : Set $ EuclideanSpace ℝ (Finₓ 2)), ∃ (x y : EuclideanSpace ℝ (Finₓ 2)), (∥x - y∥ = (1 : ℝ)) → (x ∈ S ∧ y ∈ S) ∨ (x ∉ S ∧ y ∉ S) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "all_idempotent_implies_commutative",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"A ring with all elements idempotent is commutative.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A ring with all elements idempotent is commutative.",
      "codex_time": 7.0327310130232945,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem idempotent_ring_is_commutative (R : Type*) [Ring R] (hR : ∀ x ∈ R, x^2 = x) :  ∀ (x y : R), x*y = y*x ",
      "theorem idempotent_ring_is_commutative (R : Type*) [Ringₓₓ R] (hR : ∀ x ∈ R, x^2 = x) :  ∀ (x y : R), x*y = y*x ",
      "theorem idempotent_ring_is_commutative (R : Type*) [Ringₓ R] (hR : ∀ x ∈ R, x^2 = x) :  ∀ (x y : R), x*y = y*x ",
      "theorem idempotents_commute (R : Type*) [Ring R] (all : ∀ x : R, x * x = x) :  (∀ x y : R, x * y = y * x) ",
      "theorem idempotents_commute (R : Type*) [Ringₓₓ R] (all : ∀ x : R, x * x = x) :  (∀ x y : R, x * y = y * x) ",
      "theorem idempotents_commute (R : Type*) [Ringₓ R] (all : ∀ x : R, x * x = x) :  (∀ x y : R, x * y = y * x) ",
      "theorem commutative_ring_of_idempotent_elt {R : Type*} [CommRing R] (x : R) (Hx : x^2 = x):  True ",
      "theorem commutative_ring_of_idempotent_elt {R : Type*} [CommRingₓₓ R] (x : R) (Hx : x^2 = x):  True ",
      "theorem commutative_ring_of_idempotent_elt {R : Type*} [CommRingₓ R] (x : R) (Hx : x^2 = x):  True ",
      "theorem comm_ring_of_idempt (R : Type*) [Ring R] (idempt : ∀ x : R, x * x = x) : CommRing R ",
      "theorem comm_ring_of_idempt (R : Type*) [Ring R] (idempt : ∀ x : R, x * x = x) : CommRingₓₓ R ",
      "theorem comm_ring_of_idempt (R : Type*) [Ringₓₓ R] (idempt : ∀ x : R, x * x = x) : CommRing R ",
      "theorem comm_ring_of_idempt (R : Type*) [Ringₓₓ R] (idempt : ∀ x : R, x * x = x) : CommRingₓₓ R ",
      "theorem comm_ring_of_idempt (R : Type*) [Ringₓ R] (idempt : ∀ x : R, x * x = x) : CommRing R ",
      "theorem comm_ring_of_idempt (R : Type*) [Ringₓ R] (idempt : ∀ x : R, x * x = x) : CommRingₓₓ R ",
      "theorem comm_ring_of_idempt (R : Type*) [Ring R] (idempt : ∀ x : R, x * x = x) : CommRingₓ R ",
      "theorem comm_ring_of_idempt (R : Type*) [Ringₓₓ R] (idempt : ∀ x : R, x * x = x) : CommRingₓ R ",
      "theorem comm_ring_of_idempt (R : Type*) [Ringₓ R] (idempt : ∀ x : R, x * x = x) : CommRingₓ R ",
      "theorem idempotent_then_commutative {R : Type*} [Ring R] (h : ∀ x : R, x = x^2) :  CommRing R ",
      "theorem idempotent_then_commutative {R : Type*} [Ring R] (h : ∀ x : R, x = x^2) :  CommRingₓₓ R ",
      "theorem idempotent_then_commutative {R : Type*} [Ringₓₓ R] (h : ∀ x : R, x = x^2) :  CommRing R ",
      "theorem idempotent_then_commutative {R : Type*} [Ringₓₓ R] (h : ∀ x : R, x = x^2) :  CommRingₓₓ R ",
      "theorem idempotent_then_commutative {R : Type*} [Ringₓ R] (h : ∀ x : R, x = x^2) :  CommRing R ",
      "theorem idempotent_then_commutative {R : Type*} [Ringₓ R] (h : ∀ x : R, x = x^2) :  CommRingₓₓ R ",
      "theorem idempotent_then_commutative {R : Type*} [Ring R] (h : ∀ x : R, x = x^2) :  CommRingₓ R ",
      "theorem idempotent_then_commutative {R : Type*} [Ringₓₓ R] (h : ∀ x : R, x = x^2) :  CommRingₓ R ",
      "theorem idempotent_then_commutative {R : Type*} [Ringₓ R] (h : ∀ x : R, x = x^2) :  CommRingₓ R "
    ],
    "answer": "theorem all_idempotent_implies_commutative {R : Type _} [Ring R] : (∀ x : R, x * x = 1) → CommRing R "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "all_idempotent_implies_commutative",
      "main_prompt": "A ring with all elements idempotent is commutative.",
      "prompt": "Natural language version: \"The identity map is a ring homomorphism.\" Translate the natural language version to a Lean mathlib version:\n theorem is_ring_hom.id{α : Type u} [ring α] :\nis_ring_hom id := \n\nNatural language version: \"As submodules, subalgebras are idempotent.\" Translate the natural language version to a Lean mathlib version:\n theorem subalgebra.mul_self{R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) :\nS.to_submodule * S.to_submodule = S.to_submodule := \n\nNatural language version: \"Two subrings are equal if they have the same elements.\" Translate the natural language version to a Lean mathlib version:\n theorem subring.ext{R : Type u} [ring R] {S T : subring R} (h : ∀ (x : R), x ∈ S ↔ x ∈ T) :\nS = T := \n\nNatural language version: \"The map sending a binary relation to the smallest additive congruence relation in which it is contained is idempotent.\" Translate the natural language version to a Lean mathlib version:\n theorem add_con.add_con_gen_idem{M : Type u_1} [has_add M] (r : M → M → Prop) :\nadd_con_gen ⇑(add_con_gen r) = add_con_gen r := \n\nNatural language version: \"A ring with all elements idempotent is commutative.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6198770999908447,
          "doc_string": "The identity map is a ring homomorphism.",
          "statement": "theorem is_ring_hom.id {α : Type u} [ring α] : is_ring_hom id"
        },
        {
          "sim_score": 0.6067196130752563,
          "doc_string": "As submodules, subalgebras are idempotent.",
          "statement": "theorem subalgebra.mul_self {R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : S.to_submodule * S.to_submodule = S.to_submodule"
        },
        {
          "sim_score": 0.5843548774719238,
          "doc_string": "Two subrings are equal if they have the same elements.",
          "statement": "theorem subring.ext {R : Type u} [ring R] {S T : subring R} (h : ∀ (x : R), x ∈ S ↔ x ∈ T) : S = T"
        },
        {
          "sim_score": 0.5717903971672058,
          "doc_string": "The map sending a binary relation to the smallest additive congruence relation in which it is contained is idempotent.",
          "statement": "theorem add_con.add_con_gen_idem {M : Type u_1} [has_add M] (r : M → M → Prop) : add_con_gen ⇑(add_con_gen r) = add_con_gen r"
        }
      ],
      "codex_time": 7.338132099976065,
      "search_time": 1.4921700999839231,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem add_idem.comm{R : Type u} [Semiring R] (h : ∀ x : R, add_idem x) : CommRing R ",
      "theorem add_idem.comm{R : Type u} [Semiring R] (h : ∀ x : R, add_idem x) : CommRingₓₓ R ",
      "theorem add_idem.comm{R : Type u} [Semiringₓ R] (h : ∀ x : R, add_idem x) : CommRing R ",
      "theorem add_idem.comm{R : Type u} [Semiringₓ R] (h : ∀ x : R, add_idem x) : CommRingₓₓ R ",
      "theorem add_idem.comm{R : Type u} [Semiring R] (h : ∀ x : R, add_idem x) : CommRingₓ R ",
      "theorem add_idem.comm{R : Type u} [Semiringₓ R] (h : ∀ x : R, add_idem x) : CommRingₓ R ",
      "theorem non_comm_ring_with_idempotent.comm{R : Type u} [Ring R] {H : ∀ (x : R), x * x = x} : CommRing R ",
      "theorem non_comm_ring_with_idempotent.comm{R : Type u} [Ring R] {H : ∀ (x : R), x * x = x} : CommRingₓₓ R ",
      "theorem non_comm_ring_with_idempotent.comm{R : Type u} [Ringₓₓ R] {H : ∀ (x : R), x * x = x} : CommRing R ",
      "theorem non_comm_ring_with_idempotent.comm{R : Type u} [Ringₓₓ R] {H : ∀ (x : R), x * x = x} : CommRingₓₓ R ",
      "theorem non_comm_ring_with_idempotent.comm{R : Type u} [Ringₓ R] {H : ∀ (x : R), x * x = x} : CommRing R ",
      "theorem non_comm_ring_with_idempotent.comm{R : Type u} [Ringₓ R] {H : ∀ (x : R), x * x = x} : CommRingₓₓ R ",
      "theorem non_comm_ring_with_idempotent.comm{R : Type u} [Ring R] {H : ∀ (x : R), x * x = x} : CommRingₓ R ",
      "theorem non_comm_ring_with_idempotent.comm{R : Type u} [Ringₓₓ R] {H : ∀ (x : R), x * x = x} : CommRingₓ R ",
      "theorem non_comm_ring_with_idempotent.comm{R : Type u} [Ringₓ R] {H : ∀ (x : R), x * x = x} : CommRingₓ R ",
      "theorem idempotent_ring.comm{R : Type u} [Ring R] (h : ∀ (x : R), x * x = x) : CommRing R ",
      "theorem idempotent_ring.comm{R : Type u} [Ring R] (h : ∀ (x : R), x * x = x) : CommRingₓₓ R ",
      "theorem idempotent_ring.comm{R : Type u} [Ringₓₓ R] (h : ∀ (x : R), x * x = x) : CommRing R ",
      "theorem idempotent_ring.comm{R : Type u} [Ringₓₓ R] (h : ∀ (x : R), x * x = x) : CommRingₓₓ R ",
      "theorem idempotent_ring.comm{R : Type u} [Ringₓ R] (h : ∀ (x : R), x * x = x) : CommRing R ",
      "theorem idempotent_ring.comm{R : Type u} [Ringₓ R] (h : ∀ (x : R), x * x = x) : CommRingₓₓ R ",
      "theorem idempotent_ring.comm{R : Type u} [Ring R] (h : ∀ (x : R), x * x = x) : CommRingₓ R ",
      "theorem idempotent_ring.comm{R : Type u} [Ringₓₓ R] (h : ∀ (x : R), x * x = x) : CommRingₓ R ",
      "theorem idempotent_ring.comm{R : Type u} [Ringₓ R] (h : ∀ (x : R), x * x = x) : CommRingₓ R ",
      "theorem idempotent_is_comm_ring{R : Type u} [Ring R] (H : (∀ (x : R), x ^ 2 =  x)) : CommRing R ",
      "theorem idempotent_is_comm_ring{R : Type u} [Ring R] (H : (∀ (x : R), x ^ 2 =  x)) : CommRingₓₓ R ",
      "theorem idempotent_is_comm_ring{R : Type u} [Ringₓₓ R] (H : (∀ (x : R), x ^ 2 =  x)) : CommRing R ",
      "theorem idempotent_is_comm_ring{R : Type u} [Ringₓₓ R] (H : (∀ (x : R), x ^ 2 =  x)) : CommRingₓₓ R ",
      "theorem idempotent_is_comm_ring{R : Type u} [Ringₓ R] (H : (∀ (x : R), x ^ 2 =  x)) : CommRing R ",
      "theorem idempotent_is_comm_ring{R : Type u} [Ringₓ R] (H : (∀ (x : R), x ^ 2 =  x)) : CommRingₓₓ R ",
      "theorem idempotent_is_comm_ring{R : Type u} [Ring R] (H : (∀ (x : R), x ^ 2 =  x)) : CommRingₓ R ",
      "theorem idempotent_is_comm_ring{R : Type u} [Ringₓₓ R] (H : (∀ (x : R), x ^ 2 =  x)) : CommRingₓ R ",
      "theorem idempotent_is_comm_ring{R : Type u} [Ringₓ R] (H : (∀ (x : R), x ^ 2 =  x)) : CommRingₓ R ",
      "theorem idem_ring.comm_ring{R : Type u} [Ring R] (H : ∀ r ∈ R, r^2 = r) : CommRing R ",
      "theorem idem_ring.comm_ring{R : Type u} [Ring R] (H : ∀ r ∈ R, r^2 = r) : CommRingₓₓ R ",
      "theorem idem_ring.comm_ring{R : Type u} [Ringₓₓ R] (H : ∀ r ∈ R, r^2 = r) : CommRing R ",
      "theorem idem_ring.comm_ring{R : Type u} [Ringₓₓ R] (H : ∀ r ∈ R, r^2 = r) : CommRingₓₓ R ",
      "theorem idem_ring.comm_ring{R : Type u} [Ringₓ R] (H : ∀ r ∈ R, r^2 = r) : CommRing R ",
      "theorem idem_ring.comm_ring{R : Type u} [Ringₓ R] (H : ∀ r ∈ R, r^2 = r) : CommRingₓₓ R ",
      "theorem idem_ring.comm_ring{R : Type u} [Ring R] (H : ∀ r ∈ R, r^2 = r) : CommRingₓ R ",
      "theorem idem_ring.comm_ring{R : Type u} [Ringₓₓ R] (H : ∀ r ∈ R, r^2 = r) : CommRingₓ R ",
      "theorem idem_ring.comm_ring{R : Type u} [Ringₓ R] (H : ∀ r ∈ R, r^2 = r) : CommRingₓ R "
    ],
    "answer": "theorem all_idempotent_implies_commutative {R : Type _} [Ring R] : (∀ x : R, x * x = 1) → CommRing R "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "all_idempotent_implies_commutative",
      "main_prompt": "A ring with all elements idempotent is commutative.",
      "prompt": "Natural language version: \"A ring with all elements idempotent is commutative.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 13.740487753995694,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem ring.comm_ring_of_idemp_ring {R : Type u} [CommRing R] :  ∀ {R : Type u} [CommRing R] (s : Set R), s = ⊥ → s.prod = s  theorem ring.comm_ring_of_idemp_ring_idemp {R : Type u} [CommRing R] :  ∀ {R : Type u} [CommRing R] (s : Set R), s = ⊥ → s = s.prod  theorem ring.comm_ring_of_idemp_ring_prod {R : Type u} [CommRing R]",
      "theorem ring.comm_ring_of_idemp_ring {R : Type u} [CommRingₓₓ R] :  ∀ {R : Type u} [CommRingₓₓ R] (s : Set R), s = ⊥ → s.prod = s  theorem ring.comm_ring_of_idemp_ring_idemp {R : Type u} [CommRingₓₓ R] :  ∀ {R : Type u} [CommRingₓₓ R] (s : Set R), s = ⊥ → s = s.prod  theorem ring.comm_ring_of_idemp_ring_prod {R : Type u} [CommRingₓₓ R]",
      "theorem ring.comm_ring_of_idemp_ring {R : Type u} [CommRing R] :  ∀ {R : Type u} [CommRing R] (s : Setₓ R), s = ⊥ → s.prod = s  theorem ring.comm_ring_of_idemp_ring_idemp {R : Type u} [CommRing R] :  ∀ {R : Type u} [CommRing R] (s : Setₓ R), s = ⊥ → s = s.prod  theorem ring.comm_ring_of_idemp_ring_prod {R : Type u} [CommRing R]",
      "theorem ring.comm_ring_of_idemp_ring {R : Type u} [CommRingₓₓ R] :  ∀ {R : Type u} [CommRingₓₓ R] (s : Setₓ R), s = ⊥ → s.prod = s  theorem ring.comm_ring_of_idemp_ring_idemp {R : Type u} [CommRingₓₓ R] :  ∀ {R : Type u} [CommRingₓₓ R] (s : Setₓ R), s = ⊥ → s = s.prod  theorem ring.comm_ring_of_idemp_ring_prod {R : Type u} [CommRingₓₓ R]",
      "theorem ring.comm_ring_of_idemp_ring {R : Type u} [CommRingₓ R] :  ∀ {R : Type u} [CommRingₓ R] (s : Set R), s = ⊥ → s.prod = s  theorem ring.comm_ring_of_idemp_ring_idemp {R : Type u} [CommRingₓ R] :  ∀ {R : Type u} [CommRingₓ R] (s : Set R), s = ⊥ → s = s.prod  theorem ring.comm_ring_of_idemp_ring_prod {R : Type u} [CommRingₓ R]",
      "theorem ring.comm_ring_of_idemp_ring {R : Type u} [CommRingₓ R] :  ∀ {R : Type u} [CommRingₓ R] (s : Setₓ R), s = ⊥ → s.prod = s  theorem ring.comm_ring_of_idemp_ring_idemp {R : Type u} [CommRingₓ R] :  ∀ {R : Type u} [CommRingₓ R] (s : Setₓ R), s = ⊥ → s = s.prod  theorem ring.comm_ring_of_idemp_ring_prod {R : Type u} [CommRingₓ R]",
      "theorem exterior_power_map_comp_open_unit : smooth_map f X Y → (X →₀ Y) = (X →₁ Y) ",
      "theorem all_ideals_idem_is_comm (A : Algebra ℤ )     (h : ∀ j : A, is_ideal.idem j.to_submodule) : is_commutative_ring A ",
      "theorem em_ring.commute_idempotent {α : Type*} [CommRing α] (h : ∀ (x : α), x^2 = x) : CommRing α  can be done in two lines.  end of lecture 1 -/     /-- A commutative Ring (A, +, times) is a Ring which is a Set A together with an addition +, a multiplication times  which are both commutative and associative.  The addition is commutative iff x + y = y + x The addition is associative iff (x+y) + z = x + (y + z)  ",
      "theorem em_ring.commute_idempotent {α : Type*} [CommRingₓₓ α] (h : ∀ (x : α), x^2 = x) : CommRingₓₓ α  can be done in two lines.  end of lecture 1 -/     /-- A commutative Ring (A, +, times) is a Ring which is a Set A together with an addition +, a multiplication times  which are both commutative and associative.  The addition is commutative iff x + y = y + x The addition is associative iff (x+y) + z = x + (y + z)  ",
      "theorem em_ring.commute_idempotent {α : Type*} [CommRing α] (h : ∀ (x : α), x^2 = x) : CommRing α  can be done in two lines.  end of lecture 1 -/     /-- A commutative Ringₓₓ (A, +, times) is a Ringₓₓ which is a Set A together with an addition +, a multiplication times  which are both commutative and associative.  The addition is commutative iff x + y = y + x The addition is associative iff (x+y) + z = x + (y + z)  ",
      "theorem em_ring.commute_idempotent {α : Type*} [CommRingₓₓ α] (h : ∀ (x : α), x^2 = x) : CommRingₓₓ α  can be done in two lines.  end of lecture 1 -/     /-- A commutative Ringₓₓ (A, +, times) is a Ringₓₓ which is a Set A together with an addition +, a multiplication times  which are both commutative and associative.  The addition is commutative iff x + y = y + x The addition is associative iff (x+y) + z = x + (y + z)  ",
      "theorem em_ring.commute_idempotent {α : Type*} [CommRing α] (h : ∀ (x : α), x^2 = x) : CommRing α  can be done in two lines.  end of lecture 1 -/     /-- A commutative Ring (A, +, times) is a Ring which is a Setₓ A together with an addition +, a multiplication times  which are both commutative and associative.  The addition is commutative iff x + y = y + x The addition is associative iff (x+y) + z = x + (y + z)  ",
      "theorem em_ring.commute_idempotent {α : Type*} [CommRingₓₓ α] (h : ∀ (x : α), x^2 = x) : CommRingₓₓ α  can be done in two lines.  end of lecture 1 -/     /-- A commutative Ring (A, +, times) is a Ring which is a Setₓ A together with an addition +, a multiplication times  which are both commutative and associative.  The addition is commutative iff x + y = y + x The addition is associative iff (x+y) + z = x + (y + z)  ",
      "theorem em_ring.commute_idempotent {α : Type*} [CommRing α] (h : ∀ (x : α), x^2 = x) : CommRing α  can be done in two lines.  end of lecture 1 -/     /-- A commutative Ringₓₓ (A, +, times) is a Ringₓₓ which is a Setₓ A together with an addition +, a multiplication times  which are both commutative and associative.  The addition is commutative iff x + y = y + x The addition is associative iff (x+y) + z = x + (y + z)  ",
      "theorem em_ring.commute_idempotent {α : Type*} [CommRingₓₓ α] (h : ∀ (x : α), x^2 = x) : CommRingₓₓ α  can be done in two lines.  end of lecture 1 -/     /-- A commutative Ringₓₓ (A, +, times) is a Ringₓₓ which is a Setₓ A together with an addition +, a multiplication times  which are both commutative and associative.  The addition is commutative iff x + y = y + x The addition is associative iff (x+y) + z = x + (y + z)  ",
      "theorem em_ring.commute_idempotent {α : Type*} [CommRing α] (h : ∀ (x : α), x^2 = x) : CommRing α  can be done in two lines.  end of lecture 1 -/     /-- A commutative Ringₓ (A, +, times) is a Ringₓ which is a Set A together with an addition +, a multiplication times  which are both commutative and associative.  The addition is commutative iff x + y = y + x The addition is associative iff (x+y) + z = x + (y + z)  ",
      "theorem em_ring.commute_idempotent {α : Type*} [CommRingₓₓ α] (h : ∀ (x : α), x^2 = x) : CommRingₓₓ α  can be done in two lines.  end of lecture 1 -/     /-- A commutative Ringₓ (A, +, times) is a Ringₓ which is a Set A together with an addition +, a multiplication times  which are both commutative and associative.  The addition is commutative iff x + y = y + x The addition is associative iff (x+y) + z = x + (y + z)  ",
      "theorem em_ring.commute_idempotent {α : Type*} [CommRing α] (h : ∀ (x : α), x^2 = x) : CommRing α  can be done in two lines.  end of lecture 1 -/     /-- A commutative Ringₓ (A, +, times) is a Ringₓ which is a Setₓ A together with an addition +, a multiplication times  which are both commutative and associative.  The addition is commutative iff x + y = y + x The addition is associative iff (x+y) + z = x + (y + z)  ",
      "theorem em_ring.commute_idempotent {α : Type*} [CommRingₓₓ α] (h : ∀ (x : α), x^2 = x) : CommRingₓₓ α  can be done in two lines.  end of lecture 1 -/     /-- A commutative Ringₓ (A, +, times) is a Ringₓ which is a Setₓ A together with an addition +, a multiplication times  which are both commutative and associative.  The addition is commutative iff x + y = y + x The addition is associative iff (x+y) + z = x + (y + z)  ",
      "theorem em_ring.commute_idempotent {α : Type*} [CommRingₓ α] (h : ∀ (x : α), x^2 = x) : CommRingₓ α  can be done in two lines.  end of lecture 1 -/     /-- A commutative Ring (A, +, times) is a Ring which is a Set A together with an addition +, a multiplication times  which are both commutative and associative.  The addition is commutative iff x + y = y + x The addition is associative iff (x+y) + z = x + (y + z)  ",
      "theorem em_ring.commute_idempotent {α : Type*} [CommRingₓ α] (h : ∀ (x : α), x^2 = x) : CommRingₓ α  can be done in two lines.  end of lecture 1 -/     /-- A commutative Ringₓₓ (A, +, times) is a Ringₓₓ which is a Set A together with an addition +, a multiplication times  which are both commutative and associative.  The addition is commutative iff x + y = y + x The addition is associative iff (x+y) + z = x + (y + z)  ",
      "theorem em_ring.commute_idempotent {α : Type*} [CommRingₓ α] (h : ∀ (x : α), x^2 = x) : CommRingₓ α  can be done in two lines.  end of lecture 1 -/     /-- A commutative Ring (A, +, times) is a Ring which is a Setₓ A together with an addition +, a multiplication times  which are both commutative and associative.  The addition is commutative iff x + y = y + x The addition is associative iff (x+y) + z = x + (y + z)  ",
      "theorem em_ring.commute_idempotent {α : Type*} [CommRingₓ α] (h : ∀ (x : α), x^2 = x) : CommRingₓ α  can be done in two lines.  end of lecture 1 -/     /-- A commutative Ringₓₓ (A, +, times) is a Ringₓₓ which is a Setₓ A together with an addition +, a multiplication times  which are both commutative and associative.  The addition is commutative iff x + y = y + x The addition is associative iff (x+y) + z = x + (y + z)  ",
      "theorem em_ring.commute_idempotent {α : Type*} [CommRingₓ α] (h : ∀ (x : α), x^2 = x) : CommRingₓ α  can be done in two lines.  end of lecture 1 -/     /-- A commutative Ringₓ (A, +, times) is a Ringₓ which is a Set A together with an addition +, a multiplication times  which are both commutative and associative.  The addition is commutative iff x + y = y + x The addition is associative iff (x+y) + z = x + (y + z)  ",
      "theorem em_ring.commute_idempotent {α : Type*} [CommRingₓ α] (h : ∀ (x : α), x^2 = x) : CommRingₓ α  can be done in two lines.  end of lecture 1 -/     /-- A commutative Ringₓ (A, +, times) is a Ringₓ which is a Setₓ A together with an addition +, a multiplication times  which are both commutative and associative.  The addition is commutative iff x + y = y + x The addition is associative iff (x+y) + z = x + (y + z)  ",
      "theorem IsCommutative : CommRing α ",
      "theorem IsCommutative : CommRingₓₓ α ",
      "theorem IsCommutative : CommRingₓ α "
    ],
    "answer": "theorem all_idempotent_implies_commutative {R : Type _} [Ring R] : (∀ x : R, x * x = 1) → CommRing R "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "twin_prime_conjecture",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"There are infinitely many pairs of primes that differ exactly by two.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "There are infinitely many pairs of primes that differ exactly by two.",
      "codex_time": 8.827994786988711,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem infinitely_many_prime_pairs_differing_by_two :  ∃ (p q : ℕ), p > q ∧ p.prime ∧ q.prime ∧ (2 : ℕ) = p - q ",
      "theorem infinitely_many_diffs_of_two (p q : ℕ) (is_prime_p : Prime p)  (is_prime_q : Prime q) (h : 2 + p = 2 + q) : False ",
      "theorem two_between_primes : ∀ n : ℕ, ∃ p q : ℕ, Prime p ∧ Prime q ∧ p + 2 = q ",
      "theorem infinitely_many_twin_primes :  ∃ (f : ℕ → ℕ), ∀ (p : ℕ), ∃ (n : ℕ) (hp : Prime p) (hq : Prime (f p)), f p = p + 2  ",
      "theorem infinitely_many_prime_twin_pairs :  ∀ n : ℕ, ∃ p q : ℕ, (p.prime ∧ q.prime ∧ abs (p - q) = 2) "
    ],
    "answer": "theorem twin_prime_conjecture : ∀ n : ℕ, ∃ p : ℕ, p > n → Prime p → Prime (p + 2) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "twin_prime_conjecture",
      "main_prompt": "There are infinitely many pairs of primes that differ exactly by two.",
      "prompt": "Natural language version: \"For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.exists_prime_ge_modeq_one{k : ℕ} (n : ℕ) (hpos : 0 < k) :\n∃ (p : ℕ), nat.prime p ∧ n ≤ p ∧ p ≡ 1 [MOD k] := \n\nNatural language version: \" Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.exists_infinite_primes(n : ℕ) :\n∃ (p : ℕ), n ≤ p ∧ nat.prime p := \n\nNatural language version: \"The infinite pigeonhole principle\" Translate the natural language version to a Lean mathlib version:\n theorem ordinal.infinite_pigeonhole{β α : Type u} (f : β → α) (h₁ : cardinal.aleph_0 ≤ cardinal.mk β) (h₂ : cardinal.mk α < (cardinal.mk β).ord.cof) :\n∃ (a : α), cardinal.mk ↥(f ⁻¹' {a}) = cardinal.mk β := \n\nNatural language version: \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.prime.mod_two_eq_one_iff_ne_two{p : ℕ} [fact (nat.prime p)] :\np % 2 = 1 ↔ p ≠ 2 := \n\nNatural language version: \"There are infinitely many pairs of primes that differ exactly by two.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.53578782081604,
          "doc_string": "For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`.",
          "statement": "theorem nat.exists_prime_ge_modeq_one {k : ℕ} (n : ℕ) (hpos : 0 < k) : ∃ (p : ℕ), nat.prime p ∧ n ≤ p ∧ p ≡ 1 [MOD k]"
        },
        {
          "sim_score": 0.525439977645874,
          "doc_string": " Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`.",
          "statement": "theorem nat.exists_infinite_primes (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p"
        },
        {
          "sim_score": 0.5173879861831665,
          "doc_string": "The infinite pigeonhole principle",
          "statement": "theorem ordinal.infinite_pigeonhole {β α : Type u} (f : β → α) (h₁ : cardinal.aleph_0 ≤ cardinal.mk β) (h₂ : cardinal.mk α < (cardinal.mk β).ord.cof) : ∃ (a : α), cardinal.mk ↥(f ⁻¹' {a}) = cardinal.mk β"
        },
        {
          "sim_score": 0.48807522654533386,
          "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.",
          "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2"
        }
      ],
      "codex_time": 9.010696814977564,
      "search_time": 1.480321854003705,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem nat.exists_infinite_twin_primes : ∃ (p : ℕ), ∃ (q : ℕ), p < q ∧ Nat.Prime p ∧ Nat.Prime q ∧ q - p = 2 ",
      "theorem nat.prime_twin_pair_inf : ∀ (n : ℕ), ∃ (p : ℕ), n ≤ p ∧ Nat.Prime p ∧ ∃ (p' : ℕ), p' = p + 2 ∧ Nat.Prime p' ",
      "theorem nat.exists_infinite_pairs_of_primes_diff_by_two : ∃ (p : ℕ), Nat.Prime p ∧ p + 2 ∈ Nat.Primes ",
      "theorem nat.exists_infinite_primes_diff_two : ∃ (p : ℕ), Nat.Prime p ∧ Nat.Prime (p + 2) ",
      "theorem have_infinite_two_between_primes : ∀ (n : ℕ), ∃ (p : ℕ), (n ≤ p ∧ Nat.Prime p) ∧ ∃ (q : ℕ), (p + 2 ≤ q ∧ Nat.Prime q) "
    ],
    "answer": "theorem twin_prime_conjecture : ∀ n : ℕ, ∃ p : ℕ, p > n → Prime p → Prime (p + 2) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "twin_prime_conjecture",
      "main_prompt": "There are infinitely many pairs of primes that differ exactly by two.",
      "prompt": "Natural language version: \"There are infinitely many pairs of primes that differ exactly by two.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 11.813401652994798,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem : ∀ (n : ℕ), ∃ (m : ℕ), ∀ (p : ℕ), isPrime (p + m) ↔ isPrime p ",
      "theorem prime_pair_diff_2 (n : ℕ) : ∃ m : ℕ, (n ≠ m) ∧ (Prime n) ∧ (Prime m) ∧ (n = m + 2) ",
      "theorem dirichlet_prime_pairs            : ∀ k : ℕ, ∃ p q : ℕ, p ≠ q ∧                             Prime p ∧                             Prime q ∧                              q - p = k ",
      "theorem two_prime_gap: ∀ a: ℕ, ∃ p q: ℕ, Prime p ∧ Prime q ∧ p = a + 2 ∧ q = p + 2 ",
      "theorem primes_diff_by_two_inf: ∀ a b :ℕ, a > 2 ∧ Prime a ∧ Prime (a + 2) → ∃ c :ℕ, b < c ∧ a = c ∧ Prime c ∧ Prime (c + 2).  --  section  -- (#check nat.fact)  def factorial : ℕ → ℕ "
    ],
    "answer": "theorem twin_prime_conjecture : ∀ n : ℕ, ∃ p : ℕ, p > n → Prime p → Prime (p + 2) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "fin_div_ring_is_field",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every finite division ring is a field.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every finite division ring is a field.",
      "codex_time": 6.840860775002511,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem every_finite_division_ring_is_a_field (D : Type*) [DivisionRing D]  (hD : Finite D) : Field D ",
      "theorem finite_division_ring_is_field (R : Type*) [DivisionRing R] [Fintype R]:  Field R ",
      "theorem finite_division_ring_is_field (R : Type*) [DivisionRing R] [Fintypeₓ R]:  Field R ",
      "theorem finite_division_ring_is_field (R : Type*) [DivisionRing R] (hR : FiniteDimensional R):  Field R ",
      "theorem finite_division_ring_is_field (D : Type*) [Ring D]  [FiniteDimensional D ℤ] [DivisionRing D]:  Field D ",
      "theorem finite_division_ring_is_field (D : Type*) [Ringₓₓ D]  [FiniteDimensional D ℤ] [DivisionRing D]:  Field D ",
      "theorem finite_division_ring_is_field (D : Type*) [Ringₓ D]  [FiniteDimensional D ℤ] [DivisionRing D]:  Field D ",
      "theorem finite_division_ring_of_field (D : Type*) [DivisionRing D] [Fintype D] (one_not_zero : (1 : D) ≠ 0) :  IsField D ",
      "theorem finite_division_ring_of_field (D : Type*) [DivisionRing D] [Fintypeₓ D] (one_not_zero : (1 : D) ≠ 0) :  IsField D "
    ],
    "answer": "theorem fin_div_ring_is_field {R : Type _} [DivisionRing R] [Finite R] : Field R "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "fin_div_ring_is_field",
      "main_prompt": "Every finite division ring is a field.",
      "prompt": "Natural language version: \"A subfield is closed under division.\" Translate the natural language version to a Lean mathlib version:\n theorem subfield.div_mem{K : Type u} [field K] (s : subfield K) {x y : K} :\nx ∈ s → y ∈ s → x / y ∈ s := \n\nNatural language version: \"A division_ring is one-dimensional as a vector space over itself.\" Translate the natural language version to a Lean mathlib version:\n theorem finite_dimensional.finrank_self(K : Type u) [division_ring K] :\nfinite_dimensional.finrank K K = 1 := \n\nNatural language version: \"An intermediate field is closed under division.\" Translate the natural language version to a Lean mathlib version:\n theorem intermediate_field.div_mem{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} :\nx ∈ S → y ∈ S → x / y ∈ S := \n\nNatural language version: \"A subfield is closed under multiplication.\" Translate the natural language version to a Lean mathlib version:\n theorem subfield.mul_mem{K : Type u} [field K] (s : subfield K) {x y : K} :\nx ∈ s → y ∈ s → x * y ∈ s := \n\nNatural language version: \"Every finite division ring is a field.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6756068468093872,
          "doc_string": "A subfield is closed under division.",
          "statement": "theorem subfield.div_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x / y ∈ s"
        },
        {
          "sim_score": 0.6545361280441284,
          "doc_string": "A division_ring is one-dimensional as a vector space over itself.",
          "statement": "theorem finite_dimensional.finrank_self (K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1"
        },
        {
          "sim_score": 0.6345528364181519,
          "doc_string": "An intermediate field is closed under division.",
          "statement": "theorem intermediate_field.div_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} : x ∈ S → y ∈ S → x / y ∈ S"
        },
        {
          "sim_score": 0.62082839012146,
          "doc_string": "A subfield is closed under multiplication.",
          "statement": "theorem subfield.mul_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x * y ∈ s"
        }
      ],
      "codex_time": 3.585240865009837,
      "search_time": 1.61453294500825,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem finite_dimensional.field(K : Type u) [Ring K] [FiniteDimensional K K] [DivisionRing K] : Field K ",
      "theorem finite_dimensional.field(K : Type u) [Ringₓₓ K] [FiniteDimensional K K] [DivisionRing K] : Field K ",
      "theorem finite_dimensional.field(K : Type u) [Ringₓ K] [FiniteDimensional K K] [DivisionRing K] : Field K ",
      "theorem division_ring.field(K : Type u) [DivisionRing K] (H :   Nat.Prime (FiniteDimensional.finrank K K)) : Field K ",
      "theorem finite_division_ring.field {K : Type u} [finite_division_ring K] : Field K ",
      "theorem fincard.division_ring_iff_field(K : Type u) [DivisionRing K] [h : Fintype K] : FiniteDimensional.finrank K K = 1 → Field K ",
      "theorem fincard.division_ring_iff_field(K : Type u) [DivisionRing K] [h : Fintypeₓ K] : FiniteDimensional.finrank K K = 1 → Field K ",
      "theorem finite_dimensional.field_of_division_ring(K : Type u) [DivisionRing K] (h : FiniteDimensional K K) : IsField K "
    ],
    "answer": "theorem fin_div_ring_is_field {R : Type _} [DivisionRing R] [Finite R] : Field R "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "fin_div_ring_is_field",
      "main_prompt": "Every finite division ring is a field.",
      "prompt": "Natural language version: \"Every finite division ring is a field.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 13.800993621000089,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem FinDivRingIsField :  ∀ {X : DivRing} (F : FinDivRing X), IsField  Proof. admit. Defined.    Theorem prop_310 {X: DivRing} (F:FinDivRing X) : IsField. Admitted.   ########################################################## FinRing ##########################################################   Definition FinRing ",
      "theorem every_finite_division_ring_is_field (D : Type*) [Fintype D] [DivisionRing D] : IsField D ",
      "theorem every_finite_division_ring_is_field (D : Type*) [Fintypeₓ D] [DivisionRing D] : IsField D ",
      "theorem Every_finite_division_ring_is_a_field : ∀ S : Set (DivisionRing α), Finite S → IsField S ",
      "theorem Every_finite_division_ring_is_a_field : ∀ S : Setₓ (DivisionRing α), Finite S → IsField S ",
      "theorem every_fd_is_a_field :     ∀ R : Type u,     Fintype (carrier R) →     DivisionRing R →     Field R   Make a free theorem: \"Every Finite integral IsDomain is a field.\" By how much does the problem of proving it change? The problem of proving it changes fractionally because we get to apply the theorem that \"Every Finite division Ring is a field.\"  From: https://leanprover.zulipchat.com/#narrow/Stream/116395-maths/topic/punchline/near/186535755 -/   import tactic universe u  class integral",
      "theorem every_fd_is_a_field :     ∀ R : Type u,     Fintype (carrier R) →     DivisionRing R →     Field R   Make a free theorem: \"Every Finite integral IsDomain is a field.\" By how much does the problem of proving it change? The problem of proving it changes fractionally because we get to apply the theorem that \"Every Finite division Ringₓₓ is a field.\"  From: https://leanprover.zulipchat.com/#narrow/Stream/116395-maths/topic/punchline/near/186535755 -/   import tactic universe u  class integral",
      "theorem every_fd_is_a_field :     ∀ R : Type u,     Fintype (carrier R) →     DivisionRing R →     Field R   Make a free theorem: \"Every Finite integral IsDomain is a field.\" By how much does the problem of proving it change? The problem of proving it changes fractionally because we get to apply the theorem that \"Every Finite division Ringₓ is a field.\"  From: https://leanprover.zulipchat.com/#narrow/Stream/116395-maths/topic/punchline/near/186535755 -/   import tactic universe u  class integral",
      "theorem every_fd_is_a_field :     ∀ R : Type u,     Fintype (carrier R) →     DivisionRing R →     Field R   Make a free theorem: \"Every Finite integral IsDomain is a field.\" By how much does the problem of proving it change? The problem of proving it changes fractionally because we get to apply the theorem that \"Every Finite division Ring is a field.\"  From: https://leanprover.zulipchat.com/#narrow/Streamₓ/116395-maths/topic/punchline/near/186535755 -/   import tactic universe u  class integral",
      "theorem every_fd_is_a_field :     ∀ R : Type u,     Fintype (carrier R) →     DivisionRing R →     Field R   Make a free theorem: \"Every Finite integral IsDomain is a field.\" By how much does the problem of proving it change? The problem of proving it changes fractionally because we get to apply the theorem that \"Every Finite division Ringₓₓ is a field.\"  From: https://leanprover.zulipchat.com/#narrow/Streamₓ/116395-maths/topic/punchline/near/186535755 -/   import tactic universe u  class integral",
      "theorem every_fd_is_a_field :     ∀ R : Type u,     Fintype (carrier R) →     DivisionRing R →     Field R   Make a free theorem: \"Every Finite integral IsDomain is a field.\" By how much does the problem of proving it change? The problem of proving it changes fractionally because we get to apply the theorem that \"Every Finite division Ringₓ is a field.\"  From: https://leanprover.zulipchat.com/#narrow/Streamₓ/116395-maths/topic/punchline/near/186535755 -/   import tactic universe u  class integral",
      "theorem every_fd_is_a_field :     ∀ R : Type u,     Fintypeₓ (carrier R) →     DivisionRing R →     Field R   Make a free theorem: \"Every Finite integral IsDomain is a field.\" By how much does the problem of proving it change? The problem of proving it changes fractionally because we get to apply the theorem that \"Every Finite division Ring is a field.\"  From: https://leanprover.zulipchat.com/#narrow/Stream/116395-maths/topic/punchline/near/186535755 -/   import tactic universe u  class integral",
      "theorem every_fd_is_a_field :     ∀ R : Type u,     Fintypeₓ (carrier R) →     DivisionRing R →     Field R   Make a free theorem: \"Every Finite integral IsDomain is a field.\" By how much does the problem of proving it change? The problem of proving it changes fractionally because we get to apply the theorem that \"Every Finite division Ringₓₓ is a field.\"  From: https://leanprover.zulipchat.com/#narrow/Stream/116395-maths/topic/punchline/near/186535755 -/   import tactic universe u  class integral",
      "theorem every_fd_is_a_field :     ∀ R : Type u,     Fintypeₓ (carrier R) →     DivisionRing R →     Field R   Make a free theorem: \"Every Finite integral IsDomain is a field.\" By how much does the problem of proving it change? The problem of proving it changes fractionally because we get to apply the theorem that \"Every Finite division Ringₓ is a field.\"  From: https://leanprover.zulipchat.com/#narrow/Stream/116395-maths/topic/punchline/near/186535755 -/   import tactic universe u  class integral",
      "theorem every_fd_is_a_field :     ∀ R : Type u,     Fintypeₓ (carrier R) →     DivisionRing R →     Field R   Make a free theorem: \"Every Finite integral IsDomain is a field.\" By how much does the problem of proving it change? The problem of proving it changes fractionally because we get to apply the theorem that \"Every Finite division Ring is a field.\"  From: https://leanprover.zulipchat.com/#narrow/Streamₓ/116395-maths/topic/punchline/near/186535755 -/   import tactic universe u  class integral",
      "theorem every_fd_is_a_field :     ∀ R : Type u,     Fintypeₓ (carrier R) →     DivisionRing R →     Field R   Make a free theorem: \"Every Finite integral IsDomain is a field.\" By how much does the problem of proving it change? The problem of proving it changes fractionally because we get to apply the theorem that \"Every Finite division Ringₓₓ is a field.\"  From: https://leanprover.zulipchat.com/#narrow/Streamₓ/116395-maths/topic/punchline/near/186535755 -/   import tactic universe u  class integral",
      "theorem every_fd_is_a_field :     ∀ R : Type u,     Fintypeₓ (carrier R) →     DivisionRing R →     Field R   Make a free theorem: \"Every Finite integral IsDomain is a field.\" By how much does the problem of proving it change? The problem of proving it changes fractionally because we get to apply the theorem that \"Every Finite division Ringₓ is a field.\"  From: https://leanprover.zulipchat.com/#narrow/Streamₓ/116395-maths/topic/punchline/near/186535755 -/   import tactic universe u  class integral",
      "theorem QP_dvr_is_field (F : DivisionRing) : IsField F --Don't care about the proof  -- \"Every union of an indexed collection of sets is an indexed collection of sets\". --This is a bogus example because this statement doesn't make sense without \"indexed collection\" clarified. def yee :     ∀ (ι : Type) (I J : ι → Type),         (∀ i : ι, Set I i)    → Set (union J)  | ι I J P ",
      "theorem QP_dvr_is_field (F : DivisionRing) : IsField F --Don't care about the proof  -- \"Every union of an indexed collection of sets is an indexed collection of sets\". --This is a bogus example because this statement doesn't make sense without \"indexed collection\" clarified. def yee :     ∀ (ι : Type) (I J : ι → Type),         (∀ i : ι, Setₓ I i)    → Setₓ (union J)  | ι I J P "
    ],
    "answer": "theorem fin_div_ring_is_field {R : Type _} [DivisionRing R] [Finite R] : Field R "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "am_gm_ineq",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"The product of two positive numbers is at most the square of their average.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The product of two positive numbers is at most the square of their average.",
      "codex_time": 6.657072167989099,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem prod_le_square_avg (a b : ℝ) (hab : 0 ≤ a) (hbb : 0 ≤ b) :  a * b ≤ (a + b)^2 / 2 ",
      "theorem sqrt_mul_le_mul (a b : ℝ) (ha : 0 ≤ a) (hb : 0 ≤ b) :  a*b ≤ sqrt (a)*sqrt (b) * sqrt (a)*sqrt (b) ",
      "theorem leq_prod_leq_sq_sum (x y : ℝ) (hx : x ≥ 0) (hy : y ≥ 0) :  x * y ≤ (x + y)^2 / 2 ",
      "theorem product_leq_average_square (x y : ℝ) (hx0 : 0 < x) (hy0 : 0 < y) :  x*y ≤ (x + y)^2 / 2 ",
      "theorem mul_le_square_of_average_nonneg (x y : ℝ) (hx : 0 ≤ x) (hy : 0 ≤ y) :  x * y ≤ (x + y) / 2 * (x + y) "
    ],
    "answer": "theorem am_gm_ineq : ∀ (a b : ℝ), a > 0 → b > 0 → a * b ≤ ((a + b)/(1 + 1))^2 "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "am_gm_ineq",
      "main_prompt": "The product of two positive numbers is at most the square of their average.",
      "prompt": "Natural language version: \" The geometric mean is less than or equal to the arithmetic mean, weighted version for two `nnreal` numbers.\" Translate the natural language version to a Lean mathlib version:\n theorem nnreal.geom_mean_le_arith_mean2_weighted(w₁ w₂ p₁ p₂ : nnreal) :\nw₁ + w₂ = 1 → p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂ := \n\nNatural language version: \"The square of the smallest prime factor of a composite number `n` is at most `n`.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.min_fac_sq_le_self{n : ℕ} (w : 0 < n) (h : ¬nat.prime n) :\nn.min_fac ^ 2 ≤ n := \n\nNatural language version: \" AM-GM inequality: the **geometric mean is less than or equal to the arithmetic mean**, weighted version for real-valued nonnegative functions.\" Translate the natural language version to a Lean mathlib version:\n theorem real.geom_mean_le_arith_mean_weighted{ι : Type u} (s : finset ι) (w z : ι → ℝ) (hw : ∀ (i : ι), i ∈ s → 0 ≤ w i) (hw' : s.sum (λ (i : ι), w i) = 1) (hz : ∀ (i : ι), i ∈ s → 0 ≤ z i) :\ns.prod (λ (i : ι), z i ^ w i) ≤ s.sum (λ (i : ι), w i * z i) := \n\nNatural language version: \"The natural square root is at most the real square root\" Translate the natural language version to a Lean mathlib version:\n theorem real.nat_sqrt_le_real_sqrt{a : ℕ} :\n↑(nat.sqrt a) ≤ real.sqrt ↑a := \n\nNatural language version: \"The product of two positive numbers is at most the square of their average.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5334862470626831,
          "doc_string": " The geometric mean is less than or equal to the arithmetic mean, weighted version for two `nnreal` numbers.",
          "statement": "theorem nnreal.geom_mean_le_arith_mean2_weighted (w₁ w₂ p₁ p₂ : nnreal) : w₁ + w₂ = 1 → p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂"
        },
        {
          "sim_score": 0.5259432196617126,
          "doc_string": "The square of the smallest prime factor of a composite number `n` is at most `n`.",
          "statement": "theorem nat.min_fac_sq_le_self {n : ℕ} (w : 0 < n) (h : ¬nat.prime n) : n.min_fac ^ 2 ≤ n"
        },
        {
          "sim_score": 0.5007948279380798,
          "doc_string": " AM-GM inequality: the **geometric mean is less than or equal to the arithmetic mean**, weighted version for real-valued nonnegative functions.",
          "statement": "theorem real.geom_mean_le_arith_mean_weighted {ι : Type u} (s : finset ι) (w z : ι → ℝ) (hw : ∀ (i : ι), i ∈ s → 0 ≤ w i) (hw' : s.sum (λ (i : ι), w i) = 1) (hz : ∀ (i : ι), i ∈ s → 0 ≤ z i) : s.prod (λ (i : ι), z i ^ w i) ≤ s.sum (λ (i : ι), w i * z i)"
        },
        {
          "sim_score": 0.4941546320915222,
          "doc_string": "The natural square root is at most the real square root",
          "statement": "theorem real.nat_sqrt_le_real_sqrt {a : ℕ} : ↑(nat.sqrt a) ≤ real.sqrt ↑a"
        }
      ],
      "codex_time": 5.2238901399832685,
      "search_time": 1.4299069349945057,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem real.mul_le_sqr_pos{a b : ℝ} :  0 < a → 0 < b → a * b ≤ (a + b) ^ 2 ",
      "theorem real.two_mul_le_two_sqr(r s : ℝ) (h₀ : 0 < r) (h₁ : 0 < s) : r * s ≤ (r + s) / 2 * (r + s) ",
      "theorem real.prod_le_avg_sq{a b : ℝ} (wa : 0 < a) (wb : 0 < b) : a * b ≤ (a + b) ^ 2 / 4 ",
      "theorem real.product_le_average(a b : Nnreal) : a * b ≤ (a+b)/2 ",
      "theorem real.le.mul{a b : ℝ} (ha : 0 < a) (hb : 0 < b) :  a * b ≤ (a + b) / 2 * (a + b) / 2 "
    ],
    "answer": "theorem am_gm_ineq : ∀ (a b : ℝ), a > 0 → b > 0 → a * b ≤ ((a + b)/(1 + 1))^2 "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "am_gm_ineq",
      "main_prompt": "The product of two positive numbers is at most the square of their average.",
      "prompt": "Natural language version: \"The product of two positive numbers is at most the square of their average.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 6.413750496023567,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem sqrt_le_sqrt_iff_le_iff (x y : ℝ) : √ x ≤ √ y ↔ x ≤ y ",
      "theorem IJK: ∀ (a b:ℝ) (I:a>0) (J: b>0), a*b ≤ (a+b)^2/4 ",
      "theorem foo (n m : ℕ)  (h1 : 0 < n ∧ 0 < m) : m * n <= (n + m) * (n + m) / 4 ",
      "theorem foo (a b : ℝ) (hab : 0 < a) (hbb : 0 < b) : a * b ≤ (a + b)^2 / 4  -- The next line is Lean reading the proof back to us.  -- Notice that we needed to say 0 < a and 0 < b to make sure the  -- expression (a + b) / 2 is actually a real number. ",
      "theorem prod_le_sqr_avg { x y : R } ( hx : 0 ≤ x ) ( hy : 0 ≤ y ) : x * y ≤ ( x + y ) / 2 "
    ],
    "answer": "theorem am_gm_ineq : ∀ (a b : ℝ), a > 0 → b > 0 → a * b ≤ ((a + b)/(1 + 1))^2 "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "sylvester_gallai",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"In any configuration of points on the plane, not all on a line, there is a line which contains exactly two of the points.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "In any configuration of points on the plane, not all on a line, there is a line which contains exactly two of the points.",
      "codex_time": 14.475803741021082,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem four_points_are_collinear_not_all_on_one_line (X : Type*) [discrete_linear_ordered_field X] (p1 p2 p3 p4 : X × X) :  p1 = p2 ∨ p1 = p3 ∨ p1 = p4 ∨ p2 = p3 ∨ p2 = p4 ∨ p3 = p4 ∨  let l ",
      "theorem existence_of_line_through_two_points (X : Type*) [Inhabited X] [AddCommGroup X] [∀ a b : X, dist a b = dist b a] [∀ a b c : X, dist a c ≤ dist a b + dist b c]  (F : Set (Set X)) (h_set_of_points_is_not_on_line : ∀ a ∉ F, ∃ b c ∈ F, a ∉ line_through b c) :  ∃ b c ∈ F, ∀ d ∈ F, d ≠ b ∧ d ≠ c → ¬ line_through",
      "theorem existence_of_line_through_two_points (X : Type*) [Inhabited X] [AddCommGroupₓₓ X] [∀ a b : X, dist a b = dist b a] [∀ a b c : X, dist a c ≤ dist a b + dist b c]  (F : Set (Set X)) (h_set_of_points_is_not_on_line : ∀ a ∉ F, ∃ b c ∈ F, a ∉ line_through b c) :  ∃ b c ∈ F, ∀ d ∈ F, d ≠ b ∧ d ≠ c → ¬ line_through",
      "theorem existence_of_line_through_two_points (X : Type*) [Inhabited X] [AddCommGroup X] [∀ a b : X, dist a b = dist b a] [∀ a b c : X, dist a c ≤ dist a b + dist b c]  (F : Setₓ (Setₓ X)) (h_set_of_points_is_not_on_line : ∀ a ∉ F, ∃ b c ∈ F, a ∉ line_through b c) :  ∃ b c ∈ F, ∀ d ∈ F, d ≠ b ∧ d ≠ c → ¬ line_through",
      "theorem existence_of_line_through_two_points (X : Type*) [Inhabited X] [AddCommGroupₓₓ X] [∀ a b : X, dist a b = dist b a] [∀ a b c : X, dist a c ≤ dist a b + dist b c]  (F : Setₓ (Setₓ X)) (h_set_of_points_is_not_on_line : ∀ a ∉ F, ∃ b c ∈ F, a ∉ line_through b c) :  ∃ b c ∈ F, ∀ d ∈ F, d ≠ b ∧ d ≠ c → ¬ line_through",
      "theorem existence_of_line_through_two_points (X : Type*) [Inhabited X] [AddCommGroupₓ X] [∀ a b : X, dist a b = dist b a] [∀ a b c : X, dist a c ≤ dist a b + dist b c]  (F : Set (Set X)) (h_set_of_points_is_not_on_line : ∀ a ∉ F, ∃ b c ∈ F, a ∉ line_through b c) :  ∃ b c ∈ F, ∀ d ∈ F, d ≠ b ∧ d ≠ c → ¬ line_through",
      "theorem existence_of_line_through_two_points (X : Type*) [Inhabited X] [AddCommGroupₓ X] [∀ a b : X, dist a b = dist b a] [∀ a b c : X, dist a c ≤ dist a b + dist b c]  (F : Setₓ (Setₓ X)) (h_set_of_points_is_not_on_line : ∀ a ∉ F, ∃ b c ∈ F, a ∉ line_through b c) :  ∃ b c ∈ F, ∀ d ∈ F, d ≠ b ∧ d ≠ c → ¬ line_through",
      "theorem intermediate_value_thm_of_completeness_of_reals (a b : ℝ) (h : a < b) (f : ℝ → ℝ)  (hf : Continuous f) (h_a_neq_b : f a ≠ f b) :  ∃ c : ℝ, a < c ∧ c < b ∧ f a * f c < 0 ",
      "theorem choose_two_points_on_a_line (n : ℕ) {p₁ p₂ ... pₙ : ℝ^2} :  pdd ",
      "theorem two_points_on_line (X : Type*) [AddCommGroup X] [vector_space ℝ X] [FiniteDimensional ℝ X]  [MetricSpace X] (S : Set X) (hS : ∀ a b : X, a ≠ b → ∃ c d : X, is_line a b c d ∧ c ≠ d) :  ∃ a b c : X, is_line a b c c ∧ c ≠ a ∧ c ≠ b ",
      "theorem two_points_on_line (X : Type*) [AddCommGroupₓₓ X] [vector_space ℝ X] [FiniteDimensional ℝ X]  [MetricSpace X] (S : Set X) (hS : ∀ a b : X, a ≠ b → ∃ c d : X, is_line a b c d ∧ c ≠ d) :  ∃ a b c : X, is_line a b c c ∧ c ≠ a ∧ c ≠ b ",
      "theorem two_points_on_line (X : Type*) [AddCommGroup X] [vector_space ℝ X] [FiniteDimensional ℝ X]  [MetricSpace X] (S : Setₓ X) (hS : ∀ a b : X, a ≠ b → ∃ c d : X, is_line a b c d ∧ c ≠ d) :  ∃ a b c : X, is_line a b c c ∧ c ≠ a ∧ c ≠ b ",
      "theorem two_points_on_line (X : Type*) [AddCommGroupₓₓ X] [vector_space ℝ X] [FiniteDimensional ℝ X]  [MetricSpace X] (S : Setₓ X) (hS : ∀ a b : X, a ≠ b → ∃ c d : X, is_line a b c d ∧ c ≠ d) :  ∃ a b c : X, is_line a b c c ∧ c ≠ a ∧ c ≠ b ",
      "theorem two_points_on_line (X : Type*) [AddCommGroupₓ X] [vector_space ℝ X] [FiniteDimensional ℝ X]  [MetricSpace X] (S : Set X) (hS : ∀ a b : X, a ≠ b → ∃ c d : X, is_line a b c d ∧ c ≠ d) :  ∃ a b c : X, is_line a b c c ∧ c ≠ a ∧ c ≠ b ",
      "theorem two_points_on_line (X : Type*) [AddCommGroupₓ X] [vector_space ℝ X] [FiniteDimensional ℝ X]  [MetricSpace X] (S : Setₓ X) (hS : ∀ a b : X, a ≠ b → ∃ c d : X, is_line a b c d ∧ c ≠ d) :  ∃ a b c : X, is_line a b c c ∧ c ≠ a ∧ c ≠ b "
    ],
    "answer": "theorem sylvester_gallai {P L : Type _} [HasMem P L] [Membership P L] [Configuration.Nondegenerate P L] : ∃ (l : L) (p q : P), p ∈ l → q ∈ l → (∀ r : P, r ∈ l → r = p ∨ r = q) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "sylvester_gallai",
      "main_prompt": "In any configuration of points on the plane, not all on a line, there is a line which contains exactly two of the points.",
      "prompt": "Natural language version: \"A single point is collinear.\" Translate the natural language version to a Lean mathlib version:\n theorem collinear_singleton(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) :\ncollinear k {p} := \n\nNatural language version: \"If a nondegenerate configuration has at least as many points as lines, then there exists  an injective function `f` from lines to points, such that `f l` does not lie on `l`.\" Translate the natural language version to a Lean mathlib version:\n theorem configuration.nondegenerate.exists_injective_of_card_le{P L : Type u} [has_mem P L] [configuration.nondegenerate P L] [fintype P] [fintype L] (h : fintype.card L ≤ fintype.card P) :\n∃ (f : L → P), function.injective f ∧ ∀ (l : L), f l ∉ l := \n\nNatural language version: \"If a nondegenerate configuration has a unique point on any two lines, then `|L| ≤ |P|`.\" Translate the natural language version to a Lean mathlib version:\n theorem configuration.has_points.card_le(P L : Type u) [has_mem P L] [configuration.has_points P L] [fintype P] [fintype L] :\nfintype.card L ≤ fintype.card P := \n\nNatural language version: \"If a nondegenerate configuration has a unique line through any two points, then `|P| ≤ |L|`.\" Translate the natural language version to a Lean mathlib version:\n theorem configuration.has_lines.card_le(P L : Type u) [has_mem P L] [configuration.has_lines P L] [fintype P] [fintype L] :\nfintype.card P ≤ fintype.card L := \n\nNatural language version: \"In any configuration of points on the plane, not all on a line, there is a line which contains exactly two of the points.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5291177034378052,
          "doc_string": "A single point is collinear.",
          "statement": "theorem collinear_singleton (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) : collinear k {p}"
        },
        {
          "sim_score": 0.5157747268676758,
          "doc_string": "If a nondegenerate configuration has at least as many points as lines, then there exists  an injective function `f` from lines to points, such that `f l` does not lie on `l`.",
          "statement": "theorem configuration.nondegenerate.exists_injective_of_card_le {P L : Type u} [has_mem P L] [configuration.nondegenerate P L] [fintype P] [fintype L] (h : fintype.card L ≤ fintype.card P) : ∃ (f : L → P), function.injective f ∧ ∀ (l : L), f l ∉ l"
        },
        {
          "sim_score": 0.5101643800735474,
          "doc_string": "If a nondegenerate configuration has a unique point on any two lines, then `|L| ≤ |P|`.",
          "statement": "theorem configuration.has_points.card_le (P L : Type u) [has_mem P L] [configuration.has_points P L] [fintype P] [fintype L] : fintype.card L ≤ fintype.card P"
        },
        {
          "sim_score": 0.500416100025177,
          "doc_string": "If a nondegenerate configuration has a unique line through any two points, then `|P| ≤ |L|`.",
          "statement": "theorem configuration.has_lines.card_le (P L : Type u) [has_mem P L] [configuration.has_lines P L] [fintype P] [fintype L] : fintype.card P ≤ fintype.card L"
        }
      ],
      "codex_time": 9.957743514009053,
      "search_time": 1.4894644650048576,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem configuration.no_lines.exists_collinear_two{k : Type u_1} {P : Type u_2} [DivisionRing k] [AddCommGroup k] [Module k V] {V : Type u_3} [AddCommGroup V] [vector_space k V] [AddTorsor V P] [configuration P V] (hP : ¬ ∀ (p1 p2 : P), p1 ∈ (Collinear k {p2})) : ∃ (c p1 p2 : P), p1 ≠ p2 ∧ Collinear k {p1, p2}",
      "theorem configuration.no_lines.exists_collinear_two{k : Type u_1} {P : Type u_2} [DivisionRing k] [AddCommGroupₓₓ k] [Module k V] {V : Type u_3} [AddCommGroupₓₓ V] [vector_space k V] [AddTorsor V P] [configuration P V] (hP : ¬ ∀ (p1 p2 : P), p1 ∈ (Collinear k {p2})) : ∃ (c p1 p2 : P), p1 ≠ p2 ∧ Collinear k {p1, p2}",
      "theorem configuration.no_lines.exists_collinear_two{k : Type u_1} {P : Type u_2} [DivisionRing k] [AddCommGroupₓ k] [Module k V] {V : Type u_3} [AddCommGroupₓ V] [vector_space k V] [AddTorsor V P] [configuration P V] (hP : ¬ ∀ (p1 p2 : P), p1 ∈ (Collinear k {p2})) : ∃ (c p1 p2 : P), p1 ≠ p2 ∧ Collinear k {p1, p2}",
      "theorem configuration.on_plane.exists_line_of_card_ge_three(P : Type u) [HasMem P line] [configuration.on_plane circle P] [Fintype P] [Configuration.Nondegenerate (Nonempty P) line] (h : Fintype.card P ≥ 3) : ∃ (l : line), l ∩ P = ⊥ ",
      "theorem configuration.on_plane.exists_line_of_card_ge_three(P : Type u) [HasMem P line] [configuration.on_plane circle P] [Fintypeₓ P] [Configuration.Nondegenerate (Nonempty P) line] (h : Fintypeₓ.card P ≥ 3) : ∃ (l : line), l ∩ P = ⊥ ",
      "theorem configuration.nondegenerate.has_two(P : fin_set ℝ²) (h : is_nondegenerate P) : ∃ (l : fin_set ℝ), l ∉ P ∧ ∃ (p q : ℝ), l ⊆ {p, q} ∧ Fintype.card l = 2 ",
      "theorem configuration.nondegenerate.has_two(P : fin_set ℝ²) (h : is_nondegenerate P) : ∃ (l : fin_set ℝ), l ∉ P ∧ ∃ (p q : ℝ), l ⊆ {p, q} ∧ Fintypeₓ.card l = 2 ",
      "theorem configuration.linear_pair_lemma(P : Type u_1) [HasMem P (aff_pt (aff_str ℤ 3))] [Fintype P] [OrderedRing α] [AddCommGroup (aff_pt (aff_str ℤ 3))] [vector_space α (aff_pt (aff_str ℤ 3))] [aff_pt (aff_str ℤ 3) : HasScalar α] [aff_pt (aff_str ℤ 3) : is_basis.{u_1 u_2} (aff_pt (aff_str ℤ 3)) α] [",
      "theorem configuration.linear_pair_lemma(P : Type u_1) [HasMem P (aff_pt (aff_str ℤ 3))] [Fintype P] [OrderedRing α] [AddCommGroupₓₓ (aff_pt (aff_str ℤ 3))] [vector_space α (aff_pt (aff_str ℤ 3))] [aff_pt (aff_str ℤ 3) : HasScalar α] [aff_pt (aff_str ℤ 3) : is_basis.{u_1 u_2} (aff_pt (aff_str ℤ 3)) α] [",
      "theorem configuration.linear_pair_lemma(P : Type u_1) [HasMem P (aff_pt (aff_str ℤ 3))] [Fintype P] [OrderedRing α] [AddCommGroupₓ (aff_pt (aff_str ℤ 3))] [vector_space α (aff_pt (aff_str ℤ 3))] [aff_pt (aff_str ℤ 3) : HasScalar α] [aff_pt (aff_str ℤ 3) : is_basis.{u_1 u_2} (aff_pt (aff_str ℤ 3)) α] [",
      "theorem configuration.linear_pair_lemma(P : Type u_1) [HasMem P (aff_pt (aff_str ℤ 3))] [Fintypeₓ P] [OrderedRing α] [AddCommGroup (aff_pt (aff_str ℤ 3))] [vector_space α (aff_pt (aff_str ℤ 3))] [aff_pt (aff_str ℤ 3) : HasScalar α] [aff_pt (aff_str ℤ 3) : is_basis.{u_1 u_2} (aff_pt (aff_str ℤ 3)) α] [",
      "theorem configuration.linear_pair_lemma(P : Type u_1) [HasMem P (aff_pt (aff_str ℤ 3))] [Fintypeₓ P] [OrderedRing α] [AddCommGroupₓₓ (aff_pt (aff_str ℤ 3))] [vector_space α (aff_pt (aff_str ℤ 3))] [aff_pt (aff_str ℤ 3) : HasScalar α] [aff_pt (aff_str ℤ 3) : is_basis.{u_1 u_2} (aff_pt (aff_str ℤ 3)) α] [",
      "theorem configuration.linear_pair_lemma(P : Type u_1) [HasMem P (aff_pt (aff_str ℤ 3))] [Fintypeₓ P] [OrderedRing α] [AddCommGroupₓ (aff_pt (aff_str ℤ 3))] [vector_space α (aff_pt (aff_str ℤ 3))] [aff_pt (aff_str ℤ 3) : HasScalar α] [aff_pt (aff_str ℤ 3) : is_basis.{u_1 u_2} (aff_pt (aff_str ℤ 3)) α] [",
      "theorem picard_1_eg(V : Type u_1) {P : Type u_2} [t ℝ] [AddTorsor ℝ V] [HasMem V P] [DecidableEq P] [Finite V] [Finite P] (h_coplanar : ∀ (p q r : P) (v : V), r ∈ p ⟶ᵇ v ∧ r ∉ p ⟶ᵇ v → p = q) (h_not_all_on_line : ∃ (p q : P), p ≠ q) : ∃ (p q : P) (v : V),"
    ],
    "answer": "theorem sylvester_gallai {P L : Type _} [HasMem P L] [Membership P L] [Configuration.Nondegenerate P L] : ∃ (l : L) (p q : P), p ∈ l → q ∈ l → (∀ r : P, r ∈ l → r = p ∨ r = q) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "sylvester_gallai",
      "main_prompt": "In any configuration of points on the plane, not all on a line, there is a line which contains exactly two of the points.",
      "prompt": "Natural language version: \"In any configuration of points on the plane, not all on a line, there is a line which contains exactly two of the points.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 13.03304845301318,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem two_points_on_line (p q : point) :     ∃ l : line, on_line l p ∧ on_line l q ",
      "theorem pigeonhole : ∀ S t, S.size > t.size → ∃ (f : S → t), f.injective ",
      "theorem at_least_two_on_line {T : Type} [hd : FiniteDimensional T] (s : Set T) :  not (∀a, a ∈ s → a ∈ Set.Univ) → ",
      "theorem at_least_two_on_line {T : Type} [hd : FiniteDimensional T] (s : Setₓ T) :  not (∀a, a ∈ s → a ∈ Setₓ.Univ) → ",
      "theorem example: ∀ (p q r s : point . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
      "theorem my_lemma :      ∀ (a b c d e f g h i : ℝ),      (a ≠ b) ∧ (a ≠ c) ∧ (a ≠ d) ∧ (a ≠ e) ∧ (a ≠ f) ∧ (a ≠ g) ∧ (a ≠ h) ∧ (a ≠ i) ∧      (b ≠ c) ∧ (b ≠ d) ∧ (b ≠ e) ∧ (b ≠ f) ∧ (b ≠ g) ∧ (b ≠ h) ∧ (b ≠ i) ∧     "
    ],
    "answer": "theorem sylvester_gallai {P L : Type _} [HasMem P L] [Membership P L] [Configuration.Nondegenerate P L] : ∃ (l : L) (p q : P), p ∈ l → q ∈ l → (∀ r : P, r ∈ l → r = p ∨ r = q) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "cantor_schroeder_bernstein",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"If each of two types can be mapped injectively into the other, then there is a bijection between them.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If each of two types can be mapped injectively into the other, then there is a bijection between them.",
      "codex_time": 6.707535443012603,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem two_types_bijective_to_each_other_bijective  (X Y : Type*) (f : X → Y) (g : Y → X)  (f_inj : injective f) (g_inj : injective g) :  bijective (λ x : X, g (f x)) ",
      "theorem injective_map_implies_bijection {α β : Type} (f : α → β) :  injective f → surjective f → bijective f ",
      "theorem if_injective_then_bijective_map_exists (X Y : Type*)  (hXY : ∃ (f : X → Y), Function.Injective f)  (hYX : ∃ (g : Y → X), Function.Injective g) :  ∃ (h : X → Y), Function.bijective h ",
      "theorem bijection_exists_of_injections (α β : Type*)  (f : α → β) (hf : injective f)  (g : β → α) (hg : injective g) : ∃ g' : α → β, bijective g' ",
      "theorem two_injections_make_bijection {α β : Type*}    {f : α → β} {g : β → α} (hf : Function.Injective f) (hg : Function.Injective g) :    ∃ g' : α → β, bijective g' "
    ],
    "answer": "theorem cantor_schroeder_bernstein {α β : Type _} (f : α → β) (g : β → α) : Function.Injective f → Function.Injective g → (∃ h : α → β, Function.Bijective h) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "cantor_schroeder_bernstein",
      "main_prompt": "If each of two types can be mapped injectively into the other, then there is a bijection between them.",
      "prompt": "Natural language version: \" **The Schröder-Bernstein Theorem**: Given injections `α → β` and `β → α`, we can get a bijection `α → β`.\" Translate the natural language version to a Lean mathlib version:\n theorem function.embedding.schroeder_bernstein{α : Type u} {β : Type v} {f : α → β} {g : β → α} (hf : function.injective f) (hg : function.injective g) :\n∃ (h : α → β), function.bijective h := \n\nNatural language version: \"A morphism in `Type u` is an isomorphism if and only if it is bijective.\" Translate the natural language version to a Lean mathlib version:\n theorem category_theory.is_iso_iff_bijective{X Y : Type u} (f : X ⟶ Y) :\ncategory_theory.is_iso f ↔ function.bijective f := \n\nNatural language version: \"An equivalence is essentially surjective.  See <https://stacks.math.columbia.edu/tag/02C3>.\" Translate the natural language version to a Lean mathlib version:\n theorem category_theory.equivalence.ess_surj_of_equivalence{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) [category_theory.is_equivalence F] :\ncategory_theory.ess_surj F := \n\nNatural language version: \"If two subtypes of a fintype have equal cardinality, so do their complements.\" Translate the natural language version to a Lean mathlib version:\n theorem fintype.card_compl_eq_card_compl{α : Type u_1} [fintype α] (p q : α → Prop) [fintype {x // p x}] [fintype {x // ¬p x}] [fintype {x // q x}] [fintype {x // ¬q x}] (h : fintype.card {x // p x} = fintype.card {x // q x}) :\nfintype.card {x // ¬p x} = fintype.card {x // ¬q x} := \n\nNatural language version: \"If each of two types can be mapped injectively into the other, then there is a bijection between them.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.648023247718811,
          "doc_string": " **The Schröder-Bernstein Theorem**: Given injections `α → β` and `β → α`, we can get a bijection `α → β`.",
          "statement": "theorem function.embedding.schroeder_bernstein {α : Type u} {β : Type v} {f : α → β} {g : β → α} (hf : function.injective f) (hg : function.injective g) : ∃ (h : α → β), function.bijective h"
        },
        {
          "sim_score": 0.617520809173584,
          "doc_string": "A morphism in `Type u` is an isomorphism if and only if it is bijective.",
          "statement": "theorem category_theory.is_iso_iff_bijective {X Y : Type u} (f : X ⟶ Y) : category_theory.is_iso f ↔ function.bijective f"
        },
        {
          "sim_score": 0.612472414970398,
          "doc_string": "An equivalence is essentially surjective.  See <https://stacks.math.columbia.edu/tag/02C3>.",
          "statement": "theorem category_theory.equivalence.ess_surj_of_equivalence {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) [category_theory.is_equivalence F] : category_theory.ess_surj F"
        },
        {
          "sim_score": 0.6091285347938538,
          "doc_string": "If two subtypes of a fintype have equal cardinality, so do their complements.",
          "statement": "theorem fintype.card_compl_eq_card_compl {α : Type u_1} [fintype α] (p q : α → Prop) [fintype {x // p x}] [fintype {x // ¬p x}] [fintype {x // q x}] [fintype {x // ¬q x}] (h : fintype.card {x // p x} = fintype.card {x // q x}) : fintype.card {x // ¬p x} = fintype.card {x // ¬q x}"
        }
      ],
      "codex_time": 10.661786549026147,
      "search_time": 1.443614877993241,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem nonempty.schroeder_bernstein{α : Type u} (β : Nonempty (Type v)) : ∃ (f : α → β.value), Function.bijective f ",
      "theorem function.injective.bijective_of_self_injective {α : Type u_1} {β : Type u_2} (f : α → β) : Function.Injective f → ∃ g, Function.bijective g ",
      "theorem function.exists_bijective_of_injective_left_inverse{α : Type u} {β : Type v} {f : α → β} {g : β → α} (hf: Function.Injective f) (hg: Function.Injective g) (h : ∀ x, g (f x) = x) : ∃ (h : α → β), Function.bijective h ",
      "theorem function.embedding.schroeder_bernstein{α : Type u} {β : Type v} {f : α → β} {g : β → α} (hf : Function.Injective f) (hg : Function.Injective g) : ∃ (h : α → β), Function.bijective h ",
      "theorem schroeder_bernstein {α β : Type u} (h1 : α ⟶ β) (h2 : β ⟶ α) (inj₁ : Function.Injective h1) (inj₂ : Function.Injective h2) : Nonempty (Equiv α β) ",
      "theorem schroeder_bernstein {α β : Type u} (h1 : α ⟶ β) (h2 : β ⟶ α) (inj₁ : Function.Injective h1) (inj₂ : Function.Injective h2) : Nonempty (Equivₓ α β) "
    ],
    "answer": "theorem cantor_schroeder_bernstein {α β : Type _} (f : α → β) (g : β → α) : Function.Injective f → Function.Injective g → (∃ h : α → β, Function.Bijective h) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "cantor_schroeder_bernstein",
      "main_prompt": "If each of two types can be mapped injectively into the other, then there is a bijection between them.",
      "prompt": "Natural language version: \"If each of two types can be mapped injectively into the other, then there is a bijection between them.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 6.919001622998621,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem iff_injective { A B : Type* } ( f g : A → B ) [ injA : function . injective f ] [ injB : function . injective g ] : function . bijective ( f ∘ g ) ",
      "theorem eq_iff_bij_betw {α} {β} {f : α → β} {g : α → β} (hf : Function.Injective f) (hg : Function.Injective g) :   f = g ↔ bij_betw f univ univ",
      "theorem textbijection_iff_bijective_maps (X Y:Type) (f:X->Y) (g:Y->X) :     (bijection f /\\ bijection g) <-> (∀ x : X, (g (f x) = x) ∧ (f (g y) = y)) ",
      "theorem problem : IsMonoidUnital R → IsMonoidUnital C → ∃g : R → C, ∀r : R, g (r * One R) = g r ",
      "theorem nat.inj_iff_bijective (f g : α → β) :   ∀ (hf : injective f) (hg : injective g),   (∀ a b : α, f a = f b ↔ g a = g b) ↔ Function.bijective f g "
    ],
    "answer": "theorem cantor_schroeder_bernstein {α β : Type _} (f : α → β) (g : β → α) : Function.Injective f → Function.Injective g → (∃ h : α → β, Function.Bijective h) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "graph_unique_common_neighbour_implies_universal_adjacent_vertex",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"A finite graph in which every two vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A finite graph in which every two vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.",
      "codex_time": 11.536435332003748,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem fin_graph_with_1_edge_shared_has_vertex_adjacent_to_all (G : SimpleGraph ℕ)  (h : to_finset (fin_set.univ) ∉ G.enomultiadjacencies) (hfin : finset.card G.vertices < ⊤) :  ∃ hv, ∀ (v : G.vertex_set), hv.2 v = hv.1.2 ",
      "theorem d_regular_finite_graph_contains_center (G : Type*) [finite_graph G]  (hG : ∀ a b : G, ∃ c : G, c ≠ a ∧ c ≠ b ∧ c ",
      "theorem graph_with_unique_common_neighbour_has_vertex_adjacent_to_all_others  (G : Finset (Finset ℕ)) (H : ∀ x y ∈ G.val, finset.card (x ∩ y) = 1) :  ∃ y ∈ G.val, (∀ x, x ≠ y → y ∩ x ≠ ∅) ",
      "theorem pigeonhole_with_couple (n m : ℕ) (f : Fin n → Fin m) :   ∃ c : Fin m, (∀ a : Fin n, f a = c) ∨ (∀ a : Fin n, f a ≠ c) ",
      "theorem pigeonhole_with_couple (n m : ℕ) (f : Finₓ n → Finₓ m) :   ∃ c : Finₓ m, (∀ a : Finₓ n, f a = c) ∨ (∀ a : Finₓ n, f a ≠ c) ",
      "theorem one_common_neighbor_has_central_point (G : Type*) [Fintype G] [DecidableEq G]  [Fintype (G × G)] [DecidableEq (G × G)] [Fintype (G × G × G)]  [DecidableEq (G × G × G)] [fin_digraph_with_edge G]  (hx : ∀ (y x : G), ∃! z : G, edge_between y x z) : ∃ z : G,  ∀ (x : G) (hxz : ¬edge_between x z z), edge_between x z z ",
      "theorem one_common_neighbor_has_central_point (G : Type*) [Fintypeₓ G] [DecidableEq G]  [Fintypeₓ (G × G)] [DecidableEq (G × G)] [Fintypeₓ (G × G × G)]  [DecidableEq (G × G × G)] [fin_digraph_with_edge G]  (hx : ∀ (y x : G), ∃! z : G, edge_between y x z) : ∃ z : G,  ∀ (x : G) (hxz : ¬edge_between x z z), edge_between x z z "
    ],
    "answer": "theorem graph_unique_common_neighbour_implies_universal_adjacent_vertex {V : Type _} [Finite V] (G : SimpleGraph V) : (∀ v w : V, ∃! x : V, G.Adj v x ∧ G.Adj w x) → (∃ c : V, ∀ v : V, G.Adj c v) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "graph_unique_common_neighbour_implies_universal_adjacent_vertex",
      "main_prompt": "A finite graph in which every two vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.",
      "prompt": "Natural language version: \"Two vertices are adjacent iff there is an edge between them. The condition `v ≠ w` ensures they are different endpoints of the edge, which is necessary since when `v = w` the existential `∃ (e ∈ G.edge_set), v ∈ e ∧ w ∈ e` is satisfied by every edge incident to `v`.\" Translate the natural language version to a Lean mathlib version:\n theorem simple_graph.adj_iff_exists_edge{V : Type u} (G : simple_graph V) {v w : V} :\nG.adj v w ↔ v ≠ w ∧ ∃ (e : sym2 V) (H : e ∈ G.edge_set), v ∈ e ∧ w ∈ e := \n\nNatural language version: \"The handshaking lemma.  See also `simple_graph.sum_degrees_eq_twice_card_edges`.\" Translate the natural language version to a Lean mathlib version:\n theorem simple_graph.even_card_odd_degree_vertices{V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] :\neven (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card := \n\nNatural language version: \"There exists a vertex of maximal degree. Note the assumption of being nonempty is necessary, as the lemma implies there exists a vertex.\" Translate the natural language version to a Lean mathlib version:\n theorem simple_graph.exists_maximal_degree_vertex{V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [nonempty V] :\n∃ (v : V), G.max_degree = G.degree v := \n\nNatural language version: \"In a graph, if `k` is at least the degree of every vertex, then it is at least the maximum degree.\" Translate the natural language version to a Lean mathlib version:\n theorem simple_graph.max_degree_le_of_forall_degree_le{V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (k : ℕ) (h : ∀ (v : V), G.degree v ≤ k) :\nG.max_degree ≤ k := \n\nNatural language version: \"A finite graph in which every two vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5179886817932129,
          "doc_string": "Two vertices are adjacent iff there is an edge between them. The condition `v ≠ w` ensures they are different endpoints of the edge, which is necessary since when `v = w` the existential `∃ (e ∈ G.edge_set), v ∈ e ∧ w ∈ e` is satisfied by every edge incident to `v`.",
          "statement": "theorem simple_graph.adj_iff_exists_edge {V : Type u} (G : simple_graph V) {v w : V} : G.adj v w ↔ v ≠ w ∧ ∃ (e : sym2 V) (H : e ∈ G.edge_set), v ∈ e ∧ w ∈ e"
        },
        {
          "sim_score": 0.5029463171958923,
          "doc_string": "The handshaking lemma.  See also `simple_graph.sum_degrees_eq_twice_card_edges`.",
          "statement": "theorem simple_graph.even_card_odd_degree_vertices {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] : even (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card"
        },
        {
          "sim_score": 0.4985456168651581,
          "doc_string": "There exists a vertex of maximal degree. Note the assumption of being nonempty is necessary, as the lemma implies there exists a vertex.",
          "statement": "theorem simple_graph.exists_maximal_degree_vertex {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [nonempty V] : ∃ (v : V), G.max_degree = G.degree v"
        },
        {
          "sim_score": 0.48896029591560364,
          "doc_string": "In a graph, if `k` is at least the degree of every vertex, then it is at least the maximum degree.",
          "statement": "theorem simple_graph.max_degree_le_of_forall_degree_le {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (k : ℕ) (h : ∀ (v : V), G.degree v ≤ k) : G.max_degree ≤ k"
        }
      ],
      "codex_time": 10.822478272981243,
      "search_time": 1.4880530529771931,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem simple_graph.no_isolated_points_of_num_common_neighbours_one_imp_num_adj_eq_card_of_ne_one{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.adj] (H : ∀ (v w : V), (G.num_common_neighbours v w) = 1 → (G.num_adj v) = card (G.neighbours v)) (v w : V) (H : G.num_common_neighbours v w = 1) : False ",
      "theorem simple_graph.no_isolated_points_of_num_common_neighbours_one_imp_num_adj_eq_card_of_ne_one{V : Type u} (G : SimpleGraph V) [Fintypeₓ V] [DecidableRel G.adj] (H : ∀ (v w : V), (G.num_common_neighbours v w) = 1 → (G.num_adj v) = card (G.neighbours v)) (v w : V) (H : G.num_common_neighbours v w = 1) : False ",
      "theorem simple_graph.unique_common_neighbour_implies_n1_connectivity{V : Type u} (G : SimpleGraph V) [DecidableRel G.adj] [Fintype V] : (∀ (a b : V), G.card {v | v ≠ a ∧ v ≠ b ∧ G.adj a v ∧ G.adj b v} = 1) → ∃ (v : V), ∀ (x : G.vertex_set), x ≠ v → G.adj v x ",
      "theorem simple_graph.unique_common_neighbour_implies_n1_connectivity{V : Type u} (G : SimpleGraph V) [DecidableRel G.adj] [Fintypeₓ V] : (∀ (a b : V), G.card {v | v ≠ a ∧ v ≠ b ∧ G.adj a v ∧ G.adj b v} = 1) → ∃ (v : V), ∀ (x : G.vertex_set), x ≠ v → G.adj v x ",
      "theorem simple_graph.exists_universal_vertex_of_card_three_vertices{V : Type u} (G : SimpleGraph V) (H : G.is_finite ∧ G.num_vertices = 3) : -- Finite graph G has exactly 3 vertices ∃ (v : V), ∀ (w : V), w ≠ v → G.adj v w ",
      "theorem simple_graph.one_common_neighbour_implies_universal_vertex{V : Type u} (H : SimpleGraph V) [Fintype V] [DecidableRel H.adj] : (∀ (u v : V), u ≠ v → finset.card ({w | H.adj w u ∧ H.adj w v} ∩ {w | w ≠ u ∧ w ≠ v}) = 1) → ∃ (v : V), (∀ (w : V), H.adj v w) ",
      "theorem simple_graph.one_common_neighbour_implies_universal_vertex{V : Type u} (H : SimpleGraph V) [Fintypeₓ V] [DecidableRel H.adj] : (∀ (u v : V), u ≠ v → finset.card ({w | H.adj w u ∧ H.adj w v} ∩ {w | w ≠ u ∧ w ≠ v}) = 1) → ∃ (v : V), (∀ (w : V), H.adj v w) ",
      "theorem simple_graph.unique_common_neighbour_implies_unique_neighbour{V : Type u} [Fintype V] (G : SimpleGraph V) [Fintype G.edge_set] [DecidableRel G.adj] (h : ∀ (v : V), ∀ (w : V), G.card (common_neighbours v w) = 1) : ∃ (v : V), ∀ (w : V), G.adj v w ",
      "theorem simple_graph.unique_common_neighbour_implies_unique_neighbour{V : Type u} [Fintypeₓ V] (G : SimpleGraph V) [Fintypeₓ G.edge_set] [DecidableRel G.adj] (h : ∀ (v : V), ∀ (w : V), G.card (common_neighbours v w) = 1) : ∃ (v : V), ∀ (w : V), G.adj v w "
    ],
    "answer": "theorem graph_unique_common_neighbour_implies_universal_adjacent_vertex {V : Type _} [Finite V] (G : SimpleGraph V) : (∀ v w : V, ∃! x : V, G.Adj v x ∧ G.Adj w x) → (∃ c : V, ∀ v : V, G.Adj c v) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "graph_unique_common_neighbour_implies_universal_adjacent_vertex",
      "main_prompt": "A finite graph in which every two vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.",
      "prompt": "Natural language version: \"A finite graph in which every two vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 8.476489251013845,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem sec6_8_lemma_vvv { Γ : Finset Vertex } ( h1 : ∀ u v : Vertex , ∃ w : Vertex ,   is_adjacent Γ u w ∧ is_adjacent Γ v w ) : ∃ v : Vertex , ∀ u : Vertex , is_adjacent Γ u v ",
      "theorem common_neighbour_has_all_neighbours (L:bipartite_lattice' k n) :  ∃ x, x ∈ L.X ∧ (∀ y, y∈L.X → x -[L.B]→ y )     ",
      "theorem graph_theory_lemma_2 : ∀ ( G : Set G ) , ∀ ( x y z : G ) , Segment x y z → ( ∀ ( r : G ) , x ≠ r → ¬ Segment y z r ∧ ¬ Segment z x r ) → ( ∀ ( r : G ) , r ≠ x → r ≠ y → r ≠ z → x ≠ r ) ",
      "theorem graph_theory_lemma_2 : ∀ ( G : Setₓ G ) , ∀ ( x y z : G ) , Segment x y z → ( ∀ ( r : G ) , x ≠ r → ¬ Segment y z r ∧ ¬ Segment z x r ) → ( ∀ ( r : G ) , r ≠ x → r ≠ y → r ≠ z → x ≠ r ) ",
      "theorem graph_theorem' (g : Finset (Finset ℕ)) (two_common : ∀ {{u v : Finset ℕ}} (huv : u ∈ g) (hvu : v ∈ g), finset.card (u ∩ v) = 2) (nogaps : ∀ t : Finset ℕ, t ∈ g → ∀ r : Finset ℕ, r ∈ g → t ≠ r → t ∩ r ≠ ∅) :        ∃ (z : Finset ℕ) (hz : z ∈ g), ∀ t : Finset ℕ, t ∈",
      "theorem common_neighbor_stop (G) [Fintype G] [Fintype (s G)] [Fintype (t G)] [Fintype (s ⁻¹' G)] [Fintype (t ⁻¹' G)] (h_comm : ∀ a b, (#⟨s ⁻¹' a, t ⁻¹' b⟩ : G) = (#⟨s ⁻¹' b, t ⁻¹' a⟩ : G))     [∀ a:G, ∃! b, (#⟨a, b⟩ :",
      "theorem common_neighbor_stop (G) [Fintypeₓ G] [Fintypeₓ (s G)] [Fintypeₓ (t G)] [Fintypeₓ (s ⁻¹' G)] [Fintypeₓ (t ⁻¹' G)] (h_comm : ∀ a b, (#⟨s ⁻¹' a, t ⁻¹' b⟩ : G) = (#⟨s ⁻¹' b, t ⁻¹' a⟩ : G))     [∀ a:G, ∃! b, (#⟨a, b⟩ :"
    ],
    "answer": "theorem graph_unique_common_neighbour_implies_universal_adjacent_vertex {V : Type _} [Finite V] (G : SimpleGraph V) : (∀ v w : V, ∃! x : V, G.Adj v x ∧ G.Adj w x) → (∃ c : V, ∀ v : V, G.Adj c v) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "partition_odd_distincts",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"The number of partitions with odd parts is equal to the number of partitions with distinct parts.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The number of partitions with odd parts is equal to the number of partitions with distinct parts.",
      "codex_time": 9.680341992992908,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem partitions_with_odd_parts_equals_partitions_with_distinct_parts (n : ℕ) : card ({p : ℕ × ℕ | p.1 ≤ n ∧ p.1 % 2 = 1} ∩ finset.univ.prod Finset.univ) = card {p : ℕ × ℕ | p.1 ≤ n ∧ p.1 ≠ p.2} ",
      "theorem partitions_with_odd_parts_eq_distinct_parts (m : ℕ) :  ∑ (p : nat.partition m), nat.odd (nat.partition.length p) = ∑ (p : nat.partition m), p.distinct ",
      "theorem odd_partitions_eq_distinct_partitions : ∀ n : ℕ, |(partitions.filter Odd n).elems| =  |(partitions.filter disjoint_and_ne_zero n).elems| ",
      "theorem count_partitions_with_odd_parts_eq_count_partitions_with_distinct_parts (n : ℕ) :  card (distinct_partitions_of_n n) = card (odd_partitions_of_n n) ",
      "theorem partitions_with_odd_parts_and_parts_distinct_equiv :  #count {k : ℕ, m : ℕ, l : ℕ, (k * 2 * m + 1) | l} =  #count {k : ℕ, m : ℕ, l : ℕ, s : Finset ℕ, (k * 2 * m + 1) | l ∧ l ∈ s} "
    ],
    "answer": "theorem partition_odd_distincts : ∀ n : ℕ, Finset.card (Nat.Partition.odds n) = Finset.card (Nat.Partition.distincts n) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "partition_odd_distincts",
      "main_prompt": "The number of partitions with odd parts is equal to the number of partitions with distinct parts.",
      "prompt": "Natural language version: \"If we can partition a sum into subsets that cancel out, then the whole sum cancels.\" Translate the natural language version to a Lean mathlib version:\n theorem finset.sum_cancels_of_partition_cancels{β : Type u} {α : Type v} {s : finset α} {f : α → β} [add_comm_monoid β] (R : setoid α) [decidable_rel setoid.r] (h : ∀ (x : α), x ∈ s → (finset.filter (λ (y : α), y ≈ x) s).sum (λ (a : α), f a) = 0) :\ns.sum (λ (x : α), f x) = 0 := \n\nNatural language version: \" To show a property is true on the odd parts, it suffices to show it is true on the vectors, closed under addition, and under left-multiplication by a pair of vectors.\" Translate the natural language version to a Lean mathlib version:\n theorem clifford_algebra.odd_induction{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) {P : Π (x : clifford_algebra Q), x ∈ clifford_algebra.even_odd Q 1 → Prop} (hι : ∀ (v : M), P (⇑(clifford_algebra.ι Q) v) _) (hadd : ∀ {x y : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 1} {hy : y ∈ clifford_algebra.even_odd Q 1}, P x hx → P y hy → P (x + y) _) (hιι_mul : ∀ (m₁ m₂ : M) {x : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 1}, P x hx → P (⇑(clifford_algebra.ι Q) m₁ * ⇑(clifford_algebra.ι Q) m₂ * x) _) (x : clifford_algebra Q) (hx : x ∈ clifford_algebra.even_odd Q 1) :\nP x hx := \n\nNatural language version: \"A sum can be partitioned into a sum of sums, each equivalent under a setoid.\" Translate the natural language version to a Lean mathlib version:\n theorem finset.sum_partition{β : Type u} {α : Type v} {s : finset α} {f : α → β} [add_comm_monoid β] (R : setoid α) [decidable_rel setoid.r] :\ns.sum (λ (x : α), f x) = (finset.image quotient.mk s).sum (λ (xbar : quotient R), (finset.filter (λ (y : α), ⟦y⟧ = xbar) s).sum (λ (y : α), f y)) := \n\nNatural language version: \"Distinct elements of a set of sets partitioning α are disjoint.\" Translate the natural language version to a Lean mathlib version:\n theorem setoid.eqv_classes_disjoint{α : Type u_1} {c : set (set α)} (H : ∀ (a : α), ∃! (b : set α) (H : b ∈ c), a ∈ b) :\nc.pairwise_disjoint id := \n\nNatural language version: \"The number of partitions with odd parts is equal to the number of partitions with distinct parts.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.45678937435150146,
          "doc_string": "If we can partition a sum into subsets that cancel out, then the whole sum cancels.",
          "statement": "theorem finset.sum_cancels_of_partition_cancels {β : Type u} {α : Type v} {s : finset α} {f : α → β} [add_comm_monoid β] (R : setoid α) [decidable_rel setoid.r] (h : ∀ (x : α), x ∈ s → (finset.filter (λ (y : α), y ≈ x) s).sum (λ (a : α), f a) = 0) : s.sum (λ (x : α), f x) = 0"
        },
        {
          "sim_score": 0.44783246517181396,
          "doc_string": " To show a property is true on the odd parts, it suffices to show it is true on the vectors, closed under addition, and under left-multiplication by a pair of vectors.",
          "statement": "theorem clifford_algebra.odd_induction {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) {P : Π (x : clifford_algebra Q), x ∈ clifford_algebra.even_odd Q 1 → Prop} (hι : ∀ (v : M), P (⇑(clifford_algebra.ι Q) v) _) (hadd : ∀ {x y : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 1} {hy : y ∈ clifford_algebra.even_odd Q 1}, P x hx → P y hy → P (x + y) _) (hιι_mul : ∀ (m₁ m₂ : M) {x : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 1}, P x hx → P (⇑(clifford_algebra.ι Q) m₁ * ⇑(clifford_algebra.ι Q) m₂ * x) _) (x : clifford_algebra Q) (hx : x ∈ clifford_algebra.even_odd Q 1) : P x hx"
        },
        {
          "sim_score": 0.42162370681762695,
          "doc_string": "A sum can be partitioned into a sum of sums, each equivalent under a setoid.",
          "statement": "theorem finset.sum_partition {β : Type u} {α : Type v} {s : finset α} {f : α → β} [add_comm_monoid β] (R : setoid α) [decidable_rel setoid.r] : s.sum (λ (x : α), f x) = (finset.image quotient.mk s).sum (λ (xbar : quotient R), (finset.filter (λ (y : α), ⟦y⟧ = xbar) s).sum (λ (y : α), f y))"
        },
        {
          "sim_score": 0.4164368808269501,
          "doc_string": "Distinct elements of a set of sets partitioning α are disjoint.",
          "statement": "theorem setoid.eqv_classes_disjoint {α : Type u_1} {c : set (set α)} (H : ∀ (a : α), ∃! (b : set α) (H : b ∈ c), a ∈ b) : c.pairwise_disjoint id"
        }
      ],
      "codex_time": 11.550722971995128,
      "search_time": 1.4321352730039507,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem clifford_algebra.odd_partitions_iff_distinct_partitions{R : Type u_1} {Q : QuadraticForm R (CliffordAlgebra Q)} : clifford_algebra.odd_partitions Q = clifford_algebra.distinct_partitions Q ",
      "theorem partitions.count_distinct_odd_equiv_num_partitions (n : ℕ) : (n.count_distinct_odd).card = (partitions.count_partitions n).card ",
      "theorem gt_0_of_partitions_with_odd_parts_eq_partitions_with_distinct_parts {P : ℕ → ℕ} {Q : ℕ → ℕ} (h : P ∘ (partitions_with_odd_parts) = Q ∘ (partitions_with_distinct_parts)) : 0 < partitions_with_odd_parts n ",
      "theorem partitions.partition_alt_equiv_distinct {n : ℕ} : bijective (partitions.partition n).filter (partitions.distinct) ",
      "theorem natural.quotient.count_partitions_same_as_distinct{n : ℕ} : @countable.count (Fin n → ℕ) (λ (p1 p2 : Fin n → ℕ), ∃ (f : subtype.{u_1 u_1} (λ (i : Fin n), i.val < p2 i) → subtype.{u_2 u_2} (λ (i : Fin n), i.val < p1 i)), (quotient.formation (λ (i : Fin n), @nat.lt_trichotomy _ (i.val) (p1 i) (p2",
      "theorem natural.quotient.count_partitions_same_as_distinct{n : ℕ} : @countable.count (Fin n → ℕ) (λ (p1 p2 : Fin n → ℕ), ∃ (f : subtype.{u_1 u_1} (λ (i : Fin n), i.val < p2 i) → subtype.{u_2 u_2} (λ (i : Fin n), i.val < p1 i)), (quotient.formation (λ (i : Fin n), @nat.lt_trichotomyₓ _ (i.val) (p1 i) (p2",
      "theorem natural.quotient.count_partitions_same_as_distinct{n : ℕ} : @countable.count (Finₓ n → ℕ) (λ (p1 p2 : Finₓ n → ℕ), ∃ (f : subtype.{u_1 u_1} (λ (i : Finₓ n), i.val < p2 i) → subtype.{u_2 u_2} (λ (i : Finₓ n), i.val < p1 i)), (quotient.formation (λ (i : Finₓ n), @nat.lt_trichotomy _ (i.val) (p1 i) (p2",
      "theorem natural.quotient.count_partitions_same_as_distinct{n : ℕ} : @countable.count (Finₓ n → ℕ) (λ (p1 p2 : Finₓ n → ℕ), ∃ (f : subtype.{u_1 u_1} (λ (i : Finₓ n), i.val < p2 i) → subtype.{u_2 u_2} (λ (i : Finₓ n), i.val < p1 i)), (quotient.formation (λ (i : Finₓ n), @nat.lt_trichotomyₓ _ (i.val) (p1 i) (p2"
    ],
    "answer": "theorem partition_odd_distincts : ∀ n : ℕ, Finset.card (Nat.Partition.odds n) = Finset.card (Nat.Partition.distincts n) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "partition_odd_distincts",
      "main_prompt": "The number of partitions with odd parts is equal to the number of partitions with distinct parts.",
      "prompt": "Natural language version: \"The number of partitions with odd parts is equal to the number of partitions with distinct parts.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 7.544797426991863,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem nat.odd_partitions_distinct_part_partitions_equiv :    Π n : ℕ, card { p | p ∈ @partitions ℕ _ _ 1 n ∧ p.is_distinct } = card { p | p ∈ @partitions ℕ _ _ 1 n ∧ p.summand_is_odd }  /-   There isn't a mathlib typeclass for \"property holds for every element of a List\" for a List of arbitrary objects, so if you want to make it mean \"every element of the partition satisfies the   property\" you have to make it a function of partitions:  -/   ",
      "theorem Nat . sum_add_distrib { α : Type * } [ Zero α ] [ Add α ] ( f : ℕ → α ) : ( ∑ x in Finset . Ico 1 n , ( ∑ x in Finset . Ico 1 x , f x ) ) = ( ∑ i in Finset . Ico 1 n , ( ∑ j in Finset . Ico 1 i , f j ) ) ∧ ( ∑ x in Finset . Ico 1 n , ( ∑ x in Finset . Ico 1 x , f x ) ) = ( ∑ i in Finset . Ico 1 n , ( ∑ j in Finset",
      "theorem : ∀ n : Nat , # odd_par n = # distinct_par n .  } lorem universe u' variables {α : Type u} #print prefix α attribute [instance] theorem bar (a b : Prop) : b ∧ a ",
      "theorem test1 : (number_of_partitions_with_odd_parts : ℕ) = (number_of_partitions_with_distinct_parts : ℕ) ",
      "theorem foo (n : ℕ) : #((Set.Range (n+1)).filter Odd) = #((Set.Range (n+1)).filter (λ m, set.card (partition m) = m)) ",
      "theorem foo (n : ℕ) : #((Setₓ.Range (n+1)).filter Odd) = #((Setₓ.Range (n+1)).filter (λ m, set.card (partition m) = m)) "
    ],
    "answer": "theorem partition_odd_distincts : ∀ n : ℕ, Finset.card (Nat.Partition.odds n) = Finset.card (Nat.Partition.distincts n) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "zorn",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every non-empty poset in which every chain has an upper bound contains a maximal element.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every non-empty poset in which every chain has an upper bound contains a maximal element.",
      "codex_time": 5.770648528006859,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem poset_with_maximal_element (α : Type*) [PartialOrder α] (h : ∀ c : Set α, Nonempty c → (∃ x, IsGlb x c)) :  ∃ m, maximal m ",
      "theorem poset_with_maximal_element (α : Type*) [PartialOrderₓₓ α] (h : ∀ c : Set α, Nonempty c → (∃ x, IsGlb x c)) :  ∃ m, maximal m ",
      "theorem poset_with_maximal_element (α : Type*) [PartialOrder α] (h : ∀ c : Setₓ α, Nonempty c → (∃ x, IsGlb x c)) :  ∃ m, maximal m ",
      "theorem poset_with_maximal_element (α : Type*) [PartialOrderₓₓ α] (h : ∀ c : Setₓ α, Nonempty c → (∃ x, IsGlb x c)) :  ∃ m, maximal m ",
      "theorem poset_with_maximal_element (α : Type*) [PartialOrderₓ α] (h : ∀ c : Set α, Nonempty c → (∃ x, IsGlb x c)) :  ∃ m, maximal m ",
      "theorem poset_with_maximal_element (α : Type*) [PartialOrderₓ α] (h : ∀ c : Setₓ α, Nonempty c → (∃ x, IsGlb x c)) :  ∃ m, maximal m ",
      "theorem nonempty_chain_upper_bound_has_max (X : Type*) [PartialOrder X]  (hX : Nonempty X) (h : ∀ c : Set X, Nonempty c → IsChain c → ∃ b, ∀ x, x ∈ c → x ≤ b) :  ∃ m : X, ∀ x, x ≤ m ",
      "theorem nonempty_chain_upper_bound_has_max (X : Type*) [PartialOrderₓₓ X]  (hX : Nonempty X) (h : ∀ c : Set X, Nonempty c → IsChain c → ∃ b, ∀ x, x ∈ c → x ≤ b) :  ∃ m : X, ∀ x, x ≤ m ",
      "theorem nonempty_chain_upper_bound_has_max (X : Type*) [PartialOrder X]  (hX : Nonempty X) (h : ∀ c : Setₓ X, Nonempty c → IsChain c → ∃ b, ∀ x, x ∈ c → x ≤ b) :  ∃ m : X, ∀ x, x ≤ m ",
      "theorem nonempty_chain_upper_bound_has_max (X : Type*) [PartialOrderₓₓ X]  (hX : Nonempty X) (h : ∀ c : Setₓ X, Nonempty c → IsChain c → ∃ b, ∀ x, x ∈ c → x ≤ b) :  ∃ m : X, ∀ x, x ≤ m ",
      "theorem nonempty_chain_upper_bound_has_max (X : Type*) [PartialOrderₓ X]  (hX : Nonempty X) (h : ∀ c : Set X, Nonempty c → IsChain c → ∃ b, ∀ x, x ∈ c → x ≤ b) :  ∃ m : X, ∀ x, x ≤ m ",
      "theorem nonempty_chain_upper_bound_has_max (X : Type*) [PartialOrderₓ X]  (hX : Nonempty X) (h : ∀ c : Setₓ X, Nonempty c → IsChain c → ∃ b, ∀ x, x ∈ c → x ≤ b) :  ∃ m : X, ∀ x, x ≤ m ",
      "theorem of_zorn (X : Type*) [LinearOrder X] :   (∀ C : Set X, (∀ x y : X, x ∈ C → y ∈ C → x ≤ y ∨ y ≤ x) →     ∃ y, IsMax C y) → ∃ x, IsMax X x ",
      "theorem of_zorn (X : Type*) [LinearOrderₓₓ X] :   (∀ C : Set X, (∀ x y : X, x ∈ C → y ∈ C → x ≤ y ∨ y ≤ x) →     ∃ y, IsMax C y) → ∃ x, IsMax X x ",
      "theorem of_zorn (X : Type*) [LinearOrder X] :   (∀ C : Setₓ X, (∀ x y : X, x ∈ C → y ∈ C → x ≤ y ∨ y ≤ x) →     ∃ y, IsMax C y) → ∃ x, IsMax X x ",
      "theorem of_zorn (X : Type*) [LinearOrderₓₓ X] :   (∀ C : Setₓ X, (∀ x y : X, x ∈ C → y ∈ C → x ≤ y ∨ y ≤ x) →     ∃ y, IsMax C y) → ∃ x, IsMax X x ",
      "theorem of_zorn (X : Type*) [LinearOrderₓ X] :   (∀ C : Set X, (∀ x y : X, x ∈ C → y ∈ C → x ≤ y ∨ y ≤ x) →     ∃ y, IsMax C y) → ∃ x, IsMax X x ",
      "theorem of_zorn (X : Type*) [LinearOrderₓ X] :   (∀ C : Setₓ X, (∀ x y : X, x ∈ C → y ∈ C → x ≤ y ∨ y ≤ x) →     ∃ y, IsMax C y) → ∃ x, IsMax X x ",
      "theorem poset_maximal_element (α : Type*) (r : α → α → Prop) [hs : IsWellOrder α r]    [Inhabited α] (h_chain : ∀ s : Set α, ∃ b, (∀ x ∈ s, x ≤ b)) :    ∃ x : α, x ⊥ ",
      "theorem poset_maximal_element (α : Type*) (r : α → α → Prop) [hs : IsWellOrder α r]    [Inhabited α] (h_chain : ∀ s : Setₓ α, ∃ b, (∀ x ∈ s, x ≤ b)) :    ∃ x : α, x ⊥ ",
      "theorem every_nonempty_poset_with_chains_has_maximal_elements (P : Type*) [PartialOrder P] :  ∀ p : P, ¬ p ≈ ⊥ → Nonempty (Filter P) ∧ ∀ S : Set P, IsChain S → ∃ (c : P), is_maximal c S ",
      "theorem every_nonempty_poset_with_chains_has_maximal_elements (P : Type*) [PartialOrderₓₓ P] :  ∀ p : P, ¬ p ≈ ⊥ → Nonempty (Filter P) ∧ ∀ S : Set P, IsChain S → ∃ (c : P), is_maximal c S ",
      "theorem every_nonempty_poset_with_chains_has_maximal_elements (P : Type*) [PartialOrder P] :  ∀ p : P, ¬ p ≈ ⊥ → Nonempty (Filter P) ∧ ∀ S : Setₓ P, IsChain S → ∃ (c : P), is_maximal c S ",
      "theorem every_nonempty_poset_with_chains_has_maximal_elements (P : Type*) [PartialOrderₓₓ P] :  ∀ p : P, ¬ p ≈ ⊥ → Nonempty (Filter P) ∧ ∀ S : Setₓ P, IsChain S → ∃ (c : P), is_maximal c S ",
      "theorem every_nonempty_poset_with_chains_has_maximal_elements (P : Type*) [PartialOrderₓ P] :  ∀ p : P, ¬ p ≈ ⊥ → Nonempty (Filter P) ∧ ∀ S : Set P, IsChain S → ∃ (c : P), is_maximal c S ",
      "theorem every_nonempty_poset_with_chains_has_maximal_elements (P : Type*) [PartialOrderₓ P] :  ∀ p : P, ¬ p ≈ ⊥ → Nonempty (Filter P) ∧ ∀ S : Setₓ P, IsChain S → ∃ (c : P), is_maximal c S "
    ],
    "answer": "theorem zorn {α : Type _} [PartialOrder α] [Nonempty α] : (∀ c : Set α, IsChain LE.le c → (∃ b : α, ∀ a ∈ c, a ≤ b)) → (∃ m : α, ∀ a : α, m ≤ a → a = m) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "zorn",
      "main_prompt": "Every non-empty poset in which every chain has an upper bound contains a maximal element.",
      "prompt": "Natural language version: \" **Zorn's lemma**  If every chain has an upper bound, then there exists a maximal element.\" Translate the natural language version to a Lean mathlib version:\n theorem exists_maximal_of_chains_bounded{α : Type u_1} {r : α → α → Prop} (h : ∀ (c : set α), is_chain r c → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) (trans : ∀ {a b c : α}, r a b → r b c → r a c) :\n∃ (m : α), ∀ (a : α), r m a → r a m := \n\nNatural language version: \" A variant of Zorn's lemma. If every nonempty chain of a nonempty type has an upper bound, then there is a maximal element.\" Translate the natural language version to a Lean mathlib version:\n theorem exists_maximal_of_nonempty_chains_bounded{α : Type u_1} {r : α → α → Prop} [nonempty α] (h : ∀ (c : set α), is_chain r c → c.nonempty → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) (trans : ∀ {a b c : α}, r a b → r b c → r a c) :\n∃ (m : α), ∀ (a : α), r m a → r a m := \n\nNatural language version: \"Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle.\" Translate the natural language version to a Lean mathlib version:\n theorem is_chain.exists_max_chain{α : Type u_1} {r : α → α → Prop} {c : set α} (hc : is_chain r c) :\n∃ (M : set α), is_max_chain r M ∧ c ⊆ M := \n\nNatural language version: \" The Sup of a non-empty set is its least upper bound for a conditionally complete lattice with a top.\" Translate the natural language version to a Lean mathlib version:\n theorem with_top.is_lub_Sup'{β : Type u_1} [conditionally_complete_lattice β] {s : set (with_top β)} (hs : s.nonempty) :\nis_lub s (has_Sup.Sup s) := \n\nNatural language version: \"Every non-empty poset in which every chain has an upper bound contains a maximal element.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.8077962398529053,
          "doc_string": " **Zorn's lemma**  If every chain has an upper bound, then there exists a maximal element.",
          "statement": "theorem exists_maximal_of_chains_bounded {α : Type u_1} {r : α → α → Prop} (h : ∀ (c : set α), is_chain r c → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) (trans : ∀ {a b c : α}, r a b → r b c → r a c) : ∃ (m : α), ∀ (a : α), r m a → r a m"
        },
        {
          "sim_score": 0.782833456993103,
          "doc_string": " A variant of Zorn's lemma. If every nonempty chain of a nonempty type has an upper bound, then there is a maximal element.",
          "statement": "theorem exists_maximal_of_nonempty_chains_bounded {α : Type u_1} {r : α → α → Prop} [nonempty α] (h : ∀ (c : set α), is_chain r c → c.nonempty → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) (trans : ∀ {a b c : α}, r a b → r b c → r a c) : ∃ (m : α), ∀ (a : α), r m a → r a m"
        },
        {
          "sim_score": 0.6981233954429626,
          "doc_string": "Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle.",
          "statement": "theorem is_chain.exists_max_chain {α : Type u_1} {r : α → α → Prop} {c : set α} (hc : is_chain r c) : ∃ (M : set α), is_max_chain r M ∧ c ⊆ M"
        },
        {
          "sim_score": 0.6111599206924438,
          "doc_string": " The Sup of a non-empty set is its least upper bound for a conditionally complete lattice with a top.",
          "statement": "theorem with_top.is_lub_Sup' {β : Type u_1} [conditionally_complete_lattice β] {s : set (with_top β)} (hs : s.nonempty) : is_lub s (has_Sup.Sup s)"
        }
      ],
      "codex_time": 9.578672475996427,
      "search_time": 1.4391371550154872,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem exists_max_of_chains_bounded{α : Type u_1} {r : α → α → Prop} [IsRefl α r] (h : ∀ (c : Set α), IsChain r c → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) : ∃ (m : α), ∀ (a : α), r m a → r a m ",
      "theorem exists_max_of_chains_bounded{α : Type u_1} {r : α → α → Prop} [IsRefl α r] (h : ∀ (c : Setₓ α), IsChain r c → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) : ∃ (m : α), ∀ (a : α), r m a → r a m ",
      "theorem exists_maximal_of_chains_bounded_poset{α : Type*} [poset α] [Nonempty α] (h : ∀ (c : Set α), IsChain (<) c → c.nonempty → (∃ (ub : α), ∀ (a : α), a ∈ c → a ≤ ub)) : ∃ (m : α), ∀ (a : α), m ≥ a → m ≤ a ",
      "theorem exists_maximal_of_chains_bounded_poset{α : Type*} [poset α] [Nonempty α] (h : ∀ (c : Setₓ α), IsChain (<) c → c.nonempty → (∃ (ub : α), ∀ (a : α), a ∈ c → a ≤ ub)) : ∃ (m : α), ∀ (a : α), m ≥ a → m ≤ a ",
      "theorem exists_maximal_of_chains_bounded{α : Type u_1} {r : α → α → Prop} (h : ∀ (c : Set α), IsChain r c → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) (Trans : ∀ {a b c : α}, r a b → r b c → r a c) : ∃ (m : α), ∀ (a : α), r m a → r a m ",
      "theorem exists_maximal_of_chains_bounded{α : Type u_1} {r : α → α → Prop} (h : ∀ (c : Setₓ α), IsChain r c → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) (Trans : ∀ {a b c : α}, r a b → r b c → r a c) : ∃ (m : α), ∀ (a : α), r m a → r a m ",
      "theorem upper_bounded_implies_exists_maximal{α : Type u_1} {r : α → α → Prop} (h : ∀ (c : Set α), IsChain r c → ∃ (ub : α), ∀ (a : α), a ∈ c → r ub a) (Trans : ∀ {a b c : α}, r a b → r b c → r a c) [Nonempty α] : ∃ (m : α), ∀ (a : α), r a m → r m a ",
      "theorem upper_bounded_implies_exists_maximal{α : Type u_1} {r : α → α → Prop} (h : ∀ (c : Setₓ α), IsChain r c → ∃ (ub : α), ∀ (a : α), a ∈ c → r ub a) (Trans : ∀ {a b c : α}, r a b → r b c → r a c) [Nonempty α] : ∃ (m : α), ∀ (a : α), r a m → r m a ",
      "theorem exists_maximal_of_chains_bounded_nonempty{α : Type u_1} {r : α → α → Prop} [PartialOrder α] (h : ∀ (c : Set α), IsChain r c → c.nonempty → (∃ (ub : α), is_ub c ub)) : ∃ (m : α), is_maximal r m ",
      "theorem exists_maximal_of_chains_bounded_nonempty{α : Type u_1} {r : α → α → Prop} [PartialOrderₓₓ α] (h : ∀ (c : Set α), IsChain r c → c.nonempty → (∃ (ub : α), is_ub c ub)) : ∃ (m : α), is_maximal r m ",
      "theorem exists_maximal_of_chains_bounded_nonempty{α : Type u_1} {r : α → α → Prop} [PartialOrder α] (h : ∀ (c : Setₓ α), IsChain r c → c.nonempty → (∃ (ub : α), is_ub c ub)) : ∃ (m : α), is_maximal r m ",
      "theorem exists_maximal_of_chains_bounded_nonempty{α : Type u_1} {r : α → α → Prop} [PartialOrderₓₓ α] (h : ∀ (c : Setₓ α), IsChain r c → c.nonempty → (∃ (ub : α), is_ub c ub)) : ∃ (m : α), is_maximal r m ",
      "theorem exists_maximal_of_chains_bounded_nonempty{α : Type u_1} {r : α → α → Prop} [PartialOrderₓ α] (h : ∀ (c : Set α), IsChain r c → c.nonempty → (∃ (ub : α), is_ub c ub)) : ∃ (m : α), is_maximal r m ",
      "theorem exists_maximal_of_chains_bounded_nonempty{α : Type u_1} {r : α → α → Prop} [PartialOrderₓ α] (h : ∀ (c : Setₓ α), IsChain r c → c.nonempty → (∃ (ub : α), is_ub c ub)) : ∃ (m : α), is_maximal r m "
    ],
    "answer": "theorem zorn {α : Type _} [PartialOrder α] [Nonempty α] : (∀ c : Set α, IsChain LE.le c → (∃ b : α, ∀ a ∈ c, a ≤ b)) → (∃ m : α, ∀ a : α, m ≤ a → a = m) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "zorn",
      "main_prompt": "Every non-empty poset in which every chain has an upper bound contains a maximal element.",
      "prompt": "Natural language version: \"Every non-empty poset in which every chain has an upper bound contains a maximal element.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 9.797200271015754,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem exists_max : ∀ {X : Type} (R : X → X → Prop) [DecidableRel R] [IsPartialOrder R],   ∀ (xs : Set X) (hxs : xs ≠ ∅),   (∀ s : Set X, s ≠ ∅ → (∀ x ∈ s, ∀ y ∈ s, R x y) → ∃ z ∈ s, ∀ x ∈ s, R x z) →   (∃ x, x ∈ xs ∧ ∀ y, y ∈ xs → R y x)  ",
      "theorem exists_max : ∀ {X : Type} (R : X → X → Prop) [DecidableRel R] [IsPartialOrder R],   ∀ (xs : Setₓ X) (hxs : xs ≠ ∅),   (∀ s : Setₓ X, s ≠ ∅ → (∀ x ∈ s, ∀ y ∈ s, R x y) → ∃ z ∈ s, ∀ x ∈ s, R x z) →   (∃ x, x ∈ xs ∧ ∀ y, y ∈ xs → R y x)  ",
      "theorem Zorn (X : Type u) [PartialOrder X] (H : ∀ C, chain C → ∃ x, is_maximal X C x) : ∃ x, is_ub X UNIV x ",
      "theorem Zorn (X : Type u) [PartialOrderₓₓ X] (H : ∀ C, chain C → ∃ x, is_maximal X C x) : ∃ x, is_ub X UNIV x ",
      "theorem Zorn (X : Type u) [PartialOrderₓ X] (H : ∀ C, chain C → ∃ x, is_maximal X C x) : ∃ x, is_ub X UNIV x ",
      "theorem exists_maximal : ∀ { α : Type } [ PartialOrder α ] { s : Set α } , s.nonempty → ∀ { x : α } , x ∈ s → ∃ ( h : is_maximal x s ) , True  Ok, now what are maximal elements? \"For all y in S, y ≤ x ∧ ¬(y < x).\" /- before we can Even think about how to state this, we need to know-/ -- what it means to hold for all y in s! def is_maximal ( α : Type ) [ PartialOrder α ] ( x : α ) ( s : Set α ) : Prop ",
      "theorem exists_maximal : ∀ { α : Type } [ PartialOrderₓₓ α ] { s : Set α } , s.nonempty → ∀ { x : α } , x ∈ s → ∃ ( h : is_maximal x s ) , True  Ok, now what are maximal elements? \"For all y in S, y ≤ x ∧ ¬(y < x).\" /- before we can Even think about how to state this, we need to know-/ -- what it means to hold for all y in s! def is_maximal ( α : Type ) [ PartialOrderₓₓ α ] ( x : α ) ( s : Set α ) : Prop ",
      "theorem exists_maximal : ∀ { α : Type } [ PartialOrder α ] { s : Setₓ α } , s.nonempty → ∀ { x : α } , x ∈ s → ∃ ( h : is_maximal x s ) , True  Ok, now what are maximal elements? \"For all y in S, y ≤ x ∧ ¬(y < x).\" /- before we can Even think about how to state this, we need to know-/ -- what it means to hold for all y in s! def is_maximal ( α : Type ) [ PartialOrder α ] ( x : α ) ( s : Setₓ α ) : Prop ",
      "theorem exists_maximal : ∀ { α : Type } [ PartialOrderₓₓ α ] { s : Setₓ α } , s.nonempty → ∀ { x : α } , x ∈ s → ∃ ( h : is_maximal x s ) , True  Ok, now what are maximal elements? \"For all y in S, y ≤ x ∧ ¬(y < x).\" /- before we can Even think about how to state this, we need to know-/ -- what it means to hold for all y in s! def is_maximal ( α : Type ) [ PartialOrderₓₓ α ] ( x : α ) ( s : Setₓ α ) : Prop ",
      "theorem exists_maximal : ∀ { α : Type } [ PartialOrderₓ α ] { s : Set α } , s.nonempty → ∀ { x : α } , x ∈ s → ∃ ( h : is_maximal x s ) , True  Ok, now what are maximal elements? \"For all y in S, y ≤ x ∧ ¬(y < x).\" /- before we can Even think about how to state this, we need to know-/ -- what it means to hold for all y in s! def is_maximal ( α : Type ) [ PartialOrderₓ α ] ( x : α ) ( s : Set α ) : Prop ",
      "theorem exists_maximal : ∀ { α : Type } [ PartialOrderₓ α ] { s : Setₓ α } , s.nonempty → ∀ { x : α } , x ∈ s → ∃ ( h : is_maximal x s ) , True  Ok, now what are maximal elements? \"For all y in S, y ≤ x ∧ ¬(y < x).\" /- before we can Even think about how to state this, we need to know-/ -- what it means to hold for all y in s! def is_maximal ( α : Type ) [ PartialOrderₓ α ] ( x : α ) ( s : Setₓ α ) : Prop ",
      "theorem kruskal_katona : Nonempty (Set ι) → (∀ c : chain α, Nonempty (↑c ⊔ᵤ ({0} : Set ι))) → ∃ (s : Set ι),   is_maximal s ",
      "theorem kruskal_katona : Nonempty (Setₓ ι) → (∀ c : chain α, Nonempty (↑c ⊔ᵤ ({0} : Setₓ ι))) → ∃ (s : Setₓ ι),   is_maximal s ",
      "theorem no_maximal_element_of_poset_in_setoid_implies_not_empty_has_no_upper_bounds (X : \\ Type*) [poset X] (H1 :  ∀ (A : Setoid X) [DecidablePred A], ¬ maximal A) (A : Setoid X) (x : A) (H2 : x ∈ A) : \\ ∀ {y : X}, A x y → False | y H3 ",
      "theorem no_maximal_element_of_poset_in_setoid_implies_not_empty_has_no_upper_bounds (X : \\ Type*) [poset X] (H1 :  ∀ (A : Setoidₓ X) [DecidablePred A], ¬ maximal A) (A : Setoidₓ X) (x : A) (H2 : x ∈ A) : \\ ∀ {y : X}, A x y → False | y H3 "
    ],
    "answer": "theorem zorn {α : Type _} [PartialOrder α] [Nonempty α] : (∀ c : Set α, IsChain LE.le c → (∃ b : α, ∀ a ∈ c, a ≤ b)) → (∃ m : α, ∀ a : α, m ≤ a → a = m) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "aut_group_cyclic_implies_abelian",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"A group whose automorphism group is cyclic is Abelian.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A group whose automorphism group is cyclic is Abelian.",
      "codex_time": 10.554913405998377,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem group_with_cyclic_automorphism_group_is_abelian (G : Type*) [Group G]  (H : ∀ (f : G → G), Function.Surjective f → f 1 = 1 → IsGroupHom f → IsGroupHom f.inv → ∃ n : ℕ, f = λ x : G, x^n) :  abelian_group G ",
      "theorem group_with_cyclic_automorphism_group_is_abelian (G : Type*) [Groupₓₓ G]  (H : ∀ (f : G → G), Function.Surjective f → f 1 = 1 → IsGroupHom f → IsGroupHom f.inv → ∃ n : ℕ, f = λ x : G, x^n) :  abelian_group G ",
      "theorem group_with_cyclic_automorphism_group_is_abelian (G : Type*) [Groupₓ G]  (H : ∀ (f : G → G), Function.Surjective f → f 1 = 1 → IsGroupHom f → IsGroupHom f.inv → ∃ n : ℕ, f = λ x : G, x^n) :  abelian_group G ",
      "theorem cyclic_aut_group_implies_abelian (G : Type*) [Group G] (hG : ∃ x : G, x ≠ 1 ∧  ∀ g : G, x * g = g → g = 1) : abelian G ",
      "theorem cyclic_aut_group_implies_abelian (G : Type*) [Groupₓₓ G] (hG : ∃ x : G, x ≠ 1 ∧  ∀ g : G, x * g = g → g = 1) : abelian G ",
      "theorem cyclic_aut_group_implies_abelian (G : Type*) [Groupₓ G] (hG : ∃ x : G, x ≠ 1 ∧  ∀ g : G, x * g = g → g = 1) : abelian G ",
      "theorem abelian_automorphism_group_is_abelian (G : Type*) [Group G]  (H : ∀ f : G → G, IsGroupHom f → (∃ n : ℤ, f = nat_pow n) → automorphism f):  Abelian_group G ",
      "theorem abelian_automorphism_group_is_abelian (G : Type*) [Groupₓₓ G]  (H : ∀ f : G → G, IsGroupHom f → (∃ n : ℤ, f = nat_pow n) → automorphism f):  Abelian_group G ",
      "theorem abelian_automorphism_group_is_abelian (G : Type*) [Groupₓ G]  (H : ∀ f : G → G, IsGroupHom f → (∃ n : ℤ, f = nat_pow n) → automorphism f):  Abelian_group G ",
      "theorem group_automorphism_group_is_cyclic_is_abelian (G : Type*) [Group G]  (H : Type*) [Group H] (f : G → H) (f_inj : Function.Injective f)  (f_surj : Function.Surjective f) (h_g_abelian : ∀ x y : G, x * y = y * x)  (h_h_cyclic : ∀ x y : H, ∃ z : H, z ^ 2 = 1 ∧ x = z * y ∧ y = z * x) :  ∀ x y : G, f x * f y =",
      "theorem group_automorphism_group_is_cyclic_is_abelian (G : Type*) [Groupₓₓ G]  (H : Type*) [Groupₓₓ H] (f : G → H) (f_inj : Function.Injective f)  (f_surj : Function.Surjective f) (h_g_abelian : ∀ x y : G, x * y = y * x)  (h_h_cyclic : ∀ x y : H, ∃ z : H, z ^ 2 = 1 ∧ x = z * y ∧ y = z * x) :  ∀ x y : G, f x * f y =",
      "theorem group_automorphism_group_is_cyclic_is_abelian (G : Type*) [Groupₓ G]  (H : Type*) [Groupₓ H] (f : G → H) (f_inj : Function.Injective f)  (f_surj : Function.Surjective f) (h_g_abelian : ∀ x y : G, x * y = y * x)  (h_h_cyclic : ∀ x y : H, ∃ z : H, z ^ 2 = 1 ∧ x = z * y ∧ y = z * x) :  ∀ x y : G, f x * f y =",
      "theorem abelian_if_automorphism_group_cyclic (G : Type*) [Group G] (hG : ∃ g : G, IsCyclic G g) : abelian_group G ",
      "theorem abelian_if_automorphism_group_cyclic (G : Type*) [Groupₓₓ G] (hG : ∃ g : G, IsCyclic G g) : abelian_group G ",
      "theorem abelian_if_automorphism_group_cyclic (G : Type*) [Groupₓ G] (hG : ∃ g : G, IsCyclic G g) : abelian_group G "
    ],
    "answer": "theorem aut_group_cyclic_implies_abelian {G : Type _} [Groupₓ G] : CategoryTheory.Aut G → CommGroup G "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "aut_group_cyclic_implies_abelian",
      "main_prompt": "A group whose automorphism group is cyclic is Abelian.",
      "prompt": "Natural language version: \"A finite group of prime order is cyclic.\" Translate the natural language version to a Lean mathlib version:\n theorem is_cyclic_of_prime_card{α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) :\nis_cyclic α := \n\nNatural language version: \"Every subgroup of `ℤ` is cyclic.\" Translate the natural language version to a Lean mathlib version:\n theorem int.subgroup_cyclic(H : add_subgroup ℤ) :\n∃ (a : ℤ), H = add_subgroup.closure {a} := \n\nNatural language version: \"A finite subgroup of the unit group of an integral domain is cyclic.\" Translate the natural language version to a Lean mathlib version:\n theorem is_cyclic_of_subgroup_is_domain{R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G →* R) (hf : function.injective ⇑f) :\nis_cyclic G := \n\nNatural language version: \"The product of group homomorphisms is a group homomorphism if the target is commutative.\" Translate the natural language version to a Lean mathlib version:\n theorem is_group_hom.mul{α : Type u_1} {β : Type u_2} [group α] [comm_group β] {f g : α → β} (hf : is_group_hom f) (hg : is_group_hom g) :\nis_group_hom (λ (a : α), f a * g a) := \n\nNatural language version: \"A group whose automorphism group is cyclic is Abelian.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6319984793663025,
          "doc_string": "A finite group of prime order is cyclic.",
          "statement": "theorem is_cyclic_of_prime_card {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_cyclic α"
        },
        {
          "sim_score": 0.6267713308334351,
          "doc_string": "Every subgroup of `ℤ` is cyclic.",
          "statement": "theorem int.subgroup_cyclic (H : add_subgroup ℤ) : ∃ (a : ℤ), H = add_subgroup.closure {a}"
        },
        {
          "sim_score": 0.5008938312530518,
          "doc_string": "A finite subgroup of the unit group of an integral domain is cyclic.",
          "statement": "theorem is_cyclic_of_subgroup_is_domain {R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G →* R) (hf : function.injective ⇑f) : is_cyclic G"
        },
        {
          "sim_score": 0.4840320944786072,
          "doc_string": "The product of group homomorphisms is a group homomorphism if the target is commutative.",
          "statement": "theorem is_group_hom.mul {α : Type u_1} {β : Type u_2} [group α] [comm_group β] {f g : α → β} (hf : is_group_hom f) (hg : is_group_hom g) : is_group_hom (λ (a : α), f a * g a)"
        }
      ],
      "codex_time": 7.294612680008868,
      "search_time": 1.4686311910045333,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem abelian_of_aut_cyclic{α : Type u_1} [Group α] [Fintype (aut α)] {G : Type u_2} [Group G] [Fintype G] (h : IsCyclic G) : ∀ (f : α →* G), IsGroupHom f → Function.Injective ⇑f → ((∃ (a : α), f a = 1) → CommGroup α) ",
      "theorem abelian_of_aut_cyclic{α : Type u_1} [Group α] [Fintype (aut α)] {G : Type u_2} [Group G] [Fintype G] (h : IsCyclic G) : ∀ (f : α →* G), IsGroupHom f → Function.Injective ⇑f → ((∃ (a : α), f a = 1) → CommGroupₓₓ α) ",
      "theorem abelian_of_aut_cyclic{α : Type u_1} [Groupₓₓ α] [Fintype (aut α)] {G : Type u_2} [Groupₓₓ G] [Fintype G] (h : IsCyclic G) : ∀ (f : α →* G), IsGroupHom f → Function.Injective ⇑f → ((∃ (a : α), f a = 1) → CommGroup α) ",
      "theorem abelian_of_aut_cyclic{α : Type u_1} [Groupₓₓ α] [Fintype (aut α)] {G : Type u_2} [Groupₓₓ G] [Fintype G] (h : IsCyclic G) : ∀ (f : α →* G), IsGroupHom f → Function.Injective ⇑f → ((∃ (a : α), f a = 1) → CommGroupₓₓ α) ",
      "theorem abelian_of_aut_cyclic{α : Type u_1} [Groupₓ α] [Fintype (aut α)] {G : Type u_2} [Groupₓ G] [Fintype G] (h : IsCyclic G) : ∀ (f : α →* G), IsGroupHom f → Function.Injective ⇑f → ((∃ (a : α), f a = 1) → CommGroup α) ",
      "theorem abelian_of_aut_cyclic{α : Type u_1} [Groupₓ α] [Fintype (aut α)] {G : Type u_2} [Groupₓ G] [Fintype G] (h : IsCyclic G) : ∀ (f : α →* G), IsGroupHom f → Function.Injective ⇑f → ((∃ (a : α), f a = 1) → CommGroupₓₓ α) ",
      "theorem abelian_of_aut_cyclic{α : Type u_1} [Group α] [Fintype (aut α)] {G : Type u_2} [Group G] [Fintype G] (h : IsCyclic G) : ∀ (f : α →* G), IsGroupHom f → Function.Injective ⇑f → ((∃ (a : α), f a = 1) → CommGroupₓ α) ",
      "theorem abelian_of_aut_cyclic{α : Type u_1} [Groupₓₓ α] [Fintype (aut α)] {G : Type u_2} [Groupₓₓ G] [Fintype G] (h : IsCyclic G) : ∀ (f : α →* G), IsGroupHom f → Function.Injective ⇑f → ((∃ (a : α), f a = 1) → CommGroupₓ α) ",
      "theorem abelian_of_aut_cyclic{α : Type u_1} [Groupₓ α] [Fintype (aut α)] {G : Type u_2} [Groupₓ G] [Fintype G] (h : IsCyclic G) : ∀ (f : α →* G), IsGroupHom f → Function.Injective ⇑f → ((∃ (a : α), f a = 1) → CommGroupₓ α) ",
      "theorem abelian_of_aut_cyclic{α : Type u_1} [Group α] [Fintypeₓ (aut α)] {G : Type u_2} [Group G] [Fintypeₓ G] (h : IsCyclic G) : ∀ (f : α →* G), IsGroupHom f → Function.Injective ⇑f → ((∃ (a : α), f a = 1) → CommGroup α) ",
      "theorem abelian_of_aut_cyclic{α : Type u_1} [Group α] [Fintypeₓ (aut α)] {G : Type u_2} [Group G] [Fintypeₓ G] (h : IsCyclic G) : ∀ (f : α →* G), IsGroupHom f → Function.Injective ⇑f → ((∃ (a : α), f a = 1) → CommGroupₓₓ α) ",
      "theorem abelian_of_aut_cyclic{α : Type u_1} [Groupₓₓ α] [Fintypeₓ (aut α)] {G : Type u_2} [Groupₓₓ G] [Fintypeₓ G] (h : IsCyclic G) : ∀ (f : α →* G), IsGroupHom f → Function.Injective ⇑f → ((∃ (a : α), f a = 1) → CommGroup α) ",
      "theorem abelian_of_aut_cyclic{α : Type u_1} [Groupₓₓ α] [Fintypeₓ (aut α)] {G : Type u_2} [Groupₓₓ G] [Fintypeₓ G] (h : IsCyclic G) : ∀ (f : α →* G), IsGroupHom f → Function.Injective ⇑f → ((∃ (a : α), f a = 1) → CommGroupₓₓ α) ",
      "theorem abelian_of_aut_cyclic{α : Type u_1} [Groupₓ α] [Fintypeₓ (aut α)] {G : Type u_2} [Groupₓ G] [Fintypeₓ G] (h : IsCyclic G) : ∀ (f : α →* G), IsGroupHom f → Function.Injective ⇑f → ((∃ (a : α), f a = 1) → CommGroup α) ",
      "theorem abelian_of_aut_cyclic{α : Type u_1} [Groupₓ α] [Fintypeₓ (aut α)] {G : Type u_2} [Groupₓ G] [Fintypeₓ G] (h : IsCyclic G) : ∀ (f : α →* G), IsGroupHom f → Function.Injective ⇑f → ((∃ (a : α), f a = 1) → CommGroupₓₓ α) ",
      "theorem abelian_of_aut_cyclic{α : Type u_1} [Group α] [Fintypeₓ (aut α)] {G : Type u_2} [Group G] [Fintypeₓ G] (h : IsCyclic G) : ∀ (f : α →* G), IsGroupHom f → Function.Injective ⇑f → ((∃ (a : α), f a = 1) → CommGroupₓ α) ",
      "theorem abelian_of_aut_cyclic{α : Type u_1} [Groupₓₓ α] [Fintypeₓ (aut α)] {G : Type u_2} [Groupₓₓ G] [Fintypeₓ G] (h : IsCyclic G) : ∀ (f : α →* G), IsGroupHom f → Function.Injective ⇑f → ((∃ (a : α), f a = 1) → CommGroupₓ α) ",
      "theorem abelian_of_aut_cyclic{α : Type u_1} [Groupₓ α] [Fintypeₓ (aut α)] {G : Type u_2} [Groupₓ G] [Fintypeₓ G] (h : IsCyclic G) : ∀ (f : α →* G), IsGroupHom f → Function.Injective ⇑f → ((∃ (a : α), f a = 1) → CommGroupₓ α) ",
      "theorem is_abelian_of_cyclic_aut_group{G : Type u_1} [Group G] : IsCyclic group_aut G →  is_abelian G ",
      "theorem is_abelian_of_cyclic_aut_group{G : Type u_1} [Groupₓₓ G] : IsCyclic group_aut G →  is_abelian G ",
      "theorem is_abelian_of_cyclic_aut_group{G : Type u_1} [Groupₓ G] : IsCyclic group_aut G →  is_abelian G ",
      "theorem is_abelian_of_aut_is_cyclic{α : Type u} [Group α] (h : IsCyclic (aut α)) : is_abelian α ",
      "theorem is_abelian_of_aut_is_cyclic{α : Type u} [Groupₓₓ α] (h : IsCyclic (aut α)) : is_abelian α ",
      "theorem is_abelian_of_aut_is_cyclic{α : Type u} [Groupₓ α] (h : IsCyclic (aut α)) : is_abelian α ",
      "theorem abelian_of_auto_cyclic(H : α) {G : Type u} [Group G] (H1 : IsCyclic (automorphism_group α)) : abelian G ",
      "theorem abelian_of_auto_cyclic(H : α) {G : Type u} [Groupₓₓ G] (H1 : IsCyclic (automorphism_group α)) : abelian G ",
      "theorem abelian_of_auto_cyclic(H : α) {G : Type u} [Groupₓ G] (H1 : IsCyclic (automorphism_group α)) : abelian G ",
      "theorem is_abelian_of_aut_cyclic{G : Type u} [Group G] (a : G) (ha : IsCyclic (aut G)) : is_abelian G ",
      "theorem is_abelian_of_aut_cyclic{G : Type u} [Groupₓₓ G] (a : G) (ha : IsCyclic (aut G)) : is_abelian G ",
      "theorem is_abelian_of_aut_cyclic{G : Type u} [Groupₓ G] (a : G) (ha : IsCyclic (aut G)) : is_abelian G "
    ],
    "answer": "theorem aut_group_cyclic_implies_abelian {G : Type _} [Groupₓ G] : CategoryTheory.Aut G → CommGroup G "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "aut_group_cyclic_implies_abelian",
      "main_prompt": "A group whose automorphism group is cyclic is Abelian.",
      "prompt": "Natural language version: \"A group whose automorphism group is cyclic is Abelian.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 9.479002601001412,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem is_abelian_of_aut_group_cyclic (G : Set α) [Group α] [CommGroup α] [Fintype (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Set α) [Group α] [CommGroupₓₓ α] [Fintype (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Set α) [Groupₓₓ α] [CommGroup α] [Fintype (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Set α) [Groupₓₓ α] [CommGroupₓₓ α] [Fintype (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Setₓ α) [Group α] [CommGroup α] [Fintype (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Setₓ α) [Group α] [CommGroupₓₓ α] [Fintype (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Setₓ α) [Groupₓₓ α] [CommGroup α] [Fintype (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Setₓ α) [Groupₓₓ α] [CommGroupₓₓ α] [Fintype (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Set α) [Groupₓ α] [CommGroup α] [Fintype (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Set α) [Groupₓ α] [CommGroupₓₓ α] [Fintype (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Setₓ α) [Groupₓ α] [CommGroup α] [Fintype (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Setₓ α) [Groupₓ α] [CommGroupₓₓ α] [Fintype (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Set α) [Group α] [CommGroupₓ α] [Fintype (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Set α) [Groupₓₓ α] [CommGroupₓ α] [Fintype (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Setₓ α) [Group α] [CommGroupₓ α] [Fintype (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Setₓ α) [Groupₓₓ α] [CommGroupₓ α] [Fintype (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Set α) [Groupₓ α] [CommGroupₓ α] [Fintype (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Setₓ α) [Groupₓ α] [CommGroupₓ α] [Fintype (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Set α) [Group α] [CommGroup α] [Fintypeₓ (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Set α) [Group α] [CommGroupₓₓ α] [Fintypeₓ (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Set α) [Groupₓₓ α] [CommGroup α] [Fintypeₓ (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Set α) [Groupₓₓ α] [CommGroupₓₓ α] [Fintypeₓ (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Setₓ α) [Group α] [CommGroup α] [Fintypeₓ (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Setₓ α) [Group α] [CommGroupₓₓ α] [Fintypeₓ (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Setₓ α) [Groupₓₓ α] [CommGroup α] [Fintypeₓ (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Setₓ α) [Groupₓₓ α] [CommGroupₓₓ α] [Fintypeₓ (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Set α) [Groupₓ α] [CommGroup α] [Fintypeₓ (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Set α) [Groupₓ α] [CommGroupₓₓ α] [Fintypeₓ (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Setₓ α) [Groupₓ α] [CommGroup α] [Fintypeₓ (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Setₓ α) [Groupₓ α] [CommGroupₓₓ α] [Fintypeₓ (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Set α) [Group α] [CommGroupₓ α] [Fintypeₓ (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Set α) [Groupₓₓ α] [CommGroupₓ α] [Fintypeₓ (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Setₓ α) [Group α] [CommGroupₓ α] [Fintypeₓ (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Setₓ α) [Groupₓₓ α] [CommGroupₓ α] [Fintypeₓ (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Set α) [Groupₓ α] [CommGroupₓ α] [Fintypeₓ (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_abelian_of_aut_group_cyclic (G : Setₓ α) [Groupₓ α] [CommGroupₓ α] [Fintypeₓ (aut α)] :   ∀ g ∈ (↑aut α), IsSubgroup G → cyclic (↑(aut_group.map aut_hom G g) α) → is_abelian G ",
      "theorem is_Abelian_of_cyclic_aut_group (G : Type) [Group G] : (∃ g : G, ∀ x : G, cyclic (group_aut.automorphism_group G x)) → Abelian G ",
      "theorem is_Abelian_of_cyclic_aut_group (G : Type) [Groupₓₓ G] : (∃ g : G, ∀ x : G, cyclic (group_aut.automorphism_group G x)) → Abelian G ",
      "theorem is_Abelian_of_cyclic_aut_group (G : Type) [Groupₓ G] : (∃ g : G, ∀ x : G, cyclic (group_aut.automorphism_group G x)) → Abelian G ",
      "theorem cyclic_group_is_abelian (G : Type*) [Group G] [Fintype G] (hNG : ¬ is_group G) (H : Finset G → Finset G → Type*) (H_bin : ∀ g : G, H (singleton (1 : G)) (singleton g) = Unit) (H_assoc : ∀ g h i : G, H (singleton (g * h)) (singleton i) = H (singleton g) (singleton h)) (H_id : H (singleton (1 : G)) (singleton (1 : G)) = Unit) (H_inv : ∀ g :",
      "theorem cyclic_group_is_abelian (G : Type*) [Groupₓₓ G] [Fintype G] (hNG : ¬ is_group G) (H : Finset G → Finset G → Type*) (H_bin : ∀ g : G, H (singleton (1 : G)) (singleton g) = Unit) (H_assoc : ∀ g h i : G, H (singleton (g * h)) (singleton i) = H (singleton g) (singleton h)) (H_id : H (singleton (1 : G)) (singleton (1 : G)) = Unit) (H_inv : ∀ g :",
      "theorem cyclic_group_is_abelian (G : Type*) [Groupₓ G] [Fintype G] (hNG : ¬ is_group G) (H : Finset G → Finset G → Type*) (H_bin : ∀ g : G, H (singleton (1 : G)) (singleton g) = Unit) (H_assoc : ∀ g h i : G, H (singleton (g * h)) (singleton i) = H (singleton g) (singleton h)) (H_id : H (singleton (1 : G)) (singleton (1 : G)) = Unit) (H_inv : ∀ g :",
      "theorem cyclic_group_is_abelian (G : Type*) [Group G] [Fintypeₓ G] (hNG : ¬ is_group G) (H : Finset G → Finset G → Type*) (H_bin : ∀ g : G, H (singleton (1 : G)) (singleton g) = Unit) (H_assoc : ∀ g h i : G, H (singleton (g * h)) (singleton i) = H (singleton g) (singleton h)) (H_id : H (singleton (1 : G)) (singleton (1 : G)) = Unit) (H_inv : ∀ g :",
      "theorem cyclic_group_is_abelian (G : Type*) [Groupₓₓ G] [Fintypeₓ G] (hNG : ¬ is_group G) (H : Finset G → Finset G → Type*) (H_bin : ∀ g : G, H (singleton (1 : G)) (singleton g) = Unit) (H_assoc : ∀ g h i : G, H (singleton (g * h)) (singleton i) = H (singleton g) (singleton h)) (H_id : H (singleton (1 : G)) (singleton (1 : G)) = Unit) (H_inv : ∀ g :",
      "theorem cyclic_group_is_abelian (G : Type*) [Groupₓ G] [Fintypeₓ G] (hNG : ¬ is_group G) (H : Finset G → Finset G → Type*) (H_bin : ∀ g : G, H (singleton (1 : G)) (singleton g) = Unit) (H_assoc : ∀ g h i : G, H (singleton (g * h)) (singleton i) = H (singleton g) (singleton h)) (H_id : H (singleton (1 : G)) (singleton (1 : G)) = Unit) (H_inv : ∀ g :",
      "theorem noncomm_cyclic (G : Type) [Group G] [Fintype G] [DecidableEq G] :   not is_comm_group G → ∃ (g : G) (n : ℕ), order g = n ",
      "theorem noncomm_cyclic (G : Type) [Groupₓₓ G] [Fintype G] [DecidableEq G] :   not is_comm_group G → ∃ (g : G) (n : ℕ), order g = n ",
      "theorem noncomm_cyclic (G : Type) [Groupₓ G] [Fintype G] [DecidableEq G] :   not is_comm_group G → ∃ (g : G) (n : ℕ), order g = n ",
      "theorem noncomm_cyclic (G : Type) [Group G] [Fintypeₓ G] [DecidableEq G] :   not is_comm_group G → ∃ (g : G) (n : ℕ), order g = n ",
      "theorem noncomm_cyclic (G : Type) [Groupₓₓ G] [Fintypeₓ G] [DecidableEq G] :   not is_comm_group G → ∃ (g : G) (n : ℕ), order g = n ",
      "theorem noncomm_cyclic (G : Type) [Groupₓ G] [Fintypeₓ G] [DecidableEq G] :   not is_comm_group G → ∃ (g : G) (n : ℕ), order g = n ",
      "theorem is_abelian  { G : Group }  [ hG : is_cyclic_group G ]  : is_abelian_group G ",
      "theorem is_abelian  { G : Groupₓₓ }  [ hG : is_cyclic_group G ]  : is_abelian_group G ",
      "theorem is_abelian  { G : Groupₓ }  [ hG : is_cyclic_group G ]  : is_abelian_group G "
    ],
    "answer": "theorem aut_group_cyclic_implies_abelian {G : Type _} [Groupₓ G] : CategoryTheory.Aut G → CommGroup G "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "image_union",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"The image of a union of sets is the union of the images.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The image of a union of sets is the union of the images.",
      "codex_time": 12.794990707014222,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem image_union_eq_union_image {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]  (f : X → Y) (s t : Set X) : f '' (s ∪ t) = f '' s ∪ f '' t ",
      "theorem image_union_eq_union_image {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]  (f : X → Y) (s t : Setₓ X) : f '' (s ∪ t) = f '' s ∪ f '' t ",
      "theorem image_union (f : X → Y) (s₁ s₂ : Set X) :  f '' (s₁ ∪ s₂) = f '' s₁ ∪ f '' s₂ ",
      "theorem image_union (f : X → Y) (s₁ s₂ : Setₓ X) :  f '' (s₁ ∪ s₂) = f '' s₁ ∪ f '' s₂ ",
      "theorem image_union_is_union_of_images (X Y : Type*) [TopologicalSpace X] [TopologicalSpace Y]  (f : X → Y) (s t : Set X) : f '' (s ∪ t) = f '' s ∪ f '' t ",
      "theorem image_union_is_union_of_images (X Y : Type*) [TopologicalSpace X] [TopologicalSpace Y]  (f : X → Y) (s t : Setₓ X) : f '' (s ∪ t) = f '' s ∪ f '' t ",
      "theorem image_union_eq_union_image (f : ι → η) {s : ι → Set η}  (h : ∀a:ι, f a ∈ s a) :   f ⁻¹' (⋃ a, s a) = ⋃ a, f ⁻¹' s a ",
      "theorem image_union_eq_union_image (f : ι → η) {s : ι → Setₓ η}  (h : ∀a:ι, f a ∈ s a) :   f ⁻¹' (⋃ a, s a) = ⋃ a, f ⁻¹' s a ",
      "theorem image_union_eq_union_image (X : Type*) [TopologicalSpace X] (Y : Type*)  [TopologicalSpace Y] (ϕ : X → Y) (S : Set X) : IsOpen S →  ∀ (A : Set (Set X)), (∀ T ∈ A, IsOpen T ∧ ϕ ⁻¹' ϕ '' T = T) →  ϕ '' (⋃₀ A) = ⋃₀ {ϕ '' A | A ∈ A} ",
      "theorem image_union_eq_union_image (X : Type*) [TopologicalSpace X] (Y : Type*)  [TopologicalSpace Y] (ϕ : X → Y) (S : Setₓ X) : IsOpen S →  ∀ (A : Setₓ (Setₓ X)), (∀ T ∈ A, IsOpen T ∧ ϕ ⁻¹' ϕ '' T = T) →  ϕ '' (⋃₀ A) = ⋃₀ {ϕ '' A | A ∈ A} "
    ],
    "answer": "theorem image_union (f : α → β) (S : Set (Set α)) : (f <$> (⋃₀ S)) = (⋃₀ ((Functor.map f) <$> S)) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "image_union",
      "main_prompt": "The image of a union of sets is the union of the images.",
      "prompt": "Natural language version: \" The cardinality of a union is at most the sum of the cardinalities of the two sets.\" Translate the natural language version to a Lean mathlib version:\n theorem cardinal.mk_union_le{α : Type u} (S T : set α) :\ncardinal.mk ↥(S ∪ T) ≤ cardinal.mk ↥S + cardinal.mk ↥T := \n\nNatural language version: \" This rather trivial consequence of `subset_Union`is convenient with `apply`, and has `i` explicit for this purpose.\" Translate the natural language version to a Lean mathlib version:\n theorem set.subset_Union_of_subset{α : Type u_1} {ι : Sort u_4} {s : set α} {t : ι → set α} (i : ι) (h : s ⊆ t i) :\ns ⊆ ⋃ (i : ι), t i := \n\nNatural language version: \"The union of two sets is bounded iff each of the sets is bounded.\" Translate the natural language version to a Lean mathlib version:\n theorem metric.bounded_union{α : Type u} [pseudo_metric_space α] {s t : set α} :\nmetric.bounded (s ∪ t) ↔ metric.bounded s ∧ metric.bounded t := \n\nNatural language version: \"The span of a union of sets is the sup of their spans.\" Translate the natural language version to a Lean mathlib version:\n theorem affine_subspace.span_union(k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s t : set P) :\naffine_span k (s ∪ t) = affine_span k s ⊔ affine_span k t := \n\nNatural language version: \"The image of a union of sets is the union of the images.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6315420866012573,
          "doc_string": " The cardinality of a union is at most the sum of the cardinalities of the two sets.",
          "statement": "theorem cardinal.mk_union_le {α : Type u} (S T : set α) : cardinal.mk ↥(S ∪ T) ≤ cardinal.mk ↥S + cardinal.mk ↥T"
        },
        {
          "sim_score": 0.5471856594085693,
          "doc_string": " This rather trivial consequence of `subset_Union`is convenient with `apply`, and has `i` explicit for this purpose.",
          "statement": "theorem set.subset_Union_of_subset {α : Type u_1} {ι : Sort u_4} {s : set α} {t : ι → set α} (i : ι) (h : s ⊆ t i) : s ⊆ ⋃ (i : ι), t i"
        },
        {
          "sim_score": 0.5332727432250977,
          "doc_string": "The union of two sets is bounded iff each of the sets is bounded.",
          "statement": "theorem metric.bounded_union {α : Type u} [pseudo_metric_space α] {s t : set α} : metric.bounded (s ∪ t) ↔ metric.bounded s ∧ metric.bounded t"
        },
        {
          "sim_score": 0.5295044779777527,
          "doc_string": "The span of a union of sets is the sup of their spans.",
          "statement": "theorem affine_subspace.span_union (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s t : set P) : affine_span k (s ∪ t) = affine_span k s ⊔ affine_span k t"
        }
      ],
      "codex_time": 5.90167042799294,
      "search_time": 1.4571299679810181,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem function.image_union{α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β) (g : α → γ) (s : Set α) : function.image f s ∪ function.image g s = function.image (Sum f g) s ",
      "theorem function.image_union{α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β) (g : α → γ) (s : Setₓ α) : function.image f s ∪ function.image g s = function.image (Sum f g) s ",
      "theorem set.image_union{α : Type u_1} {β : Type u_2} (s t : Set α) (f : α → β) : f ⁻¹' (s ∪ t) = f ⁻¹' s ∪ f ⁻¹' t ",
      "theorem set.image_union{α : Type u_1} {β : Type u_2} (s t : Setₓ α) (f : α → β) : f ⁻¹' (s ∪ t) = f ⁻¹' s ∪ f ⁻¹' t ",
      "theorem function.image.Union_image{α : Type u} {β : Type v_1} (f : α → β) (s : Set (Set α)) : f '' (⋃ s) = (⋃ (t : Set α) (H : t ∈ s), f '' t) ",
      "theorem function.image.Union_image{α : Type u} {β : Type v_1} (f : α → β) (s : Setₓ (Setₓ α)) : f '' (⋃ s) = (⋃ (t : Setₓ α) (H : t ∈ s), f '' t) ",
      "theorem set.image_union{α : Type u} {β : Type v} {f : α → β} {s t : Set α} : f '' (s ∪ t) = f '' s ∪ f '' t ",
      "theorem set.image_union{α : Type u} {β : Type v} {f : α → β} {s t : Setₓ α} : f '' (s ∪ t) = f '' s ∪ f '' t ",
      "theorem set.image_Union{α : Type u_1} {β : Type u_2} {f : α → β} {s : Set α} {t : Set (Set α)} (h : s ∈ t) : f '' (⋃ (u : {x // x ∈ t}), ⇑u) = ⋃ u, f '' u ",
      "theorem set.image_Union{α : Type u_1} {β : Type u_2} {f : α → β} {s : Setₓ α} {t : Setₓ (Setₓ α)} (h : s ∈ t) : f '' (⋃ (u : {x // x ∈ t}), ⇑u) = ⋃ u, f '' u "
    ],
    "answer": "theorem image_union (f : α → β) (S : Set (Set α)) : (f <$> (⋃₀ S)) = (⋃₀ ((Functor.map f) <$> S)) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "image_union",
      "main_prompt": "The image of a union of sets is the union of the images.",
      "prompt": "Natural language version: \"The image of a union of sets is the union of the images.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 8.341736010013847,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem image_union_eq : ∀ (f : α → β) (s t : Set α),    f '' (s ∪ t) = f '' s ∪ f '' t ",
      "theorem image_union_eq : ∀ (f : α → β) (s t : Setₓ α),    f '' (s ∪ t) = f '' s ∪ f '' t ",
      "theorem image_union_of_sets (f : Π (A : Set X), Set Y) {S T : Set X} :  f (S ∪ T) = f S ∪ f T ",
      "theorem image_union_of_sets (f : Π (A : Setₓ X), Setₓ Y) {S T : Setₓ X} :  f (S ∪ T) = f S ∪ f T ",
      "theorem the_image_of_the_union_is_the_union_of_the_images {α : Type*} {β : Type*}:  Π (f : α → β) (a : Set α), ∀ b, a ∈ b →  f '' a  ⊆ f '' (⋃₀ b) ",
      "theorem the_image_of_the_union_is_the_union_of_the_images {α : Type*} {β : Type*}:  Π (f : α → β) (a : Setₓ α), ∀ b, a ∈ b →  f '' a  ⊆ f '' (⋃₀ b) ",
      "theorem image_union_of (L:Set X) (f:X\\to Y):(image_of L f) = (union_of (image_of L f)) ",
      "theorem image_union_of (L:Setₓ X) (f:X\\to Y):(image_of L f) = (union_of (image_of L f)) ",
      "theorem image_union_theorem {α β: Type} {s: Set (Set α)} {f: α → β}:   f '' (⋃₀ s) = (⋃₀ s >> f) ",
      "theorem image_union_theorem {α β: Type} {s: Setₓ (Setₓ α)} {f: α → β}:   f '' (⋃₀ s) = (⋃₀ s >> f) "
    ],
    "answer": "theorem image_union (f : α → β) (S : Set (Set α)) : (f <$> (⋃₀ S)) = (⋃₀ ((Functor.map f) <$> S)) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "urysohn",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.",
      "codex_time": 7.428364108985988,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem separated_iff_is_normal (X : Type*) [TopologicalSpace X] :  is_normal X ↔ ∀ (C D : Set X) (hC : IsClosed C) (hD : IsClosed D) (hCD : C ∩ D = ∅),  ∃ (U V : Set X) (hU : IsOpen U) (hV : IsOpen V), C ⊆ U ∧ D ⊆ V ∧ X = U ∪ V ",
      "theorem separated_iff_is_normal (X : Type*) [TopologicalSpace X] :  is_normal X ↔ ∀ (C D : Setₓ X) (hC : IsClosed C) (hD : IsClosed D) (hCD : C ∩ D = ∅),  ∃ (U V : Setₓ X) (hU : IsOpen U) (hV : IsOpen V), C ⊆ U ∧ D ⊆ V ∧ X = U ∪ V ",
      "theorem normal_space_iff_separating_function_exists (X : Type*) [TopologicalSpace X] :  is_normal X ↔ (∀ f g : Set X, Disjoint f g → IsClosed f ",
      "theorem normal_space_iff_separating_function_exists (X : Type*) [TopologicalSpace X] :  is_normal X ↔ (∀ f g : Setₓ X, Disjoint f g → IsClosed f ",
      "theorem normal_iff_disjoint_closed_separated (X : Type*) [TopologicalSpace X] :  NormalSpace X ↔ ∀ C D : Set X, IsClosed C ∧ IsClosed D ∧ Disjoint C D → ∃ f : X → ℝ, Continuous f ∧ ∀ x y, f x = f y → x ∈ C ∧ y ∈ D ∨ x ∈ D ∧ y ∈ C ",
      "theorem normal_iff_disjoint_closed_separated (X : Type*) [TopologicalSpace X] :  NormalSpace X ↔ ∀ C D : Setₓ X, IsClosed C ∧ IsClosed D ∧ Disjoint C D → ∃ f : X → ℝ, Continuous f ∧ ∀ x y, f x = f y → x ∈ C ∧ y ∈ D ∨ x ∈ D ∧ y ∈ C ",
      "theorem normal_iff_closed_subsets_separated (X : Type*) [TopologicalSpace X] :  NormalSpace X ↔ ∀ (A B : Set X) (hAcl : IsClosed A) (hBcl : IsClosed B)  (hA_inter_B_empty : A ∩ B = ∅), ∃ f : X → ℝ, Continuous f ∧ (∀ a ∈ A, f a = 0) ∧ (∀ b ∈ B, f b = 1) ",
      "theorem normal_iff_closed_subsets_separated (X : Type*) [TopologicalSpace X] :  NormalSpace X ↔ ∀ (A B : Setₓ X) (hAcl : IsClosed A) (hBcl : IsClosed B)  (hA_inter_B_empty : A ∩ B = ∅), ∃ f : X → ℝ, Continuous f ∧ (∀ a ∈ A, f a = 0) ∧ (∀ b ∈ B, f b = 1) ",
      "theorem normal_iff_disjoint_closed_separable (X : Type*) [TopologicalSpace X] :  NormalSpace X ↔  (∀ A B : Set X, IsClosed A → IsClosed B → Disjoint A B → ∃ f : X → ℝ, Continuous f ∧  set.separation (A) (B) f ",
      "theorem normal_iff_disjoint_closed_separable (X : Type*) [TopologicalSpace X] :  NormalSpace X ↔  (∀ A B : Setₓ X, IsClosed A → IsClosed B → Disjoint A B → ∃ f : X → ℝ, Continuous f ∧  set.separation (A) (B) f "
    ],
    "answer": "theorem urysohn {X : Type _} [TopologicalSpace X] [TopologicalSpace ℝ] : NormalSpace X ↔ ( ∀ {S T : Set X}, IsClosed S → IsClosed T → Disjoint S T → (∃ f : X → ℝ, Continuous f → (∀ x ∈ S, f x = 0) ∧ (∀ x ∈ T, f x = 1)) ) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "urysohn",
      "main_prompt": "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.",
      "prompt": "Natural language version: \" Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, then there exists a continuous function `f : X → ℝ` such that  * `f` equals zero on `s`; * `f` equals one on `t`; * `0 ≤ f x ≤ 1` for all `x`.\" Translate the natural language version to a Lean mathlib version:\n theorem exists_bounded_zero_one_of_closed{X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) :\n∃ (f : bounded_continuous_function X ℝ), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1 := \n\nNatural language version: \" Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, then there exists a continuous function `f : X → ℝ` such that  * `f` equals zero on `s`; * `f` equals one on `t`; * `0 ≤ f x ≤ 1` for all `x`.\" Translate the natural language version to a Lean mathlib version:\n theorem exists_continuous_zero_one_of_closed{X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) :\n∃ (f : C(X, ℝ)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1 := \n\nNatural language version: \" Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, and `a ≤ b` are two real numbers, then there exists a continuous function `f : X → ℝ` such that  * `f` equals `a` on `s`; * `f` equals `b` on `t`; * `a ≤ f x ≤ b` for all `x`.\" Translate the natural language version to a Lean mathlib version:\n theorem exists_bounded_mem_Icc_of_closed_of_le{X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) {a b : ℝ} (hle : a ≤ b) :\n∃ (f : bounded_continuous_function X ℝ), set.eq_on ⇑f (function.const X a) s ∧ set.eq_on ⇑f (function.const X b) t ∧ ∀ (x : X), ⇑f x ∈ set.Icc a b := \n\nNatural language version: \"The topological closure of a normal subgroup is normal.\" Translate the natural language version to a Lean mathlib version:\n theorem subgroup.is_normal_topological_closure{G : Type u_1} [topological_space G] [group G] [topological_group G] (N : subgroup G) [N.normal] :\nN.topological_closure.normal := \n\nNatural language version: \"A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.629673182964325,
          "doc_string": " Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, then there exists a continuous function `f : X → ℝ` such that  * `f` equals zero on `s`; * `f` equals one on `t`; * `0 ≤ f x ≤ 1` for all `x`.",
          "statement": "theorem exists_bounded_zero_one_of_closed {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : ∃ (f : bounded_continuous_function X ℝ), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1"
        },
        {
          "sim_score": 0.629673182964325,
          "doc_string": " Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, then there exists a continuous function `f : X → ℝ` such that  * `f` equals zero on `s`; * `f` equals one on `t`; * `0 ≤ f x ≤ 1` for all `x`.",
          "statement": "theorem exists_continuous_zero_one_of_closed {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : ∃ (f : C(X, ℝ)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1"
        },
        {
          "sim_score": 0.5748592615127563,
          "doc_string": " Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, and `a ≤ b` are two real numbers, then there exists a continuous function `f : X → ℝ` such that  * `f` equals `a` on `s`; * `f` equals `b` on `t`; * `a ≤ f x ≤ b` for all `x`.",
          "statement": "theorem exists_bounded_mem_Icc_of_closed_of_le {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) {a b : ℝ} (hle : a ≤ b) : ∃ (f : bounded_continuous_function X ℝ), set.eq_on ⇑f (function.const X a) s ∧ set.eq_on ⇑f (function.const X b) t ∧ ∀ (x : X), ⇑f x ∈ set.Icc a b"
        },
        {
          "sim_score": 0.5395680069923401,
          "doc_string": "The topological closure of a normal subgroup is normal.",
          "statement": "theorem subgroup.is_normal_topological_closure {G : Type u_1} [topological_space G] [group G] [topological_group G] (N : subgroup G) [N.normal] : N.topological_closure.normal"
        }
      ],
      "codex_time": 8.357022618001793,
      "search_time": 1.484566332976101,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem normal_iff_two_set_separate{X : Type u_1} [TopologicalSpace X] : NormalSpace X ↔ ∀ (s t : Set X) (hs : IsClosed s) (ht : IsClosed t) (hd : Disjoint s t),  ∃ (f : C(X, ℝ)), Set.EqOn ⇑f 0 s ∧ Set.EqOn ⇑f 1 t ",
      "theorem normal_iff_two_set_separate{X : Type u_1} [TopologicalSpace X] : NormalSpace X ↔ ∀ (s t : Setₓ X) (hs : IsClosed s) (ht : IsClosed t) (hd : Disjoint s t),  ∃ (f : C(X, ℝ)), Setₓ.EqOn ⇑f 0 s ∧ Setₓ.EqOn ⇑f 1 t ",
      "theorem is_closed_topological_space.is_normal_iff_separated : ∀ {X : Type u_1} [TopologicalSpace X], is_closed_topological_space.is_normal X ↔ ∀ (s t : Set X), IsClosed s → IsClosed t → Disjoint s t → ∃(f : X → ℝ), Continuous f ∧ Set.EqOn f 0 s ∧ Set.EqOn f 1 t ",
      "theorem is_closed_topological_space.is_normal_iff_separated : ∀ {X : Type u_1} [TopologicalSpace X], is_closed_topological_space.is_normal X ↔ ∀ (s t : Setₓ X), IsClosed s → IsClosed t → Disjoint s t → ∃(f : X → ℝ), Continuous f ∧ Setₓ.EqOn f 0 s ∧ Setₓ.EqOn f 1 t ",
      "theorem tspace_normal_iff'{X : Type u_1} [TopologicalSpace X] (H : ∀ (s t : Set X), IsClosed s → IsClosed t → Disjoint s t → ∃ (f : C(X, I₁)), (Set.EqOn ⇑f 0 s) ∧ (Set.EqOn ⇑f 1 t)) : is_normal_space X ",
      "theorem tspace_normal_iff'{X : Type u_1} [TopologicalSpace X] (H : ∀ (s t : Setₓ X), IsClosed s → IsClosed t → Disjoint s t → ∃ (f : C(X, I₁)), (Setₓ.EqOn ⇑f 0 s) ∧ (Setₓ.EqOn ⇑f 1 t)) : is_normal_space X ",
      "theorem is_normal_of_separation_of_disjoint_closed{X : Type u_1} [TopologicalSpace X] : NormalSpace X ↔ ∀ (s t : Set X), IsClosed s → IsClosed t → Disjoint s t → ∃ (f : BoundedContinuousFunction X ℝ),   Set.EqOn ⇑f 0 s ∧ Set.EqOn ⇑f 1 t ",
      "theorem is_normal_of_separation_of_disjoint_closed{X : Type u_1} [TopologicalSpace X] : NormalSpace X ↔ ∀ (s t : Setₓ X), IsClosed s → IsClosed t → Disjoint s t → ∃ (f : BoundedContinuousFunction X ℝ),   Setₓ.EqOn ⇑f 0 s ∧ Setₓ.EqOn ⇑f 1 t ",
      "theorem normal_iff_separated_of_closed_of_closed{X : Type u_1} [TopologicalSpace X] [NormalSpace X] {s t : Set X} (hs : IsClosed s) (ht : IsClosed t) (hd : Disjoint s t) : ∃ (f : BoundedContinuousFunction X ℝ), Set.EqOn ⇑f 0 s ∧ Set.EqOn ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ Set.Icc 0 1 ",
      "theorem normal_iff_separated_of_closed_of_closed{X : Type u_1} [TopologicalSpace X] [NormalSpace X] {s t : Setₓ X} (hs : IsClosed s) (ht : IsClosed t) (hd : Disjoint s t) : ∃ (f : BoundedContinuousFunction X ℝ), Setₓ.EqOn ⇑f 0 s ∧ Setₓ.EqOn ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ Setₓ.Icc 0 1 "
    ],
    "answer": "theorem urysohn {X : Type _} [TopologicalSpace X] [TopologicalSpace ℝ] : NormalSpace X ↔ ( ∀ {S T : Set X}, IsClosed S → IsClosed T → Disjoint S T → (∃ f : X → ℝ, Continuous f → (∀ x ∈ S, f x = 0) ∧ (∀ x ∈ T, f x = 1)) ) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "urysohn",
      "main_prompt": "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.",
      "prompt": "Natural language version: \"A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 11.34956903901184,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem t1 : ∀ (X : Type) [TopologicalSpace X],     NormalSpace X ↔ (∀ (C D : Set X), closed_in_space X C → closed_in_space X D → Disjoint C D → (∃(f:X → ℝ), continuous_map_topological_space X ℝ f ∧ (C = f ⁻¹' {v | v > 0} ∧ D = f ⁻¹' {v | v < 0}))) ",
      "theorem t1 : ∀ (X : Type) [TopologicalSpace X],     NormalSpace X ↔ (∀ (C D : Setₓ X), closed_in_space X C → closed_in_space X D → Disjoint C D → (∃(f:X → ℝ), continuous_map_topological_space X ℝ f ∧ (C = f ⁻¹' {v | v > 0} ∧ D = f ⁻¹' {v | v < 0}))) ",
      "theorem normal_iff_separated { α : Type u } [ TopologicalSpace α ] :   NormalSpace α ↔ ∀ ( A B : Set α ), Disjoint A B →     ∃ u v : α → Prop , IsClosed u ∧ IsClosed v ∧ Continuous u ∧ Continuous v ∧     A = u.univ ∧ B = v.univ ∧ ∀ a : α , u a → ¬ v a .)  /-- A topological space is Normal if and only if any two Disjoint IsClosed subsets can be separated by a Continuous function. -/ lemma normal_iff_separated",
      "theorem normal_iff_separated { α : Type u } [ TopologicalSpace α ] :   NormalSpace α ↔ ∀ ( A B : Setₓ α ), Disjoint A B →     ∃ u v : α → Prop , IsClosed u ∧ IsClosed v ∧ Continuous u ∧ Continuous v ∧     A = u.univ ∧ B = v.univ ∧ ∀ a : α , u a → ¬ v a .)  /-- A topological space is Normal if and only if any two Disjoint IsClosed subsets can be separated by a Continuous function. -/ lemma normal_iff_separated",
      "theorem is_normal_iff_separate_disjoint_closed_subsets : ∀ ( X : Top ) ( I J N : Set X ),         IsClosed N I help /- Here, I assumed that you have defined the function IsClosed at the same tim",
      "theorem is_normal_iff_separate_disjoint_closed_subsets : ∀ ( X : Top ) ( I J N : Setₓ X ),         IsClosed N I help /- Here, I assumed that you have defined the function IsClosed at the same tim",
      "theorem lemma1 :  ∀ s : Set α,    IsClosed s →  ∀ t : Set α,    IsClosed t →    s ∩ t = ∅ →    ∃ u : α → Prop,      is_continuous u ∧ (∀ x : α, t ≤ u x) ∧ (∀ x : α, ¬ s ≤ u x) ",
      "theorem lemma1 :  ∀ s : Setₓ α,    IsClosed s →  ∀ t : Setₓ α,    IsClosed t →    s ∩ t = ∅ →    ∃ u : α → Prop,      is_continuous u ∧ (∀ x : α, t ≤ u x) ∧ (∀ x : α, ¬ s ≤ u x) ",
      "theorem exists_separating { X : Type * } [ TopologicalSpace X ]     { C C' : Set X } ( hC : IsClosed C ) ( hC' : IsClosed C' ) ( hCC' : C ∩ C' = ∅ ) :     ∃ f : X → ℝ , Continuous f ∧ ( ∀ x ∈ C , f x ≤ 0 ) ∧ ( ∀ x ∈ C' , 0 ≤ f x ) ",
      "theorem exists_separating { X : Type * } [ TopologicalSpace X ]     { C C' : Setₓ X } ( hC : IsClosed C ) ( hC' : IsClosed C' ) ( hCC' : C ∩ C' = ∅ ) :     ∃ f : X → ℝ , Continuous f ∧ ( ∀ x ∈ C , f x ≤ 0 ) ∧ ( ∀ x ∈ C' , 0 ≤ f x ) "
    ],
    "answer": "theorem urysohn {X : Type _} [TopologicalSpace X] [TopologicalSpace ℝ] : NormalSpace X ↔ ( ∀ {S T : Set X}, IsClosed S → IsClosed T → Disjoint S T → (∃ f : X → ℝ, Continuous f → (∀ x ∈ S, f x = 0) ∧ (∀ x ∈ T, f x = 1)) ) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "real_field_aut_trivial",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"The only field automorphism of the reals is the identity.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The only field automorphism of the reals is the identity.",
      "codex_time": 6.783345555013511,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem field_automorphism_reals_eq_id : ∀ (f : ℝ →+* ℝ), f =  (id : ℝ →+* ℝ) ",
      "theorem field_automorphism_reals_id  : ∀ f : ℝ ≃+* ℝ, f = equiv.refl _ ",
      "theorem field_automorphism_of_reals  (f : ℝ → ℝ) [field_hom f] (hf0 : f 0 = 0) (hf1 : f 1 = 1)  : Function.bijective f ",
      "theorem field_hom_id_of_reals (f : ℝ →+* ℝ) : f = function.id ↔ Function.comp f f = f ",
      "theorem field_automorphism_reals_eq_id (f : ℝ →+* ℝ) : f = 1 "
    ],
    "answer": "theorem real_field_aut_trivial : ∀ (f : ℝ ≃+* ℝ), (∀ x : ℝ, f x = x) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "real_field_aut_trivial",
      "main_prompt": "The only field automorphism of the reals is the identity.",
      "prompt": "Natural language version: \" There is at most one ordered ring isomorphism between a linear ordered field and an archimedean linear ordered field.\" Translate the natural language version to a Lean mathlib version:\n theorem order_ring_iso.subsingleton_right{α : Type u_2} {β : Type u_3} [linear_ordered_field α] [linear_ordered_field β] [archimedean β] :\nsubsingleton (α ≃+*o β) := \n\nNatural language version: \" There is at most one ordered ring isomorphism between an archimedean linear ordered field and a linear ordered field.\" Translate the natural language version to a Lean mathlib version:\n theorem order_ring_iso.subsingleton_left{α : Type u_2} {β : Type u_3} [linear_ordered_field α] [archimedean α] [linear_ordered_field β] :\nsubsingleton (α ≃+*o β) := \n\nNatural language version: \" There is at most one ordered ring homomorphism from a linear ordered field to an archimedean linear ordered field.\" Translate the natural language version to a Lean mathlib version:\n theorem order_ring_hom.subsingleton{α : Type u_2} {β : Type u_3} [linear_ordered_field α] [linear_ordered_field β] [archimedean β] :\nsubsingleton (α →+*o β) := \n\nNatural language version: \"The cardinality of the reals, as a type.\" Translate the natural language version to a Lean mathlib version:\n theorem cardinal.mk_real :\ncardinal.mk ℝ = cardinal.continuum := \n\nNatural language version: \"The only field automorphism of the reals is the identity.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5189149975776672,
          "doc_string": " There is at most one ordered ring isomorphism between a linear ordered field and an archimedean linear ordered field.",
          "statement": "theorem order_ring_iso.subsingleton_right {α : Type u_2} {β : Type u_3} [linear_ordered_field α] [linear_ordered_field β] [archimedean β] : subsingleton (α ≃+*o β)"
        },
        {
          "sim_score": 0.5125109553337097,
          "doc_string": " There is at most one ordered ring isomorphism between an archimedean linear ordered field and a linear ordered field.",
          "statement": "theorem order_ring_iso.subsingleton_left {α : Type u_2} {β : Type u_3} [linear_ordered_field α] [archimedean α] [linear_ordered_field β] : subsingleton (α ≃+*o β)"
        },
        {
          "sim_score": 0.4997551739215851,
          "doc_string": " There is at most one ordered ring homomorphism from a linear ordered field to an archimedean linear ordered field.",
          "statement": "theorem order_ring_hom.subsingleton {α : Type u_2} {β : Type u_3} [linear_ordered_field α] [linear_ordered_field β] [archimedean β] : subsingleton (α →+*o β)"
        },
        {
          "sim_score": 0.4784242510795593,
          "doc_string": "The cardinality of the reals, as a type.",
          "statement": "theorem cardinal.mk_real  : cardinal.mk ℝ = cardinal.continuum"
        }
      ],
      "codex_time": 9.451521862996742,
      "search_time": 1.5093220950220712,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem real.subsingleton_field_aut : Subsingleton (real.field_aut →₀ real.field_aut) ",
      "theorem eq_id.field_automorphisms_reals (f : ℝ →+* ℝ) : f = 𝕍 ",
      "theorem field_automorphism.id_iff_of_real_field {α : Type u_1} [Field α] {f : α ≃+* α} (hr : ∀ a : α, a ≠ 0 → ∃ n : ℕ, n⁻¹ ≤ f a ∧ f a ≤ n) : f = field_automorphism.id α ",
      "theorem field_automorphism_real.unique (f : ℝ →+* ℝ) : f = field_automorphism.id ",
      "theorem is_field_automorphism_id : ∀ (g : ℝ →+* ℝ), g = 𝕍1 "
    ],
    "answer": "theorem real_field_aut_trivial : ∀ (f : ℝ ≃+* ℝ), (∀ x : ℝ, f x = x) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "real_field_aut_trivial",
      "main_prompt": "The only field automorphism of the reals is the identity.",
      "prompt": "Natural language version: \"The only field automorphism of the reals is the identity.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 13.798172502021771,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem exists_automorphism_of_field_reals : exists (ee : Embedding ℝ ℝ), ee.to_fun ≠ id ",
      "theorem the_only_field_automorphism_of_the_reals_is_the_identity :  (∀ f : ℝ → ℝ, Function.bijective f → automorphism f (add_monoid.to_add_group ℝ)) → ((automorphism.to_add_group_hom     (is_group_hom.of_bijective       (is_add_group_hom.add_monoid_to_add_group ℝ)       (automorphism.symm (is_total_bijection.id (add_monoid.to_add_group ℝ))",
      "theorem poly_aut (f : α → β) [is_field_hom f] [Field α] [Field β] (h : ¬ α = ⊤) : f = id ",
      "theorem f_aut_id : ∀ f : ℝ → ℝ, function.automorphism f → f = id in mathlib proof :   intros f hf ⟨ g hg ⟩ , have hg' : ... ",
      "theorem King_of_the_real_numbers {U : Type} (Algebra : Type) [CommMonoid U]  (ϕ : Algebra → Algebra) (B : Algebra) (Hom : Algebra → U → Prop)  (homomorphism : ∀ a, Hom a (1))  (invariant : ∀ {a b : Algebra}, Hom a b → Hom (ϕ a) b)  (μ : Algebra → U → Algebra → Type) (ϕ_mul : ∀ a b, Hom a b → Hom (ϕ a) b → Hom (ϕ (ϕ a)) (ϕ b))  (one_of_a :",
      "theorem King_of_the_real_numbers {U : Type} (Algebra : Type) [CommMonoidₓ U]  (ϕ : Algebra → Algebra) (B : Algebra) (Hom : Algebra → U → Prop)  (homomorphism : ∀ a, Hom a (1))  (invariant : ∀ {a b : Algebra}, Hom a b → Hom (ϕ a) b)  (μ : Algebra → U → Algebra → Type) (ϕ_mul : ∀ a b, Hom a b → Hom (ϕ a) b → Hom (ϕ (ϕ a)) (ϕ b))  (one_of_a :"
    ],
    "answer": "theorem real_field_aut_trivial : ∀ (f : ℝ ≃+* ℝ), (∀ x : ℝ, f x = x) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "period_three_implies_chaos",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.",
      "codex_time": 13.564320550009143,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem fn_with_three_period_has_all_periods_gt_0 [Nonempty α] [Preorder α]  (f : α → α) (h_three : ∃ x, ∃ e > 0, ∀ y, dist y x < e → f y = f (f (f x)))  (h_mono : Monotone f) : ∀ (n : ℕ), n > 0 → ∃ x, ∃ e > 0,  ∀ y, dist y x < e → f^[n] x = f^[n] y ",
      "theorem fn_with_three_period_has_all_periods_gt_0 [Nonempty α] [Preorderₓₓ α]  (f : α → α) (h_three : ∃ x, ∃ e > 0, ∀ y, dist y x < e → f y = f (f (f x)))  (h_mono : Monotone f) : ∀ (n : ℕ), n > 0 → ∃ x, ∃ e > 0,  ∀ y, dist y x < e → f^[n] x = f^[n] y ",
      "theorem fn_with_three_period_has_all_periods_gt_0 [Nonempty α] [Preorderₓ α]  (f : α → α) (h_three : ∃ x, ∃ e > 0, ∀ y, dist y x < e → f y = f (f (f x)))  (h_mono : Monotone f) : ∀ (n : ℕ), n > 0 → ∃ x, ∃ e > 0,  ∀ y, dist y x < e → f^[n] x = f^[n] y ",
      "theorem points_of_positive_period_exist_of_point_period_three (f : [0,1] → [0,1])  (hf : ∃ x : [0,1], periodic f x 3) :  ∀ n : ℕ,  ∃ x : [0,1],  periodic f x n ",
      "theorem non_periodic_point_implies_point_of_all_periods (f : I → I)  (hf : ∃ x ∈ I, f (f (f x)) = x) : ∀ k : ℕ, k > 0 → ∃ y ∈ I, f ^ k y = y ",
      "theorem period_three_has_all_periods {X : Type*} [TopologicalSpace X] [MetricSpace X] [metric_space.to_topological_space X] (f : X → X) (x0 : X)  (hf : ∀ x : X, f (f (f x)) = f x) (hx0 : f (f (f x0)) = x0) :  ∀ n : ℕ, ∃ x : X, f (f (f ... (f x) ... n times)) = x ",
      "theorem period_three_implies_all_periods [TopologicalSpace (Icc 0 1)] [Nontrivial Icc_nontrivial_real]  (f : Icc 0 1 → Icc 0 1) (h : ∃ m : ℝ, 0 < m ∧ 1 > m ∧ f (real.Icc m (m+1)) = real.Icc m (m+1))  (hf : ∀ m : ℝ, 0 < m ∧ 1 > m → f (real.Icc m (m+1)) = real.Icc m (m+1)):   ∀ n:ℕ"
    ],
    "answer": "theorem period_three_implies_chaos : ∀ f : Set.Icc 0 1 → Set.Icc 0 1, (∃ x : Set.Icc 0 1, Function.IsPeriodicPt f 3 x) → (∀ n : ℕ, n > 0 → ∃ y : Set.Icc 0 1, Function.IsPeriodicPt f n y) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "period_three_implies_chaos",
      "main_prompt": "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.",
      "prompt": "Natural language version: \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some  `y ∈ Ico 0 c` such that `f x = f y`.\" Translate the natural language version to a Lean mathlib version:\n theorem function.periodic.exists_mem_Ico₀{α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x : α) :\n∃ (y : α) (H : y ∈ set.Ico 0 c), f x = f y := \n\nNatural language version: \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some  `y ∈ Ico a (a + c)` such that `f x = f y`.\" Translate the natural language version to a Lean mathlib version:\n theorem function.periodic.exists_mem_Ico{α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x a : α) :\n∃ (y : α) (H : y ∈ set.Ico a (a + c)), f x = f y := \n\nNatural language version: \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some  `y ∈ Ioc a (a + c)` such that `f x = f y`.\" Translate the natural language version to a Lean mathlib version:\n theorem function.periodic.exists_mem_Ioc{α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x a : α) :\n∃ (y : α) (H : y ∈ set.Ioc a (a + c)), f x = f y := \n\nNatural language version: \" If `f` sends two periodic points `x` and `y` of positive periods to the same point, then `x = y`.\" Translate the natural language version to a Lean mathlib version:\n theorem function.is_periodic_pt.eq_of_apply_eq{α : Type u_1} {f : α → α} {x y : α} {m n : ℕ} (hx : function.is_periodic_pt f m x) (hy : function.is_periodic_pt f n y) (hm : 0 < m) (hn : 0 < n) (h : f x = f y) :\nx = y := \n\nNatural language version: \"If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6410606503486633,
          "doc_string": "If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some  `y ∈ Ico 0 c` such that `f x = f y`.",
          "statement": "theorem function.periodic.exists_mem_Ico₀ {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x : α) : ∃ (y : α) (H : y ∈ set.Ico 0 c), f x = f y"
        },
        {
          "sim_score": 0.6367848515510559,
          "doc_string": "If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some  `y ∈ Ico a (a + c)` such that `f x = f y`.",
          "statement": "theorem function.periodic.exists_mem_Ico {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x a : α) : ∃ (y : α) (H : y ∈ set.Ico a (a + c)), f x = f y"
        },
        {
          "sim_score": 0.6170958876609802,
          "doc_string": "If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some  `y ∈ Ioc a (a + c)` such that `f x = f y`.",
          "statement": "theorem function.periodic.exists_mem_Ioc {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x a : α) : ∃ (y : α) (H : y ∈ set.Ioc a (a + c)), f x = f y"
        },
        {
          "sim_score": 0.5864872932434082,
          "doc_string": " If `f` sends two periodic points `x` and `y` of positive periods to the same point, then `x = y`.",
          "statement": "theorem function.is_periodic_pt.eq_of_apply_eq {α : Type u_1} {f : α → α} {x y : α} {m n : ℕ} (hx : function.is_periodic_pt f m x) (hy : function.is_periodic_pt f n y) (hm : 0 < m) (hn : 0 < n) (h : f x = f y) : x = y"
        }
      ],
      "codex_time": 8.996071822999511,
      "search_time": 1.5940131290117279,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem function.exists_period_three_of_Ico_self_to_self₀{α : Type u_1} [LinearOrderedCommGroup α] [Archimedean α] {f : Ico ₀ (1 : α) → Ico ₀ (1 : α)} (hf : Function.bijective f) : ∃ x, Function.IsPeriodicPt f 3 x ",
      "theorem function.is_periodic_pt.exists_three{α : Type u_1} [LinearOrderedAddCommGroup α] (f : Icc 0 1 → α) {x : α} (H : Function.IsPeriodicPt f 3 x) {z : α} (hz : 0 < z) : ∃ (t : ℕ) (y : α), Function.IsPeriodicPt f t y ",
      "theorem function.is_periodic_pt_of_period_three_Icc{f : ℝ → ℝ} (H : Function.IsPeriodicPt f (3 : ℕ) (0 : ℝ)) :  ∀ (m : ℕ), Function.IsPeriodicPt f m (0 : ℝ) ",
      "theorem function.exists_periodic_point.of_period_three_of_unit_interval_to_unit_interval{f : ℝ → ℝ} (h : function.exists_periodic_point 3 f) : ∀ (n : ℕ) (H : n > 0), function.exists_periodic_point n f ",
      "theorem function.exists_of_is_periodic_pt{α : Type u_1} {f : α → α} {x : α} {m : ℕ} (hx : Function.IsPeriodicPt f m x) (hm : 0 < m) : ∃ (y : α) (n : ℕ), (0 < n) ∧ (Function.IsPeriodicPt f n y) "
    ],
    "answer": "theorem period_three_implies_chaos : ∀ f : Set.Icc 0 1 → Set.Icc 0 1, (∃ x : Set.Icc 0 1, Function.IsPeriodicPt f 3 x) → (∀ n : ℕ, n > 0 → ∃ y : Set.Icc 0 1, Function.IsPeriodicPt f n y) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "period_three_implies_chaos",
      "main_prompt": "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.",
      "prompt": "Natural language version: \"If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 13.508300371002406,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem :     ∀ (f : ℝ → ℝ) (a : ℝ),     a ∈ Icc 0 1 → f a = a →     ∀ (n : ℕ), ∃ (b : ℝ), b ∈ Icc 0 1 ∧ (f ^[ 3] b = b) ∧ (f ^[ n] b = b) ",
      "theorem erratum_nth : 1 ≤ n → ∀ x, (f ^[n]).1 x = x → ∃ y, ∃ m : ℕ, n ≤ m ∧ (f ^[m]).1 y = y ",
      "theorem three_implies_all (f : ℝ → ℝ) (hf : ∃ x : ℝ, f (f (f x)) = x) : ∃ n : ℕ, ∃ x : ℝ, n > 0 ∧ f^[n] x = x ",
      "theorem foo (f : ℝ → ℝ) (h : ∃ x ∈ Icc 0 1, f (f (f x)) = x) :   ∃ x ∈ Icc 0 1, ∃ d : ℕ, (d ≠ 1) ∧ ∀ y ∈ Icc 0 1 (f y = y → y = x) ",
      "theorem blue_berry {f : ℕ → ℕ → Prop}      (h : ∀ x, ∀ y, ∃ z, f x z ∧ f z y):      ∀ x, ∀ y, ∃ z, f x z ∧ f z y  3. Write the negation of the proposition.  theorem blue_berry {f : ℕ → ℕ → Prop}      (h : ∀ x, ∀ y, ∃ z, f x z ∧ f z y):      ∀ x, ∀ y, ∃ z, f x z ∧ f z y → False  4. Prove the neg"
    ],
    "answer": "theorem period_three_implies_chaos : ∀ f : Set.Icc 0 1 → Set.Icc 0 1, (∃ x : Set.Icc 0 1, Function.IsPeriodicPt f 3 x) → (∀ n : ℕ, n > 0 → ∃ y : Set.Icc 0 1, Function.IsPeriodicPt f n y) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "terminal_unique_iso",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"A terminal object in a category is unique up to unique isomorphism.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A terminal object in a category is unique up to unique isomorphism.",
      "codex_time": 9.574278379004681,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem category_theory_unique_upto_unique_isomorphism {C : Type u}  [category.{v} C] (T T' : C) : terminal T → @terminal.is_unique C _ T T' _ _ ",
      "theorem terminal_is_unique (C : Type u) [category C] [h : has_terminal C]  {X Y : C} (hX : is_terminal X) (hY : is_terminal Y) :  X ≅ Y ",
      "theorem unique_terminal_up_to_isomorphism {C : Type*} [category.{v} C] : ∀ (T T₀ : C), terminal T → terminal T₀ → T ≅ T₀ ",
      "theorem if_two_terminal_objects_then_they_are_isomorphic   {C : Type*} [category.{v} C] (T T' : C) (ht : is_terminal T) (ht' : is_terminal T') :     T ≅ T' ",
      "theorem terminal_is_unique_up_to_unique_iso (C : Type u) [category.{v} C]  (T₁ T₂ : C) (hT₁ : is_terminal T₁) (hT₂ : is_terminal T₂) :  T₁ ≅ T₂ "
    ],
    "answer": "theorem terminal_unique_iso {C : Type _} [CategoryTheory.Category C] : ∀ T₁ T₂ : C, CategoryTheory.Limits.IsTerminal T₁ → CategoryTheory.Limits.IsTerminal T₂ → (∃ ι : CategoryTheory.Iso T₁ T₂, ∀ ι' : CategoryTheory.Iso T₁ T₂, ι = ι') "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "terminal_unique_iso",
      "main_prompt": "A terminal object in a category is unique up to unique isomorphism.",
      "prompt": "Natural language version: \" We can more explicitly show that a category has a terminal object by specifying the object, and showing there is a unique morphism to it from any other object.\" Translate the natural language version to a Lean mathlib version:\n theorem category_theory.limits.has_terminal_of_unique{C : Type u₁} [category_theory.category C] (X : C) [h : Π (Y : C), unique (Y ⟶ X)] :\ncategory_theory.limits.has_terminal C := \n\nNatural language version: \"Any two morphisms to a terminal object are equal.\" Translate the natural language version to a Lean mathlib version:\n theorem category_theory.limits.is_terminal.hom_ext{C : Type u₁} [category_theory.category C] {X Y : C} (t : category_theory.limits.is_terminal X) (f g : Y ⟶ X) :\nf = g := \n\nNatural language version: \"If the unique morphism from `A` to a terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_is_terminal_from`.\" Translate the natural language version to a Lean mathlib version:\n theorem category_theory.is_subterminal_of_mono_is_terminal_from{C : Type u₁} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)] :\ncategory_theory.is_subterminal A := \n\nNatural language version: \"If there are zero morphisms, any terminal object is a zero object.\" Translate the natural language version to a Lean mathlib version:\n theorem category_theory.limits.has_zero_object_of_has_terminal_object{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C] :\ncategory_theory.limits.has_zero_object C := \n\nNatural language version: \"A terminal object in a category is unique up to unique isomorphism.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.8502864837646484,
          "doc_string": " We can more explicitly show that a category has a terminal object by specifying the object, and showing there is a unique morphism to it from any other object.",
          "statement": "theorem category_theory.limits.has_terminal_of_unique {C : Type u₁} [category_theory.category C] (X : C) [h : Π (Y : C), unique (Y ⟶ X)] : category_theory.limits.has_terminal C"
        },
        {
          "sim_score": 0.8256147503852844,
          "doc_string": "Any two morphisms to a terminal object are equal.",
          "statement": "theorem category_theory.limits.is_terminal.hom_ext {C : Type u₁} [category_theory.category C] {X Y : C} (t : category_theory.limits.is_terminal X) (f g : Y ⟶ X) : f = g"
        },
        {
          "sim_score": 0.6706336140632629,
          "doc_string": "If the unique morphism from `A` to a terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_is_terminal_from`.",
          "statement": "theorem category_theory.is_subterminal_of_mono_is_terminal_from {C : Type u₁} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)] : category_theory.is_subterminal A"
        },
        {
          "sim_score": 0.6649926900863647,
          "doc_string": "If there are zero morphisms, any terminal object is a zero object.",
          "statement": "theorem category_theory.limits.has_zero_object_of_has_terminal_object {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C] : category_theory.limits.has_zero_object C"
        }
      ],
      "codex_time": 12.061553191015264,
      "search_time": 1.4388788799988106,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem category_theory.limits.unique_terminal_equiv{C : Type u₁} [CategoryTheory.Category C] : Unique (CategoryTheory.Limits.HasTerminal C) ",
      "theorem category_theory.limits.terminal_up_to_isomorphism{C : Type*} [CategoryTheory.Category C] [t₁ : CategoryTheory.Limits.HasTerminal C] [t₂ : CategoryTheory.Limits.HasTerminal C] : CategoryTheory.IsIso (t₁.terminal.from t₂.terminal) ",
      "theorem category_theory.limits.terminal_is_iso_zero_object{C : Type u} [CategoryTheory.Category C] {T : C} [CategoryTheory.Limits.HasTerminal C] [CategoryTheory.Limits.HasZeroObject C] : Nonempty (T ≅ (0 : C)) ",
      "theorem category_theory.uniqueness_of_terminal_up_to_iso{C : Type u₁} [CategoryTheory.Category C] {T₁ T₂ : C} [CategoryTheory.Limits.IsTerminal T₁] [CategoryTheory.Limits.IsTerminal T₂] : ∃ (f : T₁ ⟶ T₂), ∀ (g : T₁ ⟶ T₂), CategoryTheory.Mono g → f = g ",
      "theorem category_theory.limits.is_terminal_unique {C : Type u} [CategoryTheory.Category C] (T T' : C) : CategoryTheory.Limits.IsTerminal T → CategoryTheory.Limits.IsTerminal T' → T ≅ T' "
    ],
    "answer": "theorem terminal_unique_iso {C : Type _} [CategoryTheory.Category C] : ∀ T₁ T₂ : C, CategoryTheory.Limits.IsTerminal T₁ → CategoryTheory.Limits.IsTerminal T₂ → (∃ ι : CategoryTheory.Iso T₁ T₂, ∀ ι' : CategoryTheory.Iso T₁ T₂, ι = ι') "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "terminal_unique_iso",
      "main_prompt": "A terminal object in a category is unique up to unique isomorphism.",
      "prompt": "Natural language version: \"A terminal object in a category is unique up to unique isomorphism.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 10.971891207998851,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem terminal_is_unique {C : Type u}   [category.{ v } C]   (t₁ t₂ : overt (over (terminal) C))   (w₁ : t₁ ⟶ terminal C)   (w₂ : t₂ ⟶ terminal C)   : unique_isomorphism(w₁ ≫ overt.rec_iso t₁, w₂ ≫ overt.rec_iso t₂).   Is there still a problem?  }  lemma embedding_unicity   {C : Type u} [category.",
      "theorem terminal_prop { X : Type } [ terminal : category.{ u v }.{ v } X ] : ∃! x : X , True     ",
      "theorem terminal_unique (C : Type*) [𝒞 : category.{v} C] [terminal.{v} C] (T : C) [terminal_object.{v} T] :   T ≅ terminal.{v} C ",
      "theorem unique_terminal_object (C : Type) [category C] :      Unique (terminal_object C)   ",
      "theorem terminal_object_is_unique_up_to_unique_isomorphism {C : Type u} [category.{v} C] (T₁ T₂ : C) (HT₁ : is_terminal T₁)   (HT₂ : is_terminal T₂) : {f : T₁ ⟶ T₂ // ∀ g : T₁ ⟶ T₂, f ≫ HT₂.uniq g = HT₁.uniq g} "
    ],
    "answer": "theorem terminal_unique_iso {C : Type _} [CategoryTheory.Category C] : ∀ T₁ T₂ : C, CategoryTheory.Limits.IsTerminal T₁ → CategoryTheory.Limits.IsTerminal T₂ → (∃ ι : CategoryTheory.Iso T₁ T₂, ∀ ι' : CategoryTheory.Iso T₁ T₂, ι = ι') "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "torsion_in_fg_group_implies_finite",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"A finitely-presented group containing a torsion element is finite.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A finitely-presented group containing a torsion element is finite.",
      "codex_time": 7.901811512972927,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem finite_group_contains_torsion_element (G : Type*)  [Fintype G] [Group G] (n : ℕ) (m : G) (h_m : m ^ n = 1):  card G < ⊤ ",
      "theorem finite_group_contains_torsion_element (G : Type*)  [Fintype G] [Groupₓₓ G] (n : ℕ) (m : G) (h_m : m ^ n = 1):  card G < ⊤ ",
      "theorem finite_group_contains_torsion_element (G : Type*)  [Fintype G] [Groupₓ G] (n : ℕ) (m : G) (h_m : m ^ n = 1):  card G < ⊤ ",
      "theorem finite_group_contains_torsion_element (G : Type*)  [Fintypeₓ G] [Group G] (n : ℕ) (m : G) (h_m : m ^ n = 1):  card G < ⊤ ",
      "theorem finite_group_contains_torsion_element (G : Type*)  [Fintypeₓ G] [Groupₓₓ G] (n : ℕ) (m : G) (h_m : m ^ n = 1):  card G < ⊤ ",
      "theorem finite_group_contains_torsion_element (G : Type*)  [Fintypeₓ G] [Groupₓ G] (n : ℕ) (m : G) (h_m : m ^ n = 1):  card G < ⊤ ",
      "theorem torsion_implies_finite (G : Type*) [Group G] [Fintype G] [is_finite_group G] :  ∃ x : G, ∃ n : ℕ, (x ^ n = 1) ∧ (IsNoetherian Int G) ",
      "theorem torsion_implies_finite (G : Type*) [Groupₓₓ G] [Fintype G] [is_finite_group G] :  ∃ x : G, ∃ n : ℕ, (x ^ n = 1) ∧ (IsNoetherian Int G) ",
      "theorem torsion_implies_finite (G : Type*) [Groupₓ G] [Fintype G] [is_finite_group G] :  ∃ x : G, ∃ n : ℕ, (x ^ n = 1) ∧ (IsNoetherian Int G) ",
      "theorem torsion_implies_finite (G : Type*) [Group G] [Fintypeₓ G] [is_finite_group G] :  ∃ x : G, ∃ n : ℕ, (x ^ n = 1) ∧ (IsNoetherian Int G) ",
      "theorem torsion_implies_finite (G : Type*) [Groupₓₓ G] [Fintypeₓ G] [is_finite_group G] :  ∃ x : G, ∃ n : ℕ, (x ^ n = 1) ∧ (IsNoetherian Int G) ",
      "theorem torsion_implies_finite (G : Type*) [Groupₓ G] [Fintypeₓ G] [is_finite_group G] :  ∃ x : G, ∃ n : ℕ, (x ^ n = 1) ∧ (IsNoetherian Int G) ",
      "theorem finite_presented_group_with_torsion_element_is_finite (R : Type*) [CommRing R] (g : FreeGroup R)  (f : FreeGroup R →* R →+* ℤ) (Nontrivial : ∃ r : R, r ≠ 0 ∧ f.to_fun (f.ker.lift r) = 0) :  Fintype R ",
      "theorem finite_presented_group_with_torsion_element_is_finite (R : Type*) [CommRingₓₓ R] (g : FreeGroup R)  (f : FreeGroup R →* R →+* ℤ) (Nontrivial : ∃ r : R, r ≠ 0 ∧ f.to_fun (f.ker.lift r) = 0) :  Fintype R ",
      "theorem finite_presented_group_with_torsion_element_is_finite (R : Type*) [CommRingₓ R] (g : FreeGroup R)  (f : FreeGroup R →* R →+* ℤ) (Nontrivial : ∃ r : R, r ≠ 0 ∧ f.to_fun (f.ker.lift r) = 0) :  Fintype R ",
      "theorem finite_presented_group_with_torsion_element_is_finite (R : Type*) [CommRing R] (g : FreeGroup R)  (f : FreeGroup R →* R →+* ℤ) (Nontrivial : ∃ r : R, r ≠ 0 ∧ f.to_fun (f.ker.lift r) = 0) :  Fintypeₓ R ",
      "theorem finite_presented_group_with_torsion_element_is_finite (R : Type*) [CommRingₓₓ R] (g : FreeGroup R)  (f : FreeGroup R →* R →+* ℤ) (Nontrivial : ∃ r : R, r ≠ 0 ∧ f.to_fun (f.ker.lift r) = 0) :  Fintypeₓ R ",
      "theorem finite_presented_group_with_torsion_element_is_finite (R : Type*) [CommRingₓ R] (g : FreeGroup R)  (f : FreeGroup R →* R →+* ℤ) (Nontrivial : ∃ r : R, r ≠ 0 ∧ f.to_fun (f.ker.lift r) = 0) :  Fintypeₓ R ",
      "theorem fp_group_has_torsion_implies_finite (G : Type*) [Group G]  (c : fin_chain_GP G) :  ∀ g, ∃ n g' : ℕ, c.fintype.mem_terminal n g' ∧  c.fintype.stable_under_helper n g' g ",
      "theorem fp_group_has_torsion_implies_finite (G : Type*) [Groupₓₓ G]  (c : fin_chain_GP G) :  ∀ g, ∃ n g' : ℕ, c.fintype.mem_terminal n g' ∧  c.fintype.stable_under_helper n g' g ",
      "theorem fp_group_has_torsion_implies_finite (G : Type*) [Groupₓ G]  (c : fin_chain_GP G) :  ∀ g, ∃ n g' : ℕ, c.fintype.mem_terminal n g' ∧  c.fintype.stable_under_helper n g' g ",
      "theorem finite_subgroup_of_torsion (G : Type*) [Group G] [Fintype G] [Fintype (units G)]  (x : G) (htorsion : ∀ n : ℕ, (x ^ n) ∈ Finset.univ) :  finset.card G < ∞ ",
      "theorem finite_subgroup_of_torsion (G : Type*) [Groupₓₓ G] [Fintype G] [Fintype (units G)]  (x : G) (htorsion : ∀ n : ℕ, (x ^ n) ∈ Finset.univ) :  finset.card G < ∞ ",
      "theorem finite_subgroup_of_torsion (G : Type*) [Groupₓ G] [Fintype G] [Fintype (units G)]  (x : G) (htorsion : ∀ n : ℕ, (x ^ n) ∈ Finset.univ) :  finset.card G < ∞ ",
      "theorem finite_subgroup_of_torsion (G : Type*) [Group G] [Fintypeₓ G] [Fintypeₓ (units G)]  (x : G) (htorsion : ∀ n : ℕ, (x ^ n) ∈ Finset.univ) :  finset.card G < ∞ ",
      "theorem finite_subgroup_of_torsion (G : Type*) [Groupₓₓ G] [Fintypeₓ G] [Fintypeₓ (units G)]  (x : G) (htorsion : ∀ n : ℕ, (x ^ n) ∈ Finset.univ) :  finset.card G < ∞ ",
      "theorem finite_subgroup_of_torsion (G : Type*) [Groupₓ G] [Fintypeₓ G] [Fintypeₓ (units G)]  (x : G) (htorsion : ∀ n : ℕ, (x ^ n) ∈ Finset.univ) :  finset.card G < ∞ "
    ],
    "answer": "theorem torsion_in_fg_group_implies_finite {G : Type _} [Groupₓ G] : Groupₓ.Fg G → Finite G "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "torsion_in_fg_group_implies_finite",
      "main_prompt": "A finitely-presented group containing a torsion element is finite.",
      "prompt": "Natural language version: \"Finite groups are torsion groups.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_of_fintype{G : Type u_1} [group G] [fintype G] :\nmonoid.is_torsion G := \n\nNatural language version: \"Subgroups of torsion groups are torsion groups.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion.subgroup{G : Type u_1} [group G] (tG : monoid.is_torsion G) (H : subgroup G) :\nmonoid.is_torsion ↥H := \n\nNatural language version: \"Finite additive groups are additive torsion groups.\" Translate the natural language version to a Lean mathlib version:\n theorem is_add_torsion_of_fintype{G : Type u_1} [add_group G] [fintype G] :\nadd_monoid.is_torsion G := \n\nNatural language version: \"A nontrivial torsion group is not torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion.not_torsion_free{G : Type u_1} [group G] [hN : nontrivial G] :\nmonoid.is_torsion G → ¬monoid.is_torsion_free G := \n\nNatural language version: \"A finitely-presented group containing a torsion element is finite.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.7566978335380554,
          "doc_string": "Finite groups are torsion groups.",
          "statement": "theorem is_torsion_of_fintype {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G"
        },
        {
          "sim_score": 0.6571311950683594,
          "doc_string": "Subgroups of torsion groups are torsion groups.",
          "statement": "theorem is_torsion.subgroup {G : Type u_1} [group G] (tG : monoid.is_torsion G) (H : subgroup G) : monoid.is_torsion ↥H"
        },
        {
          "sim_score": 0.6486772298812866,
          "doc_string": "Finite additive groups are additive torsion groups.",
          "statement": "theorem is_add_torsion_of_fintype {G : Type u_1} [add_group G] [fintype G] : add_monoid.is_torsion G"
        },
        {
          "sim_score": 0.6356827020645142,
          "doc_string": "A nontrivial torsion group is not torsion-free.",
          "statement": "theorem is_torsion.not_torsion_free {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G → ¬monoid.is_torsion_free G"
        }
      ],
      "codex_time": 9.398841628979426,
      "search_time": 1.6795614779985044,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem is_torsion.finset.fintype_of_fp{G : Type u_1} [Group G] [fp_group G] (U : G) (H : Monoidₓ.IsTorsion G U) : Fintype G ",
      "theorem is_torsion.finset.fintype_of_fp{G : Type u_1} [Groupₓₓ G] [fp_group G] (U : G) (H : Monoidₓ.IsTorsion G U) : Fintype G ",
      "theorem is_torsion.finset.fintype_of_fp{G : Type u_1} [Groupₓ G] [fp_group G] (U : G) (H : Monoidₓ.IsTorsion G U) : Fintype G ",
      "theorem is_torsion.finset.fintype_of_fp{G : Type u_1} [Group G] [fp_group G] (U : G) (H : Monoidₓ.IsTorsion G U) : Fintypeₓ G ",
      "theorem is_torsion.finset.fintype_of_fp{G : Type u_1} [Groupₓₓ G] [fp_group G] (U : G) (H : Monoidₓ.IsTorsion G U) : Fintypeₓ G ",
      "theorem is_torsion.finset.fintype_of_fp{G : Type u_1} [Groupₓ G] [fp_group G] (U : G) (H : Monoidₓ.IsTorsion G U) : Fintypeₓ G ",
      "theorem fg_is_finite_of_torsion{G : Type u_1} [Group G]   (hG : Fintype G)   (g : ∃ x : G, x ≠ 1) : ∃ p : ℕ, G ≃ finset.univ.card = p ",
      "theorem fg_is_finite_of_torsion{G : Type u_1} [Groupₓₓ G]   (hG : Fintype G)   (g : ∃ x : G, x ≠ 1) : ∃ p : ℕ, G ≃ finset.univ.card = p ",
      "theorem fg_is_finite_of_torsion{G : Type u_1} [Groupₓ G]   (hG : Fintype G)   (g : ∃ x : G, x ≠ 1) : ∃ p : ℕ, G ≃ finset.univ.card = p ",
      "theorem fg_is_finite_of_torsion{G : Type u_1} [Group G]   (hG : Fintypeₓ G)   (g : ∃ x : G, x ≠ 1) : ∃ p : ℕ, G ≃ finset.univ.card = p ",
      "theorem fg_is_finite_of_torsion{G : Type u_1} [Groupₓₓ G]   (hG : Fintypeₓ G)   (g : ∃ x : G, x ≠ 1) : ∃ p : ℕ, G ≃ finset.univ.card = p ",
      "theorem fg_is_finite_of_torsion{G : Type u_1} [Groupₓ G]   (hG : Fintypeₓ G)   (g : ∃ x : G, x ≠ 1) : ∃ p : ℕ, G ≃ finset.univ.card = p ",
      "theorem is_torsion.finset{G : Type u} [Group G] [hNG : Nontrivial G] [is_fin_pres G] : ∃ x : G, Monoidₓ.IsTorsion (finset.singleton x) ",
      "theorem is_torsion.finset{G : Type u} [Groupₓₓ G] [hNG : Nontrivial G] [is_fin_pres G] : ∃ x : G, Monoidₓ.IsTorsion (finset.singleton x) ",
      "theorem is_torsion.finset{G : Type u} [Groupₓ G] [hNG : Nontrivial G] [is_fin_pres G] : ∃ x : G, Monoidₓ.IsTorsion (finset.singleton x) ",
      "theorem finitely_presented.is_finite_of_torsion{G : Type u_1} [Group G] [Fintype G] (hG : finitely_presented G) :  ∃ n : ℕ, ∀ g : G, (monoid.has_pow g n) = 1 ",
      "theorem finitely_presented.is_finite_of_torsion{G : Type u_1} [Groupₓₓ G] [Fintype G] (hG : finitely_presented G) :  ∃ n : ℕ, ∀ g : G, (monoid.has_pow g n) = 1 ",
      "theorem finitely_presented.is_finite_of_torsion{G : Type u_1} [Groupₓ G] [Fintype G] (hG : finitely_presented G) :  ∃ n : ℕ, ∀ g : G, (monoid.has_pow g n) = 1 ",
      "theorem finitely_presented.is_finite_of_torsion{G : Type u_1} [Group G] [Fintypeₓ G] (hG : finitely_presented G) :  ∃ n : ℕ, ∀ g : G, (monoid.has_pow g n) = 1 ",
      "theorem finitely_presented.is_finite_of_torsion{G : Type u_1} [Groupₓₓ G] [Fintypeₓ G] (hG : finitely_presented G) :  ∃ n : ℕ, ∀ g : G, (monoid.has_pow g n) = 1 ",
      "theorem finitely_presented.is_finite_of_torsion{G : Type u_1} [Groupₓ G] [Fintypeₓ G] (hG : finitely_presented G) :  ∃ n : ℕ, ∀ g : G, (monoid.has_pow g n) = 1 ",
      "theorem is_torsion.fp_fintype(G : Type u_3) [Group G] [fp_group G] (a : G) : ∃ n : ℕ, ∀ n : ℕ, n • a = 1 → n = 0 → False → False ",
      "theorem is_torsion.fp_fintype(G : Type u_3) [Groupₓₓ G] [fp_group G] (a : G) : ∃ n : ℕ, ∀ n : ℕ, n • a = 1 → n = 0 → False → False ",
      "theorem is_torsion.fp_fintype(G : Type u_3) [Groupₓ G] [fp_group G] (a : G) : ∃ n : ℕ, ∀ n : ℕ, n • a = 1 → n = 0 → False → False "
    ],
    "answer": "theorem torsion_in_fg_group_implies_finite {G : Type _} [Groupₓ G] : Groupₓ.Fg G → Finite G "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "torsion_in_fg_group_implies_finite",
      "main_prompt": "A finitely-presented group containing a torsion element is finite.",
      "prompt": "Natural language version: \"A finitely-presented group containing a torsion element is finite.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 7.57651069900021,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem exists_torsion_implies_finite : ∀ G : multiplicative (FreeGroup α) ,   ∃ g : FreeGroup β∈ G , finite_order g → Finite (quotient_group G)  ",
      "theorem foo (G : Type) [Group G] (H : Finset G) (h : ∀ (g ∈ H), ∀ (h ∈ H), g * h = 1) (t : ∃ (g ∈ H), g ≠ 1) :   False . Define foo and prove it in mathlib. In the process, you must create new lemmas as needed.  (Update: we have now proved it in mathlib. But you can practice by trying to prove it again, without looking at the code. Or glance at the code, and try to emulate the naming/formatting.) */  theorem fin_gp_of_t",
      "theorem foo (G : Type) [Groupₓₓ G] (H : Finset G) (h : ∀ (g ∈ H), ∀ (h ∈ H), g * h = 1) (t : ∃ (g ∈ H), g ≠ 1) :   False . Define foo and prove it in mathlib. In the process, you must create new lemmas as needed.  (Update: we have now proved it in mathlib. But you can practice by trying to prove it again, without looking at the code. Or glance at the code, and try to emulate the naming/formatting.) */  theorem fin_gp_of_t",
      "theorem foo (G : Type) [Groupₓ G] (H : Finset G) (h : ∀ (g ∈ H), ∀ (h ∈ H), g * h = 1) (t : ∃ (g ∈ H), g ≠ 1) :   False . Define foo and prove it in mathlib. In the process, you must create new lemmas as needed.  (Update: we have now proved it in mathlib. But you can practice by trying to prove it again, without looking at the code. Or glance at the code, and try to emulate the naming/formatting.) */  theorem fin_gp_of_t",
      "theorem finite_group_implies_finite_order_elements : function.equiv (finite_group α) (∀ a, orderOf a < ⊤) ",
      "theorem Q3 : ∃ (G : Type) [Group G] [Fintype G], ∃ g : G, order g ≠ 1 ",
      "theorem Q3 : ∃ (G : Type) [Groupₓₓ G] [Fintype G], ∃ g : G, order g ≠ 1 ",
      "theorem Q3 : ∃ (G : Type) [Groupₓ G] [Fintype G], ∃ g : G, order g ≠ 1 ",
      "theorem Q3 : ∃ (G : Type) [Group G] [Fintypeₓ G], ∃ g : G, order g ≠ 1 ",
      "theorem Q3 : ∃ (G : Type) [Groupₓₓ G] [Fintypeₓ G], ∃ g : G, order g ≠ 1 ",
      "theorem Q3 : ∃ (G : Type) [Groupₓ G] [Fintypeₓ G], ∃ g : G, order g ≠ 1 ",
      "theorem finitely_presented_group_a_torsion_element_is_finite (k : Type*) [CommRing k] [Fintype k] [Field k] [Fintype (units k)]    [finitely_presented_group (add_comm_group_with_zero (units k))) (a : (units k)).          theorem finitely_presented_group_a_torsion_element_is_finite (k : Type*) [CommRing k] [Fintype k] [Field k] [Fintype (units k)]    [finitely_presented_group (add_comm_",
      "theorem finitely_presented_group_a_torsion_element_is_finite (k : Type*) [CommRingₓₓ k] [Fintype k] [Field k] [Fintype (units k)]    [finitely_presented_group (add_comm_group_with_zero (units k))) (a : (units k)).          theorem finitely_presented_group_a_torsion_element_is_finite (k : Type*) [CommRingₓₓ k] [Fintype k] [Field k] [Fintype (units k)]    [finitely_presented_group (add_comm_",
      "theorem finitely_presented_group_a_torsion_element_is_finite (k : Type*) [CommRingₓ k] [Fintype k] [Field k] [Fintype (units k)]    [finitely_presented_group (add_comm_group_with_zero (units k))) (a : (units k)).          theorem finitely_presented_group_a_torsion_element_is_finite (k : Type*) [CommRingₓ k] [Fintype k] [Field k] [Fintype (units k)]    [finitely_presented_group (add_comm_",
      "theorem finitely_presented_group_a_torsion_element_is_finite (k : Type*) [CommRing k] [Fintypeₓ k] [Field k] [Fintypeₓ (units k)]    [finitely_presented_group (add_comm_group_with_zero (units k))) (a : (units k)).          theorem finitely_presented_group_a_torsion_element_is_finite (k : Type*) [CommRing k] [Fintypeₓ k] [Field k] [Fintypeₓ (units k)]    [finitely_presented_group (add_comm_",
      "theorem finitely_presented_group_a_torsion_element_is_finite (k : Type*) [CommRingₓₓ k] [Fintypeₓ k] [Field k] [Fintypeₓ (units k)]    [finitely_presented_group (add_comm_group_with_zero (units k))) (a : (units k)).          theorem finitely_presented_group_a_torsion_element_is_finite (k : Type*) [CommRingₓₓ k] [Fintypeₓ k] [Field k] [Fintypeₓ (units k)]    [finitely_presented_group (add_comm_",
      "theorem finitely_presented_group_a_torsion_element_is_finite (k : Type*) [CommRingₓ k] [Fintypeₓ k] [Field k] [Fintypeₓ (units k)]    [finitely_presented_group (add_comm_group_with_zero (units k))) (a : (units k)).          theorem finitely_presented_group_a_torsion_element_is_finite (k : Type*) [CommRingₓ k] [Fintypeₓ k] [Field k] [Fintypeₓ (units k)]    [finitely_presented_group (add_comm_"
    ],
    "answer": "theorem torsion_in_fg_group_implies_finite {G : Type _} [Groupₓ G] : Groupₓ.Fg G → Finite G "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "compl_union",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"The complement of the union of two sets is the intersection of their complements.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The complement of the union of two sets is the intersection of their complements.",
      "codex_time": 12.295254955999553,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem set.compl_union_compl' (X : Type*) [DecidableEq X]: ∀ A B : Set X,  X \\ (A ∪ B) = X \\ A ∩ X \\ B ",
      "theorem set.compl_union_compl' (X : Type*) [DecidableEq X]: ∀ A B : Setₓ X,  X \\ (A ∪ B) = X \\ A ∩ X \\ B ",
      "theorem compl_union_compl_inter : ∀ (A B : Set X), -(A ∪ B) = -A ∩ -B ",
      "theorem compl_union_compl_inter : ∀ (A B : Setₓ X), -(A ∪ B) = -A ∩ -B ",
      "theorem preimage_sInter_of_preimage_of_sUnion_eq_sUnion_of_preimage   (α : Type u) (β : Type v) [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace (α × β)]   (s : Set (α × β)) (t : Set β) :  sInter (t.comap $ λp:s, p.snd) ↑s =  ↑sUnion (t.map $ λp:s, p.snd) ",
      "theorem preimage_sInter_of_preimage_of_sUnion_eq_sUnion_of_preimage   (α : Type u) (β : Type v) [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace (α × β)]   (s : Setₓ (α × β)) (t : Setₓ β) :  sInter (t.comap $ λp:s, p.snd) ↑s =  ↑sUnion (t.map $ λp:s, p.snd) ",
      "theorem complement_of_union_eq_intersection_of_complements (X : Type*) [TopologicalSpace X]  (A B : Set X) : (- A ∪ B)^c = (-A)^c ⊓ (-B)^c ",
      "theorem complement_of_union_eq_intersection_of_complements (X : Type*) [TopologicalSpace X]  (A B : Setₓ X) : (- A ∪ B)^c = (-A)^c ⊓ (-B)^c ",
      "theorem complement_union_eq_intersection_complement (X : Type*) (A B : Set X) : set.compl A ∪ set.compl B = (A ∩ B)ᶜ ",
      "theorem complement_union_eq_intersection_complement (X : Type*) (A B : Setₓ X) : set.compl A ∪ set.compl B = (A ∩ B)ᶜ "
    ],
    "answer": "theorem compl_union {α : Type _} (S T : Set α) : (S ∪ T).compl = S.compl ∩ T.compl "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "compl_union",
      "main_prompt": "The complement of the union of two sets is the intersection of their complements.",
      "prompt": "Natural language version: \"The complement of a set has the same frontier as the original set.\" Translate the natural language version to a Lean mathlib version:\n theorem frontier_compl{α : Type u} [topological_space α] (s : set α) :\nfrontier sᶜ = frontier s := \n\nNatural language version: \"The union of two sets is bounded above if and only if each of the sets is.\" Translate the natural language version to a Lean mathlib version:\n theorem bdd_below_union{γ : Type w} [semilattice_inf γ] {s t : set γ} :\nbdd_below (s ∪ t) ↔ bdd_below s ∧ bdd_below t := \n\nNatural language version: \"The union of two sets is bounded above if and only if each of the sets is.\" Translate the natural language version to a Lean mathlib version:\n theorem bdd_above_union{γ : Type w} [semilattice_sup γ] {s t : set γ} :\nbdd_above (s ∪ t) ↔ bdd_above s ∧ bdd_above t := \n\nNatural language version: \" The cardinality of a union is at most the sum of the cardinalities of the two sets.\" Translate the natural language version to a Lean mathlib version:\n theorem cardinal.mk_union_le{α : Type u} (S T : set α) :\ncardinal.mk ↥(S ∪ T) ≤ cardinal.mk ↥S + cardinal.mk ↥T := \n\nNatural language version: \"The complement of the union of two sets is the intersection of their complements.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6778950691223145,
          "doc_string": "The complement of a set has the same frontier as the original set.",
          "statement": "theorem frontier_compl {α : Type u} [topological_space α] (s : set α) : frontier sᶜ = frontier s"
        },
        {
          "sim_score": 0.6120935678482056,
          "doc_string": "The union of two sets is bounded above if and only if each of the sets is.",
          "statement": "theorem bdd_below_union {γ : Type w} [semilattice_inf γ] {s t : set γ} : bdd_below (s ∪ t) ↔ bdd_below s ∧ bdd_below t"
        },
        {
          "sim_score": 0.6120935678482056,
          "doc_string": "The union of two sets is bounded above if and only if each of the sets is.",
          "statement": "theorem bdd_above_union {γ : Type w} [semilattice_sup γ] {s t : set γ} : bdd_above (s ∪ t) ↔ bdd_above s ∧ bdd_above t"
        },
        {
          "sim_score": 0.6097555160522461,
          "doc_string": " The cardinality of a union is at most the sum of the cardinalities of the two sets.",
          "statement": "theorem cardinal.mk_union_le {α : Type u} (S T : set α) : cardinal.mk ↥(S ∪ T) ≤ cardinal.mk ↥S + cardinal.mk ↥T"
        }
      ],
      "codex_time": 6.262508013984188,
      "search_time": 1.466880152001977,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem compl_union{α : Type u} {s t : Set α} : sᶜ ∪ tᶜ = (s ∩ t)ᶜ ",
      "theorem compl_union{α : Type u} {s t : Setₓ α} : sᶜ ∪ tᶜ = (s ∩ t)ᶜ ",
      "theorem compl_union{α : Type u} (s₁ s₂ : Set α) : (s₁ ∪ s₂)ᶜ = (s₁ᶜ) ∩ (s₂ᶜ) ",
      "theorem compl_union{α : Type u} (s₁ s₂ : Setₓ α) : (s₁ ∪ s₂)ᶜ = (s₁ᶜ) ∩ (s₂ᶜ) ",
      "theorem compl_union{α : Type u} {s t : Set α} : (- s ∪ - t)ᶜ = - (s ∩ t) ",
      "theorem compl_union{α : Type u} {s t : Setₓ α} : (- s ∪ - t)ᶜ = - (s ∩ t) ",
      "theorem compl_union{α : Type u} (S T : Set α) : (S ∪ T)ᶜ = Sᶜ ∩ Tᶜ ",
      "theorem compl_union{α : Type u} (S T : Setₓ α) : (S ∪ T)ᶜ = Sᶜ ∩ Tᶜ ",
      "theorem compl_union{α : Type u} {S T : Set α} : (S ∪ T)ᶜ = Sᶜ ∩ Tᶜ ",
      "theorem compl_union{α : Type u} {S T : Setₓ α} : (S ∪ T)ᶜ = Sᶜ ∩ Tᶜ "
    ],
    "answer": "theorem compl_union {α : Type _} (S T : Set α) : (S ∪ T).compl = S.compl ∩ T.compl "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "compl_union",
      "main_prompt": "The complement of the union of two sets is the intersection of their complements.",
      "prompt": "Natural language version: \"The complement of the union of two sets is the intersection of their complements.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 11.641492582013598,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem Complement_union_complement_intersection (A B : Set T) :     (-(A ∪ B)) = (-A) ∩ (-B) ",
      "theorem Complement_union_complement_intersection (A B : Setₓ T) :     (-(A ∪ B)) = (-A) ∩ (-B) ",
      "theorem ‹the complement of the union of two sets is the intersection of their complements› :     ∀ (A B : Set α),         -(A ∪ B) = (-A ∩ -B)   ` -/ example   end xena -- hide   /- Hint: You can use union.comm, inter.comm, compl_union, inter_compl -/  universe u   /-- Lesson 1: α and β are the types -/ def set_private (α β : Type u) ",
      "theorem ‹the complement of the union of two sets is the intersection of their complements› :     ∀ (A B : Setₓ α),         -(A ∪ B) = (-A ∩ -B)   ` -/ example   end xena -- hide   /- Hint: You can use union.comm, inter.comm, compl_union, inter_compl -/  universe u   /-- Lesson 1: α and β are the types -/ def set_private (α β : Type u) ",
      "theorem DeMorgan_diff2 : ( (∪ a:S, b : T, f a b) )' = (∩ a : S , (∩ b : T, (f a b)') ) ",
      "theorem DeMorgan2 (e1 e2 : Set α) : -(e1 ∪ e2) = (-e1 ∩ -e2) ",
      "theorem DeMorgan2 (e1 e2 : Setₓ α) : -(e1 ∪ e2) = (-e1 ∩ -e2) ",
      "theorem art_comp_u_comp_is_comp_u (a b : Set ℤ) : - (a ∪ b) = - a ∩ - b ",
      "theorem art_comp_u_comp_is_comp_u (a b : Setₓ ℤ) : - (a ∪ b) = - a ∩ - b "
    ],
    "answer": "theorem compl_union {α : Type _} (S T : Set α) : (S ∪ T).compl = S.compl ∩ T.compl "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "flt_3",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"The sum of the cubes of two positive integers is never equal to the cube of a third integer.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The sum of the cubes of two positive integers is never equal to the cube of a third integer.",
      "codex_time": 9.350611811009003,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem impossible_sum_of_two_cubes : ∀ a b, ¬ (a^3 + b^3 = 0) ",
      "theorem not_square_sum_cube_eq (m n : ℕ) (hmn : m > 0 ∧ n > 0) :  ∃ p : ℕ, (p^3 ≠ m^3 + n^3) ",
      "theorem sum_cubes_of_two_nonzero_integers_never_eq_cube_of_another (a b c : ℤ)  (ha : a ≠ 0) (hb : b ≠ 0) (hc : c ≠ 0) (habc : a ^ 3 + b ^ 3 = c ^ 3) : False ",
      "theorem sum_of_cubes_not_equal_cube (a b c : ℤ) (hcab : c ^ 3 = a ^ 3 + b ^ 3)  (hc : c > 0) (ha : a > 0) (hb : b > 0) : False ",
      "theorem sum_of_cubes_is_not_cube (n m k : ℤ) (hn : 0 < n) (hm : 0 < m) :  k ^ 3 ≠ n ^ 3 + m ^ 3 "
    ],
    "answer": "theorem flt_3 : ∀ a b c : ℕ, a > 0 → b > 0 → ¬(a^3 + b^3 = c^3) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "flt_3",
      "main_prompt": "The sum of the cubes of two positive integers is never equal to the cube of a third integer.",
      "prompt": "Natural language version: \"The zeroth Pythagorean triple is all zeros.\" Translate the natural language version to a Lean mathlib version:\n theorem pythagorean_triple.zero :\npythagorean_triple 0 0 0 := \n\nNatural language version: \"The sum of two squares is zero iff both elements are zero.\" Translate the natural language version to a Lean mathlib version:\n theorem mul_self_add_mul_self_eq_zero{α : Type u} [linear_ordered_ring α] {x y : α} :\nx * x + y * y = 0 ↔ x = 0 ∧ y = 0 := \n\nNatural language version: \" **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.prime.sq_add_sq{p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) :\n∃ (a b : ℕ), a ^ 2 + b ^ 2 = p := \n\nNatural language version: \" Pythagorean triples are interchangable, i.e `x * x + y * y = y * y + x * x = z * z`. This comes from additive commutativity.\" Translate the natural language version to a Lean mathlib version:\n theorem pythagorean_triple_comm{x y z : ℤ} :\npythagorean_triple x y z ↔ pythagorean_triple y x z := \n\nNatural language version: \"The sum of the cubes of two positive integers is never equal to the cube of a third integer.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5193248391151428,
          "doc_string": "The zeroth Pythagorean triple is all zeros.",
          "statement": "theorem pythagorean_triple.zero  : pythagorean_triple 0 0 0"
        },
        {
          "sim_score": 0.4774671792984009,
          "doc_string": "The sum of two squares is zero iff both elements are zero.",
          "statement": "theorem mul_self_add_mul_self_eq_zero {α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0"
        },
        {
          "sim_score": 0.4648144245147705,
          "doc_string": " **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**.",
          "statement": "theorem nat.prime.sq_add_sq {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p"
        },
        {
          "sim_score": 0.4421241879463196,
          "doc_string": " Pythagorean triples are interchangable, i.e `x * x + y * y = y * y + x * x = z * z`. This comes from additive commutativity.",
          "statement": "theorem pythagorean_triple_comm {x y z : ℤ} : pythagorean_triple x y z ↔ pythagorean_triple y x z"
        }
      ],
      "codex_time": 9.081373843015172,
      "search_time": 1.568569580995245,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem nat.cube_sum_of_cubes{a b c : ℕ} [Fact (Nat.Prime c)] [Fact (Nat.Prime (a ^ 3 + b ^ 3))] (hpos : 0 < a ∧ 0 < b ∧ 0 < c) : a ˆ 3 + b ˆ 3 ≠ c ˆ 3 ",
      "theorem cube_sum{x y z : ℕ} (hxy : x ^ 3 + y ^ 3 = z ^ 3) : False ",
      "theorem sum_cube_neq{a b c : ℕ} (habn : a ^ 3 + b ^ 3 ≠ c ^ 3) : ¬ (a * a * a + b * b * b = c * c * c) ",
      "theorem sum_cubes_three_squares (x y z : ℕ) (hx : 0 < x) (hy : 0 < y) (hz : 0 < z) : (x ^ 3 + y ^ 3 + z ^ 3) / 3 ≠ x * y * z ",
      "theorem sum_of_cubes {x y z : ℤ} (hx : x > 0) (hy : y > 0) (hz : z > 0) : ¬ x ^ 3 + y ^ 3 = z ^ 3 "
    ],
    "answer": "theorem flt_3 : ∀ a b c : ℕ, a > 0 → b > 0 → ¬(a^3 + b^3 = c^3) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "flt_3",
      "main_prompt": "The sum of the cubes of two positive integers is never equal to the cube of a third integer.",
      "prompt": "Natural language version: \"The sum of the cubes of two positive integers is never equal to the cube of a third integer.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 7.477294229000108,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem sum_of_two_cubes_neq_cube { a b c : ℕ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) : a^3 + b^3 ≠ c^3 ",
      "theorem not_sumeq_cubes {x y z: ℕ} (hx: 0 < x) (hy: 0 < y) (hz: 0 < z):   x^3 + y^3 ≠ z^3 ",
      "theorem sum_cube_eq_cube { a b c : ℕ } ( h1 : 0 < a ) ( h2 : 0 < b ) ( h3 : 0 < c ) : a ^ 3 + b ^ 3 ≠ c ^ 3 ",
      "theorem sum_squares_cubes_eq_cube : ∀ (n m k : ℕ ), (n ^ 3) + (m ^ 3) = (k ^ 3) → False  Use tactic mode to complete the proof. -/  theorem sum_squares_cubes_eq_cube : ∀ (n m k : ℕ ), (n ^ 3) + (m ^ 3) = (k ^ 3) → False | 0 _ _ _ ",
      "theorem sum_of_squares_is_not_square_of_third (n m l : ℕ) : (n ^ 3 + m ^ 3) ≠ l ^ 3 "
    ],
    "answer": "theorem flt_3 : ∀ a b c : ℕ, a > 0 → b > 0 → ¬(a^3 + b^3 = c^3) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "elems_order_two_implies_commutative",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"If every element of a group `G` has order two, then every pair of elements of `G` commutes.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If every element of a group `G` has order two, then every pair of elements of `G` commutes.",
      "codex_time": 7.174255167978117,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem pair_of_elements_commuting_if_group_elements_have_order_two (G : Type*) [Group G]  (H : ∀ x : G, x * x = 1) : ∀ x y : G, x * y * x * y * x * y * x * y = 1 ",
      "theorem pair_of_elements_commuting_if_group_elements_have_order_two (G : Type*) [Groupₓₓ G]  (H : ∀ x : G, x * x = 1) : ∀ x y : G, x * y * x * y * x * y * x * y = 1 ",
      "theorem pair_of_elements_commuting_if_group_elements_have_order_two (G : Type*) [Groupₓ G]  (H : ∀ x : G, x * x = 1) : ∀ x y : G, x * y * x * y * x * y * x * y = 1 ",
      "theorem order_two_commutes (G : Type*) [Group G] (h : ∀ x : G, x = x⁻¹) : ∀ x y : G, x * y = y * x ",
      "theorem order_two_commutes (G : Type*) [Groupₓₓ G] (h : ∀ x : G, x = x⁻¹) : ∀ x y : G, x * y = y * x ",
      "theorem order_two_commutes (G : Type*) [Groupₓ G] (h : ∀ x : G, x = x⁻¹) : ∀ x y : G, x * y = y * x ",
      "theorem pair_commutes_of_nat_two_order (G : Type*) [Group G] (hG : ∀ (g : G), g^2 = 1) :  ∀ a b : G, a * b = b * a ",
      "theorem pair_commutes_of_nat_two_order (G : Type*) [Groupₓₓ G] (hG : ∀ (g : G), g^2 = 1) :  ∀ a b : G, a * b = b * a ",
      "theorem pair_commutes_of_nat_two_order (G : Type*) [Groupₓ G] (hG : ∀ (g : G), g^2 = 1) :  ∀ a b : G, a * b = b * a ",
      "theorem group_of_order_two_pair_commutes (G : Type*) [Group G] (h : ∀ a : G, a ≠ 1 → a * a = 1) :  ∀ {a b : G}, a * b = b * a ",
      "theorem group_of_order_two_pair_commutes (G : Type*) [Groupₓₓ G] (h : ∀ a : G, a ≠ 1 → a * a = 1) :  ∀ {a b : G}, a * b = b * a ",
      "theorem group_of_order_two_pair_commutes (G : Type*) [Groupₓ G] (h : ∀ a : G, a ≠ 1 → a * a = 1) :  ∀ {a b : G}, a * b = b * a ",
      "theorem order_two_group_commutes (G : Type*) [Group G] (hg : ∀ x : G, order x = 2) :  ∀ x y : G, x * y = y * x ",
      "theorem order_two_group_commutes (G : Type*) [Groupₓₓ G] (hg : ∀ x : G, order x = 2) :  ∀ x y : G, x * y = y * x ",
      "theorem order_two_group_commutes (G : Type*) [Groupₓ G] (hg : ∀ x : G, order x = 2) :  ∀ x y : G, x * y = y * x "
    ],
    "answer": "theorem elems_order_two_implies_commutative {G: Type _}[Group G] : (∀ x y : G, x * x = 1) → (∀ x y : G, Commute x y) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "elems_order_two_implies_commutative",
      "main_prompt": "If every element of a group `G` has order two, then every pair of elements of `G` commutes.",
      "prompt": "Natural language version: \"If `a` commutes with `b`, then `b` commutes with `a`.\" Translate the natural language version to a Lean mathlib version:\n theorem commute.symm{S : Type u_1} [has_mul S] {a b : S} (h : commute a b) :\ncommute b a := \n\nNatural language version: \"If `a` commutes with `b`, then `b` commutes with `a`.\" Translate the natural language version to a Lean mathlib version:\n theorem add_commute.symm{S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) :\nadd_commute b a := \n\nNatural language version: \"Commuting elements of finite order are closed under multiplication.\" Translate the natural language version to a Lean mathlib version:\n theorem commute.is_of_fin_order_mul{G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) :\nis_of_fin_order (x * y) := \n\nNatural language version: \"If `a` commutes with both `b` and `c`, then it commutes with their product.\" Translate the natural language version to a Lean mathlib version:\n theorem commute.mul_right{S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) :\ncommute a (b * c) := \n\nNatural language version: \"If every element of a group `G` has order two, then every pair of elements of `G` commutes.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6088767051696777,
          "doc_string": "If `a` commutes with `b`, then `b` commutes with `a`.",
          "statement": "theorem commute.symm {S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : commute b a"
        },
        {
          "sim_score": 0.6088767051696777,
          "doc_string": "If `a` commutes with `b`, then `b` commutes with `a`.",
          "statement": "theorem add_commute.symm {S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : add_commute b a"
        },
        {
          "sim_score": 0.5862270593643188,
          "doc_string": "Commuting elements of finite order are closed under multiplication.",
          "statement": "theorem commute.is_of_fin_order_mul {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)"
        },
        {
          "sim_score": 0.5844683647155762,
          "doc_string": "If `a` commutes with both `b` and `c`, then it commutes with their product.",
          "statement": "theorem commute.mul_right {S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) : commute a (b * c)"
        }
      ],
      "codex_time": 10.195432050997624,
      "search_time": 1.5816187500022352,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem commute.is_of_fin_order_two_of_fin_two{G : Type u} [Group G] (h : ∀ x : G, IsOfFinOrder (x : G) (ℕ)) : ∀ x y : G, Commute (x : G) y ",
      "theorem commute.is_of_fin_order_two_of_fin_two{G : Type u} [Groupₓₓ G] (h : ∀ x : G, IsOfFinOrder (x : G) (ℕ)) : ∀ x y : G, Commute (x : G) y ",
      "theorem commute.is_of_fin_order_two_of_fin_two{G : Type u} [Groupₓ G] (h : ∀ x : G, IsOfFinOrder (x : G) (ℕ)) : ∀ x y : G, Commute (x : G) y ",
      "theorem every_element_has_order_two.add_commute_irr{G : Type u} [Group G] (h1 : ∀ x : G, IsOfFinOrder x) (h2 : ∀ x : G, is_of_order x two_ne_zero) : ∀ x y : G, AddCommute x y ",
      "theorem every_element_has_order_two.add_commute_irr{G : Type u} [Groupₓₓ G] (h1 : ∀ x : G, IsOfFinOrder x) (h2 : ∀ x : G, is_of_order x two_ne_zero) : ∀ x y : G, AddCommute x y ",
      "theorem every_element_has_order_two.add_commute_irr{G : Type u} [Groupₓ G] (h1 : ∀ x : G, IsOfFinOrder x) (h2 : ∀ x : G, is_of_order x two_ne_zero) : ∀ x y : G, AddCommute x y ",
      "theorem allofhasordnto2_iff_allpairsofy_commutes{G : Type u} [Group G] : (∀ x : G, IsOfFinOrder x 2) ↔ (∀ x y : G, Commute x y) ",
      "theorem allofhasordnto2_iff_allpairsofy_commutes{G : Type u} [Groupₓₓ G] : (∀ x : G, IsOfFinOrder x 2) ↔ (∀ x y : G, Commute x y) ",
      "theorem allofhasordnto2_iff_allpairsofy_commutes{G : Type u} [Groupₓ G] : (∀ x : G, IsOfFinOrder x 2) ↔ (∀ x y : G, Commute x y) ",
      "theorem iop_two.commute{G : Type u} [Group G] {x y : G} (h : iop_two x) (h' : iop_two y) : Commute x y ",
      "theorem iop_two.commute{G : Type u} [Groupₓₓ G] {x y : G} (h : iop_two x) (h' : iop_two y) : Commute x y ",
      "theorem iop_two.commute{G : Type u} [Groupₓ G] {x y : G} (h : iop_two x) (h' : iop_two y) : Commute x y ",
      "theorem commute_of_card_two{G : Type u} [Group G] (h : ∀ (g:G), @is_of_order G 2 g) : ∀ x y : G, Commute x y ",
      "theorem commute_of_card_two{G : Type u} [Groupₓₓ G] (h : ∀ (g:G), @is_of_order G 2 g) : ∀ x y : G, Commute x y ",
      "theorem commute_of_card_two{G : Type u} [Groupₓ G] (h : ∀ (g:G), @is_of_order G 2 g) : ∀ x y : G, Commute x y "
    ],
    "answer": "theorem elems_order_two_implies_commutative {G: Type _}[Group G] : (∀ x y : G, x * x = 1) → (∀ x y : G, Commute x y) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "elems_order_two_implies_commutative",
      "main_prompt": "If every element of a group `G` has order two, then every pair of elements of `G` commutes.",
      "prompt": "Natural language version: \"If every element of a group `G` has order two, then every pair of elements of `G` commutes.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 11.552625905023888,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem lexch_1 (G : Group) : (∏ g : G, order g = 2) → (∏ g h : G, h * g = g * h) ",
      "theorem lexch_1 (G : Groupₓₓ) : (∏ g : G, order g = 2) → (∏ g h : G, h * g = g * h) ",
      "theorem lexch_1 (G : Groupₓ) : (∏ g : G, order g = 2) → (∏ g h : G, h * g = g * h) ",
      "theorem exists_in_range_right_of_ge_nat (a b : ℕ) (h : b < a) : ∃ n : ℕ, b + n = a ",
      "theorem : ∀ G : Type , ( ∀ ( x : G ), x ^ 2 = 1) →  ∀ x y : G , x * y = y * x ",
      "theorem every_pair_commutes_on_order_two :   ∀ (G : Type) [Group G],     ∀ g : G, g ≠ 0 → order G g = 2 →       ∀ (h k : G), k ≠ 0 → order G k = 2 → h * k = k * h  ",
      "theorem every_pair_commutes_on_order_two :   ∀ (G : Type) [Groupₓₓ G],     ∀ g : G, g ≠ 0 → order G g = 2 →       ∀ (h k : G), k ≠ 0 → order G k = 2 → h * k = k * h  ",
      "theorem every_pair_commutes_on_order_two :   ∀ (G : Type) [Groupₓ G],     ∀ g : G, g ≠ 0 → order G g = 2 →       ∀ (h k : G), k ≠ 0 → order G k = 2 → h * k = k * h  ",
      "theorem pair_commutes_iff_all_have_order_2 (G : Type) [Group G] :    (∀ g : G, g^2 = 1) ↔ (∀ (g1 g2 : G), g1 * g2 = g2 * g1)  Proof.     by <fill in the proof>  Qed. -/  /-- Let G be a group. Suppose every element of G has order 2. Prove    every pair of elements of G Commute     Because it is a short, non-technical proof, be sure to include    commentary.  Hint: Proving iffs is usually easier than proving direct implications",
      "theorem pair_commutes_iff_all_have_order_2 (G : Type) [Groupₓₓ G] :    (∀ g : G, g^2 = 1) ↔ (∀ (g1 g2 : G), g1 * g2 = g2 * g1)  Proof.     by <fill in the proof>  Qed. -/  /-- Let G be a group. Suppose every element of G has order 2. Prove    every pair of elements of G Commute     Because it is a short, non-technical proof, be sure to include    commentary.  Hint: Proving iffs is usually easier than proving direct implications",
      "theorem pair_commutes_iff_all_have_order_2 (G : Type) [Groupₓ G] :    (∀ g : G, g^2 = 1) ↔ (∀ (g1 g2 : G), g1 * g2 = g2 * g1)  Proof.     by <fill in the proof>  Qed. -/  /-- Let G be a group. Suppose every element of G has order 2. Prove    every pair of elements of G Commute     Because it is a short, non-technical proof, be sure to include    commentary.  Hint: Proving iffs is usually easier than proving direct implications"
    ],
    "answer": "theorem elems_order_two_implies_commutative {G: Type _}[Group G] : (∀ x y : G, x * x = 1) → (∀ x y : G, Commute x y) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "prime_eq_two_or_odd",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every prime number is either `2` or odd.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every prime number is either `2` or odd.",
      "codex_time": 5.914799810998375,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem every_prime_is_two_or_odd :  ∀ p : ℕ, Prime p → p = 2 ∨ nat.odd p ",
      "theorem two_or_odd (P : ℕ) (h : Prime P) : P = 2 ∨ ¬ Even P ",
      "theorem prime_is_either_two_or_odd :  ∀ p : ℕ, Prime p → p = 2 ∨ p % 2 = 1 ",
      "theorem prime.odd_or_two : ∀ p : ℕ, Prime p → p = 2 ∨ p % 2 = 1 ",
      "theorem primes_over_natural_numbers_are_even_or_odd (n : ℕ) (hn : Prime n) :  ∃ (p : ℕ), n = 2 ∨ (Even p ∧ p = n) "
    ],
    "answer": "theorem prime_eq_two_or_odd {n: Nat} : Prime n → n = 2 ∨ Odd n "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "prime_eq_two_or_odd",
      "main_prompt": "Every prime number is either `2` or odd.",
      "prompt": "Natural language version: \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.prime.mod_two_eq_one_iff_ne_two{p : ℕ} [fact (nat.prime p)] :\np % 2 = 1 ↔ p ≠ 2 := \n\nNatural language version: \"A natural number is odd iff it has residue `1` or `3` mod `4`\" Translate the natural language version to a Lean mathlib version:\n theorem nat.odd_mod_four_iff{n : ℕ} :\nn % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 := \n\nNatural language version: \"The only numbers with empty prime factorization are `0` and `1`\" Translate the natural language version to a Lean mathlib version:\n theorem nat.factorization_eq_zero_iff(n : ℕ) :\nn.factorization = 0 ↔ n = 0 ∨ n = 1 := \n\nNatural language version: \"The only prime factor of prime `p` is `p` itself, with multiplicity `1`\" Translate the natural language version to a Lean mathlib version:\n theorem nat.prime.factorization{p : ℕ} (hp : nat.prime p) :\np.factorization = finsupp.single p 1 := \n\nNatural language version: \"Every prime number is either `2` or odd.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.7289595007896423,
          "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.",
          "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2"
        },
        {
          "sim_score": 0.5622097253799438,
          "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`",
          "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"
        },
        {
          "sim_score": 0.5335504412651062,
          "doc_string": "The only numbers with empty prime factorization are `0` and `1`",
          "statement": "theorem nat.factorization_eq_zero_iff (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1"
        },
        {
          "sim_score": 0.5028786063194275,
          "doc_string": "The only prime factor of prime `p` is `p` itself, with multiplicity `1`",
          "statement": "theorem nat.prime.factorization {p : ℕ} (hp : nat.prime p) : p.factorization = finsupp.single p 1"
        }
      ],
      "codex_time": 6.363089246995514,
      "search_time": 1.4313888899923768,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem nat.prime.or_eq_two(p : ℕ) [Fact (Nat.Prime p)] : p = 2 ∨ p % 2 = 1 ",
      "theorem nat.prime.not_two_of_odd{n : ℕ} (h_prime : Nat.Prime n) (h_odd : n % 2 = 1) : n ≠ 2 ",
      "theorem nat.prime.exhaust{p : ℕ} (hp : Nat.Prime p) : p = 2 ∨ p % 2 = 1 ",
      "theorem nat.prime.is_odd_or_eq_two(p : ℕ) [Fact (Nat.Prime p)] :  p = 2 ∨ p % 2 = 1 ",
      "theorem nat.prime.or_two{p : ℕ} (hp : Nat.Prime p) : p ≠ 2 ∨ p = 2 "
    ],
    "answer": "theorem prime_eq_two_or_odd {n: Nat} : Prime n → n = 2 ∨ Odd n "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "prime_eq_two_or_odd",
      "main_prompt": "Every prime number is either `2` or odd.",
      "prompt": "Natural language version: \"Every prime number is either `2` or odd.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 4.722628629999235,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem odd_prime_or_two : ∀ x : ℕ , Prime x → is_odd x ∨ x = 2 ",
      "theorem prime_iff_even {p : ℕ} : Prime p ↔ p = 2 ∨ Odd p ",
      "theorem prime_even_or_odd ( p : ℕ ) ( h : Prime p ) : ( p = 2 ) ∨ ( Odd p ) ",
      "theorem nat.prime_odd_or_two { n : ℕ } : Nat.Prime n → n = 2 ∨ n % 2 ≠ 0 ",
      "theorem double_even_or_odd . { n : ℕ } ( H : Prime n ) : ( n = 2 ) ∨ ( n % 2 = 1 ) "
    ],
    "answer": "theorem prime_eq_two_or_odd {n: Nat} : Prime n → n = 2 ∨ Odd n "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "poly_odd_degree_has_zero",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every odd degree polynomial over `ℝ` has a zero\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every odd degree polynomial over `ℝ` has a zero",
      "codex_time": 6.5423500680190045,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem odd_degree_polynomial_over_reals_has_zero (p : Polynomial ℝ) (hp : degree p % 2 = 1) :  ∃ r : ℝ, p.eval r = 0 ",
      "theorem poly_odd_degree_has_zero (a : ℝ) (f : Polynomial ℝ)  (Odd : ¬is_even (nat_degree f)) : ∃ z : ℝ, Polynomial.eval f z = 0 ",
      "theorem poly_of_odd_degree_has_root (p : Polynomial ℝ) (hp_odd : p.degree % 2 = 1) :  polynorm.roots p.map ℝ ≠ ∅ ",
      "theorem odd_degree_polynomial_has_a_root (p : Polynomial ℝ) : degree p % 2 = 1 ∧ ∃ x, p.eval x = 0 ",
      "theorem odd_degree_poly_has_zero (p : Polynomial ℝ)  (hdeg : p.degree % 2 = 1) : ∃ z, z ≠ 0 ∧ p.eval z = 0 "
    ],
    "answer": "theorem poly_odd_degree_has_zero {α : Type _} [Field α] (p : Polynomial α) : Odd (p.degree) → ∃ x, p.IsRoot x "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "poly_odd_degree_has_zero",
      "main_prompt": "Every odd degree polynomial over `ℝ` has a zero",
      "prompt": "Natural language version: \"The degree of a product of polynomials is at most the sum of the degrees, where the degree of the zero polynomial is ⊥.\" Translate the natural language version to a Lean mathlib version:\n theorem polynomial.degree_multiset_prod_le{R : Type u} [comm_semiring R] (t : multiset (polynomial R)) :\nt.prod.degree ≤ (multiset.map polynomial.degree t).sum := \n\nNatural language version: \"The degree of a product of polynomials is equal to the sum of the degrees, where the degree of the zero polynomial is ⊥.\" Translate the natural language version to a Lean mathlib version:\n theorem polynomial.degree_multiset_prod{R : Type u} [comm_semiring R] [no_zero_divisors R] (t : multiset (polynomial R)) [nontrivial R] :\nt.prod.degree = (multiset.map (λ (f : polynomial R), f.degree) t).sum := \n\nNatural language version: \"The degree of a product of polynomials is equal to the sum of the degrees, where the degree of the zero polynomial is ⊥.\" Translate the natural language version to a Lean mathlib version:\n theorem polynomial.degree_prod{R : Type u} {ι : Type w} (s : finset ι) [comm_semiring R] [no_zero_divisors R] (f : ι → polynomial R) [nontrivial R] :\n(s.prod (λ (i : ι), f i)).degree = s.sum (λ (i : ι), (f i).degree) := \n\nNatural language version: \"The degree of a minimal polynomial, as a natural number, is positive.\" Translate the natural language version to a Lean mathlib version:\n theorem minpoly.nat_degree_pos{A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] [nontrivial B] {x : B} (hx : is_integral A x) :\n0 < (minpoly A x).nat_degree := \n\nNatural language version: \"Every odd degree polynomial over `ℝ` has a zero\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.50849449634552,
          "doc_string": "The degree of a product of polynomials is at most the sum of the degrees, where the degree of the zero polynomial is ⊥.",
          "statement": "theorem polynomial.degree_multiset_prod_le {R : Type u} [comm_semiring R] (t : multiset (polynomial R)) : t.prod.degree ≤ (multiset.map polynomial.degree t).sum"
        },
        {
          "sim_score": 0.48135414719581604,
          "doc_string": "The degree of a product of polynomials is equal to the sum of the degrees, where the degree of the zero polynomial is ⊥.",
          "statement": "theorem polynomial.degree_multiset_prod {R : Type u} [comm_semiring R] [no_zero_divisors R] (t : multiset (polynomial R)) [nontrivial R] : t.prod.degree = (multiset.map (λ (f : polynomial R), f.degree) t).sum"
        },
        {
          "sim_score": 0.48135414719581604,
          "doc_string": "The degree of a product of polynomials is equal to the sum of the degrees, where the degree of the zero polynomial is ⊥.",
          "statement": "theorem polynomial.degree_prod {R : Type u} {ι : Type w} (s : finset ι) [comm_semiring R] [no_zero_divisors R] (f : ι → polynomial R) [nontrivial R] : (s.prod (λ (i : ι), f i)).degree = s.sum (λ (i : ι), (f i).degree)"
        },
        {
          "sim_score": 0.4661085605621338,
          "doc_string": "The degree of a minimal polynomial, as a natural number, is positive.",
          "statement": "theorem minpoly.nat_degree_pos {A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] [nontrivial B] {x : B} (hx : is_integral A x) : 0 < (minpoly A x).nat_degree"
        }
      ],
      "codex_time": 9.308353050000733,
      "search_time": 1.7156728270056192,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem has_root_odd_degree_real {R : Type u} [Nontrivial R] [discrete_field R] (p : Polynomial R) : (∀ x : R, Polynomial.eval p x = 0 ∨ Polynomial.eval p (-x) = 0) ↔ p.nat_degree % 2 = 1 ",
      "theorem exists_root_odd_degree_real_polynomial (p : Polynomial ℝ) : p.degree.nat_mod 2 = 1 → ∃ z, z ≠ 0 ∧ (z : ℝ) ∈ p.roots ",
      "theorem reals.IVT_irrational_2{r : ℝ} (hr : ∀ r, r ∈ (Ioo (0:ℝ) 1)) : ∃ r : ℝ, r ∈ (Ioo 0 (1:ℝ)) ∧ r ≠ 0 ",
      "theorem real.odd_degree_zero{p : Polynomial ℝ} (hp : p.degree = 2 * _ + 1) : ∃x : ℝ, real.to_real_poly p x = 0 ",
      "theorem exists_odd_degree_root_real (f : Polynomial ℝ) (hf : f.nat_degree % 2 = 1) : ∃ x : ℝ, f.eval x = 0 "
    ],
    "answer": "theorem poly_odd_degree_has_zero {α : Type _} [Field α] (p : Polynomial α) : Odd (p.degree) → ∃ x, p.IsRoot x "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "poly_odd_degree_has_zero",
      "main_prompt": "Every odd degree polynomial over `ℝ` has a zero",
      "prompt": "Natural language version: \"Every odd degree polynomial over `ℝ` has a zero\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 9.513906200998463,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem odd_degree_has_zero { f : Polynomial ℝ } ( hf : degree f % 2 = 1 ) : ∃ x , f x = 0 ",
      "theorem Every_odd_degree_polynomial_over_ℝ_has_a_zero : every Odd degree Polynomial over ℝ has a Zero  What would the proof of the Lean mathlib version look like? }  example : every Odd degree Polynomial over ℝ has a Zero ",
      "theorem odd_degree_polynomial_has_zero (p : Polynomial ℝ) (h : p.degree % 2 = 1) : ∃ x, p.eval x = 0  (This example is stolen from a recent paper on classifying the difficult parts of a proof assistant.) )  Normally, we would implement has_eval like this: structure Polynomial (α : Type) ",
      "theorem odd_degree_poly_has_zero (p : Polynomial ℝ) (hp : Odd (p.degree)) : ∃ x : ℝ, p x = 0 ",
      "theorem polynomial_has_zero (p : Polynomial ℝ) (hp : Even (degree p)) : ∀ x, p x = 0 "
    ],
    "answer": "theorem poly_odd_degree_has_zero {α : Type _} [Field α] (p : Polynomial α) : Odd (p.degree) → ∃ x, p.IsRoot x "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "product_conseq_odd",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"The product of two consequitive natural numbers is odd\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The product of two consequitive natural numbers is odd",
      "codex_time": 5.667548823985271,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem product_of_two_consequitive_nat_is_odd (n : Nat) :  2*n - 1 ≠ 0 ∧ 2*n - 1 ∣ n*n + n ",
      "theorem product_even_odd (n : ℕ) :  2 * n * (2 * n + 1) % 2 = 1 ",
      "theorem product_of_conseq_even_numbers_is_odd (n : ℕ):  ∀ m, (m = n ∨ m = n+1) → (m*n) % 2 = 1 ",
      "theorem odd_product_of_two_consequtive (n : ℕ) :  n % 2 = 0 ∧ n.succ % 2 = 1 → n / 2 % 2 = 1 ",
      "theorem product_of_consequitive_naturals_is_odd (n : ℕ):  Odd (n * (n + 1)) "
    ],
    "answer": "theorem product_conseq_odd (n: Nat): Odd <| n * (n + 1) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "product_conseq_odd",
      "main_prompt": "The product of two consequitive natural numbers is odd",
      "prompt": "Natural language version: \" If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.even_pow{m n : ℕ} :\neven (m ^ n) ↔ even m ∧ n ≠ 0 := \n\nNatural language version: \"A natural number is odd iff it has residue `1` or `3` mod `4`\" Translate the natural language version to a Lean mathlib version:\n theorem nat.odd_mod_four_iff{n : ℕ} :\nn % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 := \n\nNatural language version: \"Two natural numbers are equal if and only if the have the same multiples.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.dvd_right_iff_eq{m n : ℕ} :\n(∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n := \n\nNatural language version: \"The product of the factors is the original number\" Translate the natural language version to a Lean mathlib version:\n theorem pnat.prod_factor_multiset(n : ℕ+) :\nn.factor_multiset.prod = n := \n\nNatural language version: \"The product of two consequitive natural numbers is odd\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5561787486076355,
          "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.",
          "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0"
        },
        {
          "sim_score": 0.5415111780166626,
          "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`",
          "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"
        },
        {
          "sim_score": 0.5249637365341187,
          "doc_string": "Two natural numbers are equal if and only if the have the same multiples.",
          "statement": "theorem nat.dvd_right_iff_eq {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n"
        },
        {
          "sim_score": 0.5125280022621155,
          "doc_string": "The product of the factors is the original number",
          "statement": "theorem pnat.prod_factor_multiset (n : ℕ+) : n.factor_multiset.prod = n"
        }
      ],
      "codex_time": 6.743548944010399,
      "search_time": 1.4329123749921564,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem nat.mul_succ_succ_odd{m n : ℕ} : ∃ k : ℤ, (int.of_nat (m + 1)) * (int.of_nat (n + 1)) = 2 * k.succ ",
      "theorem nat.prod_succ: ∀ a : ℕ, Even (a + 1) ",
      "theorem mul_nat_mul_add_nat_mul_add_mul_nat :  ∀ (m n : ℕ), (m * n) * (n + 1) = m * n * n + m ",
      "theorem nat.even_mul(m n : ℕ) : Even m ∧ m ≠ 0 → Even n ∧ n ≠ 0 → Even (m * n ∧ m ≠ 0) ",
      "theorem pnat.even_iff_odd_mul{m n : ℕ+} : Even m ↔ Odd (m * n) "
    ],
    "answer": "theorem product_conseq_odd (n: Nat): Odd <| n * (n + 1) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "product_conseq_odd",
      "main_prompt": "The product of two consequitive natural numbers is odd",
      "prompt": "Natural language version: \"The product of two consequitive natural numbers is odd\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 8.615691202983726,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem nat_odd_product : ∀ m n : ℕ, (2 * m) + (2 * n) = 1 → False  Split in two inequalities to censor the term m, and rewrite the proof 1 = (2 * m) + (2 * n) which is False  theorem nat_odd_product : ∀ m n : ℕ, (2 * m) + (2 * n) ≥ 3 → (2 * m) + (2 * n) > 3  Sketch the proof.   ...  Show the proof.  #reduce (2 : ℕ) * 3 + (2 : ℕ) * 4 > 3",
      "theorem odd_product_of_consecutive_numbers ( n : ℕ ) : 2 ∣ n → nat.succ n * n % 2 = 1 ",
      "theorem two_consecutive_odd_product_nat ( a b : ℕ ) : Odd ( a * b ) ",
      "theorem two_consec_naturals_mult_odd : ∀ n : ℕ, ∃ m : ℕ, (m+1)*(m+2) = n ",
      "theorem is_even_and_is_odd_and_times_odd: ∀ n : ℕ, n % 2 = 0 ∧ ∃ m : ℕ, m > 0 ∧ n * m % 2 = 1  Not verified. Couldn't use the m in the proof body, and couldn't finish playing around with abstraction. *)  -- Question 3:  -- Example: natural number n divisible by m  -- Natural language version: \"n is divisible by m\" -- Lean version: ∀ (n m : ℕ) d, m > 0 → n = m*d -- Translate the Lean version to a natural language version: --"
    ],
    "answer": "theorem product_conseq_odd (n: Nat): Odd <| n * (n + 1) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "constant_is_differentiable",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every constant function `f x = c` from real numbers to real numbers is differentiable.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every constant function `f x = c` from real numbers to real numbers is differentiable.",
      "codex_time": 5.051264838984935,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem constant_differentiable (f : ℝ → ℝ) (c : ℝ) : ∀ x ∉ Set.Range (μ c), (deriv f c) x = 0 ",
      "theorem constant_differentiable (f : ℝ → ℝ) (c : ℝ) : ∀ x ∉ Setₓ.Range (μ c), (deriv f c) x = 0 ",
      "theorem deriv_const (c : ℝ) : HasDerivAt 0 (λ x : ℝ, c) ",
      "theorem differentiable_constant_function (a : ℝ) (C : ℝ) :  Differentiable (λ x : ℝ, C) ",
      "theorem constant_function_is_differentiable (f : ℝ → ℝ) :  Differentiable f ",
      "theorem constant_function_differentiable_on_Reals (c : ℝ) :  ∀ x : ℝ, DifferentiableAt ℝ real.fderiv_at sin x "
    ],
    "answer": "theorem constant_is_differentiable {f: ℝ → ℝ}: ∃ c: ℝ, (∀ x : ℝ, f x = c) → Differentiable ℝ f "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "constant_is_differentiable",
      "main_prompt": "Every constant function `f x = c` from real numbers to real numbers is differentiable.",
      "prompt": "Natural language version: \"If a function is `C^n` with `n ≥ 1`, then it is differentiable.\" Translate the natural language version to a Lean mathlib version:\n theorem cont_diff.differentiable{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {n : with_top ℕ} (h : cont_diff 𝕜 n f) (hn : 1 ≤ n) :\ndifferentiable 𝕜 f := \n\nNatural language version: \"If a function is `C^n` with `n ≥ 1` at a point, then it is differentiable there.\" Translate the natural language version to a Lean mathlib version:\n theorem cont_diff_at.differentiable_at{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {x : E} {n : with_top ℕ} (h : cont_diff_at 𝕜 n f x) (hn : 1 ≤ n) :\ndifferentiable_at 𝕜 f x := \n\nNatural language version: \" If a function is `C^n` within a set at a point, with `n ≥ 1`, then it is differentiable within this set at this point.\" Translate the natural language version to a Lean mathlib version:\n theorem cont_diff_within_at.differentiable_within_at'{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {x : E} {n : with_top ℕ} (h : cont_diff_within_at 𝕜 n f s x) (hn : 1 ≤ n) :\ndifferentiable_within_at 𝕜 f (has_insert.insert x s) x := \n\nNatural language version: \"If a function is `C^n` on a set with `n ≥ 1`, then it is differentiable there.\" Translate the natural language version to a Lean mathlib version:\n theorem cont_diff_on.differentiable_on{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {n : with_top ℕ} (h : cont_diff_on 𝕜 n f s) (hn : 1 ≤ n) :\ndifferentiable_on 𝕜 f s := \n\nNatural language version: \"Every constant function `f x = c` from real numbers to real numbers is differentiable.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6595531702041626,
          "doc_string": "If a function is `C^n` with `n ≥ 1`, then it is differentiable.",
          "statement": "theorem cont_diff.differentiable {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {n : with_top ℕ} (h : cont_diff 𝕜 n f) (hn : 1 ≤ n) : differentiable 𝕜 f"
        },
        {
          "sim_score": 0.6467167139053345,
          "doc_string": "If a function is `C^n` with `n ≥ 1` at a point, then it is differentiable there.",
          "statement": "theorem cont_diff_at.differentiable_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {x : E} {n : with_top ℕ} (h : cont_diff_at 𝕜 n f x) (hn : 1 ≤ n) : differentiable_at 𝕜 f x"
        },
        {
          "sim_score": 0.6451953649520874,
          "doc_string": " If a function is `C^n` within a set at a point, with `n ≥ 1`, then it is differentiable within this set at this point.",
          "statement": "theorem cont_diff_within_at.differentiable_within_at' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {x : E} {n : with_top ℕ} (h : cont_diff_within_at 𝕜 n f s x) (hn : 1 ≤ n) : differentiable_within_at 𝕜 f (has_insert.insert x s) x"
        },
        {
          "sim_score": 0.6353325843811035,
          "doc_string": "If a function is `C^n` on a set with `n ≥ 1`, then it is differentiable there.",
          "statement": "theorem cont_diff_on.differentiable_on {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {n : with_top ℕ} (h : cont_diff_on 𝕜 n f s) (hn : 1 ≤ n) : differentiable_on 𝕜 f s"
        }
      ],
      "codex_time": 5.653682729986031,
      "search_time": 1.462075316987466,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem const_diff {f : ℝ → ℝ} (c : ℝ) (x : ℝ) : Differentiable 𝕜 f ",
      "theorem differentiable_const{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] [NormedSpace 𝕜 ℝ] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {c : E} {f : E → E} (Hf : f = (λ x, c)) : DifferentiableOn 𝕜 f ℝ ",
      "theorem continuous_const.differentiable (c : ℝ) : Differentiable ℝ (λ (x : ℝ), c) ",
      "theorem continuous_linear_map.const.differentiable (c : ℝ) : Differentiable ℝ (λ x:ℝ, c) ",
      "theorem differentiable_const : Differentiable ℝ (λ x : ℝ, 0) "
    ],
    "answer": "theorem constant_is_differentiable {f: ℝ → ℝ}: ∃ c: ℝ, (∀ x : ℝ, f x = c) → Differentiable ℝ f "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "constant_is_differentiable",
      "main_prompt": "Every constant function `f x = c` from real numbers to real numbers is differentiable.",
      "prompt": "Natural language version: \"Every constant function `f x = c` from real numbers to real numbers is differentiable.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 6.935172853991389,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem continuous_differentiable_eq (f : ℝ → ℝ) (c : ℝ) (h : ∀ x, f x = c) :   DifferentiableAt f (x : ℝ) ",
      "theorem function_differentiable : Differentiable ℝ ℝ (λ f x, c) ",
      "theorem const_diff (f : ℝ → ℝ) (c : ℝ) (Hf : ∀ x, f x = c) : DifferentiableAt f 0 ",
      "theorem constant_function_is_differentiable : Differentiable f ",
      "theorem diff_const :    ∀ {c : ℝ},    ∀ f : ℝ → ℝ,    f = pure c →    DifferentiableAt f ℝ x "
    ],
    "answer": "theorem constant_is_differentiable {f: ℝ → ℝ}: ∃ c: ℝ, (∀ x : ℝ, f x = c) → Differentiable ℝ f "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "index_two_subgroup",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every index 2 subgroup of a group is free\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every index 2 subgroup of a group is free",
      "codex_time": 8.448681969981408,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem free_subgroup_index_two (G : Type*) [Group G] (H : Set G)  (H_subgroup : IsSubgroup H) (H_index_two : (QuotientGroup.mk H) ≃ (ℤ / 2ℤ)) :  ∃ n : ℕ, ∃ f : (Fin n) ⇒ G, f.image = H ∧  ∀ i j : Fin n, i ≠ j → f i ≠ f j ",
      "theorem free_subgroup_index_two (G : Type*) [Groupₓₓ G] (H : Set G)  (H_subgroup : IsSubgroup H) (H_index_two : (QuotientGroup.mk H) ≃ (ℤ / 2ℤ)) :  ∃ n : ℕ, ∃ f : (Fin n) ⇒ G, f.image = H ∧  ∀ i j : Fin n, i ≠ j → f i ≠ f j ",
      "theorem free_subgroup_index_two (G : Type*) [Group G] (H : Setₓ G)  (H_subgroup : IsSubgroup H) (H_index_two : (QuotientGroup.mk H) ≃ (ℤ / 2ℤ)) :  ∃ n : ℕ, ∃ f : (Fin n) ⇒ G, f.image = H ∧  ∀ i j : Fin n, i ≠ j → f i ≠ f j ",
      "theorem free_subgroup_index_two (G : Type*) [Groupₓₓ G] (H : Setₓ G)  (H_subgroup : IsSubgroup H) (H_index_two : (QuotientGroup.mk H) ≃ (ℤ / 2ℤ)) :  ∃ n : ℕ, ∃ f : (Fin n) ⇒ G, f.image = H ∧  ∀ i j : Fin n, i ≠ j → f i ≠ f j ",
      "theorem free_subgroup_index_two (G : Type*) [Group G] (H : Set G)  (H_subgroup : IsSubgroup H) (H_index_two : (QuotientGroup.mk H) ≃ (ℤ / 2ℤ)) :  ∃ n : ℕ, ∃ f : (Finₓ n) ⇒ G, f.image = H ∧  ∀ i j : Finₓ n, i ≠ j → f i ≠ f j ",
      "theorem free_subgroup_index_two (G : Type*) [Groupₓₓ G] (H : Set G)  (H_subgroup : IsSubgroup H) (H_index_two : (QuotientGroup.mk H) ≃ (ℤ / 2ℤ)) :  ∃ n : ℕ, ∃ f : (Finₓ n) ⇒ G, f.image = H ∧  ∀ i j : Finₓ n, i ≠ j → f i ≠ f j ",
      "theorem free_subgroup_index_two (G : Type*) [Group G] (H : Setₓ G)  (H_subgroup : IsSubgroup H) (H_index_two : (QuotientGroup.mk H) ≃ (ℤ / 2ℤ)) :  ∃ n : ℕ, ∃ f : (Finₓ n) ⇒ G, f.image = H ∧  ∀ i j : Finₓ n, i ≠ j → f i ≠ f j ",
      "theorem free_subgroup_index_two (G : Type*) [Groupₓₓ G] (H : Setₓ G)  (H_subgroup : IsSubgroup H) (H_index_two : (QuotientGroup.mk H) ≃ (ℤ / 2ℤ)) :  ∃ n : ℕ, ∃ f : (Finₓ n) ⇒ G, f.image = H ∧  ∀ i j : Finₓ n, i ≠ j → f i ≠ f j ",
      "theorem free_subgroup_index_two (G : Type*) [Groupₓ G] (H : Set G)  (H_subgroup : IsSubgroup H) (H_index_two : (QuotientGroup.mk H) ≃ (ℤ / 2ℤ)) :  ∃ n : ℕ, ∃ f : (Fin n) ⇒ G, f.image = H ∧  ∀ i j : Fin n, i ≠ j → f i ≠ f j ",
      "theorem free_subgroup_index_two (G : Type*) [Groupₓ G] (H : Setₓ G)  (H_subgroup : IsSubgroup H) (H_index_two : (QuotientGroup.mk H) ≃ (ℤ / 2ℤ)) :  ∃ n : ℕ, ∃ f : (Fin n) ⇒ G, f.image = H ∧  ∀ i j : Fin n, i ≠ j → f i ≠ f j ",
      "theorem free_subgroup_index_two (G : Type*) [Groupₓ G] (H : Set G)  (H_subgroup : IsSubgroup H) (H_index_two : (QuotientGroup.mk H) ≃ (ℤ / 2ℤ)) :  ∃ n : ℕ, ∃ f : (Finₓ n) ⇒ G, f.image = H ∧  ∀ i j : Finₓ n, i ≠ j → f i ≠ f j ",
      "theorem free_subgroup_index_two (G : Type*) [Groupₓ G] (H : Setₓ G)  (H_subgroup : IsSubgroup H) (H_index_two : (QuotientGroup.mk H) ≃ (ℤ / 2ℤ)) :  ∃ n : ℕ, ∃ f : (Finₓ n) ⇒ G, f.image = H ∧  ∀ i j : Finₓ n, i ≠ j → f i ≠ f j ",
      "theorem free_subgroup_of_subgroup_of_index_2 (G : Type*) [Group G] (H : Set G)  (H_subgroup : IsSubgroup H) (H_index_2 : coset H 1 ≠ ∅) :  IsFreeGroup H ",
      "theorem free_subgroup_of_subgroup_of_index_2 (G : Type*) [Groupₓₓ G] (H : Set G)  (H_subgroup : IsSubgroup H) (H_index_2 : coset H 1 ≠ ∅) :  IsFreeGroup H ",
      "theorem free_subgroup_of_subgroup_of_index_2 (G : Type*) [Group G] (H : Setₓ G)  (H_subgroup : IsSubgroup H) (H_index_2 : coset H 1 ≠ ∅) :  IsFreeGroup H ",
      "theorem free_subgroup_of_subgroup_of_index_2 (G : Type*) [Groupₓₓ G] (H : Setₓ G)  (H_subgroup : IsSubgroup H) (H_index_2 : coset H 1 ≠ ∅) :  IsFreeGroup H ",
      "theorem free_subgroup_of_subgroup_of_index_2 (G : Type*) [Groupₓ G] (H : Set G)  (H_subgroup : IsSubgroup H) (H_index_2 : coset H 1 ≠ ∅) :  IsFreeGroup H ",
      "theorem free_subgroup_of_subgroup_of_index_2 (G : Type*) [Groupₓ G] (H : Setₓ G)  (H_subgroup : IsSubgroup H) (H_index_2 : coset H 1 ≠ ∅) :  IsFreeGroup H ",
      "theorem free_iff_index2_subgroup_of_group (G : Type*) [Group G]  (H : Subgroup G) (hx : H = ⟨(λ a b, a * b * a⁻¹ * b⁻¹), by {intros, simp [pow_inv, mul_inv]}, 2⟩) :  FreeGroup H ",
      "theorem free_iff_index2_subgroup_of_group (G : Type*) [Groupₓₓ G]  (H : Subgroup G) (hx : H = ⟨(λ a b, a * b * a⁻¹ * b⁻¹), by {intros, simp [pow_inv, mul_inv]}, 2⟩) :  FreeGroup H ",
      "theorem free_iff_index2_subgroup_of_group (G : Type*) [Groupₓ G]  (H : Subgroup G) (hx : H = ⟨(λ a b, a * b * a⁻¹ * b⁻¹), by {intros, simp [pow_inv, mul_inv]}, 2⟩) :  FreeGroup H ",
      "theorem index_two_subgroups_are_free (G : Type*) [Group G] (H : Set G) (hH : (H : Set G) ⊆ G)  (hH_subgroup : IsSubgroup H) (hH_index_2 : ∃ g : G, H.prod g = Set.Univ) :  IsFreeGroup H ",
      "theorem index_two_subgroups_are_free (G : Type*) [Groupₓₓ G] (H : Set G) (hH : (H : Set G) ⊆ G)  (hH_subgroup : IsSubgroup H) (hH_index_2 : ∃ g : G, H.prod g = Set.Univ) :  IsFreeGroup H ",
      "theorem index_two_subgroups_are_free (G : Type*) [Group G] (H : Setₓ G) (hH : (H : Setₓ G) ⊆ G)  (hH_subgroup : IsSubgroup H) (hH_index_2 : ∃ g : G, H.prod g = Setₓ.Univ) :  IsFreeGroup H ",
      "theorem index_two_subgroups_are_free (G : Type*) [Groupₓₓ G] (H : Setₓ G) (hH : (H : Setₓ G) ⊆ G)  (hH_subgroup : IsSubgroup H) (hH_index_2 : ∃ g : G, H.prod g = Setₓ.Univ) :  IsFreeGroup H ",
      "theorem index_two_subgroups_are_free (G : Type*) [Groupₓ G] (H : Set G) (hH : (H : Set G) ⊆ G)  (hH_subgroup : IsSubgroup H) (hH_index_2 : ∃ g : G, H.prod g = Set.Univ) :  IsFreeGroup H ",
      "theorem index_two_subgroups_are_free (G : Type*) [Groupₓ G] (H : Setₓ G) (hH : (H : Setₓ G) ⊆ G)  (hH_subgroup : IsSubgroup H) (hH_index_2 : ∃ g : G, H.prod g = Setₓ.Univ) :  IsFreeGroup H ",
      "theorem free_subgroup_index_two (G : Type*) [Group G]  (H : Subgroup G) (hH : [G : H] = 2) :  Fintype.card (subgroup.to_finset G) = Fintype.card (subgroup.to_finset H) ",
      "theorem free_subgroup_index_two (G : Type*) [Groupₓₓ G]  (H : Subgroup G) (hH : [G : H] = 2) :  Fintype.card (subgroup.to_finset G) = Fintype.card (subgroup.to_finset H) ",
      "theorem free_subgroup_index_two (G : Type*) [Groupₓ G]  (H : Subgroup G) (hH : [G : H] = 2) :  Fintype.card (subgroup.to_finset G) = Fintype.card (subgroup.to_finset H) ",
      "theorem free_subgroup_index_two (G : Type*) [Group G]  (H : Subgroup G) (hH : [G : H] = 2) :  Fintypeₓ.card (subgroup.to_finset G) = Fintypeₓ.card (subgroup.to_finset H) ",
      "theorem free_subgroup_index_two (G : Type*) [Groupₓₓ G]  (H : Subgroup G) (hH : [G : H] = 2) :  Fintypeₓ.card (subgroup.to_finset G) = Fintypeₓ.card (subgroup.to_finset H) ",
      "theorem free_subgroup_index_two (G : Type*) [Groupₓ G]  (H : Subgroup G) (hH : [G : H] = 2) :  Fintypeₓ.card (subgroup.to_finset G) = Fintypeₓ.card (subgroup.to_finset H) "
    ],
    "answer": "theorem index_two_subgroup {G : Type _} [Groupₓ G] (H : Subgroup G): H.index = 2 → Subgroup.Normal H "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "index_two_subgroup",
      "main_prompt": "Every index 2 subgroup of a group is free",
      "prompt": "Natural language version: \"Subgroups of torsion-free groups are torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.subgroup{G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) :\nmonoid.is_torsion_free ↥H := \n\nNatural language version: \"**Schreier's Lemma**: A finite index subgroup of a finitely generated  group is finitely generated.\" Translate the natural language version to a Lean mathlib version:\n theorem subgroup.fg_of_index_ne_zero{G : Type u_1} [group G] {H : subgroup G} [hG : group.fg G] (hH : H.index ≠ 0) :\ngroup.fg ↥H := \n\nNatural language version: \"Direct products of torsion free groups are torsion free.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.prod{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) :\nmonoid.is_torsion_free (Π (i : η), Gs i) := \n\nNatural language version: \"Quotienting a group by its torsion subgroup yields a torsion free group.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.quotient_torsion(G : Type u_1) [comm_group G] :\nmonoid.is_torsion_free (G ⧸ torsion G) := \n\nNatural language version: \"Every index 2 subgroup of a group is free\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6636497974395752,
          "doc_string": "Subgroups of torsion-free groups are torsion-free.",
          "statement": "theorem is_torsion_free.subgroup {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) : monoid.is_torsion_free ↥H"
        },
        {
          "sim_score": 0.5494142770767212,
          "doc_string": "**Schreier's Lemma**: A finite index subgroup of a finitely generated  group is finitely generated.",
          "statement": "theorem subgroup.fg_of_index_ne_zero {G : Type u_1} [group G] {H : subgroup G} [hG : group.fg G] (hH : H.index ≠ 0) : group.fg ↥H"
        },
        {
          "sim_score": 0.5431281924247742,
          "doc_string": "Direct products of torsion free groups are torsion free.",
          "statement": "theorem is_torsion_free.prod {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i)"
        },
        {
          "sim_score": 0.5406138896942139,
          "doc_string": "Quotienting a group by its torsion subgroup yields a torsion free group.",
          "statement": "theorem is_torsion_free.quotient_torsion (G : Type u_1) [comm_group G] : monoid.is_torsion_free (G ⧸ torsion G)"
        }
      ],
      "codex_time": 11.474060665990692,
      "search_time": 1.4575754079851322,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem group.free_of_is_free (G : Type u_1) [Group G] (I : Type u_2) [Group I] (H : Subgroup I) (hI : 2 ∣ H.index) : is_free ↥H ",
      "theorem group.free_of_is_free (G : Type u_1) [Groupₓₓ G] (I : Type u_2) [Groupₓₓ I] (H : Subgroup I) (hI : 2 ∣ H.index) : is_free ↥H ",
      "theorem group.free_of_is_free (G : Type u_1) [Groupₓ G] (I : Type u_2) [Groupₓ I] (H : Subgroup I) (hI : 2 ∣ H.index) : is_free ↥H ",
      "theorem is_free.index_eq_two{G : Type u_1} [Group G] {H : Subgroup G} [FreeGroup G] (hH : H.index = 2) : is_free ↥H ",
      "theorem is_free.index_eq_two{G : Type u_1} [Groupₓₓ G] {H : Subgroup G} [FreeGroup G] (hH : H.index = 2) : is_free ↥H ",
      "theorem is_free.index_eq_two{G : Type u_1} [Groupₓ G] {H : Subgroup G} [FreeGroup G] (hH : H.index = 2) : is_free ↥H ",
      "theorem subgroup.free_of_index_eq_two{G : Type u_1} [Group G] {H : Subgroup G} (hHind : H.index = 2) : FreeGroup H ",
      "theorem subgroup.free_of_index_eq_two{G : Type u_1} [Groupₓₓ G] {H : Subgroup G} (hHind : H.index = 2) : FreeGroup H ",
      "theorem subgroup.free_of_index_eq_two{G : Type u_1} [Groupₓ G] {H : Subgroup G} (hHind : H.index = 2) : FreeGroup H ",
      "theorem is_free.subgroup_index2_of_generators{G : Type u_1} [Group G] {g : ℕ → G} (gh : IsGroupHom ℕ G g) (hg : ∀ n, 0 < n → ∃ m hm, g n ≠ g m) : ∀ m > 0, is_free G (subgroup_index2_of_generators g gh hg m) ",
      "theorem is_free.subgroup_index2_of_generators{G : Type u_1} [Groupₓₓ G] {g : ℕ → G} (gh : IsGroupHom ℕ G g) (hg : ∀ n, 0 < n → ∃ m hm, g n ≠ g m) : ∀ m > 0, is_free G (subgroup_index2_of_generators g gh hg m) ",
      "theorem is_free.subgroup_index2_of_generators{G : Type u_1} [Groupₓ G] {g : ℕ → G} (gh : IsGroupHom ℕ G g) (hg : ∀ n, 0 < n → ∃ m hm, g n ≠ g m) : ∀ m > 0, is_free G (subgroup_index2_of_generators g gh hg m) ",
      "theorem subgroup.free_of_index_two(G : Type u_1) [Group G] (H : Subgroup G) (hH : H.index = 2) : @FreeGroup G _ H ",
      "theorem subgroup.free_of_index_two(G : Type u_1) [Groupₓₓ G] (H : Subgroup G) (hH : H.index = 2) : @FreeGroup G _ H ",
      "theorem subgroup.free_of_index_two(G : Type u_1) [Groupₓ G] (H : Subgroup G) (hH : H.index = 2) : @FreeGroup G _ H "
    ],
    "answer": "theorem index_two_subgroup {G : Type _} [Groupₓ G] (H : Subgroup G): H.index = 2 → Subgroup.Normal H "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "index_two_subgroup",
      "main_prompt": "Every index 2 subgroup of a group is free",
      "prompt": "Natural language version: \"Every index 2 subgroup of a group is free\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 7.056525922002038,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem every_index2_subgrp_is_free (G) {e : FreeGroup G} :      ∀ n, n ∈ ((subgroups_of G).ker.range) → IsFreeGroup finset.free_group (F ∩ H n) -- Note that I don't Even have to put \"sorry\" anymore.   | n h' ",
      "theorem Every_index2_subgroup_is_free_mathlib_statement : ∀ G : Group, ∀ H : Subgroup G, H.card ≤ 2 ∧ H.card > 1 → ∀ x : G.carrier, ∀ y : G.carrier, H.genSubgroup.subset {y*x} → free H.genSubgroup.subset. Proof. ... The universal quantifier is where I'm getting confused. Should I be setting up some sort of induction on H.genSubgroup.subset or Group elements? Does anyone have any advice on this sort of problem?   A:  The statement is not correct. Let",
      "theorem Every_index2_subgroup_is_free_mathlib_statement : ∀ G : Groupₓₓ, ∀ H : Subgroup G, H.card ≤ 2 ∧ H.card > 1 → ∀ x : G.carrier, ∀ y : G.carrier, H.genSubgroup.subset {y*x} → free H.genSubgroup.subset. Proof. ... The universal quantifier is where I'm getting confused. Should I be setting up some sort of induction on H.genSubgroup.subset or Groupₓₓ elements? Does anyone have any advice on this sort of problem?   A:  The statement is not correct. Let",
      "theorem Every_index2_subgroup_is_free_mathlib_statement : ∀ G : Groupₓ, ∀ H : Subgroup G, H.card ≤ 2 ∧ H.card > 1 → ∀ x : G.carrier, ∀ y : G.carrier, H.genSubgroup.subset {y*x} → free H.genSubgroup.subset. Proof. ... The universal quantifier is where I'm getting confused. Should I be setting up some sort of induction on H.genSubgroup.subset or Groupₓ elements? Does anyone have any advice on this sort of problem?   A:  The statement is not correct. Let",
      "theorem second_subgroup_free {G : Type*} [Group G] (H : Subgroup G) : is_free G (λ X : Set G, set.card X = 2) ",
      "theorem second_subgroup_free {G : Type*} [Groupₓₓ G] (H : Subgroup G) : is_free G (λ X : Set G, set.card X = 2) ",
      "theorem second_subgroup_free {G : Type*} [Group G] (H : Subgroup G) : is_free G (λ X : Setₓ G, set.card X = 2) ",
      "theorem second_subgroup_free {G : Type*} [Groupₓₓ G] (H : Subgroup G) : is_free G (λ X : Setₓ G, set.card X = 2) ",
      "theorem second_subgroup_free {G : Type*} [Groupₓ G] (H : Subgroup G) : is_free G (λ X : Set G, set.card X = 2) ",
      "theorem second_subgroup_free {G : Type*} [Groupₓ G] (H : Subgroup G) : is_free G (λ X : Setₓ G, set.card X = 2) ",
      "theorem F ( α : Type ) [ Group α ] : ∀ i : Finset [ Group α ], card i = 2 → i . to_finset . IsSubgroup → i . to_finset . is_free  Why does it work?  Are there any axioms left for you to figure out?   Final question (for now): Suppose someone gives you a Lean term that you believe to be True, but you can't prove it. How can you proceed? - try to phrase it as a lemma and then use #print axioms as above - What do you expect/hope to see? - What can you gain from this procedure?  ",
      "theorem F ( α : Type ) [ Groupₓₓ α ] : ∀ i : Finset [ Groupₓₓ α ], card i = 2 → i . to_finset . IsSubgroup → i . to_finset . is_free  Why does it work?  Are there any axioms left for you to figure out?   Final question (for now): Suppose someone gives you a Lean term that you believe to be True, but you can't prove it. How can you proceed? - try to phrase it as a lemma and then use #print axioms as above - What do you expect/hope to see? - What can you gain from this procedure?  ",
      "theorem F ( α : Type ) [ Groupₓ α ] : ∀ i : Finset [ Groupₓ α ], card i = 2 → i . to_finset . IsSubgroup → i . to_finset . is_free  Why does it work?  Are there any axioms left for you to figure out?   Final question (for now): Suppose someone gives you a Lean term that you believe to be True, but you can't prove it. How can you proceed? - try to phrase it as a lemma and then use #print axioms as above - What do you expect/hope to see? - What can you gain from this procedure?  ",
      "theorem every_sub.sub_free : ∀ n : ℕ, n < 1 → every_sub.sub_free (1 : ℤ) "
    ],
    "answer": "theorem index_two_subgroup {G : Type _} [Groupₓ G] (H : Subgroup G): H.index = 2 → Subgroup.Normal H "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "subgpFree",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every subgroup of a free group is free\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every subgroup of a free group is free",
      "codex_time": 5.209705468994798,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem free_group.subgroup.free {α} [G : FreeGroup α] (H : Subgroup G) : FreeGroup H ",
      "theorem subgroup_of_free_group_is_free {G : Type*} [FreeGroup G] (H : Set G) (H_subgroup : IsSubgroup H) : FreeGroup H ",
      "theorem subgroup_of_free_group_is_free {G : Type*} [FreeGroup G] (H : Setₓ G) (H_subgroup : IsSubgroup H) : FreeGroup H ",
      "theorem subgroup_of_free_group_is_free (G : Type*) [Group G] (M : Set G) (hM : IsSubgroup M) :  FreeGroup M ",
      "theorem subgroup_of_free_group_is_free (G : Type*) [Groupₓₓ G] (M : Set G) (hM : IsSubgroup M) :  FreeGroup M ",
      "theorem subgroup_of_free_group_is_free (G : Type*) [Group G] (M : Setₓ G) (hM : IsSubgroup M) :  FreeGroup M ",
      "theorem subgroup_of_free_group_is_free (G : Type*) [Groupₓₓ G] (M : Setₓ G) (hM : IsSubgroup M) :  FreeGroup M ",
      "theorem subgroup_of_free_group_is_free (G : Type*) [Groupₓ G] (M : Set G) (hM : IsSubgroup M) :  FreeGroup M ",
      "theorem subgroup_of_free_group_is_free (G : Type*) [Groupₓ G] (M : Setₓ G) (hM : IsSubgroup M) :  FreeGroup M ",
      "theorem subgroup_of_free_group_is_free {α : Type*} (s : Set (FreeAbelianGroup α))  (h0 : @Zero _ s = 0) (h1 : @One _ s = 1) (hs : @Mul _ s _ _ (@One _ s _ (@Zero _ s))) :  is_free (FreeAbelianGroup α) s ",
      "theorem subgroup_of_free_group_is_free {α : Type*} (s : Setₓ (FreeAbelianGroup α))  (h0 : @Zero _ s = 0) (h1 : @One _ s = 1) (hs : @Mul _ s _ _ (@One _ s _ (@Zero _ s))) :  is_free (FreeAbelianGroup α) s ",
      "theorem subgroup_of_free_group_is_free_group {α : Type*}  (h : Group α) (f : FreeGroup h) :  ∀ (n : Subgroup f), FreeGroup n ",
      "theorem subgroup_of_free_group_is_free_group {α : Type*}  (h : Groupₓₓ α) (f : FreeGroup h) :  ∀ (n : Subgroup f), FreeGroup n ",
      "theorem subgroup_of_free_group_is_free_group {α : Type*}  (h : Groupₓ α) (f : FreeGroup h) :  ∀ (n : Subgroup f), FreeGroup n "
    ],
    "answer": "theorem subgpFree {G : Type _} [Groupₓ G] : (K : Subgroup G) → Σ β, FreeGroup β ≃* ↥K "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "subgpFree",
      "main_prompt": "Every subgroup of a free group is free",
      "prompt": "Natural language version: \"Subgroups of torsion-free groups are torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.subgroup{G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) :\nmonoid.is_torsion_free ↥H := \n\nNatural language version: \"Quotienting a group by its torsion subgroup yields a torsion free group.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.quotient_torsion(G : Type u_1) [comm_group G] :\nmonoid.is_torsion_free (G ⧸ torsion G) := \n\nNatural language version: \"Subgroups of additive torsion-free groups are additively torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.add_subgroup{G : Type u_1} [add_group G] (tG : add_monoid.is_torsion_free G) (H : add_subgroup G) :\nadd_monoid.is_torsion_free ↥H := \n\nNatural language version: \"Direct products of torsion free groups are torsion free.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.prod{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) :\nmonoid.is_torsion_free (Π (i : η), Gs i) := \n\nNatural language version: \"Every subgroup of a free group is free\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.7357965111732483,
          "doc_string": "Subgroups of torsion-free groups are torsion-free.",
          "statement": "theorem is_torsion_free.subgroup {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) : monoid.is_torsion_free ↥H"
        },
        {
          "sim_score": 0.621972382068634,
          "doc_string": "Quotienting a group by its torsion subgroup yields a torsion free group.",
          "statement": "theorem is_torsion_free.quotient_torsion (G : Type u_1) [comm_group G] : monoid.is_torsion_free (G ⧸ torsion G)"
        },
        {
          "sim_score": 0.6199988722801208,
          "doc_string": "Subgroups of additive torsion-free groups are additively torsion-free.",
          "statement": "theorem is_torsion_free.add_subgroup {G : Type u_1} [add_group G] (tG : add_monoid.is_torsion_free G) (H : add_subgroup G) : add_monoid.is_torsion_free ↥H"
        },
        {
          "sim_score": 0.58650141954422,
          "doc_string": "Direct products of torsion free groups are torsion free.",
          "statement": "theorem is_torsion_free.prod {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i)"
        }
      ],
      "codex_time": 7.315295198990498,
      "search_time": 1.3809250470076222,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem free_of_free_subgroup.is_free{ι : Type u_1} (hs : ι → Type u_2) [Π (i : ι), Group (hs i)] (H : Π (i : ι), free_of_free_subgroup (hs i)) : FreeGroup (Π (i : ι), hs i) ",
      "theorem free_of_free_subgroup.is_free{ι : Type u_1} (hs : ι → Type u_2) [Π (i : ι), Groupₓₓ (hs i)] (H : Π (i : ι), free_of_free_subgroup (hs i)) : FreeGroup (Π (i : ι), hs i) ",
      "theorem free_of_free_subgroup.is_free{ι : Type u_1} (hs : ι → Type u_2) [Π (i : ι), Groupₓ (hs i)] (H : Π (i : ι), free_of_free_subgroup (hs i)) : FreeGroup (Π (i : ι), hs i) ",
      "theorem is_free.subgroup'{G : Type u_1} [Group G] (fG : monoid.is_free G) (H : Subgroup G) : monoid.is_free ↥H ",
      "theorem is_free.subgroup'{G : Type u_1} [Groupₓₓ G] (fG : monoid.is_free G) (H : Subgroup G) : monoid.is_free ↥H ",
      "theorem is_free.subgroup'{G : Type u_1} [Groupₓ G] (fG : monoid.is_free G) (H : Subgroup G) : monoid.is_free ↥H ",
      "theorem free_subgroup{η: Type u_2} [DecidableEq η] (S : Set η) (HS_subset_t : S ⊆ η) : Group (FreeGroup S) ",
      "theorem free_subgroup{η: Type u_2} [DecidableEq η] (S : Set η) (HS_subset_t : S ⊆ η) : Groupₓₓ (FreeGroup S) ",
      "theorem free_subgroup{η: Type u_2} [DecidableEq η] (S : Setₓ η) (HS_subset_t : S ⊆ η) : Group (FreeGroup S) ",
      "theorem free_subgroup{η: Type u_2} [DecidableEq η] (S : Setₓ η) (HS_subset_t : S ⊆ η) : Groupₓₓ (FreeGroup S) ",
      "theorem free_subgroup{η: Type u_2} [DecidableEq η] (S : Set η) (HS_subset_t : S ⊆ η) : Groupₓ (FreeGroup S) ",
      "theorem free_subgroup{η: Type u_2} [DecidableEq η] (S : Setₓ η) (HS_subset_t : S ⊆ η) : Groupₓ (FreeGroup S) ",
      "theorem is_free.subgroup(X : Type v_1 u_1) [DecidableEq X] [FreeGroup F] (H : Subgroup F) (Xf : is_generator_set X (↑H) set.finite_to_set) : is_free X (↑H) ",
      "theorem free.subgroup(S : Type u_1) [Group S] (fS : FreeGroup S) (H : Subgroup S) : FreeGroup ↥H ",
      "theorem free.subgroup(S : Type u_1) [Groupₓₓ S] (fS : FreeGroup S) (H : Subgroup S) : FreeGroup ↥H ",
      "theorem free.subgroup(S : Type u_1) [Groupₓ S] (fS : FreeGroup S) (H : Subgroup S) : FreeGroup ↥H "
    ],
    "answer": "theorem subgpFree {G : Type _} [Groupₓ G] : (K : Subgroup G) → Σ β, FreeGroup β ≃* ↥K "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "subgpFree",
      "main_prompt": "Every subgroup of a free group is free",
      "prompt": "Natural language version: \"Every subgroup of a free group is free\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 7.116309869015822,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem subgroup_of_free_group_is_free : ∀ G : Group, Subgroup G (FreeGroup G) ",
      "theorem subgroup_of_free_group_is_free : ∀ G : Groupₓₓ, Subgroup G (FreeGroup G) ",
      "theorem subgroup_of_free_group_is_free : ∀ G : Groupₓ, Subgroup G (FreeGroup G) ",
      "theorem subgroup_of_free_group_is_free (G : Type) [Group G] (g : G) :    IsSubgroup G g -> IsFreeGroup (subgroup.subtype g) ",
      "theorem subgroup_of_free_group_is_free (G : Type) [Groupₓₓ G] (g : G) :    IsSubgroup G g -> IsFreeGroup (subgroup.subtype g) ",
      "theorem subgroup_of_free_group_is_free (G : Type) [Groupₓ G] (g : G) :    IsSubgroup G g -> IsFreeGroup (subgroup.subtype g) ",
      "theorem every_subgroup_of_a_free_group_is_free (G : Type) [Group G] [FreeGroup G] :  ∀ [Subgroup K] , ∃ X : Set G , X ∈ fin_gen G ∧ IsSubgroup (subgroup_generated_by X) K ∧ FreeGroup (subgroup_generated_by X)  Proof.  intros K,  This is where I got stuck. I'm not sure how to prove the subgroup_generated_by X part. I understand that I need to show that all elements of K are equal to Group operators. But I'm not sure how to do that in lean. ",
      "theorem every_subgroup_of_a_free_group_is_free (G : Type) [Groupₓₓ G] [FreeGroup G] :  ∀ [Subgroup K] , ∃ X : Set G , X ∈ fin_gen G ∧ IsSubgroup (subgroup_generated_by X) K ∧ FreeGroup (subgroup_generated_by X)  Proof.  intros K,  This is where I got stuck. I'm not sure how to prove the subgroup_generated_by X part. I understand that I need to show that all elements of K are equal to Groupₓₓ operators. But I'm not sure how to do that in lean. ",
      "theorem every_subgroup_of_a_free_group_is_free (G : Type) [Group G] [FreeGroup G] :  ∀ [Subgroup K] , ∃ X : Setₓ G , X ∈ fin_gen G ∧ IsSubgroup (subgroup_generated_by X) K ∧ FreeGroup (subgroup_generated_by X)  Proof.  intros K,  This is where I got stuck. I'm not sure how to prove the subgroup_generated_by X part. I understand that I need to show that all elements of K are equal to Group operators. But I'm not sure how to do that in lean. ",
      "theorem every_subgroup_of_a_free_group_is_free (G : Type) [Groupₓₓ G] [FreeGroup G] :  ∀ [Subgroup K] , ∃ X : Setₓ G , X ∈ fin_gen G ∧ IsSubgroup (subgroup_generated_by X) K ∧ FreeGroup (subgroup_generated_by X)  Proof.  intros K,  This is where I got stuck. I'm not sure how to prove the subgroup_generated_by X part. I understand that I need to show that all elements of K are equal to Groupₓₓ operators. But I'm not sure how to do that in lean. ",
      "theorem every_subgroup_of_a_free_group_is_free (G : Type) [Groupₓ G] [FreeGroup G] :  ∀ [Subgroup K] , ∃ X : Set G , X ∈ fin_gen G ∧ IsSubgroup (subgroup_generated_by X) K ∧ FreeGroup (subgroup_generated_by X)  Proof.  intros K,  This is where I got stuck. I'm not sure how to prove the subgroup_generated_by X part. I understand that I need to show that all elements of K are equal to Groupₓ operators. But I'm not sure how to do that in lean. ",
      "theorem every_subgroup_of_a_free_group_is_free (G : Type) [Groupₓ G] [FreeGroup G] :  ∀ [Subgroup K] , ∃ X : Setₓ G , X ∈ fin_gen G ∧ IsSubgroup (subgroup_generated_by X) K ∧ FreeGroup (subgroup_generated_by X)  Proof.  intros K,  This is where I got stuck. I'm not sure how to prove the subgroup_generated_by X part. I understand that I need to show that all elements of K are equal to Groupₓ operators. But I'm not sure how to do that in lean. ",
      "theorem subgroup_of_free_group_is_free ( G : Group ) ( H : Subgroup G ) :   ∃ ( A : Type ) ( g : A →* G ), IsFreeGroup g G  To prove this, I need to customize IsFreeGroup to work on subgroups, not merely types. -/  import algebra.group.basic    /-! # Subgroups  ## Main Definitions  The type `Subgroup`, and how to build one.  ## Main Statements  Any Subgroup of a free Group is free. -/    -- We mainly work with free groups, made with is_free_",
      "theorem subgroup_of_free_group_is_free ( G : Groupₓₓ ) ( H : Subgroup G ) :   ∃ ( A : Type ) ( g : A →* G ), IsFreeGroup g G  To prove this, I need to customize IsFreeGroup to work on subgroups, not merely types. -/  import algebra.group.basic    /-! # Subgroups  ## Main Definitions  The type `Subgroup`, and how to build one.  ## Main Statements  Any Subgroup of a free Groupₓₓ is free. -/    -- We mainly work with free groups, made with is_free_",
      "theorem subgroup_of_free_group_is_free ( G : Groupₓ ) ( H : Subgroup G ) :   ∃ ( A : Type ) ( g : A →* G ), IsFreeGroup g G  To prove this, I need to customize IsFreeGroup to work on subgroups, not merely types. -/  import algebra.group.basic    /-! # Subgroups  ## Main Definitions  The type `Subgroup`, and how to build one.  ## Main Statements  Any Subgroup of a free Groupₓ is free. -/    -- We mainly work with free groups, made with is_free_",
      "theorem {u v : Type u} [Fintype u] (h : Fintype.card = Fintype.card) (H1 : Inhabited u) (H2 : Inhabited v) : Inhabited (ulift (u × v)) ",
      "theorem {u v : Type u} [Fintypeₓ u] (h : Fintypeₓ.card = Fintypeₓ.card) (H1 : Inhabited u) (H2 : Inhabited v) : Inhabited (ulift (u × v)) "
    ],
    "answer": "theorem subgpFree {G : Type _} [Groupₓ G] : (K : Subgroup G) → Σ β, FreeGroup β ≃* ↥K "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "free_group_torsion_free",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every free group is torsion free\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every free group is torsion free",
      "codex_time": 7.478738637000788,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem free_implies_torsion_free (G : Type*) [Group G] (H : Set G)  (f : G →* H) (hs : f.injective) (H_free : IsFreeGroup H) :  is_torsion_free G ",
      "theorem free_implies_torsion_free (G : Type*) [Groupₓₓ G] (H : Set G)  (f : G →* H) (hs : f.injective) (H_free : IsFreeGroup H) :  is_torsion_free G ",
      "theorem free_implies_torsion_free (G : Type*) [Group G] (H : Setₓ G)  (f : G →* H) (hs : f.injective) (H_free : IsFreeGroup H) :  is_torsion_free G ",
      "theorem free_implies_torsion_free (G : Type*) [Groupₓₓ G] (H : Setₓ G)  (f : G →* H) (hs : f.injective) (H_free : IsFreeGroup H) :  is_torsion_free G ",
      "theorem free_implies_torsion_free (G : Type*) [Groupₓ G] (H : Set G)  (f : G →* H) (hs : f.injective) (H_free : IsFreeGroup H) :  is_torsion_free G ",
      "theorem free_implies_torsion_free (G : Type*) [Groupₓ G] (H : Setₓ G)  (f : G →* H) (hs : f.injective) (H_free : IsFreeGroup H) :  is_torsion_free G ",
      "theorem free_group_is_torsion_free (G : Type*) [Group G]  (hG : is_free (↑G : Set G)) : is_torsion_free (↑G : Set G) ",
      "theorem free_group_is_torsion_free (G : Type*) [Groupₓₓ G]  (hG : is_free (↑G : Set G)) : is_torsion_free (↑G : Set G) ",
      "theorem free_group_is_torsion_free (G : Type*) [Group G]  (hG : is_free (↑G : Setₓ G)) : is_torsion_free (↑G : Setₓ G) ",
      "theorem free_group_is_torsion_free (G : Type*) [Groupₓₓ G]  (hG : is_free (↑G : Setₓ G)) : is_torsion_free (↑G : Setₓ G) ",
      "theorem free_group_is_torsion_free (G : Type*) [Groupₓ G]  (hG : is_free (↑G : Set G)) : is_torsion_free (↑G : Set G) ",
      "theorem free_group_is_torsion_free (G : Type*) [Groupₓ G]  (hG : is_free (↑G : Setₓ G)) : is_torsion_free (↑G : Setₓ G) ",
      "theorem free_group_is_torsion_free (G : Type*) [Group G]  (hG : ∀ x : G, x ≠ 1 → ∃ y : G, y ^ 2 = x) :  group.torsion_free G ",
      "theorem free_group_is_torsion_free (G : Type*) [Groupₓₓ G]  (hG : ∀ x : G, x ≠ 1 → ∃ y : G, y ^ 2 = x) :  group.torsion_free G ",
      "theorem free_group_is_torsion_free (G : Type*) [Groupₓ G]  (hG : ∀ x : G, x ≠ 1 → ∃ y : G, y ^ 2 = x) :  group.torsion_free G ",
      "theorem free_group_is_torsion_free (G : Type*) [Group G] (f : FreeGroup G) :  ∀ x : FreeGroup G, x ≠ 1 → (∃ n : ℕ, x = (n : ℕ) • x) → False ",
      "theorem free_group_is_torsion_free (G : Type*) [Groupₓₓ G] (f : FreeGroup G) :  ∀ x : FreeGroup G, x ≠ 1 → (∃ n : ℕ, x = (n : ℕ) • x) → False ",
      "theorem free_group_is_torsion_free (G : Type*) [Groupₓ G] (f : FreeGroup G) :  ∀ x : FreeGroup G, x ≠ 1 → (∃ n : ℕ, x = (n : ℕ) • x) → False ",
      "theorem free_is_torsion_free (G : Type*) [Group G] (H : Subgroup G)  (hH : FreeGroup H) : torsion_free G ",
      "theorem free_is_torsion_free (G : Type*) [Groupₓₓ G] (H : Subgroup G)  (hH : FreeGroup H) : torsion_free G ",
      "theorem free_is_torsion_free (G : Type*) [Groupₓ G] (H : Subgroup G)  (hH : FreeGroup H) : torsion_free G "
    ],
    "answer": "theorem free_group_torsion_free {α : Type} : Monoidₓ.IsTorsionFree (FreeGroup α) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "free_group_torsion_free",
      "main_prompt": "Every free group is torsion free",
      "prompt": "Natural language version: \"Subgroups of torsion-free groups are torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.subgroup{G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) :\nmonoid.is_torsion_free ↥H := \n\nNatural language version: \"A nontrivial torsion-free group is not torsion.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.not_torsion{G : Type u_1} [group G] [hN : nontrivial G] :\nmonoid.is_torsion_free G → ¬monoid.is_torsion G := \n\nNatural language version: \"Direct products of torsion free groups are torsion free.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.prod{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) :\nmonoid.is_torsion_free (Π (i : η), Gs i) := \n\nNatural language version: \"Direct products of additive torsion free groups are torsion free.\" Translate the natural language version to a Lean mathlib version:\n theorem add_monoid.is_torsion_free.prod{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_group (Gs i)] (tfGs : ∀ (i : η), add_monoid.is_torsion_free (Gs i)) :\nadd_monoid.is_torsion_free (Π (i : η), Gs i) := \n\nNatural language version: \"Every free group is torsion free\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.8580459356307983,
          "doc_string": "Subgroups of torsion-free groups are torsion-free.",
          "statement": "theorem is_torsion_free.subgroup {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) : monoid.is_torsion_free ↥H"
        },
        {
          "sim_score": 0.8004929423332214,
          "doc_string": "A nontrivial torsion-free group is not torsion.",
          "statement": "theorem is_torsion_free.not_torsion {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G → ¬monoid.is_torsion G"
        },
        {
          "sim_score": 0.7987847924232483,
          "doc_string": "Direct products of torsion free groups are torsion free.",
          "statement": "theorem is_torsion_free.prod {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i)"
        },
        {
          "sim_score": 0.7854448556900024,
          "doc_string": "Direct products of additive torsion free groups are torsion free.",
          "statement": "theorem add_monoid.is_torsion_free.prod {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_group (Gs i)] (tfGs : ∀ (i : η), add_monoid.is_torsion_free (Gs i)) : add_monoid.is_torsion_free (Π (i : η), Gs i)"
        }
      ],
      "codex_time": 5.630564228980802,
      "search_time": 1.4791829389869235,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem free_group.is_torsion_free{α : Type u_1} : Monoidₓ.IsTorsionFree (FreeGroup α) ",
      "theorem free_group.is_torsion_free{n : Type u_1} {α : Type u_2} [Group α] [Fintype n] : Monoidₓ.IsTorsionFree (FreeGroup n α) ",
      "theorem free_group.is_torsion_free{n : Type u_1} {α : Type u_2} [Groupₓₓ α] [Fintype n] : Monoidₓ.IsTorsionFree (FreeGroup n α) ",
      "theorem free_group.is_torsion_free{n : Type u_1} {α : Type u_2} [Groupₓ α] [Fintype n] : Monoidₓ.IsTorsionFree (FreeGroup n α) ",
      "theorem free_group.is_torsion_free{n : Type u_1} {α : Type u_2} [Group α] [Fintypeₓ n] : Monoidₓ.IsTorsionFree (FreeGroup n α) ",
      "theorem free_group.is_torsion_free{n : Type u_1} {α : Type u_2} [Groupₓₓ α] [Fintypeₓ n] : Monoidₓ.IsTorsionFree (FreeGroup n α) ",
      "theorem free_group.is_torsion_free{n : Type u_1} {α : Type u_2} [Groupₓ α] [Fintypeₓ n] : Monoidₓ.IsTorsionFree (FreeGroup n α) ",
      "theorem free_group.is_torsion_free{α : Type u_1} (s : Set α) : Monoidₓ.IsTorsionFree (FreeGroup s) ",
      "theorem free_group.is_torsion_free{α : Type u_1} (s : Setₓ α) : Monoidₓ.IsTorsionFree (FreeGroup s) ",
      "theorem is_torsion_free.free_group{α : Type u_1} [Fintype α] (tG : Monoidₓ.IsTorsion (FreeGroup α)) : is_torsion_free (FreeGroup α) ",
      "theorem is_torsion_free.free_group{α : Type u_1} [Fintypeₓ α] (tG : Monoidₓ.IsTorsion (FreeGroup α)) : is_torsion_free (FreeGroup α) ",
      "theorem free_group.is_torsion_free{α : Type u} [FreeGroup α] : Monoidₓ.IsTorsionFree (FreeGroup.of α) "
    ],
    "answer": "theorem free_group_torsion_free {α : Type} : Monoidₓ.IsTorsionFree (FreeGroup α) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "free_group_torsion_free",
      "main_prompt": "Every free group is torsion free",
      "prompt": "Natural language version: \"Every free group is torsion free\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 7.198624655022286,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem : ∀ G : Type , ( FreeGroup G ) → ( torsion_free G ) ",
      "theorem free_group_is_torsion_free (G : Type) [Group G] [fb : FreeGroup G] : torsion_free G ",
      "theorem free_group_is_torsion_free (G : Type) [Groupₓₓ G] [fb : FreeGroup G] : torsion_free G ",
      "theorem free_group_is_torsion_free (G : Type) [Groupₓ G] [fb : FreeGroup G] : torsion_free G ",
      "theorem freepreserves_tf : ∀ G : mygroup, is_free G → torsion_free G. So in plain words we are trying to prove that free groups are torsion free. Moreover, the question we want to answer is for what groups this statement is True, so the proposition we want is of the form X → Y, where X is the Set of groups for which the statement is True, and Y is the Set of groups for which the statement is not true. Now we start constructing the sample solution:  1) Refine the statement. Note that the object of study here is the Set of groups that are not torsion free. At some point we will have to prove is_",
      "theorem freepreserves_tf : ∀ G : mygroup, is_free G → torsion_free G. So in plain words we are trying to prove that free groups are torsion free. Moreover, the question we want to answer is for what groups this statement is True, so the proposition we want is of the form X → Y, where X is the Setₓ of groups for which the statement is True, and Y is the Setₓ of groups for which the statement is not true. Now we start constructing the sample solution:  1) Refine the statement. Note that the object of study here is the Setₓ of groups that are not torsion free. At some point we will have to prove is_",
      "theorem free_group.is_torsion_free :   ∀ (G : Type u)[FreeGroup G] [is_torsion G],   False ",
      "theorem Q1005 : ∀ G : Type , (( ∀ R : Type , (IsSubgroup G R) → False) → (∀ {x : G}, has_order G x → 1=x)) →  (IsFreeGroup G) → (is_torsion_free_group G) .   translate  \"For any type G such that such that if (any Subgroup R of G is False) then  (for any x of type G, if x has_order then x=1), if G  is a free Group then G is a torsion free Group\"     Reasoning in Lean:  Proof Succinct. Precise",
      "theorem Q1005 : ∀ G : Type , (( ∀ R : Type , (IsSubgroup G R) → False) → (∀ {x : G}, has_order G x → 1=x)) →  (IsFreeGroup G) → (is_torsion_free_group G) .   translate  \"For any type G such that such that if (any Subgroup R of G is False) then  (for any x of type G, if x has_order then x=1), if G  is a free Groupₓₓ then G is a torsion free Groupₓₓ\"     Reasoning in Lean:  Proof Succinct. Precise",
      "theorem Q1005 : ∀ G : Type , (( ∀ R : Type , (IsSubgroup G R) → False) → (∀ {x : G}, has_order G x → 1=x)) →  (IsFreeGroup G) → (is_torsion_free_group G) .   translate  \"For any type G such that such that if (any Subgroup R of G is False) then  (for any x of type G, if x has_order then x=1), if G  is a free Groupₓ then G is a torsion free Groupₓ\"     Reasoning in Lean:  Proof Succinct. Precise"
    ],
    "answer": "theorem free_group_torsion_free {α : Type} : Monoidₓ.IsTorsionFree (FreeGroup α) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "integer_subgroups",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every non-empty subgroup of `ℤ` is isomorphic to `ℤ`\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every non-empty subgroup of `ℤ` is isomorphic to `ℤ`",
      "codex_time": 5.7116632999968715,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem nonempty_Zgroup_nonempty_int : ∀ G : Type*,  [Group G] → (1 : G) ≠ 1 → G ≃ ℤ ",
      "theorem nonempty_Zgroup_nonempty_int : ∀ G : Type*,  [Groupₓₓ G] → (1 : G) ≠ 1 → G ≃ ℤ ",
      "theorem nonempty_Zgroup_nonempty_int : ∀ G : Type*,  [Groupₓ G] → (1 : G) ≠ 1 → G ≃ ℤ ",
      "theorem every_nontrivial_subgroup_of_Z_isomorphic_to_Z (S : Subgroup ℤ) (hS : S ≠ ⊥) :  S ≃* ℤ ",
      "theorem Z_is_divisible (G : Type*) [AddGroup G] (h : ∀ g : G, g ≠ 0 → ∃ n : ℤ, n • g = 0) :  ∃ (H : Type*) [AddGroup H], G ≃ Z ",
      "theorem Z_is_divisible (G : Type*) [AddGroupₓₓ G] (h : ∀ g : G, g ≠ 0 → ∃ n : ℤ, n • g = 0) :  ∃ (H : Type*) [AddGroupₓₓ H], G ≃ Z ",
      "theorem Z_is_divisible (G : Type*) [AddGroupₓ G] (h : ∀ g : G, g ≠ 0 → ∃ n : ℤ, n • g = 0) :  ∃ (H : Type*) [AddGroupₓ H], G ≃ Z ",
      "theorem nonempty_subgroup_isomorphic_z (G : Type*) [Group G] (H : Set G) (hH : H ≠ ∅) :  @is_group_hom.left_cancel_fun _ _ int.Z_group_hom H ",
      "theorem nonempty_subgroup_isomorphic_z (G : Type*) [Groupₓₓ G] (H : Set G) (hH : H ≠ ∅) :  @is_group_hom.left_cancel_fun _ _ int.Z_group_hom H ",
      "theorem nonempty_subgroup_isomorphic_z (G : Type*) [Group G] (H : Setₓ G) (hH : H ≠ ∅) :  @is_group_hom.left_cancel_fun _ _ int.Z_group_hom H ",
      "theorem nonempty_subgroup_isomorphic_z (G : Type*) [Groupₓₓ G] (H : Setₓ G) (hH : H ≠ ∅) :  @is_group_hom.left_cancel_fun _ _ int.Z_group_hom H ",
      "theorem nonempty_subgroup_isomorphic_z (G : Type*) [Groupₓ G] (H : Set G) (hH : H ≠ ∅) :  @is_group_hom.left_cancel_fun _ _ int.Z_group_hom H ",
      "theorem nonempty_subgroup_isomorphic_z (G : Type*) [Groupₓ G] (H : Setₓ G) (hH : H ≠ ∅) :  @is_group_hom.left_cancel_fun _ _ int.Z_group_hom H ",
      "theorem nonempty_subgroup_integer_iso_integer (G : Type*) [Group G] (H : Subgroup G)  (hH : H ≠ {1}) : G ≃* (ℤ : Type*) ",
      "theorem nonempty_subgroup_integer_iso_integer (G : Type*) [Groupₓₓ G] (H : Subgroup G)  (hH : H ≠ {1}) : G ≃* (ℤ : Type*) ",
      "theorem nonempty_subgroup_integer_iso_integer (G : Type*) [Groupₓ G] (H : Subgroup G)  (hH : H ≠ {1}) : G ≃* (ℤ : Type*) "
    ],
    "answer": "theorem integer_subgroups (H : AddSubgroup ℤ) : H.Carrier.Nonempty  →   ↥H ≃+ ℤ "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "integer_subgroups",
      "main_prompt": "Every non-empty subgroup of `ℤ` is isomorphic to `ℤ`",
      "prompt": "Natural language version: \"Every subgroup of `ℤ` is cyclic.\" Translate the natural language version to a Lean mathlib version:\n theorem int.subgroup_cyclic(H : add_subgroup ℤ) :\n∃ (a : ℤ), H = add_subgroup.closure {a} := \n\nNatural language version: \"If the quotient by a subgroup gives a singleton then the subgroup is the whole group.\" Translate the natural language version to a Lean mathlib version:\n theorem quotient_group.subgroup_eq_top_of_subsingleton{G : Type u} [group G] (H : subgroup G) (h : subsingleton (G ⧸ H)) :\nH = ⊤ := \n\nNatural language version: \"The subgroup generated by a set includes the set.\" Translate the natural language version to a Lean mathlib version:\n theorem subgroup.subset_closure{G : Type u_1} [group G] {k : set G} :\nk ⊆ ↑(subgroup.closure k) := \n\nNatural language version: \"Two subgroups are equal if they have the same elements.\" Translate the natural language version to a Lean mathlib version:\n theorem subgroup.ext{G : Type u_1} [group G] {H K : subgroup G} (h : ∀ (x : G), x ∈ H ↔ x ∈ K) :\nH = K := \n\nNatural language version: \"Every non-empty subgroup of `ℤ` is isomorphic to `ℤ`\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.710217297077179,
          "doc_string": "Every subgroup of `ℤ` is cyclic.",
          "statement": "theorem int.subgroup_cyclic (H : add_subgroup ℤ) : ∃ (a : ℤ), H = add_subgroup.closure {a}"
        },
        {
          "sim_score": 0.5739960670471191,
          "doc_string": "If the quotient by a subgroup gives a singleton then the subgroup is the whole group.",
          "statement": "theorem quotient_group.subgroup_eq_top_of_subsingleton {G : Type u} [group G] (H : subgroup G) (h : subsingleton (G ⧸ H)) : H = ⊤"
        },
        {
          "sim_score": 0.5350345969200134,
          "doc_string": "The subgroup generated by a set includes the set.",
          "statement": "theorem subgroup.subset_closure {G : Type u_1} [group G] {k : set G} : k ⊆ ↑(subgroup.closure k)"
        },
        {
          "sim_score": 0.5225922465324402,
          "doc_string": "Two subgroups are equal if they have the same elements.",
          "statement": "theorem subgroup.ext {G : Type u_1} [group G] {H K : subgroup G} (h : ∀ (x : G), x ∈ H ↔ x ∈ K) : H = K"
        }
      ],
      "codex_time": 9.994682027987437,
      "search_time": 1.4260498700023163,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem int.subgroup_isomorphic_int(H : AddSubgroup ℤ) (h : (0:ℤ) ∈ H) : Nonempty (add_subgroup.quotient_add_group H) ∧ add_subgroup.quotient_add_group H ≃ₗ[ℤ] ℤ ",
      "theorem nonempty_int_subgroup_equiv_int{H : AddSubgroup ℤ} (hn : H ≠ ⊥) : H ≃ ℤ ",
      "theorem int.subgroup.of_ne_empty_one_isom_int{H : AddSubgroup ℤ} (h : (1 : ℤ) ∈ H) :  H ≃ ℤ ",
      "theorem int.nonempty_subgroup_injective(H : AddSubgroup ℤ) (h: ∃ (a : ℤ), a ∈ H) : injective (@int.add_group_hom_coe_nat : H → ℤ) ",
      "theorem subgroup.infinite_cyclic(H : Subgroup ℤ) (hne : ¬ ∀ x, x ∈ H → x = 0) : ∃ (a : ℤ), (∀(n : ℤ), n • a ∈ H) ∧ H ≃ₙ[AddMonoid ℤ] ℤ ",
      "theorem subgroup.infinite_cyclic(H : Subgroup ℤ) (hne : ¬ ∀ x, x ∈ H → x = 0) : ∃ (a : ℤ), (∀(n : ℤ), n • a ∈ H) ∧ H ≃ₙ[AddMonoidₓ ℤ] ℤ "
    ],
    "answer": "theorem integer_subgroups (H : AddSubgroup ℤ) : H.Carrier.Nonempty  →   ↥H ≃+ ℤ "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "integer_subgroups",
      "main_prompt": "Every non-empty subgroup of `ℤ` is isomorphic to `ℤ`",
      "prompt": "Natural language version: \"Every non-empty subgroup of `ℤ` is isomorphic to `ℤ`\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 11.630960176000372,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem is_subgroup_of_Z_isomorphic_to_Z {S : Subgroup ℤ} (H : S.val.nonempty) :    (S.1 : Set ℤ) ≃ ℤ ",
      "theorem is_subgroup_of_Z_isomorphic_to_Z {S : Subgroup ℤ} (H : S.val.nonempty) :    (S.1 : Setₓ ℤ) ≃ ℤ ",
      "theorem every_nonempty_int_subgroup_is_int { G : Type * } [ Group G ] ( h : ( 0 : G ) ≠ 1 ) : ∃ f : Int → G , @ IsGroupHom Int G f ⊢ f 0 = 0 ∧ f 1 = 1 ",
      "theorem every_nonempty_int_subgroup_is_int { G : Type * } [ Groupₓₓ G ] ( h : ( 0 : G ) ≠ 1 ) : ∃ f : Int → G , @ IsGroupHom Int G f ⊢ f 0 = 0 ∧ f 1 = 1 ",
      "theorem every_nonempty_int_subgroup_is_int { G : Type * } [ Groupₓ G ] ( h : ( 0 : G ) ≠ 1 ) : ∃ f : Int → G , @ IsGroupHom Int G f ⊢ f 0 = 0 ∧ f 1 = 1 ",
      "theorem subgroup_int :∀ x : Subgroup Int , (x ≠ ⊥) → x ≅ ℤ ",
      "theorem Z_subgroup_iso_Z : ∀ G : Group ℤ , ( 0 : ℤ ) ∈ G → ( ∃ f : G → ℤ , function . bijective f ∧ ∀ x y : G , f ( x * y ) = f x * f y )  This is an actual Mathlib theorem, that's not too hard to prove. (I also added it to the be_iso List)  imports group_theory_bundled import group_theorem_blog #check Z_subgroup_iso_Z  Imported classes and instances  Also the blog posts assume certain types of theorems and definitions ",
      "theorem Z_subgroup_iso_Z : ∀ G : Groupₓₓ ℤ , ( 0 : ℤ ) ∈ G → ( ∃ f : G → ℤ , function . bijective f ∧ ∀ x y : G , f ( x * y ) = f x * f y )  This is an actual Mathlib theorem, that's not too hard to prove. (I also added it to the be_iso List)  imports group_theory_bundled import group_theorem_blog #check Z_subgroup_iso_Z  Imported classes and instances  Also the blog posts assume certain types of theorems and definitions ",
      "theorem Z_subgroup_iso_Z : ∀ G : Groupₓ ℤ , ( 0 : ℤ ) ∈ G → ( ∃ f : G → ℤ , function . bijective f ∧ ∀ x y : G , f ( x * y ) = f x * f y )  This is an actual Mathlib theorem, that's not too hard to prove. (I also added it to the be_iso List)  imports group_theory_bundled import group_theorem_blog #check Z_subgroup_iso_Z  Imported classes and instances  Also the blog posts assume certain types of theorems and definitions ",
      "theorem z_dvd_iff_mod_eq_zero (n m : ℕ) : n ∣ m ↔ m % n = 0 "
    ],
    "answer": "theorem integer_subgroups (H : AddSubgroup ℤ) : H.Carrier.Nonempty  →   ↥H ≃+ ℤ "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "int_poly_rat_zeros_int",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"If the coefficients of a polynomial over rationals are integral, every rational root is integral.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If the coefficients of a polynomial over rationals are integral, every rational root is integral.",
      "codex_time": 10.176823131012497,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem integral_coeff_int_root (n : ℕ) (a : ℤ) (gcd_a_n : gcd n a = 1) :   ∀ (k : ℤ), Polynomial.eval (Polynomial.c a * X ^ n - 1) k = 0 → k = 0 ∨ k = 1 ",
      "theorem integral_coeffs_implies_integral_root {α : Type} [integral_domain α] (p : Polynomial α)  (h_coeffs : ∀ m : ℕ, m ≤ p.nat_degree → p.coeff m ∈ Set.Range (Coe : ℤ → α))  (root : α) (h_root : root ∣ p) : ∃ r : ℤ, root = (Coe r : α) ",
      "theorem integral_coeffs_implies_integral_root {α : Type} [integral_domain α] (p : Polynomial α)  (h_coeffs : ∀ m : ℕ, m ≤ p.nat_degree → p.coeff m ∈ Setₓ.Range (Coe : ℤ → α))  (root : α) (h_root : root ∣ p) : ∃ r : ℤ, root = (Coe r : α) ",
      "theorem integral_coeffs_rational_roots_int (f : Polynomial ℚ) (h₁ : integral_domain ℚ)  (h₂ : integral_domain ℤ) (h₃ : ∀ c ∈ f.coeffs, c : ℤ) (p : Polynomial ℚ)  (hp : p ≠ 0) (h_divides : p ∣ f) :  ∀ r, r ≠ 0 → root f r → r : ℤ ",
      "theorem rational_roots_are_integral (f : Polynomial ℤ) (hpf : ¬ is_zero f) :  (∀ x : ℚ, f.eval x = 0 → IsIntegral x) ",
      "theorem poly_of_rational_coeffs_integral_roots (f : Polynomial ℚ) :  integral_domain ℤ → (∃ a : ℤ, f.eval a = 0) → ∃ b : ℤ, f.eval b = 0 "
    ],
    "answer": "theorem int_poly_rat_zeros_int (p: Polynomial ℚ) : ∀ n: ℕ, IsIntegral ℚ (p.coeff n) →  ∀ x: ℚ, p.IsRoot x →  IsIntegral ℚ x "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "int_poly_rat_zeros_int",
      "main_prompt": "If the coefficients of a polynomial over rationals are integral, every rational root is integral.",
      "prompt": "Natural language version: \" Rational root theorem part 1: if `r : f.codomain` is a root of a polynomial over the ufd `A`, then the numerator of `r` divides the constant coefficient\" Translate the natural language version to a Lean mathlib version:\n theorem num_dvd_of_is_root{A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} {r : K} (hr : ⇑(polynomial.aeval r) p = 0) :\nis_fraction_ring.num A r ∣ p.coeff 0 := \n\nNatural language version: \" Integral root theorem: if `r : f.codomain` is a root of a monic polynomial over the ufd `A`, then `r` is an integer\" Translate the natural language version to a Lean mathlib version:\n theorem is_integer_of_is_root_of_monic{A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} (hp : p.monic) {r : K} (hr : ⇑(polynomial.aeval r) p = 0) :\nis_localization.is_integer A r := \n\nNatural language version: \" Rational root theorem part 2: if `r : f.codomain` is a root of a polynomial over the ufd `A`, then the denominator of `r` divides the leading coefficient\" Translate the natural language version to a Lean mathlib version:\n theorem denom_dvd_of_is_root{A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} {r : K} (hr : ⇑(polynomial.aeval r) p = 0) :\n↑(is_fraction_ring.denom A r) ∣ p.leading_coeff := \n\nNatural language version: \"This lemma is useful for working with the `int_degree` of a rational function.\" Translate the natural language version to a Lean mathlib version:\n theorem polynomial.nat_degree_sub_eq_of_prod_eq{R : Type u} [semiring R] [no_zero_divisors R] {p₁ p₂ q₁ q₂ : polynomial R} (hp₁ : p₁ ≠ 0) (hq₁ : q₁ ≠ 0) (hp₂ : p₂ ≠ 0) (hq₂ : q₂ ≠ 0) (h_eq : p₁ * q₂ = p₂ * q₁) :\n↑(p₁.nat_degree) - ↑(q₁.nat_degree) = ↑(p₂.nat_degree) - ↑(q₂.nat_degree) := \n\nNatural language version: \"If the coefficients of a polynomial over rationals are integral, every rational root is integral.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6362022161483765,
          "doc_string": " Rational root theorem part 1: if `r : f.codomain` is a root of a polynomial over the ufd `A`, then the numerator of `r` divides the constant coefficient",
          "statement": "theorem num_dvd_of_is_root {A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} {r : K} (hr : ⇑(polynomial.aeval r) p = 0) : is_fraction_ring.num A r ∣ p.coeff 0"
        },
        {
          "sim_score": 0.6275410652160645,
          "doc_string": " Integral root theorem: if `r : f.codomain` is a root of a monic polynomial over the ufd `A`, then `r` is an integer",
          "statement": "theorem is_integer_of_is_root_of_monic {A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} (hp : p.monic) {r : K} (hr : ⇑(polynomial.aeval r) p = 0) : is_localization.is_integer A r"
        },
        {
          "sim_score": 0.6202014684677124,
          "doc_string": " Rational root theorem part 2: if `r : f.codomain` is a root of a polynomial over the ufd `A`, then the denominator of `r` divides the leading coefficient",
          "statement": "theorem denom_dvd_of_is_root {A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} {r : K} (hr : ⇑(polynomial.aeval r) p = 0) : ↑(is_fraction_ring.denom A r) ∣ p.leading_coeff"
        },
        {
          "sim_score": 0.5798273086547852,
          "doc_string": "This lemma is useful for working with the `int_degree` of a rational function.",
          "statement": "theorem polynomial.nat_degree_sub_eq_of_prod_eq {R : Type u} [semiring R] [no_zero_divisors R] {p₁ p₂ q₁ q₂ : polynomial R} (hp₁ : p₁ ≠ 0) (hq₁ : q₁ ≠ 0) (hp₂ : p₂ ≠ 0) (hq₂ : q₂ ≠ 0) (h_eq : p₁ * q₂ = p₂ * q₁) : ↑(p₁.nat_degree) - ↑(q₁.nat_degree) = ↑(p₂.nat_degree) - ↑(q₂.nat_degree)"
        }
      ],
      "codex_time": 8.817720086983172,
      "search_time": 1.6466410249995533,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem is_integral_int_degree_of_eq{R : Type*} [integral_domain R] [Algebra ℚ R] (p : Polynomial R) (hp : ∀ r : R, 0 < r → r ∣ p.coeff 0) (r) (hr : Polynomial.aeval r p = 0) : r.is_integral ",
      "theorem is_root_of_monic_of_integral₁{R : Type u} [CommRing R] [IsDomain R] {p₁ : Polynomial (ℤ[X])} {p₂ : Polynomial R} (h_int : p₁.is_integral) (h_eq : p₂.coeff ↑(p₁.nat_degree) = p₁.coeff ↑(p₁.nat_degree)) (h_roots : ∀ y, (y : ℚ) = 0 ∨ y ∣ ↑(p₂.leading",
      "theorem is_root_of_monic_of_integral₁{R : Type u} [CommRingₓₓ R] [IsDomain R] {p₁ : Polynomial (ℤ[X])} {p₂ : Polynomial R} (h_int : p₁.is_integral) (h_eq : p₂.coeff ↑(p₁.nat_degree) = p₁.coeff ↑(p₁.nat_degree)) (h_roots : ∀ y, (y : ℚ) = 0 ∨ y ∣ ↑(p₂.leading",
      "theorem is_root_of_monic_of_integral₁{R : Type u} [CommRingₓ R] [IsDomain R] {p₁ : Polynomial (ℤ[X])} {p₂ : Polynomial R} (h_int : p₁.is_integral) (h_eq : p₂.coeff ↑(p₁.nat_degree) = p₁.coeff ↑(p₁.nat_degree)) (h_roots : ∀ y, (y : ℚ) = 0 ∨ y ∣ ↑(p₂.leading",
      "theorem is_integer_of_is_root_of_int_coeff{p : Polynomial ℚ} (h_int_coeff : p.coeffs_int) {x : ℚ} (h_root : p.eval x = 0) : is_rat_localization.is_integer x ",
      "theorem is_localization.is_integer_of_is_root_of_int{A : Type u_1} [CommRing A] [NoZeroDivisors A] {p : Polynomial A} (hp : p.is_int) {r : A} (hr : p.eval r = 0) : IsLocalization.IsInteger A r ",
      "theorem is_localization.is_integer_of_is_root_of_int{A : Type u_1} [CommRingₓₓ A] [NoZeroDivisors A] {p : Polynomial A} (hp : p.is_int) {r : A} (hr : p.eval r = 0) : IsLocalization.IsInteger A r ",
      "theorem is_localization.is_integer_of_is_root_of_int{A : Type u_1} [CommRingₓ A] [NoZeroDivisors A] {p : Polynomial A} (hp : p.is_int) {r : A} (hr : p.eval r = 0) : IsLocalization.IsInteger A r ",
      "theorem is_integral_of_roots_integral{R : Type u_1} [CommRing R] {p : Polynomial R} (hp : ∀ (i : ℕ), p.coeff i ∈ @submonoid.to_submodule ℤ ℤ (submonoid.of ℤ 1) _) {r : ℚ} (hr : Polynomial.aeval r p = 0) :  IsIntegral r ",
      "theorem is_integral_of_roots_integral{R : Type u_1} [CommRingₓₓ R] {p : Polynomial R} (hp : ∀ (i : ℕ), p.coeff i ∈ @submonoid.to_submodule ℤ ℤ (submonoid.of ℤ 1) _) {r : ℚ} (hr : Polynomial.aeval r p = 0) :  IsIntegral r ",
      "theorem is_integral_of_roots_integral{R : Type u_1} [CommRingₓ R] {p : Polynomial R} (hp : ∀ (i : ℕ), p.coeff i ∈ @submonoid.to_submodule ℤ ℤ (submonoid.of ℤ 1) _) {r : ℚ} (hr : Polynomial.aeval r p = 0) :  IsIntegral r "
    ],
    "answer": "theorem int_poly_rat_zeros_int (p: Polynomial ℚ) : ∀ n: ℕ, IsIntegral ℚ (p.coeff n) →  ∀ x: ℚ, p.IsRoot x →  IsIntegral ℚ x "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "int_poly_rat_zeros_int",
      "main_prompt": "If the coefficients of a polynomial over rationals are integral, every rational root is integral.",
      "prompt": "Natural language version: \"If the coefficients of a polynomial over rationals are integral, every rational root is integral.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 11.01090104598552,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem (is_root_integral : ∀ {τ : Type} [integral_domain τ] (f : Polynomial τ) [is_integral_polynomial f] {x : τ}, is_root f x) ",
      "theorem Nat . pow_root_integral ( a b : ℤ ) ( hba : b ≠ 0 ) ( n : Nat ) ( ha : a ≠ 0 ) : ( a ^ n ≠ b ) ",
      "theorem polya_folklore (f : Polynomial ℚ) (Hz : ∀ i, f.coeff i ∈ ℤ) : ¬ ∃ z : ℚ, z ≠ 0 ∧ z ∣ f.eval 0 ∧ ¬ z ∣ 0 ",
      "theorem int.coeff_then_int_root (α : Type) [integral_domain α] (as : List α) [h : int.coeffs as] (q : ℚ) {hq : q.denom = 1} (h : is_root as q) : q.num ∈ @int.set α ",
      "theorem poly_int_nat_prime_integral_root : ∀ 𝕜 [nontrivial_normed_field 𝕜] (a : ℕ) (r : ℚ),  (a : ℤ) ≠ 0 →  ∃ x : ℤ, x ∣ a ∧ r = (𝕜.to_real (rat.cast_int x))⁻¹ *   sqrt (𝕜.to_real (rat.cast_int a)) "
    ],
    "answer": "theorem int_poly_rat_zeros_int (p: Polynomial ℚ) : ∀ n: ℕ, IsIntegral ℚ (p.coeff n) →  ∀ x: ℚ, p.IsRoot x →  IsIntegral ℚ x "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "has_prime_factor",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every natural number greater than `1` is divisible by a prime number.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every natural number greater than `1` is divisible by a prime number.",
      "codex_time": 8.210922890983056,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem prime_divides_some_succ_of_nat {p : ℕ} (hp : Prime p) (n : ℕ) (h : 1 < n): ∃ k : ℕ, p ∣ succ k ∧ k < n ",
      "theorem nat.succ_ne_zero (n : ℕ) : nat.succ n ≠ 0 ",
      "theorem odd_nat.succ_pos_iff (n : ℕ) : Odd (n.succ) ↔ n.succ > 0 ",
      "theorem nat.ne_one_div_prime (n : ℕ) (hn : n ≠ 1) : ∃ p : ℕ, p.prime ∧ p ∣ n ",
      "theorem exists_prime_number_divides (m : ℕ) (m_pos : m > 1) :  ∃ p : ℕ, Prime p ∧ p ∣ m "
    ],
    "answer": "theorem has_prime_factor (n: ℕ) : n > 1 → ∃ p: ℕ, Prime p ∧ (∃ d: ℕ, p * d = n) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "has_prime_factor",
      "main_prompt": "Every natural number greater than `1` is divisible by a prime number.",
      "prompt": "Natural language version: \" If a small natural number is divisible by a larger natural number, the small number is zero.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.eq_zero_of_dvd_of_lt{a b : ℕ} (w : a ∣ b) (h : b < a) :\nb = 0 := \n\nNatural language version: \"Every nonzero natural number has a unique prime factorization\" Translate the natural language version to a Lean mathlib version:\n theorem nat.factorization_inj :\nset.inj_on nat.factorization {x : ℕ | x ≠ 0} := \n\nNatural language version: \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.prime.mod_two_eq_one_iff_ne_two{p : ℕ} [fact (nat.prime p)] :\np % 2 = 1 ↔ p ≠ 2 := \n\nNatural language version: \"The only prime factor of prime `p` is `p` itself, with multiplicity `1`\" Translate the natural language version to a Lean mathlib version:\n theorem nat.prime.factorization{p : ℕ} (hp : nat.prime p) :\np.factorization = finsupp.single p 1 := \n\nNatural language version: \"Every natural number greater than `1` is divisible by a prime number.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6529487371444702,
          "doc_string": " If a small natural number is divisible by a larger natural number, the small number is zero.",
          "statement": "theorem nat.eq_zero_of_dvd_of_lt {a b : ℕ} (w : a ∣ b) (h : b < a) : b = 0"
        },
        {
          "sim_score": 0.593155562877655,
          "doc_string": "Every nonzero natural number has a unique prime factorization",
          "statement": "theorem nat.factorization_inj  : set.inj_on nat.factorization {x : ℕ | x ≠ 0}"
        },
        {
          "sim_score": 0.5878391265869141,
          "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.",
          "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2"
        },
        {
          "sim_score": 0.5869839191436768,
          "doc_string": "The only prime factor of prime `p` is `p` itself, with multiplicity `1`",
          "statement": "theorem nat.prime.factorization {p : ℕ} (hp : nat.prime p) : p.factorization = finsupp.single p 1"
        }
      ],
      "codex_time": 3.4960174949956127,
      "search_time": 1.434510382998269,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem nat.ge.prime{n : ℕ} (h : n > 1) : ∃ p : ℕ, Nat.Prime p ∧ 1 < p ∧ p ∣ n ",
      "theorem nat.one_lt_prime_divisor{n : ℕ} (hn : 1 < n) : ∃ p, Nat.Prime p ∧ p ∣ n ",
      "theorem nat.exists_prime_factor (n : ℕ) (h : n > 1) : ∃ p, Prime p ∧ p ∣ n ",
      "theorem nat.ge_two.has_dvd_prime(n : ℕ) (h : 2 ≤ n) : ∃ p : ℕ, Prime p ∧ p ∣ n ",
      "theorem nat.exists_prime_divisor{n : ℕ} (h : n > 1) : ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n "
    ],
    "answer": "theorem has_prime_factor (n: ℕ) : n > 1 → ∃ p: ℕ, Prime p ∧ (∃ d: ℕ, p * d = n) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "has_prime_factor",
      "main_prompt": "Every natural number greater than `1` is divisible by a prime number.",
      "prompt": "Natural language version: \"Every natural number greater than `1` is divisible by a prime number.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 7.534994906018255,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem naturals_greater_1_div_prime (n : ℕ) (h : n > 1) : ∃ n' : ℕ, (∀ d : ℕ, d ∣ n' → d = 1 ∨ d = n') ",
      "theorem HasInf : ∀ n : ℕ, n > 1 → ∃ p : poly_antidiagonal, p.min_degree ≤ n ∧ p.is_prime ∧ ∀ f : poly_antidiagonal, f.min_degree ≤ n → f.is_prime → f = p ",
      "theorem HasInfₓ : ∀ n : ℕ, n > 1 → ∃ p : poly_antidiagonal, p.min_degree ≤ n ∧ p.is_prime ∧ ∀ f : poly_antidiagonal, f.min_degree ≤ n → f.is_prime → f = p ",
      "theorem nat_prime_divisor : ∀ n: ℕ, n > 1 → ∃ p: ℕ, p > 1 ∧ Prime p ∧ p ∣ n ",
      "theorem : (∀ n : ℕ, n > 1 → ∃ p : ℕ, (Prime p) ∧ ( ∃ m : ℕ, n = p * m)) ",
      "theorem f : ∀ n : ℕ,  (1:ℕ) < n → ∃ p : ℕ, Prime p ∧ p ∣ n "
    ],
    "answer": "theorem has_prime_factor (n: ℕ) : n > 1 → ∃ p: ℕ, Prime p ∧ (∃ d: ℕ, p * d = n) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "six_not_prime_sum",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Six is not the sum of two prime numbers.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Six is not the sum of two prime numbers.",
      "codex_time": 9.64134580901009,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem six_neq_sum_of_two_prime_numbers :  ¬ (∃ p q : ℕ, Prime p ∧ Prime q ∧ 6 = p + q) ",
      "theorem mul_two_mul_mul_eq_square_add_one (x : ℕ) (hx : x ≥ 1) :  x * 2 * x = x^2 + 1 ",
      "theorem no_sum_of_two_primes_6 (p q : ℕ) (hp : Prime p) (hq : Prime q):  6 ≠ p + q ",
      "theorem six_eq_primes (p q : ℕ) : 6 = p + q →  (Prime p ∧ Prime q) → False ",
      "theorem six_not_sum_of_two_primes (primes : Set ℕ) (h_1 : (1 : ℕ) ∈ primes)  (h_finite : Finite primes) (h_closed : ∀ m n ∈ primes, m * n ∈ primes) (h_square_neq_prime :  ∀ m ∈ primes, m^2 ≠ 1) (h_prime_divisors : ∀ m n : ℕ, m * n = 1 → m = 1 ∨ m ∈ primes  → n = 1 ∨ n ∈ primes) (primes_pos :",
      "theorem six_not_sum_of_two_primes (primes : Setₓ ℕ) (h_1 : (1 : ℕ) ∈ primes)  (h_finite : Finite primes) (h_closed : ∀ m n ∈ primes, m * n ∈ primes) (h_square_neq_prime :  ∀ m ∈ primes, m^2 ≠ 1) (h_prime_divisors : ∀ m n : ℕ, m * n = 1 → m = 1 ∨ m ∈ primes  → n = 1 ∨ n ∈ primes) (primes_pos :"
    ],
    "answer": "theorem six_not_prime_sum : ¬ (∃ n m: Nat, Prime n ∧ Prime m ∧ n ≠ m ∧ 6 = n + m) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "six_not_prime_sum",
      "main_prompt": "Six is not the sum of two prime numbers.",
      "prompt": "Natural language version: \"The sine of `π / 6` is `1 / 2`.\" Translate the natural language version to a Lean mathlib version:\n theorem real.sin_pi_div_six :\nreal.sin (real.pi / 6) = 1 / 2 := \n\nNatural language version: \" Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.exists_infinite_primes(n : ℕ) :\n∃ (p : ℕ), n ≤ p ∧ nat.prime p := \n\nNatural language version: \" **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.prime.sq_add_sq{p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) :\n∃ (a b : ℕ), a ^ 2 + b ^ 2 = p := \n\nNatural language version: \" Euclid's lemma: if `a ∣ b * c` and `a` and `b` have no common prime factors, `a ∣ c`. Compare `is_coprime.dvd_of_dvd_mul_right`.\" Translate the natural language version to a Lean mathlib version:\n theorem unique_factorization_monoid.dvd_of_dvd_mul_right_of_no_prime_factors{R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] {a b c : R} (ha : a ≠ 0) (no_factors : ∀ {d : R}, d ∣ a → d ∣ b → ¬prime d) :\na ∣ b * c → a ∣ c := \n\nNatural language version: \"Six is not the sum of two prime numbers.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.4190795421600342,
          "doc_string": "The sine of `π / 6` is `1 / 2`.",
          "statement": "theorem real.sin_pi_div_six  : real.sin (real.pi / 6) = 1 / 2"
        },
        {
          "sim_score": 0.41275641322135925,
          "doc_string": " Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`.",
          "statement": "theorem nat.exists_infinite_primes (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p"
        },
        {
          "sim_score": 0.4100857973098755,
          "doc_string": " **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**.",
          "statement": "theorem nat.prime.sq_add_sq {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p"
        },
        {
          "sim_score": 0.40865230560302734,
          "doc_string": " Euclid's lemma: if `a ∣ b * c` and `a` and `b` have no common prime factors, `a ∣ c`. Compare `is_coprime.dvd_of_dvd_mul_right`.",
          "statement": "theorem unique_factorization_monoid.dvd_of_dvd_mul_right_of_no_prime_factors {R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] {a b c : R} (ha : a ≠ 0) (no_factors : ∀ {d : R}, d ∣ a → d ∣ b → ¬prime d) : a ∣ b * c → a ∣ c"
        }
      ],
      "codex_time": 6.6912566919927485,
      "search_time": 1.4358506849966943,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem nat.prime.no_sum_of_two{p q : ℕ} (hp : Nat.Prime p) (hq : Nat.Prime q) : 2 < p → 2 < q → p + q ≠ 6 ",
      "theorem nat.not_two_primes_six : ∀ {a b : ℕ}, a ≠ 2 → b ≠ 2 → ∀ (h : a + b = 6), a ≤ 2 ∧ b ≤ 2 ",
      "theorem nat.not_sum_of_primes_of_six : ∀ (a b : ℕ), Nat.Prime a → Nat.Prime b → a + b ≠ 6 ",
      "theorem nat.not_sum_two_primes : ¬ ∃ {a b : ℕ}, a.prime ∧ b.prime ∧ 6 = a + b ",
      "theorem nat.prime.sq_add_sq_not_six(p : ℕ) [Fact (Nat.Prime p)] (hp : p % 4 = 1) : ¬(∃ (a b : ℕ), a ^ 2 + b ^ 2 = p) "
    ],
    "answer": "theorem six_not_prime_sum : ¬ (∃ n m: Nat, Prime n ∧ Prime m ∧ n ≠ m ∧ 6 = n + m) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "six_not_prime_sum",
      "main_prompt": "Six is not the sum of two prime numbers.",
      "prompt": "Natural language version: \"Six is not the sum of two prime numbers.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 5.365607718005776,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem six_not_sum_two_primes :  ∀ a b : ℕ, Prime a → Prime b → 2 ≤ a → 2 ≤ b → 6 ≠ a + b ",
      "theorem sum_of_primes (x y : ℕ) (ha : 2 < x) (hb : 2 < y) : x + y ≠ 6 ",
      "theorem notsix ( n : ℕ ) ( h1 : n > 1 ) ( h2 : n < 6 ) : 6 ≠ n ",
      "theorem six_is_not_the_sum_of_two_prime_numbers : ¬prime_sum 6 ",
      "theorem ci6_not_eq_primes : ∀ p q : ℕ, (2 ≤ p ∧ 2 ≤ q ∧ p + q = 6) → False , where \"cI6\" "
    ],
    "answer": "theorem six_not_prime_sum : ¬ (∃ n m: Nat, Prime n ∧ Prime m ∧ n ≠ m ∧ 6 = n + m) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "fin_torsionfree",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"A finite torsion-free group is trivial\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A finite torsion-free group is trivial",
      "codex_time": 9.737914669996826,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem finite_torsion_free_group_is_trivial (G : Type*) [Group G] (hfg : finset.card G < ⊤)  (hftf : ∀ x : G, x ≠ 1 → ∃ n : ℕ, x ^ n = 1) :  G.val = {1} ",
      "theorem finite_torsion_free_group_is_trivial (G : Type*) [Groupₓₓ G] (hfg : finset.card G < ⊤)  (hftf : ∀ x : G, x ≠ 1 → ∃ n : ℕ, x ^ n = 1) :  G.val = {1} ",
      "theorem finite_torsion_free_group_is_trivial (G : Type*) [Groupₓ G] (hfg : finset.card G < ⊤)  (hftf : ∀ x : G, x ≠ 1 → ∃ n : ℕ, x ^ n = 1) :  G.val = {1} ",
      "theorem finite_torsion_free_group_is_trivial (G : Type*) [Group G] [Fintype G]  (H : ∀ g : G, g ≠ 1 → ∃ n : ℕ, g ^ n = 1) : G ≅ (1 : G) ",
      "theorem finite_torsion_free_group_is_trivial (G : Type*) [Groupₓₓ G] [Fintype G]  (H : ∀ g : G, g ≠ 1 → ∃ n : ℕ, g ^ n = 1) : G ≅ (1 : G) ",
      "theorem finite_torsion_free_group_is_trivial (G : Type*) [Groupₓ G] [Fintype G]  (H : ∀ g : G, g ≠ 1 → ∃ n : ℕ, g ^ n = 1) : G ≅ (1 : G) ",
      "theorem finite_torsion_free_group_is_trivial (G : Type*) [Group G] [Fintypeₓ G]  (H : ∀ g : G, g ≠ 1 → ∃ n : ℕ, g ^ n = 1) : G ≅ (1 : G) ",
      "theorem finite_torsion_free_group_is_trivial (G : Type*) [Groupₓₓ G] [Fintypeₓ G]  (H : ∀ g : G, g ≠ 1 → ∃ n : ℕ, g ^ n = 1) : G ≅ (1 : G) ",
      "theorem finite_torsion_free_group_is_trivial (G : Type*) [Groupₓ G] [Fintypeₓ G]  (H : ∀ g : G, g ≠ 1 → ∃ n : ℕ, g ^ n = 1) : G ≅ (1 : G) ",
      "theorem finite_torsion_free_group_is_trivial (G : Type*) [Group G]  (hG_fin : Fintype G) (hG_tor_f : ∀ x : G, is_nontrivial G → x ≠ 1) :  G ≅ (1 : G) ",
      "theorem finite_torsion_free_group_is_trivial (G : Type*) [Groupₓₓ G]  (hG_fin : Fintype G) (hG_tor_f : ∀ x : G, is_nontrivial G → x ≠ 1) :  G ≅ (1 : G) ",
      "theorem finite_torsion_free_group_is_trivial (G : Type*) [Groupₓ G]  (hG_fin : Fintype G) (hG_tor_f : ∀ x : G, is_nontrivial G → x ≠ 1) :  G ≅ (1 : G) ",
      "theorem finite_torsion_free_group_is_trivial (G : Type*) [Group G]  (hG_fin : Fintypeₓ G) (hG_tor_f : ∀ x : G, is_nontrivial G → x ≠ 1) :  G ≅ (1 : G) ",
      "theorem finite_torsion_free_group_is_trivial (G : Type*) [Groupₓₓ G]  (hG_fin : Fintypeₓ G) (hG_tor_f : ∀ x : G, is_nontrivial G → x ≠ 1) :  G ≅ (1 : G) ",
      "theorem finite_torsion_free_group_is_trivial (G : Type*) [Groupₓ G]  (hG_fin : Fintypeₓ G) (hG_tor_f : ∀ x : G, is_nontrivial G → x ≠ 1) :  G ≅ (1 : G) ",
      "theorem finite_torsion_free_group_is_trivial (G : Type*) [Group G] (hG_fin : Fintype G)  (HG_tor_free : ∀ x : G, x ≠ 1 → ∃ n : ℕ, x ^ n = 1) :  ∀ x : G, x = 1 ",
      "theorem finite_torsion_free_group_is_trivial (G : Type*) [Groupₓₓ G] (hG_fin : Fintype G)  (HG_tor_free : ∀ x : G, x ≠ 1 → ∃ n : ℕ, x ^ n = 1) :  ∀ x : G, x = 1 ",
      "theorem finite_torsion_free_group_is_trivial (G : Type*) [Groupₓ G] (hG_fin : Fintype G)  (HG_tor_free : ∀ x : G, x ≠ 1 → ∃ n : ℕ, x ^ n = 1) :  ∀ x : G, x = 1 ",
      "theorem finite_torsion_free_group_is_trivial (G : Type*) [Group G] (hG_fin : Fintypeₓ G)  (HG_tor_free : ∀ x : G, x ≠ 1 → ∃ n : ℕ, x ^ n = 1) :  ∀ x : G, x = 1 ",
      "theorem finite_torsion_free_group_is_trivial (G : Type*) [Groupₓₓ G] (hG_fin : Fintypeₓ G)  (HG_tor_free : ∀ x : G, x ≠ 1 → ∃ n : ℕ, x ^ n = 1) :  ∀ x : G, x = 1 ",
      "theorem finite_torsion_free_group_is_trivial (G : Type*) [Groupₓ G] (hG_fin : Fintypeₓ G)  (HG_tor_free : ∀ x : G, x ≠ 1 → ∃ n : ℕ, x ^ n = 1) :  ∀ x : G, x = 1 ",
      "theorem finite_torsion_free_group_is_trivial {G : Type*} [Group G] (hG : Fintype G)  (hGt : ∀ x : G, x ≠ 1 → x ^ (G.card : ℕ) = 1) : G = {1} ",
      "theorem finite_torsion_free_group_is_trivial {G : Type*} [Groupₓₓ G] (hG : Fintype G)  (hGt : ∀ x : G, x ≠ 1 → x ^ (G.card : ℕ) = 1) : G = {1} ",
      "theorem finite_torsion_free_group_is_trivial {G : Type*} [Groupₓ G] (hG : Fintype G)  (hGt : ∀ x : G, x ≠ 1 → x ^ (G.card : ℕ) = 1) : G = {1} ",
      "theorem finite_torsion_free_group_is_trivial {G : Type*} [Group G] (hG : Fintypeₓ G)  (hGt : ∀ x : G, x ≠ 1 → x ^ (G.card : ℕ) = 1) : G = {1} ",
      "theorem finite_torsion_free_group_is_trivial {G : Type*} [Groupₓₓ G] (hG : Fintypeₓ G)  (hGt : ∀ x : G, x ≠ 1 → x ^ (G.card : ℕ) = 1) : G = {1} ",
      "theorem finite_torsion_free_group_is_trivial {G : Type*} [Groupₓ G] (hG : Fintypeₓ G)  (hGt : ∀ x : G, x ≠ 1 → x ^ (G.card : ℕ) = 1) : G = {1} "
    ],
    "answer": "theorem fin_torsionfree {G: Type _}[Groupₓ G][Finite G] : Monoidₓ.IsTorsionFree G → IsSubgroup.Trivial G "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "fin_torsionfree",
      "main_prompt": "A finite torsion-free group is trivial",
      "prompt": "Natural language version: \"Subgroups of torsion-free groups are torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.subgroup{G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) :\nmonoid.is_torsion_free ↥H := \n\nNatural language version: \"A nontrivial torsion group is not torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion.not_torsion_free{G : Type u_1} [group G] [hN : nontrivial G] :\nmonoid.is_torsion G → ¬monoid.is_torsion_free G := \n\nNatural language version: \"A nontrivial torsion-free group is not torsion.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.not_torsion{G : Type u_1} [group G] [hN : nontrivial G] :\nmonoid.is_torsion_free G → ¬monoid.is_torsion G := \n\nNatural language version: \"Direct products of torsion free groups are torsion free.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.prod{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) :\nmonoid.is_torsion_free (Π (i : η), Gs i) := \n\nNatural language version: \"A finite torsion-free group is trivial\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.8230506181716919,
          "doc_string": "Subgroups of torsion-free groups are torsion-free.",
          "statement": "theorem is_torsion_free.subgroup {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) : monoid.is_torsion_free ↥H"
        },
        {
          "sim_score": 0.8135049939155579,
          "doc_string": "A nontrivial torsion group is not torsion-free.",
          "statement": "theorem is_torsion.not_torsion_free {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G → ¬monoid.is_torsion_free G"
        },
        {
          "sim_score": 0.8007985353469849,
          "doc_string": "A nontrivial torsion-free group is not torsion.",
          "statement": "theorem is_torsion_free.not_torsion {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G → ¬monoid.is_torsion G"
        },
        {
          "sim_score": 0.7504584789276123,
          "doc_string": "Direct products of torsion free groups are torsion free.",
          "statement": "theorem is_torsion_free.prod {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i)"
        }
      ],
      "codex_time": 6.756425740983104,
      "search_time": 1.4408756789925974,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem is_torsion_free_of_finite{G : Type u_1} [Group G] [Fintype G] [is_torsion_free : Monoidₓ.IsTorsionFree G] : G ≃ (1 : G) ",
      "theorem is_torsion_free_of_finite{G : Type u_1} [Groupₓₓ G] [Fintype G] [is_torsion_free : Monoidₓ.IsTorsionFree G] : G ≃ (1 : G) ",
      "theorem is_torsion_free_of_finite{G : Type u_1} [Groupₓ G] [Fintype G] [is_torsion_free : Monoidₓ.IsTorsionFree G] : G ≃ (1 : G) ",
      "theorem is_torsion_free_of_finite{G : Type u_1} [Group G] [Fintypeₓ G] [is_torsion_free : Monoidₓ.IsTorsionFree G] : G ≃ (1 : G) ",
      "theorem is_torsion_free_of_finite{G : Type u_1} [Groupₓₓ G] [Fintypeₓ G] [is_torsion_free : Monoidₓ.IsTorsionFree G] : G ≃ (1 : G) ",
      "theorem is_torsion_free_of_finite{G : Type u_1} [Groupₓ G] [Fintypeₓ G] [is_torsion_free : Monoidₓ.IsTorsionFree G] : G ≃ (1 : G) ",
      "theorem is_torsion_free.finite_iff_trivial{G : Type u_1} [Group G] (tfG : Monoidₓ.IsTorsionFree G) (fG : Fintype G) : G ≃ fin_zero ",
      "theorem is_torsion_free.finite_iff_trivial{G : Type u_1} [Groupₓₓ G] (tfG : Monoidₓ.IsTorsionFree G) (fG : Fintype G) : G ≃ fin_zero ",
      "theorem is_torsion_free.finite_iff_trivial{G : Type u_1} [Groupₓ G] (tfG : Monoidₓ.IsTorsionFree G) (fG : Fintype G) : G ≃ fin_zero ",
      "theorem is_torsion_free.finite_iff_trivial{G : Type u_1} [Group G] (tfG : Monoidₓ.IsTorsionFree G) (fG : Fintypeₓ G) : G ≃ fin_zero ",
      "theorem is_torsion_free.finite_iff_trivial{G : Type u_1} [Groupₓₓ G] (tfG : Monoidₓ.IsTorsionFree G) (fG : Fintypeₓ G) : G ≃ fin_zero ",
      "theorem is_torsion_free.finite_iff_trivial{G : Type u_1} [Groupₓ G] (tfG : Monoidₓ.IsTorsionFree G) (fG : Fintypeₓ G) : G ≃ fin_zero ",
      "theorem is_torsion_free.fintype_card1_iff {G : Type u_1} [Group G] [Fintype G] (H : Monoidₓ.IsTorsionFree G) : card G = 1 ↔ IsUnit G.0 ",
      "theorem is_torsion_free.fintype_card1_iff {G : Type u_1} [Groupₓₓ G] [Fintype G] (H : Monoidₓ.IsTorsionFree G) : card G = 1 ↔ IsUnit G.0 ",
      "theorem is_torsion_free.fintype_card1_iff {G : Type u_1} [Groupₓ G] [Fintype G] (H : Monoidₓ.IsTorsionFree G) : card G = 1 ↔ IsUnit G.0 ",
      "theorem is_torsion_free.fintype_card1_iff {G : Type u_1} [Group G] [Fintypeₓ G] (H : Monoidₓ.IsTorsionFree G) : card G = 1 ↔ IsUnit G.0 ",
      "theorem is_torsion_free.fintype_card1_iff {G : Type u_1} [Groupₓₓ G] [Fintypeₓ G] (H : Monoidₓ.IsTorsionFree G) : card G = 1 ↔ IsUnit G.0 ",
      "theorem is_torsion_free.fintype_card1_iff {G : Type u_1} [Groupₓ G] [Fintypeₓ G] (H : Monoidₓ.IsTorsionFree G) : card G = 1 ↔ IsUnit G.0 ",
      "theorem is_torsion_free.fintype {G : Type u_1} [Group G] [Fintype G] : Monoidₓ.IsTorsionFree G → trivial G ",
      "theorem is_torsion_free.fintype {G : Type u_1} [Groupₓₓ G] [Fintype G] : Monoidₓ.IsTorsionFree G → trivial G ",
      "theorem is_torsion_free.fintype {G : Type u_1} [Groupₓ G] [Fintype G] : Monoidₓ.IsTorsionFree G → trivial G ",
      "theorem is_torsion_free.fintype {G : Type u_1} [Group G] [Fintype G] : Monoidₓ.IsTorsionFree G → trivialₓ G ",
      "theorem is_torsion_free.fintype {G : Type u_1} [Groupₓₓ G] [Fintype G] : Monoidₓ.IsTorsionFree G → trivialₓ G ",
      "theorem is_torsion_free.fintype {G : Type u_1} [Groupₓ G] [Fintype G] : Monoidₓ.IsTorsionFree G → trivialₓ G ",
      "theorem is_torsion_free.fintype {G : Type u_1} [Group G] [Fintypeₓ G] : Monoidₓ.IsTorsionFree G → trivial G ",
      "theorem is_torsion_free.fintype {G : Type u_1} [Groupₓₓ G] [Fintypeₓ G] : Monoidₓ.IsTorsionFree G → trivial G ",
      "theorem is_torsion_free.fintype {G : Type u_1} [Groupₓ G] [Fintypeₓ G] : Monoidₓ.IsTorsionFree G → trivial G ",
      "theorem is_torsion_free.fintype {G : Type u_1} [Group G] [Fintypeₓ G] : Monoidₓ.IsTorsionFree G → trivialₓ G ",
      "theorem is_torsion_free.fintype {G : Type u_1} [Groupₓₓ G] [Fintypeₓ G] : Monoidₓ.IsTorsionFree G → trivialₓ G ",
      "theorem is_torsion_free.fintype {G : Type u_1} [Groupₓ G] [Fintypeₓ G] : Monoidₓ.IsTorsionFree G → trivialₓ G ",
      "theorem is_torsion_free.trivial_finite{G : Type u_1} [Group G] [Fintype G] [hN : Nontrivial G] : Monoidₓ.IsTorsionFree G → ⊥ ",
      "theorem is_torsion_free.trivial_finite{G : Type u_1} [Groupₓₓ G] [Fintype G] [hN : Nontrivial G] : Monoidₓ.IsTorsionFree G → ⊥ ",
      "theorem is_torsion_free.trivial_finite{G : Type u_1} [Groupₓ G] [Fintype G] [hN : Nontrivial G] : Monoidₓ.IsTorsionFree G → ⊥ ",
      "theorem is_torsion_free.trivial_finite{G : Type u_1} [Group G] [Fintypeₓ G] [hN : Nontrivial G] : Monoidₓ.IsTorsionFree G → ⊥ ",
      "theorem is_torsion_free.trivial_finite{G : Type u_1} [Groupₓₓ G] [Fintypeₓ G] [hN : Nontrivial G] : Monoidₓ.IsTorsionFree G → ⊥ ",
      "theorem is_torsion_free.trivial_finite{G : Type u_1} [Groupₓ G] [Fintypeₓ G] [hN : Nontrivial G] : Monoidₓ.IsTorsionFree G → ⊥ "
    ],
    "answer": "theorem fin_torsionfree {G: Type _}[Groupₓ G][Finite G] : Monoidₓ.IsTorsionFree G → IsSubgroup.Trivial G "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "fin_torsionfree",
      "main_prompt": "A finite torsion-free group is trivial",
      "prompt": "Natural language version: \"A finite torsion-free group is trivial\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 9.143268368003191,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem True Sorry  -/   export group_theory.subgroup IsOpen group_theory  variables {G : Type*} [Group G]  section is_trivial  variables {g₁ g₂ g₃ : G}  class is_trivial (G : Type*) [Group G] ",
      "theorem True Sorry  -/   export group_theory.subgroup IsOpen group_theory  variables {G : Type*} [Groupₓₓ G]  section is_trivial  variables {g₁ g₂ g₃ : G}  class is_trivial (G : Type*) [Groupₓₓ G] ",
      "theorem True Sorry  -/   export group_theory.subgroup IsOpen group_theory  variables {G : Type*} [Groupₓ G]  section is_trivial  variables {g₁ g₂ g₃ : G}  class is_trivial (G : Type*) [Groupₓ G] ",
      "theorem ``A Finite torsion-free Group is trivial'' ",
      "theorem ``A Finite torsion-free Groupₓₓ is trivial'' ",
      "theorem ``A Finite torsion-free Groupₓ is trivial'' ",
      "theorem ``A Finite torsion-free Group is trivialₓ'' ",
      "theorem ``A Finite torsion-free Groupₓₓ is trivialₓ'' ",
      "theorem ``A Finite torsion-free Groupₓ is trivialₓ'' ",
      "theorem finite_torsion_free_group_trivial_lemma : ∀ (G : Type*) [Group G] [Fintype G] [pi.torsion_free G],   G ≃ ℤ ",
      "theorem finite_torsion_free_group_trivial_lemma : ∀ (G : Type*) [Groupₓₓ G] [Fintype G] [pi.torsion_free G],   G ≃ ℤ ",
      "theorem finite_torsion_free_group_trivial_lemma : ∀ (G : Type*) [Groupₓ G] [Fintype G] [pi.torsion_free G],   G ≃ ℤ ",
      "theorem finite_torsion_free_group_trivial_lemma : ∀ (G : Type*) [Group G] [Fintypeₓ G] [pi.torsion_free G],   G ≃ ℤ ",
      "theorem finite_torsion_free_group_trivial_lemma : ∀ (G : Type*) [Groupₓₓ G] [Fintypeₓ G] [pi.torsion_free G],   G ≃ ℤ ",
      "theorem finite_torsion_free_group_trivial_lemma : ∀ (G : Type*) [Groupₓ G] [Fintypeₓ G] [pi.torsion_free G],   G ≃ ℤ ",
      "theorem ftf_trivial (G : Type*) [ab_group G] [Fintype G] [has_torsion G]:   G = vector.zero ",
      "theorem ftf_trivial (G : Type*) [ab_group G] [Fintypeₓ G] [has_torsion G]:   G = vector.zero ",
      "theorem fin_tors_free_group_is_trivial (G : Type*) [Group G] [Fintype G]  (H : ∀ g, (g : G) ≠ 1) : G = 1 ",
      "theorem fin_tors_free_group_is_trivial (G : Type*) [Groupₓₓ G] [Fintype G]  (H : ∀ g, (g : G) ≠ 1) : G = 1 ",
      "theorem fin_tors_free_group_is_trivial (G : Type*) [Groupₓ G] [Fintype G]  (H : ∀ g, (g : G) ≠ 1) : G = 1 ",
      "theorem fin_tors_free_group_is_trivial (G : Type*) [Group G] [Fintypeₓ G]  (H : ∀ g, (g : G) ≠ 1) : G = 1 ",
      "theorem fin_tors_free_group_is_trivial (G : Type*) [Groupₓₓ G] [Fintypeₓ G]  (H : ∀ g, (g : G) ≠ 1) : G = 1 ",
      "theorem fin_tors_free_group_is_trivial (G : Type*) [Groupₓ G] [Fintypeₓ G]  (H : ∀ g, (g : G) ≠ 1) : G = 1 "
    ],
    "answer": "theorem fin_torsionfree {G: Type _}[Groupₓ G][Finite G] : Monoidₓ.IsTorsionFree G → IsSubgroup.Trivial G "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "hom_rat_Z_trivial",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Any homomorphism from the additive group of rational numbers to `ℤ` is trivial\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Any homomorphism from the additive group of rational numbers to `ℤ` is trivial",
      "codex_time": 3.8287297910137568,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem hom_rat_to_int_trivial (h : (ℚ: Type*) ≃ₗ[Add.add ℚ] ℤ) : h = 0 ",
      "theorem hom_rat_add_int (f : ℚ → ℤ) (h : ∀ x y : ℚ, f (x + y) = f x + f y) : ∀ x : ℚ, f x = 0 ",
      "theorem no_nonzero_hom_from_q_to_int :  ∀ (f : ℚ → ℤ), (∀ x, f (x + x) = f x + f x) → (∀ x, f x = 0) ",
      "theorem zero_hom_of_rationals_to_ints (f : ℚ → ℤ) [IsGroupHom f] : f 0 = 0 ",
      "theorem hom_from_Q_to_Z_is_trivial :  ∀ [Group G] (f : ℚ →+ G), f 0 = 0 → f 1 = 1 → f (-1 : ℚ) = 1 → f = 0 ",
      "theorem hom_from_Q_to_Z_is_trivial :  ∀ [Groupₓₓ G] (f : ℚ →+ G), f 0 = 0 → f 1 = 1 → f (-1 : ℚ) = 1 → f = 0 ",
      "theorem hom_from_Q_to_Z_is_trivial :  ∀ [Groupₓ G] (f : ℚ →+ G), f 0 = 0 → f 1 = 1 → f (-1 : ℚ) = 1 → f = 0 "
    ],
    "answer": "theorem hom_rat_Z_trivial (f : ℚ → ℤ) : IsAddGroupHom f →  ∀ x: ℚ, f x = 0 "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "hom_rat_Z_trivial",
      "main_prompt": "Any homomorphism from the additive group of rational numbers to `ℤ` is trivial",
      "prompt": "Natural language version: \"An additive group homomorphism is injective if its kernel is trivial.\" Translate the natural language version to a Lean mathlib version:\n theorem is_add_group_hom.injective_iff{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) :\nfunction.injective f ↔ ∀ (a : α), f a = 0 → a = 0 := \n\nNatural language version: \"An additive group homomorphism sends 0 to 0.\" Translate the natural language version to a Lean mathlib version:\n theorem is_add_group_hom.map_zero{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) :\nf 0 = 0 := \n\nNatural language version: \"Additive group homomorphisms preserve integer scaling.\" Translate the natural language version to a Lean mathlib version:\n theorem map_zsmul{G : Type u_6} {H : Type u_7} {F : Type u_8} [add_group G] [subtraction_monoid H] [add_monoid_hom_class F G H] (f : F) (n : ℤ) (g : G) :\n⇑f (n • g) = n • ⇑f g := \n\nNatural language version: \"Additive group homomorphisms preserve integer scaling.\" Translate the natural language version to a Lean mathlib version:\n theorem add_monoid_hom.map_zsmul{α : Type u_1} {β : Type u_2} [add_group α] [subtraction_monoid β] (f : α →+ β) (g : α) (n : ℤ) :\n⇑f (n • g) = n • ⇑f g := \n\nNatural language version: \"Any homomorphism from the additive group of rational numbers to `ℤ` is trivial\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.7258538603782654,
          "doc_string": "An additive group homomorphism is injective if its kernel is trivial.",
          "statement": "theorem is_add_group_hom.injective_iff {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 0 → a = 0"
        },
        {
          "sim_score": 0.7063751220703125,
          "doc_string": "An additive group homomorphism sends 0 to 0.",
          "statement": "theorem is_add_group_hom.map_zero {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : f 0 = 0"
        },
        {
          "sim_score": 0.6773562431335449,
          "doc_string": "Additive group homomorphisms preserve integer scaling.",
          "statement": "theorem map_zsmul {G : Type u_6} {H : Type u_7} {F : Type u_8} [add_group G] [subtraction_monoid H] [add_monoid_hom_class F G H] (f : F) (n : ℤ) (g : G) : ⇑f (n • g) = n • ⇑f g"
        },
        {
          "sim_score": 0.6773562431335449,
          "doc_string": "Additive group homomorphisms preserve integer scaling.",
          "statement": "theorem add_monoid_hom.map_zsmul {α : Type u_1} {β : Type u_2} [add_group α] [subtraction_monoid β] (f : α →+ β) (g : α) (n : ℤ) : ⇑f (n • g) = n • ⇑f g"
        }
      ],
      "codex_time": 4.650995299016358,
      "search_time": 1.4669762930134311,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem rat.injective_add_hom_of_injective_nat_hom⦃α⦄{α : Type u} [AddGroup α] (f : ℚ →+ α) : Function.Injective (λ x : ℚ, ⇑f (↑x : ℚ)) → f = 0 ",
      "theorem rat.injective_add_hom_of_injective_nat_hom⦃α⦄{α : Type u} [AddGroupₓₓ α] (f : ℚ →+ α) : Function.Injective (λ x : ℚ, ⇑f (↑x : ℚ)) → f = 0 ",
      "theorem rat.injective_add_hom_of_injective_nat_hom⦃α⦄{α : Type u} [AddGroupₓ α] (f : ℚ →+ α) : Function.Injective (λ x : ℚ, ⇑f (↑x : ℚ)) → f = 0 ",
      "theorem add_group.nat_abs_of_hom_of_dvd{α : Type u} {β : Type v} [AddGroup α] [AddGroup β]    {f : α →+ β} (hf : f 0 = 0) (hd : surjective f) (h : β) : nat_abs (↥(f h) : ℤ) ∣ ↥h ",
      "theorem add_group.nat_abs_of_hom_of_dvd{α : Type u} {β : Type v} [AddGroupₓₓ α] [AddGroupₓₓ β]    {f : α →+ β} (hf : f 0 = 0) (hd : surjective f) (h : β) : nat_abs (↥(f h) : ℤ) ∣ ↥h ",
      "theorem add_group.nat_abs_of_hom_of_dvd{α : Type u} {β : Type v} [AddGroupₓ α] [AddGroupₓ β]    {f : α →+ β} (hf : f 0 = 0) (hd : surjective f) (h : β) : nat_abs (↥(f h) : ℤ) ∣ ↥h ",
      "theorem subtype.coe_injective$(p : ℚ → Prop) [IsAddGroupHom (Coe : (Σ a : ℚ, p a) → ℚ)] {q : ℚ} : ∀  r s, Coe r = Coe s → r = s ",
      "theorem add_monoid_hom.map_Cantor_rational_embedding_trivial'{α : Type u_5} {β : Type u_6} [AddGroup α] [AddMonoid β] (f : α →+ β) [IsAddGroupHom f] : ⇑f (Cantor_rational_embedding r) = ⇑f r ",
      "theorem add_monoid_hom.map_Cantor_rational_embedding_trivial'{α : Type u_5} {β : Type u_6} [AddGroupₓₓ α] [AddMonoid β] (f : α →+ β) [IsAddGroupHom f] : ⇑f (Cantor_rational_embedding r) = ⇑f r ",
      "theorem add_monoid_hom.map_Cantor_rational_embedding_trivial'{α : Type u_5} {β : Type u_6} [AddGroup α] [AddMonoidₓ β] (f : α →+ β) [IsAddGroupHom f] : ⇑f (Cantor_rational_embedding r) = ⇑f r ",
      "theorem add_monoid_hom.map_Cantor_rational_embedding_trivial'{α : Type u_5} {β : Type u_6} [AddGroupₓₓ α] [AddMonoidₓ β] (f : α →+ β) [IsAddGroupHom f] : ⇑f (Cantor_rational_embedding r) = ⇑f r ",
      "theorem add_monoid_hom.map_Cantor_rational_embedding_trivial'{α : Type u_5} {β : Type u_6} [AddGroupₓ α] [AddMonoid β] (f : α →+ β) [IsAddGroupHom f] : ⇑f (Cantor_rational_embedding r) = ⇑f r ",
      "theorem add_monoid_hom.map_Cantor_rational_embedding_trivial'{α : Type u_5} {β : Type u_6} [AddGroupₓ α] [AddMonoidₓ β] (f : α →+ β) [IsAddGroupHom f] : ⇑f (Cantor_rational_embedding r) = ⇑f r ",
      "theorem is_add_group_hom_of_injection_int{α : Type u_1} [AddCommGroup α] {f : α →ₗ[ℚ] ℤ} (hf : Function.Injective f) : IsAddGroupHom f ",
      "theorem is_add_group_hom_of_injection_int{α : Type u_1} [AddCommGroupₓₓ α] {f : α →ₗ[ℚ] ℤ} (hf : Function.Injective f) : IsAddGroupHom f ",
      "theorem is_add_group_hom_of_injection_int{α : Type u_1} [AddCommGroupₓ α] {f : α →ₗ[ℚ] ℤ} (hf : Function.Injective f) : IsAddGroupHom f "
    ],
    "answer": "theorem hom_rat_Z_trivial (f : ℚ → ℤ) : IsAddGroupHom f →  ∀ x: ℚ, f x = 0 "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "hom_rat_Z_trivial",
      "main_prompt": "Any homomorphism from the additive group of rational numbers to `ℤ` is trivial",
      "prompt": "Natural language version: \"Any homomorphism from the additive group of rational numbers to `ℤ` is trivial\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 7.417343595996499,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem add_comm_group.mul_inv_cancel_left (x : ℚ ) : x * x⁻¹ = 1 ",
      "theorem Q_hom_to_Z_special (φ : ℚ → ℤ) (h : function.is_monoid_hom φ) : function.ker φ = {0} ",
      "theorem Q_to_Z_is_trivial {f : ℚ → ℤ} [IsGroupHom f] : ∀ q : ℚ, f q = 0 ",
      "theorem nat_lang : (ℚ, +) →* (ℤ, +) ",
      "theorem Q_to_Z_hom_is_trivial (f : ℚ → ℤ) (h : ∀ q : ℚ, f(q + q) = f q + f q) : f = λ q : ℚ, 0 "
    ],
    "answer": "theorem hom_rat_Z_trivial (f : ℚ → ℤ) : IsAddGroupHom f →  ∀ x: ℚ, f x = 0 "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "fin_int_domain_ring_is_field",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every finite division ring is a field.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every finite division ring is a field.",
      "codex_time": 5.7241555280052125,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem finite_division_ring_is_field (D : Type*) [DivisionRing D] (hD :  fintype. Card D < ℕ.omega) : Field D ",
      "theorem finite_division_ring_is_field (F : Type*) [DivisionRing F] [Fintype F]:  Field F ",
      "theorem finite_division_ring_is_field (F : Type*) [DivisionRing F] [Fintypeₓ F]:  Field F ",
      "theorem finite_division_ring_is_field (R : Type*) [_root_.finite_dimensional R] [DivisionRing R]:  Field R ",
      "theorem finite_division_ring_is_field (A : Type*) [DivisionRing A] (hA : Fintype A) :  IsField A ",
      "theorem finite_division_ring_is_field (A : Type*) [DivisionRing A] (hA : Fintypeₓ A) :  IsField A ",
      "theorem division_ring.finite.field (D : Type*) [DivisionRing D] [Fintype D] : Field D ",
      "theorem division_ring.finite.field (D : Type*) [DivisionRing D] [Fintypeₓ D] : Field D "
    ],
    "answer": "theorem fin_int_domain_ring_is_field {R : Type _} [Ringₓ R][IsDomain R] [Finite R] : Field R "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "fin_int_domain_ring_is_field",
      "main_prompt": "Every finite division ring is a field.",
      "prompt": "Natural language version: \"A subfield is closed under division.\" Translate the natural language version to a Lean mathlib version:\n theorem subfield.div_mem{K : Type u} [field K] (s : subfield K) {x y : K} :\nx ∈ s → y ∈ s → x / y ∈ s := \n\nNatural language version: \"A division_ring is one-dimensional as a vector space over itself.\" Translate the natural language version to a Lean mathlib version:\n theorem finite_dimensional.finrank_self(K : Type u) [division_ring K] :\nfinite_dimensional.finrank K K = 1 := \n\nNatural language version: \"An intermediate field is closed under division.\" Translate the natural language version to a Lean mathlib version:\n theorem intermediate_field.div_mem{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} :\nx ∈ S → y ∈ S → x / y ∈ S := \n\nNatural language version: \"A subfield is closed under multiplication.\" Translate the natural language version to a Lean mathlib version:\n theorem subfield.mul_mem{K : Type u} [field K] (s : subfield K) {x y : K} :\nx ∈ s → y ∈ s → x * y ∈ s := \n\nNatural language version: \"Every finite division ring is a field.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6756068468093872,
          "doc_string": "A subfield is closed under division.",
          "statement": "theorem subfield.div_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x / y ∈ s"
        },
        {
          "sim_score": 0.6545361280441284,
          "doc_string": "A division_ring is one-dimensional as a vector space over itself.",
          "statement": "theorem finite_dimensional.finrank_self (K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1"
        },
        {
          "sim_score": 0.6345528364181519,
          "doc_string": "An intermediate field is closed under division.",
          "statement": "theorem intermediate_field.div_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} : x ∈ S → y ∈ S → x / y ∈ S"
        },
        {
          "sim_score": 0.62082839012146,
          "doc_string": "A subfield is closed under multiplication.",
          "statement": "theorem subfield.mul_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x * y ∈ s"
        }
      ],
      "codex_time": 5.01110641399282,
      "search_time": 1.5487677009950858,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem finite_dimensional.fd_is_field{K : Type u} [fd_char_0 K] [DivisionRing K] [FiniteDimensional K K] : Field K ",
      "theorem finite_division_ring.field (K : Type u) [DivisionRing K] [Fintype K] : IsField K ",
      "theorem finite_division_ring.field (K : Type u) [DivisionRing K] [Fintypeₓ K] : IsField K ",
      "theorem finite_division_ring.to_field(K : Type u) [DivisionRing K] (card : cardinal.{u}) [Fintype K] [cardinal.fintype K card] : Field K ",
      "theorem finite_division_ring.to_field(K : Type u) [DivisionRing K] (card : cardinal.{u}) [Fintypeₓ K] [cardinal.fintype K card] : Field K ",
      "theorem finite.division_ring_is_field{K : Type u} [DivisionRing K] [Fintype K] : IsField K ",
      "theorem finite.division_ring_is_field{K : Type u} [DivisionRing K] [Fintypeₓ K] : IsField K ",
      "theorem is_field_division_ring_finite : ∀ (K : Type u) [DivisionRing K], @FiniteDimensional K _ → IsField K "
    ],
    "answer": "theorem fin_int_domain_ring_is_field {R : Type _} [Ringₓ R][IsDomain R] [Finite R] : Field R "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "fin_int_domain_ring_is_field",
      "main_prompt": "Every finite division ring is a field.",
      "prompt": "Natural language version: \"Every finite division ring is a field.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 12.83588868699735,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem every_finite_division_ring_is_a_field :   (∃ (k : Type) [Fintype k] [DecidableEq k] [DivisionRing k]  (p : k ≃+* (k → k))  , True) →   True ",
      "theorem every_finite_division_ring_is_a_field :   (∃ (k : Type) [Fintypeₓ k] [DecidableEq k] [DivisionRing k]  (p : k ≃+* (k → k))  , True) →   True ",
      "theorem Q5 : Π (D : Type) [DivisionRing D] [FiniteDimensional D ℝ], IsField D  begin    intro D,    apply_instance  end Qed. (/ *) --In this case, we specify a _specific_ type of our choice, ℝ:  /- Lean:  variable (D : Type)  variable [div_ring : DivisionRing D]  variable [fdD : FiniteDimensional D ℝ]  goal IsField D -/ /- Mathlib:  variable (D : Type)  variable [DivisionRing D]  variable [FiniteDimensional D",
      "theorem foo { 𝔽 : Type } [ Field 𝔽 ] ( x y z : 𝔽 ) : x = 0 → y = 0 → z = 0 → x + y + z = 0 ",
      "theorem field_of_division_ring (D : Type*) [DivisionRing D] [Fintype D] : Field D ",
      "theorem field_of_division_ring (D : Type*) [DivisionRing D] [Fintypeₓ D] : Field D ",
      "theorem fin_div_ring_is_field [{α : Type*} [div_ring α] [Fintype α] [DecidableEq α]]: Field α  2. What did you do?     Well, at first I simply copied the structure definition of Finite division ring. Then I wrote a natural language theorem, which I then translated into Lean.  3. How long did it take?     I wrote the natural language theorem on paper and then translated it into Lean. After that I went looking for theorems, but forgot them. So I wrote the theorem twice. -/   /-- A Finite division Ring is a commutative Ring where every non-Zero element is in",
      "theorem fin_div_ring_is_field [{α : Type*} [div_ring α] [Fintype α] [DecidableEq α]]: Field α  2. What did you do?     Well, at first I simply copied the structure definition of Finite division ring. Then I wrote a natural language theorem, which I then translated into Lean.  3. How long did it take?     I wrote the natural language theorem on paper and then translated it into Lean. After that I went looking for theorems, but forgot them. So I wrote the theorem twice. -/   /-- A Finite division Ringₓₓ is a commutative Ringₓₓ where every non-Zero element is in",
      "theorem fin_div_ring_is_field [{α : Type*} [div_ring α] [Fintype α] [DecidableEq α]]: Field α  2. What did you do?     Well, at first I simply copied the structure definition of Finite division ring. Then I wrote a natural language theorem, which I then translated into Lean.  3. How long did it take?     I wrote the natural language theorem on paper and then translated it into Lean. After that I went looking for theorems, but forgot them. So I wrote the theorem twice. -/   /-- A Finite division Ringₓ is a commutative Ringₓ where every non-Zero element is in",
      "theorem fin_div_ring_is_field [{α : Type*} [div_ring α] [Fintypeₓ α] [DecidableEq α]]: Field α  2. What did you do?     Well, at first I simply copied the structure definition of Finite division ring. Then I wrote a natural language theorem, which I then translated into Lean.  3. How long did it take?     I wrote the natural language theorem on paper and then translated it into Lean. After that I went looking for theorems, but forgot them. So I wrote the theorem twice. -/   /-- A Finite division Ring is a commutative Ring where every non-Zero element is in",
      "theorem fin_div_ring_is_field [{α : Type*} [div_ring α] [Fintypeₓ α] [DecidableEq α]]: Field α  2. What did you do?     Well, at first I simply copied the structure definition of Finite division ring. Then I wrote a natural language theorem, which I then translated into Lean.  3. How long did it take?     I wrote the natural language theorem on paper and then translated it into Lean. After that I went looking for theorems, but forgot them. So I wrote the theorem twice. -/   /-- A Finite division Ringₓₓ is a commutative Ringₓₓ where every non-Zero element is in",
      "theorem fin_div_ring_is_field [{α : Type*} [div_ring α] [Fintypeₓ α] [DecidableEq α]]: Field α  2. What did you do?     Well, at first I simply copied the structure definition of Finite division ring. Then I wrote a natural language theorem, which I then translated into Lean.  3. How long did it take?     I wrote the natural language theorem on paper and then translated it into Lean. After that I went looking for theorems, but forgot them. So I wrote the theorem twice. -/   /-- A Finite division Ringₓ is a commutative Ringₓ where every non-Zero element is in"
    ],
    "answer": "theorem fin_int_domain_ring_is_field {R : Type _} [Ringₓ R][IsDomain R] [Finite R] : Field R "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "finite_space_compact",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every finite topological space is compact\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every finite topological space is compact",
      "codex_time": 6.303301887004636,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem compact_of_finite_subset [TopologicalSpace α] {s : Set α} (hs : Finite s) : IsCompact s ",
      "theorem compact_of_finite_subset [TopologicalSpace α] {s : Setₓ α} (hs : Finite s) : IsCompact s ",
      "theorem finite_is_compact (X : Type*) [TopologicalSpace X] (homeo : CompactSpace X)  (Fin : Fintype X) : CompactSpace X ",
      "theorem finite_is_compact (X : Type*) [TopologicalSpace X] (homeo : CompactSpace X)  (Finₓ : Fintype X) : CompactSpace X ",
      "theorem finite_is_compact (X : Type*) [TopologicalSpace X] (homeo : CompactSpace X)  (Fin : Fintypeₓ X) : CompactSpace X ",
      "theorem finite_is_compact (X : Type*) [TopologicalSpace X] (homeo : CompactSpace X)  (Finₓ : Fintypeₓ X) : CompactSpace X ",
      "theorem every_finite_topological_space_is_compact (X : Type*) [TopologicalSpace X] (hXfinite :   (∃ n : ℕ, X ≃ Fin n)) : CompactSpace X ",
      "theorem every_finite_topological_space_is_compact (X : Type*) [TopologicalSpace X] (hXfinite :   (∃ n : ℕ, X ≃ Finₓ n)) : CompactSpace X ",
      "theorem finite_topological_space_is_compact {X}  [TopologicalSpace X] [Fintype X] :  CompactSpace X ",
      "theorem finite_topological_space_is_compact {X}  [TopologicalSpace X] [Fintypeₓ X] :  CompactSpace X ",
      "theorem finite_topological_space_is_compact (X : Type*) [TopologicalSpace X] (J : finite_set X) :  IsCompact J "
    ],
    "answer": "theorem finite_space_compact {X : Type _}[TopologicalSpace X][Finite X] : CompactSpace X "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "finite_space_compact",
      "main_prompt": "Every finite topological space is compact",
      "prompt": "Natural language version: \"A set `s` is compact if for every open cover of `s`, there exists a finite subcover.\" Translate the natural language version to a Lean mathlib version:\n theorem is_compact_of_finite_subcover{α : Type u} [topological_space α] {s : set α} (h : ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)) :\nis_compact s := \n\nNatural language version: \"For every open cover of a compact set, there exists a finite subcover.\" Translate the natural language version to a Lean mathlib version:\n theorem is_compact.elim_finite_subcover_image{α : Type u} {ι : Type u_1} [topological_space α] {s : set α} {b : set ι} {c : ι → set α} (hs : is_compact s) (hc₁ : ∀ (i : ι), i ∈ b → is_open (c i)) (hc₂ : s ⊆ ⋃ (i : ι) (H : i ∈ b), c i) :\n∃ (b' : set ι) (H : b' ⊆ b), b'.finite ∧ s ⊆ ⋃ (i : ι) (H : i ∈ b'), c i := \n\nNatural language version: \"For every open cover of a compact set, there exists a finite subcover.\" Translate the natural language version to a Lean mathlib version:\n theorem is_compact.elim_finite_subcover{α : Type u} [topological_space α] {s : set α} {ι : Type v} (hs : is_compact s) (U : ι → set α) (hUo : ∀ (i : ι), is_open (U i)) (hsU : s ⊆ ⋃ (i : ι), U i) :\n∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i := \n\nNatural language version: \" A set `s` is compact if and only if for every open cover of `s`, there exists a finite subcover.\" Translate the natural language version to a Lean mathlib version:\n theorem is_compact_iff_finite_subcover{α : Type u} [topological_space α] {s : set α} :\nis_compact s ↔ ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i) := \n\nNatural language version: \"Every finite topological space is compact\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.676864504814148,
          "doc_string": "A set `s` is compact if for every open cover of `s`, there exists a finite subcover.",
          "statement": "theorem is_compact_of_finite_subcover {α : Type u} [topological_space α] {s : set α} (h : ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)) : is_compact s"
        },
        {
          "sim_score": 0.6767893433570862,
          "doc_string": "For every open cover of a compact set, there exists a finite subcover.",
          "statement": "theorem is_compact.elim_finite_subcover_image {α : Type u} {ι : Type u_1} [topological_space α] {s : set α} {b : set ι} {c : ι → set α} (hs : is_compact s) (hc₁ : ∀ (i : ι), i ∈ b → is_open (c i)) (hc₂ : s ⊆ ⋃ (i : ι) (H : i ∈ b), c i) : ∃ (b' : set ι) (H : b' ⊆ b), b'.finite ∧ s ⊆ ⋃ (i : ι) (H : i ∈ b'), c i"
        },
        {
          "sim_score": 0.6767893433570862,
          "doc_string": "For every open cover of a compact set, there exists a finite subcover.",
          "statement": "theorem is_compact.elim_finite_subcover {α : Type u} [topological_space α] {s : set α} {ι : Type v} (hs : is_compact s) (U : ι → set α) (hUo : ∀ (i : ι), is_open (U i)) (hsU : s ⊆ ⋃ (i : ι), U i) : ∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i"
        },
        {
          "sim_score": 0.65172278881073,
          "doc_string": " A set `s` is compact if and only if for every open cover of `s`, there exists a finite subcover.",
          "statement": "theorem is_compact_iff_finite_subcover {α : Type u} [topological_space α] {s : set α} : is_compact s ↔ ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)"
        }
      ],
      "codex_time": 4.463791654998204,
      "search_time": 1.4327223660075106,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem is_compact_fintype{α : Type u} [TopologicalSpace α] (h : Fintype α) : IsCompact α ",
      "theorem is_compact_fintype{α : Type u} [TopologicalSpace α] (h : Fintypeₓ α) : IsCompact α ",
      "theorem finite_iff_compact{α : Type u} [TopologicalSpace α] : Finite α ↔ IsCompact α ",
      "theorem finite.compact{α : Type u} [TopologicalSpace α] (h : Finite α) : IsCompact α ",
      "theorem finset.finite_topological_space_is_compact {α : Type*} [t : TopologicalSpace α]  (b : Finset α) : IsCompact b ",
      "theorem is_compact.finite{α : Type*} [TopologicalSpace α] [Fintype α] : IsCompact α ",
      "theorem is_compact.finite{α : Type*} [TopologicalSpace α] [Fintypeₓ α] : IsCompact α "
    ],
    "answer": "theorem finite_space_compact {X : Type _}[TopologicalSpace X][Finite X] : CompactSpace X "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "finite_space_compact",
      "main_prompt": "Every finite topological space is compact",
      "prompt": "Natural language version: \"Every finite topological space is compact\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 13.868266420002328,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem Every_finite_topological_space_is_compact : ∀ X, finite_topological_space X → IsCompact X ",
      "theorem is_every_finite_topological_space_compact (X : Type) [t : TopologicalSpace X] : IsCompact (finite_topology X) ",
      "theorem my_theorem : ∀ X : Type, Finite X → IsCompact X ",
      "theorem Finite_topological_space.compact {X : Type*} [TopologicalSpace X] (hfinite : Fintype X) : IsCompact X  You will have to use the NOTATION command, as well as the #check command to look up what Nat and Fin gt.  You will also have to use the examples in the Lean library to find the various structures we use in mathlib.  Find all the declarations that could conceivably be imported. (Hint: mathlib is organized into directories.)   What is the type of the hypothesis hfinite   What is the type of the conclusion comp   Use #check to look for the declaration of Fintype   Use #check to look",
      "theorem Finite_topological_space.compact {X : Type*} [TopologicalSpace X] (hfinite : Fintype X) : IsCompact X  You will have to use the NOTATION command, as well as the #check command to look up what Nat and Finₓ gt.  You will also have to use the examples in the Lean library to find the various structures we use in mathlib.  Find all the declarations that could conceivably be imported. (Hint: mathlib is organized into directories.)   What is the type of the hypothesis hfinite   What is the type of the conclusion comp   Use #check to look for the declaration of Fintype   Use #check to look",
      "theorem Finite_topological_space.compact {X : Type*} [TopologicalSpace X] (hfinite : Fintypeₓ X) : IsCompact X  You will have to use the NOTATION command, as well as the #check command to look up what Nat and Fin gt.  You will also have to use the examples in the Lean library to find the various structures we use in mathlib.  Find all the declarations that could conceivably be imported. (Hint: mathlib is organized into directories.)   What is the type of the hypothesis hfinite   What is the type of the conclusion comp   Use #check to look for the declaration of Fintypeₓ   Use #check to look",
      "theorem Finite_topological_space.compact {X : Type*} [TopologicalSpace X] (hfinite : Fintypeₓ X) : IsCompact X  You will have to use the NOTATION command, as well as the #check command to look up what Nat and Finₓ gt.  You will also have to use the examples in the Lean library to find the various structures we use in mathlib.  Find all the declarations that could conceivably be imported. (Hint: mathlib is organized into directories.)   What is the type of the hypothesis hfinite   What is the type of the conclusion comp   Use #check to look for the declaration of Fintypeₓ   Use #check to look",
      "theorem 1 : ∀ ( X : Type ) [ TopologicalSpace X ], ∀ ( I : Finset X ), *  *   Definition:   theorem : ∀ (X : Type) [TopologicalSpace X],   Finset X → exists f : X → ℕ, bijective f ∧ CompactSpace (induced f)   theorem   (X : Type) [TopologicalSpace X]  : Finset X → exists f : X → ℕ, bijective f ∧ CompactSpace (induced f)   example { X : Type } [ TopologicalSpace X ] ( f : X →  ℕ ) : bi"
    ],
    "answer": "theorem finite_space_compact {X : Type _}[TopologicalSpace X][Finite X] : CompactSpace X "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "freegroup_hopfian",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every surjective homomorphism from a finitely generated free group to itself is injective\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every surjective homomorphism from a finitely generated free group to itself is injective",
      "codex_time": 10.182387432985706,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem injection_of_surjective_homomorphism_of_finitely_generated_free (F : Type*) [FreeGroup F] [Fintype F]  (hf : ∃ g : F → F, Function.LeftInverse g ∘ g = id ∧ g ∘ Function.LeftInverse g = id):  ∃ f : F → F, Function.LeftInverse f ∘ f = id ∧ f ∘ Function.LeftInverse f = id ",
      "theorem injection_of_surjective_homomorphism_of_finitely_generated_free (F : Type*) [FreeGroup F] [Fintypeₓ F]  (hf : ∃ g : F → F, Function.LeftInverse g ∘ g = id ∧ g ∘ Function.LeftInverse g = id):  ∃ f : F → F, Function.LeftInverse f ∘ f = id ∧ f ∘ Function.LeftInverse f = id ",
      "theorem surjective_homomorphism_injective_free_group (G : Type*) [Group G] (n : ℕ) (f : FreeGroup n → G)  (hf : surjective f) :  injective f ",
      "theorem surjective_homomorphism_injective_free_group (G : Type*) [Groupₓₓ G] (n : ℕ) (f : FreeGroup n → G)  (hf : surjective f) :  injective f ",
      "theorem surjective_homomorphism_injective_free_group (G : Type*) [Groupₓ G] (n : ℕ) (f : FreeGroup n → G)  (hf : surjective f) :  injective f ",
      "theorem surjective_homomorphism_of_fin_gen_free_group_injects (G : Type*) [Group G]  (f : G → G) (hf : ∃ n, f (λ i : Fin n, 1) = 1)  (H : ∀ g h, f (g * h) = f g * f h) :  (∀ a, ∃ x, f x = a) → inj_on f (Set.Range f) ",
      "theorem surjective_homomorphism_of_fin_gen_free_group_injects (G : Type*) [Groupₓₓ G]  (f : G → G) (hf : ∃ n, f (λ i : Fin n, 1) = 1)  (H : ∀ g h, f (g * h) = f g * f h) :  (∀ a, ∃ x, f x = a) → inj_on f (Set.Range f) ",
      "theorem surjective_homomorphism_of_fin_gen_free_group_injects (G : Type*) [Group G]  (f : G → G) (hf : ∃ n, f (λ i : Fin n, 1) = 1)  (H : ∀ g h, f (g * h) = f g * f h) :  (∀ a, ∃ x, f x = a) → inj_on f (Setₓ.Range f) ",
      "theorem surjective_homomorphism_of_fin_gen_free_group_injects (G : Type*) [Groupₓₓ G]  (f : G → G) (hf : ∃ n, f (λ i : Fin n, 1) = 1)  (H : ∀ g h, f (g * h) = f g * f h) :  (∀ a, ∃ x, f x = a) → inj_on f (Setₓ.Range f) ",
      "theorem surjective_homomorphism_of_fin_gen_free_group_injects (G : Type*) [Group G]  (f : G → G) (hf : ∃ n, f (λ i : Finₓ n, 1) = 1)  (H : ∀ g h, f (g * h) = f g * f h) :  (∀ a, ∃ x, f x = a) → inj_on f (Set.Range f) ",
      "theorem surjective_homomorphism_of_fin_gen_free_group_injects (G : Type*) [Groupₓₓ G]  (f : G → G) (hf : ∃ n, f (λ i : Finₓ n, 1) = 1)  (H : ∀ g h, f (g * h) = f g * f h) :  (∀ a, ∃ x, f x = a) → inj_on f (Set.Range f) ",
      "theorem surjective_homomorphism_of_fin_gen_free_group_injects (G : Type*) [Group G]  (f : G → G) (hf : ∃ n, f (λ i : Finₓ n, 1) = 1)  (H : ∀ g h, f (g * h) = f g * f h) :  (∀ a, ∃ x, f x = a) → inj_on f (Setₓ.Range f) ",
      "theorem surjective_homomorphism_of_fin_gen_free_group_injects (G : Type*) [Groupₓₓ G]  (f : G → G) (hf : ∃ n, f (λ i : Finₓ n, 1) = 1)  (H : ∀ g h, f (g * h) = f g * f h) :  (∀ a, ∃ x, f x = a) → inj_on f (Setₓ.Range f) ",
      "theorem surjective_homomorphism_of_fin_gen_free_group_injects (G : Type*) [Groupₓ G]  (f : G → G) (hf : ∃ n, f (λ i : Fin n, 1) = 1)  (H : ∀ g h, f (g * h) = f g * f h) :  (∀ a, ∃ x, f x = a) → inj_on f (Set.Range f) ",
      "theorem surjective_homomorphism_of_fin_gen_free_group_injects (G : Type*) [Groupₓ G]  (f : G → G) (hf : ∃ n, f (λ i : Fin n, 1) = 1)  (H : ∀ g h, f (g * h) = f g * f h) :  (∀ a, ∃ x, f x = a) → inj_on f (Setₓ.Range f) ",
      "theorem surjective_homomorphism_of_fin_gen_free_group_injects (G : Type*) [Groupₓ G]  (f : G → G) (hf : ∃ n, f (λ i : Finₓ n, 1) = 1)  (H : ∀ g h, f (g * h) = f g * f h) :  (∀ a, ∃ x, f x = a) → inj_on f (Set.Range f) ",
      "theorem surjective_homomorphism_of_fin_gen_free_group_injects (G : Type*) [Groupₓ G]  (f : G → G) (hf : ∃ n, f (λ i : Finₓ n, 1) = 1)  (H : ∀ g h, f (g * h) = f g * f h) :  (∀ a, ∃ x, f x = a) → inj_on f (Setₓ.Range f) ",
      "theorem injectivity_of_surjective_homomorphisms_from_fg_free_groups (G : Type*) [Group G]  (hG_fg : Fintype (G)) (hG_free : FreeGroup G) (f : G →* G) :  Function.Surjective f → Function.Injective f ",
      "theorem injectivity_of_surjective_homomorphisms_from_fg_free_groups (G : Type*) [Groupₓₓ G]  (hG_fg : Fintype (G)) (hG_free : FreeGroup G) (f : G →* G) :  Function.Surjective f → Function.Injective f ",
      "theorem injectivity_of_surjective_homomorphisms_from_fg_free_groups (G : Type*) [Groupₓ G]  (hG_fg : Fintype (G)) (hG_free : FreeGroup G) (f : G →* G) :  Function.Surjective f → Function.Injective f ",
      "theorem injectivity_of_surjective_homomorphisms_from_fg_free_groups (G : Type*) [Group G]  (hG_fg : Fintypeₓ (G)) (hG_free : FreeGroup G) (f : G →* G) :  Function.Surjective f → Function.Injective f ",
      "theorem injectivity_of_surjective_homomorphisms_from_fg_free_groups (G : Type*) [Groupₓₓ G]  (hG_fg : Fintypeₓ (G)) (hG_free : FreeGroup G) (f : G →* G) :  Function.Surjective f → Function.Injective f ",
      "theorem injectivity_of_surjective_homomorphisms_from_fg_free_groups (G : Type*) [Groupₓ G]  (hG_fg : Fintypeₓ (G)) (hG_free : FreeGroup G) (f : G →* G) :  Function.Surjective f → Function.Injective f ",
      "theorem surjective_homomorphism_of_finitely_generated_free_group_to_itself_is_injective {F G: Type*}  [Group F] [Group G] (f : F → G) (hf : Function.Surjective f)  (hFfin : Fintype.card F < ℕ) (hGfin : Fintype.card G < ℕ) :  Function.Injective f ",
      "theorem surjective_homomorphism_of_finitely_generated_free_group_to_itself_is_injective {F G: Type*}  [Groupₓₓ F] [Groupₓₓ G] (f : F → G) (hf : Function.Surjective f)  (hFfin : Fintype.card F < ℕ) (hGfin : Fintype.card G < ℕ) :  Function.Injective f ",
      "theorem surjective_homomorphism_of_finitely_generated_free_group_to_itself_is_injective {F G: Type*}  [Groupₓ F] [Groupₓ G] (f : F → G) (hf : Function.Surjective f)  (hFfin : Fintype.card F < ℕ) (hGfin : Fintype.card G < ℕ) :  Function.Injective f ",
      "theorem surjective_homomorphism_of_finitely_generated_free_group_to_itself_is_injective {F G: Type*}  [Group F] [Group G] (f : F → G) (hf : Function.Surjective f)  (hFfin : Fintypeₓ.card F < ℕ) (hGfin : Fintypeₓ.card G < ℕ) :  Function.Injective f ",
      "theorem surjective_homomorphism_of_finitely_generated_free_group_to_itself_is_injective {F G: Type*}  [Groupₓₓ F] [Groupₓₓ G] (f : F → G) (hf : Function.Surjective f)  (hFfin : Fintypeₓ.card F < ℕ) (hGfin : Fintypeₓ.card G < ℕ) :  Function.Injective f ",
      "theorem surjective_homomorphism_of_finitely_generated_free_group_to_itself_is_injective {F G: Type*}  [Groupₓ F] [Groupₓ G] (f : F → G) (hf : Function.Surjective f)  (hFfin : Fintypeₓ.card F < ℕ) (hGfin : Fintypeₓ.card G < ℕ) :  Function.Injective f "
    ],
    "answer": "theorem freegroup_hopfian {α : Type _} [Finite α]: (f: FreeGroup α → FreeGroup α) → (IsGroupHom f) → f.Surjective → f.Injective "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "freegroup_hopfian",
      "main_prompt": "Every surjective homomorphism from a finitely generated free group to itself is injective",
      "prompt": "Natural language version: \"The canonical injection from the type to the free group is an injection.\" Translate the natural language version to a Lean mathlib version:\n theorem free_group.of_injective{α : Type u} :\nfunction.injective free_group.of := \n\nNatural language version: \"A group homomorphism is injective iff its kernel is trivial.\" Translate the natural language version to a Lean mathlib version:\n theorem is_group_hom.injective_iff{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) :\nfunction.injective f ↔ ∀ (a : α), f a = 1 → a = 1 := \n\nNatural language version: \" Two homomorphisms out of a free group are equal if they are equal on generators.  See note [partially-applied ext lemmas].\" Translate the natural language version to a Lean mathlib version:\n theorem free_group.ext_hom{α : Type u} {G : Type u_1} [group G] (f g : free_group α →* G) (h : ∀ (a : α), ⇑f (free_group.of a) = ⇑g (free_group.of a)) :\nf = g := \n\nNatural language version: \"The range of a surjective homomorphism from a nilpotent group is nilpotent\" Translate the natural language version to a Lean mathlib version:\n theorem nilpotent_of_surjective{G : Type u_1} [group G] {G' : Type u_2} [group G'] [h : group.is_nilpotent G] (f : G →* G') (hf : function.surjective ⇑f) :\ngroup.is_nilpotent G' := \n\nNatural language version: \"Every surjective homomorphism from a finitely generated free group to itself is injective\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6470739841461182,
          "doc_string": "The canonical injection from the type to the free group is an injection.",
          "statement": "theorem free_group.of_injective {α : Type u} : function.injective free_group.of"
        },
        {
          "sim_score": 0.6357327103614807,
          "doc_string": "A group homomorphism is injective iff its kernel is trivial.",
          "statement": "theorem is_group_hom.injective_iff {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 1 → a = 1"
        },
        {
          "sim_score": 0.5912977457046509,
          "doc_string": " Two homomorphisms out of a free group are equal if they are equal on generators.  See note [partially-applied ext lemmas].",
          "statement": "theorem free_group.ext_hom {α : Type u} {G : Type u_1} [group G] (f g : free_group α →* G) (h : ∀ (a : α), ⇑f (free_group.of a) = ⇑g (free_group.of a)) : f = g"
        },
        {
          "sim_score": 0.5858901143074036,
          "doc_string": "The range of a surjective homomorphism from a nilpotent group is nilpotent",
          "statement": "theorem nilpotent_of_surjective {G : Type u_1} [group G] {G' : Type u_2} [group G'] [h : group.is_nilpotent G] (f : G →* G') (hf : function.surjective ⇑f) : group.is_nilpotent G'"
        }
      ],
      "codex_time": 9.860292875993764,
      "search_time": 1.4647069969796576,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem free_group.surjective_injective_of_finitely_generated{G : Type u} [Fintype G] [Group G] {f : FreeGroup G →* FreeGroup G} (hf : Function.Surjective ⇑f) : Function.Injective ⇑f ",
      "theorem free_group.surjective_injective_of_finitely_generated{G : Type u} [Fintype G] [Groupₓₓ G] {f : FreeGroup G →* FreeGroup G} (hf : Function.Surjective ⇑f) : Function.Injective ⇑f ",
      "theorem free_group.surjective_injective_of_finitely_generated{G : Type u} [Fintype G] [Groupₓ G] {f : FreeGroup G →* FreeGroup G} (hf : Function.Surjective ⇑f) : Function.Injective ⇑f ",
      "theorem free_group.surjective_injective_of_finitely_generated{G : Type u} [Fintypeₓ G] [Group G] {f : FreeGroup G →* FreeGroup G} (hf : Function.Surjective ⇑f) : Function.Injective ⇑f ",
      "theorem free_group.surjective_injective_of_finitely_generated{G : Type u} [Fintypeₓ G] [Groupₓₓ G] {f : FreeGroup G →* FreeGroup G} (hf : Function.Surjective ⇑f) : Function.Injective ⇑f ",
      "theorem free_group.surjective_injective_of_finitely_generated{G : Type u} [Fintypeₓ G] [Groupₓ G] {f : FreeGroup G →* FreeGroup G} (hf : Function.Surjective ⇑f) : Function.Injective ⇑f ",
      "theorem free_group.surj_inj{α : Type u} {G : Type u_1} [Group G] (f : FreeGroup α →* G) (hf : Function.Surjective ⇑f) (h : free_group.is_of_fintype α) : Function.Injective ⇑f ",
      "theorem free_group.surj_inj{α : Type u} {G : Type u_1} [Groupₓₓ G] (f : FreeGroup α →* G) (hf : Function.Surjective ⇑f) (h : free_group.is_of_fintype α) : Function.Injective ⇑f ",
      "theorem free_group.surj_inj{α : Type u} {G : Type u_1} [Groupₓ G] (f : FreeGroup α →* G) (hf : Function.Surjective ⇑f) (h : free_group.is_of_fintype α) : Function.Injective ⇑f ",
      "theorem hom.injective_of_surjective_of_fg_free{α : Type u} (G : Type u_1) [Group G] {f : G →* G} (hf : Function.Surjective ⇑f) {g : FreeGroup α →* G} (hg : f = g) : Function.Injective ⇑g ",
      "theorem hom.injective_of_surjective_of_fg_free{α : Type u} (G : Type u_1) [Groupₓₓ G] {f : G →* G} (hf : Function.Surjective ⇑f) {g : FreeGroup α →* G} (hg : f = g) : Function.Injective ⇑g ",
      "theorem hom.injective_of_surjective_of_fg_free{α : Type u} (G : Type u_1) [Groupₓ G] {f : G →* G} (hf : Function.Surjective ⇑f) {g : FreeGroup α →* G} (hg : f = g) : Function.Injective ⇑g ",
      "theorem free_group.injective_of_surjective [Fintype α] {G : Type u} [Group G] (f : free_group.π α →* G) : Function.Surjective f → Function.Injective f ",
      "theorem free_group.injective_of_surjective [Fintype α] {G : Type u} [Groupₓₓ G] (f : free_group.π α →* G) : Function.Surjective f → Function.Injective f ",
      "theorem free_group.injective_of_surjective [Fintype α] {G : Type u} [Groupₓ G] (f : free_group.π α →* G) : Function.Surjective f → Function.Injective f ",
      "theorem free_group.injective_of_surjective [Fintypeₓ α] {G : Type u} [Group G] (f : free_group.π α →* G) : Function.Surjective f → Function.Injective f ",
      "theorem free_group.injective_of_surjective [Fintypeₓ α] {G : Type u} [Groupₓₓ G] (f : free_group.π α →* G) : Function.Surjective f → Function.Injective f ",
      "theorem free_group.injective_of_surjective [Fintypeₓ α] {G : Type u} [Groupₓ G] (f : free_group.π α →* G) : Function.Surjective f → Function.Injective f ",
      "theorem free_group.surjective_injective{α : Type u} (n : ℕ) (f : FreeGroup α →+* FreeGroup α) (hf : Function.Surjective ⇑f) : Function.Injective ⇑f "
    ],
    "answer": "theorem freegroup_hopfian {α : Type _} [Finite α]: (f: FreeGroup α → FreeGroup α) → (IsGroupHom f) → f.Surjective → f.Injective "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "freegroup_hopfian",
      "main_prompt": "Every surjective homomorphism from a finitely generated free group to itself is injective",
      "prompt": "Natural language version: \"Every surjective homomorphism from a finitely generated free group to itself is injective\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 12.162902993004536,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem nat_lang_to_lean : ∀ f : F → F , ( ∃ e j , ( e ⊕ j , e , j ) ≼ F ) → ( f",
      "theorem injective_hom_from_free_to_free (R : Type) (s : Finset R) (k : R → R) (k_inj : Function.Injective k) (k0 : ∀ (r ∈ s), k r = r) : Function.Injective (λ r, k r) ",
      "theorem intial_clue (R : Type *) [CommRing R] (m n : ℕ) (h : m ≤ n) (h1 : m ≠ 0) :   Finset.range n.succ ≤ insert n (Finset.range m) ",
      "theorem intial_clue (R : Type *) [CommRingₓₓ R] (m n : ℕ) (h : m ≤ n) (h1 : m ≠ 0) :   Finset.range n.succ ≤ insert n (Finset.range m) ",
      "theorem intial_clue (R : Type *) [CommRingₓ R] (m n : ℕ) (h : m ≤ n) (h1 : m ≠ 0) :   Finset.range n.succ ≤ insert n (Finset.range m) ",
      "theorem free_group.surjective_is_injective {n: ℕ} (g : FreeGroup n)   (h : surjective g) : injective g ",
      "theorem every_surjective_hom_from_fg_free_group_to_itself_is_injective {α : Type*} [Fintype α] [DecidableEq α] [Fintype (α → α)] [DecidableEq (α → α)] (h : surjective (s : Multiset α → Multiset α)) : injective s ",
      "theorem every_surjective_hom_from_fg_free_group_to_itself_is_injective {α : Type*} [Fintypeₓ α] [DecidableEq α] [Fintypeₓ (α → α)] [DecidableEq (α → α)] (h : surjective (s : Multiset α → Multiset α)) : injective s "
    ],
    "answer": "theorem freegroup_hopfian {α : Type _} [Finite α]: (f: FreeGroup α → FreeGroup α) → (IsGroupHom f) → f.Surjective → f.Injective "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "polys_unbounded",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every polynomial of positive degree over reals is unbounded.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every polynomial of positive degree over reals is unbounded.",
      "codex_time": 14.27699931699317,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem poly_is_unbounded (n : Nat) :  n > 0 → ∀ (p : Polynomial ℝ), ∀ x : ℝ, ∃ n : ℕ, abs (p.eval x) > n ",
      "theorem unboundedness_of_every_polynomial (R : Type*) [Ring R]  [is_real_ring R] (n : ℕ) (h_n_not_0 : n ≠ 0) (p : Polynomial R) :  ∀ b : ℝ, ∃ a : ℝ, ∃ x : ℝ, p.eval x = a * x ^ n + b ",
      "theorem unboundedness_of_every_polynomial (R : Type*) [Ringₓₓ R]  [is_real_ring R] (n : ℕ) (h_n_not_0 : n ≠ 0) (p : Polynomial R) :  ∀ b : ℝ, ∃ a : ℝ, ∃ x : ℝ, p.eval x = a * x ^ n + b ",
      "theorem unboundedness_of_every_polynomial (R : Type*) [Ringₓ R]  [is_real_ring R] (n : ℕ) (h_n_not_0 : n ≠ 0) (p : Polynomial R) :  ∀ b : ℝ, ∃ a : ℝ, ∃ x : ℝ, p.eval x = a * x ^ n + b ",
      "theorem poly_of_positive_degree (X : Type*) [Ring X] (f : Polynomial.x)  (hf_pos : 0 < degree f) : ∀ x ∈ X, ∃ x' ∈ X, ∥x'∥ > ∥x∥ ",
      "theorem poly_of_positive_degree (X : Type*) [Ringₓₓ X] (f : Polynomial.x)  (hf_pos : 0 < degree f) : ∀ x ∈ X, ∃ x' ∈ X, ∥x'∥ > ∥x∥ ",
      "theorem poly_of_positive_degree (X : Type*) [Ringₓ X] (f : Polynomial.x)  (hf_pos : 0 < degree f) : ∀ x ∈ X, ∃ x' ∈ X, ∥x'∥ > ∥x∥ ",
      "theorem poly_of_positive_degree_is_unbounded (p : Polynomial ℝ) (hdeg : 0 < p.degree) :  ∀ x : ℝ, ∃ y : ℝ, p.eval y = x ",
      "theorem polynomial_of_positive_degree_is_unbounded (n : ℕ) (p : Polynomial ℝ) (hn : degree p > 0):  ∀ a : ℝ, ∃ x : ℝ, ∃ δ : ℝ, x > -δ ∧ ∃ ε : ℝ, ε > 0 ∧ (∀ y : ℝ, abs (y - a) < δ → abs (p.eval y - p.eval a) > ε):  ∀ a : ℝ, ∃ x : ℝ, ∃ δ : ℝ, ("
    ],
    "answer": "theorem polys_unbounded (p: Polynomial ℝ) : p.degree > 0 → ∀ m: ℝ, ∃ x: ℝ, p.eval x  > m ∨ p.eval x < -m  "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "polys_unbounded",
      "main_prompt": "Every polynomial of positive degree over reals is unbounded.",
      "prompt": "Natural language version: \"An alternative statement of Weierstrass' theorem.  Every real-valued continuous function on `[a,b]` is a uniform limit of polynomials.\" Translate the natural language version to a Lean mathlib version:\n theorem continuous_map_mem_polynomial_functions_closure(a b : ℝ) (f : C(↥(set.Icc a b), ℝ)) :\nf ∈ (polynomial_functions (set.Icc a b)).topological_closure := \n\nNatural language version: \"The degree of a product of polynomials is at most the sum of the degrees, where the degree of the zero polynomial is ⊥.\" Translate the natural language version to a Lean mathlib version:\n theorem polynomial.degree_multiset_prod_le{R : Type u} [comm_semiring R] (t : multiset (polynomial R)) :\nt.prod.degree ≤ (multiset.map polynomial.degree t).sum := \n\nNatural language version: \"The **Weierstrass Approximation Theorem**: polynomials functions on `[a, b] ⊆ ℝ` are dense in `C([a,b],ℝ)`  (While we could deduce this as an application of the Stone-Weierstrass theorem, our proof of that relies on the fact that `abs` is in the closure of polynomials on `[-M, M]`, so we may as well get this done first.)\" Translate the natural language version to a Lean mathlib version:\n theorem polynomial_functions_closure_eq_top(a b : ℝ) :\n(polynomial_functions (set.Icc a b)).topological_closure = ⊤ := \n\nNatural language version: \" The monomial function `x^n` tends to `+∞` at `+∞` for any positive natural `n`. A version for positive real powers exists as `tendsto_rpow_at_top`.\" Translate the natural language version to a Lean mathlib version:\n theorem filter.tendsto_pow_at_top{α : Type u_3} [ordered_semiring α] {n : ℕ} (hn : 1 ≤ n) :\nfilter.tendsto (λ (x : α), x ^ n) filter.at_top filter.at_top := \n\nNatural language version: \"Every polynomial of positive degree over reals is unbounded.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5175106525421143,
          "doc_string": "An alternative statement of Weierstrass' theorem.  Every real-valued continuous function on `[a,b]` is a uniform limit of polynomials.",
          "statement": "theorem continuous_map_mem_polynomial_functions_closure (a b : ℝ) (f : C(↥(set.Icc a b), ℝ)) : f ∈ (polynomial_functions (set.Icc a b)).topological_closure"
        },
        {
          "sim_score": 0.5134747624397278,
          "doc_string": "The degree of a product of polynomials is at most the sum of the degrees, where the degree of the zero polynomial is ⊥.",
          "statement": "theorem polynomial.degree_multiset_prod_le {R : Type u} [comm_semiring R] (t : multiset (polynomial R)) : t.prod.degree ≤ (multiset.map polynomial.degree t).sum"
        },
        {
          "sim_score": 0.5014804005622864,
          "doc_string": "The **Weierstrass Approximation Theorem**: polynomials functions on `[a, b] ⊆ ℝ` are dense in `C([a,b],ℝ)`  (While we could deduce this as an application of the Stone-Weierstrass theorem, our proof of that relies on the fact that `abs` is in the closure of polynomials on `[-M, M]`, so we may as well get this done first.)",
          "statement": "theorem polynomial_functions_closure_eq_top (a b : ℝ) : (polynomial_functions (set.Icc a b)).topological_closure = ⊤"
        },
        {
          "sim_score": 0.48543989658355713,
          "doc_string": " The monomial function `x^n` tends to `+∞` at `+∞` for any positive natural `n`. A version for positive real powers exists as `tendsto_rpow_at_top`.",
          "statement": "theorem filter.tendsto_pow_at_top {α : Type u_3} [ordered_semiring α] {n : ℕ} (hn : 1 ≤ n) : filter.tendsto (λ (x : α), x ^ n) filter.at_top filter.at_top"
        }
      ],
      "codex_time": 6.2306809650035575,
      "search_time": 1.434766952006612,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem is_bounded_polynomial_iff_degree_le_zero(R : Type u_1) [LinearOrderedField R] (t : Polynomial R) : is_bounded ((@Polynomial.eval _ _ R) t) ↔ Polynomial.degree t ≤ 0 ",
      "theorem unbounded_of_degree_pos{R : Type u} [nonzero_comm_ring R] {F : Type*} [Field F] (a : Polynomial R) (h : Polynomial.degree a > 0) : ∃C : ℚ, C > 0 ∧ ∀x:Polynomial R, ∀b : F, Polynomial.eval₂ a x b ≤ C ",
      "theorem polynomial.unbounded_of_degree_pos{R : Type u} [discrete_field R] {p : Polynomial R} (hp0 : p.degree > 0) : ∀ x : R, ∃ y : R, x < y ∧ p y ≠ 0 ",
      "theorem unbounded_polynomial_of_degree_pos (f : Polynomial ℝ) {n : ℕ} (hn : 0 < n) : unbounded (λ (x : ℝ), f.eval x) ",
      "theorem ne_top_then_supr_not_is_lub{α : Type u} [TopologicalSpace α] [completely_lattice α] (a : β) (f : β → α) : ¬ IsLub (Supr f) (f '' Set.Univ) ",
      "theorem ne_top_then_supr_not_is_lub{α : Type u} [TopologicalSpace α] [completely_lattice α] (a : β) (f : β → α) : ¬ IsLub (Supr f) (f '' Setₓ.Univ) "
    ],
    "answer": "theorem polys_unbounded (p: Polynomial ℝ) : p.degree > 0 → ∀ m: ℝ, ∃ x: ℝ, p.eval x  > m ∨ p.eval x < -m  "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "polys_unbounded",
      "main_prompt": "Every polynomial of positive degree over reals is unbounded.",
      "prompt": "Natural language version: \"Every polynomial of positive degree over reals is unbounded.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 10.618605050985934,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem C { α : Type } [ CommRing α ] ( Polynomial : α → ℝ ) ( d : ℕ ) ( Hnonzero : ∀ x : α , 0 ≤ ( Polynomial x ) * ( Polynomial x ) )    ( Hd : 0 < d ) : False ",
      "theorem C { α : Type } [ CommRingₓₓ α ] ( Polynomial : α → ℝ ) ( d : ℕ ) ( Hnonzero : ∀ x : α , 0 ≤ ( Polynomial x ) * ( Polynomial x ) )    ( Hd : 0 < d ) : False ",
      "theorem C { α : Type } [ CommRingₓ α ] ( Polynomial : α → ℝ ) ( d : ℕ ) ( Hnonzero : ∀ x : α , 0 ≤ ( Polynomial x ) * ( Polynomial x ) )    ( Hd : 0 < d ) : False ",
      "theorem nl_mathlib : ∀ n:ℕ, n>0 → (∃ x:ℝ, ∀ f:ℝ → ℝ, f.degree_le n → (∃ y:ℝ, ¬ f y = 0)) ",
      "theorem polynomial_cobounded (k : ℝ) : ∃ M, ∀ x, ∀P:ℕ → ℤ, ∀c:ℤ, (degree P ≥ k)  ∧ (P ≠ 0) → Nat.find (λ n : ℕ, (abs (Polynomial.eval P x - c))  > M * (abs (Polynomial.eval P n - c))) nz  lemma nat_find_0_aux M c (h : c > -M) (h1 : c < M) :  ∀ n, abs (M - c) < (abs (nz - c))",
      "theorem polynomial_unbounded (p : Polynomial ℝ) (hp : p.degree > 0) :   ∃ (x : ℝ), ∀ (n : ℕ), abs (p.eval a) < n ",
      "theorem polynomial_unbounded (f : Polynomial ℝ) (hf : degree f > 0) : ∀ r : ℝ, ∃ x : ℝ, abs (f.eval x) > r "
    ],
    "answer": "theorem polys_unbounded (p: Polynomial ℝ) : p.degree > 0 → ∀ m: ℝ, ∃ x: ℝ, p.eval x  > m ∨ p.eval x < -m  "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "field_hom_inj_or_trivial",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"A homomorphism between fields is either injective or trivial.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A homomorphism between fields is either injective or trivial.",
      "codex_time": 4.984231541980989,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem ring_hom_either_injective_or_trivial (F : Type*) (G : Type*) [Field F] [Field G]  (φ : F →+* G) (hφ : trivial_ring_hom φ) : injective_ring_hom φ ",
      "theorem injective.of_ne_trivial_hom (f : α →ₗ[R] β) (x y : α)  (hx : f x ≠ 0) (hy : f y ≠ 0) (hxy : f (x + y) = 0):  x = 0 ∧ y = 0 ",
      "theorem field_hom_surj_inj (k l : Type*) [Field k] [Field l] (f : k → l)  (hf : IsRingHom f) : ∃ g : l → k, IsRingHom g ∧ ∀ x, f (g x) = x ",
      "theorem hom_between_fields_inj_or_trivial {F G : Type*} [Field F] [Field G]  (f : F → G) [IsRingHom f] (hf : f ≠ 0):  ∀ a b : F, (f a = f b) → (a = b) ",
      "theorem field_hom_injective_or_trivial {α β : Type*} [Field α] [Field β] (f : α → β) [IsRingHom f] (s : Set β) :  surjective f ∨ f '' s = ∅ ",
      "theorem field_hom_injective_or_trivial {α β : Type*} [Field α] [Field β] (f : α → β) [IsRingHom f] (s : Setₓ β) :  surjective f ∨ f '' s = ∅ "
    ],
    "answer": "theorem field_hom_inj_or_trivial {F F' : Type _} [Field F] [Field F'] : ∀ ϕ : F →+* F', ϕ.toFun.Injective ∨ (∀ x : F, ϕ x = 0) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "field_hom_inj_or_trivial",
      "main_prompt": "A homomorphism between fields is either injective or trivial.",
      "prompt": "Natural language version: \"A group homomorphism is injective iff its kernel is trivial.\" Translate the natural language version to a Lean mathlib version:\n theorem is_group_hom.injective_iff{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) :\nfunction.injective f ↔ ∀ (a : α), f a = 1 → a = 1 := \n\nNatural language version: \"If two ring homomorphisms are equal on a set, then they are equal on its subfield closure.\" Translate the natural language version to a Lean mathlib version:\n theorem ring_hom.eq_on_field_closure{K : Type u} {L : Type v} [field K] [field L] {f g : K →+* L} {s : set K} (h : set.eq_on ⇑f ⇑g s) :\nset.eq_on ⇑f ⇑g ↑(subfield.closure s) := \n\nNatural language version: \"A monomorphism is injective.\" Translate the natural language version to a Lean mathlib version:\n theorem linear_map.ker_eq_bot_of_cancel{R : Type u_1} {R₂ : Type u_3} {M : Type u_9} {M₂ : Type u_12} [semiring R] [semiring R₂] [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module R₂ M₂] {τ₁₂ : R →+* R₂} {f : M →ₛₗ[τ₁₂] M₂} (h : ∀ (u v : ↥(f.ker) →ₗ[R] M), f.comp u = f.comp v → u = v) :\nf.ker = ⊥ := \n\nNatural language version: \"An additive group homomorphism is injective if its kernel is trivial.\" Translate the natural language version to a Lean mathlib version:\n theorem is_add_group_hom.injective_iff{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) :\nfunction.injective f ↔ ∀ (a : α), f a = 0 → a = 0 := \n\nNatural language version: \"A homomorphism between fields is either injective or trivial.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6868539452552795,
          "doc_string": "A group homomorphism is injective iff its kernel is trivial.",
          "statement": "theorem is_group_hom.injective_iff {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 1 → a = 1"
        },
        {
          "sim_score": 0.6491084694862366,
          "doc_string": "If two ring homomorphisms are equal on a set, then they are equal on its subfield closure.",
          "statement": "theorem ring_hom.eq_on_field_closure {K : Type u} {L : Type v} [field K] [field L] {f g : K →+* L} {s : set K} (h : set.eq_on ⇑f ⇑g s) : set.eq_on ⇑f ⇑g ↑(subfield.closure s)"
        },
        {
          "sim_score": 0.6350299715995789,
          "doc_string": "A monomorphism is injective.",
          "statement": "theorem linear_map.ker_eq_bot_of_cancel {R : Type u_1} {R₂ : Type u_3} {M : Type u_9} {M₂ : Type u_12} [semiring R] [semiring R₂] [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module R₂ M₂] {τ₁₂ : R →+* R₂} {f : M →ₛₗ[τ₁₂] M₂} (h : ∀ (u v : ↥(f.ker) →ₗ[R] M), f.comp u = f.comp v → u = v) : f.ker = ⊥"
        },
        {
          "sim_score": 0.6343168020248413,
          "doc_string": "An additive group homomorphism is injective if its kernel is trivial.",
          "statement": "theorem is_add_group_hom.injective_iff {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 0 → a = 0"
        }
      ],
      "codex_time": 8.774585238017607,
      "search_time": 1.4498521750210784,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem field_hom.injective_or_trivial{K : Type u_25} [Field K] [unit_group K] {F : Type v_111} [Field F] [unit_group F] {f : K →+* F} (hf : ∀ (a ∈ F), ∃ k : K, a = f k) : Function.Injective f ∨ Function.Surjective f ",
      "theorem field.hom_eq_one_of_injective{F₁ : Type u_1} {F₂ : Type u_4} [Field F₁] [Field F₂] {f : F₁ →+* F₂} (h : ∀ x y, f x = f y → x = y) : Function.Injective f ",
      "theorem field.hom_injective_or_trivial{α : Type u} {β : Type v} [Field α] [Field β] {f : α →+* β} (hf : f ≠ 0) : Function.Injective f ∨ f = 0 ",
      "theorem alg_hom.injective_or_trivial{A : Type u_1} {B : Type u_2} {K : Type u_3} [Field K] [integral_domain A] [integral_domain B] [Algebra K A] [Algebra K B] {σ : A →+* B} (h : σ.is_algebra_map) : Function.Injective (⇑σ) ∨ Function.Surjective (⇑σ) ",
      "theorem is_field_hom.injective_or_trivial{K : Type u} {L : Type v} [Field K] [Field L] {τ : K →+* L} (h : is_field_hom τ) : Function.Injective τ ∨ (∀ (a : K), a ≠ 0 → τ a = 0) "
    ],
    "answer": "theorem field_hom_inj_or_trivial {F F' : Type _} [Field F] [Field F'] : ∀ ϕ : F →+* F', ϕ.toFun.Injective ∨ (∀ x : F, ϕ x = 0) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "field_hom_inj_or_trivial",
      "main_prompt": "A homomorphism between fields is either injective or trivial.",
      "prompt": "Natural language version: \"A homomorphism between fields is either injective or trivial.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 9.922715328983031,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem forall (F G : Type*) [Field F] [Field G] (f : F → G) (M : Set G) [is_subfield M],    injective f ∨ a1 (F) f (G) (set.injection f) M = ∅ ",
      "theorem forall (F G : Type*) [Field F] [Field G] (f : F → G) (M : Setₓ G) [is_subfield M],    injective f ∨ a1 (F) f (G) (set.injection f) M = ∅ ",
      "theorem foo (K L : Type*) [Field K] [Field L] (f : K → L) (h1 : Function.Injective f) : f 1 = 1 ↔ f 0 = 0.  --3. --Natural language version: \"If a Field has characteristic Zero, then it has a Subfield isomorphic to the rationals.\" Translate the natural language version to a Lean mathlib version.  --4. --Natural language version: \"If a Field has characteristic Zero, then it has no Nontrivial Finite subfields.\" Translate the natural language version to a Lean mathlib version:   --5. --Natural language version: \"A Field is Infinite",
      "theorem homomorphism_to_homomorphism (m : Monoid) (n : Monoid) (hmn : m ≃ n) : monoid_hom m n ",
      "theorem homomorphism_to_homomorphism (m : Monoidₓ) (n : Monoidₓ) (hmn : m ≃ n) : monoid_hom m n ",
      "theorem nesbitt_step_1 (k₁ k₂ : Type*) [Field k₁] [Field k₂] (f : k₁ → k₂) :  injective f ∨ ∀ a : k₁, f a = 0 ",
      "theorem field_lemmas_bot_of_inject_hom {α : Type v} [Field α] (f : integer → α) : injective f → f 0 = 0 "
    ],
    "answer": "theorem field_hom_inj_or_trivial {F F' : Type _} [Field F] [Field F'] : ∀ ϕ : F →+* F', ϕ.toFun.Injective ∨ (∀ x : F, ϕ x = 0) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "noetherian_implies_ascending_chain_condition",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every ascending chain of sub-modules of a Noetherian module eventually stabilises.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every ascending chain of sub-modules of a Noetherian module eventually stabilises.",
      "codex_time": 10.734952466009418,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem exists_equiv_lt_chain_stabilises (M : Type*) [Module ℤ M] (hM : noetherian ℤ M) (X Y : Submodule ℤ M) :  ∃ N : ℕ, ∀ m : ℕ, m ≥ N → X ≤ X.lt_succ m ",
      "theorem eventually_stable_submodules (R : Type*) [CommRing R]  (M : Type*) [AddCommGroup M] [Module R M] [noetherian_module R M]  (n : ℕ) (f : Fin n → Submodule R M)  (hf : ∀ i, f i ≤ f (i + 1)):  ∃ j : Fin n, ∀ i, f i ≤ f j ",
      "theorem eventually_stable_submodules (R : Type*) [CommRing R]  (M : Type*) [AddCommGroupₓₓ M] [Module R M] [noetherian_module R M]  (n : ℕ) (f : Fin n → Submodule R M)  (hf : ∀ i, f i ≤ f (i + 1)):  ∃ j : Fin n, ∀ i, f i ≤ f j ",
      "theorem eventually_stable_submodules (R : Type*) [CommRingₓₓ R]  (M : Type*) [AddCommGroup M] [Module R M] [noetherian_module R M]  (n : ℕ) (f : Fin n → Submodule R M)  (hf : ∀ i, f i ≤ f (i + 1)):  ∃ j : Fin n, ∀ i, f i ≤ f j ",
      "theorem eventually_stable_submodules (R : Type*) [CommRingₓₓ R]  (M : Type*) [AddCommGroupₓₓ M] [Module R M] [noetherian_module R M]  (n : ℕ) (f : Fin n → Submodule R M)  (hf : ∀ i, f i ≤ f (i + 1)):  ∃ j : Fin n, ∀ i, f i ≤ f j ",
      "theorem eventually_stable_submodules (R : Type*) [CommRing R]  (M : Type*) [AddCommGroupₓ M] [Module R M] [noetherian_module R M]  (n : ℕ) (f : Fin n → Submodule R M)  (hf : ∀ i, f i ≤ f (i + 1)):  ∃ j : Fin n, ∀ i, f i ≤ f j ",
      "theorem eventually_stable_submodules (R : Type*) [CommRingₓₓ R]  (M : Type*) [AddCommGroupₓ M] [Module R M] [noetherian_module R M]  (n : ℕ) (f : Fin n → Submodule R M)  (hf : ∀ i, f i ≤ f (i + 1)):  ∃ j : Fin n, ∀ i, f i ≤ f j ",
      "theorem eventually_stable_submodules (R : Type*) [CommRingₓ R]  (M : Type*) [AddCommGroup M] [Module R M] [noetherian_module R M]  (n : ℕ) (f : Fin n → Submodule R M)  (hf : ∀ i, f i ≤ f (i + 1)):  ∃ j : Fin n, ∀ i, f i ≤ f j ",
      "theorem eventually_stable_submodules (R : Type*) [CommRingₓ R]  (M : Type*) [AddCommGroupₓₓ M] [Module R M] [noetherian_module R M]  (n : ℕ) (f : Fin n → Submodule R M)  (hf : ∀ i, f i ≤ f (i + 1)):  ∃ j : Fin n, ∀ i, f i ≤ f j ",
      "theorem eventually_stable_submodules (R : Type*) [CommRingₓ R]  (M : Type*) [AddCommGroupₓ M] [Module R M] [noetherian_module R M]  (n : ℕ) (f : Fin n → Submodule R M)  (hf : ∀ i, f i ≤ f (i + 1)):  ∃ j : Fin n, ∀ i, f i ≤ f j ",
      "theorem eventually_stable_submodules (R : Type*) [CommRing R]  (M : Type*) [AddCommGroup M] [Module R M] [noetherian_module R M]  (n : ℕ) (f : Finₓ n → Submodule R M)  (hf : ∀ i, f i ≤ f (i + 1)):  ∃ j : Finₓ n, ∀ i, f i ≤ f j ",
      "theorem eventually_stable_submodules (R : Type*) [CommRing R]  (M : Type*) [AddCommGroupₓₓ M] [Module R M] [noetherian_module R M]  (n : ℕ) (f : Finₓ n → Submodule R M)  (hf : ∀ i, f i ≤ f (i + 1)):  ∃ j : Finₓ n, ∀ i, f i ≤ f j ",
      "theorem eventually_stable_submodules (R : Type*) [CommRingₓₓ R]  (M : Type*) [AddCommGroup M] [Module R M] [noetherian_module R M]  (n : ℕ) (f : Finₓ n → Submodule R M)  (hf : ∀ i, f i ≤ f (i + 1)):  ∃ j : Finₓ n, ∀ i, f i ≤ f j ",
      "theorem eventually_stable_submodules (R : Type*) [CommRingₓₓ R]  (M : Type*) [AddCommGroupₓₓ M] [Module R M] [noetherian_module R M]  (n : ℕ) (f : Finₓ n → Submodule R M)  (hf : ∀ i, f i ≤ f (i + 1)):  ∃ j : Finₓ n, ∀ i, f i ≤ f j ",
      "theorem eventually_stable_submodules (R : Type*) [CommRing R]  (M : Type*) [AddCommGroupₓ M] [Module R M] [noetherian_module R M]  (n : ℕ) (f : Finₓ n → Submodule R M)  (hf : ∀ i, f i ≤ f (i + 1)):  ∃ j : Finₓ n, ∀ i, f i ≤ f j ",
      "theorem eventually_stable_submodules (R : Type*) [CommRingₓₓ R]  (M : Type*) [AddCommGroupₓ M] [Module R M] [noetherian_module R M]  (n : ℕ) (f : Finₓ n → Submodule R M)  (hf : ∀ i, f i ≤ f (i + 1)):  ∃ j : Finₓ n, ∀ i, f i ≤ f j ",
      "theorem eventually_stable_submodules (R : Type*) [CommRingₓ R]  (M : Type*) [AddCommGroup M] [Module R M] [noetherian_module R M]  (n : ℕ) (f : Finₓ n → Submodule R M)  (hf : ∀ i, f i ≤ f (i + 1)):  ∃ j : Finₓ n, ∀ i, f i ≤ f j ",
      "theorem eventually_stable_submodules (R : Type*) [CommRingₓ R]  (M : Type*) [AddCommGroupₓₓ M] [Module R M] [noetherian_module R M]  (n : ℕ) (f : Finₓ n → Submodule R M)  (hf : ∀ i, f i ≤ f (i + 1)):  ∃ j : Finₓ n, ∀ i, f i ≤ f j ",
      "theorem eventually_stable_submodules (R : Type*) [CommRingₓ R]  (M : Type*) [AddCommGroupₓ M] [Module R M] [noetherian_module R M]  (n : ℕ) (f : Finₓ n → Submodule R M)  (hf : ∀ i, f i ≤ f (i + 1)):  ∃ j : Finₓ n, ∀ i, f i ≤ f j ",
      "theorem noetherian_modules {R : Type*}[CommRing R] (M : Type*) [AddCommGroup M] [Module R M]  (h_noeth : noetherian R) (h_ascending : ∀ (N : Submodule R M), ∃ s : ℕ, (∀ i : ℕ, i ≤ s → N ≤ ⟨N.carrier⟩^(i))):  ∃ s : ℕ, is_strictly_ascending s ⟨M.carrier⟩ ",
      "theorem noetherian_modules {R : Type*}[CommRing R] (M : Type*) [AddCommGroupₓₓ M] [Module R M]  (h_noeth : noetherian R) (h_ascending : ∀ (N : Submodule R M), ∃ s : ℕ, (∀ i : ℕ, i ≤ s → N ≤ ⟨N.carrier⟩^(i))):  ∃ s : ℕ, is_strictly_ascending s ⟨M.carrier⟩ ",
      "theorem noetherian_modules {R : Type*}[CommRingₓₓ R] (M : Type*) [AddCommGroup M] [Module R M]  (h_noeth : noetherian R) (h_ascending : ∀ (N : Submodule R M), ∃ s : ℕ, (∀ i : ℕ, i ≤ s → N ≤ ⟨N.carrier⟩^(i))):  ∃ s : ℕ, is_strictly_ascending s ⟨M.carrier⟩ ",
      "theorem noetherian_modules {R : Type*}[CommRingₓₓ R] (M : Type*) [AddCommGroupₓₓ M] [Module R M]  (h_noeth : noetherian R) (h_ascending : ∀ (N : Submodule R M), ∃ s : ℕ, (∀ i : ℕ, i ≤ s → N ≤ ⟨N.carrier⟩^(i))):  ∃ s : ℕ, is_strictly_ascending s ⟨M.carrier⟩ ",
      "theorem noetherian_modules {R : Type*}[CommRing R] (M : Type*) [AddCommGroupₓ M] [Module R M]  (h_noeth : noetherian R) (h_ascending : ∀ (N : Submodule R M), ∃ s : ℕ, (∀ i : ℕ, i ≤ s → N ≤ ⟨N.carrier⟩^(i))):  ∃ s : ℕ, is_strictly_ascending s ⟨M.carrier⟩ ",
      "theorem noetherian_modules {R : Type*}[CommRingₓₓ R] (M : Type*) [AddCommGroupₓ M] [Module R M]  (h_noeth : noetherian R) (h_ascending : ∀ (N : Submodule R M), ∃ s : ℕ, (∀ i : ℕ, i ≤ s → N ≤ ⟨N.carrier⟩^(i))):  ∃ s : ℕ, is_strictly_ascending s ⟨M.carrier⟩ ",
      "theorem noetherian_modules {R : Type*}[CommRingₓ R] (M : Type*) [AddCommGroup M] [Module R M]  (h_noeth : noetherian R) (h_ascending : ∀ (N : Submodule R M), ∃ s : ℕ, (∀ i : ℕ, i ≤ s → N ≤ ⟨N.carrier⟩^(i))):  ∃ s : ℕ, is_strictly_ascending s ⟨M.carrier⟩ ",
      "theorem noetherian_modules {R : Type*}[CommRingₓ R] (M : Type*) [AddCommGroupₓₓ M] [Module R M]  (h_noeth : noetherian R) (h_ascending : ∀ (N : Submodule R M), ∃ s : ℕ, (∀ i : ℕ, i ≤ s → N ≤ ⟨N.carrier⟩^(i))):  ∃ s : ℕ, is_strictly_ascending s ⟨M.carrier⟩ ",
      "theorem noetherian_modules {R : Type*}[CommRingₓ R] (M : Type*) [AddCommGroupₓ M] [Module R M]  (h_noeth : noetherian R) (h_ascending : ∀ (N : Submodule R M), ∃ s : ℕ, (∀ i : ℕ, i ≤ s → N ≤ ⟨N.carrier⟩^(i))):  ∃ s : ℕ, is_strictly_ascending s ⟨M.carrier⟩ ",
      "theorem stabilise_ascending_chain_noetherian (R : Type*) [CommRing R] [nontrivial_linear_ordered_semiring R]  (A : Type*) [AddCommGroup A] [Module R A] (a : A) (n : ℕ) (hA : ∀ i : ℕ, i ≤ n → Ideal.span R (range (λ k : ℕ, a^k)))  (hn : n > 0) : ∃ n': ℕ, n' ≤ n ∧ ∀ n'' : ℕ, n' ≤ n'' → Ideal.span R (range (λ k :",
      "theorem stabilise_ascending_chain_noetherian (R : Type*) [CommRing R] [nontrivial_linear_ordered_semiring R]  (A : Type*) [AddCommGroupₓₓ A] [Module R A] (a : A) (n : ℕ) (hA : ∀ i : ℕ, i ≤ n → Ideal.span R (range (λ k : ℕ, a^k)))  (hn : n > 0) : ∃ n': ℕ, n' ≤ n ∧ ∀ n'' : ℕ, n' ≤ n'' → Ideal.span R (range (λ k :",
      "theorem stabilise_ascending_chain_noetherian (R : Type*) [CommRingₓₓ R] [nontrivial_linear_ordered_semiring R]  (A : Type*) [AddCommGroup A] [Module R A] (a : A) (n : ℕ) (hA : ∀ i : ℕ, i ≤ n → Ideal.span R (range (λ k : ℕ, a^k)))  (hn : n > 0) : ∃ n': ℕ, n' ≤ n ∧ ∀ n'' : ℕ, n' ≤ n'' → Ideal.span R (range (λ k :",
      "theorem stabilise_ascending_chain_noetherian (R : Type*) [CommRingₓₓ R] [nontrivial_linear_ordered_semiring R]  (A : Type*) [AddCommGroupₓₓ A] [Module R A] (a : A) (n : ℕ) (hA : ∀ i : ℕ, i ≤ n → Ideal.span R (range (λ k : ℕ, a^k)))  (hn : n > 0) : ∃ n': ℕ, n' ≤ n ∧ ∀ n'' : ℕ, n' ≤ n'' → Ideal.span R (range (λ k :",
      "theorem stabilise_ascending_chain_noetherian (R : Type*) [CommRing R] [nontrivial_linear_ordered_semiring R]  (A : Type*) [AddCommGroupₓ A] [Module R A] (a : A) (n : ℕ) (hA : ∀ i : ℕ, i ≤ n → Ideal.span R (range (λ k : ℕ, a^k)))  (hn : n > 0) : ∃ n': ℕ, n' ≤ n ∧ ∀ n'' : ℕ, n' ≤ n'' → Ideal.span R (range (λ k :",
      "theorem stabilise_ascending_chain_noetherian (R : Type*) [CommRingₓₓ R] [nontrivial_linear_ordered_semiring R]  (A : Type*) [AddCommGroupₓ A] [Module R A] (a : A) (n : ℕ) (hA : ∀ i : ℕ, i ≤ n → Ideal.span R (range (λ k : ℕ, a^k)))  (hn : n > 0) : ∃ n': ℕ, n' ≤ n ∧ ∀ n'' : ℕ, n' ≤ n'' → Ideal.span R (range (λ k :",
      "theorem stabilise_ascending_chain_noetherian (R : Type*) [CommRingₓ R] [nontrivial_linear_ordered_semiring R]  (A : Type*) [AddCommGroup A] [Module R A] (a : A) (n : ℕ) (hA : ∀ i : ℕ, i ≤ n → Ideal.span R (range (λ k : ℕ, a^k)))  (hn : n > 0) : ∃ n': ℕ, n' ≤ n ∧ ∀ n'' : ℕ, n' ≤ n'' → Ideal.span R (range (λ k :",
      "theorem stabilise_ascending_chain_noetherian (R : Type*) [CommRingₓ R] [nontrivial_linear_ordered_semiring R]  (A : Type*) [AddCommGroupₓₓ A] [Module R A] (a : A) (n : ℕ) (hA : ∀ i : ℕ, i ≤ n → Ideal.span R (range (λ k : ℕ, a^k)))  (hn : n > 0) : ∃ n': ℕ, n' ≤ n ∧ ∀ n'' : ℕ, n' ≤ n'' → Ideal.span R (range (λ k :",
      "theorem stabilise_ascending_chain_noetherian (R : Type*) [CommRingₓ R] [nontrivial_linear_ordered_semiring R]  (A : Type*) [AddCommGroupₓ A] [Module R A] (a : A) (n : ℕ) (hA : ∀ i : ℕ, i ≤ n → Ideal.span R (range (λ k : ℕ, a^k)))  (hn : n > 0) : ∃ n': ℕ, n' ≤ n ∧ ∀ n'' : ℕ, n' ≤ n'' → Ideal.span R (range (λ k :",
      "theorem every_ascending_chain_stabilises (M : Type*) [AddCommGroup M] [Module R M]  (hM : noetherian M) : ∀ n : ℕ, ∀ S : Set (Set M), LinearIndependent S →  (∀ i, S i ∈ S (i + 1)) → ∃ N, ∀ m > N, S m = S N ",
      "theorem every_ascending_chain_stabilises (M : Type*) [AddCommGroupₓₓ M] [Module R M]  (hM : noetherian M) : ∀ n : ℕ, ∀ S : Set (Set M), LinearIndependent S →  (∀ i, S i ∈ S (i + 1)) → ∃ N, ∀ m > N, S m = S N ",
      "theorem every_ascending_chain_stabilises (M : Type*) [AddCommGroup M] [Module R M]  (hM : noetherian M) : ∀ n : ℕ, ∀ S : Setₓ (Setₓ M), LinearIndependent S →  (∀ i, S i ∈ S (i + 1)) → ∃ N, ∀ m > N, S m = S N ",
      "theorem every_ascending_chain_stabilises (M : Type*) [AddCommGroupₓₓ M] [Module R M]  (hM : noetherian M) : ∀ n : ℕ, ∀ S : Setₓ (Setₓ M), LinearIndependent S →  (∀ i, S i ∈ S (i + 1)) → ∃ N, ∀ m > N, S m = S N ",
      "theorem every_ascending_chain_stabilises (M : Type*) [AddCommGroupₓ M] [Module R M]  (hM : noetherian M) : ∀ n : ℕ, ∀ S : Set (Set M), LinearIndependent S →  (∀ i, S i ∈ S (i + 1)) → ∃ N, ∀ m > N, S m = S N ",
      "theorem every_ascending_chain_stabilises (M : Type*) [AddCommGroupₓ M] [Module R M]  (hM : noetherian M) : ∀ n : ℕ, ∀ S : Setₓ (Setₓ M), LinearIndependent S →  (∀ i, S i ∈ S (i + 1)) → ∃ N, ∀ m > N, S m = S N "
    ],
    "answer": "theorem noetherian_implies_ascending_chain_condition {R M : Type _} [Ringₓ R] [AddCommMonoidₓ M] [Module R M] : IsNoetherian R M → ∀ (f : ℕ →o Submodule R M), ∃ n : ℕ, ∀ m : ℕ, n < m → f n = f m "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "noetherian_implies_ascending_chain_condition",
      "main_prompt": "Every ascending chain of sub-modules of a Noetherian module eventually stabilises.",
      "prompt": "Natural language version: \"A module is Noetherian iff every increasing chain of submodules stabilizes.\" Translate the natural language version to a Lean mathlib version:\n theorem monotone_stabilizes_iff_noetherian{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] :\n(∀ (f : ℕ →o submodule R M), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m) ↔ is_noetherian R M := \n\nNatural language version: \"A module is Artinian iff every decreasing chain of submodules stabilizes.\" Translate the natural language version to a Lean mathlib version:\n theorem monotone_stabilizes_iff_artinian{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] :\n(∀ (f : ℕ →o (submodule R M)ᵒᵈ), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m) ↔ is_artinian R M := \n\nNatural language version: \"A generalization of the theorem that if `N` is a submodule of `M` and  `N` and `M / N` are both Noetherian, then `M` is Noetherian.\" Translate the natural language version to a Lean mathlib version:\n theorem well_founded_gt_exact_sequence{α : Type u_1} [lattice α] [is_modular_lattice α] {β : Type u_2} {γ : Type u_3} [preorder β] [partial_order γ] (h₁ : well_founded gt) (h₂ : well_founded gt) (K : α) (f₁ : β → α) (f₂ : α → β) (g₁ : γ → α) (g₂ : α → γ) (gci : galois_coinsertion f₁ f₂) (gi : galois_insertion g₂ g₁) (hf : ∀ (a : α), f₁ (f₂ a) = a ⊓ K) (hg : ∀ (a : α), g₁ (g₂ a) = a ⊔ K) :\nwell_founded gt := \n\nNatural language version: \"An R-module is Noetherian iff all its submodules are finitely-generated.\" Translate the natural language version to a Lean mathlib version:\n theorem is_noetherian_def{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] :\nis_noetherian R M ↔ ∀ (s : submodule R M), s.fg := \n\nNatural language version: \"Every ascending chain of sub-modules of a Noetherian module eventually stabilises.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.9016166925430298,
          "doc_string": "A module is Noetherian iff every increasing chain of submodules stabilizes.",
          "statement": "theorem monotone_stabilizes_iff_noetherian {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] : (∀ (f : ℕ →o submodule R M), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m) ↔ is_noetherian R M"
        },
        {
          "sim_score": 0.7797067761421204,
          "doc_string": "A module is Artinian iff every decreasing chain of submodules stabilizes.",
          "statement": "theorem monotone_stabilizes_iff_artinian {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] : (∀ (f : ℕ →o (submodule R M)ᵒᵈ), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m) ↔ is_artinian R M"
        },
        {
          "sim_score": 0.698657751083374,
          "doc_string": "A generalization of the theorem that if `N` is a submodule of `M` and  `N` and `M / N` are both Noetherian, then `M` is Noetherian.",
          "statement": "theorem well_founded_gt_exact_sequence {α : Type u_1} [lattice α] [is_modular_lattice α] {β : Type u_2} {γ : Type u_3} [preorder β] [partial_order γ] (h₁ : well_founded gt) (h₂ : well_founded gt) (K : α) (f₁ : β → α) (f₂ : α → β) (g₁ : γ → α) (g₂ : α → γ) (gci : galois_coinsertion f₁ f₂) (gi : galois_insertion g₂ g₁) (hf : ∀ (a : α), f₁ (f₂ a) = a ⊓ K) (hg : ∀ (a : α), g₁ (g₂ a) = a ⊔ K) : well_founded gt"
        },
        {
          "sim_score": 0.6557018756866455,
          "doc_string": "An R-module is Noetherian iff all its submodules are finitely-generated.",
          "statement": "theorem is_noetherian_def {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] : is_noetherian R M ↔ ∀ (s : submodule R M), s.fg"
        }
      ],
      "codex_time": 10.447741597978165,
      "search_time": 1.4387332439946476,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem monotone_stabilises_noetherian{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoid M] [Module R M] (h : IsNoetherian R M) : ∀ {f : ℕ → Submodule R M}, Monotone f → ∃ N : ℕ, ∀ {n : ℕ}, n ≥ N → f n = f (n + 1) ",
      "theorem monotone_stabilises_noetherian{R : Type u_1} {M : Type u_2} [Semiringₓ R] [AddCommMonoid M] [Module R M] (h : IsNoetherian R M) : ∀ {f : ℕ → Submodule R M}, Monotone f → ∃ N : ℕ, ∀ {n : ℕ}, n ≥ N → f n = f (n + 1) ",
      "theorem monotone_stabilises_noetherian{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoidₓ M] [Module R M] (h : IsNoetherian R M) : ∀ {f : ℕ → Submodule R M}, Monotone f → ∃ N : ℕ, ∀ {n : ℕ}, n ≥ N → f n = f (n + 1) ",
      "theorem monotone_stabilises_noetherian{R : Type u_1} {M : Type u_2} [Semiringₓ R] [AddCommMonoidₓ M] [Module R M] (h : IsNoetherian R M) : ∀ {f : ℕ → Submodule R M}, Monotone f → ∃ N : ℕ, ∀ {n : ℕ}, n ≥ N → f n = f (n + 1) ",
      "theorem final_segment_of_nhds_of_is_noetherian{α : Type*} [CompleteLinearOrder α] [TopologicalSpace α] (a : α) (x : ℝ⁺) (ha : IsNoetherian (𝕜 ⊛ 𝕜⁻¹) ℝ) : IsOpen (λ (t : α), x - (a - t)) ",
      "theorem is_noetherian_iff'{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoid M] [Module R M] : IsNoetherian R M ↔ ∀ (f : ℕ →o Submodule R M), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m ",
      "theorem is_noetherian_iff'{R : Type u_1} {M : Type u_2} [Semiringₓ R] [AddCommMonoid M] [Module R M] : IsNoetherian R M ↔ ∀ (f : ℕ →o Submodule R M), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m ",
      "theorem is_noetherian_iff'{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoidₓ M] [Module R M] : IsNoetherian R M ↔ ∀ (f : ℕ →o Submodule R M), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m ",
      "theorem is_noetherian_iff'{R : Type u_1} {M : Type u_2} [Semiringₓ R] [AddCommMonoidₓ M] [Module R M] : IsNoetherian R M ↔ ∀ (f : ℕ →o Submodule R M), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m ",
      "theorem noetherian_imp_stable_forall{R : Type u_1} {M : Type u_2} [CommRing R] [AddCommGroup M] [Module R M] (h : IsNoetherian R M) (P Q : Type u_3) (f : M → P) (g : M → Q) : ∀ (xs ys : Set M), Finite xs → Finite ys → StrictMono gx → y ⊓ (x ⊔ K) = ∅ → Finite {m | m ∈ s} = False →  ∃ (m : M), (",
      "theorem noetherian_imp_stable_forall{R : Type u_1} {M : Type u_2} [CommRing R] [AddCommGroupₓₓ M] [Module R M] (h : IsNoetherian R M) (P Q : Type u_3) (f : M → P) (g : M → Q) : ∀ (xs ys : Set M), Finite xs → Finite ys → StrictMono gx → y ⊓ (x ⊔ K) = ∅ → Finite {m | m ∈ s} = False →  ∃ (m : M), (",
      "theorem noetherian_imp_stable_forall{R : Type u_1} {M : Type u_2} [CommRingₓₓ R] [AddCommGroup M] [Module R M] (h : IsNoetherian R M) (P Q : Type u_3) (f : M → P) (g : M → Q) : ∀ (xs ys : Set M), Finite xs → Finite ys → StrictMono gx → y ⊓ (x ⊔ K) = ∅ → Finite {m | m ∈ s} = False →  ∃ (m : M), (",
      "theorem noetherian_imp_stable_forall{R : Type u_1} {M : Type u_2} [CommRingₓₓ R] [AddCommGroupₓₓ M] [Module R M] (h : IsNoetherian R M) (P Q : Type u_3) (f : M → P) (g : M → Q) : ∀ (xs ys : Set M), Finite xs → Finite ys → StrictMono gx → y ⊓ (x ⊔ K) = ∅ → Finite {m | m ∈ s} = False →  ∃ (m : M), (",
      "theorem noetherian_imp_stable_forall{R : Type u_1} {M : Type u_2} [CommRing R] [AddCommGroup M] [Module R M] (h : IsNoetherian R M) (P Q : Type u_3) (f : M → P) (g : M → Q) : ∀ (xs ys : Setₓ M), Finite xs → Finite ys → StrictMono gx → y ⊓ (x ⊔ K) = ∅ → Finite {m | m ∈ s} = False →  ∃ (m : M), (",
      "theorem noetherian_imp_stable_forall{R : Type u_1} {M : Type u_2} [CommRing R] [AddCommGroupₓₓ M] [Module R M] (h : IsNoetherian R M) (P Q : Type u_3) (f : M → P) (g : M → Q) : ∀ (xs ys : Setₓ M), Finite xs → Finite ys → StrictMono gx → y ⊓ (x ⊔ K) = ∅ → Finite {m | m ∈ s} = False →  ∃ (m : M), (",
      "theorem noetherian_imp_stable_forall{R : Type u_1} {M : Type u_2} [CommRingₓₓ R] [AddCommGroup M] [Module R M] (h : IsNoetherian R M) (P Q : Type u_3) (f : M → P) (g : M → Q) : ∀ (xs ys : Setₓ M), Finite xs → Finite ys → StrictMono gx → y ⊓ (x ⊔ K) = ∅ → Finite {m | m ∈ s} = False →  ∃ (m : M), (",
      "theorem noetherian_imp_stable_forall{R : Type u_1} {M : Type u_2} [CommRingₓₓ R] [AddCommGroupₓₓ M] [Module R M] (h : IsNoetherian R M) (P Q : Type u_3) (f : M → P) (g : M → Q) : ∀ (xs ys : Setₓ M), Finite xs → Finite ys → StrictMono gx → y ⊓ (x ⊔ K) = ∅ → Finite {m | m ∈ s} = False →  ∃ (m : M), (",
      "theorem noetherian_imp_stable_forall{R : Type u_1} {M : Type u_2} [CommRing R] [AddCommGroupₓ M] [Module R M] (h : IsNoetherian R M) (P Q : Type u_3) (f : M → P) (g : M → Q) : ∀ (xs ys : Set M), Finite xs → Finite ys → StrictMono gx → y ⊓ (x ⊔ K) = ∅ → Finite {m | m ∈ s} = False →  ∃ (m : M), (",
      "theorem noetherian_imp_stable_forall{R : Type u_1} {M : Type u_2} [CommRingₓₓ R] [AddCommGroupₓ M] [Module R M] (h : IsNoetherian R M) (P Q : Type u_3) (f : M → P) (g : M → Q) : ∀ (xs ys : Set M), Finite xs → Finite ys → StrictMono gx → y ⊓ (x ⊔ K) = ∅ → Finite {m | m ∈ s} = False →  ∃ (m : M), (",
      "theorem noetherian_imp_stable_forall{R : Type u_1} {M : Type u_2} [CommRing R] [AddCommGroupₓ M] [Module R M] (h : IsNoetherian R M) (P Q : Type u_3) (f : M → P) (g : M → Q) : ∀ (xs ys : Setₓ M), Finite xs → Finite ys → StrictMono gx → y ⊓ (x ⊔ K) = ∅ → Finite {m | m ∈ s} = False →  ∃ (m : M), (",
      "theorem noetherian_imp_stable_forall{R : Type u_1} {M : Type u_2} [CommRingₓₓ R] [AddCommGroupₓ M] [Module R M] (h : IsNoetherian R M) (P Q : Type u_3) (f : M → P) (g : M → Q) : ∀ (xs ys : Setₓ M), Finite xs → Finite ys → StrictMono gx → y ⊓ (x ⊔ K) = ∅ → Finite {m | m ∈ s} = False →  ∃ (m : M), (",
      "theorem noetherian_imp_stable_forall{R : Type u_1} {M : Type u_2} [CommRingₓ R] [AddCommGroup M] [Module R M] (h : IsNoetherian R M) (P Q : Type u_3) (f : M → P) (g : M → Q) : ∀ (xs ys : Set M), Finite xs → Finite ys → StrictMono gx → y ⊓ (x ⊔ K) = ∅ → Finite {m | m ∈ s} = False →  ∃ (m : M), (",
      "theorem noetherian_imp_stable_forall{R : Type u_1} {M : Type u_2} [CommRingₓ R] [AddCommGroupₓₓ M] [Module R M] (h : IsNoetherian R M) (P Q : Type u_3) (f : M → P) (g : M → Q) : ∀ (xs ys : Set M), Finite xs → Finite ys → StrictMono gx → y ⊓ (x ⊔ K) = ∅ → Finite {m | m ∈ s} = False →  ∃ (m : M), (",
      "theorem noetherian_imp_stable_forall{R : Type u_1} {M : Type u_2} [CommRingₓ R] [AddCommGroup M] [Module R M] (h : IsNoetherian R M) (P Q : Type u_3) (f : M → P) (g : M → Q) : ∀ (xs ys : Setₓ M), Finite xs → Finite ys → StrictMono gx → y ⊓ (x ⊔ K) = ∅ → Finite {m | m ∈ s} = False →  ∃ (m : M), (",
      "theorem noetherian_imp_stable_forall{R : Type u_1} {M : Type u_2} [CommRingₓ R] [AddCommGroupₓₓ M] [Module R M] (h : IsNoetherian R M) (P Q : Type u_3) (f : M → P) (g : M → Q) : ∀ (xs ys : Setₓ M), Finite xs → Finite ys → StrictMono gx → y ⊓ (x ⊔ K) = ∅ → Finite {m | m ∈ s} = False →  ∃ (m : M), (",
      "theorem noetherian_imp_stable_forall{R : Type u_1} {M : Type u_2} [CommRingₓ R] [AddCommGroupₓ M] [Module R M] (h : IsNoetherian R M) (P Q : Type u_3) (f : M → P) (g : M → Q) : ∀ (xs ys : Set M), Finite xs → Finite ys → StrictMono gx → y ⊓ (x ⊔ K) = ∅ → Finite {m | m ∈ s} = False →  ∃ (m : M), (",
      "theorem noetherian_imp_stable_forall{R : Type u_1} {M : Type u_2} [CommRingₓ R] [AddCommGroupₓ M] [Module R M] (h : IsNoetherian R M) (P Q : Type u_3) (f : M → P) (g : M → Q) : ∀ (xs ys : Setₓ M), Finite xs → Finite ys → StrictMono gx → y ⊓ (x ⊔ K) = ∅ → Finite {m | m ∈ s} = False →  ∃ (m : M), (",
      "theorem noetherian_stabilization{R : Type u_1} {M : Type u_2} [ο : Semiring R] [n : AddCommMonoid M] [m : Module R M] [noetherian : IsNoetherian R M] {f : ℕ →o Submodule R M} (hf : order_preserving f) : ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → f m = f n ",
      "theorem noetherian_stabilization{R : Type u_1} {M : Type u_2} [ο : Semiringₓ R] [n : AddCommMonoid M] [m : Module R M] [noetherian : IsNoetherian R M] {f : ℕ →o Submodule R M} (hf : order_preserving f) : ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → f m = f n ",
      "theorem noetherian_stabilization{R : Type u_1} {M : Type u_2} [ο : Semiring R] [n : AddCommMonoidₓ M] [m : Module R M] [noetherian : IsNoetherian R M] {f : ℕ →o Submodule R M} (hf : order_preserving f) : ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → f m = f n ",
      "theorem noetherian_stabilization{R : Type u_1} {M : Type u_2} [ο : Semiringₓ R] [n : AddCommMonoidₓ M] [m : Module R M] [noetherian : IsNoetherian R M] {f : ℕ →o Submodule R M} (hf : order_preserving f) : ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → f m = f n "
    ],
    "answer": "theorem noetherian_implies_ascending_chain_condition {R M : Type _} [Ringₓ R] [AddCommMonoidₓ M] [Module R M] : IsNoetherian R M → ∀ (f : ℕ →o Submodule R M), ∃ n : ℕ, ∀ m : ℕ, n < m → f n = f m "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "noetherian_implies_ascending_chain_condition",
      "main_prompt": "Every ascending chain of sub-modules of a Noetherian module eventually stabilises.",
      "prompt": "Natural language version: \"Every ascending chain of sub-modules of a Noetherian module eventually stabilises.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 6.7440393260039855,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem nat_lang : Π {M : Type} [AddCommGroup M] [Module R M], noetherian M → Π {N : Submodule M}, ∃ n, ∀ m ≥ n, N ≤ ⟨M, μ n⟩ ",
      "theorem nat_lang : Π {M : Type} [AddCommGroupₓₓ M] [Module R M], noetherian M → Π {N : Submodule M}, ∃ n, ∀ m ≥ n, N ≤ ⟨M, μ n⟩ ",
      "theorem nat_lang : Π {M : Type} [AddCommGroupₓ M] [Module R M], noetherian M → Π {N : Submodule M}, ∃ n, ∀ m ≥ n, N ≤ ⟨M, μ n⟩ ",
      "theorem lenstra ( M : Type* ) [ AddCommGroup M ] [ Module ℤ M ] [ IsNoetherianRing ℤ ] [ is_noetherian_module ℤ M ] :  ∀ ( S : Set M ) ( h : Submodule ℤ M S ),  ∃ s : ℕ, ∀ ( t : ℕ ), is_submodule t S → t ≤ s ",
      "theorem lenstra ( M : Type* ) [ AddCommGroupₓₓ M ] [ Module ℤ M ] [ IsNoetherianRing ℤ ] [ is_noetherian_module ℤ M ] :  ∀ ( S : Set M ) ( h : Submodule ℤ M S ),  ∃ s : ℕ, ∀ ( t : ℕ ), is_submodule t S → t ≤ s ",
      "theorem lenstra ( M : Type* ) [ AddCommGroup M ] [ Module ℤ M ] [ IsNoetherianRing ℤ ] [ is_noetherian_module ℤ M ] :  ∀ ( S : Setₓ M ) ( h : Submodule ℤ M S ),  ∃ s : ℕ, ∀ ( t : ℕ ), is_submodule t S → t ≤ s ",
      "theorem lenstra ( M : Type* ) [ AddCommGroupₓₓ M ] [ Module ℤ M ] [ IsNoetherianRing ℤ ] [ is_noetherian_module ℤ M ] :  ∀ ( S : Setₓ M ) ( h : Submodule ℤ M S ),  ∃ s : ℕ, ∀ ( t : ℕ ), is_submodule t S → t ≤ s ",
      "theorem lenstra ( M : Type* ) [ AddCommGroupₓ M ] [ Module ℤ M ] [ IsNoetherianRing ℤ ] [ is_noetherian_module ℤ M ] :  ∀ ( S : Set M ) ( h : Submodule ℤ M S ),  ∃ s : ℕ, ∀ ( t : ℕ ), is_submodule t S → t ≤ s ",
      "theorem lenstra ( M : Type* ) [ AddCommGroupₓ M ] [ Module ℤ M ] [ IsNoetherianRing ℤ ] [ is_noetherian_module ℤ M ] :  ∀ ( S : Setₓ M ) ( h : Submodule ℤ M S ),  ∃ s : ℕ, ∀ ( t : ℕ ), is_submodule t S → t ≤ s ",
      "theorem every_ascending_chain_of_submodules_eventually_stabilises : ∀ {M : Module R} [Hi : noetherian M] (S),    ∀ (S' : Submodule R M),      S' ≤ S →      ∃ S_min S_min_le, is_limit (λ S', S' ≤ S → S_min) S' S_min_le ",
      "theorem noetherian_chain' (R : Type) [CommRing R] [noetherian_ring R] (M : Type) [AddCommGroup M] [Module R M] [noetherian_module R M] {I : Type} (ℱ : I → Submodule R M) (h : chain ℱ) :      ∃ N : Submodule R M, ∀ (i : I), ℱ i ≤ N ",
      "theorem noetherian_chain' (R : Type) [CommRing R] [noetherian_ring R] (M : Type) [AddCommGroupₓₓ M] [Module R M] [noetherian_module R M] {I : Type} (ℱ : I → Submodule R M) (h : chain ℱ) :      ∃ N : Submodule R M, ∀ (i : I), ℱ i ≤ N ",
      "theorem noetherian_chain' (R : Type) [CommRingₓₓ R] [noetherian_ring R] (M : Type) [AddCommGroup M] [Module R M] [noetherian_module R M] {I : Type} (ℱ : I → Submodule R M) (h : chain ℱ) :      ∃ N : Submodule R M, ∀ (i : I), ℱ i ≤ N ",
      "theorem noetherian_chain' (R : Type) [CommRingₓₓ R] [noetherian_ring R] (M : Type) [AddCommGroupₓₓ M] [Module R M] [noetherian_module R M] {I : Type} (ℱ : I → Submodule R M) (h : chain ℱ) :      ∃ N : Submodule R M, ∀ (i : I), ℱ i ≤ N ",
      "theorem noetherian_chain' (R : Type) [CommRing R] [noetherian_ring R] (M : Type) [AddCommGroupₓ M] [Module R M] [noetherian_module R M] {I : Type} (ℱ : I → Submodule R M) (h : chain ℱ) :      ∃ N : Submodule R M, ∀ (i : I), ℱ i ≤ N ",
      "theorem noetherian_chain' (R : Type) [CommRingₓₓ R] [noetherian_ring R] (M : Type) [AddCommGroupₓ M] [Module R M] [noetherian_module R M] {I : Type} (ℱ : I → Submodule R M) (h : chain ℱ) :      ∃ N : Submodule R M, ∀ (i : I), ℱ i ≤ N ",
      "theorem noetherian_chain' (R : Type) [CommRingₓ R] [noetherian_ring R] (M : Type) [AddCommGroup M] [Module R M] [noetherian_module R M] {I : Type} (ℱ : I → Submodule R M) (h : chain ℱ) :      ∃ N : Submodule R M, ∀ (i : I), ℱ i ≤ N ",
      "theorem noetherian_chain' (R : Type) [CommRingₓ R] [noetherian_ring R] (M : Type) [AddCommGroupₓₓ M] [Module R M] [noetherian_module R M] {I : Type} (ℱ : I → Submodule R M) (h : chain ℱ) :      ∃ N : Submodule R M, ∀ (i : I), ℱ i ≤ N ",
      "theorem noetherian_chain' (R : Type) [CommRingₓ R] [noetherian_ring R] (M : Type) [AddCommGroupₓ M] [Module R M] [noetherian_module R M] {I : Type} (ℱ : I → Submodule R M) (h : chain ℱ) :      ∃ N : Submodule R M, ∀ (i : I), ℱ i ≤ N ",
      "theorem nat_anti_noetherian_lemma (R : Type) [Ring R] [Fintype R] (M : Type) [AddCommGroup M] [Module R M] : noetherian M → ∀ s t, is_submodule (submodule.closure t : Submodule M) s → is_submodule s (submodule.closure t) → s = submodule.closure t ",
      "theorem nat_anti_noetherian_lemma (R : Type) [Ring R] [Fintype R] (M : Type) [AddCommGroupₓₓ M] [Module R M] : noetherian M → ∀ s t, is_submodule (submodule.closure t : Submodule M) s → is_submodule s (submodule.closure t) → s = submodule.closure t ",
      "theorem nat_anti_noetherian_lemma (R : Type) [Ringₓₓ R] [Fintype R] (M : Type) [AddCommGroup M] [Module R M] : noetherian M → ∀ s t, is_submodule (submodule.closure t : Submodule M) s → is_submodule s (submodule.closure t) → s = submodule.closure t ",
      "theorem nat_anti_noetherian_lemma (R : Type) [Ringₓₓ R] [Fintype R] (M : Type) [AddCommGroupₓₓ M] [Module R M] : noetherian M → ∀ s t, is_submodule (submodule.closure t : Submodule M) s → is_submodule s (submodule.closure t) → s = submodule.closure t ",
      "theorem nat_anti_noetherian_lemma (R : Type) [Ringₓ R] [Fintype R] (M : Type) [AddCommGroup M] [Module R M] : noetherian M → ∀ s t, is_submodule (submodule.closure t : Submodule M) s → is_submodule s (submodule.closure t) → s = submodule.closure t ",
      "theorem nat_anti_noetherian_lemma (R : Type) [Ringₓ R] [Fintype R] (M : Type) [AddCommGroupₓₓ M] [Module R M] : noetherian M → ∀ s t, is_submodule (submodule.closure t : Submodule M) s → is_submodule s (submodule.closure t) → s = submodule.closure t ",
      "theorem nat_anti_noetherian_lemma (R : Type) [Ring R] [Fintype R] (M : Type) [AddCommGroupₓ M] [Module R M] : noetherian M → ∀ s t, is_submodule (submodule.closure t : Submodule M) s → is_submodule s (submodule.closure t) → s = submodule.closure t ",
      "theorem nat_anti_noetherian_lemma (R : Type) [Ringₓₓ R] [Fintype R] (M : Type) [AddCommGroupₓ M] [Module R M] : noetherian M → ∀ s t, is_submodule (submodule.closure t : Submodule M) s → is_submodule s (submodule.closure t) → s = submodule.closure t ",
      "theorem nat_anti_noetherian_lemma (R : Type) [Ringₓ R] [Fintype R] (M : Type) [AddCommGroupₓ M] [Module R M] : noetherian M → ∀ s t, is_submodule (submodule.closure t : Submodule M) s → is_submodule s (submodule.closure t) → s = submodule.closure t ",
      "theorem nat_anti_noetherian_lemma (R : Type) [Ring R] [Fintypeₓ R] (M : Type) [AddCommGroup M] [Module R M] : noetherian M → ∀ s t, is_submodule (submodule.closure t : Submodule M) s → is_submodule s (submodule.closure t) → s = submodule.closure t ",
      "theorem nat_anti_noetherian_lemma (R : Type) [Ring R] [Fintypeₓ R] (M : Type) [AddCommGroupₓₓ M] [Module R M] : noetherian M → ∀ s t, is_submodule (submodule.closure t : Submodule M) s → is_submodule s (submodule.closure t) → s = submodule.closure t ",
      "theorem nat_anti_noetherian_lemma (R : Type) [Ringₓₓ R] [Fintypeₓ R] (M : Type) [AddCommGroup M] [Module R M] : noetherian M → ∀ s t, is_submodule (submodule.closure t : Submodule M) s → is_submodule s (submodule.closure t) → s = submodule.closure t ",
      "theorem nat_anti_noetherian_lemma (R : Type) [Ringₓₓ R] [Fintypeₓ R] (M : Type) [AddCommGroupₓₓ M] [Module R M] : noetherian M → ∀ s t, is_submodule (submodule.closure t : Submodule M) s → is_submodule s (submodule.closure t) → s = submodule.closure t ",
      "theorem nat_anti_noetherian_lemma (R : Type) [Ringₓ R] [Fintypeₓ R] (M : Type) [AddCommGroup M] [Module R M] : noetherian M → ∀ s t, is_submodule (submodule.closure t : Submodule M) s → is_submodule s (submodule.closure t) → s = submodule.closure t ",
      "theorem nat_anti_noetherian_lemma (R : Type) [Ringₓ R] [Fintypeₓ R] (M : Type) [AddCommGroupₓₓ M] [Module R M] : noetherian M → ∀ s t, is_submodule (submodule.closure t : Submodule M) s → is_submodule s (submodule.closure t) → s = submodule.closure t ",
      "theorem nat_anti_noetherian_lemma (R : Type) [Ring R] [Fintypeₓ R] (M : Type) [AddCommGroupₓ M] [Module R M] : noetherian M → ∀ s t, is_submodule (submodule.closure t : Submodule M) s → is_submodule s (submodule.closure t) → s = submodule.closure t ",
      "theorem nat_anti_noetherian_lemma (R : Type) [Ringₓₓ R] [Fintypeₓ R] (M : Type) [AddCommGroupₓ M] [Module R M] : noetherian M → ∀ s t, is_submodule (submodule.closure t : Submodule M) s → is_submodule s (submodule.closure t) → s = submodule.closure t ",
      "theorem nat_anti_noetherian_lemma (R : Type) [Ringₓ R] [Fintypeₓ R] (M : Type) [AddCommGroupₓ M] [Module R M] : noetherian M → ∀ s t, is_submodule (submodule.closure t : Submodule M) s → is_submodule s (submodule.closure t) → s = submodule.closure t "
    ],
    "answer": "theorem noetherian_implies_ascending_chain_condition {R M : Type _} [Ringₓ R] [AddCommMonoidₓ M] [Module R M] : IsNoetherian R M → ∀ (f : ℕ →o Submodule R M), ∃ n : ℕ, ∀ m : ℕ, n < m → f n = f m "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "differentiability_implies_continuity",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Differentiability implies continuity.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Differentiability implies continuity.",
      "codex_time": 8.280181679991074,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem differentiable_implies_continuous (X : Type*) [TopologicalSpace X] [NormedGroup X] [NormedSpace ℝ X] {x : X} {f : X → ℝ} (h_diff : Differentiable f x) : Continuous f ",
      "theorem differentiable_imp_continuous {n : ℕ} {f : ℝ^n → ℝ} (hf : Differentiable f) :  Continuous f ",
      "theorem diff_continuous (X : Type*) (n : ℕ) [Inhabited X] [TopologicalSpace X] [AddCommGroup X] [vector_space ℝ X] (f : X → ℝ) (x : X) (hf : Differentiable f x) :  Continuous f x ",
      "theorem diff_continuous (X : Type*) (n : ℕ) [Inhabited X] [TopologicalSpace X] [AddCommGroupₓₓ X] [vector_space ℝ X] (f : X → ℝ) (x : X) (hf : Differentiable f x) :  Continuous f x ",
      "theorem diff_continuous (X : Type*) (n : ℕ) [Inhabited X] [TopologicalSpace X] [AddCommGroupₓ X] [vector_space ℝ X] (f : X → ℝ) (x : X) (hf : Differentiable f x) :  Continuous f x ",
      "theorem diff_imp_cont (f : ℝ → ℝ) (hf : Differentiable f) : Continuous f ",
      "theorem differentiable_function_continuous {Y : Type*} [TopologicalSpace Y] {f : ℝ → Y}  (df : f DifferentiableAt a) : Continuous f "
    ],
    "answer": "theorem differentiability_implies_continuity [TopologicalSpace ℝ] : ∀ f : ℝ → ℝ, Differentiable ℝ f → Continuous f "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "differentiability_implies_continuity",
      "main_prompt": "Differentiability implies continuity.",
      "prompt": "Natural language version: \"If a function is locally Lipschitz around a point, then it is continuous at this point.\" Translate the natural language version to a Lean mathlib version:\n theorem continuous_at_of_locally_lipschitz{α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {f : α → β} {x : α} {r : ℝ} (hr : 0 < r) (K : ℝ) (h : ∀ (y : α), has_dist.dist y x < r → has_dist.dist (f y) (f x) ≤ K * has_dist.dist y x) :\ncontinuous_at f x := \n\nNatural language version: \" If a function is differentiable on the right of a point `a : ℝ`, continuous at `a`, and its derivative also converges at `a`, then `f` is differentiable on the right at `a`.\" Translate the natural language version to a Lean mathlib version:\n theorem has_deriv_at_interval_left_endpoint_of_tendsto_deriv{E : Type u_1} [normed_group E] [normed_space ℝ E] {s : set ℝ} {e : E} {a : ℝ} {f : ℝ → E} (f_diff : differentiable_on ℝ f s) (f_lim : continuous_within_at f s a) (hs : s ∈ nhds_within a (set.Ioi a)) (f_lim' : filter.tendsto (λ (x : ℝ), deriv f x) (nhds_within a (set.Ioi a)) (nhds e)) :\nhas_deriv_within_at f e (set.Ici a) a := \n\nNatural language version: \" If a function is differentiable on the left of a point `a : ℝ`, continuous at `a`, and its derivative also converges at `a`, then `f` is differentiable on the left at `a`.\" Translate the natural language version to a Lean mathlib version:\n theorem has_deriv_at_interval_right_endpoint_of_tendsto_deriv{E : Type u_1} [normed_group E] [normed_space ℝ E] {s : set ℝ} {e : E} {a : ℝ} {f : ℝ → E} (f_diff : differentiable_on ℝ f s) (f_lim : continuous_within_at f s a) (hs : s ∈ nhds_within a (set.Iio a)) (f_lim' : filter.tendsto (λ (x : ℝ), deriv f x) (nhds_within a (set.Iio a)) (nhds e)) :\nhas_deriv_within_at f e (set.Iic a) a := \n\nNatural language version: \"A Lipschitz function is continuous\" Translate the natural language version to a Lean mathlib version:\n theorem lipschitz_with.continuous{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {K : nnreal} {f : α → β} (hf : lipschitz_with K f) :\ncontinuous f := \n\nNatural language version: \"Differentiability implies continuity.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6264367699623108,
          "doc_string": "If a function is locally Lipschitz around a point, then it is continuous at this point.",
          "statement": "theorem continuous_at_of_locally_lipschitz {α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {f : α → β} {x : α} {r : ℝ} (hr : 0 < r) (K : ℝ) (h : ∀ (y : α), has_dist.dist y x < r → has_dist.dist (f y) (f x) ≤ K * has_dist.dist y x) : continuous_at f x"
        },
        {
          "sim_score": 0.6016049981117249,
          "doc_string": " If a function is differentiable on the right of a point `a : ℝ`, continuous at `a`, and its derivative also converges at `a`, then `f` is differentiable on the right at `a`.",
          "statement": "theorem has_deriv_at_interval_left_endpoint_of_tendsto_deriv {E : Type u_1} [normed_group E] [normed_space ℝ E] {s : set ℝ} {e : E} {a : ℝ} {f : ℝ → E} (f_diff : differentiable_on ℝ f s) (f_lim : continuous_within_at f s a) (hs : s ∈ nhds_within a (set.Ioi a)) (f_lim' : filter.tendsto (λ (x : ℝ), deriv f x) (nhds_within a (set.Ioi a)) (nhds e)) : has_deriv_within_at f e (set.Ici a) a"
        },
        {
          "sim_score": 0.5962556600570679,
          "doc_string": " If a function is differentiable on the left of a point `a : ℝ`, continuous at `a`, and its derivative also converges at `a`, then `f` is differentiable on the left at `a`.",
          "statement": "theorem has_deriv_at_interval_right_endpoint_of_tendsto_deriv {E : Type u_1} [normed_group E] [normed_space ℝ E] {s : set ℝ} {e : E} {a : ℝ} {f : ℝ → E} (f_diff : differentiable_on ℝ f s) (f_lim : continuous_within_at f s a) (hs : s ∈ nhds_within a (set.Iio a)) (f_lim' : filter.tendsto (λ (x : ℝ), deriv f x) (nhds_within a (set.Iio a)) (nhds e)) : has_deriv_within_at f e (set.Iic a) a"
        },
        {
          "sim_score": 0.5795943737030029,
          "doc_string": "A Lipschitz function is continuous",
          "statement": "theorem lipschitz_with.continuous {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {K : nnreal} {f : α → β} (hf : lipschitz_with K f) : continuous f"
        }
      ],
      "codex_time": 6.055595788988285,
      "search_time": 1.448735445010243,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem differentiable_at.continuous_at{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {s : Set ℝ} {x : ℝ} {f : ℝ → E} (h_dif_f : DifferentiableWithinAt ℝ f s x) : ContinuousWithinAt f s x ",
      "theorem differentiable_at.continuous_at{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {s : Setₓ ℝ} {x : ℝ} {f : ℝ → E} (h_dif_f : DifferentiableWithinAt ℝ f s x) : ContinuousWithinAt f s x ",
      "theorem differentiable.continuous{α : Type u} {β : Type v} [UniformSpace α] [TopologicalSpace β] {f : α → β} {a : α} (hf : Differentiable f a) : Continuous (f a) ",
      "theorem differentiable.continuous{α : Type u} {β : Type v} [UniformSpaceₓ α] [TopologicalSpace β] {f : α → β} {a : α} (hf : Differentiable f a) : Continuous (f a) ",
      "theorem differentiable_on.continuous_on{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] {s : Set α} {f : α → β} (h : DifferentiableOn α β f s) : ContinuousOn s f ",
      "theorem differentiable_on.continuous_on{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] {s : Setₓ α} {f : α → β} (h : DifferentiableOn α β f s) : ContinuousOn s f ",
      "theorem diff_continuous{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {f : ℝ → E} (hf : Differentiable f) : Continuous f ",
      "theorem differentiable_at.continuous{f : ℝ → ℝ} {a : ℝ} (H : DifferentiableAt f a) : ContinuousAt f a "
    ],
    "answer": "theorem differentiability_implies_continuity [TopologicalSpace ℝ] : ∀ f : ℝ → ℝ, Differentiable ℝ f → Continuous f "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "differentiability_implies_continuity",
      "main_prompt": "Differentiability implies continuity.",
      "prompt": "Natural language version: \"Differentiability implies continuity.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 9.817274647997692,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem diff_implies_cont (f : ℝ → ℝ) : Differentiable f → Continuous f ",
      "theorem diff_imp_cont {F: ℝ → ℝ} {x: ℝ}: ∀ {c: ℝ → Prop} {n: ℕ}, CauSeq c n F → c x → (∀ ε>0, ∃ δ>0, ∀ δ'∈c, |F F.diff x δ' - F F.diff x δ| < ε)  ",
      "theorem d_to_c (α) [NormedGroup α] [NormedSpace α] : diffable f → Continuous f ",
      "theorem diff_impl_continuity (f : ℝ → ℝ) (x : ℝ) (h : is_differentiable_at f x) : Continuous (f) ",
      "theorem diff_impl_cont {f : ℝ → ℝ} {x : ℝ} (hx : is_differentiable_at f x) : ContinuousAt f x "
    ],
    "answer": "theorem differentiability_implies_continuity [TopologicalSpace ℝ] : ∀ f : ℝ → ℝ, Differentiable ℝ f → Continuous f "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "angle_sum_pi",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"The angles of a triangle add up to two right angles.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The angles of a triangle add up to two right angles.",
      "codex_time": 12.227333054994233,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem eq_pi_angle_sum (x y z : is_angle x y z) :  x + y + z = 2*pi ",
      "theorem sum_of_angles_in_triangle_is_180 :  ∀ (A B C : ℝ) (a b c : ℝ),  c > 0 ∧ a > 0 ∧ b > 0 ∧ A + B + C = π ∧  A = asin(sin(B)*sin(c)/sin(A)) ∧  B = asin(sin(A)*sin(c)/sin(B)) ∧  C = asin(sin(A)*sin(b)/sin(C)) →  a + b = π - C ",
      "theorem angles_of_triangle_add_up_to_two_right_angles (A B C : angle) :  A + B + C = sec (1/2) * π ",
      "theorem angs_add_eq_2_right_angs (t : triangle) :  angle t.α + angle t.β + angle t.γ ≤ 2*pi ",
      "theorem sum_of_angles_of_triangle_eq_two_right_angles (a b c : ℝ) :  0 < a → 0 < b → 0 < c →  a + b + c = π "
    ],
    "answer": "theorem angle_sum_pi {p q r : EuclideanSpace ℝ (Finₓ 2)} : EuclideanGeometry.angle p q r + EuclideanGeometry.angle q r p + EuclideanGeometry.angle r p q = Real.pi "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "angle_sum_pi",
      "main_prompt": "The angles of a triangle add up to two right angles.",
      "prompt": "Natural language version: \" If the angle between two vectors is π, the angles between those vectors and a third vector add to π.\" Translate the natural language version to a Lean mathlib version:\n theorem inner_product_geometry.angle_add_angle_eq_pi_of_angle_eq_pi{V : Type u_1} [inner_product_space ℝ V] {x y : V} (z : V) (h : inner_product_geometry.angle x y = real.pi) :\ninner_product_geometry.angle x z + inner_product_geometry.angle y z = real.pi := \n\nNatural language version: \" Vertical Angles Theorem: angles opposite each other, formed by two intersecting straight lines, are equal.\" Translate the natural language version to a Lean mathlib version:\n theorem euclidean_geometry.angle_eq_angle_of_angle_eq_pi_of_angle_eq_pi{V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 p4 p5 : P} (hapc : euclidean_geometry.angle p1 p5 p3 = real.pi) (hbpd : euclidean_geometry.angle p2 p5 p4 = real.pi) :\neuclidean_geometry.angle p1 p5 p2 = euclidean_geometry.angle p3 p5 p4 := \n\nNatural language version: \" Given three nonzero vectors, adding the angles between them in cyclic order, with the second vector in each angle negated, results in π. If the vectors add to 0, this is a version of the sum of the angles of a triangle.\" Translate the natural language version to a Lean mathlib version:\n theorem orthonormal.oangle_add_cyc3_neg_right{V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) :\nhb.oangle x (-y) + hb.oangle y (-z) + hb.oangle z (-x) = ↑real.pi := \n\nNatural language version: \" Given three nonzero vectors, adding the angles between them in cyclic order, with the second vector in each angle negated, results in π. If the vectors add to 0, this is a version of the sum of the angles of a triangle.\" Translate the natural language version to a Lean mathlib version:\n theorem orientation.oangle_add_cyc3_neg_right{V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) :\no.oangle x (-y) + o.oangle y (-z) + o.oangle z (-x) = ↑real.pi := \n\nNatural language version: \"The angles of a triangle add up to two right angles.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5743768215179443,
          "doc_string": " If the angle between two vectors is π, the angles between those vectors and a third vector add to π.",
          "statement": "theorem inner_product_geometry.angle_add_angle_eq_pi_of_angle_eq_pi {V : Type u_1} [inner_product_space ℝ V] {x y : V} (z : V) (h : inner_product_geometry.angle x y = real.pi) : inner_product_geometry.angle x z + inner_product_geometry.angle y z = real.pi"
        },
        {
          "sim_score": 0.5685725212097168,
          "doc_string": " Vertical Angles Theorem: angles opposite each other, formed by two intersecting straight lines, are equal.",
          "statement": "theorem euclidean_geometry.angle_eq_angle_of_angle_eq_pi_of_angle_eq_pi {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 p4 p5 : P} (hapc : euclidean_geometry.angle p1 p5 p3 = real.pi) (hbpd : euclidean_geometry.angle p2 p5 p4 = real.pi) : euclidean_geometry.angle p1 p5 p2 = euclidean_geometry.angle p3 p5 p4"
        },
        {
          "sim_score": 0.5616596937179565,
          "doc_string": " Given three nonzero vectors, adding the angles between them in cyclic order, with the second vector in each angle negated, results in π. If the vectors add to 0, this is a version of the sum of the angles of a triangle.",
          "statement": "theorem orthonormal.oangle_add_cyc3_neg_right {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle x (-y) + hb.oangle y (-z) + hb.oangle z (-x) = ↑real.pi"
        },
        {
          "sim_score": 0.5616596937179565,
          "doc_string": " Given three nonzero vectors, adding the angles between them in cyclic order, with the second vector in each angle negated, results in π. If the vectors add to 0, this is a version of the sum of the angles of a triangle.",
          "statement": "theorem orientation.oangle_add_cyc3_neg_right {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle x (-y) + o.oangle y (-z) + o.oangle z (-x) = ↑real.pi"
        }
      ],
      "codex_time": 6.071401793014957,
      "search_time": 1.4386507550079841,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem euclidean_triangle.angle_add_angle_add_angle_eq_twopi{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {p1 p2 p3 : P} (ha : euclidean_triangle.is_angle p1 p2 p3) : EuclideanGeometry.angle p1 p2 p3 + EuclideanGeometry.angle p2 p3 p1 + EuclideanGeometry.angle p3 p1 p2 =",
      "theorem euclidean_geometry.angle_sum_eq2pi{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {p1 p2 p3 : P} : EuclideanGeometry.angle p1 p2 p3 + EuclideanGeometry.angle p2 p3 p1 + EuclideanGeometry.angle p3 p1 p2 = 2 * Real.pi ",
      "theorem euclidean_geometry.triangle_angle_sum_eq_tworightangles(α β γ : ℝ) (hα : α < Real.pi) (hβ : β < Real.pi) (hγ : γ < Real.pi) (hab : α + β > Real.pi) (hbc : β + γ > Real.pi) : α + β + γ = ↑(real.int 2) * ↑Real.pi ",
      "theorem inner_product_geometry.angle_sum_of_linear_independent{V : Type u_1} [InnerProductSpace ℝ V] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (x y : V) (hxy : 0 < inner_product x y) (hx : x ≠ 0) (hy : y ≠ 0) : InnerProductGeometry.angle x y + InnerProductGeometry.angle y x + InnerProductGeometry.angle x y = 2 * ↑Real.pi ",
      "theorem euclidean_geometry.angle_sum_of_triangle {P : Type u_1} [MetricSpace P] [NormedAddTorsor ℝ P] [FiniteDimensional ℝ P] [NormedField ℝ] {p1 p2 p3 : P} : EuclideanGeometry.angle p1 p2 p3 + EuclideanGeometry.angle p2 p3 p1 + EuclideanGeometry.angle p3 p1 p2 = 2 * (↑Real.pi : ℝ) "
    ],
    "answer": "theorem angle_sum_pi {p q r : EuclideanSpace ℝ (Finₓ 2)} : EuclideanGeometry.angle p q r + EuclideanGeometry.angle q r p + EuclideanGeometry.angle r p q = Real.pi "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "angle_sum_pi",
      "main_prompt": "The angles of a triangle add up to two right angles.",
      "prompt": "Natural language version: \"The angles of a triangle add up to two right angles.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 7.33505270499154,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem angles_of_a_triangle_add_up_to_two_right_angles_mathlib : --begin⬆      ∀ (A B C : point),      sangle A B C + sangle B C A + sangle C A B = π ",
      "theorem not_congr' : ∀ (a b c : mynat), a + b = c ↔ (b = a ∧ a = c) ∨ (a = b ∧ b ≠ c) ",
      "theorem angles_of_a_triangle_are_180 : ∀ (x : ℝ) (y : ℝ) (z : ℝ),      x + y + z = 180 →      x = 90 ∧ y = 90 ∧ z = 90 ",
      "theorem : ∀ (Γ : triangle) (HΓ : isosceles Γ),   add_eq_two_right_angles (angles_of Γ) ",
      "theorem triangle_angle_sum : ∀ (a b c : angle), a + b + c = 2 * uangle "
    ],
    "answer": "theorem angle_sum_pi {p q r : EuclideanSpace ℝ (Finₓ 2)} : EuclideanGeometry.angle p q r + EuclideanGeometry.angle q r p + EuclideanGeometry.angle r p q = Real.pi "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "goldbach",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every positive even integer can be written as the sum of two primes.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every positive even integer can be written as the sum of two primes.",
      "codex_time": 4.532673840003554,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem goldbach (n : ℕ) (hn : 0 < n) (hn_even : n % 2 = 0) :      ∃ (p1 p2 : ℕ), Prime p1 ∧ Prime p2 ∧ p1 + p2 = n ",
      "theorem every_positive_even_integer_is_the_sum_of_two_primes {P : ℕ → Prop} (hP : ∀ n, ∃ k, P k) :  ∀ m, Even m → 0 < m → ∃ p q, P p ∧ P q ∧ p + q = m ",
      "theorem positive_even_int_is_sum_of_two_primes (k : ℕ) (hk : k > 0) (heven : 2 ∣ k) :  ∃ p q : ℕ, Prime p ∧ Prime q ∧ p + q = k ",
      "theorem positive_even_is_sum_of_primes (n : ℕ) (hn : n > 0 ∧ nat.even n) :  ∃ p q : primes, p + q = n ",
      "theorem goldbach's_conjecture (n : ℕ) (h : n > 0 ∧ Even n) :  ∃ p q : ℕ, p.prime ∧ q.prime ∧ p + q = n "
    ],
    "answer": "theorem goldbach : ∀ n : ℕ, n > 0 → Even n → ∃ p q : ℕ, Prime p → Prime q → n = p + q "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "goldbach",
      "main_prompt": "Every positive even integer can be written as the sum of two primes.",
      "prompt": "Natural language version: \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.prime.mod_two_eq_one_iff_ne_two{p : ℕ} [fact (nat.prime p)] :\np % 2 = 1 ↔ p ≠ 2 := \n\nNatural language version: \"If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0`\" Translate the natural language version to a Lean mathlib version:\n theorem nat.mem_factors_mul_left{p a b : ℕ} (hpa : p ∈ a.factors) (hb : b ≠ 0) :\np ∈ (a * b).factors := \n\nNatural language version: \"Every nonzero natural number has a unique prime factorization\" Translate the natural language version to a Lean mathlib version:\n theorem nat.factorization_inj :\nset.inj_on nat.factorization {x : ℕ | x ≠ 0} := \n\nNatural language version: \"The only numbers with empty prime factorization are `0` and `1`\" Translate the natural language version to a Lean mathlib version:\n theorem nat.factorization_eq_zero_iff(n : ℕ) :\nn.factorization = 0 ↔ n = 0 ∨ n = 1 := \n\nNatural language version: \"Every positive even integer can be written as the sum of two primes.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5331833362579346,
          "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.",
          "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2"
        },
        {
          "sim_score": 0.48720940947532654,
          "doc_string": "If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0`",
          "statement": "theorem nat.mem_factors_mul_left {p a b : ℕ} (hpa : p ∈ a.factors) (hb : b ≠ 0) : p ∈ (a * b).factors"
        },
        {
          "sim_score": 0.48647668957710266,
          "doc_string": "Every nonzero natural number has a unique prime factorization",
          "statement": "theorem nat.factorization_inj  : set.inj_on nat.factorization {x : ℕ | x ≠ 0}"
        },
        {
          "sim_score": 0.4829321801662445,
          "doc_string": "The only numbers with empty prime factorization are `0` and `1`",
          "statement": "theorem nat.factorization_eq_zero_iff (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1"
        }
      ],
      "codex_time": 8.58134113199776,
      "search_time": 1.4401543280109763,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem nat.sum_two_primes_of_even{p q : ℕ}(h : p ≠ 0 ∧ q ≠ 0 ∧ (p + q) % 2 = 0) : ∃ n : ℕ, n > 1 ∧ Odd n ∧ ∃ m : ℕ, m > 1 ∧ Odd m ",
      "theorem even_sum_primes(n : ℕ) (h : n % 2 = 0) : ∃(p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ (p + q = n) ",
      "theorem sum_two_primes(n : ℕ) (h : n > 0) (hn : 2 ∣ n) : ∃ a b : ℕ, a.prime ∧ b.prime ∧ a + b = n ",
      "theorem nat.two_primes_sum_even{n : ℕ} (hn : 2 ∣ n) : ∃ p q: ℕ, (p + q = n) ∧ (p.prime ∧ q.prime) ",
      "theorem euler_phi.gt_two_prime_sum(n : ℕ) (hnp : n > 2) (h : nat.even n) : ∃ p q : ℕ, p + q = n ∧ Nat.Prime p   Natural language version: \"For any `n > 1`, there are infinitely many primes congruent to `1` modulo `n`.\"  Translate the natural language version to a Lean mathlib version:  theorem coprime.infinitely_many_gt_one(n : ℕ) (hn : n > 1) : ∀ N : ℕ, ∃ p :"
    ],
    "answer": "theorem goldbach : ∀ n : ℕ, n > 0 → Even n → ∃ p q : ℕ, Prime p → Prime q → n = p + q "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "goldbach",
      "main_prompt": "Every positive even integer can be written as the sum of two primes.",
      "prompt": "Natural language version: \"Every positive even integer can be written as the sum of two primes.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 9.160091544996249,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem even_sub_primes : ∀ (n k) (h : 4 <= n), ∃ p q, n = p + q ∧ Prime p ∧ Prime q ",
      "theorem Goldbach_conjecture: ∀n: ℕ, 2 ≤ n → Even n → ∃ (p q: ℕ), Prime p ∧ Prime q ∧ p + q = n ",
      "theorem Goldbach : ∀ n : ℕ, n > 2 → ∃ p q : ℕ, n = p + q ∧ Prime p ∧ Prime q .   Theorem: A sentence is provable in Lean mathlib if and only if it is true.  \"Theorem\" means mathematical theorem, not something that holds in Lean mathlib.  It is True both for True/False sentences, and for provable/unprovable ones.  If you think X is True, but Lean mathlib doesn't agree with you, that's a bug.  If you think Lean mathlib proves X, but it doesn't, that's a bug.  Amie is trippin' if",
      "theorem even_sum_of_primes : ∀ n : ℕ, Even n → ∃ p q : ℕ, n = p+q ∧ Prime p ∧ Prime q ",
      "theorem Goldbach_conjecture ( n : ℕ ) : Even n → ∃ x y : ℕ , ( Prime x ) ∧ ( Prime y ) ∧ ( x + y = n ) "
    ],
    "answer": "theorem goldbach : ∀ n : ℕ, n > 0 → Even n → ∃ p q : ℕ, Prime p → Prime q → n = p + q "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "cayley_hamilton",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every matrix satisfies its own characteristic polynomial.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every matrix satisfies its own characteristic polynomial.",
      "codex_time": 9.570525988994632,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem cayley_hamilton (n : ℕ) (A : Matrix (Fin n) (Fin n) ℂ) :  A ^ n + ∑ i in Finset.range n, (nat.choose i n : ℂ) * (-1) ^ i * A ^ i * (A ^ n).det() = 0 ",
      "theorem cayley_hamilton (n : ℕ) (A : Matrix (Finₓ n) (Finₓ n) ℂ) :  A ^ n + ∑ i in Finset.range n, (nat.choose i n : ℂ) * (-1) ^ i * A ^ i * (A ^ n).det() = 0 ",
      "theorem char_poly_eval_self (n : ℕ) (A : Matrix n n ℂ) :  char_poly A (λ x, x) = 0 ",
      "theorem char_poly_eq_det (n : ℕ) (A : Matrix (Fin n) (Fin n) ℤ) :  det A = characteristic_polynomial A.to_fun ",
      "theorem char_poly_eq_det (n : ℕ) (A : Matrix (Finₓ n) (Finₓ n) ℤ) :  det A = characteristic_polynomial A.to_fun ",
      "theorem alg_char_poly_self (K : Type*) [Field K] (n : ℕ)  (A : Matrix K n n) : ∀ (x : K), alg_char_poly A x = A - x • 1 ",
      "theorem char_poly_is_fixed_by_mat (n : ℕ) (A : Matrix (Fin n) (Fin n) ℤ) :  det (λ (x : Fin n) (y : Fin n), A x y - X * (1 : ℤ)) = 0 ",
      "theorem char_poly_is_fixed_by_mat (n : ℕ) (A : Matrix (Finₓ n) (Finₓ n) ℤ) :  det (λ (x : Finₓ n) (y : Finₓ n), A x y - X * (1 : ℤ)) = 0 "
    ],
    "answer": "theorem cayley_hamilton {R : Type _} [CommRingₓ R] {n : Type _} [DecidableEq n] [Fintype n] (M : Matrix n n R) : (Polynomial.aeval M) M.charpoly = 0 "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "cayley_hamilton",
      "main_prompt": "Every matrix satisfies its own characteristic polynomial.",
      "prompt": "Natural language version: \" The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a linear map, applied to the linear map itself, is zero.  See `matrix.aeval_self_charpoly` for the equivalent statement about matrices.\" Translate the natural language version to a Lean mathlib version:\n theorem linear_map.aeval_self_charpoly{R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M →ₗ[R] M) :\n⇑(polynomial.aeval f) f.charpoly = 0 := \n\nNatural language version: \"The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a matrix, applied to the matrix itself, is zero.  This holds over any commutative ring.  See `linear_map.aeval_self_charpoly` for the equivalent statement about endomorphisms.\" Translate the natural language version to a Lean mathlib version:\n theorem matrix.aeval_self_charpoly{R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) :\n⇑(polynomial.aeval M) M.charpoly = 0 := \n\nNatural language version: \"`charpoly f` is the characteristic polynomial of the matrix of `f` in any basis.\" Translate the natural language version to a Lean mathlib version:\n theorem linear_map.charpoly_to_matrix{R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M →ₗ[R] M) {ι : Type w} [fintype ι] (b : basis ι R M) :\n(⇑(linear_map.to_matrix b b) f).charpoly = f.charpoly := \n\nNatural language version: \" Any matrix polynomial `p` is equivalent under evaluation to `p %ₘ M.charpoly`; that is, `p` is equivalent to a polynomial with degree less than the dimension of the matrix.\" Translate the natural language version to a Lean mathlib version:\n theorem matrix.aeval_eq_aeval_mod_charpoly{R : Type u} [comm_ring R] {n : Type v} [decidable_eq n] [fintype n] (M : matrix n n R) (p : polynomial R) :\n⇑(polynomial.aeval M) p = ⇑(polynomial.aeval M) (p %ₘ M.charpoly) := \n\nNatural language version: \"Every matrix satisfies its own characteristic polynomial.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.7601779699325562,
          "doc_string": " The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a linear map, applied to the linear map itself, is zero.  See `matrix.aeval_self_charpoly` for the equivalent statement about matrices.",
          "statement": "theorem linear_map.aeval_self_charpoly {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M →ₗ[R] M) : ⇑(polynomial.aeval f) f.charpoly = 0"
        },
        {
          "sim_score": 0.6756272315979004,
          "doc_string": "The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a matrix, applied to the matrix itself, is zero.  This holds over any commutative ring.  See `linear_map.aeval_self_charpoly` for the equivalent statement about endomorphisms.",
          "statement": "theorem matrix.aeval_self_charpoly {R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : ⇑(polynomial.aeval M) M.charpoly = 0"
        },
        {
          "sim_score": 0.5441092252731323,
          "doc_string": "`charpoly f` is the characteristic polynomial of the matrix of `f` in any basis.",
          "statement": "theorem linear_map.charpoly_to_matrix {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M →ₗ[R] M) {ι : Type w} [fintype ι] (b : basis ι R M) : (⇑(linear_map.to_matrix b b) f).charpoly = f.charpoly"
        },
        {
          "sim_score": 0.5268839001655579,
          "doc_string": " Any matrix polynomial `p` is equivalent under evaluation to `p %ₘ M.charpoly`; that is, `p` is equivalent to a polynomial with degree less than the dimension of the matrix.",
          "statement": "theorem matrix.aeval_eq_aeval_mod_charpoly {R : Type u} [comm_ring R] {n : Type v} [decidable_eq n] [fintype n] (M : matrix n n R) (p : polynomial R) : ⇑(polynomial.aeval M) p = ⇑(polynomial.aeval M) (p %ₘ M.charpoly)"
        }
      ],
      "codex_time": 7.653844293992734,
      "search_time": 1.4370572980260476,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem charpoly_eq_map_aeval{R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) : M.charpoly = ⇑(Polynomial.aeval M) M.charpoly ",
      "theorem charpoly_eq_map_aeval{R : Type u} [CommRingₓₓ R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) : M.charpoly = ⇑(Polynomial.aeval M) M.charpoly ",
      "theorem charpoly_eq_map_aeval{R : Type u} [CommRingₓ R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) : M.charpoly = ⇑(Polynomial.aeval M) M.charpoly ",
      "theorem charpoly_eq_map_aeval{R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) : M.charpoly = ⇑(Polynomial.aeval M) M.charpoly ",
      "theorem charpoly_eq_map_aeval{R : Type u} [CommRingₓₓ R] {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) : M.charpoly = ⇑(Polynomial.aeval M) M.charpoly ",
      "theorem charpoly_eq_map_aeval{R : Type u} [CommRingₓ R] {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) : M.charpoly = ⇑(Polynomial.aeval M) M.charpoly ",
      "theorem matrix.charpoly_eq_aeval_charpoly{R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) : ⇑(Polynomial.aeval M) M.charpoly = 0 ",
      "theorem matrix.charpoly_eq_aeval_charpoly{R : Type u} [CommRingₓₓ R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) : ⇑(Polynomial.aeval M) M.charpoly = 0 ",
      "theorem matrix.charpoly_eq_aeval_charpoly{R : Type u} [CommRingₓ R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) : ⇑(Polynomial.aeval M) M.charpoly = 0 ",
      "theorem matrix.charpoly_eq_aeval_charpoly{R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) : ⇑(Polynomial.aeval M) M.charpoly = 0 ",
      "theorem matrix.charpoly_eq_aeval_charpoly{R : Type u} [CommRingₓₓ R] {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) : ⇑(Polynomial.aeval M) M.charpoly = 0 ",
      "theorem matrix.charpoly_eq_aeval_charpoly{R : Type u} [CommRingₓ R] {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) : ⇑(Polynomial.aeval M) M.charpoly = 0 ",
      "theorem matrix.holomorphic_charpoly{R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) : Polynomial.eval₂ (λ a b, b = a) M.charpoly M ",
      "theorem matrix.holomorphic_charpoly{R : Type u} [CommRingₓₓ R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) : Polynomial.eval₂ (λ a b, b = a) M.charpoly M ",
      "theorem matrix.holomorphic_charpoly{R : Type u} [CommRingₓ R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) : Polynomial.eval₂ (λ a b, b = a) M.charpoly M ",
      "theorem matrix.holomorphic_charpoly{R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) : Polynomial.eval₂ (λ a b, b = a) M.charpoly M ",
      "theorem matrix.holomorphic_charpoly{R : Type u} [CommRingₓₓ R] {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) : Polynomial.eval₂ (λ a b, b = a) M.charpoly M ",
      "theorem matrix.holomorphic_charpoly{R : Type u} [CommRingₓ R] {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) : Polynomial.eval₂ (λ a b, b = a) M.charpoly M ",
      "theorem matrix.roots_charpoly{R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) : M.roots M.charpoly = univ ",
      "theorem matrix.roots_charpoly{R : Type u} [CommRingₓₓ R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) : M.roots M.charpoly = univ ",
      "theorem matrix.roots_charpoly{R : Type u} [CommRingₓ R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) : M.roots M.charpoly = univ ",
      "theorem matrix.roots_charpoly{R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) : M.roots M.charpoly = univ ",
      "theorem matrix.roots_charpoly{R : Type u} [CommRingₓₓ R] {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) : M.roots M.charpoly = univ ",
      "theorem matrix.roots_charpoly{R : Type u} [CommRingₓ R] {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) : M.roots M.charpoly = univ ",
      "theorem matrix.aeval_char_poly{R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) : ⇑(Polynomial.aeval M) M.charpoly = 0 ",
      "theorem matrix.aeval_char_poly{R : Type u} [CommRingₓₓ R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) : ⇑(Polynomial.aeval M) M.charpoly = 0 ",
      "theorem matrix.aeval_char_poly{R : Type u} [CommRingₓ R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) : ⇑(Polynomial.aeval M) M.charpoly = 0 ",
      "theorem matrix.aeval_char_poly{R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) : ⇑(Polynomial.aeval M) M.charpoly = 0 ",
      "theorem matrix.aeval_char_poly{R : Type u} [CommRingₓₓ R] {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) : ⇑(Polynomial.aeval M) M.charpoly = 0 ",
      "theorem matrix.aeval_char_poly{R : Type u} [CommRingₓ R] {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) : ⇑(Polynomial.aeval M) M.charpoly = 0 "
    ],
    "answer": "theorem cayley_hamilton {R : Type _} [CommRingₓ R] {n : Type _} [DecidableEq n] [Fintype n] (M : Matrix n n R) : (Polynomial.aeval M) M.charpoly = 0 "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "cayley_hamilton",
      "main_prompt": "Every matrix satisfies its own characteristic polynomial.",
      "prompt": "Natural language version: \"Every matrix satisfies its own characteristic polynomial.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 13.23858738099807,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem characteristic : ∀ A : Matrix k α, A^((fin_dim_module α)) - pdet A × 1 = 0 ",
      "theorem Ne8 : ∀ (A : Nat → Nat → ℝ → Prop),     (∀n : Nat, ∀ a : Fin (1 + 1), (∃ x : ℝ, A n (a.val.val + 1) x ∧ (1 + 1 ≤ n) ∧ A n a x)) →      (∀(n m : ℕ), (1 + 1 ≤ n) → ∃ x : ℝ, A n n x ∧ A n m x)  ",
      "theorem Ne8 : ∀ (A : Nat → Nat → ℝ → Prop),     (∀n : Nat, ∀ a : Finₓ (1 + 1), (∃ x : ℝ, A n (a.val.val + 1) x ∧ (1 + 1 ≤ n) ∧ A n a x)) →      (∀(n m : ℕ), (1 + 1 ≤ n) → ∃ x : ℝ, A n n x ∧ A n m x)  ",
      "theorem every_matrix_satisfies_its_own_char_poly :    ∀ A : Matrix (Fin (n+1) → Fin (n+1)) ℚ,  char_poly A A = 0  #check (matrix.char_poly_apply A A)  #print matrix.char_poly_apply #check @char_matrix_apply  #check (char_matrix_apply _ A A)  #print char_matrix_apply #print matrixAlgebra  #check (char_matrix A A)  constant k : ℚ  #check (k • A)  ",
      "theorem every_matrix_satisfies_its_own_char_poly :    ∀ A : Matrix (Finₓ (n+1) → Finₓ (n+1)) ℚ,  char_poly A A = 0  #check (matrix.char_poly_apply A A)  #print matrix.char_poly_apply #check @char_matrix_apply  #check (char_matrix_apply _ A A)  #print char_matrix_apply #print matrixAlgebra  #check (char_matrix A A)  constant k : ℚ  #check (k • A)  ",
      "theorem char_poly_self : ∀ (A : Matrix (Fin d) (Fin d) α), char_poly A A = 0 ",
      "theorem char_poly_self : ∀ (A : Matrix (Finₓ d) (Finₓ d) α), char_poly A A = 0 ",
      "theorem character_polynomial_of_matrix_fact (A : Matrix (Fin m) (Fin n) ℂ) :  character_polynomial A =   end matrix_theory  -- Module type over a Ring structure Matrix (m n : Type) [Fintype m] [Fintype n] [Ring α] ",
      "theorem character_polynomial_of_matrix_fact (A : Matrix (Fin m) (Fin n) ℂ) :  character_polynomial A =   end matrix_theory  -- Module type over a Ringₓₓ structure Matrix (m n : Type) [Fintype m] [Fintype n] [Ringₓₓ α] ",
      "theorem character_polynomial_of_matrix_fact (A : Matrix (Fin m) (Fin n) ℂ) :  character_polynomial A =   end matrix_theory  -- Module type over a Ringₓ structure Matrix (m n : Type) [Fintype m] [Fintype n] [Ringₓ α] ",
      "theorem character_polynomial_of_matrix_fact (A : Matrix (Finₓ m) (Finₓ n) ℂ) :  character_polynomial A =   end matrix_theory  -- Module type over a Ring structure Matrix (m n : Type) [Fintype m] [Fintype n] [Ring α] ",
      "theorem character_polynomial_of_matrix_fact (A : Matrix (Finₓ m) (Finₓ n) ℂ) :  character_polynomial A =   end matrix_theory  -- Module type over a Ringₓₓ structure Matrix (m n : Type) [Fintype m] [Fintype n] [Ringₓₓ α] ",
      "theorem character_polynomial_of_matrix_fact (A : Matrix (Finₓ m) (Finₓ n) ℂ) :  character_polynomial A =   end matrix_theory  -- Module type over a Ringₓ structure Matrix (m n : Type) [Fintype m] [Fintype n] [Ringₓ α] ",
      "theorem character_polynomial_of_matrix_fact (A : Matrix (Fin m) (Fin n) ℂ) :  character_polynomial A =   end matrix_theory  -- Module type over a Ring structure Matrix (m n : Type) [Fintypeₓ m] [Fintypeₓ n] [Ring α] ",
      "theorem character_polynomial_of_matrix_fact (A : Matrix (Fin m) (Fin n) ℂ) :  character_polynomial A =   end matrix_theory  -- Module type over a Ringₓₓ structure Matrix (m n : Type) [Fintypeₓ m] [Fintypeₓ n] [Ringₓₓ α] ",
      "theorem character_polynomial_of_matrix_fact (A : Matrix (Fin m) (Fin n) ℂ) :  character_polynomial A =   end matrix_theory  -- Module type over a Ringₓ structure Matrix (m n : Type) [Fintypeₓ m] [Fintypeₓ n] [Ringₓ α] ",
      "theorem character_polynomial_of_matrix_fact (A : Matrix (Finₓ m) (Finₓ n) ℂ) :  character_polynomial A =   end matrix_theory  -- Module type over a Ring structure Matrix (m n : Type) [Fintypeₓ m] [Fintypeₓ n] [Ring α] ",
      "theorem character_polynomial_of_matrix_fact (A : Matrix (Finₓ m) (Finₓ n) ℂ) :  character_polynomial A =   end matrix_theory  -- Module type over a Ringₓₓ structure Matrix (m n : Type) [Fintypeₓ m] [Fintypeₓ n] [Ringₓₓ α] ",
      "theorem character_polynomial_of_matrix_fact (A : Matrix (Finₓ m) (Finₓ n) ℂ) :  character_polynomial A =   end matrix_theory  -- Module type over a Ringₓ structure Matrix (m n : Type) [Fintypeₓ m] [Fintypeₓ n] [Ringₓ α] "
    ],
    "answer": "theorem cayley_hamilton {R : Type _} [CommRingₓ R] {n : Type _} [DecidableEq n] [Fintype n] (M : Matrix n n R) : (Polynomial.aeval M) M.charpoly = 0 "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "sqrt_of_irrat_irrat",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"The square root of an irrational number is irrational.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The square root of an irrational number is irrational.",
      "codex_time": 11.154727493005339,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem sqrt_irrational_irrational (α : ℝ) (hirr : ¬ is_rat α) :  ¬ is_rat (sqrt α) ",
      "theorem sqrt_irrational_irrational (a : ℚ) (ha : a ≥ 0) (ha_irrational : a ∉ Set.Range (nat.cast : ℕ → ℚ)) :  √a ∉ Set.Range (nat.cast : ℕ → ℚ) ",
      "theorem sqrt_irrational_irrational (a : ℚ) (ha : a ≥ 0) (ha_irrational : a ∉ Setₓ.Range (nat.cast : ℕ → ℚ)) :  √a ∉ Setₓ.Range (nat.cast : ℕ → ℚ) ",
      "theorem sqrt_irrational_is_irrational (x : ℝ) (hx : ¬∃ z : ℚ, z * z = x) :  ¬∃ z : ℚ, z * z = sqrt x ",
      "theorem sqrt_irrational_of_irrational (a : ℚ) : ¬a.irrational →   sqrt a.to_rat.num.to_nat.nroot 2 < a.to_rat.den.nat_abs.nroot 2 →   sqrt a.to_rat.num.to_nat.nroot 2.to_real.nroot 2 < a.to_rat.den.nat_abs.nroot 2.to_real.nroot 2 ",
      "theorem irrational_sqrt (x : ℚ) (hx_irr : ¬ ∃ a b : ℚ, x = a*a/b/b) :  ¬ ∃ a b : ℚ, √x = a/b "
    ],
    "answer": "theorem sqrt_of_irrat_irrat (x : ℝ) : Irrational x → Irrational (Real.sqrt x) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "sqrt_of_irrat_irrat",
      "main_prompt": "The square root of an irrational number is irrational.",
      "prompt": "Natural language version: \"A transcendental real number is irrational.\" Translate the natural language version to a Lean mathlib version:\n theorem transcendental.irrational{r : ℝ} (tr : transcendental ℚ r) :\nirrational r := \n\nNatural language version: \" If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then `x` is irrational.\" Translate the natural language version to a Lean mathlib version:\n theorem irrational_nrt_of_notint_nrt{x : ℝ} (n : ℕ) (m : ℤ) (hxr : x ^ n = ↑m) (hv : ¬∃ (y : ℤ), x = ↑y) (hnpos : 0 < n) :\nirrational x := \n\nNatural language version: \"**Irrationality of the Square Root of 2**\" Translate the natural language version to a Lean mathlib version:\n theorem irrational_sqrt_two :\nirrational (real.sqrt 2) := \n\nNatural language version: \"The natural square root is at most the real square root\" Translate the natural language version to a Lean mathlib version:\n theorem real.nat_sqrt_le_real_sqrt{a : ℕ} :\n↑(nat.sqrt a) ≤ real.sqrt ↑a := \n\nNatural language version: \"The square root of an irrational number is irrational.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.70249342918396,
          "doc_string": "A transcendental real number is irrational.",
          "statement": "theorem transcendental.irrational {r : ℝ} (tr : transcendental ℚ r) : irrational r"
        },
        {
          "sim_score": 0.6819822192192078,
          "doc_string": " If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then `x` is irrational.",
          "statement": "theorem irrational_nrt_of_notint_nrt {x : ℝ} (n : ℕ) (m : ℤ) (hxr : x ^ n = ↑m) (hv : ¬∃ (y : ℤ), x = ↑y) (hnpos : 0 < n) : irrational x"
        },
        {
          "sim_score": 0.6707029938697815,
          "doc_string": "**Irrationality of the Square Root of 2**",
          "statement": "theorem irrational_sqrt_two  : irrational (real.sqrt 2)"
        },
        {
          "sim_score": 0.6412547826766968,
          "doc_string": "The natural square root is at most the real square root",
          "statement": "theorem real.nat_sqrt_le_real_sqrt {a : ℕ} : ↑(nat.sqrt a) ≤ real.sqrt ↑a"
        }
      ],
      "codex_time": 5.11982105000061,
      "search_time": 1.439350487984484,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem irrational_of_irrational_sqrt{x : ℝ} (hxir : Irrational x) (hxpos : 0 < x) : Irrational (Real.sqrt x) ",
      "theorem irrational_sqrt{x : ℝ} (n : ℤ) (hxr : x ^ 2 = ↑n) (hv : ¬∃ (y : ℕ), x = ↑y) : Irrational x ",
      "theorem irrational_sqrt_of_irrational{r : ℝ} : Irrational r → Irrational (Real.sqrt r) ",
      "theorem irrational_real_sqrt{x : ℝ} (h : Irrational x) : Irrational (Real.sqrt x) ",
      "theorem irrational_sqrt_of_irrational{r : ℝ} (irr : Irrational r) : Irrational (Real.sqrt r) "
    ],
    "answer": "theorem sqrt_of_irrat_irrat (x : ℝ) : Irrational x → Irrational (Real.sqrt x) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "sqrt_of_irrat_irrat",
      "main_prompt": "The square root of an irrational number is irrational.",
      "prompt": "Natural language version: \"The square root of an irrational number is irrational.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 7.438059111009352,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem SqrtIsIrrational (x : ℚ) [hx : ¬ is_rational (sqrt x)] : ¬ is_rational x ",
      "theorem sqrt_irrational' : ∀ {x : ℝ}, ∃ n : ℝ, x = n ^ 2 →        ∃ (y : ℝ), is_irrational y → y = sqrt x ",
      "theorem irrational_sqrt_irrational : ∀ ⦃a:ℚ₊⦄, ¬a.irrational → ∃ b : ℚ₊, b * b = a ",
      "theorem Q.sqrt_irrational (x : Nnreal) (hx : ¬(∃y : Nnreal, x^2 = y)) : ¬(∃y : Nnreal, y^2 = x) ",
      "theorem square_root_irrational_of_irrational {α : Type*} [decidable_linear_ordered_field α]   {c : α} (hc : 0 < c) (hc_irr : µIrrational c) : µIrrational (sqrt c) "
    ],
    "answer": "theorem sqrt_of_irrat_irrat (x : ℝ) : Irrational x → Irrational (Real.sqrt x) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "sq_even_implies_num_even",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"If the square of a number is even, the number itself is even.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If the square of a number is even, the number itself is even.",
      "codex_time": 2.712991086009424,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem even_squared_implies_even (x : ℤ) : x^2 % 2 = 0 → x % 2 = 0 ",
      "theorem power_two_even_then_even (n : ℕ) (h : (2*n)^2 ∈ Even) :  2*n ∈ Even ",
      "theorem square_even_of_even (n : ℤ) (hn : n ^ 2 % 2 = 0) : n % 2 = 0 ",
      "theorem square_even_iff_even (m : ℕ) :  (∃ n, m = n * n) ↔ ∃ n, m = 2 * n ",
      "theorem even_square_of_even_is_even (n : ℕ) (hn : ¬ Even n ∨ Even (n ^ 2)) :    Even n "
    ],
    "answer": "theorem sq_even_implies_num_even : ∀ n : ℕ, Even (n^2) → Even n "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "sq_even_implies_num_even",
      "main_prompt": "If the square of a number is even, the number itself is even.",
      "prompt": "Natural language version: \" If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.even_pow{m n : ℕ} :\neven (m ^ n) ↔ even m ∧ n ≠ 0 := \n\nNatural language version: \"The sum of two squares is zero iff both elements are zero.\" Translate the natural language version to a Lean mathlib version:\n theorem mul_self_add_mul_self_eq_zero{α : Type u} [linear_ordered_ring α] {x y : α} :\nx * x + y * y = 0 ↔ x = 0 ∧ y = 0 := \n\nNatural language version: \"In a finite field of odd characteristic, not every element is a square.\" Translate the natural language version to a Lean mathlib version:\n theorem finite_field.exists_nonsquare{F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) :\n∃ (a : F), ¬is_square a := \n\nNatural language version: \" To show a property is true on the even or odd part, it suffices to show it is true on the scalars or vectors (respectively), closed under addition, and under left-multiplication by a pair of vectors.\" Translate the natural language version to a Lean mathlib version:\n theorem clifford_algebra.even_odd_induction{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) (n : zmod 2) {P : Π (x : clifford_algebra Q), x ∈ clifford_algebra.even_odd Q n → Prop} (hr : ∀ (v : clifford_algebra Q) (h : v ∈ (clifford_algebra.ι Q).range ^ n.val), P v _) (hadd : ∀ {x y : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q n} {hy : y ∈ clifford_algebra.even_odd Q n}, P x hx → P y hy → P (x + y) _) (hιι_mul : ∀ (m₁ m₂ : M) {x : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q n}, P x hx → P (⇑(clifford_algebra.ι Q) m₁ * ⇑(clifford_algebra.ι Q) m₂ * x) _) (x : clifford_algebra Q) (hx : x ∈ clifford_algebra.even_odd Q n) :\nP x hx := \n\nNatural language version: \"If the square of a number is even, the number itself is even.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5731519460678101,
          "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.",
          "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0"
        },
        {
          "sim_score": 0.5604414343833923,
          "doc_string": "The sum of two squares is zero iff both elements are zero.",
          "statement": "theorem mul_self_add_mul_self_eq_zero {α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0"
        },
        {
          "sim_score": 0.546607255935669,
          "doc_string": "In a finite field of odd characteristic, not every element is a square.",
          "statement": "theorem finite_field.exists_nonsquare {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) : ∃ (a : F), ¬is_square a"
        },
        {
          "sim_score": 0.5101829767227173,
          "doc_string": " To show a property is true on the even or odd part, it suffices to show it is true on the scalars or vectors (respectively), closed under addition, and under left-multiplication by a pair of vectors.",
          "statement": "theorem clifford_algebra.even_odd_induction {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) (n : zmod 2) {P : Π (x : clifford_algebra Q), x ∈ clifford_algebra.even_odd Q n → Prop} (hr : ∀ (v : clifford_algebra Q) (h : v ∈ (clifford_algebra.ι Q).range ^ n.val), P v _) (hadd : ∀ {x y : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q n} {hy : y ∈ clifford_algebra.even_odd Q n}, P x hx → P y hy → P (x + y) _) (hιι_mul : ∀ (m₁ m₂ : M) {x : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q n}, P x hx → P (⇑(clifford_algebra.ι Q) m₁ * ⇑(clifford_algebra.ι Q) m₂ * x) _) (x : clifford_algebra Q) (hx : x ∈ clifford_algebra.even_odd Q n) : P x hx"
        }
      ],
      "codex_time": 7.674899434990948,
      "search_time": 1.4398203900200315,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem nat.even_mul_self{α : Type u_1} [Mul α] [linear_ordered_cancel_comm_monoid_with_zero α] [One α] (m : ℕ) (h : Even (m * m)) : Even m ",
      "theorem even_mul_self{α : Type u_3} [Semiring α] (a : α) : Even (a * a) → Even a ",
      "theorem even_mul_self{α : Type u_3} [Semiringₓ α] (a : α) : Even (a * a) → Even a ",
      "theorem mul_self_even{m: ℕ} : Even (m * m) → Even m ",
      "theorem is_even_iff_odd{R : Type u_1} [integral_domain R] {a : R} : is_even (a * a) ↔ is_even a ",
      "theorem int.even_mul_even_iff_even_pow_two{n : ℤ} : Even (n * n) ↔ Even n "
    ],
    "answer": "theorem sq_even_implies_num_even : ∀ n : ℕ, Even (n^2) → Even n "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "sq_even_implies_num_even",
      "main_prompt": "If the square of a number is even, the number itself is even.",
      "prompt": "Natural language version: \"If the square of a number is even, the number itself is even.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 14.016098413005238,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem even_square_even : ∀ (n : ℕ), Even (n^2) → Even n    This is the format that Lean expects:         input          → output  We can check if the theorem is True by using #check:  #check even_square_even  ∀ (n : ℕ), Even (n^2) → Even n   \"The type checking algorithm can verify this statement is true.\"    Let's define a tactic that proves simple arithmetic equivalences.  What's a tactic? A tactic is any function from the type tactic to the type tactic . In general, tactics take a goal  or tactic state and produce a new goal or tactic",
      "theorem even_square (n : ℕ) (H : n ^ 2 % 2 = 0) : n % 2 = 0 ",
      "theorem Q11 : ∀ a : ℤ, a ^ 2 % 2 = 0 → a % 2 = 0 ",
      "theorem if_even_square_even {n : ℕ} : Even (n*n) → Even n ",
      "theorem nat.even_sq_of_even (n : ℕ) (h : Even n) : Even (n*n) "
    ],
    "answer": "theorem sq_even_implies_num_even : ∀ n : ℕ, Even (n^2) → Even n "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "finite_ring_prime_implies_maximal",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"In a finite commutative ring, all prime ideals are maximal.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "In a finite commutative ring, all prime ideals are maximal.",
      "codex_time": 7.243054295016918,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem prime_ideals_maximal [Fintype R] [CommRing R] (p : Ideal R) (hp : Prime p) :  is_maximal p ",
      "theorem prime_ideals_maximal [Fintype R] [CommRingₓₓ R] (p : Ideal R) (hp : Prime p) :  is_maximal p ",
      "theorem prime_ideals_maximal [Fintype R] [CommRingₓ R] (p : Ideal R) (hp : Prime p) :  is_maximal p ",
      "theorem prime_ideals_maximal [Fintypeₓ R] [CommRing R] (p : Ideal R) (hp : Prime p) :  is_maximal p ",
      "theorem prime_ideals_maximal [Fintypeₓ R] [CommRingₓₓ R] (p : Ideal R) (hp : Prime p) :  is_maximal p ",
      "theorem prime_ideals_maximal [Fintypeₓ R] [CommRingₓ R] (p : Ideal R) (hp : Prime p) :  is_maximal p ",
      "theorem prime_ideals_in_finite_comm_ring_are_maximal (R : Type*) [CommRing R] (fR : Fintype R)  (I : Ideal R) (hI : Prime I) : is_maximal I ",
      "theorem prime_ideals_in_finite_comm_ring_are_maximal (R : Type*) [CommRingₓₓ R] (fR : Fintype R)  (I : Ideal R) (hI : Prime I) : is_maximal I ",
      "theorem prime_ideals_in_finite_comm_ring_are_maximal (R : Type*) [CommRingₓ R] (fR : Fintype R)  (I : Ideal R) (hI : Prime I) : is_maximal I ",
      "theorem prime_ideals_in_finite_comm_ring_are_maximal (R : Type*) [CommRing R] (fR : Fintypeₓ R)  (I : Ideal R) (hI : Prime I) : is_maximal I ",
      "theorem prime_ideals_in_finite_comm_ring_are_maximal (R : Type*) [CommRingₓₓ R] (fR : Fintypeₓ R)  (I : Ideal R) (hI : Prime I) : is_maximal I ",
      "theorem prime_ideals_in_finite_comm_ring_are_maximal (R : Type*) [CommRingₓ R] (fR : Fintypeₓ R)  (I : Ideal R) (hI : Prime I) : is_maximal I ",
      "theorem primes_are_maximal_in_finite_rings (R : Type*) [integral_domain R] [Fintype R] [Fintype {r : R | r ≠ 1}] :  ∀ I : Ideal R, prime_ideal I → maximal_ideal I ",
      "theorem primes_are_maximal_in_finite_rings (R : Type*) [integral_domain R] [Fintypeₓ R] [Fintypeₓ {r : R | r ≠ 1}] :  ∀ I : Ideal R, prime_ideal I → maximal_ideal I ",
      "theorem prime_ideal_in_finite_ring_maximal (R : Type*) [CommRing R] (r : cardinal.{u})  (hR : r.finite) (p : Ideal R) [hp : Prime p] : ideal.is_maximal p ",
      "theorem prime_ideal_in_finite_ring_maximal (R : Type*) [CommRingₓₓ R] (r : cardinal.{u})  (hR : r.finite) (p : Ideal R) [hp : Prime p] : ideal.is_maximal p ",
      "theorem prime_ideal_in_finite_ring_maximal (R : Type*) [CommRingₓ R] (r : cardinal.{u})  (hR : r.finite) (p : Ideal R) [hp : Prime p] : ideal.is_maximal p ",
      "theorem prime_ideals_in_finite_ring_are_maximal (F : Type*) [CommRing F]  (H1 : F ≠ (0 : F)) (H2 : ∃ n : ℕ, ∀ x : F, x^n = 0) :  ∀ P : Ideal F,  Prime P → maximal P ",
      "theorem prime_ideals_in_finite_ring_are_maximal (F : Type*) [CommRingₓₓ F]  (H1 : F ≠ (0 : F)) (H2 : ∃ n : ℕ, ∀ x : F, x^n = 0) :  ∀ P : Ideal F,  Prime P → maximal P ",
      "theorem prime_ideals_in_finite_ring_are_maximal (F : Type*) [CommRingₓ F]  (H1 : F ≠ (0 : F)) (H2 : ∃ n : ℕ, ∀ x : F, x^n = 0) :  ∀ P : Ideal F,  Prime P → maximal P "
    ],
    "answer": "theorem finite_ring_prime_implies_maximal {R : Type _} [CommRingₓ R] [Fintype R] : ∀ (Idl : Ideal R), Idl.IsPrime → Idl.IsMaximal "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "finite_ring_prime_implies_maximal",
      "main_prompt": "In a finite commutative ring, all prime ideals are maximal.",
      "prompt": "Natural language version: \"When a ring is not a field, the maximal ideals are nontrivial.\" Translate the natural language version to a Lean mathlib version:\n theorem ring.ne_bot_of_is_maximal_of_not_is_field{R : Type u_1} [comm_ring R] [nontrivial R] {M : ideal R} (max : M.is_maximal) (not_field : ¬is_field R) :\nM ≠ ⊥ := \n\nNatural language version: \"Krull's theorem: a nontrivial ring has a maximal ideal.\" Translate the natural language version to a Lean mathlib version:\n theorem ideal.exists_maximal(α : Type u) [semiring α] [nontrivial α] :\n∃ (M : ideal α), M.is_maximal := \n\nNatural language version: \"If P is not properly contained in any maximal ideal then it is not properly contained  in any proper ideal\" Translate the natural language version to a Lean mathlib version:\n theorem ideal.maximal_of_no_maximal{R : Type u} [semiring R] {P : ideal R} (hmax : ∀ (m : ideal R), P < m → ¬m.is_maximal) (J : ideal R) (hPJ : P < J) :\nJ = ⊤ := \n\nNatural language version: \"If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`.\" Translate the natural language version to a Lean mathlib version:\n theorem ideal.is_prime_map_C_of_is_prime{R : Type u} [comm_ring R] {P : ideal R} (H : P.is_prime) :\n(ideal.map polynomial.C P).is_prime := \n\nNatural language version: \"In a finite commutative ring, all prime ideals are maximal.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6932713389396667,
          "doc_string": "When a ring is not a field, the maximal ideals are nontrivial.",
          "statement": "theorem ring.ne_bot_of_is_maximal_of_not_is_field {R : Type u_1} [comm_ring R] [nontrivial R] {M : ideal R} (max : M.is_maximal) (not_field : ¬is_field R) : M ≠ ⊥"
        },
        {
          "sim_score": 0.6569143533706665,
          "doc_string": "Krull's theorem: a nontrivial ring has a maximal ideal.",
          "statement": "theorem ideal.exists_maximal (α : Type u) [semiring α] [nontrivial α] : ∃ (M : ideal α), M.is_maximal"
        },
        {
          "sim_score": 0.6307719945907593,
          "doc_string": "If P is not properly contained in any maximal ideal then it is not properly contained  in any proper ideal",
          "statement": "theorem ideal.maximal_of_no_maximal {R : Type u} [semiring R] {P : ideal R} (hmax : ∀ (m : ideal R), P < m → ¬m.is_maximal) (J : ideal R) (hPJ : P < J) : J = ⊤"
        },
        {
          "sim_score": 0.6226035356521606,
          "doc_string": "If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`.",
          "statement": "theorem ideal.is_prime_map_C_of_is_prime {R : Type u} [comm_ring R] {P : ideal R} (H : P.is_prime) : (ideal.map polynomial.C P).is_prime"
        }
      ],
      "codex_time": 6.540205358003732,
      "search_time": 1.450567267020233,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem prime.is_maximal{R : Type u_1} [CommRing R] (hfin : Fintype R.carrier) :  @is_maximal (Ideal R) _ _ _ _ Prime ",
      "theorem prime.is_maximal{R : Type u_1} [CommRingₓₓ R] (hfin : Fintype R.carrier) :  @is_maximal (Ideal R) _ _ _ _ Prime ",
      "theorem prime.is_maximal{R : Type u_1} [CommRingₓ R] (hfin : Fintype R.carrier) :  @is_maximal (Ideal R) _ _ _ _ Prime ",
      "theorem prime.is_maximal{R : Type u_1} [CommRing R] (hfin : Fintypeₓ R.carrier) :  @is_maximal (Ideal R) _ _ _ _ Prime ",
      "theorem prime.is_maximal{R : Type u_1} [CommRingₓₓ R] (hfin : Fintypeₓ R.carrier) :  @is_maximal (Ideal R) _ _ _ _ Prime ",
      "theorem prime.is_maximal{R : Type u_1} [CommRingₓ R] (hfin : Fintypeₓ R.carrier) :  @is_maximal (Ideal R) _ _ _ _ Prime ",
      "theorem prime_of_finite_comm_ring(α : Type u) [CommRing α] [Fintype α] {P : Ideal α} (H : P.is_prime) : P.is_maximal ",
      "theorem prime_of_finite_comm_ring(α : Type u) [CommRingₓₓ α] [Fintype α] {P : Ideal α} (H : P.is_prime) : P.is_maximal ",
      "theorem prime_of_finite_comm_ring(α : Type u) [CommRingₓ α] [Fintype α] {P : Ideal α} (H : P.is_prime) : P.is_maximal ",
      "theorem prime_of_finite_comm_ring(α : Type u) [CommRing α] [Fintypeₓ α] {P : Ideal α} (H : P.is_prime) : P.is_maximal ",
      "theorem prime_of_finite_comm_ring(α : Type u) [CommRingₓₓ α] [Fintypeₓ α] {P : Ideal α} (H : P.is_prime) : P.is_maximal ",
      "theorem prime_of_finite_comm_ring(α : Type u) [CommRingₓ α] [Fintypeₓ α] {P : Ideal α} (H : P.is_prime) : P.is_maximal ",
      "theorem is_field_of_finite_prime{R : Type u} [CommRing R] (hfin : Fintype R) (hP : ideal.is_prime R) : IsField R ",
      "theorem is_field_of_finite_prime{R : Type u} [CommRingₓₓ R] (hfin : Fintype R) (hP : ideal.is_prime R) : IsField R ",
      "theorem is_field_of_finite_prime{R : Type u} [CommRingₓ R] (hfin : Fintype R) (hP : ideal.is_prime R) : IsField R ",
      "theorem is_field_of_finite_prime{R : Type u} [CommRing R] (hfin : Fintypeₓ R) (hP : ideal.is_prime R) : IsField R ",
      "theorem is_field_of_finite_prime{R : Type u} [CommRingₓₓ R] (hfin : Fintypeₓ R) (hP : ideal.is_prime R) : IsField R ",
      "theorem is_field_of_finite_prime{R : Type u} [CommRingₓ R] (hfin : Fintypeₓ R) (hP : ideal.is_prime R) : IsField R ",
      "theorem ideal.prime_of_finite_implies_maximal{R : Type u_1} [CommRing R] [Fintype R] {I : Ideal R} (hip : I.is_prime) : I.is_maximal ",
      "theorem ideal.prime_of_finite_implies_maximal{R : Type u_1} [CommRingₓₓ R] [Fintype R] {I : Ideal R} (hip : I.is_prime) : I.is_maximal ",
      "theorem ideal.prime_of_finite_implies_maximal{R : Type u_1} [CommRingₓ R] [Fintype R] {I : Ideal R} (hip : I.is_prime) : I.is_maximal ",
      "theorem ideal.prime_of_finite_implies_maximal{R : Type u_1} [CommRing R] [Fintypeₓ R] {I : Ideal R} (hip : I.is_prime) : I.is_maximal ",
      "theorem ideal.prime_of_finite_implies_maximal{R : Type u_1} [CommRingₓₓ R] [Fintypeₓ R] {I : Ideal R} (hip : I.is_prime) : I.is_maximal ",
      "theorem ideal.prime_of_finite_implies_maximal{R : Type u_1} [CommRingₓ R] [Fintypeₓ R] {I : Ideal R} (hip : I.is_prime) : I.is_maximal ",
      "theorem finite_comm_ring.is_field_of_no_prime : ∀ (α : Type u_1) (finite_comm_ring : finite_comm_ring α), ¬∃ (p : Ideal α), p.is_prime → IsField α "
    ],
    "answer": "theorem finite_ring_prime_implies_maximal {R : Type _} [CommRingₓ R] [Fintype R] : ∀ (Idl : Ideal R), Idl.IsPrime → Idl.IsMaximal "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "finite_ring_prime_implies_maximal",
      "main_prompt": "In a finite commutative ring, all prime ideals are maximal.",
      "prompt": "Natural language version: \"In a finite commutative ring, all prime ideals are maximal.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 8.42631383400294,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem nonzero_of_finite_comm_ring_of_prime_is_maximal ( R : Type ) [ CommRing R ] [ Fintype R ] :    ∀ p : prime_ideal R, p.maximal ",
      "theorem nonzero_of_finite_comm_ring_of_prime_is_maximal ( R : Type ) [ CommRingₓₓ R ] [ Fintype R ] :    ∀ p : prime_ideal R, p.maximal ",
      "theorem nonzero_of_finite_comm_ring_of_prime_is_maximal ( R : Type ) [ CommRingₓ R ] [ Fintype R ] :    ∀ p : prime_ideal R, p.maximal ",
      "theorem nonzero_of_finite_comm_ring_of_prime_is_maximal ( R : Type ) [ CommRing R ] [ Fintypeₓ R ] :    ∀ p : prime_ideal R, p.maximal ",
      "theorem nonzero_of_finite_comm_ring_of_prime_is_maximal ( R : Type ) [ CommRingₓₓ R ] [ Fintypeₓ R ] :    ∀ p : prime_ideal R, p.maximal ",
      "theorem nonzero_of_finite_comm_ring_of_prime_is_maximal ( R : Type ) [ CommRingₓ R ] [ Fintypeₓ R ] :    ∀ p : prime_ideal R, p.maximal ",
      "theorem fcring_is_pid (X : Type) [Ring X] : is_prime_ideal (ideal.univ X) ",
      "theorem fcring_is_pid (X : Type) [Ringₓₓ X] : is_prime_ideal (ideal.univ X) ",
      "theorem fcring_is_pid (X : Type) [Ringₓ X] : is_prime_ideal (ideal.univ X) ",
      "theorem finite_rings_have_maximal_prime_ideals (R : Type*) [CommRing R] [Fintype R] ... ",
      "theorem finite_rings_have_maximal_prime_ideals (R : Type*) [CommRingₓₓ R] [Fintype R] ... ",
      "theorem finite_rings_have_maximal_prime_ideals (R : Type*) [CommRingₓ R] [Fintype R] ... ",
      "theorem finite_rings_have_maximal_prime_ideals (R : Type*) [CommRing R] [Fintypeₓ R] ... ",
      "theorem finite_rings_have_maximal_prime_ideals (R : Type*) [CommRingₓₓ R] [Fintypeₓ R] ... ",
      "theorem finite_rings_have_maximal_prime_ideals (R : Type*) [CommRingₓ R] [Fintypeₓ R] ... ",
      "theorem finite_comm_ring_has_only_max_primes ( R ): Prop ",
      "theorem ring_finite.maximal_of_prime {R : Type*} [CommRing R] [FiniteDimensional R] (p : prime_ideal R) : p.is_maximal  end subsection *}  namespace ring_finite  section variables {α : Type*} [Field α] [FiniteDimensional α]  /-- Dim of a Vector space is either 0 or 1. -/ lemma dim_eq_0_or_1 (V : Type*) [AddCommGroup V] [Module α V] :   α →* V ≃ₗ[α] (0 : Submodule α",
      "theorem ring_finite.maximal_of_prime {R : Type*} [CommRing R] [FiniteDimensional R] (p : prime_ideal R) : p.is_maximal  end subsection *}  namespace ring_finite  section variables {α : Type*} [Field α] [FiniteDimensional α]  /-- Dim of a Vector space is either 0 or 1. -/ lemma dim_eq_0_or_1 (V : Type*) [AddCommGroupₓₓ V] [Module α V] :   α →* V ≃ₗ[α] (0 : Submodule α",
      "theorem ring_finite.maximal_of_prime {R : Type*} [CommRingₓₓ R] [FiniteDimensional R] (p : prime_ideal R) : p.is_maximal  end subsection *}  namespace ring_finite  section variables {α : Type*} [Field α] [FiniteDimensional α]  /-- Dim of a Vector space is either 0 or 1. -/ lemma dim_eq_0_or_1 (V : Type*) [AddCommGroup V] [Module α V] :   α →* V ≃ₗ[α] (0 : Submodule α",
      "theorem ring_finite.maximal_of_prime {R : Type*} [CommRingₓₓ R] [FiniteDimensional R] (p : prime_ideal R) : p.is_maximal  end subsection *}  namespace ring_finite  section variables {α : Type*} [Field α] [FiniteDimensional α]  /-- Dim of a Vector space is either 0 or 1. -/ lemma dim_eq_0_or_1 (V : Type*) [AddCommGroupₓₓ V] [Module α V] :   α →* V ≃ₗ[α] (0 : Submodule α",
      "theorem ring_finite.maximal_of_prime {R : Type*} [CommRing R] [FiniteDimensional R] (p : prime_ideal R) : p.is_maximal  end subsection *}  namespace ring_finite  section variables {α : Type*} [Field α] [FiniteDimensional α]  /-- Dim of a Vector space is either 0 or 1. -/ lemma dim_eq_0_or_1 (V : Type*) [AddCommGroupₓ V] [Module α V] :   α →* V ≃ₗ[α] (0 : Submodule α",
      "theorem ring_finite.maximal_of_prime {R : Type*} [CommRingₓₓ R] [FiniteDimensional R] (p : prime_ideal R) : p.is_maximal  end subsection *}  namespace ring_finite  section variables {α : Type*} [Field α] [FiniteDimensional α]  /-- Dim of a Vector space is either 0 or 1. -/ lemma dim_eq_0_or_1 (V : Type*) [AddCommGroupₓ V] [Module α V] :   α →* V ≃ₗ[α] (0 : Submodule α",
      "theorem ring_finite.maximal_of_prime {R : Type*} [CommRingₓ R] [FiniteDimensional R] (p : prime_ideal R) : p.is_maximal  end subsection *}  namespace ring_finite  section variables {α : Type*} [Field α] [FiniteDimensional α]  /-- Dim of a Vector space is either 0 or 1. -/ lemma dim_eq_0_or_1 (V : Type*) [AddCommGroup V] [Module α V] :   α →* V ≃ₗ[α] (0 : Submodule α",
      "theorem ring_finite.maximal_of_prime {R : Type*} [CommRingₓ R] [FiniteDimensional R] (p : prime_ideal R) : p.is_maximal  end subsection *}  namespace ring_finite  section variables {α : Type*} [Field α] [FiniteDimensional α]  /-- Dim of a Vector space is either 0 or 1. -/ lemma dim_eq_0_or_1 (V : Type*) [AddCommGroupₓₓ V] [Module α V] :   α →* V ≃ₗ[α] (0 : Submodule α",
      "theorem ring_finite.maximal_of_prime {R : Type*} [CommRingₓ R] [FiniteDimensional R] (p : prime_ideal R) : p.is_maximal  end subsection *}  namespace ring_finite  section variables {α : Type*} [Field α] [FiniteDimensional α]  /-- Dim of a Vector space is either 0 or 1. -/ lemma dim_eq_0_or_1 (V : Type*) [AddCommGroupₓ V] [Module α V] :   α →* V ≃ₗ[α] (0 : Submodule α"
    ],
    "answer": "theorem finite_ring_prime_implies_maximal {R : Type _} [CommRingₓ R] [Fintype R] : ∀ (Idl : Ideal R), Idl.IsPrime → Idl.IsMaximal "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "hausdorff_iff_diag_closed",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.",
      "codex_time": 6.140594590979163,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem hausdorff_iff_diagonal_closed (X : Type*) [TopologicalSpace X] :  @IsClosed _ _ (Prod.topologicalSpace X X) (diagonal_rel.set X) ↔ hausdorff_space X ",
      "theorem hausdorff_iff_close_prod_diagonal (X : Type*) [TopologicalSpace X] :  hausdorff X ↔ IsClosed ({p : X × X | p.1 = p.2}) ",
      "theorem closed_iff_hausdorff (X : Type*) [TopologicalSpace X] :  ∀ U : Set X × X, IsClosed U ↔ ∀ x : X, ∃ V W : Set X,  IsOpen V ∧ IsOpen W ∧ x ∈ V ∧ x ∈ W ∧ Disjoint V W ",
      "theorem closed_iff_hausdorff (X : Type*) [TopologicalSpace X] :  ∀ U : Setₓ X × X, IsClosed U ↔ ∀ x : X, ∃ V W : Setₓ X,  IsOpen V ∧ IsOpen W ∧ x ∈ V ∧ x ∈ W ∧ Disjoint V W ",
      "theorem hausdorff_eq_closed_diagonal (X : Type*) [T : TopologicalSpace X] :  T.hausdorff ↔ IsClosed {p : X × X | p.1 = p.2} ",
      "theorem hausdorff_iff_closed_diagonal (X : Type*) [TopologicalSpace X] :   @is_separated_space X X (submodule.subtype_val (submodule.top _ _))   ↔ IsClosed (submodule.subtype_val (submodule.top _ _)) "
    ],
    "answer": "theorem hausdorff_iff_diag_closed {X : Type _} [TopologicalSpace X] : T2Space X ↔ IsClosed (Set.Diagonal X) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "hausdorff_iff_diag_closed",
      "main_prompt": "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.",
      "prompt": "Natural language version: \"The Hausdorff edistance between sets or their closures is the same\" Translate the natural language version to a Lean mathlib version:\n theorem emetric.Hausdorff_edist_closure{α : Type u} [pseudo_emetric_space α] {s t : set α} :\nemetric.Hausdorff_edist (closure s) (closure t) = emetric.Hausdorff_edist s t := \n\nNatural language version: \"Two closed sets are at zero Hausdorff distance if and only if they coincide\" Translate the natural language version to a Lean mathlib version:\n theorem is_closed.Hausdorff_dist_zero_iff_eq{α : Type u} [pseudo_metric_space α] {s t : set α} (hs : is_closed s) (ht : is_closed t) (fin : emetric.Hausdorff_edist s t ≠ ⊤) :\nmetric.Hausdorff_dist s t = 0 ↔ s = t := \n\nNatural language version: \"Two closed sets are at zero Hausdorff edistance if and only if they coincide\" Translate the natural language version to a Lean mathlib version:\n theorem emetric.Hausdorff_edist_zero_iff_eq_of_closed{α : Type u} [pseudo_emetric_space α] {s t : set α} (hs : is_closed s) (ht : is_closed t) :\nemetric.Hausdorff_edist s t = 0 ↔ s = t := \n\nNatural language version: \"Replacing a set by its closure does not change the Hausdorff edistance.\" Translate the natural language version to a Lean mathlib version:\n theorem emetric.Hausdorff_edist_closure₂{α : Type u} [pseudo_emetric_space α] {s t : set α} :\nemetric.Hausdorff_edist s (closure t) = emetric.Hausdorff_edist s t := \n\nNatural language version: \"A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5625295639038086,
          "doc_string": "The Hausdorff edistance between sets or their closures is the same",
          "statement": "theorem emetric.Hausdorff_edist_closure {α : Type u} [pseudo_emetric_space α] {s t : set α} : emetric.Hausdorff_edist (closure s) (closure t) = emetric.Hausdorff_edist s t"
        },
        {
          "sim_score": 0.5602964162826538,
          "doc_string": "Two closed sets are at zero Hausdorff distance if and only if they coincide",
          "statement": "theorem is_closed.Hausdorff_dist_zero_iff_eq {α : Type u} [pseudo_metric_space α] {s t : set α} (hs : is_closed s) (ht : is_closed t) (fin : emetric.Hausdorff_edist s t ≠ ⊤) : metric.Hausdorff_dist s t = 0 ↔ s = t"
        },
        {
          "sim_score": 0.5491901636123657,
          "doc_string": "Two closed sets are at zero Hausdorff edistance if and only if they coincide",
          "statement": "theorem emetric.Hausdorff_edist_zero_iff_eq_of_closed {α : Type u} [pseudo_emetric_space α] {s t : set α} (hs : is_closed s) (ht : is_closed t) : emetric.Hausdorff_edist s t = 0 ↔ s = t"
        },
        {
          "sim_score": 0.5290781259536743,
          "doc_string": "Replacing a set by its closure does not change the Hausdorff edistance.",
          "statement": "theorem emetric.Hausdorff_edist_closure₂ {α : Type u} [pseudo_emetric_space α] {s t : set α} : emetric.Hausdorff_edist s (closure t) = emetric.Hausdorff_edist s t"
        }
      ],
      "codex_time": 4.811419643985573,
      "search_time": 1.4491934010002296,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem Hausdorff_iff_diagonal_subset_closed{α : Type u} [TopologicalSpace α] : Hausdorff α ↔ IsClosed (Subtype.val '' {p:α × α | p.1 = p.2}) ",
      "theorem Hausdorff_iff_diagonal_mem_closed {α : Type*} [TopologicalSpace α] : Hausdorff α ↔ Closure ({p : α × α | p.1 = p.2}) = univ (subtype.val_subtype) ",
      "theorem Hausdorff_iff_is_closed_diagonal{α : Type u} [TopologicalSpace α] : IsClosed $ set.prod Set.Univ Set.Univ ",
      "theorem Hausdorff_iff_is_closed_diagonal{α : Type u} [TopologicalSpace α] : IsClosed $ set.prod Setₓ.Univ Setₓ.Univ ",
      "theorem is_closed_Hausdorff_singleton {α : Type u} [t : TopologicalSpace α] : IsClosedMap (@singleton α (α × α)) ↔ t.is_Hausdorff ",
      "theorem is_closed.Hausdorff_iff_diag_closed{α : Type u} [TopologicalSpace α] : IsClosed (set.diag α) ↔ is_Hausdorff α "
    ],
    "answer": "theorem hausdorff_iff_diag_closed {X : Type _} [TopologicalSpace X] : T2Space X ↔ IsClosed (Set.Diagonal X) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "hausdorff_iff_diag_closed",
      "main_prompt": "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.",
      "prompt": "Natural language version: \"A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 12.712473966006655,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem Hausdorff_iff_closed_diagonal : Hausdorff X ↔ ∀ x : X, { x } ⊆ D ",
      "theorem diag_is_closed_iff_topological_space_is_Hausdorff (X : Type) [TopologicalSpace X] :   (∀ U : Set X × X, IsOpen U → Prod.fst U = univ → Prod.snd U = univ → False) ↔ is_Hausdorff X ",
      "theorem diag_is_closed_iff_topological_space_is_Hausdorff (X : Type) [TopologicalSpace X] :   (∀ U : Setₓ X × X, IsOpen U → Prod.fst U = univ → Prod.snd U = univ → False) ↔ is_Hausdorff X ",
      "theorem left_is_right (X) (h : Hausdorff X) : IsClosed (diagonal X) ",
      "theorem Hausdorff_condition : (∀ a b : X, a ≠ b → ∃ U V : Set X, IsOpen U ∧ IsOpen V ∧ a ∈ U ∧ b ∈ V ∧ U ∩ V = ∅) ↔ (diagonal : Set (X × X)) ≤  Unique X",
      "theorem Hausdorff_condition : (∀ a b : X, a ≠ b → ∃ U V : Setₓ X, IsOpen U ∧ IsOpen V ∧ a ∈ U ∧ b ∈ V ∧ U ∩ V = ∅) ↔ (diagonal : Setₓ (X × X)) ≤  Unique X",
      "theorem hausdorff_iff_closed_diagonal :   \"hausdorff X ↔ IsClosed (set.prod.fst X = set.prod.snd X)\"  proof   assume \"hausdorff X\"   end hausdorff_iff_closed_diagonal  lemma closure_contains_mem_closure_eq {a : α} {s : Set α} :   mem_closure s a ≠ s a → mem_closure s a ",
      "theorem hausdorff_iff_closed_diagonal :   \"hausdorff X ↔ IsClosed (set.prod.fst X = set.prod.snd X)\"  proof   assume \"hausdorff X\"   end hausdorff_iff_closed_diagonal  lemma closure_contains_mem_closure_eq {a : α} {s : Setₓ α} :   mem_closure s a ≠ s a → mem_closure s a "
    ],
    "answer": "theorem hausdorff_iff_diag_closed {X : Type _} [TopologicalSpace X] : T2Space X ↔ IsClosed (Set.Diagonal X) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "open_iff_open_nhd_all_pt",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"If every point of a subset of a topological space is contained in some open set, the subset itself is open.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If every point of a subset of a topological space is contained in some open set, the subset itself is open.",
      "codex_time": 4.792443223996088,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem every_point_is_contained_in_open_set_is_open (X : Type*) [TopologicalSpace X]  (A : Set X) (hA : ∀ x ∈ A, ∃ U : Set X, IsOpen U ∧ x ∈ U):  IsOpen A ",
      "theorem every_point_is_contained_in_open_set_is_open (X : Type*) [TopologicalSpace X]  (A : Setₓ X) (hA : ∀ x ∈ A, ∃ U : Setₓ X, IsOpen U ∧ x ∈ U):  IsOpen A ",
      "theorem every_point_is_contained_in_some_open_set_implies_open (X : Type*) [TopologicalSpace X]  (A : Set X) (hA : ∀ a ∈ A, ∃ U : Set X, IsOpen U ∧ a ∈ U) : IsOpen A ",
      "theorem every_point_is_contained_in_some_open_set_implies_open (X : Type*) [TopologicalSpace X]  (A : Setₓ X) (hA : ∀ a ∈ A, ∃ U : Setₓ X, IsOpen U ∧ a ∈ U) : IsOpen A ",
      "theorem subset_of_open_subset_is_open (X : Type*) [TopologicalSpace X]  (A : Set X) (hA : ∀ x ∈ A, ∃ U : Set X, IsOpen U ∧ x ∈ U ∧ U ⊆ A):  IsOpen A ",
      "theorem subset_of_open_subset_is_open (X : Type*) [TopologicalSpace X]  (A : Setₓ X) (hA : ∀ x ∈ A, ∃ U : Setₓ X, IsOpen U ∧ x ∈ U ∧ U ⊆ A):  IsOpen A ",
      "theorem subset_of_every_point_in_set_is_open (X : Type*) [TopologicalSpace X]  (A : Set X) (hA : ∀ x ∈ A, ∃ U : Set X, IsOpen U ∧ x ∈ U):  IsOpen A ",
      "theorem subset_of_every_point_in_set_is_open (X : Type*) [TopologicalSpace X]  (A : Setₓ X) (hA : ∀ x ∈ A, ∃ U : Setₓ X, IsOpen U ∧ x ∈ U):  IsOpen A ",
      "theorem every_point_is_contained_in_open_then_set_itself_is_open (X : Type*) [TopologicalSpace X]  (A : Set X) (hA : ∀ (x : X), x ∈ A → ∃ U : Set X, IsOpen U ∧ x ∈ U):  IsOpen A ",
      "theorem every_point_is_contained_in_open_then_set_itself_is_open (X : Type*) [TopologicalSpace X]  (A : Setₓ X) (hA : ∀ (x : X), x ∈ A → ∃ U : Setₓ X, IsOpen U ∧ x ∈ U):  IsOpen A "
    ],
    "answer": "theorem open_iff_open_nhd_all_pt {X : Type _} [TopologicalSpace X] (S : Set X) : (∀ x ∈ S, ∃ U : Set X, IsOpen U) → IsOpen S "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "open_iff_open_nhd_all_pt",
      "main_prompt": "If every point of a subset of a topological space is contained in some open set, the subset itself is open.",
      "prompt": "Natural language version: \" A predicate is true in a neighborhood of `a` iff it is true for all the points in an open set containing `a`.\" Translate the natural language version to a Lean mathlib version:\n theorem eventually_nhds_iff{α : Type u} [topological_space α] {a : α} {p : α → Prop} :\n(∀ᶠ (x : α) in nhds a, p x) ↔ ∃ (t : set α), (∀ (x : α), x ∈ t → p x) ∧ is_open t ∧ a ∈ t := \n\nNatural language version: \"Given an open finite set `S` in a T₀ space, there is some `x ∈ S` such that `{x}` is open.\" Translate the natural language version to a Lean mathlib version:\n theorem exists_open_singleton_of_open_finite{α : Type u} [topological_space α] [t0_space α] {s : set α} (hfin : s.finite) (hne : s.nonempty) (ho : is_open s) :\n∃ (x : α) (H : x ∈ s), is_open {x} := \n\nNatural language version: \" If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s: it contains an open set containing `s`.\" Translate the natural language version to a Lean mathlib version:\n theorem exists_open_set_nhds'{α : Type u} [topological_space α] {s U : set α} (h : U ∈ ⨆ (x : α) (H : x ∈ s), nhds x) :\n∃ (V : set α), s ⊆ V ∧ is_open V ∧ V ⊆ U := \n\nNatural language version: \" If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`: it contains an open set containing `s`.\" Translate the natural language version to a Lean mathlib version:\n theorem exists_open_set_nhds{α : Type u} [topological_space α] {s U : set α} (h : ∀ (x : α), x ∈ s → U ∈ nhds x) :\n∃ (V : set α), s ⊆ V ∧ is_open V ∧ V ⊆ U := \n\nNatural language version: \"If every point of a subset of a topological space is contained in some open set, the subset itself is open.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.624941349029541,
          "doc_string": " A predicate is true in a neighborhood of `a` iff it is true for all the points in an open set containing `a`.",
          "statement": "theorem eventually_nhds_iff {α : Type u} [topological_space α] {a : α} {p : α → Prop} : (∀ᶠ (x : α) in nhds a, p x) ↔ ∃ (t : set α), (∀ (x : α), x ∈ t → p x) ∧ is_open t ∧ a ∈ t"
        },
        {
          "sim_score": 0.619118332862854,
          "doc_string": "Given an open finite set `S` in a T₀ space, there is some `x ∈ S` such that `{x}` is open.",
          "statement": "theorem exists_open_singleton_of_open_finite {α : Type u} [topological_space α] [t0_space α] {s : set α} (hfin : s.finite) (hne : s.nonempty) (ho : is_open s) : ∃ (x : α) (H : x ∈ s), is_open {x}"
        },
        {
          "sim_score": 0.6141307353973389,
          "doc_string": " If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s: it contains an open set containing `s`.",
          "statement": "theorem exists_open_set_nhds' {α : Type u} [topological_space α] {s U : set α} (h : U ∈ ⨆ (x : α) (H : x ∈ s), nhds x) : ∃ (V : set α), s ⊆ V ∧ is_open V ∧ V ⊆ U"
        },
        {
          "sim_score": 0.6101160645484924,
          "doc_string": " If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`: it contains an open set containing `s`.",
          "statement": "theorem exists_open_set_nhds {α : Type u} [topological_space α] {s U : set α} (h : ∀ (x : α), x ∈ s → U ∈ nhds x) : ∃ (V : set α), s ⊆ V ∧ is_open V ∧ V ⊆ U"
        }
      ],
      "codex_time": 10.69111048799823,
      "search_time": 1.4257859050121624,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem topological_space.of_forall_mem_open{α : Type u} [TopologicalSpace α]{s:Set α} (m:∀ (x : α), x ∈ s → ∃ (t:Set α), IsOpen t ∧ x ∈ t): IsOpen s ",
      "theorem topological_space.of_forall_mem_open{α : Type u} [TopologicalSpace α]{s:Setₓ α} (m:∀ (x : α), x ∈ s → ∃ (t:Setₓ α), IsOpen t ∧ x ∈ t): IsOpen s ",
      "theorem assumption_of_nhds_not_mem_nhds {α : Type u} [TopologicalSpace α] {x : α} (h : ∀ (a : Set α), a ∈ nhds x → a ≠ {x}) : ∃ (n : Set α), IsOpen n ∧ n ⊆ {x} ",
      "theorem assumption_of_nhds_not_mem_nhds {α : Type u} [TopologicalSpace α] {x : α} (h : ∀ (a : Setₓ α), a ∈ nhds x → a ≠ {x}) : ∃ (n : Setₓ α), IsOpen n ∧ n ⊆ {x} ",
      "theorem is_open_of_forall_mem_open{α : Type u} [TopologicalSpace α] {s : Set α} {U : Set α} (h : ∀ (x : α), x ∈ s → ∃ (V : Set α), IsOpen V ∧ V ⊆ U ∧ x ∈ V) (hp : U = ⋃₀ s) : IsOpen U ",
      "theorem is_open_of_forall_mem_open{α : Type u} [TopologicalSpace α] {s : Setₓ α} {U : Setₓ α} (h : ∀ (x : α), x ∈ s → ∃ (V : Setₓ α), IsOpen V ∧ V ⊆ U ∧ x ∈ V) (hp : U = ⋃₀ s) : IsOpen U ",
      "theorem is_open_iff_forall_mem_open_nhds{α : Type u} [TopologicalSpace α] {s : Set α} : IsOpen s ↔ ∀ (x : α), x ∈ s → ∃ (u : Set α), IsOpen u ∧ x ∈ u ∧ u ⊆ s ",
      "theorem is_open_iff_forall_mem_open_nhds{α : Type u} [TopologicalSpace α] {s : Setₓ α} : IsOpen s ↔ ∀ (x : α), x ∈ s → ∃ (u : Setₓ α), IsOpen u ∧ x ∈ u ∧ u ⊆ s ",
      "theorem mem_nhds_of_mem_nhds_within{α : Type u} [TopologicalSpace α] {s : Set α} {a : α} (h : ∀ (x : α), x ∈ s → ∃ (V : Set α), a ∈ V ∧ IsOpen V ∧ x ∈ V) : ∃ (V : Set α), a ∈ V ∧ IsOpen V ∧ s ⊆ V ",
      "theorem mem_nhds_of_mem_nhds_within{α : Type u} [TopologicalSpace α] {s : Setₓ α} {a : α} (h : ∀ (x : α), x ∈ s → ∃ (V : Setₓ α), a ∈ V ∧ IsOpen V ∧ x ∈ V) : ∃ (V : Setₓ α), a ∈ V ∧ IsOpen V ∧ s ⊆ V "
    ],
    "answer": "theorem open_iff_open_nhd_all_pt {X : Type _} [TopologicalSpace X] (S : Set X) : (∀ x ∈ S, ∃ U : Set X, IsOpen U) → IsOpen S "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "open_iff_open_nhd_all_pt",
      "main_prompt": "If every point of a subset of a topological space is contained in some open set, the subset itself is open.",
      "prompt": "Natural language version: \"If every point of a subset of a topological space is contained in some open set, the subset itself is open.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 7.097953535994748,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem subset_open_of_points_open {P} {x : P} (H : ∀ (x : P) , x ∈ open_set P) : open_set P ⊆ open_set P ",
      "theorem subset_open (h : ∀ x : X, x ∈ s → ∃ V : Type, ∃ u : V, x ∈ u ∧ u ∈ 𝒳) : s ∈ 𝒳 ",
      "theorem subset_open_iff_forall_mem_open {α : Type*} [t : TopologicalSpace α] {s : Set α} (hs : IsOpen s) : s ⊆ ⋃₀ open_sets ",
      "theorem subset_open_iff_forall_mem_open {α : Type*} [t : TopologicalSpace α] {s : Setₓ α} (hs : IsOpen s) : s ⊆ ⋃₀ open_sets ",
      "theorem subset_open {X : Type*} [TopologicalSpace X] {A B : Set X} (H : A ⊆ B) (H1 : ∀b, b ∈ B → ∃U, IsOpen U ∧ b ∈ U) : IsOpen A ",
      "theorem subset_open {X : Type*} [TopologicalSpace X] {A B : Setₓ X} (H : A ⊆ B) (H1 : ∀b, b ∈ B → ∃U, IsOpen U ∧ b ∈ U) : IsOpen A ",
      "theorem nlangversion {X:TopologicalSpace} (Y : Set X ) ( hl : Y ⊆ ∪ U , ∃ V , V ∈ U ∧ Y ⊆ V ):Y ∈ X . TopologicalSpace . IsOpen ",
      "theorem nlangversion {X:TopologicalSpace} (Y : Setₓ X ) ( hl : Y ⊆ ∪ U , ∃ V , V ∈ U ∧ Y ⊆ V ):Y ∈ X . TopologicalSpace . IsOpen "
    ],
    "answer": "theorem open_iff_open_nhd_all_pt {X : Type _} [TopologicalSpace X] (S : Set X) : (∀ x ∈ S, ∃ U : Set X, IsOpen U) → IsOpen S "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "complex_conj_prod_real",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"The product of a complex number with its conjugate is a real number.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The product of a complex number with its conjugate is a real number.",
      "codex_time": 3.7433156999759376,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem complex_conj_mult_real (x : ℂ) : (conjugate x) * x = x.re^2 + x.im^2 ",
      "theorem product_of_complex_with_its_conjugate (z : ℂ) : (z * conj z) ∈ ℝ ",
      "theorem prod_real_conj_real (z : ℂ) : z*conj z ∈ ℝ ",
      "theorem mul_conj_is_real :  ∀ z : ℂ, (z * z.conj).re = ∥z∥^2 ",
      "theorem conjugate_times_complex_is_real (x : ℂ) : x*conjugate x ∈ ℝ "
    ],
    "answer": "theorem complex_conj_prod_real : ∀ z : ℂ, ∃ r : ℝ, z * (starRingEnd ℂ $ z) = (r : ℂ) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "complex_conj_prod_real",
      "main_prompt": "The product of a complex number with its conjugate is a real number.",
      "prompt": "Natural language version: \"A complex number `z` plus its conjugate `conj z` is `2` times its real part.\" Translate the natural language version to a Lean mathlib version:\n theorem complex.re_eq_add_conj(z : ℂ) :\n↑(z.re) = (z + ⇑(star_ring_end ℂ) z) / 2 := \n\nNatural language version: \"A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part.\" Translate the natural language version to a Lean mathlib version:\n theorem complex.im_eq_sub_conj(z : ℂ) :\n↑(z.im) = (z - ⇑(star_ring_end ℂ) z) / (2 * complex.I) := \n\nNatural language version: \" A linear operator on a complex inner product space is self-adjoint precisely when `⟪T v, v⟫_ℂ` is real for all v.\" Translate the natural language version to a Lean mathlib version:\n theorem inner_product_space.is_self_adjoint_iff_inner_map_self_real{V : Type u_4} [inner_product_space ℂ V] (T : V →ₗ[ℂ] V) :\ninner_product_space.is_self_adjoint T ↔ ∀ (v : V), ⇑(star_ring_end ℂ) (has_inner.inner (⇑T v) v) = has_inner.inner (⇑T v) v := \n\nNatural language version: \"Polarization identity: The real part of the  inner product, in terms of the norm.\" Translate the natural language version to a Lean mathlib version:\n theorem re_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) :\n⇑is_R_or_C.re (has_inner.inner x y) = (∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ - ∥x - y∥ * ∥x - y∥) / 2 := \n\nNatural language version: \"The product of a complex number with its conjugate is a real number.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6665807962417603,
          "doc_string": "A complex number `z` plus its conjugate `conj z` is `2` times its real part.",
          "statement": "theorem complex.re_eq_add_conj (z : ℂ) : ↑(z.re) = (z + ⇑(star_ring_end ℂ) z) / 2"
        },
        {
          "sim_score": 0.6368286609649658,
          "doc_string": "A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part.",
          "statement": "theorem complex.im_eq_sub_conj (z : ℂ) : ↑(z.im) = (z - ⇑(star_ring_end ℂ) z) / (2 * complex.I)"
        },
        {
          "sim_score": 0.5591109395027161,
          "doc_string": " A linear operator on a complex inner product space is self-adjoint precisely when `⟪T v, v⟫_ℂ` is real for all v.",
          "statement": "theorem inner_product_space.is_self_adjoint_iff_inner_map_self_real {V : Type u_4} [inner_product_space ℂ V] (T : V →ₗ[ℂ] V) : inner_product_space.is_self_adjoint T ↔ ∀ (v : V), ⇑(star_ring_end ℂ) (has_inner.inner (⇑T v) v) = has_inner.inner (⇑T v) v"
        },
        {
          "sim_score": 0.48265978693962097,
          "doc_string": "Polarization identity: The real part of the  inner product, in terms of the norm.",
          "statement": "theorem re_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) : ⇑is_R_or_C.re (has_inner.inner x y) = (∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ - ∥x - y∥ * ∥x - y∥) / 2"
        }
      ],
      "codex_time": 9.362573266000254,
      "search_time": 1.4299217259977013,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem complex.is_real_elim(z : ℂ) : is_real_elim (z * conj z) ",
      "theorem complex.conj_mul_conj_eq_norm_squared (c : ℂ) :  Mul.mul ⇑(starRingEnd ℂ) c (Mul.mul ⇑(starRingEnd ℂ) c c) = ⇑(is_R_or_C.re c.re) ",
      "theorem is_R_or_C_rmul(x : ℂ) : is_R_or_C (⇑(starRingEnd ℂ) x * x) ",
      "theorem is_R_or_C.is_real_mul_conj(z : ℂ) : is_R_or_C.is_real (z * ⇑(starRingEnd ℂ) z) ",
      "theorem complex.star_prod_is_rel (c : ℂ) : ∣⇑(c * starRingEnd ℂ c)∣ = ⇑(abs (c * starRingEnd ℂ c)) "
    ],
    "answer": "theorem complex_conj_prod_real : ∀ z : ℂ, ∃ r : ℝ, z * (starRingEnd ℂ $ z) = (r : ℂ) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "complex_conj_prod_real",
      "main_prompt": "The product of a complex number with its conjugate is a real number.",
      "prompt": "Natural language version: \"The product of a complex number with its conjugate is a real number.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 10.245818525989307,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem product_conjugate (c : ℂ) : c * conj c = norm_sq c ",
      "theorem complex_Mul_conj {n : ℂ} (h : n.norm_sq = n * n.conj) : n * n.conj ∈ ℝ ",
      "theorem my_product_lemma :  ∀ (z : ℂ), z * conj z = (re z)^2 + (im z)^2 Example: ∀ (a b c : my_nat),  a + (b + c) = (a + b) + c theorem nat_add_three : ∀ (a b c : my_nat), a + (b + c) = (a + b) + c theorem nat_add_three : ∀ (a b c : my_nat), a + (b + c) = (a + b) + c  theorem One : ∀ (X : Type), Empty",
      "theorem conj_times_conj (z: ℂ) : z * z.conj = z.norm_sq From these, prove <code>theorem sqrt_abs_one_square (z: ℂ) :    z * z.conj = 1 → z * z = 1 ",
      "theorem my_thm2 (z : ℂ) : (z * complex.conj z).re = z.re * z.re + z.im * z.im "
    ],
    "answer": "theorem complex_conj_prod_real : ∀ z : ℂ, ∃ r : ℝ, z * (starRingEnd ℂ $ z) = (r : ℂ) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "non_id_implies_infinite_order",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every non-identity element of a free group is of infinite order.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every non-identity element of a free group is of infinite order.",
      "codex_time": 10.100909483007854,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem infinite_order_free_group_element (G : Type*) [Group G] (x : G)  (h : x ≠ 1) : ∀ n : ℕ, x ^ n ≠ 1 ",
      "theorem infinite_order_free_group_element (G : Type*) [Groupₓₓ G] (x : G)  (h : x ≠ 1) : ∀ n : ℕ, x ^ n ≠ 1 ",
      "theorem infinite_order_free_group_element (G : Type*) [Groupₓ G] (x : G)  (h : x ≠ 1) : ∀ n : ℕ, x ^ n ≠ 1 ",
      "theorem free_group_non_identity_element_infinite_order (G : Type*) [Group G]  [fg : IsFreeGroup G] (x : G) (hx : x ≠ 1) :  infinite_order x ",
      "theorem free_group_non_identity_element_infinite_order (G : Type*) [Groupₓₓ G]  [fg : IsFreeGroup G] (x : G) (hx : x ≠ 1) :  infinite_order x ",
      "theorem free_group_non_identity_element_infinite_order (G : Type*) [Groupₓ G]  [fg : IsFreeGroup G] (x : G) (hx : x ≠ 1) :  infinite_order x ",
      "theorem nonidentity_elements_of_free_group_are_of_infinite_order (n : ℕ) (g : FreeGroup n)  (hg : g ≠ 1) : ∀ m, g ^ m ≠ 1 ",
      "theorem non_id_of_free_group_has_infinite_order (G : Type*) [Group G] (h_free : FreeGroup G)  (g : G) (non_id_g : g ≠ 1) :  ∀ n : ℕ, g ~^ n ≠ 1 ",
      "theorem non_id_of_free_group_has_infinite_order (G : Type*) [Groupₓₓ G] (h_free : FreeGroup G)  (g : G) (non_id_g : g ≠ 1) :  ∀ n : ℕ, g ~^ n ≠ 1 ",
      "theorem non_id_of_free_group_has_infinite_order (G : Type*) [Groupₓ G] (h_free : FreeGroup G)  (g : G) (non_id_g : g ≠ 1) :  ∀ n : ℕ, g ~^ n ≠ 1 ",
      "theorem infinite_order_of_non_identity_element (F : Type*) [Group F]  [Fintype F] {x : F} (hF : Fintype.card F ≥ 2) (hx : x ≠ 1) :  ∀ n : ℕ, x ^ n ≠ 1 ",
      "theorem infinite_order_of_non_identity_element (F : Type*) [Groupₓₓ F]  [Fintype F] {x : F} (hF : Fintype.card F ≥ 2) (hx : x ≠ 1) :  ∀ n : ℕ, x ^ n ≠ 1 ",
      "theorem infinite_order_of_non_identity_element (F : Type*) [Groupₓ F]  [Fintype F] {x : F} (hF : Fintype.card F ≥ 2) (hx : x ≠ 1) :  ∀ n : ℕ, x ^ n ≠ 1 ",
      "theorem infinite_order_of_non_identity_element (F : Type*) [Group F]  [Fintypeₓ F] {x : F} (hF : Fintypeₓ.card F ≥ 2) (hx : x ≠ 1) :  ∀ n : ℕ, x ^ n ≠ 1 ",
      "theorem infinite_order_of_non_identity_element (F : Type*) [Groupₓₓ F]  [Fintypeₓ F] {x : F} (hF : Fintypeₓ.card F ≥ 2) (hx : x ≠ 1) :  ∀ n : ℕ, x ^ n ≠ 1 ",
      "theorem infinite_order_of_non_identity_element (F : Type*) [Groupₓ F]  [Fintypeₓ F] {x : F} (hF : Fintypeₓ.card F ≥ 2) (hx : x ≠ 1) :  ∀ n : ℕ, x ^ n ≠ 1 "
    ],
    "answer": "theorem non_id_implies_infinite_order {G : Type _} [Groupₓ G] : FreeGroup G → (∀ g : G, g ≠ 1 → orderOf g = 0) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "non_id_implies_infinite_order",
      "main_prompt": "Every non-identity element of a free group is of infinite order.",
      "prompt": "Natural language version: \" If two words correspond to the same element in the free group, then they have a common maximal reduction. This is the proof that the function that sends an element of the free group to its maximal reduction is well-defined.\" Translate the natural language version to a Lean mathlib version:\n theorem free_group.reduce.sound{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.mk L₁ = free_group.mk L₂) :\nfree_group.reduce L₁ = free_group.reduce L₂ := \n\nNatural language version: \"A group element has finite order iff its order is positive.\" Translate the natural language version to a Lean mathlib version:\n theorem order_of_pos_iff{G : Type u} {x : G} [monoid G] :\n0 < order_of x ↔ is_of_fin_order x := \n\nNatural language version: \"Inverses of elements of finite order have finite order.\" Translate the natural language version to a Lean mathlib version:\n theorem is_of_fin_order_inv_iff{G : Type u} [group G] {x : G} :\nis_of_fin_order x⁻¹ ↔ is_of_fin_order x := \n\nNatural language version: \"Inverses of elements of finite order have finite order.\" Translate the natural language version to a Lean mathlib version:\n theorem is_of_fin_order.inv{G : Type u} [group G] {x : G} (hx : is_of_fin_order x) :\nis_of_fin_order x⁻¹ := \n\nNatural language version: \"Every non-identity element of a free group is of infinite order.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5920776724815369,
          "doc_string": " If two words correspond to the same element in the free group, then they have a common maximal reduction. This is the proof that the function that sends an element of the free group to its maximal reduction is well-defined.",
          "statement": "theorem free_group.reduce.sound {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.mk L₁ = free_group.mk L₂) : free_group.reduce L₁ = free_group.reduce L₂"
        },
        {
          "sim_score": 0.5908461809158325,
          "doc_string": "A group element has finite order iff its order is positive.",
          "statement": "theorem order_of_pos_iff {G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x"
        },
        {
          "sim_score": 0.5742547512054443,
          "doc_string": "Inverses of elements of finite order have finite order.",
          "statement": "theorem is_of_fin_order_inv_iff {G : Type u} [group G] {x : G} : is_of_fin_order x⁻¹ ↔ is_of_fin_order x"
        },
        {
          "sim_score": 0.5742547512054443,
          "doc_string": "Inverses of elements of finite order have finite order.",
          "statement": "theorem is_of_fin_order.inv {G : Type u} [group G] {x : G} (hx : is_of_fin_order x) : is_of_fin_order x⁻¹"
        }
      ],
      "codex_time": 8.806428215000778,
      "search_time": 1.4412528529937845,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem free_group.is_of_fin_order.neg{α : Type u}  (x : FreeGroup α) : IsOfFinOrder x ↔ x = 1 ",
      "theorem order_of_ne_one_of_inf_order_free_group{α : Type u} {g : FreeGroup α} (hg : g ≠ 1) : ∃ (N : ℕ), ∀ n, n ≥ N → g ^ n ≠ 1 ",
      "theorem free_group.is_of_fin_order {α : Type u} [DecidableEq α] {s : FreeGroup α} (H : s ≠ 1) :   ¬ IsOfFinOrder s ",
      "theorem is_of_fin_order_iff_one_of_free_group{α : Type u} {L : List (α × Bool)} [DecidableEq α] : IsOfFinOrder (FreeGroup.mk L) ↔ L = [] ",
      "theorem free_group.forall_mem_ne'"
    ],
    "answer": "theorem non_id_implies_infinite_order {G : Type _} [Groupₓ G] : FreeGroup G → (∀ g : G, g ≠ 1 → orderOf g = 0) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "non_id_implies_infinite_order",
      "main_prompt": "Every non-identity element of a free group is of infinite order.",
      "prompt": "Natural language version: \"Every non-identity element of a free group is of infinite order.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 7.699175054003717,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem free_group.nni_elem.left_not_inv_cancel_of_eq_pow_self_of_total_order_neg {G : Type*} [FreeGroup G] (n : ℕ) (H : ∀ x, x ≠ 1 → pnat.total_order (λ x : ℕ, (x:G) * n * x⁻¹) n)       {x : G} (H1 : x ≠ 1) (H2 : ∃ i : ℕ, x * i * x⁻¹ = n) :         ∃ (i : ℕ), x *",
      "theorem no_finite_order_nontrivial_free_group_elem (G : Group) {a : G} (h : a ≠ 1) : ¬ (order a < ∞) ",
      "theorem no_finite_order_nontrivial_free_group_elem (G : Groupₓₓ) {a : G} (h : a ≠ 1) : ¬ (order a < ∞) ",
      "theorem no_finite_order_nontrivial_free_group_elem (G : Groupₓ) {a : G} (h : a ≠ 1) : ¬ (order a < ∞) ",
      "theorem every_non_id_element_of_free_group_is_of_infinite_order {G : Type*} [Group G] (H : ∃ (g : G), g ≠ 1) : ∀ g : G, g ≠ 1 → ∀ n : ℕ, (g ^ n) ≠ 1 ",
      "theorem every_non_id_element_of_free_group_is_of_infinite_order {G : Type*} [Groupₓₓ G] (H : ∃ (g : G), g ≠ 1) : ∀ g : G, g ≠ 1 → ∀ n : ℕ, (g ^ n) ≠ 1 ",
      "theorem every_non_id_element_of_free_group_is_of_infinite_order {G : Type*} [Groupₓ G] (H : ∃ (g : G), g ≠ 1) : ∀ g : G, g ≠ 1 → ∀ n : ℕ, (g ^ n) ≠ 1 ",
      "theorem Infinite . order_of_elements_of_free_group ( F : FreeGroup G ) ( x : F . generated_group )  ( L : x ≠ 1 ) : ∞ = card ( Quotient . mk x : Set F . generated_group ) ",
      "theorem Infinite . order_of_elements_of_free_group ( F : FreeGroup G ) ( x : F . generated_group )  ( L : x ≠ 1 ) : ∞ = card ( Quotient . mk x : Setₓ F . generated_group ) ",
      "theorem Infinite . order_of_elements_of_free_group ( F : FreeGroup G ) ( x : F . generated_group )  ( L : x ≠ 1 ) : ∞ = card ( Quotientₓ . mk x : Set F . generated_group ) ",
      "theorem Infinite . order_of_elements_of_free_group ( F : FreeGroup G ) ( x : F . generated_group )  ( L : x ≠ 1 ) : ∞ = card ( Quotientₓ . mk x : Setₓ F . generated_group ) ",
      "theorem infinite_order_of_free_group (F : Type*) [Group F] [IsFreeGroup F] (a : F) : ¬IsUnit a → ∀ n : ℕ, ∃ x : ℤ, n = x   Are there other theorems in mathlib that are similar to this One? Yes: it is a simplified version of the theorem   lattice.inf_bot  Evaluate \"infinite_order_of_free_group G a h\".   It fails:   Failed to synthesize type class instance for     sorry Prove it using the proof method \"sorry\", then the current tactics will prove it for you",
      "theorem infinite_order_of_free_group (F : Type*) [Groupₓₓ F] [IsFreeGroup F] (a : F) : ¬IsUnit a → ∀ n : ℕ, ∃ x : ℤ, n = x   Are there other theorems in mathlib that are similar to this One? Yes: it is a simplified version of the theorem   lattice.inf_bot  Evaluate \"infinite_order_of_free_group G a h\".   It fails:   Failed to synthesize type class instance for     sorry Prove it using the proof method \"sorry\", then the current tactics will prove it for you",
      "theorem infinite_order_of_free_group (F : Type*) [Groupₓ F] [IsFreeGroup F] (a : F) : ¬IsUnit a → ∀ n : ℕ, ∃ x : ℤ, n = x   Are there other theorems in mathlib that are similar to this One? Yes: it is a simplified version of the theorem   lattice.inf_bot  Evaluate \"infinite_order_of_free_group G a h\".   It fails:   Failed to synthesize type class instance for     sorry Prove it using the proof method \"sorry\", then the current tactics will prove it for you"
    ],
    "answer": "theorem non_id_implies_infinite_order {G : Type _} [Groupₓ G] : FreeGroup G → (∀ g : G, g ≠ 1 → orderOf g = 0) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "sub_ring_field_with_id_is_int_domain",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Any sub-ring of a field that contains the identity is an integral domain\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Any sub-ring of a field that contains the identity is an integral domain",
      "codex_time": 14.453089719987474,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem any_subring_of_field_containing_one_is_integral_domain (R : Type*)  [Ring R] [Field R] (S : Set R) (One : R) (subset : S ⊆ R) (one_in_S : One ∈ S)  (Subring : is_subring S) :  integral_domain S ",
      "theorem any_subring_of_field_containing_one_is_integral_domain (R : Type*)  [Ringₓₓ R] [Field R] (S : Set R) (One : R) (subset : S ⊆ R) (one_in_S : One ∈ S)  (Subring : is_subring S) :  integral_domain S ",
      "theorem any_subring_of_field_containing_one_is_integral_domain (R : Type*)  [Ring R] [Field R] (S : Setₓ R) (One : R) (subset : S ⊆ R) (one_in_S : One ∈ S)  (Subring : is_subring S) :  integral_domain S ",
      "theorem any_subring_of_field_containing_one_is_integral_domain (R : Type*)  [Ringₓₓ R] [Field R] (S : Setₓ R) (One : R) (subset : S ⊆ R) (one_in_S : One ∈ S)  (Subring : is_subring S) :  integral_domain S ",
      "theorem any_subring_of_field_containing_one_is_integral_domain (R : Type*)  [Ringₓ R] [Field R] (S : Set R) (One : R) (subset : S ⊆ R) (one_in_S : One ∈ S)  (Subring : is_subring S) :  integral_domain S ",
      "theorem any_subring_of_field_containing_one_is_integral_domain (R : Type*)  [Ringₓ R] [Field R] (S : Setₓ R) (One : R) (subset : S ⊆ R) (one_in_S : One ∈ S)  (Subring : is_subring S) :  integral_domain S ",
      "theorem integral_domain_of_subfield_of_unit (α : Type*) [integral_domain α] (S : Set α)  [is_subring S] (hs : ({(1 : α)} ⊆ S) ∧ ∀ x y ∈ S, x * y ∈ S) : integral_domain S ",
      "theorem integral_domain_of_subfield_of_unit (α : Type*) [integral_domain α] (S : Setₓ α)  [is_subring S] (hs : ({(1 : α)} ⊆ S) ∧ ∀ x y ∈ S, x * y ∈ S) : integral_domain S ",
      "theorem subring_of_field_contains_identity_is_integral_domain (R : Type*) [Ring R] [Field R]  (A : Set R)  (hA_is_subring : is_subring A)  (hA_contains_identity : 1 ∈ A) :  integral_domain A Natural language version: \"If CD = AB and A is an injective function, then either CD = BD or CD = AD.\" Translate the natural language version to a Lean mathlib version:  theorem AB_eq_CD_and_A_injective_impl_CD_eq_BD_or_CD_eq_AD (",
      "theorem subring_of_field_contains_identity_is_integral_domain (R : Type*) [Ringₓₓ R] [Field R]  (A : Set R)  (hA_is_subring : is_subring A)  (hA_contains_identity : 1 ∈ A) :  integral_domain A Natural language version: \"If CD = AB and A is an injective function, then either CD = BD or CD = AD.\" Translate the natural language version to a Lean mathlib version:  theorem AB_eq_CD_and_A_injective_impl_CD_eq_BD_or_CD_eq_AD (",
      "theorem subring_of_field_contains_identity_is_integral_domain (R : Type*) [Ring R] [Field R]  (A : Setₓ R)  (hA_is_subring : is_subring A)  (hA_contains_identity : 1 ∈ A) :  integral_domain A Natural language version: \"If CD = AB and A is an injective function, then either CD = BD or CD = AD.\" Translate the natural language version to a Lean mathlib version:  theorem AB_eq_CD_and_A_injective_impl_CD_eq_BD_or_CD_eq_AD (",
      "theorem subring_of_field_contains_identity_is_integral_domain (R : Type*) [Ringₓₓ R] [Field R]  (A : Setₓ R)  (hA_is_subring : is_subring A)  (hA_contains_identity : 1 ∈ A) :  integral_domain A Natural language version: \"If CD = AB and A is an injective function, then either CD = BD or CD = AD.\" Translate the natural language version to a Lean mathlib version:  theorem AB_eq_CD_and_A_injective_impl_CD_eq_BD_or_CD_eq_AD (",
      "theorem subring_of_field_contains_identity_is_integral_domain (R : Type*) [Ringₓ R] [Field R]  (A : Set R)  (hA_is_subring : is_subring A)  (hA_contains_identity : 1 ∈ A) :  integral_domain A Natural language version: \"If CD = AB and A is an injective function, then either CD = BD or CD = AD.\" Translate the natural language version to a Lean mathlib version:  theorem AB_eq_CD_and_A_injective_impl_CD_eq_BD_or_CD_eq_AD (",
      "theorem subring_of_field_contains_identity_is_integral_domain (R : Type*) [Ringₓ R] [Field R]  (A : Setₓ R)  (hA_is_subring : is_subring A)  (hA_contains_identity : 1 ∈ A) :  integral_domain A Natural language version: \"If CD = AB and A is an injective function, then either CD = BD or CD = AD.\" Translate the natural language version to a Lean mathlib version:  theorem AB_eq_CD_and_A_injective_impl_CD_eq_BD_or_CD_eq_AD (",
      "theorem subring_containing_1_of_field_is_integral_domain (R : Type*) [Ring R] [Field R] (RR : Type*) [Ring RR]  [is_subring R RR] (one_RR : (1 : R) ≠ 0) :  integral_domain RR ",
      "theorem subring_containing_1_of_field_is_integral_domain (R : Type*) [Ringₓₓ R] [Field R] (RR : Type*) [Ringₓₓ RR]  [is_subring R RR] (one_RR : (1 : R) ≠ 0) :  integral_domain RR ",
      "theorem subring_containing_1_of_field_is_integral_domain (R : Type*) [Ringₓ R] [Field R] (RR : Type*) [Ringₓ RR]  [is_subring R RR] (one_RR : (1 : R) ≠ 0) :  integral_domain RR ",
      "theorem subring_of_field_is_integral_domain {α : Type*} [integral_domain α] (R : Set α) [is_subring R]  (h1_in_R : (1 : α) ∈ R) :  integral_domain.to_domain R ",
      "theorem subring_of_field_is_integral_domain {α : Type*} [integral_domain α] (R : Setₓ α) [is_subring R]  (h1_in_R : (1 : α) ∈ R) :  integral_domain.to_domain R "
    ],
    "answer": "theorem sub_ring_field_with_id_is_int_domain {F : Type _} [Field F] : ∀ R : Subring F, 1 ∈ R.Carrier → IsDomain ↥R "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "sub_ring_field_with_id_is_int_domain",
      "main_prompt": "Any sub-ring of a field that contains the identity is an integral domain",
      "prompt": "Natural language version: \"A subfield is closed under inverses.\" Translate the natural language version to a Lean mathlib version:\n theorem subfield.inv_mem{K : Type u} [field K] (s : subfield K) {x : K} :\nx ∈ s → x⁻¹ ∈ s := \n\nNatural language version: \"A subring contains the ring's 1.\" Translate the natural language version to a Lean mathlib version:\n theorem subring.one_mem{R : Type u} [ring R] (s : subring R) :\n1 ∈ s := \n\nNatural language version: \"A subring contains the ring's 0.\" Translate the natural language version to a Lean mathlib version:\n theorem subring.zero_mem{R : Type u} [ring R] (s : subring R) :\n0 ∈ s := \n\nNatural language version: \"A subfield is closed under division.\" Translate the natural language version to a Lean mathlib version:\n theorem subfield.div_mem{K : Type u} [field K] (s : subfield K) {x y : K} :\nx ∈ s → y ∈ s → x / y ∈ s := \n\nNatural language version: \"Any sub-ring of a field that contains the identity is an integral domain\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6670852899551392,
          "doc_string": "A subfield is closed under inverses.",
          "statement": "theorem subfield.inv_mem {K : Type u} [field K] (s : subfield K) {x : K} : x ∈ s → x⁻¹ ∈ s"
        },
        {
          "sim_score": 0.6393297910690308,
          "doc_string": "A subring contains the ring's 1.",
          "statement": "theorem subring.one_mem {R : Type u} [ring R] (s : subring R) : 1 ∈ s"
        },
        {
          "sim_score": 0.6295010447502136,
          "doc_string": "A subring contains the ring's 0.",
          "statement": "theorem subring.zero_mem {R : Type u} [ring R] (s : subring R) : 0 ∈ s"
        },
        {
          "sim_score": 0.6208624243736267,
          "doc_string": "A subfield is closed under division.",
          "statement": "theorem subfield.div_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x / y ∈ s"
        }
      ],
      "codex_time": 5.314992551022442,
      "search_time": 1.43123984101112,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem is_domain_of_subfield {R : Type} (s : Subfield R) : is_integral_domain s.carrier ",
      "theorem subring.id.int_dom {K : Type u} [Field K] (s : Subring K) (h : 1 ∈ s) : integral_domain (Subtype.val ∘ s) ",
      "theorem subring_of_field_contains_one_is_integral_domain{K : Type u} [Field K] (s : Subring K) (one_mem : 1 ∈ s) : integral_domain s ",
      "theorem subring_of_field.one_eq_zero{K : Type u}[Field K] (s : Subring K)(Zero : 0 ∈ s)(One : 1 ∈ s) {x : K}: (x ∈ s) ∧ (x = 0) ",
      "theorem subfield.is_integral_domain{F : Type u} [Field F]  (s : Subfield F) (hi : 1 ∈ s) : integral_domain s "
    ],
    "answer": "theorem sub_ring_field_with_id_is_int_domain {F : Type _} [Field F] : ∀ R : Subring F, 1 ∈ R.Carrier → IsDomain ↥R "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "sub_ring_field_with_id_is_int_domain",
      "main_prompt": "Any sub-ring of a field that contains the identity is an integral domain",
      "prompt": "Natural language version: \"Any sub-ring of a field that contains the identity is an integral domain\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 12.023270962003153,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem is_integral_domain_of_integral_domain_of_contains_id {α : Type u} [integral_domain α] (S : Set α) (h : (1:α) ∈ S) : integral_domain S ",
      "theorem is_integral_domain_of_integral_domain_of_contains_id {α : Type u} [integral_domain α] (S : Setₓ α) (h : (1:α) ∈ S) : integral_domain S ",
      "theorem field_of_integral_domain ( R : Type ) [ integral_domain R ] [ is_field_hom ( mk R )] : Field R |`. i : integral_domain R ",
      "theorem of def_domain. The salient point here is that we want to create a variable that has a \"definition by  recursion\" over the Ring axioms. To do that, we need to use the binders of our Ring type.   We'll use `int_quotient_ring` for the Ring axioms and use a lambda to introduce the variable. We need to state that the Subring we're talking about contains 1, and the eliminator for `Subring` can help.  ```lean example : def_domain (int_quotient_ring _ _) ",
      "theorem of def_domain. The salient point here is that we want to create a variable that has a \"definition by  recursion\" over the Ringₓₓ axioms. To do that, we need to use the binders of our Ringₓₓ type.   We'll use `int_quotient_ring` for the Ringₓₓ axioms and use a lambda to introduce the variable. We need to state that the Subring we're talking about contains 1, and the eliminator for `Subring` can help.  ```lean example : def_domain (int_quotient_ring _ _) ",
      "theorem of def_domain. The salient point here is that we want to create a variable that has a \"definition by  recursion\" over the Ringₓ axioms. To do that, we need to use the binders of our Ringₓ type.   We'll use `int_quotient_ring` for the Ringₓ axioms and use a lambda to introduce the variable. We need to state that the Subring we're talking about contains 1, and the eliminator for `Subring` can help.  ```lean example : def_domain (int_quotient_ring _ _) ",
      "theorem any_subring_of_field_is_domain (K : Type) [Field K] {A : Subring K} : IsDomain A ",
      "theorem sub_ring_is_integral : ∀ `{F : Field K} (S : Set K) (HS : algebra.subring S),   algebra.unit_of (1 : K) ∈ S → integral_domain S ",
      "theorem sub_ring_is_integral : ∀ `{F : Field K} (S : Setₓ K) (HS : algebra.subring S),   algebra.unit_of (1 : K) ∈ S → integral_domain S "
    ],
    "answer": "theorem sub_ring_field_with_id_is_int_domain {F : Type _} [Field F] : ∀ R : Subring F, 1 ∈ R.Carrier → IsDomain ↥R "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "dvr_unit_iff_val_zero",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.",
      "codex_time": 8.95798699799343,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem is_a_unit_discrete_valuation_ring (R : Type*) [integral_domain R] [DiscreteValuationRing R]  (v : R → ℕ) (val_multiplicative : ∀ a b ∈ R, v (a * b) = v a + v b)  (val_is_zero : ∀ x ∈ R\\{0}, v x ≠ 0 )  (x ∈ R\\{0}) :  x ∈ units R ↔ v x = 0 ",
      "theorem unit_iff_zero_val (R : Type*) [DiscreteValuationRing R] (a : R) :  a ∈ units R ↔ val a = 0 ",
      "theorem unit_iff_is_zero_of_discrete_valuation_ring (R : Type*) [DiscreteValuationRing R] (x : R) :  IsUnit x ↔ v R x = 0 ",
      "theorem dvr.is_unit_iff_val_eq_zero {R : Type*}  [CommRing R] [discrete_valued R] (x : R) :  IsUnit x ↔ is_zero (val x) ",
      "theorem dvr.is_unit_iff_val_eq_zero {R : Type*}  [CommRingₓₓ R] [discrete_valued R] (x : R) :  IsUnit x ↔ is_zero (val x) ",
      "theorem dvr.is_unit_iff_val_eq_zero {R : Type*}  [CommRingₓ R] [discrete_valued R] (x : R) :  IsUnit x ↔ is_zero (val x) ",
      "theorem val_two_if_unit_or_nonunit (R : Type*) [DiscreteValuationRing R] (x : R) :  val R x == 0 ↔ IsUnit R x ∨ x = 0 "
    ],
    "answer": "theorem dvr_unit_iff_val_zero {R : Type _} [CommRingₓ R] [IsDomain R] [DiscreteValuationRing R] : ∀ r : R, IsUnit r → DiscreteValuationRing.addVal R r = 0 "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "dvr_unit_iff_val_zero",
      "main_prompt": "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.",
      "prompt": "Natural language version: \"An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a discrete valuation ring.\" Translate the natural language version to a Lean mathlib version:\n theorem discrete_valuation_ring.of_has_unit_mul_pow_irreducible_factorization{R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) :\ndiscrete_valuation_ring R := \n\nNatural language version: \"A unique factorization domain with at least one irreducible element in which all irreducible elements are associated is a discrete valuation ring.\" Translate the natural language version to a Lean mathlib version:\n theorem discrete_valuation_ring.of_ufd_of_unique_irreducible{R : Type u} [comm_ring R] [is_domain R] [unique_factorization_monoid R] (h₁ : ∃ (p : R), irreducible p) (h₂ : ∀ ⦃p q : R⦄, irreducible p → irreducible q → associated p q) :\ndiscrete_valuation_ring R := \n\nNatural language version: \" If `𝒪` satisfies `v.integers 𝒪` where `v` is a valuation on a field, then `𝒪` is a valuation ring.\" Translate the natural language version to a Lean mathlib version:\n theorem valuation_ring.of_integers{𝒪 : Type u} {K : Type v} {Γ : Type w} [comm_ring 𝒪] [is_domain 𝒪] [field K] [algebra 𝒪 K] [linear_ordered_comm_group_with_zero Γ] (v : valuation K Γ) (hh : v.integers 𝒪) :\nvaluation_ring 𝒪 := \n\nNatural language version: \"Nonzero elements have nonzero adic valuation.\" Translate the natural language version to a Lean mathlib version:\n theorem is_dedekind_domain.height_one_spectrum.int_valuation_ne_zero{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x : R) (hx : x ≠ 0) :\nv.int_valuation_def x ≠ 0 := \n\nNatural language version: \"An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.7251311540603638,
          "doc_string": "An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a discrete valuation ring.",
          "statement": "theorem discrete_valuation_ring.of_has_unit_mul_pow_irreducible_factorization {R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) : discrete_valuation_ring R"
        },
        {
          "sim_score": 0.6923463344573975,
          "doc_string": "A unique factorization domain with at least one irreducible element in which all irreducible elements are associated is a discrete valuation ring.",
          "statement": "theorem discrete_valuation_ring.of_ufd_of_unique_irreducible {R : Type u} [comm_ring R] [is_domain R] [unique_factorization_monoid R] (h₁ : ∃ (p : R), irreducible p) (h₂ : ∀ ⦃p q : R⦄, irreducible p → irreducible q → associated p q) : discrete_valuation_ring R"
        },
        {
          "sim_score": 0.6915189623832703,
          "doc_string": " If `𝒪` satisfies `v.integers 𝒪` where `v` is a valuation on a field, then `𝒪` is a valuation ring.",
          "statement": "theorem valuation_ring.of_integers {𝒪 : Type u} {K : Type v} {Γ : Type w} [comm_ring 𝒪] [is_domain 𝒪] [field K] [algebra 𝒪 K] [linear_ordered_comm_group_with_zero Γ] (v : valuation K Γ) (hh : v.integers 𝒪) : valuation_ring 𝒪"
        },
        {
          "sim_score": 0.6845616698265076,
          "doc_string": "Nonzero elements have nonzero adic valuation.",
          "statement": "theorem is_dedekind_domain.height_one_spectrum.int_valuation_ne_zero {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x : R) (hx : x ≠ 0) : v.int_valuation_def x ≠ 0"
        }
      ],
      "codex_time": 8.07621061001555,
      "search_time": 1.431369549012743,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem discrete_valuation_ring.unit_iff_int_valuation_zero{R : Type u} [DiscreteValuationRing R] {x : R} : IsUnit x ↔ 0 = v.int_valuation_def x ",
      "theorem discrete_valuation_ring.units_int_valuation_eq_zero{R : Type u} [CommRing R] [DiscreteValuationRing R] {x : R} (hx : (x : units R)):  discrete_valuation_ring.int_valuation_def x = 0 ",
      "theorem discrete_valuation_ring.units_int_valuation_eq_zero{R : Type u} [CommRingₓₓ R] [DiscreteValuationRing R] {x : R} (hx : (x : units R)):  discrete_valuation_ring.int_valuation_def x = 0 ",
      "theorem discrete_valuation_ring.units_int_valuation_eq_zero{R : Type u} [CommRingₓ R] [DiscreteValuationRing R] {x : R} (hx : (x : units R)):  discrete_valuation_ring.int_valuation_def x = 0 ",
      "theorem discrete_valuation_ring.h0_units{R : Type u} [IsDomain R] (ur : DiscreteValuationRing R) : ∀ ⦃x : R⦄, x ∈ ur.units ↔ ur.valuation x = 0 ",
      "theorem discrete_valuation_ring.unit_iff{R : Type u} [CommRing R] [IsDomain R] [DiscreteValuationRing R] {p : R} : IsUnit p ↔ (((discrete_valuation_ring.integral_closure R) : Set R) p).valuation = 0 ",
      "theorem discrete_valuation_ring.unit_iff{R : Type u} [CommRingₓₓ R] [IsDomain R] [DiscreteValuationRing R] {p : R} : IsUnit p ↔ (((discrete_valuation_ring.integral_closure R) : Set R) p).valuation = 0 ",
      "theorem discrete_valuation_ring.unit_iff{R : Type u} [CommRing R] [IsDomain R] [DiscreteValuationRing R] {p : R} : IsUnit p ↔ (((discrete_valuation_ring.integral_closure R) : Setₓ R) p).valuation = 0 ",
      "theorem discrete_valuation_ring.unit_iff{R : Type u} [CommRingₓₓ R] [IsDomain R] [DiscreteValuationRing R] {p : R} : IsUnit p ↔ (((discrete_valuation_ring.integral_closure R) : Setₓ R) p).valuation = 0 ",
      "theorem discrete_valuation_ring.unit_iff{R : Type u} [CommRingₓ R] [IsDomain R] [DiscreteValuationRing R] {p : R} : IsUnit p ↔ (((discrete_valuation_ring.integral_closure R) : Set R) p).valuation = 0 ",
      "theorem discrete_valuation_ring.unit_iff{R : Type u} [CommRingₓ R] [IsDomain R] [DiscreteValuationRing R] {p : R} : IsUnit p ↔ (((discrete_valuation_ring.integral_closure R) : Setₓ R) p).valuation = 0 ",
      "theorem discrete_valuation_ring.units.eq_fin_of_ne_fin{R : Type u} [DiscreteValuationRing R] {r : R} (hr : r ≠ 0) (h : v r ≠ 0) : r ∈ units R "
    ],
    "answer": "theorem dvr_unit_iff_val_zero {R : Type _} [CommRingₓ R] [IsDomain R] [DiscreteValuationRing R] : ∀ r : R, IsUnit r → DiscreteValuationRing.addVal R r = 0 "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "dvr_unit_iff_val_zero",
      "main_prompt": "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.",
      "prompt": "Natural language version: \"An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 6.227731277991552,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem not_unit_of_val_ne_zero { R : Type * } [DiscreteValuationRing R] { p : R }    (h : val p <> 0 ) : ( ¬ IsUnit p ) ",
      "theorem is_unit_iff_valuation_zero (α : Type) [DiscreteValuationRing α] (x : α) :   IsUnit x ↔ Valuation x = 0 ",
      "theorem is_unit_of_val_zero_iff : ∀ a : R , a ∈ units R ↔ ( val a = 0 ) ",
      "theorem unit_iff_valuation_zero {R : Type}: ∀ (x : (discrete_val_ring R)), unit_of x ↔ Valuation R x = 0 ",
      "theorem unit_of_edvr_val_zero : ∀{K : Type} [edvr K] (x : K), Unit x ↔ (val x = 0) "
    ],
    "answer": "theorem dvr_unit_iff_val_zero {R : Type _} [CommRingₓ R] [IsDomain R] [DiscreteValuationRing R] : ∀ r : R, IsUnit r → DiscreteValuationRing.addVal R r = 0 "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "exp_convex",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"The exponential function is convex.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The exponential function is convex.",
      "codex_time": 5.221274390001781,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem exp_convex : ∀ x y : ℝ, x ≤ y →  (exp x : ℝ) ≤ exp y ",
      "theorem exp_is_convex (t : ℝ) (h : 0 < t) :  ConvexOn ℝ (λ x : ℝ, t * x) exp ",
      "theorem exp_convex (x y z : ℝ) :  (exp x + exp y)/2 ≤ exp ((x+y)/2) ",
      "theorem log_exp_convex (x : ℝ) :  ConvexOn (λ x : ℝ, exp x) {y | y ≤ x} ",
      "theorem exp_is_convex :  ∀ x y : ℝ, (y < 1) → (x < log y) → ConvexOn (λ x : ℝ, exp x) (Icc : Set ℝ) ",
      "theorem exp_is_convex :  ∀ x y : ℝ, (y < 1) → (x < log y) → ConvexOn (λ x : ℝ, exp x) (Icc : Setₓ ℝ) "
    ],
    "answer": "theorem exp_convex : ConvexOn ℝ Set.univ Real.exp "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "exp_convex",
      "main_prompt": "The exponential function is convex.",
      "prompt": "Natural language version: \"`exp` is convex on the whole real line.\" Translate the natural language version to a Lean mathlib version:\n theorem convex_on_exp :\nconvex_on ℝ set.univ real.exp := \n\nNatural language version: \"`exp` is strictly convex on the whole real line.\" Translate the natural language version to a Lean mathlib version:\n theorem strict_convex_on_exp :\nstrict_convex_on ℝ set.univ real.exp := \n\nNatural language version: \"`x^m`, `m : ℤ` is convex on `(0, +∞)` for all `m` except `0` and `1`.\" Translate the natural language version to a Lean mathlib version:\n theorem strict_convex_on_zpow{m : ℤ} (hm₀ : m ≠ 0) (hm₁ : m ≠ 1) :\nstrict_convex_on ℝ (set.Ioi 0) (λ (x : ℝ), x ^ m) := \n\nNatural language version: \"`x^n`, `n : ℕ` is convex on `[0, +∞)` for all `n`\" Translate the natural language version to a Lean mathlib version:\n theorem convex_on_pow(n : ℕ) :\nconvex_on ℝ (set.Ici 0) (λ (x : ℝ), x ^ n) := \n\nNatural language version: \"The exponential function is convex.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.8296651840209961,
          "doc_string": "`exp` is convex on the whole real line.",
          "statement": "theorem convex_on_exp  : convex_on ℝ set.univ real.exp"
        },
        {
          "sim_score": 0.8015367984771729,
          "doc_string": "`exp` is strictly convex on the whole real line.",
          "statement": "theorem strict_convex_on_exp  : strict_convex_on ℝ set.univ real.exp"
        },
        {
          "sim_score": 0.5888562202453613,
          "doc_string": "`x^m`, `m : ℤ` is convex on `(0, +∞)` for all `m` except `0` and `1`.",
          "statement": "theorem strict_convex_on_zpow {m : ℤ} (hm₀ : m ≠ 0) (hm₁ : m ≠ 1) : strict_convex_on ℝ (set.Ioi 0) (λ (x : ℝ), x ^ m)"
        },
        {
          "sim_score": 0.5808110237121582,
          "doc_string": "`x^n`, `n : ℕ` is convex on `[0, +∞)` for all `n`",
          "statement": "theorem convex_on_pow (n : ℕ) : convex_on ℝ (set.Ici 0) (λ (x : ℝ), x ^ n)"
        }
      ],
      "codex_time": 3.437689333979506,
      "search_time": 1.4332952370168641,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem convex_exp : Convex (@Real.exp ℝ _) ",
      "theorem convex_exp : Convex Real.exp ",
      "theorem convex_exp : Convex Real.exp ",
      "theorem convex_exp : Convex exp ",
      "theorem convex_exp : Convex Real.exp "
    ],
    "answer": "theorem exp_convex : ConvexOn ℝ Set.univ Real.exp "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "exp_convex",
      "main_prompt": "The exponential function is convex.",
      "prompt": "Natural language version: \"The exponential function is convex.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 12.793934280984104,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem exponential_function_is_convex : Convex (exp_function) ",
      "theorem Exp_convex : is_convex Exp. The is_convex, concave, and affine declarations amount to several theorems. *) example : is_convex (Exp R) ",
      "theorem exp_convex {c x y : ℝ} : c * exp (x + y) ≤ exp x * exp y ",
      "theorem 𝕜.exp_convex (𝕜 : Type) [exp_preserves_order 𝕜] (x y : 𝕜) : ConvexOn 𝕜 exp x y ",
      "theorem exp_convex : Convex (exp : ℝ → ℝ) .     AQ1: It seems to me that we could make things easier by going straight to Lean. So, I'm starting with a Set of questions on the natural language version of the problem.   What does it mean to differentiate \"$f$\" in \"$n$ locations\"? (10 minutes) What is the motivation for requiring that $f(0) = 0$? (10 minutes) What is the motivation for requiring that $f(1) = 1$? (10 minutes) What is the motivation for requiring that $f$ be Continuous? (10 minutes) Give an example",
      "theorem exp_convex : Convex (exp : ℝ → ℝ) .     AQ1: It seems to me that we could make things easier by going straight to Lean. So, I'm starting with a Setₓ of questions on the natural language version of the problem.   What does it mean to differentiate \"$f$\" in \"$n$ locations\"? (10 minutes) What is the motivation for requiring that $f(0) = 0$? (10 minutes) What is the motivation for requiring that $f(1) = 1$? (10 minutes) What is the motivation for requiring that $f$ be Continuous? (10 minutes) Give an example"
    ],
    "answer": "theorem exp_convex : ConvexOn ℝ Set.univ Real.exp "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "coprime_integer_span_sylvester_coin",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.",
      "codex_time": 7.143665453011636,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem exists_linear_combination_relprime_indexes_ge_bound  (a b : ℕ) (hab : nat.coprime a b) : ∀ n, ∃ x y, (a : ℤ) * x + b * y = n ∧ x ∈ ℤ ∧ y ∈ ℤ ",
      "theorem bezout_mod_lt_add_self (a b : ℕ) (h : nat.coprime a b) (m : ℕ) :  ∃ x y : ℕ, a*x + b*y = m % (a + b) ",
      "theorem positive_relatively_prime_pair_formulation_lemma_prime (m n : ℕ)  (hmn : gcd m n = 1) (N : ℕ) (N0 : N ≥ 0) : ∃ x y : ℕ, x * nat.succ m + y * nat.succ n = nat.succ N ",
      "theorem linear_combination_of_rel_prime_integers_large_enough (a b : ℤ)  (a_pos : 0 < a) (b_pos : 0 < b) (h : gcd a b = 1) (N : ℕ) (N_large : N > 2*a*b) :  ∃ x y : ℕ, N = (a : ℕ) * x + b * y ",
      "theorem linear_combination_of_relatively_prime_naturals (a b : ℕ) (h_rel_prime : nat.coprime a b) (N : ℕ) (h_sufficiently_big : N ≥ a + b) :  ∃ x y : ℕ, N = a*x + b*y "
    ],
    "answer": "theorem coprime_integer_span_sylvester_coin : ∀ a b : ℕ, a > 0 → b > 0 → Nat.coprime a b → ∃ m : ℕ, ∀ N : ℕ, N > m → ∃ x y : ℕ, N = a*x + b*y "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "coprime_integer_span_sylvester_coin",
      "main_prompt": "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.",
      "prompt": "Natural language version: \" **Bézout's lemma**: given `x y : ℕ`, `gcd x y = x * a + y * b`, where `a = gcd_a x y` and `b = gcd_b x y` are computed by the extended Euclidean algorithm.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.gcd_eq_gcd_ab(x y : ℕ) :\n↑(x.gcd y) = ↑x * x.gcd_a y + ↑y * x.gcd_b y := \n\nNatural language version: \" For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be written in the form `a * x + b * y` for some pair of integers `x` and `y`\" Translate the natural language version to a Lean mathlib version:\n theorem int.gcd_least_linear{a b : ℤ} (ha : a ≠ 0) :\nis_least {n : ℕ | 0 < n ∧ ∃ (x y : ℤ), ↑n = a * x + b * y} (a.gcd b) := \n\nNatural language version: \"If ` x * y = a * p ^ n` where `p` is prime, then `x` and `y` can both be written  as the product of a power of `p` and a divisor of `a`.\" Translate the natural language version to a Lean mathlib version:\n theorem mul_eq_mul_prime_pow{R : Type u_1} [cancel_comm_monoid_with_zero R] {x y a p : R} {n : ℕ} (hp : prime p) (hx : x * y = a * p ^ n) :\n∃ (i j : ℕ) (b c : R), i + j = n ∧ a = b * c ∧ x = b * p ^ i ∧ y = c * p ^ j := \n\nNatural language version: \" Euclid's lemma: if `a ∣ b * c` and `a` and `c` have no common prime factors, `a ∣ b`. Compare `is_coprime.dvd_of_dvd_mul_left`.\" Translate the natural language version to a Lean mathlib version:\n theorem unique_factorization_monoid.dvd_of_dvd_mul_left_of_no_prime_factors{R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] {a b c : R} (ha : a ≠ 0) :\n(∀ {d : R}, d ∣ a → d ∣ c → ¬prime d) → a ∣ b * c → a ∣ b := \n\nNatural language version: \"For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5282862186431885,
          "doc_string": " **Bézout's lemma**: given `x y : ℕ`, `gcd x y = x * a + y * b`, where `a = gcd_a x y` and `b = gcd_b x y` are computed by the extended Euclidean algorithm.",
          "statement": "theorem nat.gcd_eq_gcd_ab (x y : ℕ) : ↑(x.gcd y) = ↑x * x.gcd_a y + ↑y * x.gcd_b y"
        },
        {
          "sim_score": 0.5160197615623474,
          "doc_string": " For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be written in the form `a * x + b * y` for some pair of integers `x` and `y`",
          "statement": "theorem int.gcd_least_linear {a b : ℤ} (ha : a ≠ 0) : is_least {n : ℕ | 0 < n ∧ ∃ (x y : ℤ), ↑n = a * x + b * y} (a.gcd b)"
        },
        {
          "sim_score": 0.4904349744319916,
          "doc_string": "If ` x * y = a * p ^ n` where `p` is prime, then `x` and `y` can both be written  as the product of a power of `p` and a divisor of `a`.",
          "statement": "theorem mul_eq_mul_prime_pow {R : Type u_1} [cancel_comm_monoid_with_zero R] {x y a p : R} {n : ℕ} (hp : prime p) (hx : x * y = a * p ^ n) : ∃ (i j : ℕ) (b c : R), i + j = n ∧ a = b * c ∧ x = b * p ^ i ∧ y = c * p ^ j"
        },
        {
          "sim_score": 0.47909241914749146,
          "doc_string": " Euclid's lemma: if `a ∣ b * c` and `a` and `c` have no common prime factors, `a ∣ b`. Compare `is_coprime.dvd_of_dvd_mul_left`.",
          "statement": "theorem unique_factorization_monoid.dvd_of_dvd_mul_left_of_no_prime_factors {R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] {a b c : R} (ha : a ≠ 0) : (∀ {d : R}, d ∣ a → d ∣ c → ¬prime d) → a ∣ b * c → a ∣ b"
        }
      ],
      "codex_time": 11.290124716993887,
      "search_time": 1.4988727460149676,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem int.coprime.exists_one_of_eq_one_or_lt{a b : ℤ} (h : a.coprime b) (h1 : a = 1 ∨ a < 1) (h2 : b = 1 ∨ b < 1) (n : ℕ) : ∃ (x y : ℤ), a * x + b * y = ↑n ",
      "theorem exists_nat_mul_eq_linear_comb_of_coprime {a b : ℕ} (h : IsCoprime a b) : ∀ {N : ℕ}, N > (b - 1) * (a - 1) + b + 1 → ∃ (x y : ℕ), ↑N = ↑a * x + ↑b * y ",
      "theorem exists_gcd_eq_gcd_nat{a b : ℕ} (hab : gcd a b = 1) {N : ℕ} (hN : N ≥ a * b) : ∃ (x y : ℕ), ↑(x * a + y * b) = N ∧ ↑a * ↑x + ↑b * ↑y = N ",
      "theorem bezout.exists{R : Type u_1} [CommRing R] {a b x y : R} (hab : a.gcd b = 1) (h : ¬(∃ (u v : R), a * u + b * v = 1)) : ∃ (c : ℤ), ∀ (x y : R), a * x + b * y = c → c = 0 ∧ x = 0 ∧ y = 0 ",
      "theorem bezout.exists{R : Type u_1} [CommRingₓₓ R] {a b x y : R} (hab : a.gcd b = 1) (h : ¬(∃ (u v : R), a * u + b * v = 1)) : ∃ (c : ℤ), ∀ (x y : R), a * x + b * y = c → c = 0 ∧ x = 0 ∧ y = 0 ",
      "theorem bezout.exists{R : Type u_1} [CommRingₓ R] {a b x y : R} (hab : a.gcd b = 1) (h : ¬(∃ (u v : R), a * u + b * v = 1)) : ∃ (c : ℤ), ∀ (x y : R), a * x + b * y = c → c = 0 ∧ x = 0 ∧ y = 0 ",
      "theorem nat.exists_eq_mul_add_of_coprime{a b : ℕ} (hab : nat.coprime a b) : ∀ {N : ℕ}, N > (a - 1) * (b - 1) → ∃ (x y : ℕ), N = a * x + b * y "
    ],
    "answer": "theorem coprime_integer_span_sylvester_coin : ∀ a b : ℕ, a > 0 → b > 0 → Nat.coprime a b → ∃ m : ℕ, ∀ N : ℕ, N > m → ∃ x y : ℕ, N = a*x + b*y "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "coprime_integer_span_sylvester_coin",
      "main_prompt": "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.",
      "prompt": "Natural language version: \"For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 8.649475797021296,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem Dirichlet : ∀ a b : ℕ, IsCoprime a b → ∃ (x y : ℕ), ∀ z : ℕ, z ≥ x → z ≥ y → ∃ (u v : ℕ), a * u + b * v = z ",
      "theorem some_prime_numbers_are_even : ∀ n, n > 6 → n % 2 = 0 ∨ n % 2 = 1 ∨ n % 2 = 5 ∨ n % 2 = 3 ",
      "theorem : ∀ a b x y n, a > 1 → b > 1 → IsCoprime a b → n ≥ max a b → ∃ x y : ℕ, x ≥ 0 ∧ y ≥ 0 ∧ n = a * x + b * y ",
      "theorem fermat_two_squares {a b : ℕ} (a_pos : 0 < a) (ab_coprime : gcd a b = 1) :   ∃ x y : ℕ, a * x + b * y = ↑(Ω ab_coprime) ",
      "theorem linear_comb_exists ( a b : ℕ ) ( h : IsCoprime a b ) : ∀ n : ℕ , n ≥ 2 * max a b → ∃ x y : ℕ , n = a * x + b * y .  Pour envoyer un nouveau fichier au dépôt git: 1. Vérifier que LE fichier n'existe pas déjà dans la branche actuelle. 2. ajouter LE nouveau fichier avec `git Add <nom_fichier>`. 3. Faire un `git commit` avec un message qui"
    ],
    "answer": "theorem coprime_integer_span_sylvester_coin : ∀ a b : ℕ, a > 0 → b > 0 → Nat.coprime a b → ∃ m : ℕ, ∀ N : ℕ, N > m → ∃ x y : ℕ, N = a*x + b*y "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "frobenius_pow_sum_eq_sum_pow",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem abs_sum_leq_sum_abs (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem sum_add_square_sub_square_eq_sum_square (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"In a commutative ring with prime characteristic $p$, the $p$th power of the sum of two elements is equal to the sum of the $p$th powers of the elements.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "In a commutative ring with prime characteristic $p$, the $p$th power of the sum of two elements is equal to the sum of the $p$th powers of the elements.",
      "codex_time": 8.516061720001744,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem sum_p_powers_prime_p_power_eq_sum_p_power  (R : Type*) [CommRing R] (p : ℕ) [hp : Nat.Prime p] (hchar : p.nat_abs = CharP R)  (a b : R) : (a + b) ^ p = a ^ p + b ^ p ",
      "theorem sum_p_powers_prime_p_power_eq_sum_p_power  (R : Type*) [CommRingₓₓ R] (p : ℕ) [hp : Nat.Prime p] (hchar : p.nat_abs = CharP R)  (a b : R) : (a + b) ^ p = a ^ p + b ^ p ",
      "theorem sum_p_powers_prime_p_power_eq_sum_p_power  (R : Type*) [CommRingₓ R] (p : ℕ) [hp : Nat.Prime p] (hchar : p.nat_abs = CharP R)  (a b : R) : (a + b) ^ p = a ^ p + b ^ p ",
      "theorem sum_power_eq_power_sum {R : Type*} [CommRing R] (p : ℕ) (r s : R)  (hp : Nat.Prime p) (hpd : p ∣ nat.fact p) :  r ^ p + s ^ p = (r + s) ^ p ",
      "theorem sum_power_eq_power_sum {R : Type*} [CommRingₓₓ R] (p : ℕ) (r s : R)  (hp : Nat.Prime p) (hpd : p ∣ nat.fact p) :  r ^ p + s ^ p = (r + s) ^ p ",
      "theorem sum_power_eq_power_sum {R : Type*} [CommRingₓ R] (p : ℕ) (r s : R)  (hp : Nat.Prime p) (hpd : p ∣ nat.fact p) :  r ^ p + s ^ p = (r + s) ^ p ",
      "theorem power_add_eq (p : ℕ) [CommRing R] [CharP R p] (a b : R) : (a + b)^p = a^p + b^p ",
      "theorem power_add_eq (p : ℕ) [CommRingₓₓ R] [CharP R p] (a b : R) : (a + b)^p = a^p + b^p ",
      "theorem power_add_eq (p : ℕ) [CommRingₓ R] [CharP R p] (a b : R) : (a + b)^p = a^p + b^p ",
      "theorem power_sum_eq_sum_power (R : Type*) [CommRing R]  (prime_char : Nat.Prime (Charₓ R)) (p : ℕ) [IsPrimitiveRoot (p : ℕ) (Charₓ R)] (x y : R) :  x ^ p + y ^ p = (x + y) ^ p ",
      "theorem power_sum_eq_sum_power (R : Type*) [CommRingₓₓ R]  (prime_char : Nat.Prime (Charₓ R)) (p : ℕ) [IsPrimitiveRoot (p : ℕ) (Charₓ R)] (x y : R) :  x ^ p + y ^ p = (x + y) ^ p ",
      "theorem power_sum_eq_sum_power (R : Type*) [CommRingₓ R]  (prime_char : Nat.Prime (Charₓ R)) (p : ℕ) [IsPrimitiveRoot (p : ℕ) (Charₓ R)] (x y : R) :  x ^ p + y ^ p = (x + y) ^ p ",
      "theorem prime_pow_add (R : Type*) [CommRing R] [Fintype R]  (p : ℕ) (hp : Nat.Prime p) (hprime : ¬ CharP R p)  (x y : R) :  x ^ p + y ^ p = (x + y) ^ p ",
      "theorem prime_pow_add (R : Type*) [CommRingₓₓ R] [Fintype R]  (p : ℕ) (hp : Nat.Prime p) (hprime : ¬ CharP R p)  (x y : R) :  x ^ p + y ^ p = (x + y) ^ p ",
      "theorem prime_pow_add (R : Type*) [CommRingₓ R] [Fintype R]  (p : ℕ) (hp : Nat.Prime p) (hprime : ¬ CharP R p)  (x y : R) :  x ^ p + y ^ p = (x + y) ^ p ",
      "theorem prime_pow_add (R : Type*) [CommRing R] [Fintypeₓ R]  (p : ℕ) (hp : Nat.Prime p) (hprime : ¬ CharP R p)  (x y : R) :  x ^ p + y ^ p = (x + y) ^ p ",
      "theorem prime_pow_add (R : Type*) [CommRingₓₓ R] [Fintypeₓ R]  (p : ℕ) (hp : Nat.Prime p) (hprime : ¬ CharP R p)  (x y : R) :  x ^ p + y ^ p = (x + y) ^ p ",
      "theorem prime_pow_add (R : Type*) [CommRingₓ R] [Fintypeₓ R]  (p : ℕ) (hp : Nat.Prime p) (hprime : ¬ CharP R p)  (x y : R) :  x ^ p + y ^ p = (x + y) ^ p "
    ],
    "answer": "theorem frobenius_pow_sum_eq_sum_pow {R : Type _} [CommRingₓ R] : (p : ℕ) → Prime p → CharP R p → ∀ a b : R, (a + b)^p = a^p + b^p "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "frobenius_pow_sum_eq_sum_pow",
      "main_prompt": "In a commutative ring with prime characteristic $p$, the $p$th power of the sum of two elements is equal to the sum of the $p$th powers of the elements.",
      "prompt": "Natural language version: \"For coprime `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`\" Translate the natural language version to a Lean mathlib version:\n theorem nat.factorization_mul_of_coprime{a b : ℕ} (hab : a.coprime b) :\n(a * b).factorization = a.factorization + b.factorization := \n\nNatural language version: \"For coprime `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`\" Translate the natural language version to a Lean mathlib version:\n theorem nat.factorization_mul_apply_of_coprime{p a b : ℕ} (hab : a.coprime b) :\n⇑((a * b).factorization) p = ⇑(a.factorization) p + ⇑(b.factorization) p := \n\nNatural language version: \"For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`\" Translate the natural language version to a Lean mathlib version:\n theorem nat.factorization_mul{a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0) :\n(a * b).factorization = a.factorization + b.factorization := \n\nNatural language version: \"For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`\" Translate the natural language version to a Lean mathlib version:\n theorem factorization_mul{α : Type u_1} [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] [normalization_monoid α] [decidable_eq α] {a b : α} (ha : a ≠ 0) (hb : b ≠ 0) :\nfactorization (a * b) = factorization a + factorization b := \n\nNatural language version: \"In a commutative ring with prime characteristic $p$, the $p$th power of the sum of two elements is equal to the sum of the $p$th powers of the elements.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6287815570831299,
          "doc_string": "For coprime `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`",
          "statement": "theorem nat.factorization_mul_of_coprime {a b : ℕ} (hab : a.coprime b) : (a * b).factorization = a.factorization + b.factorization"
        },
        {
          "sim_score": 0.6287815570831299,
          "doc_string": "For coprime `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`",
          "statement": "theorem nat.factorization_mul_apply_of_coprime {p a b : ℕ} (hab : a.coprime b) : ⇑((a * b).factorization) p = ⇑(a.factorization) p + ⇑(b.factorization) p"
        },
        {
          "sim_score": 0.6084638833999634,
          "doc_string": "For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`",
          "statement": "theorem nat.factorization_mul {a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0) : (a * b).factorization = a.factorization + b.factorization"
        },
        {
          "sim_score": 0.6084638833999634,
          "doc_string": "For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`",
          "statement": "theorem factorization_mul {α : Type u_1} [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] [normalization_monoid α] [decidable_eq α] {a b : α} (ha : a ≠ 0) (hb : b ≠ 0) : factorization (a * b) = factorization a + factorization b"
        }
      ],
      "codex_time": 8.370010916987667,
      "search_time": 2.0902485070109833,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem pow_sub_sub_mul_sub_sub_commute_aux{𝕜 : Type u_1} [Field 𝕜] (p : ℕ) (ϕ : qia) (q : Fin (nqia ϕ)) :  (↑(ϕ.mk q) : ℚ) ^ p = ↑((ϕ.mk q).1) ^ p ",
      "theorem pow_sub_sub_mul_sub_sub_commute_aux{𝕜 : Type u_1} [Field 𝕜] (p : ℕ) (ϕ : qia) (q : Finₓ (nqia ϕ)) :  (↑(ϕ.mk q) : ℚ) ^ p = ↑((ϕ.mk q).1) ^ p ",
      "theorem nat.dvd_mul_pow (p : ℕ) {a b : ℕ} (h : p.prime) (h1 : a = (b : ℤ)) (h2 : p ∣ b) : p ^ 2 ∣ a * b ",
      "theorem is_ring.map_add_pow {α : Type u_1} [CommRing α] [IsField α] [DecidableEq α] (p : Ω_α) {a b : α} (ha : p = 0) (hb : p = 0) : pow_omega (a + b) p = pow_omega a p + pow_omega b p ",
      "theorem is_ring.map_add_pow {α : Type u_1} [CommRingₓₓ α] [IsField α] [DecidableEq α] (p : Ω_α) {a b : α} (ha : p = 0) (hb : p = 0) : pow_omega (a + b) p = pow_omega a p + pow_omega b p ",
      "theorem is_ring.map_add_pow {α : Type u_1} [CommRingₓ α] [IsField α] [DecidableEq α] (p : Ω_α) {a b : α} (ha : p = 0) (hb : p = 0) : pow_omega (a + b) p = pow_omega a p + pow_omega b p ",
      "theorem nat.add_mul_self{p a b : ℕ} (hp : p.prime) : ↑p * ((a * b) + b + a) = (↑p * (a + b)).pow 2 ",
      "theorem nat.factorization_mul_of_coprime{a b : ℕ} (hab : a.coprime b) : (a * b).factorization = a.factorization + b.factorization "
    ],
    "answer": "theorem frobenius_pow_sum_eq_sum_pow {R : Type _} [CommRingₓ R] : (p : ℕ) → Prime p → CharP R p → ∀ a b : R, (a + b)^p = a^p + b^p "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "frobenius_pow_sum_eq_sum_pow",
      "main_prompt": "In a commutative ring with prime characteristic $p$, the $p$th power of the sum of two elements is equal to the sum of the $p$th powers of the elements.",
      "prompt": "Natural language version: \"In a commutative ring with prime characteristic $p$, the $p$th power of the sum of two elements is equal to the sum of the $p$th powers of the elements.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 8.086846553022042,
      "use_theorem_name": true
    },
    "outputs": [
      "theorem pow_sum_r (α : Type u) [CommRing α] [DecidableEq α] [CharP α] (a b : α) : (a+b)^p = a^p+b^p Use tactic mode to prove the Lean version in Lean's mathlib. You can copy the statement into VS Code and delete the \": Prop\" part. You can see that Lean already knows that $p=CharP(R)$, and we have variables $a,b$ in variable context. You should find that all you need to use is the Ring axioms and the \"frobenius map\" axiom:   fpow f a p",
      "theorem pow_sum_r (α : Type u) [CommRingₓₓ α] [DecidableEq α] [CharP α] (a b : α) : (a+b)^p = a^p+b^p Use tactic mode to prove the Lean version in Lean's mathlib. You can copy the statement into VS Code and delete the \": Prop\" part. You can see that Lean already knows that $p=CharP(R)$, and we have variables $a,b$ in variable context. You should find that all you need to use is the Ring axioms and the \"frobenius map\" axiom:   fpow f a p",
      "theorem pow_sum_r (α : Type u) [CommRing α] [DecidableEq α] [CharP α] (a b : α) : (a+b)^p = a^p+b^p Use tactic mode to prove the Lean version in Lean's mathlib. You can copy the statement into VS Code and delete the \": Prop\" part. You can see that Lean already knows that $p=CharP(R)$, and we have variables $a,b$ in variable context. You should find that all you need to use is the Ringₓₓ axioms and the \"frobenius map\" axiom:   fpow f a p",
      "theorem pow_sum_r (α : Type u) [CommRingₓₓ α] [DecidableEq α] [CharP α] (a b : α) : (a+b)^p = a^p+b^p Use tactic mode to prove the Lean version in Lean's mathlib. You can copy the statement into VS Code and delete the \": Prop\" part. You can see that Lean already knows that $p=CharP(R)$, and we have variables $a,b$ in variable context. You should find that all you need to use is the Ringₓₓ axioms and the \"frobenius map\" axiom:   fpow f a p",
      "theorem pow_sum_r (α : Type u) [CommRing α] [DecidableEq α] [CharP α] (a b : α) : (a+b)^p = a^p+b^p Use tactic mode to prove the Lean version in Lean's mathlib. You can copy the statement into VS Code and delete the \": Prop\" part. You can see that Lean already knows that $p=CharP(R)$, and we have variables $a,b$ in variable context. You should find that all you need to use is the Ringₓ axioms and the \"frobenius map\" axiom:   fpow f a p",
      "theorem pow_sum_r (α : Type u) [CommRingₓₓ α] [DecidableEq α] [CharP α] (a b : α) : (a+b)^p = a^p+b^p Use tactic mode to prove the Lean version in Lean's mathlib. You can copy the statement into VS Code and delete the \": Prop\" part. You can see that Lean already knows that $p=CharP(R)$, and we have variables $a,b$ in variable context. You should find that all you need to use is the Ringₓ axioms and the \"frobenius map\" axiom:   fpow f a p",
      "theorem pow_sum_r (α : Type u) [CommRingₓ α] [DecidableEq α] [CharP α] (a b : α) : (a+b)^p = a^p+b^p Use tactic mode to prove the Lean version in Lean's mathlib. You can copy the statement into VS Code and delete the \": Prop\" part. You can see that Lean already knows that $p=CharP(R)$, and we have variables $a,b$ in variable context. You should find that all you need to use is the Ring axioms and the \"frobenius map\" axiom:   fpow f a p",
      "theorem pow_sum_r (α : Type u) [CommRingₓ α] [DecidableEq α] [CharP α] (a b : α) : (a+b)^p = a^p+b^p Use tactic mode to prove the Lean version in Lean's mathlib. You can copy the statement into VS Code and delete the \": Prop\" part. You can see that Lean already knows that $p=CharP(R)$, and we have variables $a,b$ in variable context. You should find that all you need to use is the Ringₓₓ axioms and the \"frobenius map\" axiom:   fpow f a p",
      "theorem pow_sum_r (α : Type u) [CommRingₓ α] [DecidableEq α] [CharP α] (a b : α) : (a+b)^p = a^p+b^p Use tactic mode to prove the Lean version in Lean's mathlib. You can copy the statement into VS Code and delete the \": Prop\" part. You can see that Lean already knows that $p=CharP(R)$, and we have variables $a,b$ in variable context. You should find that all you need to use is the Ringₓ axioms and the \"frobenius map\" axiom:   fpow f a p",
      "theorem sum_pow_p : ∀ (R : Type*) [CommRing R] (p : ℕ), ∀ a b : R, function . comp has_pow . pow p a + b = has_pow . pow p a + has_pow . pow p b ",
      "theorem sum_pow_p : ∀ (R : Type*) [CommRingₓₓ R] (p : ℕ), ∀ a b : R, function . comp has_pow . pow p a + b = has_pow . pow p a + has_pow . pow p b ",
      "theorem sum_pow_p : ∀ (R : Type*) [CommRingₓ R] (p : ℕ), ∀ a b : R, function . comp has_pow . pow p a + b = has_pow . pow p a + has_pow . pow p b ",
      "theorem natlang_commring_pth_pow_sum { R : Type * } [ CommRing R ] ( p : ℕ ) [ hp : Prime p ] ( x y : R ) : ( x + y ) ^ p = x ^ p + y ^ p ",
      "theorem natlang_commring_pth_pow_sum { R : Type * } [ CommRingₓₓ R ] ( p : ℕ ) [ hp : Prime p ] ( x y : R ) : ( x + y ) ^ p = x ^ p + y ^ p ",
      "theorem natlang_commring_pth_pow_sum { R : Type * } [ CommRingₓ R ] ( p : ℕ ) [ hp : Prime p ] ( x y : R ) : ( x + y ) ^ p = x ^ p + y ^ p ",
      "theorem natlang_version : ∀ { R : Type },   CommRing R → ∀ ( x y : R ), ( x + y ) ^ p = x ^ p + y ^ p ",
      "theorem natlang_version : ∀ { R : Type },   CommRingₓₓ R → ∀ ( x y : R ), ( x + y ) ^ p = x ^ p + y ^ p ",
      "theorem natlang_version : ∀ { R : Type },   CommRingₓ R → ∀ ( x y : R ), ( x + y ) ^ p = x ^ p + y ^ p ",
      "theorem nat_lang_thm : assumes p : Nat, (Prime p)   -- and because a lot of folks can't understand the natural language logic, I translate it to MathLogic: -- theorem logic_thm : ∀ p, Prime p → (∀ r, ...)  -- Since the theorem is not True universally, I have to give r; indeed, Lean treats this as a prop, since it contains   unknowns (it's in a ∀ quantifier).   -/  variables    (x y : G) (p : Nat) (h : Prime p)  -- so I translate it to Lean logic: /- 1)"
    ],
    "answer": "theorem frobenius_pow_sum_eq_sum_pow {R : Type _} [CommRingₓ R] : (p : ℕ) → Prime p → CharP R p → ∀ a b : R, (a + b)^p = a^p + b^p "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "compact_if_all_proper_compact",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"If every proper closed set of a topological space is compact, then the space itself is compact.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If every proper closed set of a topological space is compact, then the space itself is compact.",
      "codex_time": 4.621345956984442,
      "use_theorem_name": false
    },
    "outputs": [
      "(X : Type*) [TopologicalSpace X] (hX : IsCompact X)  : ∀ A : Set X, IsCompact A → IsOpen A ∨ A = X ",
      "(X : Type*) [TopologicalSpace X] (hX : IsCompact X)  : ∀ A : Setₓ X, IsCompact A → IsOpen A ∨ A = X ",
      "(X : Type*) [TopologicalSpace X]    [CompactSpace X] (hX : ∀ S : Set X, IsClosed S → IsCompact S → S = X) :    compact_space.is_compact X ",
      "(X : Type*) [TopologicalSpace X]    [CompactSpace X] (hX : ∀ S : Setₓ X, IsClosed S → IsCompact S → S = X) :    compact_space.is_compact X ",
      "(X : Type*) [TopologicalSpace X] (hX : ∀ A : Set X, IsClosed A → A ≠ X → IsCompact A) :  IsCompact X ",
      "(X : Type*) [TopologicalSpace X] (hX : ∀ A : Setₓ X, IsClosed A → A ≠ X → IsCompact A) :  IsCompact X ",
      "(X : Type*) [TopologicalSpace X]  (h_prop_closed_comp : ∀ {M : Set X} (h_closed : IsClosed M) (h_proper : M ⊆ᶠ X),  IsCompact M) : IsCompact X ",
      "(X : Type*) [TopologicalSpace X]  (h_prop_closed_comp : ∀ {M : Setₓ X} (h_closed : IsClosed M) (h_proper : M ⊆ᶠ X),  IsCompact M) : IsCompact X ",
      "(X : Type*) [topological space X] (h_comp : ∀ S : Set X, IsClosed S → ¬ IsOpen S → IsCompact S) :  IsCompact X ",
      "(X : Type*) [topological space X] (h_comp : ∀ S : Setₓ X, IsClosed S → ¬ IsOpen S → IsCompact S) :  IsCompact X "
    ],
    "answer": "{α : Type _} [TopologicalSpace α] : (∀ (s : Set α), (s ≠ Set.univ) → IsCompact s) → CompactSpace α"
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "compact_if_all_proper_compact",
      "main_prompt": "If every proper closed set of a topological space is compact, then the space itself is compact.",
      "prompt": "Natural language version: \"A closed subset of a compact set is a compact set.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) :\nis_compact t := \n\nNatural language version: \"A set `s` is compact if for every open cover of `s`, there exists a finite subcover.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [topological_space α] {s : set α} (h : ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)) :\nis_compact s := \n\nNatural language version: \"The intersection of a compact set and a closed set is a compact set.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) :\nis_compact (s ∩ t) := \n\nNatural language version: \"The intersection of a closed set and a compact set is a compact set.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s) :\nis_compact (s ∩ t) := \n\nNatural language version: \"If every proper closed set of a topological space is compact, then the space itself is compact.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.782024621963501,
          "doc_string": "A closed subset of a compact set is a compact set.",
          "statement": "theorem compact_of_is_closed_subset {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) : is_compact t"
        },
        {
          "sim_score": 0.6621682643890381,
          "doc_string": "A set `s` is compact if for every open cover of `s`, there exists a finite subcover.",
          "statement": "theorem is_compact_of_finite_subcover {α : Type u} [topological_space α] {s : set α} (h : ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)) : is_compact s"
        },
        {
          "sim_score": 0.651668906211853,
          "doc_string": "The intersection of a compact set and a closed set is a compact set.",
          "statement": "theorem is_compact.inter_right {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) : is_compact (s ∩ t)"
        },
        {
          "sim_score": 0.6444039344787598,
          "doc_string": "The intersection of a closed set and a compact set is a compact set.",
          "statement": "theorem is_compact.inter_left {α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s) : is_compact (s ∩ t)"
        }
      ],
      "codex_time": 4.641647889016895,
      "search_time": 1.6613354209985118,
      "use_theorem_name": false
    },
    "outputs": [
      "{α : Type u} [TopologicalSpace α] {s : Set α} (h : ∀ s, IsClosed s ∧ ¬ IsEmpty s → IsCompact s) : IsCompact α ",
      "{α : Type u} [TopologicalSpace α] {s : Setₓ α} (h : ∀ s, IsClosed s ∧ ¬ IsEmpty s → IsCompact s) : IsCompact α ",
      "{α : Type u} [TopologicalSpace α] (h : ∀ (s : Set α), IsClosed s → s ≠ univ → IsCompact s) : IsCompact univ ",
      "{α : Type u} [TopologicalSpace α] (h : ∀ (s : Setₓ α), IsClosed s → s ≠ univ → IsCompact s) : IsCompact univ ",
      "{α : Type u} [TopologicalSpace α] : (∀ {s : Set α} (hs : IsClosed s) (hns : ∀ x, s x → x ≠ x), IsCompact s) → IsCompact α ",
      "{α : Type u} [TopologicalSpace α] : (∀ {s : Setₓ α} (hs : IsClosed s) (hns : ∀ x, s x → x ≠ x), IsCompact s) → IsCompact α ",
      "{α : Type u} [TopologicalSpace α] (h : ∀ (s : Set α) (hs : IsClosed s) (hps : proper s), IsCompact s) : IsCompact α ",
      "{α : Type u} [TopologicalSpace α] (h : ∀ (s : Setₓ α) (hs : IsClosed s) (hps : proper s), IsCompact s) : IsCompact α ",
      "{α : Type u} [TopologicalSpace α] (h : ∀ s, IsClosed s → (s ≠ univ → IsCompact s)) : IsCompact univ "
    ],
    "answer": "{α : Type _} [TopologicalSpace α] : (∀ (s : Set α), (s ≠ Set.univ) → IsCompact s) → CompactSpace α"
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "compact_if_all_proper_compact",
      "main_prompt": "If every proper closed set of a topological space is compact, then the space itself is compact.",
      "prompt": "Natural language version: \"If every proper closed set of a topological space is compact, then the space itself is compact.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 5.954007053020177,
      "use_theorem_name": false
    },
    "outputs": [
      "problem2 : ∀ (X : Type) [TopologicalSpace X] , (∀ (K : Set X), proper K → IsCompact K) → IsCompact X ",
      "problem2 : ∀ (X : Type) [TopologicalSpace X] , (∀ (K : Setₓ X), proper K → IsCompact K) → IsCompact X ",
      "iff { P : Prop } { Q : Prop } : ( P → Q ) → ( Q → P ) → P ↔ Q ",
      "compact_of_closed_compact {X : Top} (H : ∀ U : Set X, IsClosed U → IsCompact U) : IsCompact X ",
      "compact_of_closed_compact {X : Top} (H : ∀ U : Setₓ X, IsClosed U → IsCompact U) : IsCompact X ",
      "if_every_proper_closed_set_is_compact_then_original_space_is_compact (X : TopologicalSpace α)    (prop_closed_compact : ∀ (Y : Set α), proper_filter Y → IsClosed Y → IsCompact Y) :    IsCompact X ↔ (∀ (Y : Set α), IsClosed Y → IsCompact Y) ",
      "if_every_proper_closed_set_is_compact_then_original_space_is_compact (X : TopologicalSpace α)    (prop_closed_compact : ∀ (Y : Setₓ α), proper_filter Y → IsClosed Y → IsCompact Y) :    IsCompact X ↔ (∀ (Y : Setₓ α), IsClosed Y → IsCompact Y) ",
      "implies_compact_of_compact_of_closed (f: IsCompact B → IsCompact A) (c : IsClosed A) : IsCompact A "
    ],
    "answer": "{α : Type _} [TopologicalSpace α] : (∀ (s : Set α), (s ≠ Set.univ) → IsCompact s) → CompactSpace α"
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "fermat_two_square",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every prime that is one greater than a multiple of four can be expressed as the sum of two squares.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every prime that is one greater than a multiple of four can be expressed as the sum of two squares.",
      "codex_time": 4.3623252310208045,
      "use_theorem_name": false
    },
    "outputs": [
      "(p : ℕ) :  Prime p → 4 ∣ p - 1 → ∃ a b : ℤ, p = a^2 + b^2 ",
      "(p : ℕ) (hp1k : (1 + p % 4 = 0) ∧ Prime p):  ∃ a b : ℕ, a*a + b*b = p ∧ gcd a b = 1 ",
      "(p : ℕ) (hp: Nat.Prime p) (h : 4 ∣ p - 1):  ∃ a b : ℕ, a ^ 2 + b ^ 2 = p ",
      "{p : ℕ} (h : p.prime) (h1 : ∃ n : ℕ, p = n*4+1) :  ∃ (a b : ℕ), a^2 + b^2 = p ",
      "(p : ℕ) (hp : Prime p) (h : p % 4 = 1) : ∃ (a b : ℕ), a^2 + b^2 = p "
    ],
    "answer": ": ∀ p : ℕ, Prime p → (p % 4 = 1) → ∃ a b : ℕ, a ^ 2 + b ^ 2 = p "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "fermat_two_square",
      "main_prompt": "Every prime that is one greater than a multiple of four can be expressed as the sum of two squares.",
      "prompt": "Natural language version: \" **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**.\" Translate the natural language version to a Lean mathlib version:\n theorem {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) :\n∃ (a b : ℕ), a ^ 2 + b ^ 2 = p := \n\nNatural language version: \"**Four squares theorem**\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) :\n∃ (a b c d : ℕ), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n := \n\nNatural language version: \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.\" Translate the natural language version to a Lean mathlib version:\n theorem {p : ℕ} [fact (nat.prime p)] :\np % 2 = 1 ↔ p ≠ 2 := \n\nNatural language version: \"The square of the smallest prime factor of a composite number `n` is at most `n`.\" Translate the natural language version to a Lean mathlib version:\n theorem {n : ℕ} (w : 0 < n) (h : ¬nat.prime n) :\nn.min_fac ^ 2 ≤ n := \n\nNatural language version: \"Every prime that is one greater than a multiple of four can be expressed as the sum of two squares.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6522289514541626,
          "doc_string": " **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**.",
          "statement": "theorem nat.prime.sq_add_sq {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p"
        },
        {
          "sim_score": 0.5913749933242798,
          "doc_string": "**Four squares theorem**",
          "statement": "theorem nat.sum_four_squares (n : ℕ) : ∃ (a b c d : ℕ), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"
        },
        {
          "sim_score": 0.49175825715065,
          "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.",
          "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2"
        },
        {
          "sim_score": 0.48426979780197144,
          "doc_string": "The square of the smallest prime factor of a composite number `n` is at most `n`.",
          "statement": "theorem nat.min_fac_sq_le_self {n : ℕ} (w : 0 < n) (h : ¬nat.prime n) : n.min_fac ^ 2 ≤ n"
        }
      ],
      "codex_time": 5.032618942001136,
      "search_time": 1.6139122870226856,
      "use_theorem_name": false
    },
    "outputs": [
      "{p : ℕ} [Fact (Nat.Prime p)] (h : p % 4 = 3) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p ",
      "{p : ℕ} [Fact (Nat.Prime p)] (hp : 1 = p % 4) : ∃ (a b : ℕ), a + b = p ",
      "{p : ℕ} [Fact (Nat.Prime p)] (hp : ∃ k, p = 4 * k + 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p ",
      "{p : ℕ} [Fact (Nat.Prime p)] (HP : p = nat.succ (4*k) ↔                                           Nat.Prime p ∧ p % 2 = 1 ∧ p % 4 = 3) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p ",
      "{p : ℕ} [Fact (Nat.Prime p)] (hp : p ≠ 2) (hp : p % 4 = 1) : ∃ (a b : ℕ), (a ^ 2 + b ^ 2 = p) "
    ],
    "answer": ": ∀ p : ℕ, Prime p → (p % 4 = 1) → ∃ a b : ℕ, a ^ 2 + b ^ 2 = p "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "fermat_two_square",
      "main_prompt": "Every prime that is one greater than a multiple of four can be expressed as the sum of two squares.",
      "prompt": "Natural language version: \"Every prime that is one greater than a multiple of four can be expressed as the sum of two squares.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 10.054599094990408,
      "use_theorem_name": false
    },
    "outputs": [
      "une (p : ℕ) (hp : Prime p) (hp1 : p % 4 = 1) : ∃ (a b : ℕ), a^2 + b^2 = p ",
      "dvd_add_iff_left { p : ℕ } ( ha : p ∣ a ) : p ∣ b ↔ p ∣ ( a + b ) ",
      "sums_of_squares_even_primes : ∀ p : ℕ, Prime p → p % 4 = 1 → ∃ x y : ℕ, p = x ^ 2 + y ^ 2 ",
      "zero_or_one_mod_four (n : ℕ) : n % 4 = 0 ∨ n % 4 = 1 ",
      "sum_of_squares (n : ℕ) : 2 ∣ (n - 1) → ∃ k h : ℕ, k^2 + h^2 = n begin   (intros a b c h),   rw h at a,   rw ← add_assoc a b c,   rw add_assoc a b c,   rw add_comm c b,   rw ← add_assoc a b c,   rw ← add_assoc a b c,   rw ← add_assoc a b c,   rw ← add_assoc a",
      "sum_of_squares (n : ℕ) : 2 ∣ (n - 1) → ∃ k h : ℕ, k^2 + h^2 = n begin   (intros a b c h),   rw h at a,   rw ← add_assocₓ a b c,   rw add_assocₓ a b c,   rw add_comm c b,   rw ← add_assocₓ a b c,   rw ← add_assocₓ a b c,   rw ← add_assocₓ a b c,   rw ← add_assocₓ a",
      "sum_of_squares (n : ℕ) : 2 ∣ (n - 1) → ∃ k h : ℕ, k^2 + h^2 = n begin   (intros a b c h),   rw h at a,   rw ← add_assoc a b c,   rw add_assoc a b c,   rw add_commₓ c b,   rw ← add_assoc a b c,   rw ← add_assoc a b c,   rw ← add_assoc a b c,   rw ← add_assoc a",
      "sum_of_squares (n : ℕ) : 2 ∣ (n - 1) → ∃ k h : ℕ, k^2 + h^2 = n begin   (intros a b c h),   rw h at a,   rw ← add_assocₓ a b c,   rw add_assocₓ a b c,   rw add_commₓ c b,   rw ← add_assocₓ a b c,   rw ← add_assocₓ a b c,   rw ← add_assocₓ a b c,   rw ← add_assocₓ a"
    ],
    "answer": ": ∀ p : ℕ, Prime p → (p % 4 = 1) → ∃ a b : ℕ, a ^ 2 + b ^ 2 = p "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "unit_line_in_or_out_of_euclidean_plane_subset",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"For every subset of the Euclidean plane, there is a line segment of unit length whose endpoints are either both inside the subset or both outside it.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "For every subset of the Euclidean plane, there is a line segment of unit length whose endpoints are either both inside the subset or both outside it.",
      "codex_time": 10.52339810898411,
      "use_theorem_name": false
    },
    "outputs": [
      "(S : Set ℝ²) : ∀a b : ℝ², a ≠ b → (a ∈ S ↔  b ∈ S) → ∃c d : ℝ²,  Segment (a, b) = Segment (c, d) ∧ ∥c - d∥ = 1 ",
      "(S : Setₓ ℝ²) : ∀a b : ℝ², a ≠ b → (a ∈ S ↔  b ∈ S) → ∃c d : ℝ²,  Segment (a, b) = Segment (c, d) ∧ ∥c - d∥ = 1 ",
      "(p : ℝ × ℝ → Prop) : ∀ x y z w, z ≠ w →  p (x, y) → p (z, w) ↔ ∃ (λ F : ℕ → ℝ,   p (F 0, F 1) ∧ p ((F 0 + F 1)/2, (F 1 - F 0)/2) ∧   F 0 + F 1 = 2*z ∧ F 1 - F 0 = 2*w) ",
      "(S : Set ℝ^2) : ∃ a b : ℝ^2, dist a b = 1 ∧ (a ∈ S ↔ b ∈ S) ",
      "(S : Setₓ ℝ^2) : ∃ a b : ℝ^2, dist a b = 1 ∧ (a ∈ S ↔ b ∈ S) ",
      "(s : Set (euclidean_plane 2)) :  ∀ x y : euclidean_plane 2, ∥x - y∥ = 1 → ∀ t : ℝ, 0 ≤ t ∧ t ≤ 1 →  x + t • (y - x) ∈ s → y + t • (x - y) ∈ s ",
      "(s : Setₓ (euclidean_plane 2)) :  ∀ x y : euclidean_plane 2, ∥x - y∥ = 1 → ∀ t : ℝ, 0 ≤ t ∧ t ≤ 1 →  x + t • (y - x) ∈ s → y + t • (x - y) ∈ s ",
      "(S : Set (Euclidean_plane 2))  (h : set.nonempty S) (hS : ∀ x y : euclidean_plane,  x ≠ 0 ∧ y ≠ 0 ∧ ∥x∥ = 1 ∧ ∥y∥ = 1 → ∃ c : euclidean_plane,  (∀ t : R, 0 < t → t < 1 → c + t • x ∈ S) ∧  (∀ t : R, 0 < t → t < 1 → c + t • y ∈ S) ∧  (∀ t : R, 0 < t → t < 1 →",
      "(S : Setₓ (Euclidean_plane 2))  (h : set.nonempty S) (hS : ∀ x y : euclidean_plane,  x ≠ 0 ∧ y ≠ 0 ∧ ∥x∥ = 1 ∧ ∥y∥ = 1 → ∃ c : euclidean_plane,  (∀ t : R, 0 < t → t < 1 → c + t • x ∈ S) ∧  (∀ t : R, 0 < t → t < 1 → c + t • y ∈ S) ∧  (∀ t : R, 0 < t → t < 1 →"
    ],
    "answer": ": ∀ (S : Set $ EuclideanSpace ℝ (Finₓ 2)), ∃ (x y : EuclideanSpace ℝ (Finₓ 2)), (∥x - y∥ = (1 : ℝ)) → (x ∈ S ∧ y ∈ S) ∨ (x ∉ S ∧ y ∉ S) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "unit_line_in_or_out_of_euclidean_plane_subset",
      "main_prompt": "For every subset of the Euclidean plane, there is a line segment of unit length whose endpoints are either both inside the subset or both outside it.",
      "prompt": "Natural language version: \"If `x ∈ s` and `y ∈ interior s`, then the segment `(x, y]` is included in `interior s`.\" Translate the natural language version to a Lean mathlib version:\n theorem {E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) {x y : E} (hx : x ∈ s) (hy : y ∈ interior s) {t : 𝕜} (ht : t ∈ set.Ioc 0 1) :\nx + t • (y - x) ∈ interior s := \n\nNatural language version: \" If `x ≠ y` belong to the same closed ball, then the open segment with endpoints `x` and `y` is included in the corresponding open ball.\" Translate the natural language version to a Lean mathlib version:\n theorem {E : Type u_2} [normed_group E] [normed_space ℝ E] [strict_convex_space ℝ E] {x y z : E} {r : ℝ} (hx : x ∈ metric.closed_ball z r) (hy : y ∈ metric.closed_ball z r) (hne : x ≠ y) :\nopen_segment ℝ x y ⊆ metric.ball z r := \n\nNatural language version: \" If a subset of a real vector space contains a segment, then the direction of this segment belongs to the tangent cone at its endpoints.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_4} [normed_group G] [normed_space ℝ G] {s : set G} {x y : G} (h : segment ℝ x y ⊆ s) :\ny - x ∈ tangent_cone_at ℝ s x := \n\nNatural language version: \"If `x ∈ closure s` and `y ∈ interior s`, then the segment `(x, y]` is included in `interior s`.\" Translate the natural language version to a Lean mathlib version:\n theorem {E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) {x y : E} (hx : x ∈ closure s) (hy : y ∈ interior s) {t : 𝕜} (ht : t ∈ set.Ioc 0 1) :\nx + t • (y - x) ∈ interior s := \n\nNatural language version: \"For every subset of the Euclidean plane, there is a line segment of unit length whose endpoints are either both inside the subset or both outside it.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5471247434616089,
          "doc_string": "If `x ∈ s` and `y ∈ interior s`, then the segment `(x, y]` is included in `interior s`.",
          "statement": "theorem convex.add_smul_sub_mem_interior {E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) {x y : E} (hx : x ∈ s) (hy : y ∈ interior s) {t : 𝕜} (ht : t ∈ set.Ioc 0 1) : x + t • (y - x) ∈ interior s"
        },
        {
          "sim_score": 0.5154375433921814,
          "doc_string": " If `x ≠ y` belong to the same closed ball, then the open segment with endpoints `x` and `y` is included in the corresponding open ball.",
          "statement": "theorem open_segment_subset_ball_of_ne {E : Type u_2} [normed_group E] [normed_space ℝ E] [strict_convex_space ℝ E] {x y z : E} {r : ℝ} (hx : x ∈ metric.closed_ball z r) (hy : y ∈ metric.closed_ball z r) (hne : x ≠ y) : open_segment ℝ x y ⊆ metric.ball z r"
        },
        {
          "sim_score": 0.5063760280609131,
          "doc_string": " If a subset of a real vector space contains a segment, then the direction of this segment belongs to the tangent cone at its endpoints.",
          "statement": "theorem mem_tangent_cone_of_segment_subset {G : Type u_4} [normed_group G] [normed_space ℝ G] {s : set G} {x y : G} (h : segment ℝ x y ⊆ s) : y - x ∈ tangent_cone_at ℝ s x"
        },
        {
          "sim_score": 0.5046789050102234,
          "doc_string": "If `x ∈ closure s` and `y ∈ interior s`, then the segment `(x, y]` is included in `interior s`.",
          "statement": "theorem convex.add_smul_sub_mem_interior' {E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) {x y : E} (hx : x ∈ closure s) (hy : y ∈ interior s) {t : 𝕜} (ht : t ∈ set.Ioc 0 1) : x + t • (y - x) ∈ interior s"
        }
      ],
      "codex_time": 11.452028172992868,
      "search_time": 1.4950008899904788,
      "use_theorem_name": false
    },
    "outputs": [
      "∀ (s : Set ℝ²) (t : Set.Ioc 0 1), ∃ (a b : ℝ²), (a, b) ∈ (segment_def ℝ 1) ∧ (∀ (t : 𝕜",
      "∀ (s : Setₓ ℝ²) (t : Setₓ.Ioc 0 1), ∃ (a b : ℝ²), (a, b) ∈ (segment_def ℝ 1) ∧ (∀ (t : 𝕜",
      "{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] (s : Set E) (x y : E) : ∃z, z ∈ Metric.Ball ℝ x 1 ∧ z ∈ Metric.Ball ℝ y 1 ∧ (z ∈ s ↔ x ∈ s) ",
      "{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] (s : Setₓ E) (x y : E) : ∃z, z ∈ Metric.Ball ℝ x 1 ∧ z ∈ Metric.Ball ℝ y 1 ∧ (z ∈ s ↔ x ∈ s) ",
      "{ℝ_2 : Type u_2} [InnerProductSpace ℝ ℝ_2] {s : Set ℝ_2} (T : AffineIndependent ℝ s) : ∃ x y : ℝ_2, ∥x - y∥ = 1 ∧ sign_condition ℝ s x y ",
      "{ℝ_2 : Type u_2} [InnerProductSpace ℝ ℝ_2] {s : Setₓ ℝ_2} (T : AffineIndependent ℝ s) : ∃ x y : ℝ_2, ∥x - y∥ = 1 ∧ sign_condition ℝ s x y ",
      "{E : Type u_2} {𝕜 : Type u_3} [NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] {s : Set E} (hs : simplex 𝕜 s) :   ∃ x y : E , x ∈ Closure s ∧ (y ∈ Interior s ∨ y ∈ Closure (univ \\ s)) ∧ abs (y - x) = 1 ",
      "{E : Type u_2} {𝕜 : Type u_3} [NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] {s : Setₓ E} (hs : simplex 𝕜 s) :   ∃ x y : E , x ∈ Closure s ∧ (y ∈ Interior s ∨ y ∈ Closure (univ \\ s)) ∧ abs (y - x) = 1 ",
      "{E : Type u_2} {𝕜 : Type u_3} [LinearOrderedField 𝕜] [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] [bounded_linear_ordered_field 𝕜] [TopologicalAddGroup E] [HasContinuousConstSmul 𝕜 E] {s : Set E} {x y : E} (h : ~(Interior s = ∅)) : ∃ θ : ℝ, θ ∈ Set.Ioc 0 (2 * π) ∧ (λ (t :",
      "{E : Type u_2} {𝕜 : Type u_3} [LinearOrderedField 𝕜] [AddCommGroupₓₓ E] [Module 𝕜 E] [TopologicalSpace E] [bounded_linear_ordered_field 𝕜] [TopologicalAddGroup E] [HasContinuousConstSmul 𝕜 E] {s : Set E} {x y : E} (h : ~(Interior s = ∅)) : ∃ θ : ℝ, θ ∈ Set.Ioc 0 (2 * π) ∧ (λ (t :",
      "{E : Type u_2} {𝕜 : Type u_3} [LinearOrderedField 𝕜] [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] [bounded_linear_ordered_field 𝕜] [TopologicalAddGroup E] [HasContinuousConstSmul 𝕜 E] {s : Setₓ E} {x y : E} (h : ~(Interior s = ∅)) : ∃ θ : ℝ, θ ∈ Setₓ.Ioc 0 (2 * π) ∧ (λ (t :",
      "{E : Type u_2} {𝕜 : Type u_3} [LinearOrderedField 𝕜] [AddCommGroupₓₓ E] [Module 𝕜 E] [TopologicalSpace E] [bounded_linear_ordered_field 𝕜] [TopologicalAddGroup E] [HasContinuousConstSmul 𝕜 E] {s : Setₓ E} {x y : E} (h : ~(Interior s = ∅)) : ∃ θ : ℝ, θ ∈ Setₓ.Ioc 0 (2 * π) ∧ (λ (t :",
      "{E : Type u_2} {𝕜 : Type u_3} [LinearOrderedField 𝕜] [AddCommGroupₓ E] [Module 𝕜 E] [TopologicalSpace E] [bounded_linear_ordered_field 𝕜] [TopologicalAddGroup E] [HasContinuousConstSmul 𝕜 E] {s : Set E} {x y : E} (h : ~(Interior s = ∅)) : ∃ θ : ℝ, θ ∈ Set.Ioc 0 (2 * π) ∧ (λ (t :",
      "{E : Type u_2} {𝕜 : Type u_3} [LinearOrderedField 𝕜] [AddCommGroupₓ E] [Module 𝕜 E] [TopologicalSpace E] [bounded_linear_ordered_field 𝕜] [TopologicalAddGroup E] [HasContinuousConstSmul 𝕜 E] {s : Setₓ E} {x y : E} (h : ~(Interior s = ∅)) : ∃ θ : ℝ, θ ∈ Setₓ.Ioc 0 (2 * π) ∧ (λ (t :"
    ],
    "answer": ": ∀ (S : Set $ EuclideanSpace ℝ (Finₓ 2)), ∃ (x y : EuclideanSpace ℝ (Finₓ 2)), (∥x - y∥ = (1 : ℝ)) → (x ∈ S ∧ y ∈ S) ∨ (x ∉ S ∧ y ∉ S) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "unit_line_in_or_out_of_euclidean_plane_subset",
      "main_prompt": "For every subset of the Euclidean plane, there is a line segment of unit length whose endpoints are either both inside the subset or both outside it.",
      "prompt": "Natural language version: \"For every subset of the Euclidean plane, there is a line segment of unit length whose endpoints are either both inside the subset or both outside it.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 7.01500216400018,
      "use_theorem_name": false
    },
    "outputs": [
      "decidable_path (p : line) (s : Set M) ",
      "decidable_path (p : line) (s : Setₓ M) ",
      "in_unit_seg (p q : ℝ²) : p ∈ unit_seg p q → p ∈ unit_seg q p ∨ q ∈ unit_seg p q.  -- However, an attempt to prove this just by working through the definition of ℝ² leads to a mess. -- Let's try a new approach.  /-- When two points in the R^2 plane lie on the same Unit-length line Segment, we say they are *aligned*. -/ def aligned (p q : ℝ²) : Prop ",
      "subset_segment {E : Type*} [Inhabited E] [AddCommGroup E] [DistribMulAction E R_ns] [NormedGroup E] [NormedSpace ℝ E] (s : Set E) : ∃ (a b : E), (a ∈ s ∧ b ∈ s) ∨ (a ∉ s ∧ b ∉ s) ∧ dist a b = 1 ",
      "subset_segment {E : Type*} [Inhabited E] [AddCommGroupₓₓ E] [DistribMulAction E R_ns] [NormedGroup E] [NormedSpace ℝ E] (s : Set E) : ∃ (a b : E), (a ∈ s ∧ b ∈ s) ∨ (a ∉ s ∧ b ∉ s) ∧ dist a b = 1 ",
      "subset_segment {E : Type*} [Inhabited E] [AddCommGroup E] [DistribMulAction E R_ns] [NormedGroup E] [NormedSpace ℝ E] (s : Setₓ E) : ∃ (a b : E), (a ∈ s ∧ b ∈ s) ∨ (a ∉ s ∧ b ∉ s) ∧ dist a b = 1 ",
      "subset_segment {E : Type*} [Inhabited E] [AddCommGroupₓₓ E] [DistribMulAction E R_ns] [NormedGroup E] [NormedSpace ℝ E] (s : Setₓ E) : ∃ (a b : E), (a ∈ s ∧ b ∈ s) ∨ (a ∉ s ∧ b ∉ s) ∧ dist a b = 1 ",
      "subset_segment {E : Type*} [Inhabited E] [AddCommGroupₓ E] [DistribMulAction E R_ns] [NormedGroup E] [NormedSpace ℝ E] (s : Set E) : ∃ (a b : E), (a ∈ s ∧ b ∈ s) ∨ (a ∉ s ∧ b ∉ s) ∧ dist a b = 1 ",
      "subset_segment {E : Type*} [Inhabited E] [AddCommGroupₓ E] [DistribMulAction E R_ns] [NormedGroup E] [NormedSpace ℝ E] (s : Setₓ E) : ∃ (a b : E), (a ∈ s ∧ b ∈ s) ∨ (a ∉ s ∧ b ∉ s) ∧ dist a b = 1 ",
      "bin_witt: ∀ s: Set ℝ², ∃ a b: ℝ², dist a b = 1 ∧ (a ∈ s ↔ b ∈ s) ",
      "bin_witt: ∀ s: Setₓ ℝ², ∃ a b: ℝ², dist a b = 1 ∧ (a ∈ s ↔ b ∈ s) ",
      "is_intersecting :  ∀ (X : Set ℝ²), ∃ a b:point, a≠b ∧ (a∈X ↔ b∈X)    theorem is_intersecting :  ∀ (X : Set ℝ²), ∃ (a b:point), a≠b ∧ (a∈X ↔ b∈X)  *)  variables P Q : Prop   -- biconditional notation P ↔ Q : 10 ",
      "is_intersecting :  ∀ (X : Setₓ ℝ²), ∃ a b:point, a≠b ∧ (a∈X ↔ b∈X)    theorem is_intersecting :  ∀ (X : Setₓ ℝ²), ∃ (a b:point), a≠b ∧ (a∈X ↔ b∈X)  *)  variables P Q : Prop   -- biconditional notation P ↔ Q : 10 "
    ],
    "answer": ": ∀ (S : Set $ EuclideanSpace ℝ (Finₓ 2)), ∃ (x y : EuclideanSpace ℝ (Finₓ 2)), (∥x - y∥ = (1 : ℝ)) → (x ∈ S ∧ y ∈ S) ∨ (x ∉ S ∧ y ∉ S) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "all_idempotent_implies_commutative",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"A ring with all elements idempotent is commutative.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A ring with all elements idempotent is commutative.",
      "codex_time": 5.970071902003838,
      "use_theorem_name": false
    },
    "outputs": [
      "(R : Type*) [Ring R]  (h : ∀ (x : R), x * x = x) : CommRing R ",
      "(R : Type*) [Ring R]  (h : ∀ (x : R), x * x = x) : CommRingₓₓ R ",
      "(R : Type*) [Ringₓₓ R]  (h : ∀ (x : R), x * x = x) : CommRing R ",
      "(R : Type*) [Ringₓₓ R]  (h : ∀ (x : R), x * x = x) : CommRingₓₓ R ",
      "(R : Type*) [Ringₓ R]  (h : ∀ (x : R), x * x = x) : CommRing R ",
      "(R : Type*) [Ringₓ R]  (h : ∀ (x : R), x * x = x) : CommRingₓₓ R ",
      "(R : Type*) [Ring R]  (h : ∀ (x : R), x * x = x) : CommRingₓ R ",
      "(R : Type*) [Ringₓₓ R]  (h : ∀ (x : R), x * x = x) : CommRingₓ R ",
      "(R : Type*) [Ringₓ R]  (h : ∀ (x : R), x * x = x) : CommRingₓ R ",
      "(A : Type*) [CommRing A]  (hA : ∀ (a : A), a^2 = a) : (∀ (a b : A), a*b = b*a) ",
      "(A : Type*) [CommRingₓₓ A]  (hA : ∀ (a : A), a^2 = a) : (∀ (a b : A), a*b = b*a) ",
      "(A : Type*) [CommRingₓ A]  (hA : ∀ (a : A), a^2 = a) : (∀ (a b : A), a*b = b*a) ",
      "(R : Type*) [CommRing R] (h : ∀ a : R, a ^ 2 = a) :  @commutative R _ ",
      "(R : Type*) [CommRingₓₓ R] (h : ∀ a : R, a ^ 2 = a) :  @commutative R _ ",
      "(R : Type*) [CommRingₓ R] (h : ∀ a : R, a ^ 2 = a) :  @commutative R _ ",
      "(R : Type*) [Ring R] (h : ∀ a : R, a^2 = a) :  comm_ring.comm R ",
      "(R : Type*) [Ringₓₓ R] (h : ∀ a : R, a^2 = a) :  comm_ring.comm R ",
      "(R : Type*) [Ringₓ R] (h : ∀ a : R, a^2 = a) :  comm_ring.comm R ",
      "(R : Type*) [Ring R] (h : ∀ x : R, x + x = x) :  CommRing R",
      "(R : Type*) [Ring R] (h : ∀ x : R, x + x = x) :  CommRingₓₓ R",
      "(R : Type*) [Ringₓₓ R] (h : ∀ x : R, x + x = x) :  CommRing R",
      "(R : Type*) [Ringₓₓ R] (h : ∀ x : R, x + x = x) :  CommRingₓₓ R",
      "(R : Type*) [Ringₓ R] (h : ∀ x : R, x + x = x) :  CommRing R",
      "(R : Type*) [Ringₓ R] (h : ∀ x : R, x + x = x) :  CommRingₓₓ R",
      "(R : Type*) [Ring R] (h : ∀ x : R, x + x = x) :  CommRingₓ R",
      "(R : Type*) [Ringₓₓ R] (h : ∀ x : R, x + x = x) :  CommRingₓ R",
      "(R : Type*) [Ringₓ R] (h : ∀ x : R, x + x = x) :  CommRingₓ R"
    ],
    "answer": "{R : Type _} [Ring R] : (∀ x : R, x * x = 1) → CommRing R "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "all_idempotent_implies_commutative",
      "main_prompt": "A ring with all elements idempotent is commutative.",
      "prompt": "Natural language version: \"The identity map is a ring homomorphism.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [ring α] :\nis_ring_hom id := \n\nNatural language version: \"As submodules, subalgebras are idempotent.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) :\nS.to_submodule * S.to_submodule = S.to_submodule := \n\nNatural language version: \"Two subrings are equal if they have the same elements.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [ring R] {S T : subring R} (h : ∀ (x : R), x ∈ S ↔ x ∈ T) :\nS = T := \n\nNatural language version: \"The map sending a binary relation to the smallest additive congruence relation in which it is contained is idempotent.\" Translate the natural language version to a Lean mathlib version:\n theorem {M : Type u_1} [has_add M] (r : M → M → Prop) :\nadd_con_gen ⇑(add_con_gen r) = add_con_gen r := \n\nNatural language version: \"A ring with all elements idempotent is commutative.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6198770999908447,
          "doc_string": "The identity map is a ring homomorphism.",
          "statement": "theorem is_ring_hom.id {α : Type u} [ring α] : is_ring_hom id"
        },
        {
          "sim_score": 0.6067196130752563,
          "doc_string": "As submodules, subalgebras are idempotent.",
          "statement": "theorem subalgebra.mul_self {R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : S.to_submodule * S.to_submodule = S.to_submodule"
        },
        {
          "sim_score": 0.5843548774719238,
          "doc_string": "Two subrings are equal if they have the same elements.",
          "statement": "theorem subring.ext {R : Type u} [ring R] {S T : subring R} (h : ∀ (x : R), x ∈ S ↔ x ∈ T) : S = T"
        },
        {
          "sim_score": 0.5717903971672058,
          "doc_string": "The map sending a binary relation to the smallest additive congruence relation in which it is contained is idempotent.",
          "statement": "theorem add_con.add_con_gen_idem {M : Type u_1} [has_add M] (r : M → M → Prop) : add_con_gen ⇑(add_con_gen r) = add_con_gen r"
        }
      ],
      "codex_time": 4.747569280007156,
      "search_time": 1.448395250015892,
      "use_theorem_name": false
    },
    "outputs": [
      "{α : Type u} [Ring α] (h : ∀ x, x * x = x) : CommRing α ",
      "{α : Type u} [Ring α] (h : ∀ x, x * x = x) : CommRingₓₓ α ",
      "{α : Type u} [Ringₓₓ α] (h : ∀ x, x * x = x) : CommRing α ",
      "{α : Type u} [Ringₓₓ α] (h : ∀ x, x * x = x) : CommRingₓₓ α ",
      "{α : Type u} [Ringₓ α] (h : ∀ x, x * x = x) : CommRing α ",
      "{α : Type u} [Ringₓ α] (h : ∀ x, x * x = x) : CommRingₓₓ α ",
      "{α : Type u} [Ring α] (h : ∀ x, x * x = x) : CommRingₓ α ",
      "{α : Type u} [Ringₓₓ α] (h : ∀ x, x * x = x) : CommRingₓ α ",
      "{α : Type u} [Ringₓ α] (h : ∀ x, x * x = x) : CommRingₓ α ",
      "{R : Type u} [Ring R] (h : ∀ (x : R), x + x = x) : IsCommutative R ",
      "{R : Type u} [Ringₓₓ R] (h : ∀ (x : R), x + x = x) : IsCommutative R ",
      "{R : Type u} [Ringₓ R] (h : ∀ (x : R), x + x = x) : IsCommutative R ",
      "{R : Type u} [Ring R] (H : ∀ x : R, x * x = x) : is_comm_ring R ",
      "{R : Type u} [Ringₓₓ R] (H : ∀ x : R, x * x = x) : is_comm_ring R ",
      "{R : Type u} [Ringₓ R] (H : ∀ x : R, x * x = x) : is_comm_ring R ",
      "{R : Type u} [Ring R] (h : ∀ (x : R), x^2 = x) : commutative R ",
      "{R : Type u} [Ringₓₓ R] (h : ∀ (x : R), x^2 = x) : commutative R ",
      "{R : Type u} [Ringₓ R] (h : ∀ (x : R), x^2 = x) : commutative R ",
      "{R : Type u} [Ring R] (h : ∀ (x : R), x * x = x) : is_comm_ring R ",
      "{R : Type u} [Ringₓₓ R] (h : ∀ (x : R), x * x = x) : is_comm_ring R ",
      "{R : Type u} [Ringₓ R] (h : ∀ (x : R), x * x = x) : is_comm_ring R "
    ],
    "answer": "{R : Type _} [Ring R] : (∀ x : R, x * x = 1) → CommRing R "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "all_idempotent_implies_commutative",
      "main_prompt": "A ring with all elements idempotent is commutative.",
      "prompt": "Natural language version: \"A ring with all elements idempotent is commutative.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 8.27048383501824,
      "use_theorem_name": false
    },
    "outputs": [
      "comm_ring_idempotent.intro {R} [CommRing R]    (h_eq : ∀ x : R, x * x = x) : comm_ring.commutes R ",
      "comm_ring_idempotent.intro {R} [CommRingₓₓ R]    (h_eq : ∀ x : R, x * x = x) : comm_ring.commutes R ",
      "comm_ring_idempotent.intro {R} [CommRingₓ R]    (h_eq : ∀ x : R, x * x = x) : comm_ring.commutes R ",
      "ring.one_idempotent {α : Type} [CommRing α]  (h : ∀ (a : α), a + a = a) : 1 = 0 ",
      "ring.one_idempotent {α : Type} [CommRingₓₓ α]  (h : ∀ (a : α), a + a = a) : 1 = 0 ",
      "ring.one_idempotent {α : Type} [CommRingₓ α]  (h : ∀ (a : α), a + a = a) : 1 = 0 ",
      "{u v x} [CommRing k] (h : Ideal.span k {u,v}) (hx : h.1 = x) : x ∈ h ",
      "{u v x} [CommRingₓₓ k] (h : Ideal.span k {u,v}) (hx : h.1 = x) : x ∈ h ",
      "{u v x} [CommRingₓ k] (h : Ideal.span k {u,v}) (hx : h.1 = x) : x ∈ h ",
      "idem_is_comm (R : Type) [Ring R] (h : ∀ x : R, x * x = x) : commutative R ",
      "idem_is_comm (R : Type) [Ringₓₓ R] (h : ∀ x : R, x * x = x) : commutative R ",
      "idem_is_comm (R : Type) [Ringₓ R] (h : ∀ x : R, x * x = x) : commutative R ",
      "all_idempotent_implies_commutative ( R : Type ) ( addition : R -> R -> R ) ( arbitrary_identity : R )  ( multiplication : R -> R -> R ) ( identity_element : R ) ( addition_is_commutative : ∀ x y : R , addition x y = addition y x )  ( right_distributive :  proof_by_contradiction : Proof by contradiction - in mathlib methodology slide #16 https://github.com/leanprover-community/mathlib/pull/3196 -/  IsOpen classical variable (R : Type) variable [Ring R] variables a b c d",
      "all_idempotent_implies_commutative ( R : Type ) ( addition : R -> R -> R ) ( arbitrary_identity : R )  ( multiplication : R -> R -> R ) ( identity_element : R ) ( addition_is_commutative : ∀ x y : R , addition x y = addition y x )  ( right_distributive :  proof_by_contradiction : Proof by contradiction - in mathlib methodology slide #16 https://github.com/leanprover-community/mathlib/pull/3196 -/  IsOpen classical variable (R : Type) variable [Ringₓₓ R] variables a b c d",
      "all_idempotent_implies_commutative ( R : Type ) ( addition : R -> R -> R ) ( arbitrary_identity : R )  ( multiplication : R -> R -> R ) ( identity_element : R ) ( addition_is_commutative : ∀ x y : R , addition x y = addition y x )  ( right_distributive :  proof_by_contradiction : Proof by contradiction - in mathlib methodology slide #16 https://github.com/leanprover-community/mathlib/pull/3196 -/  IsOpen classical variable (R : Type) variable [Ringₓ R] variables a b c d"
    ],
    "answer": "{R : Type _} [Ring R] : (∀ x : R, x * x = 1) → CommRing R "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "twin_prime_conjecture",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"There are infinitely many pairs of primes that differ exactly by two.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "There are infinitely many pairs of primes that differ exactly by two.",
      "codex_time": 6.226274352986366,
      "use_theorem_name": false
    },
    "outputs": [
      ": ∃ n : ℕ, n > 1 ∧ ∀ i : ℕ, i < n → ∃ p q : ℕ, p < q ∧ p.prime ∧ q.prime ∧ q = p + 2 ",
      ": ∃ (p q : ℕ), Prime p ∧ Prime q ∧ p + 2 = q ",
      ": ∃ (x e : ℕ), x ≠ 2 ∧ x + 2 = e ∧ Prime x ∧ Prime e ",
      ":  ∃ (p q : ℕ) (hp : Prime p) (hq : Prime q), 2 = q - p ",
      ": ∀ m : ℕ, ∃ p q : ℕ, Prime p ∧ Prime q ∧ p - q = 2 "
    ],
    "answer": ": ∀ n : ℕ, ∃ p : ℕ, p > n → Prime p → Prime (p + 2) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "twin_prime_conjecture",
      "main_prompt": "There are infinitely many pairs of primes that differ exactly by two.",
      "prompt": "Natural language version: \"For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`.\" Translate the natural language version to a Lean mathlib version:\n theorem {k : ℕ} (n : ℕ) (hpos : 0 < k) :\n∃ (p : ℕ), nat.prime p ∧ n ≤ p ∧ p ≡ 1 [MOD k] := \n\nNatural language version: \" Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) :\n∃ (p : ℕ), n ≤ p ∧ nat.prime p := \n\nNatural language version: \"The infinite pigeonhole principle\" Translate the natural language version to a Lean mathlib version:\n theorem {β α : Type u} (f : β → α) (h₁ : cardinal.aleph_0 ≤ cardinal.mk β) (h₂ : cardinal.mk α < (cardinal.mk β).ord.cof) :\n∃ (a : α), cardinal.mk ↥(f ⁻¹' {a}) = cardinal.mk β := \n\nNatural language version: \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.\" Translate the natural language version to a Lean mathlib version:\n theorem {p : ℕ} [fact (nat.prime p)] :\np % 2 = 1 ↔ p ≠ 2 := \n\nNatural language version: \"There are infinitely many pairs of primes that differ exactly by two.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.53578782081604,
          "doc_string": "For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`.",
          "statement": "theorem nat.exists_prime_ge_modeq_one {k : ℕ} (n : ℕ) (hpos : 0 < k) : ∃ (p : ℕ), nat.prime p ∧ n ≤ p ∧ p ≡ 1 [MOD k]"
        },
        {
          "sim_score": 0.525439977645874,
          "doc_string": " Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`.",
          "statement": "theorem nat.exists_infinite_primes (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p"
        },
        {
          "sim_score": 0.5173879861831665,
          "doc_string": "The infinite pigeonhole principle",
          "statement": "theorem ordinal.infinite_pigeonhole {β α : Type u} (f : β → α) (h₁ : cardinal.aleph_0 ≤ cardinal.mk β) (h₂ : cardinal.mk α < (cardinal.mk β).ord.cof) : ∃ (a : α), cardinal.mk ↥(f ⁻¹' {a}) = cardinal.mk β"
        },
        {
          "sim_score": 0.48807522654533386,
          "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.",
          "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2"
        }
      ],
      "codex_time": 11.843190373998368,
      "search_time": 1.6370324949966744,
      "use_theorem_name": false
    },
    "outputs": [
      ": ∀n, ∃[Fact (Nat.Prime p)] [Fact (Nat.Prime (p + 2))], p > n ",
      ": ∀ n, ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ p + 2 = q ",
      ": ∀ (n : ℕ), ∃ (pp : ℕ), Nat.Prime pp ∧ ∃ (pp' : ℕ), Nat.Prime pp' ∧ pp'=pp+2 ",
      "(p q : ℕ) : Nat.Prime p → Nat.Prime q → ∃ (r : ℕ), Nat.Prime r ∧ ∃ (s : ℕ), Nat.Prime s ∧ p + 2 = r ∧ q + 2 = s ",
      "{p q : ℕ} [Fact (Nat.Prime p)] [Fact (Nat.Prime q)] (h₁ : p ≠ q) : ∃ (k : ℕ) (hp ha : Nat.Prime (2 * k + 1)) (h₂ : p = 2 * k + 1 ∨ q = 2 * k + 1), (2 * k + 1 = p ∨ 2 * k + 1 = q) ∧ (2 * k + 1 = p ∨ (2 * k + 2) = q) "
    ],
    "answer": ": ∀ n : ℕ, ∃ p : ℕ, p > n → Prime p → Prime (p + 2) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "twin_prime_conjecture",
      "main_prompt": "There are infinitely many pairs of primes that differ exactly by two.",
      "prompt": "Natural language version: \"There are infinitely many pairs of primes that differ exactly by two.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 8.058844143990427,
      "use_theorem_name": false
    },
    "outputs": [
      "two_prime_pairs : ∃ (x y : ℕ), Prime x ∧ Prime y ∧ y = x + 2 ",
      "some_theorem : ∀ p : ℕ , Prime p → ∃ q : ℕ , Prime q ∧ p + 2 = q ",
      "twin_prime_theorem : ∀ a b : ℕ, ∃ p q : ℕ, p < q ∧ p % 2 = 1 ∧ q % 2 = 1 ∧ q - p = 2",
      "my_theorem : ∃ (a b : ℕ), Prime a ∧ Prime b ∧ b = a + 2  ",
      "two_primes_differ_by_two : \"∀n::ℕ, ∃ p q::ℕ, Prime p ∧ Prime q ∧ p - q = 2\" Your definition should use the definition of primes we saw in the lecture video. 4. Prove the theorem we just defined! 5. Explain the proof to your neighbor! *)  --You should be able to use the following theorem (proved in class):  theorem n_prime_ge_2 : \"∀n::ℕ, Prime n → n ≥ 2\" proof (induction n) case 0 assume H1 : \"Prime 0\""
    ],
    "answer": ": ∀ n : ℕ, ∃ p : ℕ, p > n → Prime p → Prime (p + 2) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "fin_div_ring_is_field",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every finite division ring is a field.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every finite division ring is a field.",
      "codex_time": 5.80271166501916,
      "use_theorem_name": false
    },
    "outputs": [
      "(F : Type*) [Field F] (p : F ≠ 0)  (h0 : ∀ x : F, x ≠ 0 → ∃ y : F, x * y = 1) :  finite_dimension F Nat ",
      "(D : Type*) [DivisionRing D] (n : ℕ)  (hD : FiniteDimensional D ℤ n) : IsField D ",
      "(D : Type*) [DivisionRing D] [Fintype D] : IsField D ",
      "(D : Type*) [DivisionRing D] [Fintypeₓ D] : IsField D ",
      "(D : Type*) [Fintype D] [DivisionRing D] :  Field D ",
      "(D : Type*) [Fintypeₓ D] [DivisionRing D] :  Field D ",
      "(R : Type*) [DivisionRing R] [Fintype R] :  Field R ",
      "(R : Type*) [DivisionRing R] [Fintypeₓ R] :  Field R "
    ],
    "answer": "{R : Type _} [DivisionRing R] [Finite R] : Field R "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "fin_div_ring_is_field",
      "main_prompt": "Every finite division ring is a field.",
      "prompt": "Natural language version: \"A subfield is closed under division.\" Translate the natural language version to a Lean mathlib version:\n theorem {K : Type u} [field K] (s : subfield K) {x y : K} :\nx ∈ s → y ∈ s → x / y ∈ s := \n\nNatural language version: \"A division_ring is one-dimensional as a vector space over itself.\" Translate the natural language version to a Lean mathlib version:\n theorem (K : Type u) [division_ring K] :\nfinite_dimensional.finrank K K = 1 := \n\nNatural language version: \"An intermediate field is closed under division.\" Translate the natural language version to a Lean mathlib version:\n theorem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} :\nx ∈ S → y ∈ S → x / y ∈ S := \n\nNatural language version: \"A subfield is closed under multiplication.\" Translate the natural language version to a Lean mathlib version:\n theorem {K : Type u} [field K] (s : subfield K) {x y : K} :\nx ∈ s → y ∈ s → x * y ∈ s := \n\nNatural language version: \"Every finite division ring is a field.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6756068468093872,
          "doc_string": "A subfield is closed under division.",
          "statement": "theorem subfield.div_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x / y ∈ s"
        },
        {
          "sim_score": 0.6545361280441284,
          "doc_string": "A division_ring is one-dimensional as a vector space over itself.",
          "statement": "theorem finite_dimensional.finrank_self (K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1"
        },
        {
          "sim_score": 0.6345528364181519,
          "doc_string": "An intermediate field is closed under division.",
          "statement": "theorem intermediate_field.div_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} : x ∈ S → y ∈ S → x / y ∈ S"
        },
        {
          "sim_score": 0.62082839012146,
          "doc_string": "A subfield is closed under multiplication.",
          "statement": "theorem subfield.mul_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x * y ∈ s"
        }
      ],
      "codex_time": 3.1822543120069895,
      "search_time": 1.5387114559998736,
      "use_theorem_name": false
    },
    "outputs": [
      "(K : Type u) [Fintype K] [DivisionRing K] : Field K ",
      "(K : Type u) [Fintypeₓ K] [DivisionRing K] : Field K ",
      "{K : Type u} [Fintype K] [DivisionRing K] : Field K ",
      "{K : Type u} [Fintypeₓ K] [DivisionRing K] : Field K ",
      "(K : Type u) [DivisionRing K] (s : FiniteDimensional.finrank K K < with_top.ω) : IsField K ",
      "(K : Type u) [DivisionRing K] [Fintype K] : is_field_of_fintype K ",
      "(K : Type u) [DivisionRing K] [Fintypeₓ K] : is_field_of_fintype K ",
      "{K : Type u} [DivisionRing K] (h : Finite K) : Field K "
    ],
    "answer": "{R : Type _} [DivisionRing R] [Finite R] : Field R "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "fin_div_ring_is_field",
      "main_prompt": "Every finite division ring is a field.",
      "prompt": "Natural language version: \"Every finite division ring is a field.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 8.327289648994338,
      "use_theorem_name": false
    },
    "outputs": [
      "FiniteDivisionRingField: -- This is the ---revised--- version of the theorem. -- You have to prove the theorem, this is just its statement.      ∀(F : Type), ∀(D : DivisionRing F), addition D ∧ multiplication D ∧ One D ∧ Zero D ∧ negation D ∧ Inv D ∧ Finite D → Field F   -- Bonus Prove the differences between Finite division Ring and field. ie: example:      ∃(D : DivisionRing ℕ), Finite D ∧ ¬(Field D)  end FiniteDivisionRingField   namespace FiniteDivisionRingFinite",
      "FiniteDivisionRingField: -- This is the ---revised--- version of the theorem. -- You have to prove the theorem, this is just its statement.      ∀(F : Type), ∀(D : DivisionRing F), addition D ∧ multiplication D ∧ One D ∧ Zero D ∧ negation D ∧ Inv D ∧ Finite D → Field F   -- Bonus Prove the differences between Finite division Ringₓₓ and field. ie: example:      ∃(D : DivisionRing ℕ), Finite D ∧ ¬(Field D)  end FiniteDivisionRingField   namespace FiniteDivisionRingFinite",
      "FiniteDivisionRingField: -- This is the ---revised--- version of the theorem. -- You have to prove the theorem, this is just its statement.      ∀(F : Type), ∀(D : DivisionRing F), addition D ∧ multiplication D ∧ One D ∧ Zero D ∧ negation D ∧ Inv D ∧ Finite D → Field F   -- Bonus Prove the differences between Finite division Ringₓ and field. ie: example:      ∃(D : DivisionRing ℕ), Finite D ∧ ¬(Field D)  end FiniteDivisionRingField   namespace FiniteDivisionRingFinite",
      "division_ring_example {R : Type*} [DivisionRing R] (h : ∃ n : ℕ, n ≠ 0 ∧ (n : R) ≠ 1) : False ",
      "endom_eq_field_of_finite_endom_eq_fin_division_ring (R : Type) [DivisionRing R] (D : Set R) [Fintype D] (f : D → D) [IsAddGroupHom f] : D = Set.Range f → ∃ g : D → R, IsAddGroupHom g ∧ IsScalarTower g f ∧  ∀ (i j : D), i ≠ j → g i * g j = 0 ",
      "endom_eq_field_of_finite_endom_eq_fin_division_ring (R : Type) [DivisionRing R] (D : Setₓ R) [Fintype D] (f : D → D) [IsAddGroupHom f] : D = Setₓ.Range f → ∃ g : D → R, IsAddGroupHom g ∧ IsScalarTower g f ∧  ∀ (i j : D), i ≠ j → g i * g j = 0 ",
      "endom_eq_field_of_finite_endom_eq_fin_division_ring (R : Type) [DivisionRing R] (D : Set R) [Fintypeₓ D] (f : D → D) [IsAddGroupHom f] : D = Set.Range f → ∃ g : D → R, IsAddGroupHom g ∧ IsScalarTower g f ∧  ∀ (i j : D), i ≠ j → g i * g j = 0 ",
      "endom_eq_field_of_finite_endom_eq_fin_division_ring (R : Type) [DivisionRing R] (D : Setₓ R) [Fintypeₓ D] (f : D → D) [IsAddGroupHom f] : D = Setₓ.Range f → ∃ g : D → R, IsAddGroupHom g ∧ IsScalarTower g f ∧  ∀ (i j : D), i ≠ j → g i * g j = 0 ",
      "T : fin_ring_field D   4) A toy version:  ```  structure my_type ",
      "this_theorem_is_true : ∀ (D : Type*) [DivisionRing D] (f : Fintype D), Field D --#check this_theorem_is_true open_locale classical open_locale classical --#check this_theorem_is_true example : this_theorem_is_true ℤ [Fintype ℤ] int.mk' ",
      "this_theorem_is_true : ∀ (D : Type*) [DivisionRing D] (f : Fintypeₓ D), Field D --#check this_theorem_is_true open_locale classical open_locale classical --#check this_theorem_is_true example : this_theorem_is_true ℤ [Fintypeₓ ℤ] int.mk' "
    ],
    "answer": "{R : Type _} [DivisionRing R] [Finite R] : Field R "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "am_gm_ineq",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"The product of two positive numbers is at most the square of their average.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The product of two positive numbers is at most the square of their average.",
      "codex_time": 5.155484684015391,
      "use_theorem_name": false
    },
    "outputs": [
      "(a b : ℝ) (h : 0 < a) (h2 : 0 < b) :  2*a*b / 2 ≤ ((a+b)/2)^2 ",
      "(x y : ℝ) (hx0 hy0 : 0 ≤ x) (hyx : y ≤ x):  x * y ≤ (x + y)^2 / 4 ",
      "(a b : ℝ) (ha : 0 < a) (hb : 0 < b) :  (2 : ℝ) * a * b / ((2 : ℝ) * a + (2 : ℝ) * b) ≤ (a+b)/(2:ℝ) ",
      "(a b : ℝ) (h_a : 0 < a) (h_b : 0 < b) : a * b ≤ (a + b) ^ 2 / 4 ",
      "(a b : ℝ) (ha : 0 ≤ a) (hb : 0 ≤ b) :  a * b ≤ (a + b)^2 / 2 "
    ],
    "answer": ": ∀ (a b : ℝ), a > 0 → b > 0 → a * b ≤ ((a + b)/(1 + 1))^2 "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "am_gm_ineq",
      "main_prompt": "The product of two positive numbers is at most the square of their average.",
      "prompt": "Natural language version: \" The geometric mean is less than or equal to the arithmetic mean, weighted version for two `nnreal` numbers.\" Translate the natural language version to a Lean mathlib version:\n theorem (w₁ w₂ p₁ p₂ : nnreal) :\nw₁ + w₂ = 1 → p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂ := \n\nNatural language version: \"The square of the smallest prime factor of a composite number `n` is at most `n`.\" Translate the natural language version to a Lean mathlib version:\n theorem {n : ℕ} (w : 0 < n) (h : ¬nat.prime n) :\nn.min_fac ^ 2 ≤ n := \n\nNatural language version: \" AM-GM inequality: the **geometric mean is less than or equal to the arithmetic mean**, weighted version for real-valued nonnegative functions.\" Translate the natural language version to a Lean mathlib version:\n theorem {ι : Type u} (s : finset ι) (w z : ι → ℝ) (hw : ∀ (i : ι), i ∈ s → 0 ≤ w i) (hw' : s.sum (λ (i : ι), w i) = 1) (hz : ∀ (i : ι), i ∈ s → 0 ≤ z i) :\ns.prod (λ (i : ι), z i ^ w i) ≤ s.sum (λ (i : ι), w i * z i) := \n\nNatural language version: \"The natural square root is at most the real square root\" Translate the natural language version to a Lean mathlib version:\n theorem {a : ℕ} :\n↑(nat.sqrt a) ≤ real.sqrt ↑a := \n\nNatural language version: \"The product of two positive numbers is at most the square of their average.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5334862470626831,
          "doc_string": " The geometric mean is less than or equal to the arithmetic mean, weighted version for two `nnreal` numbers.",
          "statement": "theorem nnreal.geom_mean_le_arith_mean2_weighted (w₁ w₂ p₁ p₂ : nnreal) : w₁ + w₂ = 1 → p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂"
        },
        {
          "sim_score": 0.5259432196617126,
          "doc_string": "The square of the smallest prime factor of a composite number `n` is at most `n`.",
          "statement": "theorem nat.min_fac_sq_le_self {n : ℕ} (w : 0 < n) (h : ¬nat.prime n) : n.min_fac ^ 2 ≤ n"
        },
        {
          "sim_score": 0.5007948279380798,
          "doc_string": " AM-GM inequality: the **geometric mean is less than or equal to the arithmetic mean**, weighted version for real-valued nonnegative functions.",
          "statement": "theorem real.geom_mean_le_arith_mean_weighted {ι : Type u} (s : finset ι) (w z : ι → ℝ) (hw : ∀ (i : ι), i ∈ s → 0 ≤ w i) (hw' : s.sum (λ (i : ι), w i) = 1) (hz : ∀ (i : ι), i ∈ s → 0 ≤ z i) : s.prod (λ (i : ι), z i ^ w i) ≤ s.sum (λ (i : ι), w i * z i)"
        },
        {
          "sim_score": 0.4941546320915222,
          "doc_string": "The natural square root is at most the real square root",
          "statement": "theorem real.nat_sqrt_le_real_sqrt {a : ℕ} : ↑(nat.sqrt a) ≤ real.sqrt ↑a"
        }
      ],
      "codex_time": 7.779130658018403,
      "search_time": 1.465386819007108,
      "use_theorem_name": false
    },
    "outputs": [
      "(x y : ℝ) (hx0 : 0 < x) (hy0 : 0 < y) : x * y ≤ x + y ",
      "{a b : ℝ} (h : 0 < a) (h' : 0 < b) : a * b ≤ (a + b) ^ 2 / 4. ",
      "{a b : ℝ} (ha : 0 < a) (hb : 0 < b) : a * b ≤ (a + b) ^ 2 / 4 ",
      "{a b : ℝ} (ha : 0 ≤ a) (hb : 0 ≤ b) : a * b ≤ (a + b)^2 / 2 ",
      "{a b : ℝ} (h₁ : 0 ≤ a) (h₂ : 0 ≤ b) : a * b ≤ ((a + b) / 2) ^ 2 "
    ],
    "answer": ": ∀ (a b : ℝ), a > 0 → b > 0 → a * b ≤ ((a + b)/(1 + 1))^2 "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "am_gm_ineq",
      "main_prompt": "The product of two positive numbers is at most the square of their average.",
      "prompt": "Natural language version: \"The product of two positive numbers is at most the square of their average.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 10.786587082984624,
      "use_theorem_name": false
    },
    "outputs": [
      "Q3709 : ∀ a b : ℝ , a > 0 → b > 0 → a * b ≤ ( a + b ) / 2 ^ 2 ",
      "two ( x y : ℝ ) : 0 < x → 0 < y → x * y ≤ ( x + y ) / 2 * ( x + y ) / 2 ",
      "two_pos_product_le_aver_square :  /- Let a and b be positive real numbers. Prove that the  product of a and b is at most the square of their average.-/  begin     assume a b : ℝ,     assume ha : a > 0,     assume hb : b > 0,     have haver : (2 : ℝ)⁻¹ * (a + b)² ≥ (2 : ℝ)⁻¹ * ⟨a, b, ha, hb⟩,         have h1 : (2 : ℝ)⁻¹ * (a + b)",
      "sqrt_le_avg : ∀ a b : ℝ, a * b ≤ (a + b)^2 ",
      "prod_le_prod_mean (a b : ℕ) : a * b ≤ (a + b)^2 "
    ],
    "answer": ": ∀ (a b : ℝ), a > 0 → b > 0 → a * b ≤ ((a + b)/(1 + 1))^2 "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "sylvester_gallai",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"In any configuration of points on the plane, not all on a line, there is a line which contains exactly two of the points.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "In any configuration of points on the plane, not all on a line, there is a line which contains exactly two of the points.",
      "codex_time": 5.38002449600026,
      "use_theorem_name": false
    },
    "outputs": [
      "(α : Type) [AddCommGroup α] [vector_space ℝ α]  (p : α) (hs : ∀ q : α, q ≠ p → Fintype { r : α | q - p = r }) : ∃ L : Submodule ℝ α, L ≠ ⊥ ∧ Finite L ⊓ span ℝ {p} = ⊥ ",
      "(α : Type) [AddCommGroupₓₓ α] [vector_space ℝ α]  (p : α) (hs : ∀ q : α, q ≠ p → Fintype { r : α | q - p = r }) : ∃ L : Submodule ℝ α, L ≠ ⊥ ∧ Finite L ⊓ span ℝ {p} = ⊥ ",
      "(α : Type) [AddCommGroupₓ α] [vector_space ℝ α]  (p : α) (hs : ∀ q : α, q ≠ p → Fintype { r : α | q - p = r }) : ∃ L : Submodule ℝ α, L ≠ ⊥ ∧ Finite L ⊓ span ℝ {p} = ⊥ ",
      "(α : Type) [AddCommGroup α] [vector_space ℝ α]  (p : α) (hs : ∀ q : α, q ≠ p → Fintypeₓ { r : α | q - p = r }) : ∃ L : Submodule ℝ α, L ≠ ⊥ ∧ Finite L ⊓ span ℝ {p} = ⊥ ",
      "(α : Type) [AddCommGroupₓₓ α] [vector_space ℝ α]  (p : α) (hs : ∀ q : α, q ≠ p → Fintypeₓ { r : α | q - p = r }) : ∃ L : Submodule ℝ α, L ≠ ⊥ ∧ Finite L ⊓ span ℝ {p} = ⊥ ",
      "(α : Type) [AddCommGroupₓ α] [vector_space ℝ α]  (p : α) (hs : ∀ q : α, q ≠ p → Fintypeₓ { r : α | q - p = r }) : ∃ L : Submodule ℝ α, L ≠ ⊥ ∧ Finite L ⊓ span ℝ {p} = ⊥ ",
      "(s : Set (point ℝ)) (h1 : ∃ x y : ℝ, x ≠ y)  (h2 : ∀ a b : ℝ, ∃ c : ℝ, ∀ x y ∈ s, (a*x + b*y) ≠ c) :  ∃ L : line ℝ, set.card (L ∩ s) = 2 ",
      "(s : Setₓ (point ℝ)) (h1 : ∃ x y : ℝ, x ≠ y)  (h2 : ∀ a b : ℝ, ∃ c : ℝ, ∀ x y ∈ s, (a*x + b*y) ≠ c) :  ∃ L : line ℝ, set.card (L ∩ s) = 2 ",
      "(points : Set (point ℝ 2)) (hpoints : card points ≥ 3):  ∃ Path : (point ℝ 2) → (point ℝ 2) → Prop,  ∃ a b : (point ℝ 2), is_path a b Path ∧ a ≠ b ∧ card {x | x ∈ points ∧ Path a b x} = 2 ∧  ∀ a b c, is_path a b Path → {x : point ℝ 2 | x ∈ points ∕\\ Path a b x} ≠ {c} ",
      "(points : Setₓ (point ℝ 2)) (hpoints : card points ≥ 3):  ∃ Path : (point ℝ 2) → (point ℝ 2) → Prop,  ∃ a b : (point ℝ 2), is_path a b Path ∧ a ≠ b ∧ card {x | x ∈ points ∧ Path a b x} = 2 ∧  ∀ a b c, is_path a b Path → {x : point ℝ 2 | x ∈ points ∕\\ Path a b x} ≠ {c} ",
      "(P : Type*) [Fintype P] [AddCommGroup P] [vector_space ℝ P] [affine_space P]  (points : finite_image P ℂ) (n : ℕ) (hn : n > 0) (hn' : n > 4)  (hnonaligned : ¬ (∃ (r : ℝ), ∀ p ∈ points.val, Coe r * (p : P) ∈ points.val)) :  ∃ (l : P → ℝ), ∃ p_1, p_2 : P, p_1 ≠ p_2 ∧ l p_1",
      "(P : Type*) [Fintype P] [AddCommGroupₓₓ P] [vector_space ℝ P] [affine_space P]  (points : finite_image P ℂ) (n : ℕ) (hn : n > 0) (hn' : n > 4)  (hnonaligned : ¬ (∃ (r : ℝ), ∀ p ∈ points.val, Coe r * (p : P) ∈ points.val)) :  ∃ (l : P → ℝ), ∃ p_1, p_2 : P, p_1 ≠ p_2 ∧ l p_1",
      "(P : Type*) [Fintype P] [AddCommGroupₓ P] [vector_space ℝ P] [affine_space P]  (points : finite_image P ℂ) (n : ℕ) (hn : n > 0) (hn' : n > 4)  (hnonaligned : ¬ (∃ (r : ℝ), ∀ p ∈ points.val, Coe r * (p : P) ∈ points.val)) :  ∃ (l : P → ℝ), ∃ p_1, p_2 : P, p_1 ≠ p_2 ∧ l p_1",
      "(P : Type*) [Fintypeₓ P] [AddCommGroup P] [vector_space ℝ P] [affine_space P]  (points : finite_image P ℂ) (n : ℕ) (hn : n > 0) (hn' : n > 4)  (hnonaligned : ¬ (∃ (r : ℝ), ∀ p ∈ points.val, Coe r * (p : P) ∈ points.val)) :  ∃ (l : P → ℝ), ∃ p_1, p_2 : P, p_1 ≠ p_2 ∧ l p_1",
      "(P : Type*) [Fintypeₓ P] [AddCommGroupₓₓ P] [vector_space ℝ P] [affine_space P]  (points : finite_image P ℂ) (n : ℕ) (hn : n > 0) (hn' : n > 4)  (hnonaligned : ¬ (∃ (r : ℝ), ∀ p ∈ points.val, Coe r * (p : P) ∈ points.val)) :  ∃ (l : P → ℝ), ∃ p_1, p_2 : P, p_1 ≠ p_2 ∧ l p_1",
      "(P : Type*) [Fintypeₓ P] [AddCommGroupₓ P] [vector_space ℝ P] [affine_space P]  (points : finite_image P ℂ) (n : ℕ) (hn : n > 0) (hn' : n > 4)  (hnonaligned : ¬ (∃ (r : ℝ), ∀ p ∈ points.val, Coe r * (p : P) ∈ points.val)) :  ∃ (l : P → ℝ), ∃ p_1, p_2 : P, p_1 ≠ p_2 ∧ l p_1",
      "(X : Type*) [Fintype X] (f : X → ℝ^2)  (hf : (∀ P : {P : X × X // P.1 ≠ P.2},               (∀ i : (Fin 2), f i.1 = f i.2 → False)) → False) :  ∃ P : {P : X × X // P.1 ≠ P.2}, ∀ L : {L : ℝ × ℝ // L.1 ≠ L.2} × (Fin 1) × (Fin 2),  f P.1 = (L.1).1 + ↑L.2.1 *",
      "(X : Type*) [Fintype X] (f : X → ℝ^2)  (hf : (∀ P : {P : X × X // P.1 ≠ P.2},               (∀ i : (Finₓ 2), f i.1 = f i.2 → False)) → False) :  ∃ P : {P : X × X // P.1 ≠ P.2}, ∀ L : {L : ℝ × ℝ // L.1 ≠ L.2} × (Finₓ 1) × (Finₓ 2),  f P.1 = (L.1).1 + ↑L.2.1 *",
      "(X : Type*) [Fintypeₓ X] (f : X → ℝ^2)  (hf : (∀ P : {P : X × X // P.1 ≠ P.2},               (∀ i : (Fin 2), f i.1 = f i.2 → False)) → False) :  ∃ P : {P : X × X // P.1 ≠ P.2}, ∀ L : {L : ℝ × ℝ // L.1 ≠ L.2} × (Fin 1) × (Fin 2),  f P.1 = (L.1).1 + ↑L.2.1 *",
      "(X : Type*) [Fintypeₓ X] (f : X → ℝ^2)  (hf : (∀ P : {P : X × X // P.1 ≠ P.2},               (∀ i : (Finₓ 2), f i.1 = f i.2 → False)) → False) :  ∃ P : {P : X × X // P.1 ≠ P.2}, ∀ L : {L : ℝ × ℝ // L.1 ≠ L.2} × (Finₓ 1) × (Finₓ 2),  f P.1 = (L.1).1 + ↑L.2.1 *"
    ],
    "answer": "{P L : Type _} [HasMem P L] [Membership P L] [Configuration.Nondegenerate P L] : ∃ (l : L) (p q : P), p ∈ l → q ∈ l → (∀ r : P, r ∈ l → r = p ∨ r = q) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "sylvester_gallai",
      "main_prompt": "In any configuration of points on the plane, not all on a line, there is a line which contains exactly two of the points.",
      "prompt": "Natural language version: \"A single point is collinear.\" Translate the natural language version to a Lean mathlib version:\n theorem (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) :\ncollinear k {p} := \n\nNatural language version: \"If a nondegenerate configuration has at least as many points as lines, then there exists  an injective function `f` from lines to points, such that `f l` does not lie on `l`.\" Translate the natural language version to a Lean mathlib version:\n theorem {P L : Type u} [has_mem P L] [configuration.nondegenerate P L] [fintype P] [fintype L] (h : fintype.card L ≤ fintype.card P) :\n∃ (f : L → P), function.injective f ∧ ∀ (l : L), f l ∉ l := \n\nNatural language version: \"If a nondegenerate configuration has a unique point on any two lines, then `|L| ≤ |P|`.\" Translate the natural language version to a Lean mathlib version:\n theorem (P L : Type u) [has_mem P L] [configuration.has_points P L] [fintype P] [fintype L] :\nfintype.card L ≤ fintype.card P := \n\nNatural language version: \"If a nondegenerate configuration has a unique line through any two points, then `|P| ≤ |L|`.\" Translate the natural language version to a Lean mathlib version:\n theorem (P L : Type u) [has_mem P L] [configuration.has_lines P L] [fintype P] [fintype L] :\nfintype.card P ≤ fintype.card L := \n\nNatural language version: \"In any configuration of points on the plane, not all on a line, there is a line which contains exactly two of the points.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5291177034378052,
          "doc_string": "A single point is collinear.",
          "statement": "theorem collinear_singleton (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) : collinear k {p}"
        },
        {
          "sim_score": 0.5157747268676758,
          "doc_string": "If a nondegenerate configuration has at least as many points as lines, then there exists  an injective function `f` from lines to points, such that `f l` does not lie on `l`.",
          "statement": "theorem configuration.nondegenerate.exists_injective_of_card_le {P L : Type u} [has_mem P L] [configuration.nondegenerate P L] [fintype P] [fintype L] (h : fintype.card L ≤ fintype.card P) : ∃ (f : L → P), function.injective f ∧ ∀ (l : L), f l ∉ l"
        },
        {
          "sim_score": 0.5101643800735474,
          "doc_string": "If a nondegenerate configuration has a unique point on any two lines, then `|L| ≤ |P|`.",
          "statement": "theorem configuration.has_points.card_le (P L : Type u) [has_mem P L] [configuration.has_points P L] [fintype P] [fintype L] : fintype.card L ≤ fintype.card P"
        },
        {
          "sim_score": 0.500416100025177,
          "doc_string": "If a nondegenerate configuration has a unique line through any two points, then `|P| ≤ |L|`.",
          "statement": "theorem configuration.has_lines.card_le (P L : Type u) [has_mem P L] [configuration.has_lines P L] [fintype P] [fintype L] : fintype.card P ≤ fintype.card L"
        }
      ],
      "codex_time": 7.869558934995439,
      "search_time": 1.4785787790024187,
      "use_theorem_name": false
    },
    "outputs": [
      "two_lines : ∃ l₁ l₂ : Subtype P, ∃ p₁ p₂ : P, (p₁, p₂) ∉ l₁ ∧ (p₁, p₂) ∉ l₂ ∧ (p₁, p₂) ∈ ξ ",
      "(P : Type u) [HasMem P configuration.points] [DecidableEq P] [Fintype P] : ∃ p q : P, Function.Injective (λ (p : point_on_line k V P p q) (l : line k V P p q), { p, q }) ",
      "(P : Type u) [HasMem P configuration.points] [DecidableEq P] [Fintypeₓ P] : ∃ p q : P, Function.Injective (λ (p : point_on_line k V P p q) (l : line k V P p q), { p, q }) ",
      "(P : Type u) [HasMem P plane] [Fintype P] [DecidableEq plane] [Fintype plane] [nodup P] {l : plane} (hl : ∀ p, p ∈ l → p ∈ P) : ∃ p₁ p₂, p₁ ∈ P ∧ p₂ ∈ P ∧ p₂ ≠ p₁ ∧ pairwise_eq plane p₂ p₁ l ",
      "(P : Type u) [HasMem P plane] [Fintypeₓ P] [DecidableEq plane] [Fintypeₓ plane] [nodup P] {l : plane} (hl : ∀ p, p ∈ l → p ∈ P) : ∃ p₁ p₂, p₁ ∈ P ∧ p₂ ∈ P ∧ p₂ ≠ p₁ ∧ pairwise_eq plane p₂ p₁ l ",
      "{P : Type u_1} {L : Type u_2} [HasMem P L] [Fintype P] [Fintype L] (h : Fintype.card P > 2)  : Fintype L ",
      "{P : Type u_1} {L : Type u_2} [HasMem P L] [Fintypeₓ P] [Fintypeₓ L] (h : Fintypeₓ.card P > 2)  : Fintypeₓ L ",
      "(P : Type u) [HasMem P (L a P)] [Fintype P] [Fintype (L a P)] : ∃ (L : Set (L a P)), Fintype.card L = 2 ∧ ∀ (l ∈ L), l ≠ 0 ",
      "(P : Type u) [HasMem P (L a P)] [Fintype P] [Fintype (L a P)] : ∃ (L : Setₓ (L a P)), Fintype.card L = 2 ∧ ∀ (l ∈ L), l ≠ 0 ",
      "(P : Type u) [HasMem P (L a P)] [Fintypeₓ P] [Fintypeₓ (L a P)] : ∃ (L : Set (L a P)), Fintypeₓ.card L = 2 ∧ ∀ (l ∈ L), l ≠ 0 ",
      "(P : Type u) [HasMem P (L a P)] [Fintypeₓ P] [Fintypeₓ (L a P)] : ∃ (L : Setₓ (L a P)), Fintypeₓ.card L = 2 ∧ ∀ (l ∈ L), l ≠ 0 "
    ],
    "answer": "{P L : Type _} [HasMem P L] [Membership P L] [Configuration.Nondegenerate P L] : ∃ (l : L) (p q : P), p ∈ l → q ∈ l → (∀ r : P, r ∈ l → r = p ∨ r = q) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "sylvester_gallai",
      "main_prompt": "In any configuration of points on the plane, not all on a line, there is a line which contains exactly two of the points.",
      "prompt": "Natural language version: \"In any configuration of points on the plane, not all on a line, there is a line which contains exactly two of the points.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 9.685172995988978,
      "use_theorem_name": false
    },
    "outputs": [
      "exists_line_contains_two_pts : and_classification → ∃ a b : line_through, ∀ l : line_through, (l ⊆ a) ∨ (l ⊆ b) ∨ (l ∩ a ∩ b ≠ ∅) -/  /- --Here is the formulation that is closer to `point_on_plane` but with `non_collinear` added\" lemma no_collinear_points : Π a : point_on_plane | ∀ l : line_through, (l ⊆ a) ∨ (l ∩ a = ∅),   ∃",
      "intermediate_value_thm:  end",
      "line_contains_exactly_two_points : ∀ {m : Set (point 2)} (h : m.card ≠ 0), ∃ l : line 2, l.inter_points 2 m.card h = 2 ",
      "line_contains_exactly_two_points : ∀ {m : Setₓ (point 2)} (h : m.card ≠ 0), ∃ l : line 2, l.inter_points 2 m.card h = 2 ",
      "pigeonhole_principle {α : Type*} (s : Finset α) (p : α → Prop)   (h : ∀ x, ∃ a ∈ s, p a) : (∃ a b ∈ s, p a ∧ p b ∧ a ≠ b) ∨   ∃ x ∈ set.univ.image (λ (x : α), { a : α // p a }), x.1 ∈ s ∧ ∃ x ∈ set.univ.image (λ (x : α), { a : α // p a }), x.1 ∈ s ",
      "in_to_two [Nonempty α] [FiniteDimensional α] [AddCommGroup α] [vector_space α ℝ]   (S : Set α) [S_nonempty : Nonempty S] : ∃ (a b : α), S ⊆ { z | z = a + b*(b - a) }      ",
      "in_to_two [Nonempty α] [FiniteDimensional α] [AddCommGroupₓₓ α] [vector_space α ℝ]   (S : Set α) [S_nonempty : Nonempty S] : ∃ (a b : α), S ⊆ { z | z = a + b*(b - a) }      ",
      "in_to_two [Nonempty α] [FiniteDimensional α] [AddCommGroup α] [vector_space α ℝ]   (S : Setₓ α) [S_nonempty : Nonempty S] : ∃ (a b : α), S ⊆ { z | z = a + b*(b - a) }      ",
      "in_to_two [Nonempty α] [FiniteDimensional α] [AddCommGroupₓₓ α] [vector_space α ℝ]   (S : Setₓ α) [S_nonempty : Nonempty S] : ∃ (a b : α), S ⊆ { z | z = a + b*(b - a) }      ",
      "in_to_two [Nonempty α] [FiniteDimensional α] [AddCommGroupₓ α] [vector_space α ℝ]   (S : Set α) [S_nonempty : Nonempty S] : ∃ (a b : α), S ⊆ { z | z = a + b*(b - a) }      ",
      "in_to_two [Nonempty α] [FiniteDimensional α] [AddCommGroupₓ α] [vector_space α ℝ]   (S : Setₓ α) [S_nonempty : Nonempty S] : ∃ (a b : α), S ⊆ { z | z = a + b*(b - a) }      "
    ],
    "answer": "{P L : Type _} [HasMem P L] [Membership P L] [Configuration.Nondegenerate P L] : ∃ (l : L) (p q : P), p ∈ l → q ∈ l → (∀ r : P, r ∈ l → r = p ∨ r = q) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "cantor_schroeder_bernstein",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"If each of two types can be mapped injectively into the other, then there is a bijection between them.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If each of two types can be mapped injectively into the other, then there is a bijection between them.",
      "codex_time": 6.9743744079896715,
      "use_theorem_name": false
    },
    "outputs": [
      "{A B : Type*} (w : A → B) (z : B → A)  (h1 : ∀ x y, w x = w y → x = y)  (h2 : ∀ x y, z x = z y → x = y) :  bijective w ",
      "(A B : Type*) (h₁ : (A → B) → False) (h₂ : (B → A) → False) :  Nonempty (A ≃ B) ",
      "{X Y : Type}  (f : X → Y) (g : Y → X)  (hf : Function.Injective f) (hg : Function.Injective g) :  bijective.mk g f (function.left_inverse.bijective f g hf hg) ⟹ bijective g ",
      "LE06.LE06C (X Y : Type*)  (h : ∃ f : X → Y, injective f)  (h' : ∃ f : Y → X, injective f) :  Fintype.card X = Fintype.card Y ",
      "LE06.LE06C (X Y : Type*)  (h : ∃ f : X → Y, injective f)  (h' : ∃ f : Y → X, injective f) :  Fintypeₓ.card X = Fintypeₓ.card Y ",
      "(X Y : Type*) (f : X → Y) [injective f]  (g : Y → X) [injective g] :  bijective f "
    ],
    "answer": "{α β : Type _} (f : α → β) (g : β → α) : Function.Injective f → Function.Injective g → (∃ h : α → β, Function.Bijective h) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "cantor_schroeder_bernstein",
      "main_prompt": "If each of two types can be mapped injectively into the other, then there is a bijection between them.",
      "prompt": "Natural language version: \" **The Schröder-Bernstein Theorem**: Given injections `α → β` and `β → α`, we can get a bijection `α → β`.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} {β : Type v} {f : α → β} {g : β → α} (hf : function.injective f) (hg : function.injective g) :\n∃ (h : α → β), function.bijective h := \n\nNatural language version: \"A morphism in `Type u` is an isomorphism if and only if it is bijective.\" Translate the natural language version to a Lean mathlib version:\n theorem {X Y : Type u} (f : X ⟶ Y) :\ncategory_theory.is_iso f ↔ function.bijective f := \n\nNatural language version: \"An equivalence is essentially surjective.  See <https://stacks.math.columbia.edu/tag/02C3>.\" Translate the natural language version to a Lean mathlib version:\n theorem {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) [category_theory.is_equivalence F] :\ncategory_theory.ess_surj F := \n\nNatural language version: \"If two subtypes of a fintype have equal cardinality, so do their complements.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} [fintype α] (p q : α → Prop) [fintype {x // p x}] [fintype {x // ¬p x}] [fintype {x // q x}] [fintype {x // ¬q x}] (h : fintype.card {x // p x} = fintype.card {x // q x}) :\nfintype.card {x // ¬p x} = fintype.card {x // ¬q x} := \n\nNatural language version: \"If each of two types can be mapped injectively into the other, then there is a bijection between them.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.648023247718811,
          "doc_string": " **The Schröder-Bernstein Theorem**: Given injections `α → β` and `β → α`, we can get a bijection `α → β`.",
          "statement": "theorem function.embedding.schroeder_bernstein {α : Type u} {β : Type v} {f : α → β} {g : β → α} (hf : function.injective f) (hg : function.injective g) : ∃ (h : α → β), function.bijective h"
        },
        {
          "sim_score": 0.617520809173584,
          "doc_string": "A morphism in `Type u` is an isomorphism if and only if it is bijective.",
          "statement": "theorem category_theory.is_iso_iff_bijective {X Y : Type u} (f : X ⟶ Y) : category_theory.is_iso f ↔ function.bijective f"
        },
        {
          "sim_score": 0.612472414970398,
          "doc_string": "An equivalence is essentially surjective.  See <https://stacks.math.columbia.edu/tag/02C3>.",
          "statement": "theorem category_theory.equivalence.ess_surj_of_equivalence {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) [category_theory.is_equivalence F] : category_theory.ess_surj F"
        },
        {
          "sim_score": 0.6091285347938538,
          "doc_string": "If two subtypes of a fintype have equal cardinality, so do their complements.",
          "statement": "theorem fintype.card_compl_eq_card_compl {α : Type u_1} [fintype α] (p q : α → Prop) [fintype {x // p x}] [fintype {x // ¬p x}] [fintype {x // q x}] [fintype {x // ¬q x}] (h : fintype.card {x // p x} = fintype.card {x // q x}) : fintype.card {x // ¬p x} = fintype.card {x // ¬q x}"
        }
      ],
      "codex_time": 7.486992643011035,
      "search_time": 1.5347542650124524,
      "use_theorem_name": false
    },
    "outputs": [
      "{α : Type u_1} {β : Type u_2} {f : α → β} {g : β → α} (hf : Function.Injective f) (hg : Function.Injective g) : ∃ (h : α ≃ β), _ ",
      "{α : Type u} {β : Type v} (f : α → β) (g : β → α) : (∀ x, Function.Surjective f) → (∀ x, Function.Surjective g) → ∃ (h : α → β), Function.bijective h ",
      "{α : Type u} {β : Type v} (f : α → β) (g : β → α) [hf : Function.Injective f] [hg : Function.Injective g] : ∃ (h : α → β), Function.bijective h ",
      "{α : Type u} {β : Type v} (f : α → β) (g : β → α) [Hf : Function.Injective f] [Hg : Function.Injective g] : ∃ (h : β → α), Function.bijective h ",
      "{α : Type u_1} {β : Type u_2} (f : α → β) {g : β → α} (hf : ∀a, ∃ha, f a = g ha) (hg : ∀b, ∃hb, g b = f hb) : bijective f "
    ],
    "answer": "{α β : Type _} (f : α → β) (g : β → α) : Function.Injective f → Function.Injective g → (∃ h : α → β, Function.Bijective h) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "cantor_schroeder_bernstein",
      "main_prompt": "If each of two types can be mapped injectively into the other, then there is a bijection between them.",
      "prompt": "Natural language version: \"If each of two types can be mapped injectively into the other, then there is a bijection between them.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 13.75339470198378,
      "use_theorem_name": false
    },
    "outputs": [
      "foo [Fintype [Fin1 : α], Fintype [Fin2 : β]] (h1 : injective f) (h2 : injective g)   (h3 : ∀ x : α, ∃ y : β, hf (Fin1 x) = g (Fin2 y)) :   ∃ h : β → α, f ∘ h = g ∘ Fin2 ∧ injective h 🤔 ?  (according to https://math.stackexchange.com/q/146430, https://en.wikipedia.org/wiki/Banach%E2%80%93Bernstein_theorem gives a generalization of",
      "foo [Fintype [Finₓ1 : α], Fintype [Finₓ2 : β]] (h1 : injective f) (h2 : injective g)   (h3 : ∀ x : α, ∃ y : β, hf (Finₓ1 x) = g (Finₓ2 y)) :   ∃ h : β → α, f ∘ h = g ∘ Finₓ2 ∧ injective h 🤔 ?  (according to https://math.stackexchange.com/q/146430, https://en.wikipedia.org/wiki/Banach%E2%80%93Bernstein_theorem gives a generalization of",
      "foo [Fintypeₓ [Fin1 : α], Fintypeₓ [Fin2 : β]] (h1 : injective f) (h2 : injective g)   (h3 : ∀ x : α, ∃ y : β, hf (Fin1 x) = g (Fin2 y)) :   ∃ h : β → α, f ∘ h = g ∘ Fin2 ∧ injective h 🤔 ?  (according to https://math.stackexchange.com/q/146430, https://en.wikipedia.org/wiki/Banach%E2%80%93Bernstein_theorem gives a generalization of",
      "foo [Fintypeₓ [Finₓ1 : α], Fintypeₓ [Finₓ2 : β]] (h1 : injective f) (h2 : injective g)   (h3 : ∀ x : α, ∃ y : β, hf (Finₓ1 x) = g (Finₓ2 y)) :   ∃ h : β → α, f ∘ h = g ∘ Finₓ2 ∧ injective h 🤔 ?  (according to https://math.stackexchange.com/q/146430, https://en.wikipedia.org/wiki/Banach%E2%80%93Bernstein_theorem gives a generalization of",
      "nat_mul_comm' (x y : ℕ): x * y = y * x ",
      "two { A B : Type } ( f : A → B ) ( g : B → A ) : Injective f → Injective g → bijective f ",
      "is_iso_if_bijective ( X Y : Type )   ( N : X → Y )   ( M : Y → X )   ( N_bijective : bijective X Y N )   ( M_bijective : bijective Y X M ) :  iso X Y ",
      "lem4 : ∀ A, ∀ B, (∀ a, A a → B a) → (∀ b, B b → A b) → ∃ X, @Eq α (A X) (B X) → Prop "
    ],
    "answer": "{α β : Type _} (f : α → β) (g : β → α) : Function.Injective f → Function.Injective g → (∃ h : α → β, Function.Bijective h) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "graph_unique_common_neighbour_implies_universal_adjacent_vertex",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"A finite graph in which every two vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A finite graph in which every two vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.",
      "codex_time": 7.647909646999324,
      "use_theorem_name": false
    },
    "outputs": [
      "(X : Type) [Fintype X] (f : X → ((X → Prop) → Prop))  (h : ∀ x y, f x (λ y, f y (λ z, x = z ∨ y = z))):  ∃ x, ∀ y, f y (λ z, x = z) ",
      "(X : Type) [Fintypeₓ X] (f : X → ((X → Prop) → Prop))  (h : ∀ x y, f x (λ y, f y (λ z, x = z ∨ y = z))):  ∃ x, ∀ y, f y (λ z, x = z) ",
      "finite_graph_with_precisely_one_common_neighbour_has_vertex_adjacent_to_all_other_vertices :  ∀ G : Type*, ∀ n : ℕ, ∀ adj : n → n → Prop,  ∀ hG_finite : Fintype n,  (∀ v : n, ∀ w : n, ∃ x : n, adj x v ∧ adj x w) →  (∃ x : n, ∀ y : n, x ≠ y → adj x y) ",
      "finite_graph_with_precisely_one_common_neighbour_has_vertex_adjacent_to_all_other_vertices :  ∀ G : Type*, ∀ n : ℕ, ∀ adj : n → n → Prop,  ∀ hG_finite : Fintypeₓ n,  (∀ v : n, ∀ w : n, ∃ x : n, adj x v ∧ adj x w) →  (∃ x : n, ∀ y : n, x ≠ y → adj x y) ",
      "(G : Type*) [Fintype G] [DecidableEq G] [Fintype (G × G)]          [Finset G] [Finset (G × G)] (graph : Finset (G × G))          (conn : ∀ g : G, g ∈ graph.univ → ∀ h : G, h ∈ graph.univ → ∃ k, g ≠ h ∧ g = k ∧ h = k) :  ∃ g, ∀ h, (g ≠ h) → g = h ",
      "(G : Type*) [Fintypeₓ G] [DecidableEq G] [Fintypeₓ (G × G)]          [Finset G] [Finset (G × G)] (graph : Finset (G × G))          (conn : ∀ g : G, g ∈ graph.univ → ∀ h : G, h ∈ graph.univ → ∃ k, g ≠ h ∧ g = k ∧ h = k) :  ∃ g, ∀ h, (g ≠ h) → g = h ",
      "(G : Type*) [Fintype G] [DecidableEq G] [fin_graph G]  (hG : ∀ v w : G, card {u | v ≠ u ∧ w ≠ u} = 1) :  ∃ v : G, ∀ X : Set G, card X = card G → (∀ u ∈ X, v -- u) ∧ (∀ u ∈ G, X ≠ ∅ → v -- u) ",
      "(G : Type*) [Fintype G] [DecidableEq G] [fin_graph G]  (hG : ∀ v w : G, card {u | v ≠ u ∧ w ≠ u} = 1) :  ∃ v : G, ∀ X : Setₓ G, card X = card G → (∀ u ∈ X, v -- u) ∧ (∀ u ∈ G, X ≠ ∅ → v -- u) ",
      "(G : Type*) [Fintypeₓ G] [DecidableEq G] [fin_graph G]  (hG : ∀ v w : G, card {u | v ≠ u ∧ w ≠ u} = 1) :  ∃ v : G, ∀ X : Set G, card X = card G → (∀ u ∈ X, v -- u) ∧ (∀ u ∈ G, X ≠ ∅ → v -- u) ",
      "(G : Type*) [Fintypeₓ G] [DecidableEq G] [fin_graph G]  (hG : ∀ v w : G, card {u | v ≠ u ∧ w ≠ u} = 1) :  ∃ v : G, ∀ X : Setₓ G, card X = card G → (∀ u ∈ X, v -- u) ∧ (∀ u ∈ G, X ≠ ∅ → v -- u) ",
      "(n : ℕ) (e : Fin n → Fin n → Prop)  (fe : ∀ (x y z : Fin n), e x y ∧ e y z → e x z)  [Fintype ℕ n] [DecidableEq ℕ n] -- Decidable instances are needed to define the Finset  [DecidableEq (Fin n)]  (fnd : ∀ (x y : Fin n), e x y ∨ ¬ e x y)  (hd : ∀ (x y : Fin n), ∃ z, e x z ∧ e y z)  (ht : ∀ (x : Fin n),",
      "(n : ℕ) (e : Finₓ n → Finₓ n → Prop)  (fe : ∀ (x y z : Finₓ n), e x y ∧ e y z → e x z)  [Fintype ℕ n] [DecidableEq ℕ n] -- Decidable instances are needed to define the Finset  [DecidableEq (Finₓ n)]  (fnd : ∀ (x y : Finₓ n), e x y ∨ ¬ e x y)  (hd : ∀ (x y : Finₓ n), ∃ z, e x z ∧ e y z)  (ht : ∀ (x : Finₓ n),",
      "(n : ℕ) (e : Fin n → Fin n → Prop)  (fe : ∀ (x y z : Fin n), e x y ∧ e y z → e x z)  [Fintypeₓ ℕ n] [DecidableEq ℕ n] -- Decidable instances are needed to define the Finset  [DecidableEq (Fin n)]  (fnd : ∀ (x y : Fin n), e x y ∨ ¬ e x y)  (hd : ∀ (x y : Fin n), ∃ z, e x z ∧ e y z)  (ht : ∀ (x : Fin n),",
      "(n : ℕ) (e : Finₓ n → Finₓ n → Prop)  (fe : ∀ (x y z : Finₓ n), e x y ∧ e y z → e x z)  [Fintypeₓ ℕ n] [DecidableEq ℕ n] -- Decidable instances are needed to define the Finset  [DecidableEq (Finₓ n)]  (fnd : ∀ (x y : Finₓ n), e x y ∨ ¬ e x y)  (hd : ∀ (x y : Finₓ n), ∃ z, e x z ∧ e y z)  (ht : ∀ (x : Finₓ n),"
    ],
    "answer": "{V : Type _} [Finite V] (G : SimpleGraph V) : (∀ v w : V, ∃! x : V, G.Adj v x ∧ G.Adj w x) → (∃ c : V, ∀ v : V, G.Adj c v) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "graph_unique_common_neighbour_implies_universal_adjacent_vertex",
      "main_prompt": "A finite graph in which every two vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.",
      "prompt": "Natural language version: \"Two vertices are adjacent iff there is an edge between them. The condition `v ≠ w` ensures they are different endpoints of the edge, which is necessary since when `v = w` the existential `∃ (e ∈ G.edge_set), v ∈ e ∧ w ∈ e` is satisfied by every edge incident to `v`.\" Translate the natural language version to a Lean mathlib version:\n theorem {V : Type u} (G : simple_graph V) {v w : V} :\nG.adj v w ↔ v ≠ w ∧ ∃ (e : sym2 V) (H : e ∈ G.edge_set), v ∈ e ∧ w ∈ e := \n\nNatural language version: \"The handshaking lemma.  See also `simple_graph.sum_degrees_eq_twice_card_edges`.\" Translate the natural language version to a Lean mathlib version:\n theorem {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] :\neven (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card := \n\nNatural language version: \"There exists a vertex of maximal degree. Note the assumption of being nonempty is necessary, as the lemma implies there exists a vertex.\" Translate the natural language version to a Lean mathlib version:\n theorem {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [nonempty V] :\n∃ (v : V), G.max_degree = G.degree v := \n\nNatural language version: \"In a graph, if `k` is at least the degree of every vertex, then it is at least the maximum degree.\" Translate the natural language version to a Lean mathlib version:\n theorem {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (k : ℕ) (h : ∀ (v : V), G.degree v ≤ k) :\nG.max_degree ≤ k := \n\nNatural language version: \"A finite graph in which every two vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5179886817932129,
          "doc_string": "Two vertices are adjacent iff there is an edge between them. The condition `v ≠ w` ensures they are different endpoints of the edge, which is necessary since when `v = w` the existential `∃ (e ∈ G.edge_set), v ∈ e ∧ w ∈ e` is satisfied by every edge incident to `v`.",
          "statement": "theorem simple_graph.adj_iff_exists_edge {V : Type u} (G : simple_graph V) {v w : V} : G.adj v w ↔ v ≠ w ∧ ∃ (e : sym2 V) (H : e ∈ G.edge_set), v ∈ e ∧ w ∈ e"
        },
        {
          "sim_score": 0.5029463171958923,
          "doc_string": "The handshaking lemma.  See also `simple_graph.sum_degrees_eq_twice_card_edges`.",
          "statement": "theorem simple_graph.even_card_odd_degree_vertices {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] : even (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card"
        },
        {
          "sim_score": 0.4985456168651581,
          "doc_string": "There exists a vertex of maximal degree. Note the assumption of being nonempty is necessary, as the lemma implies there exists a vertex.",
          "statement": "theorem simple_graph.exists_maximal_degree_vertex {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [nonempty V] : ∃ (v : V), G.max_degree = G.degree v"
        },
        {
          "sim_score": 0.48896029591560364,
          "doc_string": "In a graph, if `k` is at least the degree of every vertex, then it is at least the maximum degree.",
          "statement": "theorem simple_graph.max_degree_le_of_forall_degree_le {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (k : ℕ) (h : ∀ (v : V), G.degree v ≤ k) : G.max_degree ≤ k"
        }
      ],
      "codex_time": 12.804689691023668,
      "search_time": 1.517556758975843,
      "use_theorem_name": false
    },
    "outputs": [
      "{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.adj] : (∀ (v w : V), G.adj v w → G.degree v = 1) → ∃ (v : V), ∀ (w : V), v ≠ w → G.adj v w ",
      "{V : Type u} (G : SimpleGraph V) [Fintypeₓ V] [DecidableRel G.adj] : (∀ (v w : V), G.adj v w → G.degree v = 1) → ∃ (v : V), ∀ (w : V), v ≠ w → G.adj v w ",
      "{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.adj] (h : ∀ (v w : V) (vw : G.adj v w),     G.adj_set v ∩ G.adj_set w = {vw.2.1}) : ∃ (v : V), (∀ (w : V), (G.adj_set v) ∩ (G.adj_set w) = {some (G.adj v w)} ∧ G.adj v w) ",
      "{V : Type u} (G : SimpleGraph V) [Fintypeₓ V] [DecidableRel G.adj] (h : ∀ (v w : V) (vw : G.adj v w),     G.adj_set v ∩ G.adj_set w = {vw.2.1}) : ∃ (v : V), (∀ (w : V), (G.adj_set v) ∩ (G.adj_set w) = {some (G.adj v w)} ∧ G.adj v w) ",
      "{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.adj] (H : ∀ (v w : V), G.adj v w → G.degree v = G.degree w ∧ G.degree v = 2) : ∃ (v : V), ∀ (w : V), v ≠ w → G.adj v w ",
      "{V : Type u} (G : SimpleGraph V) [Fintypeₓ V] [DecidableRel G.adj] (H : ∀ (v w : V), G.adj v w → G.degree v = G.degree w ∧ G.degree v = 2) : ∃ (v : V), ∀ (w : V), v ≠ w → G.adj v w ",
      "{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.adj] (h : ∀ (v w : V), v ≠ w → G.adj v w ∨ G.adj w v) : ∃ (v : V), ∀ (w : V), w ≠ v → G.adj v w ",
      "{V : Type u} (G : SimpleGraph V) [Fintypeₓ V] [DecidableRel G.adj] (h : ∀ (v w : V), v ≠ w → G.adj v w ∨ G.adj w v) : ∃ (v : V), ∀ (w : V), w ≠ v → G.adj v w ",
      "{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.adj] (h : ∀ (v w : V), G.is_complete_graph {v, w}) : ∃ (v : V), G.is_vertex_cover tt = ({v} : Finset V) ",
      "{V : Type u} (G : SimpleGraph V) [Fintypeₓ V] [DecidableRel G.adj] (h : ∀ (v w : V), G.is_complete_graph {v, w}) : ∃ (v : V), G.is_vertex_cover tt = ({v} : Finset V) "
    ],
    "answer": "{V : Type _} [Finite V] (G : SimpleGraph V) : (∀ v w : V, ∃! x : V, G.Adj v x ∧ G.Adj w x) → (∃ c : V, ∀ v : V, G.Adj c v) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "graph_unique_common_neighbour_implies_universal_adjacent_vertex",
      "main_prompt": "A finite graph in which every two vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.",
      "prompt": "Natural language version: \"A finite graph in which every two vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 5.502323626016732,
      "use_theorem_name": false
    },
    "outputs": [
      "finite_Havel_Hakimi: ∀ (n : ℕ),   ∀ (g : Fin n → Fin n → Prop),   (∀ (i j: Fin n), i ≠ j → ∃ !(k : Fin n), g i k ∧ g j k) → (∀ i : Fin n, ∃ k : Fin n, ∃ l : Fin n, g i k ∧ ¬ g i l) ",
      "finite_Havel_Hakimi: ∀ (n : ℕ),   ∀ (g : Finₓ n → Finₓ n → Prop),   (∀ (i j: Finₓ n), i ≠ j → ∃ !(k : Finₓ n), g i k ∧ g j k) → (∀ i : Finₓ n, ∃ k : Finₓ n, ∃ l : Finₓ n, g i k ∧ ¬ g i l) ",
      ": seems_like_a_conjecture (λ (f : Finset (Finset ℕ)), f ≠ ∅) ",
      "vertex_with_all_adjacent_vertices(V : Type) (E : V → V → Prop) : finite_vgraph V → (∀ x y : V, (∃ z : V, E x z ∧ E y z) → E x y) → (∃ v : V, ∀ u, u ≠ v → E u v) ",
      "fin_g_ex_node_is_adj_all_vertices (G : fin_graph n) :  ∃ v : vertices_fin G, forall v' : vertices G, v' ≠ v → v' ∈ G.adj v ",
      "exists_all_adj {V: Type*} [Fintype V] (coadj: Π (a b: V), button_graph V)                     (H: ∀ a b : V, coadj a b) (a : V):  ∀ b, connect a b ↔ H a b ",
      "exists_all_adj {V: Type*} [Fintypeₓ V] (coadj: Π (a b: V), button_graph V)                     (H: ∀ a b : V, coadj a b) (a : V):  ∀ b, connect a b ↔ H a b "
    ],
    "answer": "{V : Type _} [Finite V] (G : SimpleGraph V) : (∀ v w : V, ∃! x : V, G.Adj v x ∧ G.Adj w x) → (∃ c : V, ∀ v : V, G.Adj c v) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "partition_odd_distincts",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"The number of partitions with odd parts is equal to the number of partitions with distinct parts.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The number of partitions with odd parts is equal to the number of partitions with distinct parts.",
      "codex_time": 9.617209566000383,
      "use_theorem_name": false
    },
    "outputs": [
      "(n : ℕ) : lift_t (@list.partitions.partitions ℕ _ n).filterb  (λ p : List ℕ, Prod.snd p % 2 = 1) = lift_t (@list.partitions.partitions ℕ _ n).filter  (λ p : List ℕ, ∀ a b ∈ p, a ≠ b) ",
      ":  card {p : partition ℕ | ∃ (a: ℕ), p.res a % 2 = 1} = card {p : partition ℕ | ∀ (a b: ℕ), a ≠ b → b ∉ p.res a} ",
      "(n : ℕ) :  Nat.count (λ f, (∃ i, i ∈ f.support ∧ Odd i) ∧ f.min = 0) (partitions n) =  Nat.count (λ f, f.min = 0 ∧ ∀ i j, i ≠ j → i ∈ f.support → j ∈ f.support → i + f i ≠ j + f j) (partitions n) ",
      ": ∀ n : ℕ, card {p : Finset ℕ // (∀ i ≤ p.1, ↑(p.val i) % 2 = 1) ∧ (finset.nodup p.1 ∧ p.1.card = n)} = card {p : Finset ℕ // finset.nodup p.1 ∧ p.1.card = n} ",
      ":  ∑ p : partition ℕ, ∑ k in p.parts, bodd k = ∑ p : partition ℕ, ∀ k, Dvd 1 k ∧ Dvd 1 (p.parts.erase_dup k) "
    ],
    "answer": ": ∀ n : ℕ, Finset.card (Nat.Partition.odds n) = Finset.card (Nat.Partition.distincts n) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "partition_odd_distincts",
      "main_prompt": "The number of partitions with odd parts is equal to the number of partitions with distinct parts.",
      "prompt": "Natural language version: \"If we can partition a sum into subsets that cancel out, then the whole sum cancels.\" Translate the natural language version to a Lean mathlib version:\n theorem {β : Type u} {α : Type v} {s : finset α} {f : α → β} [add_comm_monoid β] (R : setoid α) [decidable_rel setoid.r] (h : ∀ (x : α), x ∈ s → (finset.filter (λ (y : α), y ≈ x) s).sum (λ (a : α), f a) = 0) :\ns.sum (λ (x : α), f x) = 0 := \n\nNatural language version: \" To show a property is true on the odd parts, it suffices to show it is true on the vectors, closed under addition, and under left-multiplication by a pair of vectors.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) {P : Π (x : clifford_algebra Q), x ∈ clifford_algebra.even_odd Q 1 → Prop} (hι : ∀ (v : M), P (⇑(clifford_algebra.ι Q) v) _) (hadd : ∀ {x y : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 1} {hy : y ∈ clifford_algebra.even_odd Q 1}, P x hx → P y hy → P (x + y) _) (hιι_mul : ∀ (m₁ m₂ : M) {x : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 1}, P x hx → P (⇑(clifford_algebra.ι Q) m₁ * ⇑(clifford_algebra.ι Q) m₂ * x) _) (x : clifford_algebra Q) (hx : x ∈ clifford_algebra.even_odd Q 1) :\nP x hx := \n\nNatural language version: \"A sum can be partitioned into a sum of sums, each equivalent under a setoid.\" Translate the natural language version to a Lean mathlib version:\n theorem {β : Type u} {α : Type v} {s : finset α} {f : α → β} [add_comm_monoid β] (R : setoid α) [decidable_rel setoid.r] :\ns.sum (λ (x : α), f x) = (finset.image quotient.mk s).sum (λ (xbar : quotient R), (finset.filter (λ (y : α), ⟦y⟧ = xbar) s).sum (λ (y : α), f y)) := \n\nNatural language version: \"Distinct elements of a set of sets partitioning α are disjoint.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} {c : set (set α)} (H : ∀ (a : α), ∃! (b : set α) (H : b ∈ c), a ∈ b) :\nc.pairwise_disjoint id := \n\nNatural language version: \"The number of partitions with odd parts is equal to the number of partitions with distinct parts.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.45678937435150146,
          "doc_string": "If we can partition a sum into subsets that cancel out, then the whole sum cancels.",
          "statement": "theorem finset.sum_cancels_of_partition_cancels {β : Type u} {α : Type v} {s : finset α} {f : α → β} [add_comm_monoid β] (R : setoid α) [decidable_rel setoid.r] (h : ∀ (x : α), x ∈ s → (finset.filter (λ (y : α), y ≈ x) s).sum (λ (a : α), f a) = 0) : s.sum (λ (x : α), f x) = 0"
        },
        {
          "sim_score": 0.44783246517181396,
          "doc_string": " To show a property is true on the odd parts, it suffices to show it is true on the vectors, closed under addition, and under left-multiplication by a pair of vectors.",
          "statement": "theorem clifford_algebra.odd_induction {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) {P : Π (x : clifford_algebra Q), x ∈ clifford_algebra.even_odd Q 1 → Prop} (hι : ∀ (v : M), P (⇑(clifford_algebra.ι Q) v) _) (hadd : ∀ {x y : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 1} {hy : y ∈ clifford_algebra.even_odd Q 1}, P x hx → P y hy → P (x + y) _) (hιι_mul : ∀ (m₁ m₂ : M) {x : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 1}, P x hx → P (⇑(clifford_algebra.ι Q) m₁ * ⇑(clifford_algebra.ι Q) m₂ * x) _) (x : clifford_algebra Q) (hx : x ∈ clifford_algebra.even_odd Q 1) : P x hx"
        },
        {
          "sim_score": 0.42162370681762695,
          "doc_string": "A sum can be partitioned into a sum of sums, each equivalent under a setoid.",
          "statement": "theorem finset.sum_partition {β : Type u} {α : Type v} {s : finset α} {f : α → β} [add_comm_monoid β] (R : setoid α) [decidable_rel setoid.r] : s.sum (λ (x : α), f x) = (finset.image quotient.mk s).sum (λ (xbar : quotient R), (finset.filter (λ (y : α), ⟦y⟧ = xbar) s).sum (λ (y : α), f y))"
        },
        {
          "sim_score": 0.4164368808269501,
          "doc_string": "Distinct elements of a set of sets partitioning α are disjoint.",
          "statement": "theorem setoid.eqv_classes_disjoint {α : Type u_1} {c : set (set α)} (H : ∀ (a : α), ∃! (b : set α) (H : b ∈ c), a ∈ b) : c.pairwise_disjoint id"
        }
      ],
      "codex_time": 12.19458099399344,
      "search_time": 1.4897750779928174,
      "use_theorem_name": false
    },
    "outputs": [
      "partitions.equiv_oddeven_distinct {n : ℕ} : (partitions.equiv_oddeven n).card = (partitions.distinct_part_of_n_ge_2 n).card ",
      "{α : Type u_1} (h : α → α → Prop) (h_ext : ∀ (x y z w : α), x = y → z = w → h x z → h y w) (h_refl : ∀ (x : α), h x x) (h_sym : ∀ (x y : α), h x y → h y x) (h_trans : ∀ {x y z : α}, h x y → h y z → h x z) (hrel : ∀ (a b : α) (H : h a b), h a a ∨ h b b) (h_iff : ∀ (a b",
      "(n : ℕ) : (partition_set.filter partition.odd n).card = (partition_set.filter partition.distinct_parts n).card ",
      "{α : Type u_1} {c : ℕ → Set (Set α)} (H : ∀ (n : ℕ), ∀ (a : ℕ), a ∈ c n → ∃! (b : Set α) (H : b ∈ c n), a ∈ b) : has_unique_sum_of_parts α c ",
      "{α : Type u_1} {c : ℕ → Setₓ (Setₓ α)} (H : ∀ (n : ℕ), ∀ (a : ℕ), a ∈ c n → ∃! (b : Setₓ α) (H : b ∈ c n), a ∈ b) : has_unique_sum_of_parts α c ",
      "{p : ℕ} {R : Type*} {M : Type*} [CommRing R] [AddCommGroup M] [Module R M] (Q : QuadraticForm R M) : finset.card (possible_even_odd_partitions Q p) = finset.card (Finset.filter distinct (possible_partitions Q p)) ",
      "{p : ℕ} {R : Type*} {M : Type*} [CommRing R] [AddCommGroupₓₓ M] [Module R M] (Q : QuadraticForm R M) : finset.card (possible_even_odd_partitions Q p) = finset.card (Finset.filter distinct (possible_partitions Q p)) ",
      "{p : ℕ} {R : Type*} {M : Type*} [CommRingₓₓ R] [AddCommGroup M] [Module R M] (Q : QuadraticForm R M) : finset.card (possible_even_odd_partitions Q p) = finset.card (Finset.filter distinct (possible_partitions Q p)) ",
      "{p : ℕ} {R : Type*} {M : Type*} [CommRingₓₓ R] [AddCommGroupₓₓ M] [Module R M] (Q : QuadraticForm R M) : finset.card (possible_even_odd_partitions Q p) = finset.card (Finset.filter distinct (possible_partitions Q p)) ",
      "{p : ℕ} {R : Type*} {M : Type*} [CommRing R] [AddCommGroupₓ M] [Module R M] (Q : QuadraticForm R M) : finset.card (possible_even_odd_partitions Q p) = finset.card (Finset.filter distinct (possible_partitions Q p)) ",
      "{p : ℕ} {R : Type*} {M : Type*} [CommRingₓₓ R] [AddCommGroupₓ M] [Module R M] (Q : QuadraticForm R M) : finset.card (possible_even_odd_partitions Q p) = finset.card (Finset.filter distinct (possible_partitions Q p)) ",
      "{p : ℕ} {R : Type*} {M : Type*} [CommRingₓ R] [AddCommGroup M] [Module R M] (Q : QuadraticForm R M) : finset.card (possible_even_odd_partitions Q p) = finset.card (Finset.filter distinct (possible_partitions Q p)) ",
      "{p : ℕ} {R : Type*} {M : Type*} [CommRingₓ R] [AddCommGroupₓₓ M] [Module R M] (Q : QuadraticForm R M) : finset.card (possible_even_odd_partitions Q p) = finset.card (Finset.filter distinct (possible_partitions Q p)) ",
      "{p : ℕ} {R : Type*} {M : Type*} [CommRingₓ R] [AddCommGroupₓ M] [Module R M] (Q : QuadraticForm R M) : finset.card (possible_even_odd_partitions Q p) = finset.card (Finset.filter distinct (possible_partitions Q p)) "
    ],
    "answer": ": ∀ n : ℕ, Finset.card (Nat.Partition.odds n) = Finset.card (Nat.Partition.distincts n) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "partition_odd_distincts",
      "main_prompt": "The number of partitions with odd parts is equal to the number of partitions with distinct parts.",
      "prompt": "Natural language version: \"The number of partitions with odd parts is equal to the number of partitions with distinct parts.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 6.451756244990975,
      "use_theorem_name": false
    },
    "outputs": [
      "odd_eq_distinct' (n : ℕ ) :     #{ oddpartitions n } = #{ distinctpartitions n } ",
      "natural_language_to_lean : ∃ n : ℕ, ∃z : ℕ, 1 + n - (z ^ 2) = 0 ",
      "natural_to_lean : -- Add your answer here  example (m n : ℕ) : m + n ≥ m ",
      "finpartdistinct {s : Finset ℕ} (h : ∀ p ∈ s, p ∉ s.erase p) : finset.card s = finset.card (finset.univ.filter    (λ p, p ∉ s)) ",
      "odd_parts_iff_distinct_parts (n : ℕ) : nat.partition_count_aux n 1 Black = nat.partition_count_aux n 0 Green "
    ],
    "answer": ": ∀ n : ℕ, Finset.card (Nat.Partition.odds n) = Finset.card (Nat.Partition.distincts n) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "zorn",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every non-empty poset in which every chain has an upper bound contains a maximal element.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every non-empty poset in which every chain has an upper bound contains a maximal element.",
      "codex_time": 11.430125957995187,
      "use_theorem_name": false
    },
    "outputs": [
      "(P : Type*) [PartialOrder P]  (h : ∀ T : Set P, (∀ x ∈ T, ∀ y ∈ T, x ≤ y ∨ y ≤ x) → Nonempty T → ∃ z : P, ∀ x ∈ T, x ≤ z) :  (∃ m : P, ∀ x : P, m ≤ x → x = m) ∨ (∃ y, ∀ x : P, x ≤ y) ",
      "(P : Type*) [PartialOrderₓₓ P]  (h : ∀ T : Set P, (∀ x ∈ T, ∀ y ∈ T, x ≤ y ∨ y ≤ x) → Nonempty T → ∃ z : P, ∀ x ∈ T, x ≤ z) :  (∃ m : P, ∀ x : P, m ≤ x → x = m) ∨ (∃ y, ∀ x : P, x ≤ y) ",
      "(P : Type*) [PartialOrder P]  (h : ∀ T : Setₓ P, (∀ x ∈ T, ∀ y ∈ T, x ≤ y ∨ y ≤ x) → Nonempty T → ∃ z : P, ∀ x ∈ T, x ≤ z) :  (∃ m : P, ∀ x : P, m ≤ x → x = m) ∨ (∃ y, ∀ x : P, x ≤ y) ",
      "(P : Type*) [PartialOrderₓₓ P]  (h : ∀ T : Setₓ P, (∀ x ∈ T, ∀ y ∈ T, x ≤ y ∨ y ≤ x) → Nonempty T → ∃ z : P, ∀ x ∈ T, x ≤ z) :  (∃ m : P, ∀ x : P, m ≤ x → x = m) ∨ (∃ y, ∀ x : P, x ≤ y) ",
      "(P : Type*) [PartialOrderₓ P]  (h : ∀ T : Set P, (∀ x ∈ T, ∀ y ∈ T, x ≤ y ∨ y ≤ x) → Nonempty T → ∃ z : P, ∀ x ∈ T, x ≤ z) :  (∃ m : P, ∀ x : P, m ≤ x → x = m) ∨ (∃ y, ∀ x : P, x ≤ y) ",
      "(P : Type*) [PartialOrderₓ P]  (h : ∀ T : Setₓ P, (∀ x ∈ T, ∀ y ∈ T, x ≤ y ∨ y ≤ x) → Nonempty T → ∃ z : P, ∀ x ∈ T, x ≤ z) :  (∃ m : P, ∀ x : P, m ≤ x → x = m) ∨ (∃ y, ∀ x : P, x ≤ y) ",
      "(P : Type*) [PartialOrder P]  (H : ∀ c : Set P, Nonempty c → ∃ z : P, is_upper_bound c z) :  Nonempty P ",
      "(P : Type*) [PartialOrderₓₓ P]  (H : ∀ c : Set P, Nonempty c → ∃ z : P, is_upper_bound c z) :  Nonempty P ",
      "(P : Type*) [PartialOrder P]  (H : ∀ c : Setₓ P, Nonempty c → ∃ z : P, is_upper_bound c z) :  Nonempty P ",
      "(P : Type*) [PartialOrderₓₓ P]  (H : ∀ c : Setₓ P, Nonempty c → ∃ z : P, is_upper_bound c z) :  Nonempty P ",
      "(P : Type*) [PartialOrderₓ P]  (H : ∀ c : Set P, Nonempty c → ∃ z : P, is_upper_bound c z) :  Nonempty P ",
      "(P : Type*) [PartialOrderₓ P]  (H : ∀ c : Setₓ P, Nonempty c → ∃ z : P, is_upper_bound c z) :  Nonempty P ",
      "(X : Type*) [PartialOrder X] (hX_nonempty : Nonempty X)  (h : ∀ (x : ℕ → X), (∀ i j, i ≤ j → x i ≤ x j) →  ∃ (x : X), ∀ y, x ≤ y → (∃ i, x = x i) ) :  ∃ (x0 : X), ∀ y : X, x0 ≤ y → x0 = y ",
      "(X : Type*) [PartialOrderₓₓ X] (hX_nonempty : Nonempty X)  (h : ∀ (x : ℕ → X), (∀ i j, i ≤ j → x i ≤ x j) →  ∃ (x : X), ∀ y, x ≤ y → (∃ i, x = x i) ) :  ∃ (x0 : X), ∀ y : X, x0 ≤ y → x0 = y ",
      "(X : Type*) [PartialOrderₓ X] (hX_nonempty : Nonempty X)  (h : ∀ (x : ℕ → X), (∀ i j, i ≤ j → x i ≤ x j) →  ∃ (x : X), ∀ y, x ≤ y → (∃ i, x = x i) ) :  ∃ (x0 : X), ∀ y : X, x0 ≤ y → x0 = y ",
      "(X : Type*) [PartialOrder X] {C : X → Prop}  (hC : ∀ x : X, C x → ∃ z : X, z ≥ x ∧ ∀ y : X, y ≥ x → y ≥ z) :  ∃ (x : X), C x ∧ ∀ y : X, y ≥ x → y = x ",
      "(X : Type*) [PartialOrderₓₓ X] {C : X → Prop}  (hC : ∀ x : X, C x → ∃ z : X, z ≥ x ∧ ∀ y : X, y ≥ x → y ≥ z) :  ∃ (x : X), C x ∧ ∀ y : X, y ≥ x → y = x ",
      "(X : Type*) [PartialOrderₓ X] {C : X → Prop}  (hC : ∀ x : X, C x → ∃ z : X, z ≥ x ∧ ∀ y : X, y ≥ x → y ≥ z) :  ∃ (x : X), C x ∧ ∀ y : X, y ≥ x → y = x ",
      "(P : Type*) [poset P] (h : ∀ X : Set P, chain X → ∃ b, is_upper_bound X b) :  ∃ m : P, ∀ a : P, ¬(is_upper_bound (insert m Empty) a)  ",
      "(P : Type*) [poset P] (h : ∀ X : Setₓ P, chain X → ∃ b, is_upper_bound X b) :  ∃ m : P, ∀ a : P, ¬(is_upper_bound (insert m Empty) a)  "
    ],
    "answer": "{α : Type _} [PartialOrder α] [Nonempty α] : (∀ c : Set α, IsChain LE.le c → (∃ b : α, ∀ a ∈ c, a ≤ b)) → (∃ m : α, ∀ a : α, m ≤ a → a = m) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "zorn",
      "main_prompt": "Every non-empty poset in which every chain has an upper bound contains a maximal element.",
      "prompt": "Natural language version: \" **Zorn's lemma**  If every chain has an upper bound, then there exists a maximal element.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} {r : α → α → Prop} (h : ∀ (c : set α), is_chain r c → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) (trans : ∀ {a b c : α}, r a b → r b c → r a c) :\n∃ (m : α), ∀ (a : α), r m a → r a m := \n\nNatural language version: \" A variant of Zorn's lemma. If every nonempty chain of a nonempty type has an upper bound, then there is a maximal element.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} {r : α → α → Prop} [nonempty α] (h : ∀ (c : set α), is_chain r c → c.nonempty → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) (trans : ∀ {a b c : α}, r a b → r b c → r a c) :\n∃ (m : α), ∀ (a : α), r m a → r a m := \n\nNatural language version: \"Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} {r : α → α → Prop} {c : set α} (hc : is_chain r c) :\n∃ (M : set α), is_max_chain r M ∧ c ⊆ M := \n\nNatural language version: \" The Sup of a non-empty set is its least upper bound for a conditionally complete lattice with a top.\" Translate the natural language version to a Lean mathlib version:\n theorem {β : Type u_1} [conditionally_complete_lattice β] {s : set (with_top β)} (hs : s.nonempty) :\nis_lub s (has_Sup.Sup s) := \n\nNatural language version: \"Every non-empty poset in which every chain has an upper bound contains a maximal element.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.8077962398529053,
          "doc_string": " **Zorn's lemma**  If every chain has an upper bound, then there exists a maximal element.",
          "statement": "theorem exists_maximal_of_chains_bounded {α : Type u_1} {r : α → α → Prop} (h : ∀ (c : set α), is_chain r c → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) (trans : ∀ {a b c : α}, r a b → r b c → r a c) : ∃ (m : α), ∀ (a : α), r m a → r a m"
        },
        {
          "sim_score": 0.782833456993103,
          "doc_string": " A variant of Zorn's lemma. If every nonempty chain of a nonempty type has an upper bound, then there is a maximal element.",
          "statement": "theorem exists_maximal_of_nonempty_chains_bounded {α : Type u_1} {r : α → α → Prop} [nonempty α] (h : ∀ (c : set α), is_chain r c → c.nonempty → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) (trans : ∀ {a b c : α}, r a b → r b c → r a c) : ∃ (m : α), ∀ (a : α), r m a → r a m"
        },
        {
          "sim_score": 0.6981233954429626,
          "doc_string": "Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle.",
          "statement": "theorem is_chain.exists_max_chain {α : Type u_1} {r : α → α → Prop} {c : set α} (hc : is_chain r c) : ∃ (M : set α), is_max_chain r M ∧ c ⊆ M"
        },
        {
          "sim_score": 0.6111599206924438,
          "doc_string": " The Sup of a non-empty set is its least upper bound for a conditionally complete lattice with a top.",
          "statement": "theorem with_top.is_lub_Sup' {β : Type u_1} [conditionally_complete_lattice β] {s : set (with_top β)} (hs : s.nonempty) : is_lub s (has_Sup.Sup s)"
        }
      ],
      "codex_time": 9.46299122797791,
      "search_time": 1.4935360020026565,
      "use_theorem_name": false
    },
    "outputs": [
      "{α : Type u_1} {r : α → α → Prop} [CompleteLattice α] [Nonempty α] [PartialOrder r] : (∀ (c : Set α), IsChain r c → c.nonempty → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) →  ∃ (m : α), ∀ (a : α), r m a → r a m ",
      "{α : Type u_1} {r : α → α → Prop} [CompleteLattice α] [Nonempty α] [PartialOrderₓₓ r] : (∀ (c : Set α), IsChain r c → c.nonempty → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) →  ∃ (m : α), ∀ (a : α), r m a → r a m ",
      "{α : Type u_1} {r : α → α → Prop} [CompleteLattice α] [Nonempty α] [PartialOrder r] : (∀ (c : Setₓ α), IsChain r c → c.nonempty → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) →  ∃ (m : α), ∀ (a : α), r m a → r a m ",
      "{α : Type u_1} {r : α → α → Prop} [CompleteLattice α] [Nonempty α] [PartialOrderₓₓ r] : (∀ (c : Setₓ α), IsChain r c → c.nonempty → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) →  ∃ (m : α), ∀ (a : α), r m a → r a m ",
      "{α : Type u_1} {r : α → α → Prop} [CompleteLattice α] [Nonempty α] [PartialOrderₓ r] : (∀ (c : Set α), IsChain r c → c.nonempty → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) →  ∃ (m : α), ∀ (a : α), r m a → r a m ",
      "{α : Type u_1} {r : α → α → Prop} [CompleteLattice α] [Nonempty α] [PartialOrderₓ r] : (∀ (c : Setₓ α), IsChain r c → c.nonempty → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) →  ∃ (m : α), ∀ (a : α), r m a → r a m ",
      "{α : Type u_1} {r : α → α → Prop} [CompleteLatticeₓ α] [Nonempty α] [PartialOrder r] : (∀ (c : Set α), IsChain r c → c.nonempty → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) →  ∃ (m : α), ∀ (a : α), r m a → r a m ",
      "{α : Type u_1} {r : α → α → Prop} [CompleteLatticeₓ α] [Nonempty α] [PartialOrderₓₓ r] : (∀ (c : Set α), IsChain r c → c.nonempty → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) →  ∃ (m : α), ∀ (a : α), r m a → r a m ",
      "{α : Type u_1} {r : α → α → Prop} [CompleteLatticeₓ α] [Nonempty α] [PartialOrder r] : (∀ (c : Setₓ α), IsChain r c → c.nonempty → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) →  ∃ (m : α), ∀ (a : α), r m a → r a m ",
      "{α : Type u_1} {r : α → α → Prop} [CompleteLatticeₓ α] [Nonempty α] [PartialOrderₓₓ r] : (∀ (c : Setₓ α), IsChain r c → c.nonempty → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) →  ∃ (m : α), ∀ (a : α), r m a → r a m ",
      "{α : Type u_1} {r : α → α → Prop} [CompleteLatticeₓ α] [Nonempty α] [PartialOrderₓ r] : (∀ (c : Set α), IsChain r c → c.nonempty → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) →  ∃ (m : α), ∀ (a : α), r m a → r a m ",
      "{α : Type u_1} {r : α → α → Prop} [CompleteLatticeₓ α] [Nonempty α] [PartialOrderₓ r] : (∀ (c : Setₓ α), IsChain r c → c.nonempty → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) →  ∃ (m : α), ∀ (a : α), r m a → r a m ",
      "{α : Type u_1} {r : α → α → Prop} [PartialOrder α] (h : ∀ (c : Set α), IsChain r c → (∃ (ub : α), ∀ (a : α), a ∈ c → a ≤ ub)) (Trans : ∀ (a b c : α), a ≤ b → b ≤ c → a ≤ c) : ∃ (m : α), is_maximal m ",
      "{α : Type u_1} {r : α → α → Prop} [PartialOrderₓₓ α] (h : ∀ (c : Set α), IsChain r c → (∃ (ub : α), ∀ (a : α), a ∈ c → a ≤ ub)) (Trans : ∀ (a b c : α), a ≤ b → b ≤ c → a ≤ c) : ∃ (m : α), is_maximal m ",
      "{α : Type u_1} {r : α → α → Prop} [PartialOrder α] (h : ∀ (c : Setₓ α), IsChain r c → (∃ (ub : α), ∀ (a : α), a ∈ c → a ≤ ub)) (Trans : ∀ (a b c : α), a ≤ b → b ≤ c → a ≤ c) : ∃ (m : α), is_maximal m ",
      "{α : Type u_1} {r : α → α → Prop} [PartialOrderₓₓ α] (h : ∀ (c : Setₓ α), IsChain r c → (∃ (ub : α), ∀ (a : α), a ∈ c → a ≤ ub)) (Trans : ∀ (a b c : α), a ≤ b → b ≤ c → a ≤ c) : ∃ (m : α), is_maximal m ",
      "{α : Type u_1} {r : α → α → Prop} [PartialOrderₓ α] (h : ∀ (c : Set α), IsChain r c → (∃ (ub : α), ∀ (a : α), a ∈ c → a ≤ ub)) (Trans : ∀ (a b c : α), a ≤ b → b ≤ c → a ≤ c) : ∃ (m : α), is_maximal m ",
      "{α : Type u_1} {r : α → α → Prop} [PartialOrderₓ α] (h : ∀ (c : Setₓ α), IsChain r c → (∃ (ub : α), ∀ (a : α), a ∈ c → a ≤ ub)) (Trans : ∀ (a b c : α), a ≤ b → b ≤ c → a ≤ c) : ∃ (m : α), is_maximal m ",
      "{α : Type u_1} {r : α → α → Prop} (h : ∀ {c : Set α}, c.nonempty → IsChain r c → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) : ∃ (m : α), (∀ (a : α), r m a → r a m) ∧ ∀ (n : α), (∀ (a : α), r m a → r a m) → r n m → r n n ",
      "{α : Type u_1} {r : α → α → Prop} (h : ∀ {c : Setₓ α}, c.nonempty → IsChain r c → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) : ∃ (m : α), (∀ (a : α), r m a → r a m) ∧ ∀ (n : α), (∀ (a : α), r m a → r a m) → r n m → r n n ",
      "{β : Type u_1} [poset β] {p : β} (h : ∀ (c : Set β), IsChain (≤) c → c.nonempty → (∃ (ub : β), ∀ (a : β), a ∈ c → a ≤ ub)) : ∃ (m : β), ∀ (a : β), p ≤ a → a ≤ p ",
      "{β : Type u_1} [poset β] {p : β} (h : ∀ (c : Setₓ β), IsChain (≤) c → c.nonempty → (∃ (ub : β), ∀ (a : β), a ∈ c → a ≤ ub)) : ∃ (m : β), ∀ (a : β), p ≤ a → a ≤ p ",
      "{α : Type u_1} {r : α → α → Prop} {P : Set α} (hp : ∀ (c : Set α), IsChain r c → chain_upper_bound c r P) (hc : chain_upper_bound c r P) : ∃ (m : α), ∀ (a : α), r m a → r a m ",
      "{α : Type u_1} {r : α → α → Prop} {P : Setₓ α} (hp : ∀ (c : Setₓ α), IsChain r c → chain_upper_bound c r P) (hc : chain_upper_bound c r P) : ∃ (m : α), ∀ (a : α), r m a → r a m "
    ],
    "answer": "{α : Type _} [PartialOrder α] [Nonempty α] : (∀ c : Set α, IsChain LE.le c → (∃ b : α, ∀ a ∈ c, a ≤ b)) → (∃ m : α, ∀ a : α, m ≤ a → a = m) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "zorn",
      "main_prompt": "Every non-empty poset in which every chain has an upper bound contains a maximal element.",
      "prompt": "Natural language version: \"Every non-empty poset in which every chain has an upper bound contains a maximal element.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 7.002985528000863,
      "use_theorem_name": false
    },
    "outputs": [
      "zorn' {α : Type*} (h : ∀ c:Set α, c.chain → c.nonempty → ∃ m:α, is_maximal c m) :   ∃ m : α, is_maximal α m ",
      "zorn' {α : Type*} (h : ∀ c:Setₓ α, c.chain → c.nonempty → ∃ m:α, is_maximal c m) :   ∃ m : α, is_maximal α m ",
      "maximal_element_of_nonempty_poset { α : Type u } [ PartialOrder α ] ( h : 0 < Cardinal α ) ( h_chain : ∀ { β : Type u } [ PartialOrder β ], ( ∀ ( b : β ), b ≠ 0 ) → β ≠ 0 → β ≤ Cardinal α ) : ∃ m , is_maximal m ",
      "maximal_element_of_nonempty_poset { α : Type u } [ PartialOrderₓₓ α ] ( h : 0 < Cardinal α ) ( h_chain : ∀ { β : Type u } [ PartialOrderₓₓ β ], ( ∀ ( b : β ), b ≠ 0 ) → β ≠ 0 → β ≤ Cardinal α ) : ∃ m , is_maximal m ",
      "maximal_element_of_nonempty_poset { α : Type u } [ PartialOrderₓ α ] ( h : 0 < Cardinal α ) ( h_chain : ∀ { β : Type u } [ PartialOrderₓ β ], ( ∀ ( b : β ), b ≠ 0 ) → β ≠ 0 → β ≤ Cardinal α ) : ∃ m , is_maximal m ",
      "zorn (P : Type) (PartialOrder P) [LE P] [DecidableRel (≤)] (chain : Type) (chain_fnc : chain → P)     (upper_bnd : Π c ⊆ chain, (Π (x y : c), x ≤ y → y ≤ x → y = x) → (Π x : c, ∃ u : P, ∀ y ∈ c, y ≤ u) → P)     (h : ∃ c' ⊆ chain, ∀ x, x ≤ chain_fnc x) : ∃ m ∈ P, ∀ y ∈ P, m",
      "zorn (P : Type) (PartialOrderₓₓ P) [LE P] [DecidableRel (≤)] (chain : Type) (chain_fnc : chain → P)     (upper_bnd : Π c ⊆ chain, (Π (x y : c), x ≤ y → y ≤ x → y = x) → (Π x : c, ∃ u : P, ∀ y ∈ c, y ≤ u) → P)     (h : ∃ c' ⊆ chain, ∀ x, x ≤ chain_fnc x) : ∃ m ∈ P, ∀ y ∈ P, m",
      "zorn (P : Type) (PartialOrderₓ P) [LE P] [DecidableRel (≤)] (chain : Type) (chain_fnc : chain → P)     (upper_bnd : Π c ⊆ chain, (Π (x y : c), x ≤ y → y ≤ x → y = x) → (Π x : c, ∃ u : P, ∀ y ∈ c, y ≤ u) → P)     (h : ∃ c' ⊆ chain, ∀ x, x ≤ chain_fnc x) : ∃ m ∈ P, ∀ y ∈ P, m",
      "Zorn' { R : Type u } [ PartialOrder R ]     ( H : ∀ C ⊆ R , ( ∀ a b ∈ C , a ≤ b ∨ b ≤ a ) → ∃ x ∈ R , ∀ y ∈ C , y ≤ x ) :     ∃ x ∈ R , ∀ y \\in R , y ≤ x ",
      "Zorn' { R : Type u } [ PartialOrderₓₓ R ]     ( H : ∀ C ⊆ R , ( ∀ a b ∈ C , a ≤ b ∨ b ≤ a ) → ∃ x ∈ R , ∀ y ∈ C , y ≤ x ) :     ∃ x ∈ R , ∀ y \\in R , y ≤ x ",
      "Zorn' { R : Type u } [ PartialOrderₓ R ]     ( H : ∀ C ⊆ R , ( ∀ a b ∈ C , a ≤ b ∨ b ≤ a ) → ∃ x ∈ R , ∀ y ∈ C , y ≤ x ) :     ∃ x ∈ R , ∀ y \\in R , y ≤ x ",
      "noetherian.choice_lemma {S : Set α} (H : Nonempty (⋃₀ s ∈ S, [⋂₀ t ∈ s, t])) : ∃ s∈S, ∀ t ∈ S, t ⊆ s ",
      "noetherian.choice_lemma {S : Setₓ α} (H : Nonempty (⋃₀ s ∈ S, [⋂₀ t ∈ s, t])) : ∃ s∈S, ∀ t ∈ S, t ⊆ s "
    ],
    "answer": "{α : Type _} [PartialOrder α] [Nonempty α] : (∀ c : Set α, IsChain LE.le c → (∃ b : α, ∀ a ∈ c, a ≤ b)) → (∃ m : α, ∀ a : α, m ≤ a → a = m) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "aut_group_cyclic_implies_abelian",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"A group whose automorphism group is cyclic is Abelian.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A group whose automorphism group is cyclic is Abelian.",
      "codex_time": 9.990242988977116,
      "use_theorem_name": false
    },
    "outputs": [
      "(G : Type*) [Group G] (β : G → G)  (hβ : Function.bijective β) (hβ1 : ∀ x : G, β x * β (x⁻¹) = 1)  (hβ2 : ∀ x y : G, β (x * y) = β x * β y)  (hβ3 : ∀ x : G, β x * x * (β x)⁻¹ = 1) (H : Type*) [Group H]  (g : G → H) (hg : Function.bijective g) (hg2 : ∀ x y : G, g (x",
      "(G : Type*) [Groupₓₓ G] (β : G → G)  (hβ : Function.bijective β) (hβ1 : ∀ x : G, β x * β (x⁻¹) = 1)  (hβ2 : ∀ x y : G, β (x * y) = β x * β y)  (hβ3 : ∀ x : G, β x * x * (β x)⁻¹ = 1) (H : Type*) [Groupₓₓ H]  (g : G → H) (hg : Function.bijective g) (hg2 : ∀ x y : G, g (x",
      "(G : Type*) [Groupₓ G] (β : G → G)  (hβ : Function.bijective β) (hβ1 : ∀ x : G, β x * β (x⁻¹) = 1)  (hβ2 : ∀ x y : G, β (x * y) = β x * β y)  (hβ3 : ∀ x : G, β x * x * (β x)⁻¹ = 1) (H : Type*) [Groupₓ H]  (g : G → H) (hg : Function.bijective g) (hg2 : ∀ x y : G, g (x",
      "(G : Type*) [Group G]  (hG : ∃ g : G → G, Function.bijective g ∧ ∀ x y : G, g (x * y) = g x * g y):  abelian G ",
      "(G : Type*) [Groupₓₓ G]  (hG : ∃ g : G → G, Function.bijective g ∧ ∀ x y : G, g (x * y) = g x * g y):  abelian G ",
      "(G : Type*) [Groupₓ G]  (hG : ∃ g : G → G, Function.bijective g ∧ ∀ x y : G, g (x * y) = g x * g y):  abelian G ",
      "(G : Type*) [Group G]  (H : group_with_aut G) (H1 : ∀ (G₂ : Type*) [Group G₂], G ≃* G₂ → Abelian_group G₂) :  @is_abelian_group G G _ ",
      "(G : Type*) [Groupₓₓ G]  (H : group_with_aut G) (H1 : ∀ (G₂ : Type*) [Groupₓₓ G₂], G ≃* G₂ → Abelian_group G₂) :  @is_abelian_group G G _ ",
      "(G : Type*) [Groupₓ G]  (H : group_with_aut G) (H1 : ∀ (G₂ : Type*) [Groupₓ G₂], G ≃* G₂ → Abelian_group G₂) :  @is_abelian_group G G _ ",
      "(G : Type*) [Group G] (H : Type*) [Group H] (f : G → H)  (hf : Function.bijective f) (hf_iso : IsGroupHom f)  (hint : ∃ (g_aut : H → H), Function.bijective g_aut ∧ IsGroupHom g_aut ∧  (∃ (n : ℕ), ∀ h : H, g_aut h = h ^ n)) :  Abelian G ",
      "(G : Type*) [Groupₓₓ G] (H : Type*) [Groupₓₓ H] (f : G → H)  (hf : Function.bijective f) (hf_iso : IsGroupHom f)  (hint : ∃ (g_aut : H → H), Function.bijective g_aut ∧ IsGroupHom g_aut ∧  (∃ (n : ℕ), ∀ h : H, g_aut h = h ^ n)) :  Abelian G ",
      "(G : Type*) [Groupₓ G] (H : Type*) [Groupₓ H] (f : G → H)  (hf : Function.bijective f) (hf_iso : IsGroupHom f)  (hint : ∃ (g_aut : H → H), Function.bijective g_aut ∧ IsGroupHom g_aut ∧  (∃ (n : ℕ), ∀ h : H, g_aut h = h ^ n)) :  Abelian G ",
      "(G : Type*) [Group G] (haut : ∃ g : G, IsGroupHom (automorphism_of_equiv G g)):  abelian_group G ",
      "(G : Type*) [Groupₓₓ G] (haut : ∃ g : G, IsGroupHom (automorphism_of_equiv G g)):  abelian_group G ",
      "(G : Type*) [Groupₓ G] (haut : ∃ g : G, IsGroupHom (automorphism_of_equiv G g)):  abelian_group G "
    ],
    "answer": "{G : Type _} [Groupₓ G] : CategoryTheory.Aut G → CommGroup G "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "aut_group_cyclic_implies_abelian",
      "main_prompt": "A group whose automorphism group is cyclic is Abelian.",
      "prompt": "Natural language version: \"A finite group of prime order is cyclic.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) :\nis_cyclic α := \n\nNatural language version: \"Every subgroup of `ℤ` is cyclic.\" Translate the natural language version to a Lean mathlib version:\n theorem (H : add_subgroup ℤ) :\n∃ (a : ℤ), H = add_subgroup.closure {a} := \n\nNatural language version: \"A finite subgroup of the unit group of an integral domain is cyclic.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G →* R) (hf : function.injective ⇑f) :\nis_cyclic G := \n\nNatural language version: \"The product of group homomorphisms is a group homomorphism if the target is commutative.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} {β : Type u_2} [group α] [comm_group β] {f g : α → β} (hf : is_group_hom f) (hg : is_group_hom g) :\nis_group_hom (λ (a : α), f a * g a) := \n\nNatural language version: \"A group whose automorphism group is cyclic is Abelian.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6319984793663025,
          "doc_string": "A finite group of prime order is cyclic.",
          "statement": "theorem is_cyclic_of_prime_card {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_cyclic α"
        },
        {
          "sim_score": 0.6267713308334351,
          "doc_string": "Every subgroup of `ℤ` is cyclic.",
          "statement": "theorem int.subgroup_cyclic (H : add_subgroup ℤ) : ∃ (a : ℤ), H = add_subgroup.closure {a}"
        },
        {
          "sim_score": 0.5008938312530518,
          "doc_string": "A finite subgroup of the unit group of an integral domain is cyclic.",
          "statement": "theorem is_cyclic_of_subgroup_is_domain {R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G →* R) (hf : function.injective ⇑f) : is_cyclic G"
        },
        {
          "sim_score": 0.4840320944786072,
          "doc_string": "The product of group homomorphisms is a group homomorphism if the target is commutative.",
          "statement": "theorem is_group_hom.mul {α : Type u_1} {β : Type u_2} [group α] [comm_group β] {f g : α → β} (hf : is_group_hom f) (hg : is_group_hom g) : is_group_hom (λ (a : α), f a * g a)"
        }
      ],
      "codex_time": 7.3680931930139195,
      "search_time": 1.7266927709861193,
      "use_theorem_name": false
    },
    "outputs": [
      "{α : Type u} [Group α] (h : IsCyclic (aut α)) : CommGroup α ",
      "{α : Type u} [Group α] (h : IsCyclic (aut α)) : CommGroupₓₓ α ",
      "{α : Type u} [Groupₓₓ α] (h : IsCyclic (aut α)) : CommGroup α ",
      "{α : Type u} [Groupₓₓ α] (h : IsCyclic (aut α)) : CommGroupₓₓ α ",
      "{α : Type u} [Groupₓ α] (h : IsCyclic (aut α)) : CommGroup α ",
      "{α : Type u} [Groupₓ α] (h : IsCyclic (aut α)) : CommGroupₓₓ α ",
      "{α : Type u} [Group α] (h : IsCyclic (aut α)) : CommGroupₓ α ",
      "{α : Type u} [Groupₓₓ α] (h : IsCyclic (aut α)) : CommGroupₓ α ",
      "{α : Type u} [Groupₓ α] (h : IsCyclic (aut α)) : CommGroupₓ α ",
      "{α : Type u} [Group α] (h : IsCyclic (group_aut α)) : CommGroup α ",
      "{α : Type u} [Group α] (h : IsCyclic (group_aut α)) : CommGroupₓₓ α ",
      "{α : Type u} [Groupₓₓ α] (h : IsCyclic (group_aut α)) : CommGroup α ",
      "{α : Type u} [Groupₓₓ α] (h : IsCyclic (group_aut α)) : CommGroupₓₓ α ",
      "{α : Type u} [Groupₓ α] (h : IsCyclic (group_aut α)) : CommGroup α ",
      "{α : Type u} [Groupₓ α] (h : IsCyclic (group_aut α)) : CommGroupₓₓ α ",
      "{α : Type u} [Group α] (h : IsCyclic (group_aut α)) : CommGroupₓ α ",
      "{α : Type u} [Groupₓₓ α] (h : IsCyclic (group_aut α)) : CommGroupₓ α ",
      "{α : Type u} [Groupₓ α] (h : IsCyclic (group_aut α)) : CommGroupₓ α ",
      "{α : Type u} [Group α] (H : IsCyclic (aut G)) : CommGroup α ",
      "{α : Type u} [Group α] (H : IsCyclic (aut G)) : CommGroupₓₓ α ",
      "{α : Type u} [Groupₓₓ α] (H : IsCyclic (aut G)) : CommGroup α ",
      "{α : Type u} [Groupₓₓ α] (H : IsCyclic (aut G)) : CommGroupₓₓ α ",
      "{α : Type u} [Groupₓ α] (H : IsCyclic (aut G)) : CommGroup α ",
      "{α : Type u} [Groupₓ α] (H : IsCyclic (aut G)) : CommGroupₓₓ α ",
      "{α : Type u} [Group α] (H : IsCyclic (aut G)) : CommGroupₓ α ",
      "{α : Type u} [Groupₓₓ α] (H : IsCyclic (aut G)) : CommGroupₓ α ",
      "{α : Type u} [Groupₓ α] (H : IsCyclic (aut G)) : CommGroupₓ α ",
      "{α : Type u} [Group α] {aut : Group (group_aut α)} (h : IsCyclic aut) : is_abelian α ",
      "{α : Type u} [Groupₓₓ α] {aut : Groupₓₓ (group_aut α)} (h : IsCyclic aut) : is_abelian α ",
      "{α : Type u} [Groupₓ α] {aut : Groupₓ (group_aut α)} (h : IsCyclic aut) : is_abelian α ",
      "(G : Type u) [Group G] (H : Type u) [Group H] (f : G →+* H) (hf : is_group_isomorphism f)   (Hₛ : IsCyclic (group_automorphisms_of H)) : CommGroup G ",
      "(G : Type u) [Group G] (H : Type u) [Group H] (f : G →+* H) (hf : is_group_isomorphism f)   (Hₛ : IsCyclic (group_automorphisms_of H)) : CommGroupₓₓ G ",
      "(G : Type u) [Groupₓₓ G] (H : Type u) [Groupₓₓ H] (f : G →+* H) (hf : is_group_isomorphism f)   (Hₛ : IsCyclic (group_automorphisms_of H)) : CommGroup G ",
      "(G : Type u) [Groupₓₓ G] (H : Type u) [Groupₓₓ H] (f : G →+* H) (hf : is_group_isomorphism f)   (Hₛ : IsCyclic (group_automorphisms_of H)) : CommGroupₓₓ G ",
      "(G : Type u) [Groupₓ G] (H : Type u) [Groupₓ H] (f : G →+* H) (hf : is_group_isomorphism f)   (Hₛ : IsCyclic (group_automorphisms_of H)) : CommGroup G ",
      "(G : Type u) [Groupₓ G] (H : Type u) [Groupₓ H] (f : G →+* H) (hf : is_group_isomorphism f)   (Hₛ : IsCyclic (group_automorphisms_of H)) : CommGroupₓₓ G ",
      "(G : Type u) [Group G] (H : Type u) [Group H] (f : G →+* H) (hf : is_group_isomorphism f)   (Hₛ : IsCyclic (group_automorphisms_of H)) : CommGroupₓ G ",
      "(G : Type u) [Groupₓₓ G] (H : Type u) [Groupₓₓ H] (f : G →+* H) (hf : is_group_isomorphism f)   (Hₛ : IsCyclic (group_automorphisms_of H)) : CommGroupₓ G ",
      "(G : Type u) [Groupₓ G] (H : Type u) [Groupₓ H] (f : G →+* H) (hf : is_group_isomorphism f)   (Hₛ : IsCyclic (group_automorphisms_of H)) : CommGroupₓ G "
    ],
    "answer": "{G : Type _} [Groupₓ G] : CategoryTheory.Aut G → CommGroup G "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "aut_group_cyclic_implies_abelian",
      "main_prompt": "A group whose automorphism group is cyclic is Abelian.",
      "prompt": "Natural language version: \"A group whose automorphism group is cyclic is Abelian.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 10.55459084600443,
      "use_theorem_name": false
    },
    "outputs": [
      "is_abelian (G : Type) [Group G] [is_cyclic_group G] : abelian_group G ",
      "is_abelian (G : Type) [Groupₓₓ G] [is_cyclic_group G] : abelian_group G ",
      "is_abelian (G : Type) [Groupₓ G] [is_cyclic_group G] : abelian_group G ",
      "do_what_the_theorem_says {G : Type u} [Group G] [Fintype G] : ∀(s : Set G),     s.finite → s.aut_group.is_cyclic → s.is_abelian ",
      "do_what_the_theorem_says {G : Type u} [Groupₓₓ G] [Fintype G] : ∀(s : Set G),     s.finite → s.aut_group.is_cyclic → s.is_abelian ",
      "do_what_the_theorem_says {G : Type u} [Group G] [Fintype G] : ∀(s : Setₓ G),     s.finite → s.aut_group.is_cyclic → s.is_abelian ",
      "do_what_the_theorem_says {G : Type u} [Groupₓₓ G] [Fintype G] : ∀(s : Setₓ G),     s.finite → s.aut_group.is_cyclic → s.is_abelian ",
      "do_what_the_theorem_says {G : Type u} [Groupₓ G] [Fintype G] : ∀(s : Set G),     s.finite → s.aut_group.is_cyclic → s.is_abelian ",
      "do_what_the_theorem_says {G : Type u} [Groupₓ G] [Fintype G] : ∀(s : Setₓ G),     s.finite → s.aut_group.is_cyclic → s.is_abelian ",
      "do_what_the_theorem_says {G : Type u} [Group G] [Fintypeₓ G] : ∀(s : Set G),     s.finite → s.aut_group.is_cyclic → s.is_abelian ",
      "do_what_the_theorem_says {G : Type u} [Groupₓₓ G] [Fintypeₓ G] : ∀(s : Set G),     s.finite → s.aut_group.is_cyclic → s.is_abelian ",
      "do_what_the_theorem_says {G : Type u} [Group G] [Fintypeₓ G] : ∀(s : Setₓ G),     s.finite → s.aut_group.is_cyclic → s.is_abelian ",
      "do_what_the_theorem_says {G : Type u} [Groupₓₓ G] [Fintypeₓ G] : ∀(s : Setₓ G),     s.finite → s.aut_group.is_cyclic → s.is_abelian ",
      "do_what_the_theorem_says {G : Type u} [Groupₓ G] [Fintypeₓ G] : ∀(s : Set G),     s.finite → s.aut_group.is_cyclic → s.is_abelian ",
      "do_what_the_theorem_says {G : Type u} [Groupₓ G] [Fintypeₓ G] : ∀(s : Setₓ G),     s.finite → s.aut_group.is_cyclic → s.is_abelian ",
      "abelian_cyclic_automorphism_group (G : Type) [Group G] [Fintype G] : cyclic_group (group_aut G) → Abelian_group G ",
      "abelian_cyclic_automorphism_group (G : Type) [Groupₓₓ G] [Fintype G] : cyclic_group (group_aut G) → Abelian_group G ",
      "abelian_cyclic_automorphism_group (G : Type) [Groupₓ G] [Fintype G] : cyclic_group (group_aut G) → Abelian_group G ",
      "abelian_cyclic_automorphism_group (G : Type) [Group G] [Fintypeₓ G] : cyclic_group (group_aut G) → Abelian_group G ",
      "abelian_cyclic_automorphism_group (G : Type) [Groupₓₓ G] [Fintypeₓ G] : cyclic_group (group_aut G) → Abelian_group G ",
      "abelian_cyclic_automorphism_group (G : Type) [Groupₓ G] [Fintypeₓ G] : cyclic_group (group_aut G) → Abelian_group G ",
      "finGroup.cyclic_aut_is_Abelian. [Group α]  (G : finGroup α)  (hG : finGroup.cyclic β)  (a : α)  (hab : a ∈ finGroup.to_set β)  [facts : IsGroupHom (hat : β → α) ]  [factt : Function.Injective hat ]  [factr : ∀ (a b : β), hat (a * b) = hat a * hat b]  [factl : ∀ (a : β), hat (1 • a) = 1 • hat a]  (ha : ∀ x, hat x = hat",
      "finGroup.cyclic_aut_is_Abelian. [Groupₓₓ α]  (G : finGroup α)  (hG : finGroup.cyclic β)  (a : α)  (hab : a ∈ finGroup.to_set β)  [facts : IsGroupHom (hat : β → α) ]  [factt : Function.Injective hat ]  [factr : ∀ (a b : β), hat (a * b) = hat a * hat b]  [factl : ∀ (a : β), hat (1 • a) = 1 • hat a]  (ha : ∀ x, hat x = hat",
      "finGroup.cyclic_aut_is_Abelian. [Groupₓ α]  (G : finGroup α)  (hG : finGroup.cyclic β)  (a : α)  (hab : a ∈ finGroup.to_set β)  [facts : IsGroupHom (hat : β → α) ]  [factt : Function.Injective hat ]  [factr : ∀ (a b : β), hat (a * b) = hat a * hat b]  [factl : ∀ (a : β), hat (1 • a) = 1 • hat a]  (ha : ∀ x, hat x = hat",
      "group_cyclic_aut_equals_comm (G : Type) [Group G] [cc : Fintype G] [DecidableEq G] [Hc : nontrivial_comm G]      ⦃H : CommGroup G⦄ (Hac : comm_group.aut (card G) G )  : ∀a b : G, abel_group.mul_comm a b ",
      "group_cyclic_aut_equals_comm (G : Type) [Group G] [cc : Fintype G] [DecidableEq G] [Hc : nontrivial_comm G]      ⦃H : CommGroupₓₓ G⦄ (Hac : comm_group.aut (card G) G )  : ∀a b : G, abel_group.mul_comm a b ",
      "group_cyclic_aut_equals_comm (G : Type) [Groupₓₓ G] [cc : Fintype G] [DecidableEq G] [Hc : nontrivial_comm G]      ⦃H : CommGroup G⦄ (Hac : comm_group.aut (card G) G )  : ∀a b : G, abel_group.mul_comm a b ",
      "group_cyclic_aut_equals_comm (G : Type) [Groupₓₓ G] [cc : Fintype G] [DecidableEq G] [Hc : nontrivial_comm G]      ⦃H : CommGroupₓₓ G⦄ (Hac : comm_group.aut (card G) G )  : ∀a b : G, abel_group.mul_comm a b ",
      "group_cyclic_aut_equals_comm (G : Type) [Groupₓ G] [cc : Fintype G] [DecidableEq G] [Hc : nontrivial_comm G]      ⦃H : CommGroup G⦄ (Hac : comm_group.aut (card G) G )  : ∀a b : G, abel_group.mul_comm a b ",
      "group_cyclic_aut_equals_comm (G : Type) [Groupₓ G] [cc : Fintype G] [DecidableEq G] [Hc : nontrivial_comm G]      ⦃H : CommGroupₓₓ G⦄ (Hac : comm_group.aut (card G) G )  : ∀a b : G, abel_group.mul_comm a b ",
      "group_cyclic_aut_equals_comm (G : Type) [Group G] [cc : Fintype G] [DecidableEq G] [Hc : nontrivial_comm G]      ⦃H : CommGroupₓ G⦄ (Hac : comm_group.aut (card G) G )  : ∀a b : G, abel_group.mul_comm a b ",
      "group_cyclic_aut_equals_comm (G : Type) [Groupₓₓ G] [cc : Fintype G] [DecidableEq G] [Hc : nontrivial_comm G]      ⦃H : CommGroupₓ G⦄ (Hac : comm_group.aut (card G) G )  : ∀a b : G, abel_group.mul_comm a b ",
      "group_cyclic_aut_equals_comm (G : Type) [Groupₓ G] [cc : Fintype G] [DecidableEq G] [Hc : nontrivial_comm G]      ⦃H : CommGroupₓ G⦄ (Hac : comm_group.aut (card G) G )  : ∀a b : G, abel_group.mul_comm a b ",
      "group_cyclic_aut_equals_comm (G : Type) [Group G] [cc : Fintypeₓ G] [DecidableEq G] [Hc : nontrivial_comm G]      ⦃H : CommGroup G⦄ (Hac : comm_group.aut (card G) G )  : ∀a b : G, abel_group.mul_comm a b ",
      "group_cyclic_aut_equals_comm (G : Type) [Group G] [cc : Fintypeₓ G] [DecidableEq G] [Hc : nontrivial_comm G]      ⦃H : CommGroupₓₓ G⦄ (Hac : comm_group.aut (card G) G )  : ∀a b : G, abel_group.mul_comm a b ",
      "group_cyclic_aut_equals_comm (G : Type) [Groupₓₓ G] [cc : Fintypeₓ G] [DecidableEq G] [Hc : nontrivial_comm G]      ⦃H : CommGroup G⦄ (Hac : comm_group.aut (card G) G )  : ∀a b : G, abel_group.mul_comm a b ",
      "group_cyclic_aut_equals_comm (G : Type) [Groupₓₓ G] [cc : Fintypeₓ G] [DecidableEq G] [Hc : nontrivial_comm G]      ⦃H : CommGroupₓₓ G⦄ (Hac : comm_group.aut (card G) G )  : ∀a b : G, abel_group.mul_comm a b ",
      "group_cyclic_aut_equals_comm (G : Type) [Groupₓ G] [cc : Fintypeₓ G] [DecidableEq G] [Hc : nontrivial_comm G]      ⦃H : CommGroup G⦄ (Hac : comm_group.aut (card G) G )  : ∀a b : G, abel_group.mul_comm a b ",
      "group_cyclic_aut_equals_comm (G : Type) [Groupₓ G] [cc : Fintypeₓ G] [DecidableEq G] [Hc : nontrivial_comm G]      ⦃H : CommGroupₓₓ G⦄ (Hac : comm_group.aut (card G) G )  : ∀a b : G, abel_group.mul_comm a b ",
      "group_cyclic_aut_equals_comm (G : Type) [Group G] [cc : Fintypeₓ G] [DecidableEq G] [Hc : nontrivial_comm G]      ⦃H : CommGroupₓ G⦄ (Hac : comm_group.aut (card G) G )  : ∀a b : G, abel_group.mul_comm a b ",
      "group_cyclic_aut_equals_comm (G : Type) [Groupₓₓ G] [cc : Fintypeₓ G] [DecidableEq G] [Hc : nontrivial_comm G]      ⦃H : CommGroupₓ G⦄ (Hac : comm_group.aut (card G) G )  : ∀a b : G, abel_group.mul_comm a b ",
      "group_cyclic_aut_equals_comm (G : Type) [Groupₓ G] [cc : Fintypeₓ G] [DecidableEq G] [Hc : nontrivial_comm G]      ⦃H : CommGroupₓ G⦄ (Hac : comm_group.aut (card G) G )  : ∀a b : G, abel_group.mul_comm a b "
    ],
    "answer": "{G : Type _} [Groupₓ G] : CategoryTheory.Aut G → CommGroup G "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "image_union",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"The image of a union of sets is the union of the images.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The image of a union of sets is the union of the images.",
      "codex_time": 13.686756782000884,
      "use_theorem_name": false
    },
    "outputs": [
      "(R S : Type*) [Ring R] (f : S → R) (a b : Set S):     f '' (a ∪ b) = f '' a ∪ f '' b ",
      "(R S : Type*) [Ringₓₓ R] (f : S → R) (a b : Set S):     f '' (a ∪ b) = f '' a ∪ f '' b ",
      "(R S : Type*) [Ring R] (f : S → R) (a b : Setₓ S):     f '' (a ∪ b) = f '' a ∪ f '' b ",
      "(R S : Type*) [Ringₓₓ R] (f : S → R) (a b : Setₓ S):     f '' (a ∪ b) = f '' a ∪ f '' b ",
      "(R S : Type*) [Ringₓ R] (f : S → R) (a b : Set S):     f '' (a ∪ b) = f '' a ∪ f '' b ",
      "(R S : Type*) [Ringₓ R] (f : S → R) (a b : Setₓ S):     f '' (a ∪ b) = f '' a ∪ f '' b ",
      "(A : Type u) (B : Type v) (f : A → B)  (a : Set A) (b : Set (Set A)) (h : a ∈ b) :  f '' (⋃₀ b) = (⋃₀ (image f b)) ",
      "(A : Type u) (B : Type v) (f : A → B)  (a : Setₓ A) (b : Setₓ (Setₓ A)) (h : a ∈ b) :  f '' (⋃₀ b) = (⋃₀ (image f b)) ",
      "(X Y Z : Type*) [has_emptyc X] [has_emptyc Y]  [has_inter X] [has_inter Y] [has_union Y] [has_uinter Y]  [has_union Z] [has_uinter Z]  [has_unionc X] [has_unionc Y]  [has_unionc Z] [has_emptyc Z]  [has_emptyc (X × Y)] [has_inter (X × Y)] [has_union (X × Y)]  [has_uinter (X × Y)] [has_unionc (X × Y)]  [has_emptyc (Y ×",
      "(A B C : Type*) [Nonempty A] [Nonempty B] [Nonempty C]   (f : A → B) (g : A → C) (a : Set A) :   f '' (a ∪ g ⁻¹' a) = f '' a ∪ g ⁻¹' (f '' a) ",
      "(A B C : Type*) [Nonempty A] [Nonempty B] [Nonempty C]   (f : A → B) (g : A → C) (a : Setₓ A) :   f '' (a ∪ g ⁻¹' a) = f '' a ∪ g ⁻¹' (f '' a) ",
      "(X Y : Type*) [TopologicalSpace X] [TopologicalSpace Y]  (A B : Set X) (f : X → Y) :  f '' (A ∪ B) = f '' A ∪ f '' B ",
      "(X Y : Type*) [TopologicalSpace X] [TopologicalSpace Y]  (A B : Setₓ X) (f : X → Y) :  f '' (A ∪ B) = f '' A ∪ f '' B "
    ],
    "answer": "(f : α → β) (S : Set (Set α)) : (f <$> (⋃₀ S)) = (⋃₀ ((Functor.map f) <$> S)) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "image_union",
      "main_prompt": "The image of a union of sets is the union of the images.",
      "prompt": "Natural language version: \" The cardinality of a union is at most the sum of the cardinalities of the two sets.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} (S T : set α) :\ncardinal.mk ↥(S ∪ T) ≤ cardinal.mk ↥S + cardinal.mk ↥T := \n\nNatural language version: \" This rather trivial consequence of `subset_Union`is convenient with `apply`, and has `i` explicit for this purpose.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} {ι : Sort u_4} {s : set α} {t : ι → set α} (i : ι) (h : s ⊆ t i) :\ns ⊆ ⋃ (i : ι), t i := \n\nNatural language version: \"The union of two sets is bounded iff each of the sets is bounded.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [pseudo_metric_space α] {s t : set α} :\nmetric.bounded (s ∪ t) ↔ metric.bounded s ∧ metric.bounded t := \n\nNatural language version: \"The span of a union of sets is the sup of their spans.\" Translate the natural language version to a Lean mathlib version:\n theorem (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s t : set P) :\naffine_span k (s ∪ t) = affine_span k s ⊔ affine_span k t := \n\nNatural language version: \"The image of a union of sets is the union of the images.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6315420866012573,
          "doc_string": " The cardinality of a union is at most the sum of the cardinalities of the two sets.",
          "statement": "theorem cardinal.mk_union_le {α : Type u} (S T : set α) : cardinal.mk ↥(S ∪ T) ≤ cardinal.mk ↥S + cardinal.mk ↥T"
        },
        {
          "sim_score": 0.5471856594085693,
          "doc_string": " This rather trivial consequence of `subset_Union`is convenient with `apply`, and has `i` explicit for this purpose.",
          "statement": "theorem set.subset_Union_of_subset {α : Type u_1} {ι : Sort u_4} {s : set α} {t : ι → set α} (i : ι) (h : s ⊆ t i) : s ⊆ ⋃ (i : ι), t i"
        },
        {
          "sim_score": 0.5332727432250977,
          "doc_string": "The union of two sets is bounded iff each of the sets is bounded.",
          "statement": "theorem metric.bounded_union {α : Type u} [pseudo_metric_space α] {s t : set α} : metric.bounded (s ∪ t) ↔ metric.bounded s ∧ metric.bounded t"
        },
        {
          "sim_score": 0.5295044779777527,
          "doc_string": "The span of a union of sets is the sup of their spans.",
          "statement": "theorem affine_subspace.span_union (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s t : set P) : affine_span k (s ∪ t) = affine_span k s ⊔ affine_span k t"
        }
      ],
      "codex_time": 8.4119693050161,
      "search_time": 1.472945643006824,
      "use_theorem_name": false
    },
    "outputs": [
      "{α : Sort u} (s t : Set α) {β : Sort v} (f : α → β) : f '' (s ∪ t) = f '' s ∪ f '' t ",
      "{α : Sort u} (s t : Setₓ α) {β : Sort v} (f : α → β) : f '' (s ∪ t) = f '' s ∪ f '' t ",
      "(. 𝓝(s ∪ t)) = (. 𝓝(s)) ∪ (. 𝓝(t)) ",
      "{α β : Type u} {s : Set (α × β)} {a : Set α} {b : Set β} (h : s = {p : (α × β) | p.1 ∈ a ∧ p.2 ∈ b}) : finset.univ.image p.1 ∪ finset.univ.image p.2 = finset.univ.image (⇑h).1 ",
      "{α β : Type u} {s : Setₓ (α × β)} {a : Setₓ α} {b : Setₓ β} (h : s = {p : (α × β) | p.1 ∈ a ∧ p.2 ∈ b}) : finset.univ.image p.1 ∪ finset.univ.image p.2 = finset.univ.image (⇑h).1 ",
      "{α : Type u} {β : Type v} {δ : Type w} [_inst_1 : Group δ] (f : α → δ → β) (s t : Set α) : ∀ g, f '' (s ∪ t) g = (f '' s) g ∪ (f '' t) g ",
      "{α : Type u} {β : Type v} {δ : Type w} [_inst_1 : Groupₓₓ δ] (f : α → δ → β) (s t : Set α) : ∀ g, f '' (s ∪ t) g = (f '' s) g ∪ (f '' t) g ",
      "{α : Type u} {β : Type v} {δ : Type w} [_inst_1 : Group δ] (f : α → δ → β) (s t : Setₓ α) : ∀ g, f '' (s ∪ t) g = (f '' s) g ∪ (f '' t) g ",
      "{α : Type u} {β : Type v} {δ : Type w} [_inst_1 : Groupₓₓ δ] (f : α → δ → β) (s t : Setₓ α) : ∀ g, f '' (s ∪ t) g = (f '' s) g ∪ (f '' t) g ",
      "{α : Type u} {β : Type v} {δ : Type w} [_inst_1 : Groupₓ δ] (f : α → δ → β) (s t : Set α) : ∀ g, f '' (s ∪ t) g = (f '' s) g ∪ (f '' t) g ",
      "{α : Type u} {β : Type v} {δ : Type w} [_inst_1 : Groupₓ δ] (f : α → δ → β) (s t : Setₓ α) : ∀ g, f '' (s ∪ t) g = (f '' s) g ∪ (f '' t) g ",
      "(α : Type u) (β : Type v) (s₁ t₁ : Set α) (s₂ t₂ : Set β) (f : α → β) : f '' (s₁ ∪ t₁) = f '' s₁ ∪ f '' t₁ ↔ ∀ (a : α) (a_in_s : a ∈ s₁) (a_in_t : a ∈ t₁), f a ∈ s₂ ∨ f a ∈ t₂ ",
      "(α : Type u) (β : Type v) (s₁ t₁ : Setₓ α) (s₂ t₂ : Setₓ β) (f : α → β) : f '' (s₁ ∪ t₁) = f '' s₁ ∪ f '' t₁ ↔ ∀ (a : α) (a_in_s : a ∈ s₁) (a_in_t : a ∈ t₁), f a ∈ s₂ ∨ f a ∈ t₂ "
    ],
    "answer": "(f : α → β) (S : Set (Set α)) : (f <$> (⋃₀ S)) = (⋃₀ ((Functor.map f) <$> S)) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "image_union",
      "main_prompt": "The image of a union of sets is the union of the images.",
      "prompt": "Natural language version: \"The image of a union of sets is the union of the images.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 7.611687933007488,
      "use_theorem_name": false
    },
    "outputs": [
      "natlang :  ∀ (R' : X→Y→Prop) (r:R) (A B : Set X), im (union R A B) r = union (λ y, ∃ x₁ x₂, x₁ ∈ A ∧ x₂ ∈ B ∧ pair X fst snd x₁ x₂ = y) (im A r) (im B r) ",
      "natlang :  ∀ (R' : X→Y→Prop) (r:R) (A B : Setₓ X), im (union R A B) r = union (λ y, ∃ x₁ x₂, x₁ ∈ A ∧ x₂ ∈ B ∧ pair X fst snd x₁ x₂ = y) (im A r) (im B r) ",
      "image_union_eq {α β : Type*} (f : α → β) (s t : Set α) : f '' (s ∪ t) = f '' s ∪ f '' t .  Lemma image_union_eq :   ∀ {α β : Type*} (f : α → β) (s t : Set α), f '' (s ∪ t) = f '' s ∪ f '' t.  Proof.   Show Proof.     intros α β f s t.   apply ext.   intros y.   Show Proof.     unfold image at 2.   Show Proof.   ",
      "image_union_eq {α β : Type*} (f : α → β) (s t : Setₓ α) : f '' (s ∪ t) = f '' s ∪ f '' t .  Lemma image_union_eq :   ∀ {α β : Type*} (f : α → β) (s t : Setₓ α), f '' (s ∪ t) = f '' s ∪ f '' t.  Proof.   Show Proof.     intros α β f s t.   apply ext.   intros y.   Show Proof.     unfold image at 2.   Show Proof.   ",
      "union_image {α β : Type*} (f : α → β) (s : Set α) : f '' (⋃x ∈ s, {x}) = ⋃x ∈ s, {f x}",
      "union_image {α β : Type*} (f : α → β) (s : Setₓ α) : f '' (⋃x ∈ s, {x}) = ⋃x ∈ s, {f x}",
      "Set .image_union { α β } ( f : α → β ) : { s : Set α // is_measurable s } ⟶ ⊤    ",
      "Setₓ .image_union { α β } ( f : α → β ) : { s : Setₓ α // is_measurable s } ⟶ ⊤    ",
      "← → : { f : α ↪ β } → { s : Set α } → { t : Set β } → · ⊆ Set' ( λ x , x ∈ s ",
      "← → : { f : α ↪ β } → { s : Setₓ α } → { t : Setₓ β } → · ⊆ Setₓ' ( λ x , x ∈ s "
    ],
    "answer": "(f : α → β) (S : Set (Set α)) : (f <$> (⋃₀ S)) = (⋃₀ ((Functor.map f) <$> S)) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "urysohn",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.",
      "codex_time": 9.59224843600532,
      "use_theorem_name": false
    },
    "outputs": [
      "(X : Type*) [TopologicalSpace X]  (hX : NormalSpace X) : ∀ F G : Set X, Disjoint F G →  ∃ (h : F → ℝ), Continuous h ∧ ∀ x, x ∈ F → h x ≠ 0 ∧ h1 x = 0 → x ∈ G ",
      "(X : Type*) [TopologicalSpace X]  (hX : NormalSpace X) : ∀ F G : Setₓ X, Disjoint F G →  ∃ (h : F → ℝ), Continuous h ∧ ∀ x, x ∈ F → h x ≠ 0 ∧ h1 x = 0 → x ∈ G ",
      "(X : Type*) [TopologicalSpace X]  (hnorm : ∀ A B : Set X, Disjoint A B →  ∃ U V : Set X, IsOpen U ∧ IsOpen V ∧ A ⊆ U ∧ B ⊆ V ∧ Disjoint U V) :  NormalSpace X ",
      "(X : Type*) [TopologicalSpace X]  (hnorm : ∀ A B : Setₓ X, Disjoint A B →  ∃ U V : Setₓ X, IsOpen U ∧ IsOpen V ∧ A ⊆ U ∧ B ⊆ V ∧ Disjoint U V) :  NormalSpace X ",
      "(X : Type*) [TopologicalSpace X] :  NormalSpace X ↔  ∀ C C' : Set X, IsClosed C → IsClosed C' → C ∩ C' = ∅ → ∃ f : X → ℝ,  Continuous f ∧ ∀ x ∈ C, f x = 0 ∧ ∀ x ∈ C', f x = 1 ",
      "(X : Type*) [TopologicalSpace X] :  NormalSpace X ↔  ∀ C C' : Setₓ X, IsClosed C → IsClosed C' → C ∩ C' = ∅ → ∃ f : X → ℝ,  Continuous f ∧ ∀ x ∈ C, f x = 0 ∧ ∀ x ∈ C', f x = 1 ",
      "(X : Type*) [TopologicalSpace X] (hX : NormalSpace X):  ∀ C D : Set X, Disjoint C D → bicontinuous (id : X → X) ",
      "(X : Type*) [TopologicalSpace X] (hX : NormalSpace X):  ∀ C D : Setₓ X, Disjoint C D → bicontinuous (id : X → X) ",
      "(X : Type*) [TopologicalSpace X] :  NormalSpace X ↔ ∀ (A B : Set X), IsClosed A → IsClosed B → Disjoint A B →  Nonempty (Set C ",
      "(X : Type*) [TopologicalSpace X] :  NormalSpace X ↔ ∀ (A B : Setₓ X), IsClosed A → IsClosed B → Disjoint A B →  Nonempty (Setₓ C "
    ],
    "answer": "{X : Type _} [TopologicalSpace X] [TopologicalSpace ℝ] : NormalSpace X ↔ ( ∀ {S T : Set X}, IsClosed S → IsClosed T → Disjoint S T → (∃ f : X → ℝ, Continuous f → (∀ x ∈ S, f x = 0) ∧ (∀ x ∈ T, f x = 1)) ) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "urysohn",
      "main_prompt": "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.",
      "prompt": "Natural language version: \" Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, then there exists a continuous function `f : X → ℝ` such that  * `f` equals zero on `s`; * `f` equals one on `t`; * `0 ≤ f x ≤ 1` for all `x`.\" Translate the natural language version to a Lean mathlib version:\n theorem {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) :\n∃ (f : bounded_continuous_function X ℝ), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1 := \n\nNatural language version: \" Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, then there exists a continuous function `f : X → ℝ` such that  * `f` equals zero on `s`; * `f` equals one on `t`; * `0 ≤ f x ≤ 1` for all `x`.\" Translate the natural language version to a Lean mathlib version:\n theorem {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) :\n∃ (f : C(X, ℝ)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1 := \n\nNatural language version: \" Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, and `a ≤ b` are two real numbers, then there exists a continuous function `f : X → ℝ` such that  * `f` equals `a` on `s`; * `f` equals `b` on `t`; * `a ≤ f x ≤ b` for all `x`.\" Translate the natural language version to a Lean mathlib version:\n theorem {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) {a b : ℝ} (hle : a ≤ b) :\n∃ (f : bounded_continuous_function X ℝ), set.eq_on ⇑f (function.const X a) s ∧ set.eq_on ⇑f (function.const X b) t ∧ ∀ (x : X), ⇑f x ∈ set.Icc a b := \n\nNatural language version: \"The topological closure of a normal subgroup is normal.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [topological_space G] [group G] [topological_group G] (N : subgroup G) [N.normal] :\nN.topological_closure.normal := \n\nNatural language version: \"A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.629673182964325,
          "doc_string": " Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, then there exists a continuous function `f : X → ℝ` such that  * `f` equals zero on `s`; * `f` equals one on `t`; * `0 ≤ f x ≤ 1` for all `x`.",
          "statement": "theorem exists_bounded_zero_one_of_closed {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : ∃ (f : bounded_continuous_function X ℝ), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1"
        },
        {
          "sim_score": 0.629673182964325,
          "doc_string": " Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, then there exists a continuous function `f : X → ℝ` such that  * `f` equals zero on `s`; * `f` equals one on `t`; * `0 ≤ f x ≤ 1` for all `x`.",
          "statement": "theorem exists_continuous_zero_one_of_closed {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : ∃ (f : C(X, ℝ)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1"
        },
        {
          "sim_score": 0.5748592615127563,
          "doc_string": " Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, and `a ≤ b` are two real numbers, then there exists a continuous function `f : X → ℝ` such that  * `f` equals `a` on `s`; * `f` equals `b` on `t`; * `a ≤ f x ≤ b` for all `x`.",
          "statement": "theorem exists_bounded_mem_Icc_of_closed_of_le {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) {a b : ℝ} (hle : a ≤ b) : ∃ (f : bounded_continuous_function X ℝ), set.eq_on ⇑f (function.const X a) s ∧ set.eq_on ⇑f (function.const X b) t ∧ ∀ (x : X), ⇑f x ∈ set.Icc a b"
        },
        {
          "sim_score": 0.5395680069923401,
          "doc_string": "The topological closure of a normal subgroup is normal.",
          "statement": "theorem subgroup.is_normal_topological_closure {G : Type u_1} [topological_space G] [group G] [topological_group G] (N : subgroup G) [N.normal] : N.topological_closure.normal"
        }
      ],
      "codex_time": 7.739471149980091,
      "search_time": 1.5973553500080016,
      "use_theorem_name": false
    },
    "outputs": [
      "{X : Type u_1} [TopologicalSpace X] : ∀ (s t : Set X), IsClosed s → IsClosed t → Disjoint s t → ∃ (f : C(X, ℝ)), Set.EqOn ⇑f 0 s ∧ Set.EqOn ⇑f 1 t ",
      "{X : Type u_1} [TopologicalSpace X] : ∀ (s t : Setₓ X), IsClosed s → IsClosed t → Disjoint s t → ∃ (f : C(X, ℝ)), Setₓ.EqOn ⇑f 0 s ∧ Setₓ.EqOn ⇑f 1 t ",
      "{X : Type u_1} [TopologicalSpace X] : NormalSpace X ↔ ∀ {s t : Set X} (hs : IsClosed s) (ht : IsClosed t) (hd : Disjoint s t), separated_by_continuous_function (Function.const X 0) s t ",
      "{X : Type u_1} [TopologicalSpace X] : NormalSpace X ↔ ∀ {s t : Setₓ X} (hs : IsClosed s) (ht : IsClosed t) (hd : Disjoint s t), separated_by_continuous_function (Function.const X 0) s t ",
      "{X : Type u_1} [TopologicalSpace X] : (is_normal X) ⇔ ∀ ⦃ s t : Set X ⦄, IsClosed s → IsClosed t → Disjoint s t → ∃ (f : X → ℝ), is_continuous f ∧ (∀ (x : X), f x ∈ Set.Icc (0 : ℝ) (1 : ℝ))   ∧ Set.EqOn f 0 s ∧ Set.EqOn f 1 t ",
      "{X : Type u_1} [TopologicalSpace X] : (is_normal X) ⇔ ∀ ⦃ s t : Setₓ X ⦄, IsClosed s → IsClosed t → Disjoint s t → ∃ (f : X → ℝ), is_continuous f ∧ (∀ (x : X), f x ∈ Setₓ.Icc (0 : ℝ) (1 : ℝ))   ∧ Setₓ.EqOn f 0 s ∧ Setₓ.EqOn f 1 t ",
      "{X : Type u_1} [TopologicalSpace X] : (∀ (s t : Set X), Disjoint s t → IsClosed s → IsClosed t → ∃ (f : C(X, ℝ)), Set.EqOn ⇑f 0 s ∧ Set.EqOn ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ Set.Icc 0 1) → NormalSpace X ",
      "{X : Type u_1} [TopologicalSpace X] : (∀ (s t : Setₓ X), Disjoint s t → IsClosed s → IsClosed t → ∃ (f : C(X, ℝ)), Setₓ.EqOn ⇑f 0 s ∧ Setₓ.EqOn ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ Setₓ.Icc 0 1) → NormalSpace X ",
      "{X : Type u_1} [TopologicalSpace X] : NormalSpace X ↔ ∀ s t : Set X, IsClosed s → IsClosed t → Disjoint s t → ∃ (f : C(X, ℝ)), Set.EqOn ⇑f 0 s ∧ Set.EqOn ⇑f 1 t ",
      "{X : Type u_1} [TopologicalSpace X] : NormalSpace X ↔ ∀ s t : Setₓ X, IsClosed s → IsClosed t → Disjoint s t → ∃ (f : C(X, ℝ)), Setₓ.EqOn ⇑f 0 s ∧ Setₓ.EqOn ⇑f 1 t "
    ],
    "answer": "{X : Type _} [TopologicalSpace X] [TopologicalSpace ℝ] : NormalSpace X ↔ ( ∀ {S T : Set X}, IsClosed S → IsClosed T → Disjoint S T → (∃ f : X → ℝ, Continuous f → (∀ x ∈ S, f x = 0) ∧ (∀ x ∈ T, f x = 1)) ) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "urysohn",
      "main_prompt": "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.",
      "prompt": "Natural language version: \"A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 7.936674150987528,
      "use_theorem_name": false
    },
    "outputs": [
      "normality_def: A space X is Normal if and only if ∀ A, B : closed_subset X, A ∩ B = ∅ → ∃ f: X we can define a Set A, a Set B, and a function f,  such that f(B) is Disjoint from A, and f(A) is a subset of B -/  section import topology.constructions universe u  IsOpen classical Set Lattice Ennreal  local attribute [instance] prop_decidable  --IsOpen TopologicalSpace open_locale classical TopologicalSpace variables (X Y : Type u) [TopologicalSpace",
      "normality_def: A space X is Normal if and only if ∀ A, B : closed_subset X, A ∩ B = ∅ → ∃ f: X we can define a Setₓ A, a Setₓ B, and a function f,  such that f(B) is Disjoint from A, and f(A) is a subset of B -/  section import topology.constructions universe u  IsOpen classical Setₓ Lattice Ennreal  local attribute [instance] prop_decidable  --IsOpen TopologicalSpace open_locale classical TopologicalSpace variables (X Y : Type u) [TopologicalSpace",
      "normality_def: A space X is Normal if and only if ∀ A, B : closed_subset X, A ∩ B = ∅ → ∃ f: X we can define a Set A, a Set B, and a function f,  such that f(B) is Disjoint from A, and f(A) is a subset of B -/  section import topology.constructions universe u  IsOpen classical Set Latticeₓ Ennreal  local attribute [instance] prop_decidable  --IsOpen TopologicalSpace open_locale classical TopologicalSpace variables (X Y : Type u) [TopologicalSpace",
      "normality_def: A space X is Normal if and only if ∀ A, B : closed_subset X, A ∩ B = ∅ → ∃ f: X we can define a Setₓ A, a Setₓ B, and a function f,  such that f(B) is Disjoint from A, and f(A) is a subset of B -/  section import topology.constructions universe u  IsOpen classical Setₓ Latticeₓ Ennreal  local attribute [instance] prop_decidable  --IsOpen TopologicalSpace open_locale classical TopologicalSpace variables (X Y : Type u) [TopologicalSpace",
      "schroeder_berstein { X : Type * } [ TopologicalSpace X ] ( seperable : ∃ ( sub : Set X ), IsSeparable sub ) : is_normal X ↔ ∀ ( A B : Set X ), IsClosed A → IsClosed B → Disjoint A B → ∃ ( f : X → ℝ ), Continuous f ∧ map f A ⊆ ( -∞ , 0 ) ∧ map f B ⊆ ( 0 , ∞ ) ",
      "schroeder_berstein { X : Type * } [ TopologicalSpace X ] ( seperable : ∃ ( sub : Setₓ X ), IsSeparable sub ) : is_normal X ↔ ∀ ( A B : Setₓ X ), IsClosed A → IsClosed B → Disjoint A B → ∃ ( f : X → ℝ ), Continuous f ∧ map f A ⊆ ( -∞ , 0 ) ∧ map f B ⊆ ( 0 , ∞ ) ",
      "is_normal (S : Type*) [TopologicalSpace S] : Prop ",
      "normal_of_separation [TopologicalSpace α] (s : Set α) (h : (separating_closed α) s) : Normal α ",
      "normal_of_separation [TopologicalSpace α] (s : Setₓ α) (h : (separating_closed α) s) : Normal α ",
      "normality_condition_prop :     ∀ X : Top.{u} ,     is_normal X ↔     ∀ A B : Set X ,       A.is_closed →       B.is_closed →       Disjoint A B →       ∃ f : X → ℝ ,       effective_function f ∧       (f '' A).is_closed ∧       (f '' B).is_complement_of (f '' A)  -- 2.  /- (a) Prove this theorem lean mathlib version: \"If a space is connected then any Continuous function from X to ℝ is constant",
      "normality_condition_prop :     ∀ X : Top.{u} ,     is_normal X ↔     ∀ A B : Setₓ X ,       A.is_closed →       B.is_closed →       Disjoint A B →       ∃ f : X → ℝ ,       effective_function f ∧       (f '' A).is_closed ∧       (f '' B).is_complement_of (f '' A)  -- 2.  /- (a) Prove this theorem lean mathlib version: \"If a space is connected then any Continuous function from X to ℝ is constant"
    ],
    "answer": "{X : Type _} [TopologicalSpace X] [TopologicalSpace ℝ] : NormalSpace X ↔ ( ∀ {S T : Set X}, IsClosed S → IsClosed T → Disjoint S T → (∃ f : X → ℝ, Continuous f → (∀ x ∈ S, f x = 0) ∧ (∀ x ∈ T, f x = 1)) ) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "real_field_aut_trivial",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"The only field automorphism of the reals is the identity.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The only field automorphism of the reals is the identity.",
      "codex_time": 8.221915528003592,
      "use_theorem_name": false
    },
    "outputs": [
      "(q : ℚ) (hq : q ≠ 0)  : Function.bijective (λ x:ℚ, x*q) ",
      "(R : Type*) [discrete_linear_ordered_field R] [Nontrivial R] :  ∀ f : R →+* R, ∀ x : R, f x = x ",
      ":  ∀ φ : ℝ →+* ℝ, φ = LinearMap.id ",
      "(f : ℝ ≃+* ℝ) : f = equiv.refl ℝ ",
      "(f : ℝ →ₐ[+] ℝ) (hf : Function.bijective f) (hf2 : ∀ a b : ℝ, f(a + b) = f(a) + f(b)) :  ∀ x : ℝ, f x = x "
    ],
    "answer": ": ∀ (f : ℝ ≃+* ℝ), (∀ x : ℝ, f x = x) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "real_field_aut_trivial",
      "main_prompt": "The only field automorphism of the reals is the identity.",
      "prompt": "Natural language version: \" There is at most one ordered ring isomorphism between a linear ordered field and an archimedean linear ordered field.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_2} {β : Type u_3} [linear_ordered_field α] [linear_ordered_field β] [archimedean β] :\nsubsingleton (α ≃+*o β) := \n\nNatural language version: \" There is at most one ordered ring isomorphism between an archimedean linear ordered field and a linear ordered field.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_2} {β : Type u_3} [linear_ordered_field α] [archimedean α] [linear_ordered_field β] :\nsubsingleton (α ≃+*o β) := \n\nNatural language version: \" There is at most one ordered ring homomorphism from a linear ordered field to an archimedean linear ordered field.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_2} {β : Type u_3} [linear_ordered_field α] [linear_ordered_field β] [archimedean β] :\nsubsingleton (α →+*o β) := \n\nNatural language version: \"The cardinality of the reals, as a type.\" Translate the natural language version to a Lean mathlib version:\n theorem  :\ncardinal.mk ℝ = cardinal.continuum := \n\nNatural language version: \"The only field automorphism of the reals is the identity.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5189149975776672,
          "doc_string": " There is at most one ordered ring isomorphism between a linear ordered field and an archimedean linear ordered field.",
          "statement": "theorem order_ring_iso.subsingleton_right {α : Type u_2} {β : Type u_3} [linear_ordered_field α] [linear_ordered_field β] [archimedean β] : subsingleton (α ≃+*o β)"
        },
        {
          "sim_score": 0.5125109553337097,
          "doc_string": " There is at most one ordered ring isomorphism between an archimedean linear ordered field and a linear ordered field.",
          "statement": "theorem order_ring_iso.subsingleton_left {α : Type u_2} {β : Type u_3} [linear_ordered_field α] [archimedean α] [linear_ordered_field β] : subsingleton (α ≃+*o β)"
        },
        {
          "sim_score": 0.4997551739215851,
          "doc_string": " There is at most one ordered ring homomorphism from a linear ordered field to an archimedean linear ordered field.",
          "statement": "theorem order_ring_hom.subsingleton {α : Type u_2} {β : Type u_3} [linear_ordered_field α] [linear_ordered_field β] [archimedean β] : subsingleton (α →+*o β)"
        },
        {
          "sim_score": 0.4784242510795593,
          "doc_string": "The cardinality of the reals, as a type.",
          "statement": "theorem cardinal.mk_real  : cardinal.mk ℝ = cardinal.continuum"
        }
      ],
      "codex_time": 2.867950686981203,
      "search_time": 1.4932327840069775,
      "use_theorem_name": false
    },
    "outputs": [
      "{f : ℝ →+* ℝ} (hf : Function.bijective f) : is_field_hom ⟨f, hf.injective⟩ ",
      " : Fintype { f : ℝ → ℝ // f.aut } ",
      " : Fintypeₓ { f : ℝ → ℝ // f.aut } ",
      " {f : ℝ →+* ℝ} (hf : Function.bijective f) : f = LinearMap.id ",
      " : Subsingleton {f : ℝ →+* ℝ // f.bijective} ",
      ": finset.univ.filter (λ (f : Π {α : Type*}, α → α), Function.Injective f ∧ (∀ a ⦃b : ℝ⦄, (f a = f b) ↔ a = b)) = {⟨id, id_inj _, λ _ _, iff.rfl⟩} "
    ],
    "answer": ": ∀ (f : ℝ ≃+* ℝ), (∀ x : ℝ, f x = x) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "real_field_aut_trivial",
      "main_prompt": "The only field automorphism of the reals is the identity.",
      "prompt": "Natural language version: \"The only field automorphism of the reals is the identity.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 9.60327520701685,
      "use_theorem_name": false
    },
    "outputs": [
      "field_automorphisms.extendable_to_homomorphism_reals_id : ∀ (F : Type u) [Field F] (f : F →+* F)       [linear_equiv.{u} F F] (hf : inj f), f = linear_equiv.to_fun (linear_equiv.refl F) ",
      "field_automorphism_of_real_is_id : ∀ (f : ℝ ≃+* ℝ), f = by sorry  Is this  legal?  It's legal but not complete. You need to replace the by sorry with actual equalities between functions.  rintros ⟨f,_⟩,  (Here ⟨f,_⟩ is the way you destruct the isomorphism of complete fields. You can alternatively use {f} in place of ⟨f,_⟩, but the explicitness of ⟨f,_⟩ is nice if you're not used to working with isomorphisms of fields",
      "only_id_field_automorphism_of_reals : sorry ",
      "reals_field_automorphism_equiv_id : ∀ α : reals, α ≃ * :   theorem reals_field_automorphism_equiv_id :  Function.bijective f :  variable h1 : ∀ x, f x ≠ 0 :  variable h2 : ∀ x y, f (x * y) = f x * f y :  variable h3 : ∀ x y, f (x + y) = f x + f y :  variable h_id : ∀ x, f x = x variable h_inj :  h_inj (f x) (f y)   ",
      "eq_of_field_aut { f : ℝ → ℝ } ( h : ∀ x y , f ( x + y ) = f x + f y ) : f = id  This theorem is a good example of writing mathematical proofs with a tactical proof. Take a look at h : ∀ (x y : ℝ), f (x + y) = f x + f y  and note that this is a universal quantification, which Lean's fancy roman font sorts of hints at. Consequently for this quantifier to be True in general, it has to be True for all values of the variable. This is what generalization accomplishes - it takes an element of the variable's type"
    ],
    "answer": ": ∀ (f : ℝ ≃+* ℝ), (∀ x : ℝ, f x = x) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "period_three_implies_chaos",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.",
      "codex_time": 8.720532843988622,
      "use_theorem_name": false
    },
    "outputs": [
      "(s : {x // 0 ≤ x ∧ x ≤ 1}) (f : {x // 0 ≤ x ∧ x ≤ 1} → {x // 0 ≤ x ∧ x ≤ 1})  (hf : f s = s) : ∀ n : ℕ, ∃ t : {x // 0 ≤ x ∧ x ≤ 1}, f ^ n t = t ",
      "(f : [0, 1] → [0, 1]) (h1 : ∃ x : ℝ, x ∈ Icc (0, 1) ∧ f x = x) :  ∀ n : ℕ, ∃ x : ℝ, x ∈ Icc (0, 1) ∧ f ^ n x = x ",
      "(f : [0, 1] → [0, 1])  (h3 : ∃ p, f (f (f p)) = p) :  ∃ s: ℕ, ∃ p, ∀ n, f (f (f (... (f p) ...))) = p ",
      "(f : I → I) (h_p3 : ∃ x : I, f (f (f x)) = x) (n : ℕ) (hn : 3 ∣ n): ∃ x : I, f ^[n] x = x ",
      "(f : ℝ → ℝ) (H_periodic_3 : f ((f (f (0 : ℝ)) = 0)) :  ∃ n : ℕ, ∀ a b : ℝ, (1 : ℝ) > b - a → f (a) = f (a + n) "
    ],
    "answer": ": ∀ f : Set.Icc 0 1 → Set.Icc 0 1, (∃ x : Set.Icc 0 1, Function.IsPeriodicPt f 3 x) → (∀ n : ℕ, n > 0 → ∃ y : Set.Icc 0 1, Function.IsPeriodicPt f n y) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "period_three_implies_chaos",
      "main_prompt": "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.",
      "prompt": "Natural language version: \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some  `y ∈ Ico 0 c` such that `f x = f y`.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x : α) :\n∃ (y : α) (H : y ∈ set.Ico 0 c), f x = f y := \n\nNatural language version: \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some  `y ∈ Ico a (a + c)` such that `f x = f y`.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x a : α) :\n∃ (y : α) (H : y ∈ set.Ico a (a + c)), f x = f y := \n\nNatural language version: \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some  `y ∈ Ioc a (a + c)` such that `f x = f y`.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x a : α) :\n∃ (y : α) (H : y ∈ set.Ioc a (a + c)), f x = f y := \n\nNatural language version: \" If `f` sends two periodic points `x` and `y` of positive periods to the same point, then `x = y`.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} {f : α → α} {x y : α} {m n : ℕ} (hx : function.is_periodic_pt f m x) (hy : function.is_periodic_pt f n y) (hm : 0 < m) (hn : 0 < n) (h : f x = f y) :\nx = y := \n\nNatural language version: \"If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6410606503486633,
          "doc_string": "If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some  `y ∈ Ico 0 c` such that `f x = f y`.",
          "statement": "theorem function.periodic.exists_mem_Ico₀ {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x : α) : ∃ (y : α) (H : y ∈ set.Ico 0 c), f x = f y"
        },
        {
          "sim_score": 0.6367848515510559,
          "doc_string": "If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some  `y ∈ Ico a (a + c)` such that `f x = f y`.",
          "statement": "theorem function.periodic.exists_mem_Ico {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x a : α) : ∃ (y : α) (H : y ∈ set.Ico a (a + c)), f x = f y"
        },
        {
          "sim_score": 0.6170958876609802,
          "doc_string": "If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some  `y ∈ Ioc a (a + c)` such that `f x = f y`.",
          "statement": "theorem function.periodic.exists_mem_Ioc {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x a : α) : ∃ (y : α) (H : y ∈ set.Ioc a (a + c)), f x = f y"
        },
        {
          "sim_score": 0.5864872932434082,
          "doc_string": " If `f` sends two periodic points `x` and `y` of positive periods to the same point, then `x = y`.",
          "statement": "theorem function.is_periodic_pt.eq_of_apply_eq {α : Type u_1} {f : α → α} {x y : α} {m n : ℕ} (hx : function.is_periodic_pt f m x) (hy : function.is_periodic_pt f n y) (hm : 0 < m) (hn : 0 < n) (h : f x = f y) : x = y"
        }
      ],
      "codex_time": 10.607637445005821,
      "search_time": 1.474250674014911,
      "use_theorem_name": false
    },
    "outputs": [
      "{f : Set.Icc 0 1 → Set.Icc 0 1} (h : ∃ (x : Set.Icc 0 1), Function.IsPeriodicPt f 3 x) : ∀ (n : ℕ), ∃ (xn : Set.Icc 0 1), Function.IsPeriodicPt f n xn ",
      "{f : Setₓ.Icc 0 1 → Setₓ.Icc 0 1} (h : ∃ (x : Setₓ.Icc 0 1), Function.IsPeriodicPt f 3 x) : ∀ (n : ℕ), ∃ (xn : Setₓ.Icc 0 1), Function.IsPeriodicPt f n xn ",
      "{f : ℝ → ℝ} (h : ¬ function.is_injective f) (hf : Function.IsPeriodicPt f 3 0) (hm : 0 < 3) : ∃ (n : ℕ), ∃ (x : ℝ) (hx : 0 ≤ x ∧ x < 1 ∧ f x = f (x + (real.of_nat n))), 0 < n ",
      "{f : ℕ → ℕ} (H : ∃ x : ℕ, Function.IsPeriodicPt f 3 x) : ∀ m : ℕ, ∃ x : ℕ, Function.IsPeriodicPt f m x ",
      "{f : Icc 0 1 → Icc 0 1} (hf : function.fixed_point f (1 / 3)) : ∀ (x : ℕ), function.fixed_point f ((1 / 3) + (x : ℕ → ℝ) / 3) ",
      "{f : Icc 0 1 → Icc 0 1} {x : Icc 0 1} (h : ∃ (n : ℕ), Function.IsPeriodicPt f 3 x) : ∀ (n : ℕ) (hn : 0 < n), ∃ (y : Icc 0 1), Function.IsPeriodicPt f n y "
    ],
    "answer": ": ∀ f : Set.Icc 0 1 → Set.Icc 0 1, (∃ x : Set.Icc 0 1, Function.IsPeriodicPt f 3 x) → (∀ n : ℕ, n > 0 → ∃ y : Set.Icc 0 1, Function.IsPeriodicPt f n y) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "period_three_implies_chaos",
      "main_prompt": "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.",
      "prompt": "Natural language version: \"If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 14.598535224999068,
      "use_theorem_name": false
    },
    "outputs": [
      "has_homs_to_all_ints_of_period_three (f : α → α) [AddGroup α] [TopologicalSpace α] [TopologicalAddGroup α] [TopologicalSemiring α] [t1_space α] [metrizable_space α] [MetricSpace α] [UniformSpace α] [CompleteSpace α] [unique_periodic_hom f] [unique_monotonicity ⊥] [unique_periodic_hom f] [unique_monotonicity ⊥] [unique_periodic_hom ⊥] :    ∃ (η : ℕ),",
      "has_homs_to_all_ints_of_period_three (f : α → α) [AddGroupₓₓ α] [TopologicalSpace α] [TopologicalAddGroup α] [TopologicalSemiring α] [t1_space α] [metrizable_space α] [MetricSpace α] [UniformSpace α] [CompleteSpace α] [unique_periodic_hom f] [unique_monotonicity ⊥] [unique_periodic_hom f] [unique_monotonicity ⊥] [unique_periodic_hom ⊥] :    ∃ (η : ℕ),",
      "has_homs_to_all_ints_of_period_three (f : α → α) [AddGroupₓ α] [TopologicalSpace α] [TopologicalAddGroup α] [TopologicalSemiring α] [t1_space α] [metrizable_space α] [MetricSpace α] [UniformSpace α] [CompleteSpace α] [unique_periodic_hom f] [unique_monotonicity ⊥] [unique_periodic_hom f] [unique_monotonicity ⊥] [unique_periodic_hom ⊥] :    ∃ (η : ℕ),",
      "has_homs_to_all_ints_of_period_three (f : α → α) [AddGroup α] [TopologicalSpace α] [TopologicalAddGroup α] [TopologicalSemiring α] [t1_space α] [metrizable_space α] [MetricSpace α] [UniformSpaceₓ α] [CompleteSpace α] [unique_periodic_hom f] [unique_monotonicity ⊥] [unique_periodic_hom f] [unique_monotonicity ⊥] [unique_periodic_hom ⊥] :    ∃ (η : ℕ),",
      "has_homs_to_all_ints_of_period_three (f : α → α) [AddGroupₓₓ α] [TopologicalSpace α] [TopologicalAddGroup α] [TopologicalSemiring α] [t1_space α] [metrizable_space α] [MetricSpace α] [UniformSpaceₓ α] [CompleteSpace α] [unique_periodic_hom f] [unique_monotonicity ⊥] [unique_periodic_hom f] [unique_monotonicity ⊥] [unique_periodic_hom ⊥] :    ∃ (η : ℕ),",
      "has_homs_to_all_ints_of_period_three (f : α → α) [AddGroupₓ α] [TopologicalSpace α] [TopologicalAddGroup α] [TopologicalSemiring α] [t1_space α] [metrizable_space α] [MetricSpace α] [UniformSpaceₓ α] [CompleteSpace α] [unique_periodic_hom f] [unique_monotonicity ⊥] [unique_periodic_hom f] [unique_monotonicity ⊥] [unique_periodic_hom ⊥] :    ∃ (η : ℕ),",
      "pr : (∀ (f : Nat → Nat) (n : Nat), (∃ (i j : Nat), ((i ≤ j) ∧ period f j = 0) ∧ period f i = n) → (∃ (i j : Nat), ((i ≤ j) ∧ period f j = 0) ∧ period f i = n)) → ∀ (i j : Nat), ((i ≤ j) ∧ period f j = 0) ∧ period f i = n. Show what the hypotheses are, Yes f -> ∃n i j, i <= j ip f j = 0 ∧ period f i = n. Yes, great! I think we will",
      "is_periodic_of_has_period { p : ℝ } ( h : ¬ ( function . is_periodic f ) ) : has_period f p h ",
      "has_3pt_period_implies_all_periods (f : ℝ → ℝ) (hf : has_3pt_period f) :  ∀ (n : ℕ), has_period f n → has_period f (n * 3) ",
      "unit_loop_three_orbit_implies_all_orbits (f : ℝ → ℝ) (hf : Continuous f) (h : ∃ x, f(f(f x)) = x) :   ∃ x, f x = x "
    ],
    "answer": ": ∀ f : Set.Icc 0 1 → Set.Icc 0 1, (∃ x : Set.Icc 0 1, Function.IsPeriodicPt f 3 x) → (∀ n : ℕ, n > 0 → ∃ y : Set.Icc 0 1, Function.IsPeriodicPt f n y) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "terminal_unique_iso",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"A terminal object in a category is unique up to unique isomorphism.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A terminal object in a category is unique up to unique isomorphism.",
      "codex_time": 7.656400879990542,
      "use_theorem_name": false
    },
    "outputs": [
      "(C : Type u) [category.{v} C]  (t1 t2 : C) (t1_terminal : @has_terminal.terminal _ @has_terminal.to_has_terminal C _ t1)  (t2_terminal : @has_terminal.terminal _ @has_terminal.to_ha",
      "(C : Type*) [category C]  (X Y : C) (hX : is_terminal X) (hY : is_terminal Y) :  Nonempty (X ≅ Y) ",
      "(C : Type u) [category.{v} C] (X Y : C) [terminal.{v} X] [terminal.{v} Y] :   Nonempty (X ≅ Y) ",
      "(C : Type u) [category.{v} C] : IsGroupHom (λ (f g : C), ∃! [f' : C], f = f') ",
      "(C : Type u) [category.{v} C]  (X₀ X₁ : C) (h₀ : terminal X₀) (h₁ : terminal X₁) :  X₀ ≅ X₁ "
    ],
    "answer": "{C : Type _} [CategoryTheory.Category C] : ∀ T₁ T₂ : C, CategoryTheory.Limits.IsTerminal T₁ → CategoryTheory.Limits.IsTerminal T₂ → (∃ ι : CategoryTheory.Iso T₁ T₂, ∀ ι' : CategoryTheory.Iso T₁ T₂, ι = ι') "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "terminal_unique_iso",
      "main_prompt": "A terminal object in a category is unique up to unique isomorphism.",
      "prompt": "Natural language version: \" We can more explicitly show that a category has a terminal object by specifying the object, and showing there is a unique morphism to it from any other object.\" Translate the natural language version to a Lean mathlib version:\n theorem {C : Type u₁} [category_theory.category C] (X : C) [h : Π (Y : C), unique (Y ⟶ X)] :\ncategory_theory.limits.has_terminal C := \n\nNatural language version: \"Any two morphisms to a terminal object are equal.\" Translate the natural language version to a Lean mathlib version:\n theorem {C : Type u₁} [category_theory.category C] {X Y : C} (t : category_theory.limits.is_terminal X) (f g : Y ⟶ X) :\nf = g := \n\nNatural language version: \"If the unique morphism from `A` to a terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_is_terminal_from`.\" Translate the natural language version to a Lean mathlib version:\n theorem {C : Type u₁} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)] :\ncategory_theory.is_subterminal A := \n\nNatural language version: \"If there are zero morphisms, any terminal object is a zero object.\" Translate the natural language version to a Lean mathlib version:\n theorem {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C] :\ncategory_theory.limits.has_zero_object C := \n\nNatural language version: \"A terminal object in a category is unique up to unique isomorphism.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.8502864837646484,
          "doc_string": " We can more explicitly show that a category has a terminal object by specifying the object, and showing there is a unique morphism to it from any other object.",
          "statement": "theorem category_theory.limits.has_terminal_of_unique {C : Type u₁} [category_theory.category C] (X : C) [h : Π (Y : C), unique (Y ⟶ X)] : category_theory.limits.has_terminal C"
        },
        {
          "sim_score": 0.8256147503852844,
          "doc_string": "Any two morphisms to a terminal object are equal.",
          "statement": "theorem category_theory.limits.is_terminal.hom_ext {C : Type u₁} [category_theory.category C] {X Y : C} (t : category_theory.limits.is_terminal X) (f g : Y ⟶ X) : f = g"
        },
        {
          "sim_score": 0.6706336140632629,
          "doc_string": "If the unique morphism from `A` to a terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_is_terminal_from`.",
          "statement": "theorem category_theory.is_subterminal_of_mono_is_terminal_from {C : Type u₁} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)] : category_theory.is_subterminal A"
        },
        {
          "sim_score": 0.6649926900863647,
          "doc_string": "If there are zero morphisms, any terminal object is a zero object.",
          "statement": "theorem category_theory.limits.has_zero_object_of_has_terminal_object {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C] : category_theory.limits.has_zero_object C"
        }
      ],
      "codex_time": 7.707911478995811,
      "search_time": 1.520757896010764,
      "use_theorem_name": false
    },
    "outputs": [
      "{C : Type u₁} [CategoryTheory.Category C] {T T' : C} (hT : CategoryTheory.Limits.IsTerminal T) (hT' : CategoryTheory.Limits.IsTerminal T') : T ≅ T' ",
      "{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Limits.HasTerminal C] [CategoryTheory.Limits.HasTerminal C] : category_theory.limits.uniqueness_of_terminal_up_to_iso.{u₁} C ",
      "{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasTerminal C] [CategoryTheory.Limits.HasZeroObject C] : Subsingleton category_theory.limits.terminal_obj ",
      "{C : Type u₁} [small_category C] [CategoryTheory.Limits.HasTerminal C] {T₁ T₂ : C} (t₁ : CategoryTheory.Limits.IsTerminal T₁) (t₂ : CategoryTheory.Limits.IsTerminal T₂) : T₁ ≅ T₂ ",
      "{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Limits.HasTerminal C] : Nonempty (∃ (U : Type u₂), U ≃ category_theory.limits.terminal C) "
    ],
    "answer": "{C : Type _} [CategoryTheory.Category C] : ∀ T₁ T₂ : C, CategoryTheory.Limits.IsTerminal T₁ → CategoryTheory.Limits.IsTerminal T₂ → (∃ ι : CategoryTheory.Iso T₁ T₂, ∀ ι' : CategoryTheory.Iso T₁ T₂, ι = ι') "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "terminal_unique_iso",
      "main_prompt": "A terminal object in a category is unique up to unique isomorphism.",
      "prompt": "Natural language version: \"A terminal object in a category is unique up to unique isomorphism.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 14.211217574978946,
      "use_theorem_name": false
    },
    "outputs": [
      "unique_termal_in_category' {C : Type u} [𝒞 : category.{v} C] {O : C} :      is_obj_terminal O →       ∀ (O' : C), is_obj_terminal O' → O ≅ O' ",
      "terminal_obj_unique_up_to_unique_isomorphism (C : Type u) [category_struct C] :   ∀ A B : C, is_terminal A → is_terminal B → (A ≅ B) ",
      "terminal_object_unique_up_to_unique_isomorphism (C : Category.{v}) [h : has_terminal_object C] {X : C}    [hX : is_terminal_object X] (Y : C) [hY : is_terminal_object Y] : X ≅ Y ",
      "Ex4 : Unique ( λ ( x : C ), is_terminal { f : F ⟶ x // is_surjection f }) ",
      "term_unique { X : C } [ terminal X ] : ∀ Y : C , terminal Y → Y ≅ X  Now let's prove this theorem. But instead of following the usual tactic procedure, let's try to use the category theoretic language to directly give a proof term and see if it type checks.  Proof term:    λ(Y : C) (hyp : terminal Y),      have t_exists : X ⟶ Y, from terminal.from Y,     have Eq : X ⟶ Y ≅ X, from terminal.uniq t_exists, Eq  Type check and run:   /- tset_no_holes processing file"
    ],
    "answer": "{C : Type _} [CategoryTheory.Category C] : ∀ T₁ T₂ : C, CategoryTheory.Limits.IsTerminal T₁ → CategoryTheory.Limits.IsTerminal T₂ → (∃ ι : CategoryTheory.Iso T₁ T₂, ∀ ι' : CategoryTheory.Iso T₁ T₂, ι = ι') "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "torsion_in_fg_group_implies_finite",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"A finitely-presented group containing a torsion element is finite.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A finitely-presented group containing a torsion element is finite.",
      "codex_time": 14.036326958012069,
      "use_theorem_name": false
    },
    "outputs": [
      "(G : Type*) [Group G] [Fintype G]  (hGp : Fintype.card G < ∞) (hGt : ∃ x : G, x ≠ 1) :  Fintype.card G < ∞ ",
      "(G : Type*) [Groupₓₓ G] [Fintype G]  (hGp : Fintype.card G < ∞) (hGt : ∃ x : G, x ≠ 1) :  Fintype.card G < ∞ ",
      "(G : Type*) [Groupₓ G] [Fintype G]  (hGp : Fintype.card G < ∞) (hGt : ∃ x : G, x ≠ 1) :  Fintype.card G < ∞ ",
      "(G : Type*) [Group G] [Fintypeₓ G]  (hGp : Fintypeₓ.card G < ∞) (hGt : ∃ x : G, x ≠ 1) :  Fintypeₓ.card G < ∞ ",
      "(G : Type*) [Groupₓₓ G] [Fintypeₓ G]  (hGp : Fintypeₓ.card G < ∞) (hGt : ∃ x : G, x ≠ 1) :  Fintypeₓ.card G < ∞ ",
      "(G : Type*) [Groupₓ G] [Fintypeₓ G]  (hGp : Fintypeₓ.card G < ∞) (hGt : ∃ x : G, x ≠ 1) :  Fintypeₓ.card G < ∞ ",
      "(G : Type*) [Group G] [Fintype G] [fpG : finitely_presented G]:  ∃ x : G, x ≠ 1 ↔ x^k = 1 → Fintype G ",
      "(G : Type*) [Groupₓₓ G] [Fintype G] [fpG : finitely_presented G]:  ∃ x : G, x ≠ 1 ↔ x^k = 1 → Fintype G ",
      "(G : Type*) [Groupₓ G] [Fintype G] [fpG : finitely_presented G]:  ∃ x : G, x ≠ 1 ↔ x^k = 1 → Fintype G ",
      "(G : Type*) [Group G] [Fintypeₓ G] [fpG : finitely_presented G]:  ∃ x : G, x ≠ 1 ↔ x^k = 1 → Fintypeₓ G ",
      "(G : Type*) [Groupₓₓ G] [Fintypeₓ G] [fpG : finitely_presented G]:  ∃ x : G, x ≠ 1 ↔ x^k = 1 → Fintypeₓ G ",
      "(G : Type*) [Groupₓ G] [Fintypeₓ G] [fpG : finitely_presented G]:  ∃ x : G, x ≠ 1 ↔ x^k = 1 → Fintypeₓ G ",
      "(G : Type*) [Fintype G] [fin_group G]  {R : Type*} [Fintype R] [DecidableEq R] (g : G) (h : ∃ n > 1, g ^ n = 1)  (Rel : List (R × R))  (to_g : R → G)  (h_surj : Function.Surjective to_g)  (h_pres : List.Pairwise (λ x1 x2, to_g x1 = to_g x2 → x1 = x2) Rel) :  card G < ⊤ ",
      "(G : Type*) [Fintypeₓ G] [fin_group G]  {R : Type*} [Fintypeₓ R] [DecidableEq R] (g : G) (h : ∃ n > 1, g ^ n = 1)  (Rel : List (R × R))  (to_g : R → G)  (h_surj : Function.Surjective to_g)  (h_pres : List.Pairwise (λ x1 x2, to_g x1 = to_g x2 → x1 = x2) Rel) :  card G < ⊤ ",
      "(F : Type*) [Fintype F] [fin_group F]  (G : Type*) [Fintype G] [Group G]  (s : F → G) [IsGroupHom s]  (h : ∃ f : F, f ≠ 1) :  Fintype G ",
      "(F : Type*) [Fintype F] [fin_group F]  (G : Type*) [Fintype G] [Groupₓₓ G]  (s : F → G) [IsGroupHom s]  (h : ∃ f : F, f ≠ 1) :  Fintype G ",
      "(F : Type*) [Fintype F] [fin_group F]  (G : Type*) [Fintype G] [Groupₓ G]  (s : F → G) [IsGroupHom s]  (h : ∃ f : F, f ≠ 1) :  Fintype G ",
      "(F : Type*) [Fintypeₓ F] [fin_group F]  (G : Type*) [Fintypeₓ G] [Group G]  (s : F → G) [IsGroupHom s]  (h : ∃ f : F, f ≠ 1) :  Fintypeₓ G ",
      "(F : Type*) [Fintypeₓ F] [fin_group F]  (G : Type*) [Fintypeₓ G] [Groupₓₓ G]  (s : F → G) [IsGroupHom s]  (h : ∃ f : F, f ≠ 1) :  Fintypeₓ G ",
      "(F : Type*) [Fintypeₓ F] [fin_group F]  (G : Type*) [Fintypeₓ G] [Groupₓ G]  (s : F → G) [IsGroupHom s]  (h : ∃ f : F, f ≠ 1) :  Fintypeₓ G ",
      "(G : Type*) [Fintype G] [Group G] (hG : ∃ g : G, ∃ n : ℕ, n ≠ 0 ∧ g ^ n = 1) :  Fintype.card G < ⊤ ",
      "(G : Type*) [Fintype G] [Groupₓₓ G] (hG : ∃ g : G, ∃ n : ℕ, n ≠ 0 ∧ g ^ n = 1) :  Fintype.card G < ⊤ ",
      "(G : Type*) [Fintype G] [Groupₓ G] (hG : ∃ g : G, ∃ n : ℕ, n ≠ 0 ∧ g ^ n = 1) :  Fintype.card G < ⊤ ",
      "(G : Type*) [Fintypeₓ G] [Group G] (hG : ∃ g : G, ∃ n : ℕ, n ≠ 0 ∧ g ^ n = 1) :  Fintypeₓ.card G < ⊤ ",
      "(G : Type*) [Fintypeₓ G] [Groupₓₓ G] (hG : ∃ g : G, ∃ n : ℕ, n ≠ 0 ∧ g ^ n = 1) :  Fintypeₓ.card G < ⊤ ",
      "(G : Type*) [Fintypeₓ G] [Groupₓ G] (hG : ∃ g : G, ∃ n : ℕ, n ≠ 0 ∧ g ^ n = 1) :  Fintypeₓ.card G < ⊤ "
    ],
    "answer": "{G : Type _} [Groupₓ G] : Groupₓ.Fg G → Finite G "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "torsion_in_fg_group_implies_finite",
      "main_prompt": "A finitely-presented group containing a torsion element is finite.",
      "prompt": "Natural language version: \"Finite groups are torsion groups.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] [fintype G] :\nmonoid.is_torsion G := \n\nNatural language version: \"Subgroups of torsion groups are torsion groups.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] (tG : monoid.is_torsion G) (H : subgroup G) :\nmonoid.is_torsion ↥H := \n\nNatural language version: \"Finite additive groups are additive torsion groups.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [add_group G] [fintype G] :\nadd_monoid.is_torsion G := \n\nNatural language version: \"A nontrivial torsion group is not torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] [hN : nontrivial G] :\nmonoid.is_torsion G → ¬monoid.is_torsion_free G := \n\nNatural language version: \"A finitely-presented group containing a torsion element is finite.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.7566978335380554,
          "doc_string": "Finite groups are torsion groups.",
          "statement": "theorem is_torsion_of_fintype {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G"
        },
        {
          "sim_score": 0.6571311950683594,
          "doc_string": "Subgroups of torsion groups are torsion groups.",
          "statement": "theorem is_torsion.subgroup {G : Type u_1} [group G] (tG : monoid.is_torsion G) (H : subgroup G) : monoid.is_torsion ↥H"
        },
        {
          "sim_score": 0.6486772298812866,
          "doc_string": "Finite additive groups are additive torsion groups.",
          "statement": "theorem is_add_torsion_of_fintype {G : Type u_1} [add_group G] [fintype G] : add_monoid.is_torsion G"
        },
        {
          "sim_score": 0.6356827020645142,
          "doc_string": "A nontrivial torsion group is not torsion-free.",
          "statement": "theorem is_torsion.not_torsion_free {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G → ¬monoid.is_torsion_free G"
        }
      ],
      "codex_time": 5.733185497985687,
      "search_time": 1.4627392099937424,
      "use_theorem_name": false
    },
    "outputs": [
      "{G : Type u_1} [Group G] [Fintype G] {H : Type u_1} [Group H] [Fintype H]   (f : group_hom G H) (h : fintype.is_fin_gen G) (hT : ∃ x : G, ∃ n : ℕ, x^n = 1) : Fintype G ",
      "{G : Type u_1} [Groupₓₓ G] [Fintype G] {H : Type u_1} [Groupₓₓ H] [Fintype H]   (f : group_hom G H) (h : fintype.is_fin_gen G) (hT : ∃ x : G, ∃ n : ℕ, x^n = 1) : Fintype G ",
      "{G : Type u_1} [Groupₓ G] [Fintype G] {H : Type u_1} [Groupₓ H] [Fintype H]   (f : group_hom G H) (h : fintype.is_fin_gen G) (hT : ∃ x : G, ∃ n : ℕ, x^n = 1) : Fintype G ",
      "{G : Type u_1} [Group G] [Fintypeₓ G] {H : Type u_1} [Group H] [Fintypeₓ H]   (f : group_hom G H) (h : fintype.is_fin_gen G) (hT : ∃ x : G, ∃ n : ℕ, x^n = 1) : Fintypeₓ G ",
      "{G : Type u_1} [Groupₓₓ G] [Fintypeₓ G] {H : Type u_1} [Groupₓₓ H] [Fintypeₓ H]   (f : group_hom G H) (h : fintype.is_fin_gen G) (hT : ∃ x : G, ∃ n : ℕ, x^n = 1) : Fintypeₓ G ",
      "{G : Type u_1} [Groupₓ G] [Fintypeₓ G] {H : Type u_1} [Groupₓ H] [Fintypeₓ H]   (f : group_hom G H) (h : fintype.is_fin_gen G) (hT : ∃ x : G, ∃ n : ℕ, x^n = 1) : Fintypeₓ G ",
      "{G : Type u_1} [Group G] [is_fp G] : ∃ (g : G) [hg : monoid.torsion_elem G g], Fintype G ",
      "{G : Type u_1} [Groupₓₓ G] [is_fp G] : ∃ (g : G) [hg : monoid.torsion_elem G g], Fintype G ",
      "{G : Type u_1} [Groupₓ G] [is_fp G] : ∃ (g : G) [hg : monoid.torsion_elem G g], Fintype G ",
      "{G : Type u_1} [Group G] [is_fp G] : ∃ (g : G) [hg : monoid.torsion_elem G g], Fintypeₓ G ",
      "{G : Type u_1} [Groupₓₓ G] [is_fp G] : ∃ (g : G) [hg : monoid.torsion_elem G g], Fintypeₓ G ",
      "{G : Type u_1} [Groupₓ G] [is_fp G] : ∃ (g : G) [hg : monoid.torsion_elem G g], Fintypeₓ G ",
      "{G : Type u_1} [Group G] : group.is_f.p G → ∃ (g : G) (h : Monoidₓ.IsTorsion g), Fintype G ",
      "{G : Type u_1} [Groupₓₓ G] : group.is_f.p G → ∃ (g : G) (h : Monoidₓ.IsTorsion g), Fintype G ",
      "{G : Type u_1} [Groupₓ G] : group.is_f.p G → ∃ (g : G) (h : Monoidₓ.IsTorsion g), Fintype G ",
      "{G : Type u_1} [Group G] : group.is_f.p G → ∃ (g : G) (h : Monoidₓ.IsTorsion g), Fintypeₓ G ",
      "{G : Type u_1} [Groupₓₓ G] : group.is_f.p G → ∃ (g : G) (h : Monoidₓ.IsTorsion g), Fintypeₓ G ",
      "{G : Type u_1} [Groupₓ G] : group.is_f.p G → ∃ (g : G) (h : Monoidₓ.IsTorsion g), Fintypeₓ G ",
      "{G : Type u_1} [Group G] [Fintype G] (H : Subgroup G) [fin.is_fp H] : ∃ g, H.torsion g ",
      "{G : Type u_1} [Groupₓₓ G] [Fintype G] (H : Subgroup G) [fin.is_fp H] : ∃ g, H.torsion g ",
      "{G : Type u_1} [Groupₓ G] [Fintype G] (H : Subgroup G) [fin.is_fp H] : ∃ g, H.torsion g ",
      "{G : Type u_1} [Group G] [Fintypeₓ G] (H : Subgroup G) [fin.is_fp H] : ∃ g, H.torsion g ",
      "{G : Type u_1} [Groupₓₓ G] [Fintypeₓ G] (H : Subgroup G) [fin.is_fp H] : ∃ g, H.torsion g ",
      "{G : Type u_1} [Groupₓ G] [Fintypeₓ G] (H : Subgroup G) [fin.is_fp H] : ∃ g, H.torsion g ",
      "{G : Type u_1} [Group G] [h : Fintype G] (H1 : finitely_presented G) (H : ∃ a : G, a ≠ 1) : Fintype G ",
      "{G : Type u_1} [Groupₓₓ G] [h : Fintype G] (H1 : finitely_presented G) (H : ∃ a : G, a ≠ 1) : Fintype G ",
      "{G : Type u_1} [Groupₓ G] [h : Fintype G] (H1 : finitely_presented G) (H : ∃ a : G, a ≠ 1) : Fintype G ",
      "{G : Type u_1} [Group G] [h : Fintypeₓ G] (H1 : finitely_presented G) (H : ∃ a : G, a ≠ 1) : Fintypeₓ G ",
      "{G : Type u_1} [Groupₓₓ G] [h : Fintypeₓ G] (H1 : finitely_presented G) (H : ∃ a : G, a ≠ 1) : Fintypeₓ G ",
      "{G : Type u_1} [Groupₓ G] [h : Fintypeₓ G] (H1 : finitely_presented G) (H : ∃ a : G, a ≠ 1) : Fintypeₓ G "
    ],
    "answer": "{G : Type _} [Groupₓ G] : Groupₓ.Fg G → Finite G "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "torsion_in_fg_group_implies_finite",
      "main_prompt": "A finitely-presented group containing a torsion element is finite.",
      "prompt": "Natural language version: \"A finitely-presented group containing a torsion element is finite.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 13.834488082997268,
      "use_theorem_name": false
    },
    "outputs": [
      "finite_presented_group_of_torsion_is_finite_natlang (G : Type*) [Group G] [is_finitely_presented G] (H : ∃ g : G, g ≠ 1) :   ¬ is_infinite G ",
      "finite_presented_group_of_torsion_is_finite_natlang (G : Type*) [Groupₓₓ G] [is_finitely_presented G] (H : ∃ g : G, g ≠ 1) :   ¬ is_infinite G ",
      "finite_presented_group_of_torsion_is_finite_natlang (G : Type*) [Groupₓ G] [is_finitely_presented G] (H : ∃ g : G, g ≠ 1) :   ¬ is_infinite G ",
      "has_torsion.finite_group {G : Type} [Group G] (hG : finitely_presented_group G) (htor :  ∃ a : G, a ≠ 1 ∧ a * a = 1):   finite_group G.  lemma htor.left_coset_eq {G : Type} [Group G] (hG : finitely_presented_group G) (htor :  ∃ a : G, a ≠ 1 ∧ a * a = 1) (h : Set G) (g : G):   (∃ b ∈ h, b * a = g) ↔ g",
      "has_torsion.finite_group {G : Type} [Groupₓₓ G] (hG : finitely_presented_group G) (htor :  ∃ a : G, a ≠ 1 ∧ a * a = 1):   finite_group G.  lemma htor.left_coset_eq {G : Type} [Groupₓₓ G] (hG : finitely_presented_group G) (htor :  ∃ a : G, a ≠ 1 ∧ a * a = 1) (h : Set G) (g : G):   (∃ b ∈ h, b * a = g) ↔ g",
      "has_torsion.finite_group {G : Type} [Group G] (hG : finitely_presented_group G) (htor :  ∃ a : G, a ≠ 1 ∧ a * a = 1):   finite_group G.  lemma htor.left_coset_eq {G : Type} [Group G] (hG : finitely_presented_group G) (htor :  ∃ a : G, a ≠ 1 ∧ a * a = 1) (h : Setₓ G) (g : G):   (∃ b ∈ h, b * a = g) ↔ g",
      "has_torsion.finite_group {G : Type} [Groupₓₓ G] (hG : finitely_presented_group G) (htor :  ∃ a : G, a ≠ 1 ∧ a * a = 1):   finite_group G.  lemma htor.left_coset_eq {G : Type} [Groupₓₓ G] (hG : finitely_presented_group G) (htor :  ∃ a : G, a ≠ 1 ∧ a * a = 1) (h : Setₓ G) (g : G):   (∃ b ∈ h, b * a = g) ↔ g",
      "has_torsion.finite_group {G : Type} [Groupₓ G] (hG : finitely_presented_group G) (htor :  ∃ a : G, a ≠ 1 ∧ a * a = 1):   finite_group G.  lemma htor.left_coset_eq {G : Type} [Groupₓ G] (hG : finitely_presented_group G) (htor :  ∃ a : G, a ≠ 1 ∧ a * a = 1) (h : Set G) (g : G):   (∃ b ∈ h, b * a = g) ↔ g",
      "has_torsion.finite_group {G : Type} [Groupₓ G] (hG : finitely_presented_group G) (htor :  ∃ a : G, a ≠ 1 ∧ a * a = 1):   finite_group G.  lemma htor.left_coset_eq {G : Type} [Groupₓ G] (hG : finitely_presented_group G) (htor :  ∃ a : G, a ≠ 1 ∧ a * a = 1) (h : Setₓ G) (g : G):   (∃ b ∈ h, b * a = g) ↔ g",
      "finitely_presented_group.torsion_element_is_finite (G : Type*) [Group G] [Fintype G] [fgp G] : group_hom.torsion G → Fintype G  theorem fintype.finite_fintype [Fintype α] : Fintype α → Fintype α ",
      "finitely_presented_group.torsion_element_is_finite (G : Type*) [Groupₓₓ G] [Fintype G] [fgp G] : group_hom.torsion G → Fintype G  theorem fintype.finite_fintype [Fintype α] : Fintype α → Fintype α ",
      "finitely_presented_group.torsion_element_is_finite (G : Type*) [Groupₓ G] [Fintype G] [fgp G] : group_hom.torsion G → Fintype G  theorem fintype.finite_fintype [Fintype α] : Fintype α → Fintype α ",
      "finitely_presented_group.torsion_element_is_finite (G : Type*) [Group G] [Fintypeₓ G] [fgp G] : group_hom.torsion G → Fintypeₓ G  theorem fintype.finite_fintype [Fintypeₓ α] : Fintypeₓ α → Fintypeₓ α ",
      "finitely_presented_group.torsion_element_is_finite (G : Type*) [Groupₓₓ G] [Fintypeₓ G] [fgp G] : group_hom.torsion G → Fintypeₓ G  theorem fintype.finite_fintype [Fintypeₓ α] : Fintypeₓ α → Fintypeₓ α ",
      "finitely_presented_group.torsion_element_is_finite (G : Type*) [Groupₓ G] [Fintypeₓ G] [fgp G] : group_hom.torsion G → Fintypeₓ G  theorem fintype.finite_fintype [Fintypeₓ α] : Fintypeₓ α → Fintypeₓ α ",
      "oops : ∃ f : ℕ → ℤ, f (1+1) ≠ 0 --> finset.fintype {g : ℕ → ℤ // ∃ f : ℕ → ℤ, f (1+1) ≠ 0} ",
      "finitely_presented_group_with_torsion_element_finite (G : Type*) [Group G] [Fintype G] [Fintype G] ",
      "finitely_presented_group_with_torsion_element_finite (G : Type*) [Groupₓₓ G] [Fintype G] [Fintype G] ",
      "finitely_presented_group_with_torsion_element_finite (G : Type*) [Groupₓ G] [Fintype G] [Fintype G] ",
      "finitely_presented_group_with_torsion_element_finite (G : Type*) [Group G] [Fintypeₓ G] [Fintypeₓ G] ",
      "finitely_presented_group_with_torsion_element_finite (G : Type*) [Groupₓₓ G] [Fintypeₓ G] [Fintypeₓ G] ",
      "finitely_presented_group_with_torsion_element_finite (G : Type*) [Groupₓ G] [Fintypeₓ G] [Fintypeₓ G] "
    ],
    "answer": "{G : Type _} [Groupₓ G] : Groupₓ.Fg G → Finite G "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "compl_union",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"The complement of the union of two sets is the intersection of their complements.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The complement of the union of two sets is the intersection of their complements.",
      "codex_time": 5.520602020988008,
      "use_theorem_name": false
    },
    "outputs": [
      "(A B : Set ℝ) :  (A ∪ B)ᶜ = Aᶜ ∩ Bᶜ ",
      "(A B : Setₓ ℝ) :  (A ∪ B)ᶜ = Aᶜ ∩ Bᶜ ",
      "(X : Type*) (A B : Set X) :  (A ∪ B)ᶜ = Aᶜ ∩ Bᶜ ",
      "(X : Type*) (A B : Setₓ X) :  (A ∪ B)ᶜ = Aᶜ ∩ Bᶜ ",
      "(M A B : Set M) :  (set.compl $ A ∪ B) = (set.compl A) ∩ (set.compl B) ",
      "(M A B : Setₓ M) :  (set.compl $ A ∪ B) = (set.compl A) ∩ (set.compl B) ",
      "(X : Type*) (A B : Set X) :  -(A ∪ B) = -A ∩ -B ",
      "(X : Type*) (A B : Setₓ X) :  -(A ∪ B) = -A ∩ -B ",
      "(X : Type*) (A B : Set X) : (set.compl_union_compl A B) = set.compl_inter (set.compl A) (set.compl B) ",
      "(X : Type*) (A B : Setₓ X) : (set.compl_union_compl A B) = set.compl_inter (set.compl A) (set.compl B) "
    ],
    "answer": "{α : Type _} (S T : Set α) : (S ∪ T).compl = S.compl ∩ T.compl "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "compl_union",
      "main_prompt": "The complement of the union of two sets is the intersection of their complements.",
      "prompt": "Natural language version: \"The complement of a set has the same frontier as the original set.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [topological_space α] (s : set α) :\nfrontier sᶜ = frontier s := \n\nNatural language version: \"The union of two sets is bounded above if and only if each of the sets is.\" Translate the natural language version to a Lean mathlib version:\n theorem {γ : Type w} [semilattice_inf γ] {s t : set γ} :\nbdd_below (s ∪ t) ↔ bdd_below s ∧ bdd_below t := \n\nNatural language version: \"The union of two sets is bounded above if and only if each of the sets is.\" Translate the natural language version to a Lean mathlib version:\n theorem {γ : Type w} [semilattice_sup γ] {s t : set γ} :\nbdd_above (s ∪ t) ↔ bdd_above s ∧ bdd_above t := \n\nNatural language version: \" The cardinality of a union is at most the sum of the cardinalities of the two sets.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} (S T : set α) :\ncardinal.mk ↥(S ∪ T) ≤ cardinal.mk ↥S + cardinal.mk ↥T := \n\nNatural language version: \"The complement of the union of two sets is the intersection of their complements.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6778950691223145,
          "doc_string": "The complement of a set has the same frontier as the original set.",
          "statement": "theorem frontier_compl {α : Type u} [topological_space α] (s : set α) : frontier sᶜ = frontier s"
        },
        {
          "sim_score": 0.6120935678482056,
          "doc_string": "The union of two sets is bounded above if and only if each of the sets is.",
          "statement": "theorem bdd_below_union {γ : Type w} [semilattice_inf γ] {s t : set γ} : bdd_below (s ∪ t) ↔ bdd_below s ∧ bdd_below t"
        },
        {
          "sim_score": 0.6120935678482056,
          "doc_string": "The union of two sets is bounded above if and only if each of the sets is.",
          "statement": "theorem bdd_above_union {γ : Type w} [semilattice_sup γ] {s t : set γ} : bdd_above (s ∪ t) ↔ bdd_above s ∧ bdd_above t"
        },
        {
          "sim_score": 0.6097555160522461,
          "doc_string": " The cardinality of a union is at most the sum of the cardinalities of the two sets.",
          "statement": "theorem cardinal.mk_union_le {α : Type u} (S T : set α) : cardinal.mk ↥(S ∪ T) ≤ cardinal.mk ↥S + cardinal.mk ↥T"
        }
      ],
      "codex_time": 4.9173353480000515,
      "search_time": 1.4480129570001736,
      "use_theorem_name": false
    },
    "outputs": [
      "{α : Type u} {s t : Set α} : sᶜ ∩ tᶜ = (s ∪ t)ᶜ ",
      "{α : Type u} {s t : Setₓ α} : sᶜ ∩ tᶜ = (s ∪ t)ᶜ ",
      "{α : Type u} (s t : Set α) : sᶜ ∪ tᶜ = (s ∩ t)ᶜ ",
      "{α : Type u} (s t : Setₓ α) : sᶜ ∪ tᶜ = (s ∩ t)ᶜ ",
      "{α : Type u} (S T : Set α) : ((S ∪ T)ᶜ : Set α) = Sᶜ ∩ Tᶜ ",
      "{α : Type u} (S T : Setₓ α) : ((S ∪ T)ᶜ : Setₓ α) = Sᶜ ∩ Tᶜ ",
      "{α : Type u} (S T : Set α) : (S ∪ T)ᶜ = Sᶜ ∩ Tᶜ ",
      "{α : Type u} (S T : Setₓ α) : (S ∪ T)ᶜ = Sᶜ ∩ Tᶜ ",
      "{α : Type u} (U V : Set α) : (- (U ∪ V)) = (- U) ∩ (- V) ",
      "{α : Type u} (U V : Setₓ α) : (- (U ∪ V)) = (- U) ∩ (- V) "
    ],
    "answer": "{α : Type _} (S T : Set α) : (S ∪ T).compl = S.compl ∩ T.compl "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "compl_union",
      "main_prompt": "The complement of the union of two sets is the intersection of their complements.",
      "prompt": "Natural language version: \"The complement of the union of two sets is the intersection of their complements.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 6.717659387009917,
      "use_theorem_name": false
    },
    "outputs": [
      "set.compl_union_compl_eq_inter_compl {X : Type*} [DecidableEq X] (A B : Set X) :   -(A ∪ B) = -A ∩ -B ",
      "set.compl_union_compl_eq_inter_compl {X : Type*} [DecidableEq X] (A B : Setₓ X) :   -(A ∪ B) = -A ∩ -B ",
      "set.compl_union_compl_inter (A B : Set X) : set.compl (A ∪ B) = (set.compl A) ∩ (set.compl B) ",
      "set.compl_union_compl_inter (A B : Setₓ X) : set.compl (A ∪ B) = (set.compl A) ∩ (set.compl B) ",
      "Set . complement_union_inter_complement :  ... ",
      "Setₓ . complement_union_inter_complement :  ... ",
      "De_Morgan_law_compl_union (n : ℕ) (M_1 M_2 : Finset ℕ) :    compl_union n M_1 M_2 = HasCompl n (Inter M_1 M_2) ",
      "compl_union (A B : Set X) : -(A ∪ B) = -A ∩ -B ",
      "compl_union (A B : Setₓ X) : -(A ∪ B) = -A ∩ -B "
    ],
    "answer": "{α : Type _} (S T : Set α) : (S ∪ T).compl = S.compl ∩ T.compl "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "flt_3",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"The sum of the cubes of two positive integers is never equal to the cube of a third integer.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The sum of the cubes of two positive integers is never equal to the cube of a third integer.",
      "codex_time": 6.254193135973765,
      "use_theorem_name": false
    },
    "outputs": [
      "(a c : ℕ) (b : ℕ) (h_ac : a^3 + c^3 = b^3 ): False ",
      "(m n p : ℕ) (h1 : (0 : ℕ) < m) (h2 : 0 < n)  (h3 : 0 < p) : ∃ x y z : ℕ, m^3 + n^3 = x^3 + y^3 + z^3 ",
      "(x y z : ℕ) (hx_pos : 0 < x) (hy_pos : 0 < y) (hz_pos : 0 < z) :  (x*x*x) + (y*y*y) ≠ z*z*z ",
      "(m n p: ℕ) : p^3 ≠ (m^3) + (n^3) ",
      "(x y z : ℕ)  (hx : 0 < x) (hy : 0 < y) (hz : 0 < z) (hxz : x^3 + y^3 ≠ z^3) :  sorry "
    ],
    "answer": ": ∀ a b c : ℕ, a > 0 → b > 0 → ¬(a^3 + b^3 = c^3) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "flt_3",
      "main_prompt": "The sum of the cubes of two positive integers is never equal to the cube of a third integer.",
      "prompt": "Natural language version: \"The zeroth Pythagorean triple is all zeros.\" Translate the natural language version to a Lean mathlib version:\n theorem  :\npythagorean_triple 0 0 0 := \n\nNatural language version: \"The sum of two squares is zero iff both elements are zero.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [linear_ordered_ring α] {x y : α} :\nx * x + y * y = 0 ↔ x = 0 ∧ y = 0 := \n\nNatural language version: \" **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**.\" Translate the natural language version to a Lean mathlib version:\n theorem {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) :\n∃ (a b : ℕ), a ^ 2 + b ^ 2 = p := \n\nNatural language version: \" Pythagorean triples are interchangable, i.e `x * x + y * y = y * y + x * x = z * z`. This comes from additive commutativity.\" Translate the natural language version to a Lean mathlib version:\n theorem {x y z : ℤ} :\npythagorean_triple x y z ↔ pythagorean_triple y x z := \n\nNatural language version: \"The sum of the cubes of two positive integers is never equal to the cube of a third integer.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5193248391151428,
          "doc_string": "The zeroth Pythagorean triple is all zeros.",
          "statement": "theorem pythagorean_triple.zero  : pythagorean_triple 0 0 0"
        },
        {
          "sim_score": 0.4774671792984009,
          "doc_string": "The sum of two squares is zero iff both elements are zero.",
          "statement": "theorem mul_self_add_mul_self_eq_zero {α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0"
        },
        {
          "sim_score": 0.4648144245147705,
          "doc_string": " **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**.",
          "statement": "theorem nat.prime.sq_add_sq {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p"
        },
        {
          "sim_score": 0.4421241879463196,
          "doc_string": " Pythagorean triples are interchangable, i.e `x * x + y * y = y * y + x * x = z * z`. This comes from additive commutativity.",
          "statement": "theorem pythagorean_triple_comm {x y z : ℤ} : pythagorean_triple x y z ↔ pythagorean_triple y x z"
        }
      ],
      "codex_time": 4.896273948979797,
      "search_time": 1.502638221019879,
      "use_theorem_name": false
    },
    "outputs": [
      "{x y z : ℤ} (hxz : 0 < x + y) (hyz : 0 < y + z) (hxz : 0 < x + z) : (x ^ 3 + y ^ 3 = z ^ 3) → False ",
      "{x y z : ℕ} (hx : x > 0) (hy : y > 0) (hz : z > 0) : x^3 + y^3 ≠ z^3 ",
      "(hx : x > 0) (hy : y > 0) {z : ℕ} : x ^ 3 + y ^ 3 ≠ z ^ 3 ",
      "{x y z : ℤ} [decidable_linear_ordered_comm_ring α] (h : x ^ 3 + y ^ 3 ≠ z ^ 3) : 0 < x ∧ 0 < y ",
      "{x y z : ℤ} (hx : x > 0) (hy : y > 0) (hz : z > 0) : x ^ 3 + y ^ 3 ≠ z ^ 3 "
    ],
    "answer": ": ∀ a b c : ℕ, a > 0 → b > 0 → ¬(a^3 + b^3 = c^3) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "flt_3",
      "main_prompt": "The sum of the cubes of two positive integers is never equal to the cube of a third integer.",
      "prompt": "Natural language version: \"The sum of the cubes of two positive integers is never equal to the cube of a third integer.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 5.368797476985492,
      "use_theorem_name": false
    },
    "outputs": [
      "not_equal_sum_of_cubes (a b c : ℕ) (h : a^3 + b^3 = c^3 ) : False ",
      "sum_of_cubes_of_two_pos : ∀ m n k : ℕ, m^3 + n^3 ≠ k^3 ",
      "sum_of_three_cubes : ∀ m n k : ℕ , (m ^ 3 + n ^ 3) /= (k ^ 3) ",
      "cube_of_two_plus_cube_of_two_is_not_cube_of_third :   ∀ x y z: ℕ, (x * x * x + y * y * y) ≠ z * z * z ",
      "naturals_sum_cube_neq_cube (b c : Nat) :   ∑ i in range 2, b^3 + c^3 ≠ (i-1)^3 "
    ],
    "answer": ": ∀ a b c : ℕ, a > 0 → b > 0 → ¬(a^3 + b^3 = c^3) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "elems_order_two_implies_commutative",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"If every element of a group `G` has order two, then every pair of elements of `G` commutes.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If every element of a group `G` has order two, then every pair of elements of `G` commutes.",
      "codex_time": 5.72358208798687,
      "use_theorem_name": false
    },
    "outputs": [
      "(G : Type*) [Group G] (h2 : ∀ g, (g : G)^2 = 1):  ∀ x y : G, x * y = y * x ",
      "(G : Type*) [Groupₓₓ G] (h2 : ∀ g, (g : G)^2 = 1):  ∀ x y : G, x * y = y * x ",
      "(G : Type*) [Groupₓ G] (h2 : ∀ g, (g : G)^2 = 1):  ∀ x y : G, x * y = y * x ",
      "(G : Type*) [Group G] (h : ∀ x : G, x * x = 1) :  ∀ x y : G, x * y = y * x ",
      "(G : Type*) [Groupₓₓ G] (h : ∀ x : G, x * x = 1) :  ∀ x y : G, x * y = y * x ",
      "(G : Type*) [Groupₓ G] (h : ∀ x : G, x * x = 1) :  ∀ x y : G, x * y = y * x ",
      "(G : Type*) [Group G] (hG : ∀ g : G, g * g = 1) :  ∀ x y : G, x * y = y * x ",
      "(G : Type*) [Groupₓₓ G] (hG : ∀ g : G, g * g = 1) :  ∀ x y : G, x * y = y * x ",
      "(G : Type*) [Groupₓ G] (hG : ∀ g : G, g * g = 1) :  ∀ x y : G, x * y = y * x ",
      "(G : Type*) [Group G]  (hG : ∀ x : G, x ^ 2 = 1) : CommGroup G ",
      "(G : Type*) [Group G]  (hG : ∀ x : G, x ^ 2 = 1) : CommGroupₓₓ G ",
      "(G : Type*) [Groupₓₓ G]  (hG : ∀ x : G, x ^ 2 = 1) : CommGroup G ",
      "(G : Type*) [Groupₓₓ G]  (hG : ∀ x : G, x ^ 2 = 1) : CommGroupₓₓ G ",
      "(G : Type*) [Groupₓ G]  (hG : ∀ x : G, x ^ 2 = 1) : CommGroup G ",
      "(G : Type*) [Groupₓ G]  (hG : ∀ x : G, x ^ 2 = 1) : CommGroupₓₓ G ",
      "(G : Type*) [Group G]  (hG : ∀ x : G, x ^ 2 = 1) : CommGroupₓ G ",
      "(G : Type*) [Groupₓₓ G]  (hG : ∀ x : G, x ^ 2 = 1) : CommGroupₓ G ",
      "(G : Type*) [Groupₓ G]  (hG : ∀ x : G, x ^ 2 = 1) : CommGroupₓ G ",
      "(G : Type*) [Group G]  (hG : ∀ g : G, g^2 = 1) :  ∀ x y : G, x * y = y * x ",
      "(G : Type*) [Groupₓₓ G]  (hG : ∀ g : G, g^2 = 1) :  ∀ x y : G, x * y = y * x ",
      "(G : Type*) [Groupₓ G]  (hG : ∀ g : G, g^2 = 1) :  ∀ x y : G, x * y = y * x "
    ],
    "answer": "{G: Type _}[Group G] : (∀ x y : G, x * x = 1) → (∀ x y : G, Commute x y) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "elems_order_two_implies_commutative",
      "main_prompt": "If every element of a group `G` has order two, then every pair of elements of `G` commutes.",
      "prompt": "Natural language version: \"If `a` commutes with `b`, then `b` commutes with `a`.\" Translate the natural language version to a Lean mathlib version:\n theorem {S : Type u_1} [has_mul S] {a b : S} (h : commute a b) :\ncommute b a := \n\nNatural language version: \"If `a` commutes with `b`, then `b` commutes with `a`.\" Translate the natural language version to a Lean mathlib version:\n theorem {S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) :\nadd_commute b a := \n\nNatural language version: \"Commuting elements of finite order are closed under multiplication.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) :\nis_of_fin_order (x * y) := \n\nNatural language version: \"If `a` commutes with both `b` and `c`, then it commutes with their product.\" Translate the natural language version to a Lean mathlib version:\n theorem {S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) :\ncommute a (b * c) := \n\nNatural language version: \"If every element of a group `G` has order two, then every pair of elements of `G` commutes.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6088767051696777,
          "doc_string": "If `a` commutes with `b`, then `b` commutes with `a`.",
          "statement": "theorem commute.symm {S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : commute b a"
        },
        {
          "sim_score": 0.6088767051696777,
          "doc_string": "If `a` commutes with `b`, then `b` commutes with `a`.",
          "statement": "theorem add_commute.symm {S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : add_commute b a"
        },
        {
          "sim_score": 0.5862270593643188,
          "doc_string": "Commuting elements of finite order are closed under multiplication.",
          "statement": "theorem commute.is_of_fin_order_mul {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)"
        },
        {
          "sim_score": 0.5844683647155762,
          "doc_string": "If `a` commutes with both `b` and `c`, then it commutes with their product.",
          "statement": "theorem commute.mul_right {S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) : commute a (b * c)"
        }
      ],
      "codex_time": 9.017476831009844,
      "search_time": 1.6500981619756203,
      "use_theorem_name": false
    },
    "outputs": [
      "{G : Type u} [Group G] (H : ∀ x : G, finite.mk 0 = x.order) : ∀ x y : G, Commute x y ",
      "{G : Type u} [Groupₓₓ G] (H : ∀ x : G, finite.mk 0 = x.order) : ∀ x y : G, Commute x y ",
      "{G : Type u} [Groupₓ G] (H : ∀ x : G, finite.mk 0 = x.order) : ∀ x y : G, Commute x y ",
      "{G : Type u} (H : ∀ (x : G), IsOfFinOrder (x : G) ∧ 2 ≤ Nat.find x) : ∀ {x y : G}, Commute x y ",
      "{G : Type u} [Group G] (hG : is_of_fin_order_two G) {x y : G} : Commute x y ",
      "{G : Type u} [Groupₓₓ G] (hG : is_of_fin_order_two G) {x y : G} : Commute x y ",
      "{G : Type u} [Groupₓ G] (hG : is_of_fin_order_two G) {x y : G} : Commute x y ",
      "{G : Type u} {x y : G} [Monoid G] (hx : IsOfFinOrder x) (hy : IsOfFinOrder y) : ∀ (h : orderOf x = 2) (h' : orderOf y = 2), Commute x y ",
      "{G : Type u} {x y : G} [Monoidₓ G] (hx : IsOfFinOrder x) (hy : IsOfFinOrder y) : ∀ (h : orderOf x = 2) (h' : orderOf y = 2), Commute x y ",
      "{G : Type u_1} [Group G] (h : ∀ x : G, is_of_order_two x) : ∀ x y : G, Commute x y ",
      "{G : Type u_1} [Groupₓₓ G] (h : ∀ x : G, is_of_order_two x) : ∀ x y : G, Commute x y ",
      "{G : Type u_1} [Groupₓ G] (h : ∀ x : G, is_of_order_two x) : ∀ x y : G, Commute x y "
    ],
    "answer": "{G: Type _}[Group G] : (∀ x y : G, x * x = 1) → (∀ x y : G, Commute x y) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "elems_order_two_implies_commutative",
      "main_prompt": "If every element of a group `G` has order two, then every pair of elements of `G` commutes.",
      "prompt": "Natural language version: \"If every element of a group `G` has order two, then every pair of elements of `G` commutes.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 7.878516655997373,
      "use_theorem_name": false
    },
    "outputs": [
      "order_two_then_commutes {G : Type} [Group G]  (H : ∀ x : G, x*x = 1) : ∀ (a b : G), a*b = b*a ",
      "order_two_then_commutes {G : Type} [Groupₓₓ G]  (H : ∀ x : G, x*x = 1) : ∀ (a b : G), a*b = b*a ",
      "order_two_then_commutes {G : Type} [Groupₓ G]  (H : ∀ x : G, x*x = 1) : ∀ (a b : G), a*b = b*a ",
      "odd_group.commutes_if_each_element_of_order_two (G : Type*) [Group G] [odd_group G] :   ∀ g : G, order g = 2 → ∀ a b : G, a * b = b * a ",
      "odd_group.commutes_if_each_element_of_order_two (G : Type*) [Groupₓₓ G] [odd_group G] :   ∀ g : G, order g = 2 → ∀ a b : G, a * b = b * a ",
      "odd_group.commutes_if_each_element_of_order_two (G : Type*) [Groupₓ G] [odd_group G] :   ∀ g : G, order g = 2 → ∀ a b : G, a * b = b * a ",
      "ex5_5 {G : Type} [Group G] (h : ∀ x : G, x^2 = 1) : CommGroup G ",
      "ex5_5 {G : Type} [Group G] (h : ∀ x : G, x^2 = 1) : CommGroupₓₓ G ",
      "ex5_5 {G : Type} [Groupₓₓ G] (h : ∀ x : G, x^2 = 1) : CommGroup G ",
      "ex5_5 {G : Type} [Groupₓₓ G] (h : ∀ x : G, x^2 = 1) : CommGroupₓₓ G ",
      "ex5_5 {G : Type} [Groupₓ G] (h : ∀ x : G, x^2 = 1) : CommGroup G ",
      "ex5_5 {G : Type} [Groupₓ G] (h : ∀ x : G, x^2 = 1) : CommGroupₓₓ G ",
      "ex5_5 {G : Type} [Group G] (h : ∀ x : G, x^2 = 1) : CommGroupₓ G ",
      "ex5_5 {G : Type} [Groupₓₓ G] (h : ∀ x : G, x^2 = 1) : CommGroupₓ G ",
      "ex5_5 {G : Type} [Groupₓ G] (h : ∀ x : G, x^2 = 1) : CommGroupₓ G ",
      "two_elts_commute (G : Type) [Group G] (H : ∀ g : G, has_order g 2) :  ∀ a b ∈ G, a * b = b * a ",
      "two_elts_commute (G : Type) [Groupₓₓ G] (H : ∀ g : G, has_order g 2) :  ∀ a b ∈ G, a * b = b * a ",
      "two_elts_commute (G : Type) [Groupₓ G] (H : ∀ g : G, has_order g 2) :  ∀ a b ∈ G, a * b = b * a ",
      "foo (g : G) : g * g = 1 "
    ],
    "answer": "{G: Type _}[Group G] : (∀ x y : G, x * x = 1) → (∀ x y : G, Commute x y) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "prime_eq_two_or_odd",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every prime number is either `2` or odd.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every prime number is either `2` or odd.",
      "codex_time": 3.5695287270064,
      "use_theorem_name": false
    },
    "outputs": [
      "(p : ℕ) (hp  : Prime p) :  p = 2 ∨ ∃ n : ℕ, p = 2 * n + 1 ",
      "(p : ℕ) (hp : Prime p) :  p = 2 ∨ p % 2 = 1 ",
      "(p : ℕ) (hp : Prime p) : p = 2 ∨ Even p ",
      "(p : ℕ) (h : Prime p) : p = 2 ∨ p % 2 = 1 ",
      "(p : ℕ) (hp : Nat.Prime p) :  p = 2 ∨ ∃ n : ℕ, n > 0 ∧   p = 2*n + 1 "
    ],
    "answer": "{n: Nat} : Prime n → n = 2 ∨ Odd n "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "prime_eq_two_or_odd",
      "main_prompt": "Every prime number is either `2` or odd.",
      "prompt": "Natural language version: \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.\" Translate the natural language version to a Lean mathlib version:\n theorem {p : ℕ} [fact (nat.prime p)] :\np % 2 = 1 ↔ p ≠ 2 := \n\nNatural language version: \"A natural number is odd iff it has residue `1` or `3` mod `4`\" Translate the natural language version to a Lean mathlib version:\n theorem {n : ℕ} :\nn % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 := \n\nNatural language version: \"The only numbers with empty prime factorization are `0` and `1`\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) :\nn.factorization = 0 ↔ n = 0 ∨ n = 1 := \n\nNatural language version: \"The only prime factor of prime `p` is `p` itself, with multiplicity `1`\" Translate the natural language version to a Lean mathlib version:\n theorem {p : ℕ} (hp : nat.prime p) :\np.factorization = finsupp.single p 1 := \n\nNatural language version: \"Every prime number is either `2` or odd.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.7289595007896423,
          "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.",
          "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2"
        },
        {
          "sim_score": 0.5622097253799438,
          "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`",
          "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"
        },
        {
          "sim_score": 0.5335504412651062,
          "doc_string": "The only numbers with empty prime factorization are `0` and `1`",
          "statement": "theorem nat.factorization_eq_zero_iff (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1"
        },
        {
          "sim_score": 0.5028786063194275,
          "doc_string": "The only prime factor of prime `p` is `p` itself, with multiplicity `1`",
          "statement": "theorem nat.prime.factorization {p : ℕ} (hp : nat.prime p) : p.factorization = finsupp.single p 1"
        }
      ],
      "codex_time": 4.6803766950033605,
      "search_time": 1.46482077499968,
      "use_theorem_name": false
    },
    "outputs": [
      "{p : ℕ} (hp : Nat.Prime p) :  p = 2 ∨ p % 2 = 1 ",
      "(p : ℕ) :  Nat.Prime p ↔ p = 2 ∨ p % 2 = 1 ",
      "{p : ℕ} (hp : Nat.Prime p) : p = 2 ∨ p % 2 = 1 ",
      "(n : ℕ) (hp : Nat.Prime n) : n = 2 ∨ n % 2 = 1 ",
      "{p : ℕ} (hp : Nat.Prime p) : p = 2 ∨ p % 2 = 1 "
    ],
    "answer": "{n: Nat} : Prime n → n = 2 ∨ Odd n "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "prime_eq_two_or_odd",
      "main_prompt": "Every prime number is either `2` or odd.",
      "prompt": "Natural language version: \"Every prime number is either `2` or odd.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 11.800225621991558,
      "use_theorem_name": false
    },
    "outputs": [
      "prime_two_or_odd : ∀x : ℕ, Prime x → x = 2 ∨ (∃p, x = 2*p + 1 ∧ Prime p) ",
      "natural_number.prime_odd_or_two : ∀ p : ℕ, Prime p → p = 2 ∨ p % 2 ≠ 0 ",
      "every_prime_is_two_or_odd : ∀ (n : ℕ), Prime n → n = 2 ∨ n % 2 = 1  apply nat.prime.not_dvd_two; assumption,-- 3.2-3   Have you considered all cases? **NO  Does the statement follow directly from One of the facts in examples.lean? **NO  Does it need to Zero? **NO  Does it need to be about pos_num? **NO  Does it need to be about integers? **NO  Does it need to mention Even or Odd? **YES  Does it need to mention mod? **YES  Does it need to mention Dvd? **YES ",
      "primes_are_2_n_odd (n : ℕ) (H : Prime n) : n = 2 ∨ ∃ k, n = k * 2 + 1 ",
      "Two_or_odd ( x : ℕ ) : ( Prime x → ( x = 2 ∨ Odd x )) "
    ],
    "answer": "{n: Nat} : Prime n → n = 2 ∨ Odd n "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "poly_odd_degree_has_zero",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every odd degree polynomial over `ℝ` has a zero\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every odd degree polynomial over `ℝ` has a zero",
      "codex_time": 8.610929604008561,
      "use_theorem_name": false
    },
    "outputs": [
      "ℝ : ∀ (n : ℕ) (p : Polynomial ℝ), n % 2 = 1 → polynomial.deg p < n → ∃ c : ℝ, p.eval c = 0 ",
      "(n : ℕ) (h : 0 < n % 2) (f : Polynomial ℝ) :  ∃ x : ℝ, Polynomial.eval f x = 0 ",
      "(n : ℕ) (h : n % 2 = 1) (p : Polynomial ℝ)  (hp : p.nat_degree = n): ∥-∥^∥  Natural language version: \"Let X be a totally ordered set. Prove that if x ∈ X, then [x, x] is an interval containing x. If, in addition X is Dedekind complete, prove that this interval has a supremum in X.\" Translate the natural language version to a Lean mathlib version:  unresolved  Natural language version: \"Let x be a real number, and y an Irrational number. Prove that the real numbers x + y and x",
      "(a : ℝ) (n : ℕ) (h : n % 2 = 1) :  ∃ x : ℝ, a * x^n + 1 = 0 ",
      "∀ a : ℝ, ∃ x : ℝ, Polynomial.c a * 'X^3 + Polynomial.c 0 * 'X^2 + Polynomial.c 0 * 'X + Polynomial.c 1 = 0 "
    ],
    "answer": "{α : Type _} [Field α] (p : Polynomial α) : Odd (p.degree) → ∃ x, p.IsRoot x "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "poly_odd_degree_has_zero",
      "main_prompt": "Every odd degree polynomial over `ℝ` has a zero",
      "prompt": "Natural language version: \"The degree of a product of polynomials is at most the sum of the degrees, where the degree of the zero polynomial is ⊥.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [comm_semiring R] (t : multiset (polynomial R)) :\nt.prod.degree ≤ (multiset.map polynomial.degree t).sum := \n\nNatural language version: \"The degree of a product of polynomials is equal to the sum of the degrees, where the degree of the zero polynomial is ⊥.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [comm_semiring R] [no_zero_divisors R] (t : multiset (polynomial R)) [nontrivial R] :\nt.prod.degree = (multiset.map (λ (f : polynomial R), f.degree) t).sum := \n\nNatural language version: \"The degree of a product of polynomials is equal to the sum of the degrees, where the degree of the zero polynomial is ⊥.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} {ι : Type w} (s : finset ι) [comm_semiring R] [no_zero_divisors R] (f : ι → polynomial R) [nontrivial R] :\n(s.prod (λ (i : ι), f i)).degree = s.sum (λ (i : ι), (f i).degree) := \n\nNatural language version: \"The degree of a minimal polynomial, as a natural number, is positive.\" Translate the natural language version to a Lean mathlib version:\n theorem {A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] [nontrivial B] {x : B} (hx : is_integral A x) :\n0 < (minpoly A x).nat_degree := \n\nNatural language version: \"Every odd degree polynomial over `ℝ` has a zero\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.50849449634552,
          "doc_string": "The degree of a product of polynomials is at most the sum of the degrees, where the degree of the zero polynomial is ⊥.",
          "statement": "theorem polynomial.degree_multiset_prod_le {R : Type u} [comm_semiring R] (t : multiset (polynomial R)) : t.prod.degree ≤ (multiset.map polynomial.degree t).sum"
        },
        {
          "sim_score": 0.48135414719581604,
          "doc_string": "The degree of a product of polynomials is equal to the sum of the degrees, where the degree of the zero polynomial is ⊥.",
          "statement": "theorem polynomial.degree_multiset_prod {R : Type u} [comm_semiring R] [no_zero_divisors R] (t : multiset (polynomial R)) [nontrivial R] : t.prod.degree = (multiset.map (λ (f : polynomial R), f.degree) t).sum"
        },
        {
          "sim_score": 0.48135414719581604,
          "doc_string": "The degree of a product of polynomials is equal to the sum of the degrees, where the degree of the zero polynomial is ⊥.",
          "statement": "theorem polynomial.degree_prod {R : Type u} {ι : Type w} (s : finset ι) [comm_semiring R] [no_zero_divisors R] (f : ι → polynomial R) [nontrivial R] : (s.prod (λ (i : ι), f i)).degree = s.sum (λ (i : ι), (f i).degree)"
        },
        {
          "sim_score": 0.4661085605621338,
          "doc_string": "The degree of a minimal polynomial, as a natural number, is positive.",
          "statement": "theorem minpoly.nat_degree_pos {A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] [nontrivial B] {x : B} (hx : is_integral A x) : 0 < (minpoly A x).nat_degree"
        }
      ],
      "codex_time": 4.9523714979877695,
      "search_time": 1.528045929997461,
      "use_theorem_name": false
    },
    "outputs": [
      "(p : Polynomial ℝ) (h : p.nat_degree % 2 = 1) : ∃ x : ℝ, p.eval x = 0 ",
      "{R : Type u} [CommRing R] [LinearOrderedField R] (f : Polynomial R) (hf : f.nat_degree % 2 = 1) : ∃ (a : R), Polynomial.eval f a = 0 ",
      "{R : Type u} [CommRingₓₓ R] [LinearOrderedField R] (f : Polynomial R) (hf : f.nat_degree % 2 = 1) : ∃ (a : R), Polynomial.eval f a = 0 ",
      "{R : Type u} [CommRingₓ R] [LinearOrderedField R] (f : Polynomial R) (hf : f.nat_degree % 2 = 1) : ∃ (a : R), Polynomial.eval f a = 0 ",
      "{R : Type u} [discrete_field R] (f : Polynomial R) : f.nat_degree % 2 = 1 → ∃ a : R, f.eval a = 0 ",
      "{α : Type} [LinearOrderedField α] [Nontrivial α] (p : Polynomial α) (h : 2 ∣ p.nat_degree) : ∃ x : α, p.eval x = 0 ",
      "{α : Type u} [discrete_linear_ordered_field α] (p : Polynomial α) (hp : p.nat_degree = 1 + 2 * p.nat_degree.div2) (h : p ≠ 0) : ∃ c : α, p.eval₂ c = 0 "
    ],
    "answer": "{α : Type _} [Field α] (p : Polynomial α) : Odd (p.degree) → ∃ x, p.IsRoot x "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "poly_odd_degree_has_zero",
      "main_prompt": "Every odd degree polynomial over `ℝ` has a zero",
      "prompt": "Natural language version: \"Every odd degree polynomial over `ℝ` has a zero\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 7.384289454988902,
      "use_theorem_name": false
    },
    "outputs": [
      "polynomial_odd_degree_has_zero (p : Polynomial ℝ) (hp : p.degree % 2 = 1) :   ∃ z, p.eval z = 0, End English.  /- Conventions: When leaving comments please use dashes to  overline the word that you do not understand. -/  Open Scope R_scope. Open Scope polynomial_scope.  /-  Why does the mean value theorem have a section explaining why the theorem is correct? You should make a guess as to why this theorem is True, and then look up the Normal proof online.  -/  /- [L",
      ": ∀ p : Polynomial ℝ, p.degree % 2 = 1 -> ∃ x : ℝ , p x = 0 , this is the theorem > #### 4.1.6 #### 4.1.7 #### 4.1.8 #### 4.2.1  If `p` is True, `q` is True, and `r` is True, then: - `r` Implies `q`, and `q` Implies `p`, we can deduce `p` - `p` Implies `q`, and `q` Implies `p`, we can deduce `q` - `p` Implies `q`, `q",
      "exists_x_odd_degree_polynomial_real_eq_0 (p : Polynomial ℝ) (hp : ¬ p.is_monic) :    ∃ x, p.eval x = 0 ",
      "every_odd_polynomial_has_a_zero : ∀ { n : ℕ }, ( ∀ ( P : ℝ →ₗ [ ℝ ] n ), P . 1 = 0 )  We can substitute `42` for the second `ℝ` in the translation above:  theorem every_odd_polynomial_has_a_zero { n } ( P : ℝ →ₗ [ 42 ] n ) : P . 1 = 0  Now we can insert this back into the problem as a hint: example : every_odd_polynomial_has_a_zero ( 42 : ℕ ) ",
      "polynomial_root_odd : (∀ (p : Polynomial ℝ), p.degree > 0 → p.degree % 2 = 1 → has_root p) "
    ],
    "answer": "{α : Type _} [Field α] (p : Polynomial α) : Odd (p.degree) → ∃ x, p.IsRoot x "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "product_conseq_odd",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"The product of two consequitive natural numbers is odd\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The product of two consequitive natural numbers is odd",
      "codex_time": 7.7436661350075155,
      "use_theorem_name": false
    },
    "outputs": [
      "(n : ℕ) : n * (n + 1) % 2 = 1 ",
      "(n : ℕ) : n * nat.succ n % 2 = 1      Natural language version: \"The product of two consequitive natural numbers is Even\" Translate the natural language version to a Lean mathlib version:  theorem (n : ℕ) : n * nat.succ n % 2 = 0      Natural language version: \"If a * b * c * d = 1, then abcd = 1.\" Translate the natural language version to a Lean mathlib version:  theorem (a b c d : ℂ) (habcd : a * b * c * d = 1) :  a * b^(c * d",
      "(n : ℕ) (h : n ≥ 2):  ∃ m : ℕ, ∃ f : Fin m, ∃ a : Fin n, f.1 = 2*a.1 ",
      "(n : ℕ) (h : n ≥ 2):  ∃ m : ℕ, ∃ f : Finₓ m, ∃ a : Finₓ n, f.1 = 2*a.1 ",
      "(n : ℕ) : ∃ m : ℕ, ∀ m' : ℕ, m' * (m' + 1) = m ∧ Odd m ",
      "(n : ℕ) : ∃ m : ℕ, ∀ r : ℕ, n = m*r → ¬ Even m × Even r "
    ],
    "answer": "(n: Nat): Odd <| n * (n + 1) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "product_conseq_odd",
      "main_prompt": "The product of two consequitive natural numbers is odd",
      "prompt": "Natural language version: \" If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.\" Translate the natural language version to a Lean mathlib version:\n theorem {m n : ℕ} :\neven (m ^ n) ↔ even m ∧ n ≠ 0 := \n\nNatural language version: \"A natural number is odd iff it has residue `1` or `3` mod `4`\" Translate the natural language version to a Lean mathlib version:\n theorem {n : ℕ} :\nn % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 := \n\nNatural language version: \"Two natural numbers are equal if and only if the have the same multiples.\" Translate the natural language version to a Lean mathlib version:\n theorem {m n : ℕ} :\n(∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n := \n\nNatural language version: \"The product of the factors is the original number\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ+) :\nn.factor_multiset.prod = n := \n\nNatural language version: \"The product of two consequitive natural numbers is odd\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5561787486076355,
          "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.",
          "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0"
        },
        {
          "sim_score": 0.5415111780166626,
          "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`",
          "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"
        },
        {
          "sim_score": 0.5249637365341187,
          "doc_string": "Two natural numbers are equal if and only if the have the same multiples.",
          "statement": "theorem nat.dvd_right_iff_eq {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n"
        },
        {
          "sim_score": 0.5125280022621155,
          "doc_string": "The product of the factors is the original number",
          "statement": "theorem pnat.prod_factor_multiset (n : ℕ+) : n.factor_multiset.prod = n"
        }
      ],
      "codex_time": 5.241321459994651,
      "search_time": 1.482777747005457,
      "use_theorem_name": false
    },
    "outputs": [
      "{m : ℕ} : Even (m * (m + 1)) ",
      "(n : ℕ+) {a b : ℕ+} : (a*(a+1) = b*(b+1)) → (b % 2 = 1) ",
      "(n : ℕ+) : Odd ((n + 1) * n) ",
      "(n : ℕ+) : ∃ (a : ℕ), 2 * a + 1 = n.gcd (2 * a) ",
      "{m n : ℕ} : n = m + 1 → n * m % 2 = 1 "
    ],
    "answer": "(n: Nat): Odd <| n * (n + 1) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "product_conseq_odd",
      "main_prompt": "The product of two consequitive natural numbers is odd",
      "prompt": "Natural language version: \"The product of two consequitive natural numbers is odd\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 4.301859184983186,
      "use_theorem_name": false
    },
    "outputs": [
      "if_add_conseq_term_is_odd (a : ℕ) : a * (a + 1) % 2 = 1 ",
      "P : ∀ m ∈ ℕ , ∀ n ∈ ℕ , ∃ k ∈ ℕ, k = m * n ↔ k % 2 = 1 ",
      "ex2 : ∀ n : ℕ, ∃ k : ℕ, 2 * n + 2 = 2 * k ",
      "odd_product_of_consequtive_natural_numbers {a b : ℕ} (h0 : a = succ b) : Odd (a*b) ",
      "exists_two_consecutive_odd_numbers : let a "
    ],
    "answer": "(n: Nat): Odd <| n * (n + 1) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "constant_is_differentiable",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every constant function `f x = c` from real numbers to real numbers is differentiable.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every constant function `f x = c` from real numbers to real numbers is differentiable.",
      "codex_time": 5.969116169027984,
      "use_theorem_name": false
    },
    "outputs": [
      "(f : ℝ → ℝ) (c : ℝ)  (f_const : ∀ x, f x = c) :  Differentiable f ",
      "(c : ℝ) (f : ℝ → ℝ) (hf : ∀ x : ℝ, f x = c) :  Differentiable ℝ ℝ f ",
      "(f : ℝ → ℝ) (hf : Continuous f)  (hfc : ∀ x, f x = f.const 0) : Differentiable f ",
      "(f : ℝ → ℝ) (c : ℝ) (hf : ∀ x : ℝ, (f x) = c) :  Differentiable f  ",
      "(c : ℝ) (f : ℝ → ℝ) (h : ∀ x : ℝ, f x = c) :  Differentiable f "
    ],
    "answer": "{f: ℝ → ℝ}: ∃ c: ℝ, (∀ x : ℝ, f x = c) → Differentiable ℝ f "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "constant_is_differentiable",
      "main_prompt": "Every constant function `f x = c` from real numbers to real numbers is differentiable.",
      "prompt": "Natural language version: \"If a function is `C^n` with `n ≥ 1`, then it is differentiable.\" Translate the natural language version to a Lean mathlib version:\n theorem {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {n : with_top ℕ} (h : cont_diff 𝕜 n f) (hn : 1 ≤ n) :\ndifferentiable 𝕜 f := \n\nNatural language version: \"If a function is `C^n` with `n ≥ 1` at a point, then it is differentiable there.\" Translate the natural language version to a Lean mathlib version:\n theorem {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {x : E} {n : with_top ℕ} (h : cont_diff_at 𝕜 n f x) (hn : 1 ≤ n) :\ndifferentiable_at 𝕜 f x := \n\nNatural language version: \" If a function is `C^n` within a set at a point, with `n ≥ 1`, then it is differentiable within this set at this point.\" Translate the natural language version to a Lean mathlib version:\n theorem {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {x : E} {n : with_top ℕ} (h : cont_diff_within_at 𝕜 n f s x) (hn : 1 ≤ n) :\ndifferentiable_within_at 𝕜 f (has_insert.insert x s) x := \n\nNatural language version: \"If a function is `C^n` on a set with `n ≥ 1`, then it is differentiable there.\" Translate the natural language version to a Lean mathlib version:\n theorem {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {n : with_top ℕ} (h : cont_diff_on 𝕜 n f s) (hn : 1 ≤ n) :\ndifferentiable_on 𝕜 f s := \n\nNatural language version: \"Every constant function `f x = c` from real numbers to real numbers is differentiable.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6595531702041626,
          "doc_string": "If a function is `C^n` with `n ≥ 1`, then it is differentiable.",
          "statement": "theorem cont_diff.differentiable {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {n : with_top ℕ} (h : cont_diff 𝕜 n f) (hn : 1 ≤ n) : differentiable 𝕜 f"
        },
        {
          "sim_score": 0.6467167139053345,
          "doc_string": "If a function is `C^n` with `n ≥ 1` at a point, then it is differentiable there.",
          "statement": "theorem cont_diff_at.differentiable_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {x : E} {n : with_top ℕ} (h : cont_diff_at 𝕜 n f x) (hn : 1 ≤ n) : differentiable_at 𝕜 f x"
        },
        {
          "sim_score": 0.6451953649520874,
          "doc_string": " If a function is `C^n` within a set at a point, with `n ≥ 1`, then it is differentiable within this set at this point.",
          "statement": "theorem cont_diff_within_at.differentiable_within_at' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {x : E} {n : with_top ℕ} (h : cont_diff_within_at 𝕜 n f s x) (hn : 1 ≤ n) : differentiable_within_at 𝕜 f (has_insert.insert x s) x"
        },
        {
          "sim_score": 0.6353325843811035,
          "doc_string": "If a function is `C^n` on a set with `n ≥ 1`, then it is differentiable there.",
          "statement": "theorem cont_diff_on.differentiable_on {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {n : with_top ℕ} (h : cont_diff_on 𝕜 n f s) (hn : 1 ≤ n) : differentiable_on 𝕜 f s"
        }
      ],
      "codex_time": 6.46006202098215,
      "search_time": 1.5521861550223548,
      "use_theorem_name": false
    },
    "outputs": [
      "{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {f : ℝ → ℝ} (h : const_func f) : Differentiable 𝕜 f ",
      "differentiable.const {f : real → real} (h : ∀x, f x = f 0) : Differentiable f ",
      "{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} (c : F) : (∀ x : E, f x = c) → DifferentiableOn 𝕜 f (univ : Set E) ",
      "{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} (c : F) : (∀ x : E, f x = c) → DifferentiableOn 𝕜 f (univ : Setₓ E) ",
      "differentiable_const (c : ℝ) : Differentiable ℝ (λ x:ℝ, c) ",
      "{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {f : ℝ → ℝ} {c : ℝ} (h : constant f c) : DifferentiableOn 𝕜 f univ "
    ],
    "answer": "{f: ℝ → ℝ}: ∃ c: ℝ, (∀ x : ℝ, f x = c) → Differentiable ℝ f "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "constant_is_differentiable",
      "main_prompt": "Every constant function `f x = c` from real numbers to real numbers is differentiable.",
      "prompt": "Natural language version: \"Every constant function `f x = c` from real numbers to real numbers is differentiable.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 6.447238699009176,
      "use_theorem_name": false
    },
    "outputs": [
      "diff_const_fun (f : ℝ → ℝ) (c : ℝ) (hf : ∀x : ℝ, f x = c) : Differentiable f ↔ DifferentiableAt f c ",
      "real_differentiable_const (f : ℝ → ℝ) [Hf : DifferentiableAt f a] (c : ℝ) :   f a = c → DifferentiableOn f (Icc a (a+1)) ",
      "diff_const (f : ℝ → ℝ) (c : ℝ) (h : ∀ x, f x = c) : Differentiable f ",
      "dber : ∀ {f : ℝ → ℝ}, ∀ {c}, (∀ x : ℝ, f x = c) → Differentiable f ",
      "my_thm (x : R) : DifferentiableAt (λ x, 0) x "
    ],
    "answer": "{f: ℝ → ℝ}: ∃ c: ℝ, (∀ x : ℝ, f x = c) → Differentiable ℝ f "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "index_two_subgroup",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every index 2 subgroup of a group is free\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every index 2 subgroup of a group is free",
      "codex_time": 4.75069759998587,
      "use_theorem_name": false
    },
    "outputs": [
      "(G : Type*) [Group G] (s : Set G) [IsSubgroup s] (Hs : Fintype.card s = 2) : is_free s ",
      "(G : Type*) [Groupₓₓ G] (s : Set G) [IsSubgroup s] (Hs : Fintype.card s = 2) : is_free s ",
      "(G : Type*) [Group G] (s : Setₓ G) [IsSubgroup s] (Hs : Fintype.card s = 2) : is_free s ",
      "(G : Type*) [Groupₓₓ G] (s : Setₓ G) [IsSubgroup s] (Hs : Fintype.card s = 2) : is_free s ",
      "(G : Type*) [Groupₓ G] (s : Set G) [IsSubgroup s] (Hs : Fintype.card s = 2) : is_free s ",
      "(G : Type*) [Groupₓ G] (s : Setₓ G) [IsSubgroup s] (Hs : Fintype.card s = 2) : is_free s ",
      "(G : Type*) [Group G] (s : Set G) [IsSubgroup s] (Hs : Fintypeₓ.card s = 2) : is_free s ",
      "(G : Type*) [Groupₓₓ G] (s : Set G) [IsSubgroup s] (Hs : Fintypeₓ.card s = 2) : is_free s ",
      "(G : Type*) [Group G] (s : Setₓ G) [IsSubgroup s] (Hs : Fintypeₓ.card s = 2) : is_free s ",
      "(G : Type*) [Groupₓₓ G] (s : Setₓ G) [IsSubgroup s] (Hs : Fintypeₓ.card s = 2) : is_free s ",
      "(G : Type*) [Groupₓ G] (s : Set G) [IsSubgroup s] (Hs : Fintypeₓ.card s = 2) : is_free s ",
      "(G : Type*) [Groupₓ G] (s : Setₓ G) [IsSubgroup s] (Hs : Fintypeₓ.card s = 2) : is_free s ",
      "is_free_group_two :  ∀ (G : Type*) [Group G], Group.is_free_group {s : G | orderOf G ≠ 2} ",
      "is_free_group_two :  ∀ (G : Type*) [Groupₓₓ G], Groupₓₓ.is_free_group {s : G | orderOf G ≠ 2} ",
      "is_free_group_two :  ∀ (G : Type*) [Groupₓ G], Groupₓ.is_free_group {s : G | orderOf G ≠ 2} ",
      "(G : Type*) [Group G] (s : Set G) [h2 : IsSubgroup s]  [hi_2 : (index_aux G s h2) = 2] : is_free s ",
      "(G : Type*) [Groupₓₓ G] (s : Set G) [h2 : IsSubgroup s]  [hi_2 : (index_aux G s h2) = 2] : is_free s ",
      "(G : Type*) [Group G] (s : Setₓ G) [h2 : IsSubgroup s]  [hi_2 : (index_aux G s h2) = 2] : is_free s ",
      "(G : Type*) [Groupₓₓ G] (s : Setₓ G) [h2 : IsSubgroup s]  [hi_2 : (index_aux G s h2) = 2] : is_free s ",
      "(G : Type*) [Groupₓ G] (s : Set G) [h2 : IsSubgroup s]  [hi_2 : (index_aux G s h2) = 2] : is_free s ",
      "(G : Type*) [Groupₓ G] (s : Setₓ G) [h2 : IsSubgroup s]  [hi_2 : (index_aux G s h2) = 2] : is_free s ",
      "(G : Type*) [Group G] (H : Set G) (hH : 2 ∣ Cardinal.mk H) : ∃ X : Set G, fintype.cardinal X = 2 ",
      "(G : Type*) [Groupₓₓ G] (H : Set G) (hH : 2 ∣ Cardinal.mk H) : ∃ X : Set G, fintype.cardinal X = 2 ",
      "(G : Type*) [Group G] (H : Setₓ G) (hH : 2 ∣ Cardinal.mk H) : ∃ X : Setₓ G, fintype.cardinal X = 2 ",
      "(G : Type*) [Groupₓₓ G] (H : Setₓ G) (hH : 2 ∣ Cardinal.mk H) : ∃ X : Setₓ G, fintype.cardinal X = 2 ",
      "(G : Type*) [Groupₓ G] (H : Set G) (hH : 2 ∣ Cardinal.mk H) : ∃ X : Set G, fintype.cardinal X = 2 ",
      "(G : Type*) [Groupₓ G] (H : Setₓ G) (hH : 2 ∣ Cardinal.mk H) : ∃ X : Setₓ G, fintype.cardinal X = 2 ",
      "(G : Type*) [Group G]  (H : Subgroup G) (h2 : H.1.2) : FreeGroup G ",
      "(G : Type*) [Groupₓₓ G]  (H : Subgroup G) (h2 : H.1.2) : FreeGroup G ",
      "(G : Type*) [Groupₓ G]  (H : Subgroup G) (h2 : H.1.2) : FreeGroup G "
    ],
    "answer": "{G : Type _} [Groupₓ G] (H : Subgroup G): H.index = 2 → Subgroup.Normal H "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "index_two_subgroup",
      "main_prompt": "Every index 2 subgroup of a group is free",
      "prompt": "Natural language version: \"Subgroups of torsion-free groups are torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) :\nmonoid.is_torsion_free ↥H := \n\nNatural language version: \"**Schreier's Lemma**: A finite index subgroup of a finitely generated  group is finitely generated.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] {H : subgroup G} [hG : group.fg G] (hH : H.index ≠ 0) :\ngroup.fg ↥H := \n\nNatural language version: \"Direct products of torsion free groups are torsion free.\" Translate the natural language version to a Lean mathlib version:\n theorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) :\nmonoid.is_torsion_free (Π (i : η), Gs i) := \n\nNatural language version: \"Quotienting a group by its torsion subgroup yields a torsion free group.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type u_1) [comm_group G] :\nmonoid.is_torsion_free (G ⧸ torsion G) := \n\nNatural language version: \"Every index 2 subgroup of a group is free\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6636497974395752,
          "doc_string": "Subgroups of torsion-free groups are torsion-free.",
          "statement": "theorem is_torsion_free.subgroup {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) : monoid.is_torsion_free ↥H"
        },
        {
          "sim_score": 0.5494142770767212,
          "doc_string": "**Schreier's Lemma**: A finite index subgroup of a finitely generated  group is finitely generated.",
          "statement": "theorem subgroup.fg_of_index_ne_zero {G : Type u_1} [group G] {H : subgroup G} [hG : group.fg G] (hH : H.index ≠ 0) : group.fg ↥H"
        },
        {
          "sim_score": 0.5431281924247742,
          "doc_string": "Direct products of torsion free groups are torsion free.",
          "statement": "theorem is_torsion_free.prod {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i)"
        },
        {
          "sim_score": 0.5406138896942139,
          "doc_string": "Quotienting a group by its torsion subgroup yields a torsion free group.",
          "statement": "theorem is_torsion_free.quotient_torsion (G : Type u_1) [comm_group G] : monoid.is_torsion_free (G ⧸ torsion G)"
        }
      ],
      "codex_time": 6.778020755999023,
      "search_time": 1.501041351002641,
      "use_theorem_name": false
    },
    "outputs": [
      "(G : Type u_1) [Group G] (H : Subgroup G) (pfHG : H.index = 2) :  @free_of_IIC _ _ 1 _ H ",
      "(G : Type u_1) [Groupₓₓ G] (H : Subgroup G) (pfHG : H.index = 2) :  @free_of_IIC _ _ 1 _ H ",
      "(G : Type u_1) [Groupₓ G] (H : Subgroup G) (pfHG : H.index = 2) :  @free_of_IIC _ _ 1 _ H ",
      "{G : Type u_1} [Group G] (H : Subgroup G) (hi2 : H.index = 2) : FreeGroup ↥H ",
      "{G : Type u_1} [Groupₓₓ G] (H : Subgroup G) (hi2 : H.index = 2) : FreeGroup ↥H ",
      "{G : Type u_1} [Groupₓ G] (H : Subgroup G) (hi2 : H.index = 2) : FreeGroup ↥H ",
      "{A : Type u_1} [G : Group A] (H : Subgroup A) (fH : H.index = 2) : group.free H.carrier ",
      "{A : Type u_1} [G : Groupₓₓ A] (H : Subgroup A) (fH : H.index = 2) : group.free H.carrier ",
      "{A : Type u_1} [G : Groupₓ A] (H : Subgroup A) (fH : H.index = 2) : group.free H.carrier ",
      "(G : Type u_1) [CommGroup G] (H : Subgroup G) : H.index = 2 → FreeGroup G H ",
      "(G : Type u_1) [CommGroupₓₓ G] (H : Subgroup G) : H.index = 2 → FreeGroup G H ",
      "(G : Type u_1) [CommGroupₓ G] (H : Subgroup G) : H.index = 2 → FreeGroup G H ",
      "{G : Type u_1} [Group G] : ∀ (H : Subgroup G) (hH : H.finite.index = 2), FreeGroup H ",
      "{G : Type u_1} [Groupₓₓ G] : ∀ (H : Subgroup G) (hH : H.finite.index = 2), FreeGroup H ",
      "{G : Type u_1} [Groupₓ G] : ∀ (H : Subgroup G) (hH : H.finite.index = 2), FreeGroup H "
    ],
    "answer": "{G : Type _} [Groupₓ G] (H : Subgroup G): H.index = 2 → Subgroup.Normal H "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "index_two_subgroup",
      "main_prompt": "Every index 2 subgroup of a group is free",
      "prompt": "Natural language version: \"Every index 2 subgroup of a group is free\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 12.771684473002097,
      "use_theorem_name": false
    },
    "outputs": [
      "is_free_of_two_subgroup { G : Type * } [ Group G ] ( H : Subgroup G ) ( H2 : ∀ ( g : G ) , g^2 ∈ H ) :     is_free H  Proofs in Lean require axioms used in the proof to be explicitly stated. For example, the theorem above needs to be modified to include: universe u variables { X : Type u } [ Group X ] to indicate that X is a type that belongs to the universe (which is a technical issue that allows us to rigorously treat large categories of mathematical objects).  The latest version of the theorem can be seen at https://github.com/leanprover-",
      "is_free_of_two_subgroup { G : Type * } [ Groupₓₓ G ] ( H : Subgroup G ) ( H2 : ∀ ( g : G ) , g^2 ∈ H ) :     is_free H  Proofs in Lean require axioms used in the proof to be explicitly stated. For example, the theorem above needs to be modified to include: universe u variables { X : Type u } [ Groupₓₓ X ] to indicate that X is a type that belongs to the universe (which is a technical issue that allows us to rigorously treat large categories of mathematical objects).  The latest version of the theorem can be seen at https://github.com/leanprover-",
      "is_free_of_two_subgroup { G : Type * } [ Groupₓ G ] ( H : Subgroup G ) ( H2 : ∀ ( g : G ) , g^2 ∈ H ) :     is_free H  Proofs in Lean require axioms used in the proof to be explicitly stated. For example, the theorem above needs to be modified to include: universe u variables { X : Type u } [ Groupₓ X ] to indicate that X is a type that belongs to the universe (which is a technical issue that allows us to rigorously treat large categories of mathematical objects).  The latest version of the theorem can be seen at https://github.com/leanprover-",
      "it_free_on_index_2 {G : Type*} [Group G] (H : Set G) [Fintype H] (subgp : find_subgroup H G)    (indexed : find_subgroup_indexing subgp H = 2) :   @IsFreeGroup G _ _ {x | x ∈ H} set.mem set.mem_erase _ _ ",
      "it_free_on_index_2 {G : Type*} [Groupₓₓ G] (H : Set G) [Fintype H] (subgp : find_subgroup H G)    (indexed : find_subgroup_indexing subgp H = 2) :   @IsFreeGroup G _ _ {x | x ∈ H} set.mem set.mem_erase _ _ ",
      "it_free_on_index_2 {G : Type*} [Group G] (H : Setₓ G) [Fintype H] (subgp : find_subgroup H G)    (indexed : find_subgroup_indexing subgp H = 2) :   @IsFreeGroup G _ _ {x | x ∈ H} set.mem set.mem_erase _ _ ",
      "it_free_on_index_2 {G : Type*} [Groupₓₓ G] (H : Setₓ G) [Fintype H] (subgp : find_subgroup H G)    (indexed : find_subgroup_indexing subgp H = 2) :   @IsFreeGroup G _ _ {x | x ∈ H} set.mem set.mem_erase _ _ ",
      "it_free_on_index_2 {G : Type*} [Groupₓ G] (H : Set G) [Fintype H] (subgp : find_subgroup H G)    (indexed : find_subgroup_indexing subgp H = 2) :   @IsFreeGroup G _ _ {x | x ∈ H} set.mem set.mem_erase _ _ ",
      "it_free_on_index_2 {G : Type*} [Groupₓ G] (H : Setₓ G) [Fintype H] (subgp : find_subgroup H G)    (indexed : find_subgroup_indexing subgp H = 2) :   @IsFreeGroup G _ _ {x | x ∈ H} set.mem set.mem_erase _ _ ",
      "it_free_on_index_2 {G : Type*} [Group G] (H : Set G) [Fintypeₓ H] (subgp : find_subgroup H G)    (indexed : find_subgroup_indexing subgp H = 2) :   @IsFreeGroup G _ _ {x | x ∈ H} set.mem set.mem_erase _ _ ",
      "it_free_on_index_2 {G : Type*} [Groupₓₓ G] (H : Set G) [Fintypeₓ H] (subgp : find_subgroup H G)    (indexed : find_subgroup_indexing subgp H = 2) :   @IsFreeGroup G _ _ {x | x ∈ H} set.mem set.mem_erase _ _ ",
      "it_free_on_index_2 {G : Type*} [Group G] (H : Setₓ G) [Fintypeₓ H] (subgp : find_subgroup H G)    (indexed : find_subgroup_indexing subgp H = 2) :   @IsFreeGroup G _ _ {x | x ∈ H} set.mem set.mem_erase _ _ ",
      "it_free_on_index_2 {G : Type*} [Groupₓₓ G] (H : Setₓ G) [Fintypeₓ H] (subgp : find_subgroup H G)    (indexed : find_subgroup_indexing subgp H = 2) :   @IsFreeGroup G _ _ {x | x ∈ H} set.mem set.mem_erase _ _ ",
      "it_free_on_index_2 {G : Type*} [Groupₓ G] (H : Set G) [Fintypeₓ H] (subgp : find_subgroup H G)    (indexed : find_subgroup_indexing subgp H = 2) :   @IsFreeGroup G _ _ {x | x ∈ H} set.mem set.mem_erase _ _ ",
      "it_free_on_index_2 {G : Type*} [Groupₓ G] (H : Setₓ G) [Fintypeₓ H] (subgp : find_subgroup H G)    (indexed : find_subgroup_indexing subgp H = 2) :   @IsFreeGroup G _ _ {x | x ∈ H} set.mem set.mem_erase _ _ ",
      "free_sub (G : Type*) [Group G] (H : Subgroup G)   (h2 : ∀ v : FreeGroup G, ∃ (x : G), x ∈ H ∧ x ^ 2 = 1) : FreeGroup G ",
      "free_sub (G : Type*) [Groupₓₓ G] (H : Subgroup G)   (h2 : ∀ v : FreeGroup G, ∃ (x : G), x ∈ H ∧ x ^ 2 = 1) : FreeGroup G ",
      "free_sub (G : Type*) [Groupₓ G] (H : Subgroup G)   (h2 : ∀ v : FreeGroup G, ∃ (x : G), x ∈ H ∧ x ^ 2 = 1) : FreeGroup G ",
      "every_index_2_subgroup_is_free { G : Type } [ Group G ] :   ∀ H : Subgroup G, [ H ] = 2 → ( ∃ ( g : G ), _ ) ∼ FreeGroup ( equiv_fintype H )  We now have to fill in all the ideas with details.  1. What means *a Group*? It's a type equipped with arrows for the Group operations. So, given a type G and two functions G × G → G and G → G, we want to check that the relations hold (associativity, identity, invertibility = axioms for a Group) We go back to the definition",
      "every_index_2_subgroup_is_free { G : Type } [ Groupₓₓ G ] :   ∀ H : Subgroup G, [ H ] = 2 → ( ∃ ( g : G ), _ ) ∼ FreeGroup ( equiv_fintype H )  We now have to fill in all the ideas with details.  1. What means *a Groupₓₓ*? It's a type equipped with arrows for the Groupₓₓ operations. So, given a type G and two functions G × G → G and G → G, we want to check that the relations hold (associativity, identity, invertibility = axioms for a Groupₓₓ) We go back to the definition",
      "every_index_2_subgroup_is_free { G : Type } [ Groupₓ G ] :   ∀ H : Subgroup G, [ H ] = 2 → ( ∃ ( g : G ), _ ) ∼ FreeGroup ( equiv_fintype H )  We now have to fill in all the ideas with details.  1. What means *a Groupₓ*? It's a type equipped with arrows for the Groupₓ operations. So, given a type G and two functions G × G → G and G → G, we want to check that the relations hold (associativity, identity, invertibility = axioms for a Groupₓ) We go back to the definition",
      "natural_enum   Define the theorem:  3. Write out the equation in Lean mathlib version  4. Check the equation, it should compile successfully   Proof of the theorem:  5. Give names to all the terms  6. For each term, substitute the definition of that term,     then mark the substituted term with a comment.  7. Proof comes next. Try to follow the marked out template,     we will rewrite the proof in Lean after this. *)  /- Theorem: Every index 2 Subgroup of a Group is free Translation: Let G be a group.              Suppose H is a Subgroup of G containing the identity of G such that              card H = 2",
      "natural_enum   Define the theorem:  3. Write out the equation in Lean mathlib version  4. Check the equation, it should compile successfully   Proof of the theorem:  5. Give names to all the terms  6. For each term, substitute the definition of that term,     then mark the substituted term with a comment.  7. Proof comes next. Try to follow the marked out template,     we will rewrite the proof in Lean after this. *)  /- Theorem: Every index 2 Subgroup of a Groupₓₓ is free Translation: Let G be a group.              Suppose H is a Subgroup of G containing the identity of G such that              card H = 2",
      "natural_enum   Define the theorem:  3. Write out the equation in Lean mathlib version  4. Check the equation, it should compile successfully   Proof of the theorem:  5. Give names to all the terms  6. For each term, substitute the definition of that term,     then mark the substituted term with a comment.  7. Proof comes next. Try to follow the marked out template,     we will rewrite the proof in Lean after this. *)  /- Theorem: Every index 2 Subgroup of a Groupₓ is free Translation: Let G be a group.              Suppose H is a Subgroup of G containing the identity of G such that              card H = 2"
    ],
    "answer": "{G : Type _} [Groupₓ G] (H : Subgroup G): H.index = 2 → Subgroup.Normal H "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "subgpFree",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every subgroup of a free group is free\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every subgroup of a free group is free",
      "codex_time": 10.352006158005679,
      "use_theorem_name": false
    },
    "outputs": [
      "(G : Type*) [Group G]  (S : Set G) (fS : IsSubgroup S)  (fG : is_free (fS.to_subtype)) :  is_free S ",
      "(G : Type*) [Groupₓₓ G]  (S : Set G) (fS : IsSubgroup S)  (fG : is_free (fS.to_subtype)) :  is_free S ",
      "(G : Type*) [Group G]  (S : Setₓ G) (fS : IsSubgroup S)  (fG : is_free (fS.to_subtype)) :  is_free S ",
      "(G : Type*) [Groupₓₓ G]  (S : Setₓ G) (fS : IsSubgroup S)  (fG : is_free (fS.to_subtype)) :  is_free S ",
      "(G : Type*) [Groupₓ G]  (S : Set G) (fS : IsSubgroup S)  (fG : is_free (fS.to_subtype)) :  is_free S ",
      "(G : Type*) [Groupₓ G]  (S : Setₓ G) (fS : IsSubgroup S)  (fG : is_free (fS.to_subtype)) :  is_free S ",
      "(G : Type*) [Group G] (H : Subgroup G)  (free_G : FreeGroup G) :  FreeGroup H ",
      "(G : Type*) [Groupₓₓ G] (H : Subgroup G)  (free_G : FreeGroup G) :  FreeGroup H ",
      "(G : Type*) [Groupₓ G] (H : Subgroup G)  (free_G : FreeGroup G) :  FreeGroup H ",
      "(G : Type*) [Group G] [IsFreeGroup G]  {H : Set G} [IsSubgroup H] (hH : IsFreeGroup H) :  ∀ x : H, x ∈ G ",
      "(G : Type*) [Groupₓₓ G] [IsFreeGroup G]  {H : Set G} [IsSubgroup H] (hH : IsFreeGroup H) :  ∀ x : H, x ∈ G ",
      "(G : Type*) [Group G] [IsFreeGroup G]  {H : Setₓ G} [IsSubgroup H] (hH : IsFreeGroup H) :  ∀ x : H, x ∈ G ",
      "(G : Type*) [Groupₓₓ G] [IsFreeGroup G]  {H : Setₓ G} [IsSubgroup H] (hH : IsFreeGroup H) :  ∀ x : H, x ∈ G ",
      "(G : Type*) [Groupₓ G] [IsFreeGroup G]  {H : Set G} [IsSubgroup H] (hH : IsFreeGroup H) :  ∀ x : H, x ∈ G ",
      "(G : Type*) [Groupₓ G] [IsFreeGroup G]  {H : Setₓ G} [IsSubgroup H] (hH : IsFreeGroup H) :  ∀ x : H, x ∈ G ",
      "(X : Type*) [Group X] (free : ∀ x : X, True)  (g : X → X) (hg : ∀ x y : X, g(x * y) = g(x) * g(y))  (H : Set X) (hH : ∅ ∈ H ∧ (∀ x y ∈ H, x * y ∈ H) ∧ ∀ x ∈ H, x⁻¹ ∈ H) :  ∀ x : X, ∃ y ∈ H, x = g(y) ",
      "(X : Type*) [Groupₓₓ X] (free : ∀ x : X, True)  (g : X → X) (hg : ∀ x y : X, g(x * y) = g(x) * g(y))  (H : Set X) (hH : ∅ ∈ H ∧ (∀ x y ∈ H, x * y ∈ H) ∧ ∀ x ∈ H, x⁻¹ ∈ H) :  ∀ x : X, ∃ y ∈ H, x = g(y) ",
      "(X : Type*) [Group X] (free : ∀ x : X, True)  (g : X → X) (hg : ∀ x y : X, g(x * y) = g(x) * g(y))  (H : Setₓ X) (hH : ∅ ∈ H ∧ (∀ x y ∈ H, x * y ∈ H) ∧ ∀ x ∈ H, x⁻¹ ∈ H) :  ∀ x : X, ∃ y ∈ H, x = g(y) ",
      "(X : Type*) [Groupₓₓ X] (free : ∀ x : X, True)  (g : X → X) (hg : ∀ x y : X, g(x * y) = g(x) * g(y))  (H : Setₓ X) (hH : ∅ ∈ H ∧ (∀ x y ∈ H, x * y ∈ H) ∧ ∀ x ∈ H, x⁻¹ ∈ H) :  ∀ x : X, ∃ y ∈ H, x = g(y) ",
      "(X : Type*) [Groupₓ X] (free : ∀ x : X, True)  (g : X → X) (hg : ∀ x y : X, g(x * y) = g(x) * g(y))  (H : Set X) (hH : ∅ ∈ H ∧ (∀ x y ∈ H, x * y ∈ H) ∧ ∀ x ∈ H, x⁻¹ ∈ H) :  ∀ x : X, ∃ y ∈ H, x = g(y) ",
      "(X : Type*) [Groupₓ X] (free : ∀ x : X, True)  (g : X → X) (hg : ∀ x y : X, g(x * y) = g(x) * g(y))  (H : Setₓ X) (hH : ∅ ∈ H ∧ (∀ x y ∈ H, x * y ∈ H) ∧ ∀ x ∈ H, x⁻¹ ∈ H) :  ∀ x : X, ∃ y ∈ H, x = g(y) ",
      "(G : Type*) [Group G] (H : Set G) [IsSubgroup H] :  IsSubmonoid H → IsSubgroup H ",
      "(G : Type*) [Groupₓₓ G] (H : Set G) [IsSubgroup H] :  IsSubmonoid H → IsSubgroup H ",
      "(G : Type*) [Group G] (H : Setₓ G) [IsSubgroup H] :  IsSubmonoid H → IsSubgroup H ",
      "(G : Type*) [Groupₓₓ G] (H : Setₓ G) [IsSubgroup H] :  IsSubmonoid H → IsSubgroup H ",
      "(G : Type*) [Groupₓ G] (H : Set G) [IsSubgroup H] :  IsSubmonoid H → IsSubgroup H ",
      "(G : Type*) [Groupₓ G] (H : Setₓ G) [IsSubgroup H] :  IsSubmonoid H → IsSubgroup H "
    ],
    "answer": "{G : Type _} [Groupₓ G] : (K : Subgroup G) → Σ β, FreeGroup β ≃* ↥K "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "subgpFree",
      "main_prompt": "Every subgroup of a free group is free",
      "prompt": "Natural language version: \"Subgroups of torsion-free groups are torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) :\nmonoid.is_torsion_free ↥H := \n\nNatural language version: \"Quotienting a group by its torsion subgroup yields a torsion free group.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type u_1) [comm_group G] :\nmonoid.is_torsion_free (G ⧸ torsion G) := \n\nNatural language version: \"Subgroups of additive torsion-free groups are additively torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [add_group G] (tG : add_monoid.is_torsion_free G) (H : add_subgroup G) :\nadd_monoid.is_torsion_free ↥H := \n\nNatural language version: \"Direct products of torsion free groups are torsion free.\" Translate the natural language version to a Lean mathlib version:\n theorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) :\nmonoid.is_torsion_free (Π (i : η), Gs i) := \n\nNatural language version: \"Every subgroup of a free group is free\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.7357965111732483,
          "doc_string": "Subgroups of torsion-free groups are torsion-free.",
          "statement": "theorem is_torsion_free.subgroup {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) : monoid.is_torsion_free ↥H"
        },
        {
          "sim_score": 0.621972382068634,
          "doc_string": "Quotienting a group by its torsion subgroup yields a torsion free group.",
          "statement": "theorem is_torsion_free.quotient_torsion (G : Type u_1) [comm_group G] : monoid.is_torsion_free (G ⧸ torsion G)"
        },
        {
          "sim_score": 0.6199988722801208,
          "doc_string": "Subgroups of additive torsion-free groups are additively torsion-free.",
          "statement": "theorem is_torsion_free.add_subgroup {G : Type u_1} [add_group G] (tG : add_monoid.is_torsion_free G) (H : add_subgroup G) : add_monoid.is_torsion_free ↥H"
        },
        {
          "sim_score": 0.58650141954422,
          "doc_string": "Direct products of torsion free groups are torsion free.",
          "statement": "theorem is_torsion_free.prod {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i)"
        }
      ],
      "codex_time": 2.655978763999883,
      "search_time": 1.4969823299907148,
      "use_theorem_name": false
    },
    "outputs": [
      "(α : Type u) (F : FreeGroup α) {H : Set F} [IsSubgroup H] : IsFreeGroup H ",
      "(α : Type u) (F : FreeGroup α) {H : Setₓ F} [IsSubgroup H] : IsFreeGroup H ",
      "{α : Type u_1} (F : FreeGroup α) (H : Subgroup (FreeGroup α)) : FreeGroup.of (H : Set (FreeGroup α))= H ",
      "{α : Type u_1} (F : FreeGroup α) (H : Subgroup (FreeGroup α)) : FreeGroup.of (H : Setₓ (FreeGroup α))= H ",
      "(G : Type u_1) [FreeGroup G] (H : Subgroup G) :    FreeGroup (Subtype.val H) ",
      "{G : Type u_1} [Group G] (fG : FreeGroup G) (H : Subgroup G) : FreeGroup ↥H ",
      "{G : Type u_1} [Groupₓₓ G] (fG : FreeGroup G) (H : Subgroup G) : FreeGroup ↥H ",
      "{G : Type u_1} [Groupₓ G] (fG : FreeGroup G) (H : Subgroup G) : FreeGroup ↥H ",
      "{η : Type u_1} {G : Type u_2} [Group G] (frG : FreeGroup η G) (H : Subgroup G) : FreeGroup η ↥H ",
      "{η : Type u_1} {G : Type u_2} [Groupₓₓ G] (frG : FreeGroup η G) (H : Subgroup G) : FreeGroup η ↥H ",
      "{η : Type u_1} {G : Type u_2} [Groupₓ G] (frG : FreeGroup η G) (H : Subgroup G) : FreeGroup η ↥H "
    ],
    "answer": "{G : Type _} [Groupₓ G] : (K : Subgroup G) → Σ β, FreeGroup β ≃* ↥K "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "subgpFree",
      "main_prompt": "Every subgroup of a free group is free",
      "prompt": "Natural language version: \"Every subgroup of a free group is free\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 7.362826420983765,
      "use_theorem_name": false
    },
    "outputs": [
      "free_group_subgroup_is_free : ...  -- You might find these useful:  def FreeGroup (X : Type*) : Type* ",
      "is_free_of_free_sub { G : Type * } [ Group G ] [ H : is_free G ] ( H' : Subgroup G ) : Subgroup G ",
      "is_free_of_free_sub { G : Type * } [ Groupₓₓ G ] [ H : is_free G ] ( H' : Subgroup G ) : Subgroup G ",
      "is_free_of_free_sub { G : Type * } [ Groupₓ G ] [ H : is_free G ] ( H' : Subgroup G ) : Subgroup G ",
      "every_subgroup_of_free_group_is_free ( G : Type ) [ Group G ] [ Fintype G : Fintype G ] [ DecidableEq G ] ( f : Finset G ) ( h : IsSubgroup f ) : IsFreeGroup f ",
      "every_subgroup_of_free_group_is_free ( G : Type ) [ Groupₓₓ G ] [ Fintype G : Fintype G ] [ DecidableEq G ] ( f : Finset G ) ( h : IsSubgroup f ) : IsFreeGroup f ",
      "every_subgroup_of_free_group_is_free ( G : Type ) [ Groupₓ G ] [ Fintype G : Fintype G ] [ DecidableEq G ] ( f : Finset G ) ( h : IsSubgroup f ) : IsFreeGroup f ",
      "every_subgroup_of_free_group_is_free ( G : Type ) [ Group G ] [ Fintypeₓ G : Fintypeₓ G ] [ DecidableEq G ] ( f : Finset G ) ( h : IsSubgroup f ) : IsFreeGroup f ",
      "every_subgroup_of_free_group_is_free ( G : Type ) [ Groupₓₓ G ] [ Fintypeₓ G : Fintypeₓ G ] [ DecidableEq G ] ( f : Finset G ) ( h : IsSubgroup f ) : IsFreeGroup f ",
      "every_subgroup_of_free_group_is_free ( G : Type ) [ Groupₓ G ] [ Fintypeₓ G : Fintypeₓ G ] [ DecidableEq G ] ( f : Finset G ) ( h : IsSubgroup f ) : IsFreeGroup f ",
      "is_free (p : ℕ → Prop) (G : Type) [Group G] :   (∀ H : Set G, IsSubgroup H → IsFreeGroup p H)",
      "is_free (p : ℕ → Prop) (G : Type) [Groupₓₓ G] :   (∀ H : Set G, IsSubgroup H → IsFreeGroup p H)",
      "is_free (p : ℕ → Prop) (G : Type) [Group G] :   (∀ H : Setₓ G, IsSubgroup H → IsFreeGroup p H)",
      "is_free (p : ℕ → Prop) (G : Type) [Groupₓₓ G] :   (∀ H : Setₓ G, IsSubgroup H → IsFreeGroup p H)",
      "is_free (p : ℕ → Prop) (G : Type) [Groupₓ G] :   (∀ H : Set G, IsSubgroup H → IsFreeGroup p H)",
      "is_free (p : ℕ → Prop) (G : Type) [Groupₓ G] :   (∀ H : Setₓ G, IsSubgroup H → IsFreeGroup p H)",
      "natlang (G : Group) [is_free G] (H : Subgroup G) : is_free H  How to write the type of theorem natlang?   1º attempt:   theorem natlang (G : Group) [is_free G] (H : Subgroup G) : is_free H  apply has_free_generators.free_group.mpr ...  ^^^^^^ ERROR ^^^^^^   2º attempt:  theorem natlang (G : Group) [is_free G] (H : Subgroup G) : is_free H.  apply has_free_generators.free_group.mpr ...  ^^^^^^ ERROR ^^^^^^",
      "natlang (G : Groupₓₓ) [is_free G] (H : Subgroup G) : is_free H  How to write the type of theorem natlang?   1º attempt:   theorem natlang (G : Groupₓₓ) [is_free G] (H : Subgroup G) : is_free H  apply has_free_generators.free_group.mpr ...  ^^^^^^ ERROR ^^^^^^   2º attempt:  theorem natlang (G : Groupₓₓ) [is_free G] (H : Subgroup G) : is_free H.  apply has_free_generators.free_group.mpr ...  ^^^^^^ ERROR ^^^^^^",
      "natlang (G : Groupₓ) [is_free G] (H : Subgroup G) : is_free H  How to write the type of theorem natlang?   1º attempt:   theorem natlang (G : Groupₓ) [is_free G] (H : Subgroup G) : is_free H  apply has_free_generators.free_group.mpr ...  ^^^^^^ ERROR ^^^^^^   2º attempt:  theorem natlang (G : Groupₓ) [is_free G] (H : Subgroup G) : is_free H.  apply has_free_generators.free_group.mpr ...  ^^^^^^ ERROR ^^^^^^"
    ],
    "answer": "{G : Type _} [Groupₓ G] : (K : Subgroup G) → Σ β, FreeGroup β ≃* ↥K "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "free_group_torsion_free",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every free group is torsion free\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every free group is torsion free",
      "codex_time": 11.572696299001109,
      "use_theorem_name": false
    },
    "outputs": [
      "(G : Type*) [Group G] (is_free : FreeGroup G) :  ∀ x : G, x ≠ 1 → ∃ n : ℤ, x ^ n = 1 ",
      "(G : Type*) [Groupₓₓ G] (is_free : FreeGroup G) :  ∀ x : G, x ≠ 1 → ∃ n : ℤ, x ^ n = 1 ",
      "(G : Type*) [Groupₓ G] (is_free : FreeGroup G) :  ∀ x : G, x ≠ 1 → ∃ n : ℤ, x ^ n = 1 ",
      "(G : Type*) [Group G] [Fintype G] (hG : free G) :  ∀ x : G, x ≠ 1 → ∃ i : ℤ, x ^ i = 1 → 1 ",
      "(G : Type*) [Groupₓₓ G] [Fintype G] (hG : free G) :  ∀ x : G, x ≠ 1 → ∃ i : ℤ, x ^ i = 1 → 1 ",
      "(G : Type*) [Groupₓ G] [Fintype G] (hG : free G) :  ∀ x : G, x ≠ 1 → ∃ i : ℤ, x ^ i = 1 → 1 ",
      "(G : Type*) [Group G] [Fintypeₓ G] (hG : free G) :  ∀ x : G, x ≠ 1 → ∃ i : ℤ, x ^ i = 1 → 1 ",
      "(G : Type*) [Groupₓₓ G] [Fintypeₓ G] (hG : free G) :  ∀ x : G, x ≠ 1 → ∃ i : ℤ, x ^ i = 1 → 1 ",
      "(G : Type*) [Groupₓ G] [Fintypeₓ G] (hG : free G) :  ∀ x : G, x ≠ 1 → ∃ i : ℤ, x ^ i = 1 → 1 ",
      "(G : Type*) [Group G]  (H : IsSubgroup (Subtype.val '' {f | f ≠ id})) :  ∀ a : G, a ≠ 1 → ∃ (n : ℕ), a ^ n = 1 ",
      "(G : Type*) [Groupₓₓ G]  (H : IsSubgroup (Subtype.val '' {f | f ≠ id})) :  ∀ a : G, a ≠ 1 → ∃ (n : ℕ), a ^ n = 1 ",
      "(G : Type*) [Groupₓ G]  (H : IsSubgroup (Subtype.val '' {f | f ≠ id})) :  ∀ a : G, a ≠ 1 → ∃ (n : ℕ), a ^ n = 1 ",
      "(G : Type*) [Group G] (fg : fg_pair G) :  ∀ {g : G}, g ≠ 1 → ∃ (x : ℕ), g ^ x = 1 → (∀ (x: ℕ), g ^ x ≠ 1) *)  /- 2. Natural language version: \"If n is a positive integer, then there exists a Prime number between n and 2n.\" Write an expression for the negation of this statement (end with a period, not a colon). -/   /- 3. Natural language version: \"If p is a Prime number, then it divides the factorial of any integer m ≥ p.\"",
      "(G : Type*) [Groupₓₓ G] (fg : fg_pair G) :  ∀ {g : G}, g ≠ 1 → ∃ (x : ℕ), g ^ x = 1 → (∀ (x: ℕ), g ^ x ≠ 1) *)  /- 2. Natural language version: \"If n is a positive integer, then there exists a Prime number between n and 2n.\" Write an expression for the negation of this statement (end with a period, not a colon). -/   /- 3. Natural language version: \"If p is a Prime number, then it divides the factorial of any integer m ≥ p.\"",
      "(G : Type*) [Groupₓ G] (fg : fg_pair G) :  ∀ {g : G}, g ≠ 1 → ∃ (x : ℕ), g ^ x = 1 → (∀ (x: ℕ), g ^ x ≠ 1) *)  /- 2. Natural language version: \"If n is a positive integer, then there exists a Prime number between n and 2n.\" Write an expression for the negation of this statement (end with a period, not a colon). -/   /- 3. Natural language version: \"If p is a Prime number, then it divides the factorial of any integer m ≥ p.\"",
      "(G : Type*) [Group G] (IS : Set G) (f : IS → G) (h : ∀ g ∈ G, ∃ i : IS, f i = g)  (h_inj : Function.Injective f) : ∀ g : G, ∀ n : ℕ, g ^ n = 1 → identically g ",
      "(G : Type*) [Groupₓₓ G] (IS : Set G) (f : IS → G) (h : ∀ g ∈ G, ∃ i : IS, f i = g)  (h_inj : Function.Injective f) : ∀ g : G, ∀ n : ℕ, g ^ n = 1 → identically g ",
      "(G : Type*) [Group G] (IS : Setₓ G) (f : IS → G) (h : ∀ g ∈ G, ∃ i : IS, f i = g)  (h_inj : Function.Injective f) : ∀ g : G, ∀ n : ℕ, g ^ n = 1 → identically g ",
      "(G : Type*) [Groupₓₓ G] (IS : Setₓ G) (f : IS → G) (h : ∀ g ∈ G, ∃ i : IS, f i = g)  (h_inj : Function.Injective f) : ∀ g : G, ∀ n : ℕ, g ^ n = 1 → identically g ",
      "(G : Type*) [Groupₓ G] (IS : Set G) (f : IS → G) (h : ∀ g ∈ G, ∃ i : IS, f i = g)  (h_inj : Function.Injective f) : ∀ g : G, ∀ n : ℕ, g ^ n = 1 → identically g ",
      "(G : Type*) [Groupₓ G] (IS : Setₓ G) (f : IS → G) (h : ∀ g ∈ G, ∃ i : IS, f i = g)  (h_inj : Function.Injective f) : ∀ g : G, ∀ n : ℕ, g ^ n = 1 → identically g "
    ],
    "answer": "{α : Type} : Monoidₓ.IsTorsionFree (FreeGroup α) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "free_group_torsion_free",
      "main_prompt": "Every free group is torsion free",
      "prompt": "Natural language version: \"Subgroups of torsion-free groups are torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) :\nmonoid.is_torsion_free ↥H := \n\nNatural language version: \"A nontrivial torsion-free group is not torsion.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] [hN : nontrivial G] :\nmonoid.is_torsion_free G → ¬monoid.is_torsion G := \n\nNatural language version: \"Direct products of torsion free groups are torsion free.\" Translate the natural language version to a Lean mathlib version:\n theorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) :\nmonoid.is_torsion_free (Π (i : η), Gs i) := \n\nNatural language version: \"Direct products of additive torsion free groups are torsion free.\" Translate the natural language version to a Lean mathlib version:\n theorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_group (Gs i)] (tfGs : ∀ (i : η), add_monoid.is_torsion_free (Gs i)) :\nadd_monoid.is_torsion_free (Π (i : η), Gs i) := \n\nNatural language version: \"Every free group is torsion free\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.8580459356307983,
          "doc_string": "Subgroups of torsion-free groups are torsion-free.",
          "statement": "theorem is_torsion_free.subgroup {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) : monoid.is_torsion_free ↥H"
        },
        {
          "sim_score": 0.8004929423332214,
          "doc_string": "A nontrivial torsion-free group is not torsion.",
          "statement": "theorem is_torsion_free.not_torsion {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G → ¬monoid.is_torsion G"
        },
        {
          "sim_score": 0.7987847924232483,
          "doc_string": "Direct products of torsion free groups are torsion free.",
          "statement": "theorem is_torsion_free.prod {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i)"
        },
        {
          "sim_score": 0.7854448556900024,
          "doc_string": "Direct products of additive torsion free groups are torsion free.",
          "statement": "theorem add_monoid.is_torsion_free.prod {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_group (Gs i)] (tfGs : ∀ (i : η), add_monoid.is_torsion_free (Gs i)) : add_monoid.is_torsion_free (Π (i : η), Gs i)"
        }
      ],
      "codex_time": 13.028151459002402,
      "search_time": 1.5132423070026562,
      "use_theorem_name": false
    },
    "outputs": [
      "{G : Type u_1} [Group G] (tG : FreeGroup G) : Monoidₓ.IsTorsionFree G ",
      "{G : Type u_1} [Groupₓₓ G] (tG : FreeGroup G) : Monoidₓ.IsTorsionFree G ",
      "{G : Type u_1} [Groupₓ G] (tG : FreeGroup G) : Monoidₓ.IsTorsionFree G ",
      "{η : Type u_1} {G : Type u_2} [Group G] (H : ∀ (a : η), ∃ (g : G), g ≠ (1 : G)) : Monoidₓ.IsTorsionFree G ",
      "{η : Type u_1} {G : Type u_2} [Groupₓₓ G] (H : ∀ (a : η), ∃ (g : G), g ≠ (1 : G)) : Monoidₓ.IsTorsionFree G ",
      "{η : Type u_1} {G : Type u_2} [Groupₓ G] (H : ∀ (a : η), ∃ (g : G), g ≠ (1 : G)) : Monoidₓ.IsTorsionFree G ",
      "{A : Type u} [Group A] (fA : monoid.is_free A) : Monoidₓ.IsTorsionFree A ",
      "{A : Type u} [Groupₓₓ A] (fA : monoid.is_free A) : Monoidₓ.IsTorsionFree A ",
      "{A : Type u} [Groupₓ A] (fA : monoid.is_free A) : Monoidₓ.IsTorsionFree A ",
      "{α : Type u_1} [c : Fintype α] (Gs : α → Type u_2) (hgs : ∀ (i : α) (f : Gs i), ∃ g : Gs i, g ≠ f) (hs : ∀ {i j : α}, i ≠ j → ∃ k : Gs i → Gs j, ∀ (l : Gs i), k l ≠ l) (Hs : ∀ i : α, Group (Gs i)) : Monoidₓ.IsTorsionFree (FreeGroup α Gs) ",
      "{α : Type u_1} [c : Fintype α] (Gs : α → Type u_2) (hgs : ∀ (i : α) (f : Gs i), ∃ g : Gs i, g ≠ f) (hs : ∀ {i j : α}, i ≠ j → ∃ k : Gs i → Gs j, ∀ (l : Gs i), k l ≠ l) (Hs : ∀ i : α, Groupₓₓ (Gs i)) : Monoidₓ.IsTorsionFree (FreeGroup α Gs) ",
      "{α : Type u_1} [c : Fintype α] (Gs : α → Type u_2) (hgs : ∀ (i : α) (f : Gs i), ∃ g : Gs i, g ≠ f) (hs : ∀ {i j : α}, i ≠ j → ∃ k : Gs i → Gs j, ∀ (l : Gs i), k l ≠ l) (Hs : ∀ i : α, Groupₓ (Gs i)) : Monoidₓ.IsTorsionFree (FreeGroup α Gs) ",
      "{α : Type u_1} [c : Fintypeₓ α] (Gs : α → Type u_2) (hgs : ∀ (i : α) (f : Gs i), ∃ g : Gs i, g ≠ f) (hs : ∀ {i j : α}, i ≠ j → ∃ k : Gs i → Gs j, ∀ (l : Gs i), k l ≠ l) (Hs : ∀ i : α, Group (Gs i)) : Monoidₓ.IsTorsionFree (FreeGroup α Gs) ",
      "{α : Type u_1} [c : Fintypeₓ α] (Gs : α → Type u_2) (hgs : ∀ (i : α) (f : Gs i), ∃ g : Gs i, g ≠ f) (hs : ∀ {i j : α}, i ≠ j → ∃ k : Gs i → Gs j, ∀ (l : Gs i), k l ≠ l) (Hs : ∀ i : α, Groupₓₓ (Gs i)) : Monoidₓ.IsTorsionFree (FreeGroup α Gs) ",
      "{α : Type u_1} [c : Fintypeₓ α] (Gs : α → Type u_2) (hgs : ∀ (i : α) (f : Gs i), ∃ g : Gs i, g ≠ f) (hs : ∀ {i j : α}, i ≠ j → ∃ k : Gs i → Gs j, ∀ (l : Gs i), k l ≠ l) (Hs : ∀ i : α, Groupₓ (Gs i)) : Monoidₓ.IsTorsionFree (FreeGroup α Gs) ",
      "{G : Type u_1} {s : Type u_2} [Group G] (is_free : IsFreeGroup s G) : Monoidₓ.IsTorsionFree G ",
      "{G : Type u_1} {s : Type u_2} [Groupₓₓ G] (is_free : IsFreeGroup s G) : Monoidₓ.IsTorsionFree G ",
      "{G : Type u_1} {s : Type u_2} [Groupₓ G] (is_free : IsFreeGroup s G) : Monoidₓ.IsTorsionFree G "
    ],
    "answer": "{α : Type} : Monoidₓ.IsTorsionFree (FreeGroup α) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "free_group_torsion_free",
      "main_prompt": "Every free group is torsion free",
      "prompt": "Natural language version: \"Every free group is torsion free\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 9.230117765982868,
      "use_theorem_name": false
    },
    "outputs": [
      "free_is_torsion_free (G : Group) (H : free G) : torsion_free G ",
      "free_is_torsion_free (G : Groupₓₓ) (H : free G) : torsion_free G ",
      "free_is_torsion_free (G : Groupₓ) (H : free G) : torsion_free G ",
      "free_group_implies_torsion_free_group : ∀ G : Type, FreeGroup G → torsion_free_group G ",
      "Every_free_group_is_torsion_free : ∀ (G : Type(u)), is_group G                                         → IsFreeGroup G                                         → is_torsion_free_group G  -- 2.  Define and typecheck the statement.  IsOpen FreeGroup  IsOpen free_group.quotient  IsOpen category_theory  IsOpen category_theory.group  theorem Every_free_group_is_torsion_free : ∀ (G : Type(u)), is_group G                                         → IsFreeGroup G                                         → is_torsion_free_group G  ",
      "every_free_group_is_torsion_free : ∀ F : Type v → Sort *, IsFreeGroup F → is_torsion_free F ",
      "Q3a (F : Type*) [FreeGroup F] : torsion_free F "
    ],
    "answer": "{α : Type} : Monoidₓ.IsTorsionFree (FreeGroup α) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "integer_subgroups",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every non-empty subgroup of `ℤ` is isomorphic to `ℤ`\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every non-empty subgroup of `ℤ` is isomorphic to `ℤ`",
      "codex_time": 4.99290766500053,
      "use_theorem_name": false
    },
    "outputs": [
      "(G : Type*) [Group G] (n : ℕ) (hG : G ≠ ∅) :  ∃ (f : group_hom ℤ G), f 1 ≠ 1 ",
      "(G : Type*) [Groupₓₓ G] (n : ℕ) (hG : G ≠ ∅) :  ∃ (f : group_hom ℤ G), f 1 ≠ 1 ",
      "(G : Type*) [Groupₓ G] (n : ℕ) (hG : G ≠ ∅) :  ∃ (f : group_hom ℤ G), f 1 ≠ 1 ",
      "(A : Type*) [Group A] [DecidableEq A] (H : Set A) (h_H : (1 : A) ∈ H)  (h_H_nonempty : H ≠ ∅) :  Σ (i : ℤ → A), Function.bijective i ",
      "(A : Type*) [Groupₓₓ A] [DecidableEq A] (H : Set A) (h_H : (1 : A) ∈ H)  (h_H_nonempty : H ≠ ∅) :  Σ (i : ℤ → A), Function.bijective i ",
      "(A : Type*) [Group A] [DecidableEq A] (H : Setₓ A) (h_H : (1 : A) ∈ H)  (h_H_nonempty : H ≠ ∅) :  Σ (i : ℤ → A), Function.bijective i ",
      "(A : Type*) [Groupₓₓ A] [DecidableEq A] (H : Setₓ A) (h_H : (1 : A) ∈ H)  (h_H_nonempty : H ≠ ∅) :  Σ (i : ℤ → A), Function.bijective i ",
      "(A : Type*) [Groupₓ A] [DecidableEq A] (H : Set A) (h_H : (1 : A) ∈ H)  (h_H_nonempty : H ≠ ∅) :  Σ (i : ℤ → A), Function.bijective i ",
      "(A : Type*) [Groupₓ A] [DecidableEq A] (H : Setₓ A) (h_H : (1 : A) ∈ H)  (h_H_nonempty : H ≠ ∅) :  Σ (i : ℤ → A), Function.bijective i ",
      "(G : Type*) [Group G] [Fintype G]  (H : Type*) [Group H] [Fintype H] (f : G → H)  (hf : Function.bijective f) (hfg : ∀ a b ∈ f '' G, a * b ∈ f '' G) :  H ≃ ℤ ",
      "(G : Type*) [Groupₓₓ G] [Fintype G]  (H : Type*) [Groupₓₓ H] [Fintype H] (f : G → H)  (hf : Function.bijective f) (hfg : ∀ a b ∈ f '' G, a * b ∈ f '' G) :  H ≃ ℤ ",
      "(G : Type*) [Groupₓ G] [Fintype G]  (H : Type*) [Groupₓ H] [Fintype H] (f : G → H)  (hf : Function.bijective f) (hfg : ∀ a b ∈ f '' G, a * b ∈ f '' G) :  H ≃ ℤ ",
      "(G : Type*) [Group G] [Fintypeₓ G]  (H : Type*) [Group H] [Fintypeₓ H] (f : G → H)  (hf : Function.bijective f) (hfg : ∀ a b ∈ f '' G, a * b ∈ f '' G) :  H ≃ ℤ ",
      "(G : Type*) [Groupₓₓ G] [Fintypeₓ G]  (H : Type*) [Groupₓₓ H] [Fintypeₓ H] (f : G → H)  (hf : Function.bijective f) (hfg : ∀ a b ∈ f '' G, a * b ∈ f '' G) :  H ≃ ℤ ",
      "(G : Type*) [Groupₓ G] [Fintypeₓ G]  (H : Type*) [Groupₓ H] [Fintypeₓ H] (f : G → H)  (hf : Function.bijective f) (hfg : ∀ a b ∈ f '' G, a * b ∈ f '' G) :  H ≃ ℤ ",
      "(G : Type*) [Group G] (H : Subgroup G)  (hG : G ≠ ∅) : (ℤ : Type*) ≃* G  (g : G) (hg : g ≠ 1) : ∃ m : ℤ, g ^ m = 1 ",
      "(G : Type*) [Groupₓₓ G] (H : Subgroup G)  (hG : G ≠ ∅) : (ℤ : Type*) ≃* G  (g : G) (hg : g ≠ 1) : ∃ m : ℤ, g ^ m = 1 ",
      "(G : Type*) [Groupₓ G] (H : Subgroup G)  (hG : G ≠ ∅) : (ℤ : Type*) ≃* G  (g : G) (hg : g ≠ 1) : ∃ m : ℤ, g ^ m = 1 ",
      "(G : Type*) [Group G] (H ⊆ G) (h_H : H ≠ ∅) :  G ≃ ℤ ",
      "(G : Type*) [Groupₓₓ G] (H ⊆ G) (h_H : H ≠ ∅) :  G ≃ ℤ ",
      "(G : Type*) [Groupₓ G] (H ⊆ G) (h_H : H ≠ ∅) :  G ≃ ℤ "
    ],
    "answer": "(H : AddSubgroup ℤ) : H.Carrier.Nonempty  →   ↥H ≃+ ℤ "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "integer_subgroups",
      "main_prompt": "Every non-empty subgroup of `ℤ` is isomorphic to `ℤ`",
      "prompt": "Natural language version: \"Every subgroup of `ℤ` is cyclic.\" Translate the natural language version to a Lean mathlib version:\n theorem (H : add_subgroup ℤ) :\n∃ (a : ℤ), H = add_subgroup.closure {a} := \n\nNatural language version: \"If the quotient by a subgroup gives a singleton then the subgroup is the whole group.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u} [group G] (H : subgroup G) (h : subsingleton (G ⧸ H)) :\nH = ⊤ := \n\nNatural language version: \"The subgroup generated by a set includes the set.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] {k : set G} :\nk ⊆ ↑(subgroup.closure k) := \n\nNatural language version: \"Two subgroups are equal if they have the same elements.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] {H K : subgroup G} (h : ∀ (x : G), x ∈ H ↔ x ∈ K) :\nH = K := \n\nNatural language version: \"Every non-empty subgroup of `ℤ` is isomorphic to `ℤ`\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.710217297077179,
          "doc_string": "Every subgroup of `ℤ` is cyclic.",
          "statement": "theorem int.subgroup_cyclic (H : add_subgroup ℤ) : ∃ (a : ℤ), H = add_subgroup.closure {a}"
        },
        {
          "sim_score": 0.5739960670471191,
          "doc_string": "If the quotient by a subgroup gives a singleton then the subgroup is the whole group.",
          "statement": "theorem quotient_group.subgroup_eq_top_of_subsingleton {G : Type u} [group G] (H : subgroup G) (h : subsingleton (G ⧸ H)) : H = ⊤"
        },
        {
          "sim_score": 0.5350345969200134,
          "doc_string": "The subgroup generated by a set includes the set.",
          "statement": "theorem subgroup.subset_closure {G : Type u_1} [group G] {k : set G} : k ⊆ ↑(subgroup.closure k)"
        },
        {
          "sim_score": 0.5225922465324402,
          "doc_string": "Two subgroups are equal if they have the same elements.",
          "statement": "theorem subgroup.ext {G : Type u_1} [group G] {H K : subgroup G} (h : ∀ (x : G), x ∈ H ↔ x ∈ K) : H = K"
        }
      ],
      "codex_time": 8.135182752012042,
      "search_time": 1.4847017290012445,
      "use_theorem_name": false
    },
    "outputs": [
      "{G : Type u_1} [Group G] {H : Subgroup G} (h : (∃ (x : G), x ∉ H) → H ≃ₐ[r] ℤ) :   *)   end fin_mul_action",
      "{G : Type u_1} [Groupₓₓ G] {H : Subgroup G} (h : (∃ (x : G), x ∉ H) → H ≃ₐ[r] ℤ) :   *)   end fin_mul_action",
      "{G : Type u_1} [Groupₓ G] {H : Subgroup G} (h : (∃ (x : G), x ∉ H) → H ≃ₐ[r] ℤ) :   *)   end fin_mul_action",
      "{H : Subgroup ℤ} : H ≠ ⊥ → group_isomorphism ℤ H ",
      "{H : Type u_1} [Group H] (h : 0 ∈ H) : @group_equiv ℤ _ _ H ",
      "{H : Type u_1} [Groupₓₓ H] (h : 0 ∈ H) : @group_equiv ℤ _ _ H ",
      "{H : Type u_1} [Groupₓ H] (h : 0 ∈ H) : @group_equiv ℤ _ _ H ",
      "(G : ∃ (e : ℤ), e ∈ G ∧ ∀ (a : ℤ), a ∈ G → a + -[1+ a] ∈ G) :  ∃ (f : ℤ → G), IsGroupHom f ",
      "{G : Type u} [Group G] (H : Nonempty (Subgroup G)) : @group.equiv.{u u} G G ",
      "{G : Type u} [Groupₓₓ G] (H : Nonempty (Subgroup G)) : @group.equiv.{u u} G G ",
      "{G : Type u} [Groupₓ G] (H : Nonempty (Subgroup G)) : @group.equiv.{u u} G G "
    ],
    "answer": "(H : AddSubgroup ℤ) : H.Carrier.Nonempty  →   ↥H ≃+ ℤ "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "integer_subgroups",
      "main_prompt": "Every non-empty subgroup of `ℤ` is isomorphic to `ℤ`",
      "prompt": "Natural language version: \"Every non-empty subgroup of `ℤ` is isomorphic to `ℤ`\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 7.047498227009783,
      "use_theorem_name": false
    },
    "outputs": [
      "Nat . lemma_6 : forall n : ℕ , n > 0 → n > 0 ∧ n > 0 ",
      "(H : Subgroup G) (h : ∅ ≠ G) : G ≅ₙ[Int] Z ",
      "z_subgroup_is_integers (G : Set ℤ) (H : G ≠ ∅) : IsSubgroup G → G ≅ ℤ ",
      "z_subgroup_is_integers (G : Setₓ ℤ) (H : G ≠ ∅) : IsSubgroup G → G ≅ ℤ ",
      "nat_subg_of_subg {G : Type*} [Group G] [IsSubgroup G] (S : Set G)    (H_nonempty : ∃ g : G, g ∈ S) : H ",
      "nat_subg_of_subg {G : Type*} [Groupₓₓ G] [IsSubgroup G] (S : Set G)    (H_nonempty : ∃ g : G, g ∈ S) : H ",
      "nat_subg_of_subg {G : Type*} [Group G] [IsSubgroup G] (S : Setₓ G)    (H_nonempty : ∃ g : G, g ∈ S) : H ",
      "nat_subg_of_subg {G : Type*} [Groupₓₓ G] [IsSubgroup G] (S : Setₓ G)    (H_nonempty : ∃ g : G, g ∈ S) : H ",
      "nat_subg_of_subg {G : Type*} [Groupₓ G] [IsSubgroup G] (S : Set G)    (H_nonempty : ∃ g : G, g ∈ S) : H ",
      "nat_subg_of_subg {G : Type*} [Groupₓ G] [IsSubgroup G] (S : Setₓ G)    (H_nonempty : ∃ g : G, g ∈ S) : H ",
      "every_nonempty_subgroup_of_Z_is_isomorphic_to_Z [ CommGroup α ] [ Additive α ] { s : Set α } ( hs : s ≠ ∅ ) :    ∃ f : group_hom ( Subgroup.closure α s ) ℤ, ∃ g : group_hom ℤ ( Subgroup.closure α s ), f.ker = ⊥ ∧ g.ker = ⊥ ",
      "every_nonempty_subgroup_of_Z_is_isomorphic_to_Z [ CommGroupₓₓ α ] [ Additive α ] { s : Set α } ( hs : s ≠ ∅ ) :    ∃ f : group_hom ( Subgroup.closure α s ) ℤ, ∃ g : group_hom ℤ ( Subgroup.closure α s ), f.ker = ⊥ ∧ g.ker = ⊥ ",
      "every_nonempty_subgroup_of_Z_is_isomorphic_to_Z [ CommGroup α ] [ Additive α ] { s : Setₓ α } ( hs : s ≠ ∅ ) :    ∃ f : group_hom ( Subgroup.closure α s ) ℤ, ∃ g : group_hom ℤ ( Subgroup.closure α s ), f.ker = ⊥ ∧ g.ker = ⊥ ",
      "every_nonempty_subgroup_of_Z_is_isomorphic_to_Z [ CommGroupₓₓ α ] [ Additive α ] { s : Setₓ α } ( hs : s ≠ ∅ ) :    ∃ f : group_hom ( Subgroup.closure α s ) ℤ, ∃ g : group_hom ℤ ( Subgroup.closure α s ), f.ker = ⊥ ∧ g.ker = ⊥ ",
      "every_nonempty_subgroup_of_Z_is_isomorphic_to_Z [ CommGroupₓ α ] [ Additive α ] { s : Set α } ( hs : s ≠ ∅ ) :    ∃ f : group_hom ( Subgroup.closure α s ) ℤ, ∃ g : group_hom ℤ ( Subgroup.closure α s ), f.ker = ⊥ ∧ g.ker = ⊥ ",
      "every_nonempty_subgroup_of_Z_is_isomorphic_to_Z [ CommGroupₓ α ] [ Additive α ] { s : Setₓ α } ( hs : s ≠ ∅ ) :    ∃ f : group_hom ( Subgroup.closure α s ) ℤ, ∃ g : group_hom ℤ ( Subgroup.closure α s ), f.ker = ⊥ ∧ g.ker = ⊥ "
    ],
    "answer": "(H : AddSubgroup ℤ) : H.Carrier.Nonempty  →   ↥H ≃+ ℤ "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "int_poly_rat_zeros_int",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"If the coefficients of a polynomial over rationals are integral, every rational root is integral.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If the coefficients of a polynomial over rationals are integral, every rational root is integral.",
      "codex_time": 11.183689049998065,
      "use_theorem_name": false
    },
    "outputs": [
      "(n : ℕ) (f : Polynomial ℚ)  (hf : polynomial.all_coeff_integral f) :  ∀ r, Polynomial.eval f r ∈ (0 : ℚ) ↔    ∃ s:ℤ,  (r.num, r.denom) = s ∧    ∃ i, (coeff f i).num = 0 ∧ (coeff f i).denom * s = 1 ",
      "(n : ℕ) (hn : n > 0) (p : Polynomial ℚ)  (hp : ∀ i : Fin n, (coeff p i).denom = 1) :  ∀ r, r.is_root p → r.num = (0 : ℚ) ∨ ∃ d : ℕ, d > 0 ∧ r.num = d ∧ r.denom = 1 ",
      "(n : ℕ) (hn : n > 0) (p : Polynomial ℚ)  (hp : ∀ i : Finₓ n, (coeff p i).denom = 1) :  ∀ r, r.is_root p → r.num = (0 : ℚ) ∨ ∃ d : ℕ, d > 0 ∧ r.num = d ∧ r.denom = 1 ",
      "(n : ℕ) (f : Polynomial ℚ)  (hf : ∀ (α : ℚ), f.eval α = 0 → ∃ m : ℕ, f.coeff m % 1 = 0) :  ∀ (m : ℤ), m ≠ 0 → f.eval m = 0 → ∃ n : ℕ, f.coeff n % 1 = 0 ",
      "(p : Polynomial ℚ) (hp : is_integral_polynomial p) (hrat : is_rat_root p) : ¬ hrat.is_irreducible",
      "(X : Type*) [integral_domain X]  (R : Polynomial.x) (H : ∀ i, coeff R i ∈ (Set.Range : ℤ → X)) :  ∀ r ∈ roots R, r : ℤ ",
      "(X : Type*) [integral_domain X]  (R : Polynomial.x) (H : ∀ i, coeff R i ∈ (Setₓ.Range : ℤ → X)) :  ∀ r ∈ roots R, r : ℤ "
    ],
    "answer": "int_poly_rat_zeros_int (p: Polynomial ℚ) : ∀ n: ℕ, IsIntegral ℚ (p.coeff n) →  ∀ x: ℚ, p.IsRoot x →  IsIntegral ℚ x "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "int_poly_rat_zeros_int",
      "main_prompt": "If the coefficients of a polynomial over rationals are integral, every rational root is integral.",
      "prompt": "Natural language version: \" Rational root theorem part 1: if `r : f.codomain` is a root of a polynomial over the ufd `A`, then the numerator of `r` divides the constant coefficient\" Translate the natural language version to a Lean mathlib version:\n theorem {A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} {r : K} (hr : ⇑(polynomial.aeval r) p = 0) :\nis_fraction_ring.num A r ∣ p.coeff 0 := \n\nNatural language version: \" Integral root theorem: if `r : f.codomain` is a root of a monic polynomial over the ufd `A`, then `r` is an integer\" Translate the natural language version to a Lean mathlib version:\n theorem {A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} (hp : p.monic) {r : K} (hr : ⇑(polynomial.aeval r) p = 0) :\nis_localization.is_integer A r := \n\nNatural language version: \" Rational root theorem part 2: if `r : f.codomain` is a root of a polynomial over the ufd `A`, then the denominator of `r` divides the leading coefficient\" Translate the natural language version to a Lean mathlib version:\n theorem {A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} {r : K} (hr : ⇑(polynomial.aeval r) p = 0) :\n↑(is_fraction_ring.denom A r) ∣ p.leading_coeff := \n\nNatural language version: \"This lemma is useful for working with the `int_degree` of a rational function.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [semiring R] [no_zero_divisors R] {p₁ p₂ q₁ q₂ : polynomial R} (hp₁ : p₁ ≠ 0) (hq₁ : q₁ ≠ 0) (hp₂ : p₂ ≠ 0) (hq₂ : q₂ ≠ 0) (h_eq : p₁ * q₂ = p₂ * q₁) :\n↑(p₁.nat_degree) - ↑(q₁.nat_degree) = ↑(p₂.nat_degree) - ↑(q₂.nat_degree) := \n\nNatural language version: \"If the coefficients of a polynomial over rationals are integral, every rational root is integral.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6362022161483765,
          "doc_string": " Rational root theorem part 1: if `r : f.codomain` is a root of a polynomial over the ufd `A`, then the numerator of `r` divides the constant coefficient",
          "statement": "theorem num_dvd_of_is_root {A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} {r : K} (hr : ⇑(polynomial.aeval r) p = 0) : is_fraction_ring.num A r ∣ p.coeff 0"
        },
        {
          "sim_score": 0.6275410652160645,
          "doc_string": " Integral root theorem: if `r : f.codomain` is a root of a monic polynomial over the ufd `A`, then `r` is an integer",
          "statement": "theorem is_integer_of_is_root_of_monic {A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} (hp : p.monic) {r : K} (hr : ⇑(polynomial.aeval r) p = 0) : is_localization.is_integer A r"
        },
        {
          "sim_score": 0.6202014684677124,
          "doc_string": " Rational root theorem part 2: if `r : f.codomain` is a root of a polynomial over the ufd `A`, then the denominator of `r` divides the leading coefficient",
          "statement": "theorem denom_dvd_of_is_root {A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} {r : K} (hr : ⇑(polynomial.aeval r) p = 0) : ↑(is_fraction_ring.denom A r) ∣ p.leading_coeff"
        },
        {
          "sim_score": 0.5798273086547852,
          "doc_string": "This lemma is useful for working with the `int_degree` of a rational function.",
          "statement": "theorem polynomial.nat_degree_sub_eq_of_prod_eq {R : Type u} [semiring R] [no_zero_divisors R] {p₁ p₂ q₁ q₂ : polynomial R} (hp₁ : p₁ ≠ 0) (hq₁ : q₁ ≠ 0) (hp₂ : p₂ ≠ 0) (hq₂ : q₂ ≠ 0) (h_eq : p₁ * q₂ = p₂ * q₁) : ↑(p₁.nat_degree) - ↑(q₁.nat_degree) = ↑(p₂.nat_degree) - ↑(q₂.nat_degree)"
        }
      ],
      "codex_time": 10.011051232984755,
      "search_time": 1.4644726150145289,
      "use_theorem_name": false
    },
    "outputs": [
      "{R : Type u} [CommRing R] [Algebra ℚ R] [IsFractionRing R ℚ] (p : Polynomial R) (h : p.leading_coeff ∈ ℤ) (r : R) (h_monic : p.monic) (h_root : r ∣ p.leading_coeff ∧ p.eval r = 0) : r ∈ ℤ ",
      "{R : Type u} [CommRingₓₓ R] [Algebra ℚ R] [IsFractionRing R ℚ] (p : Polynomial R) (h : p.leading_coeff ∈ ℤ) (r : R) (h_monic : p.monic) (h_root : r ∣ p.leading_coeff ∧ p.eval r = 0) : r ∈ ℤ ",
      "{R : Type u} [CommRingₓ R] [Algebra ℚ R] [IsFractionRing R ℚ] (p : Polynomial R) (h : p.leading_coeff ∈ ℤ) (r : R) (h_monic : p.monic) (h_root : r ∣ p.leading_coeff ∧ p.eval r = 0) : r ∈ ℤ ",
      "{p : Polynomial ℚ} (hp : ∀c : ℤ, c ∈ p.coeffs → ∃x : ℕ, ↑x ∣ c) {r : ℚ} (hr : p.eval r = 0) : IsLocalization.IsInteger ℤ r ",
      "{R : Type u} [Semiring R] [NoZeroDivisors R] [IsField R] [Algebra ℤ R] {p : Polynomial R} (h : ∀ (i : Polynomial R), i ∈ p.support → IsLocalization.IsInteger ℤ (polynomial.coeff p i)) {r : R} (h_root : p.eval r = 0) : IsLocalization.IsInteger ℤ r ",
      "{R : Type u} [Semiringₓ R] [NoZeroDivisors R] [IsField R] [Algebra ℤ R] {p : Polynomial R} (h : ∀ (i : Polynomial R), i ∈ p.support → IsLocalization.IsInteger ℤ (polynomial.coeff p i)) {r : R} (h_root : p.eval r = 0) : IsLocalization.IsInteger ℤ r ",
      "{α : Type u} [CommRing α] [DecidableEq α] [Fintype α] {p : Polynomial α} (hp : ∀ b ∈ p.coeffs, IsLocalization.IsInteger ℚ b) {r : α} (hr : p.eval r = 0) (hp' : IsLocalization.IsInteger ℚ r) : IsLocalization.IsInteger ℚ r ",
      "{α : Type u} [CommRingₓₓ α] [DecidableEq α] [Fintype α] {p : Polynomial α} (hp : ∀ b ∈ p.coeffs, IsLocalization.IsInteger ℚ b) {r : α} (hr : p.eval r = 0) (hp' : IsLocalization.IsInteger ℚ r) : IsLocalization.IsInteger ℚ r ",
      "{α : Type u} [CommRingₓ α] [DecidableEq α] [Fintype α] {p : Polynomial α} (hp : ∀ b ∈ p.coeffs, IsLocalization.IsInteger ℚ b) {r : α} (hr : p.eval r = 0) (hp' : IsLocalization.IsInteger ℚ r) : IsLocalization.IsInteger ℚ r ",
      "{α : Type u} [CommRing α] [DecidableEq α] [Fintypeₓ α] {p : Polynomial α} (hp : ∀ b ∈ p.coeffs, IsLocalization.IsInteger ℚ b) {r : α} (hr : p.eval r = 0) (hp' : IsLocalization.IsInteger ℚ r) : IsLocalization.IsInteger ℚ r ",
      "{α : Type u} [CommRingₓₓ α] [DecidableEq α] [Fintypeₓ α] {p : Polynomial α} (hp : ∀ b ∈ p.coeffs, IsLocalization.IsInteger ℚ b) {r : α} (hr : p.eval r = 0) (hp' : IsLocalization.IsInteger ℚ r) : IsLocalization.IsInteger ℚ r ",
      "{α : Type u} [CommRingₓ α] [DecidableEq α] [Fintypeₓ α] {p : Polynomial α} (hp : ∀ b ∈ p.coeffs, IsLocalization.IsInteger ℚ b) {r : α} (hr : p.eval r = 0) (hp' : IsLocalization.IsInteger ℚ r) : IsLocalization.IsInteger ℚ r ",
      "{R : Type u} [CommRing R] [IsDomain R] [UniqueFactorizationMonoid R] [Field ℚ] [Algebra R ℚ] [IsFractionRing R ℚ] {p : Polynomial R} (h : (∀ i, IsLocalization.IsInteger R i)): (∀ r : ℚ, Polynomial.aeval r p = 0 → IsLocalization.IsInteger R r) ",
      "{R : Type u} [CommRingₓₓ R] [IsDomain R] [UniqueFactorizationMonoid R] [Field ℚ] [Algebra R ℚ] [IsFractionRing R ℚ] {p : Polynomial R} (h : (∀ i, IsLocalization.IsInteger R i)): (∀ r : ℚ, Polynomial.aeval r p = 0 → IsLocalization.IsInteger R r) ",
      "{R : Type u} [CommRingₓ R] [IsDomain R] [UniqueFactorizationMonoid R] [Field ℚ] [Algebra R ℚ] [IsFractionRing R ℚ] {p : Polynomial R} (h : (∀ i, IsLocalization.IsInteger R i)): (∀ r : ℚ, Polynomial.aeval r p = 0 → IsLocalization.IsInteger R r) "
    ],
    "answer": "int_poly_rat_zeros_int (p: Polynomial ℚ) : ∀ n: ℕ, IsIntegral ℚ (p.coeff n) →  ∀ x: ℚ, p.IsRoot x →  IsIntegral ℚ x "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "int_poly_rat_zeros_int",
      "main_prompt": "If the coefficients of a polynomial over rationals are integral, every rational root is integral.",
      "prompt": "Natural language version: \"If the coefficients of a polynomial over rationals are integral, every rational root is integral.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 8.808232160983607,
      "use_theorem_name": false
    },
    "outputs": [
      "no_rational_nonintegral_roots_of_integral_polynomial {R : Type} [interger_coefficients_field R] (p : Polynomial R) : True ",
      "rat_poly_roots_integral {α : Type*} [Field α] (p : Polynomial α) [Fact (0 : α) ≠ 1]   (inst : is_integral_polynomial p) (r : α) : is_integral_polynomial r → is_integral_polynomial (p.eval r) ",
      "rat_to_int_is_int' : ∀ p : Polynomial ℚ, p.coeffs ∈ Submodule.map (ℤ →+* ℚ) ℤ    → polynomial.roots (Polynomial.map int.cast p) = Subtype.val '' (polynomial.roots p) ",
      "nat.eq_zero_of_mul_eq_zero_right {α : Type*} [LinearOrderedRing α] (m n : α) (h : m * n = 0) : n = 0 | 0 ",
      "nat_degree_thm {x : ℝ} (h : polynomial.coeff (Polynomial.degree p) p ∈ ℤ)     (h_lt : Polynomial.eval x p = 0) : x ∈ ℤ "
    ],
    "answer": "int_poly_rat_zeros_int (p: Polynomial ℚ) : ∀ n: ℕ, IsIntegral ℚ (p.coeff n) →  ∀ x: ℚ, p.IsRoot x →  IsIntegral ℚ x "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "has_prime_factor",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every natural number greater than `1` is divisible by a prime number.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every natural number greater than `1` is divisible by a prime number.",
      "codex_time": 5.600416540022707,
      "use_theorem_name": false
    },
    "outputs": [
      "(n : ℕ) (h : 1 < n) : ∃ p : ℕ, p.prime ∧ p ∣ n ",
      "(n : ℕ) (hn : 1 < n) :  ∃ p : ℕ, p ∈ prime_factors n ∧ p.prime ",
      "(n : ℕ) (hn : n > 1) : ∃ p, p.prime ∧ ∃ k : ℕ, nat.prime_divisor p ∣ n ",
      "(n : ℕ) (h : n > 1) : ∃ p, Prime p ∧ ∃ k, n = p * k ",
      "(n : ℕ) (h : n > 1) : ∃ p : ℕ, Nat.Prime p ∧ p ∣ n "
    ],
    "answer": "(n: ℕ) : n > 1 → ∃ p: ℕ, Prime p ∧ (∃ d: ℕ, p * d = n) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "has_prime_factor",
      "main_prompt": "Every natural number greater than `1` is divisible by a prime number.",
      "prompt": "Natural language version: \" If a small natural number is divisible by a larger natural number, the small number is zero.\" Translate the natural language version to a Lean mathlib version:\n theorem {a b : ℕ} (w : a ∣ b) (h : b < a) :\nb = 0 := \n\nNatural language version: \"Every nonzero natural number has a unique prime factorization\" Translate the natural language version to a Lean mathlib version:\n theorem  :\nset.inj_on nat.factorization {x : ℕ | x ≠ 0} := \n\nNatural language version: \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.\" Translate the natural language version to a Lean mathlib version:\n theorem {p : ℕ} [fact (nat.prime p)] :\np % 2 = 1 ↔ p ≠ 2 := \n\nNatural language version: \"The only prime factor of prime `p` is `p` itself, with multiplicity `1`\" Translate the natural language version to a Lean mathlib version:\n theorem {p : ℕ} (hp : nat.prime p) :\np.factorization = finsupp.single p 1 := \n\nNatural language version: \"Every natural number greater than `1` is divisible by a prime number.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6529487371444702,
          "doc_string": " If a small natural number is divisible by a larger natural number, the small number is zero.",
          "statement": "theorem nat.eq_zero_of_dvd_of_lt {a b : ℕ} (w : a ∣ b) (h : b < a) : b = 0"
        },
        {
          "sim_score": 0.593155562877655,
          "doc_string": "Every nonzero natural number has a unique prime factorization",
          "statement": "theorem nat.factorization_inj  : set.inj_on nat.factorization {x : ℕ | x ≠ 0}"
        },
        {
          "sim_score": 0.5878391265869141,
          "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.",
          "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2"
        },
        {
          "sim_score": 0.5869839191436768,
          "doc_string": "The only prime factor of prime `p` is `p` itself, with multiplicity `1`",
          "statement": "theorem nat.prime.factorization {p : ℕ} (hp : nat.prime p) : p.factorization = finsupp.single p 1"
        }
      ],
      "codex_time": 4.207383264991222,
      "search_time": 1.454934626002796,
      "use_theorem_name": false
    },
    "outputs": [
      "{n : ℕ} (h : n > 1) : ∃ p, Nat.Prime p ∧ p ∣ n ",
      "{a : ℕ} (ha : 2 ≤ a) :  ∃ p, p.prime ∧ ↑p ∣ a ",
      ": ∀ {n : ℕ} (hn : 1 < n), ∃ (p : ℕ) (hp : Nat.Prime p), p ∣ n ",
      "{n : ℕ} (hn : n > 1) : ∃ p : ℕ, Nat.Prime p ∧ p ∣ n ",
      "{n : ℕ} (h : 2 ≤ n ==> ∃ p ∈ primes, p ∣ n) "
    ],
    "answer": "(n: ℕ) : n > 1 → ∃ p: ℕ, Prime p ∧ (∃ d: ℕ, p * d = n) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "has_prime_factor",
      "main_prompt": "Every natural number greater than `1` is divisible by a prime number.",
      "prompt": "Natural language version: \"Every natural number greater than `1` is divisible by a prime number.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 9.944287020014599,
      "use_theorem_name": false
    },
    "outputs": [
      "greater than 1 are Prime : ∀ n : ℕ, n > 1 → ∃ p : ℕ, p.prime ∧ nat.prime_factors n = [p]  def greater than 1 are Prime : ∀ n : ℕ, n > 1 → ∃ p : ℕ, p.prime ∧ nat.prime_factors n = [p] ",
      "greater_than_one_divisible_by_prime :   ∀ n : ℕ, 1 < n → ∃ p : ℕ, Prime p ∧ p ∣ n ",
      "nat.nat.prime_gt_1_of_dvd {n : ℕ} (h : n > 1) (Dvd : n ∣ k) : ∃ p : ℕ, Prime p ∧ p ∣ k ",
      "my_thm : ∀ m : ℕ , 1 < m → ∃ p : ℕ , p . Prime ∧ p ∣ m ",
      "p_every (n : ℕ) (h : n > 1) : ∃ p : ℕ, Nat.Prime p ∧ p ∣ n "
    ],
    "answer": "(n: ℕ) : n > 1 → ∃ p: ℕ, Prime p ∧ (∃ d: ℕ, p * d = n) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "six_not_prime_sum",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Six is not the sum of two prime numbers.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Six is not the sum of two prime numbers.",
      "codex_time": 12.342966515017906,
      "use_theorem_name": false
    },
    "outputs": [
      "(p q : ℕ) [DecidableEq ℕ] (hp : Prime p) (hq : Prime q)  (h : p + q = 6) : False ",
      "(h : ∃ p q : ℕ, p ≥ 2 ∧ q ≥ 2 ∧ Prime p ∧ Prime q ∧ 6 = p + q) :  False ",
      "(n : ℕ) (pr1 : Prime (finset.sum {a, b}))  (pr2 : Prime (finset.sum {a, b}))  (h : finset.sum {a, b} = 6) :  False ",
      ":  ¬ ∃ p1 p2 : ℕ, Prime p1 ∧ Prime p2 ∧ p1 + p2 = 6  Natural language version: \"Let ℝ^n have the usual topology. Let n ≥ 1. Let x ∈ ℝ ^ n, let ε > 0; there is a δ > 0 such that δℝ^n(x) ⊆ (ε)ℝ^n(x). (Hint: what happens when x = 0?)\" Translate the natural language version to a Lean mathlib version:  theorem (n : ℕ) (x : EuclideanSpace",
      "h6_primes : ¬ ∃ p q : ℕ, p < q ∧ Prime p ∧ Prime q ∧ p + q = 6 "
    ],
    "answer": ": ¬ (∃ n m: Nat, Prime n ∧ Prime m ∧ n ≠ m ∧ 6 = n + m) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "six_not_prime_sum",
      "main_prompt": "Six is not the sum of two prime numbers.",
      "prompt": "Natural language version: \"The sine of `π / 6` is `1 / 2`.\" Translate the natural language version to a Lean mathlib version:\n theorem  :\nreal.sin (real.pi / 6) = 1 / 2 := \n\nNatural language version: \" Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) :\n∃ (p : ℕ), n ≤ p ∧ nat.prime p := \n\nNatural language version: \" **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**.\" Translate the natural language version to a Lean mathlib version:\n theorem {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) :\n∃ (a b : ℕ), a ^ 2 + b ^ 2 = p := \n\nNatural language version: \" Euclid's lemma: if `a ∣ b * c` and `a` and `b` have no common prime factors, `a ∣ c`. Compare `is_coprime.dvd_of_dvd_mul_right`.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] {a b c : R} (ha : a ≠ 0) (no_factors : ∀ {d : R}, d ∣ a → d ∣ b → ¬prime d) :\na ∣ b * c → a ∣ c := \n\nNatural language version: \"Six is not the sum of two prime numbers.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.4190795421600342,
          "doc_string": "The sine of `π / 6` is `1 / 2`.",
          "statement": "theorem real.sin_pi_div_six  : real.sin (real.pi / 6) = 1 / 2"
        },
        {
          "sim_score": 0.41275641322135925,
          "doc_string": " Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`.",
          "statement": "theorem nat.exists_infinite_primes (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p"
        },
        {
          "sim_score": 0.4100857973098755,
          "doc_string": " **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**.",
          "statement": "theorem nat.prime.sq_add_sq {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p"
        },
        {
          "sim_score": 0.40865230560302734,
          "doc_string": " Euclid's lemma: if `a ∣ b * c` and `a` and `b` have no common prime factors, `a ∣ c`. Compare `is_coprime.dvd_of_dvd_mul_right`.",
          "statement": "theorem unique_factorization_monoid.dvd_of_dvd_mul_right_of_no_prime_factors {R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] {a b c : R} (ha : a ≠ 0) (no_factors : ∀ {d : R}, d ∣ a → d ∣ b → ¬prime d) : a ∣ b * c → a ∣ c"
        }
      ],
      "codex_time": 4.61223292798968,
      "search_time": 1.5245796910021454,
      "use_theorem_name": false
    },
    "outputs": [
      ": ¬ ∃ (a b : ℕ), Nat.Prime a ∧ Nat.Prime b ∧ a + b = 6 ",
      ": ¬ ∃ (a b : ℕ), Nat.Prime a ∧ Nat.Prime b ∧ a + b = 6 ",
      ": ¬ ∃ (a b : ℕ), Nat.Prime a ∧ Nat.Prime b ∧ a + b = 6 ",
      ": ∀ p q : ℕ, Nat.Prime p → Nat.Prime q → p + q ≠ 6 ",
      ": ¬ ((2 : ℕ) = (3 : ℕ)) ∧ ¬ ((2 : ℕ) = (3 : ℕ)) "
    ],
    "answer": ": ¬ (∃ n m: Nat, Prime n ∧ Prime m ∧ n ≠ m ∧ 6 = n + m) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "six_not_prime_sum",
      "main_prompt": "Six is not the sum of two prime numbers.",
      "prompt": "Natural language version: \"Six is not the sum of two prime numbers.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 4.959866607008735,
      "use_theorem_name": false
    },
    "outputs": [
      "not_six_sum_two_prime :     ¬ (6 : ℕ ) = p + q ∧ Prime p ∧ Prime q ",
      "six_neq_two_prime_sums : (6:ℕ) ≠ 2+3 ",
      "six_not_sum_two_primes : ¬ (6 = (2 + 3))  ",
      "six_not_sum_of_two_primes : ¬ ∃ a b : ℕ,        a < b ∧ b < 6 ∧ b + a = 6 ∧ Prime b ∧ Prime a ",
      "sum_two_primes_not_6 : ¬(2 + 3 = 6) "
    ],
    "answer": ": ¬ (∃ n m: Nat, Prime n ∧ Prime m ∧ n ≠ m ∧ 6 = n + m) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "fin_torsionfree",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"A finite torsion-free group is trivial\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A finite torsion-free group is trivial",
      "codex_time": 8.606701053999132,
      "use_theorem_name": false
    },
    "outputs": [
      "(G : Type*) [Fintype G] [Group G] (hG: ∀ g : G, g = 1):  { g : G // g ≠ 1} ",
      "(G : Type*) [Fintype G] [Groupₓₓ G] (hG: ∀ g : G, g = 1):  { g : G // g ≠ 1} ",
      "(G : Type*) [Fintype G] [Groupₓ G] (hG: ∀ g : G, g = 1):  { g : G // g ≠ 1} ",
      "(G : Type*) [Fintypeₓ G] [Group G] (hG: ∀ g : G, g = 1):  { g : G // g ≠ 1} ",
      "(G : Type*) [Fintypeₓ G] [Groupₓₓ G] (hG: ∀ g : G, g = 1):  { g : G // g ≠ 1} ",
      "(G : Type*) [Fintypeₓ G] [Groupₓ G] (hG: ∀ g : G, g = 1):  { g : G // g ≠ 1} ",
      "(G : Type*) [Group G] [Fintype G] [is_abelian G]  (hG : ∀ a : G, a ≠ 1 → ∃ k : ℕ, a ^ k = 1) :  G ≃ (1 : G) ",
      "(G : Type*) [Groupₓₓ G] [Fintype G] [is_abelian G]  (hG : ∀ a : G, a ≠ 1 → ∃ k : ℕ, a ^ k = 1) :  G ≃ (1 : G) ",
      "(G : Type*) [Groupₓ G] [Fintype G] [is_abelian G]  (hG : ∀ a : G, a ≠ 1 → ∃ k : ℕ, a ^ k = 1) :  G ≃ (1 : G) ",
      "(G : Type*) [Group G] [Fintypeₓ G] [is_abelian G]  (hG : ∀ a : G, a ≠ 1 → ∃ k : ℕ, a ^ k = 1) :  G ≃ (1 : G) ",
      "(G : Type*) [Groupₓₓ G] [Fintypeₓ G] [is_abelian G]  (hG : ∀ a : G, a ≠ 1 → ∃ k : ℕ, a ^ k = 1) :  G ≃ (1 : G) ",
      "(G : Type*) [Groupₓ G] [Fintypeₓ G] [is_abelian G]  (hG : ∀ a : G, a ≠ 1 → ∃ k : ℕ, a ^ k = 1) :  G ≃ (1 : G) ",
      "(G : Type*) [Group G] [Fintype G] (h1 : Fintype.card G > 1)  (h2 : ∀ x : G, x ≠ 1 → ∃ n : ℕ, x ^ n = 1) :  ∀ x : G, x = 1 ",
      "(G : Type*) [Groupₓₓ G] [Fintype G] (h1 : Fintype.card G > 1)  (h2 : ∀ x : G, x ≠ 1 → ∃ n : ℕ, x ^ n = 1) :  ∀ x : G, x = 1 ",
      "(G : Type*) [Groupₓ G] [Fintype G] (h1 : Fintype.card G > 1)  (h2 : ∀ x : G, x ≠ 1 → ∃ n : ℕ, x ^ n = 1) :  ∀ x : G, x = 1 ",
      "(G : Type*) [Group G] [Fintypeₓ G] (h1 : Fintypeₓ.card G > 1)  (h2 : ∀ x : G, x ≠ 1 → ∃ n : ℕ, x ^ n = 1) :  ∀ x : G, x = 1 ",
      "(G : Type*) [Groupₓₓ G] [Fintypeₓ G] (h1 : Fintypeₓ.card G > 1)  (h2 : ∀ x : G, x ≠ 1 → ∃ n : ℕ, x ^ n = 1) :  ∀ x : G, x = 1 ",
      "(G : Type*) [Groupₓ G] [Fintypeₓ G] (h1 : Fintypeₓ.card G > 1)  (h2 : ∀ x : G, x ≠ 1 → ∃ n : ℕ, x ^ n = 1) :  ∀ x : G, x = 1 ",
      "(G : Type*) [Group G] (hG_card : card G < ⊤)  (hG_tors : ∀ x : G, x ≠ 1 → ∃ m : ℕ, x ^ m = 1) : G = ({1} : Set G) ",
      "(G : Type*) [Groupₓₓ G] (hG_card : card G < ⊤)  (hG_tors : ∀ x : G, x ≠ 1 → ∃ m : ℕ, x ^ m = 1) : G = ({1} : Set G) ",
      "(G : Type*) [Group G] (hG_card : card G < ⊤)  (hG_tors : ∀ x : G, x ≠ 1 → ∃ m : ℕ, x ^ m = 1) : G = ({1} : Setₓ G) ",
      "(G : Type*) [Groupₓₓ G] (hG_card : card G < ⊤)  (hG_tors : ∀ x : G, x ≠ 1 → ∃ m : ℕ, x ^ m = 1) : G = ({1} : Setₓ G) ",
      "(G : Type*) [Groupₓ G] (hG_card : card G < ⊤)  (hG_tors : ∀ x : G, x ≠ 1 → ∃ m : ℕ, x ^ m = 1) : G = ({1} : Set G) ",
      "(G : Type*) [Groupₓ G] (hG_card : card G < ⊤)  (hG_tors : ∀ x : G, x ≠ 1 → ∃ m : ℕ, x ^ m = 1) : G = ({1} : Setₓ G) ",
      "(G : Type*) [Fintype G] [Group G] [Nontrivial G]  {𝒢 : Subgroup G} (h𝒢 : ∀ x ∈ 𝒢, x = 1) : False ",
      "(G : Type*) [Fintype G] [Groupₓₓ G] [Nontrivial G]  {𝒢 : Subgroup G} (h𝒢 : ∀ x ∈ 𝒢, x = 1) : False ",
      "(G : Type*) [Fintype G] [Groupₓ G] [Nontrivial G]  {𝒢 : Subgroup G} (h𝒢 : ∀ x ∈ 𝒢, x = 1) : False ",
      "(G : Type*) [Fintypeₓ G] [Group G] [Nontrivial G]  {𝒢 : Subgroup G} (h𝒢 : ∀ x ∈ 𝒢, x = 1) : False ",
      "(G : Type*) [Fintypeₓ G] [Groupₓₓ G] [Nontrivial G]  {𝒢 : Subgroup G} (h𝒢 : ∀ x ∈ 𝒢, x = 1) : False ",
      "(G : Type*) [Fintypeₓ G] [Groupₓ G] [Nontrivial G]  {𝒢 : Subgroup G} (h𝒢 : ∀ x ∈ 𝒢, x = 1) : False "
    ],
    "answer": "{G: Type _}[Groupₓ G][Finite G] : Monoidₓ.IsTorsionFree G → IsSubgroup.Trivial G "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "fin_torsionfree",
      "main_prompt": "A finite torsion-free group is trivial",
      "prompt": "Natural language version: \"Subgroups of torsion-free groups are torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) :\nmonoid.is_torsion_free ↥H := \n\nNatural language version: \"A nontrivial torsion group is not torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] [hN : nontrivial G] :\nmonoid.is_torsion G → ¬monoid.is_torsion_free G := \n\nNatural language version: \"A nontrivial torsion-free group is not torsion.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] [hN : nontrivial G] :\nmonoid.is_torsion_free G → ¬monoid.is_torsion G := \n\nNatural language version: \"Direct products of torsion free groups are torsion free.\" Translate the natural language version to a Lean mathlib version:\n theorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) :\nmonoid.is_torsion_free (Π (i : η), Gs i) := \n\nNatural language version: \"A finite torsion-free group is trivial\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.8230506181716919,
          "doc_string": "Subgroups of torsion-free groups are torsion-free.",
          "statement": "theorem is_torsion_free.subgroup {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) : monoid.is_torsion_free ↥H"
        },
        {
          "sim_score": 0.8135049939155579,
          "doc_string": "A nontrivial torsion group is not torsion-free.",
          "statement": "theorem is_torsion.not_torsion_free {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G → ¬monoid.is_torsion_free G"
        },
        {
          "sim_score": 0.8007985353469849,
          "doc_string": "A nontrivial torsion-free group is not torsion.",
          "statement": "theorem is_torsion_free.not_torsion {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G → ¬monoid.is_torsion G"
        },
        {
          "sim_score": 0.7504584789276123,
          "doc_string": "Direct products of torsion free groups are torsion free.",
          "statement": "theorem is_torsion_free.prod {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i)"
        }
      ],
      "codex_time": 5.388354164984776,
      "search_time": 1.4583576289878692,
      "use_theorem_name": false
    },
    "outputs": [
      "{G : Type u_1} [Group G] [hG : is_finitely_generated G] (tfG : Monoidₓ.IsTorsionFree G) : trivial G ",
      "{G : Type u_1} [Groupₓₓ G] [hG : is_finitely_generated G] (tfG : Monoidₓ.IsTorsionFree G) : trivial G ",
      "{G : Type u_1} [Groupₓ G] [hG : is_finitely_generated G] (tfG : Monoidₓ.IsTorsionFree G) : trivial G ",
      "{G : Type u_1} [Group G] [hG : is_finitely_generated G] (tfG : Monoidₓ.IsTorsionFree G) : trivialₓ G ",
      "{G : Type u_1} [Groupₓₓ G] [hG : is_finitely_generated G] (tfG : Monoidₓ.IsTorsionFree G) : trivialₓ G ",
      "{G : Type u_1} [Groupₓ G] [hG : is_finitely_generated G] (tfG : Monoidₓ.IsTorsionFree G) : trivialₓ G ",
      "{G : Type u_1} [Group G] (f : Fintype G) : Monoidₓ.IsTorsionFree G → Fintype.card G = 1 ",
      "{G : Type u_1} [Groupₓₓ G] (f : Fintype G) : Monoidₓ.IsTorsionFree G → Fintype.card G = 1 ",
      "{G : Type u_1} [Groupₓ G] (f : Fintype G) : Monoidₓ.IsTorsionFree G → Fintype.card G = 1 ",
      "{G : Type u_1} [Group G] (f : Fintypeₓ G) : Monoidₓ.IsTorsionFree G → Fintypeₓ.card G = 1 ",
      "{G : Type u_1} [Groupₓₓ G] (f : Fintypeₓ G) : Monoidₓ.IsTorsionFree G → Fintypeₓ.card G = 1 ",
      "{G : Type u_1} [Groupₓ G] (f : Fintypeₓ G) : Monoidₓ.IsTorsionFree G → Fintypeₓ.card G = 1 ",
      "{G : Type u_1} [Group G] [Fintype G] : Monoidₓ.IsTorsionFree G → ¬ Nontrivial G ",
      "{G : Type u_1} [Groupₓₓ G] [Fintype G] : Monoidₓ.IsTorsionFree G → ¬ Nontrivial G ",
      "{G : Type u_1} [Groupₓ G] [Fintype G] : Monoidₓ.IsTorsionFree G → ¬ Nontrivial G ",
      "{G : Type u_1} [Group G] [Fintypeₓ G] : Monoidₓ.IsTorsionFree G → ¬ Nontrivial G ",
      "{G : Type u_1} [Groupₓₓ G] [Fintypeₓ G] : Monoidₓ.IsTorsionFree G → ¬ Nontrivial G ",
      "{G : Type u_1} [Groupₓ G] [Fintypeₓ G] : Monoidₓ.IsTorsionFree G → ¬ Nontrivial G ",
      "{G : Type u_1} [Group G] [finite_group G] (tfG : Monoidₓ.IsTorsionFree G) : Nontrivial G → False ",
      "{G : Type u_1} [Groupₓₓ G] [finite_group G] (tfG : Monoidₓ.IsTorsionFree G) : Nontrivial G → False ",
      "{G : Type u_1} [Groupₓ G] [finite_group G] (tfG : Monoidₓ.IsTorsionFree G) : Nontrivial G → False ",
      "{G : Type u_1} [Group G] [fG : Fintype G] [tfG : Monoidₓ.IsTorsionFree G] : G ≃ ℕ ",
      "{G : Type u_1} [Groupₓₓ G] [fG : Fintype G] [tfG : Monoidₓ.IsTorsionFree G] : G ≃ ℕ ",
      "{G : Type u_1} [Groupₓ G] [fG : Fintype G] [tfG : Monoidₓ.IsTorsionFree G] : G ≃ ℕ ",
      "{G : Type u_1} [Group G] [fG : Fintypeₓ G] [tfG : Monoidₓ.IsTorsionFree G] : G ≃ ℕ ",
      "{G : Type u_1} [Groupₓₓ G] [fG : Fintypeₓ G] [tfG : Monoidₓ.IsTorsionFree G] : G ≃ ℕ ",
      "{G : Type u_1} [Groupₓ G] [fG : Fintypeₓ G] [tfG : Monoidₓ.IsTorsionFree G] : G ≃ ℕ "
    ],
    "answer": "{G: Type _}[Groupₓ G][Finite G] : Monoidₓ.IsTorsionFree G → IsSubgroup.Trivial G "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "fin_torsionfree",
      "main_prompt": "A finite torsion-free group is trivial",
      "prompt": "Natural language version: \"A finite torsion-free group is trivial\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 9.018558857002063,
      "use_theorem_name": false
    },
    "outputs": [
      "finite_torsion_free_group_is_trivial : finite_torsion_free (trivial G) ",
      "finite_torsion_free_group_is_trivial : finite_torsion_free (trivialₓ G) ",
      "finite_torsion_free_group_is_trivial (G : Type*) [Group G] [Fintype G] [torsion_free G] : G ≃ ({1} : Type*)  Theorem finite_torsion_free_group_is_trivial (G : Type*) [Group G] [Fintype G] [torsion_free G] : G ≃ ({1} : Type*) ",
      "finite_torsion_free_group_is_trivial (G : Type*) [Groupₓₓ G] [Fintype G] [torsion_free G] : G ≃ ({1} : Type*)  Theorem finite_torsion_free_group_is_trivial (G : Type*) [Groupₓₓ G] [Fintype G] [torsion_free G] : G ≃ ({1} : Type*) ",
      "finite_torsion_free_group_is_trivial (G : Type*) [Groupₓ G] [Fintype G] [torsion_free G] : G ≃ ({1} : Type*)  Theorem finite_torsion_free_group_is_trivial (G : Type*) [Groupₓ G] [Fintype G] [torsion_free G] : G ≃ ({1} : Type*) ",
      "finite_torsion_free_group_is_trivial (G : Type*) [Group G] [Fintypeₓ G] [torsion_free G] : G ≃ ({1} : Type*)  Theorem finite_torsion_free_group_is_trivial (G : Type*) [Group G] [Fintypeₓ G] [torsion_free G] : G ≃ ({1} : Type*) ",
      "finite_torsion_free_group_is_trivial (G : Type*) [Groupₓₓ G] [Fintypeₓ G] [torsion_free G] : G ≃ ({1} : Type*)  Theorem finite_torsion_free_group_is_trivial (G : Type*) [Groupₓₓ G] [Fintypeₓ G] [torsion_free G] : G ≃ ({1} : Type*) ",
      "finite_torsion_free_group_is_trivial (G : Type*) [Groupₓ G] [Fintypeₓ G] [torsion_free G] : G ≃ ({1} : Type*)  Theorem finite_torsion_free_group_is_trivial (G : Type*) [Groupₓ G] [Fintypeₓ G] [torsion_free G] : G ≃ ({1} : Type*) ",
      "is trivial (G : fin_tor_free Group) : G = trivial ",
      "is trivial (G : fin_tor_free Groupₓₓ) : G = trivial ",
      "is trivial (G : fin_tor_free Groupₓ) : G = trivial ",
      "is trivialₓ (G : fin_tor_free Group) : G = trivialₓ ",
      "is trivialₓ (G : fin_tor_free Groupₓₓ) : G = trivialₓ ",
      "is trivialₓ (G : fin_tor_free Groupₓ) : G = trivialₓ ",
      "fpi_is_trivial { A : Type * } [ Fintype A ] [ CommGroup A ] [ pi A ] :  ∃ g : A , 1 = g ",
      "fpi_is_trivial { A : Type * } [ Fintype A ] [ CommGroupₓₓ A ] [ pi A ] :  ∃ g : A , 1 = g ",
      "fpi_is_trivial { A : Type * } [ Fintype A ] [ CommGroupₓ A ] [ pi A ] :  ∃ g : A , 1 = g ",
      "fpi_is_trivial { A : Type * } [ Fintypeₓ A ] [ CommGroup A ] [ pi A ] :  ∃ g : A , 1 = g ",
      "fpi_is_trivial { A : Type * } [ Fintypeₓ A ] [ CommGroupₓₓ A ] [ pi A ] :  ∃ g : A , 1 = g ",
      "fpi_is_trivial { A : Type * } [ Fintypeₓ A ] [ CommGroupₓ A ] [ pi A ] :  ∃ g : A , 1 = g ",
      "is_trivial.of_fintype_tors (G : Type) [Unique G] [Group G] [Fintype G] [Fintype (G × G)] [tors G] : is_trivial G . To make sure that is_trivial is already in our mathlib: import group_theory.subgroup  Before task 2, check the docs. Is is_trivial the right thing? It seems like yes!  Also, task 2 before that is something that should be done by someone who knows the definitions!  Dear Isabelle/Isainjit: I'm very much looking forward to this new connection. I'm sure math",
      "is_trivial.of_fintype_tors (G : Type) [Unique G] [Groupₓₓ G] [Fintype G] [Fintype (G × G)] [tors G] : is_trivial G . To make sure that is_trivial is already in our mathlib: import group_theory.subgroup  Before task 2, check the docs. Is is_trivial the right thing? It seems like yes!  Also, task 2 before that is something that should be done by someone who knows the definitions!  Dear Isabelle/Isainjit: I'm very much looking forward to this new connection. I'm sure math",
      "is_trivial.of_fintype_tors (G : Type) [Unique G] [Groupₓ G] [Fintype G] [Fintype (G × G)] [tors G] : is_trivial G . To make sure that is_trivial is already in our mathlib: import group_theory.subgroup  Before task 2, check the docs. Is is_trivial the right thing? It seems like yes!  Also, task 2 before that is something that should be done by someone who knows the definitions!  Dear Isabelle/Isainjit: I'm very much looking forward to this new connection. I'm sure math",
      "is_trivial.of_fintype_tors (G : Type) [Unique G] [Group G] [Fintypeₓ G] [Fintypeₓ (G × G)] [tors G] : is_trivial G . To make sure that is_trivial is already in our mathlib: import group_theory.subgroup  Before task 2, check the docs. Is is_trivial the right thing? It seems like yes!  Also, task 2 before that is something that should be done by someone who knows the definitions!  Dear Isabelle/Isainjit: I'm very much looking forward to this new connection. I'm sure math",
      "is_trivial.of_fintype_tors (G : Type) [Unique G] [Groupₓₓ G] [Fintypeₓ G] [Fintypeₓ (G × G)] [tors G] : is_trivial G . To make sure that is_trivial is already in our mathlib: import group_theory.subgroup  Before task 2, check the docs. Is is_trivial the right thing? It seems like yes!  Also, task 2 before that is something that should be done by someone who knows the definitions!  Dear Isabelle/Isainjit: I'm very much looking forward to this new connection. I'm sure math",
      "is_trivial.of_fintype_tors (G : Type) [Unique G] [Groupₓ G] [Fintypeₓ G] [Fintypeₓ (G × G)] [tors G] : is_trivial G . To make sure that is_trivial is already in our mathlib: import group_theory.subgroup  Before task 2, check the docs. Is is_trivial the right thing? It seems like yes!  Also, task 2 before that is something that should be done by someone who knows the definitions!  Dear Isabelle/Isainjit: I'm very much looking forward to this new connection. I'm sure math"
    ],
    "answer": "{G: Type _}[Groupₓ G][Finite G] : Monoidₓ.IsTorsionFree G → IsSubgroup.Trivial G "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "hom_rat_Z_trivial",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Any homomorphism from the additive group of rational numbers to `ℤ` is trivial\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Any homomorphism from the additive group of rational numbers to `ℤ` is trivial",
      "codex_time": 13.161472238018177,
      "use_theorem_name": false
    },
    "outputs": [
      "(f : ℚ → ℤ) [IsRingHom f] :  ∀ q : ℚ, f (q*q) = 0 ",
      "(f : ℚ → ℤ) [IsAddGroupHom f] : ∀ x y : ℚ, f (x + y) = f x + f y  Natural language version: \"Let G be a Group admitting an automorphism of order 3. If o(a)=2, prove that the order of a is 2 or 6.\" Translate the natural language version to a Lean mathlib version:  theorem (G : Type*) [Group G] (a : G)  (h : ∃ f : G → G, IsGroupHom f ∧ ∀ x : G, f x = x)  (h1 : a ≠",
      "(f : ℚ → ℤ) [IsAddGroupHom f] : ∀ x y : ℚ, f (x + y) = f x + f y  Natural language version: \"Let G be a Groupₓₓ admitting an automorphism of order 3. If o(a)=2, prove that the order of a is 2 or 6.\" Translate the natural language version to a Lean mathlib version:  theorem (G : Type*) [Groupₓₓ G] (a : G)  (h : ∃ f : G → G, IsGroupHom f ∧ ∀ x : G, f x = x)  (h1 : a ≠",
      "(f : ℚ → ℤ) [IsAddGroupHom f] : ∀ x y : ℚ, f (x + y) = f x + f y  Natural language version: \"Let G be a Groupₓ admitting an automorphism of order 3. If o(a)=2, prove that the order of a is 2 or 6.\" Translate the natural language version to a Lean mathlib version:  theorem (G : Type*) [Groupₓ G] (a : G)  (h : ∃ f : G → G, IsGroupHom f ∧ ∀ x : G, f x = x)  (h1 : a ≠",
      "(φ : ℚ → ℤ) [IsGroupHom φ] :  ∀ q : ℚ, φ q = 0 ",
      "(f : ℚ → ℤ) [IsAddGroupHom f] : ∀ x : ℚ, f x = 0 ",
      "(f : ℚ → ℤ) (hf : IsGroupHom f) :  ∀ r : ℚ, f r = 0 "
    ],
    "answer": "(f : ℚ → ℤ) : IsAddGroupHom f →  ∀ x: ℚ, f x = 0 "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "hom_rat_Z_trivial",
      "main_prompt": "Any homomorphism from the additive group of rational numbers to `ℤ` is trivial",
      "prompt": "Natural language version: \"An additive group homomorphism is injective if its kernel is trivial.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) :\nfunction.injective f ↔ ∀ (a : α), f a = 0 → a = 0 := \n\nNatural language version: \"An additive group homomorphism sends 0 to 0.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) :\nf 0 = 0 := \n\nNatural language version: \"Additive group homomorphisms preserve integer scaling.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_6} {H : Type u_7} {F : Type u_8} [add_group G] [subtraction_monoid H] [add_monoid_hom_class F G H] (f : F) (n : ℤ) (g : G) :\n⇑f (n • g) = n • ⇑f g := \n\nNatural language version: \"Additive group homomorphisms preserve integer scaling.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} {β : Type u_2} [add_group α] [subtraction_monoid β] (f : α →+ β) (g : α) (n : ℤ) :\n⇑f (n • g) = n • ⇑f g := \n\nNatural language version: \"Any homomorphism from the additive group of rational numbers to `ℤ` is trivial\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.7258538603782654,
          "doc_string": "An additive group homomorphism is injective if its kernel is trivial.",
          "statement": "theorem is_add_group_hom.injective_iff {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 0 → a = 0"
        },
        {
          "sim_score": 0.7063751220703125,
          "doc_string": "An additive group homomorphism sends 0 to 0.",
          "statement": "theorem is_add_group_hom.map_zero {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : f 0 = 0"
        },
        {
          "sim_score": 0.6773562431335449,
          "doc_string": "Additive group homomorphisms preserve integer scaling.",
          "statement": "theorem map_zsmul {G : Type u_6} {H : Type u_7} {F : Type u_8} [add_group G] [subtraction_monoid H] [add_monoid_hom_class F G H] (f : F) (n : ℤ) (g : G) : ⇑f (n • g) = n • ⇑f g"
        },
        {
          "sim_score": 0.6773562431335449,
          "doc_string": "Additive group homomorphisms preserve integer scaling.",
          "statement": "theorem add_monoid_hom.map_zsmul {α : Type u_1} {β : Type u_2} [add_group α] [subtraction_monoid β] (f : α →+ β) (g : α) (n : ℤ) : ⇑f (n • g) = n • ⇑f g"
        }
      ],
      "codex_time": 5.191497617022833,
      "search_time": 1.5807068219874054,
      "use_theorem_name": false
    },
    "outputs": [
      "{α : Type u_1} [Group α] (f : ℚ → α) [IsAddGroupHom f] : ∃ (n : ℤ), ∀ (x : ℚ), f x = n ",
      "{α : Type u_1} [Groupₓₓ α] (f : ℚ → α) [IsAddGroupHom f] : ∃ (n : ℤ), ∀ (x : ℚ), f x = n ",
      "{α : Type u_1} [Groupₓ α] (f : ℚ → α) [IsAddGroupHom f] : ∃ (n : ℤ), ∀ (x : ℚ), f x = n ",
      "{α : Type u} [AddCommGroup α] [Group α] [CharZero α] (f : ℚ →+ α) : f 0 = 0 ",
      "{α : Type u} [AddCommGroupₓₓ α] [Group α] [CharZero α] (f : ℚ →+ α) : f 0 = 0 ",
      "{α : Type u} [AddCommGroup α] [Groupₓₓ α] [CharZero α] (f : ℚ →+ α) : f 0 = 0 ",
      "{α : Type u} [AddCommGroupₓₓ α] [Groupₓₓ α] [CharZero α] (f : ℚ →+ α) : f 0 = 0 ",
      "{α : Type u} [AddCommGroupₓ α] [Group α] [CharZero α] (f : ℚ →+ α) : f 0 = 0 ",
      "{α : Type u} [AddCommGroupₓ α] [Groupₓₓ α] [CharZero α] (f : ℚ →+ α) : f 0 = 0 ",
      "{α : Type u} [AddCommGroup α] [Groupₓ α] [CharZero α] (f : ℚ →+ α) : f 0 = 0 ",
      "{α : Type u} [AddCommGroupₓₓ α] [Groupₓ α] [CharZero α] (f : ℚ →+ α) : f 0 = 0 ",
      "{α : Type u} [AddCommGroupₓ α] [Groupₓ α] [CharZero α] (f : ℚ →+ α) : f 0 = 0 ",
      "{R : Type u_1} {n : ℕ} [CommRing R] [Prime n] {h : add_group.to_add_group (units R) ≃* ℤ} : h = 0 ",
      "{R : Type u_1} {n : ℕ} [CommRingₓₓ R] [Prime n] {h : add_group.to_add_group (units R) ≃* ℤ} : h = 0 ",
      "{R : Type u_1} {n : ℕ} [CommRingₓ R] [Prime n] {h : add_group.to_add_group (units R) ≃* ℤ} : h = 0 ",
      "{G : Type u_1} {H : Type u_2} [AddGroup G] [SubtractionMonoid H] (hom_class : group_hom_class ℚ G H) : trivial H ",
      "{G : Type u_1} {H : Type u_2} [AddGroupₓₓ G] [SubtractionMonoid H] (hom_class : group_hom_class ℚ G H) : trivial H ",
      "{G : Type u_1} {H : Type u_2} [AddGroup G] [SubtractionMonoid H] (hom_class : group_hom_class ℚ G H) : trivialₓ H ",
      "{G : Type u_1} {H : Type u_2} [AddGroupₓₓ G] [SubtractionMonoid H] (hom_class : group_hom_class ℚ G H) : trivialₓ H ",
      "{G : Type u_1} {H : Type u_2} [AddGroupₓ G] [SubtractionMonoid H] (hom_class : group_hom_class ℚ G H) : trivial H ",
      "{G : Type u_1} {H : Type u_2} [AddGroupₓ G] [SubtractionMonoid H] (hom_class : group_hom_class ℚ G H) : trivialₓ H ",
      "{α : Type u_1} {β : Type u_2} [AddGroup α] [AddGroup β] [Ring β] (f : α →+ β) : f = 0 ↔ ∀ (q : ℚ), f q = 0 → q = 0 ",
      "{α : Type u_1} {β : Type u_2} [AddGroup α] [AddGroup β] [Ringₓₓ β] (f : α →+ β) : f = 0 ↔ ∀ (q : ℚ), f q = 0 → q = 0 ",
      "{α : Type u_1} {β : Type u_2} [AddGroupₓₓ α] [AddGroupₓₓ β] [Ring β] (f : α →+ β) : f = 0 ↔ ∀ (q : ℚ), f q = 0 → q = 0 ",
      "{α : Type u_1} {β : Type u_2} [AddGroupₓₓ α] [AddGroupₓₓ β] [Ringₓₓ β] (f : α →+ β) : f = 0 ↔ ∀ (q : ℚ), f q = 0 → q = 0 ",
      "{α : Type u_1} {β : Type u_2} [AddGroup α] [AddGroup β] [Ringₓ β] (f : α →+ β) : f = 0 ↔ ∀ (q : ℚ), f q = 0 → q = 0 ",
      "{α : Type u_1} {β : Type u_2} [AddGroupₓₓ α] [AddGroupₓₓ β] [Ringₓ β] (f : α →+ β) : f = 0 ↔ ∀ (q : ℚ), f q = 0 → q = 0 ",
      "{α : Type u_1} {β : Type u_2} [AddGroupₓ α] [AddGroupₓ β] [Ring β] (f : α →+ β) : f = 0 ↔ ∀ (q : ℚ), f q = 0 → q = 0 ",
      "{α : Type u_1} {β : Type u_2} [AddGroupₓ α] [AddGroupₓ β] [Ringₓₓ β] (f : α →+ β) : f = 0 ↔ ∀ (q : ℚ), f q = 0 → q = 0 ",
      "{α : Type u_1} {β : Type u_2} [AddGroupₓ α] [AddGroupₓ β] [Ringₓ β] (f : α →+ β) : f = 0 ↔ ∀ (q : ℚ), f q = 0 → q = 0 "
    ],
    "answer": "(f : ℚ → ℤ) : IsAddGroupHom f →  ∀ x: ℚ, f x = 0 "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "hom_rat_Z_trivial",
      "main_prompt": "Any homomorphism from the additive group of rational numbers to `ℤ` is trivial",
      "prompt": "Natural language version: \"Any homomorphism from the additive group of rational numbers to `ℤ` is trivial\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 7.689356604008935,
      "use_theorem_name": false
    },
    "outputs": [
      "any_homomorphism_from_rational_additive_group_to_int_is_trivial :    ∀ (q : ℚ), ∃ (r : ℤ), q + r = 0 ",
      "Qnat_is_int_iff_surjection_injective : is_int Q Nat ↔ Function.Injective (Q Nat) ∧ surjective (Q Nat) ",
      "nat_lang_mathlib (G : Type*) [Group G] (f : ℚ →₂[AddMonoid] G) : f.ker = ℤ → f = 0 ",
      "nat_lang_mathlib (G : Type*) [Groupₓₓ G] (f : ℚ →₂[AddMonoid] G) : f.ker = ℤ → f = 0 ",
      "nat_lang_mathlib (G : Type*) [Group G] (f : ℚ →₂[AddMonoidₓ] G) : f.ker = ℤ → f = 0 ",
      "nat_lang_mathlib (G : Type*) [Groupₓₓ G] (f : ℚ →₂[AddMonoidₓ] G) : f.ker = ℤ → f = 0 ",
      "nat_lang_mathlib (G : Type*) [Groupₓ G] (f : ℚ →₂[AddMonoid] G) : f.ker = ℤ → f = 0 ",
      "nat_lang_mathlib (G : Type*) [Groupₓ G] (f : ℚ →₂[AddMonoidₓ] G) : f.ker = ℤ → f = 0 ",
      "example : ∀ (A B : Type) [AddCommGroup A] [AddCommGroup B] (f : A → B), IsAddGroupHom f → (∀ x : ℚ, f (x : ℝ) = 0) → f 0 = 0 ",
      "example : ∀ (A B : Type) [AddCommGroupₓₓ A] [AddCommGroupₓₓ B] (f : A → B), IsAddGroupHom f → (∀ x : ℚ, f (x : ℝ) = 0) → f 0 = 0 ",
      "example : ∀ (A B : Type) [AddCommGroupₓ A] [AddCommGroupₓ B] (f : A → B), IsAddGroupHom f → (∀ x : ℚ, f (x : ℝ) = 0) → f 0 = 0 ",
      "If_rat.of_trivial : If_rat.trivial → A → F ",
      "If_rat.of_trivial : If_rat.trivialₓ → A → F "
    ],
    "answer": "(f : ℚ → ℤ) : IsAddGroupHom f →  ∀ x: ℚ, f x = 0 "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "fin_int_domain_ring_is_field",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every finite division ring is a field.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every finite division ring is a field.",
      "codex_time": 7.35270361599396,
      "use_theorem_name": false
    },
    "outputs": [
      "is_field_finite_division {F : Type*} [DivisionRing F]  (hF: Fintype F) : IsField F ",
      "is_field_finite_division {F : Type*} [DivisionRing F]  (hF: Fintypeₓ F) : IsField F ",
      "(F : Type*) [DivisionRing F] [Fintype F] :  Field F ",
      "(F : Type*) [DivisionRing F] [Fintypeₓ F] :  Field F ",
      "(F : Type*) [Fintype F] [DivisionRing F] :  Field F ",
      "(F : Type*) [Fintypeₓ F] [DivisionRing F] :  Field F ",
      "(D : Type*) [DivisionRing D] (n : ℕ) (h2 : 2 ≤ n) (hfin : Nat.Prime n)  (hD : Fintype D) : Field D ",
      "(D : Type*) [DivisionRing D] (n : ℕ) (h2 : 2 ≤ n) (hfin : Nat.Prime n)  (hD : Fintypeₓ D) : Field D ",
      "(D : Type*) [CommRing D] [Fintype D] [FiniteDimensional ℤ D] :  IsField D ",
      "(D : Type*) [CommRingₓₓ D] [Fintype D] [FiniteDimensional ℤ D] :  IsField D ",
      "(D : Type*) [CommRingₓ D] [Fintype D] [FiniteDimensional ℤ D] :  IsField D ",
      "(D : Type*) [CommRing D] [Fintypeₓ D] [FiniteDimensional ℤ D] :  IsField D ",
      "(D : Type*) [CommRingₓₓ D] [Fintypeₓ D] [FiniteDimensional ℤ D] :  IsField D ",
      "(D : Type*) [CommRingₓ D] [Fintypeₓ D] [FiniteDimensional ℤ D] :  IsField D "
    ],
    "answer": "{R : Type _} [Ringₓ R][IsDomain R] [Finite R] : Field R "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "fin_int_domain_ring_is_field",
      "main_prompt": "Every finite division ring is a field.",
      "prompt": "Natural language version: \"A subfield is closed under division.\" Translate the natural language version to a Lean mathlib version:\n theorem {K : Type u} [field K] (s : subfield K) {x y : K} :\nx ∈ s → y ∈ s → x / y ∈ s := \n\nNatural language version: \"A division_ring is one-dimensional as a vector space over itself.\" Translate the natural language version to a Lean mathlib version:\n theorem (K : Type u) [division_ring K] :\nfinite_dimensional.finrank K K = 1 := \n\nNatural language version: \"An intermediate field is closed under division.\" Translate the natural language version to a Lean mathlib version:\n theorem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} :\nx ∈ S → y ∈ S → x / y ∈ S := \n\nNatural language version: \"A subfield is closed under multiplication.\" Translate the natural language version to a Lean mathlib version:\n theorem {K : Type u} [field K] (s : subfield K) {x y : K} :\nx ∈ s → y ∈ s → x * y ∈ s := \n\nNatural language version: \"Every finite division ring is a field.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6756068468093872,
          "doc_string": "A subfield is closed under division.",
          "statement": "theorem subfield.div_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x / y ∈ s"
        },
        {
          "sim_score": 0.6545361280441284,
          "doc_string": "A division_ring is one-dimensional as a vector space over itself.",
          "statement": "theorem finite_dimensional.finrank_self (K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1"
        },
        {
          "sim_score": 0.6345528364181519,
          "doc_string": "An intermediate field is closed under division.",
          "statement": "theorem intermediate_field.div_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} : x ∈ S → y ∈ S → x / y ∈ S"
        },
        {
          "sim_score": 0.62082839012146,
          "doc_string": "A subfield is closed under multiplication.",
          "statement": "theorem subfield.mul_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x * y ∈ s"
        }
      ],
      "codex_time": 5.707831264997367,
      "search_time": 1.4604721890063956,
      "use_theorem_name": false
    },
    "outputs": [
      "(K : Type u) [DivisionRing K] [Fintype K] : Field K ",
      "(K : Type u) [DivisionRing K] [Fintypeₓ K] : Field K ",
      "{K : Type u} [DivisionRing K] [Fintype K] [DecidableEq K] : Field K ",
      "{K : Type u} [DivisionRing K] [Fintypeₓ K] [DecidableEq K] : Field K ",
      "{K : Type u} [FiniteDimensional K ℤp] [DivisionRing K] : Field K ",
      "{K : Type u} [DivisionRing K] (h : Finite K) : Field K ",
      "(K : Type u) [DivisionRing K] [Fintype K] : @Subfield K (@subfield_le K (fintype.card_pos K)) ",
      "(K : Type u) [DivisionRing K] [Fintypeₓ K] : @Subfield K (@subfield_le K (fintype.card_pos K)) "
    ],
    "answer": "{R : Type _} [Ringₓ R][IsDomain R] [Finite R] : Field R "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "fin_int_domain_ring_is_field",
      "main_prompt": "Every finite division ring is a field.",
      "prompt": "Natural language version: \"Every finite division ring is a field.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 9.53978893099702,
      "use_theorem_name": false
    },
    "outputs": [
      "every_finite_division_ring_is_field : ∀ d : DivisionRing, finite_sum d → IsField d ",
      "RingDivision.is_field_every :   ∀ k : RingDivision.{u v}, IsField k ",
      "every_finite_division_ring_is_a_field :  ∀ (D : Type u) [DivisionRing D] [Fintype D], IsField D ",
      "every_finite_division_ring_is_a_field :  ∀ (D : Type u) [DivisionRing D] [Fintypeₓ D], IsField D ",
      "every_finite_division_ring_is_a_field : Π ( D : Type ), DivisionRing D → Fintype D → Field D ",
      "every_finite_division_ring_is_a_field : Π ( D : Type ), DivisionRing D → Fintypeₓ D → Field D ",
      "finite_division_ring_is_field {D : Type} [DivisionRing D] [Fintype D] : is_a_field D. Write a proof term of the type of that theorem. -/  -- ANSWER example : (∀ (D : Type) [hsD : DivisionRing D] [hfD : Fintype D], is_a_field D) ",
      "finite_division_ring_is_field {D : Type} [DivisionRing D] [Fintypeₓ D] : is_a_field D. Write a proof term of the type of that theorem. -/  -- ANSWER example : (∀ (D : Type) [hsD : DivisionRing D] [hfD : Fintypeₓ D], is_a_field D) "
    ],
    "answer": "{R : Type _} [Ringₓ R][IsDomain R] [Finite R] : Field R "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "finite_space_compact",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every finite topological space is compact\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every finite topological space is compact",
      "codex_time": 5.378165368019836,
      "use_theorem_name": false
    },
    "outputs": [
      "(X : Type*) [TopologicalSpace X] (hfin : Fintype X) : CompactSpace X ",
      "(X : Type*) [TopologicalSpace X] (hfin : Fintypeₓ X) : CompactSpace X ",
      "finite_compact {X : Type*} [TopologicalSpace X] (hX : Finite X) :  IsCompact X ",
      "(X : Type*) [TopologicalSpace X] (fh : finite_basis_of_opens X) :  CompactSpace X ",
      "(X : Type*) [TopologicalSpace X]  (n : ℕ) (hfin : Fintype X) (hX : IsCompact X) :  Finite X ",
      "(X : Type*) [TopologicalSpace X]  (n : ℕ) (hfin : Fintypeₓ X) (hX : IsCompact X) :  Finite X ",
      "(X : Type*) [TopologicalSpace X] (hF : Fintype X) (H : Set (Set X))  (hH : ∀ U : Set X, U ∈ H ↔ IsOpen U) (hcover : ∀ x ∈ X, ∃ U : Set X, IsOpen U ∧ x ∈ U) :  ∃ F : Set (Set X), ⋂₀ F = univ ",
      "(X : Type*) [TopologicalSpace X] (hF : Fintype X) (H : Setₓ (Setₓ X))  (hH : ∀ U : Setₓ X, U ∈ H ↔ IsOpen U) (hcover : ∀ x ∈ X, ∃ U : Setₓ X, IsOpen U ∧ x ∈ U) :  ∃ F : Setₓ (Setₓ X), ⋂₀ F = univ ",
      "(X : Type*) [TopologicalSpace X] (hF : Fintypeₓ X) (H : Set (Set X))  (hH : ∀ U : Set X, U ∈ H ↔ IsOpen U) (hcover : ∀ x ∈ X, ∃ U : Set X, IsOpen U ∧ x ∈ U) :  ∃ F : Set (Set X), ⋂₀ F = univ ",
      "(X : Type*) [TopologicalSpace X] (hF : Fintypeₓ X) (H : Setₓ (Setₓ X))  (hH : ∀ U : Setₓ X, U ∈ H ↔ IsOpen U) (hcover : ∀ x ∈ X, ∃ U : Setₓ X, IsOpen U ∧ x ∈ U) :  ∃ F : Setₓ (Setₓ X), ⋂₀ F = univ "
    ],
    "answer": "{X : Type _}[TopologicalSpace X][Finite X] : CompactSpace X "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "finite_space_compact",
      "main_prompt": "Every finite topological space is compact",
      "prompt": "Natural language version: \"A set `s` is compact if for every open cover of `s`, there exists a finite subcover.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [topological_space α] {s : set α} (h : ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)) :\nis_compact s := \n\nNatural language version: \"For every open cover of a compact set, there exists a finite subcover.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} {ι : Type u_1} [topological_space α] {s : set α} {b : set ι} {c : ι → set α} (hs : is_compact s) (hc₁ : ∀ (i : ι), i ∈ b → is_open (c i)) (hc₂ : s ⊆ ⋃ (i : ι) (H : i ∈ b), c i) :\n∃ (b' : set ι) (H : b' ⊆ b), b'.finite ∧ s ⊆ ⋃ (i : ι) (H : i ∈ b'), c i := \n\nNatural language version: \"For every open cover of a compact set, there exists a finite subcover.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [topological_space α] {s : set α} {ι : Type v} (hs : is_compact s) (U : ι → set α) (hUo : ∀ (i : ι), is_open (U i)) (hsU : s ⊆ ⋃ (i : ι), U i) :\n∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i := \n\nNatural language version: \" A set `s` is compact if and only if for every open cover of `s`, there exists a finite subcover.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [topological_space α] {s : set α} :\nis_compact s ↔ ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i) := \n\nNatural language version: \"Every finite topological space is compact\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.676864504814148,
          "doc_string": "A set `s` is compact if for every open cover of `s`, there exists a finite subcover.",
          "statement": "theorem is_compact_of_finite_subcover {α : Type u} [topological_space α] {s : set α} (h : ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)) : is_compact s"
        },
        {
          "sim_score": 0.6767893433570862,
          "doc_string": "For every open cover of a compact set, there exists a finite subcover.",
          "statement": "theorem is_compact.elim_finite_subcover_image {α : Type u} {ι : Type u_1} [topological_space α] {s : set α} {b : set ι} {c : ι → set α} (hs : is_compact s) (hc₁ : ∀ (i : ι), i ∈ b → is_open (c i)) (hc₂ : s ⊆ ⋃ (i : ι) (H : i ∈ b), c i) : ∃ (b' : set ι) (H : b' ⊆ b), b'.finite ∧ s ⊆ ⋃ (i : ι) (H : i ∈ b'), c i"
        },
        {
          "sim_score": 0.6767893433570862,
          "doc_string": "For every open cover of a compact set, there exists a finite subcover.",
          "statement": "theorem is_compact.elim_finite_subcover {α : Type u} [topological_space α] {s : set α} {ι : Type v} (hs : is_compact s) (U : ι → set α) (hUo : ∀ (i : ι), is_open (U i)) (hsU : s ⊆ ⋃ (i : ι), U i) : ∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i"
        },
        {
          "sim_score": 0.65172278881073,
          "doc_string": " A set `s` is compact if and only if for every open cover of `s`, there exists a finite subcover.",
          "statement": "theorem is_compact_iff_finite_subcover {α : Type u} [topological_space α] {s : set α} : is_compact s ↔ ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)"
        }
      ],
      "codex_time": 6.1293448169890326,
      "search_time": 1.4795987970137503,
      "use_theorem_name": false
    },
    "outputs": [
      "{α : Type u} [TopologicalSpace α] (h : Nonempty α) (hs : finite_topological_space α) : IsCompact (univ : Set α) ",
      "{α : Type u} [TopologicalSpace α] (h : Nonempty α) (hs : finite_topological_space α) : IsCompact (univ : Setₓ α) ",
      "{α : Type u} [TopologicalSpace α] (H : (Fintype α)) : IsCompact α ",
      "{α : Type u} [TopologicalSpace α] (H : (Fintypeₓ α)) : IsCompact α ",
      "{α : Type u} [TopologicalSpace α] (h₁ : Finite α) : IsCompact α ",
      "{α : Type u} [TopologicalSpace α] (hαf : Fintype α) : IsCompact α ",
      "{α : Type u} [TopologicalSpace α] (hαf : Fintypeₓ α) : IsCompact α ",
      "{α : Type u} [TopologicalSpace α] (hα : Nonempty α) : IsCompact α "
    ],
    "answer": "{X : Type _}[TopologicalSpace X][Finite X] : CompactSpace X "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "finite_space_compact",
      "main_prompt": "Every finite topological space is compact",
      "prompt": "Natural language version: \"Every finite topological space is compact\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 6.154093182994984,
      "use_theorem_name": false
    },
    "outputs": [
      "finite_compact (X : Type*) [TopologicalSpace X] [Fintype X] : CompactSpace X ",
      "finite_compact (X : Type*) [TopologicalSpace X] [Fintypeₓ X] : CompactSpace X ",
      "TotallyBoundedImpliesCompact (X : Type) [t : TopologicalSpace X] :    (∀ (ε : ℝ) (ε_pos : 0 < ε), ∃ (U : Set X), IsOpen U ∧ X ⊆ Closure U ) → IsCompact X ",
      "TotallyBoundedImpliesCompact (X : Type) [t : TopologicalSpace X] :    (∀ (ε : ℝ) (ε_pos : 0 < ε), ∃ (U : Setₓ X), IsOpen U ∧ X ⊆ Closure U ) → IsCompact X ",
      "every_finite_topological_space_is_compact : ∀ (X : Type) [TopologicalSpace X] [Fintype X], CompactSpace X ",
      "every_finite_topological_space_is_compact : ∀ (X : Type) [TopologicalSpace X] [Fintypeₓ X], CompactSpace X ",
      "compact_iff_compact_of_finite (X : Type*) [TopologicalSpace X] : IsCompact X ↔ Finite X ",
      "every_finite_topological_space_is_compact :     ∀ (X : Type*) [TopologicalSpace X], Finite X → CompactSpace X   -/  %tactic lemma sudoku (X : Type*) [TopologicalSpace X] (n : ℕ) :      (∃ (x : X), x.val = n) → ∃ (x : X), x.val ≥ n   "
    ],
    "answer": "{X : Type _}[TopologicalSpace X][Finite X] : CompactSpace X "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "freegroup_hopfian",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every surjective homomorphism from a finitely generated free group to itself is injective\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every surjective homomorphism from a finitely generated free group to itself is injective",
      "codex_time": 8.908651261008345,
      "use_theorem_name": false
    },
    "outputs": [
      "(G : Type*) [Group G] (n : ℕ) [fg : Fintype (Fin n)]  (γ : FreeGroup (Fin n) →* G) (hγ : surjective γ) : injective γ ",
      "(G : Type*) [Groupₓₓ G] (n : ℕ) [fg : Fintype (Fin n)]  (γ : FreeGroup (Fin n) →* G) (hγ : surjective γ) : injective γ ",
      "(G : Type*) [Group G] (n : ℕ) [fg : Fintype (Finₓ n)]  (γ : FreeGroup (Finₓ n) →* G) (hγ : surjective γ) : injective γ ",
      "(G : Type*) [Groupₓₓ G] (n : ℕ) [fg : Fintype (Finₓ n)]  (γ : FreeGroup (Finₓ n) →* G) (hγ : surjective γ) : injective γ ",
      "(G : Type*) [Groupₓ G] (n : ℕ) [fg : Fintype (Fin n)]  (γ : FreeGroup (Fin n) →* G) (hγ : surjective γ) : injective γ ",
      "(G : Type*) [Groupₓ G] (n : ℕ) [fg : Fintype (Finₓ n)]  (γ : FreeGroup (Finₓ n) →* G) (hγ : surjective γ) : injective γ ",
      "(G : Type*) [Group G] (n : ℕ) [fg : Fintypeₓ (Fin n)]  (γ : FreeGroup (Fin n) →* G) (hγ : surjective γ) : injective γ ",
      "(G : Type*) [Groupₓₓ G] (n : ℕ) [fg : Fintypeₓ (Fin n)]  (γ : FreeGroup (Fin n) →* G) (hγ : surjective γ) : injective γ ",
      "(G : Type*) [Group G] (n : ℕ) [fg : Fintypeₓ (Finₓ n)]  (γ : FreeGroup (Finₓ n) →* G) (hγ : surjective γ) : injective γ ",
      "(G : Type*) [Groupₓₓ G] (n : ℕ) [fg : Fintypeₓ (Finₓ n)]  (γ : FreeGroup (Finₓ n) →* G) (hγ : surjective γ) : injective γ ",
      "(G : Type*) [Groupₓ G] (n : ℕ) [fg : Fintypeₓ (Fin n)]  (γ : FreeGroup (Fin n) →* G) (hγ : surjective γ) : injective γ ",
      "(G : Type*) [Groupₓ G] (n : ℕ) [fg : Fintypeₓ (Finₓ n)]  (γ : FreeGroup (Finₓ n) →* G) (hγ : surjective γ) : injective γ ",
      "(G : Type*) [Group G] (hG : Fintype (free_group.carrier G))  (f : FreeGroup G →* G) (hf : Function.Injective f) :  Function.Surjective f ",
      "(G : Type*) [Groupₓₓ G] (hG : Fintype (free_group.carrier G))  (f : FreeGroup G →* G) (hf : Function.Injective f) :  Function.Surjective f ",
      "(G : Type*) [Groupₓ G] (hG : Fintype (free_group.carrier G))  (f : FreeGroup G →* G) (hf : Function.Injective f) :  Function.Surjective f ",
      "(G : Type*) [Group G] (hG : Fintypeₓ (free_group.carrier G))  (f : FreeGroup G →* G) (hf : Function.Injective f) :  Function.Surjective f ",
      "(G : Type*) [Groupₓₓ G] (hG : Fintypeₓ (free_group.carrier G))  (f : FreeGroup G →* G) (hf : Function.Injective f) :  Function.Surjective f ",
      "(G : Type*) [Groupₓ G] (hG : Fintypeₓ (free_group.carrier G))  (f : FreeGroup G →* G) (hf : Function.Injective f) :  Function.Surjective f ",
      "(F : Type u) [FreeGroup F] [Fintype F] (f : F → F) (hf : is_surjective f)  (hf_hom : ∀ a b : F, f (a * b) = f a * f b) :  is_injective f ",
      "(F : Type u) [FreeGroup F] [Fintypeₓ F] (f : F → F) (hf : is_surjective f)  (hf_hom : ∀ a b : F, f (a * b) = f a * f b) :  is_injective f ",
      "(N : Type) [Group N] [is_finitely_generated N] [is_free N]  (ϕ : N → N) (hϕ : Function.Surjective ϕ) (hϕ_homo : Function.Injective ϕ) :  Function.Injective ϕ ",
      "(N : Type) [Groupₓₓ N] [is_finitely_generated N] [is_free N]  (ϕ : N → N) (hϕ : Function.Surjective ϕ) (hϕ_homo : Function.Injective ϕ) :  Function.Injective ϕ ",
      "(N : Type) [Groupₓ N] [is_finitely_generated N] [is_free N]  (ϕ : N → N) (hϕ : Function.Surjective ϕ) (hϕ_homo : Function.Injective ϕ) :  Function.Injective ϕ ",
      "(G : Type*) [Group G] [Fintype G] [DecidableEq G] [IsGroupHom (f₁ : G → G)] [surjective f₁] : injective f₁ ",
      "(G : Type*) [Groupₓₓ G] [Fintype G] [DecidableEq G] [IsGroupHom (f₁ : G → G)] [surjective f₁] : injective f₁ ",
      "(G : Type*) [Groupₓ G] [Fintype G] [DecidableEq G] [IsGroupHom (f₁ : G → G)] [surjective f₁] : injective f₁ ",
      "(G : Type*) [Group G] [Fintypeₓ G] [DecidableEq G] [IsGroupHom (f₁ : G → G)] [surjective f₁] : injective f₁ ",
      "(G : Type*) [Groupₓₓ G] [Fintypeₓ G] [DecidableEq G] [IsGroupHom (f₁ : G → G)] [surjective f₁] : injective f₁ ",
      "(G : Type*) [Groupₓ G] [Fintypeₓ G] [DecidableEq G] [IsGroupHom (f₁ : G → G)] [surjective f₁] : injective f₁ "
    ],
    "answer": "{α : Type _} [Finite α]: (f: FreeGroup α → FreeGroup α) → (IsGroupHom f) → f.Surjective → f.Injective "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "freegroup_hopfian",
      "main_prompt": "Every surjective homomorphism from a finitely generated free group to itself is injective",
      "prompt": "Natural language version: \"The canonical injection from the type to the free group is an injection.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} :\nfunction.injective free_group.of := \n\nNatural language version: \"A group homomorphism is injective iff its kernel is trivial.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) :\nfunction.injective f ↔ ∀ (a : α), f a = 1 → a = 1 := \n\nNatural language version: \" Two homomorphisms out of a free group are equal if they are equal on generators.  See note [partially-applied ext lemmas].\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} {G : Type u_1} [group G] (f g : free_group α →* G) (h : ∀ (a : α), ⇑f (free_group.of a) = ⇑g (free_group.of a)) :\nf = g := \n\nNatural language version: \"The range of a surjective homomorphism from a nilpotent group is nilpotent\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] {G' : Type u_2} [group G'] [h : group.is_nilpotent G] (f : G →* G') (hf : function.surjective ⇑f) :\ngroup.is_nilpotent G' := \n\nNatural language version: \"Every surjective homomorphism from a finitely generated free group to itself is injective\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6470739841461182,
          "doc_string": "The canonical injection from the type to the free group is an injection.",
          "statement": "theorem free_group.of_injective {α : Type u} : function.injective free_group.of"
        },
        {
          "sim_score": 0.6357327103614807,
          "doc_string": "A group homomorphism is injective iff its kernel is trivial.",
          "statement": "theorem is_group_hom.injective_iff {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 1 → a = 1"
        },
        {
          "sim_score": 0.5912977457046509,
          "doc_string": " Two homomorphisms out of a free group are equal if they are equal on generators.  See note [partially-applied ext lemmas].",
          "statement": "theorem free_group.ext_hom {α : Type u} {G : Type u_1} [group G] (f g : free_group α →* G) (h : ∀ (a : α), ⇑f (free_group.of a) = ⇑g (free_group.of a)) : f = g"
        },
        {
          "sim_score": 0.5858901143074036,
          "doc_string": "The range of a surjective homomorphism from a nilpotent group is nilpotent",
          "statement": "theorem nilpotent_of_surjective {G : Type u_1} [group G] {G' : Type u_2} [group G'] [h : group.is_nilpotent G] (f : G →* G') (hf : function.surjective ⇑f) : group.is_nilpotent G'"
        }
      ],
      "codex_time": 4.3753448179923,
      "search_time": 1.483718688978115,
      "use_theorem_name": false
    },
    "outputs": [
      "{α : Type u} {β : Type v} [Group β] {f : FreeGroup α →* β} (hf : Function.Surjective ⇑f) : Function.Injective ⇑f ",
      "{α : Type u} {β : Type v} [Groupₓₓ β] {f : FreeGroup α →* β} (hf : Function.Surjective ⇑f) : Function.Injective ⇑f ",
      "{α : Type u} {β : Type v} [Groupₓ β] {f : FreeGroup α →* β} (hf : Function.Surjective ⇑f) : Function.Injective ⇑f ",
      "{α : Type u} {G : Type u_1} [Group G] (f : FreeGroup α →* G) (hf : Function.Surjective ⇑f) : Function.Injective ⇑f ",
      "{α : Type u} {G : Type u_1} [Groupₓₓ G] (f : FreeGroup α →* G) (hf : Function.Surjective ⇑f) : Function.Injective ⇑f ",
      "{α : Type u} {G : Type u_1} [Groupₓ G] (f : FreeGroup α →* G) (hf : Function.Surjective ⇑f) : Function.Injective ⇑f ",
      "{α : Type u} {G : FreeGroup α} (H : ∃ s : Set α, Finite s ∧ G = Closure s) {H' : Type u_1} [Group H'] (f : G →* H') (hf : Function.Surjective ⇑f) : Function.Injective ⇑f ",
      "{α : Type u} {G : FreeGroup α} (H : ∃ s : Set α, Finite s ∧ G = Closure s) {H' : Type u_1} [Groupₓₓ H'] (f : G →* H') (hf : Function.Surjective ⇑f) : Function.Injective ⇑f ",
      "{α : Type u} {G : FreeGroup α} (H : ∃ s : Setₓ α, Finite s ∧ G = Closure s) {H' : Type u_1} [Group H'] (f : G →* H') (hf : Function.Surjective ⇑f) : Function.Injective ⇑f ",
      "{α : Type u} {G : FreeGroup α} (H : ∃ s : Setₓ α, Finite s ∧ G = Closure s) {H' : Type u_1} [Groupₓₓ H'] (f : G →* H') (hf : Function.Surjective ⇑f) : Function.Injective ⇑f ",
      "{α : Type u} {G : FreeGroup α} (H : ∃ s : Set α, Finite s ∧ G = Closure s) {H' : Type u_1} [Groupₓ H'] (f : G →* H') (hf : Function.Surjective ⇑f) : Function.Injective ⇑f ",
      "{α : Type u} {G : FreeGroup α} (H : ∃ s : Setₓ α, Finite s ∧ G = Closure s) {H' : Type u_1} [Groupₓ H'] (f : G →* H') (hf : Function.Surjective ⇑f) : Function.Injective ⇑f ",
      "{α : Type u_1} [Fintype α] {f : FreeGroup α →* FreeGroup α} (hf : Function.Surjective ⇑f) : Function.Injective f ",
      "{α : Type u_1} [Fintypeₓ α] {f : FreeGroup α →* FreeGroup α} (hf : Function.Surjective ⇑f) : Function.Injective f ",
      "{α : Type u} {G : Type u_1} [Group G] (f : FreeGroup α →* G) (h₁ : Function.Surjective f) (h₂ : ∃ (t : Finset α), is_basis ↑t) : Function.Injective f ",
      "{α : Type u} {G : Type u_1} [Groupₓₓ G] (f : FreeGroup α →* G) (h₁ : Function.Surjective f) (h₂ : ∃ (t : Finset α), is_basis ↑t) : Function.Injective f ",
      "{α : Type u} {G : Type u_1} [Groupₓ G] (f : FreeGroup α →* G) (h₁ : Function.Surjective f) (h₂ : ∃ (t : Finset α), is_basis ↑t) : Function.Injective f "
    ],
    "answer": "{α : Type _} [Finite α]: (f: FreeGroup α → FreeGroup α) → (IsGroupHom f) → f.Surjective → f.Injective "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "freegroup_hopfian",
      "main_prompt": "Every surjective homomorphism from a finitely generated free group to itself is injective",
      "prompt": "Natural language version: \"Every surjective homomorphism from a finitely generated free group to itself is injective\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 8.291480947984383,
      "use_theorem_name": false
    },
    "outputs": [
      "surj_hom_free_group_inj_on_fg (G : Type*) [_inst_1 : Fintype G] [_inst_2 : DecidableEq G] [Group G]     [Fintype (FreeGroup G)] (S : Set (FreeGroup G)) [IsSubgroup S]     (f : FreeGroup G →* G) [is_surjective f] (H : f.ker ≤ S) :   is_injective (ker_restrict f S) ",
      "surj_hom_free_group_inj_on_fg (G : Type*) [_inst_1 : Fintype G] [_inst_2 : DecidableEq G] [Groupₓₓ G]     [Fintype (FreeGroup G)] (S : Set (FreeGroup G)) [IsSubgroup S]     (f : FreeGroup G →* G) [is_surjective f] (H : f.ker ≤ S) :   is_injective (ker_restrict f S) ",
      "surj_hom_free_group_inj_on_fg (G : Type*) [_inst_1 : Fintype G] [_inst_2 : DecidableEq G] [Group G]     [Fintype (FreeGroup G)] (S : Setₓ (FreeGroup G)) [IsSubgroup S]     (f : FreeGroup G →* G) [is_surjective f] (H : f.ker ≤ S) :   is_injective (ker_restrict f S) ",
      "surj_hom_free_group_inj_on_fg (G : Type*) [_inst_1 : Fintype G] [_inst_2 : DecidableEq G] [Groupₓₓ G]     [Fintype (FreeGroup G)] (S : Setₓ (FreeGroup G)) [IsSubgroup S]     (f : FreeGroup G →* G) [is_surjective f] (H : f.ker ≤ S) :   is_injective (ker_restrict f S) ",
      "surj_hom_free_group_inj_on_fg (G : Type*) [_inst_1 : Fintype G] [_inst_2 : DecidableEq G] [Groupₓ G]     [Fintype (FreeGroup G)] (S : Set (FreeGroup G)) [IsSubgroup S]     (f : FreeGroup G →* G) [is_surjective f] (H : f.ker ≤ S) :   is_injective (ker_restrict f S) ",
      "surj_hom_free_group_inj_on_fg (G : Type*) [_inst_1 : Fintype G] [_inst_2 : DecidableEq G] [Groupₓ G]     [Fintype (FreeGroup G)] (S : Setₓ (FreeGroup G)) [IsSubgroup S]     (f : FreeGroup G →* G) [is_surjective f] (H : f.ker ≤ S) :   is_injective (ker_restrict f S) ",
      "surj_hom_free_group_inj_on_fg (G : Type*) [_inst_1 : Fintypeₓ G] [_inst_2 : DecidableEq G] [Group G]     [Fintypeₓ (FreeGroup G)] (S : Set (FreeGroup G)) [IsSubgroup S]     (f : FreeGroup G →* G) [is_surjective f] (H : f.ker ≤ S) :   is_injective (ker_restrict f S) ",
      "surj_hom_free_group_inj_on_fg (G : Type*) [_inst_1 : Fintypeₓ G] [_inst_2 : DecidableEq G] [Groupₓₓ G]     [Fintypeₓ (FreeGroup G)] (S : Set (FreeGroup G)) [IsSubgroup S]     (f : FreeGroup G →* G) [is_surjective f] (H : f.ker ≤ S) :   is_injective (ker_restrict f S) ",
      "surj_hom_free_group_inj_on_fg (G : Type*) [_inst_1 : Fintypeₓ G] [_inst_2 : DecidableEq G] [Group G]     [Fintypeₓ (FreeGroup G)] (S : Setₓ (FreeGroup G)) [IsSubgroup S]     (f : FreeGroup G →* G) [is_surjective f] (H : f.ker ≤ S) :   is_injective (ker_restrict f S) ",
      "surj_hom_free_group_inj_on_fg (G : Type*) [_inst_1 : Fintypeₓ G] [_inst_2 : DecidableEq G] [Groupₓₓ G]     [Fintypeₓ (FreeGroup G)] (S : Setₓ (FreeGroup G)) [IsSubgroup S]     (f : FreeGroup G →* G) [is_surjective f] (H : f.ker ≤ S) :   is_injective (ker_restrict f S) ",
      "surj_hom_free_group_inj_on_fg (G : Type*) [_inst_1 : Fintypeₓ G] [_inst_2 : DecidableEq G] [Groupₓ G]     [Fintypeₓ (FreeGroup G)] (S : Set (FreeGroup G)) [IsSubgroup S]     (f : FreeGroup G →* G) [is_surjective f] (H : f.ker ≤ S) :   is_injective (ker_restrict f S) ",
      "surj_hom_free_group_inj_on_fg (G : Type*) [_inst_1 : Fintypeₓ G] [_inst_2 : DecidableEq G] [Groupₓ G]     [Fintypeₓ (FreeGroup G)] (S : Setₓ (FreeGroup G)) [IsSubgroup S]     (f : FreeGroup G →* G) [is_surjective f] (H : f.ker ≤ S) :   is_injective (ker_restrict f S) ",
      "t3 : Π (G : Type*) [finitely_generated_group G] [is_free G]      (f : G → G), injective f → surjective f → injective f ",
      "surjective_homomorphism_of_free_group_injective (f : Π₁( G )) (fg : fin_gen S) {A} {a : A}          (surj : Function.Surjective ( f : Π₁( G ) → Π₁( G ))) : injective f ",
      "injective_hom {α β : Type*} [CommGroup α] [CommGroup β]  (f : α → β) [is_surjective f] : is_injective f ",
      "injective_hom {α β : Type*} [CommGroupₓₓ α] [CommGroupₓₓ β]  (f : α → β) [is_surjective f] : is_injective f ",
      "injective_hom {α β : Type*} [CommGroupₓ α] [CommGroupₓ β]  (f : α → β) [is_surjective f] : is_injective f ",
      "every_surjective_homomorphism_from_finitely_generated_free_group_to_itself_is_injective : ∀  s : Type u_1 , ∀  G : Type u_1 , ∀  H : Type u_1 , Fintype s → Group G → Group H → ( Π ( g : G ), Fintype ( coset g G )) → ( Π ( x y : G ), x ≠ y → ( Π ( g : G ), coset g G ≃ coset ( g • x ) G ) ∧ ( Π ( g : G ), coset g G ≃ coset ( g • y",
      "every_surjective_homomorphism_from_finitely_generated_free_group_to_itself_is_injective : ∀  s : Type u_1 , ∀  G : Type u_1 , ∀  H : Type u_1 , Fintype s → Groupₓₓ G → Groupₓₓ H → ( Π ( g : G ), Fintype ( coset g G )) → ( Π ( x y : G ), x ≠ y → ( Π ( g : G ), coset g G ≃ coset ( g • x ) G ) ∧ ( Π ( g : G ), coset g G ≃ coset ( g • y",
      "every_surjective_homomorphism_from_finitely_generated_free_group_to_itself_is_injective : ∀  s : Type u_1 , ∀  G : Type u_1 , ∀  H : Type u_1 , Fintype s → Groupₓ G → Groupₓ H → ( Π ( g : G ), Fintype ( coset g G )) → ( Π ( x y : G ), x ≠ y → ( Π ( g : G ), coset g G ≃ coset ( g • x ) G ) ∧ ( Π ( g : G ), coset g G ≃ coset ( g • y",
      "every_surjective_homomorphism_from_finitely_generated_free_group_to_itself_is_injective : ∀  s : Type u_1 , ∀  G : Type u_1 , ∀  H : Type u_1 , Fintypeₓ s → Group G → Group H → ( Π ( g : G ), Fintypeₓ ( coset g G )) → ( Π ( x y : G ), x ≠ y → ( Π ( g : G ), coset g G ≃ coset ( g • x ) G ) ∧ ( Π ( g : G ), coset g G ≃ coset ( g • y",
      "every_surjective_homomorphism_from_finitely_generated_free_group_to_itself_is_injective : ∀  s : Type u_1 , ∀  G : Type u_1 , ∀  H : Type u_1 , Fintypeₓ s → Groupₓₓ G → Groupₓₓ H → ( Π ( g : G ), Fintypeₓ ( coset g G )) → ( Π ( x y : G ), x ≠ y → ( Π ( g : G ), coset g G ≃ coset ( g • x ) G ) ∧ ( Π ( g : G ), coset g G ≃ coset ( g • y",
      "every_surjective_homomorphism_from_finitely_generated_free_group_to_itself_is_injective : ∀  s : Type u_1 , ∀  G : Type u_1 , ∀  H : Type u_1 , Fintypeₓ s → Groupₓ G → Groupₓ H → ( Π ( g : G ), Fintypeₓ ( coset g G )) → ( Π ( x y : G ), x ≠ y → ( Π ( g : G ), coset g G ≃ coset ( g • x ) G ) ∧ ( Π ( g : G ), coset g G ≃ coset ( g • y"
    ],
    "answer": "{α : Type _} [Finite α]: (f: FreeGroup α → FreeGroup α) → (IsGroupHom f) → f.Surjective → f.Injective "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "polys_unbounded",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every polynomial of positive degree over reals is unbounded.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every polynomial of positive degree over reals is unbounded.",
      "codex_time": 9.514002912008436,
      "use_theorem_name": false
    },
    "outputs": [
      "(a : ℝ) (n : ℕ) (h : 0 < n) :  ∃ x : ℝ, ∀ y : ℝ, (∀ (i : Fin n) (a : ℝ), (a i) * (y ^ i.val) - (Sum i in Fin n, (a i) * (x ^ i.val))) ≠ 0 ",
      "(a : ℝ) (n : ℕ) (h : 0 < n) :  ∃ x : ℝ, ∀ y : ℝ, (∀ (i : Finₓ n) (a : ℝ), (a i) * (y ^ i.val) - (Sum i in Finₓ n, (a i) * (x ^ i.val))) ≠ 0 ",
      "(p : Polynomial ℝ) (hp : polynomial.deg p > 0) :  ∀ x : ℝ, ∃ y : ℝ, y > x ∧ p.eval y > p.eval x ",
      "(p : real→ℝ) [Polynomial p] (h : 0 < degree p) :  ∃ c : ℝ, ∀ x : ℝ, ∥p x∥ > c ",
      "(p : ℝ) {n : ℕ} (hn : 0 < n) :  ∃ x : ℝ, abs p < abs x^n ",
      "(f : ℝ → ℝ) [Polynomial f] (h : nat.degree f > 0) :  ∀ M : ℝ, ∃ x : ℝ, ∥f x∥ ≥ M "
    ],
    "answer": "(p: Polynomial ℝ) : p.degree > 0 → ∀ m: ℝ, ∃ x: ℝ, p.eval x  > m ∨ p.eval x < -m  "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "polys_unbounded",
      "main_prompt": "Every polynomial of positive degree over reals is unbounded.",
      "prompt": "Natural language version: \"An alternative statement of Weierstrass' theorem.  Every real-valued continuous function on `[a,b]` is a uniform limit of polynomials.\" Translate the natural language version to a Lean mathlib version:\n theorem (a b : ℝ) (f : C(↥(set.Icc a b), ℝ)) :\nf ∈ (polynomial_functions (set.Icc a b)).topological_closure := \n\nNatural language version: \"The degree of a product of polynomials is at most the sum of the degrees, where the degree of the zero polynomial is ⊥.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [comm_semiring R] (t : multiset (polynomial R)) :\nt.prod.degree ≤ (multiset.map polynomial.degree t).sum := \n\nNatural language version: \"The **Weierstrass Approximation Theorem**: polynomials functions on `[a, b] ⊆ ℝ` are dense in `C([a,b],ℝ)`  (While we could deduce this as an application of the Stone-Weierstrass theorem, our proof of that relies on the fact that `abs` is in the closure of polynomials on `[-M, M]`, so we may as well get this done first.)\" Translate the natural language version to a Lean mathlib version:\n theorem (a b : ℝ) :\n(polynomial_functions (set.Icc a b)).topological_closure = ⊤ := \n\nNatural language version: \" The monomial function `x^n` tends to `+∞` at `+∞` for any positive natural `n`. A version for positive real powers exists as `tendsto_rpow_at_top`.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_3} [ordered_semiring α] {n : ℕ} (hn : 1 ≤ n) :\nfilter.tendsto (λ (x : α), x ^ n) filter.at_top filter.at_top := \n\nNatural language version: \"Every polynomial of positive degree over reals is unbounded.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5175106525421143,
          "doc_string": "An alternative statement of Weierstrass' theorem.  Every real-valued continuous function on `[a,b]` is a uniform limit of polynomials.",
          "statement": "theorem continuous_map_mem_polynomial_functions_closure (a b : ℝ) (f : C(↥(set.Icc a b), ℝ)) : f ∈ (polynomial_functions (set.Icc a b)).topological_closure"
        },
        {
          "sim_score": 0.5134747624397278,
          "doc_string": "The degree of a product of polynomials is at most the sum of the degrees, where the degree of the zero polynomial is ⊥.",
          "statement": "theorem polynomial.degree_multiset_prod_le {R : Type u} [comm_semiring R] (t : multiset (polynomial R)) : t.prod.degree ≤ (multiset.map polynomial.degree t).sum"
        },
        {
          "sim_score": 0.5014804005622864,
          "doc_string": "The **Weierstrass Approximation Theorem**: polynomials functions on `[a, b] ⊆ ℝ` are dense in `C([a,b],ℝ)`  (While we could deduce this as an application of the Stone-Weierstrass theorem, our proof of that relies on the fact that `abs` is in the closure of polynomials on `[-M, M]`, so we may as well get this done first.)",
          "statement": "theorem polynomial_functions_closure_eq_top (a b : ℝ) : (polynomial_functions (set.Icc a b)).topological_closure = ⊤"
        },
        {
          "sim_score": 0.48543989658355713,
          "doc_string": " The monomial function `x^n` tends to `+∞` at `+∞` for any positive natural `n`. A version for positive real powers exists as `tendsto_rpow_at_top`.",
          "statement": "theorem filter.tendsto_pow_at_top {α : Type u_3} [ordered_semiring α] {n : ℕ} (hn : 1 ≤ n) : filter.tendsto (λ (x : α), x ^ n) filter.at_top filter.at_top"
        }
      ],
      "codex_time": 8.425400767999236,
      "search_time": 1.4346691030077636,
      "use_theorem_name": false
    },
    "outputs": [
      "{α : Type u_1} [discrete_linear_ordered_field α] (p : Polynomial α) : 0 < p.degree → ∃ (u v : α), u < v ∧ ∀ (n : ℕ), (polynomial.eval_on p v) n > n ",
      "(p : ℝ[X]) : is_unbounded_left (Set p.range) ",
      "(p : ℝ[X]) : is_unbounded_left (Setₓ p.range) ",
      "{R : Type u} [LinearOrderedField R] (p : Polynomial R) (hp : 0 < p.nat_degree) : ∃ x, ∀ y, y < p.nat_degree → ∃ c, p.eval ⟨y, h.lt_succ_self y⟩ ≤ c * p.eval ⟨x, h.lt_succ_self x⟩ ",
      "{α : Type u_3} [discrete_field α] (f : Polynomial α) (hf : 0 < f.degree) : ∃ (p : P(ℝ)) (q : ℝ), ∀ n : ℝ, n ≥ p → (abs(Polynomial.eval n f)) ≥ q ",
      "{α : Type u_4} [decidable_linear_ordered_comm_ring α] {p : Polynomial α} (hp : 0 < p.degree) : ¬ (BddAbove (polynomial.range p.coeff_multiset)) "
    ],
    "answer": "(p: Polynomial ℝ) : p.degree > 0 → ∀ m: ℝ, ∃ x: ℝ, p.eval x  > m ∨ p.eval x < -m  "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "polys_unbounded",
      "main_prompt": "Every polynomial of positive degree over reals is unbounded.",
      "prompt": "Natural language version: \"Every polynomial of positive degree over reals is unbounded.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 9.196454343997175,
      "use_theorem_name": false
    },
    "outputs": [
      "every_polynomial_of_positive_degree_over_reals_is_unbounded (i : ℕ) (h : i > 0 ) : ∀ (p : Polynomial ℝ) , ∃ y : ℝ , ∀ x : ℝ, (Polynomial.eval₂ x y p) > i ",
      "{MPolyPositive} unbounded_polynomial' {R : Type} [Field R] {d : ℕ} (hp : d > 0) (hc : ∀ c : R, ∃ x, Polynomial R d c x) : False ",
      "is_unbounded (n : ℕ) (f : Polynomial ℝ) [p : degree f > 0] : ∃ a, ∀ b≥a, ∃ x:ℝ, |X^n| f x ≥ b .   example : is_unbounded 3 (1 + 3*X^2) ",
      "nat_language : unbounded (λ n, 1 / n) ",
      "poly_unbounded (n : ℕ) (p : Polynomial ℝ) : p.nat_degree > n → ∀ x, ∃ y, y > x ∧ abs(p.eval y) > abs (p.eval x) "
    ],
    "answer": "(p: Polynomial ℝ) : p.degree > 0 → ∀ m: ℝ, ∃ x: ℝ, p.eval x  > m ∨ p.eval x < -m  "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "field_hom_inj_or_trivial",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"A homomorphism between fields is either injective or trivial.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A homomorphism between fields is either injective or trivial.",
      "codex_time": 6.165453321998939,
      "use_theorem_name": false
    },
    "outputs": [
      "(F G : Type*) [Field F] [Field G]  (f : F → G) (hom : IsRingHom f) :  injective f ∨ f = 0 ",
      "(α β : Type*)  [Field α] [Field β] (f : α → β) [IsAddGroupHom f] [IsAddMonoidHom f]  [IsMonoidHom f] (h : f 1 = 1) :  (Function.Injective f) ∨ ∀ x : α, f x = 0 ",
      "(K L : Type*) [Field K] [Field L] (g : K → L) [IsRingHom g] :  injective g ∨ g = 0 ",
      "(α : Type*) [Field α] (f : α → α) [IsRingHom f] :  Function.Injective f ∨ ∀ x : α, f x = 0 ",
      "(F K : Type*) [Field F] [Field K] (h : F → K) [IsRingHom h]  (h_inj : ∀ x y, h x = h y → x = y) : Function.Injective h "
    ],
    "answer": "{F F' : Type _} [Field F] [Field F'] : ∀ ϕ : F →+* F', ϕ.toFun.Injective ∨ (∀ x : F, ϕ x = 0) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "field_hom_inj_or_trivial",
      "main_prompt": "A homomorphism between fields is either injective or trivial.",
      "prompt": "Natural language version: \"A group homomorphism is injective iff its kernel is trivial.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) :\nfunction.injective f ↔ ∀ (a : α), f a = 1 → a = 1 := \n\nNatural language version: \"If two ring homomorphisms are equal on a set, then they are equal on its subfield closure.\" Translate the natural language version to a Lean mathlib version:\n theorem {K : Type u} {L : Type v} [field K] [field L] {f g : K →+* L} {s : set K} (h : set.eq_on ⇑f ⇑g s) :\nset.eq_on ⇑f ⇑g ↑(subfield.closure s) := \n\nNatural language version: \"A monomorphism is injective.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_1} {R₂ : Type u_3} {M : Type u_9} {M₂ : Type u_12} [semiring R] [semiring R₂] [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module R₂ M₂] {τ₁₂ : R →+* R₂} {f : M →ₛₗ[τ₁₂] M₂} (h : ∀ (u v : ↥(f.ker) →ₗ[R] M), f.comp u = f.comp v → u = v) :\nf.ker = ⊥ := \n\nNatural language version: \"An additive group homomorphism is injective if its kernel is trivial.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) :\nfunction.injective f ↔ ∀ (a : α), f a = 0 → a = 0 := \n\nNatural language version: \"A homomorphism between fields is either injective or trivial.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6868539452552795,
          "doc_string": "A group homomorphism is injective iff its kernel is trivial.",
          "statement": "theorem is_group_hom.injective_iff {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 1 → a = 1"
        },
        {
          "sim_score": 0.6491084694862366,
          "doc_string": "If two ring homomorphisms are equal on a set, then they are equal on its subfield closure.",
          "statement": "theorem ring_hom.eq_on_field_closure {K : Type u} {L : Type v} [field K] [field L] {f g : K →+* L} {s : set K} (h : set.eq_on ⇑f ⇑g s) : set.eq_on ⇑f ⇑g ↑(subfield.closure s)"
        },
        {
          "sim_score": 0.6350299715995789,
          "doc_string": "A monomorphism is injective.",
          "statement": "theorem linear_map.ker_eq_bot_of_cancel {R : Type u_1} {R₂ : Type u_3} {M : Type u_9} {M₂ : Type u_12} [semiring R] [semiring R₂] [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module R₂ M₂] {τ₁₂ : R →+* R₂} {f : M →ₛₗ[τ₁₂] M₂} (h : ∀ (u v : ↥(f.ker) →ₗ[R] M), f.comp u = f.comp v → u = v) : f.ker = ⊥"
        },
        {
          "sim_score": 0.6343168020248413,
          "doc_string": "An additive group homomorphism is injective if its kernel is trivial.",
          "statement": "theorem is_add_group_hom.injective_iff {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 0 → a = 0"
        }
      ],
      "codex_time": 9.296392163989367,
      "search_time": 1.4474918549822178,
      "use_theorem_name": false
    },
    "outputs": [
      "{F : Type u} {F₂ : Type v} [Field F] [Field F₂] {τ : F →+* F₂} (h : ∀ (u v : ↥(τ.ker) →ₗ[F] F), τ.comp u = τ.comp v → u = v) : Function.Injective τ ∨ τ = 0 ",
      "{α : Type u} {β : Type v} [Field α] [Field β] {f : α →+* β} : Function.Injective f ∨ f = 0 ",
      "{K : Type u} {L : Type v} [Field K] [Field L] {f : K →+* L} : Function.Injective f ∨ f = 0 ",
      "{K : Type u_1} (L : Type v_1) [Field K] [Field L] {f : K →+* L} (hf : IsRingHom f) : setoid.injective f ⊕ ∀ (a : K), f a = 0 ",
      "{α : Type u} {β : Type v} [Field α] [Field β] {f : α → β} (hf : IsMonoidHom f) : Function.Injective f ∨ ∀ (a : α), f a = 0 "
    ],
    "answer": "{F F' : Type _} [Field F] [Field F'] : ∀ ϕ : F →+* F', ϕ.toFun.Injective ∨ (∀ x : F, ϕ x = 0) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "field_hom_inj_or_trivial",
      "main_prompt": "A homomorphism between fields is either injective or trivial.",
      "prompt": "Natural language version: \"A homomorphism between fields is either injective or trivial.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 12.863167470000917,
      "use_theorem_name": false
    },
    "outputs": [
      "ffield_hom.injective_or_trivial_of_injective_on_carrier (f : α →+* β) ( hf : Function.Injective f.to_fun) : f.injective ∨ trivial  theorem ffield_hom.inj_eq_0_of_inj_on_carrier (f : α →+* β) ( hf : Function.Injective f.to_fun) : injective f → f = 0 ",
      "ffield_hom.injective_or_trivial_of_injective_on_carrier (f : α →+* β) ( hf : Function.Injective f.to_fun) : f.injective ∨ trivialₓ  theorem ffield_hom.inj_eq_0_of_inj_on_carrier (f : α →+* β) ( hf : Function.Injective f.to_fun) : injective f → f = 0 ",
      "homomorphism_between_fields_is_injective_or_trivial {M: Type*} [Field M]    {N: Type*} [Field N] (f: M → N): injective f ∨ f = monoid_hom.id ",
      "(u : FieldHom U F) (inj : injective u) :    ∀ (v : FieldHom U F) (hom : ∀ x : U, v x = u x), v = u  | v hom ",
      "is_field_hom.inj_or_triv (hf : Field β) (hF : Field F) (h : hom β F hf hF) :    (λ a, ∃ b, h a = b • 1) ∨ (∀ a : β, h a = 0) ",
      "is_not_injective_then_is_trivial :  ∀ F₁ F₂ : Type u₁,  (∀ a b c d : F₁, a + b = c + d → a = c ∧ b = d) →  (∀ a b : F₁, a * b = 0 → a = 0 ∨ b = 0) →  ∀ (φ : F₁ → F₂) (h₁ : ∀ a b : F₁, φ a = φ b → a = b),  optional_decl (int_hom_ext"
    ],
    "answer": "{F F' : Type _} [Field F] [Field F'] : ∀ ϕ : F →+* F', ϕ.toFun.Injective ∨ (∀ x : F, ϕ x = 0) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "noetherian_implies_ascending_chain_condition",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every ascending chain of sub-modules of a Noetherian module eventually stabilises.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every ascending chain of sub-modules of a Noetherian module eventually stabilises.",
      "codex_time": 12.659880203020293,
      "use_theorem_name": false
    },
    "outputs": [
      "(R : Type*) [CommRing R] (M : Type*) [AddCommGroup M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrder A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRing R] (M : Type*) [AddCommGroupₓₓ M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrder A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRingₓₓ R] (M : Type*) [AddCommGroup M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrder A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRingₓₓ R] (M : Type*) [AddCommGroupₓₓ M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrder A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRing R] (M : Type*) [AddCommGroup M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrderₓₓ A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRing R] (M : Type*) [AddCommGroupₓₓ M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrderₓₓ A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRingₓₓ R] (M : Type*) [AddCommGroup M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrderₓₓ A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRingₓₓ R] (M : Type*) [AddCommGroupₓₓ M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrderₓₓ A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRing R] (M : Type*) [AddCommGroupₓ M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrder A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRingₓₓ R] (M : Type*) [AddCommGroupₓ M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrder A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRing R] (M : Type*) [AddCommGroupₓ M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrderₓₓ A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRingₓₓ R] (M : Type*) [AddCommGroupₓ M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrderₓₓ A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRing R] (M : Type*) [AddCommGroup M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrderₓ A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRing R] (M : Type*) [AddCommGroupₓₓ M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrderₓ A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRingₓₓ R] (M : Type*) [AddCommGroup M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrderₓ A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRingₓₓ R] (M : Type*) [AddCommGroupₓₓ M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrderₓ A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRing R] (M : Type*) [AddCommGroupₓ M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrderₓ A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRingₓₓ R] (M : Type*) [AddCommGroupₓ M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrderₓ A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRingₓ R] (M : Type*) [AddCommGroup M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrder A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRingₓ R] (M : Type*) [AddCommGroupₓₓ M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrder A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRingₓ R] (M : Type*) [AddCommGroup M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrderₓₓ A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRingₓ R] (M : Type*) [AddCommGroupₓₓ M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrderₓₓ A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRingₓ R] (M : Type*) [AddCommGroupₓ M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrder A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRingₓ R] (M : Type*) [AddCommGroupₓ M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrderₓₓ A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRingₓ R] (M : Type*) [AddCommGroup M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrderₓ A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRingₓ R] (M : Type*) [AddCommGroupₓₓ M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrderₓ A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(R : Type*) [CommRingₓ R] (M : Type*) [AddCommGroupₓ M] [Module R M] (hM : noetherian_module R M) (A : Type*) [PartialOrderₓ A] (f : A → Submodule R M) (hf : ∀ (x y : A), x ≤ y → f x ≤ f y) : ∃ x, f x = ⋃₀ (range $ λ y : A, f y) ",
      "(M : Type*) [AddCommGroup M] [Module ℤ M]  (hM : is_noetherian_module ℤ M) (n : ℕ) (f : Fin n → Submodule ℤ M)  (hf : ∀ (i j : ℕ) (h : i < j) (h' : j < n.succ), f i < f j) :  ∃ (N : ℕ) (N_lt : N < n.succ),  ∀ (i : ℕ) (i_lt : i < n.succ), i ≥ N → f i = f N",
      "(M : Type*) [AddCommGroupₓₓ M] [Module ℤ M]  (hM : is_noetherian_module ℤ M) (n : ℕ) (f : Fin n → Submodule ℤ M)  (hf : ∀ (i j : ℕ) (h : i < j) (h' : j < n.succ), f i < f j) :  ∃ (N : ℕ) (N_lt : N < n.succ),  ∀ (i : ℕ) (i_lt : i < n.succ), i ≥ N → f i = f N",
      "(M : Type*) [AddCommGroupₓ M] [Module ℤ M]  (hM : is_noetherian_module ℤ M) (n : ℕ) (f : Fin n → Submodule ℤ M)  (hf : ∀ (i j : ℕ) (h : i < j) (h' : j < n.succ), f i < f j) :  ∃ (N : ℕ) (N_lt : N < n.succ),  ∀ (i : ℕ) (i_lt : i < n.succ), i ≥ N → f i = f N",
      "(M : Type*) [AddCommGroup M] [Module ℤ M]  (hM : is_noetherian_module ℤ M) (n : ℕ) (f : Finₓ n → Submodule ℤ M)  (hf : ∀ (i j : ℕ) (h : i < j) (h' : j < n.succ), f i < f j) :  ∃ (N : ℕ) (N_lt : N < n.succ),  ∀ (i : ℕ) (i_lt : i < n.succ), i ≥ N → f i = f N",
      "(M : Type*) [AddCommGroupₓₓ M] [Module ℤ M]  (hM : is_noetherian_module ℤ M) (n : ℕ) (f : Finₓ n → Submodule ℤ M)  (hf : ∀ (i j : ℕ) (h : i < j) (h' : j < n.succ), f i < f j) :  ∃ (N : ℕ) (N_lt : N < n.succ),  ∀ (i : ℕ) (i_lt : i < n.succ), i ≥ N → f i = f N",
      "(M : Type*) [AddCommGroupₓ M] [Module ℤ M]  (hM : is_noetherian_module ℤ M) (n : ℕ) (f : Finₓ n → Submodule ℤ M)  (hf : ∀ (i j : ℕ) (h : i < j) (h' : j < n.succ), f i < f j) :  ∃ (N : ℕ) (N_lt : N < n.succ),  ∀ (i : ℕ) (i_lt : i < n.succ), i ≥ N → f i = f N",
      "(A : Type*) [noetherian_ring A] (M : Type*) [AddCommGroup M] [Module A M]  (B : ℕ → Submodule A M) (h_asc : ∀ n, B n ⊆ B (n+1)) :  ∃ N : ℕ, ∀ n, B n = B (N+n) ",
      "(A : Type*) [noetherian_ring A] (M : Type*) [AddCommGroupₓₓ M] [Module A M]  (B : ℕ → Submodule A M) (h_asc : ∀ n, B n ⊆ B (n+1)) :  ∃ N : ℕ, ∀ n, B n = B (N+n) ",
      "(A : Type*) [noetherian_ring A] (M : Type*) [AddCommGroupₓ M] [Module A M]  (B : ℕ → Submodule A M) (h_asc : ∀ n, B n ⊆ B (n+1)) :  ∃ N : ℕ, ∀ n, B n = B (N+n) ",
      "(R : Type*) [CommRing R] {M : Type*} [Module R M]  (hM : is_noetherian_module R M) (x : List (Submodule R M)) (hx : is_ascending x) :  x ≠ List.nil → ∃ n : ℕ, x.nth_le n hx = x.nth_le (n+1) hx ",
      "(R : Type*) [CommRingₓₓ R] {M : Type*} [Module R M]  (hM : is_noetherian_module R M) (x : List (Submodule R M)) (hx : is_ascending x) :  x ≠ List.nil → ∃ n : ℕ, x.nth_le n hx = x.nth_le (n+1) hx ",
      "(R : Type*) [CommRingₓ R] {M : Type*} [Module R M]  (hM : is_noetherian_module R M) (x : List (Submodule R M)) (hx : is_ascending x) :  x ≠ List.nil → ∃ n : ℕ, x.nth_le n hx = x.nth_le (n+1) hx ",
      "(M : Type*) [AddCommGroup M] [Module ℤ M]  (hn : noetherian ℤ M) : ∀ (X : Set M) (hX : chains.is_upper_bound X) (hX_chain : ∀ N ∈ X,  chains.is_upper_bound (λ (Z : Set M), ∃ {m : M} (h : m ∈ N), Z = ⋃ i, (λ n:ℕ, n • m) '' { n | n ≤ i } )) (hX_in_X : X ⊆ chains.powerset M),  ∃",
      "(M : Type*) [AddCommGroupₓₓ M] [Module ℤ M]  (hn : noetherian ℤ M) : ∀ (X : Set M) (hX : chains.is_upper_bound X) (hX_chain : ∀ N ∈ X,  chains.is_upper_bound (λ (Z : Set M), ∃ {m : M} (h : m ∈ N), Z = ⋃ i, (λ n:ℕ, n • m) '' { n | n ≤ i } )) (hX_in_X : X ⊆ chains.powerset M),  ∃",
      "(M : Type*) [AddCommGroup M] [Module ℤ M]  (hn : noetherian ℤ M) : ∀ (X : Setₓ M) (hX : chains.is_upper_bound X) (hX_chain : ∀ N ∈ X,  chains.is_upper_bound (λ (Z : Setₓ M), ∃ {m : M} (h : m ∈ N), Z = ⋃ i, (λ n:ℕ, n • m) '' { n | n ≤ i } )) (hX_in_X : X ⊆ chains.powerset M),  ∃",
      "(M : Type*) [AddCommGroupₓₓ M] [Module ℤ M]  (hn : noetherian ℤ M) : ∀ (X : Setₓ M) (hX : chains.is_upper_bound X) (hX_chain : ∀ N ∈ X,  chains.is_upper_bound (λ (Z : Setₓ M), ∃ {m : M} (h : m ∈ N), Z = ⋃ i, (λ n:ℕ, n • m) '' { n | n ≤ i } )) (hX_in_X : X ⊆ chains.powerset M),  ∃",
      "(M : Type*) [AddCommGroupₓ M] [Module ℤ M]  (hn : noetherian ℤ M) : ∀ (X : Set M) (hX : chains.is_upper_bound X) (hX_chain : ∀ N ∈ X,  chains.is_upper_bound (λ (Z : Set M), ∃ {m : M} (h : m ∈ N), Z = ⋃ i, (λ n:ℕ, n • m) '' { n | n ≤ i } )) (hX_in_X : X ⊆ chains.powerset M),  ∃",
      "(M : Type*) [AddCommGroupₓ M] [Module ℤ M]  (hn : noetherian ℤ M) : ∀ (X : Setₓ M) (hX : chains.is_upper_bound X) (hX_chain : ∀ N ∈ X,  chains.is_upper_bound (λ (Z : Setₓ M), ∃ {m : M} (h : m ∈ N), Z = ⋃ i, (λ n:ℕ, n • m) '' { n | n ≤ i } )) (hX_in_X : X ⊆ chains.powerset M),  ∃"
    ],
    "answer": "{R M : Type _} [Ringₓ R] [AddCommMonoidₓ M] [Module R M] : IsNoetherian R M → ∀ (f : ℕ →o Submodule R M), ∃ n : ℕ, ∀ m : ℕ, n < m → f n = f m "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "noetherian_implies_ascending_chain_condition",
      "main_prompt": "Every ascending chain of sub-modules of a Noetherian module eventually stabilises.",
      "prompt": "Natural language version: \"A module is Noetherian iff every increasing chain of submodules stabilizes.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] :\n(∀ (f : ℕ →o submodule R M), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m) ↔ is_noetherian R M := \n\nNatural language version: \"A module is Artinian iff every decreasing chain of submodules stabilizes.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] :\n(∀ (f : ℕ →o (submodule R M)ᵒᵈ), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m) ↔ is_artinian R M := \n\nNatural language version: \"A generalization of the theorem that if `N` is a submodule of `M` and  `N` and `M / N` are both Noetherian, then `M` is Noetherian.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} [lattice α] [is_modular_lattice α] {β : Type u_2} {γ : Type u_3} [preorder β] [partial_order γ] (h₁ : well_founded gt) (h₂ : well_founded gt) (K : α) (f₁ : β → α) (f₂ : α → β) (g₁ : γ → α) (g₂ : α → γ) (gci : galois_coinsertion f₁ f₂) (gi : galois_insertion g₂ g₁) (hf : ∀ (a : α), f₁ (f₂ a) = a ⊓ K) (hg : ∀ (a : α), g₁ (g₂ a) = a ⊔ K) :\nwell_founded gt := \n\nNatural language version: \"An R-module is Noetherian iff all its submodules are finitely-generated.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] :\nis_noetherian R M ↔ ∀ (s : submodule R M), s.fg := \n\nNatural language version: \"Every ascending chain of sub-modules of a Noetherian module eventually stabilises.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.9016166925430298,
          "doc_string": "A module is Noetherian iff every increasing chain of submodules stabilizes.",
          "statement": "theorem monotone_stabilizes_iff_noetherian {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] : (∀ (f : ℕ →o submodule R M), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m) ↔ is_noetherian R M"
        },
        {
          "sim_score": 0.7797067761421204,
          "doc_string": "A module is Artinian iff every decreasing chain of submodules stabilizes.",
          "statement": "theorem monotone_stabilizes_iff_artinian {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] : (∀ (f : ℕ →o (submodule R M)ᵒᵈ), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m) ↔ is_artinian R M"
        },
        {
          "sim_score": 0.698657751083374,
          "doc_string": "A generalization of the theorem that if `N` is a submodule of `M` and  `N` and `M / N` are both Noetherian, then `M` is Noetherian.",
          "statement": "theorem well_founded_gt_exact_sequence {α : Type u_1} [lattice α] [is_modular_lattice α] {β : Type u_2} {γ : Type u_3} [preorder β] [partial_order γ] (h₁ : well_founded gt) (h₂ : well_founded gt) (K : α) (f₁ : β → α) (f₂ : α → β) (g₁ : γ → α) (g₂ : α → γ) (gci : galois_coinsertion f₁ f₂) (gi : galois_insertion g₂ g₁) (hf : ∀ (a : α), f₁ (f₂ a) = a ⊓ K) (hg : ∀ (a : α), g₁ (g₂ a) = a ⊔ K) : well_founded gt"
        },
        {
          "sim_score": 0.6557018756866455,
          "doc_string": "An R-module is Noetherian iff all its submodules are finitely-generated.",
          "statement": "theorem is_noetherian_def {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] : is_noetherian R M ↔ ∀ (s : submodule R M), s.fg"
        }
      ],
      "codex_time": 11.324376939010108,
      "search_time": 1.4521226090146229,
      "use_theorem_name": false
    },
    "outputs": [
      "{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoid M] [Module R M] (h : IsNoetherian R M) (f : ℕ →o Submodule R M) : ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m ",
      "{R : Type u_1} {M : Type u_2} [Semiringₓ R] [AddCommMonoid M] [Module R M] (h : IsNoetherian R M) (f : ℕ →o Submodule R M) : ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m ",
      "{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoidₓ M] [Module R M] (h : IsNoetherian R M) (f : ℕ →o Submodule R M) : ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m ",
      "{R : Type u_1} {M : Type u_2} [Semiringₓ R] [AddCommMonoidₓ M] [Module R M] (h : IsNoetherian R M) (f : ℕ →o Submodule R M) : ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m ",
      "{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoid M] [Module R M] : IsNoetherian R M → ∀ (f : ℕ →o Submodule R M), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m ",
      "{R : Type u_1} {M : Type u_2} [Semiringₓ R] [AddCommMonoid M] [Module R M] : IsNoetherian R M → ∀ (f : ℕ →o Submodule R M), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m ",
      "{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoidₓ M] [Module R M] : IsNoetherian R M → ∀ (f : ℕ →o Submodule R M), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m ",
      "{R : Type u_1} {M : Type u_2} [Semiringₓ R] [AddCommMonoidₓ M] [Module R M] : IsNoetherian R M → ∀ (f : ℕ →o Submodule R M), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m ",
      "{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoid M] [Module R M] (h : IsNoetherian R M) (f : ℕ → Submodule R M) : ∃ (n : ℕ) (x y : Submodule R M), ∀ (m : ℕ), n ≤ m → x = y ",
      "{R : Type u_1} {M : Type u_2} [Semiringₓ R] [AddCommMonoid M] [Module R M] (h : IsNoetherian R M) (f : ℕ → Submodule R M) : ∃ (n : ℕ) (x y : Submodule R M), ∀ (m : ℕ), n ≤ m → x = y ",
      "{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoidₓ M] [Module R M] (h : IsNoetherian R M) (f : ℕ → Submodule R M) : ∃ (n : ℕ) (x y : Submodule R M), ∀ (m : ℕ), n ≤ m → x = y ",
      "{R : Type u_1} {M : Type u_2} [Semiringₓ R] [AddCommMonoidₓ M] [Module R M] (h : IsNoetherian R M) (f : ℕ → Submodule R M) : ∃ (n : ℕ) (x y : Submodule R M), ∀ (m : ℕ), n ≤ m → x = y ",
      "{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoid M] [Module R M] (f : ℕ →o Submodule R M) (hf : ∀ (d : ℕ), (f d).fg) : ¬({n : ℕ // f n < f (n + 1)} ≠ ∅)  Natural language version: \"Every descending chain of sub-modules of an Artinian Module eventually stabilises.\" Translate the natural language version to a Lean mathlib version:  theorem {R : Type u_1} {M : Type u_2} [Semiring R",
      "{R : Type u_1} {M : Type u_2} [Semiringₓ R] [AddCommMonoid M] [Module R M] (f : ℕ →o Submodule R M) (hf : ∀ (d : ℕ), (f d).fg) : ¬({n : ℕ // f n < f (n + 1)} ≠ ∅)  Natural language version: \"Every descending chain of sub-modules of an Artinian Module eventually stabilises.\" Translate the natural language version to a Lean mathlib version:  theorem {R : Type u_1} {M : Type u_2} [Semiringₓ R",
      "{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoidₓ M] [Module R M] (f : ℕ →o Submodule R M) (hf : ∀ (d : ℕ), (f d).fg) : ¬({n : ℕ // f n < f (n + 1)} ≠ ∅)  Natural language version: \"Every descending chain of sub-modules of an Artinian Module eventually stabilises.\" Translate the natural language version to a Lean mathlib version:  theorem {R : Type u_1} {M : Type u_2} [Semiring R",
      "{R : Type u_1} {M : Type u_2} [Semiringₓ R] [AddCommMonoidₓ M] [Module R M] (f : ℕ →o Submodule R M) (hf : ∀ (d : ℕ), (f d).fg) : ¬({n : ℕ // f n < f (n + 1)} ≠ ∅)  Natural language version: \"Every descending chain of sub-modules of an Artinian Module eventually stabilises.\" Translate the natural language version to a Lean mathlib version:  theorem {R : Type u_1} {M : Type u_2} [Semiringₓ R",
      "{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoid M] [Module R M] (h : IsNoetherian R M) (f : ℕ →o Submodule R M) : ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m ",
      "{R : Type u_1} {M : Type u_2} [Semiringₓ R] [AddCommMonoid M] [Module R M] (h : IsNoetherian R M) (f : ℕ →o Submodule R M) : ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m ",
      "{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoidₓ M] [Module R M] (h : IsNoetherian R M) (f : ℕ →o Submodule R M) : ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m ",
      "{R : Type u_1} {M : Type u_2} [Semiringₓ R] [AddCommMonoidₓ M] [Module R M] (h : IsNoetherian R M) (f : ℕ →o Submodule R M) : ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m "
    ],
    "answer": "{R M : Type _} [Ringₓ R] [AddCommMonoidₓ M] [Module R M] : IsNoetherian R M → ∀ (f : ℕ →o Submodule R M), ∃ n : ℕ, ∀ m : ℕ, n < m → f n = f m "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "noetherian_implies_ascending_chain_condition",
      "main_prompt": "Every ascending chain of sub-modules of a Noetherian module eventually stabilises.",
      "prompt": "Natural language version: \"Every ascending chain of sub-modules of a Noetherian module eventually stabilises.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 8.207776368013583,
      "use_theorem_name": false
    },
    "outputs": [
      "ascending_chain_of_submodule_of_Noetherian_module_eventually_stabilises' (R : Type*) [CommRing R]    (a : Set R) (M : Type*) [AddCommGroup M] [Module R M] (H : noetherian (submodule.subtype R a M)) :    ∀ c : Type u, Cardinal.mk c → ∃ c : Set (submodule.subtype R a M), ∀ d : Set (submodule.subtype R a M), c ⊆ d →    d ∈ fin_submodules_of_submodule_of_Noether",
      "ascending_chain_of_submodule_of_Noetherian_module_eventually_stabilises' (R : Type*) [CommRing R]    (a : Set R) (M : Type*) [AddCommGroupₓₓ M] [Module R M] (H : noetherian (submodule.subtype R a M)) :    ∀ c : Type u, Cardinal.mk c → ∃ c : Set (submodule.subtype R a M), ∀ d : Set (submodule.subtype R a M), c ⊆ d →    d ∈ fin_submodules_of_submodule_of_Noether",
      "ascending_chain_of_submodule_of_Noetherian_module_eventually_stabilises' (R : Type*) [CommRingₓₓ R]    (a : Set R) (M : Type*) [AddCommGroup M] [Module R M] (H : noetherian (submodule.subtype R a M)) :    ∀ c : Type u, Cardinal.mk c → ∃ c : Set (submodule.subtype R a M), ∀ d : Set (submodule.subtype R a M), c ⊆ d →    d ∈ fin_submodules_of_submodule_of_Noether",
      "ascending_chain_of_submodule_of_Noetherian_module_eventually_stabilises' (R : Type*) [CommRingₓₓ R]    (a : Set R) (M : Type*) [AddCommGroupₓₓ M] [Module R M] (H : noetherian (submodule.subtype R a M)) :    ∀ c : Type u, Cardinal.mk c → ∃ c : Set (submodule.subtype R a M), ∀ d : Set (submodule.subtype R a M), c ⊆ d →    d ∈ fin_submodules_of_submodule_of_Noether",
      "ascending_chain_of_submodule_of_Noetherian_module_eventually_stabilises' (R : Type*) [CommRing R]    (a : Setₓ R) (M : Type*) [AddCommGroup M] [Module R M] (H : noetherian (submodule.subtype R a M)) :    ∀ c : Type u, Cardinal.mk c → ∃ c : Setₓ (submodule.subtype R a M), ∀ d : Setₓ (submodule.subtype R a M), c ⊆ d →    d ∈ fin_submodules_of_submodule_of_Noether",
      "ascending_chain_of_submodule_of_Noetherian_module_eventually_stabilises' (R : Type*) [CommRing R]    (a : Setₓ R) (M : Type*) [AddCommGroupₓₓ M] [Module R M] (H : noetherian (submodule.subtype R a M)) :    ∀ c : Type u, Cardinal.mk c → ∃ c : Setₓ (submodule.subtype R a M), ∀ d : Setₓ (submodule.subtype R a M), c ⊆ d →    d ∈ fin_submodules_of_submodule_of_Noether",
      "ascending_chain_of_submodule_of_Noetherian_module_eventually_stabilises' (R : Type*) [CommRingₓₓ R]    (a : Setₓ R) (M : Type*) [AddCommGroup M] [Module R M] (H : noetherian (submodule.subtype R a M)) :    ∀ c : Type u, Cardinal.mk c → ∃ c : Setₓ (submodule.subtype R a M), ∀ d : Setₓ (submodule.subtype R a M), c ⊆ d →    d ∈ fin_submodules_of_submodule_of_Noether",
      "ascending_chain_of_submodule_of_Noetherian_module_eventually_stabilises' (R : Type*) [CommRingₓₓ R]    (a : Setₓ R) (M : Type*) [AddCommGroupₓₓ M] [Module R M] (H : noetherian (submodule.subtype R a M)) :    ∀ c : Type u, Cardinal.mk c → ∃ c : Setₓ (submodule.subtype R a M), ∀ d : Setₓ (submodule.subtype R a M), c ⊆ d →    d ∈ fin_submodules_of_submodule_of_Noether",
      "ascending_chain_of_submodule_of_Noetherian_module_eventually_stabilises' (R : Type*) [CommRing R]    (a : Set R) (M : Type*) [AddCommGroupₓ M] [Module R M] (H : noetherian (submodule.subtype R a M)) :    ∀ c : Type u, Cardinal.mk c → ∃ c : Set (submodule.subtype R a M), ∀ d : Set (submodule.subtype R a M), c ⊆ d →    d ∈ fin_submodules_of_submodule_of_Noether",
      "ascending_chain_of_submodule_of_Noetherian_module_eventually_stabilises' (R : Type*) [CommRingₓₓ R]    (a : Set R) (M : Type*) [AddCommGroupₓ M] [Module R M] (H : noetherian (submodule.subtype R a M)) :    ∀ c : Type u, Cardinal.mk c → ∃ c : Set (submodule.subtype R a M), ∀ d : Set (submodule.subtype R a M), c ⊆ d →    d ∈ fin_submodules_of_submodule_of_Noether",
      "ascending_chain_of_submodule_of_Noetherian_module_eventually_stabilises' (R : Type*) [CommRing R]    (a : Setₓ R) (M : Type*) [AddCommGroupₓ M] [Module R M] (H : noetherian (submodule.subtype R a M)) :    ∀ c : Type u, Cardinal.mk c → ∃ c : Setₓ (submodule.subtype R a M), ∀ d : Setₓ (submodule.subtype R a M), c ⊆ d →    d ∈ fin_submodules_of_submodule_of_Noether",
      "ascending_chain_of_submodule_of_Noetherian_module_eventually_stabilises' (R : Type*) [CommRingₓₓ R]    (a : Setₓ R) (M : Type*) [AddCommGroupₓ M] [Module R M] (H : noetherian (submodule.subtype R a M)) :    ∀ c : Type u, Cardinal.mk c → ∃ c : Setₓ (submodule.subtype R a M), ∀ d : Setₓ (submodule.subtype R a M), c ⊆ d →    d ∈ fin_submodules_of_submodule_of_Noether",
      "ascending_chain_of_submodule_of_Noetherian_module_eventually_stabilises' (R : Type*) [CommRingₓ R]    (a : Set R) (M : Type*) [AddCommGroup M] [Module R M] (H : noetherian (submodule.subtype R a M)) :    ∀ c : Type u, Cardinal.mk c → ∃ c : Set (submodule.subtype R a M), ∀ d : Set (submodule.subtype R a M), c ⊆ d →    d ∈ fin_submodules_of_submodule_of_Noether",
      "ascending_chain_of_submodule_of_Noetherian_module_eventually_stabilises' (R : Type*) [CommRingₓ R]    (a : Set R) (M : Type*) [AddCommGroupₓₓ M] [Module R M] (H : noetherian (submodule.subtype R a M)) :    ∀ c : Type u, Cardinal.mk c → ∃ c : Set (submodule.subtype R a M), ∀ d : Set (submodule.subtype R a M), c ⊆ d →    d ∈ fin_submodules_of_submodule_of_Noether",
      "ascending_chain_of_submodule_of_Noetherian_module_eventually_stabilises' (R : Type*) [CommRingₓ R]    (a : Setₓ R) (M : Type*) [AddCommGroup M] [Module R M] (H : noetherian (submodule.subtype R a M)) :    ∀ c : Type u, Cardinal.mk c → ∃ c : Setₓ (submodule.subtype R a M), ∀ d : Setₓ (submodule.subtype R a M), c ⊆ d →    d ∈ fin_submodules_of_submodule_of_Noether",
      "ascending_chain_of_submodule_of_Noetherian_module_eventually_stabilises' (R : Type*) [CommRingₓ R]    (a : Setₓ R) (M : Type*) [AddCommGroupₓₓ M] [Module R M] (H : noetherian (submodule.subtype R a M)) :    ∀ c : Type u, Cardinal.mk c → ∃ c : Setₓ (submodule.subtype R a M), ∀ d : Setₓ (submodule.subtype R a M), c ⊆ d →    d ∈ fin_submodules_of_submodule_of_Noether",
      "ascending_chain_of_submodule_of_Noetherian_module_eventually_stabilises' (R : Type*) [CommRingₓ R]    (a : Set R) (M : Type*) [AddCommGroupₓ M] [Module R M] (H : noetherian (submodule.subtype R a M)) :    ∀ c : Type u, Cardinal.mk c → ∃ c : Set (submodule.subtype R a M), ∀ d : Set (submodule.subtype R a M), c ⊆ d →    d ∈ fin_submodules_of_submodule_of_Noether",
      "ascending_chain_of_submodule_of_Noetherian_module_eventually_stabilises' (R : Type*) [CommRingₓ R]    (a : Setₓ R) (M : Type*) [AddCommGroupₓ M] [Module R M] (H : noetherian (submodule.subtype R a M)) :    ∀ c : Type u, Cardinal.mk c → ∃ c : Setₓ (submodule.subtype R a M), ∀ d : Setₓ (submodule.subtype R a M), c ⊆ d →    d ∈ fin_submodules_of_submodule_of_Noether",
      "Noetherian.ascending_chain_stabilises {R : Type*} [CommRing R] {M : Type*} [AddCommGroup M] [Module R M] [is_Noetherian R M] (c : chain (Submodule R M)) : is_strictly_ascending R c → False ",
      "Noetherian.ascending_chain_stabilises {R : Type*} [CommRing R] {M : Type*} [AddCommGroupₓₓ M] [Module R M] [is_Noetherian R M] (c : chain (Submodule R M)) : is_strictly_ascending R c → False ",
      "Noetherian.ascending_chain_stabilises {R : Type*} [CommRingₓₓ R] {M : Type*} [AddCommGroup M] [Module R M] [is_Noetherian R M] (c : chain (Submodule R M)) : is_strictly_ascending R c → False ",
      "Noetherian.ascending_chain_stabilises {R : Type*} [CommRingₓₓ R] {M : Type*} [AddCommGroupₓₓ M] [Module R M] [is_Noetherian R M] (c : chain (Submodule R M)) : is_strictly_ascending R c → False ",
      "Noetherian.ascending_chain_stabilises {R : Type*} [CommRing R] {M : Type*} [AddCommGroupₓ M] [Module R M] [is_Noetherian R M] (c : chain (Submodule R M)) : is_strictly_ascending R c → False ",
      "Noetherian.ascending_chain_stabilises {R : Type*} [CommRingₓₓ R] {M : Type*} [AddCommGroupₓ M] [Module R M] [is_Noetherian R M] (c : chain (Submodule R M)) : is_strictly_ascending R c → False ",
      "Noetherian.ascending_chain_stabilises {R : Type*} [CommRingₓ R] {M : Type*} [AddCommGroup M] [Module R M] [is_Noetherian R M] (c : chain (Submodule R M)) : is_strictly_ascending R c → False ",
      "Noetherian.ascending_chain_stabilises {R : Type*} [CommRingₓ R] {M : Type*} [AddCommGroupₓₓ M] [Module R M] [is_Noetherian R M] (c : chain (Submodule R M)) : is_strictly_ascending R c → False ",
      "Noetherian.ascending_chain_stabilises {R : Type*} [CommRingₓ R] {M : Type*} [AddCommGroupₓ M] [Module R M] [is_Noetherian R M] (c : chain (Submodule R M)) : is_strictly_ascending R c → False ",
      "fn (A : Type) [CommRing A] (M : Type) [Module A M] [noetherian_module A M]      (N : Set M) (hn : is_submodule N M) (hn_nest : ∀ (N' : Set M), is_submodule N' N → N' ≤ N) :      ∃ N' : Set M, is_submodule N' M ∧ N' ≤ N ",
      "fn (A : Type) [CommRingₓₓ A] (M : Type) [Module A M] [noetherian_module A M]      (N : Set M) (hn : is_submodule N M) (hn_nest : ∀ (N' : Set M), is_submodule N' N → N' ≤ N) :      ∃ N' : Set M, is_submodule N' M ∧ N' ≤ N ",
      "fn (A : Type) [CommRing A] (M : Type) [Module A M] [noetherian_module A M]      (N : Setₓ M) (hn : is_submodule N M) (hn_nest : ∀ (N' : Setₓ M), is_submodule N' N → N' ≤ N) :      ∃ N' : Setₓ M, is_submodule N' M ∧ N' ≤ N ",
      "fn (A : Type) [CommRingₓₓ A] (M : Type) [Module A M] [noetherian_module A M]      (N : Setₓ M) (hn : is_submodule N M) (hn_nest : ∀ (N' : Setₓ M), is_submodule N' N → N' ≤ N) :      ∃ N' : Setₓ M, is_submodule N' M ∧ N' ≤ N ",
      "fn (A : Type) [CommRingₓ A] (M : Type) [Module A M] [noetherian_module A M]      (N : Set M) (hn : is_submodule N M) (hn_nest : ∀ (N' : Set M), is_submodule N' N → N' ≤ N) :      ∃ N' : Set M, is_submodule N' M ∧ N' ≤ N ",
      "fn (A : Type) [CommRingₓ A] (M : Type) [Module A M] [noetherian_module A M]      (N : Setₓ M) (hn : is_submodule N M) (hn_nest : ∀ (N' : Setₓ M), is_submodule N' N → N' ≤ N) :      ∃ N' : Setₓ M, is_submodule N' M ∧ N' ≤ N ",
      "every_asc_chain_of_submodules_stabilizes (M : Type) [AddCommGroup M] [Module R M] [noetherian_add M]:   ∀ c : Set (Set M), (∀ Uf T ∈ c, Uf ⊆ T) → ∃ Uf ∈ c, ∀ T ∈ c, Uf ⊆ T ",
      "every_asc_chain_of_submodules_stabilizes (M : Type) [AddCommGroupₓₓ M] [Module R M] [noetherian_add M]:   ∀ c : Set (Set M), (∀ Uf T ∈ c, Uf ⊆ T) → ∃ Uf ∈ c, ∀ T ∈ c, Uf ⊆ T ",
      "every_asc_chain_of_submodules_stabilizes (M : Type) [AddCommGroup M] [Module R M] [noetherian_add M]:   ∀ c : Setₓ (Setₓ M), (∀ Uf T ∈ c, Uf ⊆ T) → ∃ Uf ∈ c, ∀ T ∈ c, Uf ⊆ T ",
      "every_asc_chain_of_submodules_stabilizes (M : Type) [AddCommGroupₓₓ M] [Module R M] [noetherian_add M]:   ∀ c : Setₓ (Setₓ M), (∀ Uf T ∈ c, Uf ⊆ T) → ∃ Uf ∈ c, ∀ T ∈ c, Uf ⊆ T ",
      "every_asc_chain_of_submodules_stabilizes (M : Type) [AddCommGroupₓ M] [Module R M] [noetherian_add M]:   ∀ c : Set (Set M), (∀ Uf T ∈ c, Uf ⊆ T) → ∃ Uf ∈ c, ∀ T ∈ c, Uf ⊆ T ",
      "every_asc_chain_of_submodules_stabilizes (M : Type) [AddCommGroupₓ M] [Module R M] [noetherian_add M]:   ∀ c : Setₓ (Setₓ M), (∀ Uf T ∈ c, Uf ⊆ T) → ∃ Uf ∈ c, ∀ T ∈ c, Uf ⊆ T ",
      "chain_stabilises {R : Type*} [CommRing R] (M : Module R)    (Hnoeth : Noetherian M.to_Module) :  Π s : Set (Submodule M.to_Module), Directed s → chain s → ∃ m ∈ s, ∀ m' ∈ s, m ⊆ m' → m = m'  IsChain, induced_set and chain are defined here:  https://github.com/leanprover/mathlib/blob/master/data/Set/basic.lean#L561  The right proof should be easy:  def chain_stabilises {",
      "chain_stabilises {R : Type*} [CommRingₓₓ R] (M : Module R)    (Hnoeth : Noetherian M.to_Module) :  Π s : Set (Submodule M.to_Module), Directed s → chain s → ∃ m ∈ s, ∀ m' ∈ s, m ⊆ m' → m = m'  IsChain, induced_set and chain are defined here:  https://github.com/leanprover/mathlib/blob/master/data/Set/basic.lean#L561  The right proof should be easy:  def chain_stabilises {",
      "chain_stabilises {R : Type*} [CommRing R] (M : Module R)    (Hnoeth : Noetherian M.to_Module) :  Π s : Setₓ (Submodule M.to_Module), Directed s → chain s → ∃ m ∈ s, ∀ m' ∈ s, m ⊆ m' → m = m'  IsChain, induced_set and chain are defined here:  https://github.com/leanprover/mathlib/blob/master/data/Setₓ/basic.lean#L561  The right proof should be easy:  def chain_stabilises {",
      "chain_stabilises {R : Type*} [CommRingₓₓ R] (M : Module R)    (Hnoeth : Noetherian M.to_Module) :  Π s : Setₓ (Submodule M.to_Module), Directed s → chain s → ∃ m ∈ s, ∀ m' ∈ s, m ⊆ m' → m = m'  IsChain, induced_set and chain are defined here:  https://github.com/leanprover/mathlib/blob/master/data/Setₓ/basic.lean#L561  The right proof should be easy:  def chain_stabilises {",
      "chain_stabilises {R : Type*} [CommRingₓ R] (M : Module R)    (Hnoeth : Noetherian M.to_Module) :  Π s : Set (Submodule M.to_Module), Directed s → chain s → ∃ m ∈ s, ∀ m' ∈ s, m ⊆ m' → m = m'  IsChain, induced_set and chain are defined here:  https://github.com/leanprover/mathlib/blob/master/data/Set/basic.lean#L561  The right proof should be easy:  def chain_stabilises {",
      "chain_stabilises {R : Type*} [CommRingₓ R] (M : Module R)    (Hnoeth : Noetherian M.to_Module) :  Π s : Setₓ (Submodule M.to_Module), Directed s → chain s → ∃ m ∈ s, ∀ m' ∈ s, m ⊆ m' → m = m'  IsChain, induced_set and chain are defined here:  https://github.com/leanprover/mathlib/blob/master/data/Setₓ/basic.lean#L561  The right proof should be easy:  def chain_stabilises {"
    ],
    "answer": "{R M : Type _} [Ringₓ R] [AddCommMonoidₓ M] [Module R M] : IsNoetherian R M → ∀ (f : ℕ →o Submodule R M), ∃ n : ℕ, ∀ m : ℕ, n < m → f n = f m "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "differentiability_implies_continuity",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Differentiability implies continuity.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Differentiability implies continuity.",
      "codex_time": 6.9072370039939415,
      "use_theorem_name": false
    },
    "outputs": [
      "(f : ℝ → ℝ) (hf : times_cont_diff_on ℝ f) :  ContinuousOn ℝ f ",
      "(f : ℝ → ℝ) (hf : deriv f) : Continuous f ",
      "(X : Type*) [TopologicalSpace X] (Y : Type*) [TopologicalSpace Y] {f : X → Y} {a : X}  (hf : DifferentiableAt 𝕜 X Y f a) :  ContinuousAt f a ",
      "{f : E → F}  (hf : DifferentiableAt 𝕜 f a) :  ContinuousAt 𝕜 f a ",
      "(f : ℝ → ℝ) (f' : ℝ → ℝ) (hf' : derivWithin ℝ f f' (Set.Univ)) :  ContinuousOn f (Set.Univ) ",
      "(f : ℝ → ℝ) (f' : ℝ → ℝ) (hf' : derivWithin ℝ f f' (Setₓ.Univ)) :  ContinuousOn f (Setₓ.Univ) "
    ],
    "answer": "[TopologicalSpace ℝ] : ∀ f : ℝ → ℝ, Differentiable ℝ f → Continuous f "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "differentiability_implies_continuity",
      "main_prompt": "Differentiability implies continuity.",
      "prompt": "Natural language version: \"If a function is locally Lipschitz around a point, then it is continuous at this point.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {f : α → β} {x : α} {r : ℝ} (hr : 0 < r) (K : ℝ) (h : ∀ (y : α), has_dist.dist y x < r → has_dist.dist (f y) (f x) ≤ K * has_dist.dist y x) :\ncontinuous_at f x := \n\nNatural language version: \" If a function is differentiable on the right of a point `a : ℝ`, continuous at `a`, and its derivative also converges at `a`, then `f` is differentiable on the right at `a`.\" Translate the natural language version to a Lean mathlib version:\n theorem {E : Type u_1} [normed_group E] [normed_space ℝ E] {s : set ℝ} {e : E} {a : ℝ} {f : ℝ → E} (f_diff : differentiable_on ℝ f s) (f_lim : continuous_within_at f s a) (hs : s ∈ nhds_within a (set.Ioi a)) (f_lim' : filter.tendsto (λ (x : ℝ), deriv f x) (nhds_within a (set.Ioi a)) (nhds e)) :\nhas_deriv_within_at f e (set.Ici a) a := \n\nNatural language version: \" If a function is differentiable on the left of a point `a : ℝ`, continuous at `a`, and its derivative also converges at `a`, then `f` is differentiable on the left at `a`.\" Translate the natural language version to a Lean mathlib version:\n theorem {E : Type u_1} [normed_group E] [normed_space ℝ E] {s : set ℝ} {e : E} {a : ℝ} {f : ℝ → E} (f_diff : differentiable_on ℝ f s) (f_lim : continuous_within_at f s a) (hs : s ∈ nhds_within a (set.Iio a)) (f_lim' : filter.tendsto (λ (x : ℝ), deriv f x) (nhds_within a (set.Iio a)) (nhds e)) :\nhas_deriv_within_at f e (set.Iic a) a := \n\nNatural language version: \"A Lipschitz function is continuous\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {K : nnreal} {f : α → β} (hf : lipschitz_with K f) :\ncontinuous f := \n\nNatural language version: \"Differentiability implies continuity.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6264367699623108,
          "doc_string": "If a function is locally Lipschitz around a point, then it is continuous at this point.",
          "statement": "theorem continuous_at_of_locally_lipschitz {α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {f : α → β} {x : α} {r : ℝ} (hr : 0 < r) (K : ℝ) (h : ∀ (y : α), has_dist.dist y x < r → has_dist.dist (f y) (f x) ≤ K * has_dist.dist y x) : continuous_at f x"
        },
        {
          "sim_score": 0.6016049981117249,
          "doc_string": " If a function is differentiable on the right of a point `a : ℝ`, continuous at `a`, and its derivative also converges at `a`, then `f` is differentiable on the right at `a`.",
          "statement": "theorem has_deriv_at_interval_left_endpoint_of_tendsto_deriv {E : Type u_1} [normed_group E] [normed_space ℝ E] {s : set ℝ} {e : E} {a : ℝ} {f : ℝ → E} (f_diff : differentiable_on ℝ f s) (f_lim : continuous_within_at f s a) (hs : s ∈ nhds_within a (set.Ioi a)) (f_lim' : filter.tendsto (λ (x : ℝ), deriv f x) (nhds_within a (set.Ioi a)) (nhds e)) : has_deriv_within_at f e (set.Ici a) a"
        },
        {
          "sim_score": 0.5962556600570679,
          "doc_string": " If a function is differentiable on the left of a point `a : ℝ`, continuous at `a`, and its derivative also converges at `a`, then `f` is differentiable on the left at `a`.",
          "statement": "theorem has_deriv_at_interval_right_endpoint_of_tendsto_deriv {E : Type u_1} [normed_group E] [normed_space ℝ E] {s : set ℝ} {e : E} {a : ℝ} {f : ℝ → E} (f_diff : differentiable_on ℝ f s) (f_lim : continuous_within_at f s a) (hs : s ∈ nhds_within a (set.Iio a)) (f_lim' : filter.tendsto (λ (x : ℝ), deriv f x) (nhds_within a (set.Iio a)) (nhds e)) : has_deriv_within_at f e (set.Iic a) a"
        },
        {
          "sim_score": 0.5795943737030029,
          "doc_string": "A Lipschitz function is continuous",
          "statement": "theorem lipschitz_with.continuous {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {K : nnreal} {f : α → β} (hf : lipschitz_with K f) : continuous f"
        }
      ],
      "codex_time": 13.302136803016765,
      "search_time": 1.4399381499970332,
      "use_theorem_name": false
    },
    "outputs": [
      "{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {s : Set ℝ} {a : ℝ} {f : ℝ → E} (f_diff : DifferentiableOn ℝ f s) (ha : a ∈ s) : ContinuousOn ℝ f (Set.Icc a a) ",
      "{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {s : Setₓ ℝ} {a : ℝ} {f : ℝ → E} (f_diff : DifferentiableOn ℝ f s) (ha : a ∈ s) : ContinuousOn ℝ f (Setₓ.Icc a a) ",
      "{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {f : ℝ → E} {a : ℝ} (hf : DifferentiableAt ℝ f a) : ContinuousAt f a ",
      "{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {s : Set ℝ} {a : ℝ} {f : ℝ → E} (hf : ∀ (x : ℝ), x ∈ s → HasDerivAt f (f x)) (hs : IsOpen s) (hf' : continuous_restrict (Finsupp.total (univ : Finset ℝ) f) s) : Continuous (Finsupp.total (univ : Finset ℝ) f) ",
      "{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {s : Setₓ ℝ} {a : ℝ} {f : ℝ → E} (hf : ∀ (x : ℝ), x ∈ s → HasDerivAt f (f x)) (hs : IsOpen s) (hf' : continuous_restrict (Finsupp.total (univ : Finset ℝ) f) s) : Continuous (Finsupp.total (univ : Finset ℝ) f) ",
      "{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {a : ℝ} {f : ℝ → E} (hn : is_deriv_at f a) : ContinuousAt f a ",
      "{α : Type u} [TopologicalSpace α] [MetricSpace α] {β : Type v} {f : α → β} {x : α} (hf : DifferentiableAt α β f x) : ContinuousAt f x "
    ],
    "answer": "[TopologicalSpace ℝ] : ∀ f : ℝ → ℝ, Differentiable ℝ f → Continuous f "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "differentiability_implies_continuity",
      "main_prompt": "Differentiability implies continuity.",
      "prompt": "Natural language version: \"Differentiability implies continuity.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 9.579682253010105,
      "use_theorem_name": false
    },
    "outputs": [
      "diff_to_cont : Differentiable α β ι f → Continuous α β f ",
      "differentiable_imp_continuous_at_within (s : Set E) (f : E → F) (x : E) (df : E → F) :    differentiable_at_within f x s df → continuous_at_within f x s ",
      "differentiable_imp_continuous_at_within (s : Setₓ E) (f : E → F) (x : E) (df : E → F) :    differentiable_at_within f x s df → continuous_at_within f x s ",
      "differentiability_imp_continuity (f : ℝ → ℝ) {x : ℝ} (hf : DifferentiableAt f x) : ContinuousAt f x ",
      "diff_imp_cont' {f : ℝ → ℝ} {a : ℝ} (hfderiv : Differentiable f a) : Continuous f a. done) end  ----  -- (You could probably show the other way here too but the first One is better)  /-  ## 13. For all x, ∀ x, f′(x) ≥ 0 → f(x) ≥ f(0)  -/  section thirteenth  theorem allx_diffgeq0impliesfxgeq0 (f : ℝ → ℝ) (hfderiv : ∀ x, f'",
      "f_differentiable_at_some_x_impl_continuous_at_x (f : ℝ → ℝ) (hb : b > a) :    ((∃ h : DifferentiableAt ℝ f (at_right a hb), True) →  bdd_above_on f (Ioc a hb)) "
    ],
    "answer": "[TopologicalSpace ℝ] : ∀ f : ℝ → ℝ, Differentiable ℝ f → Continuous f "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "angle_sum_pi",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"The angles of a triangle add up to two right angles.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The angles of a triangle add up to two right angles.",
      "codex_time": 6.153305271000136,
      "use_theorem_name": false
    },
    "outputs": [
      ": ∀ (α β γ : angle (𝐙/4)), α + β + γ = 2 * 𝐑 ",
      "(α β γ : angle)  (hα : angle.is_right α) (hβ : angle.is_half_pi β) (hγ : angle.is_half_pi γ) :  angle.add α (angle.add β γ) = angle.right ",
      "(a b c : ℝ) (h_cos₁ : -1 ≤ cos a) (h_cos₂ : -1 ≤ cos b) (h_cos₃ : -1 ≤ cos c)  (h_cos₁_le : cos a ≤ 1) (h_cos₂_le : cos b ≤ 1) (h_cos₃_le : cos c ≤ 1) :  a + b + c = 2* π ",
      "(a b c : ℝ) (h : (a > 0) ∧ (b > 0) ∧ (c > 0) ∧  (a + b > c) ∧ (b + c > a) ∧ (c + a > b)) :  a + b + c = π ",
      "(a b c : ℝ) (h : a ^ 2 + b ^ 2 = c ^ 2) : b = a*c + b*c → a + b = c "
    ],
    "answer": "{p q r : EuclideanSpace ℝ (Finₓ 2)} : EuclideanGeometry.angle p q r + EuclideanGeometry.angle q r p + EuclideanGeometry.angle r p q = Real.pi "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "angle_sum_pi",
      "main_prompt": "The angles of a triangle add up to two right angles.",
      "prompt": "Natural language version: \" If the angle between two vectors is π, the angles between those vectors and a third vector add to π.\" Translate the natural language version to a Lean mathlib version:\n theorem {V : Type u_1} [inner_product_space ℝ V] {x y : V} (z : V) (h : inner_product_geometry.angle x y = real.pi) :\ninner_product_geometry.angle x z + inner_product_geometry.angle y z = real.pi := \n\nNatural language version: \" Vertical Angles Theorem: angles opposite each other, formed by two intersecting straight lines, are equal.\" Translate the natural language version to a Lean mathlib version:\n theorem {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 p4 p5 : P} (hapc : euclidean_geometry.angle p1 p5 p3 = real.pi) (hbpd : euclidean_geometry.angle p2 p5 p4 = real.pi) :\neuclidean_geometry.angle p1 p5 p2 = euclidean_geometry.angle p3 p5 p4 := \n\nNatural language version: \" Given three nonzero vectors, adding the angles between them in cyclic order, with the second vector in each angle negated, results in π. If the vectors add to 0, this is a version of the sum of the angles of a triangle.\" Translate the natural language version to a Lean mathlib version:\n theorem {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) :\nhb.oangle x (-y) + hb.oangle y (-z) + hb.oangle z (-x) = ↑real.pi := \n\nNatural language version: \" Given three nonzero vectors, adding the angles between them in cyclic order, with the second vector in each angle negated, results in π. If the vectors add to 0, this is a version of the sum of the angles of a triangle.\" Translate the natural language version to a Lean mathlib version:\n theorem {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) :\no.oangle x (-y) + o.oangle y (-z) + o.oangle z (-x) = ↑real.pi := \n\nNatural language version: \"The angles of a triangle add up to two right angles.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5743768215179443,
          "doc_string": " If the angle between two vectors is π, the angles between those vectors and a third vector add to π.",
          "statement": "theorem inner_product_geometry.angle_add_angle_eq_pi_of_angle_eq_pi {V : Type u_1} [inner_product_space ℝ V] {x y : V} (z : V) (h : inner_product_geometry.angle x y = real.pi) : inner_product_geometry.angle x z + inner_product_geometry.angle y z = real.pi"
        },
        {
          "sim_score": 0.5685725212097168,
          "doc_string": " Vertical Angles Theorem: angles opposite each other, formed by two intersecting straight lines, are equal.",
          "statement": "theorem euclidean_geometry.angle_eq_angle_of_angle_eq_pi_of_angle_eq_pi {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 p4 p5 : P} (hapc : euclidean_geometry.angle p1 p5 p3 = real.pi) (hbpd : euclidean_geometry.angle p2 p5 p4 = real.pi) : euclidean_geometry.angle p1 p5 p2 = euclidean_geometry.angle p3 p5 p4"
        },
        {
          "sim_score": 0.5616596937179565,
          "doc_string": " Given three nonzero vectors, adding the angles between them in cyclic order, with the second vector in each angle negated, results in π. If the vectors add to 0, this is a version of the sum of the angles of a triangle.",
          "statement": "theorem orthonormal.oangle_add_cyc3_neg_right {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle x (-y) + hb.oangle y (-z) + hb.oangle z (-x) = ↑real.pi"
        },
        {
          "sim_score": 0.5616596937179565,
          "doc_string": " Given three nonzero vectors, adding the angles between them in cyclic order, with the second vector in each angle negated, results in π. If the vectors add to 0, this is a version of the sum of the angles of a triangle.",
          "statement": "theorem orientation.oangle_add_cyc3_neg_right {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle x (-y) + o.oangle y (-z) + o.oangle z (-x) = ↑real.pi"
        }
      ],
      "codex_time": 11.767082732985727,
      "search_time": 1.4687023029837292,
      "use_theorem_name": false
    },
    "outputs": [
      "{V : Type u_1} [InnerProductSpace ℝ V] {x y z : V} (h : InnerProductGeometry.angle x y + InnerProductGeometry.angle y z + InnerProductGeometry.angle z x = 2 * Real.pi) : True ",
      "{V : Type u_1} [InnerProductSpace ℝ V] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] {o : Orientation ℝ V (Fin 2)} {p1 p2 p3 : V} (h1 : angle p1 p2 p3 < angle p2 p3 p1) : o.oangle p1 p2 + o.oangle p2 p3 + o.oangle p3 p1 = 2 ",
      "{V : Type u_1} [InnerProductSpace ℝ V] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] {o : Orientation ℝ V (Finₓ 2)} {p1 p2 p3 : V} (h1 : angle p1 p2 p3 < angle p2 p3 p1) : o.oangle p1 p2 + o.oangle p2 p3 + o.oangle p3 p1 = 2 ",
      "{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : hb.oangle x (hb.orthoproj (x + y)) + hb.oangle y (-hb.orthoproj (x + y)) = ↑Real.pi ",
      "{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Finₓ 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : hb.oangle x (hb.orthoproj (x + y)) + hb.oangle y (-hb.orthoproj (x + y)) = ↑Real.pi ",
      "{V : Type u_1} [InnerProductSpace ℝ V] [hd3 : Fact (FiniteDimensional.finrank ℝ V = 3)] (o : Orientation ℝ V (Fin 3)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle x y + o.oangle y z + o.oangle z x = ↑Real.pi * 2 ",
      "{V : Type u_1} [InnerProductSpace ℝ V] [hd3 : Fact (FiniteDimensional.finrank ℝ V = 3)] (o : Orientation ℝ V (Finₓ 3)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle x y + o.oangle y z + o.oangle z x = ↑Real.pi * 2 ",
      "{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [NormedAddTorsor V P] {p1 p2 p3 p5 : P} : 2*EuclideanGeometry.angle p1 p5 p3 + 2*EuclideanGeometry.angle p2 p5 p3 + 2*EuclideanGeometry.angle p1 p5 p2 = 2*Real.pi "
    ],
    "answer": "{p q r : EuclideanSpace ℝ (Finₓ 2)} : EuclideanGeometry.angle p q r + EuclideanGeometry.angle q r p + EuclideanGeometry.angle r p q = Real.pi "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "angle_sum_pi",
      "main_prompt": "The angles of a triangle add up to two right angles.",
      "prompt": "Natural language version: \"The angles of a triangle add up to two right angles.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 8.175744519016007,
      "use_theorem_name": false
    },
    "outputs": [
      "Q212142 (A B C : Type*) (a : line A) (b : line B) (c : line C) [incident a.1 b.1 c.1] [incident b.1 c.1 a.1] [incident c.1 a.1 b.1]: True ",
      "sum_of_angles_is_180_degrees :    ∀ A B C : triangle,     angle A + angle B + angle C = 2 * (∀α : angle, is_right α) ",
      "triangle_or_rigth ( a b c : ℝ ) : is_triangle a b c ∨ is_right a b c ",
      "Nat lang : ∀ (a b c : ℝ), a^2 + b^2 = c^2 ↔ a + b + c = pi ",
      "add_angles_eq_two_right_angles : ∀ (A B C : angle), A + B + C = two_right_angles "
    ],
    "answer": "{p q r : EuclideanSpace ℝ (Finₓ 2)} : EuclideanGeometry.angle p q r + EuclideanGeometry.angle q r p + EuclideanGeometry.angle r p q = Real.pi "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "goldbach",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every positive even integer can be written as the sum of two primes.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every positive even integer can be written as the sum of two primes.",
      "codex_time": 4.824600228021154,
      "use_theorem_name": false
    },
    "outputs": [
      "(n : ℕ) (hn : n > 0) (he : ∃ k, 2 * k = n) :  ∃ p q, Prime p ∧ Prime q ∧ p + q = n ",
      "(n : ℕ) (h : 0 < n ∧ Even (n+1)) :  ∃ p q : ℕ, p.prime ∧ q.prime ∧ p+q = n ",
      "(n : ℕ) (h : 4 ∣ n) (hp : ¬ (∃ p q r, n = p*q*r)) :  ∃ p q, p.1 ∧ q.1 ∧ (p.2 = 2 ∨ q.2 = 2) ∧ p.2 ≠ q.2 ∧ n = p.2*q.2 ",
      "(n : ℕ) (hpos : 0 < n) (heven : Even n) :  ∃ (m n : ℕ), m < n ∧ m.prime ∧ n.prime ∧ m + n = n ",
      "(n : ℕ) (hn0 : 0 < n) (hn_even : 2 ∣ n) :  ∃ p q : ℕ,   0 < p ∧ 2 ≠ p ∧ Prime p ∧ 0 < q ∧ 2 ≠ q ∧ Prime q ∧ n = p + q "
    ],
    "answer": ": ∀ n : ℕ, n > 0 → Even n → ∃ p q : ℕ, Prime p → Prime q → n = p + q "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "goldbach",
      "main_prompt": "Every positive even integer can be written as the sum of two primes.",
      "prompt": "Natural language version: \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.\" Translate the natural language version to a Lean mathlib version:\n theorem {p : ℕ} [fact (nat.prime p)] :\np % 2 = 1 ↔ p ≠ 2 := \n\nNatural language version: \"If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0`\" Translate the natural language version to a Lean mathlib version:\n theorem {p a b : ℕ} (hpa : p ∈ a.factors) (hb : b ≠ 0) :\np ∈ (a * b).factors := \n\nNatural language version: \"Every nonzero natural number has a unique prime factorization\" Translate the natural language version to a Lean mathlib version:\n theorem  :\nset.inj_on nat.factorization {x : ℕ | x ≠ 0} := \n\nNatural language version: \"The only numbers with empty prime factorization are `0` and `1`\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) :\nn.factorization = 0 ↔ n = 0 ∨ n = 1 := \n\nNatural language version: \"Every positive even integer can be written as the sum of two primes.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5331833362579346,
          "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.",
          "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2"
        },
        {
          "sim_score": 0.48720940947532654,
          "doc_string": "If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0`",
          "statement": "theorem nat.mem_factors_mul_left {p a b : ℕ} (hpa : p ∈ a.factors) (hb : b ≠ 0) : p ∈ (a * b).factors"
        },
        {
          "sim_score": 0.48647668957710266,
          "doc_string": "Every nonzero natural number has a unique prime factorization",
          "statement": "theorem nat.factorization_inj  : set.inj_on nat.factorization {x : ℕ | x ≠ 0}"
        },
        {
          "sim_score": 0.4829321801662445,
          "doc_string": "The only numbers with empty prime factorization are `0` and `1`",
          "statement": "theorem nat.factorization_eq_zero_iff (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1"
        }
      ],
      "codex_time": 5.843470266001532,
      "search_time": 1.493072356999619,
      "use_theorem_name": false
    },
    "outputs": [
      "(p : ℕ) (hp : p ≥ 2): ∃p1 p2 : ℕ,    p1.nat_prime ∧ p2.nat_prime ∧ p1 + p2 = p ",
      "{n : ℕ}(hn : n ≠ 0) : ∃ p q : ℕ, p + q = n ∧ (Fact (Prime p)) ∧ (Fact (Prime q)) ∧ (Even n) ",
      "(n : ℕ) (h : n > 0) : ∃ a b : (Nat.Prime a) ∧ (Nat.Prime b) ",
      "(n p q : ℕ) (h : 0 < n ∧ n % 2 = 0) : n = p + q ∧ (Nat.Prime p) ∧ (Nat.Prime q) ",
      "(n : ℕ) (h : n ≥ 2 ∧ n % 2 = 0) : ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ p + q = n "
    ],
    "answer": ": ∀ n : ℕ, n > 0 → Even n → ∃ p q : ℕ, Prime p → Prime q → n = p + q "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "goldbach",
      "main_prompt": "Every positive even integer can be written as the sum of two primes.",
      "prompt": "Natural language version: \"Every positive even integer can be written as the sum of two primes.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 6.856547880975995,
      "use_theorem_name": false
    },
    "outputs": [
      "goldbach_two_prime (n : ℕ) : 2 ≤ n → ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ 2*n = p+q ",
      "Goldbach : ∀ n : ℕ , n % 2 = 0 → ∃ p q : ℕ , n = p + q ∧ Prime p ∧ Prime q ",
      "Goldbach_mathlib : ∀ (n : ℕ), n = 0 → n = 1 → n = 2 → n = 3 → n = 6 → Even n → (∃ m p : ℕ, m ≠ 0 ∧ p ≠ 0 ∧ Even p ∧ Even m ∧ m <> p ∧ m*p = n ∧ n = m + p) ",
      "Goldbach : ∀ n:ℤ, n > 0 → ∃ p q : ℕ, Prime p ∧ Prime q ∧ p + q = ↑n ",
      ": ∀ n : ℕ, n % 2 = 0 → ∃ p q, Prime p ∧ Prime q ∧ n = p + q "
    ],
    "answer": ": ∀ n : ℕ, n > 0 → Even n → ∃ p q : ℕ, Prime p → Prime q → n = p + q "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "cayley_hamilton",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every matrix satisfies its own characteristic polynomial.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every matrix satisfies its own characteristic polynomial.",
      "codex_time": 11.110754669993185,
      "use_theorem_name": false
    },
    "outputs": [
      "(n : ℕ) (M : Matrix (Fin n) (Fin n) ℂ)  (p : Polynomial ℂ) (Hp : p M = 0) :  ∀ (x : ℂ) (hx : is_eigenvector M x), p.eval x = 0 ",
      "(n : ℕ) (M : Matrix (Finₓ n) (Finₓ n) ℂ)  (p : Polynomial ℂ) (Hp : p M = 0) :  ∀ (x : ℂ) (hx : is_eigenvector M x), p.eval x = 0 ",
      "(A : Matrix n n R) :  monic_det A = characteristic A ",
      "(n : ℕ) (mat : Matrix (Fin n) (Fin n) ℂ) (a : ℂ) :   ∀ b, Polynomial.eval b (matrix.char_poly mat) a = 0 → a = b ",
      "(n : ℕ) (mat : Matrix (Finₓ n) (Finₓ n) ℂ) (a : ℂ) :   ∀ b, Polynomial.eval b (matrix.char_poly mat) a = 0 → a = b ",
      "(K : Type*) [discrete_field K] (n : Type u) [Fintype n]  [DecidableEq n] (A : (Fin n × Fin n) → K) : det (λ i : Fin n × Fin n, A (i.1, i.2) • char_poly A x i.1 i.2) = char_poly A x ",
      "(K : Type*) [discrete_field K] (n : Type u) [Fintype n]  [DecidableEq n] (A : (Finₓ n × Finₓ n) → K) : det (λ i : Finₓ n × Finₓ n, A (i.1, i.2) • char_poly A x i.1 i.2) = char_poly A x ",
      "(K : Type*) [discrete_field K] (n : Type u) [Fintypeₓ n]  [DecidableEq n] (A : (Fin n × Fin n) → K) : det (λ i : Fin n × Fin n, A (i.1, i.2) • char_poly A x i.1 i.2) = char_poly A x ",
      "(K : Type*) [discrete_field K] (n : Type u) [Fintypeₓ n]  [DecidableEq n] (A : (Finₓ n × Finₓ n) → K) : det (λ i : Finₓ n × Finₓ n, A (i.1, i.2) • char_poly A x i.1 i.2) = char_poly A x ",
      "(n : ℕ) (A : Matrix (Fin n) (Fin n) ℂ)  (p : Polynomial ℂ) (h : ∀ z, p z = 0 ↔ z * id_mat n - A = 0) :  p (A.trace) = 0 ",
      "(n : ℕ) (A : Matrix (Finₓ n) (Finₓ n) ℂ)  (p : Polynomial ℂ) (h : ∀ z, p z = 0 ↔ z * id_mat n - A = 0) :  p (A.trace) = 0 "
    ],
    "answer": "{R : Type _} [CommRingₓ R] {n : Type _} [DecidableEq n] [Fintype n] (M : Matrix n n R) : (Polynomial.aeval M) M.charpoly = 0 "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "cayley_hamilton",
      "main_prompt": "Every matrix satisfies its own characteristic polynomial.",
      "prompt": "Natural language version: \" The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a linear map, applied to the linear map itself, is zero.  See `matrix.aeval_self_charpoly` for the equivalent statement about matrices.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M →ₗ[R] M) :\n⇑(polynomial.aeval f) f.charpoly = 0 := \n\nNatural language version: \"The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a matrix, applied to the matrix itself, is zero.  This holds over any commutative ring.  See `linear_map.aeval_self_charpoly` for the equivalent statement about endomorphisms.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) :\n⇑(polynomial.aeval M) M.charpoly = 0 := \n\nNatural language version: \"`charpoly f` is the characteristic polynomial of the matrix of `f` in any basis.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M →ₗ[R] M) {ι : Type w} [fintype ι] (b : basis ι R M) :\n(⇑(linear_map.to_matrix b b) f).charpoly = f.charpoly := \n\nNatural language version: \" Any matrix polynomial `p` is equivalent under evaluation to `p %ₘ M.charpoly`; that is, `p` is equivalent to a polynomial with degree less than the dimension of the matrix.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [comm_ring R] {n : Type v} [decidable_eq n] [fintype n] (M : matrix n n R) (p : polynomial R) :\n⇑(polynomial.aeval M) p = ⇑(polynomial.aeval M) (p %ₘ M.charpoly) := \n\nNatural language version: \"Every matrix satisfies its own characteristic polynomial.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.7601779699325562,
          "doc_string": " The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a linear map, applied to the linear map itself, is zero.  See `matrix.aeval_self_charpoly` for the equivalent statement about matrices.",
          "statement": "theorem linear_map.aeval_self_charpoly {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M →ₗ[R] M) : ⇑(polynomial.aeval f) f.charpoly = 0"
        },
        {
          "sim_score": 0.6756272315979004,
          "doc_string": "The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a matrix, applied to the matrix itself, is zero.  This holds over any commutative ring.  See `linear_map.aeval_self_charpoly` for the equivalent statement about endomorphisms.",
          "statement": "theorem matrix.aeval_self_charpoly {R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : ⇑(polynomial.aeval M) M.charpoly = 0"
        },
        {
          "sim_score": 0.5441092252731323,
          "doc_string": "`charpoly f` is the characteristic polynomial of the matrix of `f` in any basis.",
          "statement": "theorem linear_map.charpoly_to_matrix {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M →ₗ[R] M) {ι : Type w} [fintype ι] (b : basis ι R M) : (⇑(linear_map.to_matrix b b) f).charpoly = f.charpoly"
        },
        {
          "sim_score": 0.5268839001655579,
          "doc_string": " Any matrix polynomial `p` is equivalent under evaluation to `p %ₘ M.charpoly`; that is, `p` is equivalent to a polynomial with degree less than the dimension of the matrix.",
          "statement": "theorem matrix.aeval_eq_aeval_mod_charpoly {R : Type u} [comm_ring R] {n : Type v} [decidable_eq n] [fintype n] (M : matrix n n R) (p : polynomial R) : ⇑(polynomial.aeval M) p = ⇑(polynomial.aeval M) (p %ₘ M.charpoly)"
        }
      ],
      "codex_time": 5.290859720989829,
      "search_time": 1.4968492100015283,
      "use_theorem_name": false
    },
    "outputs": [
      "{R : Type u} [CommRing R] {n : Type w} [DecidableEq n] [Fintype n] (M : Matrix n n R) : M.charpoly.eval₂ M = 0 ",
      "{R : Type u} [CommRingₓₓ R] {n : Type w} [DecidableEq n] [Fintype n] (M : Matrix n n R) : M.charpoly.eval₂ M = 0 ",
      "{R : Type u} [CommRingₓ R] {n : Type w} [DecidableEq n] [Fintype n] (M : Matrix n n R) : M.charpoly.eval₂ M = 0 ",
      "{R : Type u} [CommRing R] {n : Type w} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) : M.charpoly.eval₂ M = 0 ",
      "{R : Type u} [CommRingₓₓ R] {n : Type w} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) : M.charpoly.eval₂ M = 0 ",
      "{R : Type u} [CommRingₓ R] {n : Type w} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) : M.charpoly.eval₂ M = 0 ",
      "{R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) (p : Polynomial R) : p = 0 ∨ p = M.charpoly ↔ (p %ₘ M.charpoly).eval M = 0 ",
      "{R : Type u} [CommRingₓₓ R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) (p : Polynomial R) : p = 0 ∨ p = M.charpoly ↔ (p %ₘ M.charpoly).eval M = 0 ",
      "{R : Type u} [CommRingₓ R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) (p : Polynomial R) : p = 0 ∨ p = M.charpoly ↔ (p %ₘ M.charpoly).eval M = 0 ",
      "{R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) (p : Polynomial R) : p = 0 ∨ p = M.charpoly ↔ (p %ₘ M.charpoly).eval M = 0 ",
      "{R : Type u} [CommRingₓₓ R] {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) (p : Polynomial R) : p = 0 ∨ p = M.charpoly ↔ (p %ₘ M.charpoly).eval M = 0 ",
      "{R : Type u} [CommRingₓ R] {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) (p : Polynomial R) : p = 0 ∨ p = M.charpoly ↔ (p %ₘ M.charpoly).eval M = 0 ",
      "{R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) : M.charpoly.eval M = 0 ",
      "{R : Type u} [CommRingₓₓ R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) : M.charpoly.eval M = 0 ",
      "{R : Type u} [CommRingₓ R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) : M.charpoly.eval M = 0 ",
      "{R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) : M.charpoly.eval M = 0 ",
      "{R : Type u} [CommRingₓₓ R] {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) : M.charpoly.eval M = 0 ",
      "{R : Type u} [CommRingₓ R] {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) : M.charpoly.eval M = 0 ",
      "{R : Type u} [CommRing R] (M : integral_domain R) {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) : M.charpoly.eval M 0 = 0 ",
      "{R : Type u} [CommRingₓₓ R] (M : integral_domain R) {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) : M.charpoly.eval M 0 = 0 ",
      "{R : Type u} [CommRingₓ R] (M : integral_domain R) {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) : M.charpoly.eval M 0 = 0 ",
      "{R : Type u} [CommRing R] (M : integral_domain R) {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) : M.charpoly.eval M 0 = 0 ",
      "{R : Type u} [CommRingₓₓ R] (M : integral_domain R) {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) : M.charpoly.eval M 0 = 0 ",
      "{R : Type u} [CommRingₓ R] (M : integral_domain R) {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) : M.charpoly.eval M 0 = 0 ",
      "{R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) {p : Polynomial R} : M.charpoly = p ↔ matrix_mx R M (p.eval₂ = *(≠)) M ",
      "{R : Type u} [CommRingₓₓ R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) {p : Polynomial R} : M.charpoly = p ↔ matrix_mx R M (p.eval₂ = *(≠)) M ",
      "{R : Type u} [CommRingₓ R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) {p : Polynomial R} : M.charpoly = p ↔ matrix_mx R M (p.eval₂ = *(≠)) M ",
      "{R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) {p : Polynomial R} : M.charpoly = p ↔ matrix_mx R M (p.eval₂ = *(≠)) M ",
      "{R : Type u} [CommRingₓₓ R] {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) {p : Polynomial R} : M.charpoly = p ↔ matrix_mx R M (p.eval₂ = *(≠)) M ",
      "{R : Type u} [CommRingₓ R] {n : Type v} [DecidableEq n] [Fintypeₓ n] (M : Matrix n n R) {p : Polynomial R} : M.charpoly = p ↔ matrix_mx R M (p.eval₂ = *(≠)) M "
    ],
    "answer": "{R : Type _} [CommRingₓ R] {n : Type _} [DecidableEq n] [Fintype n] (M : Matrix n n R) : (Polynomial.aeval M) M.charpoly = 0 "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "cayley_hamilton",
      "main_prompt": "Every matrix satisfies its own characteristic polynomial.",
      "prompt": "Natural language version: \"Every matrix satisfies its own characteristic polynomial.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 8.867336855008034,
      "use_theorem_name": false
    },
    "outputs": [
      "True1: (∀ A : M n, A) → True ",
      "characteristic_polynomial_self :  ∀ {n : ℕ} (A : Matrix (Fin n) (Fin n) ℚ),  characteristic_polynomial A = 0 ",
      "characteristic_polynomial_self :  ∀ {n : ℕ} (A : Matrix (Finₓ n) (Finₓ n) ℚ),  characteristic_polynomial A = 0 ",
      "characteristic_polynomial_apply (n:ℕ) (A: Matrix (Fin n) (Fin n) ℚ): characteristic_polynomial A = A -- If we make the definition of Matrix, then we can use the poly_apply defintion to fill in the missing =A from above. def poly_apply (A:Type) [CommRing A] (L:List A) (x:A) ",
      "characteristic_polynomial_apply (n:ℕ) (A: Matrix (Fin n) (Fin n) ℚ): characteristic_polynomial A = A -- If we make the definition of Matrix, then we can use the poly_apply defintion to fill in the missing =A from above. def poly_apply (A:Type) [CommRingₓₓ A] (L:List A) (x:A) ",
      "characteristic_polynomial_apply (n:ℕ) (A: Matrix (Fin n) (Fin n) ℚ): characteristic_polynomial A = A -- If we make the definition of Matrix, then we can use the poly_apply defintion to fill in the missing =A from above. def poly_apply (A:Type) [CommRingₓ A] (L:List A) (x:A) ",
      "characteristic_polynomial_apply (n:ℕ) (A: Matrix (Finₓ n) (Finₓ n) ℚ): characteristic_polynomial A = A -- If we make the definition of Matrix, then we can use the poly_apply defintion to fill in the missing =A from above. def poly_apply (A:Type) [CommRing A] (L:List A) (x:A) ",
      "characteristic_polynomial_apply (n:ℕ) (A: Matrix (Finₓ n) (Finₓ n) ℚ): characteristic_polynomial A = A -- If we make the definition of Matrix, then we can use the poly_apply defintion to fill in the missing =A from above. def poly_apply (A:Type) [CommRingₓₓ A] (L:List A) (x:A) ",
      "characteristic_polynomial_apply (n:ℕ) (A: Matrix (Finₓ n) (Finₓ n) ℚ): characteristic_polynomial A = A -- If we make the definition of Matrix, then we can use the poly_apply defintion to fill in the missing =A from above. def poly_apply (A:Type) [CommRingₓ A] (L:List A) (x:A) ",
      "C (A : Matrix (Fin 1) (Fin 1) ℂ) : characteristic_polynomial A = [1, -(A 0 0)] ",
      "C (A : Matrix (Finₓ 1) (Finₓ 1) ℂ) : characteristic_polynomial A = [1, -(A 0 0)] ",
      "hensel_lemma_special_version (R : Type*) [CommRing R] (M : Matrix R 5 5) :∃ C : Matrix R 5 5, C * M = M * C ",
      "hensel_lemma_special_version (R : Type*) [CommRingₓₓ R] (M : Matrix R 5 5) :∃ C : Matrix R 5 5, C * M = M * C ",
      "hensel_lemma_special_version (R : Type*) [CommRingₓ R] (M : Matrix R 5 5) :∃ C : Matrix R 5 5, C * M = M * C "
    ],
    "answer": "{R : Type _} [CommRingₓ R] {n : Type _} [DecidableEq n] [Fintype n] (M : Matrix n n R) : (Polynomial.aeval M) M.charpoly = 0 "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "sqrt_of_irrat_irrat",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"The square root of an irrational number is irrational.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The square root of an irrational number is irrational.",
      "codex_time": 6.699135800998192,
      "use_theorem_name": false
    },
    "outputs": [
      "(x : ℝ) (hx2 : x^2∉ ℚ) :  √ x ∉ ℚ ",
      "(x : ℝ) (hx_irrat : ¬ is_rat x) :    ∀ y, y ^ 2 = x → ¬ is_rat y ",
      "(a : ℝ) (ha0 : 0 < a) (ha_irr : ∃ q : ℕ, ∃ p : ℕ, q * q * p * p = a) :  ∀ b : ℝ, ∃ r : ℝ, ∀ a, a * a = r * r → a = b ",
      "(x : ℝ) (hx : ∥x∥ x > 0 ∧ ¬ ∃ y : ℚ, ∥x∥ = y^2) :  ¬ ∃ y : ℚ, ∥√∥x∥∥ = y ",
      "(a : ℝ) (ha : a ≠ 0)   (h : ¬ ∃ x, x^2 = a) :    ∀ x : ℝ, x^2 = a → x = 0 "
    ],
    "answer": "(x : ℝ) : Irrational x → Irrational (Real.sqrt x) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "sqrt_of_irrat_irrat",
      "main_prompt": "The square root of an irrational number is irrational.",
      "prompt": "Natural language version: \"A transcendental real number is irrational.\" Translate the natural language version to a Lean mathlib version:\n theorem {r : ℝ} (tr : transcendental ℚ r) :\nirrational r := \n\nNatural language version: \" If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then `x` is irrational.\" Translate the natural language version to a Lean mathlib version:\n theorem {x : ℝ} (n : ℕ) (m : ℤ) (hxr : x ^ n = ↑m) (hv : ¬∃ (y : ℤ), x = ↑y) (hnpos : 0 < n) :\nirrational x := \n\nNatural language version: \"**Irrationality of the Square Root of 2**\" Translate the natural language version to a Lean mathlib version:\n theorem  :\nirrational (real.sqrt 2) := \n\nNatural language version: \"The natural square root is at most the real square root\" Translate the natural language version to a Lean mathlib version:\n theorem {a : ℕ} :\n↑(nat.sqrt a) ≤ real.sqrt ↑a := \n\nNatural language version: \"The square root of an irrational number is irrational.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.70249342918396,
          "doc_string": "A transcendental real number is irrational.",
          "statement": "theorem transcendental.irrational {r : ℝ} (tr : transcendental ℚ r) : irrational r"
        },
        {
          "sim_score": 0.6819822192192078,
          "doc_string": " If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then `x` is irrational.",
          "statement": "theorem irrational_nrt_of_notint_nrt {x : ℝ} (n : ℕ) (m : ℤ) (hxr : x ^ n = ↑m) (hv : ¬∃ (y : ℤ), x = ↑y) (hnpos : 0 < n) : irrational x"
        },
        {
          "sim_score": 0.6707029938697815,
          "doc_string": "**Irrationality of the Square Root of 2**",
          "statement": "theorem irrational_sqrt_two  : irrational (real.sqrt 2)"
        },
        {
          "sim_score": 0.6412547826766968,
          "doc_string": "The natural square root is at most the real square root",
          "statement": "theorem real.nat_sqrt_le_real_sqrt {a : ℕ} : ↑(nat.sqrt a) ≤ real.sqrt ↑a"
        }
      ],
      "codex_time": 3.5490879860008135,
      "search_time": 1.4941794150217902,
      "use_theorem_name": false
    },
    "outputs": [
      "{x : ℝ} (irx : Irrational x) : Irrational (Real.sqrt x) ",
      "{x : ℝ} (hxr : Irrational x) : Irrational (Real.sqrt x) ",
      "{a : ℕ} (IH :  Irrational (Real.sqrt ↑a)) : Irrational ↑(Nat.sqrt a) ",
      "{x : ℝ} (hxr : Irrational x) : Irrational (Real.sqrt x) ",
      "{x : ℝ} (irr : Irrational x) : Irrational (Real.sqrt x) "
    ],
    "answer": "(x : ℝ) : Irrational x → Irrational (Real.sqrt x) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "sqrt_of_irrat_irrat",
      "main_prompt": "The square root of an irrational number is irrational.",
      "prompt": "Natural language version: \"The square root of an irrational number is irrational.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 6.418318103009369,
      "use_theorem_name": false
    },
    "outputs": [
      "sq_irr_irr       {a : ℝ} {b : ℚ} (H : a * b = sqrt a * sqrt b) : a*b = sqrt a * sqrt b ",
      "irrational_root_irrational (t : ℝ) (h : t.sqrt.irrational) :      t.irrational  proof    intro ht_is_rat,    have : t.sqrt ∈ ℚ ",
      "sqrt_irrational_irrational {α : Type} [discrete_field α] (x : α) (hx : ¬ IsSquare x) : ¬ IsSquare √x ",
      "irr_sqrt (x : ℚ) : x ≠ 0 → Irrational x → Irrational (sqrt x) ",
      "Q_sqrt_irrational : ∀ {x : ℚ}, x.is_irrational → (x ^ 2).sqrt.is_irrational "
    ],
    "answer": "(x : ℝ) : Irrational x → Irrational (Real.sqrt x) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "sq_even_implies_num_even",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"If the square of a number is even, the number itself is even.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If the square of a number is even, the number itself is even.",
      "codex_time": 6.299675221001962,
      "use_theorem_name": false
    },
    "outputs": [
      "(n : ℕ) (hn : n * n % 2 = 0) : 0 ≤ n ",
      "(n : ℕ) (h : 2^n = 2*m) : 2*(2^n) = 2*2*m ",
      "(n : ℕ) (hn : 2 * n ∈ Even) :  n ∈ Even ",
      "(x : ℕ) (hx : 2 ∣ x*x) : 2 ∣ x ",
      "(n : Nat) (h : Even (n^2)) : Even n "
    ],
    "answer": ": ∀ n : ℕ, Even (n^2) → Even n "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "sq_even_implies_num_even",
      "main_prompt": "If the square of a number is even, the number itself is even.",
      "prompt": "Natural language version: \" If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.\" Translate the natural language version to a Lean mathlib version:\n theorem {m n : ℕ} :\neven (m ^ n) ↔ even m ∧ n ≠ 0 := \n\nNatural language version: \"The sum of two squares is zero iff both elements are zero.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [linear_ordered_ring α] {x y : α} :\nx * x + y * y = 0 ↔ x = 0 ∧ y = 0 := \n\nNatural language version: \"In a finite field of odd characteristic, not every element is a square.\" Translate the natural language version to a Lean mathlib version:\n theorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) :\n∃ (a : F), ¬is_square a := \n\nNatural language version: \" To show a property is true on the even or odd part, it suffices to show it is true on the scalars or vectors (respectively), closed under addition, and under left-multiplication by a pair of vectors.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) (n : zmod 2) {P : Π (x : clifford_algebra Q), x ∈ clifford_algebra.even_odd Q n → Prop} (hr : ∀ (v : clifford_algebra Q) (h : v ∈ (clifford_algebra.ι Q).range ^ n.val), P v _) (hadd : ∀ {x y : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q n} {hy : y ∈ clifford_algebra.even_odd Q n}, P x hx → P y hy → P (x + y) _) (hιι_mul : ∀ (m₁ m₂ : M) {x : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q n}, P x hx → P (⇑(clifford_algebra.ι Q) m₁ * ⇑(clifford_algebra.ι Q) m₂ * x) _) (x : clifford_algebra Q) (hx : x ∈ clifford_algebra.even_odd Q n) :\nP x hx := \n\nNatural language version: \"If the square of a number is even, the number itself is even.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5731519460678101,
          "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.",
          "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0"
        },
        {
          "sim_score": 0.5604414343833923,
          "doc_string": "The sum of two squares is zero iff both elements are zero.",
          "statement": "theorem mul_self_add_mul_self_eq_zero {α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0"
        },
        {
          "sim_score": 0.546607255935669,
          "doc_string": "In a finite field of odd characteristic, not every element is a square.",
          "statement": "theorem finite_field.exists_nonsquare {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) : ∃ (a : F), ¬is_square a"
        },
        {
          "sim_score": 0.5101829767227173,
          "doc_string": " To show a property is true on the even or odd part, it suffices to show it is true on the scalars or vectors (respectively), closed under addition, and under left-multiplication by a pair of vectors.",
          "statement": "theorem clifford_algebra.even_odd_induction {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) (n : zmod 2) {P : Π (x : clifford_algebra Q), x ∈ clifford_algebra.even_odd Q n → Prop} (hr : ∀ (v : clifford_algebra Q) (h : v ∈ (clifford_algebra.ι Q).range ^ n.val), P v _) (hadd : ∀ {x y : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q n} {hy : y ∈ clifford_algebra.even_odd Q n}, P x hx → P y hy → P (x + y) _) (hιι_mul : ∀ (m₁ m₂ : M) {x : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q n}, P x hx → P (⇑(clifford_algebra.ι Q) m₁ * ⇑(clifford_algebra.ι Q) m₂ * x) _) (x : clifford_algebra Q) (hx : x ∈ clifford_algebra.even_odd Q n) : P x hx"
        }
      ],
      "codex_time": 8.593759972980479,
      "search_time": 1.7009556770208292,
      "use_theorem_name": false
    },
    "outputs": [
      "{α : Type u} [integral_domain α] (a : α) : Even ((a : ℤ)^2) → Even a ",
      "{R : Type u} [CommRing R] (r : R) : is_even (r * r) → is_even r ",
      "{R : Type u} [CommRingₓₓ R] (r : R) : is_even (r * r) → is_even r ",
      "{R : Type u} [CommRingₓ R] (r : R) : is_even (r * r) → is_even r ",
      "{m : ℕ} (h : Even (m * m)) : Even m ",
      "{α : Type u_1} {m n : ℕ} [LinearOrderedSemiring α] (hmn : (m ^ 2) * (n ^ (2 : ℕ)) = 0) : 2 ∣ m ^ 2 ∧ 2 ∣ n ^ 2 ",
      "{R : Type u} [Ring R] (a : R) (h2HasMem : 2 ∈ units R) : is_even (a * a) → is_even a ",
      "{R : Type u} [Ringₓₓ R] (a : R) (h2HasMem : 2 ∈ units R) : is_even (a * a) → is_even a ",
      "{R : Type u} [Ringₓ R] (a : R) (h2HasMem : 2 ∈ units R) : is_even (a * a) → is_even a "
    ],
    "answer": ": ∀ n : ℕ, Even (n^2) → Even n "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "sq_even_implies_num_even",
      "main_prompt": "If the square of a number is even, the number itself is even.",
      "prompt": "Natural language version: \"If the square of a number is even, the number itself is even.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 10.38675956899533,
      "use_theorem_name": false
    },
    "outputs": [
      "square_even (n : ℕ) : Even n → Even (n * n) ",
      "Q28 (n : ℕ): Even (n^2) → Even n ",
      "if_square_even_number_even : ∀ m : ℕ, m ^ 2 % 2 = 0 → m % 2 = 0 ",
      "square_even : ∃ (n : ℕ), n ^ 2 % 2 = 0  using tactic. If a natural language version is unclear, be sure to Add your own interpretation of the mathematical statement.    /-- If a ∈ B → C, then a ∈ B → (B∩C) -/ lemma and_of_implies (a b c : Prop) :   (a → b) → (a → (b ∧ c)) ",
      "even_square_iff_even (n : ℕ) : nat.even (n^2) ↔ nat.even n "
    ],
    "answer": ": ∀ n : ℕ, Even (n^2) → Even n "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "finite_ring_prime_implies_maximal",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"In a finite commutative ring, all prime ideals are maximal.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "In a finite commutative ring, all prime ideals are maximal.",
      "codex_time": 7.978997197991703,
      "use_theorem_name": false
    },
    "outputs": [
      "(R : Type*) [CommRing R] (h : Fintype R)  (P : Set R) (is_ideal : Ideal P)  (Prime : Prime P) : maximal P ",
      "(R : Type*) [CommRingₓₓ R] (h : Fintype R)  (P : Set R) (is_ideal : Ideal P)  (Prime : Prime P) : maximal P ",
      "(R : Type*) [CommRing R] (h : Fintype R)  (P : Setₓ R) (is_ideal : Ideal P)  (Prime : Prime P) : maximal P ",
      "(R : Type*) [CommRingₓₓ R] (h : Fintype R)  (P : Setₓ R) (is_ideal : Ideal P)  (Prime : Prime P) : maximal P ",
      "(R : Type*) [CommRingₓ R] (h : Fintype R)  (P : Set R) (is_ideal : Ideal P)  (Prime : Prime P) : maximal P ",
      "(R : Type*) [CommRingₓ R] (h : Fintype R)  (P : Setₓ R) (is_ideal : Ideal P)  (Prime : Prime P) : maximal P ",
      "(R : Type*) [CommRing R] (h : Fintypeₓ R)  (P : Set R) (is_ideal : Ideal P)  (Prime : Prime P) : maximal P ",
      "(R : Type*) [CommRingₓₓ R] (h : Fintypeₓ R)  (P : Set R) (is_ideal : Ideal P)  (Prime : Prime P) : maximal P ",
      "(R : Type*) [CommRing R] (h : Fintypeₓ R)  (P : Setₓ R) (is_ideal : Ideal P)  (Prime : Prime P) : maximal P ",
      "(R : Type*) [CommRingₓₓ R] (h : Fintypeₓ R)  (P : Setₓ R) (is_ideal : Ideal P)  (Prime : Prime P) : maximal P ",
      "(R : Type*) [CommRingₓ R] (h : Fintypeₓ R)  (P : Set R) (is_ideal : Ideal P)  (Prime : Prime P) : maximal P ",
      "(R : Type*) [CommRingₓ R] (h : Fintypeₓ R)  (P : Setₓ R) (is_ideal : Ideal P)  (Prime : Prime P) : maximal P ",
      "(R : Type*) [CommRing R] [Fintype R] (I : Ideal R)  (P : Prime_ideal I) :  is_maximal_ideal I ",
      "(R : Type*) [CommRingₓₓ R] [Fintype R] (I : Ideal R)  (P : Prime_ideal I) :  is_maximal_ideal I ",
      "(R : Type*) [CommRingₓ R] [Fintype R] (I : Ideal R)  (P : Prime_ideal I) :  is_maximal_ideal I ",
      "(R : Type*) [CommRing R] [Fintypeₓ R] (I : Ideal R)  (P : Prime_ideal I) :  is_maximal_ideal I ",
      "(R : Type*) [CommRingₓₓ R] [Fintypeₓ R] (I : Ideal R)  (P : Prime_ideal I) :  is_maximal_ideal I ",
      "(R : Type*) [CommRingₓ R] [Fintypeₓ R] (I : Ideal R)  (P : Prime_ideal I) :  is_maximal_ideal I ",
      "(R : Type*) [CommRing R] (hRf : Fintype R) (p : Ideal R) (p_prime : Prime p) :  ideal.maximal p ",
      "(R : Type*) [CommRingₓₓ R] (hRf : Fintype R) (p : Ideal R) (p_prime : Prime p) :  ideal.maximal p ",
      "(R : Type*) [CommRingₓ R] (hRf : Fintype R) (p : Ideal R) (p_prime : Prime p) :  ideal.maximal p ",
      "(R : Type*) [CommRing R] (hRf : Fintypeₓ R) (p : Ideal R) (p_prime : Prime p) :  ideal.maximal p ",
      "(R : Type*) [CommRingₓₓ R] (hRf : Fintypeₓ R) (p : Ideal R) (p_prime : Prime p) :  ideal.maximal p ",
      "(R : Type*) [CommRingₓ R] (hRf : Fintypeₓ R) (p : Ideal R) (p_prime : Prime p) :  ideal.maximal p ",
      "(R : Type*) [Ring R][Fintype R] (M P : Ideal R) [Prime P]  (hm : ∀ m ∈ M, m ≠ 0 → ∃ p ∈ P, m = p) :   M = Ideal.span P ",
      "(R : Type*) [Ringₓₓ R][Fintype R] (M P : Ideal R) [Prime P]  (hm : ∀ m ∈ M, m ≠ 0 → ∃ p ∈ P, m = p) :   M = Ideal.span P ",
      "(R : Type*) [Ringₓ R][Fintype R] (M P : Ideal R) [Prime P]  (hm : ∀ m ∈ M, m ≠ 0 → ∃ p ∈ P, m = p) :   M = Ideal.span P ",
      "(R : Type*) [Ring R][Fintypeₓ R] (M P : Ideal R) [Prime P]  (hm : ∀ m ∈ M, m ≠ 0 → ∃ p ∈ P, m = p) :   M = Ideal.span P ",
      "(R : Type*) [Ringₓₓ R][Fintypeₓ R] (M P : Ideal R) [Prime P]  (hm : ∀ m ∈ M, m ≠ 0 → ∃ p ∈ P, m = p) :   M = Ideal.span P ",
      "(R : Type*) [Ringₓ R][Fintypeₓ R] (M P : Ideal R) [Prime P]  (hm : ∀ m ∈ M, m ≠ 0 → ∃ p ∈ P, m = p) :   M = Ideal.span P ",
      "(R : Type*) [CommRing R] [fd_char_p R]  (P : Ideal R) (hp : Prime P) : maximal P ",
      "(R : Type*) [CommRingₓₓ R] [fd_char_p R]  (P : Ideal R) (hp : Prime P) : maximal P ",
      "(R : Type*) [CommRingₓ R] [fd_char_p R]  (P : Ideal R) (hp : Prime P) : maximal P "
    ],
    "answer": "{R : Type _} [CommRingₓ R] [Fintype R] : ∀ (Idl : Ideal R), Idl.IsPrime → Idl.IsMaximal "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "finite_ring_prime_implies_maximal",
      "main_prompt": "In a finite commutative ring, all prime ideals are maximal.",
      "prompt": "Natural language version: \"When a ring is not a field, the maximal ideals are nontrivial.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_1} [comm_ring R] [nontrivial R] {M : ideal R} (max : M.is_maximal) (not_field : ¬is_field R) :\nM ≠ ⊥ := \n\nNatural language version: \"Krull's theorem: a nontrivial ring has a maximal ideal.\" Translate the natural language version to a Lean mathlib version:\n theorem (α : Type u) [semiring α] [nontrivial α] :\n∃ (M : ideal α), M.is_maximal := \n\nNatural language version: \"If P is not properly contained in any maximal ideal then it is not properly contained  in any proper ideal\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [semiring R] {P : ideal R} (hmax : ∀ (m : ideal R), P < m → ¬m.is_maximal) (J : ideal R) (hPJ : P < J) :\nJ = ⊤ := \n\nNatural language version: \"If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [comm_ring R] {P : ideal R} (H : P.is_prime) :\n(ideal.map polynomial.C P).is_prime := \n\nNatural language version: \"In a finite commutative ring, all prime ideals are maximal.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6932713389396667,
          "doc_string": "When a ring is not a field, the maximal ideals are nontrivial.",
          "statement": "theorem ring.ne_bot_of_is_maximal_of_not_is_field {R : Type u_1} [comm_ring R] [nontrivial R] {M : ideal R} (max : M.is_maximal) (not_field : ¬is_field R) : M ≠ ⊥"
        },
        {
          "sim_score": 0.6569143533706665,
          "doc_string": "Krull's theorem: a nontrivial ring has a maximal ideal.",
          "statement": "theorem ideal.exists_maximal (α : Type u) [semiring α] [nontrivial α] : ∃ (M : ideal α), M.is_maximal"
        },
        {
          "sim_score": 0.6307719945907593,
          "doc_string": "If P is not properly contained in any maximal ideal then it is not properly contained  in any proper ideal",
          "statement": "theorem ideal.maximal_of_no_maximal {R : Type u} [semiring R] {P : ideal R} (hmax : ∀ (m : ideal R), P < m → ¬m.is_maximal) (J : ideal R) (hPJ : P < J) : J = ⊤"
        },
        {
          "sim_score": 0.6226035356521606,
          "doc_string": "If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`.",
          "statement": "theorem ideal.is_prime_map_C_of_is_prime {R : Type u} [comm_ring R] {P : ideal R} (H : P.is_prime) : (ideal.map polynomial.C P).is_prime"
        }
      ],
      "codex_time": 5.820907569985138,
      "search_time": 1.4874710789881647,
      "use_theorem_name": false
    },
    "outputs": [
      "{R : Type u} [CommRing R] [Fintype R] (I : Ideal R) (h : ∀ P : Ideal R, P ≤ I → P.is_prime → P = I ∨ P = ⊥) : I.is_maximal ",
      "{R : Type u} [CommRingₓₓ R] [Fintype R] (I : Ideal R) (h : ∀ P : Ideal R, P ≤ I → P.is_prime → P = I ∨ P = ⊥) : I.is_maximal ",
      "{R : Type u} [CommRingₓ R] [Fintype R] (I : Ideal R) (h : ∀ P : Ideal R, P ≤ I → P.is_prime → P = I ∨ P = ⊥) : I.is_maximal ",
      "{R : Type u} [CommRing R] [Fintypeₓ R] (I : Ideal R) (h : ∀ P : Ideal R, P ≤ I → P.is_prime → P = I ∨ P = ⊥) : I.is_maximal ",
      "{R : Type u} [CommRingₓₓ R] [Fintypeₓ R] (I : Ideal R) (h : ∀ P : Ideal R, P ≤ I → P.is_prime → P = I ∨ P = ⊥) : I.is_maximal ",
      "{R : Type u} [CommRingₓ R] [Fintypeₓ R] (I : Ideal R) (h : ∀ P : Ideal R, P ≤ I → P.is_prime → P = I ∨ P = ⊥) : I.is_maximal ",
      "{R : Type u} [CommRing R] (h : Fintype R) : ∀ P : Ideal R, P.is_prime → P.is_maximal ",
      "{R : Type u} [CommRingₓₓ R] (h : Fintype R) : ∀ P : Ideal R, P.is_prime → P.is_maximal ",
      "{R : Type u} [CommRingₓ R] (h : Fintype R) : ∀ P : Ideal R, P.is_prime → P.is_maximal ",
      "{R : Type u} [CommRing R] (h : Fintypeₓ R) : ∀ P : Ideal R, P.is_prime → P.is_maximal ",
      "{R : Type u} [CommRingₓₓ R] (h : Fintypeₓ R) : ∀ P : Ideal R, P.is_prime → P.is_maximal ",
      "{R : Type u} [CommRingₓ R] (h : Fintypeₓ R) : ∀ P : Ideal R, P.is_prime → P.is_maximal ",
      "{R : Type u} [CommRing R] [Fintype R] {P : Ideal R} (H : P.is_prime) : P.is_maximal ",
      "{R : Type u} [CommRingₓₓ R] [Fintype R] {P : Ideal R} (H : P.is_prime) : P.is_maximal ",
      "{R : Type u} [CommRingₓ R] [Fintype R] {P : Ideal R} (H : P.is_prime) : P.is_maximal ",
      "{R : Type u} [CommRing R] [Fintypeₓ R] {P : Ideal R} (H : P.is_prime) : P.is_maximal ",
      "{R : Type u} [CommRingₓₓ R] [Fintypeₓ R] {P : Ideal R} (H : P.is_prime) : P.is_maximal ",
      "{R : Type u} [CommRingₓ R] [Fintypeₓ R] {P : Ideal R} (H : P.is_prime) : P.is_maximal ",
      "{R : Type u} [CommRing R] [Fintype R] {P : Ideal R} (Prime : P.is_prime) : P.is_maximal ",
      "{R : Type u} [CommRingₓₓ R] [Fintype R] {P : Ideal R} (Prime : P.is_prime) : P.is_maximal ",
      "{R : Type u} [CommRingₓ R] [Fintype R] {P : Ideal R} (Prime : P.is_prime) : P.is_maximal ",
      "{R : Type u} [CommRing R] [Fintypeₓ R] {P : Ideal R} (Prime : P.is_prime) : P.is_maximal ",
      "{R : Type u} [CommRingₓₓ R] [Fintypeₓ R] {P : Ideal R} (Prime : P.is_prime) : P.is_maximal ",
      "{R : Type u} [CommRingₓ R] [Fintypeₓ R] {P : Ideal R} (Prime : P.is_prime) : P.is_maximal ",
      "{R : Type u} [CommRing R] [Fintype R] (p : Ideal R) (H : p.is_prime) : p.is_maximal ",
      "{R : Type u} [CommRingₓₓ R] [Fintype R] (p : Ideal R) (H : p.is_prime) : p.is_maximal ",
      "{R : Type u} [CommRingₓ R] [Fintype R] (p : Ideal R) (H : p.is_prime) : p.is_maximal ",
      "{R : Type u} [CommRing R] [Fintypeₓ R] (p : Ideal R) (H : p.is_prime) : p.is_maximal ",
      "{R : Type u} [CommRingₓₓ R] [Fintypeₓ R] (p : Ideal R) (H : p.is_prime) : p.is_maximal ",
      "{R : Type u} [CommRingₓ R] [Fintypeₓ R] (p : Ideal R) (H : p.is_prime) : p.is_maximal "
    ],
    "answer": "{R : Type _} [CommRingₓ R] [Fintype R] : ∀ (Idl : Ideal R), Idl.IsPrime → Idl.IsMaximal "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "finite_ring_prime_implies_maximal",
      "main_prompt": "In a finite commutative ring, all prime ideals are maximal.",
      "prompt": "Natural language version: \"In a finite commutative ring, all prime ideals are maximal.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 8.307035503996303,
      "use_theorem_name": false
    },
    "outputs": [
      "finite_comm_ring_prime_ideals_are_maximal { R : Type } [ CommRing R ] [ FiniteDimensional R ] :   ∀ I : Ideal R, Prime I → maximal I ",
      "finite_comm_ring_prime_ideals_are_maximal { R : Type } [ CommRingₓₓ R ] [ FiniteDimensional R ] :   ∀ I : Ideal R, Prime I → maximal I ",
      "finite_comm_ring_prime_ideals_are_maximal { R : Type } [ CommRingₓ R ] [ FiniteDimensional R ] :   ∀ I : Ideal R, Prime I → maximal I ",
      "finite_integral_domain_prime_ideal_is_maximal : todo (G) Move to Mathlib section.   -- Def. 9.3. A Ring R is a Boolean Ring if  -- (a) R is a commutative Ring,  -- (b) 1 + 1 = 0 and 0 + 1 = 1,  -- (c) x∈ R, if and only if, 1 + x = 1.   -- Important examples are: (ℤ2 , +mod2, *mod2), (ℚ, +, ⋅) and ((0, 1), +, ⋅). We will call these --",
      "finite_integral_domain_prime_ideal_is_maximal : todo (G) Move to Mathlib section.   -- Def. 9.3. A Ringₓₓ R is a Boolean Ringₓₓ if  -- (a) R is a commutative Ringₓₓ,  -- (b) 1 + 1 = 0 and 0 + 1 = 1,  -- (c) x∈ R, if and only if, 1 + x = 1.   -- Important examples are: (ℤ2 , +mod2, *mod2), (ℚ, +, ⋅) and ((0, 1), +, ⋅). We will call these --",
      "finite_integral_domain_prime_ideal_is_maximal : todo (G) Move to Mathlib section.   -- Def. 9.3. A Ringₓ R is a Boolean Ringₓ if  -- (a) R is a commutative Ringₓ,  -- (b) 1 + 1 = 0 and 0 + 1 = 1,  -- (c) x∈ R, if and only if, 1 + x = 1.   -- Important examples are: (ℤ2 , +mod2, *mod2), (ℚ, +, ⋅) and ((0, 1), +, ⋅). We will call these --",
      "fin_comm_ring_all_primes_are_maximal (R : Type*) [CommRing R] (Hfin : IsNoetherianRing R) : all_primes_are_maximal R ",
      "fin_comm_ring_all_primes_are_maximal (R : Type*) [CommRingₓₓ R] (Hfin : IsNoetherianRing R) : all_primes_are_maximal R ",
      "fin_comm_ring_all_primes_are_maximal (R : Type*) [CommRingₓ R] (Hfin : IsNoetherianRing R) : all_primes_are_maximal R ",
      "exists_max_prime ( R : Type ) [ integral_domain R ] : ∃ a : Ideal R , a . Prime ∧ ∃ x : Ideal R , x . maximal ∧ x = a ",
      "lemma1 ( R : Type ) [ Ring R ] : Finite R →   ∀ x , Prime R x → maximal R x . Translate the Lean mathlib version to a computer science version:  def lemma1 ( R : Type ) [ Ring R ] : Finite R →    ∀ x , Prime R x → maximal R x . You can now run lemma1 as follows:  run_cmd tactic.trace.run_tactic $ lemma1 .  The formal proof above was obtained using the [Lean] framework. The formal proof itself is included in [this file]. Please see the paper for a version which is more human readable.  Almost everything in a Lean file",
      "lemma1 ( R : Type ) [ Ringₓₓ R ] : Finite R →   ∀ x , Prime R x → maximal R x . Translate the Lean mathlib version to a computer science version:  def lemma1 ( R : Type ) [ Ringₓₓ R ] : Finite R →    ∀ x , Prime R x → maximal R x . You can now run lemma1 as follows:  run_cmd tactic.trace.run_tactic $ lemma1 .  The formal proof above was obtained using the [Lean] framework. The formal proof itself is included in [this file]. Please see the paper for a version which is more human readable.  Almost everything in a Lean file",
      "lemma1 ( R : Type ) [ Ringₓ R ] : Finite R →   ∀ x , Prime R x → maximal R x . Translate the Lean mathlib version to a computer science version:  def lemma1 ( R : Type ) [ Ringₓ R ] : Finite R →    ∀ x , Prime R x → maximal R x . You can now run lemma1 as follows:  run_cmd tactic.trace.run_tactic $ lemma1 .  The formal proof above was obtained using the [Lean] framework. The formal proof itself is included in [this file]. Please see the paper for a version which is more human readable.  Almost everything in a Lean file"
    ],
    "answer": "{R : Type _} [CommRingₓ R] [Fintype R] : ∀ (Idl : Ideal R), Idl.IsPrime → Idl.IsMaximal "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "hausdorff_iff_diag_closed",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.",
      "codex_time": 7.985844911017921,
      "use_theorem_name": false
    },
    "outputs": [
      "(X : Type*) [TopologicalSpace X] :  IsClosed {p : X × X | p.1 = p.2} ↔ is_Hausdorff X ",
      "(X : Type*) [TopologicalSpace X] :  hausdorff X ↔ IsClosed (@set.diagonal X) ",
      "(X : Type*) [TopologicalSpace X] : haussdorff_space X ↔ IsClosed {p : X × X | p.1 = p.2} ",
      "(X : Type*) [TopologicalSpace X]:  ¬IsEmpty X → ∀ x y : X, IsClosed {p : X × X | p.1 = p.2 } ↔ is_Hausdorff X ",
      "(X : Type*) [Hausdorff : TopologicalSpace X] :  IsClosed (set.prod X X) "
    ],
    "answer": "{X : Type _} [TopologicalSpace X] : T2Space X ↔ IsClosed (Set.Diagonal X) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "hausdorff_iff_diag_closed",
      "main_prompt": "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.",
      "prompt": "Natural language version: \"The Hausdorff edistance between sets or their closures is the same\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [pseudo_emetric_space α] {s t : set α} :\nemetric.Hausdorff_edist (closure s) (closure t) = emetric.Hausdorff_edist s t := \n\nNatural language version: \"Two closed sets are at zero Hausdorff distance if and only if they coincide\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [pseudo_metric_space α] {s t : set α} (hs : is_closed s) (ht : is_closed t) (fin : emetric.Hausdorff_edist s t ≠ ⊤) :\nmetric.Hausdorff_dist s t = 0 ↔ s = t := \n\nNatural language version: \"Two closed sets are at zero Hausdorff edistance if and only if they coincide\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [pseudo_emetric_space α] {s t : set α} (hs : is_closed s) (ht : is_closed t) :\nemetric.Hausdorff_edist s t = 0 ↔ s = t := \n\nNatural language version: \"Replacing a set by its closure does not change the Hausdorff edistance.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [pseudo_emetric_space α] {s t : set α} :\nemetric.Hausdorff_edist s (closure t) = emetric.Hausdorff_edist s t := \n\nNatural language version: \"A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5625295639038086,
          "doc_string": "The Hausdorff edistance between sets or their closures is the same",
          "statement": "theorem emetric.Hausdorff_edist_closure {α : Type u} [pseudo_emetric_space α] {s t : set α} : emetric.Hausdorff_edist (closure s) (closure t) = emetric.Hausdorff_edist s t"
        },
        {
          "sim_score": 0.5602964162826538,
          "doc_string": "Two closed sets are at zero Hausdorff distance if and only if they coincide",
          "statement": "theorem is_closed.Hausdorff_dist_zero_iff_eq {α : Type u} [pseudo_metric_space α] {s t : set α} (hs : is_closed s) (ht : is_closed t) (fin : emetric.Hausdorff_edist s t ≠ ⊤) : metric.Hausdorff_dist s t = 0 ↔ s = t"
        },
        {
          "sim_score": 0.5491901636123657,
          "doc_string": "Two closed sets are at zero Hausdorff edistance if and only if they coincide",
          "statement": "theorem emetric.Hausdorff_edist_zero_iff_eq_of_closed {α : Type u} [pseudo_emetric_space α] {s t : set α} (hs : is_closed s) (ht : is_closed t) : emetric.Hausdorff_edist s t = 0 ↔ s = t"
        },
        {
          "sim_score": 0.5290781259536743,
          "doc_string": "Replacing a set by its closure does not change the Hausdorff edistance.",
          "statement": "theorem emetric.Hausdorff_edist_closure₂ {α : Type u} [pseudo_emetric_space α] {s t : set α} : emetric.Hausdorff_edist s (closure t) = emetric.Hausdorff_edist s t"
        }
      ],
      "codex_time": 6.471322034980403,
      "search_time": 1.3948053639905993,
      "use_theorem_name": false
    },
    "outputs": [
      "{X : Type u} [TopologicalSpace X] : IsClosed (set.prod X X) (set.diag X) ↔ hausdorff X ",
      "{α : Type u} (X : α → Type v) [Π x, TopologicalSpace (X x)] : Π (x : X), IsClosed (set.prod X.univ X.univ.image (λ y : X, (x, y))) ↔ is_Hausdorff X ",
      "{X : Type u} [TopologicalSpace X] : IsClosed (diagonal X) ↔ is_Hausdorff X ",
      "[TopologicalSpace α] (ht : t2_space α) : Hausdorff_space α ↔ IsClosed (diagonal : Set (α × α)) ",
      "[TopologicalSpace α] (ht : t2_space α) : Hausdorff_space α ↔ IsClosed (diagonal : Setₓ (α × α)) ",
      "{α : Type u} [t : TopologicalSpace α] : t.is_Hausdorff ↔ IsClosed (diagonal α) "
    ],
    "answer": "{X : Type _} [TopologicalSpace X] : T2Space X ↔ IsClosed (Set.Diagonal X) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "hausdorff_iff_diag_closed",
      "main_prompt": "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.",
      "prompt": "Natural language version: \"A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 4.559409334004158,
      "use_theorem_name": false
    },
    "outputs": [
      "t2 : Hausdorff ↔ ∀ X , IsClosed (diagonal X) ",
      "hausdorff_iff_diagonalf_is_closed : hausdorff X ↔ IsClosed (λ p : X × X, p.fst = p.snd) ",
      "not_iff : (∀ (a b:Setoid α), a ⊆ b ↔ a ∩ b = a) → False ",
      "not_iff : (∀ (a b:Setoidₓ α), a ⊆ b ↔ a ∩ b = a) → False ",
      "diag_closed_iff_hausdorff {X : Type *} [TopologicalSpace X] :  IsClosed {p : X × X | p.1 = p.2} ↔ hausdorff X ",
      "diag_closed {X : Type*} [T : TopologicalSpace X] [H : T] : IsClosed (set.diag X) "
    ],
    "answer": "{X : Type _} [TopologicalSpace X] : T2Space X ↔ IsClosed (Set.Diagonal X) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "open_iff_open_nhd_all_pt",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"If every point of a subset of a topological space is contained in some open set, the subset itself is open.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If every point of a subset of a topological space is contained in some open set, the subset itself is open.",
      "codex_time": 8.631500621006126,
      "use_theorem_name": false
    },
    "outputs": [
      "(X : Type*) [TopologicalSpace X]  (A : Set X) (hA : ∀ x ∈ A, ∃ U : Set X, IsOpen U ∧ x ∈ U) : IsOpen A ",
      "(X : Type*) [TopologicalSpace X]  (A : Setₓ X) (hA : ∀ x ∈ A, ∃ U : Setₓ X, IsOpen U ∧ x ∈ U) : IsOpen A ",
      "(X : Type*) [TopologicalSpace X]  (A : Set X) (hA : ∀ x, x ∈ A → ∃ U : Set X, IsOpen U ∧ x ∈ U) :  IsOpen A ",
      "(X : Type*) [TopologicalSpace X]  (A : Setₓ X) (hA : ∀ x, x ∈ A → ∃ U : Setₓ X, IsOpen U ∧ x ∈ U) :  IsOpen A ",
      "(X : Type*) [TopologicalSpace X]  (A : Set X) (hA : ∀ x ∈ A, ∃ U : Set X, IsOpen U ∧ x ∈ U):  IsOpen A ",
      "(X : Type*) [TopologicalSpace X]  (A : Setₓ X) (hA : ∀ x ∈ A, ∃ U : Setₓ X, IsOpen U ∧ x ∈ U):  IsOpen A ",
      "(X : Type*) [TopologicalSpace X]  (A : Set X) (hA : ∀ x ∈ A, ∃ U : Set X, IsOpen U ∧ x ∈ U):  IsOpen A ",
      "(X : Type*) [TopologicalSpace X]  (A : Setₓ X) (hA : ∀ x ∈ A, ∃ U : Setₓ X, IsOpen U ∧ x ∈ U):  IsOpen A ",
      "(X : Type*) [TopologicalSpace X]  (A : Set X) (hA : ∀ x ∈ A, ∃ U : Set X, IsOpen U ∧ x ∈ U):  IsOpen A ",
      "(X : Type*) [TopologicalSpace X]  (A : Setₓ X) (hA : ∀ x ∈ A, ∃ U : Setₓ X, IsOpen U ∧ x ∈ U):  IsOpen A "
    ],
    "answer": "{X : Type _} [TopologicalSpace X] (S : Set X) : (∀ x ∈ S, ∃ U : Set X, IsOpen U) → IsOpen S "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "open_iff_open_nhd_all_pt",
      "main_prompt": "If every point of a subset of a topological space is contained in some open set, the subset itself is open.",
      "prompt": "Natural language version: \" A predicate is true in a neighborhood of `a` iff it is true for all the points in an open set containing `a`.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [topological_space α] {a : α} {p : α → Prop} :\n(∀ᶠ (x : α) in nhds a, p x) ↔ ∃ (t : set α), (∀ (x : α), x ∈ t → p x) ∧ is_open t ∧ a ∈ t := \n\nNatural language version: \"Given an open finite set `S` in a T₀ space, there is some `x ∈ S` such that `{x}` is open.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [topological_space α] [t0_space α] {s : set α} (hfin : s.finite) (hne : s.nonempty) (ho : is_open s) :\n∃ (x : α) (H : x ∈ s), is_open {x} := \n\nNatural language version: \" If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s: it contains an open set containing `s`.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [topological_space α] {s U : set α} (h : U ∈ ⨆ (x : α) (H : x ∈ s), nhds x) :\n∃ (V : set α), s ⊆ V ∧ is_open V ∧ V ⊆ U := \n\nNatural language version: \" If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`: it contains an open set containing `s`.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [topological_space α] {s U : set α} (h : ∀ (x : α), x ∈ s → U ∈ nhds x) :\n∃ (V : set α), s ⊆ V ∧ is_open V ∧ V ⊆ U := \n\nNatural language version: \"If every point of a subset of a topological space is contained in some open set, the subset itself is open.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.624941349029541,
          "doc_string": " A predicate is true in a neighborhood of `a` iff it is true for all the points in an open set containing `a`.",
          "statement": "theorem eventually_nhds_iff {α : Type u} [topological_space α] {a : α} {p : α → Prop} : (∀ᶠ (x : α) in nhds a, p x) ↔ ∃ (t : set α), (∀ (x : α), x ∈ t → p x) ∧ is_open t ∧ a ∈ t"
        },
        {
          "sim_score": 0.619118332862854,
          "doc_string": "Given an open finite set `S` in a T₀ space, there is some `x ∈ S` such that `{x}` is open.",
          "statement": "theorem exists_open_singleton_of_open_finite {α : Type u} [topological_space α] [t0_space α] {s : set α} (hfin : s.finite) (hne : s.nonempty) (ho : is_open s) : ∃ (x : α) (H : x ∈ s), is_open {x}"
        },
        {
          "sim_score": 0.6141307353973389,
          "doc_string": " If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s: it contains an open set containing `s`.",
          "statement": "theorem exists_open_set_nhds' {α : Type u} [topological_space α] {s U : set α} (h : U ∈ ⨆ (x : α) (H : x ∈ s), nhds x) : ∃ (V : set α), s ⊆ V ∧ is_open V ∧ V ⊆ U"
        },
        {
          "sim_score": 0.6101160645484924,
          "doc_string": " If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`: it contains an open set containing `s`.",
          "statement": "theorem exists_open_set_nhds {α : Type u} [topological_space α] {s U : set α} (h : ∀ (x : α), x ∈ s → U ∈ nhds x) : ∃ (V : set α), s ⊆ V ∧ is_open V ∧ V ⊆ U"
        }
      ],
      "codex_time": 4.460379459982505,
      "search_time": 1.332091069984017,
      "use_theorem_name": false
    },
    "outputs": [
      "{α : Type u} [TopologicalSpace α] {s : Set α} (h : ∀ (x : α), x ∈ s → ∃ (u : Set α), u ⊆ s ∧ IsOpen u) : IsOpen s ",
      "{α : Type u} [TopologicalSpace α] {s : Setₓ α} (h : ∀ (x : α), x ∈ s → ∃ (u : Setₓ α), u ⊆ s ∧ IsOpen u) : IsOpen s ",
      "{α : Type*} [TopologicalSpace α] {s : Set α} (h : ∀ (x : α), x ∈ s → ∃ (t : Set α), (∀ (y : α), y ∈ t → y ∈ s) ∧ IsOpen t ∧ x ∈ t) :  IsOpen s ",
      "{α : Type*} [TopologicalSpace α] {s : Setₓ α} (h : ∀ (x : α), x ∈ s → ∃ (t : Setₓ α), (∀ (y : α), y ∈ t → y ∈ s) ∧ IsOpen t ∧ x ∈ t) :  IsOpen s ",
      "{α : Type u} [TopologicalSpace α] {s : Set α} (h : ∀ (x : α), x ∈ s → ∃ (u : Set α), IsOpen u ∧ x ∈ u) : IsOpen s ",
      "{α : Type u} [TopologicalSpace α] {s : Setₓ α} (h : ∀ (x : α), x ∈ s → ∃ (u : Setₓ α), IsOpen u ∧ x ∈ u) : IsOpen s ",
      "{α : Type u} [TopologicalSpace α] {s : Set α} (h : ∀ (x : α), x ∈ s → ∃ (t : Set α), x ∈ t ∧ IsOpen t) : IsOpen s ",
      "{α : Type u} [TopologicalSpace α] {s : Setₓ α} (h : ∀ (x : α), x ∈ s → ∃ (t : Setₓ α), x ∈ t ∧ IsOpen t) : IsOpen s ",
      "{α : Type u} [TopologicalSpace α] {s : Set α} {p : α → Prop} (h : ∀ (x : α), (x ∈ s) → ∃ (V : Set α), IsOpen V ∧ x ∈ V): IsOpen s ",
      "{α : Type u} [TopologicalSpace α] {s : Setₓ α} {p : α → Prop} (h : ∀ (x : α), (x ∈ s) → ∃ (V : Setₓ α), IsOpen V ∧ x ∈ V): IsOpen s "
    ],
    "answer": "{X : Type _} [TopologicalSpace X] (S : Set X) : (∀ x ∈ S, ∃ U : Set X, IsOpen U) → IsOpen S "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "open_iff_open_nhd_all_pt",
      "main_prompt": "If every point of a subset of a topological space is contained in some open set, the subset itself is open.",
      "prompt": "Natural language version: \"If every point of a subset of a topological space is contained in some open set, the subset itself is open.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 7.866904499998782,
      "use_theorem_name": false
    },
    "outputs": [
      "open_subset_iff (s : Set α) : IsOpen s ↔ ∀t ∈ s, ∃u, IsOpen u ∧ t ∈ u ∧ u ⊆ s ",
      "open_subset_iff (s : Setₓ α) : IsOpen s ↔ ∀t ∈ s, ∃u, IsOpen u ∧ t ∈ u ∧ u ⊆ s ",
      "subset_of_topological_space_is_open {x : Set ℝ} (a : Set x) (h : ∀b ∈ a, ∃c : Set ℝ, c ∈ 𝓝[x] b ∧ (c ∈ 𝓤ₛ)) : a ∈ 𝓤ₛ ",
      "subset_of_topological_space_is_open {x : Setₓ ℝ} (a : Setₓ x) (h : ∀b ∈ a, ∃c : Setₓ ℝ, c ∈ 𝓝[x] b ∧ (c ∈ 𝓤ₛ)) : a ∈ 𝓤ₛ ",
      "filter.forall { α : Type * } [ TopologicalSpace α ] { s : Set α } : IsOpen s ↔ ( ∀ ( x : α ), x ∈ s → ∃ ( t : Set α ) ( h : IsOpen t ), x ∈ t ∧ t ⊆ s ) ",
      "filter.forall { α : Type * } [ TopologicalSpace α ] { s : Setₓ α } : IsOpen s ↔ ( ∀ ( x : α ), x ∈ s → ∃ ( t : Setₓ α ) ( h : IsOpen t ), x ∈ t ∧ t ⊆ s ) ",
      "(h : TopologicalSpace X) (s : Set X) (G : ∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U) : IsOpen s ",
      "(h : TopologicalSpace X) (s : Setₓ X) (G : ∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U) : IsOpen s ",
      "subset_open_iff_forall_mem_open : sorry "
    ],
    "answer": "{X : Type _} [TopologicalSpace X] (S : Set X) : (∀ x ∈ S, ∃ U : Set X, IsOpen U) → IsOpen S "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "complex_conj_prod_real",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"The product of a complex number with its conjugate is a real number.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The product of a complex number with its conjugate is a real number.",
      "codex_time": 4.236629835009808,
      "use_theorem_name": false
    },
    "outputs": [
      "(α : Type*) [Ring α] [discrete_field α]  (α_inhab : Nonempty α) (x : α) : ∥x∥ ^ 2 = x * x ",
      "(α : Type*) [Ringₓₓ α] [discrete_field α]  (α_inhab : Nonempty α) (x : α) : ∥x∥ ^ 2 = x * x ",
      "(α : Type*) [Ringₓ α] [discrete_field α]  (α_inhab : Nonempty α) (x : α) : ∥x∥ ^ 2 = x * x ",
      "(z : ℂ) : z*conj z = z.re*(z.re) + z.im*(z.im) ",
      "(z : ℂ) :  ∃ r : ℝ, r = z * conj z ",
      "(z : ℂ) : is_real (z * conj z) ",
      "(z : ℂ) : z * z.conj = z.norm_sq "
    ],
    "answer": ": ∀ z : ℂ, ∃ r : ℝ, z * (starRingEnd ℂ $ z) = (r : ℂ) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "complex_conj_prod_real",
      "main_prompt": "The product of a complex number with its conjugate is a real number.",
      "prompt": "Natural language version: \"A complex number `z` plus its conjugate `conj z` is `2` times its real part.\" Translate the natural language version to a Lean mathlib version:\n theorem (z : ℂ) :\n↑(z.re) = (z + ⇑(star_ring_end ℂ) z) / 2 := \n\nNatural language version: \"A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part.\" Translate the natural language version to a Lean mathlib version:\n theorem (z : ℂ) :\n↑(z.im) = (z - ⇑(star_ring_end ℂ) z) / (2 * complex.I) := \n\nNatural language version: \" A linear operator on a complex inner product space is self-adjoint precisely when `⟪T v, v⟫_ℂ` is real for all v.\" Translate the natural language version to a Lean mathlib version:\n theorem {V : Type u_4} [inner_product_space ℂ V] (T : V →ₗ[ℂ] V) :\ninner_product_space.is_self_adjoint T ↔ ∀ (v : V), ⇑(star_ring_end ℂ) (has_inner.inner (⇑T v) v) = has_inner.inner (⇑T v) v := \n\nNatural language version: \"Polarization identity: The real part of the  inner product, in terms of the norm.\" Translate the natural language version to a Lean mathlib version:\n theorem {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) :\n⇑is_R_or_C.re (has_inner.inner x y) = (∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ - ∥x - y∥ * ∥x - y∥) / 2 := \n\nNatural language version: \"The product of a complex number with its conjugate is a real number.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6665807962417603,
          "doc_string": "A complex number `z` plus its conjugate `conj z` is `2` times its real part.",
          "statement": "theorem complex.re_eq_add_conj (z : ℂ) : ↑(z.re) = (z + ⇑(star_ring_end ℂ) z) / 2"
        },
        {
          "sim_score": 0.6368286609649658,
          "doc_string": "A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part.",
          "statement": "theorem complex.im_eq_sub_conj (z : ℂ) : ↑(z.im) = (z - ⇑(star_ring_end ℂ) z) / (2 * complex.I)"
        },
        {
          "sim_score": 0.5591109395027161,
          "doc_string": " A linear operator on a complex inner product space is self-adjoint precisely when `⟪T v, v⟫_ℂ` is real for all v.",
          "statement": "theorem inner_product_space.is_self_adjoint_iff_inner_map_self_real {V : Type u_4} [inner_product_space ℂ V] (T : V →ₗ[ℂ] V) : inner_product_space.is_self_adjoint T ↔ ∀ (v : V), ⇑(star_ring_end ℂ) (has_inner.inner (⇑T v) v) = has_inner.inner (⇑T v) v"
        },
        {
          "sim_score": 0.48265978693962097,
          "doc_string": "Polarization identity: The real part of the  inner product, in terms of the norm.",
          "statement": "theorem re_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) : ⇑is_R_or_C.re (has_inner.inner x y) = (∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ - ∥x - y∥ * ∥x - y∥) / 2"
        }
      ],
      "codex_time": 6.301921194011811,
      "search_time": 1.3324739320087247,
      "use_theorem_name": false
    },
    "outputs": [
      "(z : ℂ) : ⇑is_R_or_C.re (star_ring.star_ring_hom.star_ring_hom_map ℂ Star (⇑z * ⇑(starRingEnd ℂ) z)) = ⇑z * ⇑(starRingEnd ℂ) z ",
      "(z : ℂ) : ↑(⇑(starRingEnd ℂ) z * z) = ↑(z * ⋆z) ",
      "(x : ℂ) : ⇑is_R_or_C.re (x * (⇑(starRingEnd ℂ) x) ) = x.abs * x.abs ",
      "(z : ℂ) : is_R_or_C.re (z * z.conj) = z.abs^2 ",
      "(z : ℂ) : ↑(⇑(starRingEnd ℂ) z) = (↑z) * (↑z) "
    ],
    "answer": ": ∀ z : ℂ, ∃ r : ℝ, z * (starRingEnd ℂ $ z) = (r : ℂ) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "complex_conj_prod_real",
      "main_prompt": "The product of a complex number with its conjugate is a real number.",
      "prompt": "Natural language version: \"The product of a complex number with its conjugate is a real number.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 10.709482749021845,
      "use_theorem_name": false
    },
    "outputs": [
      "complex_conj_mul_real : ∀ (z : ℂ), (↑z * conjugate z) ∈ ℝ ,     // Reduce the theorem to a contractible goal:  from ⟨0.0, _, _⟩,    // finish the  proof with a Ring tactic:  Ring, end  /- The \\library{tidy} tactic is useful to solve a goal with a single \"master equation\" conjectured to be an equality.  For instance, consider the following goal:  -/  example {a b c d : ℝ} : a * b * d * c *",
      "complex_conj_mul_real : ∀ (z : ℂ), (↑z * conjugate z) ∈ ℝ ,     // Reduce the theorem to a contractible goal:  from ⟨0.0, _, _⟩,    // finish the  proof with a Ringₓₓ tactic:  Ringₓₓ, end  /- The \\library{tidy} tactic is useful to solve a goal with a single \"master equation\" conjectured to be an equality.  For instance, consider the following goal:  -/  example {a b c d : ℝ} : a * b * d * c *",
      "complex_conj_mul_real : ∀ (z : ℂ), (↑z * conjugate z) ∈ ℝ ,     // Reduce the theorem to a contractible goal:  from ⟨0.0, _, _⟩,    // finish the  proof with a Ringₓ tactic:  Ringₓ, end  /- The \\library{tidy} tactic is useful to solve a goal with a single \"master equation\" conjectured to be an equality.  For instance, consider the following goal:  -/  example {a b c d : ℝ} : a * b * d * c *",
      "prod_conj_real : ∀ (z : C), ∃ (r : ℝ), z * conj z = (r : C) ",
      "nlv_to_lmv ( z : ℂ ) : z * z.conj = z.norm * z.norm ",
      "mul_conj_real : ∀ (a b : ℂ), real (a * b) → a = b ",
      "Q : ∀z : ℂ, z * conj z = (Re z) ^ 2 + (Im z) ^ 2 "
    ],
    "answer": ": ∀ z : ℂ, ∃ r : ℝ, z * (starRingEnd ℂ $ z) = (r : ℂ) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "non_id_implies_infinite_order",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Every non-identity element of a free group is of infinite order.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every non-identity element of a free group is of infinite order.",
      "codex_time": 6.012982610001927,
      "use_theorem_name": false
    },
    "outputs": [
      "(G : Type*) [Group G] (x : G) [FreeGroup G] (hx : x ≠ 1) :  ∀ n : ℕ, x ^ n ≠ 1 ",
      "(G : Type*) [Groupₓₓ G] (x : G) [FreeGroup G] (hx : x ≠ 1) :  ∀ n : ℕ, x ^ n ≠ 1 ",
      "(G : Type*) [Groupₓ G] (x : G) [FreeGroup G] (hx : x ≠ 1) :  ∀ n : ℕ, x ^ n ≠ 1 ",
      "(G : Type*) [Group G] (f : FreeGroup G)  (x : G) (hx : x ≠ 1) : ∀ (n : ℕ), x ^ n ≠ 1 ",
      "(G : Type*) [Groupₓₓ G] (f : FreeGroup G)  (x : G) (hx : x ≠ 1) : ∀ (n : ℕ), x ^ n ≠ 1 ",
      "(G : Type*) [Groupₓ G] (f : FreeGroup G)  (x : G) (hx : x ≠ 1) : ∀ (n : ℕ), x ^ n ≠ 1 ",
      "(G : Type*) [Group G] (H : FreeGroup G) (n : ℕ)  (h : ∀ (x : G) (hx : x ≠ 1), (∃ (n : ℕ), x ^ n = 1) → n = 0) :  ∀ x : G, x ≠ 1 → ∃ n : ℕ, x ^ n ≠ 1 ",
      "(G : Type*) [Groupₓₓ G] (H : FreeGroup G) (n : ℕ)  (h : ∀ (x : G) (hx : x ≠ 1), (∃ (n : ℕ), x ^ n = 1) → n = 0) :  ∀ x : G, x ≠ 1 → ∃ n : ℕ, x ^ n ≠ 1 ",
      "(G : Type*) [Groupₓ G] (H : FreeGroup G) (n : ℕ)  (h : ∀ (x : G) (hx : x ≠ 1), (∃ (n : ℕ), x ^ n = 1) → n = 0) :  ∀ x : G, x ≠ 1 → ∃ n : ℕ, x ^ n ≠ 1 ",
      "(G : Type*) [Group G]  (f : Π n, FreeGroup (Fin n)) (hG : FreeGroup G) :  ∀ x : G, x ≠ 1 → ∃ n : ℕ, x ^ n ≠ 1 ",
      "(G : Type*) [Groupₓₓ G]  (f : Π n, FreeGroup (Fin n)) (hG : FreeGroup G) :  ∀ x : G, x ≠ 1 → ∃ n : ℕ, x ^ n ≠ 1 ",
      "(G : Type*) [Group G]  (f : Π n, FreeGroup (Finₓ n)) (hG : FreeGroup G) :  ∀ x : G, x ≠ 1 → ∃ n : ℕ, x ^ n ≠ 1 ",
      "(G : Type*) [Groupₓₓ G]  (f : Π n, FreeGroup (Finₓ n)) (hG : FreeGroup G) :  ∀ x : G, x ≠ 1 → ∃ n : ℕ, x ^ n ≠ 1 ",
      "(G : Type*) [Groupₓ G]  (f : Π n, FreeGroup (Fin n)) (hG : FreeGroup G) :  ∀ x : G, x ≠ 1 → ∃ n : ℕ, x ^ n ≠ 1 ",
      "(G : Type*) [Groupₓ G]  (f : Π n, FreeGroup (Finₓ n)) (hG : FreeGroup G) :  ∀ x : G, x ≠ 1 → ∃ n : ℕ, x ^ n ≠ 1 ",
      "(G : Type*) [Group G] (f : FreeGroup G):  ∀ a : G, a ≠ 1 → (∀ n : ℕ, f a ^ n ≠ 1) ∧ (∀ n : ℤ, f a ^ n ≠ 1) ",
      "(G : Type*) [Groupₓₓ G] (f : FreeGroup G):  ∀ a : G, a ≠ 1 → (∀ n : ℕ, f a ^ n ≠ 1) ∧ (∀ n : ℤ, f a ^ n ≠ 1) ",
      "(G : Type*) [Groupₓ G] (f : FreeGroup G):  ∀ a : G, a ≠ 1 → (∀ n : ℕ, f a ^ n ≠ 1) ∧ (∀ n : ℤ, f a ^ n ≠ 1) "
    ],
    "answer": "{G : Type _} [Groupₓ G] : FreeGroup G → (∀ g : G, g ≠ 1 → orderOf g = 0) "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "non_id_implies_infinite_order",
      "main_prompt": "Every non-identity element of a free group is of infinite order.",
      "prompt": "Natural language version: \" If two words correspond to the same element in the free group, then they have a common maximal reduction. This is the proof that the function that sends an element of the free group to its maximal reduction is well-defined.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.mk L₁ = free_group.mk L₂) :\nfree_group.reduce L₁ = free_group.reduce L₂ := \n\nNatural language version: \"A group element has finite order iff its order is positive.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u} {x : G} [monoid G] :\n0 < order_of x ↔ is_of_fin_order x := \n\nNatural language version: \"Inverses of elements of finite order have finite order.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u} [group G] {x : G} :\nis_of_fin_order x⁻¹ ↔ is_of_fin_order x := \n\nNatural language version: \"Inverses of elements of finite order have finite order.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u} [group G] {x : G} (hx : is_of_fin_order x) :\nis_of_fin_order x⁻¹ := \n\nNatural language version: \"Every non-identity element of a free group is of infinite order.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5920776724815369,
          "doc_string": " If two words correspond to the same element in the free group, then they have a common maximal reduction. This is the proof that the function that sends an element of the free group to its maximal reduction is well-defined.",
          "statement": "theorem free_group.reduce.sound {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.mk L₁ = free_group.mk L₂) : free_group.reduce L₁ = free_group.reduce L₂"
        },
        {
          "sim_score": 0.5908461809158325,
          "doc_string": "A group element has finite order iff its order is positive.",
          "statement": "theorem order_of_pos_iff {G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x"
        },
        {
          "sim_score": 0.5742547512054443,
          "doc_string": "Inverses of elements of finite order have finite order.",
          "statement": "theorem is_of_fin_order_inv_iff {G : Type u} [group G] {x : G} : is_of_fin_order x⁻¹ ↔ is_of_fin_order x"
        },
        {
          "sim_score": 0.5742547512054443,
          "doc_string": "Inverses of elements of finite order have finite order.",
          "statement": "theorem is_of_fin_order.inv {G : Type u} [group G] {x : G} (hx : is_of_fin_order x) : is_of_fin_order x⁻¹"
        }
      ],
      "codex_time": 5.115586811996764,
      "search_time": 1.338385823997669,
      "use_theorem_name": false
    },
    "outputs": [
      "{α : Type u} (L : List (α × Bool)) (n : ℕ) [DecidableEq α] : free_group.C x ≠ 1 ↔ x ≠ 1 ",
      "{α : Type u} (x : FreeGroup α) :  net.dense {i | FreeGroup.reduce i = FreeGroup.reduce (x^i)}   ",
      "{α : Type u} [DecidableEq α] (x : FreeGroup α) : x ≠ 1 → ¬IsOfFinOrder x ",
      "{α : Type u} {L : List (α × Bool)}   (h : ∃(t : α × Bool) (h : t ∈ L), t ≠ (0, bor t.2 tt)) :  ∀(t : α × Bool) (h : t ∈ L), ¬ IsOfFinOrder (FreeGroup.mk L) ",
      "free_group.is_of_inf_order_of_not_is_one : ∀ {α : Type u} [DecidableEq α] (a : FreeGroup α), a ≠ 1 → is_of_inf_order a "
    ],
    "answer": "{G : Type _} [Groupₓ G] : FreeGroup G → (∀ g : G, g ≠ 1 → orderOf g = 0) "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "non_id_implies_infinite_order",
      "main_prompt": "Every non-identity element of a free group is of infinite order.",
      "prompt": "Natural language version: \"Every non-identity element of a free group is of infinite order.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 6.021806073986227,
      "use_theorem_name": false
    },
    "outputs": [
      ": ∀ (G : Type*) [Group G] (h : G ≠ 1), ∃ x : G, x ≠ 1 ∧ x ≠ x⁻¹ ",
      ": ∀ (G : Type*) [Groupₓₓ G] (h : G ≠ 1), ∃ x : G, x ≠ 1 ∧ x ≠ x⁻¹ ",
      ": ∀ (G : Type*) [Groupₓ G] (h : G ≠ 1), ∃ x : G, x ≠ 1 ∧ x ≠ x⁻¹ ",
      "free_group_non_identity_has_infinite_order { G : Type } [ Group G ] [ is_free G ] [ is_set G ] ( g : G ) ( h : g ≠ 1 ) :    ∀  n : ℕ, ( g ^ ( n ) ≠ 1 ) ",
      "free_group_non_identity_has_infinite_order { G : Type } [ Groupₓₓ G ] [ is_free G ] [ is_set G ] ( g : G ) ( h : g ≠ 1 ) :    ∀  n : ℕ, ( g ^ ( n ) ≠ 1 ) ",
      "free_group_non_identity_has_infinite_order { G : Type } [ Groupₓ G ] [ is_free G ] [ is_set G ] ( g : G ) ( h : g ≠ 1 ) :    ∀  n : ℕ, ( g ^ ( n ) ≠ 1 ) ",
      "free_group.no_torsion {G : Type*} [Group G] (H : ∀ {x : G}, x ≠ 1 → ∀ n : ℕ, x ^ n ≠ 1) : ∀ {g : G}, g ≠ 1 → ∞ ≠ g ",
      "free_group.no_torsion {G : Type*} [Groupₓₓ G] (H : ∀ {x : G}, x ≠ 1 → ∀ n : ℕ, x ^ n ≠ 1) : ∀ {g : G}, g ≠ 1 → ∞ ≠ g ",
      "free_group.no_torsion {G : Type*} [Groupₓ G] (H : ∀ {x : G}, x ≠ 1 → ∀ n : ℕ, x ^ n ≠ 1) : ∀ {g : G}, g ≠ 1 → ∞ ≠ g ",
      "FreeGroup . nnthm : Π { β : Type } [ α : β → Type ] [ _ inst_2 : Group α ] [ _ inst_3 : FreeGroup α ] ( x : β ), x ≠ 1 → ∞ ∣ order x ",
      "FreeGroup . nnthm : Π { β : Type } [ α : β → Type ] [ _ inst_2 : Groupₓₓ α ] [ _ inst_3 : FreeGroup α ] ( x : β ), x ≠ 1 → ∞ ∣ order x ",
      "FreeGroup . nnthm : Π { β : Type } [ α : β → Type ] [ _ inst_2 : Groupₓ α ] [ _ inst_3 : FreeGroup α ] ( x : β ), x ≠ 1 → ∞ ∣ order x ",
      "my_infinite_order_mathlib : ∀ (X : Type) (S : Set X) [IsFreeGroup S]     (f : X), f ≠ 1 → order f = ⊤ ",
      "my_infinite_order_mathlib : ∀ (X : Type) (S : Setₓ X) [IsFreeGroup S]     (f : X), f ≠ 1 → order f = ⊤ "
    ],
    "answer": "{G : Type _} [Groupₓ G] : FreeGroup G → (∀ g : G, g ≠ 1 → orderOf g = 0) "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "sub_ring_field_with_id_is_int_domain",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"Any sub-ring of a field that contains the identity is an integral domain\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Any sub-ring of a field that contains the identity is an integral domain",
      "codex_time": 6.164875899994513,
      "use_theorem_name": false
    },
    "outputs": [
      "(R : Type*) [Ring R] (I : Ideal R)  [is_subring I] (hI : (1 : R) ∈ I) :  integral_domain I ",
      "(R : Type*) [Ringₓₓ R] (I : Ideal R)  [is_subring I] (hI : (1 : R) ∈ I) :  integral_domain I ",
      "(R : Type*) [Ringₓ R] (I : Ideal R)  [is_subring I] (hI : (1 : R) ∈ I) :  integral_domain I ",
      "(A : Type*) (K : Type*) [integral_domain K]  [CommRing A] [Algebra K A] (h : 1 ∈ A) : integral_domain A ",
      "(A : Type*) (K : Type*) [integral_domain K]  [CommRingₓₓ A] [Algebra K A] (h : 1 ∈ A) : integral_domain A ",
      "(A : Type*) (K : Type*) [integral_domain K]  [CommRingₓ A] [Algebra K A] (h : 1 ∈ A) : integral_domain A ",
      "(R : Type*) [CommRing R] (S : Set R) [is_subring S]  (hS_i : 1 ∈ S) : is_integral_domain S ",
      "(R : Type*) [CommRingₓₓ R] (S : Set R) [is_subring S]  (hS_i : 1 ∈ S) : is_integral_domain S ",
      "(R : Type*) [CommRing R] (S : Setₓ R) [is_subring S]  (hS_i : 1 ∈ S) : is_integral_domain S ",
      "(R : Type*) [CommRingₓₓ R] (S : Setₓ R) [is_subring S]  (hS_i : 1 ∈ S) : is_integral_domain S ",
      "(R : Type*) [CommRingₓ R] (S : Set R) [is_subring S]  (hS_i : 1 ∈ S) : is_integral_domain S ",
      "(R : Type*) [CommRingₓ R] (S : Setₓ R) [is_subring S]  (hS_i : 1 ∈ S) : is_integral_domain S ",
      "(F : Type*) (B : Type*) [Ring F] [Subring B]  (h1 : 1 ∈ B) :  integral_domain B ",
      "(F : Type*) (B : Type*) [Ringₓₓ F] [Subring B]  (h1 : 1 ∈ B) :  integral_domain B ",
      "(F : Type*) (B : Type*) [Ringₓ F] [Subring B]  (h1 : 1 ∈ B) :  integral_domain B ",
      "(R : Type*) [Ring R] [Field R] (A : Set R) [is_subring A] (H : (1:R) ∈ A) :  integral_domain A ",
      "(R : Type*) [Ringₓₓ R] [Field R] (A : Set R) [is_subring A] (H : (1:R) ∈ A) :  integral_domain A ",
      "(R : Type*) [Ring R] [Field R] (A : Setₓ R) [is_subring A] (H : (1:R) ∈ A) :  integral_domain A ",
      "(R : Type*) [Ringₓₓ R] [Field R] (A : Setₓ R) [is_subring A] (H : (1:R) ∈ A) :  integral_domain A ",
      "(R : Type*) [Ringₓ R] [Field R] (A : Set R) [is_subring A] (H : (1:R) ∈ A) :  integral_domain A ",
      "(R : Type*) [Ringₓ R] [Field R] (A : Setₓ R) [is_subring A] (H : (1:R) ∈ A) :  integral_domain A "
    ],
    "answer": "{F : Type _} [Field F] : ∀ R : Subring F, 1 ∈ R.Carrier → IsDomain ↥R "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "sub_ring_field_with_id_is_int_domain",
      "main_prompt": "Any sub-ring of a field that contains the identity is an integral domain",
      "prompt": "Natural language version: \"A subfield is closed under inverses.\" Translate the natural language version to a Lean mathlib version:\n theorem {K : Type u} [field K] (s : subfield K) {x : K} :\nx ∈ s → x⁻¹ ∈ s := \n\nNatural language version: \"A subring contains the ring's 1.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [ring R] (s : subring R) :\n1 ∈ s := \n\nNatural language version: \"A subring contains the ring's 0.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [ring R] (s : subring R) :\n0 ∈ s := \n\nNatural language version: \"A subfield is closed under division.\" Translate the natural language version to a Lean mathlib version:\n theorem {K : Type u} [field K] (s : subfield K) {x y : K} :\nx ∈ s → y ∈ s → x / y ∈ s := \n\nNatural language version: \"Any sub-ring of a field that contains the identity is an integral domain\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6670852899551392,
          "doc_string": "A subfield is closed under inverses.",
          "statement": "theorem subfield.inv_mem {K : Type u} [field K] (s : subfield K) {x : K} : x ∈ s → x⁻¹ ∈ s"
        },
        {
          "sim_score": 0.6393297910690308,
          "doc_string": "A subring contains the ring's 1.",
          "statement": "theorem subring.one_mem {R : Type u} [ring R] (s : subring R) : 1 ∈ s"
        },
        {
          "sim_score": 0.6295010447502136,
          "doc_string": "A subring contains the ring's 0.",
          "statement": "theorem subring.zero_mem {R : Type u} [ring R] (s : subring R) : 0 ∈ s"
        },
        {
          "sim_score": 0.6208624243736267,
          "doc_string": "A subfield is closed under division.",
          "statement": "theorem subfield.div_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x / y ∈ s"
        }
      ],
      "codex_time": 9.568462060997263,
      "search_time": 1.3781938120082486,
      "use_theorem_name": false
    },
    "outputs": [
      "{R : Type u} [Ring R] (s : Subring R) [Field K] (homK : K → R) (h : ∀ x : K, 0 ≠ x → homK x ≠ 0) (h1 : homK 1 ∈ s) :  integral_domain s ",
      "{R : Type u} [Ringₓₓ R] (s : Subring R) [Field K] (homK : K → R) (h : ∀ x : K, 0 ≠ x → homK x ≠ 0) (h1 : homK 1 ∈ s) :  integral_domain s ",
      "{R : Type u} [Ringₓ R] (s : Subring R) [Field K] (homK : K → R) (h : ∀ x : K, 0 ≠ x → homK x ≠ 0) (h1 : homK 1 ∈ s) :  integral_domain s ",
      "{K : Type u} [Field K] (s : Subring K) (H : 1 ∈ s) : integral_domain s ",
      "(K : Type u) [discrete_field K] {R : Set K} [is_subring R] (One : (1:K) ∈ R) :   is_integral_domain R ",
      "(K : Type u) [discrete_field K] {R : Setₓ K} [is_subring R] (One : (1:K) ∈ R) :   is_integral_domain R ",
      "{K : Type u} [Field K] (s : Subring K) (H1 : ∀ (a : K), a ∈ s → a⁻¹ ∈ s) (H2 : 1 ∈ s) : integral_domain s ",
      "{K : Type u} [Field K] (s : Subring K) (h₁ : 1 ∈ s) : integral_domain s "
    ],
    "answer": "{F : Type _} [Field F] : ∀ R : Subring F, 1 ∈ R.Carrier → IsDomain ↥R "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "sub_ring_field_with_id_is_int_domain",
      "main_prompt": "Any sub-ring of a field that contains the identity is an integral domain",
      "prompt": "Natural language version: \"Any sub-ring of a field that contains the identity is an integral domain\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 11.832734199007973,
      "use_theorem_name": false
    },
    "outputs": [
      "ideal_of_sub_set_of_int_der ( A B : Set R ) ( hA : additive_subgroup A )    ( hA_int_der : is_integral_derivation A R d ) ( hA_subs_B : A ⊆ B )    ( hB_field : Field B ) ( hB_subs_R : B ⊆ R ) :    is_integral_derivation B R d ∧ Field (der_sub_set hB_subs_R) ",
      "ideal_of_sub_set_of_int_der ( A B : Setₓ R ) ( hA : additive_subgroup A )    ( hA_int_der : is_integral_derivation A R d ) ( hA_subs_B : A ⊆ B )    ( hB_field : Field B ) ( hB_subs_R : B ⊆ R ) :    is_integral_derivation B R d ∧ Field (der_sub_set hB_subs_R) ",
      "subring_ring.is_integral_domain_of_field (h : subring_ring R) (Ho : 1 : R ≠ 0)  example : subring_ring R → is_integral_domain R ",
      "field_subring_integral {α : Type u} [Field α] {s : Set α} [is_subring s] (⊥ : 1 ∈ s) :   integral_domain s ",
      "field_subring_integral {α : Type u} [Field α] {s : Setₓ α} [is_subring s] (⊥ : 1 ∈ s) :   integral_domain s ",
      "any_subring_of_a_field_that_contains_the_id_is_integral : ∀ R : Type u_1, R → CommRing R → ∃ (L : Type u_2) (i_3 : integral_domain L),   (∃ (i_1 : R → L) (i_2 : L → R),      IsRingHom i_1 ∧ IsRingHom i_2 ∧ i_2 ∘ i_1 = id R) ",
      "any_subring_of_a_field_that_contains_the_id_is_integral : ∀ R : Type u_1, R → CommRingₓₓ R → ∃ (L : Type u_2) (i_3 : integral_domain L),   (∃ (i_1 : R → L) (i_2 : L → R),      IsRingHom i_1 ∧ IsRingHom i_2 ∧ i_2 ∘ i_1 = id R) ",
      "any_subring_of_a_field_that_contains_the_id_is_integral : ∀ R : Type u_1, R → CommRingₓ R → ∃ (L : Type u_2) (i_3 : integral_domain L),   (∃ (i_1 : R → L) (i_2 : L → R),      IsRingHom i_1 ∧ IsRingHom i_2 ∧ i_2 ∘ i_1 = id R) ",
      "is_int_dom_subring_of_field (R : Type) [CommRing R] [Field R] {I : Set R} [is_subring I] :    I ≠ ∅ → is_integral_domain I ",
      "is_int_dom_subring_of_field (R : Type) [CommRingₓₓ R] [Field R] {I : Set R} [is_subring I] :    I ≠ ∅ → is_integral_domain I ",
      "is_int_dom_subring_of_field (R : Type) [CommRing R] [Field R] {I : Setₓ R} [is_subring I] :    I ≠ ∅ → is_integral_domain I ",
      "is_int_dom_subring_of_field (R : Type) [CommRingₓₓ R] [Field R] {I : Setₓ R} [is_subring I] :    I ≠ ∅ → is_integral_domain I ",
      "is_int_dom_subring_of_field (R : Type) [CommRingₓ R] [Field R] {I : Set R} [is_subring I] :    I ≠ ∅ → is_integral_domain I ",
      "is_int_dom_subring_of_field (R : Type) [CommRingₓ R] [Field R] {I : Setₓ R} [is_subring I] :    I ≠ ∅ → is_integral_domain I "
    ],
    "answer": "{F : Type _} [Field F] : ∀ R : Subring F, 1 ∈ R.Carrier → IsDomain ↥R "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "dvr_unit_iff_val_zero",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.",
      "codex_time": 8.454251390998252,
      "use_theorem_name": false
    },
    "outputs": [
      "(R : Type*) [DiscreteValuationRing R] (x : R) :  x ∈ units R ↔ ∃ y : R, y ≠ 0 ∧ x * y = 1 ",
      "(R : Type*) [integral_domain R] [CommRing R] [DiscreteValuationRing R]  (x : R) (hx : IsUnit x ↔ Valuation x = 0) ",
      "(R : Type*) [integral_domain R] [CommRingₓₓ R] [DiscreteValuationRing R]  (x : R) (hx : IsUnit x ↔ Valuation x = 0) ",
      "(R : Type*) [integral_domain R] [CommRingₓ R] [DiscreteValuationRing R]  (x : R) (hx : IsUnit x ↔ Valuation x = 0) ",
      "(R : Type*) [DiscreteValuationRing R] (x : R) :  x ∈ units R ↔ val R x = 0  Natural language version: \"The intersection of two Finite-index Normal subgroups of a Group is a Finite-index Normal subgroup.\" Translate the natural language version to a Lean mathlib version:  theorem (G : Type*) [Group G] {N M : Set G} [IsSubgroup N] [IsSubgroup M]  (hf : finite.card (quotient_group.left_rel N) ∧ finite.card (quotient_group.left_rel M))  (hN :",
      "(R : Type*) [DiscreteValuationRing R] (x : R) :  x ∈ units R ↔ val R x = 0  Natural language version: \"The intersection of two Finite-index Normal subgroups of a Groupₓₓ is a Finite-index Normal subgroup.\" Translate the natural language version to a Lean mathlib version:  theorem (G : Type*) [Groupₓₓ G] {N M : Set G} [IsSubgroup N] [IsSubgroup M]  (hf : finite.card (quotient_group.left_rel N) ∧ finite.card (quotient_group.left_rel M))  (hN :",
      "(R : Type*) [DiscreteValuationRing R] (x : R) :  x ∈ units R ↔ val R x = 0  Natural language version: \"The intersection of two Finite-index Normal subgroups of a Group is a Finite-index Normal subgroup.\" Translate the natural language version to a Lean mathlib version:  theorem (G : Type*) [Group G] {N M : Setₓ G} [IsSubgroup N] [IsSubgroup M]  (hf : finite.card (quotient_group.left_rel N) ∧ finite.card (quotient_group.left_rel M))  (hN :",
      "(R : Type*) [DiscreteValuationRing R] (x : R) :  x ∈ units R ↔ val R x = 0  Natural language version: \"The intersection of two Finite-index Normal subgroups of a Groupₓₓ is a Finite-index Normal subgroup.\" Translate the natural language version to a Lean mathlib version:  theorem (G : Type*) [Groupₓₓ G] {N M : Setₓ G} [IsSubgroup N] [IsSubgroup M]  (hf : finite.card (quotient_group.left_rel N) ∧ finite.card (quotient_group.left_rel M))  (hN :",
      "(R : Type*) [DiscreteValuationRing R] (x : R) :  x ∈ units R ↔ val R x = 0  Natural language version: \"The intersection of two Finite-index Normal subgroups of a Groupₓ is a Finite-index Normal subgroup.\" Translate the natural language version to a Lean mathlib version:  theorem (G : Type*) [Groupₓ G] {N M : Set G} [IsSubgroup N] [IsSubgroup M]  (hf : finite.card (quotient_group.left_rel N) ∧ finite.card (quotient_group.left_rel M))  (hN :",
      "(R : Type*) [DiscreteValuationRing R] (x : R) :  x ∈ units R ↔ val R x = 0  Natural language version: \"The intersection of two Finite-index Normal subgroups of a Groupₓ is a Finite-index Normal subgroup.\" Translate the natural language version to a Lean mathlib version:  theorem (G : Type*) [Groupₓ G] {N M : Setₓ G} [IsSubgroup N] [IsSubgroup M]  (hf : finite.card (quotient_group.left_rel N) ∧ finite.card (quotient_group.left_rel M))  (hN :",
      "(R : Type*) [DiscreteValuationRing R]  (x : R) : x ∈ units R ↔ val x = 0 ",
      "(R : Type*)  [DiscreteValuationRing R] (x : R) :  IsUnit x ↔ val R x = 0 "
    ],
    "answer": "{R : Type _} [CommRingₓ R] [IsDomain R] [DiscreteValuationRing R] : ∀ r : R, IsUnit r → DiscreteValuationRing.addVal R r = 0 "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "dvr_unit_iff_val_zero",
      "main_prompt": "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.",
      "prompt": "Natural language version: \"An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a discrete valuation ring.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) :\ndiscrete_valuation_ring R := \n\nNatural language version: \"A unique factorization domain with at least one irreducible element in which all irreducible elements are associated is a discrete valuation ring.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [comm_ring R] [is_domain R] [unique_factorization_monoid R] (h₁ : ∃ (p : R), irreducible p) (h₂ : ∀ ⦃p q : R⦄, irreducible p → irreducible q → associated p q) :\ndiscrete_valuation_ring R := \n\nNatural language version: \" If `𝒪` satisfies `v.integers 𝒪` where `v` is a valuation on a field, then `𝒪` is a valuation ring.\" Translate the natural language version to a Lean mathlib version:\n theorem {𝒪 : Type u} {K : Type v} {Γ : Type w} [comm_ring 𝒪] [is_domain 𝒪] [field K] [algebra 𝒪 K] [linear_ordered_comm_group_with_zero Γ] (v : valuation K Γ) (hh : v.integers 𝒪) :\nvaluation_ring 𝒪 := \n\nNatural language version: \"Nonzero elements have nonzero adic valuation.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x : R) (hx : x ≠ 0) :\nv.int_valuation_def x ≠ 0 := \n\nNatural language version: \"An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.7251311540603638,
          "doc_string": "An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a discrete valuation ring.",
          "statement": "theorem discrete_valuation_ring.of_has_unit_mul_pow_irreducible_factorization {R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) : discrete_valuation_ring R"
        },
        {
          "sim_score": 0.6923463344573975,
          "doc_string": "A unique factorization domain with at least one irreducible element in which all irreducible elements are associated is a discrete valuation ring.",
          "statement": "theorem discrete_valuation_ring.of_ufd_of_unique_irreducible {R : Type u} [comm_ring R] [is_domain R] [unique_factorization_monoid R] (h₁ : ∃ (p : R), irreducible p) (h₂ : ∀ ⦃p q : R⦄, irreducible p → irreducible q → associated p q) : discrete_valuation_ring R"
        },
        {
          "sim_score": 0.6915189623832703,
          "doc_string": " If `𝒪` satisfies `v.integers 𝒪` where `v` is a valuation on a field, then `𝒪` is a valuation ring.",
          "statement": "theorem valuation_ring.of_integers {𝒪 : Type u} {K : Type v} {Γ : Type w} [comm_ring 𝒪] [is_domain 𝒪] [field K] [algebra 𝒪 K] [linear_ordered_comm_group_with_zero Γ] (v : valuation K Γ) (hh : v.integers 𝒪) : valuation_ring 𝒪"
        },
        {
          "sim_score": 0.6845616698265076,
          "doc_string": "Nonzero elements have nonzero adic valuation.",
          "statement": "theorem is_dedekind_domain.height_one_spectrum.int_valuation_ne_zero {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x : R) (hx : x ≠ 0) : v.int_valuation_def x ≠ 0"
        }
      ],
      "codex_time": 5.3449695729941595,
      "search_time": 1.3810809220012743,
      "use_theorem_name": false
    },
    "outputs": [
      "{R : Type u} [CommRing R] [IsDomain R] [DiscreteValuationRing R] (x : R) : IsUnit x ↔ ∃ s : R, s * x = 1 ",
      "{R : Type u} [CommRingₓₓ R] [IsDomain R] [DiscreteValuationRing R] (x : R) : IsUnit x ↔ ∃ s : R, s * x = 1 ",
      "{R : Type u} [CommRingₓ R] [IsDomain R] [DiscreteValuationRing R] (x : R) : IsUnit x ↔ ∃ s : R, s * x = 1 ",
      "{R : Type u} [CommRing R] [IsDomain R] [DiscreteValuationRing R] (x : R) : IsUnit x ↔ discrete_valuation_ring.int_valuation_def x = 0 ",
      "{R : Type u} [CommRingₓₓ R] [IsDomain R] [DiscreteValuationRing R] (x : R) : IsUnit x ↔ discrete_valuation_ring.int_valuation_def x = 0 ",
      "{R : Type u} [CommRingₓ R] [IsDomain R] [DiscreteValuationRing R] (x : R) : IsUnit x ↔ discrete_valuation_ring.int_valuation_def x = 0 ",
      "{R : Type u_1} [Field R] [DiscreteValuationRing R] {v : discrete_valuation_ring.height_one_spectrum R} (x : R) : IsUnit x ≃ (v.int_valuation_def x = 0) ",
      "{R : Type u} [DiscreteValuationRing R] (x : R) : IsUnit x ↔ (nat.prime.int_val_def x = 0 : Nnreal) ",
      "{R : Type u_1} [CommRing R] [IsDomain R] [DiscreteValuationRing R] (x : R) : IsUnit x ↔ v.int_valuation_def x = 0 ",
      "{R : Type u_1} [CommRingₓₓ R] [IsDomain R] [DiscreteValuationRing R] (x : R) : IsUnit x ↔ v.int_valuation_def x = 0 ",
      "{R : Type u_1} [CommRingₓ R] [IsDomain R] [DiscreteValuationRing R] (x : R) : IsUnit x ↔ v.int_valuation_def x = 0 "
    ],
    "answer": "{R : Type _} [CommRingₓ R] [IsDomain R] [DiscreteValuationRing R] : ∀ r : R, IsUnit r → DiscreteValuationRing.addVal R r = 0 "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "dvr_unit_iff_val_zero",
      "main_prompt": "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.",
      "prompt": "Natural language version: \"An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 6.173651578021236,
      "use_theorem_name": false
    },
    "outputs": [
      "Unit (α : Type*) [DiscreteValuationRing α] : Π x : α,   (x ≠ 0 → Valuation R x = 0) ↔ IsUnit x ",
      "f : ∀ a : α , IsUnit α a ↔ (val α a = 0) ",
      "v0_imp_unit (v : discrete_valuation_ring.{max u} R) (g : R)     (H : discrete_valuation_ring.val v g = 0) : IsUnit g ",
      "val_unit {R : Type*} [DiscreteValuationRing R] (x : R) : x ∈ (gives_dis_val R)⁻¹' ({0} : Set ℚ) ",
      "val_unit {R : Type*} [DiscreteValuationRing R] (x : R) : x ∈ (gives_dis_val R)⁻¹' ({0} : Setₓ ℚ) ",
      "is_unit_of_valuation_zero (R : Type) [DiscreteValuationRing R] (x : R) : val x = 0 → IsUnit x "
    ],
    "answer": "{R : Type _} [CommRingₓ R] [IsDomain R] [DiscreteValuationRing R] : ∀ r : R, IsUnit r → DiscreteValuationRing.addVal R r = 0 "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "exp_convex",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"The exponential function is convex.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The exponential function is convex.",
      "codex_time": 7.400497094989987,
      "use_theorem_name": false
    },
    "outputs": [
      "(x y : ℝ) (hx : 0 ≤ x) (hy : 0 ≤ y) (λ : ℝ) (hλ0 : 0 ≤ λ) (hλ1 : λ ≤ 1) :  ((exp x) ^ λ) * ((exp y) ^ (1-λ)) ≤ exp (λ * x + (1-λ) * y) ",
      "(x : ℝ) :  ConvexOn (λ t : ℝ, exp t) x ",
      ": Convex exp ",
      "(x y : ℝ) (hxy : 0 ≤ x) (hy : 0 ≤ y) (h_xy : x ≤ y) (t : ℝ) (ht : 0 < t) (h_t : t ≤ 1):  exp (t * x + (1 - t) * y) ≤ t * exp x + (1 - t) * exp y ",
      "(x y a : ℝ) (hx : x < 0) (hy : y < 0) : is_convex_function ℝ ℝ (λ x, exp x) "
    ],
    "answer": ": ConvexOn ℝ Set.univ Real.exp "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "exp_convex",
      "main_prompt": "The exponential function is convex.",
      "prompt": "Natural language version: \"`exp` is convex on the whole real line.\" Translate the natural language version to a Lean mathlib version:\n theorem  :\nconvex_on ℝ set.univ real.exp := \n\nNatural language version: \"`exp` is strictly convex on the whole real line.\" Translate the natural language version to a Lean mathlib version:\n theorem  :\nstrict_convex_on ℝ set.univ real.exp := \n\nNatural language version: \"`x^m`, `m : ℤ` is convex on `(0, +∞)` for all `m` except `0` and `1`.\" Translate the natural language version to a Lean mathlib version:\n theorem {m : ℤ} (hm₀ : m ≠ 0) (hm₁ : m ≠ 1) :\nstrict_convex_on ℝ (set.Ioi 0) (λ (x : ℝ), x ^ m) := \n\nNatural language version: \"`x^n`, `n : ℕ` is convex on `[0, +∞)` for all `n`\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) :\nconvex_on ℝ (set.Ici 0) (λ (x : ℝ), x ^ n) := \n\nNatural language version: \"The exponential function is convex.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.8296651840209961,
          "doc_string": "`exp` is convex on the whole real line.",
          "statement": "theorem convex_on_exp  : convex_on ℝ set.univ real.exp"
        },
        {
          "sim_score": 0.8015367984771729,
          "doc_string": "`exp` is strictly convex on the whole real line.",
          "statement": "theorem strict_convex_on_exp  : strict_convex_on ℝ set.univ real.exp"
        },
        {
          "sim_score": 0.5888562202453613,
          "doc_string": "`x^m`, `m : ℤ` is convex on `(0, +∞)` for all `m` except `0` and `1`.",
          "statement": "theorem strict_convex_on_zpow {m : ℤ} (hm₀ : m ≠ 0) (hm₁ : m ≠ 1) : strict_convex_on ℝ (set.Ioi 0) (λ (x : ℝ), x ^ m)"
        },
        {
          "sim_score": 0.5808110237121582,
          "doc_string": "`x^n`, `n : ℕ` is convex on `[0, +∞)` for all `n`",
          "statement": "theorem convex_on_pow (n : ℕ) : convex_on ℝ (set.Ici 0) (λ (x : ℝ), x ^ n)"
        }
      ],
      "codex_time": 3.8294329380150884,
      "search_time": 1.3569003070006147,
      "use_theorem_name": false
    },
    "outputs": [
      ": Convex Real.exp ",
      " : ConvexOn ℝ Set.Univ Real.exp ",
      " : ConvexOn ℝ Setₓ.Univ Real.exp ",
      " : ConvexOn ℝ Set.Univ (λ (x : ℝ), exp x) ",
      " : ConvexOn ℝ Setₓ.Univ (λ (x : ℝ), exp x) ",
      ": ConvexOn ℝ (-(1 : ℝ)) 1 Real.exp ",
      ": ConvexOn ℝ Set.Univ Real.exp ",
      ": ConvexOn ℝ Setₓ.Univ Real.exp "
    ],
    "answer": ": ConvexOn ℝ Set.univ Real.exp "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "exp_convex",
      "main_prompt": "The exponential function is convex.",
      "prompt": "Natural language version: \"The exponential function is convex.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 8.410151135991327,
      "use_theorem_name": false
    },
    "outputs": [
      "exp_convex : Convex ℝ ? ℝ exp ",
      "is_convex ( f : ℝ → ℝ ) : ConvexOn f ( Set.Range f ) ",
      "is_convex ( f : ℝ → ℝ ) : ConvexOn f ( Setₓ.Range f ) ",
      "exp_convex : is_strict_inc ∘ expx ",
      "ExpConvex : ConvexOn ℝ_as_MetricSpace exp ",
      "exp_convex    (a b : ℝ) (h : a < b) (h₁ : 0 ≤ a) (h₂ : 0 ≤ b):   (exp a + exp b)/2 ≤ exp ((a+b)/2) "
    ],
    "answer": ": ConvexOn ℝ Set.univ Real.exp "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "coprime_integer_span_sylvester_coin",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.",
      "codex_time": 5.598308807995636,
      "use_theorem_name": false
    },
    "outputs": [
      "(a b : ℕ) (hab : a ≠ 0 ∧ b ≠ 0 ∧ a.gcd b = 1)  (N : ℕ) (hN : ∃ S : Set ℕ, Finite S ∧ ∑ x in S, b * x = N):  ∃ x y : ℕ, a * x + b * y = N ",
      "(a b : ℕ) (hab : a ≠ 0 ∧ b ≠ 0 ∧ a.gcd b = 1)  (N : ℕ) (hN : ∃ S : Setₓ ℕ, Finite S ∧ ∑ x in S, b * x = N):  ∃ x y : ℕ, a * x + b * y = N ",
      "(a b N : ℕ)  (hab : gcd a b = 1) (hN : N ≥ a + b) :  ∃ x y : ℕ, N = a * x + b * y ",
      "(a b : ℕ) (h : gcd a b = 1)  (N : ℕ) (hN : N > b) :  ∃ x y : ℕ, a * x + b * y = N ",
      "(a b : ℕ) (hab : gcd a b = 1) (N : ℕ) (hN : N ≥ (a + 1) * (b + 1) - 1) :  ∃ x y : ℕ, N = a*x + b*y ",
      "(a b : ℕ) (hab : gcd a b = 1) :  ∀ N : ℕ, ∃ (x y : ℕ), N = a * x + b * y "
    ],
    "answer": ": ∀ a b : ℕ, a > 0 → b > 0 → Nat.coprime a b → ∃ m : ℕ, ∀ N : ℕ, N > m → ∃ x y : ℕ, N = a*x + b*y "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "coprime_integer_span_sylvester_coin",
      "main_prompt": "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.",
      "prompt": "Natural language version: \" **Bézout's lemma**: given `x y : ℕ`, `gcd x y = x * a + y * b`, where `a = gcd_a x y` and `b = gcd_b x y` are computed by the extended Euclidean algorithm.\" Translate the natural language version to a Lean mathlib version:\n theorem (x y : ℕ) :\n↑(x.gcd y) = ↑x * x.gcd_a y + ↑y * x.gcd_b y := \n\nNatural language version: \" For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be written in the form `a * x + b * y` for some pair of integers `x` and `y`\" Translate the natural language version to a Lean mathlib version:\n theorem {a b : ℤ} (ha : a ≠ 0) :\nis_least {n : ℕ | 0 < n ∧ ∃ (x y : ℤ), ↑n = a * x + b * y} (a.gcd b) := \n\nNatural language version: \"If ` x * y = a * p ^ n` where `p` is prime, then `x` and `y` can both be written  as the product of a power of `p` and a divisor of `a`.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_1} [cancel_comm_monoid_with_zero R] {x y a p : R} {n : ℕ} (hp : prime p) (hx : x * y = a * p ^ n) :\n∃ (i j : ℕ) (b c : R), i + j = n ∧ a = b * c ∧ x = b * p ^ i ∧ y = c * p ^ j := \n\nNatural language version: \" Euclid's lemma: if `a ∣ b * c` and `a` and `c` have no common prime factors, `a ∣ b`. Compare `is_coprime.dvd_of_dvd_mul_left`.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] {a b c : R} (ha : a ≠ 0) :\n(∀ {d : R}, d ∣ a → d ∣ c → ¬prime d) → a ∣ b * c → a ∣ b := \n\nNatural language version: \"For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.5282862186431885,
          "doc_string": " **Bézout's lemma**: given `x y : ℕ`, `gcd x y = x * a + y * b`, where `a = gcd_a x y` and `b = gcd_b x y` are computed by the extended Euclidean algorithm.",
          "statement": "theorem nat.gcd_eq_gcd_ab (x y : ℕ) : ↑(x.gcd y) = ↑x * x.gcd_a y + ↑y * x.gcd_b y"
        },
        {
          "sim_score": 0.5160197615623474,
          "doc_string": " For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be written in the form `a * x + b * y` for some pair of integers `x` and `y`",
          "statement": "theorem int.gcd_least_linear {a b : ℤ} (ha : a ≠ 0) : is_least {n : ℕ | 0 < n ∧ ∃ (x y : ℤ), ↑n = a * x + b * y} (a.gcd b)"
        },
        {
          "sim_score": 0.4904349744319916,
          "doc_string": "If ` x * y = a * p ^ n` where `p` is prime, then `x` and `y` can both be written  as the product of a power of `p` and a divisor of `a`.",
          "statement": "theorem mul_eq_mul_prime_pow {R : Type u_1} [cancel_comm_monoid_with_zero R] {x y a p : R} {n : ℕ} (hp : prime p) (hx : x * y = a * p ^ n) : ∃ (i j : ℕ) (b c : R), i + j = n ∧ a = b * c ∧ x = b * p ^ i ∧ y = c * p ^ j"
        },
        {
          "sim_score": 0.47909241914749146,
          "doc_string": " Euclid's lemma: if `a ∣ b * c` and `a` and `c` have no common prime factors, `a ∣ b`. Compare `is_coprime.dvd_of_dvd_mul_left`.",
          "statement": "theorem unique_factorization_monoid.dvd_of_dvd_mul_left_of_no_prime_factors {R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] {a b c : R} (ha : a ≠ 0) : (∀ {d : R}, d ∣ a → d ∣ c → ¬prime d) → a ∣ b * c → a ∣ b"
        }
      ],
      "codex_time": 6.606359152006917,
      "search_time": 1.4123720790084917,
      "use_theorem_name": false
    },
    "outputs": [
      "{R : Type u_2} [CommRing R] (x y : R) (ha : 0 < x) (hb : 0 < y) : ∃ (i j : ℕ), ∃ (a b : R), i + j > j ∧ ↑i * x + ↑j * y = a * ↑x + b * ↑y ",
      "{R : Type u_2} [CommRingₓₓ R] (x y : R) (ha : 0 < x) (hb : 0 < y) : ∃ (i j : ℕ), ∃ (a b : R), i + j > j ∧ ↑i * x + ↑j * y = a * ↑x + b * ↑y ",
      "{R : Type u_2} [CommRingₓ R] (x y : R) (ha : 0 < x) (hb : 0 < y) : ∃ (i j : ℕ), ∃ (a b : R), i + j > j ∧ ↑i * x + ↑j * y = a * ↑x + b * ↑y ",
      "(x a b : ℕ) (hab : a.gcd b = 1) : ∃ (y : ℕ), a * x + b * y = ↑x * ↑b ",
      "{a b : ℕ} (hab : IsCoprime a b) : ∃ k : ℕ, ∀ (n : ℕ), n < k → ∃ (x y : ℕ), n = a * x + b * y ",
      "{a b : ℕ} (h : a.coprime b) : ∃ x y z : ℕ, z ≥ max (a * b) 2 ∧ x = z % a ∧ y = z % b ∧ ↑z = ↑a * x + ↑b * y ",
      "{n a b : ℕ} (hab : a.coprime b) : ∃ (x y : ℕ), n = a * x + b * y ∧ y < b "
    ],
    "answer": ": ∀ a b : ℕ, a > 0 → b > 0 → Nat.coprime a b → ∃ m : ℕ, ∀ N : ℕ, N > m → ∃ x y : ℕ, N = a*x + b*y "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "coprime_integer_span_sylvester_coin",
      "main_prompt": "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.",
      "prompt": "Natural language version: \"For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 11.055162864999147,
      "use_theorem_name": false
    },
    "outputs": [
      "every_natural_number_is_a_linear_combination_of_a_and_b : ∀ (k : ℕ), ∃ (x y : ℕ), k = a * x + b * y ",
      "linear_comb {a b x y N : ℕ} [h : IsCoprime a b] (hax : a > 0) (hbx : b > 0) (gcd1 : N = a * x + b * y) : ∃ x y : ℕ  Goal: Any sufficiently large natural number $N$ is of the form $N = a * x + b * y$ where $x$ and $y$ are natural numbers Translate the English description to a Lean lemma.  lemma gcd_eq_dvd [h : IsCoprime a b] (hbx : b > 0) : ∃ x y :",
      "up_to_prime_factorization : ∀ a b : ℕ+, (a.1.coprime b.1) → ∀ N : ℕ, ∃ x y : ℕ+, N = a.1 * x.1 + b.1 * y.1 ",
      "Euler :  ∀ a b ∀ (h1 : Nat.Prime a) (h2 : Nat.Prime b) (h3a : a ≠ b), ∀ N, ∃ x y, a * x + b * y = N ",
      "rlt_prop (a b : ℕ+) :  ∀ n : ℕ+, ∃ x y : ℕ, n = a * x + b * y     proof    assume n,  have Fact : n < a+b, from (@finite_nat (a+b) n dec_trivial),  have Fact : n = 0 ∨ 0 < n, by exact  let H : n = 0 ∨ 0 < n "
    ],
    "answer": ": ∀ a b : ℕ, a > 0 → b > 0 → Nat.coprime a b → ∃ m : ℕ, ∀ N : ℕ, N > m → ∃ x y : ℕ, N = a*x + b*y "
  },
  {
    "metadata": {
      "prompt_type": "fixed few shot",
      "theorem_name": "frobenius_pow_sum_eq_sum_pow",
      "prompt": "Natural language version: \"If z_1, ..., z_n are complex, then |z_1 + z_2 + ... + z_n| <= |z_1| + |z_2| + ... + |z_n|.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (f : ℕ → ℂ) :\nabs (∑ i in finset.range n, f i) ≤ ∑ i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in R^n, then |x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) (x y : euclidean_space ℝ (fin n)) :\n ∥x + y∥^2 + ∥x - y∥^2 = 2*∥x∥^2 + 2*∥y∥^2 :=\n\nNatural language version: \"If x is an element of infinite order in G, prove that the elements x^n, n ∈ Z are all distinct.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type*) [group G] (x : G)\n (hx : x ≠ 1) (hx_inf : ∀ n : ℕ, x ^ n ≠ 1) :\n ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n :=\n\nNatural language version: \"Let X be a topological space; let A be a subset of X. Suppose that for each x ∈ A there is an open set U containing x such that U ⊆ A. Show that A is open in X\" Translate the natural language version to a Lean mathlib version:\n theorem (X : Type*) [topological_space X]\n (A : set X) (hA : ∀ x ∈ A, ∃ U : set X, is_open U ∧ x ∈ U ∧ U ⊆ A):\n is_open A :=\n\nNatural language version: \"In a commutative ring with prime characteristic $p$, the $p$th power of the sum of two elements is equal to the sum of the $p$th powers of the elements.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "In a commutative ring with prime characteristic $p$, the $p$th power of the sum of two elements is equal to the sum of the $p$th powers of the elements.",
      "codex_time": 4.085696828988148,
      "use_theorem_name": false
    },
    "outputs": [
      "(p : ℕ) (p_is_prime : Prime p)  (R : Type*)  [CommRing R] [CharP R p] (n m : R) :  (n + m)^p = n^p + m^p ",
      "(p : ℕ) (p_is_prime : Prime p)  (R : Type*)  [CommRingₓₓ R] [CharP R p] (n m : R) :  (n + m)^p = n^p + m^p ",
      "(p : ℕ) (p_is_prime : Prime p)  (R : Type*)  [CommRingₓ R] [CharP R p] (n m : R) :  (n + m)^p = n^p + m^p ",
      "(R : Type*) [CommRing R]  [CharP R] (p : ℕ) [Fact (CharP R) = some p]     (i j : R) : i ^ p + j ^ p = (i + j) ^ p ",
      "(R : Type*) [CommRingₓₓ R]  [CharP R] (p : ℕ) [Fact (CharP R) = some p]     (i j : R) : i ^ p + j ^ p = (i + j) ^ p ",
      "(R : Type*) [CommRingₓ R]  [CharP R] (p : ℕ) [Fact (CharP R) = some p]     (i j : R) : i ^ p + j ^ p = (i + j) ^ p ",
      "(A : Type*) [CommRing A] (p : ℕ) (hp : Prime p)  (f g : A) : (f + g) ^ p = f ^ p + g ^ p ",
      "(A : Type*) [CommRingₓₓ A] (p : ℕ) (hp : Prime p)  (f g : A) : (f + g) ^ p = f ^ p + g ^ p ",
      "(A : Type*) [CommRingₓ A] (p : ℕ) (hp : Prime p)  (f g : A) : (f + g) ^ p = f ^ p + g ^ p ",
      "(R : Type*) [CommRing R] (p : ℕ) (hp : Nat.Prime p)  (x y : R) :  (x + y)^p = x^p + y^p ",
      "(R : Type*) [CommRingₓₓ R] (p : ℕ) (hp : Nat.Prime p)  (x y : R) :  (x + y)^p = x^p + y^p ",
      "(R : Type*) [CommRingₓ R] (p : ℕ) (hp : Nat.Prime p)  (x y : R) :  (x + y)^p = x^p + y^p ",
      "(p : ℕ) (h : p > 0) (hp : p.prime)  (R : Type*) [CommRing R] (hp' : characteristic R = p)  (x y : R) : (x + y) ^ p = x ^ p + y ^ p ",
      "(p : ℕ) (h : p > 0) (hp : p.prime)  (R : Type*) [CommRingₓₓ R] (hp' : characteristic R = p)  (x y : R) : (x + y) ^ p = x ^ p + y ^ p ",
      "(p : ℕ) (h : p > 0) (hp : p.prime)  (R : Type*) [CommRingₓ R] (hp' : characteristic R = p)  (x y : R) : (x + y) ^ p = x ^ p + y ^ p "
    ],
    "answer": "{R : Type _} [CommRingₓ R] : (p : ℕ) → Prime p → CharP R p → ∀ a b : R, (a + b)^p = a^p + b^p "
  },
  {
    "metadata": {
      "prompt_type": "retrieved k few shot",
      "theorem_name": "frobenius_pow_sum_eq_sum_pow",
      "main_prompt": "In a commutative ring with prime characteristic $p$, the $p$th power of the sum of two elements is equal to the sum of the $p$th powers of the elements.",
      "prompt": "Natural language version: \"For coprime `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`\" Translate the natural language version to a Lean mathlib version:\n theorem {a b : ℕ} (hab : a.coprime b) :\n(a * b).factorization = a.factorization + b.factorization := \n\nNatural language version: \"For coprime `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`\" Translate the natural language version to a Lean mathlib version:\n theorem {p a b : ℕ} (hab : a.coprime b) :\n⇑((a * b).factorization) p = ⇑(a.factorization) p + ⇑(b.factorization) p := \n\nNatural language version: \"For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`\" Translate the natural language version to a Lean mathlib version:\n theorem {a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0) :\n(a * b).factorization = a.factorization + b.factorization := \n\nNatural language version: \"For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] [normalization_monoid α] [decidable_eq α] {a b : α} (ha : a ≠ 0) (hb : b ≠ 0) :\nfactorization (a * b) = factorization a + factorization b := \n\nNatural language version: \"In a commutative ring with prime characteristic $p$, the $p$th power of the sum of two elements is equal to the sum of the $p$th powers of the elements.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "ret-prompts": [
        {
          "sim_score": 0.6287815570831299,
          "doc_string": "For coprime `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`",
          "statement": "theorem nat.factorization_mul_of_coprime {a b : ℕ} (hab : a.coprime b) : (a * b).factorization = a.factorization + b.factorization"
        },
        {
          "sim_score": 0.6287815570831299,
          "doc_string": "For coprime `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`",
          "statement": "theorem nat.factorization_mul_apply_of_coprime {p a b : ℕ} (hab : a.coprime b) : ⇑((a * b).factorization) p = ⇑(a.factorization) p + ⇑(b.factorization) p"
        },
        {
          "sim_score": 0.6084638833999634,
          "doc_string": "For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`",
          "statement": "theorem nat.factorization_mul {a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0) : (a * b).factorization = a.factorization + b.factorization"
        },
        {
          "sim_score": 0.6084638833999634,
          "doc_string": "For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`",
          "statement": "theorem factorization_mul {α : Type u_1} [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] [normalization_monoid α] [decidable_eq α] {a b : α} (ha : a ≠ 0) (hb : b ≠ 0) : factorization (a * b) = factorization a + factorization b"
        }
      ],
      "codex_time": 7.542835899017518,
      "search_time": 1.3461158830032218,
      "use_theorem_name": false
    },
    "outputs": [
      "{α : Type u_1} [CommRing α] [DecidableEq α] (hp : ∃! n : ℕ, h.characteristic = p.prime_pow n) {a b : α} : (a + b)^p = a^p + b^p ",
      "{α : Type u_1} [CommRingₓₓ α] [DecidableEq α] (hp : ∃! n : ℕ, h.characteristic = p.prime_pow n) {a b : α} : (a + b)^p = a^p + b^p ",
      "{α : Type u_1} [CommRingₓ α] [DecidableEq α] (hp : ∃! n : ℕ, h.characteristic = p.prime_pow n) {a b : α} : (a + b)^p = a^p + b^p ",
      "{α : Type u_1} [CommRing α] (p : ℕ) (p_prime : Prime p) [CharP α p] (a b : α) : (a + b)^[p] = a^[p] + b^[p] ",
      "{α : Type u_1} [CommRingₓₓ α] (p : ℕ) (p_prime : Prime p) [CharP α p] (a b : α) : (a + b)^[p] = a^[p] + b^[p] ",
      "{α : Type u_1} [CommRingₓ α] (p : ℕ) (p_prime : Prime p) [CharP α p] (a b : α) : (a + b)^[p] = a^[p] + b^[p] ",
      "{α : Type u_1} [CommRing α] [DecidableEq α] (hp : CharP α) {a b : α} : (↑a + ↑b) ^ p = ↑a ^ p + ↑b ^ p ",
      "{α : Type u_1} [CommRingₓₓ α] [DecidableEq α] (hp : CharP α) {a b : α} : (↑a + ↑b) ^ p = ↑a ^ p + ↑b ^ p ",
      "{α : Type u_1} [CommRingₓ α] [DecidableEq α] (hp : CharP α) {a b : α} : (↑a + ↑b) ^ p = ↑a ^ p + ↑b ^ p ",
      "{α : Type u_1} [CommSemiring α] (p : ℕ) (hp : Nat.Prime p) [CharP α p hp] {a b : α} : a ^ p + b ^ p = (a + b) ^ p ",
      "{α : Type u_1} [CommSemiringₓ α] (p : ℕ) (hp : Nat.Prime p) [CharP α p hp] {a b : α} : a ^ p + b ^ p = (a + b) ^ p ",
      "{α : Type u_1} [CommRing α] (p : ℕ) (hp : Prime p) (hchar : CharP α p) {a b : α} : (a + b)^p = a^p + b^p ",
      "{α : Type u_1} [CommRingₓₓ α] (p : ℕ) (hp : Prime p) (hchar : CharP α p) {a b : α} : (a + b)^p = a^p + b^p ",
      "{α : Type u_1} [CommRingₓ α] (p : ℕ) (hp : Prime p) (hchar : CharP α p) {a b : α} : (a + b)^p = a^p + b^p "
    ],
    "answer": "{R : Type _} [CommRingₓ R] : (p : ℕ) → Prime p → CharP R p → ∀ a b : R, (a + b)^p = a^p + b^p "
  },
  {
    "metadata": {
      "prompt_type": "none few shot",
      "theorem_name": "frobenius_pow_sum_eq_sum_pow",
      "main_prompt": "In a commutative ring with prime characteristic $p$, the $p$th power of the sum of two elements is equal to the sum of the $p$th powers of the elements.",
      "prompt": "Natural language version: \"In a commutative ring with prime characteristic $p$, the $p$th power of the sum of two elements is equal to the sum of the $p$th powers of the elements.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "codex_time": 9.646428829000797,
      "use_theorem_name": false
    },
    "outputs": [
      "sum_pow_swap_p : ∀ (R : Type) [CommRing R] [CharP R p] (a b : R), (a + b) ^ p = a ^ p + b ^ p Proof. Abort.  -- Exercises at the end of chapter 3 -- 3.7. Recall that the Ring of Polynomial functions $R ",
      "sum_pow_swap_p : ∀ (R : Type) [CommRingₓₓ R] [CharP R p] (a b : R), (a + b) ^ p = a ^ p + b ^ p Proof. Abort.  -- Exercises at the end of chapter 3 -- 3.7. Recall that the Ring of Polynomial functions $R ",
      "sum_pow_swap_p : ∀ (R : Type) [CommRing R] [CharP R p] (a b : R), (a + b) ^ p = a ^ p + b ^ p Proof. Abort.  -- Exercises at the end of chapter 3 -- 3.7. Recall that the Ringₓₓ of Polynomial functions $R ",
      "sum_pow_swap_p : ∀ (R : Type) [CommRingₓₓ R] [CharP R p] (a b : R), (a + b) ^ p = a ^ p + b ^ p Proof. Abort.  -- Exercises at the end of chapter 3 -- 3.7. Recall that the Ringₓₓ of Polynomial functions $R ",
      "sum_pow_swap_p : ∀ (R : Type) [CommRing R] [CharP R p] (a b : R), (a + b) ^ p = a ^ p + b ^ p Proof. Abort.  -- Exercises at the end of chapter 3 -- 3.7. Recall that the Ringₓ of Polynomial functions $R ",
      "sum_pow_swap_p : ∀ (R : Type) [CommRingₓₓ R] [CharP R p] (a b : R), (a + b) ^ p = a ^ p + b ^ p Proof. Abort.  -- Exercises at the end of chapter 3 -- 3.7. Recall that the Ringₓ of Polynomial functions $R ",
      "sum_pow_swap_p : ∀ (R : Type) [CommRingₓ R] [CharP R p] (a b : R), (a + b) ^ p = a ^ p + b ^ p Proof. Abort.  -- Exercises at the end of chapter 3 -- 3.7. Recall that the Ring of Polynomial functions $R ",
      "sum_pow_swap_p : ∀ (R : Type) [CommRingₓ R] [CharP R p] (a b : R), (a + b) ^ p = a ^ p + b ^ p Proof. Abort.  -- Exercises at the end of chapter 3 -- 3.7. Recall that the Ringₓₓ of Polynomial functions $R ",
      "sum_pow_swap_p : ∀ (R : Type) [CommRingₓ R] [CharP R p] (a b : R), (a + b) ^ p = a ^ p + b ^ p Proof. Abort.  -- Exercises at the end of chapter 3 -- 3.7. Recall that the Ringₓ of Polynomial functions $R ",
      "my_lemma :  CommRing α → Prime p → a ∈ α → b ∈ α → (a + b)^p = a^p + b^p ",
      "my_lemma :  CommRingₓₓ α → Prime p → a ∈ α → b ∈ α → (a + b)^p = a^p + b^p ",
      "my_lemma :  CommRingₓ α → Prime p → a ∈ α → b ∈ α → (a + b)^p = a^p + b^p ",
      "pang1 (R : Type) [CommRing R] [CharP R.prime p] {a b:R}: (a+b)^p = a^p + b^p ",
      "pang1 (R : Type) [CommRingₓₓ R] [CharP R.prime p] {a b:R}: (a+b)^p = a^p + b^p ",
      "pang1 (R : Type) [CommRingₓ R] [CharP R.prime p] {a b:R}: (a+b)^p = a^p + b^p ",
      "nat_lang_problem2 : ∀ { R : Type } [ CommRing R ] [ hp : Prime ( CharP R ) ] { a b : R }, (a + b) ^ CharP R = a^CharP R + b^CharP R ",
      "nat_lang_problem2 : ∀ { R : Type } [ CommRingₓₓ R ] [ hp : Prime ( CharP R ) ] { a b : R }, (a + b) ^ CharP R = a^CharP R + b^CharP R ",
      "nat_lang_problem2 : ∀ { R : Type } [ CommRingₓ R ] [ hp : Prime ( CharP R ) ] { a b : R }, (a + b) ^ CharP R = a^CharP R + b^CharP R ",
      "Multiset . map_eq_of_equiv_on_image ( interv al : Set ℤ) ( Equiv : Equivalence interv al) : ∀( f g : ℤ → ℤ), ( ∀x∈interv al, fx ≡ gx mod a ) → Multiset . map f ( interv al . to_multiset ) = Multiset . map g ( interv al . to_multiset ) ",
      "Multiset . map_eq_of_equiv_on_image ( interv al : Setₓ ℤ) ( Equiv : Equivalence interv al) : ∀( f g : ℤ → ℤ), ( ∀x∈interv al, fx ≡ gx mod a ) → Multiset . map f ( interv al . to_multiset ) = Multiset . map g ( interv al . to_multiset ) ",
      "Multiset . map_eq_of_equiv_on_image ( interv al : Set ℤ) ( Equivₓ : Equivalence interv al) : ∀( f g : ℤ → ℤ), ( ∀x∈interv al, fx ≡ gx mod a ) → Multiset . map f ( interv al . to_multiset ) = Multiset . map g ( interv al . to_multiset ) ",
      "Multiset . map_eq_of_equiv_on_image ( interv al : Setₓ ℤ) ( Equivₓ : Equivalence interv al) : ∀( f g : ℤ → ℤ), ( ∀x∈interv al, fx ≡ gx mod a ) → Multiset . map f ( interv al . to_multiset ) = Multiset . map g ( interv al . to_multiset ) ",
      "Multiset . map_eq_of_equiv_on_image ( interv al : Set ℤ) ( Equiv : Equivalenceₓ interv al) : ∀( f g : ℤ → ℤ), ( ∀x∈interv al, fx ≡ gx mod a ) → Multiset . map f ( interv al . to_multiset ) = Multiset . map g ( interv al . to_multiset ) ",
      "Multiset . map_eq_of_equiv_on_image ( interv al : Setₓ ℤ) ( Equiv : Equivalenceₓ interv al) : ∀( f g : ℤ → ℤ), ( ∀x∈interv al, fx ≡ gx mod a ) → Multiset . map f ( interv al . to_multiset ) = Multiset . map g ( interv al . to_multiset ) ",
      "Multiset . map_eq_of_equiv_on_image ( interv al : Set ℤ) ( Equivₓ : Equivalenceₓ interv al) : ∀( f g : ℤ → ℤ), ( ∀x∈interv al, fx ≡ gx mod a ) → Multiset . map f ( interv al . to_multiset ) = Multiset . map g ( interv al . to_multiset ) ",
      "Multiset . map_eq_of_equiv_on_image ( interv al : Setₓ ℤ) ( Equivₓ : Equivalenceₓ interv al) : ∀( f g : ℤ → ℤ), ( ∀x∈interv al, fx ≡ gx mod a ) → Multiset . map f ( interv al . to_multiset ) = Multiset . map g ( interv al . to_multiset ) "
    ],
    "answer": "{R : Type _} [CommRingₓ R] : (p : ℕ) → Prime p → CharP R p → ∀ a b : R, (a + b)^p = a^p + b^p "
  }
]