{"type": "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] (e : PartialHomeomorph α β) {f : γ → α},\n  f ⁻¹' e.source = Set.univ → (Continuous f ↔ Continuous (↑e ∘ f))", "name": "PartialHomeomorph.continuous_iff_continuous_comp_left", "isProp": true, "docString": "A function is continuous if and only if its composition with a partial homeomorphism\non the left is continuous and its image is contained in the source. ", "terms": "[\n    \"function\",\n    \"continuous\",\n    \"composition\",\n    \"partial homeomorphism\",\n    \"image\",\n    \"contained\",\n    \"source\"\n]"}
{"type": "{α : Type u_2} → [inst : LinearOrder α] → (s : Finset α) → Finset.Nonempty s → α", "name": "Finset.max'", "isProp": false, "docString": "Given a nonempty finset `s` in a linear order `α`, then `s.max' h` is its maximum, as an\nelement of `α`, where `h` is a proof of nonemptiness. Without this assumption, use instead `s.max`,\ntaking values in `WithBot α`. ", "terms": "[\n    \"nonempty\",\n    \"finset\",\n    \"linear order\",\n    \"maximum\",\n    \"element\",\n    \"proof\",\n    \"nonemptiness\",\n    \"assumption\",\n    \"WithBot\"\n]"}
{"type": "∀ {α : Type u_1} {c : ℝ} {l : Filter α} {u v : α → ℝ},\n  (Asymptotics.IsBigOWith c l (fun x => |u x|) fun x => |v x|) → Asymptotics.IsBigOWith c l u v", "name": "Asymptotics.IsBigOWith.of_abs_abs", "isProp": true, "docString": "**Alias** of the forward direction of `Asymptotics.isBigOWith_abs_abs`.", "terms": "[\"Alias\", \"forward direction\", \"Asymptotics.isBigOWith_abs_abs\"]"}
{"type": "{R : Type u_1} →\n  [inst : Semiring R] →\n    {M : Type u_6} →\n      [inst_1 : TopologicalSpace M] →\n        [inst_2 : AddCommMonoid M] →\n          [inst_3 : Module R M] →\n            {N₂ : Type u_9} →\n              [inst_4 : TopologicalSpace N₂] →\n                [inst_5 : AddCommMonoid N₂] →\n                  [inst_6 : Module R N₂] →\n                    {N₃ : Type u_10} →\n                      [inst_7 : TopologicalSpace N₃] →\n                        [inst_8 : AddCommMonoid N₃] →\n                          [inst_9 : Module R N₃] → (M →L[R] N₂) × (M →L[R] N₃) ≃ (M →L[R] N₂ × N₃)", "name": "ContinuousLinearMap.prodEquiv", "isProp": false, "docString": "`ContinuousLinearMap.prod` as an `Equiv`. ", "terms": "[\n    \"ContinuousLinearMap.prod\",\n    \"Equiv\"\n]"}
{"type": "{R : Type u_7} →\n  {S : Type u_8} →\n    {F : Type u_9} →\n      {G : Type u_10} →\n        [inst : NonAssocSemiring R] →\n          [inst_1 : NonAssocSemiring S] →\n            [inst_2 : RingHomClass F R S] →\n              [inst_3 : RingHomClass G S R] →\n                (hom : F) →\n                  (inv : G) → RingHom.comp ↑inv ↑hom = RingHom.id R → RingHom.comp ↑hom ↑inv = RingHom.id S → R ≃+* S", "name": "RingEquiv.ofHomInv", "isProp": false, "docString": "Construct an equivalence of rings from unital homomorphisms in both directions, which are inverses.\n", "terms": "[\n    \"Construct\",\n    \"equivalence\",\n    \"rings\",\n    \"unital homomorphisms\",\n    \"directions\",\n    \"inverses\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {P : CategoryTheory.Functor Cᵒᵖ (Type w)} →\n      {D : Type u₂} →\n        [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n          (F : CategoryTheory.Functor D C) →\n            {X : D} →\n              {T : CategoryTheory.Presieve X} →\n                CategoryTheory.Presieve.FamilyOfElements (CategoryTheory.Functor.comp F.op P) T →\n                  CategoryTheory.Presieve.FamilyOfElements P (CategoryTheory.Presieve.functorPushforward F T)", "name": "CategoryTheory.Presieve.FamilyOfElements.functorPushforward", "isProp": false, "docString": "Given a family of elements of a sieve `S` on `X` whose values factors through `F`, we can\nrealize it as a family of elements of `S.functorPushforward F`. Since the preimage is obtained by\nchoice, this is not well-defined generally.\n", "terms": "[\n    \"family of elements\",\n    \"sieve\",\n    \"values\",\n    \"factors through\",\n    \"realize\",\n    \"functorPushforward\",\n    \"preimage\",\n    \"obtained by\",\n    \"choice\",\n    \"well-defined\"\n]"}
{"type": "∀ {M : Type u_2} [inst : AddZeroClass M] (x : M), AddSemiconjBy 0 x x", "name": "AddSemiconjBy.zero_left", "isProp": true, "docString": "Zero semiconjugates any element to itself.", "terms": "[\"Zero\", \"semiconjugate\", \"element\"]"}
{"type": "{G : Type u_10} → [inst : AddGroup G] → G → G ≃ G", "name": "Equiv.subLeft", "isProp": false, "docString": "A version of `Equiv.addLeft a (-b)` that is defeq to `a - b`. ", "terms": "[\n    \"version\",\n    \"Equiv.addLeft\",\n    \"defeq\",\n    \"-\"\n]"}
{"type": "∀ {α : Type u} {s : Set α}, Set.Finite s → Nonempty (Fintype ↑s)", "name": "Set.Finite.nonempty_fintype", "isProp": true, "docString": "**Alias** of the forward direction of `Set.finite_def`.", "terms": "[\"Alias\", \"forward direction\", \"Set.finite_def\"]"}
{"type": "∀ {R : Type u_1} [inst : CommSemiring R] {A : Type u_2} {B : Type u_3} [inst_1 : Semiring A] [inst_2 : Semiring B]\n  [inst_3 : Algebra R A] [inst_4 : Algebra R B] (I : Ideal B),\n  Submodule.restrictScalars R (Ideal.map Algebra.TensorProduct.includeRight I) =\n    LinearMap.range (LinearMap.lTensor A (Submodule.subtype (Submodule.restrictScalars R I)))", "name": "Ideal.map_includeRight_eq", "isProp": true, "docString": "The ideal of `A ⊗[R] B` generated by `I` is the image of `A ⊗[R] I` ", "terms": "[\n  \"ideal\",\n  \"generated\",\n  \"image\",\n  \"tensor product\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} [inst : Add α] [inst_1 : Preorder α] [inst_2 : Preorder β]\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {f g : β → α},\n  Monotone f → StrictMono g → StrictMono fun x => f x + g x", "name": "Monotone.add_strictMono", "isProp": true, "docString": "The sum of a monotone function and a strictly monotone function is\nstrictly monotone.", "terms": "[\n  \"sum\",\n  \"monotone function\",\n  \"strictly monotone function\"\n]"}
{"type": "∀ {α : Type u_1} [inst : AddCommSemigroup α] [inst_1 : PartialOrder α] [inst_2 : ExistsAddOfLE α]\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_4 : Sub α] [inst_5 : OrderedSub α]\n  {a b c : α} [inst_6 : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]\n  [inst : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1], b ≤ a → c ≤ a → (a - b < a - c ↔ c < b)", "name": "tsub_lt_tsub_iff_left_of_le_of_le", "isProp": true, "docString": "See `tsub_lt_tsub_iff_left_of_le` for a stronger statement in a linear order. ", "terms": "[]"}
{"type": "∀ {K : Type u_1} {n : ℕ} {g : GeneralizedContinuedFraction K} [inst : DivisionRing K] {m : ℕ},\n  m ≤ n →\n    GeneralizedContinuedFraction.continuantsAux g m =\n      GeneralizedContinuedFraction.continuantsAux (GeneralizedContinuedFraction.squashGCF g n) m", "name": "GeneralizedContinuedFraction.continuantsAux_eq_continuantsAux_squashGCF_of_le", "isProp": true, "docString": "The auxiliary continuants before the squashed position stay the same. ", "terms": "[\"auxiliary continuants\", \"squashed position\"]"}
{"type": "{V : Type u} → {W : Type v} → SimpleGraph V → SimpleGraph W → Type (max u v)", "name": "SimpleGraph.Embedding", "isProp": false, "docString": "A graph embedding is an embedding `f` such that for vertices `v w : V`,\n`G.Adj (f v) (f w) ↔ G.Adj v w`. Its image is an induced subgraph of G'.\n\nThe notation `G ↪g G'` represents the type of graph embeddings. ", "terms": "[\n    \"graph embedding\",\n    \"embedding\",\n    \"vertices\",\n    \"Adj\",\n    \"image\",\n    \"induced subgraph\",\n    \"type of graph embeddings\"\n]"}
{"type": "{α : Type u_1} → [inst : TopologicalSpace α] → [inst_1 : LE α] → ClopenUpperSet α → UpperSet α", "name": "ClopenUpperSet.toUpperSet", "isProp": false, "docString": "Reinterpret an upper clopen as an upper set. ", "terms": "[\n    \"Reinterpret\",\n    \"upper clopen\",\n    \"upper set\"\n]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]\n  (F : CategoryTheory.Functor C D) {W X Y Z : C} {f : W ⟶ X} {g : W ⟶ Y} {h : X ⟶ Z} {i : Y ⟶ Z}\n  [inst_2 : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) F],\n  CategoryTheory.IsPushout f g h i → CategoryTheory.IsPushout (F.map f) (F.map g) (F.map h) (F.map i)", "name": "CategoryTheory.IsPushout.map", "isProp": true, "docString": "**Alias** of `CategoryTheory.Functor.map_isPushout`.", "terms": "[\"Alias\", \"CategoryTheory\", \"Functor\", \"map_isPushout\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {X Y Z : C} →\n      {f : X ⟶ Z} →\n        {g : Y ⟶ Z} →\n          {t : CategoryTheory.Limits.PullbackCone f g} →\n            CategoryTheory.Limits.IsLimit t →\n              {W : C} →\n                (h : W ⟶ X) →\n                  (k : W ⟶ Y) →\n                    CategoryTheory.CategoryStruct.comp h f = CategoryTheory.CategoryStruct.comp k g → (W ⟶ t.pt)", "name": "CategoryTheory.Limits.PullbackCone.IsLimit.lift", "isProp": false, "docString": "If `t` is a limit pullback cone over `f` and `g` and `h : W ⟶ X` and `k : W ⟶ Y` are such that\n`h ≫ f = k ≫ g`, then we get `l : W ⟶ t.pt`, which satisfies `l ≫ fst t = h`\nand `l ≫ snd t = k`, see `IsLimit.lift_fst` and `IsLimit.lift_snd`. ", "terms": "[\n  \"limit pullback cone\",\n  \"f\",\n  \"g\",\n  \"h\",\n  \"W\",\n  \"X\",\n  \"k\",\n  \"Y\",\n  \"l\",\n  \"t.pt\",\n  \"fst t\",\n  \"snd t\",\n  \"IsLimit.lift_fst\",\n  \"IsLimit.lift_snd\"\n]"}
{"type": "∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : TopologicalRing 𝕜] (a b : 𝕜)\n  (h : 0 < a), ⇑(affineHomeomorph a b (_ : a ≠ 0)) '' Set.Icc 0 1 = Set.Icc b (a + b)", "name": "affineHomeomorph_image_I", "isProp": true, "docString": "The image of `[0,1]` under the homeomorphism `fun x ↦ a * x + b` is `[b, a+b]`.\n", "terms": "[\n    \"image\",\n    \"homeomorphism\",\n    \"fun\",\n    \"↦\"\n]"}
{"type": "{α : Type u} → Tree α → ℕ", "name": "Tree.numNodes", "isProp": false, "docString": "The number of internal nodes (i.e. not including leaves) of a binary tree ", "terms": "[\n    \"number\",\n    \"internal nodes\",\n    \"binary tree\",\n    \"leaves\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {X Y : C} → (f : X ⟶ Y) → [inst_1 : CategoryTheory.IsSplitEpi f] → CategoryTheory.RegularEpi f", "name": "CategoryTheory.RegularEpi.ofSplitEpi", "isProp": false, "docString": "Every split epimorphism is a regular epimorphism. ", "terms": "[\n    \"split epimorphism\",\n    \"regular epimorphism\"\n]"}
{"type": "{w x y z : SetTheory.PGame} →\n  SetTheory.PGame.Relabelling w x → SetTheory.PGame.Relabelling y z → SetTheory.PGame.Relabelling (w - y) (x - z)", "name": "SetTheory.PGame.Relabelling.subCongr", "isProp": false, "docString": "If `w` has the same moves as `x` and `y` has the same moves as `z`,\nthen `w - y` has the same moves as `x - z`. ", "terms": "[\"moves\", \"same\", \"-\", \"has\"]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {s : EuclideanGeometry.Sphere P} {p : P} (v : V),\n  EuclideanGeometry.Sphere.secondInter s p v ∈ s ↔ p ∈ s", "name": "EuclideanGeometry.Sphere.secondInter_mem", "isProp": true, "docString": "The point given by `secondInter` lies on the sphere. ", "terms": "[\"point\", \"sphere\"]"}
{"type": "∀ (k : Type u₁) {G : Type u₂} {R : Type u_2} [inst : Semiring k] [inst_1 : DistribSMul R k] [inst_2 : Add G]\n  [inst_3 : SMulCommClass R k k], SMulCommClass R (AddMonoidAlgebra k G) (AddMonoidAlgebra k G)", "name": "AddMonoidAlgebra.smulCommClass_self", "isProp": true, "docString": "Note that if `k` is a `CommSemiring` then we have `SMulCommClass k k k` and so we can take\n`R = k` in the below. In other words, if the coefficients are commutative amongst themselves, they\nalso commute with the algebra multiplication. ", "terms": "[\n  \"CommSemiring\",\n  \"SMulCommClass\",\n  \"coefficients\",\n  \"commutative\",\n  \"algebra multiplication\"\n]"}
{"type": "{G : Type u_3} → [inst : Group G] → {H : Subgroup G} → [inst_1 : Subgroup.Normal H] → G →* MulAut ↥H", "name": "MulAut.conjNormal", "isProp": false, "docString": "Group conjugation on a normal subgroup. Analogous to `MulAut.conj`. ", "terms": "[\"Group\", \"conjugation\", \"normal subgroup\", \"Analogous\", \"MulAut.conj\"]"}
{"type": "{X Y : Type u} →\n  [inst : AddCommMonoid X] → [inst_1 : AddCommMonoid Y] → (X →+ Y) → (AddCommMonCat.of X ⟶ AddCommMonCat.of Y)", "name": "AddCommMonCat.ofHom", "isProp": false, "docString": "Typecheck an `AddMonoidHom` as a morphism in `AddCommMonCat`. ", "terms": "[\n    \"Typecheck\",\n    \"AddMonoidHom\",\n    \"morphism\",\n    \"AddCommMonCat\"\n]"}
{"type": "{n m : ℕ} → n = m → Fin n → Fin m", "name": "Fin.cast", "isProp": false, "docString": "`cast eq i` embeds `i` into an equal `Fin` type. ", "terms": "[\"cast\", \"eq\", \"embeds\", \"equal\", \"Fin\", \"type\"]"}
{"type": "∀ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : AddCommMonoid A] [inst_2 : Module R A]\n  [self : Coalgebra R A], LinearMap.rTensor A Coalgebra.counit ∘ₗ Coalgebra.comul = (TensorProduct.mk R R A) 1", "name": "Coalgebra.rTensor_counit_comp_comul", "isProp": true, "docString": "The counit satisfies the left counitality law ", "terms": "[\n    \"counit\",\n    \"left counitality law\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {X : C} →\n      {J : CategoryTheory.GrothendieckTopology C} →\n        {S : CategoryTheory.GrothendieckTopology.Cover J X} →\n          CategoryTheory.GrothendieckTopology.Cover.Relation S → CategoryTheory.GrothendieckTopology.Cover.Arrow S", "name": "CategoryTheory.GrothendieckTopology.Cover.Relation.fst", "isProp": false, "docString": "The first `Arrow` associated to a `Relation`.\nUsed in defining `index`. ", "terms": "[\"Arrow\", \"Relation\", \"index\"]"}
{"type": "{n k : ℕ} → { s // 0 ∈ s } ≃ Sym (Fin (Nat.succ n)) k", "name": "Sym.e1", "isProp": false, "docString": "Over `Fin (n + 1)`, the multisets of size `k + 1` containing `0` are equivalent to those of size\n`k`, as demonstrated by respectively erasing or appending `0`. ", "terms": "[\n    \"Fin\",\n    \"multisets\",\n    \"size\",\n    \"equivalent\",\n    \"erasing\",\n    \"appending\"\n]"}
{"type": "Set UpperHalfPlane", "name": "ModularGroup.fd", "isProp": false, "docString": "The standard (closed) fundamental domain of the action of `SL(2,ℤ)` on `ℍ`. ", "terms": "[\n  \"standard\",\n  \"closed\",\n  \"fundamental domain\",\n  \"action\",\n  \"SL(2,ℤ)\",\n  \"ℍ\"\n]"}
{"type": "{α : Type u_2} → [inst : Inf α] → [inst : HImp α] → α → α → α", "name": "bihimp", "isProp": false, "docString": "The Heyting bi-implication is `(b ⇨ a) ⊓ (a ⇨ b)`. This generalizes equivalence of\npropositions. ", "terms": "[\n  \"Heyting\",\n  \"bi-implication\",\n  \"equivalence of propositions\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    (D : Type u₂) →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        [inst_2 : ∀ (a b : C), CategoryTheory.Limits.HasCoproductsOfShape (a ⟶ b) D] →\n          (c : C) → CategoryTheory.evaluationLeftAdjoint D c ⊣ (CategoryTheory.evaluation C D).obj c", "name": "CategoryTheory.evaluationAdjunctionRight", "isProp": false, "docString": "The adjunction showing that evaluation is a right adjoint. ", "terms": "[\n    \"adjunction\",\n    \"evaluation\",\n    \"right adjoint\"\n]"}
{"type": "{α : Type u_1} → (α → Bool) → List α → List α", "name": "List.eraseP", "isProp": false, "docString": "`eraseP p l` removes the first element of `l` satisfying the predicate `p`. ", "terms": "[\"eraseP\", \"element\", \"satisfying\", \"predicate\", \"removes\", \"first\"]"}
{"type": "∀ {α : Type u_1} {M : Type u_5} [inst : CommMonoid M] {f : α → M} {s : Set α},\n  Set.EqOn f 1 s → (finprod fun i => finprod fun h => f i) = 1", "name": "finprod_mem_of_eqOn_one", "isProp": true, "docString": "If a function `f` equals `1` on a set `s`, then the product of `f i` over `i ∈ s` equals `1`. ", "terms": "[\n    \"function\",\n    \"equals\",\n    \"set\",\n    \"product\",\n    \"over\",\n    \"element of\"\n]"}
{"type": "∀ {f f' : ℝ → ℝ} {a b : ℝ},\n  ContinuousOn f (Set.Icc a b) →\n    (∀ x ∈ Set.Ico a b, ∀ (r : ℝ), f' x < r → ∃ᶠ (z : ℝ) in nhdsWithin x (Set.Ioi x), slope f x z < r) →\n      ∀ {B B' : ℝ → ℝ},\n        f a ≤ B a →\n          (∀ (x : ℝ), HasDerivAt B (B' x) x) →\n            (∀ x ∈ Set.Ico a b, f x = B x → f' x < B' x) → ∀ ⦃x : ℝ⦄, x ∈ Set.Icc a b → f x ≤ B x", "name": "image_le_of_liminf_slope_right_lt_deriv_boundary", "isProp": true, "docString": "General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a ≤ B a`;\n* `B` has derivative `B'` everywhere on `ℝ`;\n* for each `x ∈ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\n  is bounded above by a function `f'`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x ≤ B x` everywhere on `[a, b]`. ", "terms": "[\n    \"General fencing theorem\",\n    \"continuous functions\",\n    \"estimate\",\n    \"derivative\",\n    \"functions\",\n    \"ℝ\",\n    \"right-side limit inferior\",\n    \"bounded above\",\n    \"function\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.IsFilteredOrEmpty C] →\n      {D : Type u₁} →\n        [inst_2 : CategoryTheory.Category.{v₁, u₁} D] →\n          (F : CategoryTheory.Functor D C) →\n            CategoryTheory.Functor D (CategoryTheory.IsFiltered.SmallFilteredIntermediate F)", "name": "CategoryTheory.IsFiltered.SmallFilteredIntermediate.factoring", "isProp": false, "docString": "The first part of a factoring of a functor from a small category to a filtered category through\na small filtered category. ", "terms": "[\n    \"factoring\",\n    \"functor\",\n    \"small category\",\n    \"filtered category\",\n    \"small filtered category\"\n]"}
{"type": "∀ {α : Type u_1} {E : Type u_2} {F : Type u_3} {m0 : MeasurableSpace α} {p : ENNReal} {μ : MeasureTheory.Measure α}\n  [inst : NormedAddCommGroup E] [inst_1 : NormedAddCommGroup F] {f : α → E} {g : α → F},\n  MeasureTheory.Memℒp g p →\n    MeasureTheory.AEStronglyMeasurable f μ → (∀ᵐ (x : α) ∂μ, ‖f x‖ ≤ ‖g x‖) → MeasureTheory.Memℒp f p", "name": "MeasureTheory.Memℒp.mono", "isProp": true, "docString": "**Alias** of `MeasureTheory.Memℒp.of_le`.", "terms": "[\n  \"Alias\",\n  \"Measure Theory\",\n  \"Memℒp\",\n  \"of_le\"\n]"}
{"type": "{α : Type u_1} → (s : Multiset α) → Multiset { x // x ∈ s }", "name": "Multiset.attach", "isProp": false, "docString": "\"Attach\" a proof that `a ∈ s` to each element `a` in `s` to produce\na multiset on `{x // x ∈ s}`. ", "terms": "[\n  \"proof\",\n  \"element\",\n  \"multiset\"\n]"}
{"type": "{α : Type u_1} → {n : ℕ} → α → (i : Fin (n + 1)) → Sym α (n - ↑i) → Sym α n", "name": "Sym.fill", "isProp": false, "docString": "Fill a term `m : Sym α (n - i)` with `i` copies of `a` to obtain a term of `Sym α n`.\nThis is a convenience wrapper for `m.append (replicate i a)` that adjusts the term using\n`Sym.cast`. ", "terms": "[\n    \"term\",\n    \"Sym\",\n    \"α\",\n    \"n\",\n    \"i\",\n    \"copies\",\n    \"convenience wrapper\",\n    \"append\",\n    \"replicate\",\n    \"adjust\",\n    \"Sym.cast\"\n]"}
{"type": "∀ {α : Type u_4} {β : Type u_5} {γ : Type u_3} {f : α → β → γ} {a : Option α} {b : Option β} {δ : Type u_1}\n  {β' : Type u_2} {g : γ → δ} {f' : β' → α → δ} {g' : β → β'},\n  (∀ (a : α) (b : β), g (f a b) = f' (g' b) a) → Option.map g (Option.map₂ f a b) = Option.map₂ f' (Option.map g' b) a", "name": "Option.map_map₂_antidistrib_left", "isProp": true, "docString": "Symmetric statement to `Option.map₂_map_left_anticomm`. ", "terms": "The given statement doesn't contain any specific mathematical terms apart from the generic term \"Symmetric\". The term `Option.map₂_map_left_anticomm` seems to be a function or method, possibly in a programming language like Haskell or Scala, but without more context, it's difficult to confirm whether it has a mathematical meaning.\n\nFollowing is the JSON list with the detected mathematical term:\n\n```\n[\"Symmetric\"]\n```"}
{"type": "{R : Type u_1} → {A : Type u_3} → [inst : CommRing R] → [inst_1 : Ring A] → (R →+* A) → A → Prop", "name": "RingHom.IsIntegralElem", "isProp": false, "docString": "An element `x` of `A` is said to be integral over `R` with respect to `f`\nif it is a root of a monic polynomial `p : R[X]` evaluated under `f` ", "terms": "[\n  \"element\",\n  \"integral\",\n  \"root\",\n  \"monic polynomial\",\n  \"evaluated\"\n]"}
{"type": "{α : Type u_1} → [inst : AddCommGroup α] → AddCommGroup.TotalPositiveCone α → AddCommGroup.PositiveCone α", "name": "AddCommGroup.TotalPositiveCone.toPositiveCone", "isProp": false, "docString": "Forget that a `TotalPositiveCone` is total. ", "terms": "[\"TotalPositiveCone\", \"total\"]"}
{"type": "{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {K : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} K] →\n        {C : Type u₃} →\n          [inst_2 : CategoryTheory.Category.{v₃, u₃} C] →\n            {F : CategoryTheory.Functor J C} →\n              (e : K ≌ J) →\n                CategoryTheory.Limits.Cocone F ≌ CategoryTheory.Limits.Cocone (CategoryTheory.Functor.comp e.functor F)", "name": "CategoryTheory.Limits.Cocones.whiskeringEquivalence", "isProp": false, "docString": "Whiskering by an equivalence gives an equivalence between categories of cones.\n", "terms": "[\n    \"Whiskering\",\n    \"Equivalence\",\n    \"Categories\",\n    \"Cones\"\n]"}
{"type": "{F : Type u_1} → [inst : CommSemiring F] → ℕ → Polynomial F → Prop", "name": "Polynomial.HasSeparableContraction", "isProp": false, "docString": "The condition of having a separable contraction. ", "terms": "[\"condition\", \"having\", \"separable\", \"contraction\"]"}
{"type": "{R : Type u_1} →\n  [inst : CommRing R] →\n    {M : Type u_2} →\n      [inst_1 : AddCommGroup M] →\n        [inst_2 : Module R M] →\n          {M' : Type u_3} →\n            [inst_3 : AddCommGroup M'] →\n              [inst_4 : Module R M'] →\n                {ι : Type u_4} →\n                  [inst_5 : DecidableEq ι] →\n                    [inst_6 : Fintype ι] →\n                      {f : M →ₗ[R] M'} →\n                        {v : Basis ι R M} →\n                          {v' : Basis ι R M'} → IsUnit (Matrix.det ((LinearMap.toMatrix v v') f)) → M ≃ₗ[R] M'", "name": "LinearEquiv.ofIsUnitDet", "isProp": false, "docString": "Builds a linear equivalence from a linear map whose determinant in some bases is a unit. ", "terms": "[\n    \"linear equivalence\",\n    \"linear map\",\n    \"determinant\",\n    \"bases\",\n    \"unit\"\n]"}
{"type": "{m : Type u_2} →\n  {n : Type u_3} →\n    {α : Type u_4} →\n      [inst : Fintype m] →\n        [inst_1 : Fintype n] →\n          [inst_2 : DecidableEq m] →\n            [inst_3 : DecidableEq n] →\n              [inst_4 : CommRing α] →\n                (A : Matrix m m α) →\n                  (B : Matrix m n α) →\n                    (C : Matrix n m α) →\n                      (D : Matrix n n α) →\n                        [inst_5 : Invertible A] →\n                          [inst_6 : Invertible (Matrix.fromBlocks A B C D)] → Invertible (D - C * ⅟A * B)", "name": "Matrix.invertibleOfFromBlocks₁₁Invertible", "isProp": false, "docString": "If a block matrix is invertible and so is its bottom left element, then so is the corresponding\nSchur complement. ", "terms": "[\n    \"block matrix\",\n    \"invertible\",\n    \"bottom left element\",\n    \"corresponding\",\n    \"Schur complement\"\n]"}
{"type": "∀ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M],\n  Submodule.torsion R ↥(Submodule.torsion R M) = ⊤", "name": "Submodule.torsion_torsion_eq_top", "isProp": true, "docString": "The torsion submodule of the torsion submodule (viewed as a module) is the full\ntorsion module. ", "terms": "[\n    \"torsion submodule\",\n    \"module\",\n    \"full torsion module\"\n]"}
{"type": "∀ (R : Type u) [inst : Ring R] [inst_1 : StrongRankCondition R] {ι : Type v} [inst_2 : Fintype ι] (M : ι → Type w)\n  [inst_3 : (i : ι) → AddCommGroup (M i)] [inst_4 : (i : ι) → Module R (M i)] [inst_5 : ∀ (i : ι), Module.Free R (M i)]\n  [inst_6 : ∀ (i : ι), Module.Finite R (M i)],\n  FiniteDimensional.finrank R (DirectSum ι fun i => M i) =\n    Finset.sum Finset.univ fun i => FiniteDimensional.finrank R (M i)", "name": "FiniteDimensional.finrank_directSum", "isProp": true, "docString": "The finrank of the direct sum is the sum of the finranks. ", "terms": "[\n  \"finrank\",\n  \"direct sum\",\n  \"sum\"\n]"}
{"type": "∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a : α}, 0 ≤ a → a / 2 ≤ a", "name": "half_le_self", "isProp": true, "docString": "**Alias** of the reverse direction of `half_le_self_iff`.", "terms": "[\"Alias\", \"reverse direction\", \"half_le_self_iff\"]"}
{"type": "∀ {α : Type u} {β : Type v} {γ : Type w} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {s : Set α} {p : Filter ι}\n  [inst_1 : UniformSpace γ] {g : β → γ},\n  UniformContinuous g → UniformCauchySeqOn F p s → UniformCauchySeqOn (fun n => g ∘ F n) p s", "name": "UniformContinuous.comp_uniformCauchySeqOn", "isProp": true, "docString": "Composing on the left by a uniformly continuous function preserves\nuniform Cauchy sequences ", "terms": "[\n  \"Composing\",\n  \"Uniformly continuous function\",\n  \"Preserves\",\n  \"Uniform Cauchy sequences\"\n]"}
{"type": "∀ {n : ℕ} (self : CompositionAsSet n), Fin.last n ∈ self.boundaries", "name": "CompositionAsSet.getLast_mem", "isProp": true, "docString": "Last element of the composition", "terms": "[\"last element\", \"composition\"]"}
{"type": "∀ {M₀ : Type u_2} [inst : MulZeroClass M₀], (fun x => x * 0) = Function.const M₀ 0", "name": "mul_zero_eq_const", "isProp": true, "docString": "To match `mul_one_eq_id`. ", "terms": "The statement you provided does not contain any mathematical terms. Therefore, the JSON list is:\n\n    []"}
{"type": "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : PredOrder α] [inst_2 : IsPredArchimedean α] (r : α → α → Prop)\n  {n m : α},\n  (∀ i ∈ Set.Ioc m n, r i (Order.pred i)) → (∀ i ∈ Set.Ioc n m, r (Order.pred i) i) → n ≠ m → Relation.TransGen r n m", "name": "transGen_of_pred_of_ne", "isProp": true, "docString": "For `n ≠ m`, `(n, m)` is in the transitive closure of a relation `~` if `i ~ pred i` and\n`pred i ~ i` for all `i` between `n` and `m`. ", "terms": "[\n\"transitive closure\",\n\"relation\"\n]"}
{"type": "{E : Type u_2} →\n  [inst : NormedAddCommGroup E] →\n    [inst_1 : InnerProductSpace ℝ E] →\n      {n : ℕ} → [_i : Fact (FiniteDimensional.finrank ℝ E = n)] → Orientation ℝ E (Fin n) → E [Λ^Fin n]→ₗ[ℝ] ℝ", "name": "Orientation.volumeForm", "isProp": false, "docString": "The volume form on an oriented real inner product space, a nonvanishing top-dimensional\nalternating form uniquely defined by compatibility with the orientation and inner product structure.\n", "terms": "[\n    \"Volume form\",\n    \"Oriented\",\n    \"Real inner product space\",\n    \"Nonvanishing\",\n    \"Top-dimensional\",\n    \"Alternating form\",\n    \"Uniquely defined\",\n    \"Compatibility\",\n    \"Orientation\",\n    \"Inner product structure\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : AddCommMonoid α] {f : β → α} {γ : Type u_5}\n  [inst_2 : DivisionRing γ] [inst_3 : Module γ α] [inst_4 : ContinuousConstSMul γ α] [inst_5 : T2Space α] (g : γ),\n  ∑' (i : β), g • f i = g • ∑' (i : β), f i", "name": "tsum_const_smul''", "isProp": true, "docString": "Infinite sums commute with scalar multiplication. Version for scalars living in a\n`DivisionRing`; no summability hypothesis. This could be made to work for a\n`[GroupWithZero γ]` if there was such a thing as `DistribMulActionWithZero`. ", "terms": "[\n  \"Infinite sums\",\n  \"commute\",\n  \"scalar multiplication\",\n  \"Scalars\",\n  \"DivisionRing\",\n  \"summability hypothesis\",\n  \"GroupWithZero\",\n  \"DistribMulActionWithZero\"\n]"}
{"type": "{α : Type u_1} → (α →₀ ℕ) →+ Multiset α", "name": "Finsupp.toMultiset", "isProp": false, "docString": "Given `f : α →₀ ℕ`, `f.toMultiset` is the multiset with multiplicities given by the values of\n`f` on the elements of `α`. We define this function as an `AddMonoidHom`.\n\nUnder the additional assumption of `[DecidableEq α]`, this is available as\n`Multiset.toFinsupp : Multiset α ≃+ (α →₀ ℕ)`; the two declarations are separate as this assumption\nis only needed for one direction. ", "terms": "[\n    \"f\",\n    \"α\",\n    \"→₀\",\n    \"ℕ\",\n    \"f.toMultiset\",\n    \"multiset\",\n    \"multiplicities\",\n    \"values\",\n    \"elements\",\n    \"AddMonoidHom\",\n    \"DecidableEq\",\n    \"Multiset.toFinsupp\",\n    \"≃+\",\n    \"declarations\",\n    \"assumption\",\n    \"direction\"\n]"}
{"type": "∀ {α : Type u_1} {ι : Type u_4} {ι' : Type u_5} [inst : ConditionallyCompleteLinearOrder α] {v : Filter ι}\n  {p : ι' → Prop} {s : ι' → Set ι} [inst_1 : Countable (Subtype p)] [inst_2 : Nonempty (Subtype p)],\n  Filter.HasBasis v p s →\n    ∀ (f : ι → α),\n      Filter.limsup f v =\n        if ∃ j, s ↑j = ∅ then sInf Set.univ\n        else if ∀ (j : Subtype p), ¬BddAbove (Set.range fun i => f ↑i) then sInf ∅ else ⨅ j, ⨆ i, f ↑i", "name": "Filter.HasBasis.limsup_eq_ite", "isProp": true, "docString": "Writing a limsup as an infimum of supremum, in a (possibly non-complete) conditionally complete\nlinear order. A reparametrization trick is needed to avoid taking the supremum of sets which are\nnot bounded below. ", "terms": "[\n    \"limsup\",\n    \"infimum\",\n    \"supremum\",\n    \"conditionally complete\",\n    \"linear order\",\n    \"reparametrization trick\",\n    \"bounded below\"\n]"}
{"type": "{α : Type u} → {β : Type v} → [inst : Preorder β] → (α → β) → Filter α → α → Prop", "name": "IsMinFilter", "isProp": false, "docString": "`IsMinFilter f l a` means that `f a ≤ f x` in some `l`-neighborhood of `a` ", "terms": "[\n  \"IsMinFilter\",\n  \"≤\",\n  \"neighborhood\"\n]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P n) (i : Fin (n + 1)),\n  dist (Affine.Simplex.circumcenter s) (Affine.Simplex.points s i) = Affine.Simplex.circumradius s", "name": "Affine.Simplex.dist_circumcenter_eq_circumradius'", "isProp": true, "docString": "All points have distance to the circumcenter equal to the\ncircumradius. ", "terms": "[\n  \"points\",\n  \"distance\",\n  \"circumcenter\",\n  \"equal\",\n  \"circumradius\"\n]"}
{"type": "Simps.Config → Bool", "name": "Simps.Config.fullyApplied", "isProp": false, "docString": "Generated lemmas that are fully applied, i.e. generates equalities between applied functions.\nSet this to `false` to generate equalities between functions. ", "terms": "[\n  \"lemmas\",\n  \"fully applied\",\n  \"generates\",\n  \"equalities\",\n  \"applied functions\",\n  \"set\",\n  \"false\",\n  \"functions\"\n]"}
{"type": "{R : Type u} →\n  [inst : Add R] →\n    [inst_1 : Mul R] →\n      [inst_2 : Neg R] →\n        [inst_3 : Zero R] →\n          [inst_4 : One R] →\n            (∀ (a b c : R), a + b + c = a + (b + c)) →\n              (∀ (a : R), 0 + a = a) →\n                (∀ (a : R), -a + a = 0) →\n                  (∀ (a b c : R), a * b * c = a * (b * c)) →\n                    (∀ (a : R), 1 * a = a) →\n                      (∀ (a : R), a * 1 = a) →\n                        (∀ (a b c : R), a * (b + c) = a * b + a * c) →\n                          (∀ (a b c : R), (a + b) * c = a * c + b * c) → Ring R", "name": "Ring.ofMinimalAxioms", "isProp": false, "docString": "Define a `Ring` structure on a Type by proving a minimized set of axioms.\nNote that this uses the default definitions for `npow`, `nsmul`, `zsmul` and `sub`\nSee note [reducible non-instances]. ", "terms": "[\n  \"Ring\",\n  \"Type\",\n  \"axioms\",\n  \"npow\",\n  \"nsmul\",\n  \"zsmul\",\n  \"sub\",\n  \"reducible non-instances\"\n]"}
{"type": "∀ {M : Type u_3} {N : Type u_4} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] {f g : M →+ N},\n  f = g ↔ ∀ (x : M), f x = g x", "name": "AddMonoidHom.ext_iff", "isProp": true, "docString": "Deprecated: use `FunLike.ext_iff` instead.", "terms": "[\"Deprecated\", \"use\", \"`FunLike.ext_iff`\", \"instead\"]"}
{"type": "∀ {f : ℝ → ℝ}, (∀ (x : ℝ), 0 < deriv f x) → StrictMono f", "name": "strictMono_of_deriv_pos", "isProp": true, "docString": "Let `f : ℝ → ℝ` be a differentiable function. If `f'` is positive, then\n`f` is a strictly monotone function.\nNote that we don't require differentiability explicitly as it already implied by the derivative\nbeing strictly positive. ", "terms": "[\n    \"Real numbers\",\n    \"Function\",\n    \"Differentiable function\",\n    \"Positive\",\n    \"Strictly monotone function\",\n    \"Derivative\"\n]"}
{"type": "{𝕜 : Type u_1} →\n  {E : Type u_2} →\n    [inst : OrderedSemiring 𝕜] →\n      [inst_1 : AddCommGroup E] →\n        [inst_2 : SMul 𝕜 E] → (S : ConvexCone 𝕜 E) → ConvexCone.Pointed S → ConvexCone.Salient S → OrderedAddCommGroup E", "name": "ConvexCone.toOrderedAddCommGroup", "isProp": false, "docString": "A pointed and salient cone defines an `OrderedAddCommGroup`. ", "terms": "[\n    \"Pointed\",\n    \"Salient Cone\",\n    \"OrderedAddCommGroup\"\n]"}
{"type": "∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {H : Type uH}\n  [inst_2 : TopologicalSpace H] {I : ModelWithCorners ℝ E H} {M : Type uM} [inst_3 : TopologicalSpace M]\n  [inst_4 : ChartedSpace H M] {s : optParam (Set M) Set.univ} (self : SmoothPartitionOfUnity ι I M s) (x : M),\n  (finsum fun i => (SmoothPartitionOfUnity.toFun s self i) x) ≤ 1", "name": "SmoothPartitionOfUnity.sum_le_one'", "isProp": true, "docString": "The functions in the partition of unity add up to at most `1` everywhere. ", "terms": "[\n    \"functions\",\n    \"partition of unity\",\n    \"add up\",\n    \"at most\",\n    \"everywhere\"\n]"}
{"type": "∀ {X Y Z : Type u} (f : X ⟶ Y) {g h : Y ⟶ Z}\n  (w : CategoryTheory.CategoryStruct.comp f g = CategoryTheory.CategoryStruct.comp f h),\n  CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.Fork.ofι f w) → ∀ (y : Y), g y = h y → ∃! x, f x = y", "name": "CategoryTheory.Limits.Types.unique_of_type_equalizer", "isProp": true, "docString": "The converse of `type_equalizer_of_unique`. ", "terms": "[\n    \"converse\",\n    \"type\",\n    \"equalizer\",\n    \"unique\"\n]"}
{"type": "∀ {α : Type u_2} [inst : GeneralizedHeytingAlgebra α] {a b c : α}, Codisjoint a c → b ≤ a → c ⇨ b ≤ a", "name": "Codisjoint.himp_le_of_right_le", "isProp": true, "docString": "See `himp_le` for a stronger version in Boolean algebras. ", "terms": "[\"stronger version\", \"Boolean algebras\"]"}
{"type": "(R : Type u_1) →\n  (M : Type u_2) → [inst : CommSemiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → Set R → Submodule R M", "name": "Submodule.torsionBySet", "isProp": false, "docString": "The submodule containing all elements `x` of `M` such that `a • x = 0` for all `a` in `s`. ", "terms": "[\n  \"submodule\",\n  \"elements\",\n  \"zero\",\n  \"for all\"\n]"}
{"type": "(p : ENNReal) → p ≤ 1 → (n : ℕ) → PMF (Fin (n + 1))", "name": "PMF.binomial", "isProp": false, "docString": "The binomial `PMF`: the probability of observing exactly `i` “heads” in a sequence of `n`\nindependent coin tosses, each having probability `p` of coming up “heads”. ", "terms": "[\n    \"binomial\",\n    \"PMF\",\n    \"probability\",\n    \"observing\",\n    \"exactly\",\n    \"sequence\",\n    \"independent\",\n    \"coin tosses\",\n    \"coming up\"\n]"}
{"type": "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  1 < Module.rank K V → ∀ {x : V}, x ≠ 0 → ∃ y, LinearIndependent K ![x, y]", "name": "exists_linearIndependent_pair_of_one_lt_rank", "isProp": true, "docString": "Given a nonzero vector in a space of dimension `> 1`, one may find another vector linearly\nindependent of the first one. ", "terms": "[\n  \"nonzero vector\",\n  \"space\",\n  \"dimension\",\n  \"vector\",\n  \"linearly independent\"\n]"}
{"type": "{X Y B : Profinite} → (f : X ⟶ B) → (g : Y ⟶ B) → CategoryTheory.Limits.PullbackCone f g", "name": "Profinite.pullback.cone", "isProp": false, "docString": "The pullback cone whose cone point is the explicit pullback. ", "terms": "[\n  \"pullback cone\",\n  \"cone point\",\n  \"explicit pullback\"\n]"}
{"type": "∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G],\n  TopologicalSpace.PositiveCompacts G → WeaklyLocallyCompactSpace G", "name": "TopologicalSpace.PositiveCompacts.weaklyLocallyCompactSpace_of_group", "isProp": true, "docString": "Every topological group in which there exists a compact set with nonempty interior\nis weakly locally compact. ", "terms": "[\n    \"Topological Group\",\n    \"Compact Set\",\n    \"Nonempty Interior\",\n    \"Weakly Locally Compact\"\n]"}
{"type": "{α : Type u_1} → [ord : Ord α] → [inst : Inhabited α] → (xs : Array α) → optParam ℕ 0 → optParam ℕ (Array.size xs) → α", "name": "Array.maxI", "isProp": false, "docString": "Find the first maximal element of an array. If the array is empty, `default` is\nreturned. If `start` and `stop` are given, only the subarray `xs[start:stop]` is\nconsidered.\n", "terms": "[\"first\", \"maximal element\", \"array\", \"empty\", \"default\", \"returned\", \"start\", \"stop\", \"subarray\", \"xs[start:stop]\", \"considered\"]"}
{"type": "{ι : Type u_1} → BoxIntegral.Box ι → Set ι ↪ BoxIntegral.Box ι", "name": "BoxIntegral.Box.splitCenterBoxEmb", "isProp": false, "docString": "`BoxIntegral.Box.splitCenterBox` bundled as a `Function.Embedding`. ", "terms": "[\"BoxIntegral.Box.splitCenterBox\", \"Function.Embedding\"]"}
{"type": "ℕ → ℝ → ℝ", "name": "bernoulliFun", "isProp": false, "docString": "The function `x ↦ Bₖ(x) : ℝ → ℝ`. ", "terms": "[\"function\", \"ℝ\", \"ℝ\"]"}
{"type": "∀ {β : Sort u_1} {α : Sort u_2} (P : β → Sort w) (e : α ≃ β) (f : (a : α) → P (e a)) (a : α),\n  (Equiv.piCongrLeft P e) f (e a) = f a", "name": "Equiv.piCongrLeft_apply_apply", "isProp": true, "docString": "Note: the \"obvious\" statement `(piCongrLeft P e) f b = f (e.symm b)` doesn't typecheck: the\nLHS would have type `P b` while the RHS would have type `P (e (e.symm b))`. This lemma is a way\naround it in the case where `b` is of the form `e a`, so we can use `f a` instead of\n`f (e.symm (e a))`. ", "terms": "[\n    \"piCongrLeft\",\n    \"typecheck\",\n    \"LHS (Left Hand Side)\",\n    \"RHS (Right Hand Side)\",\n    \"type\",\n    \"lemma\",\n    \"symm (symmetric)\",\n    \"case\"\n]"}
{"type": "∀ {B : Type u_1} (F₁ : Type u_2) (E₁ : B → Type u_3) (F₂ : Type u_4) (E₂ : B → Type u_5)\n  [inst : TopologicalSpace (Bundle.TotalSpace F₁ E₁)] [inst_1 : TopologicalSpace (Bundle.TotalSpace F₂ E₂)],\n  Inducing fun p => ({ proj := p.proj, snd := p.snd.1 }, { proj := p.proj, snd := p.snd.2 })", "name": "FiberBundle.Prod.inducing_diag", "isProp": true, "docString": "The diagonal map from the total space of the fiberwise product of two fiber bundles\n`E₁`, `E₂` into `TotalSpace F₁ E₁ × TotalSpace F₂ E₂` is `Inducing`. ", "terms": "[\n  \"diagonal map\",\n  \"total space\",\n  \"fiberwise product\",\n  \"fiber bundles\",\n  \"TotalSpace\",\n  \"Inducing\"\n]"}
{"type": "∀ {R : Type u_1} [inst : CommRing R] (I : Ideal R), Filter.HasBasis (nhds 0) (fun _n => True) fun n => ↑(I ^ n)", "name": "Ideal.hasBasis_nhds_zero_adic", "isProp": true, "docString": "For the `I`-adic topology, the neighborhoods of zero has basis given by the powers of `I`. ", "terms": "[\n    \"I-adic topology\",\n    \"neighborhoods\",\n    \"zero\",\n    \"basis\",\n    \"powers\"\n]"}
{"type": "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α]\n  [inst_3 : DenselyOrdered α] {a : α}, Set.Nonempty (Set.Ioi a) → closure (Set.Ioi a) = Set.Ici a", "name": "closure_Ioi'", "isProp": true, "docString": "The closure of the interval `(a, +∞)` is the closed interval `[a, +∞)`, unless `a` is a top\nelement. ", "terms": "[\n    \"closure\",\n    \"interval\",\n    \"closed interval\",\n    \"top element\"\n]"}
{"type": "(L : FirstOrder.Language) → (M : Type w) → [inst : FirstOrder.Language.Structure L M] → FirstOrder.Language.Hom L M M", "name": "FirstOrder.Language.Hom.id", "isProp": false, "docString": "The identity map from a structure to itself. ", "terms": "[\n    \"identity map\",\n    \"structure\"\n]"}
{"type": "∀ {𝕜 : Type u_4} {E : Type u_5} {P : Type u_6} [inst : NormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : MeasurableSpace P] [inst_4 : MetricSpace P] [inst_5 : NormedAddTorsor E P]\n  [inst_6 : BorelSpace P] {d : ℝ},\n  0 ≤ d →\n    ∀ (x : P) {c : 𝕜},\n      c ≠ 0 →\n        ∀ (s : Set P),\n          ↑↑(MeasureTheory.Measure.hausdorffMeasure d) (⇑(AffineMap.homothety x c) '' s) =\n            NNReal.rpow ‖c‖₊ d • ↑↑(MeasureTheory.Measure.hausdorffMeasure d) s", "name": "MeasureTheory.hausdorffMeasure_homothety_image", "isProp": true, "docString": "Scaling by `c` around `x` scales the measure by `‖c‖₊ ^ d`. ", "terms": "[\n    \"Scaling\",\n    \"Measure\",\n    \"Norm\",\n    \"Exponentiation\"\n]"}
{"type": "{R : Type u} → [inst : NonAssocSemiring R] → CompleteLattice (Subsemiring R)", "name": "Subsemiring.instCompleteLatticeSubsemiring", "isProp": false, "docString": "Subsemirings of a semiring form a complete lattice. ", "terms": "[\"Subsemirings\", \"semiring\", \"form\", \"complete lattice\"]"}
{"type": "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b : α}, a ≤ 1 → b ≤ 1 → a * b ≤ 1", "name": "mul_le_one'", "isProp": true, "docString": "**Alias** of `Left.mul_le_one`.\n\n---\n\nAssumes left covariance.\nThe lemma assuming right covariance is `Right.mul_le_one`. ", "terms": "[]\n"}
{"type": "{R₁ : Type u_1} →\n  [inst : Semiring R₁] →\n    {M₁ : Type u_4} →\n      [inst_1 : TopologicalSpace M₁] →\n        [inst_2 : AddCommMonoid M₁] → [inst_3 : Module R₁ M₁] → ULift.{u_10, u_4} M₁ ≃L[R₁] M₁", "name": "ContinuousLinearEquiv.ulift", "isProp": false, "docString": "The continuous linear equivalence between `ULift M₁` and `M₁`.\n\nThis is a continuous version of `ULift.moduleEquiv`. ", "terms": "[\n  \"continuous\",\n  \"linear\",\n  \"equivalence\",\n  \"ULift\",\n  \"moduleEquiv\"\n]"}
{"type": "∀ {α : Type u} [inst : Preorder α] [inst_1 : IsDirected α fun x x_1 => x ≤ x_1] [inst_2 : Nonempty α] {s : Set α},\n  Set.Finite s → BddAbove s", "name": "Set.Finite.bddAbove", "isProp": true, "docString": "A finite set is bounded above.", "terms": "[\"finite set\", \"bounded above\"]"}
{"type": "{R : Type u_1} →\n  [inst : CommSemiring R] →\n    {n : Type w} →\n      [inst_1 : DecidableEq n] → [inst_2 : Fintype n] → Matrix n n (Polynomial R) ≃ₐ[R] Polynomial (Matrix n n R)", "name": "matPolyEquiv", "isProp": false, "docString": "The algebra isomorphism stating \"matrices of polynomials are the same as polynomials of matrices\".\n\n(You probably shouldn't attempt to use this underlying definition ---\nit's an algebra equivalence, and characterised extensionally by the lemma\n`matPolyEquiv_coeff_apply` below.)\n", "terms": "[\n    \"algebra\",\n    \"isomorphism\",\n    \"matrices\",\n    \"polynomials\",\n    \"equivalence\",\n    \"characterised\",\n    \"extensionally\",\n    \"lemma\"\n]"}
{"type": "{α : Type u_2} →\n  [inst : AddCommMonoid α] →\n    {A : Set α} → {n : ℕ} → {β : Type u_7} → [inst_1 : AddCommGroup β] → AddCommGroup (A →+[n] β)", "name": "AddFreimanHom.addCommGroup", "isProp": false, "docString": "If `β` is an additive commutative group, then `A →*[n] β` is an additive commutative\ngroup too.", "terms": "[\n    \"additive commutative group\"\n]"}
{"type": "∀ {α : Type u_1} [inst : TopologicalSpace α] {x : α} {γ : Type u_4} [inst_1 : LinearOrderedAddCommMonoid γ]\n  [inst_2 : TopologicalSpace γ] [inst_3 : OrderTopology γ] {f g : α → γ},\n  UpperSemicontinuousAt f x →\n    UpperSemicontinuousAt g x →\n      ContinuousAt (fun p => p.1 + p.2) (f x, g x) → UpperSemicontinuousAt (fun z => f z + g z) x", "name": "UpperSemicontinuousAt.add'", "isProp": true, "docString": "The sum of two upper semicontinuous functions is upper semicontinuous. Formulated with an\nexplicit continuity assumption on addition, for application to `EReal`. The unprimed version of\nthe lemma uses `[ContinuousAdd]`. ", "terms": "[\n  \"sum\",\n  \"upper semicontinuous\",\n  \"functions\",\n  \"continuity\",\n  \"addition\",\n  \"EReal\",\n  \"lemma\",\n  \"ContinuousAdd\"\n]"}
{"type": "∀ {ι : Type u_1} [inst : Finite ι] {I : BoxIntegral.Box ι} {π : BoxIntegral.Prepartition I},\n  BoxIntegral.Prepartition.IsPartition π → ∃ s, BoxIntegral.Prepartition.splitMany I s ≤ π", "name": "BoxIntegral.Prepartition.IsPartition.exists_splitMany_le", "isProp": true, "docString": "If `π` is a partition of `I`, then there exists a finite set `s` of hyperplanes such that\n`splitMany I s ≤ π`. ", "terms": "[\n  \"partition\",\n  \"exists\",\n  \"finite set\",\n  \"hyperplanes\",\n  \"splitMany\",\n  \"≤\"\n]"}
{"type": "{R₁ : Type u_2} →\n  {R₂ : Type u_3} →\n    {M : Type u_9} →\n      {M₂ : Type u_11} →\n        [inst : Semiring R₁] →\n          [inst_1 : Semiring R₂] →\n            [inst_2 : AddCommMonoid M] →\n              [inst_3 : AddCommMonoid M₂] →\n                [inst_4 : Module R₁ M] → [inst_5 : Module R₂ M₂] → {σ₁₂ : R₁ →+* R₂} → Zero (M →ₛₗ[σ₁₂] M₂)", "name": "LinearMap.instZeroLinearMap", "isProp": false, "docString": "The constant 0 map is linear. ", "terms": "[\n    \"constant\",\n    \"0\",\n    \"map\",\n    \"linear\"\n]"}
{"type": "∀ {α : Type u_1} {m : MeasurableSpace α} (s : Set α), Nonempty { t // s ⊆ t ∧ MeasurableSet t }", "name": "nonempty_measurable_superset", "isProp": true, "docString": "Every set has a measurable superset. Declare this as local instance as needed. ", "terms": "[\n    \"set\",\n    \"measurable\",\n    \"superset\",\n    \"local instance\"\n]"}
{"type": "{V : Type u} → SimpleGraph V → Type u", "name": "SimpleGraph.ConnectedComponent", "isProp": false, "docString": "The quotient of `V` by the `SimpleGraph.Reachable` relation gives the connected\ncomponents of a graph. ", "terms": "[\n    \"quotient\",\n    \"SimpleGraph.Reachable\",\n    \"relation\",\n    \"connected components\",\n    \"graph\"\n]"}
{"type": "{X : Type u} →\n  {Y : Type v} →\n    [inst : TopologicalSpace X] →\n      [inst_1 : TopologicalSpace Y] →\n        {x₀ x₁ : X} → Path x₀ x₁ → ContinuousMap.Homotopy (ContinuousMap.const Y x₀) (ContinuousMap.const Y x₁)", "name": "Path.toHomotopyConst", "isProp": false, "docString": "A path `Path x₀ x₁` generates a homotopy between constant functions `fun _ ↦ x₀` and\n`fun _ ↦ x₁`. ", "terms": "[\n    \"path\",\n    \"homotopy\",\n    \"constant functions\"\n]"}
{"type": "{R : Type u_1} → [inst : CommRing R] → (Fin 3 → R) →ₗ[R] (Fin 3 → R) →ₗ[R] Fin 3 → R", "name": "crossProduct", "isProp": false, "docString": "The cross product of two vectors in $R^3$ for $R$ a commutative ring. ", "terms": "[\n  \"cross product\",\n  \"vectors\",\n  \"R^3\",\n  \"commutative ring\"\n]"}
{"type": "{M : Type u_1} → [inst : AddGroup M] → (c : AddCon M) → AddGroup (AddCon.Quotient c)", "name": "AddCon.addGroup", "isProp": false, "docString": "The quotient of an `AddGroup` by an additive congruence relation is\nan `AddGroup`.", "terms": "[\n  \"Quotient\",\n  \"AddGroup\",\n  \"Additive Congruence Relation\"\n]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      [inst_2 : CategoryTheory.MonoidalCategory C] →\n        [inst_3 : CategoryTheory.MonoidalPreadditive C] →\n          [inst_4 : CategoryTheory.Limits.HasFiniteBiproducts C] →\n            {J : Type} →\n              [inst_5 : Fintype J] →\n                (X : C) →\n                  (f : J → C) →\n                    CategoryTheory.MonoidalCategory.tensorObj X (⨁ f) ≅\n                      ⨁ fun j => CategoryTheory.MonoidalCategory.tensorObj X (f j)", "name": "CategoryTheory.leftDistributor", "isProp": false, "docString": "The isomorphism showing how tensor product on the left distributes over direct sums. ", "terms": "[\n    \"Isomorphism\",\n    \"Tensor Product\",\n    \"Distributes\",\n    \"Direct Sums\"\n]"}
{"type": "{R : Type u_1} → {n : Type u_9} → [inst : CommRing R] → [inst : Fintype n] → Matrix n n R → Matrix n n R → Prop", "name": "Matrix.IsSelfAdjoint", "isProp": false, "docString": "The condition for a square matrix `A` to be self-adjoint with respect to the square matrix\n`J`. ", "terms": "[\n    \"condition\",\n    \"square matrix\",\n    \"self-adjoint\",\n    \"respect to\"\n]"}
{"type": "(α : Type u_1) → α × Empty ≃ Empty", "name": "Equiv.prodEmpty", "isProp": false, "docString": "`Empty` type is a right absorbing element for type product up to an equivalence. ", "terms": "[\n    \"Empty type\",\n    \"right absorbing element\",\n    \"type product\",\n    \"equivalence\"\n]"}
{"type": "∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {p₁ p₂ p₃ p₄ p₅ : P},\n  p₁ ∈ affineSpan k {p₄, p₅} → p₂ ∈ affineSpan k {p₄, p₅} → p₃ ∈ affineSpan k {p₄, p₅} → Collinear k {p₁, p₂, p₃}", "name": "collinear_triple_of_mem_affineSpan_pair", "isProp": true, "docString": "If three points lie in the affine span of two points, the first three points are collinear. ", "terms": "[\n  \"three points\",\n  \"lie\",\n  \"affine span\",\n  \"two points\",\n  \"first three points\",\n  \"collinear\"\n]"}
{"type": "{n : ℕ} →\n  {F : TypeVec.{u} (n + 1) → Type u} →\n    [inst : MvFunctor F] → [q : MvQPF F] → {α : TypeVec.{u} n} → {β : Type u} → (F (α ::: β) → β) → MvQPF.Fix F α → β", "name": "MvQPF.Fix.rec", "isProp": false, "docString": "Recursor for `Fix F` ", "terms": "[\"Recursor\", \"Fix\", \"F\"]"}
{"type": "∀ {α : Type u_1} {m : MeasurableSpace α} (ν μ : MeasureTheory.Measure α) [inst : MeasureTheory.IsFiniteMeasure ν]\n  [inst : MeasureTheory.Measure.HaveLebesgueDecomposition ν μ] (r : NNReal),\n  MeasureTheory.Measure.rnDeriv (r • ν) μ =ᶠ[MeasureTheory.Measure.ae μ] r • MeasureTheory.Measure.rnDeriv ν μ", "name": "MeasureTheory.Measure.rnDeriv_smul_left", "isProp": true, "docString": "Radon-Nikodym derivative of the scalar multiple of a measure.\nSee also `rnDeriv_smul_left'`, which requires sigma-finite `ν` and `μ`. ", "terms": "[\n    \"Radon-Nikodym derivative\",\n    \"scalar multiple\",\n    \"measure\",\n    \"sigma-finite\"\n]"}
{"type": "{α : Type u_1} → {β : Type u_2} → Equiv.Perm α → Equiv.Perm β → Equiv.Perm (α ⊕ β)", "name": "Equiv.Perm.sumCongr", "isProp": false, "docString": "Combine a permutation of `α` and of `β` into a permutation of `α ⊕ β`. ", "terms": "[\"Combine\", \"permutation\", \"⊕\"]"}
{"type": "(X : AlgebraicGeometry.Scheme) →\n  CategoryTheory.Functor.comp (AlgebraicGeometry.Scheme.restrictFunctor X).op\n      (CategoryTheory.Functor.comp (CategoryTheory.Over.forget X).op AlgebraicGeometry.Scheme.Γ) ≅\n    X.presheaf", "name": "AlgebraicGeometry.Scheme.restrictFunctorΓ", "isProp": false, "docString": "The functor that restricts to open subschemes and then takes global section is\nisomorphic to the structure sheaf. ", "terms": "[\n    \"functor\",\n    \"restricts\",\n    \"open subschemes\",\n    \"global section\",\n    \"isomorphic\",\n    \"structure sheaf\"\n]"}
{"type": "(k : Type u_1) →\n  {P₁ : Type u_2} →\n    {V₁ : Type u_6} →\n      [inst : Ring k] →\n        [inst_1 : AddCommGroup V₁] → [inst_2 : Module k V₁] → [inst_3 : AddTorsor V₁ P₁] → P₁ → V₁ ≃ᵃ[k] P₁", "name": "AffineEquiv.vaddConst", "isProp": false, "docString": "The map `v ↦ v +ᵥ b` as an affine equivalence between a module `V` and an affine space `P` with\ntangent space `V`. ", "terms": "[\n    \"map\", \n    \"affine equivalence\", \n    \"module\", \n    \"affine space\", \n    \"tangent space\"\n]"}
{"type": "(K : Type u_1) →\n  {L : Type u_2} →\n    [inst : Field K] → [inst_1 : Field L] → [inst_2 : Algebra K L] → ValuationSubring L → Subgroup (L ≃ₐ[K] L)", "name": "ValuationSubring.decompositionSubgroup", "isProp": false, "docString": "The decomposition subgroup defined as the stabilizer of the action\non the type of all valuation subrings of the field. ", "terms": "[\n    \"Decomposition subgroup\",\n    \"Stabilizer\",\n    \"Action\",\n    \"Type\",\n    \"Valuation subrings\",\n    \"Field\"\n]"}
{"type": "∀ (α : Type u) [inst : OrderedCommGroup α], ContravariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1", "name": "OrderedCommGroup.to_contravariantClass_left_le", "isProp": true, "docString": "A choice-free shortcut instance. ", "terms": "[]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {J : Type w} →\n          [inst_2 : CategoryTheory.Category.{w', w} J] →\n            (F : CategoryTheory.Functor C D) →\n              [inst_3 : CategoryTheory.CreatesColimitsOfShape J F] →\n                [inst_4 : CategoryTheory.Limits.HasColimitsOfShape J D] →\n                  CategoryTheory.Limits.PreservesColimitsOfShape J F", "name": "CategoryTheory.preservesColimitOfShapeOfCreatesColimitsOfShapeAndHasColimitsOfShape", "isProp": false, "docString": "`F` preserves the colimit of shape `J` if it creates these colimits and `D` has them. ", "terms": "[\n    \"preserves\",\n    \"colimit\",\n    \"shape\",\n    \"creates\",\n    \"has\"\n]"}
{"type": "Lean.ParserDescr", "name": "Interval.«term[[_,_]]»", "isProp": false, "docString": "`[[a, b]]` denotes the set of elements lying between `a` and `b`, inclusive. ", "terms": "[\"denotes\", \"set\", \"elements\", \"lying\", \"between\", \"inclusive\"]"}
{"type": "{𝕜 : Type u_1} →\n  {E : Type u_2} →\n    [inst : IsROrC 𝕜] →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : InnerProductSpace 𝕜 E] →\n          {ι : Type u_3} →\n            [inst_3 : LinearOrder ι] →\n              [inst_4 : LocallyFiniteOrderBot ι] →\n                [inst_5 : IsWellOrder ι fun x x_1 => x < x_1] → Basis ι 𝕜 E → Basis ι 𝕜 E", "name": "gramSchmidtBasis", "isProp": false, "docString": "When given a basis, `gramSchmidt` produces a basis. ", "terms": "[\n  \"basis\",\n  \"gramSchmidt\"\n]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]\n  {F : CategoryTheory.Functor C D} {G : CategoryTheory.Functor D C} (self : F ⊣ G) {X : C} {Y : D} {g : X ⟶ G.obj Y},\n  (CategoryTheory.Adjunction.homEquiv self X Y).symm g =\n    CategoryTheory.CategoryStruct.comp (F.map g) (self.counit.app Y)", "name": "CategoryTheory.Adjunction.homEquiv_counit", "isProp": true, "docString": "Naturality of the counit of an adjunction ", "terms": "[\n    \"Naturality\",\n    \"counit\",\n    \"adjunction\"\n]"}
{"type": "(p : Type u_2) →\n  (q : Type u_3) →\n    (R : Type u₂) →\n      [inst : DecidableEq p] →\n        [inst_1 : DecidableEq q] →\n          [inst_2 : CommRing R] →\n            [inst_3 : Fintype p] →\n              [inst_4 : Fintype q] →\n                {i : R} → i * i = -1 → ↥(LieAlgebra.Orthogonal.so' p q R) ≃ₗ⁅R⁆ ↥(LieAlgebra.Orthogonal.so (p ⊕ q) R)", "name": "LieAlgebra.Orthogonal.soIndefiniteEquiv", "isProp": false, "docString": "An equivalence between the indefinite and definite orthogonal Lie algebras, over a ring\ncontaining a square root of -1. ", "terms": "[\n  \"equivalence\",\n  \"indefinite\",\n  \"definite\",\n  \"orthogonal\",\n  \"Lie algebras\",\n  \"ring\",\n  \"square root\",\n  \"-1\"\n]"}
{"type": "∀ {𝕜 : Type u_3} {E : Type u_7} [inst : NormedField 𝕜] [inst_1 : SeminormedAddCommGroup E] [inst_2 : NormedSpace 𝕜 E]\n  {r : ℝ}, Balanced 𝕜 (Metric.ball 0 r)", "name": "balanced_ball_zero", "isProp": true, "docString": "Balls at the origin are balanced. ", "terms": "[\"Balls\", \"origin\", \"balanced\"]"}
{"type": "(n : Type u) → [inst : DecidableEq n] → [inst : Fintype n] → (R : Type v) → [inst : CommRing R] → Type (max 0 u v)", "name": "Matrix.SpecialLinearGroup", "isProp": false, "docString": "`SpecialLinearGroup n R` is the group of `n` by `n` `R`-matrices with determinant equal to 1.\n", "terms": "[\n    \"SpecialLinearGroup\",\n    \"group\",\n    \"matrices\",\n    \"determinant\",\n    \"equal\"\n]"}
{"type": "∀ {ι : Type u_1} {α : Type u_2} [inst : CommMonoid α] (t : Finset ι) (f : ι → Set α) (g : ι → α),\n  (∀ i ∈ t, g i ∈ f i) → (Finset.prod t fun i => g i) ∈ Finset.prod t fun i => f i", "name": "Set.finset_prod_mem_finset_prod", "isProp": true, "docString": "An n-ary version of `Set.mul_mem_mul`. ", "terms": "[\"n-ary\", \"Set\", \"mul_mem_mul\"]"}
{"type": "String → List String → List String", "name": "ToAdditive.capitalizeFirstLike", "isProp": false, "docString": "Capitalize First element of a list like `s`.\nNote that we need to capitalize multiple characters in some cases,\nin examples like `HMul` or `hAdd`. ", "terms": "[\n\"First element\",\n\"list\",\n\"capitalize\",\n\"characters\",\n\"examples\"\n]"}
{"type": "∀ {n : ℕ}, orderOf (DihedralGroup.r 1) = n", "name": "DihedralGroup.orderOf_r_one", "isProp": true, "docString": "If `0 < n`, then `r 1` has order `n`.\n", "terms": "[\"0\", \"<\", \"order\"]"}
{"type": "{α : Type u_1} → {β : Type u_2} → (G : SimpleGraph α) → (H : SimpleGraph β) → G □ H ≃g H □ G", "name": "SimpleGraph.boxProdComm", "isProp": false, "docString": "The box product is commutative up to isomorphism. `Equiv.prodComm` as a graph isomorphism. ", "terms": "[\n    \"box product\",\n    \"commutative\",\n    \"isomorphism\",\n    \"graph isomorphism\"\n]"}
{"type": "∀ {Ω : Type u_1} [inst : MeasurableSpace Ω] [inst_1 : TopologicalSpace Ω] [inst_2 : HasOuterApproxClosed Ω]\n  [inst_3 : BorelSpace Ω] {μ ν : MeasureTheory.Measure Ω} [inst_4 : MeasureTheory.IsFiniteMeasure μ],\n  (∀ (f : BoundedContinuousFunction Ω NNReal), ∫⁻ (x : Ω), ↑(f x) ∂μ = ∫⁻ (x : Ω), ↑(f x) ∂ν) → μ = ν", "name": "MeasureTheory.ext_of_forall_lintegral_eq_of_IsFiniteMeasure", "isProp": true, "docString": "Two finite Borel measures are equal if the integrals of all bounded continuous functions with\nrespect to both agree. ", "terms": "[\n  \"Finite\",\n  \"Borel measures\",\n  \"Equal\",\n  \"Integrals\",\n  \"Bounded\",\n  \"Continuous functions\",\n  \"Respect to\",\n  \"Agree\"\n]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Preadditive C] (X Y : C)\n  [inst_2 : CategoryTheory.Limits.HasBinaryCoproduct X Y], CategoryTheory.Limits.HasBinaryBiproduct X Y", "name": "CategoryTheory.Limits.HasBinaryBiproduct.of_hasBinaryCoproduct", "isProp": true, "docString": "In a preadditive category, if the coproduct of `X` and `Y` exists, then the\nbinary biproduct of `X` and `Y` exists. ", "terms": "[\n    \"preadditive category\",\n    \"coproduct\",\n    \"binary biproduct\"\n]"}
{"type": "{n : ℕ} →\n  (a : Composition n) →\n    (b : Composition (Composition.length a)) →\n      (i : Fin (Composition.length (Composition.gather a b))) →\n        Composition (Composition.blocksFun (Composition.gather a b) i)", "name": "Composition.sigmaCompositionAux", "isProp": false, "docString": "An auxiliary function used in the definition of `sigmaEquivSigmaPi` below, associating to\ntwo compositions `a` of `n` and `b` of `a.length`, and an index `i` bounded by the length of\n`a.gather b`, the subcomposition of `a` made of those blocks belonging to the `i`-th block of\n`a.gather b`. ", "terms": "[\n  \"auxiliary function\",\n  \"definition\",\n  \"sigmaEquivSigmaPi\",\n  \"associating\",\n  \"compositions\",\n  \"length\",\n  \"index\",\n  \"bounded\",\n  \"subcomposition\",\n  \"blocks\"\n]"}
{"type": "{α : Type u_1} → {β : Type u_2} → α ⊕ β → Bool", "name": "Sum.isLeft", "isProp": false, "docString": "Check if a sum is `inl`. ", "terms": "[\"sum\", \"inl\"]"}
{"type": "{α : Type u_1} → {β : Type u_2} → (f : α → β) → (s : Set α) → Set.InjOn f s → ↑s ≃ ↑(f '' s)", "name": "Equiv.Set.imageOfInjOn", "isProp": false, "docString": "If a function `f` is injective on a set `s`, then `s` is equivalent to `f '' s`. ", "terms": "[\n    \"function\",\n    \"injective\",\n    \"set\",\n    \"equivalent\"\n]"}
{"type": "∀ {R : Type u} [self : AddCommGroupWithOne R] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1", "name": "AddCommGroupWithOne.natCast_succ", "isProp": true, "docString": "The canonical map `ℕ → R` is a homomorphism. ", "terms": "[\n    \"canonical map\",\n    \"ℕ\",\n    \"R\",\n    \"homomorphism\"\n]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (P Q : C) [inst_1 : CategoryTheory.Limits.HasBinaryProduct P Q]\n  [inst_2 : CategoryTheory.Limits.HasBinaryProduct Q P],\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.braiding P Q).hom\n      (CategoryTheory.Limits.prod.braiding Q P).hom =\n    CategoryTheory.CategoryStruct.id (P ⨯ Q)", "name": "CategoryTheory.Limits.prod.symmetry", "isProp": true, "docString": "The braiding isomorphism is symmetric. ", "terms": "[\n    \"braiding\",\n    \"isomorphism\",\n    \"symmetric\"\n]"}
{"type": "(F : CategoryTheory.Functor CompHausᵒᵖ AddCommGroupCat) →\n  [inst : CategoryTheory.Limits.PreservesFiniteProducts F] →\n    CategoryTheory.regularCoverage.EqualizerCondition\n        (CategoryTheory.Functor.comp F (CategoryTheory.forget AddCommGroupCat)) →\n      CondensedAb", "name": "CondensedAb.ofSheafCompHaus", "isProp": false, "docString": "A `CondensedAb` version of `Condensed.ofSheafCompHaus`. ", "terms": "[\"CondensedAb\", \"Condensed.ofSheafCompHaus\"]"}
{"type": "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {E' : Type u_3} [inst_3 : NormedAddCommGroup E'] [inst_4 : NormedSpace 𝕜 E'] {f : E → E'},\n  MDifferentiable (modelWithCornersSelf 𝕜 E) (modelWithCornersSelf 𝕜 E') f ↔ Differentiable 𝕜 f", "name": "mdifferentiable_iff_differentiable", "isProp": true, "docString": "For maps between vector spaces, `MDifferentiable` and `Differentiable` coincide ", "terms": "[\n  \"maps\",\n  \"vector spaces\",\n  \"MDifferentiable\",\n  \"Differentiable\",\n  \"coincide\"\n]"}
{"type": "∀ {E : Type u_5} {P : Type u_6} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace P]\n  [inst_3 : MetricSpace P] [inst_4 : NormedAddTorsor E P] [inst_5 : BorelSpace P] (x y : P) (s : Set ℝ),\n  ↑↑(MeasureTheory.Measure.hausdorffMeasure 1) (⇑(AffineMap.lineMap x y) '' s) =\n    nndist x y • ↑↑(MeasureTheory.Measure.hausdorffMeasure 1) s", "name": "MeasureTheory.hausdorffMeasure_lineMap_image", "isProp": true, "docString": "Mapping a set of reals along a line segment scales the measure by the length of a segment.\n\nThis is an auxiliary result used to prove `hausdorffMeasure_affineSegment`. ", "terms": "[\n  \"Mapping\",\n  \"Set\",\n  \"Reals\",\n  \"Line segment\",\n  \"Scales\",\n  \"Measure\",\n  \"Length\",\n  \"Segment\",\n  \"Auxiliary result\",\n  \"Hausdorff measure\",\n  \"Affine segment\"\n]"}
{"type": "∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\n  EMetric.hausdorffEdist s t ≠ ⊤ → (Metric.hausdorffDist s t = 0 ↔ closure s = closure t)", "name": "Metric.hausdorffDist_zero_iff_closure_eq_closure", "isProp": true, "docString": "Two sets are at zero Hausdorff distance if and only if they have the same closures ", "terms": "[\n    \"Sets\",\n    \"Zero\",\n    \"Hausdorff distance\",\n    \"If and only if\",\n    \"Same\",\n    \"Closures\"\n]"}
{"type": "∀ {R : Type u_1} {S : Type u_2} [inst : CommSemiring R] [inst_1 : CommRing S] [inst : Algebra R S] (I : Ideal S),\n  IsNilpotent I →\n    ∀ {P : ⦃S : Type u_2⦄ → [inst : CommRing S] → Ideal S → Prop},\n      (∀ ⦃S : Type u_2⦄ [inst : CommRing S] (I : Ideal S), I ^ 2 = ⊥ → P I) →\n        (∀ ⦃S : Type u_2⦄ [inst : CommRing S] (I J : Ideal S),\n            I ≤ J → P I → P (Ideal.map (Ideal.Quotient.mk I) J) → P J) →\n          P I", "name": "Ideal.IsNilpotent.induction_on", "isProp": true, "docString": "Let `P` be a property on ideals. If `P` holds for square-zero ideals, and if\n`P I → P (J ⧸ I) → P J`, then `P` holds for all nilpotent ideals. ", "terms": "[\n    \"property\", \n    \"ideals\",\n    \"square-zero ideals\", \n    \"nilpotent ideals\"\n]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_3, u_1} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      {S : CategoryTheory.ShortComplex C} → CategoryTheory.ShortComplex.Splitting S → CategoryTheory.SplitMono S.f", "name": "CategoryTheory.ShortComplex.Splitting.splitMono_f", "isProp": false, "docString": "Given a splitting of a short complex `S`, this shows that `S.f` is a split monomorphism. ", "terms": "[\n    \"splitting\",\n    \"short complex\",\n    \"split monomorphism\"\n]"}
{"type": "∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B},\n  IsIntegral A x → Polynomial.Monic (minpoly A x)", "name": "minpoly.monic", "isProp": true, "docString": "A minimal polynomial is monic. ", "terms": "[\n    \"minimal polynomial\",\n    \"monic\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\n  [inst : NormedAddCommGroup β] {p : ENNReal} [inst_1 : Subsingleton ι],\n  1 ≤ p → p ≠ ⊤ → ∀ {f : ι → α → β}, (∀ (i : ι), MeasureTheory.Memℒp (f i) p) → MeasureTheory.UnifIntegrable f p μ", "name": "MeasureTheory.unifIntegrable_subsingleton", "isProp": true, "docString": "A single function is uniformly integrable. ", "terms": "[\n  \"Single function\",\n  \"Uniformly integrable\"\n]"}
{"type": "(R : Type u_1) →\n  {A : Type u_2} →\n    [inst : Semiring R] →\n      [inst_1 : StarMul R] →\n        [inst_2 : TrivialStar R] →\n          [inst_3 : AddCommGroup A] →\n            [inst_4 : Module R A] →\n              [inst_5 : StarAddMonoid A] →\n                [inst_6 : StarModule R A] → [inst_7 : Invertible 2] → A →ₗ[R] ↥(skewAdjoint A)", "name": "skewAdjointPart", "isProp": false, "docString": "The skew-adjoint part of an element of a star module, as a linear map. ", "terms": "[\n  \"skew-adjoint\",\n  \"element\",\n  \"star module\",\n  \"linear map\"\n]"}
{"type": "{m : Type u → Type u} →\n  [inst : Monad m] →\n    {α : Type u} → [inst : BEq α] → [inst : Hashable α] → (α → MLList m α) → α → optParam (Option ℕ) none → MLList m α", "name": "depthFirstRemovingDuplicates", "isProp": false, "docString": "Variant of `depthFirst`,\nusing an internal `HashSet` to record and avoid already visited nodes.\n\nThis version describes the graph using `α → MLList m α`,\nand returns the monadic lazy list of nodes visited in order.\n\nThis is potentially very expensive.\nIf you want to do efficient enumerations from a generation function,\navoiding duplication up to equality or isomorphism,\nuse Brendan McKay's method of \"generation by canonical construction path\".\n", "terms": "[\n  \"Variant\",\n  \"depthFirst\",\n  \"internal\",\n  \"HashSet\",\n  \"record\",\n  \"avoid\",\n  \"visited\",\n  \"nodes\",\n  \"version\",\n  \"describes\",\n  \"graph\",\n  \"α → MLList m α\",\n  \"returns\",\n  \"monadic\",\n  \"lazy\",\n  \"list\",\n  \"nodes\",\n  \"visited\",\n  \"order\",\n  \"potentially\",\n  \"expensive\",\n  \"efficient\",\n  \"enumerations\",\n  \"generation\",\n  \"function\",\n  \"avoiding\",\n  \"duplication\",\n  \"equality\",\n  \"isomorphism\",\n  \"Brendan McKay's method\",\n  \"generation\",\n  \"canonical\",\n  \"construction\",\n  \"path\"\n]"}
{"type": "{H : Type u} →\n  [inst : NormedAddCommGroup H] →\n    [inst_1 : InnerProductSpace ℂ H] → [inst_2 : CompleteSpace H] → VonNeumannAlgebra H → VonNeumannAlgebra H", "name": "VonNeumannAlgebra.commutant", "isProp": false, "docString": "The centralizer of a `VonNeumannAlgebra`, as a `VonNeumannAlgebra`.", "terms": "[\n    \"centralizer\",\n    \"VonNeumannAlgebra\"\n]"}
{"type": "ℝ → ℤ → ℤ → Prop", "name": "Real.ContfracLegendre.Ass", "isProp": false, "docString": "Define the technical condition to be used as assumption in the inductive proof. ", "terms": "[]"}
{"type": "{𝕜 : Type u_1} →\n  [inst : LinearOrderedField 𝕜] →\n    [inst_1 : TopologicalSpace 𝕜] → [inst_2 : OrderTopology 𝕜] → (p q : 𝕜) → p ≠ 0 → q ≠ 0 → AddCircle p ≃+ AddCircle q", "name": "AddCircle.equivAddCircle", "isProp": false, "docString": "The rescaling equivalence between additive circles with different periods. ", "terms": "[\"rescaling\", \"equivalence\", \"additive\", \"circles\", \"different\", \"periods\"]"}
{"type": "{V : Type u} →\n  [inst : Quiver V] →\n    {C : Type u_1} →\n      [inst_1 : CategoryTheory.Category.{u_2, u_1} C] → V ⥤q C → CategoryTheory.Functor (CategoryTheory.Paths V) C", "name": "CategoryTheory.Quiv.lift", "isProp": false, "docString": "Any prefunctor into a category lifts to a functor from the path category. ", "terms": "[\n    \"prefunctor\",\n    \"category\",\n    \"functor\",\n    \"path category\"\n]"}
{"type": "Lean.ParserDescr", "name": "CategoryTheory.Limits.«term⨁_»", "isProp": false, "docString": "`biproduct f` computes the biproduct of a family of elements `f`. (It is defined as an\nabbreviation for `limit (Discrete.functor f)`, so for most facts about `biproduct f`, you will\njust use general facts about limits and colimits.) ", "terms": "[\n    \"biproduct\",\n    \"computes\",\n    \"family of elements\",\n    \"defined\",\n    \"abbreviation\",\n    \"limit\",\n    \"Discrete.functor\",\n    \"facts\",\n    \"limits\",\n    \"colimits\"\n]"}
{"type": "∀ {X : Type u_4} {Y : Type u_5} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (self : X ≃ₜ Y),\n  Continuous self.invFun", "name": "Homeomorph.continuous_invFun", "isProp": true, "docString": "The inverse map of a homeomorphism is a continuous function. ", "terms": "[\n    \"Inverse map\",\n    \"Homeomorphism\",\n    \"Continuous function\"\n]"}
{"type": "{α : Type u_1} →\n  [inst : MetricSpace α] →\n    [inst_1 : MeasurableSpace α] →\n      [inst_2 : OpensMeasurableSpace α] →\n        [inst_3 : SecondCountableTopology α] →\n          (μ : MeasureTheory.Measure α) →\n            [inst_4 : MeasureTheory.IsLocallyFiniteMeasure μ] →\n              (C : NNReal) →\n                (∀ (x : α),\n                    ∃ᶠ (r : ℝ) in nhdsWithin 0 (Set.Ioi 0),\n                      ↑↑μ (Metric.closedBall x (3 * r)) ≤ ↑C * ↑↑μ (Metric.closedBall x r)) →\n                  VitaliFamily μ", "name": "Vitali.vitaliFamily", "isProp": false, "docString": "Assume that around every point there are arbitrarily small scales at which the measure is\ndoubling. Then the set of closed sets `a` with nonempty interior contained in `closedBall x r` and\ncovering a fixed proportion `1/C` of the ball `closedBall x (3 * r)` forms a Vitali family.\nThis is essentially a restatement of the measurable Vitali theorem. ", "terms": "[\n    \"point\", \n    \"arbitrarily small scales\", \n    \"measure\", \n    \"doubling\", \n    \"set\", \n    \"closed sets\", \n    \"nonempty interior\", \n    \"closedBall\", \n    \"covering\", \n    \"fixed proportion\", \n    \"ball\", \n    \"Vitali family\", \n    \"measurable\", \n    \"Vitali theorem\"\n]"}
{"type": "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderTop α] {a : α}, IsTop a → a = ⊤", "name": "IsTop.eq_top", "isProp": true, "docString": "**Alias** of the forward direction of `isTop_iff_eq_top`.", "terms": "[]\n"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {J₁ J₂ : CategoryTheory.GrothendieckTopology C},\n  J₁.sieves = J₂.sieves → J₁ = J₂", "name": "CategoryTheory.GrothendieckTopology.ext", "isProp": true, "docString": "An extensionality lemma in terms of the coercion to a pi-type.\nWe prove this explicitly rather than deriving it so that it is in terms of the coercion rather than\nthe projection `.sieves`.\n", "terms": "[\n    \"extensionality lemma\",\n    \"coercion\",\n    \"pi-type\",\n    \"deriving\",\n    \"projection\",\n    \"sieves\"\n]"}
{"type": "{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {C : Type u} →\n      [inst_1 : CategoryTheory.Category.{v, u} C] →\n        {F : CategoryTheory.Functor J C} →\n          (self : CategoryTheory.Limits.ColimitCocone F) → CategoryTheory.Limits.IsColimit self.cocone", "name": "CategoryTheory.Limits.ColimitCocone.isColimit", "isProp": false, "docString": "The proof that it is the colimit cocone ", "terms": "[\"proof\", \"colimit\", \"cocone\"]"}
{"type": "∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\n  ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ ↔ inner x y = 0", "name": "norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero", "isProp": true, "docString": "Pythagorean theorem, if-and-only-if vector inner product form. ", "terms": "[\n    \"Pythagorean theorem\",\n    \"if-and-only-if\",\n    \"vector\",\n    \"inner product\",\n    \"form\"\n]"}
{"type": "∀ {R : Type u} {A : Type v} {B : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Semiring B]\n  [inst_3 : Algebra R A] [inst_4 : Algebra R B] (self : A ≃ₐ[R] B) (r : R),\n  Equiv.toFun self.toEquiv ((algebraMap R A) r) = (algebraMap R B) r", "name": "AlgEquiv.commutes'", "isProp": true, "docString": "An equivalence of algebras commutes with the action of scalars. ", "terms": "[\n    \"equivalence\",\n    \"algebras\",\n    \"commutes\",\n    \"action\",\n    \"scalars\"\n]"}
{"type": "{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {C : Type u₃} →\n      [inst_1 : CategoryTheory.Category.{v₃, u₃} C] →\n        {F : CategoryTheory.Functor J C} →\n          {t : CategoryTheory.Limits.Cocone F} →\n            {D : Type u₄} →\n              [inst_2 : CategoryTheory.Category.{v₄, u₄} D] →\n                (G : CategoryTheory.Functor C D) →\n                  [inst_3 : CategoryTheory.Faithful G] →\n                    (ht : CategoryTheory.Limits.IsColimit (G.mapCocone t)) →\n                      (desc : (s : CategoryTheory.Limits.Cocone F) → t.pt ⟶ s.pt) →\n                        (∀ (s : CategoryTheory.Limits.Cocone F),\n                            G.map (desc s) = CategoryTheory.Limits.IsColimit.desc ht (G.mapCocone s)) →\n                          CategoryTheory.Limits.IsColimit t", "name": "CategoryTheory.Limits.IsColimit.ofFaithful", "isProp": false, "docString": "If G : C → D is a faithful functor which sends t to a colimit cocone,\nthen it suffices to check that the induced maps for the image of t\ncan be lifted to maps of C. ", "terms": "[\n    \"faithful functor\",\n    \"colimit cocone\",\n    \"induced maps\",\n    \"image\",\n    \"maps\"\n]"}
{"type": "{α : Type u_3} →\n  {β : Type u_4} →\n    (f : α → β → β) →\n      (s : Multiset α) → (Set.Pairwise {x | x ∈ s} fun x y => ∀ (b : β), f x (f y b) = f y (f x b)) → β → β", "name": "Multiset.noncommFoldr", "isProp": false, "docString": "Fold of a `s : Multiset α` with `f : α → β → β`, given a proof that `LeftCommutative f`\non all elements `x ∈ s`. ", "terms": "[\n    \"Fold\",\n    \"Multiset\",\n    \"LeftCommutative\",\n    \"elements\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasColimits C] →\n      {X : TopCat} →\n        (F : TopCat.Presheaf C X) →\n          {U : TopologicalSpace.Opens ↑X} → (x : ↥U) → F.obj (Opposite.op U) ⟶ TopCat.Presheaf.stalk F ↑x", "name": "TopCat.Presheaf.germ", "isProp": false, "docString": "The germ of a section of a presheaf over an open at a point of that open.\n", "terms": "[\n    \"germ\",\n    \"section\",\n    \"presheaf\",\n    \"open\",\n    \"point\"\n]"}
{"type": "∀ {G : Type u_2} [inst : AddGroup G] {ι : Sort u_5} (S : ι → AddSubgroup G) {C : G → Prop} {x : G},\n  x ∈ ⨆ i, S i → (∀ (i : ι), ∀ x ∈ S i, C x) → C 0 → (∀ (x y : G), C x → C y → C (x + y)) → C x", "name": "AddSubgroup.iSup_induction", "isProp": true, "docString": " An induction principle for elements of `⨆ i, S i`.\nIf `C` holds for `0` and all elements of `S i` for all `i`, and is preserved under addition,\nthen it holds for all elements of the supremum of `S`. ", "terms": "[\n\"induction principle\",\n\"elements\",\n\"holds\",\n\"0\",\n\"all\",\n\"preserved\",\n\"addition\",\n\"supremum\"\n]"}
{"type": "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V},\n  Orientation.oangle o x y = ↑(Real.pi / 2) → Real.Angle.cos (Orientation.oangle o (x + y) y) * ‖x + y‖ = ‖y‖", "name": "Orientation.cos_oangle_add_left_mul_norm_of_oangle_eq_pi_div_two", "isProp": true, "docString": "The cosine of an angle in a right-angled triangle multiplied by the hypotenuse equals the\nadjacent side. ", "terms": "[\n    \"cosine\",\n    \"angle\",\n    \"right-angled triangle\",\n    \"multiplied\",\n    \"hypotenuse\",\n    \"equals\",\n    \"adjacent side\"\n]"}
{"type": "{J : Type w} →\n  {C : Type u} →\n    [inst : CategoryTheory.Category.{v, u} C] →\n      {X Y : C} →\n        {f : J → (X ⟶ Y)} →\n          [inst_1 : Nonempty J] →\n            (t : CategoryTheory.Limits.Trident f) →\n              ((s : CategoryTheory.Limits.Trident f) →\n                  { l //\n                    CategoryTheory.CategoryStruct.comp l (CategoryTheory.Limits.Trident.ι t) =\n                        CategoryTheory.Limits.Trident.ι s ∧\n                      ∀\n                        {m :\n                          ((CategoryTheory.Functor.const (CategoryTheory.Limits.WalkingParallelFamily J)).obj s.pt).obj\n                              CategoryTheory.Limits.WalkingParallelFamily.zero ⟶\n                            ((CategoryTheory.Functor.const (CategoryTheory.Limits.WalkingParallelFamily J)).obj\n                                  t.pt).obj\n                              CategoryTheory.Limits.WalkingParallelFamily.zero},\n                        CategoryTheory.CategoryStruct.comp m (CategoryTheory.Limits.Trident.ι t) =\n                            CategoryTheory.Limits.Trident.ι s →\n                          m = l }) →\n                CategoryTheory.Limits.IsLimit t", "name": "CategoryTheory.Limits.Trident.IsLimit.mk'", "isProp": false, "docString": "This is another convenient method to verify that a trident is a limit cone. It\nonly asks for a proof of facts that carry any mathematical content, and allows access to the\nsame `s` for all parts. ", "terms": "[\"convenient method\", \"verify\", \"trident\", \"limit cone\", \"proof\", \"facts\", \"mathematical content\", \"access\", \"parts\"]"}
{"type": "Multiplicative ℂ →* ℂ", "name": "Complex.expMonoidHom", "isProp": false, "docString": "the exponential function as a monoid hom from `Multiplicative ℂ` to `ℂ` ", "terms": "[\n    \"exponential function\",\n    \"monoid\",\n    \"hom\",\n    \"Multiplicative ℂ\",\n    \"ℂ\"\n]"}
{"type": "∀ {m : ℕ} {P : (n : ℕ) → m ≤ n → Prop},\n  P m (_ : m ≤ m) → (∀ (n : ℕ) (hn : m ≤ n), P n hn → P (n + 1) (_ : m ≤ n + 1)) → ∀ (n : ℕ) (hn : m ≤ n), P n hn", "name": "Nat.le_induction", "isProp": true, "docString": "Induction principle starting at a non-zero number. For maps to a `Sort*` see `le_rec_on`.\nTo use in an induction proof, the syntax is `induction n, hn using Nat.le_induction` (or the same\nfor `induction'`). ", "terms": "[\n    \"Induction principle\",\n    \"non-zero number\",\n    \"maps\",\n    \"Sort*\",\n    \"le_rec_on\",\n    \"induction proof\",\n    \"syntax\",\n    \"Nat.le_induction\",\n    \"induction\"\n]"}
{"type": "∀ {α : Type u_1} {n : ℕ} {s t : Finset α}, s ∈ Finset.powersetCard n t ↔ s ⊆ t ∧ Finset.card s = n", "name": "Finset.mem_powersetCard", "isProp": true, "docString": "**Formula for the Number of Combinations** ", "terms": "[\"Formula\", \"Number\", \"Combinations\"]"}
{"type": "∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} {𝓕 : Type u_10} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : RingHomIsometric σ₁₂]\n  [inst_7 : SemilinearMapClass 𝓕 σ₁₂ E F] (f : 𝓕), Continuous ⇑f → ∃ C, 0 < C ∧ ∀ (x : E), ‖f x‖ ≤ C * ‖x‖", "name": "SemilinearMapClass.bound_of_continuous", "isProp": true, "docString": "A continuous linear map between seminormed spaces is bounded when the field is nontrivially\nnormed. The continuity ensures boundedness on a ball of some radius `ε`. The nontriviality of the\nnorm is then used to rescale any element into an element of norm in `[ε/C, ε]`, whose image has a\ncontrolled norm. The norm control for the original element follows by rescaling. ", "terms": "[\n    \"continuous\",\n    \"linear map\",\n    \"seminormed spaces\",\n    \"bounded\",\n    \"field\",\n    \"nontrivially normed\",\n    \"continuity\",\n    \"boundedness\",\n    \"ball\",\n    \"radius\",\n    \"nontriviality\",\n    \"norm\",\n    \"rescale\",\n    \"element\",\n    \"image\",\n    \"controlled norm\",\n    \"rescaling\"\n]"}
{"type": "(X : Type u) →\n  (Y : Type v) →\n    [inst : MetricSpace X] →\n      [inst_1 : Nonempty X] →\n        [inst : CompactSpace X] → [inst : MetricSpace Y] → [inst_2 : Nonempty Y] → [inst : CompactSpace Y] → ℝ", "name": "GromovHausdorff.ghDist", "isProp": false, "docString": "The Gromov-Hausdorff distance between two nonempty compact metric spaces, equal by definition to\nthe distance of the equivalence classes of these spaces in the Gromov-Hausdorff space. ", "terms": "[\n\"Gromov-Hausdorff distance\", \n\"nonempty\", \n\"compact\", \n\"metric spaces\", \n\"definition\", \n\"distance\", \n\"equivalence classes\", \n\"Gromov-Hausdorff space\"\n]"}
{"type": "∀ {α : Type u_1} {M : Type u_5} [inst : CommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ x ∈ s, p (f x)) → p (finprod fun i => finprod fun h => f i)", "name": "finprod_mem_induction", "isProp": true, "docString": "To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on factors. ", "terms": "[\n    \"property\",\n    \"finite product\",\n    \"suffices\",\n    \"prove\",\n    \"multiplicative\",\n    \"holds\",\n    \"factors\"\n]"}
{"type": "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x y : V},\n  inner x y = 0 → x ≠ 0 ∨ y = 0 → Real.tan (InnerProductGeometry.angle x (x + y)) * ‖x‖ = ‖y‖", "name": "InnerProductGeometry.tan_angle_add_mul_norm_of_inner_eq_zero", "isProp": true, "docString": "The tangent of an angle in a right-angled triangle multiplied by the adjacent side equals\nthe opposite side. ", "terms": "[\n    \"tangent\",\n    \"angle\",\n    \"right-angled triangle\",\n    \"multiplied\",\n    \"adjacent side\",\n    \"equals\",\n    \"opposite side\"\n]"}
{"type": "∀ {m : Type u_2} {n : Type u_3} {α : Type v} [inst : Star α] [inst_1 : TrivialStar α] (A : Matrix m n α),\n  Matrix.conjTranspose A = Matrix.transpose A", "name": "Matrix.conjTranspose_eq_transpose_of_trivial", "isProp": true, "docString": "When `star x = x` on the coefficients (such as the real numbers) `conjTranspose` and `transpose`\nare the same operation. ", "terms": "[\n    \"star\",\n    \"coefficients\",\n    \"real numbers\",\n    \"conjTranspose\",\n    \"transpose\",\n    \"operation\"\n]"}
{"type": "{𝕜 : Type u_1} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {EM : Type u_2} →\n      [inst_1 : NormedAddCommGroup EM] →\n        [inst_2 : NormedSpace 𝕜 EM] →\n          {HM : Type u_3} →\n            [inst_3 : TopologicalSpace HM] →\n              ModelWithCorners 𝕜 EM HM →\n                {E : Type u_4} →\n                  [inst_4 : NormedAddCommGroup E] →\n                    [inst_5 : NormedSpace 𝕜 E] →\n                      {H : Type u_5} →\n                        [inst_6 : TopologicalSpace H] →\n                          (I : ModelWithCorners 𝕜 E H) →\n                            (M : Type u) →\n                              [inst_7 : TopologicalSpace M] →\n                                [inst_8 : ChartedSpace HM M] →\n                                  (R : Type u) →\n                                    [inst_9 : TopologicalSpace R] →\n                                      [inst_10 : ChartedSpace H R] →\n                                        [inst_11 : Ring R] →\n                                          [inst : SmoothRing I R] → TopCat.Sheaf RingCat (TopCat.of M)", "name": "smoothSheafRing", "isProp": false, "docString": "The sheaf of smooth functions from `M` to `R`, for `R` a smooth ring, as a sheaf of\nrings. ", "terms": "[\n    \"sheaf\",\n    \"smooth functions\",\n    \"smooth ring\",\n    \"sheaf of rings\"\n]"}
{"type": "{ι : Type u_1} →\n  (V : Type u) →\n    [inst : CategoryTheory.Category.{v, u} V] →\n      [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] →\n        (c : ComplexShape ι) → CategoryTheory.Functor (HomologicalComplex V c) (CategoryTheory.GradedObject ι V)", "name": "HomologicalComplex.forget", "isProp": false, "docString": "The functor forgetting the differential in a complex, obtaining a graded object. ", "terms": "[\n  \"functor\",\n  \"differential\",\n  \"complex\",\n  \"graded\",\n  \"object\"\n]"}
{"type": "MulChar.IsQuadratic ZMod.χ₈'", "name": "ZMod.isQuadratic_χ₈'", "isProp": true, "docString": "`χ₈'` takes values in `{0, 1, -1}` ", "terms": "[\"takes values in\"]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →L[𝕜] E}, LinearMap.IsSymmetric ↑T → ∀ (x : E), ↑(ContinuousLinearMap.reApplyInnerSelf T x) = inner (T x) x", "name": "LinearMap.IsSymmetric.coe_reApplyInnerSelf_apply", "isProp": true, "docString": "For a symmetric operator `T`, the function `fun x ↦ ⟪T x, x⟫` is real-valued. ", "terms": "[\n    \"Symmetric Operator\",\n    \"Function\",\n    \"Real-Valued\"\n]"}
{"type": "∀ {α : Type u_2} {ι : Type u_6} {m0 : MeasurableSpace α} {μ ν : MeasureTheory.Measure α} [inst : Countable ι]\n  {s : ι → Set α},\n  ⋃ i, s i = Set.univ →\n    (μ = ν ↔ ∀ (i : ι), MeasureTheory.Measure.restrict μ (s i) = MeasureTheory.Measure.restrict ν (s i))", "name": "MeasureTheory.Measure.ext_iff_of_iUnion_eq_univ", "isProp": true, "docString": "Two measures are equal if they have equal restrictions on a spanning collection of sets\n(formulated using `Union`). ", "terms": "[\n    \"measures\",\n    \"equal\",\n    \"restrictions\",\n    \"spanning collection\",\n    \"sets\",\n    \"Union\"\n]"}
{"type": "(M : Type u_2) → [inst : AddCommMonoid M] → (S : Type u_3) → [inst : SMul S M] → Prop", "name": "Module.IsTorsion'", "isProp": false, "docString": "An `S`-torsion module is a module where every element is `a`-torsion for some `a` in `S`. ", "terms": "[\n  \"S-torsion module\",\n  \"module\",\n  \"element\",\n  \"a-torsion\",\n  \"in\"\n]"}
{"type": "∀ {f : ℝ → ℝ}, Continuous f → StrictAnti (deriv f) → StrictConcaveOn ℝ Set.univ f", "name": "StrictAnti.strictConcaveOn_univ_of_deriv", "isProp": true, "docString": "If a function `f` is continuous and `f'` is strictly antitone on `ℝ` then `f` is strictly\nconcave. Note that we don't require differentiability, since it is guaranteed at all but at most\none point by the strict antitonicity of `f'`. ", "terms": "[\n  \"function\",\n  \"continuous\",\n  \"strictly antitone\",\n  \"ℝ\",\n  \"strictly concave\",\n  \"differentiability\",\n  \"point\",\n  \"strict antitonicity\"\n]"}
{"type": "{n : ℕ} → Fin (n + 2) → Fin (n + 1)", "name": "Fin.castPred", "isProp": false, "docString": "`castPred` embeds `i : Fin (n + 2)` into `Fin (n + 1)`\nby lowering just `last (n + 1)` to `last n`. ", "terms": "[\n    \"castPred\",\n    \"Fin\",\n    \"+\",\n    \"embeds\",\n    \"into\",\n    \"lowering\",\n    \"last\"\n]"}
{"type": "{α : Type u_2} →\n  [inst : DistribLattice α] →\n    [inst_1 : BoundedOrder α] → (hnot : α → α) → (∀ (a b c : α), a ⊓ hnot b ≤ c ↔ a ≤ b ⊔ c) → CoheytingAlgebra α", "name": "CoheytingAlgebra.ofHNot", "isProp": false, "docString": "Construct a co-Heyting algebra from the difference and Heyting negation alone. ", "terms": "[\n    \"Construct\",\n    \"co-Heyting algebra\",\n    \"difference\",\n    \"Heyting negation\"\n]"}
{"type": "{C : Type u₁} →\n  {D : Type u₂} →\n    [inst : CategoryTheory.Category.{v₁, u₁} C] →\n      [inst_1 : CategoryTheory.Category.{v₁, u₂} D] →\n        {G : CategoryTheory.Functor D C} →\n          [inst_2 : CategoryTheory.IsRightAdjoint G] →\n            [inst_3 : CategoryTheory.ReflectsIsomorphisms G] →\n              [inst_4 : CategoryTheory.Monad.HasCoequalizerOfIsSplitPair G] →\n                [inst_5 : CategoryTheory.Monad.PreservesColimitOfIsSplitPair G] → CategoryTheory.MonadicRightAdjoint G", "name": "CategoryTheory.Monad.monadicOfHasPreservesGSplitCoequalizersOfReflectsIsomorphisms", "isProp": false, "docString": "An alternate version of Beck's monadicity theorem. If `G` reflects isomorphisms, preserves\ncoequalizers of `G`-split pairs and `C` has coequalizers of `G`-split pairs, then it is monadic.\n", "terms": "[\n  \"alternate version\",\n  \"Beck's monadicity theorem\",\n  \"reflects\",\n  \"isomorphisms\",\n  \"preserves\",\n  \"coequalizers\",\n  \"-split pairs\",\n  \"has\",\n  \"monadic\"\n]"}
{"type": "{α : Type u} → FreeAddSemigroup α → α", "name": "FreeAddSemigroup.head", "isProp": false, "docString": "The head of the element ", "terms": "[\"head\", \"element\"]"}
{"type": "{α : Type u_1} → {n : ℕ} → Coe (Vector α n) (Sym α n)", "name": "Sym.instCoeVectorSym", "isProp": false, "docString": "This is the quotient map that takes a list of n elements as an n-tuple and produces an nth\nsymmetric power.\n", "terms": "[\n    \"quotient map\",\n    \"list\",\n    \"elements\",\n    \"n-tuple\",\n    \"symmetric power\"\n]"}
{"type": "Lean.PrettyPrinter.Delaborator.Delab", "name": "BigOperators.delabFinsetSum", "isProp": false, "docString": "Delaborator for `Finset.prod`. The `pp.piBinderTypes` option controls whether\nto show the domain type when the sum is over `Finset.univ`. ", "terms": "[\n  \"Delaborator\",\n  \"Finset.prod\",\n  \"pp.piBinderTypes\",\n  \"domain type\",\n  \"Finset.univ\"\n]"}
{"type": "Type u → Type u", "name": "CategoryTheory.ShrinkHoms", "isProp": false, "docString": "We define a type alias `ShrinkHoms C` for `C`. When we have `LocallySmall.{w} C`,\nwe'll put a `Category.{w}` instance on `ShrinkHoms C`.\n", "terms": "[\n    \"type alias\",\n    \"LocallySmall\",\n    \"Category\",\n    \"instance\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.SmallCategory C] →\n    CategoryTheory.Functor.comp CategoryTheory.yoneda\n        ((CategoryTheory.whiskeringLeft Cᵒᵖ (CategoryTheory.Functor Cᵒᵖ (Type u₁))ᵒᵖ (Type u₁)).obj\n          CategoryTheory.yoneda.op) ≅\n      CategoryTheory.Functor.id (CategoryTheory.Functor Cᵒᵖ (Type u₁))", "name": "CategoryTheory.curriedYonedaLemma'", "isProp": false, "docString": "The curried version of yoneda lemma when `C` is small. ", "terms": "[\n  \"curried version\",\n  \"yoneda lemma\",\n  \"small\"\n]"}
{"type": "{G : Type u} →\n  [inst : CategoryTheory.Groupoid G] →\n    [inst_1 : IsFreeGroupoid G] →\n      (T : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G))) →\n        [inst_2 : Quiver.Arborescence (WideSubquiver.toType (Quiver.Symmetrify (IsFreeGroupoid.Generators G)) T)] →\n          {a b : G} → (a ⟶ b) → CategoryTheory.End (IsFreeGroupoid.SpanningTree.root' T)", "name": "IsFreeGroupoid.SpanningTree.loopOfHom", "isProp": false, "docString": "Any hom in `G` can be made into a loop, by conjugating with `treeHom`s. ", "terms": "[\n    \"hom\",\n    \"G\",\n    \"loop\",\n    \"conjugating\",\n    \"treeHom\"\n]"}
{"type": "{B : Type u} →\n  [inst : CategoryTheory.Bicategory B] →\n    (a : B) →\n      CategoryTheory.Bicategory.Adjunction (CategoryTheory.CategoryStruct.id a) (CategoryTheory.CategoryStruct.id a)", "name": "CategoryTheory.Bicategory.Adjunction.id", "isProp": false, "docString": "Adjunction between identities. ", "terms": "[\n    \"Adjunction\",\n    \"identities\"\n]"}
{"type": "{α : Type u_1} →\n  [inst : OrderedAddCommGroup α] →\n    {β : Type u_3} →\n      [inst_1 : Zero β] →\n        [inst_2 : Add β] →\n          [inst_3 : Neg β] →\n            [inst_4 : Sub β] →\n              [inst_5 : SMul ℕ β] →\n                [inst_6 : SMul ℤ β] →\n                  (f : β → α) →\n                    Function.Injective f →\n                      f 0 = 0 →\n                        (∀ (x y : β), f (x + y) = f x + f y) →\n                          (∀ (x : β), f (-x) = -f x) →\n                            (∀ (x y : β), f (x - y) = f x - f y) →\n                              (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                (∀ (x : β) (n : ℤ), f (n • x) = n • f x) → OrderedAddCommGroup β", "name": "Function.Injective.orderedAddCommGroup", "isProp": false, "docString": "Pullback an `OrderedAddCommGroup` under an injective map.", "terms": "[\n    \"Pullback\",\n    \"OrderedAddCommGroup\",\n    \"Injective map\"\n]"}
{"type": "{𝕜 : Type u_1} →\n  {E : Type u_2} →\n    [inst : OrderedRing 𝕜] →\n      [inst_1 : AddCommGroup E] → [inst_2 : Module 𝕜 E] → Membership (Finset E) (Geometry.SimplicialComplex 𝕜 E)", "name": "Geometry.SimplicialComplex.instMembershipFinsetSimplicialComplex", "isProp": false, "docString": "A `Finset` belongs to a `SimplicialComplex` if it's a face of it. ", "terms": "[\n    \"Finset\",\n    \"SimplicialComplex\",\n    \"face\"\n]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {Z X Y P : C} {f : Z ⟶ X} {g : Z ⟶ Y} {inl : X ⟶ P}\n  {inr : Y ⟶ P} (self : CategoryTheory.IsPushout f g inl inr),\n  Nonempty\n    (CategoryTheory.Limits.IsColimit\n      (CategoryTheory.Limits.PushoutCocone.mk inl inr\n        (_ : CategoryTheory.CategoryStruct.comp f inl = CategoryTheory.CategoryStruct.comp g inr)))", "name": "CategoryTheory.IsPushout.isColimit'", "isProp": true, "docString": "the pushout cocone is a colimit ", "terms": "[\n    \"pushout cocone\",\n    \"colimit\"\n]"}
{"type": "∀ {M : Type u} [self : LeftCancelMonoid M] (a : M), 1 * a = a", "name": "LeftCancelMonoid.one_mul", "isProp": true, "docString": "One is a left neutral element for multiplication ", "terms": "[\n  \"One\",\n  \"Left neutral element\",\n  \"Multiplication\"\n]"}
{"type": "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {n : ℕ∞}\n  {E' : Type u_3} [inst_5 : NormedAddCommGroup E'] [inst_6 : NormedSpace 𝕜 E'] {F' : Type u_4}\n  [inst_7 : NormedAddCommGroup F'] [inst_8 : NormedSpace 𝕜 F'] {f : E → F} {g : E' → F'},\n  ContDiff 𝕜 n f → ContDiff 𝕜 n g → ContDiff 𝕜 n (Prod.map f g)", "name": "ContDiff.prod_map", "isProp": true, "docString": "The product map of two `C^n` functions is `C^n`. ", "terms": "[\n  \"Product map\",\n  \"C^n functions\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {K : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection K] {v : E}, v ∈ Kᗮ → (orthogonalProjection K) v = 0", "name": "orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero", "isProp": true, "docString": "The orthogonal projection onto `K` of an element of `Kᗮ` is zero. ", "terms": "[\n  \"orthogonal projection\",\n  \"element\",\n  \"zero\"\n]"}
{"type": "∀ {V : Type u_1} {W : Type u_2} [inst : SeminormedAddCommGroup V] [inst_1 : SeminormedAddCommGroup W]\n  (self : NormedAddGroupHom V W) (v₁ v₂ : V),\n  NormedAddGroupHom.toFun self (v₁ + v₂) = NormedAddGroupHom.toFun self v₁ + NormedAddGroupHom.toFun self v₂", "name": "NormedAddGroupHom.map_add'", "isProp": true, "docString": "A `NormedAddGroupHom` is additive. ", "terms": "[\"NormedAddGroupHom\", \"additive\"]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    {X Y : AlgebraicGeometry.PresheafedSpace C} →\n      {f : X ⟶ Y} →\n        (H : AlgebraicGeometry.PresheafedSpace.IsOpenImmersion f) →\n          X ≅ AlgebraicGeometry.PresheafedSpace.restrict Y (_ : OpenEmbedding ⇑f.base)", "name": "AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.isoRestrict", "isProp": false, "docString": "An open immersion `f : X ⟶ Y` induces an isomorphism `X ≅ Y|_{f(X)}`. ", "terms": "[\n    \"open immersion\",\n    \"induces\",\n    \"isomorphism\"\n]"}
{"type": "∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : ι → k) (p : ι → P) (b : P) {pred : ι → Prop}\n  [inst_3 : DecidablePred pred],\n  (∀ i ∈ s, w i ≠ 0 → pred i) →\n    (Finset.weightedVSubOfPoint (Finset.filter pred s) p b) w = (Finset.weightedVSubOfPoint s p b) w", "name": "Finset.weightedVSubOfPoint_filter_of_ne", "isProp": true, "docString": "A weighted sum over `s.filter pred` equals one over `s` if all the weights at indices in `s`\nnot satisfying `pred` are zero. ", "terms": "[\"weighted sum\", \"filter\", \"equals\", \"one\", \"weights\", \"indices\", \"zero\"]"}
{"type": "∀ {α : Type u} [self : OrderedSemiring α] (a b c : α), a ≤ b → 0 ≤ c → a * c ≤ b * c", "name": "OrderedSemiring.mul_le_mul_of_nonneg_right", "isProp": true, "docString": "In an ordered semiring, we can multiply an inequality `a ≤ b` on the right\nby a non-negative element `0 ≤ c` to obtain `a * c ≤ b * c`. ", "terms": "[\n    \"ordered semiring\",\n    \"multiply\",\n    \"inequality\",\n    \"non-negative element\"\n]"}
{"type": "{α : Type u_1} → {β : Type u_2} → α ≃ β → FreeGroup α ≃* FreeGroup β", "name": "FreeGroup.freeGroupCongr", "isProp": false, "docString": "Equivalent types give rise to multiplicatively equivalent free groups.\n\nThe converse can be found in `GroupTheory.FreeAbelianGroupFinsupp`,\nas `Equiv.of_freeGroupEquiv`\n ", "terms": "[\n  \"Equivalent types\",\n  \"multiplicatively equivalent\",\n  \"free groups\",\n  \"converse\",\n  \"GroupTheory\",\n  \"FreeAbelianGroupFinsupp\",\n  \"Equiv.of_freeGroupEquiv\"\n]"}
{"type": "∀ {α : Type u} [inst : BEq α] [self : LawfulBEq α] {a b : α}, (a == b) = true → a = b", "name": "LawfulBEq.eq_of_beq", "isProp": true, "docString": "If `a == b` evaluates to `true`, then `a` and `b` are equal in the logic. ", "terms": "[\"evaluates\", \"true\", \"equal\", \"logic\"]"}
{"type": "Lean.TrailingParserDescr", "name": "«term_<|_»", "isProp": false, "docString": "Haskell-like pipe operator `<|`. `f <| x` means the same as the same as `f x`,\nexcept that it parses `x` with lower precedence, which means that `f <| g <| x`\nis interpreted as `f (g x)` rather than `(f g) x`.\n", "terms": "[]\n"}
{"type": "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsPrincipalIdealRing R] {M : Type v}\n  [inst_3 : AddCommGroup M] [inst_4 : Module R M] [inst_5 : Module.Finite R M],\n  Module.IsTorsion R M →\n    ∃ ι x x p,\n      ∃ (_ : ∀ (i : ι), Irreducible (p i)), ∃ e, DirectSum.IsInternal fun i => Submodule.torsionBy R M (p i ^ e i)", "name": "Submodule.exists_isInternal_prime_power_torsion_of_pid", "isProp": true, "docString": "A finitely generated torsion module over a PID is an internal direct sum of its\n`p i ^ e i`-torsion submodules for some primes `p i` and numbers `e i`.", "terms": "[\n  \"finitely generated\",\n  \"torsion module\",\n  \"PID\",\n  \"internal direct sum\",\n  \"submodules\",\n  \"primes\",\n  \"numbers\"\n]"}
{"type": "{X : Type u_1} →\n  {Y : Type u_2} → {Z : Type u_3} → [inst : TopologicalSpace X] → (Y → Z) → LocallyConstant X Y → LocallyConstant X Z", "name": "LocallyConstant.map", "isProp": false, "docString": "Push forward of locally constant maps under any map, by post-composition. ", "terms": "[\n    \"Push forward\",\n    \"locally constant maps\",\n    \"map\",\n    \"post-composition\"\n]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {f g : CategoryTheory.Arrow C}\n  [inst_1 : CategoryTheory.Limits.HasImage f.hom] [inst_2 : CategoryTheory.Limits.HasImage g.hom] {sq : f ⟶ g}\n  (self : CategoryTheory.Limits.ImageMap sq),\n  CategoryTheory.CategoryStruct.comp self.map (CategoryTheory.Limits.image.ι g.hom) =\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι f.hom) sq.right", "name": "CategoryTheory.Limits.ImageMap.map_ι", "isProp": true, "docString": "An image map is a morphism `image f → image g` fitting into a commutative square and satisfying\nthe obvious commutativity conditions. ", "terms": "[\n  \"image map\",\n  \"morphism\",\n  \"image\",\n  \"commutative square\",\n  \"commutativity conditions\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} {f : α →. β ⊕ α} {b : β} {a : α}, Sum.inl b ∈ f a → b ∈ PFun.fix f a", "name": "PFun.fix_stop", "isProp": true, "docString": "If advancing one step from `a` leads to `b : β`, then `f.fix a = b` ", "terms": "[\n    \"advancing\",\n    \"one step\",\n    \"leads to\",\n    \"fix\"\n]"}
{"type": "(l : Type u_4) → (R : Type u₂) → [inst : DecidableEq l] → [inst : CommRing R] → Matrix (Unit ⊕ l ⊕ l) (Unit ⊕ l ⊕ l) R", "name": "LieAlgebra.Orthogonal.PB", "isProp": false, "docString": "A matrix transforming the bilinear form defined by the matrix `JB` into an\nalmost-split-signature diagonal matrix.\n\nIt looks like this as a `(2l+1) x (2l+1)` matrix of blocks:\n\n   [ 1 0  0 ]\n   [ 0 1 -1 ]\n   [ 0 1  1 ]\n\nwhere sizes of the blocks are:\n\n   [`1 x 1` `1 x l` `1 x l`]\n   [`l x 1` `l x l` `l x l`]\n   [`l x 1` `l x l` `l x l`]\n", "terms": "[\n    \"Matrix\",\n    \"Transforming\",\n    \"Bilinear form\",\n    \"Almost-split-signature diagonal matrix\",\n    \"Blocks\"\n]"}
{"type": "Surreal →+o SetTheory.Game", "name": "Surreal.toGame", "isProp": false, "docString": "Casts a `Surreal` number into a `Game`. ", "terms": "[\"Surreal number\", \"Game\", \"cast\"]"}
{"type": "∀ {b o : Ordinal.{u}}, 1 < b → ∀ {x : Ordinal.{u} × Ordinal.{u}}, x ∈ Ordinal.CNF b o → x.2 < b", "name": "Ordinal.CNF_snd_lt", "isProp": true, "docString": "Every coefficient in the Cantor normal form `CNF b o` is less than `b`. ", "terms": "[\n  \"Coefficient\",\n  \"Cantor Normal Form\",\n  \"Less Than\"\n]"}
{"type": "Lean.PrettyPrinter.Unexpander", "name": "Matrix.vecConsUnexpander", "isProp": false, "docString": "Unexpander for the `![x, y, ...]` notation. ", "terms": "[]"}
{"type": "{α : Type u} → {m : Type u → Type v} → [inst : Functor m] → (α → Prop) → m α → Prop", "name": "SatisfiesM", "isProp": false, "docString": "`SatisfiesM p (x : m α)` lifts propositions over a monad. It asserts that `x` may as well\nhave the type `x : m {a // p a}`, because there exists some `m {a // p a}` whose image is `x`.\nSo `p` is the postcondition of the monadic value.\n", "terms": "[\n  \"SatisfiesM\",\n  \"propositions\",\n  \"monad\",\n  \"type\",\n  \"exists\",\n  \"image\",\n  \"postcondition\",\n  \"monadic value\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α]\n  [inst_3 : LinearOrder β] (f : β → α) [inst : SecondCountableTopology α],\n  Set.Countable {x | ∃ z < f x, ∀ (y : β), x < y → f y ≤ z}", "name": "countable_image_gt_image_Ioi", "isProp": true, "docString": "For a function taking values in a second countable space, the set of points `x` for\nwhich the image under `f` of `(x, ∞)` is separated below from `f x` is countable. ", "terms": "[\n    \"function\",\n    \"values\",\n    \"second countable space\",\n    \"set\",\n    \"points\",\n    \"image\",\n    \"separated below\",\n    \"countable\"\n]"}
{"type": "{α : Type u_2} → [inst : Monoid α] → Monoid (Set α)", "name": "Set.monoid", "isProp": false, "docString": "`Set α` is a `Monoid` under pointwise operations if `α` is. ", "terms": "[\n    \"Set\",\n    \"Monoid\",\n    \"pointwise operations\"\n]"}
{"type": "↑{⊥, ⊤}ᶜ ≃ᵐ ℝ", "name": "MeasurableEquiv.erealEquivReal", "isProp": false, "docString": "The set of finite `EReal` numbers is `MeasurableEquiv` to `ℝ`. ", "terms": "[\n    \"set\",\n    \"finite\",\n    \"EReal\",\n    \"numbers\",\n    \"MeasurableEquiv\",\n    \"ℝ\"\n]"}
{"type": "{X : AlgebraicGeometry.Scheme} → TopologicalSpace.Opens ↑↑X.toPresheafedSpace → Prop", "name": "AlgebraicGeometry.IsAffineOpen", "isProp": false, "docString": "An open subset of a scheme is affine if the open subscheme is affine. ", "terms": "[\n    \"open subset\",\n    \"scheme\",\n    \"affine\",\n    \"open subscheme\"\n]"}
{"type": "Type u → Type u", "name": "PMF", "isProp": false, "docString": "A probability mass function, or discrete probability measures is a function `α → ℝ≥0∞` such\nthat the values have (infinite) sum `1`. ", "terms": "[\n    \"Probability Mass Function\",\n    \"Discrete Probability Measures\",\n    \"Function\",\n    \"Values\",\n    \"Infinite\",\n    \"Sum\"\n]"}
{"type": "∀ {a b : ℕ}, ¬a ≤ b → b < a", "name": "Nat.lt_of_not_le", "isProp": true, "docString": "**Alias** of the forward direction of `Nat.not_le`.", "terms": "[\"Alias\", \"forward direction\", \"Nat.not_le\"]"}
{"type": "∀ {G : Type u_1} [inst : Group G] {s : Set G} {N : Subgroup G} [inst_1 : Subgroup.Normal N],\n  s ⊆ ↑N → Subgroup.normalClosure s ≤ N", "name": "Subgroup.normalClosure_le_normal", "isProp": true, "docString": "The normal closure of `s` is the smallest normal subgroup containing `s`. ", "terms": "[\n    \"normal closure\",\n    \"smallest\",\n    \"normal subgroup\",\n    \"containing\"\n]"}
{"type": "∀ (z₁ z₂ : NNReal) {p : ℝ}, 1 ≤ p → (z₁ + z₂) ^ p ≤ 2 ^ (p - 1) * (z₁ ^ p + z₂ ^ p)", "name": "NNReal.rpow_add_le_mul_rpow_add_rpow", "isProp": true, "docString": "Unweighted mean inequality, version for two elements of `ℝ≥0` and real exponents. ", "terms": "[\n    \"Unweighted mean inequality\",\n    \"elements\",\n    \"ℝ≥0\",\n    \"real exponents\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_4} [inst_3 : Fintype ι] {v : ι → E},\n  Orthonormal 𝕜 v → ∀ (l : ι → 𝕜) (i : ι), inner (v i) (Finset.sum Finset.univ fun i => l i • v i) = l i", "name": "Orthonormal.inner_right_fintype", "isProp": true, "docString": "The inner product of a linear combination of a set of orthonormal vectors with one of those\nvectors picks out the coefficient of that vector. ", "terms": "[\n    \"inner product\",\n    \"linear combination\",\n    \"set\",\n    \"orthonormal vectors\",\n    \"vectors\",\n    \"coefficient\"\n]"}
{"type": "{R : Type u_1} → [inst : CommSemiring R] → R → (S : Type u_4) → [inst_1 : CommSemiring S] → [inst : Algebra R S] → Prop", "name": "IsLocalization.Away", "isProp": false, "docString": "Given `x : R`, the typeclass `IsLocalization.Away x S` states that `S` is\nisomorphic to the localization of `R` at the submonoid generated by `x`. ", "terms": "[\"R\", \"typeclass\", \"IsLocalization.Away\", \"isomorphic\", \"localization\", \"submonoid\", \"generated\"]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} {F : Type u_5} [inst : NormedAddCommGroup F] [inst_1 : CompleteSpace F] {u : α → ℝ}\n  [inst_2 : TopologicalSpace β] {f : α → β → F},\n  (∀ (i : α), Continuous (f i)) →\n    Summable u → (∀ (n : α) (x : β), ‖f n x‖ ≤ u n) → Continuous fun x => ∑' (n : α), f n x", "name": "continuous_tsum", "isProp": true, "docString": "An infinite sum of functions with summable sup norm is continuous if each individual\nfunction is. ", "terms": "[\n    \"infinite sum\",\n    \"functions\",\n    \"summable\",\n    \"sup norm\",\n    \"continuous\"\n]"}
{"type": "∀ {E : Type u_9} [self : SeminormedAddCommGroup E] (x y : E), dist x y = ‖x - y‖", "name": "SeminormedAddCommGroup.dist_eq", "isProp": true, "docString": "The distance function is induced by the norm. ", "terms": "[\n    \"distance function\",\n    \"induced\",\n    \"norm\"\n]"}
{"type": "{G : Type w} → [inst : TopologicalSpace G] → [inst_1 : AddGroup G] → [inst_2 : ContinuousAdd G] → G → G ≃ₜ G", "name": "Homeomorph.addRight", "isProp": false, "docString": "Addition from the right in a topological additive group as a homeomorphism.", "terms": "[\n    \"Addition\",\n    \"Right\",\n    \"Topological\",\n    \"Additive Group\",\n    \"Homeomorphism\"\n]"}
{"type": "∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : ContinuousAdd G] (H : AddSubgroup G),\n  0 ∈ interior ↑H → IsOpen ↑H", "name": "AddSubgroup.isOpen_of_zero_mem_interior", "isProp": true, "docString": "If a subgroup of an additive topological group has `0` in its interior, then it is\nopen.", "terms": "[\n    \"subgroup\",\n    \"additive\",\n    \"topological group\",\n    \"interior\",\n    \"open\"\n]"}
{"type": "∀ {g g' : ℝ → ℝ} {a l : ℝ},\n  ContinuousWithinAt g (Set.Ici a) a →\n    (∀ x ∈ Set.Ioi a, HasDerivAt g (g' x) x) →\n      (∀ x ∈ Set.Ioi a, g' x ≤ 0) → Filter.Tendsto g Filter.atTop (nhds l) → MeasureTheory.IntegrableOn g' (Set.Ioi a)", "name": "MeasureTheory.integrableOn_Ioi_deriv_of_nonpos", "isProp": true, "docString": "When a function has a limit at infinity, and its derivative is nonpositive, then the derivative\nis automatically integrable on `(a, +∞)`. Version assuming differentiability\non `(a, +∞)` and continuity at `a⁺`. ", "terms": "[\n    \"function\",\n    \"limit\",\n    \"infinity\",\n    \"derivative\",\n    \"nonpositive\",\n    \"integrable\",\n    \"differentiability\",\n    \"continuity\"\n]"}
{"type": "PartialHomeomorph ℂ ℂ", "name": "Complex.expPartialHomeomorph", "isProp": false, "docString": "`Complex.exp` as a `PartialHomeomorph` with `source = {z | -π < im z < π}` and\n`target = {z | 0 < re z} ∪ {z | im z ≠ 0}`. This definition is used to prove that `Complex.log`\nis complex differentiable at all points but the negative real semi-axis. ", "terms": "[\n    \"Complex.exp\",\n    \"PartialHomeomorph\",\n    \"source\",\n    \"im\",\n    \"target\",\n    \"re\",\n    \"union\",\n    \"Complex.log\",\n    \"complex differentiable\",\n    \"negative real semi-axis\"\n]"}
{"type": "{X Y Z : CategoryTheory.Limits.WalkingParallelPair} →\n  CategoryTheory.Limits.WalkingParallelPairHom X Y →\n    CategoryTheory.Limits.WalkingParallelPairHom Y Z → CategoryTheory.Limits.WalkingParallelPairHom X Z", "name": "CategoryTheory.Limits.WalkingParallelPairHom.comp", "isProp": false, "docString": "Composition of morphisms in the indexing diagram for (co)equalizers. ", "terms": "[\n    \"Composition\",\n    \"Morphisms\",\n    \"Indexing Diagram\",\n    \"(Co)equalizers\"\n]"}
{"type": "∀ {M : Type u_4} [inst : AddCommMonoid M] (S : AddSubmonoid M) {ι : Type u_5} {t : Finset ι} {f : ι → M},\n  (∀ c ∈ t, f c ∈ S) → (Finset.sum t fun c => f c) ∈ S", "name": "AddSubmonoid.sum_mem", "isProp": true, "docString": "Sum of elements in an `AddSubmonoid` of an `AddCommMonoid` indexed by a `Finset`\nis in the `AddSubmonoid`.", "terms": "[\n    \"Sum\",\n    \"elements\",\n    \"AddSubmonoid\",\n    \"AddCommMonoid\",\n    \"indexed\",\n    \"Finset\"\n]"}
{"type": "{ι : Type u_1} →\n  {V : Type u} →\n    [inst : CategoryTheory.Category.{v, u} V] →\n      [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] →\n        {c : ComplexShape ι} →\n          [inst_2 : CategoryTheory.Limits.HasKernels V] →\n            [inst_3 : CategoryTheory.Limits.HasImages V] →\n              [inst_4 : CategoryTheory.Limits.HasCokernels V] →\n                (C : HomologicalComplex V c) →\n                  {i j k : ι} →\n                    ComplexShape.Rel c i j →\n                      ComplexShape.Rel c j k →\n                        (HomologicalComplex.homology' C j ≅\n                          homology' (HomologicalComplex.d C i j) (HomologicalComplex.d C j k)\n                            (_ :\n                              CategoryTheory.CategoryStruct.comp (HomologicalComplex.d C i j)\n                                  (HomologicalComplex.d C j k) =\n                                0))", "name": "HomologicalComplex.homology'Iso", "isProp": false, "docString": "The `j`th homology of a homological complex (as kernel of 'the differential from `Cⱼ`' modulo\nthe image of 'the differential to `Cⱼ`') is isomorphic to the kernel of `d : Cⱼ → Cₖ` modulo\nthe image of `d : Cᵢ → Cⱼ` when `Rel i j` and `Rel j k`. ", "terms": "[\n    \"homology\",\n    \"homological complex\",\n    \"kernel\",\n    \"differential\",\n    \"modulo\",\n    \"image\",\n    \"isomorphic\"\n    \"Rel\"\n]"}
{"type": "∀ {ι : Type u_1} {R : Type u_8} [inst : CanonicallyOrderedCommSemiring R] {f : ι → R} {s : Finset ι}\n  [inst_1 : Nontrivial R], (0 < Finset.prod s fun i => f i) ↔ ∀ i ∈ s, 0 < f i", "name": "CanonicallyOrderedCommSemiring.prod_pos", "isProp": true, "docString": "Note that the name is to match `CanonicallyOrderedCommSemiring.mul_pos`. ", "terms": "[\"CanonicallyOrderedCommSemiring.mul_pos\"]"}
{"type": "{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : Semiring R] →\n      [inst_1 : AddCommMonoid M] →\n        [inst_2 : Module R M] →\n          (R₂ : Type u_5) →\n            [inst_3 : CommSemiring R₂] →\n              [inst_4 : Algebra R₂ R] →\n                [inst_5 : Module R₂ M] → [inst_6 : IsScalarTower R₂ R M] → BilinForm R M →ₗ[R₂] M →ₗ[R₂] M →ₗ[R] R", "name": "BilinForm.toLinHom", "isProp": false, "docString": "The linear map obtained from a `BilinForm` by fixing the left co-ordinate and evaluating in\nthe right.\nThis is the most general version of the construction; it is `R₂`-linear for some distinguished\ncommutative subsemiring `R₂` of the scalar ring.  Over a semiring with no particular distinguished\nsuch subsemiring, use `toLin'`, which is `ℕ`-linear.  Over a commutative semiring, use `toLin`,\nwhich is linear. ", "terms": "[\n  \"linear map\",\n  \"BilinForm\",\n  \"co-ordinate\",\n  \"evaluating\",\n  \"general version\",\n  \"construction\",\n  \"R₂-linear\",\n  \"distinguished\",\n  \"commutative\",\n  \"subsemiring\",\n  \"scalar ring\",\n  \"semiring\",\n  \"toLin'\",\n  \"ℕ-linear\",\n  \"commutative semiring\",\n  \"toLin\",\n  \"linear\"\n]"}
{"type": "{M : Type u_1} → [inst : SeminormedAddCommGroup M] → (S : AddSubgroup M) → NormedAddGroupHom M (M ⧸ S)", "name": "AddSubgroup.normedMk", "isProp": false, "docString": "The morphism from a seminormed group to the quotient by a subgroup. ", "terms": "[\n  \"morphism\",\n  \"seminormed group\",\n  \"quotient\",\n  \"subgroup\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {f g : CategoryTheory.Arrow C} →\n      {F : CategoryTheory.Limits.MonoFactorisation f.hom} →\n        CategoryTheory.Limits.IsImage F →\n          (sq : f ⟶ g) →\n            [inst_1 : CategoryTheory.IsIso sq] →\n              CategoryTheory.Limits.IsImage (CategoryTheory.Limits.MonoFactorisation.ofArrowIso F sq)", "name": "CategoryTheory.Limits.IsImage.ofArrowIso", "isProp": false, "docString": "If `f` and `g` are isomorphic arrows, then a mono factorisation of `f` that is an image\ngives a mono factorisation of `g` that is an image ", "terms": "[\n    \"isomorphic\",\n    \"arrows\",\n    \"mono factorisation\",\n    \"image\"\n]"}
{"type": "{R : Type u_1} →\n  {M : Type u_2} →\n    {N : Type u_3} →\n      {ι : Type u_4} →\n        [inst : Semiring R] →\n          [inst_1 : AddCommMonoid M] →\n            [inst_2 : Module R M] →\n              [inst_3 : TopologicalSpace M] →\n                [inst_4 : AddCommMonoid N] →\n                  [inst_5 : Module R N] →\n                    [inst_6 : TopologicalSpace N] → M[Λ^ι]→L[R]N → ContinuousMultilinearMap R (fun x => M) N", "name": "ContinuousAlternatingMap.toContinuousMultilinearMap", "isProp": false, "docString": "Projection to `ContinuousMultilinearMap`s. ", "terms": "[\n    \"Projection\",\n    \"ContinuousMultilinearMap\"\n]"}
{"type": "{α : Type u_1} → α ≃ AsBoolAlg α", "name": "toBoolAlg", "isProp": false, "docString": "The \"identity\" equivalence between `AsBoolAlg α` and `α`. ", "terms": "[\n\"identity\",\n\"equivalence\",\n\"AsBoolAlg\",\n\"α\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Abelian C] → CategoryTheory.NonPreadditiveAbelian C", "name": "CategoryTheory.Abelian.nonPreadditiveAbelian", "isProp": false, "docString": "Every abelian category is, in particular, `NonPreadditiveAbelian`. ", "terms": "[\n  \"abelian category\",\n  \"NonPreadditiveAbelian\"\n]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {β : Type u'}\n  [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] (f : β → C)\n  [inst_2 : CategoryTheory.Limits.HasColimit (CategoryTheory.Discrete.functor f)] (b : β),\n  CategoryTheory.IsSplitMono (CategoryTheory.Limits.Sigma.ι f b)", "name": "CategoryTheory.Limits.isSplitMono_sigma_ι", "isProp": true, "docString": "In the presence of zero morphisms, coprojections into a coproduct are (split) monomorphisms. ", "terms": "[\n    \"zero morphisms\",\n    \"coprojections\",\n    \"coproduct\",\n    \"split monomorphisms\",\n    \"monomorphisms\"\n]"}
{"type": "{α : Type u_5} → {β : Type u_6} → [inst : NonAssocSemiring α] → [inst_1 : NonAssocSemiring β] → (α →+* β) → α →*₀ β", "name": "RingHom.toMonoidWithZeroHom", "isProp": false, "docString": "Reinterpret a ring homomorphism `f : α →+* β` as a monoid with zero homomorphism `α →*₀ β`.\nThe `simp`-normal form is `(f : α →*₀ β)`. ", "terms": "[\n    \"ring homomorphism\",\n    \"monoid with zero homomorphism\",\n    \"simp-normal form\"\n]"}
{"type": "AlgebraicGeometry.AffineTargetMorphismProperty", "name": "AlgebraicGeometry.QuasiSeparated.affineProperty", "isProp": false, "docString": "The `AffineTargetMorphismProperty` corresponding to `QuasiSeparated`, asserting that the\ndomain is a quasi-separated scheme. ", "terms": "[\n  \"AffineTargetMorphismProperty\",\n  \"QuasiSeparated\",\n  \"domain\",\n  \"quasi-separated scheme\"\n]"}
{"type": "∀ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [self : Module.Finite R M], Submodule.FG ⊤", "name": "Module.Finite.out", "isProp": true, "docString": "A module over a semiring is `Finite` if it is finitely generated as a module. ", "terms": "[\n  \"module\",\n  \"semiring\",\n  \"Finite\",\n  \"finitely generated\"\n]"}
{"type": "{R : Type u_1} → [inst : CommSemiring R] → [inst : Module R (Additive ℤˣ)] → Pow ℤˣ R", "name": "Int.instUnitsPow", "isProp": false, "docString": "There is a canonical power operation on `ℤˣ` by `R` if `Additive ℤˣ` is an `R`-module.\n\nIn lemma names, this operations is called `uzpow` to match `zpow`.\n\nNotably this is satisfied by `R ∈ {ℕ, ℤ, ZMod 2}`. ", "terms": "[\n  \"canonical\",\n  \"power operation\",\n  \"ℤˣ\",\n  \"R\",\n  \"Additive ℤˣ\",\n  \"R-module\",\n  \"lemma\",\n  \"uzpow\",\n  \"zpow\",\n  \"ℕ\",\n  \"ℤ\",\n  \"ZMod 2\"\n]"}
{"type": "(V : Type v) →\n  [inst : CategoryTheory.Category.{w, v} V] →\n    [inst_1 : CategoryTheory.MonoidalCategory V] →\n      (C : Type u₁) → [inst_2 : CategoryTheory.EnrichedCategory V C] → CategoryTheory.EnrichedFunctor V C C", "name": "CategoryTheory.EnrichedFunctor.id", "isProp": false, "docString": "The identity enriched functor. ", "terms": "[\n    \"identity\",\n    \"enriched\",\n    \"functor\"\n]"}
{"type": "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R],\n  DiscreteValuationRing.HasUnitMulPowIrreducibleFactorization R → DiscreteValuationRing R", "name": "DiscreteValuationRing.ofHasUnitMulPowIrreducibleFactorization", "isProp": true, "docString": "An integral domain in which there is an irreducible element `p`\nsuch that every nonzero element is associated to a power of `p`\nis a discrete valuation ring.\n", "terms": "[\n    \"integral domain\",\n    \"irreducible element\",\n    \"nonzero element\",\n    \"associated\",\n    \"power\",\n    \"discrete valuation ring\"\n]"}
{"type": "∀ {M : Type u_1} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_2} [inst_1 : CommMonoid N] {P : Type u_3}\n  [inst_2 : CommMonoid P] (f : Submonoid.LocalizationMap S N) {g : M →* P} (hg : ∀ (y : ↥S), IsUnit (g ↑y)) (x : M)\n  (y : ↥S),\n  (Submonoid.LocalizationMap.lift f hg) (Submonoid.LocalizationMap.mk' f x y) =\n    g x * ↑((IsUnit.liftRight (MonoidHom.restrict g S) hg) y)⁻¹", "name": "Submonoid.LocalizationMap.lift_mk'", "isProp": true, "docString": "Given a Localization map `f : M →* N` for a Submonoid `S ⊆ M` and a map of `CommMonoid`s\n`g : M →* P` such that `g y` is invertible for all `y : S`, the homomorphism induced from\n`N` to `P` maps `f x * (f y)⁻¹` to `g x * (g y)⁻¹` for all `x : M, y ∈ S`. ", "terms": "[\n\"Localization map\",\n\"Submonoid\",\n\"map\",\n\"CommMonoid\",\n\"invertible\",\n\"homomorphism\",\n\"induced\",\n\"maps\",\n\"for all\",\n\"inverse\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroObject C] → [inst_2 : CategoryTheory.Limits.HasInitial C] → 0 ≅ ⊥_ C", "name": "CategoryTheory.Limits.HasZeroObject.zeroIsoInitial", "isProp": false, "docString": "The (unique) isomorphism between the chosen initial object and the chosen zero object. ", "terms": "[\n  \"Isomorphism\",\n  \"Initial object\",\n  \"Zero object\"\n]"}
{"type": "∀ {E : Type u_6} [inst : SeminormedAddGroup E] (a b : E), ‖b‖₊ ≤ ‖a‖₊ + ‖a - b‖₊", "name": "nnnorm_le_insert", "isProp": true, "docString": "**Alias** of `nnnorm_le_nnnorm_add_nnnorm_sub`.", "terms": "[]\n"}
{"type": "{H : Type u} → [inst : TopologicalSpace H] → OrderBot (StructureGroupoid H)", "name": "instStructureGroupoidOrderBot", "isProp": false, "docString": "Every structure groupoid contains the identity groupoid. ", "terms": "[\n    \"Structure Groupoid\",\n    \"Identity Groupoid\"\n]"}
{"type": "{α β : Type u_6} → [i₁ : MeasurableSpace α] → [i₂ : MeasurableSpace β] → α = β → HEq i₁ i₂ → α ≃ᵐ β", "name": "MeasurableEquiv.cast", "isProp": false, "docString": "Equal measurable spaces are equivalent. ", "terms": "[\"Equal\", \"measurable spaces\", \"equivalent\"]"}
{"type": "{L : FirstOrder.Language} →\n  {α : Type u'} →\n    {γ : Type u_3} →\n      FirstOrder.Language.Term (FirstOrder.Language.withConstants L γ) α → FirstOrder.Language.Term L (γ ⊕ α)", "name": "FirstOrder.Language.Term.constantsToVars", "isProp": false, "docString": "Sends a term with constants to a term with extra variables. ", "terms": "[\"term\", \"constants\", \"variables\", \"extra variables\"]"}
{"type": "{R : Type u_3} → {S : Type u_5} → [inst : Ring R] → [inst : Ring S] → Ring (R × S)", "name": "Prod.instRing", "isProp": false, "docString": "Product of two rings is a ring. ", "terms": "[\n    \"Product\",\n    \"Rings\"\n]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.IsFiltered C] {D : Type u₁}\n  [inst_2 : CategoryTheory.Category.{v₁, u₁} D] {L : CategoryTheory.Functor D C} {R : CategoryTheory.Functor C D},\n  (L ⊣ R) → CategoryTheory.IsFiltered D", "name": "CategoryTheory.IsFiltered.of_right_adjoint", "isProp": true, "docString": "If `C` is filtered, and we have a functor `R : C ⥤ D` with a left adjoint, then `D` is filtered.\n", "terms": "[\n  \"filtered\",\n  \"functor\",\n  \"left adjoint\"\n]"}
{"type": "∀ {α : Type u_1} [inst : DecidableEq α] [inst_1 : Fintype α], Finset.upShadow ∅ = ∅", "name": "Finset.upShadow_empty", "isProp": true, "docString": "The upper shadow of the empty set is empty. ", "terms": "[\"upper shadow\", \"empty set\"]"}
{"type": "∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →SL[σ₁₂] F)\n  [inst_6 : RingHomIsometric σ₁₂], ‖f‖ = 0 ↔ f = 0", "name": "ContinuousLinearMap.op_norm_zero_iff", "isProp": true, "docString": "An operator is zero iff its norm vanishes. ", "terms": "[\n  \"operator\",\n  \"zero\",\n  \"iff\",\n  \"norm\",\n  \"vanishes\"\n]"}
{"type": "(K : Type u₁) →\n  [inst : Field K] →\n    (v : Valuation K NNReal) →\n      (O : Type u₂) → [inst_1 : CommRing O] → [inst_2 : Algebra O K] → Valuation.Integers v O → ℕ → Type u₂", "name": "ModP", "isProp": false, "docString": "`O/(p)` for `O`, ring of integers of `K`. ", "terms": "[\n    \"O/(p)\",\n    \"O\",\n    \"ring of integers\",\n    \"K\"\n]"}
{"type": "¬Small.{u, max (u + 1) (v + 1)} Ordinal.{max u v}", "name": "not_small_ordinal", "isProp": true, "docString": "The type of ordinals in universe `u` is not `Small.{u}`. This is the type-theoretic analog of\nthe Burali-Forti paradox. ", "terms": "[\n    \"ordinals\",\n    \"universe\",\n    \"Small.{u}\",\n    \"type-theoretic\",\n    \"Burali-Forti paradox\"\n]"}
{"type": "{α : Type u_1} → {β : Type u_2} → (α → β) → Sym2 α → Sym2 β", "name": "Sym2.map", "isProp": false, "docString": "The functor `Sym2` is functorial, and this function constructs the induced maps.\n", "terms": "[\n  \"functor\",\n  \"functorial\",\n  \"function\",\n  \"induced maps\"\n]"}
{"type": "∀ {R : Type u} [inst : CommRing R] (I : Ideal R),\n  (∀ (J : Ideal R) (hJ : Ideal.IsMaximal J), Ideal.map (algebraMap R (Localization.AtPrime J)) I = ⊥) → I = ⊥", "name": "ideal_eq_bot_of_localization'", "isProp": true, "docString": "An ideal is trivial if its localization at every maximal ideal is trivial. ", "terms": "[\n    \"Ideal\",\n    \"Trivial\",\n    \"Localization\",\n    \"Maximal Ideal\"\n]"}
{"type": "∀ {x : ENNReal}, x ≠ ⊤ → Filter.HasBasis (nhds x) (fun x => x ≠ 0) fun ε => Set.Icc (x - ε) (x + ε)", "name": "ENNReal.hasBasis_nhds_of_ne_top'", "isProp": true, "docString": "Closed intervals `Set.Icc (x - ε) (x + ε)`, `ε ≠ 0`, form a basis of neighborhoods of an\nextended nonnegative real number `x ≠ ∞`. We use `Set.Icc` instead of `Set.Ioo` because this way the\nstatement works for `x = 0`.\n", "terms": "[\n    \"Closed intervals\",\n    \"Set.Icc\",\n    \"basis\",\n    \"neighborhoods\",\n    \"extended\",\n    \"nonnegative real number\",\n    \"Set.Ioo\"\n]"}
{"type": "(L : FirstOrder.Language) →\n  (ι : Type v) →\n    [inst : Preorder ι] →\n      (G : ι → Type w) →\n        [inst_1 : (i : ι) → FirstOrder.Language.Structure L (G i)] →\n          (f : (i j : ι) → i ≤ j → FirstOrder.Language.Embedding L (G i) (G j)) →\n            [inst_2 : IsDirected ι fun x x_1 => x ≤ x_1] →\n              [inst_3 : DirectedSystem G fun i j h => ⇑(f i j h)] →\n                [inst_4 : Nonempty ι] →\n                  {P : Type u₁} →\n                    [inst_5 : FirstOrder.Language.Structure L P] →\n                      (g : (i : ι) → FirstOrder.Language.Embedding L (G i) P) →\n                        (∀ (i j : ι) (hij : i ≤ j) (x : G i), (g j) ((f i j hij) x) = (g i) x) →\n                          FirstOrder.Language.Embedding L (FirstOrder.Language.DirectLimit G f) P", "name": "FirstOrder.Language.DirectLimit.lift", "isProp": false, "docString": "The universal property of the direct limit: maps from the components to another module\nthat respect the directed system structure (i.e. make some diagram commute) give rise\nto a unique map out of the direct limit. ", "terms": "[\n    \"universal property\",\n    \"direct limit\",\n    \"maps\",\n    \"components\",\n    \"module\",\n    \"directed system structure\",\n    \"diagram\",\n    \"commute\",\n    \"unique map\"\n]"}
{"type": "(P : PFunctor.{u}) → {α : Type v₁} → {β : Type v₂} → (α → β) → ↑P α → ↑P β", "name": "PFunctor.map", "isProp": false, "docString": "Applying `P` to a morphism of `Type` ", "terms": "[\"Applying\", \"morphism\", \"Type\"]"}
{"type": "∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {p : ENNReal},\n  1 ≤ p →\n    ∀ {f : ℕ → α → ℝ},\n      MeasureTheory.UniformIntegrable f p μ →\n        MeasureTheory.UniformIntegrable (fun n => (Finset.sum (Finset.range n) fun i => f i) / ↑n) p μ", "name": "MeasureTheory.uniformIntegrable_average_real", "isProp": true, "docString": "The averaging of a uniformly integrable real-valued sequence is also uniformly integrable. ", "terms": "[\n    \"averaging\",\n    \"uniformly integrable\",\n    \"real-valued\",\n    \"sequence\"\n]"}
{"type": "CategoryTheory.Functor CondensedSet CondensedAb", "name": "Condensed.freeAb", "isProp": false, "docString": "The left adjoint to the forgetful functor. The *free condensed abelian group* on a condensed set.\n", "terms": "[\n  \"left adjoint\",\n  \"forgetful functor\",\n  \"free condensed abelian group\",\n  \"condensed set\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {D : Type u'} →\n      [inst_1 : CategoryTheory.Category.{v', u'} D] →\n        (F : CategoryTheory.Functor C D) →\n          [inst_2 :\n              CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair)\n                F] →\n            [inst_3 : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) F] →\n              [inst_4 : CategoryTheory.Limits.HasFiniteCoproducts C] →\n                (n : ℕ) → CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete (Fin n)) F", "name": "CategoryTheory.preservesShapeFinOfPreservesBinaryAndInitial", "isProp": false, "docString": "If `F` preserves the initial object and binary coproducts, then it preserves colimits of shape\n`Discrete (Fin n)`.\n", "terms": "[\n    \"preserves\",\n    \"initial object\",\n    \"binary coproducts\",\n    \"colimits\",\n    \"shape\",\n    \"Discrete\",\n    \"Fin n\"\n]"}
{"type": "Lean.PrettyPrinter.Delaborator.Delab", "name": "iInf_delab", "isProp": false, "docString": "Delaborator for indexed infimum. ", "terms": "[\"Delaborator\", \"indexed\", \"infimum\"]"}
{"type": "{α : Type u} → {β : Type v} → (ℕ → α → β) → ℕ → List α → List β", "name": "List.oldMapIdxCore", "isProp": false, "docString": "Lean3 `map_with_index` helper function ", "terms": "The statement provided is related to computer science, particularly functional programming (in the Lean3 proof assistant), and not directly to mathematics. The term `map_with_index` is a functional programming concept, and not a mathematical term in the traditional sense. \n\nHence, the return would be an empty list:\n[]\n"}
{"type": "{M : Type w} →\n  {c f₁ f₂ : Type u} →\n    {r₁ r₂ : Type v} →\n      (c → M) →\n        (f₁ → M → M) →\n          (f₂ → M → M → M) →\n            (r₁ → Set M) → (r₂ → M → M → Prop) → FirstOrder.Language.Structure (FirstOrder.Language.mk₂ c f₁ f₂ r₁ r₂) M", "name": "FirstOrder.Language.Structure.mk₂", "isProp": false, "docString": "A structure constructor to match `FirstOrder.Language₂`. ", "terms": "[\"structure constructor\", \"FirstOrder.Language₂\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {D : Type u_1} →\n      [inst_1 : CategoryTheory.Category.{u_2, u_1} D] →\n        {Z : D} →\n          (F : CategoryTheory.Functor C D) →\n            (hZ : CategoryTheory.Limits.IsInitial Z) →\n              (G : CategoryTheory.Functor (CategoryTheory.WithInitial C) D) →\n                (CategoryTheory.Functor.comp CategoryTheory.WithInitial.incl G ≅ F) →\n                  (G.obj CategoryTheory.WithInitial.star ≅ Z) → (G ≅ CategoryTheory.WithInitial.liftToInitial F hZ)", "name": "CategoryTheory.WithInitial.liftToInitialUnique", "isProp": false, "docString": "A variant of `lift_unique` with `Z` an initial object. ", "terms": "[\n    \"variant\", \n    \"lift_unique\", \n    \"initial object\"\n]"}
{"type": "∀ {a : NNReal}, AddLECancellable ↑a", "name": "ENNReal.cancel_coe", "isProp": true, "docString": "This lemma has an abbreviated name because it is used frequently. ", "terms": "[]"}
{"type": "∀ {α : Type u} [inst : AddCommGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c : α}, a < b + c → a - b < c", "name": "sub_left_lt_of_lt_add", "isProp": true, "docString": "**Alias** of the reverse direction of `sub_lt_iff_lt_add'`.", "terms": "[\n  \"Alias\",\n  \"reverse direction\",\n  \"sub_lt_iff_lt_add\"\n]"}
{"type": "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ : Real.Angle),\n  LinearMap.det ↑(Orientation.rotation o θ).toLinearEquiv = 1", "name": "Orientation.det_rotation", "isProp": true, "docString": "The determinant of `rotation` (as a linear map) is equal to `1`. ", "terms": "[\"determinant\", \"rotation\", \"linear map\", \"equal\", \"1\"]"}
{"type": "∀ {α : Type u_1} [inst : CommGroup α] [inst_1 : DecidableEq α] (A B C : Finset α),\n  Finset.card (A / C) * Finset.card B ≤ Finset.card (A * B) * Finset.card (B * C)", "name": "Finset.card_div_mul_le_card_mul_mul_card_mul", "isProp": true, "docString": "**Ruzsa's triangle inequality**. Div-mul-mul version. ", "terms": "[\"Ruzsa's triangle inequality\", \"Div-mul-mul version\"]"}
{"type": "∀ {β : Type u} {α : Type v} [inst : AddCommMonoid β] [inst_1 : DecidableEq α] (s : Finset α) {f : α → β} {a : α},\n  f a = 0 → (Finset.sum (Finset.erase s a) fun x => f x) = Finset.sum s fun x => f x", "name": "Finset.sum_erase", "isProp": true, "docString": "If a function applied at a point is 0, a sum is unchanged by\nremoving that point, if present, from a `Finset`.", "terms": "[\n    \"function\",\n    \"point\",\n    \"0\",\n    \"sum\",\n    \"unchanged\",\n    \"removing\",\n    \"present\",\n    \"Finset\"\n]"}
{"type": "∀ {E : Type u_2} [inst : AddCommGroup E] [inst_1 : Module ℝ E] (s : ConvexCone ℝ E) (f : E →ₗ.[ℝ] ℝ),\n  (∀ (x : ↥f.domain), ↑x ∈ s → 0 ≤ ↑f x) →\n    (∀ (y : E), ∃ x, ↑x + y ∈ s) → f.domain ≠ ⊤ → ∃ g, f < g ∧ ∀ (x : ↥g.domain), ↑x ∈ s → 0 ≤ ↑g x", "name": "RieszExtension.step", "isProp": true, "docString": "Induction step in M. Riesz extension theorem. Given a convex cone `s` in a vector space `E`,\na partially defined linear map `f : f.domain → ℝ`, assume that `f` is nonnegative on `f.domain ∩ p`\nand `p + s = E`. If `f` is not defined on the whole `E`, then we can extend it to a larger\nsubmodule without breaking the non-negativity condition. ", "terms": "[\n    \"Induction step\",\n    \"M. Riesz extension theorem\",\n    \"Convex cone\",\n    \"Vector space\",\n    \"Partially defined\",\n    \"Linear map\",\n    \"Domain\",\n    \"ℝ\",\n    \"Nonnegative\",\n    \"Intersection\",\n    \"Submodule\",\n    \"Non-negativity condition\"\n]"}
{"type": "Type (u + 1)", "name": "SSet.Augmented", "isProp": false, "docString": "The category of augmented simplicial sets, as a particular case of\naugmented simplicial objects. ", "terms": "[\n    \"category\",\n    \"augmented simplicial sets\",\n    \"particular case\",\n    \"augmented simplicial objects\"\n]"}
{"type": "(α : Type u_1) →\n  (E : Type u_4) →\n    (𝕜 : Type u_6) →\n      [inst : MeasurableSpace α] →\n        [inst_1 : NormedAddCommGroup E] →\n          {p : ENNReal} →\n            {μ : MeasureTheory.Measure α} →\n              [inst_2 : Fact (1 ≤ p)] →\n                [inst_3 : NormedRing 𝕜] →\n                  [inst_4 : Module 𝕜 E] →\n                    [inst_5 : BoundedSMul 𝕜 E] → ↥(MeasureTheory.Lp.simpleFunc E p μ) →L[𝕜] ↥(MeasureTheory.Lp E p)", "name": "MeasureTheory.Lp.simpleFunc.coeToLp", "isProp": false, "docString": "The embedding of Lp simple functions into Lp functions, as a continuous linear map. ", "terms": "[\n    \"embedding\",\n    \"Lp simple functions\",\n    \"Lp functions\",\n    \"continuous\",\n    \"linear map\"\n]"}
{"type": "{α : Type u_2} → (β : Type u_3) → [inst : LinearOrderedField α] → [inst : DivisionRing β] → α → Set β", "name": "LinearOrderedField.cutMap", "isProp": false, "docString": "The lower cut of rationals inside a linear ordered field that are less than a given element of\nanother linear ordered field. ", "terms": "[\n    \"lower cut\",\n    \"rationals\",\n    \"linear ordered field\",\n    \"element\"\n]"}
{"type": "∀ {Ω : Type u_1} {ι : Type u_2} {L : Filter ι} [inst : MeasurableSpace Ω] [inst_1 : PseudoEMetricSpace Ω]\n  [inst_2 : OpensMeasurableSpace Ω] [inst_3 : HasOuterApproxClosed Ω] {μ : MeasureTheory.ProbabilityMeasure Ω}\n  {μs : ι → MeasureTheory.ProbabilityMeasure Ω},\n  Filter.Tendsto μs L (nhds μ) →\n    ∀ {E : Set Ω},\n      (fun s => ENNReal.toNNReal (↑↑↑μ s)) (frontier E) = 0 →\n        Filter.Tendsto (fun i => (fun s => ENNReal.toNNReal (↑↑↑(μs i) s)) E) L\n          (nhds ((fun s => ENNReal.toNNReal (↑↑↑μ s)) E))", "name": "MeasureTheory.ProbabilityMeasure.tendsto_measure_of_null_frontier_of_tendsto", "isProp": true, "docString": "One implication of the portmanteau theorem:\nWeak convergence of probability measures implies that if the boundary of a Borel set\ncarries no probability mass under the limit measure, then the limit of the measures of the set\nequals the measure of the set under the limit probability measure.\n\nA version with coercions to ordinary `ℝ≥0∞`-valued measures is\n`MeasureTheory.ProbabilityMeasure.tendsto_measure_of_null_frontier_of_tendsto'`.\n", "terms": "[\"implication\", \"portmanteau theorem\", \"weak convergence\", \"probability measures\", \"boundary\", \"Borel set\", \"probability mass\", \"limit measure\", \"limit of the measures\", \"measure of the set\", \"limit probability measure\", \"coercions\", \"ℝ≥0∞\", \"valued measures\", \"MeasureTheory.ProbabilityMeasure.tendsto_measure_of_null_frontier_of_tendsto'\"]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} {f : α → β},\n  Function.Injective f → (Nat.card β = 0 → Nat.card α = 0) → Nat.card α ≤ Nat.card β", "name": "Finite.card_le_of_injective'", "isProp": true, "docString": "If `f` is injective, then `Nat.card α ≤ Nat.card β`. We must also assume\n`Nat.card β = 0 → Nat.card α = 0` since `Nat.card` is defined to be `0` for infinite types. ", "terms": "[\n    \"injective\",\n    \"Nat.card\",\n    \"≤\",\n    \"0\",\n    \"infinite types\"\n]"}
{"type": "∀ {α : Type u_1} {M : Type u_8} {R : Type u_14} {S : Type u_15} [inst : Zero M] [inst_1 : Semiring R]\n  [inst_2 : Semiring S] (h : R →+* S) (f : α →₀ M) (g : α → M → R),\n  h (Finsupp.sum f g) = Finsupp.sum f fun a b => h (g a b)", "name": "RingHom.map_finsupp_sum", "isProp": true, "docString": "Deprecated, use `_root_.map_finsupp_sum` instead. ", "terms": "The statement provided does not contain any mathematical terms excluding meta-mathematical terms, variable names and symbols. Therefore, the answer is an empty list:\n\n    []"}
{"type": "ℕ → (R : Type u_1) → [inst : CommRing R] → [inst : IsDomain R] → Finset R", "name": "Polynomial.nthRootsFinset", "isProp": false, "docString": "The multiset `nthRoots ↑n (1 : R)` as a Finset. ", "terms": "[\n    \"multiset\",\n    \"nthRoots\",\n    \"^\",\n    \"1\",\n    \"R\",\n    \"Finset\"\n]"}
{"type": "Unique (ℝ →+* ℝ)", "name": "Real.RingHom.unique", "isProp": false, "docString": "There exists no nontrivial ring homomorphism `ℝ →+* ℝ`. ", "terms": "[\n    \"exists\",\n    \"nontrivial\",\n    \"ring\",\n    \"homomorphism\"\n]"}
{"type": "{α : Type u_1} → {β : α → Type u_2} → WType β → (a : α) × (β a → WType β)", "name": "WType.toSigma", "isProp": false, "docString": "The canonical map to the corresponding sigma type, returning the label of a node as an\nelement `a` of `α`, and the children of the node as a function `β a → WType β`. ", "terms": "[\n    \"canonical map\",\n    \"corresponding\",\n    \"sigma type\",\n    \"returning\",\n    \"label\",\n    \"node\",\n    \"element\",\n    \"children\",\n    \"node\",\n    \"function\",\n    \"WType\"\n]"}
{"type": "{α : Type u} → (r : α → α → Prop) → [inst : IsStrictOrder α r] → PartialOrder α", "name": "partialOrderOfSO", "isProp": false, "docString": "Construct a partial order from an `isStrictOrder` relation.\n\nSee note [reducible non-instances]. ", "terms": "[\n    \"Construct\",\n    \"partial order\",\n    \"isStrictOrder\",\n    \"relation\",\n    \"reducible non-instances\"\n]"}
{"type": "(𝕜 : Type u_8) → [inst : IsROrC 𝕜] → (n : Type u_9) → [inst : Fintype n] → Type (max u_9 u_8)", "name": "EuclideanSpace", "isProp": false, "docString": "The standard real/complex Euclidean space, functions on a finite type. For an `n`-dimensional\nspace use `EuclideanSpace 𝕜 (Fin n)`. ", "terms": "[\"standard real/complex Euclidean space\", \"functions\", \"finite type\", \"n-dimensional space\", \"EuclideanSpace\", \"Fin\"]"}
{"type": "{ι : Type u_1} →\n  {R : Type u_2} →\n    [inst : CommRing R] →\n      [inst_1 : IsDomain R] →\n        [inst_2 : IsPrincipalIdealRing R] →\n          {S : Type u_4} →\n            [inst_3 : CommRing S] →\n              [inst_4 : IsDomain S] →\n                [inst_5 : Algebra R S] → [inst_6 : Finite ι] → Basis ι R S → (I : Ideal S) → I ≠ ⊥ → Basis ι R ↥I", "name": "Ideal.selfBasis", "isProp": false, "docString": "If `S` a finite-dimensional ring extension of a PID `R` which is free as an `R`-module,\nthen any nonzero `S`-ideal `I` is free as an `R`-submodule of `S`, and we can\nfind a basis for `S` and `I` such that the inclusion map is a square diagonal\nmatrix; this is the basis for `I`.\nSee `Ideal.ringBasis` for the basis on `S`,\nsee `Ideal.smithCoeffs` for the entries of the diagonal matrix\nand `Ideal.selfBasis_def` for the proof that the inclusion map forms a square diagonal matrix.\n", "terms": "[\n  \"finite-dimensional\",\n  \"ring extension\",\n  \"Principal Ideal Domain (PID)\",\n  \"free\",\n  \"R-module\",\n  \"nonzero\",\n  \"S-ideal\",\n  \"free\",\n  \"R-submodule\",\n  \"basis\",\n  \"inclusion map\",\n  \"square diagonal matrix\",\n  \"Ideal.ringBasis\",\n  \"entries\",\n  \"diagonal matrix\",\n  \"Ideal.smithCoeffs\",\n  \"Ideal.selfBasis_def\"\n]"}
{"type": "Lean.ParserDescr", "name": "BigOperators.«term∏ᶠ_,_»", "isProp": false, "docString": "`∏ᶠ x, f x` is notation for `finprod f`. It is the sum of `f x`, where `x` ranges over the\nmultiplicative support of `f`, if it's finite, one otherwise. Taking the product over multiple\narguments or conditions is possible, e.g. `∏ᶠ (x) (y), f x y` and `∏ᶠ (x) (h: x ∈ s), f x`", "terms": "[\n    \"notation\",\n    \"finprod\",\n    \"sum\",\n    \"ranges\",\n    \"multiplicative support\",\n    \"finite\",\n    \"one\",\n    \"product\",\n    \"arguments\",\n    \"conditions\"\n]"}
{"type": "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : TopologicalSpace α] →\n      [inst_1 : TopologicalSpace β] →\n        (e : PartialEquiv α β) →\n          ContinuousOn (↑e) e.source → IsOpenMap (Set.restrict e.source ↑e) → IsOpen e.source → PartialHomeomorph α β", "name": "PartialHomeomorph.ofContinuousOpenRestrict", "isProp": false, "docString": "A `PartialEquiv` with continuous open forward map and open source is a `PartialHomeomorph`. ", "terms": "[\n  \"PartialEquiv\",\n  \"continuous\",\n  \"open forward map\",\n  \"open source\",\n  \"PartialHomeomorph\"\n]"}
{"type": "{V : Type u} →\n  [inst : CategoryTheory.Category.{v, u} V] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] →\n      [inst_2 : CategoryTheory.Limits.HasKernels V] →\n        [inst_3 : CategoryTheory.Limits.HasImages V] →\n          [inst_4 : CategoryTheory.Limits.HasCokernels V] →\n            (C : CochainComplex V ℕ) →\n              (n : ℕ) →\n                HomologicalComplex.homology' C (n + 1) ≅\n                  homology' (HomologicalComplex.d C n (n + 1)) (HomologicalComplex.d C (n + 1) (n + 2))\n                    (_ :\n                      CategoryTheory.CategoryStruct.comp (HomologicalComplex.d C n (n + 1))\n                          (HomologicalComplex.d C (n + 1) (n + 2)) =\n                        0)", "name": "CochainComplex.homology'SuccIso", "isProp": false, "docString": "The `n + 1`th cohomology of a cochain complex (as kernel of 'the differential from `Cₙ₊₁`'\nmodulo the image of 'the differential to `Cₙ₊₁`') is isomorphic to the kernel of `d : Cₙ₊₁ → Cₙ₊₂`\nmodulo the image of `d : Cₙ → Cₙ₊₁`. ", "terms": "[\n\"Cohomology\",\n\"Cochain complex\",\n\"Kernel\",\n\"Differential\",\n\"Modulo\",\n\"Image\",\n\"Isomorphic\"\n]"}
{"type": "∀ {α : Type u} {ι : Type u_1} [inst : PseudoMetricSpace α] {s : Set α} {f : α → ↥(lp (fun i => ℝ) ⊤)} {K : NNReal},\n  LipschitzOnWith K f s → ∃ g, LipschitzWith K g ∧ Set.EqOn f g s", "name": "LipschitzOnWith.extend_lp_infty", "isProp": true, "docString": "A function `f : α → ℓ^∞(ι, ℝ)` which is `K`-Lipschitz on a subset `s` admits a `K`-Lipschitz\nextension to the whole space.\n\nTheorem 2.2 of [Assaf Naor, *Metric Embeddings and Lipschitz Extensions*][Naor-2015]\n\nThe same result for the case of a finite type `ι` is implemented in\n`LipschitzOnWith.extend_pi`.\n", "terms": "[\n  \"function\", \n  \"ℓ^∞(ι, ℝ)\", \n  \"K-Lipschitz\", \n  \"subset\", \n  \"K-Lipschitz extension\", \n  \"whole space\", \n  \"Theorem\", \n  \"Metric Embeddings\", \n  \"Lipschitz Extensions\", \n  \"finite type\", \n  \"LipschitzOnWith.extend_pi\"\n]"}
{"type": "{R : Type u_1} → {A : Type u_2} → Unitization R A → A", "name": "Unitization.snd", "isProp": false, "docString": "The canonical projection `Unitization R A → A`. ", "terms": "[\n    \"canonical projection\",\n    \"Unitization\",\n    \"R\",\n    \"A\"\n]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : CategoryTheory.SimplicialObject.Augmented C}\n  (f : X ⟶ Y),\n  CategoryTheory.CategoryStruct.comp\n      ((CategoryTheory.SimplicialObject.Augmented.drop.map f).app (Opposite.op (SimplexCategory.mk 0)))\n      (Y.hom.app (Opposite.op (SimplexCategory.mk 0))) =\n    CategoryTheory.CategoryStruct.comp (X.hom.app (Opposite.op (SimplexCategory.mk 0)))\n      (CategoryTheory.SimplicialObject.Augmented.point.map f)", "name": "CategoryTheory.SimplicialObject.Augmented.w₀", "isProp": true, "docString": "The compatibility of a morphism with the augmentation, on 0-simplices ", "terms": "[\n    \"compatibility\",\n    \"morphism\",\n    \"augmentation\",\n    \"0-simplices\"\n]"}
{"type": "∀ {Ω : Type u_1} {m0 : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω} {ℱ : MeasureTheory.Filtration ℕ m0}\n  [inst : MeasureTheory.IsFiniteMeasure μ] {g : Ω → ℝ},\n  MeasureTheory.Integrable g →\n    MeasureTheory.StronglyMeasurable g →\n      ∀ᵐ (x : Ω) ∂μ, Filter.Tendsto (fun n => MeasureTheory.condexp (↑ℱ n) μ g x) Filter.atTop (nhds (g x))", "name": "MeasureTheory.Integrable.tendsto_ae_condexp", "isProp": true, "docString": "Part c of the **L¹ martingale convergence theorem**: Given an integrable function `g` which\nis measurable with respect to `⨆ n, ℱ n` where `ℱ` is a filtration, the martingale defined by\n`𝔼[g | ℱ n]` converges almost everywhere to `g`.\n\nThis martingale also converges to `g` in L¹ and this result is provided by\n`MeasureTheory.Integrable.tendsto_snorm_condexp` ", "terms": "[\n  \"L¹\",\n  \"martingale convergence theorem\",\n  \"integrable function\",\n  \"measurable\",\n  \"filtration\",\n  \"martingale\",\n  \"converges almost everywhere\",\n  \"L¹ convergence\",\n  \"MeasureTheory.Integrable.tendsto_snorm_condexp\"\n]"}
{"type": "(F : CategoryTheory.Functor Stoneanᵒᵖ AddCommGroupCat) →\n  [inst : CategoryTheory.Limits.PreservesFiniteProducts F] → CondensedAb", "name": "CondensedAb.ofSheafStonean", "isProp": false, "docString": "A `CondensedAb` version of `Condensed.ofSheafStonean`. ", "terms": "[\"CondensedAb\", \"Condensed.ofSheafStonean\"]"}
{"type": "∀ {R : Type u_1} {R₂ : Type u_2} {M : Type u_4} {M₂ : Type u_5} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] [inst_3 : Semiring R₂] {σ₁₂ : R →+* R₂} [inst_4 : AddCommMonoid M₂] [inst_5 : Module R₂ M₂]\n  {F : Type u_8} [inst_6 : SemilinearMapClass F σ₁₂ M M₂] [inst_7 : RingHomSurjective σ₁₂] (f : F) (s : Set M)\n  (N : Submodule R₂ M₂), Submodule.map f (Submodule.span R s) ≤ N ↔ ∀ m ∈ s, f m ∈ N", "name": "LinearMap.map_span_le", "isProp": true, "docString": "**Alias** of `Submodule.map_span_le`.", "terms": "[\"Alias\", \"Submodule\", \"map_span_le\"]"}
{"type": "{α β : BddOrd} → ↑α.toPartOrd ≃o ↑β.toPartOrd → (α ≅ β)", "name": "BddOrd.Iso.mk", "isProp": false, "docString": "Constructs an equivalence between bounded orders from an order isomorphism between them. ", "terms": "[\n    \"Constructs\",\n    \"equivalence\",\n    \"bounded orders\",\n    \"order isomorphism\"\n]"}
{"type": "∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (w₁ : NumberField.InfinitePlace K) {B : ℕ},\n  NumberField.mixedEmbedding.minkowskiBound K < NumberField.mixedEmbedding.convexBodyLTFactor K * ↑B →\n    ∀ {x : ↥(NumberField.ringOfIntegers K)},\n      x ≠ 0 → ∃ y, y ≠ 0 ∧ (∀ (w : NumberField.InfinitePlace K), w ≠ w₁ → w ↑y < w ↑x) ∧ |(Algebra.norm ℚ) ↑y| ≤ ↑B", "name": "NumberField.Units.dirichletUnitTheorem.seq_next", "isProp": true, "docString": "This result shows that there always exists a next term in the sequence. ", "terms": "[\"result\", \"exists\", \"next term\", \"sequence\"]"}
{"type": "∀ {ι : Type u_1} {M : Type u_4} {N : Type u_5} [inst : CommMonoid M] [inst_1 : OrderedCommMonoid N] (f : M → N)\n  (p : M → Prop),\n  f 1 = 1 →\n    (∀ (x y : M), p x → p y → f (x * y) ≤ f x * f y) →\n      (∀ (x y : M), p x → p y → p (x * y)) →\n        ∀ (g : ι → M) {s : Finset ι},\n          (∀ i ∈ s, p (g i)) → f (Finset.prod s fun i => g i) ≤ Finset.prod s fun i => f (g i)", "name": "Finset.le_prod_of_submultiplicative_on_pred", "isProp": true, "docString": "Let `{x | p x}` be a subsemigroup of a commutative monoid `M`. Let `f : M → N` be a map\nsuch that `f 1 = 1` and `f` is submultiplicative on `{x | p x}`, i.e.,\n`p x → p y → f (x * y) ≤ f x * f y`. Let `g i`, `i ∈ s`, be a finite family of elements of `M` such\nthat `∀ i ∈ s, p (g i)`. Then `f (∏ i in s, g i) ≤ ∏ i in s, f (g i)`. ", "terms": "[\n    \"subsemigroup\",\n    \"commutative\",\n    \"monoid\",\n    \"map\",\n    \"submultiplicative\",\n    \"finite family\",\n    \"elements\",\n    \"product\"\n]"}
{"type": "{m : Type (max u_1 u_2) → Type u_3} →\n  {α : Type u_2} →\n    {β : Type (max u_1 u_2)} → [inst : Monad m] → [inst : Alternative m] → List α → (α → m β) → m (List α × List β)", "name": "List.tryAllM", "isProp": false, "docString": "Run a monadic function on every element of a list,\nreturning the list of elements on which the function fails, and the list of successful results. ", "terms": "[\"monadic function\", \"element\", \"list\", \"function\", \"results\"]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} [inst : Mul α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α}\n  [inst_3 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1],\n  Monotone f → Monotone g → Monotone fun x => f x * g x", "name": "Monotone.mul'", "isProp": true, "docString": "The product of two monotone functions is monotone. ", "terms": "[\n    \"product\",\n    \"monotone functions\",\n    \"is\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    (J : CategoryTheory.GrothendieckTopology C) →\n      {D : Type w} →\n        [inst_1 : CategoryTheory.Category.{max v u, w} D] →\n          [inst_2 :\n              ∀ (P : CategoryTheory.Functor Cᵒᵖ D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X),\n                CategoryTheory.Limits.HasMultiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)] →\n            [inst_3 :\n                ∀ (X : C),\n                  CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)ᵒᵖ D] →\n              (P : CategoryTheory.Functor Cᵒᵖ D) → P ⟶ CategoryTheory.GrothendieckTopology.sheafify J P", "name": "CategoryTheory.GrothendieckTopology.toSheafify", "isProp": false, "docString": "The canonical map from `P` to its sheafification. ", "terms": "[\n  \"canonical map\",\n  \"sheafification\"\n]"}
{"type": "{β : Sort u_1} → {α : Sort u_2} → {p : β → Prop} → (e : α ≃ β) → { a // p (e a) } ≃ { b // p b }", "name": "Equiv.subtypeEquivOfSubtype", "isProp": false, "docString": "If `α ≃ β`, then for any predicate `p : β → Prop` the subtype `{a // p (e a)}` is equivalent\nto the subtype `{b // p b}`. ", "terms": "[\n  \"equivalent\",\n  \"predicate\",\n  \"subtype\"\n]"}
{"type": "{R : Type u} →\n  [inst : Ring R] →\n    {X₁ X₂ X₃ : Type v} →\n      [inst_1 : AddCommGroup X₁] →\n        [inst_2 : AddCommGroup X₂] →\n          [inst_3 : AddCommGroup X₃] →\n            [inst_4 : Module R X₁] →\n              [inst_5 : Module R X₂] →\n                [inst_6 : Module R X₃] →\n                  (f : X₁ →ₗ[R] X₂) → (g : X₂ →ₗ[R] X₃) → g ∘ₗ f = 0 → CategoryTheory.ShortComplex (ModuleCat R)", "name": "CategoryTheory.ShortComplex.moduleCatMk", "isProp": false, "docString": "Constructor for short complexes in `ModuleCat.{v} R` taking as inputs\nlinear maps `f` and `g` and the vanishing of their composition. ", "terms": "[\n    \"Constructor\",\n    \"Short complexes\",\n    \"ModuleCat.{v} R\",\n    \"Inputs\",\n    \"Linear maps\",\n    \"Composition\",\n    \"Vanishing\"\n]"}
{"type": "(X : AlgebraicGeometry.Scheme) →\n  {U : TopologicalSpace.Opens ↑↑X.toPresheafedSpace} →\n    ↑(X.presheaf.obj (Opposite.op U)) → TopologicalSpace.Opens ↑↑X.toPresheafedSpace", "name": "AlgebraicGeometry.Scheme.basicOpen", "isProp": false, "docString": "The subset of the underlying space where the given section does not vanish. ", "terms": "[\n  \"subset\",\n  \"underlying space\",\n  \"section\",\n  \"vanish\"\n]"}
{"type": "{J : Type w} →\n  {C : Type uC} →\n    [inst : CategoryTheory.Category.{uC', uC} C] →\n      [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n        {F : J → C} →\n          CategoryTheory.Functor (CategoryTheory.Limits.Bicone F)\n            (CategoryTheory.Limits.Cone (CategoryTheory.Discrete.functor F))", "name": "CategoryTheory.Limits.Bicone.toConeFunctor", "isProp": false, "docString": "Extract the cone from a bicone. ", "terms": "[\"cone\", \"bicone\"]"}
{"type": "{R : Type u_1} → [inst : CommRing R] → Polynomial R → Set (PrimeSpectrum R)", "name": "AlgebraicGeometry.Polynomial.imageOfDf", "isProp": false, "docString": "Given a polynomial `f ∈ R[x]`, `imageOfDf` is the subset of `Spec R` where at least one\nof the coefficients of `f` does not vanish.  Lemma `imageOfDf_eq_comap_C_compl_zeroLocus`\nproves that `imageOfDf` is the image of `(zeroLocus {f})ᶜ` under the morphism\n`comap C : Spec R[x] → Spec R`. ", "terms": "[\n    \"polynomial\",\n    \"subset\",\n    \"coefficients\",\n    \"vanish\",\n    \"lemma\",\n    \"image\",\n    \"zeroLocus\",\n    \"morphism\",\n    \"comap\"\n]"}
{"type": "∀ {m : Type u_1} {R : Type u_3} [inst : Fintype m] [inst_1 : DecidableEq m] [inst_2 : CommSemiring R]\n  (A : Matrix m m R), (RingHom.mapMatrix (MvPolynomial.eval fun p => A p.1 p.2)) (Matrix.mvPolynomialX m m R) = A", "name": "Matrix.mvPolynomialX_mapMatrix_eval", "isProp": true, "docString": "A variant of `Matrix.mvPolynomialX_map_eval₂` with a bundled `RingHom` on the LHS. ", "terms": "[\n  \"variant\",\n  \"Matrix\",\n  \"mvPolynomialX_map_eval₂\",\n  \"bundled\",\n  \"RingHom\",\n  \"LHS\"\n]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {p1 p2 p3 : P},\n  EuclideanGeometry.angle p1 p2 p3 = EuclideanGeometry.angle p1 p3 p2 →\n    EuclideanGeometry.angle p2 p1 p3 ≠ Real.pi → dist p1 p2 = dist p1 p3", "name": "EuclideanGeometry.dist_eq_of_angle_eq_angle_of_angle_ne_pi", "isProp": true, "docString": "Converse of pons asinorum, angle-at-point form. ", "terms": "[\n    \"Converse\",\n    \"Pons Asinorum\",\n    \"Angle-at-Point Form\"\n]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C], CategoryTheory.Faithful CategoryTheory.yoneda", "name": "CategoryTheory.Yoneda.yoneda_faithful", "isProp": true, "docString": "The Yoneda embedding is faithful.\n\nSee <https://stacks.math.columbia.edu/tag/001P>.\n", "terms": "[\"Yoneda embedding\", \"faithful\"]"}
{"type": "{α : Type u_1} → [inst : DecidableEq α] → Multiset α → Finset (α × ℕ)", "name": "Multiset.toEnumFinset", "isProp": false, "docString": "Construct a finset whose elements enumerate the elements of the multiset `m`.\nThe `ℕ` component is used to differentiate between equal elements: if `x` appears `n` times\nthen `(x, 0)`, ..., and `(x, n-1)` appear in the `Finset`. ", "terms": "[\n  \"construct\",\n  \"finset\",\n  \"enumerate\",\n  \"elements\",\n  \"multiset\",\n  \"component\",\n  \"differentiate\",\n  \"equal\",\n  \"times\",\n  \"appear\",\n  \"Finset\"\n]"}
{"type": "∀ {X Y : AlgebraicGeometry.LocallyRingedSpace} (self : AlgebraicGeometry.LocallyRingedSpace.Hom X Y)\n  (x : ↑↑X.toPresheafedSpace), IsLocalRingHom (AlgebraicGeometry.PresheafedSpace.stalkMap self.val x)", "name": "AlgebraicGeometry.LocallyRingedSpace.Hom.prop", "isProp": true, "docString": "the underlying morphism induces a local ring homomorphism on stalks ", "terms": "[\n    \"underlying\",\n    \"morphism\",\n    \"induces\",\n    \"local\",\n    \"ring\",\n    \"homomorphism\",\n    \"stalks\"\n]"}
{"type": "∀ {obj : Type u} [self : CategoryTheory.Groupoid obj] {X Y : obj} (f : X ⟶ Y),\n  CategoryTheory.CategoryStruct.comp f (CategoryTheory.Groupoid.inv f) = CategoryTheory.CategoryStruct.id X", "name": "CategoryTheory.Groupoid.comp_inv", "isProp": true, "docString": "`f` composed with `inv f` is the identity ", "terms": "[\n    \"composed\",\n    \"inv\",\n    \"identity\"\n]"}
{"type": "{M : Type u_1} →\n  {A : Type u_4} →\n    {B : Type u_5} →\n      [inst : AddZeroClass A] →\n        [inst_1 : DistribSMul M A] →\n          [inst_2 : AddZeroClass B] →\n            [inst_3 : SMul M B] →\n              (f : A →+ B) → Function.Surjective ⇑f → (∀ (c : M) (x : A), f (c • x) = c • f x) → DistribSMul M B", "name": "Function.Surjective.distribSMul", "isProp": false, "docString": "Pushforward a distributive scalar multiplication along a surjective additive monoid\nhomomorphism.\nSee note [reducible non-instances]. ", "terms": "[\n\"Pushforward\",\n\"Distributive\",\n\"Scalar multiplication\",\n\"Surjective\",\n\"Additive monoid\",\n\"Homomorphism\",\n\"Reducible\",\n\"Non-instances\"\n]"}
{"type": "{α : Type u_2} → [inst : TopologicalSpace α] → TopologicalSpace.Opens α → Set α", "name": "TopologicalSpace.Opens.Simps.coe", "isProp": false, "docString": "See Note [custom simps projection]. ", "terms": "The provided statement does not contain any mathematical term. So, the JSON list would be an empty list.\n\n[]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        (F : CategoryTheory.Functor C D) →\n          [inst_2 : CategoryTheory.CreatesLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F] →\n            [inst_3 : CategoryTheory.Limits.HasLimitsOfSize.{w, w', v₂, u₂} D] →\n              CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F", "name": "CategoryTheory.preservesLimitsOfCreatesLimitsAndHasLimits", "isProp": false, "docString": "`F` preserves limits if it creates limits and `D` has limits. ", "terms": "[\n  \"preserves\",\n  \"limits\",\n  \"creates\",\n  \"has\"\n]"}
{"type": "{α : Type u_2} → [inst : AddZeroClass α] → α →+ Set α", "name": "Set.singletonAddMonoidHom", "isProp": false, "docString": "The singleton operation as an `AddMonoidHom`.", "terms": "[\n    \"singleton operation\",\n    \"AddMonoidHom\"\n]"}
{"type": "∀ {E : Type u_4} {F : Type u_5} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n  [inst_2 : FiniteDimensional ℝ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ℝ F] {f : E → F} {s t : Set E},\n  ContDiffOn ℝ 1 f s → Convex ℝ s → t ⊆ s → dimH (f '' t) ≤ dimH t", "name": "ContDiffOn.dimH_image_le", "isProp": true, "docString": "Let `f` be a function defined on a finite dimensional real normed space. If `f` is `C¹`-smooth\non a convex set `s`, then the Hausdorff dimension of `f '' s` is less than or equal to the Hausdorff\ndimension of `s`.\n\nTODO: do we actually need `Convex ℝ s`? ", "terms": "[\n    \"function\",\n    \"defined\",\n    \"finite dimensional\",\n    \"real normed space\",\n    \"C¹-smooth\",\n    \"convex set\",\n    \"Hausdorff dimension\",\n    \"less than or equal to\"\n]"}
{"type": "{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : CommRing R] →\n      [inst_1 : AddCommGroup M] → [inst_2 : Module R M] → {x : M} → {f : Module.Dual R M} → f x = 2 → M ≃ₗ[R] M", "name": "Module.reflection", "isProp": false, "docString": "Given an element `x` in a module `M` and a linear form `f` on `M` for which `f x = 2`, we define\nthe endomorphism of `M` for which `y ↦ y - (f y) • x`.\n\nIt is an involutive endomorphism of `M` fixing the kernel of `f` for which `x ↦ -x`. ", "terms": "[\n    \"element\",\n    \"module\",\n    \"linear form\",\n    \"endomorphism\",\n    \"involutive endomorphism\",\n    \"kernel\"\n]"}
{"type": "{α : Type u_1} → List (Lists α) → Lists' α true", "name": "Lists'.ofList", "isProp": false, "docString": "Converts a `List` of ZFA lists to a proper ZFA prelist. ", "terms": "[\n    \"List\",\n    \"ZFA lists\",\n    \"proper\",\n    \"ZFA prelist\"\n]"}
{"type": "{α : Type u_1} →\n  [inst : NormedField α] →\n    {E : Type u_5} →\n      [inst_1 : SeminormedAddCommGroup E] →\n        [inst_2 : NormedSpace α E] →\n          {F : Type u_6} → [inst_3 : SeminormedAddCommGroup F] → [inst_4 : NormedSpace α F] → NormedSpace α (E × F)", "name": "Prod.normedSpace", "isProp": false, "docString": "The product of two normed spaces is a normed space, with the sup norm. ", "terms": "[\n    \"Product\",\n    \"Normed Spaces\",\n    \"Sup Norm\"\n]"}
{"type": "{α : Type u_1} → Array α → Array (α × ℕ)", "name": "Array.zipWithIndex", "isProp": false, "docString": "Turns `#[a, b]` into `#[(a, 0), (b, 1)]`. ", "terms": "[]\n"}
{"type": "(σ : Type u_1) → (R : Type u_2) → (p : ℕ) → [inst : CommSemiring R] → [inst_1 : Invertible ↑p] → Invertible ↑p", "name": "MvPolynomial.invertibleCoeNat", "isProp": false, "docString": "A natural number that is invertible when coerced to a commutative semiring `R`\nis also invertible when coerced to any polynomial ring with rational coefficients.\n\nShort-cut for typeclass resolution. ", "terms": "[\n    \"Natural number\",\n    \"Invertible\",\n    \"Coerced\",\n    \"Commutative semiring\",\n    \"Polynomial ring\",\n    \"Rational coefficients\",\n    \"Typeclass resolution\"\n]"}
{"type": "(n : ℕ) → InvolutiveNeg (Fin n)", "name": "Fin.instInvolutiveNeg", "isProp": false, "docString": "Note this is more general than `Fin.addCommGroup` as it applies (vacuously) to `Fin 0` too. ", "terms": "[\"more general\", \"Fin.addCommGroup\", \"applies\", \"vacuously\", \"Fin 0\"]"}
{"type": "{α : Sort u} → {β : Sort v} → [self : CoeHTC α β] → α → β", "name": "CoeHTC.coe", "isProp": false, "docString": "Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. ", "terms": "[\"Coerces\", \"value\", \"type\", \"Accessible\", \"notation\", \"double type\", \"ascription\"]"}
{"type": "{M : Type u_1} →\n  {A : Type u_5} → [inst : Mul M] → [inst_1 : SetLike A M] → [hA : MulMemClass A M] → (S' : A) → ↥S' →ₙ* M", "name": "MulMemClass.subtype", "isProp": false, "docString": "The natural semigroup hom from a subsemigroup of semigroup `M` to `M`. ", "terms": "[\n    \"natural\",\n    \"semigroup\",\n    \"hom\",\n    \"subsemigroup\"\n]"}
{"type": "{J : Type v} →\n  [inst : CategoryTheory.SmallCategory J] →\n    [inst_1 : CategoryTheory.IsFiltered J] → CategoryTheory.Functor J AddGroupCat → AddGroupCat", "name": "AddGroupCat.FilteredColimits.colimit", "isProp": false, "docString": "The bundled additive group giving the filtered colimit of a diagram.", "terms": "[\n    \"Bundled\",\n    \"Additive Group\",\n    \"Filtered Colimit\",\n    \"Diagram\"\n]"}
{"type": "∀ (F : Type u) (E : Type v) [inst : Field F] [inst_1 : Field E] [inst_2 : Algebra F E] (K : Type w) [inst_3 : Field K]\n  [inst_4 : Algebra F K] [inst_5 : Algebra E K] [inst_6 : IsScalarTower F E K],\n  Algebra.IsAlgebraic E K →\n    Cardinal.lift.{w, v} (Field.sepDegree F E) * Cardinal.lift.{v, w} (Field.sepDegree E K) =\n      Cardinal.lift.{v, w} (Field.sepDegree F K)", "name": "Field.lift_sepDegree_mul_lift_sepDegree_of_isAlgebraic", "isProp": true, "docString": "If `K / E / F` is a field extension tower, such that `K / E` is algebraic, then\n$[E:F]_s [K:E]_s = [K:F]_s$. See also `lift_rank_mul_lift_rank`. ", "terms": "[\n    \"field extension tower\",\n    \"algebraic\",\n    \"lift_rank_mul_lift_rank\"\n]"}
{"type": "∀ {α : Type u_1} [inst : TopologicalSpace α] {x : α} {γ : Type u_4} [inst_1 : LinearOrderedAddCommMonoid γ]\n  [inst_2 : TopologicalSpace γ] [inst_3 : OrderTopology γ] {f g : α → γ},\n  LowerSemicontinuousAt f x →\n    LowerSemicontinuousAt g x →\n      ContinuousAt (fun p => p.1 + p.2) (f x, g x) → LowerSemicontinuousAt (fun z => f z + g z) x", "name": "LowerSemicontinuousAt.add'", "isProp": true, "docString": "The sum of two lower semicontinuous functions is lower semicontinuous. Formulated with an\nexplicit continuity assumption on addition, for application to `EReal`. The unprimed version of\nthe lemma uses `[ContinuousAdd]`. ", "terms": "[\n    \"sum\",\n    \"lower semicontinuous functions\",\n    \"lower semicontinuous\",\n    \"continuity\",\n    \"addition\",\n    \"EReal\",\n    \"lemma\",\n    \"ContinuousAdd\"\n]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] →\n      (S : CategoryTheory.ShortComplex.SnakeInput C) →\n        CategoryTheory.ShortComplex.SnakeInput.P' S ≅\n          (CategoryTheory.ShortComplex.SnakeInput.P (CategoryTheory.ShortComplex.SnakeInput.op S)).unop", "name": "CategoryTheory.ShortComplex.SnakeInput.P'IsoUnopOpP", "isProp": false, "docString": "The duality isomorphism `S.P' ≅ Opposite.unop S.op.P`. ", "terms": "[\n  \"duality\",\n  \"isomorphism\",\n  \"Opposite.unop\",\n  \"S.op.P\"\n]"}
{"type": "{ι : Type u_1} → (A : ι → Type u_2) → [inst : AddMonoid ι] → [inst_1 : GradedMonoid.GMonoid A] → Monoid (A 0)", "name": "GradedMonoid.GradeZero.monoid", "isProp": false, "docString": "The `Monoid` structure derived from `GMonoid A`. ", "terms": "[\n  \"Monoid\",\n  \"structure\",\n  \"derived\",\n  \"GMonoid\"\n]"}
{"type": "∀ {s : Set ℝ}, Bornology.IsBounded s → EMetric.diam s = ENNReal.ofReal (sSup s - sInf s)", "name": "Real.ediam_eq", "isProp": true, "docString": "For a bounded set `s : Set ℝ`, its `EMetric.diam` is equal to `sSup s - sInf s` reinterpreted as\n`ℝ≥0∞`. ", "terms": "[\n    \"bounded set\",\n    \"Set\",\n    \"ℝ\",\n    \"EMetric.diam\",\n    \"equal\",\n    \"sSup\",\n    \"sInf\",\n    \"reinterpreted\",\n    \"ℝ≥0∞\"\n]"}
{"type": "∀ {R : Type u_1} {E : Type u_3} {ι : Type u_5} [inst : LinearOrderedField R] [inst_1 : AddCommGroup E]\n  [inst_2 : Module R E] (s : Finset ι),\n  Finset.Nonempty s → ∀ (p : ι → E), Finset.centroid R s p = Finset.centerMass s (Finset.centroidWeights R s) p", "name": "Finset.centroid_eq_centerMass", "isProp": true, "docString": "The centroid can be regarded as a center of mass. ", "terms": "[\"centroid\", \"center of mass\"]"}
{"type": "∀ {G : Type u_1} [inst : Group G], Group.IsNilpotent (G ⧸ Subgroup.center G) → Group.IsNilpotent G", "name": "of_quotient_center_nilpotent", "isProp": true, "docString": "If the quotient by `center G` is nilpotent, then so is G. ", "terms": "[\"quotient\", \"center\", \"nilpotent\", \"G\"]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {P : CategoryTheory.Functor Cᵒᵖ (Type w)} {X : C}\n  {R : CategoryTheory.Presieve X}\n  {x : CategoryTheory.Presieve.FamilyOfElements P (CategoryTheory.Sieve.generate R).arrows},\n  CategoryTheory.Presieve.FamilyOfElements.Compatible x →\n    CategoryTheory.Presieve.FamilyOfElements.sieveExtend\n        (CategoryTheory.Presieve.FamilyOfElements.restrict (_ : R ≤ (CategoryTheory.Sieve.generate R).arrows) x) =\n      x", "name": "CategoryTheory.Presieve.extend_restrict", "isProp": true, "docString": "Given a family of elements `x` for the sieve `S` generated by a presieve `R`, if `x` is restricted\nto `R` and then extended back up to `S`, the resulting extension equals `x`.\n", "terms": "[\n    \"family of elements\",\n    \"sieve\",\n    \"generated\",\n    \"presieve\",\n    \"restricted\",\n    \"extended\",\n    \"resulting extension\",\n    \"equals\"\n]"}
{"type": "Lean.ParserDescr", "name": "Class.«term⋃₀_»", "isProp": false, "docString": "The union of a class is the class of all members of ZFC sets in the class ", "terms": "[\n  \"union\",\n  \"class\",\n  \"members\",\n  \"ZFC sets\"\n]"}
{"type": "∀ {x : ℝ}, x ≠ 0 → ∀ {r : ℂ}, r ≠ -1 → HasDerivAt (fun y => ↑y ^ (r + 1) / (r + 1)) (↑x ^ r) x", "name": "hasDerivAt_ofReal_cpow", "isProp": true, "docString": "Although `fun x => x ^ r` for fixed `r` is *not* complex-differentiable along the negative real\nline, it is still real-differentiable, and the derivative is what one would formally expect. ", "terms": "[\n  \"complex-differentiable\",\n  \"negative real line\",\n  \"real-differentiable\",\n  \"derivative\"\n]"}
{"type": "∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (r : k) (p₁ p₂ : P), r • (p₁ -ᵥ p₂) +ᵥ p₂ ∈ affineSpan k {p₁, p₂}", "name": "smul_vsub_rev_vadd_mem_affineSpan_pair", "isProp": true, "docString": "A multiple of the difference of two points added to the second point lies in their affine\nspan. ", "terms": "[\n    \"multiple\",\n    \"difference\",\n    \"points\",\n    \"added\",\n    \"second point\",\n    \"lies\",\n    \"affine span\"\n]"}
{"type": "FirstOrder.Language → Type u", "name": "FirstOrder.Language.Constants", "isProp": false, "docString": "The type of constants in a given language. ", "terms": "[\"type\", \"constants\", \"language\"]"}
{"type": "∀ {α : Type u_1} [inst : CircularPreorder α] {a b c d : α}, sbtw a b c → sbtw a c d → sbtw a b d", "name": "SBtw.sbtw.trans_right", "isProp": true, "docString": "**Alias** of `sbtw_trans_right`.", "terms": "[]\n"}
{"type": "{α : Type u_1} →\n  {β : Type u_2} → {M : Type u_5} → [inst : AddZeroClass M] → {f : α → β} → Function.Injective f → (β →₀ M) →+ α →₀ M", "name": "Finsupp.comapDomain.addMonoidHom", "isProp": false, "docString": "`Finsupp.comapDomain` is an `AddMonoidHom`. ", "terms": "[\n    \"Finsupp.comapDomain\",\n    \"AddMonoidHom\"\n]"}
{"type": "(R : Type u_1) → [inst : StrictOrderedSemiring R] → Submonoid R", "name": "posSubmonoid", "isProp": false, "docString": "Submonoid of positive elements of an ordered semiring. ", "terms": "[\n    \"Submonoid\",\n    \"Positive elements\",\n    \"Ordered semiring\"\n]"}
{"type": "{R : Type u_1} → [inst : CommRing R] → (Nat.ArithmeticFunction R)ˣ", "name": "Nat.ArithmeticFunction.zetaUnit", "isProp": false, "docString": "A unit in `ArithmeticFunction R` that evaluates to `ζ`, with inverse `μ`. ", "terms": "[\n  \"ArithmeticFunction\",\n  \"unit\",\n  \"evaluates\",\n  \"inverse\"\n]"}
{"type": "(ι : Type u_1) → {R : Type u_2} → [inst : AddMonoid ι] → [inst_1 : Semiring R] → DirectSum.GSemiring fun x => R", "name": "Semiring.directSumGSemiring", "isProp": false, "docString": "A direct sum of copies of a `Semiring` inherits the multiplication structure. ", "terms": "[\n    \"Direct sum\",\n    \"Copies\",\n    \"Semiring\",\n    \"Inherits\",\n    \"Multiplication structure\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} {f : α → β} [inst : TopologicalSpace β] [inst_1 : Zero β] {m0 : MeasurableSpace α},\n  MeasureTheory.StronglyMeasurable f →\n    ∀ (μ : MeasureTheory.Measure α) [inst_2 : MeasureTheory.SigmaFinite μ], MeasureTheory.FinStronglyMeasurable f μ", "name": "MeasureTheory.StronglyMeasurable.finStronglyMeasurable", "isProp": true, "docString": "If the measure is sigma-finite, all strongly measurable functions are\n`FinStronglyMeasurable`. ", "terms": "[\n  \"measure\",\n  \"sigma-finite\",\n  \"strongly measurable functions\",\n  \"FinStronglyMeasurable\"\n]"}
{"type": "{ι : Type u_1} →\n  {α : ι → Type u_2} →\n    [inst : (i : ι) → Zero (α i)] →\n      [inst_1 : LinearOrder ι] → [inst_2 : (i : ι) → LinearOrder (α i)] → LinearOrder (Lex (Π₀ (i : ι), α i))", "name": "DFinsupp.Lex.linearOrder", "isProp": false, "docString": "The linear order on `DFinsupp`s obtained by the lexicographic ordering. ", "terms": "[\n    \"linear order\",\n    \"DFinsupp\",\n    \"lexicographic ordering\"\n]"}
{"type": "Bool → Option Mathlib.Explode.Entry → List (Option ℕ) → List (Option ℕ)", "name": "Mathlib.Explode.explodeCore.consDep", "isProp": false, "docString": "Prepend the `line` of the `Entry` to `deps` if it's not `none`, but if the entry isn't marked\nwith `useAsDep` then it's not added to the list at all. ", "terms": "[]"}
{"type": "{α : Type u_1} → {β : Type u_2} → Functor.Const α β → α", "name": "Functor.Const.run", "isProp": false, "docString": "Extract the element of `α` from the `Const` functor. ", "terms": "[\n    \"element\",\n    \"functor\",\n    \"Const\"\n]"}
{"type": "{R : Type u} →\n  {A : Type v} →\n    [inst : CommSemiring R] →\n      [inst_1 : StarRing R] →\n        [inst_2 : Semiring A] →\n          [inst_3 : StarRing A] →\n            [inst_4 : Algebra R A] → [inst_5 : StarModule R A] → StarSubalgebra R A → Subalgebra R A", "name": "StarSubalgebra.toSubalgebra", "isProp": false, "docString": "Forgetting that a *-subalgebra is closed under *.\n", "terms": "[\n    \"*-subalgebra\",\n    \"closed\",\n    \"*\"\n]"}
{"type": "∀ {β : Type v} {γ : Type w} [inst : EMetricSpace γ] [inst_1 : EMetricSpace β] {f : γ → β},\n  UniformEmbedding f ↔\n    (∀ ε > 0, ∃ δ > 0, ∀ {a b : γ}, edist a b < δ → edist (f a) (f b) < ε) ∧\n      ∀ δ > 0, ∃ ε > 0, ∀ {a b : γ}, edist (f a) (f b) < ε → edist a b < δ", "name": "EMetric.uniformEmbedding_iff'", "isProp": true, "docString": "A map between emetric spaces is a uniform embedding if and only if the edistance between `f x`\nand `f y` is controlled in terms of the distance between `x` and `y` and conversely. ", "terms": "[\n    \"map\",\n    \"emetric spaces\",\n    \"uniform embedding\",\n    \"edistance\",\n    \"distance\"\n]"}
{"type": "∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] (x : 𝕜) {𝕜' : Type u_1} [inst_1 : NontriviallyNormedField 𝕜']\n  [inst_2 : NormedAlgebra 𝕜 𝕜'] {h : 𝕜 → 𝕜'} {h₂ : 𝕜' → 𝕜'} {h' h₂' : 𝕜'},\n  HasDerivAt h₂ h₂' (h x) → HasDerivAt h h' x → HasDerivAt (h₂ ∘ h) (h₂' * h') x", "name": "HasDerivAt.comp", "isProp": true, "docString": "The chain rule. ", "terms": "[\"chain rule\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      {σ τ : Type} →\n        [inst_2 : Fintype τ] →\n          {S : σ → C} →\n            [inst_3 : CategoryTheory.Limits.HasBiproduct S] →\n              {T : τ → C} →\n                [inst_4 : CategoryTheory.Limits.HasBiproduct T] →\n                  (s : σ) →\n                    CategoryTheory.CategoryStruct.id (S s) ≠ 0 →\n                      (f : ⨁ S ⟶ ⨁ T) →\n                        [inst_5 : CategoryTheory.IsIso f] →\n                          Trunc\n                            ((t : τ) ×'\n                              CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι S s)\n                                  (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.biproduct.π T t)) ≠\n                                0)", "name": "CategoryTheory.Biproduct.columnNonzeroOfIso", "isProp": false, "docString": "If `f : ⨁ S ⟶ ⨁ T` is an isomorphism, and `s` is a non-trivial summand of the source,\nthen there is some `t` in the target so that the `s, t` matrix entry of `f` is nonzero.\n", "terms": "[\n  \"Isomorphism\",\n  \"Summand\",\n  \"Source\",\n  \"Target\",\n  \"Matrix entry\",\n  \"Nonzero\"\n]"}
{"type": "{C₁ : Type u_1} →\n  {C₂ : Type u_2} →\n    {C₃ : Type u_3} →\n      {C₄ : Type u_4} →\n        [inst : CategoryTheory.Category.{u_7, u_1} C₁] →\n          [inst_1 : CategoryTheory.Category.{u_8, u_2} C₂] →\n            [inst_2 : CategoryTheory.Category.{u_9, u_3} C₃] →\n              [inst_3 : CategoryTheory.Category.{u_10, u_4} C₄] →\n                (T : C₁ ≌ C₂) →\n                  (L : CategoryTheory.Functor C₁ C₃) →\n                    (R : CategoryTheory.Functor C₂ C₄) →\n                      (B : C₃ ≌ C₄) →\n                        CategoryTheory.CatCommSq T.functor L R B.functor →\n                          CategoryTheory.CatCommSq T.inverse R L B.inverse", "name": "CategoryTheory.CatCommSq.hInv", "isProp": false, "docString": "Horizontal inverse of a 2-commutative square ", "terms": "[\n    \"Horizontal inverse\",\n    \"2-commutative square\"\n]"}
{"type": "∀ {J : Type w} {C : Type uC} [inst : CategoryTheory.Category.{uC', uC} C]\n  [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {F : J → C} (self : CategoryTheory.Limits.Bicone F) (j j' : J),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Bicone.ι self j) (CategoryTheory.Limits.Bicone.π self j') =\n    if h : j = j' then CategoryTheory.eqToHom (_ : F j = F j') else 0", "name": "CategoryTheory.Limits.Bicone.ι_π", "isProp": true, "docString": "A `c : Bicone F` is:\n* an object `c.pt` and\n* morphisms `π j : pt ⟶ F j` and `ι j : F j ⟶ pt` for each `j`,\n* such that `ι j ≫ π j'` is the identity when `j = j'` and zero otherwise.\n", "terms": "[\n    \"Bicone\",\n    \"object\",\n    \"morphisms\",\n    \"identity\",\n    \"zero\"\n]"}
{"type": "∀ {z w : UpperHalfPlane},\n  UpperHalfPlane.re z = UpperHalfPlane.re w →\n    dist z w = dist (Real.log (UpperHalfPlane.im z)) (Real.log (UpperHalfPlane.im w))", "name": "UpperHalfPlane.dist_of_re_eq", "isProp": true, "docString": "For two points on the same vertical line, the distance is equal to the distance between the\nlogarithms of their imaginary parts. ", "terms": "[\n    \"points\",\n    \"vertical line\",\n    \"distance\",\n    \"equal\",\n    \"distance between\",\n    \"logarithms\",\n    \"imaginary parts\"\n]"}
{"type": "{α : Type u_1} → [inst : Preorder α] → [inst : LocallyFiniteOrderTop α] → α → Multiset α", "name": "Multiset.Ici", "isProp": false, "docString": "The multiset of elements `x` such that `a ≤ x`. Basically `Set.Ici a` as a multiset. ", "terms": "[\"multiset\", \"elements\", \"Set.Ici\", \"≤\"]"}
{"type": "∀ {α : Type u_3} [self : LinearOrderedCancelCommMonoid α] (a b : α), compare a b = compareOfLessAndEq a b", "name": "LinearOrderedCancelCommMonoid.compare_eq_compareOfLessAndEq", "isProp": true, "docString": "Comparison via `compare` is equal to the canonical comparison given decidable `<` and `=`. ", "terms": "[\"Comparison\", \"compare\", \"equal\", \"canonical comparison\", \"decidable\", \"<\", \"=\"]"}
{"type": "{M : Type u_1} →\n  {N : Type u_2} →\n    {P : Type u_5} →\n      [inst : MulOneClass M] →\n        [inst_1 : MulOneClass N] →\n          [inst_2 : MulOneClass P] →\n            (f : FreeMonoid (M ⊕ N) →* P) →\n              f (FreeMonoid.of (Sum.inl 1)) = 1 →\n                f (FreeMonoid.of (Sum.inr 1)) = 1 →\n                  (∀ (x y : M),\n                      f (FreeMonoid.of (Sum.inl (x * y))) = f (FreeMonoid.of (Sum.inl x) * FreeMonoid.of (Sum.inl y))) →\n                    (∀ (x y : N),\n                        f (FreeMonoid.of (Sum.inr (x * y))) =\n                          f (FreeMonoid.of (Sum.inr x) * FreeMonoid.of (Sum.inr y))) →\n                      Monoid.Coprod M N →* P", "name": "Monoid.Coprod.clift", "isProp": false, "docString": "Lift a monoid homomorphism `FreeMonoid (M ⊕ N) →* P` satisfying additional properties to\n`M ∗ N →* P`. In many cases, `Coprod.lift` is more convenient.\n\nCompared to `Coprod.lift`,\nthis definition allows a user to provide a custom computational behavior.\nAlso, it only needs `MulOneclass` assumptions while `Coprod.lift` needs a `Monoid` structure.\n", "terms": "[\n    \"monoid homomorphism\",\n    \"FreeMonoid\",\n    \"Coprod.lift\",\n    \"MulOneclass\",\n    \"Monoid\"\n]"}
{"type": "∀ (q : Quaternion ℝ), ‖NormedSpace.exp ℝ q‖ = ‖NormedSpace.exp ℝ q.re‖", "name": "Quaternion.norm_exp", "isProp": true, "docString": "Note that this implies that exponentials of pure imaginary quaternions are unit quaternions\nsince in that case the RHS is `1` via `exp_zero` and `norm_one`. ", "terms": "[\n    \"exponentials\",\n    \"pure imaginary\",\n    \"quaternions\",\n    \"unit quaternions\",\n    \"RHS\",\n    \"1\",\n    \"exp_zero\",\n    \"norm_one\"\n]"}
{"type": "∀ {H : Type u_5} [inst : NormedAddCommGroup H] [inst_1 : InnerProductSpace ℝ H] [inst_2 : CompleteSpace H]\n  (K : ConvexCone ℝ H), Set.Nonempty ↑K → IsClosed ↑K → ∀ {b : H}, b ∉ K → ∃ y, (∀ x ∈ K, 0 ≤ inner x y) ∧ inner y b < 0", "name": "ConvexCone.hyperplane_separation_of_nonempty_of_isClosed_of_nmem", "isProp": true, "docString": "This is a stronger version of the Hahn-Banach separation theorem for closed convex cones. This\nis also the geometric interpretation of Farkas' lemma. ", "terms": "[\n    \"Hahn-Banach separation theorem\",\n    \"closed convex cones\",\n    \"geometric interpretation\",\n    \"Farkas' lemma\"\n]"}
{"type": "Lean.ParserDescr", "name": "Real.termπ", "isProp": false, "docString": "The number π = 3.14159265... Defined here using choice as twice a zero of cos in [1,2], from\nwhich one can derive all its properties. For explicit bounds on π, see `Data.Real.Pi.Bounds`. ", "terms": "[\n    \"number\",\n    \"π\",\n    \"defined\",\n    \"choice\",\n    \"twice\",\n    \"zero\",\n    \"cos\",\n    \"[1,2]\",\n    \"derive\",\n    \"properties\",\n    \"explicit\",\n    \"bounds\",\n    \"Data.Real.Pi.Bounds\"\n]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      [inst_2 : CategoryTheory.MonoidalCategory C] →\n        [inst_3 : CategoryTheory.MonoidalPreadditive C] →\n          [inst_4 : CategoryTheory.Limits.HasFiniteBiproducts C] →\n            {J : Type} →\n              [inst_5 : Fintype J] →\n                (f : J → C) →\n                  (X : C) →\n                    CategoryTheory.MonoidalCategory.tensorObj (⨁ f) X ≅\n                      ⨁ fun j => CategoryTheory.MonoidalCategory.tensorObj (f j) X", "name": "CategoryTheory.rightDistributor", "isProp": false, "docString": "The isomorphism showing how tensor product on the right distributes over direct sums. ", "terms": "[\n  \"Isomorphism\",\n  \"Tensor Product\",\n  \"Distributes\",\n  \"Direct Sums\"\n]"}
{"type": "∀ {α : Type u_1} [inst : LinearOrderedSemifield α] [inst_1 : Archimedean α] [inst_2 : ExistsAddOfLE α] {x y : α},\n  0 < x → y < 1 → ∃ n, y ^ n < x", "name": "exists_pow_lt_of_lt_one", "isProp": true, "docString": "For any `y < 1` and any positive `x`, there exists `n : ℕ` with `y ^ n < x`. ", "terms": "[\n    \"any\",\n    \"less than\",\n    \"positive\",\n    \"there exists\",\n    \"natural number\",\n    \"with\",\n    \"power of\",\n    \"less than\"\n]"}
{"type": "(X : CondensedSet) → CategoryTheory.Limits.PreservesFiniteProducts X.val", "name": "CondensedSet.instPreservesFiniteProductsOppositeCompHausOppositeCategoryTypeTypesValCoherentTopologyProof_1", "isProp": false, "docString": "A condensed set preserves finite products. ", "terms": "[\n    \"condensed set\", \n    \"preserves\", \n    \"finite products\"\n]"}
{"type": "(M : Type u_9) → [inst : One M] → OneHom M M", "name": "OneHom.id", "isProp": false, "docString": "The identity map from a type with 1 to itself. ", "terms": "[\n  \"identity map\",\n  \"type\",\n  \"1\",\n  \"itself\"\n]"}
{"type": "∀ {τ : Type u_1} {α : Type u_2} [inst : CanonicallyOrderedAddCommMonoid τ] {ϕ : τ → α → α} {s : Set α},\n  IsFwInvariant ϕ s → IsInvariant ϕ s", "name": "IsFwInvariant.isInvariant", "isProp": true, "docString": "If `τ` is a `CanonicallyOrderedAddCommMonoid` (e.g., `ℕ` or `ℝ≥0`), then the notions\n`IsFwInvariant` and `IsInvariant` are equivalent. ", "terms": "[\n    \"CanonicallyOrderedAddCommMonoid\", \n    \"ℕ\", \n    \"ℝ≥0\", \n    \"IsFwInvariant\", \n    \"IsInvariant\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → ∀ (a : α), f a⁻¹ = (f a)⁻¹", "name": "IsGroupHom.map_inv", "isProp": true, "docString": "A group homomorphism sends inverses to inverses. ", "terms": "[\n  \"group\",\n  \"homomorphism\",\n  \"sends\",\n  \"inverses\"\n]"}
{"type": "∀ {α ι : Type u} {a : Cardinal.{u}} [inst : Countable ι] {f : ι → Set α} {l : Filter ι} [inst : Filter.NeBot l]\n  {t : Set α}, (∀ x ∈ t, ∀ᶠ (i : ι) in l, x ∈ f i) → (∀ (i : ι), Cardinal.mk ↑(f i) ≤ a) → Cardinal.mk ↑t ≤ a", "name": "Cardinal.mk_subtype_le_of_countable_eventually_mem_aux", "isProp": true, "docString": "If a set `t` is eventually covered by a countable family of sets, all with cardinality at\nmost `a`, then the cardinality of `t` is also bounded by `a`.\nSupersed by `mk_le_of_countable_eventually_mem` which does not assume\nthat the indexing set lives in the same universe. ", "terms": "[\n    \"set\",\n    \"eventually covered\",\n    \"countable\",\n    \"family of sets\",\n    \"cardinality\",\n    \"bounded\",\n    \"indexing set\",\n    \"universe\"\n]"}
{"type": "∀ {C : Type u_1} {ι : Type u_2} [inst : CategoryTheory.Category.{u_3, u_1} C] [inst_1 : CategoryTheory.Abelian C]\n  {c : ComplexShape ι} {S : CategoryTheory.ShortComplex (HomologicalComplex C c)}\n  (hS : CategoryTheory.ShortComplex.ShortExact S) (i j : ι) (hij : ComplexShape.Rel c i j),\n  CategoryTheory.ShortComplex.Exact\n    (CategoryTheory.ShortComplex.mk (CategoryTheory.ShortComplex.ShortExact.δ hS i j hij)\n      (HomologicalComplex.homologyMap S.f j)\n      (_ :\n        CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.ShortExact.δ hS i j hij)\n            (HomologicalComplex.homologyMap S.f j) =\n          0))", "name": "CategoryTheory.ShortComplex.ShortExact.homology_exact₁", "isProp": true, "docString": "Exactness of `S.X₃.homology i ⟶ S.X₁.homology j ⟶ S.X₂.homology j`. ", "terms": "[\n    \"Exactness\",\n    \"Homology\"\n]"}
{"type": "{R : Type u_1} →\n  (K : Type u_2) →\n    [inst : CommRing R] →\n      [inst_1 : Field K] →\n        [inst_2 : Algebra R K] →\n          [inst_3 : IsFractionRing R K] →\n            [inst_4 : IsDomain R] →\n              ClassGroup R ≃* (FractionalIdeal (nonZeroDivisors R) K)ˣ ⧸ MonoidHom.range (toPrincipalIdeal R K)", "name": "ClassGroup.equiv", "isProp": false, "docString": "The definition of the class group does not depend on the choice of field of fractions. ", "terms": "[\n  \"definition\",\n  \"class group\",\n  \"depend\",\n  \"choice\",\n  \"field of fractions\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      [inst_2 : CategoryTheory.HasShift C ℤ] →\n        CategoryTheory.Pretriangulated.Triangle C → CategoryTheory.Pretriangulated.Triangle C", "name": "CategoryTheory.Pretriangulated.Triangle.invRotate", "isProp": false, "docString": "Given a triangle of the form:\n```\n      f       g       h\n  X  ───> Y  ───> Z  ───> X⟦1⟧\n```\napplying `invRotate` gives a triangle that can be thought of as:\n```\n        -h⟦-1⟧'     f       g\n  Z⟦-1⟧  ───>  X  ───> Y  ───> Z\n```\n(note that this diagram doesn't technically fit the definition of triangle, as `Z⟦-1⟧⟦1⟧` is\nnot necessarily equal to `Z`, but it is isomorphic, by the `counitIso` of `shiftEquiv C 1`)\n", "terms": "[\n  \"triangle\",\n  \"invRotate\",\n  \"isomorphic\",\n  \"counitIso\",\n  \"shiftEquiv\"\n]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  (t : Affine.Triangle ℝ P) {i₁ i₂ i₃ : Fin 3},\n  i₁ ≠ i₂ →\n    i₁ ≠ i₃ →\n      i₂ ≠ i₃ →\n        dist (Affine.Simplex.points t i₁) (Affine.Simplex.points t i₃) /\n            |Real.Angle.sin\n                (EuclideanGeometry.oangle (Affine.Simplex.points t i₁) (Affine.Simplex.points t i₂)\n                  (Affine.Simplex.points t i₃))| =\n          2 * Affine.Simplex.circumradius t", "name": "Affine.Triangle.dist_div_sin_oangle_eq_two_mul_circumradius", "isProp": true, "docString": "Twice the circumradius of a triangle may be expressed explicitly as the length of a side\ndivided by the absolute value of the sine of the angle at the third point (a version of the law\nof sines or sine rule). ", "terms": "[\n  \"Twice\",\n  \"Circumradius\",\n  \"Triangle\",\n  \"Expressed\",\n  \"Explicitly\",\n  \"Length\",\n  \"Side\",\n  \"Divided\",\n  \"Absolute Value\",\n  \"Sine\",\n  \"Angle\",\n  \"Third Point\",\n  \"Law of Sines\",\n  \"Sine Rule\"\n]"}
{"type": "∀ {R : Type u_1} [inst : Mul R] [inst_1 : IsCancelMul R] (g : R), IsRegular g", "name": "IsRegular.all", "isProp": true, "docString": "If all multiplications cancel then every element is regular. ", "terms": "[\n  \"multiplication\",\n  \"cancel\",\n  \"element\",\n  \"regular\"\n]"}
{"type": "(R : Type u_2) → [inst : MonoidWithZero R] → (M : Type u_3) → [inst_1 : Zero M] → [inst_2 : MulAction R M] → Submonoid R", "name": "nonZeroSMulDivisors", "isProp": false, "docString": "Let `R` be a monoid with zero and `M` an additive monoid with an `R`-action, then the collection\nof non-zero smul-divisors forms a submonoid. These elements are also called `M`-regular.", "terms": "[\n    \"monoid\",\n    \"zero\",\n    \"additive monoid\",\n    \"action\",\n    \"collection\",\n    \"non-zero\",\n    \"smul-divisors\",\n    \"submonoid\",\n    \"elements\",\n    \"regular\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] → {P : C} → CategoryTheory.Limits.IsTerminal P → (⊤_ C ≅ P)", "name": "CategoryTheory.Limits.terminalIsoIsTerminal", "isProp": false, "docString": "The (unique) isomorphism between the chosen terminal object and any other terminal object. ", "terms": "[\"isomorphism\", \"terminal object\"]"}
{"type": "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {G : Type uG}\n  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace 𝕜 G] {x : E} {n : ℕ∞} {s : Set E} {f : E → F} {g : E → G},\n  ContDiffWithinAt 𝕜 n f s x → ContDiffWithinAt 𝕜 n g s x → ContDiffWithinAt 𝕜 n (fun x => (f x, g x)) s x", "name": "ContDiffWithinAt.prod", "isProp": true, "docString": "The cartesian product of `C^n` functions at a point in a domain is `C^n`. ", "terms": "[\n  \"Cartesian product\",\n  \"Functions\",\n  \"Point\",\n  \"Domain\"\n]"}
{"type": "{R : Type u} → [inst : Semiring R] → R → Polynomial R → R", "name": "Polynomial.eval", "isProp": false, "docString": "`eval x p` is the evaluation of the polynomial `p` at `x` ", "terms": "[\"evaluation\", \"polynomial\"]"}
{"type": "{A : Type u_1} →\n  {B : Type u_2} →\n    {α : Type u_3} →\n      [inst : Zero α] →\n        [inst_1 : AddMonoid A] →\n          [inst_2 : AddMonoid B] →\n            [inst_3 : SMul α A] →\n              [inst_4 : SMul α B] →\n                [inst_5 : DivisibleBy A α] →\n                  (f : A → B) → Function.Surjective f → (∀ (a : A) (n : α), f (n • a) = n • f a) → DivisibleBy B α", "name": "Function.Surjective.divisibleBy", "isProp": false, "docString": "If `f : A → B` is a surjective homomorphism and `A` is `α`-divisible, then `B` is also\n`α`-divisible.", "terms": "[\n\"f\",\n\"A\",\n\"B\",\n\"surjective\",\n\"homomorphism\",\n\"α-divisible\"\n]"}
{"type": "{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : CommRing R] →\n      [inst_1 : AddCommGroup M] →\n        [inst_2 : Module R M] → (Q : QuadraticForm R M) → GradedAlgebra (CliffordAlgebra.evenOdd Q)", "name": "CliffordAlgebra.gradedAlgebra", "isProp": false, "docString": "The clifford algebra is graded by the even and odd parts. ", "terms": "[\"clifford algebra\", \"graded\", \"even\", \"odd\", \"parts\"]"}
{"type": "{X : Type u_1} → [inst : TopologicalSpace X] → CompactExhaustion X → X → ℕ", "name": "CompactExhaustion.find", "isProp": false, "docString": "The minimal `n` such that `x ∈ K n`. ", "terms": "[\"minimal\", \"such that\", \"element of\"]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v, u₁} C] →\n    {C' : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v, u₂} C'] →\n        (D : CategoryTheory.GlueData C) →\n          (F : CategoryTheory.Functor C C') →\n            [H :\n                (i j k : D.J) →\n                  CategoryTheory.Limits.PreservesLimit\n                    (CategoryTheory.Limits.cospan (CategoryTheory.GlueData.f D i j) (CategoryTheory.GlueData.f D i k))\n                    F] →\n              CategoryTheory.GlueData C'", "name": "CategoryTheory.GlueData.mapGlueData", "isProp": false, "docString": "A functor that preserves the pullbacks of `f i j` and `f i k` can map a family of glue data. ", "terms": "[\n    \"Functor\",\n    \"Preserves\",\n    \"Pullbacks\",\n    \"Map\",\n    \"Family\",\n    \"Glue Data\"\n]"}
{"type": "(n : ℕ) → Composition n ≃ CompositionAsSet n", "name": "compositionEquiv", "isProp": false, "docString": "Equivalence between `Composition n` and `CompositionAsSet n`. ", "terms": "[\n  \"Equivalence\",\n  \"Composition\",\n  \"CompositionAsSet\"\n]"}
{"type": "{α : Type u} → {n : ℕ} → Vector α n → Fin n → α", "name": "Vector.get", "isProp": false, "docString": "nth element of a vector, indexed by a `Fin` type. ", "terms": "[\n    \"nth element\",\n    \"vector\",\n    \"indexed\",\n    \"`Fin` type\"\n]"}
{"type": "{ι : Type u_1} →\n  {A : ι → Type u_2} →\n    [inst : AddMonoid ι] → [inst_1 : (i : ι) → AddCommGroup (A i)] → [self : DirectSum.GRing A] → ℤ → A 0", "name": "DirectSum.GRing.intCast", "isProp": false, "docString": "The canonical map from ℤ to the zeroth component of a graded ring.", "terms": "[\n    \"canonical map\",\n    \"ℤ\",\n    \"zeroth component\",\n    \"graded ring\"\n]"}
{"type": "∀ {ι : Type u_1} {X : Type u_3} {α : Type u_6} [inst : TopologicalSpace X] [inst_1 : UniformSpace α] {F : ι → X → α}\n  {x₀ : X}, EquicontinuousAt F x₀ ↔ ∀ U ∈ uniformity α, ∃ V ∈ nhds x₀, ∀ x ∈ V, ∀ y ∈ V, ∀ (i : ι), (F i x, F i y) ∈ U", "name": "equicontinuousAt_iff_pair", "isProp": true, "docString": "Reformulation of equicontinuity at `x₀` comparing two variables near `x₀` instead of comparing\nonly one with `x₀`. ", "terms": "[\"Reformulation\", \"equicontinuity\", \"variables\", \"near\", \"comparing\"]"}
{"type": "{R : Type u_1} →\n  [inst : CommSemiring R] →\n    {S : Type u_2} →\n      [inst_1 : CommSemiring S] →\n        [inst_2 : Algebra R S] →\n          {P : Type u_3} →\n            [inst_3 : CommSemiring P] →\n              (x : R) →\n                [inst_4 : IsLocalization.Away x S] →\n                  (y : R) → [inst_5 : Algebra R P] → [inst : IsLocalization.Away (x * y) P] → S →+* P", "name": "IsLocalization.Away.awayToAwayRight", "isProp": false, "docString": "Given `x y : R` and localizations `S`, `P` away from `x` and `x * y`\nrespectively, the homomorphism induced from `S` to `P`. ", "terms": "[\"R\", \"localizations\", \"away from\", \"homomorphism\", \"induced from\"]"}
{"type": "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : LinearOrder β] [inst_2 : SuccOrder β]\n  [inst_3 : IsSuccArchimedean β] {s : β → Set α} {t : Set β},\n  Set.Nonempty t →\n    Set.OrdConnected t →\n      (∀ n ∈ t, IsConnected (s n)) →\n        (∀ n ∈ t, Order.succ n ∈ t → Set.Nonempty (s n ∩ s (Order.succ n))) → IsConnected (⋃ n ∈ t, s n)", "name": "IsConnected.biUnion_of_chain", "isProp": true, "docString": "The iUnion of connected sets indexed by a subset of a type with an archimedean successor\n(like `ℕ` or `ℤ`) such that any two neighboring sets meet is preconnected. ", "terms": "[\n    \"Union\",\n    \"connected sets\",\n    \"indexed\",\n    \"subset\",\n    \"type\",\n    \"archimedean successor\",\n    \"ℕ\",\n    \"ℤ\",\n    \"neighboring sets\",\n    \"meet\",\n    \"preconnected\"\n]"}
{"type": "CategoryTheory.Functor Bipointed Pointed", "name": "bipointedToPointedFst", "isProp": false, "docString": "The forgetful functor from `Bipointed` to `Pointed` which forgets about the second point. ", "terms": "[\"forgetful functor\", \"Bipointed\", \"Pointed\", \"second point\"]"}
{"type": "∀ {α : Type u} [inst : LT α] [inst_1 : WellFoundedLT α] {C : α → Sort u_1} (F : (x : α) → ((y : α) → y < x → C y) → C x)\n  (x : α), WellFoundedLT.fix F x = F x fun y x => WellFoundedLT.fix F y", "name": "WellFoundedLT.fix_eq", "isProp": true, "docString": "The value from `WellFoundedLT.fix` is built from the previous ones as specified. ", "terms": "[\"WellFoundedLT.fix\", \"value\", \"built\", \"previous\", \"specified\"]"}
{"type": "{R : Type u_1} →\n  {ι : Type u_2} →\n    {A : Type u_3} →\n      {B : Type u_4} →\n        [inst : CommSemiring ι] →\n          [inst_1 : Module ι (Additive ℤˣ)] →\n            [inst_2 : DecidableEq ι] →\n              [inst_3 : CommRing R] →\n                [inst_4 : Ring A] →\n                  [inst_5 : Ring B] →\n                    [inst_6 : Algebra R A] →\n                      [inst_7 : Algebra R B] →\n                        (𝒜 : ι → Submodule R A) →\n                          (ℬ : ι → Submodule R B) →\n                            [inst_8 : GradedAlgebra 𝒜] → [inst_9 : GradedAlgebra ℬ] → Mul (GradedTensorProduct R 𝒜 ℬ)", "name": "GradedTensorProduct.instMulGradedTensorProduct", "isProp": false, "docString": "The multipication on the graded tensor product.\n\nSee `GradedTensorProduct.coe_mul_coe` for a characterization on pure tensors. ", "terms": "[\n    \"multiplication\",\n    \"graded\",\n    \"tensor product\",\n    \"characterization\",\n    \"pure tensors\"\n]"}
{"type": "∀ {X : Type u_2} [inst : EMetricSpace X] [inst_1 : MeasurableSpace X] [inst_2 : BorelSpace X]\n  {m₁ m₂ : ENNReal → ENNReal} {c : ENNReal},\n  c ≠ ⊤ →\n    c ≠ 0 →\n      m₁ ≤ᶠ[nhdsWithin 0 (Set.Ici 0)] c • m₂ → MeasureTheory.Measure.mkMetric m₁ ≤ c • MeasureTheory.Measure.mkMetric m₂", "name": "MeasureTheory.Measure.mkMetric_mono_smul", "isProp": true, "docString": "If `c ∉ {0, ∞}` and `m₁ d ≤ c * m₂ d` for `d < ε` for some `ε > 0`\n(we use `≤ᶠ[𝓝[≥] 0]` to state this), then `mkMetric m₁ hm₁ ≤ c • mkMetric m₂ hm₂`. ", "terms": "[\n    \"not an element of (∉)\",\n    \"infinity (∞)\",\n    \"less than or equal to (≤)\",\n    \"multiplication (*)\",\n    \"less than (<)\",\n    \"greater than (>)\",\n    \"neighborhood of a point (𝓝)\",\n    \"greater than or equal to (≥)\",\n    \"scalar multiplication (•)\",\n    \"mkMetric\"\n]"}
{"type": "∀ {α : Type u_1} (l : List α) (c : Composition (List.length l)), List.join (List.splitWrtComposition l c) = l", "name": "List.join_splitWrtComposition", "isProp": true, "docString": "If one splits a list along a composition, and then joins the sublists, one gets back the\noriginal list. ", "terms": "[\"splits\", \"list\", \"along\", \"composition\", \"joins\", \"sublists\", \"original list\"]"}
{"type": "{R : Type u_1} →\n  {R₂ : Type u_3} →\n    {M : Type u_6} →\n      {M₂ : Type u_8} →\n        [inst : Semiring R] →\n          [inst_1 : Semiring R₂] →\n            [inst_2 : AddCommMonoid M] →\n              [inst_3 : AddCommMonoid M₂] →\n                [inst_4 : Module R M] →\n                  [inst_5 : Module R₂ M₂] →\n                    {σ₁₂ : R →+* R₂} →\n                      {σ₂₁ : R₂ →+* R} →\n                        [inst_6 : RingHomInvPair σ₁₂ σ₂₁] →\n                          [inst_7 : RingHomInvPair σ₂₁ σ₁₂] →\n                            {F : Type u_10} →\n                              [sc : SemilinearMapClass F σ₁₂ M M₂] →\n                                (f : F) → Function.Injective ⇑f → (p : Submodule R M) → ↥p ≃ₛₗ[σ₁₂] ↥(Submodule.map f p)", "name": "Submodule.equivMapOfInjective", "isProp": false, "docString": "The pushforward of a submodule by an injective linear map is\nlinearly equivalent to the original submodule. See also `LinearEquiv.submoduleMap` for a\ncomputable version when `f` has an explicit inverse. ", "terms": "[\n    \"pushforward\",\n    \"submodule\",\n    \"injective\",\n    \"linear map\",\n    \"linearly equivalent\",\n    \"original submodule\",\n    \"LinearEquiv.submoduleMap\",\n    \"computable version\",\n    \"explicit inverse\"\n]"}
{"type": "∀ {F : Type u_12} {A : outParam (Type u_13)} {B : outParam (Type u_14)} [inst : Mul A] [inst_1 : Mul B]\n  [self : MulEquivClass F A B] (f : F) (a b : A), f (a * b) = f a * f b", "name": "MulEquivClass.map_mul", "isProp": true, "docString": "Preserves multiplication. ", "terms": "[\"Preserves\", \"Multiplication\"]"}
{"type": "∀ {α : Type u_4} [inst : LinearOrderedRing α], Subsingleton (FloorRing α)", "name": "subsingleton_floorRing", "isProp": true, "docString": "There exists at most one `FloorRing` structure on a given linear ordered ring. ", "terms": "[\n  \"exists\",\n  \"at most\",\n  \"one\",\n  \"FloorRing\",\n  \"structure\",\n  \"given\",\n  \"linear\",\n  \"ordered\",\n  \"ring\"\n]"}
{"type": "Fact (FiniteDimensional.finrank ℝ ℂ = 2)", "name": "Complex.finrank_real_complex_fact", "isProp": true, "docString": "`Fact` version of the dimension of `ℂ` over `ℝ`, locally useful in the definition of the\ncircle. ", "terms": "[\n    \"Fact\",\n    \"Dimension\",\n    \"ℂ\",\n    \"ℝ\",\n    \"Locally\",\n    \"Definition\",\n    \"Circle\"\n]"}
{"type": "{m : Type u_3} →\n  {n : Type u_4} →\n    {α : Type u_5} →\n      [inst : Fintype m] → [inst : Fintype n] → [inst : NormedAddCommGroup α] → NormedAddCommGroup (Matrix m n α)", "name": "Matrix.normedAddCommGroup", "isProp": false, "docString": "Normed group instance (using sup norm of sup norm) for matrices over a normed group.  Not\ndeclared as an instance because there are several natural choices for defining the norm of a\nmatrix. ", "terms": "[\n    \"Normed group\",\n    \"sup norm\",\n    \"matrices\",\n    \"norm\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [inst : NontriviallyNormedField 𝕜]\n  [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace 𝕜 G] (q : FormalMultilinearSeries 𝕜 F G)\n  (p : FormalMultilinearSeries 𝕜 E F) (N : ℕ) (z : E),\n  FormalMultilinearSeries.partialSum q N (Finset.sum (Finset.Ico 1 N) fun i => (p i) fun _j => z) =\n    Finset.sum (FormalMultilinearSeries.compPartialSumTarget 0 N N) fun i =>\n      (FormalMultilinearSeries.compAlongComposition q p i.snd) fun _j => z", "name": "FormalMultilinearSeries.comp_partialSum", "isProp": true, "docString": "Composing the partial sums of two multilinear series coincides with the sum over all\ncompositions in `comp_partial_sum_target 0 N N`. This is precisely the motivation for the\ndefinition of `comp_partial_sum_target`. ", "terms": "[\n  \"Composing\",\n  \"partial sums\",\n  \"multilinear series\",\n  \"sum\",\n  \"compositions\",\n  \"definition\"\n]"}
{"type": "∀ {S : Type u_2} [inst : CommRing S] {K : Type u_4} [inst_1 : Field K] [inst_2 : Algebra K S] [inst_3 : Nontrivial S]\n  (pb : PowerBasis K S), (Algebra.trace K S) pb.gen = -Polynomial.nextCoeff (minpoly K pb.gen)", "name": "PowerBasis.trace_gen_eq_nextCoeff_minpoly", "isProp": true, "docString": "Given `pb : PowerBasis K S`, the trace of `pb.gen` is `-(minpoly K pb.gen).nextCoeff`. ", "terms": "[\n  \"PowerBasis\",\n  \"trace\",\n  \"minpoly\",\n  \"nextCoeff\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Abelian C] →\n      {X : C} → (P Q : CategoryTheory.ProjectiveResolution X) → HomotopyEquiv P.complex Q.complex", "name": "CategoryTheory.ProjectiveResolution.homotopyEquiv", "isProp": false, "docString": "Any two projective resolutions are homotopy equivalent. ", "terms": "[\n    \"projective resolutions\",\n    \"homotopy equivalent\"\n]"}
{"type": "(R : Type u_4) →\n  {M : Type u_5} →\n    [inst : Semiring R] →\n      [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → (w : Set M) → ↥(Submodule.span R w) → ↑w →₀ R", "name": "Span.repr", "isProp": false, "docString": "Pick some representation of `x : span R w` as a linear combination in `w`,\nusing the axiom of choice.\n", "terms": "[\n  \"representation\",\n  \"span\",\n  \"R\",\n  \"linear combination\",\n  \"axiom of choice\"\n]"}
{"type": "∀ {ι : Type u_1} {M : Type u_3} [inst : TopologicalSpace M] [inst_1 : Add M] [inst_2 : ContinuousAdd M],\n  ContinuousAdd (ι → M)", "name": "Pi.continuousAdd'", "isProp": true, "docString": "A version of `Pi.continuousAdd` for non-dependent functions. It is needed\nbecause sometimes Lean fails to use `Pi.continuousAdd` for non-dependent functions.", "terms": "[]\n"}
{"type": "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → LazyList α → Option α", "name": "LazyList.find", "isProp": false, "docString": "Return the first object contained in the list that satisfies\npredicate `p` ", "terms": "[\n\"Object\", \n\"List\", \n\"Satisfies\", \n\"Predicate\"\n]"}
{"type": "(C : Type u) →\n  [inst : CategoryTheory.Category.{v, u} C] → [inst_1 : CategoryTheory.MonoidalCategory C] → CategoryTheory.Functor C C", "name": "CategoryTheory.MonoidalCategory.tensorUnitRight", "isProp": false, "docString": "The functor `fun X ↦ X ⊗ 𝟙_ C`. ", "terms": "[\n    \"functor\",\n    \"tensor product\",\n    \"identity\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] →\n          [inst_3 : CategoryTheory.Limits.HasZeroMorphisms D] →\n            {F : CategoryTheory.Functor C D} →\n              [inst_4 : CategoryTheory.Functor.PreservesZeroMorphisms F] →\n                [self : CategoryTheory.Limits.PreservesFiniteBiproducts F] →\n                  {J : Type} → [inst_5 : Fintype J] → CategoryTheory.Limits.PreservesBiproductsOfShape J F", "name": "CategoryTheory.Limits.PreservesFiniteBiproducts.preserves", "isProp": false, "docString": "A functor `F` preserves finite biproducts if it preserves biproducts of shape `J` whenever\n`J` is a fintype. ", "terms": "[\n    \"functor\",\n    \"preserves\",\n    \"finite biproducts\",\n    \"biproducts\",\n    \"shape\",\n    \"fintype\"\n]"}
{"type": "{α : Type u_1} → (α → α → Prop) → Set α → Prop", "name": "IsAntichain", "isProp": false, "docString": "An antichain is a set such that no two distinct elements are related. ", "terms": "[\n  \"antichain\",\n  \"set\",\n  \"elements\",\n  \"related\",\n  \"distinct\"\n]"}
{"type": "Lean.PrettyPrinter.Delaborator.Delab", "name": "LinearEquiv.transNotation.delab", "isProp": false, "docString": "Pretty printer defined by `notation3` command. ", "terms": "[]"}
{"type": "∀ {M : Type u_1} [inst : AddZeroClass M] {s : Set M} {p : M → Prop} {x : M},\n  x ∈ AddSubmonoid.closure s → (∀ x ∈ s, p x) → p 0 → (∀ (x y : M), p x → p y → p (x + y)) → p x", "name": "AddSubmonoid.closure_induction", "isProp": true, "docString": "An induction principle for additive closure membership. If `p` holds for `0` and all\nelements of `s`, and is preserved under addition, then `p` holds for all elements of the\nadditive closure of `s`.", "terms": "[\n    \"induction principle\",\n    \"additive closure\",\n    \"membership\",\n    \"holds for\",\n    \"elements\",\n    \"preserved\",\n    \"under addition\",\n    \"all elements\",\n    \"additive closure\"\n]"}
{"type": "∀ {M : Type u_1} [inst : Monoid M] (c : Con M) (f : M → M),\n  (∀ (x : M), c (f x * x) 1) → ∀ {x y : M}, c x y → c (f x) (f y)", "name": "Con.map_of_mul_left_rel_one", "isProp": true, "docString": "Sometimes, a group is defined as a quotient of a monoid by a congruence relation.\nUsually, the inverse operation is defined as `Setoid.map f _` for some `f`.\nThis lemma allows to avoid code duplication in the definition of the inverse operation:\ninstead of proving both `∀ x y, c x y → c (f x) (f y)` (to define the operation)\nand `∀ x, c (f x * x) 1` (to prove the group laws), one can only prove the latter. ", "terms": "The mathematical terms in the statement are:\n\n- \"group\"\n- \"quotient\"\n- \"monoid\"\n- \"congruence relation\"\n- \"inverse operation\"\n- \"Setoid.map\"\n- \"lemma\"\n- \"code duplication\"\n- \"definition\"\n- \"operation\"\n- \"group laws\"\n\nHere is the JSON list:\n\n    [\"group\", \"quotient\", \"monoid\", \"congruence relation\", \"inverse operation\", \"Setoid.map\", \"lemma\", \"code duplication\", \"definition\", \"operation\", \"group laws\"]"}
{"type": "∀ {α : Type u_1} [inst : MetricSpace α] {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} (v : VitaliFamily μ)\n  [inst_1 : SecondCountableTopology α] [inst_2 : BorelSpace α] [inst_3 : MeasureTheory.IsLocallyFiniteMeasure μ]\n  {ρ : MeasureTheory.Measure α} [inst_4 : MeasureTheory.IsLocallyFiniteMeasure ρ],\n  MeasureTheory.Measure.AbsolutelyContinuous ρ μ →\n    ∀ᵐ (x : α) ∂μ, ∃ c, Filter.Tendsto (fun a => ↑↑ρ a / ↑↑μ a) (VitaliFamily.filterAt v x) (nhds c)", "name": "VitaliFamily.ae_tendsto_div", "isProp": true, "docString": "If `ρ` is absolutely continuous with respect to `μ`, then for almost every `x`,\nthe ratio `ρ a / μ a` converges as `a` shrinks to `x` along a Vitali family for `μ`. ", "terms": "[\n    \"absolutely continuous\",\n    \"with respect to\",\n    \"almost every\",\n    \"ratio\",\n    \"converges\",\n    \"shrinks to\",\n    \"along\",\n    \"Vitali family\"\n]"}
{"type": "{R : Type u_1} →\n  [inst : CommSemiring R] →\n    {S : Type u_2} → [inst_1 : CommSemiring S] → [inst_2 : Algebra R S] → (x : R) → [inst : IsLocalization.Away x S] → S", "name": "IsLocalization.Away.invSelf", "isProp": false, "docString": "Given `x : R` and a localization map `F : R →+* S` away from `x`, `invSelf` is `(F x)⁻¹`. ", "terms": "[\n  \"R\",\n  \"localization map\",\n  \"S\",\n  \"away from\",\n  \"invSelf\",\n  \"inverse\"\n]"}
{"type": "∀ {ι : Type u_5} {π : ι → Type u_6} [T : (i : ι) → TopologicalSpace (π i)] [inst : Finite ι]\n  [inst : ∀ (i : ι), DiscreteTopology (π i)], DiscreteTopology ((i : ι) → π i)", "name": "Pi.discreteTopology", "isProp": true, "docString": "A finite product of discrete spaces is discrete. ", "terms": "[\n    \"finite product\",\n    \"discrete spaces\",\n    \"discrete\"\n]"}
{"type": "{C : Type u_1} →\n  {D : Type u_2} →\n    [inst : CategoryTheory.Category.{u_3, u_1} C] →\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] →\n        [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] →\n          [inst_3 : CategoryTheory.Limits.HasZeroMorphisms D] →\n            (F : CategoryTheory.Functor C D) →\n              [inst_4 : CategoryTheory.Functor.PreservesZeroMorphisms F] →\n                (S : CategoryTheory.ShortComplex C) →\n                  S.g = 0 →\n                    [inst_5 : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair S.f 0) F] →\n                      CategoryTheory.Functor.PreservesLeftHomologyOf F S", "name": "CategoryTheory.Functor.preservesLeftHomologyOfZerog", "isProp": false, "docString": "If a short complex `S` is such that `S.g = 0` and that the cokernel of `S.f` is preserved\nby a functor `F`, then `F` preserves the left homology of `S`. ", "terms": "[\n    \"short complex\",\n    \"cokernel\",\n    \"functor\",\n    \"preserves\",\n    \"left homology\"\n]"}
{"type": "∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (x : (↥(NumberField.ringOfIntegers K))ˣ),\n  ∃! ζ e, x = ↑ζ * Finset.prod Finset.univ fun i => NumberField.Units.fundSystem K i ^ e i", "name": "NumberField.Units.exist_unique_eq_mul_prod", "isProp": true, "docString": "**Dirichlet Unit Theorem**. Any unit `x` of `𝓞 K` can be written uniquely as the product of\na root of unity and powers of the units of the fundamental system `fundSystem`. ", "terms": "[\n    \"Dirichlet Unit Theorem\",\n    \"unit\",\n    \"product\",\n    \"root of unity\",\n    \"powers\",\n    \"units of the fundamental system\"\n]"}
{"type": "∀ {M : Type u_9} {N : Type u_10} [inst : One M] [inst_1 : One N] (self : OneHom M N), OneHom.toFun self 1 = 1", "name": "OneHom.map_one'", "isProp": true, "docString": "The proposition that the function preserves 1 ", "terms": "[\n    \"Proposition\",\n    \"Function\",\n    \"Preserves\",\n    \"1\"\n]"}
{"type": "Type u_3 → Type u_3", "name": "SetSemiring", "isProp": false, "docString": "An alias for `Set α`, which has a semiring structure given by `∪` as \"addition\" and pointwise\nmultiplication `*` as \"multiplication\". ", "terms": "[\n    \"alias\",\n    \"Set\",\n    \"semiring structure\",\n    \"addition\",\n    \"pointwise multiplication\",\n    \"multiplication\"\n]"}
{"type": "{n : ℕ} → Fin n → Equiv.Perm (Fin n)", "name": "Fin.cycleRange", "isProp": false, "docString": "`Fin.cycleRange i` is the cycle `(0 1 2 ... i)` leaving `(i+1 ... (n-1))` unchanged. ", "terms": "[\"Fin.cycleRange\", \"cycle\", \"unchanged\"]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_5, u_1} C] →\n    {D : Type u_2} →\n      [inst_1 : CategoryTheory.Category.{u_6, u_2} D] →\n        {K : CategoryTheory.GrothendieckTopology D} →\n          {A : Type u_4} →\n            [inst_2 : CategoryTheory.Category.{u_7, u_4} A] →\n              {G : CategoryTheory.Functor C D} →\n                [inst_3 : CategoryTheory.Functor.IsCoverDense G K] →\n                  [inst_4 : CategoryTheory.Full G] →\n                    {ℱ ℱ' : CategoryTheory.Sheaf K A} →\n                      (CategoryTheory.Functor.comp G.op ℱ.val ≅ CategoryTheory.Functor.comp G.op ℱ'.val) → (ℱ ≅ ℱ')", "name": "CategoryTheory.Functor.IsCoverDense.sheafIso", "isProp": false, "docString": "Given a natural isomorphism `G ⋙ ℱ ≅ G ⋙ ℱ'` between presheaves of arbitrary category,\nwhere `G` is full and cover-dense, and `ℱ', ℱ` are sheaves,\nwe may obtain a natural isomorphism between presheaves.\n", "terms": "[\n  \"natural isomorphism\",\n  \"presheaves\",\n  \"arbitrary category\",\n  \"full\",\n  \"cover-dense\",\n  \"sheaves\"\n]"}
{"type": "(R : Type u_1) →\n  (p : ℕ) →\n    [inst : CommSemiring R] →\n      [inst_1 : Fact (Nat.Prime p)] → [inst_2 : CharP R p] → [inst_3 : PerfectRing R p] → R ≃+* R", "name": "frobeniusEquiv", "isProp": false, "docString": "The Frobenius automorphism for a perfect ring. ", "terms": "[\n    \"Frobenius automorphism\",\n    \"perfect ring\"\n]"}
{"type": "∀ {A : Type u} {B : Type v} {ι : Type w} [inst : DecidableEq ι] [inst_1 : CommRing A] [inst_2 : CommRing B]\n  [inst_3 : Algebra A B] [inst_4 : Fintype ι] (b : ι → B) (P : Matrix ι ι A),\n  Algebra.discr A (Matrix.vecMul b (Matrix.map P ⇑(algebraMap A B))) = Matrix.det P ^ 2 * Algebra.discr A b", "name": "Algebra.discr_of_matrix_vecMul", "isProp": true, "docString": "Relation between `Algebra.discr A ι b` and\n`Algebra.discr A ((P.map (algebraMap A B)).vecMul b)`. ", "terms": "[\"Relation\", \"Algebra.discr\", \"P.map\", \"algebraMap\", \"vecMul\"]"}
{"type": "{C₁ : Type u₁} →\n  {C₂ : Type u₂} →\n    [inst : CategoryTheory.Category.{v₁, u₁} C₁] →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} C₂] →\n        (W₁ : CategoryTheory.MorphismProperty C₁) →\n          [inst_2 : CategoryTheory.MorphismProperty.ContainsIdentities W₁] →\n            (W₂ : CategoryTheory.MorphismProperty C₂) →\n              [inst_3 : CategoryTheory.MorphismProperty.ContainsIdentities W₂] →\n                {E : Type u₅} →\n                  [inst_4 : CategoryTheory.Category.{v₅, u₅} E] →\n                    CategoryTheory.Localization.StrictUniversalPropertyFixedTarget\n                      (CategoryTheory.Functor.prod (CategoryTheory.MorphismProperty.Q W₁)\n                        (CategoryTheory.MorphismProperty.Q W₂))\n                      (CategoryTheory.MorphismProperty.prod W₁ W₂) E", "name": "CategoryTheory.Localization.StrictUniversalPropertyFixedTarget.prod", "isProp": false, "docString": "The product of two (constructed) localized categories satisfies the universal\nproperty of the localized category of the product. ", "terms": "[\n  \"Product\",\n  \"Constructed\",\n  \"Localized Categories\",\n  \"Universal Property\",\n  \"Localized Category\",\n  \"Product\"\n]"}
{"type": "∀ {G : Type u_1} {α : Type u_3} [inst : AddGroup G] [inst_1 : AddAction G α] [inst_2 : MeasurableSpace α] {s : Set α}\n  {μ : MeasureTheory.Measure α},\n  MeasureTheory.NullMeasurableSet s → (∀ (x : α), ∃! g, g +ᵥ x ∈ s) → MeasureTheory.IsAddFundamentalDomain G s", "name": "MeasureTheory.IsAddFundamentalDomain.mk'", "isProp": true, "docString": "If for each `x : α`, exactly one of `g +ᵥ x`, `g : G`, belongs to a measurable set\n`s`, then `s` is a fundamental domain for the additive action of `G` on `α`.", "terms": "[\n    \"each\",\n    \"exactly one\",\n    \"belongs\",\n    \"measurable set\",\n    \"fundamental domain\",\n    \"additive action\"\n]"}
{"type": "{G : Type u} →\n  [inst : Group G] → {H : Type v} → [inst_1 : Group H] → (φ : G →* H) → G ⧸ MonoidHom.ker φ ≃* ↥(MonoidHom.range φ)", "name": "QuotientGroup.quotientKerEquivRange", "isProp": false, "docString": "**Noether's first isomorphism theorem** (a definition): the canonical isomorphism between\n`G/(ker φ)` to `range φ`. ", "terms": "[\n    \"Noether's first isomorphism theorem\",\n    \"canonical isomorphism\",\n    \"G\",\n    \"ker φ\",\n    \"range φ\"\n]"}
{"type": "{R : Type u} →\n  {M : Type v} →\n    {M₂ : Type w} →\n      {M₃ : Type y} →\n        [inst : CommSemiring R] →\n          [inst_1 : AddCommMonoid M] →\n            [inst_2 : AddCommMonoid M₂] →\n              [inst_3 : AddCommMonoid M₃] →\n                [inst_4 : Module R M] →\n                  [inst_5 : Module R M₂] →\n                    [inst_6 : Module R M₃] →\n                      {n : ℕ} →\n                        (M →ₗ[R] M₂ →ₗ[R] M₃) → (M →ₗ[R] M₂ →ₗ[R] Fin n → M₃) → M →ₗ[R] M₂ →ₗ[R] Fin (Nat.succ n) → M₃", "name": "LinearMap.vecCons₂", "isProp": false, "docString": "A bilinear map into `Fin n.succ → M₃` can be built out of a map into `M₃` and a map into\n`Fin n → M₃` ", "terms": "[\n    \"bilinear map\",\n    \"Fin n.succ\",\n    \"M₃\",\n    \"map\",\n    \"Fin n\"\n]"}
{"type": "CategoryTheory.Limits.WalkingSpanᵒᵖ ≌ CategoryTheory.Limits.WalkingCospan", "name": "CategoryTheory.Limits.walkingSpanOpEquiv", "isProp": false, "docString": "The duality equivalence `WalkingSpanᵒᵖ ≌ WalkingCospan` ", "terms": "[\n    \"duality\",\n    \"equivalence\"\n]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    {X₀ X₁ : C} →\n      (X₀ ⟶ X₁) →\n        (i j : Fin 2) →\n          i ≤ j → (CategoryTheory.ComposableArrows.Mk₁.obj X₀ X₁ i ⟶ CategoryTheory.ComposableArrows.Mk₁.obj X₀ X₁ j)", "name": "CategoryTheory.ComposableArrows.Mk₁.map", "isProp": false, "docString": "The obvious map `obj X₀ X₁ i ⟶ obj X₀ X₁ j` whenever `i j : Fin 2` satisfy `i ≤ j`. ", "terms": "[\n  \"map\",\n  \"obj\",\n  \"Fin\",\n  \"satisfy\",\n  \"≤\"\n]"}
{"type": "{α : Type u} → {β : α → Type v} → [inst : DecidableEq α] → List (Sigma β) → Finmap β", "name": "List.toFinmap", "isProp": false, "docString": "Given `l : List (Sigma β)`, create a term of type `Finmap β` by removing\nentries with duplicate keys. ", "terms": "[\n    \"List\",\n    \"Sigma\",\n    \"term\",\n    \"type\",\n    \"Finmap\",\n    \"entries\",\n    \"duplicate keys\"\n]"}
{"type": "{d : ℤ} → ℤ√d → Prop", "name": "Pell.IsPell", "isProp": false, "docString": "The property of being a solution to the Pell equation, expressed\nas a property of elements of `ℤ√d`. ", "terms": "[\n    \"Property\",\n    \"Solution\",\n    \"Pell equation\",\n    \"Expressed\",\n    \"Elements\",\n    \"ℤ√d\"\n]"}
{"type": "∀ (L : Type u_1) [inst : CompleteLattice L] (U : Set (Locale.PT L)), IsOpen U ↔ ∃ u, {x | x u} = U", "name": "Locale.PT.isOpen_iff", "isProp": true, "docString": "Characterization of when a subset of the space of points is open. ", "terms": "[\n  \"Characterization\",\n  \"Subset\",\n  \"Space\",\n  \"Points\",\n  \"Open\"\n]"}
{"type": "{R : Type u_1} → [inst : AddGroupWithOne R] → {n : ℕ} → ZMod n → R", "name": "ZMod.cast", "isProp": false, "docString": "Cast an integer modulo `n` to another semiring.\nThis function is a morphism if the characteristic of `R` divides `n`.\nSee `ZMod.castHom` for a bundled version. ", "terms": "[\n    \"integer\",\n    \"modulo\",\n    \"semiring\",\n    \"function\",\n    \"morphism\",\n    \"characteristic\",\n    \"divides\",\n    \"bundled version\"\n]"}
{"type": "∀ (x : ℝ), Real.sinh (Real.arsinh x) = x", "name": "Real.sinh_arsinh", "isProp": true, "docString": "`arsinh` is the right inverse of `sinh`. ", "terms": "[\"arsinh\", \"right inverse\", \"sinh\"]"}
{"type": "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T5Space X], T5Space (SeparationQuotient X)", "name": "instT5SpaceSeparationQuotientInstTopologicalSpaceSeparationQuotient", "isProp": true, "docString": "The `SeparationQuotient` of a completely normal R₀ space is a T₅ space.\nWe don't have typeclasses for completely normal spaces (without T₁ assumption) and R₀ spaces,\nso we use `T5Space` for assumption and for conclusion.\n\nOne can prove this using a homeomorphism between `X` and `SeparationQuotient X`.\nWe give an alternative proof of the `completely_normal` axiom\nthat works without assuming that `X` is a T₁ space. ", "terms": "Here are the mathematical terms in the given statement:\n\n```\n[\n    \"SeparationQuotient\",\n    \"completely normal\",\n    \"R₀ space\",\n    \"T₅ space\",\n    \"homeomorphism\",\n    \"completely_normal\",\n    \"T₁ space\",\n    \"axiom\"\n]\n```"}
{"type": "CategoryTheory.Functor FintypeCat Profinite", "name": "FintypeCat.toProfinite", "isProp": false, "docString": "The natural functor from `Fintype` to `Profinite`, endowing a finite type with the\ndiscrete topology. ", "terms": "[\n    \"natural functor\",\n    \"Fintype\",\n    \"Profinite\",\n    \"finite type\",\n    \"discrete topology\"\n]"}
{"type": "{α : Type u} → (α → Filter α) → TopologicalSpace α", "name": "TopologicalSpace.mkOfNhds", "isProp": false, "docString": "Construct a topology on α given the filter of neighborhoods of each point of α. ", "terms": "[\n    \"Construct\",\n    \"Topology\",\n    \"Filter\",\n    \"Neighborhoods\",\n    \"Point\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {J : Type u} →\n          [inst_2 : CategoryTheory.Category.{v, u} J] →\n            (R : CategoryTheory.Functor D C) →\n              [inst_3 : CategoryTheory.MonadicRightAdjoint R] →\n                [inst_4 : CategoryTheory.Limits.PreservesColimitsOfShape J R] →\n                  CategoryTheory.CreatesColimitsOfShape J R", "name": "CategoryTheory.monadicCreatesColimitsOfShapeOfPreservesColimitsOfShape", "isProp": false, "docString": "A monadic functor creates any colimits of shapes it preserves. ", "terms": "[\n    \"Monadic Functor\", \n    \"Colimits\", \n    \"Shapes\", \n    \"Preserves\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {i : α → β},\n  DenseInducing i → DenseRange i", "name": "DenseInducing.dense", "isProp": true, "docString": "The range of a dense inducing map is a dense set. ", "terms": "[\n    \"range\",\n    \"dense\",\n    \"inducing map\",\n    \"dense set\"\n]"}
{"type": "(R : Type u) →\n  [inst : CommSemiring R] →\n    (S : Type v) → [inst_1 : Semiring S] → [inst_2 : Algebra R S] → Polynomial R →ₐ[R] Polynomial S", "name": "Polynomial.mapAlg", "isProp": false, "docString": "The map `R[X] → S[X]` as an algebra homomorphism. ", "terms": "[\n    \"map\",\n    \"R[X]\",\n    \"S[X]\",\n    \"algebra\",\n    \"homomorphism\"\n]"}
{"type": "∀ {H : Type u} [inst : NormedAddCommGroup H] [inst_1 : InnerProductSpace ℂ H] [inst_2 : CompleteSpace H]\n  (self : VonNeumannAlgebra H), Set.centralizer (Set.centralizer self.carrier) = self.carrier", "name": "VonNeumannAlgebra.centralizer_centralizer'", "isProp": true, "docString": "The double commutant (a.k.a. centralizer) of a `VonNeumannAlgebra` is itself. ", "terms": "[\n  \"double commutant\",\n  \"centralizer\",\n  \"Von Neumann Algebra\"\n]"}
{"type": "∀ {m : Type u_2} {α : Type u_4} [inst : Fintype m] [inst_1 : DecidableEq m] [inst_2 : CommRing α] (u v : m → α),\n  Matrix.det (1 + Matrix.col u * Matrix.row v) = 1 + Matrix.dotProduct v u", "name": "Matrix.det_one_add_col_mul_row", "isProp": true, "docString": "A special case of the **Matrix determinant lemma** for when `A = I`. ", "terms": "[\n    \"Matrix determinant lemma\",\n    \"special case\",\n    \"A\",\n    \"I\"\n]"}
{"type": "∀ {I : Type u} {β : Type u_2} [inst : DecidableEq I] [inst_1 : One β] (i : I) (x : β) (i' : I),\n  Pi.mulSingle i x i' = if i' = i then x else 1", "name": "Pi.mulSingle_apply", "isProp": true, "docString": "On non-dependent functions, `Pi.mulSingle` can be expressed as an `ite` ", "terms": "[\n    \"non-dependent functions\",\n    \"Pi.mulSingle\",\n    \"expressed\",\n    \"ite\"\n]"}
{"type": "{F : Type u_1} →\n  {α : Type u_2} → {β : Type u_3} → [inst : Bot α] → [inst_1 : Bot β] → [inst_2 : BotHomClass F α β] → F → BotHom α β", "name": "BotHomClass.toBotHom", "isProp": false, "docString": "Turn an element of a type `F` satisfying `BotHomClass F α β` into an actual\n`BotHom`. This is declared as the default coercion from `F` to `BotHom α β`. ", "terms": "[\n    \"element\",\n    \"type\",\n    \"F\",\n    \"satisfying\",\n    \"BotHomClass\",\n    \"F\",\n    \"α\",\n    \"β\",\n    \"actual\",\n    \"BotHom\",\n    \"declared\",\n    \"default\",\n    \"coercion\",\n    \"from\",\n    \"F\",\n    \"to\",\n    \"BotHom\",\n    \"α\",\n    \"β\"\n]"}
{"type": "Lean.TrailingParserDescr", "name": "«term_≃o_»", "isProp": false, "docString": "Notation for an `OrderIso`. ", "terms": "[\"Notation\", \"OrderIso\"]"}
{"type": "∀ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ⧸ AddCommGroup.torsion G)", "name": "AddIsTorsionFree.quotient_torsion", "isProp": true, "docString": "Quotienting a group by its additive torsion subgroup yields an additive torsion free group.", "terms": "[\n    \"Quotienting\",\n    \"Group\",\n    \"Additive\",\n    \"Torsion subgroup\",\n    \"Yields\",\n    \"Torsion free group\"\n]"}
{"type": "{𝕜 : Type u_1} →\n  {A : Type u_2} →\n    [inst : NontriviallyNormedField 𝕜] →\n      [inst_1 : NonUnitalNormedRing A] →\n        [inst_2 : NormedSpace 𝕜 A] →\n          [inst_3 : IsScalarTower 𝕜 A A] →\n            [inst_4 : SMulCommClass 𝕜 A A] → [inst : RegularNormedAlgebra 𝕜 A] → MetricSpace (Unitization 𝕜 A)", "name": "Unitization.instMetricSpace", "isProp": false, "docString": "Pull back the metric structure from `𝕜 × (A →L[𝕜] A)` to `Unitization 𝕜 A` using the\nalgebra homomorphism `Unitization.splitMul 𝕜 A`, but replace the bornology and the uniformity so\nthat they coincide with `𝕜 × A`. ", "terms": "[\n    \"metric structure\",\n    \"𝕜 × (A →L[𝕜] A)\",\n    \"Unitization 𝕜 A\",\n    \"algebra homomorphism\",\n    \"Unitization.splitMul 𝕜 A\",\n    \"bornology\",\n    \"uniformity\",\n    \"𝕜 × A\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] {f : β → α},\n  Bornology.IsBounded (Set.range f) ↔ ∃ C, ∀ (x y : β), dist (f x) (f y) ≤ C", "name": "Metric.isBounded_range_iff", "isProp": true, "docString": "Characterization of the boundedness of the range of a function ", "terms": "[\n    \"Characterization\",\n    \"Boundedness\",\n    \"Range\",\n    \"Function\"\n]"}
{"type": "∀ {α : Type u_1} {ι : Sort u_4} {κ : ι → Sort u_7} {s : (i : ι) → κ i → Set α} {t : Set α} (i : ι) (j : κ i),\n  s i j ⊆ t → ⋂ i, ⋂ j, s i j ⊆ t", "name": "Set.iInter₂_subset_of_subset", "isProp": true, "docString": "This rather trivial consequence of `iInter₂_subset` is convenient with `apply`, and has `i` and\n`j` explicit for this purpose. ", "terms": "[\"consequence\", \"subset\", \"convenient\", \"apply\", \"explicit\"]"}
{"type": "{α : Type u_1} → (α → Bool) → List α → List (List α)", "name": "List.splitOnP", "isProp": false, "docString": "Split a list at every element satisfying a predicate. The separators are not in the result.\n```\n[1, 1, 2, 3, 2, 4, 4].splitOnP (· == 2) = [[1, 1], [3], [4, 4]]\n```\n", "terms": "[\"Split\", \"list\", \"element\", \"satisfying\", \"predicate\", \"separators\", \"result\", \"splitOnP\", \"==\"]"}
{"type": "(α : Type u_3) → [inst : MeasurableSpace α] → MeasureTheory.SignedMeasure α ≃ MeasureTheory.JordanDecomposition α", "name": "MeasureTheory.SignedMeasure.toJordanDecompositionEquiv", "isProp": false, "docString": "`MeasureTheory.SignedMeasure.toJordanDecomposition` and\n`MeasureTheory.JordanDecomposition.toSignedMeasure` form an `Equiv`. ", "terms": "[\n    \"MeasureTheory.SignedMeasure.toJordanDecomposition\",\n    \"MeasureTheory.JordanDecomposition.toSignedMeasure\",\n    \"Equiv\"\n]"}
{"type": "{R : Type u} →\n  [inst : Ring R] →\n    {ι : Type v} →\n      [inst_1 : Preorder ι] →\n        (G : ι → Type v) →\n          [inst_2 : (i : ι) → AddCommGroup (G i)] →\n            [inst_3 : (i : ι) → Module R (G i)] →\n              (f : (i j : ι) → i ≤ j → G i →ₗ[R] G j) →\n                [inst_4 : DirectedSystem G fun i j h => ⇑(f i j h)] → CategoryTheory.Functor ι (ModuleCat R)", "name": "ModuleCat.directLimitDiagram", "isProp": false, "docString": "The diagram (in the sense of `CategoryTheory`)\nof an unbundled `directLimit` of modules. ", "terms": "[\n    \"diagram\",\n    \"CategoryTheory\",\n    \"directLimit\",\n    \"modules\"\n]"}
{"type": "{C : Type u_1} →\n  {D : Type u_2} →\n    [inst : CategoryTheory.Category.{u_4, u_1} C] →\n      [inst_1 : CategoryTheory.Category.{u_5, u_2} D] →\n        (L : CategoryTheory.Functor C D) →\n          (W : CategoryTheory.MorphismProperty C) →\n            {E : Type u_3} →\n              [inst_2 : CategoryTheory.Category.{u_6, u_3} E] →\n                [inst_3 : CategoryTheory.Functor.IsLocalization L W] →\n                  (F₁ F₂ : CategoryTheory.Functor C E) →\n                    (F₁' F₂' : CategoryTheory.Functor D E) →\n                      [inst_4 : CategoryTheory.Localization.Lifting L W F₁ F₁'] →\n                        [inst_5 : CategoryTheory.Localization.Lifting L W F₂ F₂'] → (F₁ ⟶ F₂) → (F₁' ⟶ F₂')", "name": "CategoryTheory.Localization.liftNatTrans", "isProp": false, "docString": "Given a localization functor `L : C ⥤ D` for `W : MorphismProperty C`,\nif `(F₁' F₂' : D ⥤ E)` are functors which lifts functors `(F₁ F₂ : C ⥤ E)`,\na natural transformation `τ : F₁ ⟶ F₂` uniquely lifts to a natural transformation `F₁' ⟶ F₂'`. ", "terms": "[\n    \"localization functor\",\n    \"MorphismProperty\",\n    \"functors\",\n    \"lifts functors\",\n    \"natural transformation\",\n    \"uniquely lifts\"\n]"}
{"type": "∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]}", "name": "Nat.infinite_setOf_prime_modEq_one", "isProp": true, "docString": "For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. ", "terms": "[\n\"positive\",\n\"ℕ\",\n\"infinitely many\",\n\"primes\",\n\"≡ 1\",\n\"[MOD k]\"\n]"}
{"type": "(α : Type u_1) → [inst : LinearOrder α] → LinOrd", "name": "LinOrd.of", "isProp": false, "docString": "Construct a bundled `LinOrd` from the underlying type and typeclass. ", "terms": "[\"Construct\", \"bundled\", \"LinOrd\", \"underlying type\", \"typeclass\"]"}
{"type": "(R : Type u_1) →\n  {V : Type u_2} →\n    {P : Type u_4} →\n      [inst : OrderedRing R] → [inst_1 : AddCommGroup V] → [inst : Module R V] → [inst : AddTorsor V P] → P → P → Set P", "name": "affineSegment", "isProp": false, "docString": "The segment of points weakly between `x` and `y`. When convexity is refactored to support\nabstract affine combination spaces, this will no longer need to be a separate definition from\n`segment`. However, lemmas involving `+ᵥ` or `-ᵥ` will still be relevant after such a\nrefactoring, as distinct from versions involving `+` or `-` in a module. ", "terms": "[\n\"segment\",\n\"points\",\n\"weakly between\",\n\"convexity\",\n\"abstract affine combination spaces\",\n\"definition\",\n\"lemmas\",\n\"versions\",\n\"module\"\n]"}
{"type": "∀ {α : Type u_1} [inst : ConditionallyCompleteLinearOrderBot α] {s : Set α}, BddAbove s → ↑(sSup s) = ⨆ a ∈ s, ↑a", "name": "WithTop.coe_sSup", "isProp": true, "docString": "A version of `WithTop.coe_sSup'` with a more convenient but less general statement. ", "terms": "[]"}
{"type": "{α : Type u_1} → Matroid α → IndepMatroid α", "name": "Matroid.dualIndepMatroid", "isProp": false, "docString": "Given `M : Matroid α`, the `IndepMatroid α` whose independent sets are\nthe subsets of `M.E` that are disjoint from some base of `M` ", "terms": "[\n  \"Matroid\",\n  \"IndepMatroid\",\n  \"independent sets\",\n  \"subsets\",\n  \"disjoint\",\n  \"base\"\n]"}
{"type": "{L : FirstOrder.Language} →\n  {α : Type u'} →\n    FirstOrder.Language.Relations L 2 →\n      FirstOrder.Language.Term L α → FirstOrder.Language.Term L α → FirstOrder.Language.Formula L α", "name": "FirstOrder.Language.Relations.formula₂", "isProp": false, "docString": "Applies a binary relation to two terms as a formula. ", "terms": "[\"binary relation\", \"terms\", \"formula\"]"}
{"type": "∀ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G]\n  [inst_3 : MeasurableSpace G] [inst_4 : BorelSpace G] (μ : MeasureTheory.Measure G)\n  [inst_5 : MeasureTheory.Measure.IsHaarMeasure μ] [inst_6 : LocallyCompactSpace G]\n  [inst_7 : MeasureTheory.Measure.InnerRegular μ], MeasureTheory.Measure.IsInvInvariant μ", "name": "MeasureTheory.Measure.IsHaarMeasure.isInvInvariant_of_innerRegular", "isProp": true, "docString": "Any inner regular Haar measure is invariant under inversion in an abelian group. ", "terms": "[\n  \"Inner Regular\",\n  \"Haar Measure\",\n  \"Invariant\",\n  \"Inversion\",\n  \"Abelian Group\"\n]"}
{"type": "{R : Type u_1} →\n  {L : Type u_2} →\n    [inst : CommRing R] →\n      [inst_1 : LieRing L] →\n        [inst_2 : LieAlgebra R L] →\n          (H : LieSubalgebra R L) → [inst_3 : LieAlgebra.IsNilpotent R ↥H] → (↥H → R) → LieSubmodule R (↥H) L", "name": "LieAlgebra.rootSpace", "isProp": false, "docString": "Given a nilpotent Lie subalgebra `H ⊆ L`, the root space of a map `χ : H → R` is the weight\nspace of `L` regarded as a module of `H` via the adjoint action. ", "terms": "[\n    \"nilpotent\",\n    \"Lie subalgebra\",\n    \"root space\",\n    \"map\",\n    \"weight space\",\n    \"module\",\n    \"adjoint action\"\n]"}
{"type": "∀ {R : Type u} [inst : NonAssocSemiring R] {s : Set R} {p : R → Prop} {x : R},\n  x ∈ Subsemiring.closure s →\n    (∀ x ∈ s, p x) → p 0 → p 1 → (∀ (x y : R), p x → p y → p (x + y)) → (∀ (x y : R), p x → p y → p (x * y)) → p x", "name": "Subsemiring.closure_induction", "isProp": true, "docString": "An induction principle for closure membership. If `p` holds for `0`, `1`, and all elements\nof `s`, and is preserved under addition and multiplication, then `p` holds for all elements\nof the closure of `s`. ", "terms": "[\n    \"induction principle\",\n    \"closure membership\",\n    \"holds\",\n    \"0\",\n    \"1\",\n    \"elements\",\n    \"preserved\",\n    \"addition\",\n    \"multiplication\",\n    \"closure\"\n]"}
{"type": "{M : Type u_4} → [inst : CommMonoidWithZero M] → (S : Submonoid M) → Localization S", "name": "Localization.zero", "isProp": false, "docString": "The zero element in a Localization is defined as `(0, 1)`.\n\nShould not be confused with `AddLocalization.zero` which is `(0, 0)`. ", "terms": "[\n    \"zero element\",\n    \"Localization\",\n    \"defined\",\n    \"AddLocalization.zero\"\n]"}
{"type": "(α : Type u) → [ms : MeasurableSpace α] → MeasCat", "name": "MeasCat.of", "isProp": false, "docString": "Construct a bundled `MeasCat` from the underlying type and the typeclass. ", "terms": "[\"Construct\", \"bundled\", \"MeasCat\", \"underlying type\", \"typeclass\"]"}
{"type": "{G : Type u_1} → [inst : Mul G] → G → G → G", "name": "leftMul", "isProp": false, "docString": "`leftMul g` denotes left multiplication by `g` ", "terms": "[\"left multiplication\"]"}
{"type": "∀ {E : Type u_1} {f f' : ℝ → E} {a : ℝ} {m : E} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n  [inst_2 : CompleteSpace E],\n  ContinuousWithinAt f (Set.Iic a) a →\n    (∀ x ∈ Set.Iio a, HasDerivAt f (f' x) x) →\n      MeasureTheory.IntegrableOn f' (Set.Iic a) →\n        Filter.Tendsto f Filter.atBot (nhds m) → ∫ (x : ℝ) in Set.Iic a, f' x = f a - m", "name": "MeasureTheory.integral_Iic_of_hasDerivAt_of_tendsto", "isProp": true, "docString": "**Fundamental theorem of calculus-2**, on semi-infinite intervals `(-∞, a)`.\nWhen a function has a limit `m` at `-∞`, and its derivative is integrable, then the\nintegral of the derivative on `(-∞, a)` is `f a - m`. Version assuming differentiability\non `(-∞, a)` and continuity at `a⁻`. ", "terms": "[\n    \"Fundamental theorem of calculus-2\",\n    \"semi-infinite intervals\",\n    \"function\",\n    \"limit\",\n    \"derivative\",\n    \"integrable\",\n    \"integral\",\n    \"differentiability\",\n    \"continuity\"\n]"}
{"type": "∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type w} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace 𝕜] {ι : Type u_1} [inst_6 : Finite ι] (v : Basis ι 𝕜 E),\n  ∃ C > 0, ∀ {u : E →L[𝕜] F} (M : NNReal), (∀ (i : ι), ‖u (v i)‖₊ ≤ M) → ‖u‖₊ ≤ C * M", "name": "Basis.exists_op_nnnorm_le", "isProp": true, "docString": "A weaker version of `Basis.op_nnnorm_le` that abstracts away the value of `C`. ", "terms": "[\"weaker version\", \"Basis.op_nnnorm_le\", \"abstracts away\", \"value\"]"}
{"type": "∀ {ι : Type u_1} {α : Type u_2} [inst : LinearOrderedRing α] {s : Finset ι} {σ : Equiv.Perm ι} {f g : ι → α},\n  MonovaryOn f g ↑s →\n    {x | σ x ≠ x} ⊆ ↑s →\n      (((Finset.sum s fun i => f (σ i) * g i) < Finset.sum s fun i => f i * g i) ↔ ¬MonovaryOn (f ∘ ⇑σ) g ↑s)", "name": "MonovaryOn.sum_comp_perm_mul_lt_sum_mul_iff", "isProp": true, "docString": "**Strict inequality case of Rearrangement Inequality**: Pointwise multiplication of\n`f` and `g`, which monovary together, is strictly decreased by a permutation if and only if\n`f ∘ σ` and `g` do not monovary together. Stated by permuting the entries of `f`. ", "terms": "[\n    \"Strict inequality\",\n    \"Rearrangement Inequality\",\n    \"Pointwise multiplication\",\n    \"Monovary together\",\n    \"Strictly decreased\",\n    \"Permutation\",\n    \"Entries\"\n]"}
{"type": "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {H : Type u_2} [inst_1 : TopologicalSpace H] {E : Type u_3}\n  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace 𝕜 E] (I : ModelWithCorners 𝕜 E H) {G : Type u_5}\n  [inst_4 : TopologicalSpace G] [inst_5 : ChartedSpace H G] [inst_6 : Group G] [inst : LieGroup I G], TopologicalGroup G", "name": "topologicalGroup_of_lieGroup", "isProp": true, "docString": "A Lie group is a topological group. This is not an instance for technical reasons,\nsee note [Design choices about smooth algebraic structures]. ", "terms": "[\n    \"Lie group\",\n    \"topological group\",\n    \"smooth algebraic structures\"\n]"}
{"type": "∀ {R : Type u_1} {M : Type u_2} [inst : Monoid M] [inst_1 : CommRing R] [inst_2 : Nontrivial R],\n  Algebra.FiniteType R (MonoidAlgebra R M) ↔ Monoid.FG M", "name": "MonoidAlgebra.finiteType_iff_fg", "isProp": true, "docString": "A monoid `M` is finitely generated if and only if `MonoidAlgebra R M` is of finite type. ", "terms": "[\n  \"monoid\",\n  \"finitely generated\",\n  \"MonoidAlgebra\",\n  \"finite type\"\n]"}
{"type": "∀ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} {N : Type u_5} [inst_1 : AddGroup N] (f : N →+ G),\n  AddSubgroup.comap f (AddSubgroup.normalizer H) ≤ AddSubgroup.normalizer (AddSubgroup.comap f H)", "name": "AddSubgroup.le_normalizer_comap", "isProp": true, "docString": "The preimage of the normalizer is contained in the normalizer of the preimage.", "terms": "[\n    \"preimage\",\n    \"normalizer\",\n    \"contained\"\n]"}
{"type": "List ℕ → ℕ → List ℕ", "name": "Denumerable.raise'", "isProp": false, "docString": "Outputs the list of partial sums plus one of the input list, that is\n`raise [a₁, a₂, a₃, ...] n = [n + a₁, n + a₁ + a₂ + 1, n + a₁ + a₂ + a₃ + 2, ...]`. Adding one each\ntime ensures the elements are distinct. ", "terms": "[\n  \"Outputs\",\n  \"list\",\n  \"partial sums\",\n  \"plus\",\n  \"one\",\n  \"input\",\n  \"Adding\",\n  \"each\",\n  \"time\",\n  \"ensures\",\n  \"elements\",\n  \"are\",\n  \"distinct\"\n]"}
{"type": "∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : TopologicalSpace R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {ι : Type u_3} [inst_4 : TopologicalRing R] [inst_5 : TopologicalSpace M]\n  [inst_6 : TopologicalAddGroup M] {p : ι → Prop} {b : ι → Set M},\n  Filter.HasBasis (nhds 0) p b →\n    (∀ {i : ι}, p i → ∃ V ∈ nhds 0, ∃ j, ∃ (_ : p j), V • b j ⊆ b i) →\n      (∀ (x₀ : R) {i : ι}, p i → ∃ j, ∃ (_ : p j), b j ⊆ (fun x => x₀ • x) ⁻¹' b i) →\n        (∀ (m₀ : M) {i : ι}, p i → ∀ᶠ (x : R) in nhds 0, x • m₀ ∈ b i) → ContinuousSMul R M", "name": "ContinuousSMul.of_basis_zero", "isProp": true, "docString": "A topological add group with a basis of `𝓝 0` satisfying the axioms of `ModuleFilterBasis`\nis a topological module.\n\nThis lemma is mathematically useless because one could obtain such a result by applying\n`ModuleFilterBasis.continuousSMul` and use the fact that group topologies are characterized\nby their neighborhoods of 0 to obtain the `ContinuousSMul` on the pre-existing topology.\n\nBut it turns out it's just easier to get it as a byproduct of the proof, so this is just a free\nquality-of-life improvement. ", "terms": "[\n    \"topological add group\",\n    \"basis\",\n    \"𝓝 0\",\n    \"axioms\",\n    \"ModuleFilterBasis\",\n    \"topological module\",\n    \"lemma\",\n    \"ModuleFilterBasis.continuousSMul\",\n    \"group topologies\",\n    \"neighborhoods of 0\",\n    \"ContinuousSMul\",\n    \"pre-existing topology\",\n    \"proof\"\n]"}
{"type": "{R : Type u} →\n  {A : Type v} →\n    [inst : CommSemiring R] →\n      [inst_1 : Semiring A] →\n        [inst_2 : Algebra R A] →\n          {α : Type u_1} → [inst_3 : AddCommMonoid α] → [inst_4 : Module A α] → (S : Subalgebra R A) → Module (↥S) α", "name": "Subalgebra.moduleLeft", "isProp": false, "docString": "The action by a subalgebra is the action by the underlying algebra. ", "terms": "[\"action\", \"subalgebra\", \"underlying algebra\"]"}
{"type": "∀ {α : Type u} [self : LinearOrderedSemiring α] (a b : α), compare a b = compareOfLessAndEq a b", "name": "LinearOrderedSemiring.compare_eq_compareOfLessAndEq", "isProp": true, "docString": "Comparison via `compare` is equal to the canonical comparison given decidable `<` and `=`. ", "terms": "[\"Comparison\", \"compare\", \"equal\", \"canonical comparison\", \"decidable\", \"<\", \"=\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      {X Y : C} → (c : CategoryTheory.Limits.BinaryBicone X Y) → CategoryTheory.Limits.KernelFork c.fst", "name": "CategoryTheory.Limits.BinaryBicone.fstKernelFork", "isProp": false, "docString": "A kernel fork for the kernel of `BinaryBicone.fst`. It consists of the morphism\n`BinaryBicone.inr`. ", "terms": "[\n    \"kernel\",\n    \"BinaryBicone.fst\",\n    \"morphism\",\n    \"BinaryBicone.inr\"\n]"}
{"type": "{α : Type u_1} → [inst : LT α] → Set α → ℕ∞", "name": "Set.chainHeight", "isProp": false, "docString": "The maximal length of a strictly ascending sequence in a partial order. ", "terms": "[\n  \"maximal\", \n  \"length\", \n  \"strictly ascending sequence\", \n  \"partial order\"\n]"}
{"type": "∀ {α : Type u_1} [inst : Mul α] [inst_1 : LT α]\n  [inst_2 : ContravariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a b c : α}, a * b < a * c → b < c", "name": "OrderedCommGroup.lt_of_mul_lt_mul_left", "isProp": true, "docString": "**Alias** of `lt_of_mul_lt_mul_left'`.", "terms": "[\"Alias\", \"lt_of_mul_lt_mul_left\"]"}
{"type": "(M : Type u_1) → [inst : Monoid M] → (R : Type v) → [inst_1 : Semiring R] → [inst : MulSemiringAction M R] → M → R →+* R", "name": "MulSemiringAction.toRingHom", "isProp": false, "docString": "Each element of the monoid defines a semiring homomorphism. ", "terms": "[\n  \"element\",\n  \"monoid\",\n  \"defines\",\n  \"semiring\",\n  \"homomorphism\"\n]"}
{"type": "{J K : Type v} →\n  [inst : CategoryTheory.SmallCategory J] →\n    [inst_1 : CategoryTheory.SmallCategory K] →\n      {C : Type u} →\n        [inst_2 : CategoryTheory.Category.{v, u} C] →\n          (F : CategoryTheory.Functor J (CategoryTheory.Functor K C)) →\n            [inst_3 : CategoryTheory.Limits.HasColimitsOfShape K C] → CategoryTheory.Limits.DiagramOfCocones F", "name": "CategoryTheory.Limits.DiagramOfCocones.mkOfHasColimits", "isProp": false, "docString": "Given a functor `F : J ⥤ K ⥤ C`, with all needed colimits,\nwe can construct a diagram consisting of the colimit cocone over each functor `F.obj j`,\nand the universal cocone morphisms between these.\n", "terms": "[\n  \"functor\",\n  \"colimits\",\n  \"construct\",\n  \"diagram\",\n  \"colimit cocone\",\n  \"functor\",\n  \"universal cocone morphisms\"\n]"}
{"type": "∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {x y z : 𝕜},\n  x < y → (z ∈ Set.Ioo x y ↔ ∃ a b, 0 < a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z)", "name": "Convex.mem_Ioo", "isProp": true, "docString": "A point is in an `Ioo` iff it can be expressed as a strict convex combination of the endpoints.\n", "terms": "[\n    \"point\",\n    \"Ioo\",\n    \"expressed\",\n    \"strict convex combination\",\n    \"endpoints\"\n]"}
{"type": "{X Y : TopCat} →\n  (A : Type u_1) →\n    [inst : CategoryTheory.Category.{w, u_1} A] →\n      [inst_1 : CategoryTheory.ConcreteCategory A] →\n        [inst_2 : CategoryTheory.Limits.HasColimits A] →\n          [inst_3 : CategoryTheory.Limits.HasLimits A] →\n            [inst_4 : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget A)] →\n              [inst_5 : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget A)] →\n                [inst_6 : CategoryTheory.ReflectsIsomorphisms (CategoryTheory.forget A)] →\n                  (f : X ⟶ Y) →\n                    TopCat.Sheaf.pullback A f ≅\n                      CategoryTheory.Functor.comp (TopCat.Sheaf.forget A Y)\n                        (CategoryTheory.Functor.comp (TopCat.Presheaf.pullback A f)\n                          (CategoryTheory.presheafToSheaf (Opens.grothendieckTopology ↑X) A))", "name": "TopCat.Sheaf.pullbackIso", "isProp": false, "docString": "The pullback of a sheaf is isomorphic (actually definitionally equal) to the sheafification\nof the pullback as a presheaf.\n", "terms": "[\n    \"pullback\",\n    \"sheaf\",\n    \"isomorphic\",\n    \"sheafification\",\n    \"presheaf\"\n]"}
{"type": "(K : Type u_1) →\n  [inst : Field K] → (L : Type u_2) → [inst_1 : Field L] → [inst_2 : Algebra K L] → Set (IntermediateField K L)", "name": "finiteExts", "isProp": false, "docString": "Given a field extension `L/K`, `finiteExts K L` is the set of\nintermediate field extensions `L/E/K` such that `E/K` is finite ", "terms": "[\n  \"field extension\",\n  \"set\",\n  \"intermediate field extensions\",\n  \"finite\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (K : Submodule 𝕜 E) [inst_3 : CompleteSpace E], CompleteSpace ↥Kᗮ", "name": "Submodule.instOrthogonalCompleteSpace", "isProp": true, "docString": "In a complete space, the orthogonal complement of any submodule `K` is complete. ", "terms": "[\n  \"complete space\",\n  \"orthogonal complement\",\n  \"submodule\",\n  \"complete\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Abelian C] →\n      {X Y : C} → (f : X ⟶ Y) → CategoryTheory.Abelian.coimage f ≅ CategoryTheory.Limits.image f", "name": "CategoryTheory.Abelian.coimageIsoImage'", "isProp": false, "docString": "There is a canonical isomorphism between the abelian coimage and the categorical image of a\nmorphism. ", "terms": "[\n    \"canonical\",\n    \"isomorphism\",\n    \"abelian\",\n    \"coimage\",\n    \"categorical\",\n    \"image\",\n    \"morphism\"\n]"}
{"type": "{G : Type u} → [inst : AddGroup G] → AddGroupFilterBasis G → TopologicalSpace G", "name": "AddGroupFilterBasis.topology", "isProp": false, "docString": "The topological space structure coming from an additive group filter basis.", "terms": "[\n  \"Topological Space\",\n  \"Structure\",\n  \"Additive Group\",\n  \"Filter Basis\"\n]"}
{"type": "∀ {R : Type u_1} {M : Type u_2} {M₂ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup M₂]\n  [inst_3 : Module R M] [inst_4 : Module R M₂] (f : M ≃ₗ[R] M₂) (p : Submodule R M),\n  FiniteDimensional.finrank R ↥(Submodule.map (↑f) p) = FiniteDimensional.finrank R ↥p", "name": "LinearEquiv.finrank_map_eq", "isProp": true, "docString": "Pushforwards of finite-dimensional submodules along a `LinearEquiv` have the same finrank. ", "terms": "[\n    \"Pushforwards\",\n    \"finite-dimensional\",\n    \"submodules\",\n    \"LinearEquiv\",\n    \"finrank\"\n]"}
{"type": "∀ {α : Type u} [inst : HasSubset α] [inst_1 : HasSSubset α]\n  [inst_2 : IsNonstrictStrictOrder α (fun x x_1 => x ⊆ x_1) fun x x_1 => x ⊂ x_1] {a b c : α}\n  [inst_3 : IsTrans α fun x x_1 => x ⊆ x_1], a ⊂ b → b ⊆ c → a ⊂ c", "name": "HasSSubset.SSubset.trans_subset", "isProp": true, "docString": "**Alias** of `ssubset_of_ssubset_of_subset`.", "terms": "[\"Alias\", \"ssubset_of_ssubset_of_subset\"]"}
{"type": "{α : Type u_1} → {β : Type u_2} → Filter α → Filter β → Filter (α × β)", "name": "Filter.coprod", "isProp": false, "docString": "Coproduct of filters. ", "terms": "[\n    \"Coproduct\",\n    \"Filters\"\n]"}
{"type": "{R : Type u_1} → [inst : CommSemiring R] → {M : Submonoid R} → ↥M → R →+ Localization M", "name": "Localization.mkAddMonoidHom", "isProp": false, "docString": "For any given denominator `b : M`, the map `a ↦ a / b` is an `AddMonoidHom` from `R` to\n`Localization M`", "terms": "[\n  \"denominator\",\n  \"map\",\n  \"AddMonoidHom\",\n  \"Localization\"\n]"}
{"type": "∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α} {r : ℝ},\n  0 ≤ r → (∀ x ∈ s, ∃ y ∈ t, dist x y ≤ r) → (∀ x ∈ t, ∃ y ∈ s, dist x y ≤ r) → Metric.hausdorffDist s t ≤ r", "name": "Metric.hausdorffDist_le_of_mem_dist", "isProp": true, "docString": "Bounding the Hausdorff distance by exhibiting, for any point in each set,\nanother point in the other set at controlled distance ", "terms": "[\n    \"Bounding\",\n    \"Hausdorff distance\",\n    \"point\",\n    \"set\",\n    \"controlled distance\"\n]"}
{"type": "∀ (x : ℝ), 0 < Real.cosh x", "name": "Real.cosh_pos", "isProp": true, "docString": "`Real.cosh` is always positive ", "terms": "[\"Real.cosh\", \"positive\"]"}
{"type": "{α : Type u_1} →\n  {m : MeasurableSpace α} → MeasureTheory.ComplexMeasure α → MeasureTheory.Measure α → MeasureTheory.ComplexMeasure α", "name": "MeasureTheory.ComplexMeasure.singularPart", "isProp": false, "docString": "The singular part between a complex measure `c` and a positive measure `μ` is the complex\nmeasure satisfying `c.singularPart μ + μ.withDensityᵥ (c.rnDeriv μ) = c`. This property is given\nby `MeasureTheory.ComplexMeasure.singularPart_add_withDensity_rnDeriv_eq`. ", "terms": "[\n    \"singular part\",\n    \"complex measure\",\n    \"positive measure\",\n    \"withDensityᵥ\",\n    \"rnDeriv\",\n    \"MeasureTheory.ComplexMeasure.singularPart_add_withDensity_rnDeriv_eq\"\n]"}
{"type": "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : PredOrder α] [inst_2 : IsPredArchimedean α] (r : α → α → Prop)\n  {n m : α}, (∀ i ∈ Set.Ioc n m, r (Order.pred i) i) → n < m → Relation.TransGen r n m", "name": "transGen_of_pred_of_lt", "isProp": true, "docString": "For `n < m`, `(n, m)` is in the transitive closure of a relation `~` for `n ≠ m` if `pred i ~ i`\nfor all `i` between `n` and `m`. ", "terms": "[\n  \"Transitive closure\",\n  \"Relation\",\n  \"Between\",\n  \"For all\"\n]"}
{"type": "∀ {α : Type u_1} [inst : Semigroup α] {a b : α} (c : α), a * c = b → a ∣ b", "name": "dvd_of_mul_right_eq", "isProp": true, "docString": "**Alias** of `Dvd.intro`.", "terms": "[]"}
{"type": "{B : Type u_2} →\n  {F : Type u_3} →\n    {Z : Type u_5} →\n      [inst : TopologicalSpace B] →\n        [inst_1 : TopologicalSpace F] →\n          {proj : Z → B} → [inst_2 : TopologicalSpace Z] → Trivialization F proj → Z → B × F", "name": "Trivialization.toFun'", "isProp": false, "docString": "Coercion of a trivialization to a function. We don't use `e.toFun` in the `CoeFun` instance\nbecause it is actually `e.toPartialEquiv.toFun`, so `simp` will apply lemmas about\n`toPartialEquiv`. While we may want to switch to this behavior later, doing it mid-port will break a\nlot of proofs.  ", "terms": "[\"Coercion\", \"trivialization\", \"function\", \"CoeFun\", \"instance\", \"toPartialEquiv\", \"lemmas\", \"proofs\"]"}
{"type": "{d : ℤ} → One (ℤ√d)", "name": "Zsqrtd.instOneZsqrtd", "isProp": false, "docString": "The one of the ring ", "terms": "[\"ring\"]"}
{"type": "(R : Type u_3) →\n  (A : Type u_4) → [inst : Semiring R] → [inst_1 : AddCommMonoid A] → [inst_2 : Module R A] → A →ₗ[R] Unitization R A", "name": "Unitization.inrHom", "isProp": false, "docString": "The canonical `R`-linear inclusion `A → Unitization R A`. ", "terms": "[\n  \"Canonical\",\n  \"R-linear\",\n  \"Inclusion\",\n  \"Unitization\"\n]"}
{"type": "{α : Type u_2} → [inst : CompletePartialOrder α] → OmegaCompletePartialOrder α", "name": "CompletePartialOrder.toOmegaCompletePartialOrder", "isProp": false, "docString": "A complete partial order is an ω-complete partial order. ", "terms": "[\n    \"complete partial order\", \n    \"ω-complete partial order\"\n]"}
{"type": "∀ {α : Type u_2} {A : Set α} {β : Type u_7} [inst : CommMonoid α] [inst_1 : CommMonoid β] {n : ℕ} (self : A →*[n] β)\n  {s t : Multiset α},\n  (∀ ⦃x : α⦄, x ∈ s → x ∈ A) →\n    (∀ ⦃x : α⦄, x ∈ t → x ∈ A) →\n      Multiset.card s = n →\n        Multiset.card t = n →\n          Multiset.prod s = Multiset.prod t →\n            Multiset.prod (Multiset.map self.toFun s) = Multiset.prod (Multiset.map self.toFun t)", "name": "FreimanHom.map_prod_eq_map_prod'", "isProp": true, "docString": "An `n`-Freiman homomorphism preserves products of `n` elements. ", "terms": "[\n    \"Freiman homomorphism\",\n    \"preserves\",\n    \"products\",\n    \"elements\"\n]"}
{"type": "{α : Type u_1} → [inst : PartialOrder α] → NonemptyInterval α ↪o Set α", "name": "NonemptyInterval.coeHom", "isProp": false, "docString": "Consider a nonempty interval `[a, b]` as the set `[a, b]`. ", "terms": "[\"nonempty\", \"interval\", \"set\"]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v, u₁} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      {D : Type u₂} →\n        [inst_2 : CategoryTheory.Category.{v, u₂} D] →\n          [inst_3 : CategoryTheory.Abelian D] →\n            (F : CategoryTheory.Functor C D) →\n              (G : CategoryTheory.Functor D C) →\n                [inst_4 : CategoryTheory.Functor.PreservesZeroMorphisms G] →\n                  (CategoryTheory.Functor.comp F G ≅ CategoryTheory.Functor.id C) →\n                    (G ⊣ F) →\n                      [inst_5 : CategoryTheory.Limits.HasCokernels C] →\n                        [inst_6 : CategoryTheory.Limits.HasKernels C] →\n                          [inst_7 : CategoryTheory.Limits.PreservesFiniteLimits G] →\n                            [inst_8 : CategoryTheory.Functor.PreservesZeroMorphisms F] →\n                              {X Y : C} →\n                                (f : X ⟶ Y) → CategoryTheory.Abelian.coimage f ≅ CategoryTheory.Abelian.image f", "name": "CategoryTheory.AbelianOfAdjunction.coimageIsoImage", "isProp": false, "docString": "Auxiliary definition: the abelian coimage and abelian image agree.\nWe still need to check that this agrees with the canonical morphism.\n", "terms": "[\n    \"Auxiliary definition\",\n    \"abelian\",\n    \"coimage\",\n    \"image\",\n    \"agrees\",\n    \"canonical\",\n    \"morphism\"\n]"}
{"type": "{R : Type u} →\n  {A : Type v} →\n    {B : Type w} →\n      [inst : CommSemiring R] →\n        [inst_1 : Semiring A] →\n          [inst_2 : Semiring B] → [inst_3 : Algebra R A] → [inst_4 : Algebra R B] → (A →ₐ[R] B) → A →ₗ[R] B", "name": "AlgHom.toLinearMap", "isProp": false, "docString": "R-Alg ⥤ R-Mod ", "terms": "[\"R-Alg\", \"⥤\", \"R-Mod\"]"}
{"type": "{α : Type u_1} → {β : Type u_2} → [inst : TopologicalSpace α] → [inst_1 : TopologicalSpace β] → C(α, β) → α → β", "name": "ContinuousMap.toFun", "isProp": false, "docString": "The function `α → β` ", "terms": "The statement provided contains no mathematical terms. It only includes variable names (`α`, `β`) and an arrow symbol (`→`) representing a function or mapping from `α` to `β`. However, these are not considered mathematical terms.\n\nHere's the expected output:\n\n    []"}
{"type": "{G : Type u_1} → {M : Type u_2} → [inst : AddGroup G] → [inst_1 : AddMonoid M] → (G →+ M) → G →+ AddUnits M", "name": "AddMonoidHom.toHomAddUnits", "isProp": false, "docString": "If `f` is a homomorphism from an additive group `G` to an additive monoid `M`,\nthen its image lies in the `AddUnits` of `M`,\nand `f.toHomUnits` is the corresponding homomorphism from `G` to `AddUnits M`.", "terms": "[\n  \"homomorphism\",\n  \"additive group\",\n  \"additive monoid\",\n  \"image\",\n  \"AddUnits\",\n  \"corresponding\"\n]"}
{"type": "(k : Type u_1) → [inst : Ring k] → {ι : Type u_4} → [inst : DecidableEq ι] → ι → ι → ι → k", "name": "Finset.weightedVSubVSubWeights", "isProp": false, "docString": "Weights for expressing the subtraction of two points as a `weightedVSub`. ", "terms": "[\"Weights\", \"expressing\", \"subtraction\", \"two points\", \"weightedVSub\"]"}
{"type": "{R : Type u_1} →\n  {L : Type u_2} →\n    [inst : CommRing R] →\n      [inst_1 : LieRing L] →\n        [inst_2 : LieAlgebra R L] →\n          (H : LieSubalgebra R L) → [inst_3 : LieAlgebra.IsNilpotent R ↥H] → LieAlgebra.LieCharacter R ↥H → Prop", "name": "LieAlgebra.IsRoot", "isProp": false, "docString": "A root of a Lie algebra `L` with respect to a nilpotent subalgebra `H ⊆ L` is a weight of `L`,\nregarded as a module of `H` via the adjoint action. ", "terms": "[\n    \"root\",\n    \"Lie algebra\",\n    \"nilpotent subalgebra\",\n    \"weight\",\n    \"module\",\n    \"adjoint action\"\n]"}
{"type": "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : MeasurableSpace α] →\n      [inst_1 : SemilatticeSup β] →\n        [inst_2 : OrderBot β] → [inst_3 : Zero β] → (ℕ → β) → (α → β) → ℕ → MeasureTheory.SimpleFunc α β", "name": "MeasureTheory.SimpleFunc.approx", "isProp": false, "docString": "Fix a sequence `i : ℕ → β`. Given a function `α → β`, its `n`-th approximation\nby simple functions is defined so that in case `β = ℝ≥0∞` it sends each `a` to the supremum\nof the set `{i k | k ≤ n ∧ i k ≤ f a}`, see `approx_apply` and `iSup_approx_apply` for details. ", "terms": "[\n  \"sequence\",\n  \"function\",\n  \"approximation\",\n  \"simple functions\",\n  \"case\",\n  \"sends\",\n  \"supremum\",\n  \"set\",\n  \"details\"\n]"}
{"type": "∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] {n : ℤ} {a b : α}, n ≠ 0 → (n • a = n • b ↔ a = b)", "name": "zsmul_eq_zsmul_iff'", "isProp": true, "docString": "Alias of `zsmul_right_inj`, for ease of discovery alongside\n`zsmul_le_zsmul_iff'` and `zsmul_lt_zsmul_iff'`.", "terms": "The mathematical terms in the statement are all related to the operation of multiplication in the integers (`zsmul`). The terms are:\n\n- `zsmul_right_inj`\n- `zsmul_le_zsmul_iff`\n- `zsmul_lt_zsmul_iff`\n\nHere they are in a JSON list:\n\n```\n[\n  \"zsmul_right_inj\",\n  \"zsmul_le_zsmul_iff\",\n  \"zsmul_lt_zsmul_iff\"\n]\n```"}
{"type": "{α : Type u_1} → Array α → ℕ → α → Array α", "name": "Array.setD", "isProp": false, "docString": "Set an element in an array, or do nothing if the index is out of bounds.\n\nThis will perform the update destructively provided that `a` has a reference\ncount of 1 when called.\n", "terms": "[\"set\", \"element\", \"array\", \"index\", \"out of bounds\", \"update\", \"destructively\", \"reference count\"]"}
{"type": "∀ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {s : Set M}\n  {p : M → M → Prop} {a b : M},\n  a ∈ Submodule.span R s →\n    b ∈ Submodule.span R s →\n      (∀ x ∈ s, ∀ y ∈ s, p x y) →\n        (∀ (y : M), p 0 y) →\n          (∀ (x : M), p x 0) →\n            (∀ (x₁ x₂ y : M), p x₁ y → p x₂ y → p (x₁ + x₂) y) →\n              (∀ (x y₁ y₂ : M), p x y₁ → p x y₂ → p x (y₁ + y₂)) →\n                (∀ (r : R) (x y : M), p x y → p (r • x) y) → (∀ (r : R) (x y : M), p x y → p x (r • y)) → p a b", "name": "Submodule.span_induction₂", "isProp": true, "docString": "An induction principle for span membership. This is a version of `Submodule.span_induction`\nfor binary predicates. ", "terms": "[\"induction principle\", \"span membership\", \"Submodule.span_induction\", \"binary predicates\"]"}
{"type": "{α : Type u_1} →\n  [inst : MetricSpace α] →\n    {m0 : MeasurableSpace α} →\n      {μ : MeasureTheory.Measure α} →\n        VitaliFamily μ → (ν : MeasureTheory.Measure α) → MeasureTheory.Measure.AbsolutelyContinuous ν μ → VitaliFamily ν", "name": "VitaliFamily.mono", "isProp": false, "docString": "A Vitali family for a measure `μ` is also a Vitali family for any measure absolutely continuous\nwith respect to `μ`. ", "terms": "[\n    \"Vitali family\",\n    \"measure\",\n    \"absolutely continuous\"\n]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X Y : C} {P : CategoryTheory.Subobject Y}\n  {f g : X ⟶ CategoryTheory.Subobject.underlying.obj P},\n  CategoryTheory.CategoryStruct.comp f (CategoryTheory.Subobject.arrow P) =\n      CategoryTheory.CategoryStruct.comp g (CategoryTheory.Subobject.arrow P) →\n    f = g", "name": "CategoryTheory.Subobject.eq_of_comp_arrow_eq", "isProp": true, "docString": "Two morphisms into a subobject are equal exactly if\nthe morphisms into the ambient object are equal ", "terms": "[\n  \"morphisms\",\n  \"subobject\",\n  \"equal\",\n  \"ambient object\"\n]"}
{"type": "(α : Type u_1) → [inst : Preorder α] → LowerAdjoint id", "name": "LowerAdjoint.id", "isProp": false, "docString": "The identity function as a lower adjoint to itself. ", "terms": "[\n    \"Identity function\",\n    \"Lower adjoint\"\n]"}
{"type": "∀ (𝕜 : Type u) [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] {r : ℝ},\n  0 < r → IsCompact (Metric.closedBall 0 r) → FiniteDimensional 𝕜 E", "name": "finiteDimensional_of_isCompact_closedBall₀", "isProp": true, "docString": "**Riesz's theorem**: if a closed ball with center zero of positive radius is compact in a vector\nspace, then the space is finite-dimensional. ", "terms": "[\n    \"Riesz's theorem\",\n    \"closed ball\",\n    \"center\",\n    \"zero\",\n    \"positive radius\",\n    \"compact\",\n    \"vector space\",\n    \"finite-dimensional\"\n]"}
{"type": "{α : Type u_1} → α → WithTop α → α", "name": "WithTop.untop'", "isProp": false, "docString": "Specialization of `Option.getD` to values in `WithTop α` that respects API boundaries.\n", "terms": "[\"Specialization\", \"Option.getD\", \"values\", \"WithTop α\", \"respects\", \"API boundaries\"]"}
{"type": "{α : Sort u₁} →\n  {β : Sort u₂} → {φ : Sort u₃} → {δ : Sort u₄} → {ζ : Sort u₅} → (α → β → φ) → (φ → δ → ζ) → (α → β → δ) → α → β → ζ", "name": "Function.combine", "isProp": false, "docString": "Given functions `f : α → β → φ`, `g : α → β → δ` and a binary operator `op : φ → δ → ζ`,\nproduce a function `α → β → ζ` that applies `f` and `g` on each argument and then applies\n`op` to the results.\n", "terms": "[\n    \"functions\",\n    \"binary operator\",\n    \"argument\",\n    \"applies\",\n    \"results\"\n]"}
{"type": "{α : Type u_1} →\n  [inst : UniformSpace α] →\n    (pkg : AbstractCompletion α) →\n      {β : Type u_2} →\n        [inst_1 : UniformSpace β] →\n          (pkg' : AbstractCompletion β) →\n            {γ : Type u_3} → [inst_2 : UniformSpace γ] → (α → β → γ) → pkg.space → pkg'.space → γ", "name": "AbstractCompletion.extend₂", "isProp": false, "docString": "Extend two variable map to completions. ", "terms": "[\"Extend\", \"two variable map\", \"completions\"]"}
{"type": "(C : Type u_1) →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      CategoryTheory.MonoidalFunctor (CategoryTheory.EndMonoidal (CategoryTheory.MonoidalSingleObj.star C)) C", "name": "CategoryTheory.MonoidalSingleObj.endMonoidalStarFunctor", "isProp": false, "docString": "The monoidal functor from the endomorphisms of the single object\nwhen we promote a monoidal category to a single object bicategory,\nto the original monoidal category.\n\nWe subsequently show this is an equivalence.\n", "terms": "[\n    \"monoidal functor\",\n    \"endomorphisms\",\n    \"single object\",\n    \"monoidal category\",\n    \"single object bicategory\",\n    \"original monoidal category\",\n    \"equivalence\"\n]"}
{"type": "{V : Type u_1} →\n  {P : Type u_2} →\n    [inst : NormedAddCommGroup V] →\n      [inst_1 : InnerProductSpace ℝ V] →\n        [inst_2 : MetricSpace P] →\n          [inst_3 : NormedAddTorsor V P] → {n : ℕ} → Affine.Simplex ℝ P (n + 1) → Fin (n + 2) → AffineSubspace ℝ P", "name": "Affine.Simplex.altitude", "isProp": false, "docString": "An altitude of a simplex is the line that passes through a vertex\nand is orthogonal to the opposite face. ", "terms": "[\n  \"altitude\",\n  \"simplex\",\n  \"line\",\n  \"passes through\",\n  \"vertex\",\n  \"orthogonal\",\n  \"opposite face\"\n]"}
{"type": "(𝕜 : Type u_1) →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type u_2} →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : NormedSpace 𝕜 E] →\n          {H : Type u_3} →\n            [inst_3 : TopologicalSpace H] →\n              ModelWithCorners 𝕜 E H →\n                (M : Type u_4) → [inst : TopologicalSpace M] → [inst : ChartedSpace H M] → ℕ∞ → M → Type (max 0 u_4 u_1)", "name": "PointedSmoothMap", "isProp": false, "docString": "Type synonym, introduced to put a different `SMul` action on `C^n⟮I, M; 𝕜⟯`\nwhich is defined as `f • r = f(x) * r`. ", "terms": "[\n    \"Type synonym\",\n    \"SMul\",\n    \"C^n⟮I, M; 𝕜⟯\",\n    \"defined\",\n    \"action\",\n    \"f • r = f(x) * r\"\n]"}
{"type": "{k : Type u₁} →\n  {G : Type u₂} →\n    {R : Type u_2} →\n      [inst : CommSemiring R] →\n        [inst_1 : Semiring k] → [inst_2 : Algebra R k] → [inst_3 : AddMonoid G] → k →ₐ[R] AddMonoidAlgebra k G", "name": "AddMonoidAlgebra.singleZeroAlgHom", "isProp": false, "docString": "`Finsupp.single 0` as an `AlgHom` ", "terms": "[\n  \"Finsupp.single\",\n  \"AlgHom\"\n]"}
{"type": "{α : Type u_2} →\n  {β : Type u_3} →\n    [inst : PartialOrder α] → [inst_1 : PartialOrder β] → ((fun x x_1 => x < x_1) ↪r fun x x_1 => x < x_1) → α ↪o β", "name": "RelEmbedding.orderEmbeddingOfLTEmbedding", "isProp": false, "docString": "Embeddings of partial orders that preserve `<` also preserve `≤`. ", "terms": "[\"Embeddings\", \"partial orders\", \"preserve\", \"<\", \"≤\"]"}
{"type": "∀ {𝕜 : Type u} {A : Type v} [inst : Field 𝕜] [inst_1 : Ring A] [inst_2 : Algebra 𝕜 A] [inst_3 : IsAlgClosed 𝕜] (a : A)\n  {n : ℕ}, 0 < n → spectrum 𝕜 (a ^ n) = (fun x => x ^ n) '' spectrum 𝕜 a", "name": "spectrum.map_pow_of_pos", "isProp": true, "docString": "A specialization of `spectrum.map_polynomial_aeval_of_nonempty` to monic monomials for\nconvenience. ", "terms": "[\n  \"specialization\",\n  \"spectrum\",\n  \"map_polynomial_aeval_of_nonempty\",\n  \"monic\",\n  \"monomials\"\n]"}
{"type": "{Ω : Type u_1} →\n  {β : Type u_2} →\n    {ι : Type u_3} →\n      {m : MeasurableSpace Ω} →\n        [inst : TopologicalSpace β] →\n          [inst : Preorder ι] → [inst_1 : MeasurableSpace ι] → MeasureTheory.Filtration ι m → (ι → Ω → β) → Prop", "name": "MeasureTheory.ProgMeasurable", "isProp": false, "docString": "Progressively measurable process. A sequence of functions `u` is said to be progressively\nmeasurable with respect to a filtration `f` if at each point in time `i`, `u` restricted to\n`Set.Iic i × Ω` is measurable with respect to the product `MeasurableSpace` structure where the\nσ-algebra used for `Ω` is `f i`.\nThe usual definition uses the interval `[0,i]`, which we replace by `Set.Iic i`. We recover the\nusual definition for index types `ℝ≥0` or `ℕ`. ", "terms": "[\n  \"Progressively measurable process\",\n  \"Sequence\",\n  \"Functions\",\n  \"Measurable\",\n  \"Filtration\",\n  \"Point in time\",\n  \"Restricted\",\n  \"Set\",\n  \"Product\",\n  \"MeasurableSpace structure\",\n  \"σ-algebra\",\n  \"Interval\",\n  \"Index types\"\n]"}
{"type": "∀ {α : Type u} {m : ℕ} (x : α) (u : Fin (Nat.succ m) → α), Matrix.vecCons x u 1 = Matrix.vecHead u", "name": "Matrix.cons_val_one", "isProp": true, "docString": "`![a, b, ...] 1` is equal to `b`.\n\nThe simplifier needs a special lemma for length `≥ 2`, in addition to\n`cons_val_succ`, because `1 : Fin 1 = 0 : Fin 1`.\n", "terms": "[\n  \"equal\",\n  \"lemma\",\n  \"length\",\n  \"≥\",\n  \"2\",\n  \"addition\",\n  \"cons_val_succ\",\n  \"1\",\n  \"Fin\",\n  \"1\",\n  \"0\",\n  \"Fin\",\n  \"1\"\n]"}
{"type": "{A : Type u_1} →\n  {A' : Type u_2} →\n    {B' : Type u_4} →\n      [inst : CategoryTheory.Category.{u_5, u_1} A] →\n        [inst_1 : CategoryTheory.Category.{u_6, u_2} A'] →\n          [inst_2 : CategoryTheory.Category.{u_7, u_4} B'] →\n            {eA : A ≌ A'} →\n              {e' : A' ≌ B'} →\n                {F : CategoryTheory.Functor A B'} → (CategoryTheory.Functor.comp eA.functor e'.functor ≅ F) → (A ≌ B')", "name": "AlgebraicTopology.DoldKan.Compatibility.equivalence₁", "isProp": false, "docString": "An intermediate equivalence `A ≅ B'` whose functor is `F` and whose inverse is\n`e'.inverse ⋙ eA.inverse`. ", "terms": "[\n    \"Intermediate Equivalence\",\n    \"Functor\",\n    \"Inverse\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : InnerProductSpace 𝕜 F] {T : E →ₗ.[𝕜] F},\n  Dense ↑T.domain → ∀ [inst_5 : CompleteSpace E], LinearPMap.IsFormalAdjoint (LinearPMap.adjoint T) T", "name": "LinearPMap.adjoint_isFormalAdjoint", "isProp": true, "docString": "The fundamental property of the adjoint. ", "terms": "[\"fundamental property\", \"adjoint\"]"}
{"type": "∀ {a b : ℕ}, a ≠ 0 → b ≠ 0 → List.Perm (Nat.factors (a * b)) (Nat.factors a ++ Nat.factors b)", "name": "Nat.perm_factors_mul", "isProp": true, "docString": "For positive `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` ", "terms": "[\n    \"positive\",\n    \"prime factors\",\n    \"union\"\n]"}
{"type": "{R : Type u} →\n  {A : Type w} →\n    [inst : CommSemiring R] → [inst_1 : Semiring A] → [inst_2 : Algebra R A] → (S : Subsemiring R) → Algebra (↥S) A", "name": "Algebra.ofSubsemiring", "isProp": false, "docString": "Algebra over a subsemiring. This builds upon `Subsemiring.module`. ", "terms": "[\n    \"Algebra\",\n    \"Subsemiring\",\n    \"Module\"\n]"}
{"type": "{α : Type u_1} → {β : Type u_2} → [inst : Fintype α] → [inst : DecidableEq β] → (f : α ↪ β) → ↑(Set.range ⇑f) → α", "name": "Function.Embedding.invOfMemRange", "isProp": false, "docString": "The inverse of an embedding `f : α ↪ β`, of the type `↥(Set.range f) → α`.\nThis is the computable version of `Function.invFun` that requires `Fintype α` and `DecidableEq β`,\nor the function version of applying `(Equiv.ofInjective f f.injective).symm`.\nThis function should not usually be used for actual computation because for most cases,\nan explicit inverse can be stated that has better computational properties.\nThis function computes by checking all terms `a : α` to find the `f a = b`, so it is O(N) where\n`N = Fintype.card α`.\n", "terms": "[\n    \"inverse\",\n    \"embedding\",\n    \"type\",\n    \"Set.range\",\n    \"Function.invFun\",\n    \"Fintype\",\n    \"DecidableEq\",\n    \"Equiv.ofInjective\",\n    \"symm\",\n    \"computation\",\n    \"explicit inverse\",\n    \"computational properties\",\n    \"checking all terms\",\n    \"O(N)\",\n    \"Fintype.card\"\n]"}
{"type": "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\n  Continuous f → IsClosed (Function.fixedPoints f)", "name": "isClosed_fixedPoints", "isProp": true, "docString": "The set of fixed points of a continuous map is a closed set. ", "terms": "[\n  \"Set\",\n  \"Fixed points\",\n  \"Continuous map\",\n  \"Closed set\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      [inst_2 : CategoryTheory.Limits.HasZeroObject C] → {X Y : C} → CategoryTheory.Limits.image 0 ≅ 0", "name": "CategoryTheory.Limits.imageZero", "isProp": false, "docString": "The image of a zero morphism is the zero object. ", "terms": "[\n    \"image\", \n    \"zero morphism\", \n    \"zero object\"\n]"}
{"type": "ℂ → ℂ", "name": "Complex.tan", "isProp": false, "docString": "The complex tangent function, defined as `sin z / cos z` ", "terms": "[\n    \"complex\",\n    \"tangent function\",\n    \"defined as\",\n    \"sin\",\n    \"cos\",\n    \"z\",\n    \"/\"\n]"}
{"type": "∀ {M : Type u_3} [inst : AddCommMonoid M] {s : Set M},\n  IsAddSubmonoid s → ∀ (m : Multiset M), (∀ a ∈ m, a ∈ s) → Multiset.sum m ∈ s", "name": "IsAddSubmonoid.multiset_sum_mem", "isProp": true, "docString": "The sum of a multiset of elements of an `AddSubmonoid` of an `AddCommMonoid`\nis an element of the `AddSubmonoid`. ", "terms": "[\n  \"sum\",\n  \"multiset\",\n  \"elements\",\n  \"AddSubmonoid\",\n  \"AddCommMonoid\",\n  \"element\"\n]"}
{"type": "∀ {α : Type u} [inst : UniformSpace α] (self : AbstractCompletion α), CompleteSpace self.space", "name": "AbstractCompletion.complete", "isProp": true, "docString": "The completion is complete. ", "terms": "[\"completion\", \"complete\"]"}
{"type": "∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n", "name": "Nat.minFac_sq_le_self", "isProp": true, "docString": "The square of the smallest prime factor of a composite number `n` is at most `n`.\n", "terms": "[\n    \"square\",\n    \"smallest prime factor\",\n    \"composite number\",\n    \"at most\"\n]"}
{"type": "∀ {R : Type u} [inst : Ring R] {S T : Subring R}, (∀ (x : R), x ∈ S ↔ x ∈ T) → S = T", "name": "Subring.ext", "isProp": true, "docString": "Two subrings are equal if they have the same elements. ", "terms": "[\"two\", \"subrings\", \"equal\", \"same\", \"elements\"]"}
{"type": "∀ {M : Type u_1} (c : M) (X : Type u_2) [inst : VAdd M X] [inst_1 : TopologicalSpace X] [h : ProperConstVAdd M X],\n  IsProperMap fun x => c +ᵥ x", "name": "isProperMap_vadd", "isProp": true, "docString": "`(c +ᵥ ·)` is a proper map.", "terms": "[\"proper map\", \"+ᵥ\", \"·\"]"}
{"type": "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V) (θ : Real.Angle),\n  ((Orientation.kahler o) ((Orientation.rotation o θ) x)) y =\n    (starRingEnd ℂ) ↑(Real.Angle.expMapCircle θ) * ((Orientation.kahler o) x) y", "name": "Orientation.kahler_rotation_left", "isProp": true, "docString": "Rotating the first of two vectors by `θ` scales their Kahler form by `cos θ - sin θ * I`. ", "terms": "[\n    \"Rotating\",\n    \"vectors\",\n    \"scales\",\n    \"Kahler form\",\n    \"cos\",\n    \"sin\",\n    \"I\"\n]"}
{"type": "Lean.PrettyPrinter.Delaborator.Delab", "name": "«term⨍_In_.._,_».delab", "isProp": false, "docString": "Pretty printer defined by `notation3` command. ", "terms": "[]"}
{"type": "{α : Type u_3} → {β : Type u_4} → [inst : Mul α] → [inst_1 : Mul β] → (α →ₙ* β) → (I : Type u_5) → (I → α) →ₙ* I → β", "name": "MulHom.compLeft", "isProp": false, "docString": "Semigroup homomorphism between the function spaces `I → α` and `I → β`, induced by a semigroup\nhomomorphism `f` between `α` and `β`. ", "terms": "[\n    \"Semigroup\",\n    \"Homomorphism\",\n    \"Function Spaces\",\n    \"Induced\",\n    \"α\",\n    \"β\"\n]"}
{"type": "∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (p : P) (direction : Submodule k V), p ∈ AffineSubspace.mk' p direction", "name": "AffineSubspace.self_mem_mk'", "isProp": true, "docString": "An affine subspace constructed from a point and a direction contains that point. ", "terms": "[\n    \"affine subspace\",\n    \"point\",\n    \"direction\",\n    \"contains\"\n]"}
{"type": "∀ {f : ℂ →+* ℂ}, Continuous ⇑f → f = RingHom.id ℂ ∨ f = starRingEnd ℂ", "name": "Complex.ringHom_eq_id_or_conj_of_continuous", "isProp": true, "docString": "The only continuous ring homomorphisms from `ℂ` to `ℂ` are the identity and the complex\nconjugation. ", "terms": "[\n  \"continuous\",\n  \"ring\",\n  \"homomorphisms\",\n  \"ℂ\",\n  \"identity\",\n  \"complex\",\n  \"conjugation\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {X : C} →\n      [inst_1 : CategoryTheory.Limits.HasImages C] →\n        CategoryTheory.Functor.comp (CategoryTheory.MonoOver.forget X) CategoryTheory.MonoOver.image ≅\n          CategoryTheory.Functor.id (CategoryTheory.MonoOver X)", "name": "CategoryTheory.MonoOver.forgetImage", "isProp": false, "docString": "Forgetting that a monomorphism over `X` is a monomorphism, then taking its image,\nis the identity functor.\n", "terms": "[\n    \"Forgetting\",\n    \"Monomorphism\",\n    \"Over\",\n    \"Taking\",\n    \"Image\",\n    \"Identity Functor\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : TopologicalSpace β]\n  [inst_3 : ClosedIciTopology α] [inst_4 : Nonempty β] {f : β → α},\n  Continuous f → Filter.Tendsto f (Filter.cocompact β) Filter.atBot → ∃ x, ∀ (y : β), f y ≤ f x", "name": "Continuous.exists_forall_ge", "isProp": true, "docString": "The **extreme value theorem**: if a continuous function `f` tends to negative infinity away from\ncompact sets, then it has a global maximum. ", "terms": "[\n    \"extreme value theorem\",\n    \"continuous function\",\n    \"tends\",\n    \"negative infinity\",\n    \"away from\",\n    \"compact sets\",\n    \"global maximum\"\n]"}
{"type": "∀ (R : Type u_2) {M : Type u_5} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (n : ℤ) (b : M),\n  n • b = ↑n • b", "name": "zsmul_eq_smul_cast", "isProp": true, "docString": "`zsmul` is equal to any other module structure via a cast. ", "terms": "[\n    \"zsmul\",\n    \"equal\",\n    \"module\",\n    \"structure\",\n    \"cast\"\n]"}
{"type": "∀ {𝕜 : Type u_5} [inst : NontriviallyNormedField 𝕜] {E : Type u_6} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {E' : Type u_7} [inst_3 : NormedAddCommGroup E'] [inst_4 : NormedSpace 𝕜 E'] {H : Type u_8}\n  [inst_5 : TopologicalSpace H] {I : ModelWithCorners 𝕜 E H} {H' : Type u_9} [inst_6 : TopologicalSpace H']\n  {I' : ModelWithCorners 𝕜 E' H'} (M : Type u_10) [inst_7 : TopologicalSpace M] [inst_8 : ChartedSpace H M]\n  [inst_9 : SmoothManifoldWithCorners I M] (M' : Type u_11) [inst_10 : TopologicalSpace M']\n  [inst_11 : ChartedSpace H' M'] [inst_12 : SmoothManifoldWithCorners I' M'],\n  SmoothManifoldWithCorners (ModelWithCorners.prod I I') (M × M')", "name": "SmoothManifoldWithCorners.prod", "isProp": true, "docString": "The product of two smooth manifolds with corners is naturally a smooth manifold with corners. ", "terms": "[\n    \"Product\",\n    \"Two\",\n    \"Smooth Manifolds\",\n    \"Corners\",\n    \"Naturally\",\n    \"Smooth Manifold\"\n]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.ConcreteCategory C] {X : TopCat}\n  {ℱ 𝒢 : TopCat.Presheaf C X} [inst_2 : CategoryTheory.Limits.HasColimits C]\n  [inst_3 : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)] (T : ℱ ⟶ 𝒢),\n  TopCat.Presheaf.IsLocallySurjective T ↔ ∀ (x : ↑X), Function.Surjective ⇑((TopCat.Presheaf.stalkFunctor C x).map T)", "name": "TopCat.Presheaf.locally_surjective_iff_surjective_on_stalks", "isProp": true, "docString": "An equivalent condition for a map of presheaves to be locally surjective\nis for all the induced maps on stalks to be surjective. ", "terms": "[\n    \"equivalent condition\",\n    \"map\",\n    \"presheaves\",\n    \"locally surjective\",\n    \"induced maps\",\n    \"stalks\",\n    \"surjective\"\n]"}
{"type": "∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [inst_1 : GCDMonoid α] {m n k : α},\n  k ∣ m * n → ∃ d₁ d₂, d₁ ∣ m ∧ d₂ ∣ n ∧ k = d₁ * d₂", "name": "exists_dvd_and_dvd_of_dvd_mul", "isProp": true, "docString": "Represent a divisor of `m * n` as a product of a divisor of `m` and a divisor of `n`.\n\nIn other words, the nonzero elements of a `GCDMonoid` form a decomposition monoid\n(more widely known as a pre-Schreier domain in the context of rings).\n\nNote: In general, this representation is highly non-unique.\n\nSee `Nat.prodDvdAndDvdOfDvdProd` for a constructive version on `ℕ`.  ", "terms": "[\n  \"divisor\",\n  \"product\",\n  \"nonzero elements\",\n  \"GCDMonoid\",\n  \"decomposition monoid\",\n  \"pre-Schreier domain\",\n  \"rings\",\n  \"representation\",\n  \"non-unique\",\n  \"constructive version\",\n  \"ℕ\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    (D : AlgebraicGeometry.PresheafedSpace.GlueData C) →\n      [inst_1 : CategoryTheory.Limits.HasLimits C] →\n        {i : D.J} →\n          (U : TopologicalSpace.Opens ↑↑(CategoryTheory.GlueData.U D.toGlueData i)) →\n            (CategoryTheory.GlueData.U D.toGlueData i).presheaf.obj (Opposite.op U) ⟶\n              CategoryTheory.Limits.limit (AlgebraicGeometry.PresheafedSpace.GlueData.diagramOverOpen D U)", "name": "AlgebraicGeometry.PresheafedSpace.GlueData.ιInvApp", "isProp": false, "docString": "(Implementation) The natural map `Γ(𝒪_{U_i}, U) ⟶ Γ(𝒪_X, 𝖣.ι i '' U)`.\nThis forms the inverse of `(𝖣.ι i).c.app (op U)`. ", "terms": "[\n    \"natural map\",\n    \"inverse\",\n    \"op\"\n]"}
{"type": "{α : Type u_1} → Ord α → LT α", "name": "Ord.toLT", "isProp": false, "docString": "Derive an `LT` instance from an `Ord` instance.\n", "terms": "[]"}
{"type": "{α : Type u_2} → [inst : TopologicalSpace α] → [inst_1 : T1Space α] → α → TopologicalSpace.Closeds α", "name": "TopologicalSpace.Closeds.singleton", "isProp": false, "docString": "The term of `TopologicalSpace.Closeds α` corresponding to a singleton. ", "terms": "[\n    \"TopologicalSpace\",\n    \"Closeds\",\n    \"singleton\"\n]"}
{"type": "(R : Type u) →\n  (M : Type v₁) →\n    (P : Type v₃) →\n      (Q : Type v₄) →\n        [inst : CommRing R] →\n          [inst_1 : AddCommGroup M] →\n            [inst_2 : AddCommGroup P] →\n              [inst_3 : AddCommGroup Q] →\n                [inst_4 : Module R M] →\n                  [inst_5 : Module R P] →\n                    [inst_6 : Module R Q] →\n                      [inst_7 : Module.Free R M] →\n                        [inst_8 : Module.Finite R M] → TensorProduct R P (M →ₗ[R] Q) ≃ₗ[R] M →ₗ[R] TensorProduct R P Q", "name": "lTensorHomEquivHomLTensor", "isProp": false, "docString": "When `M` is a finite free module, the map `lTensorHomToHomLTensor` is an equivalence. Note\nthat `lTensorHomEquivHomLTensor` is not defined directly in terms of\n`lTensorHomToHomLTensor`, but the equivalence between the two is given by\n`lTensorHomEquivHomLTensor_toLinearMap` and `lTensorHomEquivHomLTensor_apply`. ", "terms": "[\n    \"finite\",\n    \"free module\",\n    \"map\",\n    \"equivalence\",\n    \"defined\",\n    \"terms\",\n    \"linear map\",\n    \"apply\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {F : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup F] [inst_2 : InnerProductSpace 𝕜 F]\n  [inst_3 : CompleteSpace F] {f : F → 𝕜} {f' x : F},\n  HasGradientAt f f' x → HasFDerivAt f ((InnerProductSpace.toDual 𝕜 F) f') x", "name": "HasGradientAt.hasFDerivAt", "isProp": true, "docString": "**Alias** of the forward direction of `hasGradientAt_iff_hasFDerivAt`.", "terms": "The mathematical terms in the given statement are:\n\n1. Alias\n2. Forward direction\n3. hasGradientAt\n4. iff (if and only if)\n5. hasFDerivAt\n\nHere they are formatted as a JSON list:\n\n```json\n[\n  \"Alias\",\n  \"Forward direction\",\n  \"hasGradientAt\",\n  \"iff\",\n  \"hasFDerivAt\"\n]\n```"}
{"type": "∀ {X : Type u_1} {ι : Type u_3} [inst : TopologicalSpace X] [hι : Countable ι] (s : ι → Set X),\n  (∀ (i : ι), IsCompact (s i)) → IsSigmaCompact (⋃ i, s i)", "name": "isSigmaCompact_iUnion_of_isCompact", "isProp": true, "docString": "Countable unions of compact sets are σ-compact. ", "terms": "[\n    \"Countable unions\",\n    \"compact sets\",\n    \"σ-compact\"\n]"}
{"type": "∀ {R : Type u_1} {M : Type u_5} {n : Type u_18} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {I I' : R →+* R} [inst_3 : Nontrivial R] {B : M →ₛₗ[I] M →ₛₗ[I'] R} {v : Basis n R M},\n  LinearMap.IsOrthoᵢ B ⇑v → LinearMap.SeparatingLeft B → ∀ (i : n), ¬LinearMap.IsOrtho B (v i) (v i)", "name": "LinearMap.IsOrthoᵢ.not_isOrtho_basis_self_of_separatingLeft", "isProp": true, "docString": "An orthogonal basis with respect to a left-separating bilinear form has no self-orthogonal\nelements. ", "terms": "[\n    \"orthogonal basis\",\n    \"left-separating\",\n    \"bilinear form\",\n    \"self-orthogonal\",\n    \"elements\"\n]"}
{"type": "{α : Type u_1} →\n  {β : Type u_7} → [inst : AddMonoid β] → {x : MeasurableSpace α} → MeasureTheory.Measure α → (Set α → β) → Prop", "name": "MeasureTheory.FinMeasAdditive", "isProp": false, "docString": "A set function is `FinMeasAdditive` if its value on the union of two disjoint measurable\nsets with finite measure is the sum of its values on each set. ", "terms": "[\n    \"set function\",\n    \"FinMeasAdditive\",\n    \"value\",\n    \"union\",\n    \"disjoint\",\n    \"measurable sets\",\n    \"finite measure\",\n    \"sum\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {F : CategoryTheory.Functor C D} →\n          {G : CategoryTheory.Functor D C} →\n            (F ⊣ G) →\n              {J : Type u} →\n                [inst_2 : CategoryTheory.Category.{v, u} J] →\n                  {K : CategoryTheory.Functor J D} →\n                    (X : Cᵒᵖ) →\n                      (CategoryTheory.Functor.comp F.op ((CategoryTheory.cones J D).obj K)).obj X →\n                        ((CategoryTheory.cones J C).obj (CategoryTheory.Functor.comp K G)).obj X", "name": "CategoryTheory.Adjunction.conesIsoComponentHom", "isProp": false, "docString": "auxiliary construction for `conesIso` ", "terms": "[]"}
{"type": "∀ {α : Type u_1} [inst : Preorder α] {s : Set α}, DirSupInacc s → DirSupClosed sᶜ", "name": "DirSupInacc.compl", "isProp": true, "docString": "**Alias** of the reverse direction of `dirSupClosed_compl`.", "terms": "[\"Alias\", \"reverse direction\", \"dirSupClosed_compl\"]"}
{"type": "∀ {F : Type u_6} {α : outParam (Type u_7)} {β : outParam (Type u_8)} [inst : Bot α] [inst_1 : Bot β]\n  [self : BotHomClass F α β] (f : F), f ⊥ = ⊥", "name": "BotHomClass.map_bot", "isProp": true, "docString": "A `BotHomClass` morphism preserves the bottom element. ", "terms": "[\"BotHomClass\", \"morphism\", \"preserves\", \"bottom element\"]"}
{"type": "{M : Type u_4} → [inst : MulOneClass M] → Submonoid M → Subsemigroup M", "name": "Submonoid.toSubsemigroup", "isProp": false, "docString": "A submonoid of a monoid `M` can be considered as a subsemigroup of that monoid. ", "terms": "[\n    \"submonoid\",\n    \"monoid\",\n    \"subsemigroup\"\n]"}
{"type": "{α : Type u_1} → (α → α → Prop) → Set α → Prop", "name": "IsStrongAntichain", "isProp": false, "docString": "A strong (upward) antichain is a set such that no two distinct elements are related to a common\nelement. ", "terms": "[\n  \"Strong (upward) antichain\",\n  \"Set\",\n  \"Distinct elements\",\n  \"Related\",\n  \"Common element\"\n]"}
{"type": "∀ {A : Type u_4} [inst : AddMonoid A], FaithfulSMul (AddAut A) A", "name": "AddAut.apply_faithfulSMul", "isProp": true, "docString": "`AddAut.applyDistribMulAction` is faithful. ", "terms": "[]\n"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]\n  (F : CategoryTheory.Functor C D) [inst_2 : CategoryTheory.Functor.Initial F] [inst : CategoryTheory.IsCofiltered C],\n  CategoryTheory.IsCofiltered D", "name": "CategoryTheory.IsCofiltered.of_initial", "isProp": true, "docString": "Initial functors preserve cofilteredness.\n\nThis can be seen as a generalization of `IsCofiltered.of_left_adjoint` (which states that left\nadjoints preserve cofilteredness), as right adjoints are always initial, see `intial_of_adjunction`.\n", "terms": "[\n  \"functors\",\n  \"preserve\",\n  \"cofilteredness\",\n  \"generalization\",\n  \"IsCofiltered.of_left_adjoint\",\n  \"states\",\n  \"left adjoints\",\n  \"right adjoints\",\n  \"initial\",\n  \"initial_of_adjunction\"\n]"}
{"type": "{k : Type u_1} →\n  {V : Type u_2} →\n    [inst : Ring k] → [inst_1 : AddCommGroup V] → [inst_2 : Module k V] → Submodule k V → AffineSubspace k V", "name": "Submodule.toAffineSubspace", "isProp": false, "docString": "Reinterpret `p : Submodule k V` as an `AffineSubspace k V`. ", "terms": "[\n    \"Reinterpret\",\n    \"Submodule\",\n    \"AffineSubspace\"\n]"}
{"type": "{F : Type u → Type w} →\n  {G : Type v → Type u} →\n    [inst : Functor F] → [inst : Functor G] → {α β : Type v} → (α → β) → Functor.Comp F G α → Functor.Comp F G β", "name": "Functor.Comp.map", "isProp": false, "docString": "The map operation for the composition `Comp F G` of functors `F` and `G`. ", "terms": "[\n  \"map operation\",\n  \"composition\",\n  \"functors\"\n]"}
{"type": "{I : Type u} →\n  [inst : Inhabited I] →\n    [inst : LinearOrder I] →\n      [inst_1 : IsWellOrder I fun x x_1 => x < x_1] →\n        (C : Set (I → Bool)) → IsClosed C → Basis ↑(Profinite.NobelingProof.GoodProducts C) ℤ (LocallyConstant ↑C ℤ)", "name": "Profinite.NobelingProof.GoodProducts.Basis", "isProp": false, "docString": "`GoodProducts C` as a `ℤ`-basis for `LocallyConstant C ℤ`.  ", "terms": "[\n  \"GoodProducts\",\n  \"ℤ\",\n  \"basis\",\n  \"LocallyConstant\"\n]"}
{"type": "{J : Type u'} →\n  [inst : CategoryTheory.Category.{v', u'} J] →\n    {C : Type u} →\n      [inst_1 : CategoryTheory.Category.{v, u} C] →\n        (F : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)) →\n          [inst_2 : CategoryTheory.Limits.HasColimit F] →\n            TopologicalSpace.Opens ↑↑(CategoryTheory.Limits.colimit F) → CategoryTheory.Functor Jᵒᵖ C", "name": "AlgebraicGeometry.PresheafedSpace.componentwiseDiagram", "isProp": false, "docString": "Given a diagram of `PresheafedSpace C`s, its colimit is computed by pushing the sheaves onto\nthe colimit of the underlying spaces, and taking componentwise limit.\nThis is the componentwise diagram for an open set `U` of the colimit of the underlying spaces.\n", "terms": "[\n    \"PresheafedSpace\",\n    \"colimit\",\n    \"pushing\",\n    \"sheaves\",\n    \"underlying spaces\",\n    \"componentwise limit\",\n    \"componentwise diagram\",\n    \"open set\"\n]"}
{"type": "∀ {M : Type u_1} [inst : MulOneClass M] (S : Submonoid M), S = ⊥ ∨ ∃ x ∈ S, x ≠ 1", "name": "Submonoid.bot_or_exists_ne_one", "isProp": true, "docString": "A submonoid is either the trivial submonoid or contains a nonzero element. ", "terms": "[\n    \"submonoid\",\n    \"trivial submonoid\",\n    \"nonzero element\"\n]"}
{"type": "{ι : Type u_4} →\n  {π : ι → Type u_9} → [inst : Fintype ι] → [inst : (i : ι) → NormedAddGroup (π i)] → NormedAddGroup ((i : ι) → π i)", "name": "Pi.normedAddGroup", "isProp": false, "docString": "Finite product of seminormed groups, using the sup norm.", "terms": "[\n    \"Finite product\",\n    \"Seminormed groups\", \n    \"Sup norm\"\n]"}
{"type": "∀ {R : Type u_1} [inst : CommRing R] {x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ y₁ y₂ y₃ y₄ y₅ y₆ y₇ y₈ : R},\n  (x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2 + x₅ ^ 2 + x₆ ^ 2 + x₇ ^ 2 + x₈ ^ 2) *\n      (y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2 + y₅ ^ 2 + y₆ ^ 2 + y₇ ^ 2 + y₈ ^ 2) =\n    (x₁ * y₁ - x₂ * y₂ - x₃ * y₃ - x₄ * y₄ - x₅ * y₅ - x₆ * y₆ - x₇ * y₇ - x₈ * y₈) ^ 2 +\n                  (x₁ * y₂ + x₂ * y₁ + x₃ * y₄ - x₄ * y₃ + x₅ * y₆ - x₆ * y₅ - x₇ * y₈ + x₈ * y₇) ^ 2 +\n                (x₁ * y₃ - x₂ * y₄ + x₃ * y₁ + x₄ * y₂ + x₅ * y₇ + x₆ * y₈ - x₇ * y₅ - x₈ * y₆) ^ 2 +\n              (x₁ * y₄ + x₂ * y₃ - x₃ * y₂ + x₄ * y₁ + x₅ * y₈ - x₆ * y₇ + x₇ * y₆ - x₈ * y₅) ^ 2 +\n            (x₁ * y₅ - x₂ * y₆ - x₃ * y₇ - x₄ * y₈ + x₅ * y₁ + x₆ * y₂ + x₇ * y₃ + x₈ * y₄) ^ 2 +\n          (x₁ * y₆ + x₂ * y₅ - x₃ * y₈ + x₄ * y₇ - x₅ * y₂ + x₆ * y₁ - x₇ * y₄ + x₈ * y₃) ^ 2 +\n        (x₁ * y₇ + x₂ * y₈ + x₃ * y₅ - x₄ * y₆ - x₅ * y₃ + x₆ * y₄ + x₇ * y₁ - x₈ * y₂) ^ 2 +\n      (x₁ * y₈ - x₂ * y₇ + x₃ * y₆ + x₄ * y₅ - x₅ * y₄ - x₆ * y₃ + x₇ * y₂ + x₈ * y₁) ^ 2", "name": "sum_eight_sq_mul_sum_eight_sq", "isProp": true, "docString": "Degen's eight squares identity, see <https://en.wikipedia.org/wiki/Degen%27s_eight-square_identity>.\n\nThis sign choice here corresponds to the signs obtained by multiplying two octonions.\n", "terms": "{\n  \"Mathematical_Terms\": [\"Degen's eight squares identity\", \"sign\", \"corresponds\", \"obtained\", \"multiplying\", \"two\", \"octonions\"]\n}"}
{"type": "ℤ → ZNum", "name": "ZNum.ofInt'", "isProp": false, "docString": "Converts an `Int` to a `ZNum`. ", "terms": "[\"Int\", \"ZNum\"]"}
{"type": "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {H : Type u_2} [inst_1 : TopologicalSpace H] {E : Type u_3}\n  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace 𝕜 E] (I : ModelWithCorners 𝕜 E H) {G : Type u_4}\n  [inst_4 : Add G] [inst_5 : TopologicalSpace G] [inst_6 : ChartedSpace H G] [inst : SmoothAdd I G], ContinuousAdd G", "name": "continuousAdd_of_smooth", "isProp": true, "docString": "If the addition is smooth, then it is continuous. This is not an instance for\ntechnical reasons, see note [Design choices about smooth algebraic structures].", "terms": "[\n    \"addition\",\n    \"smooth\",\n    \"continuous\",\n    \"instance\",\n    \"technical reasons\",\n    \"note\",\n    \"Design choices about smooth algebraic structures\"\n]"}
{"type": "{ι : Type u_1} →\n  {R : Type u_2} →\n    [inst : CommRing R] →\n      [inst_1 : IsDomain R] →\n        [inst_2 : IsPrincipalIdealRing R] →\n          {M : Type u_3} →\n            [inst_3 : AddCommGroup M] →\n              [inst_4 : Module R M] →\n                [inst_5 : Finite ι] → Basis ι R M → (N : Submodule R M) → (n : ℕ) × Basis.SmithNormalForm N ι n", "name": "Submodule.smithNormalForm", "isProp": false, "docString": "If `M` is finite free over a PID `R`, then any submodule `N` is free\nand we can find a basis for `M` and `N` such that the inclusion map is a diagonal matrix\nin Smith normal form.\n\nThis is a strengthening of `Submodule.basisOfPid`.\n\nSee also `Ideal.smithNormalForm`, which moreover proves that the dimension of\nan ideal is the same as the dimension of the whole ring.\n", "terms": "[\n    \"finite\",\n    \"free\",\n    \"over\",\n    \"PID\",\n    \"submodule\",\n    \"basis\",\n    \"inclusion map\",\n    \"diagonal matrix\",\n    \"Smith normal form\",\n    \"Ideal\",\n    \"dimension\",\n    \"ring\",\n    \"whole ring\"\n]"}
{"type": "{ι : Type u_1} →\n  (V : Type u_2) →\n    [inst : CategoryTheory.Category.{u_3, u_2} V] →\n      (c : ComplexShape ι) →\n        [inst_1 : CategoryTheory.Preadditive V] →\n          CategoryTheory.Functor.id (HomologicalComplex Vᵒᵖ c)ᵒᵖ ≅\n            CategoryTheory.Functor.comp (HomologicalComplex.unopFunctor V c) (HomologicalComplex.unopInverse V c)", "name": "HomologicalComplex.unopUnitIso", "isProp": false, "docString": "Auxiliary definition for `unopEquivalence`. ", "terms": "[]"}
{"type": "∀ {m : Type u_1} {R : Type u_2} [inst : Fintype m] [inst_1 : CommRing R] {M : Matrix m m R},\n  Matrix.Nondegenerate M → ∀ {v : m → R}, v ≠ 0 → ∃ w, Matrix.dotProduct v (Matrix.mulVec M w) ≠ 0", "name": "Matrix.Nondegenerate.exists_not_ortho_of_ne_zero", "isProp": true, "docString": "If `M` is nondegenerate and `v ≠ 0`, then there is some `w` such that `w * M * v ≠ 0`. ", "terms": "[\n  \"nondegenerate\",\n  \"zero\",\n  \"multiplication\",\n  \"not equal to\",\n  \"some\",\n  \"existential quantification\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {W X Y Z S T : C} →\n      (f₁ : S ⟶ W) →\n        (f₂ : S ⟶ X) →\n          [inst_1 : CategoryTheory.Limits.HasPushout f₁ f₂] →\n            (g₁ : T ⟶ Y) →\n              (g₂ : T ⟶ Z) →\n                [inst_2 : CategoryTheory.Limits.HasPushout g₁ g₂] →\n                  (i₁ : W ⟶ Y) →\n                    (i₂ : X ⟶ Z) →\n                      (i₃ : S ⟶ T) →\n                        CategoryTheory.CategoryStruct.comp f₁ i₁ = CategoryTheory.CategoryStruct.comp i₃ g₁ →\n                          CategoryTheory.CategoryStruct.comp f₂ i₂ = CategoryTheory.CategoryStruct.comp i₃ g₂ →\n                            (CategoryTheory.Limits.pushout f₁ f₂ ⟶ CategoryTheory.Limits.pushout g₁ g₂)", "name": "CategoryTheory.Limits.pushout.map", "isProp": false, "docString": "Given such a diagram, then there is a natural morphism `W ⨿ₛ X ⟶ Y ⨿ₜ Z`.\n\n    W ⟶ Y\n  ↗      ↗\nS ⟶ T\n  ↘      ↘\n    X ⟶ Z\n\n", "terms": "[\n    \"diagram\",\n    \"natural morphism\"\n]"}
{"type": "∀ {p : EReal × EReal}, p.1 ≠ ⊤ ∨ p.2 ≠ ⊥ → p.1 ≠ ⊥ ∨ p.2 ≠ ⊤ → ContinuousAt (fun p => p.1 + p.2) p", "name": "EReal.continuousAt_add", "isProp": true, "docString": "The addition on `EReal` is continuous except where it doesn't make sense (i.e., at `(⊥, ⊤)`\nand at `(⊤, ⊥)`). ", "terms": "[\n    \"addition\",\n    \"EReal\",\n    \"continuous\"\n]"}
{"type": "∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x ∈ S → y ∈ S → x * y ∈ S", "name": "IntermediateField.mul_mem", "isProp": true, "docString": "An intermediate field is closed under multiplication. ", "terms": "[\n    \"intermediate field\",\n    \"closed\",\n    \"multiplication\"\n]"}
{"type": "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a b : α},\n  a < 1 → b ≤ 1 → a * b < 1", "name": "Right.mul_lt_one_of_lt_of_le", "isProp": true, "docString": "Assumes right covariance.\nThe lemma assuming left covariance is `Left.mul_lt_one_of_lt_of_le`. ", "terms": "[\n  \"right covariance\",\n  \"lemma\",\n  \"left covariance\",\n  \"mul\",\n  \"lt\",\n  \"one\",\n  \"of\",\n  \"le\"\n]"}
{"type": "(K : Type u_1) →\n  [inst : Field K] →\n    (NumberField.InfinitePlace K → NNReal) →\n      Set (({ w // NumberField.InfinitePlace.IsReal w } → ℝ) × ({ w // NumberField.InfinitePlace.IsComplex w } → ℂ))", "name": "NumberField.mixedEmbedding.convexBodyLT", "isProp": false, "docString": "The convex body defined by `f`: the set of points `x : E` such that `‖x w‖ < f w` for all\ninfinite places `w`. ", "terms": "[\n    \"convex body\",\n    \"defined by\",\n    \"set of points\",\n    \"such that\",\n    \"for all\",\n    \"infinite places\",\n    \"<\",\n    \"‖‖\"\n]"}
{"type": "(α : Type u) →\n  (β : Type v) → [inst : Group α] → [inst_1 : AddMonoid β] → [inst_2 : DistribMulAction α β] → α →* AddAut β", "name": "DistribMulAction.toAddAut", "isProp": false, "docString": "Each element of the group defines an additive monoid isomorphism.\n\nThis is a stronger version of `MulAction.toPermHom`. ", "terms": "[\n    \"element\",\n    \"group\",\n    \"defines\",\n    \"additive\",\n    \"monoid\",\n    \"isomorphism\",\n    \"version\",\n    \"MulAction.toPermHom\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        (G : CategoryTheory.Functor C D) →\n          {J : Type w} →\n            (f : J → C) →\n              [inst_2 : CategoryTheory.Limits.HasCoproduct f] →\n                [inst_3 : CategoryTheory.Limits.HasCoproduct fun j => G.obj (f j)] →\n                  [inst_4 : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Discrete.functor f) G] →\n                    G.obj (∐ f) ≅ ∐ fun j => G.obj (f j)", "name": "CategoryTheory.Limits.PreservesCoproduct.iso", "isProp": false, "docString": "If `G` preserves colimits,\nwe have an isomorphism from the image of a coproduct to the coproduct of the images.\n", "terms": "[\n    \"preserves\",\n    \"colimits\",\n    \"isomorphism\",\n    \"image\",\n    \"coproduct\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} {s : Set α} [inst : LinearOrder α] [inst_1 : LinearOrder β] {f : α → β},\n  ¬MonotoneOn f s ∧ ¬AntitoneOn f s ↔\n    ∃ a,\n      ∃ (_ : a ∈ s),\n        ∃ b, ∃ (_ : b ∈ s), ∃ c, ∃ (_ : c ∈ s), a < b ∧ b < c ∧ (f a < f b ∧ f c < f b ∨ f b < f a ∧ f b < f c)", "name": "Set.not_monotoneOn_not_antitoneOn_iff_exists_lt_lt", "isProp": true, "docString": "A function between linear orders which is neither monotone nor antitone makes a dent upright or\ndownright. ", "terms": "[\n  \"Function\",\n  \"Linear orders\",\n  \"Monotone\",\n  \"Antitone\",\n  \"Dent\",\n  \"Upright\",\n  \"Downright\"\n]"}
{"type": "{α : Type u} → {t : Type u → Type u} → [inst : Traversable t] → t α → List α", "name": "Traversable.toList", "isProp": false, "docString": "Conceptually, `toList` collects all the elements of a collection\nin a list. This idea is formalized by\n\n  `lemma toList_spec (x : t α) : toList x = foldMap FreeMonoid.mk x`.\n\nThe definition of `toList` is based on `foldl` and `List.cons` for\nspeed. It is faster than using `foldMap FreeMonoid.mk` because, by\nusing `foldl` and `List.cons`, each insertion is done in constant\ntime. As a consequence, `toList` performs in linear.\n\nOn the other hand, `foldMap FreeMonoid.mk` creates a singleton list\naround each element and concatenates all the resulting lists. In\n`xs ++ ys`, concatenation takes a time proportional to `length xs`. Since\nthe order in which concatenation is evaluated is unspecified, nothing\nprevents each element of the traversable to be appended at the end\n`xs ++ [x]` which would yield a `O(n²)` run time. ", "terms": "[\n    \"toList\",\n    \"elements\",\n    \"collection\",\n    \"list\",\n    \"lemma\",\n    \"foldMap\",\n    \"FreeMonoid.mk\",\n    \"definition\",\n    \"foldl\",\n    \"List.cons\",\n    \"insertion\",\n    \"constant time\",\n    \"linear\",\n    \"singleton list\",\n    \"concatenates\",\n    \"length\",\n    \"order\",\n    \"concatenation\",\n    \"evaluated\",\n    \"traversable\",\n    \"appended\",\n    \"O(n²)\",\n    \"run time\"\n]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {m n : ℕ} (s : Affine.Simplex ℝ P m) (e : Fin (m + 1) ≃ Fin (n + 1)),\n  Affine.Simplex.circumcenter (Affine.Simplex.reindex s e) = Affine.Simplex.circumcenter s", "name": "Affine.Simplex.circumcenter_reindex", "isProp": true, "docString": "Reindexing a simplex along an `Equiv` of index types does not change the circumcenter. ", "terms": "[\"Reindexing\", \"simplex\", \"Equiv\", \"index types\", \"circumcenter\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {X Y : C} →\n      {f f' : X ⟶ Y} →\n        [inst_1 : CategoryTheory.Limits.HasImage f] →\n          [inst_2 : CategoryTheory.Limits.HasImage f'] →\n            f = f' → (CategoryTheory.Limits.image f ⟶ CategoryTheory.Limits.image f')", "name": "CategoryTheory.Limits.image.eqToHom", "isProp": false, "docString": "An equation between morphisms gives a comparison map between the images\n(which momentarily we prove is an iso).\n", "terms": "[\n  \"equation\",\n  \"morphisms\",\n  \"comparison map\",\n  \"images\",\n  \"iso\"\n]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    {X Y : C} →\n      [inst_1 : CategoryTheory.Limits.HasPullbacks C] →\n        {U V₁ V₂ : C} →\n          (f : X ⟶ Y) →\n            (i : U ⟶ Y) →\n              (i₁ : V₁ ⟶ CategoryTheory.Limits.pullback f i) →\n                (i₂ : V₂ ⟶ CategoryTheory.Limits.pullback f i) →\n                  [inst_2 : CategoryTheory.Limits.HasPullback i₁ i₂] →\n                    CategoryTheory.Limits.pullback (CategoryTheory.Limits.pullback.diagonal f)\n                        (CategoryTheory.Limits.pullback.map\n                          (CategoryTheory.CategoryStruct.comp i₁ CategoryTheory.Limits.pullback.snd)\n                          (CategoryTheory.CategoryStruct.comp i₂ CategoryTheory.Limits.pullback.snd) f f\n                          (CategoryTheory.CategoryStruct.comp i₁ CategoryTheory.Limits.pullback.fst)\n                          (CategoryTheory.CategoryStruct.comp i₂ CategoryTheory.Limits.pullback.fst) i\n                          (_ :\n                            CategoryTheory.CategoryStruct.comp\n                                (CategoryTheory.CategoryStruct.comp i₁ CategoryTheory.Limits.pullback.snd) i =\n                              CategoryTheory.CategoryStruct.comp\n                                (CategoryTheory.CategoryStruct.comp i₁ CategoryTheory.Limits.pullback.fst) f)\n                          (_ :\n                            CategoryTheory.CategoryStruct.comp\n                                (CategoryTheory.CategoryStruct.comp i₂ CategoryTheory.Limits.pullback.snd) i =\n                              CategoryTheory.CategoryStruct.comp\n                                (CategoryTheory.CategoryStruct.comp i₂ CategoryTheory.Limits.pullback.fst) f)) ≅\n                      CategoryTheory.Limits.pullback i₁ i₂", "name": "CategoryTheory.Limits.pullbackDiagonalMapIso", "isProp": false, "docString": "This iso witnesses the fact that\ngiven `f : X ⟶ Y`, `i : U ⟶ Y`, and `i₁ : V₁ ⟶ X ×[Y] U`, `i₂ : V₂ ⟶ X ×[Y] U`, the diagram\n\nV₁ ×[X ×[Y] U] V₂ ⟶ V₁ ×[U] V₂\n        |                 |\n        |                 |\n        ↓                 ↓\n        X        ⟶ X ×[Y] X\n\nis a pullback square.\nAlso see `pullback_fst_map_snd_isPullback`.\n", "terms": "[\n  \"iso\", \n  \"fact\", \n  \"diagram\", \n  \"pullback square\", \n  \"pullback_fst_map_snd_isPullback\"\n]"}
{"type": "(G : Type u_1) → [inst : AddGroup G] → [inst_1 : TopologicalSpace G] → [inst : TopologicalAddGroup G] → UniformSpace G", "name": "TopologicalAddGroup.toUniformSpace", "isProp": false, "docString": "The right uniformity on a topological additive group (as opposed to the left\nuniformity).\n\nWarning: in general the right and left uniformities do not coincide and so one does not obtain a\n`UniformAddGroup` structure. Two important special cases where they _do_ coincide are for\ncommutative additive groups (see `comm_topologicalAddGroup_is_uniform`) and for compact\nadditive groups (see `topologicalAddGroup_is_uniform_of_compactSpace`).", "terms": "[\n  \"Right Uniformity\",\n  \"Topological Additive Group\",\n  \"Left Uniformity\",\n  \"UniformAddGroup\",\n  \"Commutative Additive Groups\",\n  \"Compact Additive Groups\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {J : CategoryTheory.GrothendieckTopology C} →\n      {A : Type u'} →\n        [inst_1 : CategoryTheory.Category.{v', u'} A] →\n          CategoryTheory.Sheaf J A → CategoryTheory.Sheaf J A → CategoryTheory.Sheaf J (Type (max (max u v') v))", "name": "CategoryTheory.sheafHom", "isProp": false, "docString": "Given two sheaves `F` and `G` on a site `(C, J)` with values in a category `A`,\nthis `sheafHom F G` is the sheaf of types which sends an object `X : C`\nto the type of morphisms between the \"restrictions\" of `F` and `G` to the category `Over X`. ", "terms": "[\n    \"sheaves\",\n    \"site\",\n    \"values\",\n    \"category\",\n    \"sheafHom\",\n    \"sheaf of types\",\n    \"object\",\n    \"type of morphisms\",\n    \"restrictions\",\n    \"Over\"\n]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  {p₁ p₂ p₃ p₄ p₅ p₆ : P},\n  2 • EuclideanGeometry.oangle p₁ p₂ p₃ = 2 • EuclideanGeometry.oangle p₄ p₅ p₆ →\n    (AffineIndependent ℝ ![p₁, p₂, p₃] ↔ AffineIndependent ℝ ![p₄, p₅, p₆])", "name": "EuclideanGeometry.affineIndependent_iff_of_two_zsmul_oangle_eq", "isProp": true, "docString": "If twice the oriented angles between two triples of points are equal, one triple is affinely\nindependent if and only if the other is. ", "terms": "[\n    \"twice\",\n    \"oriented angles\",\n    \"triples of points\",\n    \"equal\",\n    \"affinely independent\",\n    \"if and only if\"\n]"}
{"type": "∀ {R : Type u} {L : Type v} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L] {I : LieIdeal R L}\n  (k : ℕ), ↑(LieModule.lowerCentralSeries R (↥↑I) (↥↑I) k) ≤ ↑(LieModule.lowerCentralSeries R L (↥↑I) k)", "name": "LieModule.coe_lowerCentralSeries_ideal_le", "isProp": true, "docString": "Note that the below inequality can be strict. For example the ideal of strictly-upper-triangular\n2x2 matrices inside the Lie algebra of upper-triangular 2x2 matrices with `k = 1`. ", "terms": "[\n  \"inequality\",\n  \"strict\",\n  \"ideal\",\n  \"strictly-upper-triangular\",\n  \"matrices\",\n  \"Lie algebra\",\n  \"upper-triangular\",\n  \"2x2 matrices\"\n]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasFiniteWidePullbacks C]\n  {B : C}, CategoryTheory.Limits.HasFiniteProducts (CategoryTheory.Over B)", "name": "CategoryTheory.Over.ConstructProducts.over_finiteProducts_of_finiteWidePullbacks", "isProp": true, "docString": "Given all finite wide pullbacks in `C`, construct finite products in `C/B`. ", "terms": "[\n    \"finite\",\n    \"wide pullbacks\",\n    \"construct\",\n    \"finite products\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (x y : E), IsROrC.re (inner x y) = (‖x + y‖ * ‖x + y‖ - ‖x - y‖ * ‖x - y‖) / 4", "name": "re_inner_eq_norm_add_mul_self_sub_norm_sub_mul_self_div_four", "isProp": true, "docString": "Polarization identity: The real part of the inner product, in terms of the norm. ", "terms": "[\n    \"Polarization identity\",\n    \"real part\",\n    \"inner product\",\n    \"norm\"\n]"}
{"type": "Lean.Macro", "name": "PiNotation.replacePiNotation", "isProp": false, "docString": "Since pi notation and forall notation are interchangeable, we can\nparse it by simply using the pre-existing forall parser. ", "terms": "[\n  \"Pi Notation\",\n  \"Forall Notation\",\n  \"Parser\"\n]"}
{"type": "∀ (C : Type u) [inst : CategoryTheory.Category.{v, u} C]\n  [inst_1 : CategoryTheory.Limits.HasColimitsOfSize.{max v₁ v₂, max u₁ u₂, v, u} C],\n  CategoryTheory.Limits.HasColimitsOfSize.{v₁, u₁, v, u} C", "name": "CategoryTheory.Limits.hasColimitsOfSizeShrink", "isProp": true, "docString": "`hasColimitsOfSizeShrink.{v u} C` tries to obtain `HasColimitsOfSize.{v u} C`\nfrom some other `HasColimitsOfSize C`.\n", "terms": "[\n    \"hasColimitsOfSizeShrink\",\n    \"HasColimitsOfSize\"\n]"}
{"type": "∀ {S : Type u_2} [inst : CommRing S] {R : Type u_3} [inst_1 : CommRing R] [inst_2 : Algebra R S] {A : Type u_4}\n  [inst_3 : CommRing A] [inst_4 : Algebra R A] [inst_5 : Algebra S A] [inst_6 : IsScalarTower R S A]\n  {B : PowerBasis S A},\n  IsIntegral R B.gen →\n    ∀ [inst_7 : IsDomain S] {x y : A},\n      (∀ (i : Fin B.dim), IsIntegral R ((B.basis.repr x) i)) →\n        (∀ (i : Fin B.dim), IsIntegral R ((B.basis.repr y) i)) →\n          minpoly S B.gen = Polynomial.map (algebraMap R S) (minpoly R B.gen) →\n            ∀ (i : Fin B.dim), IsIntegral R ((B.basis.repr (x * y)) i)", "name": "PowerBasis.repr_mul_isIntegral", "isProp": true, "docString": "Let `B : PowerBasis S A` be such that `IsIntegral R B.gen`, and let `x y : A` be elements with\nintegral coordinates in the base `B.basis`. Then `IsIntegral R ((B.basis.repr (x * y) i)` for all\n`i` if `minpoly S B.gen = (minpoly R B.gen).map (algebraMap R S)`. This is the case if `R` is a GCD\ndomain and `S` is its fraction ring. ", "terms": "[\n  \"PowerBasis\",\n  \"IsIntegral\",\n  \"elements\",\n  \"integral coordinates\",\n  \"base\",\n  \"repr\",\n  \"minpoly\",\n  \"map\",\n  \"algebraMap\",\n  \"GCD domain\",\n  \"fraction ring\"\n]"}
{"type": "{α : Type u_1} → {β : Type u_2} → (r : α → α → Prop) → (s : β → β → Prop) → r ≼i Sum.Lex r s", "name": "InitialSeg.leAdd", "isProp": false, "docString": "Initial segment embedding of an order `r` into the disjoint union of `r` and `s`. ", "terms": "[\n    \"Initial segment\",\n    \"Embedding\",\n    \"Order\",\n    \"Disjoint union\"\n]"}
{"type": "∀ {α : Type u_1} [inst : AddCommGroup α] [inst_1 : TopologicalSpace α] [inst_2 : TopologicalAddGroup α]\n  [inst_3 : T2Space α] (f : ℕ → α), Filter.Tendsto (fun i => ∑' (k : ℕ), f (k + i)) Filter.atTop (nhds 0)", "name": "tendsto_sum_nat_add", "isProp": true, "docString": "For `f : ℕ → α`, then `∑' k, f (k + i)` tends to zero. This does not require a summability\nassumption on `f`, as otherwise all sums are zero. ", "terms": "[\n    \"function\",\n    \"natural numbers\",\n    \"tends to zero\",\n    \"summability\",\n    \"assumption\",\n    \"sums\",\n    \"zero\"\n]"}
{"type": "{R : Type u₁} →\n  {S : Type u₂} →\n    [inst : Ring R] →\n      [inst_1 : Ring S] →\n        (f : R →+* S) →\n          (M : Type v) →\n            [inst_2 : AddCommMonoid M] →\n              [inst_3 : Module R M] → SMul S (↑((ModuleCat.restrictScalars f).obj (ModuleCat.mk S)) →ₗ[R] M)", "name": "ModuleCat.CoextendScalars.hasSMul", "isProp": false, "docString": "Given an `R`-module M, consider Hom(S, M) -- the `R`-linear maps between S (as an `R`-module by\nmeans of restriction of scalars) and M. `S` acts on Hom(S, M) by `s • g = x ↦ g (x • s)`\n", "terms": "[\n  \"R-module\",\n  \"Hom\",\n  \"R-linear maps\",\n  \"restriction of scalars\",\n  \"acts\",\n  \"s • g\",\n  \"x ↦ g (x • s)\"\n]"}
{"type": "{R : Type u_1} →\n  {M : Type u_2} →\n    {N : Type u_3} →\n      {P : Type u_4} →\n        [inst : CommRing R] →\n          [inst_1 : AddCommGroup M] →\n            [inst_2 : AddCommGroup N] →\n              [inst_3 : AddCommGroup P] →\n                [inst_4 : Module R M] →\n                  [inst_5 : Module R N] →\n                    [inst_6 : Module R P] →\n                      {f : M →ₗ[R] N} →\n                        {g : N →ₗ[R] P} →\n                          (Q : Type u_5) →\n                            [inst_7 : AddCommGroup Q] →\n                              [inst_8 : Module R Q] →\n                                Function.Exact ⇑f ⇑g →\n                                  Function.Surjective ⇑g →\n                                    TensorProduct R P Q →ₗ[R]\n                                      TensorProduct R N Q ⧸ LinearMap.range (LinearMap.rTensor Q f)", "name": "rTensor.inverse", "isProp": false, "docString": "The inverse map in `rTensor.equiv` ", "terms": "[\"inverse map\", \"rTensor.equiv\"]"}
{"type": "{T : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} T] →\n    (Y : T) →\n      CategoryTheory.Over.map (CategoryTheory.CategoryStruct.id Y) ≅ CategoryTheory.Functor.id (CategoryTheory.Over Y)", "name": "CategoryTheory.Over.mapId", "isProp": false, "docString": "Mapping by the identity morphism is just the identity functor. ", "terms": "[\n  \"Mapping\",\n  \"Identity Morphism\",\n  \"Identity Functor\"\n]"}
{"type": "{α : Type u} → {a : α} → (s : Set α) → [inst : Fintype ↑s] → a ∉ s → Fintype ↑(insert a s)", "name": "Set.fintypeInsertOfNotMem", "isProp": false, "docString": "A `Fintype` structure on `insert a s` when inserting a new element. ", "terms": "[\n    \"Fintype\",\n    \"insert\",\n    \"structure\",\n    \"element\"\n]"}
{"type": "∀ {G : Type u_4} {E : Type u_5} [inst : MeasurableSpace G] [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ℝ E]\n  {μ : MeasureTheory.Measure G} {f : G → E} {g : G} [inst_3 : AddGroup G] [inst_4 : MeasurableAdd G]\n  [inst_5 : MeasureTheory.Measure.IsAddLeftInvariant μ], (∀ (x : G), f (g + x) = -f x) → ∫ (x : G), f x ∂μ = 0", "name": "MeasureTheory.integral_eq_zero_of_add_left_eq_neg", "isProp": true, "docString": "If some left-translate of a function negates it, then the integral of the function with\nrespect to a left-invariant measure is 0.", "terms": "[\n  \"left-translate\",\n  \"function\",\n  \"negates\",\n  \"integral\",\n  \"left-invariant measure\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        (F : CategoryTheory.Functor C D) →\n          [inst_2 : CategoryTheory.Functor.Initial F] →\n            {E : Type u₃} →\n              [inst_3 : CategoryTheory.Category.{v₃, u₃} E] →\n                {G : CategoryTheory.Functor D E} →\n                  (t : CategoryTheory.Limits.Cone G) →\n                    CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.Cone.whisker F t) ≃\n                      CategoryTheory.Limits.IsLimit t", "name": "CategoryTheory.Functor.Initial.isLimitWhiskerEquiv", "isProp": false, "docString": "When `F : C ⥤ D` is initial, and `t : Cone G` for some `G : D ⥤ E`,\n`t.whisker F` is a limit cone exactly when `t` is.\n", "terms": "[\n    \"initial\",\n    \"Cone\",\n    \"limit cone\",\n    \"whisker\"\n]"}
{"type": "{α : Type u_1} →\n  [inst : PartialOrder α] → (f : α → α) → (∀ (x : α), x ≤ f x) → (∀ ⦃x y : α⦄, x ≤ f y → f x ≤ f y) → ClosureOperator α", "name": "ClosureOperator.mk₂", "isProp": false, "docString": "Convenience constructor for a closure operator using the weaker minimality axiom:\n`x ≤ f y → f x ≤ f y`, which is sometimes easier to prove in practice. ", "terms": "[\n    \"Convenience constructor\",\n    \"closure operator\",\n    \"weaker minimality axiom\"\n]"}
{"type": "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R},\n  Polynomial.Monic p →\n    Multiset.card (Polynomial.roots p) = Polynomial.natDegree p →\n      Multiset.prod (Multiset.map (fun a => Polynomial.X - Polynomial.C a) (Polynomial.roots p)) = p", "name": "Polynomial.prod_multiset_X_sub_C_of_monic_of_roots_card_eq", "isProp": true, "docString": "A monic polynomial `p` that has as many roots as its degree\ncan be written `p = ∏(X - a)`, for `a` in `p.roots`. ", "terms": "[\n    \"monic polynomial\", \n    \"roots\", \n    \"degree\", \n    \"product (∏)\", \n    \"subtraction (-)\"\n]"}
{"type": "{F : Type u₀ → Type u₁ → Type u₂} → [inst : Bifunctor F] → {α α' : Type u₀} → {β : Type u₁} → (α → α') → F α β → F α' β", "name": "Bifunctor.fst", "isProp": false, "docString": "Left map of a bifunctor. ", "terms": "[\n    \"Left map\",\n    \"bifunctor\"\n]"}
{"type": "∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ℤ}, ↑a ≠ 0 → legendreSym p a ^ 2 = 1", "name": "legendreSym.sq_one", "isProp": true, "docString": "The square of the symbol is 1 if `p ∤ a`. ", "terms": "[\n    \"square\",\n    \"symbol\",\n    \"1\",\n    \"p\",\n    \"divides\",\n    \"a\"\n]"}
{"type": "(K : Type u_1) →\n  (V : Type u_2) →\n    [inst : Field K] →\n      [inst_1 : AddCommGroup V] →\n        [inst_2 : Module K V] →\n          GaloisCoinsertion (⇑OrderDual.toDual ∘ Submodule.dualAnnihilator)\n            (Submodule.dualCoannihilator ∘ ⇑OrderDual.ofDual)", "name": "Subspace.dualAnnihilatorGci", "isProp": false, "docString": "`Submodule.dualAnnihilator` and `Submodule.dualCoannihilator` form a Galois coinsertion. ", "terms": "[\n  \"Submodule\",\n  \"dualAnnihilator\",\n  \"dualCoannihilator\",\n  \"Galois coinsertion\"\n]"}
{"type": "{α : Type u} → (s : Stream'.Seq α) → (n : ℕ) → Decidable (Stream'.Seq.TerminatedAt s n)", "name": "Stream'.Seq.terminatedAtDecidable", "isProp": false, "docString": "It is decidable whether a sequence terminates at a given position. ", "terms": "[\"decidable\", \"sequence\", \"terminates\", \"position\"]"}
{"type": "{R : Type u_1} →\n  [inst : CommSemiring R] →\n    {M : Submonoid R} →\n      {S : Type u_2} →\n        [inst_1 : CommSemiring S] →\n          [inst_2 : Algebra R S] →\n            {P : Type u_3} →\n              [inst_3 : CommSemiring P] →\n                [inst_4 : IsLocalization M S] →\n                  {T : Submonoid P} →\n                    (Q : Type u_4) →\n                      [inst_5 : CommSemiring Q] →\n                        [inst_6 : Algebra P Q] →\n                          [inst_7 : IsLocalization T Q] → (g : R →+* P) → M ≤ Submonoid.comap g T → S →+* Q", "name": "IsLocalization.map", "isProp": false, "docString": "Map a homomorphism `g : R →+* P` to `S →+* Q`, where `S` and `Q` are\nlocalizations of `R` and `P` at `M` and `T` respectively,\nsuch that `g(M) ⊆ T`.\n\nWe send `z : S` to `algebraMap P Q (g x) * (algebraMap P Q (g y))⁻¹`, where\n`(x, y) : R × M` are such that `z = f x * (f y)⁻¹`. ", "terms": "[\n    \"Map\",\n    \"Homomorphism\",\n    \"Localizations\",\n    \"Subset\",\n    \"AlgebraMap\",\n    \"Multiplication\",\n    \"Inverse\"\n]"}
{"type": "{α : Type u} → α → α → α → α → α → α → α → α → Array α", "name": "Array.mkArray8", "isProp": false, "docString": "Create array `#[a₁, a₂, a₃, a₄, a₅, a₆, a₇, a₈]` ", "terms": "The given statement is primarily focused on a procedural task and does not specifically incorporate mathematical terms in the context of concepts, theories, or properties. Therefore, the appropriate response would be an empty list, since there are no higher-level mathematical terms present.\n\n```json\n[]\n```"}
{"type": "∀ {α : Type u_1} {a b : α} [inst : MulOneClass α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : PosMulMono α],\n  1 < a → 1 ≤ b → 0 ≤ a → 1 < a * b", "name": "Left.lt_mul_of_lt_of_one_le_of_nonneg", "isProp": true, "docString": "Assumes left covariance. ", "terms": "[\"covariance\", \"left\"]"}
{"type": "CategoryTheory.ConcreteCategory Stonean", "name": "Stonean.instConcreteCategoryStoneanInstLargeCategoryStonean", "isProp": false, "docString": "Stonean spaces are a concrete category. ", "terms": "[\"Stonean spaces\", \"concrete category\"]"}
{"type": "{σ : Type u_1} →\n  (R : Type u_2) →\n    {A : Type u_3} →\n      [inst : CommSemiring R] →\n        [inst_1 : AddCommMonoid A] →\n          [inst_2 : Module R A] → [inst_3 : Module (MvPolynomial σ R) A] → (σ → A) → MvPolynomial σ R →ₗ[R] A", "name": "MvPolynomial.mkDerivationₗ", "isProp": false, "docString": "The derivation on `MvPolynomial σ R` that takes value `f i` on `X i`, as a linear map.\nUse `MvPolynomial.mkDerivation` instead. ", "terms": "[\n  \"derivation\",\n  \"MvPolynomial\",\n  \"value\",\n  \"linear map\",\n  \"MvPolynomial.mkDerivation\"\n]"}
{"type": "Lean.MetaM (List Lean.Expr)", "name": "Mathlib.Deriving.Traversable.getFVarsNotImplementationDetails", "isProp": false, "docString": "Get `Expr`s of `FVarId`s which is not implementation details in the current context. ", "terms": "The provided statement does not contain any mathematical terms as defined by mathematical literature and academic research papers. Therefore, the JSON list returned should be empty: \n\n`[]`"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.HasShift C ℤ] [inst_3 : CategoryTheory.Preadditive C]\n  [inst_4 : ∀ (n : ℤ), CategoryTheory.Functor.Additive (CategoryTheory.shiftFunctor C n)]\n  [self : CategoryTheory.Pretriangulated C] {X Y : C} (f : X ⟶ Y),\n  ∃ Z g h, CategoryTheory.Pretriangulated.Triangle.mk f g h ∈ CategoryTheory.Pretriangulated.distinguishedTriangles", "name": "CategoryTheory.Pretriangulated.distinguished_cocone_triangle", "isProp": true, "docString": "any morphism `X ⟶ Y` is part of a distinguished triangle `X ⟶ Y ⟶ Z ⟶ X⟦1⟧` ", "terms": "[\"morphism\", \"part of\", \"distinguished triangle\"]"}
{"type": "∀ {G : Type u_4} {E : Type u_5} [inst : MeasurableSpace G] [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ℝ E]\n  {μ : MeasureTheory.Measure G} [inst_3 : AddGroup G] [inst_4 : MeasurableAdd G]\n  [inst_5 : MeasureTheory.Measure.IsAddLeftInvariant μ] (f : G → E) (g : G), ∫ (x : G), f (g + x) ∂μ = ∫ (x : G), f x ∂μ", "name": "MeasureTheory.integral_add_left_eq_self", "isProp": true, "docString": "Translating a function by left-addition does not change its integral with respect to a\nleft-invariant measure.", "terms": "[\n  \"Translating\",\n  \"function\",\n  \"left-addition\",\n  \"change\",\n  \"integral\",\n  \"respect\",\n  \"left-invariant\",\n  \"measure\"\n]"}
{"type": "{α : Type u_1} → [inst : BEq α] → List α → α → List α", "name": "List.eraseTR", "isProp": false, "docString": "Tail recursive version of `erase`. ", "terms": "[\"tail recursive\", \"erase\"]"}
{"type": "{𝕜 : Type u_1} →\n  [inst : LinearOrderedAddCommGroup 𝕜] →\n    [inst_1 : TopologicalSpace 𝕜] →\n      [inst_2 : OrderTopology 𝕜] →\n        (p : 𝕜) → [hp : Fact (0 < p)] → (a : 𝕜) → [inst_3 : Archimedean 𝕜] → AddCircle p ≃ ↑(Set.Ioc a (a + p))", "name": "AddCircle.equivIoc", "isProp": false, "docString": "The equivalence between `AddCircle p` and the half-open interval `(a, a + p]`, whose inverse\nis the natural quotient map. ", "terms": "[\n\"equivalence\",\n\"AddCircle\",\n\"half-open interval\",\n\"inverse\",\n\"natural quotient map\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (x y : E), ‖x + y‖ ^ 2 = ‖x‖ ^ 2 + 2 * IsROrC.re (inner x y) + ‖y‖ ^ 2", "name": "norm_add_pow_two", "isProp": true, "docString": "**Alias** of `norm_add_sq`.\n\n---\n\nExpand the square ", "terms": "[\n    \"Alias\",\n    \"norm_add_sq\",\n    \"Expand\",\n    \"square\"\n]"}
{"type": "{α : Type u_1} → α ≃ Topology.WithLower α", "name": "Topology.WithLower.toLower", "isProp": false, "docString": "`toLower` is the identity function to the `WithLower` of a type.  ", "terms": "[\"toLower\", \"identity function\", \"WithLower\", \"type\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {J : Type w} →\n      [inst_1 : CategoryTheory.SmallCategory J] →\n        (F : CategoryTheory.Functor J C) →\n          [inst_2 : CategoryTheory.Limits.HasLimit (CategoryTheory.Discrete.functor F.obj)] →\n            [inst_3 : CategoryTheory.Limits.HasLimit (CategoryTheory.Discrete.functor fun f => F.obj f.fst.2)] →\n              [inst_4 : CategoryTheory.Limits.HasEqualizers C] → CategoryTheory.Limits.LimitCone F", "name": "CategoryTheory.Limits.limitConeOfEqualizerAndProduct", "isProp": false, "docString": "Given the existence of the appropriate (possibly finite) products and equalizers,\nwe can construct a limit cone for `F`.\n(This assumes the existence of all equalizers, which is technically stronger than needed.)\n", "terms": "[\n    \"existence\",\n    \"appropriate\",\n    \"possibly finite\",\n    \"products\",\n    \"equalizers\",\n    \"construct\",\n    \"limit cone\",\n    \"assumes\"\n]"}
{"type": "∀ {ι : Type u'} {R : Type u_2} {M : Type u_4} {v : ι → M} [inst : Ring R] [inst_1 : AddCommGroup M]\n  [inst_2 : Module R M], LinearIndependent R v → CompleteLattice.Independent fun i => Submodule.span R {v i}", "name": "LinearIndependent.independent_span_singleton", "isProp": true, "docString": "See also `CompleteLattice.independent_iff_linearIndependent_of_ne_zero`. ", "terms": "[\"CompleteLattice\", \"independent\", \"linearIndependent\", \"ne_zero\"]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} {δ : Type u_4} [inst : AddCommMonoid α] [inst_1 : TopologicalSpace α]\n  [inst_2 : T2Space α] [inst_3 : CompleteLattice β] (m : β → α),\n  m ⊥ = 0 →\n    ∀ (R : α → α → Prop),\n      (∀ (s : ℕ → β), R (m (⨆ i, s i)) (∑' (i : ℕ), m (s i))) →\n        ∀ (s : δ → β) (t : Finset δ), R (m (⨆ d ∈ t, s d)) (Finset.sum t fun d => m (s d))", "name": "rel_iSup_sum", "isProp": true, "docString": "If a function is countably sub-additive then it is sub-additive on finite sets ", "terms": "[\n    \"function\",\n    \"countably sub-additive\",\n    \"sub-additive\",\n    \"finite sets\"\n]"}
{"type": "∀ (R : Type u_1) [inst : Ring R], Polynomial.cyclotomic 0 R = 1", "name": "Polynomial.cyclotomic_zero", "isProp": true, "docString": "The zeroth cyclotomic polyomial is `1`. ", "terms": "[\n  \"zeroth\",\n  \"cyclotomic polynomial\",\n  \"1\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        (F : CategoryTheory.Functor Cᵒᵖ Dᵒᵖ) →\n          (G : CategoryTheory.Functor Dᵒᵖ Cᵒᵖ) →\n            (CategoryTheory.Functor.unop G ⊣ CategoryTheory.Functor.unop F) → (F ⊣ G)", "name": "CategoryTheory.Adjunction.adjointOfUnopAdjointUnop", "isProp": false, "docString": "If `G.unop` is adjoint to `F.unop` then `F` is adjoint to `G`. ", "terms": "[\"adjoint\", \"unop\"]"}
{"type": "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] {s : Set E}\n  {f : E → E} {f' : E → E →L[ℝ] E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ],\n  (∀ x ∈ s, HasFDerivWithinAt f (f' x) s x) → (∀ x ∈ s, ContinuousLinearMap.det (f' x) = 0) → ↑↑μ (f '' s) = 0", "name": "MeasureTheory.addHaar_image_eq_zero_of_det_fderivWithin_eq_zero", "isProp": true, "docString": "A version of Sard lemma in fixed dimension: given a differentiable function from `E` to `E` and\na set where the differential is not invertible, then the image of this set has zero measure. ", "terms": "[\n\"Sard lemma\",\n\"fixed dimension\",\n\"differentiable function\",\n\"differential\",\n\"invertible\",\n\"image\",\n\"zero measure\"\n]"}
{"type": "{Γ : Type u_1} →\n  [inst : Inhabited Γ] →\n    {l₁ l₂ : List Γ} → Turing.BlankRel l₁ l₂ → { l // Turing.BlankExtends l₁ l ∧ Turing.BlankExtends l₂ l }", "name": "Turing.BlankRel.above", "isProp": false, "docString": "Given two `BlankRel` lists, there exists (constructively) a common join. ", "terms": "[\n  \"Given\",\n  \"two\",\n  \"lists\",\n  \"there exists\",\n  \"constructively\",\n  \"a common\",\n  \"join\"\n]"}
{"type": "{R : Type u_1} →\n  {M : Type u_2} →\n    {M' : Type u_3} →\n      {N : Type u_4} →\n        {N' : Type u_5} →\n          {ι : Type u_6} →\n            [inst : Semiring R] →\n              [inst_1 : AddCommMonoid M] →\n                [inst_2 : Module R M] →\n                  [inst_3 : TopologicalSpace M] →\n                    [inst_4 : AddCommMonoid M'] →\n                      [inst_5 : Module R M'] →\n                        [inst_6 : TopologicalSpace M'] →\n                          [inst_7 : AddCommMonoid N] →\n                            [inst_8 : Module R N] →\n                              [inst_9 : TopologicalSpace N] →\n                                [inst_10 : AddCommMonoid N'] →\n                                  [inst_11 : Module R N'] →\n                                    [inst_12 : TopologicalSpace N'] →\n                                      (M ≃L[R] M') → (N ≃L[R] N') → M[Λ^ι]→L[R]N ≃ M'[Λ^ι]→L[R]N'", "name": "ContinuousLinearEquiv.continuousAlternatingMapCongr", "isProp": false, "docString": "Continuous linear equivalences between domains and codomains define an equivalence between the\nspaces of continuous alternating maps. ", "terms": "[\n  \"Continuous\",\n  \"Linear\",\n  \"Equivalences\",\n  \"Domains\",\n  \"Codomains\",\n  \"Equivalence\",\n  \"Spaces\",\n  \"Continuous Alternating Maps\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] (e : PartialHomeomorph α β) {f : γ → α} {s : Set γ} {x : γ},\n  f x ∈ e.source → f ⁻¹' e.source ∈ nhdsWithin x s → (ContinuousWithinAt f s x ↔ ContinuousWithinAt (↑e ∘ f) s x)", "name": "PartialHomeomorph.continuousWithinAt_iff_continuousWithinAt_comp_left", "isProp": true, "docString": "Continuity within a set at a point can be read under left composition with a local\nhomeomorphism if a neighborhood of the initial point is sent to the source of the local\nhomeomorphism", "terms": "[\n  \"Continuity\",\n  \"Set\",\n  \"Point\",\n  \"Left composition\",\n  \"Local homeomorphism\",\n  \"Neighborhood\",\n  \"Initial point\",\n  \"Source\"\n]"}
{"type": "∀ {G : Type v} {X : Type w} [inst : PseudoMetricSpace X] [inst_1 : VAdd G X] [inst_2 : IsometricVAdd G X] {s : Set X},\n  Bornology.IsBounded s → ∀ (c : G), Bornology.IsBounded (c +ᵥ s)", "name": "Bornology.IsBounded.vadd", "isProp": true, "docString": "Given an additive isometric action of `G` on `X`, the image of a bounded set in `X`\nunder translation by `c : G` is bounded", "terms": "[\n    \"additive isometric action\",\n    \"image\",\n    \"bounded set\",\n    \"translation\",\n    \"bounded\"\n]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  {p₁ p₂ p₃ p₄ : P},\n  2 • EuclideanGeometry.oangle p₁ p₂ p₄ = 2 • EuclideanGeometry.oangle p₁ p₃ p₄ →\n    ¬Collinear ℝ {p₁, p₂, p₄} → EuclideanGeometry.Cospherical {p₁, p₂, p₃, p₄}", "name": "EuclideanGeometry.cospherical_of_two_zsmul_oangle_eq_of_not_collinear", "isProp": true, "docString": "Converse of \"angles in same segment are equal\" and \"opposite angles of a cyclic quadrilateral\nadd to π\", for oriented angles mod π. ", "terms": "[\n  \"Converse\",\n  \"Angles\",\n  \"Same Segment\",\n  \"Equal\",\n  \"Opposite Angles\",\n  \"Cyclic Quadrilateral\",\n  \"Add\",\n  \"π\",\n  \"Oriented Angles\",\n  \"Mod\"\n]"}
{"type": "{K : Type u} → [inst : Field K] → ↥⊤ ≃+* K", "name": "Subfield.topEquiv", "isProp": false, "docString": "The ring equiv between the top element of `Subfield K` and `K`. ", "terms": "[\n  \"ring\",\n  \"equiv\",\n  \"top element\",\n  \"Subfield\",\n  \"K\"\n]"}
{"type": "ChartedSpace (EuclideanSpace ℝ (Fin 1)) ↥circle", "name": "instChartedSpaceEuclideanSpaceRealIsROrCFinOfNatNatInstOfNatNatFintypeToTopologicalSpaceUniformSpaceENNRealInstOfNatToNatCastInstCanonicallyOrderedCommSemiringENNRealProof_1ToUniformSpacePseudoMetricSpaceSubtypeComplexMemSubmonoidToMulOneClassToMulZeroOneClassToNonAssocSemiringInstSemiringComplexInstMembershipInstSetLikeSubmonoidCircleInstTopologicalSpaceSubtypeToPseudoMetricSpaceToSeminormedRingToSeminormedCommRingToNormedCommRingInstNormedFieldComplex", "isProp": false, "docString": "The unit circle in `ℂ` is a charted space modelled on `EuclideanSpace ℝ (Fin 1)`.  This\nfollows by definition from the corresponding result for `Metric.Sphere`. ", "terms": "[\n  \"unit circle\",\n  \"ℂ\",\n  \"charted space\",\n  \"modelled\",\n  \"EuclideanSpace\",\n  \"ℝ\",\n  \"Fin 1\",\n  \"definition\",\n  \"corresponding result\",\n  \"Metric.Sphere\"\n]"}
{"type": "∀ {α : Type u_1} [self : CompleteBooleanAlgebra α] (s : Set α) (a : α), (∀ b ∈ s, b ≤ a) → sSup s ≤ a", "name": "CompleteBooleanAlgebra.sSup_le", "isProp": true, "docString": "Any upper bound is more than the set supremum. ", "terms": "[\"upper bound\", \"more than\", \"set\", \"supremum\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      [inst_2 : CategoryTheory.Limits.HasKernels C] →\n        (X : C) → (CategoryTheory.Subobject (Opposite.op X))ᵒᵈ →o CategoryTheory.Subobject X", "name": "CategoryTheory.Limits.kernelOrderHom", "isProp": false, "docString": "Taking kernels is an order-reversing map from the quotient objects of `X` to the subobjects of\n`X`. ", "terms": "[\n  \"kernels\",\n  \"order-reversing map\",\n  \"quotient objects\",\n  \"subobjects\"\n]"}
{"type": "∀ {a b : ℕ}, Nat.Coprime a b → List.Disjoint (Nat.factors a) (Nat.factors b)", "name": "Nat.coprime_factors_disjoint", "isProp": true, "docString": "The sets of factors of coprime `a` and `b` are disjoint ", "terms": "[\n  \"sets\",\n  \"factors\",\n  \"coprime\",\n  \"disjoint\"\n]"}
{"type": "ℕ → ℕ", "name": "Subgroup.cardCommutatorBound", "isProp": false, "docString": "A bound for the size of the commutator subgroup in terms of the number of commutators. ", "terms": "[\n  \"bound\",\n  \"size\",\n  \"commutator subgroup\",\n  \"terms\",\n  \"number\",\n  \"commutators\"\n]"}
{"type": "Num → List Turing.PartrecToTM2.Γ'", "name": "Turing.PartrecToTM2.trNum", "isProp": false, "docString": "We use `Num` to define the translation of binary natural numbers. Positive numbers are\ntranslated using `trPosNum`, and `trNum 0 = []`. So there are never any trailing `bit0`'s in\na translated `Num`.\n\n    0 = []\n    1 = [bit1]\n    2 = [bit0, bit1]\n    3 = [bit1, bit1]\n    4 = [bit0, bit0, bit1]\n", "terms": "[\"Num\", \"translation\", \"binary\", \"natural numbers\", \"Positive numbers\", \"trPosNum\", \"trNum\", \"trailing\", \"bit0\", \"translated\", \"bit1\"]"}
{"type": "∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {s1 s2 : AffineSubspace k P},\n  Set.Nonempty ↑s1 →\n    Set.Nonempty ↑s2 → IsCompl (AffineSubspace.direction s1) (AffineSubspace.direction s2) → ∃ p, ↑s1 ∩ ↑s2 = {p}", "name": "AffineSubspace.inter_eq_singleton_of_nonempty_of_isCompl", "isProp": true, "docString": "If the directions of two nonempty affine subspaces are complements of each other, they intersect\nin exactly one point. ", "terms": "[\n    \"directions\",\n    \"nonempty\",\n    \"affine subspaces\",\n    \"complements\",\n    \"intersect\",\n    \"exactly one\",\n    \"point\"\n]"}
{"type": "{G : Type u_1} →\n  [inst : AddGroup G] →\n    {H : AddSubgroup G} →\n      {S : Set G} → S ∈ AddSubgroup.rightTransversals ↑H → Quotient (QuotientAddGroup.rightRel H) ≃ ↑S", "name": "AddSubgroup.MemRightTransversals.toEquiv", "isProp": false, "docString": "A right transversal is in bijection with right cosets.", "terms": "[\n    \"right transversal\",\n    \"bijection\",\n    \"right cosets\"\n]"}
{"type": "Set Ordinal.{u} → Ordinal.{u} → Ordinal.{u}", "name": "Ordinal.enumOrd", "isProp": false, "docString": "Enumerator function for an unbounded set of ordinals. ", "terms": "[\n    \"Enumerator function\",\n    \"Unbounded set\",\n    \"Ordinals\"\n]"}
{"type": "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {F : Type u_3} [inst_1 : NormedAddCommGroup F] [inst_2 : NormedSpace 𝕜 F]\n  (p : Submodule 𝕜 F) [inst_3 : FiniteDimensional 𝕜 ↥p], Submodule.ClosedComplemented p", "name": "Submodule.ClosedComplemented.of_finiteDimensional", "isProp": true, "docString": "A finite dimensional submodule over `ℝ` or `ℂ` is `Submodule.ClosedComplemented`. ", "terms": "[\n    \"finite dimensional\",\n    \"submodule\",\n    \"ℝ\",\n    \"ℂ\",\n    \"Submodule.ClosedComplemented\"\n]"}
{"type": "∀ {p : ℕ}, Nat.Prime p → Nat.factorization p = fun₀ | p => 1", "name": "Nat.Prime.factorization", "isProp": true, "docString": "The only prime factor of prime `p` is `p` itself, with multiplicity `1` ", "terms": "[\n  \"Prime\",\n  \"Factor\",\n  \"Multiplicity\"\n]"}
{"type": "∃ c, ∀ (n : ℕ), Real.log (Stirling.stirlingSeq 1) - Real.log (Stirling.stirlingSeq (n + 1)) ≤ c", "name": "Stirling.log_stirlingSeq_bounded_aux", "isProp": true, "docString": "For any `n`, we have `log_stirlingSeq 1 - log_stirlingSeq n ≤ 1/4 * ∑' 1/k^2`  ", "terms": "[\n    \"log_stirlingSeq\",\n    \"less than or equal to\",\n    \"multiplication\",\n    \"sum\",\n    \"reciprocal\",\n    \"square\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {x : α} {p : Filter ι},\n  TendstoUniformlyOn F f p {x} ↔ Filter.Tendsto (fun n => F n x) p (nhds (f x))", "name": "tendstoUniformlyOn_singleton_iff_tendsto", "isProp": true, "docString": "Uniform convergence on a singleton is equivalent to regular convergence ", "terms": "[\n    \"Uniform convergence\",\n    \"Singleton\",\n    \"Equivalent\",\n    \"Regular convergence\"\n]"}
{"type": "∀ {X : Type u_1} {ι : Type u_2} {Y : ι → Type u_3} [inst : TopologicalSpace X]\n  [inst_1 : (i : ι) → TopologicalSpace (Y i)] [inst_2 : ConnectedSpace X] (f : C(X, (i : ι) × Y i)),\n  ∃ i g, f = ContinuousMap.comp (ContinuousMap.sigmaMk i) g", "name": "ContinuousMap.exists_lift_sigma", "isProp": true, "docString": "Every continuous map from a connected topological space to the disjoint union of a family of\ntopological spaces is a composition of the embedding `ContinuousMap.sigmMk i : C(Y i, Σ i, Y i)` for\nsome `i` and a continuous map `g : C(X, Y i)`. See also `Continuous.exists_lift_sigma` for a version\nwith unbundled functions and `ContinuousMap.sigmaCodHomeomorph` for a homeomorphism defined using\nthis fact. ", "terms": "[\n  \"continuous map\",\n  \"connected topological space\",\n  \"disjoint union\",\n  \"family of topological spaces\",\n  \"composition\",\n  \"embedding\",\n  \"ContinuousMap.sigmMk\",\n  \"continuous map\",\n  \"Continuous.exists_lift_sigma\",\n  \"unbundled functions\",\n  \"ContinuousMap.sigmaCodHomeomorph\",\n  \"homeomorphism\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.HasShift C ℤ] →\n      {T₁ T₂ T₃ : CategoryTheory.Pretriangulated.Triangle C} →\n        CategoryTheory.Pretriangulated.TriangleMorphism T₁ T₂ →\n          CategoryTheory.Pretriangulated.TriangleMorphism T₂ T₃ → CategoryTheory.Pretriangulated.TriangleMorphism T₁ T₃", "name": "CategoryTheory.Pretriangulated.TriangleMorphism.comp", "isProp": false, "docString": "Composition of triangle morphisms gives a triangle morphism.\n", "terms": "[\n    \"Composition\",\n    \"Triangle\",\n    \"Morphisms\"\n]"}
{"type": "{α : Type u_2} → Bornology α", "name": "Bornology.cofinite", "isProp": false, "docString": "The cofinite filter as a bornology ", "terms": "[\n    \"Cofinite filter\",\n    \"Bornology\"\n]"}
{"type": "{x y : SetTheory.PGame} →\n  (r : SetTheory.PGame.Relabelling x y) →\n    (i : SetTheory.PGame.RightMoves y) →\n      SetTheory.PGame.Relabelling (SetTheory.PGame.moveRight x ((SetTheory.PGame.Relabelling.rightMovesEquiv r).symm i))\n        (SetTheory.PGame.moveRight y i)", "name": "SetTheory.PGame.Relabelling.moveRightSymm", "isProp": false, "docString": "A right move of `y` is a relabelling of a right move of `x`. ", "terms": "[]"}
{"type": "∀ {M : Type u_12} {N : Type u_13} [inst : Mul M] [inst_1 : Mul N] (self : M ≃* N) (x y : M),\n  Equiv.toFun self.toEquiv (x * y) = Equiv.toFun self.toEquiv x * Equiv.toFun self.toEquiv y", "name": "MulEquiv.map_mul'", "isProp": true, "docString": "The proposition that the function preserves multiplication ", "terms": "[\n    \"Proposition\",\n    \"Function\",\n    \"Preserves\",\n    \"Multiplication\"\n]"}
{"type": "∀ {α : Type u_1} (l : List α) (c : Composition (List.length l)),\n  List.map List.length (List.splitWrtComposition l c) = c.blocks", "name": "List.map_length_splitWrtComposition", "isProp": true, "docString": "When one splits a list along a composition `c`, the lengths of the sublists thus created are\ngiven by the block sizes in `c`. ", "terms": "[\"splits\", \"list\", \"along\", \"composition\", \"lengths\", \"sublists\", \"block sizes\"]"}
{"type": "{L : FirstOrder.Language} → FirstOrder.Language.Relations L 2 → FirstOrder.Language.Sentence L", "name": "FirstOrder.Language.Relations.antisymmetric", "isProp": false, "docString": "The sentence indicating that a basic relation symbol is antisymmetric. ", "terms": "[\n    \"relation symbol\",\n    \"antisymmetric\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_5} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommGroup β] [inst_3 : SMul 𝕜 E] [inst_4 : Module 𝕜 β] {s : Set E} {f : E → β},\n  ConvexOn 𝕜 s (-f) ↔ ConcaveOn 𝕜 s f", "name": "neg_convexOn_iff", "isProp": true, "docString": "A function `-f` is convex iff `f` is concave. ", "terms": "[\n    \"function\",\n    \"convex\",\n    \"concave\",\n    \"iff\"\n]"}
{"type": "{α : Sort u_1} → {β : Sort u_2} → (f : β → α) → Function.Surjective f → α ↪ β", "name": "Function.Embedding.ofSurjective", "isProp": false, "docString": "A right inverse `surjInv` of a surjective function as an `Embedding`. ", "terms": "[\n  \"Right inverse\",\n  \"Surjective function\",\n  \"Embedding\"\n]"}
{"type": "{V : Type u_1} → [inst : Quiver V] → WideSubquiver V ≃ Set (Quiver.Total V)", "name": "Quiver.wideSubquiverEquivSetTotal", "isProp": false, "docString": "A wide subquiver of `G` can equivalently be viewed as a total set of arrows. ", "terms": "[\n    \"wide subquiver\",\n    \"equivalently\",\n    \"total set\",\n    \"arrows\"\n]"}
{"type": "∀ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] {F : Type u_5}\n  [mc : MonoidHomClass F M N] (f : F) (s : Set M), Submonoid.map f (Submonoid.closure s) = Submonoid.closure (⇑f '' s)", "name": "MonoidHom.map_mclosure", "isProp": true, "docString": "The image under a monoid hom of the submonoid generated by a set equals the submonoid generated\nby the image of the set. ", "terms": "[\n    \"image\",\n    \"monoid\",\n    \"hom\",\n    \"submonoid\",\n    \"generated\",\n    \"set\",\n    \"equals\"\n]"}
{"type": "{α : Type u_1} →\n  [inst : DecidableEq α] →\n    {s : Finset α} →\n      {p : (t : Finset α) → t ⊂ s → Prop} →\n        [inst : (t : Finset α) → (h : t ⊂ s) → Decidable (p t h)] → Decidable (∀ (t : Finset α) (h : t ⊂ s), p t h)", "name": "Finset.decidableForallOfDecidableSSubsets", "isProp": false, "docString": "For predicate `p` decidable on ssubsets, it is decidable whether `p` holds for every ssubset. ", "terms": "[\n    \"predicate\",\n    \"decidable\",\n    \"subsets\",\n    \"holds\"\n]"}
{"type": "Num → PosNum", "name": "Num.succ'", "isProp": false, "docString": "The successor of a `Num` as a `PosNum`. ", "terms": "[\n    \"successor\", \n    \"Num\", \n    \"PosNum\"\n]"}
{"type": "∀ {β : Type u} {α : Type v} {s : Finset α} {f : α → β} [inst : AddCommMonoid β] (R : Setoid α)\n  [inst_1 : DecidableRel Setoid.r],\n  (∀ x ∈ s, (Finset.sum (Finset.filter (fun y => y ≈ x) s) fun a => f a) = 0) → (Finset.sum s fun x => f x) = 0", "name": "Finset.sum_cancels_of_partition_cancels", "isProp": true, "docString": "If we can partition a sum into subsets that cancel out, then the whole sum cancels.", "terms": "[\"partition\", \"sum\", \"subsets\", \"cancel out\"]"}
{"type": "∀ {n : ℕ} {α : Type u_1} {v : Vector α n}, Vector.toList (Vector.reverse v) = List.reverse (Vector.toList v)", "name": "Vector.toList_reverse", "isProp": true, "docString": "The `List` of a vector after a `reverse`, retrieved by `toList` is equal\nto the `List.reverse` after retrieving a vector's `toList`. ", "terms": "[\n    \"List\",\n    \"Vector\",\n    \"Reverse\",\n    \"ToList\",\n    \"List.reverse\"\n]"}
{"type": "∃ a, 0 < a ∧ ∀ (n : ℕ), a ≤ Stirling.stirlingSeq (n + 1)", "name": "Stirling.stirlingSeq'_bounded_by_pos_constant", "isProp": true, "docString": "The sequence `stirlingSeq` has a positive lower bound.\n", "terms": "[\"sequence\", \"positive lower bound\"]"}
{"type": "{ι : Type u_1} →\n  (V : Type u) →\n    [inst : CategoryTheory.Category.{v, u} V] →\n      [inst : CategoryTheory.Preadditive V] → ComplexShape ι → Type (max (max u u_1) v)", "name": "HomotopyCategory", "isProp": false, "docString": "`HomotopyCategory V c` is the category of chain complexes of shape `c` in `V`,\nwith chain maps identified when they are homotopic. ", "terms": "[\n    \"HomotopyCategory\", \n    \"category\", \n    \"chain complexes\", \n    \"chain maps\", \n    \"homotopic\"\n]"}
{"type": "{τ : Type u_1} → {α : Type u_2} → (τ → α → α) → Set α → Prop", "name": "IsInvariant", "isProp": false, "docString": "A set `s ⊆ α` is invariant under `ϕ : τ → α → α` if\n`ϕ t s ⊆ s` for all `t` in `τ`. ", "terms": "[\n  \"set\",\n  \"subset\",\n  \"invariant\",\n  \"under\",\n  \"function\",\n  \"for all\"\n]"}
{"type": "∀ {α : Type u_1} [inst : LinearOrder α] {s : Finset α} {k : ℕ} (h : Finset.card s = k) (hz : 0 < k),\n  (Finset.orderEmbOfFin s h) { val := k - 1, isLt := (_ : k - 1 < k) } = Finset.max' s (_ : Finset.Nonempty s)", "name": "Finset.orderEmbOfFin_last", "isProp": true, "docString": "The bijection `orderEmbOfFin s h` sends `k-1` to the maximum of `s`. ", "terms": "[\n  \"bijection\",\n  \"orderEmbOfFin\",\n  \"sends\",\n  \"maximum\"\n]"}
{"type": "(C : Type u_1) →\n  [inst : CategoryTheory.Category.{u_4, u_1} C] →\n    (A : Type u_3) → [inst_1 : AddMonoid A] → [inst : CategoryTheory.HasShift C A] → Type u_1", "name": "CategoryTheory.OppositeShift", "isProp": false, "docString": "The category `OppositeShift C A` is the opposite category `Cᵒᵖ` equipped\nwith the naive shift: `shiftFunctor (OppositeShift C A) n` is `(shiftFunctor C n).op`. ", "terms": "[\n    \"category\",\n    \"OppositeShift\",\n    \"opposite category\",\n    \"Cᵒᵖ\",\n    \"equipped\",\n    \"naive shift\",\n    \"shiftFunctor\",\n    \"op\"\n]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [self : CategoryTheory.Limits.HasFiniteCoproducts C] (n : ℕ),\n  CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (Fin n)) C", "name": "CategoryTheory.Limits.HasFiniteCoproducts.out", "isProp": true, "docString": "`C` has all finite coproducts ", "terms": "[\"C\", \"finite\", \"coproducts\"]"}
{"type": "∀ {R : Type u} [inst : Semiring R] {S : Type v} [inst_1 : Semiring S] (f : R →+* S), Polynomial.X ∈ Polynomial.lifts f", "name": "Polynomial.X_mem_lifts", "isProp": true, "docString": "The polynomial `X` lifts. ", "terms": "[\"polynomial\", \"lifts\"]"}
{"type": "∀ {A : Type u_1} [inst : AddCancelMonoid A] [inst_1 : Finset.HasAntidiagonal A] {n : A}\n  {p q : { x // x ∈ Finset.antidiagonal n }}, (↑p).1 = (↑q).1 → p = q", "name": "Finset.antidiagonal_subtype_ext", "isProp": true, "docString": "A point in the antidiagonal is determined by its first co-ordinate (subtype version of\n`Finset.antidiagonal_congr`). This lemma is used by the `ext` tactic. ", "terms": "[\n    \"point\",\n    \"antidiagonal\",\n    \"determined\",\n    \"first co-ordinate\",\n    \"subtype\",\n    \"version\",\n    \"Finset.antidiagonal_congr\",\n    \"lemma\",\n    \"ext\",\n    \"tactic\"\n]"}
{"type": "∀ (p : ENNReal) (h : p ≤ 1), PMF.binomial p h 1 = PMF.map (fun x => bif x then 1 else 0) (PMF.bernoulli p h)", "name": "PMF.binomial_one_eq_bernoulli", "isProp": true, "docString": "The binomial distribution on one coin is the bernoully distribution. ", "terms": "[\n    \"binomial distribution\",\n    \"coin\",\n    \"Bernoulli distribution\"\n]"}
{"type": "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₂] →\n      [inst_1 : Zero M₂] →\n        [inst_2 : SMul ℕ M₂] →\n          [inst_3 : Neg M₂] →\n            [inst_4 : Sub M₂] →\n              [inst_5 : SMul ℤ M₂] →\n                [inst_6 : AddGroup M₁] →\n                  (f : M₁ → M₂) →\n                    Function.Surjective f →\n                      f 0 = 0 →\n                        (∀ (x y : M₁), f (x + y) = f x + f y) →\n                          (∀ (x : M₁), f (-x) = -f x) →\n                            (∀ (x y : M₁), f (x - y) = f x - f y) →\n                              (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) →\n                                (∀ (x : M₁) (n : ℤ), f (n • x) = n • f x) → AddGroup M₂", "name": "Function.Surjective.addGroup", "isProp": false, "docString": "A type endowed with `0` and `+` is an additive group, if it admits a\nsurjective map that preserves `0` and `+` to an additive group.", "terms": "[\n    \"type\",\n    \"endowed\",\n    \"0\",\n    \"+\",\n    \"additive group\",\n    \"admits\",\n    \"surjective map\",\n    \"preserves\"\n]"}
{"type": "∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\n  a ≠ 0 → (quadraticChar F) a ^ 2 = 1", "name": "quadraticChar_sq_one", "isProp": true, "docString": "The square of the quadratic character on nonzero arguments is `1`. ", "terms": "[\n  \"Square\",\n  \"Quadratic character\",\n  \"Nonzero arguments\"\n]"}
{"type": "∀ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {Q : QuadraticForm R M} (d : Module.Dual R M) (a : M) (b : CliffordAlgebra Q),\n  (CliffordAlgebra.contractLeft d) ((CliffordAlgebra.ι Q) a * b) =\n    d a • b - (CliffordAlgebra.ι Q) a * (CliffordAlgebra.contractLeft d) b", "name": "CliffordAlgebra.contractLeft_ι_mul", "isProp": true, "docString": "This is [grinberg_clifford_2016][] Theorem 6  ", "terms": "The statement provided does not contain any mathematical terms. It simply references a theorem from a source. Therefore, the JSON list is empty. Here is the return:\n\n    []"}
{"type": "{R : Type u} →\n  {S : Type v} → {F : Type u_1} → [inst : Semiring R] → [inst_1 : Semiring S] → [rcf : RingHomClass F R S] → F → Ideal R", "name": "RingHom.ker", "isProp": false, "docString": "Kernel of a ring homomorphism as an ideal of the domain. ", "terms": "[\n  \"Kernel\",\n  \"Ring\",\n  \"Homomorphism\",\n  \"Ideal\",\n  \"Domain\"\n]"}
{"type": "∀ {G₁ : Type u_2} {G₂ : Type u_3} [inst : Group G₁] [inst_1 : Group G₂] [inst_2 : Group.IsNilpotent G₁]\n  [inst_3 : Group.IsNilpotent G₂], Group.IsNilpotent (G₁ × G₂)", "name": "isNilpotent_prod", "isProp": true, "docString": "Products of nilpotent groups are nilpotent ", "terms": "[\n    \"Products\",\n    \"nilpotent groups\",\n    \"nilpotent\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {K : NNReal} {s : Set α}\n  {f : α → β}, LipschitzOnWith K f s → ∀ x ∈ s, ∀ y ∈ s, dist (f x) (f y) ≤ ↑K * dist x y", "name": "LipschitzOnWith.dist_le_mul", "isProp": true, "docString": "**Alias** of the forward direction of `lipschitzOnWith_iff_dist_le_mul`.", "terms": "[]\n"}
{"type": "{α : Type u} → [inst : LT α] → [inst : DecidableRel fun x x_1 => x < x_1] → α → α → Ordering", "name": "cmp", "isProp": false, "docString": "Construct an `Ordering` from a type with a decidable `LT` instance,\nassuming that incomparable terms are `Ordering.eq`.\n", "terms": "[\n    \"Construct\", \n    \"Ordering\", \n    \"type\", \n    \"decidable\", \n    \"LT\", \n    \"instance\", \n    \"assuming\", \n    \"incomparable\", \n    \"terms\", \n    \"Ordering.eq\"\n]"}
{"type": "∀ {α : Type u} [inst : AddMonoid α] (f : ℕ → α) (n : ℕ),\n  List.sum (List.map f (List.range (Nat.succ n))) = f 0 + List.sum (List.map (fun i => f (Nat.succ i)) (List.range n))", "name": "List.sum_range_succ'", "isProp": true, "docString": "A variant of `sum_range_succ` which pulls off the first term in the sum rather than the last.", "terms": "[]"}
{"type": "{α : Type u_2} →\n  [inst : Add α] →\n    [inst_1 : LinearOrder α] → [inst : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] → α → α ↪o α", "name": "OrderEmbedding.addLeft", "isProp": false, "docString": "The order embedding sending `b` to `a + b`, for some fixed `a`.\nSee also `OrderIso.addLeft` when working in an additive ordered group.", "terms": "[\n    \"Order embedding\",\n    \"Addition\",\n    \"Fixed\",\n    \"OrderIso.addLeft\",\n    \"Additive ordered group\"\n]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  {p p₁ p₂ p₃ : P},\n  p₁ ≠ p →\n    p₂ ≠ p →\n      p₃ ≠ p → EuclideanGeometry.oangle p₁ p p₃ - EuclideanGeometry.oangle p₁ p p₂ = EuclideanGeometry.oangle p₂ p p₃", "name": "EuclideanGeometry.oangle_sub_left", "isProp": true, "docString": "Given three points not equal to `p`, the angle between the first and the third at `p` minus\nthe angle between the first and the second equals the angle between the second and the third. ", "terms": "[\"points\", \"equal\", \"angle\", \"between\", \"first\", \"third\", \"at\", \"minus\", \"second\", \"equals\"]"}
{"type": "(R : Type u) → (L : Type v) → [inst : CommRing R] → [inst_1 : LieRing L] → [inst_2 : LieAlgebra R L] → LieIdeal R L", "name": "LieAlgebra.radical", "isProp": false, "docString": "The (solvable) radical of Lie algebra is the `sSup` of all solvable ideals. ", "terms": "[\n  \"solvable\",\n  \"radical\",\n  \"Lie algebra\",\n  \"sSup\",\n  \"ideals\"\n]"}
{"type": "∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] (a : α), |a| = a ∧ 0 ≤ a ∨ |a| = -a ∧ a < 0", "name": "abs_cases", "isProp": true, "docString": "For an element `a` of a linear ordered ring, either `abs a = a` and `0 ≤ a`,\nor `abs a = -a` and `a < 0`.\nUse cases on this lemma to automate linarith in inequalities ", "terms": "[\"element\", \"linear ordered ring\", \"abs\", \"0\", \"≤\", \"-\", \"<\", \"lemma\", \"automate\", \"linarith\", \"inequalities\"]"}
{"type": "{I : Type u} →\n  {C : Set (I → Bool)} →\n    (hC : IsCompact C) →\n      [inst : (s : Finset I) → (i : I) → Decidable (i ∈ s)] →\n        CategoryTheory.Limits.Cone (Profinite.NobelingProof.spanFunctor hC)", "name": "Profinite.NobelingProof.spanCone", "isProp": false, "docString": "The limit cone on `spanFunctor` with point `C`. ", "terms": "[\"limit cone\", \"spanFunctor\", \"point\"]"}
{"type": "{m : Type u_3} →\n  {n : Type u_4} →\n    {α : Type u_5} →\n      [inst : Fintype m] →\n        [inst : Fintype n] → [inst : SeminormedAddCommGroup α] → SeminormedAddCommGroup (Matrix m n α)", "name": "Matrix.linftyOpSeminormedAddCommGroup", "isProp": false, "docString": "Seminormed group instance (using sup norm of L1 norm) for matrices over a seminormed group. Not\ndeclared as an instance because there are several natural choices for defining the norm of a\nmatrix. ", "terms": "[\n\"Seminormed group\",\n\"sup norm\",\n\"L1 norm\",\n\"matrices\",\n\"norm\"\n]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {s : EuclideanGeometry.Sphere P} {p₁ p₂ p₃ : P},\n  Collinear ℝ {p₁, p₂, p₃} → p₁ ∈ s → dist p₂ s.center < s.radius → p₃ ∈ s → p₁ ≠ p₃ → Sbtw ℝ p₁ p₂ p₃", "name": "EuclideanGeometry.sbtw_of_collinear_of_dist_center_lt_radius", "isProp": true, "docString": "Given three collinear points, two on a sphere and one inside it, the one inside it is\nstrictly between the other two points. ", "terms": "[\n  \"collinear points\",\n  \"sphere\",\n  \"inside\",\n  \"strictly between\",\n  \"points\"\n]"}
{"type": "∀ {g : Matrix.SpecialLinearGroup (Fin 2) ℤ} {z : UpperHalfPlane},\n  z ∈ ModularGroup.fdo → g • z ∈ ModularGroup.fdo → ↑g 1 0 = 0", "name": "ModularGroup.c_eq_zero", "isProp": true, "docString": "An auxiliary result en route to `ModularGroup.eq_smul_self_of_mem_fdo_mem_fdo`. ", "terms": "The statement you provided does not contain any mathematical terms, it seems more like a reference to a specific result or theorem, but without any explicit mathematical terms mentioned. Therefore, the answer is an empty list.\n\n[]"}
{"type": "(R : Type u_7) →\n  {ι : Type u_8} →\n    [inst : CommSemiring ι] →\n      [inst_1 : Module ι (Additive ℤˣ)] →\n        [inst_2 : DecidableEq ι] →\n          (𝒜 : ι → Type u_9) →\n            (ℬ : ι → Type u_10) →\n              [inst_3 : CommRing R] →\n                [inst_4 : (i : ι) → AddCommGroup (𝒜 i)] →\n                  [inst_5 : (i : ι) → AddCommGroup (ℬ i)] →\n                    [inst_6 : (i : ι) → Module R (𝒜 i)] →\n                      [inst_7 : (i : ι) → Module R (ℬ i)] →\n                        [inst_8 : DirectSum.GRing 𝒜] →\n                          [inst_9 : DirectSum.GRing ℬ] →\n                            [inst_10 : DirectSum.GAlgebra R 𝒜] →\n                              [inst : DirectSum.GAlgebra R ℬ] →\n                                TensorProduct R (DirectSum ι 𝒜) (DirectSum ι ℬ) →ₗ[R]\n                                  TensorProduct R (DirectSum ι 𝒜) (DirectSum ι ℬ) →ₗ[R]\n                                    TensorProduct R (DirectSum ι 𝒜) (DirectSum ι ℬ)", "name": "TensorProduct.gradedMul", "isProp": false, "docString": "The multiplication operation for tensor products of externally `ι`-graded algebras. ", "terms": "[\n    \"multiplication operation\",\n    \"tensor products\",\n    \"externally `ι`-graded\",\n    \"algebras\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {m : MeasurableSpace α} {mβ : MeasurableSpace β} [inst : Zero β]\n  [inst_1 : MeasurableSingletonClass β] (b : β) [inst_2 : NeZero b],\n  Measurable (Set.indicator s fun x => b) ↔ MeasurableSet s", "name": "measurable_indicator_const_iff", "isProp": true, "docString": "The measurability of a set `A` is equivalent to the measurability of the indicator function\nwhich takes a constant value `b ≠ 0` on a set `A` and `0` elsewhere. ", "terms": "[\n    \"measurability\",\n    \"set\",\n    \"equivalent\",\n    \"indicator function\",\n    \"constant value\",\n    \"elsewhere\"\n]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    {W : CategoryTheory.MorphismProperty C} →\n      {X Y : C} → (s : Y ⟶ X) → W s → CategoryTheory.MorphismProperty.RightFraction W X Y", "name": "CategoryTheory.MorphismProperty.RightFraction.ofInv", "isProp": false, "docString": "The right fraction from `X` to `Y` given by a morphism `s : Y ⟶ X` such that `W s`. ", "terms": "[\n    \"right fraction\",\n    \"morphism\"\n]"}
{"type": "∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {F : Type v} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace 𝕜 F] {f : 𝕜 → F} {x : 𝕜} {f' : F},\n  HasDerivAt f f' x → HasFDerivAt f (ContinuousLinearMap.smulRight 1 f') x", "name": "HasDerivAt.hasFDerivAt", "isProp": true, "docString": "**Alias** of the forward direction of `hasDerivAt_iff_hasFDerivAt`.\n\n---\n\nExpressing `HasDerivAt f f' x` in terms of `HasFDerivAt` ", "terms": "[\"Alias\", \"forward direction\", \"hasDerivAt_iff_hasFDerivAt\", \"Expressing\", \"HasDerivAt\", \"terms\", \"HasFDerivAt\"]"}
{"type": "{R : Type u} →\n  [inst : Ring R] →\n    {M N : ModuleCat R} →\n      {f : M ⟶ N} →\n        ↥(LinearMap.ker f) →ₗ[R] ↑(CategoryTheory.Subobject.underlying.obj (CategoryTheory.Limits.kernelSubobject f))", "name": "ModuleCat.toKernelSubobject", "isProp": false, "docString": "Bundle an element `m : M` such that `f m = 0` as a term of `kernelSubobject f`. ", "terms": "[\n  \"Bundle\",\n  \"element\",\n  \"such that\",\n  \"term\",\n  \"kernelSubobject\"\n]"}
{"type": "∀ {ι : Type w} [inst : DecidableEq ι] [inst_1 : Fintype ι] (K : Type u) {L : Type v} (E : Type z) [inst_2 : Field K]\n  [inst_3 : Field L] [inst_4 : Field E] [inst_5 : Algebra K L] [inst_6 : Algebra K E] [inst_7 : Module.Finite K L]\n  [inst_8 : IsAlgClosed E] (b : ι → L) [inst_9 : IsSeparable K L] (e : ι ≃ (L →ₐ[K] E)),\n  (algebraMap K E) (Algebra.discr K b) = Matrix.det (Algebra.embeddingsMatrixReindex K E b e) ^ 2", "name": "Algebra.discr_eq_det_embeddingsMatrixReindex_pow_two", "isProp": true, "docString": "If `L/K` is a field extension and `b : ι → L`, then `discr K b` is the square of the\ndeterminant of the matrix whose `(i, j)` coefficient is `σⱼ (b i)`, where `σⱼ : L →ₐ[K] E` is the\nembedding in an algebraically closed field `E` corresponding to `j : ι` via a bijection\n`e : ι ≃ (L →ₐ[K] E)`. ", "terms": "[\"field extension\", \"determinant\", \"matrix\", \"coefficient\", \"embedding\", \"algebraically closed field\", \"bijection\"]"}
{"type": "∀ (x : ℂ), HasStrictDerivAt Complex.sinh (Complex.cosh x) x", "name": "Complex.hasStrictDerivAt_sinh", "isProp": true, "docString": "The complex hyperbolic sine function is everywhere strictly differentiable, with the derivative\n`cosh x`. ", "terms": "[\n  \"Complex\",\n  \"Hyperbolic Sine Function\",\n  \"Everywhere Strictly Differentiable\",\n  \"Derivative\",\n  \"Hyperbolic Cosine Function\"\n]"}
{"type": "∀ {R : Type u_1} [inst : CommRing R] [self : IsIntegrallyClosed R] {x : FractionRing R},\n  IsIntegral R x → ∃ y, (algebraMap R (FractionRing R)) y = x", "name": "IsIntegrallyClosed.algebraMap_eq_of_integral", "isProp": true, "docString": "All integral elements of `Frac(R)` are also elements of `R`. ", "terms": "[\n  \"integral elements\",\n  \"Frac\",\n  \"elements\"\n]"}
{"type": "Lean.Expr → Lean.Expr", "name": "Mathlib.MoveAdd.prepareOp", "isProp": false, "docString": "`prepareOp sum` takes an `Expr`ession as input.  It assumes that `sum` is a well-formed\nterm representing a repeated application of a binary operation and that the summands are the\nlast two arguments passed to the operation.\nIt returns the expression consisting of the operation with all its arguments already applied,\nexcept for the last two.\nThis is similar to `Lean.Meta.mkAdd, Lean.Meta.mkMul`, except that the resulting operation is\nprimed to work with operands of the same type as the ones already appearing in `sum`.\n\nThis is useful to rearrange the operands.\n", "terms": "[\n    \"prepareOp\",\n    \"sum\",\n    \"Expr\",\n    \"well-formed\",\n    \"term\",\n    \"repeated application\",\n    \"binary operation\",\n    \"summands\",\n    \"arguments\",\n    \"operation\",\n    \"expression\",\n    \"Lean.Meta.mkAdd\",\n    \"Lean.Meta.mkMul\",\n    \"operands\",\n    \"type\",\n    \"rearrange\"\n]"}
{"type": "{k G : Type u} → [inst : CommRing k] → [inst_1 : Group G] → (A : Rep k G) → Submodule k ↥(groupCohomology.twoCocycles A)", "name": "groupCohomology.twoCoboundaries", "isProp": false, "docString": "The 2-coboundaries `B²(G, A)` of `A : Rep k G`, defined as the image of the map\n`Fun(G, A) → Fun(G × G, A)` sending `(f, (g₁, g₂)) ↦ ρ_A(g₁)(f(g₂)) - f(g₁g₂) + f(g₁).` ", "terms": "[\n    \"2-coboundaries\",\n    \"B²(G, A)\",\n    \"Rep k G\",\n    \"image\",\n    \"map\",\n    \"Fun(G, A)\",\n    \"Fun(G × G, A)\",\n    \"ρ_A(g₁)\",\n    \"f(g₂)\",\n    \"f(g₁g₂)\",\n    \"f(g₁)\"\n]"}
{"type": "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → [inst : UniformSpace β] → γ ≃ α → UniformFun γ β ≃ᵤ UniformFun α β", "name": "UniformFun.congrLeft", "isProp": false, "docString": "Turn a bijection `γ ≃ α` into a uniform isomorphism\n`(γ →ᵤ β) ≃ᵤ (α →ᵤ β)` by pre-composing. ", "terms": "[\n  \"bijection\",\n  \"uniform isomorphism\",\n  \"pre-composing\"\n]"}
{"type": "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {𝕜 : Type u_3} {G : Type u_4}\n  [inst_2 : IsROrC 𝕜] [inst_3 : NormedSpace 𝕜 E] [inst_4 : NormedAddCommGroup G] [inst_5 : NormedSpace 𝕜 G] {s : Set E}\n  {x : E} {f' : E → E →L[𝕜] G},\n  Convex ℝ s →\n    ∀ {f : E → G},\n      (∀ᶠ (y : E) in nhdsWithin x s, HasFDerivWithinAt f (f' y) s y) →\n        ContinuousWithinAt f' s x → ∃ K, ∃ t ∈ nhdsWithin x s, LipschitzOnWith K f t", "name": "Convex.exists_nhdsWithin_lipschitzOnWith_of_hasFDerivWithinAt", "isProp": true, "docString": "Let `s` be a convex set in a real normed vector space `E`, let `f : E → G` be a function\ndifferentiable within `s` in a neighborhood of `x : E` with derivative `f'`. Suppose that `f'` is\ncontinuous within `s` at `x`. Then for any number `K : ℝ≥0` larger than `‖f' x‖₊`, `f` is Lipschitz\non some neighborhood of `x` within `s`. See also\n`Convex.exists_nhdsWithin_lipschitzOnWith_of_hasFDerivWithinAt_of_nnnorm_lt` for a version\nwith an explicit estimate on the Lipschitz constant. ", "terms": "[\n    \"convex set\",\n    \"real\",\n    \"normed vector space\",\n    \"function\",\n    \"differentiable\",\n    \"neighborhood\",\n    \"derivative\",\n    \"continuous\",\n    \"number\",\n    \"larger than\",\n    \"Lipschitz\",\n    \"explicit estimate\",\n    \"Lipschitz constant\"\n]"}
{"type": "Type (u_1 + 1)", "name": "NatOrdinal", "isProp": false, "docString": "A type synonym for ordinals with natural addition and multiplication. ", "terms": "[\"type synonym\", \"ordinals\", \"natural addition\", \"multiplication\"]"}
{"type": "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners 𝕜 E H} {G : Type u_4}\n  [inst_4 : TopologicalSpace G] [inst_5 : ChartedSpace H G] [inst_6 : Monoid G] [inst_7 : SmoothMul I G] (g : G)\n  (X : LeftInvariantDerivation I G),\n  (hfdifferential (_ : (smoothLeftMul I g) 1 = g)) ((Derivation.evalAt 1) ↑X) = (Derivation.evalAt g) ↑X", "name": "LeftInvariantDerivation.left_invariant'", "isProp": true, "docString": "Premature version of the lemma. Prefer using `left_invariant` instead. ", "terms": "[]"}
{"type": "{α : Type u_1} →\n  {ι : Type u_2} → {κ : Type u_3} → {C : (ι → Option α) → κ} → Combinatorics.Line.ColorFocused C → ι → Option α", "name": "Combinatorics.Line.ColorFocused.focus", "isProp": false, "docString": "The common endpoint of the lines in the color-focused collection. ", "terms": "[\"common endpoint\", \"lines\", \"collection\"]"}
{"type": "{V : Type u} → {G : SimpleGraph V} → {u v : V} → SimpleGraph.Walk G u v → ℕ", "name": "SimpleGraph.Walk.length", "isProp": false, "docString": "The length of a walk is the number of edges/darts along it. ", "terms": "[\"length\", \"walk\", \"number\", \"edges\", \"darts\", \"along\"]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    {n : ℕ} →\n      (F : CategoryTheory.ComposableArrows C n) →\n        (i j : ℕ) →\n          (hij : autoParam (i ≤ j) _auto✝) →\n            (hjn : autoParam (j ≤ n) _auto✝¹) →\n              F.obj { val := i, isLt := (_ : i < n + 1) } ⟶ F.obj { val := j, isLt := (_ : j < n + 1) }", "name": "CategoryTheory.ComposableArrows.map'", "isProp": false, "docString": "The map `F.obj' i ⟶ F.obj' j` when `F : ComposableArrows C n`, and `i` and `j`\nare natural numbers such that `i ≤ j ≤ n`. ", "terms": "[\n  \"map\",\n  \"ComposableArrows\",\n  \"natural numbers\"\n]"}
{"type": "{𝕜 : Type u_1} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type u_2} →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : NormedSpace 𝕜 E] →\n          {E' : Type u_3} →\n            [inst_3 : NormedAddCommGroup E'] →\n              [inst_4 : NormedSpace 𝕜 E'] →\n                {H : Type u_4} →\n                  [inst_5 : TopologicalSpace H] →\n                    {I : ModelWithCorners 𝕜 E H} →\n                      {H' : Type u_5} →\n                        [inst_6 : TopologicalSpace H'] →\n                          {I' : ModelWithCorners 𝕜 E' H'} →\n                            {N : Type u_6} →\n                              [inst_7 : TopologicalSpace N] →\n                                [inst_8 : ChartedSpace H N] →\n                                  {G : Type u_10} →\n                                    [inst_9 : AddMonoid G] →\n                                      [inst_10 : TopologicalSpace G] →\n                                        [inst_11 : ChartedSpace H' G] →\n                                          [inst_12 : SmoothAdd I' G] → ContMDiffMap I I' N G ⊤ →+ N → G", "name": "SmoothMap.coeFnAddMonoidHom", "isProp": false, "docString": "Coercion to a function as an `AddMonoidHom`.\nSimilar to `AddMonoidHom.coeFn`.", "terms": "[\n    \"Coercion\",\n    \"Function\",\n    \"AddMonoidHom\"\n]"}
{"type": "∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K]\n  {ifp_n ifp_succ_n : GeneralizedContinuedFraction.IntFractPair K},\n  GeneralizedContinuedFraction.IntFractPair.stream v n = some ifp_n →\n    GeneralizedContinuedFraction.IntFractPair.stream v (n + 1) = some ifp_succ_n → ↑ifp_succ_n.b ≤ ifp_n.fr⁻¹", "name": "GeneralizedContinuedFraction.IntFractPair.succ_nth_stream_b_le_nth_stream_fr_inv", "isProp": true, "docString": "Shows that the `n + 1`th integer part `bₙ₊₁` of the stream is smaller or equal than the inverse of\nthe `n`th fractional part `frₙ` of the stream.\nThis result is straight-forward as `bₙ₊₁` is defined as the floor of `1 / frₙ`.\n", "terms": "[\n    \"integer part\",\n    \"stream\",\n    \"smaller or equal\",\n    \"inverse\",\n    \"fractional part\",\n    \"result\",\n    \"straight-forward\",\n    \"defined\",\n    \"floor\"\n]"}
{"type": "∀ {α : Type u_1} [inst : Lattice α] [inst_1 : IsLowerModularLattice α] {a b : α}, b ⋖ a ⊔ b → a ⊓ b ⋖ a", "name": "Covby.inf_of_sup_right", "isProp": true, "docString": "**Alias** of `inf_covby_of_covby_sup_right`.", "terms": "The statement you provided does not contain any mathematical terms, so the list is empty. Here is the JSON representation of that:\n\n```json\n[]\n```"}
{"type": "{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {K : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} K] →\n        {C : Type u₃} →\n          [inst_2 : CategoryTheory.Category.{v₃, u₃} C] →\n            {F : CategoryTheory.Functor J C} →\n              (E : CategoryTheory.Functor K J) →\n                CategoryTheory.Limits.Cone F → CategoryTheory.Limits.Cone (CategoryTheory.Functor.comp E F)", "name": "CategoryTheory.Limits.Cone.whisker", "isProp": false, "docString": "Whisker a cone by precomposition of a functor. ", "terms": "[\"Whisker\", \"Cone\", \"Precomposition\", \"Functor\"]"}
{"type": "{α : Type u_1} → (α → α → Prop) → Sym2 α → Sym2 α → Prop", "name": "Sym2.GameAdd", "isProp": false, "docString": "`Sym2.GameAdd rα x y` means that `x` can be reached from `y` by decreasing either entry with\nrespect to the relation `rα`.\n\nSee `Prod.GameAdd` for the ordered pair analog. ", "terms": "[\n    \"Sym2.GameAdd\",\n    \"reached\",\n    \"decreasing\",\n    \"entry\",\n    \"relation\",\n    \"Prod.GameAdd\",\n    \"ordered pair\",\n    \"analog\"\n]"}
{"type": "{P : Type u_1} → [inst : LE P] → PartialOrder (Order.Ideal P)", "name": "Order.Ideal.instPartialOrderIdeal", "isProp": false, "docString": "The partial ordering by subset inclusion, inherited from `Set P`. ", "terms": "[\n    \"Partial ordering\",\n    \"Subset\",\n    \"Inclusion\",\n    \"Inherited\",\n    \"Set\"\n]"}
{"type": "Type", "name": "SetTheory.PGame.Domineering.Board", "isProp": false, "docString": "A Domineering board is an arbitrary finite subset of `ℤ × ℤ`. ", "terms": "[\n    \"Domineering board\", \n    \"arbitrary\", \n    \"finite\", \n    \"subset\", \n    \"ℤ × ℤ\"\n]"}
{"type": "{G : Type u_1} →\n  [inst : Group G] →\n    {S : Type u_6} → [inst_1 : SetLike S G] → [inst_2 : SubgroupClass S G] → {H K : S} → H ≤ K → ↥H →* ↥K", "name": "SubgroupClass.inclusion", "isProp": false, "docString": "The inclusion homomorphism from a subgroup `H` contained in `K` to `K`. ", "terms": "[\n  \"inclusion\",\n  \"homomorphism\",\n  \"subgroup\",\n  \"contained\",\n  \"in\"\n]"}
{"type": "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : α) {b : α}, 0 < b → a - b < a", "name": "sub_lt_self", "isProp": true, "docString": "**Alias** of the reverse direction of `sub_lt_self_iff`.", "terms": "[\"Alias\", \"reverse direction\", \"sub_lt_self_iff\"]"}
{"type": "(V : Type u_1) → (W : Type u_2) → SimpleGraph.Coloring (completeBipartiteGraph V W) Bool", "name": "SimpleGraph.CompleteBipartiteGraph.bicoloring", "isProp": false, "docString": "The bicoloring of a complete bipartite graph using whether a vertex\nis on the left or on the right. ", "terms": "[\n  \"bicoloring\",\n  \"complete bipartite graph\",\n  \"vertex\",\n  \"left\",\n  \"right\"\n]"}
{"type": "{Ω : Type u_1} →\n  {Ω' : Type u_2} →\n    [inst : MeasurableSpace Ω] →\n      [inst_1 : MeasurableSpace Ω'] →\n        [inst_2 : TopologicalSpace Ω] →\n          [inst_3 : OpensMeasurableSpace Ω] →\n            [inst_4 : TopologicalSpace Ω'] →\n              [inst_5 : BorelSpace Ω'] →\n                {f : Ω → Ω'} → Continuous f → MeasureTheory.FiniteMeasure Ω →L[NNReal] MeasureTheory.FiniteMeasure Ω'", "name": "MeasureTheory.FiniteMeasure.mapClm", "isProp": false, "docString": "The push-forward of a finite measure by a continuous function between Borel spaces as\na continuous linear map. ", "terms": "[\n  \"push-forward\",\n  \"finite measure\",\n  \"continuous function\",\n  \"Borel spaces\",\n  \"continuous linear map\"\n]"}
{"type": "∀ {Ω : Type u_1} {m0 : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω} {ℱ : MeasureTheory.Filtration ℕ m0}\n  {f : ℕ → Ω → ℝ} {R : NNReal} [inst : MeasureTheory.IsFiniteMeasure μ],\n  MeasureTheory.Submartingale f ℱ μ →\n    (∀ (n : ℕ), MeasureTheory.snorm (f n) 1 μ ≤ ↑R) →\n      ∀ᵐ (ω : Ω) ∂μ, Filter.Tendsto (fun n => f n ω) Filter.atTop (nhds (MeasureTheory.Filtration.limitProcess f ℱ μ ω))", "name": "MeasureTheory.Submartingale.ae_tendsto_limitProcess", "isProp": true, "docString": "**Almost everywhere martingale convergence theorem**: An L¹-bounded submartingale converges\nalmost everywhere to a `⨆ n, ℱ n`-measurable function. ", "terms": "[\n  \"Almost everywhere\",\n  \"Martingale convergence theorem\",\n  \"L¹-bounded\",\n  \"Submartingale\",\n  \"Converges\",\n  \"Measurable function\"\n]"}
{"type": "{C : Type u₁} → [inst : CategoryTheory.Category.{v₁, u₁} C] → C → Type (max u₁ v₁)", "name": "CategoryTheory.Subobject", "isProp": false, "docString": "The category of subobjects of `X : C`, defined as isomorphism classes of monomorphisms into `X`.\n", "terms": "[\n    \"category\",\n    \"subobjects\",\n    \"isomorphism\",\n    \"classes\",\n    \"monomorphisms\"\n]"}
{"type": "∀ {R₂ : Type u_2} [inst : Semiring R₂] {M₂ : Type u_5} [inst_1 : UniformSpace M₂] [inst_2 : AddCommMonoid M₂]\n  [inst_3 : Module R₂ M₂] [inst_4 : SeparatedSpace M₂] {f : M₂ →ₗ[R₂] M₂},\n  IsCompactOperator ⇑f →\n    ∀ {V : Submodule R₂ M₂} (hV : ∀ v ∈ V, f v ∈ V) [hcomplete : CompleteSpace ↥V],\n      IsCompactOperator ⇑(LinearMap.restrict f hV)", "name": "IsCompactOperator.restrict'", "isProp": true, "docString": "If a compact operator preserves a complete submodule, its restriction to that submodule is\ncompact.\n\nNote that, following mathlib's convention in linear algebra, `restrict` designates the restriction\nof an endomorphism `f : E →ₗ E` to an endomorphism `f' : ↥V →ₗ ↥V`. To prove that the restriction\n`f' : ↥U →ₛₗ ↥V` of a compact operator `f : E →ₛₗ F` is compact, apply\n`IsCompactOperator.codRestrict` to `f ∘ U.subtypeL`, which is compact by\n`IsCompactOperator.comp_clm`. ", "terms": "[\n    \"compact operator\",\n    \"preserves\",\n    \"complete submodule\",\n    \"restriction\",\n    \"endomorphism\",\n    \"compact\",\n    \"mathlib's convention\",\n    \"linear algebra\",\n    \"restrict\",\n    \"IsCompactOperator.codRestrict\",\n    \"compact\",\n    \"IsCompactOperator.comp_clm\"\n]"}
{"type": "{R : Type u_1} →\n  {M : Type u_2} →\n    {N : Type u_3} →\n      [inst : CommRing R] →\n        [inst_1 : AddCommGroup M] →\n          [inst_2 : AddCommGroup N] →\n            [inst_3 : Module R M] →\n              [inst_4 : Module R N] →\n                (Q : QuadraticForm R M) →\n                  (f : M →ₗ[R] N →ₗ[R] N) →\n                    (∀ (m : M) (x : N), (f m) ((f m) x) = Q m • x) → N →ₗ[R] CliffordAlgebra Q →ₗ[R] N", "name": "CliffordAlgebra.foldl", "isProp": false, "docString": "Fold a bilinear map along the generators of a term of the clifford algebra, with the rule\ngiven by `foldl Q f hf n (ι Q m * x) = f m (foldl Q f hf n x)`.\n\nFor example, `foldl f hf n (r • ι R u + ι R v * ι R w) = r • f u n + f v (f w n)`. ", "terms": "[\n  \"Fold\",\n  \"Bilinear map\",\n  \"Generators\",\n  \"Term\",\n  \"Clifford algebra\",\n  \"Rule\",\n  \"Example\"\n]"}
{"type": "∀ (n : ℕ) {m : ℝ}, 2 ≤ m → LiouvilleNumber.remainder m n < 1 / (m ^ Nat.factorial n) ^ n", "name": "LiouvilleNumber.remainder_lt", "isProp": true, "docString": "An upper estimate on the remainder. This estimate works with `m ∈ ℝ` satisfying `2 ≤ m` and is\nweaker than the estimate `LiouvilleNumber.remainder_lt'` above. However, this estimate is\nmore useful for the proof. ", "terms": "[\n    \"upper estimate\",\n    \"remainder\",\n    \"estimate\",\n    \"ℝ\",\n    \"LiouvilleNumber.remainder_lt'\"\n]"}
{"type": "∀ {A : Type u_1} [inst : NormedAddCommGroup A] [inst_1 : CompactSpace A] [inst_2 : ConnectedSpace A]\n  [inst_3 : MeasurableSpace A] [inst_4 : BorelSpace A] {μ : MeasureTheory.Measure A}\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (ξ : A) {n : ℕ},\n  0 < n → ∀ (δ : ℝ), ↑↑μ Set.univ ≤ (n + 1) • ↑↑μ (Metric.closedBall 0 (δ / 2)) → ∃ j ∈ Set.Icc 1 n, ‖j • ξ‖ ≤ δ", "name": "NormedAddCommGroup.exists_norm_nsmul_le", "isProp": true, "docString": "A general version of **Dirichlet's approximation theorem**.\n\nSee also `AddCircle.exists_norm_nsmul_le`. ", "terms": "[\n    \"Dirichlet's approximation theorem\",\n    \"AddCircle.exists_norm_nsmul_le\"\n]"}
{"type": "{R : Type u} → [inst : AddMonoid R] → [inst_1 : StarAddMonoid R] → R ≃+ R", "name": "starAddEquiv", "isProp": false, "docString": "`star` as an `AddEquiv` ", "terms": "[\"star\", \"AddEquiv\"]"}
{"type": "∀ (R : Type u) [inst : Semiring R] [inst_1 : Nontrivial R] (p q : ℕ) [inst_2 : CharP R p] [inst : ExpChar R q],\n  q = 1 ↔ p = 0", "name": "expChar_one_iff_char_zero", "isProp": true, "docString": "The exponential characteristic is one iff the characteristic is zero. ", "terms": "[\n    \"exponential\",\n    \"characteristic\",\n    \"one\",\n    \"iff\",\n    \"zero\"\n]"}
{"type": "{α : Type u_2} →\n  {β : Type u_3} → [inst : TopologicalSpace α] → [inst_1 : TopologicalSpace β] → SpectralMap α β → C(α, β)", "name": "SpectralMap.toContinuousMap", "isProp": false, "docString": "Reinterpret a `SpectralMap` as a `ContinuousMap`. ", "terms": "[\"SpectralMap\", \"ContinuousMap\"]"}
{"type": "∀ {G : Type u_7} [inst : AddGroup G] (self : NonarchAddGroupSeminorm G) (r s : G),\n  ZeroHom.toFun self.toZeroHom (r + s) ≤ max (ZeroHom.toFun self.toZeroHom r) (ZeroHom.toFun self.toZeroHom s)", "name": "NonarchAddGroupSeminorm.add_le_max'", "isProp": true, "docString": "The seminorm applied to a sum is dominated by the maximum of the function applied to the\naddends. ", "terms": "[\n    \"seminorm\",\n    \"sum\",\n    \"dominated\",\n    \"maximum\",\n    \"function\",\n    \"addends\"\n]"}
{"type": "{M : Type u_5} → [inst : AddCommMonoid M] → (S : AddSubmonoid M) → AddCommMonoid ↥S", "name": "AddSubmonoid.toAddCommMonoid", "isProp": false, "docString": "An `AddSubmonoid` of an `AddCommMonoid` is an `AddCommMonoid`.", "terms": "[\n    \"AddSubmonoid\",\n    \"AddCommMonoid\"\n]"}
{"type": "∀ {α : Type u_4} {β : Type u_5} {γ : Type u_3} {a : Option α} {b : Option β} {β' : Type u_1} {δ : Type u_2}\n  {f : α → β' → γ} {g : β → β'} {f' : α → β → δ} {g' : δ → γ},\n  (∀ (a : α) (b : β), f a (g b) = g' (f' a b)) → Option.map₂ f a (Option.map g b) = Option.map g' (Option.map₂ f' a b)", "name": "Option.map_map₂_right_comm", "isProp": true, "docString": "Symmetric statement to `Option.map_map₂_distrib_right`. ", "terms": "[\"Symmetric\", \"Option\", \"map_map₂\", \"distrib_right\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {X Y Z : C} →\n      {f : X ⟶ Y} →\n        {g : X ⟶ Z} →\n          {W : C} →\n            (inl : Y ⟶ W) →\n              (inr : Z ⟶ W) →\n                CategoryTheory.CategoryStruct.comp f inl = CategoryTheory.CategoryStruct.comp g inr →\n                  CategoryTheory.Limits.PushoutCocone f g", "name": "CategoryTheory.Limits.PushoutCocone.mk", "isProp": false, "docString": "A pushout cocone on `f` and `g` is determined by morphisms `inl : Y ⟶ W` and `inr : Z ⟶ W` such\nthat `f ≫ inl = g ↠ inr`. ", "terms": "[\n    \"pushout cocone\",\n    \"morphisms\"\n]"}
{"type": "∀ (x : SetTheory.PGame), 0 * x ≈ 0", "name": "SetTheory.PGame.zero_mul_equiv", "isProp": true, "docString": "`0 * x` is equivalent to `0`. ", "terms": "[\"0\", \"*\", \"x\", \"equivalent\", \"0\"]"}
{"type": "∀ {m n : ℕ+}, ↑m = ↑n ↔ m = n", "name": "PNat.coe_inj", "isProp": true, "docString": "We now define a long list of structures on `ℕ+` induced by\nsimilar structures on `ℕ`. Most of these behave in a completely\nobvious way, but there are a few things to be said about\nsubtraction, division and powers.\n", "terms": "[\n    \"structures\",\n    \"ℕ+\",\n    \"induced\",\n    \"ℕ\",\n    \"subtraction\",\n    \"division\",\n    \"powers\"\n]"}
{"type": "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set (α × α)} {x : α},\n  s ∈ nhds (x, x) → ∃ U, IsOpen U ∧ x ∈ U ∧ U ×ˢ U ⊆ s", "name": "exists_nhds_square", "isProp": true, "docString": "Given a neighborhood `s` of `(x, x)`, then `(x, x)` has a square open neighborhood\nthat is a subset of `s`. ", "terms": "[\"neighborhood\", \"subset\", \"square open neighborhood\"]"}
{"type": "∀ {α : Type u_1} {ι : Type u_4} {p : ι → Prop} {s : ι → Set α}, Filter.IsCountableBasis p s → Set.Countable (setOf p)", "name": "Filter.IsCountableBasis.countable", "isProp": true, "docString": "The set of `i` that satisfy the predicate `p` is countable. ", "terms": "[\n  \"set\",\n  \"satisfy\",\n  \"predicate\",\n  \"countable\"\n]"}
{"type": "CategoryTheory.Limits.PreservesLimitsOfSize.{v, v, max u v, max u v, max (u + 1) (v + 1), max (u + 1) (v + 1)}\n  (CategoryTheory.forget₂ AddCommMonCatMax AddMonCatMax)", "name": "AddCommMonCat.forget₂AddMonPreservesLimits", "isProp": false, "docString": "The forgetful functor from additive\n\ncommutative monoids to additive monoids preserves all limits.\n\n\nThis means the underlying type of a limit can be computed as a limit in the category of additive\n\nmonoids.", "terms": "[\n    \"forgetful functor\",\n    \"additive commutative monoids\",\n    \"additive monoids\",\n    \"preserves\",\n    \"limits\",\n    \"underlying type\",\n    \"computed\",\n    \"category\"\n]"}
{"type": "∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1", "name": "LinearOrderedCommGroupWithZero.mul_inv_cancel", "isProp": true, "docString": "Every nonzero element of a group with zero is invertible. ", "terms": "[\n    \"nonzero element\",\n    \"group\",\n    \"zero\",\n    \"invertible\"\n]"}
{"type": "∀ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : NoZeroSMulDivisors K V] [inst_4 : StrongRankCondition K] (v : V),\n  v ≠ 0 → (∀ (w : V), ∃ c, c • v = w) → FiniteDimensional.finrank K V = 1", "name": "finrank_eq_one", "isProp": true, "docString": "If there is a nonzero vector and every other vector is a multiple of it,\nthen the module has dimension one. ", "terms": "[\n    \"nonzero vector\",\n    \"vector\",\n    \"multiple\",\n    \"module\",\n    \"dimension\"\n]"}
{"type": "{M : Type u_1} → [inst : Mul M] → Set M → Subsemigroup M", "name": "Subsemigroup.closure", "isProp": false, "docString": "The `Subsemigroup` generated by a set. ", "terms": "[\n    \"Subsemigroup\",\n    \"generated\",\n    \"set\"\n]"}
{"type": "{α : Type u_1} →\n  [inst : GeneralizedBooleanAlgebra α] →\n    [inst_1 : DecidableRel Disjoint] → [inst : DecidableRel fun x x_1 => x ≤ x_1] → α → α → α → α", "name": "UV.compress", "isProp": false, "docString": "UV-compressing `a` means removing `v` from it and adding `u` if `a` and `u` are disjoint and\n`v ≤ a` (it replaces the `v` part of `a` by the `u` part). Else, UV-compressing `a` doesn't do\nanything. This is most useful when `u` and `v` are disjoint finsets of the same size. ", "terms": "[\n    \"UV-compressing\",\n    \"removing\",\n    \"adding\",\n    \"disjoint\",\n    \"replaces\",\n    \"part\",\n    \"doesn't do anything\",\n    \"useful\",\n    \"finsets\",\n    \"size\"\n]"}
{"type": "{α : Type u_7} →\n  {β : Type u_8} → [inst : Add α] → [inst_1 : Mul α] → [inst_2 : Add β] → [inst_3 : Mul β] → αᵐᵒᵖ ≃+* βᵐᵒᵖ ≃ (α ≃+* β)", "name": "RingEquiv.unop", "isProp": false, "docString": "The 'unopposite' of a ring iso `αᵐᵒᵖ ≃+* βᵐᵒᵖ`. Inverse to `RingEquiv.op`. ", "terms": "[\n    \"unopposite\",\n    \"ring\",\n    \"iso\",\n    \"Inverse\",\n    \"RingEquiv.op\"\n]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {p1 p2 p3 p4 p5 : P},\n  EuclideanGeometry.angle p1 p5 p3 = Real.pi →\n    EuclideanGeometry.angle p2 p5 p4 = Real.pi → EuclideanGeometry.angle p1 p5 p2 = EuclideanGeometry.angle p3 p5 p4", "name": "EuclideanGeometry.angle_eq_angle_of_angle_eq_pi_of_angle_eq_pi", "isProp": true, "docString": "**Vertical Angles Theorem**: angles opposite each other, formed by two intersecting straight\nlines, are equal. ", "terms": "[\"Vertical Angles Theorem\", \"angles\", \"opposite\", \"intersecting\", \"straight lines\", \"equal\"]"}
{"type": "{X : Type u_1} → X → FreeAbelianGroup X →+ ℤ", "name": "FreeAbelianGroup.coeff", "isProp": false, "docString": "`coeff x` is the additive group homomorphism `FreeAbelianGroup X →+ ℤ`\nthat sends `a` to the multiplicity of `x : X` in `a`. ", "terms": "[\n    \"coeff\",\n    \"additive group\",\n    \"homomorphism\",\n    \"FreeAbelianGroup\",\n    \"ℤ\",\n    \"sends\",\n    \"multiplicity\"\n]"}
{"type": "{n : ℕ} → (m : ℕ) → Fin n → Fin (n + m)", "name": "Fin.castAdd", "isProp": false, "docString": "`castAdd m i` embeds `i : Fin n` in `Fin (n+m)`. See also `Fin.natAdd` and `Fin.addNat`. ", "terms": "[\"castAdd\", \"embeds\", \"Fin\", \"natAdd\", \"addNat\"]"}
{"type": "ℝ → ℕ → ℕ", "name": "SzemerediRegularity.initialBound", "isProp": false, "docString": "Auxiliary function for Szemerédi's regularity lemma. The size of the partition by which we start\nblowing. ", "terms": "[\"Auxiliary function\", \"Szemerédi's regularity lemma\", \"size\", \"partition\", \"start blowing\"]"}
{"type": "{T : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} T] →\n    {X : T} →\n      {U V : CategoryTheory.Under X} →\n        (f : U.right ⟶ V.right) → autoParam (CategoryTheory.CategoryStruct.comp U.hom f = V.hom) _auto✝ → (U ⟶ V)", "name": "CategoryTheory.Under.homMk", "isProp": false, "docString": "To give a morphism in the under category, it suffices to give a morphism fitting in a\ncommutative triangle. ", "terms": "[\n  \"morphism\",\n  \"under category\",\n  \"commutative triangle\"\n]"}
{"type": "∀ {ι : Type u_1} {V : Type u} [inst : CategoryTheory.Category.{v, u} V]\n  [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] {c : ComplexShape ι} (C : HomologicalComplex V c) {i i' j : ι}\n  (rij : ComplexShape.Rel c i j) (rij' : ComplexShape.Rel c i' j),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom (_ : HomologicalComplex.X C i = HomologicalComplex.X C i'))\n      (HomologicalComplex.d C i' j) =\n    HomologicalComplex.d C i j", "name": "HomologicalComplex.eqToHom_comp_d", "isProp": true, "docString": "If `C.d i j` and `C.d i' j` are both allowed, then we must have `i = i'`,\nand so the differentials only differ by an `eqToHom`.\n", "terms": "[\n  \"C.d i j\",\n  \"C.d i' j\",\n  \"allowed\",\n  \"must have\",\n  \"differentials\",\n  \"differ\",\n  \"eqToHom\"\n]"}
{"type": "Lean.TrailingParserDescr", "name": "«term_>_»", "isProp": false, "docString": "`a > b` is an abbreviation for `b < a`. ", "terms": "[\n  \"abbreviation\",\n  \">\"\n]"}
{"type": "∀ {α : Type u_1} {M : Type u_5} [inst : AddCommMonoid M] {f : α → M} {s : Set α},\n  (finsum fun i => finsum fun h => f i) ≠ 0 → ∃ x ∈ s, f x ≠ 0", "name": "exists_ne_zero_of_finsum_mem_ne_zero", "isProp": true, "docString": "If the product of `f i` over `i ∈ s` is not equal to `0`, then there is some `x ∈ s`\nsuch that `f x ≠ 0`.", "terms": "[\n    \"product\",\n    \"over\",\n    \"not equal to\",\n    \"some\",\n    \"such that\"\n]"}
{"type": "{α : Type u_1} → [inst : Unique α] → Encodable α", "name": "Unique.encodable", "isProp": false, "docString": "A type with unique element is encodable. This is not an instance to avoid diamonds. ", "terms": "[\"type\", \"unique element\", \"encodable\", \"instance\", \"avoid\", \"diamonds\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    (X : C) →\n      [inst_1 : CategoryTheory.Limits.HasBinaryProducts C] →\n        CategoryTheory.Functor (CategoryTheory.Comonad.Coalgebra (CategoryTheory.prodComonad X)) (CategoryTheory.Over X)", "name": "CategoryTheory.coalgebraToOver", "isProp": false, "docString": "The forward direction of the equivalence from coalgebras for the product comonad to the over\ncategory.\n", "terms": "[\n    \"forward direction\",\n    \"equivalence\",\n    \"coalgebras\",\n    \"product comonad\",\n    \"over category\"\n]"}
{"type": "(R : Type u_1) → [inst : Monoid R] → (S : Submonoid R) → [inst_1 : OreLocalization.OreSet S] → Setoid (R × ↥S)", "name": "OreLocalization.oreEqv", "isProp": false, "docString": "The setoid on `R × S` used for the Ore localization. ", "terms": "[\n    \"setoid\",\n    \"Ore localization\",\n    \"R\",\n    \"S\",\n    \"×\"\n]"}
{"type": "{X Y : TopCat} →\n  (f : X ⟶ Y) → (x : ↑X) → CategoryTheory.Functor (TopologicalSpace.OpenNhds (f x)) (TopologicalSpace.OpenNhds x)", "name": "TopologicalSpace.OpenNhds.map", "isProp": false, "docString": "The preimage functor from neighborhoods of `f x` to neighborhoods of `x`. ", "terms": "[\n    \"preimage functor\", \n    \"neighborhoods\"\n]"}
{"type": "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X → Y},\n  Continuous f → Monotone f", "name": "Continuous.specialization_monotone", "isProp": true, "docString": "A continuous function is monotone with respect to the specialization preorders on the domain and\nthe codomain. ", "terms": "[\n    \"continuous function\",\n    \"monotone\",\n    \"specialization preorders\",\n    \"domain\",\n    \"codomain\"\n]"}
{"type": "{ι : Type u_1} → BoxIntegral.Box ι → Set ι → BoxIntegral.Box ι", "name": "BoxIntegral.Box.splitCenterBox", "isProp": false, "docString": "For a box `I`, the hyperplanes passing through its center split `I` into `2 ^ card ι` boxes.\n`BoxIntegral.Box.splitCenterBox I s` is one of these boxes. See also\n`BoxIntegral.Partition.splitCenter` for the corresponding `BoxIntegral.Partition`. ", "terms": "[\n    \"box\",\n    \"hyperplanes\",\n    \"center\",\n    \"split\",\n    \"card\",\n    \"BoxIntegral.Box.splitCenterBox\",\n    \"BoxIntegral.Partition.splitCenter\",\n    \"BoxIntegral.Partition\"\n]"}
{"type": "(V : Type (u + 1)) →\n  [inst : CategoryTheory.LargeCategory V] →\n    (G : MonCat) → [inst_1 : CategoryTheory.MonoidalCategory V] → CategoryTheory.MonoidalFunctor (Action V G) V", "name": "Action.forgetMonoidal", "isProp": false, "docString": "When `V` is monoidal the forgetful functor `Action V G` to `V` is monoidal. ", "terms": "[\n  \"Monoidal\",\n  \"Forgetful Functor\",\n  \"Action\",\n  \"Monoidal\"\n]"}
{"type": "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {n : ℕ}\n  {v : Fin n → V}, LinearIndependent K v → n < FiniteDimensional.finrank K V → ∃ x, LinearIndependent K (Fin.snoc v x)", "name": "exists_linearIndependent_snoc_of_lt_finrank", "isProp": true, "docString": "Given a family of `n` linearly independent vectors in a finite-dimensional space of\ndimension `> n`, one may extend the family by another vector while retaining linear independence. ", "terms": "[\n  \"family\",\n  \"linearly independent vectors\",\n  \"finite-dimensional space\",\n  \"dimension\",\n  \"extend\",\n  \"vector\",\n  \"retaining\",\n  \"linear independence\"\n]"}
{"type": "∀ {n : ℕ} {p : Fin n} {i : Fin (n + 1)}, i ≠ Fin.castSucc p → Fin.succAbove (Fin.castSucc p) (Fin.predAbove p i) = i", "name": "Fin.succAbove_predAbove", "isProp": true, "docString": "Sending `Fin (n+1)` to `Fin n` by subtracting one from anything above `p`\nthen back to `Fin (n+1)` with a gap around `p` is the identity away from `p`. ", "terms": "[\n    \"Fin\",\n    \"subtracting\",\n    \"one\",\n    \"identity\",\n    \"gap\",\n    \"away\"\n]"}
{"type": "∀ {ι : Type u_4} {π : ι → Type u_9} [inst : Fintype ι] [inst_1 : (i : ι) → SeminormedGroup (π i)] (f : (i : ι) → π i),\n  (Finset.sum Finset.univ fun i => ‖f i‖₊) ≤ Fintype.card ι • ‖f‖₊", "name": "Pi.sum_nnnorm_apply_le_nnnorm'", "isProp": true, "docString": "The $L^1$ norm is less than the $L^\\infty$ norm scaled by the cardinality. ", "terms": "[\n  \"L^1 norm\",\n  \"less than\",\n  \"L^infty norm\",\n  \"scaled\",\n  \"cardinality\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} [inst : Semiring α] [inst_1 : Semiring β] {f : α → β}, IsSemiringHom f → f 1 = 1", "name": "IsSemiringHom.map_one", "isProp": true, "docString": "The proposition that `f` preserves the multiplicative identity. ", "terms": "[\n\"proposition\",\n\"preserves\",\n\"multiplicative identity\"\n]"}
{"type": "(𝕜 : Type u_1) →\n  {E : Type u_4} →\n    (Fₗ : Type u_7) →\n      [inst : SeminormedAddCommGroup E] →\n        [inst_1 : SeminormedAddCommGroup Fₗ] →\n          [inst_2 : NontriviallyNormedField 𝕜] →\n            [inst_3 : NormedSpace 𝕜 E] → [inst_4 : NormedSpace 𝕜 Fₗ] → E →L[𝕜] (E →L[𝕜] Fₗ) →L[𝕜] Fₗ", "name": "ContinuousLinearMap.apply", "isProp": false, "docString": "The continuous semilinear map obtained by applying a continuous semilinear map at a given\nvector.\n\nThis is the continuous version of `LinearMap.applyₗ`. ", "terms": "[\n    \"Continuous\",\n    \"Semilinear Map\",\n    \"Vector\",\n    \"LinearMap.applyₗ\"\n]"}
{"type": "(J : Type w) →\n  CategoryTheory.Functor.comp (CategoryTheory.Limits.widePullbackShapeUnop J)\n      (CategoryTheory.Limits.widePushoutShapeOp J) ≅\n    CategoryTheory.Functor.id (CategoryTheory.Limits.WidePullbackShape J)ᵒᵖ", "name": "CategoryTheory.Limits.widePullbackShapeOpUnop", "isProp": false, "docString": "The inverse of the unit isomorphism of the equivalence\n`widePullbackShapeOpEquiv : (WidePullbackShape J)ᵒᵖ ≌ WidePushoutShape J` ", "terms": "[\n    \"Inverse\",\n    \"Unit\",\n    \"Isomorphism\",\n    \"Equivalence\",\n    \"WidePullbackShape\",\n    \"OpEquiv\",\n    \"WidePushoutShape\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {e : PartialHomeomorph α β} {s : Set α} {t : Set γ} {x : α} {f : α → γ},\n  ContinuousWithinAt f s x →\n    x ∈ e.source →\n      t ∈ nhds (f x) →\n        ↑(PartialHomeomorph.symm e) ⁻¹' s =ᶠ[nhds (↑e x)] e.target ∩ ↑(PartialHomeomorph.symm e) ⁻¹' (s ∩ f ⁻¹' t)", "name": "PartialHomeomorph.preimage_eventuallyEq_target_inter_preimage_inter", "isProp": true, "docString": "This lemma is useful in the manifold library in the case that `e` is a chart. It states that\nlocally around `e x` the set `e.symm ⁻¹' s` is the same as the set intersected with the target\nof `e` and some other neighborhood of `f x` (which will be the source of a chart on `γ`).  ", "terms": "[\n    \"lemma\",\n    \"manifold\",\n    \"chart\",\n    \"locally\",\n    \"set\",\n    \"symm\",\n    \"inverse\",\n    \"intersected\",\n    \"target\",\n    \"neighborhood\",\n    \"source\"\n]"}
{"type": "{α : Type u} → (T : Set (Set α)) → ∅ ∈ T → (∀ A ⊆ T, ⋂₀ A ∈ T) → (∀ A ∈ T, ∀ B ∈ T, A ∪ B ∈ T) → TopologicalSpace α", "name": "TopologicalSpace.ofClosed", "isProp": false, "docString": "A constructor for topologies by specifying the closed sets,\nand showing that they satisfy the appropriate conditions. ", "terms": "[\n    \"Constructor\",\n    \"Topologies\",\n    \"Closed sets\",\n    \"Satisfy\",\n    \"Appropriate conditions\"\n]"}
{"type": "{J : Type v} →\n  [inst : CategoryTheory.SmallCategory J] →\n    (F : CategoryTheory.Functor J SemiRingCatMax) →\n      (j : J) →\n        (CategoryTheory.Limits.Types.limitCone\n              (CategoryTheory.Functor.comp F (CategoryTheory.forget SemiRingCat))).pt →+*\n          (CategoryTheory.Functor.comp F (CategoryTheory.forget SemiRingCat)).obj j", "name": "SemiRingCat.limitπRingHom", "isProp": false, "docString": "`limit.π (F ⋙ forget SemiRingCat) j` as a `RingHom`. ", "terms": "[\n    \"limit\",\n    \"π\",\n    \"F\",\n    \"⋙\",\n    \"forget\",\n    \"SemiRingCat\",\n    \"j\",\n    \"RingHom\"\n]"}
{"type": "(P : Type u_1) → (L : Type u_2) → [inst : Membership P L] → [inst : Configuration.ProjectivePlane P L] → ℕ", "name": "Configuration.ProjectivePlane.order", "isProp": false, "docString": "The order of a projective plane is one less than the number of lines through an arbitrary point.\nEquivalently, it is one less than the number of points on an arbitrary line. ", "terms": "[\n    \"order\",\n    \"projective plane\",\n    \"one less\",\n    \"number of lines\",\n    \"through\",\n    \"arbitrary point\",\n    \"equivalently\",\n    \"number of points\",\n    \"on\",\n    \"arbitrary line\"\n]"}
{"type": "{R₃ : Type u_7} →\n  [inst : CommRing R₃] →\n    {n : Type u_11} → [inst_1 : Fintype n] → Matrix n n R₃ → [inst_2 : DecidableEq n] → Submodule R₃ (Matrix n n R₃)", "name": "skewAdjointMatricesSubmodule'", "isProp": false, "docString": "The submodule of skew-adjoint matrices with respect to the bilinear form corresponding to\nthe matrix `J`. ", "terms": "[\n  \"submodule\",\n  \"skew-adjoint matrices\",\n  \"bilinear form\",\n  \"matrix\"\n]"}
{"type": "{ι : Type u_1} →\n  (I J : BoxIntegral.Box ι) → J ≤ I → (x : ι → ℝ) → x ∈ BoxIntegral.Box.Icc I → BoxIntegral.TaggedPrepartition I", "name": "BoxIntegral.TaggedPrepartition.single", "isProp": false, "docString": "Tagged prepartition with single box and prescribed tag. ", "terms": "[\n    \"Tagged prepartition\",\n    \"Single box\",\n    \"Prescribed tag\"\n]"}
{"type": "{α : Type u_1} →\n  {β : Type u_2} →\n    {m : MeasurableSpace α} →\n      {μ : MeasureTheory.Measure α} →\n        [inst : TopologicalSpace β] →\n          {f : α → β} → [inst_1 : Zero β] → [inst_2 : T2Space β] → MeasureTheory.AEFinStronglyMeasurable f μ → Set α", "name": "MeasureTheory.AEFinStronglyMeasurable.sigmaFiniteSet", "isProp": false, "docString": "A measurable set `t` such that `f =ᵐ[μ.restrict tᶜ] 0` and `sigma_finite (μ.restrict t)`. ", "terms": "[\n  \"measurable set\",\n  \"restrict\",\n  \"sigma_finite\"\n]"}
{"type": "{α : Type u_2} →\n  {β : Type u_3} →\n    {γ : Type u_4} →\n      [inst : InfSet α] → [inst_1 : InfSet β] → [inst_2 : InfSet γ] → sInfHom β γ → sInfHom α β → sInfHom α γ", "name": "sInfHom.comp", "isProp": false, "docString": "Composition of `sInfHom`s as a `sInfHom`. ", "terms": "[\n    \"Composition\",\n    \"sInfHom\"\n]"}
{"type": "{R : Type u} → WeierstrassCurve R → R", "name": "WeierstrassCurve.a₄", "isProp": false, "docString": "The `a₄` coefficient of a Weierstrass curve. ", "terms": "[\n    \"coefficient\",\n    \"Weierstrass curve\"\n]"}
{"type": "{α : Type u_1} → (op : α → α → α) → [hc : IsCommutative α op] → [ha : IsAssociative α op] → α → Multiset α → α", "name": "Multiset.fold", "isProp": false, "docString": "`fold op b s` folds a commutative associative operation `op` over\nthe multiset `s`. ", "terms": "[\n  \"fold\",\n  \"commutative\",\n  \"associative operation\",\n  \"multiset\"\n]"}
{"type": "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Add M] →\n      [inst_1 : Add N] → (f : AddHom M N) → {g : N → M} → Function.LeftInverse g ⇑f → M ≃+ ↥(AddHom.srange f)", "name": "AddEquiv.ofLeftInverse", "isProp": false, "docString": "An additive semigroup homomorphism `f : M →+ N` with a left-inverse\n`g : N → M` defines an additive equivalence between `M` and `f.srange`.\nThis is a bidirectional version of `AddHom.srangeRestrict`. ", "terms": "[\n    \"additive semigroup\",\n    \"homomorphism\",\n    \"left-inverse\",\n    \"additive equivalence\",\n    \"bidirectional\",\n    \"AddHom.srangeRestrict\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {γ' : Type u_6} {δ : Type u_7} {ε : Type u_9}\n  {f : Filter α} {g : Filter β} {h : Filter γ} {m : α → δ → ε} {n : β → γ → δ} {m₁ : α → β → β'} {m₂ : α → γ → γ'}\n  {n' : β' → γ' → ε},\n  (∀ (a : α) (b : β) (c : γ), m a (n b c) = n' (m₁ a b) (m₂ a c)) →\n    Filter.map₂ m f (Filter.map₂ n g h) ≤ Filter.map₂ n' (Filter.map₂ m₁ f g) (Filter.map₂ m₂ f h)", "name": "Filter.map₂_distrib_le_left", "isProp": true, "docString": "The other direction does not hold because of the `f`-`f` cross terms on the RHS. ", "terms": "[\"direction\", \"hold\", \"cross terms\", \"RHS\"]"}
{"type": "{ι : Type u_1} → {M : ι → Type u_2} → [inst : (i : ι) → Monoid (M i)] → {i : ι} → Monoid.CoprodI.Word.Pair M i → M i", "name": "Monoid.CoprodI.Word.Pair.head", "isProp": false, "docString": "An element of `M i`, the first letter of the word. ", "terms": "[\"element\"]"}
{"type": "Lean.Parser.Parser", "name": "Finsupp.fun₀", "isProp": false, "docString": "`fun₀ | i => a` is notation for `Finsupp.single i a`, and with multiple match arms,\n`fun₀ ... | i => a` is notation for `Finsupp.update (fun₀ ...) i a`.\n\nAs a result, if multiple match arms coincide, the last one takes precedence. ", "terms": "The mathematical terms in the statement are:\n\n- \"notation\"\n- \"Finsupp.single\"\n- \"multiple match arms\"\n- \"Finsupp.update\"\n- \"coincide\"\n- \"last one\"\n- \"takes precedence\"\n\nRepresented in JSON, it would look like:\n\n```json\n[\n    \"notation\",\n    \"Finsupp.single\",\n    \"multiple match arms\",\n    \"Finsupp.update\",\n    \"coincide\",\n    \"last one\",\n    \"takes precedence\"\n]\n```"}
{"type": "{V : Type u} → SimpleGraph V → Type v → Type (max u v)", "name": "SimpleGraph.Coloring", "isProp": false, "docString": "An `α`-coloring of a simple graph `G` is a homomorphism of `G` into the complete graph on `α`.\nThis is also known as a proper coloring.\n", "terms": "[\n    \"α-coloring\",\n    \"simple graph\",\n    \"homomorphism\",\n    \"complete graph\",\n    \"proper coloring\"\n]"}
{"type": "ℂ ≃L[ℝ] ℂ", "name": "Complex.conjCle", "isProp": false, "docString": "Continuous linear equiv version of the conj function, from `ℂ` to `ℂ`. ", "terms": "[\n\"Continuous\",\n\"Linear\",\n\"Equiv\",\n\"Function\",\n\"ℂ\"\n]"}
{"type": "{Ω : Type u_1} →\n  {ι : Type u_3} →\n    {m : MeasurableSpace Ω} →\n      [inst : Preorder ι] →\n        {E : Type u_4} →\n          [inst_1 : Zero E] →\n            [inst_2 : TopologicalSpace E] → (ι → Ω → E) → MeasureTheory.Filtration ι m → MeasureTheory.Measure Ω → Ω → E", "name": "MeasureTheory.Filtration.limitProcess", "isProp": false, "docString": "Given a process `f` and a filtration `ℱ`, if `f` converges to some `g` almost everywhere and\n`g` is `⨆ n, ℱ n`-measurable, then `limitProcess f ℱ μ` chooses said `g`, else it returns 0.\n\nThis definition is used to phrase the a.e. martingale convergence theorem\n`Submartingale.ae_tendsto_limitProcess` where an L¹-bounded submartingale `f` adapted to `ℱ`\nconverges to `limitProcess f ℱ μ` `μ`-almost everywhere. ", "terms": "[\n    \"process\",\n    \"filtration\",\n    \"converges\",\n    \"almost everywhere\",\n    \"measurable\",\n    \"limitProcess\",\n    \"returns\",\n    \"definition\",\n    \"phrase\",\n    \"martingale convergence theorem\",\n    \"Submartingale.ae_tendsto_limitProcess\",\n    \"L¹-bounded\",\n    \"submartingale\",\n    \"adapted\",\n    \"μ-almost everywhere\"\n]"}
{"type": "Lean.ParserDescr", "name": "WittVector.mapFun.tacticMap_fun_tac", "isProp": false, "docString": "Auxiliary tactic for showing that `mapFun` respects the ring operations. ", "terms": "[\"Auxiliary tactic\", \"showing\", \"mapFun\", \"respects\", \"ring operations\"]"}
{"type": "∀ {α : Type u_1} (n : ℕ) (a : α) (l : List α), List.length (List.leftpad n a l) = max n (List.length l)", "name": "List.leftpad_length", "isProp": true, "docString": "The length of the List returned by `List.leftpad n a l` is equal\nto the larger of `n` and `l.length` ", "terms": "[\n  \"length\",\n  \"List\",\n  \"leftpad\",\n  \"equal\",\n  \"larger\"\n]"}
{"type": "{A : Type u_4} → [inst : AddGroup A] → AddSubgroup A ≃o Subgroup (Multiplicative A)", "name": "AddSubgroup.toSubgroup", "isProp": false, "docString": "Additive subgroups of an additive group `A` are isomorphic to subgroups of `Multiplicative A`.\n", "terms": "[\n    \"Additive subgroups\",\n    \"additive group\",\n    \"isomorphic\",\n    \"subgroups\",\n    \"Multiplicative\"\n]"}
{"type": "Fin 2 ≃ Bool", "name": "finTwoEquiv", "isProp": false, "docString": "Equivalence between `Fin 2` and `Bool`. ", "terms": "[\"Equivalence\", \"Fin 2\", \"Bool\"]"}
{"type": "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      {δ : Type u_4} →\n        [inst : TopologicalSpace α] →\n          [inst_1 : TopologicalSpace β] →\n            [inst_2 : TopologicalSpace γ] →\n              [inst_3 : TopologicalSpace δ] →\n                PartialHomeomorph α β → PartialHomeomorph γ δ → PartialHomeomorph (α × γ) (β × δ)", "name": "PartialHomeomorph.prod", "isProp": false, "docString": "The product of two partial homeomorphisms, as a partial homeomorphism on the product space. ", "terms": "[\n    \"product\",\n    \"partial homeomorphisms\",\n    \"product space\"\n]"}
{"type": "{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {C : Type u₃} →\n      [inst_1 : CategoryTheory.Category.{v₃, u₃} C] →\n        {F : CategoryTheory.Functor J C} →\n          {t : CategoryTheory.Limits.Cone F} →\n            CategoryTheory.Limits.IsLimit t →\n              (W : C) → ULift.{u₁, v₃} (W ⟶ t.pt) ≅ (CategoryTheory.Functor.const J).obj W ⟶ F", "name": "CategoryTheory.Limits.IsLimit.homIso", "isProp": false, "docString": "The universal property of a limit cone: a map `W ⟶ X` is the same as\na cone on `F` with cone point `W`. ", "terms": "[\n    \"universal property\",\n    \"limit cone\",\n    \"map\",\n    \"cone\",\n    \"cone point\"\n]"}
{"type": "∀ {V : Type u} {K : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] [hK : Invertible 2] {B : BilinForm K V},\n  BilinForm.IsSymm B → ∃ v, BilinForm.iIsOrtho B ⇑v", "name": "BilinForm.exists_orthogonal_basis", "isProp": true, "docString": "Given a symmetric bilinear form `B` on some vector space `V` over a field `K`\nin which `2` is invertible, there exists an orthogonal basis with respect to `B`. ", "terms": "[\n\"symmetric bilinear form\",\n\"vector space\",\n\"field\",\n\"invertible\",\n\"orthogonal basis\",\n\"respect to\"\n]"}
{"type": "∀ {α : Type u_2} {f : Equiv.Perm α} {s : Finset α} (hf : Equiv.Perm.IsCycleOn f ↑s),\n  s ×ˢ s =\n    Finset.disjiUnion (Finset.range (Finset.card s))\n      (fun k =>\n        Finset.map\n          { toFun := fun i => (i, (f ^ k) i),\n            inj' :=\n              (_ :\n                ∀ (i j : α),\n                  (fun i => (i, (f ^ k) i)) i = (fun i => (i, (f ^ k) i)) j →\n                    ((fun i => (i, (f ^ k) i)) i).1 = ((fun i => (i, (f ^ k) i)) j).1) }\n          s)\n      (_ :\n        Set.PairwiseDisjoint ↑(Finset.range (Finset.card s)) fun k =>\n          Finset.map\n            { toFun := fun i => (i, (f ^ k) i),\n              inj' :=\n                (_ :\n                  ∀ (i j : α),\n                    (fun i => (i, (f ^ k) i)) i = (fun i => (i, (f ^ k) i)) j →\n                      ((fun i => (i, (f ^ k) i)) i).1 = ((fun i => (i, (f ^ k) i)) j).1) }\n            s)", "name": "Finset.product_self_eq_disjiUnion_perm", "isProp": true, "docString": "We can partition the square `s ×ˢ s` into shifted diagonals as such:\n```\n01234\n40123\n34012\n23401\n12340\n```\n\nThe diagonals are given by the cycle `f`.\n", "terms": "[\n  \"partition\",\n  \"square\",\n  \"shifted diagonals\",\n  \"cycle\"\n]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] (J : CategoryTheory.GrothendieckTopology C),\n  CategoryTheory.CoverPreserving J J (CategoryTheory.Functor.id C)", "name": "CategoryTheory.idCoverPreserving", "isProp": true, "docString": "The identity functor on a site is cover-preserving. ", "terms": "[\n    \"identity functor\", \n    \"site\", \n    \"cover-preserving\"\n]"}
{"type": "∀ {α : Type u_5} [self : ConditionallyCompleteLinearOrderedField α] (s : Set α), ¬BddAbove s → sSup s = sSup ∅", "name": "ConditionallyCompleteLinearOrderedField.csSup_of_not_bddAbove", "isProp": true, "docString": "If a set is not bounded above, its supremum is by convention `sSup ∅`. ", "terms": "[\n  \"set\",\n  \"bounded\",\n  \"above\",\n  \"supremum\",\n  \"convention\",\n  \"∅\"\n]"}
{"type": "ℂ → ℝ → ℝ → ℂ", "name": "GaussianFourier.verticalIntegral", "isProp": false, "docString": "The integral of the Gaussian function over the vertical edges of a rectangle\nwith vertices at `(±T, 0)` and `(±T, c)`.  ", "terms": "[\n    \"Integral\",\n    \"Gaussian function\",\n    \"Vertical edges\",\n    \"Rectangle\",\n    \"Vertices\"\n]"}
{"type": "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → Rel α β → Rel β γ → Rel α γ", "name": "Rel.comp", "isProp": false, "docString": "Composition of relation; note that it follows the `CategoryTheory/` order of arguments. ", "terms": "[\n    \"Composition of relation\",\n    \"CategoryTheory\",\n    \"order of arguments\"\n]"}
{"type": "PSet → PSet → Prop", "name": "PSet.Subset", "isProp": false, "docString": "A pre-set is a subset of another pre-set if every element of the first family is extensionally\nequivalent to some element of the second family.", "terms": "[\n    \"pre-set\",\n    \"subset\",\n    \"element\",\n    \"family\",\n    \"extensionally equivalent\"\n]"}
{"type": "{α : Type u_1} → α → WithTop α", "name": "WithTop.some", "isProp": false, "docString": "The canonical map from `α` into `WithTop α` ", "terms": "[\n  \"canonical map\", \n  \"WithTop\"\n]"}
{"type": "Type", "name": "PNat", "isProp": false, "docString": "`ℕ+` is the type of positive natural numbers. It is defined as a subtype,\nand the VM representation of `ℕ+` is the same as `ℕ` because the proof\nis not stored. ", "terms": "[\n  \"type\",\n  \"positive natural numbers\",\n  \"defined\",\n  \"subtype\",\n  \"VM representation\",\n  \"proof\",\n  \"stored\"\n]"}
{"type": "∀ (n : ℕ) (R : Type u_1) [inst : CommRing R], Polynomial.IsPrimitive (Polynomial.cyclotomic n R)", "name": "Polynomial.cyclotomic.isPrimitive", "isProp": true, "docString": "`cyclotomic n` is primitive. ", "terms": "[\"cyclotomic\", \"primitive\"]"}
{"type": "∀ {n : ℕ}, Even n → n ≠ 0 → StrictConvexOn ℝ Set.univ fun x => x ^ n", "name": "Even.strictConvexOn_pow", "isProp": true, "docString": "`x^n`, `n : ℕ` is strictly convex on the whole real line whenever `n ≠ 0` is even. ", "terms": "[\n  \"strictly convex\",\n  \"whole real line\",\n  \"even\",\n  \"ℕ\",\n  \"not equal to\",\n  \"zero\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : TopologicalSpace β]\n  [inst_3 : ClosedIciTopology α] [inst_4 : Nonempty β] [inst_5 : One α] {f : β → α},\n  Continuous f → HasCompactMulSupport f → ∃ x, ∀ (y : β), f y ≤ f x", "name": "Continuous.exists_forall_ge_of_hasCompactMulSupport", "isProp": true, "docString": "A continuous function with compact support has a global maximum. ", "terms": "[\n    \"continuous function\", \n    \"compact support\", \n    \"global maximum\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasProducts C] →\n      {X : TopCat} →\n        {F : TopCat.Presheaf C X} →\n          {ι : Type v'} →\n            (U : ι → TopologicalSpace.Opens ↑X) →\n              {G : TopCat.Presheaf C X} →\n                (F ≅ G) →\n                  (TopCat.Presheaf.SheafConditionEqualizerProducts.piOpens F U ≅\n                    TopCat.Presheaf.SheafConditionEqualizerProducts.piOpens G U)", "name": "TopCat.Presheaf.SheafConditionEqualizerProducts.piOpens.isoOfIso", "isProp": false, "docString": "Isomorphic presheaves have isomorphic `piOpens` for any cover `U`. ", "terms": "[\n    \"Isomorphic\",\n    \"Presheaves\",\n    \"Cover\"\n]"}
{"type": "{R : Type u} → {σ : Type u_1} → [inst : CommSemiring R] → MvPolynomial σ R → Finset (σ →₀ ℕ)", "name": "MvPolynomial.support", "isProp": false, "docString": "The finite set of all `m : σ →₀ ℕ` such that `X^m` has a non-zero coefficient.  ", "terms": "[\n  \"finite set\",\n  \"non-zero coefficient\"\n]"}
{"type": "{R : Type u_4} → [inst : Nontrivial R] → [hR : CommRing R] → (∀ (a : R), IsUnit a ∨ a = 0) → Field R", "name": "fieldOfIsUnitOrEqZero", "isProp": false, "docString": "Constructs a `Field` structure on a `CommRing` consisting only of units and 0.\nSee note [reducible non-instances]. ", "terms": "[\n    \"Field\",\n    \"Structure\",\n    \"CommRing\",\n    \"Units\",\n    \"0\",\n    \"Reducible\",\n    \"Non-instances\"\n]"}
{"type": "(n : ℕ) → Fintype ↑(Set.Iio n)", "name": "Set.Nat.fintypeIio", "isProp": false, "docString": "This is not an instance so that it does not conflict with the one\nin `Mathlib/Order/LocallyFinite.lean`. ", "terms": "[]\n"}
{"type": "{R : Type u} →\n  {S₁ : Type v} →\n    {σ : Type u_1} →\n      [inst : CommSemiring R] → [inst_1 : CommSemiring S₁] → (R →+* S₁) → (σ → S₁) → MvPolynomial σ R → S₁", "name": "MvPolynomial.eval₂", "isProp": false, "docString": "Evaluate a polynomial `p` given a valuation `g` of all the variables\nand a ring hom `f` from the scalar ring to the target ", "terms": "[\n    \"Evaluate\",\n    \"Polynomial\",\n    \"Valuation\",\n    \"Variables\",\n    \"Ring\",\n    \"Homomorphism\",\n    \"Scalar ring\",\n    \"Target\"\n]"}
{"type": "{G : Type u_1} → [inst : GroupWithZero G] → (a : G) → a ≠ 0 → Equiv.Perm G", "name": "Equiv.mulRight₀", "isProp": false, "docString": "Right multiplication by a nonzero element in a `GroupWithZero` is a permutation of the\nunderlying type. ", "terms": "[\n    \"Right multiplication\",\n    \"nonzero element\",\n    \"GroupWithZero\",\n    \"permutation\",\n    \"underlying type\"\n]"}
{"type": "(p : ℕ) → [hp : Fact (Nat.Prime p)] → ℕ → ℕ → MvPolynomial (Fin 1 × ℕ) ℤ", "name": "WittVector.wittNSMul", "isProp": false, "docString": "The polynomials used for defining repeated addition of the ring of Witt vectors. ", "terms": "[\n    \"Polynomials\",\n    \"Defining\",\n    \"Repeated Addition\",\n    \"Ring\",\n    \"Witt Vectors\"\n]"}
{"type": "CpltSepUniformSpace → UniformSpaceCat", "name": "CpltSepUniformSpace.toUniformSpace", "isProp": false, "docString": "The function forgetting that a complete separated uniform spaces is complete and separated. ", "terms": "[\n    \"function\",\n    \"complete\",\n    \"separated\",\n    \"uniform spaces\"\n]"}
{"type": "{α : Type u_1} → (α → α → Bool) → (a : Array α) → Fin (Array.size a) → { a' // Array.size a' = Array.size a }", "name": "BinaryHeap.heapifyDown", "isProp": false, "docString": "Core operation for binary heaps, expressed directly on arrays.\nGiven an array which is a max-heap, push item `i` down to restore the max-heap property. ", "terms": "[\n    \"Core operation\",\n    \"Binary heaps\",\n    \"Arrays\",\n    \"Max-heap\",\n    \"Push item\",\n    \"Restore\",\n    \"Max-heap property\"\n]"}
{"type": "(𝕜 : Type u_1) → {A : Type u_2} → [inst : Field 𝕜] → [inst_1 : Ring A] → [inst_2 : Algebra 𝕜 A] → A → Polynomial 𝕜", "name": "Polynomial.annIdealGenerator", "isProp": false, "docString": "`annIdealGenerator 𝕜 a` is the monic generator of `annIdeal 𝕜 a`\nif one exists, otherwise `0`.\n\nSince `𝕜[X]` is a principal ideal domain there is a polynomial `g` such that\n `span 𝕜 {g} = annIdeal a`. This picks some generator.\n We prefer the monic generator of the ideal. ", "terms": "[\n  \"annIdealGenerator\",\n  \"monic\",\n  \"generator\",\n  \"annIdeal\",\n  \"0\",\n  \"principal ideal domain\",\n  \"polynomial\",\n  \"span\",\n  \"ideal\"\n]"}
{"type": "{B : Type u} →\n  [inst : CategoryTheory.Bicategory B] →\n    (a b c : B) → CategoryTheory.Functor (b ⟶ c) (CategoryTheory.Functor (a ⟶ b) (a ⟶ c))", "name": "CategoryTheory.Bicategory.postcomposing", "isProp": false, "docString": "Postcomposition of a 1-morphism as a functor from the category of 1-morphisms `b ⟶ c` into the\ncategory of functors `(a ⟶ b) ⥤ (a ⟶ c)`. ", "terms": "[\n    \"Postcomposition\",\n    \"1-morphism\",\n    \"functor\",\n    \"category\",\n    \"functors\"\n]"}
{"type": "{M : Type u_1} →\n  [inst : Add M] → (c : AddCon M) → [inst_1 : (a b : M) → Decidable (c a b)] → DecidableEq (AddCon.Quotient c)", "name": "AddCon.instDecidableEqQuotient", "isProp": false, "docString": "The quotient by a decidable additive congruence relation has decidable equality.", "terms": "[\n  \"quotient\",\n  \"decidable\",\n  \"additive\",\n  \"congruence relation\",\n  \"equality\"\n]"}
{"type": "{R : Type u_1} →\n  [inst : CommSemiring R] →\n    {M : Type u_4} →\n      {N : Type u_5} →\n        {P : Type u_6} →\n          [inst_1 : AddCommMonoid M] →\n            [inst_2 : AddCommMonoid N] →\n              [inst_3 : AddCommMonoid P] →\n                [inst_4 : Module R M] →\n                  [inst_5 : Module R N] →\n                    (f : M →+ N →+ P) →\n                      (∀ (r : R) (m : M) (n : N), (f (r • m)) n = (f m) (r • n)) → TensorProduct R M N →+ P", "name": "TensorProduct.liftAddHom", "isProp": false, "docString": "Lift an `R`-balanced map to the tensor product.\n\nA map `f : M →+ N →+ P` additive in both components is `R`-balanced, or middle linear with respect\nto `R`, if scalar multiplication in either argument is equivalent, `f (r • m) n = f m (r • n)`.\n\nNote that strictly the first action should be a right-action by `R`, but for now `R` is commutative\nso it doesn't matter. ", "terms": "[\n    \"R-balanced map\",\n    \"tensor product\",\n    \"map\",\n    \"additive\",\n    \"components\",\n    \"middle linear\",\n    \"scalar multiplication\",\n    \"equivalent\",\n    \"right-action\",\n    \"commutative\"\n]"}
{"type": "∀ {ι : Type u_1} {α : Type u_2} [inst : LinearOrderedRing α] {s : Finset ι} {σ : Equiv.Perm ι} {f g : ι → α},\n  AntivaryOn f g ↑s → {x | σ x ≠ x} ⊆ ↑s → (Finset.sum s fun i => f i * g i) ≤ Finset.sum s fun i => f i * g (σ i)", "name": "AntivaryOn.sum_mul_le_sum_mul_comp_perm", "isProp": true, "docString": "**Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is minimized when `f` and\n`g` antivary together. Stated by permuting the entries of `g`. ", "terms": "[\n \"Rearrangement Inequality\",\n \"Pointwise multiplication\",\n \"minimized\",\n \"antivary\",\n \"permuting\",\n \"entries\"\n]"}
{"type": "∀ {M : Type u_1} [inst : MulOneClass M] {p : M → Prop} (x : M) {s : Set M},\n  Submonoid.closure s = ⊤ → (∀ x ∈ s, p x) → p 1 → (∀ (x y : M), p x → p y → p (x * y)) → p x", "name": "Submonoid.dense_induction", "isProp": true, "docString": "If `s` is a dense set in a monoid `M`, `Submonoid.closure s = ⊤`, then in order to prove that\nsome predicate `p` holds for all `x : M` it suffices to verify `p x` for `x ∈ s`, verify `p 1`,\nand verify that `p x` and `p y` imply `p (x * y)`. ", "terms": "[\n    \"dense set\",\n    \"monoid\",\n    \"Submonoid.closure\",\n    \"predicate\",\n    \"holds for all\",\n    \"verify\",\n    \"imply\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β} (s : Set β),\n  Embedding f → Embedding (Set.restrictPreimage s f)", "name": "Embedding.restrictPreimage", "isProp": true, "docString": "**Alias** of `Set.restrictPreimage_embedding`.", "terms": "[\"Alias\", \"Set.restrictPreimage_embedding\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {J : CategoryTheory.GrothendieckTopology C} →\n      {D : Type w} →\n        [inst_1 : CategoryTheory.Category.{max v u, w} D] →\n          [inst_2 : CategoryTheory.ConcreteCategory D] →\n            {Y X : C} →\n              {P : CategoryTheory.Functor Cᵒᵖ D} →\n                {S : CategoryTheory.GrothendieckTopology.Cover J X} →\n                  CategoryTheory.Meq P S →\n                    (f : Y ⟶ X) → CategoryTheory.Meq P ((CategoryTheory.GrothendieckTopology.pullback J f).obj S)", "name": "CategoryTheory.Meq.pullback", "isProp": false, "docString": "Pull back a term of `Meq P S` with respect to a morphism `f : Y ⟶ X` in `C`. ", "terms": "[\n  \"Pull back\",\n  \"term\",\n  \"Meq P S\",\n  \"with respect to\",\n  \"morphism\",\n  \"f : Y ⟶ X\",\n  \"in\",\n  \"C\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {D : Type u'} →\n      [inst_1 : CategoryTheory.Category.{v, u'} D] →\n        [inst_2 : CategoryTheory.Limits.HasLimits D] →\n          [inst_3 : CategoryTheory.WellPowered D] →\n            {𝒢 : Set D} →\n              [inst_4 : Small.{v, u'} ↑𝒢] →\n                CategoryTheory.IsCoseparating 𝒢 →\n                  (G : CategoryTheory.Functor D C) →\n                    [inst_5 : CategoryTheory.Limits.PreservesLimits G] → CategoryTheory.IsRightAdjoint G", "name": "CategoryTheory.isRightAdjointOfPreservesLimitsOfIsCoseparating", "isProp": false, "docString": "The special adjoint functor theorem: if `G : D ⥤ C` preserves limits and `D` is complete,\nwell-powered and has a small coseparating set, then `G` has a left adjoint.\n", "terms": "[\n    \"special adjoint functor theorem\",\n    \"functor\",\n    \"preserves limits\",\n    \"complete\",\n    \"well-powered\",\n    \"small coseparating set\",\n    \"left adjoint\"\n]"}
{"type": "∀ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace ℝ E] {f : ℝ → E}\n  {a b : ℝ},\n  IntervalIntegrable f MeasureTheory.volume a b →\n    StronglyMeasurableAtFilter f (nhds b) → ContinuousAt f b → HasDerivAt (fun u => ∫ (x : ℝ) in a..u, f x) (f b) b", "name": "intervalIntegral.integral_hasDerivAt_right", "isProp": true, "docString": "**Fundamental theorem of calculus-1**: if `f : ℝ → E` is integrable on `a..b` and `f` is\ncontinuous at `b`, then `u ↦ ∫ x in a..u, f x` has derivative `f b` at `b`. ", "terms": "[\n    \"Fundamental theorem of calculus-1\",\n    \"integrable\",\n    \"continuous\",\n    \"derivative\",\n    \"ℝ\",\n    \"E\",\n    \"a..b\",\n    \"∫ x in a..u, f x\",\n    \"f b\"\n]"}
{"type": "∀ {α : Type u} [inst : PseudoMetricSpace α] (x y : α), edist x y = ↑(nndist x y)", "name": "edist_nndist", "isProp": true, "docString": "Express `edist` in terms of `nndist`", "terms": "[\"Express\", \"in terms of\"]"}
{"type": "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {s : Set α},\n  AntitoneOn f s → MonotoneOn (f ∘ ⇑OrderDual.ofDual) s", "name": "AntitoneOn.dual_left", "isProp": true, "docString": "**Alias** of the reverse direction of `monotoneOn_comp_ofDual_iff`.", "terms": "[\"Alias\", \"reverse direction\", \"monotoneOn_comp_ofDual_iff\"]"}
{"type": "∀ (α : Type u) {β : Type v} [inst : AddGroup α] [inst_1 : AddAction α β] (b : β) [inst_2 : Fintype α]\n  [inst_3 : Fintype ↑(AddAction.orbit α b)] [inst_4 : Fintype ↥(AddAction.stabilizer α b)],\n  Fintype.card ↑(AddAction.orbit α b) * Fintype.card ↥(AddAction.stabilizer α b) = Fintype.card α", "name": "AddAction.card_orbit_add_card_stabilizer_eq_card_addGroup", "isProp": true, "docString": "Orbit-stabilizer theorem.", "terms": "[\n    \"Orbit-stabilizer theorem\"\n]"}
{"type": "∀ {p : ℕ}, (Summable fun n => 1 / ↑n ^ p) ↔ 1 < p", "name": "Real.summable_one_div_int_pow", "isProp": true, "docString": "Summability of the `p`-series over `ℤ`. ", "terms": "[\"Summability\", \"p-series\", \"over\", \"ℤ\"]"}
{"type": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a ≤ b → (¬a ⩿ b ↔ ∃ c, a < c ∧ c < b)", "name": "not_wcovby_iff", "isProp": true, "docString": "If `a ≤ b`, then `b` does not cover `a` iff there's an element in between. ", "terms": "[\n    \"≤\",\n    \"cover\",\n    \"element\",\n    \"in between\",\n    \"iff\"\n]"}
{"type": "∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : LinearOrderedRing α] [inst_1 : LinearOrderedAddCommGroup β]\n  [inst_2 : Module α β] [inst_3 : OrderedSMul α β] {f : ι → α} {g : ι → β} {s : Set ι},\n  MonovaryOn f g s → ∀ ⦃i : ι⦄, i ∈ s → ∀ ⦃j : ι⦄, j ∈ s → 0 ≤ (f j - f i) • (g j - g i)", "name": "MonovaryOn.sub_smul_sub_nonneg", "isProp": true, "docString": "**Alias** of the forward direction of `monovaryOn_iff_forall_smul_nonneg`.", "terms": "[\"Alias\", \"forward direction\", \"monovaryOn_iff_forall_smul_nonneg\"]"}
{"type": "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V},\n  Orientation.oangle o x y = ↑(Real.pi / 2) → ‖x‖ / Real.Angle.cos (Orientation.oangle o x (x + y)) = ‖x + y‖", "name": "Orientation.norm_div_cos_oangle_add_right_of_oangle_eq_pi_div_two", "isProp": true, "docString": "A side of a right-angled triangle divided by the cosine of the adjacent angle equals the\nhypotenuse. ", "terms": "[\n    \"side\",\n    \"right-angled triangle\",\n    \"divided\",\n    \"cosine\",\n    \"adjacent angle\",\n    \"equals\",\n    \"hypotenuse\"\n]"}
{"type": "{R : Type u} → [inst : Add R] → Mul (Tropical R)", "name": "Tropical.instMulTropical", "isProp": false, "docString": "Tropical multiplication is the addition in the underlying `R`. ", "terms": "[\n  \"Tropical multiplication\",\n  \"addition\",\n  \"underlying\"\n]"}
{"type": "∀ {α : Type u} [self : CompleteAtomicBooleanAlgebra α] (x y : α), x \\ y = x ⊓ yᶜ", "name": "CompleteAtomicBooleanAlgebra.sdiff_eq", "isProp": true, "docString": "`x \\ y` is equal to `x ⊓ yᶜ` ", "terms": "[\n    \"equal\",\n    \"⊓\",\n    \"ᶜ\"\n]"}
{"type": "(R : Type u) →\n  [inst : CommRing R] →\n    (f : R) →\n      (AlgebraicGeometry.Spec.structureSheaf R).val.obj (Opposite.op (PrimeSpectrum.basicOpen f)) ≅\n        CommRingCat.of (Localization.Away f)", "name": "AlgebraicGeometry.StructureSheaf.basicOpenIso", "isProp": false, "docString": "The ring isomorphism between the structure sheaf on `basicOpen f` and the localization of `R`\nat the submonoid of powers of `f`. ", "terms": "[\n  \"ring\",\n  \"isomorphism\",\n  \"structure sheaf\",\n  \"basicOpen\",\n  \"localization\",\n  \"submonoid\",\n  \"powers\"\n]"}
{"type": "(𝕜 : Type u_1) →\n  {E : Type u_2} →\n    {β : Type u_4} →\n      [inst : OrderedSemiring 𝕜] → [inst : AddCommMonoid E] → [inst : LE β] → [inst : SMul 𝕜 E] → Set E → (E → β) → Prop", "name": "QuasiconcaveOn", "isProp": false, "docString": "A function is quasiconcave if all its superlevels are convex.\nThis means that, for all `r`, `{x ∈ s | r ≤ f x}` is `𝕜`-convex. ", "terms": "[\n    \"function\",\n    \"quasiconcave\",\n    \"superlevels\",\n    \"convex\",\n    \"r\",\n    \"x\",\n    \"s\",\n    \"f\",\n    \"𝕜-convex\"\n]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {s : EuclideanGeometry.Sphere P} {p₁ p₂ : P},\n  p₁ ∈ s → dist p₂ s.center ≤ s.radius → 0 < inner (p₁ -ᵥ p₂) (p₁ -ᵥ s.center) ∨ p₁ = p₂", "name": "EuclideanGeometry.inner_pos_or_eq_of_dist_le_radius", "isProp": true, "docString": "Given a point on a sphere and a point not outside it, the inner product between the\ndifference of those points and the radius vector is positive unless the points are equal. ", "terms": "[\n    \"point\", \n    \"sphere\", \n    \"inner product\", \n    \"difference\", \n    \"radius vector\", \n    \"positive\", \n    \"equal\"\n]"}
{"type": "{F : Type u_1} →\n  [inst : CommSemiring F] → {q : ℕ} → {f : Polynomial F} → Polynomial.HasSeparableContraction q f → Polynomial F", "name": "Polynomial.HasSeparableContraction.contraction", "isProp": false, "docString": "A choice of a separable contraction. ", "terms": "[\n    \"choice\",\n    \"separable\",\n    \"contraction\"\n]"}
{"type": "ℕ → Prop", "name": "Nat.Perfect", "isProp": false, "docString": "`n : ℕ` is perfect if and only the sum of the proper divisors of `n` is `n` and `n`\nis positive. ", "terms": "[\"ℕ\", \"perfect\", \"sum\", \"proper divisors\", \"positive\"]"}
{"type": "∀ {R : Type u_1} {E : Type u_2} {F : Type u_3} [inst : CommRing R] [inst_1 : AddCommGroup E] [inst_2 : AddCommGroup F]\n  [inst_3 : Module R E] [inst_4 : Module R F] [inst_5 : TopologicalSpace E] [inst_6 : TopologicalSpace F]\n  [inst_7 : ContinuousAdd E] [inst_8 : ContinuousAdd F] [inst_9 : TopologicalSpace R] [inst_10 : ContinuousSMul R E]\n  [inst_11 : ContinuousSMul R F] {f : E →ₗ.[R] F},\n  LinearMap.ker f.toFun = ⊥ →\n    LinearPMap.IsClosable f →\n      LinearMap.ker (LinearPMap.closure f).toFun = ⊥ →\n        LinearPMap.closure (LinearPMap.inverse f) = LinearPMap.inverse (LinearPMap.closure f)", "name": "LinearPMap.inverse_closure", "isProp": true, "docString": "If `f` is invertible and closable, then taking the closure and the inverse commute. ", "terms": "[\n    \"invertible\",\n    \"closable\",\n    \"closure\",\n    \"inverse\",\n    \"commute\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    (J : CategoryTheory.GrothendieckTopology C) →\n      {D : Type w₁} →\n        [inst_1 : CategoryTheory.Category.{max v u, w₁} D] →\n          [inst_2 : CategoryTheory.ConcreteCategory D] →\n            [inst_3 : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)] →\n              CategoryTheory.Functor (CategoryTheory.Sheaf J D) (CategoryTheory.SheafOfTypes J)", "name": "CategoryTheory.sheafForget", "isProp": false, "docString": "The forgetful functor from `Sheaf J D` to sheaves of types, for a concrete category `D`\nwhose forgetful functor preserves the correct limits. ", "terms": "[\n    \"forgetful functor\",\n    \"Sheaf\",\n    \"sheaves of types\",\n    \"concrete category\",\n    \"preserves\",\n    \"correct limits\"\n]"}
{"type": "(J : Type u) →\n  [inst : CategoryTheory.Category.{v, u} J] →\n    [inst_1 : CategoryTheory.FinallySmall J] → CategoryTheory.Functor (CategoryTheory.FinalModel J) J", "name": "CategoryTheory.fromFinalModel", "isProp": false, "docString": "An arbitrarily chosen final functor `FinalModel J ⥤ J`. ", "terms": "[\n  \"arbitrarily chosen\",\n  \"final functor\",\n  \"FinalModel\",\n  \"J\",\n  \"⥤\"\n]"}
{"type": "↥circle →* ℂˣ", "name": "circle.toUnits", "isProp": false, "docString": "The elements of the circle embed into the units. ", "terms": "[\"elements\", \"circle\", \"embed\", \"units\"]"}
{"type": "{K : Type u_1} →\n  {L : Type u_2} →\n    [inst : Field K] →\n      [inst_1 : Field L] →\n        [inst_2 : Algebra K L] → {F : IntermediateField K L} → IntermediateField K ↥F → IntermediateField K L", "name": "IntermediateField.lift", "isProp": false, "docString": "Lift an intermediate_field of an intermediate_field ", "terms": "[\n  \"Lift\",\n  \"intermediate_field\"\n]"}
{"type": "∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α),\n  ∃ t, s ⊆ t ∧ MeasurableSet t ∧ ↑↑μ t = ↑↑μ s", "name": "MeasureTheory.exists_measurable_superset", "isProp": true, "docString": "For every set there exists a measurable superset of the same measure. ", "terms": "[\n    \"set\",\n    \"exists\",\n    \"measurable\",\n    \"superset\",\n    \"measure\"\n]"}
{"type": "ℝ →+ Additive ↥circle", "name": "expMapCircleHom", "isProp": false, "docString": "The map `fun t => exp (t * I)` from `ℝ` to the unit circle in `ℂ`,\nconsidered as a homomorphism of groups. ", "terms": "[\n    \"map\",\n    \"exp\",\n    \"I\",\n    \"ℝ\",\n    \"unit circle\",\n    \"ℂ\",\n    \"homomorphism\",\n    \"groups\"\n]"}
{"type": "{R : Type u_1} →\n  [inst : CommRing R] →\n    (x y : R) → (Polynomial R ⧸ Ideal.span {Polynomial.C x, Polynomial.X - Polynomial.C y}) ≃ₐ[R] R ⧸ Ideal.span {x}", "name": "Polynomial.quotientSpanCXSubCAlgEquiv", "isProp": false, "docString": "For a commutative ring $R$, evaluating a polynomial at an element $y \\in R$ induces an\nisomorphism of $R$-algebras $R[X] / \\langle x, X - y \\rangle \\cong R / \\langle x \\rangle$. ", "terms": "[\n    \"commutative ring\",\n    \"polynomial\",\n    \"element\",\n    \"isomorphism\",\n    \"algebras\",\n    \"induces\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {f : 𝕜 → E} {r : ENNReal} {x : 𝕜} {p : FormalMultilinearSeries 𝕜 𝕜 E},\n  HasFPowerSeriesOnBall f p x r →\n    (∀ (r' : NNReal), 0 < r' → ∃ p', HasFPowerSeriesOnBall f p' x ↑r') → HasFPowerSeriesOnBall f p x ⊤", "name": "HasFPowerSeriesOnBall.r_eq_top_of_exists", "isProp": true, "docString": "If a function `f : 𝕜 → E` has power series representation `p` on a ball of some radius and for\neach positive radius it has some power series representation, then `p` converges to `f` on the whole\n`𝕜`. ", "terms": "[\n    \"function\",\n    \"power series representation\",\n    \"ball\",\n    \"radius\",\n    \"positive radius\",\n    \"converges\"\n]"}
{"type": "∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [inst_1 : UniqueFactorizationMonoid α] {P : α → Prop}\n  (s : Finset α) (i : α → ℕ),\n  (∀ p ∈ s, Prime p) →\n    (∀ p ∈ s, ∀ q ∈ s, p ∣ q → p = q) →\n      (∀ {x : α}, IsUnit x → P x) →\n        (∀ {p : α} (i : ℕ), Prime p → P (p ^ i)) →\n          (∀ {x y : α}, (∀ (p : α), p ∣ x → p ∣ y → IsUnit p) → P x → P y → P (x * y)) →\n            P (Finset.prod s fun p => p ^ i p)", "name": "UniqueFactorizationMonoid.induction_on_prime_power", "isProp": true, "docString": "If `P` holds for units and powers of primes,\nand `P x ∧ P y` for coprime `x, y` implies `P (x * y)`,\nthen `P` holds on a product of powers of distinct primes. ", "terms": "[\n    \"units\",\n    \"primes\",\n    \"powers\",\n    \"coprime\",\n    \"product\",\n    \"distinct\"\n]"}
{"type": "{𝕜 : Type u_1} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {EM : Type u_2} →\n      [inst_1 : NormedAddCommGroup EM] →\n        [inst_2 : NormedSpace 𝕜 EM] →\n          {HM : Type u_3} →\n            [inst_3 : TopologicalSpace HM] →\n              ModelWithCorners 𝕜 EM HM →\n                {E : Type u_4} →\n                  [inst_4 : NormedAddCommGroup E] →\n                    [inst_5 : NormedSpace 𝕜 E] →\n                      {H : Type u_5} →\n                        [inst_6 : TopologicalSpace H] →\n                          (I : ModelWithCorners 𝕜 E H) →\n                            (M : Type u) →\n                              [inst_7 : TopologicalSpace M] →\n                                [inst_8 : ChartedSpace HM M] →\n                                  (G : Type u) →\n                                    [inst_9 : TopologicalSpace G] →\n                                      [inst_10 : ChartedSpace H G] →\n                                        [inst_11 : Group G] →\n                                          [inst : LieGroup I G] → TopCat.Sheaf GroupCat (TopCat.of M)", "name": "smoothSheafGroup", "isProp": false, "docString": "The sheaf of smooth functions from `M` to `G`, for `G` a Lie group, as a sheaf of\ngroups. ", "terms": "[\n  \"Sheaf\",\n  \"Smooth Functions\",\n  \"Lie Group\",\n  \"Sheaf of Groups\"\n]"}
{"type": "∀ {n : ℕ} {α : Fin (n + 1) → Type u} (q : (i : Fin (n + 1)) → α i), Fin.cons (q 0) (Fin.tail q) = q", "name": "Fin.cons_self_tail", "isProp": true, "docString": "Concatenating the first element of a tuple with its tail gives back the original tuple ", "terms": "[\n    \"Concatenating\",\n    \"First element\",\n    \"Tuple\",\n    \"Tail\",\n    \"Original\"\n]"}
{"type": "{M : Type u_5} → [inst : OrderedAddCommMonoid M] → (S : AddSubmonoid M) → OrderedAddCommMonoid ↥S", "name": "AddSubmonoid.toOrderedAddCommMonoid", "isProp": false, "docString": "An `AddSubmonoid` of an `OrderedAddCommMonoid` is an `OrderedAddCommMonoid`.", "terms": "[\n  \"AddSubmonoid\", \n  \"OrderedAddCommMonoid\"\n]"}
{"type": "{R : Type u} →\n  [inst : NonUnitalRing R] →\n    [inst_1 : PartialOrder R] →\n      [inst_2 : StarRing R] →\n        (∀ {x y : R}, x ≤ y → ∀ (z : R), z + x ≤ z + y) → (∀ (x : R), 0 ≤ x ↔ ∃ s, x = star s * s) → StarOrderedRing R", "name": "StarOrderedRing.ofNonnegIff'", "isProp": false, "docString": "When `R` is a non-unital ring, to construct a `StarOrderedRing` instance it suffices to\nshow that the nonnegative elements are precisely those elements of the form `star s * s`\nfor `s : R`.\n\nThis is provided for convenience because it holds in many common scenarios (e.g.,`ℝ`, `ℂ`, or\nany C⋆-algebra), and obviates the hassle of `AddSubmonoid.closure_induction` when creating those\ninstances. ", "terms": "[\n    \"non-unital ring\",\n    \"StarOrderedRing\",\n    \"nonnegative elements\",\n    \"ℝ\",\n    \"ℂ\",\n    \"C⋆-algebra\",\n    \"AddSubmonoid.closure_induction\"\n]"}
{"type": "∀ {M₀ : Type u} [self : MulZeroOneClass M₀] (a : M₀), a * 0 = 0", "name": "MulZeroOneClass.mul_zero", "isProp": true, "docString": "Zero is a right absorbing element for multiplication ", "terms": "[\n    \"Zero\",\n    \"Right Absorbing Element\",\n    \"Multiplication\"\n]"}
{"type": "{β : Type w} →\n  {C : Type u} →\n    [inst : CategoryTheory.Category.{v, u} C] →\n      {F : β → C} →\n        {c : CategoryTheory.Limits.Fan F} → CategoryTheory.Limits.IsLimit c → {A : C} → ((i : β) → A ⟶ F i) → (A ⟶ c.pt)", "name": "CategoryTheory.Limits.Fan.IsLimit.desc", "isProp": false, "docString": "Constructor for morphisms to the point of a limit fan. ", "terms": "[\n    \"Constructor\",\n    \"Morphisms\",\n    \"Point\",\n    \"Limit\",\n    \"Fan\"\n]"}
{"type": "∀ {f f' : ℝ → ℝ} {a b : ℝ},\n  ContinuousOn f (Set.Icc a b) →\n    (∀ x ∈ Set.Ico a b, HasDerivWithinAt f (f' x) (Set.Ici x) x) →\n      ∀ {B B' : ℝ → ℝ},\n        f a ≤ B a →\n          (∀ (x : ℝ), HasDerivAt B (B' x) x) →\n            (∀ x ∈ Set.Ico a b, f x = B x → f' x < B' x) → ∀ ⦃x : ℝ⦄, x ∈ Set.Icc a b → f x ≤ B x", "name": "image_le_of_deriv_right_lt_deriv_boundary", "isProp": true, "docString": "General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a ≤ B a`;\n* `B` has derivative `B'` everywhere on `ℝ`;\n* `f` has right derivative `f'` at every point of `[a, b)`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x ≤ B x` everywhere on `[a, b]`. ", "terms": "[\n  \"General fencing theorem\",\n  \"continuous functions\",\n  \"estimate\",\n  \"derivative\",\n  \"functions\",\n  \"ℝ\",\n  \"right derivative\",\n  \"point\",\n  \"everywhere\"\n]"}
{"type": "{α : Type u_1} → α → Semiquot α", "name": "Semiquot.pure", "isProp": false, "docString": "`pure a` is `a` reinterpreted as an unspecified element of `{a}`. ", "terms": "[\"pure\", \"reinterpreted\", \"unspecified element\"]"}
{"type": "(P : ℕ → Prop) → [inst : DecidablePred P] → PartENat", "name": "PartENat.find", "isProp": false, "docString": "The smallest `PartENat` satisfying a (decidable) predicate `P : ℕ → Prop` ", "terms": "[\n    \"smallest\",\n    \"PartENat\",\n    \"satisfying\",\n    \"decidable\",\n    \"predicate\",\n    \"ℕ\",\n    \"Prop\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_5} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]\n  [inst_2 : LinearOrderedAddCommMonoid β] [inst_3 : SMul 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : OrderedSMul 𝕜 β]\n  {s : Set E} {f : E → β}, ConcaveOn 𝕜 s f → ∀ {x y z : E}, x ∈ s → y ∈ s → z ∈ segment 𝕜 x y → min (f x) (f y) ≤ f z", "name": "ConcaveOn.ge_on_segment", "isProp": true, "docString": "A concave function on a segment is lower-bounded by the min of its endpoints. ", "terms": "[\n    \"Concave function\",\n    \"Segment\",\n    \"Lower-bounded\",\n    \"Min\",\n    \"Endpoints\"\n]"}
{"type": "{α : Type u_2} → [inst : CommMonoid α] → CommMonoid (Filter α)", "name": "Filter.commMonoid", "isProp": false, "docString": "`Filter α` is a `CommMonoid` under pointwise operations if `α` is. ", "terms": "[\n    \"Filter\",\n    \"CommMonoid\",\n    \"pointwise operations\"\n]"}
{"type": "{ι : Type u_4} →\n  {π : ι → Type u_9} →\n    [inst : Fintype ι] → [inst : (i : ι) → SeminormedAddGroup (π i)] → SeminormedAddGroup ((i : ι) → π i)", "name": "Pi.seminormedAddGroup", "isProp": false, "docString": "Finite product of seminormed groups, using the sup norm.", "terms": "[\n    \"Finite product\",\n    \"Seminormed groups\",\n    \"Sup norm\"\n]"}
{"type": "∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] [inst_1 : CategoryTheory.IsPreconnected J],\n  CategoryTheory.IsPreconnected Jᵒᵖ", "name": "CategoryTheory.isPreconnected_op", "isProp": true, "docString": "If `J` is preconnected, then `Jᵒᵖ` is preconnected as well. ", "terms": "[\"preconnected\"]"}
{"type": "{C : Type u_1} →\n  {D : Type u_2} →\n    [inst : CategoryTheory.Category.{u_3, u_1} C] →\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] →\n        [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] →\n          [inst_3 : CategoryTheory.Limits.HasZeroMorphisms D] →\n            (F : CategoryTheory.Functor C D) →\n              [inst_4 : CategoryTheory.Functor.PreservesZeroMorphisms F] →\n                CategoryTheory.Functor (CategoryTheory.ShortComplex C) (CategoryTheory.ShortComplex D)", "name": "CategoryTheory.Functor.mapShortComplex", "isProp": false, "docString": "The functor `ShortComplex C ⥤ ShortComplex D` induced by a functor `C ⥤ D` which\npreserves zero morphisms. ", "terms": "[\n    \"functor\",\n    \"ShortComplex\",\n    \"induced\",\n    \"preserves\",\n    \"zero morphisms\"\n]"}
{"type": "{J : Type v'} →\n  [inst : CategoryTheory.Category.{u', v'} J] →\n    {C : Type u} →\n      [inst_1 : CategoryTheory.Category.{v, u} C] →\n        {F : CategoryTheory.Functor J C} →\n          {c : CategoryTheory.Limits.Cocone F} → CategoryTheory.IsVanKampenColimit c → CategoryTheory.Limits.IsColimit c", "name": "CategoryTheory.IsVanKampenColimit.isColimit", "isProp": false, "docString": "A van Kampen colimit is a colimit. ", "terms": "[\n    \"van Kampen colimit\",\n    \"colimit\"\n]"}
{"type": "{R : Type u_1} →\n  {S : Type u_6} →\n    {M : Type u_9} →\n      {M₃ : Type u_12} →\n        {F : Type u_17} →\n          [inst : Semiring R] →\n            [inst_1 : Semiring S] →\n              [inst_2 : AddCommMonoid M] →\n                [inst_3 : AddCommMonoid M₃] →\n                  [inst_4 : Module R M] →\n                    [inst_5 : Module S M₃] → {σ : R →+* S} → F → [i : SemilinearMapClass F σ M M₃] → M →ₛₗ[σ] M₃", "name": "SemilinearMapClass.semilinearMap", "isProp": false, "docString": "Reinterpret an element of a type of semilinear maps as a semilinear map. ", "terms": "[\"element\", \"type\", \"semilinear maps\", \"semilinear map\"]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]\n  {T : D} {S : CategoryTheory.Functor C D} {f : CategoryTheory.CostructuredArrow S T}\n  (h : CategoryTheory.CostructuredArrow.IsUniversal f) (g : CategoryTheory.CostructuredArrow S T),\n  CategoryTheory.CategoryStruct.comp (S.map (CategoryTheory.CostructuredArrow.IsUniversal.lift h g)) f.hom = g.hom", "name": "CategoryTheory.CostructuredArrow.IsUniversal.fac", "isProp": true, "docString": "Any costructured arrow factors through a universal arrow. ", "terms": "[\n    \"costructured arrow\",\n    \"factors through\",\n    \"universal arrow\"\n]"}
{"type": "Lean.Elab.DerivingHandlerNoArgs", "name": "Mathlib.Deriving.Traversable.traversableDeriveHandler", "isProp": false, "docString": "The deriving handler for `Traversable`. ", "terms": "[]\nThis statement appears to be more related to functional programming (specifically Haskell) rather than a mathematical concept. The terms \"deriving\", \"handler\", and \"Traversable\" are related to functional programming concepts. However, they don't have specific definitions in mathematical terminology."}
{"type": "{α : Type u_1} →\n  [inst : Lattice α] →\n    [inst_1 : OrderBot α] →\n      {a b : α} → (P : Finpartition a) → {parts : Finset α} → parts ⊆ P.parts → Finset.sup parts id = b → Finpartition b", "name": "Finpartition.ofSubset", "isProp": false, "docString": "A `Finpartition` constructor from a bigger existing finpartition. ", "terms": "[\n  \"Finpartition\",\n  \"constructor\",\n  \"existing finpartition\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} {m0 : MeasurableSpace α} [inst : MeasurableSpace β] {μ : MeasureTheory.Measure α}\n  {f : α → β}, AEMeasurable f → ∀ {s : Set β}, ↑↑(MeasureTheory.Measure.map f μ) s = 0 → ↑↑μ (f ⁻¹' s) = 0", "name": "MeasureTheory.Measure.preimage_null_of_map_null", "isProp": true, "docString": "Even if `s` is not measurable, `map f μ s = 0` implies that `μ (f ⁻¹' s) = 0`. ", "terms": "[\n  \"measurable\",\n  \"map\",\n  \"implies\",\n  \"inverse\"\n]"}
{"type": "∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : α → ENNReal}\n  [inst : MeasureTheory.IsProbabilityMeasure μ], ∫⁻ (a : α), f a ∂μ ≠ ⊤ → ∃ x, ∫⁻ (a : α), f a ∂μ ≤ f x", "name": "MeasureTheory.exists_lintegral_le", "isProp": true, "docString": "**First moment method**. The maximum of a measurable function is greater than its integral. ", "terms": "[\n    \"First moment method\",\n    \"maximum\",\n    \"measurable function\",\n    \"greater than\",\n    \"integral\"\n]"}
{"type": "Finset (Tree Unit) → Finset (Tree Unit) → Finset (Tree Unit)", "name": "Tree.pairwiseNode", "isProp": false, "docString": "Given two finsets, find all trees that can be formed with\nleft child in `a` and right child in `b` ", "terms": "[\n  \"finsets\",\n  \"trees\",\n  \"formed\",\n  \"left child\",\n  \"right child\"\n]"}
{"type": "{n : ℕ} →\n  {α : TypeVec.{u} n} →\n    (p : TypeVec.Arrow (TypeVec.prod α α) (TypeVec.repeat n Prop)) →\n      TypeVec.Arrow (TypeVec.Subtype_ p) fun i => { x // TypeVec.ofRepeat (p i (TypeVec.prod.mk i x.1 x.2)) }", "name": "TypeVec.ofSubtype'", "isProp": false, "docString": "similar to `of_subtype` adapted to relations (i.e. predicate on product) ", "terms": "[\"similar\", \"of_subtype\", \"adapted\", \"relations\", \"predicate\", \"product\"]"}
{"type": "{X : Type u} → {Y : Type v} → [inst : MetricSpace X] → [inst : MetricSpace Y] → MetricSpace (X ⊕ Y)", "name": "Metric.metricSpaceSum", "isProp": false, "docString": "The distance on the disjoint union indeed defines a metric space. All the distance properties\nfollow from our choice of the distance. The harder work is to show that the uniform structure\ndefined by the distance coincides with the disjoint union uniform structure. ", "terms": "[\n    \"distance\",\n    \"disjoint union\",\n    \"metric space\",\n    \"distance properties\",\n    \"uniform structure\"\n]"}
{"type": "{α : Type u_1} → α ≃ Topology.WithUpperSet α", "name": "Topology.WithUpperSet.toUpperSet", "isProp": false, "docString": "`toUpperSet` is the identity function to the `WithUpperSet` of a type.  ", "terms": "[\"toUpperSet\", \"identity function\", \"WithUpperSet\", \"type\"]"}
{"type": "ℕ+ → ℕ+ → ℕ+", "name": "PNat.divExact", "isProp": false, "docString": "If `h : k | m`, then `k * (div_exact m k) = m`. Note that this is not equal to `m / k`. ", "terms": "[\n    \"division\",\n    \"multiplication\",\n    \"equality\",\n    \"exact division\",\n    \"not equal\"\n]"}
{"type": "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} {R S : Set G} (hR : R ∈ Subgroup.rightTransversals ↑H),\n  1 ∈ R →\n    Subgroup.closure S = ⊤ →\n      Subgroup.closure\n          ((fun g =>\n              { val := g * (↑(Subgroup.MemRightTransversals.toFun hR g))⁻¹,\n                property := (_ : g * (↑(Subgroup.MemRightTransversals.toFun hR g))⁻¹ ∈ H) }) ''\n            (R * S)) =\n        ⊤", "name": "Subgroup.closure_mul_image_eq_top", "isProp": true, "docString": "**Schreier's Lemma**: If `R : Set G` is a `rightTransversal` of `H : Subgroup G`\nwith `1 ∈ R`, and if `G` is generated by `S : Set G`, then `H` is generated by the `Set`\n`(R * S).image (fun g ↦ g * (toFun hR g)⁻¹)`. ", "terms": "[\n\"Schreier's Lemma\",\n\"Set\",\n\"rightTransversal\",\n\"Subgroup\",\n\"generated\",\n\"image\",\n\"toFun\",\n\"inverse\"\n]"}
{"type": "{X Y Z : Stonean} → (f : X ⟶ Z) → {i : Y ⟶ Z} → (hi : OpenEmbedding ⇑i) → Stonean.pullback f hi ⟶ X", "name": "Stonean.pullback.fst", "isProp": false, "docString": "The projection from the pullback to the first component. ", "terms": "[\n    \"projection\",\n    \"pullback\",\n    \"first component\"\n]"}
{"type": "(𝕜 : Type u_1) →\n  {E : Type u_2} →\n    [inst : IsROrC 𝕜] →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst : InnerProductSpace 𝕜 E] →\n          {ι : Type u_3} →\n            [inst : LinearOrder ι] →\n              [inst_2 : LocallyFiniteOrderBot ι] → [inst : IsWellOrder ι fun x x_1 => x < x_1] → (ι → E) → ι → E", "name": "gramSchmidt", "isProp": false, "docString": "The Gram-Schmidt process takes a set of vectors as input\nand outputs a set of orthogonal vectors which have the same span. ", "terms": "[\n    \"Gram-Schmidt process\", \n    \"set\", \n    \"vectors\", \n    \"input\", \n    \"outputs\", \n    \"orthogonal vectors\", \n    \"span\"\n]"}
{"type": "∀ {α : Type u} [inst : NormedField α] {u : ℕ → α}, IsCauSeq norm u ↔ CauchySeq u", "name": "isCauSeq_iff_cauchySeq", "isProp": true, "docString": "In a normed field, `CauSeq` coincides with the usual notion of Cauchy sequences. ", "terms": "[\n    \"normed field\",\n    \"Cauchy sequences\"\n]"}
{"type": "∀ {α : Type u_1} {M : Type u_8} {N : Type u_10} [inst : Zero M] [inst_1 : AddCommMonoid N] [inst_2 : DecidableEq α]\n  (f : α →₀ M) (a : α) (b : α → M → N),\n  (Finsupp.sum f fun x v => if x = a then b x v else 0) = if a ∈ f.support then b a (f a) else 0", "name": "Finsupp.sum_ite_eq'", "isProp": true, "docString": "A restatement of `sum_ite_eq` with the equality test reversed.", "terms": "[\"restatement\", \"sum_ite_eq\", \"equality test\", \"reversed\"]"}
{"type": "∀ {E : Type u_6} [inst : SeminormedAddGroup E] {s : AddSubgroup E} (x : ↥s), ‖x‖ = ‖↑x‖", "name": "AddSubgroup.coe_norm", "isProp": true, "docString": "If `x` is an element of a subgroup `s` of a seminormed group `E`, its\nnorm in `s` is equal to its norm in `E`.", "terms": "[\n\"element\",\n\"subgroup\",\n\"seminormed group\",\n\"norm\"\n]"}
{"type": "{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {C : Type u₃} →\n      [inst_1 : CategoryTheory.Category.{v₃, u₃} C] →\n        {F : CategoryTheory.Functor J C} →\n          {s t : CategoryTheory.Limits.Cocone F} →\n            CategoryTheory.Limits.IsColimit s → CategoryTheory.Limits.IsColimit t → (s ≅ t)", "name": "CategoryTheory.Limits.IsColimit.uniqueUpToIso", "isProp": false, "docString": "Colimit cocones on `F` are unique up to isomorphism. ", "terms": "[\n    \"Colimit\",\n    \"Cocones\",\n    \"Isomorphism\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      (X : CategoryTheory.Center C) → CategoryTheory.Center.tensorObj X CategoryTheory.Center.tensorUnit ≅ X", "name": "CategoryTheory.Center.rightUnitor", "isProp": false, "docString": "Auxiliary definition for the `MonoidalCategory` instance on `Center C`. ", "terms": "[\"Auxiliary definition\", \"MonoidalCategory\", \"instance\", \"Center\", \"C\"]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (K : Submodule 𝕜 E) [inst_3 : HasOrthogonalProjection K],\n  ContinuousLinearMap.id 𝕜 E =\n    ContinuousLinearMap.comp (Submodule.subtypeL K) (orthogonalProjection K) +\n      ContinuousLinearMap.comp (Submodule.subtypeL Kᗮ) (orthogonalProjection Kᗮ)", "name": "id_eq_sum_orthogonalProjection_self_orthogonalComplement", "isProp": true, "docString": "In a complete space `E`, the projection maps onto a complete subspace `K` and its orthogonal\ncomplement sum to the identity. ", "terms": "[\n  \"Complete Space\",\n  \"Projection Maps\",\n  \"Complete Subspace\",\n  \"Orthogonal Complement\",\n  \"Identity\",\n  \"Sum\"\n]"}
{"type": "∀ {n : Type u_4} {α : Type v} [inst : DecidableEq n] [inst_1 : Zero α] [inst_2 : One α] (σ : n ≃ n) (i j : n),\n  PEquiv.toMatrix (Equiv.toPEquiv σ) i j = OfNat.ofNat 1 (σ i) j", "name": "PEquiv.equiv_toPEquiv_toMatrix", "isProp": true, "docString": "We can also define permutation matrices by permuting the rows of the identity matrix. ", "terms": "[\n    \"define\",\n    \"permutation matrices\",\n    \"permuting\",\n    \"rows\",\n    \"identity matrix\"\n]"}
{"type": "{x y : SetTheory.PGame} →\n  SetTheory.PGame.LeftMoves x × SetTheory.PGame.RightMoves y ⊕\n      SetTheory.PGame.RightMoves x × SetTheory.PGame.LeftMoves y ≃\n    SetTheory.PGame.RightMoves (x * y)", "name": "SetTheory.PGame.toRightMovesMul", "isProp": false, "docString": "Turns a left and a right move for `x` and `y` into a right move for `x * y` and vice versa.\n\nEven though these types are the same (not definitionally so), this is the preferred way to convert\nbetween them. ", "terms": "[\"left and a right move\", \"x\", \"y\", \"x * y\", \"convert\", \"types\", \"definitionally\"]"}
{"type": "{α : Sort u} → (α → α → Prop) → Sort (max 1 u)", "name": "DecidableRel", "isProp": false, "docString": "A decidable relation. See `Decidable`. ", "terms": "[\"decidable relation\", \"Decidable\"]"}
{"type": "(α : Type u_3) → (β : Type u_4) → [inst : Mul α] → [inst_1 : CommSemigroup β] → (α →ₙ* β) →ₙ* α → β", "name": "MulHom.coeFn", "isProp": false, "docString": "Coercion of a `MulHom` into a function is itself a `MulHom`.\n\nSee also `MulHom.eval`. ", "terms": "[\"Coercion\", \"MulHom\", \"function\", \"MulHom.eval\"]"}
{"type": "∀ {R : Type u} {K : Type v} {L : Type z} {p : R} [inst : CommRing R] [inst_1 : Field K] [inst_2 : Field L]\n  [inst_3 : Algebra K L] [inst_4 : Algebra R L] [inst_5 : Algebra R K] [inst_6 : IsScalarTower R K L]\n  [inst_7 : IsSeparable K L] [inst_8 : IsDomain R] [inst_9 : IsFractionRing R K] [inst_10 : IsIntegrallyClosed R]\n  {B : PowerBasis K L},\n  Prime p →\n    IsIntegral R B.gen →\n      ∀ {z : L},\n        IsIntegral R z →\n          p • z ∈ Algebra.adjoin R {B.gen} →\n            Polynomial.IsEisensteinAt (minpoly R B.gen) (Submodule.span R {p}) → z ∈ Algebra.adjoin R {B.gen}", "name": "mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt", "isProp": true, "docString": "Let `K` be the field of fraction of an integrally closed domain `R` and let `L` be a separable\nextension of `K`, generated by an integral power basis `B` such that the minimal polynomial of\n`B.gen` is Eisenstein at `p`. Given `z : L` integral over `R`, if `p • z ∈ adjoin R {B.gen}`, then\n`z ∈ adjoin R {B.gen}`. ", "terms": "[\n\"field of fraction\",\n\"integrally closed domain\",\n\"separable extension\",\n\"integral power basis\",\n\"minimal polynomial\",\n\"Eisenstein\",\n\"integral over\",\n\"adjoin\"\n]"}
{"type": "∀ {n : ℕ} (self : Composition n), List.sum self.blocks = n", "name": "Composition.blocks_sum", "isProp": true, "docString": "Proof that `blocks` sums to `n`", "terms": "[]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type u₂}\n  [inst_2 : CategoryTheory.Category.{v₂, u₂} D] [inst_3 : CategoryTheory.MonoidalCategory D]\n  (self : CategoryTheory.LaxMonoidalFunctor C D) (X Y Z : C),\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.LaxMonoidalFunctor.μ self X Y)\n        (CategoryTheory.CategoryStruct.id (self.obj Z)))\n      (CategoryTheory.CategoryStruct.comp\n        (CategoryTheory.LaxMonoidalFunctor.μ self (CategoryTheory.MonoidalCategory.tensorObj X Y) Z)\n        (self.map (CategoryTheory.MonoidalCategory.associator X Y Z).hom)) =\n    CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.associator (self.obj X) (self.obj Y) (self.obj Z)).hom\n      (CategoryTheory.CategoryStruct.comp\n        (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id (self.obj X))\n          (CategoryTheory.LaxMonoidalFunctor.μ self Y Z))\n        (CategoryTheory.LaxMonoidalFunctor.μ self X (CategoryTheory.MonoidalCategory.tensorObj Y Z)))", "name": "CategoryTheory.LaxMonoidalFunctor.associativity", "isProp": true, "docString": "associativity of the tensorator ", "terms": "[\"associativity\", \"tensorator\"]"}
{"type": "ZFSet → ZFSet → ZFSet", "name": "ZFSet.Insert", "isProp": false, "docString": "`Insert x y` is the set `{x} ∪ y` ", "terms": "[\"Insert\", \"set\", \"∪\"]"}
{"type": "∀ {a c b d : Prop}, (a ↔ c) → (b ↔ d) → (a ∨ b ↔ c ∨ d)", "name": "Iff.or", "isProp": true, "docString": "**Alias** of `or_congr`.", "terms": "[]\n"}
{"type": "Lean.TrailingParserDescr", "name": "«term_≃⋆ₐ_»", "isProp": false, "docString": "A *⋆-algebra* equivalence is an equivalence preserving addition, multiplication, scalar\nmultiplication and the star operation, which allows for considering both unital and non-unital\nequivalences with a single structure. Currently, `AlgEquiv` requires unital algebras, which is\nwhy this structure does not extend it. ", "terms": "[\n    \"*⋆-algebra\",\n    \"equivalence\",\n    \"addition\",\n    \"multiplication\",\n    \"scalar multiplication\",\n    \"star operation\",\n    \"unital\",\n    \"non-unital\",\n    \"structure\",\n    \"AlgEquiv\",\n    \"algebras\"\n]"}
{"type": "∀ {ι : Type u} {f : ι → Ordinal.{max u v} → Ordinal.{max u v}},\n  (∀ (i : ι), Ordinal.IsNormal (f i)) → Ordinal.derivFamily f = Ordinal.enumOrd (⋂ i, Function.fixedPoints (f i))", "name": "Ordinal.derivFamily_eq_enumOrd", "isProp": true, "docString": "For a family of normal functions, `Ordinal.derivFamily` enumerates the common fixed points. ", "terms": "[\n    \"family\",\n    \"normal functions\",\n    \"Ordinal.derivFamily\",\n    \"enumerates\",\n    \"common fixed points\"\n]"}
{"type": "∀ {X : Type u_1} (d : X → X → NNReal) (dist_self : ∀ (x : X), d x x = 0) (dist_comm : ∀ (x y : X), d x y = d y x),\n  (∀ (x₁ x₂ x₃ x₄ : X), d x₁ x₄ ≤ 2 * max (d x₁ x₂) (max (d x₂ x₃) (d x₃ x₄))) → ∀ (x y : X), ↑(d x y) ≤ 2 * dist x y", "name": "PseudoMetricSpace.le_two_mul_dist_ofPreNNDist", "isProp": true, "docString": "Consider a function `d : X → X → ℝ≥0` such that `d x x = 0` and `d x y = d y x` for all `x`,\n`y`. Let `dist` be the largest pseudometric distance such that `dist x y ≤ d x y`, see\n`PseudoMetricSpace.ofPreNNDist`. Suppose that `d` satisfies the following triangle-like\ninequality: `d x₁ x₄ ≤ 2 * max (d x₁ x₂, d x₂ x₃, d x₃ x₄)`. Then `d x y ≤ 2 * dist x y` for all\n`x`, `y`. ", "terms": "[\n    \"function\",\n    \"real numbers\",\n    \"equal to\",\n    \"for all\",\n    \"largest\",\n    \"pseudometric distance\",\n    \"less than or equal to\",\n    \"PseudoMetricSpace.ofPreNNDist\",\n    \"satisfies\",\n    \"triangle-like inequality\",\n    \"max\",\n    \"then\"\n]"}
{"type": "(𝕜 : Type u_1) →\n  [inst : NontriviallyNormedField 𝕜] →\n    (𝕜' : Type u_11) →\n      [inst_1 : NonUnitalSeminormedRing 𝕜'] →\n        [inst_2 : NormedSpace 𝕜 𝕜'] →\n          [inst_3 : IsScalarTower 𝕜 𝕜' 𝕜'] → [inst_4 : SMulCommClass 𝕜 𝕜' 𝕜'] → 𝕜' →ₙₐ[𝕜] 𝕜' →L[𝕜] 𝕜'", "name": "NonUnitalAlgHom.Lmul", "isProp": false, "docString": "Multiplication on the left in a non-unital normed algebra `𝕜'` as a non-unital algebra\nhomomorphism into the algebra of *continuous* linear maps. This is the left regular representation\nof `A` acting on itself.\n\nThis has more algebraic structure than `ContinuousLinearMap.mul`, but there is no longer continuity\nbundled in the first coordinate.  An alternative viewpoint is that this upgrades\n`NonUnitalAlgHom.lmul` from a homomorphism into linear maps to a homomorphism into *continuous*\nlinear maps. ", "terms": "[\n  \"Multiplication\",\n  \"Non-unital normed algebra\",\n  \"Non-unital algebra\",\n  \"Homomorphism\",\n  \"Algebra\",\n  \"Continuous linear maps\",\n  \"Left regular representation\",\n  \"Algebraic structure\",\n  \"ContinuousLinearMap.mul\",\n  \"Continuity\",\n  \"First coordinate\",\n  \"Alternative viewpoint\",\n  \"Upgrades\",\n  \"NonUnitalAlgHom.lmul\",\n  \"Linear maps\"\n]"}
{"type": "∀ {R : Type u_1} [inst : LinearOrderedSemifield R] [inst_1 : FloorSemiring R] {b : ℕ},\n  1 < b → ∀ {x : ℤ} {r : R}, 0 < r → (↑b ^ x ≤ r ↔ x ≤ Int.log b r)", "name": "Int.zpow_le_iff_le_log", "isProp": true, "docString": "`zpow b` and `Int.log b` (almost) form a Galois connection. ", "terms": "[\n    \"zpow\",\n    \"Int.log\",\n    \"Galois connection\"\n]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] (X : C),\n  CategoryTheory.IsPullback 0 0 0 (CategoryTheory.CategoryStruct.id X)", "name": "CategoryTheory.IsPullback.zero_top", "isProp": true, "docString": "The square with `0 : 0 ⟶ 0` on the top and `𝟙 X` on the bottom is a pullback square. ", "terms": "[\n    \"square\",\n    \"0 : 0 ⟶ 0\",\n    \"𝟙 X\",\n    \"pullback square\"\n]"}
{"type": "∀ {G : Type u_4} {E : Type u_5} [inst : MeasurableSpace G] [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ℝ E]\n  {μ : MeasureTheory.Measure G} {f : G → E} {g : G} [inst_3 : Group G] [inst_4 : MeasurableMul G]\n  [inst_5 : MeasureTheory.Measure.IsMulLeftInvariant μ], (∀ (x : G), f (g * x) = -f x) → ∫ (x : G), f x ∂μ = 0", "name": "MeasureTheory.integral_eq_zero_of_mul_left_eq_neg", "isProp": true, "docString": "If some left-translate of a function negates it, then the integral of the function with respect\nto a left-invariant measure is 0. ", "terms": "[\n    \"left-translate\",\n    \"function\",\n    \"negates\",\n    \"integral\",\n    \"left-invariant measure\"\n]"}
{"type": "{C : Type v} →\n  [inst : CategoryTheory.Category.{v, v} C] →\n    {D : Type v} →\n      [inst_1 : CategoryTheory.Category.{v, v} D] →\n        (F : CategoryTheory.Functor C D) →\n          (d : D) →\n            [inst_2 :\n                CategoryTheory.IsIso\n                  (CategoryTheory.Limits.colimit.pre (CategoryTheory.coyoneda.obj (Opposite.op d)) F)] →\n              CategoryTheory.Limits.colimit\n                  (CategoryTheory.Functor.comp F (CategoryTheory.coyoneda.obj (Opposite.op d))) ≅\n                PUnit.{v + 1}", "name": "CategoryTheory.Functor.Final.colimitCompCoyonedaIso", "isProp": false, "docString": "If the universal morphism `colimit (F ⋙ coyoneda.obj (op d)) ⟶ colimit (coyoneda.obj (op d))`\nis an isomorphism (as it always is when `F` is cofinal),\nthen `colimit (F ⋙ coyoneda.obj (op d)) ≅ PUnit`\n(simply because `colimit (coyoneda.obj (op d)) ≅ PUnit`).\n", "terms": "[\n    \"universal morphism\",\n    \"colimit\",\n    \"isomorphism\",\n    \"cofinal\",\n    \"coyoneda.obj\",\n    \"op\",\n    \"PUnit\"\n]"}
{"type": "∀ (a : ℝ),\n  a ≠ 0 →\n    Filter.Tendsto Stirling.stirlingSeq Filter.atTop (nhds a) →\n      Filter.Tendsto Real.Wallis.W Filter.atTop (nhds (a ^ 2 / 2))", "name": "Stirling.second_wallis_limit", "isProp": true, "docString": "Suppose the sequence `stirlingSeq` (defined above) has the limit `a ≠ 0`.\nThen the Wallis sequence `W n` has limit `a^2 / 2`.\n", "terms": "[\"sequence\", \"limit\", \"Wallis sequence\"]"}
{"type": "{ι : Type u_1} → {E : ι → Type u_2} → [inst : (i : ι) → MetricSpace (E i)] → MetricSpace ((i : ι) × E i)", "name": "Metric.Sigma.metricSpace", "isProp": false, "docString": "A metric space structure on the disjoint union `Σ i, E i`.\nWe embed isometrically each factor, set the basepoints at distance 1, arbitrarily,\nand say that the distance from `a` to `b` is the sum of the distances of `a` and `b` to\ntheir respective basepoints, plus the distance 1 between the basepoints.\nSince there is an arbitrary choice in this construction, it is not an instance by default. ", "terms": "[\"metric space\", \"structure\", \"disjoint union\", \"embed\", \"isometrically\", \"factor\", \"basepoints\", \"distance\", \"sum\", \"distances\", \"respective\", \"choice\", \"construction\", \"instance\"]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} {mβ : MeasurableSpace β} {s : Set β},\n  MeasurableSet s → MeasurableSet (Sum.inr '' s)", "name": "MeasurableSet.inr_image", "isProp": true, "docString": "**Alias** of the reverse direction of `measurableSet_inr_image`.", "terms": "[\"Alias\", \"reverse direction\", \"measurableSet\", \"inr_image\"]"}
{"type": "{R : Type u_1} →\n  {A : Type u_2} →\n    {B : Type u_3} →\n      [inst : Monoid R] →\n        [inst_1 : NonUnitalNonAssocSemiring A] →\n          [inst_2 : DistribMulAction R A] →\n            [inst_3 : Star A] →\n              [inst_4 : NonUnitalNonAssocSemiring B] →\n                [inst_5 : DistribMulAction R B] →\n                  [inst_6 : Star B] → (f : A →⋆ₙₐ[R] B) → (f' : A → B) → f' = ⇑f → A →⋆ₙₐ[R] B", "name": "NonUnitalStarAlgHom.copy", "isProp": false, "docString": "Copy of a `NonUnitalStarAlgHom` with a new `toFun` equal to the old one. Useful\nto fix definitional equalities. ", "terms": "[\"NonUnitalStarAlgHom\", \"toFun\", \"definitional equalities\"]"}
{"type": "{α : Type u} →\n  {β : Type v} → (α → β → Prop) → (Computation α → Computation β → Prop) → α ⊕ Computation α → β ⊕ Computation β → Prop", "name": "Computation.LiftRelAux", "isProp": false, "docString": "Alternate definition of `LiftRel` over relations between `Computation`s", "terms": "[\"Alternate definition\", \"LiftRel\", \"relations\", \"Computation\"]"}
{"type": "∀ (a : Cardinal.{u}), a < 2 ^ a", "name": "Cardinal.cantor", "isProp": true, "docString": "**Cantor's theorem** ", "terms": "[\"Cantor's theorem\"]"}
{"type": "∀ (X : Stonean), CategoryTheory.Projective X", "name": "Stonean.instProjectiveStoneanInstLargeCategoryStonean", "isProp": true, "docString": "Every Stonean space is projective in `Stonean`. ", "terms": "[\"Stonean space\", \"projective\", \"Stonean\"]"}
{"type": "{J : Type u_1} →\n  {C : Type u_2} →\n    [inst : CategoryTheory.Category.{u_3, u_1} J] →\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} C] →\n        [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] →\n          (F : CategoryTheory.Functor J (CategoryTheory.ShortComplex C)) →\n            [inst_3 : CategoryTheory.Limits.HasLimit (CategoryTheory.Functor.comp F CategoryTheory.ShortComplex.π₁)] →\n              [inst_4 : CategoryTheory.Limits.HasLimit (CategoryTheory.Functor.comp F CategoryTheory.ShortComplex.π₂)] →\n                [inst_5 :\n                    CategoryTheory.Limits.HasLimit (CategoryTheory.Functor.comp F CategoryTheory.ShortComplex.π₃)] →\n                  CategoryTheory.Limits.IsLimit\n                    (CategoryTheory.ShortComplex.π₁.mapCone (CategoryTheory.ShortComplex.limitCone F))", "name": "CategoryTheory.ShortComplex.isLimitπ₁MapConeLimitCone", "isProp": false, "docString": "`limitCone F` becomes limit after the application of `π₁ : ShortComplex C ⥤ C`. ", "terms": "[\n  \"limitCone\",\n  \"limit\",\n  \"application\",\n  \"ShortComplex\",\n  \"C\",\n  \"⥤\"\n]"}
{"type": "∀ {S : Type u_1} [inst : UnitalShelf S] (x y z : S), Shelf.act (Shelf.act x y) z = Shelf.act x (Shelf.act y z)", "name": "UnitalShelf.assoc", "isProp": true, "docString": "The associativity of a unital shelf comes for free.\n", "terms": "[\"associativity\", \"unital shelf\"]"}
{"type": "{w : Type u_3} →\n  {w' : Type u_4} →\n    {m : Type u_3 → Type u_5} →\n      {m' : Type u_4 → Type u_6} → [inst : ULiftable m m'] → w ≃ w' → ULiftable (WriterT w m) (WriterT w' m')", "name": "WriterT.uliftable'", "isProp": false, "docString": "for specific writer monads, this function helps to create a uliftable instance ", "terms": "[\"writer monads\", \"function\", \"create\", \"uliftable instance\"]"}
{"type": "∀ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (h : M ≃+ N), IsAddHom ⇑h", "name": "AddEquiv.isAddHom", "isProp": true, "docString": "An additive isomorphism preserves addition (deprecated).", "terms": "[\n    \"additive\",\n    \"isomorphism\",\n    \"preserves\",\n    \"addition\",\n    \"deprecated\"\n]"}
{"type": "{α : Type u_1} → {β : Type u_2} → (α ↪ β) → Finset α ↪o Finset β", "name": "Finset.mapEmbedding", "isProp": false, "docString": "Associate to an embedding `f` from `α` to `β` the order embedding that maps a finset to its\nimage under `f`. ", "terms": "[\n    \"Associate\",\n    \"embedding\",\n    \"order embedding\",\n    \"maps\",\n    \"finset\",\n    \"image\"\n]"}
{"type": "{α : Type u} → {β : Type v} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → Prop", "name": "LeftOrdContinuous", "isProp": false, "docString": "A function `f` between preorders is left order continuous if it preserves all suprema.  We\ndefine it using `IsLUB` instead of `sSup` so that the proof works both for complete lattices and\nconditionally complete lattices. ", "terms": "[\n  \"function\",\n  \"preorders\",\n  \"left order continuous\",\n  \"preserves\",\n  \"suprema\",\n  \"IsLUB\",\n  \"sSup\",\n  \"proof\",\n  \"complete lattices\",\n  \"conditionally complete lattices\"\n]"}
{"type": "{α : Type u_1} →\n  [inst : Sup α] →\n    [inst_1 : Inf α] →\n      (∀ (a b : α), a ⊔ b = b ⊔ a) →\n        (∀ (a b c : α), a ⊔ b ⊔ c = a ⊔ (b ⊔ c)) →\n          (∀ (a b : α), a ⊓ b = b ⊓ a) →\n            (∀ (a b c : α), a ⊓ b ⊓ c = a ⊓ (b ⊓ c)) →\n              (∀ (a b : α), a ⊔ a ⊓ b = a) → (∀ (a b : α), a ⊓ (a ⊔ b) = a) → Lattice α", "name": "Lattice.mk'", "isProp": false, "docString": "A type with a pair of commutative and associative binary operations which satisfy two absorption\nlaws relating the two operations has the structure of a lattice.\n\nThe partial order is defined so that `a ≤ b` unfolds to `a ⊔ b = b`; cf. `sup_eq_right`.\n", "terms": "[\n    \"type\",\n    \"pair\",\n    \"commutative\",\n    \"associative\",\n    \"binary operations\",\n    \"absorption laws\",\n    \"structure\",\n    \"lattice\",\n    \"partial order\",\n    \"defined\",\n    \"unfolds\",\n    \"sup_eq_right\"\n]"}
{"type": "∀ {α : Type u_1} [self : CanonicallyLinearOrderedAddCommMonoid α] (a b : α), compare a b = compareOfLessAndEq a b", "name": "CanonicallyLinearOrderedAddCommMonoid.compare_eq_compareOfLessAndEq", "isProp": true, "docString": "Comparison via `compare` is equal to the canonical comparison given decidable `<` and `=`. ", "terms": "[\"Comparison\", \"compare\", \"equal\", \"canonical comparison\", \"decidable\"]"}
{"type": "ByteSlice → String", "name": "ByteSlice.toString", "isProp": false, "docString": "Convert a byte slice into a string. This does not handle non-ASCII characters correctly:\nevery byte will become a unicode character with codepoint < 256. ", "terms": "[]\n"}
{"type": "∀ {G : Type u_1} [inst : Group G], Monoid.exponent G = 2 → ∀ (x : G), x⁻¹ = x", "name": "inv_eq_self_of_exponent_two", "isProp": true, "docString": "In a group of exponent two, every element is its own inverse. ", "terms": "[\n  \"group\",\n  \"exponent\",\n  \"element\",\n  \"inverse\"\n]"}
{"type": "{V : Type u} → SimpleGraph V → SimpleGraph V → Prop", "name": "SimpleGraph.IsSubgraph", "isProp": false, "docString": "The relation that one `SimpleGraph` is a subgraph of another.\nNote that this should be spelled `≤`. ", "terms": "[\n  \"Relation\",\n  \"SimpleGraph\",\n  \"Subgraph\",\n  \"≤\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (K₁ K₂ : Submodule 𝕜 E), K₁ᗮ ⊓ K₂ᗮ = (K₁ ⊔ K₂)ᗮ", "name": "Submodule.inf_orthogonal", "isProp": true, "docString": "The inf of two orthogonal subspaces equals the subspace orthogonal\nto the sup. ", "terms": "[\n  \"inf\",\n  \"orthogonal\",\n  \"subspaces\",\n  \"subspace\",\n  \"sup\"\n]"}
{"type": "∀ {R : Type v} {M : Type w} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : NoZeroSMulDivisors R M] (f : Module.End R M) (μs : Set R) (xs : ↑μs → M),\n  (∀ (μ : ↑μs), Module.End.HasEigenvector f (↑μ) (xs μ)) → LinearIndependent (ι := ↑μs) R xs", "name": "Module.End.eigenvectors_linearIndependent", "isProp": true, "docString": "Eigenvectors corresponding to distinct eigenvalues of a linear operator are linearly\nindependent. (Lemma 5.10 of [axler2015])\n\nWe use the eigenvalues as indexing set to ensure that there is only one eigenvector for each\neigenvalue in the image of `xs`. ", "terms": "[\n    \"Eigenvectors\",\n    \"Eigenvalues\",\n    \"Linear Operator\",\n    \"Linearly Independent\",\n    \"Indexing Set\",\n    \"Image\"\n]"}
{"type": "∀ {α : Type u_1} {l : List α} {x : α}, List.Duplicate x l ↔ List.Sublist [x, x] l", "name": "List.duplicate_iff_sublist", "isProp": true, "docString": "The contrapositive of `List.nodup_iff_sublist`. ", "terms": "[\"contrapositive\", \"List.nodup_iff_sublist\"]"}
{"type": "∀ {d : ℤ} {a b : Pell.Solution₁ d},\n  Pell.Solution₁.x a = Pell.Solution₁.x b → Pell.Solution₁.y a = Pell.Solution₁.y b → a = b", "name": "Pell.Solution₁.ext", "isProp": true, "docString": "Two solutions are equal if their `x` and `y` components are equal. ", "terms": "[\"solutions\", \"equal\", \"components\"]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        (G : CategoryTheory.Functor C D) →\n          {J : Type w} →\n            [inst_2 : CategoryTheory.Category.{w', w} J] →\n              [inst_3 : CategoryTheory.Limits.PreservesColimitsOfShape J G] →\n                [inst_4 : CategoryTheory.Limits.HasColimitsOfShape J D] →\n                  [inst_5 : CategoryTheory.Limits.HasColimitsOfShape J C] →\n                    CategoryTheory.Functor.comp CategoryTheory.Limits.colim G ≅\n                      CategoryTheory.Functor.comp ((CategoryTheory.whiskeringRight J C D).obj G)\n                        CategoryTheory.Limits.colim", "name": "CategoryTheory.preservesColimitNatIso", "isProp": false, "docString": "If `C, D` has all colimits of shape `J`, and `G` preserves them, then `preservesColimitIso`\nis functorial wrt `F`. ", "terms": "[\n    \"colimits\",\n    \"shape\",\n    \"preserves\",\n    \"functorial\"\n]"}
{"type": "∀ {α : Type u} {L₁ L₂ : List (α × Bool)} [inst : DecidableEq α],\n  FreeAddGroup.Red L₁ L₂ → FreeAddGroup.reduce L₁ = FreeAddGroup.reduce L₂", "name": "FreeGroup.freeAddGroup.red.reduce_eq", "isProp": true, "docString": "**Alias** of `FreeAddGroup.reduce.eq_of_red`.\n\n---\n\nIf a word reduces to another word, then they have a common maximal reduction.", "terms": "[\n  \"Alias\",\n  \"FreeAddGroup.reduce.eq_of_red\",\n  \"word\",\n  \"reduces\",\n  \"common\",\n  \"maximal\",\n  \"reduction\"\n]"}
{"type": "Linarith.LinarithM Unit", "name": "Linarith.elimAllVarsM", "isProp": false, "docString": "`elimAllVarsM` eliminates all variables from the linarith state, leaving it with a set of\nground comparisons. If this succeeds without exception, the original `linarith` state is consistent.\n", "terms": "[\"elimAllVarsM\", \"variables\", \"linarith state\", \"set\", \"ground comparisons\", \"exception\", \"original\", \"consistent\"]"}
{"type": "{M : Type u_1} →\n  {α : Type u_6} →\n    {β : Type u_7} →\n      [inst : Monoid M] →\n        [inst_1 : MulAction M α] →\n          [inst_2 : SMul M β] →\n            (f : α → β) → Function.Surjective f → (∀ (c : M) (x : α), f (c • x) = c • f x) → MulAction M β", "name": "Function.Surjective.mulAction", "isProp": false, "docString": "Pushforward a multiplicative action along a surjective map respecting `•`.\nSee note [reducible non-instances]. ", "terms": "[\n    \"Pushforward\",\n    \"Multiplicative action\",\n    \"Surjective map\",\n    \"Respecting\",\n    \"Reducible non-instances\"\n]"}
{"type": "{M : Type u} →\n  [inst : CommMonoid M] →\n    {N : Type u} →\n      [inst_1 : CommMonoid N] →\n        (M →* N) → CategoryTheory.BraidedFunctor (CategoryTheory.Discrete M) (CategoryTheory.Discrete N)", "name": "CategoryTheory.Discrete.braidedFunctor", "isProp": false, "docString": "A multiplicative morphism between commutative monoids gives a braided functor between\nthe corresponding discrete braided monoidal categories.\n", "terms": "[\n    \"multiplicative morphism\",\n    \"commutative monoids\",\n    \"braided functor\",\n    \"discrete braided monoidal categories\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} {mβ : MeasurableSpace β} {m : MeasurableSpace α} (t : ℕ → Set β),\n  (∀ (n : ℕ), MeasurableSet (t n)) →\n    Pairwise (Disjoint on t) →\n      ∀ (g : ℕ → β → α), (∀ (n : ℕ), Measurable (g n)) → ∃ f, Measurable f ∧ ∀ (n : ℕ), ∀ x ∈ t n, f x = g n x", "name": "exists_measurable_piecewise_nat", "isProp": true, "docString": "Given countably many disjoint measurable sets `t n` and countably many measurable\nfunctions `g n`, one can construct a measurable function that coincides with `g n` on `t n`. ", "terms": "[\n  \"countably many\",\n  \"disjoint\",\n  \"measurable sets\",\n  \"measurable functions\",\n  \"construct\",\n  \"measurable function\",\n  \"coincides\"\n]"}
{"type": "{X : Type u} → {Y : Type v} → [inst : MetricSpace X] → [inst : MetricSpace Y] → X ⊕ Y → X ⊕ Y → ℝ", "name": "Metric.Sum.dist", "isProp": false, "docString": "Distance on a disjoint union. There are many (noncanonical) ways to put a distance compatible\nwith each factor.\nIf the two spaces are bounded, one can say for instance that each point in the first is at distance\n`diam X + diam Y + 1` of each point in the second.\nInstead, we choose a construction that works for unbounded spaces, but requires basepoints,\nchosen arbitrarily.\nWe embed isometrically each factor, set the basepoints at distance 1,\narbitrarily, and say that the distance from `a` to `b` is the sum of the distances of `a` and `b` to\ntheir respective basepoints, plus the distance 1 between the basepoints.\nSince there is an arbitrary choice in this construction, it is not an instance by default. ", "terms": "[\n    \"Distance\",\n    \"Disjoint Union\",\n    \"Noncanonical\",\n    \"Compatible\",\n    \"Bounded\",\n    \"Diameter\",\n    \"Unbounded\",\n    \"Basepoints\",\n    \"Embed\",\n    \"Isometrically\",\n    \"Sum\",\n    \"Instance\",\n    \"Default\"\n]"}
{"type": "∀ {α : Sort u} {a : α}, HEq a a", "name": "HEq.rfl", "isProp": true, "docString": "A version of `HEq.refl` with an implicit argument. ", "terms": "[]"}
{"type": "∀ {G : Type w} [inst : Group G] {g : G} {P : G → Prop},\n  P 1 → (∀ (a : G), P a → P (g * a)) → (∀ (a : G), P a → P (g⁻¹ * a)) → ∀ (n : ℤ), P (g ^ n)", "name": "zpow_induction_left", "isProp": true, "docString": "To show a property of all powers of `g` it suffices to show it is closed under multiplication\nby `g` and `g⁻¹` on the left. For subgroups generated by more than one element, see\n`Subgroup.closure_induction_left`. ", "terms": "[\n    \"property\",\n    \"powers\",\n    \"closed\",\n    \"multiplication\",\n    \"subgroups\",\n    \"generated\",\n    \"element\",\n    \"Subgroup.closure_induction_left\"\n]"}
{"type": "{M : Type w} →\n  {c f₁ f₂ : Type u} →\n    {r₁ r₂ : Type v} →\n      (c → M) →\n        (f₁ → M → M) →\n          (f₂ → M → M → M) →\n            {n : ℕ} → FirstOrder.Language.Functions (FirstOrder.Language.mk₂ c f₁ f₂ r₁ r₂) n → (Fin n → M) → M", "name": "FirstOrder.Language.funMap₂", "isProp": false, "docString": "The function map for `FirstOrder.Language.Structure₂`. ", "terms": "[\n  \"function map\",\n  \"FirstOrder\",\n  \"Language\",\n  \"Structure₂\"\n]"}
{"type": "{α : Type u} →\n  [inst : CompleteLattice α] →\n    {J : Type u} →\n      [inst_1 : CategoryTheory.SmallCategory J] →\n        (F : CategoryTheory.Functor J α) → CategoryTheory.Limits.ColimitCocone F", "name": "CategoryTheory.Limits.CompleteLattice.colimitCocone", "isProp": false, "docString": "The colimit cocone over any functor into a complete lattice.\n", "terms": "[\n    \"colimit\",\n    \"cocone\",\n    \"functor\",\n    \"complete lattice\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_5} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]\n  [inst_2 : LinearOrderedAddCommMonoid β] [inst_3 : SMul 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : OrderedSMul 𝕜 β]\n  {s : Set E} {f : E → β},\n  StrictConvexOn 𝕜 s f → ∀ {x y z : E}, x ∈ s → y ∈ s → x ≠ y → z ∈ openSegment 𝕜 x y → f z < max (f x) (f y)", "name": "StrictConvexOn.lt_on_openSegment", "isProp": true, "docString": "A strictly convex function on an open segment is strictly upper-bounded by the max of its\nendpoints. ", "terms": "[\n    \"strictly convex function\",\n    \"open segment\",\n    \"strictly upper-bounded\",\n    \"max\",\n    \"endpoints\"\n]"}
{"type": "∀ (R : Type u_1) [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {C : Module.Ray R M → Prop}, (∀ (v : M) (hv : v ≠ 0), C (rayOfNeZero R v hv)) → ∀ (x : Module.Ray R M), C x", "name": "Module.Ray.ind", "isProp": true, "docString": "An induction principle for `Module.Ray`, used as `induction x using Module.Ray.ind`. ", "terms": "[\"induction principle\", \"Module.Ray\"]"}
{"type": "{R : Type u_1} →\n  {M : Type u_2} →\n    {M₂ : Type u_3} →\n      [inst : TopologicalSpace M] →\n        [inst_1 : TopologicalSpace M₂] →\n          [inst_2 : Semiring R] →\n            [inst_3 : AddCommMonoid M₂] →\n              [inst_4 : Module R M₂] → [inst_5 : AddCommMonoid M] → [inst_6 : Module R M] → (M →L[R] M₂) → M₂ →L[R] M", "name": "ContinuousLinearMap.inverse", "isProp": false, "docString": "Introduce a function `inverse` from `M →L[R] M₂` to `M₂ →L[R] M`, which sends `f` to `f.symm` if\n`f` is a continuous linear equivalence and to `0` otherwise.  This definition is somewhat ad hoc,\nbut one needs a fully (rather than partially) defined inverse function for some purposes, including\nfor calculus. ", "terms": "[\n    \"function\",\n    \"inverse\",\n    \"M →L[R] M₂\",\n    \"M₂ →L[R] M\",\n    \"continuous\",\n    \"linear\",\n    \"equivalence\",\n    \"definition\",\n    \"inverse function\",\n    \"calculus\"\n]"}
{"type": "(𝕜 : Type u_6) →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type u_7} →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : NormedSpace 𝕜 E] →\n          {F : Type u_8} →\n            [inst_3 : NormedAddCommGroup F] → [inst_4 : NormedSpace 𝕜 F] → (E → F) → Set E → E → E →L[𝕜] F", "name": "fderivWithin", "isProp": false, "docString": "If `f` has a derivative at `x` within `s`, then `fderivWithin 𝕜 f s x` is such a derivative.\nOtherwise, it is set to `0`. If `x` is isolated in `s`, we take the derivative within `s` to\nbe zero for convenience. ", "terms": "[\n    \"derivative\", \n    \"fderivWithin\",\n    \"isolated\",\n    \"zero\"\n]"}
{"type": "{α : Type u_1} → {lt : α → α → Bool} → BinaryHeap α lt → Option α × BinaryHeap α lt", "name": "BinaryHeap.extractMax", "isProp": false, "docString": "`O(log n)`. Return and remove the maximum element from a `BinaryHeap`. ", "terms": "[\n    \"O(log n)\",\n    \"Return\",\n    \"Remove\",\n    \"Maximum element\",\n    \"BinaryHeap\"\n]"}
{"type": "∀ {Ω : Type u_2} [inst : MeasurableSpace Ω] [inst_1 : PseudoEMetricSpace Ω] [inst_2 : OpensMeasurableSpace Ω]\n  (μ : MeasureTheory.Measure Ω) [inst_3 : MeasureTheory.IsFiniteMeasure μ] {F : Set Ω},\n  IsClosed F →\n    ∀ {δs : ℕ → ℝ} (δs_pos : ∀ (n : ℕ), 0 < δs n),\n      Filter.Tendsto δs Filter.atTop (nhds 0) →\n        Filter.Tendsto (fun n => ∫⁻ (ω : Ω), ↑((thickenedIndicator (_ : 0 < δs n) F) ω) ∂μ) Filter.atTop (nhds (↑↑μ F))", "name": "MeasureTheory.tendsto_lintegral_thickenedIndicator_of_isClosed", "isProp": true, "docString": "The integrals of thickened indicators of a closed set against a finite measure tend to the\nmeasure of the closed set if the thickening radii tend to zero. ", "terms": "[\n    \"integrals\",\n    \"thickened indicators\",\n    \"closed set\",\n    \"finite measure\",\n    \"measure\",\n    \"thickening radii\",\n    \"tend to zero\"\n]"}
{"type": "{α : Type u_1} →\n  {m : MeasurableSpace α} →\n    {M : Type u_3} →\n      [inst : AddCommMonoid M] →\n        [inst_1 : TopologicalSpace M] →\n          [inst_2 : ContinuousAdd M] →\n            MeasureTheory.VectorMeasure α M → MeasureTheory.VectorMeasure α M → MeasureTheory.VectorMeasure α M", "name": "MeasureTheory.VectorMeasure.add", "isProp": false, "docString": "The sum of two vector measure is a vector measure. ", "terms": "[\n    \"sum\",\n    \"vector measure\"\n]"}
{"type": "(C : Type u_1) →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.HasShift C ℤ] →\n      (n m : ℤ) → n + m = 0 → (CategoryTheory.shiftFunctor Cᵒᵖ n ≅ (CategoryTheory.shiftFunctor C m).op)", "name": "CategoryTheory.Pretriangulated.shiftFunctorOpIso", "isProp": false, "docString": "The shift functor on the opposite category identifies to the opposite functor\nof a shift functor on the original category. ", "terms": "[\n    \"shift functor\",\n    \"opposite category\",\n    \"identifies\",\n    \"opposite functor\",\n    \"original category\"\n]"}
{"type": "∀ {V : Type u} {G G' : SimpleGraph V} (h : G ≤ G') {u v : V} {p : SimpleGraph.Walk G u v},\n  SimpleGraph.Walk.IsPath (SimpleGraph.Walk.mapLe h p) → SimpleGraph.Walk.IsPath p", "name": "SimpleGraph.Walk.IsPath.of_mapLe", "isProp": true, "docString": "**Alias** of the forward direction of `SimpleGraph.Walk.mapLe_isPath`.", "terms": "[\"Alias\", \"forward direction\", \"SimpleGraph.Walk.mapLe_isPath\"]"}
{"type": "{ι : Type v} → (α : ι → TopCatMax) → CategoryTheory.Limits.Cofan α", "name": "TopCat.sigmaCofan", "isProp": false, "docString": "The explicit cofan of a family of topological spaces given by the sigma type. ", "terms": "[\n    \"explicit cofan\",\n    \"family\",\n    \"topological spaces\",\n    \"sigma type\"\n]"}
{"type": "(M : Type u_1) → (N : Type u_2) → [inst : Monoid M] → [inst : Monoid N] → Type (max u_2 u_1)", "name": "MonCat.AssocMonoidHom", "isProp": false, "docString": "`MonoidHom` doesn't actually assume associativity. This alias is needed to make the category\ntheory machinery work. ", "terms": "[\"MonoidHom\", \"associativity\", \"alias\", \"category theory\", \"machinery\"]"}
{"type": "{γ : Type u_3} → [U : TopologicalSpace γ] → (m : MetricSpace γ) → U = UniformSpace.toTopologicalSpace → MetricSpace γ", "name": "MetricSpace.replaceTopology", "isProp": false, "docString": "Build a new metric space from an old one where the bundled topological structure is provably\n(but typically non-definitionaly) equal to some given topological structure.\nSee Note [forgetful inheritance].\n", "terms": "[\"metric space\", \"topological structure\", \"equal\", \"given\", \"inheritance\"]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X : C} (self : CategoryTheory.Sieve X) {Y Z : C}\n  {f : Y ⟶ X}, self.arrows f → ∀ (g : Z ⟶ Y), self.arrows (CategoryTheory.CategoryStruct.comp g f)", "name": "CategoryTheory.Sieve.downward_closed", "isProp": true, "docString": "stability by precomposition ", "terms": "[\"stability\", \"precomposition\"]"}
{"type": "{α : Type u_1} →\n  [inst : Preorder α] → [inst_1 : TopologicalSpace α] → [inst_2 : Topology.IsLowerSet α] → Topology.WithLowerSet α ≃ₜ α", "name": "Topology.IsLowerSet.WithLowerSetHomeomorph", "isProp": false, "docString": "If `α` is equipped with the lower set topology, then it is homeomorphic to `WithLowerSet α`. ", "terms": "[\n  \"equipped\",\n  \"lower set topology\",\n  \"homeomorphic\",\n  \"WithLowerSet\"\n]"}
{"type": "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], WittVector.IsPoly p fun x x_1 x_2 => 1", "name": "WittVector.oneIsPoly", "isProp": true, "docString": "The function that is constantly one on Witt vectors is a polynomial function. ", "terms": "[\n    \"function\", \n    \"constantly\", \n    \"one\", \n    \"Witt vectors\", \n    \"polynomial function\"\n]"}
{"type": "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] [inst_2 : Nonempty V] (k : ℕ),\n  (∀ (v : V), k ≤ SimpleGraph.degree G v) → k ≤ SimpleGraph.minDegree G", "name": "SimpleGraph.le_minDegree_of_forall_le_degree", "isProp": true, "docString": "In a nonempty graph, if `k` is at most the degree of every vertex, it is at most the minimum\ndegree. Note the assumption that the graph is nonempty is necessary as long as `G.minDegree` is\ndefined to be a natural. ", "terms": "[\n    \"nonempty graph\", \n    \"degree\", \n    \"vertex\", \n    \"minimum degree\", \n    \"graph\", \n    \"natural\"\n]"}
{"type": "∀ {M : Type u_1} [inst : MulOneClass M] {ι : Sort u_4} (S : ι → Submonoid M) {C : M → Prop} {x : M},\n  x ∈ ⨆ i, S i → (∀ (i : ι), ∀ x ∈ S i, C x) → C 1 → (∀ (x y : M), C x → C y → C (x * y)) → C x", "name": "Submonoid.iSup_induction", "isProp": true, "docString": "An induction principle for elements of `⨆ i, S i`.\nIf `C` holds for `1` and all elements of `S i` for all `i`, and is preserved under multiplication,\nthen it holds for all elements of the supremum of `S`. ", "terms": "[\n    \"induction principle\",\n    \"elements\",\n    \"⨆ i, S i\",\n    \"holds\",\n    \"1\",\n    \"all elements\",\n    \"preserved\",\n    \"multiplication\",\n    \"all elements\",\n    \"supremum\",\n    \"S\"\n]"}
{"type": "ZNum → Option PosNum", "name": "PosNum.ofZNum'", "isProp": false, "docString": "Converts a `ZNum` to `Option PosNum`, where it is `some` if the `ZNum` was positive and `none`\notherwise. ", "terms": "[\n    \"Converts\",\n    \"ZNum\",\n    \"Option\",\n    \"PosNum\",\n    \"some\",\n    \"none\"\n]"}
{"type": "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E] {n : ℕ}\n  [_i : Fact (FiniteDimensional.finrank ℝ E = n)] (o : Orientation ℝ E (Fin n)) (φ : E ≃ₗᵢ[ℝ] E),\n  0 < LinearMap.det ↑φ.toLinearEquiv →\n    ∀ (x : Fin n → E), (Orientation.volumeForm o) (⇑φ ∘ x) = (Orientation.volumeForm o) x", "name": "Orientation.volumeForm_comp_linearIsometryEquiv", "isProp": true, "docString": "The volume form is invariant under pullback by a positively-oriented isometric automorphism. ", "terms": "[\n    \"Volume form\",\n    \"Invariant\",\n    \"Pullback\",\n    \"Positively-oriented\",\n    \"Isometric\",\n    \"Automorphism\"\n]"}
{"type": "∀ {α : Type u} (s : Set α), IsOpen {u | s ∈ u}", "name": "ultrafilter_isOpen_basic", "isProp": true, "docString": "The basic open sets for the topology on ultrafilters are open. ", "terms": "[\n  \"basic open sets\", \n  \"topology\", \n  \"ultrafilters\", \n  \"open\"\n]"}
{"type": "{R : Type u_2} → [inst : CommMonoid R] → (S : Submonoid R) → OreLocalization.OreSet S", "name": "OreLocalization.oreSetComm", "isProp": false, "docString": "Every submonoid of a commutative monoid is an Ore set. ", "terms": "[\n  \"submonoid\",\n  \"commutative monoid\",\n  \"Ore set\"\n]"}
{"type": "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {s₁ : Setoid α} →\n      {s₂ : Setoid β} →\n        {φ : Quotient s₁ → Quotient s₂ → Sort u_5} →\n          [inst : ∀ (a : α) (b : β), Subsingleton (φ ⟦a⟧ ⟦b⟧)] →\n            (q₁ : Quotient s₁) →\n              (q₂ : Quotient s₂) → ((a₁ : α) → (a₂ : β) → φ (Quotient.mk'' a₁) (Quotient.mk'' a₂)) → φ q₁ q₂", "name": "Quotient.recOnSubsingleton₂'", "isProp": false, "docString": "A version of `Quotient.recOnSubsingleton₂` taking `{s₁ : Setoid α} {s₂ : Setoid α}`\nas implicit arguments instead of instance arguments. ", "terms": "[\n    \"Quotient.recOnSubsingleton₂\",\n    \"Setoid\",\n    \"implicit arguments\",\n    \"instance arguments\"\n]"}
{"type": "{α : Type u_1} →\n  {β : Type u_2} → [inst : TopologicalSpace α] → [inst_1 : TopologicalSpace β] → PartialHomeomorph α β → α → β", "name": "PartialHomeomorph.Simps.apply", "isProp": false, "docString": "See Note [custom simps projection]. We need to specify this projection explicitly in this case,\nbecause it is a composition of multiple projections. ", "terms": "[]"}
{"type": "{α : Type u} →\n  [inst : TopologicalSpace α] →\n    {γ : Type u} →\n      [inst_1 : TopologicalSpace γ] →\n        [inst_2 : T2Space γ] → [inst_3 : CompactSpace γ] → {f : α → γ} → Continuous f → StoneCech α → γ", "name": "stoneCechExtend", "isProp": false, "docString": "The extension of a continuous function from α to a compact\nHausdorff space γ to the Stone-Čech compactification of α. ", "terms": "[\n    \"extension\",\n    \"continuous function\",\n    \"compact Hausdorff space\",\n    \"Stone-Čech compactification\"\n]"}
{"type": "{α : Type u_1} →\n  {A : Type u_3} →\n    [inst : AddGroup A] → [inst_1 : Monoid α] → [inst_2 : DistribMulAction α A] → MulAction α (AddSubgroup A)", "name": "AddSubgroup.pointwiseMulAction", "isProp": false, "docString": "The action on an additive subgroup corresponding to applying the action to every element.\n\nThis is available as an instance in the `Pointwise` locale. ", "terms": "[\n    \"action\",\n    \"additive subgroup\",\n    \"applying\",\n    \"every element\",\n    \"instance\",\n    \"Pointwise\",\n    \"locale\"\n]"}
{"type": "{α : Type u_1} → [inst : Preorder α] → (ℕ →o α) → α", "name": "monotonicSequenceLimit", "isProp": false, "docString": "The constant value of an eventually-constant monotone sequence `a₀ ≤ a₁ ≤ a₂ ≤ ...` in a\npartially-ordered type. ", "terms": "[\n  \"constant value\",\n  \"eventually-constant\",\n  \"monotone sequence\",\n  \"partially-ordered type\"\n]"}
{"type": "∀ (α : Type u) [inst : Preorder α] [inst_1 : Nonempty α] [inst_2 : NoMinOrder α] [inst_3 : NoMaxOrder α],\n  ∃ f, StrictAnti f", "name": "Int.exists_strictAnti", "isProp": true, "docString": "If `α` is a nonempty preorder with no minimal or maximal elements, then there exists a strictly\nantitone function `f : ℤ → α`. ", "terms": "[\n    \"nonempty\",\n    \"preorder\",\n    \"minimal elements\",\n    \"maximal elements\",\n    \"strictly\",\n    \"antitone function\"\n]"}
{"type": "∀ {α : Type u_1} [inst : PartialOrder α] {s t : Finset α} {a : α},\n  { ofColex := s } ≤ { ofColex := t } → (∀ b ∈ t, b < a) → ∀ b ∈ s, b < a", "name": "Finset.Colex.forall_lt_mono", "isProp": true, "docString": "If `s ≤ t` in colex, and all elements in `t` are small, then all elements in `s` are small. ", "terms": "[\n    \"≤\",\n    \"colex\",\n    \"elements\",\n    \"small\"\n]"}
{"type": "∀ {R : Type u_1} [inst : AddCommGroup R] {f g : ℕ → R} (s : Set ℕ),\n  (∀ (m n : ℕ), m ∣ n → n ∈ s → m ∈ s) →\n    ((∀ n > 0, n ∈ s → (Finset.sum (Nat.divisors n) fun i => f i) = g n) ↔\n      ∀ n > 0,\n        n ∈ s → (Finset.sum (Nat.divisorsAntidiagonal n) fun x => Nat.ArithmeticFunction.moebius x.1 • g x.2) = f n)", "name": "Nat.ArithmeticFunction.sum_eq_iff_sum_smul_moebius_eq_on", "isProp": true, "docString": "Möbius inversion for functions to an `AddCommGroup`, where the equalities only hold on a\nwell-behaved set. ", "terms": "[\n  \"Möbius inversion\",\n  \"functions\",\n  \"AddCommGroup\",\n  \"equalities\",\n  \"set\",\n  \"well-behaved\"\n]"}
{"type": "∀ {ι : Type u_1} {E : Type u_3} [inst : SeminormedAddCommGroup E] {f : ι → E},\n  (Summable fun i => ‖f i‖) → ‖∑' (i : ι), f i‖ ≤ ∑' (i : ι), ‖f i‖", "name": "norm_tsum_le_tsum_norm", "isProp": true, "docString": "If `∑' i, ‖f i‖` is summable, then `‖∑' i, f i‖ ≤ (∑' i, ‖f i‖)`. Note that we do not assume\nthat `∑' i, f i` is summable, and it might not be the case if `α` is not a complete space. ", "terms": "[\n    \"summable\",\n    \"norm\",\n    \"less than or equal to\",\n    \"complete space\"\n]"}
{"type": "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E] [inst_2 : CompleteSpace E]\n  (K : ProperCone ℝ E), ProperCone.dual (ProperCone.dual K) = K", "name": "ProperCone.dual_dual", "isProp": true, "docString": "The dual of the dual of a proper cone is itself. ", "terms": "[\"dual\", \"proper cone\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{w, u₂} D] →\n        [inst_2 : CategoryTheory.Limits.HasBinaryCoproducts C] →\n          [inst_3 : CategoryTheory.Limits.HasBinaryCoproducts D] →\n            (F : CategoryTheory.Functor C D) →\n              (A : C) →\n                CategoryTheory.Functor.comp F (CategoryTheory.Limits.coprod.functor.obj (F.obj A)) ⟶\n                  CategoryTheory.Functor.comp (CategoryTheory.Limits.coprod.functor.obj A) F", "name": "CategoryTheory.Limits.coprodComparisonNatTrans", "isProp": false, "docString": "The coproduct comparison morphism from `FA ⨿ F-` to `F(A ⨿ -)`, whose components are given by\n`coprodComparison`.\n", "terms": "[\n    \"coproduct\",\n    \"comparison\",\n    \"morphism\",\n    \"components\"\n]"}
{"type": "{ι : Type u_1} →\n  {M : Type u_2} →\n    [inst : AddCommMonoid M] →\n      {I₀ : WithTop (BoxIntegral.Box ι)} →\n        BoxIntegral.BoxAdditiveMap ι M I₀ →\n          (I : WithTop (BoxIntegral.Box ι)) → I ≤ I₀ → BoxIntegral.BoxAdditiveMap ι M I", "name": "BoxIntegral.BoxAdditiveMap.restrict", "isProp": false, "docString": "If `f` is box-additive on subboxes of `I₀`, then it is box-additive on subboxes of any\n`I ≤ I₀`. ", "terms": "[\n    \"box-additive\",\n    \"subboxes\",\n    \"≤\"\n]"}
{"type": "{ι : Type u_1} → (A : ι → Type u_2) → [inst : AddMonoid ι] → [inst_1 : GradedMonoid.GMonoid A] → A 0 →* GradedMonoid A", "name": "GradedMonoid.mkZeroMonoidHom", "isProp": false, "docString": "`GradedMonoid.mk 0` is a `MonoidHom`, using the `GradedMonoid.GradeZero.monoid` structure.\n", "terms": "[\n  \"GradedMonoid.mk\",\n  \"MonoidHom\",\n  \"GradedMonoid.GradeZero.monoid\",\n  \"structure\"\n]"}
{"type": "{R : Type u_1} →\n  [inst : CommRing R] →\n    {M : Type u_2} →\n      [inst_1 : AddCommGroup M] →\n        [inst_2 : Module R M] → {Q : QuadraticForm R M} → CliffordAlgebra Q →ₗ[R] CliffordAlgebra Q", "name": "CliffordAlgebra.reverse", "isProp": false, "docString": "Grade reversion, inverting the multiplication order of basis vectors.\nAlso called *transpose* in some literature. ", "terms": "[\n    \"Grade reversion\",\n    \"inverting\",\n    \"multiplication order\",\n    \"basis vectors\",\n    \"transpose\"\n]"}
{"type": "(L : FirstOrder.Language) → [inst : FirstOrder.Language.IsOrdered L] → FirstOrder.Language.Sentence L", "name": "FirstOrder.Language.denselyOrderedSentence", "isProp": false, "docString": "A sentence indicating that an order is dense:\n$\\forall x, \\forall y, x < y \\to \\exists z, x < z \\wedge z < y$. ", "terms": "[\n  \"forall\",\n  \"exists\",\n  \"less than\",\n  \"logical conjunction\",\n  \"logical implication\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {J : Type w} →\n          [inst_2 : CategoryTheory.Category.{w', w} J] →\n            {K : CategoryTheory.Functor J C} →\n              {F : CategoryTheory.Functor C D} →\n                [inst_3 : CategoryTheory.CreatesLimit K F] →\n                  {c : CategoryTheory.Limits.Cone (CategoryTheory.Functor.comp K F)} →\n                    CategoryTheory.Limits.IsLimit c → CategoryTheory.Limits.Cone K", "name": "CategoryTheory.liftLimit", "isProp": false, "docString": "`liftLimit t` is the cone for `K` given by lifting the limit `t` for `K ⋙ F`. ", "terms": "[\n    \"liftLimit\",\n    \"cone\",\n    \"lifting\",\n    \"limit\"\n]"}
{"type": "({R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → (R →+* S) → Prop) → Prop", "name": "RingHom.StableUnderComposition", "isProp": false, "docString": "A property is `StableUnderComposition` if the composition of two such morphisms\nstill falls in the class. ", "terms": "[\"property\", \"StableUnderComposition\", \"composition\", \"morphisms\", \"class\"]"}
{"type": "∀ {ι : Type u_1} {A : ι → Type u_2} [inst : Add ι] [inst_1 : (i : ι) → AddCommMonoid (A i)]\n  [self : DirectSum.GNonUnitalNonAssocSemiring A] {i j : ι} (a : A i) (b c : A j),\n  GradedMonoid.GMul.mul a (b + c) = GradedMonoid.GMul.mul a b + GradedMonoid.GMul.mul a c", "name": "DirectSum.GNonUnitalNonAssocSemiring.mul_add", "isProp": true, "docString": "Multiplication from the right between graded components distributes with respect to\naddition. ", "terms": "[\n  \"Multiplication\",\n  \"Right\",\n  \"Graded components\",\n  \"Distributes\",\n  \"Respect\",\n  \"Addition\"\n]"}
{"type": "{E : ℕ → Type u_1} → ((n : ℕ) → E n) → ℕ → Set ((n : ℕ) → E n)", "name": "PiNat.cylinder", "isProp": false, "docString": "In a product space `Π n, E n`, the cylinder set of length `n` around `x`, denoted\n`cylinder x n`, is the set of sequences `y` that coincide with `x` on the first `n` symbols, i.e.,\nsuch that `y i = x i` for all `i < n`.\n", "terms": "[\n    \"product space\",\n    \"cylinder set\",\n    \"length\",\n    \"set\",\n    \"sequences\",\n    \"coincide\",\n    \"symbols\",\n    \"for all\"\n]"}
{"type": "∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAdd₂ G]\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\n  [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddRightInvariant μ],\n  MeasureTheory.MeasurePreserving fun z => (z.1 - z.2, z.2)", "name": "MeasureTheory.measurePreserving_sub_prod", "isProp": true, "docString": "The map `(x, y) ↦ (x - y, y)` preserves the measure `μ × ν`. ", "terms": "[\n    \"map\",\n    \"measure\",\n    \"preserves\"\n]"}
{"type": "Lean.TrailingParserDescr", "name": "CategoryTheory.ihom.«term_⟶[_]_»", "isProp": false, "docString": "`A ⟶[C] B` denotes the internal hom from `A` to `B` ", "terms": "[\n  \"internal hom\"\n]"}
{"type": "{α : Type u} → {s : Set α} → CoeHead (Set ↑s) (Set α)", "name": "Set.instCoeHeadSetElem", "isProp": false, "docString": "Coercion using `(Subtype.val '' ·)` ", "terms": "The mathematical terms in the statement provided are \"Coercion\", \"Subtype\", \"val\". Therefore, the JSON list of mathematical terms is:\n\n    [\"Coercion\", \"Subtype\", \"val\"]"}
{"type": "{α : Type u_3} →\n  {β : Type u_4} →\n    [inst : Lattice α] →\n      [inst_1 : BoundedOrder α] →\n        [inst_2 : Lattice β] → [inst_3 : BoundedOrder β] → BoundedLatticeHom α β ≃ BoundedLatticeHom αᵒᵈ βᵒᵈ", "name": "BoundedLatticeHom.dual", "isProp": false, "docString": "Reinterpret a bounded lattice homomorphism as a bounded lattice homomorphism between the dual\nbounded lattices. ", "terms": "[\n  \"Reinterpret\",\n  \"bounded lattice\",\n  \"homomorphism\",\n  \"dual bounded lattices\"\n]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    {X Y : CategoryTheory.SimplicialObject.Augmented C} →\n      (X ≅ Y) → SimplicialObject.Augmented.ExtraDegeneracy X → SimplicialObject.Augmented.ExtraDegeneracy Y", "name": "SimplicialObject.Augmented.ExtraDegeneracy.ofIso", "isProp": false, "docString": "If `X` and `Y` are isomorphic augmented simplicial objects, then an extra\ndegeneracy for `X` gives also an extra degeneracy for `Y` ", "terms": []}
{"type": "∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (Q : Type u_5)\n  [inst_3 : AddCommGroup Q] [inst_4 : Module R Q] (N : Submodule R M),\n  LinearMap.ker (LinearMap.lTensor Q (Submodule.mkQ N)) = LinearMap.range (LinearMap.lTensor Q (Submodule.subtype N))", "name": "lTensor_mkQ", "isProp": true, "docString": "Right-exactness of tensor product ", "terms": "[\n    \"Right-exactness\",\n    \"Tensor product\"\n]"}
{"type": "∀ (A : Type u_2) [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsDedekindDomain A] (P : Ideal A)\n  [inst_3 : Ideal.IsPrime P] (Aₘ : Type u_4) [inst_4 : CommRing Aₘ] [inst_5 : IsDomain Aₘ] [inst_6 : Algebra A Aₘ]\n  [inst : IsLocalization.AtPrime Aₘ P], IsDedekindDomain Aₘ", "name": "IsLocalization.AtPrime.isDedekindDomain", "isProp": true, "docString": "The localization of a Dedekind domain at every nonzero prime ideal is a Dedekind domain. ", "terms": "[\n    \"localization\",\n    \"Dedekind domain\",\n    \"nonzero\",\n    \"prime ideal\"\n]"}
{"type": "∀ (α : Type u) [inst : OrderedCommGroup α],\n  ContravariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1", "name": "OrderedCommGroup.to_contravariantClass_right_le", "isProp": true, "docString": "A choice-free shortcut instance. ", "terms": "[]\n"}
{"type": "(α : Type u₁) → (CategoryTheory.Discrete α)ᵒᵖ ≌ CategoryTheory.Discrete α", "name": "CategoryTheory.Discrete.opposite", "isProp": false, "docString": "A discrete category is equivalent to its opposite category. ", "terms": "[\n    \"Discrete category\",\n    \"Equivalent\",\n    \"Opposite category\"\n]"}
{"type": "{n : ℕ} → {α : Type u_1} → {β : Type u_2} → (β → α → β) → β → Vector α n → Vector β (n + 1)", "name": "Vector.scanl", "isProp": false, "docString": "Construct a `Vector β (n + 1)` from a `Vector α n` by scanning `f : β → α → β`\nfrom the \"left\", that is, from 0 to `Fin.last n`, using `b : β` as the starting value.\n", "terms": "[\n    \"Vector\",\n    \"Construct\",\n    \"scanning\",\n    \"from\",\n    \"left\",\n    \"to\",\n    \"starting value\",\n    \"Fin.last\"\n]"}
{"type": "∀ {α : Type u_1} {ι : Type u_4} {s : ι → Set α}, Filter.liminf s Filter.cofinite = {x | Set.Finite {n | x ∉ s n}}", "name": "Filter.cofinite.liminf_set_eq", "isProp": true, "docString": "In other words, `liminf cofinite s` is the set of elements lying outside the family `s`\nfinitely often. ", "terms": "[\"liminf\", \"cofinite\", \"set\", \"elements\", \"family\", \"finitely often\"]"}
{"type": "∀ {α : Type u}, TopologicalSpace.induced pure Ultrafilter.topologicalSpace = ⊥", "name": "induced_topology_pure", "isProp": true, "docString": "The map `pure : α → Ultrafilter α` induces on `α` the discrete topology. ", "terms": "[\n  \"map\",\n  \"pure\",\n  \"Ultrafilter\",\n  \"induces\",\n  \"discrete topology\"\n]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X : C} (P : CategoryTheory.Functor Cᵒᵖ (Type w))\n  {S : CategoryTheory.Sieve X} {R : CategoryTheory.Presieve X},\n  S.arrows ≤ R →\n    CategoryTheory.Presieve.IsSheafFor P S.arrows →\n      (∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄,\n          R f → CategoryTheory.Presieve.IsSeparatedFor P (CategoryTheory.Sieve.pullback f S).arrows) →\n        CategoryTheory.Presieve.IsSheafFor P R", "name": "CategoryTheory.Presieve.isSheafFor_subsieve_aux", "isProp": true, "docString": "If a presieve `R` on `X` has a subsieve `S` such that:\n\n* `P` is a sheaf for `S`.\n* For every `f` in `R`, `P` is separated for the pullback of `S` along `f`,\n\nthen `P` is a sheaf for `R`.\n\nThis is closely related to [Elephant] C2.1.6(i).\n", "terms": "[\n    \"presieve\",\n    \"sub-sieve\", \n    \"sheaf\", \n    \"separated\", \n    \"pullback\"\n]"}
{"type": "{β : Sort v} → (β → β → Prop) → Prop", "name": "Reflexive", "isProp": false, "docString": "A reflexive relation relates every element to itself. ", "terms": "[\"reflexive relation\", \"element\"]"}
{"type": "{𝕜 : Type u_1} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type u_2} →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : NormedSpace 𝕜 E] →\n          {E' : Type u_3} →\n            [inst_3 : NormedAddCommGroup E'] →\n              [inst_4 : NormedSpace 𝕜 E'] →\n                {H : Type u_4} →\n                  [inst_5 : TopologicalSpace H] →\n                    (I : ModelWithCorners 𝕜 E H) →\n                      {H' : Type u_5} →\n                        [inst_6 : TopologicalSpace H'] →\n                          (I' : ModelWithCorners 𝕜 E' H') →\n                            {M : Type u_6} →\n                              [inst_7 : TopologicalSpace M] →\n                                [inst_8 : ChartedSpace H M] →\n                                  [inst_9 : SmoothManifoldWithCorners I M] →\n                                    {M' : Type u_7} →\n                                      [inst_10 : TopologicalSpace M'] →\n                                        [inst_11 : ChartedSpace H' M'] →\n                                          [inst_12 : SmoothManifoldWithCorners I' M'] →\n                                            {N : Type u_9} → (N → M) → (N → M') → (N → E →L[𝕜] E') → N → N → E →L[𝕜] E'", "name": "inTangentCoordinates", "isProp": false, "docString": "When `ϕ x` is a continuous linear map that changes vectors in charts around `f x` to vectors\nin charts around `g x`, `inTangentCoordinates I I' f g ϕ x₀ x` is a coordinate change of\nthis continuous linear map that makes sense from charts around `f x₀` to charts around `g x₀`\nby composing it with appropriate coordinate changes.\nNote that the type of `ϕ` is more accurately\n`Π x : N, TangentSpace I (f x) →L[𝕜] TangentSpace I' (g x)`.\nWe are unfolding `TangentSpace` in this type so that Lean recognizes that the type of `ϕ` doesn't\nactually depend on `f` or `g`.\n\nThis is the underlying function of the trivializations of the hom of (pullbacks of) tangent spaces.\n", "terms": "[\n    \"Continuous linear map\",\n    \"Vectors\",\n    \"Charts\",\n    \"Coordinate change\",\n    \"Composing\",\n    \"TangentSpace\",\n    \"Type\",\n    \"Unfolding\",\n    \"Depend\",\n    \"Underlying function\",\n    \"Trivializations\",\n    \"Hom\",\n    \"Pullbacks\",\n    \"Tangent spaces\"\n]"}
{"type": "PosNum → PosNum", "name": "PosNum.minFac", "isProp": false, "docString": "Returns the smallest prime factor of `n ≠ 1`. ", "terms": "[\n  \"Returns\",\n  \"smallest\",\n  \"prime factor\",\n  \"n\",\n  \"≠\",\n  \"1\"\n]"}
{"type": "∀ {α : Type u_1} [inst : AddCommSemigroup α] [inst_1 : PartialOrder α] [inst_2 : ExistsAddOfLE α]\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_4 : Sub α] [inst : OrderedSub α]\n  {a b c : α}, c ≤ b → a - c < b - c → a < b", "name": "lt_of_tsub_lt_tsub_right_of_le", "isProp": true, "docString": "See `lt_of_tsub_lt_tsub_right` for a stronger statement in a linear order. ", "terms": "[]"}
{"type": "{n : Type u_2} →\n  {α : Type u_3} →\n    [inst : Fintype n] →\n      [inst_1 : DecidableEq n] →\n        [inst_2 : Semiring α] →\n          [inst_3 : StarRing α] → (A : Matrix n n α) → [inst_4 : Invertible (Matrix.conjTranspose A)] → Invertible A", "name": "Matrix.invertibleOfInvertibleConjTranspose", "isProp": false, "docString": "A matrix is invertible if the conjugate transpose is invertible. ", "terms": "[\n    \"Matrix\",\n    \"Invertible\",\n    \"Conjugate Transpose\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {J : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} J] →\n        (F : CategoryTheory.Functor Jᵒᵖ C) →\n          {c : CategoryTheory.Limits.Cone F} →\n            CategoryTheory.Limits.IsLimit c →\n              CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.coconeRightOpOfCone c)", "name": "CategoryTheory.Limits.isColimitCoconeRightOpOfCone", "isProp": false, "docString": "Turn a limit for `F : Jᵒᵖ ⥤ C` into a colimit for `F.rightOp : J ⥤ Cᵒᵖ`. ", "terms": "[\n    \"limit\",\n    \"colimit\",\n    \"functor\",\n    \"opposite category\"\n]"}
{"type": "∀ {V : Type u_1} {W : Type u_2} [inst : SeminormedAddCommGroup V] [inst_1 : SeminormedAddCommGroup W]\n  (self : NormedAddGroupHom V W), ∃ C, ∀ (v : V), ‖NormedAddGroupHom.toFun self v‖ ≤ C * ‖v‖", "name": "NormedAddGroupHom.bound'", "isProp": true, "docString": "A `NormedAddGroupHom` is bounded. ", "terms": "[\n  \"NormedAddGroupHom\",\n  \"bounded\"\n]"}
{"type": "{J : Type w} →\n  {C : Type u} →\n    [inst : CategoryTheory.Category.{v, u} C] →\n      {F : CategoryTheory.Functor (CategoryTheory.Limits.WalkingParallelFamily J) C} →\n        (CategoryTheory.Limits.Cotrident fun j => F.map (CategoryTheory.Limits.WalkingParallelFamily.Hom.line j)) →\n          CategoryTheory.Limits.Cocone F", "name": "CategoryTheory.Limits.Cocone.ofCotrident", "isProp": false, "docString": "This is a helper construction that can be useful when verifying that a category has all\ncoequalizers. Given `F : WalkingParallelFamily ⥤ C`, which is really the same as\n`parallelFamily (fun j ↦ F.map (line j))`, and a cotrident on `fun j ↦ F.map (line j)` we get a\ncocone on `F`.\n\nIf you're thinking about using this, have a look at\n`hasWideCoequalizers_of_hasColimit_parallelFamily`, which you may find to be an easier way\nof achieving your goal. ", "terms": "[\n    \"helper construction\",\n    \"verifying\",\n    \"category\",\n    \"coequalizers\",\n    \"WalkingParallelFamily\",\n    \"C\",\n    \"parallelFamily\",\n    \"cotrident\",\n    \"cocone\",\n    \"hasWideCoequalizers_of_hasColimit_parallelFamily\"\n]"}
{"type": "∀ {ι : Type u_1} {I J Js : BoxIntegral.Box ι} {s : Finset (ι × ℝ)},\n  (∀ (i : ι), {(i, BoxIntegral.Box.lower J i), (i, BoxIntegral.Box.upper J i)} ⊆ s) →\n    Js ∈ BoxIntegral.Prepartition.splitMany I s → ¬Disjoint ↑J ↑Js → Js ≤ J", "name": "BoxIntegral.Prepartition.not_disjoint_imp_le_of_subset_of_mem_splitMany", "isProp": true, "docString": "Let `s : Finset (ι × ℝ)` be a set of hyperplanes `{x : ι → ℝ | x i = r}` in `ι → ℝ` encoded as\npairs `(i, r)`. Suppose that this set contains all faces of a box `J`. The hyperplanes of `s` split\na box `I` into subboxes. Let `Js` be one of them. If `J` and `Js` have nonempty intersection, then\n`Js` is a subbox of `J`.  ", "terms": "[\n    \"Finset\",\n    \"hyperplanes\",\n    \"encoded\",\n    \"pairs\",\n    \"contains\",\n    \"faces\",\n    \"box\",\n    \"split\",\n    \"subboxes\",\n    \"intersection\",\n    \"subbox\"\n]"}
{"type": "(R : Type u_1) →\n  [inst : CommRing R] →\n    {C : Type u} →\n      [inst_1 : CategoryTheory.Category.{v, u} C] →\n        {D : Type u} →\n          [inst_2 : CategoryTheory.Category.{v, u} D] →\n            [inst_3 : CategoryTheory.Preadditive D] →\n              [inst_4 : CategoryTheory.Linear R D] →\n                CategoryTheory.Functor C D → CategoryTheory.Functor (CategoryTheory.Free R C) D", "name": "CategoryTheory.Free.lift", "isProp": false, "docString": "A functor to an `R`-linear category lifts to a functor from its `R`-linear completion.\n", "terms": "[\n    \"functor\",\n    \"R-linear category\",\n    \"lifts\",\n    \"R-linear completion\"\n]"}
{"type": "∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {𝕜 : Type u_2} [inst_1 : IsROrC 𝕜]\n  {E : Type u_3} [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ℝ E] [inst_4 : NormedSpace 𝕜 E]\n  [inst_5 : CompleteSpace E] {F F' : 𝕜 → α → E} {x₀ : 𝕜} {ε : ℝ},\n  0 < ε →\n    (∀ᶠ (x : 𝕜) in nhds x₀, MeasureTheory.AEStronglyMeasurable (F x) μ) →\n      MeasureTheory.Integrable (F x₀) →\n        MeasureTheory.AEStronglyMeasurable (F' x₀) μ →\n          ∀ {bound : α → ℝ},\n            (∀ᵐ (a : α) ∂μ, ∀ x ∈ Metric.ball x₀ ε, ‖F' x a‖ ≤ bound a) →\n              MeasureTheory.Integrable bound →\n                (∀ᵐ (a : α) ∂μ, ∀ x ∈ Metric.ball x₀ ε, HasDerivAt (fun x => F x a) (F' x a) x) →\n                  MeasureTheory.Integrable (F' x₀) ∧\n                    HasDerivAt (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), F' x₀ a ∂μ) x₀", "name": "hasDerivAt_integral_of_dominated_loc_of_deriv_le", "isProp": true, "docString": "Derivative under integral of `x ↦ ∫ F x a` at a given point `x₀ : ℝ`, assuming\n`F x₀` is integrable, `x ↦ F x a` is differentiable on an interval around `x₀` for ae `a`\n(with interval radius independent of `a`) with derivative uniformly bounded by an integrable\nfunction, and `F x` is ae-measurable for `x` in a possibly smaller neighborhood of `x₀`. ", "terms": "[\n  \"Derivative\",\n  \"Integral\",\n  \"Integrable\",\n  \"Differentiable\",\n  \"Interval\",\n  \"Derivative uniformly bounded\",\n  \"Measurable\",\n  \"Neighborhood\",\n  \"Real numbers (ℝ)\"\n]"}
{"type": "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : Countable α] [inst_2 : MeasurableSingletonClass α]\n  (μ : MeasureTheory.Measure α), (MeasureTheory.Measure.sum fun a => ↑↑μ {a} • MeasureTheory.Measure.dirac a) = μ", "name": "MeasureTheory.Measure.sum_smul_dirac", "isProp": true, "docString": "A measure on a countable type is a sum of Dirac measures. ", "terms": "[\n  \"measure\",\n  \"countable type\",\n  \"sum\",\n  \"Dirac measures\"\n]"}
{"type": "{X Y : TopCat} → TopCat.of (↑X × ↑Y) ⟶ Y", "name": "TopCat.prodSnd", "isProp": false, "docString": "The second projection from the product. ", "terms": "[\n    \"Second Projection\",\n    \"Product\"\n]"}
{"type": "{V : Type u} → {G : SimpleGraph V} → Inhabited (SimpleGraph.Partition G)", "name": "SimpleGraph.instInhabitedPartition", "isProp": false, "docString": "The partition where every vertex is in its own part. ", "terms": "[\"partition\", \"vertex\", \"part\"]"}
{"type": "(R : Type u) →\n  (M : Type v₁) →\n    (N : Type v₂) →\n      [inst : CommSemiring R] →\n        [inst_1 : AddCommMonoid M] →\n          [inst_2 : AddCommMonoid N] →\n            [inst_3 : Module R M] → [inst_4 : Module R N] → TensorProduct R (Module.Dual R M) N →ₗ[R] M →ₗ[R] N", "name": "dualTensorHom", "isProp": false, "docString": "The natural map associating a linear map to the tensor product of two modules. ", "terms": "[\n    \"Natural map\",\n    \"Associating\",\n    \"Linear map\",\n    \"Tensor product\",\n    \"Two modules\"\n]"}
{"type": "∀ {X : Type u_4} [inst : TopologicalSpace X] [self : PathConnectedSpace X], Nonempty X", "name": "PathConnectedSpace.nonempty", "isProp": true, "docString": "A path-connected space must be nonempty. ", "terms": "[\"path-connected space\", \"nonempty\"]"}
{"type": "{α : Type u} → {β : Type v} → (α → β) → Stream'.Seq α → Stream'.Seq β", "name": "Stream'.Seq.map", "isProp": false, "docString": "Map a function over a sequence. ", "terms": "[\"Map\", \"Function\", \"Sequence\"]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E] {s : Set E},\n  (convexHull 𝕜) s = ⋃ t, ⋃ (_ : ↑t ⊆ s), ⋃ (_ : AffineIndependent 𝕜 Subtype.val), (convexHull 𝕜) ↑t", "name": "convexHull_eq_union", "isProp": true, "docString": "**Carathéodory's convexity theorem** ", "terms": "[\n    \"Carathéodory's convexity theorem\"\n]"}
{"type": "∀ {d : ℤ} {a : Pell.Solution₁ d}, Pell.IsFundamental a → 0 < Pell.Solution₁.x a", "name": "Pell.IsFundamental.x_pos", "isProp": true, "docString": "A fundamental solution has positive `x`. ", "terms": "[\"fundamental solution\", \"positive\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {W X Y Z : C} →\n      [inst_1 : CategoryTheory.Limits.HasBinaryProduct W X] →\n        [inst_2 : CategoryTheory.Limits.HasBinaryProduct Y Z] → (W ⟶ Y) → (X ⟶ Z) → (W ⨯ X ⟶ Y ⨯ Z)", "name": "CategoryTheory.Limits.prod.map", "isProp": false, "docString": "If the products `W ⨯ X` and `Y ⨯ Z` exist, then every pair of morphisms `f : W ⟶ Y` and\n`g : X ⟶ Z` induces a morphism `prod.map f g : W ⨯ X ⟶ Y ⨯ Z`. ", "terms": "[\n    \"products\",\n    \"exist\",\n    \"pair\",\n    \"morphisms\",\n    \"induces\",\n    \"morphism\",\n    \"prod.map\"\n]"}
{"type": "∀ {F : Type u_1} {G : Type u_2} {N : Type u_3} [inst : SubtractionMonoid G] [inst_1 : AddMonoid N]\n  [inst_2 : AddMonoidHomClass F G N] {x : G}, IsAddUnit x → ∀ (f g : F), f x = g x → f (-x) = g (-x)", "name": "IsAddUnit.eq_on_neg", "isProp": true, "docString": "If two homomorphisms from a subtraction monoid to an additive monoid are equal at an\nadditive unit `x`, then they are equal at `-x`.", "terms": "[\n    \"homomorphisms\",\n    \"subtraction monoid\",\n    \"additive monoid\",\n    \"equal\",\n    \"additive unit\"\n]"}
{"type": "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x : V),\n  2 • Orientation.oangle o x (-x) = 0", "name": "Orientation.two_zsmul_oangle_neg_self_right", "isProp": true, "docString": "Twice the angle between a vector and its negation is 0. ", "terms": "[\"Twice\", \"angle\", \"vector\", \"negation\", \"0\"]"}
{"type": "{f : Type u → Type v} → [self : Functor f] → {α β : Type u} → α → f β → f α", "name": "Functor.mapConst", "isProp": false, "docString": "The special case `const a <$> x`, which can sometimes be implemented more\nefficiently. ", "terms": "[\"special case\", \"const\", \"<$>\", \"implemented\", \"efficiently\"]"}
{"type": "∀ {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [inst : Fintype ι] [inst_1 : NontriviallyNormedField 𝕜]\n  [inst_2 : (i : ι) → NormedAddCommGroup (E i)] [inst_3 : (i : ι) → NormedSpace 𝕜 (E i)] [inst_4 : NormedAddCommGroup G]\n  [inst_5 : NormedSpace 𝕜 G] (f : ContinuousMultilinearMap 𝕜 E G) (m : (i : ι) → E i),\n  ‖f m‖ ≤ ‖f‖ * Finset.prod Finset.univ fun i => ‖m i‖", "name": "ContinuousMultilinearMap.le_op_norm", "isProp": true, "docString": "The fundamental property of the operator norm of a continuous multilinear map:\n`‖f m‖` is bounded by `‖f‖` times the product of the `‖m i‖`. ", "terms": "[\n    \"fundamental property\",\n    \"operator norm\",\n    \"continuous\",\n    \"multilinear map\",\n    \"bounded\",\n    \"times\",\n    \"product\"\n]"}
{"type": "∀ {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : CompactSpace X] [inst_2 : Nonempty X]\n  [inst_3 : MetricSpace Y] [inst_4 : CompactSpace Y] [inst_5 : Nonempty Y],\n  GromovHausdorff.HD (GromovHausdorff.candidatesBDist X Y) ≤ Metric.diam Set.univ + 1 + Metric.diam Set.univ", "name": "GromovHausdorff.HD_candidatesBDist_le", "isProp": true, "docString": "Explicit bound on `HD (dist)`. This means that when looking for minimizers it will\nbe sufficient to look for functions with `HD(f)` bounded by this bound. ", "terms": "[\n  \"Explicit bound\",\n  \"HD (dist)\",\n  \"minimizers\",\n  \"functions\",\n  \"HD(f)\",\n  \"bound\"\n]"}
{"type": "{G : Type u_1} → [inst : AddGroup G] → Set G → Set G → Prop", "name": "AddSubgroup.IsComplement", "isProp": false, "docString": "`S` and `T` are complements if `(+) : S × T → G` is a bijection", "terms": "[\n    \"complements\",\n    \"bijection\"\n]"}
{"type": "∀ (a : ↥circle), LinearEquiv.det (rotation a).toLinearEquiv = 1", "name": "linearEquiv_det_rotation", "isProp": true, "docString": "The determinant of `rotation` (as a linear equiv) is equal to `1`. ", "terms": "[\"determinant\", \"rotation\", \"linear equiv\", \"equal\", \"1\"]"}
{"type": "{C₁ : Type u_1} →\n  {C₂ : Type u_2} →\n    {D₁ : Type u_4} →\n      {D₂ : Type u_5} →\n        [inst : CategoryTheory.Category.{u_6, u_1} C₁] →\n          [inst_1 : CategoryTheory.Category.{u_7, u_2} C₂] →\n            [inst_2 : CategoryTheory.Category.{u_8, u_4} D₁] →\n              [inst_3 : CategoryTheory.Category.{u_9, u_5} D₂] →\n                (L₁ : CategoryTheory.Functor C₁ D₁) →\n                  (W₁ : CategoryTheory.MorphismProperty C₁) →\n                    [inst_4 : CategoryTheory.Functor.IsLocalization L₁ W₁] →\n                      (L₂ : CategoryTheory.Functor C₂ D₂) →\n                        (W₂ : CategoryTheory.MorphismProperty C₂) →\n                          [inst_5 : CategoryTheory.Functor.IsLocalization L₂ W₂] →\n                            (G : CategoryTheory.Functor C₁ D₂) →\n                              (G' : CategoryTheory.Functor D₁ D₂) →\n                                [inst_6 : CategoryTheory.Localization.Lifting L₁ W₁ G G'] →\n                                  (F : CategoryTheory.Functor C₂ D₁) →\n                                    (F' : CategoryTheory.Functor D₂ D₁) →\n                                      [inst_7 : CategoryTheory.Localization.Lifting L₂ W₂ F F'] →\n                                        (CategoryTheory.Functor.comp G F' ≅ L₁) →\n                                          (CategoryTheory.Functor.comp F G' ≅ L₂) → CategoryTheory.IsEquivalence G'", "name": "CategoryTheory.Localization.isEquivalence", "isProp": false, "docString": "Basic constructor of an equivalence between localized categories ", "terms": "[\n    \"Basic constructor\",\n    \"equivalence\",\n    \"localized categories\"\n]"}
{"type": "∀ {α : Type u} {s : Set α}, Nonempty ↑s ↔ s ≠ ∅", "name": "Set.nonempty_iff_ne_empty'", "isProp": true, "docString": "See also `not_nonempty_iff_eq_empty'`. ", "terms": "[]"}
{"type": "{F : Type u_1} →\n  {K₁ : Type u_3} →\n    {K₂ : Type u_4} →\n      [inst : Field F] →\n        [inst_1 : Field K₁] →\n          [inst_2 : Field K₂] →\n            [inst_3 : Algebra F K₁] →\n              [inst_4 : Algebra F K₂] →\n                (K₁ →ₐ[F] K₂) →\n                  (E : Type u_6) →\n                    [inst_5 : Field E] →\n                      [inst_6 : Algebra F E] →\n                        [inst_7 : Algebra E K₁] →\n                          [inst_8 : Algebra E K₂] →\n                            [inst_9 : IsScalarTower F E K₁] →\n                              [inst_10 : IsScalarTower F E K₂] →\n                                [h : Normal F E] →\n                                  ↥(AlgHom.range (IsScalarTower.toAlgHom F E K₁)) →ₐ[F]\n                                    ↥(AlgHom.range (IsScalarTower.toAlgHom F E K₂))", "name": "AlgHom.restrictNormalAux", "isProp": false, "docString": "Restrict algebra homomorphism to image of normal subfield ", "terms": "[\n    \"Restrict\",\n    \"Algebra\",\n    \"Homomorphism\",\n    \"Image\",\n    \"Normal Subfield\"\n]"}
{"type": "∀ {α : Type u_1} [inst : Monoid α] {a b u : α}, IsUnit u → (a * u ∣ b ↔ a ∣ b)", "name": "IsUnit.mul_right_dvd", "isProp": true, "docString": "In a monoid, an element a divides an element b iff all associates of `a` divide `b`.", "terms": "[\n    \"monoid\",\n    \"element\",\n    \"divides\",\n    \"associates\"\n]"}
{"type": "∀ (l : List ℕ) (n : ℕ), List.Sorted (fun x x_1 => x ≤ x_1) (Denumerable.raise l n)", "name": "Denumerable.raise_sorted", "isProp": true, "docString": "`raise l n` is a non-decreasing sequence. ", "terms": "[\"raise\", \"non-decreasing sequence\"]"}
{"type": "{α : Sort u_1} → [inst : IsEmpty α] → (β : α → Sort v) → Unique ((a : α) → β a)", "name": "Pi.uniqueOfIsEmpty", "isProp": false, "docString": "There is a unique function on an empty domain. ", "terms": "[\n    \"unique\",\n    \"function\",\n    \"empty\",\n    \"domain\"\n]"}
{"type": "∀ (n p : ℕ),\n  (Finset.sum (Finset.range n) fun k => ↑k ^ p) =\n    Finset.sum (Finset.range (p + 1)) fun i => bernoulli i * ↑(Nat.choose (p + 1) i) * ↑n ^ (p + 1 - i) / (↑p + 1)", "name": "sum_range_pow", "isProp": true, "docString": "**Faulhaber's theorem** relating the **sum of p-th powers** to the Bernoulli numbers:\n$$\\sum_{k=0}^{n-1} k^p = \\sum_{i=0}^p B_i\\binom{p+1}{i}\\frac{n^{p+1-i}}{p+1}.$$\nSee https://proofwiki.org/wiki/Faulhaber%27s_Formula and [orosi2018faulhaber] for\nthe proof provided here. ", "terms": "[\n    \"Faulhaber's theorem\",\n    \"sum of p-th powers\",\n    \"Bernoulli numbers\",\n    \"sum\",\n    \"binomial coefficient\",\n    \"power\"\n]"}
{"type": "Bool → PosNum → PosNum", "name": "PosNum.bit", "isProp": false, "docString": "`bit b n` appends the bit `b` to the end of `n`, where `bit tt x = x1` and `bit ff x = x0`. ", "terms": "[\"bit\", \"append\", \"end\", \"bit tt\", \"bit ff\"]"}
{"type": "∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] (self : CategoryTheory.Coverage C) ⦃X Y : C⦄ (f : Y ⟶ X),\n  ∀ S ∈ CategoryTheory.Coverage.covering self X,\n    ∃ T ∈ CategoryTheory.Coverage.covering self Y, CategoryTheory.Presieve.FactorsThruAlong T S f", "name": "CategoryTheory.Coverage.pullback", "isProp": true, "docString": "Given any covering sieve `S` on `X` and a morphism `f : Y ⟶ X`, there exists\nsome covering sieve `T` on `Y` such that `T` factors through `S` along `f`. ", "terms": "[\n    \"covering sieve\",\n    \"morphism\",\n    \"factors through\"\n]"}
{"type": "{Ω : Type u_1} →\n  (m' : MeasurableSpace Ω) →\n    [mΩ : MeasurableSpace Ω] →\n      [inst : StandardBorelSpace Ω] →\n        [inst : Nonempty Ω] →\n          m' ≤ mΩ →\n            {β : Type u_3} →\n              {γ : Type u_4} →\n                [inst : MeasurableSpace β] →\n                  [inst : MeasurableSpace γ] →\n                    (Ω → β) →\n                      (Ω → γ) →\n                        (μ : autoParam (MeasureTheory.Measure Ω) _auto✝) →\n                          [inst : MeasureTheory.IsFiniteMeasure μ] → Prop", "name": "ProbabilityTheory.CondIndepFun", "isProp": false, "docString": "Two functions are conditionally independent if the two measurable space structures they generate\nare conditionally independent. For a function `f` with codomain having measurable space structure\n`m`, the generated measurable space structure is `m.comap f`.\nSee `ProbabilityTheory.condIndepFun_iff`. ", "terms": "[\n  \"functions\",\n  \"conditionally independent\",\n  \"measurable space structures\",\n  \"generate\",\n  \"codomain\",\n  \"measurable space structure\",\n  \"comap\",\n  \"ProbabilityTheory.condIndepFun_iff\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} [inst : MulOneClass α] [inst_1 : MulOneClass β] {f : α → β}, IsMonoidHom f → f 1 = 1", "name": "IsMonoidHom.map_one", "isProp": true, "docString": "The proposition that `f` preserves the multiplicative identity. ", "terms": "[\n  \"Proposition\",\n  \"Preserves\",\n  \"Multiplicative Identity\"\n]"}
{"type": "∀ {R : Type u_1} {M : Type u_2} [inst : AddMonoid M] [inst_1 : CommSemiring R] {S : Set M},\n  AddSubmonoid.closure S = ⊤ → Function.Surjective ⇑((FreeAlgebra.lift R) fun s => AddMonoidAlgebra.of' R M ↑s)", "name": "AddMonoidAlgebra.freeAlgebra_lift_of_surjective_of_closure", "isProp": true, "docString": "If a set `S` generates an additive monoid `M`, then the image of `M` generates, as algebra,\n`R[M]`. ", "terms": "[\n    \"Set\",\n    \"Generates\",\n    \"Additive Monoid\",\n    \"Image\",\n    \"Algebra\"\n]"}
{"type": "∀ {α : Type u_1} [inst : LinearOrder α] {s : Finset α} {k : ℕ} (h : Finset.card s = k) {f : Fin k → α},\n  (∀ (x : Fin k), f x ∈ s) → StrictMono f → f = ⇑(Finset.orderEmbOfFin s h)", "name": "Finset.orderEmbOfFin_unique", "isProp": true, "docString": "Any increasing map `f` from `Fin k` to a finset of cardinality `k` has to coincide with\nthe increasing bijection `orderEmbOfFin s h`. ", "terms": "[\n    \"increasing map\",\n    \"Fin k\",\n    \"finset\",\n    \"cardinality\",\n    \"coincide\",\n    \"increasing bijection\",\n    \"orderEmbOfFin\"\n]"}
{"type": "∀ {R : Type u} [inst : CommRing R] {S : Type v} [inst_1 : CommRing S] (p : Ideal R) [inst_2 : IsDomain S]\n  [inst_3 : IsDedekindDomain S] [inst_4 : Algebra R S] (K : Type u_1) (L : Type u_2) [inst_5 : Field K]\n  [inst_6 : Field L] [inst_7 : IsDomain R] [inst_8 : IsDedekindDomain R] [inst_9 : Algebra R K]\n  [inst_10 : IsFractionRing R K] [inst_11 : Algebra S L] [inst_12 : IsFractionRing S L] [inst_13 : Algebra K L]\n  [inst_14 : Algebra R L] [inst_15 : IsScalarTower R S L] [inst_16 : IsScalarTower R K L] [inst_17 : IsNoetherian R S]\n  [inst_18 : IsIntegralClosure S R L] [inst_19 : Ideal.IsMaximal p],\n  p ≠ ⊥ →\n    (Finset.sum (Multiset.toFinset (UniqueFactorizationMonoid.factors (Ideal.map (algebraMap R S) p))) fun P =>\n        Ideal.ramificationIdx (algebraMap R S) p P * Ideal.inertiaDeg (algebraMap R S) p P) =\n      FiniteDimensional.finrank K L", "name": "Ideal.sum_ramification_inertia", "isProp": true, "docString": "The **fundamental identity** of ramification index `e` and inertia degree `f`:\nfor `P` ranging over the primes lying over `p`, `∑ P, e P * f P = [Frac(S) : Frac(R)]`;\nhere `S` is a finite `R`-module (and thus `Frac(S) : Frac(R)` is a finite extension) and `p`\nis maximal.\n", "terms": "[\n    \"fundamental identity\",\n    \"ramification index\",\n    \"inertia degree\",\n    \"primes\",\n    \"lying over\",\n    \"finite\",\n    \"module\",\n    \"finite extension\",\n    \"maximal\"\n]"}
{"type": "∀ (𝕜 : Type u_1) (E : Type u_3) [inst : NontriviallyNormedField 𝕜] [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E], Bornology.vonNBornology 𝕜 E = PseudoMetricSpace.toBornology", "name": "NormedSpace.vonNBornology_eq", "isProp": true, "docString": "In a normed space, the von Neumann bornology (`Bornology.vonNBornology`) is equal to the\nmetric bornology. ", "terms": "[\n    \"normed space\",\n    \"von Neumann bornology\",\n    \"metric bornology\",\n    \"equal\"\n]"}
{"type": "{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : Ring R] →\n      [inst_1 : AddCommGroup M] → [inst_2 : Module R M] → (p p' : Submodule R M) → p = p' → (M ⧸ p) ≃ₗ[R] M ⧸ p'", "name": "Submodule.quotEquivOfEq", "isProp": false, "docString": "Quotienting by equal submodules gives linearly equivalent quotients. ", "terms": "[\n    \"Quotienting\",\n    \"equal\",\n    \"submodules\",\n    \"gives\",\n    \"linearly\",\n    \"equivalent\",\n    \"quotients\"\n]"}
{"type": "∀ {𝕜 : Type u_3} [inst : Field 𝕜] {r : ℕ} (M : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) (i : Fin r ⊕ Unit),\n  (List.prod (Matrix.Pivot.listTransvecCol M) * M) (Sum.inr ()) i = M (Sum.inr ()) i", "name": "Matrix.Pivot.listTransvecCol_mul_last_row", "isProp": true, "docString": "Multiplying by all the matrices in `listTransvecCol M` does not change the last row. ", "terms": "[\"Multiplying\", \"matrices\", \"listTransvecCol\", \"does not change\", \"last row\"]"}
{"type": "{α : Type u_1} →\n  {m : MeasurableSpace α} →\n    {M : Type u_4} →\n      {N : Type u_5} →\n        [inst : AddCommMonoid M] →\n          [inst_1 : TopologicalSpace M] →\n            [inst_2 : AddCommMonoid N] →\n              [inst_3 : TopologicalSpace N] → MeasureTheory.VectorMeasure α M → MeasureTheory.VectorMeasure α N → Prop", "name": "MeasureTheory.VectorMeasure.AbsolutelyContinuous", "isProp": false, "docString": "A vector measure `v` is absolutely continuous with respect to a measure `μ` if for all sets\n`s`, `μ s = 0`, we have `v s = 0`. ", "terms": "[\n    \"Vector Measure\",\n    \"Absolutely Continuous\",\n    \"Measure\",\n    \"Sets\"\n]"}
{"type": "∀ {R : Type u_1} [inst : CommSemiring R] {M : Submonoid R} {S : Type u_2} [inst_1 : CommSemiring S]\n  [inst_2 : Algebra R S] [self : IsLocalization M S] (z : S), ∃ x, z * (algebraMap R S) ↑x.2 = (algebraMap R S) x.1", "name": "IsLocalization.surj'", "isProp": true, "docString": "The `algebraMap` is surjective ", "terms": "[\n    \"algebraMap\",\n    \"surjective\"\n]"}
{"type": "∀ {α : Type u_1} {l : List α}, 0 < List.length l → l ≠ []", "name": "List.ne_nil_of_length_pos", "isProp": true, "docString": "**Alias** of the forward direction of `List.length_pos`.", "terms": "[\"Alias\", \"forward direction\", \"List.length_pos\"]"}
{"type": "(α : Sort u_1) → [s : Setoid α] → Quotient s ↪ α", "name": "Function.Embedding.quotientOut", "isProp": false, "docString": "`Quotient.out` as an embedding. ", "terms": "[\"Quotient\", \"embedding\"]"}
{"type": "{α : Type u_6} → [inst : DecidableEq α] → [inst : AddMonoid α] → {s : Finset α} → Decidable (AddSalemSpencer ↑s)", "name": "instDecidableAddSalemSpencerToSet", "isProp": false, "docString": "Whether a given finset is Salem-Spencer is decidable.", "terms": "[\"finset\", \"Salem-Spencer\", \"decidable\"]"}
{"type": "{ι : Type u_1} →\n  {𝕜 : Type u_3} → [inst : IsROrC 𝕜] → [inst_1 : Fintype ι] → [inst_2 : DecidableEq ι] → ι → 𝕜 → EuclideanSpace 𝕜 ι", "name": "EuclideanSpace.single", "isProp": false, "docString": "The vector given in euclidean space by being `1 : 𝕜` at coordinate `i : ι` and `0 : 𝕜` at\nall other coordinates. ", "terms": "[\n    \"vector\",\n    \"euclidean space\",\n    \"coordinate\"\n]"}
{"type": "∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} {f : J → (X ⟶ Y)} [inst_1 : Nonempty J]\n  {t : CategoryTheory.Limits.Cotrident f} {Z Z' : C} (q : Z ⟶ Z') (ht : CategoryTheory.Limits.IsColimit t)\n  (k : t.pt ⟶ Z),\n  ↑((CategoryTheory.Limits.Cotrident.IsColimit.homIso ht Z') (CategoryTheory.CategoryStruct.comp k q)) =\n    CategoryTheory.CategoryStruct.comp (↑((CategoryTheory.Limits.Cotrident.IsColimit.homIso ht Z) k)) q", "name": "CategoryTheory.Limits.Cotrident.IsColimit.homIso_natural", "isProp": true, "docString": "The bijection of `Cotrident.IsColimit.homIso` is natural in `Z`. ", "terms": "[\n  \"Bijection\",\n  \"Cotrident.IsColimit.homIso\",\n  \"Natural\",\n  \"Z\"\n]"}
{"type": "∀ {R : Type u} {M : Type v} {N : Type w} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] [inst_4 : AddCommGroup N] [inst_5 : Module R N] (f : M →ₗ[R] N) (p : Submodule R M)\n  [inst_6 : Module.Finite R ↥p], FiniteDimensional.finrank R ↥(Submodule.map f p) ≤ FiniteDimensional.finrank R ↥p", "name": "Submodule.finrank_map_le", "isProp": true, "docString": "Pushforwards of finite submodules have a smaller finrank. ", "terms": "[\n    \"Pushforwards\",\n    \"finite\",\n    \"submodules\",\n    \"smaller\",\n    \"finrank\"\n]"}
{"type": "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : NonAssocRing α], TopologicalSemiring α → TopologicalRing α", "name": "TopologicalSemiring.toTopologicalRing", "isProp": true, "docString": "If `R` is a ring which is a topological semiring, then it is automatically a topological\nring. This exists so that one can place a topological ring structure on `R` without explicitly\nproving `continuous_neg`. ", "terms": "[\n    \"ring\",\n    \"topological semiring\",\n    \"topological ring\",\n    \"ring structure\",\n    \"continuous_neg\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.HasShift C ℤ] →\n      (X₁ X₂ : C) →\n        [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] →\n          [inst_3 : CategoryTheory.Limits.HasBinaryProduct X₁ X₂] → CategoryTheory.Pretriangulated.Triangle C", "name": "CategoryTheory.Pretriangulated.binaryProductTriangle", "isProp": false, "docString": "The obvious triangle `X₁ ⟶ X₁ ⨯ X₂ ⟶ X₂ ⟶ X₁⟦1⟧`. ", "terms": "[\n    \"triangle\",\n    \"Cartesian product\",\n    \"morphism\",\n    \"shift functor\"\n]"}
{"type": "CategoryTheory.Limits.PreservesLimitsOfSize.{v, v, max u v, max u v, max (u + 1) (v + 1), max (u + 1) (v + 1)}\n  (CategoryTheory.forget GroupCatMax)", "name": "GroupCat.forgetPreservesLimitsOfSize", "isProp": false, "docString": "The forgetful functor from groups to types preserves all limits.\n\nThis means the underlying type of a limit can be computed as a limit in the category of types. ", "terms": "[\n    \"forgetful functor\",\n    \"groups\",\n    \"types\",\n    \"preserves\",\n    \"limits\",\n    \"underlying type\",\n    \"computed\",\n    \"category\"\n]"}
{"type": "(R : Type u) →\n  [inst : Semiring R] →\n    {ι : Type v} →\n      {M : ι → Type w} →\n        [inst_1 : (i : ι) → AddCommMonoid (M i)] →\n          [inst_2 : (i : ι) → Module R (M i)] →\n            {κ : Type u_1} → (h : ι ≃ κ) → (DirectSum ι fun i => M i) ≃ₗ[R] DirectSum κ fun k => M (h.symm k)", "name": "DirectSum.lequivCongrLeft", "isProp": false, "docString": "Reindexing terms of a direct sum is linear. ", "terms": "[\n  \"Reindexing\",\n  \"Terms\",\n  \"Direct sum\",\n  \"Linear\"\n]"}
{"type": "∀ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X} (ts : t ⊆ s),\n  instTopologicalSpaceSubtype = TopologicalSpace.induced (Set.inclusion ts) instTopologicalSpaceSubtype", "name": "TopologicalSpace.subset_trans", "isProp": true, "docString": "Let `X` be a topological space and let `s, t ⊆ X` be two subsets.  If there is an inclusion\n`t ⊆ s`, then the topological space structure on `t` induced by `X` is the same as the one\nobtained by the induced topological space structure on `s`. Use `embedding_inclusion` instead. ", "terms": "[\n    \"topological space\",\n    \"subsets\",\n    \"inclusion\",\n    \"induced\",\n    \"embedding_inclusion\"\n]"}
{"type": "∀ (R : Type u_1) [inst : CommRing R] (M : Type u_2) [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M] [inst_4 : Module.Finite R M], LinearMap.trace R M ∘ₗ dualTensorHom R M M = contractLeft R M", "name": "LinearMap.trace_eq_contract", "isProp": true, "docString": "When `M` is finite free, the trace of a linear map correspond to the contraction pairing under\nthe isomorphism `End(M) ≃ M* ⊗ M`", "terms": "[\n    \"finite free\",\n    \"trace\",\n    \"linear map\",\n    \"contraction pairing\",\n    \"isomorphism\",\n    \"End(M)\",\n    \"M*\",\n    \"⊗\"\n]"}
{"type": "∀ {t : ENNReal}, t ≠ ⊤ → Continuous (ENNReal.truncateToReal t)", "name": "ENNReal.continuous_truncateToReal", "isProp": true, "docString": "The truncated cast `ENNReal.truncateToReal t : ℝ≥0∞ → ℝ` is continuous when `t ≠ ∞`. ", "terms": "[\n    \"truncated\",\n    \"cast\",\n    \"ENNReal.truncateToReal\",\n    \"ℝ≥0∞\",\n    \"ℝ\",\n    \"continuous\",\n    \"∞\"\n]"}
{"type": "∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {b : K},\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialDenominators (GeneralizedContinuedFraction.of v)) n = some b →\n    ∃ z, b = ↑z", "name": "GeneralizedContinuedFraction.exists_int_eq_of_part_denom", "isProp": true, "docString": "Shows that the partial denominators `bᵢ` correspond to an integer. ", "terms": "[\"partial denominators\", \"integer\"]"}
{"type": "CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} GroupCatMaxAux", "name": "AddGroupCat.hasLimitsOfSize", "isProp": true, "docString": "The category of additive groups has all limits.", "terms": "[\n    \"category\",\n    \"additive groups\",\n    \"limits\"\n]"}
{"type": "{α : Type u} →\n  [uniformSpace : UniformSpace α] →\n    {f : Filter α} →\n      Cauchy f → {U : ℕ → Set (α × α)} → (∀ (n : ℕ), U n ∈ uniformity α) → (n : ℕ) → { s // s ∈ f ∧ s ×ˢ s ⊆ U n }", "name": "SequentiallyComplete.setSeqAux", "isProp": false, "docString": "An auxiliary sequence of sets approximating a Cauchy filter. ", "terms": "[\n    \"Auxiliary Sequence\",\n    \"Sets\",\n    \"Approximating\",\n    \"Cauchy Filter\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : Preorder β] {a : α} {f : α → β},\n  MonotoneOn f (Set.Iic a) → MonotoneOn f (Set.Ici a) → Monotone f", "name": "MonotoneOn.Iic_union_Ici", "isProp": true, "docString": "If `f` is monotone both on `(-∞, a]` and `[a, ∞)`, then it is monotone on the whole line. ", "terms": "[\n  \"monotone\",\n  \"(-∞, a]\",\n  \"[a, ∞)\",\n  \"whole line\"\n]"}
{"type": "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V) (θ : Real.Angle),\n  Orientation.oangle o ((Orientation.rotation o θ) x) ((Orientation.rotation o θ) y) = Orientation.oangle o x y", "name": "Orientation.oangle_rotation", "isProp": true, "docString": "Rotating both vectors by the same angle does not change the angle between those vectors. ", "terms": "[\"rotating\", \"vectors\", \"angle\", \"change\"]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : CommRing 𝕜] [inst_1 : AddCommGroup E] [inst_2 : AddCommGroup F]\n  [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 F] [inst_5 : TopologicalSpace E] [inst_6 : TopologicalSpace F]\n  [inst_7 : TopologicalAddGroup E] [inst_8 : ContinuousConstSMul 𝕜 E] [inst_9 : TopologicalAddGroup F]\n  [inst_10 : ContinuousConstSMul 𝕜 F] (q : FormalMultilinearSeries 𝕜 E F) (p : FormalMultilinearSeries 𝕜 E E),\n  FormalMultilinearSeries.comp q p 0 = q 0", "name": "FormalMultilinearSeries.comp_coeff_zero''", "isProp": true, "docString": "The `0`-th coefficient of `q.comp p` is `q 0`. When `p` goes from `E` to `E`, this can be\nexpressed as a direct equality ", "terms": "[\n    \"0-th coefficient\",\n    \"q.comp p\",\n    \"q 0\",\n    \"goes from\",\n    \"E to E\",\n    \"expressed\",\n    \"direct equality\"\n]"}
{"type": "{α : Type u_1} → Ordnode α → Ordnode (Ordnode α)", "name": "Ordnode.powerset", "isProp": false, "docString": "O(2^n). Constructs the powerset of a given set, that is, the set of all subsets.\n\npowerset {1, 2, 3} = {∅, {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}} ", "terms": "[\n    \"O(2^n)\",\n    \"Constructs\",\n    \"powerset\",\n    \"given set\",\n    \"set of all subsets\",\n    \"∅\",\n    \"{1}\",\n    \"{2}\",\n    \"{3}\",\n    \"{1,2}\",\n    \"{1,3}\",\n    \"{2,3}\",\n    \"{1,2,3}\"\n]"}
{"type": "(n : ℕ) → Composition n", "name": "Composition.ones", "isProp": false, "docString": "The composition made of blocks all of size `1`. ", "terms": "[]"}
{"type": "{α : Type u} → [inst : BEq α] → List α → List α → List α", "name": "List.removeAll", "isProp": false, "docString": "`O(|xs|)`. Computes the \"set difference\" of lists,\nby filtering out all elements of `xs` which are also in `ys`.\n* `removeAll [1, 1, 5, 1, 2, 4, 5] [1, 2, 2] = [5, 4, 5]`\n ", "terms": "[\"O(|xs|)\", \"set difference\", \"lists\", \"filtering\", \"elements\"]"}
{"type": "{n : ℕ} →\n  {A : Type u} →\n    (F : A → TypeVec.{u} n → Type u) →\n      [inst : (α : A) → MvFunctor (F α)] →\n        [inst_1 : (α : A) → MvQPF (F α)] → ⦃α : TypeVec.{u} n⦄ → ↑(MvQPF.Sigma.P F) α → MvQPF.Sigma F α", "name": "MvQPF.Sigma.abs", "isProp": false, "docString": "abstraction function for dependent sums ", "terms": "[\n    \"abstraction function\",\n    \"dependent sums\"\n]"}
{"type": "∀ {α : Sort u_2} [inst : DecidableEq α] {β : Sort u_1} {v : α → β} {i j : α},\n  v i = v j → ∀ (k : α), v ((Equiv.swap i j) k) = v k", "name": "Equiv.apply_swap_eq_self", "isProp": true, "docString": "A function is invariant to a swap if it is equal at both elements ", "terms": "[\n    \"function\", \n    \"invariant\", \n    \"swap\", \n    \"equal\", \n    \"elements\"\n]"}
{"type": "{α : Type u_1} → {β : Type u_2} → [inst : LE α] → (α → Set β) → α → Set β", "name": "Set.Accumulate", "isProp": false, "docString": "`Accumulate s` is the union of `s y` for `y ≤ x`. ", "terms": "[\n    \"Accumulate\",\n    \"union\",\n    \"less than or equal to\"\n]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {R X Y Z : C} {a b : R ⟶ X} {f₁ : X ⟶ Y} {f₂ : Y ⟶ Z},\n  CategoryTheory.CategoryStruct.comp a f₁ = CategoryTheory.CategoryStruct.comp b f₁ →\n    CategoryTheory.IsKernelPair (CategoryTheory.CategoryStruct.comp f₁ f₂) a b → CategoryTheory.IsKernelPair f₁ a b", "name": "CategoryTheory.IsKernelPair.cancel_right", "isProp": true, "docString": "If `(a,b)` is a kernel pair for `f₁ ≫ f₂` and `a ≫ f₁ = b ≫ f₁`, then `(a,b)` is a kernel pair for\njust `f₁`.\nThat is, to show that `(a,b)` is a kernel pair for `f₁` it suffices to only show the square\ncommutes, rather than to additionally show it's a pullback.\n", "terms": "[\n    \"kernel pair\",\n    \"f₁\",\n    \"f₂\",\n    \"commutes\",\n    \"pullback\"\n]"}
{"type": "{α : Type u_1} → Set α → Semiquot α → Semiquot α", "name": "Semiquot.blur", "isProp": false, "docString": "Replace `s` in a `q : Semiquot α` with a union `s ∪ q.s` ", "terms": "[\n    \"Replace\",\n    \"Semiquot\",\n    \"union\"\n]"}
{"type": "{I : Type u_1} →\n  {J : Type u_2} →\n    {C : Type u_3} →\n      [inst : CategoryTheory.Category.{u_4, u_3} C] →\n        (X : CategoryTheory.GradedObject I C) →\n          (p : I → J) → [inst : CategoryTheory.GradedObject.HasMap X p] → CategoryTheory.GradedObject J C", "name": "CategoryTheory.GradedObject.mapObj", "isProp": false, "docString": "Given `X : GradedObject I C` and `p : I → J`, `X.mapObj p` is the graded object by `J`\nwhich in degree `j` consists of the coproduct of the `X i` such that `p i = j`. ", "terms": "[\n    \"GradedObject\",\n    \"mapObj\",\n    \"graded object\",\n    \"degree\",\n    \"coproduct\"\n]"}
{"type": "(n : ℕ) → (l : Multiset ℕ) → Multiset.sum l = n → Nat.Partition n", "name": "Nat.Partition.ofSums", "isProp": false, "docString": "Given a multiset which sums to `n`, construct a partition of `n` with the same multiset, but\nwithout the zeros.\n", "terms": "[\"multiset\", \"sums\", \"construct\", \"partition\", \"zeros\"]"}
{"type": "{α : Type u_1} →\n  [inst : MeasurableSpace α] →\n    {M : Type u_3} →\n      [inst_1 : AddCommMonoid M] →\n        [inst_2 : TopologicalSpace M] →\n          {N : Type u_4} →\n            [inst_3 : AddCommMonoid N] →\n              [inst_4 : TopologicalSpace N] →\n                {R : Type u_5} →\n                  [inst_5 : Semiring R] →\n                    [inst_6 : Module R M] →\n                      [inst_7 : Module R N] →\n                        [inst_8 : ContinuousAdd M] →\n                          [inst_9 : ContinuousAdd N] →\n                            [inst_10 : ContinuousConstSMul R M] →\n                              [inst_11 : ContinuousConstSMul R N] →\n                                (f : M →ₗ[R] N) →\n                                  Continuous ⇑f → MeasureTheory.VectorMeasure α M →ₗ[R] MeasureTheory.VectorMeasure α N", "name": "MeasureTheory.VectorMeasure.mapRangeₗ", "isProp": false, "docString": "Given a continuous linear map `f : M → N`, `mapRangeₗ` is the linear map mapping the\nvector measure `v` on `M` to the vector measure `f ∘ v` on `N`. ", "terms": "[\n    \"continuous\",\n    \"linear map\",\n    \"mapRangeₗ\",\n    \"vector measure\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : TopologicalSpace β] {f : α → β} {s : Set α},\n  ContinuousOn f s → TopologicalSpace.IsSeparable s → TopologicalSpace.IsSeparable (f '' s)", "name": "ContinuousOn.isSeparable_image", "isProp": true, "docString": "If a map is continuous on a separable set `s`, then the image of `s` is also separable. ", "terms": "[\n    \"map\",\n    \"continuous\",\n    \"separable set\",\n    \"image\"\n]"}
{"type": "∀ {R : Type u_1} [inst : Ring R] {E : Type u_2} [inst_1 : AddCommGroup E] [inst_2 : Module R E] {F : Type u_3}\n  [inst_3 : AddCommGroup F] [inst_4 : Module R F] (f : E →ₗ.[R] F) {x : E} {x' : F},\n  (x, x') ∈ LinearPMap.graph f → x = 0 → x' = 0", "name": "LinearPMap.graph_fst_eq_zero_snd", "isProp": true, "docString": "The property that `f 0 = 0` in terms of the graph. ", "terms": "[\n  \"Property\",\n  \"Function\",\n  \"Graph\"\n]"}
{"type": "{α : Sort u_2} → [h : Nonempty α] → Inhabited α", "name": "Classical.inhabited_of_nonempty'", "isProp": false, "docString": "Using `Classical.choice`, lifts a (`Prop`-valued) `Nonempty` instance to a (`Type`-valued)\n`Inhabited` instance. `Classical.inhabited_of_nonempty` already exists, in\n`Init/Classical.lean`, but the assumption is not a type class argument,\nwhich makes it unsuitable for some applications. ", "terms": "[\n    \"Classical.choice\",\n    \"Prop-valued\",\n    \"Nonempty\",\n    \"Type-valued\",\n    \"Inhabited\",\n    \"Classical.inhabited_of_nonempty\",\n    \"Init/Classical.lean\",\n    \"type class argument\"\n]"}
{"type": "∀ {M : Type u_1} [inst : AddMonoid M] {x : M}, AddMonoid.Closure {x} = multiples x", "name": "AddMonoid.closure_singleton", "isProp": true, "docString": "The `AddSubmonoid` generated by an element of an `AddMonoid` equals the set of\nnatural number multiples of the element.", "terms": "[\n  \"AddSubmonoid\",\n  \"element\",\n  \"AddMonoid\",\n  \"set\",\n  \"natural number\",\n  \"multiples\"\n]"}
{"type": "∀ {α : Type u_1} {r : α → α → Prop} [inst : IsIrrefl α r] {a : α}, Acc r a → Acc (Relation.CutExpand r) {a}", "name": "Acc.cutExpand", "isProp": true, "docString": "A singleton `{a}` is accessible under `CutExpand r` if `a` is accessible under `r`,\nassuming `r` is irreflexive. ", "terms": "[\"singleton\", \"accessible\", \"CutExpand\", \"irreflexive\"]"}
{"type": "{J : Type v} →\n  [inst : CategoryTheory.SmallCategory J] →\n    (F : CategoryTheory.Functor J MonCat) →\n      [inst_1 : CategoryTheory.IsFiltered J] → (j : J) → F.obj j ⟶ MonCat.FilteredColimits.colimit F", "name": "MonCat.FilteredColimits.coconeMorphism", "isProp": false, "docString": "The monoid homomorphism from a given monoid in the diagram to the colimit monoid. ", "terms": "[\n    \"monoid\",\n    \"homomorphism\",\n    \"diagram\",\n    \"colimit\"\n]"}
{"type": "ℂ → ℂ", "name": "Complex.GammaIntegral", "isProp": false, "docString": "Euler's integral for the `Γ` function (of a complex variable `s`), defined as\n`∫ x in Ioi 0, exp (-x) * x ^ (s - 1)`.\n\nSee `Complex.GammaIntegral_convergent` for a proof of the convergence of the integral for\n`0 < re s`. ", "terms": "[\n    \"Euler's integral\",\n    \"Γ function\",\n    \"complex variable\",\n    \"exp\",\n    \"integral\",\n    \"convergence\",\n    \"re\"\n]"}
{"type": "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Ideal.IsPrime (Ideal.span {PowerSeries.X})", "name": "PowerSeries.span_X_isPrime", "isProp": true, "docString": "The ideal spanned by the variable in the power series ring\nover an integral domain is a prime ideal.", "terms": "[\n    \"ideal\",\n    \"spanned\",\n    \"variable\",\n    \"power series ring\",\n    \"integral domain\",\n    \"prime ideal\"\n]"}
{"type": "∀ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {A : Type u_1}\n  [inst_3 : Semiring A] [inst_4 : Algebra R A] {f g : ExteriorAlgebra R M →ₐ[R] A},\n  AlgHom.toLinearMap f ∘ₗ ExteriorAlgebra.ι R = AlgHom.toLinearMap g ∘ₗ ExteriorAlgebra.ι R → f = g", "name": "ExteriorAlgebra.hom_ext", "isProp": true, "docString": "See note [partially-applied ext lemmas]. ", "terms": "The given statement does not contain any mathematical terms. As such, the JSON list representing all mathematical terms in the statement would be an empty list, represented as follows:\n\n    []"}
{"type": "∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M],\n  (∀ (a : Set (Submodule R M)), Set.Nonempty a → ∃ M' ∈ a, ∀ I ∈ a, ¬M' < I) ↔ IsNoetherian R M", "name": "set_has_maximal_iff_noetherian", "isProp": true, "docString": "A module is Noetherian iff every nonempty set of submodules has a maximal submodule among them.\n", "terms": "[\n    \"module\",\n    \"Noetherian\",\n    \"nonempty set\",\n    \"submodules\",\n    \"maximal submodule\"\n]"}
{"type": "{a : Prop} → (b : Bool) → (b = true ↔ a) → Decidable a", "name": "decidable_of_bool", "isProp": false, "docString": "Prove that `a` is decidable by constructing a boolean `b` and a proof that `b ↔ a`.\n(This is sometimes taken as an alternate definition of decidability.) ", "terms": "[\n  \"Decidable\",\n  \"Constructing\",\n  \"Boolean\",\n  \"Proof\",\n  \"Biconditional\",\n  \"Definition\",\n  \"Decidability\"\n]"}
{"type": "∀ {Ω : Type u_1} {m0 : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω} {ℱ : MeasureTheory.Filtration ℕ m0}\n  [inst : MeasureTheory.IsFiniteMeasure μ] (g : Ω → ℝ),\n  ∀ᵐ (x : Ω) ∂μ,\n    Filter.Tendsto (fun n => MeasureTheory.condexp (↑ℱ n) μ g x) Filter.atTop\n      (nhds (MeasureTheory.condexp (⨆ n, ↑ℱ n) μ g x))", "name": "MeasureTheory.tendsto_ae_condexp", "isProp": true, "docString": "**Lévy's upward theorem**, almost everywhere version: given a function `g` and a filtration\n`ℱ`, the sequence defined by `𝔼[g | ℱ n]` converges almost everywhere to `𝔼[g | ⨆ n, ℱ n]`. ", "terms": "[\n  \"Lévy's upward theorem\",\n  \"function\",\n  \"filtration\",\n  \"sequence\",\n  \"almost everywhere\",\n  \"converges\",\n  \"expectation\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_3} {F : Type u_4} [inst : OrderedRing 𝕜] [inst_1 : TopologicalSpace E]\n  [inst_2 : TopologicalSpace F] [inst_3 : AddCommGroup E] [inst_4 : AddCommGroup F] [inst_5 : Module 𝕜 E]\n  [inst_6 : Module 𝕜 F] {s : Set E}, StrictConvex 𝕜 s → ∀ {f : E →ᵃ[𝕜] F}, IsOpenMap ⇑f → StrictConvex 𝕜 (⇑f '' s)", "name": "StrictConvex.affine_image", "isProp": true, "docString": "The image of a strictly convex set under an affine map is strictly convex. ", "terms": "[\n    \"Image\",\n    \"Strictly Convex Set\",\n    \"Affine Map\",\n    \"Strictly Convex\"\n]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {P : CategoryTheory.Functor Cᵒᵖ (Type w)} {X : C}\n  {R : CategoryTheory.Presieve X}, CategoryTheory.Presieve.IsSheafFor P R → CategoryTheory.Presieve.IsSeparatedFor P R", "name": "CategoryTheory.Presieve.IsSheafFor.isSeparatedFor", "isProp": true, "docString": "If `P` is a sheaf for `R`, it is separated for `R`. ", "terms": "[\n    \"Sheaf\",\n    \"Separated\"\n]"}
{"type": "∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Metric.hausdorffDist s ∅ = 0", "name": "Metric.hausdorffDist_empty", "isProp": true, "docString": "The Hausdorff distance to the empty set vanishes (if you want to have the more reasonable\nvalue ∞ instead, use `EMetric.hausdorffEdist`, which takes values in ℝ≥0∞) ", "terms": "[\n    \"Hausdorff distance\",\n    \"empty set\",\n    \"vanishes\",\n    \"value\",\n    \"EMetric.hausdorffEdist\",\n    \"values\",\n    \"ℝ≥0∞\"\n]"}
{"type": "{L : FirstOrder.Language} →\n  {α : Type u'} →\n    {γ : Type u_3} →\n      {n : ℕ} →\n        FirstOrder.Language.BoundedFormula (FirstOrder.Language.withConstants L γ) α n ≃\n          FirstOrder.Language.BoundedFormula L (γ ⊕ α) n", "name": "FirstOrder.Language.BoundedFormula.constantsVarsEquiv", "isProp": false, "docString": "A bijection sending formulas with constants to formulas with extra variables. ", "terms": "[\n    \"Bijection\",\n    \"Formulas\",\n    \"Constants\",\n    \"Variables\"\n]"}
{"type": "{α : Type u} → α → Stream'.Seq α → Stream'.Seq α", "name": "Stream'.Seq.cons", "isProp": false, "docString": "Prepend an element to a sequence ", "terms": "[\n    \"Prepend\",\n    \"Element\",\n    \"Sequence\"\n]"}
{"type": "{R : Type u} →\n  {A : Type v} →\n    {B : Type w} →\n      [inst : CommSemiring R] →\n        [inst_1 : NonUnitalSemiring A] →\n          [inst_2 : StarRing A] →\n            [inst_3 : Module R A] →\n              [inst_4 : NonUnitalSemiring B] →\n                [inst_5 : StarRing B] →\n                  [inst_6 : Module R B] →\n                    NonUnitalStarSubalgebra R A → NonUnitalStarSubalgebra R B → NonUnitalStarSubalgebra R (A × B)", "name": "NonUnitalStarSubalgebra.prod", "isProp": false, "docString": "The product of two non-unital star subalgebras is a non-unital star subalgebra. ", "terms": "[\n    \"product\",\n    \"two\",\n    \"non-unital\",\n    \"star subalgebras\",\n    \"is\",\n    \"a\"\n]"}
{"type": "(R : Type u) → {A : Type v} → [inst : CommSemiring R] → [inst_1 : Ring A] → [inst : Algebra R A] → A → Set R", "name": "spectrum", "isProp": false, "docString": "Given a commutative ring `R` and an `R`-algebra `A`, the *spectrum* of `a : A`\nis the `Set R` consisting of those `r : R` for which `r•1 - a` is not a unit of the\nalgebra `A`.\n\nThe spectrum is simply the complement of the resolvent set.  ", "terms": "[\n  \"Commutative ring\",\n  \"Algebra\",\n  \"Spectrum\",\n  \"Set\",\n  \"Unit of the algebra\",\n  \"Complement\",\n  \"Resolvent set\"\n]"}
{"type": "∀ {m x y : Bool}, (x && m) = (y && m) ∧ (x || m) = (y || m) ↔ x = y", "name": "Bool.and_or_inj_right'", "isProp": true, "docString": "**Alias** of `Bool.and_or_inj_right_iff`.", "terms": "[\"Alias\", \"Bool.and_or_inj_right_iff\"]"}
{"type": "{α : Type u_1} → {n n' : ℕ} → Sym α n → Sym α n' → Sym α (n + n')", "name": "Sym.append", "isProp": false, "docString": "Append a pair of `Sym` terms. ", "terms": "[\"Append\", \"Pair\", \"Sym\"]"}
{"type": "{β : Sort v} → (β → β → Prop) → Prop", "name": "Total", "isProp": false, "docString": "A relation is total if for all `x` and `y`, either `x ≺ y` or `y ≺ x`. ", "terms": "[\n    \"relation\",\n    \"total\"\n]"}
{"type": "∀ {α : Type u_1} {M : Type u_5} [inst : AddCommMonoid M] {f : α → M} {a : α} {s : Set α},\n  (a ∉ s → f a = 0) → (finsum fun i => finsum fun h => f i) = finsum fun i => finsum fun h => f i", "name": "finsum_mem_insert_of_eq_zero_if_not_mem", "isProp": true, "docString": "If `f a = 0` when `a ∉ s`, then the sum of `f i` over `i ∈ insert a s` equals the sum\nof `f i` over `i ∈ s`.", "terms": "[\n    \"function\",\n    \"equals\",\n    \"sum\",\n    \"insert\",\n    \"set\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Preadditive C] → CochainComplex C ℤ → CochainComplex C ℤ → ℤ → Type v", "name": "CochainComplex.HomComplex.Cochain", "isProp": false, "docString": "A cochain of degree `n : ℤ` between to cochain complexes `F` and `G` consists\nof a family of morphisms `F.X p ⟶ G.X q` whenever `p + n = q`, i.e. for all\ntriplets in `HomComplex.Triplet n`. ", "terms": "[\n    \"cochain\",\n    \"degree\",\n    \"ℤ\",\n    \"cochain complexes\",\n    \"family of morphisms\",\n    \"HomComplex.Triplet\"\n]"}
{"type": "{α : Type u_1} →\n  {β : Type u_2} →\n    {δ : Type u_3} →\n      [inst : AddZeroClass δ] → [inst : Min δ] → Levenshtein.Cost α β δ → List α → List β → { r // 0 < List.length r }", "name": "suffixLevenshtein", "isProp": false, "docString": "`suffixLevenshtein C xs ys` computes the Levenshtein distance\n(using the cost functions provided by a `C : Cost α β δ`)\nfrom each suffix of the list `xs` to the list `ys`.\n\nThe first element of this list is the Levenshtein distance from `xs` to `ys`.\n\nNote that if the cost functions do not satisfy the inequalities\n* `C.delete a + C.insert b ≥ C.substitute a b`\n* `C.substitute a b + C.substitute b c ≥ C.substitute a c`\n(or if any values are negative)\nthen the edit distances calculated here may not agree with the general\ngeodesic distance on the edit graph.\n", "terms": "[\n\"Levenshtein distance\",\n\"cost functions\",\n\"suffix\",\n\"list\",\n\"element\",\n\"inequalities\",\n\"delete\",\n\"insert\",\n\"substitute\",\n\"negative\",\n\"edit distances\",\n\"geodesic distance\",\n\"edit graph\"\n]"}
{"type": "{α : Type u_1} → {β : Type u_2} → {M : Type u_5} → [inst : AddCommMonoid M] → (α → β) → (α →₀ M) → β →₀ M", "name": "Finsupp.mapDomain", "isProp": false, "docString": "Given `f : α → β` and `v : α →₀ M`, `mapDomain f v : β →₀ M`\nis the finitely supported function whose value at `a : β` is the sum\nof `v x` over all `x` such that `f x = a`. ", "terms": "[\n    \"function\",\n    \"finitely supported function\",\n    \"value\",\n    \"sum\",\n    \"mapDomain\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    (X : C) →\n      CategoryTheory.MonoOver.map (CategoryTheory.CategoryStruct.id X) ≅\n        CategoryTheory.Functor.id (CategoryTheory.MonoOver X)", "name": "CategoryTheory.MonoOver.mapId", "isProp": false, "docString": "`MonoOver.map` preserves the identity (up to a natural isomorphism). ", "terms": "[\n  \"MonoOver.map\",\n  \"preserves\",\n  \"identity\",\n  \"natural isomorphism\"\n]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] (s : AffineSubspace ℝ P) [inst_4 : Nonempty ↥s]\n  [inst_5 : HasOrthogonalProjection (AffineSubspace.direction s)] (p₁ p₂ : P),\n  dist p₁ ((EuclideanGeometry.reflection s) p₂) = dist ((EuclideanGeometry.reflection s) p₁) p₂", "name": "EuclideanGeometry.dist_reflection", "isProp": true, "docString": "The distance between `p₁` and the reflection of `p₂` equals that\nbetween the reflection of `p₁` and `p₂`. ", "terms": "[\n    \"distance\",\n    \"reflection\",\n    \"equals\",\n    \"between\"\n]"}
{"type": "∀ {M : Type u_3} {N : Type u_4} [inst : Mul M] [inst_1 : Mul N] {f g : M →ₙ* N}, f = g → ∀ (x : M), f x = g x", "name": "MulHom.congr_fun", "isProp": true, "docString": "Deprecated: use `FunLike.congr_fun` instead. ", "terms": "[]"}
{"type": "Lean.TrailingParserDescr", "name": "Asymptotics.«term_=o[_]_»", "isProp": false, "docString": "The Landau notation `f =o[l] g` where `f` and `g` are two functions on a type `α` and `l` is\na filter on `α`, means that eventually for `l`, `‖f‖` is bounded by an arbitrarily small constant\nmultiple of `‖g‖`. In other words, `‖f‖ / ‖g‖` tends to `0` along `l`, modulo division by zero\nissues that are avoided by this definition. ", "terms": "[\n    \"Landau notation\",\n    \"functions\",\n    \"type\",\n    \"filter\",\n    \"eventually\",\n    \"bounded\",\n    \"arbitrarily small constant\",\n    \"multiple\",\n    \"tends to\",\n    \"modulo\",\n    \"division by zero\",\n    \"definition\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {J : Type w} →\n          [inst_2 : CategoryTheory.Category.{w', w} J] →\n            (K : CategoryTheory.Functor J C) →\n              (F : CategoryTheory.Functor C D) →\n                [inst_3 : CategoryTheory.CreatesLimit K F] →\n                  (c : CategoryTheory.Limits.Cone (CategoryTheory.Functor.comp K F)) →\n                    (t : CategoryTheory.Limits.IsLimit c) → Inhabited (CategoryTheory.LiftsToLimit K F c t)", "name": "CategoryTheory.inhabitedLiftsToLimit", "isProp": false, "docString": "Satisfy the inhabited linter ", "terms": "[]"}
{"type": "∀ (f f' : ℝ → ℝ) {a b : ℝ},\n  a < b →\n    ∀ (g g' : ℝ → ℝ) {lfa lga lfb lgb : ℝ},\n      (∀ x ∈ Set.Ioo a b, HasDerivAt f (f' x) x) →\n        (∀ x ∈ Set.Ioo a b, HasDerivAt g (g' x) x) →\n          Filter.Tendsto f (nhdsWithin a (Set.Ioi a)) (nhds lfa) →\n            Filter.Tendsto g (nhdsWithin a (Set.Ioi a)) (nhds lga) →\n              Filter.Tendsto f (nhdsWithin b (Set.Iio b)) (nhds lfb) →\n                Filter.Tendsto g (nhdsWithin b (Set.Iio b)) (nhds lgb) →\n                  ∃ c ∈ Set.Ioo a b, (lgb - lga) * f' c = (lfb - lfa) * g' c", "name": "exists_ratio_hasDerivAt_eq_ratio_slope'", "isProp": true, "docString": "Cauchy's **Mean Value Theorem**, extended `HasDerivAt` version. ", "terms": "[\n    \"Cauchy's Mean Value Theorem\",\n    \"HasDerivAt\"\n]"}
{"type": "{α : Type u_1} → {β : Type u_2} → List α → List β → List (α × Option β)", "name": "List.zipLeft", "isProp": false, "docString": "Left-biased version of `List.zip`. `zipLeft as bs` returns the list of pairs\n`(aᵢ, bᵢ)` for `aᵢ ∈ as` and `bᵢ ∈ bs`. If `bs` is shorter than `as`, the\nremaining `aᵢ` are paired with `none`.\n```\nzipLeft [1, 2] ['a'] = [(1, some 'a'), (2, none)]\nzipLeft [1] ['a', 'b'] = [(1, some 'a')]\nzipLeft = zipWithLeft prod.mk\n```\n", "terms": "[\"List.zip\", \"list\", \"pairs\", \"shorter\", \"paired\", \"none\", \"some\", \"zipWithLeft\", \"prod.mk\"]"}
{"type": "{ι : Type u_1} → {I : BoxIntegral.Box ι} → BoxIntegral.TaggedPrepartition I → [inst : Fintype ι] → NNReal", "name": "BoxIntegral.TaggedPrepartition.distortion", "isProp": false, "docString": "The distortion of a tagged prepartition is the maximum of distortions of its boxes. ", "terms": "[\n    \"distortion\",\n    \"tagged prepartition\",\n    \"maximum\",\n    \"boxes\"\n]"}
{"type": "{α : Type u_1} → {β : Type u_2} → (α → β) → Set α → Set β → Prop", "name": "Set.SurjOn", "isProp": false, "docString": "`f` is surjective from `a` to `b` if `b` is contained in the image of `a`. ", "terms": "[\n    \"surjective\",\n    \"contained\",\n    \"image\"\n]"}
{"type": "{M : Type u_1} → [inst : MulOneClass M] → CompleteLattice (Submonoid M)", "name": "Submonoid.instCompleteLatticeSubmonoid", "isProp": false, "docString": "Submonoids of a monoid form a complete lattice. ", "terms": "[\n    \"Submonoids\",\n    \"Monoid\",\n    \"Complete Lattice\"\n]"}
{"type": "∀ {p : ℕ+} {k : ℕ} {K : Type u} [inst : Field K] [inst_1 : CharZero K] {ζ : K} [hp : Fact (Nat.Prime ↑p)]\n  [inst_2 : IsCyclotomicExtension {p ^ (k + 1)} ℚ K] (hζ : IsPrimitiveRoot ζ ↑(p ^ (k + 1))),\n  Prime (IsPrimitiveRoot.toInteger hζ - 1)", "name": "IsPrimitiveRoot.zeta_sub_one_prime", "isProp": true, "docString": "`ζ - 1` is prime if `ζ` is a primitive `p ^ (k + 1)`-th root of unity. ", "terms": "[\n  \"prime\",\n  \"primitive\",\n  \"root of unity\"\n]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (J₁ : CategoryTheory.GrothendieckTopology C) {X : C}\n  (S : CategoryTheory.Sieve X), S ≤ CategoryTheory.GrothendieckTopology.close J₁ S", "name": "CategoryTheory.GrothendieckTopology.le_close", "isProp": true, "docString": "Any sieve is smaller than its closure. ", "terms": "[\"sieve\", \"smaller\", \"closure\"]"}
{"type": "∀ {K : Type u} [inst : Field K] (s : Subfield K) {l : List K}, (∀ x ∈ l, x ∈ s) → List.prod l ∈ s", "name": "Subfield.list_prod_mem", "isProp": true, "docString": "Product of a list of elements in a subfield is in the subfield. ", "terms": "[\n    \"Product\",\n    \"List of elements\",\n    \"Subfield\"\n]"}
{"type": "{α : Type u} → Array α → Array α → Array α", "name": "Array.appendCore", "isProp": false, "docString": "Slower `Array.append` used in quotations. ", "terms": "[]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      {K : Type} →\n        [inst_2 : Fintype K] →\n          [inst_3 : CategoryTheory.Limits.HasFiniteBiproducts C] →\n            (f : K → C) →\n              (p : Set K) →\n                CategoryTheory.Limits.kernel (CategoryTheory.Limits.biproduct.toSubtype f p) ≅ ⨁ Subtype.restrict pᶜ f", "name": "CategoryTheory.Limits.kernelBiproductToSubtypeIso", "isProp": false, "docString": "The kernel of `biproduct.toSubtype f p` is `⨁ Subtype.restrict pᶜ f`. ", "terms": "[\n    \"kernel\",\n    \"biproduct\",\n    \"toSubtype\",\n    \"Subtype\",\n    \"restrict\"\n]"}
{"type": "(𝕜 : Type u_1) →\n  {V : Type u_2} →\n    {P : Type u_8} →\n      [inst : NormedField 𝕜] →\n        [inst_1 : SeminormedAddCommGroup V] →\n          [inst_2 : NormedSpace 𝕜 V] → [inst_3 : PseudoMetricSpace P] → [inst_4 : NormedAddTorsor V P] → P → P ≃ᵃⁱ[𝕜] P", "name": "AffineIsometryEquiv.pointReflection", "isProp": false, "docString": "Point reflection in `x` as an affine isometric automorphism. ", "terms": "[\n  \"Point reflection\",\n  \"Affine\",\n  \"Isometric\",\n  \"Automorphism\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : Preorder β] {a : α} {f : α → β},\n  StrictMonoOn f (Set.Iic a) → StrictMonoOn f (Set.Ici a) → StrictMono f", "name": "StrictMonoOn.Iic_union_Ici", "isProp": true, "docString": "If `f` is strictly monotone both on `(-∞, a]` and `[a, ∞)`, then it is strictly monotone on the\nwhole line. ", "terms": "[\"strictly monotone\", \"(-∞, a]\", \"[a, ∞)\", \"whole line\"]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        (G : CategoryTheory.Functor C D) →\n          [inst_2 : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Functor.empty C) G] →\n            CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) G", "name": "CategoryTheory.Limits.preservesLimitsOfShapePemptyOfPreservesTerminal", "isProp": false, "docString": "Preserving the terminal object implies preserving all limits of the empty diagram. ", "terms": "[\n    \"Preserving\",\n    \"terminal object\",\n    \"implies\",\n    \"preserving\",\n    \"all\",\n    \"limits\",\n    \"empty diagram\"\n]"}
{"type": "∀ {R : Type u} {S : Type v} [inst : NonUnitalNonAssocRing R] [inst_1 : NonUnitalNonAssocRing S] {f g : R →ₙ+* S}\n  {s : Set R}, Set.EqOn (⇑f) (⇑g) s → Set.EqOn ⇑f ⇑g ↑(NonUnitalSubring.closure s)", "name": "NonUnitalRingHom.eqOn_set_closure", "isProp": true, "docString": "If two ring homomorphisms are equal on a set, then they are equal on its\n`NonUnitalSubring` closure. ", "terms": "[\n    \"ring homomorphisms\",\n    \"equal\",\n    \"set\",\n    \"NonUnitalSubring\",\n    \"closure\"\n]"}
{"type": "∀ {G : Type u_3} [inst : CommGroup G] (K : Subgroup G) (g : Multiset G), (∀ a ∈ g, a ∈ K) → Multiset.prod g ∈ K", "name": "Subgroup.multiset_prod_mem", "isProp": true, "docString": "Product of a multiset of elements in a subgroup of a `CommGroup` is in the subgroup. ", "terms": "[\n    \"Product\",\n    \"multiset\",\n    \"elements\",\n    \"subgroup\",\n    \"CommGroup\"\n]"}
{"type": "∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} {x : α} {U : Set α},\n  AccPt x (Filter.principal C) → U ∈ nhds x → AccPt x (Filter.principal (U ∩ C))", "name": "AccPt.nhds_inter", "isProp": true, "docString": "If `x` is an accumulation point of a set `C` and `U` is a neighborhood of `x`,\nthen `x` is an accumulation point of `U ∩ C`. ", "terms": "[\n  \"accumulation point\",\n  \"set\",\n  \"neighborhood\",\n  \"intersection\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] → {P Q : C} → {S T : D} → (P ≅ Q) → (S ≅ T) → ((P, S) ≅ (Q, T))", "name": "CategoryTheory.Iso.prod", "isProp": false, "docString": "Construct an isomorphism in `C × D` out of two isomorphisms in `C` and `D`. ", "terms": "[\"Construct\", \"isomorphism\", \"out of\", \"two\", \"isomorphisms\"]"}
{"type": "∀ {𝕜 : Type u_3} {E : Type u_7} [inst : NormedField 𝕜] [inst_1 : SeminormedAddCommGroup E] [inst_2 : NormedSpace 𝕜 E]\n  {r : ℝ} {x : E}, ‖x‖ < r → Absorbent 𝕜 (Metric.ball x r)", "name": "absorbent_ball", "isProp": true, "docString": "Balls containing the origin are absorbent. ", "terms": "[\"Balls\", \"origin\", \"absorbent\"]"}
{"type": "∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {x y : α} {t : Set α},\n  x ∈ s → y ∈ t → Metric.diam (s ∪ t) ≤ Metric.diam s + dist x y + Metric.diam t", "name": "Metric.diam_union", "isProp": true, "docString": "The diameter of a union is controlled by the sum of the diameters, and the distance between\nany two points in each of the sets. This lemma is true without any side condition, since it is\nobviously true if `s ∪ t` is unbounded. ", "terms": "[\n    \"diameter\",\n    \"union\",\n    \"sum\",\n    \"diameters\",\n    \"distance\",\n    \"points\",\n    \"sets\",\n    \"lemma\",\n    \"side condition\",\n    \"unbounded\"\n]"}
{"type": "(R : Type u_1) →\n  [inst : Semiring R] →\n    (S : Type u_2) →\n      [inst_1 : Semiring S] →\n        {M : Type u_5} →\n          {N : Type u_6} →\n            {Pₗ : Type u_12} →\n              [inst_2 : AddCommMonoid M] →\n                [inst_3 : AddCommMonoid N] →\n                  [inst_4 : AddCommMonoid Pₗ] →\n                    [inst_5 : Module R M] →\n                      [inst_6 : Module S N] →\n                        [inst_7 : Module R Pₗ] →\n                          [inst_8 : Module S Pₗ] →\n                            [inst_9 : SMulCommClass S R Pₗ] →\n                              (f : M → N → Pₗ) →\n                                (∀ (m₁ m₂ : M) (n : N), f (m₁ + m₂) n = f m₁ n + f m₂ n) →\n                                  (∀ (c : R) (m : M) (n : N), f (c • m) n = c • f m n) →\n                                    (∀ (m : M) (n₁ n₂ : N), f m (n₁ + n₂) = f m n₁ + f m n₂) →\n                                      (∀ (c : S) (m : M) (n : N), f m (c • n) = c • f m n) → M →ₗ[R] N →ₗ[S] Pₗ", "name": "LinearMap.mk₂'", "isProp": false, "docString": "Create a bilinear map from a function that is linear in each component.\nSee `mk₂` for the special case where both arguments come from modules over the same ring. ", "terms": "[\n    \"bilinear map\",\n    \"function\",\n    \"linear\",\n    \"component\",\n    \"special case\",\n    \"arguments\",\n    \"modules\",\n    \"ring\"\n]"}
{"type": "{α : Type u_8} → {β : Type u_9} → [inst : InfSet α] → [inst_1 : InfSet β] → sInfHom α β → α → β", "name": "sInfHom.toFun", "isProp": false, "docString": "The underlying function of an `sInfHom`. ", "terms": "[\"underlying function\", \"sInfHom\"]"}
{"type": "∀ {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [inst : Fintype ι] [inst_1 : NontriviallyNormedField 𝕜]\n  [inst_2 : (i : ι) → NormedAddCommGroup (E i)] [inst_3 : (i : ι) → NormedSpace 𝕜 (E i)] [inst_4 : NormedAddCommGroup G]\n  [inst_5 : NormedSpace 𝕜 G] (f : ContinuousMultilinearMap 𝕜 E G) [inst_6 : DecidableEq ι] (m₁ m₂ : (i : ι) → E i),\n  ‖f m₁ - f m₂‖ ≤\n    ‖f‖ *\n      Finset.sum Finset.univ fun i =>\n        Finset.prod Finset.univ fun j => if j = i then ‖m₁ i - m₂ i‖ else max ‖m₁ j‖ ‖m₂ j‖", "name": "ContinuousMultilinearMap.norm_image_sub_le'", "isProp": true, "docString": "The difference `f m₁ - f m₂` is controlled in terms of `‖f‖` and `‖m₁ - m₂‖`, precise version.\nFor a less precise but more usable version, see `norm_image_sub_le`. The bound reads\n`‖f m - f m'‖ ≤\n  ‖f‖ * ‖m 1 - m' 1‖ * max ‖m 2‖ ‖m' 2‖ * max ‖m 3‖ ‖m' 3‖ * ... * max ‖m n‖ ‖m' n‖ + ...`,\nwhere the other terms in the sum are the same products where `1` is replaced by any `i`.", "terms": "[\n  \"difference\",\n  \"controlled\",\n  \"terms\",\n  \"norm\",\n  \"precise version\",\n  \"usable version\",\n  \"norm_image_sub_le\",\n  \"bound\",\n  \"max\",\n  \"product\",\n  \"sum\",\n  \"replaced\"\n]"}
{"type": "∀ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] [inst_1 : AddMonoid M] (f : AddMonoidAlgebra R M),\n  f ∈ Algebra.adjoin R (AddMonoidAlgebra.of' R M '' ↑f.support)", "name": "AddMonoidAlgebra.mem_adjoin_support", "isProp": true, "docString": "An element of `R[M]` is in the subalgebra generated by its support. ", "terms": "[\n    \"element\",\n    \"R[M]\",\n    \"subalgebra\",\n    \"generated\",\n    \"support\"\n]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  {p p₁ p₂ : P},\n  p₁ ≠ p → p₂ ≠ p → Real.Angle.cos (EuclideanGeometry.oangle p₁ p p₂) = Real.cos (EuclideanGeometry.angle p₁ p p₂)", "name": "EuclideanGeometry.cos_oangle_eq_cos_angle", "isProp": true, "docString": "The cosine of the oriented angle at `p` between two points not equal to `p` equals that of the\nunoriented angle. ", "terms": "[\n    \"cosine\",\n    \"oriented angle\",\n    \"points\",\n    \"not equal\",\n    \"unoriented angle\"\n]"}
{"type": "{α : Type} → [inst : DecidableEq α] → SlimCheck.InjectiveFunction α → List (SlimCheck.InjectiveFunction α)", "name": "SlimCheck.InjectiveFunction.shrink", "isProp": false, "docString": "Shrink an injective function slicing a segment in the middle of the domain and removing\nthe corresponding elements in the codomain, hence maintaining the property that\none is a permutation of the other.\n", "terms": "[\n    \"Shrink\",\n    \"Injective function\",\n    \"Slicing\",\n    \"Segment\",\n    \"Middle\",\n    \"Domain\",\n    \"Removing\",\n    \"Corresponding elements\",\n    \"Codomain\",\n    \"Maintaining\",\n    \"Property\",\n    \"Permutation\"\n]"}
{"type": "{C : Type v} →\n  [inst : CategoryTheory.SmallCategory C] → (X : Cᵒᵖ) → CategoryTheory.Limits.Cocone (CategoryTheory.coyoneda.obj X)", "name": "CategoryTheory.Coyoneda.colimitCocone", "isProp": false, "docString": "The colimit cocone over `coyoneda.obj X`, with cocone point `PUnit`.\n", "terms": "[\n  \"colimit\",\n  \"cocone\",\n  \"coyoneda.obj\",\n  \"cocone point\",\n  \"PUnit\"\n]"}
{"type": "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (v₁ v₂ v₃ : V),\n  EuclideanGeometry.angle (-v₁) (-v₂) (-v₃) = EuclideanGeometry.angle v₁ v₂ v₃", "name": "EuclideanGeometry.angle_neg", "isProp": true, "docString": "Angles in a vector space are invariant to inversion ", "terms": "[\n    \"Angles\",\n    \"Vector Space\",\n    \"Invariant\",\n    \"Inversion\"\n]"}
{"type": "∀ {n : ℕ} [inst : NeZero n] {i : Fin n}, 0 < i → 0 < Fin.castSucc i", "name": "Fin.castSucc_pos'", "isProp": true, "docString": "`castSucc i` is positive when `i` is positive.\n\nThe `Fin.castSucc_pos` in `Std` only applies in `Fin (n+1)`.\nThis one instead uses a `NeZero n` typeclass hypothesis.", "terms": "[\n    \"castSucc\",\n    \"positive\",\n    \"Fin.castSucc_pos\",\n    \"Std\",\n    \"Fin\",\n    \"n+1\",\n    \"NeZero\",\n    \"typeclass\",\n    \"hypothesis\"\n]"}
{"type": "SNum → SNum", "name": "SNum.bit0", "isProp": false, "docString": "Add an inactive bit at the end of a `SNum`. This mimics `ZNum.bit0`. ", "terms": "[\"inactive bit\", \"end\", \"SNum\", \"mimics\", \"ZNum.bit0\"]"}
{"type": "∀ (α : Type u_1) (β : Type u_2) [inst : UniformSpace β] (f : UniformFun α β),\n  Filter.HasBasis (nhds f) (fun V => V ∈ uniformity β) fun V => {g | (f, g) ∈ UniformFun.gen α β V}", "name": "UniformFun.hasBasis_nhds", "isProp": true, "docString": "For `f : α →ᵤ β`, `𝓝 f` admits the family `{g | ∀ x, (f x, g x) ∈ V}` for `V ∈ 𝓤 β` as a\nfilter basis. ", "terms": "[\n    \"f\",\n    \"α\",\n    \"→ᵤ\",\n    \"β\",\n    \"𝓝\",\n    \"admits\",\n    \"the family\",\n    \"{g | ∀ x, (f x, g x) ∈ V}\",\n    \"for\",\n    \"V\",\n    \"∈\",\n    \"𝓤\",\n    \"as a\",\n    \"filter basis\"\n]"}
{"type": "(α : Type u) →\n  {β : Type v} →\n    [inst : AddGroup α] → [inst_1 : AddAction α β] → (b : β) → ↑(AddAction.orbit α b) ≃ α ⧸ AddAction.stabilizer α b", "name": "AddAction.orbitEquivQuotientStabilizer", "isProp": false, "docString": "Orbit-stabilizer theorem.", "terms": "[\"Orbit-stabilizer theorem\"]"}
{"type": "∀ {α : Type u} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  [inst_3 : DenselyOrdered α] {δ : Type u_1} [inst_4 : LinearOrder δ] [inst_5 : TopologicalSpace δ]\n  [inst_6 : OrderClosedTopology δ] {a b : α} {f : α → δ},\n  ContinuousOn f (Set.uIcc a b) → Set.uIcc (f a) (f b) ⊆ f '' Set.uIcc a b", "name": "intermediate_value_uIcc", "isProp": true, "docString": "**Intermediate Value Theorem** for continuous functions on closed intervals, unordered case. ", "terms": "[\n    \"Intermediate Value Theorem\",\n    \"continuous functions\",\n    \"closed intervals\",\n    \"unordered case\"\n]"}
{"type": "∀ {α : Type u_1} {f g : α → α}, Function.Semiconj f g g → Function.Commute f g", "name": "Function.Semiconj.commute", "isProp": true, "docString": "Reinterpret `Function.Semiconj f g g` as `Function.Commute f g`. These two predicates are\ndefinitionally equal but have different dot-notation lemmas. ", "terms": "[\n    \"Function\",\n    \"Semiconj\",\n    \"Commutate\",\n    \"predicate\",\n    \"definitionally equal\",\n    \"dot-notation\",\n    \"lemmas\"\n]"}
{"type": "{X : Type u_1} → [inst : TopologicalSpace X] → X → Set X", "name": "pathComponent", "isProp": false, "docString": "The path component of `x` is the set of points that can be joined to `x`. ", "terms": "[\"path component\", \"set\", \"points\", \"joined\"]"}
{"type": "Lean.ParserDescr", "name": "«binderTerm∈_»", "isProp": false, "docString": "Declare `∀ x ∈ y, ...` as syntax for `∀ x, x ∈ y → ...` and `∃ x ∈ y, ...` as syntax for\n`∃ x, x ∈ y ∧ ...` ", "terms": "[\n  \"Declare\",\n  \"∀\",\n  \"∈\",\n  \"→\",\n  \"∃\",\n  \"∧\"\n]"}
{"type": "∀ {k G : Type u} [inst : CommRing k] [inst_1 : Monoid G] {V : Type u} [inst_2 : AddCommGroup V] [inst_3 : Module k V]\n  (ρ : Representation k G V) (g : ↑(MonCat.of G)), (Rep.ρ (Rep.of ρ)) g = ρ g", "name": "Rep.of_ρ_apply", "isProp": true, "docString": "Allows us to apply lemmas about the underlying `ρ`, which would take an element `g : G` rather\nthan `g : MonCat.of G` as an argument. ", "terms": "[\n    \"lemmas\",\n    \"underlying\",\n    \"element\",\n    \"argument\",\n    \"MonCat.of\"\n]"}
{"type": "∀ {α : Type u} [inst : PseudoMetricSpace α] {x y : α}, Metric.infDist x {y} = dist x y", "name": "Metric.infDist_singleton", "isProp": true, "docString": "The minimal distance to a singleton is the distance to the unique point in this singleton ", "terms": "[\"minimal distance\", \"singleton\", \"distance\", \"unique point\"]"}
{"type": "{α : Type u_1} → {β : Type u_3} → {γ : Type u_5} → (α → β → γ) → Filter α → Filter β → Filter γ", "name": "Filter.map₂", "isProp": false, "docString": "The image of a binary function `m : α → β → γ` as a function `Filter α → Filter β → Filter γ`.\nMathematically this should be thought of as the image of the corresponding function `α × β → γ`. ", "terms": "[\n    \"image\",\n    \"binary function\",\n    \"function\",\n    \"Filter\",\n    \"corresponding function\"\n]"}
{"type": "ℝ → Real.Angle", "name": "Real.Angle.coe", "isProp": false, "docString": "The canonical map from `ℝ` to the quotient `Angle`. ", "terms": "[\n  \"canonical map\",\n  \"ℝ\",\n  \"quotient\",\n  \"Angle\"\n]"}
{"type": "{R : Type u} →\n  {ι : Type v} →\n    {M₁ : ι → Type w₁} →\n      {M₂ : Type w₂} →\n        [inst : Semiring R] →\n          [inst_1 : (i : ι) → AddCommMonoid (M₁ i)] →\n            [inst_2 : AddCommMonoid M₂] →\n              [inst_3 : (i : ι) → Module R (M₁ i)] →\n                [inst_4 : Module R M₂] →\n                  [inst_5 : (i : ι) → TopologicalSpace (M₁ i)] →\n                    [inst_6 : TopologicalSpace M₂] →\n                      [inst_7 : ContinuousAdd M₂] → ((i : ι) → M₁ i) → ContinuousMultilinearMap R M₁ M₂ →+ M₂", "name": "ContinuousMultilinearMap.applyAddHom", "isProp": false, "docString": "Evaluation of a `ContinuousMultilinearMap` at a vector as an `AddMonoidHom`. ", "terms": "[\n  \"Evaluation\",\n  \"ContinuousMultilinearMap\",\n  \"Vector\",\n  \"AddMonoidHom\"\n]"}
{"type": "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {E' : Type u_5} [inst_3 : NormedAddCommGroup E'] [inst_4 : NormedSpace 𝕜 E'] {n : ℕ∞}\n  {f : E → E'} {x : E}, ContMDiffAt (modelWithCornersSelf 𝕜 E) (modelWithCornersSelf 𝕜 E') n f x → ContDiffAt 𝕜 n f x", "name": "ContMDiffAt.contDiffAt", "isProp": true, "docString": "**Alias** of the forward direction of `contMDiffAt_iff_contDiffAt`.", "terms": "[\"Alias\", \"forward direction\", \"contMDiffAt_iff_contDiffAt\"]"}
{"type": "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsOpen s ↔ ∀ x ∈ s, ∀ᶠ (y : α) in nhds x, y ∈ s", "name": "isOpen_iff_eventually", "isProp": true, "docString": "A set `s` is open iff for every point `x` in `s` and every `y` close to `x`, `y` is in `s`. ", "terms": "[\n  \"set\",\n  \"open\",\n  \"point\",\n  \"every\",\n  \"close\",\n  \"in\"\n]"}
{"type": "∀ {R : Type u} [inst : NonUnitalNonAssocRing R] {s : Set R} {p : R → R → Prop} {a b : R},\n  a ∈ NonUnitalSubring.closure s →\n    b ∈ NonUnitalSubring.closure s →\n      (∀ x ∈ s, ∀ y ∈ s, p x y) →\n        (∀ (x : R), p 0 x) →\n          (∀ (x : R), p x 0) →\n            (∀ (x y : R), p x y → p (-x) y) →\n              (∀ (x y : R), p x y → p x (-y)) →\n                (∀ (x₁ x₂ y : R), p x₁ y → p x₂ y → p (x₁ + x₂) y) →\n                  (∀ (x y₁ y₂ : R), p x y₁ → p x y₂ → p x (y₁ + y₂)) →\n                    (∀ (x₁ x₂ y : R), p x₁ y → p x₂ y → p (x₁ * x₂) y) →\n                      (∀ (x y₁ y₂ : R), p x y₁ → p x y₂ → p x (y₁ * y₂)) → p a b", "name": "NonUnitalSubring.closure_induction₂", "isProp": true, "docString": "An induction principle for closure membership, for predicates with two arguments. ", "terms": "[\"induction principle\", \"closure membership\", \"predicates\", \"arguments\"]"}
{"type": "∀ {𝕜 : Type u_2} [inst : NontriviallyNormedField 𝕜] {E : Type u_3} {F : Type u_4} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {𝕝 : Type u_7}\n  [inst_5 : NontriviallyNormedField 𝕝] [inst_6 : NormedAlgebra 𝕜 𝕝] [inst_7 : NormedSpace 𝕝 F]\n  [inst_8 : IsScalarTower 𝕜 𝕝 F] {f : E → 𝕝} {g : E → F} {z : E},\n  AnalyticAt 𝕜 f z → AnalyticAt 𝕜 g z → AnalyticAt 𝕜 (fun x => f x • g x) z", "name": "AnalyticAt.smul", "isProp": true, "docString": "Scalar multiplication of one analytic function by another. ", "terms": "[\n    \"Scalar multiplication\",\n    \"Analytic function\"\n]"}
{"type": "∀ {α : Sort u_2} {σ : α → Sort u_1} (P : Prop) [inst : Decidable P] (f g : (a : α) → σ a) (a : α),\n  ite P f g a = if P then f a else g a", "name": "ite_apply", "isProp": true, "docString": "A 'ite' producing a `Pi` type `Π a, σ a`, applied to a value `a : α` is a `ite` that applies\neither branch to `a`. ", "terms": "[\"ite\", \"Pi\", \"type\", \"applied\", \"value\", \"applies\", \"branch\"]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] (v₁ v₂ v₃ : V) (p : P),\n  EuclideanGeometry.angle (v₁ +ᵥ p) (v₂ +ᵥ p) (v₃ +ᵥ p) = EuclideanGeometry.angle v₁ v₂ v₃", "name": "EuclideanGeometry.angle_vadd_const", "isProp": true, "docString": "Angles are translation invariant ", "terms": "[\"Angles\", \"Translation Invariant\"]"}
{"type": "(X : Type u_1) →\n  {ι : Type u_2} →\n    (Y : ι → Type u_3) →\n      [inst : TopologicalSpace X] →\n        [inst_1 : (i : ι) → TopologicalSpace (Y i)] →\n          [inst_2 : ConnectedSpace X] → C(X, (i : ι) × Y i) ≃ₜ (i : ι) × C(X, Y i)", "name": "ContinuousMap.sigmaCodHomeomorph", "isProp": false, "docString": "Homeomorphism between the type `C(X, Σ i, Y i)` of continuous maps from a connected topological\nspace to the disjoint union of a family of topological spaces and the disjoint union of the types of\ncontinuous maps `C(X, Y i)`.\n\nThe inverse map sends `⟨i, g⟩` to `ContinuousMap.comp (ContinuousMap.sigmaMk i) g`. ", "terms": "[\n    \"Homeomorphism\",\n    \"Continuous maps\",\n    \"Connected topological space\",\n    \"Disjoint union\",\n    \"Family of topological spaces\",\n    \"Types of continuous maps\",\n    \"Inverse map\",\n    \"ContinuousMap.comp\",\n    \"ContinuousMap.sigmaMk\"\n]"}
{"type": "∀ {p : ℕ}, padicValInt p 1 = 0", "name": "padicValInt.one", "isProp": true, "docString": "`padicValInt p 1` is `0` for any `p`. ", "terms": "[\n  \"padicValInt\",\n  \"0\",\n  \"any\"\n]"}
{"type": "∀ {α : Type u_4} [self : BiheytingAlgebra α] (a : α), ⊤ \\ a = ￢a", "name": "BiheytingAlgebra.top_sdiff", "isProp": true, "docString": "`⊤ \\ a` is `￢a` ", "terms": "[\"⊤\", \"\\\", \"￢\"]"}
{"type": "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β} [inst : Subsingleton α], Function.Surjective f → Subsingleton β", "name": "Function.Surjective.subsingleton", "isProp": true, "docString": "If the domain of a surjective function is a subsingleton, then the codomain is a subsingleton as\nwell. ", "terms": "[\n    \"domain\",\n    \"surjective function\",\n    \"subsingleton\",\n    \"codomain\"\n]"}
{"type": "{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : CommSemiring R] →\n      [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → GradedMonoid.GOne fun i => TensorPower R i M", "name": "TensorPower.gOne", "isProp": false, "docString": "As a graded monoid, `⨂[R]^i M` has a `1 : ⨂[R]^0 M`. ", "terms": "[\n    \"graded monoid\",\n    \"⨂[R]^i M\",\n    \"1\",\n    \"⨂[R]^0 M\"\n]"}
{"type": "∀ {α : Type u} [inst : UniformSpace α] (self : AbstractCompletion α), DenseRange self.coe", "name": "AbstractCompletion.dense", "isProp": true, "docString": "The map into the completion has dense range. ", "terms": "[\"map\", \"completion\", \"dense\", \"range\"]"}
{"type": "PNat.XgcdType → ℕ", "name": "PNat.XgcdType.bp", "isProp": false, "docString": "`bp` is a variable which changes through the algorithm. ", "terms": "[]"}
{"type": "{R : Type u_1} →\n  [inst : Semiring R] →\n    {M : Type u_2} →\n      [inst_1 : AddCommMonoid M] →\n        [inst_2 : Module R M] →\n          {N : Type u_3} →\n            [inst_3 : AddCommMonoid N] →\n              [inst_4 : Module R N] →\n                {ι : Type u_7} →\n                  {M₂ : Type u_10} →\n                    [inst_5 : AddCommMonoid M₂] →\n                      [inst_6 : Module R M₂] → M [Λ^ι]→ₗ[R] N → (M₂ →ₗ[R] M) → M₂ [Λ^ι]→ₗ[R] N", "name": "AlternatingMap.compLinearMap", "isProp": false, "docString": "Composing an alternating map with the same linear map on each argument gives again an\nalternating map. ", "terms": "[\n    \"Composing\",\n    \"Alternating map\",\n    \"Linear map\",\n    \"Argument\"\n]"}
{"type": "{ι : Type u_1} →\n  {G : ι → Type u_2} →\n    {H : Type u_3} →\n      [inst : (i : ι) → Monoid (G i)] →\n        [inst_1 : Monoid H] → ((i : ι) → H →* G i) → Con (Monoid.Coprod (Monoid.CoprodI G) H)", "name": "Monoid.PushoutI.con", "isProp": false, "docString": "The relation we quotient by to form the pushout ", "terms": "[\n  \"Relation\",\n  \"Quotient\",\n  \"Form\",\n  \"Pushout\"\n]"}
{"type": "PNat.XgcdType → ℕ × ℕ", "name": "PNat.XgcdType.vp", "isProp": false, "docString": "The map `v` gives the product of the matrix\n[[w, x], [y, z]] = [[wp + 1, x], [y, zp + 1]]\nand the vector [a, b] = [ap + 1, bp + 1].  The map\n`vp` gives [sp, tp] such that v = [sp + 1, tp + 1].\n", "terms": "[\"map\", \"product\", \"matrix\", \"vector\"]"}
{"type": "{R : Type u_1} →\n  [inst : StrictOrderedCommSemiring R] →\n    {M : Type u_2} →\n      [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → (ι : Type u_4) → [inst_3 : IsEmpty ι] → Module.Oriented R M ι", "name": "IsEmpty.oriented", "isProp": false, "docString": "A module is canonically oriented with respect to an empty index type. ", "terms": "[\n    \"module\",\n    \"canonically oriented\",\n    \"empty index type\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    (J : CategoryTheory.GrothendieckTopology C) →\n      {D : Type w} →\n        [inst_1 : CategoryTheory.Category.{max v u, w} D] →\n          [inst_2 :\n              ∀ (P : CategoryTheory.Functor Cᵒᵖ D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X),\n                CategoryTheory.Limits.HasMultiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)] →\n            [inst_3 :\n                ∀ (X : C),\n                  CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)ᵒᵖ D] →\n              {P : CategoryTheory.Functor Cᵒᵖ D} →\n                CategoryTheory.Presheaf.IsSheaf J P → (P ≅ CategoryTheory.GrothendieckTopology.sheafify J P)", "name": "CategoryTheory.GrothendieckTopology.isoSheafify", "isProp": false, "docString": "If `P` is a sheaf, then `P` is isomorphic to `J.sheafify P`. ", "terms": "[\n  \"sheaf\",\n  \"isomorphic\",\n  \"sheafify\"\n]"}
{"type": "{R : Type u} →\n  [inst : CommRing R] →\n    (M : ModuleCat R) →\n      {N₁ N₂ : ModuleCat R} →\n        (N₁ ⟶ N₂) → (ModuleCat.MonoidalCategory.tensorObj M N₁ ⟶ ModuleCat.MonoidalCategory.tensorObj M N₂)", "name": "ModuleCat.MonoidalCategory.whiskerLeft", "isProp": false, "docString": "(implementation) left whiskering for R-modules ", "terms": "[\"implementation\", \"left whiskering\", \"R-modules\"]"}
{"type": "{R : Type u_1} →\n  {M : Type u_9} →\n    {M₂ : Type u_12} →\n      [inst : Semiring R] →\n        [inst_1 : AddCommMonoid M] →\n          [inst_2 : Module R M] →\n            [inst_3 : AddCommMonoid M₂] → [inst_4 : Module R M₂] → (e : M ≃ M₂) → IsLinearMap R ⇑e → M ≃ₗ[R] M₂", "name": "Equiv.toLinearEquiv", "isProp": false, "docString": "An equivalence whose underlying function is linear is a linear equivalence. ", "terms": "[\n  \"equivalence\",\n  \"underlying function\",\n  \"linear\",\n  \"linear equivalence\"\n]"}
{"type": "{G : Type u_3} → [inst : DivInvMonoid G] → ConjAct G ≃* G", "name": "ConjAct.ofConjAct", "isProp": false, "docString": "Reinterpret `g : ConjAct G` as an element of `G`. ", "terms": "[\"Reinterpret\", \"element\", \"ConjAct\", \"G\"]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} [inst : CompleteLattice α] {f : Filter β} {u : β → α},\n  Filter.liminf u f = ⨆ s ∈ f, ⨅ a ∈ s, u a", "name": "Filter.liminf_eq_iSup_iInf", "isProp": true, "docString": "In a complete lattice, the liminf of a function is the infimum over sets `s` in the filter\nof the supremum of the function over `s` ", "terms": "[\n    \"complete lattice\",\n    \"liminf\",\n    \"function\",\n    \"infimum\",\n    \"sets\",\n    \"filter\",\n    \"supremum\"\n]"}
{"type": "ℝ → (ℕ → Bool) → ℕ → ℝ", "name": "Cardinal.cantorFunctionAux", "isProp": false, "docString": "The body of the sum in `cantorFunction`.\n`cantorFunctionAux c f n = c ^ n` if `f n = true`;\n`cantorFunctionAux c f n = 0` if `f n = false`. ", "terms": "[\"body\", \"sum\", \"cantorFunction\", \"cantorFunctionAux\", \"true\", \"false\", \"0\", \"^\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {X Y Z : C} →\n      {f : X ⟶ Z} →\n        {g : Y ⟶ Z} →\n          (t : CategoryTheory.Limits.PullbackCone f g) →\n            (lift : (s : CategoryTheory.Limits.PullbackCone f g) → s.pt ⟶ t.pt) →\n              (∀ (s : CategoryTheory.Limits.PullbackCone f g),\n                  CategoryTheory.CategoryStruct.comp (lift s) (CategoryTheory.Limits.PullbackCone.fst t) =\n                    CategoryTheory.Limits.PullbackCone.fst s) →\n                (∀ (s : CategoryTheory.Limits.PullbackCone f g),\n                    CategoryTheory.CategoryStruct.comp (lift s) (CategoryTheory.Limits.PullbackCone.snd t) =\n                      CategoryTheory.Limits.PullbackCone.snd s) →\n                  (∀ (s : CategoryTheory.Limits.PullbackCone f g) (m : s.pt ⟶ t.pt),\n                      (∀ (j : CategoryTheory.Limits.WalkingCospan),\n                          CategoryTheory.CategoryStruct.comp m (t.π.app j) = s.π.app j) →\n                        m = lift s) →\n                    CategoryTheory.Limits.IsLimit t", "name": "CategoryTheory.Limits.PullbackCone.isLimitAux", "isProp": false, "docString": "This is a slightly more convenient method to verify that a pullback cone is a limit cone. It\nonly asks for a proof of facts that carry any mathematical content ", "terms": "[\"pullback cone\", \"limit cone\", \"proof\", \"facts\", \"mathematical content\"]"}
{"type": "∀ {m n : ℕ}, Nat.Coprime m n → 1 < m → 1 < n → FrobeniusNumber (m * n - m - n) {m, n}", "name": "frobeniusNumber_pair", "isProp": true, "docString": "The **Chicken McNugget theorem** stating that the Frobenius number\nof positive numbers `m` and `n` is `m * n - m - n`. ", "terms": "[\n  \"Chicken McNugget theorem\",\n  \"Frobenius number\",\n  \"positive numbers\",\n  \"multiplication\",\n  \"subtraction\"\n]"}
{"type": "∀ {α : Type u_1} [inst : Monoid α] {a b : α} {u : αˣ}, a ∣ b * ↑u ↔ a ∣ b", "name": "Units.dvd_mul_right", "isProp": true, "docString": "In a monoid, an element `a` divides an element `b` iff `a` divides all\nassociates of `b`. ", "terms": "[\n  \"monoid\",\n  \"element\",\n  \"divides\",\n  \"associates\"\n]"}
{"type": "∀ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (S : Type u_3)\n  [inst_3 : CommMonoid S] [inst_4 : DistribMulAction S M] [inst_5 : SMulCommClass S R M],\n  Module.IsTorsion' (↥(Submodule.torsion' R M S)) S", "name": "Submodule.torsion'_isTorsion'", "isProp": true, "docString": "The `S`-torsion submodule is an `S`-torsion module. ", "terms": "[\"submodule\", \"module\", \"S-torsion\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    (D : AlgebraicGeometry.PresheafedSpace.GlueData C) →\n      [inst_1 : CategoryTheory.Limits.HasLimits C] →\n        (i j : D.J) →\n          (U : TopologicalSpace.Opens ↑↑(CategoryTheory.GlueData.U D.toGlueData i)) →\n            (CategoryTheory.GlueData.U D.toGlueData i).presheaf.obj (Opposite.op U) ⟶\n              (CategoryTheory.GlueData.U D.toGlueData j).presheaf.obj\n                (Opposite.op\n                  ((TopologicalSpace.Opens.map (CategoryTheory.GlueData.ι D.toGlueData j).base).obj\n                    ((IsOpenMap.functor (_ : IsOpenMap ⇑(CategoryTheory.GlueData.ι D.toGlueData i).base)).obj U)))", "name": "AlgebraicGeometry.PresheafedSpace.GlueData.opensImagePreimageMap", "isProp": false, "docString": "(Implementation). The map `Γ(𝒪_{U_i}, U) ⟶ Γ(𝒪_{U_j}, 𝖣.ι j ⁻¹' (𝖣.ι i '' U))` ", "terms": "[\n    \"map\",\n    \"Γ\",\n    \"𝒪\",\n    \"U\",\n    \"𝖣.ι\",\n    \"⁻¹\",\n    \"''\"\n]"}
{"type": "{R : Type u} →\n  [inst : Ring R] →\n    {G H : ModuleCat R} → (f : G ⟶ H) → CategoryTheory.Limits.kernel f ≅ ModuleCat.of R ↥(LinearMap.ker f)", "name": "ModuleCat.kernelIsoKer", "isProp": false, "docString": "The categorical kernel of a morphism in `ModuleCat`\nagrees with the usual module-theoretical kernel.\n", "terms": "[\n    \"categorical kernel\",\n    \"morphism\",\n    \"ModuleCat\",\n    \"usual module-theoretical kernel\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (f : C(α, β)) {x y : α},\n  x = y → f x = f y", "name": "ContinuousMap.congr_arg", "isProp": true, "docString": "Deprecated. Use `FunLike.congr_arg` instead. ", "terms": "[]"}
{"type": "Lean.ParserDescr", "name": "tacticCongrm?", "isProp": false, "docString": "Display a widget panel allowing to generate a `congrm` call with holes specified by selecting\nsubexpressions in the goal.", "terms": "[]\n"}
{"type": "Linarith.LinarithConfig → Option (List Linarith.GlobalBranchingPreprocessor)", "name": "Linarith.LinarithConfig.preprocessors", "isProp": false, "docString": "Override the list of preprocessors. ", "terms": "[]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      {D : Type u_1} →\n        [inst_2 : CategoryTheory.Category.{v₁, u_1} D] →\n          [inst_3 : CategoryTheory.Preadditive D] →\n            {E : Type u_2} →\n              [inst_4 : CategoryTheory.Category.{v₁, u_2} E] →\n                [inst_5 : CategoryTheory.Preadditive E] →\n                  (F : CategoryTheory.Functor C D) →\n                    [inst_6 : CategoryTheory.Functor.Additive F] →\n                      (G : CategoryTheory.Functor D E) →\n                        [inst_7 : CategoryTheory.Functor.Additive G] →\n                          CategoryTheory.Functor.mapMat_ (CategoryTheory.Functor.comp F G) ≅\n                            CategoryTheory.Functor.comp (CategoryTheory.Functor.mapMat_ F)\n                              (CategoryTheory.Functor.mapMat_ G)", "name": "CategoryTheory.Functor.mapMatComp", "isProp": false, "docString": "Composite functors induce composite functors on matrix categories.\n", "terms": "[\n    \"Composite functors\",\n    \"induce\",\n    \"matrix categories\"\n]"}
{"type": "∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]\n  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ℝ E H} {M : Type uM} [inst_4 : TopologicalSpace M]\n  [inst_5 : ChartedSpace H M] {s : optParam (Set M) Set.univ} (self : SmoothBumpCovering ι I M s),\n  ∀ x ∈ s, ∃ i, ↑(SmoothBumpCovering.toFun s self i) =ᶠ[nhds x] 1", "name": "SmoothBumpCovering.eventuallyEq_one'", "isProp": true, "docString": "Around each point in `s`, one of the bump functions is equal to `1`. ", "terms": "[\"point\", \"bump functions\", \"equal\"]"}
{"type": "∀ (a b : ℝ) {p q : ℝ}, Real.IsConjugateExponent p q → a * b ≤ |a| ^ p / p + |b| ^ q / q", "name": "Real.young_inequality", "isProp": true, "docString": "Young's inequality, a version for arbitrary real numbers. ", "terms": "[\"Young's inequality\", \"version\", \"arbitrary\", \"real numbers\"]"}
{"type": "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x y : V},\n  Real.sin (InnerProductGeometry.angle x y) = 0 ↔\n    InnerProductGeometry.angle x y = 0 ∨ InnerProductGeometry.angle x y = Real.pi", "name": "InnerProductGeometry.sin_eq_zero_iff_angle_eq_zero_or_angle_eq_pi", "isProp": true, "docString": "The sine of the angle between two vectors is 0 if and only if the angle is 0 or π. ", "terms": "[\n    \"sine\",\n    \"angle\",\n    \"vectors\",\n    \"if and only if\",\n    \"0\",\n    \"π\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} (s : Finset β) {f : α → β},\n  (∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) → (Finset.sum s fun b => ↑↑μ (f ⁻¹' {b})) = ↑↑μ (f ⁻¹' ↑s)", "name": "MeasureTheory.sum_measure_preimage_singleton", "isProp": true, "docString": "If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. ", "terms": "[\n    \"Finset\",\n    \"measure\",\n    \"preimage\",\n    \"sum\",\n    \"fibers\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_3} {f : α → β → α} {b : β},\n  (∀ (a : α), f a b = a) → ∀ (l : Filter α), Filter.map₂ f l (pure b) = l", "name": "Filter.map₂_right_identity", "isProp": true, "docString": "If `b` is a right identity for `f : α → β → α`, then `pure b` is a right identity for\n`Filter.map₂ f`. ", "terms": "[\n    \"right identity\",\n    \"pure\",\n    \"Filter.map₂\",\n    \"function\"\n]"}
{"type": "{X : AlgebraicGeometry.Scheme} →\n  {U : TopologicalSpace.Opens ↑↑X.toPresheafedSpace} →\n    AlgebraicGeometry.IsAffineOpen U →\n      (AlgebraicGeometry.Scheme.Spec.obj (Opposite.op (X.presheaf.obj (Opposite.op U))) ⟶ X)", "name": "AlgebraicGeometry.IsAffineOpen.fromSpec", "isProp": false, "docString": "The open immersion `Spec 𝒪ₓ(U) ⟶ X` for an affine `U`. ", "terms": "[\n    \"open immersion\",\n    \"Spec\",\n    \"affine\"\n]"}
{"type": "∀ {α : Type u_1} [inst : Subsingleton α] (s : Finset α), Finset.card s ≤ 1", "name": "Finset.card_le_one_of_subsingleton", "isProp": true, "docString": "A `Finset` of a subsingleton type has cardinality at most one. ", "terms": "[\n    \"Finset\",\n    \"subsingleton type\",\n    \"cardinality\"\n]"}
{"type": "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V},\n  Orientation.oangle o x y = ↑(Real.pi / 2) → Real.Angle.tan (Orientation.oangle o y (y - x)) = ‖x‖ / ‖y‖", "name": "Orientation.tan_oangle_sub_right_of_oangle_eq_pi_div_two", "isProp": true, "docString": "The tangent of an angle in a right-angled triangle as a ratio of sides, version subtracting\nvectors. ", "terms": "[\n    \"tangent\",\n    \"angle\",\n    \"right-angled triangle\",\n    \"ratio\",\n    \"sides\",\n    \"subtracting\",\n    \"vectors\"\n]"}
{"type": "∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare (-2) ↔ Fintype.card F % 8 ≠ 5 ∧ Fintype.card F % 8 ≠ 7", "name": "FiniteField.isSquare_neg_two_iff", "isProp": true, "docString": "`-2` is a square in `F` iff `#F` is not congruent to `5` or `7` mod `8`. ", "terms": "[\n    \"square\",\n    \"congruent\",\n    \"mod\"\n]"}
{"type": "(α : Type u_5) →\n  [H1 : PartialOrder α] →\n    [H2 : SupSet α] →\n      (∀ (a b : α), BddAbove {a, b}) →\n        (∀ (a b : α), BddBelow {a, b}) →\n          (∀ (s : Set α), BddAbove s → Set.Nonempty s → IsLUB s (sSup s)) → ConditionallyCompleteLattice α", "name": "conditionallyCompleteLatticeOfsSup", "isProp": false, "docString": "Create a `ConditionallyCompleteLattice` from a `PartialOrder` and `sup` function\nthat returns the least upper bound of a nonempty set which is bounded above. Usually this\nconstructor provides poor definitional equalities.  If other fields are known explicitly, they\nshould be provided; for example, if `inf` is known explicitly, construct the\n`ConditionallyCompleteLattice` instance as\n```\ninstance : ConditionallyCompleteLattice my_T :=\n  { inf := better_inf,\n    le_inf := ...,\n    inf_le_right := ...,\n    inf_le_left := ...\n    -- don't care to fix sup, sInf\n    ..conditionallyCompleteLatticeOfsSup my_T _ }\n```\n", "terms": "[\n    \"ConditionallyCompleteLattice\",\n    \"PartialOrder\",\n    \"sup\",\n    \"least upper bound\",\n    \"nonempty set\",\n    \"bounded above\",\n    \"definitional equalities\",\n    \"inf\",\n    \"instance\",\n    \"le_inf\",\n    \"inf_le_right\",\n    \"inf_le_left\",\n    \"conditionallyCompleteLatticeOfsSup\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      (R : Type w) →\n        [inst_2 : Semiring R] →\n          [inst_3 : CategoryTheory.Linear R C] → {X Y : C} → (Z : C) → (X ⟶ Y) → (Y ⟶ Z) →ₗ[R] X ⟶ Z", "name": "CategoryTheory.Linear.leftComp", "isProp": false, "docString": "Composition by a fixed left argument as an `R`-linear map. ", "terms": "[\n    \"Composition\",\n    \"Fixed\",\n    \"Left argument\",\n    \"R-linear map\"\n]"}
{"type": "{R : Type u} →\n  {S : Type v} → [inst : CommRing R] → [inst_1 : CommRing S] → (R →+* S) → C(PrimeSpectrum S, PrimeSpectrum R)", "name": "PrimeSpectrum.comap", "isProp": false, "docString": "The function between prime spectra of commutative rings induced by a ring homomorphism.\nThis function is continuous. ", "terms": "[\n  \"function\", \n  \"prime spectra\", \n  \"commutative rings\", \n  \"ring homomorphism\", \n  \"continuous\"\n]"}
{"type": "{M : Type u_1} → {N : Type u_2} → [inst : AddMonoid M] → [inst_1 : AddMonoid N] → AddMonoid.Coprod M N →+ N", "name": "AddMonoid.Coprod.snd", "isProp": false, "docString": "The natural projection `AddMonoid.Coprod M N →+ N`.", "terms": "[\n    \"Natural Projection\",\n    \"AddMonoid\",\n    \"Coprod\",\n    \"M\",\n    \"N\",\n    \"→+\"\n]"}
{"type": "WType.Natα → Type", "name": "WType.Natβ", "isProp": false, "docString": "The arity of the constructors for the naturals, `zero` takes no arguments, `succ` takes one ", "terms": "[\n  \"arity\",\n  \"constructors\",\n  \"naturals\",\n  \"zero\",\n  \"arguments\",\n  \"succ\"\n]"}
{"type": "∀ {F : Type u_1} [inst : NormedField F] [inst_1 : CompleteSpace F] {f : ℕ →* F},\n  (∀ {p : ℕ}, Nat.Prime p → ‖f p‖ < 1) →\n    ∀ (N : ℕ),\n      (Summable fun m => ‖f ↑m‖) ∧ HasSum (fun m => f ↑m) (Finset.prod (Nat.primesBelow N) fun p => (1 - f p)⁻¹)", "name": "EulerProduct.summable_and_hasSum_smoothNumbers_prod_primesBelow_geometric", "isProp": true, "docString": "Given a (completely) multiplicative function `f : ℕ → F`, where `F` is a normed field,\nsuch that `‖f p‖ < 1` for all primes `p`, we can express the sum of `f n` over all `N`-smooth\npositive integers `n` as a product of `(1 - f p)⁻¹` over the primes `p < N`. At the same time,\nwe show that the sum involved converges absolutely. ", "terms": "[\n    \"multiplicative function\",\n    \"ℕ\",\n    \"→\",\n    \"F\",\n    \"normed field\",\n    \"‖‖\",\n    \"<\",\n    \"1\",\n    \"primes\",\n    \"sum\",\n    \"N-smooth\",\n    \"positive integers\",\n    \"product\",\n    \"(1 - )⁻¹\",\n    \"<\",\n    \"N\",\n    \"converges\",\n    \"absolutely\"\n]"}
{"type": "{ι : Type u_1} → [inst : LinearOrder ι] → ι → ι", "name": "LinearLocallyFiniteOrder.succFn", "isProp": false, "docString": "Successor in a linear order. This defines a true successor only when `i` is isolated from above,\ni.e. when `i` is not the greatest lower bound of `(i, ∞)`. ", "terms": "[\n    \"Successor\",\n    \"Linear order\",\n    \"True successor\",\n    \"Isolated\",\n    \"From above\",\n    \"Greatest lower bound\",\n    \"∞\"\n]"}
{"type": "∀ {R : Type u} {S : Type v} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S] {F : Type u_1}\n  [inst_2 : NonUnitalRingHomClass F R S] (f : F) (s : Set R),\n  NonUnitalSubsemiring.map f (NonUnitalSubsemiring.closure s) = NonUnitalSubsemiring.closure (⇑f '' s)", "name": "NonUnitalRingHom.map_sclosure", "isProp": true, "docString": "The image under a ring homomorphism of the subsemiring generated by a set equals\nthe subsemiring generated by the image of the set. ", "terms": "[\n    \"Image\", \n    \"Ring homomorphism\", \n    \"Subsemiring\", \n    \"Generated\", \n    \"Set\", \n    \"Equals\"\n]"}
{"type": "∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\n  |inner x y / (‖x‖ * ‖y‖)| = 1 ↔ x ≠ 0 ∧ ∃ r, r ≠ 0 ∧ y = r • x", "name": "abs_real_inner_div_norm_mul_norm_eq_one_iff", "isProp": true, "docString": "The inner product of two vectors, divided by the product of their\nnorms, has absolute value 1 if and only if they are nonzero and one is\na multiple of the other. One form of equality case for Cauchy-Schwarz. ", "terms": "[\n    \"Inner product\",\n    \"Vectors\",\n    \"Divided\",\n    \"Product\",\n    \"Norms\",\n    \"Absolute value\",\n    \"Nonzero\",\n    \"Multiple\",\n    \"Equality case\",\n    \"Cauchy-Schwarz\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        (F : CategoryTheory.Functor C D) → [self : CategoryTheory.IsEquivalence F] → CategoryTheory.Functor D C", "name": "CategoryTheory.IsEquivalence.inverse", "isProp": false, "docString": "The inverse functor to `F` ", "terms": "[\n    \"Inverse\",\n    \"Functor\"\n]"}
{"type": "∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 2 = a * a", "name": "sq", "isProp": true, "docString": "**Alias** of `pow_two`.\n\n---\n\nNote that most of the lemmas about powers of two refer to it as `sq`. ", "terms": "[\"Alias\", \"pow_two\", \"lemmas\", \"powers of two\", \"sq\"]"}
{"type": "(α : Type u) →\n  [inst : Lattice α] →\n    [inst_1 : DecidableEq α] →\n      [inst_2 : DecidableRel fun x x_1 => x ≤ x_1] →\n        [inst_3 : DecidableRel fun x x_1 => x < x_1] → [inst : IsTotal α fun x x_1 => x ≤ x_1] → LinearOrder α", "name": "Lattice.toLinearOrder", "isProp": false, "docString": "A lattice with total order is a linear order.\n\nSee note [reducible non-instances]. ", "terms": "[\"lattice\", \"total order\", \"linear order\"]"}
{"type": "(R : Type u) → [inst : Semiring R] → Type u", "name": "Ideal", "isProp": false, "docString": "A (left) ideal in a semiring `R` is an additive submonoid `s` such that\n`a * b ∈ s` whenever `b ∈ s`. If `R` is a ring, then `s` is an additive subgroup.  ", "terms": "[\n    \"Ideal\",\n    \"Semiring\",\n    \"Additive submonoid\",\n    \"Ring\",\n    \"Additive subgroup\"\n]"}
{"type": "∀ {α : Type u_1} {E : Type u_3} [inst : MeasurableSpace α] {ι : Type u_5} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : TopologicalSpace α] [inst_3 : OpensMeasurableSpace α] [inst_4 : NormedSpace ℝ E] [inst_5 : CompleteSpace E]\n  {μ : MeasureTheory.Measure α} [inst_6 : MeasureTheory.IsLocallyFiniteMeasure μ] {a : α} {t : Set α} {f : α → E},\n  ContinuousWithinAt f t a →\n    MeasurableSet t →\n      StronglyMeasurableAtFilter f (nhdsWithin a t) →\n        ∀ {s : ι → Set α} {li : Filter ι},\n          Filter.Tendsto s li (Filter.smallSets (nhdsWithin a t)) →\n            ∀ (m : optParam (ι → ℝ) fun i => ENNReal.toReal (↑↑μ (s i))),\n              autoParam ((fun i => ENNReal.toReal (↑↑μ (s i))) =ᶠ[li] m) _auto✝ →\n                (fun i => ∫ (x : α) in s i, f x ∂μ - m i • f a) =o[li] m", "name": "ContinuousWithinAt.integral_sub_linear_isLittleO_ae", "isProp": true, "docString": "Fundamental theorem of calculus for set integrals, `nhdsWithin` version: if `μ` is a locally\nfinite measure and `f` is an almost everywhere measurable function that is continuous at a point `a`\nwithin a measurable set `t`, then `∫ x in s i, f x ∂μ = μ (s i) • f a + o(μ (s i))` at a filter `li`\nprovided that `s i` tends to `(𝓝[t] a).smallSets` along `li`.  Since `μ (s i)` is an `ℝ≥0∞`\nnumber, we use `(μ (s i)).toReal` in the actual statement.\n\nOften there is a good formula for `(μ (s i)).toReal`, so the formalization can take an optional\nargument `m` with this formula and a proof of `(fun i => (μ (s i)).toReal) =ᶠ[li] m`. Without these\narguments, `m i = (μ (s i)).toReal` is used in the output. ", "terms": "[\n    \"Fundamental theorem of calculus\",\n    \"set integrals\",\n    \"nhdsWithin\",\n    \"locally finite measure\",\n    \"almost everywhere measurable function\",\n    \"continuous\",\n    \"measurable set\",\n    \"integral\",\n    \"filter\",\n    \"tends\",\n    \"smallSets\",\n    \"ℝ≥0∞\",\n    \"number\",\n    \"toReal\",\n    \"formula\",\n    \"formalization\",\n    \"optional argument\",\n    \"proof\",\n    \"output\"\n]"}
{"type": "{α : Type u_2} →\n  {M₁ : Type u_6} →\n    {M₂ : Type u_7} →\n      [inst : TopologicalSpace M₂] →\n        [inst_1 : T2Space M₂] →\n          [inst_2 : MulOneClass M₁] →\n            [inst_3 : MulOneClass M₂] →\n              [inst_4 : ContinuousMul M₂] →\n                {F : Type u_8} →\n                  [inst_5 : MonoidHomClass F M₁ M₂] →\n                    {l : Filter α} →\n                      (f : M₁ → M₂) →\n                        (g : α → F) →\n                          [inst_6 : Filter.NeBot l] → Filter.Tendsto (fun a x => (g a) x) l (nhds f) → M₁ →* M₂", "name": "monoidHomOfTendsto", "isProp": false, "docString": "Construct a bundled monoid homomorphism from a pointwise limit of monoid homomorphisms. ", "terms": "[\n    \"Construct\",\n    \"bundled\",\n    \"monoid homomorphism\",\n    \"from\",\n    \"pointwise limit\",\n    \"of\",\n    \"monoid homomorphisms\"\n]"}
{"type": "{α : Type u_2} → [inst : AddCommMonoid α] → Multiset α → α", "name": "Multiset.sum", "isProp": false, "docString": "Sum of a multiset given a commutative additive monoid structure on `α`.\n`sum {a, b, c} = a + b + c`", "terms": "[\n  \"Sum\",\n  \"Multiset\",\n  \"Commutative\",\n  \"Additive\",\n  \"Monoid\",\n  \"Structure\"\n]"}
{"type": "(V : Type (u + 1)) →\n  [inst : CategoryTheory.LargeCategory V] →\n    (G : MonCat) →\n      [inst_1 : CategoryTheory.MonoidalCategory V] →\n        [inst_2 : CategoryTheory.BraidedCategory V] → CategoryTheory.BraidedFunctor (Action V G) V", "name": "Action.forgetBraided", "isProp": false, "docString": "When `V` is braided the forgetful functor `Action V G` to `V` is braided. ", "terms": "[\n    \"Braided\",\n    \"Forgetful Functor\",\n    \"Action\",\n    \"G\"\n]"}
{"type": "∀ (R : Type u_3) (M : Type u_4) [inst : AddCommMonoid M] [inst_1 : Semiring R] [inst_2 : Module R M],\n  AddMonoid.IsTorsion R → AddMonoid.IsTorsion M", "name": "AddMonoid.IsTorsion.module_of_torsion", "isProp": true, "docString": "A module whose scalars are additively torsion is additively torsion. ", "terms": "[\n    \"module\",\n    \"scalars\",\n    \"additively\",\n    \"torsion\"\n]"}
{"type": "{α : Type u_1} → {β : Type u_2} → [inst : Fintype α] → [inst_1 : Fintype β] → Fintype.card α = Fintype.card β → α ≃ β", "name": "Fintype.equivOfCardEq", "isProp": false, "docString": "Two `Fintype`s with the same cardinality are (noncomputably) in bijection.\n\nSee `Fintype.truncEquivOfCardEq` for the computable version,\nand `Fintype.truncEquivFinOfCardEq` and `Fintype.equivFinOfCardEq` for\nthe specialization to `Fin`.\n", "terms": "[\n    \"Fintype\",\n    \"cardinality\",\n    \"bijection\",\n    \"Fintype.truncEquivOfCardEq\",\n    \"computable\",\n    \"Fintype.truncEquivFinOfCardEq\",\n    \"Fintype.equivFinOfCardEq\",\n    \"Fin\",\n    \"specialization\"\n]"}
{"type": "∀ {α : Type u_1} {n : Type u_3} {m : Type u_4} {A : Matrix m m α} {B : Matrix m n α} {C : Matrix n m α}\n  {D : Matrix n n α},\n  Matrix.IsSymm A → Matrix.transpose B = C → Matrix.IsSymm D → Matrix.IsSymm (Matrix.fromBlocks A B C D)", "name": "Matrix.IsSymm.fromBlocks", "isProp": true, "docString": "A block matrix `A.fromBlocks B C D` is symmetric,\nif `A` and `D` are symmetric and `Bᵀ = C`. ", "terms": "[\n  \"block matrix\",\n  \"symmetric\",\n  \"transpose\"\n]"}
{"type": "(k G : Type u) → [inst : CommRing k] → [inst_1 : Monoid G] → ℕ → Rep k G", "name": "Rep.diagonal", "isProp": false, "docString": "The `k`-linear `G`-representation on `k[Gⁿ]`, induced by left multiplication. ", "terms": "[\n    \"linear\",\n    \"representation\",\n    \"induced\",\n    \"left multiplication\"\n]"}
{"type": "∀ {ι : Type u_1} {α : Type u_2} {s : ι → Set α}, IndexedPartition s → ∀ {x : α} {i j : ι}, x ∈ s i → x ∈ s j → i = j", "name": "IndexedPartition.eq_of_mem", "isProp": true, "docString": "two indexes are equal if they are equal in membership  ", "terms": "The mathematical terms in the given statement are:\n\n1. Indexes\n2. Equal\n3. Membership\n\nSo, as a JSON list, this would be represented as:\n\n```\n[\"Indexes\", \"Equal\", \"Membership\"]\n```"}
{"type": "{M : Type u_4} → [inst : CommMonoid M] → (S : Submonoid M) → Localization S → Localization S → Localization S", "name": "Localization.mul", "isProp": false, "docString": "Multiplication in a `Localization` is defined as `⟨a, b⟩ * ⟨c, d⟩ = ⟨a * c, b * d⟩`. ", "terms": "[\n    \"Multiplication\",\n    \"Localization\"\n]"}
{"type": "∀ {L : FirstOrder.Language} {M : Type u_1} [inst : FirstOrder.Language.Structure L M]\n  (S : FirstOrder.Language.Substructure L M),\n  (∀ (n : ℕ) (φ : FirstOrder.Language.BoundedFormula L Empty (n + 1)) (x : Fin n → ↥S) (a : M),\n      FirstOrder.Language.BoundedFormula.Realize φ default (Fin.snoc (Subtype.val ∘ x) a) →\n        ∃ b, FirstOrder.Language.BoundedFormula.Realize φ default (Fin.snoc (Subtype.val ∘ x) ↑b)) →\n    FirstOrder.Language.Substructure.IsElementary S", "name": "FirstOrder.Language.Substructure.isElementary_of_exists", "isProp": true, "docString": "The Tarski-Vaught test for elementarity of a substructure. ", "terms": "[\n    \"Tarski-Vaught test\",\n    \"elementarity\",\n    \"substructure\"\n]"}
{"type": "{R : Type u} → [self : NatCast R] → ℕ → R", "name": "NatCast.natCast", "isProp": false, "docString": "The canonical map `Nat → R`. ", "terms": "[\"canonical map\", \"Nat\", \"R\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      {X Y : C} →\n        (f : X ⟶ Y) →\n          (hf : f = 0) →\n            CategoryTheory.Limits.IsColimit\n              (CategoryTheory.Limits.CokernelCofork.ofπ (CategoryTheory.CategoryStruct.id Y)\n                (_ : CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.id Y) = 0))", "name": "CategoryTheory.Limits.CokernelCofork.IsColimit.ofId", "isProp": false, "docString": "`Y` identifies to the cokernel of a zero map `X ⟶ Y`. ", "terms": "[\n  \"identifies\",\n  \"cokernel\",\n  \"zero map\"\n]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      {S₁ S₂ : CategoryTheory.ShortComplex C} →\n        {φ : S₁ ⟶ S₂} →\n          {h₁ : CategoryTheory.ShortComplex.RightHomologyData S₁} →\n            {h₂ : CategoryTheory.ShortComplex.RightHomologyData S₂} →\n              CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂ → (h₁.Q ⟶ h₂.Q)", "name": "CategoryTheory.ShortComplex.RightHomologyMapData.φQ", "isProp": false, "docString": "the induced map on opcycles ", "terms": "[\"induced map\", \"opcycles\"]"}
{"type": "Lean.TrailingParserDescr", "name": "FinsetFamily.«term_\\\\_»", "isProp": false, "docString": "`s \\\\ t` is the finset of elements of the form `a \\ b` where `a ∈ s`, `b ∈ t`. ", "terms": "[\"finset\", \"elements\", \"form\", \"∈\"]"}
{"type": "∀ (p : ℕ → Prop) [inst : DecidablePred p] (n : ℕ), Nat.count p n = Fintype.card { k // k < n ∧ p k }", "name": "Nat.count_eq_card_fintype", "isProp": true, "docString": "`count p n` can be expressed as the cardinality of `{k // k < n ∧ p k}`. ", "terms": "[\n\"count\",\n\"expressed\",\n\"cardinality\",\n\"<\",\n\"∧\"\n]"}
{"type": "∀ {α : Type u_1} {r : Setoid α}, ∅ ∉ Setoid.classes r", "name": "Setoid.empty_not_mem_classes", "isProp": true, "docString": "The empty set is not an equivalence class. ", "terms": "[\n    \"empty set\",\n    \"equivalence class\"\n]"}
{"type": "{A : Type u_2} →\n  {B : Type u_3} →\n    {C : Type u_4} →\n      {D : Type u_5} →\n        [inst : AddMonoid A] →\n          [inst_1 : AddMonoid B] →\n            [inst_2 : AddMonoid C] →\n              [inst_3 : AddMonoid D] →\n                [inst_4 : TopologicalSpace A] →\n                  [inst_5 : TopologicalSpace B] →\n                    [inst_6 : TopologicalSpace C] →\n                      [inst_7 : TopologicalSpace D] →\n                        ContinuousAddMonoidHom A C → ContinuousAddMonoidHom B D → ContinuousAddMonoidHom (A × B) (C × D)", "name": "ContinuousAddMonoidHom.sum_map", "isProp": false, "docString": "Product of two continuous homomorphisms on different spaces.", "terms": "[\n  \"Product\",\n  \"Continuous\",\n  \"Homomorphisms\",\n  \"Spaces\"\n]"}
{"type": "∀ {α : Type u_2} {β : Type u_3} [inst : Preorder α] [inst_1 : LocallyFiniteOrder α] [inst_2 : Preorder β] (f : α → β),\n  Antitone f ↔ ∀ (a b : α), a ⩿ b → f b ≤ f a", "name": "antitone_iff_forall_wcovby", "isProp": true, "docString": "A function from a locally finite preorder is antitone if and only if it is antitone when\nrestricted to pairs satisfying `a ⩿ b`. ", "terms": "[\n    \"function\",\n    \"locally finite\",\n    \"preorder\",\n    \"antitone\",\n    \"restricted\",\n    \"pairs\",\n    \"satisfying\"\n]"}
{"type": "(β : Type u_3) →\n  (γ : Type u_4) →\n    [inst : ConditionallyCompleteLinearOrderedField β] → [inst_1 : ConditionallyCompleteLinearOrderedField γ] → β ≃+*o γ", "name": "LinearOrderedField.inducedOrderRingIso", "isProp": false, "docString": "The isomorphism of ordered rings between two conditionally complete linearly ordered fields. ", "terms": "[\n    \"isomorphism\",\n    \"ordered rings\",\n    \"conditionally complete\",\n    \"linearly ordered fields\"\n]"}
{"type": "∀ {ι : Type u_1} {α : Type u_2} [inst : LinearOrderedRing α] {σ : Equiv.Perm ι} {f g : ι → α} [inst_1 : Fintype ι],\n  Monovary f g →\n    (((Finset.sum Finset.univ fun i => f i * g (σ i)) < Finset.sum Finset.univ fun i => f i * g i) ↔\n      ¬Monovary f (g ∘ ⇑σ))", "name": "Monovary.sum_mul_comp_perm_lt_sum_mul_iff", "isProp": true, "docString": "**Strict inequality case of Rearrangement Inequality**: Pointwise multiplication of\n`f` and `g`, which monovary together, is strictly decreased by a permutation if and only if\n`f` and `g ∘ σ` do not monovary together. Stated by permuting the entries of `g`. ", "terms": "[\n    \"Strict inequality\",\n    \"Rearrangement Inequality\",\n    \"Pointwise multiplication\",\n    \"Monovary\",\n    \"Decreased\",\n    \"Permutation\",\n    \"Entries\"\n]"}
{"type": "{α : Type u_2} →\n  {β : Type u_3} → [inst : CommMonoid α] → [inst_1 : CommMonoid β] → {A : Set α} → {n : ℕ} → CommMonoid (A →*[n] β)", "name": "FreimanHom.commMonoid", "isProp": false, "docString": "`A →*[n] β` is a `CommMonoid`. ", "terms": "[\n  \"→*[n]\",\n  \"β\",\n  \"CommMonoid\"\n]"}
{"type": "{K : Type u_3} →\n  [inst : Field K] →\n    {L : Type u_4} → [inst_1 : Field L] → [inst_2 : Algebra K L] → {x : L} → IsIntegral K x → PowerBasis K ↥K⟮x⟯", "name": "IntermediateField.adjoin.powerBasis", "isProp": false, "docString": "The power basis `1, x, ..., x ^ (d - 1)` for `K⟮x⟯`,\nwhere `d` is the degree of the minimal polynomial of `x`. ", "terms": "[\n    \"power basis\",\n    \"degree\",\n    \"minimal polynomial\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {R : CategoryTheory.Functor Cᵒᵖ RingCat} →\n      (P : PresheafOfModules R) →\n        {X Y : Cᵒᵖ} → (f : X ⟶ Y) → ↑(PresheafOfModules.obj P X) →ₛₗ[R.map f] ↑(PresheafOfModules.obj P Y)", "name": "PresheafOfModules.map", "isProp": false, "docString": "If `P` is a presheaf of modules over a presheaf of rings `R`, both over some category `C`,\nand `f : X ⟶ Y` is a morphism in `Cᵒᵖ`, we construct the `R.map f`-semilinear map\nfrom the `R.obj X`-module `P.presheaf.obj X` to the `R.obj Y`-module `P.presheaf.obj Y`.\n ", "terms": "[\n    \"presheaf of modules\",\n    \"presheaf of rings\",\n    \"category\",\n    \"morphism\",\n    \"semilinear map\",\n    \"module\"\n]"}
{"type": "List ℕ → ℕ → Finset ℕ", "name": "Denumerable.raise'Finset", "isProp": false, "docString": "Makes `raise' l n` into a finset. Elements are distinct thanks to `raise'_sorted`. ", "terms": "[\"raise\", \"finset\", \"Elements\", \"distinct\", \"raise'_sorted\"]"}
{"type": "∀ {C : Type v} [inst : CommRing C] (n : ℕ+) {ψ : AddChar (ZMod ↑n) C},\n  AddChar.IsPrimitive ψ → ∀ (a : ZMod ↑n), ψ a = 1 ↔ a = 0", "name": "AddChar.IsPrimitive.zmod_char_eq_one_iff", "isProp": true, "docString": "A primitive additive character on `ZMod n` takes the value `1` only at `0`. ", "terms": "[\n  \"Primitive additive character\",\n  \"ZMod n\",\n  \"Value\",\n  \"1\",\n  \"0\"\n]"}
{"type": "∀ {X : Type u_1} [inst : TopologicalSpace X] {S : Set (Set X)},\n  Set.Countable S → (∀ s ∈ S, IsCompact s) → IsSigmaCompact (⋃₀ S)", "name": "isSigmaCompact_sUnion_of_isCompact", "isProp": true, "docString": "Countable unions of compact sets are σ-compact. ", "terms": "[\"Countable\", \"unions\", \"compact sets\", \"σ-compact\"]"}
{"type": "{I : Type v₁} →\n  {C : I → Type u₁} →\n    [inst : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)] →\n      {J : Type v₁} →\n        [inst_1 : CategoryTheory.SmallCategory J] →\n          {F : CategoryTheory.Functor J ((i : I) → C i)} →\n            {c : (i : I) → CategoryTheory.Limits.Cone (CategoryTheory.Functor.comp F (CategoryTheory.Pi.eval C i))} →\n              ((i : I) → CategoryTheory.Limits.IsLimit (c i)) →\n                CategoryTheory.Limits.IsLimit (CategoryTheory.pi.coneOfConeCompEval c)", "name": "CategoryTheory.pi.coneOfConeEvalIsLimit", "isProp": false, "docString": "Given a family of limit cones over the `F ⋙ Pi.eval C i`,\nassembling them together as a `Cone F` produces a limit cone.\n", "terms": "[\n    \"family\",\n    \"limit cones\",\n    \"Pi.eval\",\n    \"Cone\",\n    \"limit cone\"\n]"}
{"type": "{𝕜 : Type u} →\n  {ι : Type v} →\n    {E : ι → Type wE} →\n      {G : Type wG} →\n        {G' : Type wG'} →\n          [inst : Fintype ι] →\n            [inst_1 : NontriviallyNormedField 𝕜] →\n              [inst_2 : (i : ι) → NormedAddCommGroup (E i)] →\n                [inst_3 : (i : ι) → NormedSpace 𝕜 (E i)] →\n                  [inst_4 : NormedAddCommGroup G] →\n                    [inst_5 : NormedSpace 𝕜 G] →\n                      [inst_6 : NormedAddCommGroup G'] →\n                        [inst_7 : NormedSpace 𝕜 G'] →\n                          (f : G →ₗ[𝕜] MultilinearMap 𝕜 E G') →\n                            (C : ℝ) →\n                              (∀ (x : G) (m : (i : ι) → E i),\n                                  ‖(f x) m‖ ≤ C * ‖x‖ * Finset.prod Finset.univ fun i => ‖m i‖) →\n                                G →L[𝕜] ContinuousMultilinearMap 𝕜 E G'", "name": "MultilinearMap.mkContinuousLinear", "isProp": false, "docString": "Given a map `f : G →ₗ[𝕜] MultilinearMap 𝕜 E G'` and an estimate\n`H : ∀ x m, ‖f x m‖ ≤ C * ‖x‖ * ∏ i, ‖m i‖`, construct a continuous linear\nmap from `G` to `ContinuousMultilinearMap 𝕜 E G'`.\n\nIn order to lift, e.g., a map `f : (MultilinearMap 𝕜 E G) →ₗ[𝕜] MultilinearMap 𝕜 E' G'`\nto a map `(ContinuousMultilinearMap 𝕜 E G) →L[𝕜] ContinuousMultilinearMap 𝕜 E' G'`,\none can apply this construction to `f.comp ContinuousMultilinearMap.toMultilinearMapLinear`\nwhich is a linear map from `ContinuousMultilinearMap 𝕜 E G` to `MultilinearMap 𝕜 E' G'`. ", "terms": "[\n  \"map\",\n  \"MultilinearMap\",\n  \"estimate\",\n  \"continuous linear map\",\n  \"ContinuousMultilinearMap\",\n  \"lift\",\n  \"comp\",\n  \"linear map\"\n]"}
{"type": "∀ {α : Type u_1} (s t : Set α), Disjoint (s \\ t) (s ∩ t)", "name": "Set.disjoint_sdiff_inter", "isProp": true, "docString": "This lemma exists for finsets, but not for sets currently. porting note: move to\ndata.set.basic after the port. ", "terms": "[\"lemma\", \"finsets\", \"sets\", \"data.set.basic\", \"port\"]"}
{"type": "(M : Type u_2) →\n  [inst : CancelMonoidWithZero M] →\n    [inst : DecidableEq M] → [inst : Fintype M] → [inst : Nontrivial M] → GroupWithZero M", "name": "Fintype.groupWithZeroOfCancel", "isProp": false, "docString": "Every finite nontrivial cancel_monoid_with_zero is a group_with_zero. ", "terms": "[\n    \"finite\",\n    \"nontrivial\",\n    \"cancel_monoid_with_zero\",\n    \"group_with_zero\"\n]"}
{"type": "{α : Type u_1} →\n  [inst : CancelCommMonoidWithZero α] →\n    [inst_1 : NormalizationMonoid α] →\n      [inst_2 : DecidableEq α] →\n        (lcm : α → α → α) →\n          (∀ (a b : α), a ∣ lcm a b) →\n            (∀ (a b : α), b ∣ lcm a b) →\n              (∀ {a b c : α}, c ∣ a → b ∣ a → lcm c b ∣ a) →\n                (∀ (a b : α), normalize (lcm a b) = lcm a b) → NormalizedGCDMonoid α", "name": "normalizedGCDMonoidOfLCM", "isProp": false, "docString": "Define `NormalizedGCDMonoid` on a structure just from the `lcm` and its properties. ", "terms": "[\n  \"NormalizedGCDMonoid\",\n  \"structure\",\n  \"lcm\",\n  \"properties\"\n]"}
{"type": "Prop", "name": "FermatLastTheorem", "isProp": false, "docString": "Statement of Fermat's Last Theorem: `a ^ n + b ^ n = c ^ n` has no nontrivial natural solution\nwhen `n ≥ 3`. ", "terms": "[\n  \"Fermat's Last Theorem\",\n  \"nontrivial natural solution\",\n  \"n ≥ 3\"\n]"}
{"type": "∀ (α : Type u_1) (β : Type u_2) [inst : UniformSpace β] (𝔖 : Set (Set α)) (f : UniformOnFun α β 𝔖),\n  Set.Nonempty 𝔖 →\n    DirectedOn (fun x x_1 => x ⊆ x_1) 𝔖 →\n      Filter.HasBasis (nhds f) (fun SV => SV.1 ∈ 𝔖 ∧ SV.2 ∈ uniformity β) fun SV =>\n        {g | (g, f) ∈ UniformOnFun.gen 𝔖 SV.1 SV.2}", "name": "UniformOnFun.hasBasis_nhds", "isProp": true, "docString": "For `f : α →ᵤ[𝔖] β`, where `𝔖 : Set (Set α)` is nonempty and directed, `𝓝 f` admits the\nfamily `{g | ∀ x ∈ S, (f x, g x) ∈ V}` for `S ∈ 𝔖` and `V ∈ 𝓤 β` as a filter basis. ", "terms": "[\n    \"function\",\n    \"Set\",\n    \"nonempty\",\n    \"directed\",\n    \"neighborhood\",\n    \"family\",\n    \"filter basis\"\n]"}
{"type": "∀ {α : Type u_1} [inst : MeasurableSpace α] {A : Set α} {ι : Type u_2} (L : Filter ι)\n  [inst_1 : Filter.IsCountablyGenerated L] {As : ι → Set α} [inst_2 : Filter.NeBot L] {μ : MeasureTheory.Measure α},\n  (∀ (i : ι), MeasurableSet (As i)) →\n    ∀ {B : Set α},\n      MeasurableSet B →\n        ↑↑μ B ≠ ⊤ →\n          (∀ᶠ (i : ι) in L, As i ⊆ B) →\n            (∀ (x : α), ∀ᶠ (i : ι) in L, x ∈ As i ↔ x ∈ A) → Filter.Tendsto (fun i => ↑↑μ (As i)) L (nhds (↑↑μ A))", "name": "MeasureTheory.tendsto_measure_of_tendsto_indicator", "isProp": true, "docString": "If the indicators of measurable sets `Aᵢ` tend pointwise to the indicator of a set `A`\nand we eventually have `Aᵢ ⊆ B` for some set `B` of finite measure, then the measures of `Aᵢ`\ntend to the measure of `A`. ", "terms": "[\n    \"indicators\",\n    \"measurable sets\",\n    \"tend pointwise\",\n    \"set\",\n    \"eventually\",\n    \"subset\",\n    \"finite measure\",\n    \"measures\",\n    \"tend\"\n]"}
{"type": "∀ (M : Type u_1) (α : Type u_2) [inst : Monoid M] [inst_1 : MulAction M α] {ι : Sort u_3} {P : ι → Submonoid M},\n  MulAction.fixedPoints (↥(iSup P)) α = ⋂ i, MulAction.fixedPoints (↥(P i)) α", "name": "fixedPoints_submonoid_iSup", "isProp": true, "docString": "Fixed points of iSup of submonoids is intersection ", "terms": "[\n    \"Fixed points\",\n    \"iSup\",\n    \"submonoids\",\n    \"intersection\"\n]"}
{"type": "∀ {M : Type u_1} [inst : Mul M] {s : Set M} {S : Subsemigroup M}, Subsemigroup.closure s ≤ S ↔ s ⊆ ↑S", "name": "Subsemigroup.closure_le", "isProp": true, "docString": "A subsemigroup `S` includes `closure s` if and only if it includes `s`. ", "terms": "[\n    \"subsemigroup\",\n    \"includes\",\n    \"closure\",\n    \"if and only if\"\n]"}
{"type": "{M : Type u_1} →\n  {A : Type u_4} →\n    {B : Type u_5} →\n      [inst : Zero A] →\n        [inst_1 : SMulZeroClass M A] →\n          [inst_2 : Zero B] →\n            [inst_3 : SMul M B] → (f : ZeroHom A B) → (∀ (c : M) (x : A), f (c • x) = c • f x) → SMulZeroClass M B", "name": "ZeroHom.smulZeroClass", "isProp": false, "docString": "Pushforward a zero-preserving scalar multiplication along a zero-preserving map.\nSee note [reducible non-instances]. ", "terms": "[\n    \"Pushforward\",\n    \"zero-preserving\",\n    \"scalar multiplication\",\n    \"map\",\n    \"reducible\",\n    \"non-instances\"\n]"}
{"type": "∀ {K : Type u_1} [inst : DivisionRing K] {Γ₀ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Γ₀]\n  [inst_2 : Valued K Γ₀], TopologicalDivisionRing K", "name": "Valued.topologicalDivisionRing", "isProp": true, "docString": "The topology coming from a valuation on a division ring makes it a topological division ring\n[BouAC, VI.5.1 middle of Proposition 1] ", "terms": "[\n    \"topology\",\n    \"valuation\",\n    \"division ring\",\n    \"topological division ring\"\n]"}
{"type": "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : Finite ι] [inst : DecidableEq ι] [inst_1 : (i : ι) → DecidableEq (α i)]\n  (r : (i : ι) → α i → Finset (α i) → Prop),\n  (∀ (i : ι) (s : Finset (α i)), Finset.Nonempty s → ∃ x ∈ s, r i x (Finset.erase s x)) →\n    ∀ {p : ((i : ι) → Finset (α i)) → Prop} (f : (i : ι) → Finset (α i)),\n      (p fun x => ∅) →\n        (∀ (g : (i : ι) → Finset (α i)) (i : ι) (x : α i),\n            r i x (g i) → p g → p (Function.update g i (insert x (g i)))) →\n          p f", "name": "Finset.induction_on_pi_of_choice", "isProp": true, "docString": "General theorem for `Finset.induction_on_pi`-style induction principles. ", "terms": "[\n  \"General theorem\",\n  \"Finset.induction_on_pi\",\n  \"induction principles\"\n]"}
{"type": "∀ {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} {p : ENNReal} {μ : MeasureTheory.Measure α}\n  [inst : NormedAddCommGroup E] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  [inst_3 : SecondCountableTopologyEither α E] [inst_4 : MeasureTheory.IsFiniteMeasure μ]\n  (f : BoundedContinuousFunction α E),\n  ‖{ val := ContinuousMap.toAEEqFun μ f.toContinuousMap,\n        property := (_ : ContinuousMap.toAEEqFun μ f.toContinuousMap ∈ MeasureTheory.Lp E p) }‖ ≤\n    ↑(MeasureTheory.measureUnivNNReal μ) ^ (ENNReal.toReal p)⁻¹ * ‖f‖", "name": "BoundedContinuousFunction.Lp_norm_le", "isProp": true, "docString": "The `Lp`-norm of a bounded continuous function is at most a constant (depending on the measure\nof the whole space) times its sup-norm. ", "terms": "[\n    \"Lp-norm\", \n    \"bounded continuous function\", \n    \"constant\", \n    \"measure\", \n    \"whole space\", \n    \"sup-norm\"\n]"}
{"type": "Lean.ParserDescr", "name": "witt_truncateFun_tac", "isProp": false, "docString": "A macro tactic used to prove that `truncateFun` respects ring operations. ", "terms": "[\"macro tactic\", \"prove\", \"truncateFun\", \"respects\", \"ring operations\"]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      (S : CategoryTheory.ShortComplex C) → [inst : CategoryTheory.ShortComplex.HasRightHomology S] → C", "name": "CategoryTheory.ShortComplex.opcycles", "isProp": false, "docString": "The \"opcycles\" of a short complex, given by the `Q` field of a chosen right homology data.\nThis is the dual notion to cycles. ", "terms": "[\n    \"opcycles\",\n    \"short complex\",\n    \"Q field\",\n    \"chosen\",\n    \"right homology data\",\n    \"dual\",\n    \"notion\",\n    \"cycles\"\n]"}
{"type": "∀ {α : Type u_1} {l : Filter α} {f : α → ℝ},\n  ((fun x => Real.exp (f x)) =Θ[l] fun x => 1) ↔ Filter.IsBoundedUnder (fun x x_1 => x ≤ x_1) l fun x => |f x|", "name": "Real.isTheta_exp_comp_one", "isProp": true, "docString": "`Real.exp (f x)` is bounded away from zero and infinity along a filter `l` if and only if\n`|f x|` is bounded from above along this filter. ", "terms": "[\n\"Real.exp\",\n\"bounded away from zero\",\n\"infinity\",\n\"filter\",\n\"if and only if\",\n\"bounded from above\",\n\"absolute value\"\n]"}
{"type": "{n : ℕ} →\n  {α : TypeVec.{u_1} n} →\n    {β : TypeVec.{u_2} n} → {γ : TypeVec.{u_3} n} → TypeVec.Arrow β γ → TypeVec.Arrow α β → TypeVec.Arrow α γ", "name": "TypeVec.comp", "isProp": false, "docString": "arrow composition in the category of `TypeVec` ", "terms": "[\n    \"arrow composition\",\n    \"category\",\n    \"TypeVec\"\n]"}
{"type": "(𝕜 : Type u_1) →\n  {E : Type u_2} →\n    {F : Type u_3} →\n      [inst : NontriviallyNormedField 𝕜] →\n        [inst_1 : NormedAddCommGroup E] →\n          [inst_2 : NormedSpace 𝕜 E] →\n            [inst_3 : NormedAddCommGroup F] → [inst : NormedSpace 𝕜 F] → (E → F) → Set E → Prop", "name": "AnalyticOn", "isProp": false, "docString": "Given a function `f : E → F`, we say that `f` is analytic on a set `s` if it is analytic around\nevery point of `s`. ", "terms": "[\n    \"function\",\n    \"analytic\",\n    \"set\",\n    \"point\"\n]"}
{"type": "(𝕜 : Type u) →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type uE} →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : NormedSpace 𝕜 E] →\n          {F : Type uF} →\n            [inst_3 : NormedAddCommGroup F] →\n              [inst_4 : NormedSpace 𝕜 F] → (n : ℕ) → (E → F) → E → ContinuousMultilinearMap 𝕜 (fun i => E) F", "name": "iteratedFDeriv", "isProp": false, "docString": "The `n`-th derivative of a function, as a multilinear map, defined inductively. ", "terms": "[\n    \"derivative\",\n    \"function\",\n    \"multilinear map\",\n    \"defined\",\n    \"inductively\"\n]"}
{"type": "(α : Type u) → [inst : Random Id α] → SlimCheck.Gen α", "name": "SlimCheck.Gen.chooseAny", "isProp": false, "docString": "Lift `Random.random` to the `Gen` monad. ", "terms": "[\"Lift\", \"Random.random\", \"Gen\", \"monad\"]"}
{"type": "(A : Type u_1) → [inst : Add A] → Group (AddAut A)", "name": "AddAut.group", "isProp": false, "docString": "The group operation on additive automorphisms is defined by `g h => AddEquiv.trans h g`.\nThis means that multiplication agrees with composition, `(g*h)(x) = g (h x)`.\n", "terms": "[\n  \"group operation\",\n  \"additive automorphisms\",\n  \"defined\",\n  \"AddEquiv.trans\",\n  \"multiplication\",\n  \"agrees\",\n  \"composition\"\n]"}
{"type": "{α : Type u_1} →\n  {E : Type u_2} →\n    {m0 : MeasurableSpace α} →\n      (p : ENNReal) →\n        (μ : MeasureTheory.Measure α) →\n          [inst : NormedAddCommGroup E] →\n            [inst_1 : MeasureTheory.IsFiniteMeasure μ] →\n              (𝕜 : Type u_5) →\n                [inst_2 : NormedRing 𝕜] →\n                  [inst_3 : Module 𝕜 E] → [inst_4 : BoundedSMul 𝕜 E] → E →ₗ[𝕜] ↥(MeasureTheory.Lp E p)", "name": "MeasureTheory.Lp.constₗ", "isProp": false, "docString": "`MeasureTheory.Lp.const` as a `LinearMap`. ", "terms": "[\n  \"Measure Theory\",\n  \"Lp\",\n  \"const\",\n  \"Linear Map\"\n]"}
{"type": "{I : Type u} → (f : I → Type v) → [inst : (i : I) → Add (f i)] → (i : I) → AddHom ((i : I) → f i) (f i)", "name": "Pi.evalAddHom", "isProp": false, "docString": "Evaluation of functions into an indexed collection of additive semigroups at a point is an\nadditive semigroup homomorphism. This is `Function.eval i` as an `AddHom`.", "terms": "[\n    \"Evaluation of functions\",\n    \"indexed collection\",\n    \"additive semigroups\",\n    \"point\",\n    \"additive semigroup homomorphism\",\n    \"Function.eval\",\n    \"AddHom\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} {F : Type u_4} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β]\n  [inst_2 : DilationClass F α β] {f : F} {x y : α} {r : NNReal},\n  edist x y ≠ 0 → edist x y ≠ ⊤ → edist (f x) (f y) = ↑r * edist x y → r = Dilation.ratio f", "name": "Dilation.ratio_unique", "isProp": true, "docString": "The `ratio` is equal to the distance ratio for any two points with nonzero finite distance.\n`dist` and `nndist` versions below ", "terms": "[\"ratio\", \"equal\", \"distance\", \"points\", \"nonzero\", \"finite\"]"}
{"type": "∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂}, ‖0‖ = 0", "name": "ContinuousLinearMap.op_norm_zero", "isProp": true, "docString": "The norm of the `0` operator is `0`. ", "terms": "[\"norm\", \"operator\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    (D : AlgebraicGeometry.PresheafedSpace.GlueData C) →\n      [inst_1 : CategoryTheory.Limits.HasLimits C] →\n        (i j : D.J) → CategoryTheory.Limits.IsLimit (CategoryTheory.GlueData.vPullbackCone D.toGlueData i j)", "name": "AlgebraicGeometry.PresheafedSpace.GlueData.vPullbackConeIsLimit", "isProp": false, "docString": "The following diagram is a pullback, i.e. `Vᵢⱼ` is the intersection of `Uᵢ` and `Uⱼ` in `X`.\n\nVᵢⱼ ⟶ Uᵢ\n|      |\n↓      ↓\nUⱼ ⟶ X\n", "terms": "[\"pullback\", \"intersection\"]"}
{"type": "{P : ℕ → Sort u_1} → P 0 → ((n : ℕ) → P n → P (2 * n)) → ((n : ℕ) → P n → P (2 * n + 1)) → (n : ℕ) → P n", "name": "Nat.evenOddRec", "isProp": false, "docString": "Recursion principle on even and odd numbers: if we have `P 0`, and for all `i : ℕ` we can\nextend from `P i` to both `P (2 * i)` and `P (2 * i + 1)`, then we have `P n` for all `n : ℕ`.\nThis is nothing more than a wrapper around `Nat.binaryRec`, to avoid having to switch to\ndealing with `bit0` and `bit1`. ", "terms": "[\n  \"Recursion principle\",\n  \"Even numbers\",\n  \"Odd numbers\",\n  \"ℕ\",\n  \"Extend\",\n  \"2 * i\",\n  \"2 * i + 1\",\n  \"Nat.binaryRec\",\n  \"Bit0\",\n  \"Bit1\"\n]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {ι : Type u_1} {s : ι → C}\n  [inst_1 : CategoryTheory.Preadditive C] [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C]\n  [inst_3 : ∀ (i : ι), InvariantBasisNumber (CategoryTheory.End (s i))],\n  CategoryTheory.HomOrthogonal s →\n    ∀ {α β : Type} [inst_4 : Fintype α] [inst_5 : Fintype β] {f : α → ι} {g : β → ι},\n      ((⨁ fun a => s (f a)) ≅ ⨁ fun b => s (g b)) → ∃ e, ∀ (a : α), g (e a) = f a", "name": "CategoryTheory.HomOrthogonal.equiv_of_iso", "isProp": true, "docString": "Given a hom orthogonal family `s : ι → C`\nfor which each `End (s i)` is a ring with invariant basis number (e.g. if each `s i` is simple),\nif two direct sums over `s` are isomorphic, then they have the same multiplicities.\n", "terms": "[\n  \"hom orthogonal family\",\n  \"End\",\n  \"ring\",\n  \"invariant basis number\",\n  \"simple\",\n  \"direct sums\",\n  \"isomorphic\",\n  \"multiplicities\"\n]"}
{"type": "∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : LinearOrderedRing α] [inst_1 : LinearOrderedAddCommGroup β]\n  [inst_2 : Module α β] [inst_3 : OrderedSMul α β] {f : ι → α} {g : ι → β} {s : Set ι},\n  AntivaryOn f g s ↔ ∀ ⦃i : ι⦄, i ∈ s → ∀ ⦃j : ι⦄, j ∈ s → f i • g i + f j • g j ≤ f i • g j + f j • g i", "name": "antivaryOn_iff_smul_rearrangement", "isProp": true, "docString": "Two functions antivary iff the rearrangement inequality holds. ", "terms": "[\n    \"functions\",\n    \"antivary\",\n    \"rearrangement inequality\"\n]"}
{"type": "∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  ¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n →\n    GeneralizedContinuedFraction.numerators (GeneralizedContinuedFraction.of v) n *\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1) -\n        GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\n          GeneralizedContinuedFraction.numerators (GeneralizedContinuedFraction.of v) (n + 1) =\n      (-1) ^ (n + 1)", "name": "GeneralizedContinuedFraction.determinant", "isProp": true, "docString": "The determinant formula `Aₙ * Bₙ₊₁ - Bₙ * Aₙ₊₁ = (-1)^(n + 1)`. ", "terms": "[\n  \"determinant\",\n  \"formula\",\n  \"multiplication\",\n  \"subtraction\",\n  \"exponentiation\"\n]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]\n  {J : Type w} [inst_2 : CategoryTheory.Category.{w', w} J] (F : CategoryTheory.Functor C D)\n  [inst_3 : CategoryTheory.Limits.HasColimitsOfShape J D] [inst_4 : CategoryTheory.CreatesColimitsOfShape J F],\n  CategoryTheory.Limits.HasColimitsOfShape J C", "name": "CategoryTheory.hasColimitsOfShape_of_hasColimitsOfShape_createsColimitsOfShape", "isProp": true, "docString": "If `F` creates colimits of shape `J`, and `D` has colimits of shape `J`, then\n`C` has colimits of shape `J`.\n", "terms": "[\n  \"creates\",\n  \"colimits\",\n  \"shape\",\n  \"has\"\n]"}
{"type": "{V₁ : Type u_2} →\n  {V₂ : Type u_3} →\n    {V₃ : Type u_4} →\n      [inst : SeminormedAddCommGroup V₁] →\n        [inst_1 : SeminormedAddCommGroup V₂] →\n          [inst_2 : SeminormedAddCommGroup V₃] →\n            NormedAddGroupHom V₂ V₃ → NormedAddGroupHom V₁ V₂ → NormedAddGroupHom V₁ V₃", "name": "NormedAddGroupHom.comp", "isProp": false, "docString": "The composition of continuous normed group homs. ", "terms": "[\n    \"composition\",\n    \"continuous\",\n    \"normed\",\n    \"group\",\n    \"homs\"\n]"}
{"type": "∀ {g' g : ℝ → ℝ} {a b : ℝ},\n  a ≤ b →\n    ContinuousOn g (Set.Icc a b) →\n      (∀ x ∈ Set.Ioo a b, HasDerivWithinAt g (g' x) (Set.Ioi x) x) →\n        MeasureTheory.IntegrableOn g' (Set.Icc a b) → ∫ (y : ℝ) in a..b, g' y = g b - g a", "name": "intervalIntegral.integral_eq_sub_of_hasDeriv_right_of_le_real", "isProp": true, "docString": "Auxiliary lemma in the proof of `integral_eq_sub_of_hasDeriv_right_of_le`: real version ", "terms": "[\"Auxiliary lemma\", \"proof\", \"integral\", \"hasDeriv_right_of_le\", \"real version\"]"}
{"type": "∀ {α : Type u} [inst : AddGroup α] (g : AddGroupTopology α), Continuous fun p => p.1 + p.2", "name": "AddGroupTopology.continuous_add'", "isProp": true, "docString": "A version of the global `continuous_add` suitable for dot notation.", "terms": "[]\n"}
{"type": "ℤ → ℤ → ℚ", "name": "Rat.divInt", "isProp": false, "docString": "Form the quotient `n / d` where `n d : Int`. ", "terms": "[\"quotient\", \"Int\"]"}
{"type": "∀ (D : Type u_1) [inst : Finite D] [inst : Ring D] [inst_1 : IsDomain D], IsField D", "name": "Finite.isDomain_to_isField", "isProp": true, "docString": "A finite domain is a field. See also `littleWedderburn` and `Fintype.divisionRingOfIsDomain`. ", "terms": "[\n  \"finite domain\",\n  \"field\",\n  \"littleWedderburn\",\n  \"Fintype.divisionRingOfIsDomain\"\n]"}
{"type": "(C : Type u_1) →\n  [inst : CategoryTheory.Category.{u_3, u_1} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      {ι : Type u_2} →\n        (c : ComplexShape ι) →\n          (i j k : ι) →\n            [inst_2 : CategoryTheory.CategoryWithHomology C] →\n              ComplexShape.prev c j = i →\n                ComplexShape.next c j = k →\n                  (HomologicalComplex.homologyFunctor C c j ≅\n                    CategoryTheory.Functor.comp (HomologicalComplex.shortComplexFunctor' C c i j k)\n                      (CategoryTheory.ShortComplex.homologyFunctor C))", "name": "HomologicalComplex.homologyFunctorIso'", "isProp": false, "docString": "The natural isomorphism `K.homology j ≅ (K.sc' i j k).homology`\nfor all homological complexes `K` when `c.prev j = i` and `c.next j = k`. ", "terms": "[\n    \"natural isomorphism\",\n    \"homology\",\n    \"homological complexes\",\n    \"prev\",\n    \"next\"\n]"}
{"type": "∀ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {π : X → Y}\n  [inst_2 : SecondCountableTopology X], QuotientMap π → IsOpenMap π → SecondCountableTopology Y", "name": "QuotientMap.secondCountableTopology", "isProp": true, "docString": "A second countable space is mapped by an open quotient map to a second countable space. ", "terms": "[\n    \"second countable space\",\n    \"mapped\",\n    \"open quotient map\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {B : Type u_2} (F : Type u_4) (E : B → Type u_6) [inst : NontriviallyNormedField 𝕜] {EB : Type u_7}\n  [inst_1 : NormedAddCommGroup EB] [inst_2 : NormedSpace 𝕜 EB] {HB : Type u_8} [inst_3 : TopologicalSpace HB]\n  (IB : ModelWithCorners 𝕜 EB HB) [inst_4 : TopologicalSpace B] [inst_5 : ChartedSpace HB B]\n  [inst_6 : (x : B) → AddCommMonoid (E x)] [inst_7 : (x : B) → Module 𝕜 (E x)] [inst_8 : NormedAddCommGroup F]\n  [inst_9 : NormedSpace 𝕜 F] [inst_10 : TopologicalSpace (Bundle.TotalSpace F E)]\n  [inst_11 : (x : B) → TopologicalSpace (E x)] [inst_12 : FiberBundle F E] [inst_13 : VectorBundle 𝕜 F E]\n  [inst_14 : SmoothVectorBundle F E IB], HasGroupoid (Bundle.TotalSpace F E) (smoothFiberwiseLinear B F IB)", "name": "SmoothFiberwiseLinear.hasGroupoid", "isProp": true, "docString": "For a smooth vector bundle `E` over `B` with fiber modelled on `F`, the change-of-co-ordinates\nbetween two trivializations `e`, `e'` for `E`, considered as charts to `B × F`, is smooth and\nfiberwise linear. ", "terms": "[\n    \"Smooth vector bundle\",\n    \"Over\",\n    \"Fiber\",\n    \"Modeled\",\n    \"Change-of-coordinates\",\n    \"Trivializations\",\n    \"Charts\",\n    \"Smooth\",\n    \"Fiberwise linear\"\n]"}
{"type": "∀ {M : Type u_1} [inst : Monoid M] (x : M), IsSubmonoid (powers x)", "name": "powers.isSubmonoid", "isProp": true, "docString": "The set of natural number powers of an element of a monoid `M` is a submonoid of `M`. ", "terms": "[\n  \"set\",\n  \"natural number\",\n  \"powers\",\n  \"element\",\n  \"monoid\",\n  \"submonoid\"\n]"}
{"type": "{α : Type u_2} → [inst : AddCommSemigroup α] → AddCommSemigroup (Filter α)", "name": "Filter.addCommSemigroup", "isProp": false, "docString": "`Filter α` is an `AddCommSemigroup` under pointwise operations if `α` is.", "terms": "[\n    \"Filter\",\n    \"AddCommSemigroup\",\n    \"pointwise operations\"\n]"}
{"type": "{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → BilinForm R M → M → M → Prop", "name": "BilinForm.IsOrtho", "isProp": false, "docString": "The proposition that two elements of a bilinear form space are orthogonal. For orthogonality\nof an indexed set of elements, use `BilinForm.iIsOrtho`. ", "terms": "[\n  \"proposition\",\n  \"elements\",\n  \"bilinear form space\",\n  \"orthogonal\",\n  \"orthogonality\",\n  \"indexed set of elements\",\n  \"BilinForm.iIsOrtho\"\n]"}
{"type": "(R : Type u_1) → [inst : AddCommGroup R] → [inst_1 : StarAddMonoid R] → AddSubgroup R", "name": "skewAdjoint", "isProp": false, "docString": "The skew-adjoint elements of a star additive group, as an additive subgroup. ", "terms": "[\n  \"skew-adjoint elements\",\n  \"star additive group\",\n  \"additive subgroup\"\n]"}
{"type": "{α : Sort u} → PLift α ≃ α", "name": "Equiv.plift", "isProp": false, "docString": "`PLift α` is equivalent to `α`. ", "terms": "[\"PLift\", \"equivalent\"]"}
{"type": "{ι : Type u} →\n  CategoryTheory.Functor (CategoryTheory.Discrete ι) AlgebraicGeometry.LocallyRingedSpace →\n    AlgebraicGeometry.LocallyRingedSpace", "name": "AlgebraicGeometry.LocallyRingedSpace.coproduct", "isProp": false, "docString": "The explicit coproduct for `F : discrete ι ⥤ LocallyRingedSpace`. ", "terms": "[\n    \"explicit coproduct\",\n    \"F\",\n    \"discrete\",\n    \"ι\",\n    \"⥤\",\n    \"LocallyRingedSpace\"\n]"}
{"type": "{P : ℤ → Prop} →\n  [inst : DecidablePred P] → (b : ℤ) → (∀ (z : ℤ), P z → z ≤ b) → (∃ z, P z) → { ub // P ub ∧ ∀ (z : ℤ), P z → z ≤ ub }", "name": "Int.greatestOfBdd", "isProp": false, "docString": "A computable version of `exists_greatest_of_bdd`: given a decidable predicate on the\nintegers, with an explicit upper bound and a proof that it is somewhere true, return\nthe greatest value for which the predicate is true. ", "terms": "[\n    \"computable\",\n    \"exists_greatest_of_bdd\",\n    \"decidable predicate\",\n    \"integers\",\n    \"explicit upper bound\",\n    \"proof\",\n    \"true\",\n    \"greatest value\",\n    \"predicate\"\n]"}
{"type": "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α]\n  [inst_3 : DenselyOrdered α] (a b : α), Filter.comap Subtype.val (nhdsWithin a (Set.Ioi a)) = Filter.atBot", "name": "comap_coe_Ioo_nhdsWithin_Ioi", "isProp": true, "docString": "The `atBot` filter for an open interval `Ioo a b` comes from the right-neighbourhoods filter at\nthe left endpoint in the ambient order. ", "terms": "[\n    \"atBot filter\",\n    \"open interval\",\n    \"right-neighbourhoods filter\",\n    \"left endpoint\",\n    \"ambient order\"\n]"}
{"type": "USize → Fin USize.size", "name": "USize.val", "isProp": false, "docString": "Unpack a `USize` as a `Nat` less than `USize.size`.\nThis function is overridden with a native implementation. ", "terms": "[\"Unpack\", \"USize\", \"Nat\", \"less than\", \"USize.size\", \"function\", \"overridden\", \"native implementation\"]"}
{"type": "{C D : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Category.{v, u} D] →\n      {G : CategoryTheory.Functor C D} →\n        {A : Type w} →\n          [inst_2 : CategoryTheory.Category.{max u v, w} A] →\n            [inst_3 : CategoryTheory.Limits.HasLimits A] →\n              {J : CategoryTheory.GrothendieckTopology C} →\n                {K : CategoryTheory.GrothendieckTopology D} →\n                  [inst_4 : CategoryTheory.Functor.IsCocontinuous G J K] →\n                    (ℱ : CategoryTheory.Sheaf J A) →\n                      {X : A} →\n                        {U : D} →\n                          {S : CategoryTheory.Sieve U} →\n                            S ∈ CategoryTheory.GrothendieckTopology.sieves K U →\n                              {x :\n                                  CategoryTheory.Presieve.FamilyOfElements\n                                    (CategoryTheory.Functor.comp ((CategoryTheory.ran G.op).obj ℱ.val)\n                                      (CategoryTheory.coyoneda.obj (Opposite.op X)))\n                                    S.arrows} →\n                                CategoryTheory.Presieve.FamilyOfElements.Compatible x →\n                                  (Y : CategoryTheory.StructuredArrow (Opposite.op U) G.op) → X ⟶ ℱ.val.obj Y.right", "name": "CategoryTheory.RanIsSheafOfIsCocontinuous.getSection", "isProp": false, "docString": "Given a `G(Y) ⊆ U`, we can find a unique section `X ⟶ ℱ(Y)` that agrees with `x`. ", "terms": "[\n  \"subset\",\n  \"unique\",\n  \"section\",\n  \"agrees\"\n]"}
{"type": "{α : Type u_1} → α → List α → List (List α)", "name": "List.permutations'Aux", "isProp": false, "docString": "`permutations'Aux t ts` inserts `t` into every position in `ts`, including the last.\nThis function is intended for use in specifications, so it is simpler than `permutationsAux2`,\nwhich plays roughly the same role in `permutations`.\n\nNote that `(permutationsAux2 t [] [] ts id).2` is similar to this function, but skips the last\nposition:\n\n    permutations'Aux 10 [1, 2, 3] =\n      [[10, 1, 2, 3], [1, 10, 2, 3], [1, 2, 10, 3], [1, 2, 3, 10]]\n    (permutationsAux2 10 [] [] [1, 2, 3] id).2 =\n      [[10, 1, 2, 3], [1, 10, 2, 3], [1, 2, 10, 3]] ", "terms": "The mathematical terms in the provided statement are:\n\n```json\n[\n    \"permutations\",\n    \"inserts\",\n    \"position\",\n    \"function\",\n    \"specifications\",\n    \"simpler\",\n    \"role\",\n    \"similar\",\n    \"skips\",\n    \"last position\",\n    \"id\"\n]\n```"}
{"type": "Lean.Server.DocumentMeta →\n  Lean.Lsp.Range → String → optParam (Option Lean.Lsp.Range) none → ProofWidgets.MakeEditLinkProps", "name": "ProofWidgets.MakeEditLinkProps.ofReplaceRange'", "isProp": false, "docString": "Replace `range` with `newText`.\nIf `newSelection?` is absent, place the cursor at the end of the new text.\nIf `newSelection?` is present, make the specified selection instead.\nSee also `MakeEditLinkProps.ofReplaceRange`.\n", "terms": "[]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_3, u_1} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      {S : CategoryTheory.ShortComplex C} →\n        CategoryTheory.ShortComplex.ShortExact S →\n          [inst_2 : CategoryTheory.Injective S.X₁] →\n            [inst_3 : CategoryTheory.Balanced C] → CategoryTheory.ShortComplex.Splitting S", "name": "CategoryTheory.ShortComplex.ShortExact.splittingOfInjective", "isProp": false, "docString": "A choice of splitting for a short exact short complex `S` in a balanced category\nsuch that `S.X₁` is injective. ", "terms": "[\n  \"choice\",\n  \"splitting\",\n  \"short exact complex\",\n  \"balanced category\",\n  \"injective\"\n]"}
{"type": "{R : Type u} →\n  {M : Type v} →\n    {M₂ : Type w} →\n      {M₃ : Type y} →\n        [inst : Semiring R] →\n          [inst_1 : AddCommMonoid M] →\n            [inst_2 : AddCommMonoid M₂] →\n              [inst_3 : AddCommMonoid M₃] →\n                [inst_4 : Module R M] →\n                  [inst_5 : Module R M₂] → [inst_6 : Module R M₃] → (M →ₗ[R] M₂) → (M →ₗ[R] M₃) → M →ₗ[R] M₂ × M₃", "name": "LinearMap.prod", "isProp": false, "docString": "The prod of two linear maps is a linear map. ", "terms": "[\"prod\", \"linear maps\"]"}
{"type": "∀ {R : Type u_1} [inst : CommSemiring R] {M : Type u_4} {N : Type u_5} {P : Type u_6} [inst_1 : AddCommMonoid M]\n  [inst_2 : AddCommMonoid N] [inst_3 : AddCommMonoid P] [inst_4 : Module R M] [inst_5 : Module R N]\n  [inst_6 : Module R P] {g h : TensorProduct R M N →ₗ[R] P},\n  LinearMap.compr₂ (TensorProduct.mk R M N) g = LinearMap.compr₂ (TensorProduct.mk R M N) h → g = h", "name": "TensorProduct.ext", "isProp": true, "docString": "This used to be an `@[ext]` lemma, but it fails very slowly when the `ext` tactic tries to apply\nit in some cases, notably when one wants to show equality of two linear maps. The `@[ext]`\nattribute is now added locally where it is needed. Using this as the `@[ext]` lemma instead of\n`TensorProduct.ext'` allows `ext` to apply lemmas specific to `M →ₗ _` and `N →ₗ _`.\n\nSee note [partially-applied ext lemmas]. ", "terms": "[\"lemma\", \"tactic\", \"equality\", \"linear maps\", \"attribute\", \"TensorProduct.ext'\", \"lemmas\", \"partially-applied ext lemmas\"]"}
{"type": "Computability.FinEncoding ℕ", "name": "Computability.finEncodingNatBool", "isProp": false, "docString": "A binary fin_encoding of ℕ in bool. ", "terms": "[\n \"binary\",\n \"fin_encoding\",\n \"ℕ\",\n \"bool\"\n]"}
{"type": "{R : Type u_1} →\n  [inst : Semiring R] →\n    {M : Type u_2} →\n      [inst_1 : AddCommMonoid M] →\n        [inst_2 : Module R M] →\n          {ι : Type u_7} →\n            {ι' : Type u_10} →\n              {N : ι' → Type u_11} →\n                [inst_3 : (i : ι') → AddCommMonoid (N i)] →\n                  [inst_4 : (i : ι') → Module R (N i)] → ((i : ι') → M [Λ^ι]→ₗ[R] N i) → M [Λ^ι]→ₗ[R] ((i : ι') → N i)", "name": "AlternatingMap.pi", "isProp": false, "docString": "Combine a family of alternating maps with the same domain and codomains `N i` into an\nalternating map taking values in the space of functions `Π i, N i`. ", "terms": "[\n    \"family\",\n    \"alternating maps\",\n    \"domain\",\n    \"codomains\",\n    \"space of functions\"\n]"}
{"type": "∀ {β : Type v} {π : β → Type u_3} [inst : Fintype β] [inst_1 : (b : β) → PseudoMetricSpace (π b)] (x : (b : β) → π b)\n  {r : ℝ},\n  0 < r ∨ Nonempty β → Metric.sphere x r = (⋃ i, Function.eval i ⁻¹' Metric.sphere (x i) r) ∩ Metric.closedBall x r", "name": "sphere_pi", "isProp": true, "docString": "A sphere in a product space is a union of spheres on each component restricted to the closed\nball. ", "terms": "[\n    \"Sphere\",\n    \"Product Space\",\n    \"Union\",\n    \"Component\",\n    \"Restricted\",\n    \"Closed Ball\"\n]"}
{"type": "{B : Type u_2} →\n  {F : Type u_3} →\n    {Z : Type u_5} →\n      [inst : TopologicalSpace B] →\n        [inst_1 : TopologicalSpace F] → {proj : Z → B} → Pretrivialization F proj → Z → B × F", "name": "Pretrivialization.toFun'", "isProp": false, "docString": "Coercion of a pretrivialization to a function. We don't use `e.toFun` in the `CoeFun` instance\nbecause it is actually `e.toPartialEquiv.toFun`, so `simp` will apply lemmas about\n`toPartialEquiv`. While we may want to switch to this behavior later, doing it mid-port will break a\nlot of proofs.  ", "terms": "[\"Coercion\", \"pretrivialization\", \"function\", \"CoeFun\", \"instance\", \"toPartialEquiv\", \"lemmas\", \"proofs\"]"}
{"type": "∀ {G : Type u_1} [inst : Group G] {p : ℕ} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\n  [inst_3 : Finite (Sylow p ↥N)] (P : Sylow p G), ↑P ≤ N → Subgroup.normalizer ↑P ⊔ N = ⊤", "name": "Sylow.normalizer_sup_eq_top'", "isProp": true, "docString": "**Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\nof `N`, then `N_G(P) ⊔ N = G`. ", "terms": "[\n    \"Frattini's Argument\",\n    \"normal subgroup\",\n    \"Sylow p-subgroup\",\n    \"N_G(P)\"\n]"}
{"type": "∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (s : Set P) (p : P),\n  FiniteDimensional.finrank k ↥(vectorSpan k (insert p s)) ≤ FiniteDimensional.finrank k ↥(vectorSpan k s) + 1", "name": "finrank_vectorSpan_insert_le_set", "isProp": true, "docString": "Adding a point to a set with a finite-dimensional span increases the dimension by at most\none. ", "terms": "[\n    \"Adding\",\n    \"Point\",\n    \"Set\",\n    \"Finite-dimensional\",\n    \"Span\",\n    \"Increases\",\n    \"Dimension\"\n]"}
{"type": "{B : Type u_2} →\n  {F : Type u_3} →\n    {E : B → Type u_4} →\n      [inst : TopologicalSpace B] →\n        [inst_1 : TopologicalSpace F] →\n          [inst_2 : TopologicalSpace (Bundle.TotalSpace F E)] →\n            [inst_3 : (x : B) → Zero (E x)] → Trivialization F Bundle.TotalSpace.proj → (b : B) → F → E b", "name": "Trivialization.symm", "isProp": false, "docString": "A fiberwise inverse to `e'`. The function `F → E x` that induces a local inverse\n`B × F → TotalSpace F E` of `e'` on `e'.baseSet`. It is defined to be `0` outside `e'.baseSet`. ", "terms": "[\n  \"fiberwise inverse\",\n  \"function\",\n  \"induces\",\n  \"local inverse\",\n  \"TotalSpace\",\n  \"baseSet\",\n  \"defined\",\n  \"outside\"\n]"}
{"type": "∀ {a : ℤ} {b : ℕ}, Int.gcd a ↑b = 1 → jacobiSym (a ^ 2) b = 1", "name": "jacobiSym.sq_one'", "isProp": true, "docString": "The symbol `J(a^2 | b)` is `1` when `a` and `b` are coprime. ", "terms": "[\"coprime\"]"}
{"type": "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → Finset α → Finset α", "name": "Finset.filter", "isProp": false, "docString": "`Finset.filter p s` is the set of elements of `s` that satisfy `p`. ", "terms": "[\"Finset.filter\", \"set\", \"elements\", \"satisfy\"]"}
{"type": "{C : Type u} →\n  {D : Type u'} →\n    [inst : CategoryTheory.Category.{v', u'} D] →\n      [inst_1 : CategoryTheory.MonoidalCategory D] →\n        (f : C → D) →\n          (X Y : CategoryTheory.FreeMonoidalCategory C) →\n            (X ⟶ Y) →\n              (CategoryTheory.FreeMonoidalCategory.projectObj f X ⟶ CategoryTheory.FreeMonoidalCategory.projectObj f Y)", "name": "CategoryTheory.FreeMonoidalCategory.projectMap", "isProp": false, "docString": "Auxiliary definition for `FreeMonoidalCategory.project`. ", "terms": "[]"}
{"type": "Mathlib.Notation3.Matcher → Mathlib.Notation3.Matcher → Mathlib.Notation3.Matcher", "name": "Mathlib.Notation3.matchApp", "isProp": false, "docString": "Matches applications. ", "terms": "[]"}
{"type": "{α : Type u_1} → [inst : DecidableEq α] → (l : List α) → (x : α) → x ∈ l → α", "name": "List.next", "isProp": false, "docString": "Given an element `x : α` of `l : List α` such that `x ∈ l`, get the next\nelement of `l`. This works from head to tail, (including a check for last element)\nso it will match on first hit, ignoring later duplicates.\n\nFor example:\n * `next [1, 2, 3] 2 _ = 3`\n * `next [1, 2, 3] 3 _ = 1`\n * `next [1, 2, 3, 2, 4] 2 _ = 3`\n * `next [1, 2, 3, 2] 2 _ = 3`\n * `next [1, 1, 2, 3, 2] 1 _ = 1`\n", "terms": "[\"element\", \"List\", \"∈\", \"next\", \"head\", \"tail\", \"check\", \"last element\", \"match\", \"first hit\", \"ignoring\", \"later\", \"duplicates\", \"example\"]"}
{"type": "{α : Type u} → {β : α → Type v} → [inst : DecidableEq α] → (a : α) → β a → AList β → AList β", "name": "AList.replace", "isProp": false, "docString": "Replace a key with a given value in an association list.\nIf the key is not present it does nothing. ", "terms": "[]\n"}
{"type": "∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]\n  {H : Type uH} [inst_3 : TopologicalSpace H] (I : ModelWithCorners ℝ E H) {M : Type u_1} [inst_4 : EMetricSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : SigmaCompactSpace M] {K U : ι → Set M},\n  (∀ (i : ι), IsClosed (K i)) →\n    (∀ (i : ι), IsOpen (U i)) →\n      (∀ (i : ι), K i ⊆ U i) →\n        LocallyFinite K →\n          ∃ δ, (∀ (x : M), 0 < δ x) ∧ ∀ (i : ι), ∀ x ∈ K i, EMetric.closedBall x (ENNReal.ofReal (δ x)) ⊆ U i", "name": "Emetric.exists_smooth_forall_closedBall_subset", "isProp": true, "docString": "Let `M` be a smooth σ-compact manifold with extended distance. Let `K : ι → Set M` be a locally\nfinite family of closed sets, let `U : ι → Set M` be a family of open sets such that `K i ⊆ U i` for\nall `i`. Then there exists a positive smooth function `δ : M → ℝ≥0` such that for any `i` and\n`x ∈ K i`, we have `EMetric.closedBall x (δ x) ⊆ U i`. ", "terms": "[\n\"smooth\",\n\"σ-compact\",\n\"manifold\",\n\"extended distance\",\n\"locally finite family\",\n\"closed sets\",\n\"open sets\",\n\"subset\",\n\"positive\",\n\"function\",\n\"EMetric.closedBall\"\n]"}
{"type": "(p : Prop) → Decidable p", "name": "Classical.dec", "isProp": false, "docString": "Any prop `p` is decidable classically. A shorthand for `Classical.propDecidable`. ", "terms": "[\"prop\", \"decidable\", \"classically\", \"Classical\", \"propDecidable\"]"}
{"type": "{J : Type v} →\n  [inst : CategoryTheory.SmallCategory J] →\n    [inst_1 : CategoryTheory.IsFiltered J] →\n      (F : CategoryTheory.Functor J CommRingCat) →\n        CategoryTheory.Limits.IsColimit (CommRingCat.FilteredColimits.colimitCocone F)", "name": "CommRingCat.FilteredColimits.colimitCoconeIsColimit", "isProp": false, "docString": "The proposed colimit cocone is a colimit in `CommRing`. ", "terms": "[\n    \"colimit\",\n    \"cocone\",\n    \"CommRing\"\n]"}
{"type": "{𝕜 : Type u_1} →\n  {V : Type u_2} →\n    {V₂ : Type u_4} →\n      {P : Type u_8} →\n        {P₂ : Type u_9} →\n          [inst : NormedField 𝕜] →\n            [inst_1 : SeminormedAddCommGroup V] →\n              [inst_2 : SeminormedAddCommGroup V₂] →\n                [inst_3 : NormedSpace 𝕜 V] →\n                  [inst_4 : NormedSpace 𝕜 V₂] →\n                    [inst_5 : PseudoMetricSpace P] →\n                      [inst_6 : PseudoMetricSpace P₂] →\n                        [inst_7 : NormedAddTorsor V P] → [inst_8 : NormedAddTorsor V₂ P₂] → (P ≃ᵃⁱ[𝕜] P₂) → V ≃ₗᵢ[𝕜] V₂", "name": "AffineIsometryEquiv.linearIsometryEquiv", "isProp": false, "docString": "The underlying linear equiv of an affine isometry equiv is in fact a linear isometry equiv. ", "terms": "[\n    \"underlying\",\n    \"linear\",\n    \"equiv\",\n    \"affine\",\n    \"isometry\",\n    \"in fact\",\n    \"isometry\"\n]"}
{"type": "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : DecidableEq ι] [inst_1 : (i : ι) → Zero (α i)] {s : Finset ι}\n  {f : Π₀ (i : ι), α i} [inst_2 : (i : ι) → DecidableEq (α i)] {t : Π₀ (i : ι), Finset (α i)},\n  DFinsupp.support t ⊆ s → (f ∈ Finset.dfinsupp s ⇑t ↔ ∀ (i : ι), f i ∈ t i)", "name": "Finset.mem_dfinsupp_iff_of_support_subset", "isProp": true, "docString": "When `t` is supported on `s`, `f ∈ s.dfinsupp t` precisely means that `f` is pointwise in `t`.\n", "terms": "[\n\"supported\",\n\"dfinsupp\",\n\"pointwise\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {J : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} J] →\n        (F : CategoryTheory.Functor Jᵒᵖ Cᵒᵖ) →\n          {c : CategoryTheory.Limits.Cone (CategoryTheory.Functor.unop F)} →\n            CategoryTheory.Limits.IsLimit c → CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.coconeOfConeUnop c)", "name": "CategoryTheory.Limits.isColimitConeOfCoconeUnop", "isProp": false, "docString": "Turn a limit for `F.unop : J ⥤ C` into a colimit for `F : Jᵒᵖ ⥤ Cᵒᵖ`. ", "terms": "[\n    \"limit\",\n    \"unop\",\n    \"colimit\"\n]"}
{"type": "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace E] {f : E → F} {f' : E ≃L[𝕜] F} {a : E},\n  HasStrictFDerivAt f (↑f') a →\n    ∀ {g : F → E}, (∀ᶠ (x : E) in nhds a, g (f x) = x) → HasStrictFDerivAt g (↑(ContinuousLinearEquiv.symm f')) (f a)", "name": "HasStrictFDerivAt.to_local_left_inverse", "isProp": true, "docString": "If `f : E → F` has an invertible derivative `f'` at `a` in the sense of strict differentiability\nand `g (f x) = x` in a neighborhood of `a`, then `g` has derivative `f'.symm` at `f a`.\n\nFor a version assuming `f (g y) = y` and continuity of `g` at `f a` but not `[CompleteSpace E]`\nsee `of_local_left_inverse`.  ", "terms": "[\n    \"function\",\n    \"invertible derivative\",\n    \"strict differentiability\",\n    \"neighborhood\",\n    \"derivative\",\n    \"continuity\",\n    \"CompleteSpace\",\n    \"of_local_left_inverse\"\n]"}
{"type": "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X → Y},\n  IsProperMap f → IsClosedMap f", "name": "IsProperMap.isClosedMap", "isProp": true, "docString": "A proper map is closed. ", "terms": "[\"proper map\", \"closed\"]"}
{"type": "(V : Type u_6) → (P : Type u_7) → [inst : SeminormedAddCommGroup V] → [inst : AddTorsor V P] → PseudoMetricSpace P", "name": "pseudoMetricSpaceOfNormedAddCommGroupOfAddTorsor", "isProp": false, "docString": "The pseudodistance defines a pseudometric space structure on the torsor. This\nis not an instance because it depends on `V` to define a `MetricSpace P`. ", "terms": "[\n  \"pseudodistance\", \n  \"pseudometric space\", \n  \"structure\", \n  \"torsor\", \n  \"instance\", \n  \"MetricSpace\"\n]"}
{"type": "∀ {α : Type u} [inst : TopologicalSpace α] (x : α) (C : Set α),\n  AccPt x (Filter.principal C) ↔ ∀ U ∈ nhds x, ∃ y ∈ U ∩ C, y ≠ x", "name": "accPt_iff_nhds", "isProp": true, "docString": "`x` is an accumulation point of a set `C` iff every neighborhood\nof `x` contains a point of `C` other than `x`. ", "terms": "[\n    \"Accumulation Point\",\n    \"Set\",\n    \"Neighborhood\",\n    \"Contains\",\n    \"Point\"\n]"}
{"type": "∀ {α : Type u_4} [self : GeneralizedCoheytingAlgebra α] (a b c : α), a \\ b ≤ c ↔ a ≤ b ⊔ c", "name": "GeneralizedCoheytingAlgebra.sdiff_le_iff", "isProp": true, "docString": "`\\ a` is right adjoint to `⊔ a` ", "terms": "[\"right adjoint\"]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] → {T : CategoryTheory.Monad C} → CategoryTheory.Monad.Algebra T → C", "name": "CategoryTheory.Monad.Algebra.A", "isProp": false, "docString": "The underlying object associated to an algebra. ", "terms": "[\"underlying object\", \"associated\", \"algebra\"]"}
{"type": "{a : ℕ} → 1 < a → ℕ → ℕ × ℕ", "name": "Pell.pell", "isProp": false, "docString": "The Pell sequences, i.e. the sequence of integer solutions to `x ^ 2 - d * y ^ 2 = 1`, where\n`d = a ^ 2 - 1`, defined together in mutual recursion. ", "terms": "[\n    \"Pell sequences\",\n    \"sequence\",\n    \"integer solutions\",\n    \"x ^ 2 - d * y ^ 2 = 1\",\n    \"d = a ^ 2 - 1\",\n    \"mutual recursion\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {s : Set α},\n  StrictMonoOn f s → StrictAntiOn (⇑OrderDual.toDual ∘ f) s", "name": "StrictMonoOn.dual_right", "isProp": true, "docString": "**Alias** of the reverse direction of `strictAntiOn_toDual_comp_iff`.", "terms": "[\"Alias\", \"reverse direction\", \"strictAntiOn_toDual_comp_iff\"]"}
{"type": "{V : Type u} →\n  {G : SimpleGraph V} → {K L : Set V} → K ⊆ L → SimpleGraph.ComponentCompl G L → SimpleGraph.ComponentCompl G K", "name": "SimpleGraph.ComponentCompl.hom", "isProp": false, "docString": "If `K ⊆ L`, the components outside of `L` are all contained in a single component outside of `K`.\n", "terms": "[\n  \"Subset\",\n  \"Component\",\n  \"Contained\",\n  \"Single\"\n]"}
{"type": "{α : Type v} → {d u l r : ℕ} → Matrix (Fin (u + d)) (Fin (l + r)) α → Matrix (Fin u) (Fin r) α", "name": "Matrix.subUpRight", "isProp": false, "docString": "The top-right `u × r` part of a `(u+d) × (l+r)` matrix. ", "terms": "[\n    \"top-right\",\n    \"part\",\n    \"matrix\"\n]"}
{"type": "∀ {k : Type u_1} {A : Type u_2} [inst : AddMonoid A] [inst_1 : Semiring k] {s : Set A} {x : AddMonoidAlgebra k A},\n  x ∈ Ideal.span (AddMonoidAlgebra.of' k A '' s) ↔ ∀ m ∈ x.support, ∃ m' ∈ s, ∃ d, m = d + m'", "name": "AddMonoidAlgebra.mem_ideal_span_of'_image", "isProp": true, "docString": "If `x` belongs to the ideal generated by generators in `s`, then every element of the support of\n`x` factors additively through an element of `s`.\n", "terms": "[\n    \"belongs\",\n    \"ideal\",\n    \"generated\",\n    \"generators\",\n    \"element\",\n    \"support\",\n    \"factors\",\n    \"additively\",\n    \"through\"\n]"}
{"type": "{𝕜 : Type u_1} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type u_2} →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : NormedSpace 𝕜 E] →\n          {E' : Type u_3} →\n            [inst_3 : NormedAddCommGroup E'] →\n              [inst_4 : NormedSpace 𝕜 E'] →\n                {H : Type u_4} →\n                  [inst_5 : TopologicalSpace H] →\n                    {H' : Type u_5} →\n                      [inst_6 : TopologicalSpace H'] →\n                        {I : ModelWithCorners 𝕜 E H} →\n                          {I' : ModelWithCorners 𝕜 E' H'} →\n                            {M : Type u_6} →\n                              [inst_7 : TopologicalSpace M] →\n                                [inst_8 : ChartedSpace H M] →\n                                  {M' : Type u_7} →\n                                    [inst_9 : TopologicalSpace M'] →\n                                      [inst_10 : ChartedSpace H' M'] → {n : ℕ∞} → M' → ContMDiffMap I I' M M' n", "name": "ContMDiffMap.const", "isProp": false, "docString": "Constant map as a smooth map ", "terms": "[\n    \"Constant map\",\n    \"Smooth map\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] [inst_5 : CompleteSpace F]\n  {f : E → F} {p : FormalMultilinearSeries 𝕜 E F} {x y : E} {r : ENNReal},\n  HasFPowerSeriesOnBall f p x r → y ∈ EMetric.ball x r → AnalyticAt 𝕜 f y", "name": "HasFPowerSeriesOnBall.analyticAt_of_mem", "isProp": true, "docString": "If a function admits a power series expansion `p` on an open ball `B (x, r)`, then\nit is analytic at every point of this ball. ", "terms": "[\n    \"function\",\n    \"admits\",\n    \"power series expansion\",\n    \"open ball\",\n    \"analytic\",\n    \"point\"\n]"}
{"type": "ProofWidgets.Component ProofWidgets.PenroseDiagramProps", "name": "ProofWidgets.PenroseDiagram", "isProp": false, "docString": "Displays the given diagram using [Penrose](https://penrose.cs.cmu.edu/).\nThe website contains explanations of how to write domain (`dsl`), style (`sty`),\nand substance (`sub`) programs.\n\nThe diagram may also contain embedded HTML trees which are specified in `embeds`.\nEach embed is HTML together with the name of an object `x` in the substance program.\nThe objhect `x` can be of any type but *must* be assigned an `x.textBox : Rectangle` field\nin the style program. This rectangle will be replaced with the HTML tree.\n\nThe following additional constants are prepended to the style program:\n```penrose\ntheme {\n  color foreground\n  color tooltipBackground\n  color tooltipForeground\n  color tooltipBorder\n}\n```\nand can be accessed as, for example, `theme.foreground` in the provided `sty` in order to match\nthe editor theme. ", "terms": "[]"}
{"type": "∀ {E : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n  [inst_2 : SecondCountableTopology E] [inst_3 : CompleteSpace E] [inst_4 : NormedAddCommGroup F] {f : ℝ → E}\n  {g : ℝ → F} {a b : ℝ} (l : Filter ℝ) [inst_5 : Filter.NeBot l] [inst_6 : Filter.TendstoIxxClass Set.Icc l l],\n  Set.uIcc a b ∈ l →\n    (∀ᶠ (x : ℝ) in l, DifferentiableAt ℝ f x) →\n      Filter.Tendsto (fun x => ‖f x‖) l Filter.atTop → deriv f =O[l] g → ¬IntervalIntegrable g MeasureTheory.volume a b", "name": "not_intervalIntegrable_of_tendsto_norm_atTop_of_deriv_isBigO_filter", "isProp": true, "docString": "If `f` is eventually differentiable along a nontrivial filter `l : Filter ℝ` that is generated\nby convex sets, the norm of `f` tends to infinity along `l`, and `f' = O(g)` along `l`, where `f'`\nis the derivative of `f`, then `g` is not integrable on any interval `a..b` such that\n`[a, b] ∈ l`. ", "terms": "[\n    \"eventually differentiable\",\n    \"nontrivial filter\",\n    \"Filter ℝ\",\n    \"generated\",\n    \"convex sets\",\n    \"norm\",\n    \"tends to infinity\",\n    \"derivative\",\n    \"O(g)\",\n    \"integrable\",\n    \"interval\",\n    \"a..b\"\n]"}
{"type": "∀ {α : Type u} {s : Set α}, Set.Nonempty s → (Set.Countable s ↔ ∃ f, Function.Surjective f)", "name": "Set.countable_iff_exists_surjective", "isProp": true, "docString": "A non-empty set is countable iff there exists a surjection from the\nnatural numbers onto the subtype induced by the set.\n", "terms": "[\n    \"non-empty set\",\n    \"countable\",\n    \"exists\",\n    \"surjection\",\n    \"natural numbers\",\n    \"onto\",\n    \"subtype\",\n    \"induced\",\n    \"set\"\n]"}
{"type": "∀ {α : Type u_1} [self : CompleteBooleanAlgebra α] (a : α) (s : Set α), ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s", "name": "CompleteBooleanAlgebra.iInf_sup_le_sup_sInf", "isProp": true, "docString": "In a complete distributive lattice, `⊔` distributes over `⨅`. ", "terms": "[\n    \"complete\",\n    \"distributive lattice\",\n    \"distributes over\"\n]"}
{"type": "{J : Type v} →\n  [inst : CategoryTheory.SmallCategory J] →\n    {F : CategoryTheory.Functor J CategoryTheory.Cat} →\n      CategoryTheory.Limits.limit (CategoryTheory.Functor.comp F CategoryTheory.Cat.objects) →\n        CategoryTheory.Limits.limit (CategoryTheory.Functor.comp F CategoryTheory.Cat.objects) →\n          CategoryTheory.Functor J (Type v)", "name": "CategoryTheory.Cat.HasLimits.homDiagram", "isProp": false, "docString": "Auxiliary definition:\nthe diagram whose limit gives the morphism space between two objects of the limit category. ", "terms": "[\n    \"Auxiliary definition\",\n    \"diagram\",\n    \"limit\",\n    \"morphism space\",\n    \"objects\",\n    \"limit category\"\n]"}
{"type": "∀ {α : Type u_1} {R : Type u_2} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Monoid α] [inst_4 : DistribMulAction α M] [inst_5 : SMulCommClass α R M] (a : α), a • ⊥ = ⊥", "name": "Submodule.smul_bot'", "isProp": true, "docString": "See also `Submodule.smul_bot`. ", "terms": "[\"Submodule\", \"smul_bot\"]"}
{"type": "∀ {α : Type u_1} [inst : Monoid α] [inst_1 : DecidableRel fun x x_1 => x ∣ x_1] {a b : α}, a ∣ b → 0 < multiplicity a b", "name": "has_dvd.dvd.multiplicity_pos", "isProp": true, "docString": "**Alias** of the reverse direction of `multiplicity.dvd_iff_multiplicity_pos`.", "terms": "[\"Alias\", \"reverse direction\", \"multiplicity\", \"dvd_iff_multiplicity_pos\"]"}
{"type": "{ι : Type u_1} →\n  (V : Type u) →\n    [inst : CategoryTheory.Category.{v, u} V] →\n      [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] →\n        (c : ComplexShape ι) →\n          [inst_2 : CategoryTheory.Limits.HasEqualizers V] →\n            [inst_3 : CategoryTheory.Limits.HasImages V] →\n              [inst_4 : CategoryTheory.Limits.HasImageMaps V] →\n                [inst_5 : CategoryTheory.Limits.HasCokernels V] →\n                  CategoryTheory.Functor (HomologicalComplex V c) (CategoryTheory.GradedObject ι V)", "name": "gradedHomology'Functor", "isProp": false, "docString": "The homology functor from `ι`-indexed complexes to `ι`-graded objects in `V`. ", "terms": "[\n    \"homology functor\", \n    \"indexed complexes\", \n    \"graded objects\"\n]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} {f : X ⟶ Y}\n  (self : CategoryTheory.Limits.MonoFactorisation f), CategoryTheory.Mono self.m", "name": "CategoryTheory.Limits.MonoFactorisation.m_mono", "isProp": true, "docString": "A factorisation of a morphism `f = e ≫ m`, with `m` monic. ", "terms": "[\n    \"factorisation\",\n    \"morphism\",\n    \"monic\"\n]"}
{"type": "Type ((max u1 u2) + 1)", "name": "GroupCatMaxAux", "isProp": false, "docString": "An alias for `AddGroupCat.{max u v}`, to deal around unification issues.", "terms": "[\"alias\", \"AddGroupCat.{max u v}\", \"unification issues\"]"}
{"type": "∀ (R : Type u) [inst : Semiring R] {ι : Type v} [dec_ι : DecidableEq ι] {M : ι → Type w}\n  [inst_1 : (i : ι) → AddCommMonoid (M i)] [inst_2 : (i : ι) → Module R (M i)] {N : Type u₁} [inst_3 : AddCommMonoid N]\n  [inst_4 : Module R N] ⦃ψ ψ' : (DirectSum ι fun i => M i) →ₗ[R] N⦄,\n  (∀ (i : ι), ψ ∘ₗ DirectSum.lof R ι M i = ψ' ∘ₗ DirectSum.lof R ι M i) → ψ = ψ'", "name": "DirectSum.linearMap_ext", "isProp": true, "docString": "Two `LinearMap`s out of a direct sum are equal if they agree on the generators.\n\nSee note [partially-applied ext lemmas]. ", "terms": "[\n    \"LinearMap\",\n    \"direct sum\",\n    \"equal\",\n    \"agree\",\n    \"generators\",\n    \"partially-applied\",\n    \"ext lemmas\"\n]"}
{"type": "{L R : Type w} →\n  {fst snd : R → L} →\n    {A B C : CategoryTheory.Limits.WalkingMulticospan fst snd} →\n      CategoryTheory.Limits.WalkingMulticospan.Hom A B →\n        CategoryTheory.Limits.WalkingMulticospan.Hom B C → CategoryTheory.Limits.WalkingMulticospan.Hom A C", "name": "CategoryTheory.Limits.WalkingMulticospan.Hom.comp", "isProp": false, "docString": "Composition of morphisms for `WalkingMulticospan`. ", "terms": "[\n  \"Composition\",\n  \"Morphisms\",\n  \"WalkingMulticospan\"\n]"}
{"type": "{S : Type u₁} →\n  {L : Type u₂} →\n    {D : Type u₃} →\n      [inst : CategoryTheory.Category.{v₁, u₁} S] →\n        [inst_1 : CategoryTheory.Category.{v₂, u₂} L] →\n          [inst_2 : CategoryTheory.Category.{v₃, u₃} D] →\n            (ι : CategoryTheory.Functor S L) →\n              CategoryTheory.Functor S D → (x : L) → CategoryTheory.Functor (CategoryTheory.CostructuredArrow ι x) D", "name": "CategoryTheory.Lan.diagram", "isProp": false, "docString": "The diagram indexed by `Lan.index ι x` used to define `Lan`. ", "terms": "[\n  \"diagram\",\n  \"indexed\",\n  \"define\"\n]"}
{"type": "{R : Type u_1} →\n  {M : Type u_2} →\n    {N : Type u_3} →\n      {P : Type u_4} →\n        [inst : CommRing R] →\n          [inst_1 : AddCommGroup M] →\n            [inst_2 : AddCommGroup N] →\n              [inst_3 : AddCommGroup P] →\n                [inst_4 : Module R M] →\n                  [inst_5 : Module R N] →\n                    [inst_6 : Module R P] →\n                      {f : M →ₗ[R] N} →\n                        {g : N →ₗ[R] P} →\n                          (Q : Type u_5) →\n                            [inst_7 : AddCommGroup Q] →\n                              [inst_8 : Module R Q] →\n                                Function.Exact ⇑f ⇑g →\n                                  TensorProduct R N Q ⧸ LinearMap.range (LinearMap.rTensor Q f) →ₗ[R]\n                                    TensorProduct R P Q", "name": "rTensor.toFun", "isProp": false, "docString": "The direct map in `rTensor.equiv` ", "terms": "[\"direct map\", \"rTensor.equiv\"]"}
{"type": "∀ {γ : Type w} [inst : EMetricSpace γ] {x y : γ}, edist x y = 0 ↔ x = y", "name": "edist_eq_zero", "isProp": true, "docString": "Characterize the equality of points by the vanishing of their extended distance ", "terms": "[\n    \"Characterize\",\n    \"Equality\",\n    \"Points\",\n    \"Vanishing\",\n    \"Extended Distance\"\n]"}
{"type": "{α : Type u} →\n  {β : Type u_1} →\n    [inst : OrderedCommSemiring α] →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Add β] →\n            [inst_4 : Mul β] →\n              [inst_5 : Pow β ℕ] →\n                [inst_6 : SMul ℕ β] →\n                  [inst_7 : NatCast β] →\n                    (f : β → α) →\n                      Function.Injective f →\n                        f 0 = 0 →\n                          f 1 = 1 →\n                            (∀ (x y : β), f (x + y) = f x + f y) →\n                              (∀ (x y : β), f (x * y) = f x * f y) →\n                                (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                  (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                    (∀ (n : ℕ), f ↑n = ↑n) → OrderedCommSemiring β", "name": "Function.Injective.orderedCommSemiring", "isProp": false, "docString": "Pullback an `OrderedCommSemiring` under an injective map. ", "terms": "[\n    \"Pullback\",\n    \"OrderedCommSemiring\",\n    \"Injective map\"\n]"}
{"type": "∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] (χ : MulChar R R'),\n  MulChar.IsNontrivial χ ↔ χ ≠ 1", "name": "MulChar.isNontrivial_iff", "isProp": true, "docString": "A multiplicative character is nontrivial iff it is not the trivial character. ", "terms": "[\n    \"Multiplicative Character\",\n    \"Nontrivial\",\n    \"Trivial Character\"\n]"}
{"type": "∀ {ι : Type u_1} {R : Type u_3} {A : Type u_5} {x : ι → A} [inst : CommRing R] [inst_1 : CommRing A]\n  [inst_2 : Algebra R A] {K : Type u_9} [inst_3 : CommRing K] [inst_4 : Algebra R K] [inst_5 : Algebra K A]\n  [inst_6 : IsScalarTower R K A],\n  Function.Injective ⇑(algebraMap R K) → AlgebraicIndependent K x → AlgebraicIndependent R x", "name": "AlgebraicIndependent.restrictScalars", "isProp": true, "docString": "A set of algebraically independent elements in an algebra `A` over a ring `K` is also\nalgebraically independent over a subring `R` of `K`. ", "terms": "[\n\"Set\",\n\"Algebraically independent\",\n\"Elements\",\n\"Algebra\",\n\"Ring\",\n\"Subring\"\n]"}
{"type": "∀ {R : Type u_1} [inst : CommSemiring R] (P : Ideal R) [hp : Ideal.IsPrime P],\n  LocalRing (Localization (Ideal.primeCompl P))", "name": "Localization.AtPrime.localRing", "isProp": true, "docString": "The localization of `R` at the complement of a prime ideal is a local ring. ", "terms": "[\n    \"localization\",\n    \"complement\",\n    \"prime ideal\",\n    \"local ring\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        (F : CategoryTheory.Functor C D) →\n          (d : D) →\n            CategoryTheory.Functor (CategoryTheory.StructuredArrow (Opposite.op d) F.op)ᵒᵖ\n              (CategoryTheory.CostructuredArrow F d)", "name": "CategoryTheory.StructuredArrow.toCostructuredArrow'", "isProp": false, "docString": "For a functor `F : C ⥤ D` and an object `d : D`, we obtain a contravariant functor from the\ncategory of structured arrows `op d ⟶ F.op.obj c` to the category of costructured arrows\n`F.obj c ⟶ d`.\n", "terms": "[\n    \"functor\",\n    \"object\",\n    \"contravariant functor\",\n    \"category\",\n    \"structured arrows\",\n    \"costructured arrows\"\n]"}
{"type": "∀ {β : Type u} {α : Type v} {γ : Type w} [inst : AddCommMonoid β] {s : Finset γ} {t : γ → Finset α} {t' : Finset α}\n  {s' : α → Finset γ},\n  (∀ (x : γ) (y : α), x ∈ s ∧ y ∈ t x ↔ x ∈ s' y ∧ y ∈ t') →\n    ∀ {f : γ → α → β},\n      (Finset.sum s fun x => Finset.sum (t x) fun y => f x y) = Finset.sum t' fun y => Finset.sum (s' y) fun x => f x y", "name": "Finset.sum_comm'", "isProp": true, "docString": "Generalization of `Finset.sum_comm` to the case when the inner `Finset`s depend on\nthe outer variable.", "terms": "[\"Generalization\", \"Finset.sum_comm\", \"case\", \"inner\", \"Finset\", \"depend\", \"outer\", \"variable\"]"}
{"type": "∀ {α : Sort u_1} (x : α), (∀ (y : α), y = x) → Subsingleton α", "name": "subsingleton_of_forall_eq", "isProp": true, "docString": "If all points are equal to a given point `x`, then `α` is a subsingleton. ", "terms": "[\"points\", \"equal\", \"given point\", \"subsingleton\"]"}
{"type": "String → String", "name": "ToAdditive.guessName", "isProp": false, "docString": "Autogenerate additive name.\nThis runs in several steps:\n1) Split according to capitalisation rule and at `_`.\n2) Apply word-by-word translation rules.\n3) Fix up abbreviations that are not word-by-word translations, like \"addComm\" or \"Nonneg\".\n", "terms": "[]"}
{"type": "List Char", "name": "System.FilePath.pathSeparators", "isProp": false, "docString": "The list of all possible separators. ", "terms": "[]"}
{"type": "(R : Type u_1) →\n  [inst : CommSemiring R] →\n    {X : Type u_2} →\n      {A : Type u_3} → [inst_1 : Semiring A] → [inst_2 : Algebra R A] → (X → A) ≃ (FreeAlgebra R X →ₐ[R] A)", "name": "FreeAlgebra.lift", "isProp": false, "docString": "Given a function `f : X → A` where `A` is an `R`-algebra, `lift R f` is the unique lift\nof `f` to a morphism of `R`-algebras `FreeAlgebra R X → A`.\n", "terms": "[\n    \"function\",\n    \"R-algebra\",\n    \"lift\",\n    \"unique\",\n    \"morphism\",\n    \"FreeAlgebra\"\n]"}
{"type": "∀ {α : Type u_9} [self : CompleteLinearOrder α] (a b : α), a ≤ b ∨ b ≤ a", "name": "CompleteLinearOrder.le_total", "isProp": true, "docString": "A linear order is total. ", "terms": "[\"linear order\", \"total\"]"}
{"type": "{m : Type → Type} →\n  {α : Type} →\n    [inst : Monad m] →\n      [inst : Alternative m] →\n        [inst : LinearOrder α] →\n          (α → MLList m α) → α → optParam (Option ℕ) none → optParam (Option ℕ) none → optParam Bool true → MLList m α", "name": "bestFirstSearch", "isProp": false, "docString": "A lazy list recording the best first search of a graph generated by a function\n`f : α → MLList m α`.\n\nWe maintain a priority queue of visited-but-not-exhausted nodes,\nand at each step take the next child of the highest priority node in the queue.\n\nThe option `maxDepth` limits the search depth.\n\nThe option `maxQueued` bounds the size of the priority queue,\ndiscarding the lowest priority nodes as needed.\nThis implements a \"beam\" search, which may be incomplete but uses bounded memory.\n\nThe option `removeDuplicates` keeps an `RBSet` of previously visited nodes.\nOtherwise, if the graph is not a tree then nodes will be visited multiple times.\n\nThis function returns values `a : α` that are least in the `[LinearOrder α]`\namongst unvisited neighbours of visited nodes.\n", "terms": "[\n  \"lazy list\",\n  \"best first search\",\n  \"graph\",\n  \"function\",\n  \"priority queue\",\n  \"visited-but-not-exhausted nodes\",\n  \"child\",\n  \"highest priority node\",\n  \"maxDepth\",\n  \"search depth\",\n  \"maxQueued\",\n  \"size\",\n  \"discarding\",\n  \"lowest priority nodes\",\n  \"beam search\",\n  \"bounded memory\",\n  \"removeDuplicates\",\n  \"RBSet\",\n  \"previously visited nodes\",\n  \"graph\",\n  \"tree\",\n  \"nodes\",\n  \"visited multiple times\",\n  \"values\",\n  \"LinearOrder\",\n  \"unvisited neighbours\",\n  \"visited nodes\"\n]"}
{"type": "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V < Cardinal.aleph0 → Set.Finite (Basis.ofVectorSpaceIndex K V)", "name": "Basis.finite_ofVectorSpaceIndex_of_rank_lt_aleph0", "isProp": true, "docString": "If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. ", "terms": "[\n  \"vector space\",\n  \"finite dimension\",\n  \"index set\",\n  \"Basis.ofVectorSpace\",\n  \"finite\"\n]"}
{"type": "{ιA : Type u_1} → (A : ιA → Type u_4) → [inst : Add ιA] → [inst_1 : GradedMonoid.GMul A] → GradedMonoid.GSMul A A", "name": "GradedMonoid.GMul.toGSMul", "isProp": false, "docString": "A graded version of `Mul.toSMul` ", "terms": "[\"graded version\", \"Mul.toSMul\"]"}
{"type": "{α : Type u_1} → [inst : LE α] → α → Ordnode α → Prop", "name": "Ordnode.Amem", "isProp": false, "docString": "O(n). Approximate membership in the set, that is, whether some element in the\nset is equivalent to this one in the preorder. This is useful primarily for stating\ncorrectness properties; use `∈` for a version that actually uses the BST property\nof the tree.\n\n    Amem 2 {1, 2, 3} = true\n    Amem 4 {1, 2, 3} = false\n\nTo see the difference with `Emem`, we need a preorder that is not a partial order.\nFor example, suppose we compare pairs of numbers using only their first coordinate. Then:\n-- Porting note: Verify below example\n    emem (0, 1) {(0, 0), (1, 2)} = false\n    amem (0, 1) {(0, 0), (1, 2)} = true\n    (0, 1) ∈ {(0, 0), (1, 2)} = true\n\nThe `∈` relation is equivalent to `Amem` as long as the `Ordnode` is well formed,\nand should always be used instead of `Amem`. ", "terms": "[\n  \"O(n)\",\n  \"Approximate membership\",\n  \"Set\",\n  \"Element\",\n  \"Equivalent\",\n  \"Preorder\",\n  \"Correctness properties\",\n  \"BST property\",\n  \"Tree\",\n  \"True\",\n  \"False\",\n  \"Partial order\",\n  \"Pairs of numbers\",\n  \"First coordinate\",\n  \"Relation\",\n  \"Ordnode\",\n  \"Well formed\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {X Y : C} →\n      {f g : X ⟶ Y} →\n        (t : CategoryTheory.Limits.Cofork f g) →\n          (CategoryTheory.Limits.parallelPair f g).obj CategoryTheory.Limits.WalkingParallelPair.one ⟶\n            ((CategoryTheory.Functor.const CategoryTheory.Limits.WalkingParallelPair).obj t.pt).obj\n              CategoryTheory.Limits.WalkingParallelPair.one", "name": "CategoryTheory.Limits.Cofork.π", "isProp": false, "docString": "A cofork `t` on the parallelPair `f g : X ⟶ Y` consists of two morphisms\n`t.ι.app zero : X ⟶ t.pt` and `t.ι.app one : Y ⟶ t.pt`. Of these, only the second one is\ninteresting, and we give it the shorter name `Cofork.π t`. ", "terms": "[\n    \"cofork\",\n    \"parallelPair\",\n    \"morphisms\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  {p : FormalMultilinearSeries 𝕜 E F} {x : E}, HasFPowerSeriesAt 0 p x → ∀ (n : ℕ) (y : E), ((p n) fun x => y) = 0", "name": "HasFPowerSeriesAt.apply_eq_zero", "isProp": true, "docString": "If a formal multilinear series `p` represents the zero function at `x : E`, then the\nterms `p n (fun i ↦ y)` appearing in the sum are zero for any `n : ℕ`, `y : E`. ", "terms": "[\n\"formal multilinear series\",\n\"zero function\",\n\"sum\",\n\"zero\",\n\"ℕ\"\n]"}
{"type": "Lean.TrailingParserDescr", "name": "«term_⁺»", "isProp": false, "docString": "The positive part function. ", "terms": "[\n    \"positive part function\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {K : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection K] {u v : E},\n  v ∈ K → u - v ∈ Kᗮ → ↑((orthogonalProjection K) u) = v", "name": "eq_orthogonalProjection_of_mem_orthogonal", "isProp": true, "docString": "A point in `K` with the orthogonality property (here characterized in terms of `Kᗮ`) must be the\northogonal projection. ", "terms": "[\n  \"Point\",\n  \"Orthogonality Property\",\n  \"Orthogonal Projection\"\n]"}
{"type": "Lean.TrailingParserDescr", "name": "SNum.«term_::_»", "isProp": false, "docString": "Add a bit at the end of a `SNum`. This mimics `NzsNum.bit`. ", "terms": "The mathematical terms in the statement are:\n\n[\n  \"bit\",\n  \"SNum\",\n  \"NzsNum.bit\"\n]"}
{"type": "{V : Type (u + 1)} → [inst : CategoryTheory.LargeCategory V] → {G : MonCat} → (M : Action V G) → Action.Hom M M", "name": "Action.Hom.id", "isProp": false, "docString": "The identity morphism on an `Action V G`. ", "terms": "[\n    \"identity morphism\",\n    \"Action\",\n    \"V\",\n    \"G\"\n]"}
{"type": "(𝕜 : Type u_1) →\n  {E : Type u_2} →\n    {β : Type u_5} →\n      [inst : OrderedSemiring 𝕜] →\n        [inst : AddCommMonoid E] →\n          [inst : OrderedAddCommMonoid β] → [inst : SMul 𝕜 E] → [inst : SMul 𝕜 β] → Set E → (E → β) → Prop", "name": "ConvexOn", "isProp": false, "docString": "Convexity of functions ", "terms": "[\"Convexity\", \"Functions\"]"}
{"type": "∀ {p : ℕ+} {k : ℕ} {K : Type u} [inst : Field K] [inst_1 : CharZero K] {ζ : K} [hp : Fact (Nat.Prime ↑p)]\n  [inst_2 : IsCyclotomicExtension {p ^ (k + 1)} ℚ K] (hζ : IsPrimitiveRoot ζ ↑(p ^ (k + 1))),\n  p ≠ 2 → Prime (IsPrimitiveRoot.toInteger hζ - 1)", "name": "IsPrimitiveRoot.zeta_sub_one_prime_of_ne_two", "isProp": true, "docString": "`ζ - 1` is prime if `p ≠ 2` and `ζ` is a primitive `p ^ (k + 1)`-th root of unity.\nSee `zeta_sub_one_prime` for a general statement. ", "terms": "[\n    \"prime\",\n    \"primitive\",\n    \"root of unity\"\n]"}
{"type": "{ι : Sort u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} →\n      [inst : MeasurableSpace α] →\n        [inst_1 : MeasurableSpace β] →\n          {f : ι → α → β} →\n            {μ : MeasureTheory.Measure α} → (∀ (i : ι), AEMeasurable (f i)) → (α → (ι → β) → Prop) → Set α", "name": "aeSeqSet", "isProp": false, "docString": "If we have the additional hypothesis `∀ᵐ x ∂μ, p x (fun n ↦ f n x)`, this is a measurable set\nwhose complement has measure 0 such that for all `x ∈ aeSeqSet`, `f i x` is equal to\n`(hf i).mk (f i) x` for all `i` and we have the pointwise property `p x (fun n ↦ f n x)`. ", "terms": "[\n    \"additional hypothesis\",\n    \"measurable set\",\n    \"complement\",\n    \"measure 0\",\n    \"for all\",\n    \"is equal to\",\n    \"pointwise property\"\n]"}
{"type": "ℕ × ℕ ≃ ℕ", "name": "Nat.pairEquiv", "isProp": false, "docString": "An equivalence between `ℕ × ℕ` and `ℕ`. ", "terms": "[\n  \"Equivalence\",\n  \"ℕ\",\n  \"×\"\n]"}
{"type": "{𝕜 : Type u_1} →\n  {V : Type u_2} →\n    [inst : NormedField 𝕜] →\n      [inst_1 : AddCommGroup V] → [inst_2 : Module 𝕜 V] → (e : ENorm 𝕜 V) → MetricSpace ↥(ENorm.finiteSubspace e)", "name": "ENorm.metricSpace", "isProp": false, "docString": "Metric space structure on `e.finiteSubspace`. We use `EMetricSpace.toMetricSpace`\nto ensure that this definition agrees with `e.emetricSpace`. ", "terms": "[\n  \"Metric space\",\n  \"Structure\",\n  \"Finite subspace\",\n  \"EMetric space\",\n  \"Definition\",\n  \"Agrees\"\n]"}
{"type": "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_2} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_4} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → F} {U : Set M} {c : M},\n  MDifferentiableOn I (modelWithCornersSelf ℂ F) f U →\n    IsPreconnected U → IsOpen U → c ∈ U → IsMaxOn (norm ∘ f) U c → Set.EqOn (norm ∘ f) (Function.const M ‖f c‖) U", "name": "MDifferentiableOn.norm_eqOn_of_isPreconnected_of_isMaxOn", "isProp": true, "docString": "**Maximum modulus principle** on a connected set. Let `U` be a (pre)connected open set in a\ncomplex normed space. Let `f : E → F` be a function that is complex differentiable on `U`. Suppose\nthat `‖f x‖` takes its maximum value on `U` at `c ∈ U`. Then `‖f x‖ = ‖f c‖` for all `x ∈ U`. ", "terms": "[\n    \"Maximum modulus principle\",\n    \"connected set\",\n    \"preconnected\",\n    \"open set\",\n    \"complex normed space\",\n    \"function\",\n    \"complex differentiable\",\n    \"maximum value\"\n]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_3, u_1} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      (𝕜 : Type u_2) →\n        [inst_2 : Field 𝕜] →\n          [inst_3 : IsAlgClosed 𝕜] →\n            [inst_4 : CategoryTheory.Linear 𝕜 C] →\n              [inst_5 : CategoryTheory.Limits.HasKernels C] →\n                (X : C) →\n                  [inst_6 : CategoryTheory.Simple X] → [I : FiniteDimensional 𝕜 (X ⟶ X)] → Field (CategoryTheory.End X)", "name": "CategoryTheory.fieldEndOfFiniteDimensional", "isProp": false, "docString": "Endomorphisms of a simple object form a field if they are finite dimensional.\nThis can't be an instance as `𝕜` would be undetermined.\n", "terms": "[\"Endomorphisms\", \"simple object\", \"field\", \"finite dimensional\"]"}
{"type": "Simps.ParsedProjectionData → Lean.Name", "name": "Simps.ParsedProjectionData.newName", "isProp": false, "docString": "name for this projection used in the generated `simp` lemmas ", "terms": "[]"}
{"type": "Inv SetTheory.PGame", "name": "SetTheory.PGame.instInvPGame", "isProp": false, "docString": "The inverse of a pre-game in terms of the inverse on positive pre-games. ", "terms": "[\n    \"inverse\",\n    \"pre-game\",\n    \"positive pre-games\"\n]"}
{"type": "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace.SeparableSpace X] {s : Set X},\n  IsClosed s → ∀ [inst_2 : DiscreteTopology ↑s], Cardinal.continuum ≤ Cardinal.mk ↑s → ¬NormalSpace X", "name": "IsClosed.not_normal_of_continuum_le_mk", "isProp": true, "docString": "Let `s` be a closed set in a separable space. If the induced topology on `s` is discrete and `s`\nhas cardinality at least continuum, then the ambient space is not a normal space. ", "terms": "[\n  \"closed set\",\n  \"separable space\",\n  \"induced topology\",\n  \"discrete\",\n  \"cardinality\",\n  \"continuum\",\n  \"ambient space\",\n  \"normal space\"\n]"}
{"type": "{α : Sort u_1} → {β : Sort u_2} → {f : α → β} → [inst : DecidableEq β] → Function.Injective f → DecidableEq α", "name": "Function.Injective.decidableEq", "isProp": false, "docString": "If the co-domain `β` of an injective function `f : α → β` has decidable equality, then\nthe domain `α` also has decidable equality. ", "terms": "[\n    \"co-domain\",\n    \"injective function\",\n    \"function\",\n    \"domain\",\n    \"decidable equality\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} {ι : Type u_2} [inst : PseudoMetricSpace α] {F : ι → β → α} {f : β → α} {p : Filter ι}\n  {p' : Filter β}, TendstoUniformlyOnFilter F f p p' ↔ ∀ ε > 0, ∀ᶠ (n : ι × β) in p ×ˢ p', dist (f n.2) (F n.1 n.2) < ε", "name": "Metric.tendstoUniformlyOnFilter_iff", "isProp": true, "docString": "Expressing uniform convergence using `dist` ", "terms": "[\"Expressing\", \"uniform convergence\", \"using\", \"`dist`\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {X Y : C} →\n      (f : X ⟶ Y) →\n        [inst_1 : CategoryTheory.StrongEpi f] → Inhabited (CategoryTheory.Limits.StrongEpiMonoFactorisation f)", "name": "CategoryTheory.Limits.strongEpiMonoFactorisationInhabited", "isProp": false, "docString": "Satisfying the inhabited linter ", "terms": "[]"}
{"type": "(C : Type u) → [inst : CategoryTheory.Category.{v, u} C] → Prop", "name": "CategoryTheory.Limits.HasPullbacks", "isProp": false, "docString": "`HasPullbacks` represents a choice of pullback for every pair of morphisms\n\nSee <https://stacks.math.columbia.edu/tag/001W>\n", "terms": "[\n  \"HasPullbacks\",\n  \"choice\",\n  \"pullback\",\n  \"pair\",\n  \"morphisms\"\n]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v, u₂} D]\n  {S : CategoryTheory.Functor C D} {T : D} {A : CategoryTheory.CostructuredArrow S T}\n  {P Q : (CategoryTheory.CostructuredArrow S T)ᵒᵖ} {f : P ⟶ Opposite.op A} {g : Q ⟶ Opposite.op A}\n  [inst_2 : CategoryTheory.Mono f.unop.left.op] [inst_3 : CategoryTheory.Mono g.unop.left.op]\n  (h : CategoryTheory.Subobject.mk f.unop.left.op ≤ CategoryTheory.Subobject.mk g.unop.left.op),\n  CategoryTheory.CategoryStruct.comp g.unop.left\n      (CategoryTheory.Subobject.ofMkLEMk f.unop.left.op g.unop.left.op h).unop =\n    f.unop.left", "name": "CategoryTheory.CostructuredArrow.unop_left_comp_ofMkLEMk_unop", "isProp": true, "docString": "Technical lemma for `quotientEquiv`. ", "terms": "The statement provided does not contain any specific mathematical terms; it only refers to a technical lemma and a function or concept named `quotientEquiv`. Without further context, it's hard to determine the significance or meaning of these terms as they are not common terms in mathematics. Therefore, the appropriate response is an empty list:\n\n    []"}
{"type": "{a : Prop} → (b : Prop) → (a ↔ b) → [inst : Decidable b] → Decidable a", "name": "decidable_of_iff'", "isProp": false, "docString": "Transfer decidability of `b` to decidability of `a`, if the propositions are equivalent.\nThis is the same as `decidable_of_iff` but the iff is flipped. ", "terms": "[\n    \"Transfer\",\n    \"decidability\",\n    \"propositions\",\n    \"equivalent\",\n    \"decidable_of_iff\",\n    \"iff\"\n]"}
{"type": "∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 ↔ b * a = 0", "name": "mul_eq_zero_comm", "isProp": true, "docString": "If `α` has no zero divisors, then for elements `a, b : α`, `a * b` equals zero iff so is\n`b * a`. ", "terms": "[\n    \"zero divisors\",\n    \"elements\",\n    \"equals\",\n    \"zero\",\n    \"iff\"\n]"}
{"type": "(R : Type u) → [inst : CommRing R] → TopCat.Sheaf (Type u) (AlgebraicGeometry.PrimeSpectrum.Top R)", "name": "AlgebraicGeometry.structureSheafInType", "isProp": false, "docString": "The structure sheaf (valued in `Type`, not yet `CommRingCat`) is the subsheaf consisting of\nfunctions satisfying `isLocallyFraction`.\n", "terms": "[\n    \"structure sheaf\",\n    \"Type\",\n    \"CommRingCat\",\n    \"subsheaf\",\n    \"functions\",\n    \"isLocallyFraction\"\n]"}
{"type": "{𝕜 : Type u_1} →\n  {E : Type u_2} →\n    {F : Type u_3} →\n      {G : Type u_4} →\n        [inst : CommRing 𝕜] →\n          [inst_1 : AddCommGroup E] →\n            [inst_2 : AddCommGroup F] →\n              [inst_3 : AddCommGroup G] →\n                [inst_4 : Module 𝕜 E] →\n                  [inst_5 : Module 𝕜 F] →\n                    [inst_6 : Module 𝕜 G] →\n                      [inst_7 : TopologicalSpace E] →\n                        [inst_8 : TopologicalSpace F] →\n                          [inst_9 : TopologicalSpace G] →\n                            [inst_10 : TopologicalAddGroup E] →\n                              [inst_11 : ContinuousConstSMul 𝕜 E] →\n                                [inst_12 : TopologicalAddGroup F] →\n                                  [inst_13 : ContinuousConstSMul 𝕜 F] →\n                                    [inst_14 : TopologicalAddGroup G] →\n                                      [inst_15 : ContinuousConstSMul 𝕜 G] →\n                                        FormalMultilinearSeries 𝕜 F G →\n                                          FormalMultilinearSeries 𝕜 E F → FormalMultilinearSeries 𝕜 E G", "name": "FormalMultilinearSeries.comp", "isProp": false, "docString": "Formal composition of two formal multilinear series. The `n`-th coefficient in the composition\nis defined to be the sum of `q.comp_along_composition p c` over all compositions of\n`n`. In other words, this term (as a multilinear function applied to `v_0, ..., v_{n-1}`) is\n`∑'_{k} ∑'_{i₁ + ... + iₖ = n} qₖ (p_{i_1} (...), ..., p_{i_k} (...))`, where one puts all variables\n`v_0, ..., v_{n-1}` in increasing order in the dots.\n\nIn general, the composition `q ∘ p` only makes sense when the constant coefficient of `p` vanishes.\nWe give a general formula but which ignores the value of `p 0` instead.\n", "terms": "[\n    \"Formal composition\",\n    \"formal multilinear series\",\n    \"coefficient\",\n    \"composition\",\n    \"sum\",\n    \"multilinear function\",\n    \"variables\",\n    \"increasing order\",\n    \"constant coefficient\",\n    \"vanishes\",\n    \"general formula\"\n]"}
{"type": "{J : Type w} →\n  {C : Type u} →\n    [inst : CategoryTheory.Category.{v, u} C] →\n      {F : CategoryTheory.Functor (CategoryTheory.Limits.WidePullbackShape J) C} →\n        {X : C} →\n          (f : X ⟶ F.obj none) →\n            (π : (j : J) → X ⟶ F.obj (some j)) →\n              (∀ (j : J),\n                  CategoryTheory.CategoryStruct.comp (π j)\n                      (F.map (CategoryTheory.Limits.WidePullbackShape.Hom.term j)) =\n                    f) →\n                CategoryTheory.Limits.Cone F", "name": "CategoryTheory.Limits.WidePullbackShape.mkCone", "isProp": false, "docString": "Construct a cone over a wide cospan. ", "terms": "[\n  \"Construct\",\n  \"Cone\",\n  \"Wide Cospan\"\n]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z}\n  {c : CategoryTheory.Limits.PullbackCone f g},\n  CategoryTheory.Limits.IsLimit c →\n    CategoryTheory.IsPullback (CategoryTheory.Limits.PullbackCone.fst c) (CategoryTheory.Limits.PullbackCone.snd c) f g", "name": "CategoryTheory.IsPullback.of_isLimit", "isProp": true, "docString": "If `c` is a limiting pullback cone, then we have an `IsPullback c.fst c.snd f g`. ", "terms": "[\n    \"limiting pullback cone\", \n    \"IsPullback\"\n]"}
{"type": "{X : AlgebraicGeometry.Scheme} → AlgebraicGeometry.Scheme.OpenCover X → AlgebraicGeometry.Scheme.GlueData", "name": "AlgebraicGeometry.Scheme.OpenCover.gluedCover", "isProp": false, "docString": "The glue data associated with an open cover.\nThe canonical isomorphism `𝒰.gluedCover.glued ⟶ X` is provided by `𝒰.fromGlued`. ", "terms": "[\n  \"glue data\",\n  \"open cover\",\n  \"canonical isomorphism\"\n]"}
{"type": "(x y : ℝ) → [h : Fact (x < y)] → PartialHomeomorph (↑(Set.Icc x y)) (EuclideanHalfSpace 1)", "name": "IccLeftChart", "isProp": false, "docString": "The left chart for the topological space `[x, y]`, defined on `[x,y)` and sending `x` to `0` in\n`EuclideanHalfSpace 1`.\n", "terms": "[\n  \"left chart\",\n  \"topological space\",\n  \"defined on\",\n  \"sending\",\n  \"to\",\n  \"in\",\n  \"EuclideanHalfSpace\"\n]"}
{"type": "(R : Type u) → [inst : CommSemiring R] → Coalgebra R R", "name": "CommSemiring.toCoalgebra", "isProp": false, "docString": "Every commutative (semi)ring is a coalgebra over itself, with `Δ r = 1 ⊗ₜ r`. ", "terms": "[\n  \"Commutative\",\n  \"(Semi)ring\",\n  \"Coalgebra\",\n  \"Over\",\n  \"Itself\",\n  \"Δ\",\n  \"1\",\n  \"⊗ₜ\"\n]"}
{"type": "{𝕜 : Type u_1} →\n  {F : Type u_3} →\n    [inst : IsROrC 𝕜] →\n      [inst_1 : AddCommGroup F] → [inst_2 : Module 𝕜 F] → [c : InnerProductSpace.Core 𝕜 F] → NormedSpace 𝕜 F", "name": "InnerProductSpace.Core.toNormedSpace", "isProp": false, "docString": "Normed space structure constructed from an `InnerProductSpace.Core` structure ", "terms": "[\n    \"Normed space\",\n    \"structure\",\n    \"constructed\",\n    \"from\",\n    \"InnerProductSpace.Core\"\n]"}
{"type": "∀ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f g : R →+* S} {s : Set R},\n  Set.EqOn (⇑f) (⇑g) s → Set.EqOn ⇑f ⇑g ↑(Subsemiring.closure s)", "name": "RingHom.eqOn_sclosure", "isProp": true, "docString": "If two ring homomorphisms are equal on a set, then they are equal on its subsemiring closure. ", "terms": "[\n  \"ring homomorphisms\",\n  \"equal\",\n  \"set\",\n  \"subsemiring closure\"\n]"}
{"type": "{ι : Type u_6} → {π : ι → Type u_7} → [inst : (i : ι) → Preorder (π i)] → (i : ι) → ((j : ι) → π j) →o π i", "name": "Pi.evalOrderHom", "isProp": false, "docString": "Evaluation of an unbundled function at a point (`Function.eval`) as an `OrderHom`. ", "terms": "[\n    \"Evaluation\",\n    \"Unbundled function\",\n    \"Point\",\n    \"Function.eval\",\n    \"OrderHom\"\n]"}
{"type": "{J : Type v} →\n  [inst : CategoryTheory.SmallCategory J] →\n    [inst_1 : CategoryTheory.IsFiltered J] →\n      (F : CategoryTheory.Functor J AddCommGroupCat) →\n        CategoryTheory.Limits.IsColimit (AddCommGroupCat.FilteredColimits.colimitCocone F)", "name": "AddCommGroupCat.FilteredColimits.colimitCoconeIsColimit", "isProp": false, "docString": "The proposed colimit cocone is a colimit in `AddCommGroup`.", "terms": "[\n    \"proposed\",\n    \"colimit\",\n    \"cocone\",\n    \"colimit\",\n    \"AddCommGroup\"\n]"}
{"type": "{M : Type u_1} →\n  {N : Type u_2} → [inst : MulOneClass M] → [inst_1 : MulOneClass N] → FreeMonoid (M ⊕ N) →* Monoid.Coprod M N", "name": "Monoid.Coprod.mk", "isProp": false, "docString": "The natural projection `FreeMonoid (M ⊕ N) →* M ∗ N`. ", "terms": "[\n    \"Natural Projection\",\n    \"FreeMonoid\",\n    \"Direct Sum\",\n    \"Multiplication\"\n]"}
{"type": "(α : Type u_2) → (β : α → Type u_1) → [inst : (a : α) → Unique (β a)] → (a : α) × β a ≃ α", "name": "Equiv.sigmaUnique", "isProp": false, "docString": "Any family of `Unique` types is a right identity for dependent type product up to\nequivalence. ", "terms": "[\n    \"family\",\n    \"Unique types\",\n    \"right identity\",\n    \"dependent type product\",\n    \"equivalence\"\n]"}
{"type": "{R : Type u_1} →\n  {R₂ : Type u_3} →\n    {M : Type u_9} →\n      {M₂ : Type u_12} →\n        [inst : Semiring R] →\n          [inst_1 : Semiring R₂] →\n            [inst_2 : AddCommMonoid M] →\n              [inst_3 : AddCommMonoid M₂] →\n                [inst_4 : Module R M] →\n                  [inst_5 : Module R₂ M₂] →\n                    {τ₁₂ : R →+* R₂} → {F : Type u_20} → [sc : SemilinearMapClass F τ₁₂ M M₂] → F → F → Submodule R M", "name": "LinearMap.eqLocus", "isProp": false, "docString": "A linear map version of `AddMonoidHom.eqLocusM` ", "terms": "[\"linear map\", \"AddMonoidHom.eqLocusM\"]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (x y : E), ‖inner x y‖ ≤ ‖x‖ * ‖y‖", "name": "norm_inner_le_norm", "isProp": true, "docString": "Cauchy–Schwarz inequality with norm ", "terms": "[\n    \"Cauchy–Schwarz inequality\",\n    \"norm\"\n]"}
{"type": "{α : Type u_6} → (M : Type u_7) → [inst : MulOneClass M] → Set α → (α → M) →* α → M", "name": "Set.mulIndicatorHom", "isProp": false, "docString": "`Set.mulIndicator` as a `monoidHom`. ", "terms": "[\n    \"Set.mulIndicator\",\n    \"monoidHom\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {s t : Set α},\n  AntitoneOn f t → s ⊆ t → Set.Nonempty (lowerBounds s ∩ t) → BddAbove (f '' s)", "name": "AntitoneOn.map_bddBelow", "isProp": true, "docString": "The image under an antitone function of a set which is bounded below is bounded above. ", "terms": "[\n    \"Image\",\n    \"Antitone Function\",\n    \"Set\",\n    \"Bounded Below\",\n    \"Bounded Above\"\n]"}
{"type": "{R : Type u_1} →\n  {S : Type u_2} →\n    [inst : NonUnitalNonAssocSemiring R] →\n      [inst_1 : NonUnitalNonAssocSemiring S] → (f : R →ₙ+* S) → (∀ (x y : R), Commute (f x) (f y)) → Rᵐᵒᵖ →ₙ+* S", "name": "NonUnitalRingHom.fromOpposite", "isProp": false, "docString": "A non-unital ring homomorphism `f : R →ₙ* S` such that `f x` commutes with `f y` for all `x, y`\ndefines a non-unital ring homomorphism from `Rᵐᵒᵖ`. ", "terms": "[\n    \"non-unital ring\",\n    \"ring homomorphism\",\n    \"commutes\",\n    \"non-unital ring homomorphism\"\n]"}
{"type": "{σ : Type} →\n  {m : Type → Type} → [inst : Monad m] → [inst : Lean.MonadBacktrack σ m] → {α : Type} → m (Option α) → Nondet m α", "name": "Nondet.ofOptionM", "isProp": false, "docString": "Convert a monadic optional value to a nondeterministic value. ", "terms": "[\"convert\", \"monadic\", \"optional value\", \"nondeterministic value\"]"}
{"type": "{α : Type u_1} → {β : Type u_2} → [inst : SeminormedRing α] → [inst : SeminormedRing β] → SeminormedRing (α × β)", "name": "Prod.seminormedRing", "isProp": false, "docString": "Seminormed ring structure on the product of two seminormed rings,\nusing the sup norm. ", "terms": "[\n\"Seminormed ring\",\n\"Product\",\n\"Sup norm\"\n]"}
{"type": "{𝕜 : Type u_1} →\n  {V₁ : Type u_3} →\n    {V₂ : Type u_4} →\n      {P₁ : Type u_7} →\n        {P₂ : Type u_9} →\n          [inst : NormedField 𝕜] →\n            [inst_1 : SeminormedAddCommGroup V₁] →\n              [inst_2 : SeminormedAddCommGroup V₂] →\n                [inst_3 : NormedSpace 𝕜 V₁] →\n                  [inst_4 : NormedSpace 𝕜 V₂] →\n                    [inst_5 : MetricSpace P₁] →\n                      [inst_6 : PseudoMetricSpace P₂] →\n                        [inst_7 : NormedAddTorsor V₁ P₁] →\n                          [inst_8 : NormedAddTorsor V₂ P₂] →\n                            (φ : P₁ →ᵃⁱ[𝕜] P₂) →\n                              (E : AffineSubspace 𝕜 P₁) →\n                                [inst_9 : Nonempty ↥E] → ↥E ≃ᵃⁱ[𝕜] ↥(AffineSubspace.map φ.toAffineMap E)", "name": "AffineSubspace.isometryEquivMap", "isProp": false, "docString": "Restricts an affine isometry to an affine isometry equivalence between a nonempty affine\nsubspace `E` and its image.\n\nThis is an isometry version of `AffineSubspace.equivMap`, having a stronger premise and a stronger\nconclusion.\n", "terms": "[\n    \"affine isometry\",\n    \"affine isometry equivalence\",\n    \"nonempty affine subspace\",\n    \"image\",\n    \"isometry version\",\n    \"AffineSubspace.equivMap\",\n    \"premise\",\n    \"conclusion\"\n]"}
{"type": "(R : Type u) →\n  [inst : CommRing R] → [inst_1 : Invertible 2] → CategoryTheory.BraidedFunctor (QuadraticModuleCat R) (ModuleCat R)", "name": "QuadraticModuleCat.toModuleCatBraidedFunctor", "isProp": false, "docString": "`forget₂ (QuadraticModuleCat R) (ModuleCat R)` as a braided functor. ", "terms": "[\n    \"QuadraticModuleCat\",\n    \"ModuleCat\",\n    \"braided functor\",\n    \"R\"\n]"}
{"type": "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} → {r : α → α → Prop} → {s : β → β → Prop} → {t : γ → γ → Prop} → r ≃r s → s ≺i t → r ≺i t", "name": "PrincipalSeg.equivLT", "isProp": false, "docString": "Composition of an order isomorphism with a principal segment, as a principal segment ", "terms": "[\n    \"Composition\",\n    \"Order Isomorphism\",\n    \"Principal Segment\"\n]"}
{"type": "∀ {α : Type u_1} {ι : Type u_3} [inst : CompleteLattice α] {s : Finset ι} {f : ι → α},\n  Finset.SupIndep s f → CompleteLattice.Independent (f ∘ Subtype.val)", "name": "Finset.SupIndep.independent", "isProp": true, "docString": "**Alias** of the reverse direction of `CompleteLattice.independent_iff_supIndep`.", "terms": "[\"Alias\", \"reverse direction\", \"CompleteLattice.independent_iff_supIndep\"]"}
{"type": "{α : Type u} → (f : Filter α) → [inst : Filter.NeBot f] → Ultrafilter α", "name": "Ultrafilter.of", "isProp": false, "docString": "Construct an ultrafilter extending a given filter.\nThe ultrafilter lemma is the assertion that such a filter exists;\nwe use the axiom of choice to pick one. ", "terms": "[\n    \"ultrafilter\",\n    \"filter\",\n    \"ultrafilter lemma\",\n    \"axiom of choice\"\n]"}
{"type": "∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : LocallyCompactSpace G] [inst_2 : Group G]\n  [inst_3 : TopologicalGroup G] [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] {μ : MeasureTheory.Measure G}\n  [inst_6 : MeasureTheory.IsFiniteMeasureOnCompacts μ] {E : Type u_2} [inst_7 : NormedAddCommGroup E]\n  [inst_8 : NormedSpace ℝ E] {g : G → E},\n  Continuous g → HasCompactSupport g → Continuous fun x => ∫ (y : G), g (y⁻¹ * x) ∂μ", "name": "MeasureTheory.continuous_integral_apply_inv_mul", "isProp": true, "docString": "The parameterized integral `x ↦ ∫ y, g (y⁻¹ * x) ∂μ` depends continuously on `y` when `g` is a\ncompactly supported continuous function on a topological group `G`, and `μ` is finite on compact\nsets. ", "terms": "[\n    \"parameterized integral\",\n    \"continuously\",\n    \"compactly supported\",\n    \"continuous function\",\n    \"topological group\",\n    \"finite\",\n    \"compact sets\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} {M : Type u_5} [inst : CommMonoid M] [inst_1 : DecidableEq α] [inst_2 : DecidableEq β]\n  (s : Finset (α × β)) (f : α × β → M),\n  (finprod fun ab => finprod fun x => f ab) = finprod fun a => finprod fun b => finprod fun x => f (a, b)", "name": "finprod_mem_finset_product'", "isProp": true, "docString": "Note that `b ∈ (s.filter (fun ab => Prod.fst ab = a)).image Prod.snd` iff `(a, b) ∈ s` so\nwe can simplify the right hand side of this lemma. However the form stated here is more useful for\niterating this lemma, e.g., if we have `f : α × β × γ → M`. ", "terms": "[\n    \"∈\",\n    \"filter\",\n    \"fun\",\n    \"Prod.fst\",\n    \"image\",\n    \"Prod.snd\",\n    \"iff\",\n    \"lemma\",\n    \"iterating\",\n    \"→\"\n]"}
{"type": "(M : Type u_1) → [inst : Monoid M] → Monoid.Coprod M PUnit.{u_4 + 1} ≃* M", "name": "Monoid.MulEquiv.coprodPUnit", "isProp": false, "docString": "Isomorphism between `M ∗ PUnit` and `M`. ", "terms": "[\n  \"Isomorphism\",\n  \"M ∗ PUnit\",\n  \"M\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      {X Y : C} →\n        {f : X ⟶ Y} →\n          {P : C} →\n            {ι ι' : P ⟶ X} →\n              {w : CategoryTheory.CategoryStruct.comp ι f = 0} →\n                (h : ι = ι') →\n                  CategoryTheory.Limits.KernelFork.ofι ι w ≅\n                    CategoryTheory.Limits.KernelFork.ofι ι' (_ : CategoryTheory.CategoryStruct.comp ι' f = 0)", "name": "CategoryTheory.Limits.ofιCongr", "isProp": false, "docString": "If `ι = ι'`, then `fork.ofι ι _` and `fork.ofι ι' _` are isomorphic. ", "terms": "[\"isomorphic\", \"fork.of\"]"}
{"type": "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners 𝕜 E H} {M : Type u_4}\n  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {E' : Type u_5}\n  [inst_7 : NormedAddCommGroup E'] [inst_8 : NormedSpace 𝕜 E'] {H' : Type u_6} [inst_9 : TopologicalSpace H']\n  {I' : ModelWithCorners 𝕜 E' H'} {M' : Type u_7} [inst_10 : TopologicalSpace M'] [inst_11 : ChartedSpace H' M']\n  [inst_12 : SmoothManifoldWithCorners I' M'] {e : PartialHomeomorph M H} {e' : PartialHomeomorph M' H'} {f : M → M'}\n  {s : Set M} {n : ℕ∞} {x : M},\n  e ∈ SmoothManifoldWithCorners.maximalAtlas I M →\n    e' ∈ SmoothManifoldWithCorners.maximalAtlas I' M' →\n      s ⊆ e.source →\n        x ∈ e.source →\n          f x ∈ e'.source →\n            (ContMDiffWithinAt I I' n f s x ↔\n              ContinuousWithinAt f s x ∧\n                ContDiffWithinAt 𝕜 n\n                  (↑(PartialHomeomorph.extend e' I') ∘ f ∘ ↑(PartialEquiv.symm (PartialHomeomorph.extend e I)))\n                  (↑(PartialHomeomorph.extend e I) '' s) (↑(PartialHomeomorph.extend e I) x))", "name": "contMDiffWithinAt_iff_image", "isProp": true, "docString": "An alternative formulation of `contMDiffWithinAt_iff_of_mem_maximalAtlas`\nif the set if `s` lies in `e.source`. ", "terms": "[\n  \"alternative formulation\",\n  \"contMDiffWithinAt_iff_of_mem_maximalAtlas\",\n  \"set\",\n  \"lies\",\n  \"source\"\n]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {p₁ p₂ p₃ : P}, EuclideanGeometry.angle p₁ p₂ p₃ = Real.pi → Collinear ℝ {p₁, p₂, p₃}", "name": "EuclideanGeometry.collinear_of_angle_eq_pi", "isProp": true, "docString": "If the angle between three points is π, they are collinear. ", "terms": "[\n    \"angle\",\n    \"three points\",\n    \"π\",\n    \"collinear\"\n]"}
{"type": "∀ (A : Type u_4) [inst : CommRing A] [inst_1 : IsDomain A] {L : Type u_6} [inst_2 : Field L] [inst_3 : Algebra A L]\n  (C : Type u_7) [inst_4 : CommRing C] [inst_5 : IsDomain C] [inst_6 : Algebra C L] [inst_7 : IsIntegralClosure C A L]\n  [inst_8 : Algebra A C] [inst_9 : IsScalarTower A C L],\n  Algebra.IsAlgebraic A L → (∀ (x : A), (algebraMap A L) x = 0 → x = 0) → IsFractionRing C L", "name": "IsIntegralClosure.isFractionRing_of_algebraic", "isProp": true, "docString": "If the field `L` is an algebraic extension of the integral domain `A`,\nthe integral closure `C` of `A` in `L` has fraction field `L`. ", "terms": "[\n  \"field\",\n  \"algebraic extension\",\n  \"integral domain\",\n  \"integral closure\",\n  \"fraction field\"\n]"}
{"type": "∀ (α : Type u) (r : α → α → Prop) [inst : IsSymm α r], IsSymmOp α Prop r", "name": "isSymmOp_of_isSymm", "isProp": true, "docString": "The opposite of a symmetric relation is symmetric. ", "terms": "[\"opposite\", \"symmetric relation\", \"is\", \"symmetric\"]"}
{"type": "(α : Type u_1) → PEmpty.{u_2 + 1} × α ≃ PEmpty.{u_3}", "name": "Equiv.pemptyProd", "isProp": false, "docString": "`PEmpty` type is a left absorbing element for type product up to an equivalence. ", "terms": "[\n  \"PEmpty\",\n  \"type\",\n  \"left absorbing element\",\n  \"type product\",\n  \"equivalence\"\n]"}
{"type": "(C : Type u_1) →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      [inst_2 : CategoryTheory.Limits.HasKernels C] →\n        [inst_3 : CategoryTheory.Limits.HasCokernels C] →\n          CategoryTheory.ShortComplex.rightHomologyFunctor C ⟶ CategoryTheory.ShortComplex.opcyclesFunctor C", "name": "CategoryTheory.ShortComplex.rightHomologyιNatTrans", "isProp": false, "docString": "The natural transformation `S.rightHomology ⟶ S.opcycles` for all short complexes `S`. ", "terms": "[\n  \"natural transformation\",\n  \"rightHomology\",\n  \"opcycles\",\n  \"short complexes\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {s : Set α},\n  StrictAntiOn f s → StrictAntiOn (⇑OrderDual.toDual ∘ f ∘ ⇑OrderDual.ofDual) s", "name": "StrictAntiOn.dual", "isProp": true, "docString": "**Alias** of the reverse direction of `strictAntiOn_dual_iff`.", "terms": "[\"Alias\", \"reverse direction\", \"strictAntiOn_dual_iff\"]"}
{"type": "∀ {𝕂 : Type u_1} {𝔸 : Type u_2} [inst : IsROrC 𝕂] [inst_1 : NormedRing 𝔸] [inst_2 : NormedAlgebra 𝕂 𝔸]\n  [inst_3 : CompleteSpace 𝔸], HasStrictFDerivAt (NormedSpace.exp 𝕂) 1 0", "name": "hasStrictFDerivAt_exp_zero", "isProp": true, "docString": "The exponential in a Banach algebra `𝔸` over `𝕂 = ℝ` or `𝕂 = ℂ` has strict Fréchet derivative\n`1 : 𝔸 →L[𝕂] 𝔸` at zero. ", "terms": "[\n    \"exponential\",\n    \"Banach algebra\",\n    \"over\",\n    \"𝕂\",\n    \"ℝ\",\n    \"ℂ\",\n    \"strict\",\n    \"Fréchet derivative\",\n    \"1\",\n    \"→L[𝕂]\",\n    \"at\",\n    \"zero\"\n]"}
{"type": "{n : Type u_3} → {R : Type u_6} → [inst : Fintype n] → [inst : AddCommMonoid R] → Matrix n n R → R", "name": "Matrix.trace", "isProp": false, "docString": "The trace of a square matrix. For more bundled versions, see:\n* `Matrix.traceAddMonoidHom`\n* `Matrix.traceLinearMap`\n", "terms": "[\"trace\", \"square matrix\", \"Matrix.traceAddMonoidHom\", \"Matrix.traceLinearMap\"]"}
{"type": "ℕ", "name": "System.Platform.numBits", "isProp": false, "docString": "Gets the word size of the platform. That is, whether the platform is 64 or 32 bits. ", "terms": "[]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {X Y Z : C} →\n      (f : X ⟶ Y) →\n        (g : X ⟶ Z) →\n          CategoryTheory.Limits.cospan f.op g.op ≅\n            CategoryTheory.Functor.comp CategoryTheory.Limits.walkingSpanOpEquiv.inverse\n              (CategoryTheory.Limits.span f g).op", "name": "CategoryTheory.Limits.cospanOp", "isProp": false, "docString": "The canonical isomorphism relating `Cospan f.op g.op` and `(Span f g).op` ", "terms": "[\n  \"Canonical\",\n  \"Isomorphism\",\n  \"Cospan\",\n  \"op\",\n  \"Span\"\n]"}
{"type": "∀ (l : List ℕ), List.Pairwise List.Disjoint (List.ranges l)", "name": "List.ranges_disjoint", "isProp": true, "docString": "The members of `l.ranges` are pairwise disjoint ", "terms": "[\"members\", \"pairwise disjoint\", \"ranges\"]"}
{"type": "ℕ+ ≃o ℕ", "name": "OrderIso.pnatIsoNat", "isProp": false, "docString": "The order isomorphism between ℕ and ℕ+ given by `succ`. ", "terms": "[\n  \"Order Isomorphism\",\n  \"ℕ (Natural Numbers)\",\n  \"ℕ+ (Positive Natural Numbers)\",\n  \"Given\",\n  \"`succ` (Successor Function)\"\n]"}
{"type": "∀ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G],\n  ∃ ι x p, ∃ (_ : ∀ (i : ι), Nat.Prime (p i)), ∃ e, Nonempty (G ≃+ DirectSum ι fun i => ZMod (p i ^ e i))", "name": "AddCommGroup.equiv_directSum_zmod_of_fintype", "isProp": true, "docString": "**Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. ", "terms": "[\n    \"Structure theorem of finite abelian groups\",\n    \"finite abelian group\",\n    \"direct sum\",\n    \"ZMod\",\n    \"prime powers\"\n]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] →\n      {S₁ S₂ : CategoryTheory.ShortComplex.SnakeInput C} →\n        CategoryTheory.ShortComplex.SnakeInput.Hom S₁ S₂ → (S₁.L₁ ⟶ S₂.L₁)", "name": "CategoryTheory.ShortComplex.SnakeInput.Hom.f₁", "isProp": false, "docString": "a morphism between the first lines ", "terms": "[\"morphism\", \"first lines\"]"}
{"type": "{R : Type u} → [inst : Semiring R] → Polynomial R → Polynomial R", "name": "Polynomial.integralNormalization", "isProp": false, "docString": "If `f : R[X]` is a nonzero polynomial with root `z`, `integralNormalization f` is\na monic polynomial with root `leadingCoeff f * z`.\n\nMoreover, `integralNormalization 0 = 0`.\n", "terms": "[\n    \"nonzero polynomial\",\n    \"root\",\n    \"integralNormalization\",\n    \"monic polynomial\",\n    \"leadingCoeff\"\n]"}
{"type": "(J : Type v) → (f : J → ωCPO) → CategoryTheory.Limits.IsLimit (ωCPO.HasProducts.product f)", "name": "ωCPO.HasProducts.isProduct", "isProp": false, "docString": "The pi-type is a limit cone for the product. ", "terms": "[\n    \"pi-type\",\n    \"limit cone\",\n    \"product\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {v : Set E}, Orthonormal 𝕜 Subtype.val → ((∀ u ⊇ v, Orthonormal 𝕜 Subtype.val → u = v) ↔ (Submodule.span 𝕜 v)ᗮ = ⊥)", "name": "maximal_orthonormal_iff_orthogonalComplement_eq_bot", "isProp": true, "docString": "An orthonormal set in an `InnerProductSpace` is maximal, if and only if the orthogonal\ncomplement of its span is empty. ", "terms": "[\n  \"Orthonormal set\",\n  \"InnerProductSpace\",\n  \"Maximal\",\n  \"Orthogonal complement\",\n  \"Span\",\n  \"Empty\"\n]"}
{"type": "{R : Type u} → [inst : CommRing R] → CategoryTheory.Functor (AlgebraCat R) (Mon_ (ModuleCat R))", "name": "ModuleCat.MonModuleEquivalenceAlgebra.inverse", "isProp": false, "docString": "Converting a bundled algebra to a monoid object in `ModuleCat R`.\n", "terms": "[\n    \"Converting\",\n    \"bundled algebra\",\n    \"monoid object\",\n    \"ModuleCat R\"\n]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]\n  {E : Type u₃} [inst_2 : CategoryTheory.Category.{v₃, u₃} E] (F : CategoryTheory.Functor C D)\n  (G : CategoryTheory.Functor D E) [inst_3 : CategoryTheory.IsEquivalence F],\n  CategoryTheory.Functor.Initial G ↔ CategoryTheory.Functor.Initial (CategoryTheory.Functor.comp F G)", "name": "CategoryTheory.Functor.initial_iff_equivalence_comp", "isProp": true, "docString": "See also the strictly more general `initial_iff_initial_comp` below. ", "terms": "[]"}
{"type": "{ι : Type u_1} → (ι → Cardinal.{u_2}) → Cardinal.{max u_2 u_1}", "name": "Cardinal.sum", "isProp": false, "docString": "The indexed sum of cardinals is the cardinality of the\nindexed disjoint union, i.e. sigma type. ", "terms": "[\n\"Indexed sum\",\n\"Cardinals\",\n\"Cardinality\",\n\"Indexed disjoint union\",\n\"Sigma type\"\n]"}
{"type": "∀ {R : Type u_6} {A : Type u_7} [inst : AddMonoid A] [inst_1 : VAdd R A] [inst_2 : VAddCommClass R A A]\n  [inst_3 : TopologicalSpace A] [inst : ContinuousAdd A], ContinuousConstVAdd R A", "name": "VAddCommClass.continuousConstVAdd", "isProp": true, "docString": "If the action of `R` on `A` commutes with left-addition, then\ncontinuous addition implies continuous affine addition by constants.\n\nNotably, this instances applies when `R = Aᵃᵒᵖ`.", "terms": "[\n    \"action\",\n    \"commutes\",\n    \"left-addition\",\n    \"continuous\",\n    \"addition\",\n    \"affine addition\",\n    \"constants\",\n    \"instances\",\n    \"opposite algebra\"\n]"}
{"type": "{R : Type u} →\n  {L : Type v} →\n    [inst : CommRing R] →\n      [inst_1 : LieRing L] → [inst_2 : LieAlgebra R L] → {I₁ I₂ : LieIdeal R L} → I₁ ≤ I₂ → ↥↑I₁ →ₗ⁅R⁆ ↥↑I₂", "name": "LieIdeal.inclusion", "isProp": false, "docString": "Given two nested Lie ideals `I₁ ⊆ I₂`, the inclusion `I₁ ↪ I₂` is a morphism of Lie algebras. ", "terms": "[\n  \"nested\",\n  \"Lie ideals\",\n  \"inclusion\",\n  \"morphism\",\n  \"Lie algebras\"\n]"}
{"type": "{A : Type u_1} →\n  {ι : Type u_2} →\n    [inst : Ring A] → [inst_1 : Nonempty ι] → {B : ι → AddSubgroup A} → RingSubgroupsBasis B → TopologicalSpace A", "name": "RingSubgroupsBasis.topology", "isProp": false, "docString": "The topology defined from a subgroups basis, admitting the given subgroups as a basis\nof neighborhoods of zero. ", "terms": "[\n    \"topology\",\n    \"subgroups\",\n    \"basis\",\n    \"neighborhoods\",\n    \"zero\"\n]"}
{"type": "∀ {α : Type u_4} [self : CompletePartialOrder α] (d : Set α), DirectedOn (fun x x_1 => x ≤ x_1) d → IsLUB d (sSup d)", "name": "CompletePartialOrder.lubOfDirected", "isProp": true, "docString": "For each directed set `d`, `sSup d` is the least upper bound of `d`. ", "terms": "[\n    \"directed set\",\n    \"least upper bound\"\n]"}
{"type": "Type u → Type u", "name": "FreeCommRing", "isProp": false, "docString": "`FreeCommRing α` is the free commutative ring on the type `α`. ", "terms": "[\"FreeCommRing\", \"free\", \"commutative\", \"ring\", \"type\"]"}
{"type": "{R : Type u} →\n  {A : Type v} →\n    [inst : CommSemiring R] →\n      [inst_1 : NonUnitalNonAssocSemiring A] →\n        [inst_2 : Module R A] →\n          [inst_3 : IsScalarTower R A A] →\n            [inst_4 : SMulCommClass R A A] → {S T : NonUnitalSubalgebra R A} → S ≤ T → ↥S →ₙₐ[R] ↥T", "name": "NonUnitalSubalgebra.inclusion", "isProp": false, "docString": "The map `S → T` when `S` is a non-unital subalgebra contained in the non-unital subalgebra `T`.\n\nThis is the non-unital subalgebra version of `Submodule.inclusion`, or `Subring.inclusion`  ", "terms": "[\n    \"map\",\n    \"non-unital subalgebra\",\n    \"contained\",\n    \"Submodule.inclusion\",\n    \"Subring.inclusion\"\n]"}
{"type": "∀ (x : ℂ) (n : ℤ) (y : ℂ), x ^ (↑n * y) = (x ^ y) ^ n", "name": "Complex.cpow_int_mul", "isProp": true, "docString": "See also `Complex.cpow_int_mul'`. ", "terms": "[\"Complex.cpow_int_mul\"]"}
{"type": "ℕ+ → ℕ+ → PNat.XgcdType", "name": "PNat.XgcdType.start", "isProp": false, "docString": "The following function provides the starting point for\nour algorithm.  We will apply an iterative reduction process\nto it, which will produce a system satisfying IsReduced.\nThe gcd can be read off from this final system.\n", "terms": "[\n    \"function\",\n    \"algorithm\",\n    \"iterative\",\n    \"reduction\",\n    \"process\",\n    \"system\",\n    \"IsReduced\",\n    \"gcd\"\n]"}
{"type": "∀ {R : Type u} [inst : Semiring R], IsField R → ∃ x y, x ≠ y", "name": "IsField.exists_pair_ne", "isProp": true, "docString": "For a semiring to be a field, it must have two distinct elements. ", "terms": "[\n    \"semiring\",\n    \"field\",\n    \"elements\",\n    \"distinct\"\n]"}
{"type": "{ι : Type u_1} →\n  {V : Type u} →\n    [inst : CategoryTheory.Category.{v, u} V] →\n      [inst_1 : CategoryTheory.Preadditive V] →\n        {c : ComplexShape ι} → {C D : HomologicalComplex V c} → HomotopyEquiv C D → HomotopyEquiv D C", "name": "HomotopyEquiv.symm", "isProp": false, "docString": "Being homotopy equivalent is a symmetric relation. ", "terms": "[\"homotopy equivalent\", \"symmetric relation\"]"}
{"type": "∀ {α : Type u} [inst : LinearOrder α] {x y : α}, x < y ∨ y < x ↔ x ≠ y", "name": "lt_or_lt_iff_ne", "isProp": true, "docString": "A version of `ne_iff_lt_or_gt` with LHS and RHS reversed. ", "terms": "[\"version\", \"ne_iff_lt_or_gt\", \"LHS\", \"RHS\", \"reversed\"]"}
{"type": "∀ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace ℝ E] {f : ℝ → E}\n  {a b : ℝ},\n  IntervalIntegrable f MeasureTheory.volume a b →\n    StronglyMeasurableAtFilter f (nhds a) →\n      StronglyMeasurableAtFilter f (nhds b) →\n        ContinuousAt f a →\n          ContinuousAt f b →\n            fderiv ℝ (fun p => ∫ (x : ℝ) in p.1 ..p.2, f x) (a, b) =\n              ContinuousLinearMap.smulRight (ContinuousLinearMap.snd ℝ ℝ ℝ) (f b) -\n                ContinuousLinearMap.smulRight (ContinuousLinearMap.fst ℝ ℝ ℝ) (f a)", "name": "intervalIntegral.fderiv_integral", "isProp": true, "docString": "**Fundamental theorem of calculus-1**: if `f : ℝ → E` is integrable on `a..b` and `f` is\ncontinuous at `a` and `b`, then `fderiv` derivative of `(u, v) ↦ ∫ x in u..v, f x` at `(a, b)`\nequals `(u, v) ↦ v • cb - u • ca`. ", "terms": "[\n    \"Fundamental theorem of calculus-1\",\n    \"integrable\",\n    \"continuous\",\n    \"fderiv\",\n    \"derivative\",\n    \"equals\"\n]"}
{"type": "∀ {α : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : UniformSpace G] [inst_2 : UniformGroup G],\n  UniformGroup (UniformFun α G)", "name": "instUniformGroupUniformFunUniformSpaceInstGroupUniformFun", "isProp": true, "docString": "If `G` is a uniform group, then `α →ᵤ G` is a uniform group as well. ", "terms": "[\n    \"uniform group\"\n]"}
{"type": "{s : Type u_1} →\n  (X : AlgebraicGeometry.Scheme) →\n    (U : s → TopologicalSpace.Opens ↑↑X.toPresheafedSpace) → ⨆ i, U i = ⊤ → AlgebraicGeometry.Scheme.OpenCover X", "name": "AlgebraicGeometry.Scheme.openCoverOfSuprEqTop", "isProp": false, "docString": "If `U` is a family of open sets that covers `X`, then `X.restrict U` forms an `X.open_cover`. ", "terms": "[\n    \"family\",\n    \"open sets\",\n    \"covers\",\n    \"restrict\",\n    \"open_cover\"\n]"}
{"type": "∀ {R : Type u} [inst : CommRing R] (I J : Ideal R), RingHom.ker (DoubleQuot.quotQuotMk I J) = I ⊔ J", "name": "DoubleQuot.ker_quotQuotMk", "isProp": true, "docString": "The kernel of `quotQuotMk` ", "terms": "[\"kernel\"]"}
{"type": "∀ {α : Type u_1} [inst : LinearOrder α] {𝒜 : Finset (Finset α)} {r : ℕ} [inst_1 : Fintype α],\n  Finset.Colex.IsInitSeg 𝒜 r ∧ Finset.Nonempty 𝒜 ↔ ∃ s, Finset.card s = r ∧ 𝒜 = Finset.Colex.initSeg s", "name": "Finset.Colex.isInitSeg_iff_exists_initSeg", "isProp": true, "docString": "Being a nonempty initial segment of colex is equivalent to being an `initSeg`. ", "terms": "[\n  \"nonempty\",\n  \"initial segment\",\n  \"colex\",\n  \"equivalent\",\n  \"`initSeg`\"\n]"}
{"type": "∀ {α : Type u} [inst : Preorder α] [inst_1 : OrderTop α] {a b : α}, a < b → a ≠ ⊤", "name": "LT.lt.ne_top", "isProp": true, "docString": "**Alias** of `ne_top_of_lt`.", "terms": "[]\n"}
{"type": "(K : Type u_1) → [inst : Field K] → [inst : NumberField K] → ℕ", "name": "NumberField.InfinitePlace.NrRealPlaces", "isProp": false, "docString": "The number of infinite real places of the number field `K`. ", "terms": "[\n    \"number\",\n    \"infinite\",\n    \"real places\",\n    \"number field\"\n]"}
{"type": "{α : Type u_1} →\n  {β : Type u_2} →\n    (r : α → α → Prop) →\n      (s : β → β → Prop) → [inst : IsRefl α r] → [inst : IsRefl β s] → [inst : Unique α] → [inst : Unique β] → r ≃r s", "name": "RelIso.relIsoOfUniqueOfRefl", "isProp": false, "docString": "Two reflexive relations on a unique type are isomorphic. ", "terms": "[\n    \"Two\",\n    \"reflexive relations\",\n    \"on\",\n    \"a\",\n    \"unique\",\n    \"type\",\n    \"are\",\n    \"isomorphic\"\n]"}
{"type": "{𝕜 : Type u_1} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type u_2} →\n      [inst_1 : SeminormedAddCommGroup E] → [inst_2 : NormedSpace 𝕜 E] → NormedSpace.Dual 𝕜 E ≃ₗ[𝕜] WeakDual 𝕜 E", "name": "NormedSpace.Dual.toWeakDual", "isProp": false, "docString": "For normed spaces `E`, there is a canonical map `Dual 𝕜 E → WeakDual 𝕜 E` (the \"identity\"\nmapping). It is a linear equivalence. ", "terms": "[\n    \"normed spaces\",\n    \"canonical map\",\n    \"Dual 𝕜 E\",\n    \"WeakDual 𝕜 E\",\n    \"identity mapping\",\n    \"linear equivalence\"\n]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.IsFilteredOrEmpty C] {i j j' : C}\n  (f : i ⟶ j) (f' : i ⟶ j'), ∃ k g g', CategoryTheory.CategoryStruct.comp f g = CategoryTheory.CategoryStruct.comp f' g'", "name": "CategoryTheory.IsFiltered.span", "isProp": true, "docString": "For every span `j ⟵ i ⟶ j'`, there\nexists a cocone `j ⟶ k ⟵ j'` such that the square commutes. ", "terms": "[\n    \"span\",\n    \"exists\",\n    \"cocone\",\n    \"square\",\n    \"commutes\"\n]"}
{"type": "∀ {d : ℤ} {a : Pell.Solution₁ d}, Pell.IsFundamental a → ∀ {n n' : ℤ}, a ^ n ≠ -a ^ n'", "name": "Pell.IsFundamental.zpow_ne_neg_zpow", "isProp": true, "docString": "A power of a fundamental solution is never equal to the negative of a power of this\nfundamental solution. ", "terms": "[\n    \"power\",\n    \"fundamental solution\",\n    \"negative\",\n    \"equal\"\n]"}
{"type": "(C : Type u) →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasPullbacks C] →\n      CategoryTheory.GrothendieckTopology C → CategoryTheory.Pretopology C", "name": "CategoryTheory.Pretopology.ofGrothendieck", "isProp": false, "docString": "The largest pretopology generating the given Grothendieck topology.\n\nSee [MM92] Chapter III, Section 2, Equations (3,4).\n", "terms": "[\n    \"largest\",\n    \"pretopology\",\n    \"generating\",\n    \"given\",\n    \"Grothendieck topology\"\n]"}
{"type": "{α : Type u_1} →\n  {E : Type u_2} →\n    {F : Type u_3} →\n      {m0 : MeasurableSpace α} →\n        {p : ENNReal} →\n          {μ : MeasureTheory.Measure α} →\n            [inst : NormedAddCommGroup E] →\n              [inst_1 : NormedAddCommGroup F] →\n                {𝕜 : Type u_5} →\n                  [inst_2 : NontriviallyNormedField 𝕜] →\n                    [inst_3 : NormedSpace 𝕜 E] →\n                      [inst_4 : NormedSpace 𝕜 F] → (E →L[𝕜] F) → ↥(MeasureTheory.Lp E p) → ↥(MeasureTheory.Lp F p)", "name": "ContinuousLinearMap.compLp", "isProp": false, "docString": "Composing `f : Lp` with `L : E →L[𝕜] F`. ", "terms": "[\n    \"Composing\",\n    \"f\",\n    \"Lp\",\n    \"L\",\n    \"E\",\n    \"F\",\n    \"→L[𝕜]\"\n]"}
{"type": "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X] {K U : Set X},\n  IsCompact K → IsOpen U → K ⊆ U → ∃ V, IsOpen V ∧ K ⊆ V ∧ closure V ⊆ U ∧ IsCompact (closure V)", "name": "exists_open_between_and_isCompact_closure", "isProp": true, "docString": "In a locally compact T₂ space, given a compact set `K` inside an open set `U`, we can find an\nopen set `V` between these sets with compact closure: `K ⊆ V` and the closure of `V` is inside `U`.\n", "terms": "[\n  \"locally compact\",\n  \"T₂ space\",\n  \"compact set\",\n  \"open set\",\n  \"between\",\n  \"closure\",\n  \"inside\"\n]"}
{"type": "∀ {β : Type v} {π : β → Type u_3} [inst : Fintype β] [inst_1 : (b : β) → PseudoMetricSpace (π b)]\n  [h : ∀ (b : β), ProperSpace (π b)], ProperSpace ((b : β) → π b)", "name": "pi_properSpace", "isProp": true, "docString": "A finite product of proper spaces is proper. ", "terms": "[\n  \"finite product\",\n  \"proper spaces\"\n]"}
{"type": "Lean.Expr → Lean.Elab.Tactic.TacticM Unit → Lean.MetaM Lean.Expr", "name": "synthesizeUsing'", "isProp": false, "docString": "`synthesizeUsing type tac` synthesizes an element of type `type` using tactic `tac`.\n\nThe tactic must solve for all goals, in contrast to `synthesizeUsing`.\n", "terms": "[]"}
{"type": "∀ {D : Set ℝ}, Convex ℝ D → ∀ {f : ℝ → ℝ}, ContinuousOn f D → (∀ x ∈ interior D, deriv f x < 0) → StrictAntiOn f D", "name": "Convex.strictAntiOn_of_deriv_neg", "isProp": true, "docString": "Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f'` is negative, then\n`f` is a strictly antitone function on `D`. ", "terms": "[\n    \"function\",\n    \"continuous\",\n    \"convex\",\n    \"connected\",\n    \"subset\",\n    \"real line\",\n    \"differentiable\",\n    \"interior\",\n    \"negative\",\n    \"strictly antitone function\"\n]"}
{"type": "∀ (A : Type u_2) [inst : CommRing A] (K : Type u_4) [inst_1 : Field K] [inst_2 : Algebra A K]\n  [inst_3 : IsFractionRing A K],\n  IsDedekindDomain A ↔\n    IsDomain A ∧ IsNoetherianRing A ∧ Ring.DimensionLEOne A ∧ ∀ {x : K}, IsIntegral A x → ∃ y, (algebraMap A K) y = x", "name": "isDedekindDomain_iff", "isProp": true, "docString": "An integral domain is a Dedekind domain iff and only if it is\nNoetherian, has dimension ≤ 1, and is integrally closed in a given fraction field.\nIn particular, this definition does not depend on the choice of this fraction field. ", "terms": "[\n    \"Integral domain\",\n    \"Dedekind domain\",\n    \"Noetherian\",\n    \"Dimension\",\n    \"Integrally closed\",\n    \"Fraction field\"\n]"}
{"type": "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} → {r : α → α → Prop} → {s : β → β → Prop} → {t : γ → γ → Prop} → r ≺i s → s ≼i t → r ≺i t", "name": "PrincipalSeg.ltLe", "isProp": false, "docString": "Composition of a principal segment with an initial segment, as a principal segment ", "terms": "[\n    \"Composition\",\n    \"Principal Segment\",\n    \"Initial Segment\"\n]"}
{"type": "{C : Type u} → [inst : CategoryTheory.Category.{v, u} C] → CategoryTheory.Monad C → Type u", "name": "CategoryTheory.Kleisli", "isProp": false, "docString": "The objects for the Kleisli category of the monad `T : Monad C`, which are the same\nthing as objects of the base category `C`.\n", "terms": "[\n    \"objects\",\n    \"Kleisli category\",\n    \"monad\",\n    \"base category\"\n]"}
{"type": "∀ {M : Type u_6} {N : Type u_7} [inst : Add M] [inst_1 : Add N] {f g : M ≃+ N}, (∀ (x : M), f x = g x) → f = g", "name": "AddEquiv.ext", "isProp": true, "docString": "Two additive isomorphisms agree if they are defined by the same underlying function.", "terms": "[\n    \"Two\",\n    \"additive\",\n    \"isomorphisms\",\n    \"agree\",\n    \"defined\",\n    \"same\",\n    \"underlying\",\n    \"function\"\n]"}
{"type": "∀ {p : ℕ},\n  Nat.Prime p →\n    ∀ {s t : Finset (ZMod p)},\n      Finset.Nonempty s → Finset.Nonempty t → min p (Finset.card s + Finset.card t - 1) ≤ Finset.card (s + t)", "name": "ZMod.min_le_card_add", "isProp": true, "docString": "The **Cauchy-Davenport Theorem**. If `s`, `t` are nonempty sets in $$ℤ/pℤ$$, then the size of\n`s + t` is lower-bounded by `|s| + |t| - 1`, unless this quantity is greater than `p`. ", "terms": "[\n    \"Cauchy-Davenport Theorem\",\n    \"nonempty sets\",\n    \"ℤ/pℤ\",\n    \"size\",\n    \"lower-bounded\",\n    \"quantity\",\n    \"greater than\"\n]"}
{"type": "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {G : Type uG}\n  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace 𝕜 G] {g : F → G} {f : E → F} {n : ℕ} {s : Set E} {t : Set F}\n  {x : E} {N : ℕ∞},\n  ContDiffOn 𝕜 N g t →\n    ContDiffOn 𝕜 N f s →\n      ↑n ≤ N →\n        UniqueDiffOn 𝕜 t →\n          UniqueDiffOn 𝕜 s →\n            Set.MapsTo f s t →\n              x ∈ s →\n                ∀ {C D : ℝ},\n                  (∀ i ≤ n, ‖iteratedFDerivWithin 𝕜 i g t (f x)‖ ≤ C) →\n                    (∀ (i : ℕ), 1 ≤ i → i ≤ n → ‖iteratedFDerivWithin 𝕜 i f s x‖ ≤ D ^ i) →\n                      ‖iteratedFDerivWithin 𝕜 n (g ∘ f) s x‖ ≤ ↑(Nat.factorial n) * C * D ^ n", "name": "norm_iteratedFDerivWithin_comp_le", "isProp": true, "docString": "If the derivatives within a set of `g` at `f x` are bounded by `C`, and the `i`-th derivative\nwithin a set of `f` at `x` is bounded by `D^i` for all `1 ≤ i ≤ n`, then the `n`-th derivative\nof `g ∘ f` is bounded by `n! * C * D^n`. ", "terms": "[\n    \"derivatives\",\n    \"set\",\n    \"bounded\",\n    \"i-th derivative\",\n    \"for all\",\n    \"n-th derivative\",\n    \"composition\",\n    \"factorial\",\n    \"exponentiation\"\n]"}
{"type": "∀ {n : ℕ}, Fin n → 0 < n", "name": "Fin.size_pos", "isProp": true, "docString": "If you actually have an element of `Fin n`, then the `n` is always positive ", "terms": "[\"element\", \"Fin n\", \"positive\"]"}
{"type": "∀ {α : Type u_2} [inst : Lattice α] [self : IsModularLattice α] {x : α} (y : α) {z : α}, x ≤ z → (x ⊔ y) ⊓ z ≤ x ⊔ y ⊓ z", "name": "IsModularLattice.sup_inf_le_assoc_of_le", "isProp": true, "docString": "Whenever `x ≤ z`, then for any `y`, `(x ⊔ y) ⊓ z ≤ x ⊔ (y ⊓ z)`  ", "terms": "[\n    \"≤\",\n    \"⊔\",\n    \"⊓\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {F : Type u_6} [inst : NontriviallyNormedField 𝕜] [inst_1 : SeminormedAddCommGroup F]\n  [inst_2 : NormedSpace 𝕜 F] (q : Seminorm 𝕜 F), Continuous ⇑q → ∀ {x : F}, ‖x‖ = 0 → q x = 0", "name": "Seminorm.map_eq_zero_of_norm_zero", "isProp": true, "docString": "In a semi-`NormedSpace`, a continuous seminorm is zero on elements of norm `0`. ", "terms": "[\"semi-NormedSpace\", \"continuous\", \"seminorm\", \"zero\", \"elements\", \"norm\"]"}
{"type": "∀ (p : ℝ), ProperlyDiscontinuousVAdd ↥(AddSubgroup.op (AddSubgroup.zmultiples p)) ℝ", "name": "AddCircle.instProperlyDiscontinuousVAddSubtypeAddOppositeRealMemAddSubgroupAddGroupInstAddGroupRealInstMembershipInstSetLikeAddSubgroupOpZmultiplesToTopologicalSpaceToUniformSpacePseudoMetricSpaceVaddToAddZeroClassToAddMonoidToSubNegMonoidToHasOppositeVAddInstAddRealToAddSubmonoid", "isProp": true, "docString": "The action on `ℝ` by right multiplication of its the subgroup `zmultiples p` (the multiples of\n`p:ℝ`) is properly discontinuous. ", "terms": "[\n  \"Action\",\n  \"ℝ\",\n  \"Right Multiplication\",\n  \"Subgroup\",\n  \"Multiples\",\n  \"Properly Discontinuous\"\n]"}
{"type": "∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2", "name": "Nat.sq_add_sq_mul", "isProp": true, "docString": "The set of natural numbers that are sums of two squares is closed under multiplication. ", "terms": "[\n    \"Set\",\n    \"Natural numbers\",\n    \"Sums\",\n    \"Squares\",\n    \"Closed\",\n    \"Multiplication\"\n]"}
{"type": "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y z : V},\n  x ≠ 0 → y ≠ 0 → z ≠ 0 → Orientation.oangle o x y + Orientation.oangle o y z + Orientation.oangle o z x = 0", "name": "Orientation.oangle_add_cyc3", "isProp": true, "docString": "Given three nonzero vectors, adding the angles between them in cyclic order results in 0. ", "terms": "[\"nonzero\", \"vectors\", \"adding\", \"angles\", \"between\", \"cyclic order\", \"results in\"]"}
{"type": "∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : LocallyCompactSpace G] [inst_2 : Group G]\n  [inst_3 : TopologicalGroup G] [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] (μ' μ : MeasureTheory.Measure G)\n  [inst_6 : MeasureTheory.IsProbabilityMeasure μ] [inst_7 : MeasureTheory.IsProbabilityMeasure μ']\n  [inst_8 : MeasureTheory.Measure.InnerRegularCompactLTTop μ] [inst : MeasureTheory.Measure.InnerRegularCompactLTTop μ']\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant μ] [inst : MeasureTheory.Measure.IsMulLeftInvariant μ'], μ' = μ", "name": "MeasureTheory.Measure.isMulLeftInvariant_eq_of_isProbabilityMeasure", "isProp": true, "docString": "**Uniqueness of left-invariant measures**: Given two left-invariant probability measures which\nare inner regular for finite measure sets with respect to compact sets, they coincide. ", "terms": "[\n\"Uniqueness\",\n\"Left-invariant measures\",\n\"Probability measures\",\n\"Inner regular\",\n\"Finite measure sets\",\n\"Compact sets\",\n\"Coincide\"\n]"}
{"type": "{R : Type u} → [inst : NonUnitalNonAssocSemiring R] → CompleteLattice (NonUnitalSubsemiring R)", "name": "NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring", "isProp": false, "docString": "Non-unital subsemirings of a non-unital semiring form a complete lattice. ", "terms": "[\n    \"Non-unital subsemirings\",\n    \"non-unital semiring\",\n    \"complete lattice\"\n]"}
{"type": "{R : Type u_1} →\n  {L : Type u_2} →\n    {K : Type u_3} →\n      [inst : CommRing R] →\n        [inst_1 : Field K] →\n          [inst_2 : Algebra R K] →\n            [inst_3 : Field L] →\n              [inst_4 : Algebra R L] →\n                {ι : Type u_4} →\n                  (v : ι → K) →\n                    {κ : Type u_5} →\n                      (w : κ → L) →\n                        [inst_5 : IsAlgClosed K] →\n                          [inst_6 : IsAlgClosed L] →\n                            ι ≃ κ → IsTranscendenceBasis R v → IsTranscendenceBasis R w → K ≃+* L", "name": "IsAlgClosed.equivOfTranscendenceBasis", "isProp": false, "docString": "setting `R` to be `ZMod (ringChar R)` this result shows that if two algebraically\nclosed fields have equipotent transcendence bases and the same characteristic then they are\nisomorphic. ", "terms": "[\n    \"ZMod\",\n    \"ringChar\",\n    \"algebraically closed fields\",\n    \"equipotent\",\n    \"transcendence bases\",\n    \"characteristic\",\n    \"isomorphic\"\n]"}
{"type": "{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : CommRing R] →\n      [inst_1 : AddCommGroup M] → [inst_2 : Module R M] → Polynomial R → PolynomialModule R M →ₗ[R] PolynomialModule R M", "name": "PolynomialModule.comp", "isProp": false, "docString": "`comp p q` is the composition of `p : R[X]` and `q : M[X]` as `q(p(x))`.  ", "terms": "[\n  \"composition\",\n  \"R[X]\",\n  \"M[X]\",\n  \"q(p(x))\"\n]"}
{"type": "∀ {ι : Type u_1} {X : Type u_3} {α : Type u_6} {β : Type u_7} [inst : TopologicalSpace X] [inst_1 : UniformSpace α]\n  [inst_2 : UniformSpace β] {F : ι → X → α} {x₀ : X} {u : α → β},\n  UniformInducing u → (EquicontinuousAt F x₀ ↔ EquicontinuousAt ((fun x => u ∘ x) ∘ F) x₀)", "name": "UniformInducing.equicontinuousAt_iff", "isProp": true, "docString": "Given `u : α → β` a uniform inducing map, a family `𝓕 : ι → X → α` is equicontinuous at a point\n`x₀ : X` iff the family `𝓕'`, obtained by precomposing each function of `𝓕` by `u`, is\nequicontinuous at `x₀`. ", "terms": "[\n    \"uniform inducing map\",\n    \"family\",\n    \"equicontinuous\",\n    \"point\",\n    \"precomposing\",\n    \"function\"\n]"}
{"type": "∀ {μ : YoungDiagram} (self : Ssyt μ) {i1 i2 j : ℕ}, i1 < i2 → (i2, j) ∈ μ → Ssyt.entry self i1 j < Ssyt.entry self i2 j", "name": "Ssyt.col_strict'", "isProp": true, "docString": "The entries in each column are strictly increasing (top to bottom). ", "terms": "[\"entries\", \"column\", \"strictly increasing\", \"top to bottom\"]"}
{"type": "∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {n : ℕ} [inst_2 : CompleteSpace E]\n  (I : BoxIntegral.Box (Fin (n + 1))) {i : Fin (n + 1)} {f : (Fin (n + 1) → ℝ) → E} {f' : (Fin (n + 1) → ℝ) →L[ℝ] E},\n  ContinuousOn f (BoxIntegral.Box.Icc I) →\n    ∀ {x : Fin (n + 1) → ℝ},\n      x ∈ BoxIntegral.Box.Icc I →\n        ∀ {a : E} {ε : ℝ},\n          0 < ε →\n            (∀ y ∈ BoxIntegral.Box.Icc I, ‖f y - a - f' (y - x)‖ ≤ ε * ‖y - x‖) →\n              ∀ {c : NNReal},\n                BoxIntegral.Box.distortion I ≤ c →\n                  ‖(Finset.prod Finset.univ fun j => BoxIntegral.Box.upper I j - BoxIntegral.Box.lower I j) •\n                          f' (Pi.single i 1) -\n                        (BoxIntegral.integral (BoxIntegral.Box.face I i) ⊥\n                            (f ∘ Fin.insertNth i (BoxIntegral.Box.upper I i)) BoxIntegral.BoxAdditiveMap.volume -\n                          BoxIntegral.integral (BoxIntegral.Box.face I i) ⊥\n                            (f ∘ Fin.insertNth i (BoxIntegral.Box.lower I i)) BoxIntegral.BoxAdditiveMap.volume)‖ ≤\n                    2 * ε * ↑c * Finset.prod Finset.univ fun j => BoxIntegral.Box.upper I j - BoxIntegral.Box.lower I j", "name": "BoxIntegral.norm_volume_sub_integral_face_upper_sub_lower_smul_le", "isProp": true, "docString": "Auxiliary lemma for the divergence theorem. ", "terms": "[\"Auxiliary lemma\", \"divergence theorem\"]"}
{"type": "ℕ∞ → PartENat", "name": "PartENat.ofENat", "isProp": false, "docString": "Coercion from `ℕ∞` to `PartENat`. ", "terms": "[\n    \"Coercion\",\n    \"ℕ∞\",\n    \"PartENat\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.IsFilteredOrEmpty C] → {j₁ j₂ : C} → (j₁ ⟶ j₂) → (j₁ ⟶ j₂) → (j₁ ⟶ j₂) → C", "name": "CategoryTheory.IsFiltered.coeq₃", "isProp": false, "docString": "`coeq₃ f g h`, for morphisms `f g h : j₁ ⟶ j₂`, is an arbitrary choice of object\nwhich admits a morphism `coeq₃Hom f g h : j₂ ⟶ coeq₃ f g h` such that\n`coeq₃_condition₁`, `coeq₃_condition₂` and `coeq₃_condition₃` are satisfied.\nIts existence is ensured by `IsFiltered`.\n", "terms": "[\n    \"coeq₃\",\n    \"morphisms\",\n    \"object\",\n    \"morphism\",\n    \"coeq₃Hom\",\n    \"coeq₃_condition₁\",\n    \"coeq₃_condition₂\",\n    \"coeq₃_condition₃\",\n    \"IsFiltered\"\n]"}
{"type": "∀ {M : Type u_1} [inst : MulOneClass M] (S : Submonoid M), S = ⊥ ∨ Nontrivial ↥S", "name": "Submonoid.bot_or_nontrivial", "isProp": true, "docString": "A submonoid is either the trivial submonoid or nontrivial. ", "terms": "[\n    \"submonoid\",\n    \"trivial submonoid\",\n    \"nontrivial\"\n]"}
{"type": "∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\n  ‖x + y‖ ^ 2 = ‖x‖ ^ 2 + 2 * inner x y + ‖y‖ ^ 2", "name": "norm_add_pow_two_real", "isProp": true, "docString": "**Alias** of `norm_add_sq_real`.\n\n---\n\nExpand the square ", "terms": "[\"Alias\", \"norm_add_sq_real\", \"Expand\", \"square\"]"}
{"type": "(C : Type u_1) →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      [inst_2 : CategoryTheory.Limits.HasKernels C] →\n        [inst_3 : CategoryTheory.Limits.HasCokernels C] →\n          CategoryTheory.ShortComplex.opcyclesFunctor C ⟶ CategoryTheory.ShortComplex.π₃", "name": "CategoryTheory.ShortComplex.fromOpcyclesNatTrans", "isProp": false, "docString": "The natural transformation `S.opcycles ⟶ S.X₃` for all short complexes `S`. ", "terms": "[\n    \"natural transformation\",\n    \"short complexes\"\n]"}
{"type": "(α : Type u) → [inst : MetricSpace α] → [inst : TopologicalSpace.SeparableSpace α] → α → ↥(lp (fun i => ℝ) ⊤)", "name": "kuratowskiEmbedding", "isProp": false, "docString": "The Kuratowski embedding is an isometric embedding of a separable metric space in `ℓ^∞(ℕ, ℝ)`.\n", "terms": "[\n    \"Kuratowski embedding\",\n    \"isometric embedding\",\n    \"separable metric space\",\n    \"ℓ^∞(ℕ, ℝ)\"\n]"}
{"type": "(fun x x_1 => x < x_1) ≼i fun x x_1 => x < x_1", "name": "Ordinal.lift.initialSeg", "isProp": false, "docString": "Initial segment version of the lift operation on ordinals, embedding `ordinal.{u}` in\n`ordinal.{v}` as an initial segment when `u ≤ v`. ", "terms": "[\n    \"Initial segment\",\n    \"lift operation\",\n    \"ordinals\",\n    \"embedding\",\n    \"ordinal\",\n    \"initial segment\",\n    \"≤\"\n]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_5, u_1} C] →\n    {D : Type u_2} →\n      [inst_1 : CategoryTheory.Category.{u_6, u_2} D] →\n        {K : CategoryTheory.GrothendieckTopology D} →\n          {A : Type u_4} →\n            [inst_2 : CategoryTheory.Category.{u_7, u_4} A] →\n              {G : CategoryTheory.Functor C D} →\n                {ℱ : CategoryTheory.Functor Dᵒᵖ A} →\n                  {ℱ' : CategoryTheory.Sheaf K A} →\n                    (CategoryTheory.Functor.comp G.op ℱ ⟶ CategoryTheory.Functor.comp G.op ℱ'.val) →\n                      (X : A) →\n                        CategoryTheory.Functor.comp G.op\n                            (CategoryTheory.Functor.comp ℱ (CategoryTheory.coyoneda.obj (Opposite.op X))) ⟶\n                          CategoryTheory.Functor.comp G.op (CategoryTheory.sheafOver ℱ' X).val", "name": "CategoryTheory.Functor.IsCoverDense.homOver", "isProp": false, "docString": "(Implementation). Given a hom between the pullbacks of two sheaves, we can whisker it with\n`coyoneda` to obtain a hom between the pullbacks of the sheaves of maps from `X`.\n", "terms": "[\n    \"Implementation\",\n    \"hom\",\n    \"pullbacks\",\n    \"sheaves\",\n    \"whisker\",\n    \"coyoneda\",\n    \"sheaves of maps\",\n    \"X\"\n]"}
{"type": "∀ {E : Type u_4} {F : Type u_5} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℝ F] (f : SchwartzMap E F) (n : ℕ∞), ContDiff ℝ n ⇑f", "name": "SchwartzMap.smooth", "isProp": true, "docString": "Every Schwartz function is smooth. ", "terms": "[\"Schwartz function\", \"smooth\"]"}
{"type": "∀ {G : Type u_1} [inst : Group G] (K : Subgroup G), Subgroup.closure ↑K = K", "name": "Subgroup.closure_eq", "isProp": true, "docString": "Closure of a subgroup `K` equals `K`. ", "terms": "[\n    \"Closure\",\n    \"Subgroup\",\n    \"Equals\"\n]"}
{"type": "{𝕜 : Type u_1} →\n  {E : Type u_2} →\n    {F : Type u_3} →\n      [inst : IsROrC 𝕜] →\n        [inst_1 : NormedAddCommGroup E] →\n          [inst_2 : InnerProductSpace 𝕜 E] →\n            [inst_3 : NormedAddCommGroup F] →\n              [inst_4 : InnerProductSpace 𝕜 F] → (T : E →ₗ.[𝕜] F) → ↥(LinearPMap.adjointDomain T) → ↥T.domain →L[𝕜] 𝕜", "name": "LinearPMap.adjointDomainMkClm", "isProp": false, "docString": "The operator `λ x, ⟪y, T x⟫` considered as a continuous linear operator from `T.adjointDomain`\nto `𝕜`. ", "terms": "[\n  \"operator\",\n  \"continuous\",\n  \"linear operator\",\n  \"adjoint domain\"\n]"}
{"type": "∀ {α : Type u_1} [inst : Preorder α] {f : α → α} {x : α}, StrictMono f → f x < x → StrictAnti fun n => f^[n] x", "name": "StrictMono.strictAnti_iterate_of_map_lt", "isProp": true, "docString": "If `f` is a strictly antitone map and `f x < x` at some point `x`, then the iterates `f^[n] x`\nform a strictly antitone sequence. ", "terms": "[\n    \"strictly antitone map\",\n    \"point\",\n    \"iterates\",\n    \"strictly antitone sequence\"\n]"}
{"type": "{α : Type u_1} → [ord : Ord α] → [inst : Inhabited α] → (xs : Array α) → optParam ℕ 0 → optParam ℕ (Array.size xs) → α", "name": "Array.minI", "isProp": false, "docString": "Find the first minimal element of an array. If the array is empty, `default` is\nreturned. If `start` and `stop` are given, only the subarray `xs[start:stop]` is\nconsidered.\n", "terms": "[\"element\", \"array\", \"empty\", \"default\", \"start\", \"stop\", \"subarray\"]"}
{"type": "{X Y : AddGroupCat} → ↑X ≃+ ↑Y ≅ X ≅ Y", "name": "addEquivIsoAddGroupIso", "isProp": false, "docString": "\"additive equivalences between `add_group`s are the same\nas (isomorphic to) isomorphisms in `AddGroup` ", "terms": "[\n    \"additive equivalences\",\n    \"add_group\",\n    \"isomorphic\",\n    \"isomorphisms\",\n    \"AddGroup\"\n]"}
{"type": "∀ {α : Type u} [inst : StrictOrderedRing α] {a b : α}, b < 0 → a < 1 → b < a * b", "name": "lt_mul_of_lt_one_left", "isProp": true, "docString": "Variant of `mul_lt_of_lt_one_left` for `b` negative instead of positive. ", "terms": "[]\n"}
{"type": "{α : Type u} → [inst : Monoid α] → Invertible 1", "name": "invertibleOne", "isProp": false, "docString": "`1` is the inverse of itself ", "terms": "[\"1\", \"inverse\", \"itself\"]"}
{"type": "{V₁ : Type u_2} →\n  {V₂ : Type u_3} →\n    [inst : SeminormedAddCommGroup V₁] → [inst_1 : SeminormedAddCommGroup V₂] → NormedAddGroupHom V₁ V₂ → ℝ", "name": "NormedAddGroupHom.opNorm", "isProp": false, "docString": "The operator norm of a seminormed group homomorphism is the inf of all its bounds. ", "terms": "[\n  \"operator norm\",\n  \"seminormed group\",\n  \"homomorphism\",\n  \"inf\",\n  \"bounds\"\n]"}
{"type": "(R : Type u) → [inst : CommRing R] → CommRingCat", "name": "CommRingCat.of", "isProp": false, "docString": "Construct a bundled `CommRingCat` from the underlying type and typeclass. ", "terms": "[\n    \"Construct\",\n    \"bundled\",\n    \"CommRingCat\",\n    \"underlying type\",\n    \"typeclass\"\n]"}
{"type": "{L : FirstOrder.Language} →\n  {M : Type u_1} → [inst : FirstOrder.Language.Structure L M] → FirstOrder.Language.Substructure L M → Prop", "name": "FirstOrder.Language.Substructure.IsElementary", "isProp": false, "docString": "A substructure is elementary when every formula applied to a tuple in the subtructure\nagrees with its value in the overall structure. ", "terms": "[\n    \"Substructure\",\n    \"Elementary\",\n    \"Formula\",\n    \"Tuple\",\n    \"Value\",\n    \"Overall Structure\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      {X Y : C} →\n        (f : X ⟶ Y) →\n          [inst_2 : CategoryTheory.Limits.HasZeroObject C] →\n            [inst_3 : CategoryTheory.Epi f] →\n              CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.cokernel.zeroCokernelCofork f)", "name": "CategoryTheory.Limits.cokernel.isColimitCoconeZeroCocone", "isProp": false, "docString": "The morphism to the zero object is a cokernel of an epimorphism ", "terms": "[\n    \"morphism\",\n    \"zero object\",\n    \"cokernel\",\n    \"epimorphism\"\n]"}
{"type": "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {r : α → α → Prop} →\n      {s : β → β → Prop} →\n        {φ : Quot r → Quot s → Sort u_5} →\n          [h : ∀ (a : α) (b : β), Subsingleton (φ (Quot.mk r a) (Quot.mk s b))] →\n            (q₁ : Quot r) → (q₂ : Quot s) → ((a : α) → (b : β) → φ (Quot.mk r a) (Quot.mk s b)) → φ q₁ q₂", "name": "Quot.recOnSubsingleton₂", "isProp": false, "docString": "A binary version of `Quot.recOnSubsingleton`. ", "terms": "[\"binary\", \"Quot.recOnSubsingleton\"]"}
{"type": "Lean.Expr → Option (Lean.Name × Lean.Expr)", "name": "Linarith.getContrLemma", "isProp": false, "docString": "If `e` is a comparison `a R b` or the negation of a comparison `¬ a R b`, found in the target,\n`getContrLemma e` returns the name of a lemma that will change the goal to an\nimplication, along with the type of `a` and `b`.\n\nFor example, if `e` is `(a : ℕ) < b`, returns ``(`lt_of_not_ge, ℕ)``.\n", "terms": "[\"comparison\", \"negation\", \"target\", \"lemma\", \"goal\", \"implication\", \"type\", \"ℕ\", \"<\", \"lt_of_not_ge\"]"}
{"type": "∀ {p j : ℕ} [hp : Fact (Nat.Prime p)] {F : ℕ → ℚ} {S : Finset ℕ},\n  Finset.Nonempty S →\n    (∀ i ∈ S, padicValRat p (F j) < padicValRat p (F i)) →\n      (∀ (i : ℕ), 0 < F i) → padicValRat p (F j) < padicValRat p (Finset.sum S fun i => F i)", "name": "padicValRat.lt_sum_of_lt", "isProp": true, "docString": "If the p-adic valuation of a finite set of positive rationals is greater than a given rational\nnumber, then the p-adic valuation of their sum is also greater than the same rational number. ", "terms": "[\n  \"p-adic valuation\",\n  \"finite set\",\n  \"positive rationals\",\n  \"greater than\",\n  \"given rational number\",\n  \"sum\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} [inst : CompleteLinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  [inst_3 : CompleteLinearOrder β] [inst_4 : TopologicalSpace β] [inst_5 : OrderClosedTopology β] {f : α → β}\n  {s : Set α}, ContinuousAt f (sSup s) → Antitone f → f ⊥ = ⊤ → f (sSup s) = sInf (f '' s)", "name": "Antitone.map_sSup_of_continuousAt", "isProp": true, "docString": "An antitone function `f` sending `bot` to `top` and continuous at the supremum of a set sends\nthis supremum to the infimum of the image of this set. ", "terms": "[\n    \"antitone function\",\n    \"continuous\",\n    \"supremum\",\n    \"set\",\n    \"infimum\",\n    \"image\"\n]"}
{"type": "ℕ → ℕ → Bool", "name": "Nat.beq", "isProp": false, "docString": "(Boolean) equality of natural numbers.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n", "terms": "[\n    \"Boolean\",\n    \"equality\",\n    \"natural numbers\",\n    \"kernel\",\n    \"compiler\",\n    \"efficiently evaluate\",\n    \"bignum representation\",\n    \"Nat\",\n    \"logical model\",\n    \"soundness-critical\"\n]"}
{"type": "{R : Type uR} →\n  {ι : Type uι} →\n    {M₁ : ι → Type v₁} →\n      [inst : Semiring R] →\n        [inst_1 : (i : ι) → AddCommMonoid (M₁ i)] →\n          [inst_2 : (i : ι) → Module R (M₁ i)] →\n            {ι' : Type u_1} →\n              {M' : ι' → Type u_2} →\n                [inst_3 : (i : ι') → AddCommMonoid (M' i)] →\n                  [inst_4 : (i : ι') → Module R (M' i)] →\n                    ((i : ι') → MultilinearMap R M₁ (M' i)) → MultilinearMap R M₁ ((i : ι') → M' i)", "name": "MultilinearMap.pi", "isProp": false, "docString": "Combine a family of multilinear maps with the same domain and codomains `M' i` into a\nmultilinear map taking values in the space of functions `∀ i, M' i`. ", "terms": "[\n    \"family\",\n    \"multilinear maps\",\n    \"domain\",\n    \"codomains\",\n    \"multilinear map\",\n    \"values\",\n    \"space of functions\"\n]"}
{"type": "{ι : Type u_1} →\n  {V : Type u} →\n    [inst : CategoryTheory.Category.{v, u} V] →\n      [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] →\n        {c : ComplexShape ι} →\n          (C : HomologicalComplex V c) →\n            {i : ι} →\n              ¬ComplexShape.Rel c i (ComplexShape.next c i) → (HomologicalComplex.xNext C i ≅ HomologicalComplex.X C i)", "name": "HomologicalComplex.xNextIsoSelf", "isProp": false, "docString": "If there is no `j` so `c.Rel i j`, then `C.xNext i` is isomorphic to `C.X i`. ", "terms": "[\n    \"isomorphic\"\n]"}
{"type": "{α : Type u_1} →\n  [inst : AddCommMonoidWithOne α] →\n    [inst_1 : PartialOrder α] →\n      [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] →\n        [inst_3 : ZeroLEOneClass α] → [inst : CharZero α] → ℕ ↪o α", "name": "Nat.castOrderEmbedding", "isProp": false, "docString": "`Nat.cast : ℕ → α` as an `OrderEmbedding` ", "terms": "[\n  \"Nat.cast\",\n  \"ℕ\",\n  \"α\",\n  \"OrderEmbedding\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] →\n      (P : C) → [inst_2 : CategoryTheory.Limits.HasBinaryProduct (⊤_ C) P] → (⊤_ C) ⨯ P ≅ P", "name": "CategoryTheory.Limits.prod.leftUnitor", "isProp": false, "docString": "The left unitor isomorphism for binary products with the terminal object. ", "terms": "[\n    \"left unitor\",\n    \"isomorphism\",\n    \"binary products\",\n    \"terminal object\"\n]"}
{"type": "∀ {R : Type u} [inst : CommRing R] [inst_1 : Subsingleton R], IsEmpty (PrimeSpectrum R)", "name": "PrimeSpectrum.instIsEmptyPrimeSpectrum", "isProp": true, "docString": "The prime spectrum of the zero ring is empty. ", "terms": "[\n    \"prime spectrum\",\n    \"zero ring\",\n    \"empty\"\n]"}
{"type": "∀ {α : Type u_7} (self : MeasurableSpace α) (f : ℕ → Set α),\n  (∀ (i : ℕ), MeasurableSpace.MeasurableSet' self (f i)) → MeasurableSpace.MeasurableSet' self (⋃ i, f i)", "name": "MeasurableSpace.measurableSet_iUnion", "isProp": true, "docString": "The union of a sequence of measurable sets is a measurable set. Use a more general\n`MeasurableSet.iUnion` instead. ", "terms": "[\n  \"union\",\n  \"sequence\",\n  \"measurable sets\",\n  \"measurable set\",\n  \"MeasurableSet.iUnion\"\n]"}
{"type": "{M : Type u_3} → {N : Type u_4} → [inst : Add M] → [inst_1 : Add N] → AddHomClass (AddHom M N) M N", "name": "AddHom.addHomClass", "isProp": false, "docString": "`AddHom` is a type of addition-preserving homomorphisms", "terms": "[\n  \"AddHom\",\n  \"addition-preserving\",\n  \"homomorphisms\"\n]"}
{"type": "∀ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : CommRing S] (y : R) [inst_2 : Algebra R S]\n  [inst_3 : IsLocalization.Away y S] [H : Ideal.IsJacobson R], Ideal.IsJacobson S", "name": "Ideal.isJacobson_localization", "isProp": true, "docString": "If `S` is the localization of the Jacobson ring `R` at the submonoid generated by `y : R`, then\n`S` is Jacobson. ", "terms": "[\n    \"localization\",\n    \"Jacobson ring\",\n    \"submonoid\",\n    \"generated\",\n    \"Jacobson\"\n]"}
{"type": "{G : Type u_1} →\n  {S : Type u_2} → [inst : SubNegMonoid G] → [inst_1 : SetLike S G] → [inst : AddSubgroupClass S G] → {H : S} → Neg ↥H", "name": "AddSubgroupClass.neg", "isProp": false, "docString": "An additive subgroup of an `AddGroup` inherits an inverse.", "terms": "[\n    \"Additive subgroup\",\n    \"AddGroup\",\n    \"Inherits\",\n    \"Inverse\"\n]"}
{"type": "∀ {X : Type u_1} {ι : Type u_3} [inst : TopologicalSpace X] [inst_1 : Countable ι] (s : ι → Set X),\n  (∀ (i : ι), IsSigmaCompact (s i)) → IsSigmaCompact (⋃ i, s i)", "name": "isSigmaCompact_iUnion", "isProp": true, "docString": "Countable unions of σ-compact sets are σ-compact. ", "terms": "[\n  \"Countable\",\n  \"Unions\",\n  \"σ-Compact\",\n  \"Sets\"\n]"}
{"type": "∀ {R : Type u_1} {A : Type u_2} {S : Type u_4} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : CommRing S]\n  [inst_3 : Algebra R A] [inst_4 : Algebra R S] (f : A ≃ₐ[R] S),\n  Subalgebra.map (↑f) (integralClosure R A) = integralClosure R S", "name": "integralClosure_map_algEquiv", "isProp": true, "docString": "Mapping an integral closure along an `AlgEquiv` gives the integral closure. ", "terms": "[\n  \"Mapping\",\n  \"Integral Closure\",\n  \"AlgEquiv\"\n]"}
{"type": "{ι : Type u_1} →\n  {V : Type u} →\n    [inst : CategoryTheory.Category.{v, u} V] →\n      [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] →\n        {c : ComplexShape ι} →\n          {C₁ C₂ : HomologicalComplex V c} →\n            HomologicalComplex.Hom C₁ C₂ →\n              (i : ι) →\n                CategoryTheory.Arrow.mk (HomologicalComplex.dFrom C₁ i) ⟶\n                  CategoryTheory.Arrow.mk (HomologicalComplex.dFrom C₂ i)", "name": "HomologicalComplex.Hom.sqFrom", "isProp": false, "docString": "A morphism of chain complexes\ninduces a morphism of arrows of the differentials out of each object.\n", "terms": "[\n  \"morphism\",\n  \"chain complexes\",\n  \"induces\",\n  \"arrows\",\n  \"differentials\",\n  \"object\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    (I : C) →\n      (F : CategoryTheory.Functor Cᵒᵖ (Type (max u v))) →\n        CategoryTheory.Presieve.IsSheafFor F\n            (CategoryTheory.Presieve.ofArrows Empty.elim fun a => IsEmpty.elim instIsEmptyEmpty a) →\n          CategoryTheory.Limits.IsTerminal (F.obj (Opposite.op I))", "name": "CategoryTheory.Presieve.isTerminal_of_isSheafFor_empty_presieve", "isProp": false, "docString": "If `F` is a presheaf which satisfies the sheaf condition with respect to the empty presieve on any\nobject, then `F` takes that object to the terminal object.\n", "terms": "[\n    \"presheaf\",\n    \"sheaf condition\",\n    \"empty presieve\",\n    \"object\",\n    \"terminal object\"\n]"}
{"type": "∀ {β : Type u} {α : Type v} {s : Finset α} [inst : CommMonoid β] {f : α → Prop} [inst_1 : DecidablePred f],\n  Set.PairwiseDisjoint (↑s) f → ∀ (a : β), (Finset.prod s fun i => if f i then a else 1) = if ∃ i ∈ s, f i then a else 1", "name": "Finset.prod_ite_one", "isProp": true, "docString": "See also `Finset.prod_boole`. ", "terms": "[\"Finset.prod_boole\"]"}
{"type": "{R : Type u_1} →\n  {S : Type u_2} →\n    {M : Type u_3} →\n      [inst : CommRing R] →\n        [inst_1 : Field S] →\n          [inst_2 : AddCommGroup M] →\n            [inst_3 : Algebra R S] →\n              [inst_4 : Module R M] →\n                [inst_5 : Module S M] →\n                  [inst_6 : IsScalarTower R S M] →\n                    (B : BilinForm S M) → {N : Submodule R M} → ↥(BilinForm.dualSubmodule B N) → ↥N → R", "name": "BilinForm.dualSubmoduleParing", "isProp": false, "docString": "The natural paring of `B.dualSubmodule N` and `N`.\nThis is bundled as a bilinear map in `BilinForm.dualSubmoduleToDual`. ", "terms": "[\n    \"natural paring\",\n    \"dualSubmodule\",\n    \"bilinear map\",\n    \"dualSubmoduleToDual\"\n]"}
{"type": "{R : Type u1} →\n  [inst : CommRing R] →\n    {M : Type u2} →\n      [inst_1 : AddCommGroup M] →\n        [inst_2 : Module R M] →\n          {Q Q' : QuadraticForm R M} →\n            {B : BilinForm R M} → BilinForm.toQuadraticForm B = Q' - Q → CliffordAlgebra Q ≃ₗ[R] CliffordAlgebra Q'", "name": "CliffordAlgebra.changeFormEquiv", "isProp": false, "docString": "Any two algebras whose quadratic forms differ by a bilinear form are isomorphic as modules.\n\nThis is $\\bar \\lambda_B$ from [bourbaki2007][] $9 Proposition 3. ", "terms": "[\n    \"algebras\",\n    \"quadratic forms\",\n    \"differ\",\n    \"bilinear form\",\n    \"isomorphic\",\n    \"modules\",\n    \"Proposition\"\n]"}
{"type": "∀ {α : Type u_1} [inst : Setoid α] {r : α → α → Prop} {H : ∀ (a₁ b₁ a₂ b₂ : α), a₁ ≈ a₂ → b₁ ≈ b₂ → r a₁ b₁ = r a₂ b₂},\n  WellFounded r → WellFounded (Quotient.lift₂ r H)", "name": "WellFounded.quotient_lift₂", "isProp": true, "docString": "**Alias** of the reverse direction of `wellFounded_lift₂_iff`.\n\n---\n\nA relation is well founded iff its lift to a quotient is. ", "terms": "[\n    \"Alias\",\n    \"reverse direction\",\n    \"wellFounded_lift₂_iff\",\n    \"relation\",\n    \"well founded\",\n    \"lift\",\n    \"quotient\"\n]"}
{"type": "∀ {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n  [inst_2 : CompleteSpace E] {μ : MeasureTheory.Measure α} {s : Set E} {t : Set α} {f : α → E},\n  Convex ℝ s →\n    ↑↑μ t ≠ 0 →\n      ↑↑μ t ≠ ⊤ →\n        (∀ᵐ (x : α) ∂MeasureTheory.Measure.restrict μ t, f x ∈ s) →\n          MeasureTheory.IntegrableOn f t → ⨍ (x : α) in t, f x ∂μ ∈ closure s", "name": "Convex.set_average_mem_closure", "isProp": true, "docString": "If `μ` is a non-zero finite measure on `α`, `s` is a convex set in `E`, and `f` is an integrable\nfunction sending `μ`-a.e. points to `s`, then the average value of `f` belongs to `closure s`:\n`⨍ x, f x ∂μ ∈ s`. See also `Convex.centerMass_mem` for a finite sum version of this lemma. ", "terms": "[\n    \"non-zero\",\n    \"finite measure\",\n    \"convex set\",\n    \"integrable function\",\n    \"average value\",\n    \"closure\",\n    \"centerMass_mem\",\n    \"finite sum\",\n    \"lemma\"\n]"}
{"type": "{R : Type u} → [inst : CommRing R] → (W : WeierstrassCurve.Affine R) → R → Polynomial R → Ideal W.CoordinateRing", "name": "WeierstrassCurve.Affine.CoordinateRing.XYIdeal", "isProp": false, "docString": "The ideal $\\langle X - x, Y - y(X) \\rangle$ of $R[W]$ for some $x \\in R$ and $y(X) \\in R[X]$. ", "terms": "[\n    \"ideal\",\n    \"R\",\n    \"X\",\n    \"Y\",\n    \"W\",\n    \"y(X)\",\n    \"R[X]\",\n    \"R[W]\"\n]"}
{"type": "∀ {β : Type v} {γ : Type w} [inst : MetricSpace γ] [inst_1 : MetricSpace β] {f : γ → β},\n  UniformEmbedding f ↔\n    (∀ ε > 0, ∃ δ > 0, ∀ {a b : γ}, dist a b < δ → dist (f a) (f b) < ε) ∧\n      ∀ δ > 0, ∃ ε > 0, ∀ {a b : γ}, dist (f a) (f b) < ε → dist a b < δ", "name": "Metric.uniformEmbedding_iff'", "isProp": true, "docString": "A map between metric spaces is a uniform embedding if and only if the distance between `f x`\nand `f y` is controlled in terms of the distance between `x` and `y` and conversely. ", "terms": "[\n    \"map\",\n    \"metric spaces\",\n    \"uniform embedding\",\n    \"distance\"\n]"}
{"type": "{α : Type u_1} →\n  [inst : Lattice α] →\n    [inst_1 : OrderBot α] →\n      [inst_2 : DecidableEq α] →\n        {a : α} → (parts : Finset α) → Finset.SupIndep parts id → Finset.sup parts id = a → Finpartition a", "name": "Finpartition.ofErase", "isProp": false, "docString": "A `Finpartition` constructor which does not insist on `⊥` not being a part. ", "terms": "[\n    \"Finpartition\",\n    \"constructor\",\n    \"part\"\n]"}
{"type": "∀ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : NonUnitalNonAssocSemiring A] [inst_2 : Module R A]\n  [inst_3 : Star A] (self : NonUnitalStarSubalgebra R A) {a : A}, a ∈ self.carrier → star a ∈ self.carrier", "name": "NonUnitalStarSubalgebra.star_mem'", "isProp": true, "docString": "The `carrier` of a `NonUnitalStarSubalgebra` is closed under the `star` operation. ", "terms": "[\n    \"carrier\",\n    \"NonUnitalStarSubalgebra\",\n    \"closed\",\n    \"star operation\"\n]"}
{"type": "{J : Type v} →\n  [inst : CategoryTheory.SmallCategory J] → (F : CategoryTheory.Functor J MonCat) → CategoryTheory.Limits.Cocone F", "name": "MonCat.Colimits.colimitCocone", "isProp": false, "docString": "The cocone over the proposed colimit monoid. ", "terms": "[\"cocone\", \"colimit\", \"monoid\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {J : Type w} →\n      [inst_1 : CategoryTheory.SmallCategory J] →\n        {D : Type u₂} →\n          [inst_2 : CategoryTheory.Category.{v₂, u₂} D] →\n            [inst_3 : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete J) C] →\n              [inst_4 :\n                  CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete ((p : J × J) × (p.1 ⟶ p.2))) C] →\n                [inst_5 : CategoryTheory.Limits.HasEqualizers C] →\n                  (G : CategoryTheory.Functor C D) →\n                    [inst_6 :\n                        CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair G] →\n                      [inst_7 : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete J) G] →\n                        [inst_8 :\n                            CategoryTheory.Limits.PreservesLimitsOfShape\n                              (CategoryTheory.Discrete ((p : J × J) × (p.1 ⟶ p.2))) G] →\n                          CategoryTheory.Limits.PreservesLimitsOfShape J G", "name": "CategoryTheory.Limits.preservesLimitOfPreservesEqualizersAndProduct", "isProp": false, "docString": "If a functor preserves equalizers and the appropriate products, it preserves limits. ", "terms": "[\n    \"functor\",\n    \"preserves\",\n    \"equalizers\",\n    \"appropriate products\",\n    \"limits\"\n]"}
{"type": "{Ω : Type u_1} → {m : MeasurableSpace Ω} → (Ω → ℝ) → ℕ → MeasureTheory.Measure Ω → ℝ", "name": "ProbabilityTheory.moment", "isProp": false, "docString": "Moment of a real random variable, `μ[X ^ p]`. ", "terms": "[\n    \"Moment\",\n    \"Real\",\n    \"Random Variable\"\n]"}
{"type": "∀ {ι : Type u_1} {E : Type u_3} [inst : SeminormedAddCommGroup E] {f : ι → E},\n  (Summable fun i => ‖f i‖₊) → ‖∑' (i : ι), f i‖₊ ≤ ∑' (i : ι), ‖f i‖₊", "name": "nnnorm_tsum_le", "isProp": true, "docString": "If `∑' i, ‖f i‖₊` is summable, then `‖∑' i, f i‖₊ ≤ ∑' i, ‖f i‖₊`. Note that\nwe do not assume that `∑' i, f i` is summable, and it might not be the case if `α` is not a complete\nspace. ", "terms": "[\n    \"summable\",\n    \"norm\",\n    \"sum\",\n    \"complete space\"\n]"}
{"type": "∀ {a b : ℝ} (m n : ℕ),\n  ∫ (x : ℝ) in a..b, Real.sin x ^ m * Real.cos x ^ (2 * n + 1) =\n    ∫ (u : ℝ) in Real.sin a..Real.sin b, u ^ m * (1 - u ^ 2) ^ n", "name": "integral_sin_pow_mul_cos_pow_odd", "isProp": true, "docString": "Simplification of the integral of `sin x ^ m * cos x ^ n`, case `n` is odd. ", "terms": "[\n  \"Simplification\",\n  \"Integral\",\n  \"sin\",\n  \"cos\",\n  \"^ (exponentiation)\",\n  \"odd\"\n]"}
{"type": "∀ {M : Type u_2} {α : Type u_3} [inst : MeasurableSpace M] [inst_1 : MeasurableSpace α] [inst_2 : SMul M α]\n  [inst_3 : SMul Mᵐᵒᵖ α] [inst_4 : IsCentralScalar M α] [inst_5 : MeasurableSMul M α], MeasurableSMul Mᵐᵒᵖ α", "name": "MeasurableSMul.op", "isProp": true, "docString": "If a scalar is central, then its right action is measurable when its left action is. ", "terms": "[\"scalar\", \"central\", \"right action\", \"measurable\", \"left action\"]"}
{"type": "∀ {α : Type u_1} [inst : CommGroup α] [inst_1 : DecidableEq α] (A B C : Finset α),\n  Finset.card (A / C) * Finset.card B ≤ Finset.card (A * B) * Finset.card (B / C)", "name": "Finset.card_div_mul_le_card_mul_mul_card_div", "isProp": true, "docString": "**Ruzsa's triangle inequality**. Sub-add-sub version. ", "terms": "[\n  \"Ruzsa's triangle inequality\",\n  \"Sub-add-sub version\"\n]"}
{"type": "∀ {X : Type u} [inst : TopologicalSpace X] {s : Set X},\n  (∀ {ι : Type u} (U : ι → Set X), (∀ (i : ι), IsOpen (U i)) → s ⊆ ⋃ i, U i → ∃ t, s ⊆ ⋃ i ∈ t, U i) → IsCompact s", "name": "isCompact_of_finite_subcover", "isProp": true, "docString": "A set `s` is compact if for every open cover of `s`, there exists a finite subcover. ", "terms": "[\n    \"set\",\n    \"compact\",\n    \"open cover\",\n    \"exists\",\n    \"finite\",\n    \"subcover\"\n]"}
{"type": "∀ {ι : Type u_1} {l : Filter ι} {E : Type u_2} [inst : NormedAddCommGroup E] {𝕜 : Type u_3} [inst_1 : IsROrC 𝕜]\n  [inst_2 : NormedSpace 𝕜 E] {G : Type u_4} [inst_3 : NormedAddCommGroup G] [inst_4 : NormedSpace 𝕜 G] {f : ι → E → G}\n  {g : E → G} {g' : E → E →L[𝕜] G} {x : E} [inst_5 : Filter.NeBot l] {s : Set E},\n  IsOpen s →\n    TendstoLocallyUniformlyOn (fderiv 𝕜 ∘ f) g' l s →\n      (∀ (n : ι), DifferentiableOn 𝕜 (f n) s) →\n        (∀ x ∈ s, Filter.Tendsto (fun n => f n x) l (nhds (g x))) → x ∈ s → HasFDerivAt g (g' x) x", "name": "hasFDerivAt_of_tendsto_locally_uniformly_on'", "isProp": true, "docString": "A slight variant of `hasFDerivAt_of_tendstoLocallyUniformlyOn` with the assumption stated\nin terms of `DifferentiableOn` rather than `HasFDerivAt`. This makes a few proofs nicer in\ncomplex analysis where holomorphicity is assumed but the derivative is not known a priori. ", "terms": "[\n    \"hasFDerivAt_of_tendstoLocallyUniformlyOn\",\n    \"DifferentiableOn\",\n    \"complex analysis\",\n    \"holomorphicity\",\n    \"derivative\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α) [inst : NormedAddCommGroup β]\n  {f : α → β},\n  MeasureTheory.Memℒp f 1 →\n    MeasureTheory.StronglyMeasurable f →\n      ∀ {ε : ℝ}, 0 < ε → ∃ M, ∫⁻ (x : α), ↑‖Set.indicator {x | M ≤ ↑‖f x‖₊} f x‖₊ ∂μ ≤ ENNReal.ofReal ε", "name": "MeasureTheory.Memℒp.integral_indicator_norm_ge_le", "isProp": true, "docString": "This lemma is weaker than `MeasureTheory.Memℒp.integral_indicator_norm_ge_nonneg_le`\nas the latter provides `0 ≤ M` and does not require the measurability of `f`. ", "terms": "[\n\"lemma\",\n\"MeasureTheory.Memℒp.integral_indicator_norm_ge_nonneg_le\",\n\"0 ≤ M\",\n\"measurability\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.NonPreadditiveAbelian C] →\n      (A : C) → A ⟶ CategoryTheory.Limits.cokernel (CategoryTheory.Limits.diag A)", "name": "CategoryTheory.NonPreadditiveAbelian.r", "isProp": false, "docString": "The composite `A ⟶ A ⨯ A ⟶ cokernel (Δ A)`, where the first map is `(𝟙 A, 0)` and the second map\nis the canonical projection into the cokernel. ", "terms": "[\n  \"composite\",\n  \"map\",\n  \"cokernel\",\n  \"canonical projection\"\n]"}
{"type": "∀ {R : Type u_1} [inst : LinearOrderedCommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {ι : Type u_3} [inst_3 : Fintype ι] [inst_4 : DecidableEq ι] [inst_5 : Nonempty ι] (e : Basis ι R M)\n  (x : Orientation R M ι), Basis.orientation (Basis.adjustToOrientation e x) = x", "name": "Basis.orientation_adjustToOrientation", "isProp": true, "docString": "`adjust_to_orientation` gives a basis with the required orientation. ", "terms": "[\"adjust_to_orientation\", \"basis\", \"orientation\"]"}
{"type": "∀ {a : ENNReal}, a ≠ ⊤ → AddLECancellable a", "name": "ENNReal.cancel_of_ne", "isProp": true, "docString": "This lemma has an abbreviated name because it is used frequently. ", "terms": "[]"}
{"type": "∀ (k : Type u_1) (V : Type u_2) (P : Type u_3) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {s : Set P}, affineSpan k s = ⊤ → vectorSpan k s = ⊤", "name": "AffineSubspace.vectorSpan_eq_top_of_affineSpan_eq_top", "isProp": true, "docString": "If the affine span of a set is `⊤`, then the vector span of the same set is the `⊤`. ", "terms": "[\n    \"affine span\", \n    \"set\", \n    \"vector span\"\n]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X Y : C} (f : X ⟶ Y) [inst_1 : CategoryTheory.IsIso f],\n  CategoryTheory.IsSplitEpi f", "name": "CategoryTheory.IsSplitEpi.of_iso", "isProp": true, "docString": "Every iso is a split epi. ", "terms": "[\"iso\", \"split epi\"]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {F G : CategoryTheory.Functor C Dᵒᵖ} → (F.leftOp ⟶ G.leftOp) → (G ⟶ F)", "name": "CategoryTheory.NatTrans.removeLeftOp", "isProp": false, "docString": "Given a natural transformation `α : F.leftOp ⟶ G.leftOp`, for `F G : C ⥤ Dᵒᵖ`,\ntaking `op` of each component gives a natural transformation `G ⟶ F`.\n", "terms": "[\n    \"natural transformation\",\n    \"leftOp\",\n    \"component\",\n    \"C\",\n    \"Dᵒᵖ\",\n    \"op\"\n]"}
{"type": "ℕ → ℕ → Prop", "name": "Nat.Coprime", "isProp": false, "docString": "`m` and `n` are coprime, or relatively prime, if their `gcd` is 1. ", "terms": "[\n    \"coprime\", \n    \"relatively prime\", \n    \"gcd\"\n]"}
{"type": "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α},\n  0 < a → 0 < b → 0 < a + b", "name": "Right.add_pos'", "isProp": true, "docString": "Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_pos'`.", "terms": "[\n    \"right covariance\",\n    \"lemma\",\n    \"left covariance\",\n    \"add_pos\"\n]"}
{"type": "∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] [inst_1 : CompleteSpace 𝕜] {EM : Type u_1}\n  [inst_2 : NormedAddCommGroup EM] [inst_3 : NormedSpace 𝕜 EM] {HM : Type u_2} [inst_4 : TopologicalSpace HM]\n  (IM : ModelWithCorners 𝕜 EM HM) {M : Type u} [inst_5 : TopologicalSpace M] [inst_6 : ChartedSpace HM M] {x : M}\n  (f : ↑(TopCat.Presheaf.stalk (TopCat.Sheaf.presheaf (smoothSheafCommRing IM (modelWithCornersSelf 𝕜 𝕜) M 𝕜)) x)),\n  IsUnit f ↔ f ∉ RingHom.ker (smoothSheafCommRing.eval IM (modelWithCornersSelf 𝕜 𝕜) M 𝕜 x)", "name": "smoothSheafCommRing.isUnit_stalk_iff", "isProp": true, "docString": "The units of the stalk at `x` of the sheaf of smooth functions from `M` to `𝕜`, considered as a\nsheaf of commutative rings, are the functions whose values at `x` are nonzero. ", "terms": "[\n  \"units\",\n  \"stalk\",\n  \"sheaf\",\n  \"smooth functions\",\n  \"commutative rings\",\n  \"functions\",\n  \"values\",\n  \"nonzero\"\n]"}
{"type": "{T : ℝ} → [hT : Fact (0 < T)] → MeasureTheory.Measure (AddCircle T)", "name": "AddCircle.haarAddCircle", "isProp": false, "docString": "Haar measure on the additive circle, normalised to have total measure 1. ", "terms": "[\n    \"Haar measure\",\n    \"additive circle\",\n    \"normalised\",\n    \"total measure\"\n]"}
{"type": "{X Y Z : AlgebraicGeometry.Scheme} →\n  (𝒰 : AlgebraicGeometry.Scheme.OpenCover X) →\n    (f : X ⟶ Z) →\n      (g : Y ⟶ Z) →\n        [inst :\n            ∀ (i : 𝒰.J),\n              CategoryTheory.Limits.HasPullback\n                (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.OpenCover.map 𝒰 i) f) g] →\n          (i j : 𝒰.J) → AlgebraicGeometry.Scheme.Pullback.v 𝒰 f g i j ⟶ AlgebraicGeometry.Scheme.Pullback.v 𝒰 f g j i", "name": "AlgebraicGeometry.Scheme.Pullback.t", "isProp": false, "docString": "The canonical transition map `(Uᵢ ×[Z] Y) ×[X] Uⱼ ⟶ (Uⱼ ×[Z] Y) ×[X] Uᵢ` given by the fact\nthat pullbacks are associative and symmetric. ", "terms": "[\n    \"canonical\",\n    \"transition map\",\n    \"pullbacks\",\n    \"associative\",\n    \"symmetric\"\n]"}
{"type": "{R : Type u} →\n  {L₁ : Type v} →\n    {L₂ : Type w} →\n      [inst : CommRing R] →\n        [inst_1 : LieRing L₁] →\n          [inst_2 : LieRing L₂] → [inst_3 : LieAlgebra R L₁] → [inst_4 : LieAlgebra R L₂] → (L₁ ≃ₗ⁅R⁆ L₂) → L₂ ≃ₗ⁅R⁆ L₁", "name": "LieEquiv.symm", "isProp": false, "docString": "Lie algebra equivalences are symmetric. ", "terms": "[\n    \"Lie algebra\",\n    \"equivalences\",\n    \"symmetric\"\n]"}
{"type": "∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {I : Ideal R}\n  {N N' : Submodule R M}, Submodule.FG N' → I ≤ Ideal.jacobson ⊥ → N ⊔ N' ≤ N ⊔ I • N' → I • N' ≤ N", "name": "Submodule.smul_le_of_le_smul_of_le_jacobson_bot", "isProp": true, "docString": "**Nakayama's Lemma** - Statement (4) in\n[Stacks 00DV](https://stacks.math.columbia.edu/tag/00DV).\nSee also `sup_smul_eq_sup_smul_of_le_smul_of_le_jacobson` for a generalisation\nto the `jacobson` of any ideal ", "terms": "[\n  \"Nakayama's Lemma\",\n  \"Statement\",\n  \"Stacks\",\n  \"sup_smul_eq_sup_smul_of_le_smul_of_le_jacobson\",\n  \"generalisation\",\n  \"jacobson\",\n  \"ideal\"\n]"}
{"type": "∀ {R : Type u_1} [inst : Semiring R] {C : Type u_2} {D : Type u_3} [inst_1 : CategoryTheory.Category.{u_4, u_2} C]\n  [inst_2 : CategoryTheory.Category.{u_5, u_3} D] [inst_3 : CategoryTheory.Preadditive C]\n  [inst_4 : CategoryTheory.Preadditive D] [inst_5 : CategoryTheory.Linear R C] [inst_6 : CategoryTheory.Linear R D]\n  {F : CategoryTheory.Functor C D} [inst_7 : CategoryTheory.Functor.Additive F]\n  [self : CategoryTheory.Functor.Linear R F] {X Y : C} (f : X ⟶ Y) (r : R), F.map (r • f) = r • F.map f", "name": "CategoryTheory.Functor.Linear.map_smul", "isProp": true, "docString": "the functor induces a linear map on morphisms ", "terms": "[\n  \"functor\",\n  \"induces\",\n  \"linear map\",\n  \"on\",\n  \"morphisms\"\n]"}
{"type": "{ι : Type u_1} → {α : ι → Type u_2} → ((i : ι) → Filter (α i)) → Filter ((i : ι) → α i)", "name": "Filter.pi", "isProp": false, "docString": "The product of an indexed family of filters. ", "terms": "[\"product\", \"indexed family\", \"filters\"]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {F F' : CategoryTheory.Functor C D} → {G : CategoryTheory.Functor D C} → (F ⊣ G) → (F' ⊣ G) → (F ≅ F')", "name": "CategoryTheory.Adjunction.leftAdjointUniq", "isProp": false, "docString": "If `F` and `F'` are both left adjoint to `G`, then they are naturally isomorphic. ", "terms": "[\n    \"left adjoint\",\n    \"naturally isomorphic\"\n]"}
{"type": "{σ : Type u_1} → (σ → Option σ) → σ → Part σ", "name": "Turing.eval", "isProp": false, "docString": "Run a state transition function `σ → Option σ` \"to completion\". The return value is the last\nstate returned before a `none` result. If the state transition function always returns `some`,\nthen the computation diverges, returning `Part.none`. ", "terms": "[\n    \"state transition function\",\n    \"Option\",\n    \"completion\",\n    \"return value\",\n    \"last state\",\n    \"none\",\n    \"result\",\n    \"computation\",\n    \"diverges\",\n    \"Part.none\"\n]"}
{"type": "∀ {R : Type u_1} [inst : Mul R] [inst_1 : Star R] {x : R} [self : IsStarNormal x], Commute (star x) x", "name": "IsStarNormal.star_comm_self", "isProp": true, "docString": "A normal element of a star monoid commutes with its adjoint. ", "terms": "[\n    \"Normal Element\",\n    \"Star Monoid\",\n    \"Commutes\",\n    \"Adjoint\"\n]"}
{"type": "{G : Type u_1} → [inst : AddGroup G] → (H : AddSubgroup G) → Zero ↥H", "name": "AddSubgroup.zero", "isProp": false, "docString": "An `AddSubgroup` of an `AddGroup` inherits a zero.", "terms": "[\n    \"AddSubgroup\",\n    \"AddGroup\",\n    \"inherits\",\n    \"zero\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {X Y : C} →\n          {f : X ⟶ Y} →\n            CategoryTheory.SplitMono f → (F : CategoryTheory.Functor C D) → CategoryTheory.SplitMono (F.map f)", "name": "CategoryTheory.SplitMono.map", "isProp": false, "docString": "Split monomorphisms are also absolute monomorphisms. ", "terms": "[\"Split monomorphisms\", \"absolute monomorphisms\"]"}
{"type": "{α : Type u_2} →\n  {β : Type u_3} →\n    [inst : Sup α] →\n      [inst_1 : Inf α] →\n        [inst_2 : Top α] →\n          [inst_3 : HImp α] →\n            [inst_4 : GeneralizedHeytingAlgebra β] →\n              (f : α → β) →\n                Function.Injective f →\n                  (∀ (a b : α), f (a ⊔ b) = f a ⊔ f b) →\n                    (∀ (a b : α), f (a ⊓ b) = f a ⊓ f b) →\n                      f ⊤ = ⊤ → (∀ (a b : α), f (a ⇨ b) = f a ⇨ f b) → GeneralizedHeytingAlgebra α", "name": "Function.Injective.generalizedHeytingAlgebra", "isProp": false, "docString": "Pullback a `GeneralizedHeytingAlgebra` along an injection. ", "terms": "[\n  \"Pullback\", \n  \"GeneralizedHeytingAlgebra\", \n  \"Injection\"\n]"}
{"type": "{D : Type u_1} →\n  {C : Type u_2} →\n    [inst : OrderedAddCommMonoid C] →\n      {Γ : ValuedCsp D C} → {ι : Type u_3} → (self : ValuedCsp.Term Γ ι) → (Fin self.n → D) → C", "name": "ValuedCsp.Term.f", "isProp": false, "docString": "Which cost function is instantiated ", "terms": "[\"cost function\", \"instantiated\"]"}
{"type": "∀ {X : Type u_3} {E : Type u_1} {A : Type u_2} [inst : TopologicalSpace E] [inst_1 : TopologicalSpace A] {p : E → X},\n  IsSeparatedMap p →\n    IsLocallyInjective p →\n      ∀ {g₁ g₂ : A → E} [inst_2 : PreconnectedSpace A],\n        Continuous g₁ → Continuous g₂ → p ∘ g₁ = p ∘ g₂ → ∀ (a : A), g₁ a = g₂ a → g₁ = g₂", "name": "IsSeparatedMap.eq_of_comp_eq", "isProp": true, "docString": "If `p` is a locally injective separated map, and `A` is a connected space,\nthen two lifts `g₁, g₂ : A → E` of a map `f : A → X` are equal if they agree at one point. ", "terms": "[\n    \"locally injective\",\n    \"separated map\",\n    \"connected space\",\n    \"lifts\",\n    \"map\",\n    \"equal\",\n    \"agree at one point\"\n]"}
{"type": "{k G : Type u} →\n  [inst : CommRing k] →\n    [inst_1 : Monoid G] → {V : Type u} → [inst_2 : AddCommGroup V] → [inst_3 : Module k V] → (G →* V →ₗ[k] V) → Rep k G", "name": "Rep.of", "isProp": false, "docString": "Lift an unbundled representation to `Rep`. ", "terms": "[\"Lift\", \"unbundled representation\", \"Rep\"]"}
{"type": "{α : Type u_2} → [inst : MulOneClass α] → MulOneClass (Filter α)", "name": "Filter.mulOneClass", "isProp": false, "docString": "`Filter α` is a `MulOneClass` under pointwise operations if `α` is. ", "terms": "[\n    \"Filter\",\n    \"MulOneClass\",\n    \"pointwise operations\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  DenseRange f → Continuous f → ∀ {s : Set α}, Dense s → ∀ {t : Set β}, Set.MapsTo f s t → Dense t", "name": "DenseRange.dense_of_mapsTo", "isProp": true, "docString": "If a continuous map with dense range maps a dense set to a subset of `t`, then `t` is a dense\nset. ", "terms": "[\n  \"Continuous map\",\n  \"Dense range\",\n  \"Dense set\",\n  \"Subset\"\n]"}
{"type": "∀ (n : ℕ), ZMod.χ₄ ↑n = ZMod.χ₄ ↑(n % 4)", "name": "ZMod.χ₄_nat_mod_four", "isProp": true, "docString": "The value of `χ₄ n`, for `n : ℕ`, depends only on `n % 4`. ", "terms": "[\n    \"value\",\n    \"ℕ\",\n    \"depends\",\n    \"%\",\n    \"4\"\n]"}
{"type": "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b : α},\n  a ≤ 1 → b < 1 → a * b < 1", "name": "Right.mul_lt_one_of_le_of_lt", "isProp": true, "docString": "Assumes right covariance.\nThe lemma assuming left covariance is `Left.mul_lt_one_of_le_of_lt`. ", "terms": "[\n\"right covariance\",\n\"lemma\",\n\"left covariance\",\n\"mul\",\n\"lt\",\n\"one\",\n\"le\"\n]"}
{"type": "Monad Set", "name": "Set.monad", "isProp": false, "docString": "The `Set` functor is a monad.\n\nThis is not a global instance because it does not have computational content,\nso it does not make much sense using `do` notation in general.\nPlus, this would cause monad-related coercions and monad lifting logic to become activated.\nEither use `attribute [local instance] Set.monad` to make it be a local instance\nor use `SetM.run do ...` when `do` notation is wanted. ", "terms": "[\n    \"Set\",\n    \"functor\",\n    \"monad\",\n    \"global instance\",\n    \"computational content\",\n    \"do notation\",\n    \"monad-related coercions\",\n    \"monad lifting logic\",\n    \"local instance\",\n    \"SetM.run\"\n]"}
{"type": "UInt64 → UInt64", "name": "hash64", "isProp": false, "docString": "An opaque (low-level) hash operation used to implement hashing for pointers. ", "terms": "[]"}
{"type": "{α : Type u_1} → (n : ℕ) → List α → List (Sym α n)", "name": "List.sym", "isProp": false, "docString": "`xs.sym n` is all unordered `n`-tuples from the list `xs` in some order. ", "terms": "[\"unordered\", \"n-tuples\", \"list\", \"order\"]"}
{"type": "(K : Type u_2) →\n  [inst : FirstOrder.Language.Structure FirstOrder.Language.ring K] →\n    [inst : K ⊨ FirstOrder.Language.Theory.field] → Field K", "name": "FirstOrder.Field.fieldOfModelField", "isProp": false, "docString": "A model for the theory of fields is a field. To introduced locally on Types that don't\nalready have instances for ring operations.\n\nWhen this is used, it is almost always useful to also add locally the instance\n`compatibleFieldOfModelField` afterwards. ", "terms": "[\n  \"model\",\n  \"theory\",\n  \"fields\",\n  \"field\",\n  \"locally\",\n  \"Types\",\n  \"instances\",\n  \"ring operations\",\n  \"compatibleFieldOfModelField\"\n]"}
{"type": "{X Y B : Profinite} → (f : X ⟶ B) → (g : Y ⟶ B) → Profinite.pullback f g ⟶ X", "name": "Profinite.pullback.fst", "isProp": false, "docString": "The projection from the pullback to the first component. ", "terms": "[\"projection\", \"pullback\", \"first component\"]"}
{"type": "{R : Type u_1} → [inst : Semiring R] → ℕ → Polynomial R →ₗ[R] Polynomial R", "name": "Polynomial.hasseDeriv", "isProp": false, "docString": "The `k`th Hasse derivative of a polynomial `∑ a_i X^i` is `∑ (i.choose k) a_i X^(i-k)`.\nIt satisfies `k! * (hasse_deriv k f) = derivative^[k] f`. ", "terms": "[\n  \"Hasse derivative\",\n  \"polynomial\",\n  \"choose\",\n  \"derivative\",\n  \"factorial\"\n]"}
{"type": "{α : Type u_2} →\n  {β : Type u_3} → [inst : Bot α] → [inst_1 : Bot β] → (f : BotHom α β) → (f' : α → β) → f' = ⇑f → BotHom α β", "name": "BotHom.copy", "isProp": false, "docString": "Copy of a `BotHom` with a new `toFun` equal to the old one. Useful to fix definitional\nequalities. ", "terms": "[\"Copy\", \"BotHom\", \"new\", \"toFun\", \"old\", \"Useful\", \"fix\", \"definitional equalities\"]"}
{"type": "(R : Type u) →\n  (M : Type v) →\n    (M₂ : Type w) →\n      [inst : Semiring R] →\n        [inst_1 : AddCommMonoid M] →\n          [inst_2 : AddCommMonoid M₂] → [inst_3 : Module R M] → [inst_4 : Module R M₂] → M →ₗ[R] M × M₂", "name": "LinearMap.inl", "isProp": false, "docString": "The left injection into a product is a linear map. ", "terms": "[\n    \"left injection\",\n    \"product\",\n    \"linear map\"\n]"}
{"type": "Lean.TrailingParserDescr", "name": "AlgebraicGeometry.«term_|__»", "isProp": false, "docString": "restriction of a section to open subset ", "terms": "[\"restriction\", \"section\", \"open subset\"]"}
{"type": "{n : ℕ} → (Fin n → ℂ) → (Fin n → ℝ) → (Fin n → ℝ) → Fin n → ℂ", "name": "torusMap", "isProp": false, "docString": "The n dimensional exponential map $θ_i ↦ c + R e^{θ_i*I}, θ ∈ ℝⁿ$ representing\na torus in `ℂⁿ` with center `c ∈ ℂⁿ` and generalized radius `R ∈ ℝⁿ`, so we can adjust\nit to every n axis. ", "terms": "[\n    \"n dimensional\",\n    \"exponential map\",\n    \"torus\",\n    \"ℂⁿ\",\n    \"center\",\n    \"generalized radius\",\n    \"ℝⁿ\",\n    \"axis\"\n]"}
{"type": "∀ (α : Type u_1) [inst : Zero α] [inst_1 : One α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1], 0 < 1", "name": "zero_lt_one'", "isProp": true, "docString": "See `zero_lt_one` for a version with the type implicit. ", "terms": "[]"}
{"type": "∀ (X : AlgebraicGeometry.RingedSpace) (U : TopologicalSpace.Opens ↑↑X.toPresheafedSpace)\n  (f : ↑(X.presheaf.obj (Opposite.op U))), (∀ (x : ↥U), IsUnit ((TopCat.Presheaf.germ X.presheaf x) f)) → IsUnit f", "name": "AlgebraicGeometry.RingedSpace.isUnit_of_isUnit_germ", "isProp": true, "docString": "If a section `f` is a unit in each stalk, `f` must be a unit. ", "terms": "[\"section\", \"unit\", \"stalk\"]"}
{"type": "∀ {α : Type} {n : ℕ} {β : Type} {xs : Vector α n} {ys : Vector β n} {σ γ : Type} {f : α → β → σ → σ × γ} {s₀ : σ}\n  (S : Set σ),\n  s₀ ∈ S →\n    (∀ (a : α) (b : β), ∀ s ∈ S, (f a b s).1 ∈ S) →\n      (∀ (a : α) (b : β) (s s' : σ), s ∈ S → s' ∈ S → (f a b s).2 = (f a b s').2) →\n        (Vector.mapAccumr₂ f xs ys s₀).2 = Vector.map₂ (fun x x_1 => (f x x_1 s₀).2) xs ys", "name": "Vector.mapAccumr₂_eq_map₂", "isProp": true, "docString": "If there is a set of states that is closed under `f`, and such that `f` produces that same output\nfor all states in this set, then the state is not actually needed.\nHence, then we can rewrite `mapAccumr₂` into just `map₂`\n", "terms": "[\n  \"set\",\n  \"states\",\n  \"closed\",\n  \"produces\",\n  \"output\",\n  \"state\",\n  \"needed\",\n  \"rewrite\",\n  \"mapAccumr₂\",\n  \"map₂\"\n]"}
{"type": "{α : Type u_1} → Set (Set α) → FilterBasis α", "name": "Filter.FilterBasis.ofSets", "isProp": false, "docString": "The smallest filter basis containing a given collection of sets. ", "terms": "[\n    \"smallest\",\n    \"filter basis\",\n    \"containing\",\n    \"given\",\n    \"collection\",\n    \"sets\"\n]"}
{"type": "Lean.Elab.Command.CommandElab", "name": "Mathlib.Prelude.Rename.elabAlign", "isProp": false, "docString": "Elaborate an `#align` command. ", "terms": "[]"}
{"type": "{ι : Type u_1} → {G : Type u_3} → [inst : Group G] → FunLike (FreeGroupBasis ι G) ι fun x => G", "name": "FreeGroupBasis.funLike", "isProp": false, "docString": "A free group basis for `G` over `ι` is associated to a map `ι → G` recording the images of\nthe generators. ", "terms": "[\n    \"free group\",\n    \"basis\",\n    \"associated\",\n    \"map\",\n    \"images\",\n    \"generators\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.Abelian C] →\n      {X Y Z : C} →\n        (f : X ⟶ Y) →\n          (g : Y ⟶ Z) →\n            (h : CategoryTheory.Exact f g) →\n              CategoryTheory.Limits.IsLimit\n                (CategoryTheory.Limits.KernelFork.ofι (CategoryTheory.Abelian.image.ι f)\n                  (_ : CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.image.ι f) g = 0))", "name": "CategoryTheory.Abelian.isLimitImage", "isProp": false, "docString": "If `(f, g)` is exact, then `Abelian.image.ι f` is a kernel of `g`. ", "terms": "[\n    \"exact\",\n    \"Abelian\",\n    \"image\",\n    \"ι\",\n    \"kernel\"\n]"}
{"type": "(α : Type u_3) → (β : Type u_4) → [inst : MulOneClass β] → β →* α → β", "name": "Pi.constMonoidHom", "isProp": false, "docString": "`Function.const` as a `MonoidHom`. ", "terms": "[\n  \"Function.const\",\n  \"MonoidHom\"\n]"}
{"type": "(K : Type u_1) →\n  {V : Type u_2} →\n    [inst : DivisionRing K] → [inst_1 : AddCommGroup V] → [inst_2 : Module K V] → (v : V) → v ≠ 0 → Projectivization K V", "name": "Projectivization.mk", "isProp": false, "docString": "Construct an element of the projectivization from a nonzero vector. ", "terms": "[\n    \"Construct\",\n    \"element\",\n    \"projectivization\",\n    \"nonzero\",\n    \"vector\"\n]"}
{"type": "{α : Type u_1} → Set α → PartialEquiv α α", "name": "PartialEquiv.ofSet", "isProp": false, "docString": "The identity partial equivalence on a set `s` ", "terms": "[\n\"identity\",\n\"partial equivalence\",\n\"set\"\n]"}
{"type": "∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type v) [inst_2 : Field K] [inst_3 : Algebra R K]\n  [inst_4 : IsFractionRing R K],\n  ⨅ v,\n      Localization.subalgebra.ofField K (Ideal.primeCompl v.asIdeal)\n        (_ : Ideal.primeCompl v.asIdeal ≤ nonZeroDivisors R) =\n    ⊥", "name": "PrimeSpectrum.iInf_localization_eq_bot", "isProp": true, "docString": "An integral domain is equal to the intersection of its localizations at all its prime ideals\nviewed as subalgebras of its field of fractions. ", "terms": "[\n  \"integral domain\",\n  \"intersection\",\n  \"localizations\",\n  \"prime ideals\",\n  \"subalgebras\",\n  \"field of fractions\"\n]"}
{"type": "(R : Type u_1) →\n  (L : Type u_3) → [inst : CommRing R] → [inst_1 : LieRing L] → [inst_2 : LieAlgebra R L] → L →ₗ[R] L →ₗ[R] R", "name": "killingForm", "isProp": false, "docString": "A finite, free (as an `R`-module) Lie algebra `L` carries a bilinear form on `L`.\n\nThis is a specialisation of `LieModule.traceForm` to the adjoint representation of `L`. ", "terms": "[\n    \"finite\", \n    \"free\", \n    \"`R`-module\", \n    \"Lie algebra\", \n    \"`L`\", \n    \"bilinear form\", \n    \"specialisation\", \n    \"`LieModule.traceForm`\", \n    \"adjoint representation\", \n    \"`L`\"\n]"}
{"type": "{C : Type u_1} →\n  {D : Type u_2} →\n    [inst : CategoryTheory.Category.{u_3, u_1} C] →\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] →\n        [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] →\n          [inst_3 : CategoryTheory.Limits.HasZeroMorphisms D] →\n            {S : CategoryTheory.ShortComplex C} →\n              {h : CategoryTheory.ShortComplex.LeftHomologyData S} →\n                {F : CategoryTheory.Functor C D} →\n                  [inst_4 : CategoryTheory.Functor.PreservesZeroMorphisms F] →\n                    [self : CategoryTheory.ShortComplex.LeftHomologyData.IsPreservedBy h F] →\n                      CategoryTheory.Limits.PreservesColimit\n                        (CategoryTheory.Limits.parallelPair (CategoryTheory.ShortComplex.LeftHomologyData.f' h) 0) F", "name": "CategoryTheory.ShortComplex.LeftHomologyData.IsPreservedBy.f'", "isProp": false, "docString": "the functor preserves the cokernel of `h.f' : S.X₁ ⟶ h.K`. ", "terms": "[\n\"functor\",\n\"preserves\",\n\"cokernel\"\n]"}
{"type": "∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SeparableSpace α], ∃ s, Set.Countable s ∧ Dense s", "name": "TopologicalSpace.SeparableSpace.exists_countable_dense", "isProp": true, "docString": "There exists a countable dense set. ", "terms": "[\n    \"exists\",\n    \"countable\",\n    \"dense set\"\n]"}
{"type": "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y z : V},\n  x ≠ y → x ≠ z → ‖x‖ = ‖y‖ → ‖x‖ = ‖z‖ → Orientation.oangle o y z = 2 • Orientation.oangle o (y - x) (z - x)", "name": "Orientation.oangle_eq_two_zsmul_oangle_sub_of_norm_eq", "isProp": true, "docString": "Angle at center of a circle equals twice angle at circumference, oriented vector angle\nform. ", "terms": "[\n  \"Angle\",\n  \"Center\",\n  \"Circle\",\n  \"Twice\",\n  \"Circumference\",\n  \"Oriented Vector\",\n  \"Form\"\n]"}
{"type": "∀ {R : Type u} [inst : Semiring R] {P : Polynomial R → Prop} (p : Polynomial R),\n  0 < Polynomial.degree p →\n    (∀ {a : R}, a ≠ 0 → P (Polynomial.C a * Polynomial.X)) →\n      (∀ {p : Polynomial R}, 0 < Polynomial.degree p → P p → P (p * Polynomial.X)) →\n        (∀ {p : Polynomial R} {a : R}, 0 < Polynomial.degree p → P p → P (p + Polynomial.C a)) → P p", "name": "Polynomial.degree_pos_induction_on", "isProp": true, "docString": "A property holds for all polynomials of positive `degree` with coefficients in a semiring `R`\nif it holds for\n* `a * X`, with `a ∈ R`,\n* `p * X`, with `p ∈ R[X]`,\n* `p + a`, with `a ∈ R`, `p ∈ R[X]`,\nwith appropriate restrictions on each term.\n\nSee `natDegree_ne_zero_induction_on` for a similar statement involving no explicit multiplication.\n ", "terms": "[\n    \"property\",\n    \"polynomials\",\n    \"positive degree\",\n    \"coefficients\",\n    \"semiring\",\n    \"holds\",\n    \"multiplication\",\n    \"addition\",\n    \"restrictions\",\n    \"natDegree_ne_zero_induction_on\"\n]"}
{"type": "∀ {G : Type u_2} [inst : Group G] (H N : Subgroup G) [hN : Subgroup.Normal N], ↑(H ⊔ N) = ↑H * ↑N", "name": "Subgroup.mul_normal", "isProp": true, "docString": "The carrier of `H ⊔ N` is just `↑H * ↑N` (pointwise set product) when `N` is normal. ", "terms": "[\n    \"carrier\",\n    \"⊔\",\n    \"pointwise set product\",\n    \"normal\"\n]"}
{"type": "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {s : Set E}\n  {t : Set F}, UniqueDiffOn 𝕜 s → UniqueDiffOn 𝕜 t → UniqueDiffOn 𝕜 (s ×ˢ t)", "name": "UniqueDiffOn.prod", "isProp": true, "docString": "The product of two sets of unique differentiability is a set of unique differentiability. ", "terms": "[\"product\", \"sets\", \"unique differentiability\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      {F G K : CochainComplex C ℤ} →\n        {n₁ n₂ n₁₂ : ℤ} →\n          CochainComplex.HomComplex.Cochain F G n₁ →\n            CochainComplex.HomComplex.Cochain G K n₂ → n₁ + n₂ = n₁₂ → CochainComplex.HomComplex.Cochain F K n₁₂", "name": "CochainComplex.HomComplex.Cochain.comp", "isProp": false, "docString": "The composition of cochains. ", "terms": "[\n  \"composition\",\n  \"cochains\"\n]"}
{"type": "∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {p : Fin 3 → P} {i₁ i₂ i₃ : Fin 3},\n  i₁ ≠ i₂ → i₁ ≠ i₃ → i₂ ≠ i₃ → (Collinear k {p i₁, p i₂, p i₃} ↔ ¬AffineIndependent k p)", "name": "collinear_iff_not_affineIndependent_of_ne", "isProp": true, "docString": "Three points are collinear if and only if they are not affinely independent. ", "terms": "[\"Three points\", \"collinear\", \"if and only if\", \"not\", \"affinely independent\"]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (X : CategoryTheory.CosimplicialObject C) {n : ℕ}\n  {i : Fin (n + 2)} {j : Fin (n + 1)},\n  Fin.castSucc j < i →\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.CosimplicialObject.δ X (Fin.succ i))\n        (CategoryTheory.CosimplicialObject.σ X (Fin.castSucc j)) =\n      CategoryTheory.CategoryStruct.comp (CategoryTheory.CosimplicialObject.σ X j)\n        (CategoryTheory.CosimplicialObject.δ X i)", "name": "CategoryTheory.CosimplicialObject.δ_comp_σ_of_gt", "isProp": true, "docString": "The fourth cosimplicial identity ", "terms": "[\"fourth\", \"cosimplicial\", \"identity\"]"}
{"type": "∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\n  (∀ (x y : α), f (x * y) = f x * f y) → IsGroupHom f", "name": "IsGroupHom.mk'", "isProp": true, "docString": "Construct `IsGroupHom` from its only hypothesis. ", "terms": "[\"Construct\", \"IsGroupHom\", \"hypothesis\"]"}
{"type": "∀ {𝕜 : Type u_3} {E : Type u_7} [inst : NormedField 𝕜] [inst_1 : SeminormedAddCommGroup E] [inst_2 : NormedSpace 𝕜 E]\n  {r : ℝ}, 0 < r → Absorbent 𝕜 (Metric.ball 0 r)", "name": "absorbent_ball_zero", "isProp": true, "docString": "Balls at the origin are absorbent. ", "terms": "[\"balls\", \"origin\", \"absorbent\"]"}
{"type": "{R : Type u} → [inst : CommRing R] → WeierstrassCurve.Affine R → R → R → Prop", "name": "WeierstrassCurve.Affine.nonsingular", "isProp": false, "docString": "The proposition that an affine point $(x, y)$ in `W` is nonsingular.\nIn other words, either $W_X(x, y) \\ne 0$ or $W_Y(x, y) \\ne 0$. ", "terms": "[\n    \"proposition\",\n    \"affine point\",\n    \"nonsingular\"\n]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X Y : C} {f : X ⟶ Y} (hf : CategoryTheory.SplitMono f)\n  [inst_1 : CategoryTheory.Mono hf.retraction], CategoryTheory.IsIso f", "name": "CategoryTheory.IsIso.of_mono_retraction'", "isProp": true, "docString": "Every split mono whose retraction is mono is an iso. ", "terms": "[\n    \"split mono\",\n    \"retraction\",\n    \"mono\",\n    \"iso\"\n]"}
{"type": "∀ {R : Type u_1} [inst : Semiring R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] {r r' : R} (s s' : ↥S)\n  (rb : R) (sb : ↥S), ↑s * ↑sb = ↑s' * rb → r /ₒ s + r' /ₒ s' = (r * ↑sb + r' * rb) /ₒ (s * sb)", "name": "OreLocalization.oreDiv_add_char", "isProp": true, "docString": "A characterization of the addition on the Ore localizaion, allowing for arbitrary Ore\nnumerator and Ore denominator. ", "terms": "[\n    \"characterization\",\n    \"addition\",\n    \"Ore localization\",\n    \"arbitrary\",\n    \"Ore numerator\",\n    \"Ore denominator\"\n]"}
{"type": "∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {N : Set α} {f : α → ENNReal}\n  [inst : MeasureTheory.IsProbabilityMeasure μ], ∫⁻ (a : α), f a ∂μ ≠ ⊤ → ↑↑μ N = 0 → ∃ x ∉ N, ∫⁻ (a : α), f a ∂μ ≤ f x", "name": "MeasureTheory.exists_not_mem_null_lintegral_le", "isProp": true, "docString": "**First moment method**. The maximum of a measurable function is greater than its integral,\nwhile avoiding a null set. ", "terms": "[\n    \"First moment method\",\n    \"maximum\",\n    \"measurable function\",\n    \"greater than\",\n    \"integral\",\n    \"null set\"\n]"}
{"type": "{𝕜 : Type u_1} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type u_2} →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : NormedSpace 𝕜 E] →\n          {F : Type u_3} →\n            [inst_3 : NormedAddCommGroup F] →\n              [inst_4 : NormedSpace 𝕜 F] → {f : E → F} → IsBoundedLinearMap 𝕜 f → E →L[𝕜] F", "name": "IsBoundedLinearMap.toContinuousLinearMap", "isProp": false, "docString": "Construct a continuous linear map from `IsBoundedLinearMap`. ", "terms": "[\n    \"Construct\",\n    \"Continuous\",\n    \"Linear Map\",\n    \"IsBoundedLinearMap\"\n]"}
{"type": "{S : Type u_2} →\n  [inst : Ring S] → {A : Type u_4} → [inst_1 : CommRing A] → [inst_2 : Algebra A S] → PowerBasis A S → Polynomial A", "name": "PowerBasis.minpolyGen", "isProp": false, "docString": "`pb.minpolyGen` is the minimal polynomial for `pb.gen`. ", "terms": "[\"minimal polynomial\"]"}
{"type": "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R),\n  ∃ π, IsDedekindDomain.HeightOneSpectrum.intValuationDef v π = ↑(Multiplicative.ofAdd (-1))", "name": "IsDedekindDomain.HeightOneSpectrum.int_valuation_exists_uniformizer", "isProp": true, "docString": "There exists `π ∈ R` with `v`-adic valuation `Multiplicative.ofAdd (-1)`. ", "terms": "[\n    \"exists\",\n    \"π\",\n    \"∈\",\n    \"R\",\n    \"v-adic valuation\",\n    \"Multiplicative.ofAdd\",\n    \"(-1)\"\n]"}
{"type": "∀ (C : Type u) [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C], CategoryTheory.Limits.HasBinaryBiproducts C", "name": "CategoryTheory.Limits.hasBinaryBiproducts_of_finite_biproducts", "isProp": true, "docString": "A category with finite biproducts has binary biproducts.\n\nThis is not an instance as typically in concrete categories there will be\nan alternative construction with nicer definitional properties.\n", "terms": "[\n    \"category\",\n    \"finite biproducts\",\n    \"binary biproducts\",\n    \"concrete categories\",\n    \"alternative construction\",\n    \"definitional properties\"\n]"}
{"type": "∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\n  a ≠ 0 → (quadraticChar F) a = 1 ∨ (quadraticChar F) a = -1", "name": "quadraticChar_dichotomy", "isProp": true, "docString": "The quadratic character is `1` or `-1` on nonzero arguments. ", "terms": "[\"quadratic character\", \"nonzero arguments\"]"}
{"type": "∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddGroup β] {f : α → β},\n  IsAddGroupHom f → ∀ {γ : Type u_1} [inst_2 : AddGroup γ] {g : β → γ}, IsAddGroupHom g → IsAddGroupHom (g ∘ f)", "name": "IsAddGroupHom.comp", "isProp": true, "docString": "The composition of two additive group homomorphisms is an additive\ngroup homomorphism.", "terms": "[\n    \"composition\", \n    \"additive group\", \n    \"homomorphisms\"\n]"}
{"type": "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} → [inst : UniformSpace β] → [inst_1 : UniformSpace γ] → γ ≃ᵤ β → UniformFun α γ ≃ᵤ UniformFun α β", "name": "UniformFun.congrRight", "isProp": false, "docString": "Turn a uniform isomorphism `γ ≃ᵤ β` into a uniform isomorphism `(α →ᵤ γ) ≃ᵤ (α →ᵤ β)` by\npost-composing. ", "terms": "[\"uniform isomorphism\", \"post-composing\"]"}
{"type": "∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\n  inner (x + y) (x - y) = 0 ↔ ‖x‖ = ‖y‖", "name": "real_inner_add_sub_eq_zero_iff", "isProp": true, "docString": "The sum and difference of two vectors are orthogonal if and only\nif they have the same norm. ", "terms": "[\n    \"sum\",\n    \"difference\",\n    \"vectors\",\n    \"orthogonal\",\n    \"if and only if\",\n    \"norm\"\n]"}
{"type": "{R : Type u_1} → {m : Type u_2} → {n₁ : Type u_6} → {n₂ : Type u_7} → Matrix m (n₁ ⊕ n₂) R → Matrix m n₁ R", "name": "Matrix.toColumns₁", "isProp": false, "docString": "Given a column partitioned matrix extract the first column ", "terms": "[\n  \"Given\",\n  \"column\",\n  \"partitioned matrix\",\n  \"extract\",\n  \"the first column\"\n]"}
{"type": "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V},\n  Orientation.oangle o x y = ↑Real.pi ↔ x ≠ 0 ∧ y ≠ 0 ∧ SameRay ℝ x (-y)", "name": "Orientation.oangle_eq_pi_iff_sameRay_neg", "isProp": true, "docString": "The oriented angle between two vectors is `π` if and only they are nonzero and the first is\non the same ray as the negation of the second. ", "terms": "[\n    \"oriented angle\",\n    \"vectors\",\n    \"π\",\n    \"nonzero\",\n    \"ray\",\n    \"negation\"\n]"}
{"type": "∀ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst : ContinuousSMul ℝ E], PathConnectedSpace E", "name": "TopologicalAddGroup.pathConnectedSpace", "isProp": true, "docString": "Every topological vector space over ℝ is path connected.\n\nNot an instance, because it creates enormous TC subproblems (turn on `pp.all`).\n", "terms": "[\n    \"Topological vector space\",\n    \"ℝ\",\n    \"Path connected\"\n]"}
{"type": "{ι : Type u_1} →\n  [inst : LinearOrder ι] →\n    [inst_1 : SuccOrder ι] →\n      [inst_2 : PredOrder ι] → [inst_3 : IsSuccArchimedean ι] → [inst_4 : NoMaxOrder ι] → [inst_5 : OrderBot ι] → ι ≃o ℕ", "name": "orderIsoNatOfLinearSuccPredArch", "isProp": false, "docString": "If the order has a bot but no top, `toZ` defines an `OrderIso` between `ι` and `ℕ`. ", "terms": "[\n    \"order\",\n    \"bot\",\n    \"top\",\n    \"defines\",\n    \"OrderIso\",\n    \"between\",\n    \"ℕ\"\n]"}
{"type": "{ι : Type u_1} → {α : Type u_2} → {s : ι → Set α} → (hs : IndexedPartition s) → α → IndexedPartition.Quotient hs", "name": "IndexedPartition.proj", "isProp": false, "docString": "The projection onto the quotient associated to an indexed partition. ", "terms": "[\n    \"Projection\",\n    \"Quotient\",\n    \"Associated\",\n    \"Indexed\",\n    \"Partition\"\n]"}
{"type": "{L : FirstOrder.Language} →\n  {α : Type u'} → FirstOrder.Language.Functions L 1 → FirstOrder.Language.Term L α → FirstOrder.Language.Term L α", "name": "FirstOrder.Language.Functions.apply₁", "isProp": false, "docString": "Applies a unary function to a term. ", "terms": "[\"unary function\", \"term\"]"}
{"type": "(α : Type u_2) → [inst : Preorder α] → PseudoEpimorphism α α", "name": "PseudoEpimorphism.id", "isProp": false, "docString": "`id` as a `PseudoEpimorphism`. ", "terms": "[\"id\", \"PseudoEpimorphism\"]"}
{"type": "Real.sin (Real.pi / 3) = Real.sqrt 3 / 2", "name": "Real.sin_pi_div_three", "isProp": true, "docString": "The sine of `π / 3` is `√3 / 2`. ", "terms": "[\"sine\", \"π\", \"√3\", \"/\", \"2\"]"}
{"type": "Lean.TrailingParserDescr", "name": "«term_⤳_»", "isProp": false, "docString": "`x` specializes to `y` (notation: `x ⤳ y`) if either of the following equivalent properties\nhold:\n\n* `𝓝 x ≤ 𝓝 y`; this property is used as the definition;\n* `pure x ≤ 𝓝 y`; in other words, any neighbourhood of `y` contains `x`;\n* `y ∈ closure {x}`;\n* `closure {y} ⊆ closure {x}`;\n* for any closed set `s` we have `x ∈ s → y ∈ s`;\n* for any open set `s` we have `y ∈ s → x ∈ s`;\n* `y` is a cluster point of the filter `pure x = 𝓟 {x}`.\n\nThis relation defines a `Preorder` on `X`. If `X` is a T₀ space, then this preorder is a partial\norder. If `X` is a T₁ space, then this partial order is trivial : `x ⤳ y ↔ x = y`. ", "terms": "[\n  \"specializes\",\n  \"notation\",\n  \"equivalent properties\",\n  \"𝓝\",\n  \"property\",\n  \"definition\",\n  \"pure\",\n  \"neighbourhood\",\n  \"closure\",\n  \"closed set\",\n  \"open set\",\n  \"cluster point\",\n  \"filter\",\n  \"relation\",\n  \"Preorder\",\n  \"T₀ space\",\n  \"partial order\",\n  \"T₁ space\",\n  \"trivial\"\n]"}
{"type": "{A : Type u_2} →\n  {B : Type u_3} →\n    {E : Type u_6} →\n      [inst : Monoid A] →\n        [inst_1 : Monoid B] →\n          [inst_2 : CommGroup E] →\n            [inst_3 : TopologicalSpace A] →\n              [inst_4 : TopologicalSpace B] →\n                [inst_5 : TopologicalSpace E] →\n                  [inst_6 : TopologicalGroup E] →\n                    ContinuousMonoidHom A E → ContinuousMonoidHom B E → ContinuousMonoidHom (A × B) E", "name": "ContinuousMonoidHom.coprod", "isProp": false, "docString": "Coproduct of two continuous homomorphisms to the same space. ", "terms": "[\n  \"Coproduct\",\n  \"Continuous\",\n  \"Homomorphisms\",\n  \"Space\"\n]"}
{"type": "{M : Type u_10} →\n  {N : Type u_11} →\n    [inst : AddMonoid M] →\n      [inst_1 : AddZeroClass N] → [inst_2 : AddAction M N] → [inst_3 : VAddAssocClass M N N] → M →+ N", "name": "AddMonoidHom.vaddZeroHom", "isProp": false, "docString": "If the additive action of `M` on `N` is compatible with addition on `N`, then\n`fun x => x +ᵥ 0` is an additive monoid homomorphism from `M` to `N`.", "terms": "[\n  \"additive action\",\n  \"compatible\",\n  \"addition\",\n  \"additive monoid homomorphism\"\n]"}
{"type": "∀ {H : Type u} {M : Type u_2} [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M],\n  HasGroupoid M (continuousGroupoid H)", "name": "hasGroupoid_continuousGroupoid", "isProp": true, "docString": "Any charted space structure is compatible with the groupoid of all local homeomorphisms. ", "terms": "[\n  \"charted space structure\",\n  \"compatible\",\n  \"groupoid\",\n  \"local homeomorphisms\"\n]"}
{"type": "(K : Type u_1) →\n  {V : Type u_2} →\n    [inst : DivisionRing K] → [inst_1 : AddCommGroup V] → [inst_2 : Module K V] → { v // v ≠ 0 } → Projectivization K V", "name": "Projectivization.mk'", "isProp": false, "docString": "A variant of `Projectivization.mk` in terms of a subtype. `mk` is preferred. ", "terms": "[\n  \"variant\",\n  \"Projectivization.mk\",\n  \"terms\",\n  \"subtype\",\n  \"preferred\"\n]"}
{"type": "{α : Type u_1} → (Set α → Prop) → Prop", "name": "Matroid.ExchangeProperty", "isProp": false, "docString": "A predicate `P` on sets satisfies the exchange property if, for all `X` and `Y` satisfying `P`\nand all `a ∈ X \\ Y`, there exists `b ∈ Y \\ X` so that swapping `a` for `b` in `X` maintains `P`.", "terms": "[\n    \"predicate\",\n    \"sets\",\n    \"exchange property\",\n    \"satisfying\",\n    \"exists\",\n    \"swapping\",\n    \"maintains\"\n]"}
{"type": "∀ (x y z : SetTheory.PGame), x * (y + z) ≈ x * y + x * z", "name": "SetTheory.PGame.left_distrib_equiv", "isProp": true, "docString": "`x * (y + z)` is equivalent to `x * y + x * z.`", "terms": "[\"equivalent\", \"multiplication\", \"addition\"]"}
{"type": "{α : Type u} → {β : Type v} → (α → β) → List α → List β", "name": "List.mapTR", "isProp": false, "docString": "Tail-recursive version of `List.map`. ", "terms": "[\"Tail-recursive\", \"List.map\"]"}
{"type": "{α : Type u_1} → [inst : LE α] → [inst : DecidableRel fun x x_1 => x ≤ x_1] → α → Ordnode α → α → α", "name": "Ordnode.findGtAux", "isProp": false, "docString": "Auxiliary definition for `findGt`. ", "terms": "[]"}
{"type": "{R : Type u_3} →\n  {S : Type u_5} → [inst : NonUnitalCommRing R] → [inst : NonUnitalCommRing S] → NonUnitalCommRing (R × S)", "name": "Prod.instNonUnitalCommRing", "isProp": false, "docString": "Product of two `NonUnitalCommRing`s is a `NonUnitalCommRing`. ", "terms": "[\n  \"Product\",\n  \"NonUnitalCommRing\"\n]"}
{"type": "∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {F : ℕ → α → ENNReal} {f : α → ENNReal}\n  (bound : α → ENNReal),\n  (∀ (n : ℕ), Measurable (F n)) →\n    (∀ (n : ℕ), F n ≤ᶠ[MeasureTheory.Measure.ae μ] bound) →\n      ∫⁻ (a : α), bound a ∂μ ≠ ⊤ →\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => F n a) Filter.atTop (nhds (f a))) →\n          Filter.Tendsto (fun n => ∫⁻ (a : α), F n a ∂μ) Filter.atTop (nhds (∫⁻ (a : α), f a ∂μ))", "name": "MeasureTheory.tendsto_lintegral_of_dominated_convergence", "isProp": true, "docString": "Dominated convergence theorem for nonnegative functions ", "terms": "[\n\"Dominated convergence theorem\",\n\"nonnegative functions\"\n]"}
{"type": "(M : Type u_1) →\n  (N : Type u_2) → [inst : MulOneClass M] → [inst_1 : MulOneClass N] → Monoid.Coprod M N →* Monoid.Coprod N M", "name": "Monoid.Coprod.swap", "isProp": false, "docString": "Map `M ∗ N` to `N ∗ M` by applying `Sum.swap` to each element of the underlying list.\n\nSee also `MulEquiv.coprodComm` for a `MulEquiv` version. ", "terms": "[\n    \"Map\",\n    \"Sum.swap\",\n    \"Element\",\n    \"Underlying list\",\n    \"MulEquiv.coprodComm\",\n    \"MulEquiv\"\n]"}
{"type": "{G : Type u_1} →\n  [inst : MeasurableSpace G] → [inst_1 : Group G] → [inst_2 : MeasurableMul G] → [inst_3 : MeasurableInv G] → G → G ≃ᵐ G", "name": "MeasurableEquiv.divLeft", "isProp": false, "docString": "`equiv.divLeft` as a `MeasurableEquiv` ", "terms": "[\n    \"equiv\",\n    \"divLeft\",\n    \"MeasurableEquiv\"\n]"}
{"type": "Lean.ParserDescr", "name": "Int.«term⌈_⌉»", "isProp": false, "docString": "`Int.ceil a` is the smallest integer `z` such that `a ≤ z`. It is denoted with `⌈a⌉`. ", "terms": "[\"Int.ceil\", \"integer\", \"smallest\", \"such that\", \"≤\", \"denoted\", \"⌈a⌉\"]"}
{"type": "{α : Type u_4} → {β : Type u_5} → {δ : Type u_6} → Levenshtein.Cost α β δ → β → δ", "name": "Levenshtein.Cost.insert", "isProp": false, "docString": "Cost in insert an element into a list. ", "terms": "[\"Cost\", \"insert\", \"element\", \"list\"]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X : C} {S : CategoryTheory.Sieve X}\n  {P : CategoryTheory.Functor Cᵒᵖ (Type v₁)} (x : CategoryTheory.Sieve.functor S ⟶ P)\n  (g : CategoryTheory.yoneda.obj X ⟶ P),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.Sieve.functorInclusion S) g = x ↔\n    CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation (↑(CategoryTheory.Presieve.natTransEquivCompatibleFamily x))\n      (CategoryTheory.yonedaEquiv g)", "name": "CategoryTheory.Presieve.extension_iff_amalgamation", "isProp": true, "docString": "(Implementation). A lemma useful to prove `isSheafFor_iff_yonedaSheafCondition`. ", "terms": "[]\n"}
{"type": "(𝕜 : Type u_1) →\n  {E : Type u_2} →\n    [inst : OrderedSemiring 𝕜] → [inst_1 : AddCommMonoid E] → [inst : Module 𝕜 E] → ClosureOperator (Set E)", "name": "convexHull", "isProp": false, "docString": "The convex hull of a set `s` is the minimal convex set that includes `s`. ", "terms": "[\n    \"convex hull\",\n    \"set\",\n    \"minimal\",\n    \"convex set\",\n    \"includes\"\n]"}
{"type": "{α : Type u_2} →\n  {β : Type u_3} → [inst : Preorder α] → [inst_1 : Preorder β] → (f : α →o β) → (f' : α → β) → f' = ⇑f → α →o β", "name": "OrderHom.copy", "isProp": false, "docString": "Copy of an `OrderHom` with a new `toFun` equal to the old one. Useful to fix definitional\nequalities. ", "terms": "[\n    \"OrderHom\",\n    \"toFun\",\n    \"definitional equalities\"\n]"}
{"type": "(K : Type u_1) →\n  [inst : Field K] → [nf : NumberField K] → Basis (Module.Free.ChooseBasisIndex ℤ ↥(NumberField.ringOfIntegers K)) ℚ K", "name": "NumberField.integralBasis", "isProp": false, "docString": "A basis of `K` over `ℚ` that is also a basis of `𝓞 K` over `ℤ`. ", "terms": "[\n  \"basis\",\n  \"over\",\n  \"ℚ\",\n  \"ℤ\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.Limits.HasPullbacks C] →\n      {A : C} →\n        CategoryTheory.Functor (CategoryTheory.MonoOver A)\n          (CategoryTheory.Functor (CategoryTheory.MonoOver A) (CategoryTheory.MonoOver A))", "name": "CategoryTheory.MonoOver.inf", "isProp": false, "docString": "When `[HasPullbacks C]`, `MonoOver A` has \"intersections\", functorial in both arguments.\n\nAs `MonoOver A` is only a preorder, this doesn't satisfy the axioms of `SemilatticeInf`,\nbut we reuse all the names from `SemilatticeInf` because they will be used to construct\n`SemilatticeInf (subobject A)` shortly.\n", "terms": "[\n  \"HasPullbacks\",\n  \"C\",\n  \"MonoOver\",\n  \"A\",\n  \"intersections\",\n  \"functorial\",\n  \"arguments\",\n  \"preorder\",\n  \"satisfy\",\n  \"axioms\",\n  \"SemilatticeInf\",\n  \"names\",\n  \"construct\",\n  \"subobject\"\n]"}
{"type": "∀ {x : ℝ} (n : ℕ) (m : ℤ), x ^ n = ↑m → (¬∃ y, x = ↑y) → 0 < n → Irrational x", "name": "irrational_nrt_of_notint_nrt", "isProp": true, "docString": "If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\n`x` is irrational. ", "terms": "[\"integer\", \"n-th power\", \"irrational\"]"}
{"type": "{R : Type u_1} →\n  {A : Type u_2} →\n    [inst : CommRing R] →\n      [inst_1 : Ring A] →\n        [inst_2 : Algebra R A] → {c₁ c₂ : R} → QuaternionAlgebra.Basis A c₁ c₂ ≃ (QuaternionAlgebra R c₁ c₂ →ₐ[R] A)", "name": "QuaternionAlgebra.lift", "isProp": false, "docString": "A quaternionic basis on `A` is equivalent to a map from the quaternion algebra to `A`. ", "terms": "[\n    \"quaternionic basis\",\n    \"equivalent\",\n    \"map\",\n    \"quaternion algebra\"\n]"}
{"type": "{ι : Type v} →\n  {β : ι → Type w} → [inst : (i : ι) → AddCommMonoid (β i)] → [inst_1 : IsEmpty ι] → Unique (DirectSum ι fun i => β i)", "name": "DirectSum.uniqueOfIsEmpty", "isProp": false, "docString": "A direct sum over an empty type is trivial. ", "terms": "[\"direct sum\", \"empty type\", \"trivial\"]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.Limits.HasInitial C],\n  (∀ (X : C), CategoryTheory.Mono (CategoryTheory.Limits.initial.to X)) → CategoryTheory.Limits.InitialMonoClass C", "name": "CategoryTheory.Limits.InitialMonoClass.of_initial", "isProp": true, "docString": "To show a category is an `InitialMonoClass` it suffices to show every morphism out of the\ninitial object is a monomorphism. ", "terms": "[\n  \"category\",\n  \"InitialMonoClass\",\n  \"morphism\",\n  \"initial object\",\n  \"monomorphism\"\n]"}
{"type": "∀ {R : Type uR} {ι : Type uι} {M₁ : ι → Type v₁} {M₂ : Type v₂} [inst : Semiring R]\n  [inst_1 : (i : ι) → AddCommMonoid (M₁ i)] [inst_2 : AddCommMonoid M₂] [inst_3 : (i : ι) → Module R (M₁ i)]\n  [inst_4 : Module R M₂] (f : MultilinearMap R M₁ M₂) [inst_5 : DecidableEq ι] (m m' : (i : ι) → M₁ i) (t : Finset ι),\n  f (Finset.piecewise t (m + m') m') = Finset.sum (Finset.powerset t) fun s => f (Finset.piecewise s m m')", "name": "MultilinearMap.map_piecewise_add", "isProp": true, "docString": "If one adds to a vector `m'` another vector `m`, but only for coordinates in a finset `t`, then\nthe image under a multilinear map `f` is the sum of `f (s.piecewise m m')` along all subsets `s` of\n`t`. This is mainly an auxiliary statement to prove the result when `t = univ`, given in\n`map_add_univ`, although it can be useful in its own right as it does not require the index set `ι`\nto be finite.", "terms": "[\n\"vector\",\n\"coordinates\",\n\"finset\",\n\"image\",\n\"multilinear map\",\n\"sum\",\n\"piecewise\",\n\"subsets\",\n\"auxiliary statement\",\n\"result\",\n\"univ\",\n\"index set\",\n\"finite\"\n]"}
{"type": "{α : Sort u_1} → (p : α → Prop) → Subtype p ↪ α", "name": "Function.Embedding.subtype", "isProp": false, "docString": "Embedding of a `Subtype`. ", "terms": "[\"Embedding\", \"Subtype\"]"}
{"type": "{α : Type u_2} →\n  {β : Type u_3} →\n    [inst : TopologicalSpace α] →\n      [inst_1 : Preorder α] → [inst_2 : TopologicalSpace β] → [inst_3 : Preorder β] → (α →Co β) → C(α, β)", "name": "ContinuousOrderHom.toContinuousMap", "isProp": false, "docString": "Reinterpret a `ContinuousOrderHom` as a `ContinuousMap`. ", "terms": "[\n    \"Reinterpret\",\n    \"ContinuousOrderHom\",\n    \"ContinuousMap\"\n]"}
{"type": "{𝕜 : Type u_1} →\n  {B : Type u_2} →\n    {F : Type u_3} →\n      [inst : TopologicalSpace B] →\n        [inst_1 : NontriviallyNormedField 𝕜] →\n          [inst_2 : NormedAddCommGroup F] →\n            [inst_3 : NormedSpace 𝕜 F] →\n              {U : Set B} →\n                (φ : B → F ≃L[𝕜] F) →\n                  IsOpen U →\n                    ContinuousOn (fun x => ↑(φ x)) U →\n                      ContinuousOn (fun x => ↑(ContinuousLinearEquiv.symm (φ x))) U → PartialHomeomorph (B × F) (B × F)", "name": "FiberwiseLinear.localHomeomorph", "isProp": false, "docString": "For `B` a topological space and `F` a `𝕜`-normed space, a map from `U : Set B` to `F ≃L[𝕜] F`\ndetermines a local homeomorphism from `B × F` to itself by its action fiberwise. ", "terms": "[\n    \"topological space\",\n    \"normed space\",\n    \"map\",\n    \"set\",\n    \"local homeomorphism\",\n    \"fiberwise\"\n]"}
{"type": "∀ {ι : Type v} [dec_ι : DecidableEq ι] {β : ι → Type w} [inst : (i : ι) → AddCommMonoid (β i)] {γ : Type u_1}\n  [inst_1 : AddMonoid γ] ⦃f g : (DirectSum ι fun i => β i) →+ γ⦄,\n  (∀ (i : ι) (y : β i), f ((DirectSum.of (fun i => β i) i) y) = g ((DirectSum.of (fun i => β i) i) y)) → f = g", "name": "DirectSum.addHom_ext", "isProp": true, "docString": "If two additive homomorphisms from `⨁ i, β i` are equal on each `of β i y`,\nthen they are equal. ", "terms": "[\n    \"additive homomorphisms\",\n    \"equal\",\n    \"⨁ (direct sum)\"\n]"}
{"type": "{R : Type u_1} →\n  [inst : Monoid R] → {S : Submonoid R} → [inst_1 : OreLocalization.OreSet S] → ↥S → (OreLocalization R S)ˣ", "name": "OreLocalization.numeratorUnit", "isProp": false, "docString": "The fraction `s /ₒ 1` as a unit in `R[S⁻¹]`, where `s : S`. ", "terms": "[\n  \"fraction\",\n  \"unit\",\n  \"R[S⁻¹]\"\n]"}
{"type": "∀ {α : Type u_1} [inst : PartialOrder α] {s t : Finset α} {a : α},\n  { ofColex := s } ≤ { ofColex := t } → (∀ b ∈ t, b ≤ a) → ∀ b ∈ s, b ≤ a", "name": "Finset.Colex.forall_le_mono", "isProp": true, "docString": "If `s ≤ t` in colex, and all elements in `t` are small, then all elements in `s` are small. ", "terms": "[\n    \"colex\",\n    \"elements\",\n    \"small\"\n]"}
{"type": "{R : Type u} → {σ : Type u_1} → [inst : CommSemiring R] → (σ →₀ ℕ) → MvPolynomial σ R →+ R", "name": "MvPolynomial.coeffAddMonoidHom", "isProp": false, "docString": "`MvPolynomial.coeff m` but promoted to an `AddMonoidHom`. ", "terms": "[\n    \"MvPolynomial.coeff\",\n    \"promoted\",\n    \"AddMonoidHom\"\n]"}
{"type": "∀ {M : Type u_1} [inst : CommMonoidWithZero M] {p : M} {L : List M}, Prime p → (p ∣ List.prod L ↔ ∃ a ∈ L, p ∣ a)", "name": "Prime.dvd_prod_iff", "isProp": true, "docString": "Prime `p` divides the product of a list `L` iff it divides some `a ∈ L` ", "terms": "[\n    \"Prime\",\n    \"divides\",\n    \"product\",\n    \"list\",\n    \"iff\",\n    \"some\",\n    \"∈\"\n]"}
{"type": "∀ {E : Type u_2} [inst : AddCommGroup E] [inst_1 : Module ℝ E] {s : Set E} {x : E},\n  Absorbent ℝ s → Set.Nonempty {r | 0 < r ∧ x ∈ r • s}", "name": "Absorbent.gauge_set_nonempty", "isProp": true, "docString": "If the given subset is `Absorbent` then the set we take an infimum over in `gauge` is nonempty,\nwhich is useful for proving many properties about the gauge.  ", "terms": "[\"subset\", \"Absorbent\", \"set\", \"infimum\", \"gauge\", \"nonempty\", \"properties\"]"}
{"type": "∀ {α : Type u_2} {β : Type u_3} [inst : NonAssocRing α] [inst_1 : NonAssocRing β] (f : α →+* β) (x y : α),\n  f (x - y) = f x - f y", "name": "RingHom.map_sub", "isProp": true, "docString": "Ring homomorphisms preserve subtraction. ", "terms": "[\n    \"Ring\",\n    \"Homomorphisms\",\n    \"Preserve\",\n    \"Subtraction\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {m : MeasurableSpace α} [inst : TopologicalSpace β],\n  MeasureTheory.StronglyMeasurable f → TopologicalSpace.IsSeparable (Set.range f)", "name": "MeasureTheory.StronglyMeasurable.isSeparable_range", "isProp": true, "docString": "The range of a strongly measurable function is separable. ", "terms": "[\n  \"range\",\n  \"strongly measurable function\",\n  \"separable\"\n]"}
{"type": "∀ {B : Type u_2} (F : Type u_3) [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F] (E : B → Type u_5)\n  [inst_2 : TopologicalSpace (Bundle.TotalSpace F E)] [inst_3 : (b : B) → TopologicalSpace (E b)]\n  [inst_4 : ConditionallyCompleteLinearOrder B] [inst_5 : OrderTopology B] [inst_6 : FiberBundle F E] (a b : B),\n  ∃ e, Set.Icc a b ⊆ e.baseSet", "name": "FiberBundle.exists_trivialization_Icc_subset", "isProp": true, "docString": "If `E` is a fiber bundle over a conditionally complete linear order,\nthen it is trivial over any closed interval. ", "terms": "[\n    \"fiber bundle\",\n    \"conditionally complete linear order\",\n    \"trivial\",\n    \"closed interval\"\n]"}
{"type": "∀ {α : Type u} (f : Filter α), ⨆ g, ⨆ (_ : ↑g ≤ f), ↑g = f", "name": "Filter.iSup_ultrafilter_le_eq", "isProp": true, "docString": "A filter equals the intersection of all the ultrafilters which contain it. ", "terms": "[\n  \"filter\",\n  \"intersection\",\n  \"ultrafilters\",\n  \"contain\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type v} (c : β → α) (p : α → Prop) [inst : CanLift α β c p],\n  CanLift (Multiset α) (Multiset β) (Multiset.map c) fun s => ∀ x ∈ s, p x", "name": "Multiset.canLift", "isProp": true, "docString": "If each element of `s : Multiset α` can be lifted to `β`, then `s` can be lifted to\n`Multiset β`. ", "terms": "[\n  \"element\",\n  \"Multiset\",\n  \"lifted\"\n]"}
{"type": "Lean.TrailingParserDescr", "name": "Polynomial.«term_%ₘ_»", "isProp": false, "docString": "`modByMonic` gives the remainder of `p` by a monic polynomial `q`. ", "terms": "[\n  \"modByMonic\",\n  \"remainder\",\n  \"monic polynomial\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {P : CategoryTheory.Functor Cᵒᵖ (Type w)} →\n      {X : C} → {R : CategoryTheory.Presieve X} → CategoryTheory.Presieve.FamilyOfElements P R → Prop", "name": "CategoryTheory.Presieve.FamilyOfElements.Compatible", "isProp": false, "docString": "A family of elements for the arrow set `R` is *compatible* if for any `f₁ : Y₁ ⟶ X` and\n`f₂ : Y₂ ⟶ X` in `R`, and any `g₁ : Z ⟶ Y₁` and `g₂ : Z ⟶ Y₂`, if the square `g₁ ≫ f₁ = g₂ ≫ f₂`\ncommutes then the elements of `P Z` obtained by restricting the element of `P Y₁` along `g₁` and\nrestricting the element of `P Y₂` along `g₂` are the same.\n\nIn special cases, this condition can be simplified, see `pullbackCompatible_iff` and\n`compatible_iff_sieveCompatible`.\n\nThis is referred to as a \"compatible family\" in Definition C2.1.2 of [Elephant], and on nlab:\nhttps://ncatlab.org/nlab/show/sheaf#GeneralDefinitionInComponents\n\nFor a more explicit version in the case where `R` is of the form `Presieve.ofArrows`, see\n`CategoryTheory.Presieve.Arrows.Compatible`.\n", "terms": "[\n    \"family of elements\",\n    \"arrow set\",\n    \"compatible\",\n    \"square\",\n    \"commutes\",\n    \"restricting\",\n    \"pullbackCompatible_iff\",\n    \"compatible_iff_sieveCompatible\",\n    \"compatible family\",\n    \"Definition\",\n    \"Elephant\",\n    \"nlab\",\n    \"sheaf\",\n    \"GeneralDefinitionInComponents\",\n    \"explicit version\",\n    \"Presieve.ofArrows\",\n    \"CategoryTheory.Presieve.Arrows.Compatible\"\n]"}
{"type": "{α : Type u_1} → {m0 : MeasurableSpace α} → MeasureTheory.Measure α → NNReal", "name": "MeasureTheory.measureUnivNNReal", "isProp": false, "docString": "The measure of the whole space with respect to a finite measure, considered as `ℝ≥0`. ", "terms": "[\n\"measure\", \n\"whole space\", \n\"finite measure\", \n\"ℝ≥0\"\n]"}
{"type": "SemilatSupCat ≌ SemilatInfCat", "name": "SemilatSupCatEquivSemilatInfCat", "isProp": false, "docString": "The equivalence between `SemilatSupCat` and `SemilatInfCat` induced by `OrderDual` both ways. ", "terms": "[\n    \"Equivalence\",\n    \"SemilatSupCat\",\n    \"SemilatInfCat\",\n    \"OrderDual\",\n    \"Induced\"\n]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasStrictTerminalObjects C]\n  {J : Type v} [inst_2 : CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J C)\n  [inst_3 : CategoryTheory.Limits.HasLimit F] (i : J),\n  ((j : J) → j ≠ i → CategoryTheory.Limits.IsTerminal (F.obj j)) →\n    ∀ [inst_4 : Subsingleton (i ⟶ i)], CategoryTheory.IsIso (CategoryTheory.Limits.limit.π F i)", "name": "CategoryTheory.Limits.limit_π_isIso_of_is_strict_terminal", "isProp": true, "docString": "If all but one object in a diagram is strict terminal, then the limit is isomorphic to the\nsaid object via `limit.π`. ", "terms": "[\n  \"object\",\n  \"diagram\",\n  \"strict terminal\",\n  \"limit\",\n  \"isomorphic\"\n]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  {p₁ p₂ p₃ : P}, dist p₁ p₂ = dist p₁ p₃ → |Real.Angle.toReal (EuclideanGeometry.oangle p₂ p₃ p₁)| < Real.pi / 2", "name": "EuclideanGeometry.abs_oangle_left_toReal_lt_pi_div_two_of_dist_eq", "isProp": true, "docString": "A base angle of an isosceles triangle is acute, oriented angle-at-point form. ", "terms": "[\n    \"base angle\",\n    \"isosceles triangle\",\n    \"acute\",\n    \"oriented angle-at-point form\"\n]"}
{"type": "∀ {α : Type u} [inst : TopologicalSpace α] (a : α), Filter.HasBasis (nhds a) (fun s => s ∈ nhds a ∧ IsOpen s) fun x => x", "name": "nhds_basis_opens'", "isProp": true, "docString": "The open neighborhoods of `a` are a basis for the neighborhood filter. See `nhds_basis_opens`\nfor a variant using open sets around `a` instead. ", "terms": "[\n  \"open neighborhoods\",\n  \"basis\",\n  \"neighborhood filter\",\n  \"open sets\"\n]"}
{"type": "Lean.ParserDescr", "name": "MeasureTheory.«term∫⁻_In_,_∂_»", "isProp": false, "docString": "The **lower Lebesgue integral** of a function `f` with respect to a measure `μ`. ", "terms": "[\n    \"Lower Lebesgue integral\",\n    \"function\",\n    \"measure\"\n]"}
{"type": "∀ {C : Type u₁} {D : Type u₂} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.Category.{v₂, u₂} D]\n  (F : CategoryTheory.Functor C D) [inst_2 : CategoryTheory.Faithful F],\n  CategoryTheory.Faithful (CategoryTheory.Functor.toEssImage F)", "name": "CategoryTheory.Faithful.toEssImage", "isProp": true, "docString": "The induced functor of a faithful functor is faithful. ", "terms": "[\"induced functor\", \"faithful functor\"]"}
{"type": "∀ {α : Type u_1} [inst : AddCommSemigroup α] [inst_1 : PartialOrder α] [inst_2 : ExistsAddOfLE α]\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_4 : Sub α] [inst_5 : OrderedSub α]\n  {a b : α} [inst : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], a ≤ b → b - (b - a) = a", "name": "tsub_tsub_cancel_of_le", "isProp": true, "docString": "See `tsub_tsub_le` for an inequality. ", "terms": "[]\n"}
{"type": "(ι : Type u_5) →\n  (R : Type u_6) →\n    (M : Type u_7) →\n      [inst : Unique ι] → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → (ι → M) ≃ₗ[R] M", "name": "LinearEquiv.funUnique", "isProp": false, "docString": "If `ι` has a unique element, then `ι → M` is linearly equivalent to `M`. ", "terms": "[\n    \"unique element\",\n    \"linearly equivalent\"\n]"}
{"type": "{α : Type u_1} → [inst : MeasurableSpace α] → (α → ENNReal) → ℕ → MeasureTheory.SimpleFunc α ENNReal", "name": "MeasureTheory.SimpleFunc.eapprox", "isProp": false, "docString": "Approximate a function `α → ℝ≥0∞` by a sequence of simple functions. ", "terms": "[\n    \"Approximate\",\n    \"function\",\n    \"→\",\n    \"ℝ≥0∞\",\n    \"sequence\",\n    \"simple functions\"\n]"}
{"type": "∀ {ι : Type u_1} {α : Type u_2} [inst : LinearOrderedRing α] {f g : ι → α} {s : Set ι},\n  MonovaryOn f g s → ∀ ⦃i : ι⦄, i ∈ s → ∀ ⦃j : ι⦄, j ∈ s → 0 ≤ (f j - f i) * (g j - g i)", "name": "MonovaryOn.sub_mul_sub_nonneg", "isProp": true, "docString": "**Alias** of the forward direction of `monovaryOn_iff_forall_mul_nonneg`.", "terms": "[\"Alias\", \"forward direction\", \"monovaryOn_iff_forall_mul_nonneg\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      {β γ : Type} →\n        [inst_2 : Fintype β] →\n          [inst_3 : DecidableEq β] →\n            [inst_4 : DecidableEq γ] →\n              (ε : β ≃ γ) →\n                (f : γ → C) →\n                  [inst_5 : CategoryTheory.Limits.HasBiproduct f] →\n                    [inst_6 : CategoryTheory.Limits.HasBiproduct (f ∘ ⇑ε)] → ⨁ f ∘ ⇑ε ≅ ⨁ f", "name": "CategoryTheory.Limits.biproduct.reindex", "isProp": false, "docString": "Reindex a categorical biproduct via an equivalence of the index types. ", "terms": "[\n    \"Reindex\",\n    \"Categorical\",\n    \"Biproduct\",\n    \"Equivalence\",\n    \"Index types\"\n]"}
{"type": "∀ (k : Type u_1) (V : Type u_2) {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (p : P), p ∈ ⊤", "name": "AffineSubspace.mem_top", "isProp": true, "docString": "All points are in `⊤`. ", "terms": "[\"points\", \"⊤\"]"}
{"type": "{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {C : Type u} →\n      [inst_1 : CategoryTheory.Category.{v, u} C] →\n        {F : CategoryTheory.Functor J C} →\n          [inst_2 : CategoryTheory.Limits.HasLimit F] →\n            (t : CategoryTheory.Limits.LimitCone F) → CategoryTheory.Limits.limit F ≅ t.cone.pt", "name": "CategoryTheory.Limits.limit.isoLimitCone", "isProp": false, "docString": "Given any other limit cone for `F`, the chosen `limit F` is isomorphic to the cone point.\n", "terms": "[\n    \"limit cone\",\n    \"F\",\n    \"isomorphic\",\n    \"cone point\"\n]"}
{"type": "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → {δ : Type u_4} → (α ↪ β) → (γ ↪ δ) → α ⊕ γ ↪ β ⊕ δ", "name": "Function.Embedding.sumMap", "isProp": false, "docString": "If `e₁` and `e₂` are embeddings, then so is `Sum.map e₁ e₂`. ", "terms": "[\"embeddings\", \"Sum.map\"]"}
{"type": "{C : ℤ → Sort u_1} → (b : ℤ) → C b → ((k : ℤ) → k ≤ b → C k → C (k - 1)) → (n : ℕ) → C (b + Int.negSucc n)", "name": "Int.inductionOn'.neg", "isProp": false, "docString": "The negative case of `Int.inductionOn'`. ", "terms": "[\"negative case\", \"Int.inductionOn\"]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {ι : Type u_4} {F : ι → β → α}\n  [inst_2 : CompactSpace β], Equicontinuous F → UniformEquicontinuous F", "name": "CompactSpace.uniformEquicontinuous_of_equicontinuous", "isProp": true, "docString": "An equicontinuous family of functions defined on a compact uniform space is automatically\nuniformly equicontinuous. ", "terms": "[\n    \"equicontinuous\",\n    \"family of functions\",\n    \"defined on\",\n    \"compact\",\n    \"uniform space\",\n    \"automatically\",\n    \"uniformly equicontinuous\"\n]"}
{"type": "∀ {α : Type u_1} {s t : Set α}, s = t → s ⊆ t", "name": "Eq.subset", "isProp": true, "docString": "Duplicate of `Eq.subset'`, which currently has elaboration problems. ", "terms": "[\"Duplicate\", \"Eq.subset\", \"elaboration problems\"]"}
{"type": "{𝕜 : Type u_1} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type u_2} →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : NormedSpace 𝕜 E] →\n          {E' : Type u_3} →\n            [inst_3 : NormedAddCommGroup E'] →\n              [inst_4 : NormedSpace 𝕜 E'] →\n                {H : Type u_4} →\n                  [inst_5 : TopologicalSpace H] →\n                    (I : ModelWithCorners 𝕜 E H) →\n                      {H' : Type u_5} →\n                        [inst_6 : TopologicalSpace H'] →\n                          (I' : ModelWithCorners 𝕜 E' H') →\n                            {N : Type u_6} →\n                              [inst_7 : TopologicalSpace N] →\n                                [inst_8 : ChartedSpace H N] →\n                                  (G : Type u_10) →\n                                    [inst_9 : AddMonoid G] →\n                                      [inst_10 : TopologicalSpace G] →\n                                        [inst_11 : ChartedSpace H' G] →\n                                          [inst_12 : SmoothAdd I' G] →\n                                            {U V : TopologicalSpace.Opens N} →\n                                              U ≤ V → ContMDiffMap I I' (↥V) G ⊤ →+ ContMDiffMap I I' (↥U) G ⊤", "name": "SmoothMap.restrictAddMonoidHom", "isProp": false, "docString": "For an additive Lie group `G` and open sets `U ⊆ V` in `N`, the 'restriction' group\nhomomorphism from `C^∞⟮I, V; I', G⟯` to `C^∞⟮I, U; I', G⟯`.", "terms": "[\n  \"additive Lie group\",\n  \"open sets\",\n  \"restriction\",\n  \"group homomorphism\",\n  \"C^∞⟮I, V; I', G⟯\",\n  \"C^∞⟮I, U; I', G⟯\"\n]"}
{"type": "(M : Type u_1) →\n  [inst : Monoid M] →\n    {R' : Type u_2} →\n      [inst_1 : Ring R'] →\n        [inst_2 : MulSemiringAction M R'] → (U : Subring R') → [inst_3 : IsInvariantSubring M U] → ↥U →+*[M] R'", "name": "IsInvariantSubring.subtypeHom", "isProp": false, "docString": "The canonical inclusion from an invariant subring. ", "terms": "[\n  \"canonical\",\n  \"inclusion\",\n  \"invariant\",\n  \"subring\"\n]"}
{"type": "∀ {L : FirstOrder.Language} {ι : Type u_1} [inst : Encodable ι] [inst : Preorder ι]\n  [inst_1 : IsDirected ι fun x x_1 => x ≤ x_1] [inst_2 : Nonempty ι] {G : ι → Type w}\n  [inst_3 : (i : ι) → FirstOrder.Language.Structure L (G i)]\n  (f : (i j : ι) → i ≤ j → FirstOrder.Language.Embedding L (G i) (G j)),\n  (∀ (i : ι), FirstOrder.Language.Structure.CG L (G i)) →\n    ∀ [inst_4 : DirectedSystem G fun i j h => ⇑(f i j h)],\n      FirstOrder.Language.Structure.CG L (FirstOrder.Language.DirectLimit G f)", "name": "FirstOrder.Language.DirectLimit.cg", "isProp": true, "docString": "The direct limit of countably many countably generated structures is countably generated. ", "terms": "[\n    \"direct limit\", \n    \"countably many\", \n    \"countably generated\", \n    \"structures\", \n    \"generated\"\n]"}
{"type": "∀ {G : Type u_1} [inst : AddGroup G] {N : Type u_5} [inst_1 : AddGroup N] (f : G →+ N) {H K : AddSubgroup G},\n  AddMonoidHom.ker f ≤ H → AddMonoidHom.ker f ≤ K → AddSubgroup.map f H = AddSubgroup.map f K → H = K", "name": "AddSubgroup.map_injective_of_ker_le", "isProp": true, "docString": "Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`.", "terms": "[\n    \"f(A)\",\n    \"f(B)\",\n    \"ker f\",\n    \"A\",\n    \"B\",\n    \"deduce\",\n    \"=\",\n    \"≤\"\n]"}
{"type": "{α : Sort u} →\n  {s : Setoid α} →\n    {motive : Quotient s → Sort v} →\n      [h : ∀ (a : α), Subsingleton (motive ⟦a⟧)] → (q : Quotient s) → ((a : α) → motive ⟦a⟧) → motive q", "name": "Quotient.recOnSubsingleton", "isProp": false, "docString": "The analogue of `Quot.recOnSubsingleton` for `Quotient`. See `Quot.recOnSubsingleton`. ", "terms": "[\n    \"analogue\",\n    \"Quot.recOnSubsingleton\",\n    \"Quotient\"\n]"}
{"type": "{T : Type u} →\n  [inst : CategoryTheory.Category.{v, u} T] →\n    {X Y : T} →\n      {f : X ⟶ Y} →\n        {P Q : T} →\n          {g : P ⟶ Q} →\n            {u : X ⟶ P} →\n              {v : Y ⟶ Q} →\n                CategoryTheory.CategoryStruct.comp u g = CategoryTheory.CategoryStruct.comp f v →\n                  (CategoryTheory.Arrow.mk f ⟶ CategoryTheory.Arrow.mk g)", "name": "CategoryTheory.Arrow.homMk'", "isProp": false, "docString": "We can also build a morphism in the arrow category out of any commutative square in `T`. ", "terms": "[\n  \"morphism\",\n  \"arrow category\",\n  \"commutative square\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →SL[σ₁₂] F) {M : ℝ},\n  0 ≤ M → (∀ (x : E), ‖f x‖ ≤ M * ‖x‖) → ‖f‖ ≤ M", "name": "ContinuousLinearMap.op_norm_le_bound", "isProp": true, "docString": "If one controls the norm of every `A x`, then one controls the norm of `A`. ", "terms": "[\"controls\", \"norm\", \"every\", \"of\"]"}
{"type": "(X : Type u_1) → [inst : TopologicalSpace X] → [inst : SigmaCompactSpace X] → ℕ → Set X", "name": "compactCovering", "isProp": false, "docString": "A choice of compact covering for a `σ`-compact space, chosen to be monotone. ", "terms": "[\n  \"choice\",\n  \"compact covering\",\n  \"σ-compact space\",\n  \"monotone\"\n]"}
{"type": "∀ {α : Type u} [inst : HasSubset α] [inst_1 : HasSSubset α]\n  [inst_2 : IsNonstrictStrictOrder α (fun x x_1 => x ⊆ x_1) fun x x_1 => x ⊂ x_1] {a b : α}, a ⊆ b → ¬b ⊆ a → a ⊂ b", "name": "HasSubset.Subset.ssubset_of_not_subset", "isProp": true, "docString": "**Alias** of `ssubset_of_subset_not_subset`.", "terms": "[]"}
{"type": "{B : Type u₁} →\n  [inst : CategoryTheory.Bicategory B] →\n    {C : Type u₂} →\n      [inst_1 : CategoryTheory.Bicategory C] →\n        (F G : CategoryTheory.OplaxFunctor B C) →\n          CategoryTheory.Category.{max u₁ w₂, max (max (max u₁ v₁) v₂) w₂} (F ⟶ G)", "name": "CategoryTheory.OplaxNatTrans.category", "isProp": false, "docString": "Category structure on the oplax natural transformations between OplaxFunctors. ", "terms": "[\n    \"Category structure\",\n    \"oplax natural transformations\",\n    \"OplaxFunctors\"\n]"}
{"type": "∀ {α : Type u_2} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {f g : α → ENNReal},\n  AEMeasurable f →\n    AEMeasurable g →\n      ∀ {p q : ℝ},\n        0 ≤ p →\n          0 ≤ q → p + q = 1 → ∫⁻ (a : α), f a ^ p * g a ^ q ∂μ ≤ (∫⁻ (a : α), f a ∂μ) ^ p * (∫⁻ (a : α), g a ∂μ) ^ q", "name": "ENNReal.lintegral_mul_norm_pow_le", "isProp": true, "docString": "A different formulation of Hölder's inequality for two functions, with two exponents that sum to\n1, instead of reciprocals of  ", "terms": "[\n  \"formulation\",\n  \"Hölder's inequality\",\n  \"functions\",\n  \"exponents\",\n  \"sum\",\n  \"reciprocals\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_4} (l : ι →₀ 𝕜) (v : ι → E) (x : E),\n  inner (Finsupp.sum l fun i a => a • v i) x = Finsupp.sum l fun i a => (starRingEnd 𝕜) a • inner (v i) x", "name": "Finsupp.sum_inner", "isProp": true, "docString": "An inner product with a sum on the left, `Finsupp` version. ", "terms": "[\n    \"Inner product\",\n    \"Sum\",\n    \"Finsupp\"\n]"}
{"type": "∀ {α : Type v} {s : Finset α} {M : Type u_2} [inst : CommMonoid M] (f : α → M) (p : M → Prop),\n  (∀ (a b : M), p a → p b → p (a * b)) → Finset.Nonempty s → (∀ x ∈ s, p (f x)) → p (Finset.prod s fun x => f x)", "name": "Finset.prod_induction_nonempty", "isProp": true, "docString": "To prove a property of a product, it suffices to prove that\nthe property is multiplicative and holds on factors. ", "terms": "[\n    \"property\",\n    \"product\",\n    \"multiplicative\",\n    \"factors\"\n]"}
{"type": "{R : Type u_1} → [inst : Ring R] → R → PowerSeries R → PowerSeries R", "name": "PowerSeries.inv.aux", "isProp": false, "docString": "Auxiliary function used for computing inverse of a power series ", "terms": "[\"Auxiliary function\", \"computing\", \"inverse\", \"power series\"]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] (s : EuclideanGeometry.Sphere P) (p : P) (v : V),\n  dist (EuclideanGeometry.Sphere.secondInter s p v) s.center = dist p s.center", "name": "EuclideanGeometry.Sphere.secondInter_dist", "isProp": true, "docString": "The distance between `secondInter` and the center equals the distance between the original\npoint and the center. ", "terms": "[\"distance\", \"center\", \"equals\", \"original point\"]"}
{"type": "∀ {α : Type u_1} [inst : AddCommGroup α] {p a₁ a₂ b₁ b₂ : α},\n  a₂ ≡ b₂ [PMOD p] → a₁ - a₂ ≡ b₁ - b₂ [PMOD p] → a₁ ≡ b₁ [PMOD p]", "name": "AddCommGroup.ModEq.sub_right_cancel", "isProp": true, "docString": "**Alias** of the forward direction of `AddCommGroup.ModEq.sub_iff_right`.", "terms": "[]\n"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {v w : E}, inner v w = 0 → ‖w - v‖ = ‖w + v‖", "name": "norm_sub_eq_norm_add", "isProp": true, "docString": "Given two orthogonal vectors, their sum and difference have equal norms. ", "terms": "[\n    \"orthogonal vectors\", \n    \"sum\", \n    \"difference\", \n    \"equal\", \n    \"norms\"\n]"}
{"type": "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : HasOuterApproxClosed X] {F : Set X} (hF : IsClosed F)\n  [inst_2 : MeasurableSpace X] [inst_3 : OpensMeasurableSpace X] (μ : MeasureTheory.Measure X) (n : ℕ),\n  ↑↑μ F ≤ ∫⁻ (x : X), ↑((IsClosed.apprSeq hF n) x) ∂μ", "name": "HasOuterApproxClosed.measure_le_lintegral", "isProp": true, "docString": "The measure of a closed set is at most the integral of any function in a decreasing\napproximating sequence to the indicator of the set. ", "terms": "[\n    \"measure\",\n    \"closed set\",\n    \"integral\",\n    \"function\",\n    \"decreasing approximating sequence\",\n    \"indicator of the set\"\n]"}
{"type": "{R : Type u} → [inst : Ring R] → {V W : FGModuleCat R} → (V ≅ W) → ↑V ≃ₗ[R] ↑W", "name": "FGModuleCat.isoToLinearEquiv", "isProp": false, "docString": "Converts and isomorphism in the category `FGModuleCat R` to\na `LinearEquiv` between the underlying modules. ", "terms": "[\n    \"Converts\",\n    \"Isomorphism\",\n    \"Category\",\n    \"FGModuleCat R\",\n    \"LinearEquiv\",\n    \"Modules\"\n]"}
{"type": "∀ {ι : Type u_1} {X : Type u_3} {α : Type u_6} [inst : TopologicalSpace X] [inst_1 : UniformSpace α] {F : ι → X → α},\n  Equicontinuous F ↔ Continuous (⇑UniformFun.ofFun ∘ Function.swap F)", "name": "equicontinuous_iff_continuous", "isProp": true, "docString": "A family `𝓕 : ι → X → α` is equicontinuous iff the function `swap 𝓕 : X → ι → α` is\ncontinuous *when `ι → α` is equipped with the topology of uniform convergence*. This is\nvery useful for developping the equicontinuity API, but it should not be used directly for other\npurposes. ", "terms": "[\n    \"family\",\n    \"equicontinuous\",\n    \"function\",\n    \"continuous\",\n    \"topology\",\n    \"uniform convergence\",\n    \"API\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} {f : α → β},\n  Function.Surjective f → ∀ (s : Set β), Set.Subsingleton (f ⁻¹' s) → Set.Subsingleton s", "name": "Set.subsingleton_of_preimage", "isProp": true, "docString": "If the preimage of a set under a surjective map is a subsingleton,\nthe set is a subsingleton. ", "terms": "[\n    \"preimage\",\n    \"set\",\n    \"surjective map\",\n    \"subsingleton\"\n]"}
{"type": "∀ {α : Type u_1} {s t : Finset α}, s ⋖ t → ↑s ⋖ ↑t", "name": "Covby.finset_coe", "isProp": true, "docString": "**Alias** of the reverse direction of `Finset.coe_covby_coe`.", "terms": "[\n  \"Alias\",\n  \"reverse direction\",\n  \"Finset.coe_covby_coe\"\n]"}
{"type": "∀ {S : Type u_3} {R : Type u_4} [inst : CommSemiring S] [inst_1 : Semiring R] [inst_2 : Algebra S R]\n  (p : Submodule S R), SetLike.GradedMonoid fun i => p ^ i", "name": "Submodule.nat_power_gradedMonoid", "isProp": true, "docString": "A direct sum of powers of a submodule of an algebra has a multiplicative structure. ", "terms": "[\"direct sum\", \"powers\", \"submodule\", \"algebra\", \"multiplicative structure\"]"}
{"type": "{R : Type u_1} →\n  {Γ₀ : Type u_2} →\n    [inst : CommRing R] →\n      [inst_1 : LinearOrderedCommMonoidWithZero Γ₀] →\n        (v : Valuation R Γ₀) → {J : Ideal R} → J ≤ Valuation.supp v → R ⧸ J → Γ₀", "name": "Valuation.onQuotVal", "isProp": false, "docString": "If `hJ : J ⊆ supp v` then `onQuotVal hJ` is the induced function on `R / J` as a function.\nNote: it's just the function; the valuation is `onQuot hJ`. ", "terms": "[\n\"subset\",\n\"support\",\n\"function\",\n\"induced function\",\n\"quotient\",\n\"valuation\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {α : Type u_1} → {Z : α → C} → CategoryTheory.Limits.Cofan Z → CategoryTheory.Limits.Fan fun x => Opposite.op (Z x)", "name": "CategoryTheory.Limits.Cofan.op", "isProp": false, "docString": "A `Cofan` gives a `Fan` in the opposite category.  ", "terms": "[\"Cofan\", \"Fan\", \"opposite category\"]"}
{"type": "{Ω : Type u_1} →\n  {ι : Type u_2} →\n    (m' : MeasurableSpace Ω) →\n      [mΩ : MeasurableSpace Ω] →\n        [inst : StandardBorelSpace Ω] →\n          [inst : Nonempty Ω] →\n            m' ≤ mΩ →\n              (ι → MeasurableSpace Ω) →\n                (μ : autoParam (MeasureTheory.Measure Ω) _auto✝) → [inst : MeasureTheory.IsFiniteMeasure μ] → Prop", "name": "ProbabilityTheory.iCondIndep", "isProp": false, "docString": "A family of measurable space structures (i.e. of σ-algebras) is conditionally independent given\n`m'` with respect to a measure `μ` (typically defined on a finer σ-algebra) if the family of sets of\nmeasurable sets they define is independent. `m : ι → MeasurableSpace Ω` is conditionally independent\ngiven `m'` with respect to measure `μ` if for any finite set of indices `s = {i_1, ..., i_n}`, for\nany sets `f i_1 ∈ m i_1, ..., f i_n ∈ m i_n`, then\n`μ⟦⋂ i in s, f i | m'⟧ =ᵐ[μ] ∏ i in s, μ⟦f i | m'⟧ `.\nSee `ProbabilityTheory.iCondIndep_iff`. ", "terms": "[\n  \"family\",\n  \"measurable space structures\",\n  \"σ-algebras\",\n  \"conditionally independent\",\n  \"measure\",\n  \"family of sets\",\n  \"measurable sets\",\n  \"independent\",\n  \"MeasurableSpace\",\n  \"conditionally independent\",\n  \"finite set\",\n  \"indices\",\n  \"sets\",\n  \"ProbabilityTheory.iCondIndep_iff\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {F : CategoryTheory.Functor C D} →\n          {X : C} →\n            {S : CategoryTheory.Presieve X} →\n              {Y : D} →\n                {f : Y ⟶ F.obj X} → (self : CategoryTheory.Presieve.FunctorPushforwardStructure F S f) → self.preobj ⟶ X", "name": "CategoryTheory.Presieve.FunctorPushforwardStructure.premap", "isProp": false, "docString": "a map in the source category which has to be in the presieve ", "terms": "[\n  \"map\",\n  \"source category\",\n  \"presieve\"\n]"}
{"type": "∀ {α : Type u_1} [inst : MetricSpace α] {C : Set α},\n  Perfect C →\n    ∀ {ε : ENNReal},\n      Set.Nonempty C →\n        0 < ε →\n          ∃ C₀ C₁,\n            (Perfect C₀ ∧ Set.Nonempty C₀ ∧ C₀ ⊆ C ∧ EMetric.diam C₀ ≤ ε) ∧\n              (Perfect C₁ ∧ Set.Nonempty C₁ ∧ C₁ ⊆ C ∧ EMetric.diam C₁ ≤ ε) ∧ Disjoint C₀ C₁", "name": "Perfect.small_diam_splitting", "isProp": true, "docString": "A refinement of `Perfect.splitting` for metric spaces, where we also control\nthe diameter of the new perfect sets. ", "terms": "[\n  \"Refinement\",\n  \"Perfect.splitting\",\n  \"Metric spaces\",\n  \"Diameter\",\n  \"Perfect sets\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.IsFilteredOrEmpty C] → {j j' : C} → (j ⟶ j') → (j ⟶ j') → C", "name": "CategoryTheory.IsFiltered.coeq", "isProp": false, "docString": "`coeq f f'`, for morphisms `f f' : j ⟶ j'`, is an arbitrary choice of object\nwhich admits a morphism `coeqHom f f' : j' ⟶ coeq f f'` such that\n`coeq_condition : f ≫ coeqHom f f' = f' ≫ coeqHom f f'`.\nIts existence is ensured by `IsFiltered`.\n", "terms": "[\n    \"coeq\",\n    \"morphisms\",\n    \"object\",\n    \"morphism\",\n    \"coeqHom\",\n    \"coeq_condition\",\n    \"existence\",\n    \"IsFiltered\"\n]"}
{"type": "∀ (a : ℤ) {b : ℕ}, Odd b → jacobiSym (-a) b = ZMod.χ₄ ↑b * jacobiSym a b", "name": "jacobiSym.neg", "isProp": true, "docString": "If `b` is odd, then `J(-a | b) = χ₄ b * J(a | b)`. ", "terms": "[\n    \"odd\",\n    \"J-function\",\n    \"multiplication\"\n]"}
{"type": "∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\n  StrictConcaveOn 𝕜 s f → ∀ {x y z : 𝕜}, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) < (f y - f x) / (y - x)", "name": "StrictConcaveOn.slope_anti_adjacent", "isProp": true, "docString": "If `f : 𝕜 → 𝕜` is strictly concave, then for any three points `x < y < z` the slope of the\nsecant line of `f` on `[x, y]` is strictly greater than the slope of the secant line of `f` on\n`[x, z]`. ", "terms": "[\n    \"strictly concave\",\n    \"three points\",\n    \"slope\",\n    \"secant line\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] → {P Q : C} → (P ⟶ Q) → CategoryTheory.Over P → CategoryTheory.Over Q", "name": "CategoryTheory.Abelian.app", "isProp": false, "docString": "This is just composition of morphisms in `C`. Another way to express this would be\n`(Over.map f).obj a`, but our definition has nicer definitional properties. ", "terms": "[\n  \"composition of morphisms\",\n   \"C\",\n   \"Over.map\",\n   \"f\",\n   \"obj\",\n   \"a\",\n   \"definitional properties\"\n]"}
{"type": "{R : Type u} →\n  {L : Type v} →\n    {L' : Type w₂} →\n      [inst : CommRing R] →\n        [inst_1 : LieRing L] →\n          [inst_2 : LieAlgebra R L] → [inst_3 : LieRing L'] → [inst_4 : LieAlgebra R L'] → (L →ₗ⁅R⁆ L') → LieIdeal R L'", "name": "LieHom.idealRange", "isProp": false, "docString": "The range of a morphism of Lie algebras as an ideal in the codomain. ", "terms": "[\n    \"range\",\n    \"morphism\",\n    \"Lie algebras\",\n    \"ideal\",\n    \"codomain\"\n]"}
{"type": "∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {f g : α → ℝ} {s : Set α}\n  [inst_1 : MeasureTheory.SigmaFinite μ],\n  MeasureTheory.IntegrableOn f s →\n    MeasureTheory.IntegrableOn g s →\n      MeasurableSet s →\n        (∀ x ∈ s, f x ≤ g x) →\n          ↑↑(MeasureTheory.Measure.prod μ MeasureTheory.volume) (regionBetween f g s) =\n            ENNReal.ofReal (∫ (y : α) in s, (g - f) y ∂μ)", "name": "volume_regionBetween_eq_integral", "isProp": true, "docString": "If two functions are integrable on a measurable set, and one function is less than\nor equal to the other on that set, then the volume of the region\nbetween the two functions can be represented as an integral. ", "terms": "[\n    \"functions\",\n    \"integrable\",\n    \"measurable set\",\n    \"less than or equal to\",\n    \"volume\",\n    \"region\",\n    \"between\",\n    \"represented\",\n    \"integral\"\n]"}
{"type": "∀ {α : Type u_1} [inst : LinearOrder α] {E : Type u_2} [inst_1 : PseudoEMetricSpace E] (f : α → E) {s t : Set α}\n  {x : α}, IsGreatest s x → IsLeast t x → eVariationOn f (s ∪ t) = eVariationOn f s + eVariationOn f t", "name": "eVariationOn.union", "isProp": true, "docString": "If a set `s` is to the left of a set `t`, and both contain the boundary point `x`, then\nthe variation of `f` along `s ∪ t` is the sum of the variations. ", "terms": "[\n    \"set\",\n    \"left\",\n    \"boundary point\",\n    \"variation\",\n    \"sum\",\n    \"union\"\n]"}
{"type": "{E : Type u_4} →\n  {F : Type u_5} →\n    [inst : NormedAddCommGroup E] →\n      [inst_1 : NormedSpace ℝ E] →\n        [inst_2 : NormedAddCommGroup F] → [inst_3 : NormedSpace ℝ F] → CoeFun (SchwartzMap E F) fun x => E → F", "name": "SchwartzMap.instCoeFun", "isProp": false, "docString": "Helper instance for when there's too many metavariables to apply `FunLike.hasCoeToFun`. ", "terms": "[]"}
{"type": "{M : Type u_1} → [inst : MulOneClass M] → Inf (Submonoid M)", "name": "Submonoid.instInfSubmonoid", "isProp": false, "docString": "The inf of two submonoids is their intersection. ", "terms": "[\n    \"inf\",\n    \"submonoids\",\n    \"intersection\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} [inst : Preorder β] {f : α → β} {l : Filter α} {a : α},\n  IsMinFilter (⇑OrderDual.toDual ∘ f) l a → IsMaxFilter f l a", "name": "IsMinFilter.undual", "isProp": true, "docString": "**Alias** of the forward direction of `isMinFilter_dual_iff`.", "terms": "[]\n"}
{"type": "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : ℂ → E},\n  DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Iio 0) →\n    (∃ c < 2,\n        ∃ B,\n          f =O[Bornology.cobounded ℂ ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\n            Real.exp (B * Complex.abs z ^ c)) →\n      (∀ x ≤ 0, f ↑x = 0) → (∀ x ≤ 0, f (↑x * Complex.I) = 0) → Set.EqOn f 0 {z | z.re ≤ 0 ∧ z.im ≤ 0}", "name": "PhragmenLindelof.eq_zero_on_quadrant_III", "isProp": true, "docString": "**Phragmen-Lindelöf principle** in the third quadrant. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the third quadrant.\n\nThen `f` is equal to zero on the closed third quadrant. ", "terms": "[\n  \"Phragmen-Lindelöf principle\",\n  \"third quadrant\",\n  \"function\",\n  \"differentiable\",\n  \"open\",\n  \"continuous\",\n  \"closure\",\n  \"bounded\",\n  \"from above\",\n  \"exp\",\n  \"abs\",\n  \"boundary\",\n  \"equal to zero\",\n  \"closed\"\n]"}
{"type": "(R : Type u_1) → [inst : One R] → [inst : Neg R] → Type u_1", "name": "Quaternion", "isProp": false, "docString": "Space of quaternions over a type. Implemented as a structure with four fields:\n`re`, `im_i`, `im_j`, and `im_k`. ", "terms": "[\"Space\", \"quaternions\", \"type\", \"Implemented\", \"structure\", \"fields\"]"}
{"type": "{R : Type u_1} →\n  [inst : CommSemiring R] →\n    {M : Type u_4} →\n      {N : Type u_5} →\n        {P : Type u_6} →\n          {Q : Type u_7} →\n            [inst_1 : AddCommMonoid M] →\n              [inst_2 : AddCommMonoid N] →\n                [inst_3 : AddCommMonoid P] →\n                  [inst_4 : AddCommMonoid Q] →\n                    [inst_5 : Module R M] →\n                      [inst_6 : Module R N] →\n                        [inst_7 : Module R P] →\n                          [inst_8 : Module R Q] →\n                            (M →ₗ[R] P) → (N →ₗ[R] Q) → TensorProduct R M N →ₗ[R] TensorProduct R P Q", "name": "TensorProduct.map", "isProp": false, "docString": "The tensor product of a pair of linear maps between modules. ", "terms": "[\n    \"Tensor product\",\n    \"Pair\",\n    \"Linear maps\",\n    \"Modules\"\n]"}
{"type": "{M : Type u_1} → {N : Type u_2} → [inst : Mul M] → [inst_1 : Mul N] → (Mᵐᵒᵖ →ₙ* Nᵐᵒᵖ) ≃ (M →ₙ* N)", "name": "MulHom.unop", "isProp": false, "docString": "The 'unopposite' of a semigroup homomorphism `Mᵐᵒᵖ →ₙ* Nᵐᵒᵖ`. Inverse to `MulHom.op`. ", "terms": "[\n    \"unopposite\",\n    \"semigroup\",\n    \"homomorphism\",\n    \"Inverse\",\n    \"MulHom.op\"\n]"}
{"type": "∀ {α : Type u} [inst : HasSubset α] [inst_1 : IsTrans α fun x x_1 => x ⊆ x_1] {a b c : α}, a ⊆ b → b ⊆ c → a ⊆ c", "name": "HasSubset.Subset.trans", "isProp": true, "docString": "**Alias** of `subset_trans`.", "terms": "[\"Alias\", \"subset_trans\"]"}
{"type": "{F : Type u_1} → [inst : Field F] → (p q : Polynomial F) → Polynomial.Gal (p * q) →* Polynomial.Gal p × Polynomial.Gal q", "name": "Polynomial.Gal.restrictProd", "isProp": false, "docString": "The Galois group of a product maps into the product of the Galois groups.  ", "terms": "[\n    \"Galois group\",\n    \"product\",\n    \"maps into\"\n]"}
{"type": "{R' : Type u} →\n  {M : Type v} →\n    [inst : CommSemiring R'] →\n      [inst_1 : AddCommMonoid M] →\n        [inst_2 : Module R' M] →\n          [inst_3 : Module R'ᵐᵒᵖ M] →\n            [inst_4 : IsCentralScalar R' M] →\n              {A : Type u_2} →\n                [inst_5 : Semiring A] →\n                  [inst_6 : Algebra R' A] → { f // ∀ (x y : M), f x * f y = 0 } ≃ (TrivSqZeroExt R' M →ₐ[R'] A)", "name": "TrivSqZeroExt.liftEquivOfComm", "isProp": false, "docString": "A simplified version of `TrivSqZeroExt.liftEquiv` for the commutative case. ", "terms": "[\"simplified version\", \"TrivSqZeroExt.liftEquiv\", \"commutative case\"]"}
{"type": "{ι : Type u_1} → BoxIntegral.Box ι →o Set (ι → ℝ)", "name": "BoxIntegral.Box.Ioo", "isProp": false, "docString": "The interior of a box. ", "terms": "[\"interior\", \"box\"]"}
{"type": "∀ (α : Type u_1) [inst : DecidableEq α] [inst_1 : Fintype α] {m : Multiset ℕ},\n  (∃ g, Equiv.Perm.cycleType g = m) ↔ Multiset.sum m ≤ Fintype.card α ∧ ∀ a ∈ m, 2 ≤ a", "name": "Equiv.Perm.exists_with_cycleType_iff", "isProp": true, "docString": "There are permutations with cycleType `m` if and only if\nits sum is at most `Fintype.card α` and its members are at least 2. ", "terms": "[\n  \"Permutations\",\n  \"Cycle Type\",\n  \"Sum\",\n  \"At Most\",\n  \"Fintype.card\",\n  \"Members\",\n  \"At Least\"\n]"}
{"type": "∀ {M : Type u_2} [inst : AddCommGroup M] {𝕜 : Type u_7} [inst_1 : Field 𝕜] [inst_2 : Module 𝕜 M] {f : M →ₗ[𝕜] M},\n  LinearMap.det f = 0 → LinearMap.range f < ⊤", "name": "LinearMap.range_lt_top_of_det_eq_zero", "isProp": true, "docString": "If the determinant of a map vanishes, then the map is not onto. ", "terms": "[\n    \"determinant\",\n    \"map\",\n    \"vanishes\",\n    \"not onto\"\n]"}
{"type": "∀ {L : Type u_1} [inst : TopologicalSpace L] [inst_1 : Sup L] [self : ContinuousSup L], Continuous fun p => p.1 ⊔ p.2", "name": "ContinuousSup.continuous_sup", "isProp": true, "docString": "The supremum is continuous ", "terms": "[\"supremum\", \"continuous\"]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Abelian C] {P : C}\n  (a : CategoryTheory.Over P), Quot.mk (CategoryTheory.Abelian.PseudoEqual P) a = 0 ↔ a.hom = 0", "name": "CategoryTheory.Abelian.Pseudoelement.pseudoZero_iff", "isProp": true, "docString": "The pseudoelement induced by an arrow is zero precisely when that arrow is zero. ", "terms": "[\"pseudoelement\", \"induced\", \"arrow\", \"zero\", \"precisely\"]"}
{"type": "(k : Type u_1) →\n  (P₁ : Type u_2) →\n    {V₁ : Type u_6} →\n      [inst : Ring k] →\n        [inst_1 : AddCommGroup V₁] → [inst_2 : Module k V₁] → [inst_3 : AddTorsor V₁ P₁] → V₁ → P₁ ≃ᵃ[k] P₁", "name": "AffineEquiv.constVAdd", "isProp": false, "docString": "The map `p ↦ v +ᵥ p` as an affine automorphism of an affine space.\n\nNote that there is no need for an `AffineMap.constVAdd` as it is always an equivalence.\nThis is roughly to `DistribMulAction.toLinearEquiv` as `+ᵥ` is to `•`. ", "terms": "[\n    \"map\",\n    \"affine automorphism\",\n    \"affine space\",\n    \"AffineMap.constVAdd\",\n    \"equivalence\",\n    \"DistribMulAction.toLinearEquiv\",\n    \"+ᵥ\",\n    \"•\"\n]"}
{"type": "∀ {E : Type u_2} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] (s : Set E),\n  Metric.diam ((convexHull ℝ) s) = Metric.diam s", "name": "convexHull_diam", "isProp": true, "docString": "Diameter of the convex hull of a set `s` equals the emetric diameter of `s`. ", "terms": "[\n    \"Diameter\",\n    \"Convex Hull\",\n    \"Set\",\n    \"Equals\",\n    \"Emetric Diameter\"\n]"}
{"type": "Lean.PrettyPrinter.Delaborator.Delab", "name": "«term∯_InT(_,_),_».delab", "isProp": false, "docString": "Pretty printer defined by `notation3` command. ", "terms": "[]"}
{"type": "∀ {α : Type u_1} [inst : SeminormedRing α] [inst_1 : NormOneClass α] (a : α) (n : ℕ), ‖a ^ n‖ ≤ ‖a‖ ^ n", "name": "norm_pow_le", "isProp": true, "docString": "If `α` is a seminormed ring with `‖1‖ = 1`, then `‖a ^ n‖ ≤ ‖a‖ ^ n`. See also `norm_pow_le'`.", "terms": "[\n    \"seminormed ring\", \n    \"norm\", \n    \"power\"\n]"}
{"type": "{M : Type u_1} →\n  [inst : CommMonoid M] →\n    {S : Submonoid M} →\n      {N : Type u_2} →\n        [inst_1 : CommMonoid N] →\n          {P : Type u_3} →\n            [inst_2 : CommMonoid P] →\n              Submonoid.LocalizationMap S N →\n                {g : M →* P} →\n                  {T : Submonoid P} →\n                    (∀ (y : ↥S), g ↑y ∈ T) →\n                      {Q : Type u_4} → [inst : CommMonoid Q] → Submonoid.LocalizationMap T Q → N →* Q", "name": "Submonoid.LocalizationMap.map", "isProp": false, "docString": "Given a `CommMonoid` homomorphism `g : M →* P` where for Submonoids `S ⊆ M, T ⊆ P` we have\n`g(S) ⊆ T`, the induced Monoid homomorphism from the Localization of `M` at `S` to the\nLocalization of `P` at `T`: if `f : M →* N` and `k : P →* Q` are Localization maps for `S` and\n`T` respectively, we send `z : N` to `k (g x) * (k (g y))⁻¹`, where `(x, y) : M × S` are such\nthat `z = f x * (f y)⁻¹`. ", "terms": "[\n    \"CommMonoid\",\n    \"homomorphism\",\n    \"Submonoids\",\n    \"Localization\",\n    \"Monoid\",\n    \"maps\",\n    \"inverse\"\n]"}
{"type": "∀ {G : Type u_6} {H : Type u_7} {F : Type u_8} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), f a⁻¹ = (f a)⁻¹", "name": "map_inv", "isProp": true, "docString": "Group homomorphisms preserve inverse. ", "terms": "[\n    \"Group\",\n    \"Homomorphisms\",\n    \"Preserve\",\n    \"Inverse\"\n]"}
{"type": "(R : Type u_1) →\n  {E : Type u_5} → [inst : Semiring R] → [inst_1 : SeminormedAddCommGroup E] → [inst_2 : Module R E] → E ≃ₗᵢ[R] E", "name": "LinearIsometryEquiv.neg", "isProp": false, "docString": "The negation operation on a normed space `E`, considered as a linear isometry equivalence. ", "terms": "[\n    \"negation operation\", \n    \"normed space\", \n    \"linear isometry\", \n    \"equivalence\"\n]"}
{"type": "∀ {α : Type u_1} [inst : MeasurableSpace α] {s : MeasureTheory.SignedMeasure α} {i j : Set α},\n  MeasurableSet i →\n    MeasurableSet j →\n      MeasureTheory.VectorMeasure.restrict 0 i ≤ MeasureTheory.VectorMeasure.restrict s i ∧\n          MeasureTheory.VectorMeasure.restrict s iᶜ ≤ MeasureTheory.VectorMeasure.restrict 0 iᶜ →\n        MeasureTheory.VectorMeasure.restrict 0 j ≤ MeasureTheory.VectorMeasure.restrict s j ∧\n            MeasureTheory.VectorMeasure.restrict s jᶜ ≤ MeasureTheory.VectorMeasure.restrict 0 jᶜ →\n          ↑s (i ∆ j) = 0 ∧ ↑s (iᶜ ∆ jᶜ) = 0", "name": "MeasureTheory.SignedMeasure.of_symmDiff_compl_positive_negative", "isProp": true, "docString": "The symmetric difference of two Hahn decompositions has measure zero. ", "terms": "[\n  \"Symmetric Difference\",\n  \"Hahn Decompositions\",\n  \"Measure\",\n  \"Zero\"\n]"}
{"type": "∀ {α : Type u_1} {n : Type u_4} {m : Type u_5} [inst : MulZeroClass α] {A : Matrix m m α} {B : Matrix n n α},\n  Matrix.IsDiag A → Matrix.IsDiag B → Matrix.IsDiag (Matrix.kroneckerMap (fun x x_1 => x * x_1) A B)", "name": "Matrix.IsDiag.kronecker", "isProp": true, "docString": "`(A ⊗ B).IsDiag` if both `A` and `B` are diagonal. ", "terms": "[\n    \"Diagonal\",\n    \"Tensor product\"\n]"}
{"type": "{G : Type u_1} → [inst : Group G] → Set G → Subgroup G", "name": "Subgroup.centralizer", "isProp": false, "docString": "The `centralizer` of `H` is the subgroup of `g : G` commuting with every `h : H`. ", "terms": "[\n  \"centralizer\",\n  \"subgroup\",\n  \"commuting\"\n]"}
{"type": "{α : Type u} → ℕ → List α → List (ℕ × α)", "name": "List.enumFrom", "isProp": false, "docString": "`O(|l|)`. `enumFrom n l` is like `enum` but it allows you to specify the initial index.\n* `enumFrom 5 [a, b, c] = [(5, a), (6, b), (7, c)]`\n", "terms": "[\"O\", \"enumFrom\", \"enum\", \"initial index\"]"}
{"type": "{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {C : Type u} →\n      [inst_1 : CategoryTheory.Category.{v, u} C] →\n        (F : CategoryTheory.Functor J C) →\n          [inst_2 : CategoryTheory.Limits.HasLimit F] → CategoryTheory.Limits.LimitCone F", "name": "CategoryTheory.Limits.getLimitCone", "isProp": false, "docString": "Use the axiom of choice to extract explicit `LimitCone F` from `HasLimit F`. ", "terms": "[\n    \"axiom of choice\",\n    \"LimitCone\",\n    \"HasLimit\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] → C → CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{w + 1}) C", "name": "CategoryTheory.Functor.fromPUnit", "isProp": false, "docString": "The functor from `Discrete PUnit` sending everything to the given object. ", "terms": "[\n    \"functor\",\n    \"Discrete PUnit\",\n    \"object\"\n]"}
{"type": "System.FilePath → (optParam (System.FilePath → IO Bool) fun x => pure true) → IO (Array System.FilePath)", "name": "System.FilePath.walkDir", "isProp": false, "docString": "Return all filesystem entries of a preorder traversal of all directories satisfying `enter`, starting at `p`.\nSymbolic links are visited as well by default. ", "terms": "[]"}
{"type": "{α : Type u} → [inst : Mul α] → {β : Type v} → [inst_1 : Semigroup β] → (α →ₙ* β) ≃ (Magma.AssocQuotient α →ₙ* β)", "name": "Magma.AssocQuotient.lift", "isProp": false, "docString": "Lifts a magma homomorphism `α → β` to a semigroup homomorphism `Magma.AssocQuotient α → β`\ngiven a semigroup `β`. ", "terms": "[\n    \"Lifts\",\n    \"magma homomorphism\",\n    \"semigroup homomorphism\",\n    \"Magma.AssocQuotient\",\n    \"semigroup\"\n]"}
{"type": "{R₁ : Type u_1} →\n  {R₂ : Type u_2} →\n    [inst : Semiring R₁] →\n      [inst_1 : Semiring R₂] →\n        {σ₁₂ : R₁ →+* R₂} →\n          {σ₂₁ : R₂ →+* R₁} →\n            [inst_2 : RingHomInvPair σ₁₂ σ₂₁] →\n              [inst_3 : RingHomInvPair σ₂₁ σ₁₂] →\n                {M₁ : Type u_4} →\n                  [inst_4 : TopologicalSpace M₁] →\n                    [inst_5 : AddCommMonoid M₁] →\n                      {M₂ : Type u_6} →\n                        [inst_6 : TopologicalSpace M₂] →\n                          [inst_7 : AddCommMonoid M₂] →\n                            [inst_8 : Module R₁ M₁] → [inst_9 : Module R₂ M₂] → (M₁ ≃SL[σ₁₂] M₂) → M₁ →SL[σ₁₂] M₂", "name": "ContinuousLinearEquiv.toContinuousLinearMap", "isProp": false, "docString": "A continuous linear equivalence induces a continuous linear map. ", "terms": "[\n  \"continuous\",\n  \"linear equivalence\",\n  \"induces\",\n  \"continuous linear map\"\n]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      {S₁ S₂ : CategoryTheory.ShortComplex C} →\n        (φ : S₁ ⟶ S₂) →\n          CategoryTheory.ShortComplex.LeftHomologyData S₂ →\n            [inst_2 : CategoryTheory.Epi φ.τ₁] →\n              [inst_3 : CategoryTheory.IsIso φ.τ₂] →\n                [inst_4 : CategoryTheory.Mono φ.τ₃] → CategoryTheory.ShortComplex.LeftHomologyData S₁", "name": "CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono'", "isProp": false, "docString": "If `φ : S₁ ⟶ S₂` is a morphism of short complexes such that `φ.τ₁` is epi, `φ.τ₂` is an iso\nand `φ.τ₃` is mono, then a left homology data for `S₂` induces a left homology data for `S₁` with\nthe same `K` and `H` fields. The inverse construction is `ofEpiOfIsIsoOfMono`. ", "terms": "[\n    \"morphism\",\n    \"short complexes\",\n    \"epi\",\n    \"iso\",\n    \"mono\",\n    \"left homology data\",\n    \"fields\",\n    \"inverse construction\"\n]"}
{"type": "{α : Type u_1} → [inst : DecidableEq α] → (s : Cycle α) → Cycle.Nodup s → (x : α) → x ∈ s → α", "name": "Cycle.prev", "isProp": false, "docString": "Given a `s : Cycle α` such that `Nodup s`, retrieve the previous element before `x ∈ s`. ", "terms": "[\n  \"Cycle\",\n  \"Nodup\",\n  \"element\",\n  \"previous\",\n  \"retrieve\"\n]"}
{"type": "∀ {Y : Type u_1} [inst : TopologicalSpace Y],\n  SimplyConnectedSpace Y ↔ PathConnectedSpace Y ∧ ∀ (x y : Y), Subsingleton (Path.Homotopic.Quotient x y)", "name": "simply_connected_iff_paths_homotopic", "isProp": true, "docString": "A space is simply connected iff it is path connected, and there is at most one path\nup to homotopy between any two points. ", "terms": "[\n    \"space\",\n    \"simply connected\",\n    \"iff\",\n    \"path connected\",\n    \"at most\",\n    \"one\",\n    \"path\",\n    \"up to\",\n    \"homotopy\",\n    \"any\",\n    \"two\",\n    \"points\"\n]"}
{"type": "{A : Type u} →\n  [inst : CategoryTheory.Category.{v, u} A] →\n    [inst_1 : CategoryTheory.Abelian A] →\n      {X Y Z : A} →\n        (f : X ⟶ Y) →\n          (g : Y ⟶ Z) →\n            (w : CategoryTheory.CategoryStruct.comp f g = 0) → homology' f g w ⟶ CategoryTheory.Limits.cokernel f", "name": "homology'.ι", "isProp": false, "docString": "The canonical map from the homology of `f` and `g` to the cokernel of `f`. ", "terms": "[\n  \"canonical map\", \n  \"homology\", \n  \"cokernel\"\n]"}
{"type": "{α : Type u} → CompleteLattice (TopologicalSpace α)", "name": "TopologicalSpace.instCompleteLatticeTopologicalSpace", "isProp": false, "docString": "Topologies on `α` form a complete lattice, with `⊥` the discrete topology\nand `⊤` the indiscrete topology. The infimum of a collection of topologies\nis the topology generated by all their open sets, while the supremum is the\ntopology whose open sets are those sets open in every member of the collection. ", "terms": "[\n    \"Topologies\",\n    \"complete lattice\",\n    \"discrete topology\",\n    \"indiscrete topology\",\n    \"infimum\",\n    \"collection\",\n    \"topology\",\n    \"generated\",\n    \"open sets\",\n    \"supremum\",\n    \"sets\",\n    \"open\",\n    \"member\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {s : Set α},\n  MonotoneOn f s → AntitoneOn (f ∘ ⇑OrderDual.ofDual) s", "name": "MonotoneOn.dual_left", "isProp": true, "docString": "**Alias** of the reverse direction of `antitoneOn_comp_ofDual_iff`.", "terms": "[\n\"Alias\",\n\"reverse direction\",\n\"antitoneOn_comp_ofDual_iff\"\n]"}
{"type": "∀ {μ : YoungDiagram} (self : Ssyt μ) {i j : ℕ}, (i, j) ∉ μ → Ssyt.entry self i j = 0", "name": "Ssyt.zeros'", "isProp": true, "docString": "`entry` is required to be zero for all pairs `(i, j) ∉ μ`. ", "terms": "[\n    \"entry\", \n    \"zero\", \n    \"pairs\", \n    \"∉\", \n    \"μ\"\n]"}
{"type": "{X Y U : AlgebraicGeometry.Scheme} →\n  (f : X ⟶ Y) →\n    (g : U ⟶ Y) →\n      [hg : AlgebraicGeometry.IsOpenImmersion g] →\n        CategoryTheory.Arrow.mk (f ∣_ AlgebraicGeometry.Scheme.Hom.opensRange g) ≅\n          CategoryTheory.Arrow.mk CategoryTheory.Limits.pullback.snd", "name": "AlgebraicGeometry.morphismRestrictOpensRange", "isProp": false, "docString": "Restricting a morphism onto the image of an open immersion is isomorphic to the base change\nalong the immersion. ", "terms": "[\n    \"Restricting\",\n    \"morphism\",\n    \"image\",\n    \"open immersion\",\n    \"isomorphic\",\n    \"base change\",\n    \"immersion\"\n]"}
{"type": "{ι : Type u_1} →\n  {ι' : Type u_2} →\n    {R : Type u_5} →\n      {M : Type u_6} →\n        [inst : CommSemiring R] →\n          [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → Basis ι R M → (ι' → M) → Matrix ι ι' R", "name": "Basis.toMatrix", "isProp": false, "docString": "From a basis `e : ι → M` and a family of vectors `v : ι' → M`, make the matrix whose columns\nare the vectors `v i` written in the basis `e`. ", "terms": "[\n    \"basis\",\n    \"family of vectors\",\n    \"matrix\",\n    \"columns\",\n    \"vectors\"\n]"}
{"type": "Lean.ParserDescr", "name": "Mathlib.Util.«commandCompile_def%_»", "isProp": false, "docString": "`compile_def% Foo.foo` adds compiled code for the definition `Foo.foo`.\nThis can be used for type class projections or definitions like `List._sizeOf_1`,\nfor which Lean does not generate compiled code by default\n(since it is not used 99% of the time).\n", "terms": "[]\n"}
{"type": "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  (f : BoundedContinuousFunction X ℝ) {a b : ℝ} {e : X → Y},\n  (∀ (x : X), f x ∈ Set.Icc a b) → a ≤ b → ClosedEmbedding e → ∃ g, (∀ (y : Y), g y ∈ Set.Icc a b) ∧ ⇑g ∘ e = ⇑f", "name": "BoundedContinuousFunction.exists_extension_forall_mem_Icc_of_closedEmbedding", "isProp": true, "docString": "**Tietze extension theorem** for real-valued bounded continuous maps, a version for a closed\nembedding and a bounded continuous function that takes values in a non-trivial closed interval.\nSee also `exists_extension_forall_mem_of_closedEmbedding` for a more general statement that works\nfor any interval (finite or infinite, open or closed).\n\nIf `e : X → Y` is a closed embedding and `f : X →ᵇ ℝ` is a bounded continuous function such that\n`f x ∈ [a, b]` for all `x`, where `a ≤ b`, then there exists a bounded continuous function\n`g : Y →ᵇ ℝ` such that `g y ∈ [a, b]` for all `y` and `g ∘ e = f`. ", "terms": "[\n    \"Tietze extension theorem\",\n    \"real-valued\",\n    \"bounded\",\n    \"continuous maps\",\n    \"closed embedding\",\n    \"bounded continuous function\",\n    \"non-trivial closed interval\",\n    \"exists_extension_forall_mem_of_closedEmbedding\",\n    \"interval\",\n    \"finite\",\n    \"infinite\",\n    \"open\",\n    \"closed\",\n    \"embedding\",\n    \"function\",\n    \"continuous function\",\n    \"exists\",\n    \"composition\"\n]"}
{"type": "{α : Type u_2} →\n  {G : Type u_4} →\n    [inst : TopologicalSpace α] →\n      [inst_1 : AddGroup G] → [inst_2 : AddAction G α] → [inst_3 : ContinuousConstVAdd G α] → G → α ≃ₜ α", "name": "Homeomorph.vadd", "isProp": false, "docString": "The homeomorphism given by affine-addition by an element of an additive group `Γ` acting on\n`T` is a homeomorphism from `T` to itself. ", "terms": "[\n    \"homeomorphism\",\n    \"affine-addition\",\n    \"element\",\n    \"additive group\",\n    \"acting\",\n    \"to itself\"\n]"}
{"type": "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {E' : Type u_3} [inst_3 : NormedAddCommGroup E'] [inst_4 : NormedSpace 𝕜 E'] {f : E → E'},\n  MDifferentiable (modelWithCornersSelf 𝕜 E) (modelWithCornersSelf 𝕜 E') f → Differentiable 𝕜 f", "name": "MDifferentiable.differentiable", "isProp": true, "docString": "**Alias** of the forward direction of `mdifferentiable_iff_differentiable`.\n\n---\n\nFor maps between vector spaces, `MDifferentiable` and `Differentiable` coincide ", "terms": "[\"Alias\", \"forward direction\", \"mdifferentiable_iff_differentiable\", \"maps\", \"vector spaces\", \"MDifferentiable\", \"Differentiable\", \"coincide\"]"}
{"type": "∀ {p : Prop}, (¬p → False) → p", "name": "Classical.by_contradiction", "isProp": true, "docString": "**Alias** of `Classical.byContradiction`.", "terms": "[]"}
{"type": "(k : Type u) → [inst : Field k] → Type u", "name": "AlgebraicClosure.MonicIrreducible", "isProp": false, "docString": "The subtype of monic irreducible polynomials ", "terms": "[\n  \"Subtype\",\n  \"Monic\",\n  \"Irreducible\",\n  \"Polynomials\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : CompleteSpace E] {A : E →L[𝕜] E}, IsSelfAdjoint A → LinearMap.IsSymmetric ↑A", "name": "IsSelfAdjoint.isSymmetric", "isProp": true, "docString": "Every self-adjoint operator on an inner product space is symmetric. ", "terms": "[\n  \"self-adjoint operator\", \n  \"inner product space\", \n  \"symmetric\"\n]"}
{"type": "Type ((max u1 u2) + 1)", "name": "CommRingCatMax", "isProp": false, "docString": "An alias for `CommRingCat.{max u v}`, to deal around unification issues. ", "terms": "[\"alias\", \"CommRingCat\", \"max\", \"unification issues\"]"}
{"type": "{R : Type u_3} → [inst : CommRing R] → (c₁ c₂ : R) → Basis (Fin 4) R (QuaternionAlgebra R c₁ c₂)", "name": "QuaternionAlgebra.basisOneIJK", "isProp": false, "docString": "`ℍ[R, c₁, c₂]` has a basis over `R` given by `1`, `i`, `j`, and `k`. ", "terms": "[\"ℍ[R, c₁, c₂]\", \"basis\", \"over\", \"R\", \"1\", \"i\", \"j\", \"k\"]"}
{"type": "Substring → String.Pos → String.Pos", "name": "Substring.next", "isProp": false, "docString": "Given an offset of a codepoint into the substring,\nreturn the offset there of the next codepoint. ", "terms": "[]\n"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] (G : CategoryTheory.Comonad C)\n  {A B : CategoryTheory.Comonad.Coalgebra G} (f : A ⟶ B) [inst_1 : CategoryTheory.IsIso f.f], CategoryTheory.IsIso f", "name": "CategoryTheory.Comonad.coalgebra_iso_of_iso", "isProp": true, "docString": "Given a coalgebra morphism whose carrier part is an isomorphism, we get a coalgebra isomorphism.\n", "terms": "[\n    \"coalgebra morphism\",\n    \"carrier part\",\n    \"isomorphism\",\n    \"coalgebra isomorphism\"\n]"}
{"type": "(R : Type u_1) →\n  {B : Type u_2} →\n    {F : Type u_3} →\n      {E : B → Type u_4} →\n        [inst : Semiring R] →\n          [inst_1 : TopologicalSpace F] →\n            [inst_2 : TopologicalSpace B] →\n              [inst_3 : AddCommMonoid F] →\n                [inst_4 : Module R F] →\n                  [inst_5 : (x : B) → AddCommMonoid (E x)] →\n                    [inst_6 : (x : B) → Module R (E x)] →\n                      (e : Pretrivialization F Bundle.TotalSpace.proj) →\n                        [inst_7 : Pretrivialization.IsLinear R e] → (b : B) → F →ₗ[R] E b", "name": "Pretrivialization.symmₗ", "isProp": false, "docString": "A fiberwise linear inverse to `e`. ", "terms": "[\n    \"fiberwise\",\n    \"linear\",\n    \"inverse\"\n]"}
{"type": "∀ (k : Type u_1) [inst : DivisionRing k] {ι : Type u_4} (s : Finset ι) [inst_1 : CharZero k] [inst_2 : Fintype ι]\n  {n : ℕ}, Finset.card s = n + 1 → (Finset.sum Finset.univ fun i => Finset.centroidWeightsIndicator k s i) = 1", "name": "Finset.sum_centroidWeightsIndicator_eq_one_of_card_eq_add_one", "isProp": true, "docString": "In the characteristic zero case, the weights in the centroid\nindexed by a `Fintype` sum to 1 if the number of points is `n + 1`. ", "terms": "[\n    \"characteristic zero\",\n    \"weights\",\n    \"centroid\",\n    \"Fintype\",\n    \"sum\",\n    \"number of points\"\n]"}
{"type": "(M : Type w) →\n  [inst : AddCommGroup M] →\n    {R : Type u_1} →\n      {L : Type u_2} →\n        [inst_1 : CommRing R] →\n          [inst_2 : LieRing L] →\n            [inst_3 : LieAlgebra R L] → (I : LieIdeal R L) → [inst_4 : LieRingModule L M] → LieRingModule (↥↑I) M", "name": "LieIdeal.lieRingModule", "isProp": false, "docString": "Transfer the `LieRingModule` instance from the coercion `LieIdeal → LieSubalgebra`. ", "terms": "[\n  \"Transfer\",\n  \"LieRingModule\",\n  \"instance\",\n  \"coercion\",\n  \"LieIdeal\",\n  \"LieSubalgebra\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (e : PartialHomeomorph α β),\n  e.source = Set.univ → OpenEmbedding ↑e", "name": "PartialHomeomorph.to_openEmbedding", "isProp": true, "docString": "A partial homeomorphism whose source is all of `α` defines an open embedding of `α` into `β`.\nThe converse is also true; see `OpenEmbedding.toPartialHomeomorph`. ", "terms": "[\n    \"Partial Homeomorphism\",\n    \"Source\",\n    \"Defines\",\n    \"Open Embedding\",\n    \"Into\",\n    \"Converse\",\n    \"True\",\n    \"See\"\n]"}
{"type": "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] → (f : M →+ N) → (∀ (x y : M), AddCommute (f x) (f y)) → Mᵃᵒᵖ →+ N", "name": "AddMonoidHom.fromOpposite", "isProp": false, "docString": "An additive monoid homomorphism `f : M →+ N` such that `f x` additively commutes\nwith `f y` for all `x`, `y` defines an additive monoid homomorphism from `Mᵃᵒᵖ`.", "terms": "[\n    \"additive monoid\",\n    \"homomorphism\",\n    \"commutes\",\n    \"additively\"\n]"}
{"type": "∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 → q ≠ 2 → legendreSym q ↑p = legendreSym p ↑q", "name": "legendreSym.quadratic_reciprocity_one_mod_four", "isProp": true, "docString": "The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. ", "terms": "[\n    \"Law of Quadratic Reciprocity\",\n    \"odd\",\n    \"primes\",\n    \"modulus\",\n    \"equation\"\n]"}
{"type": "{C : Type u} → [inst : CategoryTheory.Category.{v, u} C] → {X : C} → Monoid (CategoryTheory.End X)", "name": "CategoryTheory.End.monoid", "isProp": false, "docString": "Endomorphisms of an object form a monoid ", "terms": "[\n    \"Endomorphisms\",\n    \"object\",\n    \"form\",\n    \"monoid\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {A : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} A] →\n        {U : C} →\n          (R : CategoryTheory.Presieve U) →\n            (P : CategoryTheory.Functor Cᵒᵖ A) →\n              [inst_2 : CategoryTheory.Limits.HasProducts A] →\n                P.obj (Opposite.op U) ⟶ CategoryTheory.Presheaf.firstObj R P", "name": "CategoryTheory.Presheaf.forkMap", "isProp": false, "docString": "The left morphism of the fork diagram given in Equation (3) of [MM92], as well as the fork diagram\nof <https://stacks.math.columbia.edu/tag/00VM>.\n", "terms": "[\"left morphism\", \"fork diagram\", \"Equation\"]"}
{"type": "∀ {X : Type u_2} [inst : EMetricSpace X] {s : Set X}, Set.Subsingleton s → dimH s = 0", "name": "Set.Subsingleton.dimH_zero", "isProp": true, "docString": "**Alias** of `dimH_subsingleton`.", "terms": "[]\n"}
{"type": "{B : Type u} → [inst : Quiver B] → {a b : B} → Quiver.Path a b → CategoryTheory.FreeBicategory.Hom a b", "name": "CategoryTheory.FreeBicategory.inclusionPathAux", "isProp": false, "docString": "Auxiliary definition for `inclusionPath`. ", "terms": "[]"}
{"type": "{R : Type u} →\n  [inst : Ring R] →\n    {V W : Type u} →\n      [inst_1 : AddCommGroup V] →\n        [inst_2 : Module R V] →\n          [inst_3 : Module.Finite R V] →\n            [inst_4 : AddCommGroup W] →\n              [inst_5 : Module R W] →\n                [inst_6 : Module.Finite R W] → (V ≃ₗ[R] W) → (FGModuleCat.of R V ≅ FGModuleCat.of R W)", "name": "LinearEquiv.toFGModuleCatIso", "isProp": false, "docString": "Converts a `LinearEquiv` to an isomorphism in the category `FGModuleCat R`. ", "terms": "[\n    \"LinearEquiv\",\n    \"Isomorphism\",\n    \"Category\",\n    \"FGModuleCat\",\n    \"R\"\n]"}
{"type": "{α : Type u_1} →\n  {A : Type u_5} →\n    [inst : AddMonoid A] → [inst_1 : Monoid α] → [inst_2 : DistribMulAction α A] → MulAction α (AddSubmonoid A)", "name": "AddSubmonoid.pointwiseMulAction", "isProp": false, "docString": "The action on an additive submonoid corresponding to applying the action to every element.\n\nThis is available as an instance in the `Pointwise` locale. ", "terms": "[\n    \"action\",\n    \"additive\",\n    \"submonoid\",\n    \"applying\",\n    \"element\",\n    \"instance\",\n    \"Pointwise\",\n    \"locale\"\n]"}
{"type": "(α : Type u_2) →\n  (β : Type u_3) → [inst : LinearOrderedField α] → [inst : ConditionallyCompleteLinearOrderedField β] → α → β", "name": "LinearOrderedField.inducedMap", "isProp": false, "docString": "The induced order preserving function from a linear ordered field to a conditionally complete\nlinear ordered field, defined by taking the Sup in the codomain of all the rationals less than the\ninput. ", "terms": "[\n    \"induced\",\n    \"order preserving function\",\n    \"linear ordered field\",\n    \"conditionally complete linear ordered field\",\n    \"Sup\",\n    \"codomain\",\n    \"rationals\",\n    \"input\"\n]"}
{"type": "{C : Type u₁} → [inst : CategoryTheory.Category.{v₁, u₁} C] → CategoryTheory.Category.{v₁, u₁} Cᵒᵖ", "name": "CategoryTheory.Category.opposite", "isProp": false, "docString": "The opposite category.\n\nSee <https://stacks.math.columbia.edu/tag/001M>.\n", "terms": "[\"opposite category\"]"}
{"type": "{𝕆 : Type u_1} →\n  {ℙ : Type u_2} →\n    {α : Type u_3} →\n      [inst : Preorder 𝕆] →\n        [inst_1 : Preorder ℙ] →\n          [inst_2 : Preorder α] →\n            [inst_3 : GradeMinOrder 𝕆 α] →\n              (f : 𝕆 → ℙ) →\n                StrictMono f → (∀ (a b : 𝕆), a ⋖ b → f a ⋖ f b) → (∀ (a : 𝕆), IsMin a → IsMin (f a)) → GradeMinOrder ℙ α", "name": "GradeMinOrder.liftLeft", "isProp": false, "docString": "Lifts a graded order along a strictly monotone function. ", "terms": "[\n    \"Lifts\", \n    \"graded order\", \n    \"strictly monotone function\"\n]"}
{"type": "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : TopologicalSpace α] → [inst_1 : TopologicalSpace β] → PartialHomeomorph α β → PartialHomeomorph β α", "name": "PartialHomeomorph.symm", "isProp": false, "docString": "The inverse of a partial homeomorphism ", "terms": "[\n  \"Inverse\",\n  \"Partial\",\n  \"Homeomorphism\"\n]"}
{"type": "∀ {p : ℕ} [hp : Fact (Nat.Prime p)] (z : ℤ), padicNorm p ↑z ≤ 1", "name": "padicNorm.of_int", "isProp": true, "docString": "The `p`-adic norm of an integer is at most `1`. ", "terms": "[\n    \"p-adic norm\",\n    \"integer\",\n    \"at most\",\n    \"1\"\n]"}
{"type": "{R : Type u_1} →\n  [inst : Semiring R] →\n    {S : Submonoid R} →\n      [inst_1 : OreLocalization.OreSet S] →\n        (r r' : R) →\n          (s s' : ↥S) →\n            (r'' : R) ×' (s'' : ↥S) ×' ↑s * ↑s'' = ↑s' * r'' ∧ r /ₒ s + r' /ₒ s' = (r * ↑s'' + r' * r'') /ₒ (s * s'')", "name": "OreLocalization.oreDivAddChar'", "isProp": false, "docString": "Another characterization of the addition on the Ore localization, bundling up all witnesses\nand conditions into a sigma type. ", "terms": "[\n    \"Characterization\",\n    \"Addition\",\n    \"Ore localization\",\n    \"Bundling up\",\n    \"Witnesses\",\n    \"Conditions\",\n    \"Sigma type\"\n]"}
{"type": "{α : Type u_1} → Ordnode α → α → Ordnode α → Ordnode α", "name": "Ordnode.node'", "isProp": false, "docString": "**Internal use only**\n\nO(1). Construct a node with the correct size information, without rebalancing. ", "terms": "[\"O(1)\", \"node\", \"size information\", \"rebalancing\"]"}
{"type": "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsTotallySeparated s → IsTotallyDisconnected s", "name": "IsTotallySeparated.isTotallyDisconnected", "isProp": true, "docString": "**Alias** of `isTotallyDisconnected_of_isTotallySeparated`.", "terms": "The mathematical terms in the given statement are \"Alias\", \"isTotallyDisconnected\", and \"isTotallySeparated\". Here is the JSON list of these terms:\n\n```json\n[\n    \"Alias\",\n    \"isTotallyDisconnected\",\n    \"isTotallySeparated\"\n]\n```"}
{"type": "(R : Type u_1) →\n  (A : Type u_2) →\n    (B : Type u_3) →\n      [inst : CommSemiring R] →\n        [inst_1 : Semiring A] →\n          [inst_2 : Algebra R A] →\n            [inst_3 : Star A] → [inst_4 : Semiring B] → [inst_5 : Algebra R B] → [inst_6 : Star B] → A × B →⋆ₐ[R] B", "name": "StarAlgHom.snd", "isProp": false, "docString": "The second projection of a product is a ⋆-algebra homomorphism. ", "terms": "[\n  \"second projection\",\n  \"product\",\n  \"⋆-algebra\",\n  \"homomorphism\"\n]"}
{"type": "{C₁ : Type u₁} →\n  {C₂ : Type u₂} →\n    {C₃ : Type u₃} →\n      {E : Type u₄} →\n        [inst : CategoryTheory.Category.{v₁, u₁} C₁] →\n          [inst_1 : CategoryTheory.Category.{v₂, u₂} C₂] →\n            [inst_2 : CategoryTheory.Category.{v₃, u₃} C₃] →\n              [inst_3 : CategoryTheory.Category.{v₄, u₄} E] →\n                {L₁ : CategoryTheory.Functor C₁ C₂} →\n                  {L₂ : CategoryTheory.Functor C₂ C₃} →\n                    {W₁ : CategoryTheory.MorphismProperty C₁} →\n                      {W₂ : CategoryTheory.MorphismProperty C₂} →\n                        CategoryTheory.Localization.StrictUniversalPropertyFixedTarget L₁ W₁ E →\n                          CategoryTheory.Localization.StrictUniversalPropertyFixedTarget L₂ W₂ E →\n                            (W₃ : CategoryTheory.MorphismProperty C₁) →\n                              CategoryTheory.MorphismProperty.IsInvertedBy W₃ (CategoryTheory.Functor.comp L₁ L₂) →\n                                W₁ ⊆ W₃ →\n                                  W₂ ⊆ CategoryTheory.MorphismProperty.map W₃ L₁ →\n                                    CategoryTheory.Localization.StrictUniversalPropertyFixedTarget\n                                      (CategoryTheory.Functor.comp L₁ L₂) W₃ E", "name": "CategoryTheory.Localization.StrictUniversalPropertyFixedTarget.comp", "isProp": false, "docString": "Under some conditions on the `MorphismProperty`, functors satisfying the strict\nuniversal property of the localization are stable under composition ", "terms": "[\n    \"MorphismProperty\",\n    \"functors\",\n    \"strict universal property\",\n    \"localization\",\n    \"stable\",\n    \"composition\"\n]"}
{"type": "Lean.ParserDescr", "name": "Mathlib.Explode.«command#explode_»", "isProp": false, "docString": "`#explode expr` displays a proof term in a line-by-line format somewhat akin to a Fitch-style\nproof or the Metamath proof style.\n\nFor example, exploding the following theorem:\n\n```lean\n#explode iff_of_true\n```\n\nproduces:\n\n```lean\niff_of_true : ∀ {a b : Prop}, a → b → (a ↔ b)\n\n0│         │ a         ├ Prop\n1│         │ b         ├ Prop\n2│         │ ha        ├ a\n3│         │ hb        ├ b\n4│         │ x✝        │ ┌ a\n5│4,3      │ ∀I        │ a → b\n6│         │ x✝        │ ┌ b\n7│6,2      │ ∀I        │ b → a\n8│5,7      │ Iff.intro │ a ↔ b\n9│0,1,2,3,8│ ∀I        │ ∀ {a b : Prop}, a → b → (a ↔ b)\n```\n\n## Overview\n\nThe `#explode` command takes the body of the theorem and decomposes it into its parts,\ndisplaying each expression constructor one at a time. The constructor is indicated\nin some way in column 3, and its dependencies are recorded in column 2.\n\nThese are the main constructor types:\n\n  - Lambda expressions (`Expr.lam`). The expression `fun (h : p) => s` is displayed as\n    ```lean\n     0│    │ h   │ ┌ p\n     1│**  │ **  │ │ q\n     2│1,2 │ ∀I  │ ∀ (h : p), q\n    ```\n    with `**` a wildcard, and there can be intervening steps between 0 and 1.\n    Nested lambda expressions can be merged, and `∀I` can depend on a whole list of arguments.\n\n  - Applications (`Expr.app`). The expression `f a b c` is displayed as\n     ```lean\n     0│**      │ f  │ A → B → C → D\n     1│**      │ a  │ A\n     2│**      │ b  │ B\n     3│**      │ c  │ C\n     1│0,1,2,3 │ ∀E │ D\n     ```\n     There can be intervening steps between each of these.\n     As a special case, if `f` is a constant it can be omitted and the display instead looks like\n     ```lean\n     0│**    │ a │ A\n     1│**    │ b │ B\n     2│**    │ c │ C\n     3│1,2,3 │ f │ D\n     ```\n\n  - Let expressions (`Expr.letE`) do not display in any special way, but they do\n    ensure that in `let x := v; b` that `v` is processed first and then `b`, rather\n    than first doing zeta reduction. This keeps lambda merging and application merging\n    from making proofs with `let` confusing to interpret.\n\n  - Everything else (constants, fvars, etc.) display `x : X` as\n    ```lean\n    0│  │ x │ X\n    ```\n\n## In more detail\n\nThe output of `#explode` is a Fitch-style proof in a four-column diagram modeled after Metamath\nproof displays like [this](http://us.metamath.org/mpeuni/ru.html). The headers of the columns are\n\"Step\", \"Hyp\", \"Ref\", \"Type\" (or \"Expression\" in the case of Metamath):\n* **Step**: An increasing sequence of numbers for each row in the proof, used in the Hyp fields.\n* **Hyp**: The direct children of the current step. These are step numbers for the subexpressions\n  for this step's expression. For theorem applications, it's the theorem arguments, and for\n  foralls it is all the bound variables and the conclusion.\n* **Ref**: The name of the theorem being applied. This is well-defined in Metamath, but in Lean\n  there are some special steps that may have long names because the structure of proof terms doesn't\n  exactly match this mold.\n  * If the theorem is `foo (x y : Z) : A x -> B y -> C x y`:\n    * the Ref field will contain `foo`,\n    * `x` and `y` will be suppressed, because term construction is not interesting, and\n    * the Hyp field will reference steps proving `A x` and `B y`. This corresponds to a proof term\n      like `@foo x y pA pB` where `pA` and `pB` are subproofs.\n    * In the Hyp column, suppressed terms are omitted, including terms that ought to be\n      suppressed but are not (in particular lambda arguments).\n      TODO: implement a configuration option to enable representing suppressed terms using\n      an `_` rather than a step number.\n  * If the head of the proof term is a local constant or lambda, then in this case the Ref will\n    say `∀E` for forall-elimination. This happens when you have for example `h : A -> B` and\n    `ha : A` and prove `b` by `h ha`; we reinterpret this as if it said `∀E h ha` where `∀E` is\n    (n-ary) modus ponens.\n  * If the proof term is a lambda, we will also use `∀I` for forall-introduction, referencing the\n    body of the lambda. The indentation level will increase, and a bracket will surround the proof\n    of the body of the lambda, starting at a proof step labeled with the name of the lambda variable\n    and its type, and ending with the `∀I` step. Metamath doesn't have steps like this, but the\n    style is based on Fitch proofs in first-order logic.\n* **Type**: This contains the type of the proof term, the theorem being proven at the current step.\n\nAlso, it is common for a Lean theorem to begin with a sequence of lambdas introducing local\nconstants of the theorem. In order to minimize the indentation level, the `∀I` steps at the end of\nthe proof will be introduced in a group and the indentation will stay fixed. (The indentation\nbrackets are only needed in order to delimit the scope of assumptions, and these assumptions\nhave global scope anyway so detailed tracking is not necessary.)\n", "terms": "[\n    \"proof term\",\n    \"Fitch-style proof\",\n    \"Metamath proof style\",\n    \"theorem\",\n    \"expr\",\n    \"Prop\",\n    \"expression constructor\",\n    \"constructor\",\n    \"Lambda expressions\",\n    \"Expr.lam\",\n    \"expression\",\n    \"fun\",\n    \"Nested lambda expressions\",\n    \"Applications\",\n    \"Expr.app\",\n    \"constant\",\n    \"Let expressions\",\n    \"Expr.letE\",\n    \"let\",\n    \"zeta reduction\",\n    \"lambda merging\",\n    \"application merging\",\n    \"proofs\",\n    \"constants\",\n    \"fvars\",\n    \"Fitch-style proof\",\n    \"four-column diagram\",\n    \"Metamath proof\",\n    \"Step\",\n    \"Hyp\",\n    \"Ref\",\n    \"Type\",\n    \"Expression\",\n    \"sequence of numbers\",\n    \"row\",\n    \"proof\",\n    \"step numbers\",\n    \"subexpressions\",\n    \"theorem applications\",\n    \"theorem arguments\",\n    \"foralls\",\n    \"bound variables\",\n    \"conclusion\",\n    \"theorem\",\n    \"structure of proof terms\",\n    \"proof term\",\n    \"local constant\",\n    \"lambda\",\n    \"forall-elimination\",\n    \"modus ponens\",\n    \"forall-introduction\",\n    \"bracket\",\n    \"first-order logic\",\n    \"type of the proof term\",\n    \"sequence of lambdas\",\n    \"local constants\",\n    \"indentation\",\n    \"assumptions\",\n    \"global scope\"\n]"}
{"type": "∀ {R₁ : Type u_1} [inst : Semiring R₁] {M₁ : Type u_4} [inst_1 : TopologicalSpace M₁] [inst_2 : AddCommMonoid M₁]\n  [inst_3 : Module R₁ M₁] [inst_4 : ContinuousAdd M₁], FaithfulSMul (M₁ →L[R₁] M₁) M₁", "name": "ContinuousLinearMap.applyFaithfulSMul", "isProp": true, "docString": "`ContinuousLinearMap.applyModule` is faithful. ", "terms": "[\"ContinuousLinearMap\", \"applyModule\", \"faithful\"]"}
{"type": "∀ {ι : Type u_1} {E : Type u_3} [inst : SeminormedAddCommGroup E] {f : ι → E} {g : ι → ℝ} {a : ℝ},\n  HasSum g a → (∀ (i : ι), ‖f i‖ ≤ g i) → ‖∑' (i : ι), f i‖ ≤ a", "name": "tsum_of_norm_bounded", "isProp": true, "docString": "Quantitative result associated to the direct comparison test for series:  If `∑' i, g i` is\nsummable, and for all `i`, `‖f i‖ ≤ g i`, then `‖∑' i, f i‖ ≤ ∑' i, g i`. Note that we do not\nassume that `∑' i, f i` is summable, and it might not be the case if `α` is not a complete space. ", "terms": "[\n    \"Quantitative result\",\n    \"direct comparison test\",\n    \"series\",\n    \"summable\",\n    \"for all\",\n    \"≤\",\n    \"complete space\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      {K L : CochainComplex C ℤ} →\n        {φ₁ φ₂ : K ⟶ L} →\n          Homotopy φ₁ φ₂ →\n            (n : ℤ) →\n              Homotopy ((CategoryTheory.shiftFunctor (HomologicalComplex C (ComplexShape.up ℤ)) n).map φ₁)\n                ((CategoryTheory.shiftFunctor (HomologicalComplex C (ComplexShape.up ℤ)) n).map φ₂)", "name": "Homotopy.shift", "isProp": false, "docString": "If `h : Homotopy φ₁ φ₂` and `n : ℤ`, this is the induced homotopy\nbetween `φ₁⟦n⟧'` and `φ₂⟦n⟧'`. ", "terms": "[\n    \"Homotopy\",\n    \"ℤ\",\n    \"induced homotopy\"\n]"}
{"type": "{M : Type u_3} → [inst : AddCommMonoid M] → AddSubmonoid M ≃o Submodule ℕ M", "name": "AddSubmonoid.toNatSubmodule", "isProp": false, "docString": "An additive submonoid is equivalent to a ℕ-submodule. ", "terms": "[\n    \"additive submonoid\",\n    \"equivalent\",\n    \"ℕ-submodule\"\n]"}
{"type": "∀ {α : Type u_1} {l : List α}, l ≠ [] → 0 < List.length l", "name": "List.length_pos_of_ne_nil", "isProp": true, "docString": "**Alias** of the reverse direction of `List.length_pos`.", "terms": "[\"Alias\", \"reverse direction\", \"List.length_pos\"]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} → [inst_1 : CategoryTheory.Category.{v₂, u₂} D] → CategoryTheory.Functor C D → C ⥤q D", "name": "CategoryTheory.Functor.toPrefunctor", "isProp": false, "docString": "The prefunctor between the underlying quivers. ", "terms": "[\n    \"prefunctor\",\n    \"underlying\",\n    \"quivers\"\n]"}
{"type": "{𝕜 : Type u} →\n  [hnorm : NontriviallyNormedField 𝕜] →\n    {E : Type v} →\n      [inst : AddCommGroup E] →\n        [inst_1 : Module 𝕜 E] →\n          [inst_2 : TopologicalSpace E] →\n            [inst_3 : TopologicalAddGroup E] →\n              [inst_4 : ContinuousSMul 𝕜 E] →\n                [inst_5 : CompleteSpace 𝕜] →\n                  {ι : Type u_1} → [inst_6 : Fintype ι] → [inst_7 : T2Space E] → Basis ι 𝕜 E → E ≃L[𝕜] ι → 𝕜", "name": "Basis.equivFunL", "isProp": false, "docString": "The continuous linear equivalence between a vector space over `𝕜` with a finite basis and\nfunctions from its basis indexing type to `𝕜`. ", "terms": "[\n\"Continuous\",\n\"Linear Equivalence\",\n\"Vector Space\",\n\"Over\",\n\"Finite Basis\",\n\"Functions\",\n\"From\",\n\"Basis Indexing Type\",\n\"To\"\n]"}
{"type": "{𝕜 : Type u_3} →\n  {𝕜₂ : Type u_4} →\n    {E : Type u_7} →\n      {E₂ : Type u_8} →\n        [inst : SeminormedRing 𝕜] →\n          [inst_1 : SeminormedRing 𝕜₂] →\n            {σ₁₂ : 𝕜 →+* 𝕜₂} →\n              [inst_2 : RingHomIsometric σ₁₂] →\n                [inst_3 : AddCommGroup E] →\n                  [inst_4 : AddCommGroup E₂] →\n                    [inst_5 : Module 𝕜 E] → [inst_6 : Module 𝕜₂ E₂] → (E →ₛₗ[σ₁₂] E₂) → Seminorm 𝕜₂ E₂ →+ Seminorm 𝕜 E", "name": "Seminorm.pullback", "isProp": false, "docString": "The composition as an `AddMonoidHom`. ", "terms": "[\"composition\", \"AddMonoidHom\"]"}
{"type": "CategoryTheory.Faithful compactumToCompHaus", "name": "compactumToCompHaus.faithful", "isProp": true, "docString": "The functor `compactumToCompHaus` is faithful. ", "terms": "[\"functor\", \"compactumToCompHaus\", \"faithful\"]"}
{"type": "(R : Type u) →\n  (S : Type v) →\n    [inst : CommRing R] →\n      [inst_1 : CommRing S] →\n        [inst_2 : Algebra R S] → Module (TensorProduct R S S) ↥(Ideal.cotangentIdeal (KaehlerDifferential.ideal R S))", "name": "instSS", "isProp": false, "docString": "A shortcut instance to prevent timing out. Hopefully to be removed in the future. ", "terms": "[]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]\n  {F : CategoryTheory.Functor C D} [self : CategoryTheory.IsEquivalence F] (X : C),\n  CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.IsEquivalence.unitIso.hom.app X))\n      (CategoryTheory.IsEquivalence.counitIso.hom.app (F.obj X)) =\n    CategoryTheory.CategoryStruct.id (F.obj X)", "name": "CategoryTheory.IsEquivalence.functor_unitIso_comp", "isProp": true, "docString": "The natural isomorphisms are inverse. ", "terms": "[\n    \"natural\",\n    \"isomorphisms\",\n    \"inverse\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Abelian C] →\n      (P : C) →\n        [hP : CategoryTheory.Projective P] →\n          CategoryTheory.Limits.PreservesFiniteColimits (CategoryTheory.preadditiveCoyonedaObj (Opposite.op P))", "name": "CategoryTheory.preservesFiniteColimitsPreadditiveCoyonedaObjOfProjective", "isProp": false, "docString": "The preadditive Co-Yoneda functor on `P` preserves finite colimits if `P` is projective. ", "terms": "[\n    \"preadditive\",\n    \"Co-Yoneda functor\",\n    \"preserves\",\n    \"finite colimits\",\n    \"projective\"\n]"}
{"type": "∀ {V : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace ℝ V] [inst_2 : FiniteDimensional ℝ V] {s : Set V},\n  Convex ℝ s → Set.Nonempty s → Set.Nonempty (intrinsicInterior ℝ s)", "name": "Set.Nonempty.intrinsicInterior", "isProp": true, "docString": "The intrinsic interior of a nonempty convex set is nonempty. ", "terms": "[\n    \"Intrinsic Interior\",\n    \"Nonempty\",\n    \"Convex Set\"\n]"}
{"type": "(n : ℕ) → Type u_1 → TypeVec.{u} n → Type u_1", "name": "MvQPF.Const", "isProp": false, "docString": "Constant multivariate functor ", "terms": "[\"Constant\", \"Multivariate\", \"Functor\"]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {B : C} {X Y : CategoryTheory.Subobject B}\n  (f : CategoryTheory.Subobject.underlying.obj X ≅ CategoryTheory.Subobject.underlying.obj Y),\n  CategoryTheory.CategoryStruct.comp f.hom (CategoryTheory.Subobject.arrow Y) = CategoryTheory.Subobject.arrow X → X = Y", "name": "CategoryTheory.Subobject.eq_of_comm", "isProp": true, "docString": "To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\nthe arrows. ", "terms": "[\n  \"subobjects\",\n  \"equal\",\n  \"suffices\",\n  \"exhibit\",\n  \"isomorphism\",\n  \"commuting\",\n  \"arrows\"\n]"}
{"type": "{α : Type u_1} →\n  [inst : CancelCommMonoidWithZero α] →\n    [inst_1 : DecidableEq α] → (∀ (a b : α), ∃ c, ∀ (d : α), a ∣ d ∧ b ∣ d ↔ c ∣ d) → GCDMonoid α", "name": "gcdMonoidOfExistsLCM", "isProp": false, "docString": "Define a `GCDMonoid` structure on a monoid just from the existence of an `lcm`. ", "terms": "[\n    \"GCDMonoid\",\n    \"structure\",\n    \"monoid\",\n    \"existence\",\n    \"lcm\"\n]"}
{"type": "{β : Type w} →\n  {C : Type u} → [inst : CategoryTheory.Category.{v, u} C] → [inst_1 : Unique β] → (f : β → C) → ∐ f ≅ f default", "name": "CategoryTheory.Limits.coproductUniqueIso", "isProp": false, "docString": "A coproduct over an index type with exactly one term is just the object over that term. ", "terms": "[\n    \"coproduct\", \n    \"index type\", \n    \"object\", \n    \"term\"\n]"}
{"type": "(R : Type u_1) →\n  (A : Type u_2) →\n    [inst : CommSemiring R] → [inst_1 : NonUnitalSemiring A] → [inst_2 : Module R A] → A →ₙₐ[R] Unitization R A", "name": "Unitization.inrNonUnitalAlgHom", "isProp": false, "docString": "The coercion from a non-unital `R`-algebra `A` to its unitization `Unitization R A`\nrealized as a non-unital algebra homomorphism. ", "terms": "[\n    \"coercion\",\n    \"non-unital\",\n    \"`R`-algebra\",\n    \"`A`\",\n    \"unitization\",\n    \"`Unitization R A`\",\n    \"realized\",\n    \"non-unital algebra\",\n    \"homomorphism\"\n]"}
{"type": "{R : Type u_1} →\n  {A : Type u_2} →\n    [inst : CommRing R] →\n      [inst_1 : CommRing A] →\n        [inst_2 : IsDomain A] →\n          [inst_3 : IsDedekindDomain A] →\n            {I : Ideal R} →\n              {J : Ideal A} → {f : R ⧸ I →+* A ⧸ J} → Function.Surjective ⇑f → { p // p ∣ I } →o { p // p ∣ J }", "name": "idealFactorsFunOfQuotHom", "isProp": false, "docString": "The map from ideals of `R` dividing `I` to the ideals of `A` dividing `J` induced by\na homomorphism `f : R/I →+* A/J` ", "terms": "[\n  \"map\",\n  \"ideals\",\n  \"dividing\",\n  \"induced\",\n  \"homomorphism\"\n]"}
{"type": "{C : Type u_1} →\n  {D : Type u_2} →\n    [inst : CategoryTheory.Category.{u_3, u_1} C] →\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] →\n        [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] →\n          [inst_3 : CategoryTheory.Limits.HasZeroMorphisms D] →\n            {S : CategoryTheory.ShortComplex C} →\n              (h : CategoryTheory.ShortComplex.LeftHomologyData S) →\n                {F : CategoryTheory.Functor C D} →\n                  [inst_4 : CategoryTheory.Functor.PreservesZeroMorphisms F] →\n                    [self : CategoryTheory.ShortComplex.LeftHomologyData.IsPreservedBy h F] →\n                      CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair S.g 0) F", "name": "CategoryTheory.ShortComplex.LeftHomologyData.IsPreservedBy.g", "isProp": false, "docString": "the functor preserves the kernel of `S.g : S.X₂ ⟶ S.X₃`. ", "terms": "[\n    \"functor\",\n    \"preserves\",\n    \"kernel\"\n]"}
{"type": "{X : Type u_1} →\n  {Y : Type u_2} →\n    [inst : TopologicalSpace X] →\n      [inst_1 : TopologicalSpace Y] →\n        {Z : Type u_5} →\n          (R : Type u_4) →\n            [inst_2 : Semiring R] →\n              [inst_3 : AddCommMonoid Z] →\n                [inst_4 : Module R Z] → (f : X → Y) → Continuous f → LocallyConstant Y Z →ₗ[R] LocallyConstant X Z", "name": "LocallyConstant.comapₗ", "isProp": false, "docString": "`LocallyConstant.comap` as a linear map. ", "terms": "[\"LocallyConstant.comap\", \"linear map\"]"}
{"type": "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : SecondCountableTopology α] (m : MeasureTheory.OuterMeasure α)\n  {s : Set α}, ↑m s ≠ 0 → ∃ x ∈ s, ∀ t ∈ nhdsWithin x s, 0 < ↑m t", "name": "MeasureTheory.OuterMeasure.exists_mem_forall_mem_nhds_within_pos", "isProp": true, "docString": "If `m s ≠ 0`, then for some point `x ∈ s` and any `t ∈ 𝓝[s] x` we have `0 < m t`. ", "terms": "[\n    \"nonzero\",\n    \"point\",\n    \"element of\",\n    \"neighborhood\",\n    \"less than\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    (D : Type u₂) →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        [inst_2 : ∀ (a b : C), CategoryTheory.Limits.HasCoproductsOfShape (a ⟶ b) D] →\n          C → CategoryTheory.Functor D (CategoryTheory.Functor C D)", "name": "CategoryTheory.evaluationLeftAdjoint", "isProp": false, "docString": "The left adjoint of evaluation. ", "terms": "[\n    \"left adjoint\",\n    \"evaluation\"\n]"}
{"type": "{M : Type u_1} → [inst : Monoid M] → {s : Set M} → (∀ a ∈ s, ∀ b ∈ s, a * b = b * a) → CommMonoid ↥(Submonoid.closure s)", "name": "Submonoid.closureCommMonoidOfComm", "isProp": false, "docString": "If all the elements of a set `s` commute, then `closure s` is a commutative monoid. ", "terms": "[\n    \"elements\",\n    \"set\",\n    \"commute\",\n    \"closure\",\n    \"commutative\",\n    \"monoid\"\n]"}
{"type": "(C : Type u) → [inst : CategoryTheory.Category.{v, u} C] → Prop", "name": "CategoryTheory.Limits.HasCoequalizers", "isProp": false, "docString": "`HasCoequalizers` represents a choice of coequalizer for every pair of morphisms ", "terms": "[\n    \"HasCoequalizers\",\n    \"choice\",\n    \"coequalizer\",\n    \"pair\",\n    \"morphisms\"\n]"}
{"type": "{R : Type u} → {σ : Type u_1} → [inst : CommSemiring R] → R →+* MvPolynomial σ R", "name": "MvPolynomial.C", "isProp": false, "docString": "`C a` is the constant polynomial with value `a` ", "terms": "[\"constant polynomial\", \"value\"]"}
{"type": "(R : Type u_1) →\n  (M : Type u_4) →\n    [inst : Ring R] →\n      [inst_1 : AddCommGroup M] →\n        [inst_2 : Module R M] → [inst_3 : NoZeroSMulDivisors R M] → (x : M) → x ≠ 0 → ↥(Submodule.span R {x}) ≃ₗ[R] R", "name": "LinearEquiv.coord", "isProp": false, "docString": "Given a nonzero element `x` of a torsion-free module `M` over a ring `R`, the natural\nisomorphism from the span of `x` to `R` given by $r \\cdot x \\mapsto r$. ", "terms": "[\n  \"nonzero element\",\n  \"torsion-free module\",\n  \"ring\",\n  \"natural isomorphism\",\n  \"span\"\n]"}
{"type": "{α : semiOutParam (Sort u)} → {β : Sort v} → [self : Coe α β] → α → β", "name": "Coe.coe", "isProp": false, "docString": "Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. ", "terms": "[\"Coerces\", \"value\", \"type\", \"Accessible\", \"notation\", \"double type ascription\"]"}
{"type": "Lean.TrailingParserDescr", "name": "FirstOrder.«term_[[_]]»", "isProp": false, "docString": "Extends a language with a constant for each element of a parameter set in `M`. ", "terms": "[\"extends\", \"language\", \"constant\", \"element\", \"parameter set\"]"}
{"type": "{α : Type u_1} →\n  {β : Type u_2} → [inst : TopologicalSpace α] → [inst_1 : TopologicalSpace β] → PartialHomeomorph α β → β → α", "name": "PartialHomeomorph.Simps.symm_apply", "isProp": false, "docString": "See Note [custom simps projection] ", "terms": "[]"}
{"type": "∀ {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} {p : ENNReal} {μ : MeasureTheory.Measure α}\n  [inst : NormedAddCommGroup E] (f : ↥(MeasureTheory.Lp E p)),\n  p ≠ 0 →\n    p ≠ ⊤ → ∀ (ε : ENNReal), ε ^ ENNReal.toReal p * ↑↑μ {x | ε ≤ ↑‖↑↑f x‖₊} ≤ ENNReal.ofReal ‖f‖ ^ ENNReal.toReal p", "name": "MeasureTheory.Lp.mul_meas_ge_le_pow_norm'", "isProp": true, "docString": "A version of Markov's inequality with elements of Lp. ", "terms": "[\n    \"Markov's inequality\",\n    \"version\",\n    \"elements\",\n    \"Lp\"\n]"}
{"type": "{F : PFunctor.{u}} →\n  [inst : DecidableEq F.A] → [inst : Inhabited (PFunctor.M F)] → PFunctor.Approx.Path F → PFunctor.M F → PFunctor.M F", "name": "PFunctor.M.isubtree", "isProp": false, "docString": "follow a path through a value of `M F` and return the subtree\nfound at the end of the path if it is a valid path for that value and\nreturn a default tree ", "terms": "[]\n"}
{"type": "∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : Set α} [inst : MeasureTheory.SigmaFinite μ]\n  {r : ENNReal}, MeasurableSet s → r < ↑↑μ s → ∃ t, MeasurableSet t ∧ t ⊆ s ∧ r < ↑↑μ t ∧ ↑↑μ t < ⊤", "name": "MeasureTheory.Measure.exists_subset_measure_lt_top", "isProp": true, "docString": "In a σ-finite space, any measurable set of measure `> r` contains a measurable subset of\nfinite measure `> r`. ", "terms": "[\n    \"σ-finite space\",\n    \"measurable set\",\n    \"measure\",\n    \"measurable subset\",\n    \"finite measure\"\n]"}
{"type": "{α : Type u_1} → [inst : CancelCommMonoidWithZero α] → Associates.FactorSet α → Associates α", "name": "Associates.FactorSet.prod", "isProp": false, "docString": "Evaluates the product of a `FactorSet` to be the product of the corresponding multiset,\nor `0` if there is none. ", "terms": "[\n    \"Evaluates\",\n    \"product\",\n    \"FactorSet\",\n    \"corresponding\",\n    \"multiset\",\n    \"0\",\n    \"none\"\n]"}
{"type": "{B : Type u} →\n  [inst : CategoryTheory.Bicategory B] →\n    {a b c : B} → {f : a ⟶ b} → {g : a ⟶ c} → CategoryTheory.Bicategory.RightExtension f g → (b ⟶ c)", "name": "CategoryTheory.Bicategory.RightExtension.extension", "isProp": false, "docString": "The extension of `g` along `f`. ", "terms": "[\"extension\", \"along\"]"}
{"type": "(G : Type u) → [inst : AddGroup G] → {α : Type v} → [inst_1 : AddAction G α] → α → AddSubgroup G", "name": "AddAction.stabilizer", "isProp": false, "docString": "The stabilizer of an element under an action, i.e. what sends the element to itself.\nAn additive subgroup.", "terms": "[\n    \"stabilizer\",\n    \"element\",\n    \"action\",\n    \"additive\",\n    \"subgroup\"\n]"}
{"type": "{B : Type u} →\n  [inst : CategoryTheory.Bicategory B] →\n    {a b c : B} →\n      {f : b ⟶ a} →\n        {g : c ⟶ a} →\n          (t : CategoryTheory.Bicategory.LeftLift f g) →\n            g ⟶ CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.LeftLift.lift t) f", "name": "CategoryTheory.Bicategory.LeftLift.unit", "isProp": false, "docString": "The 2-morphism filling the triangle diagram. ", "terms": "[\"2-morphism\", \"triangle diagram\"]"}
{"type": "{α : Type u_2} → [inst : Zero α] → [inst : Add α] → [inst : Neg α] → SMul ℤ (Set α)", "name": "Set.ZSMul", "isProp": false, "docString": "Repeated pointwise addition/subtraction (not the same as pointwise repeated\naddition/subtraction!) of a `Set`. See note [pointwise nat action]. ", "terms": "[\n\"Repeated pointwise addition/subtraction\", \n\"Set\", \n\"pointwise nat action\"\n]"}
{"type": "∀ {α : Type u} [inst : PseudoMetricSpace α] (p : α → Prop) (x : α),\n  (∃ᶠ (R : ℝ) in Filter.atTop, ∀ y ∈ Metric.ball x R, p y) → ∀ (y : α), p y", "name": "Metric.forall_of_forall_mem_ball", "isProp": true, "docString": "If a property holds for all points in balls of arbitrarily large radii, then it holds for all\npoints. ", "terms": "[\n    \"property\",\n    \"points\",\n    \"balls\",\n    \"arbitrarily large\",\n    \"radii\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {J : CategoryTheory.GrothendieckTopology C} →\n      {F F' : CategoryTheory.Sheaf J (Type w)} → (F ⟶ F') → CategoryTheory.Sheaf J (Type w)", "name": "CategoryTheory.GrothendieckTopology.imageSheaf", "isProp": false, "docString": "The image sheaf of a morphism between sheaves, defined to be the sheafification of\n`image_presheaf`. ", "terms": "[\n    \"image sheaf\",\n    \"morphism\",\n    \"sheaves\",\n    \"sheafification\",\n    \"image_presheaf\"\n]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X : C} {J : CategoryTheory.GrothendieckTopology C}\n  {S : CategoryTheory.GrothendieckTopology.Cover J X} (self : CategoryTheory.GrothendieckTopology.Cover.Arrow S),\n  (CategoryTheory.GrothendieckTopology.Cover.sieve S).arrows self.f", "name": "CategoryTheory.GrothendieckTopology.Cover.Arrow.hf", "isProp": true, "docString": "The given arrow is contained in the given sieve. ", "terms": "[\"arrow\", \"contained\", \"sieve\"]"}
{"type": "{ι : Type u_1} →\n  {V : Type u} →\n    [inst : CategoryTheory.Category.{v, u} V] →\n      [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] →\n        {c : ComplexShape ι} →\n          [inst_2 : CategoryTheory.Limits.HasKernels V] →\n            [inst_3 : CategoryTheory.Limits.HasImages V] →\n              (C : HomologicalComplex V c) →\n                (i : ι) →\n                  CategoryTheory.Subobject.underlying.obj (HomologicalComplex.boundaries C i) ⟶\n                    CategoryTheory.Subobject.underlying.obj (HomologicalComplex.cycles' C i)", "name": "HomologicalComplex.boundariesToCycles'", "isProp": false, "docString": "The canonical map from `boundaries i` to `cycles' i`. ", "terms": "[\n  \"canonical map\",\n  \"boundaries\",\n  \"cycles\"\n]"}
{"type": "{α : Type u_1} → [inst : Denumerable α] → Denumerable (List α)", "name": "Denumerable.denumerableList", "isProp": false, "docString": "If `α` is denumerable, then so is `List α`. ", "terms": "[\n  \"denumerable\",\n  \"List\"\n]"}
{"type": "(p : Prop) → [h : Decidable p] → Bool", "name": "Decidable.decide", "isProp": false, "docString": "Convert a decidable proposition into a boolean value.\n\nIf `p : Prop` is decidable, then `decide p : Bool` is the boolean value\nwhich is `true` if `p` is true and `false` if `p` is false.\n", "terms": "[\"decidable proposition\", \"boolean value\", \"decide\", \"true\", \"false\"]"}
{"type": "∀ {α : Type u_1} [inst : DecidableEq α] {s t u : Multiset α}, s - t ≤ u ↔ s ≤ u + t", "name": "Multiset.sub_le_iff_le_add", "isProp": true, "docString": "This is a special case of `tsub_le_iff_right`, which should be used instead of this.\nThis is needed to prove `OrderedSub (Multiset α)`. ", "terms": "[\"special case\", \"tsub_le_iff_right\", \"OrderedSub\", \"Multiset\"]"}
{"type": "ℕ → ℕ → ℕ", "name": "Polynomial.revAtFun", "isProp": false, "docString": "If `i ≤ N`, then `revAtFun N i` returns `N - i`, otherwise it returns `i`.\nThis is the map used by the embedding `revAt`.\n", "terms": "[\"≤\", \"returns\", \"map\", \"embedding\"]"}
{"type": "∀ (k : Type u_1) (V : Type u_2) (P : Type u_3) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P], affineSpan k Set.univ = ⊤", "name": "AffineSubspace.span_univ", "isProp": true, "docString": "The span of `univ` is `⊤`. ", "terms": "[\"span\", \"⊤\"]"}
{"type": "∀ {α : Type u} {β : Type v} {f : α → β} {g : β → α},\n  Function.Injective f → Function.Injective g → ∃ h, Function.Bijective h", "name": "Function.Embedding.schroeder_bernstein", "isProp": true, "docString": "**The Schröder-Bernstein Theorem**:\nGiven injections `α → β` and `β → α`, we can get a bijection `α → β`. ", "terms": "[\n  \"Schröder-Bernstein Theorem\",\n  \"injections\",\n  \"bijection\"\n]"}
{"type": "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, 0 < a → 0 < b → 0 < a + b", "name": "add_pos'", "isProp": true, "docString": "**Alias** of `Left.add_pos'`.", "terms": "The statement provided does not contain any mathematical terms. Therefore, the returned JSON list is empty. Here is how it looks:\n\n```json\n[]\n```"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasProducts C] →\n      {X : TopCat} →\n        (F : TopCat.Presheaf C X) →\n          {ι : Type v'} →\n            (U : ι → TopologicalSpace.Opens ↑X) →\n              CategoryTheory.Limits.Cone (CategoryTheory.Functor.comp (CategoryTheory.Pairwise.diagram U).op F) ≌\n                CategoryTheory.Limits.Cone (TopCat.Presheaf.SheafConditionEqualizerProducts.diagram F U)", "name": "TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquiv", "isProp": false, "docString": "Cones over `diagram U ⋙ F` are the same as a cones over the usual sheaf condition equalizer diagram.\n", "terms": "[\n    \"Cones\",\n    \"diagram\",\n    \"F\",\n    \"same as\",\n    \"usual\",\n    \"sheaf condition\",\n    \"equalizer diagram\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {A : C} →\n      [inst_1 : CategoryTheory.Limits.HasFiniteProducts C] →\n        [inst_2 : CategoryTheory.Exponentiable A] → {I : C} → CategoryTheory.Limits.IsInitial I → (I ⨯ A ≅ I)", "name": "CategoryTheory.mulZero", "isProp": false, "docString": "If an initial object `0` exists in a CCC, then `0 ⨯ A ≅ 0`. ", "terms": "[\n    \"initial object\",\n    \"exists\",\n    \"CCC\",\n    \"⨯ (product)\",\n    \"≅ (isomorphic)\"\n]"}
{"type": "∀ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (x : A) (r : R)\n  (y : A), x * ((algebraMap R A) r * y) = (algebraMap R A) r * (x * y)", "name": "Algebra.left_comm", "isProp": true, "docString": "`mul_left_comm` for `Algebra`s when one element is from the base ring. ", "terms": "[\n    \"mul_left_comm\",\n    \"Algebra\",\n    \"element\",\n    \"base ring\"\n]"}
{"type": "∀ {F : Type u_8} {α : outParam (Type u_9)} {β : outParam (Type u_10)} [inst : CompleteLattice α]\n  [inst_1 : CompleteLattice β] [self : CompleteLatticeHomClass F α β] (f : F) (s : Set α), f (sSup s) = sSup (⇑f '' s)", "name": "CompleteLatticeHomClass.map_sSup", "isProp": true, "docString": "The proposition that members of `CompleteLatticeHomClass` commute with arbitrary\nsuprema/joins. ", "terms": "[\n  \"proposition\",\n  \"members\",\n  \"CompleteLatticeHomClass\",\n  \"commute\",\n  \"arbitrary\",\n  \"suprema\",\n  \"joins\"\n]"}
{"type": "∀ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x ∈ s → y ∈ s → x * y ∈ s", "name": "NonUnitalSubring.mul_mem", "isProp": true, "docString": "A non-unital subring is closed under multiplication. ", "terms": "[\n    \"non-unital subring\",\n    \"closed\",\n    \"multiplication\"\n]"}
{"type": "{α : Type u_1} →\n  {M : Type u_5} →\n    {G : Type u_9} →\n      [inst : Monoid G] → [inst_1 : MulAction G α] → [inst_2 : AddCommMonoid M] → DistribMulAction G (α →₀ M)", "name": "Finsupp.comapDistribMulAction", "isProp": false, "docString": "`Finsupp.comapSMul` is distributive ", "terms": "[\n  \"Finsupp.comapSMul\",\n  \"distributive\"\n]"}
{"type": "{α : Type u_1} →\n  [inst : DecidableEq α] → ↑(derangements (Option α)) ≃ (a : α) × (↑(derangements ↑{a}ᶜ) ⊕ ↑(derangements α))", "name": "derangements.derangementsRecursionEquiv", "isProp": false, "docString": "The set of derangements on `Option α` is equivalent to the union over all `a : α` of\n\"derangements on `α` ⊕ derangements on `{a}ᶜ`\". ", "terms": "[\n  \"set\",\n  \"derangements\",\n  \"equivalent\",\n  \"union\",\n  \"over\",\n  \"all\"\n]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Abelian C]\n  [inst_2 : CategoryTheory.Limits.HasPullbacks C] {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) [inst_3 : CategoryTheory.Epi f],\n  CategoryTheory.Epi CategoryTheory.Limits.pullback.snd", "name": "CategoryTheory.Abelian.epi_pullback_of_epi_f", "isProp": true, "docString": "In an abelian category, the pullback of an epimorphism is an epimorphism.\nProof from [aluffi2016, IX.2.3], cf. [borceux-vol2, 1.7.6] ", "terms": "[\n  \"abelian category\",\n  \"pullback\",\n  \"epimorphism\"\n]"}
{"type": "(C : Type u) →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.ConcreteCategory C] → CategoryTheory.MorphismProperty C", "name": "CategoryTheory.MorphismProperty.injective", "isProp": false, "docString": "Injectiveness (in a concrete category) as a `MorphismProperty` ", "terms": "[\n    \"Injectiveness\",\n    \"Concrete Category\",\n    \"MorphismProperty\"\n]"}
{"type": "∀ {I : Type u} {f : I → Type v} [inst : DecidableEq I] [inst_1 : (i : I) → MulOneClass (f i)] (x : (i : I) → f i)\n  (i j : I), Commute (Pi.mulSingle i (x i)) (Pi.mulSingle j (x j))", "name": "Pi.mulSingle_apply_commute", "isProp": true, "docString": "The injection into a pi group with the same values commutes. ", "terms": "[\n    \"injection\",\n    \"pi group\",\n    \"values\",\n    \"commutes\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasBinaryCoproducts C] → (P Q R : C) → (P ⨿ Q) ⨿ R ≅ P ⨿ Q ⨿ R", "name": "CategoryTheory.Limits.coprod.associator", "isProp": false, "docString": "The associator isomorphism for binary coproducts. ", "terms": "[\n    \"associator\",\n    \"isomorphism\",\n    \"binary\",\n    \"coproducts\"\n]"}
{"type": "{R : Type u_1} →\n  {R₂ : Type u_2} →\n    {E : Type u_5} →\n      {E₂ : Type u_6} →\n        [inst : Semiring R] →\n          [inst_1 : Semiring R₂] →\n            {σ₁₂ : R →+* R₂} →\n              {σ₂₁ : R₂ →+* R} →\n                [inst_2 : RingHomInvPair σ₁₂ σ₂₁] →\n                  [inst_3 : RingHomInvPair σ₂₁ σ₁₂] →\n                    [inst_4 : SeminormedAddCommGroup E] →\n                      [inst_5 : SeminormedAddCommGroup E₂] →\n                        [inst_6 : Module R E] → [inst_7 : Module R₂ E₂] → (E ≃ₛₗᵢ[σ₁₂] E₂) → E₂ ≃ₛₗᵢ[σ₂₁] E", "name": "LinearIsometryEquiv.symm", "isProp": false, "docString": "The inverse `LinearIsometryEquiv`. ", "terms": "[\n    \"Inverse\",\n    \"LinearIsometryEquiv\"\n]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      {S₁ S₂ : CategoryTheory.ShortComplex C} →\n        (S₁ ≅ S₂) →\n          [inst_2 : CategoryTheory.ShortComplex.HasLeftHomology S₁] →\n            [inst_3 : CategoryTheory.ShortComplex.HasLeftHomology S₂] →\n              CategoryTheory.ShortComplex.cycles S₁ ≅ CategoryTheory.ShortComplex.cycles S₂", "name": "CategoryTheory.ShortComplex.cyclesMapIso", "isProp": false, "docString": "The isomorphism `S₁.cycles ≅ S₂.cycles` induced by an isomorphism\nof short complexes `S₁ ≅ S₂`. ", "terms": "[\n  \"isomorphism\",\n  \"cycles\",\n  \"induced\",\n  \"short complexes\"\n]"}
{"type": "{p : ℕ+} →\n  {K : Type u} →\n    [inst : Field K] →\n      [inst_1 : CharZero K] →\n        {ζ : K} →\n          [hp : Fact (Nat.Prime ↑p)] →\n            [hcycl : IsCyclotomicExtension {p} ℚ K] →\n              IsPrimitiveRoot ζ ↑p → ↥(Algebra.adjoin ℤ {ζ}) ≃ₐ[ℤ] ↥(NumberField.ringOfIntegers K)", "name": "IsPrimitiveRoot.adjoinEquivRingOfIntegers'", "isProp": false, "docString": "The algebra isomorphism `adjoin ℤ {ζ} ≃ₐ[ℤ] (𝓞 K)`, where `ζ` is a primitive `p`-th root of\nunity and `K` is a `p`-th cyclotomic extension of `ℚ`. ", "terms": "[\n  \"algebra\",\n  \"isomorphism\",\n  \"adjoin\",\n  \"ℤ\",\n  \"primitive root of unity\",\n  \"p-th\",\n  \"cyclotomic extension\",\n  \"ℚ\"\n]"}
{"type": "∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] {W : CategoryTheory.MorphismProperty C}\n  [inst_1 : CategoryTheory.MorphismProperty.HasLeftCalculusOfFractions W] {X Y Z : C}\n  (z₁ : CategoryTheory.MorphismProperty.LeftFraction W X Y) (z₂ : CategoryTheory.MorphismProperty.LeftFraction W Y Z)\n  (z₃ z₃' : CategoryTheory.MorphismProperty.LeftFraction W z₁.Y' z₂.Y'),\n  CategoryTheory.CategoryStruct.comp z₂.f z₃.s = CategoryTheory.CategoryStruct.comp z₁.s z₃.f →\n    CategoryTheory.CategoryStruct.comp z₂.f z₃'.s = CategoryTheory.CategoryStruct.comp z₁.s z₃'.f →\n      CategoryTheory.MorphismProperty.LeftFractionRel (CategoryTheory.MorphismProperty.LeftFraction.comp₀ z₁ z₂ z₃)\n        (CategoryTheory.MorphismProperty.LeftFraction.comp₀ z₁ z₂ z₃')", "name": "CategoryTheory.MorphismProperty.LeftFraction.comp₀_rel", "isProp": true, "docString": "The equivalence class of `z₁.comp₀ z₂ z₃` does not depend on the choice of `z₃` provided\nthey satisfy the compatibility `z₂.f ≫ z₃.s = z₁.s ≫ z₃.f`. ", "terms": "[\n    \"equivalence class\",\n    \"comp₀\",\n    \"choice\",\n    \"compatibility\",\n    \"≫\"\n]"}
{"type": "{α : Sort u_5} → {β : α → Type u_4} → (p : α → Prop) → ((x : α) → β x) → (x : Subtype p) → β ↑x", "name": "Subtype.restrict", "isProp": false, "docString": "Restrict a (dependent) function to a subtype ", "terms": "[\n  \"Restrict\",\n  \"Dependent Function\",\n  \"Subtype\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β],\n  IsPiSystem (Set.image2 (fun x x_1 => x ×ˢ x_1) {s | MeasurableSet s} {t | MeasurableSet t})", "name": "isPiSystem_prod", "isProp": true, "docString": "Rectangles form a π-system. ", "terms": "[\"Rectangles\", \"π-system\"]"}
{"type": "{α : Type u_1} → {r : Rel α α} → RelSeries r → {s : Rel α α} → r ≤ s → RelSeries s", "name": "RelSeries.ofLE", "isProp": false, "docString": "Given two relations `r, s` on `α` such that `r ≤ s`, any relation series of `r` induces a relation\nseries of `s`\n", "terms": "[\n    \"relations\",\n    \"relation series\",\n    \"induces\",\n    \"≤\"\n]"}
{"type": "{α : Type u_1} → {β : Type u_2} → [inst : Primcodable α] → [inst : Primcodable β] → (α → Prop) → (β → Prop) → Prop", "name": "ManyOneReducible", "isProp": false, "docString": "`p` is many-one reducible to `q` if there is a computable function translating questions about `p`\nto questions about `q`.\n", "terms": "[\n    \"many-one reducible\",\n    \"computable function\",\n    \"translating\",\n    \"questions\"\n]"}
{"type": "∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] (x : Rˣ),\n  ∀ᶠ (t : R) in nhds 0, Ring.inverse (↑x + t) = Ring.inverse (1 + ↑x⁻¹ * t) * ↑x⁻¹", "name": "NormedRing.inverse_add", "isProp": true, "docString": "The formula `Ring.inverse (x + t) = Ring.inverse (1 + x⁻¹ * t) * x⁻¹` holds for `t` sufficiently\nsmall. ", "terms": "[\n  \"formula\",\n  \"Ring.inverse\",\n  \"sufficiently small\"\n]"}
{"type": "{ι : Type u} →\n  {γ : Type w} →\n    {β : ι → Type v} →\n      [inst : Monoid γ] →\n        [inst_1 : (i : ι) → AddMonoid (β i)] → [inst : (i : ι) → DistribMulAction γ (β i)] → SMul γ (Π₀ (i : ι), β i)", "name": "DFinsupp.instSMulDFinsuppToZero", "isProp": false, "docString": "Dependent functions with finite support inherit a semiring action from an action on each\ncoordinate. ", "terms": "[\n    \"Dependent functions\",\n    \"Finite support\",\n    \"Semiring action\",\n    \"Action\",\n    \"Coordinate\"\n]"}
{"type": "{α : Type u_4} → [self : Fintype α] → Finset α", "name": "Fintype.elems", "isProp": false, "docString": "The `Finset` containing all elements of a `Fintype` ", "terms": "[\n    \"Finset\",\n    \"Fintype\",\n    \"elements\",\n    \"containing\",\n    \"all\"\n]"}
{"type": "{R : Type u_2} → [inst : Semiring R] → Module Rᵐᵒᵖ R", "name": "Semiring.toOppositeModule", "isProp": false, "docString": "Like `Semiring.toModule`, but multiplies on the right. ", "terms": "[\"Semiring.toModule\", \"multiplies\", \"right\"]"}
{"type": "{R : Type u_1} →\n  {B : Type u_2} →\n    {F : Type u_3} →\n      [inst : NontriviallyNormedField R] →\n        [inst_1 : NormedAddCommGroup F] →\n          [inst_2 : NormedSpace R F] →\n            [inst_3 : TopologicalSpace B] →\n              {ι : Type u_5} → (Z : VectorBundleCore R B F ι) → B → Trivialization F Bundle.TotalSpace.proj", "name": "VectorBundleCore.localTrivAt", "isProp": false, "docString": "Preferred local trivialization of a vector bundle constructed from core, at a given point, as\na bundle trivialization ", "terms": "[\n  \"Preferred local trivialization\",\n  \"Vector bundle\",\n  \"Core\",\n  \"Given point\",\n  \"Bundle trivialization\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {F G : CategoryTheory.Functor C D} → {H : CategoryTheory.Functor D C} → (F ⊣ H) → (F ≅ G) → (G ⊣ H)", "name": "CategoryTheory.Adjunction.ofNatIsoLeft", "isProp": false, "docString": "Transport an adjunction along a natural isomorphism on the left. ", "terms": "[\n    \"Transport\",\n    \"Adjunction\",\n    \"Natural Isomorphism\",\n    \"Left\"\n]"}
{"type": "{I : Type u} → (f : I → Type v) → [inst : (i : I) → NonAssocSemiring (f i)] → (i : I) → ((i : I) → f i) →+* f i", "name": "Pi.evalRingHom", "isProp": false, "docString": "Evaluation of functions into an indexed collection of rings at a point is a ring\nhomomorphism. This is `Function.eval` as a `RingHom`. ", "terms": "[\n    \"Evaluation\",\n    \"functions\",\n    \"indexed collection\",\n    \"rings\",\n    \"point\",\n    \"ring homomorphism\",\n    \"Function.eval\",\n    \"RingHom\"\n]"}
{"type": "{x y : SetTheory.PGame} →\n  SetTheory.PGame.LeftMoves x × SetTheory.PGame.LeftMoves y ⊕\n      SetTheory.PGame.RightMoves x × SetTheory.PGame.RightMoves y ≃\n    SetTheory.PGame.LeftMoves (x * y)", "name": "SetTheory.PGame.toLeftMovesMul", "isProp": false, "docString": "Turns two left or right moves for `x` and `y` into a left move for `x * y` and vice versa.\n\nEven though these types are the same (not definitionally so), this is the preferred way to convert\nbetween them. ", "terms": "[]\n"}
{"type": "∀ {n : ℕ} {a : Cardinal.{u_1}}, n • a < Cardinal.aleph0 ↔ n = 0 ∨ a < Cardinal.aleph0", "name": "Cardinal.nsmul_lt_aleph0_iff", "isProp": true, "docString": "See also `Cardinal.nsmul_lt_aleph0_iff_of_ne_zero` if you already have `n ≠ 0`. ", "terms": "[\"Cardinal.nsmul_lt_aleph0_iff_of_ne_zero\", \"n ≠ 0\"]"}
{"type": "∀ (x : ℝ), LiouvilleWith 1 x", "name": "liouvilleWith_one", "isProp": true, "docString": "For `p = 1` (hence, for any `p ≤ 1`), the condition `LiouvilleWith p x` is trivial. ", "terms": "[\"1\", \"any\", \"≤\", \"1\", \"condition\", \"LiouvilleWith\", \"trivial\"]"}
{"type": "∀ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s)", "name": "Group.normalClosure.isSubgroup", "isProp": true, "docString": "The normal closure of a set is a subgroup. ", "terms": "[\n    \"Normal Closure\",\n    \"Set\",\n    \"Subgroup\"\n]"}
{"type": "(C : Type u_1) →\n  (D : Type u_2) →\n    [inst : CategoryTheory.Category.{u_4, u_1} C] →\n      [inst_1 : CategoryTheory.Category.{u_5, u_2} D] →\n        CategoryTheory.Functor.comp (CategoryTheory.Idempotents.functorExtension₁ C D)\n            ((CategoryTheory.whiskeringLeft C (CategoryTheory.Idempotents.Karoubi C)\n                  (CategoryTheory.Idempotents.Karoubi D)).obj\n              (CategoryTheory.Idempotents.toKaroubi C)) ≅\n          CategoryTheory.Functor.id (CategoryTheory.Functor C (CategoryTheory.Idempotents.Karoubi D))", "name": "CategoryTheory.Idempotents.functorExtension₁CompWhiskeringLeftToKaroubiIso", "isProp": false, "docString": "The natural isomorphism expressing that functors `Karoubi C ⥤ Karoubi D` obtained\nusing `functorExtension₁` actually extends the original functors `C ⥤ Karoubi D`. ", "terms": "[\n    \"natural isomorphism\",\n    \"functors\",\n    \"Karoubi\",\n    \"functorExtension₁\",\n    \"original functors\"\n]"}
{"type": "{σ : Type} → {m : Type → Type} → [inst : Monad m] → [inst : Lean.MonadBacktrack σ m] → Alternative (Nondet m)", "name": "Nondet.instAlternativeNondet", "isProp": false, "docString": "`Nondet m` is an alternative monad. ", "terms": "[\n\"Alternative\",\n\"Monad\"\n]"}
{"type": "{R : Type u} → {S : Type v} → [inst : Ring R] → [inst_1 : Ring S] → (R →+* S) → Subring S", "name": "RingHom.range", "isProp": false, "docString": "The range of a ring homomorphism, as a subring of the target. See Note [range copy pattern]. ", "terms": "[\n    \"Range\",\n    \"Ring Homomorphism\",\n    \"Subring\",\n    \"Target\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α]\n  [inst_2 : OrderTopology α] [inst_3 : ConditionallyCompleteLinearOrder β] [inst_4 : TopologicalSpace β]\n  [inst_5 : OrderClosedTopology β] {ι : Sort u_1} [inst_6 : Nonempty ι] {f : α → β} {g : ι → α},\n  ContinuousAt f (iInf g) → Antitone f → autoParam (BddBelow (Set.range g)) _auto✝ → f (⨅ i, g i) = ⨆ i, f (g i)", "name": "Antitone.map_iInf_of_continuousAt'", "isProp": true, "docString": "An antitone function continuous at the indexed infimum over a nonempty `Sort` sends this indexed\ninfimum to the indexed supremum of the composition. ", "terms": "[\n    \"antitone function\", \n    \"continuous\", \n    \"indexed infimum\", \n    \"nonempty\", \n    \"Sort\", \n    \"indexed supremum\", \n    \"composition\"\n]"}
{"type": "{R : Type u_1} → [inst : AddMonoidWithOne R] → [inst : CharZero R] → ℕ ↪ R", "name": "Nat.castEmbedding", "isProp": false, "docString": "`Nat.cast` as an embedding into monoids of characteristic `0`. ", "terms": "[\n    \"Nat.cast\",\n    \"embedding\",\n    \"monoids\",\n    \"characteristic\"\n]"}
{"type": "Type u_1 → Type u_1", "name": "Additive", "isProp": false, "docString": "If `α` carries some multiplicative structure, then `Additive α` carries the corresponding\nadditive structure. ", "terms": "[\"multiplicative structure\", \"Additive\", \"corresponding additive structure\"]"}
{"type": "YoungDiagram → List ℕ", "name": "YoungDiagram.rowLens", "isProp": false, "docString": "List of row lengths of a Young diagram ", "terms": "[\"list\", \"row lengths\", \"Young diagram\"]"}
{"type": "{R : Type u} → [inst : CommRing R] → WeierstrassCurve R → Cubic R", "name": "WeierstrassCurve.twoTorsionPolynomial", "isProp": false, "docString": "A cubic polynomial whose discriminant is a multiple of the Weierstrass curve discriminant. If\n`W` is an elliptic curve over a field `R` of characteristic different from 2, then its roots over a\nsplitting field of `R` are precisely the $X$-coordinates of the non-zero 2-torsion points of `W`. ", "terms": "[\n    \"cubic polynomial\",\n    \"discriminant\",\n    \"multiple\",\n    \"Weierstrass curve discriminant\",\n    \"elliptic curve\",\n    \"field\",\n    \"characteristic\",\n    \"roots\",\n    \"splitting field\",\n    \"coordinates\",\n    \"non-zero\",\n    \"2-torsion points\"\n]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {p₁ p₂ : P} {s₁ s₂ : EuclideanGeometry.Sphere P},\n  p₁ ∈ s₁ → p₂ ∈ s₁ → p₁ ∈ s₂ → p₂ ∈ s₂ → inner (s₂.center -ᵥ s₁.center) (p₂ -ᵥ p₁) = 0", "name": "EuclideanGeometry.inner_vsub_vsub_of_mem_sphere_of_mem_sphere", "isProp": true, "docString": "Suppose that `p₁` and `p₂` lie in spheres `s₁` and `s₂`. Then the vector between the centers\nof those spheres is orthogonal to that between `p₁` and `p₂`; this is a version of\n`inner_vsub_vsub_of_dist_eq_of_dist_eq` for bundled spheres. (In two dimensions, this says that\nthe diagonals of a kite are orthogonal.) ", "terms": "[\n  \"spheres\",\n  \"vector\",\n  \"centers\",\n  \"orthogonal\",\n  \"inner_vsub_vsub_of_dist_eq_of_dist_eq\",\n  \"bundled spheres\",\n  \"two dimensions\",\n  \"diagonals\",\n  \"kite\"\n]"}
{"type": "{α : Type u_1} →\n  [inst : TopologicalSpace α] →\n    [inst_1 : SigmaCompactSpace α] →\n      {x : MeasurableSpace α} →\n        (μ : MeasureTheory.Measure α) →\n          [inst_2 : MeasureTheory.IsLocallyFiniteMeasure μ] →\n            MeasureTheory.Measure.FiniteSpanningSetsIn μ {K | IsOpen K}", "name": "MeasureTheory.Measure.finiteSpanningSetsInOpen", "isProp": false, "docString": "A locally finite measure on a `σ`-compact topological space admits a finite spanning sequence\nof open sets. ", "terms": "[\n  \"locally finite measure\",\n  \"σ-compact\",\n  \"topological space\",\n  \"finite\",\n  \"spanning sequence\",\n  \"open sets\"\n]"}
{"type": "∀ {R : Type u_1} [inst : MulZeroClass R] [nR : Nontrivial R], ¬IsLeftRegular 0", "name": "not_isLeftRegular_zero", "isProp": true, "docString": "In a non-trivial ring, the element `0` is not left-regular -- with typeclasses. ", "terms": "[\n    \"non-trivial ring\",\n    \"element\",\n    \"0\",\n    \"not left-regular\",\n    \"typeclasses\"\n]"}
{"type": "∀ {ι : Type u_2} {β : ι → Type u_3} [inst : Fintype ι] [inst_1 : (i : ι) → DecidableEq (β i)] {x y : (i : ι) → β i},\n  0 ≤ hammingDist x y", "name": "hammingDist_nonneg", "isProp": true, "docString": "Corresponds to `dist_nonneg`. ", "terms": "[]"}
{"type": "(a b : ℤ) → Decidable (a < b)", "name": "Int.decLt", "isProp": false, "docString": "Decides whether `a < b`.\n\n```\n#eval `¬ ( (7 : Int) < 0 )` -- true\n#eval `¬ ( (0 : Int) < 0 )` -- true\n#eval `(7 : Int) < 10` -- true\n```\n\nImplemented by efficient native code. ", "terms": "[\"Decides\", \"Int\", \"true\", \"false\", \"less than\", \"not\", \"native code\", \"efficient\"]"}
{"type": "{α : Sort u_1} → {β : Sort u_2} → (α ↪ β) → α → β", "name": "Function.Embedding.toFun", "isProp": false, "docString": "An embedding as a function. Use coercion instead. ", "terms": "[\n  \"embedding\",\n  \"function\",\n  \"coercion\"\n]"}
{"type": "{α : Type u_1} → Array α → (α → α → Bool) → Array α", "name": "Array.heapSort", "isProp": false, "docString": "`O(n log n)`. Sort an array using a `BinaryHeap`. ", "terms": "[\n    \"O(n log n)\",\n    \"Sort\",\n    \"array\",\n    \"BinaryHeap\"\n]"}
{"type": "{X : Type u_1} → [inst : NormedAddCommGroup X] → [inst_1 : NormedSpace ℝ X] → StructureGroupoid X", "name": "conformalGroupoid", "isProp": false, "docString": "The groupoid of conformal maps. ", "terms": "[\n    \"groupoid\",\n    \"conformal maps\"\n]"}
{"type": "(J : Type w) →\n  CategoryTheory.Functor.comp (CategoryTheory.Limits.widePushoutShapeUnop J)\n      (CategoryTheory.Limits.widePullbackShapeOp J) ≅\n    CategoryTheory.Functor.id (CategoryTheory.Limits.WidePushoutShape J)ᵒᵖ", "name": "CategoryTheory.Limits.widePushoutShapeOpUnop", "isProp": false, "docString": "The inverse of the unit isomorphism of the equivalence\n`widePushoutShapeOpEquiv : (WidePushoutShape J)ᵒᵖ ≌ WidePullbackShape J` ", "terms": "[\n  \"inverse\",\n  \"unit\",\n  \"isomorphism\",\n  \"equivalence\",\n  \"WidePushoutShape\",\n  \"WidePullbackShape\"\n]"}
{"type": "∀ {M : Type u_1} [inst : Add M] (c d : AddCon M), c ⊔ d = addConGen fun x y => c x y ∨ d x y", "name": "AddCon.sup_eq_addConGen", "isProp": true, "docString": "The supremum of additive congruence relations `c, d` equals the\nsmallest additive congruence relation containing the binary relation '`x` is related to `y`\nby `c` or `d`'.", "terms": "[\n  \"supremum\",\n  \"additive congruence relations\",\n  \"smallest\",\n  \"additive congruence relation\",\n  \"binary relation\",\n  \"related\"\n]"}
{"type": "{α : Type} → (ea : Computability.FinEncoding α) → Turing.TM2ComputableInTime ea ea id", "name": "Turing.idComputableInTime", "isProp": false, "docString": "A proof that the identity map on α is computable in time. ", "terms": "[\n  \"proof\",\n  \"identity map\",\n  \"computable\",\n  \"time\"\n]"}
{"type": "∀ (z : UpperHalfPlane),\n  ∃ g, ∀ (g' : Matrix.SpecialLinearGroup (Fin 2) ℤ), UpperHalfPlane.im (g' • z) ≤ UpperHalfPlane.im (g • z)", "name": "ModularGroup.exists_max_im", "isProp": true, "docString": "For `z : ℍ`, there is a `g : SL(2,ℤ)` maximizing `(g•z).im` ", "terms": "[\n  \"ℤ\",\n  \"ℍ\",\n  \".im\",\n  \"SL(2,ℤ)\",\n  \"maximizing\"\n]"}
{"type": "∀ {V : Type u_1} {W : Type u_2} {V₁ : Type u_3} [inst : SeminormedAddCommGroup V] [inst_1 : SeminormedAddCommGroup W]\n  [inst_2 : SeminormedAddCommGroup V₁] {f g : NormedAddGroupHom V W} (φ : NormedAddGroupHom V₁ V)\n  (h : NormedAddGroupHom.comp f φ = NormedAddGroupHom.comp g φ),\n  NormedAddGroupHom.NormNoninc φ → NormedAddGroupHom.NormNoninc (NormedAddGroupHom.Equalizer.lift φ h)", "name": "NormedAddGroupHom.Equalizer.lift_normNoninc", "isProp": true, "docString": "The lifting of a norm nonincreasing morphism is norm nonincreasing. ", "terms": "[\n    \"lifting\",\n    \"norm\",\n    \"nonincreasing\",\n    \"morphism\"\n]"}
{"type": "{R : Type u_1} →\n  {A : Type u_2} →\n    {B : Type u_3} →\n      {C : Type u_4} →\n        [inst : Monoid R] →\n          [inst_1 : NonUnitalNonAssocSemiring A] →\n            [inst_2 : DistribMulAction R A] →\n              [inst_3 : Star A] →\n                [inst_4 : NonUnitalNonAssocSemiring B] →\n                  [inst_5 : DistribMulAction R B] →\n                    [inst_6 : Star B] →\n                      [inst_7 : NonUnitalNonAssocSemiring C] →\n                        [inst_8 : DistribMulAction R C] →\n                          [inst_9 : Star C] → (A →⋆ₙₐ[R] B) × (A →⋆ₙₐ[R] C) ≃ (A →⋆ₙₐ[R] B × C)", "name": "NonUnitalStarAlgHom.prodEquiv", "isProp": false, "docString": "Taking the product of two maps with the same domain is equivalent to taking the product of\ntheir codomains. ", "terms": "[\n  \"product\",\n  \"maps\",\n  \"domain\",\n  \"equivalent\",\n  \"codomains\"\n]"}
{"type": "{G : Type u} →\n  [inst : Group G] →\n    (N : Subgroup G) →\n      [nN : Subgroup.Normal N] →\n        (M : Subgroup G) → [nM : Subgroup.Normal M] → N ≤ M → (G ⧸ N) ⧸ Subgroup.map (QuotientGroup.mk' N) M →* G ⧸ M", "name": "QuotientGroup.quotientQuotientEquivQuotientAux", "isProp": false, "docString": "The map from the third isomorphism theorem for groups: `(G / N) / (M / N) → G / M`. ", "terms": "[\n    \"map\",\n    \"third isomorphism theorem\",\n    \"groups\",\n    \"G / N\",\n    \"M / N\",\n    \"G / M\"\n]"}
{"type": "(K : Type u_1) →\n  [inst : Field K] →\n    [inst_1 : NumberField K] →\n      Basis (Fin (NumberField.Units.rank K)) ℤ\n        (Additive ((↥(NumberField.ringOfIntegers K))ˣ ⧸ NumberField.Units.torsion K))", "name": "NumberField.Units.basisModTorsion", "isProp": false, "docString": "A basis of the quotient `(𝓞 K)ˣ ⧸ (torsion K)` seen as an additive ℤ-module. ", "terms": "[\n    \"basis\",\n    \"quotient\",\n    \"(𝓞 K)ˣ\",\n    \"torsion\",\n    \"additive\",\n    \"ℤ-module\"\n]"}
{"type": "{α : Type u_2} → [self : CanonicallyLinearOrderedSemifield α] → DecidableEq α", "name": "CanonicallyLinearOrderedSemifield.decidableEq", "isProp": false, "docString": "In a linearly ordered type, we assume the order relations are all decidable. ", "terms": "[\n  \"linearly ordered type\", \n  \"order relations\", \n  \"decidable\"\n]"}
{"type": "TwoP ≌ TwoP", "name": "TwoP.swapEquiv", "isProp": false, "docString": "The equivalence between `TwoP` and itself induced by `Prod.swap` both ways. ", "terms": "[\"equivalence\", \"induced\", \"Prod.swap\"]"}
{"type": "∀ {α : Type u_2} {𝕜 : Type u_3} {f g : α → 𝕜} {S : Set α} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace 𝕜]\n  [inst_2 : T1Space 𝕜] [inst_3 : Field 𝕜] [inst_4 : HasContinuousInv₀ 𝕜] [inst_5 : ContinuousMul 𝕜],\n  IsPreconnected S →\n    ContinuousOn f S →\n      ContinuousOn g S → Set.EqOn (f ^ 2) (g ^ 2) S → (∀ {x : α}, x ∈ S → g x ≠ 0) → Set.EqOn f g S ∨ Set.EqOn f (-g) S", "name": "IsPreconnected.eq_or_eq_neg_of_sq_eq", "isProp": true, "docString": "If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then either `f = g` or `f = -g` on\n`S`. ", "terms": "[\n    \"functions\", \n    \"continuous\", \n    \"preconnected set\", \n    \"square\", \n    \"not equal\", \n    \"element of\", \n    \"equal\"\n]"}
{"type": "{α : Type u_1} →\n  [inst : TopologicalSpace α] → [inst_1 : GroupWithZero α] → [inst_2 : ContinuousMul α] → (c : α) → c ≠ 0 → α ≃ₜ α", "name": "Homeomorph.mulLeft₀", "isProp": false, "docString": "Left multiplication by a nonzero element in a `GroupWithZero` with continuous multiplication\nis a homeomorphism of the underlying type. ", "terms": "[\n    \"Left multiplication\",\n    \"nonzero element\",\n    \"GroupWithZero\",\n    \"continuous multiplication\",\n    \"homeomorphism\",\n    \"underlying type\"\n]"}
{"type": "Type u_1 → Type", "name": "CategoryTheory.SingleObj", "isProp": false, "docString": "Abbreviation that allows writing `CategoryTheory.SingleObj` rather than `Quiver.SingleObj`.\n", "terms": "[\"Abbreviation\", \"CategoryTheory.SingleObj\", \"Quiver.SingleObj\"]"}
{"type": "∀ (x : ℝ),\n  Filter.Tendsto (fun n => Real.pi * x * Finset.prod (Finset.range n) fun j => 1 - x ^ 2 / (↑j + 1) ^ 2) Filter.atTop\n    (nhds (Real.sin (Real.pi * x)))", "name": "Real.tendsto_euler_sin_prod", "isProp": true, "docString": "Euler's infinite product formula for the real sine function. ", "terms": "[\n    \"Euler's infinite product formula\",\n    \"real sine function\"\n]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  {p₁ p₂ p₃ : P},\n  EuclideanGeometry.oangle p₁ p₂ p₃ = ↑(Real.pi / 2) →\n    Real.Angle.cos (EuclideanGeometry.oangle p₂ p₃ p₁) = dist p₃ p₂ / dist p₁ p₃", "name": "EuclideanGeometry.cos_oangle_right_of_oangle_eq_pi_div_two", "isProp": true, "docString": "The cosine of an angle in a right-angled triangle as a ratio of sides. ", "terms": "[\n  \"cosine\",\n  \"angle\",\n  \"right-angled triangle\",\n  \"ratio\",\n  \"sides\"\n]"}
{"type": "∀ {X : Type u_2} [inst : EMetricSpace X] {m₁ m₂ : ENNReal → ENNReal} {c : ENNReal},\n  c ≠ ⊤ →\n    c ≠ 0 →\n      m₁ ≤ᶠ[nhdsWithin 0 (Set.Ici 0)] c • m₂ →\n        MeasureTheory.OuterMeasure.mkMetric m₁ ≤ c • MeasureTheory.OuterMeasure.mkMetric m₂", "name": "MeasureTheory.OuterMeasure.mkMetric_mono_smul", "isProp": true, "docString": "If `c ∉ {0, ∞}` and `m₁ d ≤ c * m₂ d` for `d < ε` for some `ε > 0`\n(we use `≤ᶠ[𝓝[≥] 0]` to state this), then `mkMetric m₁ hm₁ ≤ c • mkMetric m₂ hm₂`. ", "terms": "[\n  \"not an element of\",\n  \"set\",\n  \"multiplication\",\n  \"less than or equal to\",\n  \"less than\",\n  \"greater than\",\n  \"neighborhood\",\n  \"metric\",\n  \"scalar multiplication\"\n]"}
{"type": "{L : FirstOrder.Language} →\n  {L' : FirstOrder.Language} → {α : Type u'} → (L ≃ᴸ L') → FirstOrder.Language.Term L α ≃ FirstOrder.Language.Term L' α", "name": "FirstOrder.Language.Lequiv.onTerm", "isProp": false, "docString": "Maps a term's symbols along a language equivalence. ", "terms": "[\n  \"Maps\",\n  \"Term's symbols\",\n  \"Language equivalence\"\n]"}
{"type": "{α : Type u_1} → [inst : SemilatticeSup α] → (ℕ → α) → ℕ →o α", "name": "partialSups", "isProp": false, "docString": "The monotone sequence whose value at `n` is the supremum of the `f m` where `m ≤ n`. ", "terms": "[\n    \"Monotone sequence\",\n    \"Value\",\n    \"Supremum\"\n]"}
{"type": "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x y : V},\n  x ≠ 0 →\n    y ≠ 0 →\n      Real.sin (InnerProductGeometry.angle x (x - y) + InnerProductGeometry.angle y (y - x)) =\n        Real.sin (InnerProductGeometry.angle x y)", "name": "InnerProductGeometry.sin_angle_sub_add_angle_sub_rev_eq_sin_angle", "isProp": true, "docString": "The sine of the sum of two angles in a possibly degenerate\ntriangle (where two given sides are nonzero), vector angle form. ", "terms": "[\n    \"sine\",\n    \"sum\",\n    \"angles\",\n    \"degenerate triangle\",\n    \"sides\",\n    \"nonzero\",\n    \"vector\",\n    \"angle form\"\n]"}
{"type": "∀ (f : C(↑unitInterval, ℝ)), Filter.Tendsto (fun n => bernsteinApproximation n f) Filter.atTop (nhds f)", "name": "bernsteinApproximation_uniform", "isProp": true, "docString": "The Bernstein approximations\n```\n∑ k : Fin (n+1), f (k/n : ℝ) * n.choose k * x^k * (1-x)^(n-k)\n```\nfor a continuous function `f : C([0,1], ℝ)` converge uniformly to `f` as `n` tends to infinity.\n\nThis is the proof given in [Richard Beals' *Analysis, an introduction*][beals-analysis], §7D,\nand reproduced on wikipedia.\n", "terms": "[\n  \"Bernstein approximations\",\n  \"∑\",\n  \"Fin\",\n  \"n+1\",\n  \"k/n\",\n  \"ℝ\",\n  \"n.choose\",\n  \"x^k\",\n  \"(1-x)^(n-k)\",\n  \"continuous function\",\n  \"C([0,1], ℝ)\",\n  \"converge uniformly\",\n  \"n tends to infinity\"\n]"}
{"type": "ZFSet ≃ { s // Small.{u, u + 1} ↑s }", "name": "ZFSet.toSet_equiv", "isProp": false, "docString": "`ZFSet.toSet` as an equivalence. ", "terms": "[\"ZFSet.toSet\", \"equivalence\"]"}
{"type": "∀ {ι : Type u_1} {X : Type u_2} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {u : ι → Set X},\n  (∀ (i : ι), IsOpen (u i)) →\n    (∀ (x : X), Set.Finite {i | x ∈ u i}) →\n      ⋃ i, u i = Set.univ → ∃ v, Set.iUnion v = Set.univ ∧ (∀ (i : ι), IsClosed (v i)) ∧ ∀ (i : ι), v i ⊆ u i", "name": "exists_iUnion_eq_closed_subset", "isProp": true, "docString": "Shrinking lemma. A point-finite open cover of a closed subset of a normal space can be \"shrunk\"\nto a new closed cover so that each of the new closed sets is contained in the corresponding\noriginal open set. See also `exists_iUnion_eq_closure_subset` for a stronger statement. ", "terms": "[\n  \"Shrinking lemma\",\n  \"point-finite\",\n  \"open cover\",\n  \"closed subset\",\n  \"normal space\",\n  \"closed cover\",\n  \"closed sets\",\n  \"open set\",\n  \"exists_iUnion_eq_closure_subset\",\n  \"stronger statement\"\n]"}
{"type": "{V : Type u_1} → [inst : Quiver V] → (H : WideSubquiver V) → Quiver (WideSubquiver.toType V H)", "name": "WideSubquiver.quiver", "isProp": false, "docString": "A wide subquiver viewed as a quiver on its own. ", "terms": "[\"wide subquiver\", \"quiver\"]"}
{"type": "∀ {ι : Type u_1} {α : Type u_2} {s : ι → Set α} (hs : IndexedPartition s) (x : IndexedPartition.Quotient hs),\n  IndexedPartition.index hs (Quotient.out' x) = IndexedPartition.index hs ((IndexedPartition.out hs) x)", "name": "IndexedPartition.index_out'", "isProp": true, "docString": "The indices of `Quotient.out'` and `IndexedPartition.out` are equal. ", "terms": "[\"indices\", \"Quotient.out\", \"IndexedPartition.out\", \"equal\"]"}
{"type": "{R : Type u} →\n  [inst : Ring R] →\n    {Q : TypeMax} →\n      [inst_1 : AddCommGroup Q] →\n        [inst_2 : Module R Q] →\n          {M N : Type (max u v)} →\n            [inst_3 : AddCommGroup M] →\n              [inst_4 : AddCommGroup N] →\n                [inst_5 : Module R M] →\n                  [inst_6 : Module R N] →\n                    (i : M →ₗ[R] N) →\n                      {f : M →ₗ[R] Q} →\n                        [inst_7 : Fact (Function.Injective ⇑i)] →\n                          {y : N} → ↥(Module.Baer.supExtensionOfMaxSingleton i f y) → R", "name": "Module.Baer.ExtensionOfMaxAdjoin.snd", "isProp": false, "docString": "If `x ∈ M ⊔ ⟨y⟩`, then `x = m + r • y`, `snd` pick an arbitrary such `r`.", "terms": "[\n  \"element of\",\n  \"set\",\n  \"direct sum\",\n  \"generated subgroup\",\n  \"equals\",\n  \"plus\",\n  \"scalar multiplication\",\n  \"pick\",\n  \"arbitrary\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {D : Type u'} →\n      [inst_1 : CategoryTheory.Category.{v', u'} D] → [inst_2 : IsEmpty C] → (F G : CategoryTheory.Functor C D) → F ≅ G", "name": "CategoryTheory.Functor.isEmptyExt", "isProp": false, "docString": "Any two functors out of an empty category are isomorphic. ", "terms": "[\n    \"functors\",\n    \"empty category\",\n    \"isomorphic\"\n]"}
{"type": "(R : Type u) → [inst : CommRing R] → TopCat.PrelocalPredicate (AlgebraicGeometry.StructureSheaf.Localizations R)", "name": "AlgebraicGeometry.StructureSheaf.isFractionPrelocal", "isProp": false, "docString": "The predicate `IsFraction` is \"prelocal\",\nin the sense that if it holds on `U` it holds on any open subset `V` of `U`.\n", "terms": "[\n  \"predicate\",\n  \"IsFraction\",\n  \"prelocal\",\n  \"holds\",\n  \"open subset\"\n]"}
{"type": "∀ {M : Type u_1} [inst : AddMonoid M] {ι : Sort u_3} {s : ι → Set M},\n  (∀ (y : ι), IsAddSubmonoid (s y)) → IsAddSubmonoid (Set.iInter s)", "name": "IsAddSubmonoid.iInter", "isProp": true, "docString": "The intersection of an indexed set of `AddSubmonoid`s of an `AddMonoid` `M` is\nan `AddSubmonoid` of `M`.", "terms": "[\n  \"intersection\",\n  \"indexed set\",\n  \"AddSubmonoid\",\n  \"AddMonoid\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    (I : CategoryTheory.Limits.MultispanIndex C) →\n      [inst_1 : CategoryTheory.Limits.HasMulticoequalizer I] →\n        (b : I.R) → CategoryTheory.Limits.MultispanIndex.right I b ⟶ CategoryTheory.Limits.multicoequalizer I", "name": "CategoryTheory.Limits.Multicoequalizer.π", "isProp": false, "docString": "The canonical map from the multiequalizer to the objects on the left. ", "terms": "[\n    \"canonical map\",\n    \"multiequalizer\",\n    \"objects\"\n]"}
{"type": "(Turing.PartrecToTM2.Γ' → Bool) →\n  Turing.PartrecToTM2.K' → Turing.PartrecToTM2.K' → Turing.PartrecToTM2.Λ' → Turing.PartrecToTM2.Λ'", "name": "Turing.PartrecToTM2.move₂", "isProp": false, "docString": "Move elements from `k₁` to `k₂` without reversion, by performing a double move via the `rev`\nstack. ", "terms": "[\"elements\", \"reversion\", \"double move\", \"stack\"]"}
{"type": "∀ {R : Type u_3} {M : Type u_4} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Invertible 2] (Q : QuadraticForm R M),\n  QuadraticForm.Anisotropic Q → BilinForm.Nondegenerate (QuadraticForm.associated' Q)", "name": "QuadraticForm.nondegenerate_of_anisotropic", "isProp": true, "docString": "The associated bilinear form of an anisotropic quadratic form is nondegenerate. ", "terms": "[\n  \"associated\",\n  \"bilinear form\",\n  \"anisotropic\",\n  \"quadratic form\",\n  \"nondegenerate\"\n]"}
{"type": "{α : Type u} → {β : Type v} → (α →. β) → Filter α → Filter β → Prop", "name": "Filter.PTendsto", "isProp": false, "docString": "Generic \"limit of a partial function\" predicate. `PTendsto r l₁ l₂` asserts that for every\n`l₂`-neighborhood `a`, the `p`-core of `a` is an `l₁`-neighborhood. One generalization of\n`Filter.Tendsto` to partial function. ", "terms": "[\n    \"limit of a partial function\",\n    \"predicate\",\n    \"neighborhood\",\n    \"core\",\n    \"Filter.Tendsto\",\n    \"partial function\"\n]"}
{"type": "{R : Type u} →\n  {S : Type v} →\n    [inst : NonUnitalNonAssocSemiring R] →\n      [inst_1 : NonUnitalNonAssocSemiring S] →\n        {F : Type u_1} →\n          [inst_2 : NonUnitalRingHomClass F R S] →\n            (s : NonUnitalSubsemiring R) → (f : F) → Function.Injective ⇑f → ↥s ≃+* ↥(NonUnitalSubsemiring.map f s)", "name": "NonUnitalSubsemiring.equivMapOfInjective", "isProp": false, "docString": "A non-unital subsemiring is isomorphic to its image under an injective function ", "terms": "[\n    \"non-unital\",\n    \"subsemiring\",\n    \"isomorphic\",\n    \"image\",\n    \"injective function\"\n]"}
{"type": "{Y Z : Type u} → {g h : Y ⟶ Z} → CategoryTheory.Limits.LimitCone (CategoryTheory.Limits.parallelPair g h)", "name": "CategoryTheory.Limits.Types.equalizerLimit", "isProp": false, "docString": "Show that the subtype `{x : Y // g x = h x}` is an equalizer for the pair `(g,h)`. ", "terms": "[\n    \"subtype\", \n    \"equalizer\", \n    \"pair\"\n]"}
{"type": "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V},\n  Orientation.oangle o x y = ↑(Real.pi / 2) → ‖y‖ / Real.Angle.cos (Orientation.oangle o (x + y) y) = ‖x + y‖", "name": "Orientation.norm_div_cos_oangle_add_left_of_oangle_eq_pi_div_two", "isProp": true, "docString": "A side of a right-angled triangle divided by the cosine of the adjacent angle equals the\nhypotenuse. ", "terms": "[\n  \"side\",\n  \"right-angled triangle\",\n  \"divided by\",\n  \"cosine\",\n  \"adjacent angle\",\n  \"equals\",\n  \"hypotenuse\"\n]"}
{"type": "Mathlib.Meta.Positivity.PositivityExt", "name": "Tactic.evalInitialBound", "isProp": false, "docString": "Extension for the `positivity` tactic: `SzemerediRegularity.initialBound` is always positive. ", "terms": "[\n    \"Extension\",\n    \"positivity\",\n    \"tactic\",\n    \"SzemerediRegularity.initialBound\",\n    \"positive\"\n]"}
{"type": "∀ (α : Type u) [inst : MetricSpace α] [inst_1 : TopologicalSpace.SeparableSpace α], Isometry (kuratowskiEmbedding α)", "name": "kuratowskiEmbedding.isometry", "isProp": true, "docString": "The Kuratowski embedding is an isometry.\nTheorem 2.1 of [Assaf Naor, *Metric Embeddings and Lipschitz Extensions*][Naor-2015]. ", "terms": "[\n  \"Kuratowski embedding\",\n  \"isometry\",\n  \"Theorem\",\n  \"Metric Embeddings\",\n  \"Lipschitz Extensions\"\n]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P (n + 2)) {i₁ i₂ : Fin (n + 3)},\n  Affine.Simplex.mongePoint s ∈ Affine.Simplex.mongePlane s i₁ i₂", "name": "Affine.Simplex.mongePoint_mem_mongePlane", "isProp": true, "docString": "The Monge point lies in the Monge planes. ", "terms": "[\"Monge point\", \"Monge planes\"]"}
{"type": "∀ {α : Type u_1} [inst : CircularPreorder α] {a b c : α}, sbtw a b c → btw a b c", "name": "SBtw.sbtw.btw", "isProp": true, "docString": "**Alias** of `btw_of_sbtw`.", "terms": "[\"Alias\", \"btw_of_sbtw\"]"}
{"type": "∀ {t : Type u → Type u} [inst : Traversable t] [self : LawfulTraversable t] {α β : Type u} (f : α → β) (x : t α),\n  traverse (pure ∘ f) x = id.mk (f <$> x)", "name": "LawfulTraversable.traverse_eq_map_id", "isProp": true, "docString": "An axiom for `traverse` involving `pure : β → Id β`. ", "terms": "[\n\"Axiom\",\n\"traverse\",\n\"pure\",\n\"β\",\n\"Id\",\n\"→\"\n]"}
{"type": "{M : Type u_5} → {N : Type u_6} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → [inst_2 : Unique N] → M × N ≃+ M", "name": "AddEquiv.prodUnique", "isProp": false, "docString": "Multiplying by the trivial monoid doesn't change the structure.", "terms": "[\n    \"Multiplying\",\n    \"Trivial Monoid\",\n    \"Structure\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_4} {v : ι → E},\n  (∀ (i : ι), v i ≠ 0) → (∀ (i j : ι), i ≠ j → inner (v i) (v j) = 0) → LinearIndependent 𝕜 v", "name": "linearIndependent_of_ne_zero_of_inner_eq_zero", "isProp": true, "docString": "A family of vectors is linearly independent if they are nonzero\nand orthogonal. ", "terms": "[\n    \"family of vectors\",\n    \"linearly independent\",\n    \"nonzero\",\n    \"orthogonal\"\n]"}
{"type": "{α : Type u_1} → {β : Type u_2} → [inst : AddCommMonoid α] → [inst : TopologicalSpace α] → (β → α) → α → Prop", "name": "HasSum", "isProp": false, "docString": "Infinite sum on a topological monoid\n\nThe `atTop` filter on `Finset β` is the limit of all finite sets towards the entire type. So we sum\nup bigger and bigger sets. This sum operation is invariant under reordering. In particular,\nthe function `ℕ → ℝ` sending `n` to `(-1)^n / (n+1)` does not have a\nsum for this definition, but a series which is absolutely convergent will have the correct sum.\n\nThis is based on Mario Carneiro's\n[infinite sum `df-tsms` in Metamath](http://us.metamath.org/mpeuni/df-tsms.html).\n\nFor the definition or many statements, `α` does not need to be a topological monoid. We only add\nthis assumption later, for the lemmas where it is relevant.\n", "terms": "[\n    \"Infinite sum\",\n    \"Topological monoid\",\n    \"atTop filter\",\n    \"Finset β\",\n    \"Limit\",\n    \"Finite sets\",\n    \"Entire type\",\n    \"Sum operation\",\n    \"Invariant\",\n    \"Reordering\",\n    \"Function\",\n    \"ℕ → ℝ\",\n    \"(-1)^n / (n+1)\",\n    \"Series\",\n    \"Absolutely convergent\",\n    \"Mario Carneiro\",\n    \"Infinite sum `df-tsms` in Metamath\",\n    \"Definition\",\n    \"Statements\",\n    \"Assumption\",\n    \"Lemmas\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} [inst : PartialOrder β] (r : α → α → Prop) [inst_1 : IsSymm α r] {f : α → β},\n  (∀ (a b : α), r a b → f a ≤ f b) → ∀ {a b : α}, r a b → f a = f b", "name": "rel_imp_eq_of_rel_imp_le", "isProp": true, "docString": "A symmetric relation implies two values are equal, when it implies they're less-equal.  ", "terms": "[\"symmetric relation\", \"values\", \"equal\", \"less-equal\"]"}
{"type": "(A B : TopCat) →\n  CategoryTheory.Grpd.of\n      (↑(FundamentalGroupoid.fundamentalGroupoidFunctor.obj A) ×\n        ↑(FundamentalGroupoid.fundamentalGroupoidFunctor.obj B)) ≅\n    FundamentalGroupoid.fundamentalGroupoidFunctor.obj (TopCat.of (↑A × ↑B))", "name": "FundamentalGroupoidFunctor.prodIso", "isProp": false, "docString": "Shows `prodToProdTop` is an isomorphism, whose inverse is precisely the product\nof the induced left and right projections.\n", "terms": "[\n    \"isomorphism\",\n    \"inverse\",\n    \"product\",\n    \"induced\",\n    \"left projection\",\n    \"right projection\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.NonPreadditiveAbelian C] → {X Y : C} → Neg (X ⟶ Y)", "name": "CategoryTheory.NonPreadditiveAbelian.hasNeg", "isProp": false, "docString": "Negation of morphisms in a `NonPreadditiveAbelian` category. ", "terms": "[\n  \"Negation\",\n  \"Morphisms\",\n  \"NonPreadditiveAbelian\",\n  \"Category\"\n]"}
{"type": "{ι : Type u_1} →\n  (V : Type u) →\n    [inst : CategoryTheory.Category.{v, u} V] →\n      [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] →\n        (c : ComplexShape ι) → ι → CategoryTheory.Functor (HomologicalComplex V c) V", "name": "HomologicalComplex.eval", "isProp": false, "docString": "The functor picking out the `i`-th object of a complex. ", "terms": "[\"functor\", \"object\", \"complex\"]"}
{"type": "(R : Type u_1) → (M : Type u_2) → [inst : CommSemiring R] → [inst_1 : AddCommMonoid M] → [inst : Module R M] → Prop", "name": "Module.IsTorsion", "isProp": false, "docString": "A torsion module is a module where every element is `a`-torsion for some non-zero-divisor `a`.\n", "terms": "[\n    \"Torsion Module\",\n    \"Module\",\n    \"Element\",\n    \"Non-zero-divisor\"\n]"}
{"type": "{J : Type v} →\n  [inst : CategoryTheory.SmallCategory J] →\n    (F : CategoryTheory.Functor J MonCat) →\n      [inst_1 : CategoryTheory.IsFiltered J] → CategoryTheory.Limits.IsColimit (MonCat.FilteredColimits.colimitCocone F)", "name": "MonCat.FilteredColimits.colimitCoconeIsColimit", "isProp": false, "docString": "The proposed colimit cocone is a colimit in `MonCat`. ", "terms": "[\n    \"proposed\",\n    \"colimit\",\n    \"cocone\",\n    \"MonCat\"\n]"}
{"type": "{R : Type u} → [inst : Semiring R] → Polynomial R → ℕ → R → Polynomial R", "name": "Polynomial.update", "isProp": false, "docString": "Replace the coefficient of a `p : R[X]` at a given degree `n : ℕ`\nby a given value `a : R`. If `a = 0`, this is equal to `p.erase n`\nIf `p.natDegree < n` and `a ≠ 0`, this increases the degree to `n`.  ", "terms": "[\n    \"coefficient\",\n    \"degree\",\n    \"value\",\n    \"erase\",\n    \"natDegree\",\n    \"increases\"\n]"}
{"type": "∀ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R), NonUnitalSubring.closure ↑s = s", "name": "NonUnitalSubring.closure_eq", "isProp": true, "docString": "Closure of a `NonUnitalSubring` `S` equals `S`. ", "terms": "[\n    \"Closure\",\n    \"NonUnitalSubring\",\n    \"equals\"\n]"}
{"type": "{G : Type u_1} → [inst : Group G] → [inst_1 : Group.IsNilpotent G] → Group.nilpotencyClass G ≤ 1 → CommGroup G", "name": "commGroupOfNilpotencyClass", "isProp": false, "docString": "Groups with nilpotency class at most one are abelian ", "terms": "[\"Groups\", \"nilpotency class\", \"at most\", \"one\", \"abelian\"]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    (Y : C) → [h : (X : C) → Unique (X ⟶ Y)] → CategoryTheory.Limits.IsTerminal Y", "name": "CategoryTheory.Limits.IsTerminal.ofUnique", "isProp": false, "docString": "An object `Y` is terminal if for every `X` there is a unique morphism `X ⟶ Y`\n(as an instance). ", "terms": "[\n  \"object\",\n  \"terminal\",\n  \"every\",\n  \"unique\",\n  \"morphism\",\n  \"instance\"\n]"}
{"type": "{α : Type u_1} →\n  {β : Type u_2} →\n    {m m0 : MeasurableSpace α} →\n      {μ : MeasureTheory.Measure α} →\n        [inst : TopologicalSpace β] → (f : α → β) → MeasureTheory.AEStronglyMeasurable' m f μ → α → β", "name": "MeasureTheory.AEStronglyMeasurable'.mk", "isProp": false, "docString": "An `m`-strongly measurable function almost everywhere equal to `f`. ", "terms": "[\"strongly measurable function\", \"almost everywhere equal\"]"}
{"type": "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  (f : BoundedContinuousFunction X ℝ) (e : C(X, Y)),\n  ClosedEmbedding ⇑e → ∃ g, ‖g‖ = ‖f‖ ∧ BoundedContinuousFunction.compContinuous g e = f", "name": "BoundedContinuousFunction.exists_extension_norm_eq_of_closedEmbedding'", "isProp": true, "docString": "**Tietze extension theorem** for real-valued bounded continuous maps, a version with a closed\nembedding and bundled composition. If `e : C(X, Y)` is a closed embedding of a topological space\ninto a normal topological space and `f : X →ᵇ ℝ` is a bounded continuous function, then there exists\na bounded continuous function `g : Y →ᵇ ℝ` of the same norm such that `g ∘ e = f`. ", "terms": "[\n    \"Tietze extension theorem\",\n    \"real-valued\",\n    \"bounded\",\n    \"continuous maps\",\n    \"closed embedding\",\n    \"bundled composition\",\n    \"topological space\",\n    \"normal topological space\",\n    \"bounded continuous function\",\n    \"norm\",\n    \"function composition\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} {M : Type u_5} [inst : CommMonoid M] {f : α → M} {g : β → α},\n  Function.Injective g → (finprod fun i => finprod fun h => f i) = finprod fun j => f (g j)", "name": "finprod_mem_range", "isProp": true, "docString": "The product of `f y` over `y ∈ Set.range g` equals the product of `f (g i)` over all `i`\nprovided that `g` is injective. ", "terms": "[\n    \"product\", \n    \"Set.range\", \n    \"equals\", \n    \"injective\"\n]"}
{"type": "∀ {R : Type u} [inst : CommRing R] (M N : ModuleCat R),\n  (CategoryTheory.ihom.ev M).app N = (TensorProduct.uncurry R (↑M) (↑M →ₗ[R] ↑N) ↑N) (LinearMap.flip LinearMap.id)", "name": "ModuleCat.ihom_ev_app", "isProp": true, "docString": "Describes the counit of the adjunction `M ⊗ - ⊣ Hom(M, -)`. Given an `R`-module `N` this\nshould give a map `M ⊗ Hom(M, N) ⟶ N`, so we flip the order of the arguments in the identity map\n`Hom(M, N) ⟶ (M ⟶ N)` and uncurry the resulting map `M ⟶ Hom(M, N) ⟶ N.` ", "terms": "[\n  \"counit\",\n  \"adjunction\",\n  \"R-module\",\n  \"map\",\n  \"identity map\",\n  \"uncurry\",\n  \"Hom\",\n  \"arguments\",\n  \"order\"\n]"}
{"type": "∀ {α : Type u_1} {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n  [inst_2 : FiniteDimensional ℝ E] {f : α → E}, (Summable fun x => ‖f x‖) ↔ Summable f", "name": "summable_norm_iff", "isProp": true, "docString": "In a finite dimensional vector space over `ℝ`, the series `∑ x, ‖f x‖` is unconditionally\nsummable if and only if the series `∑ x, f x` is unconditionally summable. One implication holds in\nany complete normed space, while the other holds only in finite dimensional spaces. ", "terms": "[\n    \"finite dimensional\",\n    \"vector space\",\n    \"ℝ\",\n    \"series\",\n    \"unconditionally summable\",\n    \"implication\",\n    \"complete normed space\",\n    \"finite dimensional spaces\"\n]"}
{"type": "∀ {f g : ℝ → ℝ} {a b : ℝ} {μ : MeasureTheory.Measure ℝ},\n  a ≤ b →\n    IntervalIntegrable f μ a b →\n      IntervalIntegrable g μ a b →\n        f ≤ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ (Set.Ioc a b))] g →\n          ↑↑(MeasureTheory.Measure.restrict μ (Set.Ioc a b)) {x | f x < g x} ≠ 0 →\n            ∫ (x : ℝ) in a..b, f x ∂μ < ∫ (x : ℝ) in a..b, g x ∂μ", "name": "intervalIntegral.integral_lt_integral_of_ae_le_of_measure_setOf_lt_ne_zero", "isProp": true, "docString": "If `f` and `g` are two functions that are interval integrable on `a..b`, `a ≤ b`,\n`f x ≤ g x` for a.e. `x ∈ Set.Ioc a b`, and `f x < g x` on a subset of `Set.Ioc a b`\nof nonzero measure, then `∫ x in a..b, f x ∂μ < ∫ x in a..b, g x ∂μ`. ", "terms": "[\n\"functions\",\n\"interval integrable\",\n\"≤\",\n\"Set.Ioc\",\n\"subset\",\n\"nonzero measure\",\n\"∫\",\n\"in\",\n\"<\",\n\"∂μ\"\n]"}
{"type": "(m : Type u_1) → (n : Type u_2) → (R : Type u_3) → [inst : CommSemiring R] → Matrix m n (MvPolynomial (m × n) R)", "name": "Matrix.mvPolynomialX", "isProp": false, "docString": "The matrix with variable `X (i,j)` at location `(i,j)`. ", "terms": "[\n  \"matrix\", \n  \"variable\", \n  \"location\"\n]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace ℝ V]\n  [inst_2 : StrictConvexSpace ℝ V] [inst_3 : PseudoMetricSpace P] [inst_4 : NormedAddTorsor V P] {p p₁ p₂ p₃ : P}\n  {r : ℝ}, Collinear ℝ {p₁, p₂, p₃} → dist p₁ p = r → dist p₂ p ≤ r → dist p₃ p = r → p₁ ≠ p₃ → Wbtw ℝ p₁ p₂ p₃", "name": "Collinear.wbtw_of_dist_eq_of_dist_le", "isProp": true, "docString": "Given three collinear points, two (not equal) with distance `r` from `p` and one with\ndistance at most `r` from `p`, the third point is weakly between the other two points. ", "terms": "[\n    \"collinear points\",\n    \"distance\",\n    \"weakly between\"\n]"}
{"type": "{ι : Type u_1} → (ι → Type u_2) → Type (max u_1 u_2)", "name": "Hamming", "isProp": false, "docString": "Type synonym for a Pi type which inherits the usual algebraic instances, but is equipped with\nthe Hamming metric and norm, instead of `Pi.normedAddCommGroup` which uses the sup norm. ", "terms": "[\n    \"Type synonym\",\n    \"Pi type\",\n    \"algebraic instances\",\n    \"Hamming metric\",\n    \"norm\",\n    \"Pi.normedAddCommGroup\",\n    \"sup norm\"\n]"}
{"type": "∀ {α : Type u_2} [inst : CancelCommMonoidWithZero α] [self : NormalizationMonoid α] {a b : α},\n  a ≠ 0 → b ≠ 0 → normUnit (a * b) = normUnit a * normUnit b", "name": "NormalizationMonoid.normUnit_mul", "isProp": true, "docString": "The proposition that `normUnit` respects multiplication of non-zero elements. ", "terms": "[\n    \"Proposition\",\n    \"Norm\",\n    \"Respects\",\n    \"Multiplication\",\n    \"Non-zero elements\"\n]"}
{"type": "∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f₀ f₁ : C(X, Y)}\n  (F : ContinuousMap.Homotopy f₀ f₁), Continuous ⇑F", "name": "ContinuousMap.Homotopy.continuous", "isProp": true, "docString": "Deprecated. Use `map_continuous` instead. ", "terms": "[]"}
{"type": "∀ {α : Type u} (s : Set α) [inst : Countable ↑s], Set.Countable s", "name": "Set.to_countable", "isProp": true, "docString": "Prove `Set.Countable` from a `Countable` instance on the subtype. ", "terms": "[\n  \"Set.Countable\",\n  \"Countable\",\n  \"instance\",\n  \"subtype\"\n]"}
{"type": "(R : Type u) →\n  [inst : CommRing R] →\n    R →\n      (g : R) →\n        (U : TopologicalSpace.Opens ↑(AlgebraicGeometry.PrimeSpectrum.Top R)) →\n          (∀ x ∈ U, g ∈ Ideal.primeCompl x.asIdeal) →\n            ↑((AlgebraicGeometry.Spec.structureSheaf R).val.obj (Opposite.op U))", "name": "AlgebraicGeometry.StructureSheaf.const", "isProp": false, "docString": "The section of `structureSheaf R` on an open `U` sending each `x ∈ U` to the element\n`f/g` in the localization of `R` at `x`. ", "terms": "[\n    \"section\",\n    \"structureSheaf\",\n    \"open\",\n    \"element\",\n    \"localization\"\n]"}
{"type": "(L : FirstOrder.Language) → {α : Type u'} → Set α → FirstOrder.Language.Theory (FirstOrder.Language.withConstants L α)", "name": "FirstOrder.Language.distinctConstantsTheory", "isProp": false, "docString": "A theory indicating that each of a set of constants is distinct. ", "terms": "[\"theory\", \"constants\", \"distinct\", \"set\"]"}
{"type": "∀ {α : Type u_1} {ι : Type u_2} {E : Type u_3} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\n  [inst : NormedAddCommGroup E] {p : ENNReal} [hp : Fact (1 ≤ p)] {f : ι → ↥(MeasureTheory.Lp E p)}\n  {g : ↥(MeasureTheory.Lp E p)} {l : Filter ι},\n  Filter.Tendsto f l (nhds g) → MeasureTheory.TendstoInMeasure μ (fun n => ↑↑(f n)) l ↑↑g", "name": "MeasureTheory.tendstoInMeasure_of_tendsto_Lp", "isProp": true, "docString": "Convergence in Lp implies convergence in measure. ", "terms": "[\"Convergence\", \"Lp\", \"convergence in measure\"]"}
{"type": "(ℝ → ℝ) → Prop", "name": "AkraBazziRecurrence.GrowsPolynomially", "isProp": false, "docString": "The growth condition that the function `g` must satisfy for the Akra-Bazzi theorem to apply.\nIt roughly states that `c₁ g(n) ≤ g(u) ≤ c₂ g(n)`, for `u` between `b*n` and `n` for any\nconstant `b ∈ (0,1)`. ", "terms": "[\n    \"Growth condition\",\n    \"Function\",\n    \"Akra-Bazzi theorem\",\n    \"Apply\",\n    \"States\",\n    \"Constant\",\n    \"Between\"\n]"}
{"type": "{α : Type u} → {β : Type v} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → Set α → Prop", "name": "MonotoneOn", "isProp": false, "docString": "A function `f` is monotone on `s` if, for all `a, b ∈ s`, `a ≤ b` implies `f a ≤ f b`. ", "terms": "[\n  \"function\",\n  \"monotone\",\n  \"for all\",\n  \"implies\"\n]"}
{"type": "∀ {α : Type u} [inst : TopologicalSpace α] {p : α → Prop} {a : α},\n  (∀ᶠ (y : α) in nhds a, p y) → ∀ᶠ (y : α) in nhds a, ∀ᶠ (x : α) in nhds y, p x", "name": "Filter.Eventually.eventually_nhds", "isProp": true, "docString": "If a predicate is true in a neighbourhood of `a`, then for `y` sufficiently close\nto `a` this predicate is true in a neighbourhood of `y`. ", "terms": "[\"predicate\", \"true\", \"neighbourhood\", \"sufficiently close\"]"}
{"type": "{M : Type u_4} →\n  {N : Type u_5} →\n    [inst : Semigroup M] →\n      [inst_1 : Semigroup N] →\n        {s : Set M} → (f : M → N) → Subsemigroup.closure s = ⊤ → (∀ (x y : M), y ∈ s → f (x * y) = f x * f y) → M →ₙ* N", "name": "MulHom.ofDense", "isProp": false, "docString": "Let `s` be a subset of a semigroup `M` such that the closure of `s` is the whole semigroup.\nThen `MulHom.ofDense` defines a mul homomorphism from `M` asking for a proof\nof `f (x * y) = f x * f y` only for `y ∈ s`. ", "terms": "[\n  \"subset\",\n  \"semigroup\",\n  \"closure\",\n  \"whole\",\n  \"MulHom.ofDense\",\n  \"mul homomorphism\",\n  \"proof\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {X Y : C} →\n      {f : X ⟶ Y} →\n        (d : CategoryTheory.Factorisation f) → CategoryTheory.Factorisation.Hom d CategoryTheory.Factorisation.terminal", "name": "CategoryTheory.Factorisation.terminalHom", "isProp": false, "docString": "The unique morphism into `Factorisation.terminal f`. ", "terms": "[\n    \"unique\",\n    \"morphism\",\n    \"Factorisation\",\n    \"terminal\",\n    \"f\"\n]"}
{"type": "{m : Type u_1 → Type u_1} → {α : Type u_1} → (Unit → m (MLList m α)) → MLList m α", "name": "MLList.squash", "isProp": false, "docString": "Lift a monadic lazy list inside the monad to a monadic lazy list. ", "terms": "[\n  \"Lift\",\n  \"Monadic\",\n  \"Lazy list\",\n  \"Inside\",\n  \"Monad\",\n  \"Monadic lazy list\"\n]"}
{"type": "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : TopologicalSpace α] →\n      [inst_1 : TopologicalSpace β] → [inst_2 : Semiring β] → [inst_3 : TopologicalSemiring β] → C(α, β) →+* α → β", "name": "ContinuousMap.coeFnRingHom", "isProp": false, "docString": "Coercion to a function as a `RingHom`. ", "terms": "[\"Coercion\", \"Function\", \"RingHom\"]"}
{"type": "∀ {G : Type u_1} {α : Type u_3} [inst : AddGroup G] [inst_1 : AddAction G α] [inst_2 : MeasurableSpace α] {s : Set α}\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasurableSpace G] [inst_4 : MeasurableVAdd G α]\n  [inst_5 : MeasureTheory.VAddInvariantMeasure G α μ] [inst_6 : Countable G],\n  MeasureTheory.IsAddFundamentalDomain G s →\n    ∀ {f : α → ENNReal},\n      (∀ (γ : G) (x : α), f (γ +ᵥ x) = f x) → essSup f (MeasureTheory.Measure.restrict μ s) = essSup f μ", "name": "MeasureTheory.IsAddFundamentalDomain.essSup_measure_restrict", "isProp": true, "docString": "If `f` is invariant under the action of a countable additive group `G`, and `μ` is a\n`G`-invariant measure with a fundamental domain `s`, then the `ess_sup` of `f` restricted to `s`\nis the same as that of `f` on all of its domain.", "terms": "[\n    \"invariant\",\n    \"action\",\n    \"countable\",\n    \"additive group\",\n    \"G-invariant measure\",\n    \"fundamental domain\",\n    \"ess_sup\",\n    \"restricted\",\n    \"domain\"\n]"}
{"type": "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ},\n  DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Iio 0) →\n    (∃ c < 2,\n        ∃ B,\n          f =O[Bornology.cobounded ℂ ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\n            Real.exp (B * Complex.abs z ^ c)) →\n      (∀ x ≤ 0, ‖f ↑x‖ ≤ C) → (∀ x ≤ 0, ‖f (↑x * Complex.I)‖ ≤ C) → z.re ≤ 0 → z.im ≤ 0 → ‖f z‖ ≤ C", "name": "PhragmenLindelof.quadrant_III", "isProp": true, "docString": "**Phragmen-Lindelöf principle** in the third quadrant. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp (B * (abs z) ^ c)` on the open third quadrant\n  for some `c < 2`;\n* `‖f z‖` is bounded from above by a constant `C` on the boundary of the third quadrant.\n\nThen `‖f z‖` is bounded from above by the same constant on the closed third quadrant. ", "terms": "[\n    \"Phragmen-Lindelöf principle\",\n    \"third quadrant\",\n    \"function\",\n    \"differentiable\",\n    \"open third quadrant\",\n    \"continuous\",\n    \"closure\",\n    \"bounded from above\",\n    \"exp\",\n    \"abs\",\n    \"boundary\",\n    \"constant\",\n    \"closed third quadrant\"\n]"}
{"type": "(R : Type u_1) →\n  [inst : CommSemiring R] → (M : Type u_2) → [inst_1 : AddCommMonoid M] → [inst : Module R M] → Type (max u_1 u_2)", "name": "TensorAlgebra", "isProp": false, "docString": "The tensor algebra of the module `M` over the commutative semiring `R`.\n", "terms": "[\n  \"tensor algebra\",\n  \"module\",\n  \"commutative semiring\"\n]"}
{"type": "Lean.Name → Lean.Elab.Command.CommandElabM Unit", "name": "Mathlib.Deriving.Fintype.mkFintypeEnum", "isProp": false, "docString": "Derive a `Fintype` instance for enum types. These come with a `toCtorIdx` function.\n\nWe generate a more optimized instance than the one produced by `mkFintype`.\nThe strategy is to (1) create a list `enumList` of all the constructors, (2) prove that this\nis in `toCtorIdx` order, (3) show that `toCtorIdx` maps `enumList` to `List.range numCtors` to show\nthe list has no duplicates, and (4) give the `Fintype` instance, using 2 for completeness.\n\nThe proofs are all linear complexity, and the main computation is that\n`enumList.map toCtorIdx = List.range numCtors`, which is true by `refl`. ", "terms": "[\n    \"Fintype\",\n    \"enum types\",\n    \"toCtorIdx function\",\n    \"mkFintype\",\n    \"create\",\n    \"list\",\n    \"constructors\",\n    \"order\",\n    \"maps\",\n    \"List.range\",\n    \"no duplicates\",\n    \"instance\",\n    \"completeness\",\n    \"proofs\",\n    \"linear complexity\",\n    \"computation\",\n    \"enumList.map\",\n    \"true\",\n    \"refl\"\n]"}
{"type": "{α : Type u_1} →\n  [inst : Group α] →\n    {ι : Type u_2} →\n      (f : ι → Subgroup α) →\n        (H : Subgroup α) → ↥H ⧸ Subgroup.subgroupOf (⨅ i, f i) H ↪ (i : ι) → ↥H ⧸ Subgroup.subgroupOf (f i) H", "name": "Subgroup.quotientiInfSubgroupOfEmbedding", "isProp": false, "docString": "The natural embedding `H ⧸ (⨅ i, f i).subgroupOf H ↪ Π i, H ⧸ (f i).subgroupOf H`. ", "terms": "[\n    \"natural embedding\",\n    \"subgroupOf\",\n    \"Π\"\n]"}
{"type": "(X : Type u_2) → [inst : UniformSpace X] → [inst : Filter.IsCountablyGenerated (uniformity X)] → PseudoMetricSpace X", "name": "UniformSpace.pseudoMetricSpace", "isProp": false, "docString": "A `PseudoMetricSpace` instance compatible with a given `UniformSpace` structure. ", "terms": "[\n    \"PseudoMetricSpace\",\n    \"compatible\",\n    \"given\",\n    \"UniformSpace\",\n    \"structure\"\n]"}
{"type": "{α : Type u_1} →\n  {E : Set α} →\n    Set.Finite E →\n      (Indep : Set α → Prop) →\n        Indep ∅ →\n          (∀ ⦃I J : Set α⦄, Indep J → I ⊆ J → Indep I) →\n            (∀ ⦃I J : Set α⦄, Indep I → Indep J → Set.ncard I < Set.ncard J → ∃ e ∈ J, e ∉ I ∧ Indep (insert e I)) →\n              (∀ ⦃I : Set α⦄, Indep I → I ⊆ E) → IndepMatroid α", "name": "IndepMatroid.ofFinite", "isProp": false, "docString": "If `E` is finite, then any collection of subsets of `E` satisfying\nthe usual independence axioms determines a matroid ", "terms": "[\n    \"finite\",\n    \"collection\",\n    \"subsets\",\n    \"usual independence axioms\",\n    \"matroid\"\n]"}
{"type": "(N : Type u_1) → (X : Type u_2) → [inst : TopologicalSpace X] → X → Set C(N → ↑unitInterval, X)", "name": "GenLoop", "isProp": false, "docString": "The `n`-dimensional generalized loops based at `x` in a space `X` are\ncontinuous functions `I^n → X` that sends the boundary to `x`.\nWe allow an arbitrary indexing type `N` in place of `Fin n` here. ", "terms": "[\n    \"n-dimensional\",\n    \"generalized loops\",\n    \"based at\",\n    \"space\",\n    \"continuous functions\",\n    \"sends\",\n    \"boundary\",\n    \"arbitrary\",\n    \"indexing type\",\n    \"in place of\"\n]"}
{"type": "{α : Type u_1} → [inst : LT α] → α → Prop", "name": "Order.IsSuccLimit", "isProp": false, "docString": "A successor limit is a value that doesn't cover any other.\n\nIt's so named because in a successor order, a successor limit can't be the successor of anything\nsmaller. ", "terms": "[\"successor limit\", \"value\", \"cover\", \"successor order\", \"successor\", \"smaller\"]"}
{"type": "{R : Type u_1} →\n  {B : Type u_2} →\n    {F : Type u_3} →\n      {E : B → Type u_4} →\n        [inst : NontriviallyNormedField R] →\n          [inst_1 : (x : B) → AddCommMonoid (E x)] →\n            [inst_2 : (x : B) → Module R (E x)] →\n              [inst_3 : NormedAddCommGroup F] →\n                [inst_4 : NormedSpace R F] →\n                  [inst_5 : TopologicalSpace B] →\n                    [inst_6 : (x : B) → TopologicalSpace (E x)] →\n                      VectorPrebundle R F E → TopologicalSpace (Bundle.TotalSpace F E)", "name": "VectorPrebundle.totalSpaceTopology", "isProp": false, "docString": "Topology on the total space that will make the prebundle into a bundle. ", "terms": "[\n  \"Topology\",\n  \"Total Space\",\n  \"Prebundle\",\n  \"Bundle\"\n]"}
{"type": "(R : Type u1) →\n  [inst : CommRing R] →\n    {M : Type u2} →\n      [inst_1 : AddCommGroup M] →\n        [inst_2 : Module R M] →\n          {A : Type u_1} →\n            [inst_3 : Semiring A] →\n              [inst_4 : Algebra R A] → { f // ∀ (m : M), f m * f m = 0 } ≃ (ExteriorAlgebra R M →ₐ[R] A)", "name": "ExteriorAlgebra.lift", "isProp": false, "docString": "Given a linear map `f : M →ₗ[R] A` into an `R`-algebra `A`, which satisfies the condition:\n`cond : ∀ m : M, f m * f m = 0`, this is the canonical lift of `f` to a morphism of `R`-algebras\nfrom `ExteriorAlgebra R M` to `A`.\n", "terms": "[\n  \"linear map\",\n  \"R-algebra\",\n  \"satisfies\",\n  \"condition\",\n  \"canonical lift\",\n  \"morphism\",\n  \"ExteriorAlgebra\"\n]"}
{"type": "∀ {X : Type u} [inst : MetricSpace X] [inst_1 : CompactSpace X] [inst_2 : Nonempty X] {Y : Type v}\n  [inst_3 : MetricSpace Y] [inst_4 : CompactSpace Y] [inst_5 : Nonempty Y] {s : Set X} (Φ : ↑s → Y) {ε₁ ε₂ ε₃ : ℝ},\n  (∀ (x : X), ∃ y ∈ s, dist x y ≤ ε₁) →\n    (∀ (x : Y), ∃ y, dist x (Φ y) ≤ ε₃) →\n      (∀ (x y : ↑s), |dist x y - dist (Φ x) (Φ y)| ≤ ε₂) → GromovHausdorff.ghDist X Y ≤ ε₁ + ε₂ / 2 + ε₃", "name": "GromovHausdorff.ghDist_le_of_approx_subsets", "isProp": true, "docString": "If there are subsets which are `ε₁`-dense and `ε₃`-dense in two spaces, and\nisometric up to `ε₂`, then the Gromov-Hausdorff distance between the spaces is bounded by\n`ε₁ + ε₂/2 + ε₃`. ", "terms": "[\n    \"subsets\",\n    \"dense\",\n    \"spaces\",\n    \"isometric\",\n    \"Gromov-Hausdorff distance\",\n    \"bounded\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {α : Sort u_1} →\n      {X : C} →\n        (F : ⦃A : C⦄ → (f : A ⟶ X) → [inst : CategoryTheory.Mono f] → α) →\n          (∀ ⦃A B : C⦄ (f : A ⟶ X) (g : B ⟶ X) [inst_1 : CategoryTheory.Mono f] [inst_2 : CategoryTheory.Mono g]\n              (i : A ≅ B), CategoryTheory.CategoryStruct.comp i.hom g = f → F f = F g) →\n            CategoryTheory.Subobject X → α", "name": "CategoryTheory.Subobject.lift", "isProp": false, "docString": "Declare a function on subobjects of `X` by specifying a function on monomorphisms with\ncodomain `X`. ", "terms": "[\n    \"Declare\",\n    \"function\",\n    \"subobjects\",\n    \"specifying\",\n    \"monomorphisms\",\n    \"codomain\"\n]"}
{"type": "∀ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {Q Q' Q'' : QuadraticForm R M} {B B' : BilinForm R M} (h : BilinForm.toQuadraticForm B = Q' - Q)\n  (h' : BilinForm.toQuadraticForm B' = Q'' - Q') (x : CliffordAlgebra Q),\n  (CliffordAlgebra.changeForm h') ((CliffordAlgebra.changeForm h) x) =\n    (CliffordAlgebra.changeForm (_ : BilinForm.toQuadraticForm (B + B') = Q'' - Q)) x", "name": "CliffordAlgebra.changeForm_changeForm", "isProp": true, "docString": "This is [bourbaki2007][] $9 Lemma 3. ", "terms": "[]"}
{"type": "∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (a : A),\n  Function.Injective ⇑(algebraMap A B) → minpoly A ((algebraMap A B) a) = Polynomial.X - Polynomial.C a", "name": "minpoly.eq_X_sub_C_of_algebraMap_inj", "isProp": true, "docString": "If `B/A` is an injective ring extension, and `a` is an element of `A`,\nthen the minimal polynomial of `algebraMap A B a` is `X - C a`. ", "terms": "[\n  \"Injective ring extension\",\n  \"Element\",\n  \"Minimal polynomial\",\n  \"AlgebraMap\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} {F : Type u_4} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β]\n  [inst_2 : DilationClass F α β] (f : F) (x : α) (r' : ℝ),\n  Set.MapsTo (⇑f) (Metric.ball x r') (Metric.ball (f x) (↑(Dilation.ratio f) * r'))", "name": "Dilation.mapsTo_ball", "isProp": true, "docString": "A dilation maps balls to balls and scales the radius by `ratio f`. ", "terms": "[\n    \"dilation\",\n    \"maps\",\n    \"balls\",\n    \"scales\",\n    \"radius\",\n    \"ratio\"\n]"}
{"type": "CategoryTheory.Functor Locale TopCat", "name": "Locale.pt", "isProp": false, "docString": "The covariant functor `pt` from the category of locales to the category of\ntopological spaces, which sends a locale `L` to the topological space `PT L` of homomorphisms\nfrom `L` to `Prop` and a locale homomorphism `f` to a continuous function between the spaces\nof points. ", "terms": "[\n    \"covariant functor\",\n    \"category\",\n    \"locales\",\n    \"topological spaces\",\n    \"homomorphisms\",\n    \"locale homomorphism\",\n    \"continuous function\",\n    \"points\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {R : CategoryTheory.Functor Cᵒᵖ RingCat} →\n      {P Q R_1 : PresheafOfModules R} →\n        PresheafOfModules.Hom P Q → PresheafOfModules.Hom Q R_1 → PresheafOfModules.Hom P R_1", "name": "PresheafOfModules.Hom.comp", "isProp": false, "docString": "Composition of morphisms of presheaves of modules. ", "terms": "[\n    \"Composition\",\n    \"Morphisms\",\n    \"Presheaves\",\n    \"Modules\"\n]"}
{"type": "∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] (I : Ideal R) {x : R}, x ∈ I → ‖1 - x‖ < 1 → I = ⊤", "name": "Ideal.eq_top_of_norm_lt_one", "isProp": true, "docString": "An ideal which contains an element within `1` of `1 : R` is the unit ideal. ", "terms": "[\n    \"ideal\",\n    \"element\",\n    \"unit ideal\"\n]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P (n + 1)) (i : Fin (n + 2)) (p : P),\n  affineSpan ℝ {p, Affine.Simplex.points s i} = Affine.Simplex.altitude s i ↔\n    p ≠ Affine.Simplex.points s i ∧\n      p ∈ affineSpan ℝ (Set.range s.points) ∧\n        p -ᵥ Affine.Simplex.points s i ∈\n          (AffineSubspace.direction (affineSpan ℝ (s.points '' ↑(Finset.erase Finset.univ i))))ᗮ", "name": "Affine.Simplex.affineSpan_pair_eq_altitude_iff", "isProp": true, "docString": "A line through a vertex is the altitude through that vertex if and\nonly if it is orthogonal to the opposite face. ", "terms": "[\n    \"Line\", \n    \"Vertex\", \n    \"Altitude\", \n    \"Orthogonal\", \n    \"Opposite face\"\n]"}
{"type": "{V : Type u} → SimpleGraph V → Set (Sym2 V)", "name": "SimpleGraph.edgeSet", "isProp": false, "docString": "`G.edgeSet` is the edge set for `G`.\nThis is an abbreviation for `edgeSetEmbedding G` that permits dot notation. ", "terms": "[\n    \"edge set\",\n    \"dot notation\",\n    \"edgeSetEmbedding\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} [uniformSpace : UniformSpace α] [inst : UniformSpace β] {f : α → β} {s : Set α},\n  TotallyBounded s → UniformContinuous f → TotallyBounded (f '' s)", "name": "TotallyBounded.image", "isProp": true, "docString": "The image of a totally bounded set under a uniformly continuous map is totally bounded. ", "terms": "[\n    \"Image\",\n    \"Totally Bounded Set\",\n    \"Uniformly Continuous Map\",\n    \"Totally Bounded\"\n]"}
{"type": "{A : Type u₁} →\n  {B : Type u₂} →\n    {C : Type u₃} →\n      [inst : CategoryTheory.Category.{v₁, u₁} A] →\n        [inst_1 : CategoryTheory.Category.{v₂, u₂} B] →\n          [inst_2 : CategoryTheory.Category.{v₃, u₃} C] →\n            {U : CategoryTheory.Functor B C} →\n              {F : CategoryTheory.Functor C B} →\n                (R : CategoryTheory.Functor A B) →\n                  (F' : CategoryTheory.Functor C A) →\n                    (F ⊣ U) →\n                      (F' ⊣ CategoryTheory.Functor.comp R U) →\n                        [inst : CategoryTheory.Limits.HasReflexiveCoequalizers A] → B → A", "name": "CategoryTheory.LiftAdjoint.constructLeftAdjointObj", "isProp": false, "docString": "Construct the object part of the desired left adjoint as the coequalizer of `F'Uε_Y` with\n`otherMap`.\n", "terms": "[\n  \"object\",\n  \"left adjoint\",\n  \"coequalizer\"\n]"}
{"type": "∀ (R : Type u_5) [inst : Semiring R] (M : Type u_9) [inst_1 : AddCommMonoid M] [inst_2 : Module R M],\n  Function.Surjective ⇑(Finsupp.total M M R id)", "name": "Finsupp.total_id_surjective", "isProp": true, "docString": "Any module is a quotient of a free module. This is stated as surjectivity of\n`Finsupp.total M M R id : (M →₀ R) →ₗ[R] M`. ", "terms": "[\n    \"module\",\n    \"quotient\",\n    \"free module\",\n    \"surjectivity\",\n    \"Finsupp.total\",\n    \"id\",\n    \"→₀\",\n    \"→ₗ\"\n]"}
{"type": "(J : Type w) →\n  CategoryTheory.Functor (CategoryTheory.Limits.WidePullbackShape J)ᵒᵖ (CategoryTheory.Limits.WidePushoutShape J)", "name": "CategoryTheory.Limits.widePullbackShapeUnop", "isProp": false, "docString": "The obvious functor `(WidePullbackShape J)ᵒᵖ ⥤ WidePushoutShape J`", "terms": "[\n  \"functor\",\n  \"WidePullbackShape\",\n  \"WidePushoutShape\"\n]"}
{"type": "{ι : Type v} →\n  {M₁ : ι → Type w₁} →\n    {R' : Type u_1} →\n      {A : Type u_2} →\n        [inst : Semiring R'] →\n          [inst_1 : Semiring A] →\n            [inst_2 : (i : ι) → AddCommMonoid (M₁ i)] →\n              [inst_3 : (i : ι) → TopologicalSpace (M₁ i)] →\n                [inst_4 : (i : ι) → Module A (M₁ i)] →\n                  {ι' : Type u_3} →\n                    {M' : ι' → Type u_4} →\n                      [inst_5 : (i : ι') → AddCommMonoid (M' i)] →\n                        [inst_6 : (i : ι') → TopologicalSpace (M' i)] →\n                          [inst_7 : ∀ (i : ι'), ContinuousAdd (M' i)] →\n                            [inst_8 : (i : ι') → Module R' (M' i)] →\n                              [inst_9 : (i : ι') → Module A (M' i)] →\n                                [inst_10 : ∀ (i : ι'), SMulCommClass A R' (M' i)] →\n                                  [inst_11 : ∀ (i : ι'), ContinuousConstSMul R' (M' i)] →\n                                    ((i : ι') → ContinuousMultilinearMap A M₁ (M' i)) ≃ₗ[R']\n                                      ContinuousMultilinearMap A M₁ ((i : ι') → M' i)", "name": "ContinuousMultilinearMap.piLinearEquiv", "isProp": false, "docString": "`ContinuousMultilinearMap.pi` as a `LinearEquiv`. ", "terms": "[\n  \"ContinuousMultilinearMap.pi\",\n  \"LinearEquiv\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_3} [inst_3 : LinearOrder ι] [inst_4 : LocallyFiniteOrderBot ι]\n  [inst_5 : IsWellOrder ι fun x x_1 => x < x_1] [inst_6 : Fintype ι] [inst_7 : FiniteDimensional 𝕜 E]\n  (h : FiniteDimensional.finrank 𝕜 E = Fintype.card ι) (f : ι → E),\n  Matrix.BlockTriangular (Basis.toMatrix (OrthonormalBasis.toBasis (gramSchmidtOrthonormalBasis h f)) f) id", "name": "gramSchmidtOrthonormalBasis_inv_blockTriangular", "isProp": true, "docString": "Given an indexed family `f : ι → E` of vectors in an inner product space `E`, for which the\nsize of the index set is the dimension of `E`, the matrix of coefficients of `f` with respect to the\northonormal basis `gramSchmidtOrthonormalBasis` constructed from `f` is upper-triangular. ", "terms": "[\n    \"indexed family\",\n    \"vectors\",\n    \"inner product space\",\n    \"size\",\n    \"index set\",\n    \"dimension\",\n    \"matrix\",\n    \"coefficients\",\n    \"orthonormal basis\",\n    \"upper-triangular\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    CategoryTheory.CreatesLimitsOfSize.{w, w', v₁, v₁, u₁, u₁} (CategoryTheory.Functor.id C)", "name": "CategoryTheory.idCreatesLimits", "isProp": false, "docString": "The identity functor creates all limits. ", "terms": "[\"identity functor\", \"limits\"]"}
{"type": "∀ {α : Type u} [inst : AddCommGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c : α}, b < c - a → a + b < c", "name": "add_lt_of_lt_sub_left", "isProp": true, "docString": "**Alias** of the forward direction of `lt_sub_iff_add_lt'`.", "terms": "[]"}
{"type": "∀ {ι : Type u_1} {ι' : Type u_2} {R : Type u_3} {M : Type u_6} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] (b : Basis ι R M) (e : ι ≃ ι'), Set.range ⇑(Basis.reindex b e) = Set.range ⇑b", "name": "Basis.range_reindex", "isProp": true, "docString": "`simp` can prove this as `Basis.coe_reindex` + `EquivLike.range_comp` ", "terms": "[\n  \"prove\",\n  \"Basis.coe_reindex\",\n  \"EquivLike.range_comp\"\n]"}
{"type": "Lean.PrettyPrinter.Delaborator.Delab", "name": "Quotient.«term⟦_⟧».delab", "isProp": false, "docString": "Pretty printer defined by `notation3` command. ", "terms": "[]"}
{"type": "∀ {α : Type u_1} {E : Type u_3} [inst : MeasurableSpace α] {ι : Type u_5} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : TopologicalSpace α] [inst_3 : OpensMeasurableSpace α] [inst_4 : NormedSpace ℝ E] [inst_5 : CompleteSpace E]\n  [inst_6 : SecondCountableTopologyEither α E] {μ : MeasureTheory.Measure α}\n  [inst_7 : MeasureTheory.IsLocallyFiniteMeasure μ] {a : α} {t : Set α} {f : α → E},\n  ContinuousOn f t →\n    a ∈ t →\n      MeasurableSet t →\n        ∀ {s : ι → Set α} {li : Filter ι},\n          Filter.Tendsto s li (Filter.smallSets (nhdsWithin a t)) →\n            ∀ (m : optParam (ι → ℝ) fun i => ENNReal.toReal (↑↑μ (s i))),\n              autoParam ((fun i => ENNReal.toReal (↑↑μ (s i))) =ᶠ[li] m) _auto✝ →\n                (fun i => ∫ (x : α) in s i, f x ∂μ - m i • f a) =o[li] m", "name": "ContinuousOn.integral_sub_linear_isLittleO_ae", "isProp": true, "docString": "Fundamental theorem of calculus for set integrals, `nhdsWithin` version: if `μ` is a locally\nfinite measure, `f` is continuous on a measurable set `t`, and `a ∈ t`, then `∫ x in (s i), f x ∂μ =\nμ (s i) • f a + o(μ (s i))` at `li` provided that `s i` tends to `(𝓝[t] a).smallSets` along `li`.\nSince `μ (s i)` is an `ℝ≥0∞` number, we use `(μ (s i)).toReal` in the actual statement.\n\nOften there is a good formula for `(μ (s i)).toReal`, so the formalization can take an optional\nargument `m` with this formula and a proof of `(fun i => (μ (s i)).toReal) =ᶠ[li] m`. Without these\narguments, `m i = (μ (s i)).toReal` is used in the output. ", "terms": "[\n    \"Fundamental theorem of calculus\",\n    \"set integrals\",\n    \"nhdsWithin\",\n    \"locally finite measure\",\n    \"continuous\",\n    \"measurable set\",\n    \"integral\",\n    \"smallSets\",\n    \"ℝ≥0∞\",\n    \"toReal\",\n    \"formula\",\n    \"proof\",\n    \"fun\",\n    \"output\"\n]"}
{"type": "{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : Ring R] →\n      [inst_1 : AddCommGroup M] →\n        [inst_2 : Module R M] →\n          (S : Type u_3) →\n            [inst_3 : Ring S] →\n              [inst_4 : SMul S R] →\n                [inst_5 : Module S M] →\n                  [inst_6 : IsScalarTower S R M] → (P : Submodule R M) → (M ⧸ Submodule.restrictScalars S P) ≃ₗ[S] M ⧸ P", "name": "Submodule.Quotient.restrictScalarsEquiv", "isProp": false, "docString": "The quotient of `P` as an `S`-submodule is the same as the quotient of `P` as an `R`-submodule,\nwhere `P : Submodule R M`.\n", "terms": "[\n    \"quotient\",\n    \"S-submodule\",\n    \"R-submodule\",\n    \"Submodule\"\n]"}
{"type": "(ℕ → Bool) → ℕ → Bool", "name": "Nat.all", "isProp": false, "docString": "`all f n = true` iff every `i in [0, n-1]` satisfies `f i = true` ", "terms": "[\"all\", \"true\", \"iff\", \"every\", \"in\", \"satisfies\", \"equals\"]"}
{"type": "{K : Type u_1} → [inst : CommRing K] → RatFunc K → RatFunc K → RatFunc K", "name": "RatFunc.add", "isProp": false, "docString": "Addition of rational functions. ", "terms": "[\n    \"Addition\",\n    \"Rational functions\"\n]"}
{"type": "{A : Type u_4} →\n  [inst : AddCommMonoid A] →\n    (x : A) →\n      {B : Type u_5} →\n        [inst_1 : AddCommMonoid B] →\n          AddSubmonoid.LocalizationMap.AwayMap x B →\n            {C : Type u_6} →\n              [inst_2 : AddCommMonoid C] → (y : A) → AddSubmonoid.LocalizationMap.AwayMap (x + y) C → B →+ C", "name": "AddSubmonoid.LocalizationMap.awayToAwayRight", "isProp": false, "docString": "Given `x y : A` and Localization maps `F : A →+ B, G : A →+ C` away from `x` and `x + y`\nrespectively, the homomorphism induced from `B` to `C`. ", "terms": "[\n    \"Localization maps\",\n    \"homomorphism\",\n    \"induced\"\n]"}
{"type": "{C : Type u} → [𝒞 : CategoryTheory.Category.{v, u} C] → [self : CategoryTheory.MonoidalCategoryStruct C] → C → C → C", "name": "CategoryTheory.MonoidalCategoryStruct.tensorObj", "isProp": false, "docString": "curried tensor product of objects ", "terms": "[\n    \"curried\",\n    \"tensor product\",\n    \"objects\"\n]"}
{"type": "{σ : semiOutParam (Type u)} → {m : Type u → Type v} → [self : MonadStateOf σ m] → {α : Type u} → (σ → α × σ) → m α", "name": "MonadStateOf.modifyGet", "isProp": false, "docString": "`modifyGet (f : σ → α × σ)` applies `f` to the current state, replaces\nthe state with the return value, and returns a computed value.\n\nIt is equivalent to `do let (a, s) := f (← get); put s; pure a`, but\n`modifyGet f` may be preferable because the former does not use the state\nlinearly (without sufficient inlining). ", "terms": "[\"modifyGet\", \"f\", \"σ\", \"α\", \"×\", \"state\", \"return value\", \"computed value\", \"equivalent\", \"do let\", \"get\", \"put\", \"pure\", \"preferable\", \"does not use\", \"linearly\", \"without sufficient inlining\"]"}
{"type": "∀ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace ℝ E] {f f' : ℝ → E}\n  {a b : ℝ},\n  ContinuousOn f (Set.uIcc a b) →\n    (∀ x ∈ Set.Ioo (min a b) (max a b), HasDerivWithinAt f (f' x) (Set.Ioi x) x) →\n      IntervalIntegrable f' MeasureTheory.volume a b → ∫ (y : ℝ) in a..b, f' y = f b - f a", "name": "intervalIntegral.integral_eq_sub_of_hasDeriv_right", "isProp": true, "docString": "Fundamental theorem of calculus-2: If `f : ℝ → E` is continuous on `[a, b]` and\nhas a right derivative at `f' x` for all `x` in `[a, b)`, and `f'` is integrable on `[a, b]` then\n`∫ y in a..b, f' y` equals `f b - f a`. ", "terms": "[\n    \"Fundamental theorem of calculus\",\n    \"continuous\",\n    \"right derivative\",\n    \"integrable\",\n    \"integral\"\n]"}
{"type": "∀ {α : Type u_2} [inst : LinearOrderedField α] {a b : α}, a < 0 → b < 0 → (1 / a < 1 / b ↔ b < a)", "name": "one_div_lt_one_div_of_neg", "isProp": true, "docString": "For the single implications with fewer assumptions, see `one_div_lt_one_div_of_lt` and\n`lt_of_one_div_lt_one_div` ", "terms": "[\"single implications\", \"fewer assumptions\", \"one_div_lt_one_div_of_lt\", \"lt_of_one_div_lt_one_div\"]"}
{"type": "{R : Type u_1} → [inst : CommRing R] → [inst : IsDomain R] → Cubic R → Multiset R", "name": "Cubic.roots", "isProp": false, "docString": "The roots of a cubic polynomial. ", "terms": "[\n    \"roots\",\n    \"cubic\",\n    \"polynomial\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      {P Q R S : C} →\n        {f : P ⟶ Q} →\n          {g : P ⟶ R} →\n            {h : Q ⟶ S} →\n              {k : R ⟶ S} →\n                [hn : CategoryTheory.NormalMono h] →\n                  (comm : CategoryTheory.CategoryStruct.comp f h = CategoryTheory.CategoryStruct.comp g k) →\n                    CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.PullbackCone.mk f g comm) →\n                      CategoryTheory.NormalMono g", "name": "CategoryTheory.normalOfIsPullbackSndOfNormal", "isProp": false, "docString": "The second leg of a pullback cone is a normal monomorphism if the right component is too.\n\nSee also `pullback.sndOfMono` for the basic monomorphism version, and\n`normalOfIsPullbackFstOfNormal` for the flipped version.\n", "terms": "[\n    \"second leg\",\n    \"pullback cone\",\n    \"normal monomorphism\",\n    \"right component\",\n    \"pullback.sndOfMono\",\n    \"basic monomorphism\",\n    \"normalOfIsPullbackFstOfNormal\",\n    \"flipped version\"\n]"}
{"type": "{ι : Type u} → {β : ι → Type v} → [inst : (i : ι) → AddZeroClass (β i)] → (i : ι) → (Π₀ (i : ι), β i) →+ β i", "name": "DFinsupp.evalAddMonoidHom", "isProp": false, "docString": "Evaluation at a point is an `AddMonoidHom`. This is the finitely-supported version of\n`Pi.evalAddMonoidHom`. ", "terms": "[\n    \"Evaluation at a point\",\n    \"AddMonoidHom\",\n    \"finitely-supported\",\n    \"Pi.evalAddMonoidHom\"\n]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  {p p₁ p₂ : P},\n  p₁ ≠ p →\n    p₂ ≠ p →\n      EuclideanGeometry.oangle p₁ p p₂ = ↑(EuclideanGeometry.angle p₁ p p₂) ∨\n        EuclideanGeometry.oangle p₁ p p₂ = -↑(EuclideanGeometry.angle p₁ p p₂)", "name": "EuclideanGeometry.oangle_eq_angle_or_eq_neg_angle", "isProp": true, "docString": "The oriented angle at `p` between two points not equal to `p` is plus or minus the unoriented\nangle. ", "terms": "[\n    \"oriented angle\",\n    \"points\",\n    \"equal\",\n    \"plus\",\n    \"minus\",\n    \"unoriented angle\"\n]"}
{"type": "∀ {K : Type u} {A : Type v} [inst : Field K] [inst_1 : Ring A] [inst_2 : Algebra K A],\n  Algebra.IsAlgebraic K A → Algebra.IsIntegral K A", "name": "Algebra.IsAlgebraic.isIntegral", "isProp": true, "docString": "**Alias** of the forward direction of `Algebra.isAlgebraic_iff_isIntegral`.", "terms": "[\"Alias\", \"forward direction\", \"Algebra.isAlgebraic_iff_isIntegral\"]"}
{"type": "{Γ : Type u_1} → [inst : Inhabited Γ] → Turing.Tape Γ → Turing.ListBlank Γ", "name": "Turing.Tape.left₀", "isProp": false, "docString": "The \"inclusive\" left side of the tape, including both `left` and `head`. ", "terms": "[]"}
{"type": "{M : Type u_1} →\n  {A : Type u_4} →\n    {B : Type u_5} →\n      [inst : Monoid M] →\n        [inst_1 : AddMonoid A] →\n          [inst_2 : DistribMulAction M A] →\n            [inst_3 : AddMonoid B] →\n              [inst_4 : SMul M B] →\n                (f : A →+ B) → Function.Surjective ⇑f → (∀ (c : M) (x : A), f (c • x) = c • f x) → DistribMulAction M B", "name": "Function.Surjective.distribMulAction", "isProp": false, "docString": "Pushforward a distributive multiplicative action along a surjective additive monoid\nhomomorphism.\nSee note [reducible non-instances]. ", "terms": "[\n    \"Pushforward\",\n    \"Distributive\",\n    \"Multiplicative Action\",\n    \"Surjective\",\n    \"Additive Monoid\",\n    \"Homomorphism\",\n    \"Reducible\",\n    \"Non-instances\"\n]"}
{"type": "{α : Type u} →\n  {β : α → Type v} →\n    [inst : DecidableEq α] → (x : α) → (xs : List α) → β x → ((a : α) → a ∈ xs → β a) → (a : α) → a ∈ x :: xs → β a", "name": "FinEnum.Pi.cons", "isProp": false, "docString": "For `Pi.cons x xs y f` create a function where every `i ∈ xs` is mapped to `f i` and\n`x` is mapped to `y`  ", "terms": "[\n  \"Pi.cons\",\n  \"function\",\n  \"mapped\",\n  \"∈\"\n]"}
{"type": "{α : Type u_1} → [inst : MeasurableSpace α] → MeasureTheory.JordanDecomposition α → MeasureTheory.SignedMeasure α", "name": "MeasureTheory.JordanDecomposition.toSignedMeasure", "isProp": false, "docString": "The signed measure associated with a Jordan decomposition. ", "terms": "[\n    \"signed measure\",\n    \"associated\",\n    \"Jordan decomposition\"\n]"}
{"type": "(α : Type u_3) → [inst : AddMonoidWithOne α] → ℕ →+ α", "name": "Nat.castAddMonoidHom", "isProp": false, "docString": "`Nat.cast : ℕ → α` as an `AddMonoidHom`. ", "terms": "[\n    \"Nat.cast\",\n    \"ℕ\",\n    \"α\",\n    \"AddMonoidHom\"\n]"}
{"type": "{α : Sort u_1} → (p : α → Prop) → DecidablePred p", "name": "Classical.decPred", "isProp": false, "docString": "Any predicate `p` is decidable classically. ", "terms": "[\"predicate\", \"decidable\", \"classically\"]"}
{"type": "∀ {r : NNReal}, ⊤ - ↑r = ⊤", "name": "ENNReal.top_sub_coe", "isProp": true, "docString": "This is a special case of `WithTop.top_sub_coe` in the `ENNReal` namespace ", "terms": "[\"special case\", \"WithTop.top_sub_coe\", \"ENNReal\", \"namespace\"]"}
{"type": "{γ : Type u_2} → {β : Type u_3} → (f : γ → β) → Function.Injective f → EMetricSpace β → EMetricSpace γ", "name": "EMetricSpace.induced", "isProp": false, "docString": "The extended metric induced by an injective function taking values in an emetric space. ", "terms": "[\n    \"extended metric\",\n    \"induced\",\n    \"injective function\",\n    \"values\",\n    \"emetric space\"\n]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      {S₁ S₂ : CategoryTheory.ShortComplex C} → (φ : S₁ ⟶ S₂) → CategoryTheory.ShortComplex.Homotopy φ φ", "name": "CategoryTheory.ShortComplex.Homotopy.refl", "isProp": false, "docString": "The obvious homotopy between a morphism of short complexes and itself. ", "terms": "[\n    \"homotopy\",\n    \"morphism\",\n    \"short complexes\"\n]"}
{"type": "∀ {α : Type u_3} [inst : LE α] [self : NoTopOrder α] (a : α), ∃ b, ¬b ≤ a", "name": "NoTopOrder.exists_not_le", "isProp": true, "docString": "For each term `a`, there is some `b` which is either incomparable or strictly larger. ", "terms": "[\"term\", \"incomparable\", \"strictly larger\"]"}
{"type": "∀ {G : Type u_3} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p", "name": "exists_prime_addOrderOf_dvd_card", "isProp": true, "docString": "For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. ", "terms": "[\n    \"Prime\",\n    \"Dividing\",\n    \"Order\",\n    \"Finite Additive Group\",\n    \"Element\",\n    \"Cauchy's Theorem\"\n]"}
{"type": "{α : Type u} → {β : Type v} → (α → Computation β) → Computation α ⊕ Computation β → β ⊕ Computation α ⊕ Computation β", "name": "Computation.Bind.f", "isProp": false, "docString": "bind over a function mapping `α` to a `Computation`", "terms": "[\n  \"bind\",\n  \"function\",\n  \"mapping\",\n  \"Computation\"\n]"}
{"type": "∀ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] [inst_1 : AddGroup H] [inst_2 : IsAddCyclic H] (f : G →+ H),\n  AddMonoidHom.ker f ≤ AddSubgroup.center G → ∀ (a b : G), a + b = b + a", "name": "commutative_of_add_cyclic_center_quotient", "isProp": true, "docString": "A group is commutative if the quotient by the center is cyclic.\nAlso see `addCommGroup_of_cycle_center_quotient` for the `AddCommGroup` instance.", "terms": "[\n  \"group\",\n  \"commutative\",\n  \"quotient\",\n  \"center\",\n  \"cyclic\",\n  \"AddCommGroup\",\n  \"instance\"\n]"}
{"type": "ℕ → Linarith.Linexp → ℤ", "name": "Linarith.Linexp.zfind", "isProp": false, "docString": "`l.zfind n` returns the value associated with key `n` if there is one, and 0 otherwise.\n", "terms": "[]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]\n  {F : CategoryTheory.Functor C D} [self : CategoryTheory.Functor.PreservesMonomorphisms F] {X Y : C} (f : X ⟶ Y)\n  [inst_2 : CategoryTheory.Mono f], CategoryTheory.Mono (F.map f)", "name": "CategoryTheory.Functor.PreservesMonomorphisms.preserves", "isProp": true, "docString": "A functor preserves monomorphisms if it maps monomorphisms to monomorphisms. ", "terms": "[\n  \"functor\",\n  \"preserves\",\n  \"monomorphisms\",\n  \"maps\"\n]"}
{"type": "{α : Type u_1} → List α → Ordnode α → ℕ → Ordnode α", "name": "Ordnode.ofAscListAux₂", "isProp": false, "docString": "Auxiliary definition for `ofAscList`. ", "terms": "[]"}
{"type": "∀ {α : Type u_1} {β : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {μ : MeasureTheory.Measure α}\n  {ν : MeasureTheory.Measure β} [inst_2 : MeasureTheory.SFinite ν] [inst_3 : MeasureTheory.SFinite μ] {s : Set α}\n  {t : Set β},\n  MeasureTheory.NullMeasurableSet (s ×ˢ t) ↔\n    MeasureTheory.NullMeasurableSet s ∧ MeasureTheory.NullMeasurableSet t ∨ ↑↑μ s = 0 ∨ ↑↑ν t = 0", "name": "MeasureTheory.Measure.nullMeasurableSet_prod", "isProp": true, "docString": "The product of two sets is null measurable\nif and only if both of them are null measurable or one of them has measure zero. ", "terms": "[\n    \"product of two sets\",\n    \"null measurable\",\n    \"measure zero\"\n]"}
{"type": "{G : Type u_1} →\n  [inst : AddGroup G] →\n    [inst_1 : TopologicalSpace G] →\n      [inst_2 : T2Space G] →\n        [inst : TopologicalAddGroup G] →\n          [inst : MeasurableSpace G] →\n            [inst_3 : BorelSpace G] → TopologicalSpace.PositiveCompacts G → MeasureTheory.Measure G", "name": "MeasureTheory.Measure.addHaarMeasure", "isProp": false, "docString": "The Haar measure on the locally compact additive group `G`, scaled so that\n`addHaarMeasure K₀ K₀ = 1`.", "terms": "[\n    \"Haar measure\",\n    \"locally compact\",\n    \"additive group\",\n    \"scaled\",\n    \"measure\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Monotone f → ∀ {a : α} {s : Set α}, IsGreatest s a → IsGreatest (f '' s) (f a)", "name": "Monotone.map_isGreatest", "isProp": true, "docString": "A monotone map sends a greatest element of a set to a greatest element of its image. ", "terms": "[\n    \"monotone map\",\n    \"greatest element\",\n    \"set\",\n    \"image\"\n]"}
{"type": "{α : Type u_2} → IndepMatroid α → Set α", "name": "IndepMatroid.E", "isProp": false, "docString": "The ground set ", "terms": "[\"ground set\"]"}
{"type": "Lean.TrailingParserDescr", "name": "«term_<*_»", "isProp": false, "docString": "If `x : F α` and `y : F β`, then `x <* y` evaluates `x`, then `y`,\nand returns the result of `x`.\n\nTo avoid surprising evaluation semantics, `y` is taken \"lazily\", using a\n`Unit → f β` function. ", "terms": "[\n    \"F α\",\n    \"F β\",\n    \"<*\",\n    \"evaluates\",\n    \"returns\",\n    \"result\",\n    \"evaluation semantics\",\n    \"lazily\",\n    \"Unit → f β\",\n    \"function\"\n]"}
{"type": "∀ {G : Type u_2} [inst : MeasurableSpace G] [inst_1 : Semigroup G] [inst_2 : MeasurableMul G]\n  {μ : MeasureTheory.Measure G} {α : Type u_4} [inst_3 : SMul α G] [inst_4 : SMulCommClass α Gᵐᵒᵖ G]\n  [inst_5 : MeasurableSpace α] [inst_6 : MeasurableSMul α G] [inst_7 : MeasureTheory.Measure.IsMulRightInvariant μ]\n  (a : α), MeasureTheory.Measure.IsMulRightInvariant (MeasureTheory.Measure.map (fun x => a • x) μ)", "name": "MeasureTheory.isMulRightInvariant_map_smul", "isProp": true, "docString": "The image of a right invariant measure under a left action is right invariant, assuming that\nthe action preserves multiplication. ", "terms": "[\n\"image\",\n\"right invariant measure\",\n\"left action\",\n\"right invariant\",\n\"action\",\n\"preserves\",\n\"multiplication\"\n]"}
{"type": "{m : semiOutParam (Type u → Type v)} → {n : Type u → Type w} → [self : MonadLift m n] → {α : Type u} → m α → n α", "name": "MonadLift.monadLift", "isProp": false, "docString": "Lifts a value from monad `m` into monad `n`. ", "terms": "[\"lifts\", \"value\", \"from\", \"monad\", \"into\"]"}
{"type": "{α : Type u_1} → List (Option α) → List α → List α", "name": "List.fillNonesTR", "isProp": false, "docString": "Tail-recursive version of `fillNones`. ", "terms": "[]"}
{"type": "∀ {p : ℕ+} {k : ℕ} {K : Type u} [inst : Field K] [inst_1 : CharZero K] {ζ : K} [hp : Fact (Nat.Prime ↑p)]\n  [hcycl : IsCyclotomicExtension {p ^ k} ℚ K],\n  IsPrimitiveRoot ζ ↑(p ^ k) → IsIntegralClosure ↥(Algebra.adjoin ℤ {ζ}) ℤ K", "name": "IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime_pow", "isProp": true, "docString": "If `K` is a `p ^ k`-th cyclotomic extension of `ℚ`, then `(adjoin ℤ {ζ})` is the\nintegral closure of `ℤ` in `K`. ", "terms": "[\n    \"cyclotomic extension\",\n    \"ℚ\",\n    \"adjoin\",\n    \"ℤ\",\n    \"integral closure\",\n    \"K\"\n]"}
{"type": "{𝕜 : Type u_1} →\n  {E : Type u_5} →\n    {ι : Type u_8} →\n      [inst : NormedField 𝕜] → [inst_1 : AddCommGroup E] → [inst_2 : Module 𝕜 E] → SeminormFamily 𝕜 E ι → Set (Set E)", "name": "SeminormFamily.basisSets", "isProp": false, "docString": "The sets of a filter basis for the neighborhood filter of 0. ", "terms": "[\n    \"Sets\",\n    \"Filter Basis\",\n    \"Neighborhood Filter\"\n]"}
{"type": "{M : Type u_3} → [inst : AddCommMonoid M] → [inst_1 : Module ENNReal M] → Module NNReal M", "name": "ENNReal.instModuleNNRealInstNNRealSemiring", "isProp": false, "docString": "A `Module` over `ℝ≥0∞` restricts to a `Module` over `ℝ≥0`. ", "terms": "[\n    \"Module\",\n    \"ℝ≥0∞\",\n    \"ℝ≥0\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Antitone f → ∀ {a : α} {s : Set α}, IsGreatest s a → IsLeast (f '' s) (f a)", "name": "Antitone.map_isGreatest", "isProp": true, "docString": "An antitone map sends a greatest element of a set to a least element of its image. ", "terms": "[\n    \"Antitone map\",\n    \"Greatest element\",\n    \"Set\",\n    \"Least element\",\n    \"Image\"\n]"}
{"type": "{α : Type u_2} → [inst : CancelCommMonoidWithZero α] → [self : GCDMonoid α] → α → α → α", "name": "GCDMonoid.gcd", "isProp": false, "docString": "The greatest common divisor between two elements. ", "terms": "[\n    \"greatest common divisor\", \n    \"elements\"\n]"}
{"type": "{α : Type u} → α ≃ WellOrderExtension α", "name": "toWellOrderExtension", "isProp": false, "docString": "\"Identity\" equivalence between a well-founded order and its well-order extension. ", "terms": "[\n    \"Identity\",\n    \"Equivalence\",\n    \"Well-founded Order\",\n    \"Well-order Extension\"\n]"}
{"type": "MetricSpace ℝ", "name": "Real.metricSpace", "isProp": false, "docString": "Instantiate the reals as a metric space. ", "terms": "[\n  \"Instantiate\",\n  \"Reals\",\n  \"Metric Space\"\n]"}
{"type": "{ρ : outParam (Type u)} → {m : Type u → Type v} → [self : MonadWithReader ρ m] → {α : Type u} → (ρ → ρ) → m α → m α", "name": "MonadWithReader.withReader", "isProp": false, "docString": "`withReader (f : ρ → ρ) (x : m α) : m α`  runs the inner `x : m α` inside\na modified context after applying the function `f : ρ → ρ`.", "terms": "[\n    \"withReader\",\n    \"function\",\n    \"context\",\n    \"applying\"\n]"}
{"type": "∀ {V : Type u} (G : SimpleGraph V) [inst : DecidableEq V] (s t : V),\n  ¬SimpleGraph.Adj (SimpleGraph.replaceVertex G s t) s t", "name": "SimpleGraph.not_adj_replaceVertex_same", "isProp": true, "docString": "There is never an `s-t` edge in `G.replaceVertex s t`. ", "terms": "[\n  \"edge\",\n  \"replaceVertex\"\n]"}
{"type": "∀ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {Q : QuadraticForm R M} (d d' : Module.Dual R M) (x : CliffordAlgebra Q),\n  (CliffordAlgebra.contractRight ((CliffordAlgebra.contractRight x) d)) d' =\n    -(CliffordAlgebra.contractRight ((CliffordAlgebra.contractRight x) d')) d", "name": "CliffordAlgebra.contractRight_comm", "isProp": true, "docString": "This is [grinberg_clifford_2016][] Theorem 14 ", "terms": "[]"}
{"type": "{X Y Z : AlgebraicGeometry.Scheme} →\n  AlgebraicGeometry.Scheme.OpenCover Z →\n    (f : X ⟶ Z) → (g : Y ⟶ Z) → AlgebraicGeometry.Scheme.OpenCover (CategoryTheory.Limits.pullback f g)", "name": "AlgebraicGeometry.Scheme.Pullback.openCoverOfBase'", "isProp": false, "docString": "(Implementation). Use `openCoverOfBase` instead. ", "terms": "[]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      {X Y : C} →\n        {c : CategoryTheory.Limits.BinaryBicone X Y} →\n          CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.BinaryBicone.toCone c) →\n            CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.BinaryBicone.fstKernelFork c)", "name": "CategoryTheory.Limits.BinaryBicone.isLimitFstKernelFork", "isProp": false, "docString": "The fork defined in `BinaryBicone.fstKernelFork` is indeed a kernel. ", "terms": "[\"fork\", \"BinaryBicone.fstKernelFork\", \"kernel\"]"}
{"type": "(R : Type u) →\n  [inst : CommRing R] →\n    {ι₁ : Type v₁} →\n      [inst_1 : DecidableEq ι₁] →\n        (M₁ : ι₁ → Type w₁) →\n          (M₂' : Type w₂') →\n            [inst_2 : (i₁ : ι₁) → AddCommGroup (M₁ i₁)] →\n              [inst_3 : AddCommGroup M₂'] →\n                [inst_4 : (i₁ : ι₁) → Module R (M₁ i₁)] →\n                  [inst_5 : Module R M₂'] →\n                    TensorProduct R (DirectSum ι₁ fun i₁ => M₁ i₁) M₂' ≃ₗ[R]\n                      DirectSum ι₁ fun i => TensorProduct R (M₁ i) M₂'", "name": "TensorProduct.directSumLeft", "isProp": false, "docString": "Tensor products distribute over a direct sum on the left . ", "terms": "[\n    \"Tensor products\",\n    \"distribute\",\n    \"over\",\n    \"direct sum\",\n    \"left\"\n]"}
{"type": "∀ {α : Type u} [t : TopologicalSpace α] {β : Type u_1} [inst : TopologicalSpace β]\n  [inst_1 : TopologicalSpace.SeparableSpace α] [inst_2 : TopologicalSpace.SeparableSpace β],\n  TopologicalSpace.SeparableSpace (α × β)", "name": "TopologicalSpace.instSeparableSpaceProdInstTopologicalSpaceProd", "isProp": true, "docString": "The product of two separable spaces is a separable space. ", "terms": "[\n  \"product\",\n  \"separable spaces\"\n]"}
{"type": "{α : Type u_1} → {m : Type u_1 → Type u_1} → List α → MLList m α", "name": "MLList.ofList", "isProp": false, "docString": "Convert a `List` to a `MLList`. ", "terms": "[\"List\", \"MLList\"]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      (S : CategoryTheory.ShortComplex C) → S.f = 0 → S.g = 0 → CategoryTheory.ShortComplex.LeftHomologyData S", "name": "CategoryTheory.ShortComplex.LeftHomologyData.ofZeros", "isProp": false, "docString": "When both `S.f` and `S.g` are zero, the middle object `S.X₂` gives a left homology data on S ", "terms": "[\"zero\", \"middle object\", \"left homology\", \"data\"]"}
{"type": "{α : Type u_1} → [inst : BEq α] → [inst : Hashable α] → (α → List α) → α → optParam (Option ℕ) none → List α", "name": "depthFirstRemovingDuplicates'", "isProp": false, "docString": "Variant of `depthFirst`,\nusing an internal `HashSet` to record and avoid already visited nodes.\n\nThis version describes the graph using `α → List α`, and returns the list of nodes visited in order.\n", "terms": "[]\n"}
{"type": "∀ {τ : Type u_1} {α : Type u_2} {β : Type u_3} [inst : TopologicalSpace β] (f : Filter τ) (ϕ : τ → α → β) (s : Set α)\n  {c : Set β},\n  IsCompact c →\n    (∃ v ∈ f, closure (Set.image2 ϕ v s) ⊆ c) →\n      ∀ {n : Set β}, IsOpen n → omegaLimit f ϕ s ⊆ n → ∃ u ∈ f, closure (Set.image2 ϕ u s) ⊆ n", "name": "eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset'", "isProp": true, "docString": "A set is eventually carried into any open neighbourhood of its ω-limit:\nif `c` is a compact set such that `closure {ϕ t x | t ∈ v, x ∈ s} ⊆ c` for some `v ∈ f`\nand `n` is an open neighbourhood of `ω f ϕ s`, then for some `u ∈ f` we have\n`closure {ϕ t x | t ∈ u, x ∈ s} ⊆ n`. ", "terms": "[\n    \"set\",\n    \"eventually carried into\",\n    \"open neighbourhood\",\n    \"ω-limit\",\n    \"compact set\",\n    \"closure\",\n    \"ϕ\",\n    \"⊆\",\n    \"open neighbourhood\",\n    \"closure\",\n    \"ϕ\",\n    \"⊆\"\n]"}
{"type": "failed to pretty print expression (use 'set_option pp.rawOnError true' for raw representation)", "name": "Qq.Quoted.unsafeMk", "isProp": false, "docString": "Creates a quoted expression.  Requires that `e` has type `α`.\n\nYou should usually write this using the notation `q($e)`.\n", "terms": "[]"}
{"type": "{α : Type u} → {β : Type v} → [inst : Preorder β] → (α → β) → Set α → α → Prop", "name": "IsExtrOn", "isProp": false, "docString": "`IsExtrOn f s a` means `IsMinOn f s a` or `IsMaxOn f s a` ", "terms": "[\n  \"Extr\",\n  \"f\",\n  \"s\",\n  \"a\",\n  \"Min\",\n  \"Max\",\n  \"or\"\n]"}
{"type": "∀ {K : Type u_12} {K₁ : Type u_13} {V₁ : Type u_16} {n : Type u_18} [inst : Field K] [inst_1 : Field K₁]\n  [inst_2 : AddCommGroup V₁] [inst_3 : Module K₁ V₁] {I₁ I₁' : K₁ →+* K} {B : V₁ →ₛₗ[I₁] V₁ →ₛₗ[I₁'] K} {v : n → V₁},\n  LinearMap.IsOrthoᵢ B v → (∀ (i : n), ¬LinearMap.IsOrtho B (v i) (v i)) → LinearIndependent K₁ v", "name": "LinearMap.linearIndependent_of_isOrthoᵢ", "isProp": true, "docString": "A set of orthogonal vectors `v` with respect to some sesquilinear form `B` is linearly\nindependent if for all `i`, `B (v i) (v i) ≠ 0`. ", "terms": "[\n    \"set\",\n    \"orthogonal vectors\",\n    \"with respect to\",\n    \"sesquilinear form\",\n    \"linearly independent\",\n    \"for all\",\n    \"≠\",\n    \"0\"\n]"}
{"type": "{J : Type w} →\n  {C : Type u} →\n    [inst : CategoryTheory.Category.{v, u} C] →\n      (F : CategoryTheory.Functor (CategoryTheory.Limits.WalkingParallelFamily J) C) →\n        F ≅ CategoryTheory.Limits.parallelFamily fun j => F.map (CategoryTheory.Limits.WalkingParallelFamily.Hom.line j)", "name": "CategoryTheory.Limits.diagramIsoParallelFamily", "isProp": false, "docString": "Every functor indexing a wide (co)equalizer is naturally isomorphic (actually, equal) to a\n`parallelFamily` ", "terms": "[\n    \"functor\",\n    \"indexing\",\n    \"wide\",\n    \"(co)equalizer\",\n    \"naturally isomorphic\",\n    \"actually, equal\",\n    \"`parallelFamily`\"\n]"}
{"type": "∀ {p k n : ℕ} [hp : Fact (Nat.Prime p)],\n  (p - 1) * padicValNat p (Nat.choose (n + k) k) =\n    List.sum (Nat.digits p k) + List.sum (Nat.digits p n) - List.sum (Nat.digits p (n + k))", "name": "sub_one_mul_padicValNat_choose_eq_sub_sum_digits'", "isProp": true, "docString": "**Kummer's Theorem**\nTaking (`p - 1`) times the `p`-adic valuation of the binomial `n + k` over `k` equals the sum of the\ndigits of `k` plus the sum of the digits of `n` minus the sum of digits of `n + k`, all base `p`.\n", "terms": "[\n    \"Kummer's Theorem\",\n    \"times\",\n    \"p-adic valuation\",\n    \"binomial\",\n    \"equals\",\n    \"sum\",\n    \"digits\",\n    \"minus\",\n    \"base\"\n]"}
{"type": "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α]\n  [inst_3 : DenselyOrdered α] {a b : α}, a ≠ b → closure (Set.Ioc a b) = Set.Icc a b", "name": "closure_Ioc", "isProp": true, "docString": "The closure of the interval `(a, b]` is the closed interval `[a, b]`. ", "terms": "[\"closure\", \"interval\", \"closed interval\"]"}
{"type": "∀ {α : Type u_1} {E : α → Type u_2} [inst : (i : α) → NormedAddCommGroup (E i)] {p q : ENNReal},\n  Real.IsConjugateExponent (ENNReal.toReal p) (ENNReal.toReal q) →\n    ∀ (f : ↥(lp E p)) (g : ↥(lp E q)), (Summable fun i => ‖↑f i‖ * ‖↑g i‖) ∧ ∑' (i : α), ‖↑f i‖ * ‖↑g i‖ ≤ ‖f‖ * ‖g‖", "name": "lp.tsum_mul_le_mul_norm", "isProp": true, "docString": "Hölder inequality ", "terms": "[\n    \"Hölder inequality\"\n]"}
{"type": "{α : Type u_1} →\n  [inst : CancelCommMonoidWithZero α] →\n    [dec_irr : (p : Associates α) → Decidable (Irreducible p)] →\n      [inst_1 : DecidableEq (Associates α)] → Associates α → Associates.FactorSet α → ℕ", "name": "Associates.count", "isProp": false, "docString": "`count p s` is the multiplicity of the irreducible `p` in the FactorSet `s`.\n\nIf `p` is not irreducible, `count p s` is defined to be `0`. ", "terms": "[\n    \"count\",\n    \"multiplicity\",\n    \"irreducible\",\n    \"FactorSet\",\n    \"defined\",\n    \"0\"\n]"}
{"type": "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T5Space X], T4Space X", "name": "T5Space.toT4Space", "isProp": true, "docString": "A `T₅` space is a `T₄` space. ", "terms": "[\"T₅ space\", \"T₄ space\"]"}
{"type": "{M₁ : Type u_1} →\n  {M₂ : Type u_3} →\n    [inst : Inv M₂] →\n      [inst_1 : InvolutiveInv M₁] →\n        (f : M₁ → M₂) → Function.Surjective f → (∀ (x : M₁), f x⁻¹ = (f x)⁻¹) → InvolutiveInv M₂", "name": "Function.Surjective.involutiveInv", "isProp": false, "docString": "A type has an involutive inversion if it admits a surjective map that preserves `⁻¹` to a type\nwhich has an involutive inversion. See note [reducible non-instances] ", "terms": "[\n    \"type\",\n    \"involutive inversion\",\n    \"admits\",\n    \"surjective map\",\n    \"preserves\",\n    \"reducible non-instances\"\n]"}
{"type": "∀ {R : Type u_1} [inst : LinearOrderedCommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (u : Rˣ) (v : Module.Ray R M), u⁻¹ • v = u • v", "name": "units_inv_smul", "isProp": true, "docString": "Scaling by an inverse unit is the same as scaling by itself. ", "terms": "[\"Scaling\", \"inverse unit\"]"}
{"type": "∀ (𝕜 : Type u_1) {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] [inst_5 : CompleteSpace F]\n  (f : E → F), IsOpen {x | AnalyticAt 𝕜 f x}", "name": "isOpen_analyticAt", "isProp": true, "docString": "For any function `f` from a normed vector space to a Banach space, the set of points `x` such\nthat `f` is analytic at `x` is open. ", "terms": "[\n  \"function\",\n  \"normed vector space\",\n  \"Banach space\",\n  \"set\",\n  \"points\",\n  \"analytic\",\n  \"open\"\n]"}
{"type": "(m : Type u_2) →\n  (n : Type u_3) →\n    (o : Type u_4) →\n      (α : Type u_12) →\n        [inst : DecidableEq o] → [inst : AddZeroClass α] → (o → Matrix m n α) →+ Matrix (m × o) (n × o) α", "name": "Matrix.blockDiagonalAddMonoidHom", "isProp": false, "docString": "`Matrix.blockDiagonal` as an `AddMonoidHom`. ", "terms": "[\n  \"Matrix\",\n  \"blockDiagonal\",\n  \"AddMonoidHom\"\n]"}
{"type": "{L : FirstOrder.Language} →\n  {M : Type w} → [inst : FirstOrder.Language.Structure L M] → FirstOrder.Language.Constants L → M", "name": "FirstOrder.Language.constantMap", "isProp": false, "docString": "Interpretation of a constant symbol ", "terms": "{\n  \"MathematicalTerms\": [\"Interpretation\", \"Constant\", \"Symbol\"]\n}"}
{"type": "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsPrincipalIdealRing R] [inst_3 : DecidableEq R]\n  [inst_4 : DecidableEq (Ideal R)] [inst_5 : NormalizationMonoid R] [inst_6 : DecidableRel fun x x_1 => x ∣ x_1]\n  [inst_7 : DecidableRel fun x x_1 => x ∣ x_1] {r d : R} (hr : r ≠ 0)\n  (hd : d ∈ UniqueFactorizationMonoid.normalizedFactors r),\n  multiplicity d r =\n    multiplicity (↑((normalizedFactorsEquivSpanNormalizedFactors hr) { val := d, property := hd })) (Ideal.span {r})", "name": "multiplicity_normalizedFactorsEquivSpanNormalizedFactors_eq_multiplicity", "isProp": true, "docString": "The bijection `normalizedFactorsEquivSpanNormalizedFactors` between the set of prime\nfactors of `r` and the set of prime factors of the ideal `⟨r⟩` preserves multiplicities. ", "terms": "[\n    \"bijection\",\n    \"normalizedFactorsEquivSpanNormalizedFactors\",\n    \"set\",\n    \"prime factors\",\n    \"ideal\",\n    \"preserves\",\n    \"multiplicities\"\n]"}
{"type": "{β : Type} → Lean.Syntax → Lean.ParametricAttribute β → Lean.Name → Lean.Name → Lean.Name → Lean.Name → Lean.CoreM Unit", "name": "ToAdditive.warnParametricAttr", "isProp": false, "docString": "Warn the user when the multiplicative declaration has a parametric attribute. ", "terms": "The statement provided does not contain any mathematical terms. Hence, the JSON list will be empty.\n\n    []"}
{"type": "{R : Type u} →\n  [inst : Ring R] →\n    {α : Type u_1} → [inst_1 : Zero α] → [inst_2 : SMulWithZero R α] → (S : Subring R) → SMulWithZero (↥S) α", "name": "Subring.instSMulWithZeroSubtypeMemSubringInstMembershipInstSetLikeSubringZeroToZeroToMonoidWithZeroToSemiringToZeroMemClassToAddZeroClassToAddMonoidToAddMonoidWithOneToAddGroupWithOneToAddSubmonoidClassToNonAssocSemiringToSubsemiringClassInstSubringClassSubringInstSetLikeSubring", "isProp": false, "docString": "The action by a subring is the action by the underlying ring. ", "terms": "[\n    \"action\",\n    \"subring\",\n    \"underlying ring\"\n]"}
{"type": "∀ {V : Type u_4} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] (T : V →ₗ[ℂ] V) (x y : V),\n  inner (T y) x =\n    (inner (T (x + y)) (x + y) - inner (T (x - y)) (x - y) +\n          Complex.I * inner (T (x + Complex.I • y)) (x + Complex.I • y) -\n        Complex.I * inner (T (x - Complex.I • y)) (x - Complex.I • y)) /\n      4", "name": "inner_map_polarization", "isProp": true, "docString": "A complex polarization identity, with a linear map\n", "terms": "[\n    \"Complex\",\n    \"Polarization Identity\",\n    \"Linear Map\"\n]"}
{"type": "{α : Type u} → LazyList α → Thunk (LazyList α) → LazyList α", "name": "LazyList.append", "isProp": false, "docString": "Appends two lazy lists.  ", "terms": "[\"appends\", \"lazy lists\"]"}
{"type": "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Mul M] →\n      [inst_1 : Mul N] →\n        (c : Con M) →\n          (f : M → N) → (H : ∀ (x y : M), f (x * y) = f x * f y) → Con.mulKer f H ≤ c → Function.Surjective f → Con N", "name": "Con.mapOfSurjective", "isProp": false, "docString": "Given a surjective multiplicative-preserving function `f` whose kernel is contained in a\ncongruence relation `c`, the congruence relation on `f`'s codomain defined by '`x ≈ y` iff the\nelements of `f⁻¹(x)` are related to the elements of `f⁻¹(y)` by `c`.' ", "terms": "[\n    \"surjective\",\n    \"multiplicative-preserving function\",\n    \"kernel\",\n    \"contained\",\n    \"congruence relation\",\n    \"codomain\",\n    \"defined\",\n    \"elements\",\n    \"related\"\n]"}
{"type": "PNat.XgcdType → ℕ", "name": "PNat.XgcdType.r", "isProp": false, "docString": "`r = a % b`: remainder ", "terms": "[\"remainder\", \"%\"]"}
{"type": "{α : Type u_1} → Ordnode α → Ordnode α → Ordnode α", "name": "Ordnode.glue", "isProp": false, "docString": "**Internal use only**\n\nO(log(m + n)). Concatenate two trees that are balanced and ordered with respect to each other. ", "terms": "[\"O(log(m + n))\", \"Concatenate\", \"trees\", \"balanced\", \"ordered\", \"respect to each other\"]"}
{"type": "{R : Type u} →\n  [inst : Ring R] →\n    {M : Type v} →\n      [inst_1 : AddCommGroup M] → [inst_2 : Module R M] → (X : ModuleCat R) → [h : CategoryTheory.Epi 0] → Unique M", "name": "ModuleCat.uniqueOfEpiZero", "isProp": false, "docString": "If the zero morphism is an epi then the codomain is trivial. ", "terms": "[\n  \"zero morphism\",\n  \"epi\",\n  \"codomain\",\n  \"trivial\"\n]"}
{"type": "∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\n  (x : G), nhds ↑x = Filter.map QuotientAddGroup.mk (nhds x)", "name": "QuotientAddGroup.nhds_eq", "isProp": true, "docString": "Neighborhoods in the quotient are precisely the map of neighborhoods in the prequotient.", "terms": "[\n    \"Neighborhoods\",\n    \"quotient\",\n    \"map\",\n    \"prequotient\"\n]"}
{"type": "{X : Type u} →\n  [inst : TopologicalSpace X] →\n    {x₀ x₁ x₂ : X} →\n      {p₀ q₀ : Path x₀ x₁} →\n        {p₁ q₁ : Path x₁ x₂} →\n          Path.Homotopy p₀ q₀ → Path.Homotopy p₁ q₁ → Path.Homotopy (Path.trans p₀ p₁) (Path.trans q₀ q₁)", "name": "Path.Homotopy.hcomp", "isProp": false, "docString": "Suppose `p₀` and `q₀` are paths from `x₀` to `x₁`, `p₁` and `q₁` are paths from `x₁` to `x₂`.\nFurthermore, suppose `F : Homotopy p₀ q₀` and `G : Homotopy p₁ q₁`. Then we can define a homotopy\nfrom `p₀.trans p₁` to `q₀.trans q₁`.\n", "terms": "[\n  \"paths\",\n  \"Homotopy\",\n  \"trans\",\n  \"define\",\n  \"from\",\n  \"to\"\n]"}
{"type": "{𝕜 : Type u_3} →\n  {E : Type u_7} →\n    [inst : SeminormedRing 𝕜] → [inst_1 : AddCommGroup E] → [inst_2 : SMul 𝕜 E] → Seminorm 𝕜 E → E → ℝ → Set E", "name": "Seminorm.closedBall", "isProp": false, "docString": "The closed ball of radius `r` at `x` with respect to seminorm `p` is the set of elements `y`\nwith `p (y - x) ≤ r`. ", "terms": "[\n\"closed ball\",\n\"radius\",\n\"set\",\n\"elements\",\n\"seminorm\",\n\"respect to\",\n\"≤\"\n]"}
{"type": "{X : Type u_1} →\n  {Y : Type u_2} →\n    [inst : TopologicalSpace X] →\n      [inst_1 : TopologicalSpace Y] →\n        {Z : Type u_5} →\n          (R : Type u_4) →\n            [inst_2 : Semiring R] →\n              [inst_3 : AddCommMonoid Z] →\n                [inst_4 : Module R Z] → X ≃ₜ Y → LocallyConstant X Z ≃ₗ[R] LocallyConstant Y Z", "name": "LocallyConstant.congrLeftₗ", "isProp": false, "docString": "`LocallyConstant.congrLeft` as a linear equivalence. ", "terms": "[\"LocallyConstant\", \"congrLeft\", \"linear equivalence\"]"}
{"type": "{α : Type u_5} → {β : Type u_6} → [inst : NonAssocSemiring α] → [inst_1 : NonAssocSemiring β] → (α →+* β) → α →* β", "name": "RingHom.toMonoidHom", "isProp": false, "docString": "Reinterpret a ring homomorphism `f : α →+* β` as a monoid homomorphism `α →* β`.\nThe `simp`-normal form is `(f : α →* β)`. ", "terms": "[\n    \"ring homomorphism\",\n    \"monoid homomorphism\",\n    \"simp-normal form\"\n]"}
{"type": "{α : Type u_1} → (α → Bool) → List α → List α → Array α → List α", "name": "List.erasePTR.go", "isProp": false, "docString": "Auxiliary for `erasePTR`: `erasePTR.go p l xs acc = acc.toList ++ eraseP p xs`,\nunless `xs` does not contain any elements satisfying `p`, where it returns `l`. ", "terms": "[\n  \"Auxiliary\",\n  \"erasePTR\",\n  \"erasePTR.go\",\n  \"toList\",\n  \"++\",\n  \"eraseP\",\n  \"contain\",\n  \"elements\",\n  \"satisfying\",\n  \"returns\"\n]"}
{"type": "{V : Type u} →\n  [inst : CategoryTheory.Category.{v, u} V] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] →\n      (P Q : CochainComplex V ℕ) →\n        (zero : HomologicalComplex.X P 0 ⟶ HomologicalComplex.X Q 0) →\n          (one : HomologicalComplex.X P 1 ⟶ HomologicalComplex.X Q 1) →\n            CategoryTheory.CategoryStruct.comp zero (HomologicalComplex.d Q 0 1) =\n                CategoryTheory.CategoryStruct.comp (HomologicalComplex.d P 0 1) one →\n              ((n : ℕ) →\n                  (p :\n                      (f : HomologicalComplex.X P n ⟶ HomologicalComplex.X Q n) ×'\n                        (f' : HomologicalComplex.X P (n + 1) ⟶ HomologicalComplex.X Q (n + 1)) ×'\n                          CategoryTheory.CategoryStruct.comp f (HomologicalComplex.d Q n (n + 1)) =\n                            CategoryTheory.CategoryStruct.comp (HomologicalComplex.d P n (n + 1)) f') →\n                    (f'' : HomologicalComplex.X P (n + 2) ⟶ HomologicalComplex.X Q (n + 2)) ×'\n                      CategoryTheory.CategoryStruct.comp p.snd.fst (HomologicalComplex.d Q (n + 1) (n + 2)) =\n                        CategoryTheory.CategoryStruct.comp (HomologicalComplex.d P (n + 1) (n + 2)) f'') →\n                (n : ℕ) →\n                  (f : HomologicalComplex.X P n ⟶ HomologicalComplex.X Q n) ×'\n                    (f' : HomologicalComplex.X P (n + 1) ⟶ HomologicalComplex.X Q (n + 1)) ×'\n                      CategoryTheory.CategoryStruct.comp f (HomologicalComplex.d Q n (n + 1)) =\n                        CategoryTheory.CategoryStruct.comp (HomologicalComplex.d P n (n + 1)) f'", "name": "CochainComplex.mkHomAux", "isProp": false, "docString": "An auxiliary construction for `mkHom`.\n\nHere we build by induction a family of commutative squares,\nbut don't require at the type level that these successive commutative squares actually agree.\nThey do in fact agree, and we then capture that at the type level (i.e. by constructing a chain map)\nin `mkHom`.\n", "terms": "[\n  \"auxiliary construction\",\n  \"mkHom\",\n  \"induction\",\n  \"family\",\n  \"commutative squares\",\n  \"type level\",\n  \"chain map\"\n]"}
{"type": "∀ {R : Type u_1} [inst : StrictOrderedCommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {x y : M}, SameRay R (-x) (-y) ↔ SameRay R x y", "name": "sameRay_neg_iff", "isProp": true, "docString": "`SameRay.neg` as an `iff`. ", "terms": "[\"SameRay.neg\", \"iff\"]"}
{"type": "{ι : Type u_3} →\n  {χ : ι → Type u_4} →\n    [inst : (i : ι) → TopologicalSpace (χ i)] → {as bs : (i : ι) → χ i} → ((i : ι) → Path (as i) (bs i)) → Path as bs", "name": "Path.pi", "isProp": false, "docString": "Given a family of paths, one in each Xᵢ, we take their pointwise product to get a path in\nΠ i, Xᵢ. ", "terms": "[\n\"family of paths\",\n\"pointwise product\",\n\"path\"\n]"}
{"type": "{F : Type u → Type u} → [inst : Functor F] → {α : Type u} → (α → Prop) → F α → Prop", "name": "Functor.Liftp", "isProp": false, "docString": "If we consider `x : F α` to, in some sense, contain values of type `α`,\npredicate `Liftp p x` holds iff every value contained by `x` satisfies `p`. ", "terms": "[\"F\", \"α\", \"type\", \"Liftp\", \"p\", \"value\", \"satisfies\", \"predicate\", \"holds\", \"iff\", \"every\", \"contains\", \"consider\"]"}
{"type": "{α : Type u_1} → {x : MeasurableSpace α} → MeasureTheory.VectorMeasure α ENNReal → MeasureTheory.Measure α", "name": "MeasureTheory.VectorMeasure.ennrealToMeasure", "isProp": false, "docString": "A vector measure over `ℝ≥0∞` is a measure. ", "terms": "[\n    \"vector measure\",\n    \"ℝ≥0∞\",\n    \"measure\"\n]"}
{"type": "{α : Type u_2} → [inst : DecidableEq α] → [inst_1 : Mul α] → [inst_2 : HasDistribNeg α] → HasDistribNeg (Finset α)", "name": "Finset.distribNeg", "isProp": false, "docString": "`Finset α` has distributive negation if `α` has. ", "terms": "[\"Finset\", \"distributive negation\"]"}
{"type": "∀ {K : Type u} [self : Field K] (a : K), Field.zpow 0 a = 1", "name": "Field.zpow_zero'", "isProp": true, "docString": "`a ^ 0 = 1` ", "terms": "[\"exponentiation\", \"zero\", \"one\", \"equality\"]"}
{"type": "∀ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {Q : QuadraticForm R M} (d : Module.Dual R M) (a : M) (b : CliffordAlgebra Q),\n  (CliffordAlgebra.contractRight (b * (CliffordAlgebra.ι Q) a)) d =\n    d a • b - (CliffordAlgebra.contractRight b) d * (CliffordAlgebra.ι Q) a", "name": "CliffordAlgebra.contractRight_mul_ι", "isProp": true, "docString": "This is [grinberg_clifford_2016][] Theorem 12  ", "terms": "[]"}
{"type": "∀ {α : Type u_2} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a", "name": "LinearOrderedSemifield.zpow_succ'", "isProp": true, "docString": "`a ^ (n + 1) = a * a ^ n` ", "terms": "[\"exponentiation\", \"multiplication\", \"addition\"]"}
{"type": "∀ {d : ℤ} {a₁ : Pell.Solution₁ d},\n  Pell.IsFundamental a₁ →\n    ∀ {a : Pell.Solution₁ d}, 1 < Pell.Solution₁.x a → 0 < Pell.Solution₁.y a → Pell.Solution₁.y a₁ ≤ Pell.Solution₁.y a", "name": "Pell.IsFundamental.y_le_y", "isProp": true, "docString": "The `y`-coordinate of a fundamental solution is a lower bound for the `y`-coordinate\nof any positive solution. ", "terms": "[\n  \"coordinate\",\n  \"fundamental solution\",\n  \"lower bound\",\n  \"positive solution\"\n]"}
{"type": "{R : Type u_1} →\n  [inst : CommRing R] →\n    (S : Submonoid R) →\n      {M : Type u_2} →\n        {M' : Type u_3} →\n          [inst_1 : AddCommMonoid M] →\n            [inst_2 : AddCommMonoid M'] →\n              [inst_3 : Module R M] →\n                [inst_4 : Module R M'] → (f : M →ₗ[R] M') → [inst_5 : IsLocalizedModule S f] → LocalizedModule S M → M'", "name": "IsLocalizedModule.fromLocalizedModule'", "isProp": false, "docString": "If `(M', f : M ⟶ M')` satisfies universal property of localized module, there is a canonical\nmap `LocalizedModule S M ⟶ M'`.\n", "terms": "[\n    \"Universal Property\",\n    \"Localized Module\",\n    \"Canonical Map\"\n]"}
{"type": "∀ {X : Type u_2} {Y : Type u_3} [inst : EMetricSpace X] [inst_1 : EMetricSpace Y] [inst_2 : SecondCountableTopology X]\n  {f : X → Y} {s : Set X}, (∀ x ∈ s, ∃ C, ∃ t ∈ nhdsWithin x s, LipschitzOnWith C f t) → dimH (f '' s) ≤ dimH s", "name": "dimH_image_le_of_locally_lipschitzOn", "isProp": true, "docString": "If `s` is a set in an extended metric space `X` with second countable topology and `f : X → Y`\nis Lipschitz in a neighborhood within `s` of every point `x ∈ s`, then the Hausdorff dimension of\nthe image `f '' s` is at most the Hausdorff dimension of `s`. ", "terms": "[\n    \"set\",\n    \"extended metric space\",\n    \"second countable topology\",\n    \"Lipschitz\",\n    \"neighborhood\",\n    \"point\",\n    \"Hausdorff dimension\",\n    \"image\"\n]"}
{"type": "{R : Type u_3} →\n  {Γ₀ : Type u_4} →\n    {Γ'₀ : Type u_5} →\n      [inst : Ring R] →\n        [inst_1 : LinearOrderedAddCommMonoidWithTop Γ₀] →\n          [inst_2 : LinearOrderedAddCommMonoidWithTop Γ'₀] →\n            (f : Γ₀ →+ Γ'₀) → f ⊤ = ⊤ → Monotone ⇑f → AddValuation R Γ₀ → AddValuation R Γ'₀", "name": "AddValuation.map", "isProp": false, "docString": "A `≤`-preserving, `⊤`-preserving group homomorphism `Γ₀ → Γ'₀` induces a map\n`AddValuation R Γ₀ → AddValuation R Γ'₀`.\n", "terms": "[\n    \"≤-preserving\",\n    \"⊤-preserving\",\n    \"group homomorphism\",\n    \"induces\",\n    \"map\",\n    \"AddValuation\"\n]"}
{"type": "{α : Type u_2} → [inst : Sub α] → Sub (Set α)", "name": "Set.sub", "isProp": false, "docString": "The pointwise subtraction of sets `s - t` is defined as `{x - y | x ∈ s, y ∈ t}` in locale\n`Pointwise`.", "terms": "[\n  \"pointwise subtraction\",\n  \"sets\",\n  \"defined\",\n  \"locale\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {J X Y : C} →\n      [inst_1 : CategoryTheory.Injective J] → (X ⟶ J) → (f : X ⟶ Y) → [inst_2 : CategoryTheory.Mono f] → Y ⟶ J", "name": "CategoryTheory.Injective.factorThru", "isProp": false, "docString": "Let `J` be injective and `g` a morphism into `J`, then `g` can be factored through any monomorphism.\n", "terms": "[\n    \"injective\",\n    \"morphism\",\n    \"factored\",\n    \"monomorphism\"\n]"}
{"type": "∀ {F : Type u_16} {M : outParam (Type u_17)} {A : outParam (Type u_18)} {B : outParam (Type u_19)} [inst : Monoid M]\n  [inst_1 : AddMonoid A] [inst_2 : AddMonoid B] [inst_3 : DistribMulAction M A] [inst_4 : DistribMulAction M B]\n  [self : DistribMulActionHomClass F M A B] (f : F) (x y : A), f (x + y) = f x + f y", "name": "DistribMulActionHomClass.map_add", "isProp": true, "docString": "The proposition that the function preserves addition ", "terms": "[\n    \"proposition\",\n    \"function\",\n    \"preserves\",\n    \"addition\"\n]"}
{"type": "∀ (X : Type u_4) [inst : TopologicalSpace X] [inst_1 : PreirreducibleSpace X] [inst_2 : Nontrivial X]\n  [inst : T2Space X], False", "name": "not_preirreducible_nontrivial_t2", "isProp": true, "docString": "There does not exist a nontrivial preirreducible T₂ space. ", "terms": "[\n  \"exist\",\n  \"nontrivial\",\n  \"preirreducible\",\n  \"T₂ space\"\n]"}
{"type": "(p : ENNReal) →\n  (α : Type u_2) →\n    (β : Type u_3) →\n      [hp : Fact (1 ≤ p)] → [inst : MetricSpace α] → [inst : MetricSpace β] → MetricSpace (WithLp p (α × β))", "name": "WithLp.instProdMetricSpace", "isProp": false, "docString": "`MetricSpace` instance on the product of two metric spaces, using the `L^p` distance,\nand having as uniformity the product uniformity. ", "terms": "[\n    \"MetricSpace\",\n    \"Product\",\n    \"Metric Spaces\",\n    \"L^p Distance\",\n    \"Uniformity\",\n    \"Product Uniformity\"\n]"}
{"type": "{J : Type v} →\n  [inst : CategoryTheory.SmallCategory J] → (F : CategoryTheory.Functor J CompHaus) → CategoryTheory.Limits.Cone F", "name": "CompHaus.limitCone", "isProp": false, "docString": "An explicit limit cone for a functor `F : J ⥤ CompHaus`, defined in terms of\n`TopCat.limitCone`. ", "terms": "[\n  \"explicit\",\n  \"limit cone\",\n  \"functor\",\n  \"defined\",\n  \"terms\",\n  \"TopCat.limitCone\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : TopologicalSpace β]\n  [inst_3 : ClosedIciTopology α] {f : β → α},\n  Continuous f → ∀ (x₀ : β), (∀ᶠ (x : β) in Filter.cocompact β, f x ≤ f x₀) → ∃ x, ∀ (y : β), f y ≤ f x", "name": "Continuous.exists_forall_ge'", "isProp": true, "docString": "The **extreme value theorem**: if a continuous function `f` is smaller than a value in its range\naway from compact sets, then it has a global maximum. ", "terms": "[\n    \"Extreme Value Theorem\",\n    \"Continuous Function\",\n    \"Value\",\n    \"Range\",\n    \"Compact Sets\",\n    \"Global Maximum\"\n]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.IsFiltered C] {D : Type u₁}\n  [inst_2 : CategoryTheory.Category.{v₁, u₁} D], (C ≌ D) → CategoryTheory.IsFiltered D", "name": "CategoryTheory.IsFiltered.of_equivalence", "isProp": true, "docString": "Being filtered is preserved by equivalence of categories. ", "terms": "[\n    \"filtered\",\n    \"preserved\",\n    \"equivalence\",\n    \"categories\"\n]"}
{"type": "{A B : GroupCat} → (f : A ⟶ B) → ↑B →* Equiv.Perm (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity f)", "name": "GroupCat.SurjectiveOfEpiAuxs.h", "isProp": false, "docString": "Define `h : B ⟶ S(X')` to be `τ g τ⁻¹`\n", "terms": "[\"Define\", \"B\", \"S\", \"X'\", \"τ\", \"g\", \"τ⁻¹\"]"}
{"type": "{V : Type u} →\n  [inst : CategoryTheory.Category.{v, u} V] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] →\n      [inst_2 : CategoryTheory.Limits.HasZeroObject V] →\n        {ι : Type u_1} →\n          [inst_3 : DecidableEq ι] →\n            (c : ComplexShape ι) →\n              (j : ι) →\n                (A : V) → (i : ι) → i = j → (HomologicalComplex.X ((HomologicalComplex.single V c j).obj A) i ≅ A)", "name": "HomologicalComplex.singleObjXIsoOfEq", "isProp": false, "docString": "The object in degree `i` of `(single V c h).obj A` is just `A` when `i = j`. ", "terms": "[\"object\", \"degree\", \"single\", \"obj\"]"}
{"type": "{G : Type u_1} →\n  {G' : Type u_2} →\n    [inst : Group G] → [inst_1 : Group G'] → (e : G ≃* G') → (H : Subgroup G) → ↥H ≃* ↥(Subgroup.map (↑e) H)", "name": "MulEquiv.subgroupMap", "isProp": false, "docString": "A subgroup is isomorphic to its image under an isomorphism. If you only have an injective map,\nuse `Subgroup.equiv_map_of_injective`. ", "terms": "[\n  \"subgroup\",\n  \"isomorphic\",\n  \"image\",\n  \"isomorphism\",\n  \"injective map\",\n  \"equiv_map_of_injective\"\n]"}
{"type": "{n : ℕ} → {α : Type u_1} → [inst : LinearOrder α] → (f : Fin n → α) → Fin n ≃o { x // x ∈ Tuple.graph f }", "name": "Tuple.graphEquiv₂", "isProp": false, "docString": "`graphEquiv₂ f` is an equivalence between `Fin n` and `graph f` that respects the order.\n", "terms": "[\n  \"equivalence\",\n  \"Fin\",\n  \"graph\",\n  \"order\",\n  \"respects\"\n]"}
{"type": "∀ {X : Type u_1} [inst : TopologicalSpace X],\n  (∀ (f : X → Prop) (a : X),\n      (∀ (u : ℕ → X), Filter.Tendsto u Filter.atTop (nhds a) → Filter.Tendsto (f ∘ u) Filter.atTop (nhds (f a))) →\n        ContinuousAt f a) →\n    FrechetUrysohnSpace X", "name": "FrechetUrysohnSpace.of_seq_tendsto_imp_tendsto", "isProp": true, "docString": "An alternative construction for `FrechetUrysohnSpace`: if sequential convergence implies\nconvergence, then the space is a Fréchet-Urysohn space. ", "terms": "[\n    \"alternative construction\",\n    \"FrechetUrysohnSpace\",\n    \"sequential convergence\",\n    \"convergence\",\n    \"space\",\n    \"Fréchet-Urysohn space\"\n]"}
{"type": "∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K} {n : ℕ}\n  {ifp_succ_n : GeneralizedContinuedFraction.IntFractPair K},\n  GeneralizedContinuedFraction.IntFractPair.stream v (n + 1) = some ifp_succ_n ↔\n    ∃ ifp_n,\n      GeneralizedContinuedFraction.IntFractPair.stream v n = some ifp_n ∧\n        ifp_n.fr ≠ 0 ∧ GeneralizedContinuedFraction.IntFractPair.of ifp_n.fr⁻¹ = ifp_succ_n", "name": "GeneralizedContinuedFraction.IntFractPair.succ_nth_stream_eq_some_iff", "isProp": true, "docString": "Gives a recurrence to compute the `n + 1`th value of the sequence of integer and fractional\nparts of a value in case of non-termination.\n", "terms": "[\"recurrence\", \"compute\", \"sequence\", \"integer\", \"fractional parts\", \"value\", \"non-termination\"]"}
{"type": "{K : Type u_1} → [inst : Field K] → {φ : K →+* ℂ} → NumberField.ComplexEmbedding.IsReal φ → K →+* ℝ", "name": "NumberField.ComplexEmbedding.IsReal.embedding", "isProp": false, "docString": "A real embedding as a ring homomorphism from `K` to `ℝ` . ", "terms": "[\"real embedding\", \"ring homomorphism\"]"}
{"type": "∀ {X : Type u_2} {Y : Type u_3} [inst : EMetricSpace X] [inst_1 : EMetricSpace Y] {C r : NNReal} {f : X → Y}\n  {s : Set X}, HolderOnWith C r f s → 0 < r → dimH (f '' s) ≤ dimH s / ↑r", "name": "HolderOnWith.dimH_image_le", "isProp": true, "docString": "If `f` is a Hölder continuous map with exponent `r > 0`, then `dimH (f '' s) ≤ dimH s / r`. ", "terms": "[\n  \"Hölder continuous map\",\n  \"exponent\",\n  \"dimH\",\n  \"''\",\n  \"≤\",\n  \"/\"\n]"}
{"type": "∀ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R", "name": "NonarchimedeanRing.to_nonarchimedeanAddGroup", "isProp": true, "docString": "Every nonarchimedean ring is naturally a nonarchimedean additive group. ", "terms": "[\"nonarchimedean ring\", \"nonarchimedean additive group\"]"}
{"type": "∀ {M : Type u_3} [inst : AddMonoid M] (l : List M), Option.getD (List.get? l 0) 0 + List.sum (List.tail l) = List.sum l", "name": "List.get?_zero_add_tail_sum", "isProp": true, "docString": "We'd like to state this as `L.headI + L.tail.sum = L.sum`, but because `L.headI`\nrelies on an inhabited instance to return a garbage value on the empty list, this is not possible.\nInstead, we write the statement in terms of `(L.get? 0).getD 0`.", "terms": "[\n    \"headI\",\n    \"tail\",\n    \"sum\",\n    \"inhabited instance\",\n    \"empty list\",\n    \"get?\",\n    \"getD\"\n]"}
{"type": "∀ {α : Type u_3} {E : Type u_6} [inst : NormedAddGroup E] [inst_1 : TopologicalSpace α] {f : α → E},\n  HasCompactSupport f → HasCompactSupport fun x => ‖f x‖", "name": "HasCompactSupport.norm", "isProp": true, "docString": "**Alias** of the reverse direction of `hasCompactSupport_norm_iff`.", "terms": "[]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_3} [inst : SeminormedRing 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\n  {t t' : TopologicalSpace E}, t ≤ t' → ∀ {s : Set E}, Bornology.IsVonNBounded 𝕜 s → Bornology.IsVonNBounded 𝕜 s", "name": "Bornology.IsVonNBounded.of_topologicalSpace_le", "isProp": true, "docString": "If a topology `t'` is coarser than `t`, then any set `s` that is bounded with respect to\n`t` is bounded with respect to `t'`. ", "terms": "[\n    \"topology\",\n    \"coarser\",\n    \"set\",\n    \"bounded\"\n]"}
{"type": "{T : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} T] →\n    {X : T} → CategoryTheory.Limits.IsInitial (CategoryTheory.Under.mk (CategoryTheory.CategoryStruct.id X))", "name": "CategoryTheory.Under.mkIdInitial", "isProp": false, "docString": "The identity under `X` is initial. ", "terms": "[\"identity\", \"initial\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        (F : CategoryTheory.Functor C D) →\n          {X Y Z : C} →\n            (f : X ⟶ Y) →\n              (g : X ⟶ Z) →\n                CategoryTheory.Functor.comp (CategoryTheory.Limits.span f g) F ≅\n                  CategoryTheory.Limits.span (F.map f) (F.map g)", "name": "CategoryTheory.Limits.spanCompIso", "isProp": false, "docString": "A functor applied to a span is a span. ", "terms": "[\n    \"functor\",\n    \"applied\",\n    \"span\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      {S : CategoryTheory.ShortComplex C} →\n        CategoryTheory.ShortComplex.HomologyData S → CategoryTheory.ShortComplex.LeftHomologyData S", "name": "CategoryTheory.ShortComplex.HomologyData.left", "isProp": false, "docString": "a left homology data ", "terms": "[\"left\", \"homology\", \"data\"]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {P Q : CategoryTheory.Functor Cᵒᵖ (Type w)} →\n      {X : C} →\n        {R : CategoryTheory.Presieve X} →\n          (P ⟶ Q) → CategoryTheory.Presieve.FamilyOfElements P R → CategoryTheory.Presieve.FamilyOfElements Q R", "name": "CategoryTheory.Presieve.FamilyOfElements.compPresheafMap", "isProp": false, "docString": "Given a morphism of presheaves `f : P ⟶ Q`, we can take a family of elements valued in `P` to a\nfamily of elements valued in `Q` by composing with `f`.\n", "terms": "[\n    \"morphism\",\n    \"presheaves\",\n    \"family of elements\",\n    \"valued in\",\n    \"composing\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      {D : Type u₂} →\n        [inst_2 : CategoryTheory.Category.{v₂, u₂} D] →\n          (e : C ≌ D) →\n            CategoryTheory.LaxMonoidalFunctor.id C ≅\n              (CategoryTheory.Monoidal.toTransported e).toLaxMonoidalFunctor ⊗⋙\n                (CategoryTheory.Monoidal.fromTransported e).toLaxMonoidalFunctor", "name": "CategoryTheory.Monoidal.transportedMonoidalUnitIso", "isProp": false, "docString": "The unit isomorphism upgrades to a monoidal isomorphism. ", "terms": "[\n    \"unit\",\n    \"isomorphism\",\n    \"upgrades\",\n    \"monoidal\"\n]"}
{"type": "{α : Type u} → FreeAddSemigroup α → List α", "name": "FreeAddSemigroup.tail", "isProp": false, "docString": "The tail of the element ", "terms": "[\"tail\", \"element\"]"}
{"type": "{β : Type w} →\n  {C : Type u} →\n    [inst : CategoryTheory.Category.{v, u} C] →\n      {D : Type u₂} →\n        [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n          (G : CategoryTheory.Functor C D) →\n            (f : β → C) →\n              [inst_2 : CategoryTheory.Limits.HasProduct f] →\n                [inst_3 : CategoryTheory.Limits.HasProduct fun b => G.obj (f b)] → G.obj (∏ f) ⟶ ∏ fun b => G.obj (f b)", "name": "CategoryTheory.Limits.piComparison", "isProp": false, "docString": "The comparison morphism for the product of `f`. This is an iso iff `G` preserves the product\nof `f`, see `PreservesProduct.ofIsoComparison`. ", "terms": "[\n  \"comparison morphism\",\n  \"product\",\n  \"iso\",\n  \"preserves\",\n  \"PreservesProduct.ofIsoComparison\"\n]"}
{"type": "∀ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E] [inst_3 : T2Space E]\n  [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousSMul ℝ E] [inst_6 : LocallyConvexSpace ℝ E] {s : Set E},\n  IsCompact s → Set.Nonempty s → Set.Nonempty (Set.extremePoints ℝ s)", "name": "IsCompact.extremePoints_nonempty", "isProp": true, "docString": "**Krein-Milman lemma**: In a LCTVS, any nonempty compact set has an extreme point. ", "terms": "[\n    \"Krein-Milman lemma\",\n    \"LCTVS\",\n    \"nonempty\",\n    \"compact set\",\n    \"extreme point\"\n]"}
{"type": "(X : Type u_5) → [inst : TopologicalSpace X] → [h : TopologicalSpace.PseudoMetrizableSpace X] → PseudoMetricSpace X", "name": "TopologicalSpace.pseudoMetrizableSpacePseudoMetric", "isProp": false, "docString": "Construct on a metrizable space a metric compatible with the topology. ", "terms": "[\n  \"Construct\",\n  \"Metrizable Space\",\n  \"Metric\",\n  \"Compatible\",\n  \"Topology\"\n]"}
{"type": "(G : Type u) →\n  [inst : Group G] →\n    (α : Type v) →\n      [inst_1 : MulAction G α] → α ≃ (ω : MulAction.orbitRel.Quotient G α) × ↑(MulAction.orbitRel.Quotient.orbit ω)", "name": "MulAction.selfEquivSigmaOrbits'", "isProp": false, "docString": "Decomposition of a type `X` as a disjoint union of its orbits under a group action.\n\nThis version is expressed in terms of `MulAction.orbitRel.Quotient.orbit` instead of\n`MulAction.orbit`, to avoid mentioning `Quotient.out'`. ", "terms": "[\n    \"Decomposition\",\n    \"Type\",\n    \"Disjoint Union\",\n    \"Orbits\",\n    \"Group Action\",\n    \"MulAction.orbitRel.Quotient.orbit\",\n    \"MulAction.orbit\",\n    \"Quotient.out\"\n]"}
{"type": "{R : Type u} →\n  [inst : CommMonoid R] → {R' : Type v} → [inst_1 : CommMonoidWithZero R'] → MulChar R R' → MulChar R R' → MulChar R R'", "name": "MulChar.mul", "isProp": false, "docString": "Multiplication of multiplicative characters. (This needs the target to be commutative.) ", "terms": "[\n  \"Multiplication\",\n  \"Multiplicative characters\",\n  \"Commutative\"\n]"}
{"type": "{ι : Type u} →\n  {β : ι → Type v} →\n    [dec : DecidableEq ι] →\n      [inst : (i : ι) → Zero (β i)] → [inst_1 : (i : ι) → (x : β i) → Decidable (x ≠ 0)] → (Π₀ (i : ι), β i) → Finset ι", "name": "DFinsupp.support", "isProp": false, "docString": "Set `{i | f x ≠ 0}` as a `Finset`. ", "terms": "[\n    \"Set\",\n    \"Finset\"\n]"}
{"type": "CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} MonCatMax", "name": "MonCat.hasLimitsOfSize", "isProp": true, "docString": "The category of monoids has all limits. ", "terms": "[\n  \"Category\",\n  \"Monoids\",\n  \"Limits\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      [inst_2 : CategoryTheory.Limits.HasCoequalizers C] →\n        [inst_3 :\n            (X : C) →\n              CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁}\n                (CategoryTheory.MonoidalCategory.tensorLeft X)] →\n          [inst_4 :\n              (X : C) →\n                CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁}\n                  (CategoryTheory.MonoidalCategory.tensorRight X)] →\n            {W X Y Z : Mon_ C} →\n              (L : Bimod W X) →\n                (M : Bimod X Y) →\n                  (N : Bimod Y Z) →\n                    Bimod.tensorBimod (Bimod.tensorBimod L M) N ≅ Bimod.tensorBimod L (Bimod.tensorBimod M N)", "name": "Bimod.associatorBimod", "isProp": false, "docString": "The associator as a bimodule isomorphism. ", "terms": "[\n  \"associator\",\n  \"bimodule\",\n  \"isomorphism\"\n]"}
{"type": "(α : Type u_3) → (β : Type u_4) → [inst : MulOneClass α] → [inst_1 : CommMonoid β] → (α →* β) →* α → β", "name": "MonoidHom.coeFn", "isProp": false, "docString": "Coercion of a `MonoidHom` into a function is itself a `MonoidHom`.\n\nSee also `MonoidHom.eval`. ", "terms": "[\"Coercion\", \"MonoidHom\", \"function\", \"eval\"]"}
{"type": "(V : Type (u + 1)) →\n  [inst : CategoryTheory.LargeCategory V] →\n    (G : MonCat) → Action V G ≌ CategoryTheory.Functor (CategoryTheory.SingleObj ↑G) V", "name": "Action.functorCategoryEquivalence", "isProp": false, "docString": "The category of actions of `G` in the category `V`\nis equivalent to the functor category `singleObj G ⥤ V`.\n", "terms": "[\n  \"category\",\n  \"actions\",\n  \"equivalent\",\n  \"functor category\"\n]"}
{"type": "∀ {α : Type u_1} {E : Type u_3} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} [inst : MetricSpace E]\n  {f : ℕ → α → E} {g : α → E} [inst_1 : MeasureTheory.IsFiniteMeasure μ],\n  (∀ (n : ℕ), MeasureTheory.StronglyMeasurable (f n)) →\n    MeasureTheory.StronglyMeasurable g →\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) →\n        MeasureTheory.TendstoInMeasure μ f Filter.atTop g", "name": "MeasureTheory.tendstoInMeasure_of_tendsto_ae_of_stronglyMeasurable", "isProp": true, "docString": "Auxiliary lemma for `tendstoInMeasure_of_tendsto_ae`. ", "terms": "[]"}
{"type": "Lean.ParserDescr", "name": "Mathlib.Notation3.notation3Item", "isProp": false, "docString": "`notation3` argument. ", "terms": "[]"}
{"type": "{n : ℕ} →\n  {α : TypeVec.{u_1} n} →\n    {α' : TypeVec.{u_2} n} →\n      {β : Type u_1} → {β' : Type u_2} → TypeVec.Arrow α α' → (β → β') → TypeVec.Arrow (α ::: β) (α' ::: β')", "name": "TypeVec.appendFun", "isProp": false, "docString": "append an arrow and a function as well as their respective source and target types / typevecs ", "terms": "[\n    \"append\",\n    \"arrow\",\n    \"function\",\n    \"source\",\n    \"target\",\n    \"types\",\n    \"typevecs\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {X Y Z : C} →\n      {f : X ⟶ Z} →\n        {g : Y ⟶ Z} →\n          (c : CategoryTheory.Limits.PullbackCone f g) →\n            CategoryTheory.Limits.PushoutCocone.unop (CategoryTheory.Limits.PullbackCone.op c) ≅ c", "name": "CategoryTheory.Limits.PullbackCone.opUnop", "isProp": false, "docString": "If `c` is a pullback cone, then `c.op.unop` is isomorphic to `c`. ", "terms": "[\n    \"pullback cone\",\n    \"isomorphic\"\n]"}
{"type": "{α : Type u} → [inst : LT α] → [hwo : IsWellOrder α fun x x_1 => x < x_1] → WellFoundedRelation α", "name": "IsWellOrder.toHasWellFounded", "isProp": false, "docString": "Derive a `WellFoundedRelation` instance from an `IsWellOrder` instance. ", "terms": "[\"Derive\", \"WellFoundedRelation\", \"instance\", \"IsWellOrder\"]"}
{"type": "∀ {n : ℕ} (q : ℕ) {p : ℕ},\n  Nat.Prime p →\n    p ≤ 2 * q → (n < q → ∃ p, Nat.Prime p ∧ n < p ∧ p ≤ 2 * n) → n < p → ∃ p, Nat.Prime p ∧ n < p ∧ p ≤ 2 * n", "name": "Nat.exists_prime_lt_and_le_two_mul_succ", "isProp": true, "docString": "Proves that Bertrand's postulate holds over all positive naturals less than n by identifying a\ndescending list of primes, each no more than twice the next, such that the list contains a witness\nfor each number ≤ n.\n", "terms": "[\n    \"Bertrand's postulate\",\n    \"positive naturals\",\n    \"descending\",\n    \"primes\",\n    \"twice\",\n    \"next\",\n    \"list\",\n    \"contains\",\n    \"witness\",\n    \"number\",\n    \"≤\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} {M : Type w} [inst : DecidableEq β] {s : Finset α} {t : Finset β} {f : α → β} {w : α → M}\n  {b : M} [inst_1 : LinearOrderedCancelAddCommMonoid M],\n  (∀ y ∉ t, (Finset.sum (Finset.filter (fun x => f x = y) s) fun x => w x) ≤ 0) →\n    (Finset.card t • b < Finset.sum s fun x => w x) →\n      ∃ y ∈ t, b < Finset.sum (Finset.filter (fun x => f x = y) s) fun x => w x", "name": "Finset.exists_lt_sum_fiber_of_sum_fiber_nonpos_of_nsmul_lt_sum", "isProp": true, "docString": "The pigeonhole principle for finitely many pigeons counted by weight, strict inequality version:\nif the total weight of a finite set of pigeons is greater than `n • b`, they are sorted into some\npigeonholes, and for all but `n` pigeonholes the total weight of the pigeons there is nonpositive,\nthen for at least one of these `n` pigeonholes, the total weight of the pigeons in this pigeonhole\nis greater than `b`. ", "terms": "[\n    \"Pigeonhole principle\",\n    \"finitely many\",\n    \"total weight\",\n    \"finite set\",\n    \"greater than\",\n    \"sorted into\",\n    \"for all but\",\n    \"total weight\",\n    \"nonpositive\",\n    \"at least one\",\n    \"greater than\"\n]"}
{"type": "{M : Type uM} → {N : Type uN} → [inst : MulOneClass M] → [inst_1 : CommMonoid N] → M →* (M →* N) →* N", "name": "MonoidHom.eval", "isProp": false, "docString": "Evaluation of a `MonoidHom` at a point as a monoid homomorphism. See also `MonoidHom.apply`\nfor the evaluation of any function at a point. ", "terms": "[\n    \"Evaluation\",\n    \"MonoidHom\",\n    \"point\",\n    \"monoid homomorphism\",\n    \"MonoidHom.apply\",\n    \"function\",\n    \"evaluation\"\n]"}
{"type": "∀ {α : Type u} (S T : Set α), Cardinal.mk ↑(S ∪ T) ≤ Cardinal.mk ↑S + Cardinal.mk ↑T", "name": "Cardinal.mk_union_le", "isProp": true, "docString": "The cardinality of a union is at most the sum of the cardinalities\nof the two sets. ", "terms": "[\n  \"cardinality\",\n  \"union\",\n  \"sum\",\n  \"sets\"\n]"}
{"type": "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      [inst : UniformSpace β] → [inst_1 : UniformSpace γ] → UniformFun α (β × γ) ≃ᵤ UniformFun α β × UniformFun α γ", "name": "UniformFun.uniformEquivProdArrow", "isProp": false, "docString": "The natural bijection between `α → β × γ` and `(α → β) × (α → γ)`, upgraded to a uniform\nisomorphism between `α →ᵤ β × γ` and `(α →ᵤ β) × (α →ᵤ γ)`. ", "terms": "[\n    \"natural bijection\",\n    \"isomorphism\",\n    \"uniform isomorphism\"\n]"}
{"type": "∀ (A : Type u_2) (K : Type u_3) [inst : CommRing A] [inst_1 : Field K] [inst_2 : IsDomain A] [inst_3 : Algebra A K]\n  [inst_4 : IsFractionRing A K] (L : Type u_4) [inst_5 : Field L] [inst_6 : Algebra K L] [inst_7 : Algebra A L]\n  [inst_8 : IsScalarTower A K L] [inst_9 : FiniteDimensional K L], ∃ s b, ∀ (x : { x // x ∈ s }), IsIntegral A (b x)", "name": "FiniteDimensional.exists_is_basis_integral", "isProp": true, "docString": "If `L` is a finite extension of `K = Frac(A)`,\nthen `L` has a basis over `A` consisting of integral elements. ", "terms": "[\n  \"finite extension\",\n  \"Frac\",\n  \"basis\",\n  \"integral elements\"\n]"}
{"type": "∀ {α : Sort u_1} {k l k' l' : ℕ} (h : k = l) (h' : k' = l') {f : Fin k → Fin k' → α} {g : Fin l → Fin l' → α},\n  HEq f g ↔\n    ∀ (i : Fin k) (j : Fin k'), f i j = g { val := ↑i, isLt := (_ : ↑i < l) } { val := ↑j, isLt := (_ : ↑j < l') }", "name": "Fin.heq_fun₂_iff", "isProp": true, "docString": "Assume `k = l` and `k' = l'`.\nIf two functions `Fin k → Fin k' → α` and `Fin l → Fin l' → α` are equal on each pair,\nthen they coincide (in the heq sense). ", "terms": "[\n\"Assume\",\n\"equal\",\n\"functions\",\n\"pair\",\n\"coincide\",\n\"heq sense\"\n]"}
{"type": "Type", "name": "Task.Priority", "isProp": false, "docString": "Task priority. Tasks with higher priority will always be scheduled before ones with lower priority. ", "terms": "[]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    {X : AlgebraicGeometry.PresheafedSpace C} →\n      (Y : AlgebraicGeometry.SheafedSpace C) →\n        (f : X ⟶ Y.toPresheafedSpace) →\n          [H : AlgebraicGeometry.PresheafedSpace.IsOpenImmersion f] → AlgebraicGeometry.SheafedSpace C", "name": "AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.toSheafedSpace", "isProp": false, "docString": "If `X ⟶ Y` is an open immersion, and `Y` is a SheafedSpace, then so is `X`. ", "terms": "[\n  \"open immersion\",\n  \"SheafedSpace\"\n]"}
{"type": "∀ (M : Type u_1) (α : Type u_2) [inst : Group M] [inst_1 : MulAction M α] {ι : Sort u_3} {P : ι → Subgroup M},\n  MulAction.fixedPoints (↥(iSup P)) α = ⋂ i, MulAction.fixedPoints (↥(P i)) α", "name": "fixedPoints_subgroup_iSup", "isProp": true, "docString": "Fixed points of iSup of subgroups is intersection ", "terms": "[\n    \"Fixed points\",\n    \"iSup\",\n    \"subgroups\",\n    \"intersection\"\n]"}
{"type": "∀ {M : Type u_10} {A : Type u_11} [inst : Monoid M] [inst_1 : Monoid A] [self : MulDistribMulAction M A] (r : M)\n  (x y : A), r • (x * y) = r • x * r • y", "name": "MulDistribMulAction.smul_mul", "isProp": true, "docString": "Distributivity of `•` across `*` ", "terms": "[\"Distributivity\", \"•\", \"*\"]"}
{"type": "∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : ℤ), ↑(legendreSym p a) = ↑a ^ (p / 2)", "name": "legendreSym.eq_pow", "isProp": true, "docString": "We have the congruence `legendreSym p a ≡ a ^ (p / 2) mod p`. ", "terms": "[\n    \"congruence\",\n    \"legendreSym\",\n    \"mod\",\n    \"^\", \n    \"/\"\n]"}
{"type": "{α : Type u_1} → GeneralizedContinuedFraction α → Prop", "name": "GeneralizedContinuedFraction.Terminates", "isProp": false, "docString": "A gcf terminates if its sequence terminates. ", "terms": "[\"gcf\", \"terminates\", \"sequence\"]"}
{"type": "{α : Type u_1} → {β : Type u_2} → α × β → β × α", "name": "Prod.swap", "isProp": false, "docString": "Swap the factors of a product. `swap (a, b) = (b, a)` ", "terms": "[\"swap\", \"factors\", \"product\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {W X Y Z : C} →\n      {f : W ⟶ X} →\n        [inst_1 : CategoryTheory.Limits.HasImage f] →\n          {g : Y ⟶ Z} →\n            [inst_2 : CategoryTheory.Limits.HasImage g] →\n              (sq : CategoryTheory.Arrow.mk f ⟶ CategoryTheory.Arrow.mk g) →\n                [inst_3 : CategoryTheory.Limits.HasImageMap sq] →\n                  CategoryTheory.Subobject.underlying.obj (CategoryTheory.Limits.imageSubobject f) ⟶\n                    CategoryTheory.Subobject.underlying.obj (CategoryTheory.Limits.imageSubobject g)", "name": "CategoryTheory.Limits.imageSubobjectMap", "isProp": false, "docString": "Given a commutative square between morphisms `f` and `g`,\nwe have a morphism in the category from `imageSubobject f` to `imageSubobject g`. ", "terms": "[\n  \"Commutative Square\",\n  \"Morphisms\",\n  \"Category\",\n  \"ImageSubobject\"\n]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_3, u_1} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      (F : CategoryTheory.MonoidalFunctor (Type u_2) C) →\n        (n : ℕ) →\n          (β : Type u_2) →\n            F.obj (Fin (n + 1) → β) ≅ CategoryTheory.MonoidalCategory.tensorObj (F.obj β) (F.obj (Fin n → β))", "name": "CategoryTheory.MonoidalFunctor.mapPi", "isProp": false, "docString": "If `F` is a monoidal functor out of `Type`, it takes the (n+1)st cartesian power\nof a type to the image of that type, tensored with the image of the nth cartesian power. ", "terms": "[\n  \"Monoidal functor\",\n  \"Type\",\n  \"Cartesian power\",\n  \"Image\",\n  \"Tensor\"\n]"}
{"type": "(C : Type u_1) →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      [inst_2 : CategoryTheory.Limits.HasKernels C] →\n        [inst_3 : CategoryTheory.Limits.HasCokernels C] → CategoryTheory.Functor (CategoryTheory.ShortComplex C) C", "name": "CategoryTheory.ShortComplex.leftHomologyFunctor", "isProp": false, "docString": "The left homology functor `ShortComplex C ⥤ C`, where the left homology of a\nshort complex `S` is understood as a cokernel of the obvious map `S.toCycles : S.X₁ ⟶ S.cycles`\nwhere `S.cycles` is a kernel of `S.g : S.X₂ ⟶ S.X₃`. ", "terms": "[\n    \"left homology functor\",\n    \"ShortComplex\",\n    \"cokernel\",\n    \"obvious map\",\n    \"kernel\",\n    \"homology\",\n    \"functor\",\n    \"complex\",\n    \"map\",\n    \"cycles\"\n]"}
{"type": "{R : Type uR} →\n  {M : Type uM} →\n    {ι : Type uι} →\n      [inst : CommRing R] →\n        [inst_1 : AddCommGroup M] →\n          [inst_2 : Module R M] →\n            [inst_3 : DecidableEq ι] → Basis ι R M → [inst_4 : Finite ι] → Basis ι R (Module.Dual R M)", "name": "Basis.dualBasis", "isProp": false, "docString": "Maps a basis for `V` to a basis for the dual space. ", "terms": "[\n    \"Maps\",\n    \"basis\",\n    \"dual space\"\n]"}
{"type": "∀ {R : Type u_1} {G : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Fintype G]\n  (f : G →* R), f ≠ 1 → (Finset.sum Finset.univ fun g => f g) = 0", "name": "sum_hom_units_eq_zero", "isProp": true, "docString": "In an integral domain, a sum indexed by a nontrivial homomorphism from a finite group is zero.\n", "terms": "[\n    \"Integral domain\",\n    \"Sum\",\n    \"Indexed\",\n    \"Nontrivial homomorphism\",\n    \"Finite group\",\n    \"Zero\"\n]"}
{"type": "∀ {n : Type u_1} {𝕜 : Type u_3} [inst : Field 𝕜] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n 𝕜),\n  ∃ L L' D,\n    M =\n      List.prod (List.map Matrix.TransvectionStruct.toMatrix L) * Matrix.diagonal D *\n        List.prod (List.map Matrix.TransvectionStruct.toMatrix L')", "name": "Matrix.Pivot.exists_list_transvec_mul_diagonal_mul_list_transvec", "isProp": true, "docString": "Any matrix can be written as the product of transvections, a diagonal matrix, and\ntransvections.", "terms": "[\n    \"matrix\",\n    \"product\",\n    \"transvections\",\n    \"diagonal matrix\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {P : CategoryTheory.Functor Cᵒᵖ (Type w)} →\n      {X : C} →\n        {R : CategoryTheory.Presieve X} →\n          CategoryTheory.Presieve.IsSheafFor P R →\n            (x : CategoryTheory.Presieve.FamilyOfElements P R) →\n              CategoryTheory.Presieve.FamilyOfElements.Compatible x → P.obj (Opposite.op X)", "name": "CategoryTheory.Presieve.IsSheafFor.amalgamate", "isProp": false, "docString": "Get the amalgamation of the given compatible family, provided we have a sheaf. ", "terms": "[\n  \"Amalgamation\",\n  \"Compatible Family\",\n  \"Sheaf\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_4} [inst_1 : TopologicalSpace β] {x₀ : β}\n  (b : β → ℝ),\n  Filter.Tendsto b (nhds x₀) (nhds 0) →\n    ∀ (F : ι → β → α), (∀ᶠ (x : β) in nhds x₀, ∀ (i : ι), dist (F i x₀) (F i x) ≤ b x) → EquicontinuousAt F x₀", "name": "Metric.equicontinuousAt_of_continuity_modulus", "isProp": true, "docString": "For a family of functions to a (pseudo) metric spaces, a convenient way to prove\nequicontinuity at a point is to show that all of the functions share a common *local* continuity\nmodulus. ", "terms": "[\n    \"family of functions\",\n    \"(pseudo) metric spaces\",\n    \"equicontinuity\",\n    \"point\",\n    \"functions\",\n    \"common\",\n    \"*local* continuity\",\n    \"modulus\"\n]"}
{"type": "{α : Type u} →\n  {β : Type v} →\n    {m : Type v → Type w} →\n      [inst : Monad m] → (β → α → m β) → β → (as : Array α) → optParam ℕ 0 → optParam ℕ (Array.size as) → m β", "name": "Array.foldlMUnsafe", "isProp": false, "docString": "See comment at `forInUnsafe` ", "terms": "[]"}
{"type": "∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {F : Type v} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace 𝕜 F] {f : 𝕜 → F} {x : 𝕜} {f' : 𝕜 →L[𝕜] F}, HasFDerivAt f f' x ↔ HasDerivAt f (f' 1) x", "name": "hasFDerivAt_iff_hasDerivAt", "isProp": true, "docString": "Expressing `HasFDerivAt f f' x` in terms of `HasDerivAt` ", "terms": "[\"Expressing\", \"HasFDerivAt\", \"f\", \"f'\", \"x\", \"terms\", \"HasDerivAt\"]"}
{"type": "{R : Type u_1} →\n  {S : Type u_2} →\n    [inst : Ring R] → [inst_1 : SetLike S R] → [hSR : NonUnitalSubringClass S R] → (s : S) → Unitization ℤ ↥s →ₐ[ℤ] R", "name": "NonUnitalSubring.unitization", "isProp": false, "docString": "The natural `ℤ`-algebra homomorphism from the unitization of a non-unital subring to\nits `Subring.closure`. ", "terms": "[\n    \"Natural\",\n    \"ℤ-algebra\",\n    \"Homomorphism\",\n    \"Unitization\",\n    \"Non-unital\",\n    \"Subring\",\n    \"Subring.closure\"\n]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {ps : Set P} {n : ℕ} [inst_4 : FiniteDimensional ℝ V],\n  FiniteDimensional.finrank ℝ V = n →\n    EuclideanGeometry.Cospherical ps →\n      ∃ r, ∀ (sx : Affine.Simplex ℝ P n), Set.range sx.points ⊆ ps → Affine.Simplex.circumradius sx = r", "name": "EuclideanGeometry.exists_circumradius_eq_of_cospherical", "isProp": true, "docString": "All n-simplices among cospherical points in n-space have the same\ncircumradius. ", "terms": "[\n    \"n-simplices\",\n    \"cospherical points\",\n    \"n-space\",\n    \"same\",\n    \"circumradius\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      (S : CategoryTheory.ShortComplex C) →\n        [inst_2 : CategoryTheory.ShortComplex.HasHomology S] →\n          [inst_3 : CategoryTheory.Limits.HasCokernel S.f] →\n            [inst_4 :\n                CategoryTheory.Limits.HasKernel\n                  (CategoryTheory.Limits.cokernel.desc S.f S.g (_ : CategoryTheory.CategoryStruct.comp S.f S.g = 0))] →\n              CategoryTheory.ShortComplex.homology S ≅\n                CategoryTheory.Limits.kernel\n                  (CategoryTheory.Limits.cokernel.desc S.f S.g (_ : CategoryTheory.CategoryStruct.comp S.f S.g = 0))", "name": "CategoryTheory.ShortComplex.homologyIsoKernelDesc", "isProp": false, "docString": "The homology of a short complex `S` identifies to the kernel of the induced morphism\n`cokernel S.f ⟶ S.X₃`. ", "terms": "[\n    \"homology\",\n    \"short complex\",\n    \"kernel\",\n    \"induced morphism\",\n    \"cokernel\"\n]"}
{"type": "{ι : Type u_1} →\n  {α : Type u_6} → {β : Type u_7} → [inst : UniformSpace α] → [inst : UniformSpace β] → (ι → β → α) → Prop", "name": "UniformEquicontinuous", "isProp": false, "docString": "A family `F : ι → β → α` of functions between uniform spaces is *uniformly equicontinuous* if,\nfor all entourage `U ∈ 𝓤 α`, there is an entourage `V ∈ 𝓤 β` such that, whenever `x` and `y` are\n`V`-close, we have that, *for all `i : ι`*, `F i x` is `U`-close to `F i x₀`. ", "terms": "[\n    \"family\",\n    \"functions\",\n    \"uniform spaces\",\n    \"uniformly equicontinuous\",\n    \"entourage\",\n    \"close\"\n]"}
{"type": "{α : Type u_1} → Multiset α → Multiset α → Multiset α", "name": "Multiset.add", "isProp": false, "docString": "The sum of two multisets is the lift of the list append operation.\nThis adds the multiplicities of each element,\ni.e. `count a (s + t) = count a s + count a t`. ", "terms": "[\n    \"sum\",\n    \"multisets\",\n    \"lift\",\n    \"list append operation\",\n    \"multiplicities\",\n    \"element\",\n    \"count\"\n]"}
{"type": "(R : Type u) →\n  (S : Type v) →\n    (A : Type w) →\n      [inst : CommSemiring R] →\n        [inst_1 : CommSemiring S] →\n          [inst_2 : Semiring A] →\n            [inst_3 : Algebra R S] →\n              [inst_4 : Algebra S A] → [inst_5 : Algebra R A] → [inst_6 : IsScalarTower R S A] → S →ₐ[R] A", "name": "IsScalarTower.toAlgHom", "isProp": false, "docString": "In a tower, the canonical map from the middle element to the top element is an\nalgebra homomorphism over the bottom element. ", "terms": "[\n  \"Tower\",\n  \"Canonical map\",\n  \"Middle element\",\n  \"Top element\",\n  \"Algebra homomorphism\",\n  \"Bottom element\"\n]"}
{"type": "Mathlib.Prelude.Rename.RenameMap → Mathlib.Prelude.Rename.NameEntry → Mathlib.Prelude.Rename.RenameMap", "name": "Mathlib.Prelude.Rename.RenameMap.insert", "isProp": false, "docString": "Insert a name entry into the `RenameMap`. ", "terms": "[]\n"}
{"type": "{B : Type u₁} →\n  [inst : CategoryTheory.Bicategory B] →\n    {C : Type u₂} →\n      [inst_1 : CategoryTheory.Bicategory C] →\n        {F G H : CategoryTheory.OplaxFunctor B C} →\n          CategoryTheory.OplaxNatTrans F G → CategoryTheory.OplaxNatTrans G H → CategoryTheory.OplaxNatTrans F H", "name": "CategoryTheory.OplaxNatTrans.vcomp", "isProp": false, "docString": "Vertical composition of oplax natural transformations. ", "terms": "[\n    \"Vertical composition\",\n    \"Oplax\",\n    \"Natural transformations\"\n]"}
{"type": "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (Option α → Option β → γ) → List α → List β → List γ", "name": "List.zipWithAll", "isProp": false, "docString": "Version of `List.zipWith` that continues to the end of both lists, passing `none` to one argument\nonce the shorter list has run out.\n", "terms": "[]"}
{"type": "{n : ℕ} → [inst : NeZero n] → Fintype (DihedralGroup n)", "name": "DihedralGroup.instFintypeDihedralGroup", "isProp": false, "docString": "If `0 < n`, then `DihedralGroup n` is a finite group.\n", "terms": "[\n    \"0\",\n    \"<\",\n    \"n\",\n    \"DihedralGroup\",\n    \"finite\",\n    \"group\"\n]"}
{"type": "{L : FirstOrder.Language} →\n  {L' : FirstOrder.Language} →\n    (L →ᴸ L') →\n      {L₁ : FirstOrder.Language} →\n        {L₂ : FirstOrder.Language} → (L₁ →ᴸ L₂) → (FirstOrder.Language.sum L L₁ →ᴸ FirstOrder.Language.sum L' L₂)", "name": "FirstOrder.Language.LHom.sumMap", "isProp": false, "docString": "The map between two sum-languages induced by maps on the two factors. ", "terms": "[\n    \"map\",\n    \"sum-languages\",\n    \"induced\",\n    \"factors\"\n]"}
{"type": "Lean.ParserDescr", "name": "Uniformity.«termUniformContinuous[_,_]»", "isProp": false, "docString": "Notation for uniform continuity with respect to non-standard `UniformSpace` instances. ", "terms": "[\"Notation\", \"uniform continuity\", \"respect\", \"non-standard\", \"UniformSpace\", \"instances\"]"}
{"type": "{α : Type u_1} → {σ : Type u_3} → Ctop α σ → TopologicalSpace α", "name": "Ctop.toTopsp", "isProp": false, "docString": "Every `Ctop` is a topological space. ", "terms": "[\"Ctop\", \"topological space\"]"}
{"type": "{α : Type u_4} → [inst : OrderedSemiring α] → [self : FloorSemiring α] → α → ℕ", "name": "FloorSemiring.ceil", "isProp": false, "docString": "`FloorSemiring.ceil a` computes the least natural `n` such that `a ≤ (n : α)`.", "terms": "[\n    \"FloorSemiring.ceil\",\n    \"least natural\",\n    \"such that\",\n    \"≤\"\n]"}
{"type": "(𝕜 : Type u_1) →\n  {E : Type u_2} →\n    [inst : IsROrC 𝕜] →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : InnerProductSpace 𝕜 E] → [inst_3 : NormedSpace ℝ E] → E × E → E × E →L[ℝ] 𝕜", "name": "fderivInnerClm", "isProp": false, "docString": "Derivative of the inner product. ", "terms": "[\n    \"Derivative\", \n    \"Inner Product\"\n]"}
{"type": "{G : Type u} →\n  [inst : Group G] →\n    (H : Subgroup G) →\n      [inst_1 : Finite ↑↑H] →\n        ↑(MulAction.fixedPoints (↥H) (G ⧸ H)) ≃\n          ↥(Subgroup.normalizer H) ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H", "name": "Sylow.fixedPointsMulLeftCosetsEquivQuotient", "isProp": false, "docString": "The fixed points of the action of `H` on its cosets correspond to `normalizer H / H`. ", "terms": "[\n    \"fixed points\", \n    \"action\", \n    \"cosets\", \n    \"correspond\", \n    \"normalizer\", \n    \"division\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    (F : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C) →\n      F ≅\n        CategoryTheory.Limits.parallelPair (F.map CategoryTheory.Limits.WalkingParallelPairHom.left)\n          (F.map CategoryTheory.Limits.WalkingParallelPairHom.right)", "name": "CategoryTheory.Limits.diagramIsoParallelPair", "isProp": false, "docString": "Every functor indexing a (co)equalizer is naturally isomorphic (actually, equal) to a\n`parallelPair` ", "terms": "[\n    \"functor\",\n    \"(co)equalizer\",\n    \"naturally isomorphic\",\n    \"parallelPair\"\n]"}
{"type": "(A : outParam (Type u)) → {B : Type v} → [inst : HasQuotient A B] → B → Type (max u v)", "name": "HasQuotient.Quotient", "isProp": false, "docString": "`HasQuotient.Quotient A b` (with notation `A ⧸ b`) is the quotient\nof the type `A` by `b`.\n\nThis differs from `HasQuotient.quotient'` in that the `A` argument is\nexplicit, which is necessary to make Lean show the notation in the\ngoal state.\n", "terms": "[\"HasQuotient.Quotient\", \"quotient\", \"type\", \"notation\", \"goal state\"]"}
{"type": "{L R : Type v} →\n  {fst snd : L → R} →\n    {A B C : CategoryTheory.Limits.WalkingMultispan fst snd} →\n      CategoryTheory.Limits.WalkingMultispan.Hom A B →\n        CategoryTheory.Limits.WalkingMultispan.Hom B C → CategoryTheory.Limits.WalkingMultispan.Hom A C", "name": "CategoryTheory.Limits.WalkingMultispan.Hom.comp", "isProp": false, "docString": "Composition of morphisms for `WalkingMultispan`. ", "terms": "[\n    \"Composition\",\n    \"Morphisms\",\n    \"WalkingMultispan\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      [inst : CategoryTheory.Limits.HasBinaryBiproducts C] → C → Prop", "name": "CategoryTheory.Indecomposable", "isProp": false, "docString": "An object is indecomposable if it cannot be written as the biproduct of two nonzero objects. ", "terms": "[\n    \"object\",\n    \"indecomposable\",\n    \"written\",\n    \"biproduct\",\n    \"nonzero\",\n    \"objects\"\n]"}
{"type": "{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {K : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} K] →\n        {C : Type u} →\n          [inst_2 : CategoryTheory.Category.{v, u} C] →\n            {F : CategoryTheory.Functor J C} →\n              [inst_3 : CategoryTheory.Limits.HasLimit F] →\n                {G : CategoryTheory.Functor K C} →\n                  [inst_4 : CategoryTheory.Limits.HasLimit G] →\n                    (e : J ≌ K) →\n                      (CategoryTheory.Functor.comp e.functor G ≅ F) →\n                        (CategoryTheory.Limits.limit F ≅ CategoryTheory.Limits.limit G)", "name": "CategoryTheory.Limits.HasLimit.isoOfEquivalence", "isProp": false, "docString": "The limits of `F : J ⥤ C` and `G : K ⥤ C` are isomorphic,\nif there is an equivalence `e : J ≌ K` making the triangle commute up to natural isomorphism.\n", "terms": "[\n  \"limits\",\n  \"isomorphic\",\n  \"equivalence\",\n  \"commute\",\n  \"natural isomorphism\"\n]"}
{"type": "{ι : Type u_1} →\n  {k : Type u_3} →\n    {V : Type u_4} →\n      {P : Type u_5} →\n        [inst : AddCommGroup V] →\n          [inst_1 : AddTorsor V P] → [inst_2 : Ring k] → [inst_3 : Module k V] → AffineBasis ι k P → ι → P →ᵃ[k] k", "name": "AffineBasis.coord", "isProp": false, "docString": "The `i`th barycentric coordinate of a point. ", "terms": "[\"barycentric coordinate\", \"point\"]"}
{"type": "{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {C : Type u₃} →\n      [inst_1 : CategoryTheory.Category.{v₃, u₃} C] →\n        CategoryTheory.Functor J C → CategoryTheory.Functor C (Type (max u₁ v₃))", "name": "CategoryTheory.Functor.cocones", "isProp": false, "docString": "If `F : J ⥤ C` then `F.cocones` is the functor assigning to an object `(X : C)`\nthe type of natural transformations from `F` to the constant functor with value `X`.\nAn object corepresenting this functor is a colimit of `F`.\n", "terms": "[\n  \"Functor\",\n  \"Object\",\n  \"Type\",\n  \"Natural Transformations\",\n  \"Constant Functor\",\n  \"Corepresenting\",\n  \"Colimit\"\n]"}
{"type": "{R : Type u_1} → [inst : OrderedRing R] → (s : Subring R) → OrderedRing ↥s", "name": "Subring.toOrderedRing", "isProp": false, "docString": "A subring of an `OrderedRing` is an `OrderedRing`. ", "terms": "[\n  \"subring\",\n  \"OrderedRing\"\n]"}
{"type": "∀ (R : Type w₁) [inst : CommRing R], Algebra.FinitePresentation R R", "name": "Algebra.FinitePresentation.self", "isProp": true, "docString": "`R` is finitely presented as `R`-algebra. ", "terms": "[\n    \"finitely presented\",\n    \"R-algebra\"\n]"}
{"type": "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HXor α β γ] → α → β → γ", "name": "HXor.hXor", "isProp": false, "docString": "`a ^^^ b` computes the bitwise XOR of `a` and `b`.\nThe meaning of this notation is type-dependent. ", "terms": "[\"bitwise XOR\", \"computes\", \"type-dependent\"]"}
{"type": "{α : Type u} →\n  {β : Type v} →\n    {l : α → β} →\n      {u : β → α} → [inst : PartialOrder α] → [inst_1 : CompleteLattice β] → GaloisCoinsertion l u → CompleteLattice α", "name": "GaloisCoinsertion.liftCompleteLattice", "isProp": false, "docString": "Lift all suprema and infima along a Galois coinsertion ", "terms": "[\n    \"Lift\",\n    \"suprema\",\n    \"infima\",\n    \"Galois coinsertion\"\n]"}
{"type": "∀ {ι : Type u_1} {k : Type u_2} {V : Type u_3} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V]\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] {s : Finset ι} {w : ι → k},\n  (Finset.sum s fun i => w i) = 0 → ∀ (p : ι → P), (Finset.weightedVSub s p) w ∈ vectorSpan k (Set.range p)", "name": "weightedVSub_mem_vectorSpan", "isProp": true, "docString": "A `weightedVSub` with sum of weights 0 is in the `vectorSpan` of\nan indexed family. ", "terms": "[\n    \"weightedVSub\",\n    \"sum\",\n    \"weights\",\n    \"vectorSpan\",\n    \"indexed family\"\n]"}
{"type": "(Lean.Name → Option Lean.Name) → (Lean.Name → Option (List ℕ)) → Lean.Expr → Option Lean.Name", "name": "ToAdditive.additiveTest", "isProp": false, "docString": "`additiveTest e` tests whether the expression `e` contains a constant\n`nm` that is not applied to any arguments, and such that `translations.find?[nm] = none`.\nThis is used in `@[to_additive]` for deciding which subexpressions to transform: we only transform\nconstants if `additiveTest` applied to their first argument returns `true`.\nThis means we will replace expression applied to e.g. `α` or `α × β`, but not when applied to\ne.g. `ℕ` or `ℝ × α`.\nWe ignore all arguments specified by the `ignore` `NameMap`.\n", "terms": "[\"constant\", \"arguments\", \"translations\", \"none\", \"subexpressions\", \"transform\", \"replace\", \"expression\", \"ℕ\", \"ℝ × α\", \"ignore\", \"NameMap\"]"}
{"type": "(S : Profinite) → ↑S.toCompHaus.toTop → { C // IsClopen C } → Bool", "name": "Profinite.Nobeling.ι", "isProp": false, "docString": "The embedding `S → (I → Bool)` where `I` is the set of clopens of `S`. ", "terms": "[\n\"embedding\",\n\"set\",\n\"clopens\"\n]"}
{"type": "∀ {X : Type u} [inst : TopologicalSpace X] {s a b : Set X},\n  IsClopen s → s ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (s ∩ a)", "name": "isClopen_inter_of_disjoint_cover_clopen", "isProp": true, "docString": "The intersection of a disjoint covering by two open sets of a clopen set will be clopen. ", "terms": "[\n    \"intersection\",\n    \"disjoint\",\n    \"covering\",\n    \"open sets\",\n    \"clopen set\"\n]"}
{"type": "{G : Type w} → [inst : TopologicalSpace G] → MeasureTheory.Content G → MeasureTheory.OuterMeasure G", "name": "MeasureTheory.Content.outerMeasure", "isProp": false, "docString": "Extending a content on compact sets to an outer measure on all sets. ", "terms": "[\n    \"Extending\",\n    \"Content\",\n    \"Compact Sets\",\n    \"Outer Measure\",\n    \"Sets\"\n]"}
{"type": "Type (u + 1)", "name": "Ordinal", "isProp": false, "docString": "`Ordinal.{u}` is the type of well orders in `Type u`, up to order isomorphism. ", "terms": "[\n  \"Ordinal\",\n  \"type\",\n  \"well orders\",\n  \"Type\",\n  \"order isomorphism\"\n]"}
{"type": "∀ {α : Type u} {l : List α}, List.Nodup l → List.Nodup (List.sublists l)", "name": "List.nodup.sublists", "isProp": true, "docString": "**Alias** of the reverse direction of `List.nodup_sublists`.", "terms": "[\"Alias\", \"reverse direction\", \"List.nodup_sublists\"]"}
{"type": "∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare 2 ↔ Fintype.card F % 8 ≠ 3 ∧ Fintype.card F % 8 ≠ 5", "name": "FiniteField.isSquare_two_iff", "isProp": true, "docString": "`2` is a square in `F` iff `#F` is not congruent to `3` or `5` mod `8`. ", "terms": "[\n  \"square\",\n  \"congruent\",\n  \"mod\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {T₁ T₂ T₃ : CategoryTheory.Monad C} →\n      (f : T₁ ⟶ T₂) →\n        (g : T₂ ⟶ T₃) →\n          CategoryTheory.Monad.algebraFunctorOfMonadHom (CategoryTheory.CategoryStruct.comp f g) ≅\n            CategoryTheory.Functor.comp (CategoryTheory.Monad.algebraFunctorOfMonadHom g)\n              (CategoryTheory.Monad.algebraFunctorOfMonadHom f)", "name": "CategoryTheory.Monad.algebraFunctorOfMonadHomComp", "isProp": false, "docString": "A composition of monad morphisms gives the composition of corresponding functors.\n", "terms": "[\n    \"composition\",\n    \"monad\",\n    \"morphisms\",\n    \"corresponding\",\n    \"functors\"\n]"}
{"type": "Num → Num", "name": "Num.bit0", "isProp": false, "docString": "`bit0 n` appends a `0` to the end of `n`, where `bit0 n = n0`. ", "terms": "The statement provided contains the following mathematical terms:\n\n1. `bit0` - This term represents a binary operation that appends a `0` at the end of a binary string. \n\n2. `append` - In mathematics, to append is to add something to the end of a larger body or data structure. In this case, appending refers to the action of adding a `0` to the end of a binary number.\n\n3. `0` - `0` represents the number zero.\n\n4. `end` - This term refers to the final part or point of something. In the context of this statement, it refers to the end of a binary number.\n\n5. `=` - This symbol represents the equality relation, indicating that two quantities are identical.\n\nThe JSON list of the terms is as follows:\n\n```json\n[\n    \"bit0\",\n    \"append\",\n    \"0\",\n    \"end\",\n    \"equals\"\n]\n```"}
{"type": "{C : Type u} →\n  {A : Type u_1} →\n    [inst : CategoryTheory.Category.{v, u} C] →\n      {D : Type u_2} →\n        [inst_1 : CategoryTheory.Category.{u_3, u_2} D] →\n          [inst_2 : AddMonoid A] →\n            [inst_3 : CategoryTheory.HasShift D A] →\n              (F : CategoryTheory.Functor C D) →\n                [inst_4 : CategoryTheory.Full F] →\n                  [inst_5 : CategoryTheory.Faithful F] →\n                    (s : A → CategoryTheory.Functor C C) →\n                      ((i : A) →\n                          CategoryTheory.Functor.comp (s i) F ≅\n                            CategoryTheory.Functor.comp F (CategoryTheory.shiftFunctor D i)) →\n                        CategoryTheory.HasShift C A", "name": "CategoryTheory.hasShiftOfFullyFaithful", "isProp": false, "docString": "Given a family of endomorphisms of `C` which are intertwined by a fully faithful `F : C ⥤ D`\nwith shift functors on `D`, we can promote that family to shift functors on `C`. ", "terms": "[\n    \"family\",\n    \"endomorphisms\",\n    \"intertwined\",\n    \"fully faithful\",\n    \"shift functors\",\n    \"promote\"\n]"}
{"type": "(R : Type u_1) →\n  (S : Type u_2) →\n    (M : Type u_3) →\n      [inst : Semiring S] →\n        [inst_1 : AddCommMonoid M] →\n          [inst_2 : CommSemiring R] →\n            [inst_3 : Algebra R S] → [inst_4 : Module S M] → S →ₐ[R] Module.End R (RestrictScalars R S M)", "name": "RestrictScalars.lsmul", "isProp": false, "docString": "The `R`-algebra homomorphism from the original coefficient algebra `S` to endomorphisms\nof `RestrictScalars R S M`.\n", "terms": "[\n    \"R-algebra\",\n    \"homomorphism\",\n    \"coefficient algebra\",\n    \"endomorphisms\",\n    \"RestrictScalars\"\n]"}
{"type": "{X Y : Type u} → (f g : X ⟶ Y) → CategoryTheory.Limits.ColimitCocone (CategoryTheory.Limits.parallelPair f g)", "name": "CategoryTheory.Limits.Types.coequalizerColimit", "isProp": false, "docString": "Show that the quotient by the relation generated by `f(x) ~ g(x)`\nis a coequalizer for the pair `(f, g)`.\n", "terms": "[\"quotient\", \"relation\", \"generated\", \"f(x)\", \"g(x)\", \"coequalizer\", \"pair\"]"}
{"type": "{α : Type u_1} → [inst : LinearOrderedField α] → (β : Type u_2) → [inst : Ring β] → (β → α) → Type u_2", "name": "CauSeq", "isProp": false, "docString": "`CauSeq β abv` is the type of `β`-valued Cauchy sequences, with respect to the absolute value\nfunction `abv`. ", "terms": "[\n    \"CauSeq\",\n    \"type\",\n    \"valued\",\n    \"Cauchy sequences\",\n    \"respect\",\n    \"absolute value\",\n    \"function\"\n]"}
{"type": "{S : Type u_6} →\n  (H : S) →\n    {G : Type u_7} →\n      [inst : LinearOrderedCommGroup G] →\n        [inst_1 : SetLike S G] → [inst : SubgroupClass S G] → LinearOrderedCommGroup ↥H", "name": "SubgroupClass.toLinearOrderedCommGroup", "isProp": false, "docString": "A subgroup of a `LinearOrderedCommGroup` is a `LinearOrderedCommGroup`. ", "terms": "[\n  \"subgroup\",\n  \"LinearOrderedCommGroup\"\n]"}
{"type": "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup Rˣ) [inst_2 : Finite ↥S], IsCyclic ↥S", "name": "subgroup_units_cyclic", "isProp": true, "docString": "A finite subgroup of the units of an integral domain is cyclic. ", "terms": "[\n    \"finite\",\n    \"subgroup\",\n    \"units\",\n    \"integral domain\",\n    \"cyclic\"\n]"}
{"type": "∀ {𝕜 : Type u_3} [inst : Field 𝕜] {r : ℕ} (M : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) (i : Fin r ⊕ Unit) {k : ℕ},\n  k ≤ r → (List.prod (List.drop k (Matrix.Pivot.listTransvecCol M)) * M) (Sum.inr ()) i = M (Sum.inr ()) i", "name": "Matrix.Pivot.listTransvecCol_mul_last_row_drop", "isProp": true, "docString": "Multiplying by some of the matrices in `listTransvecCol M` does not change the last row. ", "terms": "[\n  \"Multiplying\",\n  \"Matrices\",\n  \"List\",\n  \"Row\"\n]"}
{"type": "{R : Type u_1} → [inst : Semiring R] → ℕ → PowerSeries R → Polynomial R", "name": "PowerSeries.trunc", "isProp": false, "docString": "The `n`th truncation of a formal power series to a polynomial ", "terms": "[\n  \"truncation\",\n  \"formal power series\",\n  \"polynomial\"\n]"}
{"type": "∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {F : Type v} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace 𝕜 F] {E : Type w} [inst_3 : NormedAddCommGroup E] [inst_4 : NormedSpace 𝕜 E] {f : 𝕜 → F}\n  {f' : F} (x : 𝕜) {s : Set 𝕜} {l : F → E} {l' : F →L[𝕜] E} {t : Set F},\n  HasFDerivWithinAt l l' t (f x) → HasDerivWithinAt f f' s x → Set.MapsTo f s t → HasDerivWithinAt (l ∘ f) (l' f') s x", "name": "HasFDerivWithinAt.comp_hasDerivWithinAt", "isProp": true, "docString": "The composition `l ∘ f` where `l : F → E` and `f : 𝕜 → F`, has a derivative within a set\nequal to the Fréchet derivative of `l` applied to the derivative of `f`. ", "terms": "[\n    \"composition\",\n    \"derivative\",\n    \"set\",\n    \"Fréchet derivative\",\n    \"applied\"\n]"}
{"type": "{R : Type u_1} → {S : Type u_6} → [inst : Semiring R] → [inst_1 : Semiring S] → (f : R ≃+* S) → R ≃ₛₗ[↑f] S", "name": "RingEquiv.toSemilinearEquiv", "isProp": false, "docString": "Interpret a `RingEquiv` `f` as an `f`-semilinear equiv. ", "terms": "[\n    \"RingEquiv\",\n    \"semilinear equiv\"\n]"}
{"type": "∀ {e : ℂ → ℂ} {e' : ℂ} {z : ℝ}, HasDerivAt e e' ↑z → HasDerivAt (fun x => (e ↑x).re) e'.re z", "name": "HasDerivAt.real_of_complex", "isProp": true, "docString": "If a complex function `e` is differentiable at a real point, then the function `ℝ → ℝ` given by\nthe real part of `e` is also differentiable at this point, with a derivative equal to the real part\nof the complex derivative. ", "terms": "[\n    \"complex function\",\n    \"differentiable\",\n    \"real point\",\n    \"function\",\n    \"real part\",\n    \"derivative\",\n    \"complex derivative\"\n]"}
{"type": "{R : Type u} →\n  {M : Type v} →\n    [inst : Monoid R] →\n      [inst_1 : AddMonoid M] →\n        [inst_2 : DistribMulAction R M] → [inst : DistribMulAction Rᵐᵒᵖ M] → Pow (TrivSqZeroExt R M) ℕ", "name": "TrivSqZeroExt.instPowTrivSqZeroExtNat", "isProp": false, "docString": "In the general non-commutative case, the power operator is\n\n$$\\begin{align}\n(r + m)^n &= r^n + r^{n-1}m + r^{n-2}mr + \\cdots + rmr^{n-2} + mr^{n-1} \\\\\n          & =r^n + \\sum_{i = 0}^{n - 1} r^{(n - 1) - i} m r^{i}\n\\end{align}$$\n\nIn the commutative case this becomes the simpler $(r + m)^n = r^n + nr^{n-1}m$.\n", "terms": "[\n    \"general\",\n    \"non-commutative\",\n    \"power operator\",\n    \"commutative\",\n    \"sum\",\n    \"simpler\"\n]"}
{"type": "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {f' : E →L[𝕜] F} {x₀ : E},\n  HasFDerivAt f f' x₀ → ∀ {s : Set E}, s ∈ nhds x₀ → ∀ {C : NNReal}, LipschitzOnWith C f s → ‖f'‖ ≤ ↑C", "name": "HasFDerivAt.le_of_lipschitzOn", "isProp": true, "docString": "Converse to the mean value inequality: if `f` is differentiable at `x₀` and `C`-lipschitz\non a neighborhood of `x₀` then its derivative at `x₀` has norm bounded by `C`. ", "terms": "[\n    \"Converse\",\n    \"Mean Value Inequality\",\n    \"Differentiable\",\n    \"Lipschitz\",\n    \"Neighborhood\",\n    \"Derivative\",\n    \"Norm\",\n    \"Bounded\"\n]"}
{"type": "{α : Sort u} → {β : Sort v} → PLift (α → β) → (Unit → PLift α) → PLift β", "name": "PLift.seq", "isProp": false, "docString": "Applicative sequencing. ", "terms": "[\"Applicative\", \"sequencing\"]"}
{"type": "{n m : ℕ} → Fin (m * n) → Fin m", "name": "Fin.divNat", "isProp": false, "docString": "Compute `i / n`, where `n` is a `Nat` and inferred the type of `i`. ", "terms": "[\"Compute\", \"/\", \"Nat\", \"inferred\", \"type\"]"}
{"type": "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α]\n  [inst_2 : OrderTopology α] [inst_3 : ConditionallyCompleteLinearOrder β] [inst_4 : TopologicalSpace β]\n  [inst_5 : OrderClosedTopology β] [inst_6 : Nonempty γ] {f : α → β} {g : γ → α},\n  ContinuousAt f (⨆ i, g i) → Antitone f → BddAbove (Set.range g) → f (⨆ i, g i) = ⨅ i, f (g i)", "name": "Antitone.map_ciSup_of_continuousAt", "isProp": true, "docString": "If an antitone function is continuous at the indexed supremum of a bounded function on\na nonempty `Sort`, then it sends this supremum to the infimum of the composition. ", "terms": "[\n  \"antitone function\",\n  \"continuous\",\n  \"indexed supremum\",\n  \"bounded function\",\n  \"nonempty\",\n  \"Sort\",\n  \"sends\",\n  \"supremum\",\n  \"infimum\",\n  \"composition\"\n]"}
{"type": "{E : Type uE} →\n  [inst : NormedAddCommGroup E] →\n    [inst_1 : NormedSpace ℝ E] →\n      {H : Type uH} →\n        [inst_2 : TopologicalSpace H] →\n          {I : ModelWithCorners ℝ E H} →\n            {M : Type uM} →\n              [inst_3 : TopologicalSpace M] →\n                [inst_4 : ChartedSpace H M] →\n                  {c : M} → (f : SmoothBumpFunction I c) → (r : ℝ) → r ∈ Set.Ioo 0 f.rOut → SmoothBumpFunction I c", "name": "SmoothBumpFunction.updateRIn", "isProp": false, "docString": "Replace `rIn` with another value in the interval `(0, f.rOut)`. ", "terms": "[\"Replace\", \"value\", \"interval\"]"}
{"type": "{X : Type u} →\n  {m₁ : X → X → X} →\n    {e₁ : X} →\n      EckmannHilton.IsUnital m₁ e₁ →\n        [h : AddZeroClass X] → (∀ (a b c d : X), m₁ (a + b) (c + d) = m₁ a c + m₁ b d) → AddCommMonoid X", "name": "EckmannHilton.addCommMonoid", "isProp": false, "docString": "If a type carries a unital additive magma structure that distributes over a unital binary\noperation, then the additive magma structure is a commutative additive monoid.", "terms": "[\n    \"type\",\n    \"carries\",\n    \"unital\",\n    \"additive\",\n    \"magma\",\n    \"structure\",\n    \"distributes\",\n    \"over\",\n    \"binary\",\n    \"operation\",\n    \"additive\",\n    \"magma\",\n    \"structure\",\n    \"commutative\",\n    \"additive\",\n    \"monoid\"\n]"}
{"type": "(F : Type u_1) →\n  (R : Type u_2) →\n    [inst : Field F] → [inst_1 : Semiring R] → [inst_2 : Nontrivial R] → [inst_3 : Algebra F R] → ↥⊥ ≃ₐ[F] F", "name": "Algebra.botEquiv", "isProp": false, "docString": "The bottom subalgebra is isomorphic to the field. ", "terms": "[\n    \"subalgebra\",\n    \"isomorphic\",\n    \"field\"\n]"}
{"type": "(R : Type u_1) →\n  [inst : CommSemiring R] →\n    (M : Type u_4) →\n      (N : Type u_5) →\n        (P : Type u_6) →\n          [inst_1 : AddCommMonoid M] →\n            [inst_2 : AddCommMonoid N] →\n              [inst_3 : AddCommMonoid P] →\n                [inst_4 : Module R M] →\n                  [inst_5 : Module R N] → [inst_6 : Module R P] → (M →ₗ[R] N →ₗ[R] P) →ₗ[R] TensorProduct R M N →ₗ[R] P", "name": "TensorProduct.uncurry", "isProp": false, "docString": "Linearly constructing a linear map `M ⊗ N → P` given a bilinear map `M → N → P`\nwith the property that its composition with the canonical bilinear map `M → N → M ⊗ N` is\nthe given bilinear map `M → N → P`. ", "terms": "[\n\"Linearly constructing\",\n\"Linear map\",\n\"Bilinear map\",\n\"Property\",\n\"Composition\",\n\"Canonical\",\n\"M ⊗ N\",\n\"M → N → P\",\n\"M → N → M ⊗ N\"\n]"}
{"type": "{R : Type u} → [inst : CommRing R] → WeierstrassCurve R → WeierstrassCurve.VariableChange R → WeierstrassCurve R", "name": "WeierstrassCurve.variableChange", "isProp": false, "docString": "The Weierstrass curve over `R` induced by an admissible linear change of variables\n$(X, Y) \\mapsto (u^2X + r, u^3Y + u^2sX + t)$ for some $u \\in R^\\times$ and some $r, s, t \\in R$. ", "terms": "[\n\"Weierstrass curve\", \n\"R\", \n\"admissible\", \n\"linear change of variables\", \n\"u^2X\", \n\"r\", \n\"u^3Y\", \n\"u^2sX\", \n\"t\", \n\"u\", \n\"R^times\"\n]"}
{"type": "{I : Type u} →\n  {f : I → Type v} →\n    {γ : Type w} →\n      [inst : (i : I) → AddZeroClass (f i)] → [inst_1 : AddZeroClass γ] → ((i : I) → γ →+ f i) → γ →+ (i : I) → f i", "name": "Pi.addMonoidHom", "isProp": false, "docString": "A family of additive monoid homomorphisms `f a : γ →+ β a` defines a monoid homomorphism\n`Pi.addMonoidHom f : γ →+ Π a, β a` given by `Pi.addMonoidHom f x b = f b x`.", "terms": "[\n    \"family\",\n    \"additive\",\n    \"monoid\",\n    \"homomorphisms\",\n    \"defines\",\n    \"given by\",\n    \"Pi.addMonoidHom\"\n]"}
{"type": "∀ {G : Type u_3} [inst : AddCommGroup G] (K : AddSubgroup G) (g : Multiset G), (∀ a ∈ g, a ∈ K) → Multiset.sum g ∈ K", "name": "AddSubgroup.multiset_sum_mem", "isProp": true, "docString": "Sum of a multiset of elements in an `AddSubgroup` of an `AddCommGroup` is in\nthe `AddSubgroup`.", "terms": "[\n    \"Sum\",\n    \"multiset\",\n    \"elements\",\n    \"AddSubgroup\",\n    \"AddCommGroup\"\n]"}
{"type": "(V : Type u) → [inst : Quiver V] → Sort u_1 → Sort (imax (u + 1) (u + 1) u_2 u_1)", "name": "Quiver.Labelling", "isProp": false, "docString": "An `L`-labelling of a quiver assigns to every arrow an element of `L`. ", "terms": "[\"L-labelling\", \"quiver\", \"arrow\", \"element\"]"}
{"type": "Differentiable ℂ (mellin zetaKernel₂)", "name": "differentiable_mellin_zetaKernel₂", "isProp": true, "docString": "The Mellin transform of the second zeta kernel is entire. ", "terms": "[\n    \"Mellin transform\",\n    \"second zeta kernel\",\n    \"entire\"\n]"}
{"type": "∀ {K : Type u} [inst : Field K] {s : Set K}, s ⊆ ↑(Subfield.closure s)", "name": "Subfield.subset_closure", "isProp": true, "docString": "The subfield generated by a set includes the set. ", "terms": "[\n  \"subfield\",\n  \"generated\",\n  \"set\",\n  \"includes\"\n]"}
{"type": "∀ {K : Type u} [self : DivisionRing K] (a : K), a ≠ 0 → a * a⁻¹ = 1", "name": "DivisionRing.mul_inv_cancel", "isProp": true, "docString": "For a nonzero `a`, `a⁻¹` is a right multiplicative inverse. ", "terms": "[\n    \"nonzero\",\n    \"right multiplicative inverse\"\n]"}
{"type": "{K : Type u} →\n  [inst : Field K] →\n    {G : Type u_1} → [inst_1 : Group G] → [inst_2 : MulSemiringAction G K] → SMul G (ValuationSubring K)", "name": "ValuationSubring.pointwiseHasSMul", "isProp": false, "docString": "The action on a valuation subring corresponding to applying the action to every element.\n\nThis is available as an instance in the `Pointwise` locale. ", "terms": "[\n    \"action\",\n    \"valuation subring\",\n    \"element\",\n    \"Pointwise\",\n    \"locale\",\n    \"instance\"\n]"}
{"type": "(R : Type u) →\n  (L : Type v) → [inst : CommRing R] → [inst_1 : LieRing L] → [inst_2 : LieAlgebra R L] → Set L → LieSubalgebra R L", "name": "LieSubalgebra.lieSpan", "isProp": false, "docString": "The Lie subalgebra of a Lie algebra `L` generated by a subset `s ⊆ L`. ", "terms": "[\n    \"Lie subalgebra\",\n    \"Lie algebra\",\n    \"generated\",\n    \"subset\"\n]"}
{"type": "∀ {α : Type u_2} [self : LinearOrderedField α] (n : ℕ) (a : α),\n  LinearOrderedField.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedField.zpow (Int.ofNat n) a", "name": "LinearOrderedField.zpow_succ'", "isProp": true, "docString": "`a ^ (n + 1) = a * a ^ n` ", "terms": "[\"power\", \"addition\", \"multiplication\"]"}
{"type": "{F : Type u_1} →\n  {K : Type u_2} →\n    (A : Type u_3) →\n      [inst : Field F] →\n        [inst_1 : Field K] →\n          [inst_2 : Field A] →\n            [inst_3 : Algebra F K] →\n              [inst_4 : Algebra F A] →\n                Algebra.IsAlgebraic F K →\n                  (L : Type u_4) →\n                    [inst_5 : Field L] →\n                      [inst_6 : Algebra F L] →\n                        [inst_7 : Algebra L A] →\n                          [inst_8 : IsScalarTower F L A] →\n                            (∀ (x : K), Polynomial.Splits (algebraMap F L) (minpoly F x)) → (K →ₐ[F] L) ≃ (K →ₐ[F] A)", "name": "Algebra.IsAlgebraic.algHomEquivAlgHomOfSplits", "isProp": false, "docString": "All `F`-embeddings of a field `K` into another field `A` factor through any subextension\nof `A/F` in which the minimal polynomial of elements of `K` splits. ", "terms": "[\n    \"F-embeddings\",\n    \"field\",\n    \"another field\",\n    \"factor\",\n    \"subextension\",\n    \"minimal polynomial\",\n    \"elements\",\n    \"splits\"\n]"}
{"type": "{α : Type u_1} →\n  [inst : UniformSpace α] →\n    [inst_1 : Semiring α] →\n      {β : Type u_2} →\n        [inst_2 : UniformSpace β] →\n          [inst_3 : Semiring β] →\n            [inst_4 : TopologicalSemiring β] →\n              {γ : Type u_3} →\n                [inst_5 : UniformSpace γ] →\n                  [inst_6 : Semiring γ] →\n                    [inst_7 : TopologicalSemiring γ] →\n                      [inst_8 : T2Space γ] →\n                        [inst_9 : CompleteSpace γ] →\n                          {i : α →+* β} →\n                            {f : α →+* γ} → UniformInducing ⇑i → DenseRange ⇑i → UniformContinuous ⇑f → β →+* γ", "name": "DenseInducing.extendRingHom", "isProp": false, "docString": "The dense inducing extension as a ring homomorphism. ", "terms": "[\n    \"dense\",\n    \"inducing\",\n    \"extension\",\n    \"ring\",\n    \"homomorphism\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        (F : CategoryTheory.Functor C Dᵒᵖ) →\n          [inst_2 : CategoryTheory.Limits.PreservesLimits F] → CategoryTheory.Limits.PreservesColimits F.leftOp", "name": "CategoryTheory.Limits.preservesColimitsLeftOp", "isProp": false, "docString": "If `F : C ⥤ Dᵒᵖ` preserves limits, then `F.left_op : Cᵒᵖ ⥤ D` preserves colimits. ", "terms": "[\n  \"preserves limits\",\n  \"left_op\",\n  \"preserves colimits\"\n]"}
{"type": "{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : Ring R] →\n      [inst_1 : AddCommGroup M] →\n        [inst_2 : Module R M] →\n          (p : Submodule R M) →\n            {R₂ : Type u_3} →\n              {M₂ : Type u_4} →\n                [inst_3 : Ring R₂] →\n                  [inst_4 : AddCommGroup M₂] →\n                    [inst_5 : Module R₂ M₂] →\n                      {τ₁₂ : R →+* R₂} → (f : M →ₛₗ[τ₁₂] M₂) → p ≤ LinearMap.ker f → M ⧸ p →ₛₗ[τ₁₂] M₂", "name": "Submodule.liftQ", "isProp": false, "docString": "The map from the quotient of `M` by a submodule `p` to `M₂` induced by a linear map `f : M → M₂`\nvanishing on `p`, as a linear map. ", "terms": "[\n  \"map\",\n  \"quotient\",\n  \"submodule\",\n  \"induced\",\n  \"linear map\",\n  \"vanishing\"\n]"}
{"type": "∀ (v : PrimeMultiset), PNat.factorMultiset (PrimeMultiset.prod v) = v", "name": "PrimeMultiset.factorMultiset_prod", "isProp": true, "docString": "If we start with a multiset of primes, take the product and\nthen factor it, we get back the original multiset. ", "terms": "[\n  \"multiset\",\n  \"primes\",\n  \"product\",\n  \"factor\"\n]"}
{"type": "(F : CategoryTheory.Functor CompHausᵒᵖ (Type (u + 1))) →\n  [inst : CategoryTheory.Limits.PreservesFiniteProducts F] →\n    CategoryTheory.regularCoverage.EqualizerCondition F → CondensedSet", "name": "CondensedSet.ofSheafCompHaus", "isProp": false, "docString": "A `CondensedSet` version of `Condensed.ofSheafCompHaus`. ", "terms": "[\"CondensedSet\", \"Condensed.ofSheafCompHaus\"]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E] {s : Set E}\n  {x : E},\n  x ∈ (convexHull 𝕜) s →\n    ∃ ι x_1 z w,\n      ∃ (_ : Set.range z ⊆ s) (_ : AffineIndependent 𝕜 z) (_ : ∀ (i : ι), 0 < w i),\n        (Finset.sum Finset.univ fun i => w i) = 1 ∧ (Finset.sum Finset.univ fun i => w i • z i) = x", "name": "eq_pos_convex_span_of_mem_convexHull", "isProp": true, "docString": "A more explicit version of `convexHull_eq_union`. ", "terms": "The mathematical statement provided does not contain any mathematical terms beyond the names of concepts or theorems, which are not typically categorized as mathematical terms in the traditional sense (like \"integral\", \"derivative\", \"matrix\", etc). Therefore, the resulting list is empty:\n\n    []"}
{"type": "(X : UniformSpaceCat) →\n  X ⟶ (CategoryTheory.forget₂ CpltSepUniformSpace UniformSpaceCat).obj (UniformSpaceCat.completionFunctor.obj X)", "name": "UniformSpaceCat.completionHom", "isProp": false, "docString": "The inclusion of a uniform space into its completion. ", "terms": "[\"inclusion\", \"uniform space\", \"completion\"]"}
{"type": "∀ {A : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A], IsDedekindDomain A ↔ IsDedekindDomainInv A", "name": "isDedekindDomain_iff_isDedekindDomainInv", "isProp": true, "docString": "`IsDedekindDomain` and `IsDedekindDomainInv` are equivalent ways\nto express that an integral domain is a Dedekind domain. ", "terms": "[\n    \"IsDedekindDomain\",\n    \"IsDedekindDomainInv\",\n    \"equivalent\",\n    \"express\",\n    \"integral domain\",\n    \"Dedekind domain\"\n]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Abelian C] {P Q R : C} (f : P ⟶ Q)\n  (g : Q ⟶ R) (a : CategoryTheory.Abelian.Pseudoelement P),\n  CategoryTheory.Abelian.Pseudoelement.pseudoApply (CategoryTheory.CategoryStruct.comp f g) a =\n    CategoryTheory.Abelian.Pseudoelement.pseudoApply g (CategoryTheory.Abelian.Pseudoelement.pseudoApply f a)", "name": "CategoryTheory.Abelian.Pseudoelement.comp_apply", "isProp": true, "docString": "Applying a pseudoelement to a composition of morphisms is the same as composing\nwith each morphism. Sadly, this is not a definitional equality, but at least it is\ntrue. ", "terms": "[\n  \"Pseudoelement\",\n  \"Composition of morphisms\",\n  \"Composing\",\n  \"Morphism\",\n  \"Definitional equality\"\n]"}
{"type": "{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {K : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} K] →\n        {C : Type u₃} →\n          [inst_2 : CategoryTheory.Category.{v₃, u₃} C] →\n            (G : CategoryTheory.Functor J K) →\n              (F : CategoryTheory.Functor K C) →\n                (X : C) →\n                  (f : (Y : J) → F.obj (G.obj Y) ⟶ X) →\n                    (h : ∀ {Y Z : J} (g : Y ⟶ Z), CategoryTheory.CategoryStruct.comp (F.map (G.map g)) (f Z) = f Y) →\n                      CategoryTheory.Functor.toCostructuredArrow G F X f\n                          (_ :\n                            ∀ {Y Z : J} (g : Y ⟶ Z), CategoryTheory.CategoryStruct.comp (F.map (G.map g)) (f Z) = f Y) ≅\n                        CategoryTheory.Functor.comp\n                          (CategoryTheory.Limits.Cocone.toCostructuredArrow\n                            { pt := X, ι := CategoryTheory.NatTrans.mk f })\n                          (CategoryTheory.CostructuredArrow.pre G F { pt := X, ι := CategoryTheory.NatTrans.mk f }.pt)", "name": "CategoryTheory.Functor.toCostructuredArrowIsoToCostructuredArrow", "isProp": false, "docString": "`Functor.toCostructuredArrow` can be expressed in terms of `Cocone.toCostructuredArrow`. ", "terms": "[\n  \"Functor\",\n  \"toCostructuredArrow\",\n  \"expressed\",\n  \"terms\",\n  \"Cocone\"\n]"}
{"type": "{R : Type u_1} →\n  {A : Type u_3} →\n    {B : Type u_4} →\n      [inst : CommSemiring R] →\n        [inst_1 : Semiring A] →\n          [inst_2 : Semiring B] → [inst_3 : Algebra R A] → [inst_4 : Algebra R B] → (A →ₐ[R] B) ≃ (Aᵐᵒᵖ →ₐ[R] Bᵐᵒᵖ)", "name": "AlgHom.op", "isProp": false, "docString": "An algebra hom `A →ₐ[R] B` can equivalently be viewed as an algebra hom `Aᵐᵒᵖ →ₐ[R] Bᵐᵒᵖ`.\nThis is the action of the (fully faithful) `ᵐᵒᵖ`-functor on morphisms. ", "terms": "[\n  \"algebra hom\",\n  \"equivalently\",\n  \"viewed\",\n  \"action\",\n  \"fully faithful\",\n  \"functor\",\n  \"morphisms\"\n]"}
{"type": "∀ {S₀ : Type u} [self : SemigroupWithZero S₀] (a : S₀), 0 * a = 0", "name": "SemigroupWithZero.zero_mul", "isProp": true, "docString": "Zero is a left absorbing element for multiplication ", "terms": "[\n    \"Zero\",\n    \"Left absorbing element\",\n    \"Multiplication\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {W X Y Z : C} →\n      (f : X ⟶ Y) →\n        (g : X ⟶ Z) →\n          (h : W ⟶ X) →\n            [inst_1 : CategoryTheory.Epi h] →\n              [inst_2 : CategoryTheory.Limits.HasPushout f g] →\n                CategoryTheory.Limits.IsColimit\n                  (CategoryTheory.Limits.PushoutCocone.mk CategoryTheory.Limits.pushout.inl\n                    CategoryTheory.Limits.pushout.inr\n                    (_ :\n                      CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp h f)\n                          CategoryTheory.Limits.pushout.inl =\n                        CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp h g)\n                          CategoryTheory.Limits.pushout.inr))", "name": "CategoryTheory.Limits.pushoutIsPushoutOfEpiComp", "isProp": false, "docString": "The pushout of `f, g` is also the pullback of `h ≫ f, h ≫ g` for any epi `h`. ", "terms": "[\"pushout\", \"pullback\", \"epi\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    (J : CategoryTheory.GrothendieckTopology C) →\n      {D : Type w} →\n        [inst_1 : CategoryTheory.Category.{max v u, w} D] →\n          [inst_2 :\n              ∀ (P : CategoryTheory.Functor Cᵒᵖ D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X),\n                CategoryTheory.Limits.HasMultiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)] →\n            [inst_3 :\n                ∀ (X : C),\n                  CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)ᵒᵖ D] →\n              {P Q : CategoryTheory.Functor Cᵒᵖ D} →\n                (P ⟶ Q) →\n                  (CategoryTheory.GrothendieckTopology.plusObj J P ⟶ CategoryTheory.GrothendieckTopology.plusObj J Q)", "name": "CategoryTheory.GrothendieckTopology.plusMap", "isProp": false, "docString": "An auxiliary definition used in `plus` below. ", "terms": "[]"}
{"type": "(C : Type u₁) →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      [inst_2 : CategoryTheory.BraidedCategory C] → CategoryTheory.MonoidalFunctor C (CategoryTheory.Center C)", "name": "CategoryTheory.Center.ofBraided", "isProp": false, "docString": "The functor lifting a braided category to its center, using the braiding as the half-braiding.\n", "terms": "[\n    \"functor\",\n    \"lifting\",\n    \"braided category\",\n    \"center\",\n    \"braiding\",\n    \"half-braiding\"\n]"}
{"type": "{V : Type u_1} →\n  {W : Type u_2} →\n    [inst : SeminormedAddCommGroup V] → [inst_1 : SeminormedAddCommGroup W] → NormedAddGroupHom V W → V → W", "name": "NormedAddGroupHom.toFun", "isProp": false, "docString": "The function underlying a `NormedAddGroupHom` ", "terms": "[\n    \"function\",\n    \"underlying\",\n    \"NormedAddGroupHom\"\n]"}
{"type": "{X Y : AlgebraicGeometry.Scheme} →\n  (f : X ⟶ Y) →\n    {V : TopologicalSpace.Opens ↑↑X.toPresheafedSpace} →\n      {U : TopologicalSpace.Opens ↑↑Y.toPresheafedSpace} →\n        V ≤ f⁻¹ᵁ U → (Y.presheaf.obj (Opposite.op U) ⟶ X.presheaf.obj (Opposite.op V))", "name": "AlgebraicGeometry.Scheme.Hom.appLe", "isProp": false, "docString": "Given a morphism of schemes `f : X ⟶ Y`, and open sets `U ⊆ Y`, `V ⊆ f ⁻¹' U`,\nthis is the induced map `Γ(Y, U) ⟶ Γ(X, V)`. ", "terms": "[\n    \"morphism\",\n    \"schemes\",\n    \"open sets\",\n    \"induced map\"\n]"}
{"type": "(R : Type u_2) →\n  {M : Type u_5} →\n    {M₂ : Type u_6} →\n      [inst : Semiring R] →\n        [inst_1 : AddCommMonoid M] →\n          [inst_2 : Module R M] →\n            [inst_3 : AddCommMonoid M₂] →\n              [inst_4 : SMul R M₂] →\n                (f : M₂ →+ M) → Function.Injective ⇑f → (∀ (c : R) (x : M₂), f (c • x) = c • f x) → Module R M₂", "name": "Function.Injective.module", "isProp": false, "docString": "Pullback a `Module` structure along an injective additive monoid homomorphism.\nSee note [reducible non-instances]. ", "terms": "[\n    \"Pullback\",\n    \"Module\",\n    \"Structure\",\n    \"Injective\",\n    \"Additive\",\n    \"Monoid\",\n    \"Homomorphism\",\n    \"Reducible\",\n    \"Non-instances\"\n]"}
{"type": "{α : Sort u_1} →\n  {β : Sort u_2} →\n    (r : α → α → Prop) →\n      (s : β → β → Prop) →\n        (f : α → β → Prop) →\n          (ha : ∀ (a : α) (b₁ b₂ : β), s b₁ b₂ → f a b₁ = f a b₂) →\n            (hb : ∀ (a₁ a₂ : α) (b : β), r a₁ a₂ → f a₁ b = f a₂ b) →\n              [hf : (a : α) → DecidablePred (f a)] → (q₁ : Quot r) → DecidablePred (Quot.lift₂ f ha hb q₁)", "name": "Quot.lift₂.decidablePred", "isProp": false, "docString": "Note that this provides `DecidableRel (Quot.Lift₂ f ha hb)` when `α = β`. ", "terms": "[\n  \"DecidableRel\",\n  \"Quot.Lift₂\",\n  \"f\",\n  \"ha\",\n  \"hb\",\n  \"α\",\n  \"β\"\n]"}
{"type": "∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ⟶ W)", "name": "FdRep.instFiniteDimensionalHomFdRepToQuiverToCategoryStructInstLargeCategoryFdRepToDivisionRingHomGroupInstPreadditiveFdRepInstLargeCategoryFdRepHomModuleToSemiringToDivisionSemiringInstLinearToSemiringToDivisionSemiringToSemifieldFdRepInstLargeCategoryFdRepInstPreadditiveFdRepInstLargeCategoryFdRep", "isProp": true, "docString": "All hom spaces are finite dimensional. ", "terms": "[\n    \"hom spaces\",\n    \"finite dimensional\"\n]"}
{"type": "∀ {α : Type u} {a b c d : α} [inst : Preorder α], c ≤ a → b ≤ d → a ≤ b → c ≤ d", "name": "le_implies_le_of_le_of_le", "isProp": true, "docString": "monotonicity of `≤` with respect to `→` ", "terms": "[\"monotonicity\", \"≤\", \"→\"]"}
{"type": "{α : Type u_1} →\n  {E : Type u_2} →\n    {m0 : MeasurableSpace α} →\n      (p : ENNReal) →\n        (μ : MeasureTheory.Measure α) →\n          [inst : NormedAddCommGroup E] →\n            [inst_1 : TopologicalSpace α] →\n              [inst_2 : BorelSpace α] →\n                [inst_3 : SecondCountableTopologyEither α E] →\n                  [inst_4 : CompactSpace α] →\n                    [inst_5 : MeasureTheory.IsFiniteMeasure μ] →\n                      (𝕜 : Type u_5) →\n                        [inst_6 : Fact (1 ≤ p)] →\n                          [inst_7 : NormedField 𝕜] → [inst_8 : NormedSpace 𝕜 E] → C(α, E) →L[𝕜] ↥(MeasureTheory.Lp E p)", "name": "ContinuousMap.toLp", "isProp": false, "docString": "The bounded linear map of considering a continuous function on a compact finite-measure\nspace `α` as an element of `Lp`.  By definition, the norm on `C(α, E)` is the sup-norm, transferred\nfrom the space `α →ᵇ E` of bounded continuous functions, so this construction is just a matter of\ntransferring the structure from `BoundedContinuousFunction.toLp` along the isometry. ", "terms": "[\n  \"bounded linear map\",\n  \"continuous function\",\n  \"compact\",\n  \"finite-measure space\",\n  \"element\",\n  \"Lp\",\n  \"norm\",\n  \"C(α, E)\",\n  \"sup-norm\",\n  \"space\",\n  \"α →ᵇ E\",\n  \"bounded continuous functions\",\n  \"construction\",\n  \"transferring\",\n  \"structure\",\n  \"BoundedContinuousFunction.toLp\",\n  \"isometry\"\n]"}
{"type": "(B : Type u) →\n  [inst : Quiver B] →\n    CategoryTheory.PrelaxFunctor (CategoryTheory.LocallyDiscrete (CategoryTheory.Paths B))\n      (CategoryTheory.FreeBicategory B)", "name": "CategoryTheory.FreeBicategory.preinclusion", "isProp": false, "docString": "The inclusion from the locally discrete bicategory on the path category into the free bicategory\nas a prelax functor. This will be promoted to a pseudofunctor after proving the coherence theorem.\nSee `inclusion`.\n", "terms": "[\n    \"inclusion\",\n    \"locally discrete bicategory\",\n    \"path category\",\n    \"free bicategory\",\n    \"prelax functor\",\n    \"pseudofunctor\",\n    \"coherence theorem\"\n]"}
{"type": "∀ {𝕜 : Type u} {A : Type v} [inst : NontriviallyNormedField 𝕜] [inst_1 : NonUnitalNormedRing A]\n  [inst_2 : NormedSpace 𝕜 A] [inst_3 : SMulCommClass 𝕜 A A] [inst_4 : IsScalarTower 𝕜 A A]\n  (self : DoubleCentralizer 𝕜 A) (x y : A), self.toProd.2 x * y = x * self.toProd.1 y", "name": "DoubleCentralizer.central", "isProp": true, "docString": "The centrality condition that the maps linear maps intertwine one another. ", "terms": "[\"centrality condition\", \"maps\", \"linear maps\", \"intertwine\"]"}
{"type": "{α : Type u} → [self : AndOp α] → α → α → α", "name": "AndOp.and", "isProp": false, "docString": "The implementation of `a &&& b : α`. See `HAnd`. ", "terms": "[\"implementation\", \"&&&\", \":\", \"α\", \"HAnd\"]"}
{"type": "{R : Type u} →\n  {A : Type v} →\n    [inst : CommSemiring R] →\n      [inst_1 : NonUnitalNonAssocSemiring A] →\n        [inst_2 : Module R A] → (S : NonUnitalSubalgebra R A) → ↥(NonUnitalSubalgebra.toSubmodule S) ≃ₗ[R] ↥S", "name": "NonUnitalSubalgebra.toSubmoduleEquiv", "isProp": false, "docString": "Linear equivalence between `S : Submodule R A` and `S`. Though these types are equal,\nwe define it as a `LinearEquiv` to avoid type equalities. ", "terms": "[\n  \"Linear equivalence\",\n  \"Submodule\",\n  \"LinearEquiv\",\n  \"type equalities\"\n]"}
{"type": "∀ {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] {H : Type uH}\n  [inst_3 : TopologicalSpace H] {I : ModelWithCorners ℝ E H} {M : Type uM} [inst_4 : TopologicalSpace M]\n  [inst_5 : ChartedSpace H M] {c : M} (f : SmoothBumpFunction I c) {s : Set M},\n  IsClosed s →\n    s ⊆ Function.support ↑f →\n      ∃ r ∈ Set.Ioo 0 f.rOut,\n        s ⊆ (chartAt H c).toPartialEquiv.source ∩ ↑(extChartAt I c) ⁻¹' Metric.ball (↑(extChartAt I c) c) r", "name": "SmoothBumpFunction.exists_r_pos_lt_subset_ball", "isProp": true, "docString": "If `f` is a smooth bump function and `s` closed subset of the support of `f` (i.e., of the open\nball of radius `f.rOut`), then there exists `0 < r < f.rOut` such that `s` is a subset of the open\nball of radius `r`. Formally, `s ⊆ e.source ∩ e ⁻¹' (ball (e c) r)`, where `e = extChartAt I c`. ", "terms": "[\n  \"smooth bump function\",\n  \"closed subset\",\n  \"support\",\n  \"open ball\",\n  \"radius\",\n  \"exists\",\n  \"subset\",\n  \"formally\",\n  \"source\",\n  \"intersection\",\n  \"inverse image\",\n  \"extChartAt\"\n]"}
{"type": "∀ {R : Type v} [inst : CommRing R] (A : Matrix (Fin 1) (Fin 1) R), Matrix.det A = A 0 0", "name": "Matrix.det_fin_one", "isProp": true, "docString": "Determinant of 1x1 matrix ", "terms": "[\"Determinant\", \"Matrix\"]"}
{"type": "{α : Type u} → {β : Type v} → [inst : Group β] → (α → β) ≃ (FreeGroup α →* β)", "name": "FreeGroup.lift", "isProp": false, "docString": "If `β` is a group, then any function from `α` to `β` extends uniquely to a group homomorphism\nfrom the free group over `α` to `β` ", "terms": "[\n    \"group\",\n    \"function\",\n    \"extends\",\n    \"uniquely\",\n    \"group homomorphism\",\n    \"free group\",\n    \"over\"\n]"}
{"type": "{α : Type u} → [self : Min α] → α → α → α", "name": "Min.min", "isProp": false, "docString": "The minimum operation: `min x y`. ", "terms": "[\"minimum\", \"operation\"]"}
{"type": "{R : Type u_4} → [inst : AddMonoidWithOne R] → One (AddSubmonoid R)", "name": "AddSubmonoid.one", "isProp": false, "docString": "If `R` is an additive monoid with one (e.g., a semiring), then `1 : AddSubmonoid R` is the range\nof `Nat.cast : ℕ → R`. ", "terms": "[\n    \"Additive Monoid\",\n    \"One\",\n    \"Semiring\",\n    \"AddSubmonoid\",\n    \"Range\",\n    \"Nat.cast\"\n]"}
{"type": "{C : Type u} → [inst : CategoryTheory.Category.{v, u} C] → {X Y : C} → (X ⟶ Y) → (X ⟶ Y) → Prop", "name": "CategoryTheory.Limits.HasEqualizer", "isProp": false, "docString": "`HasEqualizer f g` represents a particular choice of limiting cone\nfor the parallel pair of morphisms `f` and `g`.\n", "terms": "[\n  \"HasEqualizer\",\n  \"limiting cone\",\n  \"parallel pair\",\n  \"morphisms\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {F : CategoryTheory.Functor C D} → [inst_2 : CategoryTheory.IsEquivalence F] → CategoryTheory.IsLeftAdjoint F", "name": "CategoryTheory.Functor.leftAdjointOfEquivalence", "isProp": false, "docString": "If `F` is an equivalence, it's a left adjoint. ", "terms": "[\n    \"equivalence\",\n    \"left adjoint\"\n]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P n),\n  Affine.Simplex.mongePoint s ∈ affineSpan ℝ (Set.range s.points)", "name": "Affine.Simplex.mongePoint_mem_affineSpan", "isProp": true, "docString": "The Monge point lies in the affine span. ", "terms": "[\"Monge point\", \"affine span\"]"}
{"type": "∀ {E : Type u_1} {β : Type u_2} [inst : AddCommGroup E] [inst_1 : TopologicalSpace E] [inst_2 : Module ℝ E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] [inst_5 : OrderedAddCommGroup β] [inst_6 : Module ℝ β]\n  [inst_7 : OrderedSMul ℝ β] {s : Set E} {f : E → β} {a : E},\n  a ∈ s → IsLocalMinOn f s a → ConvexOn ℝ s f → IsMinOn f s a", "name": "IsMinOn.of_isLocalMinOn_of_convexOn", "isProp": true, "docString": "A local minimum of a convex function is a global minimum, restricted to a set `s`.\n", "terms": "[\n    \"local minimum\",\n    \"convex function\",\n    \"global minimum\",\n    \"set\"\n]"}
{"type": "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ x ∈ s, ∀ y ∈ s, ∃ t ⊆ s, x ∈ t ∧ y ∈ t ∧ IsPreconnected t) → IsPreconnected s", "name": "isPreconnected_of_forall_pair", "isProp": true, "docString": "If any two points of a set are contained in a preconnected subset,\nthen the original set is preconnected as well. ", "terms": "[\n    \"points\",\n    \"set\",\n    \"contained\",\n    \"preconnected subset\",\n    \"original set\",\n    \"preconnected\"\n]"}
{"type": "{n : ℕ} → (F : TypeVec.{u_1} (n + 1) → Type u_1) → [inst : MvFunctor F] → [q : MvQPF F] → TypeVec.{u_1} n → Type u_1", "name": "MvQPF.Fix", "isProp": false, "docString": "Least fixed point of functor F. The result is a functor with one fewer parameters\nthan the input. For `F a b c` a ternary functor, `Fix F` is a binary functor such that\n\n```lean\nFix F a b = F a b (Fix F a b)\n```\n", "terms": "[\n    \"Least fixed point\",\n    \"functor\",\n    \"parameters\",\n    \"ternary functor\",\n    \"binary functor\"\n]"}
{"type": "WType WType.Natβ → ℕ", "name": "WType.toNat", "isProp": false, "docString": "The isomorphism from the `WType` of the naturals to the naturals ", "terms": "[\n    \"Isomorphism\", \n    \"WType\", \n    \"Naturals\"\n]"}
{"type": "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] (s : Set 𝕜) [inst_1 : CompactSpace ↑s],\n  StarSubalgebra.topologicalClosure (Subalgebra.starClosure (polynomialFunctions s)) = ⊤", "name": "polynomialFunctions.starClosure_topologicalClosure", "isProp": true, "docString": "The star subalgebra generated by polynomials functions is dense in `C(s, 𝕜)` when `s` is\ncompact and `𝕜` is either `ℝ` or `ℂ`. ", "terms": "[\n    \"star subalgebra\",\n    \"polynomials functions\",\n    \"dense\",\n    \"C(s, 𝕜)\",\n    \"compact\",\n    \"ℝ\",\n    \"ℂ\"\n]"}
{"type": "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {F : Type u_2} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace 𝕜 F] {f : 𝕜 → F} {n : ℕ∞},\n  ContDiff 𝕜 n f ↔\n    (∀ (m : ℕ), ↑m ≤ n → Continuous (iteratedDeriv m f)) ∧ ∀ (m : ℕ), ↑m < n → Differentiable 𝕜 (iteratedDeriv m f)", "name": "contDiff_iff_iteratedDeriv", "isProp": true, "docString": "The property of being `C^n`, initially defined in terms of the Fréchet derivative, can be\nreformulated in terms of the one-dimensional derivative. ", "terms": "[\n    \"Property\",\n    \"C^n\",\n    \"Initially defined\",\n    \"Fréchet derivative\",\n    \"Reformulated\",\n    \"One-dimensional derivative\"\n]"}
{"type": "{C : Type uC} →\n  [inst : CategoryTheory.Category.{uC', uC} C] →\n    {W : CategoryTheory.MorphismProperty C} →\n      {D : Type uD} →\n        [inst_1 : CategoryTheory.Category.{uD', uD} D] →\n          {F₁ F₂ : CategoryTheory.Functor (CategoryTheory.MorphismProperty.Localization W) D} →\n            (CategoryTheory.Functor.comp (CategoryTheory.MorphismProperty.Q W) F₁ ⟶\n                CategoryTheory.Functor.comp (CategoryTheory.MorphismProperty.Q W) F₂) →\n              (F₁ ⟶ F₂)", "name": "CategoryTheory.Localization.Construction.natTransExtension", "isProp": false, "docString": "If `F₁` and `F₂` are functors `W.Localization ⥤ D`, a natural transformation `F₁ ⟶ F₂`\ncan be obtained from a natural transformation `W.Q ⋙ F₁ ⟶ W.Q ⋙ F₂`. ", "terms": "[\n    \"Functors\",\n    \"Localization\",\n    \"Natural Transformation\"\n]"}
{"type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  {p₁ p₂ p₃ p₄ p₅ p₆ : P},\n  2 • EuclideanGeometry.oangle p₁ p₂ p₃ = 2 • EuclideanGeometry.oangle p₄ p₅ p₆ →\n    (Collinear ℝ {p₁, p₂, p₃} ↔ Collinear ℝ {p₄, p₅, p₆})", "name": "EuclideanGeometry.collinear_iff_of_two_zsmul_oangle_eq", "isProp": true, "docString": "If twice the oriented angles between two triples of points are equal, one triple is collinear\nif and only if the other is. ", "terms": "[\n  \"twice\",\n  \"oriented angles\",\n  \"triples of points\",\n  \"equal\",\n  \"collinear\",\n  \"if and only if\"\n]"}
{"type": "(p : ℕ) →\n  (R : Type u_1) →\n    [hp : Fact (Nat.Prime p)] →\n      [inst : CommRing R] → [inst_1 : CharP R p] → [inst_2 : PerfectRing R p] → WittVector p R ≃+* WittVector p R", "name": "WittVector.frobeniusEquiv", "isProp": false, "docString": "`WittVector.frobenius` as an equiv. ", "terms": "[\n    \"WittVector\",\n    \"frobenius\",\n    \"equiv\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {M : Type u_1} →\n      [inst_1 : CategoryTheory.Category.{u_2, u_1} M] →\n        [inst_2 : CategoryTheory.MonoidalCategory M] →\n          (F : CategoryTheory.MonoidalFunctor M (CategoryTheory.Functor C C)) →\n            (m n : M) →\n              (CategoryTheory.MonoidalCategory.tensorObj m n ≅ 𝟙_ M) →\n                (CategoryTheory.Functor.comp (F.obj m) (F.obj n) ≅ CategoryTheory.Functor.id C)", "name": "CategoryTheory.unitOfTensorIsoUnit", "isProp": false, "docString": "If `m ⊗ n ≅ 𝟙_M`, then `F.obj m` is a left inverse of `F.obj n`. ", "terms": "[\n  \"tensor product\",\n  \"isomorphic\",\n  \"identity\",\n  \"functor\",\n  \"object\",\n  \"left inverse\"\n]"}
{"type": "{k : Type u_1} →\n  {V : Type u_2} →\n    {P : Type u_3} →\n      [inst : Ring k] →\n        [inst_1 : AddCommGroup V] →\n          [inst_2 : Module k V] →\n            [inst_3 : AddTorsor V P] →\n              {m n : ℕ} → Affine.Simplex k P m → Fin (m + 1) ≃ Fin (n + 1) → Affine.Simplex k P n", "name": "Affine.Simplex.reindex", "isProp": false, "docString": "Remap a simplex along an `Equiv` of index types. ", "terms": "[\"Remap\", \"Simplex\", \"Equiv\", \"Index types\"]"}
{"type": "{U : Type u_1} → [inst : Quiver U] → {u v u' v' : U} → u = u' → v = v' → (u ⟶ v) → (u' ⟶ v')", "name": "Quiver.Hom.cast", "isProp": false, "docString": "Change the endpoints of an arrow using equalities. ", "terms": "[\"endpoints\", \"arrow\", \"equalities\"]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} {f : α → β}, Function.Injective f → ∀ (s : Set α), Set.InjOn f s", "name": "Function.Injective.injOn", "isProp": true, "docString": "**Alias** of `Set.injOn_of_injective`.", "terms": "[\"Alias\", \"Set\", \"injOn_of_injective\"]"}
{"type": "Lean.Syntax →\n  List (Lean.Expr × Bool) →\n    optParam (Option Lean.Expr) none →\n      optParam (Option Lean.Expr) none → optParam (Option Lean.Syntax) none → Lean.Elab.TermElabM Unit", "name": "addRewriteSuggestion", "isProp": false, "docString": "Add a suggestion for `rw [h₁, ← h₂] at loc`. ", "terms": "[]\n"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      {S : CategoryTheory.ShortComplex C} →\n        (self : CategoryTheory.ShortComplex.LeftHomologyData S) →\n          CategoryTheory.Limits.IsLimit\n            (CategoryTheory.Limits.KernelFork.ofι self.i (_ : CategoryTheory.CategoryStruct.comp self.i S.g = 0))", "name": "CategoryTheory.ShortComplex.LeftHomologyData.hi", "isProp": false, "docString": "`i : K ⟶ S.X₂` is a kernel of `g : S.X₂ ⟶ S.X₃` ", "terms": "[\n    \"Kernel\",\n    \"Function\"\n]"}
{"type": "(R : Type u_1) →\n  [inst : CommSemiring R] → (M : Type u_5) → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → R →ₗ[R] M →ₗ[R] M", "name": "LinearMap.lsmul", "isProp": false, "docString": "Scalar multiplication as a bilinear map `R → M → M`. ", "terms": "[\n    \"Scalar multiplication\",\n    \"bilinear map\",\n    \"R\",\n    \"M\"\n]"}
{"type": "∀ (R : Type u_1) (L : Type u_2) (M : Type u_3) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst_3 : AddCommGroup M] [inst_4 : Module R M] [inst_5 : LieRingModule L M] [inst_6 : LieModule R L M]\n  [inst_7 : LieAlgebra.IsNilpotent R L] [inst_8 : LieModule.LinearWeights R L M] (χ : L → R)\n  [inst_9 : IsNoetherian R M], LieModule.IsNilpotent R L ↥↑(LieModule.shiftedWeightSpace R L M χ)", "name": "LieModule.shiftedWeightSpace.instIsNilpotentSubtypeMemSubmoduleToSemiringToCommSemiringToAddCommMonoidInstMembershipSetLikeToSubmoduleShiftedWeightSpaceAddCommGroupToRingInstModuleSubtypeMemSubmoduleToSemiringToCommSemiringToAddCommMonoidInstMembershipSetLikeToSubmoduleAddCommMonoidInstLieRingModuleSubtypeMemSubmoduleToSemiringToCommSemiringToAddCommMonoidInstMembershipSetLikeToSubmoduleShiftedWeightSpaceAddCommGroupToRing", "isProp": true, "docString": "By Engel's theorem, if `M` is Noetherian, the shifted action `⁅x, m⁆ - χ x • m` makes the\n`χ`-weight space into a nilpotent Lie module. ", "terms": "[\n    \"Engel's theorem\",\n    \"Noetherian\",\n    \"shifted action\",\n    \"weight space\",\n    \"nilpotent\",\n    \"Lie module\"\n]"}
{"type": "{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {C : Type u₃} →\n      [inst_1 : CategoryTheory.Category.{v₃, u₃} C] →\n        {F : CategoryTheory.Functor J C} →\n          {t : CategoryTheory.Limits.Cone F} →\n            (∀ (s : CategoryTheory.Limits.Cone F),\n                ∃! l, ∀ (j : J), CategoryTheory.CategoryStruct.comp l (t.π.app j) = s.π.app j) →\n              CategoryTheory.Limits.IsLimit t", "name": "CategoryTheory.Limits.IsLimit.ofExistsUnique", "isProp": false, "docString": "Noncomputably make a colimit cocone from the existence of unique factorizations. ", "terms": "[\n    \"Noncomputably\",\n    \"Colimit\",\n    \"Cocone\",\n    \"Existence\",\n    \"Unique Factorizations\"\n]"}
{"type": "∀ {α : Type u_1} [inst : CanonicallyLinearOrderedAddCommMonoid α] [inst_1 : Sub α] [inst_2 : OrderedSub α] {a b c : α}\n  [inst_3 : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], b ≤ a → (a - b < a - c ↔ c < b)", "name": "tsub_lt_tsub_iff_left_of_le", "isProp": true, "docString": "See `lt_tsub_iff_left_of_le_of_le` for a weaker statement in a partial order. ", "terms": "[]"}
{"type": "{R : Type u} →\n  {M₁ : Type v} →\n    {M₂ : Type w} →\n      [inst : CommRing R] →\n        [inst_1 : AddCommGroup M₁] →\n          [inst_2 : Module R M₁] →\n            [inst_3 : AddCommGroup M₂] → [inst_4 : Module R M₂] → (M₁ ≃ₗ[R] M₂) → Module.End R M₁ ≃ₗ⁅R⁆ Module.End R M₂", "name": "LinearEquiv.lieConj", "isProp": false, "docString": "A linear equivalence of two modules induces a Lie algebra equivalence of their endomorphisms. ", "terms": "[\n    \"linear equivalence\",\n    \"modules\",\n    \"induces\",\n    \"Lie algebra equivalence\",\n    \"endomorphisms\"\n]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      {S₁ S₂ : CategoryTheory.ShortComplex C} →\n        {φ₁ φ₂ : S₁ ⟶ S₂} → CategoryTheory.ShortComplex.Homotopy φ₁ φ₂ → CategoryTheory.ShortComplex.Homotopy φ₂ φ₁", "name": "CategoryTheory.ShortComplex.Homotopy.symm", "isProp": false, "docString": "The symmetry of homotopy between morphisms of short complexes. ", "terms": "[\n  \"symmetry\",\n  \"homotopy\",\n  \"morphisms\",\n  \"short complexes\"\n]"}
{"type": "Lean.ParserDescr", "name": "MeasureTheory.«termMeasurableSet[_]»", "isProp": false, "docString": "Notation for `MeasurableSet` with respect to a non-standard σ-algebra. ", "terms": "[\"Notation\", \"MeasurableSet\", \"respect\", \"non-standard\", \"σ-algebra\"]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {X Y : C} →\n      (f : X ⟶ Y) →\n        [inst_1 : CategoryTheory.Mono f] →\n          CategoryTheory.Functor (CategoryTheory.MonoOver X) (CategoryTheory.MonoOver Y)", "name": "CategoryTheory.MonoOver.map", "isProp": false, "docString": "We can map monomorphisms over `X` to monomorphisms over `Y`\nby post-composition with a monomorphism `f : X ⟶ Y`.\n", "terms": "[\n  \"map\",\n  \"monomorphisms\",\n  \"over\",\n  \"to\",\n  \"post-composition\",\n  \"with\",\n  \"monomorphism\"\n]"}
{"type": "∀ {α : Type u_2} [self : StrictOrderedCommRing α] (a b : α), a * b = b * a", "name": "StrictOrderedCommRing.mul_comm", "isProp": true, "docString": "Multiplication is commutative in a commutative semigroup. ", "terms": "[\n  \"Multiplication\",\n  \"Commutative\",\n  \"Commutative Semigroup\"\n]"}
{"type": "Type u → Type u", "name": "CategoryTheory.ULiftHom", "isProp": false, "docString": "`ULiftHom.{w} C` is an alias for `C`, which is endowed with a category instance\nwhose morphisms are obtained by applying `ULift.{w}` to the morphisms from `C`.\n", "terms": "[\n    \"ULiftHom.{w}\",\n    \"C\",\n    \"alias\",\n    \"endowed\",\n    \"category instance\",\n    \"morphisms\",\n    \"applying\",\n    \"ULift.{w}\"\n]"}
{"type": "(C : Type u) →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    (X : TopCat) → CategoryTheory.Functor (TopCat.Sheaf C X) (TopCat.Presheaf C X)", "name": "TopCat.Sheaf.forget", "isProp": false, "docString": "The forgetful functor from sheaves to presheaves.\n", "terms": "[\n    \"forgetful functor\",\n    \"sheaves\",\n    \"presheaves\"\n]"}
{"type": "CategoryTheory.Monad MeasCat", "name": "MeasCat.Giry", "isProp": false, "docString": "The Giry monad, i.e. the monadic structure associated with `Measure`. ", "terms": "[\"Giry monad\", \"monadic structure\", \"Measure\"]"}
{"type": "{F : PFunctor.{u}} → PFunctor.M F → F.A", "name": "PFunctor.M.head", "isProp": false, "docString": "given a tree generated by `F`, `head` gives us the first piece of data\nit contains ", "terms": "[\"tree\", \"generated\", \"head\", \"first\", \"piece\", \"data\", \"contains\"]"}
{"type": "{X : Type u_1} →\n  {Y : Type u_2} →\n    [inst : TopologicalSpace X] →\n      [inst_1 : TopologicalSpace Y] →\n        {Z : Type u_5} →\n          (R : Type u_4) →\n            [inst_2 : CommSemiring R] →\n              [inst_3 : Semiring Z] →\n                [inst_4 : Algebra R Z] → (f : X → Y) → Continuous f → LocallyConstant Y Z →ₐ[R] LocallyConstant X Z", "name": "LocallyConstant.comapₐ", "isProp": false, "docString": "`LocallyConstant.comap` as an `AlgHom` ", "terms": "[\n  \"LocallyConstant.comap\",\n  \"AlgHom\"\n]"}
{"type": "∀ {α : Type u_1} {m : MeasurableSpace α} {f : α → α} {s : Set α} {μ : MeasureTheory.Measure α},\n  QuasiErgodic f →\n    MeasureTheory.NullMeasurableSet s →\n      f ⁻¹' s =ᶠ[MeasureTheory.Measure.ae μ] s → (∀ᵐ (x : α) ∂μ, x ∈ s) ∨ ∀ᵐ (x : α) ∂μ, x ∉ s", "name": "QuasiErgodic.ae_mem_or_ae_nmem₀", "isProp": true, "docString": "For a quasi ergodic map, sets that are almost invariant (rather than strictly invariant) are\nstill either almost empty or full. ", "terms": "[\n    \"quasi ergodic map\",\n    \"sets\",\n    \"almost invariant\",\n    \"strictly invariant\",\n    \"almost empty\",\n    \"full\"\n]"}
{"type": "{T : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} T] →\n    {X : T} →\n      {f g : CategoryTheory.Over X} →\n        (hl : f.left ≅ g.left) → autoParam (CategoryTheory.CategoryStruct.comp hl.hom g.hom = f.hom) _auto✝ → (f ≅ g)", "name": "CategoryTheory.Over.isoMk", "isProp": false, "docString": "Construct an isomorphism in the over category given isomorphisms of the objects whose forward\ndirection gives a commutative triangle.\n", "terms": "[\n    \"Construct\",\n    \"Isomorphism\",\n    \"Over Category\",\n    \"Isomorphisms\",\n    \"Objects\",\n    \"Forward Direction\",\n    \"Commutative Triangle\"\n]"}
{"type": "∀ {α : Type u} {s : Set α} (hs : Set.Finite s), { x // x ∈ Set.Finite.toFinset hs } = ↑s", "name": "Set.Finite.coeSort_toFinset", "isProp": true, "docString": "Note that this is an equality of types not holding definitionally. Use wisely. ", "terms": "[]\n"}
{"type": "{n m : ℕ} →\n  {G : Fin2 n → TypeVec.{u} m → Type u} →\n    [fG : (i : Fin2 n) → MvFunctor (G i)] →\n      {α β : TypeVec.{u} m} → TypeVec.Arrow α β → TypeVec.Arrow (fun i => G i α) fun i => G i β", "name": "MvQPF.Comp.map'", "isProp": false, "docString": "map operation defined on a vector of functors ", "terms": "[\n    \"map operation\",\n    \"vector\",\n    \"functors\"\n]"}
{"type": "(R : Type u) →\n  [inst : Semiring R] →\n    (M : Type v) →\n      (ι : optParam (Type u_1) PUnit.{u_1 + 1}) →\n        [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → [inst_3 : Unique ι] → (DirectSum ι fun x => M) ≃ₗ[R] M", "name": "DirectSum.lid", "isProp": false, "docString": "The natural linear equivalence between `⨁ _ : ι, M` and `M` when `Unique ι`. ", "terms": "[\n    \"natural\",\n    \"linear\",\n    \"equivalence\",\n    \"⨁ (direct sum)\",\n    \"M (mathematical object or structure)\",\n    \"Unique\",\n    \"ι (index set)\"\n]"}
{"type": "{ι : Type v} →\n  [dec_ι : DecidableEq ι] →\n    [inst : Preorder ι] →\n      (G : ι → Type w) →\n        [inst_1 : (i : ι) → AddCommGroup (G i)] →\n          (f : (i j : ι) → i ≤ j → G i →+ G j) →\n            (P : Type u₁) →\n              [inst_2 : AddCommGroup P] →\n                (g : (i : ι) → G i →+ P) →\n                  (∀ (i j : ι) (hij : i ≤ j) (x : G i), (g j) ((f i j hij) x) = (g i) x) →\n                    AddCommGroup.DirectLimit G f →+ P", "name": "AddCommGroup.DirectLimit.lift", "isProp": false, "docString": "The universal property of the direct limit: maps from the components to another abelian group\nthat respect the directed system structure (i.e. make some diagram commute) give rise\nto a unique map out of the direct limit. ", "terms": "[\n  \"universal property\",\n  \"direct limit\",\n  \"maps\",\n  \"components\",\n  \"abelian group\",\n  \"directed system structure\",\n  \"diagram\",\n  \"commute\",\n  \"unique map\"\n]"}
{"type": "∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (r : k) (p₁ p₂ : P), (AffineMap.lineMap p₂ p₁) r ∈ affineSpan k {p₁, p₂}", "name": "AffineMap.lineMap_rev_mem_affineSpan_pair", "isProp": true, "docString": "A combination of two points expressed with `lineMap` (with the two points reversed) lies in\ntheir affine span. ", "terms": "[\n  \"combination\",\n  \"points\",\n  \"lineMap\",\n  \"affine span\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} {e e' : PartialEquiv α β},\n  e ≈ e' → ∀ (s : Set α), PartialEquiv.restr e s ≈ PartialEquiv.restr e' s", "name": "PartialEquiv.EqOnSource.restr", "isProp": true, "docString": "Restriction of partial equivs respects equivalence. ", "terms": "[\n    \"Restriction\",\n    \"Partial\",\n    \"Equivs\",\n    \"Respects\",\n    \"Equivalence\"\n]"}
{"type": "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField 𝕜] [inst_1 : CompleteSpace 𝕜] [inst_2 : AddCommGroup E]\n  [inst_3 : UniformSpace E] [inst_4 : T2Space E] [inst_5 : UniformAddGroup E] [inst_6 : Module 𝕜 E]\n  [inst_7 : ContinuousSMul 𝕜 E] (s : Submodule 𝕜 E) [inst_8 : FiniteDimensional 𝕜 ↥s], IsComplete ↑s", "name": "Submodule.complete_of_finiteDimensional", "isProp": true, "docString": "A finite-dimensional subspace is complete. ", "terms": "[\"finite-dimensional\", \"subspace\", \"complete\"]"}
{"type": "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a : α}, -a < 0 ↔ 0 < a", "name": "Left.neg_neg_iff", "isProp": true, "docString": "Uses `left` co(ntra)variant.", "terms": "[\"co(ntra)variant\", \"left\"]"}
{"type": "∀ {α : Type u_2} {l : Filter α} [inst : Filter.IsCountablyGenerated l], Filter.IsCountablyGenerated (nhds l)", "name": "Filter.instIsCountablyGeneratedFilterNhds", "isProp": true, "docString": "Neighborhoods of a countably generated filter is a countably generated filter. ", "terms": "[\n    \"Neighborhoods\",\n    \"Countably generated\",\n    \"Filter\"\n]"}
{"type": "∀ {G : Type u_1} [inst : AddGroup G] {k : Set G}, k ⊆ ↑(AddSubgroup.closure k)", "name": "AddSubgroup.subset_closure", "isProp": true, "docString": "The `AddSubgroup` generated by a set includes the set.", "terms": "[\n    \"AddSubgroup\",\n    \"generated\",\n    \"set\",\n    \"includes\"\n]"}
{"type": "Lean.ParserDescr", "name": "ZNum.transfer", "isProp": false, "docString": "This tactic tries to prove (in)equalities about `ZNum`s by transferring them to the `Int` world and\nthen trying to call `simp`.\n```lean\nexample (n : ZNum) (m : ZNum) : n ≤ n + m * m := by\n  transfer\n  exact mul_self_nonneg _\n```\n", "terms": "[\n    \"ZNum\",\n    \"Int\",\n    \"inequalities\",\n    \"mul\",\n    \"self\",\n    \"nonneg\",\n    \"transfer\"\n]"}
{"type": "{X : Type u_1} → {Y : Sort u_2} → {Z : Type u_3} → {f : X → Y} → {g : Z → Y} → Function.Pullback f g → Z", "name": "Function.Pullback.snd", "isProp": false, "docString": "The projection from the fiber product to the second factor. ", "terms": "[\n    \"projection\",\n    \"fiber product\",\n    \"second factor\"\n]"}
{"type": "∀ {M : Type u_1} [inst : MulOneClass M] {s : Set M}, s ⊆ ↑(Submonoid.closure s)", "name": "Submonoid.subset_closure", "isProp": true, "docString": "The submonoid generated by a set includes the set. ", "terms": "[\n    \"Submonoid\",\n    \"Generated\",\n    \"Set\",\n    \"Includes\"\n]"}
{"type": "∀ {M : Type u_1} [inst : Mul M] {c d : Con M}, (∀ (x y : M), c x y ↔ d x y) ↔ c = d", "name": "Con.ext_iff", "isProp": true, "docString": "Iff version of extensionality rule for congruence relations. ", "terms": "[\n  \"Iff\",\n  \"version\",\n  \"extensionality\",\n  \"rule\",\n  \"congruence\",\n  \"relations\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {F : CategoryTheory.Functor C D} →\n          {G : CategoryTheory.Functor D C} →\n            (F ⊣ G) →\n              {J : Type u} →\n                [inst_2 : CategoryTheory.Category.{v, u} J] →\n                  {K : CategoryTheory.Functor J C} →\n                    (Y : D) →\n                      ((CategoryTheory.cocones J D).obj (Opposite.op (CategoryTheory.Functor.comp K F))).obj Y →\n                        (CategoryTheory.Functor.comp G ((CategoryTheory.cocones J C).obj (Opposite.op K))).obj Y", "name": "CategoryTheory.Adjunction.coconesIsoComponentHom", "isProp": false, "docString": "auxiliary construction for `coconesIso` ", "terms": "[\"auxiliary construction\", \"coconesIso\"]"}
{"type": "{F : Type u} → [inst : Field F] → RatFunc F → LaurentSeries F", "name": "RatFunc.coeToLaurentSeries_fun", "isProp": false, "docString": "The coercion `RatFunc F → LaurentSeries F` as a function.\n\nThis is the implementation of `coeToLaurentSeries`.\n", "terms": "[\n    \"coercion\",\n    \"RatFunc\",\n    \"LaurentSeries\",\n    \"function\",\n    \"implementation\",\n    \"coeToLaurentSeries\"\n]"}
{"type": "{p : ℕ} → [hp : Fact (Nat.Prime p)] → ℚ_[p] → ℚ", "name": "padicNormE.ratNorm", "isProp": false, "docString": "`ratNorm q`, for a `p`-adic number `q` is the `p`-adic norm of `q`, as rational number.\n\nThe lemma `padicNormE.eq_ratNorm` asserts `‖q‖ = ratNorm q`. ", "terms": "[\n    \"ratNorm\",\n    \"p-adic number\",\n    \"p-adic norm\",\n    \"rational number\",\n    \"lemma\",\n    \"padicNormE.eq_ratNorm\",\n    \"asserts\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {G : CategoryTheory.Comonad C} →\n      {A B : CategoryTheory.Comonad.Coalgebra G} → CategoryTheory.Comonad.Coalgebra.Hom A B → (A.A ⟶ B.A)", "name": "CategoryTheory.Comonad.Coalgebra.Hom.f", "isProp": false, "docString": "The underlying morphism associated to a morphism of coalgebras. ", "terms": "[\n  \"underlying\",\n  \"morphism\",\n  \"associated\",\n  \"coalgebras\"\n]"}
{"type": "{ι : Type u_7} → {Z : ι → Type u_8} → [inst : (i : ι) → OrderedCommMonoid (Z i)] → OrderedCommMonoid ((i : ι) → Z i)", "name": "Pi.orderedCommMonoid", "isProp": false, "docString": "The product of a family of ordered commutative monoids is an ordered commutative monoid. ", "terms": "[\n  \"product\",\n  \"family\",\n  \"ordered\",\n  \"commutative\",\n  \"monoids\"\n]"}
{"type": "{α : Type u} → Option (α × Stream'.WSeq α) → Computation (Option (α × Stream'.WSeq α))", "name": "Stream'.WSeq.tail.aux", "isProp": false, "docString": "auxiliary definition of tail over weak sequences", "terms": "[\n    \"auxiliary definition\",\n    \"tail\",\n    \"weak sequences\"\n]"}
{"type": "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {n : ℕ∞}\n  {s : Set E} {f : E → 𝕜} {g : E → F}, ContDiffOn 𝕜 n f s → ContDiffOn 𝕜 n g s → ContDiffOn 𝕜 n (fun x => f x • g x) s", "name": "ContDiffOn.smul", "isProp": true, "docString": "The scalar multiplication of two `C^n` functions on a domain is `C^n`. ", "terms": "[\n    \"scalar multiplication\",\n    \"C^n functions\",\n    \"domain\"\n]"}
{"type": "{J : Type v} →\n  [inst : CategoryTheory.SmallCategory J] →\n    [inst_1 : CategoryTheory.IsFiltered J] →\n      (F : CategoryTheory.Functor J AddGroupCat) → (j : J) × ↑(F.obj j) → ↑(AddGroupCat.FilteredColimits.G F)", "name": "AddGroupCat.FilteredColimits.G.mk", "isProp": false, "docString": "The canonical projection into the colimit, as a quotient type.", "terms": "[\n    \"canonical projection\",\n    \"colimit\",\n    \"quotient type\"\n]"}
{"type": "∀ {α : Type u_5} [self : NontriviallyNormedField α], ∃ x, 1 < ‖x‖", "name": "NontriviallyNormedField.non_trivial", "isProp": true, "docString": "The norm attains a value exceeding 1. ", "terms": "[\n    \"norm\",\n    \"value\",\n    \"exceeding\"\n]"}
{"type": "{𝕜 : Type u_1} →\n  {A : Type u_2} →\n    [inst : NontriviallyNormedField 𝕜] →\n      [inst_1 : NonUnitalNormedRing A] →\n        [inst_2 : NormedSpace 𝕜 A] →\n          [inst_3 : IsScalarTower 𝕜 A A] →\n            [inst_4 : SMulCommClass 𝕜 A A] → [inst_5 : RegularNormedAlgebra 𝕜 A] → NormedAlgebra 𝕜 (Unitization 𝕜 A)", "name": "Unitization.instNormedAlgebra", "isProp": false, "docString": "Pull back the normed algebra structure from `𝕜 × (A →L[𝕜] A)` to `Unitization 𝕜 A` using the\nalgebra homomorphism `Unitization.splitMul 𝕜 A`. ", "terms": "[\n  \"normed algebra structure\",\n  \"𝕜 × (A →L[𝕜] A)\",\n  \"Unitization 𝕜 A\",\n  \"algebra homomorphism\",\n  \"Unitization.splitMul 𝕜 A\"\n]"}
{"type": "Div ℚ", "name": "Rat.instDivRat", "isProp": false, "docString": "Division of rational numbers. Note: `div a 0 = 0`.  Written with a separate function `Rat.div`\nas a wrapper so that the definition is not unfolded at `.instance` transparency. ", "terms": "[\"Division\", \"Rational numbers\", \"Function\", \"Definition\", \"Instance\", \"Transparency\"]"}
{"type": "∀ {α : Type u_1} {Ω : Type u_2} {_mα : MeasurableSpace α} {_mΩ : MeasurableSpace Ω}\n  {κ : ↥(ProbabilityTheory.kernel α Ω)} {μ : MeasureTheory.Measure α} [inst : ProbabilityTheory.IsMarkovKernel κ]\n  {ι : Type u_8} {β : ι → Type u_9} {m : (i : ι) → MeasurableSpace (β i)} {f : (i : ι) → Ω → β i} (S T : Finset ι),\n  Disjoint S T →\n    ProbabilityTheory.kernel.iIndepFun m f κ →\n      (∀ (i : ι), Measurable (f i)) → ProbabilityTheory.kernel.IndepFun (fun a i => f (↑i) a) (fun a i => f (↑i) a) κ", "name": "ProbabilityTheory.kernel.iIndepFun.indepFun_finset", "isProp": true, "docString": "If `f` is a family of mutually independent random variables (`iIndepFun m f μ`) and `S, T` are\ntwo disjoint finite index sets, then the tuple formed by `f i` for `i ∈ S` is independent of the\ntuple `(f i)_i` for `i ∈ T`. ", "terms": "[\n  \"family\",\n  \"mutually independent\",\n  \"random variables\",\n  \"disjoint\",\n  \"finite\",\n  \"index sets\",\n  \"tuple\",\n  \"independent\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {W X Y : C} → [inst_1 : CategoryTheory.Limits.HasBinaryCoproduct X Y] → (X ⟶ W) → (Y ⟶ W) → (X ⨿ Y ⟶ W)", "name": "CategoryTheory.Limits.coprod.desc", "isProp": false, "docString": "If the coproduct of `X` and `Y` exists, then every pair of morphisms `f : X ⟶ W` and\n`g : Y ⟶ W` induces a morphism `coprod.desc f g : X ⨿ Y ⟶ W`. ", "terms": "[\"coproduct\", \"exists\", \"pair\", \"morphisms\", \"induces\", \"morphism\"]"}
{"type": "{α : Type u_1} → [inst : DecidableEq α] → α → Multiset α → ℕ", "name": "Multiset.count", "isProp": false, "docString": "`count a s` is the multiplicity of `a` in `s`. ", "terms": "[\"count\", \"multiplicity\"]"}
{"type": "∀ {R : Type u} {M : Type v} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {I : Ideal R}\n  {N : Submodule R M} {x : M} (hx : x ∈ I • N) {p : (x : M) → x ∈ I • N → Prop},\n  (∀ (r : R) (hr : r ∈ I) (n : M) (hn : n ∈ N), p (r • n) (_ : r • n ∈ I • N)) →\n    (∀ (x : M) (hx : x ∈ I • N) (y : M) (hy : y ∈ I • N), p x hx → p y hy → p (x + y) (_ : x + y ∈ I • N)) → p x hx", "name": "Submodule.smul_induction_on'", "isProp": true, "docString": "Dependent version of `Submodule.smul_induction_on`. ", "terms": "[\"Dependent\", \"Submodule\", \"smul\", \"induction\", \"on\"]"}
{"type": "∀ {α : Type u_1} (f : Poly α), IsPoly ⇑f", "name": "Poly.isPoly", "isProp": true, "docString": "The underlying function of a `Poly` is a polynomial ", "terms": "[\"underlying function\", \"Poly\", \"polynomial\"]"}
{"type": "(α : Type u_1) → [inst : Preorder α] → WithBot (WithTop ℕ)", "name": "krullDim", "isProp": false, "docString": "Krull dimension of a preorder `α` is the supremum of the rightmost index of all relation\nseries of `α` order by `<`. If there is no series `a₀ < a₁ < ... < aₙ` in `α`, then its Krull\ndimension is defined to be negative infinity; if the length of all series `a₀ < a₁ < ... < aₙ` is\nunbounded, its Krull dimension is defined to be positive infinity.\n", "terms": "[\n    \"Krull dimension\",\n    \"preorder\",\n    \"supremum\",\n    \"rightmost index\",\n    \"relation series\",\n    \"order\",\n    \"series\",\n    \"length\",\n    \"unbounded\",\n    \"negative infinity\",\n    \"positive infinity\"\n]"}
{"type": "{M : Type u_5} →\n  {N : Type u_6} →\n    {P : Type u_7} → [inst : Mul M] → [inst_1 : Mul N] → [inst_2 : Mul P] → (M →ₙ* N) → (M →ₙ* P) → M →ₙ* N × P", "name": "MulHom.prod", "isProp": false, "docString": "Combine two `MonoidHom`s `f : M →ₙ* N`, `g : M →ₙ* P` into\n`f.prod g : M →ₙ* (N × P)` given by `(f.prod g) x = (f x, g x)`. ", "terms": "[\n  \"MonoidHom\",\n  \"combine\",\n  \"two\",\n  \"into\",\n  \"given\",\n  \"by\",\n  \"prod\"\n]"}
{"type": "{𝕜 : Type u_1} →\n  {A : Type u_2} → [inst : NontriviallyNormedField 𝕜] → [inst : NonUnitalNormedRing A] → Bornology (Unitization 𝕜 A)", "name": "Unitization.instBornology", "isProp": false, "docString": "The bornology on `Unitization 𝕜 A` is inherited from `𝕜 × A`. ", "terms": "[\n    \"bornology\",\n    \"Unitization\",\n    \"inherited\"\n]"}
{"type": "goldenConj⁻¹ = -goldenRatio", "name": "inv_goldConj", "isProp": true, "docString": "The opposite of the golden ratio is the inverse of its conjugate. ", "terms": "[\n  \"opposite\",\n  \"golden ratio\",\n  \"inverse\",\n  \"conjugate\"\n]"}
{"type": "{I : Type u} →\n  (f : I → Type v) → [inst : DecidableEq I] → [inst : (i : I) → MulZeroClass (f i)] → (i : I) → f i →ₙ* (i : I) → f i", "name": "MulHom.single", "isProp": false, "docString": "The multiplicative homomorphism including a single `MulZeroClass`\ninto a dependent family of `MulZeroClass`es, as functions supported at a point.\n\nThis is the `MulHom` version of `Pi.single`. ", "terms": "[\n\"multiplicative homomorphism\",\n\"MulZeroClass\",\n\"dependent family\",\n\"functions supported at a point\",\n\"MulHom\",\n\"Pi.single\"\n]"}
{"type": "{ι : Type u_1} →\n  {α : ι → Type u_2} →\n    [inst : PartialOrder ι] →\n      [inst_1 : OrderBot ι] →\n        [inst_2 : (i : ι) → Preorder (α i)] → [inst_3 : OrderBot (α ⊥)] → OrderBot (Σₗ (i : ι), α i)", "name": "Sigma.Lex.orderBot", "isProp": false, "docString": "The lexicographical linear order on a sigma type. ", "terms": "[\n    \"lexicographical\",\n    \"linear order\",\n    \"sigma type\"\n]"}
{"type": "∀ {I : Type u} {f : I → Type v₁} [inst : DecidableEq I] [inst_1 : (i : I) → One (f i)] {i i' : I},\n  i ≠ i' → ∀ (x : f i), Pi.mulSingle i x i' = 1", "name": "Pi.mulSingle_eq_of_ne'", "isProp": true, "docString": "Abbreviation for `mulSingle_eq_of_ne h.symm`, for ease of use by `simp`. ", "terms": "[]"}
{"type": "∀ {G : Type u_1} [inst : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_1 : Group G] [inst_2 : MeasurableMul G]\n  [inst_3 : MeasureTheory.Measure.IsMulRightInvariant μ] (f : G → ENNReal) (g : G),\n  ∫⁻ (x : G), f (x * g) ∂μ = ∫⁻ (x : G), f x ∂μ", "name": "MeasureTheory.lintegral_mul_right_eq_self", "isProp": true, "docString": "Translating a function by right-multiplication does not change its Lebesgue integral\nwith respect to a right-invariant measure. ", "terms": "[\"Translating\", \"function\", \"right-multiplication\", \"Lebesgue integral\", \"right-invariant measure\"]"}
{"type": "(𝕜 : Type u_1) → {E : Type u_3} → [inst : SeminormedRing 𝕜] → [inst : SMul 𝕜 E] → Set E → Set E → Prop", "name": "Absorbs", "isProp": false, "docString": "A set `A` absorbs another set `B` if `B` is contained in all scalings of `A` by elements of\nsufficiently large norm. ", "terms": "[\n    \"set\",\n    \"absorbs\",\n    \"contained\",\n    \"scalings\",\n    \"elements\",\n    \"norm\",\n    \"sufficiently large\"\n]"}
{"type": "∀ {β : Type u} {α : Type v} [inst : CommMonoid β] [inst_1 : DecidableEq α] (s : Finset α) {f : α → β} {a : α},\n  f a = 1 → (Finset.prod (Finset.erase s a) fun x => f x) = Finset.prod s fun x => f x", "name": "Finset.prod_erase", "isProp": true, "docString": "If a function applied at a point is 1, a product is unchanged by\nremoving that point, if present, from a `Finset`. ", "terms": "[\n    \"Function\",\n    \"Point\",\n    \"Product\",\n    \"Unchanged\",\n    \"Removing\",\n    \"Present\",\n    \"Finset\"\n]"}
{"type": "{R : Type u_1} →\n  {R₂ : Type u_3} →\n    {M : Type u_9} →\n      {M₂ : Type u_12} →\n        [inst : Semiring R] →\n          [inst_1 : Semiring R₂] →\n            [inst_2 : AddCommMonoid M] →\n              [inst_3 : AddCommMonoid M₂] →\n                [inst_4 : Module R M] →\n                  [inst_5 : Module R₂ M₂] →\n                    {τ₁₂ : R →+* R₂} → {F : Type u_20} → [sc : SemilinearMapClass F τ₁₂ M M₂] → F → Submodule R M", "name": "LinearMap.ker", "isProp": false, "docString": "The kernel of a linear map `f : M → M₂` is defined to be `comap f ⊥`. This is equivalent to the\nset of `x : M` such that `f x = 0`. The kernel is a submodule of `M`. ", "terms": "[\n  \"kernel\",\n  \"linear map\",\n  \"defined\",\n  \"comap\",\n  \"equivalent\",\n  \"set\",\n  \"submodule\"\n]"}
{"type": "∀ {X : Type u_1} {Y : Type u_2} [inst : ConditionallyCompleteLinearOrder X] [inst_1 : DenselyOrdered X]\n  [inst_2 : TopologicalSpace X] [inst_3 : OrderTopology X] [inst_4 : LinearOrder Y] [inst_5 : TopologicalSpace Y]\n  [inst_6 : OrderTopology Y] {f : X → Y} {a b : X} {l : Y},\n  a < b →\n    ContinuousOn f (Set.Ioo a b) →\n      Filter.Tendsto f (nhdsWithin a (Set.Ioi a)) (nhds l) →\n        Filter.Tendsto f (nhdsWithin b (Set.Iio b)) (nhds l) → ∃ c ∈ Set.Ioo a b, IsExtrOn f (Set.Ioo a b) c", "name": "exists_isExtrOn_Ioo_of_tendsto", "isProp": true, "docString": "If a function `f` is continuous on an open interval\nand tends to the same value at its endpoints, then it has an extremum on this open interval. ", "terms": "[\n  \"function\",\n  \"continuous\",\n  \"open interval\",\n  \"value\",\n  \"endpoints\",\n  \"extremum\"\n]"}
{"type": "∀ {α : Type u_1} {M : Type u_8} {N : Type u_10} [inst : AddZeroClass M] [inst_1 : AddCommMonoid N] {f g : α →₀ M}\n  {h : α → M → N},\n  (∀ (a : α), h a 0 = 0) →\n    (∀ (a : α) (b₁ b₂ : M), h a (b₁ + b₂) = h a b₁ + h a b₂) → Finsupp.sum (f + g) h = Finsupp.sum f h + Finsupp.sum g h", "name": "Finsupp.sum_add_index'", "isProp": true, "docString": "Taking the sum under `h` is an additive homomorphism of finsupps,if `h` is an additive\nhomomorphism. This is a more specific version of `finsupp.sum_add_index` with simpler\nhypotheses.", "terms": "[\n    \"sum\",\n    \"additive homomorphism\",\n    \"finsupps\",\n    \"finsupp.sum_add_index\",\n    \"hypotheses\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} {M : Type w} [inst : DecidableEq β] [inst_1 : Fintype α] [inst_2 : Fintype β] (f : α → β)\n  {w : α → M} {b : M} [inst_3 : LinearOrderedCancelAddCommMonoid M],\n  (Fintype.card β • b < Finset.sum Finset.univ fun x => w x) →\n    ∃ y, b < Finset.sum (Finset.filter (fun x => f x = y) Finset.univ) fun x => w x", "name": "Fintype.exists_lt_sum_fiber_of_nsmul_lt_sum", "isProp": true, "docString": "The pigeonhole principle for finitely many pigeons of different weights, strict inequality\nversion: there is a pigeonhole with the total weight of pigeons in it greater than `b` provided that\nthe total number of pigeonholes times `b` is less than the total weight of all pigeons. ", "terms": "[\n    \"Pigeonhole Principle\",\n    \"Finitely Many\",\n    \"Different Weights\",\n    \"Strict Inequality\",\n    \"Total Weight\",\n    \"Total Number\",\n    \"Times\",\n    \"Less Than\"\n]"}
{"type": "{X : Type u_6} → {Y : Type u_7} → [inst : Preorder X] → [inst_1 : Preorder Y] → X ↪o Y → X →o Y", "name": "OrderEmbedding.toOrderHom", "isProp": false, "docString": "Convert an `OrderEmbedding` to an `OrderHom`. ", "terms": "[\n  \"Convert\",\n  \"OrderEmbedding\", \n  \"OrderHom\"\n]"}
{"type": "{α : Type u_1} →\n  {δ : α → Sort v} →\n    [inst : DecidableEq α] →\n      (s : Finset α) → (a : α) → δ a → ((a : α) → a ∈ s → δ a) → (a' : α) → a' ∈ insert a s → δ a'", "name": "Finset.Pi.cons", "isProp": false, "docString": "Given a function `f` defined on a finset `s`, define a new function on the finset `s ∪ {a}`,\nequal to `f` on `s` and sending `a` to a given value `b`. This function is denoted\n`s.Pi.cons a b f`. If `a` already belongs to `s`, the new function takes the value `b` at `a`\nanyway. ", "terms": "[\n    \"function\",\n    \"defined\",\n    \"finset\",\n    \"new function\",\n    \"denoted\",\n    \"belongs\",\n    \"takes the value\"\n]"}
{"type": "{𝕜 : Type u_1} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type u_2} →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : NormedSpace 𝕜 E] →\n          {F : Type u_3} →\n            [inst_3 : NormedAddCommGroup F] →\n              [inst_4 : NormedSpace 𝕜 F] →\n                [inst_5 : CompleteSpace E] →\n                  (f : E → F) →\n                    {f' : E ≃L[𝕜] F} →\n                      {c : NNReal} →\n                        ApproximatesLinearOn f (↑f') Set.univ c →\n                          Subsingleton E ∨ c < ‖↑(ContinuousLinearEquiv.symm f')‖₊⁻¹ → E ≃ₜ F", "name": "ApproximatesLinearOn.toHomeomorph", "isProp": false, "docString": "A function `f` that approximates a linear equivalence on the whole space is a homeomorphism. ", "terms": "[\n    \"function\",\n    \"approximates\",\n    \"linear equivalence\",\n    \"whole space\",\n    \"homeomorphism\"\n]"}
{"type": "ℕ → (chars : List Char) → 0 < List.length chars → SlimCheck.SampleableExt Char", "name": "SlimCheck.Char.sampleable", "isProp": false, "docString": "This can be specialized into customized `SampleableExt Char` instances.\nThe resulting instance has `1 / length` chances of making an unrestricted choice of characters\nand it otherwise chooses a character from `chars` with uniform probabilities.  ", "terms": "[\"specialized\", \"SampleableExt\", \"instances\", \"length\", \"chances\", \"unrestricted choice\", \"characters\", \"chooses\", \"character\", \"uniform probabilities\"]"}
{"type": "∀ (k : Type u_1) [inst : DivisionRing k] {ι : Type u_4} (s : Finset ι),\n  Finset.centroidWeights k s = Function.const ι (↑(Finset.card s))⁻¹", "name": "Finset.centroidWeights_eq_const", "isProp": true, "docString": "`centroidWeights` equals a constant function. ", "terms": "[\"centroidWeights\", \"equals\", \"constant function\"]"}
{"type": "{M : Type u_3} →\n  {N : Type u_4} →\n    {P : Type u_5} →\n      [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → [inst_2 : AddZeroClass P] → (N →+ P) → (M →+ N) → M →+ P", "name": "AddMonoidHom.comp", "isProp": false, "docString": "Composition of additive monoid morphisms as an additive monoid morphism. ", "terms": "[\n    \"Composition\",\n    \"Additive Monoid\",\n    \"Morphisms\"\n]"}
{"type": "{R : Type u_1} →\n  [inst : CommRing R] →\n    (I : Ideal R) →\n      (M : Type u_2) → [inst_1 : AddCommGroup M] → [inst_2 : Module R M] → Submodule R ((n : ℕ) → M ⧸ I ^ n • ⊤)", "name": "adicCompletion", "isProp": false, "docString": "The completion of a module with respect to an ideal. This is not necessarily Hausdorff.\nIn fact, this is only complete if the ideal is finitely generated. ", "terms": "[\n  \"Completion\",\n  \"Module\",\n  \"Ideal\",\n  \"Hausdorff\",\n  \"Complete\",\n  \"Finitely Generated\"\n]"}
{"type": "{α : Type u_1} → [inst : DecidableEq α] → Equiv.Perm α → Prop", "name": "Equiv.Perm.IsSwap", "isProp": false, "docString": "`f.IsSwap` indicates that the permutation `f` is a transposition of two elements. ", "terms": "[\"permutation\", \"transposition\", \"elements\"]"}
{"type": "∀ {K : Type u_1} [inst : Field K] {Γ₀ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Γ₀] [hv : Valued K Γ₀],\n  CompletableTopField K", "name": "Valued.completable", "isProp": true, "docString": "A valued field is completable. ", "terms": "[\n    \"valued field\",\n    \"completable\"\n]"}
{"type": "{α : Type u} → {β : α → Type v} → EmptyCollection (AList β)", "name": "AList.instEmptyCollectionAList", "isProp": false, "docString": "The empty association list. ", "terms": "[\"empty\", \"association list\"]"}
{"type": "{R : Type u} →\n  [inst : Ring R] → {M N : ModuleCat R} → (f : M ⟶ N) → CategoryTheory.Limits.IsLimit (ModuleCat.kernelCone f)", "name": "ModuleCat.kernelIsLimit", "isProp": false, "docString": "The kernel of a linear map is a kernel in the categorical sense. ", "terms": "[\n  \"kernel\",\n  \"linear map\",\n  \"categorical sense\"\n]"}
{"type": "{F : Type u → Type u} → [inst : Functor F] → [q : QPF F] → Prop", "name": "QPF.SuppPreservation", "isProp": false, "docString": "does `abs` preserve `supp`? ", "terms": "[\"abs\", \"preserve\", \"supp\"]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {E : Type u₃} →\n          [inst_2 : CategoryTheory.Category.{v₃, u₃} E] →\n            (F : CategoryTheory.Functor C D) →\n              {G H : CategoryTheory.Functor D E} →\n                (G ≅ H) → (CategoryTheory.Functor.comp F G ≅ CategoryTheory.Functor.comp F H)", "name": "CategoryTheory.isoWhiskerLeft", "isProp": false, "docString": "If `α : G ≅ H` is a natural isomorphism then\n`iso_whisker_left F α : (F ⋙ G) ≅ (F ⋙ H)` has components `α.app (F.obj X)`.\n", "terms": "[\n    \"natural isomorphism\",\n    \"iso_whisker_left\",\n    \"components\",\n    \"app\",\n    \"obj\"\n]"}
{"type": "{α : Type u} → {σ : Type v} → DFA α σ → σ → α → σ", "name": "DFA.step", "isProp": false, "docString": "A transition function from state to state labelled by the alphabet. ", "terms": "[\n  \"Transition Function\",\n  \"State\",\n  \"Alphabet\"\n]"}
{"type": "∀ {α : Type u} [inst : PseudoEMetricSpace α] (δ : ℝ) {E₁ E₂ : Set α},\n  E₁ ⊆ E₂ → Metric.thickening δ E₁ ⊆ Metric.thickening δ E₂", "name": "Metric.thickening_subset_of_subset", "isProp": true, "docString": "The (open) thickening `Metric.thickening δ E` with a fixed thickening radius `δ` is\nan increasing function of the subset `E`. ", "terms": "[\n\"open\",\n\"thickening\",\n\"Metric.thickening\",\n\"fixed\",\n\"thickening radius\",\n\"increasing function\",\n\"subset\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {T : CategoryTheory.Monad C} →\n      (X : CategoryTheory.Monad.Algebra T) →\n        CategoryTheory.Limits.Cofork (CategoryTheory.Monad.FreeCoequalizer.topMap X)\n          (CategoryTheory.Monad.FreeCoequalizer.bottomMap X)", "name": "CategoryTheory.Monad.beckAlgebraCofork", "isProp": false, "docString": "Construct the Beck cofork in the category of algebras. This cofork is reflexive as well as a\ncoequalizer.\n", "terms": "[\n    \"Beck cofork\",\n    \"category\",\n    \"algebras\",\n    \"reflexive\",\n    \"coequalizer\"\n]"}
{"type": "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V},\n  x ≠ 0 → ∀ (r : ℝ), Orientation.oangle o x (x + r • (Orientation.rotation o ↑(Real.pi / 2)) x) = ↑(Real.arctan r)", "name": "Orientation.oangle_add_right_smul_rotation_pi_div_two", "isProp": true, "docString": "An angle in a right-angled triangle expressed using `arctan`, where one side is a multiple\nof a rotation of another by `π / 2`. ", "terms": "[\n    \"angle\",\n    \"right-angled triangle\",\n    \"arctan\",\n    \"side\",\n    \"multiple\",\n    \"rotation\",\n    \"π / 2\"\n]"}
{"type": "ℝ*", "name": "Hyperreal.epsilon", "isProp": false, "docString": "A sample infinitesimal hyperreal", "terms": "[\"sample\", \"infinitesimal\", \"hyperreal\"]"}
{"type": "{α : Type u_2} →\n  {β : Type u_3} →\n    [inst : CommMonoid α] → [inst_1 : CancelCommMonoid β] → {A : Set α} → {m n : ℕ} → m ≤ n → (A →*[n] β) → A →*[m] β", "name": "FreimanHom.toFreimanHom", "isProp": false, "docString": "`α →*[n] β` is naturally included in `A →*[m] β` for any `m ≤ n`. ", "terms": "[\n  \"→*\",\n  \"naturally included\",\n  \"≤\"\n]"}
{"type": "{M : Type uM} →\n  {N : Type uN} →\n    {P : Type uP} → {mM : AddZeroClass M} → {mN : AddZeroClass N} → {mP : AddCommMonoid P} → (M →+ N →+ P) → N →+ M →+ P", "name": "AddMonoidHom.flip", "isProp": false, "docString": "`flip` arguments of `f : M →+ N →+ P`", "terms": "[\n    \"flip\",\n    \"arguments\",\n    \"function\",\n    \"mapping\"\n]"}
{"type": "Lean.ParserDescr", "name": "PowerSeries.«termD⁄dX»", "isProp": false, "docString": "Abbreviation of `PowerSeries.derivative`, the formal derivative on `R⟦X⟧`.", "terms": "[\n  \"Abbreviation\",\n  \"PowerSeries.derivative\",\n  \"formal derivative\",\n  \"R⟦X⟧\"\n]"}
{"type": "{R : Type uR} →\n  {A₁ : Type uA₁} →\n    {A₂ : Type uA₂} →\n      [inst : CommSemiring R] →\n        [inst_1 : Semiring A₁] →\n          [inst_2 : Semiring A₂] → [inst_3 : Algebra R A₁] → [inst_4 : Algebra R A₂] → (A₁ ≃ₐ[R] A₂) → A₁ → A₂", "name": "AlgEquiv.Simps.apply", "isProp": false, "docString": "See Note [custom simps projection] ", "terms": "[]"}
{"type": "{α : Type v} → {d u l r : ℕ} → Matrix (Fin (u + d)) (Fin (l + r)) α → Matrix (Fin u) (Fin l) α", "name": "Matrix.subUpLeft", "isProp": false, "docString": "The top-left `u × l` part of a `(u+d) × (l+r)` matrix. ", "terms": "[\n    \"top-left\",\n    \"part\",\n    \"matrix\",\n    \"×\"\n]"}
{"type": "{D : Type u_1} →\n  {C : Type u_2} →\n    [inst : CategoryTheory.Groupoid D] →\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} C] →\n        [inst_2 : CategoryTheory.MonoidalCategory C] →\n          [inst_3 : CategoryTheory.MonoidalClosed C] → (F : CategoryTheory.Functor D C) → CategoryTheory.Closed F", "name": "CategoryTheory.Functor.closed", "isProp": false, "docString": "If `C` is a monoidal closed category and `D` is a groupoid, then every functor `F : D ⥤ C` is\nclosed in the functor category `F : D ⥤ C` with the pointwise monoidal structure. ", "terms": "[\n    \"monoidal closed category\",\n    \"groupoid\",\n    \"functor\",\n    \"functor category\",\n    \"pointwise monoidal structure\"\n]"}
{"type": "∀ {α : Type u} [inst : PseudoEMetricSpace α] {s : Set α}, Set.Nonempty s → EMetric.hausdorffEdist s ∅ = ⊤", "name": "EMetric.hausdorffEdist_empty", "isProp": true, "docString": "The Haudorff edistance to the empty set is infinite ", "terms": "[\n    \"Hausdorff distance\",\n    \"empty set\",\n    \"infinite\"\n]"}
{"type": "CategoryTheory.Limits.PreservesLimitsOfSize.{v, v, max u v, max u v, max (u + 1) (v + 1), max (u + 1) (v + 1)}\n  (CategoryTheory.forget₂ RingCatMax AddCommGroupCat)", "name": "RingCat.forget₂AddCommGroupPreservesLimitsOfSize", "isProp": false, "docString": "The forgetful functor from rings to additive commutative groups preserves all limits.\n", "terms": "[\n  \"forgetful functor\",\n  \"rings\",\n  \"additive commutative groups\",\n  \"preserves\",\n  \"limits\"\n]"}
{"type": "{α : Type u_1} → [inst : DecidableEq α] → (l : List α) → (∀ (x : α), x ∈ l) → Fintype α", "name": "Fintype.ofList", "isProp": false, "docString": "Construct a proof of `Fintype α` from a universal list ", "terms": "[\n  \"Construct\",\n  \"Proof\",\n  \"Fintype\",\n  \"Universal list\"\n]"}
{"type": "Filter.Tendsto (fun n => ↑n / (2 * ↑n + 1)) Filter.atTop (nhds (1 / 2))", "name": "Stirling.tendsto_self_div_two_mul_self_add_one", "isProp": true, "docString": "The sequence `n / (2 * n + 1)` tends to `1/2` ", "terms": "[\"sequence\", \"tends\"]"}
{"type": "{B : Type u₁} →\n  [inst : CategoryTheory.Bicategory B] →\n    {C : Type u₂} →\n      [inst_1 : CategoryTheory.Bicategory C] → CategoryTheory.OplaxFunctor B C → CategoryTheory.PrelaxFunctor B C", "name": "CategoryTheory.OplaxFunctor.toPrelaxFunctor", "isProp": false, "docString": "The prelax functor between the underlying quivers. ", "terms": "[\n    \"prelax functor\",\n    \"underlying\",\n    \"quivers\"\n]"}
{"type": "∀ {α : Type u} {ι : Type u_5} {σ : ι → Type u_7} [inst : (i : ι) → TopologicalSpace (σ i)] [inst_1 : TopologicalSpace α]\n  {f : Sigma σ → α}, (∀ (i : ι), Continuous fun a => f { fst := i, snd := a }) → Continuous f", "name": "continuous_sigma", "isProp": true, "docString": "A map out of a sum type is continuous if its restriction to each summand is. ", "terms": "[\n    \"Map\",\n    \"Sum type\",\n    \"Continuous\",\n    \"Restriction\",\n    \"Summand\"\n]"}
{"type": "{K : Type u} →\n  [inst : Field K] → (A : ValuationSubring K) → (P : Ideal ↥A) → [inst_1 : Ideal.IsPrime P] → ValuationSubring K", "name": "ValuationSubring.ofPrime", "isProp": false, "docString": "The coarsening of a valuation ring associated to a prime ideal. ", "terms": "[\n    \"Coarsening\",\n    \"Valuation ring\",\n    \"Associated\",\n    \"Prime ideal\"\n]"}
{"type": "{J : Type w} →\n  {C : Type uC} →\n    [inst : CategoryTheory.Category.{uC', uC} C] →\n      [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n        {D : Type uD} →\n          [inst_2 : CategoryTheory.Category.{uD', uD} D] →\n            [inst_3 : CategoryTheory.Limits.HasZeroMorphisms D] →\n              (F : J → C) →\n                (G : CategoryTheory.Functor C D) →\n                  [inst_4 : CategoryTheory.Functor.PreservesZeroMorphisms G] →\n                    CategoryTheory.Functor (CategoryTheory.Limits.Bicone F) (CategoryTheory.Limits.Bicone (G.obj ∘ F))", "name": "CategoryTheory.Limits.Bicones.functoriality", "isProp": false, "docString": "A functor `G : C ⥤ D` sends bicones over `F` to bicones over `G.obj ∘ F` functorially. ", "terms": "[\n  \"functor\",\n  \"bicones\",\n  \"object\",\n  \"composition\",\n  \"functorially\"\n]"}
{"type": "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V},\n  x ≠ y → ‖x‖ = ‖y‖ → Orientation.oangle o y x = ↑Real.pi - 2 • Orientation.oangle o (y - x) y", "name": "Orientation.oangle_eq_pi_sub_two_zsmul_oangle_sub_of_norm_eq", "isProp": true, "docString": "The angle at the apex of an isosceles triangle is `π` minus twice a base angle, oriented\nvector angle form. ", "terms": "[\n    \"angle\",\n    \"apex\",\n    \"isosceles triangle\",\n    \"π\",\n    \"minus\",\n    \"twice\",\n    \"base angle\",\n    \"oriented\",\n    \"vector\",\n    \"angle form\"\n]"}
{"type": "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α → β → γ) → Option α → Option β → Option γ", "name": "Option.map₂", "isProp": false, "docString": "The image of a binary function `f : α → β → γ` as a function `Option α → Option β → Option γ`.\nMathematically this should be thought of as the image of the corresponding function `α × β → γ`. ", "terms": "[\n  \"image\",\n  \"binary function\",\n  \"function\",\n  \"Option\",\n  \"corresponding function\"\n]"}
{"type": "Simps.ParsedProjectionData → Lean.Name", "name": "Simps.ParsedProjectionData.strName", "isProp": false, "docString": "name for this projection used in the structure definition ", "terms": "[]"}
{"type": "{α : Type u} → Computation (Computation α) → Computation α", "name": "Computation.join", "isProp": false, "docString": "Flatten a computation of computations into a single computation. ", "terms": "[\"flatten\", \"computation\", \"single\"]"}
{"type": "Lean.ParserDescr", "name": "precMax", "isProp": false, "docString": "Maximum precedence used in term parsers, in particular for terms in\nfunction position (`ident`, `paren`, ...)\n", "terms": "[]\n"}
{"type": "∀ {M : Type u_3} {N : Type u_4} [inst : Preorder M] [inst_1 : Add M] [inst_2 : Sub M] [inst_3 : OrderedSub M]\n  [inst_4 : PartialOrder N] [inst_5 : Add N] [inst_6 : Sub N] [inst_7 : OrderedSub N] (e : M ≃o N),\n  (∀ (a b : M), e (a + b) = e a + e b) → ∀ (a b : M), e (a - b) = e a - e b", "name": "OrderIso.map_tsub", "isProp": true, "docString": "An order isomorphism between types with ordered subtraction preserves subtraction provided that\nit preserves addition. ", "terms": "[\n    \"order isomorphism\",\n    \"types\",\n    \"ordered subtraction\",\n    \"preserves\",\n    \"subtraction\",\n    \"addition\"\n]"}
{"type": "pointedToBipointedSnd ⊣ bipointedToPointedSnd", "name": "pointedToBipointedSndBipointedToPointedSndAdjunction", "isProp": false, "docString": "The free/forgetful adjunction between `PointedToBipointed_snd` and `BipointedToPointed_snd`.\n", "terms": "[\n    \"free/forgetful adjunction\",\n    \"PointedToBipointed_snd\",\n    \"BipointedToPointed_snd\"\n]"}
{"type": "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b : α}, 1 < a → 1 < b → 1 < a * b", "name": "Left.one_lt_mul'", "isProp": true, "docString": "Assumes left covariance.\nThe lemma assuming right covariance is `Right.one_lt_mul'`. ", "terms": "[\"left covariance\", \"lemma\", \"right covariance\", \"one_lt_mul\"]"}
{"type": "{𝕜 : Type u_1} →\n  {V : Type u_2} →\n    [inst : NormedField 𝕜] →\n      [inst_1 : AddCommGroup V] → [inst_2 : Module 𝕜 V] → (e : ENorm 𝕜 V) → NormedAddCommGroup ↥(ENorm.finiteSubspace e)", "name": "ENorm.normedAddCommGroup", "isProp": false, "docString": "Normed group instance on `e.finiteSubspace`. ", "terms": "[\n    \"Normed group\",\n    \"instance\",\n    \"finiteSubspace\"\n]"}
{"type": "{B : Type u_2} →\n  {F : Type u_3} →\n    {Z : Type u_5} →\n      [inst : TopologicalSpace B] →\n        [inst_1 : TopologicalSpace F] →\n          {proj : Z → B} →\n            [inst_2 : TopologicalSpace Z] →\n              [inst_3 : LinearOrder B] →\n                [inst_4 : OrderTopology B] →\n                  (e e' : Trivialization F proj) → (a : B) → a ∈ e.baseSet → a ∈ e'.baseSet → Trivialization F proj", "name": "Trivialization.piecewiseLe", "isProp": false, "docString": "Given two bundle trivializations `e`, `e'` of a topological fiber bundle `proj : Z → B` over a\nlinearly ordered base `B` and a point `a ∈ e.baseSet ∩ e'.baseSet`, `e.piecewise_le e' a He He'`\nis the bundle trivialization over `Set.ite (Iic a) e.baseSet e'.baseSet` that is equal to `e` on\npoints `p` such that `proj p ≤ a` and is equal to `((e' p).1, h (e' p).2)` otherwise, where\n`h = e'.coord_change_homeomorph e _ _` is the homeomorphism of the fiber such that\n`h (e' p).2 = (e p).2` whenever `e p = a`. ", "terms": "[\n    \"bundle trivializations\",\n    \"topological fiber bundle\",\n    \"linearly ordered base\",\n    \"point\",\n    \"bundle trivialization\",\n    \"Set.ite\",\n    \"Iic\",\n    \"homeomorphism\",\n    \"fiber\"\n]"}
{"type": "{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {K : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} K] →\n        {C : Type u₃} →\n          [inst_2 : CategoryTheory.Category.{v₃, u₃} C] →\n            {F : CategoryTheory.Functor J C} →\n              {D : Type u₄} →\n                [inst_3 : CategoryTheory.Category.{v₄, u₄} D] →\n                  {G : CategoryTheory.Functor K D} →\n                    (h : CategoryTheory.Functor (CategoryTheory.Limits.Cone G) (CategoryTheory.Limits.Cone F)) →\n                      [inst_4 : CategoryTheory.IsRightAdjoint h] →\n                        {c : CategoryTheory.Limits.Cone G} →\n                          CategoryTheory.Limits.IsLimit c → CategoryTheory.Limits.IsLimit (h.obj c)", "name": "CategoryTheory.Limits.IsLimit.ofRightAdjoint", "isProp": false, "docString": "Given a right adjoint functor between categories of cones,\nthe image of a limit cone is a limit cone.\n", "terms": "[\n    \"right adjoint functor\",\n    \"categories\",\n    \"cones\",\n    \"image\",\n    \"limit cone\"\n]"}
{"type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] (X Y : C) [inst_3 : CategoryTheory.Limits.HasBinaryBiproduct X Y],\n  CategoryTheory.IsPushout CategoryTheory.Limits.biprod.inr 0 CategoryTheory.Limits.biprod.fst 0", "name": "CategoryTheory.IsPushout.inr_fst", "isProp": true, "docString": "The square\n```\n  Y --inr--> X ⊞ Y\n  |            |\n  0           fst\n  |            |\n  v            v\n  0 ---0-----> X\n```\nis a pushout square.\n", "terms": "[\"square\", \"inr\", \"X\", \"Y\", \"0\", \"fst\", \"pushout square\"]"}
{"type": "∀ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (p : P), Function.Injective fun x => p -ᵥ x", "name": "vsub_right_injective", "isProp": true, "docString": "Subtracting a point from the point `p` is an injective\nfunction. ", "terms": "[\"Subtracting\", \"point\", \"injective\", \"function\"]"}
{"type": "{α : Type u_1} → (o : Ordinal.{u_4}) → ((a : Ordinal.{u_4}) → a < o → α) → (Quotient.out o).α → α", "name": "Ordinal.familyOfBFamily", "isProp": false, "docString": "Converts a family indexed by an `Ordinal.{u}` to one indexed by a `Type u` using a well-ordering\ngiven by the axiom of choice. ", "terms": "[\n  \"Converts\",\n  \"family\",\n  \"indexed\",\n  \"Ordinal\",\n  \"one\",\n  \"Type\",\n  \"well-ordering\",\n  \"axiom of choice\"\n]"}
{"type": "Type → Type u_1 → Type u_1", "name": "RandG", "isProp": false, "docString": "A monad to generate random objects using the generator type `g`.  ", "terms": "[\"monad\", \"generate\", \"random objects\", \"generator type\"]"}
{"type": "∀ {Ω : Type u_1} {ι : Type u_2} {L : Filter ι} [inst : MeasurableSpace Ω] [inst_1 : TopologicalSpace Ω]\n  [inst_2 : HasOuterApproxClosed Ω] [inst_3 : OpensMeasurableSpace Ω] {μ : MeasureTheory.FiniteMeasure Ω}\n  {μs : ι → MeasureTheory.FiniteMeasure Ω},\n  Filter.Tendsto μs L (nhds μ) → ∀ {F : Set Ω}, IsClosed F → Filter.limsup (fun i => ↑↑↑(μs i) F) L ≤ ↑↑↑μ F", "name": "MeasureTheory.FiniteMeasure.limsup_measure_closed_le_of_tendsto", "isProp": true, "docString": "One implication of the portmanteau theorem:\nWeak convergence of finite measures implies that the limsup of the measures of any closed set is\nat most the measure of the closed set under the limit measure.\n", "terms": "[\n    \"implication\",\n    \"portmanteau theorem\",\n    \"weak convergence\",\n    \"finite measures\",\n    \"limsup\",\n    \"measures\",\n    \"closed set\",\n    \"measure\",\n    \"limit measure\"\n]"}
{"type": "{α : Type u_2} → (β : α → Type u_1) → (i : α) ×' β i ≃ (i : α) × β i", "name": "Equiv.psigmaEquivSigma", "isProp": false, "docString": "A `PSigma`-type is equivalent to the corresponding `Sigma`-type. ", "terms": "[\n    \"PSigma-type\",\n    \"equivalent\",\n    \"corresponding\",\n    \"Sigma-type\"\n]"}
{"type": "Lean.TrailingParserDescr", "name": "«term_[Λ^_]→ₗ[_]_»", "isProp": false, "docString": "An alternating map is a multilinear map that vanishes when two of its arguments are equal.\n", "terms": "[\n  \"alternating map\",\n  \"multilinear map\",\n  \"vanishes\",\n  \"arguments\",\n  \"equal\"\n]"}
{"type": "∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : OrderedCommGroup α] [inst_1 : OrderedCommGroup β] {s : Set ι}\n  {f : ι → α} {g : ι → β}, MonovaryOn f g s → MonovaryOn f⁻¹ g⁻¹ s", "name": "MonovaryOn.inv", "isProp": true, "docString": "**Alias** of the reverse direction of `monovaryOn_inv`.", "terms": "[\"Alias\", \"reverse direction\", \"monovaryOn_inv\"]"}
{"type": "{R : Type u_2} →\n  {M₁ : Type u_4} →\n    {M₂ : Type u_5} →\n      {M₃ : Type u_6} →\n        [inst : CommSemiring R] →\n          [inst_1 : AddCommMonoid M₁] →\n            [inst_2 : AddCommMonoid M₂] →\n              [inst_3 : AddCommMonoid M₃] →\n                [inst_4 : Module R M₁] →\n                  [inst_5 : Module R M₂] →\n                    [inst_6 : Module R M₃] →\n                      {Q₁ : QuadraticForm R M₁} →\n                        {Q₂ : QuadraticForm R M₂} → {Q₃ : QuadraticForm R M₃} → (Q₂ →qᵢ Q₃) → (Q₁ →qᵢ Q₂) → Q₁ →qᵢ Q₃", "name": "QuadraticForm.Isometry.comp", "isProp": false, "docString": "The composition of two isometries between quadratic forms. ", "terms": "[\n    \"composition\",\n    \"isometries\",\n    \"quadratic forms\"\n]"}
{"type": "∀ {α : Type u} [inst : LinearOrder α], (∀ ⦃x y z : α⦄, x < y → y < z → False) → Finite α", "name": "Finite.of_forall_not_lt_lt", "isProp": true, "docString": "If a linear order does not contain any triple of elements `x < y < z`, then this type\nis finite. ", "terms": "[\n    \"linear order\",\n    \"contain\",\n    \"triple of elements\",\n    \"finite\",\n    \"type\"\n]"}
{"type": "∀ {α : Type u_1} [inst : MetricSpace α] {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} (v : VitaliFamily μ)\n  [inst_1 : SecondCountableTopology α] [inst_2 : BorelSpace α] [inst_3 : MeasureTheory.IsLocallyFiniteMeasure μ]\n  {ρ : MeasureTheory.Measure α} [inst_4 : MeasureTheory.IsLocallyFiniteMeasure ρ],\n  MeasureTheory.Measure.AbsolutelyContinuous ρ μ →\n    ∀ {p q : NNReal},\n      p < q →\n        ∃ a b,\n          MeasurableSet a ∧\n            MeasurableSet b ∧\n              {x | VitaliFamily.limRatio v ρ x < ↑p} ⊆ a ∧ {x | ↑q < VitaliFamily.limRatio v ρ x} ⊆ b ∧ ↑↑μ (a ∩ b) = 0", "name": "VitaliFamily.exists_measurable_supersets_limRatio", "isProp": true, "docString": "Given two thresholds `p < q`, the sets `{x | v.limRatio ρ x < p}`\nand `{x | q < v.limRatio ρ x}` are obviously disjoint. The key to proving that `v.limRatio ρ` is\nalmost everywhere measurable is to show that these sets have measurable supersets which are also\ndisjoint, up to zero measure. This is the content of this lemma. ", "terms": "[\n    \"thresholds\",\n    \"sets\",\n    \"disjoint\",\n    \"proving\",\n    \"almost everywhere measurable\",\n    \"measurable supersets\",\n    \"zero measure\",\n    \"lemma\"\n]"}
{"type": "Lean.ParserDescr", "name": "Tactic.Elementwise.elementwise", "isProp": false, "docString": "The `elementwise` attribute can be added to a lemma proving an equation of morphisms, and it\ncreates a new lemma for a `ConcreteCategory` giving an equation with those morphisms applied\nto some value.\n\nSyntax examples:\n- `@[elementwise]`\n- `@[elementwise nosimp]` to not use `simp` on both sides of the generated lemma\n- `@[elementwise (attr := simp)]` to apply the `simp` attribute to both the generated lemma and\n  the original lemma.\n\nExample application of `elementwise`:\n\n```lean\n@[elementwise]\nlemma some_lemma {C : Type*} [Category C]\n    {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z) (h : X ⟶ Z) (w : ...) : f ≫ g = h := ...\n```\n\nproduces\n\n```lean\nlemma some_lemma_apply {C : Type*} [Category C]\n    {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z) (h : X ⟶ Z) (w : ...)\n    [ConcreteCategory C] (x : X) : g (f x) = h x := ...\n```\n\nHere `X` is being coerced to a type via `CategoryTheory.ConcreteCategory.hasCoeToSort` and\n`f`, `g`, and `h` are being coerced to functions via `CategoryTheory.ConcreteCategory.hasCoeToFun`.\nFurther, we simplify the type using `CategoryTheory.coe_id : ((𝟙 X) : X → X) x = x` and\n`CategoryTheory.coe_comp : (f ≫ g) x = g (f x)`,\nreplacing morphism composition with function composition.\n\nThe `[ConcreteCategory C]` argument will be omitted if it is possible to synthesize an instance.\n\nThe name of the produced lemma can be specified with `@[elementwise other_lemma_name]`.\nIf `simp` is added first, the generated lemma will also have the `simp` attribute.\n ", "terms": "[\"elementwise\", \"lemma\", \"equation\", \"morphisms\", \"ConcreteCategory\", \"simp\", \"attribute\", \"Category\", \"Type\", \"morphism composition\", \"function composition\", \"ConcreteCategory.hasCoeToSort\", \"ConcreteCategory.hasCoeToFun\", \"CategoryTheory.coe_id\", \"CategoryTheory.coe_comp\"]"}
{"type": "CategoryTheory.Limits.WalkingCospan.right ⟶ CategoryTheory.Limits.WalkingCospan.one", "name": "CategoryTheory.Limits.WalkingCospan.Hom.inr", "isProp": false, "docString": "The right arrow of the walking cospan. ", "terms": "[\n    \"Right arrow\",\n    \"Walking cospan\"\n]"}
{"type": "(n : ℕ) → Type u → MvPFunctor.{u} n", "name": "MvPFunctor.const", "isProp": false, "docString": "Constant functor where the input object does not affect the output ", "terms": "[\n  \"Constant functor\",\n  \"Input object\",\n  \"Output\"\n]"}
{"type": "(𝕜 : Type u_1) →\n  (E : Type u_4) →\n    (F : Type u_5) →\n      [inst : NormedAddCommGroup E] →\n        [inst_1 : NormedSpace ℝ E] →\n          [inst_2 : NormedAddCommGroup F] →\n            [inst_3 : NormedSpace ℝ F] →\n              [inst_4 : IsROrC 𝕜] →\n                [inst_5 : NormedSpace 𝕜 F] →\n                  [inst_6 : SMulCommClass ℝ 𝕜 F] → SchwartzMap E F →L[𝕜] BoundedContinuousFunction E F", "name": "SchwartzMap.toBoundedContinuousFunctionCLM", "isProp": false, "docString": "The inclusion map from Schwartz functions to bounded continuous functions as a continuous linear\nmap. ", "terms": "[\n    \"Inclusion map\",\n    \"Schwartz functions\",\n    \"Bounded continuous functions\",\n    \"Continuous linear map\"\n]"}
{"type": "(C : Type u_1) →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] → [inst_1 : CategoryTheory.Precoherent C] → CategoryTheory.Coverage C", "name": "CategoryTheory.coherentCoverage", "isProp": false, "docString": "The coherent coverage on a precoherent category `C`.\n", "terms": "[\"coherent coverage\", \"precoherent category\"]"}
{"type": "{δ' : Type u_5} →\n  (π : δ' → Type u_6) → [inst : (x : δ') → MeasurableSpace (π x)] → [inst_1 : Unique δ'] → ((i : δ') → π i) ≃ᵐ π default", "name": "MeasurableEquiv.piUnique", "isProp": false, "docString": "The measurable equivalence `(∀ i, π i) ≃ᵐ π ⋆` when the domain of `π` only contains `⋆` ", "terms": "[\n  \"measurable equivalence\",\n  \"domain\"\n]"}
{"type": "Complex.Gamma 0 = 0", "name": "Complex.Gamma_zero", "isProp": true, "docString": "At `0` the Gamma function is undefined; by convention we assign it the value `0`. ", "terms": "[\"Gamma function\", \"undefined\", \"convention\", \"value\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroObject C] →\n      [inst_2 : CategoryTheory.HasShift C ℤ] →\n        [inst_3 : CategoryTheory.Preadditive C] →\n          [inst_4 : ∀ (n : ℤ), CategoryTheory.Functor.Additive (CategoryTheory.shiftFunctor C n)] →\n            [hC : CategoryTheory.Pretriangulated C] →\n              (T₁ T₂ : CategoryTheory.Pretriangulated.Triangle C) →\n                T₁ ∈ CategoryTheory.Pretriangulated.distinguishedTriangles →\n                  T₂ ∈ CategoryTheory.Pretriangulated.distinguishedTriangles →\n                    (a : T₁.obj₁ ⟶ T₂.obj₁) →\n                      (b : T₁.obj₂ ⟶ T₂.obj₂) →\n                        CategoryTheory.CategoryStruct.comp T₁.mor₁ b = CategoryTheory.CategoryStruct.comp a T₂.mor₁ →\n                          (T₁ ⟶ T₂)", "name": "CategoryTheory.Pretriangulated.completeDistinguishedTriangleMorphism", "isProp": false, "docString": "A chosen extension of a commutative square into a morphism of distinguished triangles. ", "terms": "[\n    \"extension\",\n    \"commutative square\",\n    \"morphism\",\n    \"distinguished triangles\"\n]"}
{"type": "{n : ℕ} → { f // ∀ (a b : PSet.Resp n), PSet.Resp.Equiv a b → f a = f b }", "name": "PSet.Resp.evalAux", "isProp": false, "docString": "Helper function for `PSet.eval`. ", "terms": "[]"}
{"type": "(F : Type u) → [inst : Field F] → RatFunc F →ₐ[Polynomial F] LaurentSeries F", "name": "RatFunc.coeAlgHom", "isProp": false, "docString": "The coercion `RatFunc F → LaurentSeries F` as bundled alg hom. ", "terms": "[\n    \"Coercion\",\n    \"RatFunc\",\n    \"LaurentSeries\",\n    \"Bundled\",\n    \"Alg\",\n    \"Hom\"\n]"}
{"type": "{τ : Type u_1} →\n  [inst : AddCommGroup τ] →\n    [inst_1 : TopologicalSpace τ] →\n      [inst_2 : TopologicalAddGroup τ] → {α : Type u_2} → [inst_3 : TopologicalSpace α] → Flow τ α → Flow τ α", "name": "Flow.reverse", "isProp": false, "docString": "The time-reversal of a flow `ϕ` by a (commutative, additive) group\nis defined `ϕ.reverse t x = ϕ (-t) x`. ", "terms": "[\n  \"time-reversal\",\n  \"flow\",\n  \"commutative\",\n  \"additive\",\n  \"group\",\n  \"defined\",\n  \"reverse\"\n]"}
{"type": "{G : Type u_1} → [inst : Group G] → {M : Type u_7} → [inst_1 : Monoid M] → (G →* M) → (G →* M) → Subgroup G", "name": "MonoidHom.eqLocus", "isProp": false, "docString": "The subgroup of elements `x : G` such that `f x = g x` ", "terms": "[\n    \"subgroup\",\n    \"elements\",\n    \"such that\",\n    \"equals\"\n]"}
{"type": "∀ {α : Type u_1} [inst : PseudoEMetricSpace α] {f : ℕ → α} (d : ℕ → ENNReal),\n  (∀ (n : ℕ), edist (f n) (f (Nat.succ n)) ≤ d n) →\n    ∀ {a : α}, Filter.Tendsto f Filter.atTop (nhds a) → edist (f 0) a ≤ ∑' (m : ℕ), d m", "name": "edist_le_tsum_of_edist_le_of_tendsto₀", "isProp": true, "docString": "If `edist (f n) (f (n+1))` is bounded above by a function `d : ℕ → ℝ≥0∞`,\nthen the distance from `f 0` to the limit is bounded by `∑'_{k=0}^∞ d k`. ", "terms": "[\n  \"edist\",\n  \"bounded above\",\n  \"function\",\n  \"ℕ\",\n  \"ℝ≥0∞\",\n  \"distance\",\n  \"limit\",\n  \"bounded\",\n  \"∑'_{k=0}^∞\",\n  \"d k\"\n]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_5, u_1} C] →\n    {D : Type u_2} →\n      [inst_1 : CategoryTheory.Category.{u_6, u_2} D] →\n        {K : CategoryTheory.GrothendieckTopology D} →\n          {G : CategoryTheory.Functor C D} →\n            [inst_2 : CategoryTheory.Functor.IsCoverDense G K] →\n              [inst_3 : CategoryTheory.Full G] →\n                {ℱ : CategoryTheory.Functor Dᵒᵖ (Type v)} →\n                  {ℱ' : CategoryTheory.SheafOfTypes K} →\n                    (CategoryTheory.Functor.comp G.op ℱ ⟶ CategoryTheory.Functor.comp G.op ℱ'.val) →\n                      (X : D) → ℱ.obj (Opposite.op X) ⟶ ℱ'.val.obj (Opposite.op X)", "name": "CategoryTheory.Functor.IsCoverDense.Types.appHom", "isProp": false, "docString": "(Implementation). The morphism `ℱ(X) ⟶ ℱ'(X)` given by gluing the `pushforwardFamily`. ", "terms": "[\"Implementation\", \"morphism\", \"gluing\", \"pushforwardFamily\"]"}
{"type": "(α : Type u_4) → [inst : LinearOrderedRing α] → (floor : α → ℤ) → GaloisConnection Int.cast floor → FloorRing α", "name": "FloorRing.ofFloor", "isProp": false, "docString": "A `FloorRing` constructor from the `floor` function alone. ", "terms": "[\n    \"FloorRing\",\n    \"constructor\",\n    \"floor function\"\n]"}
{"type": "{α : Type u} → [inst : Group α] → CompleteSemilatticeInf (GroupTopology α)", "name": "GroupTopology.instCompleteSemilatticeInfGroupTopology", "isProp": false, "docString": "Group topologies on `γ` form a complete lattice, with `⊥` the discrete topology and `⊤` the\nindiscrete topology.\n\nThe infimum of a collection of group topologies is the topology generated by all their open sets\n(which is a group topology).\n\nThe supremum of two group topologies `s` and `t` is the infimum of the family of all group\ntopologies contained in the intersection of `s` and `t`. ", "terms": "[\n    \"Group topologies\",\n    \"complete lattice\",\n    \"discrete topology\",\n    \"indiscrete topology\",\n    \"infimum\",\n    \"collection\",\n    \"topology\",\n    \"generated\",\n    \"open sets\",\n    \"group topology\",\n    \"supremum\",\n    \"family\",\n    \"intersection\",\n    \"contained\"\n]"}
{"type": "Type u_1 → (Λ : Type u_2) → [inst : Inhabited Λ] → Type (max (max u_1 u_2) u_1 u_2)", "name": "Turing.TM0.Machine", "isProp": false, "docString": "A Post-Turing machine with symbol type `Γ` and label type `Λ`\nis a function which, given the current state `q : Λ` and\nthe tape head `a : Γ`, either halts (returns `none`) or returns\na new state `q' : Λ` and a `Stmt` describing what to do,\neither a move left or right, or a write command.\n\nBoth `Λ` and `Γ` are required to be inhabited; the default value\nfor `Γ` is the \"blank\" tape value, and the default value of `Λ` is\nthe initial state. ", "terms": "[\"Post-Turing machine\", \"symbol type\", \"label type\", \"function\", \"current state\", \"tape head\", \"halts\", \"new state\", \"Stmt\", \"move left\", \"move right\", \"write command\", \"inhabited\", \"default value\", \"blank\", \"initial state\"]"}
{"type": "∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] {a b c d : α} (h : a ≤ b),\n  |↑(Set.projIcc a b h c) - ↑(Set.projIcc a b h d)| ≤ |c - d|", "name": "Set.abs_projIcc_sub_projIcc", "isProp": true, "docString": "`Set.projIcc` is a contraction. ", "terms": "[\"Set\", \"projIcc\", \"contraction\"]"}
{"type": "{α : Type u} →\n  {β : Type v} → [inst : MulOneClass α] → [inst_1 : AddZeroClass β] → (α →* Multiplicative β) ≃ (Additive α →+ β)", "name": "MonoidHom.toAdditive'", "isProp": false, "docString": "Reinterpret `α →* Multiplicative β` as `Additive α →+ β`. ", "terms": "[\"Reinterpret\", \"Multiplicative\", \"Additive\"]"}
{"type": "{t : Type u → Type u} →\n  [self : Traversable t] → {m : Type u → Type u} → [inst : Applicative m] → {α β : Type u} → (α → m β) → t α → m (t β)", "name": "Traversable.traverse", "isProp": false, "docString": "The function commuting a traversable functor `t` with an arbitrary applicative functor `m`. ", "terms": "[\n    \"function\",\n    \"commuting\",\n    \"traversable\",\n    \"functor\",\n    \"arbitrary\",\n    \"applicative\",\n    \"functor\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {J : Type w} →\n          [inst_2 : CategoryTheory.Category.{w', w} J] →\n            {K : CategoryTheory.Functor J C} →\n              {F : CategoryTheory.Functor C D} →\n                {c : CategoryTheory.Limits.Cocone (CategoryTheory.Functor.comp K F)} →\n                  (self : CategoryTheory.LiftableCocone K F c) → F.mapCocone self.liftedCocone ≅ c", "name": "CategoryTheory.LiftableCocone.validLift", "isProp": false, "docString": "the isomorphism expressing that `liftedCocone` lifts the given cocone ", "terms": "[\n    \"Isomorphism\",\n    \"LiftedCocone\",\n    \"Cocone\"\n]"}
{"type": "{n : ℕ} → Fin n → Fin (n + 1) → Fin n", "name": "Fin.predAbove", "isProp": false, "docString": "`predAbove p i` embeds `i : Fin (n+1)` into `Fin n` by subtracting one if `p < i`. ", "terms": "[\n    \"embeds\",\n    \"Fin\",\n    \"subtracting\",\n    \"one\",\n    \"<\"\n]"}
{"type": "(R : Type u_1) →\n  {B : Type u_2} →\n    {F : Type u_3} →\n      {E : B → Type u_4} →\n        [inst : Semiring R] →\n          [inst_1 : TopologicalSpace F] →\n            [inst_2 : TopologicalSpace B] →\n              [inst_3 : TopologicalSpace (Bundle.TotalSpace F E)] →\n                [inst_4 : AddCommMonoid F] →\n                  [inst_5 : Module R F] →\n                    [inst_6 : (x : B) → AddCommMonoid (E x)] →\n                      [inst_7 : (x : B) → Module R (E x)] →\n                        (e e' : Trivialization F Bundle.TotalSpace.proj) →\n                          [inst_8 : Trivialization.IsLinear R e] →\n                            [inst_9 : Trivialization.IsLinear R e'] → B → F ≃L[R] F", "name": "Trivialization.coordChangeL", "isProp": false, "docString": "A coordinate change function between two trivializations, as a continuous linear equivalence.\nDefined to be the identity when `b` does not lie in the base set of both trivializations. ", "terms": "[\n    \"coordinate change function\",\n    \"trivializations\",\n    \"continuous\",\n    \"linear equivalence\",\n    \"identity\",\n    \"base set\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {F : CategoryTheory.Functor CategoryTheory.Limits.WalkingSpan C} →\n      (t : CategoryTheory.Limits.Cocone F) →\n        (CategoryTheory.Limits.Cocones.precompose (CategoryTheory.Limits.diagramIsoSpan F).inv).obj t ≅\n          CategoryTheory.Limits.PushoutCocone.mk (t.ι.app CategoryTheory.Limits.WalkingSpan.left)\n            (t.ι.app CategoryTheory.Limits.WalkingSpan.right)\n            (_ :\n              CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingSpan.Hom.fst)\n                  (t.ι.app CategoryTheory.Limits.WalkingSpan.left) =\n                CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingSpan.Hom.snd)\n                  (t.ι.app CategoryTheory.Limits.WalkingSpan.right))", "name": "CategoryTheory.Limits.PushoutCocone.isoMk", "isProp": false, "docString": "A diagram `WalkingSpan ⥤ C` is isomorphic to some `PushoutCocone.mk` after composing with\n`diagramIsoSpan`. ", "terms": "[\n    \"Diagram\",\n    \"Isomorphic\",\n    \"Pushout Cocone\",\n    \"Composing\",\n    \"Diagram Iso Span\"\n]"}
{"type": "∀ {G₀ : Type u_4} [inst : Zero G₀] [inst_1 : Inv G₀] [inst_2 : TopologicalSpace G₀] [self : HasContinuousInv₀ G₀]\n  ⦃x : G₀⦄, x ≠ 0 → ContinuousAt Inv.inv x", "name": "HasContinuousInv₀.continuousAt_inv₀", "isProp": true, "docString": "The map `fun x ↦ x⁻¹` is continuous at all nonzero points. ", "terms": "[\n  \"map\",\n  \"continuous\",\n  \"nonzero points\"\n]"}
{"type": "∀ {R : Type u_2} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {ι : Type u_8}\n  {f : ι → M},\n  Function.Injective f → LinearIndependent (ι := { x // x ∈ Set.range f }) R Subtype.val → LinearIndependent R f", "name": "LinearIndependent.of_subtype_range", "isProp": true, "docString": "**Alias** of the forward direction of `linearIndependent_subtype_range`.", "terms": "[\"Alias\", \"forward direction\", \"linearIndependent_subtype_range\"]"}
{"type": "{V : Type u_9} →\n  {K : Type u_10} →\n    [inst : Field K] →\n      [inst_1 : AddCommGroup V] →\n        [inst_2 : Module K V] →\n          [inst_3 : FiniteDimensional K V] → (B : BilinForm K V) → BilinForm.Nondegenerate B → V ≃ₗ[K] Module.Dual K V", "name": "BilinForm.toDual", "isProp": false, "docString": "Given a nondegenerate bilinear form `B` on a finite-dimensional vector space, `B.toDual` is\nthe linear equivalence between a vector space and its dual with the underlying linear map\n`B.toLin`. ", "terms": "[\n    \"nondegenerate\",\n    \"bilinear form\",\n    \"finite-dimensional\",\n    \"vector space\",\n    \"linear equivalence\",\n    \"dual\",\n    \"underlying\",\n    \"linear map\"\n]"}
{"type": "∀ (x : ℂ) (n : ℕ) [inst : Nat.AtLeastTwo n], x ^ OfNat.ofNat n = x ^ OfNat.ofNat n", "name": "Complex.cpow_ofNat", "isProp": true, "docString": "See Note [no_index around OfNat.ofNat] ", "terms": "[]"}
{"type": "∀ {α : Type u_1} [self : CompleteBooleanAlgebra α] (a : α) (s : Set α), a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b", "name": "CompleteBooleanAlgebra.inf_sSup_le_iSup_inf", "isProp": true, "docString": "In a frame, `⊓` distributes over `⨆`. ", "terms": "[\n  \"frame\",\n  \"distributes\",\n  \"over\"\n]"}
{"type": "(X : Type u_1) → [inst : TopologicalSpace X] → Setoid X", "name": "pathSetoid", "isProp": false, "docString": "The setoid corresponding the equivalence relation of being joined by a continuous path. ", "terms": "[\n  \"Setoid\",\n  \"Equivalence Relation\",\n  \"Continuous Path\"\n]"}
{"type": "{α : Type u_2} →\n  {β : Type u_3} →\n    {γ : Type u_4} →\n      [inst : Preorder α] → [inst_1 : Preorder β] → [inst_2 : Preorder γ] → (α →o β × γ) ≃o (α →o β) × (α →o γ)", "name": "OrderHom.prodIso", "isProp": false, "docString": "Order isomorphism between the space of monotone maps to `β × γ` and the product of the spaces\nof monotone maps to `β` and `γ`. ", "terms": "[\n  \"Order isomorphism\",\n  \"Space\",\n  \"Monotone maps\",\n  \"Product\",\n  \"Spaces\"\n]"}
{"type": "{α : Type u_1} →\n  [inst : DecidableEq α] → [inst : MulZeroOneClass α] → [inst : Nontrivial α] → MulZeroOneClass (WithTop α)", "name": "WithTop.instMulZeroOneClassWithTop", "isProp": false, "docString": "`Nontrivial α` is needed here as otherwise we have `1 * ⊤ = ⊤` but also `0 * ⊤ = 0`. ", "terms": "[\"Nontrivial\", \"1\", \"0\", \"*\", \"=\", \"⊤\"]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.Limits.HasPullbacks C] →\n      {A : C} →\n        (f g h : CategoryTheory.MonoOver A) → (h ⟶ f) → (h ⟶ g) → (h ⟶ (CategoryTheory.MonoOver.inf.obj f).obj g)", "name": "CategoryTheory.MonoOver.leInf", "isProp": false, "docString": "A morphism version of the `le_inf` axiom. ", "terms": "[\"morphism\", \"le_inf\", \"axiom\"]"}
{"type": "{α β : Type u} →\n  {L : α → SetTheory.PGame} →\n    {R : β → SetTheory.PGame} → [S : SetTheory.PGame.Short (SetTheory.PGame.mk α β L R)] → Fintype α", "name": "SetTheory.PGame.fintypeLeft", "isProp": false, "docString": "Extracting the `Fintype` instance for the indexing type for Left's moves in a short game.\nThis is an unindexed typeclass, so it can't be made a global instance.\n", "terms": "[\n    \"Fintype\",\n    \"indexing type\",\n    \"Left's moves\",\n    \"short game\",\n    \"unindexed typeclass\",\n    \"global instance\"\n]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasProducts C] {ι : Type v}\n  {B : ι → C}, (∀ (A : C), ∃ i, Nonempty (B i ⟶ A)) → ∃ T, ∀ (X : C), Nonempty (T ⟶ X)", "name": "CategoryTheory.has_weakly_initial_of_weakly_initial_set_and_hasProducts", "isProp": true, "docString": "If `C` has (small) products and a small weakly initial set of objects, then it has a weakly initial\nobject.\n", "terms": "[\n    \"Products\",\n    \"Small Products\",\n    \"Small Weakly Initial Set of Objects\",\n    \"Weakly Initial Object\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      {D : Type u₂} →\n        [inst_2 : CategoryTheory.Category.{v₂, u₂} D] →\n          [inst_3 : CategoryTheory.MonoidalCategoryStruct D] →\n            {F : CategoryTheory.Functor D C} → CategoryTheory.Monoidal.InducingFunctorData F → (𝟙_ C ≅ F.obj (𝟙_ D))", "name": "CategoryTheory.Monoidal.InducingFunctorData.εIso", "isProp": false, "docString": "Analogous to `CategoryTheory.LaxMonoidalFunctor.εIso` ", "terms": "[\"Analogous\", \"Category Theory\", \"Lax Monoidal Functor\", \"εIso\"]"}
{"type": "∀ {T : ℝ} {g : ℝ → ℝ},\n  Function.Periodic g T →\n    (∀ (t₁ t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) →\n      0 < ∫ (x : ℝ) in 0 ..T, g x → 0 < T → Filter.Tendsto (fun t => ∫ (x : ℝ) in 0 ..t, g x) Filter.atBot Filter.atBot", "name": "Function.Periodic.tendsto_atBot_intervalIntegral_of_pos", "isProp": true, "docString": "If `g : ℝ → ℝ` is periodic with period `T > 0` and `0 < ∫ x in 0..T, g x`, then\n`t ↦ ∫ x in 0..t, g x` tends to `-∞` as `t` tends to `-∞`. ", "terms": "[\n    \"Real number\",\n    \"Function\",\n    \"Periodic function\",\n    \"Period\",\n    \"Integral\",\n    \"Tends to\",\n    \"Negative infinity\"\n]"}
{"type": "PosNum → PosNum → Ordering", "name": "PosNum.cmp", "isProp": false, "docString": "Ordering of `PosNum`s. ", "terms": "[\n    \"Ordering\",\n    \"PosNum\"\n]"}
{"type": "{ι : Type u_1} →\n  (R : Type u_4) →\n    [inst : CommSemiring R] →\n      {s : ι → Type u_7} →\n        [inst_1 : (i : ι) → AddCommMonoid (s i)] →\n          [inst_2 : (i : ι) → Module R (s i)] → MultilinearMap R s (PiTensorProduct R fun i => s i)", "name": "PiTensorProduct.tprod", "isProp": false, "docString": "The canonical `MultilinearMap R s (⨂[R] i, s i)`. ", "terms": "[\n    \"Canonical\",\n    \"MultilinearMap\",\n    \"⨂\"\n]"}
{"type": "∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (n : ℕ) (a : α),\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (↑(Nat.succ n)) a)⁻¹", "name": "LinearOrderedCommGroupWithZero.zpow_neg'", "isProp": true, "docString": "`a ^ -(n + 1) = (a ^ (n + 1))⁻¹` ", "terms": "[\"exponentiation\", \"negative exponent\", \"addition\", \"inverse\"]"}
{"type": "(A : Type u_1) → [inst : Add A] → AddAut A →* Equiv.Perm A", "name": "AddAut.toPerm", "isProp": false, "docString": "Monoid hom from the group of multiplicative automorphisms to the group of permutations. ", "terms": "[\n    \"Monoid\",\n    \"Homomorphism\",\n    \"Group\",\n    \"Multiplicative Automorphisms\",\n    \"Group of Permutations\"\n]"}
{"type": "⦃J : Type u⦄ → (F : J → CategoryTheory.Grpd) → CategoryTheory.Limits.Fan F", "name": "CategoryTheory.Grpd.piLimitFan", "isProp": false, "docString": "Construct the product over an indexed family of groupoids, as a fan. ", "terms": "[\n    \"Construct\", \n    \"Product\", \n    \"Indexed Family\", \n    \"Groupoids\", \n    \"Fan\"\n]"}
{"type": "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V},\n  Orientation.oangle o x y = 0 → (x = y ↔ ‖x‖ = ‖y‖)", "name": "Orientation.eq_iff_norm_eq_of_oangle_eq_zero", "isProp": true, "docString": "Two vectors with zero angle between them are equal if and only if they have equal norms. ", "terms": "[\n    \"vectors\",\n    \"zero angle\",\n    \"equal\",\n    \"if and only if\",\n    \"norms\"\n]"}
{"type": "{p q : Prop} → SlimCheck.TestResult p → SlimCheck.TestResult q → SlimCheck.TestResult (p ∨ q)", "name": "SlimCheck.TestResult.or", "isProp": false, "docString": "Combine the test result for properties `p` and `q` to create a test for their disjunction. ", "terms": "[\"combine\", \"test result\", \"properties\", \"create\", \"disjunction\"]"}
{"type": "{X : Type u_1} → [inst : TopologicalSpace X] → {x y z : X} → Path x y → Path y z → Path x z", "name": "Path.trans", "isProp": false, "docString": "Concatenation of two paths from `x` to `y` and from `y` to `z`, putting the first\npath on `[0, 1/2]` and the second one on `[1/2, 1]`. ", "terms": "[\n    \"Concatenation\",\n    \"paths\",\n    \"[0, 1/2]\",\n    \"[1/2, 1]\"\n]"}
{"type": "∀ {α : Type u_1} {s t : Multiset α}, s ≤ t → s ⊆ t", "name": "Multiset.Le.subset", "isProp": true, "docString": "**Alias** of `Multiset.subset_of_le`.", "terms": "The mathematical terms in the given statement are:\n\n1. Alias\n2. Multiset\n3. subset_of_le\n\nIn a JSON list, they are represented as:\n\n```json\n[\n    \"Alias\",\n    \"Multiset\",\n    \"subset_of_le\"\n]\n```"}
{"type": "Lean.ParserDescr", "name": "termIfThenElse", "isProp": false, "docString": "`if c then t else e` is notation for `ite c t e`, \"if-then-else\", which decides to\nreturn `t` or `e` depending on whether `c` is true or false. The explicit argument\n`c : Prop` does not have any actual computational content, but there is an additional\n`[Decidable c]` argument synthesized by typeclass inference which actually\ndetermines how to evaluate `c` to true or false. Write `if h : c then t else e`\ninstead for a \"dependent if-then-else\" `dite`, which allows `t`/`e` to use the fact\nthat `c` is true/false.\n\nBecause lean uses a strict (call-by-value) evaluation strategy, the signature of this\nfunction is problematic in that it would require `t` and `e` to be evaluated before\ncalling the `ite` function, which would cause both sides of the `if` to be evaluated.\nEven if the result is discarded, this would be a big performance problem,\nand is undesirable for users in any case. To resolve this, `ite` is marked as\n`@[macro_inline]`, which means that it is unfolded during code generation, and\nthe definition of the function uses `fun _ => t` and `fun _ => e` so this recovers\nthe expected \"lazy\" behavior of `if`: the `t` and `e` arguments delay evaluation\nuntil `c` is known.\n", "terms": "[\n  \"notation\",\n  \"if-then-else\",\n  \"return\",\n  \"true\",\n  \"false\",\n  \"argument\",\n  \"Prop\",\n  \"computational content\",\n  \"Decidable\",\n  \"argument synthesized\",\n  \"typeclass inference\",\n  \"evaluate\",\n  \"dependent if-then-else\",\n  \"dite\",\n  \"lean\",\n  \"strict\",\n  \"call-by-value\",\n  \"evaluation strategy\",\n  \"signature\",\n  \"function\",\n  \"performance problem\",\n  \"users\",\n  \"resolve\",\n  \"macro_inline\",\n  \"unfolded\",\n  \"code generation\",\n  \"definition\",\n  \"function\",\n  \"lazy\",\n  \"arguments\",\n  \"delay evaluation\",\n  \"known\"\n]"}
{"type": "∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal},\n  (∀ (n : ℕ), AEMeasurable (f n)) →\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) → ∫⁻ (a : α), ⨆ n, f n a ∂μ = ⨆ n, ∫⁻ (a : α), f n a ∂μ", "name": "MeasureTheory.lintegral_iSup'", "isProp": true, "docString": "Monotone convergence theorem -- sometimes called Beppo-Levi convergence. Version with\nae_measurable functions. ", "terms": "[\n    \"Monotone convergence theorem\",\n    \"Beppo-Levi convergence\",\n    \"ae_measurable functions\"\n]"}
{"type": "{α : Type u_1} → [inst : LE α] → NonemptyInterval α → αᵒᵈ × α", "name": "NonemptyInterval.toDualProd", "isProp": false, "docString": "The injection that induces the order on intervals. ", "terms": "[\n    \"Injection\",\n    \"Induces\",\n    \"Order\",\n    \"Intervals\"\n]"}
{"type": "PFunctor.{u} → PFunctor.{u} → PFunctor.{u}", "name": "PFunctor.comp", "isProp": false, "docString": "functor composition for polynomial functors ", "terms": "[\n    \"functor\",\n    \"composition\",\n    \"polynomial functors\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {X Y Z : C} →\n      {f : X ⟶ Z} →\n        {g : Y ⟶ Z} → [inst_1 : CategoryTheory.Limits.HasPullback f g] → CategoryTheory.Limits.pullback f g ⟶ X", "name": "CategoryTheory.Limits.pullback.fst", "isProp": false, "docString": "The first projection of the pullback of `f` and `g`. ", "terms": "[\n    \"first projection\",\n    \"pullback\"\n]"}
{"type": "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α},\n  a < 0 → b ≤ 0 → a + b < 0", "name": "Right.add_neg_of_neg_of_nonpos", "isProp": true, "docString": "Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_neg_of_neg_of_nonpos`.", "terms": "[\n  \"right covariance\",\n  \"lemma\",\n  \"left covariance\",\n  \"add\",\n  \"neg\",\n  \"nonpos\"\n]"}
{"type": "(α : Type u_5) →\n  [H1 : Lattice α] →\n    [inst : SupSet α] → (∀ (s : Set α), BddAbove s → Set.Nonempty s → IsLUB s (sSup s)) → ConditionallyCompleteLattice α", "name": "conditionallyCompleteLatticeOfLatticeOfsSup", "isProp": false, "docString": "A version of `conditionallyCompleteLatticeOfsSup` when we already know that `α` is a lattice.\n\nThis should only be used when it is both hard and unnecessary to provide `inf` explicitly. ", "terms": "[\n    \"version\",\n    \"conditionallyCompleteLatticeOfsSup\",\n    \"lattice\",\n    \"hard\",\n    \"unnecessary\",\n    \"provide\",\n    \"inf\",\n    \"explicitly\"\n]"}
{"type": "∀ {α : Type u_3} [inst : Preorder α] [self : PredOrder α] {a : α}, a ≤ PredOrder.pred a → IsMin a", "name": "PredOrder.min_of_le_pred", "isProp": true, "docString": "Proof of interaction between `pred` and minimal element", "terms": "[\"Proof\", \"interaction\", \"pred\", \"minimal element\"]"}
{"type": "PNat.XgcdType → Prop", "name": "PNat.XgcdType.IsReduced'", "isProp": false, "docString": "`IsReduced'` is an alternative of `IsReduced`. ", "terms": "[\"IsReduced\", \"alternative\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {J : Type u₁} →\n      [inst_1 : CategoryTheory.Category.{v₁, u₁} J] →\n        {K : Type u₂} →\n          [inst_2 : CategoryTheory.Category.{v₂, u₂} K] →\n            (F : CategoryTheory.Functor J (CategoryTheory.Functor K C)) →\n              (c : (k : K) → CategoryTheory.Limits.LimitCone ((CategoryTheory.Functor.flip F).obj k)) →\n                (k : K) →\n                  ((CategoryTheory.evaluation K C).obj k).mapCone (CategoryTheory.Limits.combineCones F c) ≅ (c k).cone", "name": "CategoryTheory.Limits.evaluateCombinedCones", "isProp": false, "docString": "The stitched together cones each project down to the original given cones (up to iso). ", "terms": "[\n    \"stitched together cones\", \n    \"project\", \n    \"original given cones\", \n    \"up to iso\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        (F : C → D) → [inst_2 : CategoryTheory.Functorial F] → {X Y : C} → (X ⟶ Y) → (F X ⟶ F Y)", "name": "CategoryTheory.map", "isProp": false, "docString": "If `F : C → D` (just a function) has `[Functorial F]`,\nwe can write `map F f : F X ⟶ F Y` for the action of `F` on a morphism `f : X ⟶ Y`.\n", "terms": "[\n    \"function\",\n    \"Functorial\",\n    \"map\",\n    \"action\",\n    \"morphism\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_2} {ι : Sort uι} {m : MeasurableSpace α} {mβ : MeasurableSpace β} [inst : Countable ι]\n  (t : ι → Set α),\n  (∀ (i : ι), MeasurableSet (t i)) →\n    ∀ (f : (i : ι) → ↑(t i) → β),\n      (∀ (i : ι), Measurable (f i)) →\n        ∀\n          (hf :\n            ∀ (i j : ι) (x : α) (hxi : x ∈ t i) (hxj : x ∈ t j),\n              f i { val := x, property := hxi } = f j { val := x, property := hxj })\n          (htU : ⋃ i, t i = Set.univ), Measurable (Set.liftCover t f hf htU)", "name": "measurable_liftCover", "isProp": true, "docString": "Let `t i` be a countable covering of `α` by measurable sets. Let `f i : t i → β` be a family of\nfunctions that agree on the intersections `t i ∩ t j`. Then the function `Set.liftCover t f _ _`,\ndefined as `f i ⟨x, hx⟩` for `hx : x ∈ t i`, is measurable. ", "terms": "[\n  \"countable covering\",\n  \"measurable sets\",\n  \"family of functions\",\n  \"intersections\",\n  \"function\",\n  \"Set.liftCover\",\n  \"measurable\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  StrictMono f → StrictAnti (⇑OrderDual.toDual ∘ f)", "name": "StrictMono.dual_right", "isProp": true, "docString": "**Alias** of the reverse direction of `strictAnti_toDual_comp_iff`.", "terms": "The mathematical terms in the given statement are: \"Alias\", \"reverse direction\", \"strictAnti_toDual_comp_iff\". \n\nHere they are as a JSON list:\n\n```json\n[\n    \"Alias\",\n    \"reverse direction\",\n    \"strictAnti_toDual_comp_iff\"\n]\n```"}
{"type": "∀ {G : Type u} [inst : Mul G] [self : IsRightCancelMul G] (a b c : G), a * b = c * b → a = c", "name": "IsRightCancelMul.mul_right_cancel", "isProp": true, "docString": "Multiplication is right cancellative. ", "terms": "[\n  \"Multiplication\",\n  \"right cancellative\"\n]"}
{"type": "{ι : Type u_1} →\n  {R : Type u_3} →\n    {A : Type u_5} →\n      {x : ι → A} →\n        [inst : CommRing R] →\n          [inst_1 : CommRing A] →\n            [inst_2 : Algebra R A] → AlgebraicIndependent R x → ↥(Algebra.adjoin R (Set.range x)) →ₐ[R] MvPolynomial ι R", "name": "AlgebraicIndependent.repr", "isProp": false, "docString": "The canonical map from the subalgebra generated by an algebraic independent family\ninto the polynomial ring. ", "terms": "[\n    \"canonical map\",\n    \"subalgebra\",\n    \"generated\",\n    \"algebraic\",\n    \"independent family\",\n    \"polynomial ring\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {X : C} →\n      {J : CategoryTheory.GrothendieckTopology C} →\n        {D : Type u₁} →\n          [inst_1 : CategoryTheory.Category.{v₁, u₁} D] →\n            (S : CategoryTheory.GrothendieckTopology.Cover J X) →\n              (P : CategoryTheory.Functor Cᵒᵖ D) →\n                [inst_2 :\n                    CategoryTheory.Limits.HasMultiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)] →\n                  P.obj (Opposite.op X) ⟶\n                    CategoryTheory.Limits.multiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)", "name": "CategoryTheory.GrothendieckTopology.Cover.toMultiequalizer", "isProp": false, "docString": "The canonical map from `P.obj (op X)` to the multiequalizer associated to a covering sieve,\nassuming such a multiequalizer exists. This will be used in `Sheaf.lean` to provide an equivalent\nsheaf condition in terms of multiequalizers. ", "terms": "[\n  \"canonical map\", \n  \"P.obj\", \n  \"op X\", \n  \"multiequalizer\", \n  \"covering sieve\", \n  \"Sheaf.lean\", \n  \"equivalent sheaf condition\"\n]"}
{"type": "(Lean.Name → Bool) → Lean.CoreM (Std.HashMap Lean.Name (Array Lean.Name))", "name": "allNamesByModule", "isProp": false, "docString": "Retrieve all names in the environment satisfying a predicate,\ngathered together into a `HashMap` according to the module they are defined in.\n", "terms": "[]\n"}
{"type": "∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), ¬s1 ≤ s2 ↔ ∃ p ∈ s1, p ∉ s2", "name": "AffineSubspace.not_le_iff_exists", "isProp": true, "docString": "One subspace is not less than or equal to another if and only if it has a point not in the\nsecond subspace. ", "terms": "[\n  \"subspace\",\n  \"less than or equal to\",\n  \"if and only if\",\n  \"point\"\n]"}
{"type": "PrimeMultiset →+ Multiset ℕ", "name": "PrimeMultiset.coeNatMonoidHom", "isProp": false, "docString": "`PrimeMultiset.coe`, the coercion from a multiset of primes to a multiset of\nnaturals, promoted to an `AddMonoidHom`. ", "terms": "[\n  \"PrimeMultiset.coe\",\n  \"coercion\",\n  \"multiset\",\n  \"primes\",\n  \"naturals\",\n  \"AddMonoidHom\"\n]"}
{"type": "{ι : Type u} →\n  {E : Type v} →\n    {F : Type w} →\n      [inst : NormedAddCommGroup E] →\n        [inst_1 : NormedSpace ℝ E] →\n          [inst_2 : NormedAddCommGroup F] →\n            [inst_3 : NormedSpace ℝ F] →\n              {I : BoxIntegral.Box ι} →\n                [inst_4 : Fintype ι] →\n                  {l : BoxIntegral.IntegrationParams} →\n                    {f : (ι → ℝ) → E} →\n                      {vol : BoxIntegral.BoxAdditiveMap ι (E →L[ℝ] F) ⊤} →\n                        BoxIntegral.Integrable I l f vol → ℝ → NNReal → (ι → ℝ) → ↑(Set.Ioi 0)", "name": "BoxIntegral.Integrable.convergenceR", "isProp": false, "docString": "If `ε > 0`, then `BoxIntegral.Integrable.convergenceR` is a function `r : ℝ≥0 → ℝⁿ → (0, ∞)`\nsuch that for every `c : ℝ≥0`, for every tagged partition `π` subordinate to `r` (and satisfying\nadditional distortion estimates if `BoxIntegral.IntegrationParams.bDistortion l = true`), the\ncorresponding integral sum is `ε`-close to the integral.\n\nIf `BoxIntegral.IntegrationParams.bRiemann = true`, then `r c x` does not depend on `x`. If\n`ε ≤ 0`, then we use `r c x = 1`.  ", "terms": "[\n    \"function\",\n    \"ℝ≥0\",\n    \"ℝⁿ\",\n    \"(0, ∞)\",\n    \"tagged partition\",\n    \"subordinate\",\n    \"distortion estimates\",\n    \"integral sum\",\n    \"ε-close\",\n    \"integral\",\n    \"BoxIntegral.IntegrationParams.bRiemann\",\n    \"BoxIntegral.IntegrationParams.bDistortion\",\n    \"BoxIntegral.Integrable.convergenceR\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} [inst : Preorder β] {f : α → β} {l : Filter α} {a : α},\n  IsMaxFilter (⇑OrderDual.toDual ∘ f) l a → IsMinFilter f l a", "name": "IsMaxFilter.undual", "isProp": true, "docString": "**Alias** of the forward direction of `isMaxFilter_dual_iff`.", "terms": "[\n    \"Alias\",\n    \"forward direction\",\n    \"isMaxFilter_dual_iff\"\n]"}
{"type": "∀ {M : Type u_1} {P : Type u_3} [inst : AddZeroClass M] [inst_1 : AddZeroClass P] {c : AddCon M} {f : M →+ P}\n  (H : c ≤ AddCon.ker f) (x : M), (AddCon.lift c f H) ((AddCon.mk' c) x) = f x", "name": "AddCon.lift_mk'", "isProp": true, "docString": "The diagram describing the universal property for quotients of `AddMonoid`s\ncommutes.", "terms": "[\n    \"diagram\",\n    \"universal property\",\n    \"quotients\",\n    \"AddMonoid\",\n    \"commutes\"\n]"}
{"type": "{ι : Type u_1} →\n  {R : Type u_2} →\n    [inst : CommRing R] →\n      [inst_1 : IsDomain R] →\n        [inst_2 : IsPrincipalIdealRing R] →\n          {M : Type u_3} →\n            [inst_3 : AddCommGroup M] →\n              [inst_4 : Module R M] →\n                [inst_5 : Finite ι] →\n                  Basis ι R M →\n                    (N O : Submodule R M) →\n                      N ≤ O →\n                        (o : ℕ) × (n : ℕ) × Basis.SmithNormalForm (Submodule.comap (Submodule.subtype O) N) (Fin o) n", "name": "Submodule.smithNormalFormOfLE", "isProp": false, "docString": "If `M` is finite free over a PID `R`, then any submodule `N` is free\nand we can find a basis for `M` and `N` such that the inclusion map is a diagonal matrix\nin Smith normal form.\n\nSee `Submodule.exists_smith_normal_form_of_le` for a version of this theorem that doesn't\nneed to map `N` into a submodule of `O`.\n\nThis is a strengthening of `Submodule.basisOfPidOfLe`.\n", "terms": "[\n  \"finite\",\n  \"free\",\n  \"PID\",\n  \"submodule\",\n  \"basis\",\n  \"inclusion map\",\n  \"diagonal matrix\",\n  \"Smith normal form\",\n  \"theorem\",\n  \"strengthening\"\n]"}
{"type": "{ι : Type u_1} →\n  {𝕜 : Type u_3} →\n    [inst : IsROrC 𝕜] →\n      {E : Type u_4} →\n        [inst_1 : NormedAddCommGroup E] →\n          [inst_2 : InnerProductSpace 𝕜 E] →\n            [inst_3 : Fintype ι] →\n              {v : ι → E} → Orthonormal 𝕜 v → (Submodule.span 𝕜 (Set.range v))ᗮ = ⊥ → OrthonormalBasis ι 𝕜 E", "name": "OrthonormalBasis.mkOfOrthogonalEqBot", "isProp": false, "docString": "A finite orthonormal family of vectors whose span has trivial orthogonal complement is an\northonormal basis. ", "terms": "[\n  \"finite\",\n  \"orthonormal\",\n  \"family\",\n  \"vectors\",\n  \"span\",\n  \"trivial\",\n  \"orthogonal\",\n  \"complement\",\n  \"basis\"\n]"}
{"type": "∀ {α : Type u_2} [inst : PartialOrder α] [inst_1 : LocallyFiniteOrder α] {a b : α},\n  a < b → Finset.Ioc a b = Finset.cons b (Finset.Ioo a b) (_ : b ∉ Finset.Ioo a b)", "name": "Finset.Ioc_eq_cons_Ioo", "isProp": true, "docString": "`Finset.cons` version of `Finset.Ioo_insert_right`. ", "terms": "[\"Finset.cons\", \"Finset.Ioo_insert_right\"]"}
{"type": "{n m : ℕ} → n = m → Fin n ≃o Fin m", "name": "Fin.castIso", "isProp": false, "docString": "`Fin.cast` as an `OrderIso`, `castIso eq i` embeds `i` into an equal `Fin` type,\nsee also `Equiv.finCongr`. ", "terms": "[\n    \"Fin.cast\", \n    \"OrderIso\", \n    \"castIso\", \n    \"embeds\", \n    \"Fin\", \n    \"Equiv.finCongr\"\n]"}
{"type": "(R : Type u) →\n  (X : Type v) → [inst : CommRing R] → UniversalEnvelopingAlgebra R (FreeLieAlgebra R X) ≃ₐ[R] FreeAlgebra R X", "name": "FreeLieAlgebra.universalEnvelopingEquivFreeAlgebra", "isProp": false, "docString": "The universal enveloping algebra of the free Lie algebra is just the free unital associative\nalgebra. ", "terms": "[\n    \"Universal enveloping algebra\",\n    \"Free Lie algebra\",\n    \"Free unital associative algebra\"\n]"}
{"type": "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {n : ℕ∞}\n  {E' : Type u_3} [inst_5 : NormedAddCommGroup E'] [inst_6 : NormedSpace 𝕜 E'] {F' : Type u_4}\n  [inst_7 : NormedAddCommGroup F'] [inst_8 : NormedSpace 𝕜 F'] {f : E → F} {g : E' → F'} {x : E} {y : E'},\n  ContDiffAt 𝕜 n f x → ContDiffAt 𝕜 n g y → ContDiffAt 𝕜 n (Prod.map f g) (x, y)", "name": "ContDiffAt.prod_map", "isProp": true, "docString": "The product map of two `C^n` functions within a set at a point is `C^n`\nwithin the product set at the product point. ", "terms": "[\n  \"product map\",\n  \"C^n functions\",\n  \"set\",\n  \"point\",\n  \"C^n\",\n  \"product set\",\n  \"product point\"\n]"}
{"type": "{ι : Type u_1} →\n  {X : Type u_2} →\n    [inst : TopologicalSpace X] →\n      {u : ι → Set X} →\n        {s : Set X} →\n          (c : Set (ShrinkingLemma.PartialRefinement u s)) →\n            IsChain (fun x x_1 => x ≤ x_1) c →\n              Set.Nonempty c → (∀ x ∈ s, Set.Finite {i | x ∈ u i}) → s ⊆ ⋃ i, u i → ShrinkingLemma.PartialRefinement u s", "name": "ShrinkingLemma.PartialRefinement.chainSup", "isProp": false, "docString": "Least upper bound of a nonempty chain of partial refinements. ", "terms": "[\"Least upper bound\", \"nonempty\", \"chain\", \"partial refinements\"]"}
{"type": "ℕ+ → ℕ+ → Prop", "name": "PNat.Coprime", "isProp": false, "docString": "Two pnats are coprime if their gcd is 1. ", "terms": "[\"Two\", \"pnats\", \"coprime\", \"gcd\", \"1\"]"}
{"type": "{K : Type u_1} → [inst : Field K] → [inst_1 : NumberField K] → NumberField.InfinitePlace K", "name": "NumberField.Units.dirichletUnitTheorem.w₀", "isProp": false, "docString": "The distinguished infinite place. ", "terms": "[\"distinguished\", \"infinite\", \"place\"]"}
{"type": "{I : Type u} →\n  {f : I → Type v} →\n    {γ : Type w} →\n      [inst : (i : I) → NonUnitalNonAssocSemiring (f i)] →\n        [inst_1 : NonUnitalNonAssocSemiring γ] → ((i : I) → γ →ₙ+* f i) → γ →ₙ+* (i : I) → f i", "name": "Pi.nonUnitalRingHom", "isProp": false, "docString": "A family of non-unital ring homomorphisms `f a : γ →ₙ+* β a` defines a non-unital ring\nhomomorphism `Pi.nonUnitalRingHom f : γ →+* Π a, β a` given by\n`Pi.nonUnitalRingHom f x b = f b x`. ", "terms": "[\n  \"family\",\n  \"non-unital ring homomorphisms\",\n  \"defines\",\n  \"non-unital ring homomorphism\",\n  \"given by\"\n]"}
{"type": "{U : Type u_1} →\n  [inst : Quiver U] →\n    {V : Type u_2} → [inst_1 : Quiver V] → (φ : U ⥤q V) → (u : U) → Quiver.Star u → Quiver.Star (φ.obj u)", "name": "Prefunctor.star", "isProp": false, "docString": "A prefunctor induces a map of `Quiver.Star` at every vertex. ", "terms": "[\n    \"Prefunctor\",\n    \"Induces\",\n    \"Map\",\n    \"Quiver.Star\",\n    \"Vertex\"\n]"}
{"type": "{α : Type u_1} → PartialOrder (Subtype Setoid.IsPartition)", "name": "Setoid.Partition.partialOrder", "isProp": false, "docString": "Defining a partial order on partitions as the partial order on their induced\nequivalence relations. ", "terms": "[\n    \"partial order\",\n    \"partitions\",\n    \"induced\",\n    \"equivalence relations\"\n]"}
{"type": "{R : Type u} → [inst : NonAssocSemiring R] → Submonoid R → Subsemiring R", "name": "Submonoid.subsemiringClosure", "isProp": false, "docString": "The additive closure of a submonoid is a subsemiring. ", "terms": "[\n    \"additive closure\",\n    \"submonoid\",\n    \"subsemiring\"\n]"}
{"type": "∀ {α : Type u_1} {E : Type u_3} [inst : Norm E] {f : α → E} {l : Filter α} {u : α → ℝ},\n  f =o[l] u → f =o[l] fun x => |u x|", "name": "Asymptotics.IsLittleO.abs_right", "isProp": true, "docString": "**Alias** of the reverse direction of `Asymptotics.isLittleO_abs_right`.", "terms": "[\"Alias\", \"reverse direction\", \"Asymptotics.isLittleO_abs_right\"]"}
{"type": "∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Metric.hausdorffDist s s = 0", "name": "Metric.hausdorffDist_self_zero", "isProp": true, "docString": "The Hausdorff distance between a set and itself is zero ", "terms": "[\n    \"Hausdorff distance\",\n    \"set\",\n    \"zero\"\n]"}
{"type": "{α : Type u_1} → [inst : TopologicalSpace α] → {β : Type u_2} → [inst : Preorder β] → (α → β) → Set α → Prop", "name": "LowerSemicontinuousOn", "isProp": false, "docString": "A real function `f` is lower semicontinuous on a set `s` if, for any `ε > 0`, for any `x ∈ s`,\nfor all `x'` close enough to `x` in `s`, then `f x'` is at least `f x - ε`. We formulate this in\na general preordered space, using an arbitrary `y < f x` instead of `f x - ε`.", "terms": "[\n    \"real function\",\n    \"lower semicontinuous\",\n    \"set\",\n    \"ε > 0\",\n    \"close enough\",\n    \"at least\",\n    \"general preordered space\",\n    \"arbitrary\",\n    \"y < f x\"\n]"}
{"type": "Turing.PartrecToTM2.Γ' → Bool", "name": "Turing.PartrecToTM2.natEnd", "isProp": false, "docString": "A predicate that detects the end of a natural number, either `Γ'.cons` or `Γ'.consₗ` (or\nimplicitly the end of the list), for use in predicate-taking functions like `move` and `clear`. ", "terms": "[\"predicate\", \"end\", \"natural number\", \"cons\", \"list\", \"predicate-taking functions\", \"move\", \"clear\"]"}
{"type": "{R : Type u} →\n  {L : Type v} →\n    [inst : CommRing R] → [inst_1 : LieRing L] → [inst_2 : LieAlgebra R L] → (L' : LieSubalgebra R L) → ↥L' →ₗ⁅R,↥L'⁆ L", "name": "LieSubalgebra.incl'", "isProp": false, "docString": "The embedding of a Lie subalgebra into the ambient space as a morphism of Lie modules. ", "terms": "[\n    \"embedding\",\n    \"Lie subalgebra\",\n    \"ambient space\",\n    \"morphism\",\n    \"Lie modules\"\n]"}
{"type": "∀ {R : Type u_1} [inst : CommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {A : Type u_3}\n  [inst_3 : Semiring A] [inst_4 : Algebra R A] {f g : TensorAlgebra R M →ₐ[R] A},\n  AlgHom.toLinearMap f ∘ₗ TensorAlgebra.ι R = AlgHom.toLinearMap g ∘ₗ TensorAlgebra.ι R → f = g", "name": "TensorAlgebra.hom_ext", "isProp": true, "docString": "See note [partially-applied ext lemmas]. ", "terms": "The provided statement contains only one mathematical term. Here it is as a JSON list:\n\n[\n    \"partially-applied\",\n    \"ext\",\n    \"lemmas\"\n]"}
{"type": "{n : Type u} →\n  [inst : DecidableEq n] →\n    [inst_1 : Fintype n] → {R : Type v} → [inst_2 : CommRing R] → GL n R ≃* LinearMap.GeneralLinearGroup R (n → R)", "name": "Matrix.GeneralLinearGroup.toLin", "isProp": false, "docString": "The `GL n R` and `Matrix.GeneralLinearGroup R n` groups are multiplicatively equivalent", "terms": "[\n  \"GL n R\",\n  \"Matrix.GeneralLinearGroup R n\",\n  \"groups\",\n  \"multiplicatively equivalent\"\n]"}
{"type": "∀ {a : ℝ}, a < -1 → ∀ {c : ℝ}, 0 < c → MeasureTheory.IntegrableOn (fun t => t ^ a) (Set.Ioi c)", "name": "integrableOn_Ioi_rpow_of_lt", "isProp": true, "docString": "If `0 < c`, then `(λ t : ℝ, t ^ a)` is integrable on `(c, ∞)` for all `a < -1`. ", "terms": "[\n    \"0\",\n    \"<\",\n    \"real number\",\n    \"lambda\",\n    \"power\",\n    \"integrable\",\n    \"interval\",\n    \"-1\",\n    \"infinity\",\n    \"for all\"\n]"}
{"type": "∀ {α : Type u_6} {β : Type u_7} [inst : Bot α] [inst_1 : Bot β] (self : BotHom α β), BotHom.toFun self ⊥ = ⊥", "name": "BotHom.map_bot'", "isProp": true, "docString": "The function preserves the bottom element. The preferred spelling is `map_bot`. ", "terms": "[\"function\", \"preserves\", \"bottom element\", \"preferred spelling\", \"map_bot\"]"}
{"type": "∀ {α : Type u_1} [inst : PartialOrder α] {s : Finset α} {a : α}, { ofColex := {a} } ≤ { ofColex := s } ↔ ∃ x ∈ s, a ≤ x", "name": "Finset.Colex.singleton_le_toColex", "isProp": true, "docString": "`{a} ≤ s` in colex iff `s` contains an element greated than or equal to `a`. ", "terms": "[\n  \"element\",\n  \"contains\",\n  \"colex\",\n  \"less than or equal to\",\n  \"greater than or equal to\"\n]"}
{"type": "{α : Type u_1} → ℕ → Ordnode α → Ordnode α × Ordnode α", "name": "Ordnode.splitAt", "isProp": false, "docString": "O(log n). Split a set at the `i`th element, getting the first `i` and everything else.\n\nsplitAt 2 {a, b, c, d} = ({a, b}, {c, d})\nsplitAt 5 {a, b, c, d} = ({a, b, c, d}, ∅) ", "terms": "[\n    \"O(log n)\",\n    \"set\",\n    \"element\",\n    \"splitAt\",\n    \"∅\"\n]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] → CategoryTheory.ShortComplex.SnakeInput C → CategoryTheory.ShortComplex C", "name": "CategoryTheory.ShortComplex.SnakeInput.L₀", "isProp": false, "docString": "the zeroth row ", "terms": "[\"zeroth\", \"row\"]"}
{"type": "∀ (𝕜 : Type u_1) [inst : NontriviallyNormedField 𝕜] (E : Type u_2) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E], (modelWithCornersSelf 𝕜 E).toPartialEquiv = PartialEquiv.refl E", "name": "modelWithCornersSelf_localEquiv", "isProp": true, "docString": "In the trivial model with corners, the associated local equiv is the identity. ", "terms": "[\n  \"trivial model\",\n  \"corners\",\n  \"associated\",\n  \"local\",\n  \"equiv\",\n  \"identity\"\n]"}
{"type": "{V : Type u_1} →\n  {G : SimpleGraph V} → {u v : V} → {p : SimpleGraph.Walk G u v} → SimpleGraph.Walk.IsTrail p → Finset (Sym2 V)", "name": "SimpleGraph.Walk.IsTrail.edgesFinset", "isProp": false, "docString": "The edges of a trail as a finset, since each edge in a trail appears exactly once. ", "terms": "[\n    \"edges\",\n    \"trail\",\n    \"finset\",\n    \"edge\",\n    \"appears\",\n    \"exactly once\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {T : CategoryTheory.Monad C} →\n      (X : CategoryTheory.Monad.Algebra T) →\n        CategoryTheory.IsSplitCoequalizer (T.map X.a) ((CategoryTheory.Monad.μ T).app X.A) X.a", "name": "CategoryTheory.Monad.beckSplitCoequalizer", "isProp": false, "docString": "The Beck cofork is a split coequalizer. ", "terms": "[\n    \"Beck cofork\",\n    \"split coequalizer\"\n]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_3, u_1} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      [inst_2 : CategoryTheory.Balanced C] →\n        (S : CategoryTheory.ShortComplex C) →\n          CategoryTheory.ShortComplex.Exact S →\n            (r : S.X₂ ⟶ S.X₁) →\n              CategoryTheory.CategoryStruct.comp S.f r = CategoryTheory.CategoryStruct.id S.X₁ →\n                CategoryTheory.Epi S.g → CategoryTheory.ShortComplex.Splitting S", "name": "CategoryTheory.ShortComplex.Splitting.ofExactOfRetraction", "isProp": false, "docString": "This is the splitting of a short complex `S` in a balanced category induced by\na retraction of the morphism `S.f : S.X₁ ⟶ S.X₂` ", "terms": "[\"splitting\", \"short complex\", \"balanced category\", \"induced\", \"retraction\", \"morphism\"]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      {S₁ S₂ S₃ : CategoryTheory.ShortComplex C} →\n        {φ₁ φ₂ : S₁ ⟶ S₂} →\n          CategoryTheory.ShortComplex.Homotopy φ₁ φ₂ →\n            (ψ : S₂ ⟶ S₃) →\n              CategoryTheory.ShortComplex.Homotopy (CategoryTheory.CategoryStruct.comp φ₁ ψ)\n                (CategoryTheory.CategoryStruct.comp φ₂ ψ)", "name": "CategoryTheory.ShortComplex.Homotopy.compRight", "isProp": false, "docString": "Homotopy between morphisms of short complexes is compatible with postcomposition. ", "terms": "[\n    \"Homotopy\",\n    \"Morphisms\",\n    \"Short Complexes\",\n    \"Compatible\",\n    \"Postcomposition\"\n]"}
{"type": "{G : Type u_6} →\n  [inst : AddGroup G] →\n    {H : Type u_9} → [inst_1 : AddGroup H] → (f : G → H) → (∀ (a b : G), f (a + -b) = f a + -f b) → G →+ H", "name": "AddMonoidHom.ofMapAddNeg", "isProp": false, "docString": "Makes an additive group homomorphism from a proof that the map preserves\nthe operation `fun a b => a + -b`. See also `AddMonoidHom.ofMapSub` for a version using\n`fun a b => a - b`.", "terms": "[\n    \"additive group\",\n    \"homomorphism\",\n    \"proof\",\n    \"map\",\n    \"preserves\",\n    \"operation\",\n    \"AddMonoidHom.ofMapSub\",\n    \"version\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      (S : CategoryTheory.ShortComplex C) →\n        S.f = 0 →\n          (c : CategoryTheory.Limits.KernelFork S.g) →\n            CategoryTheory.Limits.IsLimit c → CategoryTheory.ShortComplex.HomologyData S", "name": "CategoryTheory.ShortComplex.HomologyData.ofIsLimitKernelFork", "isProp": false, "docString": "When the first map `S.f` is zero, this is the homology data on `S` given\nby any limit kernel fork of `S.g` ", "terms": "[\n    \"map\",\n    \"zero\",\n    \"homology\",\n    \"data\",\n    \"limit\",\n    \"kernel\",\n    \"fork\"\n]"}
{"type": "{ι : Type u_1} →\n  {I : BoxIntegral.Box ι} →\n    BoxIntegral.TaggedPrepartition I →\n      ((J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J) → BoxIntegral.TaggedPrepartition I", "name": "BoxIntegral.TaggedPrepartition.biUnionPrepartition", "isProp": false, "docString": "Given a tagged partition `π` of `I` and a (not tagged) partition `πi J hJ` of each `J ∈ π`,\nreturns the tagged partition of `I` into all the boxes of all `πi J hJ`. The tag of a box `J`\nis defined to be the `π.tag` of the box of the partition `π` that includes `J`.\n\nNote that usually the result is not a Henstock partition. ", "terms": "[\n    \"tagged partition\",\n    \"partition\",\n    \"box\",\n    \"tag\",\n    \"Henstock partition\"\n]"}
{"type": "∀ {R : Type u_1} {G : Type u_4} [inst : Group G] [inst_1 : MulAction G R] (g : G), IsSMulRegular R g", "name": "isSMulRegular_of_group", "isProp": true, "docString": "An element of a group acting on a Type is regular. This relies on the availability\nof the inverse given by groups, since there is no `LeftCancelSMul` typeclass. ", "terms": "[\n    \"element\",\n    \"group\",\n    \"acting\",\n    \"Type\",\n    \"regular\",\n    \"availability\",\n    \"inverse\",\n    \"LeftCancelSMul\",\n    \"typeclass\"\n]"}
{"type": "SetTheory.PGame → Ordinal.{u}", "name": "SetTheory.PGame.birthday", "isProp": false, "docString": "The birthday of a pre-game is inductively defined as the least strict upper bound of the\nbirthdays of its left and right games. It may be thought as the \"step\" in which a certain game is\nconstructed. ", "terms": "[\"birthday\", \"pre-game\", \"inductively defined\", \"least\", \"strict upper bound\", \"birthdays\", \"left games\", \"right games\", \"step\", \"game\", \"constructed\"]"}
{"type": "{C : Fin2 0 → Sort u} → (i : Fin2 0) → C i", "name": "Fin2.elim0", "isProp": false, "docString": "Ex falso. The dependent eliminator for the empty `Fin2 0` type. ", "terms": "[\"Ex falso\", \"dependent eliminator\", \"empty\", \"Fin2 0\", \"type\"]"}
{"type": "Type u → Cardinal.{u}", "name": "Cardinal.mk", "isProp": false, "docString": "The cardinal number of a type ", "terms": "[\"cardinal number\", \"type\"]"}
{"type": "∀ {x : ℂ}, 0 < x.re → (x ^ 2) ^ 2⁻¹ = x", "name": "Complex.sq_cpow_two_inv", "isProp": true, "docString": "See also `Complex.pow_cpow_ofNat_inv` for a version that also works for `x * I`, `0 ≤ x`. ", "terms": "[\"Complex.pow_cpow_ofNat_inv\", \"x * I\", \"0 ≤ x\"]"}
{"type": "SelectInsertParams → Lean.Server.RequestM (Lean.Server.RequestTask ProofWidgets.Html)", "name": "CongrmSelectionPanel.rpc", "isProp": false, "docString": "Rpc function for the congrm widget. ", "terms": "[]"}
{"type": "{α : Type u_1} → {ι : Type u_2} → (ι → Set (Set α)) → Set ι → Set (Set α)", "name": "piiUnionInter", "isProp": false, "docString": "From a set of indices `S : Set ι` and a family of sets of sets `π : ι → Set (Set α)`,\ndefine the set of sets that can be written as `⋂ x ∈ t, f x` for some finset `t ⊆ S` and sets\n`f x ∈ π x`. If `π` is a family of π-systems, then it is a π-system. ", "terms": "[\n    \"set\",\n    \"indices\",\n    \"family of sets\",\n    \"set of sets\",\n    \"define\",\n    \"can be written\",\n    \"finset\",\n    \"subset\",\n    \"family of π-systems\",\n    \"π-system\"\n]"}
{"type": "(V : Type (u + 1)) →\n  [inst : CategoryTheory.LargeCategory V] →\n    (G : MonCat) →\n      [inst_1 : CategoryTheory.MonoidalCategory V] →\n        CategoryTheory.MonoidalFunctor (Action V G) (CategoryTheory.Functor (CategoryTheory.SingleObj ↑G) V)", "name": "Action.functorCategoryMonoidalEquivalence", "isProp": false, "docString": "Upgrading the functor `Action V G ⥤ (SingleObj G ⥤ V)` to a monoidal functor. ", "terms": "[\n    \"functor\",\n    \"Action V G\",\n    \"SingleObj G\",\n    \"V\",\n    \"monoidal functor\"\n]"}
{"type": "(α : Type u_4) → [inst : BooleanRing α] → AsBoolRing (AsBoolAlg α) ≃+* α", "name": "RingEquiv.asBoolRingAsBoolAlg", "isProp": false, "docString": "Ring isomorphism between `α` considered as a Boolean algebra considered as a Boolean ring and\n`α`. ", "terms": "[\n    \"Ring\",\n    \"Isomorphism\",\n    \"Boolean algebra\",\n    \"Boolean ring\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Antitone f → Antitone (⇑OrderDual.toDual ∘ f ∘ ⇑OrderDual.ofDual)", "name": "Antitone.dual", "isProp": true, "docString": "**Alias** of the reverse direction of `antitone_dual_iff`.", "terms": "[\"Alias\", \"reverse direction\", \"antitone_dual_iff\"]"}
{"type": "(α : Type u_1) → (Fin 2 → α) ≃ α × α", "name": "finTwoArrowEquiv", "isProp": false, "docString": "The space of functions `Fin 2 → α` is equivalent to `α × α`. See also `piFinTwoEquiv` and\n`prodEquivPiFinTwo`. ", "terms": "[\n    \"space of functions\",\n    \"equivalent\",\n    \"α × α\",\n    \"piFinTwoEquiv\",\n    \"prodEquivPiFinTwo\"\n]"}
{"type": "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β]\n  [inst_2 : PseudoMetricSpace γ] {G : β → γ} {C : NNReal} (H : LipschitzWith C G),\n  LipschitzWith C (BoundedContinuousFunction.comp G H)", "name": "BoundedContinuousFunction.lipschitz_comp", "isProp": true, "docString": "The composition operator (in the target) with a Lipschitz map is Lipschitz. ", "terms": "[\n    \"composition operator\",\n    \"target\",\n    \"Lipschitz map\",\n    \"Lipschitz\"\n]"}
{"type": "{I : Type u_1} →\n  {J : Type u_2} →\n    (C : Type u_3) →\n      [inst : CategoryTheory.Category.{u_4, u_3} C] →\n        (p : I → J) →\n          [inst_1 : ∀ (j : J), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete ↑(p ⁻¹' {j})) C] →\n            CategoryTheory.Functor (CategoryTheory.GradedObject I C) (CategoryTheory.GradedObject J C)", "name": "CategoryTheory.GradedObject.map", "isProp": false, "docString": "Given a map `p : I → J`, this is the functor `GradedObject I C ⥤ GradedObject J C` which\nsends an `I`-object `X` to the graded object `X.mapObj p` which in degree `j : J` is given\nby the coproduct of those `X i` such that `p i = j`. ", "terms": "[\n    \"map\",\n    \"functor\",\n    \"GradedObject\",\n    \"sends\",\n    \"graded object\",\n    \"degree\",\n    \"coproduct\"\n]"}
{"type": "{α : Type v} → (P : α → Prop) → (i : α) ×' P i ≃ Subtype P", "name": "Equiv.psigmaEquivSubtype", "isProp": false, "docString": "A `PSigma` with `Prop` fibers is equivalent to the subtype.  ", "terms": "[\n    \"PSigma\",\n    \"Prop\",\n    \"fibers\",\n    \"equivalent\",\n    \"subtype\"\n]"}
{"type": "∀ {a b c : Prop}, (a ∨ b) ∧ c ↔ a ∧ c ∨ b ∧ c", "name": "or_and_right", "isProp": true, "docString": "`∧` distributes over `∨` (on the right). ", "terms": "[\"distributes\", \"over\", \"on the right\"]"}
{"type": "∀ {α : Type u_1} {n : Type u_4} {m : Type u_5} [inst : Zero α] {A : Matrix m m α} {D : Matrix n n α},\n  Matrix.IsDiag A → Matrix.IsDiag D → Matrix.IsDiag (Matrix.fromBlocks A 0 0 D)", "name": "Matrix.IsDiag.fromBlocks", "isProp": true, "docString": "The block matrix `A.fromBlocks 0 0 D` is diagonal if `A` and `D` are diagonal. ", "terms": "[\n    \"block matrix\",\n    \"diagonal\"\n]"}
{"type": "{k G : Type u} → [inst : CommRing k] → [inst_1 : Group G] → (A : Rep k G) → CoeSort.coe A →ₗ[k] G → CoeSort.coe A", "name": "groupCohomology.dZero", "isProp": false, "docString": "The 0th differential in the complex of inhomogeneous cochains of `A : Rep k G`, as a\n`k`-linear map `A → Fun(G, A)`. It sends `(a, g) ↦ ρ_A(g)(a) - a.` ", "terms": "[\n    \"0th differential\",\n    \"complex\",\n    \"inhomogeneous cochains\",\n    \"Rep\",\n    \"linear map\",\n    \"Fun\",\n    \"sends\"\n]"}
{"type": "{M : Type u_4} → [inst : CommMonoid M] → (S : Submonoid M) → Localization S", "name": "Localization.one", "isProp": false, "docString": "The identity element of a `Localization` is defined as `⟨1, 1⟩`. ", "terms": "[\n    \"Identity Element\",\n    \"Localization\"\n]"}
{"type": "{L : FirstOrder.Language} →\n  {α : Type u'} →\n    (n : ℕ) × FirstOrder.Language.BoundedFormula L α n → (n : ℕ) × FirstOrder.Language.BoundedFormula L α n", "name": "FirstOrder.Language.BoundedFormula.sigmaAll", "isProp": false, "docString": "Applies the `forall` quantifier to an element of `(Σ n, L.BoundedFormula α n)`,\nor returns `default` if not possible. ", "terms": "[\n    \"forall\",\n    \"quantifier\",\n    \"element\",\n    \"Σ\",\n    \"BoundedFormula\",\n    \"α\",\n    \"default\"\n]"}
{"type": "∀ {X : Type u_1} [inst : TopologicalSpace X] (𝕜 : Type u_4) [inst_1 : CommSemiring 𝕜] (A : Type u_5)\n  [inst_2 : TopologicalSpace A] [inst_3 : Semiring A] [inst_4 : TopologicalSemiring A] [inst_5 : Star A]\n  [inst_6 : ContinuousStar A] [inst_7 : Algebra 𝕜 A],\n  ContinuousMap.compStarAlgHom' 𝕜 A (ContinuousMap.id X) = StarAlgHom.id 𝕜 C(X, A)", "name": "ContinuousMap.compStarAlgHom'_id", "isProp": true, "docString": "`ContinuousMap.compStarAlgHom'` sends the identity continuous map to the identity\n`StarAlgHom` ", "terms": "[\n  \"ContinuousMap.compStarAlgHom\",\n  \"identity continuous map\",\n  \"identity\",\n  \"StarAlgHom\"\n]"}
{"type": "∀ {α : Type u_3} [inst : SemilatticeSup α] (a : α), Filter.atTop = Filter.comap Subtype.val Filter.atTop", "name": "Filter.atTop_Ioi_eq", "isProp": true, "docString": "The `atTop` filter for an open interval `Ioi a` comes from the `atTop` filter in the ambient\norder. ", "terms": "[\"filter\", \"open interval\", \"ambient order\"]"}
{"type": "∀ (F : Type u) (E : Type v) [inst : Field F] [inst_1 : Field E] [inst_2 : Algebra F E] (K : Type w) [inst_3 : Field K]\n  [inst_4 : Algebra F K] {S : Set E},\n  IntermediateField.adjoin F S = ⊤ →\n    (∀ s ∈ S, IsIntegral F s ∧ Polynomial.Splits (algebraMap F K) (minpoly F s)) →\n      Field.finSepDegree F E = Cardinal.toNat (Cardinal.mk (E →ₐ[F] K))", "name": "Field.finSepDegree_eq_of_adjoin_splits", "isProp": true, "docString": "The `Field.finSepDegree F E` is equal to the cardinality of `E →ₐ[F] K`\nif `E = F(S)` such that every element\n`s` of `S` is integral (= algebraic) over `F` and whose minimal polynomial splits in `K`. ", "terms": "[\n    \"Field\",\n    \"finSepDegree\",\n    \"equal\",\n    \"cardinality\",\n    \"integral\",\n    \"minimal polynomial\",\n    \"splits\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    (D : AlgebraicGeometry.PresheafedSpace.GlueData C) →\n      [inst_1 : CategoryTheory.Limits.HasLimits C] →\n        {i : D.J} →\n          TopologicalSpace.Opens ↑↑(CategoryTheory.GlueData.U D.toGlueData i) →\n            CategoryTheory.Functor\n              (CategoryTheory.Limits.WalkingMultispan (CategoryTheory.GlueData.diagram D.toGlueData).fstFrom\n                  (CategoryTheory.GlueData.diagram D.toGlueData).sndFrom)ᵒᵖ\n              C", "name": "AlgebraicGeometry.PresheafedSpace.GlueData.diagramOverOpen", "isProp": false, "docString": "(Implementation) Given an open subset of one of the spaces `U ⊆ Uᵢ`, the sheaf component of\nthe image `ι '' U` in the glued space is the limit of this diagram. ", "terms": "[\n    \"open subset\",\n    \"spaces\",\n    \"sheaf component\",\n    \"image\",\n    \"glued space\",\n    \"limit\",\n    \"diagram\"\n]"}
{"type": "∀ {f : ℕ → ℝ},\n  Monotone f →\n    Filter.Tendsto f Filter.atTop (nhds 0) →\n      CauchySeq fun n => Finset.sum (Finset.range (n + 1)) fun i => (-1) ^ i * f i", "name": "Monotone.cauchySeq_alternating_series_of_tendsto_zero", "isProp": true, "docString": "The **alternating series test** for monotone sequences.\nSee also `Monotone.tendsto_alternating_series_of_tendsto_zero`. ", "terms": "[\n  \"alternating series test\",\n  \"monotone sequences\",\n  \"Monotone.tendsto_alternating_series_of_tendsto_zero\"\n]"}
{"type": "∀ (R : Type u_1) [inst : Ring R] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  Polynomial.cyclotomic p R = Finset.sum (Finset.range p) fun i => Polynomial.X ^ i", "name": "Polynomial.cyclotomic_prime", "isProp": true, "docString": "If `p` is prime, then `cyclotomic p R = ∑ i in range p, X ^ i`. ", "terms": "[\n  \"prime\",\n  \"cyclotomic\",\n  \"range\",\n  \"sum\",\n  \"exponentiation\"\n]"}
{"type": "∀ {α : Sort u} {r : α → α → Prop}, Equivalence r → ∀ (x : α), r x x", "name": "Equivalence.refl", "isProp": true, "docString": "An equivalence relation is reflexive: `x ~ x` ", "terms": "[\"equivalence relation\", \"reflexive\"]"}
{"type": "{p : ℕ} → {R : Type u_1} → [hp : Fact (Nat.Prime p)] → [inst : CommRing R] → WittVector p R →+* ℕ → R", "name": "WittVector.ghostMap", "isProp": false, "docString": "`WittVector.ghostMap` is a ring homomorphism that maps each Witt vector\nto the sequence of its ghost components. ", "terms": "[\n    \"WittVector\",\n    \"ghostMap\",\n    \"ring\",\n    \"homomorphism\",\n    \"maps\",\n    \"vector\",\n    \"sequence\",\n    \"components\"\n]"}
{"type": "∀ {R : Type u_1} {ι : Type u_2} {ι' : Type u_3} [inst : NormedRing R] [inst_1 : CompleteSpace R] {f : ι → R}\n  {g : ι' → R},\n  (Summable fun x => ‖f x‖) →\n    (Summable fun x => ‖g x‖) → (∑' (x : ι), f x) * ∑' (y : ι'), g y = ∑' (z : ι × ι'), f z.1 * g z.2", "name": "tsum_mul_tsum_of_summable_norm", "isProp": true, "docString": "Product of two infinites sums indexed by arbitrary types.\nSee also `tsum_mul_tsum` if `f` and `g` are *not* absolutely summable. ", "terms": "[\n    \"Product\",\n    \"Infinite sums\",\n    \"Indexed\",\n    \"Arbitrary types\",\n    \"Absolutely summable\"\n]"}
{"type": "∀ {H : Type u_3} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s}", "name": "loc_compact_Haus_tot_disc_of_zero_dim", "isProp": true, "docString": "A locally compact Hausdorff totally disconnected space has a basis with clopen elements. ", "terms": "[\n    \"locally compact\",\n    \"Hausdorff\",\n    \"totally disconnected space\",\n    \"basis\",\n    \"clopen elements\"\n]"}
{"type": "∀ (G : Type u) [inst : AddCommGroup G] [hG : AddGroup.FG G],\n  ∃ n ι x p,\n    ∃ (_ : ∀ (i : ι), Nat.Prime (p i)), ∃ e, Nonempty (G ≃+ (Fin n →₀ ℤ) × DirectSum ι fun i => ZMod (p i ^ e i))", "name": "AddCommGroup.equiv_free_prod_directSum_zmod", "isProp": true, "docString": "**Structure theorem of finitely generated abelian groups** : Any finitely generated abelian\ngroup is the product of a power of `ℤ` and a direct sum of some `ZMod (p i ^ e i)` for some\nprime powers `p i ^ e i`. ", "terms": "[\n    \"Structure theorem of finitely generated abelian groups\",\n    \"finitely generated\",\n    \"abelian group\",\n    \"product\",\n    \"power\",\n    \"ℤ\",\n    \"direct sum\",\n    \"ZMod\",\n    \"prime\",\n    \"prime powers\"\n]"}
{"type": "{α : Type u_1} → Set (Set α) → Prop", "name": "IsPiSystem", "isProp": false, "docString": "A π-system is a collection of subsets of `α` that is closed under binary intersection of\nnon-disjoint sets. Usually it is also required that the collection is nonempty, but we don't do\nthat here. ", "terms": "[\n    \"π-system\",\n    \"collection\",\n    \"subsets\",\n    \"closed\",\n    \"binary intersection\",\n    \"non-disjoint sets\",\n    \"nonempty\"\n]"}
{"type": "{α : Type u_3} →\n  {β : Type u_4} → [inst : Add α] → [inst_1 : Add β] → AddHom α β → (I : Type u_5) → AddHom (I → α) (I → β)", "name": "AddHom.compLeft", "isProp": false, "docString": "Additive semigroup homomorphism between the function spaces `I → α`\nand `I → β`, induced by an additive semigroup homomorphism `f` between `α` and `β`", "terms": "[\n  \"Additive semigroup\",\n  \"Homomorphism\",\n  \"Function spaces\",\n  \"Induced\",\n  \"α\",\n  \"β\",\n  \"I\"\n]"}
{"type": "∀ (b : ℕ), 2 ≤ b → ∀ (f n e : ℕ), n < b ^ e → 0 < e → List.length (Nat.toDigitsCore b f n []) ≤ e", "name": "Nat.to_digits_core_length", "isProp": true, "docString": "The String representation produced by toDigitsCore has the proper length relative to\nthe number of digits in `n < e` for some base `b`. Since this works with any base greater\nthan one, it can be used for binary, decimal, and hex. ", "terms": "[\n    \"String representation\",\n    \"toDigitsCore\",\n    \"length\",\n    \"number of digits\",\n    \"<\",\n    \"base\",\n    \"greater than\",\n    \"binary\",\n    \"decimal\",\n    \"hex\"\n]"}
{"type": "{J K : Type v} →\n  [inst : CategoryTheory.SmallCategory J] →\n    [inst_1 : CategoryTheory.SmallCategory K] →\n      {C : Type u} →\n        [inst_2 : CategoryTheory.Category.{v, u} C] →\n          {F : CategoryTheory.Functor J (CategoryTheory.Functor K C)} →\n            CategoryTheory.Limits.DiagramOfCones F → (j : J) → CategoryTheory.Limits.Cone (F.obj j)", "name": "CategoryTheory.Limits.DiagramOfCones.obj", "isProp": false, "docString": "For each object, a cone. ", "terms": "[\"object\", \"cone\"]"}
{"type": "(ε : Type u) → {m : Type v → Type w} → [inst : MonadExceptOf ε m] → {α : Type v} → ε → m α", "name": "throwThe", "isProp": false, "docString": "This is the same as `throw`, but allows specifying the particular error type\nin case the monad supports throwing more than one type of error.\n", "terms": "[]"}
{"type": "(Δ : SimplexCategoryᵒᵖ) → SimplicialObject.Splitting.IndexSet Δ", "name": "SimplicialObject.Splitting.IndexSet.id", "isProp": false, "docString": "The distinguished element in `Splitting.IndexSet Δ` which corresponds to the\nidentity of `Δ`. ", "terms": "[\n    \"distinguished element\",\n    \"Splitting.IndexSet\",\n    \"corresponds\",\n    \"identity\"\n]"}
{"type": "{V : Type u} →\n  [inst : CategoryTheory.Category.{v, u} V] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] →\n      (C : CochainComplex V ℕ) →\n        {X : V} →\n          (f : X ⟶ HomologicalComplex.X C 0) →\n            (w : CategoryTheory.CategoryStruct.comp f (HomologicalComplex.d C 0 1) = 0) →\n              CochainComplex.truncate.obj (CochainComplex.augment C f w) ≅ C", "name": "CochainComplex.truncateAugment", "isProp": false, "docString": "Truncating an augmented cochain complex is isomorphic (with components the identity)\nto the original complex.\n", "terms": "[\n    \"Truncating\",\n    \"augmented\",\n    \"cochain complex\",\n    \"isomorphic\",\n    \"components\",\n    \"identity\",\n    \"original complex\"\n]"}
{"type": "{α : Type u_1} → [self : SBtw α] → α → α → α → Prop", "name": "SBtw.sbtw", "isProp": false, "docString": "Strict betweenness for circular orders. `sbtw a b c` states that `b` is strictly between `a`\nand `c` (in that order). ", "terms": "[\"Strict betweenness\", \"circular orders\", \"strictly between\"]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {X Y : C} →\n      {f g f' g' : X ⟶ Y} →\n        f = f' → g = g' → (CategoryTheory.Limits.parallelPair f g ≅ CategoryTheory.Limits.parallelPair f' g')", "name": "CategoryTheory.Limits.parallelPair.eqOfHomEq", "isProp": false, "docString": "Construct a natural isomorphism between `parallelPair f g` and `parallelPair f' g'` given\nequalities `f = f'` and `g = g'`. ", "terms": "[\n    \"Construct\",\n    \"natural isomorphism\",\n    \"parallelPair\",\n    \"equalities\"\n]"}
{"type": "∀ {𝓕 : Type u_1} {E : Type u_6} {F : Type u_7} [inst : SeminormedAddGroup E] [inst_1 : SeminormedAddGroup F]\n  [inst_2 : AddMonoidHomClass 𝓕 E F] (f : 𝓕) (C : ℝ), (∀ (x : E), ‖f x‖ ≤ C * ‖x‖) → Continuous ⇑f", "name": "AddMonoidHomClass.continuous_of_bound", "isProp": true, "docString": "A homomorphism `f` of seminormed groups is continuous, if there exists a constant `C`\nsuch that for all `x`, one has `‖f x‖ ≤ C * ‖x‖`", "terms": "[\n  \"homomorphism\",\n  \"seminormed groups\",\n  \"continuous\",\n  \"constant\",\n  \"exists\",\n  \"for all\",\n  \"one has\",\n  \"less than or equal to\",\n  \"times\"\n]"}
{"type": "∀ (V : Type u_2) {P : Type u_3} [inst : SeminormedAddCommGroup V] [inst_1 : PseudoMetricSpace P]\n  [inst_2 : NormedAddTorsor V P] (x y : P), dist x y = ‖x -ᵥ y‖", "name": "dist_eq_norm_vsub", "isProp": true, "docString": "The distance equals the norm of subtracting two points. In this\nlemma, it is necessary to have `V` as an explicit argument; otherwise\n`rw dist_eq_norm_vsub` sometimes doesn't work. ", "terms": "[\n    \"distance\",\n    \"norm\",\n    \"subtracting\",\n    \"points\",\n    \"lemma\",\n    \"argument\",\n    \"dist_eq_norm_vsub\"\n]"}
{"type": "{J : Type w} →\n  {C : Type u} →\n    [inst : CategoryTheory.Category.{v, u} C] →\n      (B : C) →\n        (objs : J → C) → ((j : J) → objs j ⟶ B) → CategoryTheory.Functor (CategoryTheory.Limits.WidePullbackShape J) C", "name": "CategoryTheory.Limits.WidePullbackShape.wideCospan", "isProp": false, "docString": "Construct a functor out of the wide pullback shape given a J-indexed collection of arrows to a\nfixed object.\n", "terms": "[\n    \"functor\",\n    \"wide pullback shape\",\n    \"J-indexed\",\n    \"collection\",\n    \"arrows\",\n    \"fixed object\"\n]"}
{"type": "∀ {α : Type u_1} {β : Type u_6} [inst : MeasurableSpace β] {μ : MeasureTheory.Measure β} {C : β → Set α → Prop}\n  {s : Set (Set α)} [m : MeasurableSpace α],\n  m = MeasurableSpace.generateFrom s →\n    IsPiSystem s →\n      (∀ᵐ (x : β) ∂μ, C x ∅) →\n        (∀ᵐ (x : β) ∂μ, ∀ t ∈ s, C x t) →\n          (∀ᵐ (x : β) ∂μ, ∀ (t : Set α), MeasurableSet t → C x t → C x tᶜ) →\n            (∀ᵐ (x : β) ∂μ,\n                ∀ (f : ℕ → Set α),\n                  Pairwise (Disjoint on f) →\n                    (∀ (i : ℕ), MeasurableSet (f i)) → (∀ (i : ℕ), C x (f i)) → C x (⋃ i, f i)) →\n              ∀ᵐ (x : β) ∂μ, ∀ ⦃t : Set α⦄, MeasurableSet t → C x t", "name": "MeasurableSpace.ae_induction_on_inter", "isProp": true, "docString": "Given a predicate on `β` and `Set α` where both `α` and `β` are measurable spaces, if the\npredicate holds for almost every `x : β` and\n- `∅ : Set α`\n- a family of sets generating the σ-algebra of `α`\nMoreover, if for almost every `x : β`, the predicate is closed under complements and countable\ndisjoint unions, then the predicate holds for almost every `x : β` and all measurable sets of `α`.\n\nThis is an AE version of `MeasurableSpace.induction_on_inter` where the condition is dependent\non a measurable space `β`. ", "terms": "[\n  \"predicate\",\n  \"measurable spaces\",\n  \"almost every\",\n  \"Set\",\n  \"family of sets\",\n  \"σ-algebra\",\n  \"closed under complements\",\n  \"countable disjoint unions\",\n  \"measurable sets\",\n  \"AE\",\n  \"MeasurableSpace.induction_on_inter\",\n  \"condition\",\n  \"dependent\"\n]"}
{"type": "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v, u₂} D] →\n        {S : D} →\n          {T : CategoryTheory.Functor C D} →\n            {A : CategoryTheory.StructuredArrow S T} →\n              (P : CategoryTheory.Subobject A.right) →\n                {q :\n                    (CategoryTheory.Functor.fromPUnit S).obj A.left ⟶\n                      T.obj (CategoryTheory.Subobject.underlying.obj P)} →\n                  CategoryTheory.CategoryStruct.comp q (T.map (CategoryTheory.Subobject.arrow P)) = A.hom →\n                    CategoryTheory.Subobject A", "name": "CategoryTheory.StructuredArrow.liftSubobject", "isProp": false, "docString": "A subobject of the underlying object of a structured arrow can be lifted to a subobject of\nthe structured arrow, provided that there is a morphism making the subobject into a structured\narrow. ", "terms": "[\n    \"subobject\",\n    \"underlying object\",\n    \"structured arrow\",\n    \"lifted\",\n    \"morphism\"\n]"}
{"type": "∀ {α : Type u_1} {ι : Type u_4} [inst : Nonempty ι] (s : Set α) (f : α → ι),\n  (Set.Pairwise s fun x y => f x = f y) ↔ ∃ z, ∀ x ∈ s, f x = z", "name": "Set.pairwise_eq_iff_exists_eq", "isProp": true, "docString": "A function `f : α → ι` with nonempty codomain takes pairwise equal values on a set `s` if and\nonly if for some `z` in the codomain, `f` takes value `z` on all `x ∈ s`. See also\n`Set.Nonempty.pairwise_eq_iff_exists_eq` for a version that assumes `Set.Nonempty s` instead of\n`[Nonempty ι]`. ", "terms": "[\n    \"function\",\n    \"nonempty\",\n    \"codomain\",\n    \"pairwise equal\",\n    \"set\",\n    \"value\",\n    \"Set.Nonempty.pairwise_eq_iff_exists_eq\"\n]"}
{"type": "∀ (R : Type u) (M : Type v) [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] [inst_4 : Module.Finite R M], Module.rank R M < Cardinal.aleph0", "name": "FiniteDimensional.rank_lt_aleph0", "isProp": true, "docString": "The rank of a finite module is finite. ", "terms": "[\"rank\", \"finite\", \"module\"]"}
{"type": "{α : Type u_1} → [inst : Preorder α] → α → α → Prop", "name": "Wcovby", "isProp": false, "docString": "`Wcovby a b` means that `a = b` or `b` covers `a`.\nThis means that `a ≤ b` and there is no element in between.\n", "terms": "[\n    \"equals\",\n    \"covers\",\n    \"element\",\n    \"in between\",\n    \"less than or equal to\"\n]"}
{"type": "∀ {α : Type u_1} [inst : Lattice α] [inst_1 : IsModularLattice α] {β : Type u_2} {γ : Type u_3}\n  [inst_2 : PartialOrder β] [inst_3 : Preorder γ],\n  (WellFounded fun x x_1 => x < x_1) →\n    (WellFounded fun x x_1 => x < x_1) →\n      ∀ (K : α) (f₁ : β → α) (f₂ : α → β) (g₁ : γ → α) (g₂ : α → γ),\n        GaloisCoinsertion f₁ f₂ →\n          GaloisInsertion g₂ g₁ →\n            (∀ (a : α), f₁ (f₂ a) = a ⊓ K) → (∀ (a : α), g₁ (g₂ a) = a ⊔ K) → WellFounded fun x x_1 => x < x_1", "name": "wellFounded_lt_exact_sequence", "isProp": true, "docString": "A generalization of the theorem that if `N` is a submodule of `M` and\n`N` and `M / N` are both Artinian, then `M` is Artinian. ", "terms": "[\n  \"generalization\",\n  \"theorem\",\n  \"submodule\",\n  \"Artinian\"\n]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {S : Type w} [inst_1 : CategoryTheory.SmallCategory S],\n  (C ≌ S) → CategoryTheory.EssentiallySmall.{w, v, u} C", "name": "CategoryTheory.EssentiallySmall.mk'", "isProp": true, "docString": "Constructor for `EssentiallySmall C` from an explicit small category witness. ", "terms": "[\n    \"Constructor\", \n    \"EssentiallySmall\", \n    \"small category\", \n    \"witness\"\n]"}
{"type": "{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      {S₁ S₂ : CategoryTheory.ShortComplex C} →\n        (h₁ : CategoryTheory.ShortComplex.RightHomologyData S₁) →\n          (h₂ : CategoryTheory.ShortComplex.RightHomologyData S₂) →\n            CategoryTheory.ShortComplex.RightHomologyMapData 0 h₁ h₂", "name": "CategoryTheory.ShortComplex.RightHomologyMapData.zero", "isProp": false, "docString": "The right homology map data associated to the zero morphism between two short complexes. ", "terms": "[\n    \"right homology\",\n    \"map\",\n    \"data\",\n    \"associated\",\n    \"zero morphism\",\n    \"between\",\n    \"two\",\n    \"short complexes\"\n]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (F : CategoryTheory.Functor Cᵒᵖ (Type (max u v))) {α : Type}\n  {X : α → C} (c : CategoryTheory.Limits.Cofan X),\n  CategoryTheory.Limits.IsColimit c →\n    ∀\n      [inst_1 :\n        CategoryTheory.Presieve.hasPullbacks (CategoryTheory.Presieve.ofArrows X (CategoryTheory.Limits.Cofan.inj c))]\n      [inst_2 : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Discrete.functor fun x => Opposite.op (X x)) F],\n      CategoryTheory.Presieve.IsSheafFor F (CategoryTheory.Presieve.ofArrows X (CategoryTheory.Limits.Cofan.inj c))", "name": "CategoryTheory.Presieve.isSheafFor_of_preservesProduct", "isProp": true, "docString": "If `F` preserves a particular product, then it `IsSheafFor` the corresponging presieve of arrows.\n", "terms": "[\n    \"Preserves\",\n    \"Product\",\n    \"IsSheafFor\",\n    \"Presieve\",\n    \"Arrows\"\n]"}
{"type": "∀ {R : Type u_1} [inst : Semiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_3}\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {ι : Type u_7} {M₂ : Type u_10} [inst_5 : AddCommMonoid M₂]\n  [inst_6 : Module R M₂] {M₃ : Type u_11} [inst_7 : AddCommMonoid M₃] [inst_8 : Module R M₃] (f : M [Λ^ι]→ₗ[R] N)\n  (g₁ : M₂ →ₗ[R] M) (g₂ : M₃ →ₗ[R] M₂),\n  AlternatingMap.compLinearMap (AlternatingMap.compLinearMap f g₁) g₂ = AlternatingMap.compLinearMap f (g₁ ∘ₗ g₂)", "name": "AlternatingMap.compLinearMap_assoc", "isProp": true, "docString": "Composing an alternating map twice with the same linear map in each argument is\nthe same as composing with their composition. ", "terms": "[\n    \"Composing\",\n    \"Alternating map\",\n    \"Twice\",\n    \"Same\",\n    \"Linear map\",\n    \"Each\",\n    \"Argument\",\n    \"Composition\"\n]"}
{"type": "{R : Type u_4} →\n  {k : ℕ} → [inst : CommRing R] → {ζ : Rˣ} → IsPrimitiveRoot ζ k → ZMod k ≃+ Additive ↥(Subgroup.zpowers ζ)", "name": "IsPrimitiveRoot.zmodEquivZPowers", "isProp": false, "docString": "The (additive) monoid equivalence between `ZMod k`\nand the powers of a primitive root of unity `ζ`. ", "terms": "[\n  \"additive\",\n  \"monoid\",\n  \"equivalence\",\n  \"ZMod\",\n  \"powers\",\n  \"primitive root of unity\"\n]"}
{"type": "∀ {a b : ℝ},\n  a ≤ 0 →\n    ∀ {z : ℂ},\n      |z.im| ≤ b →\n        b ≤ Real.pi / 2 →\n          Complex.abs (Complex.exp (↑a * (Complex.exp z + Complex.exp (-z)))) ≤\n            Real.exp (a * Real.cos b * Real.exp |z.re|)", "name": "Complex.abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le", "isProp": true, "docString": "A supporting lemma for the **Phragmen-Lindelöf principle** in a horizontal strip. If `z : ℂ`\nbelongs to a horizontal strip `|Complex.im z| ≤ b`, `b ≤ π / 2`, and `a ≤ 0`, then\n$$\\left|exp^{a\\left(e^{z}+e^{-z}\\right)}\\right| \\le e^{a\\cos b \\exp^{|re z|}}.$$\n", "terms": "[\n    \"Supporting lemma\",\n    \"Phragmen-Lindelöf principle\",\n    \"Horizontal strip\",\n    \"Complex number\",\n    \"Complex.im\",\n    \"Absolute value\",\n    \"Inequality\",\n    \"Exponential function\",\n    \"Euler's number\",\n    \"Cosine\",\n    \"Complex.re\"\n]"}
{"type": "{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    (J : CategoryTheory.GrothendieckTopology C) →\n      {D : Type w₁} →\n        [inst_1 : CategoryTheory.Category.{max v u, w₁} D] →\n          {E : Type w₂} →\n            [inst_2 : CategoryTheory.Category.{max v u, w₂} E] →\n              [inst_3 :\n                  ∀ (α β : Type (max v u)) (fst snd : β → α),\n                    CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) D] →\n                [inst_4 :\n                    ∀ (α β : Type (max v u)) (fst snd : β → α),\n                      CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) E] →\n                  [inst_5 :\n                      ∀ (X : C),\n                        CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)ᵒᵖ D] →\n                    [inst_6 :\n                        ∀ (X : C),\n                          CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)ᵒᵖ\n                            E] →\n                      (P : CategoryTheory.Functor Cᵒᵖ D) →\n                        [inst_7 :\n                            (F : CategoryTheory.Functor D E) →\n                              (X : C) →\n                                CategoryTheory.Limits.PreservesColimitsOfShape\n                                  (CategoryTheory.GrothendieckTopology.Cover J X)ᵒᵖ F] →\n                          [inst_8 :\n                              (F : CategoryTheory.Functor D E) →\n                                (X : C) →\n                                  (W : CategoryTheory.GrothendieckTopology.Cover J X) →\n                                    (P : CategoryTheory.Functor Cᵒᵖ D) →\n                                      CategoryTheory.Limits.PreservesLimit\n                                        (CategoryTheory.Limits.MulticospanIndex.multicospan\n                                          (CategoryTheory.GrothendieckTopology.Cover.index W P))\n                                        F] →\n                            (CategoryTheory.whiskeringLeft Cᵒᵖ D E).obj\n                                (CategoryTheory.GrothendieckTopology.plusObj J P) ≅\n                              CategoryTheory.Functor.comp ((CategoryTheory.whiskeringLeft Cᵒᵖ D E).obj P)\n                                (CategoryTheory.GrothendieckTopology.plusFunctor J E)", "name": "CategoryTheory.GrothendieckTopology.plusFunctorWhiskerLeftIso", "isProp": false, "docString": "The isomorphism between `P⁺ ⋙ F` and `(P ⋙ F)⁺`, functorially in `F`. ", "terms": "[\n    \"isomorphism\",\n    \"functorially\"\n]"}
{"type": "{n : Type u_3} → {α : Type v} → [inst : AddMonoid α] → [inst_1 : StarAddMonoid α] → StarAddMonoid (Matrix n n α)", "name": "Matrix.instStarAddMonoidMatrixAddMonoid", "isProp": false, "docString": "When `α` is a `*`-additive monoid, `Matrix.star` is also a `*`-additive monoid. ", "terms": "[\n    \"additive monoid\",\n    \"Matrix.star\"\n]"}
{"type": "{M : Type u_5} →\n  [inst : AddMonoid M] →\n    {A : Type u_6} → [inst_1 : SetLike A M] → [inst : AddSubmonoidClass A M] → (S : A) → AddMonoid ↥S", "name": "AddSubmonoidClass.toAddMonoid", "isProp": false, "docString": "An `AddSubmonoid` of an `AddMonoid` inherits an `AddMonoid` structure.", "terms": "[\n    \"AddSubmonoid\",\n    \"AddMonoid\",\n    \"inherits\",\n    \"structure\"\n]"}
{"type": "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : ℂ → E},\n  DiffContOnCl ℂ f (Set.Ioi 0 ×ℂ Set.Ioi 0) →\n    (∃ c < 2,\n        ∃ B,\n          f =O[Bornology.cobounded ℂ ⊓ Filter.principal (Set.Ioi 0 ×ℂ Set.Ioi 0)] fun z =>\n            Real.exp (B * Complex.abs z ^ c)) →\n      (∀ (x : ℝ), 0 ≤ x → f ↑x = 0) →\n        (∀ (x : ℝ), 0 ≤ x → f (↑x * Complex.I) = 0) → Set.EqOn f 0 {z | 0 ≤ z.re ∧ 0 ≤ z.im}", "name": "PhragmenLindelof.eq_zero_on_quadrant_I", "isProp": true, "docString": "**Phragmen-Lindelöf principle** in the first quadrant. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the first quadrant.\n\nThen `f` is equal to zero on the closed first quadrant. ", "terms": "[\n \"Phragmen-Lindelöf principle\",\n \"first quadrant\",\n \"function\",\n \"differentiable\",\n \"open\",\n \"continuous\",\n \"closure\",\n \"bounded from above\",\n \"exp\",\n \"abs\",\n \"boundary\",\n \"equal to zero\",\n \"closed\"\n]"}
{"type": "{X : TopCat} →\n  {T : ↑X → Type v} → TopCat.PrelocalPredicate T → {U : TopologicalSpace.Opens ↑X} → ((x : ↥U) → T ↑x) → Prop", "name": "TopCat.PrelocalPredicate.pred", "isProp": false, "docString": "The underlying predicate of a prelocal predicate ", "terms": "[\n  \"underlying\",\n  \"predicate\",\n  \"prelocal\"\n]"}
{"type": "∀ {α : Type u_6} {β : Type u_7} [inst : Preorder α] [inst_1 : Preorder β] [inst_2 : AddZeroClass α]\n  [inst_3 : AddZeroClass β] (self : α →+o β), Monotone self.toFun", "name": "OrderAddMonoidHom.monotone'", "isProp": true, "docString": "An `OrderAddMonoidHom` is a monotone function. ", "terms": "[\n  \"OrderAddMonoidHom\",\n  \"monotone function\"\n]"}
{"type": "{α : Type u} → {β : Type v} → α ≃ β → [inst : AddGroup β] → AddGroup α", "name": "Equiv.addGroup", "isProp": false, "docString": "Transfer `AddGroup` across an `Equiv`", "terms": "[\n\"Transfer\",\n\"AddGroup\",\n\"Equiv\"\n]"}
{"type": "(l : Type u_4) →\n  (R : Type u₂) →\n    [inst : DecidableEq l] → [inst_1 : CommRing R] → [inst_2 : Fintype l] → LieSubalgebra R (Matrix (l ⊕ l) (l ⊕ l) R)", "name": "LieAlgebra.Symplectic.sp", "isProp": false, "docString": "The symplectic Lie algebra: skew-adjoint matrices with respect to the canonical skew-symmetric\nbilinear form. ", "terms": "[\n    \"Symplectic Lie algebra\",\n    \"Skew-adjoint matrices\",\n    \"Canonical skew-symmetric\",\n    \"Bilinear form\"\n]"}
{"type": "∀ {R : Type uR} {A : Type uA} {M : Type uM} {N : Type uN} {P : Type uP} [inst : CommSemiring R] [inst_1 : Semiring A]\n  [inst_2 : Algebra R A] [inst_3 : AddCommMonoid M] [inst_4 : Module R M] [inst_5 : Module A M]\n  [inst_6 : IsScalarTower R A M] [inst_7 : AddCommMonoid N] [inst_8 : Module R N] [inst_9 : AddCommMonoid P]\n  [inst_10 : Module R P] [inst_11 : Module A P] [inst_12 : IsScalarTower R A P],\n  Function.Injective TensorProduct.AlgebraTensorModule.curry", "name": "TensorProduct.AlgebraTensorModule.curry_injective", "isProp": true, "docString": "Just as `TensorProduct.ext` is marked `ext` instead of `TensorProduct.ext'`, this is\na better `ext` lemma than `TensorProduct.AlgebraTensorModule.ext` below.\n\nSee note [partially-applied ext lemmas]. ", "terms": "[\n    \"TensorProduct\",\n    \"ext\",\n    \"lemma\",\n    \"TensorProduct.AlgebraTensorModule.ext\",\n    \"partially-applied ext lemmas\"\n]"}
{"type": "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b : α}, a ≤ 1 → b ≤ 1 → a * b ≤ 1", "name": "Left.mul_le_one", "isProp": true, "docString": "Assumes left covariance.\nThe lemma assuming right covariance is `Right.mul_le_one`. ", "terms": "[\"left covariance\", \"lemma\", \"right covariance\", \"Right.mul_le_one\"]"}
{"type": "{R : Type u_2} →\n  {M₁ : Type u_5} →\n    {M₂ : Type u_6} →\n      [inst : CommSemiring R] →\n        [inst_1 : AddCommMonoid M₁] →\n          [inst_2 : AddCommMonoid M₂] →\n            [inst_3 : Module R M₁] →\n              [inst_4 : Module R M₂] →\n                {Q₁ : QuadraticForm R M₁} →\n                  {Q₂ : QuadraticForm R M₂} → QuadraticForm.IsometryEquiv Q₁ Q₂ → QuadraticForm.IsometryEquiv Q₂ Q₁", "name": "QuadraticForm.IsometryEquiv.symm", "isProp": false, "docString": "The inverse isometric equivalence of an isometric equivalence between two quadratic forms. ", "terms": "[\n    \"Inverse\",\n    \"Isometric equivalence\",\n    \"Isometric\",\n    \"Equivalence\",\n    \"Quadratic forms\"\n]"}
{"type": "∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X : C} (S : CategoryTheory.Sieve X),\n  (∀ (W : C), CategoryTheory.Presieve.IsSheafFor (CategoryTheory.yoneda.obj W) S.arrows) ↔\n    Nonempty (CategoryTheory.Limits.IsColimit (CategoryTheory.Presieve.cocone S.arrows))", "name": "CategoryTheory.Sieve.forallYonedaIsSheaf_iff_colimit", "isProp": true, "docString": "The base of a sieve `S` is a colimit of `S` iff all Yoneda-presheaves satisfy\nthe sheaf condition for `S`.\n", "terms": "[\n    \"base\",\n    \"sieve\",\n    \"colimit\",\n    \"Yoneda-presheaves\",\n    \"satisfy\",\n    \"sheaf condition\"\n]"}
{"type": "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] {μ : MeasureTheory.Measure α}\n  [inst_2 : MeasureTheory.Measure.Regular μ], MeasureTheory.Measure.InnerRegularCompactLTTop μ", "name": "MeasureTheory.Measure.Regular.instInnerRegularCompactLTTop", "isProp": true, "docString": "If `μ` is a regular measure, then any measurable set of finite measure can be approximated by a\ncompact subset. See also `MeasurableSet.exists_isCompact_lt_add` and\n`MeasurableSet.exists_lt_isCompact_of_ne_top`. ", "terms": "[\n  \"regular measure\",\n  \"measurable set\",\n  \"finite measure\",\n  \"approximated\",\n  \"compact subset\"\n]"}
{"type": "{I : Type w₁} →\n  {C : I → Type u₁} →\n    [inst : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)] →\n      {D : I → Type u₁} →\n        [inst_1 : (i : I) → CategoryTheory.Category.{v₁, u₁} (D i)] →\n          {F G : (i : I) → CategoryTheory.Functor (C i) (D i)} →\n            ((i : I) → F i ⟶ G i) → (CategoryTheory.Sigma.Functor.sigma F ⟶ CategoryTheory.Sigma.Functor.sigma G)", "name": "CategoryTheory.Sigma.natTrans.sigma", "isProp": false, "docString": "Assemble an `I`-indexed family of natural transformations into a single natural transformation.\n", "terms": "[\n    \"indexed family\",\n    \"natural transformations\",\n    \"single natural transformation\"\n]"}
{"type": "{α : Type u_1} → [inst : Preorder α] → α → α → Set α", "name": "Set.Ico", "isProp": false, "docString": "Left-closed right-open interval ", "terms": "[\n    \"Left-closed\",\n    \"Right-open\",\n    \"Interval\"\n]"}
{"type": "{M : Type u_1} →\n  [inst : AddCommMonoid M] →\n    {S : AddSubmonoid M} →\n      {r : AddLocalization S → AddLocalization S → Sort u} →\n        [h : ∀ (a c : M) (b d : ↥S), Subsingleton (r (AddLocalization.mk a b) (AddLocalization.mk c d))] →\n          (x y : AddLocalization S) →\n            ((a c : M) → (b d : ↥S) → r (AddLocalization.mk a b) (AddLocalization.mk c d)) → r x y", "name": "AddLocalization.recOnSubsingleton₂", "isProp": false, "docString": "Copy of `Quotient.recOnSubsingleton₂` for `AddLocalization`", "terms": "[\"Quotient.recOnSubsingleton₂\", \"AddLocalization\"]"}
{"type": "{K : Type u_1} →\n  {V : Type u_2} →\n    [inst : DivisionRing K] → [inst_1 : AddCommGroup V] → [inst_2 : Module K V] → Projectivization K V → Submodule K V", "name": "Projectivization.submodule", "isProp": false, "docString": "Consider an element of the projectivization as a submodule of `V`. ", "terms": "[\n    \"element\",\n    \"projectivization\",\n    \"submodule\"\n]"}
