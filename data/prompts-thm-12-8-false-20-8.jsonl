{"text": "If every proper closed set of a topological space is compact, then the space itself is compact.", "fullPrompt": "/-- A closed subset of a compact set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) : is_compact t :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) : is_compact (s ∩ t) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s) : is_compact (s ∩ t) :=\n\n/-- In a `t2_space`, every compact set is closed. -/\ntheorem {α : Type u} [topological_space α] [t2_space α] {s : set α} (hs : is_compact s) : is_closed s :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem {α : Type u} [topological_space α] [locally_compact_space α] {K : set α} (hK : is_compact K) : ∃ (K' : set α), is_compact K' ∧ K ⊆ interior K' :=\n\n/-- In a locally compact T₂ space, every point has an open neighborhood with compact closure -/\ntheorem {α : Type u} [topological_space α] [locally_compact_space α] [t2_space α] (x : α) : ∃ (U : set α), is_open U ∧ x ∈ U ∧ is_compact (closure U) :=\n\n/--  A closed embedding is proper, ie, inverse images of compact sets are contained in compacts. Moreover, the preimage of a compact set is compact, see `closed_embedding.is_compact_preimage`. -/\ntheorem {α : Type u} {β : Type v} [topological_space α] [topological_space β] {f : α → β} (hf : closed_embedding f) : filter.tendsto f (filter.cocompact α) (filter.cocompact β) :=\n\n/--  Every separated topological group in which there exists a compact set with nonempty interior is locally compact. -/\ntheorem {G : Type w} [topological_space G] [group G] [topological_group G] [t2_space G] (K : topological_space.positive_compacts G) : locally_compact_space G :=\n\n/-- A compact set is bounded above -/\ntheorem {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] [nonempty α] {s : set α} (hs : is_compact s) : bdd_above s :=\n\n/-- A locally compact Hausdorff space is totally disconnected  if and only if it is totally separated. -/\ntheorem {H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] : totally_disconnected_space H ↔ totally_separated_space H :=\n\n/-- An unordered closed interval is compact. -/\ntheorem {α : Type u_1} [linear_order α] [topological_space α] [compact_Icc_space α] {a b : α} : is_compact (set.interval a b) :=\n\n/-- If X is is_compact then pr₂ : X × Y → Y is a closed map -/\ntheorem {X : Type u_1} [topological_space X] [compact_space X] {Y : Type u_2} [topological_space Y] : is_closed_map prod.snd :=\n\n/-- If every proper closed set of a topological space is compact, then the space itself is compact. -/\ntheorem "}
{"text": "Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.", "fullPrompt": "/--  **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- When `p ∤ a`, then `legendre_sym p a = 1` iff `a` is a square mod `p`. -/\ntheorem (p : ℕ) [fact (nat.prime p)] {a : ℤ} (ha0 : ↑a ≠ 0) : zmod.legendre_sym p a = 1 ↔ is_square ↑a :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F = 2) (a : F) : is_square a :=\n\n/-- There are no perfect squares strictly between m² and (m+1)² -/\ntheorem {n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬∃ (t : ℕ), t * t = n :=\n\n/-- A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` -/\ntheorem (p : ℕ) [hp : fact (nat.prime p)] : prime ↑p ↔ p % 4 = 3 :=\n\n/-- The Legendre symbol of `a^2` at `p` is 1 if `p ∤ a`. -/\ntheorem (p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_sym p (a ^ 2) = 1 :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem {α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0 :=\n\n/-- Euler's Criterion: a nonzero `a : zmod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem (p : ℕ) [fact (nat.prime p)] {a : zmod p} (ha : a ≠ 0) : is_square a ↔ a ^ (p / 2) = 1 :=\n\n/-- **Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. -/\ntheorem (p : ℕ) [fact (nat.prime p)] : ↑((p - 1).factorial) = -1 :=\n\n/-- The number of square roots of `a` modulo `p` is determined by the Legendre symbol. -/\ntheorem (p : ℕ) [fact (nat.prime p)] (hp : p ≠ 2) (a : ℤ) : ↑({x : zmod p | x ^ 2 = ↑a}.to_finset.card) = zmod.legendre_sym p a + 1 :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n\n/-- Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares. -/\ntheorem "}
{"text": "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.", "fullPrompt": "/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem {α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0 :=\n\n/--  **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p :=\n\n/--  Pythagorean triples are interchangable, i.e `x * x + y * y = y * y + x * x = z * z`. This comes from additive commutativity. -/\ntheorem {x y z : ℤ} : pythagorean_triple x y z ↔ pythagorean_triple y x z :=\n\n/-- The zeroth Pythagorean triple is all zeros. -/\ntheorem  : pythagorean_triple 0 0 0 :=\n\n/-- There are no perfect squares strictly between m² and (m+1)² -/\ntheorem {n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬∃ (t : ℕ), t * t = n :=\n\n/--  `(k*x, k*y, k*z)` is a Pythagorean triple if and only if `(x, y, z)` is also a triple. -/\ntheorem {x y z : ℤ} (k : ℤ) (hk : k ≠ 0) : pythagorean_triple (k * x) (k * y) (k * z) ↔ pythagorean_triple x y z :=\n\n/-- Composing two additions on the left by `y` then `x` is equal to a addition on the left by `x + y`. -/\ntheorem {α : Type u_1} [add_semigroup α] (x y : α) : has_add.add x ∘ has_add.add y = has_add.add (x + y) :=\n\n/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- For any natural numbers n, a, and b, one of the following holds: 1. n < a 2. n ≥ b 3. n ∈ Ico a b -/\ntheorem (n a b : ℕ) : n < a ∨ b ≤ n ∨ n ∈ list.Ico a b :=\n\n/-- Composing two multiplications on the left by `y` then `x` is equal to a multiplication on the left by `x * y`. -/\ntheorem {α : Type u_1} [semigroup α] (x y : α) : has_mul.mul x ∘ has_mul.mul y = has_mul.mul (x * y) :=\n\n/-- Composing two additions on the right by `y` and `x` is equal to a addition on the right by `y + x`. -/\ntheorem {α : Type u_1} [add_semigroup α] (x y : α) : ((λ (_x : α), _x + x) ∘ λ (_x : α), _x + y) = λ (_x : α), _x + (y + x) :=\n\n/-- Composing two multiplications on the right by `y` and `x` is equal to a multiplication on the right by `y * x`. -/\ntheorem {α : Type u_1} [semigroup α] (x y : α) : ((λ (_x : α), _x * x) ∘ λ (_x : α), _x * y) = λ (_x : α), _x * (y * x) :=\n\n/-- The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares. -/\ntheorem "}
{"text": "A ring with all elements idempotent is commutative.", "fullPrompt": "/-- The identity map is a ring homomorphism. -/\ntheorem {α : Type u} [ring α] : is_ring_hom id :=\n\n/-- An element of a ring multiplied by the additive inverse of one is the element's additive  inverse. -/\ntheorem {α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : a * -1 = -a :=\n\n/-- Compressing an element is idempotent. -/\ntheorem {α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v a : α) : uv.compress u v (uv.compress u v a) = uv.compress u v a :=\n\n/-- The additive inverse of one multiplied by an element of a ring is the element's additive  inverse. -/\ntheorem {α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : (-1) * a = -a :=\n\n/-- Left multiplication in a ring is an additive monoid morphism. -/\ntheorem {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), x * y) :=\n\n/-- Right multiplication in a ring is an additive monoid morphism. -/\ntheorem {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), y * x) :=\n\n/-- The identity map is an additive monoid homomorphism. -/\ntheorem {α : Type u} [add_zero_class α] : is_add_monoid_hom id :=\n\n/-- Commuting elements of finite additive order are closed under addition. -/\ntheorem {G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y) :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem (R : Type u) [non_assoc_ring R] (p : ℕ) [hc : char_p R p] [fintype R] : p ≠ 0 :=\n\n/-- Ring homomorphisms preserve additive inverses. -/\ntheorem {α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} {x : α} (hf : is_ring_hom f) : f (-x) = -f x :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- Any element commutes with itself. -/\ntheorem {S : Type u_1} [has_mul S] (a : S) : commute a a :=\n\n/-- A ring with all elements idempotent is commutative. -/\ntheorem "}
{"text": "There are infinitely many pairs of primes that differ exactly by `2`.", "fullPrompt": "/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem  : set.inj_on nat.factorization {x : ℕ | x ≠ 0} :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1 :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`. -/\ntheorem (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p :=\n\n/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- A version of `nat.exists_infinite_primes` using the `bdd_above` predicate. -/\ntheorem  : ¬bdd_above {p : ℕ | nat.prime p} :=\n\n/-- There are no perfect squares strictly between m² and (m+1)² -/\ntheorem {n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬∃ (t : ℕ), t * t = n :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime dividing it. -/\ntheorem {n : ℕ} : is_prime_pow n ↔ ∃! (p : ℕ), nat.prime p ∧ p ∣ n :=\n\n/-- If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. -/\ntheorem (p' : ℕ) : 2 < lucas_lehmer.q (p' + 2) :=\n\n/-- The Legendre symbol of `p` and `a` is zero iff `p ∣ a`. -/\ntheorem (p : ℕ) [fact (nat.prime p)] (a : ℤ) : zmod.legendre_sym p a = 0 ↔ ↑a = 0 :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a natural `k` such that `n` can be written as `p^(k+1)`. -/\ntheorem {R : Type u_1} [comm_monoid_with_zero R] (n : R) : is_prime_pow n ↔ ∃ (p : R) (k : ℕ), prime p ∧ p ^ (k + 1) = n :=\n\n/--  **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p :=\n\n/-- There are infinitely many pairs of primes that differ exactly by `2`. -/\ntheorem "}
{"text": "Every finite division ring is a field.", "fullPrompt": "/-- A division_ring is one-dimensional as a vector space over itself. -/\ntheorem (K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1 :=\n\n/-- A module over a division ring is noetherian if and only if it is finitely generated. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V ↔ module.finite K V :=\n\n/--  A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p :=\n\n/--  A prime `p` is a unit in a finite commutative ring `R` iff it does not divide the characteristic. -/\ntheorem (R : Type u_1) [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : is_unit ↑p ↔ ¬p ∣ ring_char R :=\n\n/-- A field extension is integral if it is finite. -/\ntheorem (K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite_dimensional K L] : algebra.is_integral K L :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem {α : Type u_1} [fintype α] [field α] : is_prime_pow (fintype.card α) :=\n\n/-- If an element a divides another element b in a commutative ring, a divides the sum of b and  another element c iff a divides c. -/\ntheorem {α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ b) : a ∣ b + c ↔ a ∣ c :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem (R : Type u) [non_assoc_ring R] (p : ℕ) [hc : char_p R p] [fintype R] : p ≠ 0 :=\n\n/-- `polynomial R` is never a field for any ring `R`. -/\ntheorem {R : Type u} [ring R] : ¬is_field (polynomial R) :=\n\n/-- Elements of finite additive order are closed under addition. -/\ntheorem {G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y) :=\n\n/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem {Γ₀ : Type u_3} [linear_ordered_comm_monoid_with_zero Γ₀] [nontrivial Γ₀] {K : Type u_1} [division_ring K] (v : valuation K Γ₀) {x : K} : ⇑v x = 0 ↔ x = 0 :=\n\n/--  In a noetherian module over a division ring, if a basis is indexed by a set, that set is finite. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type u_1} {s : set ι} [is_noetherian K V] (b : basis ↥s K V) : s.finite :=\n\n/--  Over a characteristic-zero division ring, the centroids of two faces of a simplex are equal if and only if those faces are given by the same subset of points. -/\ntheorem {k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [char_zero k] {n : ℕ} (s : affine.simplex k P n) {fs₁ fs₂ : finset (fin (n + 1))} {m₁ m₂ : ℕ} (h₁ : fs₁.card = m₁ + 1) (h₂ : fs₂.card = m₂ + 1) : finset.centroid k finset.univ (s.face h₁).points = finset.centroid k finset.univ (s.face h₂).points ↔ fs₁ = fs₂ :=\n\n/--  The dimension of a noetherian module over a division ring, as a cardinal, is strictly less than the first infinite cardinal `ℵ₀`. -/\ntheorem (K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [is_noetherian K V] : module.rank K V < cardinal.aleph_0 :=\n\n/--  Over a characteristic-zero division ring, the centroids given by two subsets of the points of a simplex are equal if and only if those faces are given by the same subset of points. -/\ntheorem {k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [char_zero k] {n : ℕ} (s : affine.simplex k P n) {fs₁ fs₂ : finset (fin (n + 1))} {m₁ m₂ : ℕ} (h₁ : fs₁.card = m₁ + 1) (h₂ : fs₂.card = m₂ + 1) : finset.centroid k fs₁ s.points = finset.centroid k fs₂ s.points ↔ fs₁ = fs₂ :=\n\n/-- Every finite division ring is a field. -/\ntheorem "}
{"text": "If each of two types can be mapped injectively into the other, then there is a bijection between them.", "fullPrompt": "/--  **The Schröder-Bernstein Theorem**: Given injections `α → β` and `β → α`, we can get a bijection `α → β`. -/\ntheorem {α : Type u} {β : Type v} {f : α → β} {g : β → α} (hf : function.injective f) (hg : function.injective g) : ∃ (h : α → β), function.bijective h :=\n\n/-- A binary injective function is injective when only the right argument varies. -/\ntheorem {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) (a : α) : function.injective (f a) :=\n\n/-- A binary injective function is injective when only the left argument varies. -/\ntheorem {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) (b : β) : function.injective (λ (a : α), f a b) :=\n\n/-- `option.map f` is injective if `f` is injective. -/\ntheorem {α : Type u_1} {β : Type u_2} {f : α → β} (Hf : function.injective f) : function.injective (option.map f) :=\n\n/--  `fin` as a map from `ℕ` to `Type` is injective. Note that since this is a statement about equality of types, using it should be avoided if possible. -/\ntheorem  : function.injective fin :=\n\n/--  An injective function from a nontrivial type has an argument at which it does not take a given value. -/\ntheorem {α : Type u_1} {β : Type u_2} [nontrivial α] {f : α → β} (hf : function.injective f) (y : β) : ∃ (x : α), f x ≠ y :=\n\n/-- Composition by an bijective function on the left is itself bijective. -/\ntheorem {α : Sort u} {β : Sort v} {γ : Sort w} {g : β → γ} (hg : function.bijective g) : function.bijective (function.comp g) :=\n\n/-- Composition by an injective function on the left is itself injective. -/\ntheorem {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {g : β → γ} (hg : function.injective g) : function.injective (function.comp g) :=\n\n/--  If the codomain of an injective function is a subsingleton, then the domain is a subsingleton as well. -/\ntheorem {α : Sort u} {β : Sort v} {f : α → β} (hf : function.injective f) [subsingleton β] : subsingleton α :=\n\n/-- The canonical injection from the type to the free group is an injection. -/\ntheorem {α : Type u} : function.injective free_group.of :=\n\n/-- If `x` and `y` are joined in the set `F`, then they are joined in the subtype `F`. -/\ntheorem {X : Type u_1} [topological_space X] {x y : X} {F : set X} (h : joined_in F x y) : joined ⟨x, _⟩ ⟨y, _⟩ :=\n\n/-- There is no surjection from `α : Type u` into `Type u`. This theorem  demonstrates why `Type : Type` would be inconsistent in Lean. -/\ntheorem {α : Type u} (f : α → Type (max u v)) : ¬function.surjective f :=\n\n/-- If each of two types can be mapped injectively into the other, then there is a bijection between them. -/\ntheorem "}
{"text": "A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.", "fullPrompt": "/--  This lemma characterizes discrete topological spaces as those whose singletons are neighbourhoods. -/\ntheorem {X : Type u_1} [topological_space X] : discrete_topology X ↔ nhds = has_pure.pure :=\n\n/-- Given binary relations `r, s` with `r` contained in `s`, the smallest congruence relation    containing `s` contains the smallest congruence relation containing `r`. -/\ntheorem {M : Type u_1} [has_mul M] {r s : M → M → Prop} (h : ∀ (x y : M), r x y → s x y) : con_gen r ≤ con_gen s :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there  is some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. -/\ntheorem {X : Type u_1} [topological_space X] (hX : ∀ {x y : X}, x ≠ y → (∃ (U : set X) (h_clopen : is_clopen U), x ∈ U ∧ y ∉ U)) : is_totally_disconnected set.univ :=\n\n/-- Given binary relations `r, s` with `r` contained in `s`, the smallest additive congruence relation containing `s` contains the smallest additive congruence relation containing `r`. -/\ntheorem {M : Type u_1} [has_add M] {r s : M → M → Prop} (h : ∀ (x y : M), r x y → s x y) : add_con_gen r ≤ add_con_gen s :=\n\n/-- If `s.nth n = some aₙ` for some value `aₙ`, then there is also some value `aₘ` such that `s.nth = some aₘ` for `m ≤ n`. -/\ntheorem {α : Type u} (s : seq α) {aₙ : α} {n m : ℕ} (m_le_n : m ≤ n) (s_nth_eq_some : s.nth n = option.some aₙ) : ∃ (aₘ : α), s.nth m = option.some aₘ :=\n\n/-- If a category has all coproducts then in particular it has finite coproducts. -/\ntheorem (C : Type u) [category_theory.category C] [category_theory.limits.has_coproducts C] : category_theory.limits.has_finite_coproducts C :=\n\n/-- The directed sUnion of a set S of preconnected subsets is preconnected. -/\ntheorem {α : Type u} [topological_space α] {S : set (set α)} (K : directed_on has_subset.subset S) (H : ∀ (s : set α), s ∈ S → is_preconnected s) : is_preconnected (⋃₀S) :=\n\n/-- A space is totally disconnected iff its connected components are singletons. -/\ntheorem {α : Type u} [topological_space α] : totally_disconnected_space α ↔ ∀ (x : α), connected_component x = {x} :=\n\n/-- Given a map `f : N → M` and an equivalence relation `r` on `β`, the equivalence relation    induced on `α` by `f` equals the kernel of `r`'s quotient map composed with `f`. -/\ntheorem {α : Type u_1} {β : Type u_2} {f : α → β} {r : setoid β} : setoid.comap f r = setoid.ker (quotient.mk ∘ f) :=\n\n/-- Two elements are related by an additive congruence relation `c` iff they are represented by the same element of the quotient by `c`. -/\ntheorem {M : Type u_1} [has_add M] (c : add_con M) {a b : M} : ↑a = ↑b ↔ ⇑c a b :=\n\n/--  The neighbourhoods {γ | γ < γ₀} of 0 form a directed set indexed by the invertible elements γ₀. -/\ntheorem (Γ₀ : Type u_1) [linear_ordered_comm_group_with_zero Γ₀] : directed ge (λ (γ₀ : Γ₀ˣ), filter.principal {γ : Γ₀ | γ < ↑γ₀}) :=\n\n/-- If `C` has an initial object and binary coproducts, then it has finite coproducts. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_initial C] : category_theory.limits.has_finite_coproducts C :=\n\n/-- The pseudoelement induced by an arrow is zero precisely when that arrow is zero -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (a : category_theory.over P) : ↑a = 0 ↔ a.hom = 0 :=\n\n/--  The Monge plane associated with vertices `i₁` and `i₂` equals that associated with `i₂` and `i₁`. -/\ntheorem {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P (n + 2)) (i₁ i₂ : fin (n + 3)) : s.monge_plane i₁ i₂ = s.monge_plane i₂ i₁ :=\n\n/--  Suppose all distances from `p₁` and `p₂` to the points of a simplex are equal, and that `p₁` and `p₂` lie in the affine span of `p` with the vertices of that simplex.  Then `p₁` and `p₂` are equal or reflections of each other in the affine span of the vertices of the simplex. -/\ntheorem {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} {s : affine.simplex ℝ P n} {p p₁ p₂ : P} {r : ℝ} (hp₁ : p₁ ∈ affine_span ℝ (has_insert.insert p (set.range s.points))) (hp₂ : p₂ ∈ affine_span ℝ (has_insert.insert p (set.range s.points))) (h₁ : ∀ (i : fin (n + 1)), has_dist.dist (s.points i) p₁ = r) (h₂ : ∀ (i : fin (n + 1)), has_dist.dist (s.points i) p₂ = r) : p₁ = p₂ ∨ p₁ = ⇑(euclidean_geometry.reflection (affine_span ℝ (set.range s.points))) p₂ :=\n\n/--  Suppose we are given a triangle `t₁`, and replace one of its vertices by its orthocenter, yielding triangle `t₂` (with vertices not necessarily listed in the same order).  Then an altitude of `t₂` from a vertex that was not replaced is the corresponding side of `t₁`. -/\ntheorem {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {t₁ t₂ : affine.triangle ℝ P} {i₁ i₂ i₃ j₁ j₂ j₃ : fin 3} (hi₁₂ : i₁ ≠ i₂) (hi₁₃ : i₁ ≠ i₃) (hi₂₃ : i₂ ≠ i₃) (hj₁₂ : j₁ ≠ j₂) (hj₁₃ : j₁ ≠ j₃) (hj₂₃ : j₂ ≠ j₃) (h₁ : t₂.points j₁ = t₁.orthocenter) (h₂ : t₂.points j₂ = t₁.points i₂) (h₃ : t₂.points j₃ = t₁.points i₃) : affine.simplex.altitude t₂ j₂ = affine_span ℝ {t₁.points i₁, t₁.points i₂} :=\n\n/--  Suppose we are given a triangle `t₁`, and replace one of its vertices by its orthocenter, yielding triangle `t₂` (with vertices not necessarily listed in the same order).  Then the orthocenter of `t₂` is the vertex of `t₁` that was replaced. -/\ntheorem {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {t₁ t₂ : affine.triangle ℝ P} {i₁ i₂ i₃ j₁ j₂ j₃ : fin 3} (hi₁₂ : i₁ ≠ i₂) (hi₁₃ : i₁ ≠ i₃) (hi₂₃ : i₂ ≠ i₃) (hj₁₂ : j₁ ≠ j₂) (hj₁₃ : j₁ ≠ j₃) (hj₂₃ : j₂ ≠ j₃) (h₁ : t₂.points j₁ = t₁.orthocenter) (h₂ : t₂.points j₂ = t₁.points i₂) (h₃ : t₂.points j₃ = t₁.points i₃) : t₂.orthocenter = t₁.points i₁ :=\n\n/-- In a graph, if `k` is at least the degree of every vertex, then it is at least the maximum degree. -/\ntheorem {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (k : ℕ) (h : ∀ (v : V), G.degree v ≤ k) : G.max_degree ≤ k :=\n\n/-- In a nonempty graph, if `k` is at most the degree of every vertex, it is at most the minimum degree. Note the assumption that the graph is nonempty is necessary as long as `G.min_degree` is defined to be a natural. -/\ntheorem {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [nonempty V] (k : ℕ) (h : ∀ (v : V), k ≤ G.degree v) : k ≤ G.min_degree :=\n\n/--  The **closed graph theorem** : a linear map between two Banach spaces whose graph is closed is continuous. -/\ntheorem {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] [complete_space F] [complete_space E] (g : E →ₗ[𝕜] F) (hg : is_closed ↑(g.graph)) : continuous ⇑g :=\n\n/-- The minimum degree in the graph is at most the degree of any particular vertex. -/\ntheorem {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (v : V) : G.min_degree ≤ G.degree v :=\n\n/-- When `t` is supported on `s`, `f ∈ s.dfinsupp t` precisely means that `f` is pointwise in `t`. -/\ntheorem {ι : Type u_1} {α : ι → Type u_2} [decidable_eq ι] [Π (i : ι), has_zero (α i)] {s : finset ι} {f : Π₀ (i : ι), α i} [Π (i : ι), decidable_eq (α i)] {t : Π₀ (i : ι), finset (α i)} (ht : t.support ⊆ s) : f ∈ s.dfinsupp ⇑t ↔ ∀ (i : ι), ⇑f i ∈ ⇑t i :=\n\n/-- When `t` is supported on `s`, `f ∈ s.finsupp t` precisely means that `f` is pointwise in `t`. -/\ntheorem {ι : Type u_1} {α : Type u_2} [has_zero α] {s : finset ι} {f : ι →₀ α} {t : ι →₀ finset α} (ht : t.support ⊆ s) : f ∈ s.finsupp ⇑t ↔ ∀ (i : ι), ⇑f i ∈ ⇑t i :=\n\n/--  A linear operator on a complex inner product space is self-adjoint precisely when `⟪T v, v⟫_ℂ` is real for all v. -/\ntheorem {V : Type u_4} [inner_product_space ℂ V] (T : V →ₗ[ℂ] V) : inner_product_space.is_self_adjoint T ↔ ∀ (v : V), ⇑(star_ring_end ℂ) (has_inner.inner (⇑T v) v) = has_inner.inner (⇑T v) v :=\n\n/--  For positive values, the derivative of the `n`-th auxiliary function `f_aux n` (given in this statement in unfolded form) is the `n+1`-th auxiliary function, since the polynomial `P_aux (n+1)` was chosen precisely to ensure this. -/\ntheorem (n : ℕ) (x : ℝ) (hx : x ≠ 0) : has_deriv_at (λ (x : ℝ), polynomial.eval x (exp_neg_inv_glue.P_aux n) * real.exp (-x⁻¹) / x ^ (2 * n)) (polynomial.eval x (exp_neg_inv_glue.P_aux (n + 1)) * real.exp (-x⁻¹) / x ^ (2 * (n + 1))) x :=\n\n/-- A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices. -/\ntheorem "}
{"text": "The number of partitions with odd parts is equal to the number of partitions with distinct parts.", "fullPrompt": "/--  If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive. -/\ntheorem {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0 :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n\n/-- **Alias** of the forward direction of odd_iff_exists_bit1`. -/\ntheorem {α : Type u_2} [semiring α] {a : α} : odd a → (∃ (b : α), a = bit1 b) :=\n\n/-- Odd Bernoulli numbers (greater than 1) are zero. -/\ntheorem {n : ℕ} (h_odd : odd n) (hlt : 1 < n) : bernoulli' n = 0 :=\n\n/--  Two compositions (possibly of different integers) coincide if and only if they have the same sequence of blocks. -/\ntheorem {c c' : Σ (n : ℕ), composition n} : c = c' ↔ c.snd.blocks = c'.snd.blocks :=\n\n/-- Two holors are equal if all their slices are equal. -/\ntheorem {α : Type} {d : ℕ} {ds : list ℕ} (x y : holor α (d :: ds)) (h : x.slice = y.slice) : x = y :=\n\n/-- The cardinality of the antidiagonal of `n` is `n+1`. -/\ntheorem (n : ℕ) : ⇑multiset.card (multiset.nat.antidiagonal n) = n + 1 :=\n\n/-- **Number of Subsets of a Set** -/\ntheorem {α : Type u_1} (s : finset α) : s.powerset.card = 2 ^ s.card :=\n\n/-- If `F` has odd characteristic, then for nonzero `a : F`, we have that `a ^ (#F / 2) = ±1`. -/\ntheorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) {a : F} (ha : a ≠ 0) : a ^ (fintype.card F / 2) = 1 ∨ a ^ (fintype.card F / 2) = -1 :=\n\n/-- If `a % b = c` then `b` divides `a - c`. -/\ntheorem {a b c : ℤ} (h : a % b = c) : b ∣ a - c :=\n\n/-- Congruence relations are symmetric. -/\ntheorem {M : Type u_1} [has_mul M] (c : con M) {x y : M} : ⇑c x y → ⇑c y x :=\n\n/-- **Alias** of the forward direction of even_iff_exists_bit0`. -/\ntheorem {α : Type u_2} [has_add α] {a : α} : even a → (∃ (b : α), a = bit0 b) :=\n\n/--  To show a property is true on the odd parts, it suffices to show it is true on the vectors, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) {P : Π (x : clifford_algebra Q), x ∈ clifford_algebra.even_odd Q 1 → Prop} (hι : ∀ (v : M), P (⇑(clifford_algebra.ι Q) v) _) (hadd : ∀ {x y : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 1} {hy : y ∈ clifford_algebra.even_odd Q 1}, P x hx → P y hy → P (x + y) _) (hιι_mul : ∀ (m₁ m₂ : M) {x : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 1}, P x hx → P (⇑(clifford_algebra.ι Q) m₁ * ⇑(clifford_algebra.ι Q) m₂ * x) _) (x : clifford_algebra Q) (hx : x ∈ clifford_algebra.even_odd Q 1) : P x hx :=\n\n/-- The number of partitions with odd parts is equal to the number of partitions with distinct parts. -/\ntheorem "}
{"text": "Every non-empty poset in which every chain has an upper bound contains a maximal element.", "fullPrompt": "/-- Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle. -/\ntheorem {α : Type u_1} {r : α → α → Prop} {c : set α} (hc : is_chain r c) : ∃ (M : set α), is_max_chain r M ∧ c ⊆ M :=\n\n/-- If `α` is a preorder with no maximal element, then `at_top ≤ cofinite`. -/\ntheorem {α : Type u_2} [preorder α] [no_max_order α] : filter.at_top ≤ filter.cofinite :=\n\n/--  **Hausdorff's maximality principle**  There exists a maximal totally ordered set of `α`. Note that we do not require `α` to be partially ordered by `r`. -/\ntheorem {α : Type u_1} {r : α → α → Prop} : is_max_chain r (max_chain r) :=\n\n/-- When there is a global maximum, every set is bounded above. -/\ntheorem {γ : Type w} [preorder γ] [order_top γ] (s : set γ) : bdd_above s :=\n\n/-- If `s` has a greatest element, then it is bounded above. -/\ntheorem {α : Type u} [preorder α] {s : set α} {a : α} (h : is_greatest s a) : bdd_above s :=\n\n/--  If `P : ℤ → Prop` is a predicate such that the set `{m : P m}` is bounded above and nonempty, then this set has the greatest element. This lemma uses classical logic to avoid assumption `[decidable_pred P]`. See `int.greatest_of_bdd` for a constructive counterpart. -/\ntheorem {P : ℤ → Prop} (Hbdd : ∃ (b : ℤ), ∀ (z : ℤ), P z → z ≤ b) (Hinh : ∃ (z : ℤ), P z) : ∃ (ub : ℤ), P ub ∧ ∀ (z : ℤ), P z → z ≤ ub :=\n\n/--  If `α` is a nonempty preorder with no maximal elements, then there exists a strictly monotone function `ℕ → α`. -/\ntheorem (α : Type u) [preorder α] [nonempty α] [no_max_order α] : ∃ (f : ℕ → α), strict_mono f :=\n\n/-- The edist to a set is bounded above by the edist to any of its points -/\ntheorem {α : Type u} [pseudo_emetric_space α] {x y : α} {s : set α} (h : y ∈ s) : emetric.inf_edist x s ≤ has_edist.edist x y :=\n\n/--  If `α` is a nonempty preorder with no minimal or maximal elements, then there exists a strictly monotone function `f : ℤ → α`. -/\ntheorem (α : Type u) [preorder α] [nonempty α] [no_min_order α] [no_max_order α] : ∃ (f : ℤ → α), strict_mono f :=\n\n/--  If `α` is a preorder with no maximal elements, then there exists a strictly monotone function `ℕ → α` with any prescribed value of `f 0`. -/\ntheorem {α : Type u} [preorder α] [no_max_order α] (a : α) : ∃ (f : ℕ → α), strict_mono f ∧ f 0 = a :=\n\n/-- The supremum of a singleton is the element of the singleton -/\ntheorem {α : Type u_1} [conditionally_complete_lattice α] (a : α) : has_Sup.Sup {a} = a :=\n\n/-- **Alias** of the reverse direction of complete_lattice.is_Sup_finite_compact_iff_is_sup_closed_compact`. -/\ntheorem (α : Type u_1) [complete_lattice α] : complete_lattice.is_sup_closed_compact α → complete_lattice.is_Sup_finite_compact α :=\n\n/--  A nonempty preorder with no maximal element is infinite. This is not an instance to avoid a cycle with `infinite α → nontrivial α → nonempty α`. -/\ntheorem {α : Type u_1} [preorder α] [nonempty α] [no_max_order α] : infinite α :=\n\n/--  A compact element `k` has the property that any `b < k` lies below a \"maximal element below `k`\", which is to say `[⊥, k]` is coatomic. -/\ntheorem {α : Type u_1} [complete_lattice α] {k : α} (h : complete_lattice.is_compact_element k) : is_coatomic ↥(set.Iic k) :=\n\n/--  **Zorn's lemma**  If every chain has an upper bound, then there exists a maximal element. -/\ntheorem {α : Type u_1} {r : α → α → Prop} (h : ∀ (c : set α), is_chain r c → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) (trans : ∀ {a b c : α}, r a b → r b c → r a c) : ∃ (m : α), ∀ (a : α), r m a → r a m :=\n\n/--  If `a` is the least upper bound of `s` and `b` is the least upper bound of `t`, then `a ⊔ b` is the least upper bound of `s ∪ t`. -/\ntheorem {γ : Type w} [semilattice_sup γ] {a b : γ} {s t : set γ} (hs : is_lub s a) (ht : is_lub t b) : is_lub (s ∪ t) (a ⊔ b) :=\n\n/-- Introduction rule to prove that b is the supremum of s: it suffices to check that 1) b is an upper bound 2) every other upper bound b' satisfies b ≤ b'. -/\ntheorem {α : Type u_1} [conditionally_complete_lattice α] {s : set α} {b : α} (hs : s.nonempty) (h_is_ub : ∀ (a : α), a ∈ s → a ≤ b) (h_b_le_ub : ∀ (ub : α), (∀ (a : α), a ∈ s → a ≤ ub) → b ≤ ub) : has_Sup.Sup s = b :=\n\n/--  If `a` is a least upper bound for sets `s` and `p`, then it is a least upper bound for any set `t`, `s ⊆ t ⊆ p`. -/\ntheorem {α : Type u} [preorder α] {a : α} {s t p : set α} (hs : is_lub s a) (hp : is_lub p a) (hst : s ⊆ t) (htp : t ⊆ p) : is_lub t a :=\n\n/-- A logarithmic upper bound on the multiplicity of a prime in a binomial coefficient. -/\ntheorem {p n k : ℕ} : ⇑((n.choose k).factorization) p ≤ nat.log p n :=\n\n/--  When the domain is non-empty, we do not need the `0 ≤ C` condition in the formula for ∥f∥ as an `Inf`. -/\ntheorem {α : Type u} {β : Type v} [topological_space α] [semi_normed_group β] (f : bounded_continuous_function α β) [h : nonempty α] : ∥f∥ = has_Inf.Inf {C : ℝ | ∀ (x : α), ∥⇑f x∥ ≤ C} :=\n\n/-- Cardinality of a non-empty `Icc` of finsets. -/\ntheorem {α : Type u_1} [decidable_eq α] {s t : finset α} (h : s ⊆ t) : (finset.Icc s t).card = 2 ^ (t.card - s.card) :=\n\n/--  The Sup of a non-empty set is its least upper bound for a conditionally complete lattice with a top. -/\ntheorem {β : Type u_1} [conditionally_complete_lattice β] {s : set (with_top β)} (hs : s.nonempty) : is_lub s (has_Sup.Sup s) :=\n\n/-- A non-empty set is countable iff there exists a surjection from the natural numbers onto the subtype induced by the set. -/\ntheorem {α : Type u} {s : set α} (hs : s.nonempty) : s.countable ↔ ∃ (f : ℕ → ↥s), function.surjective f :=\n\n/-- Every non-empty poset in which every chain has an upper bound contains a maximal element. -/\ntheorem "}
{"text": "A group whose automorphism group is cyclic is Abelian.", "fullPrompt": "/-- A finite group of prime order is cyclic. -/\ntheorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_cyclic α :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : is_monoid_hom f :=\n\n/-- A finite group of prime order is simple. -/\ntheorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_simple_group α :=\n\n/-- The inverse of a group homomorphism is a group homomorphism if the target is commutative. -/\ntheorem {α : Type u_1} {β : Type u_2} [group α] [comm_group β] {f : α → β} (hf : is_group_hom f) : is_group_hom (λ (a : α), (f a)⁻¹) :=\n\n/-- A map to a group preserving multiplication is a monoid homomorphism. -/\ntheorem {α : Type u} {β : Type v} [mul_one_class α] [group β] {f : α → β} (hf : is_mul_hom f) : is_monoid_hom f :=\n\n/-- Inversion is a group homomorphism if the group is commutative. -/\ntheorem {α : Type u} [comm_group α] : is_group_hom has_inv.inv :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- Finite groups are torsion groups. -/\ntheorem {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G :=\n\n/-- A group homomorphism sends 1 to 1. -/\ntheorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : f 1 = 1 :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 1 → a = 1 :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x :=\n\n/-- The identity is an additive group homomorphism. -/\ntheorem {α : Type u} [add_group α] : is_add_group_hom id :=\n\n/-- A semisimple Abelian Lie algebra is trivial. -/\ntheorem (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_algebra.is_semisimple R L] [h : is_lie_abelian L] : subsingleton L :=\n\n/--  Note that the inequality can be strict; e.g., the inclusion of an Abelian subalgebra of a simple algebra. -/\ntheorem {R : Type u} {L : Type v} {L' : Type w₂} [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] (f : L →ₗ⁅R⁆ L') {I₁ I₂ : lie_ideal R L} : lie_ideal.map f ⁅I₁,I₂⁆ ≤ ⁅lie_ideal.map f I₁,lie_ideal.map f I₂⁆ :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem {G : Type u_1} [comm_group G] : group.nilpotency_class G ≤ 1 :=\n\n/--  If an order automorphism `fa` is semiconjugate to an order embedding `fb` by a function `g` and `g'` is an order right adjoint of `g` (i.e. `g' y = Sup {x | f x ≤ y}`), then `fb` is semiconjugate to `fa` by `g'`.  This is a version of Proposition 2.1 from [Étienne Ghys, Groupes d'homeomorphismes du cercle et cohomologie bornee][ghys87:groupes]. -/\ntheorem {α : Type u_1} {β : Type u_2} [partial_order α] [preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β} (h : function.semiconj g ⇑fa ⇑fb) {g' : β → α} (hg' : is_order_right_adjoint g g') : function.semiconj g' ⇑fb ⇑fa :=\n\n/-- A group whose automorphism group is cyclic is Abelian. -/\ntheorem "}
{"text": "A uniformly continuous function of a uniformly continuous function is uniformly continuous.", "fullPrompt": "/-- The new distance is uniformly continuous. -/\ntheorem {α : Type u} [pseudo_metric_space α] : uniform_continuous (λ (p : uniform_space.completion α × uniform_space.completion α), has_dist.dist p.fst p.snd) :=\n\n/-- The minimal distance to a set is uniformly continuous in point -/\ntheorem {α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_dist x s) :=\n\n/-- The minimal distance to a set (as `ℝ≥0`) is uniformly continuous in point -/\ntheorem {α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_nndist x s) :=\n\n/-- The indexed supremum of a function is bounded above by a uniform bound -/\ntheorem {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), f x ≤ c) : supr f ≤ c :=\n\n/-- The indexed minimum of a function is bounded below by a uniform lower bound -/\ntheorem {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), c ≤ f x) : c ≤ infi f :=\n\n/--  If the domain of a `uniform_inducing` map `f` is a `separated_space`, then `f` is injective, hence it is a `uniform_embedding`. -/\ntheorem {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] [separated_space α] {f : α → β} (hf : uniform_inducing f) : uniform_embedding f :=\n\n/-- In a sequential space, continuity and sequential continuity coincide. -/\ntheorem {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X → Y} [sequential_space X] : continuous f ↔ seq_continuous f :=\n\n/-- A continuous surjective open map is a quotient map. -/\ntheorem {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f) : quotient_map f :=\n\n/--  If `f` is a Lipschitz continuous map, then the Hausdorff dimension of its range is at most the Hausdorff dimension of its domain. -/\ntheorem {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X → Y} (h : lipschitz_with K f) : dimH (set.range f) ≤ dimH set.univ :=\n\n/-- The inclusion of a fiber into the total space is a continuous map. -/\ntheorem {ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (b : B) : continuous (bundle.total_space_mk b) :=\n\n/-- The minimal distance to a set is continuous in point -/\ntheorem {α : Type u} [pseudo_metric_space α] (s : set α) : continuous (λ (x : α), metric.inf_dist x s) :=\n\n/-- The uncurrying process is a continuous map between function spaces. -/\ntheorem {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] [locally_compact_space α] [locally_compact_space β] : continuous continuous_map.uncurry :=\n\n/-- Composing on the left by a uniformly continuous function preserves  uniform convergence on a set -/\ntheorem {α : Type u_1} {β : Type u_2} {γ : Type u_3} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {s : set α} {p : filter ι} [uniform_space γ] {g : β → γ} (h : tendsto_uniformly_on F f p s) (hg : uniform_continuous g) : tendsto_uniformly_on (λ (i : ι), g ∘ F i) (g ∘ f) p s :=\n\n/-- Composing on the left by a uniformly continuous function preserves uniform convergence -/\ntheorem {α : Type u_1} {β : Type u_2} {γ : Type u_3} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {p : filter ι} [uniform_space γ] {g : β → γ} (h : tendsto_uniformly F f p) (hg : uniform_continuous g) : tendsto_uniformly (λ (i : ι), g ∘ F i) (g ∘ f) p :=\n\n/-- The composition operator (in the target) with a Lipschitz map is uniformly continuous -/\ntheorem {α : Type u} {β : Type v} {γ : Type w} [topological_space α] [pseudo_metric_space β] [pseudo_metric_space γ] {G : β → γ} {C : nnreal} (H : lipschitz_with C G) : uniform_continuous (bounded_continuous_function.comp G H) :=\n\n/-- The coercion from `lp E p` to `Π i, E i` is uniformly continuous. -/\ntheorem {α : Type u_1} {E : α → Type u_2} {p : ennreal} [Π (i : α), normed_group (E i)] [fact (1 ≤ p)] : uniform_continuous coe :=\n\n/--  Heine-Cantor: a continuous function on a compact set of a separated uniform space is uniformly continuous. -/\ntheorem {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] [separated_space α] {s : set α} {f : α → β} (hs : is_compact s) (hf : continuous_on f s) : uniform_continuous_on f s :=\n\n/--  Heine-Cantor: a continuous function on a compact separated set of a uniform space is uniformly continuous. -/\ntheorem {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] {s : set α} {f : α → β} (hs : is_compact s) (hs' : is_separated s) (hf : continuous_on f s) : uniform_continuous_on f s :=\n\n/-- A Hölder continuous function is uniformly continuous -/\ntheorem {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C r : nnreal} {f : X → Y} (hf : holder_with C r f) (h0 : 0 < r) : uniform_continuous f :=\n\n/-- A Hölder continuous function is uniformly continuous -/\ntheorem {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C r : nnreal} {f : X → Y} {s : set X} (hf : holder_on_with C r f s) (h0 : 0 < r) : uniform_continuous_on f s :=\n\n/-- A Lipschitz function is uniformly continuous -/\ntheorem {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {K : nnreal} {f : α → β} (hf : lipschitz_with K f) : uniform_continuous f :=\n\n/-- A uniformly continuous function of a uniformly continuous function is uniformly continuous. -/\ntheorem "}
{"text": "A uniformly continuous function of a uniformly continuous function is uniformly continuous.", "fullPrompt": "/-- The new distance is uniformly continuous. -/\ntheorem {α : Type u} [pseudo_metric_space α] : uniform_continuous (λ (p : uniform_space.completion α × uniform_space.completion α), has_dist.dist p.fst p.snd) :=\n\n/-- The minimal distance to a set is uniformly continuous in point -/\ntheorem {α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_dist x s) :=\n\n/-- The minimal distance to a set (as `ℝ≥0`) is uniformly continuous in point -/\ntheorem {α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_nndist x s) :=\n\n/-- The indexed supremum of a function is bounded above by a uniform bound -/\ntheorem {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), f x ≤ c) : supr f ≤ c :=\n\n/-- The indexed minimum of a function is bounded below by a uniform lower bound -/\ntheorem {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), c ≤ f x) : c ≤ infi f :=\n\n/--  If the domain of a `uniform_inducing` map `f` is a `separated_space`, then `f` is injective, hence it is a `uniform_embedding`. -/\ntheorem {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] [separated_space α] {f : α → β} (hf : uniform_inducing f) : uniform_embedding f :=\n\n/-- In a sequential space, continuity and sequential continuity coincide. -/\ntheorem {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X → Y} [sequential_space X] : continuous f ↔ seq_continuous f :=\n\n/-- A continuous surjective open map is a quotient map. -/\ntheorem {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f) : quotient_map f :=\n\n/--  If `f` is a Lipschitz continuous map, then the Hausdorff dimension of its range is at most the Hausdorff dimension of its domain. -/\ntheorem {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X → Y} (h : lipschitz_with K f) : dimH (set.range f) ≤ dimH set.univ :=\n\n/-- The inclusion of a fiber into the total space is a continuous map. -/\ntheorem {ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (b : B) : continuous (bundle.total_space_mk b) :=\n\n/-- The minimal distance to a set is continuous in point -/\ntheorem {α : Type u} [pseudo_metric_space α] (s : set α) : continuous (λ (x : α), metric.inf_dist x s) :=\n\n/-- The uncurrying process is a continuous map between function spaces. -/\ntheorem {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] [locally_compact_space α] [locally_compact_space β] : continuous continuous_map.uncurry :=\n\n/-- Composing on the left by a uniformly continuous function preserves  uniform convergence on a set -/\ntheorem {α : Type u_1} {β : Type u_2} {γ : Type u_3} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {s : set α} {p : filter ι} [uniform_space γ] {g : β → γ} (h : tendsto_uniformly_on F f p s) (hg : uniform_continuous g) : tendsto_uniformly_on (λ (i : ι), g ∘ F i) (g ∘ f) p s :=\n\n/-- Composing on the left by a uniformly continuous function preserves uniform convergence -/\ntheorem {α : Type u_1} {β : Type u_2} {γ : Type u_3} {ι : Type u_4} [uniform_space β] {F : ι → α → β} {f : α → β} {p : filter ι} [uniform_space γ] {g : β → γ} (h : tendsto_uniformly F f p) (hg : uniform_continuous g) : tendsto_uniformly (λ (i : ι), g ∘ F i) (g ∘ f) p :=\n\n/-- The composition operator (in the target) with a Lipschitz map is uniformly continuous -/\ntheorem {α : Type u} {β : Type v} {γ : Type w} [topological_space α] [pseudo_metric_space β] [pseudo_metric_space γ] {G : β → γ} {C : nnreal} (H : lipschitz_with C G) : uniform_continuous (bounded_continuous_function.comp G H) :=\n\n/-- The coercion from `lp E p` to `Π i, E i` is uniformly continuous. -/\ntheorem {α : Type u_1} {E : α → Type u_2} {p : ennreal} [Π (i : α), normed_group (E i)] [fact (1 ≤ p)] : uniform_continuous coe :=\n\n/--  Heine-Cantor: a continuous function on a compact set of a separated uniform space is uniformly continuous. -/\ntheorem {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] [separated_space α] {s : set α} {f : α → β} (hs : is_compact s) (hf : continuous_on f s) : uniform_continuous_on f s :=\n\n/--  Heine-Cantor: a continuous function on a compact separated set of a uniform space is uniformly continuous. -/\ntheorem {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] {s : set α} {f : α → β} (hs : is_compact s) (hs' : is_separated s) (hf : continuous_on f s) : uniform_continuous_on f s :=\n\n/-- A Hölder continuous function is uniformly continuous -/\ntheorem {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C r : nnreal} {f : X → Y} (hf : holder_with C r f) (h0 : 0 < r) : uniform_continuous f :=\n\n/-- A Hölder continuous function is uniformly continuous -/\ntheorem {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C r : nnreal} {f : X → Y} {s : set X} (hf : holder_on_with C r f s) (h0 : 0 < r) : uniform_continuous_on f s :=\n\n/-- A Lipschitz function is uniformly continuous -/\ntheorem {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {K : nnreal} {f : α → β} (hf : lipschitz_with K f) : uniform_continuous f :=\n\n/-- A uniformly continuous function of a uniformly continuous function is uniformly continuous. -/\ntheorem "}
{"text": "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.", "fullPrompt": "/-- A locally compact Hausdorff space is totally disconnected  if and only if it is totally separated. -/\ntheorem {H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] : totally_disconnected_space H ↔ totally_separated_space H :=\n\n/-- The normal closure of a set is a subgroup. -/\ntheorem {G : Type u_1} [group G] (s : set G) : is_subgroup (group.normal_closure s) :=\n\n/--  The fixed point lemma for normal functions: any normal function has an unbounded set of fixed points. -/\ntheorem {f : ordinal → ordinal} (H : ordinal.is_normal f) : set.unbounded has_lt.lt (function.fixed_points f) :=\n\n/-- A Hausdorff space with a clopen basis is totally separated. -/\ntheorem {α : Type u} [topological_space α] [t2_space α] (h : topological_space.is_topological_basis {s : set α | is_clopen s}) : totally_separated_space α :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there  is some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. -/\ntheorem {X : Type u_1} [topological_space X] (hX : ∀ {x y : X}, x ≠ y → (∃ (U : set X) (h_clopen : is_clopen U), x ∈ U ∧ y ∉ U)) : is_totally_disconnected set.univ :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem {G : Type u_1} {s : set G} [group G] : is_normal_subgroup (group.normal_closure s) :=\n\n/-- A product is regular if and only if the factors are. -/\ntheorem {R : Type u_1} {a b : R} [comm_semigroup R] : is_regular (a * b) ↔ is_regular a ∧ is_regular b :=\n\n/-- A locally compact Hausdorff totally disconnected space has a basis with clopen elements. -/\ntheorem {H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] [totally_disconnected_space H] : topological_space.is_topological_basis {s : set H | is_clopen s} :=\n\n/--   Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a` are regular. -/\ntheorem {R : Type u_1} {a b : R} [semigroup R] : is_regular (a * b) ∧ is_regular (b * a) ↔ is_regular a ∧ is_regular b :=\n\n/-- The normal closure of s is the smallest normal subgroup containing s. -/\ntheorem {G : Type u_1} [group G] {s t : set G} (ht : is_normal_subgroup t) (h : s ⊆ t) : group.normal_closure s ⊆ t :=\n\n/-- A space is totally disconnected iff its connected components are singletons. -/\ntheorem {α : Type u} [topological_space α] : totally_disconnected_space α ↔ ∀ (x : α), connected_component x = {x} :=\n\n/--  For any subset `s` of `α`, the restriction of continuous functions to `s` is continuous as a function from `C(α, β)` to `C(s, β)` with their respective compact-open topologies. -/\ntheorem {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (s : set α) : continuous (λ (F : C(α, β)), continuous_map.restrict s F) :=\n\n/--  Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, and `a ≤ b` are two real numbers, then there exists a continuous function `f : X → ℝ` such that  * `f` equals `a` on `s`; * `f` equals `b` on `t`; * `a ≤ f x ≤ b` for all `x`. -/\ntheorem {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) {a b : ℝ} (hle : a ≤ b) : ∃ (f : bounded_continuous_function X ℝ), set.eq_on ⇑f (function.const X a) s ∧ set.eq_on ⇑f (function.const X b) t ∧ ∀ (x : X), ⇑f x ∈ set.Icc a b :=\n\n/--  Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, then there exists a continuous function `f : X → ℝ` such that  * `f` equals zero on `s`; * `f` equals one on `t`; * `0 ≤ f x ≤ 1` for all `x`. -/\ntheorem {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : ∃ (f : C(X, ℝ)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1 :=\n\n/--  Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, then there exists a continuous function `f : X → ℝ` such that  * `f` equals zero on `s`; * `f` equals one on `t`; * `0 ≤ f x ≤ 1` for all `x`. -/\ntheorem {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : ∃ (f : bounded_continuous_function X ℝ), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1 :=\n\n/-- A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function. -/\ntheorem "}
{"text": "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.", "fullPrompt": "/-- A fixed point of `f` is a periodic point of `f` of any prescribed period. -/\ntheorem {α : Type u_1} {f : α → α} {x : α} (hf : function.is_fixed_pt f x) (n : ℕ) : function.is_periodic_pt f n x :=\n\n/-- Any point is a periodic point of period `0`. -/\ntheorem {α : Type u_1} (f : α → α) (x : α) : function.is_periodic_pt f 0 x :=\n\n/-- If a function is `antiperiodic` with antiperiod `c`, then it is also `periodic` with period  `2 * c`. -/\ntheorem {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [semiring α] [add_group β] (h : function.antiperiodic f c) : function.periodic f (2 * c) :=\n\n/--  An interval of length `a` filtered over a periodic predicate of period `a` has cardinality equal to the number naturals below `a` for which `p a` is true. -/\ntheorem (n a : ℕ) (p : ℕ → Prop) [decidable_pred p] (pp : function.periodic p a) : ⇑multiset.card (multiset.filter p (multiset.Ico n (n + a))) = nat.count p a :=\n\n/-- For the identity map, all points are periodic. -/\ntheorem {α : Type u_1} (n : ℕ) (x : α) : function.is_periodic_pt id n x :=\n\n/--  Every x greater than or equal to 1 is between two successive natural-number powers of every y greater than one. -/\ntheorem {α : Type u_1} [linear_ordered_ring α] [archimedean α] {x y : α} (hx : 1 ≤ x) (hy : 1 < y) : ∃ (n : ℕ), y ^ n ≤ x ∧ x < y ^ (n + 1) :=\n\n/-- A function `f` on `fin (n + 1)` is monotone if and only if `f i ≤ f (i + 1)` for all `i`. -/\ntheorem {n : ℕ} {α : Type u_1} [preorder α] {f : fin (n + 1) → α} : monotone f ↔ ∀ (i : fin n), f (⇑fin.cast_succ i) ≤ f i.succ :=\n\n/--  The fixed point lemma for normal functions: any normal function has an unbounded set of fixed points. -/\ntheorem {f : ordinal → ordinal} (H : ordinal.is_normal f) : set.unbounded has_lt.lt (function.fixed_points f) :=\n\n/-- Every point is a fixed point of `id`. -/\ntheorem {α : Type u} (x : α) : function.is_fixed_pt id x :=\n\n/-- If `x` is a fixed point of `f ∘ g` and `g`, then it is a fixed point of `f`. -/\ntheorem {α : Type u} {f g : α → α} {x : α} (hfg : function.is_fixed_pt (f ∘ g) x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt f x :=\n\n/-- For any `y < 1` and any positive `x`, there exists `n : ℕ` with `y ^ n < x`. -/\ntheorem {α : Type u_1} [linear_ordered_field α] [archimedean α] {x y : α} (hx : 0 < x) (hy : y < 1) : ∃ (n : ℕ), y ^ n < x :=\n\n/-- If `x` is a fixed point of `f` and `g`, then it is a fixed point of `f ∘ g`. -/\ntheorem {α : Type u} {f g : α → α} {x : α} (hf : function.is_fixed_pt f x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt (f ∘ g) x :=\n\n/--  If `f` sends two periodic points `x` and `y` of positive periods to the same point, then `x = y`. -/\ntheorem {α : Type u_1} {f : α → α} {x y : α} {m n : ℕ} (hx : function.is_periodic_pt f m x) (hy : function.is_periodic_pt f n y) (hm : 0 < m) (hn : 0 < n) (h : f x = f y) : x = y :=\n\n/-- If a function from the unit interval to itself has a point of period three, then it has points of all positive periods. -/\ntheorem "}
{"text": "A terminal object in a category is unique up to unique isomorphism.", "fullPrompt": "/-- If the unique morphism from `A` to a terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_is_terminal_from`. -/\ntheorem {C : Type u₁} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)] : category_theory.is_subterminal A :=\n\n/-- If there are zero morphisms, any terminal object is a zero object. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C] : category_theory.limits.has_zero_object C :=\n\n/-- If `A` is subterminal, the unique morphism from it to a terminal object is a monomorphism. The converse of `is_subterminal_of_mono_is_terminal_from`. -/\ntheorem {C : Type u₁} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) {T : C} (hT : category_theory.limits.is_terminal T) : category_theory.mono (hT.from A) :=\n\n/-- If `A` is subterminal, the unique morphism from it to the terminal object is a monomorphism. The converse of `is_subterminal_of_mono_terminal_from`. -/\ntheorem {C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] (hA : category_theory.is_subterminal A) : category_theory.mono (category_theory.limits.terminal.from A) :=\n\n/-- If the unique morphism from `A` to the terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_terminal_from`. -/\ntheorem {C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] [category_theory.mono (category_theory.limits.terminal.from A)] : category_theory.is_subterminal A :=\n\n/-- Construct terminal object in the over category. This isn't an instance as it's not typically the way we want to define terminal objects. (For instance, this gives a terminal object which is different from the generic one given by `over_product_of_wide_pullback` above.) -/\ntheorem {C : Type u} [category_theory.category C] (B : C) : category_theory.limits.has_terminal (category_theory.over B) :=\n\n/-- Any category with pullbacks and terminal object has binary products. -/\ntheorem (C : Type u) [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_pullbacks C] : category_theory.limits.has_binary_products C :=\n\n/-- Any simple object in a preadditive category is indecomposable. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] (X : C) [category_theory.simple X] : category_theory.indecomposable X :=\n\n/-- If a preadditive category has all kernels, then it also has all equalizers. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] : category_theory.limits.has_equalizers C :=\n\n/-- If a preadditive category has all cokernels, then it also has all coequalizers. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_cokernels C] : category_theory.limits.has_coequalizers C :=\n\n/-- If `C` has a terminal object and binary products, then it has finite products. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_terminal C] : category_theory.limits.has_finite_products C :=\n\n/-- In a preadditive category, if the coproduct of `X` and `Y` exists, then the    binary biproduct of `X` and `Y` exists. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y] : category_theory.limits.has_binary_biproduct X Y :=\n\n/--  If `c` is a limiting binary product cone, and we have a terminal object, then we have `is_pullback c.fst c.snd 0 0` (where each `0` is the unique morphism to the terminal object). -/\ntheorem {C : Type u₁} [category_theory.category C] {X Y Z : C} {c : category_theory.limits.binary_fan X Y} (h : category_theory.limits.is_limit c) (t : category_theory.limits.is_terminal Z) : category_theory.is_pullback c.fst c.snd (t.from ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.left})) (t.from ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.right})) :=\n\n/--  To show a category is a `initial_mono_class` it suffices to show the unique morphism from the initial object to a terminal object is a monomorphism. -/\ntheorem {C : Type u₁} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] (h : category_theory.mono (category_theory.limits.initial.to (⊤_ C))) : category_theory.limits.initial_mono_class C :=\n\n/-- If `C` has a terminal object and `G` preserves terminal objects, then `D` has a terminal object also. Note this property is somewhat unique to (co)limits of the empty diagram: for general `J`, if `C` has limits of shape `J` and `G` preserves them, then `D` does not necessarily have limits of shape `J`. -/\ntheorem {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (G : C ⥤ D) [category_theory.limits.has_terminal C] [category_theory.limits.preserves_limit (category_theory.functor.empty C) G] : category_theory.limits.has_terminal D :=\n\n/--  If all but one object in a diagram is strict terminal, the the limit is isomorphic to the said object via `limit.π`. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_strict_terminal_objects C] {J : Type v} [category_theory.small_category J] (F : J ⥤ C) [category_theory.limits.has_limit F] (i : J) (H : Π (j : J), j ≠ i → category_theory.limits.is_terminal (F.obj j)) [subsingleton (i ⟶ i)] : category_theory.is_iso (category_theory.limits.limit.π F i) :=\n\n/-- A terminal object in a category is unique up to unique isomorphism. -/\ntheorem "}
{"text": "The complement of the union of two sets is the intersection of their complements.", "fullPrompt": "/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem {γ : Type w} [semilattice_sup γ] {s t : set γ} : bdd_above (s ∪ t) ↔ bdd_above s ∧ bdd_above t :=\n\n/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem {γ : Type w} [semilattice_inf γ] {s t : set γ} : bdd_below (s ∪ t) ↔ bdd_below s ∧ bdd_below t :=\n\n/-- The union of two sets is bounded iff each of the sets is bounded. -/\ntheorem {α : Type u} [pseudo_metric_space α] {s t : set α} : metric.bounded (s ∪ t) ↔ metric.bounded s ∧ metric.bounded t :=\n\n/-- The union of two bounded sets is bounded. -/\ntheorem {α : Type u} [pseudo_metric_space α] {s t : set α} (hs : metric.bounded s) (ht : metric.bounded t) : metric.bounded (s ∪ t) :=\n\n/-- The union of two Gδ sets is a Gδ set. -/\ntheorem {α : Type u_1} [topological_space α] {s t : set α} (hs : is_Gδ s) (ht : is_Gδ t) : is_Gδ (s ∪ t) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s) : is_compact (s ∩ t) :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) : is_compact (s ∩ t) :=\n\n/-- If `s` is bounded, then so is `s ∩ t` -/\ntheorem {α : Type u} [preorder α] {s t : set α} (h : bdd_above s) : bdd_above (s ∩ t) :=\n\n/-- If `s` is bounded, then so is `s ∩ t` -/\ntheorem {α : Type u} [preorder α] {s t : set α} (h : bdd_below s) : bdd_below (s ∩ t) :=\n\n/-- The intersection of an open dense set with a dense set is a dense set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (hs : dense s) (ht : dense t) (hso : is_open s) : dense (s ∩ t) :=\n\n/-- If the elements of a set are independent, then any pair within that set is disjoint. -/\ntheorem {α : Type u_1} {ι : Type u_3} [complete_lattice α] {t : ι → α} (ht : complete_lattice.independent t) : pairwise (disjoint on t) :=\n\n/-- The intersection of a dense set with an open dense set is a dense set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (hs : dense s) (ht : dense t) (hto : is_open t) : dense (s ∩ t) :=\n\n/-- The complement of the union of two sets is the intersection of their complements. -/\ntheorem "}
{"text": "The sum of the cubes of two positive integers is never equal to the cube of a third integer.", "fullPrompt": "/-- The zeroth Pythagorean triple is all zeros. -/\ntheorem  : pythagorean_triple 0 0 0 :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem {α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0 :=\n\n/--  **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p :=\n\n/--  Pythagorean triples are interchangable, i.e `x * x + y * y = y * y + x * x = z * z`. This comes from additive commutativity. -/\ntheorem {x y z : ℤ} : pythagorean_triple x y z ↔ pythagorean_triple y x z :=\n\n/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- For any natural numbers n, a, and b, one of the following holds: 1. n < a 2. n ≥ b 3. n ∈ Ico a b -/\ntheorem (n a b : ℕ) : n < a ∨ b ≤ n ∨ n ∈ list.Ico a b :=\n\n/--  A triple is still a triple if you multiply `x`, `y` and `z` by a constant `k`. -/\ntheorem {x y z : ℤ} (h : pythagorean_triple x y z) (k : ℤ) : pythagorean_triple (k * x) (k * y) (k * z) :=\n\n/-- There are no perfect squares strictly between m² and (m+1)² -/\ntheorem {n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬∃ (t : ℕ), t * t = n :=\n\n/-- Additive congruence relations preserve negation. -/\ntheorem {M : Type u_1} [add_group M] (c : add_con M) {w x : M} : ⇑c w x → ⇑c (-w) (-x) :=\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/\ntheorem {m n : ℕ} : m ∣ m + n ↔ m ∣ n :=\n\n/-- Natural division is always less than division in the field. -/\ntheorem {α : Type u_1} [linear_ordered_field α] {m n : ℕ} : ↑(m / n) ≤ ↑m / ↑n :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`. -/\ntheorem (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p :=\n\n/-- We now have four different results that all encode the idea that inequality of multisets corresponds to divisibility of positive integers. -/\ntheorem {m n : ℕ+} : m.factor_multiset ≤ n.factor_multiset ↔ m ∣ n :=\n\n/-- The gcd and lcm operations on positive integers correspond to the inf and sup operations on multisets. -/\ntheorem (m n : ℕ+) : (m.gcd n).factor_multiset = m.factor_multiset ⊓ n.factor_multiset :=\n\n/-- The sum of the cubes of two positive integers is never equal to the cube of a third integer. -/\ntheorem "}
{"text": "If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.", "fullPrompt": "/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem {S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : commute b a :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem {S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : add_commute b a :=\n\n/-- Any element commutes with itself. -/\ntheorem {S : Type u_1} [has_mul S] (a : S) : commute a a :=\n\n/-- Any element commutes with itself. -/\ntheorem {S : Type u_1} [has_add S] (a : S) : add_commute a a :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem {S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) : commute a (b * c) :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their sum. -/\ntheorem {S : Type u_1} [add_semigroup S] {a b c : S} (hab : add_commute a b) (hac : add_commute a c) : add_commute a (b + c) :=\n\n/-- Moving to the opposite group or group_with_zero commutes with taking powers. -/\ntheorem {M : Type u} [div_inv_monoid M] (x : M) (z : ℤ) : mul_opposite.op (x ^ z) = mul_opposite.op x ^ z :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem {S : Type u_1} [semigroup S] {a b c : S} (hac : commute a c) (hbc : commute b c) : commute (a * b) c :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem {S : Type u_1} [add_semigroup S] {a b c : S} (hac : add_commute a c) (hbc : add_commute b c) : add_commute (a + b) c :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x :=\n\n/-- Commuting elements of finite additive order are closed under addition. -/\ntheorem {G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y) :=\n\n/--  If `A` is a family of enough low-degree polynomials over a finite ring, there is a pair of elements in `A` (with different indices but not necessarily distinct), such that their difference has small degree. -/\ntheorem {Fq : Type u_1} [fintype Fq] [ring Fq] {d m : ℕ} (hm : fintype.card Fq ^ d ≤ m) (b : polynomial Fq) (A : fin m.succ → polynomial Fq) (hA : ∀ (i : fin m.succ), (A i).degree < b.degree) : ∃ (i₀ i₁ : fin m.succ), i₀ ≠ i₁ ∧ (A i₁ - A i₀).degree < ↑(b.nat_degree - d) :=\n\n/-- If a set `s` does not contain any elements between any pair of elements `x, z ∈ s` with `x ≤ z` (i.e if given `x, y, z ∈ s` such that `x ≤ y ≤ z`, then `y` is either `x` or `z`), then `s` is finite. -/\ntheorem {α : Type u_1} [linear_order α] (s : set α) (h : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → ∀ (z : α), z ∈ s → x ≤ y → y ≤ z → x = y ∨ y = z) : s.finite :=\n\n/-- If every element of a group `G` has order `2`, then every pair of elements of `G` commutes. -/\ntheorem "}
{"text": "The product of two consecutive natural numbers is even.", "fullPrompt": "/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/--  If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive. -/\ntheorem {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0 :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n\n/-- Two natural numbers are equal if and only if the have the same divisors. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/\ntheorem {m n : ℕ} : m ∣ m + n ↔ m ∣ n :=\n\n/-- A natural number `m` divides the sum `n + m` if and only if `m` divides `n`. -/\ntheorem {m n : ℕ} : m ∣ n + m ↔ m ∣ n :=\n\n/-- Odd Bernoulli numbers (greater than 1) are zero. -/\ntheorem {n : ℕ} (h_odd : odd n) (hlt : 1 < n) : bernoulli' n = 0 :=\n\n/-- `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)` for some `k`. -/\ntheorem (m : ℕ) {n : ℕ} (hn : 0 < n) : (∃ (k : ℕ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m :=\n\n/--  Every x greater than or equal to 1 is between two successive natural-number powers of every y greater than one. -/\ntheorem {α : Type u_1} [linear_ordered_ring α] [archimedean α] {x y : α} (hx : 1 ≤ x) (hy : 1 < y) : ∃ (n : ℕ), y ^ n ≤ x ∧ x < y ^ (n + 1) :=\n\n/-- If `n > 0` then `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)`  for some `k`. -/\ntheorem (m : ℤ) {n : ℤ} (hn : 0 < n) : (∃ (k : ℤ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem  : set.inj_on nat.factorization {x : ℕ | x ≠ 0} :=\n\n/-- For any natural numbers n, a, and b, one of the following holds: 1. n < a 2. n ≥ b 3. n ∈ Ico a b -/\ntheorem (n a b : ℕ) : n < a ∨ b ≤ n ∨ n ∈ list.Ico a b :=\n\n/-- The product of two consecutive natural numbers is even. -/\ntheorem "}
{"text": "Every index 2 subgroup of a group is normal.", "fullPrompt": "/-- The normal closure of a set is a subgroup. -/\ntheorem {G : Type u_1} [group G] (s : set G) : is_subgroup (group.normal_closure s) :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem {G : Type u_1} {s : set G} [group G] : is_normal_subgroup (group.normal_closure s) :=\n\n/-- The normal closure of s is the smallest normal subgroup containing s. -/\ntheorem {G : Type u_1} [group G] {s t : set G} (ht : is_normal_subgroup t) (h : s ⊆ t) : group.normal_closure s ⊆ t :=\n\n/-- A finite group of prime order is simple. -/\ntheorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_simple_group α :=\n\n/-- The lower central series of a group is a descending central series. -/\ntheorem {G : Type u_1} [group G] : is_descending_central_series (lower_central_series G) :=\n\n/-- The upper central series of a group is an ascending central series. -/\ntheorem (G : Type u_1) [group G] : is_ascending_central_series (upper_central_series G) :=\n\n/-- If a subgroup of a topological group has `1` in its interior, then it is open. -/\ntheorem {G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 ∈ interior ↑H) : is_open ↑H :=\n\n/-- Any descending central series for a group is bounded below by the lower central series. -/\ntheorem {G : Type u_1} [group G] (H : ℕ → subgroup G) (hH : is_descending_central_series H) (n : ℕ) : lower_central_series G n ≤ H n :=\n\n/-- If `0 < n`, then `dihedral_group n` has `2n` elements. -/\ntheorem {n : ℕ} [fact (0 < n)] : fintype.card (dihedral_group n) = 2 * n :=\n\n/-- An open subgroup of a nonarchimedean ring contains the square of another one. -/\ntheorem {R : Type u_1} [ring R] [topological_space R] [nonarchimedean_ring R] (U : open_add_subgroup R) : ∃ (V : open_add_subgroup R), ↑V * ↑V ⊆ ↑U :=\n\n/-- Any ascending central series for a group is bounded above by the upper central series. -/\ntheorem {G : Type u_1} [group G] (H : ℕ → subgroup G) (hH : is_ascending_central_series H) (n : ℕ) : H n ≤ upper_central_series G n :=\n\n/-- An element admitting a left inverse is left-regular. -/\ntheorem {R : Type u_1} {a b : R} [monoid R] (h : b * a = 1) : is_left_regular a :=\n\n/-- Every index 2 subgroup of a group is normal. -/\ntheorem "}
{"text": "Every free group is torsion free.", "fullPrompt": "/-- A nontrivial torsion-free group is not torsion. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G → ¬monoid.is_torsion G :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i) :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G → ¬monoid.is_torsion_free G :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem (G : Type u_1) [monoid G] : ¬monoid.is_torsion_free G ↔ ∃ (g : G), g ≠ 1 ∧ is_of_fin_order g :=\n\n/-- Finite groups are torsion groups. -/\ntheorem {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G :=\n\n/--  If two words correspond to the same element in the free group, then they have a common maximal reduction. This is the proof that the function that sends an element of the free group to its maximal reduction is well-defined. -/\ntheorem {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.mk L₁ = free_group.mk L₂) : free_group.reduce L₁ = free_group.reduce L₂ :=\n\n/-- The canonical injection from the type to the free group is an injection. -/\ntheorem {α : Type u} : function.injective free_group.of :=\n\n/--  A word and its maximal reduction correspond to the same element of the free group. -/\ntheorem {α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.mk (free_group.reduce L) = free_group.mk L :=\n\n/--  If two words have a common maximal reduction, then they correspond to the same element in the free group. -/\ntheorem {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.reduce L₁ = free_group.reduce L₂) : free_group.mk L₁ = free_group.mk L₂ :=\n\n/-- A monoid is not a torsion monoid if it has an element of infinite order. -/\ntheorem (G : Type u_1) [monoid G] : ¬monoid.is_torsion G ↔ ∃ (g : G), ¬is_of_fin_order g :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem {G : Type u_3} [group G] : group.fg G ↔ monoid.fg G :=\n\n/-- A group `G` is finitely generated if and only if `add_monoid_algebra R G` is of finite type. -/\ntheorem {R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) ↔ group.fg G :=\n\n/-- The image of a quotient is torsion iff the group is torsion. -/\ntheorem {G : Type u_1} {H : Type u_2} [group G] {N : subgroup G} [group H] {f : G →* H} (hf : function.surjective ⇑f) (hN : N = f.ker) (tN : monoid.is_torsion ↥N) : monoid.is_torsion H ↔ monoid.is_torsion G :=\n\n/-- If a group exponent exists, the group is torsion. -/\ntheorem {G : Type u_1} [group G] (h : monoid.exponent_exists G) : monoid.is_torsion G :=\n\n/-- The image of a quotient is additively torsion iff the group is torsion. -/\ntheorem {G : Type u_1} {H : Type u_2} [add_group G] {N : add_subgroup G} [add_group H] {f : G →+ H} (hf : function.surjective ⇑f) (hN : N = f.ker) (tN : add_monoid.is_torsion ↥N) : add_monoid.is_torsion H ↔ add_monoid.is_torsion G :=\n\n/-- Direct products of additive torsion free groups are torsion free. -/\ntheorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_group (Gs i)] (tfGs : ∀ (i : η), add_monoid.is_torsion_free (Gs i)) : add_monoid.is_torsion_free (Π (i : η), Gs i) :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem (G : Type u_1) [add_comm_group G] : add_monoid.is_torsion_free (G ⧸ add_torsion G) :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem (G : Type u_1) [comm_group G] : monoid.is_torsion_free (G ⧸ torsion G) :=\n\n/-- Every free group is torsion free. -/\ntheorem "}
{"text": "Every natural number greater than `1` is divisible by a prime number. ", "fullPrompt": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem  : set.inj_on nat.factorization {x : ℕ | x ≠ 0} :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2 :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime dividing it. -/\ntheorem {n : ℕ} : is_prime_pow n ↔ ∃! (p : ℕ), nat.prime p ∧ p ∣ n :=\n\n/-- If `p` is prime, and `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)` then `a = p^(k+1)`. -/\ntheorem {a p k : ℕ} (pp : nat.prime p) (h₁ : ¬a ∣ p ^ k) (h₂ : a ∣ p ^ (k + 1)) : a = p ^ (k + 1) :=\n\n/-- If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. -/\ntheorem (p' : ℕ) : 2 < lucas_lehmer.q (p' + 2) :=\n\n/-- `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)` for some `k`. -/\ntheorem (m : ℕ) {n : ℕ} (hn : 0 < n) : (∃ (k : ℕ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m :=\n\n/-- If `n > 0` then `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)`  for some `k`. -/\ntheorem (m : ℤ) {n : ℤ} (hn : 0 < n) : (∃ (k : ℤ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m :=\n\n/-- Two natural numbers are equal if and only if the have the same divisors. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- Natural division is always less than division in the field. -/\ntheorem {α : Type u_1} [linear_ordered_field α] {m n : ℕ} : ↑(m / n) ≤ ↑m / ↑n :=\n\n/-- If the factorization of `n` contains just one number `p` then `n` is a power of `p` -/\ntheorem {n p k : ℕ} (hn : n ≠ 0) (h : n.factorization = finsupp.single p k) : n = p ^ k :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a natural `k` such that `n` can be written as `p^(k+1)`. -/\ntheorem {R : Type u_1} [comm_monoid_with_zero R] (n : R) : is_prime_pow n ↔ ∃ (p : R) (k : ℕ), prime p ∧ p ^ (k + 1) = n :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : ℕ) [hq : exp_char R q] : nat.prime q ∨ q = 1 :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`. -/\ntheorem (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p :=\n\n/--  If a small natural number is divisible by a larger natural number, the small number is zero. -/\ntheorem {a b : ℕ} (w : a ∣ b) (h : b < a) : b = 0 :=\n\n/-- Every natural number greater than `1` is divisible by a prime number.  -/\ntheorem "}
{"text": "A finite torsion-free group is trivial", "fullPrompt": "/-- A nontrivial torsion group is not torsion-free. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G → ¬monoid.is_torsion_free G :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G → ¬monoid.is_torsion G :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i) :=\n\n/-- Finite groups are torsion groups. -/\ntheorem {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem (G : Type u_1) [monoid G] : ¬monoid.is_torsion_free G ↔ ∃ (g : G), g ≠ 1 ∧ is_of_fin_order g :=\n\n/-- A finite group of prime order is simple. -/\ntheorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_simple_group α :=\n\n/-- A p-group is nilpotent -/\ntheorem {G : Type u_1} [hG : group G] [hf : fintype G] {p : ℕ} [hp : fact (nat.prime p)] (h : is_p_group p G) : group.is_nilpotent G :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_cyclic α :=\n\n/-- A group `G` is finitely generated if and only if `add_monoid_algebra R G` is of finite type. -/\ntheorem {R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) ↔ group.fg G :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 1 → a = 1 :=\n\n/--  A word and its maximal reduction correspond to the same element of the free group. -/\ntheorem {α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.mk (free_group.reduce L) = free_group.mk L :=\n\n/-- A finite torsion-free group is trivial -/\ntheorem "}
{"text": "Every finite division ring is a field.", "fullPrompt": "/-- A nontrivial torsion group is not torsion-free. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G → ¬monoid.is_torsion_free G :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G → ¬monoid.is_torsion G :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i) :=\n\n/-- Finite groups are torsion groups. -/\ntheorem {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem (G : Type u_1) [monoid G] : ¬monoid.is_torsion_free G ↔ ∃ (g : G), g ≠ 1 ∧ is_of_fin_order g :=\n\n/-- A finite group of prime order is simple. -/\ntheorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_simple_group α :=\n\n/-- A p-group is nilpotent -/\ntheorem {G : Type u_1} [hG : group G] [hf : fintype G] {p : ℕ} [hp : fact (nat.prime p)] (h : is_p_group p G) : group.is_nilpotent G :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_cyclic α :=\n\n/-- A group `G` is finitely generated if and only if `add_monoid_algebra R G` is of finite type. -/\ntheorem {R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) ↔ group.fg G :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 1 → a = 1 :=\n\n/--  A word and its maximal reduction correspond to the same element of the free group. -/\ntheorem {α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.mk (free_group.reduce L) = free_group.mk L :=\n\n/-- A finite torsion-free group is trivial -/\ntheorem "}
{"text": "Every finite topological space is compact.", "fullPrompt": "/-- In a `t2_space`, every compact set is closed. -/\ntheorem {α : Type u} [topological_space α] [t2_space α] {s : set α} (hs : is_compact s) : is_closed s :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) : is_compact t :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem {α : Type u} [topological_space α] [locally_compact_space α] {K : set α} (hK : is_compact K) : ∃ (K' : set α), is_compact K' ∧ K ⊆ interior K' :=\n\n/-- In a locally compact T₂ space, every point has an open neighborhood with compact closure -/\ntheorem {α : Type u} [topological_space α] [locally_compact_space α] [t2_space α] (x : α) : ∃ (U : set α), is_open U ∧ x ∈ U ∧ is_compact (closure U) :=\n\n/--  Every separated topological group in which there exists a compact set with nonempty interior is locally compact. -/\ntheorem {G : Type w} [topological_space G] [group G] [topological_group G] [t2_space G] (K : topological_space.positive_compacts G) : locally_compact_space G :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) : is_compact (s ∩ t) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s) : is_compact (s ∩ t) :=\n\n/-- An unordered closed interval is compact. -/\ntheorem {α : Type u_1} [linear_order α] [topological_space α] [compact_Icc_space α] {a b : α} : is_compact (set.interval a b) :=\n\n/-- A compact set is bounded above -/\ntheorem {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] [nonempty α] {s : set α} (hs : is_compact s) : bdd_above s :=\n\n/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type w} [fintype ι] (h : basis ι K V) : finite_dimensional K V :=\n\n/-- The span of a finite subset is compact in the lattice of submodules. -/\ntheorem {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (S : finset M) : complete_lattice.is_compact_element (submodule.span R ↑S) :=\n\n/-- If X is is_compact then pr₂ : X × Y → Y is a closed map -/\ntheorem {X : Type u_1} [topological_space X] [compact_space X] {Y : Type u_2} [topological_space Y] : is_closed_map prod.snd :=\n\n/-- Every finite topological space is compact. -/\ntheorem "}
{"text": "Every surjective homomorphism from a finitely generated free group to itself is injective.", "fullPrompt": "/-- The canonical injection from the type to the free group is an injection. -/\ntheorem {α : Type u} : function.injective free_group.of :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 1 → a = 1 :=\n\n/-- An additive group homomorphism is injective if its kernel is trivial. -/\ntheorem {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 0 → a = 0 :=\n\n/--  If two words correspond to the same element in the free group, then they have a common maximal reduction. This is the proof that the function that sends an element of the free group to its maximal reduction is well-defined. -/\ntheorem {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.mk L₁ = free_group.mk L₂) : free_group.reduce L₁ = free_group.reduce L₂ :=\n\n/-- A group homomorphism sends 1 to 1. -/\ntheorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : f 1 = 1 :=\n\n/-- Given a map f from α to β, the natural map from the quotient of α by the kernel of f is    injective. -/\ntheorem {α : Type u_1} {β : Type u_2} (f : α → β) : function.injective (quotient.lift f _) :=\n\n/--  A word and its maximal reduction correspond to the same element of the free group. -/\ntheorem {α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.mk (free_group.reduce L) = free_group.mk L :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : is_monoid_hom f :=\n\n/-- A free module with a basis indexed by a `fintype` is finite. -/\ntheorem {R : Type u_1} {M : Type u_2} {ι : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [fintype ι] (b : basis ι R M) : module.finite R M :=\n\n/--  If two words have a common maximal reduction, then they correspond to the same element in the free group. -/\ntheorem {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.reduce L₁ = free_group.reduce L₂) : free_group.mk L₁ = free_group.mk L₂ :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i) :=\n\n/--  Adding a group element to the point `p` is an injective function. -/\ntheorem {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (λ (_x : G), _x +ᵥ p) :=\n\n/-- The range of a surjective homomorphism from a nilpotent group is nilpotent -/\ntheorem {G : Type u_1} [group G] {G' : Type u_2} [group G'] [h : group.is_nilpotent G] (f : G →* G') (hf : function.surjective ⇑f) : group.is_nilpotent G' :=\n\n/-- Surjective `add_monoid` homomorphisms constant on an additive congruence relation `c`'s equivalence classes induce a surjective homomorphism on `c`'s quotient. -/\ntheorem {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} {f : M →+ P} (h : c ≤ add_con.ker f) (hf : function.surjective ⇑f) : function.surjective ⇑(c.lift f h) :=\n\n/-- Surjective monoid homomorphisms constant on a congruence relation `c`'s equivalence classes    induce a surjective homomorphism on `c`'s quotient. -/\ntheorem {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} {f : M →* P} (h : c ≤ con.ker f) (hf : function.surjective ⇑f) : function.surjective ⇑(c.lift f h) :=\n\n/-- Every surjective homomorphism from a finitely generated free group to itself is injective. -/\ntheorem "}
{"text": "Every positive even integer can be written as the sum of two primes.", "fullPrompt": "/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem  : set.inj_on nat.factorization {x : ℕ | x ≠ 0} :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1 :=\n\n/--  **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n\n/--  If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive. -/\ntheorem {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0 :=\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/\ntheorem {m n : ℕ} : m ∣ m + n ↔ m ∣ n :=\n\n/-- A natural number `m` divides the sum `n + m` if and only if `m` divides `n`. -/\ntheorem {m n : ℕ} : m ∣ n + m ↔ m ∣ n :=\n\n/-- **Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. -/\ntheorem (p : ℕ) [fact (nat.prime p)] : ↑((p - 1).factorial) = -1 :=\n\n/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- Odd Bernoulli numbers (greater than 1) are zero. -/\ntheorem {n : ℕ} (h_odd : odd n) (hlt : 1 < n) : bernoulli' n = 0 :=\n\n/-- Factoring a prime gives the corresponding one-element multiset. -/\ntheorem (p : nat.primes) : ↑p.factor_multiset = prime_multiset.of_prime p :=\n\n/-- A version of `nat.exists_infinite_primes` using the `bdd_above` predicate. -/\ntheorem  : ¬bdd_above {p : ℕ | nat.prime p} :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`. -/\ntheorem (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p :=\n\n/-- A version of `nat.exists_infinite_primes` using the `set.infinite` predicate. -/\ntheorem  : {p : ℕ | nat.prime p}.infinite :=\n\n/-- For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. -/\ntheorem {k : ℕ} (n : ℕ) (hpos : 0 < k) : ∃ (p : ℕ), nat.prime p ∧ n ≤ p ∧ p ≡ 1 [MOD k] :=\n\n/-- If we start with a multiset of primes, take the product and then factor it, we get back the original multiset. -/\ntheorem (v : prime_multiset) : v.prod.factor_multiset = v :=\n\n/-- Every positive even integer can be written as the sum of two primes. -/\ntheorem "}
{"text": "Every matrix satisfies its own characteristic polynomial.", "fullPrompt": "/-- The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a matrix, applied to the matrix itself, is zero.  This holds over any commutative ring.  See `linear_map.aeval_self_charpoly` for the equivalent statement about endomorphisms. -/\ntheorem {R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : ⇑(polynomial.aeval M) M.charpoly = 0 :=\n\n/-- The exponential characteristic is one iff the characteristic is zero. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] (p q : ℕ) [char_p R p] [exp_char R q] : q = 1 ↔ p = 0 :=\n\n/-- The exponential characteristic is one if the characteristic is zero. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] (p : ℕ) [hp : char_p R p] [hq : exp_char R 1] : p = 0 :=\n\n/-- The exponential characteristic is one if the characteristic is zero. -/\ntheorem (R : Type u) [semiring R] (q : ℕ) [hp : char_p R 0] [hq : exp_char R q] : q = 1 :=\n\n/-- The characteristic equals the exponential characteristic iff the former is prime. -/\ntheorem (R : Type u) [semiring R] (p q : ℕ) [hp : char_p R p] [hq : exp_char R q] : p = q ↔ nat.prime p :=\n\n/-- Characteristic `≠ 2` and nontrivial implies that `-1 ≠ 1`. -/\ntheorem {R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R ≠ 2) : -1 ≠ 1 :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : ℕ) [hq : exp_char R q] : nat.prime q ∨ q = 1 :=\n\n/-- A helper lemma: the characteristic is prime if it is non-zero. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] {p : ℕ} [hp : char_p R p] (p_ne_zero : p ≠ 0) : nat.prime p :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem (R : Type u) [non_assoc_ring R] (p : ℕ) [hc : char_p R p] [fintype R] : p ≠ 0 :=\n\n/--  In a finite-dimensional vector space, the zero map has determinant `1` in dimension `0`, and `0` otherwise. We give a formula that also works in infinite dimension, where we define the determinant to be `1`. -/\ntheorem {𝕜 : Type u_1} [field 𝕜] {M : Type u_2} [add_comm_group M] [module 𝕜 M] : ⇑linear_map.det 0 = 0 ^ finite_dimensional.finrank 𝕜 M :=\n\n/-- If `R` has characteristic `0`, then so does Frac(R). -/\ntheorem (R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [char_zero R] : char_zero K :=\n\n/--  The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is, any eigenspace has trivial intersection with the span of all the other eigenspaces. -/\ntheorem {K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] (f : module.End K V) : complete_lattice.independent f.eigenspace :=\n\n/--  The characteristic polynomial of the map `λ x, a * x` is the minimal polynomial of `a`.  In combination with `det_eq_sign_charpoly_coeff` or `trace_eq_neg_charpoly_coeff` and a bit of rewriting, this will allow us to conclude the field norm resp. trace of `x` is the product resp. sum of `x`'s conjugates. -/\ntheorem {K : Type u_1} {S : Type u_2} [field K] [comm_ring S] [algebra K S] (h : power_basis K S) : (⇑(algebra.left_mul_matrix h.basis) h.gen).charpoly = minpoly K h.gen :=\n\n/-- The geometric sequence `q^n` is a solution of `E` iff  `q` is a root of `E`'s characteristic polynomial. -/\ntheorem {α : Type u_1} [comm_ring α] (E : linear_recurrence α) (q : α) : E.is_solution (λ (n : ℕ), q ^ n) ↔ E.char_poly.is_root q :=\n\n/--  The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a linear map, applied to the linear map itself, is zero.  See `matrix.aeval_self_charpoly` for the equivalent statement about matrices. -/\ntheorem {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M →ₗ[R] M) : ⇑(polynomial.aeval f) f.charpoly = 0 :=\n\n/-- `charpoly f` is the characteristic polynomial of the matrix of `f` in any basis. -/\ntheorem {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M →ₗ[R] M) {ι : Type w} [fintype ι] (b : basis ι R M) : (⇑(linear_map.to_matrix b b) f).charpoly = f.charpoly :=\n\n/-- Every matrix satisfies its own characteristic polynomial. -/\ntheorem "}
{"text": "The square root of an irrational number is irrational.", "fullPrompt": "/-- The golden ratio is irrational. -/\ntheorem  : irrational golden_ratio :=\n\n/-- The conjugate of the golden ratio is irrational. -/\ntheorem  : irrational golden_conj :=\n\n/-- Note that most of the lemmas about powers of two refer to it as `sq`. -/\ntheorem {M : Type u} [monoid M] (a : M) : a ^ 2 = a * a :=\n\n/-- **Alias** of the reverse direction of is_square_iff_exists_sq`. -/\ntheorem {α : Type u_2} [monoid α] (m : α) : (∃ (c : α), m = c ^ 2) → is_square m :=\n\n/-- The zeroth Pythagorean triple is all zeros. -/\ntheorem  : pythagorean_triple 0 0 0 :=\n\n/-- **Alias** of the forward direction of is_square_iff_exists_sq`. -/\ntheorem {α : Type u_2} [monoid α] (m : α) : is_square m → (∃ (c : α), m = c ^ 2) :=\n\n/-- Natural division is always less than division in the field. -/\ntheorem {α : Type u_1} [linear_ordered_field α] {m n : ℕ} : ↑(m / n) ≤ ↑m / ↑n :=\n\n/-- There are no perfect squares strictly between m² and (m+1)² -/\ntheorem {n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬∃ (t : ℕ), t * t = n :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem {α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0 :=\n\n/--  If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive. -/\ntheorem {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0 :=\n\n/-- A non-zero `a : F` is a square if and only if `a ^ (#F / 2) = 1`. -/\ntheorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) {a : F} (ha : a ≠ 0) : is_square a ↔ a ^ (fintype.card F / 2) = 1 :=\n\n/-- **Alias** of int.abs_le_self_sq`. -/\ntheorem (a : ℤ) : ↑(a.nat_abs) ≤ a ^ 2 :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem {a : ℕ} : real.sqrt ↑a ≤ ↑(nat.sqrt a) + 1 :=\n\n/-- The natural square root is at most the real square root -/\ntheorem {a : ℕ} : ↑(nat.sqrt a) ≤ real.sqrt ↑a :=\n\n/-- A quadratic has no root if its discriminant has no square root. -/\ntheorem {R : Type u_1} [comm_ring R] [is_domain R] {a b c : R} (h2 : 2 ≠ 0) (ha : a ≠ 0) (h : ∀ (s : R), discrim a b c ≠ s * s) (x : R) : a * x * x + b * x + c ≠ 0 :=\n\n/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem {x y : ℝ} (h : x < y) : ∃ (r : ℝ), irrational r ∧ x < r ∧ r < y :=\n\n/-- A number satisfying the Liouville condition with exponent `p > 1` is an irrational number. -/\ntheorem {p x : ℝ} (h : liouville_with p x) (hp : 1 < p) : irrational x :=\n\n/-- A transcendental real number is irrational. -/\ntheorem {r : ℝ} (tr : transcendental ℚ r) : irrational r :=\n\n/-- If `x + y` is irrational, then at least one of `x` and `y` is irrational. -/\ntheorem {x y : ℝ} : irrational (x + y) → irrational x ∨ irrational y :=\n\n/--  If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x` is irrational. -/\ntheorem {x : ℝ} (n : ℕ) {m : ℤ} (hm : m ≠ 0) (p : ℕ) [hp : fact (nat.prime p)] (hxr : x ^ n = ↑m) (hv : (multiplicity ↑p m).get _ % n ≠ 0) : irrational x :=\n\n/--  If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then `x` is irrational. -/\ntheorem {x : ℝ} (n : ℕ) (m : ℤ) (hxr : x ^ n = ↑m) (hv : ¬∃ (y : ℤ), x = ↑y) (hnpos : 0 < n) : irrational x :=\n\n/-- The square root of an irrational number is irrational. -/\ntheorem "}
{"text": "If the square of a number is even, the number itself is even.", "fullPrompt": "/--  If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive. -/\ntheorem {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0 :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem {α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0 :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) : ∃ (a : F), ¬is_square a :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n\n/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- Two natural numbers are equal if and only if the have the same divisors. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- `0` is always a square (in a monoid with zero). -/\ntheorem (M : Type u_1) [monoid_with_zero M] : is_square 0 :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F = 2) (a : F) : is_square a :=\n\n/-- Note that most of the lemmas about powers of two refer to it as `sq`. -/\ntheorem {M : Type u} [monoid M] (a : M) : a ^ 2 = a * a :=\n\n/-- There are no perfect squares strictly between m² and (m+1)² -/\ntheorem {n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬∃ (t : ℕ), t * t = n :=\n\n/-- **Alias** of the reverse direction of is_square_iff_exists_sq`. -/\ntheorem {α : Type u_2} [monoid α] (m : α) : (∃ (c : α), m = c ^ 2) → is_square m :=\n\n/-- If the square of a number is even, the number itself is even. -/\ntheorem "}
{"text": "In a finite commutative ring, all prime ideals are maximal.", "fullPrompt": "/--  A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p :=\n\n/--  The prime divisors of the characteristic of a finite commutative ring are exactly the prime divisors of its cardinality. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : p ∣ ring_char R ↔ p ∣ fintype.card R :=\n\n/--  A prime `p` is a unit in a finite commutative ring `R` iff it does not divide the characteristic. -/\ntheorem (R : Type u_1) [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : is_unit ↑p ↔ ¬p ∣ ring_char R :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem (R : Type u) [non_assoc_ring R] (p : ℕ) [hc : char_p R p] [fintype R] : p ≠ 0 :=\n\n/-- The variable of the power series ring over an integral domain is prime. -/\ntheorem {R : Type u_1} [comm_ring R] [is_domain R] : prime power_series.X :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem {α : Type u_1} [fintype α] [field α] : is_prime_pow (fintype.card α) :=\n\n/--  An algebra over a Noetherian ring is finitely generated if and only if it is finitely presented. -/\ntheorem {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] [is_noetherian_ring R] : algebra.finite_type R A ↔ algebra.finite_presentation R A :=\n\n/-- A module over a division ring is noetherian if and only if it is finitely generated. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V ↔ module.finite K V :=\n\n/-- An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a discrete valuation ring. -/\ntheorem {R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) : discrete_valuation_ring R :=\n\n/-- A minimal polynomial is prime. -/\ntheorem {A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) : prime (minpoly A x) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_cyclic α :=\n\n/--  A `comm_ring` `K` which is the localization of an integral domain `R` at `R - {0}` is an integral domain. -/\ntheorem (A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] : is_domain K :=\n\n/-- If an element a divides another element b in a commutative ring, a divides the sum of b and  another element c iff a divides c. -/\ntheorem {α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ b) : a ∣ b + c ↔ a ∣ c :=\n\n/-- If an element a divides another element c in a commutative ring, a divides the sum of another  element b with c iff a divides b. -/\ntheorem {α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ c) : a ∣ b + c ↔ a ∣ b :=\n\n/--  A ring is a Jacobson ring if and only if for all prime ideals `P`, the Jacobson radical of `P` is equal to `P`. -/\ntheorem {R : Type u_1} [comm_ring R] : ideal.is_jacobson R ↔ ∀ (P : ideal R), P.is_prime → P.jacobson = P :=\n\n/--  In a Dedekind domain, the (nonzero) prime elements of the monoid with zero `ideal A` are exactly the prime ideals. -/\ntheorem {A : Type u_2} [comm_ring A] [is_domain A] [is_dedekind_domain A] {P : ideal A} (hP : P ≠ ⊥) : prime P ↔ P.is_prime :=\n\n/--  If `R` is a ring, then prime ideals in the localization at `M` correspond to prime ideals in the original ring `R` that are disjoint from `M`. This lemma gives the particular case for an ideal and its comap, see `le_rel_iso_of_prime` for the more general relation isomorphism -/\ntheorem {R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] (J : ideal S) : J.is_prime ↔ (ideal.comap (algebra_map R S) J).is_prime ∧ disjoint ↑M ↑(ideal.comap (algebra_map R S) J) :=\n\n/-- In a finite commutative ring, all prime ideals are maximal. -/\ntheorem "}
{"text": "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.", "fullPrompt": "/-- The Hausdorff distance between a set and itself is zero -/\ntheorem {α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist s s = 0 :=\n\n/-- The Hausdorff distance satisfies the triangular inequality -/\ntheorem {α : Type u} [pseudo_emetric_space α] {s t u : set α} : emetric.Hausdorff_edist s u ≤ emetric.Hausdorff_edist s t + emetric.Hausdorff_edist t u :=\n\n/-- The Hausdorff edistance of a set to itself vanishes -/\ntheorem {α : Type u} [pseudo_emetric_space α] {s : set α} : emetric.Hausdorff_edist s s = 0 :=\n\n/-- The distance to a set is controlled by the Hausdorff distance -/\ntheorem {α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} (h : x ∈ s) : emetric.inf_edist x t ≤ emetric.Hausdorff_edist s t :=\n\n/-- The Hausdorff distance is nonnegative -/\ntheorem {α : Type u} [pseudo_metric_space α] {s t : set α} : 0 ≤ metric.Hausdorff_dist s t :=\n\n/-- The second projection in a product of topological spaces sends open sets to open sets. -/\ntheorem {α : Type u} {β : Type v} [topological_space α] [topological_space β] : is_open_map prod.snd :=\n\n/-- If X is is_compact then pr₂ : X × Y → Y is a closed map -/\ntheorem {X : Type u_1} [topological_space X] [compact_space X] {Y : Type u_2} [topological_space Y] : is_closed_map prod.snd :=\n\n/-- A Hausdorff space with a clopen basis is totally separated. -/\ntheorem {α : Type u} [topological_space α] [t2_space α] (h : topological_space.is_topological_basis {s : set α | is_clopen s}) : totally_separated_space α :=\n\n/-- The first projection in a product of topological spaces sends open sets to open sets. -/\ntheorem {α : Type u} {β : Type v} [topological_space α] [topological_space β] : is_open_map prod.fst :=\n\n/-- The Hausdorff distance from `s` to `t` and from `t` to `s` coincide -/\ntheorem {α : Type u} [pseudo_metric_space α] {s t : set α} : metric.Hausdorff_dist s t = metric.Hausdorff_dist t s :=\n\n/-- In a sequential space, a set is closed iff it's sequentially closed. -/\ntheorem {X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s ↔ is_closed s :=\n\n/-- A locally compact Hausdorff space is totally disconnected  if and only if it is totally separated. -/\ntheorem {H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] : totally_disconnected_space H ↔ totally_separated_space H :=\n\n/-- A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$. -/\ntheorem "}
{"text": "If every point of a subset of a topological space is contained in some open set, the subset itself is open.", "fullPrompt": "/-- If a subgroup of a topological group has `1` in its interior, then it is open. -/\ntheorem {G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 ∈ interior ↑H) : is_open ↑H :=\n\n/-- Any open set is the union of the basis sets contained in it. -/\ntheorem {α : Type u} [t : topological_space α] {B : set (set α)} (hB : topological_space.is_topological_basis B) {u : set α} (ou : is_open u) : u = ⋃₀{s ∈ B | s ⊆ u} :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem {α : Type u} [topological_space α] [locally_compact_space α] {K : set α} (hK : is_compact K) : ∃ (K' : set α), is_compact K' ∧ K ⊆ interior K' :=\n\n/-- The intersection of a dense set with an open dense set is a dense set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (hs : dense s) (ht : dense t) (hto : is_open t) : dense (s ∩ t) :=\n\n/-- The intersection of an open dense set with a dense set is a dense set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (hs : dense s) (ht : dense t) (hso : is_open s) : dense (s ∩ t) :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) : is_compact t :=\n\n/--  This lemma characterizes discrete topological spaces as those whose singletons are neighbourhoods. -/\ntheorem {X : Type u_1} [topological_space X] : discrete_topology X ↔ nhds = has_pure.pure :=\n\n/-- An open set is a Gδ set. -/\ntheorem {α : Type u_1} [topological_space α] {s : set α} (h : is_open s) : is_Gδ s :=\n\n/-- In a locally compact T₂ space, every point has an open neighborhood with compact closure -/\ntheorem {α : Type u} [topological_space α] [locally_compact_space α] [t2_space α] (x : α) : ∃ (U : set α), is_open U ∧ x ∈ U ∧ is_compact (closure U) :=\n\n/-- The first projection in a product of topological spaces sends open sets to open sets. -/\ntheorem {α : Type u} {β : Type v} [topological_space α] [topological_space β] : is_open_map prod.fst :=\n\n/-- The closure of a (pre)connected set is (pre)connected as well. -/\ntheorem {α : Type u} [topological_space α] {s : set α} (H : is_preconnected s) : is_preconnected (closure s) :=\n\n/-- The frontier of a closed set has no interior point. -/\ntheorem {α : Type u} [topological_space α] {s : set α} (h : is_closed s) : interior (frontier s) = ∅ :=\n\n/-- Every member of an open set in a compact Hausdorff totally disconnected space  is contained in a clopen set contained in the open set. -/\ntheorem {α : Type u} [topological_space α] [t2_space α] [compact_space α] [totally_disconnected_space α] {x : α} {U : set α} (is_open : _root_.is_open U) (memU : x ∈ U) : ∃ (V : set α) (hV : is_clopen V), x ∈ V ∧ V ⊆ U :=\n\n/-- If every point of a subset of a topological space is contained in some open set, the subset itself is open. -/\ntheorem "}
{"text": "Every non-identity element of a free group is of infinite order.", "fullPrompt": "/--  If two words correspond to the same element in the free group, then they have a common maximal reduction. This is the proof that the function that sends an element of the free group to its maximal reduction is well-defined. -/\ntheorem {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.mk L₁ = free_group.mk L₂) : free_group.reduce L₁ = free_group.reduce L₂ :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem {G : Type u} [group G] {x : G} : is_of_fin_order x⁻¹ ↔ is_of_fin_order x :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G → ¬monoid.is_torsion G :=\n\n/--  A word and its maximal reduction correspond to the same element of the free group. -/\ntheorem {α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.mk (free_group.reduce L) = free_group.mk L :=\n\n/--  If two words have a common maximal reduction, then they correspond to the same element in the free group. -/\ntheorem {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.reduce L₁ = free_group.reduce L₂) : free_group.mk L₁ = free_group.mk L₂ :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem (G : Type u_1) [monoid G] : ¬monoid.is_torsion_free G ↔ ∃ (g : G), g ≠ 1 ∧ is_of_fin_order g :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ↔ is_of_fin_add_order x :=\n\n/-- The canonical injection from the type to the free group is an injection. -/\ntheorem {α : Type u} : function.injective free_group.of :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem {G : Type u} [add_group G] {x : G} (hx : is_of_fin_add_order x) : is_of_fin_add_order (-x) :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem {G : Type u} [add_group G] {x : G} : is_of_fin_add_order (-x) ↔ is_of_fin_add_order x :=\n\n/-- 1 is of finite order in any monoid. -/\ntheorem {G : Type u} [monoid G] : is_of_fin_order 1 :=\n\n/-- A monoid is not a torsion monoid if it has an element of infinite order. -/\ntheorem (G : Type u_1) [monoid G] : ¬monoid.is_torsion G ↔ ∃ (g : G), ¬is_of_fin_order g :=\n\n/-- An additive monoid is not a torsion monoid if it has an element of infinite order. -/\ntheorem (G : Type u_1) [add_monoid G] : ¬add_monoid.is_torsion G ↔ ∃ (g : G), ¬is_of_fin_add_order g :=\n\n/-- Shows that any non-identity element of $A_5$ whose cycle decomposition consists only of swaps  is conjugate to $(04)(13)$. This is used to show that the normal closure of such a permutation  in $A_5$ is $A_5$. -/\ntheorem {g : equiv.perm (fin 5)} (ha : g ∈ alternating_group (fin 5)) (h1 : g ≠ 1) (h2 : ∀ (n : ℕ), n ∈ g.cycle_type → n = 2) : is_conj (equiv.swap 0 4 * equiv.swap 1 3) g :=\n\n/-- Every non-identity element of a free group is of infinite order. -/\ntheorem "}
{"text": "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.", "fullPrompt": "/-- An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a discrete valuation ring. -/\ntheorem {R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) : discrete_valuation_ring R :=\n\n/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem {Γ₀ : Type u_3} [linear_ordered_comm_monoid_with_zero Γ₀] [nontrivial Γ₀] {K : Type u_1} [division_ring K] (v : valuation K Γ₀) {x : K} : ⇑v x = 0 ↔ x = 0 :=\n\n/--  A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p :=\n\n/--  A prime `p` is a unit in a finite commutative ring `R` iff it does not divide the characteristic. -/\ntheorem (R : Type u_1) [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : is_unit ↑p ↔ ¬p ∣ ring_char R :=\n\n/--  An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a unique factorization domain. See `discrete_valuation_ring.of_has_unit_mul_pow_irreducible_factorization`. -/\ntheorem {R : Type u_1} [comm_ring R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) [is_domain R] : unique_factorization_monoid R :=\n\n/-- Units of a monoid divide any element of the monoid. -/\ntheorem {α : Type u_1} [monoid α] {a u : α} (hu : is_unit u) : u ∣ a :=\n\n/-- A division_ring is one-dimensional as a vector space over itself. -/\ntheorem (K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1 :=\n\n/-- A minimal polynomial is not a unit. -/\ntheorem (A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : ¬is_unit (minpoly A x) :=\n\n/-- If `R` is an additive monoid, an element in `add_units R` is add-regular. -/\ntheorem {R : Type u_1} [add_monoid R] (a : add_units R) : is_add_regular ↑a :=\n\n/-- In a local ring the characteristics is either zero or a prime power. -/\ntheorem (R : Type u_1) [comm_ring R] [local_ring R] (q : ℕ) [char_R_q : char_p R q] : q = 0 ∨ is_prime_pow q :=\n\n/-- A localization always has cardinality less than or equal to the base ring. -/\ntheorem {R : Type u} [comm_ring R] (S : submonoid R) {L : Type u} [comm_ring L] [algebra R L] [is_localization S L] : cardinal.mk L ≤ cardinal.mk R :=\n\n/--  The localization at of an integral domain to a set of non-zero elements is an integral domain. See note [reducible non-instances]. -/\ntheorem {A : Type u_6} [comm_ring A] [is_domain A] {M : submonoid A} (hM : M ≤ non_zero_divisors A) : is_domain (localization M) :=\n\n/-- A unique factorization domain with at least one irreducible element in which all irreducible elements are associated is a discrete valuation ring. -/\ntheorem {R : Type u} [comm_ring R] [is_domain R] [unique_factorization_monoid R] (h₁ : ∃ (p : R), irreducible p) (h₂ : ∀ ⦃p q : R⦄, irreducible p → irreducible q → associated p q) : discrete_valuation_ring R :=\n\n/--  If `𝒪` satisfies `v.integers 𝒪` where `v` is a valuation on a field, then `𝒪` is a valuation ring. -/\ntheorem {𝒪 : Type u} {K : Type v} {Γ : Type w} [comm_ring 𝒪] [is_domain 𝒪] [field K] [algebra 𝒪 K] [linear_ordered_comm_group_with_zero Γ] (v : valuation K Γ) (hh : v.integers 𝒪) : valuation_ring 𝒪 :=\n\n/-- An element of a discrete valuation ring is a unit if and only if it has a valuation of zero. -/\ntheorem "}
{"text": "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.", "fullPrompt": "/--  **Bézout's lemma**: given `x y : ℕ`, `gcd x y = x * a + y * b`, where `a = gcd_a x y` and `b = gcd_b x y` are computed by the extended Euclidean algorithm. -/\ntheorem (x y : ℕ) : ↑(x.gcd y) = ↑x * x.gcd_a y + ↑y * x.gcd_b y :=\n\n/--  For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be written in the form `a * x + b * y` for some pair of integers `x` and `y` -/\ntheorem {a b : ℤ} (ha : a ≠ 0) : is_least {n : ℕ | 0 < n ∧ ∃ (x y : ℤ), ↑n = a * x + b * y} (a.gcd b) :=\n\n/-- A list with positive sum must have positive length. -/\ntheorem {M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : 0 < L.sum) : 0 < L.length :=\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/\ntheorem {m n : ℕ} : m ∣ m + n ↔ m ∣ n :=\n\n/--  **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p :=\n\n/-- A pair (i, j) is contained in the antidiagonal of `n` if and only if `i + j = n`. -/\ntheorem {n : ℕ} {x : ℕ × ℕ} : x ∈ list.nat.antidiagonal n ↔ x.fst + x.snd = n :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem  : set.inj_on nat.factorization {x : ℕ | x ≠ 0} :=\n\n/-- `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)` for some `k`. -/\ntheorem (m : ℕ) {n : ℕ} (hn : 0 < n) : (∃ (k : ℕ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m :=\n\n/-- A natural number `m` divides the sum `n + m` if and only if `m` divides `n`. -/\ntheorem {m n : ℕ} : m ∣ n + m ↔ m ∣ n :=\n\n/--  Every pair `![c, d]` of coprime integers is the \"bottom_row\" of some element `g=[[*,*],[c,d]]` of `SL(2,ℤ)`. -/\ntheorem {R : Type u_1} [comm_ring R] : set.surj_on (λ (g : matrix.special_linear_group (fin 2) R), ↑g 1) set.univ {cd : fin 2 → R | is_coprime (cd 0) (cd 1)} :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`. -/\ntheorem (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p :=\n\n/-- If `n > 0` then `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)`  for some `k`. -/\ntheorem (m : ℤ) {n : ℤ} (hn : 0 < n) : (∃ (k : ℤ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m :=\n\n/-- We now have four different results that all encode the idea that inequality of multisets corresponds to divisibility of positive integers. -/\ntheorem {m n : ℕ+} : m.factor_multiset ≤ n.factor_multiset ↔ m ∣ n :=\n\n/-- The gcd and lcm operations on positive integers correspond to the inf and sup operations on multisets. -/\ntheorem (m n : ℕ+) : (m.gcd n).factor_multiset = m.factor_multiset ⊓ n.factor_multiset :=\n\n/--  Viewing a module as an affine space modelled on itself, a `weighted_vsub` is just a linear combination. -/\ntheorem {k : Type u_1} {V : Type u_2} [ring k] [add_comm_group V] [module k V] {ι : Type u_3} (s : finset ι) {w : ι → k} {p : ι → V} (hw : s.sum w = 0) : ⇑(s.weighted_vsub p) w = s.sum (λ (i : ι), w i • p i) :=\n\n/--  The inner product of a linear combination of a set of orthonormal vectors with one of those vectors picks out the coefficient of that vector. -/\ntheorem {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : orthonormal 𝕜 v) (l : ι →₀ 𝕜) (i : ι) : has_inner.inner (⇑(finsupp.total ι E 𝕜 v) l) (v i) = ⇑(star_ring_end 𝕜) (⇑l i) :=\n\n/--  The inner product of a linear combination of a set of orthonormal vectors with one of those vectors picks out the coefficient of that vector. -/\ntheorem {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : orthonormal 𝕜 v) (l : ι → 𝕜) {s : finset ι} {i : ι} (hi : i ∈ s) : has_inner.inner (s.sum (λ (i : ι), l i • v i)) (v i) = ⇑(star_ring_end 𝕜) (l i) :=\n\n/--  The inner product of a linear combination of a set of orthonormal vectors with one of those vectors picks out the coefficient of that vector. -/\ntheorem {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} [fintype ι] {v : ι → E} (hv : orthonormal 𝕜 v) (l : ι → 𝕜) (i : ι) : has_inner.inner (finset.univ.sum (λ (i : ι), l i • v i)) (v i) = ⇑(star_ring_end 𝕜) (l i) :=\n\n/-- `f = O(g)` if and only if `∀ᶠ x in l, ∥f x∥ ≤ c * ∥g x∥` for all sufficiently large `c`. -/\ntheorem {α : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : α → E} {g' : α → F'} {l : filter α} : f =O[l] g' ↔ ∀ᶠ (c : ℝ) in filter.at_top, ∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g' x∥ :=\n\n/-- \"Semicontinuity of the `lp` norm\": If all sufficiently large elements of a sequence in `lp E p` have `lp` norm `≤ C`, then the pointwise limit, if it exists, also has `lp` norm `≤ C`. -/\ntheorem {α : Type u_1} {E : α → Type u_2} {p : ennreal} [Π (i : α), normed_group (E i)] {ι : Type u_3} {l : filter ι} [l.ne_bot] [fact (1 ≤ p)] {C : ℝ} {F : ι → ↥(lp E p)} (hCF : ∀ᶠ (k : ι) in l, ∥F k∥ ≤ C) {f : ↥(lp E p)} (hf : filter.tendsto (id (λ (i : ι), ⇑(F i))) l (nhds ⇑f)) : ∥f∥ ≤ C :=\n\n/-- `f = O(g)` if and only if `is_O_with c f g` for all sufficiently large `c`. -/\ntheorem {α : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : α → E} {g' : α → F'} {l : filter α} : f =O[l] g' ↔ ∀ᶠ (c : ℝ) in filter.at_top, asymptotics.is_O_with c l f g' :=\n\n/--  If two integers are congruent to a sufficiently large modulus, they are equal. -/\ntheorem {a b c : ℤ} (h1 : a % b = c) (h2 : (a - c).nat_abs < b.nat_abs) : a = c :=\n\n/-- For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers. -/\ntheorem "}
{"text": "Every field is a ring.", "fullPrompt": "/-- `ℤ` with its usual ring structure is not a field. -/\ntheorem  : ¬is_field ℤ :=\n\n/-- `polynomial R` is never a field for any ring `R`. -/\ntheorem {R : Type u} [ring R] : ¬is_field (polynomial R) :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem (R : Type u) [non_assoc_ring R] (p : ℕ) [hc : char_p R p] [fintype R] : p ≠ 0 :=\n\n/-- For a perfect ring, it itself is the perfection. -/\ntheorem (p : ℕ) [fact (nat.prime p)] (R : Type u₁) [comm_semiring R] [char_p R p] [perfect_ring R p] : perfection_map p (ring_hom.id R) :=\n\n/-- An element of an algebra over a field is algebraic if and only if it is integral. -/\ntheorem {K : Type u} {A : Type v} [field K] [ring A] [algebra K A] {x : A} : is_algebraic K x ↔ is_integral K x :=\n\n/-- An element of a ring multiplied by the additive inverse of one is the element's additive  inverse. -/\ntheorem {α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : a * -1 = -a :=\n\n/-- There is a field structure on type if and only if its cardinality is a prime power. -/\ntheorem {α : Type u} : nonempty (field α) ↔ is_prime_pow (cardinal.mk α) :=\n\n/--  For each field, and for each nonzero element of said field, there is a unique inverse. Since `is_field` doesn't remember the data of an `inv` function and as such, a lemma that there is a unique inverse could be useful. -/\ntheorem (R : Type u) [ring R] (hf : is_field R) (x : R) : x ≠ 0 → (∃! (y : R), x * y = 1) :=\n\n/-- The additive inverse of one multiplied by an element of a ring is the element's additive  inverse. -/\ntheorem {α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : (-1) * a = -a :=\n\n/--  If `R` is a ring which is a topological semiring, then it is automatically a topological ring. This exists so that one can place a topological ring structure on `R` without explicitly proving `continuous_neg`. -/\ntheorem {α : Type u_1} [topological_space α] [non_assoc_ring α] (h : topological_semiring α) : topological_ring α :=\n\n/-- We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem {R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2) : 2 ≠ 0 :=\n\n/-- Right multiplication in a ring is an additive monoid morphism. -/\ntheorem {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), y * x) :=\n\n/-- Every field is a ring. -/\ntheorem "}
{"text": "The set of units in a ring forms a group.", "fullPrompt": "/--  A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p :=\n\n/-- Units of a monoid divide any element of the monoid. -/\ntheorem {α : Type u_1} [monoid α] {a u : α} (hu : is_unit u) : u ∣ a :=\n\n/-- An element of a ring multiplied by the additive inverse of one is the element's additive  inverse. -/\ntheorem {α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : a * -1 = -a :=\n\n/-- The additive inverse of one multiplied by an element of a ring is the element's additive  inverse. -/\ntheorem {α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : (-1) * a = -a :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/--  A prime `p` is a unit in a finite commutative ring `R` iff it does not divide the characteristic. -/\ntheorem (R : Type u_1) [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : is_unit ↑p ↔ ¬p ∣ ring_char R :=\n\n/-- The set of natural number powers of an element of a monoid is closed under multiplication. -/\ntheorem {M : Type u_1} [monoid M] {x y z : M} : y ∈ powers x → z ∈ powers x → y * z ∈ powers x :=\n\n/-- If `R` is an additive monoid, an element in `add_units R` is add-regular. -/\ntheorem {R : Type u_1} [add_monoid R] (a : add_units R) : is_add_regular ↑a :=\n\n/-- An element of a monoid is in the set of that element's natural number powers. -/\ntheorem {M : Type u_1} [monoid M] {x : M} : x ∈ powers x :=\n\n/-- Elements of finite additive order are closed under addition. -/\ntheorem {G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y) :=\n\n/-- Left multiplication in a ring is an additive monoid morphism. -/\ntheorem {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), x * y) :=\n\n/-- 1 is in the set of natural number powers of an element of a monoid. -/\ntheorem {M : Type u_1} [monoid M] {x : M} : 1 ∈ powers x :=\n\n/-- When lowered to a prop, `matrix.diagonal_invertible_equiv_invertible` forms an `iff`. -/\ntheorem {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {v : n → α} : is_unit (matrix.diagonal v) ↔ is_unit v :=\n\n/-- When lowered to a prop, `matrix.invertible_equiv_det_invertible` forms an `iff`. -/\ntheorem {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) : is_unit A ↔ is_unit A.det :=\n\n/--  *Engel's theorem*.  Note that this implies all traditional forms of Engel's theorem via `lie_module.nontrivial_max_triv_of_is_nilpotent`, `lie_module.is_nilpotent_iff_forall`, `lie_algebra.is_nilpotent_iff_forall`. -/\ntheorem {R : Type u₁} {L : Type u₂} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : lie_algebra.is_engelian R L :=\n\n/--  The map `B.polar : set E → set F` forms an order-reversing Galois connection with `B.flip.polar : set F → set E`. We use `order_dual.to_dual` and `order_dual.of_dual` to express that `polar` is order-reversing. -/\ntheorem {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [normed_comm_ring 𝕜] [add_comm_monoid E] [add_comm_monoid F] [module 𝕜 E] [module 𝕜 F] (B : E →ₗ[𝕜] F →ₗ[𝕜] 𝕜) : galois_connection (⇑order_dual.to_dual ∘ B.polar) (B.flip.polar ∘ ⇑order_dual.of_dual) :=\n\n/--  If a family of submodules is `independent`, then a choice of nonzero vector from each submodule forms a linearly independent family. -/\ntheorem {ι : Type u_1} {R : Type u_2} {N : Type u_5} [ring R] [add_comm_group N] [module R N] [no_zero_smul_divisors R N] (p : ι → submodule R N) (hp : complete_lattice.independent p) {v : ι → N} (hv : ∀ (i : ι), v i ∈ p i) (hv' : ∀ (i : ι), v i ≠ 0) : linear_independent R v :=\n\n/-- The set of units in a ring forms a group. -/\ntheorem "}
{"text": "If the direct product of two groups is torsion free then each of the groups is torsion free.", "fullPrompt": "/-- Direct products of torsion free groups are torsion free. -/\ntheorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i) :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G → ¬monoid.is_torsion_free G :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G → ¬monoid.is_torsion G :=\n\n/-- Finite groups are torsion groups. -/\ntheorem {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G :=\n\n/-- If a direct product has finite order then so does each component. -/\ntheorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_order x) (i : η) : is_of_fin_order (x i) :=\n\n/-- If a direct product has finite additive order then so does each component. -/\ntheorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_add_order x) (i : η) : is_of_fin_add_order (x i) :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem (G : Type u_1) [monoid G] : ¬monoid.is_torsion_free G ↔ ∃ (g : G), g ≠ 1 ∧ is_of_fin_order g :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem {G : Type u_3} [group G] : group.fg G ↔ monoid.fg G :=\n\n/--  If `α` has no zero divisors, then the product of two elements is nonzero iff both of them are nonzero. -/\ntheorem {M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b ≠ 0 ↔ a ≠ 0 ∧ b ≠ 0 :=\n\n/--  If `α` has no zero divisors, then for elements `a, b : α`, `a * b` is nonzero iff so is `b * a`. -/\ntheorem {M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b ≠ 0 ↔ b * a ≠ 0 :=\n\n/-- A group `G` is finitely generated if and only if `add_monoid_algebra R G` is of finite type. -/\ntheorem {R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) ↔ group.fg G :=\n\n/--  If `α` has no zero divisors, then the product of two elements equals zero iff one of them equals zero. -/\ntheorem {M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : 0 = a * b ↔ a = 0 ∨ b = 0 :=\n\n/-- Direct products of additive torsion free groups are torsion free. -/\ntheorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_group (Gs i)] (tfGs : ∀ (i : η), add_monoid.is_torsion_free (Gs i)) : add_monoid.is_torsion_free (Π (i : η), Gs i) :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem (G : Type u_1) [add_comm_group G] : add_monoid.is_torsion_free (G ⧸ add_torsion G) :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem (G : Type u_1) [comm_group G] : monoid.is_torsion_free (G ⧸ torsion G) :=\n\n/-- The commutator of a finite direct product is contained in the direct product of the commutators. -/\ntheorem {η : Type u_1} [fintype η] {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (H K : Π (i : η), subgroup (Gs i)) : ⁅subgroup.pi set.univ H,subgroup.pi set.univ K⁆ = subgroup.pi set.univ (λ (i : η), ⁅H i,K i⁆) :=\n\n/--  The commutator of direct product is contained in the direct product of the commutators.  See `commutator_pi_pi_of_fintype` for equality given `fintype η`. -/\ntheorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (H K : Π (i : η), subgroup (Gs i)) : ⁅subgroup.pi set.univ H,subgroup.pi set.univ K⁆ ≤ subgroup.pi set.univ (λ (i : η), ⁅H i,K i⁆) :=\n\n/-- If the direct product of two groups is torsion free then each of the groups is torsion free. -/\ntheorem "}
