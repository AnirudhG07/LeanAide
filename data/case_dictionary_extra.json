[
  {
    "snakecase": "is_domain",
    "camelcase": "IsDomain"
  },
  {
    "snakecase": "or",
    "camelcase": "Or"
  },
  {
    "snakecase": "of_nat",
    "camelcase": "OfNat"
  },
  {
    "snakecase": "pfunctor",
    "camelcase": "Pfunctor"
  },
  {
    "snakecase": "is_compact",
    "camelcase": "IsCompact"
  },
  {
    "snakecase": "conformal",
    "camelcase": "Conformal"
  },
  {
    "snakecase": "fundamental_group",
    "camelcase": "FundamentalGroup"
  },
  {
    "snakecase": "monoid_with_zero_hom",
    "camelcase": "MonoidWithZeroHom"
  },
  {
    "snakecase": "padic",
    "camelcase": "Padic"
  },
  {
    "snakecase": "add_mon",
    "camelcase": "AddMon"
  },
  {
    "snakecase": "and",
    "camelcase": "And"
  },
  {
    "snakecase": "born",
    "camelcase": "Born"
  },
  {
    "snakecase": "is_open",
    "camelcase": "IsOpen"
  },
  {
    "snakecase": "seq",
    "camelcase": "Seq"
  },
  {
    "snakecase": "is_localization",
    "camelcase": "IsLocalization"
  },
  {
    "snakecase": "name",
    "camelcase": "Name"
  },
  {
    "snakecase": "directed",
    "camelcase": "Directed"
  },
  {
    "snakecase": "l_mul",
    "camelcase": "L_mul"
  },
  {
    "snakecase": "iff",
    "camelcase": "Iff"
  },
  {
    "snakecase": "class",
    "camelcase": "Class"
  },
  {
    "snakecase": "mon",
    "camelcase": "Mon"
  },
  {
    "snakecase": "is_fraction_ring",
    "camelcase": "IsFractionRing"
  },
  {
    "snakecase": "separated",
    "camelcase": "Separated"
  },
  {
    "snakecase": "free_group",
    "camelcase": "FreeGroup"
  },
  {
    "snakecase": "field",
    "camelcase": "Field"
  },
  {
    "snakecase": "linear_order",
    "camelcase": "LinearOrder"
  },
  {
    "snakecase": "partial_order",
    "camelcase": "PartialOrder"
  },
  {
    "snakecase": "add_comm_group",
    "camelcase": "AddCommGroup"
  },
  {
    "snakecase": "comm_mon",
    "camelcase": "CommMon"
  },
  {
    "snakecase": "associative",
    "camelcase": "Associative"
  },
  {
    "snakecase": "contravariant",
    "camelcase": "Contravariant"
  },
  {
    "snakecase": "mod",
    "camelcase": "Mod"
  },
  {
    "snakecase": "semi_normed_group",
    "camelcase": "SemiNormedGroup"
  },
  {
    "snakecase": "boolean_algebra",
    "camelcase": "BooleanAlgebra"
  },
  {
    "snakecase": "model_with_corners",
    "camelcase": "ModelWithCorners"
  },
  {
    "snakecase": "mon_",
    "camelcase": "Mon_"
  },
  {
    "snakecase": "well_order",
    "camelcase": "WellOrder"
  },
  {
    "snakecase": "or_else",
    "camelcase": "OrElse"
  },
  {
    "snakecase": "cont_diff_bump",
    "camelcase": "ContDiffBump"
  },
  {
    "snakecase": "top",
    "camelcase": "Top"
  },
  {
    "snakecase": "magma",
    "camelcase": "Magma"
  },
  {
    "snakecase": "isometric",
    "camelcase": "Isometric"
  },
  {
    "snakecase": "has_lift",
    "camelcase": "HasLift"
  },
  {
    "snakecase": "module",
    "camelcase": "Module"
  },
  {
    "snakecase": "is_per",
    "camelcase": "IsPer"
  },
  {
    "snakecase": "linear_ordered_comm_monoid",
    "camelcase": "LinearOrderedCommMonoid"
  },
  {
    "snakecase": "ordered_cancel_add_comm_monoid",
    "camelcase": "OrderedCancelAddCommMonoid"
  },
  {
    "snakecase": "has_sep",
    "camelcase": "HasSep"
  },
  {
    "snakecase": "set",
    "camelcase": "Set"
  },
  {
    "snakecase": "with_zero",
    "camelcase": "WithZero"
  },
  {
    "snakecase": "is_empty",
    "camelcase": "IsEmpty"
  },
  {
    "snakecase": "pfun",
    "camelcase": "Pfun"
  },
  {
    "snakecase": "irreducible",
    "camelcase": "Irreducible"
  },
  {
    "snakecase": "zmod",
    "camelcase": "Zmod"
  },
  {
    "snakecase": "io",
    "camelcase": "Io"
  },
  {
    "snakecase": "is_integral_closure",
    "camelcase": "IsIntegralClosure"
  },
  {
    "snakecase": "group_filter_basis",
    "camelcase": "GroupFilterBasis"
  },
  {
    "snakecase": "cycle",
    "camelcase": "Cycle"
  },
  {
    "snakecase": "r_mul",
    "camelcase": "R_mul"
  },
  {
    "snakecase": "lower_set",
    "camelcase": "LowerSet"
  },
  {
    "snakecase": "structomorph",
    "camelcase": "Structomorph"
  },
  {
    "snakecase": "mul_action_hom",
    "camelcase": "MulActionHom"
  },
  {
    "snakecase": "stone_cech",
    "camelcase": "StoneCech"
  },
  {
    "snakecase": "total",
    "camelcase": "Total"
  },
  {
    "snakecase": "is_lub",
    "camelcase": "IsLub"
  },
  {
    "snakecase": "is_max_chain",
    "camelcase": "IsMaxChain"
  },
  {
    "snakecase": "sub",
    "camelcase": "Sub"
  },
  {
    "snakecase": "shrink",
    "camelcase": "Shrink"
  },
  {
    "snakecase": "is_unit",
    "camelcase": "IsUnit"
  },
  {
    "snakecase": "action",
    "camelcase": "Action"
  },
  {
    "snakecase": "connected_space",
    "camelcase": "ConnectedSpace"
  },
  {
    "snakecase": "is_cau_seq",
    "camelcase": "IsCauSeq"
  },
  {
    "snakecase": "is_open_map",
    "camelcase": "IsOpenMap"
  },
  {
    "snakecase": "conjugates_of",
    "camelcase": "ConjugatesOf"
  },
  {
    "snakecase": "comm_ring",
    "camelcase": "CommRing"
  },
  {
    "snakecase": "div",
    "camelcase": "Div"
  },
  {
    "snakecase": "is_local_min",
    "camelcase": "IsLocalMin"
  },
  {
    "snakecase": "eq",
    "camelcase": "Eq"
  },
  {
    "snakecase": "symmetric",
    "camelcase": "Symmetric"
  },
  {
    "snakecase": "is_local_max",
    "camelcase": "IsLocalMax"
  },
  {
    "snakecase": "ring_hom",
    "camelcase": "RingHom"
  },
  {
    "snakecase": "mul_hom",
    "camelcase": "MulHom"
  },
  {
    "snakecase": "add_comm_mon",
    "camelcase": "AddCommMon"
  },
  {
    "snakecase": "order_iso",
    "camelcase": "OrderIso"
  },
  {
    "snakecase": "submonoid",
    "camelcase": "Submonoid"
  },
  {
    "snakecase": "is_closed",
    "camelcase": "IsClosed"
  },
  {
    "snakecase": "rand",
    "camelcase": "Rand"
  },
  {
    "snakecase": "antisymm",
    "camelcase": "Antisymm"
  },
  {
    "snakecase": "homeomorph",
    "camelcase": "Homeomorph"
  },
  {
    "snakecase": "squash",
    "camelcase": "Squash"
  },
  {
    "snakecase": "union",
    "camelcase": "Union"
  },
  {
    "snakecase": "lists",
    "camelcase": "Lists"
  },
  {
    "snakecase": "is_trans",
    "camelcase": "IsTrans"
  },
  {
    "snakecase": "orthonormal_basis",
    "camelcase": "OrthonormalBasis"
  },
  {
    "snakecase": "arity",
    "camelcase": "Arity"
  },
  {
    "snakecase": "is_locally_constant",
    "camelcase": "IsLocallyConstant"
  },
  {
    "snakecase": "covariant",
    "camelcase": "Covariant"
  },
  {
    "snakecase": "complement",
    "camelcase": "Complement"
  },
  {
    "snakecase": "is_clopen",
    "camelcase": "IsClopen"
  },
  {
    "snakecase": "order_hom",
    "camelcase": "OrderHom"
  },
  {
    "snakecase": "add_hom",
    "camelcase": "AddHom"
  },
  {
    "snakecase": "subgroup",
    "camelcase": "Subgroup"
  },
  {
    "snakecase": "filter_basis",
    "camelcase": "FilterBasis"
  },
  {
    "snakecase": "orthonormal_basis_index",
    "camelcase": "OrthonormalBasisIndex"
  },
  {
    "snakecase": "upper_set",
    "camelcase": "UpperSet"
  },
  {
    "snakecase": "ordered_comm_group",
    "camelcase": "OrderedCommGroup"
  },
  {
    "snakecase": "commutative",
    "camelcase": "Commutative"
  },
  {
    "snakecase": "not",
    "camelcase": "Not"
  },
  {
    "snakecase": "cancel_comm_monoid",
    "camelcase": "CancelCommMonoid"
  },
  {
    "snakecase": "equiv",
    "camelcase": "Equiv"
  }
]