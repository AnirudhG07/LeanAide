{"typeGroup": "(∀ {M : Type u_1} [inst : AddZeroClass M] (c : AddCon M) (x : M) (x_1 : M),\n    ZeroHom.toFun { toFun := ((AddCon.toQuotient)), map_zero' := (((rfl=:↑0 = ↑0))) } (x + x_1) =\n      ZeroHom.toFun { toFun := ((AddCon.toQuotient)), map_zero' := (((rfl=:↑0 = ↑0))) } (x + x_1) :\n  Prop)", "type": "∀ {M : Type u_1} [inst : AddZeroClass M] (c : AddCon M) (x : M) (x_1 : M),\n  ZeroHom.toFun { toFun := ((AddCon.toQuotient)), map_zero' := ((rfl)) } (x + x_1) =\n    ZeroHom.toFun { toFun := ((AddCon.toQuotient)), map_zero' := ((rfl)) } (x + x_1)", "thm": " : ∀ {M : Type u_1} [inst : AddZeroClass M] (c : AddCon M) (x : M) (x_1 : M),\n  ZeroHom.toFun { toFun := ((AddCon.toQuotient)), map_zero' := ((rfl)) } (x + x_1) =\n    ZeroHom.toFun { toFun := ((AddCon.toQuotient)), map_zero' := ((rfl)) } (x + x_1)", "terms": [], "namedLemmas": ["∀ {α : Sort u} {a : α}, a = a"], "lemmas": [], "ids": ["rfl"], "idString": "rfl; ", "context": []}
{"typeGroup": "(∀ {n : ℕ} (l : (a : Fin (n + 1)) → ℝ) (u : (a : Fin (n + 1)) → ℝ) (h : ∀ (i : Fin (n + 1)), l i < u i)\n    (i : Fin (n + 1)),\n    BoxIntegral.Box.face { lower := ((l)), upper := ((u)), lower_lt_upper := ((h)) } i =\n      { lower := ((l ∘ Fin.succAbove i)), upper := ((u ∘ Fin.succAbove i)),\n        lower_lt_upper :=\n          (((fun (x : Fin n) ↦\n            (_ :\n              l (Fin.succAbove i x) <\n                u (Fin.succAbove i x))=:∀ (x : Fin n), l (Fin.succAbove i x) < u (Fin.succAbove i x)))) } :\n  Prop)", "type": "∀ {n : ℕ} (l : (a : Fin (n + 1)) → ℝ) (u : (a : Fin (n + 1)) → ℝ) (h : ∀ (i : Fin (n + 1)), l i < u i)\n  (i : Fin (n + 1)),\n  BoxIntegral.Box.face { lower := ((l)), upper := ((u)), lower_lt_upper := ((h)) } i =\n    BoxIntegral.Box.face { lower := ((l)), upper := ((u)), lower_lt_upper := ((h)) } i", "thm": " : ∀ {n : ℕ} (l : (a : Fin (n + 1)) → ℝ) (u : (a : Fin (n + 1)) → ℝ) (h : ∀ (i : Fin (n + 1)), l i < u i)\n  (i : Fin (n + 1)),\n  BoxIntegral.Box.face { lower := ((l)), upper := ((u)), lower_lt_upper := ((h)) } i =\n    BoxIntegral.Box.face { lower := ((l)), upper := ((u)), lower_lt_upper := ((h)) } i", "terms": [], "namedLemmas": ["∀ {α : Sort u} {a : α}, a = a"], "lemmas": [], "ids": ["rfl"], "idString": "rfl; ", "context": []}
{"typeGroup": "(∀ {C : Type u_1} [inst : CategoryTheory.Category C] {A : Cᵒᵖ} {B : Cᵒᵖ} {X : Cᵒᵖ} {Y : Cᵒᵖ} {f : A ⟶ X} {i : A ⟶ B}\n    {p : X ⟶ Y} {g : B ⟶ Y} (sq : CategoryTheory.CommSq f i p g),\n    (CategoryTheory.CommSq.HasLift sq : Prop) ↔\n      (CategoryTheory.CommSq.HasLift\n          (CategoryTheory.CommSq.unop sq=:CategoryTheory.CommSq g.unop p.unop i.unop f.unop) :\n        Prop) :\n  Prop)", "type": "∀ {C : Type u_1} [inst : CategoryTheory.Category C] {A : Cᵒᵖ} {B : Cᵒᵖ} {X : Cᵒᵖ} {Y : Cᵒᵖ} {f : A ⟶ X} {i : A ⟶ B}\n  {p : X ⟶ Y} {g : B ⟶ Y} (sq : CategoryTheory.CommSq f i p g),\n  (CategoryTheory.CommSq.HasLift sq) ↔ (CategoryTheory.CommSq.HasLift (CategoryTheory.CommSq.unop sq))", "thm": " : ∀ {C : Type u_1} [inst : CategoryTheory.Category C] {A : Cᵒᵖ} {B : Cᵒᵖ} {X : Cᵒᵖ} {Y : Cᵒᵖ} {f : A ⟶ X} {i : A ⟶ B}\n  {p : X ⟶ Y} {g : B ⟶ Y} (sq : CategoryTheory.CommSq f i p g),\n  (CategoryTheory.CommSq.HasLift sq) ↔ (CategoryTheory.CommSq.HasLift (CategoryTheory.CommSq.unop sq))", "terms": [{"value": "CategoryTheory.CommSq.LiftStruct sq", "isProp": false, "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "{A : Cᵒᵖ}", "{B : Cᵒᵖ}", "{X : Cᵒᵖ}", "{Y : Cᵒᵖ}", "{f : A ⟶ X}", "{i : A ⟶ B}", "{p : X ⟶ Y}", "{g : B ⟶ Y}", "(sq : CategoryTheory.CommSq f i p g)"]}, {"value": "CategoryTheory.CommSq.LiftStruct.unopEquiv sq", "isProp": false, "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "{A : Cᵒᵖ}", "{B : Cᵒᵖ}", "{X : Cᵒᵖ}", "{Y : Cᵒᵖ}", "{f : A ⟶ X}", "{i : A ⟶ B}", "{p : X ⟶ Y}", "{g : B ⟶ Y}", "(sq : CategoryTheory.CommSq f i p g)"]}, {"value": "Equiv.toFun (CategoryTheory.CommSq.LiftStruct.unopEquiv sq)", "isProp": false, "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "{A : Cᵒᵖ}", "{B : Cᵒᵖ}", "{X : Cᵒᵖ}", "{Y : Cᵒᵖ}", "{f : A ⟶ X}", "{i : A ⟶ B}", "{p : X ⟶ Y}", "{g : B ⟶ Y}", "(sq : CategoryTheory.CommSq f i p g)"]}, {"value": "Equiv.invFun (CategoryTheory.CommSq.LiftStruct.unopEquiv sq)", "isProp": false, "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "{A : Cᵒᵖ}", "{B : Cᵒᵖ}", "{X : Cᵒᵖ}", "{Y : Cᵒᵖ}", "{f : A ⟶ X}", "{i : A ⟶ B}", "{p : X ⟶ Y}", "{g : B ⟶ Y}", "(sq : CategoryTheory.CommSq f i p g)"]}], "namedLemmas": ["∀ {C : Type u_1} [inst : CategoryTheory.Category C] {A B X Y : C} {f : A ⟶ X} {i : A ⟶ B} {p : X ⟶ Y} {g : B ⟶ Y}\n  (sq : CategoryTheory.CommSq f i p g),\n  CategoryTheory.CommSq.HasLift sq ↔ Nonempty (CategoryTheory.CommSq.LiftStruct sq)", "∀ {C : Type u_1} [inst : CategoryTheory.Category C] {W X Y Z : Cᵒᵖ} {f : W ⟶ X} {g : W ⟶ Y} {h : X ⟶ Z} {i : Y ⟶ Z},\n  CategoryTheory.CommSq f g h i → CategoryTheory.CommSq i.unop h.unop g.unop f.unop", "∀ {C : Type u_1} [inst : CategoryTheory.Category C] {A B X Y : C} {f : A ⟶ X} {i : A ⟶ B} {p : X ⟶ Y} {g : B ⟶ Y}\n  (sq : CategoryTheory.CommSq f i p g),\n  CategoryTheory.CommSq.HasLift sq ↔ Nonempty (CategoryTheory.CommSq.LiftStruct sq)", "∀ {C : Type u_1} [inst : CategoryTheory.Category C] {W X Y Z : Cᵒᵖ} {f : W ⟶ X} {g : W ⟶ Y} {h : X ⟶ Z} {i : Y ⟶ Z},\n  CategoryTheory.CommSq f g h i → CategoryTheory.CommSq i.unop h.unop g.unop f.unop", "∀ {C : Type u_1} [inst : CategoryTheory.Category C] {W X Y Z : Cᵒᵖ} {f : W ⟶ X} {g : W ⟶ Y} {h : X ⟶ Z} {i : Y ⟶ Z},\n  CategoryTheory.CommSq f g h i → CategoryTheory.CommSq i.unop h.unop g.unop f.unop", "∀ {α : Sort u_1} {β : Sort u_2}, (α → β) → (β → α) → (Nonempty α ↔ Nonempty β)"], "lemmas": [{"prop": "(CategoryTheory.CommSq.HasLift sq) ↔ (Nonempty (CategoryTheory.CommSq.LiftStruct sq))", "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "{A : Cᵒᵖ}", "{B : Cᵒᵖ}", "{X : Cᵒᵖ}", "{Y : Cᵒᵖ}", "{f : A ⟶ X}", "{i : A ⟶ B}", "{p : X ⟶ Y}", "{g : B ⟶ Y}", "(sq : CategoryTheory.CommSq f i p g)"]}, {"prop": "(CategoryTheory.CommSq.HasLift sq) = (Nonempty (CategoryTheory.CommSq.LiftStruct sq))", "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "{A : Cᵒᵖ}", "{B : Cᵒᵖ}", "{X : Cᵒᵖ}", "{Y : Cᵒᵖ}", "{f : A ⟶ X}", "{i : A ⟶ B}", "{p : X ⟶ Y}", "{g : B ⟶ Y}", "(sq : CategoryTheory.CommSq f i p g)"]}, {"prop": "CategoryTheory.CommSq g.unop p.unop i.unop f.unop", "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "{A : Cᵒᵖ}", "{B : Cᵒᵖ}", "{X : Cᵒᵖ}", "{Y : Cᵒᵖ}", "{f : A ⟶ X}", "{i : A ⟶ B}", "{p : X ⟶ Y}", "{g : B ⟶ Y}", "(sq : CategoryTheory.CommSq f i p g)"]}, {"prop": "((CategoryTheory.CommSq.HasLift sq) ↔ (CategoryTheory.CommSq.HasLift (CategoryTheory.CommSq.unop sq))) =\n  ((CategoryTheory.CommSq.HasLift sq) ↔ (CategoryTheory.CommSq.HasLift (CategoryTheory.CommSq.unop sq)))", "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "{A : Cᵒᵖ}", "{B : Cᵒᵖ}", "{X : Cᵒᵖ}", "{Y : Cᵒᵖ}", "{f : A ⟶ X}", "{i : A ⟶ B}", "{p : X ⟶ Y}", "{g : B ⟶ Y}", "(sq : CategoryTheory.CommSq f i p g)"]}, {"prop": "((CategoryTheory.CommSq.HasLift sq) ↔ (CategoryTheory.CommSq.HasLift (CategoryTheory.CommSq.unop sq))) =\n  ((Nonempty (CategoryTheory.CommSq.LiftStruct sq)) ↔ (CategoryTheory.CommSq.HasLift (CategoryTheory.CommSq.unop sq)))", "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "{A : Cᵒᵖ}", "{B : Cᵒᵖ}", "{X : Cᵒᵖ}", "{Y : Cᵒᵖ}", "{f : A ⟶ X}", "{i : A ⟶ B}", "{p : X ⟶ Y}", "{g : B ⟶ Y}", "(sq : CategoryTheory.CommSq f i p g)"]}, {"prop": "((CategoryTheory.CommSq.HasLift sq) ↔ (CategoryTheory.CommSq.HasLift (CategoryTheory.CommSq.unop sq))) =\n  ((Nonempty (CategoryTheory.CommSq.LiftStruct sq)) ↔ (CategoryTheory.CommSq.HasLift (CategoryTheory.CommSq.unop sq)))", "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "{A : Cᵒᵖ}", "{B : Cᵒᵖ}", "{X : Cᵒᵖ}", "{Y : Cᵒᵖ}", "{f : A ⟶ X}", "{i : A ⟶ B}", "{p : X ⟶ Y}", "{g : B ⟶ Y}", "(sq : CategoryTheory.CommSq f i p g)"]}, {"prop": "CategoryTheory.CommSq g.unop p.unop i.unop f.unop", "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "{A : Cᵒᵖ}", "{B : Cᵒᵖ}", "{X : Cᵒᵖ}", "{Y : Cᵒᵖ}", "{f : A ⟶ X}", "{i : A ⟶ B}", "{p : X ⟶ Y}", "{g : B ⟶ Y}", "(sq : CategoryTheory.CommSq f i p g)"]}, {"prop": "(CategoryTheory.CommSq.HasLift (CategoryTheory.CommSq.unop sq)) ↔\n  (Nonempty (CategoryTheory.CommSq.LiftStruct (CategoryTheory.CommSq.unop sq)))", "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "{A : Cᵒᵖ}", "{B : Cᵒᵖ}", "{X : Cᵒᵖ}", "{Y : Cᵒᵖ}", "{f : A ⟶ X}", "{i : A ⟶ B}", "{p : X ⟶ Y}", "{g : B ⟶ Y}", "(sq : CategoryTheory.CommSq f i p g)"]}, {"prop": "(CategoryTheory.CommSq.HasLift (CategoryTheory.CommSq.unop sq)) =\n  (Nonempty (CategoryTheory.CommSq.LiftStruct (CategoryTheory.CommSq.unop sq)))", "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "{A : Cᵒᵖ}", "{B : Cᵒᵖ}", "{X : Cᵒᵖ}", "{Y : Cᵒᵖ}", "{f : A ⟶ X}", "{i : A ⟶ B}", "{p : X ⟶ Y}", "{g : B ⟶ Y}", "(sq : CategoryTheory.CommSq f i p g)"]}, {"prop": "CategoryTheory.CommSq g.unop p.unop i.unop f.unop", "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "{A : Cᵒᵖ}", "{B : Cᵒᵖ}", "{X : Cᵒᵖ}", "{Y : Cᵒᵖ}", "{f : A ⟶ X}", "{i : A ⟶ B}", "{p : X ⟶ Y}", "{g : B ⟶ Y}", "(sq : CategoryTheory.CommSq f i p g)"]}, {"prop": "((Nonempty (CategoryTheory.CommSq.LiftStruct sq)) ↔ (CategoryTheory.CommSq.HasLift (CategoryTheory.CommSq.unop sq))) =\n  ((Nonempty (CategoryTheory.CommSq.LiftStruct sq)) ↔ (CategoryTheory.CommSq.HasLift (CategoryTheory.CommSq.unop sq)))", "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "{A : Cᵒᵖ}", "{B : Cᵒᵖ}", "{X : Cᵒᵖ}", "{Y : Cᵒᵖ}", "{f : A ⟶ X}", "{i : A ⟶ B}", "{p : X ⟶ Y}", "{g : B ⟶ Y}", "(sq : CategoryTheory.CommSq f i p g)"]}, {"prop": "((Nonempty (CategoryTheory.CommSq.LiftStruct sq)) ↔ (CategoryTheory.CommSq.HasLift (CategoryTheory.CommSq.unop sq))) =\n  ((Nonempty (CategoryTheory.CommSq.LiftStruct sq)) ↔\n    (Nonempty (CategoryTheory.CommSq.LiftStruct (CategoryTheory.CommSq.unop sq))))", "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "{A : Cᵒᵖ}", "{B : Cᵒᵖ}", "{X : Cᵒᵖ}", "{Y : Cᵒᵖ}", "{f : A ⟶ X}", "{i : A ⟶ B}", "{p : X ⟶ Y}", "{g : B ⟶ Y}", "(sq : CategoryTheory.CommSq f i p g)"]}, {"prop": "((Nonempty (CategoryTheory.CommSq.LiftStruct sq)) ↔ (CategoryTheory.CommSq.HasLift (CategoryTheory.CommSq.unop sq))) =\n  ((Nonempty (CategoryTheory.CommSq.LiftStruct sq)) ↔\n    (Nonempty (CategoryTheory.CommSq.LiftStruct (CategoryTheory.CommSq.unop sq))))", "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "{A : Cᵒᵖ}", "{B : Cᵒᵖ}", "{X : Cᵒᵖ}", "{Y : Cᵒᵖ}", "{f : A ⟶ X}", "{i : A ⟶ B}", "{p : X ⟶ Y}", "{g : B ⟶ Y}", "(sq : CategoryTheory.CommSq f i p g)"]}, {"prop": "(Nonempty (CategoryTheory.CommSq.LiftStruct sq)) ↔\n  (Nonempty (CategoryTheory.CommSq.LiftStruct (CategoryTheory.CommSq.unop sq)))", "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "{A : Cᵒᵖ}", "{B : Cᵒᵖ}", "{X : Cᵒᵖ}", "{Y : Cᵒᵖ}", "{f : A ⟶ X}", "{i : A ⟶ B}", "{p : X ⟶ Y}", "{g : B ⟶ Y}", "(sq : CategoryTheory.CommSq f i p g)"]}, {"prop": "(Nonempty (CategoryTheory.CommSq.LiftStruct sq)) ↔ (CategoryTheory.CommSq.HasLift (CategoryTheory.CommSq.unop sq))", "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "{A : Cᵒᵖ}", "{B : Cᵒᵖ}", "{X : Cᵒᵖ}", "{Y : Cᵒᵖ}", "{f : A ⟶ X}", "{i : A ⟶ B}", "{p : X ⟶ Y}", "{g : B ⟶ Y}", "(sq : CategoryTheory.CommSq f i p g)"]}], "ids": ["Eq.mpr", "id", "propext", "CategoryTheory.CommSq.HasLift.iff", "Eq.refl", "CategoryTheory.CommSq.HasLift", "CategoryTheory.CommSq.HasLift", "CategoryTheory.CommSq.unop", "Eq.mpr", "id", "propext", "CategoryTheory.CommSq.HasLift.iff", "CategoryTheory.CommSq.unop", "Eq.refl", "Nonempty", "CategoryTheory.CommSq.LiftStruct", "CategoryTheory.CommSq.HasLift", "CategoryTheory.CommSq.unop", "Nonempty.congr", "Equiv.toFun", "CategoryTheory.CommSq.LiftStruct.unopEquiv", "Equiv.invFun", "CategoryTheory.CommSq.LiftStruct.unopEquiv"], "idString": "Eq.mpr; id; propext; CategoryTheory.CommSq.HasLift.iff; Eq.refl; CategoryTheory.CommSq.HasLift; CategoryTheory.CommSq.HasLift; CategoryTheory.CommSq.unop; Eq.mpr; id; propext; CategoryTheory.CommSq.HasLift.iff; CategoryTheory.CommSq.unop; Eq.refl; Nonempty; CategoryTheory.CommSq.LiftStruct; CategoryTheory.CommSq.HasLift; CategoryTheory.CommSq.unop; Nonempty.congr; Equiv.toFun; CategoryTheory.CommSq.LiftStruct.unopEquiv; Equiv.invFun; CategoryTheory.CommSq.LiftStruct.unopEquiv; ", "context": []}
{"typeGroup": "(∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (S : Set G) (hS1 : Set.Nonempty S) (hS2 : S * S = S) {a : G}\n    (ha :\n      a ∈\n        Subsemigroup.carrier\n          (Submonoid.toSubsemigroup\n            {\n              toSubsemigroup :=\n                (({ carrier := ((S)),\n                  mul_mem' :=\n                    (((fun {a : G} ↦\n                      (_ :\n                        ∀ {b : G}\n                          (a_1 : a ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2)))\n                          (a_2 : b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))),\n                          a * b ∈\n                            Subsemigroup.carrier\n                              (Submonoid.toSubsemigroup\n                                (submonoidOfIdempotent S hS1\n                                  hS2)))=:∀ {a : G} {b : G}\n                        (a_1 : a ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2)))\n                        (a_2 : b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))),\n                        a * b ∈\n                          Subsemigroup.carrier (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n              one_mem' :=\n                (((Submonoid.one_mem'\n                    (submonoidOfIdempotent S hS1\n                      hS2)=:1 ∈\n                    Subsemigroup.carrier (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n    a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2 :\n  Prop)", "type": "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (S : Set G) (hS1 : Set.Nonempty S) (hS2 : S * S = S) {a : G}\n  (ha :\n    a ∈\n      Subsemigroup.carrier\n        (Submonoid.toSubsemigroup\n          {\n            toSubsemigroup :=\n              (({ carrier := ((S)),\n                mul_mem' :=\n                  (((fun {a : G} {b : G} ↦\n                    Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n            one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) })),\n  a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2", "thm": " : ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (S : Set G) (hS1 : Set.Nonempty S) (hS2 : S * S = S) {a : G}\n  (ha :\n    a ∈\n      Subsemigroup.carrier\n        (Submonoid.toSubsemigroup\n          {\n            toSubsemigroup :=\n              (({ carrier := ((S)),\n                mul_mem' :=\n                  (((fun {a : G} {b : G} ↦\n                    Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n            one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) })),\n  a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2", "terms": [{"value": "a⁻¹", "isProp": false, "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"value": "orderOf a - 1", "isProp": false, "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}], "namedLemmas": ["∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {M : Type u} [inst : MulOneClass M] (a : M), 1 * a = a", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 1 = a", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {G : Type u_1} [inst : Monoid G] (x : G), x ^ orderOf x = 1", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {G : Type w} [inst : Group G] (a : G) {m n : ℕ}, n ≤ m → a ^ (m - n) = a ^ m * (a ^ n)⁻¹", "∀ {G : Type u_1} [inst : LeftCancelMonoid G] [inst_1 : Finite G] (x : G), 0 < orderOf x", "∀ {M : Type u_1} {A : Type u_2} [inst : Monoid M] [inst_1 : SetLike A M] [inst_2 : SubmonoidClass A M] {S : A} {x : M},\n  x ∈ S → ∀ (n : ℕ), x ^ n ∈ S"], "lemmas": [{"prop": "1 * a⁻¹ = a⁻¹", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a⁻¹ = 1 * a⁻¹", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a ^ 1 = a", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a = a ^ 1", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a ^ orderOf a = 1", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "1 = a ^ orderOf a", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "0 < orderOf a", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a ^ (orderOf a - Nat.succ 0) = a ^ orderOf a * (a ^ Nat.succ 0)⁻¹", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a ^ orderOf a * (a ^ Nat.succ 0)⁻¹ = a ^ (orderOf a - Nat.succ 0)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) =\n  (a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) =\n  (a ^ (orderOf a - Nat.succ 0) ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) =\n  (a ^ (orderOf a - Nat.succ 0) ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a ^ (orderOf a - 1) ∈ submonoidOfIdempotent S hS1 hS2", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}], "ids": ["Eq.mpr", "id", "Eq.symm", "one_mul", "Eq.refl", "submonoidOfIdempotent", "Eq.mpr", "id", "Eq.symm", "pow_one", "Eq.refl", "submonoidOfIdempotent", "Eq.mpr", "id", "Eq.symm", "pow_orderOf_eq_one", "Eq.refl", "submonoidOfIdempotent", "Eq.mpr", "id", "Eq.symm", "pow_sub", "orderOf_pos", "Eq.refl", "orderOf", "submonoidOfIdempotent", "pow_mem", "orderOf"], "idString": "Eq.mpr; id; Eq.symm; one_mul; Eq.refl; submonoidOfIdempotent; Eq.mpr; id; Eq.symm; pow_one; Eq.refl; submonoidOfIdempotent; Eq.mpr; id; Eq.symm; pow_orderOf_eq_one; Eq.refl; submonoidOfIdempotent; Eq.mpr; id; Eq.symm; pow_sub; orderOf_pos; Eq.refl; orderOf; submonoidOfIdempotent; pow_mem; orderOf; ", "context": []}
{"typeGroup": "(∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (S : Set G) (hS1 : Set.Nonempty S) (hS2 : S * S = S) {a : G}\n    (ha :\n      a ∈\n        Subsemigroup.carrier\n          (Submonoid.toSubsemigroup\n            {\n              toSubsemigroup :=\n                (({ carrier := ((S)),\n                  mul_mem' :=\n                    (((fun {a : G} ↦\n                      (_ :\n                        ∀ {b : G}\n                          (a_1 : a ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2)))\n                          (a_2 : b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))),\n                          a * b ∈\n                            Subsemigroup.carrier\n                              (Submonoid.toSubsemigroup\n                                (submonoidOfIdempotent S hS1\n                                  hS2)))=:∀ {a : G} {b : G}\n                        (a_1 : a ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2)))\n                        (a_2 : b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))),\n                        a * b ∈\n                          Subsemigroup.carrier (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n              one_mem' :=\n                (((Submonoid.one_mem'\n                    (submonoidOfIdempotent S hS1\n                      hS2)=:1 ∈\n                    Subsemigroup.carrier (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n    a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2 :\n  Prop)", "type": "a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2", "thm": "{G : Type u_1} [Group G] [Fintype G] (S : Set G) (hS1 : Set.Nonempty S) (hS2 : S * S = S) {a : G} (ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))  : a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2", "terms": [{"value": "a⁻¹", "isProp": false, "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"value": "orderOf a - 1", "isProp": false, "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}], "namedLemmas": ["∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {M : Type u} [inst : MulOneClass M] (a : M), 1 * a = a", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 1 = a", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {G : Type u_1} [inst : Monoid G] (x : G), x ^ orderOf x = 1", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {G : Type w} [inst : Group G] (a : G) {m n : ℕ}, n ≤ m → a ^ (m - n) = a ^ m * (a ^ n)⁻¹", "∀ {G : Type u_1} [inst : LeftCancelMonoid G] [inst_1 : Finite G] (x : G), 0 < orderOf x", "∀ {M : Type u_1} {A : Type u_2} [inst : Monoid M] [inst_1 : SetLike A M] [inst_2 : SubmonoidClass A M] {S : A} {x : M},\n  x ∈ S → ∀ (n : ℕ), x ^ n ∈ S"], "lemmas": [{"prop": "1 * a⁻¹ = a⁻¹", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a⁻¹ = 1 * a⁻¹", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a ^ 1 = a", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a = a ^ 1", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a ^ orderOf a = 1", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "1 = a ^ orderOf a", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "0 < orderOf a", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a ^ (orderOf a - Nat.succ 0) = a ^ orderOf a * (a ^ Nat.succ 0)⁻¹", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a ^ orderOf a * (a ^ Nat.succ 0)⁻¹ = a ^ (orderOf a - Nat.succ 0)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) =\n  (a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) =\n  (a ^ (orderOf a - Nat.succ 0) ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) =\n  (a ^ (orderOf a - Nat.succ 0) ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a ^ (orderOf a - 1) ∈ submonoidOfIdempotent S hS1 hS2", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}], "ids": ["Eq.mpr", "id", "Eq.symm", "one_mul", "Eq.refl", "submonoidOfIdempotent", "Eq.mpr", "id", "Eq.symm", "pow_one", "Eq.refl", "submonoidOfIdempotent", "Eq.mpr", "id", "Eq.symm", "pow_orderOf_eq_one", "Eq.refl", "submonoidOfIdempotent", "Eq.mpr", "id", "Eq.symm", "pow_sub", "orderOf_pos", "Eq.refl", "orderOf", "submonoidOfIdempotent", "pow_mem", "orderOf"], "idString": "Eq.mpr; id; Eq.symm; one_mul; Eq.refl; submonoidOfIdempotent; Eq.mpr; id; Eq.symm; pow_one; Eq.refl; submonoidOfIdempotent; Eq.mpr; id; Eq.symm; pow_orderOf_eq_one; Eq.refl; submonoidOfIdempotent; Eq.mpr; id; Eq.symm; pow_sub; orderOf_pos; Eq.refl; orderOf; submonoidOfIdempotent; pow_mem; orderOf; ", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}
{"typeGroup": "(∀ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X : Cᵒᵖ}\n    {Y : Cᵒᵖ} (f : X ⟶ Y) (m : CategoryTheory.NormalMono f.unop) {Z' : Cᵒᵖ} (g' : X ⟶ Z')\n    (w' : CategoryTheory.CategoryStruct.comp CategoryTheory.NormalMono.g.op g' = 0),\n    (CategoryTheory.CategoryStruct.comp\n          ((fun {Z' : Cᵒᵖ} (g' : X ⟶ Z')\n                  (w' : CategoryTheory.CategoryStruct.comp CategoryTheory.NormalMono.g.op g' = 0) ↦\n                (↑(CategoryTheory.Limits.KernelFork.IsLimit.lift' CategoryTheory.NormalMono.isLimit g'.unop\n                      (congrArg Quiver.Hom.unop\n                          w'=:{\n                              unop :=\n                                ((CategoryTheory.CategoryStruct.comp g'.unop CategoryTheory.NormalMono.g)) }.unop =\n                          { unop := ((0)) }.unop))).op)\n              g' w').unop\n          f.unop).op =\n      (Opposite.unop g').op :\n  Prop)", "type": "∀ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X : Cᵒᵖ}\n  {Y : Cᵒᵖ} (f : X ⟶ Y) (m : CategoryTheory.NormalMono f.unop) {Z' : Cᵒᵖ} (g' : X ⟶ Z')\n  (w' : CategoryTheory.CategoryStruct.comp CategoryTheory.NormalMono.g.op g' = 0),\n  (CategoryTheory.CategoryStruct.comp\n        ((fun {Z' : Cᵒᵖ} (g' : X ⟶ Z') (w' : CategoryTheory.CategoryStruct.comp CategoryTheory.NormalMono.g.op g' = 0) ↦\n              (↑(CategoryTheory.Limits.KernelFork.IsLimit.lift' CategoryTheory.NormalMono.isLimit g'.unop\n                    (congrArg Quiver.Hom.unop w'))).op)\n            g' w').unop\n        f.unop).op =\n    (Opposite.unop g').op", "thm": " : ∀ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X : Cᵒᵖ}\n  {Y : Cᵒᵖ} (f : X ⟶ Y) (m : CategoryTheory.NormalMono f.unop) {Z' : Cᵒᵖ} (g' : X ⟶ Z')\n  (w' : CategoryTheory.CategoryStruct.comp CategoryTheory.NormalMono.g.op g' = 0),\n  (CategoryTheory.CategoryStruct.comp\n        ((fun {Z' : Cᵒᵖ} (g' : X ⟶ Z') (w' : CategoryTheory.CategoryStruct.comp CategoryTheory.NormalMono.g.op g' = 0) ↦\n              (↑(CategoryTheory.Limits.KernelFork.IsLimit.lift' CategoryTheory.NormalMono.isLimit g'.unop\n                    (congrArg Quiver.Hom.unop w'))).op)\n            g' w').unop\n        f.unop).op =\n    (Opposite.unop g').op", "terms": [{"value": "g'.unop", "isProp": false, "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "[CategoryTheory.Limits.HasZeroMorphisms C]", "{X : Cᵒᵖ}", "{Y : Cᵒᵖ}", "(f : X ⟶ Y)", "(m : CategoryTheory.NormalMono f.unop)", "{Z' : Cᵒᵖ}", "(g' : X ⟶ Z')", "(w' : CategoryTheory.CategoryStruct.comp CategoryTheory.NormalMono.g.op g' = 0)"]}, {"value": "CategoryTheory.Limits.KernelFork.IsLimit.lift' CategoryTheory.NormalMono.isLimit g'.unop (congrArg Quiver.Hom.unop w')", "isProp": false, "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "[CategoryTheory.Limits.HasZeroMorphisms C]", "{X : Cᵒᵖ}", "{Y : Cᵒᵖ}", "(f : X ⟶ Y)", "(m : CategoryTheory.NormalMono f.unop)", "{Z' : Cᵒᵖ}", "(g' : X ⟶ Z')", "(w' : CategoryTheory.CategoryStruct.comp CategoryTheory.NormalMono.g.op g' = 0)"]}], "namedLemmas": ["∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂"], "lemmas": [{"prop": "{ unop := ((CategoryTheory.CategoryStruct.comp g'.unop CategoryTheory.NormalMono.g)) }.unop = { unop := ((0)) }.unop", "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "[CategoryTheory.Limits.HasZeroMorphisms C]", "{X : Cᵒᵖ}", "{Y : Cᵒᵖ}", "(f : X ⟶ Y)", "(m : CategoryTheory.NormalMono f.unop)", "{Z' : Cᵒᵖ}", "(g' : X ⟶ Z')", "(w' : CategoryTheory.CategoryStruct.comp CategoryTheory.NormalMono.g.op g' = 0)"]}, {"prop": "CategoryTheory.CategoryStruct.comp\n    (↑(CategoryTheory.Limits.KernelFork.IsLimit.lift' CategoryTheory.NormalMono.isLimit g'.unop\n        (congrArg Quiver.Hom.unop w')))\n    (CategoryTheory.Limits.Fork.ι (CategoryTheory.Limits.KernelFork.ofι f.unop CategoryTheory.NormalMono.w)) =\n  g'.unop", "context": ["{C : Type u_1}", "[CategoryTheory.Category C]", "[CategoryTheory.Limits.HasZeroMorphisms C]", "{X : Cᵒᵖ}", "{Y : Cᵒᵖ}", "(f : X ⟶ Y)", "(m : CategoryTheory.NormalMono f.unop)", "{Z' : Cᵒᵖ}", "(g' : X ⟶ Z')", "(w' : CategoryTheory.CategoryStruct.comp CategoryTheory.NormalMono.g.op g' = 0)"]}], "ids": ["congrArg", "Quiver.Hom.op", "Subtype.property", "CategoryTheory.Limits.KernelFork.IsLimit.lift'", "CategoryTheory.NormalMono.isLimit", "unop", "congrArg", "Quiver.Hom.unop"], "idString": "congrArg; Quiver.Hom.op; Subtype.property; CategoryTheory.Limits.KernelFork.IsLimit.lift'; CategoryTheory.NormalMono.isLimit; unop; congrArg; Quiver.Hom.unop; ", "context": []}
{"typeGroup": "(∀ {n : Type u_1} {R : Type u_3} {α : Type u_2} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommSemiring R]\n    [inst_3 : Semiring α] [inst_4 : Algebra R α] (r : R) (x : Matrix n n α),\n    r • x =\n      ↑{ toMonoidHom := ((↑(RingHom.comp (Matrix.scalar n) (algebraMap R α)))),\n              map_zero' :=\n                (((RingHom.map_zero'\n                    (RingHom.comp (Matrix.scalar n)\n                      (algebraMap R α))=:OneHom.toFun (↑↑(RingHom.comp (Matrix.scalar n) (algebraMap R α))) 0 = 0))),\n              map_add' :=\n                (((RingHom.map_add'\n                    (RingHom.comp (Matrix.scalar n)\n                      (algebraMap R\n                        α))=:∀ (x : R) (y : R),\n                    OneHom.toFun (↑↑(RingHom.comp (Matrix.scalar n) (algebraMap R α))) (x + y) =\n                      OneHom.toFun (↑↑(RingHom.comp (Matrix.scalar n) (algebraMap R α))) x +\n                        OneHom.toFun (↑↑(RingHom.comp (Matrix.scalar n) (algebraMap R α))) y))) }\n          r *\n        x :\n  Prop)", "type": "∀ {n : Type u_1} {R : Type u_3} {α : Type u_2} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommSemiring R]\n  [inst_3 : Semiring α] [inst_4 : Algebra R α] (r : R) (x : Matrix n n α),\n  r • x =\n    ↑{ toMonoidHom := ((↑(RingHom.comp (Matrix.scalar n) (algebraMap R α)))),\n            map_zero' := (((RingHom.map_zero' (RingHom.comp (Matrix.scalar n) (algebraMap R α))))),\n            map_add' := (((RingHom.map_add' (RingHom.comp (Matrix.scalar n) (algebraMap R α))))) }\n        r *\n      x", "thm": " : ∀ {n : Type u_1} {R : Type u_3} {α : Type u_2} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommSemiring R]\n  [inst_3 : Semiring α] [inst_4 : Algebra R α] (r : R) (x : Matrix n n α),\n  r • x =\n    ↑{ toMonoidHom := ((↑(RingHom.comp (Matrix.scalar n) (algebraMap R α)))),\n            map_zero' := (((RingHom.map_zero' (RingHom.comp (Matrix.scalar n) (algebraMap R α))))),\n            map_add' := (((RingHom.map_add' (RingHom.comp (Matrix.scalar n) (algebraMap R α))))) }\n        r *\n      x", "terms": [{"value": "x i x_1", "isProp": false, "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"value": "↑(algebraMap R α) r * x i x_1", "isProp": false, "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}], "namedLemmas": ["∀ {m : Type u_2} {n : Type u_1} {α : Type v} {M N : Matrix m n α}, (∀ (i : m), M i = N i) → M = N", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g", "∀ {p : Prop}, p = True → p", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (r : R) (x : A),\n  r • x = ↑(algebraMap R A) r * x", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {R : Type u_3} [inst : CommSemiring R] (A : Type u_2) [inst_1 : Semiring A] [inst_2 : Algebra R A] {M : Type u_1}\n  [inst_3 : AddCommMonoid M] [inst_4 : Module A M] [inst_5 : Module R M] [inst_6 : IsScalarTower R A M] (r : R) (m : M),\n  ↑(algebraMap R A) r • m = r • m", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {M : Type u_1} {N : Type u_2} [inst : MulOneClass N] [inst_1 : SMul M N] [inst_2 : IsScalarTower M N N] (x : M)\n  (y : N), x • 1 * y = x • y", "∀ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (r : R) (x : A),\n  r • x = ↑(algebraMap R A) r * x", "∀ {α : Sort u_1} (a : α), (a = a) = True"], "lemmas": [{"prop": "∀ (x_0 : Type u_2) (x_1 : Semiring x_0) (x_2 : Algebra R x_0) (x : x_0), r • x = ↑(algebraMap R x_0) r * x", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)", "(x_0 : Type u_2)", "(x_1 : Semiring x_0)", "(x_2 : Algebra R x_0)", "(x : x_0)"]}, {"prop": "∀ (x_0 : Type u_2) (x_1 : Semiring x_0) (x_2 : Algebra R x_0) (x : x_0), r • x = ↑(algebraMap R x_0) r * x", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "r • x i x_1 = ↑(algebraMap R α) r * x i x_1", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "Eq (r • x i x_1) = Eq (↑(algebraMap R α) r * x i x_1)", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "↑(algebraMap R α) r • 1 = r • 1", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "HMul.hMul (↑(algebraMap R α) r • 1) = HMul.hMul (r • 1)", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "↑(algebraMap R α) r • 1 * x = r • 1 * x", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "(↑(algebraMap R α) r • 1 * x) i = (r • 1 * x) i", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "(↑(algebraMap R α) r • 1 * x) i x_1 = (r • 1 * x) i x_1", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "r • 1 * x = r • x", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "(r • 1 * x) i = (r • x) i", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "(r • 1 * x) i x_1 = (r • x) i x_1", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "(↑(algebraMap R α) r • 1 * x) i x_1 = (r • x) i x_1", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "∀ (x_0 : Type u_2) (x_1 : Semiring x_0) (x_2 : Algebra R x_0) (x : x_0), r • x = ↑(algebraMap R x_0) r * x", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)", "(x_0 : Type u_2)", "(x_1 : Semiring x_0)", "(x_2 : Algebra R x_0)", "(x : x_0)"]}, {"prop": "∀ (x_0 : Type u_2) (x_1 : Semiring x_0) (x_2 : Algebra R x_0) (x : x_0), r • x = ↑(algebraMap R x_0) r * x", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "r • x i x_1 = ↑(algebraMap R α) r * x i x_1", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "(↑(algebraMap R α) r • 1 * x) i x_1 = ↑(algebraMap R α) r * x i x_1", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "(r • x i x_1 = (↑(algebraMap R α) r • 1 * x) i x_1) = (↑(algebraMap R α) r * x i x_1 = ↑(algebraMap R α) r * x i x_1)", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "(↑(algebraMap R α) r * x i x_1 = ↑(algebraMap R α) r * x i x_1) = True", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "(r • x i x_1 = (↑(algebraMap R α) r • 1 * x) i x_1) = True", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "∀ (x_1 : n), r • x i x_1 = (↑(algebraMap R α) r • 1 * x) i x_1", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)"]}, {"prop": "∀ (i : n),\n  (r • x) i =\n    (↑{ toMonoidHom := ((↑(RingHom.comp (Matrix.scalar n) (algebraMap R α)))),\n              map_zero' := (((RingHom.map_zero' (RingHom.comp (Matrix.scalar n) (algebraMap R α))))),\n              map_add' := (((RingHom.map_add' (RingHom.comp (Matrix.scalar n) (algebraMap R α))))) }\n          r *\n        x)\n      i", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)"]}], "ids": ["Matrix.ext'", "funext", "of_eq_true", "Eq.trans", "congr", "congrArg", "Eq", "Algebra.smul_def", "inst_3", "inst_4", "Eq.trans", "Eq.trans", "congrFun", "congrFun", "congrFun", "congrArg", "HMul.hMul", "algebraMap_smul", "congrFun", "congrFun", "smul_one_mul", "Algebra.smul_def", "inst_3", "inst_4", "eq_self", "algebraMap"], "idString": "Matrix.ext'; funext; of_eq_true; Eq.trans; congr; congrArg; Eq; Algebra.smul_def; inst_3; inst_4; Eq.trans; Eq.trans; congrFun; congrFun; congrFun; congrArg; HMul.hMul; algebraMap_smul; congrFun; congrFun; smul_one_mul; Algebra.smul_def; inst_3; inst_4; eq_self; algebraMap; ", "context": []}
{"typeGroup": "(∀ {R : Type u_3} {M : Type u_1} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S : Type u_2)\n    [inst_3 : Ring S] [inst_4 : SMul S R] [inst_5 : Module S M] [inst_6 : IsScalarTower S R M] (P : Submodule R M),\n    Function.RightInverse\n      (Equiv.invFun\n        (Quotient.congrRight\n          (Submodule.Quotient.restrictScalarsEquiv.proof_1 S\n              P=:∀ (x : M) (x_1 : M), (Setoid.r x x_1 : Prop) ↔ (Setoid.r x x_1 : Prop))))\n      (Equiv.toFun\n        (Quotient.congrRight\n          (Submodule.Quotient.restrictScalarsEquiv.proof_1 S\n              P=:∀ (x : M) (x_1 : M), (Setoid.r x x_1 : Prop) ↔ (Setoid.r x x_1 : Prop)))) :\n  Prop)", "type": "∀ {R : Type u_3} {M : Type u_1} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S : Type u_2)\n  [inst_3 : Ring S] [inst_4 : SMul S R] [inst_5 : Module S M] [inst_6 : IsScalarTower S R M] (P : Submodule R M),\n  Function.RightInverse (Equiv.invFun (Quotient.congrRight (Submodule.Quotient.restrictScalarsEquiv.proof_1 S P)))\n    (Equiv.toFun (Quotient.congrRight (Submodule.Quotient.restrictScalarsEquiv.proof_1 S P)))", "thm": " : ∀ {R : Type u_3} {M : Type u_1} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S : Type u_2)\n  [inst_3 : Ring S] [inst_4 : SMul S R] [inst_5 : Module S M] [inst_6 : IsScalarTower S R M] (P : Submodule R M),\n  Function.RightInverse (Equiv.invFun (Quotient.congrRight (Submodule.Quotient.restrictScalarsEquiv.proof_1 S P)))\n    (Equiv.toFun (Quotient.congrRight (Submodule.Quotient.restrictScalarsEquiv.proof_1 S P)))", "terms": [{"value": "Quotient.congrRight (Submodule.Quotient.restrictScalarsEquiv.proof_1 S P)", "isProp": false, "context": ["{R : Type u_3}", "{M : Type u_1}", "[Ring R]", "[AddCommGroup M]", "[Module R M]", "(S : Type u_2)", "[Ring S]", "[SMul S R]", "[Module S M]", "[IsScalarTower S R M]", "(P : Submodule R M)"]}], "namedLemmas": ["∀ {α : Sort u_1} {β : Sort u_2} (self : α ≃ β), Function.RightInverse self.invFun self.toFun", "∀ {R : Type u_3} {M : Type u_1} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S : Type u_2)\n  [inst_3 : Ring S] [inst_4 : SMul S R] [inst_5 : Module S M] [inst_6 : IsScalarTower S R M] (P : Submodule R M)\n  (x x_1 : M), Setoid.r x x_1 ↔ Setoid.r x x_1"], "lemmas": [{"prop": "∀ (x : M) (x_1 : M), (Setoid.r x x_1) ↔ (Setoid.r x x_1)", "context": ["{R : Type u_3}", "{M : Type u_1}", "[Ring R]", "[AddCommGroup M]", "[Module R M]", "(S : Type u_2)", "[Ring S]", "[SMul S R]", "[Module S M]", "[IsScalarTower S R M]", "(P : Submodule R M)"]}], "ids": ["Equiv.right_inv", "Quotient.congrRight", "Submodule.Quotient.restrictScalarsEquiv.proof_1"], "idString": "Equiv.right_inv; Quotient.congrRight; Submodule.Quotient.restrictScalarsEquiv.proof_1; ", "context": []}
{"typeGroup": "(∀ {α : Type u_1} [inst : LinearOrderedCancelAddCommMonoid α] {s : Set α} {t : Set α} (hs : Set.IsWf s)\n    (ht : Set.IsWf t) (hns : Set.Nonempty s) (hnt : Set.Nonempty t),\n    Finset.addAntidiagonal (Set.IsWf.isPwo hs=:Set.IsPwo s) (Set.IsWf.isPwo ht=:Set.IsPwo t)\n        (Set.IsWf.min hs hns + Set.IsWf.min ht hnt) =\n      {(Set.IsWf.min hs hns, Set.IsWf.min ht hnt)} :\n  Prop)", "type": "∀ {α : Type u_1} [inst : LinearOrderedCancelAddCommMonoid α] {s : Set α} {t : Set α} (hs : Set.IsWf s) (ht : Set.IsWf t)\n  (hns : Set.Nonempty s) (hnt : Set.Nonempty t),\n  Finset.addAntidiagonal (Set.IsWf.isPwo hs) (Set.IsWf.isPwo ht) (Set.IsWf.min hs hns + Set.IsWf.min ht hnt) =\n    {(Set.IsWf.min hs hns, Set.IsWf.min ht hnt)}", "thm": " : ∀ {α : Type u_1} [inst : LinearOrderedCancelAddCommMonoid α] {s : Set α} {t : Set α} (hs : Set.IsWf s) (ht : Set.IsWf t)\n  (hns : Set.Nonempty s) (hnt : Set.Nonempty t),\n  Finset.addAntidiagonal (Set.IsWf.isPwo hs) (Set.IsWf.isPwo ht) (Set.IsWf.min hs hns + Set.IsWf.min ht hnt) =\n    {(Set.IsWf.min hs hns, Set.IsWf.min ht hnt)}", "terms": [], "namedLemmas": ["∀ {α : Type u_1} {s₁ s₂ : Finset α}, (∀ (a : α), a ∈ s₁ ↔ a ∈ s₂) → s₁ = s₂", "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {a : α}, a = a", "∀ {G : Type u_1} [inst : Add G] [inst_1 : IsLeftCancelAdd G] {a b c : G}, a + b = a + c → b = c", "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → ¬a < b → a = b", "∀ {α : Type u_1} [inst : LinearOrder α] {s : Set α} {a : α} (hs : Set.IsWf s) (hn : Set.Nonempty s),\n  a ∈ s → Set.IsWf.min hs hn ≤ a", "∀ {α : Type u} [inst : Preorder α] {x y : α}, x < y → y ≠ x", "∀ {α : Type u_1} [inst : Add α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]\n  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c d : α},\n  a < b → c ≤ d → a + c < b + d", "∀ {α : Type u_1} [inst : LinearOrder α] {s : Set α} {a : α} (hs : Set.IsWf s) (hn : Set.Nonempty s),\n  a ∈ s → Set.IsWf.min hs hn ≤ a", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {α : Type u_1} [inst : Preorder α] {s : Set α} (hs : Set.IsWf s) (hn : Set.Nonempty s), Set.IsWf.min hs hn ∈ s", "∀ {α : Type u_1} [inst : Preorder α] {s : Set α} (hs : Set.IsWf s) (hn : Set.Nonempty s), Set.IsWf.min hs hn ∈ s", "∀ {α : Sort u} {a : α}, a = a"], "lemmas": [{"prop": "((a, b) ∈ Finset.addAntidiagonal (Set.IsWf.isPwo hs) (Set.IsWf.isPwo ht) (Set.IsWf.min hs hns + Set.IsWf.min ht hnt)) =\n  ((Prod.fst (a, b) ∈ s) ∧\n    ((Prod.snd (a, b) ∈ t) ∧ (Prod.fst (a, b) + Prod.snd (a, b) = Set.IsWf.min hs hns + Set.IsWf.min ht hnt)))", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)"]}, {"prop": "Iff\n    ((a, b) ∈\n      Finset.addAntidiagonal (Set.IsWf.isPwo hs) (Set.IsWf.isPwo ht) (Set.IsWf.min hs hns + Set.IsWf.min ht hnt)) =\n  Iff\n    ((Prod.fst (a, b) ∈ s) ∧\n      ((Prod.snd (a, b) ∈ t) ∧ (Prod.fst (a, b) + Prod.snd (a, b) = Set.IsWf.min hs hns + Set.IsWf.min ht hnt)))", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)"]}, {"prop": "((a, b) ∈ {(Set.IsWf.min hs hns, Set.IsWf.min ht hnt)}) = ((a, b) = (Set.IsWf.min hs hns, Set.IsWf.min ht hnt))", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)"]}, {"prop": "((a, b) = (Set.IsWf.min hs hns, Set.IsWf.min ht hnt)) =\n  ((Prod.fst (a, b) = Prod.fst (Set.IsWf.min hs hns, Set.IsWf.min ht hnt)) ∧\n    (Prod.snd (a, b) = Prod.snd (Set.IsWf.min hs hns, Set.IsWf.min ht hnt)))", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)"]}, {"prop": "((a, b) ∈ {(Set.IsWf.min hs hns, Set.IsWf.min ht hnt)}) =\n  ((Prod.fst (a, b) = Prod.fst (Set.IsWf.min hs hns, Set.IsWf.min ht hnt)) ∧\n    (Prod.snd (a, b) = Prod.snd (Set.IsWf.min hs hns, Set.IsWf.min ht hnt)))", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)"]}, {"prop": "(((a, b) ∈ Finset.addAntidiagonal (Set.IsWf.isPwo hs) (Set.IsWf.isPwo ht) (Set.IsWf.min hs hns + Set.IsWf.min ht hnt)) ↔\n    ((a, b) ∈ {(Set.IsWf.min hs hns, Set.IsWf.min ht hnt)})) =\n  (((Prod.fst (a, b) ∈ s) ∧\n      ((Prod.snd (a, b) ∈ t) ∧ (Prod.fst (a, b) + Prod.snd (a, b) = Set.IsWf.min hs hns + Set.IsWf.min ht hnt))) ↔\n    ((Prod.fst (a, b) = Prod.fst (Set.IsWf.min hs hns, Set.IsWf.min ht hnt)) ∧\n      (Prod.snd (a, b) = Prod.snd (Set.IsWf.min hs hns, Set.IsWf.min ht hnt))))", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)"]}, {"prop": "(((a, b) ∈ Finset.addAntidiagonal (Set.IsWf.isPwo hs) (Set.IsWf.isPwo ht) (Set.IsWf.min hs hns + Set.IsWf.min ht hnt)) ↔\n    ((a, b) ∈ {(Set.IsWf.min hs hns, Set.IsWf.min ht hnt)})) =\n  (((a ∈ s) ∧ ((b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt))) ↔\n    ((a = Set.IsWf.min hs hns) ∧ (b = Set.IsWf.min ht hnt)))", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)"]}, {"prop": "Set.IsWf.min hs hns = Set.IsWf.min hs hns", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)", "(a_1 : (a ∈ s) ∧ ((b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt)))", "(has : a ∈ s)", "(right : (b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt))", "(hat : b ∈ t)", "(hst : a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt)", "(has : Set.IsWf.min hs hns ∈ s)", "(hst : Set.IsWf.min hs hns + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt)"]}, {"prop": "b = Set.IsWf.min ht hnt", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)", "(a_1 : (a ∈ s) ∧ ((b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt)))", "(has : a ∈ s)", "(right : (b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt))", "(hat : b ∈ t)", "(hst : a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt)", "(has : Set.IsWf.min hs hns ∈ s)", "(hst : Set.IsWf.min hs hns + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt)"]}, {"prop": "∀ (has : Set.IsWf.min hs hns ∈ s) (hst : Set.IsWf.min hs hns + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt),\n  (Set.IsWf.min hs hns = Set.IsWf.min hs hns) ∧ (b = Set.IsWf.min ht hnt)", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)", "(a_1 : (a ∈ s) ∧ ((b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt)))", "(has : a ∈ s)", "(right : (b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt))", "(hat : b ∈ t)", "(hst : a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt)"]}, {"prop": "Set.IsWf.min hs hns ≤ a", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)", "(a_1 : (a ∈ s) ∧ ((b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt)))", "(has : a ∈ s)", "(right : (b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt))", "(hat : b ∈ t)", "(hst : a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt)"]}, {"prop": "Set.IsWf.min ht hnt ≤ b", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)", "(a_1 : (a ∈ s) ∧ ((b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt)))", "(has : a ∈ s)", "(right : (b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt))", "(hat : b ∈ t)", "(hst : a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt)", "(hlt : Set.IsWf.min hs hns < a)"]}, {"prop": "Set.IsWf.min hs hns + Set.IsWf.min ht hnt < a + b", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)", "(a_1 : (a ∈ s) ∧ ((b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt)))", "(has : a ∈ s)", "(right : (b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt))", "(hat : b ∈ t)", "(hst : a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt)", "(hlt : Set.IsWf.min hs hns < a)"]}, {"prop": "∀ (hlt : Set.IsWf.min hs hns < a), False", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)", "(a_1 : (a ∈ s) ∧ ((b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt)))", "(has : a ∈ s)", "(right : (b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt))", "(hat : b ∈ t)", "(hst : a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt)"]}, {"prop": "Set.IsWf.min hs hns = a", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)", "(a_1 : (a ∈ s) ∧ ((b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt)))", "(has : a ∈ s)", "(right : (b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt))", "(hat : b ∈ t)", "(hst : a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt)"]}, {"prop": "∀ (hat : b ∈ t) (hst : a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt),\n  (a = Set.IsWf.min hs hns) ∧ (b = Set.IsWf.min ht hnt)", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)", "(a_1 : (a ∈ s) ∧ ((b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt)))", "(has : a ∈ s)", "(right : (b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt))"]}, {"prop": "∀ (has : a ∈ s) (right : (b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt)),\n  (a = Set.IsWf.min hs hns) ∧ (b = Set.IsWf.min ht hnt)", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)", "(a_1 : (a ∈ s) ∧ ((b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt)))"]}, {"prop": "∀ (a_1 : (a ∈ s) ∧ ((b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt))),\n  (a = Set.IsWf.min hs hns) ∧ (b = Set.IsWf.min ht hnt)", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)"]}, {"prop": "Set.IsWf.min hs hns = a", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)", "(a_1 : (a = Set.IsWf.min hs hns) ∧ (b = Set.IsWf.min ht hnt))", "(left : a = Set.IsWf.min hs hns)", "(right : b = Set.IsWf.min ht hnt)"]}, {"prop": "Set.IsWf.min ht hnt = b", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)", "(a_1 : (a = Set.IsWf.min hs hns) ∧ (b = Set.IsWf.min ht hnt))", "(left : a = Set.IsWf.min hs hns)", "(right : b = Set.IsWf.min ht hnt)"]}, {"prop": "Set.IsWf.min hs hns ∈ s", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)", "(a_1 : (a = Set.IsWf.min hs hns) ∧ (b = Set.IsWf.min ht hnt))", "(left : a = Set.IsWf.min hs hns)", "(right : b = Set.IsWf.min ht hnt)"]}, {"prop": "Set.IsWf.min ht hnt ∈ t", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)", "(a_1 : (a = Set.IsWf.min hs hns) ∧ (b = Set.IsWf.min ht hnt))", "(left : a = Set.IsWf.min hs hns)", "(right : b = Set.IsWf.min ht hnt)"]}, {"prop": "Set.IsWf.min hs hns + Set.IsWf.min ht hnt = Set.IsWf.min hs hns + Set.IsWf.min ht hnt", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)", "(a_1 : (a = Set.IsWf.min hs hns) ∧ (b = Set.IsWf.min ht hnt))", "(left : a = Set.IsWf.min hs hns)", "(right : b = Set.IsWf.min ht hnt)"]}, {"prop": "(Set.IsWf.min ht hnt ∈ t) ∧ (Set.IsWf.min hs hns + Set.IsWf.min ht hnt = Set.IsWf.min hs hns + Set.IsWf.min ht hnt)", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)", "(a_1 : (a = Set.IsWf.min hs hns) ∧ (b = Set.IsWf.min ht hnt))", "(left : a = Set.IsWf.min hs hns)", "(right : b = Set.IsWf.min ht hnt)"]}, {"prop": "(Set.IsWf.min hs hns ∈ s) ∧\n  ((Set.IsWf.min ht hnt ∈ t) ∧ (Set.IsWf.min hs hns + Set.IsWf.min ht hnt = Set.IsWf.min hs hns + Set.IsWf.min ht hnt))", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)", "(a_1 : (a = Set.IsWf.min hs hns) ∧ (b = Set.IsWf.min ht hnt))", "(left : a = Set.IsWf.min hs hns)", "(right : b = Set.IsWf.min ht hnt)"]}, {"prop": "(Set.IsWf.min hs hns ∈ s) ∧ ((b ∈ t) ∧ (Set.IsWf.min hs hns + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt))", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)", "(a_1 : (a = Set.IsWf.min hs hns) ∧ (b = Set.IsWf.min ht hnt))", "(left : a = Set.IsWf.min hs hns)", "(right : b = Set.IsWf.min ht hnt)"]}, {"prop": "∀ (left : a = Set.IsWf.min hs hns) (right : b = Set.IsWf.min ht hnt),\n  (a ∈ s) ∧ ((b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt))", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)", "(a_1 : (a = Set.IsWf.min hs hns) ∧ (b = Set.IsWf.min ht hnt))"]}, {"prop": "∀ (a_1 : (a = Set.IsWf.min hs hns) ∧ (b = Set.IsWf.min ht hnt)),\n  (a ∈ s) ∧ ((b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt))", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)"]}, {"prop": "((a ∈ s) ∧ ((b ∈ t) ∧ (a + b = Set.IsWf.min hs hns + Set.IsWf.min ht hnt))) ↔\n  ((a = Set.IsWf.min hs hns) ∧ (b = Set.IsWf.min ht hnt))", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)", "(a : α)", "(b : α)"]}, {"prop": "∀ (a : α) (b : α),\n  ((a, b) ∈\n      Finset.addAntidiagonal (Set.IsWf.isPwo hs) (Set.IsWf.isPwo ht) (Set.IsWf.min hs hns + Set.IsWf.min ht hnt)) ↔\n    ((a, b) ∈ {(Set.IsWf.min hs hns, Set.IsWf.min ht hnt)})", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)", "(a : α × α)"]}, {"prop": "∀ (a : α × α),\n  (a ∈ Finset.addAntidiagonal (Set.IsWf.isPwo hs) (Set.IsWf.isPwo ht) (Set.IsWf.min hs hns + Set.IsWf.min ht hnt)) ↔\n    (a ∈ {(Set.IsWf.min hs hns, Set.IsWf.min ht hnt)})", "context": ["{α : Type u_1}", "[LinearOrderedCancelAddCommMonoid α]", "{s : Set α}", "{t : Set α}", "(hs : Set.IsWf s)", "(ht : Set.IsWf t)", "(hns : Set.Nonempty s)", "(hnt : Set.Nonempty t)"]}], "ids": ["Finset.ext", "Eq.mpr", "id", "congr", "congrArg", "Iff", "Mathlib.Data.Finset.MulAntidiagonal._auxLemma.4", "Eq.trans", "Mathlib.Data.Finset.MulAntidiagonal._auxAddLemma.6", "Mathlib.Data.Finset.MulAntidiagonal._auxAddLemma.7", "mp", "Eq.ndrec", "Set.IsWf.min", "Set.IsWf.min", "Set.IsWf.min", "Set.IsWf.min", "left", "rfl", "add_left_cancel", "LE.le.eq_of_not_lt", "Set.IsWf.min_le", "LT.lt.ne'", "add_lt_add_of_lt_of_le", "Set.IsWf.min_le", "mpr", "Eq.symm", "Eq.symm", "Set.IsWf.min_mem", "Set.IsWf.min_mem", "rfl"], "idString": "Finset.ext; Eq.mpr; id; congr; congrArg; Iff; Mathlib.Data.Finset.MulAntidiagonal._auxLemma.4; Eq.trans; Mathlib.Data.Finset.MulAntidiagonal._auxAddLemma.6; Mathlib.Data.Finset.MulAntidiagonal._auxAddLemma.7; mp; Eq.ndrec; Set.IsWf.min; Set.IsWf.min; Set.IsWf.min; Set.IsWf.min; left; rfl; add_left_cancel; LE.le.eq_of_not_lt; Set.IsWf.min_le; LT.lt.ne'; add_lt_add_of_lt_of_le; Set.IsWf.min_le; mpr; Eq.symm; Eq.symm; Set.IsWf.min_mem; Set.IsWf.min_mem; rfl; ", "context": []}
{"typeGroup": "(∀ (α : Type u_1) (β : Type u_2) [inst : AddZeroClass β] (x : β) (x_1 : β),\n    ZeroHom.toFun { toFun := ((Function.const α)), map_zero' := (((rfl=:Function.const α 0 = Function.const α 0))) }\n        (x + x_1) =\n      ZeroHom.toFun { toFun := ((Function.const α)), map_zero' := (((rfl=:Function.const α 0 = Function.const α 0))) }\n        (x + x_1) :\n  Prop)", "type": "∀ (α : Type u_1) (β : Type u_2) [inst : AddZeroClass β] (x : β) (x_1 : β),\n  ZeroHom.toFun { toFun := ((Function.const α)), map_zero' := ((rfl)) } (x + x_1) =\n    ZeroHom.toFun { toFun := ((Function.const α)), map_zero' := ((rfl)) } (x + x_1)", "thm": " : ∀ (α : Type u_1) (β : Type u_2) [inst : AddZeroClass β] (x : β) (x_1 : β),\n  ZeroHom.toFun { toFun := ((Function.const α)), map_zero' := ((rfl)) } (x + x_1) =\n    ZeroHom.toFun { toFun := ((Function.const α)), map_zero' := ((rfl)) } (x + x_1)", "terms": [], "namedLemmas": ["∀ {α : Sort u} {a : α}, a = a"], "lemmas": [], "ids": ["rfl"], "idString": "rfl; ", "context": []}
{"typeGroup": "(∀ {X : Type u_1} [inst : TopologicalSpace X] (x : X) (t : ↑unitInterval) (x_1 : Path x x) (a : x_1 ∈ {Path.refl x}),\n    (↑(ContinuousMap.mk fun (x_2 : Path x x) ↦\n                ContinuousMap.toFun\n                  (ContinuousMap.Homotopy.toContinuousMap\n                    {\n                      toContinuousMap :=\n                        ((ContinuousMap.mk fun (p : ↑unitInterval × Path x x) ↦\n                          Path.delayReflRight (Prod.fst p) (Prod.snd p))),\n                      map_zero_left :=\n                        (((Path.delayReflRight_zero=:∀ (γ : Path x x),\n                            Path.delayReflRight 0 γ = Path.trans γ (Path.refl x)))),\n                      map_one_left := (((Path.delayReflRight_one=:∀ (γ : Path x x), Path.delayReflRight 1 γ = γ))) })\n                  (t, x_2))\n            x_1 =\n          ↑(ContinuousMap.comp (ContinuousMap.mk fun (ρ : Path x x × Path x x) ↦ Path.trans (Prod.fst ρ) (Prod.snd ρ))\n                (ContinuousMap.prodMk (ContinuousMap.id (Path x x)) (ContinuousMap.const (Path x x) (Path.refl x))))\n            x_1 :\n        Prop) ∧\n      (↑(ContinuousMap.mk fun (x_2 : Path x x) ↦\n                ContinuousMap.toFun\n                  (ContinuousMap.Homotopy.toContinuousMap\n                    {\n                      toContinuousMap :=\n                        ((ContinuousMap.mk fun (p : ↑unitInterval × Path x x) ↦\n                          Path.delayReflRight (Prod.fst p) (Prod.snd p))),\n                      map_zero_left :=\n                        (((Path.delayReflRight_zero=:∀ (γ : Path x x),\n                            Path.delayReflRight 0 γ = Path.trans γ (Path.refl x)))),\n                      map_one_left := (((Path.delayReflRight_one=:∀ (γ : Path x x), Path.delayReflRight 1 γ = γ))) })\n                  (t, x_2))\n            x_1 =\n          ↑(ContinuousMap.id (Path x x)) x_1 :\n        Prop) :\n  Prop)", "type": "∀ {X : Type u_1} [inst : TopologicalSpace X] (x : X) (t : ↑unitInterval) (x_1 : Path x x) (a : x_1 ∈ {Path.refl x}),\n  (↑(ContinuousMap.mk fun (x_2 : Path x x) ↦\n            ContinuousMap.toFun\n              (ContinuousMap.Homotopy.toContinuousMap\n                {\n                  toContinuousMap :=\n                    ((ContinuousMap.mk fun (p : ↑unitInterval × Path x x) ↦\n                      Path.delayReflRight (Prod.fst p) (Prod.snd p))),\n                  map_zero_left := ((Path.delayReflRight_zero)), map_one_left := ((Path.delayReflRight_one)) })\n              (t, x_2))\n        x_1 =\n      ↑(ContinuousMap.comp (ContinuousMap.mk fun (ρ : Path x x × Path x x) ↦ Path.trans (Prod.fst ρ) (Prod.snd ρ))\n            (ContinuousMap.prodMk (ContinuousMap.id (Path x x)) (ContinuousMap.const (Path x x) (Path.refl x))))\n        x_1) ∧\n    (↑(ContinuousMap.mk fun (x_2 : Path x x) ↦\n            ContinuousMap.toFun\n              (ContinuousMap.Homotopy.toContinuousMap\n                {\n                  toContinuousMap :=\n                    ((ContinuousMap.mk fun (p : ↑unitInterval × Path x x) ↦\n                      Path.delayReflRight (Prod.fst p) (Prod.snd p))),\n                  map_zero_left := ((Path.delayReflRight_zero)), map_one_left := ((Path.delayReflRight_one)) })\n              (t, x_2))\n        x_1 =\n      ↑(ContinuousMap.id (Path x x)) x_1)", "thm": " : ∀ {X : Type u_1} [inst : TopologicalSpace X] (x : X) (t : ↑unitInterval) (x_1 : Path x x) (a : x_1 ∈ {Path.refl x}),\n  (↑(ContinuousMap.mk fun (x_2 : Path x x) ↦\n            ContinuousMap.toFun\n              (ContinuousMap.Homotopy.toContinuousMap\n                {\n                  toContinuousMap :=\n                    ((ContinuousMap.mk fun (p : ↑unitInterval × Path x x) ↦\n                      Path.delayReflRight (Prod.fst p) (Prod.snd p))),\n                  map_zero_left := ((Path.delayReflRight_zero)), map_one_left := ((Path.delayReflRight_one)) })\n              (t, x_2))\n        x_1 =\n      ↑(ContinuousMap.comp (ContinuousMap.mk fun (ρ : Path x x × Path x x) ↦ Path.trans (Prod.fst ρ) (Prod.snd ρ))\n            (ContinuousMap.prodMk (ContinuousMap.id (Path x x)) (ContinuousMap.const (Path x x) (Path.refl x))))\n        x_1) ∧\n    (↑(ContinuousMap.mk fun (x_2 : Path x x) ↦\n            ContinuousMap.toFun\n              (ContinuousMap.Homotopy.toContinuousMap\n                {\n                  toContinuousMap :=\n                    ((ContinuousMap.mk fun (p : ↑unitInterval × Path x x) ↦\n                      Path.delayReflRight (Prod.fst p) (Prod.snd p))),\n                  map_zero_left := ((Path.delayReflRight_zero)), map_one_left := ((Path.delayReflRight_one)) })\n              (t, x_2))\n        x_1 =\n      ↑(ContinuousMap.id (Path x x)) x_1)", "terms": [], "namedLemmas": ["∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {X : Type u_1} [inst : TopologicalSpace X] {a : X}, Path.trans (Path.refl a) (Path.refl a) = Path.refl a", "∀ {α : Sort u} {a : α}, a = a"], "lemmas": [{"prop": "Path.refl x = x_1", "context": ["{X : Type u_1}", "[TopologicalSpace X]", "(x : X)", "(t : ↑unitInterval)", "(x_1 : Path x x)", "(a : x_1 ∈ {Path.refl x})"]}, {"prop": "Path.trans (Path.refl x) (Path.refl x) = Path.refl x", "context": ["{X : Type u_1}", "[TopologicalSpace X]", "(x : X)", "(t : ↑unitInterval)", "(x_1 : Path x x)", "(a : x_1 ∈ {Path.refl x})"]}, {"prop": "Path.refl x = Path.trans (Path.refl x) (Path.refl x)", "context": ["{X : Type u_1}", "[TopologicalSpace X]", "(x : X)", "(t : ↑unitInterval)", "(x_1 : Path x x)", "(a : x_1 ∈ {Path.refl x})"]}, {"prop": "↑(ContinuousMap.mk fun (x_2 : Path x x) ↦\n        ContinuousMap.toFun\n          (ContinuousMap.Homotopy.toContinuousMap\n            {\n              toContinuousMap :=\n                ((ContinuousMap.mk fun (p : ↑unitInterval × Path x x) ↦ Path.delayReflRight (Prod.fst p) (Prod.snd p))),\n              map_zero_left := ((Path.delayReflRight_zero)), map_one_left := ((Path.delayReflRight_one)) })\n          (t, x_2))\n    (Path.refl x) =\n  ↑(ContinuousMap.mk fun (x_2 : Path x x) ↦\n        ContinuousMap.toFun\n          (ContinuousMap.Homotopy.toContinuousMap\n            {\n              toContinuousMap :=\n                ((ContinuousMap.mk fun (p : ↑unitInterval × Path x x) ↦ Path.delayReflRight (Prod.fst p) (Prod.snd p))),\n              map_zero_left := ((Path.delayReflRight_zero)), map_one_left := ((Path.delayReflRight_one)) })\n          (t, x_2))\n    (Path.refl x)", "context": ["{X : Type u_1}", "[TopologicalSpace X]", "(x : X)", "(t : ↑unitInterval)", "(x_1 : Path x x)", "(a : x_1 ∈ {Path.refl x})"]}, {"prop": "(↑(ContinuousMap.mk fun (x_2 : Path x x) ↦\n          ContinuousMap.toFun\n            (ContinuousMap.Homotopy.toContinuousMap\n              {\n                toContinuousMap :=\n                  ((ContinuousMap.mk fun (p : ↑unitInterval × Path x x) ↦\n                    Path.delayReflRight (Prod.fst p) (Prod.snd p))),\n                map_zero_left := ((Path.delayReflRight_zero)), map_one_left := ((Path.delayReflRight_one)) })\n            (t, x_2))\n      (Path.refl x) =\n    ↑(ContinuousMap.comp (ContinuousMap.mk fun (ρ : Path x x × Path x x) ↦ Path.trans (Prod.fst ρ) (Prod.snd ρ))\n          (ContinuousMap.prodMk (ContinuousMap.id (Path x x)) (ContinuousMap.const (Path x x) (Path.refl x))))\n      (Path.refl x)) ∧\n  (↑(ContinuousMap.mk fun (x_2 : Path x x) ↦\n          ContinuousMap.toFun\n            (ContinuousMap.Homotopy.toContinuousMap\n              {\n                toContinuousMap :=\n                  ((ContinuousMap.mk fun (p : ↑unitInterval × Path x x) ↦\n                    Path.delayReflRight (Prod.fst p) (Prod.snd p))),\n                map_zero_left := ((Path.delayReflRight_zero)), map_one_left := ((Path.delayReflRight_one)) })\n            (t, x_2))\n      (Path.refl x) =\n    ↑(ContinuousMap.id (Path x x)) (Path.refl x))", "context": ["{X : Type u_1}", "[TopologicalSpace X]", "(x : X)", "(t : ↑unitInterval)", "(x_1 : Path x x)", "(a : x_1 ∈ {Path.refl x})"]}], "ids": ["Eq.symm", "left", "Eq.symm", "Path.refl_trans_refl", "right", "rfl"], "idString": "Eq.symm; left; Eq.symm; Path.refl_trans_refl; right; rfl; ", "context": []}
{"typeGroup": "(∀ {C : Type u_2} [inst : CategoryTheory.Category C] {X₁ : C} {X₂ : C} {X₃ : C} {Y₁ : C} {Y₂ : C} (f₁ : X₁ ⟶ Y₁)\n    (f₂ : X₂ ⟶ Y₁) (f₃ : X₂ ⟶ Y₂) (f₄ : X₃ ⟶ Y₂) [inst_1 : CategoryTheory.Limits.HasPullback f₁ f₂]\n    [inst_2 : CategoryTheory.Limits.HasPullback f₃ f₄]\n    [inst_3 :\n      CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)],\n    CategoryTheory.CategoryStruct.comp\n        (CategoryTheory.Limits.pullback.lift CategoryTheory.Limits.pullback.fst\n          (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst)\n          (Eq.trans\n              (CategoryTheory.Limits.pullback.condition=:CategoryTheory.CategoryStruct.comp\n                    CategoryTheory.Limits.pullback.fst f₁ =\n                  CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n                    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂))\n              (Eq.symm\n                  (CategoryTheory.Category.assoc CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst\n                      f₂=:CategoryTheory.CategoryStruct.comp\n                        (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n                          CategoryTheory.Limits.pullback.fst)\n                        f₂ =\n                      CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n                        (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst\n                          f₂))=:CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n                    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂) =\n                  CategoryTheory.CategoryStruct.comp\n                    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n                      CategoryTheory.Limits.pullback.fst)\n                    f₂)=:CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₁ =\n              CategoryTheory.CategoryStruct.comp\n                (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n                  CategoryTheory.Limits.pullback.fst)\n                f₂))\n        CategoryTheory.Limits.pullback.snd =\n      CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst :\n  Prop)", "type": "∀ {C : Type u_2} [inst : CategoryTheory.Category C] {X₁ : C} {X₂ : C} {X₃ : C} {Y₁ : C} {Y₂ : C} (f₁ : X₁ ⟶ Y₁)\n  (f₂ : X₂ ⟶ Y₁) (f₃ : X₂ ⟶ Y₂) (f₄ : X₃ ⟶ Y₂) [inst_1 : CategoryTheory.Limits.HasPullback f₁ f₂]\n  [inst_2 : CategoryTheory.Limits.HasPullback f₃ f₄]\n  [inst_3 :\n    CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)],\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.Limits.pullback.lift CategoryTheory.Limits.pullback.fst\n        (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst)\n        (Eq.trans CategoryTheory.Limits.pullback.condition\n          (Eq.symm\n            (CategoryTheory.Category.assoc CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst f₂))))\n      CategoryTheory.Limits.pullback.snd =\n    CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst", "thm": " : ∀ {C : Type u_2} [inst : CategoryTheory.Category C] {X₁ : C} {X₂ : C} {X₃ : C} {Y₁ : C} {Y₂ : C} (f₁ : X₁ ⟶ Y₁)\n  (f₂ : X₂ ⟶ Y₁) (f₃ : X₂ ⟶ Y₂) (f₄ : X₃ ⟶ Y₂) [inst_1 : CategoryTheory.Limits.HasPullback f₁ f₂]\n  [inst_2 : CategoryTheory.Limits.HasPullback f₃ f₄]\n  [inst_3 :\n    CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)],\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.Limits.pullback.lift CategoryTheory.Limits.pullback.fst\n        (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst)\n        (Eq.trans CategoryTheory.Limits.pullback.condition\n          (Eq.symm\n            (CategoryTheory.Category.assoc CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst f₂))))\n      CategoryTheory.Limits.pullback.snd =\n    CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst", "terms": [{"value": "CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst", "isProp": false, "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{X₁ : C}", "{X₂ : C}", "{X₃ : C}", "{Y₁ : C}", "{Y₂ : C}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₁)", "(f₃ : X₂ ⟶ Y₂)", "(f₄ : X₃ ⟶ Y₂)", "[CategoryTheory.Limits.HasPullback f₁ f₂]", "[CategoryTheory.Limits.HasPullback f₃ f₄]", "[CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)]"]}], "namedLemmas": ["∀ {C : Type u} [inst : CategoryTheory.Category C] {W X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z}\n  [inst_1 : CategoryTheory.Limits.HasPullback f g] (h : W ⟶ X) (k : W ⟶ Y)\n  (w : CategoryTheory.CategoryStruct.comp h f = CategoryTheory.CategoryStruct.comp k g),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.lift h k w) CategoryTheory.Limits.pullback.snd = k", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {C : Type u} [inst : CategoryTheory.Category C] {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z}\n  [inst_1 : CategoryTheory.Limits.HasPullback f g],\n  CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f =\n    CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd g", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {obj : Type u} [self : CategoryTheory.Category obj] {W X Y Z : obj} (f : W ⟶ X) (g : X ⟶ Y) (h : Y ⟶ Z),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g) h =\n    CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g h)"], "lemmas": [{"prop": "CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₁ =\n  CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{X₁ : C}", "{X₂ : C}", "{X₃ : C}", "{Y₁ : C}", "{Y₂ : C}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₁)", "(f₃ : X₂ ⟶ Y₂)", "(f₄ : X₃ ⟶ Y₂)", "[CategoryTheory.Limits.HasPullback f₁ f₂]", "[CategoryTheory.Limits.HasPullback f₃ f₄]", "[CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)]"]}, {"prop": "CategoryTheory.CategoryStruct.comp\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst) f₂ =\n  CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{X₁ : C}", "{X₂ : C}", "{X₃ : C}", "{Y₁ : C}", "{Y₂ : C}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₁)", "(f₃ : X₂ ⟶ Y₂)", "(f₄ : X₃ ⟶ Y₂)", "[CategoryTheory.Limits.HasPullback f₁ f₂]", "[CategoryTheory.Limits.HasPullback f₃ f₄]", "[CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)]"]}, {"prop": "CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂) =\n  CategoryTheory.CategoryStruct.comp\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst) f₂", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{X₁ : C}", "{X₂ : C}", "{X₃ : C}", "{Y₁ : C}", "{Y₂ : C}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₁)", "(f₃ : X₂ ⟶ Y₂)", "(f₄ : X₃ ⟶ Y₂)", "[CategoryTheory.Limits.HasPullback f₁ f₂]", "[CategoryTheory.Limits.HasPullback f₃ f₄]", "[CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)]"]}, {"prop": "CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₁ =\n  CategoryTheory.CategoryStruct.comp\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst) f₂", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{X₁ : C}", "{X₂ : C}", "{X₃ : C}", "{Y₁ : C}", "{Y₂ : C}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₁)", "(f₃ : X₂ ⟶ Y₂)", "(f₄ : X₃ ⟶ Y₂)", "[CategoryTheory.Limits.HasPullback f₁ f₂]", "[CategoryTheory.Limits.HasPullback f₃ f₄]", "[CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)]"]}], "ids": ["CategoryTheory.Limits.pullback.lift_snd", "CategoryTheory.Limits.pullback.fst", "CategoryTheory.CategoryStruct.comp", "CategoryTheory.Limits.pullback.snd", "CategoryTheory.Limits.pullback.fst", "Eq.trans", "CategoryTheory.Limits.pullback.condition", "Eq.symm", "CategoryTheory.Category.assoc", "CategoryTheory.Limits.pullback.snd", "CategoryTheory.Limits.pullback.fst"], "idString": "CategoryTheory.Limits.pullback.lift_snd; CategoryTheory.Limits.pullback.fst; CategoryTheory.CategoryStruct.comp; CategoryTheory.Limits.pullback.snd; CategoryTheory.Limits.pullback.fst; Eq.trans; CategoryTheory.Limits.pullback.condition; Eq.symm; CategoryTheory.Category.assoc; CategoryTheory.Limits.pullback.snd; CategoryTheory.Limits.pullback.fst; ", "context": []}
{"typeGroup": "(∀ {C : Type u_2} [inst : CategoryTheory.Category C] {X₁ : C} {X₂ : C} {X₃ : C} {Y₁ : C} {Y₂ : C} (f₁ : X₁ ⟶ Y₁)\n    (f₂ : X₂ ⟶ Y₁) (f₃ : X₂ ⟶ Y₂) (f₄ : X₃ ⟶ Y₂) [inst_1 : CategoryTheory.Limits.HasPullback f₁ f₂]\n    [inst_2 : CategoryTheory.Limits.HasPullback f₃ f₄]\n    [inst_3 :\n      CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)],\n    CategoryTheory.CategoryStruct.comp\n        (CategoryTheory.Limits.pullback.lift CategoryTheory.Limits.pullback.fst\n          (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst)\n          (Eq.trans\n              (CategoryTheory.Limits.pullback.condition=:CategoryTheory.CategoryStruct.comp\n                    CategoryTheory.Limits.pullback.fst f₁ =\n                  CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n                    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂))\n              (Eq.symm\n                  (CategoryTheory.Category.assoc CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst\n                      f₂=:CategoryTheory.CategoryStruct.comp\n                        (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n                          CategoryTheory.Limits.pullback.fst)\n                        f₂ =\n                      CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n                        (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst\n                          f₂))=:CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n                    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂) =\n                  CategoryTheory.CategoryStruct.comp\n                    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n                      CategoryTheory.Limits.pullback.fst)\n                    f₂)=:CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₁ =\n              CategoryTheory.CategoryStruct.comp\n                (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n                  CategoryTheory.Limits.pullback.fst)\n                f₂))\n        CategoryTheory.Limits.pullback.snd =\n      CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst :\n  Prop)", "type": "CategoryTheory.CategoryStruct.comp\n    (CategoryTheory.Limits.pullback.lift CategoryTheory.Limits.pullback.fst\n      (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst)\n      (Eq.trans CategoryTheory.Limits.pullback.condition\n        (Eq.symm\n          (CategoryTheory.Category.assoc CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst f₂))))\n    CategoryTheory.Limits.pullback.snd =\n  CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst", "thm": "{C : Type u_2} [CategoryTheory.Category C] {X₁ : C} {X₂ : C} {X₃ : C} {Y₁ : C} {Y₂ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₁) (f₃ : X₂ ⟶ Y₂) (f₄ : X₃ ⟶ Y₂) [CategoryTheory.Limits.HasPullback f₁ f₂] [CategoryTheory.Limits.HasPullback f₃ f₄] [CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)]  : CategoryTheory.CategoryStruct.comp\n    (CategoryTheory.Limits.pullback.lift CategoryTheory.Limits.pullback.fst\n      (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst)\n      (Eq.trans CategoryTheory.Limits.pullback.condition\n        (Eq.symm\n          (CategoryTheory.Category.assoc CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst f₂))))\n    CategoryTheory.Limits.pullback.snd =\n  CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst", "terms": [{"value": "CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst", "isProp": false, "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{X₁ : C}", "{X₂ : C}", "{X₃ : C}", "{Y₁ : C}", "{Y₂ : C}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₁)", "(f₃ : X₂ ⟶ Y₂)", "(f₄ : X₃ ⟶ Y₂)", "[CategoryTheory.Limits.HasPullback f₁ f₂]", "[CategoryTheory.Limits.HasPullback f₃ f₄]", "[CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)]"]}], "namedLemmas": ["∀ {C : Type u} [inst : CategoryTheory.Category C] {W X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z}\n  [inst_1 : CategoryTheory.Limits.HasPullback f g] (h : W ⟶ X) (k : W ⟶ Y)\n  (w : CategoryTheory.CategoryStruct.comp h f = CategoryTheory.CategoryStruct.comp k g),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.lift h k w) CategoryTheory.Limits.pullback.snd = k", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {C : Type u} [inst : CategoryTheory.Category C] {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z}\n  [inst_1 : CategoryTheory.Limits.HasPullback f g],\n  CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f =\n    CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd g", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {obj : Type u} [self : CategoryTheory.Category obj] {W X Y Z : obj} (f : W ⟶ X) (g : X ⟶ Y) (h : Y ⟶ Z),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g) h =\n    CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g h)"], "lemmas": [{"prop": "CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₁ =\n  CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{X₁ : C}", "{X₂ : C}", "{X₃ : C}", "{Y₁ : C}", "{Y₂ : C}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₁)", "(f₃ : X₂ ⟶ Y₂)", "(f₄ : X₃ ⟶ Y₂)", "[CategoryTheory.Limits.HasPullback f₁ f₂]", "[CategoryTheory.Limits.HasPullback f₃ f₄]", "[CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)]"]}, {"prop": "CategoryTheory.CategoryStruct.comp\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst) f₂ =\n  CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{X₁ : C}", "{X₂ : C}", "{X₃ : C}", "{Y₁ : C}", "{Y₂ : C}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₁)", "(f₃ : X₂ ⟶ Y₂)", "(f₄ : X₃ ⟶ Y₂)", "[CategoryTheory.Limits.HasPullback f₁ f₂]", "[CategoryTheory.Limits.HasPullback f₃ f₄]", "[CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)]"]}, {"prop": "CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂) =\n  CategoryTheory.CategoryStruct.comp\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst) f₂", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{X₁ : C}", "{X₂ : C}", "{X₃ : C}", "{Y₁ : C}", "{Y₂ : C}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₁)", "(f₃ : X₂ ⟶ Y₂)", "(f₄ : X₃ ⟶ Y₂)", "[CategoryTheory.Limits.HasPullback f₁ f₂]", "[CategoryTheory.Limits.HasPullback f₃ f₄]", "[CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)]"]}, {"prop": "CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₁ =\n  CategoryTheory.CategoryStruct.comp\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst) f₂", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{X₁ : C}", "{X₂ : C}", "{X₃ : C}", "{Y₁ : C}", "{Y₂ : C}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₁)", "(f₃ : X₂ ⟶ Y₂)", "(f₄ : X₃ ⟶ Y₂)", "[CategoryTheory.Limits.HasPullback f₁ f₂]", "[CategoryTheory.Limits.HasPullback f₃ f₄]", "[CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)]"]}], "ids": ["CategoryTheory.Limits.pullback.lift_snd", "CategoryTheory.Limits.pullback.fst", "CategoryTheory.CategoryStruct.comp", "CategoryTheory.Limits.pullback.snd", "CategoryTheory.Limits.pullback.fst", "Eq.trans", "CategoryTheory.Limits.pullback.condition", "Eq.symm", "CategoryTheory.Category.assoc", "CategoryTheory.Limits.pullback.snd", "CategoryTheory.Limits.pullback.fst"], "idString": "CategoryTheory.Limits.pullback.lift_snd; CategoryTheory.Limits.pullback.fst; CategoryTheory.CategoryStruct.comp; CategoryTheory.Limits.pullback.snd; CategoryTheory.Limits.pullback.fst; Eq.trans; CategoryTheory.Limits.pullback.condition; Eq.symm; CategoryTheory.Category.assoc; CategoryTheory.Limits.pullback.snd; CategoryTheory.Limits.pullback.fst; ", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{X₁ : C}", "{X₂ : C}", "{X₃ : C}", "{Y₁ : C}", "{Y₂ : C}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₁)", "(f₃ : X₂ ⟶ Y₂)", "(f₄ : X₃ ⟶ Y₂)", "[CategoryTheory.Limits.HasPullback f₁ f₂]", "[CategoryTheory.Limits.HasPullback f₃ f₄]", "[CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)]"]}
{"typeGroup": "(∀ (x : ℝ) (y : ℝ) [h : Fact (x < y : Prop)] ⦃x_1 : EuclideanHalfSpace 1⦄\n    (a : x_1 ∈ {z : EuclideanHalfSpace 1 | ↑z 0 < y - x}),\n    (fun (z : EuclideanHalfSpace 1) ↦\n          { val := ((min (↑z 0 + x) y)),\n            property :=\n              (((of_eq_true\n                  (Eq.trans\n                      (Eq.trans\n                          (Mathlib.Data.Set.Intervals.Basic._auxLemma.4=:(min (↑z 0 + x) y ∈ Set.Icc x y : Prop) =\n                              ((x ≤ min (↑z 0 + x) y : Prop) ∧ (min (↑z 0 + x) y ≤ y : Prop) : Prop))\n                          (congr\n                              (congrArg And\n                                  (Eq.trans\n                                      (Eq.trans\n                                          (Mathlib.Order.MinMax._auxLemma.1=:(x ≤ min (↑z 0 + x) y : Prop) =\n                                              ((x ≤ ↑z 0 + x : Prop) ∧ (x ≤ y : Prop) : Prop))\n                                          (congr\n                                              (congrArg And\n                                                  (Eq.trans\n                                                      (Mathlib.Algebra.Order.Monoid.Lemmas._auxLemma.14\n                                                          x=:(x ≤ ↑z 0 + x : Prop) = (0 ≤ ↑z 0 : Prop))\n                                                      (eq_true\n                                                          (Subtype.prop\n                                                              z=:0 ≤\n                                                              ↑z\n                                                                0)=:(0 ≤ ↑z 0 : Prop) =\n                                                          (True :\n                                                            Prop))=:(x ≤ ↑z 0 + x : Prop) =\n                                                      (True : Prop))=:And (x ≤ ↑z 0 + x : Prop) = And (True : Prop))\n                                              (eq_true\n                                                  (le_of_lt\n                                                      (Fact.out=:x <\n                                                          y)=:x ≤\n                                                      y)=:(x ≤ y : Prop) =\n                                                  (True :\n                                                    Prop))=:((x ≤ ↑z 0 + x : Prop) ∧ (x ≤ y : Prop) : Prop) =\n                                              ((True : Prop) ∧ (True : Prop) :\n                                                Prop))=:(x ≤ min (↑z 0 + x) y : Prop) =\n                                          ((True : Prop) ∧ (True : Prop) : Prop))\n                                      (and_self\n                                          (True :\n                                            Prop)=:((True : Prop) ∧ (True : Prop) : Prop) =\n                                          (True :\n                                            Prop))=:(x ≤ min (↑z 0 + x) y : Prop) =\n                                      (True : Prop))=:And (x ≤ min (↑z 0 + x) y : Prop) = And (True : Prop))\n                              (Eq.trans\n                                  (Eq.trans\n                                      (Mathlib.Order.MinMax._auxLemma.3=:(min (↑z 0 + x) y ≤ y : Prop) =\n                                          ((↑z 0 + x ≤ y : Prop) ∨ (y ≤ y : Prop) : Prop))\n                                      (congrArg (Or (↑z 0 + x ≤ y : Prop))\n                                          (Mathlib.Order.Basic._auxLemma.1\n                                              y=:(y ≤ y : Prop) =\n                                              (True :\n                                                Prop))=:((↑z 0 + x ≤ y : Prop) ∨ (y ≤ y : Prop) : Prop) =\n                                          ((↑z 0 + x ≤ y : Prop) ∨ (True : Prop) :\n                                            Prop))=:(min (↑z 0 + x) y ≤ y : Prop) =\n                                      ((↑z 0 + x ≤ y : Prop) ∨ (True : Prop) : Prop))\n                                  (or_true\n                                      (↑z 0 + x ≤ y :\n                                        Prop)=:((↑z 0 + x ≤ y : Prop) ∨ (True : Prop) : Prop) =\n                                      (True :\n                                        Prop))=:(min (↑z 0 + x) y ≤ y : Prop) =\n                                  (True :\n                                    Prop))=:((x ≤ min (↑z 0 + x) y : Prop) ∧ (min (↑z 0 + x) y ≤ y : Prop) : Prop) =\n                              ((True : Prop) ∧ (True : Prop) :\n                                Prop))=:(min (↑z 0 + x) y ∈ Set.Icc x y : Prop) =\n                          ((True : Prop) ∧ (True : Prop) : Prop))\n                      (and_self\n                          (True :\n                            Prop)=:((True : Prop) ∧ (True : Prop) : Prop) =\n                          (True :\n                            Prop))=:(min (↑z 0 + x) y ∈ Set.Icc x y : Prop) =\n                      (True : Prop))=:min (↑z 0 + x) y ∈ Set.Icc x y))) })\n        x_1 ∈\n      {z : ↑(Set.Icc x y) | ↑z < y} :\n  Prop)", "type": "∀ (x : ℝ) (y : ℝ) [h : Fact (x < y)] ⦃x_1 : EuclideanHalfSpace 1⦄ (a : x_1 ∈ {z : EuclideanHalfSpace 1 | ↑z 0 < y - x}),\n  (fun (z : EuclideanHalfSpace 1) ↦\n        { val := ((min (↑z 0 + x) y)),\n          property :=\n            (((of_eq_true\n              (Eq.trans\n                (Eq.trans Mathlib.Data.Set.Intervals.Basic._auxLemma.4\n                  (congr\n                    (congrArg And\n                      (Eq.trans\n                        (Eq.trans Mathlib.Order.MinMax._auxLemma.1\n                          (congr\n                            (congrArg And\n                              (Eq.trans (Mathlib.Algebra.Order.Monoid.Lemmas._auxLemma.14 x)\n                                (eq_true (Subtype.prop z))))\n                            (eq_true (le_of_lt Fact.out))))\n                        (and_self True)))\n                    (Eq.trans\n                      (Eq.trans Mathlib.Order.MinMax._auxLemma.3\n                        (congrArg (Or (↑z 0 + x ≤ y)) (Mathlib.Order.Basic._auxLemma.1 y)))\n                      (or_true (↑z 0 + x ≤ y)))))\n                (and_self True))))) })\n      x_1 ∈\n    {z : ↑(Set.Icc x y) | ↑z < y}", "thm": " : ∀ (x : ℝ) (y : ℝ) [h : Fact (x < y)] ⦃x_1 : EuclideanHalfSpace 1⦄ (a : x_1 ∈ {z : EuclideanHalfSpace 1 | ↑z 0 < y - x}),\n  (fun (z : EuclideanHalfSpace 1) ↦\n        { val := ((min (↑z 0 + x) y)),\n          property :=\n            (((of_eq_true\n              (Eq.trans\n                (Eq.trans Mathlib.Data.Set.Intervals.Basic._auxLemma.4\n                  (congr\n                    (congrArg And\n                      (Eq.trans\n                        (Eq.trans Mathlib.Order.MinMax._auxLemma.1\n                          (congr\n                            (congrArg And\n                              (Eq.trans (Mathlib.Algebra.Order.Monoid.Lemmas._auxLemma.14 x)\n                                (eq_true (Subtype.prop z))))\n                            (eq_true (le_of_lt Fact.out))))\n                        (and_self True)))\n                    (Eq.trans\n                      (Eq.trans Mathlib.Order.MinMax._auxLemma.3\n                        (congrArg (Or (↑z 0 + x ≤ y)) (Mathlib.Order.Basic._auxLemma.1 y)))\n                      (or_true (↑z 0 + x ≤ y)))))\n                (and_self True))))) })\n      x_1 ∈\n    {z : ↑(Set.Icc x y) | ↑z < y}", "terms": [{"value": "↑z 0", "isProp": false, "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"value": "Nat.rawCast 1", "isProp": false, "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"value": "ℝ", "isProp": false, "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"value": "Int.negOfNat 1", "isProp": false, "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"value": "y ^ Nat.rawCast 1 * Nat.rawCast 1", "isProp": false, "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"value": "x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0", "isProp": false, "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"value": "↑z 0 ^ Nat.rawCast 1 * Nat.rawCast 1", "isProp": false, "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"value": "y ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)", "isProp": false, "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"value": "x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0", "isProp": false, "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"value": "↑z 0 ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1)", "isProp": false, "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}], "namedLemmas": ["∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a", "∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂)", "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a ≥ b → a < b", "∀ {α : Type u} [inst : Preorder α] {a : α}, ¬a < a", "∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑0 = 0", "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c : α},\n  a < 0 → b ≤ c → a + b < c", "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, a < b → a - b < 0", "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, a ≤ b → a - b ≤ 0"], "lemmas": [{"prop": "(↑x_1 0 < y - x) = (↑x_1 0 < y - x)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃x_1 : EuclideanHalfSpace 1⦄"]}, {"prop": "(min (↑x_1 0 + x) y < y) = ((↑x_1 0 + x < y) ∨ (y < y))", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃x_1 : EuclideanHalfSpace 1⦄"]}, {"prop": "∀ ⦃x_1 : EuclideanHalfSpace 1⦄,\n  (∀ (a : ↑x_1 0 < y - x), min (↑x_1 0 + x) y < y) = (∀ (a : ↑x_1 0 < y - x), (↑x_1 0 + x < y) ∨ (y < y))", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]"]}, {"prop": "(∀ (a : EuclideanHalfSpace 1) (a_1 : ↑a 0 < y - x), min (↑a 0 + x) y < y) =\n  (∀ (a : EuclideanHalfSpace 1) (a_1 : ↑a 0 < y - x), (↑a 0 + x < y) ∨ (y < y))", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]"]}, {"prop": "(∀ ⦃x_1 : EuclideanHalfSpace 1⦄ (a : x_1 ∈ {z : EuclideanHalfSpace 1 | ↑z 0 < y - x}),\n    (fun (z : EuclideanHalfSpace 1) ↦\n          { val := ((min (↑z 0 + x) y)),\n            property :=\n              (((of_eq_true\n                (Eq.trans\n                  (Eq.trans Mathlib.Data.Set.Intervals.Basic._auxLemma.4\n                    (congr\n                      (congrArg And\n                        (Eq.trans\n                          (Eq.trans Mathlib.Order.MinMax._auxLemma.1\n                            (congr\n                              (congrArg And\n                                (Eq.trans (Mathlib.Algebra.Order.Monoid.Lemmas._auxLemma.14 x)\n                                  (eq_true (Subtype.prop z))))\n                              (eq_true (le_of_lt Fact.out))))\n                          (and_self True)))\n                      (Eq.trans\n                        (Eq.trans Mathlib.Order.MinMax._auxLemma.3\n                          (congrArg (Or (↑z 0 + x ≤ y)) (Mathlib.Order.Basic._auxLemma.1 y)))\n                        (or_true (↑z 0 + x ≤ y)))))\n                  (and_self True))))) })\n        x_1 ∈\n      {z : ↑(Set.Icc x y) | ↑z < y}) =\n  (∀ ⦃x_1 : EuclideanHalfSpace 1⦄ (a : ↑x_1 0 < y - x), (↑x_1 0 + x < y) ∨ (y < y))", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]"]}, {"prop": "↑z 0 = ↑z 0 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "y = y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "x = x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "HMul.hMul = HMul.hMul", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsInt (Int.rawCast (Int.negOfNat 1)) (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsNat (Nat.rawCast 1) 1", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsInt (Nat.rawCast 1) (Int.ofNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Int.negOfNat 1 = Int.negOfNat 1", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsInt (Int.rawCast (Int.negOfNat 1) * Nat.rawCast 1) (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Int.rawCast (Int.negOfNat 1) * Nat.rawCast 1 = Int.rawCast (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "-Nat.rawCast 1 = Int.rawCast (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "-(x ^ Nat.rawCast 1 * Nat.rawCast 1) = x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "-0 = 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "-(x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0) = x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "0 + (x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0) = x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0 + (x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0) =\n  y ^ Nat.rawCast 1 * Nat.rawCast 1 + (x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0 - (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0) =\n  y ^ Nat.rawCast 1 * Nat.rawCast 1 + (x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "y - x = y ^ Nat.rawCast 1 * Nat.rawCast 1 + (x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "HMul.hMul = HMul.hMul", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsInt (Int.rawCast (Int.negOfNat 1)) (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsNat (Nat.rawCast 1) 1", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsInt (Nat.rawCast 1) (Int.ofNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Int.negOfNat 1 = Int.negOfNat 1", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsInt (Int.rawCast (Int.negOfNat 1) * Nat.rawCast 1) (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Int.rawCast (Int.negOfNat 1) * Nat.rawCast 1 = Int.rawCast (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "-Nat.rawCast 1 = Int.rawCast (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "-(y ^ Nat.rawCast 1 * Nat.rawCast 1) = y ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "HMul.hMul = HMul.hMul", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsInt (Int.rawCast (Int.negOfNat 1)) (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsInt (Int.rawCast (Int.negOfNat 1)) (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Int.ofNat 1 = Int.ofNat 1", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsInt (Int.rawCast (Int.negOfNat 1) * Int.rawCast (Int.negOfNat 1)) (Int.ofNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsNat (Int.rawCast (Int.negOfNat 1) * Int.rawCast (Int.negOfNat 1)) 1", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Int.rawCast (Int.negOfNat 1) * Int.rawCast (Int.negOfNat 1) = Nat.rawCast 1", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "-Int.rawCast (Int.negOfNat 1) = Nat.rawCast 1", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "-(x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1)) = x ^ Nat.rawCast 1 * Nat.rawCast 1", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "-0 = 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "-(x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0) = x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "-(y ^ Nat.rawCast 1 * Nat.rawCast 1 + (x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0)) =\n  y ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "0 + (y ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)) =\n  y ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "↑z 0 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0 +\n    (y ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)) =\n  ↑z 0 ^ Nat.rawCast 1 * Nat.rawCast 1 +\n    (y ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "↑z 0 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0 -\n    (y ^ Nat.rawCast 1 * Nat.rawCast 1 + (x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0)) =\n  ↑z 0 ^ Nat.rawCast 1 * Nat.rawCast 1 +\n    (y ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "↑z 0 - (y - x) =\n  ↑z 0 ^ Nat.rawCast 1 * Nat.rawCast 1 +\n    (y ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "y = y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "↑z 0 = ↑z 0 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "x = x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "0 + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0) = x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "↑z 0 ^ Nat.rawCast 1 * Nat.rawCast 1 + 0 + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0) =\n  ↑z 0 ^ Nat.rawCast 1 * Nat.rawCast 1 + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "↑z 0 + x = ↑z 0 ^ Nat.rawCast 1 * Nat.rawCast 1 + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "HMul.hMul = HMul.hMul", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsInt (Int.rawCast (Int.negOfNat 1)) (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsNat (Nat.rawCast 1) 1", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsInt (Nat.rawCast 1) (Int.ofNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Int.negOfNat 1 = Int.negOfNat 1", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsInt (Int.rawCast (Int.negOfNat 1) * Nat.rawCast 1) (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Int.rawCast (Int.negOfNat 1) * Nat.rawCast 1 = Int.rawCast (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "-Nat.rawCast 1 = Int.rawCast (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "-(↑z 0 ^ Nat.rawCast 1 * Nat.rawCast 1) = ↑z 0 ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "HMul.hMul = HMul.hMul", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsInt (Int.rawCast (Int.negOfNat 1)) (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsNat (Nat.rawCast 1) 1", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsInt (Nat.rawCast 1) (Int.ofNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Int.negOfNat 1 = Int.negOfNat 1", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsInt (Int.rawCast (Int.negOfNat 1) * Nat.rawCast 1) (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Int.rawCast (Int.negOfNat 1) * Nat.rawCast 1 = Int.rawCast (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "-Nat.rawCast 1 = Int.rawCast (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "-(x ^ Nat.rawCast 1 * Nat.rawCast 1) = x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "-0 = 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "-(x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0) = x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "-(↑z 0 ^ Nat.rawCast 1 * Nat.rawCast 1 + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)) =\n  ↑z 0 ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + (x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "0 + (x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0) = x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0 + (x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0) =\n  y ^ Nat.rawCast 1 * Nat.rawCast 1 + (x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0 +\n    (↑z 0 ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + (x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0)) =\n  ↑z 0 ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) +\n    (y ^ Nat.rawCast 1 * Nat.rawCast 1 + (x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0))", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0 -\n    (↑z 0 ^ Nat.rawCast 1 * Nat.rawCast 1 + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)) =\n  ↑z 0 ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) +\n    (y ^ Nat.rawCast 1 * Nat.rawCast 1 + (x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0))", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "y - (↑z 0 + x) =\n  ↑z 0 ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) +\n    (y ^ Nat.rawCast 1 * Nat.rawCast 1 + (x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0))", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "HAdd.hAdd = HAdd.hAdd", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsNat (Nat.rawCast 1) 1", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsInt (Nat.rawCast 1) (Int.ofNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsInt (Int.rawCast (Int.negOfNat 1)) (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Int.ofNat 0 = Int.ofNat 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsInt (Nat.rawCast 1 + Int.rawCast (Int.negOfNat 1)) (Int.ofNat 0)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsNat (Nat.rawCast 1 + Int.rawCast (Int.negOfNat 1)) 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsNat (↑z 0 ^ Nat.rawCast 1 * Nat.rawCast 1 + ↑z 0 ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1))\n  0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "HAdd.hAdd = HAdd.hAdd", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsInt (Int.rawCast (Int.negOfNat 1)) (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsNat (Nat.rawCast 1) 1", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsInt (Nat.rawCast 1) (Int.ofNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Int.ofNat 0 = Int.ofNat 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsInt (Int.rawCast (Int.negOfNat 1) + Nat.rawCast 1) (Int.ofNat 0)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsNat (Int.rawCast (Int.negOfNat 1) + Nat.rawCast 1) 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsNat (y ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + y ^ Nat.rawCast 1 * Nat.rawCast 1) 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "HAdd.hAdd = HAdd.hAdd", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsNat (Nat.rawCast 1) 1", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsInt (Nat.rawCast 1) (Int.ofNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsInt (Int.rawCast (Int.negOfNat 1)) (Int.negOfNat 1)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Int.ofNat 0 = Int.ofNat 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsInt (Nat.rawCast 1 + Int.rawCast (Int.negOfNat 1)) (Int.ofNat 0)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsNat (Nat.rawCast 1 + Int.rawCast (Int.negOfNat 1)) 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsNat (x ^ Nat.rawCast 1 * Nat.rawCast 1 + x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1)) 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "0 + 0 = 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0 + (x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0) = 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "y ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0) +\n    (y ^ Nat.rawCast 1 * Nat.rawCast 1 + (x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0)) =\n  0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "↑z 0 ^ Nat.rawCast 1 * Nat.rawCast 1 +\n      (y ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)) +\n    (↑z 0 ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) +\n      (y ^ Nat.rawCast 1 * Nat.rawCast 1 + (x ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0))) =\n  0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "↑z 0 - (y - x) + (y - (↑z 0 + x)) = 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "↑0 = 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "Mathlib.Meta.NormNum.IsNat 0 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "0 = 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "↑z 0 - (y - x) + (y - (↑z 0 + x)) = 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "(↑z 0 - (y - x) + (y - (↑z 0 + x)) < 0) = (↑z 0 - (y - x) + (y - (↑z 0 + x)) < 0)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "(↑z 0 - (y - x) + (y - (↑z 0 + x)) < 0) = (0 < 0)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "↑z 0 - (y - x) < 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "y - (↑z 0 + x) ≤ 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "↑z 0 - (y - x) + (y - (↑z 0 + x)) < 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "0 < 0", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)", "(a : ↑z 0 + x ≥ y)"]}, {"prop": "∀ (a : ↑z 0 + x ≥ y), False", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)"]}, {"prop": "↑z 0 + x < y", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]", "⦃z : EuclideanHalfSpace 1⦄", "(hz : ↑z 0 < y - x)"]}, {"prop": "∀ ⦃z : EuclideanHalfSpace 1⦄ (hz : ↑z 0 < y - x), (↑z 0 + x < y) ∨ (y < y)", "context": ["(x : ℝ)", "(y : ℝ)", "[Fact (x < y)]"]}], "ids": ["Eq.mpr", "id", "forall_congr", "implies_congr", "Eq.refl", "Mathlib.Geometry.Manifold.Instances.Real._auxLemma.7", "Or.inl", "lt_of_not_ge", "Linarith.lt_irrefl", "Eq.mp", "Eq.refl", "HMul.hMul", "Int.negOfNat", "Eq.refl", "Int.negOfNat", "Int.negOfNat", "Eq.refl", "HMul.hMul", "Int.negOfNat", "Eq.refl", "Int.negOfNat", "Eq.refl", "HMul.hMul", "Int.negOfNat", "Int.negOfNat", "Eq.refl", "Int.ofNat", "Int.negOfNat", "Eq.refl", "HMul.hMul", "Int.negOfNat", "Eq.refl", "Int.negOfNat", "Eq.refl", "HMul.hMul", "Int.negOfNat", "Eq.refl", "Int.negOfNat", "Int.negOfNat", "Int.negOfNat", "Eq.refl", "HAdd.hAdd", "Int.negOfNat", "Eq.refl", "Int.ofNat", "Eq.refl", "HAdd.hAdd", "Int.negOfNat", "Eq.refl", "Int.ofNat", "Eq.refl", "HAdd.hAdd", "Int.negOfNat", "Eq.refl", "Int.ofNat", "Nat.cast_zero", "Eq.refl", "add_lt_of_neg_of_le", "sub_neg_of_lt", "sub_nonpos_of_le"], "idString": "Eq.mpr; id; forall_congr; implies_congr; Eq.refl; Mathlib.Geometry.Manifold.Instances.Real._auxLemma.7; Or.inl; lt_of_not_ge; Linarith.lt_irrefl; Eq.mp; Eq.refl; HMul.hMul; Int.negOfNat; Eq.refl; Int.negOfNat; Int.negOfNat; Eq.refl; HMul.hMul; Int.negOfNat; Eq.refl; Int.negOfNat; Eq.refl; HMul.hMul; Int.negOfNat; Int.negOfNat; Eq.refl; Int.ofNat; Int.negOfNat; Eq.refl; HMul.hMul; Int.negOfNat; Eq.refl; Int.negOfNat; Eq.refl; HMul.hMul; Int.negOfNat; Eq.refl; Int.negOfNat; Int.negOfNat; Int.negOfNat; Eq.refl; HAdd.hAdd; Int.negOfNat; Eq.refl; Int.ofNat; Eq.refl; HAdd.hAdd; Int.negOfNat; Eq.refl; Int.ofNat; Eq.refl; HAdd.hAdd; Int.negOfNat; Eq.refl; Int.ofNat; Nat.cast_zero; Eq.refl; add_lt_of_neg_of_le; sub_neg_of_lt; sub_nonpos_of_le; ", "context": []}
{"typeGroup": "(∀ {R : Type u_1} [inst : TopologicalSpace R] [inst_1 : Ring R] [inst_2 : TopologicalRing R] (I : Ideal R) (c : R)\n    (x : R)\n    (hx :\n      x ∈\n        AddSubsemigroup.carrier\n          (AddSubmonoid.toAddSubsemigroup\n            {\n              toAddSubsemigroup :=\n                (({ carrier := ((closure ↑I)),\n                  add_mem' :=\n                    (((fun {a : R} ↦\n                      (_ :\n                        ∀ {b : R}\n                          (a_1 :\n                            a ∈\n                              AddSubsemigroup.carrier\n                                (AddSubmonoid.toAddSubsemigroup\n                                  (AddSubmonoid.topologicalClosure (Submodule.toAddSubmonoid I))))\n                          (a_2 :\n                            b ∈\n                              AddSubsemigroup.carrier\n                                (AddSubmonoid.toAddSubsemigroup\n                                  (AddSubmonoid.topologicalClosure (Submodule.toAddSubmonoid I)))),\n                          a + b ∈\n                            AddSubsemigroup.carrier\n                              (AddSubmonoid.toAddSubsemigroup\n                                (AddSubmonoid.topologicalClosure\n                                  (Submodule.toAddSubmonoid\n                                    I))))=:∀ {a : R} {b : R}\n                        (a_1 :\n                          a ∈\n                            AddSubsemigroup.carrier\n                              (AddSubmonoid.toAddSubsemigroup\n                                (AddSubmonoid.topologicalClosure (Submodule.toAddSubmonoid I))))\n                        (a_2 :\n                          b ∈\n                            AddSubsemigroup.carrier\n                              (AddSubmonoid.toAddSubsemigroup\n                                (AddSubmonoid.topologicalClosure (Submodule.toAddSubmonoid I)))),\n                        a + b ∈\n                          AddSubsemigroup.carrier\n                            (AddSubmonoid.toAddSubsemigroup\n                              (AddSubmonoid.topologicalClosure (Submodule.toAddSubmonoid I)))))) })),\n              zero_mem' :=\n                (((AddSubmonoid.zero_mem'\n                    (AddSubmonoid.topologicalClosure\n                      (Submodule.toAddSubmonoid\n                        I))=:0 ∈\n                    AddSubsemigroup.carrier\n                      (AddSubmonoid.toAddSubsemigroup\n                        (AddSubmonoid.topologicalClosure (Submodule.toAddSubmonoid I)))))) })),\n    c • x ∈ closure ↑I :\n  Prop)", "type": "∀ {R : Type u_1} [inst : TopologicalSpace R] [inst_1 : Ring R] [inst_2 : TopologicalRing R] (I : Ideal R) (c : R)\n  (x : R)\n  (hx :\n    x ∈\n      AddSubsemigroup.carrier\n        (AddSubmonoid.toAddSubsemigroup\n          {\n            toAddSubsemigroup :=\n              (({ carrier := ((closure ↑I)),\n                add_mem' :=\n                  (((fun {a : R} {b : R} ↦\n                    AddSubsemigroup.add_mem'\n                      (AddSubmonoid.toAddSubsemigroup\n                        (AddSubmonoid.topologicalClosure (Submodule.toAddSubmonoid I)))))) })),\n            zero_mem' :=\n              (((AddSubmonoid.zero_mem' (AddSubmonoid.topologicalClosure (Submodule.toAddSubmonoid I))))) })),\n  c • x ∈ closure ↑I", "thm": " : ∀ {R : Type u_1} [inst : TopologicalSpace R] [inst_1 : Ring R] [inst_2 : TopologicalRing R] (I : Ideal R) (c : R)\n  (x : R)\n  (hx :\n    x ∈\n      AddSubsemigroup.carrier\n        (AddSubmonoid.toAddSubsemigroup\n          {\n            toAddSubsemigroup :=\n              (({ carrier := ((closure ↑I)),\n                add_mem' :=\n                  (((fun {a : R} {b : R} ↦\n                    AddSubsemigroup.add_mem'\n                      (AddSubmonoid.toAddSubsemigroup\n                        (AddSubmonoid.topologicalClosure (Submodule.toAddSubmonoid I)))))) })),\n            zero_mem' :=\n              (((AddSubmonoid.zero_mem' (AddSubmonoid.topologicalClosure (Submodule.toAddSubmonoid I))))) })),\n  c • x ∈ closure ↑I", "terms": [], "namedLemmas": ["∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set α} {t : Set β}\n  {f : α → β} {a : α}, Continuous f → a ∈ closure s → Set.MapsTo f s t → f a ∈ closure t", "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : NonUnitalNonAssocRing α] [inst_2 : TopologicalRing α] (x : α),\n  Continuous ↑(AddMonoidHom.mulLeft x)", "∀ {α : Type u} [inst : Semiring α] (I : Ideal α) (a : α) {b : α}, b ∈ I → a * b ∈ I"], "lemmas": [{"prop": "Continuous ↑(AddMonoidHom.mulLeft c)", "context": ["{R : Type u_1}", "[TopologicalSpace R]", "[Ring R]", "[TopologicalRing R]", "(I : Ideal R)", "(c : R)", "(x : R)", "(hx : x ∈\n  AddSubsemigroup.carrier\n    (AddSubmonoid.toAddSubsemigroup\n      {\n        toAddSubsemigroup :=\n          (({ carrier := ((closure ↑I)),\n            add_mem' :=\n              (((fun {a : R} {b : R} ↦\n                AddSubsemigroup.add_mem'\n                  (AddSubmonoid.toAddSubsemigroup\n                    (AddSubmonoid.topologicalClosure (Submodule.toAddSubmonoid I)))))) })),\n        zero_mem' := (((AddSubmonoid.zero_mem' (AddSubmonoid.topologicalClosure (Submodule.toAddSubmonoid I))))) }))"]}, {"prop": "∀ (x : R) (a : x ∈ I), c * x ∈ I", "context": ["{R : Type u_1}", "[TopologicalSpace R]", "[Ring R]", "[TopologicalRing R]", "(I : Ideal R)", "(c : R)", "(x : R)", "(hx : x ∈\n  AddSubsemigroup.carrier\n    (AddSubmonoid.toAddSubsemigroup\n      {\n        toAddSubsemigroup :=\n          (({ carrier := ((closure ↑I)),\n            add_mem' :=\n              (((fun {a : R} {b : R} ↦\n                AddSubsemigroup.add_mem'\n                  (AddSubmonoid.toAddSubsemigroup\n                    (AddSubmonoid.topologicalClosure (Submodule.toAddSubmonoid I)))))) })),\n        zero_mem' := (((AddSubmonoid.zero_mem' (AddSubmonoid.topologicalClosure (Submodule.toAddSubmonoid I))))) }))"]}], "ids": ["map_mem_closure", "mulLeft_continuous", "Ideal.mul_mem_left"], "idString": "map_mem_closure; mulLeft_continuous; Ideal.mul_mem_left; ", "context": []}
{"typeGroup": "(∀ {R : Type u_1} [inst : CommRing R] {c₁ : R} {c₂ : R} (r : R) (v : R × R),\n    AddHom.toFun\n        { toFun := ((fun (v : R × R) ↦ { re := ((0)), imI := ((Prod.fst v)), imJ := ((Prod.snd v)), imK := ((0)) })),\n          map_add' :=\n            (((fun (v₁ : R × R) ↦\n              (_ :\n                ∀ (v₂ : R × R),\n                  { re := ((0)), imI := ((Prod.fst v₁ + Prod.fst v₂)), imJ := ((Prod.snd v₁ + Prod.snd v₂)),\n                      imK := ((0)) } =\n                    { re := ((0 + 0)), imI := ((Prod.fst v₁ + Prod.fst v₂)), imJ := ((Prod.snd v₁ + Prod.snd v₂)),\n                      imK :=\n                        ((0 +\n                          0)) })=:∀ (v₁ : R × R) (v₂ : R × R),\n                { re := ((0)), imI := ((Prod.fst v₁ + Prod.fst v₂)), imJ := ((Prod.snd v₁ + Prod.snd v₂)),\n                    imK := ((0)) } =\n                  { re := ((0 + 0)), imI := ((Prod.fst v₁ + Prod.fst v₂)), imJ := ((Prod.snd v₁ + Prod.snd v₂)),\n                    imK := ((0 + 0)) }))) }\n        (r • v) =\n      ↑(RingHom.id R) r •\n        AddHom.toFun\n          { toFun := ((fun (v : R × R) ↦ { re := ((0)), imI := ((Prod.fst v)), imJ := ((Prod.snd v)), imK := ((0)) })),\n            map_add' :=\n              (((fun (v₁ : R × R) ↦\n                (_ :\n                  ∀ (v₂ : R × R),\n                    { re := ((0)), imI := ((Prod.fst v₁ + Prod.fst v₂)), imJ := ((Prod.snd v₁ + Prod.snd v₂)),\n                        imK := ((0)) } =\n                      { re := ((0 + 0)), imI := ((Prod.fst v₁ + Prod.fst v₂)), imJ := ((Prod.snd v₁ + Prod.snd v₂)),\n                        imK :=\n                          ((0 +\n                            0)) })=:∀ (v₁ : R × R) (v₂ : R × R),\n                  { re := ((0)), imI := ((Prod.fst v₁ + Prod.fst v₂)), imJ := ((Prod.snd v₁ + Prod.snd v₂)),\n                      imK := ((0)) } =\n                    { re := ((0 + 0)), imI := ((Prod.fst v₁ + Prod.fst v₂)), imJ := ((Prod.snd v₁ + Prod.snd v₂)),\n                      imK := ((0 + 0)) }))) }\n          v :\n  Prop)", "type": "∀ {R : Type u_1} [inst : CommRing R] {c₁ : R} {c₂ : R} (r : R) (v : R × R),\n  AddHom.toFun\n      { toFun := ((fun (v : R × R) ↦ { re := ((0)), imI := ((Prod.fst v)), imJ := ((Prod.snd v)), imK := ((0)) })),\n        map_add' :=\n          (((fun (v₁ : R × R) (v₂ : R × R) ↦\n            of_eq_true\n              (Eq.trans\n                (congrArg\n                  (Eq\n                    { re := ((0)), imI := ((Prod.fst v₁ + Prod.fst v₂)), imJ := ((Prod.snd v₁ + Prod.snd v₂)),\n                      imK := ((0)) })\n                  (congr\n                    (congrFun (congrFun (congrArg QuaternionAlgebra.mk (add_zero 0)) (Prod.fst v₁ + Prod.fst v₂))\n                      (Prod.snd v₁ + Prod.snd v₂))\n                    (add_zero 0)))\n                (eq_self\n                  { re := ((0)), imI := ((Prod.fst v₁ + Prod.fst v₂)), imJ := ((Prod.snd v₁ + Prod.snd v₂)),\n                    imK := ((0)) }))))) }\n      (r • v) =\n    ↑(RingHom.id R) r •\n      AddHom.toFun\n        { toFun := ((fun (v : R × R) ↦ { re := ((0)), imI := ((Prod.fst v)), imJ := ((Prod.snd v)), imK := ((0)) })),\n          map_add' :=\n            (((fun (v₁ : R × R) (v₂ : R × R) ↦\n              of_eq_true\n                (Eq.trans\n                  (congrArg\n                    (Eq\n                      { re := ((0)), imI := ((Prod.fst v₁ + Prod.fst v₂)), imJ := ((Prod.snd v₁ + Prod.snd v₂)),\n                        imK := ((0)) })\n                    (congr\n                      (congrFun (congrFun (congrArg QuaternionAlgebra.mk (add_zero 0)) (Prod.fst v₁ + Prod.fst v₂))\n                        (Prod.snd v₁ + Prod.snd v₂))\n                      (add_zero 0)))\n                  (eq_self\n                    { re := ((0)), imI := ((Prod.fst v₁ + Prod.fst v₂)), imJ := ((Prod.snd v₁ + Prod.snd v₂)),\n                      imK := ((0)) }))))) }\n        v", "thm": " : ∀ {R : Type u_1} [inst : CommRing R] {c₁ : R} {c₂ : R} (r : R) (v : R × R),\n  AddHom.toFun\n      { toFun := ((fun (v : R × R) ↦ { re := ((0)), imI := ((Prod.fst v)), imJ := ((Prod.snd v)), imK := ((0)) })),\n        map_add' :=\n          (((fun (v₁ : R × R) (v₂ : R × R) ↦\n            of_eq_true\n              (Eq.trans\n                (congrArg\n                  (Eq\n                    { re := ((0)), imI := ((Prod.fst v₁ + Prod.fst v₂)), imJ := ((Prod.snd v₁ + Prod.snd v₂)),\n                      imK := ((0)) })\n                  (congr\n                    (congrFun (congrFun (congrArg QuaternionAlgebra.mk (add_zero 0)) (Prod.fst v₁ + Prod.fst v₂))\n                      (Prod.snd v₁ + Prod.snd v₂))\n                    (add_zero 0)))\n                (eq_self\n                  { re := ((0)), imI := ((Prod.fst v₁ + Prod.fst v₂)), imJ := ((Prod.snd v₁ + Prod.snd v₂)),\n                    imK := ((0)) }))))) }\n      (r • v) =\n    ↑(RingHom.id R) r •\n      AddHom.toFun\n        { toFun := ((fun (v : R × R) ↦ { re := ((0)), imI := ((Prod.fst v)), imJ := ((Prod.snd v)), imK := ((0)) })),\n          map_add' :=\n            (((fun (v₁ : R × R) (v₂ : R × R) ↦\n              of_eq_true\n                (Eq.trans\n                  (congrArg\n                    (Eq\n                      { re := ((0)), imI := ((Prod.fst v₁ + Prod.fst v₂)), imJ := ((Prod.snd v₁ + Prod.snd v₂)),\n                        imK := ((0)) })\n                    (congr\n                      (congrFun (congrFun (congrArg QuaternionAlgebra.mk (add_zero 0)) (Prod.fst v₁ + Prod.fst v₂))\n                        (Prod.snd v₁ + Prod.snd v₂))\n                      (add_zero 0)))\n                  (eq_self\n                    { re := ((0)), imI := ((Prod.fst v₁ + Prod.fst v₂)), imJ := ((Prod.snd v₁ + Prod.snd v₂)),\n                      imK := ((0)) }))))) }\n        v", "terms": [{"value": "r • v", "isProp": false, "context": ["{R : Type u_1}", "[CommRing R]", "{c₁ : R}", "{c₂ : R}", "(r : R)", "(v : R × R)"]}], "namedLemmas": ["∀ {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀), a * 0 = 0"], "lemmas": [{"prop": "r * 0 = 0", "context": ["{R : Type u_1}", "[CommRing R]", "{c₁ : R}", "{c₂ : R}", "(r : R)", "(v : R × R)"]}, {"prop": "({ re := ((0)), imI := ((Prod.fst (r • v))), imJ := ((Prod.snd (r • v))), imK := ((0)) } =\n    { re := ((r * 0)), imI := ((r * Prod.fst v)), imJ := ((r * Prod.snd v)), imK := ((r * 0)) }) =\n  ({ re := ((0)), imI := ((Prod.fst (r • v))), imJ := ((Prod.snd (r • v))), imK := ((0)) } =\n    { re := ((r * 0)), imI := ((r * Prod.fst v)), imJ := ((r * Prod.snd v)), imK := ((r * 0)) })", "context": ["{R : Type u_1}", "[CommRing R]", "{c₁ : R}", "{c₂ : R}", "(r : R)", "(v : R × R)"]}, {"prop": "({ re := ((0)), imI := ((Prod.fst (r • v))), imJ := ((Prod.snd (r • v))), imK := ((0)) } =\n    { re := ((r * 0)), imI := ((r * Prod.fst v)), imJ := ((r * Prod.snd v)), imK := ((r * 0)) }) =\n  ({ re := ((0)), imI := ((Prod.fst (r • v))), imJ := ((Prod.snd (r • v))), imK := ((0)) } =\n    { re := ((0)), imI := ((r * Prod.fst v)), imJ := ((r * Prod.snd v)), imK := ((0)) })", "context": ["{R : Type u_1}", "[CommRing R]", "{c₁ : R}", "{c₂ : R}", "(r : R)", "(v : R × R)"]}, {"prop": "({ re := ((0)), imI := ((Prod.fst (r • v))), imJ := ((Prod.snd (r • v))), imK := ((0)) } =\n    { re := ((r * 0)), imI := ((r * Prod.fst v)), imJ := ((r * Prod.snd v)), imK := ((r * 0)) }) =\n  ({ re := ((0)), imI := ((Prod.fst (r • v))), imJ := ((Prod.snd (r • v))), imK := ((0)) } =\n    { re := ((0)), imI := ((r * Prod.fst v)), imJ := ((r * Prod.snd v)), imK := ((0)) })", "context": ["{R : Type u_1}", "[CommRing R]", "{c₁ : R}", "{c₂ : R}", "(r : R)", "(v : R × R)"]}, {"prop": "{ re := ((0)), imI := ((Prod.fst (r • v))), imJ := ((Prod.snd (r • v))), imK := ((0)) } =\n  { re := ((0)), imI := ((Prod.fst (r • v))), imJ := ((Prod.snd (r • v))), imK := ((0)) }", "context": ["{R : Type u_1}", "[CommRing R]", "{c₁ : R}", "{c₂ : R}", "(r : R)", "(v : R × R)"]}, {"prop": "{ re := ((0)), imI := ((Prod.fst (r • v))), imJ := ((Prod.snd (r • v))), imK := ((0)) } =\n  { re := ((r * 0)), imI := ((r * Prod.fst v)), imJ := ((r * Prod.snd v)), imK := ((r * 0)) }", "context": ["{R : Type u_1}", "[CommRing R]", "{c₁ : R}", "{c₂ : R}", "(r : R)", "(v : R × R)"]}], "ids": ["id", "Eq.mpr", "id", "mul_zero", "Eq.refl", "re", "imI", "Prod.fst", "imJ", "Prod.snd", "imK", "re", "imI", "Prod.fst", "imJ", "Prod.snd", "imK", "Eq.refl", "re", "imI", "Prod.fst", "imJ", "Prod.snd", "imK"], "idString": "id; Eq.mpr; id; mul_zero; Eq.refl; re; imI; Prod.fst; imJ; Prod.snd; imK; re; imI; Prod.fst; imJ; Prod.snd; imK; Eq.refl; re; imI; Prod.fst; imJ; Prod.snd; imK; ", "context": []}
{"typeGroup": "(∀ {α : Type u_1} {β : Type u_2} (s : Set (α × β)) (x : ↑s),\n    (fun (x : (x : α) × ↑{y : β | (x, y) ∈ s}) ↦\n          { val := (((Sigma.fst x, ↑(Sigma.snd x)))),\n            property := (((Subtype.property (Sigma.snd x)=:↑(Sigma.snd x) ∈ {y : β | (Sigma.fst x, y) ∈ s}))) })\n        ((fun (x : ↑s) ↦\n            { fst := ((Prod.fst ↑x)),\n              snd :=\n                (({ val := ((Prod.snd ↑x)),\n                  property :=\n                    (((of_eq_true\n                        (Eq.trans\n                            (congrFun\n                                (congrArg Membership.mem\n                                    (Prod.mk.eta=:(Prod.fst ↑x, Prod.snd ↑x) =\n                                        ↑x)=:Membership.mem (Prod.fst ↑x, Prod.snd ↑x) = Membership.mem ↑x)\n                                s=:((Prod.fst ↑x, Prod.snd ↑x) ∈ s : Prop) = (↑x ∈ s : Prop))\n                            (Mathlib.Data.Subtype._auxLemma.5\n                                x=:(↑x ∈ s : Prop) =\n                                (True :\n                                  Prop))=:((Prod.fst ↑x, Prod.snd ↑x) ∈ s : Prop) =\n                            (True : Prop))=:(Prod.fst ↑x, Prod.snd ↑x) ∈ s))) })) })\n          x) =\n      x :\n  Prop)", "type": "∀ {α : Type u_1} {β : Type u_2} (s : Set (α × β)) (x : ↑s),\n  (fun (x : (x : α) × ↑{y : β | (x, y) ∈ s}) ↦\n        { val := (((Sigma.fst x, ↑(Sigma.snd x)))), property := (((Subtype.property (Sigma.snd x)))) })\n      ((fun (x : ↑s) ↦\n          { fst := ((Prod.fst ↑x)),\n            snd :=\n              (({ val := ((Prod.snd ↑x)),\n                property :=\n                  (((of_eq_true\n                    (Eq.trans (congrFun (congrArg Membership.mem Prod.mk.eta) s)\n                      (Mathlib.Data.Subtype._auxLemma.5 x))))) })) })\n        x) =\n    x", "thm": " : ∀ {α : Type u_1} {β : Type u_2} (s : Set (α × β)) (x : ↑s),\n  (fun (x : (x : α) × ↑{y : β | (x, y) ∈ s}) ↦\n        { val := (((Sigma.fst x, ↑(Sigma.snd x)))), property := (((Subtype.property (Sigma.snd x)))) })\n      ((fun (x : ↑s) ↦\n          { fst := ((Prod.fst ↑x)),\n            snd :=\n              (({ val := ((Prod.snd ↑x)),\n                property :=\n                  (((of_eq_true\n                    (Eq.trans (congrFun (congrArg Membership.mem Prod.mk.eta) s)\n                      (Mathlib.Data.Subtype._auxLemma.5 x))))) })) })\n        x) =\n    x", "terms": [{"value": "Sigma.snd x", "isProp": false, "context": ["{α : Type u_1}", "{β : Type u_2}", "(s : Set (α × β))", "(x : ↑s)", "(x : ↑s)", "(x : (x : α) × ↑{y : β | (x, y) ∈ s})"]}, {"value": "↑x", "isProp": false, "context": ["{α : Type u_1}", "{β : Type u_2}", "(s : Set (α × β))", "(x : ↑s)", "(x : ↑s)", "(x : ↑s)"]}, {"value": "(fun (x : ↑s) ↦\n    { fst := ((Prod.fst ↑x)),\n      snd :=\n        (({ val := ((Prod.snd ↑x)),\n          property :=\n            (((of_eq_true\n              (Eq.trans (congrFun (congrArg Membership.mem Prod.mk.eta) s)\n                (Mathlib.Data.Subtype._auxLemma.5 x))))) })) })\n  x", "isProp": false, "context": ["{α : Type u_1}", "{β : Type u_2}", "(s : Set (α × β))", "(x : ↑s)", "(x : ↑s)"]}], "namedLemmas": ["∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self", "∀ {p : Prop}, p = True → p", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Type u_1} {β : Type u_2} {p : α × β}, (p.fst, p.snd) = p", "∀ {α : Sort u} {a : α}, a = a"], "lemmas": [{"prop": "↑(Sigma.snd x) ∈ {y : β | (Sigma.fst x, y) ∈ s}", "context": ["{α : Type u_1}", "{β : Type u_2}", "(s : Set (α × β))", "(x : ↑s)", "(x : ↑s)", "(x : (x : α) × ↑{y : β | (x, y) ∈ s})"]}, {"prop": "(Prod.fst ↑x, Prod.snd ↑x) = ↑x", "context": ["{α : Type u_1}", "{β : Type u_2}", "(s : Set (α × β))", "(x : ↑s)", "(x : ↑s)", "(x : ↑s)"]}, {"prop": "Membership.mem (Prod.fst ↑x, Prod.snd ↑x) = Membership.mem ↑x", "context": ["{α : Type u_1}", "{β : Type u_2}", "(s : Set (α × β))", "(x : ↑s)", "(x : ↑s)", "(x : ↑s)"]}, {"prop": "((Prod.fst ↑x, Prod.snd ↑x) ∈ s) = (↑x ∈ s)", "context": ["{α : Type u_1}", "{β : Type u_2}", "(s : Set (α × β))", "(x : ↑s)", "(x : ↑s)", "(x : ↑s)"]}, {"prop": "(↑x ∈ s) = True", "context": ["{α : Type u_1}", "{β : Type u_2}", "(s : Set (α × β))", "(x : ↑s)", "(x : ↑s)", "(x : ↑s)"]}, {"prop": "((Prod.fst ↑x, Prod.snd ↑x) ∈ s) = True", "context": ["{α : Type u_1}", "{β : Type u_2}", "(s : Set (α × β))", "(x : ↑s)", "(x : ↑s)", "(x : ↑s)"]}, {"prop": "(Prod.fst ↑x, Prod.snd ↑x) ∈ s", "context": ["{α : Type u_1}", "{β : Type u_2}", "(s : Set (α × β))", "(x : ↑s)", "(x : ↑s)", "(x : ↑s)"]}, {"prop": "∀ (x : α) (y : β) (h : (x, y) ∈ s),\n  (fun (x : (x : α) × ↑{y : β | (x, y) ∈ s}) ↦\n        { val := (((Sigma.fst x, ↑(Sigma.snd x)))), property := (((Subtype.property (Sigma.snd x)))) })\n      ((fun (x : ↑s) ↦\n          { fst := ((Prod.fst ↑x)),\n            snd :=\n              (({ val := ((Prod.snd ↑x)),\n                property :=\n                  (((of_eq_true\n                    (Eq.trans (congrFun (congrArg Membership.mem Prod.mk.eta) s)\n                      (Mathlib.Data.Subtype._auxLemma.5 x))))) })) })\n        { val := (((x, y))), property := ((h)) }) =\n    (fun (x : (x : α) × ↑{y : β | (x, y) ∈ s}) ↦\n        { val := (((Sigma.fst x, ↑(Sigma.snd x)))), property := (((Subtype.property (Sigma.snd x)))) })\n      ((fun (x : ↑s) ↦\n          { fst := ((Prod.fst ↑x)),\n            snd :=\n              (({ val := ((Prod.snd ↑x)),\n                property :=\n                  (((of_eq_true\n                    (Eq.trans (congrFun (congrArg Membership.mem Prod.mk.eta) s)\n                      (Mathlib.Data.Subtype._auxLemma.5 x))))) })) })\n        { val := (((x, y))), property := ((h)) })", "context": ["{α : Type u_1}", "{β : Type u_2}", "(s : Set (α × β))", "(x : ↑s)"]}], "ids": ["Equiv.setProdEquivSigma.match_1", "val", "Sigma.fst", "Sigma.snd", "property", "Subtype.property", "Sigma.snd", "fst", "Prod.fst", "snd", "val", "Prod.snd", "property", "of_eq_true", "Eq.trans", "congrFun", "congrArg", "Membership.mem", "Prod.mk.eta", "Mathlib.Data.Subtype._auxLemma.5", "rfl"], "idString": "Equiv.setProdEquivSigma.match_1; val; Sigma.fst; Sigma.snd; property; Subtype.property; Sigma.snd; fst; Prod.fst; snd; val; Prod.snd; property; of_eq_true; Eq.trans; congrFun; congrArg; Membership.mem; Prod.mk.eta; Mathlib.Data.Subtype._auxLemma.5; rfl; ", "context": []}
{"typeGroup": "(∀ {K : Type u_1} {Γ : (a : K) → Type u_2} (L : Turing.ListBlank ((k : K) → Option (Γ k))),\n    Turing.ListBlank.map\n        { f := ((Prod.snd)), map_pt' := (((Eq.refl (Prod.snd default)=:Prod.snd default = Prod.snd default))) }\n        (Turing.TM2to1.addBottom L) =\n      L :\n  Prop)", "type": "∀ {K : Type u_1} {Γ : (a : K) → Type u_2} (L : Turing.ListBlank ((k : K) → Option (Γ k))),\n  Turing.ListBlank.map { f := ((Prod.snd)), map_pt' := (((Eq.refl (Prod.snd default)))) } (Turing.TM2to1.addBottom L) =\n    L", "thm": " : ∀ {K : Type u_1} {Γ : (a : K) → Type u_2} (L : Turing.ListBlank ((k : K) → Option (Γ k))),\n  Turing.ListBlank.map { f := ((Prod.snd)), map_pt' := (((Eq.refl (Prod.snd default)))) } (Turing.TM2to1.addBottom L) =\n    L", "terms": [{"value": "{ f := ((Prod.snd)), map_pt' := (((Eq.refl (Prod.snd default)))) }", "isProp": false, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"value": "{ f := ((Prod.mk false)), map_pt' := ((Turing.TM2to1.addBottom.proof_1)) }", "isProp": false, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"value": "Turing.ListBlank.tail L", "isProp": false, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"value": "Turing.ListBlank.map { f := ((Prod.mk false)), map_pt' := ((Turing.TM2to1.addBottom.proof_1)) }\n  (Turing.ListBlank.tail L)", "isProp": false, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"value": "(true, Turing.ListBlank.head L)", "isProp": false, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"value": "(a = a_1)", "isProp": true, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(α : Type (max u_1 u_2))", "(a : α)", "(a' : α)", "(e'_2 : a = a')", "(a_1 : α)", "(a_2 : α)", "(x : a = a_2)"]}, {"value": "(a' = a_1)", "isProp": true, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(α : Type (max u_1 u_2))", "(a : α)", "(a' : α)", "(e'_2 : a = a')", "(a_1 : α)", "(a_2 : α)", "(x : a = a_2)"]}, {"value": "(a = a_1)", "isProp": true, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(α : Type (max u_1 u_2))", "(a : α)", "(a' : α)", "(e'_2 : a = a')", "(a_1 : α)", "(h : a' = a)", "(a' : α)"]}, {"value": "(a' = a_1)", "isProp": true, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(α : Type (max u_1 u_2))", "(a : α)", "(a' : α)", "(e'_2 : a = a')", "(a_1 : α)", "(h : a' = a)", "(a' : α)"]}, {"value": "(a = a_1)", "isProp": true, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(α : Type (max u_1 u_2))", "(a : α)", "(a' : α)", "(e'_2 : a = a')", "(a_1 : α)", "(h : a' = a)", "(e_2 : a = a)", "(h : HEq e_2 (Eq.refl a))"]}, {"value": "Γ k", "isProp": false, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"value": "(k : K) → Option (Γ k)", "isProp": false, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"value": "Turing.ListBlank ((k : K) → Option (Γ k))", "isProp": false, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"value": "Turing.ListBlank.head L", "isProp": false, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"value": "Turing.ListBlank.map { f := ((Prod.snd)), map_pt' := (((Eq.refl (Prod.snd default)))) }\n  (Turing.ListBlank.map { f := ((Prod.mk false)), map_pt' := ((Turing.TM2to1.addBottom.proof_1)) }\n    (Turing.ListBlank.tail L))", "isProp": false, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"value": "Turing.ListBlank.cons (Turing.ListBlank.head L)\n  (Turing.ListBlank.map { f := ((Prod.snd)), map_pt' := (((Eq.refl (Prod.snd default)))) }\n    (Turing.ListBlank.map { f := ((Prod.mk false)), map_pt' := ((Turing.TM2to1.addBottom.proof_1)) }\n      (Turing.ListBlank.tail L)))", "isProp": false, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"value": "Turing.ListBlank.cons (Turing.ListBlank.head L) (Turing.ListBlank.tail L)", "isProp": false, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"value": "Turing.ListBlank.cons a l", "isProp": false, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(Γ : Type (max u_1 u_2))", "(inst : Inhabited Γ)", "(a : Γ)", "(l : Turing.ListBlank Γ)", "(l' : Turing.ListBlank Γ)", "(e'_4 : l = l')", "(a_1 : Turing.ListBlank Γ)", "(x : l = a_1)"]}, {"value": "Turing.ListBlank.cons a l'", "isProp": false, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(Γ : Type (max u_1 u_2))", "(inst : Inhabited Γ)", "(a : Γ)", "(l : Turing.ListBlank Γ)", "(l' : Turing.ListBlank Γ)", "(e'_4 : l = l')", "(a_1 : Turing.ListBlank Γ)", "(x : l = a_1)"]}, {"value": "Turing.ListBlank.cons a l", "isProp": false, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(Γ : Type (max u_1 u_2))", "(inst : Inhabited Γ)", "(a : Γ)", "(l : Turing.ListBlank Γ)", "(l' : Turing.ListBlank Γ)", "(e'_4 : l = l')", "(h : l' = l)", "(l' : Turing.ListBlank Γ)"]}, {"value": "Turing.ListBlank.cons a l'", "isProp": false, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(Γ : Type (max u_1 u_2))", "(inst : Inhabited Γ)", "(a : Γ)", "(l : Turing.ListBlank Γ)", "(l' : Turing.ListBlank Γ)", "(e'_4 : l = l')", "(h : l' = l)", "(l' : Turing.ListBlank Γ)"]}, {"value": "Turing.ListBlank.cons a l", "isProp": false, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(Γ : Type (max u_1 u_2))", "(inst : Inhabited Γ)", "(a : Γ)", "(l : Turing.ListBlank Γ)", "(l' : Turing.ListBlank Γ)", "(e'_4 : l = l')", "(h : l' = l)", "(e_4 : l = l)", "(h : HEq e_4 (Eq.refl l))"]}, {"value": "instInhabitedForAll_1 K", "isProp": false, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"value": "Prod.mk false", "isProp": false, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(l : List ((k : K) → Option (Γ k)))"]}, {"value": "Turing.ListBlank.mk l", "isProp": false, "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(l : List ((k : K) → Option (Γ k)))"]}], "namedLemmas": ["∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {Γ : Type u_1} {Γ' : Type u_2} [inst : Inhabited Γ] [inst_1 : Inhabited Γ'] (f : Turing.PointedMap Γ Γ')\n  (l : Turing.ListBlank Γ) (a : Γ),\n  Turing.ListBlank.map f (Turing.ListBlank.cons a l) =\n    Turing.ListBlank.cons (Turing.PointedMap.f f a) (Turing.ListBlank.map f l)", "∀ {K : Type u_1} {Γ : K → Type u_2}, (false, default) = (false, default)", "∀ {α : Sort u} {a a' : α}, HEq a a' → a = a'", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {α : Sort u} {a a' : α}, HEq a a' → a = a'", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {K : Type u_1} {Γ : K → Type u_2}, (false, default) = (false, default)", "∀ {α : Sort u} {a a' : α}, HEq a a' → a = a'", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {α : Sort u} {a a' : α}, HEq a a' → a = a'", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {K : Type u_1} {Γ : K → Type u_2}, (false, default) = (false, default)", "∀ {Γ : Type u_1} [inst : Inhabited Γ] {p : Turing.ListBlank Γ → Prop} (q : Turing.ListBlank Γ),\n  (∀ (a : List Γ), p (Turing.ListBlank.mk a)) → p q", "∀ {p : Prop}, p = True → p", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {β : Type u_1} {γ : Type u_2} {α : Type u_3} (g : β → γ) (f : α → β) (l : List α),\n  List.map g (List.map f l) = List.map (g ∘ f) l", "∀ {α : Type u_1} (l : List α), List.map id l = l", "∀ {α : Sort u_1} (a : α), (a = a) = True", "∀ {Γ : Type u_1} [inst : Inhabited Γ] (l : Turing.ListBlank Γ),\n  Turing.ListBlank.cons (Turing.ListBlank.head l) (Turing.ListBlank.tail l) = l"], "lemmas": [{"prop": "Prod.snd default = Prod.snd default", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"prop": "(false, default) = (false, default)", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"prop": "Turing.ListBlank.map { f := ((Prod.snd)), map_pt' := (((Eq.refl (Prod.snd default)))) }\n    (Turing.ListBlank.cons (true, Turing.ListBlank.head L)\n      (Turing.ListBlank.map { f := ((Prod.mk false)), map_pt' := ((Turing.TM2to1.addBottom.proof_1)) }\n        (Turing.ListBlank.tail L))) =\n  Turing.ListBlank.cons\n    (Turing.PointedMap.f { f := ((Prod.snd)), map_pt' := (((Eq.refl (Prod.snd default)))) }\n      (true, Turing.ListBlank.head L))\n    (Turing.ListBlank.map { f := ((Prod.snd)), map_pt' := (((Eq.refl (Prod.snd default)))) }\n      (Turing.ListBlank.map { f := ((Prod.mk false)), map_pt' := ((Turing.TM2to1.addBottom.proof_1)) }\n        (Turing.ListBlank.tail L)))", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"prop": "Eq\n    (Turing.ListBlank.map { f := ((Prod.snd)), map_pt' := (((Eq.refl (Prod.snd default)))) }\n      (Turing.ListBlank.cons (true, Turing.ListBlank.head L)\n        (Turing.ListBlank.map { f := ((Prod.mk false)), map_pt' := ((Turing.TM2to1.addBottom.proof_1)) }\n          (Turing.ListBlank.tail L)))) =\n  Eq\n    (Turing.ListBlank.cons\n      (Turing.PointedMap.f { f := ((Prod.snd)), map_pt' := (((Eq.refl (Prod.snd default)))) }\n        (true, Turing.ListBlank.head L))\n      (Turing.ListBlank.map { f := ((Prod.snd)), map_pt' := (((Eq.refl (Prod.snd default)))) }\n        (Turing.ListBlank.map { f := ((Prod.mk false)), map_pt' := ((Turing.TM2to1.addBottom.proof_1)) }\n          (Turing.ListBlank.tail L))))", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"prop": "(Turing.ListBlank.map { f := ((Prod.snd)), map_pt' := (((Eq.refl (Prod.snd default)))) }\n      (Turing.ListBlank.cons (true, Turing.ListBlank.head L)\n        (Turing.ListBlank.map { f := ((Prod.mk false)), map_pt' := ((Turing.TM2to1.addBottom.proof_1)) }\n          (Turing.ListBlank.tail L))) =\n    L) =\n  (Turing.ListBlank.cons\n      (Turing.PointedMap.f { f := ((Prod.snd)), map_pt' := (((Eq.refl (Prod.snd default)))) }\n        (true, Turing.ListBlank.head L))\n      (Turing.ListBlank.map { f := ((Prod.snd)), map_pt' := (((Eq.refl (Prod.snd default)))) }\n        (Turing.ListBlank.map { f := ((Prod.mk false)), map_pt' := ((Turing.TM2to1.addBottom.proof_1)) }\n          (Turing.ListBlank.tail L))) =\n    L)", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"prop": "(Turing.ListBlank.map { f := ((Prod.snd)), map_pt' := (((Eq.refl (Prod.snd default)))) } (Turing.TM2to1.addBottom L) =\n    L) =\n  (Turing.ListBlank.cons (Turing.ListBlank.head L)\n      (Turing.ListBlank.map { f := ((Prod.snd)), map_pt' := (((Eq.refl (Prod.snd default)))) }\n        (Turing.ListBlank.map { f := ((Prod.mk false)), map_pt' := ((Turing.TM2to1.addBottom.proof_1)) }\n          (Turing.ListBlank.tail L))) =\n    L)", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"prop": "a = a", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(α : Type (max u_1 u_2))", "(a : α)", "(a' : α)", "(e'_2 : a = a')", "(a_1 : α)", "(h : a' = a)", "(a' : α)"]}, {"prop": "e_2 = (Eq.refl a)", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(α : Type (max u_1 u_2))", "(a : α)", "(a' : α)", "(e'_2 : a = a')", "(a_1 : α)", "(h : a' = a)", "(e_2 : a = a)", "(h : HEq e_2 (Eq.refl a))"]}, {"prop": "(Eq.refl a) = e_2", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(α : Type (max u_1 u_2))", "(a : α)", "(a' : α)", "(e'_2 : a = a')", "(a_1 : α)", "(h : a' = a)", "(e_2 : a = a)", "(h : HEq e_2 (Eq.refl a))"]}, {"prop": "HEq (a = a_1) (a = a_1)", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(α : Type (max u_1 u_2))", "(a : α)", "(a' : α)", "(e'_2 : a = a')", "(a_1 : α)", "(h : a' = a)", "(e_2 : a = a)", "(h : HEq e_2 (Eq.refl a))"]}, {"prop": "∀ (e_2 : a = a) (h : HEq e_2 (Eq.refl a)), HEq (a = a_1) (a = a_1)", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(α : Type (max u_1 u_2))", "(a : α)", "(a' : α)", "(e'_2 : a = a')", "(a_1 : α)", "(h : a' = a)"]}, {"prop": "a = a'", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(α : Type (max u_1 u_2))", "(a : α)", "(a' : α)", "(e'_2 : a = a')", "(a_1 : α)", "(h : a' = a)"]}, {"prop": "∀ (h : a' = a) (h : HEq e'_2 (Eq.refl a)), HEq (a = a_1) (a' = a_1)", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(α : Type (max u_1 u_2))", "(a : α)", "(a' : α)", "(e'_2 : a = a')", "(a_1 : α)"]}, {"prop": "a' = a'", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(α : Type (max u_1 u_2))", "(a : α)", "(a' : α)", "(e'_2 : a = a')", "(a_1 : α)"]}, {"prop": "HEq e'_2 e'_2", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(α : Type (max u_1 u_2))", "(a : α)", "(a' : α)", "(e'_2 : a = a')", "(a_1 : α)"]}, {"prop": "∀ (α : Type (max u_1 u_2)) (a : α) (a' : α) (e'_2 : a = a') (a_1 : α), HEq (a = a_1) (a' = a_1)", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"prop": "Prod.snd default = Prod.snd default", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"prop": "(false, default) = (false, default)", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"prop": "l = l", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(Γ : Type (max u_1 u_2))", "(inst : Inhabited Γ)", "(a : Γ)", "(l : Turing.ListBlank Γ)", "(l' : Turing.ListBlank Γ)", "(e'_4 : l = l')", "(h : l' = l)", "(l' : Turing.ListBlank Γ)"]}, {"prop": "e_4 = (Eq.refl l)", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(Γ : Type (max u_1 u_2))", "(inst : Inhabited Γ)", "(a : Γ)", "(l : Turing.ListBlank Γ)", "(l' : Turing.ListBlank Γ)", "(e'_4 : l = l')", "(h : l' = l)", "(e_4 : l = l)", "(h : HEq e_4 (Eq.refl l))"]}, {"prop": "(Eq.refl l) = e_4", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(Γ : Type (max u_1 u_2))", "(inst : Inhabited Γ)", "(a : Γ)", "(l : Turing.ListBlank Γ)", "(l' : Turing.ListBlank Γ)", "(e'_4 : l = l')", "(h : l' = l)", "(e_4 : l = l)", "(h : HEq e_4 (Eq.refl l))"]}, {"prop": "HEq (Turing.ListBlank.cons a l) (Turing.ListBlank.cons a l)", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(Γ : Type (max u_1 u_2))", "(inst : Inhabited Γ)", "(a : Γ)", "(l : Turing.ListBlank Γ)", "(l' : Turing.ListBlank Γ)", "(e'_4 : l = l')", "(h : l' = l)", "(e_4 : l = l)", "(h : HEq e_4 (Eq.refl l))"]}, {"prop": "∀ (e_4 : l = l) (h : HEq e_4 (Eq.refl l)), HEq (Turing.ListBlank.cons a l) (Turing.ListBlank.cons a l)", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(Γ : Type (max u_1 u_2))", "(inst : Inhabited Γ)", "(a : Γ)", "(l : Turing.ListBlank Γ)", "(l' : Turing.ListBlank Γ)", "(e'_4 : l = l')", "(h : l' = l)"]}, {"prop": "l = l'", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(Γ : Type (max u_1 u_2))", "(inst : Inhabited Γ)", "(a : Γ)", "(l : Turing.ListBlank Γ)", "(l' : Turing.ListBlank Γ)", "(e'_4 : l = l')", "(h : l' = l)"]}, {"prop": "∀ (h : l' = l) (h : HEq e'_4 (Eq.refl l)), HEq (Turing.ListBlank.cons a l) (Turing.ListBlank.cons a l')", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(Γ : Type (max u_1 u_2))", "(inst : Inhabited Γ)", "(a : Γ)", "(l : Turing.ListBlank Γ)", "(l' : Turing.ListBlank Γ)", "(e'_4 : l = l')"]}, {"prop": "l' = l'", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(Γ : Type (max u_1 u_2))", "(inst : Inhabited Γ)", "(a : Γ)", "(l : Turing.ListBlank Γ)", "(l' : Turing.ListBlank Γ)", "(e'_4 : l = l')"]}, {"prop": "HEq e'_4 e'_4", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(Γ : Type (max u_1 u_2))", "(inst : Inhabited Γ)", "(a : Γ)", "(l : Turing.ListBlank Γ)", "(l' : Turing.ListBlank Γ)", "(e'_4 : l = l')"]}, {"prop": "∀ (Γ : Type (max u_1 u_2)) (inst : Inhabited Γ) (a : Γ) (l : Turing.ListBlank Γ) (l' : Turing.ListBlank Γ)\n  (e'_4 : l = l'), HEq (Turing.ListBlank.cons a l) (Turing.ListBlank.cons a l')", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"prop": "Prod.snd default = Prod.snd default", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"prop": "(false, default) = (false, default)", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"prop": "List.map Prod.snd (List.map (Prod.mk false) l) = List.map (Prod.snd ∘ Prod.mk false) l", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(l : List ((k : K) → Option (Γ k)))"]}, {"prop": "List.map id l = l", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(l : List ((k : K) → Option (Γ k)))"]}, {"prop": "List.map Prod.snd (List.map (Prod.mk false) l) = l", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(l : List ((k : K) → Option (Γ k)))"]}, {"prop": "Turing.ListBlank.mk (List.map Prod.snd (List.map (Prod.mk false) l)) = Turing.ListBlank.mk l", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(l : List ((k : K) → Option (Γ k)))"]}, {"prop": "Eq (Turing.ListBlank.mk (List.map Prod.snd (List.map (Prod.mk false) l))) = Eq (Turing.ListBlank.mk l)", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(l : List ((k : K) → Option (Γ k)))"]}, {"prop": "(Turing.ListBlank.mk (List.map Prod.snd (List.map (Prod.mk false) l)) = Turing.ListBlank.mk l) =\n  (Turing.ListBlank.mk l = Turing.ListBlank.mk l)", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(l : List ((k : K) → Option (Γ k)))"]}, {"prop": "(Turing.ListBlank.mk l = Turing.ListBlank.mk l) = True", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(l : List ((k : K) → Option (Γ k)))"]}, {"prop": "(Turing.ListBlank.mk (List.map Prod.snd (List.map (Prod.mk false) l)) = Turing.ListBlank.mk l) = True", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))", "(l : List ((k : K) → Option (Γ k)))"]}, {"prop": "∀ (l : List ((k : K) → Option (Γ k))),\n  Turing.ListBlank.mk (List.map Prod.snd (List.map (Prod.mk false) l)) = Turing.ListBlank.mk l", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"prop": "Turing.ListBlank.map { f := ((Prod.snd)), map_pt' := (((Eq.refl (Prod.snd default)))) }\n    (Turing.ListBlank.map { f := ((Prod.mk false)), map_pt' := ((Turing.TM2to1.addBottom.proof_1)) }\n      (Turing.ListBlank.tail L)) =\n  Turing.ListBlank.tail L", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"prop": "HEq\n  (Turing.ListBlank.cons (Turing.ListBlank.head L)\n    (Turing.ListBlank.map { f := ((Prod.snd)), map_pt' := (((Eq.refl (Prod.snd default)))) }\n      (Turing.ListBlank.map { f := ((Prod.mk false)), map_pt' := ((Turing.TM2to1.addBottom.proof_1)) }\n        (Turing.ListBlank.tail L))))\n  (Turing.ListBlank.cons (Turing.ListBlank.head L) (Turing.ListBlank.tail L))", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"prop": "Turing.ListBlank.cons (Turing.ListBlank.head L)\n    (Turing.ListBlank.map { f := ((Prod.snd)), map_pt' := (((Eq.refl (Prod.snd default)))) }\n      (Turing.ListBlank.map { f := ((Prod.mk false)), map_pt' := ((Turing.TM2to1.addBottom.proof_1)) }\n        (Turing.ListBlank.tail L))) =\n  Turing.ListBlank.cons (Turing.ListBlank.head L) (Turing.ListBlank.tail L)", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"prop": "HEq\n  (Turing.ListBlank.cons (Turing.ListBlank.head L)\n      (Turing.ListBlank.map { f := ((Prod.snd)), map_pt' := (((Eq.refl (Prod.snd default)))) }\n        (Turing.ListBlank.map { f := ((Prod.mk false)), map_pt' := ((Turing.TM2to1.addBottom.proof_1)) }\n          (Turing.ListBlank.tail L))) =\n    L)\n  (Turing.ListBlank.cons (Turing.ListBlank.head L) (Turing.ListBlank.tail L) = L)", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"prop": "(Turing.ListBlank.cons (Turing.ListBlank.head L)\n      (Turing.ListBlank.map { f := ((Prod.snd)), map_pt' := (((Eq.refl (Prod.snd default)))) }\n        (Turing.ListBlank.map { f := ((Prod.mk false)), map_pt' := ((Turing.TM2to1.addBottom.proof_1)) }\n          (Turing.ListBlank.tail L))) =\n    L) =\n  (Turing.ListBlank.cons (Turing.ListBlank.head L) (Turing.ListBlank.tail L) = L)", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"prop": "Turing.ListBlank.cons (Turing.ListBlank.head L) (Turing.ListBlank.tail L) = L", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}, {"prop": "Turing.ListBlank.cons (Turing.ListBlank.head L)\n    (Turing.ListBlank.map { f := ((Prod.snd)), map_pt' := (((Eq.refl (Prod.snd default)))) }\n      (Turing.ListBlank.map { f := ((Prod.mk false)), map_pt' := ((Turing.TM2to1.addBottom.proof_1)) }\n        (Turing.ListBlank.tail L))) =\n  L", "context": ["{K : Type u_1}", "{Γ : (a : K) → Type u_2}", "(L : Turing.ListBlank ((k : K) → Option (Γ k)))"]}], "ids": ["Eq.mpr", "id", "congrFun", "congrArg", "Eq", "Turing.ListBlank.map_cons", "f", "Prod.snd", "map_pt'", "Eq.refl", "Prod.snd", "default", "Turing.ListBlank.map", "f", "Prod.mk", "false", "map_pt'", "Turing.TM2to1.addBottom.proof_1", "Turing.ListBlank.tail", "true", "Turing.ListBlank.head", "Eq.mpr", "eq_of_heq", "h", "h", "HEq", "HEq", "Eq.ndrec", "e_2", "HEq", "e_2", "Eq.refl", "HEq", "Eq.symm", "eq_of_heq", "HEq.refl", "Eq.symm", "Eq.refl", "HEq.refl", "Turing.ListBlank", "k", "Option", "k", "Turing.ListBlank.cons", "Turing.ListBlank.head", "Turing.ListBlank.map", "f", "Prod.snd", "map_pt'", "Eq.refl", "Prod.snd", "default", "Turing.ListBlank.map", "f", "Prod.mk", "false", "map_pt'", "Turing.TM2to1.addBottom.proof_1", "Turing.ListBlank.tail", "Turing.ListBlank.cons", "Turing.ListBlank.head", "Turing.ListBlank.tail", "eq_of_heq", "h", "h", "HEq", "HEq", "Turing.ListBlank.cons", "Turing.ListBlank.cons", "Eq.ndrec", "e_4", "HEq", "e_4", "Eq.refl", "HEq", "Turing.ListBlank.cons", "Turing.ListBlank.cons", "Eq.symm", "eq_of_heq", "HEq.refl", "Turing.ListBlank.cons", "Eq.symm", "Eq.refl", "HEq.refl", "k", "Option", "k", "instInhabitedForAll_1", "Turing.ListBlank.head", "Turing.ListBlank.map", "f", "Prod.snd", "map_pt'", "Eq.refl", "Prod.snd", "default", "Turing.ListBlank.map", "f", "Prod.mk", "false", "map_pt'", "Turing.TM2to1.addBottom.proof_1", "Turing.ListBlank.tail", "Turing.ListBlank.tail", "Turing.ListBlank.induction_on", "Turing.ListBlank.tail", "of_eq_true", "Eq.trans", "congrFun", "congrArg", "Eq", "congrArg", "Turing.ListBlank.mk", "Eq.trans", "List.map_map", "Prod.snd", "Prod.mk", "false", "List.map_id", "Turing.ListBlank.mk", "eq_self", "Turing.ListBlank.mk", "Turing.ListBlank.cons_head_tail"], "idString": "Eq.mpr; id; congrFun; congrArg; Eq; Turing.ListBlank.map_cons; f; Prod.snd; map_pt'; Eq.refl; Prod.snd; default; Turing.ListBlank.map; f; Prod.mk; false; map_pt'; Turing.TM2to1.addBottom.proof_1; Turing.ListBlank.tail; true; Turing.ListBlank.head; Eq.mpr; eq_of_heq; h; h; HEq; HEq; Eq.ndrec; e_2; HEq; e_2; Eq.refl; HEq; Eq.symm; eq_of_heq; HEq.refl; Eq.symm; Eq.refl; HEq.refl; Turing.ListBlank; k; Option; k; Turing.ListBlank.cons; Turing.ListBlank.head; Turing.ListBlank.map; f; Prod.snd; map_pt'; Eq.refl; Prod.snd; default; Turing.ListBlank.map; f; Prod.mk; false; map_pt'; Turing.TM2to1.addBottom.proof_1; Turing.ListBlank.tail; Turing.ListBlank.cons; Turing.ListBlank.head; Turing.ListBlank.tail; eq_of_heq; h; h; HEq; HEq; Turing.ListBlank.cons; Turing.ListBlank.cons; Eq.ndrec; e_4; HEq; e_4; Eq.refl; HEq; Turing.ListBlank.cons; Turing.ListBlank.cons; Eq.symm; eq_of_heq; HEq.refl; Turing.ListBlank.cons; Eq.symm; Eq.refl; HEq.refl; k; Option; k; instInhabitedForAll_1; Turing.ListBlank.head; Turing.ListBlank.map; f; Prod.snd; map_pt'; Eq.refl; Prod.snd; default; Turing.ListBlank.map; f; Prod.mk; false; map_pt'; Turing.TM2to1.addBottom.proof_1; Turing.ListBlank.tail; Turing.ListBlank.tail; Turing.ListBlank.induction_on; Turing.ListBlank.tail; of_eq_true; Eq.trans; congrFun; congrArg; Eq; congrArg; Turing.ListBlank.mk; Eq.trans; List.map_map; Prod.snd; Prod.mk; false; List.map_id; Turing.ListBlank.mk; eq_self; Turing.ListBlank.mk; Turing.ListBlank.cons_head_tail; ", "context": []}
{"typeGroup": "(∀ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] {M' : Type u_4} {N' : Type u_3}\n    [inst_2 : MulOneClass M'] [inst_3 : MulOneClass N'] (f : M ≃* M') (g : N ≃* N') (x : M × N) (x_1 : M × N),\n    Equiv.toFun\n        { toFun := ((Equiv.toFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))),\n          invFun := ((Equiv.invFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))),\n          left_inv :=\n            (((Equiv.left_inv\n                (Equiv.prodCongr (MulEquiv.toEquiv f)\n                  (MulEquiv.toEquiv\n                    g))=:Function.LeftInverse (Equiv.invFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))\n                (Equiv.toFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))))),\n          right_inv :=\n            (((Equiv.right_inv\n                (Equiv.prodCongr (MulEquiv.toEquiv f)\n                  (MulEquiv.toEquiv\n                    g))=:Function.RightInverse\n                (Equiv.invFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))\n                (Equiv.toFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))))) }\n        (x * x_1) =\n      Equiv.toFun\n          { toFun := ((Equiv.toFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))),\n            invFun := ((Equiv.invFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))),\n            left_inv :=\n              (((Equiv.left_inv\n                  (Equiv.prodCongr (MulEquiv.toEquiv f)\n                    (MulEquiv.toEquiv\n                      g))=:Function.LeftInverse\n                  (Equiv.invFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))\n                  (Equiv.toFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))))),\n            right_inv :=\n              (((Equiv.right_inv\n                  (Equiv.prodCongr (MulEquiv.toEquiv f)\n                    (MulEquiv.toEquiv\n                      g))=:Function.RightInverse\n                  (Equiv.invFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))\n                  (Equiv.toFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))))) }\n          x *\n        Equiv.toFun\n          { toFun := ((Equiv.toFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))),\n            invFun := ((Equiv.invFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))),\n            left_inv :=\n              (((Equiv.left_inv\n                  (Equiv.prodCongr (MulEquiv.toEquiv f)\n                    (MulEquiv.toEquiv\n                      g))=:Function.LeftInverse\n                  (Equiv.invFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))\n                  (Equiv.toFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))))),\n            right_inv :=\n              (((Equiv.right_inv\n                  (Equiv.prodCongr (MulEquiv.toEquiv f)\n                    (MulEquiv.toEquiv\n                      g))=:Function.RightInverse\n                  (Equiv.invFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))\n                  (Equiv.toFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))))) }\n          x_1 :\n  Prop)", "type": "∀ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] {M' : Type u_4} {N' : Type u_3}\n  [inst_2 : MulOneClass M'] [inst_3 : MulOneClass N'] (f : M ≃* M') (g : N ≃* N') (x : M × N) (x_1 : M × N),\n  Equiv.toFun\n      { toFun := ((Equiv.toFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))),\n        invFun := ((Equiv.invFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))),\n        left_inv := (((Equiv.left_inv (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g))))),\n        right_inv := (((Equiv.right_inv (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g))))) }\n      (x * x_1) =\n    Equiv.toFun\n        { toFun := ((Equiv.toFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))),\n          invFun := ((Equiv.invFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))),\n          left_inv := (((Equiv.left_inv (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g))))),\n          right_inv := (((Equiv.right_inv (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g))))) }\n        x *\n      Equiv.toFun\n        { toFun := ((Equiv.toFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))),\n          invFun := ((Equiv.invFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))),\n          left_inv := (((Equiv.left_inv (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g))))),\n          right_inv := (((Equiv.right_inv (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g))))) }\n        x_1", "thm": " : ∀ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] {M' : Type u_4} {N' : Type u_3}\n  [inst_2 : MulOneClass M'] [inst_3 : MulOneClass N'] (f : M ≃* M') (g : N ≃* N') (x : M × N) (x_1 : M × N),\n  Equiv.toFun\n      { toFun := ((Equiv.toFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))),\n        invFun := ((Equiv.invFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))),\n        left_inv := (((Equiv.left_inv (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g))))),\n        right_inv := (((Equiv.right_inv (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g))))) }\n      (x * x_1) =\n    Equiv.toFun\n        { toFun := ((Equiv.toFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))),\n          invFun := ((Equiv.invFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))),\n          left_inv := (((Equiv.left_inv (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g))))),\n          right_inv := (((Equiv.right_inv (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g))))) }\n        x *\n      Equiv.toFun\n        { toFun := ((Equiv.toFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))),\n          invFun := ((Equiv.invFun (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g)))),\n          left_inv := (((Equiv.left_inv (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g))))),\n          right_inv := (((Equiv.right_inv (Equiv.prodCongr (MulEquiv.toEquiv f) (MulEquiv.toEquiv g))))) }\n        x_1", "terms": [{"value": "Prod.fst x", "isProp": false, "context": ["{M : Type u_1}", "{N : Type u_2}", "[MulOneClass M]", "[MulOneClass N]", "{M' : Type u_4}", "{N' : Type u_3}", "[MulOneClass M']", "[MulOneClass N']", "(f : M ≃* M')", "(g : N ≃* N')", "(x : M × N)", "(x_1 : M × N)"]}, {"value": "Prod.fst x_1", "isProp": false, "context": ["{M : Type u_1}", "{N : Type u_2}", "[MulOneClass M]", "[MulOneClass N]", "{M' : Type u_4}", "{N' : Type u_3}", "[MulOneClass M']", "[MulOneClass N']", "(f : M ≃* M')", "(g : N ≃* N')", "(x : M × N)", "(x_1 : M × N)"]}, {"value": "Prod.snd x", "isProp": false, "context": ["{M : Type u_1}", "{N : Type u_2}", "[MulOneClass M]", "[MulOneClass N]", "{M' : Type u_4}", "{N' : Type u_3}", "[MulOneClass M']", "[MulOneClass N']", "(f : M ≃* M')", "(g : N ≃* N')", "(x : M × N)", "(x_1 : M × N)"]}, {"value": "Prod.snd x_1", "isProp": false, "context": ["{M : Type u_1}", "{N : Type u_2}", "[MulOneClass M]", "[MulOneClass N]", "{M' : Type u_4}", "{N' : Type u_3}", "[MulOneClass M']", "[MulOneClass N']", "(f : M ≃* M')", "(g : N ≃* N')", "(x : M × N)", "(x_1 : M × N)"]}], "namedLemmas": ["∀ {α : Type u_1} {β : Type u_2} {p q : α × β}, p.fst = q.fst → p.snd = q.snd → p = q", "∀ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] (f : M ≃* N) (x y : M), ↑f (x * y) = ↑f x * ↑f y", "∀ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] (f : M ≃* N) (x y : M), ↑f (x * y) = ↑f x * ↑f y"], "lemmas": [{"prop": "↑f (Prod.fst x * Prod.fst x_1) = ↑f (Prod.fst x) * ↑f (Prod.fst x_1)", "context": ["{M : Type u_1}", "{N : Type u_2}", "[MulOneClass M]", "[MulOneClass N]", "{M' : Type u_4}", "{N' : Type u_3}", "[MulOneClass M']", "[MulOneClass N']", "(f : M ≃* M')", "(g : N ≃* N')", "(x : M × N)", "(x_1 : M × N)"]}, {"prop": "↑g (Prod.snd x * Prod.snd x_1) = ↑g (Prod.snd x) * ↑g (Prod.snd x_1)", "context": ["{M : Type u_1}", "{N : Type u_2}", "[MulOneClass M]", "[MulOneClass N]", "{M' : Type u_4}", "{N' : Type u_3}", "[MulOneClass M']", "[MulOneClass N']", "(f : M ≃* M')", "(g : N ≃* N')", "(x : M × N)", "(x_1 : M × N)"]}], "ids": ["Prod.ext", "MulEquiv.map_mul", "Prod.fst", "Prod.fst", "MulEquiv.map_mul", "Prod.snd", "Prod.snd"], "idString": "Prod.ext; MulEquiv.map_mul; Prod.fst; Prod.fst; MulEquiv.map_mul; Prod.snd; Prod.snd; ", "context": []}
{"typeGroup": "(∀ {α : Type u_1} {s : Set α} (x : ↑s), Set.inclusion (Set.Subset.rfl=:s ⊆ s) x = x : Prop)", "type": "∀ {α : Type u_1} {s : Set α} (x : ↑s), Set.inclusion Set.Subset.rfl x = x", "thm": " : ∀ {α : Type u_1} {s : Set α} (x : ↑s), Set.inclusion Set.Subset.rfl x = x", "terms": [{"value": "{ val := ((val)), property := ((property)) }", "isProp": false, "context": ["{α : Type u_1}", "{s : Set α}", "(x : ↑s)", "(val : α)", "(property : val ∈ s)", "(h : x = { val := ((val)), property := ((property)) })"]}], "namedLemmas": ["∀ {α : Type u} {s : Set α}, s ⊆ s", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {α : Type u} {s : Set α}, s ⊆ s"], "lemmas": [{"prop": "s ⊆ s", "context": ["{α : Type u_1}", "{s : Set α}", "(x : ↑s)", "(t : { x : α // x ∈ s })"]}, {"prop": "{ val := ((val)), property := ((property)) } = x", "context": ["{α : Type u_1}", "{s : Set α}", "(x : ↑s)", "(val : α)", "(property : val ∈ s)", "(h : x = { val := ((val)), property := ((property)) })"]}, {"prop": "s ⊆ s", "context": ["{α : Type u_1}", "{s : Set α}", "(x : ↑s)", "(val : α)", "(property : val ∈ s)", "(h : x = { val := ((val)), property := ((property)) })"]}, {"prop": "Set.inclusion Set.Subset.rfl { val := ((val)), property := ((property)) } =\n  Set.inclusion Set.Subset.rfl { val := ((val)), property := ((property)) }", "context": ["{α : Type u_1}", "{s : Set α}", "(x : ↑s)", "(val : α)", "(property : val ∈ s)", "(h : x = { val := ((val)), property := ((property)) })"]}, {"prop": "∀ (val : α) (property : val ∈ s) (h : x = { val := ((val)), property := ((property)) }),\n  Set.inclusion Set.Subset.rfl x = x", "context": ["{α : Type u_1}", "{s : Set α}", "(x : ↑s)"]}, {"prop": "x = x", "context": ["{α : Type u_1}", "{s : Set α}", "(x : ↑s)"]}], "ids": ["h", "Set.inclusion", "Set.Subset.rfl", "Eq.symm", "Eq.refl", "Set.inclusion", "Set.Subset.rfl", "Eq.refl"], "idString": "h; Set.inclusion; Set.Subset.rfl; Eq.symm; Eq.refl; Set.inclusion; Set.Subset.rfl; Eq.refl; ", "context": []}
{"typeGroup": "(∀ {R : Type u_1} [inst : NonAssocSemiring R] (s : Set R) (sm : Submonoid R) (hm : ↑sm = s) (sa : AddSubmonoid R)\n    (ha : ↑sa = s),\n    1 ∈\n      Subsemigroup.carrier\n        { carrier := ((s)),\n          mul_mem' :=\n            (((fun {x : R} ↦\n              (_ :\n                ∀ {y : R} (a : x ∈ s) (a : y ∈ s),\n                  x * y ∈ s)=:∀ {x : R} {y : R} (a : x ∈ s) (a : y ∈ s), x * y ∈ s))) } :\n  Prop)", "type": "∀ {R : Type u_1} [inst : NonAssocSemiring R] (s : Set R) (sm : Submonoid R) (hm : ↑sm = s) (sa : AddSubmonoid R)\n  (ha : ↑sa = s),\n  1 ∈\n    Subsemigroup.carrier\n      { carrier := ((s)),\n        mul_mem' :=\n          (((fun {x : R} {y : R} ↦\n            Eq.mpr\n              (id\n                (implies_congr (congrArg (Membership.mem x) (Eq.symm hm))\n                  (implies_congr (congrArg (Membership.mem y) (Eq.symm hm))\n                    (congrArg (Membership.mem (x * y)) (Eq.symm hm)))))\n              (Submonoid.mul_mem sm)))) }", "thm": " : ∀ {R : Type u_1} [inst : NonAssocSemiring R] (s : Set R) (sm : Submonoid R) (hm : ↑sm = s) (sa : AddSubmonoid R)\n  (ha : ↑sa = s),\n  1 ∈\n    Subsemigroup.carrier\n      { carrier := ((s)),\n        mul_mem' :=\n          (((fun {x : R} {y : R} ↦\n            Eq.mpr\n              (id\n                (implies_congr (congrArg (Membership.mem x) (Eq.symm hm))\n                  (implies_congr (congrArg (Membership.mem y) (Eq.symm hm))\n                    (congrArg (Membership.mem (x * y)) (Eq.symm hm)))))\n              (Submonoid.mul_mem sm)))) }", "terms": [{"value": "Membership.mem x", "isProp": false, "context": ["{R : Type u_1}", "[NonAssocSemiring R]", "(s : Set R)", "(sm : Submonoid R)", "(hm : ↑sm = s)", "(sa : AddSubmonoid R)", "(ha : ↑sa = s)", "(h : 1 ∈ sm)", "(s : Set R)", "(hm : ↑sm = s)", "{x : R}", "{y : R}"]}, {"value": "Membership.mem y", "isProp": false, "context": ["{R : Type u_1}", "[NonAssocSemiring R]", "(s : Set R)", "(sm : Submonoid R)", "(hm : ↑sm = s)", "(sa : AddSubmonoid R)", "(ha : ↑sa = s)", "(h : 1 ∈ sm)", "(s : Set R)", "(hm : ↑sm = s)", "{x : R}", "{y : R}"]}, {"value": "x * y", "isProp": false, "context": ["{R : Type u_1}", "[NonAssocSemiring R]", "(s : Set R)", "(sm : Submonoid R)", "(hm : ↑sm = s)", "(sa : AddSubmonoid R)", "(ha : ↑sa = s)", "(h : 1 ∈ sm)", "(s : Set R)", "(hm : ↑sm = s)", "{x : R}", "{y : R}"]}, {"value": "Membership.mem (x * y)", "isProp": false, "context": ["{R : Type u_1}", "[NonAssocSemiring R]", "(s : Set R)", "(sm : Submonoid R)", "(hm : ↑sm = s)", "(sa : AddSubmonoid R)", "(ha : ↑sa = s)", "(h : 1 ∈ sm)", "(s : Set R)", "(hm : ↑sm = s)", "{x : R}", "{y : R}"]}, {"value": "{ carrier := ((s)),\n  mul_mem' :=\n    (((fun {x : R} {y : R} ↦\n      Eq.mpr\n        (id\n          (implies_congr (congrArg (Membership.mem x) (Eq.symm hm))\n            (implies_congr (congrArg (Membership.mem y) (Eq.symm hm))\n              (congrArg (Membership.mem (x * y)) (Eq.symm hm)))))\n        (Submonoid.mul_mem sm)))) }", "isProp": false, "context": ["{R : Type u_1}", "[NonAssocSemiring R]", "(s : Set R)", "(sm : Submonoid R)", "(hm : ↑sm = s)", "(sa : AddSubmonoid R)", "(ha : ↑sa = s)", "(h : 1 ∈ sm)", "(s : Set R)", "(hm : ↑sm = s)"]}], "namedLemmas": ["∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂)", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂)", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {M : Type u_1} [inst : MulOneClass M] (S : Submonoid M) {x y : M}, x ∈ S → y ∈ S → x * y ∈ S", "∀ {M : Type u_1} [inst : MulOneClass M] (S : Submonoid M), 1 ∈ S"], "lemmas": [{"prop": "s = ↑sm", "context": ["{R : Type u_1}", "[NonAssocSemiring R]", "(s : Set R)", "(sm : Submonoid R)", "(hm : ↑sm = s)", "(sa : AddSubmonoid R)", "(ha : ↑sa = s)", "(h : 1 ∈ sm)", "(s : Set R)", "(hm : ↑sm = s)", "{x : R}", "{y : R}"]}, {"prop": "(x ∈ s) = (x ∈ ↑sm)", "context": ["{R : Type u_1}", "[NonAssocSemiring R]", "(s : Set R)", "(sm : Submonoid R)", "(hm : ↑sm = s)", "(sa : AddSubmonoid R)", "(ha : ↑sa = s)", "(h : 1 ∈ sm)", "(s : Set R)", "(hm : ↑sm = s)", "{x : R}", "{y : R}"]}, {"prop": "s = ↑sm", "context": ["{R : Type u_1}", "[NonAssocSemiring R]", "(s : Set R)", "(sm : Submonoid R)", "(hm : ↑sm = s)", "(sa : AddSubmonoid R)", "(ha : ↑sa = s)", "(h : 1 ∈ sm)", "(s : Set R)", "(hm : ↑sm = s)", "{x : R}", "{y : R}"]}, {"prop": "(y ∈ s) = (y ∈ ↑sm)", "context": ["{R : Type u_1}", "[NonAssocSemiring R]", "(s : Set R)", "(sm : Submonoid R)", "(hm : ↑sm = s)", "(sa : AddSubmonoid R)", "(ha : ↑sa = s)", "(h : 1 ∈ sm)", "(s : Set R)", "(hm : ↑sm = s)", "{x : R}", "{y : R}"]}, {"prop": "s = ↑sm", "context": ["{R : Type u_1}", "[NonAssocSemiring R]", "(s : Set R)", "(sm : Submonoid R)", "(hm : ↑sm = s)", "(sa : AddSubmonoid R)", "(ha : ↑sa = s)", "(h : 1 ∈ sm)", "(s : Set R)", "(hm : ↑sm = s)", "{x : R}", "{y : R}"]}, {"prop": "(x * y ∈ s) = (x * y ∈ ↑sm)", "context": ["{R : Type u_1}", "[NonAssocSemiring R]", "(s : Set R)", "(sm : Submonoid R)", "(hm : ↑sm = s)", "(sa : AddSubmonoid R)", "(ha : ↑sa = s)", "(h : 1 ∈ sm)", "(s : Set R)", "(hm : ↑sm = s)", "{x : R}", "{y : R}"]}, {"prop": "(∀ (a : y ∈ s), x * y ∈ s) = (∀ (a : y ∈ ↑sm), x * y ∈ ↑sm)", "context": ["{R : Type u_1}", "[NonAssocSemiring R]", "(s : Set R)", "(sm : Submonoid R)", "(hm : ↑sm = s)", "(sa : AddSubmonoid R)", "(ha : ↑sa = s)", "(h : 1 ∈ sm)", "(s : Set R)", "(hm : ↑sm = s)", "{x : R}", "{y : R}"]}, {"prop": "(∀ (a : x ∈ s) (a : y ∈ s), x * y ∈ s) = (∀ (a : x ∈ ↑sm) (a : y ∈ ↑sm), x * y ∈ ↑sm)", "context": ["{R : Type u_1}", "[NonAssocSemiring R]", "(s : Set R)", "(sm : Submonoid R)", "(hm : ↑sm = s)", "(sa : AddSubmonoid R)", "(ha : ↑sa = s)", "(h : 1 ∈ sm)", "(s : Set R)", "(hm : ↑sm = s)", "{x : R}", "{y : R}"]}, {"prop": "(∀ (a : x ∈ s) (a : y ∈ s), x * y ∈ s) = (∀ (a : x ∈ ↑sm) (a : y ∈ ↑sm), x * y ∈ ↑sm)", "context": ["{R : Type u_1}", "[NonAssocSemiring R]", "(s : Set R)", "(sm : Submonoid R)", "(hm : ↑sm = s)", "(sa : AddSubmonoid R)", "(ha : ↑sa = s)", "(h : 1 ∈ sm)", "(s : Set R)", "(hm : ↑sm = s)", "{x : R}", "{y : R}"]}, {"prop": "∀ (a : x ∈ sm) (a : y ∈ sm), x * y ∈ sm", "context": ["{R : Type u_1}", "[NonAssocSemiring R]", "(s : Set R)", "(sm : Submonoid R)", "(hm : ↑sm = s)", "(sa : AddSubmonoid R)", "(ha : ↑sa = s)", "(h : 1 ∈ sm)", "(s : Set R)", "(hm : ↑sm = s)", "{x : R}", "{y : R}"]}, {"prop": "∀ {x : R} {y : R} (a : x ∈ s) (a : y ∈ s), x * y ∈ s", "context": ["{R : Type u_1}", "[NonAssocSemiring R]", "(s : Set R)", "(sm : Submonoid R)", "(hm : ↑sm = s)", "(sa : AddSubmonoid R)", "(ha : ↑sa = s)", "(h : 1 ∈ sm)", "(s : Set R)", "(hm : ↑sm = s)"]}, {"prop": "∀ (ha : ↑sa = ↑sm), 1 ∈ sm", "context": ["{R : Type u_1}", "[NonAssocSemiring R]", "(s : Set R)", "(sm : Submonoid R)", "(hm : ↑sm = s)", "(sa : AddSubmonoid R)", "(ha : ↑sa = s)", "(h : 1 ∈ sm)"]}, {"prop": "∀ (h : 1 ∈ sm),\n  1 ∈\n    Subsemigroup.carrier\n      { carrier := ((s)),\n        mul_mem' :=\n          (((fun {x : R} {y : R} ↦\n            Eq.mpr\n              (id\n                (implies_congr (congrArg (Membership.mem x) (Eq.symm hm))\n                  (implies_congr (congrArg (Membership.mem y) (Eq.symm hm))\n                    (congrArg (Membership.mem (x * y)) (Eq.symm hm)))))\n              (Submonoid.mul_mem sm)))) }", "context": ["{R : Type u_1}", "[NonAssocSemiring R]", "(s : Set R)", "(sm : Submonoid R)", "(hm : ↑sm = s)", "(sa : AddSubmonoid R)", "(ha : ↑sa = s)"]}, {"prop": "1 ∈ sm", "context": ["{R : Type u_1}", "[NonAssocSemiring R]", "(s : Set R)", "(sm : Submonoid R)", "(hm : ↑sm = s)", "(sa : AddSubmonoid R)", "(ha : ↑sa = s)"]}], "ids": ["Eq.rec", "Subsemigroup.carrier", "carrier", "mul_mem'", "Eq.mpr", "id", "implies_congr", "congrArg", "Membership.mem", "Eq.symm", "implies_congr", "congrArg", "Membership.mem", "Eq.symm", "congrArg", "Membership.mem", "Eq.symm", "Submonoid.mul_mem", "Submonoid.one_mem"], "idString": "Eq.rec; Subsemigroup.carrier; carrier; mul_mem'; Eq.mpr; id; implies_congr; congrArg; Membership.mem; Eq.symm; implies_congr; congrArg; Membership.mem; Eq.symm; congrArg; Membership.mem; Eq.symm; Submonoid.mul_mem; Submonoid.one_mem; ", "context": []}
{"typeGroup": "(∀ {α : Type u_1} [inst : Lattice α] [inst_1 : IsModularLattice α] (a : α) (b : α) (c : ↑(Set.Ioo (a ⊓ b) a)),\n    (fun (c : ↑(Set.Ioo b (a ⊔ b))) ↦\n          { val := ((a ⊓ ↑c)),\n            property :=\n              ((({\n                  left :=\n                    (((inf_strictMonoOn_Icc_sup\n                        (Iff.mpr (Set.left_mem_Icc=:(b ∈ Set.Icc b (a ⊔ b) : Prop) ↔ (b ≤ a ⊔ b : Prop))\n                            (le_sup_right=:b ≤ a ⊔ b)=:b ∈ Set.Icc b (a ⊔ b))\n                        (Set.Ioo_subset_Icc_self (Subtype.property c=:↑c ∈ Set.Ioo b (a ⊔ b))=:↑c ∈ Set.Icc b (a ⊔ b))\n                        (And.left\n                            (Subtype.property\n                                c=:↑c ∈\n                                Set.Ioo b (a ⊔ b))=:b < ↑c)=:(fun (c : α) ↦ a ⊓ c) b < (fun (c : α) ↦ a ⊓ c) ↑c))),\n                  right :=\n                    (((LE.le.trans_lt' (inf_le_left=:a ⊓ (a ⊔ b) ≤ a)\n                        (inf_strictMonoOn_Icc_sup\n                            (Set.Ioo_subset_Icc_self\n                                (Subtype.property c=:↑c ∈ Set.Ioo b (a ⊔ b))=:↑c ∈ Set.Icc b (a ⊔ b))\n                            (Iff.mpr (Set.right_mem_Icc=:(a ⊔ b ∈ Set.Icc b (a ⊔ b) : Prop) ↔ (b ≤ a ⊔ b : Prop))\n                                (le_sup_right=:b ≤ a ⊔ b)=:a ⊔ b ∈ Set.Icc b (a ⊔ b))\n                            (And.right\n                                (Subtype.property\n                                    c=:↑c ∈\n                                    Set.Ioo b\n                                      (a ⊔\n                                        b))=:↑c <\n                                a ⊔\n                                  b)=:(fun (c : α) ↦ a ⊓ c) ↑c <\n                            (fun (c : α) ↦ a ⊓ c)\n                              (a ⊔ b))=:a ⊓ ↑c < a))) }=:(a ⊓ b < a ⊓ ↑c : Prop) ∧ (a ⊓ ↑c < a : Prop)))) })\n        ((fun (c : ↑(Set.Ioo (a ⊓ b) a)) ↦\n            { val := ((↑c ⊔ b)),\n              property :=\n                ((({\n                    left :=\n                      (((LE.le.trans_lt (le_sup_right=:b ≤ a ⊓ b ⊔ b)\n                          (sup_strictMonoOn_Icc_inf\n                              (Iff.mpr (Set.left_mem_Icc=:(a ⊓ b ∈ Set.Icc (a ⊓ b) a : Prop) ↔ (a ⊓ b ≤ a : Prop))\n                                  (inf_le_left=:a ⊓ b ≤ a)=:a ⊓ b ∈ Set.Icc (a ⊓ b) a)\n                              (Set.Ioo_subset_Icc_self\n                                  (Subtype.property c=:↑c ∈ Set.Ioo (a ⊓ b) a)=:↑c ∈ Set.Icc (a ⊓ b) a)\n                              (And.left\n                                  (Subtype.property\n                                      c=:↑c ∈\n                                      Set.Ioo (a ⊓ b)\n                                        a)=:a ⊓ b <\n                                  ↑c)=:(fun (c : α) ↦ c ⊔ b) (a ⊓ b) < (fun (c : α) ↦ c ⊔ b) ↑c)=:b < ↑c ⊔ b))),\n                    right :=\n                      (((sup_strictMonoOn_Icc_inf\n                          (Set.Ioo_subset_Icc_self (Subtype.property c=:↑c ∈ Set.Ioo (a ⊓ b) a)=:↑c ∈ Set.Icc (a ⊓ b) a)\n                          (Iff.mpr (Set.right_mem_Icc=:(a ∈ Set.Icc (a ⊓ b) a : Prop) ↔ (a ⊓ b ≤ a : Prop))\n                              (inf_le_left=:a ⊓ b ≤ a)=:a ∈ Set.Icc (a ⊓ b) a)\n                          (And.right\n                              (Subtype.property\n                                  c=:↑c ∈\n                                  Set.Ioo (a ⊓ b)\n                                    a)=:↑c <\n                              a)=:(fun (c : α) ↦ c ⊔ b) ↑c <\n                          (fun (c : α) ↦ c ⊔ b) a))) }=:(b < ↑c ⊔ b : Prop) ∧ (↑c ⊔ b < a ⊔ b : Prop)))) })\n          c) =\n      c :\n  Prop)", "type": "∀ {α : Type u_1} [inst : Lattice α] [inst_1 : IsModularLattice α] (a : α) (b : α) (c : ↑(Set.Ioo (a ⊓ b) a)),\n  (fun (c : ↑(Set.Ioo b (a ⊔ b))) ↦\n        { val := ((a ⊓ ↑c)),\n          property :=\n            ((({\n              left :=\n                (((inf_strictMonoOn_Icc_sup (Iff.mpr Set.left_mem_Icc le_sup_right)\n                  (Set.Ioo_subset_Icc_self (Subtype.property c)) (And.left (Subtype.property c))))),\n              right :=\n                (((LE.le.trans_lt' inf_le_left\n                  (inf_strictMonoOn_Icc_sup (Set.Ioo_subset_Icc_self (Subtype.property c))\n                    (Iff.mpr Set.right_mem_Icc le_sup_right) (And.right (Subtype.property c)))))) }))) })\n      ((fun (c : ↑(Set.Ioo (a ⊓ b) a)) ↦\n          { val := ((↑c ⊔ b)),\n            property :=\n              ((({\n                left :=\n                  (((LE.le.trans_lt le_sup_right\n                    (sup_strictMonoOn_Icc_inf (Iff.mpr Set.left_mem_Icc inf_le_left)\n                      (Set.Ioo_subset_Icc_self (Subtype.property c)) (And.left (Subtype.property c)))))),\n                right :=\n                  (((sup_strictMonoOn_Icc_inf (Set.Ioo_subset_Icc_self (Subtype.property c))\n                    (Iff.mpr Set.right_mem_Icc inf_le_left) (And.right (Subtype.property c))))) }))) })\n        c) =\n    c", "thm": " : ∀ {α : Type u_1} [inst : Lattice α] [inst_1 : IsModularLattice α] (a : α) (b : α) (c : ↑(Set.Ioo (a ⊓ b) a)),\n  (fun (c : ↑(Set.Ioo b (a ⊔ b))) ↦\n        { val := ((a ⊓ ↑c)),\n          property :=\n            ((({\n              left :=\n                (((inf_strictMonoOn_Icc_sup (Iff.mpr Set.left_mem_Icc le_sup_right)\n                  (Set.Ioo_subset_Icc_self (Subtype.property c)) (And.left (Subtype.property c))))),\n              right :=\n                (((LE.le.trans_lt' inf_le_left\n                  (inf_strictMonoOn_Icc_sup (Set.Ioo_subset_Icc_self (Subtype.property c))\n                    (Iff.mpr Set.right_mem_Icc le_sup_right) (And.right (Subtype.property c)))))) }))) })\n      ((fun (c : ↑(Set.Ioo (a ⊓ b) a)) ↦\n          { val := ((↑c ⊔ b)),\n            property :=\n              ((({\n                left :=\n                  (((LE.le.trans_lt le_sup_right\n                    (sup_strictMonoOn_Icc_inf (Iff.mpr Set.left_mem_Icc inf_le_left)\n                      (Set.Ioo_subset_Icc_self (Subtype.property c)) (And.left (Subtype.property c)))))),\n                right :=\n                  (((sup_strictMonoOn_Icc_inf (Set.Ioo_subset_Icc_self (Subtype.property c))\n                    (Iff.mpr Set.right_mem_Icc inf_le_left) (And.right (Subtype.property c))))) }))) })\n        c) =\n    c", "terms": [], "namedLemmas": ["∀ {α : Sort u_1} {p : α → Prop} {a1 a2 : { x // p x }}, ↑a1 = ↑a2 → a1 = a2", "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ⊔ b = b ⊔ a", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {α : Type u_1} [inst : Lattice α] [inst_1 : IsModularLattice α] {x : α} (y : α) {z : α},\n  z ≤ x → x ⊓ y ⊔ z = x ⊓ (y ⊔ z)", "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b", "∀ {a b : Prop}, a ∧ b → b", "∀ {α : Sort u_1} {p : α → Prop} (x : Subtype p), p ↑x", "∀ {a b : Prop}, (a ↔ b) → b → a", "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ⊔ b = b ↔ a ≤ b", "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b", "∀ {a b : Prop}, a ∧ b → a", "∀ {α : Sort u_1} {p : α → Prop} (x : Subtype p), p ↑x"], "lemmas": [{"prop": "↑c ⊔ b = b ⊔ ↑c", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}, {"prop": "(a ⊓ (↑c ⊔ b) = ↑c) = (a ⊓ (↑c ⊔ b) = ↑c)", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}, {"prop": "(a ⊓ (↑c ⊔ b) = ↑c) = (a ⊓ (b ⊔ ↑c) = ↑c)", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}, {"prop": "(a ⊓ (↑c ⊔ b) = ↑c) = (a ⊓ (b ⊔ ↑c) = ↑c)", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}, {"prop": "↑c ∈ Set.Ioo (a ⊓ b) a", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}, {"prop": "↑c < a", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}, {"prop": "↑c ≤ a", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}, {"prop": "a ⊓ b ⊔ ↑c = a ⊓ (b ⊔ ↑c)", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}, {"prop": "a ⊓ (b ⊔ ↑c) = a ⊓ b ⊔ ↑c", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}, {"prop": "(a ⊓ (b ⊔ ↑c) = ↑c) = (a ⊓ (b ⊔ ↑c) = ↑c)", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}, {"prop": "(a ⊓ (b ⊔ ↑c) = ↑c) = (a ⊓ b ⊔ ↑c = ↑c)", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}, {"prop": "(a ⊓ (b ⊔ ↑c) = ↑c) = (a ⊓ b ⊔ ↑c = ↑c)", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}, {"prop": "(a ⊓ b ⊔ ↑c = ↑c) ↔ (a ⊓ b ≤ ↑c)", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}, {"prop": "↑c ∈ Set.Ioo (a ⊓ b) a", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}, {"prop": "a ⊓ b < ↑c", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}, {"prop": "a ⊓ b ≤ ↑c", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}, {"prop": "a ⊓ b ⊔ ↑c = ↑c", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}, {"prop": "(a ⊓ b ⊔ ↑c = ↑c) = (a ⊓ b ⊔ ↑c = ↑c)", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}, {"prop": "(a ⊓ b ⊔ ↑c = ↑c) = (↑c = ↑c)", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}, {"prop": "(a ⊓ b ⊔ ↑c = ↑c) = (↑c = ↑c)", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}, {"prop": "↑c = ↑c", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}, {"prop": "a ⊓ b ⊔ ↑c = ↑c", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}, {"prop": "a ⊓ (b ⊔ ↑c) = ↑c", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}, {"prop": "a ⊓ (↑c ⊔ b) = ↑c", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}, {"prop": "↑((fun (c : ↑(Set.Ioo b (a ⊔ b))) ↦\n        { val := ((a ⊓ ↑c)),\n          property :=\n            ((({\n              left :=\n                (((inf_strictMonoOn_Icc_sup (Iff.mpr Set.left_mem_Icc le_sup_right)\n                  (Set.Ioo_subset_Icc_self (Subtype.property c)) (And.left (Subtype.property c))))),\n              right :=\n                (((LE.le.trans_lt' inf_le_left\n                  (inf_strictMonoOn_Icc_sup (Set.Ioo_subset_Icc_self (Subtype.property c))\n                    (Iff.mpr Set.right_mem_Icc le_sup_right) (And.right (Subtype.property c)))))) }))) })\n      ((fun (c : ↑(Set.Ioo (a ⊓ b) a)) ↦\n          { val := ((↑c ⊔ b)),\n            property :=\n              ((({\n                left :=\n                  (((LE.le.trans_lt le_sup_right\n                    (sup_strictMonoOn_Icc_inf (Iff.mpr Set.left_mem_Icc inf_le_left)\n                      (Set.Ioo_subset_Icc_self (Subtype.property c)) (And.left (Subtype.property c)))))),\n                right :=\n                  (((sup_strictMonoOn_Icc_inf (Set.Ioo_subset_Icc_self (Subtype.property c))\n                    (Iff.mpr Set.right_mem_Icc inf_le_left) (And.right (Subtype.property c))))) }))) })\n        c)) =\n  ↑c", "context": ["{α : Type u_1}", "[Lattice α]", "[IsModularLattice α]", "(a : α)", "(b : α)", "(c : ↑(Set.Ioo (a ⊓ b) a))"]}], "ids": ["Subtype.ext", "id", "Eq.mpr", "id", "sup_comm", "Eq.refl", "Eq.mpr", "id", "Eq.symm", "inf_sup_assoc_of_le", "LT.lt.le", "And.right", "Subtype.prop", "Eq.refl", "Eq.mpr", "id", "Iff.mpr", "sup_eq_right", "LT.lt.le", "And.left", "Subtype.prop", "Eq.refl", "Eq.refl"], "idString": "Subtype.ext; id; Eq.mpr; id; sup_comm; Eq.refl; Eq.mpr; id; Eq.symm; inf_sup_assoc_of_le; LT.lt.le; And.right; Subtype.prop; Eq.refl; Eq.mpr; id; Iff.mpr; sup_eq_right; LT.lt.le; And.left; Subtype.prop; Eq.refl; Eq.refl; ", "context": []}
{"typeGroup": "(∀ (M : Type u_1) [inst : AddMonoid M] {X₁ : CategoryTheory.Discrete M} {Y₁ : CategoryTheory.Discrete M}\n    {Z₁ : CategoryTheory.Discrete M} {X₂ : CategoryTheory.Discrete M} {Y₂ : CategoryTheory.Discrete M}\n    {Z₂ : CategoryTheory.Discrete M} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (g₁ : Y₁ ⟶ Z₁) (g₂ : Y₂ ⟶ Z₂),\n    CategoryTheory.eqToHom\n        (id\n            (Eq.mpr\n                (id\n                    ((CategoryTheory.Discrete.eq_of_hom\n                            (CategoryTheory.CategoryStruct.comp f₁\n                              g₁)=:CategoryTheory.Discrete.as X₁ = CategoryTheory.Discrete.as Z₁) ▸\n                        (Eq.refl\n                            ({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                                { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                              Prop)=:({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                                { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                              Prop) =\n                            ({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                                { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                              Prop))=:({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                            { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                          Prop) =\n                        ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n                            { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                          Prop))=:({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                        { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                      Prop) =\n                    ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n                        { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                      Prop))\n                (Eq.mpr\n                    (id\n                        ((CategoryTheory.Discrete.eq_of_hom\n                                (CategoryTheory.CategoryStruct.comp f₂\n                                  g₂)=:CategoryTheory.Discrete.as X₂ = CategoryTheory.Discrete.as Z₂) ▸\n                            (Eq.refl\n                                ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n                                    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                                  Prop)=:({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n                                    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                                  Prop) =\n                                ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n                                    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                                  Prop))=:({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n                                { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                              Prop) =\n                            ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } =\n                                { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                              Prop))=:({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n                            { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                          Prop) =\n                        ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } =\n                            { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                          Prop))\n                    (Eq.refl\n                        {\n                          as :=\n                            ((CategoryTheory.Discrete.as Z₁ +\n                              CategoryTheory.Discrete.as\n                                Z₂)) }=:{ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } =\n                        {\n                          as :=\n                            ((CategoryTheory.Discrete.as Z₁ +\n                              CategoryTheory.Discrete.as\n                                Z₂)) })=:{ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n                    {\n                      as :=\n                        ((CategoryTheory.Discrete.as Z₁ +\n                          CategoryTheory.Discrete.as\n                            Z₂)) })=:{ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                {\n                  as :=\n                    ((CategoryTheory.Discrete.as Z₁ +\n                      CategoryTheory.Discrete.as\n                        Z₂)) })=:(fun (X : CategoryTheory.Discrete M) (Y : CategoryTheory.Discrete M) ↦\n                { as := ((CategoryTheory.Discrete.as X + CategoryTheory.Discrete.as Y)) })\n              X₁ X₂ =\n            (fun (X : CategoryTheory.Discrete M) (Y : CategoryTheory.Discrete M) ↦\n                { as := ((CategoryTheory.Discrete.as X + CategoryTheory.Discrete.as Y)) })\n              Z₁ Z₂) =\n      CategoryTheory.CategoryStruct.comp\n        (CategoryTheory.eqToHom\n          (id\n              (Eq.mpr\n                  (id\n                      ((CategoryTheory.Discrete.eq_of_hom\n                              f₁=:CategoryTheory.Discrete.as X₁ = CategoryTheory.Discrete.as Y₁) ▸\n                          (Eq.refl\n                              ({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                                  { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } :\n                                Prop)=:({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                                  { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } :\n                                Prop) =\n                              ({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                                  { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } :\n                                Prop))=:({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                              { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } :\n                            Prop) =\n                          ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as X₂)) } =\n                              { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } :\n                            Prop))=:({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                          { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } :\n                        Prop) =\n                      ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as X₂)) } =\n                          { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } :\n                        Prop))\n                  (Eq.mpr\n                      (id\n                          ((CategoryTheory.Discrete.eq_of_hom\n                                  f₂=:CategoryTheory.Discrete.as X₂ = CategoryTheory.Discrete.as Y₂) ▸\n                              (Eq.refl\n                                  ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as X₂)) } =\n                                      { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } :\n                                    Prop)=:({\n                                        as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as X₂)) } =\n                                      { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } :\n                                    Prop) =\n                                  ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as X₂)) } =\n                                      { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } :\n                                    Prop))=:({\n                                    as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as X₂)) } =\n                                  { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } :\n                                Prop) =\n                              ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } =\n                                  { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } :\n                                Prop))=:({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as X₂)) } =\n                              { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } :\n                            Prop) =\n                          ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } =\n                              { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } :\n                            Prop))\n                      (Eq.refl\n                          {\n                            as :=\n                              ((CategoryTheory.Discrete.as Y₁ +\n                                CategoryTheory.Discrete.as\n                                  Y₂)) }=:{ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } =\n                          {\n                            as :=\n                              ((CategoryTheory.Discrete.as Y₁ +\n                                CategoryTheory.Discrete.as\n                                  Y₂)) })=:{ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as X₂)) } =\n                      {\n                        as :=\n                          ((CategoryTheory.Discrete.as Y₁ +\n                            CategoryTheory.Discrete.as\n                              Y₂)) })=:{ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                  {\n                    as :=\n                      ((CategoryTheory.Discrete.as Y₁ +\n                        CategoryTheory.Discrete.as\n                          Y₂)) })=:(fun (X : CategoryTheory.Discrete M) (Y : CategoryTheory.Discrete M) ↦\n                  { as := ((CategoryTheory.Discrete.as X + CategoryTheory.Discrete.as Y)) })\n                X₁ X₂ =\n              (fun (X : CategoryTheory.Discrete M) (Y : CategoryTheory.Discrete M) ↦\n                  { as := ((CategoryTheory.Discrete.as X + CategoryTheory.Discrete.as Y)) })\n                Y₁ Y₂))\n        (CategoryTheory.eqToHom\n          (id\n              (Eq.mpr\n                  (id\n                      ((CategoryTheory.Discrete.eq_of_hom\n                              g₁=:CategoryTheory.Discrete.as Y₁ = CategoryTheory.Discrete.as Z₁) ▸\n                          (Eq.refl\n                              ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } =\n                                  { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                                Prop)=:({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } =\n                                  { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                                Prop) =\n                              ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } =\n                                  { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                                Prop))=:({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } =\n                              { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                            Prop) =\n                          ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Y₂)) } =\n                              { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                            Prop))=:({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } =\n                          { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                        Prop) =\n                      ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Y₂)) } =\n                          { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                        Prop))\n                  (Eq.mpr\n                      (id\n                          ((CategoryTheory.Discrete.eq_of_hom\n                                  g₂=:CategoryTheory.Discrete.as Y₂ = CategoryTheory.Discrete.as Z₂) ▸\n                              (Eq.refl\n                                  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Y₂)) } =\n                                      { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                                    Prop)=:({\n                                        as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Y₂)) } =\n                                      { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                                    Prop) =\n                                  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Y₂)) } =\n                                      { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                                    Prop))=:({\n                                    as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Y₂)) } =\n                                  { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                                Prop) =\n                              ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } =\n                                  { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                                Prop))=:({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Y₂)) } =\n                              { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                            Prop) =\n                          ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } =\n                              { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } :\n                            Prop))\n                      (Eq.refl\n                          {\n                            as :=\n                              ((CategoryTheory.Discrete.as Z₁ +\n                                CategoryTheory.Discrete.as\n                                  Z₂)) }=:{ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } =\n                          {\n                            as :=\n                              ((CategoryTheory.Discrete.as Z₁ +\n                                CategoryTheory.Discrete.as\n                                  Z₂)) })=:{ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Y₂)) } =\n                      {\n                        as :=\n                          ((CategoryTheory.Discrete.as Z₁ +\n                            CategoryTheory.Discrete.as\n                              Z₂)) })=:{ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } =\n                  {\n                    as :=\n                      ((CategoryTheory.Discrete.as Z₁ +\n                        CategoryTheory.Discrete.as\n                          Z₂)) })=:(fun (X : CategoryTheory.Discrete M) (Y : CategoryTheory.Discrete M) ↦\n                  { as := ((CategoryTheory.Discrete.as X + CategoryTheory.Discrete.as Y)) })\n                Y₁ Y₂ =\n              (fun (X : CategoryTheory.Discrete M) (Y : CategoryTheory.Discrete M) ↦\n                  { as := ((CategoryTheory.Discrete.as X + CategoryTheory.Discrete.as Y)) })\n                Z₁ Z₂)) :\n  Prop)", "type": "∀ (M : Type u_1) [inst : AddMonoid M] {X₁ : CategoryTheory.Discrete M} {Y₁ : CategoryTheory.Discrete M}\n  {Z₁ : CategoryTheory.Discrete M} {X₂ : CategoryTheory.Discrete M} {Y₂ : CategoryTheory.Discrete M}\n  {Z₂ : CategoryTheory.Discrete M} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (g₁ : Y₁ ⟶ Z₁) (g₂ : Y₂ ⟶ Z₂),\n  CategoryTheory.eqToHom\n      (id\n        (Eq.mpr\n          (id\n            ((CategoryTheory.Discrete.eq_of_hom (CategoryTheory.CategoryStruct.comp f₁ g₁)) ▸\n              (Eq.refl\n                ({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                  { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n          (Eq.mpr\n            (id\n              ((CategoryTheory.Discrete.eq_of_hom (CategoryTheory.CategoryStruct.comp f₂ g₂)) ▸\n                (Eq.refl\n                  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n                    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n            (Eq.refl { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })))) =\n    CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.eqToHom\n        (id\n          (Eq.mpr\n            (id\n              ((CategoryTheory.Discrete.eq_of_hom f₁) ▸\n                (Eq.refl\n                  ({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                    { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }))))\n            (Eq.mpr\n              (id\n                ((CategoryTheory.Discrete.eq_of_hom f₂) ▸\n                  (Eq.refl\n                    ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as X₂)) } =\n                      { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }))))\n              (Eq.refl { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) })))))\n      (CategoryTheory.eqToHom\n        (id\n          (Eq.mpr\n            (id\n              ((CategoryTheory.Discrete.eq_of_hom g₁) ▸\n                (Eq.refl\n                  ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } =\n                    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n            (Eq.mpr\n              (id\n                ((CategoryTheory.Discrete.eq_of_hom g₂) ▸\n                  (Eq.refl\n                    ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Y₂)) } =\n                      { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n              (Eq.refl { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })))))", "thm": " : ∀ (M : Type u_1) [inst : AddMonoid M] {X₁ : CategoryTheory.Discrete M} {Y₁ : CategoryTheory.Discrete M}\n  {Z₁ : CategoryTheory.Discrete M} {X₂ : CategoryTheory.Discrete M} {Y₂ : CategoryTheory.Discrete M}\n  {Z₂ : CategoryTheory.Discrete M} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (g₁ : Y₁ ⟶ Z₁) (g₂ : Y₂ ⟶ Z₂),\n  CategoryTheory.eqToHom\n      (id\n        (Eq.mpr\n          (id\n            ((CategoryTheory.Discrete.eq_of_hom (CategoryTheory.CategoryStruct.comp f₁ g₁)) ▸\n              (Eq.refl\n                ({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                  { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n          (Eq.mpr\n            (id\n              ((CategoryTheory.Discrete.eq_of_hom (CategoryTheory.CategoryStruct.comp f₂ g₂)) ▸\n                (Eq.refl\n                  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n                    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n            (Eq.refl { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })))) =\n    CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.eqToHom\n        (id\n          (Eq.mpr\n            (id\n              ((CategoryTheory.Discrete.eq_of_hom f₁) ▸\n                (Eq.refl\n                  ({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                    { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }))))\n            (Eq.mpr\n              (id\n                ((CategoryTheory.Discrete.eq_of_hom f₂) ▸\n                  (Eq.refl\n                    ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as X₂)) } =\n                      { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }))))\n              (Eq.refl { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) })))))\n      (CategoryTheory.eqToHom\n        (id\n          (Eq.mpr\n            (id\n              ((CategoryTheory.Discrete.eq_of_hom g₁) ▸\n                (Eq.refl\n                  ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } =\n                    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n            (Eq.mpr\n              (id\n                ((CategoryTheory.Discrete.eq_of_hom g₂) ▸\n                  (Eq.refl\n                    ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Y₂)) } =\n                      { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n              (Eq.refl { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })))))", "terms": [{"value": "CategoryTheory.CategoryStruct.comp f₁ g₁", "isProp": false, "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"value": "CategoryTheory.CategoryStruct.comp f₂ g₂", "isProp": false, "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"value": "Eq\n  (CategoryTheory.eqToHom\n    (id\n      (Eq.mpr\n        (id\n          ((CategoryTheory.Discrete.eq_of_hom (CategoryTheory.CategoryStruct.comp f₁ g₁)) ▸\n            (Eq.refl\n              ({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n        (Eq.mpr\n          (id\n            ((CategoryTheory.Discrete.eq_of_hom (CategoryTheory.CategoryStruct.comp f₂ g₂)) ▸\n              (Eq.refl\n                ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n                  { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n          (Eq.refl { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })))))", "isProp": false, "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"value": "CategoryTheory.eqToHom\n  (id\n    (Eq.mpr\n      (id\n        ((CategoryTheory.Discrete.eq_of_hom (CategoryTheory.CategoryStruct.comp f₁ g₁)) ▸\n          (Eq.refl\n            ({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n              { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n      (Eq.mpr\n        (id\n          ((CategoryTheory.Discrete.eq_of_hom (CategoryTheory.CategoryStruct.comp f₂ g₂)) ▸\n            (Eq.refl\n              ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n                { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n        (Eq.refl { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))", "isProp": false, "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}], "namedLemmas": ["∀ {p : Prop}, p = True → p", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Type u₁} {X Y : CategoryTheory.Discrete α}, (X ⟶ Y) → X.as = Y.as", "∀ {α : Type u₁} {X Y : CategoryTheory.Discrete α}, (X ⟶ Y) → X.as = Y.as", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y Z : C} (p : X = Y) (q : Y = Z),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom p) (CategoryTheory.eqToHom q) =\n    CategoryTheory.eqToHom (_ : X = Z)", "∀ {α : Type u₁} {X Y : CategoryTheory.Discrete α}, (X ⟶ Y) → X.as = Y.as", "∀ {α : Type u₁} {X Y : CategoryTheory.Discrete α}, (X ⟶ Y) → X.as = Y.as", "∀ {α : Type u₁} {X Y : CategoryTheory.Discrete α}, (X ⟶ Y) → X.as = Y.as", "∀ {α : Type u₁} {X Y : CategoryTheory.Discrete α}, (X ⟶ Y) → X.as = Y.as", "∀ {α : Sort u_1} (a : α), (a = a) = True", "∀ {α : Type u₁} {X Y : CategoryTheory.Discrete α}, (X ⟶ Y) → X.as = Y.as", "∀ {α : Type u₁} {X Y : CategoryTheory.Discrete α}, (X ⟶ Y) → X.as = Y.as"], "lemmas": [{"prop": "CategoryTheory.Discrete.as X₁ = CategoryTheory.Discrete.as Z₁", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }) =\n  ({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }) =\n  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }) =\n  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "CategoryTheory.Discrete.as X₂ = CategoryTheory.Discrete.as Z₂", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }) =\n  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }) =\n  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }) =\n  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "{ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } =\n  { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "{ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n  { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "{ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n  { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "(fun (X : CategoryTheory.Discrete M) (Y : CategoryTheory.Discrete M) ↦\n      { as := ((CategoryTheory.Discrete.as X + CategoryTheory.Discrete.as Y)) })\n    X₁ X₂ =\n  (fun (X : CategoryTheory.Discrete M) (Y : CategoryTheory.Discrete M) ↦\n      { as := ((CategoryTheory.Discrete.as X + CategoryTheory.Discrete.as Y)) })\n    Z₁ Z₂", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "CategoryTheory.Discrete.as X₁ = CategoryTheory.Discrete.as Y₁", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }) =\n  ({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) })", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }) =\n  ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) })", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }) =\n  ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) })", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "CategoryTheory.Discrete.as X₂ = CategoryTheory.Discrete.as Y₂", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }) =\n  ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) })", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }) =\n  ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } =\n    { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) })", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }) =\n  ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } =\n    { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) })", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "{ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } =\n  { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "{ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as X₂)) } =\n  { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "{ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n  { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "(fun (X : CategoryTheory.Discrete M) (Y : CategoryTheory.Discrete M) ↦\n      { as := ((CategoryTheory.Discrete.as X + CategoryTheory.Discrete.as Y)) })\n    X₁ X₂ =\n  (fun (X : CategoryTheory.Discrete M) (Y : CategoryTheory.Discrete M) ↦\n      { as := ((CategoryTheory.Discrete.as X + CategoryTheory.Discrete.as Y)) })\n    Y₁ Y₂", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "CategoryTheory.Discrete.as Y₁ = CategoryTheory.Discrete.as Z₁", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }) =\n  ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }) =\n  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Y₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }) =\n  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Y₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "CategoryTheory.Discrete.as Y₂ = CategoryTheory.Discrete.as Z₂", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Y₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }) =\n  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Y₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Y₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }) =\n  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Y₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }) =\n  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "{ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } =\n  { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "{ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Y₂)) } =\n  { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "{ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } =\n  { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "(fun (X : CategoryTheory.Discrete M) (Y : CategoryTheory.Discrete M) ↦\n      { as := ((CategoryTheory.Discrete.as X + CategoryTheory.Discrete.as Y)) })\n    Y₁ Y₂ =\n  (fun (X : CategoryTheory.Discrete M) (Y : CategoryTheory.Discrete M) ↦\n      { as := ((CategoryTheory.Discrete.as X + CategoryTheory.Discrete.as Y)) })\n    Z₁ Z₂", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "CategoryTheory.CategoryStruct.comp\n    (CategoryTheory.eqToHom\n      (id\n        (Eq.mpr\n          (id\n            ((CategoryTheory.Discrete.eq_of_hom f₁) ▸\n              (Eq.refl\n                ({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                  { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }))))\n          (Eq.mpr\n            (id\n              ((CategoryTheory.Discrete.eq_of_hom f₂) ▸\n                (Eq.refl\n                  ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as X₂)) } =\n                    { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }))))\n            (Eq.refl { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) })))))\n    (CategoryTheory.eqToHom\n      (id\n        (Eq.mpr\n          (id\n            ((CategoryTheory.Discrete.eq_of_hom g₁) ▸\n              (Eq.refl\n                ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } =\n                  { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n          (Eq.mpr\n            (id\n              ((CategoryTheory.Discrete.eq_of_hom g₂) ▸\n                (Eq.refl\n                  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Y₂)) } =\n                    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n            (Eq.refl { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))) =\n  CategoryTheory.eqToHom\n    (Eq.trans\n      (id\n        (Eq.mpr\n          (id\n            ((CategoryTheory.Discrete.eq_of_hom f₁) ▸\n              (Eq.refl\n                ({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                  { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }))))\n          (Eq.mpr\n            (id\n              ((CategoryTheory.Discrete.eq_of_hom f₂) ▸\n                (Eq.refl\n                  ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as X₂)) } =\n                    { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }))))\n            (Eq.refl { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }))))\n      (id\n        (Eq.mpr\n          (id\n            ((CategoryTheory.Discrete.eq_of_hom g₁) ▸\n              (Eq.refl\n                ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } =\n                  { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n          (Eq.mpr\n            (id\n              ((CategoryTheory.Discrete.eq_of_hom g₂) ▸\n                (Eq.refl\n                  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Y₂)) } =\n                    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n            (Eq.refl { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })))))", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "(CategoryTheory.eqToHom\n      (id\n        (Eq.mpr\n          (id\n            ((CategoryTheory.Discrete.eq_of_hom (CategoryTheory.CategoryStruct.comp f₁ g₁)) ▸\n              (Eq.refl\n                ({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                  { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n          (Eq.mpr\n            (id\n              ((CategoryTheory.Discrete.eq_of_hom (CategoryTheory.CategoryStruct.comp f₂ g₂)) ▸\n                (Eq.refl\n                  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n                    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n            (Eq.refl { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })))) =\n    CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.eqToHom\n        (id\n          (Eq.mpr\n            (id\n              ((CategoryTheory.Discrete.eq_of_hom f₁) ▸\n                (Eq.refl\n                  ({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                    { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }))))\n            (Eq.mpr\n              (id\n                ((CategoryTheory.Discrete.eq_of_hom f₂) ▸\n                  (Eq.refl\n                    ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as X₂)) } =\n                      { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }))))\n              (Eq.refl { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) })))))\n      (CategoryTheory.eqToHom\n        (id\n          (Eq.mpr\n            (id\n              ((CategoryTheory.Discrete.eq_of_hom g₁) ▸\n                (Eq.refl\n                  ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } =\n                    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n            (Eq.mpr\n              (id\n                ((CategoryTheory.Discrete.eq_of_hom g₂) ▸\n                  (Eq.refl\n                    ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Y₂)) } =\n                      { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n              (Eq.refl { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })))))) =\n  (CategoryTheory.eqToHom\n      (id\n        (Eq.mpr\n          (id\n            ((CategoryTheory.Discrete.eq_of_hom (CategoryTheory.CategoryStruct.comp f₁ g₁)) ▸\n              (Eq.refl\n                ({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                  { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n          (Eq.mpr\n            (id\n              ((CategoryTheory.Discrete.eq_of_hom (CategoryTheory.CategoryStruct.comp f₂ g₂)) ▸\n                (Eq.refl\n                  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n                    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n            (Eq.refl { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })))) =\n    CategoryTheory.eqToHom\n      (Eq.trans\n        (id\n          (Eq.mpr\n            (id\n              ((CategoryTheory.Discrete.eq_of_hom f₁) ▸\n                (Eq.refl\n                  ({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                    { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }))))\n            (Eq.mpr\n              (id\n                ((CategoryTheory.Discrete.eq_of_hom f₂) ▸\n                  (Eq.refl\n                    ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as X₂)) } =\n                      { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }))))\n              (Eq.refl { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }))))\n        (id\n          (Eq.mpr\n            (id\n              ((CategoryTheory.Discrete.eq_of_hom g₁) ▸\n                (Eq.refl\n                  ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } =\n                    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n            (Eq.mpr\n              (id\n                ((CategoryTheory.Discrete.eq_of_hom g₂) ▸\n                  (Eq.refl\n                    ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Y₂)) } =\n                      { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n              (Eq.refl { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))))", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "CategoryTheory.Discrete.as X₁ = CategoryTheory.Discrete.as Z₁", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }) =\n  ({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }) =\n  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }) =\n  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "CategoryTheory.Discrete.as X₂ = CategoryTheory.Discrete.as Z₂", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }) =\n  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }) =\n  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }) =\n  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } =\n    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "{ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) } =\n  { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "{ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n  { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "{ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n  { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "(fun (X : CategoryTheory.Discrete M) (Y : CategoryTheory.Discrete M) ↦\n      { as := ((CategoryTheory.Discrete.as X + CategoryTheory.Discrete.as Y)) })\n    X₁ X₂ =\n  (fun (X : CategoryTheory.Discrete M) (Y : CategoryTheory.Discrete M) ↦\n      { as := ((CategoryTheory.Discrete.as X + CategoryTheory.Discrete.as Y)) })\n    Z₁ Z₂", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "(CategoryTheory.eqToHom\n      (id\n        (Eq.mpr\n          (id\n            ((CategoryTheory.Discrete.eq_of_hom (CategoryTheory.CategoryStruct.comp f₁ g₁)) ▸\n              (Eq.refl\n                ({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                  { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n          (Eq.mpr\n            (id\n              ((CategoryTheory.Discrete.eq_of_hom (CategoryTheory.CategoryStruct.comp f₂ g₂)) ▸\n                (Eq.refl\n                  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n                    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n            (Eq.refl { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })))) =\n    CategoryTheory.eqToHom\n      (id\n        (Eq.mpr\n          (id\n            ((CategoryTheory.Discrete.eq_of_hom (CategoryTheory.CategoryStruct.comp f₁ g₁)) ▸\n              (Eq.refl\n                ({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                  { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n          (Eq.mpr\n            (id\n              ((CategoryTheory.Discrete.eq_of_hom (CategoryTheory.CategoryStruct.comp f₂ g₂)) ▸\n                (Eq.refl\n                  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n                    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n            (Eq.refl { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))) =\n  True", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}, {"prop": "(CategoryTheory.eqToHom\n      (id\n        (Eq.mpr\n          (id\n            ((CategoryTheory.Discrete.eq_of_hom (CategoryTheory.CategoryStruct.comp f₁ g₁)) ▸\n              (Eq.refl\n                ({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                  { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n          (Eq.mpr\n            (id\n              ((CategoryTheory.Discrete.eq_of_hom (CategoryTheory.CategoryStruct.comp f₂ g₂)) ▸\n                (Eq.refl\n                  ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as X₂)) } =\n                    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n            (Eq.refl { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })))) =\n    CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.eqToHom\n        (id\n          (Eq.mpr\n            (id\n              ((CategoryTheory.Discrete.eq_of_hom f₁) ▸\n                (Eq.refl\n                  ({ as := ((CategoryTheory.Discrete.as X₁ + CategoryTheory.Discrete.as X₂)) } =\n                    { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }))))\n            (Eq.mpr\n              (id\n                ((CategoryTheory.Discrete.eq_of_hom f₂) ▸\n                  (Eq.refl\n                    ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as X₂)) } =\n                      { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) }))))\n              (Eq.refl { as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) })))))\n      (CategoryTheory.eqToHom\n        (id\n          (Eq.mpr\n            (id\n              ((CategoryTheory.Discrete.eq_of_hom g₁) ▸\n                (Eq.refl\n                  ({ as := ((CategoryTheory.Discrete.as Y₁ + CategoryTheory.Discrete.as Y₂)) } =\n                    { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n            (Eq.mpr\n              (id\n                ((CategoryTheory.Discrete.eq_of_hom g₂) ▸\n                  (Eq.refl\n                    ({ as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Y₂)) } =\n                      { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) }))))\n              (Eq.refl { as := ((CategoryTheory.Discrete.as Z₁ + CategoryTheory.Discrete.as Z₂)) })))))) =\n  True", "context": ["(M : Type u_1)", "[AddMonoid M]", "{X₁ : CategoryTheory.Discrete M}", "{Y₁ : CategoryTheory.Discrete M}", "{Z₁ : CategoryTheory.Discrete M}", "{X₂ : CategoryTheory.Discrete M}", "{Y₂ : CategoryTheory.Discrete M}", "{Z₂ : CategoryTheory.Discrete M}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₂)", "(g₁ : Y₁ ⟶ Z₁)", "(g₂ : Y₂ ⟶ Z₂)"]}], "ids": ["of_eq_true", "Eq.trans", "congrArg", "Eq", "CategoryTheory.eqToHom", "id", "Eq.mpr", "id", "CategoryTheory.Discrete.eq_of_hom", "CategoryTheory.CategoryStruct.comp", "Eq.refl", "as", "CategoryTheory.Discrete.as", "CategoryTheory.Discrete.as", "as", "CategoryTheory.Discrete.as", "CategoryTheory.Discrete.as", "Eq.mpr", "id", "CategoryTheory.Discrete.eq_of_hom", "CategoryTheory.CategoryStruct.comp", "Eq.refl", "as", "CategoryTheory.Discrete.as", "CategoryTheory.Discrete.as", "as", "CategoryTheory.Discrete.as", "CategoryTheory.Discrete.as", "Eq.refl", "as", "CategoryTheory.Discrete.as", "CategoryTheory.Discrete.as", "CategoryTheory.eqToHom_trans", "id", "Eq.mpr", "id", "CategoryTheory.Discrete.eq_of_hom", "Eq.refl", "as", "CategoryTheory.Discrete.as", "CategoryTheory.Discrete.as", "as", "CategoryTheory.Discrete.as", "CategoryTheory.Discrete.as", "Eq.mpr", "id", "CategoryTheory.Discrete.eq_of_hom", "Eq.refl", "as", "CategoryTheory.Discrete.as", "CategoryTheory.Discrete.as", "as", "CategoryTheory.Discrete.as", "CategoryTheory.Discrete.as", "Eq.refl", "as", "CategoryTheory.Discrete.as", "CategoryTheory.Discrete.as", "id", "Eq.mpr", "id", "CategoryTheory.Discrete.eq_of_hom", "Eq.refl", "as", "CategoryTheory.Discrete.as", "CategoryTheory.Discrete.as", "as", "CategoryTheory.Discrete.as", "CategoryTheory.Discrete.as", "Eq.mpr", "id", "CategoryTheory.Discrete.eq_of_hom", "Eq.refl", "as", "CategoryTheory.Discrete.as", "CategoryTheory.Discrete.as", "as", "CategoryTheory.Discrete.as", "CategoryTheory.Discrete.as", "Eq.refl", "as", "CategoryTheory.Discrete.as", "CategoryTheory.Discrete.as", "eq_self", "CategoryTheory.eqToHom", "id", "Eq.mpr", "id", "CategoryTheory.Discrete.eq_of_hom", "CategoryTheory.CategoryStruct.comp", "Eq.refl", "as", "CategoryTheory.Discrete.as", "CategoryTheory.Discrete.as", "as", "CategoryTheory.Discrete.as", "CategoryTheory.Discrete.as", "Eq.mpr", "id", "CategoryTheory.Discrete.eq_of_hom", "CategoryTheory.CategoryStruct.comp", "Eq.refl", "as", "CategoryTheory.Discrete.as", "CategoryTheory.Discrete.as", "as", "CategoryTheory.Discrete.as", "CategoryTheory.Discrete.as", "Eq.refl", "as", "CategoryTheory.Discrete.as", "CategoryTheory.Discrete.as"], "idString": "of_eq_true; Eq.trans; congrArg; Eq; CategoryTheory.eqToHom; id; Eq.mpr; id; CategoryTheory.Discrete.eq_of_hom; CategoryTheory.CategoryStruct.comp; Eq.refl; as; CategoryTheory.Discrete.as; CategoryTheory.Discrete.as; as; CategoryTheory.Discrete.as; CategoryTheory.Discrete.as; Eq.mpr; id; CategoryTheory.Discrete.eq_of_hom; CategoryTheory.CategoryStruct.comp; Eq.refl; as; CategoryTheory.Discrete.as; CategoryTheory.Discrete.as; as; CategoryTheory.Discrete.as; CategoryTheory.Discrete.as; Eq.refl; as; CategoryTheory.Discrete.as; CategoryTheory.Discrete.as; CategoryTheory.eqToHom_trans; id; Eq.mpr; id; CategoryTheory.Discrete.eq_of_hom; Eq.refl; as; CategoryTheory.Discrete.as; CategoryTheory.Discrete.as; as; CategoryTheory.Discrete.as; CategoryTheory.Discrete.as; Eq.mpr; id; CategoryTheory.Discrete.eq_of_hom; Eq.refl; as; CategoryTheory.Discrete.as; CategoryTheory.Discrete.as; as; CategoryTheory.Discrete.as; CategoryTheory.Discrete.as; Eq.refl; as; CategoryTheory.Discrete.as; CategoryTheory.Discrete.as; id; Eq.mpr; id; CategoryTheory.Discrete.eq_of_hom; Eq.refl; as; CategoryTheory.Discrete.as; CategoryTheory.Discrete.as; as; CategoryTheory.Discrete.as; CategoryTheory.Discrete.as; Eq.mpr; id; CategoryTheory.Discrete.eq_of_hom; Eq.refl; as; CategoryTheory.Discrete.as; CategoryTheory.Discrete.as; as; CategoryTheory.Discrete.as; CategoryTheory.Discrete.as; Eq.refl; as; CategoryTheory.Discrete.as; CategoryTheory.Discrete.as; eq_self; CategoryTheory.eqToHom; id; Eq.mpr; id; CategoryTheory.Discrete.eq_of_hom; CategoryTheory.CategoryStruct.comp; Eq.refl; as; CategoryTheory.Discrete.as; CategoryTheory.Discrete.as; as; CategoryTheory.Discrete.as; CategoryTheory.Discrete.as; Eq.mpr; id; CategoryTheory.Discrete.eq_of_hom; CategoryTheory.CategoryStruct.comp; Eq.refl; as; CategoryTheory.Discrete.as; CategoryTheory.Discrete.as; as; CategoryTheory.Discrete.as; CategoryTheory.Discrete.as; Eq.refl; as; CategoryTheory.Discrete.as; CategoryTheory.Discrete.as; ", "context": []}
{"typeGroup": "(∀ (R : Type u_1) [inst : CommRing R] [inst_1 : IsReduced R] (p : ℕ) (k : ℕ) (m : ℕ+) [hp : Fact (Nat.Prime p : Prop)]\n    [inst_2 : CharP R p] {ζ : Rˣ},\n    (ζ ∈ rootsOfUnity ({ val := ((p)), property := (((Nat.Prime.pos (Fact.out=:Nat.Prime p)=:0 < p))) } ^ k * m) R :\n        Prop) ↔\n      (ζ ∈ rootsOfUnity m R : Prop) :\n  Prop)", "type": "∀ (R : Type u_1) [inst : CommRing R] [inst_1 : IsReduced R] (p : ℕ) (k : ℕ) (m : ℕ+) [hp : Fact (Nat.Prime p)]\n  [inst_2 : CharP R p] {ζ : Rˣ},\n  (ζ ∈ rootsOfUnity ({ val := ((p)), property := (((Nat.Prime.pos Fact.out))) } ^ k * m) R) ↔ (ζ ∈ rootsOfUnity m R)", "thm": " : ∀ (R : Type u_1) [inst : CommRing R] [inst_1 : IsReduced R] (p : ℕ) (k : ℕ) (m : ℕ+) [hp : Fact (Nat.Prime p)]\n  [inst_2 : CharP R p] {ζ : Rˣ},\n  (ζ ∈ rootsOfUnity ({ val := ((p)), property := (((Nat.Prime.pos Fact.out))) } ^ k * m) R) ↔ (ζ ∈ rootsOfUnity m R)", "terms": [{"value": "{ val := ((p)), property := (((Nat.Prime.pos Fact.out))) } ^ k * m", "isProp": false, "context": ["(R : Type u_1)", "[CommRing R]", "[IsReduced R]", "(p : ℕ)", "(k : ℕ)", "(m : ℕ+)", "[Fact (Nat.Prime p)]", "[CharP R p]", "{ζ : Rˣ}"]}, {"value": "↑m", "isProp": false, "context": ["(R : Type u_1)", "[CommRing R]", "[IsReduced R]", "(p : ℕ)", "(k : ℕ)", "(m : ℕ+)", "[Fact (Nat.Prime p)]", "[CharP R p]", "{ζ : Rˣ}"]}, {"value": "↑ζ", "isProp": false, "context": ["(R : Type u_1)", "[CommRing R]", "[IsReduced R]", "(p : ℕ)", "(k : ℕ)", "(m : ℕ+)", "[Fact (Nat.Prime p)]", "[CharP R p]", "{ζ : Rˣ}"]}, {"value": "(↑ζ ^ ↑m = 1)", "isProp": true, "context": ["(R : Type u_1)", "[CommRing R]", "[IsReduced R]", "(p : ℕ)", "(k : ℕ)", "(m : ℕ+)", "[Fact (Nat.Prime p)]", "[CharP R p]", "{ζ : Rˣ}"]}], "namedLemmas": ["∀ {p : Prop}, p = True → p", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {p : ℕ}, Nat.Prime p → 0 < p", "∀ {p : Prop} [self : Fact p], p", "∀ (p : Prop), (p ↔ p) = True"], "lemmas": [{"prop": "Nat.Prime p", "context": ["(R : Type u_1)", "[CommRing R]", "[IsReduced R]", "(p : ℕ)", "(k : ℕ)", "(m : ℕ+)", "[Fact (Nat.Prime p)]", "[CharP R p]", "{ζ : Rˣ}"]}, {"prop": "0 < p", "context": ["(R : Type u_1)", "[CommRing R]", "[IsReduced R]", "(p : ℕ)", "(k : ℕ)", "(m : ℕ+)", "[Fact (Nat.Prime p)]", "[CharP R p]", "{ζ : Rˣ}"]}, {"prop": "(ζ ∈ rootsOfUnity ({ val := ((p)), property := (((Nat.Prime.pos Fact.out))) } ^ k * m) R) =\n  (↑ζ ^ ↑({ val := ((p)), property := (((Nat.Prime.pos Fact.out))) } ^ k * m) = 1)", "context": ["(R : Type u_1)", "[CommRing R]", "[IsReduced R]", "(p : ℕ)", "(k : ℕ)", "(m : ℕ+)", "[Fact (Nat.Prime p)]", "[CharP R p]", "{ζ : Rˣ}"]}, {"prop": "(↑ζ ^ (p ^ k * ↑m) = 1) = (↑ζ ^ ↑m = 1)", "context": ["(R : Type u_1)", "[CommRing R]", "[IsReduced R]", "(p : ℕ)", "(k : ℕ)", "(m : ℕ+)", "[Fact (Nat.Prime p)]", "[CharP R p]", "{ζ : Rˣ}"]}, {"prop": "(ζ ∈ rootsOfUnity ({ val := ((p)), property := (((Nat.Prime.pos Fact.out))) } ^ k * m) R) = (↑ζ ^ ↑m = 1)", "context": ["(R : Type u_1)", "[CommRing R]", "[IsReduced R]", "(p : ℕ)", "(k : ℕ)", "(m : ℕ+)", "[Fact (Nat.Prime p)]", "[CharP R p]", "{ζ : Rˣ}"]}, {"prop": "Iff (ζ ∈ rootsOfUnity ({ val := ((p)), property := (((Nat.Prime.pos Fact.out))) } ^ k * m) R) = Iff (↑ζ ^ ↑m = 1)", "context": ["(R : Type u_1)", "[CommRing R]", "[IsReduced R]", "(p : ℕ)", "(k : ℕ)", "(m : ℕ+)", "[Fact (Nat.Prime p)]", "[CharP R p]", "{ζ : Rˣ}"]}, {"prop": "(ζ ∈ rootsOfUnity m R) = (↑ζ ^ ↑m = 1)", "context": ["(R : Type u_1)", "[CommRing R]", "[IsReduced R]", "(p : ℕ)", "(k : ℕ)", "(m : ℕ+)", "[Fact (Nat.Prime p)]", "[CharP R p]", "{ζ : Rˣ}"]}, {"prop": "((ζ ∈ rootsOfUnity ({ val := ((p)), property := (((Nat.Prime.pos Fact.out))) } ^ k * m) R) ↔ (ζ ∈ rootsOfUnity m R)) =\n  ((↑ζ ^ ↑m = 1) ↔ (↑ζ ^ ↑m = 1))", "context": ["(R : Type u_1)", "[CommRing R]", "[IsReduced R]", "(p : ℕ)", "(k : ℕ)", "(m : ℕ+)", "[Fact (Nat.Prime p)]", "[CharP R p]", "{ζ : Rˣ}"]}, {"prop": "((↑ζ ^ ↑m = 1) ↔ (↑ζ ^ ↑m = 1)) = True", "context": ["(R : Type u_1)", "[CommRing R]", "[IsReduced R]", "(p : ℕ)", "(k : ℕ)", "(m : ℕ+)", "[Fact (Nat.Prime p)]", "[CharP R p]", "{ζ : Rˣ}"]}, {"prop": "((ζ ∈ rootsOfUnity ({ val := ((p)), property := (((Nat.Prime.pos Fact.out))) } ^ k * m) R) ↔ (ζ ∈ rootsOfUnity m R)) =\n  True", "context": ["(R : Type u_1)", "[CommRing R]", "[IsReduced R]", "(p : ℕ)", "(k : ℕ)", "(m : ℕ+)", "[Fact (Nat.Prime p)]", "[CharP R p]", "{ζ : Rˣ}"]}], "ids": ["of_eq_true", "Eq.trans", "congr", "congrArg", "Iff", "Eq.trans", "Mathlib.RingTheory.RootsOfUnity.Basic._auxLemma.7", "val", "property", "Nat.Prime.pos", "Fact.out", "Mathlib.RingTheory.RootsOfUnity.Basic._auxLemma.8", "Mathlib.RingTheory.RootsOfUnity.Basic._auxLemma.7", "iff_self"], "idString": "of_eq_true; Eq.trans; congr; congrArg; Iff; Eq.trans; Mathlib.RingTheory.RootsOfUnity.Basic._auxLemma.7; val; property; Nat.Prime.pos; Fact.out; Mathlib.RingTheory.RootsOfUnity.Basic._auxLemma.8; Mathlib.RingTheory.RootsOfUnity.Basic._auxLemma.7; iff_self; ", "context": []}
{"typeGroup": "(∀ {α : Type u_1} [inst : CommMonoid α] (x : α),\n    Quotient.lift id\n        (fun (a : α) ↦ (_ : ∀ (b : α) (a_1 : IsConj a b), a = b)=:∀ (a : α) (b : α) (a_1 : IsConj a b), a = b)\n        (Quotient.mk (IsConj.setoid α) x) =\n      id x :\n  Prop)", "type": "∀ {α : Type u_1} [inst : CommMonoid α] (x : α),\n  Quotient.lift id (fun (a : α) (b : α) ↦ Iff.mp isConj_iff_eq) (Quotient.mk (IsConj.setoid α) x) = id x", "thm": " : ∀ {α : Type u_1} [inst : CommMonoid α] (x : α),\n  Quotient.lift id (fun (a : α) (b : α) ↦ Iff.mp isConj_iff_eq) (Quotient.mk (IsConj.setoid α) x) = id x", "terms": [], "namedLemmas": ["∀ {α : Sort u_1} {β : Sort u_2} [s : Setoid α] (f : α → β) (h : ∀ (a b : α), a ≈ b → f a = f b) (x : α),\n  Quotient.lift f h (Quotient.mk s x) = f x", "∀ {a b : Prop}, (a ↔ b) → a → b", "∀ {α : Type u_1} [inst : CommMonoid α] {a b : α}, IsConj a b ↔ a = b"], "lemmas": [{"prop": "(IsConj a b) ↔ (a = b)", "context": ["{α : Type u_1}", "[CommMonoid α]", "(a : α)", "(b : α)"]}, {"prop": "∀ (a : α) (b : α) (a_1 : IsConj a b), a = b", "context": ["{α : Type u_1}", "[CommMonoid α]"]}], "ids": ["Quotient.lift_mk", "id", "Iff.mp", "isConj_iff_eq"], "idString": "Quotient.lift_mk; id; Iff.mp; isConj_iff_eq; ", "context": []}
{"typeGroup": "(∀ {R : Type u_2} [inst : Ring R] {M : Type u_1} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n    [inst_3 : IsSimpleModule R M] (f : Module.End R M) (h : ¬(f = 0 : Prop)),\n    Function.LeftInverse (Equiv.invFun (Equiv.ofBijective ↑f (LinearMap.bijective_of_ne_zero h=:Function.Bijective ↑f)))\n      (Equiv.toFun (Equiv.ofBijective ↑f (LinearMap.bijective_of_ne_zero h=:Function.Bijective ↑f))) :\n  Prop)", "type": "∀ {R : Type u_2} [inst : Ring R] {M : Type u_1} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsSimpleModule R M] (f : Module.End R M) (h : ¬(f = 0)),\n  Function.LeftInverse (Equiv.invFun (Equiv.ofBijective ↑f (LinearMap.bijective_of_ne_zero h)))\n    (Equiv.toFun (Equiv.ofBijective ↑f (LinearMap.bijective_of_ne_zero h)))", "thm": " : ∀ {R : Type u_2} [inst : Ring R] {M : Type u_1} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsSimpleModule R M] (f : Module.End R M) (h : ¬(f = 0)),\n  Function.LeftInverse (Equiv.invFun (Equiv.ofBijective ↑f (LinearMap.bijective_of_ne_zero h)))\n    (Equiv.toFun (Equiv.ofBijective ↑f (LinearMap.bijective_of_ne_zero h)))", "terms": [{"value": "↑f", "isProp": false, "context": ["{R : Type u_2}", "[Ring R]", "{M : Type u_1}", "[AddCommGroup M]", "[Module R M]", "[IsSimpleModule R M]", "(f : Module.End R M)", "(h : ¬(f = 0))"]}, {"value": "Equiv.ofBijective ↑f (LinearMap.bijective_of_ne_zero h)", "isProp": false, "context": ["{R : Type u_2}", "[Ring R]", "{M : Type u_1}", "[AddCommGroup M]", "[Module R M]", "[IsSimpleModule R M]", "(f : Module.End R M)", "(h : ¬(f = 0))"]}], "namedLemmas": ["∀ {α : Sort u_1} {β : Sort u_2} (self : α ≃ β), Function.LeftInverse self.invFun self.toFun", "∀ {R : Type u_1} [inst : Ring R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {N : Type u_3}\n  [inst_3 : AddCommGroup N] [inst_4 : Module R N] [inst_5 : IsSimpleModule R M] [inst_6 : IsSimpleModule R N]\n  {f : M →ₗ[R] N}, f ≠ 0 → Function.Bijective ↑f"], "lemmas": [{"prop": "Function.Bijective ↑f", "context": ["{R : Type u_2}", "[Ring R]", "{M : Type u_1}", "[AddCommGroup M]", "[Module R M]", "[IsSimpleModule R M]", "(f : Module.End R M)", "(h : ¬(f = 0))"]}], "ids": ["Equiv.left_inv", "Equiv.ofBijective", "LinearMap.bijective_of_ne_zero"], "idString": "Equiv.left_inv; Equiv.ofBijective; LinearMap.bijective_of_ne_zero; ", "context": []}
{"typeGroup": "(∀ {α : Sort u_2} {r : (a : α) → (a : α) → Prop} {motive : (a : Quot r) → Sort u_1}\n    [h : ∀ (a : α), Subsingleton (motive (Quot.mk r a))] (f : (a : α) → motive (Quot.mk r a)) (a : α) (b : α)\n    (p : r a b), (Quot.sound p=:Quot.mk r a = Quot.mk r b) ▸ f a = f b :\n  Prop)", "type": "∀ {α : Sort u_2} {r : (a : α) → (a : α) → Prop} {motive : (a : Quot r) → Sort u_1}\n  [h : ∀ (a : α), Subsingleton (motive (Quot.mk r a))] (f : (a : α) → motive (Quot.mk r a)) (a : α) (b : α) (p : r a b),\n  (Quot.sound p) ▸ f a = f b", "thm": " : ∀ {α : Sort u_2} {r : (a : α) → (a : α) → Prop} {motive : (a : Quot r) → Sort u_1}\n  [h : ∀ (a : α), Subsingleton (motive (Quot.mk r a))] (f : (a : α) → motive (Quot.mk r a)) (a : α) (b : α) (p : r a b),\n  (Quot.sound p) ▸ f a = f b", "terms": [{"value": "(Quot.sound p) ▸ f a", "isProp": false, "context": ["{α : Sort u_2}", "{r : (a : α) → (a : α) → Prop}", "{motive : (a : Quot r) → Sort u_1}", "[∀ (a : α), Subsingleton (motive (Quot.mk r a))]", "(f : (a : α) → motive (Quot.mk r a))", "(a : α)", "(b : α)", "(p : r a b)"]}, {"value": "f b", "isProp": false, "context": ["{α : Sort u_2}", "{r : (a : α) → (a : α) → Prop}", "{motive : (a : Quot r) → Sort u_1}", "[∀ (a : α), Subsingleton (motive (Quot.mk r a))]", "(f : (a : α) → motive (Quot.mk r a))", "(a : α)", "(b : α)", "(p : r a b)"]}], "namedLemmas": ["∀ {α : Sort u} [h : Subsingleton α] (a b : α), a = b"], "lemmas": [{"prop": "Quot.mk r a = Quot.mk r b", "context": ["{α : Sort u_2}", "{r : (a : α) → (a : α) → Prop}", "{motive : (a : Quot r) → Sort u_1}", "[∀ (a : α), Subsingleton (motive (Quot.mk r a))]", "(f : (a : α) → motive (Quot.mk r a))", "(a : α)", "(b : α)", "(p : r a b)"]}], "ids": ["Subsingleton.elim", "Quot.sound"], "idString": "Subsingleton.elim; Quot.sound; ", "context": []}
