{"typeGroup": "(∀ {α : Type u_1} {β : Type u_2} (f : (a : α) → β) (s : Set α),\n    Function.Surjective (Set.MapsTo.restrict f s (f '' s) (Set.mapsTo_image f s=:Set.MapsTo f s (f '' s))) :\n  Prop)", "type": "∀ {α : Type u_1} {β : Type u_2} (f : (a : α) → β) (s : Set α) (x : ↑(f '' s)),\n  ∃ (a : ↑s), Set.MapsTo.restrict f s (f '' s) (Set.mapsTo_image f s) a = x", "thm": " : ∀ {α : Type u_1} {β : Type u_2} (f : (a : α) → β) (s : Set α) (x : ↑(f '' s)),\n  ∃ (a : ↑s), Set.MapsTo.restrict f s (f '' s) (Set.mapsTo_image f s) a = x", "terms": [{"value": "f '' s", "isProp": false, "context": ["{α : Type u_1}", "{β : Type u_2}", "(f : (a : α) → β)", "(s : Set α)", "(x : ↑(f '' s))", "(x : ↑(f '' s))"]}, {"value": "{ val := ((x)), property := ((hs)) }", "isProp": false, "context": ["{α : Type u_1}", "{β : Type u_2}", "(f : (a : α) → β)", "(s : Set α)", "(x : ↑(f '' s))", "(val : β)", "(x : α)", "(hs : x ∈ s)", "(hxy : f x = val)"]}], "namedLemmas": ["∀ {α : Type u_1} {β : Type u_2} (f : α → β) (s : Set α), Set.MapsTo f s (f '' s)", "∀ {α : Sort u_1} {p : α → Prop} {a1 a2 : { x // p x }}, ↑a1 = ↑a2 → a1 = a2"], "lemmas": [{"prop": "Set.MapsTo f s (f '' s)", "context": ["{α : Type u_1}", "{β : Type u_2}", "(f : (a : α) → β)", "(s : Set α)", "(x : ↑(f '' s))", "(x : ↑(f '' s))"]}, {"prop": "Set.MapsTo.restrict f s (f '' s) (Set.mapsTo_image f s) { val := ((x)), property := ((hs)) } =\n  { val := ((val)), property := (((Exists.intro x ({ left := ((hs)), right := ((hxy)) })))) }", "context": ["{α : Type u_1}", "{β : Type u_2}", "(f : (a : α) → β)", "(s : Set α)", "(x : ↑(f '' s))", "(val : β)", "(x : α)", "(hs : x ∈ s)", "(hxy : f x = val)"]}, {"prop": "∀ (val : β) (x : α) (hs : x ∈ s) (hxy : f x = val),\n  ∃ (a : ↑s),\n    Set.MapsTo.restrict f s (f '' s) (Set.mapsTo_image f s) a =\n      { val := ((val)), property := (((Exists.intro x ({ left := ((hs)), right := ((hxy)) })))) }", "context": ["{α : Type u_1}", "{β : Type u_2}", "(f : (a : α) → β)", "(s : Set α)", "(x : ↑(f '' s))"]}], "ids": ["Set.surjective_mapsTo_image_restrict.match_1", "a", "Set.MapsTo.restrict", "Set.mapsTo_image", "a", "Exists.intro", "property", "Subtype.ext"], "idString": "Set.surjective_mapsTo_image_restrict.match_1; a; Set.MapsTo.restrict; Set.mapsTo_image; a; Exists.intro; property; Subtype.ext; ", "context": []}
{"typeGroup": "(∀ {R : Type u_2} {A : Type u_1} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\n    {S : Subalgebra R A} {T : Subalgebra R A} (h : S ≤ T),\n    OneHom.toFun\n        (↑{\n            toOneHom :=\n              (({ toFun := ((Set.inclusion h)), map_one' := (((rfl=:Set.inclusion h 1 = Set.inclusion h 1))) })),\n            map_mul' :=\n              (((fun (x : { x : A // x ∈ S }) ↦\n                (_ :\n                  ∀ (x_1 : { x : A // x ∈ S }),\n                    OneHom.toFun\n                        { toFun := ((Set.inclusion h)), map_one' := (((rfl=:Set.inclusion h 1 = Set.inclusion h 1))) }\n                        (x * x_1) =\n                      OneHom.toFun\n                        { toFun := ((Set.inclusion h)), map_one' := (((rfl=:Set.inclusion h 1 = Set.inclusion h 1))) }\n                        (x *\n                          x_1))=:∀ (x : { x : A // x ∈ S }) (x_1 : { x : A // x ∈ S }),\n                  OneHom.toFun\n                      { toFun := ((Set.inclusion h)), map_one' := (((rfl=:Set.inclusion h 1 = Set.inclusion h 1))) }\n                      (x * x_1) =\n                    OneHom.toFun\n                      { toFun := ((Set.inclusion h)), map_one' := (((rfl=:Set.inclusion h 1 = Set.inclusion h 1))) }\n                      (x * x_1)))) })\n        0 =\n      OneHom.toFun\n        (↑{\n            toOneHom :=\n              (({ toFun := ((Set.inclusion h)), map_one' := (((rfl=:Set.inclusion h 1 = Set.inclusion h 1))) })),\n            map_mul' :=\n              (((fun (x : { x : A // x ∈ S }) ↦\n                (_ :\n                  ∀ (x_1 : { x : A // x ∈ S }),\n                    OneHom.toFun\n                        { toFun := ((Set.inclusion h)), map_one' := (((rfl=:Set.inclusion h 1 = Set.inclusion h 1))) }\n                        (x * x_1) =\n                      OneHom.toFun\n                        { toFun := ((Set.inclusion h)), map_one' := (((rfl=:Set.inclusion h 1 = Set.inclusion h 1))) }\n                        (x *\n                          x_1))=:∀ (x : { x : A // x ∈ S }) (x_1 : { x : A // x ∈ S }),\n                  OneHom.toFun\n                      { toFun := ((Set.inclusion h)), map_one' := (((rfl=:Set.inclusion h 1 = Set.inclusion h 1))) }\n                      (x * x_1) =\n                    OneHom.toFun\n                      { toFun := ((Set.inclusion h)), map_one' := (((rfl=:Set.inclusion h 1 = Set.inclusion h 1))) }\n                      (x * x_1)))) })\n        0 :\n  Prop)", "type": "∀ {R : Type u_2} {A : Type u_1} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\n  {S : Subalgebra R A} {T : Subalgebra R A} (h : S ≤ T),\n  OneHom.toFun\n      (↑{ toOneHom := (({ toFun := ((Set.inclusion h)), map_one' := ((rfl)) })),\n          map_mul' := (((fun (x : { x : A // x ∈ S }) (x_1 : { x : A // x ∈ S }) ↦ rfl))) })\n      0 =\n    OneHom.toFun\n      (↑{ toOneHom := (({ toFun := ((Set.inclusion h)), map_one' := ((rfl)) })),\n          map_mul' := (((fun (x : { x : A // x ∈ S }) (x_1 : { x : A // x ∈ S }) ↦ rfl))) })\n      0", "thm": " : ∀ {R : Type u_2} {A : Type u_1} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\n  {S : Subalgebra R A} {T : Subalgebra R A} (h : S ≤ T),\n  OneHom.toFun\n      (↑{ toOneHom := (({ toFun := ((Set.inclusion h)), map_one' := ((rfl)) })),\n          map_mul' := (((fun (x : { x : A // x ∈ S }) (x_1 : { x : A // x ∈ S }) ↦ rfl))) })\n      0 =\n    OneHom.toFun\n      (↑{ toOneHom := (({ toFun := ((Set.inclusion h)), map_one' := ((rfl)) })),\n          map_mul' := (((fun (x : { x : A // x ∈ S }) (x_1 : { x : A // x ∈ S }) ↦ rfl))) })\n      0", "terms": [], "namedLemmas": ["∀ {α : Sort u} {a : α}, a = a"], "lemmas": [], "ids": ["rfl"], "idString": "rfl; ", "context": []}
{"typeGroup": "(∀ {R : Type u_5} [inst : Semiring R] {C : Type u_1} {D : Type u_3} [inst_1 : CategoryTheory.Category C]\n    [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.Preadditive D] [inst_4 : CategoryTheory.Linear R D]\n    {F : CategoryTheory.Functor C D} {G : CategoryTheory.Functor C D} (X : C) (x : R) (x_1 : F ⟶ G),\n    AddHom.toFun\n        { toFun := ((fun (α : F ⟶ G) ↦ CategoryTheory.NatTrans.app α X)),\n          map_add' :=\n            (((fun (x : F ⟶ G) ↦\n              (_ :\n                ∀ (x_2 : F ⟶ G),\n                  (fun (α : F ⟶ G) ↦ CategoryTheory.NatTrans.app α X) (x + x_2) =\n                    (fun (α : F ⟶ G) ↦ CategoryTheory.NatTrans.app α X)\n                      (x +\n                        x_2))=:∀ (x : F ⟶ G) (x_2 : F ⟶ G),\n                (fun (α : F ⟶ G) ↦ CategoryTheory.NatTrans.app α X) (x + x_2) =\n                  (fun (α : F ⟶ G) ↦ CategoryTheory.NatTrans.app α X) (x + x_2)))) }\n        (x • x_1) =\n      AddHom.toFun\n        { toFun := ((fun (α : F ⟶ G) ↦ CategoryTheory.NatTrans.app α X)),\n          map_add' :=\n            (((fun (x : F ⟶ G) ↦\n              (_ :\n                ∀ (x_2 : F ⟶ G),\n                  (fun (α : F ⟶ G) ↦ CategoryTheory.NatTrans.app α X) (x + x_2) =\n                    (fun (α : F ⟶ G) ↦ CategoryTheory.NatTrans.app α X)\n                      (x +\n                        x_2))=:∀ (x : F ⟶ G) (x_2 : F ⟶ G),\n                (fun (α : F ⟶ G) ↦ CategoryTheory.NatTrans.app α X) (x + x_2) =\n                  (fun (α : F ⟶ G) ↦ CategoryTheory.NatTrans.app α X) (x + x_2)))) }\n        (x • x_1) :\n  Prop)", "type": "∀ {R : Type u_5} [inst : Semiring R] {C : Type u_1} {D : Type u_3} [inst_1 : CategoryTheory.Category C]\n  [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.Preadditive D] [inst_4 : CategoryTheory.Linear R D]\n  {F : CategoryTheory.Functor C D} {G : CategoryTheory.Functor C D} (X : C) (x : R) (x_1 : F ⟶ G),\n  AddHom.toFun\n      { toFun := ((fun (α : F ⟶ G) ↦ CategoryTheory.NatTrans.app α X)),\n        map_add' := (((fun (x : F ⟶ G) (x_2 : F ⟶ G) ↦ rfl))) }\n      (x • x_1) =\n    AddHom.toFun\n      { toFun := ((fun (α : F ⟶ G) ↦ CategoryTheory.NatTrans.app α X)),\n        map_add' := (((fun (x : F ⟶ G) (x_2 : F ⟶ G) ↦ rfl))) }\n      (x • x_1)", "thm": " : ∀ {R : Type u_5} [inst : Semiring R] {C : Type u_1} {D : Type u_3} [inst_1 : CategoryTheory.Category C]\n  [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.Preadditive D] [inst_4 : CategoryTheory.Linear R D]\n  {F : CategoryTheory.Functor C D} {G : CategoryTheory.Functor C D} (X : C) (x : R) (x_1 : F ⟶ G),\n  AddHom.toFun\n      { toFun := ((fun (α : F ⟶ G) ↦ CategoryTheory.NatTrans.app α X)),\n        map_add' := (((fun (x : F ⟶ G) (x_2 : F ⟶ G) ↦ rfl))) }\n      (x • x_1) =\n    AddHom.toFun\n      { toFun := ((fun (α : F ⟶ G) ↦ CategoryTheory.NatTrans.app α X)),\n        map_add' := (((fun (x : F ⟶ G) (x_2 : F ⟶ G) ↦ rfl))) }\n      (x • x_1)", "terms": [], "namedLemmas": ["∀ {α : Sort u} {a : α}, a = a"], "lemmas": [], "ids": ["rfl"], "idString": "rfl; ", "context": []}
{"typeGroup": "(∀ {V : Type u_2} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] {A : V} {B : V}\n    {C : V} [inst_2 : CategoryTheory.Limits.HasZeroObject V] [inst_3 : CategoryTheory.Limits.HasImage 0],\n    CategoryTheory.CategoryStruct.comp\n        (imageToKernel 0 0 (CategoryTheory.Limits.zero_comp=:CategoryTheory.CategoryStruct.comp 0 0 = 0))\n        (CategoryTheory.Subobject.arrow (CategoryTheory.Limits.kernelSubobject 0)) =\n      0 :\n  Prop)", "type": "∀ {V : Type u_2} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] {A : V} {B : V}\n  {C : V} [inst_2 : CategoryTheory.Limits.HasZeroObject V] [inst_3 : CategoryTheory.Limits.HasImage 0],\n  CategoryTheory.CategoryStruct.comp (imageToKernel 0 0 CategoryTheory.Limits.zero_comp)\n      (CategoryTheory.Subobject.arrow (CategoryTheory.Limits.kernelSubobject 0)) =\n    0", "thm": " : ∀ {V : Type u_2} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] {A : V} {B : V}\n  {C : V} [inst_2 : CategoryTheory.Limits.HasZeroObject V] [inst_3 : CategoryTheory.Limits.HasImage 0],\n  CategoryTheory.CategoryStruct.comp (imageToKernel 0 0 CategoryTheory.Limits.zero_comp)\n      (CategoryTheory.Subobject.arrow (CategoryTheory.Limits.kernelSubobject 0)) =\n    0", "terms": [], "namedLemmas": ["∀ {p : Prop}, p = True → p", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] {A B C : V}\n  (f : A ⟶ B) [inst_2 : CategoryTheory.Limits.HasImage f] (g : B ⟶ C) [inst_3 : CategoryTheory.Limits.HasKernel g]\n  (w : CategoryTheory.CategoryStruct.comp f g = 0),\n  CategoryTheory.CategoryStruct.comp (imageToKernel f g w)\n      (CategoryTheory.Subobject.arrow (CategoryTheory.Limits.kernelSubobject g)) =\n    CategoryTheory.Subobject.arrow (CategoryTheory.Limits.imageSubobject f)", "∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X Y Z : C}\n  {f : Y ⟶ Z}, CategoryTheory.CategoryStruct.comp 0 f = 0", "∀ {C : Type u} [inst : CategoryTheory.Category C] {X Y : C} [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasZeroObject C],\n  CategoryTheory.Subobject.arrow (CategoryTheory.Limits.imageSubobject 0) = 0", "∀ {α : Sort u_1} (a : α), (a = a) = True"], "lemmas": [{"prop": "CategoryTheory.CategoryStruct.comp 0 0 = 0", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "{A : V}", "{B : V}", "{C : V}", "[CategoryTheory.Limits.HasZeroObject V]", "[CategoryTheory.Limits.HasImage 0]"]}, {"prop": "CategoryTheory.CategoryStruct.comp (imageToKernel 0 0 CategoryTheory.Limits.zero_comp)\n    (CategoryTheory.Subobject.arrow (CategoryTheory.Limits.kernelSubobject 0)) =\n  CategoryTheory.Subobject.arrow (CategoryTheory.Limits.imageSubobject 0)", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "{A : V}", "{B : V}", "{C : V}", "[CategoryTheory.Limits.HasZeroObject V]", "[CategoryTheory.Limits.HasImage 0]"]}, {"prop": "CategoryTheory.Subobject.arrow (CategoryTheory.Limits.imageSubobject 0) = 0", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "{A : V}", "{B : V}", "{C : V}", "[CategoryTheory.Limits.HasZeroObject V]", "[CategoryTheory.Limits.HasImage 0]"]}, {"prop": "CategoryTheory.CategoryStruct.comp (imageToKernel 0 0 CategoryTheory.Limits.zero_comp)\n    (CategoryTheory.Subobject.arrow (CategoryTheory.Limits.kernelSubobject 0)) =\n  0", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "{A : V}", "{B : V}", "{C : V}", "[CategoryTheory.Limits.HasZeroObject V]", "[CategoryTheory.Limits.HasImage 0]"]}, {"prop": "Eq\n    (CategoryTheory.CategoryStruct.comp (imageToKernel 0 0 CategoryTheory.Limits.zero_comp)\n      (CategoryTheory.Subobject.arrow (CategoryTheory.Limits.kernelSubobject 0))) =\n  Eq 0", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "{A : V}", "{B : V}", "{C : V}", "[CategoryTheory.Limits.HasZeroObject V]", "[CategoryTheory.Limits.HasImage 0]"]}, {"prop": "(CategoryTheory.CategoryStruct.comp (imageToKernel 0 0 CategoryTheory.Limits.zero_comp)\n      (CategoryTheory.Subobject.arrow (CategoryTheory.Limits.kernelSubobject 0)) =\n    0) =\n  (0 = 0)", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "{A : V}", "{B : V}", "{C : V}", "[CategoryTheory.Limits.HasZeroObject V]", "[CategoryTheory.Limits.HasImage 0]"]}, {"prop": "(0 = 0) = True", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "{A : V}", "{B : V}", "{C : V}", "[CategoryTheory.Limits.HasZeroObject V]", "[CategoryTheory.Limits.HasImage 0]"]}, {"prop": "(CategoryTheory.CategoryStruct.comp (imageToKernel 0 0 CategoryTheory.Limits.zero_comp)\n      (CategoryTheory.Subobject.arrow (CategoryTheory.Limits.kernelSubobject 0)) =\n    0) =\n  True", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "{A : V}", "{B : V}", "{C : V}", "[CategoryTheory.Limits.HasZeroObject V]", "[CategoryTheory.Limits.HasImage 0]"]}], "ids": ["of_eq_true", "Eq.trans", "congrFun", "congrArg", "Eq", "Eq.trans", "imageToKernel_arrow", "CategoryTheory.Limits.zero_comp", "CategoryTheory.Limits.imageSubobject_zero_arrow", "eq_self"], "idString": "of_eq_true; Eq.trans; congrFun; congrArg; Eq; Eq.trans; imageToKernel_arrow; CategoryTheory.Limits.zero_comp; CategoryTheory.Limits.imageSubobject_zero_arrow; eq_self; ", "context": []}
{"typeGroup": "(∀ {C : Type u} [inst : CategoryTheory.Category C] {X : TopCat} (F : TopCat.Sheaf C X) (U : TopologicalSpace.Opens ↑X)\n    (V : TopologicalSpace.Opens ↑X),\n    CategoryTheory.Limits.PullbackCone.fst (TopCat.Sheaf.interUnionPullbackCone F U V) =\n      (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Sheaf.val F)).map\n        (CategoryTheory.homOfLE (le_sup_left=:U ≤ U ⊔ V)).op :\n  Prop)", "type": "∀ {C : Type u} [inst : CategoryTheory.Category C] {X : TopCat} (F : TopCat.Sheaf C X) (U : TopologicalSpace.Opens ↑X)\n  (V : TopologicalSpace.Opens ↑X),\n  CategoryTheory.Limits.PullbackCone.fst (TopCat.Sheaf.interUnionPullbackCone F U V) =\n    CategoryTheory.Limits.PullbackCone.fst (TopCat.Sheaf.interUnionPullbackCone F U V)", "thm": " : ∀ {C : Type u} [inst : CategoryTheory.Category C] {X : TopCat} (F : TopCat.Sheaf C X) (U : TopologicalSpace.Opens ↑X)\n  (V : TopologicalSpace.Opens ↑X),\n  CategoryTheory.Limits.PullbackCone.fst (TopCat.Sheaf.interUnionPullbackCone F U V) =\n    CategoryTheory.Limits.PullbackCone.fst (TopCat.Sheaf.interUnionPullbackCone F U V)", "terms": [], "namedLemmas": ["∀ {α : Sort u} {a : α}, a = a"], "lemmas": [], "ids": ["rfl"], "idString": "rfl; ", "context": []}
{"typeGroup": "(∀ {C : Type u_2} [inst : CategoryTheory.Category C] {X₁ : C} {X₂ : C} {X₃ : C} {Y₁ : C} {Y₂ : C} (f₁ : X₁ ⟶ Y₁)\n    (f₂ : X₂ ⟶ Y₁) (f₃ : X₂ ⟶ Y₂) (f₄ : X₃ ⟶ Y₂) [inst_1 : CategoryTheory.Limits.HasPullback f₁ f₂]\n    [inst_2 : CategoryTheory.Limits.HasPullback f₃ f₄]\n    [inst_3 :\n      CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)],\n    CategoryTheory.CategoryStruct.comp\n        (CategoryTheory.Limits.pullback.lift CategoryTheory.Limits.pullback.fst\n          (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst)\n          (Eq.trans\n              (CategoryTheory.Limits.pullback.condition=:CategoryTheory.CategoryStruct.comp\n                    CategoryTheory.Limits.pullback.fst f₁ =\n                  CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n                    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂))\n              (Eq.symm\n                  (CategoryTheory.Category.assoc CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst\n                      f₂=:CategoryTheory.CategoryStruct.comp\n                        (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n                          CategoryTheory.Limits.pullback.fst)\n                        f₂ =\n                      CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n                        (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst\n                          f₂))=:CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n                    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂) =\n                  CategoryTheory.CategoryStruct.comp\n                    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n                      CategoryTheory.Limits.pullback.fst)\n                    f₂)=:CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₁ =\n              CategoryTheory.CategoryStruct.comp\n                (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n                  CategoryTheory.Limits.pullback.fst)\n                f₂))\n        CategoryTheory.Limits.pullback.snd =\n      CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst :\n  Prop)", "type": "∀ {C : Type u_2} [inst : CategoryTheory.Category C] {X₁ : C} {X₂ : C} {X₃ : C} {Y₁ : C} {Y₂ : C} (f₁ : X₁ ⟶ Y₁)\n  (f₂ : X₂ ⟶ Y₁) (f₃ : X₂ ⟶ Y₂) (f₄ : X₃ ⟶ Y₂) [inst_1 : CategoryTheory.Limits.HasPullback f₁ f₂]\n  [inst_2 : CategoryTheory.Limits.HasPullback f₃ f₄]\n  [inst_3 :\n    CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)],\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.Limits.pullback.lift CategoryTheory.Limits.pullback.fst\n        (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst)\n        (Eq.trans CategoryTheory.Limits.pullback.condition\n          (Eq.symm\n            (CategoryTheory.Category.assoc CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst f₂))))\n      CategoryTheory.Limits.pullback.snd =\n    CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst", "thm": " : ∀ {C : Type u_2} [inst : CategoryTheory.Category C] {X₁ : C} {X₂ : C} {X₃ : C} {Y₁ : C} {Y₂ : C} (f₁ : X₁ ⟶ Y₁)\n  (f₂ : X₂ ⟶ Y₁) (f₃ : X₂ ⟶ Y₂) (f₄ : X₃ ⟶ Y₂) [inst_1 : CategoryTheory.Limits.HasPullback f₁ f₂]\n  [inst_2 : CategoryTheory.Limits.HasPullback f₃ f₄]\n  [inst_3 :\n    CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)],\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.Limits.pullback.lift CategoryTheory.Limits.pullback.fst\n        (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst)\n        (Eq.trans CategoryTheory.Limits.pullback.condition\n          (Eq.symm\n            (CategoryTheory.Category.assoc CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst f₂))))\n      CategoryTheory.Limits.pullback.snd =\n    CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst", "terms": [{"value": "CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst", "isProp": false, "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{X₁ : C}", "{X₂ : C}", "{X₃ : C}", "{Y₁ : C}", "{Y₂ : C}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₁)", "(f₃ : X₂ ⟶ Y₂)", "(f₄ : X₃ ⟶ Y₂)", "[CategoryTheory.Limits.HasPullback f₁ f₂]", "[CategoryTheory.Limits.HasPullback f₃ f₄]", "[CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)]"]}], "namedLemmas": ["∀ {C : Type u} [inst : CategoryTheory.Category C] {W X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z}\n  [inst_1 : CategoryTheory.Limits.HasPullback f g] (h : W ⟶ X) (k : W ⟶ Y)\n  (w : CategoryTheory.CategoryStruct.comp h f = CategoryTheory.CategoryStruct.comp k g),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.lift h k w) CategoryTheory.Limits.pullback.snd = k", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {C : Type u} [inst : CategoryTheory.Category C] {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z}\n  [inst_1 : CategoryTheory.Limits.HasPullback f g],\n  CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f =\n    CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd g", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {obj : Type u} [self : CategoryTheory.Category obj] {W X Y Z : obj} (f : W ⟶ X) (g : X ⟶ Y) (h : Y ⟶ Z),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g) h =\n    CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g h)"], "lemmas": [{"prop": "CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₁ =\n  CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{X₁ : C}", "{X₂ : C}", "{X₃ : C}", "{Y₁ : C}", "{Y₂ : C}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₁)", "(f₃ : X₂ ⟶ Y₂)", "(f₄ : X₃ ⟶ Y₂)", "[CategoryTheory.Limits.HasPullback f₁ f₂]", "[CategoryTheory.Limits.HasPullback f₃ f₄]", "[CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)]"]}, {"prop": "CategoryTheory.CategoryStruct.comp\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst) f₂ =\n  CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{X₁ : C}", "{X₂ : C}", "{X₃ : C}", "{Y₁ : C}", "{Y₂ : C}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₁)", "(f₃ : X₂ ⟶ Y₂)", "(f₄ : X₃ ⟶ Y₂)", "[CategoryTheory.Limits.HasPullback f₁ f₂]", "[CategoryTheory.Limits.HasPullback f₃ f₄]", "[CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)]"]}, {"prop": "CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂) =\n  CategoryTheory.CategoryStruct.comp\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst) f₂", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{X₁ : C}", "{X₂ : C}", "{X₃ : C}", "{Y₁ : C}", "{Y₂ : C}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₁)", "(f₃ : X₂ ⟶ Y₂)", "(f₄ : X₃ ⟶ Y₂)", "[CategoryTheory.Limits.HasPullback f₁ f₂]", "[CategoryTheory.Limits.HasPullback f₃ f₄]", "[CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)]"]}, {"prop": "CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₁ =\n  CategoryTheory.CategoryStruct.comp\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst) f₂", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{X₁ : C}", "{X₂ : C}", "{X₃ : C}", "{Y₁ : C}", "{Y₂ : C}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₁)", "(f₃ : X₂ ⟶ Y₂)", "(f₄ : X₃ ⟶ Y₂)", "[CategoryTheory.Limits.HasPullback f₁ f₂]", "[CategoryTheory.Limits.HasPullback f₃ f₄]", "[CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)]"]}], "ids": ["CategoryTheory.Limits.pullback.lift_snd", "CategoryTheory.Limits.pullback.fst", "CategoryTheory.CategoryStruct.comp", "CategoryTheory.Limits.pullback.snd", "CategoryTheory.Limits.pullback.fst", "Eq.trans", "CategoryTheory.Limits.pullback.condition", "Eq.symm", "CategoryTheory.Category.assoc", "CategoryTheory.Limits.pullback.snd", "CategoryTheory.Limits.pullback.fst"], "idString": "CategoryTheory.Limits.pullback.lift_snd; CategoryTheory.Limits.pullback.fst; CategoryTheory.CategoryStruct.comp; CategoryTheory.Limits.pullback.snd; CategoryTheory.Limits.pullback.fst; Eq.trans; CategoryTheory.Limits.pullback.condition; Eq.symm; CategoryTheory.Category.assoc; CategoryTheory.Limits.pullback.snd; CategoryTheory.Limits.pullback.fst; ", "context": []}
{"typeGroup": "(∀ {C : Type u_2} [inst : CategoryTheory.Category C] {X₁ : C} {X₂ : C} {X₃ : C} {Y₁ : C} {Y₂ : C} (f₁ : X₁ ⟶ Y₁)\n    (f₂ : X₂ ⟶ Y₁) (f₃ : X₂ ⟶ Y₂) (f₄ : X₃ ⟶ Y₂) [inst_1 : CategoryTheory.Limits.HasPullback f₁ f₂]\n    [inst_2 : CategoryTheory.Limits.HasPullback f₃ f₄]\n    [inst_3 :\n      CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)],\n    CategoryTheory.CategoryStruct.comp\n        (CategoryTheory.Limits.pullback.lift CategoryTheory.Limits.pullback.fst\n          (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst)\n          (Eq.trans\n              (CategoryTheory.Limits.pullback.condition=:CategoryTheory.CategoryStruct.comp\n                    CategoryTheory.Limits.pullback.fst f₁ =\n                  CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n                    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂))\n              (Eq.symm\n                  (CategoryTheory.Category.assoc CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst\n                      f₂=:CategoryTheory.CategoryStruct.comp\n                        (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n                          CategoryTheory.Limits.pullback.fst)\n                        f₂ =\n                      CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n                        (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst\n                          f₂))=:CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n                    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂) =\n                  CategoryTheory.CategoryStruct.comp\n                    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n                      CategoryTheory.Limits.pullback.fst)\n                    f₂)=:CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₁ =\n              CategoryTheory.CategoryStruct.comp\n                (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n                  CategoryTheory.Limits.pullback.fst)\n                f₂))\n        CategoryTheory.Limits.pullback.snd =\n      CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst :\n  Prop)", "type": "CategoryTheory.CategoryStruct.comp\n    (CategoryTheory.Limits.pullback.lift CategoryTheory.Limits.pullback.fst\n      (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst)\n      (Eq.trans CategoryTheory.Limits.pullback.condition\n        (Eq.symm\n          (CategoryTheory.Category.assoc CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst f₂))))\n    CategoryTheory.Limits.pullback.snd =\n  CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst", "thm": "{C : Type u_2} [CategoryTheory.Category C] {X₁ : C} {X₂ : C} {X₃ : C} {Y₁ : C} {Y₂ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₁) (f₃ : X₂ ⟶ Y₂) (f₄ : X₃ ⟶ Y₂) [CategoryTheory.Limits.HasPullback f₁ f₂] [CategoryTheory.Limits.HasPullback f₃ f₄] [CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)]  : CategoryTheory.CategoryStruct.comp\n    (CategoryTheory.Limits.pullback.lift CategoryTheory.Limits.pullback.fst\n      (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst)\n      (Eq.trans CategoryTheory.Limits.pullback.condition\n        (Eq.symm\n          (CategoryTheory.Category.assoc CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst f₂))))\n    CategoryTheory.Limits.pullback.snd =\n  CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst", "terms": [{"value": "CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst", "isProp": false, "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{X₁ : C}", "{X₂ : C}", "{X₃ : C}", "{Y₁ : C}", "{Y₂ : C}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₁)", "(f₃ : X₂ ⟶ Y₂)", "(f₄ : X₃ ⟶ Y₂)", "[CategoryTheory.Limits.HasPullback f₁ f₂]", "[CategoryTheory.Limits.HasPullback f₃ f₄]", "[CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)]"]}], "namedLemmas": ["∀ {C : Type u} [inst : CategoryTheory.Category C] {W X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z}\n  [inst_1 : CategoryTheory.Limits.HasPullback f g] (h : W ⟶ X) (k : W ⟶ Y)\n  (w : CategoryTheory.CategoryStruct.comp h f = CategoryTheory.CategoryStruct.comp k g),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.lift h k w) CategoryTheory.Limits.pullback.snd = k", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {C : Type u} [inst : CategoryTheory.Category C] {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z}\n  [inst_1 : CategoryTheory.Limits.HasPullback f g],\n  CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f =\n    CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd g", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {obj : Type u} [self : CategoryTheory.Category obj] {W X Y Z : obj} (f : W ⟶ X) (g : X ⟶ Y) (h : Y ⟶ Z),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g) h =\n    CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g h)"], "lemmas": [{"prop": "CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₁ =\n  CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{X₁ : C}", "{X₂ : C}", "{X₃ : C}", "{Y₁ : C}", "{Y₂ : C}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₁)", "(f₃ : X₂ ⟶ Y₂)", "(f₄ : X₃ ⟶ Y₂)", "[CategoryTheory.Limits.HasPullback f₁ f₂]", "[CategoryTheory.Limits.HasPullback f₃ f₄]", "[CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)]"]}, {"prop": "CategoryTheory.CategoryStruct.comp\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst) f₂ =\n  CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{X₁ : C}", "{X₂ : C}", "{X₃ : C}", "{Y₁ : C}", "{Y₂ : C}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₁)", "(f₃ : X₂ ⟶ Y₂)", "(f₄ : X₃ ⟶ Y₂)", "[CategoryTheory.Limits.HasPullback f₁ f₂]", "[CategoryTheory.Limits.HasPullback f₃ f₄]", "[CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)]"]}, {"prop": "CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂) =\n  CategoryTheory.CategoryStruct.comp\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst) f₂", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{X₁ : C}", "{X₂ : C}", "{X₃ : C}", "{Y₁ : C}", "{Y₂ : C}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₁)", "(f₃ : X₂ ⟶ Y₂)", "(f₄ : X₃ ⟶ Y₂)", "[CategoryTheory.Limits.HasPullback f₁ f₂]", "[CategoryTheory.Limits.HasPullback f₃ f₄]", "[CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)]"]}, {"prop": "CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₁ =\n  CategoryTheory.CategoryStruct.comp\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd CategoryTheory.Limits.pullback.fst) f₂", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{X₁ : C}", "{X₂ : C}", "{X₃ : C}", "{Y₁ : C}", "{Y₂ : C}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₁)", "(f₃ : X₂ ⟶ Y₂)", "(f₄ : X₃ ⟶ Y₂)", "[CategoryTheory.Limits.HasPullback f₁ f₂]", "[CategoryTheory.Limits.HasPullback f₃ f₄]", "[CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)]"]}], "ids": ["CategoryTheory.Limits.pullback.lift_snd", "CategoryTheory.Limits.pullback.fst", "CategoryTheory.CategoryStruct.comp", "CategoryTheory.Limits.pullback.snd", "CategoryTheory.Limits.pullback.fst", "Eq.trans", "CategoryTheory.Limits.pullback.condition", "Eq.symm", "CategoryTheory.Category.assoc", "CategoryTheory.Limits.pullback.snd", "CategoryTheory.Limits.pullback.fst"], "idString": "CategoryTheory.Limits.pullback.lift_snd; CategoryTheory.Limits.pullback.fst; CategoryTheory.CategoryStruct.comp; CategoryTheory.Limits.pullback.snd; CategoryTheory.Limits.pullback.fst; Eq.trans; CategoryTheory.Limits.pullback.condition; Eq.symm; CategoryTheory.Category.assoc; CategoryTheory.Limits.pullback.snd; CategoryTheory.Limits.pullback.fst; ", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{X₁ : C}", "{X₂ : C}", "{X₃ : C}", "{Y₁ : C}", "{Y₂ : C}", "(f₁ : X₁ ⟶ Y₁)", "(f₂ : X₂ ⟶ Y₁)", "(f₃ : X₂ ⟶ Y₂)", "(f₄ : X₃ ⟶ Y₂)", "[CategoryTheory.Limits.HasPullback f₁ f₂]", "[CategoryTheory.Limits.HasPullback f₃ f₄]", "[CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f₂)]"]}
{"typeGroup": "(∀ {α : Type u_1} [inst : AddGroup α] {s : AddSubgroup α} (g : α) (x : { x : α // x ∈ s }),\n    (fun (x : ↑(leftAddCoset g ↑s)) ↦\n          { val := ((-g + ↑x)),\n            property :=\n              (((Iff.mp (mem_leftAddCoset_iff g=:(↑x ∈ leftAddCoset g ↑s : Prop) ↔ (-g + ↑x ∈ ↑s : Prop))\n                  (Subtype.property x=:↑x ∈ leftAddCoset g ↑s)=:-g + ↑x ∈ ↑s))) })\n        ((fun (x : { x : α // x ∈ s }) ↦\n            { val := ((g + ↑x)),\n              property :=\n                (((Exists.intro ↑x\n                    ({ left := (((Subtype.property x=:↑x ∈ s))),\n                        right :=\n                          (((rfl=:(fun (x : α) ↦ g + x) ↑x =\n                              (fun (x : α) ↦ g + x)\n                                ↑x))) }=:(↑x ∈ ↑s : Prop) ∧\n                        ((fun (x : α) ↦ g + x) ↑x = g + ↑x :\n                          Prop))=:∃ (a : α), (a ∈ ↑s : Prop) ∧ ((fun (x : α) ↦ g + x) a = g + ↑x : Prop)))) })\n          x) =\n      x :\n  Prop)", "type": "∀ {α : Type u_1} [inst : AddGroup α] {s : AddSubgroup α} (g : α) (x : { x : α // x ∈ s }),\n  (fun (x : ↑(leftAddCoset g ↑s)) ↦\n        { val := ((-g + ↑x)), property := (((Iff.mp (mem_leftAddCoset_iff g) (Subtype.property x)))) })\n      ((fun (x : { x : α // x ∈ s }) ↦\n          { val := ((g + ↑x)),\n            property := (((Exists.intro ↑x ({ left := (((Subtype.property x))), right := ((rfl)) })))) })\n        x) =\n    x", "thm": " : ∀ {α : Type u_1} [inst : AddGroup α] {s : AddSubgroup α} (g : α) (x : { x : α // x ∈ s }),\n  (fun (x : ↑(leftAddCoset g ↑s)) ↦\n        { val := ((-g + ↑x)), property := (((Iff.mp (mem_leftAddCoset_iff g) (Subtype.property x)))) })\n      ((fun (x : { x : α // x ∈ s }) ↦\n          { val := ((g + ↑x)),\n            property := (((Exists.intro ↑x ({ left := (((Subtype.property x))), right := ((rfl)) })))) })\n        x) =\n    x", "terms": [{"value": "↑x", "isProp": false, "context": ["{α : Type u_1}", "[AddGroup α]", "{s : AddSubgroup α}", "(g : α)", "(x : { x : α // x ∈ s })", "(x : { x : α // x ∈ s })", "(x : { x : α // x ∈ s })"]}, {"value": "(fun (x : { x : α // x ∈ s }) ↦\n    { val := ((g + ↑x)), property := (((Exists.intro ↑x ({ left := (((Subtype.property x))), right := ((rfl)) })))) })\n  x", "isProp": false, "context": ["{α : Type u_1}", "[AddGroup α]", "{s : AddSubgroup α}", "(g : α)", "(x : { x : α // x ∈ s })", "(x : { x : α // x ∈ s })"]}], "namedLemmas": ["∀ {α : Type u_1} [inst : AddGroup α] {s : AddSubgroup α} (motive : { x // x ∈ s } → Prop) (x : { x // x ∈ s }),\n  (∀ (g : α) (hg : g ∈ s), motive { val := g, property := hg }) → motive x", "∀ {a b : Prop}, (a ↔ b) → a → b", "∀ {α : Type u_1} [inst : AddGroup α] {s : Set α} {x : α} (a : α), x ∈ leftAddCoset a s ↔ -a + x ∈ s", "∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self", "∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self", "∀ {α : Sort u} {a : α}, a = a", "∀ {α : Type u} {p : α → Prop} {a1 a2 : { x // p x }}, ↑a1 = ↑a2 → a1 = a2", "∀ {p : Prop}, p = True → p", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {G : Type u_1} [inst : AddGroup G] (a b : G), -a + (a + b) = b", "∀ {α : Sort u_1} (a : α), (a = a) = True"], "lemmas": [{"prop": "(↑x ∈ leftAddCoset g ↑s) ↔ (-g + ↑x ∈ ↑s)", "context": ["{α : Type u_1}", "[AddGroup α]", "{s : AddSubgroup α}", "(g : α)", "(x : { x : α // x ∈ s })", "(x : { x : α // x ∈ s })", "(x : ↑(leftAddCoset g ↑s))"]}, {"prop": "↑x ∈ leftAddCoset g ↑s", "context": ["{α : Type u_1}", "[AddGroup α]", "{s : AddSubgroup α}", "(g : α)", "(x : { x : α // x ∈ s })", "(x : { x : α // x ∈ s })", "(x : ↑(leftAddCoset g ↑s))"]}, {"prop": "-g + ↑x ∈ ↑s", "context": ["{α : Type u_1}", "[AddGroup α]", "{s : AddSubgroup α}", "(g : α)", "(x : { x : α // x ∈ s })", "(x : { x : α // x ∈ s })", "(x : ↑(leftAddCoset g ↑s))"]}, {"prop": "↑x ∈ s", "context": ["{α : Type u_1}", "[AddGroup α]", "{s : AddSubgroup α}", "(g : α)", "(x : { x : α // x ∈ s })", "(x : { x : α // x ∈ s })", "(x : { x : α // x ∈ s })"]}, {"prop": "(fun (x : α) ↦ g + x) ↑x = (fun (x : α) ↦ g + x) ↑x", "context": ["{α : Type u_1}", "[AddGroup α]", "{s : AddSubgroup α}", "(g : α)", "(x : { x : α // x ∈ s })", "(x : { x : α // x ∈ s })", "(x : { x : α // x ∈ s })"]}, {"prop": "(↑x ∈ ↑s) ∧ ((fun (x : α) ↦ g + x) ↑x = g + ↑x)", "context": ["{α : Type u_1}", "[AddGroup α]", "{s : AddSubgroup α}", "(g : α)", "(x : { x : α // x ∈ s })", "(x : { x : α // x ∈ s })", "(x : { x : α // x ∈ s })"]}, {"prop": "∃ (a : α), (a ∈ ↑s) ∧ ((fun (x : α) ↦ g + x) a = g + ↑x)", "context": ["{α : Type u_1}", "[AddGroup α]", "{s : AddSubgroup α}", "(g : α)", "(x : { x : α // x ∈ s })", "(x : { x : α // x ∈ s })", "(x : { x : α // x ∈ s })"]}, {"prop": "-g + (g + g_1) = g_1", "context": ["{α : Type u_1}", "[AddGroup α]", "{s : AddSubgroup α}", "(g : α)", "(x : { x : α // x ∈ s })", "(g_1 : α)", "(hg : g_1 ∈ s)"]}, {"prop": "Eq (-g + (g + g_1)) = Eq g_1", "context": ["{α : Type u_1}", "[AddGroup α]", "{s : AddSubgroup α}", "(g : α)", "(x : { x : α // x ∈ s })", "(g_1 : α)", "(hg : g_1 ∈ s)"]}, {"prop": "(-g + (g + g_1) = g_1) = (g_1 = g_1)", "context": ["{α : Type u_1}", "[AddGroup α]", "{s : AddSubgroup α}", "(g : α)", "(x : { x : α // x ∈ s })", "(g_1 : α)", "(hg : g_1 ∈ s)"]}, {"prop": "(g_1 = g_1) = True", "context": ["{α : Type u_1}", "[AddGroup α]", "{s : AddSubgroup α}", "(g : α)", "(x : { x : α // x ∈ s })", "(g_1 : α)", "(hg : g_1 ∈ s)"]}, {"prop": "(-g + (g + g_1) = g_1) = True", "context": ["{α : Type u_1}", "[AddGroup α]", "{s : AddSubgroup α}", "(g : α)", "(x : { x : α // x ∈ s })", "(g_1 : α)", "(hg : g_1 ∈ s)"]}, {"prop": "-g + (g + g_1) = g_1", "context": ["{α : Type u_1}", "[AddGroup α]", "{s : AddSubgroup α}", "(g : α)", "(x : { x : α // x ∈ s })", "(g_1 : α)", "(hg : g_1 ∈ s)"]}, {"prop": "∀ (g_1 : α) (hg : g_1 ∈ s),\n  (fun (x : ↑(leftAddCoset g ↑s)) ↦\n        { val := ((-g + ↑x)), property := (((Iff.mp (mem_leftAddCoset_iff g) (Subtype.property x)))) })\n      ((fun (x : { x : α // x ∈ s }) ↦\n          { val := ((g + ↑x)),\n            property := (((Exists.intro ↑x ({ left := (((Subtype.property x))), right := ((rfl)) })))) })\n        { val := ((g_1)), property := ((hg)) }) =\n    { val := ((g_1)), property := ((hg)) }", "context": ["{α : Type u_1}", "[AddGroup α]", "{s : AddSubgroup α}", "(g : α)", "(x : { x : α // x ∈ s })"]}], "ids": ["AddSubgroup.leftCosetEquivAddSubgroup.match_2", "val", "property", "Iff.mp", "mem_leftAddCoset_iff", "Subtype.property", "val", "property", "Exists.intro", "left", "Subtype.property", "right", "rfl", "Subtype.eq", "of_eq_true", "Eq.trans", "congrFun", "congrArg", "Eq", "neg_add_cancel_left", "eq_self"], "idString": "AddSubgroup.leftCosetEquivAddSubgroup.match_2; val; property; Iff.mp; mem_leftAddCoset_iff; Subtype.property; val; property; Exists.intro; left; Subtype.property; right; rfl; Subtype.eq; of_eq_true; Eq.trans; congrFun; congrArg; Eq; neg_add_cancel_left; eq_self; ", "context": []}
{"typeGroup": "(∀ {α : Type u_1} [inst : AddCommMonoid α] (s : Multiset α),\n    Multiset.noncommSum s\n        (fun (x : α) ↦\n          (_ :\n            ∀ (x_1 : x ∈ {x : α | x ∈ s}) (x_2 : α) (x_3 : x_2 ∈ {x : α | x ∈ s}) (x_4 : x ≠ x_2),\n              AddCommute x\n                x_2)=:∀ (x : α) (x_1 : x ∈ {x : α | x ∈ s}) (x_2 : α) (x_3 : x_2 ∈ {x : α | x ∈ s}) (x_4 : x ≠ x_2),\n            AddCommute x x_2) =\n      Multiset.sum s :\n  Prop)", "type": "∀ {α : Type u_1} [inst : AddCommMonoid α] (s : Multiset α),\n  Multiset.noncommSum s\n      (fun (x : α) (x_1 : x ∈ {x : α | x ∈ s}) (x_2 : α) (x_3 : x_2 ∈ {x : α | x ∈ s}) (x_4 : x ≠ x_2) ↦\n        AddCommute.all x x_2) =\n    Multiset.sum s", "thm": " : ∀ {α : Type u_1} [inst : AddCommMonoid α] (s : Multiset α),\n  Multiset.noncommSum s\n      (fun (x : α) (x_1 : x ∈ {x : α | x ∈ s}) (x_2 : α) (x_3 : x_2 ∈ {x : α | x ∈ s}) (x_4 : x ≠ x_2) ↦\n        AddCommute.all x x_2) =\n    Multiset.sum s", "terms": [{"value": "List.sum a", "isProp": false, "context": ["{α : Type u_1}", "[AddCommMonoid α]", "(s : Multiset α)", "(a : List α)"]}], "namedLemmas": ["∀ {α : Sort u} {s : Setoid α} {motive : Quotient s → Prop} (q : Quotient s),\n  (∀ (a : α), motive (Quotient.mk s a)) → motive q", "∀ {p : Prop}, p = True → p", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Type u_1} [inst : AddMonoid α] (l : List α) (comm : Set.Pairwise {x | x ∈ ↑l} AddCommute),\n  Multiset.noncommSum (↑l) comm = List.sum l", "∀ {S : Type u_1} [inst : AddCommSemigroup S] (a b : S), AddCommute a b", "∀ {α : Type u_1} [inst : AddCommMonoid α] (l : List α), Multiset.sum ↑l = List.sum l", "∀ {α : Sort u_1} (a : α), (a = a) = True"], "lemmas": [{"prop": "↑a = ↑a", "context": ["{α : Type u_1}", "[AddCommMonoid α]", "(s : Multiset α)", "(a : List α)"]}, {"prop": "Quotient.mk (List.isSetoid α) a = ↑a", "context": ["{α : Type u_1}", "[AddCommMonoid α]", "(s : Multiset α)", "(a : List α)"]}, {"prop": "∀ (x : α) (x_1 : x ∈ {x : α | x ∈ Quotient.mk (List.isSetoid α) a}) (x_2 : α)\n  (x_3 : x_2 ∈ {x : α | x ∈ Quotient.mk (List.isSetoid α) a}) (x_4 : x ≠ x_2), AddCommute x x_2", "context": ["{α : Type u_1}", "[AddCommMonoid α]", "(s : Multiset α)", "(a : List α)"]}, {"prop": "Set.Pairwise {x : α | x ∈ ↑a} AddCommute", "context": ["{α : Type u_1}", "[AddCommMonoid α]", "(s : Multiset α)", "(a : List α)"]}, {"prop": "Multiset.noncommSum ↑a\n    ((id (Eq.refl ↑a)) ▸\n      (fun (x : α) (x_1 : x ∈ {x : α | x ∈ Quotient.mk (List.isSetoid α) a}) (x_2 : α)\n          (x_3 : x_2 ∈ {x : α | x ∈ Quotient.mk (List.isSetoid α) a}) (x_4 : x ≠ x_2) ↦\n        AddCommute.all x x_2)) =\n  List.sum a", "context": ["{α : Type u_1}", "[AddCommMonoid α]", "(s : Multiset α)", "(a : List α)"]}, {"prop": "Eq\n    (Multiset.noncommSum ↑a\n      ((id (Eq.refl ↑a)) ▸\n        (fun (x : α) (x_1 : x ∈ {x : α | x ∈ Quotient.mk (List.isSetoid α) a}) (x_2 : α)\n            (x_3 : x_2 ∈ {x : α | x ∈ Quotient.mk (List.isSetoid α) a}) (x_4 : x ≠ x_2) ↦\n          AddCommute.all x x_2))) =\n  Eq (List.sum a)", "context": ["{α : Type u_1}", "[AddCommMonoid α]", "(s : Multiset α)", "(a : List α)"]}, {"prop": "Multiset.sum ↑a = List.sum a", "context": ["{α : Type u_1}", "[AddCommMonoid α]", "(s : Multiset α)", "(a : List α)"]}, {"prop": "(Multiset.noncommSum ↑a\n      ((id (Eq.refl ↑a)) ▸\n        (fun (x : α) (x_1 : x ∈ {x : α | x ∈ Quotient.mk (List.isSetoid α) a}) (x_2 : α)\n            (x_3 : x_2 ∈ {x : α | x ∈ Quotient.mk (List.isSetoid α) a}) (x_4 : x ≠ x_2) ↦\n          AddCommute.all x x_2)) =\n    Multiset.sum ↑a) =\n  (List.sum a = List.sum a)", "context": ["{α : Type u_1}", "[AddCommMonoid α]", "(s : Multiset α)", "(a : List α)"]}, {"prop": "(List.sum a = List.sum a) = True", "context": ["{α : Type u_1}", "[AddCommMonoid α]", "(s : Multiset α)", "(a : List α)"]}, {"prop": "(Multiset.noncommSum ↑a\n      ((id (Eq.refl ↑a)) ▸\n        (fun (x : α) (x_1 : x ∈ {x : α | x ∈ Quotient.mk (List.isSetoid α) a}) (x_2 : α)\n            (x_3 : x_2 ∈ {x : α | x ∈ Quotient.mk (List.isSetoid α) a}) (x_4 : x ≠ x_2) ↦\n          AddCommute.all x x_2)) =\n    Multiset.sum ↑a) =\n  True", "context": ["{α : Type u_1}", "[AddCommMonoid α]", "(s : Multiset α)", "(a : List α)"]}, {"prop": "∀ (a : List α),\n  Multiset.noncommSum ↑a\n      ((id (Eq.refl ↑a)) ▸\n        (fun (x : α) (x_1 : x ∈ {x : α | x ∈ Quotient.mk (List.isSetoid α) a}) (x_2 : α)\n            (x_3 : x_2 ∈ {x : α | x ∈ Quotient.mk (List.isSetoid α) a}) (x_4 : x ≠ x_2) ↦\n          AddCommute.all x x_2)) =\n    Multiset.sum ↑a", "context": ["{α : Type u_1}", "[AddCommMonoid α]", "(s : Multiset α)"]}], "ids": ["Quotient.inductionOn", "of_eq_true", "Eq.trans", "congr", "congrArg", "Eq", "Multiset.noncommSum_coe", "id", "Eq.refl", "AddCommute.all", "Multiset.coe_sum", "eq_self", "List.sum"], "idString": "Quotient.inductionOn; of_eq_true; Eq.trans; congr; congrArg; Eq; Multiset.noncommSum_coe; id; Eq.refl; AddCommute.all; Multiset.coe_sum; eq_self; List.sum; ", "context": []}
{"typeGroup": "(∀ {B : Type u_1} {F : Type u_2} {Z : Type u_3} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n    {proj : (a : Z) → B} [inst_2 : TopologicalSpace Z] (e : Trivialization F proj) {b : B}\n    (hb : b ∈ Trivialization.baseSet e) (p : F),\n    ↑(Homeomorph.symm (Trivialization.preimageSingletonHomeomorph e hb)) p =\n      { val := ((↑(LocalHomeomorph.symm (Trivialization.toLocalHomeomorph e)) (b, p))),\n        property :=\n          (((Eq.mpr\n              (id\n                  ((propext\n                          (Set.mem_preimage=:(↑(LocalHomeomorph.symm (Trivialization.toLocalHomeomorph e)) (b, p) ∈\n                                  proj ⁻¹' {b} :\n                                Prop) ↔\n                              (proj (↑(LocalHomeomorph.symm (Trivialization.toLocalHomeomorph e)) (b, p)) ∈ {b} :\n                                Prop))=:(↑(LocalHomeomorph.symm (Trivialization.toLocalHomeomorph e)) (b, p) ∈\n                              proj ⁻¹' {b} :\n                            Prop) =\n                          (proj (↑(LocalHomeomorph.symm (Trivialization.toLocalHomeomorph e)) (b, p)) ∈ {b} : Prop)) ▸\n                      (Eq.refl\n                          (↑(LocalHomeomorph.symm (Trivialization.toLocalHomeomorph e)) (b, p) ∈ proj ⁻¹' {b} :\n                            Prop)=:(↑(LocalHomeomorph.symm (Trivialization.toLocalHomeomorph e)) (b, p) ∈ proj ⁻¹' {b} :\n                            Prop) =\n                          (↑(LocalHomeomorph.symm (Trivialization.toLocalHomeomorph e)) (b, p) ∈ proj ⁻¹' {b} :\n                            Prop))=:(↑(LocalHomeomorph.symm (Trivialization.toLocalHomeomorph e)) (b, p) ∈\n                          proj ⁻¹' {b} :\n                        Prop) =\n                      (proj (↑(LocalHomeomorph.symm (Trivialization.toLocalHomeomorph e)) (b, p)) ∈ {b} :\n                        Prop))=:(↑(LocalHomeomorph.symm (Trivialization.toLocalHomeomorph e)) (b, p) ∈ proj ⁻¹' {b} :\n                    Prop) =\n                  (proj (↑(LocalHomeomorph.symm (Trivialization.toLocalHomeomorph e)) (b, p)) ∈ {b} : Prop))\n              (Eq.mpr\n                  (id\n                      ((Trivialization.proj_symm_apply' e\n                              hb=:proj (↑(LocalHomeomorph.symm (Trivialization.toLocalHomeomorph e)) (b, p)) = b) ▸\n                          (Eq.refl\n                              (proj (↑(LocalHomeomorph.symm (Trivialization.toLocalHomeomorph e)) (b, p)) ∈ {b} :\n                                Prop)=:(proj (↑(LocalHomeomorph.symm (Trivialization.toLocalHomeomorph e)) (b, p)) ∈\n                                  {b} :\n                                Prop) =\n                              (proj (↑(LocalHomeomorph.symm (Trivialization.toLocalHomeomorph e)) (b, p)) ∈ {b} :\n                                Prop))=:(proj (↑(LocalHomeomorph.symm (Trivialization.toLocalHomeomorph e)) (b, p)) ∈\n                              {b} :\n                            Prop) =\n                          (b ∈ {b} :\n                            Prop))=:(proj (↑(LocalHomeomorph.symm (Trivialization.toLocalHomeomorph e)) (b, p)) ∈ {b} :\n                        Prop) =\n                      (b ∈ {b} : Prop))\n                  (Eq.mpr\n                      (id\n                          ((propext\n                                  (Set.mem_singleton_iff=:(b ∈ {b} : Prop) ↔\n                                      (b = b : Prop))=:(b ∈ {b} : Prop) = (b = b : Prop)) ▸\n                              (Eq.refl\n                                  (b ∈ {b} :\n                                    Prop)=:(b ∈ {b} : Prop) =\n                                  (b ∈ {b} :\n                                    Prop))=:(b ∈ {b} : Prop) = (b = b : Prop))=:(b ∈ {b} : Prop) = (b = b : Prop))\n                      (Eq.refl\n                          b=:b =\n                          b)=:b ∈\n                      {b})=:proj (↑(LocalHomeomorph.symm (Trivialization.toLocalHomeomorph e)) (b, p)) ∈\n                  {b})=:↑(LocalHomeomorph.symm (Trivialization.toLocalHomeomorph e)) (b, p) ∈ proj ⁻¹' {b}))) } :\n  Prop)", "type": "∀ {B : Type u_1} {F : Type u_2} {Z : Type u_3} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n  {proj : (a : Z) → B} [inst_2 : TopologicalSpace Z] (e : Trivialization F proj) {b : B}\n  (hb : b ∈ Trivialization.baseSet e) (p : F),\n  ↑(Homeomorph.symm (Trivialization.preimageSingletonHomeomorph e hb)) p =\n    ↑(Homeomorph.symm (Trivialization.preimageSingletonHomeomorph e hb)) p", "thm": " : ∀ {B : Type u_1} {F : Type u_2} {Z : Type u_3} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n  {proj : (a : Z) → B} [inst_2 : TopologicalSpace Z] (e : Trivialization F proj) {b : B}\n  (hb : b ∈ Trivialization.baseSet e) (p : F),\n  ↑(Homeomorph.symm (Trivialization.preimageSingletonHomeomorph e hb)) p =\n    ↑(Homeomorph.symm (Trivialization.preimageSingletonHomeomorph e hb)) p", "terms": [], "namedLemmas": ["∀ {α : Sort u} {a : α}, a = a"], "lemmas": [], "ids": ["rfl"], "idString": "rfl; ", "context": []}
{"typeGroup": "(∀ {C : Type u_2} [inst : CategoryTheory.Category C] {B : C} {A : C} (f : A ⟶ B) [inst_1 : CategoryTheory.Mono f]\n    (X : CategoryTheory.Subobject B) (h : CategoryTheory.Subobject.mk f = X),\n    CategoryTheory.CategoryStruct.comp\n        (CategoryTheory.Subobject.ofMkLE f X (Eq.le h=:CategoryTheory.Subobject.mk f ≤ X))\n        (CategoryTheory.Subobject.ofLEMk X f (Eq.ge h=:X ≤ CategoryTheory.Subobject.mk f)) =\n      CategoryTheory.CategoryStruct.id A :\n  Prop)", "type": "∀ {C : Type u_2} [inst : CategoryTheory.Category C] {B : C} {A : C} (f : A ⟶ B) [inst_1 : CategoryTheory.Mono f]\n  (X : CategoryTheory.Subobject B) (h : CategoryTheory.Subobject.mk f = X),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLE f X (Eq.le h))\n      (CategoryTheory.Subobject.ofLEMk X f (Eq.ge h)) =\n    CategoryTheory.CategoryStruct.id A", "thm": " : ∀ {C : Type u_2} [inst : CategoryTheory.Category C] {B : C} {A : C} (f : A ⟶ B) [inst_1 : CategoryTheory.Mono f]\n  (X : CategoryTheory.Subobject B) (h : CategoryTheory.Subobject.mk f = X),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLE f X (Eq.le h))\n      (CategoryTheory.Subobject.ofLEMk X f (Eq.ge h)) =\n    CategoryTheory.CategoryStruct.id A", "terms": [{"value": "CategoryTheory.Subobject.mk f", "isProp": false, "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{B : C}", "{A : C}", "(f : A ⟶ B)", "[CategoryTheory.Mono f]", "(X : CategoryTheory.Subobject B)", "(h : CategoryTheory.Subobject.mk f = X)"]}, {"value": "CategoryTheory.CategoryStruct.id A", "isProp": false, "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{B : C}", "{A : C}", "(f : A ⟶ B)", "[CategoryTheory.Mono f]", "(X : CategoryTheory.Subobject B)", "(h : CategoryTheory.Subobject.mk f = X)"]}], "namedLemmas": ["∀ {p : Prop}, p = True → p", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {B A₁ A₂ : C} (f : A₁ ⟶ B) [inst_1 : CategoryTheory.Mono f]\n  (X : CategoryTheory.Subobject B) (g : A₂ ⟶ B) [inst_2 : CategoryTheory.Mono g]\n  (h₁ : CategoryTheory.Subobject.mk f ≤ X) (h₂ : X ≤ CategoryTheory.Subobject.mk g),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLE f X h₁) (CategoryTheory.Subobject.ofLEMk X g h₂) =\n    CategoryTheory.Subobject.ofMkLEMk f g (_ : CategoryTheory.Subobject.mk f ≤ CategoryTheory.Subobject.mk g)", "∀ {α : Type u} [inst : Preorder α] {a b : α}, a = b → a ≤ b", "∀ {α : Type u} [inst : Preorder α] {x y : α}, x = y → y ≤ x", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {B A₁ : C} (f : A₁ ⟶ B) [inst_1 : CategoryTheory.Mono f],\n  CategoryTheory.Subobject.ofMkLEMk f f (_ : CategoryTheory.Subobject.mk f ≤ CategoryTheory.Subobject.mk f) =\n    CategoryTheory.CategoryStruct.id A₁", "∀ {α : Sort u_1} (a : α), (a = a) = True"], "lemmas": [{"prop": "CategoryTheory.Subobject.mk f = CategoryTheory.Subobject.mk f", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{B : C}", "{A : C}", "(f : A ⟶ B)", "[CategoryTheory.Mono f]", "(X : CategoryTheory.Subobject B)", "(h : CategoryTheory.Subobject.mk f = X)"]}, {"prop": "CategoryTheory.Subobject.mk f ≤ CategoryTheory.Subobject.mk f", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{B : C}", "{A : C}", "(f : A ⟶ B)", "[CategoryTheory.Mono f]", "(X : CategoryTheory.Subobject B)", "(h : CategoryTheory.Subobject.mk f = X)"]}, {"prop": "CategoryTheory.Subobject.mk f = CategoryTheory.Subobject.mk f", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{B : C}", "{A : C}", "(f : A ⟶ B)", "[CategoryTheory.Mono f]", "(X : CategoryTheory.Subobject B)", "(h : CategoryTheory.Subobject.mk f = X)"]}, {"prop": "CategoryTheory.Subobject.mk f ≤ CategoryTheory.Subobject.mk f", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{B : C}", "{A : C}", "(f : A ⟶ B)", "[CategoryTheory.Mono f]", "(X : CategoryTheory.Subobject B)", "(h : CategoryTheory.Subobject.mk f = X)"]}, {"prop": "CategoryTheory.CategoryStruct.comp\n    (CategoryTheory.Subobject.ofMkLE f (CategoryTheory.Subobject.mk f)\n      (Eq.le (Eq.refl (CategoryTheory.Subobject.mk f))))\n    (CategoryTheory.Subobject.ofLEMk (CategoryTheory.Subobject.mk f) f\n      (Eq.ge (Eq.refl (CategoryTheory.Subobject.mk f)))) =\n  CategoryTheory.Subobject.ofMkLEMk f f\n    (LE.le.trans (Eq.le (Eq.refl (CategoryTheory.Subobject.mk f))) (Eq.ge (Eq.refl (CategoryTheory.Subobject.mk f))))", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{B : C}", "{A : C}", "(f : A ⟶ B)", "[CategoryTheory.Mono f]", "(X : CategoryTheory.Subobject B)", "(h : CategoryTheory.Subobject.mk f = X)"]}, {"prop": "CategoryTheory.Subobject.ofMkLEMk f f le_rfl = CategoryTheory.CategoryStruct.id A", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{B : C}", "{A : C}", "(f : A ⟶ B)", "[CategoryTheory.Mono f]", "(X : CategoryTheory.Subobject B)", "(h : CategoryTheory.Subobject.mk f = X)"]}, {"prop": "CategoryTheory.CategoryStruct.comp\n    (CategoryTheory.Subobject.ofMkLE f (CategoryTheory.Subobject.mk f)\n      (Eq.le (Eq.refl (CategoryTheory.Subobject.mk f))))\n    (CategoryTheory.Subobject.ofLEMk (CategoryTheory.Subobject.mk f) f\n      (Eq.ge (Eq.refl (CategoryTheory.Subobject.mk f)))) =\n  CategoryTheory.CategoryStruct.id A", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{B : C}", "{A : C}", "(f : A ⟶ B)", "[CategoryTheory.Mono f]", "(X : CategoryTheory.Subobject B)", "(h : CategoryTheory.Subobject.mk f = X)"]}, {"prop": "Eq\n    (CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.Subobject.ofMkLE f (CategoryTheory.Subobject.mk f)\n        (Eq.le (Eq.refl (CategoryTheory.Subobject.mk f))))\n      (CategoryTheory.Subobject.ofLEMk (CategoryTheory.Subobject.mk f) f\n        (Eq.ge (Eq.refl (CategoryTheory.Subobject.mk f))))) =\n  Eq (CategoryTheory.CategoryStruct.id A)", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{B : C}", "{A : C}", "(f : A ⟶ B)", "[CategoryTheory.Mono f]", "(X : CategoryTheory.Subobject B)", "(h : CategoryTheory.Subobject.mk f = X)"]}, {"prop": "(CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.Subobject.ofMkLE f (CategoryTheory.Subobject.mk f)\n        (Eq.le (Eq.refl (CategoryTheory.Subobject.mk f))))\n      (CategoryTheory.Subobject.ofLEMk (CategoryTheory.Subobject.mk f) f\n        (Eq.ge (Eq.refl (CategoryTheory.Subobject.mk f)))) =\n    CategoryTheory.CategoryStruct.id A) =\n  (CategoryTheory.CategoryStruct.id A = CategoryTheory.CategoryStruct.id A)", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{B : C}", "{A : C}", "(f : A ⟶ B)", "[CategoryTheory.Mono f]", "(X : CategoryTheory.Subobject B)", "(h : CategoryTheory.Subobject.mk f = X)"]}, {"prop": "(CategoryTheory.CategoryStruct.id A = CategoryTheory.CategoryStruct.id A) = True", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{B : C}", "{A : C}", "(f : A ⟶ B)", "[CategoryTheory.Mono f]", "(X : CategoryTheory.Subobject B)", "(h : CategoryTheory.Subobject.mk f = X)"]}, {"prop": "(CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.Subobject.ofMkLE f (CategoryTheory.Subobject.mk f)\n        (Eq.le (Eq.refl (CategoryTheory.Subobject.mk f))))\n      (CategoryTheory.Subobject.ofLEMk (CategoryTheory.Subobject.mk f) f\n        (Eq.ge (Eq.refl (CategoryTheory.Subobject.mk f)))) =\n    CategoryTheory.CategoryStruct.id A) =\n  True", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{B : C}", "{A : C}", "(f : A ⟶ B)", "[CategoryTheory.Mono f]", "(X : CategoryTheory.Subobject B)", "(h : CategoryTheory.Subobject.mk f = X)"]}, {"prop": "CategoryTheory.CategoryStruct.comp\n    (CategoryTheory.Subobject.ofMkLE f (CategoryTheory.Subobject.mk f)\n      (Eq.le (Eq.refl (CategoryTheory.Subobject.mk f))))\n    (CategoryTheory.Subobject.ofLEMk (CategoryTheory.Subobject.mk f) f\n      (Eq.ge (Eq.refl (CategoryTheory.Subobject.mk f)))) =\n  CategoryTheory.CategoryStruct.id A", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{B : C}", "{A : C}", "(f : A ⟶ B)", "[CategoryTheory.Mono f]", "(X : CategoryTheory.Subobject B)", "(h : CategoryTheory.Subobject.mk f = X)"]}], "ids": ["of_eq_true", "Eq.trans", "congrFun", "congrArg", "Eq", "Eq.trans", "CategoryTheory.Subobject.ofMkLE_comp_ofLEMk", "CategoryTheory.Subobject.mk", "Eq.le", "Eq.refl", "CategoryTheory.Subobject.mk", "Eq.ge", "Eq.refl", "CategoryTheory.Subobject.mk", "CategoryTheory.Subobject.ofMkLEMk_refl", "CategoryTheory.CategoryStruct.id", "eq_self", "CategoryTheory.CategoryStruct.id"], "idString": "of_eq_true; Eq.trans; congrFun; congrArg; Eq; Eq.trans; CategoryTheory.Subobject.ofMkLE_comp_ofLEMk; CategoryTheory.Subobject.mk; Eq.le; Eq.refl; CategoryTheory.Subobject.mk; Eq.ge; Eq.refl; CategoryTheory.Subobject.mk; CategoryTheory.Subobject.ofMkLEMk_refl; CategoryTheory.CategoryStruct.id; eq_self; CategoryTheory.CategoryStruct.id; ", "context": []}
{"typeGroup": "(∀ {α : Type u_1} [inst : DecidableEq α] {δ : (a : α) → Sort v} {m : Multiset α} {a : α}\n    (f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a'),\n    (Multiset.Pi.cons m a (f a (Multiset.mem_cons_self a m=:a ∈ a ::ₘ m)) fun (a' : α) (ha' : a' ∈ m) ↦\n        f a' (Multiset.mem_cons_of_mem ha'=:a' ∈ a ::ₘ m)) =\n      f :\n  Prop)", "type": "∀ {α : Type u_1} [inst : DecidableEq α] {δ : (a : α) → Sort v} {m : Multiset α} {a : α}\n  (f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a'),\n  (Multiset.Pi.cons m a (f a (Multiset.mem_cons_self a m)) fun (a' : α) (ha' : a' ∈ m) ↦\n      f a' (Multiset.mem_cons_of_mem ha')) =\n    f", "thm": " : ∀ {α : Type u_1} [inst : DecidableEq α] {δ : (a : α) → Sort v} {m : Multiset α} {a : α}\n  (f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a'),\n  (Multiset.Pi.cons m a (f a (Multiset.mem_cons_self a m)) fun (a' : α) (ha' : a' ∈ m) ↦\n      f a' (Multiset.mem_cons_of_mem ha')) =\n    f", "terms": [{"value": "f a (Multiset.mem_cons_self a m)", "isProp": false, "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)", "{a : α}"]}, {"value": "f a' (Multiset.mem_cons_self a' m)", "isProp": false, "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)", "(f : (a'_1 : α) → (a : a'_1 ∈ a' ::ₘ m) → δ a'_1)", "(h' : a' ∈ a' ::ₘ m)"]}, {"value": "f a (Multiset.mem_cons_self a m)", "isProp": false, "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)"]}], "namedLemmas": ["∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g", "∀ {α : Type u_1} (a : α) (s : Multiset α), a ∈ a ::ₘ s", "∀ {α : Type u_1} {a b : α} {s : Multiset α}, a ∈ s → a ∈ b ::ₘ s", "∀ {α : Type u_1} [inst : DecidableEq α] {δ : α → Sort v} {m : Multiset α} {a : α} {b : δ a} {f : (a : α) → a ∈ m → δ a}\n  (h : a ∈ a ::ₘ m), Multiset.Pi.cons m a b f a h = b", "∀ {α : Type u_1} (a : α) (s : Multiset α), a ∈ a ::ₘ s", "∀ {α : Type u_1} {a b : α} {s : Multiset α}, a ∈ s → a ∈ b ::ₘ s", "∀ {α : Type u_1} (a : α) (s : Multiset α), a ∈ a ::ₘ s", "∀ {α : Type u_1} [inst : DecidableEq α] {δ : α → Sort v} {m : Multiset α} {a a' : α} {b : δ a}\n  {f : (a : α) → a ∈ m → δ a} (h' : a' ∈ a ::ₘ m) (h : a' ≠ a), Multiset.Pi.cons m a b f a' h' = f a' (_ : a' ∈ m)", "∀ {α : Type u_1} (a : α) (s : Multiset α), a ∈ a ::ₘ s", "∀ {α : Type u_1} {a b : α} {s : Multiset α}, a ∈ s → a ∈ b ::ₘ s", "∀ {α : Type u_1} {a b : α} {s : Multiset α}, a ∈ s → a ∈ b ::ₘ s", "∀ {a b : Prop}, a ∨ b → ¬a → b", "∀ {a b : Prop}, (a ↔ b) → a → b", "∀ {α : Type u_1} {a b : α} {s : Multiset α}, a ∈ b ::ₘ s ↔ a = b ∨ a ∈ s"], "lemmas": [{"prop": "a ∈ a ::ₘ m", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)", "{a : α}"]}, {"prop": "a' ∈ a ::ₘ m", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)", "{a : α}", "(a' : α)", "(ha' : a' ∈ m)"]}, {"prop": "Multiset.Pi.cons m a' (f a' (Multiset.mem_cons_self a' m))\n    (fun (a'_1 : α) (ha' : a'_1 ∈ m) ↦ f a'_1 (Multiset.mem_cons_of_mem ha')) a' h' =\n  f a' (Multiset.mem_cons_self a' m)", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)", "(f : (a'_1 : α) → (a : a'_1 ∈ a' ::ₘ m) → δ a'_1)", "(h' : a' ∈ a' ::ₘ m)"]}, {"prop": "a' ∈ a' ::ₘ m", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)", "(f : (a'_1 : α) → (a : a'_1 ∈ a' ::ₘ m) → δ a'_1)", "(h' : a' ∈ a' ::ₘ m)"]}, {"prop": "a'_1 ∈ a' ::ₘ m", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)", "(f : (a'_1 : α) → (a : a'_1 ∈ a' ::ₘ m) → δ a'_1)", "(h' : a' ∈ a' ::ₘ m)", "(a'_1 : α)", "(ha' : a'_1 ∈ m)"]}, {"prop": "(Multiset.Pi.cons m a' (f a' (Multiset.mem_cons_self a' m))\n      (fun (a'_1 : α) (ha' : a'_1 ∈ m) ↦ f a'_1 (Multiset.mem_cons_of_mem ha')) a' h' =\n    f a' h') =\n  (Multiset.Pi.cons m a' (f a' (Multiset.mem_cons_self a' m))\n      (fun (a'_1 : α) (ha' : a'_1 ∈ m) ↦ f a'_1 (Multiset.mem_cons_of_mem ha')) a' h' =\n    f a' h')", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)", "(f : (a'_1 : α) → (a : a'_1 ∈ a' ::ₘ m) → δ a'_1)", "(h' : a' ∈ a' ::ₘ m)"]}, {"prop": "(Multiset.Pi.cons m a' (f a' (Multiset.mem_cons_self a' m))\n      (fun (a'_1 : α) (ha' : a'_1 ∈ m) ↦ f a'_1 (Multiset.mem_cons_of_mem ha')) a' h' =\n    f a' h') =\n  (f a' (Multiset.mem_cons_self a' m) = f a' h')", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)", "(f : (a'_1 : α) → (a : a'_1 ∈ a' ::ₘ m) → δ a'_1)", "(h' : a' ∈ a' ::ₘ m)"]}, {"prop": "(Multiset.Pi.cons m a' (f a' (Multiset.mem_cons_self a' m))\n      (fun (a'_1 : α) (ha' : a'_1 ∈ m) ↦ f a'_1 (Multiset.mem_cons_of_mem ha')) a' h' =\n    f a' h') =\n  (f a' (Multiset.mem_cons_self a' m) = f a' h')", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)", "(f : (a'_1 : α) → (a : a'_1 ∈ a' ::ₘ m) → δ a'_1)", "(h' : a' ∈ a' ::ₘ m)"]}, {"prop": "a' ∈ a' ::ₘ m", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)", "(f : (a'_1 : α) → (a : a'_1 ∈ a' ::ₘ m) → δ a'_1)", "(h' : a' ∈ a' ::ₘ m)"]}, {"prop": "f a' (Multiset.mem_cons_self a' m) = f a' (Multiset.mem_cons_self a' m)", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)", "(f : (a'_1 : α) → (a : a'_1 ∈ a' ::ₘ m) → δ a'_1)", "(h' : a' ∈ a' ::ₘ m)"]}, {"prop": "∀ (f : (a'_1 : α) → (a : a'_1 ∈ a' ::ₘ m) → δ a'_1) (h' : a' ∈ a' ::ₘ m),\n  Multiset.Pi.cons m a' (f a' (Multiset.mem_cons_self a' m))\n      (fun (a'_1 : α) (ha' : a'_1 ∈ m) ↦ f a'_1 (Multiset.mem_cons_of_mem ha')) a' h' =\n    f a' h'", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)"]}, {"prop": "Multiset.Pi.cons m a (f a (Multiset.mem_cons_self a m))\n    (fun (a' : α) (ha' : a' ∈ m) ↦ f a' (Multiset.mem_cons_of_mem ha')) a' h' =\n  f a' h'", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)"]}, {"prop": "Multiset.Pi.cons m a (f a (Multiset.mem_cons_self a m))\n    (fun (a' : α) (ha' : a' ∈ m) ↦ f a' (Multiset.mem_cons_of_mem ha')) a' h' =\n  f a' (Multiset.mem_cons_of_mem (Or.resolve_left (Iff.mp Multiset.mem_cons h') h))", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)"]}, {"prop": "a ∈ a ::ₘ m", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)"]}, {"prop": "a' ∈ a ::ₘ m", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)", "(a' : α)", "(ha' : a' ∈ m)"]}, {"prop": "(Multiset.Pi.cons m a (f a (Multiset.mem_cons_self a m))\n      (fun (a' : α) (ha' : a' ∈ m) ↦ f a' (Multiset.mem_cons_of_mem ha')) a' h' =\n    f a' h') =\n  (Multiset.Pi.cons m a (f a (Multiset.mem_cons_self a m))\n      (fun (a' : α) (ha' : a' ∈ m) ↦ f a' (Multiset.mem_cons_of_mem ha')) a' h' =\n    f a' h')", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)"]}, {"prop": "(Multiset.Pi.cons m a (f a (Multiset.mem_cons_self a m))\n      (fun (a' : α) (ha' : a' ∈ m) ↦ f a' (Multiset.mem_cons_of_mem ha')) a' h' =\n    f a' h') =\n  (f a' (Multiset.mem_cons_of_mem (Or.resolve_left (Iff.mp Multiset.mem_cons h') h)) = f a' h')", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)"]}, {"prop": "(Multiset.Pi.cons m a (f a (Multiset.mem_cons_self a m))\n      (fun (a' : α) (ha' : a' ∈ m) ↦ f a' (Multiset.mem_cons_of_mem ha')) a' h' =\n    f a' h') =\n  (f a' (Multiset.mem_cons_of_mem (Or.resolve_left (Iff.mp Multiset.mem_cons h') h)) = f a' h')", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)"]}, {"prop": "(a' ∈ a ::ₘ m) ↔ ((a' = a) ∨ (a' ∈ m))", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)"]}, {"prop": "(a' = a) ∨ (a' ∈ m)", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)"]}, {"prop": "a' ∈ m", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)"]}, {"prop": "a' ∈ a ::ₘ m", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)"]}, {"prop": "f a' (Multiset.mem_cons_of_mem (Or.resolve_left (Iff.mp Multiset.mem_cons h') h)) =\n  f a' (Multiset.mem_cons_of_mem (Or.resolve_left (Iff.mp Multiset.mem_cons h') h))", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)"]}, {"prop": "Multiset.Pi.cons m a (f a (Multiset.mem_cons_self a m))\n    (fun (a' : α) (ha' : a' ∈ m) ↦ f a' (Multiset.mem_cons_of_mem ha')) a' h' =\n  f a' h'", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)", "(h' : a' ∈ a ::ₘ m)"]}, {"prop": "∀ (h' : a' ∈ a ::ₘ m),\n  Multiset.Pi.cons m a (f a (Multiset.mem_cons_self a m))\n      (fun (a' : α) (ha' : a' ∈ m) ↦ f a' (Multiset.mem_cons_of_mem ha')) a' h' =\n    f a' h'", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')", "(a' : α)"]}, {"prop": "∀ (a' : α),\n  Multiset.Pi.cons m a (f a (Multiset.mem_cons_self a m))\n      (fun (a' : α) (ha' : a' ∈ m) ↦ f a' (Multiset.mem_cons_of_mem ha')) a' =\n    f a'", "context": ["{α : Type u_1}", "[DecidableEq α]", "{δ : (a : α) → Sort v}", "{m : Multiset α}", "{a : α}", "(f : (a' : α) → (a : a' ∈ a ::ₘ m) → δ a')"]}], "ids": ["funext", "funext", "h", "Eq.ndrec", "Multiset.Pi.cons", "Multiset.mem_cons_self", "Multiset.mem_cons_of_mem", "Eq.mpr", "id", "Multiset.Pi.cons_same", "Eq.refl", "Multiset.Pi.cons", "Multiset.mem_cons_self", "Multiset.mem_cons_of_mem", "Eq.refl", "Multiset.mem_cons_self", "h", "Eq.mpr", "id", "Multiset.Pi.cons_ne", "h", "Eq.refl", "Multiset.Pi.cons", "Multiset.mem_cons_self", "Multiset.mem_cons_of_mem", "Eq.refl", "Multiset.mem_cons_of_mem", "Or.resolve_left", "Iff.mp", "Multiset.mem_cons", "h"], "idString": "funext; funext; h; Eq.ndrec; Multiset.Pi.cons; Multiset.mem_cons_self; Multiset.mem_cons_of_mem; Eq.mpr; id; Multiset.Pi.cons_same; Eq.refl; Multiset.Pi.cons; Multiset.mem_cons_self; Multiset.mem_cons_of_mem; Eq.refl; Multiset.mem_cons_self; h; Eq.mpr; id; Multiset.Pi.cons_ne; h; Eq.refl; Multiset.Pi.cons; Multiset.mem_cons_self; Multiset.mem_cons_of_mem; Eq.refl; Multiset.mem_cons_of_mem; Or.resolve_left; Iff.mp; Multiset.mem_cons; h; ", "context": []}
{"typeGroup": "(∀ {α : Type u_4} {β : Type u_1} {ι : Type u_2} {κ : Type u_3} [inst : VAdd α β] (b : (a : ι) → α) (c : (a : κ) → β)\n    (_x : β) (motive : (x : _x ∈ Set.range fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p)) → Prop)\n    (x : _x ∈ Set.range fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p))\n    (h_1 :\n      ∀ (i : ι) (j : κ) (h : (fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p)) (i, j) = _x),\n        motive (Exists.intro (i, j) h=:∃ (y : ι × κ), (fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p)) y = _x)),\n    motive x :\n  Prop)", "type": "∀ {α : Type u_4} {β : Type u_1} {ι : Type u_2} {κ : Type u_3} [inst : VAdd α β] (b : (a : ι) → α) (c : (a : κ) → β)\n  (_x : β) (motive : (x : _x ∈ Set.range fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p)) → Prop)\n  (x : _x ∈ Set.range fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p))\n  (h_1 :\n    ∀ (i : ι) (j : κ) (h : (fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p)) (i, j) = _x),\n      motive (Exists.intro (i, j) h)),\n  motive x", "thm": " : ∀ {α : Type u_4} {β : Type u_1} {ι : Type u_2} {κ : Type u_3} [inst : VAdd α β] (b : (a : ι) → α) (c : (a : κ) → β)\n  (_x : β) (motive : (x : _x ∈ Set.range fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p)) → Prop)\n  (x : _x ∈ Set.range fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p))\n  (h_1 :\n    ∀ (i : ι) (j : κ) (h : (fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p)) (i, j) = _x),\n      motive (Exists.intro (i, j) h)),\n  motive x", "terms": [{"value": "Prod.fst p", "isProp": false, "context": ["{α : Type u_4}", "{β : Type u_1}", "{ι : Type u_2}", "{κ : Type u_3}", "[VAdd α β]", "(b : (a : ι) → α)", "(c : (a : κ) → β)", "(_x : β)", "(motive : (x : _x ∈ Set.range fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p)) → Prop)", "(x : _x ∈ Set.range fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p))", "(h_1 : ∀ (i : ι) (j : κ) (h : (fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p)) (i, j) = _x), motive (Exists.intro (i, j) h))", "(w : ι × κ)", "(h : (fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p)) w = _x)", "(x : ι × κ)", "(p : ι × κ)"]}, {"value": "Prod.snd p", "isProp": false, "context": ["{α : Type u_4}", "{β : Type u_1}", "{ι : Type u_2}", "{κ : Type u_3}", "[VAdd α β]", "(b : (a : ι) → α)", "(c : (a : κ) → β)", "(_x : β)", "(motive : (x : _x ∈ Set.range fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p)) → Prop)", "(x : _x ∈ Set.range fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p))", "(h_1 : ∀ (i : ι) (j : κ) (h : (fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p)) (i, j) = _x), motive (Exists.intro (i, j) h))", "(w : ι × κ)", "(h : (fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p)) w = _x)", "(x : ι × κ)", "(p : ι × κ)"]}], "namedLemmas": [], "lemmas": [{"prop": "∃ (y : ι × κ), (fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p)) y = _x", "context": ["{α : Type u_4}", "{β : Type u_1}", "{ι : Type u_2}", "{κ : Type u_3}", "[VAdd α β]", "(b : (a : ι) → α)", "(c : (a : κ) → β)", "(_x : β)", "(motive : (x : _x ∈ Set.range fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p)) → Prop)", "(x : _x ∈ Set.range fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p))", "(h_1 : ∀ (i : ι) (j : κ) (h : (fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p)) (i, j) = _x), motive (Exists.intro (i, j) h))", "(w : ι × κ)", "(h : (fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p)) w = _x)", "(x : ι × κ)"]}, {"prop": "∀ (fst : ι) (snd : κ) (h : (fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p)) (fst, snd) = _x),\n  motive (Exists.intro (fst, snd) h)", "context": ["{α : Type u_4}", "{β : Type u_1}", "{ι : Type u_2}", "{κ : Type u_3}", "[VAdd α β]", "(b : (a : ι) → α)", "(c : (a : κ) → β)", "(_x : β)", "(motive : (x : _x ∈ Set.range fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p)) → Prop)", "(x : _x ∈ Set.range fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p))", "(h_1 : ∀ (i : ι) (j : κ) (h : (fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p)) (i, j) = _x), motive (Exists.intro (i, j) h))", "(w : ι × κ)", "(h : (fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p)) w = _x)"]}, {"prop": "∀ (w : ι × κ) (h : (fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p)) w = _x), motive (Exists.intro w h)", "context": ["{α : Type u_4}", "{β : Type u_1}", "{ι : Type u_2}", "{κ : Type u_3}", "[VAdd α β]", "(b : (a : ι) → α)", "(c : (a : κ) → β)", "(_x : β)", "(motive : (x : _x ∈ Set.range fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p)) → Prop)", "(x : _x ∈ Set.range fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p))", "(h_1 : ∀ (i : ι) (j : κ) (h : (fun (p : ι × κ) ↦ b (Prod.fst p) +ᵥ c (Prod.snd p)) (i, j) = _x), motive (Exists.intro (i, j) h))"]}], "ids": ["Prod.fst", "Prod.snd", "Exists.intro"], "idString": "Prod.fst; Prod.snd; Exists.intro; ", "context": []}
{"typeGroup": "(∀ (R : Type u_2) {A : Type u_3} (M : Type u_1) [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\n    [inst_3 : AddCommMonoid M] [inst_4 : Module R M] [inst_5 : Module A M] [inst_6 : IsScalarTower R A M] (a : A)\n    (b : A),\n    OneHom.toFun\n        { toFun := ((DistribMulAction.toLinearMap R M)),\n          map_one' :=\n            (((LinearMap.ext\n                (fun (x : M) ↦ (_ : 1 • x = x)=:∀ (x : M), 1 • x = x)=:DistribMulAction.toLinearMap R M 1 = 1))) }\n        (a * b) =\n      OneHom.toFun\n          { toFun := ((DistribMulAction.toLinearMap R M)),\n            map_one' :=\n              (((LinearMap.ext\n                  (fun (x : M) ↦ (_ : 1 • x = x)=:∀ (x : M), 1 • x = x)=:DistribMulAction.toLinearMap R M 1 = 1))) }\n          a *\n        OneHom.toFun\n          { toFun := ((DistribMulAction.toLinearMap R M)),\n            map_one' :=\n              (((LinearMap.ext\n                  (fun (x : M) ↦ (_ : 1 • x = x)=:∀ (x : M), 1 • x = x)=:DistribMulAction.toLinearMap R M 1 = 1))) }\n          b :\n  Prop)", "type": "∀ (R : Type u_2) {A : Type u_3} (M : Type u_1) [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\n  [inst_3 : AddCommMonoid M] [inst_4 : Module R M] [inst_5 : Module A M] [inst_6 : IsScalarTower R A M] (a : A) (b : A),\n  OneHom.toFun\n      { toFun := ((DistribMulAction.toLinearMap R M)), map_one' := (((LinearMap.ext (fun (x : M) ↦ one_smul A x)))) }\n      (a * b) =\n    OneHom.toFun\n        { toFun := ((DistribMulAction.toLinearMap R M)), map_one' := (((LinearMap.ext (fun (x : M) ↦ one_smul A x)))) }\n        a *\n      OneHom.toFun\n        { toFun := ((DistribMulAction.toLinearMap R M)), map_one' := (((LinearMap.ext (fun (x : M) ↦ one_smul A x)))) }\n        b", "thm": " : ∀ (R : Type u_2) {A : Type u_3} (M : Type u_1) [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\n  [inst_3 : AddCommMonoid M] [inst_4 : Module R M] [inst_5 : Module A M] [inst_6 : IsScalarTower R A M] (a : A) (b : A),\n  OneHom.toFun\n      { toFun := ((DistribMulAction.toLinearMap R M)), map_one' := (((LinearMap.ext (fun (x : M) ↦ one_smul A x)))) }\n      (a * b) =\n    OneHom.toFun\n        { toFun := ((DistribMulAction.toLinearMap R M)), map_one' := (((LinearMap.ext (fun (x : M) ↦ one_smul A x)))) }\n        a *\n      OneHom.toFun\n        { toFun := ((DistribMulAction.toLinearMap R M)), map_one' := (((LinearMap.ext (fun (x : M) ↦ one_smul A x)))) }\n        b", "terms": [], "namedLemmas": ["∀ {R : Type u_1} {S : Type u_2} {M : Type u_3} {M₃ : Type u_4} [inst : Semiring R] [inst_1 : Semiring S]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₃] [inst_4 : Module R M] [inst_5 : Module S M₃] {σ : R →+* S}\n  {f g : M →ₛₗ[σ] M₃}, (∀ (x : M), ↑f x = ↑g x) → f = g", "∀ {α : Type u_3} {M : Type u_1} {N : Type u_2} [inst : SMul M N] [inst_1 : SMul N α] [inst_2 : SMul M α]\n  [inst_3 : IsScalarTower M N α] (x : M) (y : N) (z : α), (x • y) • z = x • y • z"], "lemmas": [{"prop": "∀ (z : M), (a • b) • z = a • b • z", "context": ["(R : Type u_2)", "{A : Type u_3}", "(M : Type u_1)", "[CommSemiring R]", "[Semiring A]", "[Algebra R A]", "[AddCommMonoid M]", "[Module R M]", "[Module A M]", "[IsScalarTower R A M]", "(a : A)", "(b : A)"]}], "ids": ["LinearMap.ext", "smul_assoc"], "idString": "LinearMap.ext; smul_assoc; ", "context": []}
{"typeGroup": "(∀ {B : Type u_1} {F : Type u_2} {E : (a : B) → Type u_3} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n    [inst_2 : (x : B) → TopologicalSpace (E x)] (a : FiberPrebundle F E) (x : B),\n    ∃ (e₀ : Pretrivialization F Bundle.TotalSpace.proj),\n      ∃ (he₀ : e₀ ∈ FiberPrebundle.pretrivializationAtlas a),\n        (fun (x : B) ↦\n              FiberPrebundle.trivializationOfMemPretrivializationAtlas a\n                (FiberPrebundle.pretrivialization_mem_atlas a\n                    x=:FiberPrebundle.pretrivializationAt a x ∈ FiberPrebundle.pretrivializationAtlas a))\n            x =\n          FiberPrebundle.trivializationOfMemPretrivializationAtlas a he₀ :\n  Prop)", "type": "∀ {B : Type u_1} {F : Type u_2} {E : (a : B) → Type u_3} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n  [inst_2 : (x : B) → TopologicalSpace (E x)] (a : FiberPrebundle F E) (x : B),\n  ∃ (e₀ : Pretrivialization F Bundle.TotalSpace.proj),\n    ∃ (he₀ : e₀ ∈ FiberPrebundle.pretrivializationAtlas a),\n      (fun (x : B) ↦\n            FiberPrebundle.trivializationOfMemPretrivializationAtlas a (FiberPrebundle.pretrivialization_mem_atlas a x))\n          x =\n        FiberPrebundle.trivializationOfMemPretrivializationAtlas a he₀", "thm": " : ∀ {B : Type u_1} {F : Type u_2} {E : (a : B) → Type u_3} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n  [inst_2 : (x : B) → TopologicalSpace (E x)] (a : FiberPrebundle F E) (x : B),\n  ∃ (e₀ : Pretrivialization F Bundle.TotalSpace.proj),\n    ∃ (he₀ : e₀ ∈ FiberPrebundle.pretrivializationAtlas a),\n      (fun (x : B) ↦\n            FiberPrebundle.trivializationOfMemPretrivializationAtlas a (FiberPrebundle.pretrivialization_mem_atlas a x))\n          x =\n        FiberPrebundle.trivializationOfMemPretrivializationAtlas a he₀", "terms": [{"value": "FiberPrebundle.pretrivializationAt a x", "isProp": false, "context": ["{B : Type u_1}", "{F : Type u_2}", "{E : (a : B) → Type u_3}", "[TopologicalSpace B]", "[TopologicalSpace F]", "[(x : B) → TopologicalSpace (E x)]", "(a : FiberPrebundle F E)", "(x : B)"]}], "namedLemmas": ["∀ {B : Type u_1} {F : Type u_2} {E : B → Type u_3} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n  [inst_2 : (x : B) → TopologicalSpace (E x)] (self : FiberPrebundle F E) (x : B),\n  FiberPrebundle.pretrivializationAt self x ∈ self.pretrivializationAtlas", "∀ {α : Sort u} {a : α}, a = a"], "lemmas": [{"prop": "FiberPrebundle.pretrivializationAt a x ∈ FiberPrebundle.pretrivializationAtlas a", "context": ["{B : Type u_1}", "{F : Type u_2}", "{E : (a : B) → Type u_3}", "[TopologicalSpace B]", "[TopologicalSpace F]", "[(x : B) → TopologicalSpace (E x)]", "(a : FiberPrebundle F E)", "(x : B)"]}, {"prop": "(fun (x : B) ↦\n      FiberPrebundle.trivializationOfMemPretrivializationAtlas a (FiberPrebundle.pretrivialization_mem_atlas a x))\n    x =\n  (fun (x : B) ↦\n      FiberPrebundle.trivializationOfMemPretrivializationAtlas a (FiberPrebundle.pretrivialization_mem_atlas a x))\n    x", "context": ["{B : Type u_1}", "{F : Type u_2}", "{E : (a : B) → Type u_3}", "[TopologicalSpace B]", "[TopologicalSpace F]", "[(x : B) → TopologicalSpace (E x)]", "(a : FiberPrebundle F E)", "(x : B)"]}, {"prop": "∃ (he₀ : FiberPrebundle.pretrivializationAt a x ∈ FiberPrebundle.pretrivializationAtlas a),\n  (fun (x : B) ↦\n        FiberPrebundle.trivializationOfMemPretrivializationAtlas a (FiberPrebundle.pretrivialization_mem_atlas a x))\n      x =\n    FiberPrebundle.trivializationOfMemPretrivializationAtlas a he₀", "context": ["{B : Type u_1}", "{F : Type u_2}", "{E : (a : B) → Type u_3}", "[TopologicalSpace B]", "[TopologicalSpace F]", "[(x : B) → TopologicalSpace (E x)]", "(a : FiberPrebundle F E)", "(x : B)"]}], "ids": ["Exists.intro", "FiberPrebundle.pretrivializationAt", "Exists.intro", "FiberPrebundle.pretrivialization_mem_atlas", "rfl"], "idString": "Exists.intro; FiberPrebundle.pretrivializationAt; Exists.intro; FiberPrebundle.pretrivialization_mem_atlas; rfl; ", "context": []}
{"typeGroup": "(∀ {V : Type u_2} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V]\n    (C : CochainComplex V ℕ),\n    CategoryTheory.CategoryStruct.comp\n        (HomologicalComplex.xPrevIsoSelf C\n            (Eq.mpr\n                (id\n                    (CochainComplex.prev_nat_zero ▸\n                        (Eq.refl\n                            (¬(ComplexShape.Rel (ComplexShape.up ℕ) (ComplexShape.prev (ComplexShape.up ℕ) 0) 0 :\n                                  Prop) :\n                              Prop)=:(¬(ComplexShape.Rel (ComplexShape.up ℕ) (ComplexShape.prev (ComplexShape.up ℕ) 0)\n                                    0 :\n                                  Prop) :\n                              Prop) =\n                            (¬(ComplexShape.Rel (ComplexShape.up ℕ) (ComplexShape.prev (ComplexShape.up ℕ) 0) 0 :\n                                  Prop) :\n                              Prop))=:(¬(ComplexShape.Rel (ComplexShape.up ℕ) (ComplexShape.prev (ComplexShape.up ℕ) 0)\n                                0 :\n                              Prop) :\n                          Prop) =\n                        (¬(ComplexShape.Rel (ComplexShape.up ℕ) 0 0 : Prop) :\n                          Prop))=:(¬(ComplexShape.Rel (ComplexShape.up ℕ) (ComplexShape.prev (ComplexShape.up ℕ) 0) 0 :\n                          Prop) :\n                      Prop) =\n                    (¬(ComplexShape.Rel (ComplexShape.up ℕ) 0 0 : Prop) : Prop))\n                (one_ne_zero=:1 ≠\n                    0)=:¬(ComplexShape.Rel (ComplexShape.up ℕ) (ComplexShape.prev (ComplexShape.up ℕ) 0) 0 : Prop))).hom\n        0 =\n      CategoryTheory.CategoryStruct.comp (HomologicalComplex.d C (ComplexShape.prev (ComplexShape.up ℕ) 0) 0)\n        (CategoryTheory.CategoryStruct.id (HomologicalComplex.X C 0)) :\n  Prop)", "type": "∀ {V : Type u_2} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V]\n  (C : CochainComplex V ℕ),\n  CategoryTheory.CategoryStruct.comp\n      (HomologicalComplex.xPrevIsoSelf C\n          (Eq.mpr\n            (id\n              (CochainComplex.prev_nat_zero ▸\n                (Eq.refl (¬(ComplexShape.Rel (ComplexShape.up ℕ) (ComplexShape.prev (ComplexShape.up ℕ) 0) 0)))))\n            one_ne_zero)).hom\n      0 =\n    CategoryTheory.CategoryStruct.comp (HomologicalComplex.d C (ComplexShape.prev (ComplexShape.up ℕ) 0) 0)\n      (CategoryTheory.CategoryStruct.id (HomologicalComplex.X C 0))", "thm": " : ∀ {V : Type u_2} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V]\n  (C : CochainComplex V ℕ),\n  CategoryTheory.CategoryStruct.comp\n      (HomologicalComplex.xPrevIsoSelf C\n          (Eq.mpr\n            (id\n              (CochainComplex.prev_nat_zero ▸\n                (Eq.refl (¬(ComplexShape.Rel (ComplexShape.up ℕ) (ComplexShape.prev (ComplexShape.up ℕ) 0) 0)))))\n            one_ne_zero)).hom\n      0 =\n    CategoryTheory.CategoryStruct.comp (HomologicalComplex.d C (ComplexShape.prev (ComplexShape.up ℕ) 0) 0)\n      (CategoryTheory.CategoryStruct.id (HomologicalComplex.X C 0))", "terms": [{"value": "ℕ", "isProp": false, "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "(C : CochainComplex V ℕ)"]}, {"value": "ComplexShape.up ℕ", "isProp": false, "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "(C : CochainComplex V ℕ)"]}, {"value": "ComplexShape.prev (ComplexShape.up ℕ) 0", "isProp": false, "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "(C : CochainComplex V ℕ)"]}, {"value": "ComplexShape.Rel (ComplexShape.up ℕ)", "isProp": false, "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "(C : CochainComplex V ℕ)"]}, {"value": "HomologicalComplex.X C 0", "isProp": false, "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "(C : CochainComplex V ℕ)"]}, {"value": "CategoryTheory.CategoryStruct.id (HomologicalComplex.X C 0)", "isProp": false, "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "(C : CochainComplex V ℕ)"]}], "namedLemmas": ["∀ {p : Prop}, p = True → p", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X Y : C}\n  {f : X ⟶ Y} {Z : C}, CategoryTheory.CategoryStruct.comp f 0 = 0", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {ι : Type u_1} {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V]\n  {c : ComplexShape ι} (self : HomologicalComplex V c) (i j : ι),\n  ¬ComplexShape.Rel c i j → HomologicalComplex.d self i j = 0", "∀ {p : Prop}, p = True → p", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "ComplexShape.prev (ComplexShape.up ℕ) 0 = 0", "∀ {p : Prop} {x : Decidable p}, decide p = false → p = False", "(¬False) = True", "∀ {obj : Type u} [self : CategoryTheory.Category obj] {X Y : obj} (f : X ⟶ Y),\n  CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.id Y) = f", "∀ {α : Sort u_1} (a : α), (a = a) = True"], "lemmas": [{"prop": "CategoryTheory.CategoryStruct.comp\n    (HomologicalComplex.xPrevIsoSelf C\n        (Eq.mpr\n          (id\n            (CochainComplex.prev_nat_zero ▸\n              (Eq.refl (¬(ComplexShape.Rel (ComplexShape.up ℕ) (ComplexShape.prev (ComplexShape.up ℕ) 0) 0)))))\n          one_ne_zero)).hom\n    0 =\n  0", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "(C : CochainComplex V ℕ)"]}, {"prop": "Eq\n    (CategoryTheory.CategoryStruct.comp\n      (HomologicalComplex.xPrevIsoSelf C\n          (Eq.mpr\n            (id\n              (CochainComplex.prev_nat_zero ▸\n                (Eq.refl (¬(ComplexShape.Rel (ComplexShape.up ℕ) (ComplexShape.prev (ComplexShape.up ℕ) 0) 0)))))\n            one_ne_zero)).hom\n      0) =\n  Eq 0", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "(C : CochainComplex V ℕ)"]}, {"prop": "ComplexShape.Rel (ComplexShape.up ℕ) (ComplexShape.prev (ComplexShape.up ℕ) 0) = ComplexShape.Rel (ComplexShape.up ℕ) 0", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "(C : CochainComplex V ℕ)"]}, {"prop": "(ComplexShape.Rel (ComplexShape.up ℕ) (ComplexShape.prev (ComplexShape.up ℕ) 0) 0) =\n  (ComplexShape.Rel (ComplexShape.up ℕ) 0 0)", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "(C : CochainComplex V ℕ)"]}, {"prop": "false = false", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "(C : CochainComplex V ℕ)"]}, {"prop": "(0 + 1 = 0) = False", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "(C : CochainComplex V ℕ)"]}, {"prop": "(ComplexShape.Rel (ComplexShape.up ℕ) (ComplexShape.prev (ComplexShape.up ℕ) 0) 0) = False", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "(C : CochainComplex V ℕ)"]}, {"prop": "(¬(ComplexShape.Rel (ComplexShape.up ℕ) (ComplexShape.prev (ComplexShape.up ℕ) 0) 0)) = (¬False)", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "(C : CochainComplex V ℕ)"]}, {"prop": "(¬(ComplexShape.Rel (ComplexShape.up ℕ) (ComplexShape.prev (ComplexShape.up ℕ) 0) 0)) = True", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "(C : CochainComplex V ℕ)"]}, {"prop": "¬(ComplexShape.Rel (ComplexShape.up ℕ) (ComplexShape.prev (ComplexShape.up ℕ) 0) 0)", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "(C : CochainComplex V ℕ)"]}, {"prop": "HomologicalComplex.d C (ComplexShape.prev (ComplexShape.up ℕ) 0) 0 = 0", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "(C : CochainComplex V ℕ)"]}, {"prop": "CategoryTheory.CategoryStruct.comp (HomologicalComplex.d C (ComplexShape.prev (ComplexShape.up ℕ) 0) 0) =\n  CategoryTheory.CategoryStruct.comp 0", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "(C : CochainComplex V ℕ)"]}, {"prop": "CategoryTheory.CategoryStruct.comp (HomologicalComplex.d C (ComplexShape.prev (ComplexShape.up ℕ) 0) 0)\n    (CategoryTheory.CategoryStruct.id (HomologicalComplex.X C 0)) =\n  CategoryTheory.CategoryStruct.comp 0 (CategoryTheory.CategoryStruct.id (HomologicalComplex.X C 0))", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "(C : CochainComplex V ℕ)"]}, {"prop": "CategoryTheory.CategoryStruct.comp 0 (CategoryTheory.CategoryStruct.id (HomologicalComplex.X C 0)) = 0", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "(C : CochainComplex V ℕ)"]}, {"prop": "CategoryTheory.CategoryStruct.comp (HomologicalComplex.d C (ComplexShape.prev (ComplexShape.up ℕ) 0) 0)\n    (CategoryTheory.CategoryStruct.id (HomologicalComplex.X C 0)) =\n  0", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "(C : CochainComplex V ℕ)"]}, {"prop": "(CategoryTheory.CategoryStruct.comp\n      (HomologicalComplex.xPrevIsoSelf C\n          (Eq.mpr\n            (id\n              (CochainComplex.prev_nat_zero ▸\n                (Eq.refl (¬(ComplexShape.Rel (ComplexShape.up ℕ) (ComplexShape.prev (ComplexShape.up ℕ) 0) 0)))))\n            one_ne_zero)).hom\n      0 =\n    CategoryTheory.CategoryStruct.comp (HomologicalComplex.d C (ComplexShape.prev (ComplexShape.up ℕ) 0) 0)\n      (CategoryTheory.CategoryStruct.id (HomologicalComplex.X C 0))) =\n  (0 = 0)", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "(C : CochainComplex V ℕ)"]}, {"prop": "(0 = 0) = True", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "(C : CochainComplex V ℕ)"]}, {"prop": "(CategoryTheory.CategoryStruct.comp\n      (HomologicalComplex.xPrevIsoSelf C\n          (Eq.mpr\n            (id\n              (CochainComplex.prev_nat_zero ▸\n                (Eq.refl (¬(ComplexShape.Rel (ComplexShape.up ℕ) (ComplexShape.prev (ComplexShape.up ℕ) 0) 0)))))\n            one_ne_zero)).hom\n      0 =\n    CategoryTheory.CategoryStruct.comp (HomologicalComplex.d C (ComplexShape.prev (ComplexShape.up ℕ) 0) 0)\n      (CategoryTheory.CategoryStruct.id (HomologicalComplex.X C 0))) =\n  True", "context": ["{V : Type u_2}", "[CategoryTheory.Category V]", "[CategoryTheory.Limits.HasZeroMorphisms V]", "(C : CochainComplex V ℕ)"]}], "ids": ["of_eq_true", "Eq.trans", "congr", "congrArg", "Eq", "CategoryTheory.Limits.comp_zero", "Eq.trans", "congrFun", "congrArg", "CategoryTheory.CategoryStruct.comp", "HomologicalComplex.shape", "ComplexShape.prev", "ComplexShape.up", "of_eq_true", "Eq.trans", "congrArg", "Not", "Eq.trans", "congrFun", "congrArg", "ComplexShape.Rel", "ComplexShape.up", "CochainComplex.prev_nat_zero", "eq_false_of_decide", "Eq.refl", "false", "not_false_eq_true", "CategoryTheory.CategoryStruct.id", "HomologicalComplex.X", "CategoryTheory.Category.comp_id", "eq_self"], "idString": "of_eq_true; Eq.trans; congr; congrArg; Eq; CategoryTheory.Limits.comp_zero; Eq.trans; congrFun; congrArg; CategoryTheory.CategoryStruct.comp; HomologicalComplex.shape; ComplexShape.prev; ComplexShape.up; of_eq_true; Eq.trans; congrArg; Not; Eq.trans; congrFun; congrArg; ComplexShape.Rel; ComplexShape.up; CochainComplex.prev_nat_zero; eq_false_of_decide; Eq.refl; false; not_false_eq_true; CategoryTheory.CategoryStruct.id; HomologicalComplex.X; CategoryTheory.Category.comp_id; eq_self; ", "context": []}
{"typeGroup": "(∀ {G : Type u_3} [inst : AddGroup G] {ι : Type u_2} {α : Type u_1} [inst_1 : TopologicalSpace α]\n    (F : (a : ι) → (a : α) → G) (f : (a : α) → G) (p : Filter ι) (s : Set α) (x : α) (u : Set G) (x_1 : Set α)\n    (motive :\n      (x : (x_1 ∈ nhdsWithin x s : Prop) ∧ (∀ᶠ (i : ι) in p, ∀ (a : α) (a_1 : a ∈ x_1), F i a - f a ∈ u : Prop)) → Prop)\n    (x_2 : (x_1 ∈ nhdsWithin x s : Prop) ∧ (∀ᶠ (i : ι) in p, ∀ (a : α) (a_1 : a ∈ x_1), F i a - f a ∈ u : Prop))\n    (h_1 :\n      ∀ (h : x_1 ∈ nhdsWithin x s) (hp : ∀ᶠ (i : ι) in p, ∀ (a : α) (a_1 : a ∈ x_1), F i a - f a ∈ u),\n        motive\n          ({ left := ((h)),\n              right :=\n                ((hp)) }=:(x_1 ∈ nhdsWithin x s : Prop) ∧\n              (∀ᶠ (i : ι) in p, ∀ (a : α) (a_1 : a ∈ x_1), F i a - f a ∈ u : Prop))),\n    motive x_2 :\n  Prop)", "type": "∀ {G : Type u_3} [inst : AddGroup G] {ι : Type u_2} {α : Type u_1} [inst_1 : TopologicalSpace α]\n  (F : (a : ι) → (a : α) → G) (f : (a : α) → G) (p : Filter ι) (s : Set α) (x : α) (u : Set G) (x_1 : Set α)\n  (motive : (x : (x_1 ∈ nhdsWithin x s) ∧ (∀ᶠ (i : ι) in p, ∀ (a : α) (a_1 : a ∈ x_1), F i a - f a ∈ u)) → Prop)\n  (x_2 : (x_1 ∈ nhdsWithin x s) ∧ (∀ᶠ (i : ι) in p, ∀ (a : α) (a_1 : a ∈ x_1), F i a - f a ∈ u))\n  (h_1 :\n    ∀ (h : x_1 ∈ nhdsWithin x s) (hp : ∀ᶠ (i : ι) in p, ∀ (a : α) (a_1 : a ∈ x_1), F i a - f a ∈ u),\n      motive ({ left := ((h)), right := ((hp)) })),\n  motive x_2", "thm": " : ∀ {G : Type u_3} [inst : AddGroup G] {ι : Type u_2} {α : Type u_1} [inst_1 : TopologicalSpace α]\n  (F : (a : ι) → (a : α) → G) (f : (a : α) → G) (p : Filter ι) (s : Set α) (x : α) (u : Set G) (x_1 : Set α)\n  (motive : (x : (x_1 ∈ nhdsWithin x s) ∧ (∀ᶠ (i : ι) in p, ∀ (a : α) (a_1 : a ∈ x_1), F i a - f a ∈ u)) → Prop)\n  (x_2 : (x_1 ∈ nhdsWithin x s) ∧ (∀ᶠ (i : ι) in p, ∀ (a : α) (a_1 : a ∈ x_1), F i a - f a ∈ u))\n  (h_1 :\n    ∀ (h : x_1 ∈ nhdsWithin x s) (hp : ∀ᶠ (i : ι) in p, ∀ (a : α) (a_1 : a ∈ x_1), F i a - f a ∈ u),\n      motive ({ left := ((h)), right := ((hp)) })),\n  motive x_2", "terms": [], "namedLemmas": [], "lemmas": [{"prop": "∀ (left : x_1 ∈ nhdsWithin x s) (right : ∀ᶠ (i : ι) in p, ∀ (a : α) (a_1 : a ∈ x_1), F i a - f a ∈ u),\n  motive ({ left := ((left)), right := ((right)) })", "context": ["{G : Type u_3}", "[AddGroup G]", "{ι : Type u_2}", "{α : Type u_1}", "[TopologicalSpace α]", "(F : (a : ι) → (a : α) → G)", "(f : (a : α) → G)", "(p : Filter ι)", "(s : Set α)", "(x : α)", "(u : Set G)", "(x_1 : Set α)", "(motive : (x : (x_1 ∈ nhdsWithin x s) ∧ (∀ᶠ (i : ι) in p, ∀ (a : α) (a_1 : a ∈ x_1), F i a - f a ∈ u)) → Prop)", "(x_2 : (x_1 ∈ nhdsWithin x s) ∧ (∀ᶠ (i : ι) in p, ∀ (a : α) (a_1 : a ∈ x_1), F i a - f a ∈ u))", "(h_1 : ∀ (h : x_1 ∈ nhdsWithin x s) (hp : ∀ᶠ (i : ι) in p, ∀ (a : α) (a_1 : a ∈ x_1), F i a - f a ∈ u),\n  motive ({ left := ((h)), right := ((hp)) }))"]}], "ids": [], "idString": "", "context": []}
{"typeGroup": "(∀ (z : Complex.UnitDisc)\n    (hz : optParam (↑Complex.abs ↑z < 1 : Prop) (Complex.UnitDisc.abs_lt_one z=:↑Complex.abs ↑z < 1)),\n    Complex.UnitDisc.mk (↑z) hz = z :\n  Prop)", "type": "∀ (z : Complex.UnitDisc) (hz : optParam (↑Complex.abs ↑z < 1) (Complex.UnitDisc.abs_lt_one z)),\n  { val := ((↑z)), property := (((Complex.UnitDisc.mk.proof_1 (↑z) hz))) } = z", "thm": " : ∀ (z : Complex.UnitDisc) (hz : optParam (↑Complex.abs ↑z < 1) (Complex.UnitDisc.abs_lt_one z)),\n  { val := ((↑z)), property := (((Complex.UnitDisc.mk.proof_1 (↑z) hz))) } = z", "terms": [{"value": "↑z", "isProp": false, "context": ["(z : Complex.UnitDisc)", "(hz : optParam (↑Complex.abs ↑z < 1) (Complex.UnitDisc.abs_lt_one z))"]}], "namedLemmas": ["∀ {α : Type u} {p : α → Prop} (a : { x // p x }) (h : p ↑a), { val := ↑a, property := h } = a", "∀ (z : ℂ), ↑Complex.abs z < 1 → z ∈ Metric.ball 0 1"], "lemmas": [{"prop": "↑z ∈ Metric.ball 0 1", "context": ["(z : Complex.UnitDisc)", "(hz : optParam (↑Complex.abs ↑z < 1) (Complex.UnitDisc.abs_lt_one z))"]}], "ids": ["Subtype.eta", "Complex.UnitDisc.mk.proof_1"], "idString": "Subtype.eta; Complex.UnitDisc.mk.proof_1; ", "context": []}
{"typeGroup": "(∀ (x : Bool),\n    x ∈\n      { val := (({true, false})),\n        nodup :=\n          (((of_eq_true\n              (eq_true_of_decide\n                  (Eq.refl\n                      true=:true =\n                      true)=:(Multiset.Nodup {true, false} : Prop) = (True : Prop))=:Multiset.Nodup {true, false}))) } :\n  Prop)", "type": "∀ (x : Bool), x ∈ { val := (({true, false})), nodup := (((of_eq_true (eq_true_of_decide (Eq.refl true))))) }", "thm": " : ∀ (x : Bool), x ∈ { val := (({true, false})), nodup := (((of_eq_true (eq_true_of_decide (Eq.refl true))))) }", "terms": [], "namedLemmas": ["∀ {p : Prop}, p = True → p", "∀ {p : Prop} {x : Decidable p}, decide p = true → p = True", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {p : Prop}, p = True → p", "∀ {p : Prop} {x : Decidable p}, decide p = true → p = True", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {p : Prop}, p = True → p", "∀ {p : Prop} {x : Decidable p}, decide p = true → p = True"], "lemmas": [{"prop": "true = true", "context": ["(x : Bool)", "(t : Bool)"]}, {"prop": "(Multiset.Nodup {true, false}) = True", "context": ["(x : Bool)", "(t : Bool)"]}, {"prop": "Multiset.Nodup {true, false}", "context": ["(x : Bool)", "(t : Bool)"]}, {"prop": "false = x", "context": ["(x : Bool)", "(h : x = false)"]}, {"prop": "true = true", "context": ["(x : Bool)", "(h : x = false)"]}, {"prop": "(false ∈ { val := (({true, false})), nodup := (((of_eq_true (eq_true_of_decide (Eq.refl true))))) }) = True", "context": ["(x : Bool)", "(h : x = false)"]}, {"prop": "false ∈ { val := (({true, false})), nodup := (((of_eq_true (eq_true_of_decide (Eq.refl true))))) }", "context": ["(x : Bool)", "(h : x = false)"]}, {"prop": "∀ (h : x = false), x ∈ { val := (({true, false})), nodup := (((of_eq_true (eq_true_of_decide (Eq.refl true))))) }", "context": ["(x : Bool)"]}, {"prop": "true = x", "context": ["(x : Bool)", "(h : x = true)"]}, {"prop": "true = true", "context": ["(x : Bool)", "(h : x = true)"]}, {"prop": "(true ∈ { val := (({true, false})), nodup := (((of_eq_true (eq_true_of_decide (Eq.refl true))))) }) = True", "context": ["(x : Bool)", "(h : x = true)"]}, {"prop": "true ∈ { val := (({true, false})), nodup := (((of_eq_true (eq_true_of_decide (Eq.refl true))))) }", "context": ["(x : Bool)", "(h : x = true)"]}, {"prop": "∀ (h : x = true), x ∈ { val := (({true, false})), nodup := (((of_eq_true (eq_true_of_decide (Eq.refl true))))) }", "context": ["(x : Bool)"]}, {"prop": "x = x", "context": ["(x : Bool)"]}], "ids": ["h", "val", "true", "false", "nodup", "of_eq_true", "eq_true_of_decide", "Eq.refl", "true", "Eq.symm", "of_eq_true", "eq_true_of_decide", "Eq.refl", "true", "Eq.symm", "of_eq_true", "eq_true_of_decide", "Eq.refl", "true", "Eq.refl"], "idString": "h; val; true; false; nodup; of_eq_true; eq_true_of_decide; Eq.refl; true; Eq.symm; of_eq_true; eq_true_of_decide; Eq.refl; true; Eq.symm; of_eq_true; eq_true_of_decide; Eq.refl; true; Eq.refl; ", "context": []}
{"typeGroup": "(∀ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {X : C} {Y : C} (f : X ⟶ Y),\n    (CategoryTheory.cokernelOpUnop f).inv =\n      (CategoryTheory.Limits.cokernel.desc f.op (CategoryTheory.Limits.kernel.ι f).op\n          (CategoryTheory.cokernelOpUnop.proof_4\n              f=:(CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.ι f) f).op = 0)).unop :\n  Prop)", "type": "∀ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {X : C} {Y : C} (f : X ⟶ Y),\n  (CategoryTheory.cokernelOpUnop f).inv = (CategoryTheory.cokernelOpUnop f).inv", "thm": " : ∀ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {X : C} {Y : C} (f : X ⟶ Y),\n  (CategoryTheory.cokernelOpUnop f).inv = (CategoryTheory.cokernelOpUnop f).inv", "terms": [], "namedLemmas": [], "lemmas": [], "ids": ["Eq.refl", "CategoryTheory.cokernelOpUnop", "inv"], "idString": "Eq.refl; CategoryTheory.cokernelOpUnop; inv; ", "context": []}
{"typeGroup": "(∀ (G : Type u_1) [inst : CommGroup G] {x : G}\n    (hx :\n      x ∈\n        Subsemigroup.carrier\n          (Submonoid.toSubsemigroup\n            { toSubsemigroup := ((Submonoid.toSubsemigroup (CommMonoid.torsion G))),\n              one_mem' :=\n                (((Submonoid.one_mem'\n                    (CommMonoid.torsion\n                      G)=:1 ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup (CommMonoid.torsion G))))) })),\n    IsOfFinOrder x⁻¹ :\n  Prop)", "type": "∀ (G : Type u_1) [inst : CommGroup G] {x : G}\n  (hx :\n    x ∈\n      Subsemigroup.carrier\n        (Submonoid.toSubsemigroup\n          { toSubsemigroup := ((Submonoid.toSubsemigroup (CommMonoid.torsion G))),\n            one_mem' := (((Submonoid.one_mem' (CommMonoid.torsion G)))) })),\n  IsOfFinOrder x⁻¹", "thm": " : ∀ (G : Type u_1) [inst : CommGroup G] {x : G}\n  (hx :\n    x ∈\n      Subsemigroup.carrier\n        (Submonoid.toSubsemigroup\n          { toSubsemigroup := ((Submonoid.toSubsemigroup (CommMonoid.torsion G))),\n            one_mem' := (((Submonoid.one_mem' (CommMonoid.torsion G)))) })),\n  IsOfFinOrder x⁻¹", "terms": [], "namedLemmas": ["∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → IsOfFinOrder x⁻¹"], "lemmas": [], "ids": ["IsOfFinOrder.inv"], "idString": "IsOfFinOrder.inv; ", "context": []}
{"typeGroup": "(∀ {n : ℕ} {p : Fin (n + 1)} (h : p ≠ Fin.last n) (x : { x : Fin (n + 1) // x ≠ p }),\n    ↑(OrderIso.symm (finSuccAboveEquiv p)) x = Fin.predAbove (Fin.castLT p (Fin.val_lt_last h=:↑p < n)) ↑x :\n  Prop)", "type": "∀ {n : ℕ} {p : Fin (n + 1)} (h : p ≠ Fin.last n) (x : { x : Fin (n + 1) // x ≠ p }),\n  ↑(OrderIso.symm (finSuccAboveEquiv p)) x = Fin.predAbove (Fin.castLT p (Fin.val_lt_last h)) ↑x", "thm": " : ∀ {n : ℕ} {p : Fin (n + 1)} (h : p ≠ Fin.last n) (x : { x : Fin (n + 1) // x ≠ p }),\n  ↑(OrderIso.symm (finSuccAboveEquiv p)) x = Fin.predAbove (Fin.castLT p (Fin.val_lt_last h)) ↑x", "terms": [{"value": "finSuccAboveEquiv p", "isProp": false, "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"value": "Fin.castLT p (Fin.val_lt_last h)", "isProp": false, "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"value": "↑x", "isProp": false, "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"value": "{ val := (((finSuccEquiv' p).symm)), property := (((finSuccAboveEquiv.proof_1 p))) }", "isProp": false, "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"value": "finSuccEquiv' p", "isProp": false, "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"value": "Fin.predAbove (Fin.castLT p (Fin.val_lt_last h)) ↑x", "isProp": false, "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"value": "some (Fin.predAbove (Fin.castLT p (Fin.val_lt_last h)) ↑x)", "isProp": false, "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}], "namedLemmas": ["∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {α : Type u_1} {a b : α}, some a = some b ↔ a = b", "∀ {n : ℕ} {i : Fin (n + 1)}, i ≠ Fin.last n → ↑i < n", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Type u_2} {β : Type u_1} [inst : DecidableEq β] (x : β) (e : { e // ↑e none = x }) (b : { y // y ≠ x }),\n  some (↑(↑(Equiv.optionSubtype x) e).symm b) = ↑(↑e).symm ↑b", "∀ {α : Type u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a", "∀ {n : ℕ} (p : Fin (n + 1)), ↑(finSuccEquiv' p).symm none = ↑(finSuccEquiv' p).symm none", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Sort u} {β : Sort v} (e : α ≃ β), e.symm.symm = e", "∀ {n : ℕ} {i : Fin (n + 1)}, i ≠ Fin.last n → ↑i < n", "∀ {n : ℕ} {i j : Fin (n + 1)} (hi : i ≠ Fin.last n),\n  j ≠ i → ↑(finSuccEquiv' i) j = some (Fin.predAbove (Fin.castLT i (_ : ↑i < n)) j)", "∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self"], "lemmas": [{"prop": "(some (↑(OrderIso.symm (finSuccAboveEquiv p)) x) = some (Fin.predAbove (Fin.castLT p (Fin.val_lt_last h)) ↑x)) ↔\n  (↑(OrderIso.symm (finSuccAboveEquiv p)) x = Fin.predAbove (Fin.castLT p (Fin.val_lt_last h)) ↑x)", "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"prop": "(some (↑(OrderIso.symm (finSuccAboveEquiv p)) x) = some (Fin.predAbove (Fin.castLT p (Fin.val_lt_last h)) ↑x)) =\n  (↑(OrderIso.symm (finSuccAboveEquiv p)) x = Fin.predAbove (Fin.castLT p (Fin.val_lt_last h)) ↑x)", "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"prop": "(↑(OrderIso.symm (finSuccAboveEquiv p)) x = Fin.predAbove (Fin.castLT p (Fin.val_lt_last h)) ↑x) =\n  (some (↑(OrderIso.symm (finSuccAboveEquiv p)) x) = some (Fin.predAbove (Fin.castLT p (Fin.val_lt_last h)) ↑x))", "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"prop": "↑p < n", "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"prop": "(↑(OrderIso.symm (finSuccAboveEquiv p)) x = Fin.predAbove (Fin.castLT p (Fin.val_lt_last h)) ↑x) =\n  (↑(OrderIso.symm (finSuccAboveEquiv p)) x = Fin.predAbove (Fin.castLT p (Fin.val_lt_last h)) ↑x)", "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"prop": "(↑(OrderIso.symm (finSuccAboveEquiv p)) x = Fin.predAbove (Fin.castLT p (Fin.val_lt_last h)) ↑x) =\n  (some (↑(OrderIso.symm (finSuccAboveEquiv p)) x) = some (Fin.predAbove (Fin.castLT p (Fin.val_lt_last h)) ↑x))", "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"prop": "(↑(OrderIso.symm (finSuccAboveEquiv p)) x = Fin.predAbove (Fin.castLT p (Fin.val_lt_last h)) ↑x) =\n  (some (↑(OrderIso.symm (finSuccAboveEquiv p)) x) = some (Fin.predAbove (Fin.castLT p (Fin.val_lt_last h)) ↑x))", "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"prop": "↑(finSuccEquiv' p).symm none = ↑(finSuccEquiv' p).symm none", "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"prop": "some\n    (↑(↑(Equiv.optionSubtype p)\n            { val := (((finSuccEquiv' p).symm)), property := (((finSuccAboveEquiv.proof_1 p))) }).symm\n      x) =\n  ↑(↑{ val := (((finSuccEquiv' p).symm)), property := (((finSuccAboveEquiv.proof_1 p))) }).symm ↑x", "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"prop": "(finSuccEquiv' p).symm.symm = finSuccEquiv' p", "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"prop": "↑(finSuccEquiv' p).symm.symm = ↑(finSuccEquiv' p)", "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"prop": "↑(finSuccEquiv' p).symm.symm ↑x = ↑(finSuccEquiv' p) ↑x", "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"prop": "some\n    (↑(↑(Equiv.optionSubtype p)\n            { val := (((finSuccEquiv' p).symm)), property := (((finSuccAboveEquiv.proof_1 p))) }).symm\n      x) =\n  ↑(finSuccEquiv' p) ↑x", "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"prop": "Eq\n    (some\n      (↑(↑(Equiv.optionSubtype p)\n              { val := (((finSuccEquiv' p).symm)), property := (((finSuccAboveEquiv.proof_1 p))) }).symm\n        x)) =\n  Eq (↑(finSuccEquiv' p) ↑x)", "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"prop": "↑p < n", "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"prop": "(some\n      (↑(↑(Equiv.optionSubtype p)\n              { val := (((finSuccEquiv' p).symm)), property := (((finSuccAboveEquiv.proof_1 p))) }).symm\n        x) =\n    some (Fin.predAbove (Fin.castLT p (Fin.val_lt_last h)) ↑x)) =\n  (↑(finSuccEquiv' p) ↑x = some (Fin.predAbove (Fin.castLT p (Fin.val_lt_last h)) ↑x))", "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"prop": "(some (↑(OrderIso.symm (finSuccAboveEquiv p)) x) = some (Fin.predAbove (Fin.castLT p (Fin.val_lt_last h)) ↑x)) =\n  (↑(finSuccEquiv' p) ↑x = some (Fin.predAbove (Fin.castLT p (Fin.val_lt_last h)) ↑x))", "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"prop": "↑x ≠ p", "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"prop": "↑(finSuccEquiv' p) ↑x = some (Fin.predAbove (Fin.castLT p (Fin.val_lt_last h)) ↑x)", "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}, {"prop": "some (↑(OrderIso.symm (finSuccAboveEquiv p)) x) = some (Fin.predAbove (Fin.castLT p (Fin.val_lt_last h)) ↑x)", "context": ["{n : ℕ}", "{p : Fin (n + 1)}", "(h : p ≠ Fin.last n)", "(x : { x : Fin (n + 1) // x ≠ p })"]}], "ids": ["Eq.mpr", "id", "Eq.symm", "propext", "Option.some_inj", "Eq.refl", "OrderIso.symm", "finSuccAboveEquiv", "Fin.predAbove", "Fin.castLT", "Fin.val_lt_last", "Eq.mpr", "id", "congrFun", "congrArg", "Eq", "Eq.trans", "Equiv.optionSubtype_apply_symm_apply", "val", "finSuccEquiv'", "symm", "property", "finSuccAboveEquiv.proof_1", "congrFun", "congrArg", "FunLike.coe", "Equiv.symm_symm", "finSuccEquiv'", "some", "Fin.predAbove", "Fin.castLT", "Fin.val_lt_last", "finSuccEquiv'_ne_last_apply", "Subtype.property"], "idString": "Eq.mpr; id; Eq.symm; propext; Option.some_inj; Eq.refl; OrderIso.symm; finSuccAboveEquiv; Fin.predAbove; Fin.castLT; Fin.val_lt_last; Eq.mpr; id; congrFun; congrArg; Eq; Eq.trans; Equiv.optionSubtype_apply_symm_apply; val; finSuccEquiv'; symm; property; finSuccAboveEquiv.proof_1; congrFun; congrArg; FunLike.coe; Equiv.symm_symm; finSuccEquiv'; some; Fin.predAbove; Fin.castLT; Fin.val_lt_last; finSuccEquiv'_ne_last_apply; Subtype.property; ", "context": []}
{"typeGroup": "(∀ {toLocallyRingedSpace : AlgebraicGeometry.LocallyRingedSpace}\n    {local_affine :\n      ∀ (x : ↑(AlgebraicGeometry.LocallyRingedSpace.toTopCat toLocallyRingedSpace)),\n        ∃ (U : TopologicalSpace.OpenNhds x),\n          ∃ (R : CommRingCat),\n            Nonempty\n              (AlgebraicGeometry.LocallyRingedSpace.restrict toLocallyRingedSpace\n                  (TopologicalSpace.OpenNhds.openEmbedding\n                      U=:OpenEmbedding ↑(TopologicalSpace.Opens.inclusion (CategoryTheory.FullSubcategory.obj U))) ≅\n                (CategoryTheory.Functor.toPrefunctor AlgebraicGeometry.Spec.toLocallyRingedSpace).obj (Opposite.op R))}\n    {toLocallyRingedSpace_1 : AlgebraicGeometry.LocallyRingedSpace}\n    {local_affine_1 :\n      ∀ (x : ↑(AlgebraicGeometry.LocallyRingedSpace.toTopCat toLocallyRingedSpace_1)),\n        ∃ (U : TopologicalSpace.OpenNhds x),\n          ∃ (R : CommRingCat),\n            Nonempty\n              (AlgebraicGeometry.LocallyRingedSpace.restrict toLocallyRingedSpace_1\n                  (TopologicalSpace.OpenNhds.openEmbedding\n                      U=:OpenEmbedding ↑(TopologicalSpace.Opens.inclusion (CategoryTheory.FullSubcategory.obj U))) ≅\n                (CategoryTheory.Functor.toPrefunctor AlgebraicGeometry.Spec.toLocallyRingedSpace).obj (Opposite.op R))}\n    (x :\n      { toLocallyRingedSpace := ((toLocallyRingedSpace)), local_affine := ((local_affine)) } =\n        { toLocallyRingedSpace := ((toLocallyRingedSpace_1)), local_affine := ((local_affine_1)) }),\n    toLocallyRingedSpace = toLocallyRingedSpace_1 :\n  Prop)", "type": "∀ {toLocallyRingedSpace : AlgebraicGeometry.LocallyRingedSpace}\n  {local_affine :\n    ∀ (x : ↑(AlgebraicGeometry.LocallyRingedSpace.toTopCat toLocallyRingedSpace)),\n      ∃ (U : TopologicalSpace.OpenNhds x),\n        ∃ (R : CommRingCat),\n          Nonempty\n            (AlgebraicGeometry.LocallyRingedSpace.restrict toLocallyRingedSpace\n                (TopologicalSpace.OpenNhds.openEmbedding U) ≅\n              (CategoryTheory.Functor.toPrefunctor AlgebraicGeometry.Spec.toLocallyRingedSpace).obj (Opposite.op R))}\n  {toLocallyRingedSpace_1 : AlgebraicGeometry.LocallyRingedSpace}\n  {local_affine_1 :\n    ∀ (x : ↑(AlgebraicGeometry.LocallyRingedSpace.toTopCat toLocallyRingedSpace_1)),\n      ∃ (U : TopologicalSpace.OpenNhds x),\n        ∃ (R : CommRingCat),\n          Nonempty\n            (AlgebraicGeometry.LocallyRingedSpace.restrict toLocallyRingedSpace_1\n                (TopologicalSpace.OpenNhds.openEmbedding U) ≅\n              (CategoryTheory.Functor.toPrefunctor AlgebraicGeometry.Spec.toLocallyRingedSpace).obj (Opposite.op R))}\n  (x :\n    { toLocallyRingedSpace := ((toLocallyRingedSpace)), local_affine := ((local_affine)) } =\n      { toLocallyRingedSpace := ((toLocallyRingedSpace_1)), local_affine := ((local_affine_1)) }),\n  toLocallyRingedSpace = toLocallyRingedSpace_1", "thm": " : ∀ {toLocallyRingedSpace : AlgebraicGeometry.LocallyRingedSpace}\n  {local_affine :\n    ∀ (x : ↑(AlgebraicGeometry.LocallyRingedSpace.toTopCat toLocallyRingedSpace)),\n      ∃ (U : TopologicalSpace.OpenNhds x),\n        ∃ (R : CommRingCat),\n          Nonempty\n            (AlgebraicGeometry.LocallyRingedSpace.restrict toLocallyRingedSpace\n                (TopologicalSpace.OpenNhds.openEmbedding U) ≅\n              (CategoryTheory.Functor.toPrefunctor AlgebraicGeometry.Spec.toLocallyRingedSpace).obj (Opposite.op R))}\n  {toLocallyRingedSpace_1 : AlgebraicGeometry.LocallyRingedSpace}\n  {local_affine_1 :\n    ∀ (x : ↑(AlgebraicGeometry.LocallyRingedSpace.toTopCat toLocallyRingedSpace_1)),\n      ∃ (U : TopologicalSpace.OpenNhds x),\n        ∃ (R : CommRingCat),\n          Nonempty\n            (AlgebraicGeometry.LocallyRingedSpace.restrict toLocallyRingedSpace_1\n                (TopologicalSpace.OpenNhds.openEmbedding U) ≅\n              (CategoryTheory.Functor.toPrefunctor AlgebraicGeometry.Spec.toLocallyRingedSpace).obj (Opposite.op R))}\n  (x :\n    { toLocallyRingedSpace := ((toLocallyRingedSpace)), local_affine := ((local_affine)) } =\n      { toLocallyRingedSpace := ((toLocallyRingedSpace_1)), local_affine := ((local_affine_1)) }),\n  toLocallyRingedSpace = toLocallyRingedSpace_1", "terms": [], "namedLemmas": [], "lemmas": [{"prop": "∀ (toLocallyRingedSpace_eq : toLocallyRingedSpace = toLocallyRingedSpace_1),\n  toLocallyRingedSpace = toLocallyRingedSpace_1", "context": ["{toLocallyRingedSpace : AlgebraicGeometry.LocallyRingedSpace}", "{local_affine : ∀ (x : ↑(AlgebraicGeometry.LocallyRingedSpace.toTopCat toLocallyRingedSpace)),\n  ∃ (U : TopologicalSpace.OpenNhds x),\n    ∃ (R : CommRingCat),\n      Nonempty\n        (AlgebraicGeometry.LocallyRingedSpace.restrict toLocallyRingedSpace\n            (TopologicalSpace.OpenNhds.openEmbedding U) ≅\n          (CategoryTheory.Functor.toPrefunctor AlgebraicGeometry.Spec.toLocallyRingedSpace).obj (Opposite.op R))}", "{toLocallyRingedSpace_1 : AlgebraicGeometry.LocallyRingedSpace}", "{local_affine_1 : ∀ (x : ↑(AlgebraicGeometry.LocallyRingedSpace.toTopCat toLocallyRingedSpace_1)),\n  ∃ (U : TopologicalSpace.OpenNhds x),\n    ∃ (R : CommRingCat),\n      Nonempty\n        (AlgebraicGeometry.LocallyRingedSpace.restrict toLocallyRingedSpace_1\n            (TopologicalSpace.OpenNhds.openEmbedding U) ≅\n          (CategoryTheory.Functor.toPrefunctor AlgebraicGeometry.Spec.toLocallyRingedSpace).obj (Opposite.op R))}", "(x : { toLocallyRingedSpace := ((toLocallyRingedSpace)), local_affine := ((local_affine)) } =\n  { toLocallyRingedSpace := ((toLocallyRingedSpace_1)), local_affine := ((local_affine_1)) })"]}], "ids": ["AlgebraicGeometry.Scheme.noConfusion"], "idString": "AlgebraicGeometry.Scheme.noConfusion; ", "context": []}
{"typeGroup": "(∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α →. β) (g : α →. γ) (x : α),\n    PFun.prodLift f g x =\n      { Dom := ((((Part.Dom (f x) : Prop) ∧ (Part.Dom (g x) : Prop) : Prop))),\n        get :=\n          ((fun (h : (Part.Dom (f x) : Prop) ∧ (Part.Dom (g x) : Prop)) ↦\n            (Part.get (f x) (And.left h=:Part.Dom (f x)), Part.get (g x) (And.right h=:Part.Dom (g x))))) } :\n  Prop)", "type": "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α →. β) (g : α →. γ) (x : α),\n  PFun.prodLift f g x = PFun.prodLift f g x", "thm": " : ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α →. β) (g : α →. γ) (x : α),\n  PFun.prodLift f g x = PFun.prodLift f g x", "terms": [], "namedLemmas": ["∀ {α : Sort u} {a : α}, a = a"], "lemmas": [], "ids": ["rfl"], "idString": "rfl; ", "context": []}
{"typeGroup": "(∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (f : C(α, β)) (x : α)\n    (x_1 : TopologicalSpace.OpenNhdsOf (↑f x)) (x_2 : TopologicalSpace.OpenNhdsOf (↑f x)),\n    SupHom.toFun\n        {\n          toFun :=\n            ((fun (U : TopologicalSpace.OpenNhdsOf (↑f x)) ↦\n              { toOpens := ((↑(TopologicalSpace.Opens.comap f) (TopologicalSpace.OpenNhdsOf.toOpens U))),\n                mem' := (((TopologicalSpace.OpenNhdsOf.mem U=:↑f x ∈ U))) })),\n          map_sup' :=\n            (((fun (x_3 : TopologicalSpace.OpenNhdsOf (↑f x)) ↦\n              (_ :\n                ∀ (x_4 : TopologicalSpace.OpenNhdsOf (↑f x)),\n                  (fun (U : TopologicalSpace.OpenNhdsOf (↑f x)) ↦\n                        { toOpens := ((↑(TopologicalSpace.Opens.comap f) (TopologicalSpace.OpenNhdsOf.toOpens U))),\n                          mem' := (((TopologicalSpace.OpenNhdsOf.mem U=:↑f x ∈ U))) })\n                      (x_3 ⊔ x_4) =\n                    (fun (U : TopologicalSpace.OpenNhdsOf (↑f x)) ↦\n                        { toOpens := ((↑(TopologicalSpace.Opens.comap f) (TopologicalSpace.OpenNhdsOf.toOpens U))),\n                          mem' := (((TopologicalSpace.OpenNhdsOf.mem U=:↑f x ∈ U))) })\n                      (x_3 ⊔\n                        x_4))=:∀ (x_3 : TopologicalSpace.OpenNhdsOf (↑f x)) (x_4 : TopologicalSpace.OpenNhdsOf (↑f x)),\n                (fun (U : TopologicalSpace.OpenNhdsOf (↑f x)) ↦\n                      { toOpens := ((↑(TopologicalSpace.Opens.comap f) (TopologicalSpace.OpenNhdsOf.toOpens U))),\n                        mem' := (((TopologicalSpace.OpenNhdsOf.mem U=:↑f x ∈ U))) })\n                    (x_3 ⊔ x_4) =\n                  (fun (U : TopologicalSpace.OpenNhdsOf (↑f x)) ↦\n                      { toOpens := ((↑(TopologicalSpace.Opens.comap f) (TopologicalSpace.OpenNhdsOf.toOpens U))),\n                        mem' := (((TopologicalSpace.OpenNhdsOf.mem U=:↑f x ∈ U))) })\n                    (x_3 ⊔ x_4)))) }\n        (x_1 ⊓ x_2) =\n      SupHom.toFun\n        {\n          toFun :=\n            ((fun (U : TopologicalSpace.OpenNhdsOf (↑f x)) ↦\n              { toOpens := ((↑(TopologicalSpace.Opens.comap f) (TopologicalSpace.OpenNhdsOf.toOpens U))),\n                mem' := (((TopologicalSpace.OpenNhdsOf.mem U=:↑f x ∈ U))) })),\n          map_sup' :=\n            (((fun (x_3 : TopologicalSpace.OpenNhdsOf (↑f x)) ↦\n              (_ :\n                ∀ (x_4 : TopologicalSpace.OpenNhdsOf (↑f x)),\n                  (fun (U : TopologicalSpace.OpenNhdsOf (↑f x)) ↦\n                        { toOpens := ((↑(TopologicalSpace.Opens.comap f) (TopologicalSpace.OpenNhdsOf.toOpens U))),\n                          mem' := (((TopologicalSpace.OpenNhdsOf.mem U=:↑f x ∈ U))) })\n                      (x_3 ⊔ x_4) =\n                    (fun (U : TopologicalSpace.OpenNhdsOf (↑f x)) ↦\n                        { toOpens := ((↑(TopologicalSpace.Opens.comap f) (TopologicalSpace.OpenNhdsOf.toOpens U))),\n                          mem' := (((TopologicalSpace.OpenNhdsOf.mem U=:↑f x ∈ U))) })\n                      (x_3 ⊔\n                        x_4))=:∀ (x_3 : TopologicalSpace.OpenNhdsOf (↑f x)) (x_4 : TopologicalSpace.OpenNhdsOf (↑f x)),\n                (fun (U : TopologicalSpace.OpenNhdsOf (↑f x)) ↦\n                      { toOpens := ((↑(TopologicalSpace.Opens.comap f) (TopologicalSpace.OpenNhdsOf.toOpens U))),\n                        mem' := (((TopologicalSpace.OpenNhdsOf.mem U=:↑f x ∈ U))) })\n                    (x_3 ⊔ x_4) =\n                  (fun (U : TopologicalSpace.OpenNhdsOf (↑f x)) ↦\n                      { toOpens := ((↑(TopologicalSpace.Opens.comap f) (TopologicalSpace.OpenNhdsOf.toOpens U))),\n                        mem' := (((TopologicalSpace.OpenNhdsOf.mem U=:↑f x ∈ U))) })\n                    (x_3 ⊔ x_4)))) }\n        (x_1 ⊓ x_2) :\n  Prop)", "type": "∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (f : C(α, β)) (x : α)\n  (x_1 : TopologicalSpace.OpenNhdsOf (↑f x)) (x_2 : TopologicalSpace.OpenNhdsOf (↑f x)),\n  SupHom.toFun\n      {\n        toFun :=\n          ((fun (U : TopologicalSpace.OpenNhdsOf (↑f x)) ↦\n            { toOpens := ((↑(TopologicalSpace.Opens.comap f) (TopologicalSpace.OpenNhdsOf.toOpens U))),\n              mem' := (((TopologicalSpace.OpenNhdsOf.mem U))) })),\n        map_sup' :=\n          (((fun (x_3 : TopologicalSpace.OpenNhdsOf (↑f x)) (x_4 : TopologicalSpace.OpenNhdsOf (↑f x)) ↦ rfl))) }\n      (x_1 ⊓ x_2) =\n    SupHom.toFun\n      {\n        toFun :=\n          ((fun (U : TopologicalSpace.OpenNhdsOf (↑f x)) ↦\n            { toOpens := ((↑(TopologicalSpace.Opens.comap f) (TopologicalSpace.OpenNhdsOf.toOpens U))),\n              mem' := (((TopologicalSpace.OpenNhdsOf.mem U))) })),\n        map_sup' :=\n          (((fun (x_3 : TopologicalSpace.OpenNhdsOf (↑f x)) (x_4 : TopologicalSpace.OpenNhdsOf (↑f x)) ↦ rfl))) }\n      (x_1 ⊓ x_2)", "thm": " : ∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (f : C(α, β)) (x : α)\n  (x_1 : TopologicalSpace.OpenNhdsOf (↑f x)) (x_2 : TopologicalSpace.OpenNhdsOf (↑f x)),\n  SupHom.toFun\n      {\n        toFun :=\n          ((fun (U : TopologicalSpace.OpenNhdsOf (↑f x)) ↦\n            { toOpens := ((↑(TopologicalSpace.Opens.comap f) (TopologicalSpace.OpenNhdsOf.toOpens U))),\n              mem' := (((TopologicalSpace.OpenNhdsOf.mem U))) })),\n        map_sup' :=\n          (((fun (x_3 : TopologicalSpace.OpenNhdsOf (↑f x)) (x_4 : TopologicalSpace.OpenNhdsOf (↑f x)) ↦ rfl))) }\n      (x_1 ⊓ x_2) =\n    SupHom.toFun\n      {\n        toFun :=\n          ((fun (U : TopologicalSpace.OpenNhdsOf (↑f x)) ↦\n            { toOpens := ((↑(TopologicalSpace.Opens.comap f) (TopologicalSpace.OpenNhdsOf.toOpens U))),\n              mem' := (((TopologicalSpace.OpenNhdsOf.mem U))) })),\n        map_sup' :=\n          (((fun (x_3 : TopologicalSpace.OpenNhdsOf (↑f x)) (x_4 : TopologicalSpace.OpenNhdsOf (↑f x)) ↦ rfl))) }\n      (x_1 ⊓ x_2)", "terms": [], "namedLemmas": ["∀ {α : Sort u} {a : α}, a = a"], "lemmas": [], "ids": ["rfl"], "idString": "rfl; ", "context": []}
{"typeGroup": "(∀ {M : Type u_3} {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace M] [inst_1 : MeasurableSpace α]\n    {μ : MeasureTheory.Measure α} [inst_2 : TopologicalSpace β] [inst_3 : SMul M α] [inst_4 : MeasurableSMul M α]\n    [inst_5 : MeasureTheory.SMulInvariantMeasure M α μ] (c : M) (f : (a : α) → β)\n    (hf : MeasureTheory.AEStronglyMeasurable f μ),\n    ↑DomMulAct.mk c • MeasureTheory.AEEqFun.mk f hf =\n      MeasureTheory.AEEqFun.mk (fun (x : α) ↦ f (c • x))\n        (MeasureTheory.AEStronglyMeasurable.comp_measurePreserving hf\n            (MeasureTheory.measurePreserving_smul c\n                μ=:MeasureTheory.MeasurePreserving fun (x : α) ↦\n                c • x)=:MeasureTheory.AEStronglyMeasurable (f ∘ fun (x : α) ↦ c • x) μ) :\n  Prop)", "type": "∀ {M : Type u_3} {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace M] [inst_1 : MeasurableSpace α]\n  {μ : MeasureTheory.Measure α} [inst_2 : TopologicalSpace β] [inst_3 : SMul M α] [inst_4 : MeasurableSMul M α]\n  [inst_5 : MeasureTheory.SMulInvariantMeasure M α μ] (c : M) (f : (a : α) → β)\n  (hf : MeasureTheory.AEStronglyMeasurable f μ),\n  ↑DomMulAct.mk c • MeasureTheory.AEEqFun.mk f hf = ↑DomMulAct.mk c • MeasureTheory.AEEqFun.mk f hf", "thm": " : ∀ {M : Type u_3} {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace M] [inst_1 : MeasurableSpace α]\n  {μ : MeasureTheory.Measure α} [inst_2 : TopologicalSpace β] [inst_3 : SMul M α] [inst_4 : MeasurableSMul M α]\n  [inst_5 : MeasureTheory.SMulInvariantMeasure M α μ] (c : M) (f : (a : α) → β)\n  (hf : MeasureTheory.AEStronglyMeasurable f μ),\n  ↑DomMulAct.mk c • MeasureTheory.AEEqFun.mk f hf = ↑DomMulAct.mk c • MeasureTheory.AEEqFun.mk f hf", "terms": [], "namedLemmas": ["∀ {α : Sort u} {a : α}, a = a"], "lemmas": [], "ids": ["rfl"], "idString": "rfl; ", "context": []}
{"typeGroup": "(∀ {M : Type u_1} [inst : CommMonoid M] {a : ℕ} {b : ℕ} (f : (a : Fin (a + b)) → M)\n    (hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1),\n    (Finset.prod Finset.univ fun (i : Fin (a + b)) ↦ f i) =\n      Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castLE (Nat.le.intro (rfl=:a + b = a + b)=:a ≤ a + b) i) :\n  Prop)", "type": "∀ {M : Type u_1} [inst : CommMonoid M] {a : ℕ} {b : ℕ} (f : (a : Fin (a + b)) → M)\n  (hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1),\n  (Finset.prod Finset.univ fun (i : Fin (a + b)) ↦ f i) =\n    Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castLE (Nat.le.intro rfl) i)", "thm": " : ∀ {M : Type u_1} [inst : CommMonoid M] {a : ℕ} {b : ℕ} (f : (a : Fin (a + b)) → M)\n  (hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1),\n  (Finset.prod Finset.univ fun (i : Fin (a + b)) ↦ f i) =\n    Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castLE (Nat.le.intro rfl) i)", "terms": [{"value": "Fin.castLE (Nat.le.intro rfl) i", "isProp": false, "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)", "(i : Fin a)"]}, {"value": "Fin.natAdd a a_1", "isProp": false, "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)", "(a_1 : Fin b)"]}, {"value": "Fin.castAdd b i", "isProp": false, "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)", "(i : Fin a)"]}, {"value": "Fin.natAdd a i", "isProp": false, "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)", "(i : Fin b)"]}, {"value": "Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castAdd b i)", "isProp": false, "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)"]}], "namedLemmas": ["∀ {M : Type u_1} [inst : CommMonoid M] {a b : ℕ} (f : Fin (a + b) → M),\n  (Finset.prod Finset.univ fun i => f i) =\n    (Finset.prod Finset.univ fun i => f (Fin.castAdd b i)) * Finset.prod Finset.univ fun i => f (Fin.natAdd a i)", "∀ {n m k : ℕ}, n + k = m → n ≤ m", "∀ {α : Sort u} {a : α}, a = a", "∀ {α : Type u_2} {M : Type u_1} [inst : Fintype α] [inst_1 : CommMonoid M] (f : α → M),\n  (∀ (a : α), f a = 1) → (Finset.prod Finset.univ fun a => f a) = 1", "∀ {n m k : ℕ}, n + k = m → n ≤ m", "∀ {α : Sort u} {a : α}, a = a", "∀ {M : Type u} [inst : MulOneClass M] (a : M), a * 1 = a", "∀ {n m k : ℕ}, n + k = m → n ≤ m", "∀ {α : Sort u} {a : α}, a = a"], "lemmas": [{"prop": "(Finset.prod Finset.univ fun (i : Fin (a + b)) ↦ f i) =\n  (Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castAdd b i)) *\n    Finset.prod Finset.univ fun (i : Fin b) ↦ f (Fin.natAdd a i)", "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)"]}, {"prop": "a + b = a + b", "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)", "(i : Fin a)"]}, {"prop": "a ≤ a + b", "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)", "(i : Fin a)"]}, {"prop": "((Finset.prod Finset.univ fun (i : Fin (a + b)) ↦ f i) =\n    Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castLE (Nat.le.intro rfl) i)) =\n  ((Finset.prod Finset.univ fun (i : Fin (a + b)) ↦ f i) =\n    Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castLE (Nat.le.intro rfl) i))", "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)"]}, {"prop": "((Finset.prod Finset.univ fun (i : Fin (a + b)) ↦ f i) =\n    Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castLE (Nat.le.intro rfl) i)) =\n  (((Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castAdd b i)) *\n      Finset.prod Finset.univ fun (i : Fin b) ↦ f (Fin.natAdd a i)) =\n    Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castLE (Nat.le.intro rfl) i))", "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)"]}, {"prop": "((Finset.prod Finset.univ fun (i : Fin (a + b)) ↦ f i) =\n    Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castLE (Nat.le.intro rfl) i)) =\n  (((Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castAdd b i)) *\n      Finset.prod Finset.univ fun (i : Fin b) ↦ f (Fin.natAdd a i)) =\n    Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castLE (Nat.le.intro rfl) i))", "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)"]}, {"prop": "(Finset.prod Finset.univ fun (a_1 : Fin b) ↦ f (Fin.natAdd a a_1)) = 1", "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)"]}, {"prop": "a + b = a + b", "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)", "(i : Fin a)"]}, {"prop": "a ≤ a + b", "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)", "(i : Fin a)"]}, {"prop": "(((Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castAdd b i)) *\n      Finset.prod Finset.univ fun (i : Fin b) ↦ f (Fin.natAdd a i)) =\n    Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castLE (Nat.le.intro rfl) i)) =\n  (((Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castAdd b i)) *\n      Finset.prod Finset.univ fun (i : Fin b) ↦ f (Fin.natAdd a i)) =\n    Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castLE (Nat.le.intro rfl) i))", "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)"]}, {"prop": "(((Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castAdd b i)) *\n      Finset.prod Finset.univ fun (i : Fin b) ↦ f (Fin.natAdd a i)) =\n    Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castLE (Nat.le.intro rfl) i)) =\n  ((Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castAdd b i)) * 1 =\n    Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castLE (Nat.le.intro rfl) i))", "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)"]}, {"prop": "(((Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castAdd b i)) *\n      Finset.prod Finset.univ fun (i : Fin b) ↦ f (Fin.natAdd a i)) =\n    Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castLE (Nat.le.intro rfl) i)) =\n  ((Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castAdd b i)) * 1 =\n    Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castLE (Nat.le.intro rfl) i))", "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)"]}, {"prop": "(Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castAdd b i)) * 1 =\n  Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castAdd b i)", "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)"]}, {"prop": "a + b = a + b", "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)", "(i : Fin a)"]}, {"prop": "a ≤ a + b", "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)", "(i : Fin a)"]}, {"prop": "((Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castAdd b i)) * 1 =\n    Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castLE (Nat.le.intro rfl) i)) =\n  ((Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castAdd b i)) * 1 =\n    Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castLE (Nat.le.intro rfl) i))", "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)"]}, {"prop": "((Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castAdd b i)) * 1 =\n    Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castLE (Nat.le.intro rfl) i)) =\n  ((Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castAdd b i)) =\n    Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castLE (Nat.le.intro rfl) i))", "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)"]}, {"prop": "((Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castAdd b i)) * 1 =\n    Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castLE (Nat.le.intro rfl) i)) =\n  ((Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castAdd b i)) =\n    Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castLE (Nat.le.intro rfl) i))", "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)"]}, {"prop": "(Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castAdd b i)) =\n  Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castAdd b i)", "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)"]}, {"prop": "(Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castAdd b i)) * 1 =\n  Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castLE (Nat.le.intro rfl) i)", "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)"]}, {"prop": "((Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castAdd b i)) *\n    Finset.prod Finset.univ fun (i : Fin b) ↦ f (Fin.natAdd a i)) =\n  Finset.prod Finset.univ fun (i : Fin a) ↦ f (Fin.castLE (Nat.le.intro rfl) i)", "context": ["{M : Type u_1}", "[CommMonoid M]", "{a : ℕ}", "{b : ℕ}", "(f : (a : Fin (a + b)) → M)", "(hf : ∀ (j : Fin b), f (Fin.natAdd a j) = 1)"]}], "ids": ["Eq.mpr", "id", "Fin.prod_univ_add", "Eq.refl", "Finset.prod", "Finset.univ", "Finset.prod", "Finset.univ", "Fin.castLE", "Nat.le.intro", "rfl", "Eq.mpr", "id", "Fintype.prod_eq_one", "Fin.natAdd", "Eq.refl", "Finset.prod", "Finset.univ", "Fin.castAdd", "Finset.prod", "Finset.univ", "Fin.natAdd", "Finset.prod", "Finset.univ", "Fin.castLE", "Nat.le.intro", "rfl", "Eq.mpr", "id", "mul_one", "Finset.prod", "Finset.univ", "Fin.castAdd", "Eq.refl", "Finset.prod", "Finset.univ", "Fin.castAdd", "Finset.prod", "Finset.univ", "Fin.castLE", "Nat.le.intro", "rfl", "Eq.refl", "Finset.prod", "Finset.univ", "Fin.castAdd"], "idString": "Eq.mpr; id; Fin.prod_univ_add; Eq.refl; Finset.prod; Finset.univ; Finset.prod; Finset.univ; Fin.castLE; Nat.le.intro; rfl; Eq.mpr; id; Fintype.prod_eq_one; Fin.natAdd; Eq.refl; Finset.prod; Finset.univ; Fin.castAdd; Finset.prod; Finset.univ; Fin.natAdd; Finset.prod; Finset.univ; Fin.castLE; Nat.le.intro; rfl; Eq.mpr; id; mul_one; Finset.prod; Finset.univ; Fin.castAdd; Eq.refl; Finset.prod; Finset.univ; Fin.castAdd; Finset.prod; Finset.univ; Fin.castLE; Nat.le.intro; rfl; Eq.refl; Finset.prod; Finset.univ; Fin.castAdd; ", "context": []}
{"typeGroup": "(∀ {α : Type u_1} {M : Type u_2} [inst : AddZeroClass M] (p : (a : α) → Prop) (f : α →₀ M) (g : α →₀ M),\n    ZeroHom.toFun { toFun := ((Finsupp.filter p)), map_zero' := (((Finsupp.filter_zero p=:Finsupp.filter p 0 = 0))) }\n        (f + g) =\n      ZeroHom.toFun { toFun := ((Finsupp.filter p)), map_zero' := (((Finsupp.filter_zero p=:Finsupp.filter p 0 = 0))) }\n          f +\n        ZeroHom.toFun\n          { toFun := ((Finsupp.filter p)), map_zero' := (((Finsupp.filter_zero p=:Finsupp.filter p 0 = 0))) } g :\n  Prop)", "type": "∀ {α : Type u_1} {M : Type u_2} [inst : AddZeroClass M] (p : (a : α) → Prop) (f : α →₀ M) (g : α →₀ M),\n  ZeroHom.toFun { toFun := ((Finsupp.filter p)), map_zero' := (((Finsupp.filter_zero p))) } (f + g) =\n    ZeroHom.toFun { toFun := ((Finsupp.filter p)), map_zero' := (((Finsupp.filter_zero p))) } f +\n      ZeroHom.toFun { toFun := ((Finsupp.filter p)), map_zero' := (((Finsupp.filter_zero p))) } g", "thm": " : ∀ {α : Type u_1} {M : Type u_2} [inst : AddZeroClass M] (p : (a : α) → Prop) (f : α →₀ M) (g : α →₀ M),\n  ZeroHom.toFun { toFun := ((Finsupp.filter p)), map_zero' := (((Finsupp.filter_zero p))) } (f + g) =\n    ZeroHom.toFun { toFun := ((Finsupp.filter p)), map_zero' := (((Finsupp.filter_zero p))) } f +\n      ZeroHom.toFun { toFun := ((Finsupp.filter p)), map_zero' := (((Finsupp.filter_zero p))) } g", "terms": [{"value": "{x : α | p x}", "isProp": false, "context": ["{α : Type u_1}", "{M : Type u_2}", "[AddZeroClass M]", "(p : (a : α) → Prop)", "(f : α →₀ M)", "(g : α →₀ M)"]}, {"value": "↑f", "isProp": false, "context": ["{α : Type u_1}", "{M : Type u_2}", "[AddZeroClass M]", "(p : (a : α) → Prop)", "(f : α →₀ M)", "(g : α →₀ M)"]}, {"value": "↑g", "isProp": false, "context": ["{α : Type u_1}", "{M : Type u_2}", "[AddZeroClass M]", "(p : (a : α) → Prop)", "(f : α →₀ M)", "(g : α →₀ M)"]}], "namedLemmas": ["∀ {F : Sort u_1} {α : Sort u_2} {β : α → Sort u_3} [i : FunLike F α β], Function.Injective fun f => ↑f", "∀ {α : Type u_1} {M : Type u_2} [inst : AddZeroClass M] (s : Set α) (f g : α → M),\n  (Set.indicator s fun a => f a + g a) = fun a => Set.indicator s f a + Set.indicator s g a"], "lemmas": [{"prop": "(Set.indicator {x : α | p x} fun (a : α) ↦ ↑f a + ↑g a) = fun (a : α) ↦\n  Set.indicator {x : α | p x} (↑f) a + Set.indicator {x : α | p x} (↑g) a", "context": ["{α : Type u_1}", "{M : Type u_2}", "[AddZeroClass M]", "(p : (a : α) → Prop)", "(f : α →₀ M)", "(g : α →₀ M)"]}], "ids": ["FunLike.coe_injective", "Set.indicator_add", "x", "x"], "idString": "FunLike.coe_injective; Set.indicator_add; x; x; ", "context": []}
{"typeGroup": "(∀ {α : Type u_1} [inst : AddMonoid α] (s : Multiset α) (t : Multiset α)\n    (comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute),\n    Multiset.noncommSum (s + t) comm =\n      Multiset.noncommSum s\n          (Set.Pairwise.mono (Multiset.subset_of_le (Multiset.le_add_right s t=:s ≤ s + t)=:s ⊆ s + t)\n              comm=:Set.Pairwise {x : α | x ∈ s} AddCommute) +\n        Multiset.noncommSum t\n          (Set.Pairwise.mono (Multiset.subset_of_le (Multiset.le_add_left t s=:t ≤ s + t)=:t ⊆ s + t)\n              comm=:Set.Pairwise {x : α | x ∈ t} AddCommute) :\n  Prop)", "type": "∀ {α : Type u_1} [inst : AddMonoid α] (s : Multiset α) (t : Multiset α)\n  (comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute),\n  Multiset.noncommSum (s + t) comm =\n    Multiset.noncommSum s (Set.Pairwise.mono (Multiset.subset_of_le (Multiset.le_add_right s t)) comm) +\n      Multiset.noncommSum t (Set.Pairwise.mono (Multiset.subset_of_le (Multiset.le_add_left t s)) comm)", "thm": " : ∀ {α : Type u_1} [inst : AddMonoid α] (s : Multiset α) (t : Multiset α)\n  (comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute),\n  Multiset.noncommSum (s + t) comm =\n    Multiset.noncommSum s (Set.Pairwise.mono (Multiset.subset_of_le (Multiset.le_add_right s t)) comm) +\n      Multiset.noncommSum t (Set.Pairwise.mono (Multiset.subset_of_le (Multiset.le_add_left t s)) comm)", "terms": [{"value": "a ++ a_1", "isProp": false, "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"value": "Quot.mk Setoid.r a", "isProp": false, "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"value": "Quot.mk Setoid.r a_1", "isProp": false, "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"value": "List.sum a + List.sum a_1", "isProp": false, "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}], "namedLemmas": ["∀ {p : Prop}, p = True → p", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Type u_1} [inst : AddMonoid α] (l : List α) (comm : Set.Pairwise {x | x ∈ ↑l} AddCommute),\n  Multiset.noncommSum (↑l) comm = List.sum l", "∀ {M : Type u_1} [inst : AddMonoid M] {l₁ l₂ : List M}, List.sum (l₁ ++ l₂) = List.sum l₁ + List.sum l₂", "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Type u_1} [inst : AddMonoid α] (l : List α) (comm : Set.Pairwise {x | x ∈ ↑l} AddCommute),\n  Multiset.noncommSum (↑l) comm = List.sum l", "∀ {α : Type u_1} {r : α → α → Prop} {s t : Set α}, t ⊆ s → Set.Pairwise s r → Set.Pairwise t r", "∀ {α : Type u_1} {s t : Multiset α}, s ≤ t → s ⊆ t", "∀ {α : Type u_1} (s t : Multiset α), s ≤ s + t", "∀ {α : Type u_1} [inst : AddMonoid α] (l : List α) (comm : Set.Pairwise {x | x ∈ ↑l} AddCommute),\n  Multiset.noncommSum (↑l) comm = List.sum l", "∀ {α : Type u_1} {r : α → α → Prop} {s t : Set α}, t ⊆ s → Set.Pairwise s r → Set.Pairwise t r", "∀ {α : Type u_1} {s t : Multiset α}, s ≤ t → s ⊆ t", "∀ {α : Type u_1} (s t : Multiset α), s ≤ t + s", "∀ {α : Sort u_1} (a : α), (a = a) = True"], "lemmas": [{"prop": "↑(a ++ a_1) = ↑(a ++ a_1)", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "Quot.mk Setoid.r a + Quot.mk Setoid.r a_1 = ↑(a ++ a_1)", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "Set.Pairwise {x : α | x ∈ ↑(a ++ a_1)} AddCommute", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "Multiset.noncommSum ↑(a ++ a_1) ((id (Eq.refl ↑(a ++ a_1))) ▸ comm) = List.sum (a ++ a_1)", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "List.sum (a ++ a_1) = List.sum a + List.sum a_1", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "Multiset.noncommSum ↑(a ++ a_1) ((id (Eq.refl ↑(a ++ a_1))) ▸ comm) = List.sum a + List.sum a_1", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "Eq (Multiset.noncommSum ↑(a ++ a_1) ((id (Eq.refl ↑(a ++ a_1))) ▸ comm)) = Eq (List.sum a + List.sum a_1)", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "↑a = ↑a", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "Quot.mk Setoid.r a = ↑a", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "Quot.mk Setoid.r a ≤ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "Quot.mk Setoid.r a ⊆ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a} AddCommute", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "Set.Pairwise {x : α | x ∈ ↑a} AddCommute", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "Multiset.noncommSum ↑a\n    ((id (Eq.refl ↑a)) ▸\n      (Set.Pairwise.mono (Multiset.subset_of_le (Multiset.le_add_right (Quot.mk Setoid.r a) (Quot.mk Setoid.r a_1)))\n        comm)) =\n  List.sum a", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "HAdd.hAdd\n    (Multiset.noncommSum ↑a\n      ((id (Eq.refl ↑a)) ▸\n        (Set.Pairwise.mono (Multiset.subset_of_le (Multiset.le_add_right (Quot.mk Setoid.r a) (Quot.mk Setoid.r a_1)))\n          comm))) =\n  HAdd.hAdd (List.sum a)", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "↑a_1 = ↑a_1", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "Quot.mk Setoid.r a_1 = ↑a_1", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "Quot.mk Setoid.r a_1 ≤ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "Quot.mk Setoid.r a_1 ⊆ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a_1} AddCommute", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "Set.Pairwise {x : α | x ∈ ↑a_1} AddCommute", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "Multiset.noncommSum ↑a_1\n    ((id (Eq.refl ↑a_1)) ▸\n      (Set.Pairwise.mono (Multiset.subset_of_le (Multiset.le_add_left (Quot.mk Setoid.r a_1) (Quot.mk Setoid.r a)))\n        comm)) =\n  List.sum a_1", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "Multiset.noncommSum ↑a\n      ((id (Eq.refl ↑a)) ▸\n        (Set.Pairwise.mono (Multiset.subset_of_le (Multiset.le_add_right (Quot.mk Setoid.r a) (Quot.mk Setoid.r a_1)))\n          comm)) +\n    Multiset.noncommSum ↑a_1\n      ((id (Eq.refl ↑a_1)) ▸\n        (Set.Pairwise.mono (Multiset.subset_of_le (Multiset.le_add_left (Quot.mk Setoid.r a_1) (Quot.mk Setoid.r a)))\n          comm)) =\n  List.sum a + List.sum a_1", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "(Multiset.noncommSum ↑(a ++ a_1) ((id (Eq.refl ↑(a ++ a_1))) ▸ comm) =\n    Multiset.noncommSum ↑a\n        ((id (Eq.refl ↑a)) ▸\n          (Set.Pairwise.mono (Multiset.subset_of_le (Multiset.le_add_right (Quot.mk Setoid.r a) (Quot.mk Setoid.r a_1)))\n            comm)) +\n      Multiset.noncommSum ↑a_1\n        ((id (Eq.refl ↑a_1)) ▸\n          (Set.Pairwise.mono (Multiset.subset_of_le (Multiset.le_add_left (Quot.mk Setoid.r a_1) (Quot.mk Setoid.r a)))\n            comm))) =\n  (List.sum a + List.sum a_1 = List.sum a + List.sum a_1)", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "(List.sum a + List.sum a_1 = List.sum a + List.sum a_1) = True", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "(Multiset.noncommSum ↑(a ++ a_1) ((id (Eq.refl ↑(a ++ a_1))) ▸ comm) =\n    Multiset.noncommSum ↑a\n        ((id (Eq.refl ↑a)) ▸\n          (Set.Pairwise.mono (Multiset.subset_of_le (Multiset.le_add_right (Quot.mk Setoid.r a) (Quot.mk Setoid.r a_1)))\n            comm)) +\n      Multiset.noncommSum ↑a_1\n        ((id (Eq.refl ↑a_1)) ▸\n          (Set.Pairwise.mono (Multiset.subset_of_le (Multiset.le_add_left (Quot.mk Setoid.r a_1) (Quot.mk Setoid.r a)))\n            comm))) =\n  True", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)", "(a_1 : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute)"]}, {"prop": "∀ (a_1 : List α) (comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + Quot.mk Setoid.r a_1} AddCommute),\n  Multiset.noncommSum ↑(a ++ a_1) ((id (Eq.refl ↑(a ++ a_1))) ▸ comm) =\n    Multiset.noncommSum ↑a\n        ((id (Eq.refl ↑a)) ▸\n          (Set.Pairwise.mono (Multiset.subset_of_le (Multiset.le_add_right (Quot.mk Setoid.r a) (Quot.mk Setoid.r a_1)))\n            comm)) +\n      Multiset.noncommSum ↑a_1\n        ((id (Eq.refl ↑a_1)) ▸\n          (Set.Pairwise.mono (Multiset.subset_of_le (Multiset.le_add_left (Quot.mk Setoid.r a_1) (Quot.mk Setoid.r a)))\n            comm))", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)", "(a : List α)", "(comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute)"]}, {"prop": "∀ (a : List α) (comm : Set.Pairwise {x : α | x ∈ Quot.mk Setoid.r a + t} AddCommute),\n  Multiset.noncommSum (Quot.mk Setoid.r a + t) comm =\n    Multiset.noncommSum (Quot.mk Setoid.r a)\n        (Set.Pairwise.mono (Multiset.subset_of_le (Multiset.le_add_right (Quot.mk Setoid.r a) t)) comm) +\n      Multiset.noncommSum t\n        (Set.Pairwise.mono (Multiset.subset_of_le (Multiset.le_add_left t (Quot.mk Setoid.r a))) comm)", "context": ["{α : Type u_1}", "[AddMonoid α]", "(s : Multiset α)", "(t : Multiset α)", "(comm : Set.Pairwise {x : α | x ∈ s + t} AddCommute)"]}], "ids": ["Quot.ind", "Quot.ind", "of_eq_true", "Eq.trans", "congr", "congrArg", "Eq", "Eq.trans", "Multiset.noncommSum_coe", "id", "Eq.refl", "List.sum_append", "congr", "congrArg", "HAdd.hAdd", "Multiset.noncommSum_coe", "id", "Eq.refl", "Set.Pairwise.mono", "Multiset.subset_of_le", "Multiset.le_add_right", "Quot.mk", "Setoid.r", "Quot.mk", "Setoid.r", "Multiset.noncommSum_coe", "id", "Eq.refl", "Set.Pairwise.mono", "Multiset.subset_of_le", "Multiset.le_add_left", "Quot.mk", "Setoid.r", "Quot.mk", "Setoid.r", "eq_self", "List.sum", "List.sum"], "idString": "Quot.ind; Quot.ind; of_eq_true; Eq.trans; congr; congrArg; Eq; Eq.trans; Multiset.noncommSum_coe; id; Eq.refl; List.sum_append; congr; congrArg; HAdd.hAdd; Multiset.noncommSum_coe; id; Eq.refl; Set.Pairwise.mono; Multiset.subset_of_le; Multiset.le_add_right; Quot.mk; Setoid.r; Quot.mk; Setoid.r; Multiset.noncommSum_coe; id; Eq.refl; Set.Pairwise.mono; Multiset.subset_of_le; Multiset.le_add_left; Quot.mk; Setoid.r; Quot.mk; Setoid.r; eq_self; List.sum; List.sum; ", "context": []}
{"typeGroup": "(∀ {R : Type u_2} [inst : Ring R] {E : Type u_1} [inst_1 : AddCommGroup E] [inst_2 : Module R E] (p : Submodule R E)\n    (x : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x }),\n    (fun (q : { q : Submodule R E // IsCompl p q }) ↦\n          { val := ((Submodule.linearProjOfIsCompl p ↑q (Subtype.property q=:IsCompl p ↑q))),\n            property :=\n              (((Submodule.linearProjOfIsCompl_apply_left\n                  (Subtype.property\n                      q=:IsCompl p\n                      ↑q)=:∀ (x : { x : E // x ∈ p }),\n                  ↑(Submodule.linearProjOfIsCompl p ↑q (Subtype.property q=:IsCompl p ↑q)) ↑x = x))) })\n        ((fun (f : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x }) ↦\n            { val := ((LinearMap.ker ↑f)),\n              property :=\n                (((LinearMap.isCompl_of_proj\n                    (Subtype.property f=:∀ (x : { x : E // x ∈ p }), ↑↑f ↑x = x)=:IsCompl p (LinearMap.ker ↑f)))) })\n          x) =\n      x :\n  Prop)", "type": "∀ {R : Type u_2} [inst : Ring R] {E : Type u_1} [inst_1 : AddCommGroup E] [inst_2 : Module R E] (p : Submodule R E)\n  (x : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x }),\n  (fun (q : { q : Submodule R E // IsCompl p q }) ↦\n        { val := ((Submodule.linearProjOfIsCompl p ↑q (Subtype.property q))),\n          property := (((Submodule.linearProjOfIsCompl_apply_left (Subtype.property q)))) })\n      ((fun (f : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x }) ↦\n          { val := ((LinearMap.ker ↑f)), property := (((LinearMap.isCompl_of_proj (Subtype.property f)))) })\n        x) =\n    x", "thm": " : ∀ {R : Type u_2} [inst : Ring R] {E : Type u_1} [inst_1 : AddCommGroup E] [inst_2 : Module R E] (p : Submodule R E)\n  (x : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x }),\n  (fun (q : { q : Submodule R E // IsCompl p q }) ↦\n        { val := ((Submodule.linearProjOfIsCompl p ↑q (Subtype.property q))),\n          property := (((Submodule.linearProjOfIsCompl_apply_left (Subtype.property q)))) })\n      ((fun (f : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x }) ↦\n          { val := ((LinearMap.ker ↑f)), property := (((LinearMap.isCompl_of_proj (Subtype.property f)))) })\n        x) =\n    x", "terms": [{"value": "↑q", "isProp": false, "context": ["{R : Type u_2}", "[Ring R]", "{E : Type u_1}", "[AddCommGroup E]", "[Module R E]", "(p : Submodule R E)", "(x : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x })", "(x : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x })", "(q : { q : Submodule R E // IsCompl p q })"]}, {"value": "↑f", "isProp": false, "context": ["{R : Type u_2}", "[Ring R]", "{E : Type u_1}", "[AddCommGroup E]", "[Module R E]", "(p : Submodule R E)", "(x : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x })", "(x : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x })", "(f : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x })"]}, {"value": "(fun (f : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x }) ↦\n    { val := ((LinearMap.ker ↑f)), property := (((LinearMap.isCompl_of_proj (Subtype.property f)))) })\n  x", "isProp": false, "context": ["{R : Type u_2}", "[Ring R]", "{E : Type u_1}", "[AddCommGroup E]", "[Module R E]", "(p : Submodule R E)", "(x : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x })", "(x : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x })"]}], "namedLemmas": ["∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self", "∀ {R : Type u_2} [inst : Ring R] {E : Type u_1} [inst_1 : AddCommGroup E] [inst_2 : Module R E] {p q : Submodule R E}\n  (h : IsCompl p q) (x : { x // x ∈ p }), ↑(Submodule.linearProjOfIsCompl p q h) ↑x = x", "∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self", "∀ {R : Type u_1} [inst : Ring R] {E : Type u_2} [inst_1 : AddCommGroup E] [inst_2 : Module R E] {p : Submodule R E}\n  {f : E →ₗ[R] { x // x ∈ p }}, (∀ (x : { x // x ∈ p }), ↑f ↑x = x) → IsCompl p (LinearMap.ker f)", "∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self", "∀ {α : Type u} {p : α → Prop} {a1 a2 : { x // p x }}, ↑a1 = ↑a2 → a1 = a2", "∀ {R : Type u_1} [inst : Ring R] {E : Type u_2} [inst_1 : AddCommGroup E] [inst_2 : Module R E] {p : Submodule R E}\n  (f : E →ₗ[R] { x // x ∈ p }) (hf : ∀ (x : { x // x ∈ p }), ↑f ↑x = x),\n  Submodule.linearProjOfIsCompl p (LinearMap.ker f) (_ : IsCompl p (LinearMap.ker f)) = f"], "lemmas": [{"prop": "IsCompl p ↑q", "context": ["{R : Type u_2}", "[Ring R]", "{E : Type u_1}", "[AddCommGroup E]", "[Module R E]", "(p : Submodule R E)", "(x : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x })", "(x : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x })", "(q : { q : Submodule R E // IsCompl p q })"]}, {"prop": "IsCompl p ↑q", "context": ["{R : Type u_2}", "[Ring R]", "{E : Type u_1}", "[AddCommGroup E]", "[Module R E]", "(p : Submodule R E)", "(x : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x })", "(x : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x })", "(q : { q : Submodule R E // IsCompl p q })"]}, {"prop": "∀ (x : { x : E // x ∈ p }), ↑(Submodule.linearProjOfIsCompl p ↑q (Subtype.property q)) ↑x = x", "context": ["{R : Type u_2}", "[Ring R]", "{E : Type u_1}", "[AddCommGroup E]", "[Module R E]", "(p : Submodule R E)", "(x : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x })", "(x : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x })", "(q : { q : Submodule R E // IsCompl p q })"]}, {"prop": "∀ (x : { x : E // x ∈ p }), ↑↑f ↑x = x", "context": ["{R : Type u_2}", "[Ring R]", "{E : Type u_1}", "[AddCommGroup E]", "[Module R E]", "(p : Submodule R E)", "(x : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x })", "(x : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x })", "(f : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x })"]}, {"prop": "IsCompl p (LinearMap.ker ↑f)", "context": ["{R : Type u_2}", "[Ring R]", "{E : Type u_1}", "[AddCommGroup E]", "[Module R E]", "(p : Submodule R E)", "(x : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x })", "(x : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x })", "(f : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x })"]}, {"prop": "Submodule.linearProjOfIsCompl p (LinearMap.ker f) (LinearMap.isCompl_of_proj hf) = f", "context": ["{R : Type u_2}", "[Ring R]", "{E : Type u_1}", "[AddCommGroup E]", "[Module R E]", "(p : Submodule R E)", "(x : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x })", "(f : E →ₗ[R] { x : E // x ∈ p })", "(hf : ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x)"]}, {"prop": "∀ (f : E →ₗ[R] { x : E // x ∈ p }) (hf : ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x),\n  (fun (q : { q : Submodule R E // IsCompl p q }) ↦\n        { val := ((Submodule.linearProjOfIsCompl p ↑q (Subtype.property q))),\n          property := (((Submodule.linearProjOfIsCompl_apply_left (Subtype.property q)))) })\n      ((fun (f : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x }) ↦\n          { val := ((LinearMap.ker ↑f)), property := (((LinearMap.isCompl_of_proj (Subtype.property f)))) })\n        { val := ((f)), property := ((hf)) }) =\n    { val := ((f)), property := ((hf)) }", "context": ["{R : Type u_2}", "[Ring R]", "{E : Type u_1}", "[AddCommGroup E]", "[Module R E]", "(p : Submodule R E)", "(x : { f : E →ₗ[R] { x : E // x ∈ p } // ∀ (x : { x : E // x ∈ p }), ↑f ↑x = x })"]}], "ids": ["Submodule.isComplEquivProj.match_2", "val", "Submodule.linearProjOfIsCompl", "Subtype.property", "property", "Submodule.linearProjOfIsCompl_apply_left", "Subtype.property", "val", "LinearMap.ker", "property", "LinearMap.isCompl_of_proj", "Subtype.property", "Subtype.eq", "LinearMap.linearProjOfIsCompl_of_proj"], "idString": "Submodule.isComplEquivProj.match_2; val; Submodule.linearProjOfIsCompl; Subtype.property; property; Submodule.linearProjOfIsCompl_apply_left; Subtype.property; val; LinearMap.ker; property; LinearMap.isCompl_of_proj; Subtype.property; Subtype.eq; LinearMap.linearProjOfIsCompl_of_proj; ", "context": []}
{"typeGroup": "(∀ {ι : Type u_1} {β : (a : ι) → Type u_2} [inst : Fintype ι] [inst_1 : (i : ι) → Norm (β i)]\n    [inst_2 : (i : ι) → Zero (β i)] (f : PiLp 0 β),\n    ‖f‖ = ↑(Finset.card (Set.Finite.toFinset (Set.toFinite {i : ι | f i ≠ 0}=:Set.Finite {i : ι | f i ≠ 0}))) :\n  Prop)", "type": "∀ {ι : Type u_1} {β : (a : ι) → Type u_2} [inst : Fintype ι] [inst_1 : (i : ι) → Norm (β i)]\n  [inst_2 : (i : ι) → Zero (β i)] (f : PiLp 0 β),\n  (if (0 = 0) then ↑(Finset.card (Set.Finite.toFinset (PiLp.hasNorm.proof_1 0 β f)))\n    else\n      if (0 = ⊤) then ⨆ (i : ι), ‖f i‖\n      else (Finset.sum Finset.univ fun (i : ι) ↦ ‖f i‖ ^ ENNReal.toReal 0) ^ (1 / ENNReal.toReal 0)) =\n    ↑(Finset.card (Set.Finite.toFinset (PiLp.hasNorm.proof_1 0 β f)))", "thm": " : ∀ {ι : Type u_1} {β : (a : ι) → Type u_2} [inst : Fintype ι] [inst_1 : (i : ι) → Norm (β i)]\n  [inst_2 : (i : ι) → Zero (β i)] (f : PiLp 0 β),\n  (if (0 = 0) then ↑(Finset.card (Set.Finite.toFinset (PiLp.hasNorm.proof_1 0 β f)))\n    else\n      if (0 = ⊤) then ⨆ (i : ι), ‖f i‖\n      else (Finset.sum Finset.univ fun (i : ι) ↦ ‖f i‖ ^ ENNReal.toReal 0) ^ (1 / ENNReal.toReal 0)) =\n    ↑(Finset.card (Set.Finite.toFinset (PiLp.hasNorm.proof_1 0 β f)))", "terms": [], "namedLemmas": ["∀ {c : Prop} {h : Decidable c}, c → ∀ {α : Sort u} {t e : α}, (if c then t else e) = t", "∀ {α : Sort u} {a : α}, a = a"], "lemmas": [{"prop": "0 = 0", "context": ["{ι : Type u_1}", "{β : (a : ι) → Type u_2}", "[Fintype ι]", "[(i : ι) → Norm (β i)]", "[(i : ι) → Zero (β i)]", "(f : PiLp 0 β)"]}], "ids": ["if_pos", "rfl"], "idString": "if_pos; rfl; ", "context": []}
{"typeGroup": "(∀ {α : Type u_1} {β : Type u_2} [inst : NonUnitalNonAssocSemiring α] [inst_1 : NonUnitalNonAssocSemiring β]\n    (x : α →ₙ+* β),\n    (fun (f : αᵐᵒᵖ →ₙ+* βᵐᵒᵖ) ↦\n          let src : (fun (x : αᵐᵒᵖ →+ βᵐᵒᵖ) ↦ α →+ β) (NonUnitalRingHom.toAddMonoidHom f) :=\n            ↑AddMonoidHom.mulUnop (NonUnitalRingHom.toAddMonoidHom f);\n          let src_1 : (fun (x : αᵐᵒᵖ →ₙ* βᵐᵒᵖ) ↦ α →ₙ* β) (NonUnitalRingHom.toMulHom f) :=\n            ↑MulHom.unop (NonUnitalRingHom.toMulHom f);\n          {\n            toMulHom :=\n              (({ toFun := ((ZeroHom.toFun ↑src)),\n                map_mul' :=\n                  (((MulHom.map_mul'\n                      src_1=:∀ (x : α) (y : α),\n                      MulHom.toFun src_1 (x * y) = MulHom.toFun src_1 x * MulHom.toFun src_1 y))) })),\n            map_zero' := (((ZeroHom.map_zero' ↑src=:ZeroHom.toFun (↑src) 0 = 0))),\n            map_add' :=\n              (((AddMonoidHom.map_add'\n                  src=:∀ (x : α) (y : α),\n                  ZeroHom.toFun (↑src) (x + y) = ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y))) })\n        ((fun (f : α →ₙ+* β) ↦\n            let src : (fun (x : α →+ β) ↦ αᵐᵒᵖ →+ βᵐᵒᵖ) (NonUnitalRingHom.toAddMonoidHom f) :=\n              ↑AddMonoidHom.mulOp (NonUnitalRingHom.toAddMonoidHom f);\n            let src_1 : (fun (x : α →ₙ* β) ↦ αᵐᵒᵖ →ₙ* βᵐᵒᵖ) (NonUnitalRingHom.toMulHom f) :=\n              ↑MulHom.op (NonUnitalRingHom.toMulHom f);\n            {\n              toMulHom :=\n                (({ toFun := ((ZeroHom.toFun ↑src)),\n                  map_mul' :=\n                    (((MulHom.map_mul'\n                        src_1=:∀ (x : αᵐᵒᵖ) (y : αᵐᵒᵖ),\n                        MulHom.toFun src_1 (x * y) = MulHom.toFun src_1 x * MulHom.toFun src_1 y))) })),\n              map_zero' := (((ZeroHom.map_zero' ↑src=:ZeroHom.toFun (↑src) 0 = 0))),\n              map_add' :=\n                (((AddMonoidHom.map_add'\n                    src=:∀ (x : αᵐᵒᵖ) (y : αᵐᵒᵖ),\n                    ZeroHom.toFun (↑src) (x + y) = ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y))) })\n          x) =\n      (fun (f : αᵐᵒᵖ →ₙ+* βᵐᵒᵖ) ↦\n          let src : (fun (x : αᵐᵒᵖ →+ βᵐᵒᵖ) ↦ α →+ β) (NonUnitalRingHom.toAddMonoidHom f) :=\n            ↑AddMonoidHom.mulUnop (NonUnitalRingHom.toAddMonoidHom f);\n          let src_1 : (fun (x : αᵐᵒᵖ →ₙ* βᵐᵒᵖ) ↦ α →ₙ* β) (NonUnitalRingHom.toMulHom f) :=\n            ↑MulHom.unop (NonUnitalRingHom.toMulHom f);\n          {\n            toMulHom :=\n              (({ toFun := ((ZeroHom.toFun ↑src)),\n                map_mul' :=\n                  (((MulHom.map_mul'\n                      src_1=:∀ (x : α) (y : α),\n                      MulHom.toFun src_1 (x * y) = MulHom.toFun src_1 x * MulHom.toFun src_1 y))) })),\n            map_zero' := (((ZeroHom.map_zero' ↑src=:ZeroHom.toFun (↑src) 0 = 0))),\n            map_add' :=\n              (((AddMonoidHom.map_add'\n                  src=:∀ (x : α) (y : α),\n                  ZeroHom.toFun (↑src) (x + y) = ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y))) })\n        ((fun (f : α →ₙ+* β) ↦\n            let src : (fun (x : α →+ β) ↦ αᵐᵒᵖ →+ βᵐᵒᵖ) (NonUnitalRingHom.toAddMonoidHom f) :=\n              ↑AddMonoidHom.mulOp (NonUnitalRingHom.toAddMonoidHom f);\n            let src_1 : (fun (x : α →ₙ* β) ↦ αᵐᵒᵖ →ₙ* βᵐᵒᵖ) (NonUnitalRingHom.toMulHom f) :=\n              ↑MulHom.op (NonUnitalRingHom.toMulHom f);\n            {\n              toMulHom :=\n                (({ toFun := ((ZeroHom.toFun ↑src)),\n                  map_mul' :=\n                    (((MulHom.map_mul'\n                        src_1=:∀ (x : αᵐᵒᵖ) (y : αᵐᵒᵖ),\n                        MulHom.toFun src_1 (x * y) = MulHom.toFun src_1 x * MulHom.toFun src_1 y))) })),\n              map_zero' := (((ZeroHom.map_zero' ↑src=:ZeroHom.toFun (↑src) 0 = 0))),\n              map_add' :=\n                (((AddMonoidHom.map_add'\n                    src=:∀ (x : αᵐᵒᵖ) (y : αᵐᵒᵖ),\n                    ZeroHom.toFun (↑src) (x + y) = ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y))) })\n          x) :\n  Prop)", "type": "∀ {α : Type u_1} {β : Type u_2} [inst : NonUnitalNonAssocSemiring α] [inst_1 : NonUnitalNonAssocSemiring β]\n  (x : α →ₙ+* β),\n  (fun (f : αᵐᵒᵖ →ₙ+* βᵐᵒᵖ) ↦\n        let src : (fun (x : αᵐᵒᵖ →+ βᵐᵒᵖ) ↦ α →+ β) (NonUnitalRingHom.toAddMonoidHom f) :=\n          ↑AddMonoidHom.mulUnop (NonUnitalRingHom.toAddMonoidHom f);\n        let src_1 : (fun (x : αᵐᵒᵖ →ₙ* βᵐᵒᵖ) ↦ α →ₙ* β) (NonUnitalRingHom.toMulHom f) :=\n          ↑MulHom.unop (NonUnitalRingHom.toMulHom f);\n        { toMulHom := (({ toFun := ((ZeroHom.toFun ↑src)), map_mul' := (((MulHom.map_mul' src_1))) })),\n          map_zero' := (((ZeroHom.map_zero' ↑src))), map_add' := (((AddMonoidHom.map_add' src))) })\n      ((fun (f : α →ₙ+* β) ↦\n          let src : (fun (x : α →+ β) ↦ αᵐᵒᵖ →+ βᵐᵒᵖ) (NonUnitalRingHom.toAddMonoidHom f) :=\n            ↑AddMonoidHom.mulOp (NonUnitalRingHom.toAddMonoidHom f);\n          let src_1 : (fun (x : α →ₙ* β) ↦ αᵐᵒᵖ →ₙ* βᵐᵒᵖ) (NonUnitalRingHom.toMulHom f) :=\n            ↑MulHom.op (NonUnitalRingHom.toMulHom f);\n          { toMulHom := (({ toFun := ((ZeroHom.toFun ↑src)), map_mul' := (((MulHom.map_mul' src_1))) })),\n            map_zero' := (((ZeroHom.map_zero' ↑src))), map_add' := (((AddMonoidHom.map_add' src))) })\n        x) =\n    (fun (f : αᵐᵒᵖ →ₙ+* βᵐᵒᵖ) ↦\n        let src : (fun (x : αᵐᵒᵖ →+ βᵐᵒᵖ) ↦ α →+ β) (NonUnitalRingHom.toAddMonoidHom f) :=\n          ↑AddMonoidHom.mulUnop (NonUnitalRingHom.toAddMonoidHom f);\n        let src_1 : (fun (x : αᵐᵒᵖ →ₙ* βᵐᵒᵖ) ↦ α →ₙ* β) (NonUnitalRingHom.toMulHom f) :=\n          ↑MulHom.unop (NonUnitalRingHom.toMulHom f);\n        { toMulHom := (({ toFun := ((ZeroHom.toFun ↑src)), map_mul' := (((MulHom.map_mul' src_1))) })),\n          map_zero' := (((ZeroHom.map_zero' ↑src))), map_add' := (((AddMonoidHom.map_add' src))) })\n      ((fun (f : α →ₙ+* β) ↦\n          let src : (fun (x : α →+ β) ↦ αᵐᵒᵖ →+ βᵐᵒᵖ) (NonUnitalRingHom.toAddMonoidHom f) :=\n            ↑AddMonoidHom.mulOp (NonUnitalRingHom.toAddMonoidHom f);\n          let src_1 : (fun (x : α →ₙ* β) ↦ αᵐᵒᵖ →ₙ* βᵐᵒᵖ) (NonUnitalRingHom.toMulHom f) :=\n            ↑MulHom.op (NonUnitalRingHom.toMulHom f);\n          { toMulHom := (({ toFun := ((ZeroHom.toFun ↑src)), map_mul' := (((MulHom.map_mul' src_1))) })),\n            map_zero' := (((ZeroHom.map_zero' ↑src))), map_add' := (((AddMonoidHom.map_add' src))) })\n        x)", "thm": " : ∀ {α : Type u_1} {β : Type u_2} [inst : NonUnitalNonAssocSemiring α] [inst_1 : NonUnitalNonAssocSemiring β]\n  (x : α →ₙ+* β),\n  (fun (f : αᵐᵒᵖ →ₙ+* βᵐᵒᵖ) ↦\n        let src : (fun (x : αᵐᵒᵖ →+ βᵐᵒᵖ) ↦ α →+ β) (NonUnitalRingHom.toAddMonoidHom f) :=\n          ↑AddMonoidHom.mulUnop (NonUnitalRingHom.toAddMonoidHom f);\n        let src_1 : (fun (x : αᵐᵒᵖ →ₙ* βᵐᵒᵖ) ↦ α →ₙ* β) (NonUnitalRingHom.toMulHom f) :=\n          ↑MulHom.unop (NonUnitalRingHom.toMulHom f);\n        { toMulHom := (({ toFun := ((ZeroHom.toFun ↑src)), map_mul' := (((MulHom.map_mul' src_1))) })),\n          map_zero' := (((ZeroHom.map_zero' ↑src))), map_add' := (((AddMonoidHom.map_add' src))) })\n      ((fun (f : α →ₙ+* β) ↦\n          let src : (fun (x : α →+ β) ↦ αᵐᵒᵖ →+ βᵐᵒᵖ) (NonUnitalRingHom.toAddMonoidHom f) :=\n            ↑AddMonoidHom.mulOp (NonUnitalRingHom.toAddMonoidHom f);\n          let src_1 : (fun (x : α →ₙ* β) ↦ αᵐᵒᵖ →ₙ* βᵐᵒᵖ) (NonUnitalRingHom.toMulHom f) :=\n            ↑MulHom.op (NonUnitalRingHom.toMulHom f);\n          { toMulHom := (({ toFun := ((ZeroHom.toFun ↑src)), map_mul' := (((MulHom.map_mul' src_1))) })),\n            map_zero' := (((ZeroHom.map_zero' ↑src))), map_add' := (((AddMonoidHom.map_add' src))) })\n        x) =\n    (fun (f : αᵐᵒᵖ →ₙ+* βᵐᵒᵖ) ↦\n        let src : (fun (x : αᵐᵒᵖ →+ βᵐᵒᵖ) ↦ α →+ β) (NonUnitalRingHom.toAddMonoidHom f) :=\n          ↑AddMonoidHom.mulUnop (NonUnitalRingHom.toAddMonoidHom f);\n        let src_1 : (fun (x : αᵐᵒᵖ →ₙ* βᵐᵒᵖ) ↦ α →ₙ* β) (NonUnitalRingHom.toMulHom f) :=\n          ↑MulHom.unop (NonUnitalRingHom.toMulHom f);\n        { toMulHom := (({ toFun := ((ZeroHom.toFun ↑src)), map_mul' := (((MulHom.map_mul' src_1))) })),\n          map_zero' := (((ZeroHom.map_zero' ↑src))), map_add' := (((AddMonoidHom.map_add' src))) })\n      ((fun (f : α →ₙ+* β) ↦\n          let src : (fun (x : α →+ β) ↦ αᵐᵒᵖ →+ βᵐᵒᵖ) (NonUnitalRingHom.toAddMonoidHom f) :=\n            ↑AddMonoidHom.mulOp (NonUnitalRingHom.toAddMonoidHom f);\n          let src_1 : (fun (x : α →ₙ* β) ↦ αᵐᵒᵖ →ₙ* βᵐᵒᵖ) (NonUnitalRingHom.toMulHom f) :=\n            ↑MulHom.op (NonUnitalRingHom.toMulHom f);\n          { toMulHom := (({ toFun := ((ZeroHom.toFun ↑src)), map_mul' := (((MulHom.map_mul' src_1))) })),\n            map_zero' := (((ZeroHom.map_zero' ↑src))), map_add' := (((AddMonoidHom.map_add' src))) })\n        x)", "terms": [], "namedLemmas": ["∀ {α : Sort u} {a : α}, a = a"], "lemmas": [], "ids": ["rfl"], "idString": "rfl; ", "context": []}
{"typeGroup": "(∀ {ι : Type u_4} {R' : Type u_1} {M'' : Type u_2} {N'' : Type u_3} [inst : CommSemiring R']\n    [inst_1 : AddCommMonoid M''] [inst_2 : AddCommMonoid N''] [inst_3 : Module R' M''] [inst_4 : Module R' N'']\n    [inst_5 : IsEmpty ι] (f : AlternatingMap R' M'' N'' ι),\n    AddHom.toFun\n        (LinearMap.toAddHom\n          {\n            toAddHom :=\n              (({ toFun := ((AlternatingMap.constOfIsEmpty R' M'' ι)),\n                map_add' :=\n                  (((fun (x : N'') ↦\n                    (_ :\n                      ∀ (x_1 : N''),\n                        AlternatingMap.constOfIsEmpty R' M'' ι (x + x_1) =\n                          AlternatingMap.constOfIsEmpty R' M'' ι\n                            (x +\n                              x_1))=:∀ (x : N'') (x_1 : N''),\n                      AlternatingMap.constOfIsEmpty R' M'' ι (x + x_1) =\n                        AlternatingMap.constOfIsEmpty R' M'' ι (x + x_1)))) })),\n            map_smul' :=\n              (((fun (x : R') ↦\n                (_ :\n                  ∀ (x_1 : N''),\n                    AddHom.toFun\n                        { toFun := ((AlternatingMap.constOfIsEmpty R' M'' ι)),\n                          map_add' :=\n                            (((fun (x : N'') ↦\n                              (_ :\n                                ∀ (x_2 : N''),\n                                  AlternatingMap.constOfIsEmpty R' M'' ι (x + x_2) =\n                                    AlternatingMap.constOfIsEmpty R' M'' ι\n                                      (x +\n                                        x_2))=:∀ (x : N'') (x_2 : N''),\n                                AlternatingMap.constOfIsEmpty R' M'' ι (x + x_2) =\n                                  AlternatingMap.constOfIsEmpty R' M'' ι (x + x_2)))) }\n                        (x • x_1) =\n                      AddHom.toFun\n                        { toFun := ((AlternatingMap.constOfIsEmpty R' M'' ι)),\n                          map_add' :=\n                            (((fun (x : N'') ↦\n                              (_ :\n                                ∀ (x_2 : N''),\n                                  AlternatingMap.constOfIsEmpty R' M'' ι (x + x_2) =\n                                    AlternatingMap.constOfIsEmpty R' M'' ι\n                                      (x +\n                                        x_2))=:∀ (x : N'') (x_2 : N''),\n                                AlternatingMap.constOfIsEmpty R' M'' ι (x + x_2) =\n                                  AlternatingMap.constOfIsEmpty R' M'' ι (x + x_2)))) }\n                        (x •\n                          x_1))=:∀ (x : R') (x_1 : N''),\n                  AddHom.toFun\n                      { toFun := ((AlternatingMap.constOfIsEmpty R' M'' ι)),\n                        map_add' :=\n                          (((fun (x : N'') ↦\n                            (_ :\n                              ∀ (x_2 : N''),\n                                AlternatingMap.constOfIsEmpty R' M'' ι (x + x_2) =\n                                  AlternatingMap.constOfIsEmpty R' M'' ι\n                                    (x +\n                                      x_2))=:∀ (x : N'') (x_2 : N''),\n                              AlternatingMap.constOfIsEmpty R' M'' ι (x + x_2) =\n                                AlternatingMap.constOfIsEmpty R' M'' ι (x + x_2)))) }\n                      (x • x_1) =\n                    AddHom.toFun\n                      { toFun := ((AlternatingMap.constOfIsEmpty R' M'' ι)),\n                        map_add' :=\n                          (((fun (x : N'') ↦\n                            (_ :\n                              ∀ (x_2 : N''),\n                                AlternatingMap.constOfIsEmpty R' M'' ι (x + x_2) =\n                                  AlternatingMap.constOfIsEmpty R' M'' ι\n                                    (x +\n                                      x_2))=:∀ (x : N'') (x_2 : N''),\n                              AlternatingMap.constOfIsEmpty R' M'' ι (x + x_2) =\n                                AlternatingMap.constOfIsEmpty R' M'' ι (x + x_2)))) }\n                      (x • x_1)))) })\n        ((fun (f : AlternatingMap R' M'' N'' ι) ↦ ↑f 0) f) =\n      f :\n  Prop)", "type": "∀ {ι : Type u_4} {R' : Type u_1} {M'' : Type u_2} {N'' : Type u_3} [inst : CommSemiring R'] [inst_1 : AddCommMonoid M'']\n  [inst_2 : AddCommMonoid N''] [inst_3 : Module R' M''] [inst_4 : Module R' N''] [inst_5 : IsEmpty ι]\n  (f : AlternatingMap R' M'' N'' ι),\n  AddHom.toFun\n      (LinearMap.toAddHom\n        {\n          toAddHom :=\n            (({ toFun := ((AlternatingMap.constOfIsEmpty R' M'' ι)),\n              map_add' := (((fun (x : N'') (x_1 : N'') ↦ rfl))) })),\n          map_smul' := (((fun (x : R') (x_1 : N'') ↦ rfl))) })\n      ((fun (f : AlternatingMap R' M'' N'' ι) ↦ ↑f 0) f) =\n    f", "thm": " : ∀ {ι : Type u_4} {R' : Type u_1} {M'' : Type u_2} {N'' : Type u_3} [inst : CommSemiring R'] [inst_1 : AddCommMonoid M'']\n  [inst_2 : AddCommMonoid N''] [inst_3 : Module R' M''] [inst_4 : Module R' N''] [inst_5 : IsEmpty ι]\n  (f : AlternatingMap R' M'' N'' ι),\n  AddHom.toFun\n      (LinearMap.toAddHom\n        {\n          toAddHom :=\n            (({ toFun := ((AlternatingMap.constOfIsEmpty R' M'' ι)),\n              map_add' := (((fun (x : N'') (x_1 : N'') ↦ rfl))) })),\n          map_smul' := (((fun (x : R') (x_1 : N'') ↦ rfl))) })\n      ((fun (f : AlternatingMap R' M'' N'' ι) ↦ ↑f 0) f) =\n    f", "terms": [], "namedLemmas": ["∀ {R : Type u_1} [inst : Semiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_3}\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {ι : Type u_4} {f f' : AlternatingMap R M N ι},\n  (∀ (x : ι → M), ↑f x = ↑f' x) → f = f'", "∀ {R : Type u_1} [inst : Semiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_3}\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {ι : Type u_4} (f : AlternatingMap R M N ι) {x y : ι → M},\n  x = y → ↑f x = ↑f y", "∀ {α : Sort u} [h : Subsingleton α] (a b : α), a = b"], "lemmas": [{"prop": "0 = x", "context": ["{ι : Type u_4}", "{R' : Type u_1}", "{M'' : Type u_2}", "{N'' : Type u_3}", "[CommSemiring R']", "[AddCommMonoid M'']", "[AddCommMonoid N'']", "[Module R' M'']", "[Module R' N'']", "[IsEmpty ι]", "(f : AlternatingMap R' M'' N'' ι)", "(x : (a : ι) → M'')"]}, {"prop": "∀ (x : (a : ι) → M''), ↑f 0 = ↑f x", "context": ["{ι : Type u_4}", "{R' : Type u_1}", "{M'' : Type u_2}", "{N'' : Type u_3}", "[CommSemiring R']", "[AddCommMonoid M'']", "[AddCommMonoid N'']", "[Module R' M'']", "[Module R' N'']", "[IsEmpty ι]", "(f : AlternatingMap R' M'' N'' ι)"]}], "ids": ["AlternatingMap.ext", "AlternatingMap.congr_arg", "Subsingleton.elim"], "idString": "AlternatingMap.ext; AlternatingMap.congr_arg; Subsingleton.elim; ", "context": []}
{"typeGroup": "(∀ (α : Type u) {s : Set α} {t : Set α} (b : s ⟶ t),\n    (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Equivalence.inverse (Types.monoOverEquivalenceSet α))).map b =\n      CategoryTheory.MonoOver.homMk\n        fun\n          (w :\n            CategoryTheory.Comma.left\n              (CategoryTheory.FullSubcategory.obj ((fun (s : Set α) ↦ CategoryTheory.MonoOver.mk' Subtype.val) s))) ↦\n        { val := ((↑w)), property := (((Types.monoOverEquivalenceSet.proof_4 α b w=:↑w ∈ t))) } :\n  Prop)", "type": "∀ (α : Type u) {s : Set α} {t : Set α} (b : s ⟶ t),\n  (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Equivalence.inverse (Types.monoOverEquivalenceSet α))).map b =\n    (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Equivalence.inverse (Types.monoOverEquivalenceSet α))).map b", "thm": " : ∀ (α : Type u) {s : Set α} {t : Set α} (b : s ⟶ t),\n  (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Equivalence.inverse (Types.monoOverEquivalenceSet α))).map b =\n    (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Equivalence.inverse (Types.monoOverEquivalenceSet α))).map b", "terms": [{"value": "Types.monoOverEquivalenceSet α", "isProp": false, "context": ["(α : Type u)", "{s : Set α}", "{t : Set α}", "(b : s ⟶ t)"]}, {"value": "CategoryTheory.Equivalence.inverse (Types.monoOverEquivalenceSet α)", "isProp": false, "context": ["(α : Type u)", "{s : Set α}", "{t : Set α}", "(b : s ⟶ t)"]}], "namedLemmas": [], "lemmas": [], "ids": ["Eq.refl", "CategoryTheory.Functor.toPrefunctor", "CategoryTheory.Equivalence.inverse", "Types.monoOverEquivalenceSet", "map"], "idString": "Eq.refl; CategoryTheory.Functor.toPrefunctor; CategoryTheory.Equivalence.inverse; Types.monoOverEquivalenceSet; map; ", "context": []}
{"typeGroup": "(∀ {R : Type u} {L : Type v} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n    [inst_3 : IsLieAbelian L] (ψ : Module.Dual R L),\n    ↑LieAlgebra.lieCharacterEquivLinearDual.symm ψ =\n      {\n        toLinearMap :=\n          (({ toAddHom := ((LinearMap.toAddHom ψ)),\n            map_smul' :=\n              (((LieAlgebra.lieCharacterEquivLinearDual.proof_1\n                  ψ=:∀ (r : R) (x : L),\n                  AddHom.toFun (LinearMap.toAddHom ψ) (r • x) =\n                    ↑(RingHom.id R) r • AddHom.toFun (LinearMap.toAddHom ψ) x))) })),\n        map_lie' :=\n          ((((@LieAlgebra.lieCharacterEquivLinearDual.proof_2 R L inst inst_1 inst_2 inst_3\n                ψ=:∀ {x : L} {y : L},\n                AddHom.toFun\n                    (LinearMap.toAddHom\n                      { toAddHom := ((LinearMap.toAddHom ψ)),\n                        map_smul' :=\n                          (((LinearMap.map_smul'\n                              ψ=:∀ (r : R) (x : L),\n                              AddHom.toFun (LinearMap.toAddHom ψ) (r • x) =\n                                ↑(RingHom.id R) r • AddHom.toFun (LinearMap.toAddHom ψ) x))) })\n                    ⁅x, y⁆ =\n                  ⁅AddHom.toFun\n                      (LinearMap.toAddHom\n                        { toAddHom := ((LinearMap.toAddHom ψ)),\n                          map_smul' :=\n                            (((LinearMap.map_smul'\n                                ψ=:∀ (r : R) (x : L),\n                                AddHom.toFun (LinearMap.toAddHom ψ) (r • x) =\n                                  ↑(RingHom.id R) r • AddHom.toFun (LinearMap.toAddHom ψ) x))) })\n                      x,\n                    AddHom.toFun\n                      (LinearMap.toAddHom\n                        { toAddHom := ((LinearMap.toAddHom ψ)),\n                          map_smul' :=\n                            (((LinearMap.map_smul'\n                                ψ=:∀ (r : R) (x : L),\n                                AddHom.toFun (LinearMap.toAddHom ψ) (r • x) =\n                                  ↑(RingHom.id R) r • AddHom.toFun (LinearMap.toAddHom ψ) x))) })\n                      y⁆)=:∀ {x : L} {y : L},\n              AddHom.toFun\n                  (LinearMap.toAddHom\n                    { toAddHom := ((LinearMap.toAddHom ψ)),\n                      map_smul' :=\n                        (((LinearMap.map_smul'\n                            ψ=:∀ (r : R) (x : L),\n                            AddHom.toFun (LinearMap.toAddHom ψ) (r • x) =\n                              ↑(RingHom.id R) r • AddHom.toFun (LinearMap.toAddHom ψ) x))) })\n                  ⁅x, y⁆ =\n                ⁅AddHom.toFun\n                    (LinearMap.toAddHom\n                      { toAddHom := ((LinearMap.toAddHom ψ)),\n                        map_smul' :=\n                          (((LinearMap.map_smul'\n                              ψ=:∀ (r : R) (x : L),\n                              AddHom.toFun (LinearMap.toAddHom ψ) (r • x) =\n                                ↑(RingHom.id R) r • AddHom.toFun (LinearMap.toAddHom ψ) x))) })\n                    x,\n                  AddHom.toFun\n                    (LinearMap.toAddHom\n                      { toAddHom := ((LinearMap.toAddHom ψ)),\n                        map_smul' :=\n                          (((LinearMap.map_smul'\n                              ψ=:∀ (r : R) (x : L),\n                              AddHom.toFun (LinearMap.toAddHom ψ) (r • x) =\n                                ↑(RingHom.id R) r • AddHom.toFun (LinearMap.toAddHom ψ) x))) })\n                    y⁆))) } :\n  Prop)", "type": "∀ {R : Type u} {L : Type v} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L] [inst_3 : IsLieAbelian L]\n  (ψ : Module.Dual R L), ↑LieAlgebra.lieCharacterEquivLinearDual.symm ψ = ↑LieAlgebra.lieCharacterEquivLinearDual.symm ψ", "thm": " : ∀ {R : Type u} {L : Type v} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L] [inst_3 : IsLieAbelian L]\n  (ψ : Module.Dual R L), ↑LieAlgebra.lieCharacterEquivLinearDual.symm ψ = ↑LieAlgebra.lieCharacterEquivLinearDual.symm ψ", "terms": [], "namedLemmas": ["∀ {α : Type u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a"], "lemmas": [], "ids": ["Eq.refl", "LieAlgebra.lieCharacterEquivLinearDual", "symm"], "idString": "Eq.refl; LieAlgebra.lieCharacterEquivLinearDual; symm; ", "context": []}
{"typeGroup": "(∀ {V : Type u_1} {G : SimpleGraph V} {a : ↑(SimpleGraph.Subgraph.verts ⊤)} {b : ↑(SimpleGraph.Subgraph.verts ⊤)},\n    (SimpleGraph.Adj G\n          (↑{ toFun := ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)),\n                invFun := ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) })),\n                left_inv :=\n                  (((fun (x : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦\n                    (_ :\n                      (fun (v : V) ↦ { val := ((v)), property := ((trivial)) })\n                          ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v) x) =\n                        (fun (v : V) ↦ { val := ((v)), property := ((trivial)) })\n                          ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)\n                            x))=:∀ (x : ↑(SimpleGraph.Subgraph.verts ⊤)),\n                      (fun (v : V) ↦ { val := ((v)), property := ((trivial)) })\n                          ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v) x) =\n                        (fun (v : V) ↦ { val := ((v)), property := ((trivial)) })\n                          ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v) x)))),\n                right_inv :=\n                  (((fun (x : V) ↦\n                    (_ :\n                      (fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)\n                          ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) }) x) =\n                        (fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)\n                          ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) })\n                            x))=:∀ (x : V),\n                      (fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)\n                          ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) }) x) =\n                        (fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)\n                          ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) }) x)))) }\n            a)\n          (↑{ toFun := ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)),\n                invFun := ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) })),\n                left_inv :=\n                  (((fun (x : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦\n                    (_ :\n                      (fun (v : V) ↦ { val := ((v)), property := ((trivial)) })\n                          ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v) x) =\n                        (fun (v : V) ↦ { val := ((v)), property := ((trivial)) })\n                          ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)\n                            x))=:∀ (x : ↑(SimpleGraph.Subgraph.verts ⊤)),\n                      (fun (v : V) ↦ { val := ((v)), property := ((trivial)) })\n                          ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v) x) =\n                        (fun (v : V) ↦ { val := ((v)), property := ((trivial)) })\n                          ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v) x)))),\n                right_inv :=\n                  (((fun (x : V) ↦\n                    (_ :\n                      (fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)\n                          ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) }) x) =\n                        (fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)\n                          ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) })\n                            x))=:∀ (x : V),\n                      (fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)\n                          ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) }) x) =\n                        (fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)\n                          ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) }) x)))) }\n            b) :\n        Prop) ↔\n      (SimpleGraph.Adj G\n          (↑{ toFun := ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)),\n                invFun := ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) })),\n                left_inv :=\n                  (((fun (x : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦\n                    (_ :\n                      (fun (v : V) ↦ { val := ((v)), property := ((trivial)) })\n                          ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v) x) =\n                        (fun (v : V) ↦ { val := ((v)), property := ((trivial)) })\n                          ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)\n                            x))=:∀ (x : ↑(SimpleGraph.Subgraph.verts ⊤)),\n                      (fun (v : V) ↦ { val := ((v)), property := ((trivial)) })\n                          ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v) x) =\n                        (fun (v : V) ↦ { val := ((v)), property := ((trivial)) })\n                          ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v) x)))),\n                right_inv :=\n                  (((fun (x : V) ↦\n                    (_ :\n                      (fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)\n                          ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) }) x) =\n                        (fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)\n                          ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) })\n                            x))=:∀ (x : V),\n                      (fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)\n                          ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) }) x) =\n                        (fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)\n                          ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) }) x)))) }\n            a)\n          (↑{ toFun := ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)),\n                invFun := ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) })),\n                left_inv :=\n                  (((fun (x : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦\n                    (_ :\n                      (fun (v : V) ↦ { val := ((v)), property := ((trivial)) })\n                          ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v) x) =\n                        (fun (v : V) ↦ { val := ((v)), property := ((trivial)) })\n                          ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)\n                            x))=:∀ (x : ↑(SimpleGraph.Subgraph.verts ⊤)),\n                      (fun (v : V) ↦ { val := ((v)), property := ((trivial)) })\n                          ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v) x) =\n                        (fun (v : V) ↦ { val := ((v)), property := ((trivial)) })\n                          ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v) x)))),\n                right_inv :=\n                  (((fun (x : V) ↦\n                    (_ :\n                      (fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)\n                          ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) }) x) =\n                        (fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)\n                          ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) })\n                            x))=:∀ (x : V),\n                      (fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)\n                          ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) }) x) =\n                        (fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)\n                          ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) }) x)))) }\n            b) :\n        Prop) :\n  Prop)", "type": "∀ {V : Type u_1} {G : SimpleGraph V} {a : ↑(SimpleGraph.Subgraph.verts ⊤)} {b : ↑(SimpleGraph.Subgraph.verts ⊤)},\n  (SimpleGraph.Adj G\n      (↑{ toFun := ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)),\n            invFun := ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) })),\n            left_inv := (((fun (x : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ rfl))), right_inv := (((fun (x : V) ↦ rfl))) }\n        a)\n      (↑{ toFun := ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)),\n            invFun := ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) })),\n            left_inv := (((fun (x : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ rfl))), right_inv := (((fun (x : V) ↦ rfl))) }\n        b)) ↔\n    (SimpleGraph.Adj G\n      (↑{ toFun := ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)),\n            invFun := ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) })),\n            left_inv := (((fun (x : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ rfl))), right_inv := (((fun (x : V) ↦ rfl))) }\n        a)\n      (↑{ toFun := ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)),\n            invFun := ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) })),\n            left_inv := (((fun (x : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ rfl))), right_inv := (((fun (x : V) ↦ rfl))) }\n        b))", "thm": " : ∀ {V : Type u_1} {G : SimpleGraph V} {a : ↑(SimpleGraph.Subgraph.verts ⊤)} {b : ↑(SimpleGraph.Subgraph.verts ⊤)},\n  (SimpleGraph.Adj G\n      (↑{ toFun := ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)),\n            invFun := ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) })),\n            left_inv := (((fun (x : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ rfl))), right_inv := (((fun (x : V) ↦ rfl))) }\n        a)\n      (↑{ toFun := ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)),\n            invFun := ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) })),\n            left_inv := (((fun (x : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ rfl))), right_inv := (((fun (x : V) ↦ rfl))) }\n        b)) ↔\n    (SimpleGraph.Adj G\n      (↑{ toFun := ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)),\n            invFun := ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) })),\n            left_inv := (((fun (x : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ rfl))), right_inv := (((fun (x : V) ↦ rfl))) }\n        a)\n      (↑{ toFun := ((fun (v : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ ↑v)),\n            invFun := ((fun (v : V) ↦ { val := ((v)), property := ((trivial)) })),\n            left_inv := (((fun (x : ↑(SimpleGraph.Subgraph.verts ⊤)) ↦ rfl))), right_inv := (((fun (x : V) ↦ rfl))) }\n        b))", "terms": [], "namedLemmas": ["∀ {a : Prop}, a ↔ a"], "lemmas": [], "ids": ["Iff.rfl"], "idString": "Iff.rfl; ", "context": []}
{"typeGroup": "(∀ {R : Type u_2} {L₁ : Type u_1} [inst : CommRing R] [inst_1 : LieRing L₁] [inst_2 : LieAlgebra R L₁]\n    (L₁' : LieSubalgebra R L₁) (L₁'' : LieSubalgebra R L₁) (h : ↑L₁' = ↑L₁'') (x : { x : L₁ // x ∈ L₁' })\n    (y : { x : L₁ // x ∈ L₁' }),\n    AddHom.toFun\n        (LinearMap.toAddHom\n          ↑(LinearEquiv.ofEq (LieSubalgebra.toSubmodule L₁') (LieSubalgebra.toSubmodule L₁'')\n              (LieEquiv.ofEq.proof_2 L₁' L₁'' h=:LieSubalgebra.toSubmodule L₁' = LieSubalgebra.toSubmodule L₁'')))\n        ⁅x, y⁆ =\n      AddHom.toFun\n        (LinearMap.toAddHom\n          ↑(LinearEquiv.ofEq (LieSubalgebra.toSubmodule L₁') (LieSubalgebra.toSubmodule L₁'')\n              (LieEquiv.ofEq.proof_2 L₁' L₁'' h=:LieSubalgebra.toSubmodule L₁' = LieSubalgebra.toSubmodule L₁'')))\n        ⁅x, y⁆ :\n  Prop)", "type": "∀ {R : Type u_2} {L₁ : Type u_1} [inst : CommRing R] [inst_1 : LieRing L₁] [inst_2 : LieAlgebra R L₁]\n  (L₁' : LieSubalgebra R L₁) (L₁'' : LieSubalgebra R L₁) (h : ↑L₁' = ↑L₁'') (x : { x : L₁ // x ∈ L₁' })\n  (y : { x : L₁ // x ∈ L₁' }),\n  AddHom.toFun\n      (LinearMap.toAddHom\n        ↑(LinearEquiv.ofEq (LieSubalgebra.toSubmodule L₁') (LieSubalgebra.toSubmodule L₁'')\n            (LieEquiv.ofEq.proof_2 L₁' L₁'' h)))\n      ⁅x, y⁆ =\n    AddHom.toFun\n      (LinearMap.toAddHom\n        ↑(LinearEquiv.ofEq (LieSubalgebra.toSubmodule L₁') (LieSubalgebra.toSubmodule L₁'')\n            (LieEquiv.ofEq.proof_2 L₁' L₁'' h)))\n      ⁅x, y⁆", "thm": " : ∀ {R : Type u_2} {L₁ : Type u_1} [inst : CommRing R] [inst_1 : LieRing L₁] [inst_2 : LieAlgebra R L₁]\n  (L₁' : LieSubalgebra R L₁) (L₁'' : LieSubalgebra R L₁) (h : ↑L₁' = ↑L₁'') (x : { x : L₁ // x ∈ L₁' })\n  (y : { x : L₁ // x ∈ L₁' }),\n  AddHom.toFun\n      (LinearMap.toAddHom\n        ↑(LinearEquiv.ofEq (LieSubalgebra.toSubmodule L₁') (LieSubalgebra.toSubmodule L₁'')\n            (LieEquiv.ofEq.proof_2 L₁' L₁'' h)))\n      ⁅x, y⁆ =\n    AddHom.toFun\n      (LinearMap.toAddHom\n        ↑(LinearEquiv.ofEq (LieSubalgebra.toSubmodule L₁') (LieSubalgebra.toSubmodule L₁'')\n            (LieEquiv.ofEq.proof_2 L₁' L₁'' h)))\n      ⁅x, y⁆", "terms": [], "namedLemmas": ["∀ {α : Sort u} {a : α}, a = a"], "lemmas": [], "ids": ["rfl"], "idString": "rfl; ", "context": []}
{"typeGroup": "(∀ {n : ℕ+} {K : Type u_1} [inst : Field K] (L : Type u_2) [inst_1 : CommRing L] [inst_2 : IsDomain L]\n    [inst_3 : Algebra K L] [inst_4 : IsCyclotomicExtension {n} K L] (h : Irreducible (Polynomial.cyclotomic (↑n) K))\n    (t : (ZMod ↑n)ˣ),\n    (minpoly K\n          (PowerBasis.gen\n            (IsPrimitiveRoot.powerBasis K\n              (IsCyclotomicExtension.autEquivPow.proof_1 L=:IsPrimitiveRoot (IsCyclotomicExtension.zeta n K L) ↑n))) =\n        minpoly K\n          (PowerBasis.gen\n            (IsPrimitiveRoot.powerBasis K\n              (IsCyclotomicExtension.autEquivPow.proof_2 L\n                  t=:IsPrimitiveRoot (IsCyclotomicExtension.zeta n K L ^ ZMod.val ↑t) ↑n))) :\n      Prop) :\n  Prop)", "type": "∀ {n : ℕ+} {K : Type u_1} [inst : Field K] (L : Type u_2) [inst_1 : CommRing L] [inst_2 : IsDomain L]\n  [inst_3 : Algebra K L] [inst_4 : IsCyclotomicExtension {n} K L] (h : Irreducible (Polynomial.cyclotomic (↑n) K))\n  (t : (ZMod ↑n)ˣ),\n  (minpoly K (PowerBasis.gen (IsPrimitiveRoot.powerBasis K (IsCyclotomicExtension.autEquivPow.proof_1 L))) =\n    minpoly K (PowerBasis.gen (IsPrimitiveRoot.powerBasis K (IsCyclotomicExtension.autEquivPow.proof_2 L t))))", "thm": " : ∀ {n : ℕ+} {K : Type u_1} [inst : Field K] (L : Type u_2) [inst_1 : CommRing L] [inst_2 : IsDomain L]\n  [inst_3 : Algebra K L] [inst_4 : IsCyclotomicExtension {n} K L] (h : Irreducible (Polynomial.cyclotomic (↑n) K))\n  (t : (ZMod ↑n)ˣ),\n  (minpoly K (PowerBasis.gen (IsPrimitiveRoot.powerBasis K (IsCyclotomicExtension.autEquivPow.proof_1 L))) =\n    minpoly K (PowerBasis.gen (IsPrimitiveRoot.powerBasis K (IsCyclotomicExtension.autEquivPow.proof_2 L t))))", "terms": [{"value": "↑t", "isProp": false, "context": ["{n : ℕ+}", "{K : Type u_1}", "[Field K]", "(L : Type u_2)", "[CommRing L]", "[IsDomain L]", "[Algebra K L]", "[IsCyclotomicExtension {n} K L]", "(h : Irreducible (Polynomial.cyclotomic (↑n) K))", "(t : (ZMod ↑n)ˣ)"]}, {"value": "ZMod.val ↑t", "isProp": false, "context": ["{n : ℕ+}", "{K : Type u_1}", "[Field K]", "(L : Type u_2)", "[CommRing L]", "[IsDomain L]", "[Algebra K L]", "[IsCyclotomicExtension {n} K L]", "(h : Irreducible (Polynomial.cyclotomic (↑n) K))", "(t : (ZMod ↑n)ˣ)"]}], "namedLemmas": ["∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {K : Type u_1} [inst : Field K] {R : Type u_2} [inst_1 : CommRing R] [inst_2 : IsDomain R] {μ : R} {n : ℕ}\n  [inst_3 : Algebra K R],\n  IsPrimitiveRoot μ n →\n    Irreducible (Polynomial.cyclotomic n K) → ∀ [inst_4 : NeZero ↑n], Polynomial.cyclotomic n K = minpoly K μ", "∀ (n : ℕ+) (A : Type w) (B : Type z) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\n  [inst_3 : IsCyclotomicExtension {n} A B], IsPrimitiveRoot (IsCyclotomicExtension.zeta n A B) ↑n", "∀ {K : Type u_1} [inst : Field K] {R : Type u_2} [inst_1 : CommRing R] [inst_2 : IsDomain R] {μ : R} {n : ℕ}\n  [inst_3 : Algebra K R],\n  IsPrimitiveRoot μ n →\n    Irreducible (Polynomial.cyclotomic n K) → ∀ [inst_4 : NeZero ↑n], Polynomial.cyclotomic n K = minpoly K μ", "∀ {M : Type u_1} [inst : CommMonoid M] {k : ℕ} {ζ : M},\n  IsPrimitiveRoot ζ k → ∀ (i : ℕ), Nat.coprime i k → IsPrimitiveRoot (ζ ^ i) k", "∀ (n : ℕ+) (A : Type w) (B : Type z) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\n  [inst_3 : IsCyclotomicExtension {n} A B], IsPrimitiveRoot (IsCyclotomicExtension.zeta n A B) ↑n", "∀ {n : ℕ} (u : (ZMod n)ˣ), Nat.coprime (ZMod.val ↑u) n"], "lemmas": [{"prop": "IsPrimitiveRoot (IsCyclotomicExtension.zeta n K L) ↑n", "context": ["{n : ℕ+}", "{K : Type u_1}", "[Field K]", "(L : Type u_2)", "[CommRing L]", "[IsDomain L]", "[Algebra K L]", "[IsCyclotomicExtension {n} K L]", "(h : Irreducible (Polynomial.cyclotomic (↑n) K))", "(t : (ZMod ↑n)ˣ)", "(hr : Polynomial.cyclotomic (↑n) K = minpoly K (IsCyclotomicExtension.zeta n K L ^ ZMod.val ↑t))"]}, {"prop": "Polynomial.cyclotomic (↑n) K = minpoly K (IsCyclotomicExtension.zeta n K L)", "context": ["{n : ℕ+}", "{K : Type u_1}", "[Field K]", "(L : Type u_2)", "[CommRing L]", "[IsDomain L]", "[Algebra K L]", "[IsCyclotomicExtension {n} K L]", "(h : Irreducible (Polynomial.cyclotomic (↑n) K))", "(t : (ZMod ↑n)ˣ)", "(hr : Polynomial.cyclotomic (↑n) K = minpoly K (IsCyclotomicExtension.zeta n K L ^ ZMod.val ↑t))"]}, {"prop": "minpoly K (IsCyclotomicExtension.zeta n K L) = Polynomial.cyclotomic (↑n) K", "context": ["{n : ℕ+}", "{K : Type u_1}", "[Field K]", "(L : Type u_2)", "[CommRing L]", "[IsDomain L]", "[Algebra K L]", "[IsCyclotomicExtension {n} K L]", "(h : Irreducible (Polynomial.cyclotomic (↑n) K))", "(t : (ZMod ↑n)ˣ)", "(hr : Polynomial.cyclotomic (↑n) K = minpoly K (IsCyclotomicExtension.zeta n K L ^ ZMod.val ↑t))"]}, {"prop": "IsPrimitiveRoot (IsCyclotomicExtension.zeta n K L) ↑n", "context": ["{n : ℕ+}", "{K : Type u_1}", "[Field K]", "(L : Type u_2)", "[CommRing L]", "[IsDomain L]", "[Algebra K L]", "[IsCyclotomicExtension {n} K L]", "(h : Irreducible (Polynomial.cyclotomic (↑n) K))", "(t : (ZMod ↑n)ˣ)"]}, {"prop": "Nat.coprime (ZMod.val ↑t) ↑n", "context": ["{n : ℕ+}", "{K : Type u_1}", "[Field K]", "(L : Type u_2)", "[CommRing L]", "[IsDomain L]", "[Algebra K L]", "[IsCyclotomicExtension {n} K L]", "(h : Irreducible (Polynomial.cyclotomic (↑n) K))", "(t : (ZMod ↑n)ˣ)"]}, {"prop": "IsPrimitiveRoot (IsCyclotomicExtension.zeta n K L ^ ZMod.val ↑t) ↑n", "context": ["{n : ℕ+}", "{K : Type u_1}", "[Field K]", "(L : Type u_2)", "[CommRing L]", "[IsDomain L]", "[Algebra K L]", "[IsCyclotomicExtension {n} K L]", "(h : Irreducible (Polynomial.cyclotomic (↑n) K))", "(t : (ZMod ↑n)ˣ)"]}, {"prop": "minpoly K (IsCyclotomicExtension.zeta n K L) = minpoly K (IsCyclotomicExtension.zeta n K L ^ ZMod.val ↑t)", "context": ["{n : ℕ+}", "{K : Type u_1}", "[Field K]", "(L : Type u_2)", "[CommRing L]", "[IsDomain L]", "[Algebra K L]", "[IsCyclotomicExtension {n} K L]", "(h : Irreducible (Polynomial.cyclotomic (↑n) K))", "(t : (ZMod ↑n)ˣ)"]}], "ids": ["id", "Eq.trans", "Eq.symm", "IsPrimitiveRoot.minpoly_eq_cyclotomic_of_irreducible", "IsCyclotomicExtension.zeta_spec", "IsPrimitiveRoot.minpoly_eq_cyclotomic_of_irreducible", "IsPrimitiveRoot.pow_of_coprime", "IsCyclotomicExtension.zeta_spec", "ZMod.val", "ZMod.val_coe_unit_coprime"], "idString": "id; Eq.trans; Eq.symm; IsPrimitiveRoot.minpoly_eq_cyclotomic_of_irreducible; IsCyclotomicExtension.zeta_spec; IsPrimitiveRoot.minpoly_eq_cyclotomic_of_irreducible; IsPrimitiveRoot.pow_of_coprime; IsCyclotomicExtension.zeta_spec; ZMod.val; ZMod.val_coe_unit_coprime; ", "context": []}
{"typeGroup": "(∀ {X : Type u} [inst : TopologicalSpace X] {x₀ : X} {x₁ : X} {x₂ : X} {p₀ : Path x₀ x₁} {q₀ : Path x₀ x₁}\n    {p₁ : Path x₁ x₂} {q₁ : Path x₁ x₂} (F : Path.Homotopy p₀ q₀) (G : Path.Homotopy p₁ q₁)\n    (x : ↑unitInterval × ↑unitInterval),\n    ↑(Path.Homotopy.hcomp F G) x =\n      if h : (↑(Prod.snd x) ≤ 1 / 2 : Prop) then\n        ↑(Path.Homotopy.eval F (Prod.fst x))\n          { val := ((2 * ↑(Prod.snd x))),\n            property :=\n              (((Iff.mpr\n                  (unitInterval.mul_pos_mem_iff\n                      (zero_lt_two=:0 <\n                          2)=:(2 * ↑(Prod.snd x) ∈ unitInterval : Prop) ↔ (↑(Prod.snd x) ∈ Set.Icc 0 (1 / 2) : Prop))\n                  ({\n                      left :=\n                        (((And.left (Subtype.property (Prod.snd x)=:↑(Prod.snd x) ∈ unitInterval)=:0 ≤ ↑(Prod.snd x)))),\n                      right :=\n                        ((h)) }=:(0 ≤ ↑(Prod.snd x) : Prop) ∧\n                      (↑(Prod.snd x) ≤ 1 / 2 : Prop))=:2 * ↑(Prod.snd x) ∈ unitInterval))) }\n      else\n        ↑(Path.Homotopy.eval G (Prod.fst x))\n          { val := ((2 * ↑(Prod.snd x) - 1)),\n            property :=\n              (((Iff.mpr\n                  (unitInterval.two_mul_sub_one_mem_iff=:(2 * ↑(Prod.snd x) - 1 ∈ unitInterval : Prop) ↔\n                      (↑(Prod.snd x) ∈ Set.Icc (1 / 2) 1 : Prop))\n                  ({\n                      left :=\n                        (((LT.lt.le\n                            (Iff.mp (not_le=:(¬(↑(Prod.snd x) ≤ 1 / 2 : Prop) : Prop) ↔ (1 / 2 < ↑(Prod.snd x) : Prop))\n                                h=:1 / 2 < ↑(Prod.snd x))=:1 / 2 ≤ ↑(Prod.snd x)))),\n                      right :=\n                        (((And.right\n                            (Subtype.property\n                                (Prod.snd\n                                  x)=:↑(Prod.snd x) ∈\n                                unitInterval)=:↑(Prod.snd x) ≤\n                            1))) }=:(1 / 2 ≤ ↑(Prod.snd x) : Prop) ∧\n                      (↑(Prod.snd x) ≤ 1 : Prop))=:2 * ↑(Prod.snd x) - 1 ∈ unitInterval))) } :\n  Prop)", "type": "∀ {X : Type u} [inst : TopologicalSpace X] {x₀ : X} {x₁ : X} {x₂ : X} {p₀ : Path x₀ x₁} {q₀ : Path x₀ x₁}\n  {p₁ : Path x₁ x₂} {q₁ : Path x₁ x₂} (F : Path.Homotopy p₀ q₀) (G : Path.Homotopy p₁ q₁)\n  (x : ↑unitInterval × ↑unitInterval),\n  (if (↑(Prod.snd x) ≤ 1 / 2) then Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))\n    else Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)) =\n    if h : (↑(Prod.snd x) ≤ 1 / 2) then\n      ↑(Path.Homotopy.eval F (Prod.fst x))\n        { val := ((2 * ↑(Prod.snd x))),\n          property :=\n            (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n              ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) }\n    else\n      ↑(Path.Homotopy.eval G (Prod.fst x))\n        { val := ((2 * ↑(Prod.snd x) - 1)),\n          property :=\n            (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n              ({ left := (((LT.lt.le (Iff.mp not_le h)))),\n                right := (((And.right (Subtype.property (Prod.snd x))))) })))) }", "thm": " : ∀ {X : Type u} [inst : TopologicalSpace X] {x₀ : X} {x₁ : X} {x₂ : X} {p₀ : Path x₀ x₁} {q₀ : Path x₀ x₁}\n  {p₁ : Path x₁ x₂} {q₁ : Path x₁ x₂} (F : Path.Homotopy p₀ q₀) (G : Path.Homotopy p₁ q₁)\n  (x : ↑unitInterval × ↑unitInterval),\n  (if (↑(Prod.snd x) ≤ 1 / 2) then Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))\n    else Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)) =\n    if h : (↑(Prod.snd x) ≤ 1 / 2) then\n      ↑(Path.Homotopy.eval F (Prod.fst x))\n        { val := ((2 * ↑(Prod.snd x))),\n          property :=\n            (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n              ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) }\n    else\n      ↑(Path.Homotopy.eval G (Prod.fst x))\n        { val := ((2 * ↑(Prod.snd x) - 1)),\n          property :=\n            (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n              ({ left := (((LT.lt.le (Iff.mp not_le h)))),\n                right := (((And.right (Subtype.property (Prod.snd x))))) })))) }", "terms": [{"value": "Prod.fst x", "isProp": false, "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"value": "Path.Homotopy.eval F (Prod.fst x)", "isProp": false, "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"value": "Prod.snd x", "isProp": false, "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"value": "Path.Homotopy.eval G (Prod.fst x)", "isProp": false, "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}], "namedLemmas": ["∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {c : Prop} {h : Decidable c}, c → ∀ {α : Sort u} {t e : α}, (if c then t else e) = t", "∀ {c : Prop} {h : Decidable c} (hc : c) {α : Sort u} {t : c → α} {e : ¬c → α}, dite c t e = t hc", "∀ {X : Type u_1} [inst : TopologicalSpace X] {a b : X} (γ : Path a b) {t : ℝ} (ht : t ∈ Set.Icc 0 1),\n  Path.extend γ t = ↑γ { val := t, property := ht }", "∀ {a b : Prop}, (a ↔ b) → b → a", "∀ {a t : ℝ}, 0 < a → (a * t ∈ unitInterval ↔ t ∈ Set.Icc 0 (1 / a))", "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [inst_2 : ZeroLEOneClass α] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], 0 < 2", "∀ {a b : Prop}, a ∧ b → a", "∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self", "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {c : Prop} {h : Decidable c}, ¬c → ∀ {α : Sort u} {t e : α}, (if c then t else e) = e", "∀ {c : Prop} {h : Decidable c} (hnc : ¬c) {α : Sort u} {t : c → α} {e : ¬c → α}, dite c t e = e hnc", "∀ {X : Type u_1} [inst : TopologicalSpace X] {a b : X} (γ : Path a b) {t : ℝ} (ht : t ∈ Set.Icc 0 1),\n  Path.extend γ t = ↑γ { val := t, property := ht }", "∀ {a b : Prop}, (a ↔ b) → b → a", "∀ {t : ℝ}, 2 * t - 1 ∈ unitInterval ↔ t ∈ Set.Icc (1 / 2) 1", "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b", "∀ {a b : Prop}, (a ↔ b) → a → b", "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a ≤ b ↔ b < a", "∀ {a b : Prop}, a ∧ b → b", "∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self"], "lemmas": [{"prop": "(if (↑(Prod.snd x) ≤ 1 / 2) then Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))\n  else Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)) =\n  Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "Eq\n    (if (↑(Prod.snd x) ≤ 1 / 2) then Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))\n    else Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)) =\n  Eq (Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x)))", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "(if h : (↑(Prod.snd x) ≤ 1 / 2) then\n    ↑(Path.Homotopy.eval F (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x))),\n        property :=\n          (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n            ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) }\n  else\n    ↑(Path.Homotopy.eval G (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x) - 1)),\n        property :=\n          (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n            ({ left := (((LT.lt.le (Iff.mp not_le h)))),\n              right := (((And.right (Subtype.property (Prod.snd x))))) })))) }) =\n  ↑(Path.Homotopy.eval F (Prod.fst x))\n    { val := ((2 * ↑(Prod.snd x))),\n      property :=\n        (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n          ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) }", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "((if (↑(Prod.snd x) ≤ 1 / 2) then Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))\n    else Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)) =\n    if h : (↑(Prod.snd x) ≤ 1 / 2) then\n      ↑(Path.Homotopy.eval F (Prod.fst x))\n        { val := ((2 * ↑(Prod.snd x))),\n          property :=\n            (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n              ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) }\n    else\n      ↑(Path.Homotopy.eval G (Prod.fst x))\n        { val := ((2 * ↑(Prod.snd x) - 1)),\n          property :=\n            (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n              ({ left := (((LT.lt.le (Iff.mp not_le h)))),\n                right := (((And.right (Subtype.property (Prod.snd x))))) })))) }) =\n  (Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x)) =\n    ↑(Path.Homotopy.eval F (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x))),\n        property :=\n          (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n            ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) })", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "((if (↑(Prod.snd x) ≤ 1 / 2) then Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))\n    else Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)) =\n    if h : (↑(Prod.snd x) ≤ 1 / 2) then\n      ↑(Path.Homotopy.eval F (Prod.fst x))\n        { val := ((2 * ↑(Prod.snd x))),\n          property :=\n            (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n              ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) }\n    else\n      ↑(Path.Homotopy.eval G (Prod.fst x))\n        { val := ((2 * ↑(Prod.snd x) - 1)),\n          property :=\n            (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n              ({ left := (((LT.lt.le (Iff.mp not_le h)))),\n                right := (((And.right (Subtype.property (Prod.snd x))))) })))) }) =\n  (Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x)) =\n    ↑(Path.Homotopy.eval F (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x))),\n        property :=\n          (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n            ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) })", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "0 < 2", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "(2 * ↑(Prod.snd x) ∈ unitInterval) ↔ (↑(Prod.snd x) ∈ Set.Icc 0 (1 / 2))", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "↑(Prod.snd x) ∈ unitInterval", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "0 ≤ ↑(Prod.snd x)", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "(0 ≤ ↑(Prod.snd x)) ∧ (↑(Prod.snd x) ≤ 1 / 2)", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "2 * ↑(Prod.snd x) ∈ unitInterval", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x)) =\n  ↑(Path.Homotopy.eval F (Prod.fst x))\n    { val := ((2 * ↑(Prod.snd x))),\n      property :=\n        (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n          ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) }", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "(if (↑(Prod.snd x) ≤ 1 / 2) then Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))\n  else Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)) =\n  if h : (↑(Prod.snd x) ≤ 1 / 2) then\n    ↑(Path.Homotopy.eval F (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x))),\n        property :=\n          (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n            ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) }\n  else\n    ↑(Path.Homotopy.eval G (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x) - 1)),\n        property :=\n          (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n            ({ left := (((LT.lt.le (Iff.mp not_le h)))),\n              right := (((And.right (Subtype.property (Prod.snd x))))) })))) }", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "(if (↑(Prod.snd x) ≤ 1 / 2) then Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))\n  else Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)) =\n  Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "Eq\n    (if (↑(Prod.snd x) ≤ 1 / 2) then Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))\n    else Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)) =\n  Eq (Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1))", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "(if h : (↑(Prod.snd x) ≤ 1 / 2) then\n    ↑(Path.Homotopy.eval F (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x))),\n        property :=\n          (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n            ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) }\n  else\n    ↑(Path.Homotopy.eval G (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x) - 1)),\n        property :=\n          (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n            ({ left := (((LT.lt.le (Iff.mp not_le h)))),\n              right := (((And.right (Subtype.property (Prod.snd x))))) })))) }) =\n  ↑(Path.Homotopy.eval G (Prod.fst x))\n    { val := ((2 * ↑(Prod.snd x) - 1)),\n      property :=\n        (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n          ({ left := (((LT.lt.le (Iff.mp not_le h)))), right := (((And.right (Subtype.property (Prod.snd x))))) })))) }", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "((if (↑(Prod.snd x) ≤ 1 / 2) then Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))\n    else Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)) =\n    if h : (↑(Prod.snd x) ≤ 1 / 2) then\n      ↑(Path.Homotopy.eval F (Prod.fst x))\n        { val := ((2 * ↑(Prod.snd x))),\n          property :=\n            (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n              ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) }\n    else\n      ↑(Path.Homotopy.eval G (Prod.fst x))\n        { val := ((2 * ↑(Prod.snd x) - 1)),\n          property :=\n            (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n              ({ left := (((LT.lt.le (Iff.mp not_le h)))),\n                right := (((And.right (Subtype.property (Prod.snd x))))) })))) }) =\n  (Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1) =\n    ↑(Path.Homotopy.eval G (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x) - 1)),\n        property :=\n          (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n            ({ left := (((LT.lt.le (Iff.mp not_le h)))),\n              right := (((And.right (Subtype.property (Prod.snd x))))) })))) })", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "((if (↑(Prod.snd x) ≤ 1 / 2) then Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))\n    else Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)) =\n    if h : (↑(Prod.snd x) ≤ 1 / 2) then\n      ↑(Path.Homotopy.eval F (Prod.fst x))\n        { val := ((2 * ↑(Prod.snd x))),\n          property :=\n            (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n              ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) }\n    else\n      ↑(Path.Homotopy.eval G (Prod.fst x))\n        { val := ((2 * ↑(Prod.snd x) - 1)),\n          property :=\n            (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n              ({ left := (((LT.lt.le (Iff.mp not_le h)))),\n                right := (((And.right (Subtype.property (Prod.snd x))))) })))) }) =\n  (Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1) =\n    ↑(Path.Homotopy.eval G (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x) - 1)),\n        property :=\n          (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n            ({ left := (((LT.lt.le (Iff.mp not_le h)))),\n              right := (((And.right (Subtype.property (Prod.snd x))))) })))) })", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "(2 * ↑(Prod.snd x) - 1 ∈ unitInterval) ↔ (↑(Prod.snd x) ∈ Set.Icc (1 / 2) 1)", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "(¬(↑(Prod.snd x) ≤ 1 / 2)) ↔ (1 / 2 < ↑(Prod.snd x))", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "1 / 2 < ↑(Prod.snd x)", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "1 / 2 ≤ ↑(Prod.snd x)", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "↑(Prod.snd x) ∈ unitInterval", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "↑(Prod.snd x) ≤ 1", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "(1 / 2 ≤ ↑(Prod.snd x)) ∧ (↑(Prod.snd x) ≤ 1)", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "2 * ↑(Prod.snd x) - 1 ∈ unitInterval", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1) =\n  ↑(Path.Homotopy.eval G (Prod.fst x))\n    { val := ((2 * ↑(Prod.snd x) - 1)),\n      property :=\n        (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n          ({ left := (((LT.lt.le (Iff.mp not_le h)))), right := (((And.right (Subtype.property (Prod.snd x))))) })))) }", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "(if (↑(Prod.snd x) ≤ 1 / 2) then Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))\n  else Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)) =\n  if h : (↑(Prod.snd x) ≤ 1 / 2) then\n    ↑(Path.Homotopy.eval F (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x))),\n        property :=\n          (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n            ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) }\n  else\n    ↑(Path.Homotopy.eval G (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x) - 1)),\n        property :=\n          (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n            ({ left := (((LT.lt.le (Iff.mp not_le h)))),\n              right := (((And.right (Subtype.property (Prod.snd x))))) })))) }", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}], "ids": ["h", "Prod.snd", "Eq.mpr", "id", "congr", "congrArg", "Eq", "if_pos", "h", "dif_pos", "h", "Path.extend_extends", "Path.Homotopy.eval", "Prod.fst", "Iff.mpr", "unitInterval.mul_pos_mem_iff", "zero_lt_two", "left", "And.left", "Subtype.property", "Prod.snd", "right", "h", "Eq.mpr", "id", "congr", "congrArg", "Eq", "if_neg", "h", "dif_neg", "h", "Path.extend_extends", "Path.Homotopy.eval", "Prod.fst", "Iff.mpr", "unitInterval.two_mul_sub_one_mem_iff", "left", "LT.lt.le", "Iff.mp", "not_le", "h", "right", "And.right", "Subtype.property", "Prod.snd"], "idString": "h; Prod.snd; Eq.mpr; id; congr; congrArg; Eq; if_pos; h; dif_pos; h; Path.extend_extends; Path.Homotopy.eval; Prod.fst; Iff.mpr; unitInterval.mul_pos_mem_iff; zero_lt_two; left; And.left; Subtype.property; Prod.snd; right; h; Eq.mpr; id; congr; congrArg; Eq; if_neg; h; dif_neg; h; Path.extend_extends; Path.Homotopy.eval; Prod.fst; Iff.mpr; unitInterval.two_mul_sub_one_mem_iff; left; LT.lt.le; Iff.mp; not_le; h; right; And.right; Subtype.property; Prod.snd; ", "context": []}
{"typeGroup": "(∀ {X : Type u} [inst : Preorder X] {x : X} {y : X} (h : x ⟶ y), LE.le.hom (Quiver.Hom.le h=:x ≤ y) = h : Prop)", "type": "∀ {X : Type u} [inst : Preorder X] {x : X} {y : X} (h : x ⟶ y),\n  LE.le.hom (Quiver.Hom.le h) = LE.le.hom (Quiver.Hom.le h)", "thm": " : ∀ {X : Type u} [inst : Preorder X] {x : X} {y : X} (h : x ⟶ y),\n  LE.le.hom (Quiver.Hom.le h) = LE.le.hom (Quiver.Hom.le h)", "terms": [], "namedLemmas": ["∀ {α : Sort u} {a : α}, a = a"], "lemmas": [], "ids": ["rfl"], "idString": "rfl; ", "context": []}
{"typeGroup": "(∀ {X : Type u} [inst : TopologicalSpace X] {x₀ : X} {x₁ : X} {x₂ : X} {p₀ : Path x₀ x₁} {q₀ : Path x₀ x₁}\n    {p₁ : Path x₁ x₂} {q₁ : Path x₁ x₂} (F : Path.Homotopy p₀ q₀) (G : Path.Homotopy p₁ q₁)\n    (x : ↑unitInterval × ↑unitInterval),\n    ↑(Path.Homotopy.hcomp F G) x =\n      if h : (↑(Prod.snd x) ≤ 1 / 2 : Prop) then\n        ↑(Path.Homotopy.eval F (Prod.fst x))\n          { val := ((2 * ↑(Prod.snd x))),\n            property :=\n              (((Iff.mpr\n                  (unitInterval.mul_pos_mem_iff\n                      (zero_lt_two=:0 <\n                          2)=:(2 * ↑(Prod.snd x) ∈ unitInterval : Prop) ↔ (↑(Prod.snd x) ∈ Set.Icc 0 (1 / 2) : Prop))\n                  ({\n                      left :=\n                        (((And.left (Subtype.property (Prod.snd x)=:↑(Prod.snd x) ∈ unitInterval)=:0 ≤ ↑(Prod.snd x)))),\n                      right :=\n                        ((h)) }=:(0 ≤ ↑(Prod.snd x) : Prop) ∧\n                      (↑(Prod.snd x) ≤ 1 / 2 : Prop))=:2 * ↑(Prod.snd x) ∈ unitInterval))) }\n      else\n        ↑(Path.Homotopy.eval G (Prod.fst x))\n          { val := ((2 * ↑(Prod.snd x) - 1)),\n            property :=\n              (((Iff.mpr\n                  (unitInterval.two_mul_sub_one_mem_iff=:(2 * ↑(Prod.snd x) - 1 ∈ unitInterval : Prop) ↔\n                      (↑(Prod.snd x) ∈ Set.Icc (1 / 2) 1 : Prop))\n                  ({\n                      left :=\n                        (((LT.lt.le\n                            (Iff.mp (not_le=:(¬(↑(Prod.snd x) ≤ 1 / 2 : Prop) : Prop) ↔ (1 / 2 < ↑(Prod.snd x) : Prop))\n                                h=:1 / 2 < ↑(Prod.snd x))=:1 / 2 ≤ ↑(Prod.snd x)))),\n                      right :=\n                        (((And.right\n                            (Subtype.property\n                                (Prod.snd\n                                  x)=:↑(Prod.snd x) ∈\n                                unitInterval)=:↑(Prod.snd x) ≤\n                            1))) }=:(1 / 2 ≤ ↑(Prod.snd x) : Prop) ∧\n                      (↑(Prod.snd x) ≤ 1 : Prop))=:2 * ↑(Prod.snd x) - 1 ∈ unitInterval))) } :\n  Prop)", "type": "(if (↑(Prod.snd x) ≤ 1 / 2) then Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))\n  else Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)) =\n  if h : (↑(Prod.snd x) ≤ 1 / 2) then\n    ↑(Path.Homotopy.eval F (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x))),\n        property :=\n          (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n            ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) }\n  else\n    ↑(Path.Homotopy.eval G (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x) - 1)),\n        property :=\n          (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n            ({ left := (((LT.lt.le (Iff.mp not_le h)))),\n              right := (((And.right (Subtype.property (Prod.snd x))))) })))) }", "thm": "{X : Type u} [TopologicalSpace X] {x₀ : X} {x₁ : X} {x₂ : X} {p₀ : Path x₀ x₁} {q₀ : Path x₀ x₁} {p₁ : Path x₁ x₂} {q₁ : Path x₁ x₂} (F : Path.Homotopy p₀ q₀) (G : Path.Homotopy p₁ q₁) (x : ↑unitInterval × ↑unitInterval)  : (if (↑(Prod.snd x) ≤ 1 / 2) then Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))\n  else Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)) =\n  if h : (↑(Prod.snd x) ≤ 1 / 2) then\n    ↑(Path.Homotopy.eval F (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x))),\n        property :=\n          (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n            ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) }\n  else\n    ↑(Path.Homotopy.eval G (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x) - 1)),\n        property :=\n          (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n            ({ left := (((LT.lt.le (Iff.mp not_le h)))),\n              right := (((And.right (Subtype.property (Prod.snd x))))) })))) }", "terms": [{"value": "Prod.fst x", "isProp": false, "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"value": "Path.Homotopy.eval F (Prod.fst x)", "isProp": false, "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"value": "Prod.snd x", "isProp": false, "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"value": "Path.Homotopy.eval G (Prod.fst x)", "isProp": false, "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}], "namedLemmas": ["∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {c : Prop} {h : Decidable c}, c → ∀ {α : Sort u} {t e : α}, (if c then t else e) = t", "∀ {c : Prop} {h : Decidable c} (hc : c) {α : Sort u} {t : c → α} {e : ¬c → α}, dite c t e = t hc", "∀ {X : Type u_1} [inst : TopologicalSpace X] {a b : X} (γ : Path a b) {t : ℝ} (ht : t ∈ Set.Icc 0 1),\n  Path.extend γ t = ↑γ { val := t, property := ht }", "∀ {a b : Prop}, (a ↔ b) → b → a", "∀ {a t : ℝ}, 0 < a → (a * t ∈ unitInterval ↔ t ∈ Set.Icc 0 (1 / a))", "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [inst_2 : ZeroLEOneClass α] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], 0 < 2", "∀ {a b : Prop}, a ∧ b → a", "∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self", "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {c : Prop} {h : Decidable c}, ¬c → ∀ {α : Sort u} {t e : α}, (if c then t else e) = e", "∀ {c : Prop} {h : Decidable c} (hnc : ¬c) {α : Sort u} {t : c → α} {e : ¬c → α}, dite c t e = e hnc", "∀ {X : Type u_1} [inst : TopologicalSpace X] {a b : X} (γ : Path a b) {t : ℝ} (ht : t ∈ Set.Icc 0 1),\n  Path.extend γ t = ↑γ { val := t, property := ht }", "∀ {a b : Prop}, (a ↔ b) → b → a", "∀ {t : ℝ}, 2 * t - 1 ∈ unitInterval ↔ t ∈ Set.Icc (1 / 2) 1", "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b", "∀ {a b : Prop}, (a ↔ b) → a → b", "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a ≤ b ↔ b < a", "∀ {a b : Prop}, a ∧ b → b", "∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self"], "lemmas": [{"prop": "(if (↑(Prod.snd x) ≤ 1 / 2) then Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))\n  else Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)) =\n  Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "Eq\n    (if (↑(Prod.snd x) ≤ 1 / 2) then Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))\n    else Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)) =\n  Eq (Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x)))", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "(if h : (↑(Prod.snd x) ≤ 1 / 2) then\n    ↑(Path.Homotopy.eval F (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x))),\n        property :=\n          (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n            ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) }\n  else\n    ↑(Path.Homotopy.eval G (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x) - 1)),\n        property :=\n          (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n            ({ left := (((LT.lt.le (Iff.mp not_le h)))),\n              right := (((And.right (Subtype.property (Prod.snd x))))) })))) }) =\n  ↑(Path.Homotopy.eval F (Prod.fst x))\n    { val := ((2 * ↑(Prod.snd x))),\n      property :=\n        (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n          ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) }", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "((if (↑(Prod.snd x) ≤ 1 / 2) then Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))\n    else Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)) =\n    if h : (↑(Prod.snd x) ≤ 1 / 2) then\n      ↑(Path.Homotopy.eval F (Prod.fst x))\n        { val := ((2 * ↑(Prod.snd x))),\n          property :=\n            (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n              ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) }\n    else\n      ↑(Path.Homotopy.eval G (Prod.fst x))\n        { val := ((2 * ↑(Prod.snd x) - 1)),\n          property :=\n            (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n              ({ left := (((LT.lt.le (Iff.mp not_le h)))),\n                right := (((And.right (Subtype.property (Prod.snd x))))) })))) }) =\n  (Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x)) =\n    ↑(Path.Homotopy.eval F (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x))),\n        property :=\n          (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n            ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) })", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "((if (↑(Prod.snd x) ≤ 1 / 2) then Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))\n    else Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)) =\n    if h : (↑(Prod.snd x) ≤ 1 / 2) then\n      ↑(Path.Homotopy.eval F (Prod.fst x))\n        { val := ((2 * ↑(Prod.snd x))),\n          property :=\n            (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n              ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) }\n    else\n      ↑(Path.Homotopy.eval G (Prod.fst x))\n        { val := ((2 * ↑(Prod.snd x) - 1)),\n          property :=\n            (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n              ({ left := (((LT.lt.le (Iff.mp not_le h)))),\n                right := (((And.right (Subtype.property (Prod.snd x))))) })))) }) =\n  (Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x)) =\n    ↑(Path.Homotopy.eval F (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x))),\n        property :=\n          (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n            ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) })", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "0 < 2", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "(2 * ↑(Prod.snd x) ∈ unitInterval) ↔ (↑(Prod.snd x) ∈ Set.Icc 0 (1 / 2))", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "↑(Prod.snd x) ∈ unitInterval", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "0 ≤ ↑(Prod.snd x)", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "(0 ≤ ↑(Prod.snd x)) ∧ (↑(Prod.snd x) ≤ 1 / 2)", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "2 * ↑(Prod.snd x) ∈ unitInterval", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x)) =\n  ↑(Path.Homotopy.eval F (Prod.fst x))\n    { val := ((2 * ↑(Prod.snd x))),\n      property :=\n        (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n          ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) }", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "(if (↑(Prod.snd x) ≤ 1 / 2) then Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))\n  else Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)) =\n  if h : (↑(Prod.snd x) ≤ 1 / 2) then\n    ↑(Path.Homotopy.eval F (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x))),\n        property :=\n          (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n            ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) }\n  else\n    ↑(Path.Homotopy.eval G (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x) - 1)),\n        property :=\n          (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n            ({ left := (((LT.lt.le (Iff.mp not_le h)))),\n              right := (((And.right (Subtype.property (Prod.snd x))))) })))) }", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "(if (↑(Prod.snd x) ≤ 1 / 2) then Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))\n  else Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)) =\n  Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "Eq\n    (if (↑(Prod.snd x) ≤ 1 / 2) then Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))\n    else Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)) =\n  Eq (Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1))", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "(if h : (↑(Prod.snd x) ≤ 1 / 2) then\n    ↑(Path.Homotopy.eval F (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x))),\n        property :=\n          (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n            ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) }\n  else\n    ↑(Path.Homotopy.eval G (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x) - 1)),\n        property :=\n          (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n            ({ left := (((LT.lt.le (Iff.mp not_le h)))),\n              right := (((And.right (Subtype.property (Prod.snd x))))) })))) }) =\n  ↑(Path.Homotopy.eval G (Prod.fst x))\n    { val := ((2 * ↑(Prod.snd x) - 1)),\n      property :=\n        (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n          ({ left := (((LT.lt.le (Iff.mp not_le h)))), right := (((And.right (Subtype.property (Prod.snd x))))) })))) }", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "((if (↑(Prod.snd x) ≤ 1 / 2) then Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))\n    else Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)) =\n    if h : (↑(Prod.snd x) ≤ 1 / 2) then\n      ↑(Path.Homotopy.eval F (Prod.fst x))\n        { val := ((2 * ↑(Prod.snd x))),\n          property :=\n            (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n              ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) }\n    else\n      ↑(Path.Homotopy.eval G (Prod.fst x))\n        { val := ((2 * ↑(Prod.snd x) - 1)),\n          property :=\n            (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n              ({ left := (((LT.lt.le (Iff.mp not_le h)))),\n                right := (((And.right (Subtype.property (Prod.snd x))))) })))) }) =\n  (Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1) =\n    ↑(Path.Homotopy.eval G (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x) - 1)),\n        property :=\n          (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n            ({ left := (((LT.lt.le (Iff.mp not_le h)))),\n              right := (((And.right (Subtype.property (Prod.snd x))))) })))) })", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "((if (↑(Prod.snd x) ≤ 1 / 2) then Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))\n    else Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)) =\n    if h : (↑(Prod.snd x) ≤ 1 / 2) then\n      ↑(Path.Homotopy.eval F (Prod.fst x))\n        { val := ((2 * ↑(Prod.snd x))),\n          property :=\n            (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n              ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) }\n    else\n      ↑(Path.Homotopy.eval G (Prod.fst x))\n        { val := ((2 * ↑(Prod.snd x) - 1)),\n          property :=\n            (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n              ({ left := (((LT.lt.le (Iff.mp not_le h)))),\n                right := (((And.right (Subtype.property (Prod.snd x))))) })))) }) =\n  (Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1) =\n    ↑(Path.Homotopy.eval G (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x) - 1)),\n        property :=\n          (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n            ({ left := (((LT.lt.le (Iff.mp not_le h)))),\n              right := (((And.right (Subtype.property (Prod.snd x))))) })))) })", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "(2 * ↑(Prod.snd x) - 1 ∈ unitInterval) ↔ (↑(Prod.snd x) ∈ Set.Icc (1 / 2) 1)", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "(¬(↑(Prod.snd x) ≤ 1 / 2)) ↔ (1 / 2 < ↑(Prod.snd x))", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "1 / 2 < ↑(Prod.snd x)", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "1 / 2 ≤ ↑(Prod.snd x)", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "↑(Prod.snd x) ∈ unitInterval", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "↑(Prod.snd x) ≤ 1", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "(1 / 2 ≤ ↑(Prod.snd x)) ∧ (↑(Prod.snd x) ≤ 1)", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "2 * ↑(Prod.snd x) - 1 ∈ unitInterval", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1) =\n  ↑(Path.Homotopy.eval G (Prod.fst x))\n    { val := ((2 * ↑(Prod.snd x) - 1)),\n      property :=\n        (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n          ({ left := (((LT.lt.le (Iff.mp not_le h)))), right := (((And.right (Subtype.property (Prod.snd x))))) })))) }", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}, {"prop": "(if (↑(Prod.snd x) ≤ 1 / 2) then Path.extend (Path.Homotopy.eval F (Prod.fst x)) (2 * ↑(Prod.snd x))\n  else Path.extend (Path.Homotopy.eval G (Prod.fst x)) (2 * ↑(Prod.snd x) - 1)) =\n  if h : (↑(Prod.snd x) ≤ 1 / 2) then\n    ↑(Path.Homotopy.eval F (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x))),\n        property :=\n          (((Iff.mpr (unitInterval.mul_pos_mem_iff zero_lt_two)\n            ({ left := (((And.left (Subtype.property (Prod.snd x))))), right := ((h)) })))) }\n  else\n    ↑(Path.Homotopy.eval G (Prod.fst x))\n      { val := ((2 * ↑(Prod.snd x) - 1)),\n        property :=\n          (((Iff.mpr unitInterval.two_mul_sub_one_mem_iff\n            ({ left := (((LT.lt.le (Iff.mp not_le h)))),\n              right := (((And.right (Subtype.property (Prod.snd x))))) })))) }", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}], "ids": ["h", "Prod.snd", "Eq.mpr", "id", "congr", "congrArg", "Eq", "if_pos", "h", "dif_pos", "h", "Path.extend_extends", "Path.Homotopy.eval", "Prod.fst", "Iff.mpr", "unitInterval.mul_pos_mem_iff", "zero_lt_two", "left", "And.left", "Subtype.property", "Prod.snd", "right", "h", "Eq.mpr", "id", "congr", "congrArg", "Eq", "if_neg", "h", "dif_neg", "h", "Path.extend_extends", "Path.Homotopy.eval", "Prod.fst", "Iff.mpr", "unitInterval.two_mul_sub_one_mem_iff", "left", "LT.lt.le", "Iff.mp", "not_le", "h", "right", "And.right", "Subtype.property", "Prod.snd"], "idString": "h; Prod.snd; Eq.mpr; id; congr; congrArg; Eq; if_pos; h; dif_pos; h; Path.extend_extends; Path.Homotopy.eval; Prod.fst; Iff.mpr; unitInterval.mul_pos_mem_iff; zero_lt_two; left; And.left; Subtype.property; Prod.snd; right; h; Eq.mpr; id; congr; congrArg; Eq; if_neg; h; dif_neg; h; Path.extend_extends; Path.Homotopy.eval; Prod.fst; Iff.mpr; unitInterval.two_mul_sub_one_mem_iff; left; LT.lt.le; Iff.mp; not_le; h; right; And.right; Subtype.property; Prod.snd; ", "context": ["{X : Type u}", "[TopologicalSpace X]", "{x₀ : X}", "{x₁ : X}", "{x₂ : X}", "{p₀ : Path x₀ x₁}", "{q₀ : Path x₀ x₁}", "{p₁ : Path x₁ x₂}", "{q₁ : Path x₁ x₂}", "(F : Path.Homotopy p₀ q₀)", "(G : Path.Homotopy p₁ q₁)", "(x : ↑unitInterval × ↑unitInterval)"]}
{"typeGroup": "(∀ {α : Type} {ds₁ : List ℕ} {ds₂ : List ℕ} (eq : ds₁ = ds₂) (a : Holor α ds₁),\n    cast (congr_arg (Holor α) eq=:Holor α ds₁ = Holor α ds₂) a = fun (t : HolorIndex ds₂) ↦\n      a (cast (congr_arg HolorIndex (Eq.symm eq=:ds₂ = ds₁)=:HolorIndex ds₂ = HolorIndex ds₁) t) :\n  Prop)", "type": "∀ {α : Type} {ds₁ : List ℕ} {ds₂ : List ℕ} (eq : ds₁ = ds₂) (a : Holor α ds₁),\n  cast (congr_arg (Holor α) eq) a = fun (t : HolorIndex ds₂) ↦ a (cast (congr_arg HolorIndex (Eq.symm eq)) t)", "thm": " : ∀ {α : Type} {ds₁ : List ℕ} {ds₂ : List ℕ} (eq : ds₁ = ds₂) (a : Holor α ds₁),\n  cast (congr_arg (Holor α) eq) a = fun (t : HolorIndex ds₂) ↦ a (cast (congr_arg HolorIndex (Eq.symm eq)) t)", "terms": [{"value": "Holor α", "isProp": false, "context": ["{α : Type}", "{ds₁ : List ℕ}", "{ds₂ : List ℕ}", "(eq : ds₁ = ds₂)", "(a : Holor α ds₁)"]}], "namedLemmas": ["∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂"], "lemmas": [{"prop": "ds₁ = ds₁", "context": ["{α : Type}", "{ds₁ : List ℕ}", "{ds₂ : List ℕ}", "(eq : ds₁ = ds₂)", "(a : Holor α ds₁)"]}, {"prop": "Holor α ds₁ = Holor α ds₁", "context": ["{α : Type}", "{ds₁ : List ℕ}", "{ds₂ : List ℕ}", "(eq : ds₁ = ds₂)", "(a : Holor α ds₁)"]}, {"prop": "cast (congr_arg (Holor α) (Eq.refl ds₁)) a = cast (congr_arg (Holor α) (Eq.refl ds₁)) a", "context": ["{α : Type}", "{ds₁ : List ℕ}", "{ds₂ : List ℕ}", "(eq : ds₁ = ds₂)", "(a : Holor α ds₁)"]}], "ids": ["Eq.refl", "cast", "congr_arg", "Holor", "Eq.refl"], "idString": "Eq.refl; cast; congr_arg; Holor; Eq.refl; ", "context": []}
{"typeGroup": "(∀ (n : ℕ) (P : (k : ℕ) → (a : k < n + 1) → Prop)\n    (h : ∀ (n_1 : ℕ) (h : n_1 < n), P n_1 (Nat.lt_succ_of_lt h=:n_1 < Nat.succ n))\n    (p : P n (Nat.lt_succ_self n=:n < Nat.succ n)) (k : ℕ) (h' : k < n + 1), P k h' :\n  Prop)", "type": "∀ (n : ℕ) (P : (k : ℕ) → (a : k < n + 1) → Prop) (h : ∀ (n_1 : ℕ) (h : n_1 < n), P n_1 (Nat.lt_succ_of_lt h))\n  (p : P n (Nat.lt_succ_self n)) (k : ℕ) (h' : k < n + 1), P k h'", "thm": " : ∀ (n : ℕ) (P : (k : ℕ) → (a : k < n + 1) → Prop) (h : ∀ (n_1 : ℕ) (h : n_1 < n), P n_1 (Nat.lt_succ_of_lt h))\n  (p : P n (Nat.lt_succ_self n)) (k : ℕ) (h' : k < n + 1), P k h'", "terms": [], "namedLemmas": ["∀ {a b c : Prop}, a ∨ b → (a → c) → (b → c) → c", "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : DecidableRel fun x x_1 => x ≤ x_1] {a b : α}, a ≤ b → a < b ∨ a = b", "∀ {m n : ℕ}, m < Nat.succ n → m ≤ n"], "lemmas": [{"prop": "k ≤ n", "context": ["(n : ℕ)", "(P : (k : ℕ) → (a : k < n + 1) → Prop)", "(h : ∀ (n_1 : ℕ) (h : n_1 < n), P n_1 (Nat.lt_succ_of_lt h))", "(p : P n (Nat.lt_succ_self n))", "(k : ℕ)", "(h' : k < n + 1)"]}, {"prop": "(k < n) ∨ (k = n)", "context": ["(n : ℕ)", "(P : (k : ℕ) → (a : k < n + 1) → Prop)", "(h : ∀ (n_1 : ℕ) (h : n_1 < n), P n_1 (Nat.lt_succ_of_lt h))", "(p : P n (Nat.lt_succ_self n))", "(k : ℕ)", "(h' : k < n + 1)"]}, {"prop": "∀ (h : k < n), P k (Nat.lt_succ_of_lt h)", "context": ["(n : ℕ)", "(P : (k : ℕ) → (a : k < n + 1) → Prop)", "(h : ∀ (n_1 : ℕ) (h : n_1 < n), P n_1 (Nat.lt_succ_of_lt h))", "(p : P n (Nat.lt_succ_self n))", "(k : ℕ)", "(h' : k < n + 1)"]}, {"prop": "∀ (x : n < n + 1), P n (Nat.lt_succ_self n)", "context": ["(n : ℕ)", "(P : (k : ℕ) → (a : k < n + 1) → Prop)", "(h : ∀ (n_1 : ℕ) (h : n_1 < n), P n_1 (Nat.lt_succ_of_lt h))", "(p : P n (Nat.lt_succ_self n))", "(k : ℕ)", "(h' : k < n + 1)", "(e : k = n)"]}, {"prop": "∀ (e : k = n), P k h'", "context": ["(n : ℕ)", "(P : (k : ℕ) → (a : k < n + 1) → Prop)", "(h : ∀ (n_1 : ℕ) (h : n_1 < n), P n_1 (Nat.lt_succ_of_lt h))", "(p : P n (Nat.lt_succ_self n))", "(k : ℕ)", "(h' : k < n + 1)"]}], "ids": ["Or.elim", "LE.le.lt_or_eq_dec", "Nat.le_of_lt_succ", "Nat.decidableBallLT.match_2"], "idString": "Or.elim; LE.le.lt_or_eq_dec; Nat.le_of_lt_succ; Nat.decidableBallLT.match_2; ", "context": []}
{"typeGroup": "(∀ {d : ℕ} {ds : List ℕ} (p : (a : HolorIndex (d :: ds)) → Prop) (t : HolorIndex (d :: ds))\n    (a :\n      ∀ (i : ℕ) (is : List ℕ) (h : ↑t = i :: is),\n        p\n          { val := ((i :: is)),\n            property :=\n              (((Eq.mpr\n                  (id\n                      ((Eq.symm h=:i :: is = ↑t) ▸\n                          (Eq.refl\n                              (List.Forall₂ (fun (x : ℕ) (x_1 : ℕ) ↦ x < x_1) (i :: is) (d :: ds) :\n                                Prop)=:(List.Forall₂ (fun (x : ℕ) (x_1 : ℕ) ↦ x < x_1) (i :: is) (d :: ds) : Prop) =\n                              (List.Forall₂ (fun (x : ℕ) (x_1 : ℕ) ↦ x < x_1) (i :: is) (d :: ds) :\n                                Prop))=:(List.Forall₂ (fun (x : ℕ) (x_1 : ℕ) ↦ x < x_1) (i :: is) (d :: ds) : Prop) =\n                          (List.Forall₂ (fun (x : ℕ) (x_1 : ℕ) ↦ x < x_1) (↑t) (d :: ds) :\n                            Prop))=:(List.Forall₂ (fun (x : ℕ) (x_1 : ℕ) ↦ x < x_1) (i :: is) (d :: ds) : Prop) =\n                      (List.Forall₂ (fun (x : ℕ) (x_1 : ℕ) ↦ x < x_1) (↑t) (d :: ds) : Prop))\n                  (Subtype.property\n                      t=:List.Forall₂ (fun (x : ℕ) (x_1 : ℕ) ↦ x < x_1) (↑t)\n                      (d :: ds))=:List.Forall₂ (fun (x : ℕ) (x_1 : ℕ) ↦ x < x_1) (i :: is) (d :: ds)))) }),\n    p t :\n  Prop)", "type": "∀ {d : ℕ} {ds : List ℕ} (p : (a : HolorIndex (d :: ds)) → Prop) (x : HolorIndex (d :: ds))\n  (x_1 :\n    ∀ (i : ℕ) (is : List ℕ) (h : ↑x = i :: is),\n      p\n        { val := ((i :: is)),\n          property :=\n            (((Eq.mpr\n              (id ((Eq.symm h) ▸ (Eq.refl (List.Forall₂ (fun (x : ℕ) (x_1 : ℕ) ↦ x < x_1) (i :: is) (d :: ds)))))\n              (Subtype.property x)))) }),\n  p x", "thm": " : ∀ {d : ℕ} {ds : List ℕ} (p : (a : HolorIndex (d :: ds)) → Prop) (x : HolorIndex (d :: ds))\n  (x_1 :\n    ∀ (i : ℕ) (is : List ℕ) (h : ↑x = i :: is),\n      p\n        { val := ((i :: is)),\n          property :=\n            (((Eq.mpr\n              (id ((Eq.symm h) ▸ (Eq.refl (List.Forall₂ (fun (x : ℕ) (x_1 : ℕ) ↦ x < x_1) (i :: is) (d :: ds)))))\n              (Subtype.property x)))) }),\n  p x", "terms": [], "namedLemmas": ["∀ {a b : Prop}, (a ↔ b) → a → b", "∀ {α : Type u_2} {β : Type u_1} {R : α → β → Prop} {l : List β}, List.Forall₂ R [] l ↔ l = []", "∀ {α : Type u_1} (a : α) (l : List α), a :: l ≠ []", "∀ {α : Sort u} {a : α}, a = a"], "lemmas": [{"prop": "(List.Forall₂ (fun (x : ℕ) (x_2 : ℕ) ↦ x < x_2) [] (d :: ds)) ↔ (d :: ds = [])", "context": ["{d : ℕ}", "{ds : List ℕ}", "(p : (a : HolorIndex (d :: ds)) → Prop)", "(x : HolorIndex (d :: ds))", "(x_1 : ∀ (i : ℕ) (is : List ℕ) (h : ↑x = i :: is),\n  p\n    { val := ((i :: is)),\n      property :=\n        (((Eq.mpr (id ((Eq.symm h) ▸ (Eq.refl (List.Forall₂ (fun (x : ℕ) (x_1 : ℕ) ↦ x < x_1) (i :: is) (d :: ds)))))\n          (Subtype.property x)))) })", "(hforall₂ : List.Forall₂ (fun (x : ℕ) (x_2 : ℕ) ↦ x < x_2) [] (d :: ds))", "(x : ∀ (i : ℕ) (is : List ℕ) (h : ↑{ val := (([])), property := ((hforall₂)) } = i :: is),\n  p\n    { val := ((i :: is)),\n      property :=\n        (((Eq.mpr (id ((Eq.symm h) ▸ (Eq.refl (List.Forall₂ (fun (x : ℕ) (x_2 : ℕ) ↦ x < x_2) (i :: is) (d :: ds)))))\n          (Subtype.property { val := (([])), property := ((hforall₂)) })))) })"]}, {"prop": "d :: ds = []", "context": ["{d : ℕ}", "{ds : List ℕ}", "(p : (a : HolorIndex (d :: ds)) → Prop)", "(x : HolorIndex (d :: ds))", "(x_1 : ∀ (i : ℕ) (is : List ℕ) (h : ↑x = i :: is),\n  p\n    { val := ((i :: is)),\n      property :=\n        (((Eq.mpr (id ((Eq.symm h) ▸ (Eq.refl (List.Forall₂ (fun (x : ℕ) (x_1 : ℕ) ↦ x < x_1) (i :: is) (d :: ds)))))\n          (Subtype.property x)))) })", "(hforall₂ : List.Forall₂ (fun (x : ℕ) (x_2 : ℕ) ↦ x < x_2) [] (d :: ds))", "(x : ∀ (i : ℕ) (is : List ℕ) (h : ↑{ val := (([])), property := ((hforall₂)) } = i :: is),\n  p\n    { val := ((i :: is)),\n      property :=\n        (((Eq.mpr (id ((Eq.symm h) ▸ (Eq.refl (List.Forall₂ (fun (x : ℕ) (x_2 : ℕ) ↦ x < x_2) (i :: is) (d :: ds)))))\n          (Subtype.property { val := (([])), property := ((hforall₂)) })))) })"]}, {"prop": "d :: ds ≠ []", "context": ["{d : ℕ}", "{ds : List ℕ}", "(p : (a : HolorIndex (d :: ds)) → Prop)", "(x : HolorIndex (d :: ds))", "(x_1 : ∀ (i : ℕ) (is : List ℕ) (h : ↑x = i :: is),\n  p\n    { val := ((i :: is)),\n      property :=\n        (((Eq.mpr (id ((Eq.symm h) ▸ (Eq.refl (List.Forall₂ (fun (x : ℕ) (x_1 : ℕ) ↦ x < x_1) (i :: is) (d :: ds)))))\n          (Subtype.property x)))) })", "(hforall₂ : List.Forall₂ (fun (x : ℕ) (x_2 : ℕ) ↦ x < x_2) [] (d :: ds))", "(x : ∀ (i : ℕ) (is : List ℕ) (h : ↑{ val := (([])), property := ((hforall₂)) } = i :: is),\n  p\n    { val := ((i :: is)),\n      property :=\n        (((Eq.mpr (id ((Eq.symm h) ▸ (Eq.refl (List.Forall₂ (fun (x : ℕ) (x_2 : ℕ) ↦ x < x_2) (i :: is) (d :: ds)))))\n          (Subtype.property { val := (([])), property := ((hforall₂)) })))) })"]}, {"prop": "∀ (hforall₂ : List.Forall₂ (fun (x : ℕ) (x_2 : ℕ) ↦ x < x_2) [] (d :: ds))\n  (x :\n    ∀ (i : ℕ) (is : List ℕ) (h : ↑{ val := (([])), property := ((hforall₂)) } = i :: is),\n      p\n        { val := ((i :: is)),\n          property :=\n            (((Eq.mpr\n              (id ((Eq.symm h) ▸ (Eq.refl (List.Forall₂ (fun (x : ℕ) (x_2 : ℕ) ↦ x < x_2) (i :: is) (d :: ds)))))\n              (Subtype.property { val := (([])), property := ((hforall₂)) })))) }),\n  p { val := (([])), property := ((hforall₂)) }", "context": ["{d : ℕ}", "{ds : List ℕ}", "(p : (a : HolorIndex (d :: ds)) → Prop)", "(x : HolorIndex (d :: ds))", "(x_1 : ∀ (i : ℕ) (is : List ℕ) (h : ↑x = i :: is),\n  p\n    { val := ((i :: is)),\n      property :=\n        (((Eq.mpr (id ((Eq.symm h) ▸ (Eq.refl (List.Forall₂ (fun (x : ℕ) (x_1 : ℕ) ↦ x < x_1) (i :: is) (d :: ds)))))\n          (Subtype.property x)))) })"]}, {"prop": "↑{ val := ((i :: is)), property := ((property)) } = ↑{ val := ((i :: is)), property := ((property)) }", "context": ["{d : ℕ}", "{ds : List ℕ}", "(p : (a : HolorIndex (d :: ds)) → Prop)", "(x : HolorIndex (d :: ds))", "(x_1 : ∀ (i : ℕ) (is : List ℕ) (h : ↑x = i :: is),\n  p\n    { val := ((i :: is)),\n      property :=\n        (((Eq.mpr (id ((Eq.symm h) ▸ (Eq.refl (List.Forall₂ (fun (x : ℕ) (x_1 : ℕ) ↦ x < x_1) (i :: is) (d :: ds)))))\n          (Subtype.property x)))) })", "(i : ℕ)", "(is : List ℕ)", "(property : List.Forall₂ (fun (x : ℕ) (x_2 : ℕ) ↦ x < x_2) (i :: is) (d :: ds))", "(hp : ∀ (i_1 : ℕ) (is_1 : List ℕ) (h : ↑{ val := ((i :: is)), property := ((property)) } = i_1 :: is_1),\n  p\n    { val := ((i_1 :: is_1)),\n      property :=\n        (((Eq.mpr\n          (id ((Eq.symm h) ▸ (Eq.refl (List.Forall₂ (fun (x : ℕ) (x_2 : ℕ) ↦ x < x_2) (i_1 :: is_1) (d :: ds)))))\n          (Subtype.property { val := ((i :: is)), property := ((property)) })))) })"]}, {"prop": "∀ (i : ℕ) (is : List ℕ) (property : List.Forall₂ (fun (x : ℕ) (x_2 : ℕ) ↦ x < x_2) (i :: is) (d :: ds))\n  (hp :\n    ∀ (i_1 : ℕ) (is_1 : List ℕ) (h : ↑{ val := ((i :: is)), property := ((property)) } = i_1 :: is_1),\n      p\n        { val := ((i_1 :: is_1)),\n          property :=\n            (((Eq.mpr\n              (id ((Eq.symm h) ▸ (Eq.refl (List.Forall₂ (fun (x : ℕ) (x_2 : ℕ) ↦ x < x_2) (i_1 :: is_1) (d :: ds)))))\n              (Subtype.property { val := ((i :: is)), property := ((property)) })))) }),\n  p\n    { val := ((i :: is)),\n      property :=\n        (((Eq.mpr (id ((Eq.symm rfl) ▸ (Eq.refl (List.Forall₂ (fun (x : ℕ) (x_2 : ℕ) ↦ x < x_2) (i :: is) (d :: ds)))))\n          (Subtype.property { val := ((i :: is)), property := ((property)) })))) }", "context": ["{d : ℕ}", "{ds : List ℕ}", "(p : (a : HolorIndex (d :: ds)) → Prop)", "(x : HolorIndex (d :: ds))", "(x_1 : ∀ (i : ℕ) (is : List ℕ) (h : ↑x = i :: is),\n  p\n    { val := ((i :: is)),\n      property :=\n        (((Eq.mpr (id ((Eq.symm h) ▸ (Eq.refl (List.Forall₂ (fun (x : ℕ) (x_1 : ℕ) ↦ x < x_1) (i :: is) (d :: ds)))))\n          (Subtype.property x)))) })"]}], "ids": ["Holor.holor_index_cons_decomp.match_1", "absurd", "Iff.mp", "List.forall₂_nil_left_iff", "List.cons_ne_nil", "rfl"], "idString": "Holor.holor_index_cons_decomp.match_1; absurd; Iff.mp; List.forall₂_nil_left_iff; List.cons_ne_nil; rfl; ", "context": []}
{"typeGroup": "(∀ {L : FirstOrder.Language} {ι : Type u_1} [inst : Preorder ι] (G : (a : ι) → Type u_2)\n    [inst_1 : (i : ι) → FirstOrder.Language.Structure L (G i)]\n    (f : (i : ι) → (j : ι) → (a : i ≤ j) → FirstOrder.Language.Embedding L (G i) (G j))\n    [inst_2 : IsDirected ι fun (x : ι) (x_1 : ι) ↦ x ≤ x_1] [inst_3 : Nonempty ι] {n : ℕ}\n    (x : (a : Fin n) → FirstOrder.Language.Structure.Sigma f),\n    Classical.choose\n        (Fintype.bddAbove_range fun (a : Fin n) ↦\n            Sigma.fst (x a)=:BddAbove (Set.range fun (a : Fin n) ↦ Sigma.fst (x a))) ∈\n      upperBounds (Set.range fun (a : Fin n) ↦ Sigma.fst (x a)) :\n  Prop)", "type": "∀ {L : FirstOrder.Language} {ι : Type u_1} [inst : Preorder ι] (G : (a : ι) → Type u_2)\n  [inst_1 : (i : ι) → FirstOrder.Language.Structure L (G i)]\n  (f : (i : ι) → (j : ι) → (a : i ≤ j) → FirstOrder.Language.Embedding L (G i) (G j))\n  [inst_2 : IsDirected ι fun (x : ι) (x_1 : ι) ↦ x ≤ x_1] [inst_3 : Nonempty ι] {n : ℕ}\n  (x : (a : Fin n) → FirstOrder.Language.Structure.Sigma f),\n  Classical.choose (Fintype.bddAbove_range fun (a : Fin n) ↦ Sigma.fst (x a)) ∈\n    upperBounds (Set.range fun (a : Fin n) ↦ Sigma.fst (x a))", "thm": " : ∀ {L : FirstOrder.Language} {ι : Type u_1} [inst : Preorder ι] (G : (a : ι) → Type u_2)\n  [inst_1 : (i : ι) → FirstOrder.Language.Structure L (G i)]\n  (f : (i : ι) → (j : ι) → (a : i ≤ j) → FirstOrder.Language.Embedding L (G i) (G j))\n  [inst_2 : IsDirected ι fun (x : ι) (x_1 : ι) ↦ x ≤ x_1] [inst_3 : Nonempty ι] {n : ℕ}\n  (x : (a : Fin n) → FirstOrder.Language.Structure.Sigma f),\n  Classical.choose (Fintype.bddAbove_range fun (a : Fin n) ↦ Sigma.fst (x a)) ∈\n    upperBounds (Set.range fun (a : Fin n) ↦ Sigma.fst (x a))", "terms": [{"value": "x a", "isProp": false, "context": ["{L : FirstOrder.Language}", "{ι : Type u_1}", "[Preorder ι]", "(G : (a : ι) → Type u_2)", "[(i : ι) → FirstOrder.Language.Structure L (G i)]", "(f : (i : ι) → (j : ι) → (a : i ≤ j) → FirstOrder.Language.Embedding L (G i) (G j))", "[IsDirected ι fun (x : ι) (x_1 : ι) ↦ x ≤ x_1]", "[Nonempty ι]", "{n : ℕ}", "(x : (a : Fin n) → FirstOrder.Language.Structure.Sigma f)", "(a : Fin n)"]}], "namedLemmas": ["∀ {α : Sort u} {p : α → Prop} (h : ∃ x, p x), p (Classical.choose h)", "∀ {α : Type u_1} [inst : Nonempty α] [inst : Preorder α] [inst_1 : IsDirected α fun x x_1 => x ≤ x_1] {β : Type u_2}\n  [inst_2 : Fintype β] (f : β → α), BddAbove (Set.range f)"], "lemmas": [{"prop": "BddAbove (Set.range fun (a : Fin n) ↦ Sigma.fst (x a))", "context": ["{L : FirstOrder.Language}", "{ι : Type u_1}", "[Preorder ι]", "(G : (a : ι) → Type u_2)", "[(i : ι) → FirstOrder.Language.Structure L (G i)]", "(f : (i : ι) → (j : ι) → (a : i ≤ j) → FirstOrder.Language.Embedding L (G i) (G j))", "[IsDirected ι fun (x : ι) (x_1 : ι) ↦ x ≤ x_1]", "[Nonempty ι]", "{n : ℕ}", "(x : (a : Fin n) → FirstOrder.Language.Structure.Sigma f)"]}], "ids": ["Classical.choose_spec", "Fintype.bddAbove_range", "Sigma.fst"], "idString": "Classical.choose_spec; Fintype.bddAbove_range; Sigma.fst; ", "context": []}
{"typeGroup": "(∀ (G : Type u_2) (R : Type u_1) [inst : Group G] [inst_1 : Semiring R] [inst_2 : MulSemiringAction G R] (g : G)\n    (h : G),\n    OneHom.toFun\n        { toFun := ((MulSemiringAction.toRingEquiv G R)),\n          map_one' := (((RingEquiv.ext (one_smul G=:∀ (b : R), 1 • b = b)=:MulSemiringAction.toRingEquiv G R 1 = 1))) }\n        (g * h) =\n      OneHom.toFun\n          { toFun := ((MulSemiringAction.toRingEquiv G R)),\n            map_one' :=\n              (((RingEquiv.ext (one_smul G=:∀ (b : R), 1 • b = b)=:MulSemiringAction.toRingEquiv G R 1 = 1))) }\n          g *\n        OneHom.toFun\n          { toFun := ((MulSemiringAction.toRingEquiv G R)),\n            map_one' :=\n              (((RingEquiv.ext (one_smul G=:∀ (b : R), 1 • b = b)=:MulSemiringAction.toRingEquiv G R 1 = 1))) }\n          h :\n  Prop)", "type": "∀ (G : Type u_2) (R : Type u_1) [inst : Group G] [inst_1 : Semiring R] [inst_2 : MulSemiringAction G R] (g : G) (h : G),\n  OneHom.toFun { toFun := ((MulSemiringAction.toRingEquiv G R)), map_one' := (((RingEquiv.ext (one_smul G)))) }\n      (g * h) =\n    OneHom.toFun { toFun := ((MulSemiringAction.toRingEquiv G R)), map_one' := (((RingEquiv.ext (one_smul G)))) } g *\n      OneHom.toFun { toFun := ((MulSemiringAction.toRingEquiv G R)), map_one' := (((RingEquiv.ext (one_smul G)))) } h", "thm": " : ∀ (G : Type u_2) (R : Type u_1) [inst : Group G] [inst_1 : Semiring R] [inst_2 : MulSemiringAction G R] (g : G) (h : G),\n  OneHom.toFun { toFun := ((MulSemiringAction.toRingEquiv G R)), map_one' := (((RingEquiv.ext (one_smul G)))) }\n      (g * h) =\n    OneHom.toFun { toFun := ((MulSemiringAction.toRingEquiv G R)), map_one' := (((RingEquiv.ext (one_smul G)))) } g *\n      OneHom.toFun { toFun := ((MulSemiringAction.toRingEquiv G R)), map_one' := (((RingEquiv.ext (one_smul G)))) } h", "terms": [], "namedLemmas": ["∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] {f g : R ≃+* S},\n  (∀ (x : R), ↑f x = ↑g x) → f = g", "∀ {α : Type u_1} {β : Type u_2} [inst : Monoid α] [self : MulAction α β] (x y : α) (b : β), (x * y) • b = x • y • b"], "lemmas": [{"prop": "∀ (b : R), (g * h) • b = g • h • b", "context": ["(G : Type u_2)", "(R : Type u_1)", "[Group G]", "[Semiring R]", "[MulSemiringAction G R]", "(g : G)", "(h : G)"]}], "ids": ["RingEquiv.ext", "mul_smul"], "idString": "RingEquiv.ext; mul_smul; ", "context": []}
{"typeGroup": "(∀ {R : Type u_2} [inst : Rack R] {G : Type u_1} [inst_1 : Group G] (f : ShelfHom R (Quandle.Conj G)),\n    Quotient.liftOn (Quotient.mk (Rack.PreEnvelGroup.setoid R) Rack.PreEnvelGroup.unit) (Rack.toEnvelGroup.mapAux f)\n        (fun (a : Rack.PreEnvelGroup R) ↦\n          (_ :\n            ∀ (b : Rack.PreEnvelGroup R) (x : a ≈ b),\n              Rack.toEnvelGroup.mapAux f a =\n                Rack.toEnvelGroup.mapAux f\n                  b)=:∀ (a : Rack.PreEnvelGroup R) (b : Rack.PreEnvelGroup R) (x : a ≈ b),\n            Rack.toEnvelGroup.mapAux f a = Rack.toEnvelGroup.mapAux f b) =\n      1 :\n  Prop)", "type": "∀ {R : Type u_2} [inst : Rack R] {G : Type u_1} [inst_1 : Group G] (f : ShelfHom R (Quandle.Conj G)),\n  Quotient.liftOn (Quotient.mk (Rack.PreEnvelGroup.setoid R) Rack.PreEnvelGroup.unit) (Rack.toEnvelGroup.mapAux f)\n      (fun (a : Rack.PreEnvelGroup R) (b : Rack.PreEnvelGroup R) (x : a ≈ b) ↦\n        Rack.instDivInvMonoidEnvelGroup.match_1 R a b\n          (fun (x : a ≈ b) ↦ Rack.toEnvelGroup.mapAux f a = Rack.toEnvelGroup.mapAux f b) x\n          (fun (hab : Rack.PreEnvelGroupRel' R a b) ↦ Rack.toEnvelGroup.mapAux.well_def f hab)) =\n    1", "thm": " : ∀ {R : Type u_2} [inst : Rack R] {G : Type u_1} [inst_1 : Group G] (f : ShelfHom R (Quandle.Conj G)),\n  Quotient.liftOn (Quotient.mk (Rack.PreEnvelGroup.setoid R) Rack.PreEnvelGroup.unit) (Rack.toEnvelGroup.mapAux f)\n      (fun (a : Rack.PreEnvelGroup R) (b : Rack.PreEnvelGroup R) (x : a ≈ b) ↦\n        Rack.instDivInvMonoidEnvelGroup.match_1 R a b\n          (fun (x : a ≈ b) ↦ Rack.toEnvelGroup.mapAux f a = Rack.toEnvelGroup.mapAux f b) x\n          (fun (hab : Rack.PreEnvelGroupRel' R a b) ↦ Rack.toEnvelGroup.mapAux.well_def f hab)) =\n    1", "terms": [], "namedLemmas": ["∀ {p : Prop}, p = True → p", "∀ {α : Sort u_1} (a : α), (a = a) = True"], "lemmas": [{"prop": "(1 = 1) = True", "context": ["{R : Type u_2}", "[Rack R]", "{G : Type u_1}", "[Group G]", "(f : ShelfHom R (Quandle.Conj G))"]}], "ids": ["of_eq_true", "eq_self"], "idString": "of_eq_true; eq_self; ", "context": []}
{"typeGroup": "(∀ {R : Type u_2} [inst : Rack R] {G : Type u_1} [inst_1 : Group G] (f : ShelfHom R (Quandle.Conj G)),\n    Quotient.liftOn (Quotient.mk (Rack.PreEnvelGroup.setoid R) Rack.PreEnvelGroup.unit) (Rack.toEnvelGroup.mapAux f)\n        (fun (a : Rack.PreEnvelGroup R) ↦\n          (_ :\n            ∀ (b : Rack.PreEnvelGroup R) (x : a ≈ b),\n              Rack.toEnvelGroup.mapAux f a =\n                Rack.toEnvelGroup.mapAux f\n                  b)=:∀ (a : Rack.PreEnvelGroup R) (b : Rack.PreEnvelGroup R) (x : a ≈ b),\n            Rack.toEnvelGroup.mapAux f a = Rack.toEnvelGroup.mapAux f b) =\n      1 :\n  Prop)", "type": "1 = 1", "thm": "{R : Type u_2} [Rack R] {G : Type u_1} [Group G] (f : ShelfHom R (Quandle.Conj G))  : 1 = 1", "terms": [], "namedLemmas": ["∀ {p : Prop}, p = True → p", "∀ {α : Sort u_1} (a : α), (a = a) = True"], "lemmas": [{"prop": "(1 = 1) = True", "context": ["{R : Type u_2}", "[Rack R]", "{G : Type u_1}", "[Group G]", "(f : ShelfHom R (Quandle.Conj G))"]}], "ids": ["of_eq_true", "eq_self"], "idString": "of_eq_true; eq_self; ", "context": ["{R : Type u_2}", "[Rack R]", "{G : Type u_1}", "[Group G]", "(f : ShelfHom R (Quandle.Conj G))"]}
{"typeGroup": "(∀ {α : Type u_1} [inst : MeasurableSpace α] (s : MeasureTheory.SignedMeasure α),\n    MeasurableSet\n      (Classical.choose\n        (MeasureTheory.SignedMeasure.exists_compl_positive_negative\n            s=:∃ (i : Set α),\n            (MeasurableSet i : Prop) ∧\n              ((MeasureTheory.VectorMeasure.restrict 0 i ≤ MeasureTheory.VectorMeasure.restrict s i : Prop) ∧\n                  (MeasureTheory.VectorMeasure.restrict s iᶜ ≤ MeasureTheory.VectorMeasure.restrict 0 iᶜ : Prop) :\n                Prop))) :\n  Prop)", "type": "∀ {α : Type u_1} [inst : MeasurableSpace α] (s : MeasureTheory.SignedMeasure α),\n  MeasurableSet (Classical.choose (MeasureTheory.SignedMeasure.exists_compl_positive_negative s))", "thm": " : ∀ {α : Type u_1} [inst : MeasurableSpace α] (s : MeasureTheory.SignedMeasure α),\n  MeasurableSet (Classical.choose (MeasureTheory.SignedMeasure.exists_compl_positive_negative s))", "terms": [], "namedLemmas": ["∀ {a b : Prop}, a ∧ b → a", "∀ {α : Type u_1} [inst : MeasurableSpace α] (s : MeasureTheory.SignedMeasure α),\n  MeasurableSet\n      (Classical.choose\n        (_ :\n          ∃ i,\n            MeasurableSet i ∧\n              MeasureTheory.VectorMeasure.restrict 0 i ≤ MeasureTheory.VectorMeasure.restrict s i ∧\n                MeasureTheory.VectorMeasure.restrict s iᶜ ≤ MeasureTheory.VectorMeasure.restrict 0 iᶜ)) ∧\n    MeasureTheory.VectorMeasure.restrict 0\n          (Classical.choose\n            (_ :\n              ∃ i,\n                MeasurableSet i ∧\n                  MeasureTheory.VectorMeasure.restrict 0 i ≤ MeasureTheory.VectorMeasure.restrict s i ∧\n                    MeasureTheory.VectorMeasure.restrict s iᶜ ≤ MeasureTheory.VectorMeasure.restrict 0 iᶜ)) ≤\n        MeasureTheory.VectorMeasure.restrict s\n          (Classical.choose\n            (_ :\n              ∃ i,\n                MeasurableSet i ∧\n                  MeasureTheory.VectorMeasure.restrict 0 i ≤ MeasureTheory.VectorMeasure.restrict s i ∧\n                    MeasureTheory.VectorMeasure.restrict s iᶜ ≤ MeasureTheory.VectorMeasure.restrict 0 iᶜ)) ∧\n      MeasureTheory.VectorMeasure.restrict s\n          (Classical.choose\n              (_ :\n                ∃ i,\n                  MeasurableSet i ∧\n                    MeasureTheory.VectorMeasure.restrict 0 i ≤ MeasureTheory.VectorMeasure.restrict s i ∧\n                      MeasureTheory.VectorMeasure.restrict s iᶜ ≤ MeasureTheory.VectorMeasure.restrict 0 iᶜ))ᶜ ≤\n        MeasureTheory.VectorMeasure.restrict 0\n          (Classical.choose\n              (_ :\n                ∃ i,\n                  MeasurableSet i ∧\n                    MeasureTheory.VectorMeasure.restrict 0 i ≤ MeasureTheory.VectorMeasure.restrict s i ∧\n                      MeasureTheory.VectorMeasure.restrict s iᶜ ≤ MeasureTheory.VectorMeasure.restrict 0 iᶜ))ᶜ"], "lemmas": [{"prop": "(MeasurableSet (Classical.choose (MeasureTheory.SignedMeasure.exists_compl_positive_negative s))) ∧\n  ((MeasureTheory.VectorMeasure.restrict 0\n        (Classical.choose (MeasureTheory.SignedMeasure.exists_compl_positive_negative s)) ≤\n      MeasureTheory.VectorMeasure.restrict s\n        (Classical.choose (MeasureTheory.SignedMeasure.exists_compl_positive_negative s))) ∧\n    (MeasureTheory.VectorMeasure.restrict s\n        (Classical.choose (MeasureTheory.SignedMeasure.exists_compl_positive_negative s))ᶜ ≤\n      MeasureTheory.VectorMeasure.restrict 0\n        (Classical.choose (MeasureTheory.SignedMeasure.exists_compl_positive_negative s))ᶜ))", "context": ["{α : Type u_1}", "[MeasurableSpace α]", "(s : MeasureTheory.SignedMeasure α)"]}], "ids": ["And.left", "MeasureTheory.SignedMeasure.toJordanDecomposition.proof_1"], "idString": "And.left; MeasureTheory.SignedMeasure.toJordanDecomposition.proof_1; ", "context": []}
{"typeGroup": "(∀ {C : Type u₁} [inst : CategoryTheory.Category C] {P : CategoryTheory.Functor Cᵒᵖ (Type w)} {X : C} {Y : C}\n    (S : CategoryTheory.Sieve X) {x : CategoryTheory.Presieve.FamilyOfElements P S.arrows}\n    (t : CategoryTheory.Presieve.FamilyOfElements.Compatible x) {f : Y ⟶ X} (hf : S.arrows f) {Z : C} (g : Z ⟶ Y),\n    x (CategoryTheory.CategoryStruct.comp g f)\n        (CategoryTheory.Sieve.downward_closed S hf g=:S.arrows (CategoryTheory.CategoryStruct.comp g f)) =\n      (CategoryTheory.Functor.toPrefunctor P).map g.op (x f hf) :\n  Prop)", "type": "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {P : CategoryTheory.Functor Cᵒᵖ (Type w)} {X : C} {Y : C}\n  (S : CategoryTheory.Sieve X) {x : CategoryTheory.Presieve.FamilyOfElements P S.arrows}\n  (t : CategoryTheory.Presieve.FamilyOfElements.Compatible x) {f : Y ⟶ X} (hf : S.arrows f) {Z : C} (g : Z ⟶ Y),\n  x (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.Sieve.downward_closed S hf g) =\n    (CategoryTheory.Functor.toPrefunctor P).map g.op (x f hf)", "thm": " : ∀ {C : Type u₁} [inst : CategoryTheory.Category C] {P : CategoryTheory.Functor Cᵒᵖ (Type w)} {X : C} {Y : C}\n  (S : CategoryTheory.Sieve X) {x : CategoryTheory.Presieve.FamilyOfElements P S.arrows}\n  (t : CategoryTheory.Presieve.FamilyOfElements.Compatible x) {f : Y ⟶ X} (hf : S.arrows f) {Z : C} (g : Z ⟶ Y),\n  x (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.Sieve.downward_closed S hf g) =\n    (CategoryTheory.Functor.toPrefunctor P).map g.op (x f hf)", "terms": [{"value": "CategoryTheory.CategoryStruct.comp g f", "isProp": false, "context": ["{C : Type u₁}", "[CategoryTheory.Category C]", "{P : CategoryTheory.Functor Cᵒᵖ (Type w)}", "{X : C}", "{Y : C}", "(S : CategoryTheory.Sieve X)", "{x : CategoryTheory.Presieve.FamilyOfElements P S.arrows}", "(t : CategoryTheory.Presieve.FamilyOfElements.Compatible x)", "{f : Y ⟶ X}", "(hf : S.arrows f)", "{Z : C}", "(g : Z ⟶ Y)"]}, {"value": "x (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.Sieve.downward_closed S hf g)", "isProp": false, "context": ["{C : Type u₁}", "[CategoryTheory.Category C]", "{P : CategoryTheory.Functor Cᵒᵖ (Type w)}", "{X : C}", "{Y : C}", "(S : CategoryTheory.Sieve X)", "{x : CategoryTheory.Presieve.FamilyOfElements P S.arrows}", "(t : CategoryTheory.Presieve.FamilyOfElements.Compatible x)", "{f : Y ⟶ X}", "(hf : S.arrows f)", "{Z : C}", "(g : Z ⟶ Y)"]}, {"value": "g.op", "isProp": false, "context": ["{C : Type u₁}", "[CategoryTheory.Category C]", "{P : CategoryTheory.Functor Cᵒᵖ (Type w)}", "{X : C}", "{Y : C}", "(S : CategoryTheory.Sieve X)", "{x : CategoryTheory.Presieve.FamilyOfElements P S.arrows}", "(t : CategoryTheory.Presieve.FamilyOfElements.Compatible x)", "{f : Y ⟶ X}", "(hf : S.arrows f)", "{Z : C}", "(g : Z ⟶ Y)"]}, {"value": "x f hf", "isProp": false, "context": ["{C : Type u₁}", "[CategoryTheory.Category C]", "{P : CategoryTheory.Functor Cᵒᵖ (Type w)}", "{X : C}", "{Y : C}", "(S : CategoryTheory.Sieve X)", "{x : CategoryTheory.Presieve.FamilyOfElements P S.arrows}", "(t : CategoryTheory.Presieve.FamilyOfElements.Compatible x)", "{f : Y ⟶ X}", "(hf : S.arrows f)", "{Z : C}", "(g : Z ⟶ Y)"]}, {"value": "(CategoryTheory.Functor.toPrefunctor P).map g.op (x f hf)", "isProp": false, "context": ["{C : Type u₁}", "[CategoryTheory.Category C]", "{P : CategoryTheory.Functor Cᵒᵖ (Type w)}", "{X : C}", "{Y : C}", "(S : CategoryTheory.Sieve X)", "{x : CategoryTheory.Presieve.FamilyOfElements P S.arrows}", "(t : CategoryTheory.Presieve.FamilyOfElements.Compatible x)", "{f : Y ⟶ X}", "(hf : S.arrows f)", "{Z : C}", "(g : Z ⟶ Y)"]}, {"value": "CategoryTheory.CategoryStruct.id Z", "isProp": false, "context": ["{C : Type u₁}", "[CategoryTheory.Category C]", "{P : CategoryTheory.Functor Cᵒᵖ (Type w)}", "{X : C}", "{Y : C}", "(S : CategoryTheory.Sieve X)", "{x : CategoryTheory.Presieve.FamilyOfElements P S.arrows}", "(t : CategoryTheory.Presieve.FamilyOfElements.Compatible x)", "{f : Y ⟶ X}", "(hf : S.arrows f)", "{Z : C}", "(g : Z ⟶ Y)"]}], "namedLemmas": ["∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {C : Type u} [inst : CategoryTheory.Category C] (F : CategoryTheory.Functor C (Type w)) {X : C} (a : F.obj X),\n  F.map (CategoryTheory.CategoryStruct.id X) a = a", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X : C} (self : CategoryTheory.Sieve X) {Y Z : C} {f : Y ⟶ X},\n  self.arrows f → ∀ (g : Z ⟶ Y), self.arrows (CategoryTheory.CategoryStruct.comp g f)", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X : C} (self : CategoryTheory.Sieve X) {Y Z : C} {f : Y ⟶ X},\n  self.arrows f → ∀ (g : Z ⟶ Y), self.arrows (CategoryTheory.CategoryStruct.comp g f)", "∀ {obj : Type u} [self : CategoryTheory.Category obj] {X Y : obj} (f : X ⟶ Y),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id X) f = f"], "lemmas": [{"prop": "S.arrows (CategoryTheory.CategoryStruct.comp g f)", "context": ["{C : Type u₁}", "[CategoryTheory.Category C]", "{P : CategoryTheory.Functor Cᵒᵖ (Type w)}", "{X : C}", "{Y : C}", "(S : CategoryTheory.Sieve X)", "{x : CategoryTheory.Presieve.FamilyOfElements P S.arrows}", "(t : CategoryTheory.Presieve.FamilyOfElements.Compatible x)", "{f : Y ⟶ X}", "(hf : S.arrows f)", "{Z : C}", "(g : Z ⟶ Y)"]}, {"prop": "(CategoryTheory.Functor.toPrefunctor P).map (CategoryTheory.CategoryStruct.id (Opposite.op Z))\n    (x (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.Sieve.downward_closed S hf g)) =\n  x (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.Sieve.downward_closed S hf g)", "context": ["{C : Type u₁}", "[CategoryTheory.Category C]", "{P : CategoryTheory.Functor Cᵒᵖ (Type w)}", "{X : C}", "{Y : C}", "(S : CategoryTheory.Sieve X)", "{x : CategoryTheory.Presieve.FamilyOfElements P S.arrows}", "(t : CategoryTheory.Presieve.FamilyOfElements.Compatible x)", "{f : Y ⟶ X}", "(hf : S.arrows f)", "{Z : C}", "(g : Z ⟶ Y)"]}, {"prop": "Eq\n    ((CategoryTheory.Functor.toPrefunctor P).map (CategoryTheory.CategoryStruct.id (Opposite.op Z))\n      (x (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.Sieve.downward_closed S hf g))) =\n  Eq (x (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.Sieve.downward_closed S hf g))", "context": ["{C : Type u₁}", "[CategoryTheory.Category C]", "{P : CategoryTheory.Functor Cᵒᵖ (Type w)}", "{X : C}", "{Y : C}", "(S : CategoryTheory.Sieve X)", "{x : CategoryTheory.Presieve.FamilyOfElements P S.arrows}", "(t : CategoryTheory.Presieve.FamilyOfElements.Compatible x)", "{f : Y ⟶ X}", "(hf : S.arrows f)", "{Z : C}", "(g : Z ⟶ Y)"]}, {"prop": "((CategoryTheory.Functor.toPrefunctor P).map (CategoryTheory.CategoryStruct.id (Opposite.op Z))\n      (x (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.Sieve.downward_closed S hf g)) =\n    (CategoryTheory.Functor.toPrefunctor P).map g.op (x f hf)) =\n  (x (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.Sieve.downward_closed S hf g) =\n    (CategoryTheory.Functor.toPrefunctor P).map g.op (x f hf))", "context": ["{C : Type u₁}", "[CategoryTheory.Category C]", "{P : CategoryTheory.Functor Cᵒᵖ (Type w)}", "{X : C}", "{Y : C}", "(S : CategoryTheory.Sieve X)", "{x : CategoryTheory.Presieve.FamilyOfElements P S.arrows}", "(t : CategoryTheory.Presieve.FamilyOfElements.Compatible x)", "{f : Y ⟶ X}", "(hf : S.arrows f)", "{Z : C}", "(g : Z ⟶ Y)"]}, {"prop": "S.arrows (CategoryTheory.CategoryStruct.comp g f)", "context": ["{C : Type u₁}", "[CategoryTheory.Category C]", "{P : CategoryTheory.Functor Cᵒᵖ (Type w)}", "{X : C}", "{Y : C}", "(S : CategoryTheory.Sieve X)", "{x : CategoryTheory.Presieve.FamilyOfElements P S.arrows}", "(t : CategoryTheory.Presieve.FamilyOfElements.Compatible x)", "{f : Y ⟶ X}", "(hf : S.arrows f)", "{Z : C}", "(g : Z ⟶ Y)"]}, {"prop": "CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id Z) (CategoryTheory.CategoryStruct.comp g f) =\n  CategoryTheory.CategoryStruct.comp g f", "context": ["{C : Type u₁}", "[CategoryTheory.Category C]", "{P : CategoryTheory.Functor Cᵒᵖ (Type w)}", "{X : C}", "{Y : C}", "(S : CategoryTheory.Sieve X)", "{x : CategoryTheory.Presieve.FamilyOfElements P S.arrows}", "(t : CategoryTheory.Presieve.FamilyOfElements.Compatible x)", "{f : Y ⟶ X}", "(hf : S.arrows f)", "{Z : C}", "(g : Z ⟶ Y)"]}, {"prop": "(CategoryTheory.Functor.toPrefunctor P).map (CategoryTheory.CategoryStruct.id Z).op\n    (x (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.Sieve.downward_closed S hf g)) =\n  (CategoryTheory.Functor.toPrefunctor P).map g.op (x f hf)", "context": ["{C : Type u₁}", "[CategoryTheory.Category C]", "{P : CategoryTheory.Functor Cᵒᵖ (Type w)}", "{X : C}", "{Y : C}", "(S : CategoryTheory.Sieve X)", "{x : CategoryTheory.Presieve.FamilyOfElements P S.arrows}", "(t : CategoryTheory.Presieve.FamilyOfElements.Compatible x)", "{f : Y ⟶ X}", "(hf : S.arrows f)", "{Z : C}", "(g : Z ⟶ Y)"]}], "ids": ["Eq.mp", "congrFun", "congrArg", "Eq", "CategoryTheory.FunctorToTypes.map_id_apply", "CategoryTheory.CategoryStruct.comp", "CategoryTheory.Sieve.downward_closed", "CategoryTheory.Functor.toPrefunctor", "map", "op", "CategoryTheory.CategoryStruct.id", "CategoryTheory.Sieve.downward_closed", "CategoryTheory.Category.id_comp", "CategoryTheory.CategoryStruct.comp"], "idString": "Eq.mp; congrFun; congrArg; Eq; CategoryTheory.FunctorToTypes.map_id_apply; CategoryTheory.CategoryStruct.comp; CategoryTheory.Sieve.downward_closed; CategoryTheory.Functor.toPrefunctor; map; op; CategoryTheory.CategoryStruct.id; CategoryTheory.Sieve.downward_closed; CategoryTheory.Category.id_comp; CategoryTheory.CategoryStruct.comp; ", "context": []}
{"typeGroup": "(∀ {G : Type u_1} [inst : AddGroup G] {x : G} {p : (a : { x_1 : G // x_1 ∈ AddSubgroup.zmultiples x }) → Prop},\n    (∃ (g : { x_1 : G // x_1 ∈ AddSubgroup.zmultiples x }), p g : Prop) ↔\n      (∃ (m : ℤ),\n          p\n            { val := ((m • x)),\n              property :=\n                (((Exists.intro m\n                    (rfl=:(fun (x : G) (x_1 : ℤ) ↦ x_1 • x) x m =\n                        (fun (x : G) (x_1 : ℤ) ↦ x_1 • x) x\n                          m)=:∃ (y : ℤ), (fun (x : G) (x_1 : ℤ) ↦ x_1 • x) x y = m • x))) } :\n        Prop) :\n  Prop)", "type": "∀ {G : Type u_1} [inst : AddGroup G] {x : G} {p : (a : { x_1 : G // x_1 ∈ AddSubgroup.zmultiples x }) → Prop},\n  (∃ (a : ↑(Set.range fun (y : ℤ) ↦ (fun (x : G) (x_1 : ℤ) ↦ x_1 • x) x y)), p a) ↔\n    (∃ (i : ℤ), p { val := (((fun (x : G) (x_1 : ℤ) ↦ x_1 • x) x i)), property := (((Set.mem_range_self i))) })", "thm": " : ∀ {G : Type u_1} [inst : AddGroup G] {x : G} {p : (a : { x_1 : G // x_1 ∈ AddSubgroup.zmultiples x }) → Prop},\n  (∃ (a : ↑(Set.range fun (y : ℤ) ↦ (fun (x : G) (x_1 : ℤ) ↦ x_1 • x) x y)), p a) ↔\n    (∃ (i : ℤ), p { val := (((fun (x : G) (x_1 : ℤ) ↦ x_1 • x) x i)), property := (((Set.mem_range_self i))) })", "terms": [], "namedLemmas": ["∀ {α : Type u_1} {ι : Sort u_2} {f : ι → α} {p : ↑(Set.range f) → Prop},\n  (∃ a, p a) ↔ ∃ i, p { val := f i, property := (_ : f i ∈ Set.range f) }"], "lemmas": [], "ids": ["Set.exists_subtype_range_iff"], "idString": "Set.exists_subtype_range_iff; ", "context": []}
{"typeGroup": "(∀ {X : TopCat} (U : TopologicalSpace.Opens ↑X) (V : TopologicalSpace.Opens ↑X) (x : ↑X) (m : x ∈ U ⊓ V),\n    (fun (x : { x : ↑X // x ∈ U ⊓ V }) ↦\n          { val := ((↑x)),\n            property :=\n              (((TopologicalSpace.Opens.opensHomHasCoeToFun.proof_1 (TopologicalSpace.Opens.infLELeft U V)\n                  x=:↑x ∈ ↑U))) })\n        { val := ((x)), property := ((m)) } =\n      { val := ((x)), property := (((inf_le_left m=:x ∈ ↑U))) } :\n  Prop)", "type": "∀ {X : TopCat} (U : TopologicalSpace.Opens ↑X) (V : TopologicalSpace.Opens ↑X) (x : ↑X) (m : x ∈ U ⊓ V),\n  (fun (x : { x : ↑X // x ∈ U ⊓ V }) ↦\n        { val := ((↑x)),\n          property :=\n            (((TopologicalSpace.Opens.opensHomHasCoeToFun.proof_1 (TopologicalSpace.Opens.infLELeft U V) x))) })\n      { val := ((x)), property := ((m)) } =\n    (fun (x : { x : ↑X // x ∈ U ⊓ V }) ↦\n        { val := ((↑x)),\n          property :=\n            (((TopologicalSpace.Opens.opensHomHasCoeToFun.proof_1 (TopologicalSpace.Opens.infLELeft U V) x))) })\n      { val := ((x)), property := ((m)) }", "thm": " : ∀ {X : TopCat} (U : TopologicalSpace.Opens ↑X) (V : TopologicalSpace.Opens ↑X) (x : ↑X) (m : x ∈ U ⊓ V),\n  (fun (x : { x : ↑X // x ∈ U ⊓ V }) ↦\n        { val := ((↑x)),\n          property :=\n            (((TopologicalSpace.Opens.opensHomHasCoeToFun.proof_1 (TopologicalSpace.Opens.infLELeft U V) x))) })\n      { val := ((x)), property := ((m)) } =\n    (fun (x : { x : ↑X // x ∈ U ⊓ V }) ↦\n        { val := ((↑x)),\n          property :=\n            (((TopologicalSpace.Opens.opensHomHasCoeToFun.proof_1 (TopologicalSpace.Opens.infLELeft U V) x))) })\n      { val := ((x)), property := ((m)) }", "terms": [], "namedLemmas": ["∀ {α : Sort u} {a : α}, a = a"], "lemmas": [], "ids": ["rfl"], "idString": "rfl; ", "context": []}
{"typeGroup": "(∀ (𝕜 : Type u_1) {ι : Type u_2} (E : (a : ι) → Type u_3) [inst : Fintype ι] [inst_1 : NontriviallyNormedField 𝕜]\n    [inst_2 : (i : ι) → NormedAddCommGroup (E i)] [inst_3 : (i : ι) → NormedSpace 𝕜 (E i)] {ι' : Type u_5}\n    [inst_4 : Fintype ι'] {E' : (a : ι') → Type u_4} [inst_5 : (i' : ι') → NormedAddCommGroup (E' i')]\n    [inst_6 : (i' : ι') → NormedSpace 𝕜 (E' i')] (x : 𝕜) (x_1 : (i' : ι') → ContinuousMultilinearMap 𝕜 E (E' i')),\n    AddHom.toFun\n        { toFun := ((Equiv.toFun ContinuousMultilinearMap.piEquiv)),\n          map_add' :=\n            (((fun (x : (i' : ι') → ContinuousMultilinearMap 𝕜 E (E' i')) ↦\n              (_ :\n                ∀ (x_2 : (i' : ι') → ContinuousMultilinearMap 𝕜 E (E' i')),\n                  Equiv.toFun ContinuousMultilinearMap.piEquiv (x + x_2) =\n                    Equiv.toFun ContinuousMultilinearMap.piEquiv\n                      (x +\n                        x_2))=:∀ (x : (i' : ι') → ContinuousMultilinearMap 𝕜 E (E' i'))\n                (x_2 : (i' : ι') → ContinuousMultilinearMap 𝕜 E (E' i')),\n                Equiv.toFun ContinuousMultilinearMap.piEquiv (x + x_2) =\n                  Equiv.toFun ContinuousMultilinearMap.piEquiv (x + x_2)))) }\n        (x • x_1) =\n      AddHom.toFun\n        { toFun := ((Equiv.toFun ContinuousMultilinearMap.piEquiv)),\n          map_add' :=\n            (((fun (x : (i' : ι') → ContinuousMultilinearMap 𝕜 E (E' i')) ↦\n              (_ :\n                ∀ (x_2 : (i' : ι') → ContinuousMultilinearMap 𝕜 E (E' i')),\n                  Equiv.toFun ContinuousMultilinearMap.piEquiv (x + x_2) =\n                    Equiv.toFun ContinuousMultilinearMap.piEquiv\n                      (x +\n                        x_2))=:∀ (x : (i' : ι') → ContinuousMultilinearMap 𝕜 E (E' i'))\n                (x_2 : (i' : ι') → ContinuousMultilinearMap 𝕜 E (E' i')),\n                Equiv.toFun ContinuousMultilinearMap.piEquiv (x + x_2) =\n                  Equiv.toFun ContinuousMultilinearMap.piEquiv (x + x_2)))) }\n        (x • x_1) :\n  Prop)", "type": "∀ (𝕜 : Type u_1) {ι : Type u_2} (E : (a : ι) → Type u_3) [inst : Fintype ι] [inst_1 : NontriviallyNormedField 𝕜]\n  [inst_2 : (i : ι) → NormedAddCommGroup (E i)] [inst_3 : (i : ι) → NormedSpace 𝕜 (E i)] {ι' : Type u_5}\n  [inst_4 : Fintype ι'] {E' : (a : ι') → Type u_4} [inst_5 : (i' : ι') → NormedAddCommGroup (E' i')]\n  [inst_6 : (i' : ι') → NormedSpace 𝕜 (E' i')] (x : 𝕜) (x_1 : (i' : ι') → ContinuousMultilinearMap 𝕜 E (E' i')),\n  AddHom.toFun\n      { toFun := ((Equiv.toFun ContinuousMultilinearMap.piEquiv)),\n        map_add' :=\n          (((fun (x : (i' : ι') → ContinuousMultilinearMap 𝕜 E (E' i'))\n              (x_2 : (i' : ι') → ContinuousMultilinearMap 𝕜 E (E' i')) ↦\n            rfl))) }\n      (x • x_1) =\n    AddHom.toFun\n      { toFun := ((Equiv.toFun ContinuousMultilinearMap.piEquiv)),\n        map_add' :=\n          (((fun (x : (i' : ι') → ContinuousMultilinearMap 𝕜 E (E' i'))\n              (x_2 : (i' : ι') → ContinuousMultilinearMap 𝕜 E (E' i')) ↦\n            rfl))) }\n      (x • x_1)", "thm": " : ∀ (𝕜 : Type u_1) {ι : Type u_2} (E : (a : ι) → Type u_3) [inst : Fintype ι] [inst_1 : NontriviallyNormedField 𝕜]\n  [inst_2 : (i : ι) → NormedAddCommGroup (E i)] [inst_3 : (i : ι) → NormedSpace 𝕜 (E i)] {ι' : Type u_5}\n  [inst_4 : Fintype ι'] {E' : (a : ι') → Type u_4} [inst_5 : (i' : ι') → NormedAddCommGroup (E' i')]\n  [inst_6 : (i' : ι') → NormedSpace 𝕜 (E' i')] (x : 𝕜) (x_1 : (i' : ι') → ContinuousMultilinearMap 𝕜 E (E' i')),\n  AddHom.toFun\n      { toFun := ((Equiv.toFun ContinuousMultilinearMap.piEquiv)),\n        map_add' :=\n          (((fun (x : (i' : ι') → ContinuousMultilinearMap 𝕜 E (E' i'))\n              (x_2 : (i' : ι') → ContinuousMultilinearMap 𝕜 E (E' i')) ↦\n            rfl))) }\n      (x • x_1) =\n    AddHom.toFun\n      { toFun := ((Equiv.toFun ContinuousMultilinearMap.piEquiv)),\n        map_add' :=\n          (((fun (x : (i' : ι') → ContinuousMultilinearMap 𝕜 E (E' i'))\n              (x_2 : (i' : ι') → ContinuousMultilinearMap 𝕜 E (E' i')) ↦\n            rfl))) }\n      (x • x_1)", "terms": [], "namedLemmas": ["∀ {α : Sort u} {a : α}, a = a"], "lemmas": [], "ids": ["rfl"], "idString": "rfl; ", "context": []}
{"typeGroup": "(∀ {n : Type u_1} {R : Type u_3} {α : Type u_2} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommSemiring R]\n    [inst_3 : Semiring α] [inst_4 : Algebra R α] (r : R) (x : Matrix n n α),\n    r • x =\n      ↑{ toMonoidHom := ((↑(RingHom.comp (Matrix.scalar n) (algebraMap R α)))),\n              map_zero' :=\n                (((RingHom.map_zero'\n                    (RingHom.comp (Matrix.scalar n)\n                      (algebraMap R α))=:OneHom.toFun (↑↑(RingHom.comp (Matrix.scalar n) (algebraMap R α))) 0 = 0))),\n              map_add' :=\n                (((RingHom.map_add'\n                    (RingHom.comp (Matrix.scalar n)\n                      (algebraMap R\n                        α))=:∀ (x : R) (y : R),\n                    OneHom.toFun (↑↑(RingHom.comp (Matrix.scalar n) (algebraMap R α))) (x + y) =\n                      OneHom.toFun (↑↑(RingHom.comp (Matrix.scalar n) (algebraMap R α))) x +\n                        OneHom.toFun (↑↑(RingHom.comp (Matrix.scalar n) (algebraMap R α))) y))) }\n          r *\n        x :\n  Prop)", "type": "∀ {n : Type u_1} {R : Type u_3} {α : Type u_2} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommSemiring R]\n  [inst_3 : Semiring α] [inst_4 : Algebra R α] (r : R) (x : Matrix n n α),\n  r • x =\n    ↑{ toMonoidHom := ((↑(RingHom.comp (Matrix.scalar n) (algebraMap R α)))),\n            map_zero' := (((RingHom.map_zero' (RingHom.comp (Matrix.scalar n) (algebraMap R α))))),\n            map_add' := (((RingHom.map_add' (RingHom.comp (Matrix.scalar n) (algebraMap R α))))) }\n        r *\n      x", "thm": " : ∀ {n : Type u_1} {R : Type u_3} {α : Type u_2} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommSemiring R]\n  [inst_3 : Semiring α] [inst_4 : Algebra R α] (r : R) (x : Matrix n n α),\n  r • x =\n    ↑{ toMonoidHom := ((↑(RingHom.comp (Matrix.scalar n) (algebraMap R α)))),\n            map_zero' := (((RingHom.map_zero' (RingHom.comp (Matrix.scalar n) (algebraMap R α))))),\n            map_add' := (((RingHom.map_add' (RingHom.comp (Matrix.scalar n) (algebraMap R α))))) }\n        r *\n      x", "terms": [{"value": "x i x_1", "isProp": false, "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"value": "↑(algebraMap R α) r * x i x_1", "isProp": false, "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}], "namedLemmas": ["∀ {m : Type u_2} {n : Type u_1} {α : Type v} {M N : Matrix m n α}, (∀ (i : m), M i = N i) → M = N", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g", "∀ {p : Prop}, p = True → p", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (r : R) (x : A),\n  r • x = ↑(algebraMap R A) r * x", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {R : Type u_3} [inst : CommSemiring R] (A : Type u_2) [inst_1 : Semiring A] [inst_2 : Algebra R A] {M : Type u_1}\n  [inst_3 : AddCommMonoid M] [inst_4 : Module A M] [inst_5 : Module R M] [inst_6 : IsScalarTower R A M] (r : R) (m : M),\n  ↑(algebraMap R A) r • m = r • m", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {M : Type u_1} {N : Type u_2} [inst : MulOneClass N] [inst_1 : SMul M N] [inst_2 : IsScalarTower M N N] (x : M)\n  (y : N), x • 1 * y = x • y", "∀ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (r : R) (x : A),\n  r • x = ↑(algebraMap R A) r * x", "∀ {α : Sort u_1} (a : α), (a = a) = True"], "lemmas": [{"prop": "∀ (x_0 : Type u_2) (x_1 : Semiring x_0) (x_2 : Algebra R x_0) (x : x_0), r • x = ↑(algebraMap R x_0) r * x", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)", "(x_0 : Type u_2)", "(x_1 : Semiring x_0)", "(x_2 : Algebra R x_0)", "(x : x_0)"]}, {"prop": "∀ (x_0 : Type u_2) (x_1 : Semiring x_0) (x_2 : Algebra R x_0) (x : x_0), r • x = ↑(algebraMap R x_0) r * x", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "r • x i x_1 = ↑(algebraMap R α) r * x i x_1", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "Eq (r • x i x_1) = Eq (↑(algebraMap R α) r * x i x_1)", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "↑(algebraMap R α) r • 1 = r • 1", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "HMul.hMul (↑(algebraMap R α) r • 1) = HMul.hMul (r • 1)", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "↑(algebraMap R α) r • 1 * x = r • 1 * x", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "(↑(algebraMap R α) r • 1 * x) i = (r • 1 * x) i", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "(↑(algebraMap R α) r • 1 * x) i x_1 = (r • 1 * x) i x_1", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "r • 1 * x = r • x", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "(r • 1 * x) i = (r • x) i", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "(r • 1 * x) i x_1 = (r • x) i x_1", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "(↑(algebraMap R α) r • 1 * x) i x_1 = (r • x) i x_1", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "∀ (x_0 : Type u_2) (x_1 : Semiring x_0) (x_2 : Algebra R x_0) (x : x_0), r • x = ↑(algebraMap R x_0) r * x", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)", "(x_0 : Type u_2)", "(x_1 : Semiring x_0)", "(x_2 : Algebra R x_0)", "(x : x_0)"]}, {"prop": "∀ (x_0 : Type u_2) (x_1 : Semiring x_0) (x_2 : Algebra R x_0) (x : x_0), r • x = ↑(algebraMap R x_0) r * x", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "r • x i x_1 = ↑(algebraMap R α) r * x i x_1", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "(↑(algebraMap R α) r • 1 * x) i x_1 = ↑(algebraMap R α) r * x i x_1", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "(r • x i x_1 = (↑(algebraMap R α) r • 1 * x) i x_1) = (↑(algebraMap R α) r * x i x_1 = ↑(algebraMap R α) r * x i x_1)", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "(↑(algebraMap R α) r * x i x_1 = ↑(algebraMap R α) r * x i x_1) = True", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "(r • x i x_1 = (↑(algebraMap R α) r • 1 * x) i x_1) = True", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)", "(x_1 : n)"]}, {"prop": "∀ (x_1 : n), r • x i x_1 = (↑(algebraMap R α) r • 1 * x) i x_1", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)", "(i : n)"]}, {"prop": "∀ (i : n),\n  (r • x) i =\n    (↑{ toMonoidHom := ((↑(RingHom.comp (Matrix.scalar n) (algebraMap R α)))),\n              map_zero' := (((RingHom.map_zero' (RingHom.comp (Matrix.scalar n) (algebraMap R α))))),\n              map_add' := (((RingHom.map_add' (RingHom.comp (Matrix.scalar n) (algebraMap R α))))) }\n          r *\n        x)\n      i", "context": ["{n : Type u_1}", "{R : Type u_3}", "{α : Type u_2}", "[Fintype n]", "[DecidableEq n]", "[CommSemiring R]", "[inst_3 : Semiring α]", "[inst_4 : Algebra R α]", "(r : R)", "(x : (fun (x : R) ↦ Matrix n n α) r)"]}], "ids": ["Matrix.ext'", "funext", "of_eq_true", "Eq.trans", "congr", "congrArg", "Eq", "Algebra.smul_def", "inst_3", "inst_4", "Eq.trans", "Eq.trans", "congrFun", "congrFun", "congrFun", "congrArg", "HMul.hMul", "algebraMap_smul", "congrFun", "congrFun", "smul_one_mul", "Algebra.smul_def", "inst_3", "inst_4", "eq_self", "algebraMap"], "idString": "Matrix.ext'; funext; of_eq_true; Eq.trans; congr; congrArg; Eq; Algebra.smul_def; inst_3; inst_4; Eq.trans; Eq.trans; congrFun; congrFun; congrFun; congrArg; HMul.hMul; algebraMap_smul; congrFun; congrFun; smul_one_mul; Algebra.smul_def; inst_3; inst_4; eq_self; algebraMap; ", "context": []}
{"typeGroup": "(∀ {C : Type u} [inst : CategoryTheory.Category C] {J : CategoryTheory.GrothendieckTopology C} {D : Type w}\n    [inst_1 : CategoryTheory.Category D] [inst_2 : CategoryTheory.ConcreteCategory D] {Y : C} {X : C}\n    {P : CategoryTheory.Functor Cᵒᵖ D} {S : CategoryTheory.GrothendieckTopology.Cover J X} (x : CategoryTheory.Meq P S)\n    (f : Y ⟶ X)\n    (I :\n      CategoryTheory.GrothendieckTopology.Cover.Arrow\n        ((CategoryTheory.Functor.toPrefunctor (CategoryTheory.GrothendieckTopology.pullback J f)).obj S)),\n    ↑(CategoryTheory.Meq.pullback x f) I =\n      ↑x\n        { Y := ((CategoryTheory.GrothendieckTopology.Cover.Arrow.Y I)),\n          f := ((CategoryTheory.CategoryStruct.comp (CategoryTheory.GrothendieckTopology.Cover.Arrow.f I) f)),\n          hf :=\n            (((CategoryTheory.GrothendieckTopology.Cover.Arrow.hf\n                I=:(CategoryTheory.GrothendieckTopology.Cover.sieve\n                    ((CategoryTheory.Functor.toPrefunctor (CategoryTheory.GrothendieckTopology.pullback J f)).obj\n                      S)).arrows\n                (CategoryTheory.GrothendieckTopology.Cover.Arrow.f I)))) } :\n  Prop)", "type": "∀ {C : Type u} [inst : CategoryTheory.Category C] {J : CategoryTheory.GrothendieckTopology C} {D : Type w}\n  [inst_1 : CategoryTheory.Category D] [inst_2 : CategoryTheory.ConcreteCategory D] {Y : C} {X : C}\n  {P : CategoryTheory.Functor Cᵒᵖ D} {S : CategoryTheory.GrothendieckTopology.Cover J X} (x : CategoryTheory.Meq P S)\n  (f : Y ⟶ X)\n  (I :\n    CategoryTheory.GrothendieckTopology.Cover.Arrow\n      ((CategoryTheory.Functor.toPrefunctor (CategoryTheory.GrothendieckTopology.pullback J f)).obj S)),\n  ↑(CategoryTheory.Meq.pullback x f) I = ↑(CategoryTheory.Meq.pullback x f) I", "thm": " : ∀ {C : Type u} [inst : CategoryTheory.Category C] {J : CategoryTheory.GrothendieckTopology C} {D : Type w}\n  [inst_1 : CategoryTheory.Category D] [inst_2 : CategoryTheory.ConcreteCategory D] {Y : C} {X : C}\n  {P : CategoryTheory.Functor Cᵒᵖ D} {S : CategoryTheory.GrothendieckTopology.Cover J X} (x : CategoryTheory.Meq P S)\n  (f : Y ⟶ X)\n  (I :\n    CategoryTheory.GrothendieckTopology.Cover.Arrow\n      ((CategoryTheory.Functor.toPrefunctor (CategoryTheory.GrothendieckTopology.pullback J f)).obj S)),\n  ↑(CategoryTheory.Meq.pullback x f) I = ↑(CategoryTheory.Meq.pullback x f) I", "terms": [], "namedLemmas": ["∀ {α : Sort u} {a : α}, a = a"], "lemmas": [], "ids": ["rfl"], "idString": "rfl; ", "context": []}
{"typeGroup": "(∀ (C : Type u) [inst : CategoryTheory.Category C] {X : TopCat} {Y : TopCat} (H : X ≅ Y)\n    (X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C) (X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ),\n    CategoryTheory.NatTrans.app\n        (CategoryTheory.NatTrans.app (CategoryTheory.Equivalence.counitIso (TopCat.Presheaf.presheafEquivOfIso C H)).hom\n          X_1)\n        X_2 =\n      (CategoryTheory.Functor.toPrefunctor X_1).map\n        (CategoryTheory.eqToHom\n          (congr_arg Opposite.op\n              (Eq.symm\n                  (TopologicalSpace.Opens.mapMapIso.proof_1 H\n                      (Opposite.unop\n                        X_2)=:Opposite.unop X_2 =\n                      {\n                        carrier :=\n                          ((↑H.inv ⁻¹'\n                            ↑((CategoryTheory.Functor.toPrefunctor\n                                    (CategoryTheory.Functor.mk\n                                      {\n                                        obj :=\n                                          ((fun (U : TopologicalSpace.Opens ↑Y) ↦\n                                            { carrier := ((↑H.hom ⁻¹' ↑U)),\n                                              is_open' :=\n                                                (((TopologicalSpace.Opens.map.proof_1 H.hom\n                                                    U=:IsOpen (↑H.hom ⁻¹' ↑U)))) })),\n                                        map :=\n                                          ((fun {X_3 : TopologicalSpace.Opens ↑Y} {Y_1 : TopologicalSpace.Opens ↑Y}\n                                              (i : X_3 ⟶ Y_1) ↦\n                                            {\n                                              down :=\n                                                (({\n                                                  down :=\n                                                    (((TopologicalSpace.Opens.map.proof_2 H.hom\n                                                        i=:∀ (x : ↑X)\n                                                        (h :\n                                                          x ∈\n                                                            ↑((fun (U : TopologicalSpace.Opens ↑Y) ↦\n                                                                  { carrier := ((↑H.hom ⁻¹' ↑U)),\n                                                                    is_open' :=\n                                                                      (((IsOpen.preimage\n                                                                          (ContinuousMap.continuous\n                                                                              H.hom=:Continuous ↑H.hom)\n                                                                          (TopologicalSpace.Opens.isOpen\n                                                                              U=:IsOpen\n                                                                              ↑U)=:IsOpen (↑H.hom ⁻¹' ↑U)))) })\n                                                                X_3)),\n                                                        ↑H.hom x ∈ ↑Y_1))) })) })) })).obj\n                                (Opposite.unop X_2)))),\n                        is_open' :=\n                          (((TopologicalSpace.Opens.map.proof_1 H.inv\n                              ((CategoryTheory.Functor.toPrefunctor\n                                    (CategoryTheory.Functor.mk\n                                      {\n                                        obj :=\n                                          ((fun (U : TopologicalSpace.Opens ↑Y) ↦\n                                            { carrier := ((↑H.hom ⁻¹' ↑U)),\n                                              is_open' :=\n                                                (((TopologicalSpace.Opens.map.proof_1 H.hom\n                                                    U=:IsOpen (↑H.hom ⁻¹' ↑U)))) })),\n                                        map :=\n                                          ((fun {X_3 : TopologicalSpace.Opens ↑Y} {Y_1 : TopologicalSpace.Opens ↑Y}\n                                              (i : X_3 ⟶ Y_1) ↦\n                                            {\n                                              down :=\n                                                (({\n                                                  down :=\n                                                    (((TopologicalSpace.Opens.map.proof_2 H.hom\n                                                        i=:∀ (x : ↑X)\n                                                        (h :\n                                                          x ∈\n                                                            ↑((fun (U : TopologicalSpace.Opens ↑Y) ↦\n                                                                  { carrier := ((↑H.hom ⁻¹' ↑U)),\n                                                                    is_open' :=\n                                                                      (((IsOpen.preimage\n                                                                          (ContinuousMap.continuous\n                                                                              H.hom=:Continuous ↑H.hom)\n                                                                          (TopologicalSpace.Opens.isOpen\n                                                                              U=:IsOpen\n                                                                              ↑U)=:IsOpen (↑H.hom ⁻¹' ↑U)))) })\n                                                                X_3)),\n                                                        ↑H.hom x ∈ ↑Y_1))) })) })) })).obj\n                                (Opposite.unop\n                                  X_2))=:IsOpen\n                              (↑H.inv ⁻¹'\n                                ↑((CategoryTheory.Functor.toPrefunctor\n                                        (CategoryTheory.Functor.mk\n                                          {\n                                            obj :=\n                                              ((fun (U : TopologicalSpace.Opens ↑Y) ↦\n                                                { carrier := ((↑H.hom ⁻¹' ↑U)),\n                                                  is_open' :=\n                                                    (((TopologicalSpace.Opens.map.proof_1 H.hom\n                                                        U=:IsOpen (↑H.hom ⁻¹' ↑U)))) })),\n                                            map :=\n                                              ((fun {X_3 : TopologicalSpace.Opens ↑Y} {Y_1 : TopologicalSpace.Opens ↑Y}\n                                                  (i : X_3 ⟶ Y_1) ↦\n                                                {\n                                                  down :=\n                                                    (({\n                                                      down :=\n                                                        (((TopologicalSpace.Opens.map.proof_2 H.hom\n                                                            i=:∀ (x : ↑X)\n                                                            (h :\n                                                              x ∈\n                                                                ↑((fun (U : TopologicalSpace.Opens ↑Y) ↦\n                                                                      { carrier := ((↑H.hom ⁻¹' ↑U)),\n                                                                        is_open' :=\n                                                                          (((IsOpen.preimage\n                                                                              (ContinuousMap.continuous\n                                                                                  H.hom=:Continuous ↑H.hom)\n                                                                              (TopologicalSpace.Opens.isOpen\n                                                                                  U=:IsOpen\n                                                                                  ↑U)=:IsOpen (↑H.hom ⁻¹' ↑U)))) })\n                                                                    X_3)),\n                                                            ↑H.hom x ∈ ↑Y_1))) })) })) })).obj\n                                    (Opposite.unop\n                                      X_2)))))) })=:(CategoryTheory.Functor.toPrefunctor\n                        (TopologicalSpace.Opens.map H.inv)).obj\n                    ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.hom)).obj (Opposite.unop X_2)) =\n                  Opposite.unop\n                    X_2)=:Opposite.op\n                ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.inv)).obj\n                  ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.hom)).obj (Opposite.unop X_2))) =\n              Opposite.op (Opposite.unop X_2))) :\n  Prop)", "type": "∀ (C : Type u) [inst : CategoryTheory.Category C] {X : TopCat} {Y : TopCat} (H : X ≅ Y)\n  (X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C) (X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ),\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.CategoryStruct.id\n        ((CategoryTheory.Functor.toPrefunctor X_1).obj\n          (Opposite.op\n            ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.inv)).obj\n              ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.hom)).obj (Opposite.unop X_2))))))\n      (CategoryTheory.CategoryStruct.comp\n        ((CategoryTheory.Functor.toPrefunctor X_1).map\n          (CategoryTheory.eqToHom (TopologicalSpace.Opens.mapMapIso.proof_1 H (Opposite.unop X_2))).op)\n        (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.toPrefunctor X_1).obj X_2))) =\n    (CategoryTheory.Functor.toPrefunctor X_1).map\n      (CategoryTheory.eqToHom\n        (congr_arg Opposite.op (Eq.symm (TopologicalSpace.Opens.mapMapIso.proof_1 H (Opposite.unop X_2)))))", "thm": " : ∀ (C : Type u) [inst : CategoryTheory.Category C] {X : TopCat} {Y : TopCat} (H : X ≅ Y)\n  (X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C) (X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ),\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.CategoryStruct.id\n        ((CategoryTheory.Functor.toPrefunctor X_1).obj\n          (Opposite.op\n            ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.inv)).obj\n              ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.hom)).obj (Opposite.unop X_2))))))\n      (CategoryTheory.CategoryStruct.comp\n        ((CategoryTheory.Functor.toPrefunctor X_1).map\n          (CategoryTheory.eqToHom (TopologicalSpace.Opens.mapMapIso.proof_1 H (Opposite.unop X_2))).op)\n        (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.toPrefunctor X_1).obj X_2))) =\n    (CategoryTheory.Functor.toPrefunctor X_1).map\n      (CategoryTheory.eqToHom\n        (congr_arg Opposite.op (Eq.symm (TopologicalSpace.Opens.mapMapIso.proof_1 H (Opposite.unop X_2)))))", "terms": [{"value": "H.inv", "isProp": false, "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"value": "TopologicalSpace.Opens.map H.inv", "isProp": false, "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"value": "H.hom", "isProp": false, "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"value": "TopologicalSpace.Opens.map H.hom", "isProp": false, "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"value": "Opposite.unop X_2", "isProp": false, "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"value": "(CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.hom)).obj (Opposite.unop X_2)", "isProp": false, "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"value": "(CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.inv)).obj\n  ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.hom)).obj (Opposite.unop X_2))", "isProp": false, "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"value": "Opposite.op\n  ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.inv)).obj\n    ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.hom)).obj (Opposite.unop X_2)))", "isProp": false, "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"value": "(CategoryTheory.Functor.toPrefunctor X_1).obj\n  (Opposite.op\n    ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.inv)).obj\n      ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.hom)).obj (Opposite.unop X_2))))", "isProp": false, "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"value": "CategoryTheory.CategoryStruct.id\n  ((CategoryTheory.Functor.toPrefunctor X_1).obj\n    (Opposite.op\n      ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.inv)).obj\n        ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.hom)).obj (Opposite.unop X_2)))))", "isProp": false, "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"value": "CategoryTheory.CategoryStruct.comp\n  (CategoryTheory.CategoryStruct.id\n    ((CategoryTheory.Functor.toPrefunctor X_1).obj\n      (Opposite.op\n        ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.inv)).obj\n          ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.hom)).obj (Opposite.unop X_2))))))", "isProp": false, "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"value": "(CategoryTheory.Functor.toPrefunctor X_1).map", "isProp": false, "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"value": "(CategoryTheory.Functor.toPrefunctor X_1).obj X_2", "isProp": false, "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"value": "CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.toPrefunctor X_1).obj X_2)", "isProp": false, "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"value": "CategoryTheory.eqToHom\n  (congr_arg Opposite.op (Eq.symm (TopologicalSpace.Opens.mapMapIso.proof_1 H (Opposite.unop X_2))))", "isProp": false, "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"value": "(CategoryTheory.Functor.toPrefunctor X_1).map\n  (CategoryTheory.eqToHom\n    (congr_arg Opposite.op (Eq.symm (TopologicalSpace.Opens.mapMapIso.proof_1 H (Opposite.unop X_2)))))", "isProp": false, "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}], "namedLemmas": ["∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C} (h : X = Y),\n  (CategoryTheory.eqToHom h).op = CategoryTheory.eqToHom (_ : Opposite.op Y = Opposite.op X)", "∀ {X Y : TopCat} (H : X ≅ Y) (U : TopologicalSpace.Opens ↑Y),\n  U =\n    {\n      carrier :=\n        ↑H.inv ⁻¹'\n          ↑((CategoryTheory.Functor.mk\n                  { obj := fun U => { carrier := ↑H.hom ⁻¹' ↑U, is_open' := (_ : IsOpen (↑H.hom ⁻¹' ↑U)) },\n                    map := fun {X_1 Y_1} i =>\n                      {\n                        down :=\n                          {\n                            down :=\n                              (_ :\n                                ∀ (x : ↑X),\n                                  x ∈\n                                      ↑((fun U =>\n                                            { carrier := ↑H.hom ⁻¹' ↑U, is_open' := (_ : IsOpen (↑H.hom ⁻¹' ↑U)) })\n                                          X_1) →\n                                    ↑H.hom x ∈ ↑Y_1) } } }).obj\n              U),\n      is_open' :=\n        (_ :\n          IsOpen\n            (↑H.inv ⁻¹'\n              ↑((CategoryTheory.Functor.mk\n                      { obj := fun U => { carrier := ↑H.hom ⁻¹' ↑U, is_open' := (_ : IsOpen (↑H.hom ⁻¹' ↑U)) },\n                        map := fun {X_1 Y_1} i =>\n                          {\n                            down :=\n                              {\n                                down :=\n                                  (_ :\n                                    ∀ (x : ↑X),\n                                      x ∈\n                                          ↑((fun U =>\n                                                { carrier := ↑H.hom ⁻¹' ↑U, is_open' := (_ : IsOpen (↑H.hom ⁻¹' ↑U)) })\n                                              X_1) →\n                                        ↑H.hom x ∈ ↑Y_1) } } }).obj\n                  U))) }", "∀ {obj : Type u} [self : CategoryTheory.Category obj] {X Y : obj} (f : X ⟶ Y),\n  CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.id Y) = f", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {X Y : TopCat} (H : X ≅ Y) (U : TopologicalSpace.Opens ↑Y),\n  U =\n    {\n      carrier :=\n        ↑H.inv ⁻¹'\n          ↑((CategoryTheory.Functor.mk\n                  { obj := fun U => { carrier := ↑H.hom ⁻¹' ↑U, is_open' := (_ : IsOpen (↑H.hom ⁻¹' ↑U)) },\n                    map := fun {X_1 Y_1} i =>\n                      {\n                        down :=\n                          {\n                            down :=\n                              (_ :\n                                ∀ (x : ↑X),\n                                  x ∈\n                                      ↑((fun U =>\n                                            { carrier := ↑H.hom ⁻¹' ↑U, is_open' := (_ : IsOpen (↑H.hom ⁻¹' ↑U)) })\n                                          X_1) →\n                                    ↑H.hom x ∈ ↑Y_1) } } }).obj\n              U),\n      is_open' :=\n        (_ :\n          IsOpen\n            (↑H.inv ⁻¹'\n              ↑((CategoryTheory.Functor.mk\n                      { obj := fun U => { carrier := ↑H.hom ⁻¹' ↑U, is_open' := (_ : IsOpen (↑H.hom ⁻¹' ↑U)) },\n                        map := fun {X_1 Y_1} i =>\n                          {\n                            down :=\n                              {\n                                down :=\n                                  (_ :\n                                    ∀ (x : ↑X),\n                                      x ∈\n                                          ↑((fun U =>\n                                                { carrier := ↑H.hom ⁻¹' ↑U, is_open' := (_ : IsOpen (↑H.hom ⁻¹' ↑U)) })\n                                              X_1) →\n                                        ↑H.hom x ∈ ↑Y_1) } } }).obj\n                  U))) }", "∀ {obj : Type u} [self : CategoryTheory.Category obj] {X Y : obj} (f : X ⟶ Y),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id X) f = f", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {X Y : TopCat} (H : X ≅ Y) (U : TopologicalSpace.Opens ↑Y),\n  U =\n    {\n      carrier :=\n        ↑H.inv ⁻¹'\n          ↑((CategoryTheory.Functor.mk\n                  { obj := fun U => { carrier := ↑H.hom ⁻¹' ↑U, is_open' := (_ : IsOpen (↑H.hom ⁻¹' ↑U)) },\n                    map := fun {X_1 Y_1} i =>\n                      {\n                        down :=\n                          {\n                            down :=\n                              (_ :\n                                ∀ (x : ↑X),\n                                  x ∈\n                                      ↑((fun U =>\n                                            { carrier := ↑H.hom ⁻¹' ↑U, is_open' := (_ : IsOpen (↑H.hom ⁻¹' ↑U)) })\n                                          X_1) →\n                                    ↑H.hom x ∈ ↑Y_1) } } }).obj\n              U),\n      is_open' :=\n        (_ :\n          IsOpen\n            (↑H.inv ⁻¹'\n              ↑((CategoryTheory.Functor.mk\n                      { obj := fun U => { carrier := ↑H.hom ⁻¹' ↑U, is_open' := (_ : IsOpen (↑H.hom ⁻¹' ↑U)) },\n                        map := fun {X_1 Y_1} i =>\n                          {\n                            down :=\n                              {\n                                down :=\n                                  (_ :\n                                    ∀ (x : ↑X),\n                                      x ∈\n                                          ↑((fun U =>\n                                                { carrier := ↑H.hom ⁻¹' ↑U, is_open' := (_ : IsOpen (↑H.hom ⁻¹' ↑U)) })\n                                              X_1) →\n                                        ↑H.hom x ∈ ↑Y_1) } } }).obj\n                  U))) }"], "lemmas": [{"prop": "Opposite.unop X_2 =\n  {\n    carrier :=\n      ((↑H.inv ⁻¹'\n        ↑((CategoryTheory.Functor.toPrefunctor\n                (CategoryTheory.Functor.mk\n                  {\n                    obj :=\n                      ((fun (U : TopologicalSpace.Opens ↑Y) ↦\n                        { carrier := ((↑H.hom ⁻¹' ↑U)),\n                          is_open' := (((TopologicalSpace.Opens.map.proof_1 H.hom U))) })),\n                    map :=\n                      ((fun {X_3 : TopologicalSpace.Opens ↑Y} {Y_1 : TopologicalSpace.Opens ↑Y} (i : X_3 ⟶ Y_1) ↦\n                        { down := (({ down := (((TopologicalSpace.Opens.map.proof_2 H.hom i))) })) })) })).obj\n            (Opposite.unop X_2)))),\n    is_open' :=\n      (((TopologicalSpace.Opens.map.proof_1 H.inv\n        ((CategoryTheory.Functor.toPrefunctor\n              (CategoryTheory.Functor.mk\n                {\n                  obj :=\n                    ((fun (U : TopologicalSpace.Opens ↑Y) ↦\n                      { carrier := ((↑H.hom ⁻¹' ↑U)), is_open' := (((TopologicalSpace.Opens.map.proof_1 H.hom U))) })),\n                  map :=\n                    ((fun {X_3 : TopologicalSpace.Opens ↑Y} {Y_1 : TopologicalSpace.Opens ↑Y} (i : X_3 ⟶ Y_1) ↦\n                      { down := (({ down := (((TopologicalSpace.Opens.map.proof_2 H.hom i))) })) })) })).obj\n          (Opposite.unop X_2))))) }", "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"prop": "(CategoryTheory.eqToHom (TopologicalSpace.Opens.mapMapIso.proof_1 H (Opposite.unop X_2))).op =\n  CategoryTheory.eqToHom\n    (congr_arg Opposite.op (Eq.symm (TopologicalSpace.Opens.mapMapIso.proof_1 H (Opposite.unop X_2))))", "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"prop": "(CategoryTheory.Functor.toPrefunctor X_1).map\n    (CategoryTheory.eqToHom (TopologicalSpace.Opens.mapMapIso.proof_1 H (Opposite.unop X_2))).op =\n  (CategoryTheory.Functor.toPrefunctor X_1).map\n    (CategoryTheory.eqToHom\n      (congr_arg Opposite.op (Eq.symm (TopologicalSpace.Opens.mapMapIso.proof_1 H (Opposite.unop X_2)))))", "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"prop": "CategoryTheory.CategoryStruct.comp\n    ((CategoryTheory.Functor.toPrefunctor X_1).map\n      (CategoryTheory.eqToHom (TopologicalSpace.Opens.mapMapIso.proof_1 H (Opposite.unop X_2))).op) =\n  CategoryTheory.CategoryStruct.comp\n    ((CategoryTheory.Functor.toPrefunctor X_1).map\n      (CategoryTheory.eqToHom\n        (congr_arg Opposite.op (Eq.symm (TopologicalSpace.Opens.mapMapIso.proof_1 H (Opposite.unop X_2))))))", "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"prop": "CategoryTheory.CategoryStruct.comp\n    ((CategoryTheory.Functor.toPrefunctor X_1).map\n      (CategoryTheory.eqToHom (TopologicalSpace.Opens.mapMapIso.proof_1 H (Opposite.unop X_2))).op)\n    (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.toPrefunctor X_1).obj X_2)) =\n  CategoryTheory.CategoryStruct.comp\n    ((CategoryTheory.Functor.toPrefunctor X_1).map\n      (CategoryTheory.eqToHom\n        (congr_arg Opposite.op (Eq.symm (TopologicalSpace.Opens.mapMapIso.proof_1 H (Opposite.unop X_2))))))\n    (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.toPrefunctor X_1).obj X_2))", "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"prop": "Opposite.unop X_2 =\n  {\n    carrier :=\n      ((↑H.inv ⁻¹'\n        ↑((CategoryTheory.Functor.toPrefunctor\n                (CategoryTheory.Functor.mk\n                  {\n                    obj :=\n                      ((fun (U : TopologicalSpace.Opens ↑Y) ↦\n                        { carrier := ((↑H.hom ⁻¹' ↑U)),\n                          is_open' := (((TopologicalSpace.Opens.map.proof_1 H.hom U))) })),\n                    map :=\n                      ((fun {X_3 : TopologicalSpace.Opens ↑Y} {Y_1 : TopologicalSpace.Opens ↑Y} (i : X_3 ⟶ Y_1) ↦\n                        { down := (({ down := (((TopologicalSpace.Opens.map.proof_2 H.hom i))) })) })) })).obj\n            (Opposite.unop X_2)))),\n    is_open' :=\n      (((TopologicalSpace.Opens.map.proof_1 H.inv\n        ((CategoryTheory.Functor.toPrefunctor\n              (CategoryTheory.Functor.mk\n                {\n                  obj :=\n                    ((fun (U : TopologicalSpace.Opens ↑Y) ↦\n                      { carrier := ((↑H.hom ⁻¹' ↑U)), is_open' := (((TopologicalSpace.Opens.map.proof_1 H.hom U))) })),\n                  map :=\n                    ((fun {X_3 : TopologicalSpace.Opens ↑Y} {Y_1 : TopologicalSpace.Opens ↑Y} (i : X_3 ⟶ Y_1) ↦\n                      { down := (({ down := (((TopologicalSpace.Opens.map.proof_2 H.hom i))) })) })) })).obj\n          (Opposite.unop X_2))))) }", "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"prop": "(CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.inv)).obj\n    ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.hom)).obj (Opposite.unop X_2)) =\n  Opposite.unop X_2", "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"prop": "Opposite.op\n    ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.inv)).obj\n      ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.hom)).obj (Opposite.unop X_2))) =\n  Opposite.op (Opposite.unop X_2)", "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"prop": "CategoryTheory.CategoryStruct.comp\n    ((CategoryTheory.Functor.toPrefunctor X_1).map\n      (CategoryTheory.eqToHom\n        (congr_arg Opposite.op (Eq.symm (TopologicalSpace.Opens.mapMapIso.proof_1 H (Opposite.unop X_2))))))\n    (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.toPrefunctor X_1).obj X_2)) =\n  (CategoryTheory.Functor.toPrefunctor X_1).map\n    (CategoryTheory.eqToHom\n      (congr_arg Opposite.op (Eq.symm (TopologicalSpace.Opens.mapMapIso.proof_1 H (Opposite.unop X_2)))))", "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"prop": "CategoryTheory.CategoryStruct.comp\n    ((CategoryTheory.Functor.toPrefunctor X_1).map\n      (CategoryTheory.eqToHom (TopologicalSpace.Opens.mapMapIso.proof_1 H (Opposite.unop X_2))).op)\n    (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.toPrefunctor X_1).obj X_2)) =\n  (CategoryTheory.Functor.toPrefunctor X_1).map\n    (CategoryTheory.eqToHom\n      (congr_arg Opposite.op (Eq.symm (TopologicalSpace.Opens.mapMapIso.proof_1 H (Opposite.unop X_2)))))", "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"prop": "CategoryTheory.CategoryStruct.comp\n    (CategoryTheory.CategoryStruct.id\n      ((CategoryTheory.Functor.toPrefunctor X_1).obj\n        (Opposite.op\n          ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.inv)).obj\n            ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.hom)).obj (Opposite.unop X_2))))))\n    (CategoryTheory.CategoryStruct.comp\n      ((CategoryTheory.Functor.toPrefunctor X_1).map\n        (CategoryTheory.eqToHom (TopologicalSpace.Opens.mapMapIso.proof_1 H (Opposite.unop X_2))).op)\n      (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.toPrefunctor X_1).obj X_2))) =\n  CategoryTheory.CategoryStruct.comp\n    (CategoryTheory.CategoryStruct.id\n      ((CategoryTheory.Functor.toPrefunctor X_1).obj\n        (Opposite.op\n          ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.inv)).obj\n            ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.hom)).obj (Opposite.unop X_2))))))\n    ((CategoryTheory.Functor.toPrefunctor X_1).map\n      (CategoryTheory.eqToHom\n        (congr_arg Opposite.op (Eq.symm (TopologicalSpace.Opens.mapMapIso.proof_1 H (Opposite.unop X_2))))))", "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"prop": "Opposite.unop X_2 =\n  {\n    carrier :=\n      ((↑H.inv ⁻¹'\n        ↑((CategoryTheory.Functor.toPrefunctor\n                (CategoryTheory.Functor.mk\n                  {\n                    obj :=\n                      ((fun (U : TopologicalSpace.Opens ↑Y) ↦\n                        { carrier := ((↑H.hom ⁻¹' ↑U)),\n                          is_open' := (((TopologicalSpace.Opens.map.proof_1 H.hom U))) })),\n                    map :=\n                      ((fun {X_3 : TopologicalSpace.Opens ↑Y} {Y_1 : TopologicalSpace.Opens ↑Y} (i : X_3 ⟶ Y_1) ↦\n                        { down := (({ down := (((TopologicalSpace.Opens.map.proof_2 H.hom i))) })) })) })).obj\n            (Opposite.unop X_2)))),\n    is_open' :=\n      (((TopologicalSpace.Opens.map.proof_1 H.inv\n        ((CategoryTheory.Functor.toPrefunctor\n              (CategoryTheory.Functor.mk\n                {\n                  obj :=\n                    ((fun (U : TopologicalSpace.Opens ↑Y) ↦\n                      { carrier := ((↑H.hom ⁻¹' ↑U)), is_open' := (((TopologicalSpace.Opens.map.proof_1 H.hom U))) })),\n                  map :=\n                    ((fun {X_3 : TopologicalSpace.Opens ↑Y} {Y_1 : TopologicalSpace.Opens ↑Y} (i : X_3 ⟶ Y_1) ↦\n                      { down := (({ down := (((TopologicalSpace.Opens.map.proof_2 H.hom i))) })) })) })).obj\n          (Opposite.unop X_2))))) }", "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"prop": "(CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.inv)).obj\n    ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.hom)).obj (Opposite.unop X_2)) =\n  Opposite.unop X_2", "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"prop": "Opposite.op\n    ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.inv)).obj\n      ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.hom)).obj (Opposite.unop X_2))) =\n  Opposite.op (Opposite.unop X_2)", "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}, {"prop": "CategoryTheory.CategoryStruct.comp\n    (CategoryTheory.CategoryStruct.id\n      ((CategoryTheory.Functor.toPrefunctor X_1).obj\n        (Opposite.op\n          ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.inv)).obj\n            ((CategoryTheory.Functor.toPrefunctor (TopologicalSpace.Opens.map H.hom)).obj (Opposite.unop X_2))))))\n    ((CategoryTheory.Functor.toPrefunctor X_1).map\n      (CategoryTheory.eqToHom\n        (congr_arg Opposite.op (Eq.symm (TopologicalSpace.Opens.mapMapIso.proof_1 H (Opposite.unop X_2)))))) =\n  (CategoryTheory.Functor.toPrefunctor X_1).map\n    (CategoryTheory.eqToHom\n      (congr_arg Opposite.op (Eq.symm (TopologicalSpace.Opens.mapMapIso.proof_1 H (Opposite.unop X_2)))))", "context": ["(C : Type u)", "[CategoryTheory.Category C]", "{X : TopCat}", "{Y : TopCat}", "(H : X ≅ Y)", "(X_1 : CategoryTheory.Functor (TopologicalSpace.Opens ↑Y)ᵒᵖ C)", "(X_2 : (TopologicalSpace.Opens ↑Y)ᵒᵖ)"]}], "ids": ["Eq.trans", "congrArg", "CategoryTheory.CategoryStruct.comp", "CategoryTheory.CategoryStruct.id", "CategoryTheory.Functor.toPrefunctor", "obj", "Opposite.op", "CategoryTheory.Functor.toPrefunctor", "TopologicalSpace.Opens.map", "inv", "obj", "CategoryTheory.Functor.toPrefunctor", "TopologicalSpace.Opens.map", "hom", "obj", "Opposite.unop", "Eq.trans", "congrFun", "congrArg", "CategoryTheory.CategoryStruct.comp", "congrArg", "CategoryTheory.Functor.toPrefunctor", "map", "CategoryTheory.eqToHom_op", "TopologicalSpace.Opens.mapMapIso.proof_1", "Opposite.unop", "CategoryTheory.CategoryStruct.id", "CategoryTheory.Functor.toPrefunctor", "obj", "CategoryTheory.Category.comp_id", "CategoryTheory.Functor.toPrefunctor", "map", "CategoryTheory.eqToHom", "congr_arg", "Opposite.op", "Eq.symm", "TopologicalSpace.Opens.mapMapIso.proof_1", "Opposite.unop", "CategoryTheory.Category.id_comp", "CategoryTheory.Functor.toPrefunctor", "map", "CategoryTheory.eqToHom", "congr_arg", "Opposite.op", "Eq.symm", "TopologicalSpace.Opens.mapMapIso.proof_1", "Opposite.unop"], "idString": "Eq.trans; congrArg; CategoryTheory.CategoryStruct.comp; CategoryTheory.CategoryStruct.id; CategoryTheory.Functor.toPrefunctor; obj; Opposite.op; CategoryTheory.Functor.toPrefunctor; TopologicalSpace.Opens.map; inv; obj; CategoryTheory.Functor.toPrefunctor; TopologicalSpace.Opens.map; hom; obj; Opposite.unop; Eq.trans; congrFun; congrArg; CategoryTheory.CategoryStruct.comp; congrArg; CategoryTheory.Functor.toPrefunctor; map; CategoryTheory.eqToHom_op; TopologicalSpace.Opens.mapMapIso.proof_1; Opposite.unop; CategoryTheory.CategoryStruct.id; CategoryTheory.Functor.toPrefunctor; obj; CategoryTheory.Category.comp_id; CategoryTheory.Functor.toPrefunctor; map; CategoryTheory.eqToHom; congr_arg; Opposite.op; Eq.symm; TopologicalSpace.Opens.mapMapIso.proof_1; Opposite.unop; CategoryTheory.Category.id_comp; CategoryTheory.Functor.toPrefunctor; map; CategoryTheory.eqToHom; congr_arg; Opposite.op; Eq.symm; TopologicalSpace.Opens.mapMapIso.proof_1; Opposite.unop; ", "context": []}
{"typeGroup": "(∀ {R : Type u_1} [inst : Ring R] {J : Type u_3} [inst_1 : CategoryTheory.Category J]\n    (F : CategoryTheory.Functor J (ModuleCat R)) (s : CategoryTheory.Limits.Cocone F) (s_1 : R)\n    (x : ↑(ModuleCat.Colimits.colimit F)),\n    AddHom.toFun\n        { toFun := ((ModuleCat.Colimits.descFun F s)),\n          map_add' :=\n            (((fun (x : ↑(ModuleCat.Colimits.colimit F)) ↦\n              (_ :\n                ∀ (y : ↑(ModuleCat.Colimits.colimit F)),\n                  ModuleCat.Colimits.descFun F s (x + y) =\n                    ModuleCat.Colimits.descFun F s x +\n                      ModuleCat.Colimits.descFun F s\n                        y)=:∀ (x : ↑(ModuleCat.Colimits.colimit F)) (y : ↑(ModuleCat.Colimits.colimit F)),\n                ModuleCat.Colimits.descFun F s (x + y) =\n                  ModuleCat.Colimits.descFun F s x + ModuleCat.Colimits.descFun F s y))) }\n        (s_1 • x) =\n      ↑(RingHom.id R) s_1 •\n        AddHom.toFun\n          { toFun := ((ModuleCat.Colimits.descFun F s)),\n            map_add' :=\n              (((fun (x : ↑(ModuleCat.Colimits.colimit F)) ↦\n                (_ :\n                  ∀ (y : ↑(ModuleCat.Colimits.colimit F)),\n                    ModuleCat.Colimits.descFun F s (x + y) =\n                      ModuleCat.Colimits.descFun F s x +\n                        ModuleCat.Colimits.descFun F s\n                          y)=:∀ (x : ↑(ModuleCat.Colimits.colimit F)) (y : ↑(ModuleCat.Colimits.colimit F)),\n                  ModuleCat.Colimits.descFun F s (x + y) =\n                    ModuleCat.Colimits.descFun F s x + ModuleCat.Colimits.descFun F s y))) }\n          x :\n  Prop)", "type": "∀ {R : Type u_1} [inst : Ring R] {J : Type u_3} [inst_1 : CategoryTheory.Category J]\n  (F : CategoryTheory.Functor J (ModuleCat R)) (s : CategoryTheory.Limits.Cocone F) (s_1 : R)\n  (x : ↑(ModuleCat.Colimits.colimit F)),\n  AddHom.toFun\n      { toFun := ((ModuleCat.Colimits.descFun F s)),\n        map_add' :=\n          (((fun (x : ↑(ModuleCat.Colimits.colimit F)) (y : ↑(ModuleCat.Colimits.colimit F)) ↦\n            Quot.ind\n              (fun (a : ModuleCat.Colimits.Prequotient F) ↦\n                Quot.ind\n                  (fun (a_1 : ModuleCat.Colimits.Prequotient F) ↦\n                    Eq.refl (ModuleCat.Colimits.descFun F s (Quot.mk Setoid.r a + Quot.mk Setoid.r a_1)))\n                  y)\n              x))) }\n      (s_1 • x) =\n    ↑(RingHom.id R) s_1 •\n      AddHom.toFun\n        { toFun := ((ModuleCat.Colimits.descFun F s)),\n          map_add' :=\n            (((fun (x : ↑(ModuleCat.Colimits.colimit F)) (y : ↑(ModuleCat.Colimits.colimit F)) ↦\n              Quot.ind\n                (fun (a : ModuleCat.Colimits.Prequotient F) ↦\n                  Quot.ind\n                    (fun (a_1 : ModuleCat.Colimits.Prequotient F) ↦\n                      Eq.refl (ModuleCat.Colimits.descFun F s (Quot.mk Setoid.r a + Quot.mk Setoid.r a_1)))\n                    y)\n                x))) }\n        x", "thm": " : ∀ {R : Type u_1} [inst : Ring R] {J : Type u_3} [inst_1 : CategoryTheory.Category J]\n  (F : CategoryTheory.Functor J (ModuleCat R)) (s : CategoryTheory.Limits.Cocone F) (s_1 : R)\n  (x : ↑(ModuleCat.Colimits.colimit F)),\n  AddHom.toFun\n      { toFun := ((ModuleCat.Colimits.descFun F s)),\n        map_add' :=\n          (((fun (x : ↑(ModuleCat.Colimits.colimit F)) (y : ↑(ModuleCat.Colimits.colimit F)) ↦\n            Quot.ind\n              (fun (a : ModuleCat.Colimits.Prequotient F) ↦\n                Quot.ind\n                  (fun (a_1 : ModuleCat.Colimits.Prequotient F) ↦\n                    Eq.refl (ModuleCat.Colimits.descFun F s (Quot.mk Setoid.r a + Quot.mk Setoid.r a_1)))\n                  y)\n              x))) }\n      (s_1 • x) =\n    ↑(RingHom.id R) s_1 •\n      AddHom.toFun\n        { toFun := ((ModuleCat.Colimits.descFun F s)),\n          map_add' :=\n            (((fun (x : ↑(ModuleCat.Colimits.colimit F)) (y : ↑(ModuleCat.Colimits.colimit F)) ↦\n              Quot.ind\n                (fun (a : ModuleCat.Colimits.Prequotient F) ↦\n                  Quot.ind\n                    (fun (a_1 : ModuleCat.Colimits.Prequotient F) ↦\n                      Eq.refl (ModuleCat.Colimits.descFun F s (Quot.mk Setoid.r a + Quot.mk Setoid.r a_1)))\n                    y)\n                x))) }\n        x", "terms": [{"value": "Quot.mk Setoid.r a + Quot.mk Setoid.r a_1", "isProp": false, "context": ["{R : Type u_1}", "[Ring R]", "{J : Type u_3}", "[CategoryTheory.Category J]", "(F : CategoryTheory.Functor J (ModuleCat R))", "(s : CategoryTheory.Limits.Cocone F)", "(s_1 : R)", "(x : ↑(ModuleCat.Colimits.colimit F))", "(a : ModuleCat.Colimits.Prequotient F)", "(x : ↑(ModuleCat.Colimits.colimit F))", "(y : ↑(ModuleCat.Colimits.colimit F))", "(a : ModuleCat.Colimits.Prequotient F)", "(a_1 : ModuleCat.Colimits.Prequotient F)"]}, {"value": "{ toFun := ((ModuleCat.Colimits.descFun F s)),\n  map_add' :=\n    (((fun (x : ↑(ModuleCat.Colimits.colimit F)) (y : ↑(ModuleCat.Colimits.colimit F)) ↦\n      Quot.ind\n        (fun (a : ModuleCat.Colimits.Prequotient F) ↦\n          Quot.ind\n            (fun (a_1 : ModuleCat.Colimits.Prequotient F) ↦\n              Eq.refl (ModuleCat.Colimits.descFun F s (Quot.mk Setoid.r a + Quot.mk Setoid.r a_1)))\n            y)\n        x))) }", "isProp": false, "context": ["{R : Type u_1}", "[Ring R]", "{J : Type u_3}", "[CategoryTheory.Category J]", "(F : CategoryTheory.Functor J (ModuleCat R))", "(s : CategoryTheory.Limits.Cocone F)", "(s_1 : R)", "(x : ↑(ModuleCat.Colimits.colimit F))", "(a : ModuleCat.Colimits.Prequotient F)"]}, {"value": "s_1 • Quot.mk Setoid.r a", "isProp": false, "context": ["{R : Type u_1}", "[Ring R]", "{J : Type u_3}", "[CategoryTheory.Category J]", "(F : CategoryTheory.Functor J (ModuleCat R))", "(s : CategoryTheory.Limits.Cocone F)", "(s_1 : R)", "(x : ↑(ModuleCat.Colimits.colimit F))", "(a : ModuleCat.Colimits.Prequotient F)"]}], "namedLemmas": [], "lemmas": [{"prop": "∀ (a_1 : ModuleCat.Colimits.Prequotient F),\n  ModuleCat.Colimits.descFun F s (Quot.mk Setoid.r a + Quot.mk Setoid.r a_1) =\n    ModuleCat.Colimits.descFun F s (Quot.mk Setoid.r a + Quot.mk Setoid.r a_1)", "context": ["{R : Type u_1}", "[Ring R]", "{J : Type u_3}", "[CategoryTheory.Category J]", "(F : CategoryTheory.Functor J (ModuleCat R))", "(s : CategoryTheory.Limits.Cocone F)", "(s_1 : R)", "(x : ↑(ModuleCat.Colimits.colimit F))", "(a : ModuleCat.Colimits.Prequotient F)", "(x : ↑(ModuleCat.Colimits.colimit F))", "(y : ↑(ModuleCat.Colimits.colimit F))", "(a : ModuleCat.Colimits.Prequotient F)"]}, {"prop": "∀ (a : ModuleCat.Colimits.Prequotient F),\n  ModuleCat.Colimits.descFun F s (Quot.mk Setoid.r a + y) =\n    ModuleCat.Colimits.descFun F s (Quot.mk Setoid.r a) + ModuleCat.Colimits.descFun F s y", "context": ["{R : Type u_1}", "[Ring R]", "{J : Type u_3}", "[CategoryTheory.Category J]", "(F : CategoryTheory.Functor J (ModuleCat R))", "(s : CategoryTheory.Limits.Cocone F)", "(s_1 : R)", "(x : ↑(ModuleCat.Colimits.colimit F))", "(a : ModuleCat.Colimits.Prequotient F)", "(x : ↑(ModuleCat.Colimits.colimit F))", "(y : ↑(ModuleCat.Colimits.colimit F))"]}, {"prop": "∀ (x : ↑(ModuleCat.Colimits.colimit F)) (y : ↑(ModuleCat.Colimits.colimit F)),\n  ModuleCat.Colimits.descFun F s (x + y) = ModuleCat.Colimits.descFun F s x + ModuleCat.Colimits.descFun F s y", "context": ["{R : Type u_1}", "[Ring R]", "{J : Type u_3}", "[CategoryTheory.Category J]", "(F : CategoryTheory.Functor J (ModuleCat R))", "(s : CategoryTheory.Limits.Cocone F)", "(s_1 : R)", "(x : ↑(ModuleCat.Colimits.colimit F))", "(a : ModuleCat.Colimits.Prequotient F)"]}, {"prop": "∀ (a : ModuleCat.Colimits.Prequotient F),\n  AddHom.toFun\n      { toFun := ((ModuleCat.Colimits.descFun F s)),\n        map_add' :=\n          (((fun (x : ↑(ModuleCat.Colimits.colimit F)) (y : ↑(ModuleCat.Colimits.colimit F)) ↦\n            Quot.ind\n              (fun (a : ModuleCat.Colimits.Prequotient F) ↦\n                Quot.ind\n                  (fun (a_1 : ModuleCat.Colimits.Prequotient F) ↦\n                    Eq.refl (ModuleCat.Colimits.descFun F s (Quot.mk Setoid.r a + Quot.mk Setoid.r a_1)))\n                  y)\n              x))) }\n      (s_1 • Quot.mk Setoid.r a) =\n    AddHom.toFun\n      { toFun := ((ModuleCat.Colimits.descFun F s)),\n        map_add' :=\n          (((fun (x : ↑(ModuleCat.Colimits.colimit F)) (y : ↑(ModuleCat.Colimits.colimit F)) ↦\n            Quot.ind\n              (fun (a : ModuleCat.Colimits.Prequotient F) ↦\n                Quot.ind\n                  (fun (a_1 : ModuleCat.Colimits.Prequotient F) ↦\n                    Eq.refl (ModuleCat.Colimits.descFun F s (Quot.mk Setoid.r a + Quot.mk Setoid.r a_1)))\n                  y)\n              x))) }\n      (s_1 • Quot.mk Setoid.r a)", "context": ["{R : Type u_1}", "[Ring R]", "{J : Type u_3}", "[CategoryTheory.Category J]", "(F : CategoryTheory.Functor J (ModuleCat R))", "(s : CategoryTheory.Limits.Cocone F)", "(s_1 : R)", "(x : ↑(ModuleCat.Colimits.colimit F))"]}], "ids": ["Quot.ind", "Eq.refl", "AddHom.toFun", "toFun", "ModuleCat.Colimits.descFun", "map_add'", "Quot.ind", "Quot.ind", "Eq.refl", "ModuleCat.Colimits.descFun", "Quot.mk", "Setoid.r", "Quot.mk", "Setoid.r", "Quot.mk", "Setoid.r"], "idString": "Quot.ind; Eq.refl; AddHom.toFun; toFun; ModuleCat.Colimits.descFun; map_add'; Quot.ind; Quot.ind; Eq.refl; ModuleCat.Colimits.descFun; Quot.mk; Setoid.r; Quot.mk; Setoid.r; Quot.mk; Setoid.r; ", "context": []}
{"typeGroup": "(∀ (α : Type u_1) {X : Set α} {Y : Set α} {Z : Set α} (f : X ⟶ Y) (g : Y ⟶ Z),\n    (CategoryTheory.MonoOver.homMk fun (w : { x : α // x ∈ X }) ↦\n        { val := ((↑w)),\n          property :=\n            (((Set.mem_of_mem_of_subset (Subtype.property w=:↑w ∈ X)\n                (Quiver.Hom.le (CategoryTheory.CategoryStruct.comp f g)=:X ≤ Z)=:↑w ∈ Z))) }) =\n      CategoryTheory.CategoryStruct.comp\n        (CategoryTheory.MonoOver.homMk fun (w : { x : α // x ∈ X }) ↦\n          { val := ((↑w)),\n            property := (((Set.mem_of_mem_of_subset (Subtype.property w=:↑w ∈ X) (Quiver.Hom.le f=:X ≤ Y)=:↑w ∈ Y))) })\n        (CategoryTheory.MonoOver.homMk fun (w : { x : α // x ∈ Y }) ↦\n          { val := ((↑w)),\n            property :=\n              (((Set.mem_of_mem_of_subset (Subtype.property w=:↑w ∈ Y) (Quiver.Hom.le g=:Y ≤ Z)=:↑w ∈ Z))) }) :\n  Prop)", "type": "∀ (α : Type u_1) {X : Set α} {Y : Set α} {Z : Set α} (f : X ⟶ Y) (g : Y ⟶ Z),\n  (CategoryTheory.MonoOver.homMk fun (w : { x : α // x ∈ X }) ↦\n      { val := ((↑w)),\n        property :=\n          (((Set.mem_of_mem_of_subset (Subtype.property w)\n            (Quiver.Hom.le (CategoryTheory.CategoryStruct.comp f g))))) }) =\n    CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoOver.homMk fun (w : { x : α // x ∈ X }) ↦\n        { val := ((↑w)), property := (((Set.mem_of_mem_of_subset (Subtype.property w) (Quiver.Hom.le f)))) })\n      (CategoryTheory.MonoOver.homMk fun (w : { x : α // x ∈ Y }) ↦\n        { val := ((↑w)), property := (((Set.mem_of_mem_of_subset (Subtype.property w) (Quiver.Hom.le g)))) })", "thm": " : ∀ (α : Type u_1) {X : Set α} {Y : Set α} {Z : Set α} (f : X ⟶ Y) (g : Y ⟶ Z),\n  (CategoryTheory.MonoOver.homMk fun (w : { x : α // x ∈ X }) ↦\n      { val := ((↑w)),\n        property :=\n          (((Set.mem_of_mem_of_subset (Subtype.property w)\n            (Quiver.Hom.le (CategoryTheory.CategoryStruct.comp f g))))) }) =\n    CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoOver.homMk fun (w : { x : α // x ∈ X }) ↦\n        { val := ((↑w)), property := (((Set.mem_of_mem_of_subset (Subtype.property w) (Quiver.Hom.le f)))) })\n      (CategoryTheory.MonoOver.homMk fun (w : { x : α // x ∈ Y }) ↦\n        { val := ((↑w)), property := (((Set.mem_of_mem_of_subset (Subtype.property w) (Quiver.Hom.le g)))) })", "terms": [{"value": "CategoryTheory.CategoryStruct.comp f g", "isProp": false, "context": ["(α : Type u_1)", "{X : Set α}", "{Y : Set α}", "{Z : Set α}", "(f : X ⟶ Y)", "(g : Y ⟶ Z)", "(w : { x : α // x ∈ X })"]}, {"value": "CategoryTheory.MonoOver.homMk fun (w : { x : α // x ∈ X }) ↦\n  { val := ((↑w)),\n    property :=\n      (((Set.mem_of_mem_of_subset (Subtype.property w) (Quiver.Hom.le (CategoryTheory.CategoryStruct.comp f g))))) }", "isProp": false, "context": ["(α : Type u_1)", "{X : Set α}", "{Y : Set α}", "{Z : Set α}", "(f : X ⟶ Y)", "(g : Y ⟶ Z)"]}, {"value": "CategoryTheory.MonoOver.homMk fun (w : { x : α // x ∈ X }) ↦\n  { val := ((↑w)), property := (((Set.mem_of_mem_of_subset (Subtype.property w) (Quiver.Hom.le f)))) }", "isProp": false, "context": ["(α : Type u_1)", "{X : Set α}", "{Y : Set α}", "{Z : Set α}", "(f : X ⟶ Y)", "(g : Y ⟶ Z)"]}, {"value": "CategoryTheory.MonoOver.homMk fun (w : { x : α // x ∈ Y }) ↦\n  { val := ((↑w)), property := (((Set.mem_of_mem_of_subset (Subtype.property w) (Quiver.Hom.le g)))) }", "isProp": false, "context": ["(α : Type u_1)", "{X : Set α}", "{Y : Set α}", "{Z : Set α}", "(f : X ⟶ Y)", "(g : Y ⟶ Z)"]}, {"value": "CategoryTheory.CategoryStruct.comp\n  (CategoryTheory.MonoOver.homMk fun (w : { x : α // x ∈ X }) ↦\n    { val := ((↑w)), property := (((Set.mem_of_mem_of_subset (Subtype.property w) (Quiver.Hom.le f)))) })\n  (CategoryTheory.MonoOver.homMk fun (w : { x : α // x ∈ Y }) ↦\n    { val := ((↑w)), property := (((Set.mem_of_mem_of_subset (Subtype.property w) (Quiver.Hom.le g)))) })", "isProp": false, "context": ["(α : Type u_1)", "{X : Set α}", "{Y : Set α}", "{Z : Set α}", "(f : X ⟶ Y)", "(g : Y ⟶ Z)"]}], "namedLemmas": ["∀ {p : Prop}, p = True → p", "∀ {α : Type u} {x : α} {s t : Set α}, x ∈ s → s ⊆ t → x ∈ t", "∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self", "∀ {X : Type u} [inst : Preorder X] {x y : X}, (x ⟶ y) → x ≤ y", "∀ {α : Type u} {x : α} {s t : Set α}, x ∈ s → s ⊆ t → x ∈ t", "∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self", "∀ {X : Type u} [inst : Preorder X] {x y : X}, (x ⟶ y) → x ≤ y", "∀ {α : Type u} {x : α} {s t : Set α}, x ∈ s → s ⊆ t → x ∈ t", "∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self", "∀ {X : Type u} [inst : Preorder X] {x y : X}, (x ⟶ y) → x ≤ y"], "lemmas": [{"prop": "↑w ∈ X", "context": ["(α : Type u_1)", "{X : Set α}", "{Y : Set α}", "{Z : Set α}", "(f : X ⟶ Y)", "(g : Y ⟶ Z)", "(w : { x : α // x ∈ X })"]}, {"prop": "X ≤ Z", "context": ["(α : Type u_1)", "{X : Set α}", "{Y : Set α}", "{Z : Set α}", "(f : X ⟶ Y)", "(g : Y ⟶ Z)", "(w : { x : α // x ∈ X })"]}, {"prop": "↑w ∈ Z", "context": ["(α : Type u_1)", "{X : Set α}", "{Y : Set α}", "{Z : Set α}", "(f : X ⟶ Y)", "(g : Y ⟶ Z)", "(w : { x : α // x ∈ X })"]}, {"prop": "↑w ∈ X", "context": ["(α : Type u_1)", "{X : Set α}", "{Y : Set α}", "{Z : Set α}", "(f : X ⟶ Y)", "(g : Y ⟶ Z)", "(w : { x : α // x ∈ X })"]}, {"prop": "X ≤ Y", "context": ["(α : Type u_1)", "{X : Set α}", "{Y : Set α}", "{Z : Set α}", "(f : X ⟶ Y)", "(g : Y ⟶ Z)", "(w : { x : α // x ∈ X })"]}, {"prop": "↑w ∈ Y", "context": ["(α : Type u_1)", "{X : Set α}", "{Y : Set α}", "{Z : Set α}", "(f : X ⟶ Y)", "(g : Y ⟶ Z)", "(w : { x : α // x ∈ X })"]}, {"prop": "↑w ∈ Y", "context": ["(α : Type u_1)", "{X : Set α}", "{Y : Set α}", "{Z : Set α}", "(f : X ⟶ Y)", "(g : Y ⟶ Z)", "(w : { x : α // x ∈ Y })"]}, {"prop": "Y ≤ Z", "context": ["(α : Type u_1)", "{X : Set α}", "{Y : Set α}", "{Z : Set α}", "(f : X ⟶ Y)", "(g : Y ⟶ Z)", "(w : { x : α // x ∈ Y })"]}, {"prop": "↑w ∈ Z", "context": ["(α : Type u_1)", "{X : Set α}", "{Y : Set α}", "{Z : Set α}", "(f : X ⟶ Y)", "(g : Y ⟶ Z)", "(w : { x : α // x ∈ Y })"]}, {"prop": "((CategoryTheory.MonoOver.homMk fun (w : { x : α // x ∈ X }) ↦\n      { val := ((↑w)),\n        property :=\n          (((Set.mem_of_mem_of_subset (Subtype.property w)\n            (Quiver.Hom.le (CategoryTheory.CategoryStruct.comp f g))))) }) =\n    CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoOver.homMk fun (w : { x : α // x ∈ X }) ↦\n        { val := ((↑w)), property := (((Set.mem_of_mem_of_subset (Subtype.property w) (Quiver.Hom.le f)))) })\n      (CategoryTheory.MonoOver.homMk fun (w : { x : α // x ∈ Y }) ↦\n        { val := ((↑w)), property := (((Set.mem_of_mem_of_subset (Subtype.property w) (Quiver.Hom.le g)))) })) =\n  True", "context": ["(α : Type u_1)", "{X : Set α}", "{Y : Set α}", "{Z : Set α}", "(f : X ⟶ Y)", "(g : Y ⟶ Z)"]}], "ids": ["of_eq_true", "Mathlib.Logic.Unique._auxLemma.1", "CategoryTheory.MonoOver.homMk", "val", "property", "Set.mem_of_mem_of_subset", "Subtype.property", "Quiver.Hom.le", "CategoryTheory.CategoryStruct.comp", "CategoryTheory.CategoryStruct.comp", "CategoryTheory.MonoOver.homMk", "val", "property", "Set.mem_of_mem_of_subset", "Subtype.property", "Quiver.Hom.le", "CategoryTheory.MonoOver.homMk", "val", "property", "Set.mem_of_mem_of_subset", "Subtype.property", "Quiver.Hom.le"], "idString": "of_eq_true; Mathlib.Logic.Unique._auxLemma.1; CategoryTheory.MonoOver.homMk; val; property; Set.mem_of_mem_of_subset; Subtype.property; Quiver.Hom.le; CategoryTheory.CategoryStruct.comp; CategoryTheory.CategoryStruct.comp; CategoryTheory.MonoOver.homMk; val; property; Set.mem_of_mem_of_subset; Subtype.property; Quiver.Hom.le; CategoryTheory.MonoOver.homMk; val; property; Set.mem_of_mem_of_subset; Subtype.property; Quiver.Hom.le; ", "context": []}
{"typeGroup": "(∀ {α : Type u} {β : Type v} {f : (a : α) → β},\n    Finset.preimage ∅ f\n        (of_eq_true\n            (Eq.trans\n                (forall_congr\n                    (fun ⦃x₁ : α⦄ ↦\n                      (_ :\n                        (∀ (a : x₁ ∈ f ⁻¹' ↑∅) (a : α) (a_1 : a ∈ f ⁻¹' ↑∅) (a_2 : f x₁ = f a), x₁ = a : Prop) =\n                          (True :\n                            Prop))=:∀ ⦃x₁ : α⦄,\n                        (∀ (a : x₁ ∈ f ⁻¹' ↑∅) (a : α) (a_1 : a ∈ f ⁻¹' ↑∅) (a_2 : f x₁ = f a), x₁ = a : Prop) =\n                          (True :\n                            Prop))=:(∀ (a : α) (a_1 : a ∈ f ⁻¹' ↑∅) (a_2 : α) (a_3 : a_2 ∈ f ⁻¹' ↑∅)\n                        (a_4 : f a = f a_2), a = a_2 :\n                      Prop) =\n                    (∀ (a : α), True : Prop))\n                (implies_true\n                    α=:(∀ (a : α), True : Prop) =\n                    (True :\n                      Prop))=:(∀ (a : α) (a_1 : a ∈ f ⁻¹' ↑∅) (a_2 : α) (a_3 : a_2 ∈ f ⁻¹' ↑∅) (a_4 : f a = f a_2),\n                    a = a_2 :\n                  Prop) =\n                (True :\n                  Prop))=:∀ (a : α) (a_1 : a ∈ f ⁻¹' ↑∅) (a_2 : α) (a_3 : a_2 ∈ f ⁻¹' ↑∅) (a_4 : f a = f a_2),\n            a = a_2) =\n      ∅ :\n  Prop)", "type": "∀ {α : Type u} {β : Type v} {f : (a : α) → β},\n  Finset.preimage ∅ f\n      (of_eq_true\n        (Eq.trans\n          (forall_congr\n            (fun ⦃x₁ : α⦄ ↦\n              Eq.trans\n                (implies_congr\n                  (Eq.trans (congrArg (Membership.mem x₁) (congrArg (Set.preimage f) Finset.coe_empty))\n                    (Mathlib.Data.Set.Basic._auxLemma.8 x₁))\n                  (Eq.trans\n                    (forall_congr\n                      (fun ⦃x₂ : α⦄ ↦\n                        Eq.trans\n                          (implies_congr\n                            (Eq.trans (congrArg (Membership.mem x₂) (congrArg (Set.preimage f) Finset.coe_empty))\n                              (Mathlib.Data.Set.Basic._auxLemma.8 x₂))\n                            (Eq.refl (∀ (a : f x₁ = f x₂), x₁ = x₂)))\n                          Mathlib.Logic.IsEmpty._auxLemma.1))\n                    (implies_true α)))\n                Mathlib.Logic.IsEmpty._auxLemma.1))\n          (implies_true α))) =\n    ∅", "thm": " : ∀ {α : Type u} {β : Type v} {f : (a : α) → β},\n  Finset.preimage ∅ f\n      (of_eq_true\n        (Eq.trans\n          (forall_congr\n            (fun ⦃x₁ : α⦄ ↦\n              Eq.trans\n                (implies_congr\n                  (Eq.trans (congrArg (Membership.mem x₁) (congrArg (Set.preimage f) Finset.coe_empty))\n                    (Mathlib.Data.Set.Basic._auxLemma.8 x₁))\n                  (Eq.trans\n                    (forall_congr\n                      (fun ⦃x₂ : α⦄ ↦\n                        Eq.trans\n                          (implies_congr\n                            (Eq.trans (congrArg (Membership.mem x₂) (congrArg (Set.preimage f) Finset.coe_empty))\n                              (Mathlib.Data.Set.Basic._auxLemma.8 x₂))\n                            (Eq.refl (∀ (a : f x₁ = f x₂), x₁ = x₂)))\n                          Mathlib.Logic.IsEmpty._auxLemma.1))\n                    (implies_true α)))\n                Mathlib.Logic.IsEmpty._auxLemma.1))\n          (implies_true α))) =\n    ∅", "terms": [{"value": "∅", "isProp": false, "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}"]}, {"value": "Membership.mem x₁", "isProp": false, "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}", "⦃x₁ : α⦄"]}, {"value": "Set.preimage f", "isProp": false, "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}", "⦃x₁ : α⦄"]}, {"value": "Membership.mem x₂", "isProp": false, "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}", "⦃x₁ : α⦄", "⦃x₂ : α⦄"]}, {"value": "Set.preimage f", "isProp": false, "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}", "⦃x₁ : α⦄", "⦃x₂ : α⦄"]}, {"value": "Set.preimage f", "isProp": false, "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}"]}], "namedLemmas": ["∀ {α : Type u_1}, Function.Injective Finset.toSet", "∀ {p : Prop}, p = True → p", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Type u} {β : Type v} {f : α → β} (s : Finset β) (hf : Set.InjOn f (f ⁻¹' ↑s)),\n  ↑(Finset.preimage s f hf) = f ⁻¹' ↑s", "∀ {p : Prop}, p = True → p", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂)", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Type u_1}, ↑∅ = ∅", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂)", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Type u_1}, ↑∅ = ∅", "∀ (α : Sort u), (α → True) = True", "∀ (α : Sort u), (α → True) = True", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Type u_1}, ↑∅ = ∅", "∀ {α : Type u_1}, ↑∅ = ∅", "∀ {α : Sort u_1} (a : α), (a = a) = True"], "lemmas": [{"prop": "↑∅ = ∅", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}", "⦃x₁ : α⦄"]}, {"prop": "f ⁻¹' ↑∅ = f ⁻¹' ∅", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}", "⦃x₁ : α⦄"]}, {"prop": "(x₁ ∈ f ⁻¹' ↑∅) = (x₁ ∈ f ⁻¹' ∅)", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}", "⦃x₁ : α⦄"]}, {"prop": "(x₁ ∈ ∅) = False", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}", "⦃x₁ : α⦄"]}, {"prop": "(x₁ ∈ f ⁻¹' ↑∅) = False", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}", "⦃x₁ : α⦄"]}, {"prop": "↑∅ = ∅", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}", "⦃x₁ : α⦄", "⦃x₂ : α⦄"]}, {"prop": "f ⁻¹' ↑∅ = f ⁻¹' ∅", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}", "⦃x₁ : α⦄", "⦃x₂ : α⦄"]}, {"prop": "(x₂ ∈ f ⁻¹' ↑∅) = (x₂ ∈ f ⁻¹' ∅)", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}", "⦃x₁ : α⦄", "⦃x₂ : α⦄"]}, {"prop": "(x₂ ∈ ∅) = False", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}", "⦃x₁ : α⦄", "⦃x₂ : α⦄"]}, {"prop": "(x₂ ∈ f ⁻¹' ↑∅) = False", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}", "⦃x₁ : α⦄", "⦃x₂ : α⦄"]}, {"prop": "(∀ (a : f x₁ = f x₂), x₁ = x₂) = (∀ (a : f x₁ = f x₂), x₁ = x₂)", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}", "⦃x₁ : α⦄", "⦃x₂ : α⦄"]}, {"prop": "(∀ (a : x₂ ∈ f ⁻¹' ↑∅) (a : f x₁ = f x₂), x₁ = x₂) = (∀ (a : False) (a : f x₁ = f x₂), x₁ = x₂)", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}", "⦃x₁ : α⦄", "⦃x₂ : α⦄"]}, {"prop": "(∀ (a : False) (a : f x₁ = f x₂), x₁ = x₂) = True", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}", "⦃x₁ : α⦄", "⦃x₂ : α⦄"]}, {"prop": "∀ ⦃x₂ : α⦄, (∀ (a : x₂ ∈ f ⁻¹' ↑∅) (a : f x₁ = f x₂), x₁ = x₂) = True", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}", "⦃x₁ : α⦄"]}, {"prop": "(∀ (a : α) (a_1 : a ∈ f ⁻¹' ↑∅) (a_2 : f x₁ = f a), x₁ = a) = (∀ (a : α), True)", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}", "⦃x₁ : α⦄"]}, {"prop": "(∀ (a : α), True) = True", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}", "⦃x₁ : α⦄"]}, {"prop": "(∀ (a : α) (a_1 : a ∈ f ⁻¹' ↑∅) (a_2 : f x₁ = f a), x₁ = a) = True", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}", "⦃x₁ : α⦄"]}, {"prop": "(∀ (a : x₁ ∈ f ⁻¹' ↑∅) (a : α) (a_1 : a ∈ f ⁻¹' ↑∅) (a_2 : f x₁ = f a), x₁ = a) = (∀ (a : False), True)", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}", "⦃x₁ : α⦄"]}, {"prop": "(∀ (a : False), True) = True", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}", "⦃x₁ : α⦄"]}, {"prop": "∀ ⦃x₁ : α⦄, (∀ (a : x₁ ∈ f ⁻¹' ↑∅) (a : α) (a_1 : a ∈ f ⁻¹' ↑∅) (a_2 : f x₁ = f a), x₁ = a) = True", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}"]}, {"prop": "(∀ (a : α) (a_1 : a ∈ f ⁻¹' ↑∅) (a_2 : α) (a_3 : a_2 ∈ f ⁻¹' ↑∅) (a_4 : f a = f a_2), a = a_2) = (∀ (a : α), True)", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}"]}, {"prop": "(∀ (a : α), True) = True", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}"]}, {"prop": "(∀ (a : α) (a_1 : a ∈ f ⁻¹' ↑∅) (a_2 : α) (a_3 : a_2 ∈ f ⁻¹' ↑∅) (a_4 : f a = f a_2), a = a_2) = True", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}"]}, {"prop": "∀ (a : α) (a_1 : a ∈ f ⁻¹' ↑∅) (a_2 : α) (a_3 : a_2 ∈ f ⁻¹' ↑∅) (a_4 : f a = f a_2), a = a_2", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}"]}, {"prop": "↑(Finset.preimage ∅ f\n      (of_eq_true\n        (Eq.trans\n          (forall_congr\n            (fun ⦃x₁ : α⦄ ↦\n              Eq.trans\n                (implies_congr\n                  (Eq.trans (congrArg (Membership.mem x₁) (congrArg (Set.preimage f) Finset.coe_empty))\n                    (Mathlib.Data.Set.Basic._auxLemma.8 x₁))\n                  (Eq.trans\n                    (forall_congr\n                      (fun ⦃x₂ : α⦄ ↦\n                        Eq.trans\n                          (implies_congr\n                            (Eq.trans (congrArg (Membership.mem x₂) (congrArg (Set.preimage f) Finset.coe_empty))\n                              (Mathlib.Data.Set.Basic._auxLemma.8 x₂))\n                            (Eq.refl (∀ (a : f x₁ = f x₂), x₁ = x₂)))\n                          Mathlib.Logic.IsEmpty._auxLemma.1))\n                    (implies_true α)))\n                Mathlib.Logic.IsEmpty._auxLemma.1))\n          (implies_true α)))) =\n  f ⁻¹' ↑∅", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}"]}, {"prop": "↑∅ = ∅", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}"]}, {"prop": "f ⁻¹' ↑∅ = f ⁻¹' ∅", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}"]}, {"prop": "↑(Finset.preimage ∅ f\n      (of_eq_true\n        (Eq.trans\n          (forall_congr\n            (fun ⦃x₁ : α⦄ ↦\n              Eq.trans\n                (implies_congr\n                  (Eq.trans (congrArg (Membership.mem x₁) (congrArg (Set.preimage f) Finset.coe_empty))\n                    (Mathlib.Data.Set.Basic._auxLemma.8 x₁))\n                  (Eq.trans\n                    (forall_congr\n                      (fun ⦃x₂ : α⦄ ↦\n                        Eq.trans\n                          (implies_congr\n                            (Eq.trans (congrArg (Membership.mem x₂) (congrArg (Set.preimage f) Finset.coe_empty))\n                              (Mathlib.Data.Set.Basic._auxLemma.8 x₂))\n                            (Eq.refl (∀ (a : f x₁ = f x₂), x₁ = x₂)))\n                          Mathlib.Logic.IsEmpty._auxLemma.1))\n                    (implies_true α)))\n                Mathlib.Logic.IsEmpty._auxLemma.1))\n          (implies_true α)))) =\n  f ⁻¹' ∅", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}"]}, {"prop": "Eq\n    ↑(Finset.preimage ∅ f\n        (of_eq_true\n          (Eq.trans\n            (forall_congr\n              (fun ⦃x₁ : α⦄ ↦\n                Eq.trans\n                  (implies_congr\n                    (Eq.trans (congrArg (Membership.mem x₁) (congrArg (Set.preimage f) Finset.coe_empty))\n                      (Mathlib.Data.Set.Basic._auxLemma.8 x₁))\n                    (Eq.trans\n                      (forall_congr\n                        (fun ⦃x₂ : α⦄ ↦\n                          Eq.trans\n                            (implies_congr\n                              (Eq.trans (congrArg (Membership.mem x₂) (congrArg (Set.preimage f) Finset.coe_empty))\n                                (Mathlib.Data.Set.Basic._auxLemma.8 x₂))\n                              (Eq.refl (∀ (a : f x₁ = f x₂), x₁ = x₂)))\n                            Mathlib.Logic.IsEmpty._auxLemma.1))\n                      (implies_true α)))\n                  Mathlib.Logic.IsEmpty._auxLemma.1))\n            (implies_true α)))) =\n  Eq (f ⁻¹' ∅)", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}"]}, {"prop": "↑∅ = ∅", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}"]}, {"prop": "(↑(Finset.preimage ∅ f\n        (of_eq_true\n          (Eq.trans\n            (forall_congr\n              (fun ⦃x₁ : α⦄ ↦\n                Eq.trans\n                  (implies_congr\n                    (Eq.trans (congrArg (Membership.mem x₁) (congrArg (Set.preimage f) Finset.coe_empty))\n                      (Mathlib.Data.Set.Basic._auxLemma.8 x₁))\n                    (Eq.trans\n                      (forall_congr\n                        (fun ⦃x₂ : α⦄ ↦\n                          Eq.trans\n                            (implies_congr\n                              (Eq.trans (congrArg (Membership.mem x₂) (congrArg (Set.preimage f) Finset.coe_empty))\n                                (Mathlib.Data.Set.Basic._auxLemma.8 x₂))\n                              (Eq.refl (∀ (a : f x₁ = f x₂), x₁ = x₂)))\n                            Mathlib.Logic.IsEmpty._auxLemma.1))\n                      (implies_true α)))\n                  Mathlib.Logic.IsEmpty._auxLemma.1))\n            (implies_true α)))) =\n    ↑∅) =\n  (f ⁻¹' ∅ = ∅)", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}"]}, {"prop": "(∅ = ∅) = True", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}"]}, {"prop": "(↑(Finset.preimage ∅ f\n        (of_eq_true\n          (Eq.trans\n            (forall_congr\n              (fun ⦃x₁ : α⦄ ↦\n                Eq.trans\n                  (implies_congr\n                    (Eq.trans (congrArg (Membership.mem x₁) (congrArg (Set.preimage f) Finset.coe_empty))\n                      (Mathlib.Data.Set.Basic._auxLemma.8 x₁))\n                    (Eq.trans\n                      (forall_congr\n                        (fun ⦃x₂ : α⦄ ↦\n                          Eq.trans\n                            (implies_congr\n                              (Eq.trans (congrArg (Membership.mem x₂) (congrArg (Set.preimage f) Finset.coe_empty))\n                                (Mathlib.Data.Set.Basic._auxLemma.8 x₂))\n                              (Eq.refl (∀ (a : f x₁ = f x₂), x₁ = x₂)))\n                            Mathlib.Logic.IsEmpty._auxLemma.1))\n                      (implies_true α)))\n                  Mathlib.Logic.IsEmpty._auxLemma.1))\n            (implies_true α)))) =\n    ↑∅) =\n  True", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}"]}, {"prop": "↑(Finset.preimage ∅ f\n      (of_eq_true\n        (Eq.trans\n          (forall_congr\n            (fun ⦃x₁ : α⦄ ↦\n              Eq.trans\n                (implies_congr\n                  (Eq.trans (congrArg (Membership.mem x₁) (congrArg (Set.preimage f) Finset.coe_empty))\n                    (Mathlib.Data.Set.Basic._auxLemma.8 x₁))\n                  (Eq.trans\n                    (forall_congr\n                      (fun ⦃x₂ : α⦄ ↦\n                        Eq.trans\n                          (implies_congr\n                            (Eq.trans (congrArg (Membership.mem x₂) (congrArg (Set.preimage f) Finset.coe_empty))\n                              (Mathlib.Data.Set.Basic._auxLemma.8 x₂))\n                            (Eq.refl (∀ (a : f x₁ = f x₂), x₁ = x₂)))\n                          Mathlib.Logic.IsEmpty._auxLemma.1))\n                    (implies_true α)))\n                Mathlib.Logic.IsEmpty._auxLemma.1))\n          (implies_true α)))) =\n  ↑∅", "context": ["{α : Type u}", "{β : Type v}", "{f : (a : α) → β}"]}], "ids": ["Finset.coe_injective", "of_eq_true", "Eq.trans", "congr", "congrArg", "Eq", "Eq.trans", "Finset.coe_preimage", "of_eq_true", "Eq.trans", "forall_congr", "Eq.trans", "implies_congr", "Eq.trans", "congrArg", "Membership.mem", "congrArg", "Set.preimage", "Finset.coe_empty", "Mathlib.Data.Set.Basic._auxLemma.8", "Eq.trans", "forall_congr", "Eq.trans", "implies_congr", "Eq.trans", "congrArg", "Membership.mem", "congrArg", "Set.preimage", "Finset.coe_empty", "Mathlib.Data.Set.Basic._auxLemma.8", "Eq.refl", "a", "Mathlib.Logic.IsEmpty._auxLemma.1", "implies_true", "Mathlib.Logic.IsEmpty._auxLemma.1", "implies_true", "congrArg", "Set.preimage", "Finset.coe_empty", "Finset.coe_empty", "eq_self"], "idString": "Finset.coe_injective; of_eq_true; Eq.trans; congr; congrArg; Eq; Eq.trans; Finset.coe_preimage; of_eq_true; Eq.trans; forall_congr; Eq.trans; implies_congr; Eq.trans; congrArg; Membership.mem; congrArg; Set.preimage; Finset.coe_empty; Mathlib.Data.Set.Basic._auxLemma.8; Eq.trans; forall_congr; Eq.trans; implies_congr; Eq.trans; congrArg; Membership.mem; congrArg; Set.preimage; Finset.coe_empty; Mathlib.Data.Set.Basic._auxLemma.8; Eq.refl; a; Mathlib.Logic.IsEmpty._auxLemma.1; implies_true; Mathlib.Logic.IsEmpty._auxLemma.1; implies_true; congrArg; Set.preimage; Finset.coe_empty; Finset.coe_empty; eq_self; ", "context": []}
{"typeGroup": "(∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) (x : { x : G // x ∈ H }) (x_1 : { x : G // x ∈ H }),\n    OneHom.toFun { toFun := ((Subtype.val)), map_one' := (((rfl=:↑1 = ↑1))) } (x * x_1) =\n      OneHom.toFun { toFun := ((Subtype.val)), map_one' := (((rfl=:↑1 = ↑1))) } (x * x_1) :\n  Prop)", "type": "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) (x : { x : G // x ∈ H }) (x_1 : { x : G // x ∈ H }),\n  OneHom.toFun { toFun := ((Subtype.val)), map_one' := ((rfl)) } (x * x_1) =\n    OneHom.toFun { toFun := ((Subtype.val)), map_one' := ((rfl)) } (x * x_1)", "thm": " : ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) (x : { x : G // x ∈ H }) (x_1 : { x : G // x ∈ H }),\n  OneHom.toFun { toFun := ((Subtype.val)), map_one' := ((rfl)) } (x * x_1) =\n    OneHom.toFun { toFun := ((Subtype.val)), map_one' := ((rfl)) } (x * x_1)", "terms": [], "namedLemmas": ["∀ {α : Sort u} {a : α}, a = a"], "lemmas": [], "ids": ["rfl"], "idString": "rfl; ", "context": []}
{"typeGroup": "(∀ (C : Type u₁) [inst : CategoryTheory.Category C] [inst_1 : Quiver.IsThin C] {x : CategoryTheory.ThinSkeleton C}\n    {y : CategoryTheory.ThinSkeleton C} (a : x ⟶ y),\n    (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ThinSkeleton.fromThinSkeleton C)).map a =\n      Quotient.recOnSubsingleton₂ (motive :=\n        fun (x : CategoryTheory.ThinSkeleton C) (x_1 : CategoryTheory.ThinSkeleton C) ↦\n        (a : x ⟶ x_1) → Quotient.out x ⟶ Quotient.out x_1) x y\n        (fun (X : C) (Y : C)\n            (f :\n              Quotient.mk (CategoryTheory.isIsomorphicSetoid C) X ⟶\n                Quotient.mk (CategoryTheory.isIsomorphicSetoid C) Y) ↦\n          CategoryTheory.CategoryStruct.comp\n            (Nonempty.some\n                (CategoryTheory.ThinSkeleton.fromThinSkeleton.proof_2 C\n                    X=:Quotient.out (Quotient.mk (CategoryTheory.isIsomorphicSetoid C) X) ≈ X)).hom\n            (CategoryTheory.CategoryStruct.comp\n              (Nonempty.some\n                (CategoryTheory.ThinSkeleton.fromThinSkeleton.proof_3 C X Y\n                    f=:Quotient.mk (CategoryTheory.isIsomorphicSetoid C) X ≤\n                    Quotient.mk (CategoryTheory.isIsomorphicSetoid C) Y))\n              (Nonempty.some\n                  (CategoryTheory.ThinSkeleton.fromThinSkeleton.proof_4 C\n                      Y=:Quotient.out (Quotient.mk (CategoryTheory.isIsomorphicSetoid C) Y) ≈ Y)).inv))\n        a :\n  Prop)", "type": "∀ (C : Type u₁) [inst : CategoryTheory.Category C] [inst_1 : Quiver.IsThin C] {x : CategoryTheory.ThinSkeleton C}\n  {y : CategoryTheory.ThinSkeleton C} (a : x ⟶ y),\n  (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ThinSkeleton.fromThinSkeleton C)).map a =\n    (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ThinSkeleton.fromThinSkeleton C)).map a", "thm": " : ∀ (C : Type u₁) [inst : CategoryTheory.Category C] [inst_1 : Quiver.IsThin C] {x : CategoryTheory.ThinSkeleton C}\n  {y : CategoryTheory.ThinSkeleton C} (a : x ⟶ y),\n  (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ThinSkeleton.fromThinSkeleton C)).map a =\n    (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ThinSkeleton.fromThinSkeleton C)).map a", "terms": [{"value": "CategoryTheory.ThinSkeleton.fromThinSkeleton C", "isProp": false, "context": ["(C : Type u₁)", "[CategoryTheory.Category C]", "[Quiver.IsThin C]", "{x : CategoryTheory.ThinSkeleton C}", "{y : CategoryTheory.ThinSkeleton C}", "(a : x ⟶ y)"]}], "namedLemmas": [], "lemmas": [], "ids": ["Eq.refl", "CategoryTheory.Functor.toPrefunctor", "CategoryTheory.ThinSkeleton.fromThinSkeleton", "map"], "idString": "Eq.refl; CategoryTheory.Functor.toPrefunctor; CategoryTheory.ThinSkeleton.fromThinSkeleton; map; ", "context": []}
{"typeGroup": "(∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (S : Set G) (hS1 : Set.Nonempty S) (hS2 : S * S = S) {a : G}\n    (ha :\n      a ∈\n        Subsemigroup.carrier\n          (Submonoid.toSubsemigroup\n            {\n              toSubsemigroup :=\n                (({ carrier := ((S)),\n                  mul_mem' :=\n                    (((fun {a : G} ↦\n                      (_ :\n                        ∀ {b : G}\n                          (a_1 : a ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2)))\n                          (a_2 : b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))),\n                          a * b ∈\n                            Subsemigroup.carrier\n                              (Submonoid.toSubsemigroup\n                                (submonoidOfIdempotent S hS1\n                                  hS2)))=:∀ {a : G} {b : G}\n                        (a_1 : a ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2)))\n                        (a_2 : b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))),\n                        a * b ∈\n                          Subsemigroup.carrier (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n              one_mem' :=\n                (((Submonoid.one_mem'\n                    (submonoidOfIdempotent S hS1\n                      hS2)=:1 ∈\n                    Subsemigroup.carrier (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n    a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2 :\n  Prop)", "type": "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (S : Set G) (hS1 : Set.Nonempty S) (hS2 : S * S = S) {a : G}\n  (ha :\n    a ∈\n      Subsemigroup.carrier\n        (Submonoid.toSubsemigroup\n          {\n            toSubsemigroup :=\n              (({ carrier := ((S)),\n                mul_mem' :=\n                  (((fun {a : G} {b : G} ↦\n                    Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n            one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) })),\n  a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2", "thm": " : ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (S : Set G) (hS1 : Set.Nonempty S) (hS2 : S * S = S) {a : G}\n  (ha :\n    a ∈\n      Subsemigroup.carrier\n        (Submonoid.toSubsemigroup\n          {\n            toSubsemigroup :=\n              (({ carrier := ((S)),\n                mul_mem' :=\n                  (((fun {a : G} {b : G} ↦\n                    Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n            one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) })),\n  a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2", "terms": [{"value": "a⁻¹", "isProp": false, "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"value": "orderOf a - 1", "isProp": false, "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}], "namedLemmas": ["∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {M : Type u} [inst : MulOneClass M] (a : M), 1 * a = a", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 1 = a", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {G : Type u_1} [inst : Monoid G] (x : G), x ^ orderOf x = 1", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {G : Type w} [inst : Group G] (a : G) {m n : ℕ}, n ≤ m → a ^ (m - n) = a ^ m * (a ^ n)⁻¹", "∀ {G : Type u_1} [inst : LeftCancelMonoid G] [inst_1 : Finite G] (x : G), 0 < orderOf x", "∀ {M : Type u_1} {A : Type u_2} [inst : Monoid M] [inst_1 : SetLike A M] [inst_2 : SubmonoidClass A M] {S : A} {x : M},\n  x ∈ S → ∀ (n : ℕ), x ^ n ∈ S"], "lemmas": [{"prop": "1 * a⁻¹ = a⁻¹", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a⁻¹ = 1 * a⁻¹", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a ^ 1 = a", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a = a ^ 1", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a ^ orderOf a = 1", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "1 = a ^ orderOf a", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "0 < orderOf a", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a ^ (orderOf a - Nat.succ 0) = a ^ orderOf a * (a ^ Nat.succ 0)⁻¹", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a ^ orderOf a * (a ^ Nat.succ 0)⁻¹ = a ^ (orderOf a - Nat.succ 0)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) =\n  (a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) =\n  (a ^ (orderOf a - Nat.succ 0) ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) =\n  (a ^ (orderOf a - Nat.succ 0) ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a ^ (orderOf a - 1) ∈ submonoidOfIdempotent S hS1 hS2", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}], "ids": ["Eq.mpr", "id", "Eq.symm", "one_mul", "Eq.refl", "submonoidOfIdempotent", "Eq.mpr", "id", "Eq.symm", "pow_one", "Eq.refl", "submonoidOfIdempotent", "Eq.mpr", "id", "Eq.symm", "pow_orderOf_eq_one", "Eq.refl", "submonoidOfIdempotent", "Eq.mpr", "id", "Eq.symm", "pow_sub", "orderOf_pos", "Eq.refl", "orderOf", "submonoidOfIdempotent", "pow_mem", "orderOf"], "idString": "Eq.mpr; id; Eq.symm; one_mul; Eq.refl; submonoidOfIdempotent; Eq.mpr; id; Eq.symm; pow_one; Eq.refl; submonoidOfIdempotent; Eq.mpr; id; Eq.symm; pow_orderOf_eq_one; Eq.refl; submonoidOfIdempotent; Eq.mpr; id; Eq.symm; pow_sub; orderOf_pos; Eq.refl; orderOf; submonoidOfIdempotent; pow_mem; orderOf; ", "context": []}
{"typeGroup": "(∀ {R : Type u_3} {A : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : Semiring A] [inst_2 : AddCommMonoid M]\n    [inst_3 : Module R A] [inst_4 : Module R M] (f : (a : ℕ) → A →ₗ[R] M) (c : R) (p : Polynomial A),\n    AddHom.toFun\n        { toFun := ((fun (p : Polynomial A) ↦ Polynomial.sum p fun (n : ℕ) (r : A) ↦ ↑(f n) r)),\n          map_add' :=\n            (((fun (p : Polynomial A) ↦\n              (_ :\n                ∀ (q : Polynomial A),\n                  (Polynomial.sum (p + q) fun (n : ℕ) (r : A) ↦ ↑(f n) r) =\n                    (Polynomial.sum p fun (n : ℕ) (r : A) ↦ ↑(f n) r) +\n                      Polynomial.sum q fun (n : ℕ) (r : A) ↦\n                        ↑(f n)\n                          r)=:∀ (p : Polynomial A) (q : Polynomial A),\n                (Polynomial.sum (p + q) fun (n : ℕ) (r : A) ↦ ↑(f n) r) =\n                  (Polynomial.sum p fun (n : ℕ) (r : A) ↦ ↑(f n) r) +\n                    Polynomial.sum q fun (n : ℕ) (r : A) ↦ ↑(f n) r))) }\n        (c • p) =\n      ↑(RingHom.id R) c •\n        AddHom.toFun\n          { toFun := ((fun (p : Polynomial A) ↦ Polynomial.sum p fun (n : ℕ) (r : A) ↦ ↑(f n) r)),\n            map_add' :=\n              (((fun (p : Polynomial A) ↦\n                (_ :\n                  ∀ (q : Polynomial A),\n                    (Polynomial.sum (p + q) fun (n : ℕ) (r : A) ↦ ↑(f n) r) =\n                      (Polynomial.sum p fun (n : ℕ) (r : A) ↦ ↑(f n) r) +\n                        Polynomial.sum q fun (n : ℕ) (r : A) ↦\n                          ↑(f n)\n                            r)=:∀ (p : Polynomial A) (q : Polynomial A),\n                  (Polynomial.sum (p + q) fun (n : ℕ) (r : A) ↦ ↑(f n) r) =\n                    (Polynomial.sum p fun (n : ℕ) (r : A) ↦ ↑(f n) r) +\n                      Polynomial.sum q fun (n : ℕ) (r : A) ↦ ↑(f n) r))) }\n          p :\n  Prop)", "type": "∀ {R : Type u_3} {A : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : Semiring A] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R A] [inst_4 : Module R M] (f : (a : ℕ) → A →ₗ[R] M) (c : R) (p : Polynomial A),\n  AddHom.toFun\n      { toFun := ((fun (p : Polynomial A) ↦ Polynomial.sum p fun (n : ℕ) (r : A) ↦ ↑(f n) r)),\n        map_add' :=\n          (((fun (p : Polynomial A) (q : Polynomial A) ↦\n            Polynomial.sum_add_index p q (fun (n : ℕ) (r : A) ↦ ↑(f n) r) (fun (n : ℕ) ↦ LinearMap.map_zero (f n))\n              (fun (n : ℕ) (x : A) (x_1 : A) ↦ LinearMap.map_add (f n) x x_1)))) }\n      (c • p) =\n    ↑(RingHom.id R) c •\n      AddHom.toFun\n        { toFun := ((fun (p : Polynomial A) ↦ Polynomial.sum p fun (n : ℕ) (r : A) ↦ ↑(f n) r)),\n          map_add' :=\n            (((fun (p : Polynomial A) (q : Polynomial A) ↦\n              Polynomial.sum_add_index p q (fun (n : ℕ) (r : A) ↦ ↑(f n) r) (fun (n : ℕ) ↦ LinearMap.map_zero (f n))\n                (fun (n : ℕ) (x : A) (x_1 : A) ↦ LinearMap.map_add (f n) x x_1)))) }\n        p", "thm": " : ∀ {R : Type u_3} {A : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : Semiring A] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R A] [inst_4 : Module R M] (f : (a : ℕ) → A →ₗ[R] M) (c : R) (p : Polynomial A),\n  AddHom.toFun\n      { toFun := ((fun (p : Polynomial A) ↦ Polynomial.sum p fun (n : ℕ) (r : A) ↦ ↑(f n) r)),\n        map_add' :=\n          (((fun (p : Polynomial A) (q : Polynomial A) ↦\n            Polynomial.sum_add_index p q (fun (n : ℕ) (r : A) ↦ ↑(f n) r) (fun (n : ℕ) ↦ LinearMap.map_zero (f n))\n              (fun (n : ℕ) (x : A) (x_1 : A) ↦ LinearMap.map_add (f n) x x_1)))) }\n      (c • p) =\n    ↑(RingHom.id R) c •\n      AddHom.toFun\n        { toFun := ((fun (p : Polynomial A) ↦ Polynomial.sum p fun (n : ℕ) (r : A) ↦ ↑(f n) r)),\n          map_add' :=\n            (((fun (p : Polynomial A) (q : Polynomial A) ↦\n              Polynomial.sum_add_index p q (fun (n : ℕ) (r : A) ↦ ↑(f n) r) (fun (n : ℕ) ↦ LinearMap.map_zero (f n))\n                (fun (n : ℕ) (x : A) (x_1 : A) ↦ LinearMap.map_add (f n) x x_1)))) }\n        p", "terms": [{"value": "c • p", "isProp": false, "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)"]}, {"value": "f n", "isProp": false, "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)", "(n : ℕ)"]}, {"value": "Polynomial.support p", "isProp": false, "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)"]}, {"value": "↑(f x)", "isProp": false, "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)", "(x : ℕ)", "(a : x ∈ Polynomial.support p)"]}, {"value": "f x", "isProp": false, "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)", "(x : ℕ)", "(a : x ∈ Polynomial.support p)"]}, {"value": "Polynomial.coeff p x", "isProp": false, "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)", "(x : ℕ)", "(a : x ∈ Polynomial.support p)"]}, {"value": "Polynomial.coeff p x", "isProp": false, "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)", "(x : ℕ)"]}, {"value": "Finset.sum (Polynomial.support p) fun (x : ℕ) ↦ c • ↑(f x) (Polynomial.coeff p x)", "isProp": false, "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)"]}], "namedLemmas": ["∀ {R : Type u} [inst : Semiring R] {S : Type u_1} [inst_1 : AddCommMonoid S] (p : Polynomial R) (f : ℕ → R → S),\n  (∀ (i : ℕ), f i 0 = 0) →\n    ∀ (s : Finset ℕ), Polynomial.support p ⊆ s → Polynomial.sum p f = Finset.sum s fun n => f n (Polynomial.coeff p n)", "∀ {R : Type u_3} {S : Type u_4} {M : Type u_2} {M₃ : Type u_1} [inst : Semiring R] [inst_1 : Semiring S]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₃] [inst_4 : Module R M] [inst_5 : Module S M₃] {σ : R →+* S}\n  (f : M →ₛₗ[σ] M₃), ↑f 0 = 0", "∀ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : Monoid S] [inst_2 : DistribMulAction S R] (r : S)\n  (p : Polynomial R), Polynomial.support (r • p) ⊆ Polynomial.support p", "∀ {p : Prop}, p = True → p", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {β : Type u} {α : Type v} {s₁ s₂ : Finset α} {f g : α → β} [inst : AddCommMonoid β],\n  s₁ = s₂ → (∀ (x : α), x ∈ s₂ → f x = g x) → Finset.sum s₁ f = Finset.sum s₂ g", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : SMulZeroClass S R] (r : S) (p : Polynomial R) (n : ℕ),\n  Polynomial.coeff (r • p) n = r • Polynomial.coeff p n", "∀ {R : Type u_2} {M : Type u_3} {M₂ : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : AddCommMonoid M₂] [inst_3 : Module R M] [inst_4 : Module R M₂] (fₗ : M →ₗ[R] M₂) (c : R) (x : M),\n  ↑fₗ (c • x) = c • ↑fₗ x", "∀ {α : Type u_3} {β : Type u_2} {γ : Type u_1} [inst : AddCommMonoid β] [inst_1 : DistribSMul α β] {r : α} {f : γ → β}\n  {s : Finset γ}, (r • Finset.sum s fun x => f x) = Finset.sum s fun x => r • f x", "∀ {α : Sort u_1} (a : α), (a = a) = True"], "lemmas": [{"prop": "∀ (n : ℕ), ↑(f n) 0 = 0", "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)"]}, {"prop": "Polynomial.support (c • p) ⊆ Polynomial.support p", "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)"]}, {"prop": "(Polynomial.sum (c • p) fun (n : ℕ) (r : A) ↦ ↑(f n) r) =\n  Finset.sum (Polynomial.support p) fun (n : ℕ) ↦ ↑(f n) (Polynomial.coeff (c • p) n)", "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)"]}, {"prop": "((Polynomial.sum (c • p) fun (n : ℕ) (r : A) ↦ ↑(f n) r) =\n    ↑(RingHom.id R) c • Polynomial.sum p fun (n : ℕ) (r : A) ↦ ↑(f n) r) =\n  ((Polynomial.sum (c • p) fun (n : ℕ) (r : A) ↦ ↑(f n) r) =\n    ↑(RingHom.id R) c • Polynomial.sum p fun (n : ℕ) (r : A) ↦ ↑(f n) r)", "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)"]}, {"prop": "((Polynomial.sum (c • p) fun (n : ℕ) (r : A) ↦ ↑(f n) r) =\n    ↑(RingHom.id R) c • Polynomial.sum p fun (n : ℕ) (r : A) ↦ ↑(f n) r) =\n  ((Finset.sum (Polynomial.support p) fun (n : ℕ) ↦ ↑(f n) (Polynomial.coeff (c • p) n)) =\n    ↑(RingHom.id R) c • Polynomial.sum p fun (n : ℕ) (r : A) ↦ ↑(f n) r)", "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)"]}, {"prop": "((Polynomial.sum (c • p) fun (n : ℕ) (r : A) ↦ ↑(f n) r) =\n    ↑(RingHom.id R) c • Polynomial.sum p fun (n : ℕ) (r : A) ↦ ↑(f n) r) =\n  ((Finset.sum (Polynomial.support p) fun (n : ℕ) ↦ ↑(f n) (Polynomial.coeff (c • p) n)) =\n    ↑(RingHom.id R) c • Polynomial.sum p fun (n : ℕ) (r : A) ↦ ↑(f n) r)", "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)"]}, {"prop": "Polynomial.support p = Polynomial.support p", "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)"]}, {"prop": "Polynomial.coeff (c • p) x = c • Polynomial.coeff p x", "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)", "(x : ℕ)", "(a : x ∈ Polynomial.support p)"]}, {"prop": "↑(f x) (Polynomial.coeff (c • p) x) = ↑(f x) (c • Polynomial.coeff p x)", "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)", "(x : ℕ)", "(a : x ∈ Polynomial.support p)"]}, {"prop": "↑(f x) (c • Polynomial.coeff p x) = c • ↑(f x) (Polynomial.coeff p x)", "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)", "(x : ℕ)", "(a : x ∈ Polynomial.support p)"]}, {"prop": "∀ (x : ℕ) (a : x ∈ Polynomial.support p), ↑(f x) (Polynomial.coeff (c • p) x) = c • ↑(f x) (Polynomial.coeff p x)", "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)"]}, {"prop": "(Finset.sum (Polynomial.support p) fun (n : ℕ) ↦ ↑(f n) (Polynomial.coeff (c • p) n)) =\n  Finset.sum (Polynomial.support p) fun (x : ℕ) ↦ c • ↑(f x) (Polynomial.coeff p x)", "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)"]}, {"prop": "Eq (Finset.sum (Polynomial.support p) fun (n : ℕ) ↦ ↑(f n) (Polynomial.coeff (c • p) n)) =\n  Eq (Finset.sum (Polynomial.support p) fun (x : ℕ) ↦ c • ↑(f x) (Polynomial.coeff p x))", "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)"]}, {"prop": "(c • Finset.sum (Polynomial.support p) fun (x : ℕ) ↦ ↑(f x) (Polynomial.coeff p x)) =\n  Finset.sum (Polynomial.support p) fun (x : ℕ) ↦ c • ↑(f x) (Polynomial.coeff p x)", "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)"]}, {"prop": "((Finset.sum (Polynomial.support p) fun (n : ℕ) ↦ ↑(f n) (Polynomial.coeff (c • p) n)) =\n    c • Finset.sum (Polynomial.support p) fun (x : ℕ) ↦ ↑(f x) (Polynomial.coeff p x)) =\n  ((Finset.sum (Polynomial.support p) fun (x : ℕ) ↦ c • ↑(f x) (Polynomial.coeff p x)) =\n    Finset.sum (Polynomial.support p) fun (x : ℕ) ↦ c • ↑(f x) (Polynomial.coeff p x))", "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)"]}, {"prop": "((Finset.sum (Polynomial.support p) fun (x : ℕ) ↦ c • ↑(f x) (Polynomial.coeff p x)) =\n    Finset.sum (Polynomial.support p) fun (x : ℕ) ↦ c • ↑(f x) (Polynomial.coeff p x)) =\n  True", "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)"]}, {"prop": "((Finset.sum (Polynomial.support p) fun (n : ℕ) ↦ ↑(f n) (Polynomial.coeff (c • p) n)) =\n    c • Finset.sum (Polynomial.support p) fun (x : ℕ) ↦ ↑(f x) (Polynomial.coeff p x)) =\n  True", "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)"]}, {"prop": "(Finset.sum (Polynomial.support p) fun (n : ℕ) ↦ ↑(f n) (Polynomial.coeff (c • p) n)) =\n  c • Finset.sum (Polynomial.support p) fun (x : ℕ) ↦ ↑(f x) (Polynomial.coeff p x)", "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)"]}, {"prop": "(Polynomial.sum (c • p) fun (n : ℕ) (r : A) ↦ ↑(f n) r) =\n  ↑(RingHom.id R) c • Polynomial.sum p fun (n : ℕ) (r : A) ↦ ↑(f n) r", "context": ["{R : Type u_3}", "{A : Type u_1}", "{M : Type u_2}", "[Semiring R]", "[Semiring A]", "[AddCommMonoid M]", "[Module R A]", "[Module R M]", "(f : (a : ℕ) → A →ₗ[R] M)", "(c : R)", "(p : Polynomial A)"]}], "ids": ["id", "Eq.mpr", "id", "Polynomial.sum_eq_of_subset", "LinearMap.map_zero", "Polynomial.support", "Polynomial.support_smul", "Eq.refl", "Polynomial.sum", "RingHom.id", "Polynomial.sum", "of_eq_true", "Eq.trans", "congr", "congrArg", "Eq", "Finset.sum_congr", "Eq.refl", "Polynomial.support", "Eq.trans", "congrArg", "Polynomial.coeff_smul", "LinearMap.map_smul", "Polynomial.coeff", "Finset.smul_sum", "eq_self", "Finset.sum", "Polynomial.support", "Polynomial.coeff"], "idString": "id; Eq.mpr; id; Polynomial.sum_eq_of_subset; LinearMap.map_zero; Polynomial.support; Polynomial.support_smul; Eq.refl; Polynomial.sum; RingHom.id; Polynomial.sum; of_eq_true; Eq.trans; congr; congrArg; Eq; Finset.sum_congr; Eq.refl; Polynomial.support; Eq.trans; congrArg; Polynomial.coeff_smul; LinearMap.map_smul; Polynomial.coeff; Finset.smul_sum; eq_self; Finset.sum; Polynomial.support; Polynomial.coeff; ", "context": []}
{"typeGroup": "(∀ (k : Type u_1) [inst : Field k],\n    Ideal.IsMaximal\n      (Classical.choose\n        (Ideal.exists_le_maximal (AlgebraicClosure.spanEval k)\n            (AlgebraicClosure.spanEval_ne_top\n                k=:AlgebraicClosure.spanEval k ≠\n                ⊤)=:∃ (M : Ideal (MvPolynomial (AlgebraicClosure.MonicIrreducible k) k)),\n            (Ideal.IsMaximal M : Prop) ∧ (AlgebraicClosure.spanEval k ≤ M : Prop))) :\n  Prop)", "type": "∀ (k : Type u_1) [inst : Field k],\n  Ideal.IsMaximal\n    (Classical.choose (Ideal.exists_le_maximal (AlgebraicClosure.spanEval k) (AlgebraicClosure.spanEval_ne_top k)))", "thm": " : ∀ (k : Type u_1) [inst : Field k],\n  Ideal.IsMaximal\n    (Classical.choose (Ideal.exists_le_maximal (AlgebraicClosure.spanEval k) (AlgebraicClosure.spanEval_ne_top k)))", "terms": [{"value": "AlgebraicClosure.spanEval k", "isProp": false, "context": ["(k : Type u_1)", "[Field k]"]}], "namedLemmas": ["∀ {a b : Prop}, a ∧ b → a", "∀ {α : Sort u} {p : α → Prop} (h : ∃ x, p x), p (Classical.choose h)", "∀ {α : Type u} [inst : Semiring α] (I : Ideal α), I ≠ ⊤ → ∃ M, Ideal.IsMaximal M ∧ I ≤ M", "∀ (k : Type u) [inst : Field k], AlgebraicClosure.spanEval k ≠ ⊤"], "lemmas": [{"prop": "AlgebraicClosure.spanEval k ≠ ⊤", "context": ["(k : Type u_1)", "[Field k]"]}, {"prop": "∃ (M : Ideal (MvPolynomial (AlgebraicClosure.MonicIrreducible k) k)),\n  (Ideal.IsMaximal M) ∧ (AlgebraicClosure.spanEval k ≤ M)", "context": ["(k : Type u_1)", "[Field k]"]}, {"prop": "(Ideal.IsMaximal\n    (Classical.choose (Ideal.exists_le_maximal (AlgebraicClosure.spanEval k) (AlgebraicClosure.spanEval_ne_top k)))) ∧\n  (AlgebraicClosure.spanEval k ≤\n    Classical.choose (Ideal.exists_le_maximal (AlgebraicClosure.spanEval k) (AlgebraicClosure.spanEval_ne_top k)))", "context": ["(k : Type u_1)", "[Field k]"]}], "ids": ["And.left", "Classical.choose_spec", "Ideal.exists_le_maximal", "AlgebraicClosure.spanEval", "AlgebraicClosure.spanEval_ne_top"], "idString": "And.left; Classical.choose_spec; Ideal.exists_le_maximal; AlgebraicClosure.spanEval; AlgebraicClosure.spanEval_ne_top; ", "context": []}
{"typeGroup": "(∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (S : Set G) (hS1 : Set.Nonempty S) (hS2 : S * S = S) {a : G}\n    (ha :\n      a ∈\n        Subsemigroup.carrier\n          (Submonoid.toSubsemigroup\n            {\n              toSubsemigroup :=\n                (({ carrier := ((S)),\n                  mul_mem' :=\n                    (((fun {a : G} ↦\n                      (_ :\n                        ∀ {b : G}\n                          (a_1 : a ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2)))\n                          (a_2 : b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))),\n                          a * b ∈\n                            Subsemigroup.carrier\n                              (Submonoid.toSubsemigroup\n                                (submonoidOfIdempotent S hS1\n                                  hS2)))=:∀ {a : G} {b : G}\n                        (a_1 : a ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2)))\n                        (a_2 : b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))),\n                        a * b ∈\n                          Subsemigroup.carrier (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n              one_mem' :=\n                (((Submonoid.one_mem'\n                    (submonoidOfIdempotent S hS1\n                      hS2)=:1 ∈\n                    Subsemigroup.carrier (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n    a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2 :\n  Prop)", "type": "a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2", "thm": "{G : Type u_1} [Group G] [Fintype G] (S : Set G) (hS1 : Set.Nonempty S) (hS2 : S * S = S) {a : G} (ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))  : a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2", "terms": [{"value": "a⁻¹", "isProp": false, "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"value": "orderOf a - 1", "isProp": false, "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}], "namedLemmas": ["∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {M : Type u} [inst : MulOneClass M] (a : M), 1 * a = a", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 1 = a", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {G : Type u_1} [inst : Monoid G] (x : G), x ^ orderOf x = 1", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {G : Type w} [inst : Group G] (a : G) {m n : ℕ}, n ≤ m → a ^ (m - n) = a ^ m * (a ^ n)⁻¹", "∀ {G : Type u_1} [inst : LeftCancelMonoid G] [inst_1 : Finite G] (x : G), 0 < orderOf x", "∀ {M : Type u_1} {A : Type u_2} [inst : Monoid M] [inst_1 : SetLike A M] [inst_2 : SubmonoidClass A M] {S : A} {x : M},\n  x ∈ S → ∀ (n : ℕ), x ^ n ∈ S"], "lemmas": [{"prop": "1 * a⁻¹ = a⁻¹", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a⁻¹ = 1 * a⁻¹", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a ^ 1 = a", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a = a ^ 1", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a ^ orderOf a = 1", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "1 = a ^ orderOf a", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) = (a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "0 < orderOf a", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a ^ (orderOf a - Nat.succ 0) = a ^ orderOf a * (a ^ Nat.succ 0)⁻¹", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a ^ orderOf a * (a ^ Nat.succ 0)⁻¹ = a ^ (orderOf a - Nat.succ 0)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) =\n  (a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) =\n  (a ^ (orderOf a - Nat.succ 0) ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "(a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2) =\n  (a ^ (orderOf a - Nat.succ 0) ∈ submonoidOfIdempotent S hS1 hS2)", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a ^ (orderOf a - 1) ∈ submonoidOfIdempotent S hS1 hS2", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "a ^ orderOf a * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "1 * (a ^ 1)⁻¹ ∈ submonoidOfIdempotent S hS1 hS2", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}, {"prop": "1 * a⁻¹ ∈ submonoidOfIdempotent S hS1 hS2", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}], "ids": ["Eq.mpr", "id", "Eq.symm", "one_mul", "Eq.refl", "submonoidOfIdempotent", "Eq.mpr", "id", "Eq.symm", "pow_one", "Eq.refl", "submonoidOfIdempotent", "Eq.mpr", "id", "Eq.symm", "pow_orderOf_eq_one", "Eq.refl", "submonoidOfIdempotent", "Eq.mpr", "id", "Eq.symm", "pow_sub", "orderOf_pos", "Eq.refl", "orderOf", "submonoidOfIdempotent", "pow_mem", "orderOf"], "idString": "Eq.mpr; id; Eq.symm; one_mul; Eq.refl; submonoidOfIdempotent; Eq.mpr; id; Eq.symm; pow_one; Eq.refl; submonoidOfIdempotent; Eq.mpr; id; Eq.symm; pow_orderOf_eq_one; Eq.refl; submonoidOfIdempotent; Eq.mpr; id; Eq.symm; pow_sub; orderOf_pos; Eq.refl; orderOf; submonoidOfIdempotent; pow_mem; orderOf; ", "context": ["{G : Type u_1}", "[Group G]", "[Fintype G]", "(S : Set G)", "(hS1 : Set.Nonempty S)", "(hS2 : S * S = S)", "{a : G}", "(ha : a ∈\n  Subsemigroup.carrier\n    (Submonoid.toSubsemigroup\n      {\n        toSubsemigroup :=\n          (({ carrier := ((S)),\n            mul_mem' :=\n              (((fun {a : G} {b : G} ↦\n                Subsemigroup.mul_mem' (Submonoid.toSubsemigroup (submonoidOfIdempotent S hS1 hS2))))) })),\n        one_mem' := (((Submonoid.one_mem' (submonoidOfIdempotent S hS1 hS2)))) }))"]}
{"typeGroup": "(∀ {C : Type u_2} [inst : CategoryTheory.Category C] {X : C} {Y : C} {W : C} (f : Y ⟶ X)\n    [inst_1 : CategoryTheory.EffectiveEpi f] (e : Y ⟶ W)\n    (h :\n      ∀ {Z : C} (g₁ : Z ⟶ Y) (g₂ : Z ⟶ Y)\n        (a : CategoryTheory.CategoryStruct.comp g₁ f = CategoryTheory.CategoryStruct.comp g₂ f),\n        CategoryTheory.CategoryStruct.comp g₁ e = CategoryTheory.CategoryStruct.comp g₂ e)\n    (m : X ⟶ W) (hm : CategoryTheory.CategoryStruct.comp f m = e),\n    m =\n      CategoryTheory.EffectiveEpi.desc f e\n        (fun {Z : C} ↦\n          (_ :\n            ∀ (g₁ : Z ⟶ Y) (g₂ : Z ⟶ Y)\n              (a : CategoryTheory.CategoryStruct.comp g₁ f = CategoryTheory.CategoryStruct.comp g₂ f),\n              CategoryTheory.CategoryStruct.comp g₁ e =\n                CategoryTheory.CategoryStruct.comp g₂\n                  e)=:∀ {Z : C} (g₁ : Z ⟶ Y) (g₂ : Z ⟶ Y)\n            (a : CategoryTheory.CategoryStruct.comp g₁ f = CategoryTheory.CategoryStruct.comp g₂ f),\n            CategoryTheory.CategoryStruct.comp g₁ e = CategoryTheory.CategoryStruct.comp g₂ e) :\n  Prop)", "type": "∀ {C : Type u_2} [inst : CategoryTheory.Category C] {X : C} {Y : C} {W : C} (f : Y ⟶ X)\n  [inst_1 : CategoryTheory.EffectiveEpi f] (e : Y ⟶ W)\n  (h :\n    ∀ {Z : C} (g₁ : Z ⟶ Y) (g₂ : Z ⟶ Y)\n      (a : CategoryTheory.CategoryStruct.comp g₁ f = CategoryTheory.CategoryStruct.comp g₂ f),\n      CategoryTheory.CategoryStruct.comp g₁ e = CategoryTheory.CategoryStruct.comp g₂ e)\n  (m : X ⟶ W) (hm : CategoryTheory.CategoryStruct.comp f m = e),\n  m = CategoryTheory.EffectiveEpiStruct.desc (CategoryTheory.EffectiveEpi.getStruct f) e (fun {Z : C} ↦ h)", "thm": " : ∀ {C : Type u_2} [inst : CategoryTheory.Category C] {X : C} {Y : C} {W : C} (f : Y ⟶ X)\n  [inst_1 : CategoryTheory.EffectiveEpi f] (e : Y ⟶ W)\n  (h :\n    ∀ {Z : C} (g₁ : Z ⟶ Y) (g₂ : Z ⟶ Y)\n      (a : CategoryTheory.CategoryStruct.comp g₁ f = CategoryTheory.CategoryStruct.comp g₂ f),\n      CategoryTheory.CategoryStruct.comp g₁ e = CategoryTheory.CategoryStruct.comp g₂ e)\n  (m : X ⟶ W) (hm : CategoryTheory.CategoryStruct.comp f m = e),\n  m = CategoryTheory.EffectiveEpiStruct.desc (CategoryTheory.EffectiveEpi.getStruct f) e (fun {Z : C} ↦ h)", "terms": [{"value": "CategoryTheory.EffectiveEpi.getStruct f", "isProp": false, "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{X : C}", "{Y : C}", "{W : C}", "(f : Y ⟶ X)", "[CategoryTheory.EffectiveEpi f]", "(e : Y ⟶ W)", "(h : ∀ {Z : C} (g₁ : Z ⟶ Y) (g₂ : Z ⟶ Y)\n  (a : CategoryTheory.CategoryStruct.comp g₁ f = CategoryTheory.CategoryStruct.comp g₂ f),\n  CategoryTheory.CategoryStruct.comp g₁ e = CategoryTheory.CategoryStruct.comp g₂ e)", "(m : X ⟶ W)", "(hm : CategoryTheory.CategoryStruct.comp f m = e)"]}], "namedLemmas": ["∀ {C : Type u_1} [inst : CategoryTheory.Category C] {X Y : C} {f : Y ⟶ X} (self : CategoryTheory.EffectiveEpiStruct f)\n  {W : C} (e : Y ⟶ W)\n  (h :\n    ∀ {Z : C} (g₁ g₂ : Z ⟶ Y),\n      CategoryTheory.CategoryStruct.comp g₁ f = CategoryTheory.CategoryStruct.comp g₂ f →\n        CategoryTheory.CategoryStruct.comp g₁ e = CategoryTheory.CategoryStruct.comp g₂ e)\n  (m : X ⟶ W),\n  CategoryTheory.CategoryStruct.comp f m = e →\n    m =\n      CategoryTheory.EffectiveEpiStruct.desc self e\n        (_ :\n          ∀ {Z : C} (g₁ g₂ : Z ⟶ Y),\n            CategoryTheory.CategoryStruct.comp g₁ f = CategoryTheory.CategoryStruct.comp g₂ f →\n              CategoryTheory.CategoryStruct.comp g₁ e = CategoryTheory.CategoryStruct.comp g₂ e)"], "lemmas": [{"prop": "∀ {Z : C} (g₁ : Z ⟶ Y) (g₂ : Z ⟶ Y)\n  (a : CategoryTheory.CategoryStruct.comp g₁ f = CategoryTheory.CategoryStruct.comp g₂ f),\n  CategoryTheory.CategoryStruct.comp g₁ e = CategoryTheory.CategoryStruct.comp g₂ e", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "{X : C}", "{Y : C}", "{W : C}", "(f : Y ⟶ X)", "[CategoryTheory.EffectiveEpi f]", "(e : Y ⟶ W)", "(h : ∀ {Z : C} (g₁ : Z ⟶ Y) (g₂ : Z ⟶ Y)\n  (a : CategoryTheory.CategoryStruct.comp g₁ f = CategoryTheory.CategoryStruct.comp g₂ f),\n  CategoryTheory.CategoryStruct.comp g₁ e = CategoryTheory.CategoryStruct.comp g₂ e)", "(m : X ⟶ W)", "(hm : CategoryTheory.CategoryStruct.comp f m = e)"]}], "ids": ["CategoryTheory.EffectiveEpiStruct.uniq", "CategoryTheory.EffectiveEpi.getStruct"], "idString": "CategoryTheory.EffectiveEpiStruct.uniq; CategoryTheory.EffectiveEpi.getStruct; ", "context": []}
{"typeGroup": "(∀ {α : Type u_1} [inst : CommMonoid α] (x : α),\n    Quotient.lift id\n        (fun (a : α) ↦ (_ : ∀ (b : α) (a_1 : IsConj a b), a = b)=:∀ (a : α) (b : α) (a_1 : IsConj a b), a = b)\n        (Quotient.mk (IsConj.setoid α) x) =\n      id x :\n  Prop)", "type": "∀ {α : Type u_1} [inst : CommMonoid α] (x : α),\n  Quotient.lift id (fun (a : α) (b : α) ↦ Iff.mp isConj_iff_eq) (Quotient.mk (IsConj.setoid α) x) = id x", "thm": " : ∀ {α : Type u_1} [inst : CommMonoid α] (x : α),\n  Quotient.lift id (fun (a : α) (b : α) ↦ Iff.mp isConj_iff_eq) (Quotient.mk (IsConj.setoid α) x) = id x", "terms": [], "namedLemmas": ["∀ {α : Sort u_1} {β : Sort u_2} [s : Setoid α] (f : α → β) (h : ∀ (a b : α), a ≈ b → f a = f b) (x : α),\n  Quotient.lift f h (Quotient.mk s x) = f x", "∀ {a b : Prop}, (a ↔ b) → a → b", "∀ {α : Type u_1} [inst : CommMonoid α] {a b : α}, IsConj a b ↔ a = b"], "lemmas": [{"prop": "(IsConj a b) ↔ (a = b)", "context": ["{α : Type u_1}", "[CommMonoid α]", "(a : α)", "(b : α)"]}, {"prop": "∀ (a : α) (b : α) (a_1 : IsConj a b), a = b", "context": ["{α : Type u_1}", "[CommMonoid α]"]}], "ids": ["Quotient.lift_mk", "id", "Iff.mp", "isConj_iff_eq"], "idString": "Quotient.lift_mk; id; Iff.mp; isConj_iff_eq; ", "context": []}
{"typeGroup": "(∀ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] (S : AddSubsemigroup M) (f : AddHom M N)\n    (hf : Function.Injective ↑f) (x : { x : M // x ∈ S }) (x_1 : { x : M // x ∈ S }),\n    Equiv.toFun\n        { toFun := ((Equiv.toFun (Equiv.Set.image (↑f) (↑S) hf))),\n          invFun := ((Equiv.invFun (Equiv.Set.image (↑f) (↑S) hf))),\n          left_inv :=\n            (((Equiv.left_inv\n                (Equiv.Set.image (↑f) (↑S)\n                  hf)=:Function.LeftInverse (Equiv.invFun (Equiv.Set.image (↑f) (↑S) hf))\n                (Equiv.toFun (Equiv.Set.image (↑f) (↑S) hf))))),\n          right_inv :=\n            (((Equiv.right_inv\n                (Equiv.Set.image (↑f) (↑S)\n                  hf)=:Function.RightInverse (Equiv.invFun (Equiv.Set.image (↑f) (↑S) hf))\n                (Equiv.toFun (Equiv.Set.image (↑f) (↑S) hf))))) }\n        (x + x_1) =\n      Equiv.toFun\n          { toFun := ((Equiv.toFun (Equiv.Set.image (↑f) (↑S) hf))),\n            invFun := ((Equiv.invFun (Equiv.Set.image (↑f) (↑S) hf))),\n            left_inv :=\n              (((Equiv.left_inv\n                  (Equiv.Set.image (↑f) (↑S)\n                    hf)=:Function.LeftInverse (Equiv.invFun (Equiv.Set.image (↑f) (↑S) hf))\n                  (Equiv.toFun (Equiv.Set.image (↑f) (↑S) hf))))),\n            right_inv :=\n              (((Equiv.right_inv\n                  (Equiv.Set.image (↑f) (↑S)\n                    hf)=:Function.RightInverse (Equiv.invFun (Equiv.Set.image (↑f) (↑S) hf))\n                  (Equiv.toFun (Equiv.Set.image (↑f) (↑S) hf))))) }\n          x +\n        Equiv.toFun\n          { toFun := ((Equiv.toFun (Equiv.Set.image (↑f) (↑S) hf))),\n            invFun := ((Equiv.invFun (Equiv.Set.image (↑f) (↑S) hf))),\n            left_inv :=\n              (((Equiv.left_inv\n                  (Equiv.Set.image (↑f) (↑S)\n                    hf)=:Function.LeftInverse (Equiv.invFun (Equiv.Set.image (↑f) (↑S) hf))\n                  (Equiv.toFun (Equiv.Set.image (↑f) (↑S) hf))))),\n            right_inv :=\n              (((Equiv.right_inv\n                  (Equiv.Set.image (↑f) (↑S)\n                    hf)=:Function.RightInverse (Equiv.invFun (Equiv.Set.image (↑f) (↑S) hf))\n                  (Equiv.toFun (Equiv.Set.image (↑f) (↑S) hf))))) }\n          x_1 :\n  Prop)", "type": "∀ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] (S : AddSubsemigroup M) (f : AddHom M N)\n  (hf : Function.Injective ↑f) (x : { x : M // x ∈ S }) (x_1 : { x : M // x ∈ S }),\n  Equiv.toFun\n      { toFun := ((Equiv.toFun (Equiv.Set.image (↑f) (↑S) hf))),\n        invFun := ((Equiv.invFun (Equiv.Set.image (↑f) (↑S) hf))),\n        left_inv := (((Equiv.left_inv (Equiv.Set.image (↑f) (↑S) hf)))),\n        right_inv := (((Equiv.right_inv (Equiv.Set.image (↑f) (↑S) hf)))) }\n      (x + x_1) =\n    Equiv.toFun\n        { toFun := ((Equiv.toFun (Equiv.Set.image (↑f) (↑S) hf))),\n          invFun := ((Equiv.invFun (Equiv.Set.image (↑f) (↑S) hf))),\n          left_inv := (((Equiv.left_inv (Equiv.Set.image (↑f) (↑S) hf)))),\n          right_inv := (((Equiv.right_inv (Equiv.Set.image (↑f) (↑S) hf)))) }\n        x +\n      Equiv.toFun\n        { toFun := ((Equiv.toFun (Equiv.Set.image (↑f) (↑S) hf))),\n          invFun := ((Equiv.invFun (Equiv.Set.image (↑f) (↑S) hf))),\n          left_inv := (((Equiv.left_inv (Equiv.Set.image (↑f) (↑S) hf)))),\n          right_inv := (((Equiv.right_inv (Equiv.Set.image (↑f) (↑S) hf)))) }\n        x_1", "thm": " : ∀ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] (S : AddSubsemigroup M) (f : AddHom M N)\n  (hf : Function.Injective ↑f) (x : { x : M // x ∈ S }) (x_1 : { x : M // x ∈ S }),\n  Equiv.toFun\n      { toFun := ((Equiv.toFun (Equiv.Set.image (↑f) (↑S) hf))),\n        invFun := ((Equiv.invFun (Equiv.Set.image (↑f) (↑S) hf))),\n        left_inv := (((Equiv.left_inv (Equiv.Set.image (↑f) (↑S) hf)))),\n        right_inv := (((Equiv.right_inv (Equiv.Set.image (↑f) (↑S) hf)))) }\n      (x + x_1) =\n    Equiv.toFun\n        { toFun := ((Equiv.toFun (Equiv.Set.image (↑f) (↑S) hf))),\n          invFun := ((Equiv.invFun (Equiv.Set.image (↑f) (↑S) hf))),\n          left_inv := (((Equiv.left_inv (Equiv.Set.image (↑f) (↑S) hf)))),\n          right_inv := (((Equiv.right_inv (Equiv.Set.image (↑f) (↑S) hf)))) }\n        x +\n      Equiv.toFun\n        { toFun := ((Equiv.toFun (Equiv.Set.image (↑f) (↑S) hf))),\n          invFun := ((Equiv.invFun (Equiv.Set.image (↑f) (↑S) hf))),\n          left_inv := (((Equiv.left_inv (Equiv.Set.image (↑f) (↑S) hf)))),\n          right_inv := (((Equiv.right_inv (Equiv.Set.image (↑f) (↑S) hf)))) }\n        x_1", "terms": [{"value": "↑x", "isProp": false, "context": ["{M : Type u_1}", "{N : Type u_2}", "[Add M]", "[Add N]", "(S : AddSubsemigroup M)", "(f : AddHom M N)", "(hf : Function.Injective ↑f)", "(x : { x : M // x ∈ S })", "(x_1 : { x : M // x ∈ S })"]}, {"value": "↑x_1", "isProp": false, "context": ["{M : Type u_1}", "{N : Type u_2}", "[Add M]", "[Add N]", "(S : AddSubsemigroup M)", "(f : AddHom M N)", "(hf : Function.Injective ↑f)", "(x : { x : M // x ∈ S })", "(x_1 : { x : M // x ∈ S })"]}], "namedLemmas": ["∀ {α : Sort u_1} {p : α → Prop} {a1 a2 : { x // p x }}, ↑a1 = ↑a2 → a1 = a2", "∀ {M : Type u_2} {N : Type u_3} {F : Type u_1} [inst : Add M] [inst_1 : Add N] [inst_2 : AddHomClass F M N] (f : F)\n  (x y : M), ↑f (x + y) = ↑f x + ↑f y"], "lemmas": [{"prop": "↑f (↑x + ↑x_1) = ↑f ↑x + ↑f ↑x_1", "context": ["{M : Type u_1}", "{N : Type u_2}", "[Add M]", "[Add N]", "(S : AddSubsemigroup M)", "(f : AddHom M N)", "(hf : Function.Injective ↑f)", "(x : { x : M // x ∈ S })", "(x_1 : { x : M // x ∈ S })"]}], "ids": ["Subtype.ext", "map_add"], "idString": "Subtype.ext; map_add; ", "context": []}
{"typeGroup": "(∀ {M : Type u_1} [inst : AddZeroClass M] (c : AddCon M) (x : M) (x_1 : M),\n    ZeroHom.toFun { toFun := ((AddCon.toQuotient)), map_zero' := (((rfl=:↑0 = ↑0))) } (x + x_1) =\n      ZeroHom.toFun { toFun := ((AddCon.toQuotient)), map_zero' := (((rfl=:↑0 = ↑0))) } (x + x_1) :\n  Prop)", "type": "∀ {M : Type u_1} [inst : AddZeroClass M] (c : AddCon M) (x : M) (x_1 : M),\n  ZeroHom.toFun { toFun := ((AddCon.toQuotient)), map_zero' := ((rfl)) } (x + x_1) =\n    ZeroHom.toFun { toFun := ((AddCon.toQuotient)), map_zero' := ((rfl)) } (x + x_1)", "thm": " : ∀ {M : Type u_1} [inst : AddZeroClass M] (c : AddCon M) (x : M) (x_1 : M),\n  ZeroHom.toFun { toFun := ((AddCon.toQuotient)), map_zero' := ((rfl)) } (x + x_1) =\n    ZeroHom.toFun { toFun := ((AddCon.toQuotient)), map_zero' := ((rfl)) } (x + x_1)", "terms": [], "namedLemmas": ["∀ {α : Sort u} {a : α}, a = a"], "lemmas": [], "ids": ["rfl"], "idString": "rfl; ", "context": []}
{"typeGroup": "(∀ {α : Type u_1} [inst : LinearOrder α] {s : Finset α} {k : ℕ} (h : Finset.card s = k) (hz : 0 < k),\n    ↑(Finset.orderEmbOfFin s h) { val := ((0)), isLt := ((hz)) } =\n      Finset.min' s\n        (Iff.mp (Finset.card_pos=:(0 < Finset.card s : Prop) ↔ (Finset.Nonempty s : Prop))\n            ((Eq.symm h=:k = Finset.card s) ▸ hz=:0 < Finset.card s)=:Finset.Nonempty s) :\n  Prop)", "type": "∀ {α : Type u_1} [inst : LinearOrder α] {s : Finset α} {k : ℕ} (h : Finset.card s = k) (hz : 0 < k),\n  List.nthLe (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s) 0\n      (Eq.mpr\n        (id\n          ((Finset.length_sort fun (x : α) (x_1 : α) ↦ x ≤ x_1) ▸\n            (Eq.refl\n              (↑{ val := ((0)), isLt := ((hz)) } < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s)))))\n        (Eq.mpr (id (h ▸ (Eq.refl (↑{ val := ((0)), isLt := ((hz)) } < Finset.card s))))\n          (Fin.isLt { val := ((0)), isLt := ((hz)) }))) =\n    Finset.min' s (Iff.mp Finset.card_pos ((Eq.symm h) ▸ hz))", "thm": " : ∀ {α : Type u_1} [inst : LinearOrder α] {s : Finset α} {k : ℕ} (h : Finset.card s = k) (hz : 0 < k),\n  List.nthLe (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s) 0\n      (Eq.mpr\n        (id\n          ((Finset.length_sort fun (x : α) (x_1 : α) ↦ x ≤ x_1) ▸\n            (Eq.refl\n              (↑{ val := ((0)), isLt := ((hz)) } < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s)))))\n        (Eq.mpr (id (h ▸ (Eq.refl (↑{ val := ((0)), isLt := ((hz)) } < Finset.card s))))\n          (Fin.isLt { val := ((0)), isLt := ((hz)) }))) =\n    Finset.min' s (Iff.mp Finset.card_pos ((Eq.symm h) ▸ hz))", "terms": [{"value": "Finset.min' s (Iff.mp Finset.card_pos ((Eq.symm h) ▸ hz))", "isProp": false, "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"value": "Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s", "isProp": false, "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"value": "{ val := ((0)), isLt := ((hz)) }", "isProp": false, "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"value": "Finset.min' s\n  (Iff.mp Finset.card_pos\n    (Eq.mp\n      ((Finset.length_sort fun (x : α) (x_1 : α) ↦ x ≤ x_1) ▸\n        (Eq.refl (0 < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s))))\n      (Eq.mpr\n        (id\n          ((Finset.length_sort fun (x : α) (x_1 : α) ↦ x ≤ x_1) ▸\n            (Eq.refl\n              (↑{ val := ((0)), isLt := ((hz)) } < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s)))))\n        (Eq.mpr (id (h ▸ (Eq.refl (↑{ val := ((0)), isLt := ((hz)) } < Finset.card s))))\n          (Fin.isLt { val := ((0)), isLt := ((hz)) })))))", "isProp": false, "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}], "namedLemmas": ["∀ {p : Prop}, p = True → p", "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {α : Type u_1} [inst : LinearOrder α] {s : Finset α} {h : 0 < List.length (Finset.sort (fun x x_1 => x ≤ x_1) s)},\n  List.nthLe (Finset.sort (fun x x_1 => x ≤ x_1) s) 0 h = Finset.min' s (_ : Finset.Nonempty s)", "∀ {a b : Prop}, (a ↔ b) → a → b", "∀ {α : Type u_1} {s : Finset α}, 0 < Finset.card s ↔ Finset.Nonempty s", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {α : Sort u_1} (a : α), (a = a) = True", "∀ {a b : Prop}, (a ↔ b) → a → b", "∀ {α : Type u_1} {s : Finset α}, 0 < Finset.card s ↔ Finset.Nonempty s", "∀ {α : Type u_1} (r : α → α → Prop) [inst : DecidableRel r] [inst_1 : IsTrans α r] [inst_2 : IsAntisymm α r]\n  [inst_3 : IsTotal α r] {s : Finset α}, List.length (Finset.sort r s) = Finset.card s", "∀ {α : Type u_1} (r : α → α → Prop) [inst : DecidableRel r] [inst_1 : IsTrans α r] [inst_2 : IsAntisymm α r]\n  [inst_3 : IsTotal α r] {s : Finset α}, List.length (Finset.sort r s) = Finset.card s", "∀ {n : ℕ} (self : Fin n), ↑self < n"], "lemmas": [{"prop": "List.nthLe (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s) 0\n    (Eq.mpr\n      (id\n        ((Finset.length_sort fun (x : α) (x_1 : α) ↦ x ≤ x_1) ▸\n          (Eq.refl\n            (↑{ val := ((0)), isLt := ((hz)) } < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s)))))\n      (Eq.mpr (id (h ▸ (Eq.refl (↑{ val := ((0)), isLt := ((hz)) } < Finset.card s))))\n        (Fin.isLt { val := ((0)), isLt := ((hz)) }))) =\n  Finset.min' s\n    (Iff.mp Finset.card_pos\n      (Eq.mp\n        ((Finset.length_sort fun (x : α) (x_1 : α) ↦ x ≤ x_1) ▸\n          (Eq.refl (0 < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s))))\n        (Eq.mpr\n          (id\n            ((Finset.length_sort fun (x : α) (x_1 : α) ↦ x ≤ x_1) ▸\n              (Eq.refl\n                (↑{ val := ((0)), isLt := ((hz)) } < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s)))))\n          (Eq.mpr (id (h ▸ (Eq.refl (↑{ val := ((0)), isLt := ((hz)) } < Finset.card s))))\n            (Fin.isLt { val := ((0)), isLt := ((hz)) })))))", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"prop": "Eq\n    (List.nthLe (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s) 0\n      (Eq.mpr\n        (id\n          ((Finset.length_sort fun (x : α) (x_1 : α) ↦ x ≤ x_1) ▸\n            (Eq.refl\n              (↑{ val := ((0)), isLt := ((hz)) } < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s)))))\n        (Eq.mpr (id (h ▸ (Eq.refl (↑{ val := ((0)), isLt := ((hz)) } < Finset.card s))))\n          (Fin.isLt { val := ((0)), isLt := ((hz)) })))) =\n  Eq\n    (Finset.min' s\n      (Iff.mp Finset.card_pos\n        (Eq.mp\n          ((Finset.length_sort fun (x : α) (x_1 : α) ↦ x ≤ x_1) ▸\n            (Eq.refl (0 < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s))))\n          (Eq.mpr\n            (id\n              ((Finset.length_sort fun (x : α) (x_1 : α) ↦ x ≤ x_1) ▸\n                (Eq.refl\n                  (↑{ val := ((0)), isLt := ((hz)) } < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s)))))\n            (Eq.mpr (id (h ▸ (Eq.refl (↑{ val := ((0)), isLt := ((hz)) } < Finset.card s))))\n              (Fin.isLt { val := ((0)), isLt := ((hz)) }))))))", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"prop": "(0 < Finset.card s) ↔ (Finset.Nonempty s)", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"prop": "k = Finset.card s", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"prop": "0 < Finset.card s", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"prop": "Finset.Nonempty s", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"prop": "(List.nthLe (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s) 0\n      (Eq.mpr\n        (id\n          ((Finset.length_sort fun (x : α) (x_1 : α) ↦ x ≤ x_1) ▸\n            (Eq.refl\n              (↑{ val := ((0)), isLt := ((hz)) } < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s)))))\n        (Eq.mpr (id (h ▸ (Eq.refl (↑{ val := ((0)), isLt := ((hz)) } < Finset.card s))))\n          (Fin.isLt { val := ((0)), isLt := ((hz)) }))) =\n    Finset.min' s (Iff.mp Finset.card_pos ((Eq.symm h) ▸ hz))) =\n  (Finset.min' s\n      (Iff.mp Finset.card_pos\n        (Eq.mp\n          ((Finset.length_sort fun (x : α) (x_1 : α) ↦ x ≤ x_1) ▸\n            (Eq.refl (0 < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s))))\n          (Eq.mpr\n            (id\n              ((Finset.length_sort fun (x : α) (x_1 : α) ↦ x ≤ x_1) ▸\n                (Eq.refl\n                  (↑{ val := ((0)), isLt := ((hz)) } < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s)))))\n            (Eq.mpr (id (h ▸ (Eq.refl (↑{ val := ((0)), isLt := ((hz)) } < Finset.card s))))\n              (Fin.isLt { val := ((0)), isLt := ((hz)) }))))) =\n    Finset.min' s (Iff.mp Finset.card_pos ((Eq.symm h) ▸ hz)))", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"prop": "(0 < Finset.card s) ↔ (Finset.Nonempty s)", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"prop": "List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s) = Finset.card s", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"prop": "(0 < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s)) =\n  (0 < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s))", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"prop": "(0 < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s)) = (0 < Finset.card s)", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"prop": "List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s) = Finset.card s", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"prop": "(↑{ val := ((0)), isLt := ((hz)) } < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s)) =\n  (↑{ val := ((0)), isLt := ((hz)) } < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s))", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"prop": "(↑{ val := ((0)), isLt := ((hz)) } < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s)) =\n  (↑{ val := ((0)), isLt := ((hz)) } < Finset.card s)", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"prop": "(↑{ val := ((0)), isLt := ((hz)) } < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s)) =\n  (↑{ val := ((0)), isLt := ((hz)) } < Finset.card s)", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"prop": "(↑{ val := ((0)), isLt := ((hz)) } < Finset.card s) = (↑{ val := ((0)), isLt := ((hz)) } < Finset.card s)", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"prop": "(↑{ val := ((0)), isLt := ((hz)) } < Finset.card s) = (↑{ val := ((0)), isLt := ((hz)) } < k)", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"prop": "(↑{ val := ((0)), isLt := ((hz)) } < Finset.card s) = (↑{ val := ((0)), isLt := ((hz)) } < k)", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"prop": "↑{ val := ((0)), isLt := ((hz)) } < k", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"prop": "↑{ val := ((0)), isLt := ((hz)) } < Finset.card s", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"prop": "↑{ val := ((0)), isLt := ((hz)) } < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s)", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"prop": "0 < Finset.card s", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"prop": "Finset.Nonempty s", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"prop": "(Finset.min' s\n      (Iff.mp Finset.card_pos\n        (Eq.mp\n          ((Finset.length_sort fun (x : α) (x_1 : α) ↦ x ≤ x_1) ▸\n            (Eq.refl (0 < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s))))\n          (Eq.mpr\n            (id\n              ((Finset.length_sort fun (x : α) (x_1 : α) ↦ x ≤ x_1) ▸\n                (Eq.refl\n                  (↑{ val := ((0)), isLt := ((hz)) } < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s)))))\n            (Eq.mpr (id (h ▸ (Eq.refl (↑{ val := ((0)), isLt := ((hz)) } < Finset.card s))))\n              (Fin.isLt { val := ((0)), isLt := ((hz)) }))))) =\n    Finset.min' s\n      (Iff.mp Finset.card_pos\n        (Eq.mp\n          ((Finset.length_sort fun (x : α) (x_1 : α) ↦ x ≤ x_1) ▸\n            (Eq.refl (0 < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s))))\n          (Eq.mpr\n            (id\n              ((Finset.length_sort fun (x : α) (x_1 : α) ↦ x ≤ x_1) ▸\n                (Eq.refl\n                  (↑{ val := ((0)), isLt := ((hz)) } < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s)))))\n            (Eq.mpr (id (h ▸ (Eq.refl (↑{ val := ((0)), isLt := ((hz)) } < Finset.card s))))\n              (Fin.isLt { val := ((0)), isLt := ((hz)) })))))) =\n  True", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}, {"prop": "(List.nthLe (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s) 0\n      (Eq.mpr\n        (id\n          ((Finset.length_sort fun (x : α) (x_1 : α) ↦ x ≤ x_1) ▸\n            (Eq.refl\n              (↑{ val := ((0)), isLt := ((hz)) } < List.length (Finset.sort (fun (x : α) (x_1 : α) ↦ x ≤ x_1) s)))))\n        (Eq.mpr (id (h ▸ (Eq.refl (↑{ val := ((0)), isLt := ((hz)) } < Finset.card s))))\n          (Fin.isLt { val := ((0)), isLt := ((hz)) }))) =\n    Finset.min' s (Iff.mp Finset.card_pos ((Eq.symm h) ▸ hz))) =\n  True", "context": ["{α : Type u_1}", "[LinearOrder α]", "{s : Finset α}", "{k : ℕ}", "(h : Finset.card s = k)", "(hz : 0 < k)"]}], "ids": ["of_eq_true", "Eq.trans", "congrFun", "congrArg", "Eq", "Finset.sorted_zero_eq_min'", "Finset.min'", "Iff.mp", "Finset.card_pos", "Eq.symm", "eq_self", "Finset.min'", "Iff.mp", "Finset.card_pos", "Eq.mp", "Finset.length_sort", "Eq.refl", "List.length", "Finset.sort", "Eq.mpr", "id", "Finset.length_sort", "Eq.refl", "val", "isLt", "List.length", "Finset.sort", "Eq.mpr", "id", "Eq.refl", "val", "isLt", "Finset.card", "Fin.isLt", "val", "isLt"], "idString": "of_eq_true; Eq.trans; congrFun; congrArg; Eq; Finset.sorted_zero_eq_min'; Finset.min'; Iff.mp; Finset.card_pos; Eq.symm; eq_self; Finset.min'; Iff.mp; Finset.card_pos; Eq.mp; Finset.length_sort; Eq.refl; List.length; Finset.sort; Eq.mpr; id; Finset.length_sort; Eq.refl; val; isLt; List.length; Finset.sort; Eq.mpr; id; Eq.refl; val; isLt; Finset.card; Fin.isLt; val; isLt; ", "context": []}
{"typeGroup": "(∀ {J : Type u_2} [inst : CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J AddCommMonCatMax)\n    (s : CategoryTheory.Limits.Cone F),\n    {\n        val :=\n          ((fun (j : J) ↦\n            CategoryTheory.NatTrans.app\n              (CategoryTheory.Limits.Cone.π\n                ((CategoryTheory.forget AddMonCatMax).mapCone\n                  ((CategoryTheory.forget₂ AddCommMonCat AddMonCat).mapCone s)))\n              j 0)),\n        property :=\n          ((((@CategoryTheory.Limits.Types.limitConeIsLimit.proof_1 J inst\n                (CategoryTheory.Functor.comp\n                  (CategoryTheory.Functor.comp F (CategoryTheory.forget₂ AddCommMonCat AddMonCat))\n                  (CategoryTheory.forget AddMonCatMax))\n                ((CategoryTheory.forget AddMonCatMax).mapCone\n                  ((CategoryTheory.forget₂ AddCommMonCat AddMonCat).mapCone s))\n                0=:∀ {j : J} {j' : J} (f : j ⟶ j'),\n                CategoryTheory.CategoryStruct.comp\n                    (CategoryTheory.NatTrans.app\n                      (CategoryTheory.Limits.Cone.π\n                        ((CategoryTheory.forget AddMonCatMax).mapCone\n                          ((CategoryTheory.forget₂ AddCommMonCat AddMonCat).mapCone s)))\n                      j)\n                    ((CategoryTheory.Functor.toPrefunctor\n                          (CategoryTheory.Functor.comp\n                            (CategoryTheory.Functor.comp F (CategoryTheory.forget₂ AddCommMonCat AddMonCat))\n                            (CategoryTheory.forget AddMonCatMax))).map\n                      f)\n                    0 =\n                  CategoryTheory.NatTrans.app\n                    (CategoryTheory.Limits.Cone.π\n                      ((CategoryTheory.forget AddMonCatMax).mapCone\n                        ((CategoryTheory.forget₂ AddCommMonCat AddMonCat).mapCone s)))\n                    j'\n                    0)=:∀ {j : J} {j' : J} (f : j ⟶ j'),\n              CategoryTheory.CategoryStruct.comp\n                  (CategoryTheory.NatTrans.app\n                    (CategoryTheory.Limits.Cone.π\n                      ((CategoryTheory.forget AddMonCatMax).mapCone\n                        ((CategoryTheory.forget₂ AddCommMonCat AddMonCat).mapCone s)))\n                    j)\n                  ((CategoryTheory.Functor.toPrefunctor\n                        (CategoryTheory.Functor.comp\n                          (CategoryTheory.Functor.comp F (CategoryTheory.forget₂ AddCommMonCat AddMonCat))\n                          (CategoryTheory.forget AddMonCatMax))).map\n                    f)\n                  0 =\n                CategoryTheory.NatTrans.app\n                  (CategoryTheory.Limits.Cone.π\n                    ((CategoryTheory.forget AddMonCatMax).mapCone\n                      ((CategoryTheory.forget₂ AddCommMonCat AddMonCat).mapCone s)))\n                  j' 0))) } =\n      0 :\n  Prop)", "type": "∀ {J : Type u_2} [inst : CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J AddCommMonCatMax)\n  (s : CategoryTheory.Limits.Cone F),\n  {\n      val :=\n        ((fun (j : J) ↦\n          CategoryTheory.NatTrans.app\n            (CategoryTheory.Limits.Cone.π\n              ((CategoryTheory.forget AddMonCatMax).mapCone\n                ((CategoryTheory.forget₂ AddCommMonCat AddMonCat).mapCone s)))\n            j 0)),\n      property :=\n        (((@CategoryTheory.Limits.Types.limitConeIsLimit.proof_1 J inst\n          (CategoryTheory.Functor.comp (CategoryTheory.Functor.comp F (CategoryTheory.forget₂ AddCommMonCat AddMonCat))\n            (CategoryTheory.forget AddMonCatMax))\n          ((CategoryTheory.forget AddMonCatMax).mapCone ((CategoryTheory.forget₂ AddCommMonCat AddMonCat).mapCone s))\n          0))) } =\n    0", "thm": " : ∀ {J : Type u_2} [inst : CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J AddCommMonCatMax)\n  (s : CategoryTheory.Limits.Cone F),\n  {\n      val :=\n        ((fun (j : J) ↦\n          CategoryTheory.NatTrans.app\n            (CategoryTheory.Limits.Cone.π\n              ((CategoryTheory.forget AddMonCatMax).mapCone\n                ((CategoryTheory.forget₂ AddCommMonCat AddMonCat).mapCone s)))\n            j 0)),\n      property :=\n        (((@CategoryTheory.Limits.Types.limitConeIsLimit.proof_1 J inst\n          (CategoryTheory.Functor.comp (CategoryTheory.Functor.comp F (CategoryTheory.forget₂ AddCommMonCat AddMonCat))\n            (CategoryTheory.forget AddMonCatMax))\n          ((CategoryTheory.forget AddMonCatMax).mapCone ((CategoryTheory.forget₂ AddCommMonCat AddMonCat).mapCone s))\n          0))) } =\n    0", "terms": [{"value": "CategoryTheory.forget₂ AddCommMonCat AddMonCat", "isProp": false, "context": ["{J : Type u_2}", "[CategoryTheory.SmallCategory J]", "(F : CategoryTheory.Functor J AddCommMonCatMax)", "(s : CategoryTheory.Limits.Cone F)"]}, {"value": "CategoryTheory.Functor.comp F (CategoryTheory.forget₂ AddCommMonCat AddMonCat)", "isProp": false, "context": ["{J : Type u_2}", "[CategoryTheory.SmallCategory J]", "(F : CategoryTheory.Functor J AddCommMonCatMax)", "(s : CategoryTheory.Limits.Cone F)"]}, {"value": "(CategoryTheory.forget₂ AddCommMonCat AddMonCat).mapCone s", "isProp": false, "context": ["{J : Type u_2}", "[CategoryTheory.SmallCategory J]", "(F : CategoryTheory.Functor J AddCommMonCatMax)", "(s : CategoryTheory.Limits.Cone F)"]}], "namedLemmas": ["∀ {J : Type u_2} [inst : CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J AddMonCatMax)\n  (s : CategoryTheory.Limits.Cone F),\n  { val := fun j => CategoryTheory.NatTrans.app ((CategoryTheory.forget AddMonCatMax).mapCone s).π j 0,\n      property :=\n        (_ :\n          ∀ {j j' : J} (f : j ⟶ j'),\n            CategoryTheory.CategoryStruct.comp\n                (CategoryTheory.NatTrans.app ((CategoryTheory.forget AddMonCatMax).mapCone s).π j)\n                ((CategoryTheory.Functor.comp F (CategoryTheory.forget AddMonCatMax)).map f) 0 =\n              CategoryTheory.NatTrans.app ((CategoryTheory.forget AddMonCatMax).mapCone s).π j' 0) } =\n    0"], "lemmas": [], "ids": ["AddMonCat.HasLimits.limitConeIsLimit.proof_2", "CategoryTheory.Functor.comp", "CategoryTheory.forget₂", "AddCommMonCat", "AddMonCat", "CategoryTheory.forget₂", "AddCommMonCat", "AddMonCat", "mapCone"], "idString": "AddMonCat.HasLimits.limitConeIsLimit.proof_2; CategoryTheory.Functor.comp; CategoryTheory.forget₂; AddCommMonCat; AddMonCat; CategoryTheory.forget₂; AddCommMonCat; AddMonCat; mapCone; ", "context": []}
{"typeGroup": "(∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [inst_1 : DecidableEq α] (gcd : (a : α) → (a : α) → α)\n    (gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)\n    (dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b) (a : α),\n    (fun (a : α) (b : α) ↦\n          if (a = 0 : Prop) then 0\n          else\n            Classical.choose\n              (Dvd.dvd.trans (gcd_dvd_left a b=:gcd a b ∣ a)\n                  (Dvd.intro b (rfl=:a * b = a * b)=:a ∣ a * b)=:gcd a b ∣ a * b))\n        a 0 =\n      0 :\n  Prop)", "type": "∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [inst_1 : DecidableEq α] (gcd : (a : α) → (a : α) → α)\n  (gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)\n  (dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b) (a : α),\n  (fun (a : α) (b : α) ↦ if (a = 0) then 0 else Classical.choose (Dvd.dvd.trans (gcd_dvd_left a b) (Dvd.intro b rfl))) a\n      0 =\n    0", "thm": " : ∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [inst_1 : DecidableEq α] (gcd : (a : α) → (a : α) → α)\n  (gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)\n  (dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b) (a : α),\n  (fun (a : α) (b : α) ↦ if (a = 0) then 0 else Classical.choose (Dvd.dvd.trans (gcd_dvd_left a b) (Dvd.intro b rfl))) a\n      0 =\n    0", "terms": [{"value": "gcd a 0", "isProp": false, "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)"]}, {"value": "(a = 0)", "isProp": true, "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)"]}], "namedLemmas": ["∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {c : Prop} {h : Decidable c}, c → ∀ {α : Sort u} {t e : α}, (if c then t else e) = t", "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "∀ {c : Prop} {h : Decidable c}, ¬c → ∀ {α : Sort u} {t e : α}, (if c then t else e) = e", "∀ {a b : Prop}, a ∨ b → ¬a → b", "∀ {a b : Prop}, (a ↔ b) → a → b", "∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 ↔ a = 0 ∨ b = 0", "∀ {α : Type u_1} [inst : Semigroup α] {a b c : α}, a ∣ b → b ∣ c → a ∣ c", "∀ {α : Type u_1} [inst : Semigroup α] {a b : α} (c : α), a * c = b → a ∣ b", "∀ {α : Sort u} {a : α}, a = a", "∀ {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀), a * 0 = 0", "∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂)", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {α : Type u_1} [inst : MonoidWithZero α] (a : α), Associated a 0 ↔ a = 0", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {α : Type u_1} [inst : CancelMonoidWithZero α] {a b : α}, a ∣ b → b ∣ a → Associated a b", "∀ {α : Type u_1} [inst : Monoid α] (a : α), a ∣ a", "∀ {α : Type u_1} [inst : SemigroupWithZero α] (a : α), a ∣ 0", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {α : Sort u} {p : α → Prop} (h : ∃ x, p x), p (Classical.choose h)", "∀ {α : Type u_1} [inst : Semigroup α] {a b c : α}, a ∣ b → b ∣ c → a ∣ c", "∀ {α : Type u_1} [inst : Semigroup α] {a b : α} (c : α), a * c = b → a ∣ b", "∀ {α : Sort u} {a : α}, a = a"], "lemmas": [{"prop": "(if (a = 0) then 0 else Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl))) = 0", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)"]}, {"prop": "Eq (if (a = 0) then 0 else Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl))) = Eq 0", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)"]}, {"prop": "((if (a = 0) then 0 else Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl))) = 0) = (0 = 0)", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)"]}, {"prop": "((if (a = 0) then 0 else Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl))) = 0) = (0 = 0)", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)"]}, {"prop": "0 = 0", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)"]}, {"prop": "(if (a = 0) then 0 else Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl))) = 0", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)"]}, {"prop": "(if (a = 0) then 0 else Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl))) =\n  Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl))", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)"]}, {"prop": "Eq (if (a = 0) then 0 else Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl))) =\n  Eq (Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)))", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)"]}, {"prop": "((if (a = 0) then 0 else Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl))) = 0) =\n  (Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = 0)", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)"]}, {"prop": "((if (a = 0) then 0 else Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl))) = 0) =\n  (Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = 0)", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)"]}, {"prop": "(gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = 0) ↔\n  ((gcd a 0 = 0) ∨ (Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = 0))", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0' : gcd a 0 ≠ 0)"]}, {"prop": "gcd a 0 ∣ a", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0' : gcd a 0 ≠ 0)"]}, {"prop": "a * 0 = a * 0", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0' : gcd a 0 ≠ 0)"]}, {"prop": "a ∣ a * 0", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0' : gcd a 0 ≠ 0)"]}, {"prop": "gcd a 0 ∣ a * 0", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0' : gcd a 0 ≠ 0)"]}, {"prop": "(gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = 0) =\n  (gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = 0)", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0' : gcd a 0 ≠ 0)"]}, {"prop": "(gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = 0) = (a * 0 = 0)", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0' : gcd a 0 ≠ 0)"]}, {"prop": "(gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = 0) = (a * 0 = 0)", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0' : gcd a 0 ≠ 0)"]}, {"prop": "a * 0 = 0", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0' : gcd a 0 ≠ 0)"]}, {"prop": "(a * 0 = 0) = (a * 0 = 0)", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0' : gcd a 0 ≠ 0)"]}, {"prop": "(a * 0 = 0) = (0 = 0)", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0' : gcd a 0 ≠ 0)"]}, {"prop": "(a * 0 = 0) = (0 = 0)", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0' : gcd a 0 ≠ 0)"]}, {"prop": "0 = 0", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0' : gcd a 0 ≠ 0)"]}, {"prop": "a * 0 = 0", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0' : gcd a 0 ≠ 0)"]}, {"prop": "gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = 0", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0' : gcd a 0 ≠ 0)"]}, {"prop": "(gcd a 0 = 0) ∨ (Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = 0)", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0' : gcd a 0 ≠ 0)"]}, {"prop": "(¬(gcd a 0 ≠ 0)) = (gcd a 0 = 0)", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)"]}, {"prop": "(¬(¬(a = 0))) = (a = 0)", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)"]}, {"prop": "(∀ (a_1 : ¬(gcd a 0 ≠ 0)), ¬(¬(a = 0))) = (∀ (a_1 : gcd a 0 = 0), a = 0)", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)"]}, {"prop": "(∀ (a_1 : ¬(gcd a 0 ≠ 0)), ¬(¬(a = 0))) = (∀ (a_1 : gcd a 0 = 0), a = 0)", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)"]}, {"prop": "(Associated a 0) ↔ (a = 0)", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0 : gcd a 0 = 0)"]}, {"prop": "(Associated a 0) = (a = 0)", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0 : gcd a 0 = 0)"]}, {"prop": "(a = 0) = (Associated a 0)", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0 : gcd a 0 = 0)"]}, {"prop": "(a = 0) = (a = 0)", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0 : gcd a 0 = 0)"]}, {"prop": "(a = 0) = (Associated a 0)", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0 : gcd a 0 = 0)"]}, {"prop": "(a = 0) = (Associated a 0)", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0 : gcd a 0 = 0)"]}, {"prop": "0 = gcd a 0", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0 : gcd a 0 = 0)"]}, {"prop": "(Associated a 0) = (Associated a 0)", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0 : gcd a 0 = 0)"]}, {"prop": "(Associated a 0) = (Associated a (gcd a 0))", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0 : gcd a 0 = 0)"]}, {"prop": "(Associated a 0) = (Associated a (gcd a 0))", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0 : gcd a 0 = 0)"]}, {"prop": "a ∣ a", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0 : gcd a 0 = 0)"]}, {"prop": "a ∣ 0", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0 : gcd a 0 = 0)"]}, {"prop": "a ∣ gcd a 0", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0 : gcd a 0 = 0)"]}, {"prop": "gcd a 0 ∣ a", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0 : gcd a 0 = 0)"]}, {"prop": "Associated a (gcd a 0)", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0 : gcd a 0 = 0)"]}, {"prop": "Associated a 0", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)", "(a0 : gcd a 0 = 0)"]}, {"prop": "∀ (a0 : gcd a 0 = 0), a = 0", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)"]}, {"prop": "∀ (a_1 : ¬(gcd a 0 ≠ 0)), ¬(¬(a = 0))", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)", "(h : gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = a * 0)"]}, {"prop": "gcd a 0 ∣ a", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)"]}, {"prop": "a * 0 = a * 0", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)"]}, {"prop": "a ∣ a * 0", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)"]}, {"prop": "gcd a 0 ∣ a * 0", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)"]}, {"prop": "a * 0 = gcd a 0 * Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl))", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)"]}, {"prop": "Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl)) = 0", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)"]}, {"prop": "(if (a = 0) then 0 else Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl))) = 0", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)"]}, {"prop": "(if (a = 0) then 0 else Classical.choose (Dvd.dvd.trans (gcd_dvd_left a 0) (Dvd.intro 0 rfl))) = 0", "context": ["{α : Type u_1}", "[CancelCommMonoidWithZero α]", "[DecidableEq α]", "(gcd : (a : α) → (a : α) → α)", "(gcd_dvd_left : ∀ (a : α) (b : α), gcd a b ∣ a)", "(dvd_gcd : ∀ {a : α} {b : α} {c : α} (a_1 : a ∣ c) (a_2 : a ∣ b), a ∣ gcd c b)", "(a : α)"]}], "ids": ["id", "a0", "Eq.mpr", "id", "congrFun", "congrArg", "Eq", "if_pos", "a0", "Eq.refl", "Eq.mpr", "id", "congrFun", "congrArg", "Eq", "if_neg", "a0", "Or.resolve_left", "Iff.mp", "mul_eq_zero", "Eq.mpr", "id", "Eq.refl", "Classical.choose", "Dvd.dvd.trans", "Dvd.intro", "rfl", "Eq.mpr", "id", "mul_zero", "Eq.refl", "Eq.refl", "Eq.mpr", "id", "implies_congr", "Eq.mpr", "id", "Eq.symm", "propext", "associated_zero_iff_eq_zero", "Eq.refl", "Eq.mpr", "id", "Eq.symm", "Eq.refl", "Associated", "associated_of_dvd_dvd", "dvd_refl", "dvd_zero", "a0", "Eq.symm", "Classical.choose_spec", "Dvd.dvd.trans", "Dvd.intro", "rfl"], "idString": "id; a0; Eq.mpr; id; congrFun; congrArg; Eq; if_pos; a0; Eq.refl; Eq.mpr; id; congrFun; congrArg; Eq; if_neg; a0; Or.resolve_left; Iff.mp; mul_eq_zero; Eq.mpr; id; Eq.refl; Classical.choose; Dvd.dvd.trans; Dvd.intro; rfl; Eq.mpr; id; mul_zero; Eq.refl; Eq.refl; Eq.mpr; id; implies_congr; Eq.mpr; id; Eq.symm; propext; associated_zero_iff_eq_zero; Eq.refl; Eq.mpr; id; Eq.symm; Eq.refl; Associated; associated_of_dvd_dvd; dvd_refl; dvd_zero; a0; Eq.symm; Classical.choose_spec; Dvd.dvd.trans; Dvd.intro; rfl; ", "context": []}
{"typeGroup": "(∀ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n    {S : CategoryTheory.ShortComplex Cᵒᵖ} (h : CategoryTheory.ShortComplex.RightHomologyData S),\n    CategoryTheory.CategoryStruct.comp\n        (CategoryTheory.Limits.IsLimit.lift\n          (CategoryTheory.Limits.CokernelCofork.IsColimit.ofπUnop (CategoryTheory.ShortComplex.RightHomologyData.p h)\n            (CategoryTheory.ShortComplex.RightHomologyData.wp\n                h=:CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.f S)\n                  (CategoryTheory.ShortComplex.RightHomologyData.p h) =\n                0)\n            (CategoryTheory.ShortComplex.RightHomologyData.hp h))\n          (CategoryTheory.Limits.KernelFork.ofι (CategoryTheory.ShortComplex.f (CategoryTheory.ShortComplex.unop S))\n            (CategoryTheory.ShortComplex.zero\n                (CategoryTheory.ShortComplex.unop\n                  S)=:CategoryTheory.CategoryStruct.comp\n                  (CategoryTheory.ShortComplex.f (CategoryTheory.ShortComplex.unop S))\n                  (CategoryTheory.ShortComplex.g (CategoryTheory.ShortComplex.unop S)) =\n                0)))\n        (CategoryTheory.ShortComplex.RightHomologyData.ι h).unop =\n      0 :\n  Prop)", "type": "∀ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  {S : CategoryTheory.ShortComplex Cᵒᵖ} (h : CategoryTheory.ShortComplex.RightHomologyData S),\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.Limits.IsLimit.lift\n        (CategoryTheory.Limits.CokernelCofork.IsColimit.ofπUnop (CategoryTheory.ShortComplex.RightHomologyData.p h)\n          (CategoryTheory.ShortComplex.RightHomologyData.wp h) (CategoryTheory.ShortComplex.RightHomologyData.hp h))\n        (CategoryTheory.Limits.KernelFork.ofι (CategoryTheory.ShortComplex.f (CategoryTheory.ShortComplex.unop S))\n          (CategoryTheory.ShortComplex.zero (CategoryTheory.ShortComplex.unop S))))\n      (CategoryTheory.ShortComplex.RightHomologyData.ι h).unop =\n    0", "thm": " : ∀ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  {S : CategoryTheory.ShortComplex Cᵒᵖ} (h : CategoryTheory.ShortComplex.RightHomologyData S),\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.Limits.IsLimit.lift\n        (CategoryTheory.Limits.CokernelCofork.IsColimit.ofπUnop (CategoryTheory.ShortComplex.RightHomologyData.p h)\n          (CategoryTheory.ShortComplex.RightHomologyData.wp h) (CategoryTheory.ShortComplex.RightHomologyData.hp h))\n        (CategoryTheory.Limits.KernelFork.ofι (CategoryTheory.ShortComplex.f (CategoryTheory.ShortComplex.unop S))\n          (CategoryTheory.ShortComplex.zero (CategoryTheory.ShortComplex.unop S))))\n      (CategoryTheory.ShortComplex.RightHomologyData.ι h).unop =\n    0", "terms": [], "namedLemmas": ["∀ {C : Type u₁} [inst : Quiver C] {X Y : C}, Function.Injective Quiver.Hom.op", "∀ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  {S : CategoryTheory.ShortComplex C} (self : CategoryTheory.ShortComplex.RightHomologyData S),\n  CategoryTheory.CategoryStruct.comp self.ι\n      (CategoryTheory.Limits.IsColimit.desc self.hp\n        (CategoryTheory.Limits.CokernelCofork.ofπ S.g (_ : CategoryTheory.CategoryStruct.comp S.f S.g = 0))) =\n    0"], "lemmas": [{"prop": "CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.RightHomologyData.ι h)\n    (CategoryTheory.Limits.IsColimit.desc (CategoryTheory.ShortComplex.RightHomologyData.hp h)\n      (CategoryTheory.Limits.CokernelCofork.ofπ (CategoryTheory.ShortComplex.g S)\n        (CategoryTheory.ShortComplex.zero S))) =\n  0", "context": ["{C : Type u_2}", "[CategoryTheory.Category C]", "[CategoryTheory.Limits.HasZeroMorphisms C]", "{S : CategoryTheory.ShortComplex Cᵒᵖ}", "(h : CategoryTheory.ShortComplex.RightHomologyData S)"]}], "ids": ["Quiver.Hom.op_inj", "CategoryTheory.ShortComplex.RightHomologyData.wι"], "idString": "Quiver.Hom.op_inj; CategoryTheory.ShortComplex.RightHomologyData.wι; ", "context": []}
{"typeGroup": "(∀ (α : Type u_1) (β : Type u_2) (f : Option α ↪ β),\n    (fun (f : (f : α ↪ β) × ↑(Set.range ↑f)ᶜ) ↦\n          Function.Embedding.optionElim (Sigma.fst f) ↑(Sigma.snd f)\n            (Subtype.property (Sigma.snd f)=:↑(Sigma.snd f) ∈ (Set.range ↑(Sigma.fst f))ᶜ))\n        ((fun (f : Option α ↪ β) ↦\n            { fst := ((Function.Embedding.trans Function.Embedding.coeWithTop f)),\n              snd :=\n                (({ val := ((↑f none)),\n                  property :=\n                    (((fun (x : ↑f none ∈ Set.range ↑(Function.Embedding.trans Function.Embedding.coeWithTop f)) ↦\n                      (_ :\n                        False)=:∀ (x : ↑f none ∈ Set.range ↑(Function.Embedding.trans Function.Embedding.coeWithTop f)),\n                        False))) })) })\n          f) =\n      f :\n  Prop)", "type": "∀ (α : Type u_1) (β : Type u_2) (f : Option α ↪ β),\n  (fun (f : (f : α ↪ β) × ↑(Set.range ↑f)ᶜ) ↦\n        Function.Embedding.optionElim (Sigma.fst f) ↑(Sigma.snd f) (Subtype.property (Sigma.snd f)))\n      ((fun (f : Option α ↪ β) ↦\n          { fst := ((Function.Embedding.trans Function.Embedding.coeWithTop f)),\n            snd :=\n              (({ val := ((↑f none)),\n                property :=\n                  (((fun (x : ↑f none ∈ Set.range ↑(Function.Embedding.trans Function.Embedding.coeWithTop f)) ↦\n                    Function.Embedding.optionEmbeddingEquiv.match_1 α β f\n                      (fun (x : ↑f none ∈ Set.range ↑(Function.Embedding.trans Function.Embedding.coeWithTop f)) ↦\n                        False)\n                      x\n                      (fun (x : α) (hx : ↑(Function.Embedding.trans Function.Embedding.coeWithTop f) x = ↑f none) ↦\n                        Option.some_ne_none x (Function.Embedding.injective f hx))))) })) })\n        f) =\n    f", "thm": " : ∀ (α : Type u_1) (β : Type u_2) (f : Option α ↪ β),\n  (fun (f : (f : α ↪ β) × ↑(Set.range ↑f)ᶜ) ↦\n        Function.Embedding.optionElim (Sigma.fst f) ↑(Sigma.snd f) (Subtype.property (Sigma.snd f)))\n      ((fun (f : Option α ↪ β) ↦\n          { fst := ((Function.Embedding.trans Function.Embedding.coeWithTop f)),\n            snd :=\n              (({ val := ((↑f none)),\n                property :=\n                  (((fun (x : ↑f none ∈ Set.range ↑(Function.Embedding.trans Function.Embedding.coeWithTop f)) ↦\n                    Function.Embedding.optionEmbeddingEquiv.match_1 α β f\n                      (fun (x : ↑f none ∈ Set.range ↑(Function.Embedding.trans Function.Embedding.coeWithTop f)) ↦\n                        False)\n                      x\n                      (fun (x : α) (hx : ↑(Function.Embedding.trans Function.Embedding.coeWithTop f) x = ↑f none) ↦\n                        Option.some_ne_none x (Function.Embedding.injective f hx))))) })) })\n        f) =\n    f", "terms": [{"value": "↑f none", "isProp": false, "context": ["(α : Type u_1)", "(β : Type u_2)", "(f : Option α ↪ β)", "(x : Option α)"]}], "namedLemmas": ["∀ {α : Sort u_1} {β : Sort u_2} {f g : α ↪ β}, (∀ (x : α), ↑f x = ↑g x) → f = g", "∀ {p : Prop}, p = True → p", "∀ {α : Sort u_1} (a : α), (a = a) = True"], "lemmas": [{"prop": "(↑f none = ↑f none) = True", "context": ["(α : Type u_1)", "(β : Type u_2)", "(f : Option α ↪ β)", "(x : Option α)"]}, {"prop": "↑f none = ↑f none", "context": ["(α : Type u_1)", "(β : Type u_2)", "(f : Option α ↪ β)", "(x : Option α)"]}, {"prop": "(↑f ↑val = ↑f (some val)) = (↑val = some val)", "context": ["(α : Type u_1)", "(β : Type u_2)", "(f : Option α ↪ β)", "(x : Option α)", "(val : α)"]}, {"prop": "(↑((fun (f : (f : α ↪ β) × ↑(Set.range ↑f)ᶜ) ↦\n            Function.Embedding.optionElim (Sigma.fst f) ↑(Sigma.snd f) (Subtype.property (Sigma.snd f)))\n          ((fun (f : Option α ↪ β) ↦\n              { fst := ((Function.Embedding.trans Function.Embedding.coeWithTop f)),\n                snd :=\n                  (({ val := ((↑f none)),\n                    property :=\n                      (((fun (x : ↑f none ∈ Set.range ↑(Function.Embedding.trans Function.Embedding.coeWithTop f)) ↦\n                        Function.Embedding.optionEmbeddingEquiv.match_1 α β f\n                          (fun (x : ↑f none ∈ Set.range ↑(Function.Embedding.trans Function.Embedding.coeWithTop f)) ↦\n                            False)\n                          x\n                          (fun (x : α) (hx : ↑(Function.Embedding.trans Function.Embedding.coeWithTop f) x = ↑f none) ↦\n                            Option.some_ne_none x (Function.Embedding.injective f hx))))) })) })\n            f))\n      (some val) =\n    ↑f (some val)) =\n  (↑val = some val)", "context": ["(α : Type u_1)", "(β : Type u_2)", "(f : Option α ↪ β)", "(x : Option α)", "(val : α)"]}, {"prop": "↑val = ↑val", "context": ["(α : Type u_1)", "(β : Type u_2)", "(f : Option α ↪ β)", "(x : Option α)", "(val : α)"]}, {"prop": "∀ (val : α),\n  ↑((fun (f : (f : α ↪ β) × ↑(Set.range ↑f)ᶜ) ↦\n            Function.Embedding.optionElim (Sigma.fst f) ↑(Sigma.snd f) (Subtype.property (Sigma.snd f)))\n          ((fun (f : Option α ↪ β) ↦\n              { fst := ((Function.Embedding.trans Function.Embedding.coeWithTop f)),\n                snd :=\n                  (({ val := ((↑f none)),\n                    property :=\n                      (((fun (x : ↑f none ∈ Set.range ↑(Function.Embedding.trans Function.Embedding.coeWithTop f)) ↦\n                        Function.Embedding.optionEmbeddingEquiv.match_1 α β f\n                          (fun (x : ↑f none ∈ Set.range ↑(Function.Embedding.trans Function.Embedding.coeWithTop f)) ↦\n                            False)\n                          x\n                          (fun (x : α) (hx : ↑(Function.Embedding.trans Function.Embedding.coeWithTop f) x = ↑f none) ↦\n                            Option.some_ne_none x (Function.Embedding.injective f hx))))) })) })\n            f))\n      (some val) =\n    ↑f (some val)", "context": ["(α : Type u_1)", "(β : Type u_2)", "(f : Option α ↪ β)", "(x : Option α)"]}, {"prop": "∀ (x : Option α),\n  ↑((fun (f : (f : α ↪ β) × ↑(Set.range ↑f)ᶜ) ↦\n            Function.Embedding.optionElim (Sigma.fst f) ↑(Sigma.snd f) (Subtype.property (Sigma.snd f)))\n          ((fun (f : Option α ↪ β) ↦\n              { fst := ((Function.Embedding.trans Function.Embedding.coeWithTop f)),\n                snd :=\n                  (({ val := ((↑f none)),\n                    property :=\n                      (((fun (x : ↑f none ∈ Set.range ↑(Function.Embedding.trans Function.Embedding.coeWithTop f)) ↦\n                        Function.Embedding.optionEmbeddingEquiv.match_1 α β f\n                          (fun (x : ↑f none ∈ Set.range ↑(Function.Embedding.trans Function.Embedding.coeWithTop f)) ↦\n                            False)\n                          x\n                          (fun (x : α) (hx : ↑(Function.Embedding.trans Function.Embedding.coeWithTop f) x = ↑f none) ↦\n                            Option.some_ne_none x (Function.Embedding.injective f hx))))) })) })\n            f))\n      x =\n    ↑f x", "context": ["(α : Type u_1)", "(β : Type u_2)", "(f : Option α ↪ β)"]}], "ids": ["Function.Embedding.ext", "of_eq_true", "eq_self", "none", "Eq.mpr", "id", "Mathlib.Data.FunLike.Embedding._auxLemma.1", "Eq.refl"], "idString": "Function.Embedding.ext; of_eq_true; eq_self; none; Eq.mpr; id; Mathlib.Data.FunLike.Embedding._auxLemma.1; Eq.refl; ", "context": []}
{"typeGroup": "(∀ {α : Sort u_2} {β : Type u_1} (p : Set β) (f : α ↪ β) (H : ∀ (a : α), ↑f a ∈ p) (x : α) (x_1 : α)\n    (h :\n      (fun (a : α) ↦ { val := ((↑f a)), property := (((H a=:↑f a ∈ p))) }) x =\n        (fun (a : α) ↦ { val := ((↑f a)), property := (((H a=:↑f a ∈ p))) }) x_1),\n    x = x_1 :\n  Prop)", "type": "∀ {α : Sort u_2} {β : Type u_1} (p : Set β) (f : α ↪ β) (H : ∀ (a : α), ↑f a ∈ p) (x : α) (x_1 : α)\n  (h :\n    (fun (a : α) ↦ { val := ((↑f a)), property := (((H a))) }) x =\n      (fun (a : α) ↦ { val := ((↑f a)), property := (((H a))) }) x_1),\n  x = x_1", "thm": " : ∀ {α : Sort u_2} {β : Type u_1} (p : Set β) (f : α ↪ β) (H : ∀ (a : α), ↑f a ∈ p) (x : α) (x_1 : α)\n  (h :\n    (fun (a : α) ↦ { val := ((↑f a)), property := (((H a))) }) x =\n      (fun (a : α) ↦ { val := ((↑f a)), property := (((H a))) }) x_1),\n  x = x_1", "terms": [], "namedLemmas": ["∀ {α : Sort u_1} {β : Sort u_2} (f : α ↪ β), Function.Injective ↑f", "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂"], "lemmas": [{"prop": "↑((fun (a : α) ↦ { val := ((↑f a)), property := (((H a))) }) x) =\n  ↑((fun (a : α) ↦ { val := ((↑f a)), property := (((H a))) }) x_1)", "context": ["{α : Sort u_2}", "{β : Type u_1}", "(p : Set β)", "(f : α ↪ β)", "(H : ∀ (a : α), ↑f a ∈ p)", "(x : α)", "(x_1 : α)", "(h : (fun (a : α) ↦ { val := ((↑f a)), property := (((H a))) }) x =\n  (fun (a : α) ↦ { val := ((↑f a)), property := (((H a))) }) x_1)"]}], "ids": ["Function.Embedding.injective", "congr_arg", "Subtype.val"], "idString": "Function.Embedding.injective; congr_arg; Subtype.val; ", "context": []}
{"typeGroup": "(∀ {X : Type u_1} [inst : TopologicalSpace X] (x : X) (t : ↑unitInterval) (x_1 : Path x x) (a : x_1 ∈ {Path.refl x}),\n    (↑(ContinuousMap.mk fun (x_2 : Path x x) ↦\n                ContinuousMap.toFun\n                  (ContinuousMap.Homotopy.toContinuousMap\n                    {\n                      toContinuousMap :=\n                        ((ContinuousMap.mk fun (p : ↑unitInterval × Path x x) ↦\n                          Path.delayReflRight (Prod.fst p) (Prod.snd p))),\n                      map_zero_left :=\n                        (((Path.delayReflRight_zero=:∀ (γ : Path x x),\n                            Path.delayReflRight 0 γ = Path.trans γ (Path.refl x)))),\n                      map_one_left := (((Path.delayReflRight_one=:∀ (γ : Path x x), Path.delayReflRight 1 γ = γ))) })\n                  (t, x_2))\n            x_1 =\n          ↑(ContinuousMap.comp (ContinuousMap.mk fun (ρ : Path x x × Path x x) ↦ Path.trans (Prod.fst ρ) (Prod.snd ρ))\n                (ContinuousMap.prodMk (ContinuousMap.id (Path x x)) (ContinuousMap.const (Path x x) (Path.refl x))))\n            x_1 :\n        Prop) ∧\n      (↑(ContinuousMap.mk fun (x_2 : Path x x) ↦\n                ContinuousMap.toFun\n                  (ContinuousMap.Homotopy.toContinuousMap\n                    {\n                      toContinuousMap :=\n                        ((ContinuousMap.mk fun (p : ↑unitInterval × Path x x) ↦\n                          Path.delayReflRight (Prod.fst p) (Prod.snd p))),\n                      map_zero_left :=\n                        (((Path.delayReflRight_zero=:∀ (γ : Path x x),\n                            Path.delayReflRight 0 γ = Path.trans γ (Path.refl x)))),\n                      map_one_left := (((Path.delayReflRight_one=:∀ (γ : Path x x), Path.delayReflRight 1 γ = γ))) })\n                  (t, x_2))\n            x_1 =\n          ↑(ContinuousMap.id (Path x x)) x_1 :\n        Prop) :\n  Prop)", "type": "∀ {X : Type u_1} [inst : TopologicalSpace X] (x : X) (t : ↑unitInterval) (x_1 : Path x x) (a : x_1 ∈ {Path.refl x}),\n  (↑(ContinuousMap.mk fun (x_2 : Path x x) ↦\n            ContinuousMap.toFun\n              (ContinuousMap.Homotopy.toContinuousMap\n                {\n                  toContinuousMap :=\n                    ((ContinuousMap.mk fun (p : ↑unitInterval × Path x x) ↦\n                      Path.delayReflRight (Prod.fst p) (Prod.snd p))),\n                  map_zero_left := ((Path.delayReflRight_zero)), map_one_left := ((Path.delayReflRight_one)) })\n              (t, x_2))\n        x_1 =\n      ↑(ContinuousMap.comp (ContinuousMap.mk fun (ρ : Path x x × Path x x) ↦ Path.trans (Prod.fst ρ) (Prod.snd ρ))\n            (ContinuousMap.prodMk (ContinuousMap.id (Path x x)) (ContinuousMap.const (Path x x) (Path.refl x))))\n        x_1) ∧\n    (↑(ContinuousMap.mk fun (x_2 : Path x x) ↦\n            ContinuousMap.toFun\n              (ContinuousMap.Homotopy.toContinuousMap\n                {\n                  toContinuousMap :=\n                    ((ContinuousMap.mk fun (p : ↑unitInterval × Path x x) ↦\n                      Path.delayReflRight (Prod.fst p) (Prod.snd p))),\n                  map_zero_left := ((Path.delayReflRight_zero)), map_one_left := ((Path.delayReflRight_one)) })\n              (t, x_2))\n        x_1 =\n      ↑(ContinuousMap.id (Path x x)) x_1)", "thm": " : ∀ {X : Type u_1} [inst : TopologicalSpace X] (x : X) (t : ↑unitInterval) (x_1 : Path x x) (a : x_1 ∈ {Path.refl x}),\n  (↑(ContinuousMap.mk fun (x_2 : Path x x) ↦\n            ContinuousMap.toFun\n              (ContinuousMap.Homotopy.toContinuousMap\n                {\n                  toContinuousMap :=\n                    ((ContinuousMap.mk fun (p : ↑unitInterval × Path x x) ↦\n                      Path.delayReflRight (Prod.fst p) (Prod.snd p))),\n                  map_zero_left := ((Path.delayReflRight_zero)), map_one_left := ((Path.delayReflRight_one)) })\n              (t, x_2))\n        x_1 =\n      ↑(ContinuousMap.comp (ContinuousMap.mk fun (ρ : Path x x × Path x x) ↦ Path.trans (Prod.fst ρ) (Prod.snd ρ))\n            (ContinuousMap.prodMk (ContinuousMap.id (Path x x)) (ContinuousMap.const (Path x x) (Path.refl x))))\n        x_1) ∧\n    (↑(ContinuousMap.mk fun (x_2 : Path x x) ↦\n            ContinuousMap.toFun\n              (ContinuousMap.Homotopy.toContinuousMap\n                {\n                  toContinuousMap :=\n                    ((ContinuousMap.mk fun (p : ↑unitInterval × Path x x) ↦\n                      Path.delayReflRight (Prod.fst p) (Prod.snd p))),\n                  map_zero_left := ((Path.delayReflRight_zero)), map_one_left := ((Path.delayReflRight_one)) })\n              (t, x_2))\n        x_1 =\n      ↑(ContinuousMap.id (Path x x)) x_1)", "terms": [], "namedLemmas": ["∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {α : Sort u} {a b : α}, a = b → b = a", "∀ {X : Type u_1} [inst : TopologicalSpace X] {a : X}, Path.trans (Path.refl a) (Path.refl a) = Path.refl a", "∀ {α : Sort u} {a : α}, a = a"], "lemmas": [{"prop": "Path.refl x = x_1", "context": ["{X : Type u_1}", "[TopologicalSpace X]", "(x : X)", "(t : ↑unitInterval)", "(x_1 : Path x x)", "(a : x_1 ∈ {Path.refl x})"]}, {"prop": "Path.trans (Path.refl x) (Path.refl x) = Path.refl x", "context": ["{X : Type u_1}", "[TopologicalSpace X]", "(x : X)", "(t : ↑unitInterval)", "(x_1 : Path x x)", "(a : x_1 ∈ {Path.refl x})"]}, {"prop": "Path.refl x = Path.trans (Path.refl x) (Path.refl x)", "context": ["{X : Type u_1}", "[TopologicalSpace X]", "(x : X)", "(t : ↑unitInterval)", "(x_1 : Path x x)", "(a : x_1 ∈ {Path.refl x})"]}, {"prop": "↑(ContinuousMap.mk fun (x_2 : Path x x) ↦\n        ContinuousMap.toFun\n          (ContinuousMap.Homotopy.toContinuousMap\n            {\n              toContinuousMap :=\n                ((ContinuousMap.mk fun (p : ↑unitInterval × Path x x) ↦ Path.delayReflRight (Prod.fst p) (Prod.snd p))),\n              map_zero_left := ((Path.delayReflRight_zero)), map_one_left := ((Path.delayReflRight_one)) })\n          (t, x_2))\n    (Path.refl x) =\n  ↑(ContinuousMap.mk fun (x_2 : Path x x) ↦\n        ContinuousMap.toFun\n          (ContinuousMap.Homotopy.toContinuousMap\n            {\n              toContinuousMap :=\n                ((ContinuousMap.mk fun (p : ↑unitInterval × Path x x) ↦ Path.delayReflRight (Prod.fst p) (Prod.snd p))),\n              map_zero_left := ((Path.delayReflRight_zero)), map_one_left := ((Path.delayReflRight_one)) })\n          (t, x_2))\n    (Path.refl x)", "context": ["{X : Type u_1}", "[TopologicalSpace X]", "(x : X)", "(t : ↑unitInterval)", "(x_1 : Path x x)", "(a : x_1 ∈ {Path.refl x})"]}, {"prop": "(↑(ContinuousMap.mk fun (x_2 : Path x x) ↦\n          ContinuousMap.toFun\n            (ContinuousMap.Homotopy.toContinuousMap\n              {\n                toContinuousMap :=\n                  ((ContinuousMap.mk fun (p : ↑unitInterval × Path x x) ↦\n                    Path.delayReflRight (Prod.fst p) (Prod.snd p))),\n                map_zero_left := ((Path.delayReflRight_zero)), map_one_left := ((Path.delayReflRight_one)) })\n            (t, x_2))\n      (Path.refl x) =\n    ↑(ContinuousMap.comp (ContinuousMap.mk fun (ρ : Path x x × Path x x) ↦ Path.trans (Prod.fst ρ) (Prod.snd ρ))\n          (ContinuousMap.prodMk (ContinuousMap.id (Path x x)) (ContinuousMap.const (Path x x) (Path.refl x))))\n      (Path.refl x)) ∧\n  (↑(ContinuousMap.mk fun (x_2 : Path x x) ↦\n          ContinuousMap.toFun\n            (ContinuousMap.Homotopy.toContinuousMap\n              {\n                toContinuousMap :=\n                  ((ContinuousMap.mk fun (p : ↑unitInterval × Path x x) ↦\n                    Path.delayReflRight (Prod.fst p) (Prod.snd p))),\n                map_zero_left := ((Path.delayReflRight_zero)), map_one_left := ((Path.delayReflRight_one)) })\n            (t, x_2))\n      (Path.refl x) =\n    ↑(ContinuousMap.id (Path x x)) (Path.refl x))", "context": ["{X : Type u_1}", "[TopologicalSpace X]", "(x : X)", "(t : ↑unitInterval)", "(x_1 : Path x x)", "(a : x_1 ∈ {Path.refl x})"]}], "ids": ["Eq.symm", "left", "Eq.symm", "Path.refl_trans_refl", "right", "rfl"], "idString": "Eq.symm; left; Eq.symm; Path.refl_trans_refl; right; rfl; ", "context": []}
